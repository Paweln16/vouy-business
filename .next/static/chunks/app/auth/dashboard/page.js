/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/auth/dashboard/page"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fpawelniedzwiedz%2FDesktop%2Fvouy-business%2Fsrc%2Fapp%2Fauth%2Fdashboard%2FRevenue%2FRevenue.tsx%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=false!":
/*!*****************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fpawelniedzwiedz%2FDesktop%2Fvouy-business%2Fsrc%2Fapp%2Fauth%2Fdashboard%2FRevenue%2FRevenue.tsx%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=false! ***!
  \*****************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/auth/dashboard/Revenue/Revenue.tsx */ \"(app-pages-browser)/./src/app/auth/dashboard/Revenue/Revenue.tsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGVXNlcnMlMkZwYXdlbG5pZWR6d2llZHolMkZEZXNrdG9wJTJGdm91eS1idXNpbmVzcyUyRnNyYyUyRmFwcCUyRmF1dGglMkZkYXNoYm9hcmQlMkZSZXZlbnVlJTJGUmV2ZW51ZS50c3glMjIlMkMlMjJpZHMlMjIlM0ElNUIlMjJkZWZhdWx0JTIyJTVEJTdEJnNlcnZlcj1mYWxzZSEiLCJtYXBwaW5ncyI6IkFBQUEsa05BQXlKIiwic291cmNlcyI6WyIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIsIHdlYnBhY2tFeHBvcnRzOiBbXCJkZWZhdWx0XCJdICovIFwiL1VzZXJzL3Bhd2VsbmllZHp3aWVkei9EZXNrdG9wL3ZvdXktYnVzaW5lc3Mvc3JjL2FwcC9hdXRoL2Rhc2hib2FyZC9SZXZlbnVlL1JldmVudWUudHN4XCIpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fpawelniedzwiedz%2FDesktop%2Fvouy-business%2Fsrc%2Fapp%2Fauth%2Fdashboard%2FRevenue%2FRevenue.tsx%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/auth/dashboard/Revenue/Revenue.tsx":
/*!****************************************************!*\
  !*** ./src/app/auth/dashboard/Revenue/Revenue.tsx ***!
  \****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Revenue)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var ag_charts_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ag-charts-react */ \"(app-pages-browser)/./node_modules/ag-charts-react/dist/package/index.esm.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\nfunction Revenue() {\n    _s();\n    const [options, setOptions] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)({\n        title: {\n            text: \"Acme's Inc Income\"\n        },\n        data: [\n            {\n                month: \"Jan\",\n                income: 2.3\n            },\n            {\n                month: \"Feb\",\n                income: 4.3\n            },\n            {\n                month: \"Mar\",\n                income: 5.3\n            },\n            {\n                month: \"Apr\",\n                income: 1.3\n            },\n            {\n                month: \"May\",\n                income: 2.3\n            },\n            {\n                month: \"Jun\",\n                income: 6.3\n            },\n            {\n                month: \"Jul\",\n                income: 8.3\n            },\n            {\n                month: \"Sep\",\n                income: 8.3\n            },\n            {\n                month: \"Oct\",\n                income: 5.3\n            },\n            {\n                month: \"Nov\",\n                income: 3.3\n            },\n            {\n                month: \"Dec\",\n                income: 2.3\n            }\n        ],\n        series: [\n            {\n                type: \"bar\",\n                xKey: \"month\",\n                yKey: \"income\",\n                yName: \"Income\"\n            }\n        ]\n    });\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"h-[50%] w-full border-[1px] rounded-[10px] p-[10px] z-0\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ag_charts_react__WEBPACK_IMPORTED_MODULE_1__.AgCharts, {\n            className: \"h-full w-full z-1\",\n            options: options\n        }, void 0, false, {\n            fileName: \"/Users/pawelniedzwiedz/Desktop/vouy-business/src/app/auth/dashboard/Revenue/Revenue.tsx\",\n            lineNumber: 36,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Users/pawelniedzwiedz/Desktop/vouy-business/src/app/auth/dashboard/Revenue/Revenue.tsx\",\n        lineNumber: 35,\n        columnNumber: 5\n    }, this);\n}\n_s(Revenue, \"AxIvsj2PZPeHkQoaVF1Qz6tPjUI=\");\n_c = Revenue;\nvar _c;\n$RefreshReg$(_c, \"Revenue\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvYXV0aC9kYXNoYm9hcmQvUmV2ZW51ZS9SZXZlbnVlLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQzJDO0FBQ1Y7QUFHbEIsU0FBU0U7O0lBQ3RCLE1BQU0sQ0FBQ0MsU0FBU0MsV0FBVyxHQUFHSCwrQ0FBUUEsQ0FBaUI7UUFDckRJLE9BQU87WUFDTEMsTUFBTTtRQUNSO1FBQ0FDLE1BQU07WUFDSjtnQkFBRUMsT0FBTztnQkFBT0MsUUFBUTtZQUFJO1lBQzVCO2dCQUFFRCxPQUFPO2dCQUFPQyxRQUFRO1lBQUk7WUFDNUI7Z0JBQUVELE9BQU87Z0JBQU9DLFFBQVE7WUFBSTtZQUM1QjtnQkFBRUQsT0FBTztnQkFBT0MsUUFBUTtZQUFJO1lBQzVCO2dCQUFFRCxPQUFPO2dCQUFPQyxRQUFRO1lBQUk7WUFDNUI7Z0JBQUVELE9BQU87Z0JBQU9DLFFBQVE7WUFBSTtZQUM1QjtnQkFBRUQsT0FBTztnQkFBT0MsUUFBUTtZQUFJO1lBQzVCO2dCQUFFRCxPQUFPO2dCQUFPQyxRQUFRO1lBQUk7WUFDNUI7Z0JBQUVELE9BQU87Z0JBQU9DLFFBQVE7WUFBSTtZQUM1QjtnQkFBRUQsT0FBTztnQkFBT0MsUUFBUTtZQUFJO1lBQzVCO2dCQUFFRCxPQUFPO2dCQUFPQyxRQUFRO1lBQUk7U0FDN0I7UUFDREMsUUFBUTtZQUNOO2dCQUNFQyxNQUFNO2dCQUNOQyxNQUFNO2dCQUNOQyxNQUFNO2dCQUNOQyxPQUFPO1lBQ1Q7U0FDRDtJQUNIO0lBRUEscUJBQ0UsOERBQUNDO1FBQUlDLFdBQVU7a0JBQ2IsNEVBQUNoQixxREFBUUE7WUFBQ2dCLFdBQVU7WUFBb0JiLFNBQVNBOzs7Ozs7Ozs7OztBQUd2RDtHQWpDd0JEO0tBQUFBIiwic291cmNlcyI6WyIvVXNlcnMvcGF3ZWxuaWVkendpZWR6L0Rlc2t0b3Avdm91eS1idXNpbmVzcy9zcmMvYXBwL2F1dGgvZGFzaGJvYXJkL1JldmVudWUvUmV2ZW51ZS50c3giXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5pbXBvcnQgeyBBZ0NoYXJ0cyB9IGZyb20gXCJhZy1jaGFydHMtcmVhY3RcIjtcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBBZ0NoYXJ0T3B0aW9ucyB9IGZyb20gXCJhZy1jaGFydHMtY29tbXVuaXR5XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFJldmVudWUoKSB7XG4gIGNvbnN0IFtvcHRpb25zLCBzZXRPcHRpb25zXSA9IHVzZVN0YXRlPEFnQ2hhcnRPcHRpb25zPih7XG4gICAgdGl0bGU6IHtcbiAgICAgIHRleHQ6IFwiQWNtZSdzIEluYyBJbmNvbWVcIixcbiAgICB9LFxuICAgIGRhdGE6IFtcbiAgICAgIHsgbW9udGg6IFwiSmFuXCIsIGluY29tZTogMi4zIH0sXG4gICAgICB7IG1vbnRoOiBcIkZlYlwiLCBpbmNvbWU6IDQuMyB9LFxuICAgICAgeyBtb250aDogXCJNYXJcIiwgaW5jb21lOiA1LjMgfSxcbiAgICAgIHsgbW9udGg6IFwiQXByXCIsIGluY29tZTogMS4zIH0sXG4gICAgICB7IG1vbnRoOiBcIk1heVwiLCBpbmNvbWU6IDIuMyB9LFxuICAgICAgeyBtb250aDogXCJKdW5cIiwgaW5jb21lOiA2LjMgfSxcbiAgICAgIHsgbW9udGg6IFwiSnVsXCIsIGluY29tZTogOC4zIH0sXG4gICAgICB7IG1vbnRoOiBcIlNlcFwiLCBpbmNvbWU6IDguMyB9LFxuICAgICAgeyBtb250aDogXCJPY3RcIiwgaW5jb21lOiA1LjMgfSxcbiAgICAgIHsgbW9udGg6IFwiTm92XCIsIGluY29tZTogMy4zIH0sXG4gICAgICB7IG1vbnRoOiBcIkRlY1wiLCBpbmNvbWU6IDIuMyB9LFxuICAgIF0sXG4gICAgc2VyaWVzOiBbXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwiYmFyXCIsXG4gICAgICAgIHhLZXk6IFwibW9udGhcIixcbiAgICAgICAgeUtleTogXCJpbmNvbWVcIixcbiAgICAgICAgeU5hbWU6IFwiSW5jb21lXCIsXG4gICAgICB9LFxuICAgIF0sXG4gIH0pO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJoLVs1MCVdIHctZnVsbCBib3JkZXItWzFweF0gcm91bmRlZC1bMTBweF0gcC1bMTBweF0gei0wXCI+XG4gICAgICA8QWdDaGFydHMgY2xhc3NOYW1lPVwiaC1mdWxsIHctZnVsbCB6LTFcIiBvcHRpb25zPXtvcHRpb25zfSAvPlxuICAgIDwvZGl2PlxuICApO1xufVxuIl0sIm5hbWVzIjpbIkFnQ2hhcnRzIiwidXNlU3RhdGUiLCJSZXZlbnVlIiwib3B0aW9ucyIsInNldE9wdGlvbnMiLCJ0aXRsZSIsInRleHQiLCJkYXRhIiwibW9udGgiLCJpbmNvbWUiLCJzZXJpZXMiLCJ0eXBlIiwieEtleSIsInlLZXkiLCJ5TmFtZSIsImRpdiIsImNsYXNzTmFtZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/auth/dashboard/Revenue/Revenue.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE$2\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PORTAL_TYPE:\n          return \"Portal\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_CONTEXT_TYPE:\n            return (type.displayName || \"Context\") + \".Provider\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkKeyStringCoercion(value) {\n      try {\n        testStringCoercion(value);\n        var JSCompiler_inline_result = !1;\n      } catch (e) {\n        JSCompiler_inline_result = !0;\n      }\n      if (JSCompiler_inline_result) {\n        JSCompiler_inline_result = console;\n        var JSCompiler_temp_const = JSCompiler_inline_result.error;\n        var JSCompiler_inline_result$jscomp$0 =\n          (\"function\" === typeof Symbol &&\n            Symbol.toStringTag &&\n            value[Symbol.toStringTag]) ||\n          value.constructor.name ||\n          \"Object\";\n        JSCompiler_temp_const.call(\n          JSCompiler_inline_result,\n          \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          JSCompiler_inline_result$jscomp$0\n        );\n        return testStringCoercion(value);\n      }\n    }\n    function disabledLog() {}\n    function disableLogs() {\n      if (0 === disabledDepth) {\n        prevLog = console.log;\n        prevInfo = console.info;\n        prevWarn = console.warn;\n        prevError = console.error;\n        prevGroup = console.group;\n        prevGroupCollapsed = console.groupCollapsed;\n        prevGroupEnd = console.groupEnd;\n        var props = {\n          configurable: !0,\n          enumerable: !0,\n          value: disabledLog,\n          writable: !0\n        };\n        Object.defineProperties(console, {\n          info: props,\n          log: props,\n          warn: props,\n          error: props,\n          group: props,\n          groupCollapsed: props,\n          groupEnd: props\n        });\n      }\n      disabledDepth++;\n    }\n    function reenableLogs() {\n      disabledDepth--;\n      if (0 === disabledDepth) {\n        var props = { configurable: !0, enumerable: !0, writable: !0 };\n        Object.defineProperties(console, {\n          log: assign({}, props, { value: prevLog }),\n          info: assign({}, props, { value: prevInfo }),\n          warn: assign({}, props, { value: prevWarn }),\n          error: assign({}, props, { value: prevError }),\n          group: assign({}, props, { value: prevGroup }),\n          groupCollapsed: assign({}, props, { value: prevGroupCollapsed }),\n          groupEnd: assign({}, props, { value: prevGroupEnd })\n        });\n      }\n      0 > disabledDepth &&\n        console.error(\n          \"disabledDepth fell below zero. This is a bug in React. Please file an issue.\"\n        );\n    }\n    function describeBuiltInComponentFrame(name) {\n      if (void 0 === prefix)\n        try {\n          throw Error();\n        } catch (x) {\n          var match = x.stack.trim().match(/\\n( *(at )?)/);\n          prefix = (match && match[1]) || \"\";\n          suffix =\n            -1 < x.stack.indexOf(\"\\n    at\")\n              ? \" (<anonymous>)\"\n              : -1 < x.stack.indexOf(\"@\")\n                ? \"@unknown:0:0\"\n                : \"\";\n        }\n      return \"\\n\" + prefix + name + suffix;\n    }\n    function describeNativeComponentFrame(fn, construct) {\n      if (!fn || reentry) return \"\";\n      var frame = componentFrameCache.get(fn);\n      if (void 0 !== frame) return frame;\n      reentry = !0;\n      frame = Error.prepareStackTrace;\n      Error.prepareStackTrace = void 0;\n      var previousDispatcher = null;\n      previousDispatcher = ReactSharedInternals.H;\n      ReactSharedInternals.H = null;\n      disableLogs();\n      try {\n        var RunInRootFrame = {\n          DetermineComponentFrameRoot: function () {\n            try {\n              if (construct) {\n                var Fake = function () {\n                  throw Error();\n                };\n                Object.defineProperty(Fake.prototype, \"props\", {\n                  set: function () {\n                    throw Error();\n                  }\n                });\n                if (\"object\" === typeof Reflect && Reflect.construct) {\n                  try {\n                    Reflect.construct(Fake, []);\n                  } catch (x) {\n                    var control = x;\n                  }\n                  Reflect.construct(fn, [], Fake);\n                } else {\n                  try {\n                    Fake.call();\n                  } catch (x$0) {\n                    control = x$0;\n                  }\n                  fn.call(Fake.prototype);\n                }\n              } else {\n                try {\n                  throw Error();\n                } catch (x$1) {\n                  control = x$1;\n                }\n                (Fake = fn()) &&\n                  \"function\" === typeof Fake.catch &&\n                  Fake.catch(function () {});\n              }\n            } catch (sample) {\n              if (sample && control && \"string\" === typeof sample.stack)\n                return [sample.stack, control.stack];\n            }\n            return [null, null];\n          }\n        };\n        RunInRootFrame.DetermineComponentFrameRoot.displayName =\n          \"DetermineComponentFrameRoot\";\n        var namePropDescriptor = Object.getOwnPropertyDescriptor(\n          RunInRootFrame.DetermineComponentFrameRoot,\n          \"name\"\n        );\n        namePropDescriptor &&\n          namePropDescriptor.configurable &&\n          Object.defineProperty(\n            RunInRootFrame.DetermineComponentFrameRoot,\n            \"name\",\n            { value: \"DetermineComponentFrameRoot\" }\n          );\n        var _RunInRootFrame$Deter =\n            RunInRootFrame.DetermineComponentFrameRoot(),\n          sampleStack = _RunInRootFrame$Deter[0],\n          controlStack = _RunInRootFrame$Deter[1];\n        if (sampleStack && controlStack) {\n          var sampleLines = sampleStack.split(\"\\n\"),\n            controlLines = controlStack.split(\"\\n\");\n          for (\n            _RunInRootFrame$Deter = namePropDescriptor = 0;\n            namePropDescriptor < sampleLines.length &&\n            !sampleLines[namePropDescriptor].includes(\n              \"DetermineComponentFrameRoot\"\n            );\n\n          )\n            namePropDescriptor++;\n          for (\n            ;\n            _RunInRootFrame$Deter < controlLines.length &&\n            !controlLines[_RunInRootFrame$Deter].includes(\n              \"DetermineComponentFrameRoot\"\n            );\n\n          )\n            _RunInRootFrame$Deter++;\n          if (\n            namePropDescriptor === sampleLines.length ||\n            _RunInRootFrame$Deter === controlLines.length\n          )\n            for (\n              namePropDescriptor = sampleLines.length - 1,\n                _RunInRootFrame$Deter = controlLines.length - 1;\n              1 <= namePropDescriptor &&\n              0 <= _RunInRootFrame$Deter &&\n              sampleLines[namePropDescriptor] !==\n                controlLines[_RunInRootFrame$Deter];\n\n            )\n              _RunInRootFrame$Deter--;\n          for (\n            ;\n            1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter;\n            namePropDescriptor--, _RunInRootFrame$Deter--\n          )\n            if (\n              sampleLines[namePropDescriptor] !==\n              controlLines[_RunInRootFrame$Deter]\n            ) {\n              if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {\n                do\n                  if (\n                    (namePropDescriptor--,\n                    _RunInRootFrame$Deter--,\n                    0 > _RunInRootFrame$Deter ||\n                      sampleLines[namePropDescriptor] !==\n                        controlLines[_RunInRootFrame$Deter])\n                  ) {\n                    var _frame =\n                      \"\\n\" +\n                      sampleLines[namePropDescriptor].replace(\n                        \" at new \",\n                        \" at \"\n                      );\n                    fn.displayName &&\n                      _frame.includes(\"<anonymous>\") &&\n                      (_frame = _frame.replace(\"<anonymous>\", fn.displayName));\n                    \"function\" === typeof fn &&\n                      componentFrameCache.set(fn, _frame);\n                    return _frame;\n                  }\n                while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);\n              }\n              break;\n            }\n        }\n      } finally {\n        (reentry = !1),\n          (ReactSharedInternals.H = previousDispatcher),\n          reenableLogs(),\n          (Error.prepareStackTrace = frame);\n      }\n      sampleLines = (sampleLines = fn ? fn.displayName || fn.name : \"\")\n        ? describeBuiltInComponentFrame(sampleLines)\n        : \"\";\n      \"function\" === typeof fn && componentFrameCache.set(fn, sampleLines);\n      return sampleLines;\n    }\n    function describeUnknownElementTypeFrameInDEV(type) {\n      if (null == type) return \"\";\n      if (\"function\" === typeof type) {\n        var prototype = type.prototype;\n        return describeNativeComponentFrame(\n          type,\n          !(!prototype || !prototype.isReactComponent)\n        );\n      }\n      if (\"string\" === typeof type) return describeBuiltInComponentFrame(type);\n      switch (type) {\n        case REACT_SUSPENSE_TYPE:\n          return describeBuiltInComponentFrame(\"Suspense\");\n        case REACT_SUSPENSE_LIST_TYPE:\n          return describeBuiltInComponentFrame(\"SuspenseList\");\n      }\n      if (\"object\" === typeof type)\n        switch (type.$$typeof) {\n          case REACT_FORWARD_REF_TYPE:\n            return (type = describeNativeComponentFrame(type.render, !1)), type;\n          case REACT_MEMO_TYPE:\n            return describeUnknownElementTypeFrameInDEV(type.type);\n          case REACT_LAZY_TYPE:\n            prototype = type._payload;\n            type = type._init;\n            try {\n              return describeUnknownElementTypeFrameInDEV(type(prototype));\n            } catch (x) {}\n        }\n      return \"\";\n    }\n    function getOwner() {\n      var dispatcher = ReactSharedInternals.A;\n      return null === dispatcher ? null : dispatcher.getOwner();\n    }\n    function hasValidKey(config) {\n      if (hasOwnProperty.call(config, \"key\")) {\n        var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n        if (getter && getter.isReactWarning) return !1;\n      }\n      return void 0 !== config.key;\n    }\n    function defineKeyPropWarningGetter(props, displayName) {\n      function warnAboutAccessingKey() {\n        specialPropKeyWarningShown ||\n          ((specialPropKeyWarningShown = !0),\n          console.error(\n            \"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\",\n            displayName\n          ));\n      }\n      warnAboutAccessingKey.isReactWarning = !0;\n      Object.defineProperty(props, \"key\", {\n        get: warnAboutAccessingKey,\n        configurable: !0\n      });\n    }\n    function elementRefGetterWithDeprecationWarning() {\n      var componentName = getComponentNameFromType(this.type);\n      didWarnAboutElementRef[componentName] ||\n        ((didWarnAboutElementRef[componentName] = !0),\n        console.error(\n          \"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"\n        ));\n      componentName = this.props.ref;\n      return void 0 !== componentName ? componentName : null;\n    }\n    function ReactElement(type, key, self, source, owner, props) {\n      self = props.ref;\n      type = {\n        $$typeof: REACT_ELEMENT_TYPE,\n        type: type,\n        key: key,\n        props: props,\n        _owner: owner\n      };\n      null !== (void 0 !== self ? self : null)\n        ? Object.defineProperty(type, \"ref\", {\n            enumerable: !1,\n            get: elementRefGetterWithDeprecationWarning\n          })\n        : Object.defineProperty(type, \"ref\", { enumerable: !1, value: null });\n      type._store = {};\n      Object.defineProperty(type._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: 0\n      });\n      Object.defineProperty(type, \"_debugInfo\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: null\n      });\n      Object.freeze && (Object.freeze(type.props), Object.freeze(type));\n      return type;\n    }\n    function jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self\n    ) {\n      if (\n        \"string\" === typeof type ||\n        \"function\" === typeof type ||\n        type === REACT_FRAGMENT_TYPE ||\n        type === REACT_PROFILER_TYPE ||\n        type === REACT_STRICT_MODE_TYPE ||\n        type === REACT_SUSPENSE_TYPE ||\n        type === REACT_SUSPENSE_LIST_TYPE ||\n        type === REACT_OFFSCREEN_TYPE ||\n        (\"object\" === typeof type &&\n          null !== type &&\n          (type.$$typeof === REACT_LAZY_TYPE ||\n            type.$$typeof === REACT_MEMO_TYPE ||\n            type.$$typeof === REACT_CONTEXT_TYPE ||\n            type.$$typeof === REACT_CONSUMER_TYPE ||\n            type.$$typeof === REACT_FORWARD_REF_TYPE ||\n            type.$$typeof === REACT_CLIENT_REFERENCE$1 ||\n            void 0 !== type.getModuleId))\n      ) {\n        var children = config.children;\n        if (void 0 !== children)\n          if (isStaticChildren)\n            if (isArrayImpl(children)) {\n              for (\n                isStaticChildren = 0;\n                isStaticChildren < children.length;\n                isStaticChildren++\n              )\n                validateChildKeys(children[isStaticChildren], type);\n              Object.freeze && Object.freeze(children);\n            } else\n              console.error(\n                \"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\"\n              );\n          else validateChildKeys(children, type);\n      } else {\n        children = \"\";\n        if (\n          void 0 === type ||\n          (\"object\" === typeof type &&\n            null !== type &&\n            0 === Object.keys(type).length)\n        )\n          children +=\n            \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\";\n        null === type\n          ? (isStaticChildren = \"null\")\n          : isArrayImpl(type)\n            ? (isStaticChildren = \"array\")\n            : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE\n              ? ((isStaticChildren =\n                  \"<\" +\n                  (getComponentNameFromType(type.type) || \"Unknown\") +\n                  \" />\"),\n                (children =\n                  \" Did you accidentally export a JSX literal instead of a component?\"))\n              : (isStaticChildren = typeof type);\n        console.error(\n          \"React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\",\n          isStaticChildren,\n          children\n        );\n      }\n      if (hasOwnProperty.call(config, \"key\")) {\n        children = getComponentNameFromType(type);\n        var keys = Object.keys(config).filter(function (k) {\n          return \"key\" !== k;\n        });\n        isStaticChildren =\n          0 < keys.length\n            ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\"\n            : \"{key: someKey}\";\n        didWarnAboutKeySpread[children + isStaticChildren] ||\n          ((keys =\n            0 < keys.length ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\"),\n          console.error(\n            'A props object containing a \"key\" prop is being spread into JSX:\\n  let props = %s;\\n  <%s {...props} />\\nReact keys must be passed directly to JSX without using spread:\\n  let props = %s;\\n  <%s key={someKey} {...props} />',\n            isStaticChildren,\n            children,\n            keys,\n            children\n          ),\n          (didWarnAboutKeySpread[children + isStaticChildren] = !0));\n      }\n      children = null;\n      void 0 !== maybeKey &&\n        (checkKeyStringCoercion(maybeKey), (children = \"\" + maybeKey));\n      hasValidKey(config) &&\n        (checkKeyStringCoercion(config.key), (children = \"\" + config.key));\n      if (\"key\" in config) {\n        maybeKey = {};\n        for (var propName in config)\n          \"key\" !== propName && (maybeKey[propName] = config[propName]);\n      } else maybeKey = config;\n      children &&\n        defineKeyPropWarningGetter(\n          maybeKey,\n          \"function\" === typeof type\n            ? type.displayName || type.name || \"Unknown\"\n            : type\n        );\n      return ReactElement(type, children, self, source, getOwner(), maybeKey);\n    }\n    function validateChildKeys(node, parentType) {\n      if (\n        \"object\" === typeof node &&\n        node &&\n        node.$$typeof !== REACT_CLIENT_REFERENCE\n      )\n        if (isArrayImpl(node))\n          for (var i = 0; i < node.length; i++) {\n            var child = node[i];\n            isValidElement(child) && validateExplicitKey(child, parentType);\n          }\n        else if (isValidElement(node))\n          node._store && (node._store.validated = 1);\n        else if (\n          (null === node || \"object\" !== typeof node\n            ? (i = null)\n            : ((i =\n                (MAYBE_ITERATOR_SYMBOL && node[MAYBE_ITERATOR_SYMBOL]) ||\n                node[\"@@iterator\"]),\n              (i = \"function\" === typeof i ? i : null)),\n          \"function\" === typeof i &&\n            i !== node.entries &&\n            ((i = i.call(node)), i !== node))\n        )\n          for (; !(node = i.next()).done; )\n            isValidElement(node.value) &&\n              validateExplicitKey(node.value, parentType);\n    }\n    function isValidElement(object) {\n      return (\n        \"object\" === typeof object &&\n        null !== object &&\n        object.$$typeof === REACT_ELEMENT_TYPE\n      );\n    }\n    function validateExplicitKey(element, parentType) {\n      if (\n        element._store &&\n        !element._store.validated &&\n        null == element.key &&\n        ((element._store.validated = 1),\n        (parentType = getCurrentComponentErrorInfo(parentType)),\n        !ownerHasKeyUseWarning[parentType])\n      ) {\n        ownerHasKeyUseWarning[parentType] = !0;\n        var childOwner = \"\";\n        element &&\n          null != element._owner &&\n          element._owner !== getOwner() &&\n          ((childOwner = null),\n          \"number\" === typeof element._owner.tag\n            ? (childOwner = getComponentNameFromType(element._owner.type))\n            : \"string\" === typeof element._owner.name &&\n              (childOwner = element._owner.name),\n          (childOwner = \" It was passed a child from \" + childOwner + \".\"));\n        var prevGetCurrentStack = ReactSharedInternals.getCurrentStack;\n        ReactSharedInternals.getCurrentStack = function () {\n          var stack = describeUnknownElementTypeFrameInDEV(element.type);\n          prevGetCurrentStack && (stack += prevGetCurrentStack() || \"\");\n          return stack;\n        };\n        console.error(\n          'Each child in a list should have a unique \"key\" prop.%s%s See https://react.dev/link/warning-keys for more information.',\n          parentType,\n          childOwner\n        );\n        ReactSharedInternals.getCurrentStack = prevGetCurrentStack;\n      }\n    }\n    function getCurrentComponentErrorInfo(parentType) {\n      var info = \"\",\n        owner = getOwner();\n      owner &&\n        (owner = getComponentNameFromType(owner.type)) &&\n        (info = \"\\n\\nCheck the render method of `\" + owner + \"`.\");\n      info ||\n        ((parentType = getComponentNameFromType(parentType)) &&\n          (info =\n            \"\\n\\nCheck the top-level render call using <\" + parentType + \">.\"));\n      return info;\n    }\n    var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"),\n      REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n    Symbol.for(\"react.provider\");\n    var REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\"),\n      MAYBE_ITERATOR_SYMBOL = Symbol.iterator,\n      REACT_CLIENT_REFERENCE$2 = Symbol.for(\"react.client.reference\"),\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      assign = Object.assign,\n      REACT_CLIENT_REFERENCE$1 = Symbol.for(\"react.client.reference\"),\n      isArrayImpl = Array.isArray,\n      disabledDepth = 0,\n      prevLog,\n      prevInfo,\n      prevWarn,\n      prevError,\n      prevGroup,\n      prevGroupCollapsed,\n      prevGroupEnd;\n    disabledLog.__reactDisabledLog = !0;\n    var prefix,\n      suffix,\n      reentry = !1;\n    var componentFrameCache = new (\n      \"function\" === typeof WeakMap ? WeakMap : Map\n    )();\n    var REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      specialPropKeyWarningShown;\n    var didWarnAboutElementRef = {};\n    var didWarnAboutKeySpread = {},\n      ownerHasKeyUseWarning = {};\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.jsxDEV = function (\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self\n    ) {\n      return jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self);\n    };\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYixLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHdCQUF3QixXQUFXLGdCQUFnQjtBQUNuRCx5QkFBeUIsV0FBVyxpQkFBaUI7QUFDckQseUJBQXlCLFdBQVcsaUJBQWlCO0FBQ3JELDBCQUEwQixXQUFXLGtCQUFrQjtBQUN2RCwwQkFBMEIsV0FBVyxrQkFBa0I7QUFDdkQsbUNBQW1DLFdBQVcsMkJBQTJCO0FBQ3pFLDZCQUE2QixXQUFXLHFCQUFxQjtBQUM3RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsK0NBQStDLDZCQUE2QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQkFBZ0IsZ0RBQWdEO0FBQ2hFLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQSxnQ0FBZ0Msa0NBQWtDLE9BQU87QUFDekU7QUFDQSxnR0FBZ0csU0FBUyxVQUFVLHNGQUFzRixhQUFhLFVBQVUsVUFBVTtBQUMxTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseUJBQXlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxzR0FBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxJQUFJLGdCQUFnQjtBQUNwQixJQUFJLGNBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyIsInNvdXJjZXMiOlsiL1VzZXJzL3Bhd2VsbmllZHp3aWVkei9EZXNrdG9wL3ZvdXktYnVzaW5lc3Mvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgJiZcbiAgKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkge1xuICAgICAgaWYgKG51bGwgPT0gdHlwZSkgcmV0dXJuIG51bGw7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgcmV0dXJuIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMlxuICAgICAgICAgID8gbnVsbFxuICAgICAgICAgIDogdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSkgcmV0dXJuIHR5cGU7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIkZyYWdtZW50XCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiUG9ydGFsXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJQcm9maWxlclwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiU3RyaWN0TW9kZVwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VMaXN0XCI7XG4gICAgICB9XG4gICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHN3aXRjaCAoXG4gICAgICAgICAgKFwibnVtYmVyXCIgPT09IHR5cGVvZiB0eXBlLnRhZyAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoKS4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgIHR5cGUuJCR0eXBlb2YpXG4gICAgICAgICkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuICh0eXBlLmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiKSArIFwiLlByb3ZpZGVyXCI7XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuICh0eXBlLl9jb250ZXh0LmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiKSArIFwiLkNvbnN1bWVyXCI7XG4gICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgdmFyIGlubmVyVHlwZSA9IHR5cGUucmVuZGVyO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuZGlzcGxheU5hbWU7XG4gICAgICAgICAgICB0eXBlIHx8XG4gICAgICAgICAgICAgICgodHlwZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCBcIlwiKSxcbiAgICAgICAgICAgICAgKHR5cGUgPSBcIlwiICE9PSB0eXBlID8gXCJGb3J3YXJkUmVmKFwiICsgdHlwZSArIFwiKVwiIDogXCJGb3J3YXJkUmVmXCIpKTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKGlubmVyVHlwZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgbnVsbCksXG4gICAgICAgICAgICAgIG51bGwgIT09IGlubmVyVHlwZVxuICAgICAgICAgICAgICAgID8gaW5uZXJUeXBlXG4gICAgICAgICAgICAgICAgOiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCBcIk1lbW9cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgIGlubmVyVHlwZSA9IHR5cGUuX3BheWxvYWQ7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS5faW5pdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZShpbm5lclR5cGUpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITA7XG4gICAgICB9XG4gICAgICBpZiAoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0KSB7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IGNvbnNvbGU7XG4gICAgICAgIHZhciBKU0NvbXBpbGVyX3RlbXBfY29uc3QgPSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQuZXJyb3I7XG4gICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDAgPVxuICAgICAgICAgIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBTeW1ib2wgJiZcbiAgICAgICAgICAgIFN5bWJvbC50b1N0cmluZ1RhZyAmJlxuICAgICAgICAgICAgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSkgfHxcbiAgICAgICAgICB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8XG4gICAgICAgICAgXCJPYmplY3RcIjtcbiAgICAgICAgSlNDb21waWxlcl90ZW1wX2NvbnN0LmNhbGwoXG4gICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LFxuICAgICAgICAgIFwiVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLiBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS5cIixcbiAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDBcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cbiAgICBmdW5jdGlvbiBkaXNhYmxlTG9ncygpIHtcbiAgICAgIGlmICgwID09PSBkaXNhYmxlZERlcHRoKSB7XG4gICAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcbiAgICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xuICAgICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kO1xuICAgICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICB2YWx1ZTogZGlzYWJsZWRMb2csXG4gICAgICAgICAgd3JpdGFibGU6ICEwXG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGRpc2FibGVkRGVwdGgrKztcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICAgICAgZGlzYWJsZWREZXB0aC0tO1xuICAgICAgaWYgKDAgPT09IGRpc2FibGVkRGVwdGgpIHtcbiAgICAgICAgdmFyIHByb3BzID0geyBjb25maWd1cmFibGU6ICEwLCBlbnVtZXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZMb2cgfSksXG4gICAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkluZm8gfSksXG4gICAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldldhcm4gfSksXG4gICAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZFcnJvciB9KSxcbiAgICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkdyb3VwIH0pLFxuICAgICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWQgfSksXG4gICAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZHcm91cEVuZCB9KVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIDAgPiBkaXNhYmxlZERlcHRoICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkge1xuICAgICAgaWYgKHZvaWQgMCA9PT0gcHJlZml4KVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICAgIHByZWZpeCA9IChtYXRjaCAmJiBtYXRjaFsxXSkgfHwgXCJcIjtcbiAgICAgICAgICBzdWZmaXggPVxuICAgICAgICAgICAgLTEgPCB4LnN0YWNrLmluZGV4T2YoXCJcXG4gICAgYXRcIilcbiAgICAgICAgICAgICAgPyBcIiAoPGFub255bW91cz4pXCJcbiAgICAgICAgICAgICAgOiAtMSA8IHguc3RhY2suaW5kZXhPZihcIkBcIilcbiAgICAgICAgICAgICAgICA/IFwiQHVua25vd246MDowXCJcbiAgICAgICAgICAgICAgICA6IFwiXCI7XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBcIlxcblwiICsgcHJlZml4ICsgbmFtZSArIHN1ZmZpeDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG4gICAgICBpZiAoIWZuIHx8IHJlZW50cnkpIHJldHVybiBcIlwiO1xuICAgICAgdmFyIGZyYW1lID0gY29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO1xuICAgICAgaWYgKHZvaWQgMCAhPT0gZnJhbWUpIHJldHVybiBmcmFtZTtcbiAgICAgIHJlZW50cnkgPSAhMDtcbiAgICAgIGZyYW1lID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7XG4gICAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHZvaWQgMDtcbiAgICAgIHZhciBwcmV2aW91c0Rpc3BhdGNoZXIgPSBudWxsO1xuICAgICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBudWxsO1xuICAgICAgZGlzYWJsZUxvZ3MoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBSdW5JblJvb3RGcmFtZSA9IHtcbiAgICAgICAgICBEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsIFwicHJvcHNcIiwge1xuICAgICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBSZWZsZWN0ICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250cm9sID0geDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoeCQwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2wgPSB4JDA7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoeCQxKSB7XG4gICAgICAgICAgICAgICAgICBjb250cm9sID0geCQxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAoRmFrZSA9IGZuKCkpICYmXG4gICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBGYWtlLmNhdGNoICYmXG4gICAgICAgICAgICAgICAgICBGYWtlLmNhdGNoKGZ1bmN0aW9uICgpIHt9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgICAgICAgICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiBcInN0cmluZ1wiID09PSB0eXBlb2Ygc2FtcGxlLnN0YWNrKVxuICAgICAgICAgICAgICAgIHJldHVybiBbc2FtcGxlLnN0YWNrLCBjb250cm9sLnN0YWNrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QuZGlzcGxheU5hbWUgPVxuICAgICAgICAgIFwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290XCI7XG4gICAgICAgIHZhciBuYW1lUHJvcERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFxuICAgICAgICAgIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCxcbiAgICAgICAgICBcIm5hbWVcIlxuICAgICAgICApO1xuICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IgJiZcbiAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IuY29uZmlndXJhYmxlICYmXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICAgICAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LFxuICAgICAgICAgICAgXCJuYW1lXCIsXG4gICAgICAgICAgICB7IHZhbHVlOiBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiIH1cbiAgICAgICAgICApO1xuICAgICAgICB2YXIgX1J1bkluUm9vdEZyYW1lJERldGVyID1cbiAgICAgICAgICAgIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCgpLFxuICAgICAgICAgIHNhbXBsZVN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzBdLFxuICAgICAgICAgIGNvbnRyb2xTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclsxXTtcbiAgICAgICAgaWYgKHNhbXBsZVN0YWNrICYmIGNvbnRyb2xTdGFjaykge1xuICAgICAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZVN0YWNrLnNwbGl0KFwiXFxuXCIpLFxuICAgICAgICAgICAgY29udHJvbExpbmVzID0gY29udHJvbFN0YWNrLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBuYW1lUHJvcERlc2NyaXB0b3IgPSAwO1xuICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yIDwgc2FtcGxlTGluZXMubGVuZ3RoICYmXG4gICAgICAgICAgICAhc2FtcGxlTGluZXNbbmFtZVByb3BEZXNjcmlwdG9yXS5pbmNsdWRlcyhcbiAgICAgICAgICAgICAgXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIlxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgIClcbiAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvcisrO1xuICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICA7XG4gICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPCBjb250cm9sTGluZXMubGVuZ3RoICYmXG4gICAgICAgICAgICAhY29udHJvbExpbmVzW19SdW5JblJvb3RGcmFtZSREZXRlcl0uaW5jbHVkZXMoXG4gICAgICAgICAgICAgIFwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290XCJcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICApXG4gICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXIrKztcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IgPT09IHNhbXBsZUxpbmVzLmxlbmd0aCB8fFxuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyID09PSBjb250cm9sTGluZXMubGVuZ3RoXG4gICAgICAgICAgKVxuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgMSA8PSBuYW1lUHJvcERlc2NyaXB0b3IgJiZcbiAgICAgICAgICAgICAgMCA8PSBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgJiZcbiAgICAgICAgICAgICAgc2FtcGxlTGluZXNbbmFtZVByb3BEZXNjcmlwdG9yXSAhPT1cbiAgICAgICAgICAgICAgICBjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXTtcblxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXItLTtcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgMSA8PSBuYW1lUHJvcERlc2NyaXB0b3IgJiYgMCA8PSBfUnVuSW5Sb290RnJhbWUkRGV0ZXI7XG4gICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3ItLSwgX1J1bkluUm9vdEZyYW1lJERldGVyLS1cbiAgICAgICAgICApXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0gIT09XG4gICAgICAgICAgICAgIGNvbnRyb2xMaW5lc1tfUnVuSW5Sb290RnJhbWUkRGV0ZXJdXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaWYgKDEgIT09IG5hbWVQcm9wRGVzY3JpcHRvciB8fCAxICE9PSBfUnVuSW5Sb290RnJhbWUkRGV0ZXIpIHtcbiAgICAgICAgICAgICAgICBkb1xuICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAobmFtZVByb3BEZXNjcmlwdG9yLS0sXG4gICAgICAgICAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlci0tLFxuICAgICAgICAgICAgICAgICAgICAwID4gX1J1bkluUm9vdEZyYW1lJERldGVyIHx8XG4gICAgICAgICAgICAgICAgICAgICAgc2FtcGxlTGluZXNbbmFtZVByb3BEZXNjcmlwdG9yXSAhPT1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xMaW5lc1tfUnVuSW5Sb290RnJhbWUkRGV0ZXJdKVxuICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPVxuICAgICAgICAgICAgICAgICAgICAgIFwiXFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0ucmVwbGFjZShcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIGF0IG5ldyBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIGF0IFwiXG4gICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgZm4uZGlzcGxheU5hbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICBfZnJhbWUuaW5jbHVkZXMoXCI8YW5vbnltb3VzPlwiKSAmJlxuICAgICAgICAgICAgICAgICAgICAgIChfZnJhbWUgPSBfZnJhbWUucmVwbGFjZShcIjxhbm9ueW1vdXM+XCIsIGZuLmRpc3BsYXlOYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGZuICYmXG4gICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKDEgPD0gbmFtZVByb3BEZXNjcmlwdG9yICYmIDAgPD0gX1J1bkluUm9vdEZyYW1lJERldGVyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgKHJlZW50cnkgPSAhMSksXG4gICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2aW91c0Rpc3BhdGNoZXIpLFxuICAgICAgICAgIHJlZW5hYmxlTG9ncygpLFxuICAgICAgICAgIChFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IGZyYW1lKTtcbiAgICAgIH1cbiAgICAgIHNhbXBsZUxpbmVzID0gKHNhbXBsZUxpbmVzID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogXCJcIilcbiAgICAgICAgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShzYW1wbGVMaW5lcylcbiAgICAgICAgOiBcIlwiO1xuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZm4gJiYgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHNhbXBsZUxpbmVzKTtcbiAgICAgIHJldHVybiBzYW1wbGVMaW5lcztcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUpIHtcbiAgICAgIGlmIChudWxsID09IHR5cGUpIHJldHVybiBcIlwiO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUpIHtcbiAgICAgICAgdmFyIHByb3RvdHlwZSA9IHR5cGUucHJvdG90eXBlO1xuICAgICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgICEoIXByb3RvdHlwZSB8fCAhcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUpIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSh0eXBlKTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKFwiU3VzcGVuc2VcIik7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShcIlN1c3BlbnNlTGlzdFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuICh0eXBlID0gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLnJlbmRlciwgITEpKSwgdHlwZTtcbiAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlKTtcbiAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgIHByb3RvdHlwZSA9IHR5cGUuX3BheWxvYWQ7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS5faW5pdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZShwcm90b3R5cGUpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRPd25lcigpIHtcbiAgICAgIHZhciBkaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuQTtcbiAgICAgIHJldHVybiBudWxsID09PSBkaXNwYXRjaGVyID8gbnVsbCA6IGRpc3BhdGNoZXIuZ2V0T3duZXIoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIFwia2V5XCIpKSB7XG4gICAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgXCJrZXlcIikuZ2V0O1xuICAgICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykgcmV0dXJuICExO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZvaWQgMCAhPT0gY29uZmlnLmtleTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gICAgICBmdW5jdGlvbiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkoKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duIHx8XG4gICAgICAgICAgKChzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9ICEwKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lIHZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgcHJvcC4gKGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvc3BlY2lhbC1wcm9wcylcIixcbiAgICAgICAgICAgIGRpc3BsYXlOYW1lXG4gICAgICAgICAgKSk7XG4gICAgICB9XG4gICAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSAhMDtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgXCJrZXlcIiwge1xuICAgICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVsZW1lbnRSZWZHZXR0ZXJXaXRoRGVwcmVjYXRpb25XYXJuaW5nKCkge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodGhpcy50eXBlKTtcbiAgICAgIGRpZFdhcm5BYm91dEVsZW1lbnRSZWZbY29tcG9uZW50TmFtZV0gfHxcbiAgICAgICAgKChkaWRXYXJuQWJvdXRFbGVtZW50UmVmW2NvbXBvbmVudE5hbWVdID0gITApLFxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiQWNjZXNzaW5nIGVsZW1lbnQucmVmIHdhcyByZW1vdmVkIGluIFJlYWN0IDE5LiByZWYgaXMgbm93IGEgcmVndWxhciBwcm9wLiBJdCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgSlNYIEVsZW1lbnQgdHlwZSBpbiBhIGZ1dHVyZSByZWxlYXNlLlwiXG4gICAgICAgICkpO1xuICAgICAgY29tcG9uZW50TmFtZSA9IHRoaXMucHJvcHMucmVmO1xuICAgICAgcmV0dXJuIHZvaWQgMCAhPT0gY29tcG9uZW50TmFtZSA/IGNvbXBvbmVudE5hbWUgOiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICAgICAgc2VsZiA9IHByb3BzLnJlZjtcbiAgICAgIHR5cGUgPSB7XG4gICAgICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIGtleToga2V5LFxuICAgICAgICBwcm9wczogcHJvcHMsXG4gICAgICAgIF9vd25lcjogb3duZXJcbiAgICAgIH07XG4gICAgICBudWxsICE9PSAodm9pZCAwICE9PSBzZWxmID8gc2VsZiA6IG51bGwpXG4gICAgICAgID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwicmVmXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICAgICAgZ2V0OiBlbGVtZW50UmVmR2V0dGVyV2l0aERlcHJlY2F0aW9uV2FybmluZ1xuICAgICAgICAgIH0pXG4gICAgICAgIDogT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwicmVmXCIsIHsgZW51bWVyYWJsZTogITEsIHZhbHVlOiBudWxsIH0pO1xuICAgICAgdHlwZS5fc3RvcmUgPSB7fTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLl9zdG9yZSwgXCJ2YWxpZGF0ZWRcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogMFxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJfZGVidWdJbmZvXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmZyZWV6ZSAmJiAoT2JqZWN0LmZyZWV6ZSh0eXBlLnByb3BzKSwgT2JqZWN0LmZyZWV6ZSh0eXBlKSk7XG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gICAgZnVuY3Rpb24ganN4REVWSW1wbChcbiAgICAgIHR5cGUsXG4gICAgICBjb25maWcsXG4gICAgICBtYXliZUtleSxcbiAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICBzb3VyY2UsXG4gICAgICBzZWxmXG4gICAgKSB7XG4gICAgICBpZiAoXG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlIHx8XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUgfHxcbiAgICAgICAgdHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fFxuICAgICAgICB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8XG4gICAgICAgIHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHxcbiAgICAgICAgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fFxuICAgICAgICB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHxcbiAgICAgICAgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgfHxcbiAgICAgICAgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlICYmXG4gICAgICAgICAgbnVsbCAhPT0gdHlwZSAmJlxuICAgICAgICAgICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHxcbiAgICAgICAgICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fFxuICAgICAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8XG4gICAgICAgICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05TVU1FUl9UWVBFIHx8XG4gICAgICAgICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8XG4gICAgICAgICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDEgfHxcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gdHlwZS5nZXRNb2R1bGVJZCkpXG4gICAgICApIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gY29uZmlnLmNoaWxkcmVuO1xuICAgICAgICBpZiAodm9pZCAwICE9PSBjaGlsZHJlbilcbiAgICAgICAgICBpZiAoaXNTdGF0aWNDaGlsZHJlbilcbiAgICAgICAgICAgIGlmIChpc0FycmF5SW1wbChjaGlsZHJlbikpIHtcbiAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuID0gMDtcbiAgICAgICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuIDwgY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4rK1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baXNTdGF0aWNDaGlsZHJlbl0sIHR5cGUpO1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplICYmIE9iamVjdC5mcmVlemUoY2hpbGRyZW4pO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJSZWFjdC5qc3g6IFN0YXRpYyBjaGlsZHJlbiBzaG91bGQgYWx3YXlzIGJlIGFuIGFycmF5LiBZb3UgYXJlIGxpa2VseSBleHBsaWNpdGx5IGNhbGxpbmcgUmVhY3QuanN4cyBvciBSZWFjdC5qc3hERVYuIFVzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICBlbHNlIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoaWxkcmVuID0gXCJcIjtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHZvaWQgMCA9PT0gdHlwZSB8fFxuICAgICAgICAgIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gdHlwZSAmJlxuICAgICAgICAgICAgMCA9PT0gT2JqZWN0LmtleXModHlwZSkubGVuZ3RoKVxuICAgICAgICApXG4gICAgICAgICAgY2hpbGRyZW4gKz1cbiAgICAgICAgICAgIFwiIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlIGl0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICAgICAgbnVsbCA9PT0gdHlwZVxuICAgICAgICAgID8gKGlzU3RhdGljQ2hpbGRyZW4gPSBcIm51bGxcIilcbiAgICAgICAgICA6IGlzQXJyYXlJbXBsKHR5cGUpXG4gICAgICAgICAgICA/IChpc1N0YXRpY0NoaWxkcmVuID0gXCJhcnJheVwiKVxuICAgICAgICAgICAgOiB2b2lkIDAgIT09IHR5cGUgJiYgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFXG4gICAgICAgICAgICAgID8gKChpc1N0YXRpY0NoaWxkcmVuID1cbiAgICAgICAgICAgICAgICAgIFwiPFwiICtcbiAgICAgICAgICAgICAgICAgIChnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCBcIlVua25vd25cIikgK1xuICAgICAgICAgICAgICAgICAgXCIgLz5cIiksXG4gICAgICAgICAgICAgICAgKGNoaWxkcmVuID1cbiAgICAgICAgICAgICAgICAgIFwiIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/XCIpKVxuICAgICAgICAgICAgICA6IChpc1N0YXRpY0NoaWxkcmVuID0gdHlwZW9mIHR5cGUpO1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiUmVhY3QuanN4OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciBidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlIGNvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzXCIsXG4gICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbixcbiAgICAgICAgICBjaGlsZHJlblxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBcImtleVwiKSkge1xuICAgICAgICBjaGlsZHJlbiA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhjb25maWcpLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgICAgICAgIHJldHVybiBcImtleVwiICE9PSBrO1xuICAgICAgICB9KTtcbiAgICAgICAgaXNTdGF0aWNDaGlsZHJlbiA9XG4gICAgICAgICAgMCA8IGtleXMubGVuZ3RoXG4gICAgICAgICAgICA/IFwie2tleTogc29tZUtleSwgXCIgKyBrZXlzLmpvaW4oXCI6IC4uLiwgXCIpICsgXCI6IC4uLn1cIlxuICAgICAgICAgICAgOiBcIntrZXk6IHNvbWVLZXl9XCI7XG4gICAgICAgIGRpZFdhcm5BYm91dEtleVNwcmVhZFtjaGlsZHJlbiArIGlzU3RhdGljQ2hpbGRyZW5dIHx8XG4gICAgICAgICAgKChrZXlzID1cbiAgICAgICAgICAgIDAgPCBrZXlzLmxlbmd0aCA/IFwie1wiICsga2V5cy5qb2luKFwiOiAuLi4sIFwiKSArIFwiOiAuLi59XCIgOiBcInt9XCIpLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAnQSBwcm9wcyBvYmplY3QgY29udGFpbmluZyBhIFwia2V5XCIgcHJvcCBpcyBiZWluZyBzcHJlYWQgaW50byBKU1g6XFxuICBsZXQgcHJvcHMgPSAlcztcXG4gIDwlcyB7Li4ucHJvcHN9IC8+XFxuUmVhY3Qga2V5cyBtdXN0IGJlIHBhc3NlZCBkaXJlY3RseSB0byBKU1ggd2l0aG91dCB1c2luZyBzcHJlYWQ6XFxuICBsZXQgcHJvcHMgPSAlcztcXG4gIDwlcyBrZXk9e3NvbWVLZXl9IHsuLi5wcm9wc30gLz4nLFxuICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbixcbiAgICAgICAgICAgIGNoaWxkcmVuLFxuICAgICAgICAgICAga2V5cyxcbiAgICAgICAgICAgIGNoaWxkcmVuXG4gICAgICAgICAgKSxcbiAgICAgICAgICAoZGlkV2FybkFib3V0S2V5U3ByZWFkW2NoaWxkcmVuICsgaXNTdGF0aWNDaGlsZHJlbl0gPSAhMCkpO1xuICAgICAgfVxuICAgICAgY2hpbGRyZW4gPSBudWxsO1xuICAgICAgdm9pZCAwICE9PSBtYXliZUtleSAmJlxuICAgICAgICAoY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSksIChjaGlsZHJlbiA9IFwiXCIgKyBtYXliZUtleSkpO1xuICAgICAgaGFzVmFsaWRLZXkoY29uZmlnKSAmJlxuICAgICAgICAoY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KSwgKGNoaWxkcmVuID0gXCJcIiArIGNvbmZpZy5rZXkpKTtcbiAgICAgIGlmIChcImtleVwiIGluIGNvbmZpZykge1xuICAgICAgICBtYXliZUtleSA9IHt9O1xuICAgICAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBjb25maWcpXG4gICAgICAgICAgXCJrZXlcIiAhPT0gcHJvcE5hbWUgJiYgKG1heWJlS2V5W3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV0pO1xuICAgICAgfSBlbHNlIG1heWJlS2V5ID0gY29uZmlnO1xuICAgICAgY2hpbGRyZW4gJiZcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIoXG4gICAgICAgICAgbWF5YmVLZXksXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZVxuICAgICAgICAgICAgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBcIlVua25vd25cIlxuICAgICAgICAgICAgOiB0eXBlXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGNoaWxkcmVuLCBzZWxmLCBzb3VyY2UsIGdldE93bmVyKCksIG1heWJlS2V5KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICAgICAgaWYgKFxuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygbm9kZSAmJlxuICAgICAgICBub2RlICYmXG4gICAgICAgIG5vZGUuJCR0eXBlb2YgIT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0VcbiAgICAgIClcbiAgICAgICAgaWYgKGlzQXJyYXlJbXBsKG5vZGUpKVxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcbiAgICAgICAgICAgIGlzVmFsaWRFbGVtZW50KGNoaWxkKSAmJiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KG5vZGUpKVxuICAgICAgICAgIG5vZGUuX3N0b3JlICYmIChub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSAxKTtcbiAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgKG51bGwgPT09IG5vZGUgfHwgXCJvYmplY3RcIiAhPT0gdHlwZW9mIG5vZGVcbiAgICAgICAgICAgID8gKGkgPSBudWxsKVxuICAgICAgICAgICAgOiAoKGkgPVxuICAgICAgICAgICAgICAgIChNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbm9kZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdKSB8fFxuICAgICAgICAgICAgICAgIG5vZGVbXCJAQGl0ZXJhdG9yXCJdKSxcbiAgICAgICAgICAgICAgKGkgPSBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpID8gaSA6IG51bGwpKSxcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpICYmXG4gICAgICAgICAgICBpICE9PSBub2RlLmVudHJpZXMgJiZcbiAgICAgICAgICAgICgoaSA9IGkuY2FsbChub2RlKSksIGkgIT09IG5vZGUpKVxuICAgICAgICApXG4gICAgICAgICAgZm9yICg7ICEobm9kZSA9IGkubmV4dCgpKS5kb25lOyApXG4gICAgICAgICAgICBpc1ZhbGlkRWxlbWVudChub2RlLnZhbHVlKSAmJlxuICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KG5vZGUudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBvYmplY3QgJiZcbiAgICAgICAgbnVsbCAhPT0gb2JqZWN0ICYmXG4gICAgICAgIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAgICAgIGlmIChcbiAgICAgICAgZWxlbWVudC5fc3RvcmUgJiZcbiAgICAgICAgIWVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCAmJlxuICAgICAgICBudWxsID09IGVsZW1lbnQua2V5ICYmXG4gICAgICAgICgoZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gMSksXG4gICAgICAgIChwYXJlbnRUeXBlID0gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSksXG4gICAgICAgICFvd25lckhhc0tleVVzZVdhcm5pbmdbcGFyZW50VHlwZV0pXG4gICAgICApIHtcbiAgICAgICAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW3BhcmVudFR5cGVdID0gITA7XG4gICAgICAgIHZhciBjaGlsZE93bmVyID0gXCJcIjtcbiAgICAgICAgZWxlbWVudCAmJlxuICAgICAgICAgIG51bGwgIT0gZWxlbWVudC5fb3duZXIgJiZcbiAgICAgICAgICBlbGVtZW50Ll9vd25lciAhPT0gZ2V0T3duZXIoKSAmJlxuICAgICAgICAgICgoY2hpbGRPd25lciA9IG51bGwpLFxuICAgICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBlbGVtZW50Ll9vd25lci50YWdcbiAgICAgICAgICAgID8gKGNoaWxkT3duZXIgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkpXG4gICAgICAgICAgICA6IFwic3RyaW5nXCIgPT09IHR5cGVvZiBlbGVtZW50Ll9vd25lci5uYW1lICYmXG4gICAgICAgICAgICAgIChjaGlsZE93bmVyID0gZWxlbWVudC5fb3duZXIubmFtZSksXG4gICAgICAgICAgKGNoaWxkT3duZXIgPSBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArIGNoaWxkT3duZXIgKyBcIi5cIikpO1xuICAgICAgICB2YXIgcHJldkdldEN1cnJlbnRTdGFjayA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjaztcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUpO1xuICAgICAgICAgIHByZXZHZXRDdXJyZW50U3RhY2sgJiYgKHN0YWNrICs9IHByZXZHZXRDdXJyZW50U3RhY2soKSB8fCBcIlwiKTtcbiAgICAgICAgICByZXR1cm4gc3RhY2s7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4lcyVzIFNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL3dhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLFxuICAgICAgICAgIHBhcmVudFR5cGUsXG4gICAgICAgICAgY2hpbGRPd25lclxuICAgICAgICApO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2sgPSBwcmV2R2V0Q3VycmVudFN0YWNrO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAgICAgIHZhciBpbmZvID0gXCJcIixcbiAgICAgICAgb3duZXIgPSBnZXRPd25lcigpO1xuICAgICAgb3duZXIgJiZcbiAgICAgICAgKG93bmVyID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKG93bmVyLnR5cGUpKSAmJlxuICAgICAgICAoaW5mbyA9IFwiXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYFwiICsgb3duZXIgKyBcImAuXCIpO1xuICAgICAgaW5mbyB8fFxuICAgICAgICAoKHBhcmVudFR5cGUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUocGFyZW50VHlwZSkpICYmXG4gICAgICAgICAgKGluZm8gPVxuICAgICAgICAgICAgXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudFR5cGUgKyBcIj4uXCIpKTtcbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cbiAgICB2YXIgUmVhY3QgPSByZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0XCIpLFxuICAgICAgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnRyYW5zaXRpb25hbC5lbGVtZW50XCIpLFxuICAgICAgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpLFxuICAgICAgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSxcbiAgICAgIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIiksXG4gICAgICBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpO1xuICAgIFN5bWJvbC5mb3IoXCJyZWFjdC5wcm92aWRlclwiKTtcbiAgICB2YXIgUkVBQ1RfQ09OU1VNRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb25zdW1lclwiKSxcbiAgICAgIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpLFxuICAgICAgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKSxcbiAgICAgIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIiksXG4gICAgICBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VfbGlzdFwiKSxcbiAgICAgIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpLFxuICAgICAgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIiksXG4gICAgICBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5vZmZzY3JlZW5cIiksXG4gICAgICBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSBTeW1ib2wuaXRlcmF0b3IsXG4gICAgICBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgPSBTeW1ib2wuZm9yKFwicmVhY3QuY2xpZW50LnJlZmVyZW5jZVwiKSxcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzID1cbiAgICAgICAgUmVhY3QuX19DTElFTlRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFLFxuICAgICAgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFxuICAgICAgYXNzaWduID0gT2JqZWN0LmFzc2lnbixcbiAgICAgIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpLFxuICAgICAgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5LFxuICAgICAgZGlzYWJsZWREZXB0aCA9IDAsXG4gICAgICBwcmV2TG9nLFxuICAgICAgcHJldkluZm8sXG4gICAgICBwcmV2V2FybixcbiAgICAgIHByZXZFcnJvcixcbiAgICAgIHByZXZHcm91cCxcbiAgICAgIHByZXZHcm91cENvbGxhcHNlZCxcbiAgICAgIHByZXZHcm91cEVuZDtcbiAgICBkaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSAhMDtcbiAgICB2YXIgcHJlZml4LFxuICAgICAgc3VmZml4LFxuICAgICAgcmVlbnRyeSA9ICExO1xuICAgIHZhciBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IChcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFdlYWtNYXAgPyBXZWFrTWFwIDogTWFwXG4gICAgKSgpO1xuICAgIHZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcihcInJlYWN0LmNsaWVudC5yZWZlcmVuY2VcIiksXG4gICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bjtcbiAgICB2YXIgZGlkV2FybkFib3V0RWxlbWVudFJlZiA9IHt9O1xuICAgIHZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fSxcbiAgICAgIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuICAgIGV4cG9ydHMuRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xuICAgIGV4cG9ydHMuanN4REVWID0gZnVuY3Rpb24gKFxuICAgICAgdHlwZSxcbiAgICAgIGNvbmZpZyxcbiAgICAgIG1heWJlS2V5LFxuICAgICAgaXNTdGF0aWNDaGlsZHJlbixcbiAgICAgIHNvdXJjZSxcbiAgICAgIHNlbGZcbiAgICApIHtcbiAgICAgIHJldHVybiBqc3hERVZJbXBsKHR5cGUsIGNvbmZpZywgbWF5YmVLZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZik7XG4gICAgfTtcbiAgfSkoKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYXdlbG5pZWR6d2llZHovRGVza3RvcC92b3V5LWJ1c2luZXNzL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ag-charts-community/dist/package/main.esm.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/ag-charts-community/dist/package/main.esm.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AG_CHARTS_LOCALE_EN_US: () => (/* binding */ AG_CHARTS_LOCALE_EN_US),\n/* harmony export */   AgCharts: () => (/* binding */ AgCharts),\n/* harmony export */   AgErrorBarSupportedSeriesTypes: () => (/* binding */ AgErrorBarSupportedSeriesTypes),\n/* harmony export */   AgTooltipPositionType: () => (/* binding */ AgTooltipPositionType),\n/* harmony export */   ICONS_LEGACY: () => (/* binding */ ICONS_LEGACY),\n/* harmony export */   Marker: () => (/* binding */ Marker),\n/* harmony export */   VERSION: () => (/* binding */ VERSION),\n/* harmony export */   _ModuleSupport: () => (/* binding */ module_support_exports),\n/* harmony export */   _Scale: () => (/* binding */ sparklines_scale_exports),\n/* harmony export */   _Scene: () => (/* binding */ integrated_charts_scene_exports),\n/* harmony export */   _Theme: () => (/* binding */ integrated_charts_theme_exports),\n/* harmony export */   _Util: () => (/* binding */ sparklines_util_exports),\n/* harmony export */   setupCommunityModules: () => (/* binding */ setupCommunityModules),\n/* harmony export */   time: () => (/* binding */ time_exports)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __decorateClass = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result)\n    __defProp(target, key, result);\n  return result;\n};\n\n// packages/ag-charts-locale/src/en-US.ts\nvar AG_CHARTS_LOCALE_EN_US = {\n  // Screen reader announcement when focusing an item in the chart\n  ariaAnnounceHoverDatum: \"${datum}\",\n  // Screen reader announcement when focusing a chart\n  ariaAnnounceChart: \"chart, ${seriesCount}[number] series\",\n  // Screen reader announcement when focusing a hierarchy chart\n  ariaAnnounceHierarchyChart: \"hierarchy chart, ${caption}\",\n  // Screen reader announcement when focusing a gauge chart\n  ariaAnnounceGaugeChart: \"gauge chart, ${caption}\",\n  // Screen reader announcement when focusing an item in a treemap or sunburst chart\n  ariaAnnounceHierarchyDatum: \"level ${level}[number], ${count}[number] children, ${description}\",\n  // Screen reader announcement when focusing a link in a Sankey or chord chart\n  ariaAnnounceFlowProportionLink: \"link ${index} of ${count}, from ${from} to ${to}, ${sizeName} ${size}\",\n  // Screen reader announcement when focusing a node in a Sankey or chord chart\n  ariaAnnounceFlowProportionNode: \"node ${index} of ${count}, ${description}\",\n  // Screen reader description for legend items\n  ariaDescriptionLegendItem: \"Press Space or Enter to toggle visibility\",\n  // Screen reader text for annotation-options toolbar\n  ariaLabelAnnotationOptionsToolbar: \"Annotation Options\",\n  // Screen reader text for annotation-settings dialog\n  ariaLabelAnnotationSettingsDialog: \"Annotation Settings\",\n  // Screen reader text for the color picker dialog\n  ariaLabelColorPicker: \"Color picker\",\n  // Screen reader text for the financial charts toolbar\n  ariaLabelFinancialCharts: \"Financial Charts\",\n  // Screen reader text for the legend toolbar\n  ariaLabelLegend: \"Legend\",\n  // Screen reader text for the legend pagination button\n  ariaLabelLegendPagination: \"Legend Pagination\",\n  // Screen reader text for the previous legend page button\n  ariaLabelLegendPagePrevious: \"Previous Legend Page\",\n  // Screen reader text for the next legend page button\n  ariaLabelLegendPageNext: \"Next Legend Page\",\n  // Screen reader text for the an item in the legend\n  ariaLabelLegendItem: \"${label}, Legend item ${index}[number] of ${count}[number]\",\n  // Screen reader text for the an unknown item in the legend\n  ariaLabelLegendItemUnknown: \"Unknown legend item\",\n  // Screen reader text for the navigator element\n  ariaLabelNavigator: \"Navigator\",\n  // Screen reader text for an accessibility control that changes the position of the navigator's range\n  ariaLabelNavigatorRange: \"Range\",\n  // Screen reader text for an accessibility control that changes the start of the navigator's range\n  ariaLabelNavigatorMinimum: \"Minimum\",\n  // Screen reader text for an accessibility control that changes the end of the navigator's range\n  ariaLabelNavigatorMaximum: \"Maximum\",\n  // Screen reader text for ranges toolbar\n  ariaLabelRangesToolbar: \"Ranges\",\n  // Screen reader text for the settings dialog tab-bar\n  ariaLabelSettingsTabBar: \"Settings\",\n  // Screen reader text for zoom toolbar\n  ariaLabelZoomToolbar: \"Zoom\",\n  // Screen reader text for the value of the navigator's range\n  ariaValuePanRange: \"${min}[percent] to ${max}[percent]\",\n  // Alt-text for the solid line dash style menu item icon\n  iconAltTextLineStyleSolid: \"Solid\",\n  // Alt-text for the long-dashed line dash style menu item icon\n  iconAltTextLineStyleDashed: \"Long-dashed\",\n  // Alt-text for the short-dashed line dash style menu item icon\n  iconAltTextLineStyleDotted: \"Short-dashed\",\n  // Alt-text for the 'position-top' icon\n  iconAltTextPositionTop: \"Top\",\n  // Alt-text for the 'position-center' icon\n  iconAltTextPositionCenter: \"Center\",\n  // Alt-text for the 'position-bottom' icon\n  iconAltTextPositionBottom: \"Bottom\",\n  // Alt-text for the 'position-left' icon\n  iconAltTextAlignLeft: \"Left\",\n  // Alt-text for the 'align-center' icon\n  iconAltTextAlignCenter: \"Center\",\n  // Alt-text for the 'position-right' icon\n  iconAltTextAlignRight: \"Right\",\n  // Alt-text for the 'close' icon\n  iconAltTextClose: \"Close\",\n  // Default text for the 'loading data' overlay\n  overlayLoadingData: \"Loading data...\",\n  // Default text for the 'no data' overlay\n  overlayNoData: \"No data to display\",\n  // Default text for the 'no visible series' overlay\n  overlayNoVisibleSeries: \"No visible series\",\n  // Text for the series type toolbar's chart type button\n  toolbarSeriesTypeDropdown: \"Chart Type\",\n  // Text for the series type toolbar's OHLC chart type button\n  toolbarSeriesTypeOHLC: \"OHLC\",\n  // Text for the series type toolbar's HLC chart type button\n  toolbarSeriesTypeHLC: \"HLC\",\n  // Text for the series type toolbar's high low chart type button\n  toolbarSeriesTypeHighLow: \"High Low\",\n  // Text for the series type toolbar's candles chart type button\n  toolbarSeriesTypeCandles: \"Candles\",\n  // Text for the series type toolbar's hollow candles chart type button\n  toolbarSeriesTypeHollowCandles: \"Hollow Candles\",\n  // Text for the series type toolbar's line chart type button\n  toolbarSeriesTypeLine: \"Line\",\n  // Text for the series type toolbar's line with markers chart type button\n  toolbarSeriesTypeLineWithMarkers: \"Line with Markers\",\n  // Text for the series type toolbar's line with step line chart type button\n  toolbarSeriesTypeStepLine: \"Step Line\",\n  // Text for the annotation toolbar's trend line button\n  toolbarAnnotationsTrendLine: \"Trend Line\",\n  // Text for the annotation toolbar's horizontal line button\n  toolbarAnnotationsHorizontalLine: \"Horizontal Line\",\n  // Text for the annotation toolbar's vertical line button\n  toolbarAnnotationsVerticalLine: \"Vertical Line\",\n  // Text for the annotation toolbar's parallel channel button\n  toolbarAnnotationsParallelChannel: \"Parallel Channel\",\n  // Text for the annotation toolbar's disjoint channel button\n  toolbarAnnotationsDisjointChannel: \"Disjoint Channel\",\n  // Text for the annotation toolbar's clear all button\n  toolbarAnnotationsClearAll: \"Clear All\",\n  /**\n   * Text for the annotation toolbar's color picker annotation button\n   * @deprecated v10.1.0 use `toolbarAnnotationsLineColor` instead.\n   */\n  toolbarAnnotationsColor: \"Color\",\n  // Text for the annotation toolbar's fill color picker annotation button\n  toolbarAnnotationsFillColor: \"Fill Color\",\n  // Text for the annotation toolbar's line color picker annotation button\n  toolbarAnnotationsLineColor: \"Line Color\",\n  // Text for the annotation toolbar's line style type button\n  toolbarAnnotationsLineStyle: \"Line Style\",\n  // Text for the annotation toolbar's line stroke width button\n  toolbarAnnotationsLineStrokeWidth: \"Line Stroke Width\",\n  // Text for the annotation toolbar's settings annotation button\n  toolbarAnnotationsSettings: \"Settings\",\n  // Text for the annotation toolbar's text color picker annotation button\n  toolbarAnnotationsTextColor: \"Text Color\",\n  // Text for the annotation toolbar's text size picker annotation button\n  toolbarAnnotationsTextSize: \"Text Size\",\n  // Text for the annotation toolbar's lock annotation button\n  toolbarAnnotationsLock: \"Lock\",\n  // Text for the annotation toolbar's unlock annotation button\n  toolbarAnnotationsUnlock: \"Unlock\",\n  // Text for the annotation toolbar's delete annotation button\n  toolbarAnnotationsDelete: \"Delete\",\n  // Text for the annotation toolbar's drag handle\n  toolbarAnnotationsDragHandle: \"Drag Toolbar\",\n  // Text for the annotation toolbar's line drawings menu button\n  toolbarAnnotationsLineAnnotations: \"Trend Lines\",\n  // Text for the annotation toolbar's text annotations menu button\n  toolbarAnnotationsTextAnnotations: \"Text Annotations\",\n  // Text for the annotation toolbar's shapes menu button\n  toolbarAnnotationsShapeAnnotations: \"Arrows\",\n  // Text for the annotation toolbar's measurers menu button\n  toolbarAnnotationsMeasurerAnnotations: \"Measurers\",\n  // Text for the annotation toolbar's callout button\n  toolbarAnnotationsCallout: \"Callout\",\n  // Text for the annotation toolbar's comment button\n  toolbarAnnotationsComment: \"Comment\",\n  // Text for the annotation toolbar's note button\n  toolbarAnnotationsNote: \"Note\",\n  // Text for the annotation toolbar's text button\n  toolbarAnnotationsText: \"Text\",\n  // Text for the annotation toolbar's arrow button\n  toolbarAnnotationsArrow: \"Arrow\",\n  // Text for the annotation toolbar's arrow up button\n  toolbarAnnotationsArrowUp: \"Arrow Up\",\n  // Text for the annotation toolbar's arrow down button\n  toolbarAnnotationsArrowDown: \"Arrow Down\",\n  // Text for the annotation toolbar's date range button\n  toolbarAnnotationsDateRange: \"Date Range\",\n  // Text for the annotation toolbar's price range button\n  toolbarAnnotationsPriceRange: \"Price Range\",\n  // Text for the annotation toolbar's date and price range button\n  toolbarAnnotationsDatePriceRange: \"Date and Price\",\n  // Text for the annotation toolbar's quick date and price range button\n  toolbarAnnotationsQuickDatePriceRange: \"Measure\",\n  // Text for the range toolbar's 1 month button\n  toolbarRange1Month: \"1M\",\n  // Aria label for the range toolbar's 1 month button\n  toolbarRange1MonthAria: \"1 month\",\n  // Text for the range toolbar's 3 month button\n  toolbarRange3Months: \"3M\",\n  // Aria label for the range toolbar's 3 month button\n  toolbarRange3MonthsAria: \"3 months\",\n  // Text for the range toolbar's 6 month button\n  toolbarRange6Months: \"6M\",\n  // Aria label for the range toolbar's 6 month button\n  toolbarRange6MonthsAria: \"6 months\",\n  // Text for the range toolbar's year to date button\n  toolbarRangeYearToDate: \"YTD\",\n  // Aria label for the range toolbar's year to date month button\n  toolbarRangeYearToDateAria: \"Year to date\",\n  // Text for the range toolbar's 1 year button\n  toolbarRange1Year: \"1Y\",\n  // Aria label for the range toolbar's 1 year button\n  toolbarRange1YearAria: \"1 year\",\n  // Text for the range toolbar's full range button\n  toolbarRangeAll: \"All\",\n  // Aria label for the range toolbar's full range button\n  toolbarRangeAllAria: \"All\",\n  // Text for the zoom toolbar's zoom out button\n  toolbarZoomZoomOut: \"Zoom out\",\n  // Text for the zoom toolbar's zoom in button\n  toolbarZoomZoomIn: \"Zoom in\",\n  // Text for the zoom toolbar's pan left button\n  toolbarZoomPanLeft: \"Pan left\",\n  // Text for the zoom toolbar's pan right button\n  toolbarZoomPanRight: \"Pan right\",\n  // Text for the zoom toolbar's pan to the start button\n  toolbarZoomPanStart: \"Pan to the start\",\n  // Text for the zoom toolbar's pan to the end button\n  toolbarZoomPanEnd: \"Pan to the end\",\n  // Text for the zoom toolbar's pan reset button\n  toolbarZoomReset: \"Reset the zoom\",\n  // Text for the context menu's download button\n  contextMenuDownload: \"Download\",\n  // Text for the context menu's toggle series visibility button\n  contextMenuToggleSeriesVisibility: \"Toggle Visibility\",\n  // Text for the context menu's toggle other series visibility button\n  contextMenuToggleOtherSeries: \"Toggle Other Series\",\n  // Text for the context menu's zoom to point button\n  contextMenuZoomToCursor: \"Zoom to here\",\n  // Text for the context menu's pan to point button\n  contextMenuPanToCursor: \"Pan to here\",\n  // Text for the annotation dialog's header channel tab label\n  dialogHeaderChannel: \"Channel\",\n  // Text for the annotation dialog's header line tab label\n  dialogHeaderLine: \"Line\",\n  // Text for the annotation dialog's header date range tab label\n  dialogHeaderDateRange: \"Date Range\",\n  // Text for the annotation dialog's header price range tab label\n  dialogHeaderPriceRange: \"Price Range\",\n  // Text for the annotation dialog's header date and price range tab label\n  dialogHeaderDatePriceRange: \"Date and Price\",\n  // Text for the annotation dialog's header text tab label\n  dialogHeaderText: \"Text\",\n  // Text for the annotation dialog's text alignment radio label\n  dialogInputAlign: \"Align\",\n  // Text for the annotation dialog's color picker label\n  dialogInputColorPicker: \"Color\",\n  // Text for the annotation dialog's color picker alt text\n  dialogInputColorPickerAltText: \"Text Color\",\n  // Text for the annotation dialog's fill color picker label\n  dialogInputFillColorPicker: \"Fill\",\n  // Text for the annotation dialog's fill color picker alt text\n  dialogInputFillColorPickerAltText: \"Fill Color\",\n  // Text for the annotation dialog's extend channel start checkbox\n  dialogInputExtendChannelStart: \"Extend channel start\",\n  // Text for the annotation dialog's extend channel end checkbox\n  dialogInputExtendChannelEnd: \"Extend channel end\",\n  // Text for the annotation dialog's extend line start checkbox\n  dialogInputExtendLineStart: \"Extend line start\",\n  // Text for the annotation dialog's extend line end checkbox\n  dialogInputExtendLineEnd: \"Extend line end\",\n  // Text for the annotation dialog's extend above checkbox\n  dialogInputExtendAbove: \"Extend above\",\n  // Text for the annotation dialog's extend below checkbox\n  dialogInputExtendBelow: \"Extend below\",\n  // Text for the annotation dialog's extend left checkbox\n  dialogInputExtendLeft: \"Extend left\",\n  // Text for the annotation dialog's extend right checkbox\n  dialogInputExtendRight: \"Extend right\",\n  // Text for the annotation dialog's font size select box label\n  dialogInputFontSize: \"Size\",\n  // Text for the annotation dialog's font size select box alt text\n  dialogInputFontSizeAltText: \"Font Size\",\n  // Text for the annotation dialog's line style radio label\n  dialogInputLineStyle: \"Dash\",\n  // Text for the annotation dialog's text position radio label\n  dialogInputPosition: \"Position\",\n  // Text for the annotation dialog's stroke width label\n  dialogInputStrokeWidth: \"Weight\",\n  // Text for the annotation dialog's stroke width label\n  dialogInputStrokeWidthAltText: \"Line Weight\",\n  // Text for text area input placeholders\n  inputTextareaPlaceholder: \"Add Text\",\n  // Text for the measurer statistics date range bars value\n  measurerDateRangeBars: \"${value}[number] bars\",\n  // Text for the measurer statistics price range value\n  measurerPriceRangeValue: \"${value}[number]\",\n  // Text for the measurer statistics price range percentage\n  measurerPriceRangePercent: \"${value}[percent]\",\n  // Text for the measurer statistics volume value\n  measurerVolume: \"Vol ${value}\"\n};\n\n// packages/ag-charts-types/src/chart/errorBarOptions.ts\nvar AgErrorBarSupportedSeriesTypes = [\"bar\", \"line\", \"scatter\"];\n\n// packages/ag-charts-types/src/chart/icons.ts\nvar ICONS_LEGACY = [\n  \"delete-legacy\",\n  \"disjoint-channel\",\n  \"disjoint-channel-legacy\",\n  \"horizontal-line-legacy\",\n  \"line-color-legacy\",\n  \"lock\",\n  \"lock-legacy\",\n  \"pan-end-legacy\",\n  \"pan-left-legacy\",\n  \"pan-right-legacy\",\n  \"pan-start-legacy\",\n  \"parallel-channel\",\n  \"parallel-channel-legacy\",\n  \"reset-legacy\",\n  \"trend-line\",\n  \"trend-line-legacy\",\n  \"unlock\",\n  \"unlock-legacy\",\n  \"vertical-line\",\n  \"vertical-line-legacy\",\n  \"zoom-in-legacy\",\n  \"zoom-in-alt\",\n  \"zoom-in-alt-legacy\",\n  \"zoom-out-legacy\",\n  \"zoom-out-alt\",\n  \"zoom-out-alt-legacy\"\n];\n\n// packages/ag-charts-types/src/chart/navigatorOptions.ts\nvar __MINI_CHART_SERIES_OPTIONS = void 0;\nvar __VERIFY_MINI_CHART_SERIES_OPTIONS = void 0;\n__VERIFY_MINI_CHART_SERIES_OPTIONS = __MINI_CHART_SERIES_OPTIONS;\n\n// packages/ag-charts-types/src/chart/themeOptions.ts\nvar __THEME_OVERRIDES = void 0;\nvar __VERIFY_THEME_OVERRIDES = void 0;\n__VERIFY_THEME_OVERRIDES = __THEME_OVERRIDES;\n\n// packages/ag-charts-types/src/chart/tooltipOptions.ts\nvar AgTooltipPositionType = /* @__PURE__ */ ((AgTooltipPositionType2) => {\n  AgTooltipPositionType2[\"POINTER\"] = \"pointer\";\n  AgTooltipPositionType2[\"NODE\"] = \"node\";\n  AgTooltipPositionType2[\"TOP\"] = \"top\";\n  AgTooltipPositionType2[\"RIGHT\"] = \"right\";\n  AgTooltipPositionType2[\"BOTTOM\"] = \"bottom\";\n  AgTooltipPositionType2[\"LEFT\"] = \"left\";\n  AgTooltipPositionType2[\"TOP_LEFT\"] = \"top-left\";\n  AgTooltipPositionType2[\"TOP_RIGHT\"] = \"top-right\";\n  AgTooltipPositionType2[\"BOTTOM_RIGHT\"] = \"bottom-right\";\n  AgTooltipPositionType2[\"BOTTOM_LEFT\"] = \"bottom-left\";\n  return AgTooltipPositionType2;\n})(AgTooltipPositionType || {});\n\n// packages/ag-charts-types/src/presets/gauge/commonOptions.ts\nvar __THEMEABLE_OPTIONS = void 0;\nvar __VERIFY_THEMEABLE_OPTIONS = void 0;\n__VERIFY_THEMEABLE_OPTIONS = __THEMEABLE_OPTIONS;\nvar __AXIS_LABEL_OPTIONS = void 0;\nvar __VERIFY_AXIS_LABEL_OPTIONS = void 0;\n__VERIFY_AXIS_LABEL_OPTIONS = __AXIS_LABEL_OPTIONS;\n\n// packages/ag-charts-community/src/util/time/index.ts\nvar time_exports = {};\n__export(time_exports, {\n  TimeInterval: () => TimeInterval,\n  day: () => day,\n  friday: () => friday,\n  hour: () => hour,\n  millisecond: () => millisecond,\n  minute: () => minute,\n  monday: () => monday,\n  month: () => month,\n  saturday: () => saturday,\n  second: () => second,\n  sunday: () => sunday,\n  thursday: () => thursday,\n  tuesday: () => tuesday,\n  utcDay: () => utcDay,\n  utcHour: () => utcHour,\n  utcMinute: () => utcMinute,\n  utcMonth: () => utcMonth,\n  utcYear: () => utcYear,\n  wednesday: () => wednesday,\n  year: () => year\n});\n\n// packages/ag-charts-community/src/util/function.ts\nvar doOnceState = /* @__PURE__ */ new Map();\nfunction doOnce(func, key) {\n  if (doOnceState.has(key))\n    return;\n  doOnceState.set(key, true);\n  func();\n}\ndoOnce.clear = () => doOnceState.clear();\nfunction identity(x) {\n  return x;\n}\nfunction throttle(callback2, waitMs = 0, options) {\n  const { leading = true, trailing = true } = options ?? {};\n  let timerId;\n  let lastArgs;\n  let shouldWait = false;\n  function timeoutHandler() {\n    if (trailing && lastArgs) {\n      timerId = setTimeout(timeoutHandler, waitMs);\n      callback2(...lastArgs);\n    } else {\n      shouldWait = false;\n    }\n    lastArgs = null;\n  }\n  function throttleCallback(...args) {\n    if (shouldWait) {\n      lastArgs = args;\n    } else {\n      shouldWait = true;\n      timerId = setTimeout(timeoutHandler, waitMs);\n      if (leading) {\n        callback2(...args);\n      } else {\n        lastArgs = args;\n      }\n    }\n  }\n  return Object.assign(throttleCallback, {\n    cancel() {\n      clearTimeout(timerId);\n      shouldWait = false;\n      lastArgs = null;\n    }\n  });\n}\nfunction joinFunctions(...fns) {\n  return () => {\n    for (const fn of fns) {\n      fn();\n    }\n  };\n}\n\n// packages/ag-charts-community/src/util/logger.ts\nvar Logger = {\n  log(...logContent) {\n    console.log(...logContent);\n  },\n  warn(message, ...logContent) {\n    console.warn(`AG Charts - ${message}`, ...logContent);\n  },\n  error(message, ...logContent) {\n    if (typeof message === \"object\") {\n      console.error(`AG Charts error`, message, ...logContent);\n    } else {\n      console.error(`AG Charts - ${message}`, ...logContent);\n    }\n  },\n  table(...logContent) {\n    console.table(...logContent);\n  },\n  warnOnce(message, ...logContent) {\n    doOnce(() => Logger.warn(message, ...logContent), `Logger.warn: ${message}`);\n  },\n  errorOnce(message, ...logContent) {\n    doOnce(() => Logger.error(message, ...logContent), `Logger.error: ${message}`);\n  }\n};\n\n// packages/ag-charts-community/src/util/time/interval.ts\nvar TimeInterval = class {\n  constructor(_encode, _decode, _rangeCallback) {\n    this._encode = _encode;\n    this._decode = _decode;\n    this._rangeCallback = _rangeCallback;\n  }\n  /**\n   * Returns a new date representing the latest interval boundary date before or equal to date.\n   * For example, `day.floor(date)` typically returns 12:00 AM local time on the given date.\n   * @param date\n   */\n  floor(date) {\n    const d = new Date(date);\n    const e = this._encode(d);\n    return this._decode(e);\n  }\n  /**\n   * Returns a new date representing the earliest interval boundary date after or equal to date.\n   * @param date\n   */\n  ceil(date) {\n    const d = new Date(Number(date) - 1);\n    const e = this._encode(d);\n    return this._decode(e + 1);\n  }\n  /**\n   * Returns an array of dates representing every interval boundary after or equal to start (inclusive) and before stop (exclusive).\n   * @param start Range start.\n   * @param stop Range end.\n   * @param extend If specified, the requested range will be extended to the closest \"nice\" values.\n   */\n  range(start2, stop, extend) {\n    const rangeCallback = this._rangeCallback?.(start2, stop);\n    const e0 = this._encode(extend ? this.floor(start2) : this.ceil(start2));\n    const e1 = this._encode(extend ? this.ceil(stop) : this.floor(stop));\n    if (e1 < e0) {\n      return [];\n    }\n    const range3 = [];\n    for (let e = e0; e <= e1; e++) {\n      const d = this._decode(e);\n      range3.push(d);\n    }\n    rangeCallback?.();\n    return range3;\n  }\n};\nvar CountableTimeInterval = class extends TimeInterval {\n  getOffset(snapTo, step) {\n    const s = typeof snapTo === \"number\" || snapTo instanceof Date ? this._encode(new Date(snapTo)) : 0;\n    return Math.floor(s) % step;\n  }\n  /**\n   * Returns a filtered view of this interval representing every step'th date.\n   * It can be a number of minutes, hours, days etc.\n   * Must be a positive integer.\n   * @param step\n   */\n  every(step, options) {\n    let offset4 = 0;\n    let rangeCallback;\n    const unsafeStep = step;\n    step = Math.max(1, Math.round(step));\n    if (unsafeStep !== step) {\n      Logger.warnOnce(`interval step of [${unsafeStep}] rounded to [${step}].`);\n    }\n    const { snapTo = \"start\" } = options ?? {};\n    if (typeof snapTo === \"string\") {\n      const initialOffset = offset4;\n      rangeCallback = (start2, stop) => {\n        const s = snapTo === \"start\" ? start2 : stop;\n        offset4 = this.getOffset(s, step);\n        return () => offset4 = initialOffset;\n      };\n    } else if (typeof snapTo === \"number\") {\n      offset4 = this.getOffset(new Date(snapTo), step);\n    } else if (snapTo instanceof Date) {\n      offset4 = this.getOffset(snapTo, step);\n    }\n    const encode13 = (date) => {\n      const e = this._encode(date);\n      return Math.floor((e - offset4) / step);\n    };\n    const decode13 = (encoded) => {\n      return this._decode(encoded * step + offset4);\n    };\n    return new TimeInterval(encode13, decode13, rangeCallback);\n  }\n};\n\n// packages/ag-charts-community/src/util/time/millisecond.ts\nfunction encode(date) {\n  return date.getTime();\n}\nfunction decode(encoded) {\n  return new Date(encoded);\n}\nvar millisecond = new CountableTimeInterval(encode, decode);\nvar millisecond_default = millisecond;\n\n// packages/ag-charts-community/src/util/time/duration.ts\nvar epochYear = (/* @__PURE__ */ new Date(0)).getFullYear();\nvar durationSecond = 1e3;\nvar durationMinute = durationSecond * 60;\nvar durationHour = durationMinute * 60;\nvar durationDay = durationHour * 24;\nvar durationWeek = durationDay * 7;\nvar durationMonth = durationDay * 30;\nvar durationYear = durationDay * 365;\n\n// packages/ag-charts-community/src/util/time/second.ts\nvar offset = (/* @__PURE__ */ new Date()).getTimezoneOffset() * durationMinute;\nfunction encode2(date) {\n  return Math.floor((date.getTime() - offset) / durationSecond);\n}\nfunction decode2(encoded) {\n  return new Date(offset + encoded * durationSecond);\n}\nvar second = new CountableTimeInterval(encode2, decode2);\nvar second_default = second;\n\n// packages/ag-charts-community/src/util/time/minute.ts\nvar offset2 = (/* @__PURE__ */ new Date()).getTimezoneOffset() * durationMinute;\nfunction encode3(date) {\n  return Math.floor((date.getTime() - offset2) / durationMinute);\n}\nfunction decode3(encoded) {\n  return new Date(offset2 + encoded * durationMinute);\n}\nvar minute = new CountableTimeInterval(encode3, decode3);\nvar minute_default = minute;\n\n// packages/ag-charts-community/src/util/time/hour.ts\nvar offset3 = (/* @__PURE__ */ new Date()).getTimezoneOffset() * durationMinute;\nfunction encode4(date) {\n  return Math.floor((date.getTime() - offset3) / durationHour);\n}\nfunction decode4(encoded) {\n  return new Date(offset3 + encoded * durationHour);\n}\nvar hour = new CountableTimeInterval(encode4, decode4);\nvar hour_default = hour;\n\n// packages/ag-charts-community/src/util/time/day.ts\nfunction encode5(date) {\n  const tzOffsetMs = date.getTimezoneOffset() * durationMinute;\n  return Math.floor((date.getTime() - tzOffsetMs) / durationDay);\n}\nfunction decode5(encoded) {\n  const d = new Date(1970, 0, 1);\n  d.setDate(d.getDate() + encoded);\n  return d;\n}\nvar day = new CountableTimeInterval(encode5, decode5);\nvar day_default = day;\n\n// packages/ag-charts-community/src/util/time/week.ts\nfunction weekday(weekStart) {\n  const thursday2 = 4;\n  const dayShift = (7 + weekStart - thursday2) % 7;\n  function encode13(date) {\n    const tzOffsetMs = date.getTimezoneOffset() * durationMinute;\n    return Math.floor((date.getTime() - tzOffsetMs) / durationWeek - dayShift / 7);\n  }\n  function decode13(encoded) {\n    const d = new Date(1970, 0, 1);\n    d.setDate(d.getDate() + encoded * 7 + dayShift);\n    return d;\n  }\n  return new CountableTimeInterval(encode13, decode13);\n}\nvar sunday = weekday(0);\nvar monday = weekday(1);\nvar tuesday = weekday(2);\nvar wednesday = weekday(3);\nvar thursday = weekday(4);\nvar friday = weekday(5);\nvar saturday = weekday(6);\nvar week_default = sunday;\n\n// packages/ag-charts-community/src/util/time/month.ts\nfunction encode6(date) {\n  return date.getFullYear() * 12 + date.getMonth();\n}\nfunction decode6(encoded) {\n  const year2 = Math.floor(encoded / 12);\n  const month2 = encoded - year2 * 12;\n  return new Date(year2, month2, 1);\n}\nvar month = new CountableTimeInterval(encode6, decode6);\nvar month_default = month;\n\n// packages/ag-charts-community/src/util/time/year.ts\nfunction encode7(date) {\n  return date.getFullYear();\n}\nfunction decode7(encoded) {\n  const d = /* @__PURE__ */ new Date();\n  d.setFullYear(encoded);\n  d.setMonth(0, 1);\n  d.setHours(0, 0, 0, 0);\n  return d;\n}\nvar year = new CountableTimeInterval(encode7, decode7);\nvar year_default = year;\n\n// packages/ag-charts-community/src/util/time/utcMinute.ts\nfunction encode8(date) {\n  return Math.floor(date.getTime() / durationMinute);\n}\nfunction decode8(encoded) {\n  return new Date(encoded * durationMinute);\n}\nvar utcMinute = new CountableTimeInterval(encode8, decode8);\n\n// packages/ag-charts-community/src/util/time/utcHour.ts\nfunction encode9(date) {\n  return Math.floor(date.getTime() / durationHour);\n}\nfunction decode9(encoded) {\n  return new Date(encoded * durationHour);\n}\nvar utcHour = new CountableTimeInterval(encode9, decode9);\n\n// packages/ag-charts-community/src/util/time/utcDay.ts\nfunction encode10(date) {\n  return Math.floor(date.getTime() / durationDay);\n}\nfunction decode10(encoded) {\n  const d = /* @__PURE__ */ new Date(0);\n  d.setUTCDate(d.getUTCDate() + encoded);\n  d.setUTCHours(0, 0, 0, 0);\n  return d;\n}\nvar utcDay = new CountableTimeInterval(encode10, decode10);\n\n// packages/ag-charts-community/src/util/time/utcMonth.ts\nfunction encode11(date) {\n  return date.getUTCFullYear() * 12 + date.getUTCMonth();\n}\nfunction decode11(encoded) {\n  const year2 = Math.floor(encoded / 12);\n  const month2 = encoded - year2 * 12;\n  return new Date(Date.UTC(year2, month2, 1));\n}\nvar utcMonth = new CountableTimeInterval(encode11, decode11);\n\n// packages/ag-charts-community/src/util/time/utcYear.ts\nfunction encode12(date) {\n  return date.getUTCFullYear();\n}\nfunction decode12(encoded) {\n  const d = /* @__PURE__ */ new Date();\n  d.setUTCFullYear(encoded);\n  d.setUTCMonth(0, 1);\n  d.setUTCHours(0, 0, 0, 0);\n  return d;\n}\nvar utcYear = new CountableTimeInterval(encode12, decode12);\n\n// packages/ag-charts-community/src/motion/fromToMotion.ts\nvar fromToMotion_exports = {};\n__export(fromToMotion_exports, {\n  NODE_UPDATE_STATE_TO_PHASE_MAPPING: () => NODE_UPDATE_STATE_TO_PHASE_MAPPING,\n  fromToMotion: () => fromToMotion,\n  staticFromToMotion: () => staticFromToMotion\n});\n\n// packages/ag-charts-community/src/util/id.ts\nvar ID_MAP = /* @__PURE__ */ new Map();\nfunction resetIds() {\n  ID_MAP.clear();\n}\nfunction createId(instance) {\n  const constructor = instance.constructor;\n  const className = Object.hasOwn(constructor, \"className\") ? constructor.className : constructor.name;\n  if (!className) {\n    throw new Error(`The ${constructor} is missing the 'className' property.`);\n  }\n  const nextId = (ID_MAP.get(className) ?? 0) + 1;\n  ID_MAP.set(className, nextId);\n  return `${className}-${nextId}`;\n}\nfunction generateUUID() {\n  return crypto.randomUUID?.() ?? generateUUIDv4();\n}\nfunction generateUUIDv4() {\n  const uuidArray = new Uint8Array(16);\n  crypto.getRandomValues(uuidArray);\n  uuidArray[6] = uuidArray[6] & 15 | 64;\n  uuidArray[8] = uuidArray[8] & 63 | 128;\n  let uuid = \"\";\n  for (let i = 0; i < uuidArray.length; i++) {\n    if (i === 4 || i === 6 || i === 8 || i === 10) {\n      uuid += \"-\";\n    }\n    uuid += uuidArray[i].toString(16).padStart(2, \"0\");\n  }\n  return uuid;\n}\n\n// packages/ag-charts-community/src/util/iterator.ts\nfunction* iterate(...iterators) {\n  for (const iterator of iterators) {\n    yield* iterator;\n  }\n}\nfunction toIterable(value) {\n  return value != null && typeof value === \"object\" && Symbol.iterator in value ? value : [value];\n}\n\n// packages/ag-charts-community/src/util/interpolating.ts\nvar interpolate = Symbol(\"interpolate\");\nvar isInterpolating = (x) => x[interpolate] != null;\n\n// packages/ag-charts-community/src/util/nearest.ts\nfunction nearestSquared(x, y, objects, maxDistanceSquared = Infinity) {\n  const result = { nearest: void 0, distanceSquared: maxDistanceSquared };\n  for (const obj of objects) {\n    const thisDistance = obj.distanceSquared(x, y);\n    if (thisDistance === 0) {\n      return { nearest: obj, distanceSquared: 0 };\n    } else if (thisDistance < result.distanceSquared) {\n      result.nearest = obj;\n      result.distanceSquared = thisDistance;\n    }\n  }\n  return result;\n}\nfunction nearestSquaredInContainer(x, y, container, maxDistanceSquared = Infinity) {\n  const { x: tx = x, y: ty = y } = container.transformPoint?.(x, y) ?? {};\n  const result = { nearest: void 0, distanceSquared: maxDistanceSquared };\n  for (const child of container.children) {\n    const { nearest, distanceSquared: distanceSquared3 } = child.nearestSquared(tx, ty, result.distanceSquared);\n    if (distanceSquared3 === 0) {\n      return { nearest, distanceSquared: distanceSquared3 };\n    } else if (distanceSquared3 < result.distanceSquared) {\n      result.nearest = nearest;\n      result.distanceSquared = distanceSquared3;\n    }\n  }\n  return result;\n}\n\n// packages/ag-charts-community/src/util/dom.ts\nvar verifiedGlobals = {};\nif (typeof window !== \"undefined\") {\n  verifiedGlobals.window = window;\n} else if (typeof global !== \"undefined\") {\n  verifiedGlobals.window = global.window;\n}\nif (typeof document !== \"undefined\") {\n  verifiedGlobals.document = document;\n} else if (typeof global !== \"undefined\") {\n  verifiedGlobals.document = global.document;\n}\nfunction getDocument(propertyName) {\n  return propertyName ? verifiedGlobals.document?.[propertyName] : verifiedGlobals.document;\n}\nfunction getWindow(propertyName) {\n  return propertyName ? verifiedGlobals.window?.[propertyName] : verifiedGlobals.window;\n}\nfunction createElement(tagName, className, style) {\n  const element2 = getDocument().createElement(tagName);\n  if (typeof className === \"object\") {\n    style = className;\n    className = void 0;\n  }\n  if (className) {\n    for (const name of className.split(\" \")) {\n      element2.classList.add(name);\n    }\n  }\n  if (style) {\n    Object.assign(element2.style, style);\n  }\n  return element2;\n}\nfunction createElementNS(namespaceURI, qualifiedName) {\n  return getDocument().createElementNS(namespaceURI, qualifiedName);\n}\nfunction downloadUrl(dataUrl, fileName) {\n  const { body } = getDocument();\n  const element2 = createElement(\"a\", { display: \"none\" });\n  element2.href = dataUrl;\n  element2.download = fileName;\n  body.appendChild(element2);\n  element2.click();\n  setTimeout(() => body.removeChild(element2));\n}\nfunction setDocument(document2) {\n  verifiedGlobals.document = document2;\n}\nfunction setWindow(window2) {\n  verifiedGlobals.window = window2;\n}\nfunction setElementBBox(element2, bbox) {\n  if (element2) {\n    element2.style.width = `${bbox.width}px`;\n    element2.style.height = `${bbox.height}px`;\n    element2.style.left = `${bbox.x}px`;\n    element2.style.top = `${bbox.y}px`;\n  }\n}\nfunction focusCursorAtEnd(element2) {\n  element2.focus({ preventScroll: true });\n  if (element2.lastChild?.textContent == null)\n    return;\n  const range3 = getDocument().createRange();\n  range3.setStart(element2.lastChild, element2.lastChild.textContent.length);\n  range3.setEnd(element2.lastChild, element2.lastChild.textContent.length);\n  const selection = getWindow().getSelection();\n  selection?.removeAllRanges();\n  selection?.addRange(range3);\n}\nvar _id = 0;\nfunction createElementId(label) {\n  return `${label ?? \"ag-charts-element\"}-${_id++}`;\n}\n\n// packages/ag-charts-community/src/util/number.ts\nfunction clamp(min, value, max) {\n  return Math.min(max, Math.max(min, value));\n}\nfunction clampArray(value, array2) {\n  const [min, max] = findMinMax(array2);\n  return clamp(min, value, max);\n}\nfunction findMinMax(array2) {\n  if (array2.length === 0)\n    return [];\n  const result = [Infinity, -Infinity];\n  for (const val of array2) {\n    if (val < result[0])\n      result[0] = val;\n    if (val > result[1])\n      result[1] = val;\n  }\n  return result;\n}\nfunction findRangeExtent(array2) {\n  const [min, max] = findMinMax(array2);\n  return max - min;\n}\nfunction isEqual(a, b, epsilon2 = 1e-10) {\n  return Math.abs(a - b) < epsilon2;\n}\nfunction isNegative(value) {\n  return Math.sign(value) === -1 || Object.is(value, -0);\n}\nfunction round(value, decimals = 2) {\n  const base = 10 ** decimals;\n  return Math.round(value * base) / base;\n}\nfunction toFixed(value, fractionOrSignificantDigits = 2) {\n  const power = Math.floor(Math.log(Math.abs(value)) / Math.LN10);\n  if (power >= 0 || !isFinite(power)) {\n    return value.toFixed(fractionOrSignificantDigits);\n  }\n  return value.toFixed(Math.abs(power) - 1 + fractionOrSignificantDigits);\n}\nfunction mod(n, m) {\n  return Math.floor(n % m + (n < 0 ? m : 0));\n}\nfunction countFractionDigits(value) {\n  if (Math.floor(value) === value)\n    return 0;\n  let valueString = String(value);\n  let exponent = 0;\n  if (value < 1e-6 || value >= 1e21) {\n    let exponentString;\n    [valueString, exponentString] = valueString.split(\"e\");\n    if (exponentString != null) {\n      exponent = Number(exponentString);\n    }\n  }\n  const decimalPlaces2 = valueString.split(\".\")[1]?.length ?? 0;\n  return Math.max(decimalPlaces2 - exponent, 0);\n}\nfunction formatNormalizedPercentage(ratio2, locale) {\n  locale = locale ?? getWindow(\"navigator\").language;\n  return new Intl.NumberFormat(locale, {\n    style: \"percent\",\n    minimumFractionDigits: 2,\n    maximumFractionDigits: 2\n  }).format(ratio2);\n}\nfunction formatPercentage(percent, locale) {\n  return formatNormalizedPercentage(percent / 100, locale);\n}\n\n// packages/ag-charts-community/src/scene/bbox.ts\nvar _BBox = class _BBox {\n  constructor(x, y, width2, height2) {\n    this.x = x;\n    this.y = y;\n    this.width = width2;\n    this.height = height2;\n  }\n  static fromDOMRect({ x, y, width: width2, height: height2 }) {\n    return new _BBox(x, y, width2, height2);\n  }\n  toDOMRect() {\n    return {\n      x: this.x,\n      y: this.y,\n      width: this.width,\n      height: this.height,\n      top: this.y,\n      left: this.x,\n      right: this.x + this.width,\n      bottom: this.y + this.height,\n      toJSON() {\n        return {};\n      }\n    };\n  }\n  clone() {\n    const { x, y, width: width2, height: height2 } = this;\n    return new _BBox(x, y, width2, height2);\n  }\n  equals(other) {\n    return this.x === other.x && this.y === other.y && this.width === other.width && this.height === other.height;\n  }\n  containsPoint(x, y) {\n    return x >= this.x && x <= this.x + this.width && y >= this.y && y <= this.y + this.height;\n  }\n  intersection(other) {\n    if (!this.collidesBBox(other))\n      return;\n    const newX1 = clamp(other.x, this.x, other.x + other.width);\n    const newY1 = clamp(other.y, this.y, other.y + other.height);\n    const newX2 = clamp(other.x, this.x + this.width, other.x + other.width);\n    const newY2 = clamp(other.y, this.y + this.height, other.y + other.height);\n    return new _BBox(newX1, newY1, newX2 - newX1, newY2 - newY1);\n  }\n  collidesBBox(other) {\n    return this.x < other.x + other.width && this.x + this.width > other.x && this.y < other.y + other.height && this.y + this.height > other.y;\n  }\n  computeCenter() {\n    return { x: this.x + this.width / 2, y: this.y + this.height / 2 };\n  }\n  isFinite() {\n    return Number.isFinite(this.x) && Number.isFinite(this.y) && Number.isFinite(this.width) && Number.isFinite(this.height);\n  }\n  distanceSquared(x, y) {\n    if (this.containsPoint(x, y)) {\n      return 0;\n    }\n    const dx = x - clamp(this.x, x, this.x + this.width);\n    const dy = y - clamp(this.y, y, this.y + this.height);\n    return dx * dx + dy * dy;\n  }\n  static nearestBox(x, y, boxes) {\n    return nearestSquared(x, y, boxes);\n  }\n  clip(clipRect) {\n    if (clipRect === void 0)\n      return this;\n    const x1 = Math.max(this.x, clipRect.x);\n    const y1 = Math.max(this.y, clipRect.y);\n    const x2 = Math.min(this.x + this.width, clipRect.x + clipRect.width);\n    const y2 = Math.min(this.y + this.height, clipRect.y + clipRect.height);\n    this.x = x1;\n    this.y = y1;\n    this.width = Math.max(0, x2 - x1);\n    this.height = Math.max(0, y2 - y1);\n    return this;\n  }\n  shrink(amount, position) {\n    const apply2 = (pos, amt) => {\n      switch (pos) {\n        case \"top\":\n          this.y += amt;\n        case \"bottom\":\n          this.height -= amt;\n          break;\n        case \"left\":\n          this.x += amt;\n        case \"right\":\n          this.width -= amt;\n          break;\n        case \"vertical\":\n          this.y += amt;\n          this.height -= amt * 2;\n          break;\n        case \"horizontal\":\n          this.x += amt;\n          this.width -= amt * 2;\n          break;\n        case void 0:\n          this.x += amt;\n          this.width -= amt * 2;\n          this.y += amt;\n          this.height -= amt * 2;\n          break;\n        default:\n      }\n    };\n    if (typeof amount === \"number\") {\n      apply2(position, amount);\n    } else if (typeof amount === \"object\") {\n      Object.entries(amount).forEach(([pos, amt]) => apply2(pos, amt));\n    }\n    return this;\n  }\n  grow(amount, position) {\n    if (typeof amount === \"number\") {\n      this.shrink(-amount, position);\n    } else {\n      const paddingCopy = { ...amount };\n      for (const key in paddingCopy) {\n        paddingCopy[key] *= -1;\n      }\n      this.shrink(paddingCopy);\n    }\n    return this;\n  }\n  translate(x, y) {\n    this.x += x;\n    this.y += y;\n    return this;\n  }\n  combine(other) {\n    const { x, y, width: width2, height: height2 } = this;\n    this.x = Math.min(x, other.x);\n    this.y = Math.min(y, other.y);\n    this.width = Math.max(x + width2, other.x + other.width) - this.x;\n    this.height = Math.max(y + height2, other.y + other.height) - this.y;\n  }\n  static merge(boxes) {\n    let left = Infinity;\n    let top = Infinity;\n    let right = -Infinity;\n    let bottom = -Infinity;\n    for (const box of boxes) {\n      if (box.x < left) {\n        left = box.x;\n      }\n      if (box.y < top) {\n        top = box.y;\n      }\n      if (box.x + box.width > right) {\n        right = box.x + box.width;\n      }\n      if (box.y + box.height > bottom) {\n        bottom = box.y + box.height;\n      }\n    }\n    return new _BBox(left, top, right - left, bottom - top);\n  }\n  [interpolate](other, d) {\n    return new _BBox(\n      this.x * (1 - d) + other.x * d,\n      this.y * (1 - d) + other.y * d,\n      this.width * (1 - d) + other.width * d,\n      this.height * (1 - d) + other.height * d\n    );\n  }\n};\n_BBox.zero = Object.freeze(new _BBox(0, 0, 0, 0));\n_BBox.NaN = Object.freeze(new _BBox(NaN, NaN, NaN, NaN));\nvar BBox = _BBox;\n\n// packages/ag-charts-community/src/scene/changeDetectable.ts\nvar RedrawType = /* @__PURE__ */ ((RedrawType2) => {\n  RedrawType2[RedrawType2[\"NONE\"] = 0] = \"NONE\";\n  RedrawType2[RedrawType2[\"TRIVIAL\"] = 1] = \"TRIVIAL\";\n  RedrawType2[RedrawType2[\"MINOR\"] = 2] = \"MINOR\";\n  RedrawType2[RedrawType2[\"MAJOR\"] = 3] = \"MAJOR\";\n  return RedrawType2;\n})(RedrawType || {});\nfunction SceneChangeDetection(opts) {\n  return function(target, key) {\n    const privateKey = `__${key}`;\n    if (target[key]) {\n      return;\n    }\n    prepareGetSet(target, key, privateKey, opts);\n  };\n}\nfunction prepareGetSet(target, key, privateKey, opts) {\n  const {\n    redraw = 1 /* TRIVIAL */,\n    type = \"normal\",\n    changeCb,\n    convertor,\n    checkDirtyOnAssignment = false\n  } = opts ?? {};\n  const requiredOpts = { redraw, type, changeCb, checkDirtyOnAssignment, convertor };\n  let setter;\n  switch (type) {\n    case \"normal\":\n      setter = buildNormalSetter(privateKey, requiredOpts);\n      break;\n    case \"transform\":\n      setter = buildTransformSetter(privateKey, requiredOpts);\n      break;\n    case \"path\":\n      setter = buildPathSetter(privateKey, requiredOpts);\n      break;\n  }\n  setter = buildCheckDirtyChain(\n    buildChangeCallbackChain(buildConvertorChain(setter, requiredOpts), requiredOpts),\n    requiredOpts\n  );\n  const getter = function() {\n    return this[privateKey];\n  };\n  Object.defineProperty(target, key, {\n    set: setter,\n    get: getter,\n    enumerable: true,\n    configurable: true\n  });\n}\nfunction buildConvertorChain(setterFn, opts) {\n  const { convertor } = opts;\n  if (convertor) {\n    return function(value) {\n      setterFn.call(this, convertor(value));\n    };\n  }\n  return setterFn;\n}\nvar NO_CHANGE = Symbol(\"no-change\");\nfunction buildChangeCallbackChain(setterFn, opts) {\n  const { changeCb } = opts;\n  if (changeCb) {\n    return function(value) {\n      const change = setterFn.call(this, value);\n      if (change !== NO_CHANGE) {\n        changeCb.call(this, this);\n      }\n      return change;\n    };\n  }\n  return setterFn;\n}\nfunction buildCheckDirtyChain(setterFn, opts) {\n  const { checkDirtyOnAssignment } = opts;\n  if (checkDirtyOnAssignment) {\n    return function(value) {\n      const change = setterFn.call(this, value);\n      if (change !== NO_CHANGE && value != null && value._dirty > 0 /* NONE */) {\n        this.markDirty(value._dirty);\n      }\n      return change;\n    };\n  }\n  return setterFn;\n}\nfunction buildNormalSetter(privateKey, opts) {\n  const { redraw = 1 /* TRIVIAL */, changeCb } = opts;\n  return function(value) {\n    const oldValue = this[privateKey];\n    if (value !== oldValue) {\n      this[privateKey] = value;\n      this.markDirty(redraw);\n      changeCb?.(this);\n      return value;\n    }\n    return NO_CHANGE;\n  };\n}\nfunction buildTransformSetter(privateKey, opts) {\n  const { redraw = 1 /* TRIVIAL */ } = opts;\n  return function(value) {\n    const oldValue = this[privateKey];\n    if (value !== oldValue) {\n      this[privateKey] = value;\n      this.markDirtyTransform(redraw);\n      return value;\n    }\n    return NO_CHANGE;\n  };\n}\nfunction buildPathSetter(privateKey, opts) {\n  const { redraw = 1 /* TRIVIAL */ } = opts;\n  return function(value) {\n    const oldValue = this[privateKey];\n    if (value !== oldValue) {\n      this[privateKey] = value;\n      if (!this._dirtyPath) {\n        this._dirtyPath = true;\n        this.markDirty(redraw);\n      }\n      return value;\n    }\n    return NO_CHANGE;\n  };\n}\n\n// packages/ag-charts-community/src/scene/node.ts\nvar PointerEvents = /* @__PURE__ */ ((PointerEvents2) => {\n  PointerEvents2[PointerEvents2[\"All\"] = 0] = \"All\";\n  PointerEvents2[PointerEvents2[\"None\"] = 1] = \"None\";\n  return PointerEvents2;\n})(PointerEvents || {});\nvar _Node = class _Node {\n  // Discriminators for render order within a zIndex\n  constructor(options) {\n    /** Unique number to allow creation order to be easily determined. */\n    this.serialNumber = _Node._nextSerialNumber++;\n    this.childNodeCounts = { groups: 0, nonGroups: 0 };\n    /** Unique node ID in the form `ClassName-NaturalNumber`. */\n    this.id = createId(this);\n    this.pointerEvents = 0 /* All */;\n    this._dirty = 3 /* MAJOR */;\n    this.dirtyZIndex = false;\n    this.virtualChildrenCount = 0;\n    /**\n     * To simplify the type system (especially in Selections) we don't have the `Parent` node\n     * (one that has children). Instead, we mimic HTML DOM, where any node can have children.\n     * But we still need to distinguish regular leaf nodes from container leafs somehow.\n     */\n    this.isContainerNode = false;\n    this.visible = true;\n    this.zIndex = 0;\n    this.zIndexSubOrder = void 0;\n    this.name = options?.name;\n    this.isVirtual = options?.isVirtual ?? false;\n    this.tag = options?.tag ?? NaN;\n    this.zIndex = options?.zIndex ?? 0;\n  }\n  static *extractBBoxes(nodes, skipInvisible) {\n    for (const n of nodes) {\n      if (!skipInvisible || n.visible && !n.transitionOut) {\n        const bbox = n.getBBox();\n        if (bbox)\n          yield bbox;\n      }\n    }\n  }\n  /**\n   * Some arbitrary data bound to the node.\n   */\n  get datum() {\n    return this._datum ?? this.parentNode?.datum;\n  }\n  set datum(datum) {\n    if (this._datum !== datum) {\n      this._previousDatum = this._datum;\n      this._datum = datum;\n    }\n  }\n  get previousDatum() {\n    return this._previousDatum;\n  }\n  get layerManager() {\n    return this._layerManager;\n  }\n  get dirty() {\n    return this._dirty;\n  }\n  /** Perform any pre-rendering initialization. */\n  preRender() {\n    this.childNodeCounts.groups = 0;\n    this.childNodeCounts.nonGroups = 1;\n    for (const child of this.children()) {\n      const childCounts = child.preRender();\n      this.childNodeCounts.groups += childCounts.groups;\n      this.childNodeCounts.nonGroups += childCounts.nonGroups;\n    }\n    return this.childNodeCounts;\n  }\n  render(renderCtx) {\n    const { stats } = renderCtx;\n    this._dirty = 0 /* NONE */;\n    if (renderCtx.debugNodeSearch) {\n      const idOrName = this.name ?? this.id;\n      if (renderCtx.debugNodeSearch.some((v) => typeof v === \"string\" ? v === idOrName : v.test(idOrName))) {\n        renderCtx.debugNodes[this.name ?? this.id] = this;\n      }\n    }\n    if (stats) {\n      stats.nodesRendered++;\n    }\n  }\n  _setLayerManager(value) {\n    this._layerManager = value;\n    this._debug = value?.debug;\n    for (const child of this.children(false)) {\n      child._setLayerManager(value);\n    }\n  }\n  sortChildren(compareFn) {\n    this.dirtyZIndex = false;\n    if (!this.childNodes)\n      return;\n    if (this.hasVirtualChildren())\n      return;\n    const sortedChildren = [...this.childNodes].sort(compareFn);\n    this.childNodes.clear();\n    for (const child of sortedChildren) {\n      this.childNodes.add(child);\n    }\n  }\n  *traverseUp(includeSelf) {\n    let node = this;\n    if (includeSelf) {\n      yield node;\n    }\n    while (node = node.parentNode) {\n      yield node;\n    }\n  }\n  *children(flattenVirtual = true) {\n    if (!this.childNodes)\n      return;\n    const virtualChildren = [];\n    for (const child of this.childNodes) {\n      if (flattenVirtual && child.isVirtual) {\n        virtualChildren.push(child.children());\n      } else {\n        yield child;\n      }\n    }\n    for (const vChildren of virtualChildren) {\n      yield* vChildren;\n    }\n  }\n  *virtualChildren() {\n    if (!this.childNodes || !this.virtualChildrenCount)\n      return;\n    for (const child of this.childNodes) {\n      if (child.isVirtual) {\n        yield child;\n      }\n    }\n  }\n  hasVirtualChildren() {\n    return this.virtualChildrenCount > 0;\n  }\n  /**\n   * Checks if the node is a leaf (has no children).\n   */\n  isLeaf() {\n    return !this.childNodes?.size;\n  }\n  /**\n   * Checks if the node is the root (has no parent).\n   */\n  isRoot() {\n    return !this.parentNode;\n  }\n  /**\n   * Appends one or more new node instances to this parent.\n   * If one needs to:\n   * - move a child to the end of the list of children\n   * - move a child from one parent to another (including parents in other scenes)\n   * one should use the {@link insertBefore} method instead.\n   * @param nodes A node or nodes to append.\n   */\n  append(nodes) {\n    this.childNodes ?? (this.childNodes = /* @__PURE__ */ new Set());\n    for (const node of toIterable(nodes)) {\n      node.parentNode?.removeChild(node);\n      this.childNodes.add(node);\n      node.parentNode = this;\n      node._setLayerManager(this.layerManager);\n      if (node.isVirtual) {\n        this.virtualChildrenCount++;\n      }\n    }\n    this.invalidateCachedBBox();\n    this.dirtyZIndex = true;\n    this.markDirty(3 /* MAJOR */);\n  }\n  appendChild(node) {\n    this.append(node);\n    return node;\n  }\n  removeChild(node) {\n    if (!this.childNodes?.delete(node)) {\n      return false;\n    }\n    delete node.parentNode;\n    node._setLayerManager();\n    if (node.isVirtual) {\n      this.virtualChildrenCount--;\n    }\n    this.invalidateCachedBBox();\n    this.dirtyZIndex = true;\n    this.markDirty(3 /* MAJOR */);\n    return true;\n  }\n  remove() {\n    return this.parentNode?.removeChild(this) ?? false;\n  }\n  clear() {\n    for (const child of this.children(false)) {\n      delete child.parentNode;\n      child._setLayerManager();\n    }\n    this.childNodes?.clear();\n    this.invalidateCachedBBox();\n    this.virtualChildrenCount = 0;\n  }\n  destroy() {\n    this.parentNode?.removeChild(this);\n  }\n  setProperties(styles, pickKeys) {\n    if (pickKeys) {\n      for (const key of pickKeys) {\n        this[key] = styles[key];\n      }\n    } else {\n      Object.assign(this, styles);\n    }\n    return this;\n  }\n  containsPoint(_x, _y) {\n    return false;\n  }\n  /**\n   * Hit testing method.\n   * Recursively checks if the given point is inside this node or any of its children.\n   * Returns the first matching node or `undefined`.\n   * Nodes that render later (show on top) are hit tested first.\n   */\n  pickNode(x, y, _localCoords = false) {\n    if (!this.visible || this.pointerEvents === 1 /* None */ || !this.containsPoint(x, y)) {\n      return;\n    }\n    const children = [...this.children()];\n    if (children.length > 1e3) {\n      for (let i = children.length - 1; i >= 0; i--) {\n        const child = children[i];\n        const containsPoint2 = child.containsPoint(x, y);\n        const hit = containsPoint2 ? child.pickNode(x, y) : void 0;\n        if (hit) {\n          return hit;\n        }\n      }\n    } else if (children.length) {\n      for (let i = children.length - 1; i >= 0; i--) {\n        const hit = children[i].pickNode(x, y);\n        if (hit) {\n          return hit;\n        }\n      }\n    } else if (!this.isContainerNode) {\n      return this;\n    }\n  }\n  invalidateCachedBBox() {\n    this.cachedBBox = void 0;\n    this.parentNode?.invalidateCachedBBox();\n  }\n  getBBox() {\n    if (this.cachedBBox == null) {\n      this.cachedBBox = Object.freeze(this.computeBBox());\n    }\n    return this.cachedBBox;\n  }\n  computeBBox() {\n    return;\n  }\n  markDirty(type = 1 /* TRIVIAL */, parentType = type) {\n    const { _dirty } = this;\n    const dirtyTypeBelowHighWatermark = _dirty > type || _dirty === type && type === parentType;\n    const noParentCachedBBox = this.cachedBBox == null;\n    if (noParentCachedBBox && dirtyTypeBelowHighWatermark)\n      return;\n    this.invalidateCachedBBox();\n    this._dirty = Math.max(_dirty, type);\n    if (this.parentNode) {\n      this.parentNode.markDirty(parentType);\n    } else if (this.layerManager) {\n      this.layerManager.markDirty();\n    }\n  }\n  markClean(opts) {\n    const { force = false, recursive = true } = opts ?? {};\n    if (this._dirty === 0 /* NONE */ && !force)\n      return;\n    this._dirty = 0 /* NONE */;\n    for (const child of this.children(false)) {\n      if (child.isVirtual ? recursive !== false : recursive === true) {\n        child.markClean({ force });\n      }\n    }\n  }\n  onVisibleChange() {\n  }\n  onZIndexChange() {\n    if (this.parentNode) {\n      this.parentNode.dirtyZIndex = true;\n    }\n  }\n  toSVG() {\n    return;\n  }\n};\n_Node._nextSerialNumber = 0;\n__decorateClass([\n  SceneChangeDetection({\n    redraw: 3 /* MAJOR */,\n    changeCb: (target) => target.onVisibleChange()\n  })\n], _Node.prototype, \"visible\", 2);\n__decorateClass([\n  SceneChangeDetection({\n    redraw: 1 /* TRIVIAL */,\n    changeCb: (target) => target.onZIndexChange()\n  })\n], _Node.prototype, \"zIndex\", 2);\n__decorateClass([\n  SceneChangeDetection({\n    redraw: 1 /* TRIVIAL */,\n    changeCb: (target) => target.onZIndexChange()\n  })\n], _Node.prototype, \"zIndexSubOrder\", 2);\nvar Node = _Node;\n\n// packages/ag-charts-community/src/util/color.ts\nvar lerp = (x, y, t) => x * (1 - t) + y * t;\nvar srgbToLinear = (value) => {\n  const sign = value < 0 ? -1 : 1;\n  const abs = Math.abs(value);\n  if (abs <= 0.04045)\n    return value / 12.92;\n  return sign * ((abs + 0.055) / 1.055) ** 2.4;\n};\nvar srgbFromLinear = (value) => {\n  const sign = value < 0 ? -1 : 1;\n  const abs = Math.abs(value);\n  if (abs > 31308e-7) {\n    return sign * (1.055 * abs ** (1 / 2.4) - 0.055);\n  }\n  return 12.92 * value;\n};\nvar _Color = class _Color {\n  /**\n   * Every color component should be in the [0, 1] range.\n   * Some easing functions (such as elastic easing) can overshoot the target value by some amount.\n   * So, when animating colors, if the source or target color components are already near\n   * or at the edge of the allowed [0, 1] range, it is possible for the intermediate color\n   * component value to end up outside of that range mid-animation. For this reason the constructor\n   * performs range checking/constraining.\n   * @param r Red component.\n   * @param g Green component.\n   * @param b Blue component.\n   * @param a Alpha (opacity) component.\n   */\n  constructor(r, g, b, a = 1) {\n    this.r = clamp(0, r || 0, 1);\n    this.g = clamp(0, g || 0, 1);\n    this.b = clamp(0, b || 0, 1);\n    this.a = clamp(0, a || 0, 1);\n  }\n  /**\n   * A color string can be in one of the following formats to be valid:\n   * - #rgb\n   * - #rrggbb\n   * - rgb(r, g, b)\n   * - rgba(r, g, b, a)\n   * - CSS color name such as 'white', 'orange', 'cyan', etc.\n   */\n  static validColorString(str) {\n    if (str.indexOf(\"#\") >= 0) {\n      return !!_Color.parseHex(str);\n    }\n    if (str.indexOf(\"rgb\") >= 0) {\n      return !!_Color.stringToRgba(str);\n    }\n    return !!_Color.nameToHex[str.toLowerCase()];\n  }\n  /**\n   * The given string can be in one of the following formats:\n   * - #rgb\n   * - #rrggbb\n   * - rgb(r, g, b)\n   * - rgba(r, g, b, a)\n   * - CSS color name such as 'white', 'orange', 'cyan', etc.\n   * @param str\n   */\n  static fromString(str) {\n    if (str.indexOf(\"#\") >= 0) {\n      return _Color.fromHexString(str);\n    }\n    const hex = _Color.nameToHex[str.toLowerCase()];\n    if (hex) {\n      return _Color.fromHexString(hex);\n    }\n    if (str.indexOf(\"rgb\") >= 0) {\n      return _Color.fromRgbaString(str);\n    }\n    throw new Error(`Invalid color string: '${str}'`);\n  }\n  // See https://drafts.csswg.org/css-color/#hex-notation\n  static parseHex(input) {\n    input = input.replace(/ /g, \"\").slice(1);\n    let parts;\n    switch (input.length) {\n      case 6:\n      case 8:\n        parts = [];\n        for (let i = 0; i < input.length; i += 2) {\n          parts.push(parseInt(`${input[i]}${input[i + 1]}`, 16));\n        }\n        break;\n      case 3:\n      case 4:\n        parts = input.split(\"\").map((p) => parseInt(p, 16)).map((p) => p + p * 16);\n        break;\n    }\n    if (parts?.length >= 3 && parts.every((p) => p >= 0)) {\n      if (parts.length === 3) {\n        parts.push(255);\n      }\n      return parts;\n    }\n  }\n  static fromHexString(str) {\n    const values = _Color.parseHex(str);\n    if (values) {\n      const [r, g, b, a] = values;\n      return new _Color(r / 255, g / 255, b / 255, a / 255);\n    }\n    throw new Error(`Malformed hexadecimal color string: '${str}'`);\n  }\n  static stringToRgba(str) {\n    let po = -1;\n    let pc = -1;\n    for (let i = 0; i < str.length; i++) {\n      const c = str[i];\n      if (po === -1 && c === \"(\") {\n        po = i;\n      } else if (c === \")\") {\n        pc = i;\n        break;\n      }\n    }\n    if (po === -1 || pc === -1)\n      return;\n    const contents = str.substring(po + 1, pc);\n    const parts = contents.split(\",\");\n    const rgba = [];\n    for (let i = 0; i < parts.length; i++) {\n      const part = parts[i];\n      let value = parseFloat(part);\n      if (!Number.isFinite(value)) {\n        return;\n      }\n      if (part.indexOf(\"%\") >= 0) {\n        value = clamp(0, value, 100);\n        value /= 100;\n      } else if (i === 3) {\n        value = clamp(0, value, 1);\n      } else {\n        value = clamp(0, value, 255);\n        value /= 255;\n      }\n      rgba.push(value);\n    }\n    return rgba;\n  }\n  static fromRgbaString(str) {\n    const rgba = _Color.stringToRgba(str);\n    if (rgba) {\n      if (rgba.length === 3) {\n        return new _Color(rgba[0], rgba[1], rgba[2]);\n      } else if (rgba.length === 4) {\n        return new _Color(rgba[0], rgba[1], rgba[2], rgba[3]);\n      }\n    }\n    throw new Error(`Malformed rgb/rgba color string: '${str}'`);\n  }\n  static fromArray(arr) {\n    if (arr.length === 4) {\n      return new _Color(arr[0], arr[1], arr[2], arr[3]);\n    }\n    if (arr.length === 3) {\n      return new _Color(arr[0], arr[1], arr[2]);\n    }\n    throw new Error(\"The given array should contain 3 or 4 color components (numbers).\");\n  }\n  static fromHSB(h, s, b, alpha = 1) {\n    const rgb = _Color.HSBtoRGB(h, s, b);\n    return new _Color(rgb[0], rgb[1], rgb[2], alpha);\n  }\n  static fromHSL(h, s, l, alpha = 1) {\n    const rgb = _Color.HSLtoRGB(h, s, l);\n    return new _Color(rgb[0], rgb[1], rgb[2], alpha);\n  }\n  static fromOKLCH(l, c, h, alpha = 1) {\n    const rgb = _Color.OKLCHtoRGB(l, c, h);\n    return new _Color(rgb[0], rgb[1], rgb[2], alpha);\n  }\n  static padHex(str) {\n    return str.length === 1 ? \"0\" + str : str;\n  }\n  toHexString() {\n    let hex = \"#\" + _Color.padHex(Math.round(this.r * 255).toString(16)) + _Color.padHex(Math.round(this.g * 255).toString(16)) + _Color.padHex(Math.round(this.b * 255).toString(16));\n    if (this.a < 1) {\n      hex += _Color.padHex(Math.round(this.a * 255).toString(16));\n    }\n    return hex;\n  }\n  toRgbaString(fractionDigits = 3) {\n    const components = [Math.round(this.r * 255), Math.round(this.g * 255), Math.round(this.b * 255)];\n    const k = Math.pow(10, fractionDigits);\n    if (this.a !== 1) {\n      components.push(Math.round(this.a * k) / k);\n      return `rgba(${components.join(\", \")})`;\n    }\n    return `rgb(${components.join(\", \")})`;\n  }\n  toString() {\n    if (this.a === 1) {\n      return this.toHexString();\n    }\n    return this.toRgbaString();\n  }\n  toHSB() {\n    return _Color.RGBtoHSB(this.r, this.g, this.b);\n  }\n  static RGBtoOKLCH(r, g, b) {\n    const LSRGB0 = srgbToLinear(r);\n    const LSRGB1 = srgbToLinear(g);\n    const LSRGB2 = srgbToLinear(b);\n    const LMS0 = Math.cbrt(0.4122214708 * LSRGB0 + 0.5363325363 * LSRGB1 + 0.0514459929 * LSRGB2);\n    const LMS1 = Math.cbrt(0.2119034982 * LSRGB0 + 0.6806995451 * LSRGB1 + 0.1073969566 * LSRGB2);\n    const LMS2 = Math.cbrt(0.0883024619 * LSRGB0 + 0.2817188376 * LSRGB1 + 0.6299787005 * LSRGB2);\n    const OKLAB0 = 0.2104542553 * LMS0 + 0.793617785 * LMS1 - 0.0040720468 * LMS2;\n    const OKLAB1 = 1.9779984951 * LMS0 - 2.428592205 * LMS1 + 0.4505937099 * LMS2;\n    const OKLAB2 = 0.0259040371 * LMS0 + 0.7827717662 * LMS1 - 0.808675766 * LMS2;\n    const hue = Math.atan2(OKLAB2, OKLAB1) * 180 / Math.PI;\n    const OKLCH0 = OKLAB0;\n    const OKLCH1 = Math.hypot(OKLAB1, OKLAB2);\n    const OKLCH2 = hue >= 0 ? hue : hue + 360;\n    return [OKLCH0, OKLCH1, OKLCH2];\n  }\n  static OKLCHtoRGB(l, c, h) {\n    const OKLAB0 = l;\n    const OKLAB1 = c * Math.cos(h * Math.PI / 180);\n    const OKLAB2 = c * Math.sin(h * Math.PI / 180);\n    const LMS0 = (OKLAB0 + 0.3963377774 * OKLAB1 + 0.2158037573 * OKLAB2) ** 3;\n    const LMS1 = (OKLAB0 - 0.1055613458 * OKLAB1 - 0.0638541728 * OKLAB2) ** 3;\n    const LMS2 = (OKLAB0 - 0.0894841775 * OKLAB1 - 1.291485548 * OKLAB2) ** 3;\n    const LSRGB0 = 4.0767416621 * LMS0 - 3.3077115913 * LMS1 + 0.2309699292 * LMS2;\n    const LSRGB1 = -1.2684380046 * LMS0 + 2.6097574011 * LMS1 - 0.3413193965 * LMS2;\n    const LSRGB2 = -0.0041960863 * LMS0 - 0.7034186147 * LMS1 + 1.707614701 * LMS2;\n    const SRGB0 = srgbFromLinear(LSRGB0);\n    const SRGB1 = srgbFromLinear(LSRGB1);\n    const SRGB2 = srgbFromLinear(LSRGB2);\n    return [SRGB0, SRGB1, SRGB2];\n  }\n  static RGBtoHSL(r, g, b) {\n    const min = Math.min(r, g, b);\n    const max = Math.max(r, g, b);\n    const l = (max + min) / 2;\n    let h;\n    let s;\n    if (max === min) {\n      h = 0;\n      s = 0;\n    } else {\n      const delta4 = max - min;\n      s = l > 0.5 ? delta4 / (2 - max - min) : delta4 / (max + min);\n      if (max === r) {\n        h = (g - b) / delta4 + (g < b ? 6 : 0);\n      } else if (max === g) {\n        h = (b - r) / delta4 + 2;\n      } else {\n        h = (r - g) / delta4 + 4;\n      }\n      h *= 360 / 6;\n    }\n    return [h, s, l];\n  }\n  static HSLtoRGB(h, s, l) {\n    h = (h % 360 + 360) % 360;\n    if (s === 0) {\n      return [l, l, l];\n    }\n    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n    const p = 2 * l - q;\n    function hueToRgb(t) {\n      if (t < 0)\n        t += 1;\n      if (t > 1)\n        t -= 1;\n      if (t < 1 / 6)\n        return p + (q - p) * 6 * t;\n      if (t < 1 / 2)\n        return q;\n      if (t < 2 / 3)\n        return p + (q - p) * (2 / 3 - t) * 6;\n      return p;\n    }\n    const r = hueToRgb(h / 360 + 1 / 3);\n    const g = hueToRgb(h / 360);\n    const b = hueToRgb(h / 360 - 1 / 3);\n    return [r, g, b];\n  }\n  /**\n   * Converts the given RGB triple to an array of HSB (HSV) components.\n   */\n  static RGBtoHSB(r, g, b) {\n    const min = Math.min(r, g, b);\n    const max = Math.max(r, g, b);\n    const S = max === 0 ? 0 : (max - min) / max;\n    let H = 0;\n    if (min !== max) {\n      const delta4 = max - min;\n      const rc = (max - r) / delta4;\n      const gc = (max - g) / delta4;\n      const bc = (max - b) / delta4;\n      if (r === max) {\n        H = bc - gc;\n      } else if (g === max) {\n        H = 2 + rc - bc;\n      } else {\n        H = 4 + gc - rc;\n      }\n      H /= 6;\n      if (H < 0) {\n        H = H + 1;\n      }\n    }\n    return [H * 360, S, max];\n  }\n  /**\n   * Converts the given HSB (HSV) triple to an array of RGB components.\n   */\n  static HSBtoRGB(H, S, B) {\n    H = (H % 360 + 360) % 360 / 360;\n    let r = 0;\n    let g = 0;\n    let b = 0;\n    if (S === 0) {\n      r = g = b = B;\n    } else {\n      const h = (H - Math.floor(H)) * 6;\n      const f = h - Math.floor(h);\n      const p = B * (1 - S);\n      const q = B * (1 - S * f);\n      const t = B * (1 - S * (1 - f));\n      switch (h >> 0) {\n        case 0:\n          r = B;\n          g = t;\n          b = p;\n          break;\n        case 1:\n          r = q;\n          g = B;\n          b = p;\n          break;\n        case 2:\n          r = p;\n          g = B;\n          b = t;\n          break;\n        case 3:\n          r = p;\n          g = q;\n          b = B;\n          break;\n        case 4:\n          r = t;\n          g = p;\n          b = B;\n          break;\n        case 5:\n          r = B;\n          g = p;\n          b = q;\n          break;\n      }\n    }\n    return [r, g, b];\n  }\n  static mix(c0, c1, t) {\n    return new _Color(lerp(c0.r, c1.r, t), lerp(c0.g, c1.g, t), lerp(c0.b, c1.b, t), lerp(c0.a, c1.a, t));\n  }\n};\n/**\n * CSS Color Module Level 4:\n * https://drafts.csswg.org/css-color/#named-colors\n */\n_Color.nameToHex = {\n  // @ts-expect-error\n  __proto__: null,\n  aliceblue: \"#F0F8FF\",\n  antiquewhite: \"#FAEBD7\",\n  aqua: \"#00FFFF\",\n  aquamarine: \"#7FFFD4\",\n  azure: \"#F0FFFF\",\n  beige: \"#F5F5DC\",\n  bisque: \"#FFE4C4\",\n  black: \"#000000\",\n  blanchedalmond: \"#FFEBCD\",\n  blue: \"#0000FF\",\n  blueviolet: \"#8A2BE2\",\n  brown: \"#A52A2A\",\n  burlywood: \"#DEB887\",\n  cadetblue: \"#5F9EA0\",\n  chartreuse: \"#7FFF00\",\n  chocolate: \"#D2691E\",\n  coral: \"#FF7F50\",\n  cornflowerblue: \"#6495ED\",\n  cornsilk: \"#FFF8DC\",\n  crimson: \"#DC143C\",\n  cyan: \"#00FFFF\",\n  darkblue: \"#00008B\",\n  darkcyan: \"#008B8B\",\n  darkgoldenrod: \"#B8860B\",\n  darkgray: \"#A9A9A9\",\n  darkgreen: \"#006400\",\n  darkgrey: \"#A9A9A9\",\n  darkkhaki: \"#BDB76B\",\n  darkmagenta: \"#8B008B\",\n  darkolivegreen: \"#556B2F\",\n  darkorange: \"#FF8C00\",\n  darkorchid: \"#9932CC\",\n  darkred: \"#8B0000\",\n  darksalmon: \"#E9967A\",\n  darkseagreen: \"#8FBC8F\",\n  darkslateblue: \"#483D8B\",\n  darkslategray: \"#2F4F4F\",\n  darkslategrey: \"#2F4F4F\",\n  darkturquoise: \"#00CED1\",\n  darkviolet: \"#9400D3\",\n  deeppink: \"#FF1493\",\n  deepskyblue: \"#00BFFF\",\n  dimgray: \"#696969\",\n  dimgrey: \"#696969\",\n  dodgerblue: \"#1E90FF\",\n  firebrick: \"#B22222\",\n  floralwhite: \"#FFFAF0\",\n  forestgreen: \"#228B22\",\n  fuchsia: \"#FF00FF\",\n  gainsboro: \"#DCDCDC\",\n  ghostwhite: \"#F8F8FF\",\n  gold: \"#FFD700\",\n  goldenrod: \"#DAA520\",\n  gray: \"#808080\",\n  green: \"#008000\",\n  greenyellow: \"#ADFF2F\",\n  grey: \"#808080\",\n  honeydew: \"#F0FFF0\",\n  hotpink: \"#FF69B4\",\n  indianred: \"#CD5C5C\",\n  indigo: \"#4B0082\",\n  ivory: \"#FFFFF0\",\n  khaki: \"#F0E68C\",\n  lavender: \"#E6E6FA\",\n  lavenderblush: \"#FFF0F5\",\n  lawngreen: \"#7CFC00\",\n  lemonchiffon: \"#FFFACD\",\n  lightblue: \"#ADD8E6\",\n  lightcoral: \"#F08080\",\n  lightcyan: \"#E0FFFF\",\n  lightgoldenrodyellow: \"#FAFAD2\",\n  lightgray: \"#D3D3D3\",\n  lightgreen: \"#90EE90\",\n  lightgrey: \"#D3D3D3\",\n  lightpink: \"#FFB6C1\",\n  lightsalmon: \"#FFA07A\",\n  lightseagreen: \"#20B2AA\",\n  lightskyblue: \"#87CEFA\",\n  lightslategray: \"#778899\",\n  lightslategrey: \"#778899\",\n  lightsteelblue: \"#B0C4DE\",\n  lightyellow: \"#FFFFE0\",\n  lime: \"#00FF00\",\n  limegreen: \"#32CD32\",\n  linen: \"#FAF0E6\",\n  magenta: \"#FF00FF\",\n  maroon: \"#800000\",\n  mediumaquamarine: \"#66CDAA\",\n  mediumblue: \"#0000CD\",\n  mediumorchid: \"#BA55D3\",\n  mediumpurple: \"#9370DB\",\n  mediumseagreen: \"#3CB371\",\n  mediumslateblue: \"#7B68EE\",\n  mediumspringgreen: \"#00FA9A\",\n  mediumturquoise: \"#48D1CC\",\n  mediumvioletred: \"#C71585\",\n  midnightblue: \"#191970\",\n  mintcream: \"#F5FFFA\",\n  mistyrose: \"#FFE4E1\",\n  moccasin: \"#FFE4B5\",\n  navajowhite: \"#FFDEAD\",\n  navy: \"#000080\",\n  oldlace: \"#FDF5E6\",\n  olive: \"#808000\",\n  olivedrab: \"#6B8E23\",\n  orange: \"#FFA500\",\n  orangered: \"#FF4500\",\n  orchid: \"#DA70D6\",\n  palegoldenrod: \"#EEE8AA\",\n  palegreen: \"#98FB98\",\n  paleturquoise: \"#AFEEEE\",\n  palevioletred: \"#DB7093\",\n  papayawhip: \"#FFEFD5\",\n  peachpuff: \"#FFDAB9\",\n  peru: \"#CD853F\",\n  pink: \"#FFC0CB\",\n  plum: \"#DDA0DD\",\n  powderblue: \"#B0E0E6\",\n  purple: \"#800080\",\n  rebeccapurple: \"#663399\",\n  red: \"#FF0000\",\n  rosybrown: \"#BC8F8F\",\n  royalblue: \"#4169E1\",\n  saddlebrown: \"#8B4513\",\n  salmon: \"#FA8072\",\n  sandybrown: \"#F4A460\",\n  seagreen: \"#2E8B57\",\n  seashell: \"#FFF5EE\",\n  sienna: \"#A0522D\",\n  silver: \"#C0C0C0\",\n  skyblue: \"#87CEEB\",\n  slateblue: \"#6A5ACD\",\n  slategray: \"#708090\",\n  slategrey: \"#708090\",\n  snow: \"#FFFAFA\",\n  springgreen: \"#00FF7F\",\n  steelblue: \"#4682B4\",\n  tan: \"#D2B48C\",\n  teal: \"#008080\",\n  thistle: \"#D8BFD8\",\n  tomato: \"#FF6347\",\n  transparent: \"#00000000\",\n  turquoise: \"#40E0D0\",\n  violet: \"#EE82EE\",\n  wheat: \"#F5DEB3\",\n  white: \"#FFFFFF\",\n  whitesmoke: \"#F5F5F5\",\n  yellow: \"#FFFF00\",\n  yellowgreen: \"#9ACD32\"\n};\nvar Color = _Color;\n\n// packages/ag-charts-community/src/util/interpolate.ts\nfunction interpolateNumber(a, b) {\n  return (d) => Number(a) * (1 - d) + Number(b) * d;\n}\nfunction interpolateColor(a, b) {\n  if (typeof a === \"string\") {\n    try {\n      a = Color.fromString(a);\n    } catch (e) {\n      a = Color.fromArray([0, 0, 0]);\n    }\n  }\n  if (typeof b === \"string\") {\n    try {\n      b = Color.fromString(b);\n    } catch (e) {\n      b = Color.fromArray([0, 0, 0]);\n    }\n  }\n  return (d) => Color.mix(a, b, d).toRgbaString();\n}\n\n// packages/ag-charts-community/src/util/decorator.ts\nvar BREAK_TRANSFORM_CHAIN = Symbol(\"BREAK\");\nvar CONFIG_KEY = \"__decorator_config\";\nfunction initialiseConfig(target, propertyKeyOrSymbol) {\n  if (Object.getOwnPropertyDescriptor(target, CONFIG_KEY) == null) {\n    Object.defineProperty(target, CONFIG_KEY, { value: {} });\n  }\n  const config = target[CONFIG_KEY];\n  const propertyKey = propertyKeyOrSymbol.toString();\n  if (typeof config[propertyKey] !== \"undefined\") {\n    return config[propertyKey];\n  }\n  const valuesMap = /* @__PURE__ */ new WeakMap();\n  config[propertyKey] = { setters: [], getters: [], observers: [], valuesMap };\n  const descriptor = Object.getOwnPropertyDescriptor(target, propertyKeyOrSymbol);\n  const prevSet = descriptor?.set;\n  const prevGet = descriptor?.get;\n  const getter = function() {\n    let value = prevGet ? prevGet.call(this) : valuesMap.get(this);\n    for (const transformFn of config[propertyKey].getters) {\n      value = transformFn(this, propertyKeyOrSymbol, value);\n      if (value === BREAK_TRANSFORM_CHAIN) {\n        return;\n      }\n    }\n    return value;\n  };\n  const setter = function(value) {\n    const { setters, observers } = config[propertyKey];\n    let oldValue;\n    if (setters.some((f) => f.length > 2)) {\n      oldValue = prevGet ? prevGet.call(this) : valuesMap.get(this);\n    }\n    for (const transformFn of setters) {\n      value = transformFn(this, propertyKeyOrSymbol, value, oldValue);\n      if (value === BREAK_TRANSFORM_CHAIN) {\n        return;\n      }\n    }\n    if (prevSet) {\n      prevSet.call(this, value);\n    } else {\n      valuesMap.set(this, value);\n    }\n    for (const observerFn of observers) {\n      observerFn(this, value, oldValue);\n    }\n  };\n  Object.defineProperty(target, propertyKeyOrSymbol, {\n    set: setter,\n    get: getter,\n    enumerable: true,\n    configurable: false\n  });\n  return config[propertyKey];\n}\nfunction addTransformToInstanceProperty(setTransform, getTransform, configMetadata) {\n  return (target, propertyKeyOrSymbol) => {\n    const config = initialiseConfig(target, propertyKeyOrSymbol);\n    config.setters.push(setTransform);\n    if (getTransform) {\n      config.getters.unshift(getTransform);\n    }\n    if (configMetadata) {\n      Object.assign(config, configMetadata);\n    }\n  };\n}\nfunction addObserverToInstanceProperty(setObserver) {\n  return (target, propertyKeyOrSymbol) => {\n    initialiseConfig(target, propertyKeyOrSymbol).observers.push(setObserver);\n  };\n}\nfunction isDecoratedObject(target) {\n  return typeof target !== \"undefined\" && CONFIG_KEY in target;\n}\nfunction listDecoratedProperties(target) {\n  const targets = /* @__PURE__ */ new Set();\n  while (isDecoratedObject(target)) {\n    targets.add(target?.[CONFIG_KEY]);\n    target = Object.getPrototypeOf(target);\n  }\n  return Array.from(targets).flatMap((configMap) => Object.keys(configMap));\n}\nfunction extractDecoratedProperties(target) {\n  return listDecoratedProperties(target).reduce((result, key) => {\n    result[key] = target[key] ?? null;\n    return result;\n  }, {});\n}\nfunction extractDecoratedPropertyMetadata(target, propertyKeyOrSymbol) {\n  const propertyKey = propertyKeyOrSymbol.toString();\n  while (isDecoratedObject(target)) {\n    const config = target[CONFIG_KEY];\n    if (Object.hasOwn(config, propertyKey)) {\n      return config[propertyKey];\n    }\n    target = Object.getPrototypeOf(target);\n  }\n}\n\n// packages/ag-charts-community/src/util/type-guards.ts\nfunction isDefined(val) {\n  return val != null;\n}\nfunction isArray(value) {\n  return Array.isArray(value);\n}\nfunction isBoolean(value) {\n  return typeof value === \"boolean\";\n}\nfunction isDate(value) {\n  return value instanceof Date;\n}\nfunction isValidDate(value) {\n  return isDate(value) && !isNaN(Number(value));\n}\nfunction isRegExp(value) {\n  return value instanceof RegExp;\n}\nfunction isFunction(value) {\n  return typeof value === \"function\";\n}\nfunction isObject(value) {\n  return typeof value === \"object\" && value !== null && !isArray(value);\n}\nfunction isObjectLike(value) {\n  return isArray(value) || isPlainObject(value);\n}\nfunction isPlainObject(value) {\n  return typeof value === \"object\" && value !== null && Object.getPrototypeOf(value) === Object.prototype;\n}\nfunction isString(value) {\n  return typeof value === \"string\";\n}\nfunction isNumber(value) {\n  return typeof value === \"number\";\n}\nfunction isFiniteNumber(value) {\n  return Number.isFinite(value);\n}\nfunction isHtmlElement(value) {\n  return typeof window !== \"undefined\" && value instanceof HTMLElement;\n}\nfunction isEnumKey(enumObject, enumKey) {\n  return isString(enumKey) && Object.keys(enumObject).includes(enumKey);\n}\nfunction isEnumValue(enumObject, enumValue) {\n  return Object.values(enumObject).includes(enumValue);\n}\nfunction isSymbol(value) {\n  return typeof value === \"symbol\";\n}\nfunction excludesType(obj, excluded) {\n  return obj.type !== excluded;\n}\n\n// packages/ag-charts-community/src/util/object.ts\nfunction objectEqualWith(a, b, cmp) {\n  for (const key in b) {\n    if (!(key in a))\n      return false;\n  }\n  for (const key in a) {\n    if (!(key in b))\n      return false;\n    if (!cmp(a[key], b[key]))\n      return false;\n  }\n  return true;\n}\nfunction deepMerge(...sources) {\n  return mergeDefaults(...sources.reverse());\n}\nfunction mergeDefaults(...sources) {\n  const target = {};\n  for (const source of sources) {\n    if (!isObject(source))\n      continue;\n    const keys = isDecoratedObject(source) ? listDecoratedProperties(source) : Object.keys(source);\n    for (const key of keys) {\n      if (isPlainObject(target[key]) && isPlainObject(source[key])) {\n        target[key] = mergeDefaults(target[key], source[key]);\n      } else {\n        target[key] ?? (target[key] = source[key]);\n      }\n    }\n  }\n  return target;\n}\nfunction mergeArrayDefaults(dataArray, ...itemDefaults) {\n  if (itemDefaults && isArray(dataArray)) {\n    return dataArray.map((item) => mergeDefaults(item, ...itemDefaults));\n  }\n  return dataArray;\n}\nfunction mapValues(object2, mapper) {\n  return Object.entries(object2).reduce(\n    (result, [key, value]) => {\n      result[key] = mapper(value, key, object2);\n      return result;\n    },\n    {}\n  );\n}\nfunction without(object2, keys) {\n  const clone2 = { ...object2 };\n  for (const key of keys) {\n    delete clone2[key];\n  }\n  return clone2;\n}\nfunction getPath(object2, path) {\n  const pathArray = isArray(path) ? path : path.split(\".\");\n  return pathArray.reduce((value, pathKey) => value[pathKey], object2);\n}\nvar SKIP_JS_BUILTINS = /* @__PURE__ */ new Set([\"__proto__\", \"constructor\", \"prototype\"]);\nfunction setPath(object2, path, newValue) {\n  const pathArray = isArray(path) ? path.slice() : path.split(\".\");\n  const lastKey = pathArray.pop();\n  if (pathArray.some((p) => SKIP_JS_BUILTINS.has(p)))\n    return;\n  const lastObject = pathArray.reduce((value, pathKey) => value[pathKey], object2);\n  lastObject[lastKey] = newValue;\n  return lastObject[lastKey];\n}\nfunction partialAssign(keysToCopy, target, source) {\n  if (source === void 0) {\n    return target;\n  }\n  for (const key of keysToCopy) {\n    const value = source[key];\n    if (value !== void 0) {\n      target[key] = value;\n    }\n  }\n  return target;\n}\n\n// packages/ag-charts-community/src/motion/easing.ts\nvar easing_exports = {};\n__export(easing_exports, {\n  easeIn: () => easeIn,\n  easeInOut: () => easeInOut,\n  easeInOutQuad: () => easeInOutQuad,\n  easeInQuad: () => easeInQuad,\n  easeOut: () => easeOut,\n  easeOutQuad: () => easeOutQuad,\n  inverseEaseOut: () => inverseEaseOut,\n  linear: () => linear\n});\nvar linear = (n) => n;\nvar easeIn = (n) => 1 - Math.cos(n * Math.PI / 2);\nvar easeOut = (n) => Math.sin(n * Math.PI / 2);\nvar easeInOut = (n) => -(Math.cos(n * Math.PI) - 1) / 2;\nvar easeInQuad = (n) => n * n;\nvar easeOutQuad = (n) => 1 - (1 - n) ** 2;\nvar easeInOutQuad = (n) => n < 0.5 ? 2 * n * n : 1 - (-2 * n + 2) ** 2 / 2;\nvar inverseEaseOut = (x) => 2 * Math.asin(x) / Math.PI;\n\n// packages/ag-charts-community/src/motion/animation.ts\nvar QUICK_TRANSITION = 0.2;\nvar PHASE_ORDER = [\"initial\", \"remove\", \"update\", \"add\", \"trailing\", \"end\", \"none\"];\nvar PHASE_METADATA = {\n  initial: {\n    animationDuration: 1,\n    animationDelay: 0\n  },\n  add: {\n    animationDuration: 0.25,\n    animationDelay: 0.75\n  },\n  remove: {\n    animationDuration: 0.25,\n    animationDelay: 0\n  },\n  update: {\n    animationDuration: 0.5,\n    animationDelay: 0.25\n  },\n  trailing: {\n    animationDuration: QUICK_TRANSITION,\n    animationDelay: 1,\n    skipIfNoEarlierAnimations: true\n  },\n  end: {\n    animationDelay: 1 + QUICK_TRANSITION,\n    animationDuration: 0,\n    skipIfNoEarlierAnimations: true\n  },\n  none: {\n    animationDuration: 0,\n    animationDelay: 0\n  }\n};\nvar RepeatType = /* @__PURE__ */ ((RepeatType2) => {\n  RepeatType2[\"Loop\"] = \"loop\";\n  RepeatType2[\"Reverse\"] = \"reverse\";\n  return RepeatType2;\n})(RepeatType || {});\nfunction isNodeArray(array2) {\n  return array2.every((n) => n instanceof Node);\n}\nfunction deconstructSelectionsOrNodes(selectionsOrNodes) {\n  return isNodeArray(selectionsOrNodes) ? { nodes: selectionsOrNodes, selections: [] } : { nodes: [], selections: selectionsOrNodes };\n}\nfunction animationValuesEqual(a, b) {\n  if (a === b) {\n    return true;\n  } else if (Array.isArray(a) && Array.isArray(b)) {\n    return a.length === b.length && a.every((v, i) => animationValuesEqual(v, b[i]));\n  } else if (isInterpolating(a) && isInterpolating(b)) {\n    return a.equals(b);\n  } else if (isPlainObject(a) && isPlainObject(b)) {\n    return objectEqualWith(a, b, animationValuesEqual);\n  }\n  return false;\n}\nvar Animation = class {\n  constructor(opts) {\n    this.isComplete = false;\n    this.elapsed = 0;\n    this.iteration = 0;\n    this.isPlaying = false;\n    this.isReverse = false;\n    this.id = opts.id;\n    this.groupId = opts.groupId;\n    this.autoplay = opts.autoplay ?? true;\n    this.ease = opts.ease ?? linear;\n    this.phase = opts.phase;\n    const durationProportion = opts.duration ?? PHASE_METADATA[this.phase].animationDuration;\n    this.duration = durationProportion * opts.defaultDuration;\n    this.delay = (opts.delay ?? 0) * opts.defaultDuration;\n    this.onComplete = opts.onComplete;\n    this.onPlay = opts.onPlay;\n    this.onStop = opts.onStop;\n    this.onUpdate = opts.onUpdate;\n    this.interpolate = this.createInterpolator(opts.from, opts.to);\n    this.from = opts.from;\n    if (opts.skip === true) {\n      this.onUpdate?.(opts.to, false, this);\n      this.onStop?.(this);\n      this.onComplete?.(this);\n      this.isComplete = true;\n    }\n    if (opts.collapsable !== false) {\n      this.duration = this.checkCollapse(opts, this.duration);\n    }\n  }\n  checkCollapse(opts, calculatedDuration) {\n    return animationValuesEqual(opts.from, opts.to) ? 0 : calculatedDuration;\n  }\n  play(initialUpdate = false) {\n    if (this.isPlaying || this.isComplete)\n      return;\n    this.isPlaying = true;\n    this.onPlay?.(this);\n    if (!this.autoplay)\n      return;\n    this.autoplay = false;\n    if (!initialUpdate)\n      return;\n    this.onUpdate?.(this.from, true, this);\n  }\n  pause() {\n    this.isPlaying = false;\n  }\n  stop() {\n    this.isPlaying = false;\n    if (!this.isComplete) {\n      this.isComplete = true;\n      this.onStop?.(this);\n    }\n  }\n  update(time2) {\n    if (this.isComplete)\n      return time2;\n    if (!this.isPlaying && this.autoplay) {\n      this.play(true);\n    }\n    const previousElapsed = this.elapsed;\n    this.elapsed += time2;\n    if (this.delay > this.elapsed)\n      return 0;\n    const value = this.interpolate(this.isReverse ? 1 - this.delta : this.delta);\n    this.onUpdate?.(value, false, this);\n    const totalDuration = this.delay + this.duration;\n    if (this.elapsed >= totalDuration) {\n      this.stop();\n      this.isComplete = true;\n      this.onComplete?.(this);\n      return time2 - (totalDuration - previousElapsed);\n    }\n    return 0;\n  }\n  get delta() {\n    return this.ease(clamp(0, (this.elapsed - this.delay) / this.duration, 1));\n  }\n  createInterpolator(from3, to) {\n    if (typeof to !== \"object\" || isInterpolating(to)) {\n      return this.interpolateValue(from3, to);\n    }\n    const interpolatorEntries = [];\n    for (const key in to) {\n      const interpolator = this.interpolateValue(from3[key], to[key]);\n      if (interpolator != null) {\n        interpolatorEntries.push([key, interpolator]);\n      }\n    }\n    return (d) => {\n      const result = {};\n      for (const [key, interpolator] of interpolatorEntries) {\n        result[key] = interpolator(d);\n      }\n      return result;\n    };\n  }\n  interpolateValue(a, b) {\n    if (a == null || b == null) {\n      return;\n    } else if (isInterpolating(a)) {\n      return (d) => a[interpolate](b, d);\n    }\n    try {\n      switch (typeof a) {\n        case \"number\":\n          return interpolateNumber(a, b);\n        case \"string\":\n          return interpolateColor(a, b);\n        case \"boolean\":\n          if (a === b) {\n            return () => a;\n          }\n          break;\n      }\n    } catch (e) {\n    }\n    throw new Error(`Unable to interpolate values: ${a}, ${b}`);\n  }\n};\n\n// packages/ag-charts-community/src/motion/fromToMotion.ts\nvar NODE_UPDATE_STATE_TO_PHASE_MAPPING = {\n  added: \"add\",\n  updated: \"update\",\n  removed: \"remove\",\n  unknown: \"initial\",\n  \"no-op\": \"none\"\n};\nfunction fromToMotion(groupId, subId, animationManager, selectionsOrNodes, fns, getDatumId, diff2) {\n  const { fromFn, toFn, applyFn = (node, props) => node.setProperties(props) } = fns;\n  const { nodes, selections } = deconstructSelectionsOrNodes(selectionsOrNodes);\n  const processNodes = (liveNodes, subNodes) => {\n    let prevFromProps;\n    let liveNodeIndex = 0;\n    let nodeIndex = 0;\n    for (const node of subNodes) {\n      const isLive = liveNodes[liveNodeIndex] === node;\n      const ctx = {\n        last: nodeIndex >= subNodes.length - 1,\n        lastLive: liveNodeIndex >= liveNodes.length - 1,\n        prev: subNodes[nodeIndex - 1],\n        prevFromProps,\n        prevLive: liveNodes[liveNodeIndex - 1],\n        next: subNodes[nodeIndex + 1],\n        nextLive: liveNodes[liveNodeIndex + (isLive ? 1 : 0)]\n      };\n      const animationId = `${groupId}_${subId}_${node.id}`;\n      animationManager.stopByAnimationId(animationId);\n      let status = \"unknown\";\n      if (!isLive) {\n        status = \"removed\";\n      } else if (getDatumId && diff2) {\n        status = calculateStatus(node, node.datum, getDatumId, diff2);\n      }\n      node.transitionOut = status === \"removed\";\n      const { phase, start: start2, finish, delay, duration, ...from3 } = fromFn(node, node.datum, status, ctx);\n      const {\n        phase: toPhase,\n        start: toStart,\n        finish: toFinish,\n        delay: toDelay,\n        duration: toDuration,\n        ...to\n      } = toFn(node, node.datum, status, ctx);\n      const collapsable = finish == null;\n      animationManager.animate({\n        id: animationId,\n        groupId,\n        phase: phase ?? toPhase ?? \"update\",\n        duration: duration ?? toDuration,\n        delay: delay ?? toDelay,\n        from: from3,\n        to,\n        ease: easeOut,\n        collapsable,\n        onPlay: () => {\n          applyFn(node, { ...start2, ...toStart, ...from3 });\n        },\n        onUpdate(props) {\n          applyFn(node, props);\n        },\n        onStop: () => {\n          applyFn(node, {\n            ...start2,\n            ...toStart,\n            ...from3,\n            ...to,\n            ...finish,\n            ...toFinish\n          });\n        }\n      });\n      if (isLive) {\n        liveNodeIndex++;\n      }\n      nodeIndex++;\n      prevFromProps = from3;\n    }\n  };\n  let selectionIndex = 0;\n  for (const selection of selections) {\n    const selectionNodes = selection.nodes();\n    const liveNodes = selectionNodes.filter((n) => !selection.isGarbage(n));\n    processNodes(liveNodes, selectionNodes);\n    animationManager.animate({\n      id: `${groupId}_${subId}_selection_${selectionIndex}`,\n      groupId,\n      phase: \"end\",\n      from: 0,\n      to: 1,\n      ease: easeOut,\n      onStop() {\n        selection.cleanup();\n      }\n    });\n    selectionIndex++;\n  }\n  processNodes(nodes, nodes);\n}\nfunction staticFromToMotion(groupId, subId, animationManager, selectionsOrNodes, from3, to, extraOpts) {\n  const { nodes, selections } = deconstructSelectionsOrNodes(selectionsOrNodes);\n  const { start: start2, finish, phase } = extraOpts;\n  animationManager.animate({\n    id: `${groupId}_${subId}`,\n    groupId,\n    phase: phase ?? \"update\",\n    from: from3,\n    to,\n    ease: easeOut,\n    onPlay: () => {\n      if (!start2)\n        return;\n      for (const node of nodes) {\n        node.setProperties(start2);\n      }\n      for (const selection of selections) {\n        for (const node of selection.nodes()) {\n          node.setProperties(start2);\n        }\n      }\n    },\n    onUpdate(props) {\n      for (const node of nodes) {\n        node.setProperties(props);\n      }\n      for (const selection of selections) {\n        for (const node of selection.nodes()) {\n          node.setProperties(props);\n        }\n      }\n    },\n    onStop: () => {\n      for (const node of nodes) {\n        node.setProperties({ ...to, ...finish });\n      }\n      for (const selection of selections) {\n        for (const node of selection.nodes()) {\n          node.setProperties({ ...to, ...finish });\n        }\n        selection.cleanup();\n      }\n    }\n  });\n}\nfunction calculateStatus(node, datum, getDatumId, diff2) {\n  const id = getDatumId(node, datum);\n  if (diff2.added.has(id)) {\n    return \"added\";\n  }\n  if (diff2.removed.has(id)) {\n    return \"removed\";\n  }\n  return \"updated\";\n}\n\n// packages/ag-charts-community/src/scale/invalidating.ts\nvar Invalidating = (target, propertyKey) => {\n  const mappedProperty = Symbol(String(propertyKey));\n  target[mappedProperty] = void 0;\n  Object.defineProperty(target, propertyKey, {\n    get() {\n      return this[mappedProperty];\n    },\n    set(newValue) {\n      const oldValue = this[mappedProperty];\n      if (oldValue !== newValue) {\n        this[mappedProperty] = newValue;\n        this.invalid = true;\n      }\n    },\n    enumerable: true,\n    configurable: false\n  });\n};\n\n// packages/ag-charts-community/src/scale/continuousScale.ts\nvar _ContinuousScale = class _ContinuousScale {\n  constructor(domain, range3) {\n    this.invalid = true;\n    this.nice = false;\n    this.interval = void 0;\n    this.tickCount = _ContinuousScale.defaultTickCount;\n    this.minTickCount = 0;\n    this.maxTickCount = Infinity;\n    // TODO(olegat) should be of type D[]\n    this.niceDomain = [];\n    this.defaultClampMode = \"raw\";\n    this.domain = domain;\n    this.range = range3;\n  }\n  static is(value) {\n    return value instanceof _ContinuousScale;\n  }\n  transform(x) {\n    return x;\n  }\n  transformInvert(x) {\n    return x;\n  }\n  calcBandwidth(smallestInterval = 1) {\n    const domain = this.getDomain();\n    const rangeDistance = this.getPixelRange();\n    const intervals = Math.abs(domain[1] - domain[0]) / smallestInterval + 1;\n    const maxBands = Math.floor(rangeDistance);\n    const bands = Math.min(intervals, maxBands);\n    return rangeDistance / Math.max(1, bands);\n  }\n  getDomain() {\n    if (this.nice) {\n      this.refresh();\n      if (this.niceDomain.length) {\n        return this.niceDomain;\n      }\n    }\n    return this.domain;\n  }\n  convert(x, opts) {\n    const clampMode = opts?.clampMode ?? this.defaultClampMode;\n    if (!this.domain || this.domain.length < 2) {\n      return NaN;\n    }\n    this.refresh();\n    const domain = this.getDomain().map((d) => this.transform(d));\n    const [d0, d1] = domain;\n    const { range: range3 } = this;\n    const [r0, r1] = range3;\n    x = this.transform(x);\n    if (clampMode === \"clamped\") {\n      const [start2, stop] = findMinMax(domain.map(Number));\n      if (Number(x) < start2) {\n        return r0;\n      } else if (Number(x) > stop) {\n        return r1;\n      }\n    }\n    if (d0 === d1) {\n      return (r0 + r1) / 2;\n    } else if (x === d0) {\n      return r0;\n    } else if (x === d1) {\n      return r1;\n    }\n    return r0 + (Number(x) - Number(d0)) / (Number(d1) - Number(d0)) * (r1 - r0);\n  }\n  invert(x) {\n    this.refresh();\n    const domain = this.getDomain().map((d2) => this.transform(d2));\n    const [d0, d1] = domain;\n    const { range: range3 } = this;\n    const [r0, r1] = range3;\n    const isReversed = r0 > r1;\n    const rMin = isReversed ? r1 : r0;\n    const rMax = isReversed ? r0 : r1;\n    let d;\n    if (x < rMin) {\n      return isReversed ? d1 : d0;\n    } else if (x > rMax) {\n      return isReversed ? d0 : d1;\n    } else if (r0 === r1) {\n      d = this.toDomain((Number(d0) + Number(d1)) / 2);\n    } else {\n      d = this.toDomain(Number(d0) + (x - r0) / (r1 - r0) * (Number(d1) - Number(d0)));\n    }\n    return this.transformInvert(d);\n  }\n  refresh() {\n    if (!this.invalid)\n      return;\n    this.invalid = false;\n    this.update();\n    if (this.invalid) {\n      Logger.warnOnce(\"Expected update to not invalidate scale\");\n    }\n  }\n  getPixelRange() {\n    const [a, b] = this.range;\n    return Math.abs(b - a);\n  }\n};\n_ContinuousScale.defaultTickCount = 5;\n_ContinuousScale.defaultMaxTickCount = 6;\n__decorateClass([\n  Invalidating\n], _ContinuousScale.prototype, \"domain\", 2);\n__decorateClass([\n  Invalidating\n], _ContinuousScale.prototype, \"range\", 2);\n__decorateClass([\n  Invalidating\n], _ContinuousScale.prototype, \"nice\", 2);\n__decorateClass([\n  Invalidating\n], _ContinuousScale.prototype, \"interval\", 2);\n__decorateClass([\n  Invalidating\n], _ContinuousScale.prototype, \"tickCount\", 2);\n__decorateClass([\n  Invalidating\n], _ContinuousScale.prototype, \"minTickCount\", 2);\n__decorateClass([\n  Invalidating\n], _ContinuousScale.prototype, \"maxTickCount\", 2);\nvar ContinuousScale = _ContinuousScale;\n\n// packages/ag-charts-community/src/util/array.ts\nfunction extent(values) {\n  if (values.length === 0) {\n    return null;\n  }\n  let min = Infinity;\n  let max = -Infinity;\n  for (let n of values) {\n    if (n instanceof Date) {\n      n = n.getTime();\n    }\n    if (typeof n !== \"number\") {\n      continue;\n    }\n    if (n < min) {\n      min = n;\n    }\n    if (n > max) {\n      max = n;\n    }\n  }\n  const result = [min, max];\n  return result.every(isFinite) ? result : null;\n}\nfunction normalisedExtentWithMetadata(d, min, max) {\n  let clipped = false;\n  if (d.length > 2) {\n    d = extent(d) ?? [NaN, NaN];\n  }\n  if (!isNaN(min)) {\n    clipped || (clipped = min > d[0]);\n    d = [min, d[1]];\n  }\n  if (!isNaN(max)) {\n    clipped || (clipped = max < d[1]);\n    d = [d[0], max];\n  }\n  if (d[0] > d[1]) {\n    d = [];\n  }\n  return { extent: d, clipped };\n}\nfunction arraysEqual(a, b) {\n  if (a == null || b == null || a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i++) {\n    if (Array.isArray(a[i]) && Array.isArray(b[i])) {\n      if (!arraysEqual(a[i], b[i])) {\n        return false;\n      }\n    } else if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction toArray(value) {\n  if (typeof value === \"undefined\") {\n    return [];\n  }\n  return Array.isArray(value) ? value : [value];\n}\nfunction unique(array2) {\n  return Array.from(new Set(array2));\n}\nfunction groupBy(array2, iteratee) {\n  return array2.reduce((result, item) => {\n    const groupKey = iteratee(item);\n    result[groupKey] ?? (result[groupKey] = []);\n    result[groupKey].push(item);\n    return result;\n  }, {});\n}\nfunction circularSliceArray(data, size, offset4 = 0) {\n  if (data.length === 0) {\n    return [];\n  }\n  const result = [];\n  for (let i = 0; i < size; i++) {\n    result.push(data.at((i + offset4) % data.length));\n  }\n  return result;\n}\nfunction sortBasedOnArray(baseArray, orderArray) {\n  const orderMap = /* @__PURE__ */ new Map();\n  orderArray.forEach((item, index) => {\n    orderMap.set(item, index);\n  });\n  return baseArray.sort((a, b) => {\n    const indexA = orderMap.get(a) ?? Infinity;\n    const indexB = orderMap.get(b) ?? Infinity;\n    return indexA - indexB;\n  });\n}\n\n// packages/ag-charts-community/src/util/timeFormat.ts\nvar CONSTANTS = {\n  periods: [\"AM\", \"PM\"],\n  days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n  shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n  months: [\n    \"January\",\n    \"February\",\n    \"March\",\n    \"April\",\n    \"May\",\n    \"June\",\n    \"July\",\n    \"August\",\n    \"September\",\n    \"October\",\n    \"November\",\n    \"December\"\n  ],\n  shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n};\nfunction dayOfYear(date, startOfYear = new Date(date.getFullYear(), 0, 1)) {\n  const startOffset = date.getTimezoneOffset() - startOfYear.getTimezoneOffset();\n  const timeDiff = date.getTime() - startOfYear.getTime() + startOffset * 6e4;\n  const timeOneDay = 36e5 * 24;\n  return Math.floor(timeDiff / timeOneDay);\n}\nfunction weekOfYear(date, startDay) {\n  const startOfYear = new Date(date.getFullYear(), 0, 1);\n  const startOfYearDay = startOfYear.getDay();\n  const firstWeekStartOffset = (startDay - startOfYearDay + 7) % 7;\n  const startOffset = new Date(date.getFullYear(), 0, firstWeekStartOffset + 1);\n  if (startOffset <= date) {\n    return Math.floor(dayOfYear(date, startOffset) / 7) + 1;\n  }\n  return 0;\n}\nvar SUNDAY = 0;\nvar MONDAY = 1;\nvar THURSDAY = 4;\nfunction isoWeekOfYear(date, year2 = date.getFullYear()) {\n  const firstOfYear = new Date(year2, 0, 1);\n  const firstOfYearDay = firstOfYear.getDay();\n  const firstThursdayOffset = (THURSDAY - firstOfYearDay + 7) % 7;\n  const startOffset = new Date(year2, 0, firstThursdayOffset - (THURSDAY - MONDAY) + 1);\n  if (startOffset <= date) {\n    return Math.floor(dayOfYear(date, startOffset) / 7) + 1;\n  }\n  return isoWeekOfYear(date, year2 - 1);\n}\nfunction timezone(date) {\n  const offset4 = date.getTimezoneOffset();\n  const unsignedOffset = Math.abs(offset4);\n  const sign = offset4 > 0 ? \"-\" : \"+\";\n  return `${sign}${pad(Math.floor(unsignedOffset / 60), 2, \"0\")}${pad(Math.floor(unsignedOffset % 60), 2, \"0\")}`;\n}\nvar FORMATTERS = {\n  a: (d) => CONSTANTS.shortDays[d.getDay()],\n  A: (d) => CONSTANTS.days[d.getDay()],\n  b: (d) => CONSTANTS.shortMonths[d.getMonth()],\n  B: (d) => CONSTANTS.months[d.getMonth()],\n  c: \"%x, %X\",\n  d: (d, p) => pad(d.getDate(), 2, p ?? \"0\"),\n  e: \"%_d\",\n  f: (d, p) => pad(d.getMilliseconds() * 1e3, 6, p ?? \"0\"),\n  H: (d, p) => pad(d.getHours(), 2, p ?? \"0\"),\n  I: (d, p) => {\n    const hours = d.getHours() % 12;\n    return hours === 0 ? \"12\" : pad(hours, 2, p ?? \"0\");\n  },\n  j: (d, p) => pad(dayOfYear(d) + 1, 3, p ?? \"0\"),\n  m: (d, p) => pad(d.getMonth() + 1, 2, p ?? \"0\"),\n  M: (d, p) => pad(d.getMinutes(), 2, p ?? \"0\"),\n  L: (d, p) => pad(d.getMilliseconds(), 3, p ?? \"0\"),\n  p: (d) => d.getHours() < 12 ? \"AM\" : \"PM\",\n  Q: (d) => String(d.getTime()),\n  s: (d) => String(Math.floor(d.getTime() / 1e3)),\n  S: (d, p) => pad(d.getSeconds(), 2, p ?? \"0\"),\n  u: (d) => {\n    let day2 = d.getDay();\n    if (day2 < 1)\n      day2 += 7;\n    return String(day2 % 7);\n  },\n  U: (d, p) => pad(weekOfYear(d, SUNDAY), 2, p ?? \"0\"),\n  V: (d, p) => pad(isoWeekOfYear(d), 2, p ?? \"0\"),\n  w: (d, p) => pad(d.getDay(), 2, p ?? \"0\"),\n  W: (d, p) => pad(weekOfYear(d, MONDAY), 2, p ?? \"0\"),\n  x: \"%-m/%-d/%Y\",\n  X: \"%-I:%M:%S %p\",\n  y: (d, p) => pad(d.getFullYear() % 100, 2, p ?? \"0\"),\n  Y: (d, p) => pad(d.getFullYear(), 4, p ?? \"0\"),\n  Z: (d) => timezone(d),\n  \"%\": () => \"%\"\n};\nvar PADS = {\n  _: \" \",\n  \"0\": \"0\",\n  \"-\": \"\"\n};\nfunction pad(value, size, padChar) {\n  const output = String(Math.floor(value));\n  if (output.length >= size) {\n    return output;\n  }\n  return `${padChar.repeat(size - output.length)}${output}`;\n}\nfunction buildFormatter(formatString) {\n  const formatParts = [];\n  while (formatString.length > 0) {\n    let nextEscapeIdx = formatString.indexOf(\"%\");\n    if (nextEscapeIdx !== 0) {\n      const literalPart = nextEscapeIdx > 0 ? formatString.substring(0, nextEscapeIdx) : formatString;\n      formatParts.push(literalPart);\n    }\n    if (nextEscapeIdx < 0)\n      break;\n    const maybePadSpecifier = formatString[nextEscapeIdx + 1];\n    const maybePad = PADS[maybePadSpecifier];\n    if (maybePad != null) {\n      nextEscapeIdx++;\n    }\n    const maybeFormatterSpecifier = formatString[nextEscapeIdx + 1];\n    const maybeFormatter = FORMATTERS[maybeFormatterSpecifier];\n    if (typeof maybeFormatter === \"function\") {\n      formatParts.push([maybeFormatter, maybePad]);\n    } else if (typeof maybeFormatter === \"string\") {\n      const formatter = buildFormatter(maybeFormatter);\n      formatParts.push([formatter, maybePad]);\n    } else {\n      formatParts.push(`${maybePad ?? \"\"}${maybeFormatterSpecifier}`);\n    }\n    formatString = formatString.substring(nextEscapeIdx + 2);\n  }\n  return (dateTime) => {\n    const dateTimeAsDate = typeof dateTime === \"number\" ? new Date(dateTime) : dateTime;\n    return formatParts.map((c) => typeof c === \"string\" ? c : c[0](dateTimeAsDate, c[1])).join(\"\");\n  };\n}\n\n// packages/ag-charts-community/src/util/timeFormatDefaults.ts\nfunction dateToNumber(value) {\n  return value instanceof Date ? value.getTime() : value;\n}\nfunction defaultTimeTickFormat(ticks, domain, formatOffset) {\n  const formatString = calculateDefaultTimeTickFormat(ticks, domain, formatOffset);\n  const formatter = buildFormatter(formatString);\n  return (date) => formatter(date);\n}\nfunction calculateDefaultTimeTickFormat(ticks = [], domain = ticks, formatOffset = 0) {\n  let minInterval = Infinity;\n  for (let i = 1; i < ticks.length; i++) {\n    minInterval = Math.min(minInterval, Math.abs(ticks[i] - ticks[i - 1]));\n  }\n  const startYear = new Date(domain[0]).getFullYear();\n  const stopYear = new Date(domain.at(-1)).getFullYear();\n  const yearChange = stopYear - startYear > 0;\n  const timeFormat = isFinite(minInterval) ? getIntervalLowestGranularityFormat(minInterval, ticks) : getLowestGranularityFormat(ticks[0]);\n  return formatStringBuilder(Math.max(timeFormat - formatOffset, 0), yearChange, ticks);\n}\nfunction getIntervalLowestGranularityFormat(value, ticks) {\n  if (value < durationSecond) {\n    return 0 /* MILLISECOND */;\n  } else if (value < durationMinute) {\n    return 1 /* SECOND */;\n  } else if (value < durationHour) {\n    return 2 /* MINUTE */;\n  } else if (value < durationDay) {\n    return 3 /* HOUR */;\n  } else if (value < durationWeek) {\n    return 4 /* WEEK_DAY */;\n  } else if (value < durationDay * 28 || value < durationDay * 31 && hasDuplicateMonth(ticks)) {\n    return 5 /* SHORT_MONTH */;\n  } else if (value < durationYear) {\n    return 6 /* MONTH */;\n  }\n  return 7 /* YEAR */;\n}\nfunction getLowestGranularityFormat(value) {\n  if (second_default.floor(value) < value) {\n    return 0 /* MILLISECOND */;\n  } else if (minute_default.floor(value) < value) {\n    return 1 /* SECOND */;\n  } else if (hour_default.floor(value) < value) {\n    return 2 /* MINUTE */;\n  } else if (day_default.floor(value) < value) {\n    return 3 /* HOUR */;\n  } else if (month_default.floor(value) < value) {\n    if (week_default.floor(value) < value) {\n      return 4 /* WEEK_DAY */;\n    }\n    return 5 /* SHORT_MONTH */;\n  } else if (year_default.floor(value) < value) {\n    return 6 /* MONTH */;\n  }\n  return 7 /* YEAR */;\n}\nfunction hasDuplicateMonth(ticks) {\n  let prevMonth = new Date(ticks[0]).getMonth();\n  for (let i = 1; i < ticks.length; i++) {\n    const tickMonth = new Date(ticks[i]).getMonth();\n    if (prevMonth === tickMonth) {\n      return true;\n    }\n    prevMonth = tickMonth;\n  }\n  return false;\n}\nfunction formatStringBuilder(defaultTimeFormat, yearChange, ticks) {\n  const firstTick = dateToNumber(ticks[0]);\n  const lastTick = dateToNumber(ticks.at(-1));\n  const extent2 = Math.abs(lastTick - firstTick);\n  const activeYear = yearChange || defaultTimeFormat === 7 /* YEAR */;\n  const activeDate = extent2 === 0;\n  const parts = [\n    [\"hour\", 6 * durationHour, 14 * durationDay, 3 /* HOUR */, \"%I %p\"],\n    [\"hour\", durationMinute, 6 * durationHour, 3 /* HOUR */, \"%I:%M\"],\n    [\"second\", 1e3, 6 * durationHour, 1 /* SECOND */, \":%S\"],\n    [\"ms\", 0, 6 * durationHour, 0 /* MILLISECOND */, \".%L\"],\n    [\"am/pm\", durationMinute, 6 * durationHour, 3 /* HOUR */, \"%p\"],\n    \" \",\n    [\"day\", durationDay, durationWeek, 4 /* WEEK_DAY */, \"%a\"],\n    [\"month\", activeDate ? 0 : durationWeek, 52 * durationWeek, 5 /* SHORT_MONTH */, \"%b %d\"],\n    [\"month\", 5 * durationWeek, 10 * durationYear, 6 /* MONTH */, \"%B\"],\n    \" \",\n    [\"year\", activeYear ? 0 : durationYear, Infinity, 7 /* YEAR */, \"%Y\"]\n  ];\n  const formatParts = parts.filter((v) => {\n    if (typeof v === \"string\") {\n      return true;\n    }\n    const [_, min, max, format] = v;\n    return format >= defaultTimeFormat && min <= extent2 && extent2 < max;\n  }).reduce(\n    (r, next) => {\n      if (typeof next === \"string\") {\n        r.result.push(next);\n      } else if (!r.used.has(next[0])) {\n        r.result.push(next);\n        r.used.add(next[0]);\n      }\n      return r;\n    },\n    { result: [], used: /* @__PURE__ */ new Set() }\n  ).result;\n  const firstFormat = formatParts.findIndex((v) => typeof v !== \"string\");\n  const lastFormat = formatParts.findLastIndex((v) => typeof v !== \"string\");\n  return formatParts.slice(firstFormat, lastFormat + 1).map((v) => typeof v === \"string\" ? v : v[4]).join(\"\").replaceAll(/\\s+/g, \" \").trim();\n}\n\n// packages/ag-charts-community/src/scale/bandScale.ts\nvar _BandScale = class _BandScale {\n  constructor() {\n    this.type = \"band\";\n    this.invalid = true;\n    this.range = [0, 1];\n    this.round = false;\n    this.interval = void 0;\n    /**\n     * Maps datum to its index in the {@link domain} array.\n     * Used to check for duplicate data (not allowed).\n     */\n    this.index = /* @__PURE__ */ new Map();\n    /**\n     * The output range values for datum at each index.\n     */\n    this.ordinalRange = [];\n    /**\n     * Contains unique data only.\n     */\n    this._domain = [];\n    this._bandwidth = 1;\n    this._step = 1;\n    this._inset = 1;\n    this._rawBandwidth = 1;\n    /**\n     * The ratio of the range that is reserved for space between bands.\n     */\n    this._paddingInner = 0;\n    /**\n     * The ratio of the range that is reserved for space before the first\n     * and after the last band.\n     */\n    this._paddingOuter = 0;\n  }\n  static is(value) {\n    return value instanceof _BandScale;\n  }\n  refresh() {\n    if (!this.invalid)\n      return;\n    this.invalid = false;\n    this.update();\n    if (this.invalid) {\n      Logger.warnOnce(\"Expected update to not invalidate scale\");\n    }\n  }\n  set domain(values) {\n    this.index = /* @__PURE__ */ new Map();\n    this.invalid = true;\n    this._domain = [];\n    for (const value of values) {\n      const key = dateToNumber(value);\n      if (this.getIndex(key) === void 0) {\n        this.index.set(key, this._domain.push(value) - 1);\n      }\n    }\n  }\n  get domain() {\n    return this._domain;\n  }\n  getDomain() {\n    return this._domain;\n  }\n  ticks() {\n    this.refresh();\n    return this._domain;\n  }\n  convert(d) {\n    this.refresh();\n    const i = this.getIndex(d);\n    if (i == null) {\n      return NaN;\n    }\n    return this.ordinalRange[i] ?? NaN;\n  }\n  invert(position) {\n    this.refresh();\n    const index = this.ordinalRange.findIndex((p) => p === position);\n    return this.domain[index];\n  }\n  invertNearest(position) {\n    this.refresh();\n    let nearest = -1;\n    let minDistance = Infinity;\n    const index = this.ordinalRange.findIndex((p, i) => {\n      if (p === position)\n        return true;\n      const distance3 = Math.abs(position - p);\n      if (distance3 < minDistance) {\n        minDistance = distance3;\n        nearest = i;\n      }\n      return false;\n    });\n    return this.domain[index] ?? this.domain[nearest];\n  }\n  get bandwidth() {\n    this.refresh();\n    return this._bandwidth;\n  }\n  get step() {\n    this.refresh();\n    return this._step;\n  }\n  get inset() {\n    this.refresh();\n    return this._inset;\n  }\n  get rawBandwidth() {\n    this.refresh();\n    return this._rawBandwidth;\n  }\n  set padding(value) {\n    value = clamp(0, value, 1);\n    this._paddingInner = value;\n    this._paddingOuter = value;\n  }\n  get padding() {\n    return this._paddingInner;\n  }\n  set paddingInner(value) {\n    this._paddingInner = clamp(0, value, 1);\n  }\n  get paddingInner() {\n    return this._paddingInner;\n  }\n  set paddingOuter(value) {\n    this._paddingOuter = clamp(0, value, 1);\n  }\n  get paddingOuter() {\n    return this._paddingOuter;\n  }\n  update() {\n    const count = this._domain.length;\n    if (count === 0)\n      return;\n    const [r0, r1] = this.range;\n    let { _paddingInner: paddingInner } = this;\n    const { _paddingOuter: paddingOuter, round: round5 } = this;\n    const rangeDistance = r1 - r0;\n    let rawStep;\n    if (count === 1) {\n      paddingInner = 0;\n      rawStep = rangeDistance * (1 - paddingOuter * 2);\n    } else {\n      rawStep = rangeDistance / Math.max(1, count - paddingInner + paddingOuter * 2);\n    }\n    const step = round5 ? Math.floor(rawStep) : rawStep;\n    let inset = r0 + (rangeDistance - step * (count - paddingInner)) / 2;\n    let bandwidth = step * (1 - paddingInner);\n    if (round5) {\n      inset = Math.round(inset);\n      bandwidth = Math.round(bandwidth);\n    }\n    this._step = step;\n    this._inset = inset;\n    this._bandwidth = bandwidth;\n    this._rawBandwidth = rawStep * (1 - paddingInner);\n    this.ordinalRange = this._domain.map((_, i) => inset + step * i);\n  }\n  getIndex(value) {\n    return this.index.get(value instanceof Date ? value.getTime() : value);\n  }\n};\n__decorateClass([\n  Invalidating\n], _BandScale.prototype, \"range\", 2);\n__decorateClass([\n  Invalidating\n], _BandScale.prototype, \"round\", 2);\n__decorateClass([\n  Invalidating\n], _BandScale.prototype, \"interval\", 2);\nvar BandScale = _BandScale;\n\n// packages/ag-charts-community/src/util/properties.ts\nvar BaseProperties = class {\n  set(properties) {\n    const { className = this.constructor.name } = this.constructor;\n    if (typeof properties !== \"object\") {\n      Logger.warn(`unable to set ${className} - expecting a properties object`);\n      return this;\n    }\n    const keys = new Set(Object.keys(properties));\n    for (const propertyKey of listDecoratedProperties(this)) {\n      if (keys.has(propertyKey)) {\n        const value = properties[propertyKey];\n        const self = this;\n        if (isProperties(self[propertyKey])) {\n          if (self[propertyKey] instanceof PropertiesArray) {\n            const array2 = self[propertyKey].reset(value);\n            if (array2 != null) {\n              self[propertyKey] = array2;\n            } else {\n              Logger.warn(`unable to set [${propertyKey}] - expecting a properties array`);\n            }\n          } else {\n            self[propertyKey].set(value);\n          }\n        } else {\n          self[propertyKey] = value;\n        }\n        keys.delete(propertyKey);\n      }\n    }\n    for (const unknownKey of keys) {\n      Logger.warn(`unable to set [${unknownKey}] in ${className} - property is unknown`);\n    }\n    return this;\n  }\n  isValid(warningPrefix) {\n    return listDecoratedProperties(this).every((propertyKey) => {\n      const { optional } = extractDecoratedPropertyMetadata(this, propertyKey);\n      const valid = optional === true || typeof this[propertyKey] !== \"undefined\";\n      if (!valid) {\n        Logger.warnOnce(`${warningPrefix ?? \"\"}[${propertyKey}] is required.`);\n      }\n      return valid;\n    });\n  }\n  toJson() {\n    return listDecoratedProperties(this).reduce((object2, propertyKey) => {\n      const propertyValue = this[propertyKey];\n      object2[propertyKey] = isProperties(propertyValue) ? propertyValue.toJson() : propertyValue;\n      return object2;\n    }, {});\n  }\n};\nvar PropertiesArray = class _PropertiesArray extends Array {\n  constructor(itemFactory, ...properties) {\n    super(properties.length);\n    const isConstructor = (value2) => Boolean(value2?.prototype?.constructor?.name);\n    const value = isConstructor(itemFactory) ? (params) => new itemFactory().set(params) : itemFactory;\n    Object.defineProperty(this, \"itemFactory\", { value, enumerable: false, configurable: false });\n    this.set(properties);\n  }\n  set(properties) {\n    if (isArray(properties)) {\n      this.length = properties.length;\n      for (let i = 0; i < properties.length; i++) {\n        this[i] = this.itemFactory(properties[i]);\n      }\n    }\n    return this;\n  }\n  reset(properties) {\n    if (Array.isArray(properties)) {\n      return new _PropertiesArray(this.itemFactory, ...properties);\n    }\n  }\n  toJson() {\n    return this.map((value) => value?.toJson?.() ?? value);\n  }\n};\nfunction isProperties(value) {\n  return value instanceof BaseProperties || value instanceof PropertiesArray;\n}\n\n// packages/ag-charts-community/src/util/validation.ts\nfunction Validate(predicate, options = {}) {\n  const { optional = false, property: overrideProperty } = options;\n  return addTransformToInstanceProperty(\n    (target, property, value) => {\n      const context = { ...options, target, property };\n      if (optional && typeof value === \"undefined\" || predicate(value, context)) {\n        if (isProperties(target[property]) && !isProperties(value)) {\n          target[property].set(value);\n          return target[property];\n        }\n        return value;\n      }\n      const cleanKey = overrideProperty ?? String(property).replace(/^_*/, \"\");\n      const targetName = target.constructor.className ?? target.constructor.name.replace(/Properties$/, \"\");\n      let valueString = stringify(value);\n      const maxLength = 50;\n      if (valueString != null && valueString.length > maxLength) {\n        const excessCharacters = valueString.length - maxLength;\n        valueString = valueString.slice(0, maxLength) + `... (+${excessCharacters} characters)`;\n      }\n      Logger.warn(\n        `Property [${cleanKey}] of [${targetName}] cannot be set to [${valueString}]${predicate.message ? `; expecting ${getPredicateMessage(predicate, context)}` : \"\"}, ignoring.`\n      );\n      return BREAK_TRANSFORM_CHAIN;\n    },\n    void 0,\n    { optional }\n  );\n}\nvar AND = (...predicates) => {\n  const messages = [];\n  return predicateWithMessage(\n    (value, ctx) => {\n      messages.length = 0;\n      return predicates.every((predicate) => {\n        const isValid2 = predicate(value, ctx);\n        if (!isValid2) {\n          messages.push(getPredicateMessage(predicate, ctx));\n        }\n        return isValid2;\n      });\n    },\n    () => messages.filter(Boolean).join(\" AND \")\n  );\n};\nvar OR = (...predicates) => predicateWithMessage(\n  (value, ctx) => predicates.some((predicate) => predicate(value, ctx)),\n  (ctx) => predicates.map(getPredicateMessageMapper(ctx)).filter(Boolean).join(\" OR \")\n);\nvar OBJECT = attachObjectRestrictions(\n  predicateWithMessage(\n    (value, ctx) => isProperties(value) || isObject(value) && isProperties(ctx.target[ctx.property]),\n    \"a properties object\"\n  )\n);\nvar PLAIN_OBJECT = attachObjectRestrictions(predicateWithMessage((value) => isObject(value), \"an object\"));\nvar BOOLEAN = predicateWithMessage(isBoolean, \"a boolean\");\nvar FUNCTION = predicateWithMessage(isFunction, \"a function\");\nvar STRING = predicateWithMessage(isString, \"a string\");\nvar NUMBER = attachNumberRestrictions(predicateWithMessage(isFiniteNumber, \"a number\"));\nvar REAL_NUMBER = predicateWithMessage((value) => isNumber(value) && !isNaN(value), \"a real number\");\nvar NAN = predicateWithMessage((value) => isNumber(value) && isNaN(value), \"NaN\");\nvar POSITIVE_NUMBER = NUMBER.restrict({ min: 0 });\nvar RATIO = NUMBER.restrict({ min: 0, max: 1 });\nvar DEGREE = NUMBER.restrict({ min: -360, max: 360 });\nvar NUMBER_OR_NAN = OR(NUMBER, NAN);\nvar ARRAY = attachArrayRestrictions(predicateWithMessage(isArray, \"an array\"));\nvar ARRAY_OF = (predicate, message) => predicateWithMessage(\n  (value, ctx) => isArray(value) && value.every((item) => predicate(item, ctx)),\n  (ctx) => {\n    const arrayMessage = getPredicateMessage(ARRAY, ctx) ?? \"\";\n    return message ? `${arrayMessage} of ${message}` : arrayMessage;\n  }\n);\nvar isComparable = (value) => isFiniteNumber(value) || isValidDate(value);\nvar LESS_THAN = (otherField) => predicateWithMessage(\n  (v, ctx) => !isComparable(v) || !isComparable(ctx.target[otherField]) || v < ctx.target[otherField],\n  `to be less than ${otherField}`\n);\nvar GREATER_THAN = (otherField) => predicateWithMessage(\n  (v, ctx) => !isComparable(v) || !isComparable(ctx.target[otherField]) || v > ctx.target[otherField],\n  `to be greater than ${otherField}`\n);\nvar DATE = predicateWithMessage(isValidDate, \"Date object\");\nvar DATE_OR_DATETIME_MS = OR(DATE, POSITIVE_NUMBER);\nvar colorMessage = `A color string can be in one of the following formats to be valid: #rgb, #rrggbb, rgb(r, g, b), rgba(r, g, b, a) or a CSS color name such as 'white', 'orange', 'cyan', etc`;\nvar COLOR_STRING = predicateWithMessage(\n  (v) => isString(v) && Color.validColorString(v),\n  `color String. ${colorMessage}`\n);\nvar COLOR_STRING_ARRAY = predicateWithMessage(ARRAY_OF(COLOR_STRING), `color strings. ${colorMessage}`);\nvar BOOLEAN_ARRAY = ARRAY_OF(BOOLEAN, \"boolean values\");\nvar NUMBER_ARRAY = ARRAY_OF(NUMBER, \"numbers\");\nvar STRING_ARRAY = ARRAY_OF(STRING, \"strings\");\nvar DATE_ARRAY = predicateWithMessage(ARRAY_OF(DATE), \"Date objects\");\nvar OBJECT_ARRAY = predicateWithMessage(ARRAY_OF(OBJECT), \"objects\");\nvar LINE_CAP = UNION([\"butt\", \"round\", \"square\"], \"a line cap\");\nvar LINE_JOIN = UNION([\"round\", \"bevel\", \"miter\"], \"a line join\");\nvar LINE_STYLE = UNION([\"solid\", \"dashed\", \"dotted\"], \"a line style\");\nvar LINE_DASH = predicateWithMessage(\n  ARRAY_OF(POSITIVE_NUMBER),\n  \"numbers specifying the length in pixels of alternating dashes and gaps, for example, [6, 3] means dashes with a length of 6 pixels with gaps between of 3 pixels.\"\n);\nvar POSITION = UNION([\"top\", \"right\", \"bottom\", \"left\"], \"a position\");\nvar FONT_STYLE = UNION([\"normal\", \"italic\", \"oblique\"], \"a font style\");\nvar FONT_WEIGHT = OR(\n  UNION([\"normal\", \"bold\", \"bolder\", \"lighter\"], \"a font weight\"),\n  NUMBER.restrict({ min: 1, max: 1e3 })\n);\nvar TEXT_WRAP = UNION([\"never\", \"always\", \"hyphenate\", \"on-space\"], \"a text wrap strategy\");\nvar TEXT_ALIGN = UNION([\"left\", \"center\", \"right\"], \"a text align\");\nvar VERTICAL_ALIGN = UNION([\"top\", \"middle\", \"bottom\"], \"a vertical align\");\nvar OVERFLOW_STRATEGY = UNION([\"ellipsis\", \"hide\"], \"an overflow strategy\");\nvar DIRECTION = UNION([\"horizontal\", \"vertical\"], \"a direction\");\nvar PLACEMENT = UNION([\"inside\", \"outside\"], \"a placement\");\nvar INTERACTION_RANGE = OR(UNION([\"exact\", \"nearest\"], \"interaction range\"), NUMBER);\nvar LABEL_PLACEMENT = UNION([\"top\", \"bottom\", \"left\", \"right\"]);\nfunction UNION(options, message = \"a\") {\n  return predicateWithMessage(\n    (v, ctx) => {\n      const option = options.find((o) => {\n        const value = typeof o === \"string\" ? o : o.value;\n        return v === value;\n      });\n      if (option == null)\n        return false;\n      if (typeof option !== \"string\" && (option.deprecated === true || option.deprecatedTo != null)) {\n        const messages = [`Property [%s] with value '${option.value}' is deprecated.`];\n        if (option.deprecatedTo) {\n          messages.push(`Use ${option.deprecatedTo} instead.`);\n        }\n        Logger.warnOnce(messages.join(\" \"), ctx.property);\n      }\n      return true;\n    },\n    `${message} keyword such as ${joinUnionOptions(options)}`\n  );\n}\nvar MIN_SPACING = OR(AND(NUMBER.restrict({ min: 1 }), LESS_THAN(\"maxSpacing\")), NAN);\nvar MAX_SPACING = OR(AND(NUMBER.restrict({ min: 1 }), GREATER_THAN(\"minSpacing\")), NAN);\nfunction predicateWithMessage(predicate, message) {\n  predicate.message = message;\n  return predicate;\n}\nfunction joinUnionOptions(options) {\n  const values = options.filter((option) => typeof option === \"string\" || option.undocumented !== true).map((option) => `'${typeof option === \"string\" ? option : option.value}'`);\n  if (values.length === 1) {\n    return values[0];\n  }\n  const lastValue = values.pop();\n  return `${values.join(\", \")} or ${lastValue}`;\n}\nfunction getPredicateMessage(predicate, ctx) {\n  return isFunction(predicate.message) ? predicate.message(ctx) : predicate.message;\n}\nfunction getPredicateMessageMapper(ctx) {\n  return (predicate) => getPredicateMessage(predicate, ctx);\n}\nfunction attachArrayRestrictions(predicate) {\n  return Object.assign(predicate, {\n    restrict({ length: length2, minLength } = {}) {\n      let message = \"an array\";\n      if (isNumber(minLength) && minLength > 0) {\n        message = \"a non-empty array\";\n      } else if (isNumber(length2)) {\n        message = `an array of length ${length2}`;\n      }\n      return predicateWithMessage(\n        (value) => isArray(value) && (isNumber(length2) ? value.length === length2 : true) && (isNumber(minLength) ? value.length >= minLength : true),\n        message\n      );\n    }\n  });\n}\nfunction attachNumberRestrictions(predicate) {\n  return Object.assign(predicate, {\n    restrict({ min, max } = {}) {\n      const message = [\"a number\"];\n      const hasMin = isNumber(min);\n      const hasMax = isNumber(max);\n      if (hasMin && hasMax) {\n        message.push(`between ${min} and ${max} inclusive`);\n      } else if (hasMin) {\n        message.push(`greater than or equal to ${min}`);\n      } else if (hasMax) {\n        message.push(`less than or equal to ${max}`);\n      }\n      return predicateWithMessage(\n        (value) => isFiniteNumber(value) && (hasMin ? value >= min : true) && (hasMax ? value <= max : true),\n        message.join(\" \")\n      );\n    }\n  });\n}\nfunction attachObjectRestrictions(predicate) {\n  return Object.assign(predicate, {\n    restrict(objectType) {\n      return predicateWithMessage(\n        (value) => value instanceof objectType,\n        (ctx) => getPredicateMessage(predicate, ctx) ?? `an instance of ${objectType.name}`\n      );\n    }\n  });\n}\nfunction stringify(value) {\n  if (typeof value === \"number\") {\n    if (isNaN(value))\n      return \"NaN\";\n    if (value === Infinity)\n      return \"Infinity\";\n    if (value === -Infinity)\n      return \"-Infinity\";\n  }\n  return JSON.stringify(value);\n}\n\n// packages/ag-charts-community/src/chart/chartAxisDirection.ts\nvar ChartAxisDirection = /* @__PURE__ */ ((ChartAxisDirection2) => {\n  ChartAxisDirection2[\"X\"] = \"x\";\n  ChartAxisDirection2[\"Y\"] = \"y\";\n  return ChartAxisDirection2;\n})(ChartAxisDirection || {});\n\n// packages/ag-charts-community/src/module/moduleMap.ts\nvar ModuleMap = class {\n  constructor() {\n    this.moduleMap = /* @__PURE__ */ new Map();\n  }\n  *modules() {\n    for (const m of this.moduleMap.values()) {\n      yield m.moduleInstance;\n    }\n  }\n  addModule(module, moduleFactory) {\n    if (this.moduleMap.has(module.optionsKey)) {\n      throw new Error(`AG Charts - module already initialised: ${module.optionsKey}`);\n    }\n    this.moduleMap.set(module.optionsKey, { module, moduleInstance: moduleFactory(module) });\n  }\n  removeModule(module) {\n    const moduleKey = isString(module) ? module : module.optionsKey;\n    this.moduleMap.get(moduleKey)?.moduleInstance.destroy();\n    this.moduleMap.delete(moduleKey);\n  }\n  getModule(module) {\n    return this.moduleMap.get(isString(module) ? module : module.optionsKey)?.moduleInstance;\n  }\n  isEnabled(module) {\n    return this.moduleMap.has(isString(module) ? module : module.optionsKey);\n  }\n  mapModules(callback2) {\n    return Array.from(this.moduleMap.values(), (m, i) => callback2(m.moduleInstance, i));\n  }\n  destroy() {\n    for (const moduleKey of this.moduleMap.keys()) {\n      this.moduleMap.get(moduleKey)?.moduleInstance.destroy();\n    }\n    this.moduleMap.clear();\n  }\n};\n\n// packages/ag-charts-community/src/motion/resetMotion.ts\nvar resetMotion_exports = {};\n__export(resetMotion_exports, {\n  resetMotion: () => resetMotion\n});\nfunction resetMotion(selectionsOrNodes, propsFn) {\n  const { nodes, selections } = deconstructSelectionsOrNodes(selectionsOrNodes);\n  for (const selection of selections) {\n    for (const node of selection.nodes()) {\n      const from3 = propsFn(node, node.datum);\n      node.setProperties(from3);\n    }\n    selection.cleanup();\n  }\n  for (const node of nodes) {\n    const from3 = propsFn(node, node.datum);\n    node.setProperties(from3);\n  }\n}\n\n// packages/ag-charts-community/src/util/numberFormat.ts\nfunction parseFormat(format) {\n  let prefix;\n  let suffix;\n  const surrounded = surroundedRegEx.exec(format);\n  if (surrounded) {\n    [, prefix, format, suffix] = surrounded;\n  }\n  const match = formatRegEx.exec(format);\n  if (!match) {\n    throw new Error(`The number formatter is invalid: ${format}`);\n  }\n  const [, fill, align, sign, symbol, zero, width2, comma, precision, trim, type] = match;\n  return {\n    fill,\n    align,\n    sign,\n    symbol,\n    zero,\n    width: parseInt(width2),\n    comma,\n    precision: parseInt(precision),\n    trim: Boolean(trim),\n    type,\n    prefix,\n    suffix\n  };\n}\nfunction numberFormat(format) {\n  const options = typeof format === \"string\" ? parseFormat(format) : format;\n  const { fill, align, sign = \"-\", symbol, zero, width: width2, comma, type, prefix = \"\", suffix = \"\", precision } = options;\n  let { trim } = options;\n  const precisionIsNaN = precision == null || isNaN(precision);\n  let formatBody;\n  if (!type) {\n    formatBody = decimalTypes[\"g\"];\n    trim = true;\n  } else if (type in decimalTypes && type in integerTypes) {\n    formatBody = precisionIsNaN ? integerTypes[type] : decimalTypes[type];\n  } else if (type in decimalTypes) {\n    formatBody = decimalTypes[type];\n  } else if (type in integerTypes) {\n    formatBody = integerTypes[type];\n  } else {\n    throw new Error(`The number formatter type is invalid: ${type}`);\n  }\n  let formatterPrecision;\n  if (precision == null || precisionIsNaN) {\n    formatterPrecision = type ? 6 : 12;\n  } else {\n    formatterPrecision = precision;\n  }\n  return (n) => {\n    let result = formatBody(n, formatterPrecision);\n    if (trim) {\n      result = removeTrailingZeros(result);\n    }\n    if (comma) {\n      result = insertSeparator(result, comma);\n    }\n    result = addSign(n, result, sign);\n    if (symbol && symbol !== \"#\") {\n      result = `${symbol}${result}`;\n    }\n    if (symbol === \"#\" && type === \"x\") {\n      result = `0x${result}`;\n    }\n    if (type === \"s\") {\n      result = `${result}${getSIPrefix(n)}`;\n    }\n    if (type === \"%\" || type === \"p\") {\n      result = `${result}%`;\n    }\n    if (width2 != null && !isNaN(width2)) {\n      result = addPadding(result, width2, fill ?? zero, align);\n    }\n    result = `${prefix}${result}${suffix}`;\n    return result;\n  };\n}\nvar formatRegEx = /^(?:(.)?([<>=^]))?([+\\-( ])?([$€£¥₣₹#])?(0)?(\\d+)?(,)?(?:\\.(\\d+))?(~)?([%a-z])?$/i;\nvar surroundedRegEx = /^((?:[^#]|#[^{])*)#{([^}]+)}(.*)$/;\nvar integerTypes = {\n  b: (n) => absFloor(n).toString(2),\n  c: (n) => String.fromCharCode(n),\n  d: (n) => Math.round(Math.abs(n)).toFixed(0),\n  o: (n) => absFloor(n).toString(8),\n  x: (n) => absFloor(n).toString(16),\n  X: (n) => integerTypes.x(n).toUpperCase(),\n  n: (n) => integerTypes.d(n),\n  \"%\": (n) => `${absFloor(n * 100).toFixed(0)}`\n};\nvar decimalTypes = {\n  e: (n, f) => Math.abs(n).toExponential(f),\n  E: (n, f) => decimalTypes.e(n, f).toUpperCase(),\n  f: (n, f) => Math.abs(n).toFixed(f),\n  F: (n, f) => decimalTypes.f(n, f).toUpperCase(),\n  g: (n, f) => {\n    if (n === 0) {\n      return \"0\";\n    }\n    const a = Math.abs(n);\n    const p = Math.floor(Math.log10(a));\n    if (p >= -4 && p < f) {\n      return a.toFixed(f - 1 - p);\n    }\n    return a.toExponential(f - 1);\n  },\n  G: (n, f) => decimalTypes.g(n, f).toUpperCase(),\n  n: (n, f) => decimalTypes.g(n, f),\n  p: (n, f) => decimalTypes.r(n * 100, f),\n  r: (n, f) => {\n    if (n === 0) {\n      return \"0\";\n    }\n    const a = Math.abs(n);\n    const p = Math.floor(Math.log10(a));\n    const q = p - (f - 1);\n    if (q <= 0) {\n      return a.toFixed(-q);\n    }\n    const x = 10 ** q;\n    return (Math.round(a / x) * x).toFixed();\n  },\n  s: (n, f) => {\n    const p = getSIPrefixPower(n);\n    return decimalTypes.r(n / 10 ** p, f);\n  },\n  \"%\": (n, f) => decimalTypes.f(n * 100, f)\n};\nvar minSIPrefix = -24;\nvar maxSIPrefix = 24;\nvar siPrefixes = {\n  [minSIPrefix]: \"y\",\n  [-21]: \"z\",\n  [-18]: \"a\",\n  [-15]: \"f\",\n  [-12]: \"p\",\n  [-9]: \"n\",\n  [-6]: \"\\xB5\",\n  [-3]: \"m\",\n  [0]: \"\",\n  [3]: \"k\",\n  [6]: \"M\",\n  [9]: \"G\",\n  [12]: \"T\",\n  [15]: \"P\",\n  [18]: \"E\",\n  [21]: \"Z\",\n  [maxSIPrefix]: \"Y\"\n};\nvar minusSign = \"\\u2212\";\nfunction absFloor(n) {\n  return Math.floor(Math.abs(n));\n}\nfunction removeTrailingZeros(numString) {\n  return numString.replace(/\\.0+$/, \"\").replace(/(\\.[1-9])0+$/, \"$1\");\n}\nfunction insertSeparator(numString, separator) {\n  let dotIndex = numString.indexOf(\".\");\n  if (dotIndex < 0) {\n    dotIndex = numString.length;\n  }\n  const integerChars = numString.substring(0, dotIndex).split(\"\");\n  const fractionalPart = numString.substring(dotIndex);\n  for (let i = integerChars.length - 3; i > 0; i -= 3) {\n    integerChars.splice(i, 0, separator);\n  }\n  return `${integerChars.join(\"\")}${fractionalPart}`;\n}\nfunction getSIPrefix(n) {\n  return siPrefixes[getSIPrefixPower(n)];\n}\nfunction getSIPrefixPower(n) {\n  return clamp(minSIPrefix, n ? Math.floor(Math.log10(Math.abs(n)) / 3) * 3 : 0, maxSIPrefix);\n}\nfunction addSign(num, numString, signType = \"\") {\n  if (signType === \"(\") {\n    return num >= 0 ? numString : `(${numString})`;\n  }\n  const plusSign = signType === \"+\" ? \"+\" : \"\";\n  return `${num >= 0 ? plusSign : minusSign}${numString}`;\n}\nfunction addPadding(numString, width2, fill = \" \", align = \">\") {\n  let result = numString;\n  if (align === \">\" || !align) {\n    result = result.padStart(width2, fill);\n  } else if (align === \"<\") {\n    result = result.padEnd(width2, fill);\n  } else if (align === \"^\") {\n    const padWidth = Math.max(0, width2 - result.length);\n    const padLeft = Math.ceil(padWidth / 2);\n    const padRight = Math.floor(padWidth / 2);\n    result = result.padStart(padLeft + result.length, fill);\n    result = result.padEnd(padRight + result.length, fill);\n  }\n  return result;\n}\n\n// packages/ag-charts-community/src/util/ticks.ts\nvar tInterval = (timeInterval, baseDuration, step) => ({\n  duration: baseDuration * step,\n  timeInterval,\n  step\n});\nvar TickIntervals = [\n  tInterval(second_default, durationSecond, 1),\n  tInterval(second_default, durationSecond, 5),\n  tInterval(second_default, durationSecond, 15),\n  tInterval(second_default, durationSecond, 30),\n  tInterval(minute_default, durationMinute, 1),\n  tInterval(minute_default, durationMinute, 5),\n  tInterval(minute_default, durationMinute, 15),\n  tInterval(minute_default, durationMinute, 30),\n  tInterval(hour_default, durationHour, 1),\n  tInterval(hour_default, durationHour, 3),\n  tInterval(hour_default, durationHour, 6),\n  tInterval(hour_default, durationHour, 12),\n  tInterval(day_default, durationDay, 1),\n  tInterval(day_default, durationDay, 2),\n  tInterval(week_default, durationWeek, 1),\n  tInterval(week_default, durationWeek, 2),\n  tInterval(week_default, durationWeek, 3),\n  tInterval(month_default, durationMonth, 1),\n  tInterval(month_default, durationMonth, 2),\n  tInterval(month_default, durationMonth, 3),\n  tInterval(month_default, durationMonth, 4),\n  tInterval(month_default, durationMonth, 6),\n  tInterval(year_default, durationYear, 1)\n];\nvar TickMultipliers = [1, 2, 5, 10];\nfunction isCloseToInteger(n, delta4) {\n  return Math.abs(Math.round(n) - n) < delta4;\n}\nfunction createTicks(start2, stop, count, minCount, maxCount) {\n  if (count < 2) {\n    return [start2, stop];\n  }\n  const step = tickStep(start2, stop, count, minCount, maxCount);\n  if (!Number.isFinite(step)) {\n    return [];\n  }\n  if (!isCloseToInteger(start2 / step, 1e-12)) {\n    start2 = Math.ceil(start2 / step) * step;\n  }\n  if (!isCloseToInteger(stop / step, 1e-12)) {\n    stop = Math.floor(stop / step) * step;\n  }\n  return range(start2, stop, step);\n}\nfunction getTickInterval(start2, stop, count, minCount, maxCount, targetInterval) {\n  const target = targetInterval ?? Math.abs(stop - start2) / Math.max(count, 1);\n  let i = 0;\n  for (const tickInterval of TickIntervals) {\n    if (target <= tickInterval.duration)\n      break;\n    i++;\n  }\n  if (i === 0) {\n    const step2 = Math.max(tickStep(start2, stop, count, minCount, maxCount), 1);\n    return millisecond_default.every(step2);\n  } else if (i === TickIntervals.length) {\n    const step2 = targetInterval == null ? tickStep(start2 / durationYear, stop / durationYear, count, minCount, maxCount) : 1;\n    return year_default.every(step2);\n  }\n  const i0 = TickIntervals[i - 1];\n  const i1 = TickIntervals[i];\n  const { timeInterval, step } = target - i0.duration < i1.duration - target ? i0 : i1;\n  return timeInterval.every(step);\n}\nfunction tickStep(start2, end2, count, minCount = 0, maxCount = Infinity) {\n  if (start2 === end2) {\n    return clamp(1, minCount, maxCount);\n  } else if (count < 1) {\n    return NaN;\n  }\n  const extent2 = Math.abs(end2 - start2);\n  const step = 10 ** Math.floor(Math.log10(extent2 / count));\n  let m = NaN, minDiff = Infinity, isInBounds = false;\n  for (const multiplier of TickMultipliers) {\n    const c = Math.ceil(extent2 / (multiplier * step));\n    const validBounds = c >= minCount && c <= maxCount;\n    if (isInBounds && !validBounds)\n      continue;\n    const diffCount = Math.abs(c - count);\n    if (minDiff > diffCount || isInBounds !== validBounds) {\n      isInBounds || (isInBounds = validBounds);\n      minDiff = diffCount;\n      m = multiplier;\n    }\n  }\n  return m * step;\n}\nfunction decimalPlaces(decimal) {\n  for (let i = decimal.length - 1; i >= 0; i -= 1) {\n    if (decimal[i] !== \"0\") {\n      return i + 1;\n    }\n  }\n  return 0;\n}\nfunction tickFormat(ticks, format) {\n  const options = parseFormat(format ?? \",f\");\n  if (options.precision == null || isNaN(options.precision)) {\n    if (!options.type || \"eEFgGnprs\".includes(options.type)) {\n      options.precision = Math.max(\n        ...ticks.map((x) => {\n          if (!Number.isFinite(x))\n            return 0;\n          const [integer, decimal] = x.toExponential((options.type ? 6 : 12) - 1).split(/\\.|e/g);\n          return (integer !== \"1\" && integer !== \"-1\" ? 1 : 0) + decimalPlaces(decimal) + 1;\n        })\n      );\n    } else if (\"f%\".includes(options.type)) {\n      options.precision = Math.max(\n        ...ticks.map((x) => {\n          if (!Number.isFinite(x) || x === 0)\n            return 0;\n          const l = Math.floor(Math.log10(Math.abs(x)));\n          const digits = options.type ? 6 : 12;\n          const decimal = x.toExponential(digits - 1).split(/\\.|e/g)[1];\n          const decimalLength = decimalPlaces(decimal);\n          return Math.max(0, decimalLength - l);\n        })\n      );\n    }\n  }\n  const formatter = numberFormat(options);\n  return (n) => formatter(Number(n));\n}\nfunction range(start2, end2, step) {\n  if (!Number.isFinite(step) || step <= 0)\n    return [];\n  const f = 10 ** countFractionDigits(step);\n  const d0 = Math.min(start2, end2);\n  const d1 = Math.max(start2, end2);\n  const out = [];\n  for (let i = 0; ; i += 1) {\n    const p = Math.round((d0 + step * i) * f) / f;\n    if (p <= d1) {\n      out.push(p);\n    } else {\n      break;\n    }\n  }\n  return out;\n}\nfunction isDenseInterval(count, availableRange) {\n  if (count >= availableRange) {\n    Logger.warnOnce(\n      `the configured interval results in more than 1 item per pixel, ignoring. Supply a larger interval or omit this configuration`\n    );\n    return true;\n  }\n  return false;\n}\nfunction niceTicksDomain(start2, end2) {\n  const extent2 = Math.abs(end2 - start2);\n  const step = 10 ** Math.floor(Math.log10(extent2));\n  let minError = Infinity, ticks = [start2, end2];\n  for (const multiplier of TickMultipliers) {\n    const m = multiplier * step;\n    const d0 = Math.floor(start2 / m) * m;\n    const d1 = Math.ceil(end2 / m) * m;\n    const error = 1 - extent2 / Math.abs(d1 - d0);\n    if (minError > error) {\n      minError = error;\n      ticks = [d0, d1];\n    }\n  }\n  return ticks;\n}\nfunction estimateTickCount(rangeExtent, minSpacing, maxSpacing, defaultTickCount, defaultMinSpacing) {\n  defaultMinSpacing = Math.max(defaultMinSpacing, rangeExtent / (defaultTickCount + 1));\n  if (isNaN(minSpacing)) {\n    minSpacing = defaultMinSpacing;\n  }\n  if (isNaN(maxSpacing)) {\n    maxSpacing = rangeExtent;\n  }\n  if (minSpacing > maxSpacing) {\n    if (minSpacing === defaultMinSpacing) {\n      minSpacing = maxSpacing;\n    } else {\n      maxSpacing = minSpacing;\n    }\n  }\n  const maxTickCount = clamp(1, Math.floor(rangeExtent / minSpacing), Math.min(Math.floor(rangeExtent), 100));\n  const minTickCount = Math.min(maxTickCount, Math.ceil(rangeExtent / maxSpacing));\n  const tickCount = clamp(minTickCount, defaultTickCount, maxTickCount);\n  return { minTickCount, maxTickCount, tickCount };\n}\n\n// packages/ag-charts-community/src/scale/logScale.ts\nvar _LogScale = class _LogScale extends ContinuousScale {\n  constructor() {\n    super([1, 10], [0, 1]);\n    this.type = \"log\";\n    this.base = 10;\n    this.baseLog = identity;\n    this.basePow = identity;\n    this.log = (x) => {\n      const start2 = Math.min(...this.domain);\n      return start2 >= 0 ? this.baseLog(x) : -this.baseLog(-x);\n    };\n    this.pow = (x) => {\n      const start2 = Math.min(...this.domain);\n      return start2 >= 0 ? this.basePow(x) : -this.basePow(-x);\n    };\n    this.defaultClampMode = \"clamped\";\n  }\n  toDomain(d) {\n    return d;\n  }\n  transform(x) {\n    const start2 = Math.min(...this.domain);\n    return start2 >= 0 ? Math.log(x) : -Math.log(-x);\n  }\n  transformInvert(x) {\n    const start2 = Math.min(...this.domain);\n    return start2 >= 0 ? Math.exp(x) : -Math.exp(-x);\n  }\n  refresh() {\n    if (this.base <= 0) {\n      this.base = 0;\n      Logger.warnOnce(\"expecting a finite Number greater than to 0\");\n    }\n    super.refresh();\n  }\n  update() {\n    if (!this.domain || this.domain.length < 2) {\n      return;\n    }\n    this.baseLog = _LogScale.getBaseLogMethod(this.base);\n    this.basePow = _LogScale.getBasePowerMethod(this.base);\n    if (this.nice) {\n      this.updateNiceDomain();\n    }\n  }\n  updateNiceDomain() {\n    const [d0, d1] = this.domain;\n    const roundStart = d0 > d1 ? Math.ceil : Math.floor;\n    const roundStop = d0 > d1 ? Math.floor : Math.ceil;\n    const n0 = this.pow(roundStart(this.log(d0)));\n    const n1 = this.pow(roundStop(this.log(d1)));\n    this.niceDomain = [n0, n1];\n  }\n  ticks() {\n    const count = this.tickCount ?? 10;\n    if (!this.domain || this.domain.length < 2 || count < 1) {\n      return [];\n    }\n    this.refresh();\n    const base = this.base;\n    const [d0, d1] = this.getDomain();\n    const start2 = Math.min(d0, d1);\n    const stop = Math.max(d0, d1);\n    let p0 = this.log(start2);\n    let p1 = this.log(stop);\n    if (this.interval) {\n      const inBounds = (tick) => tick >= start2 && tick <= stop;\n      const step = Math.min(Math.abs(this.interval), Math.abs(p1 - p0));\n      const ticks2 = range(p0, p1, step).map(this.pow).filter(inBounds);\n      if (!isDenseInterval(ticks2.length, this.getPixelRange())) {\n        return ticks2;\n      }\n    }\n    const isBaseInteger = base % 1 === 0;\n    const isDiffLarge = p1 - p0 >= count;\n    if (!isBaseInteger || isDiffLarge) {\n      return createTicks(p0, p1, Math.min(p1 - p0, count)).map(this.pow);\n    }\n    const ticks = [];\n    const isPositive = start2 > 0;\n    p0 = Math.floor(p0) - 1;\n    p1 = Math.round(p1) + 1;\n    const availableSpacing = findRangeExtent(this.range) / count;\n    let lastTickPosition = Infinity;\n    for (let p = p0; p <= p1; p++) {\n      const nextMagnitudeTickPosition = this.convert(this.pow(p + 1));\n      for (let k = 1; k < base; k++) {\n        const q = isPositive ? k : base - k + 1;\n        const t = this.pow(p) * q;\n        const tickPosition = this.convert(t);\n        const prevSpacing = Math.abs(lastTickPosition - tickPosition);\n        const nextSpacing = Math.abs(tickPosition - nextMagnitudeTickPosition);\n        const fits = prevSpacing >= availableSpacing && nextSpacing >= availableSpacing;\n        if (t >= start2 && t <= stop && (k === 1 || fits || ticks.length === 0)) {\n          ticks.push(t);\n          lastTickPosition = tickPosition;\n        }\n      }\n    }\n    return ticks;\n  }\n  tickFormat({\n    count,\n    ticks,\n    specifier\n  }) {\n    if (count !== Infinity && ticks == null) {\n      this.ticks();\n    }\n    specifier ?? (specifier = this.base === 10 ? \".0e\" : \",\");\n    return isString(specifier) ? numberFormat(specifier) : specifier;\n  }\n  static getBaseLogMethod(base) {\n    switch (base) {\n      case 10:\n        return Math.log10;\n      case Math.E:\n        return Math.log;\n      case 2:\n        return Math.log2;\n      default:\n        return (x) => Math.log(x) / Math.log(base);\n    }\n  }\n  static getBasePowerMethod(base) {\n    switch (base) {\n      case 10:\n        return (x) => x >= 0 ? 10 ** x : 1 / 10 ** -x;\n      case Math.E:\n        return Math.exp;\n      default:\n        return (x) => base ** x;\n    }\n  }\n};\n__decorateClass([\n  Invalidating\n], _LogScale.prototype, \"base\", 2);\nvar LogScale = _LogScale;\n\n// packages/ag-charts-community/src/scale/timeScale.ts\nvar TimeScale = class _TimeScale extends ContinuousScale {\n  constructor() {\n    super([], [0, 1]);\n    this.type = \"time\";\n  }\n  toDomain(d) {\n    return new Date(d);\n  }\n  convert(x, opts) {\n    return super.convert(new Date(x), opts);\n  }\n  invert(y) {\n    return new Date(super.invert(y));\n  }\n  /**\n   * Returns uniformly-spaced dates that represent the scale's domain.\n   */\n  ticks() {\n    if (!this.domain || this.domain.length < 2) {\n      return [];\n    }\n    this.refresh();\n    const { interval, nice, tickCount, minTickCount, maxTickCount } = this;\n    const [start2, stop] = findMinMax(this.getDomain().map(dateToNumber));\n    if (interval != null) {\n      return _TimeScale.getTicksForInterval({ start: start2, stop, interval, availableRange: this.getPixelRange() }) ?? _TimeScale.getDefaultTicks({ start: start2, stop, tickCount, minTickCount, maxTickCount });\n    } else if (nice && tickCount === 2) {\n      return this.niceDomain;\n    } else if (nice && tickCount === 1) {\n      return this.niceDomain.slice(0, 1);\n    }\n    return _TimeScale.getDefaultTicks({ start: start2, stop, tickCount, minTickCount, maxTickCount });\n  }\n  static getDefaultTicks({\n    start: start2,\n    stop,\n    tickCount,\n    minTickCount,\n    maxTickCount\n  }) {\n    const t = getTickInterval(start2, stop, tickCount, minTickCount, maxTickCount);\n    return t ? t.range(new Date(start2), new Date(stop)) : [];\n  }\n  static getTicksForInterval({\n    start: start2,\n    stop,\n    interval,\n    availableRange\n  }) {\n    if (!interval) {\n      return [];\n    }\n    if (interval instanceof TimeInterval) {\n      const ticks2 = interval.range(new Date(start2), new Date(stop));\n      if (isDenseInterval(ticks2.length, availableRange)) {\n        return;\n      }\n      return ticks2;\n    }\n    const absInterval = Math.abs(interval);\n    if (isDenseInterval((stop - start2) / absInterval, availableRange))\n      return;\n    const timeInterval = TickIntervals.findLast((tickInterval) => absInterval % tickInterval.duration === 0);\n    if (timeInterval) {\n      const i = timeInterval.timeInterval.every(absInterval / (timeInterval.duration / timeInterval.step));\n      return i.range(new Date(start2), new Date(stop));\n    }\n    let date = new Date(start2);\n    const stopDate = new Date(stop);\n    const ticks = [];\n    while (date <= stopDate) {\n      ticks.push(date);\n      date = new Date(date);\n      date.setMilliseconds(date.getMilliseconds() + absInterval);\n    }\n    return ticks;\n  }\n  /**\n   * Returns a time format function suitable for displaying tick values.\n   *\n   * @param ticks Optional array of tick values for custom formatting.\n   * @param domain Optional array representing the [min, max] values of the time axis.\n   * @param specifier Optional format specifier string for custom date formatting (e.g., `%Y`, `%m`, `%d`).\n   * @param formatOffset Optional number for applying an offset to the format (e.g., timezone shifts).\n   * @returns A function that formats a `Date` object into a string based on the provided specifier or default format.\n   */\n  tickFormat({\n    ticks,\n    domain,\n    specifier,\n    formatOffset\n  }) {\n    return specifier == null ? defaultTimeTickFormat(ticks, domain, formatOffset) : buildFormatter(specifier);\n  }\n  update() {\n    if (!this.domain || this.domain.length < 2) {\n      return;\n    }\n    if (this.nice) {\n      this.updateNiceDomain();\n    }\n  }\n  /**\n   * Extends the domain so that it starts and ends on nice round values.\n   * This method typically modifies the scale’s domain, and may only extend the bounds to the nearest round value.\n   */\n  updateNiceDomain() {\n    const maxAttempts = 4;\n    let [d0, d1] = this.domain;\n    for (let i = 0; i < maxAttempts; i++) {\n      this.updateNiceDomainIteration(d0, d1);\n      const [n0, n1] = this.niceDomain;\n      if (dateToNumber(d0) === dateToNumber(n0) && dateToNumber(d1) === dateToNumber(n1)) {\n        break;\n      }\n      d0 = n0;\n      d1 = n1;\n    }\n  }\n  updateNiceDomainIteration(d0, d1) {\n    const start2 = Math.min(dateToNumber(d0), dateToNumber(d1));\n    const stop = Math.max(dateToNumber(d0), dateToNumber(d1));\n    const isReversed = d0 > d1;\n    const { interval } = this;\n    let i;\n    if (interval instanceof TimeInterval) {\n      i = interval;\n    } else {\n      const tickCount = typeof interval === \"number\" ? (stop - start2) / Math.max(interval, 1) : this.tickCount;\n      i = getTickInterval(start2, stop, tickCount, this.minTickCount, this.maxTickCount);\n    }\n    if (i) {\n      const intervalRange = i.range(new Date(start2), new Date(stop), true);\n      const domain = isReversed ? [...intervalRange].reverse() : intervalRange;\n      const n0 = domain[0];\n      const n1 = domain.at(-1);\n      this.niceDomain = [n0, n1];\n    }\n  }\n};\n\n// packages/ag-charts-community/src/scale/ordinalTimeScale.ts\nfunction compareNumbers(a, b) {\n  return a - b;\n}\nvar _OrdinalTimeScale = class _OrdinalTimeScale extends BandScale {\n  constructor() {\n    super(...arguments);\n    this.type = \"ordinal-time\";\n    this.tickCount = ContinuousScale.defaultTickCount;\n    this.minTickCount = 0;\n    this.maxTickCount = Infinity;\n    this.interval = void 0;\n    this._domain = [];\n    this.timestamps = [];\n    this.sortedTimestamps = [];\n    this.visibleRange = [0, 1];\n  }\n  static is(value) {\n    return value instanceof _OrdinalTimeScale;\n  }\n  setVisibleRange(visibleRange) {\n    this.visibleRange = visibleRange;\n  }\n  set domain(values) {\n    this.invalid = true;\n    if (values.length === 0) {\n      this._domain = [];\n      return;\n    }\n    this._domain = values;\n    this.timestamps = unique(values.map(dateToNumber));\n    this.sortedTimestamps = this.timestamps.slice().sort(compareNumbers);\n  }\n  get domain() {\n    return this._domain;\n  }\n  ticks() {\n    this.refresh();\n    const [t0, t1] = [this.timestamps[0], this.timestamps.at(-1)];\n    const start2 = Math.min(t0, t1);\n    const stop = Math.max(t0, t1);\n    const isReversed = t0 > t1;\n    let ticks;\n    if (this.interval == null) {\n      ticks = this.getDefaultTicks(this.maxTickCount, isReversed);\n    } else {\n      const [r0, r1] = this.range;\n      const availableRange = Math.abs(r1 - r0);\n      ticks = TimeScale.getTicksForInterval({ start: start2, stop, interval: this.interval, availableRange }) ?? [];\n    }\n    const tickPositions = /* @__PURE__ */ new Set();\n    return ticks.filter((tick) => {\n      const position = this.convert(tick);\n      if (isNaN(position) || tickPositions.has(position)) {\n        return false;\n      }\n      tickPositions.add(position);\n      return true;\n    });\n  }\n  getDefaultTicks(maxTickCount, isReversed) {\n    const ticks = [];\n    const count = this.timestamps.length;\n    const tickEvery = Math.ceil(count * (this.visibleRange[1] - this.visibleRange[0]) / maxTickCount);\n    const tickOffset = Math.floor(tickEvery / 2);\n    for (const [index, value] of this.timestamps.entries()) {\n      if (tickEvery > 0 && (index + tickOffset) % tickEvery)\n        continue;\n      if (isReversed) {\n        ticks.push(new Date(this.timestamps[count - index - 1]));\n      } else {\n        ticks.push(new Date(value));\n      }\n    }\n    return ticks;\n  }\n  convert(d) {\n    this.refresh();\n    const n = Number(d);\n    if (n < this.sortedTimestamps[0]) {\n      return NaN;\n    }\n    let i = this.findInterval(n);\n    if (this.timestamps[0] !== this.sortedTimestamps[0]) {\n      i = this.timestamps.length - i - 1;\n    }\n    return this.ordinalRange[i] ?? NaN;\n  }\n  findInterval(target) {\n    const { sortedTimestamps } = this;\n    let low = 0;\n    let high = sortedTimestamps.length - 1;\n    while (low <= high) {\n      const mid = Math.floor((low + high) / 2);\n      if (sortedTimestamps[mid] === target) {\n        return mid;\n      } else if (sortedTimestamps[mid] < target) {\n        low = mid + 1;\n      } else {\n        high = mid - 1;\n      }\n    }\n    return low;\n  }\n  /**\n   * Returns a time format function suitable for displaying tick values.\n   * @param specifier If the specifier string is provided, this method is equivalent to\n   * the {@link TimeLocaleObject.format} method.\n   * If no specifier is provided, this method returns the default time format function.\n   */\n  tickFormat({\n    ticks,\n    domain,\n    specifier\n  }) {\n    return specifier == null ? defaultTimeTickFormat(ticks, domain) : buildFormatter(specifier);\n  }\n  invert(position) {\n    this.refresh();\n    const index = this.ordinalRange.findIndex((p) => position <= p);\n    return this.domain[index];\n  }\n  invertNearest(y) {\n    return new Date(super.invertNearest(y));\n  }\n};\n__decorateClass([\n  Invalidating\n], _OrdinalTimeScale.prototype, \"tickCount\", 2);\n__decorateClass([\n  Invalidating\n], _OrdinalTimeScale.prototype, \"minTickCount\", 2);\n__decorateClass([\n  Invalidating\n], _OrdinalTimeScale.prototype, \"maxTickCount\", 2);\n__decorateClass([\n  Invalidating\n], _OrdinalTimeScale.prototype, \"interval\", 2);\nvar OrdinalTimeScale = _OrdinalTimeScale;\n\n// packages/ag-charts-community/src/util/compare.ts\nfunction ascendingStringNumberUndefined(a, b) {\n  if (typeof a === \"number\" && typeof b === \"number\") {\n    return a - b;\n  } else if (typeof a === \"string\" && typeof b === \"string\") {\n    return a.localeCompare(b);\n  } else if (a == null && b == null) {\n    return 0;\n  } else if (a == null) {\n    return -1;\n  } else if (b == null) {\n    return 1;\n  }\n  return String(a).localeCompare(String(b));\n}\nfunction toLiteral(v) {\n  return typeof v === \"function\" ? v() : v;\n}\nfunction compoundAscending(a, b, comparator) {\n  for (const idx in a) {\n    const diff2 = comparator(toLiteral(a[idx]), toLiteral(b[idx]));\n    if (diff2 !== 0) {\n      return diff2;\n    }\n  }\n  return 0;\n}\n\n// packages/ag-charts-community/src/scene/debug.util.ts\nfunction nodeCount(node) {\n  let count = 1;\n  let visibleCount = node.visible ? 1 : 0;\n  let dirtyCount = node.dirty > 0 /* NONE */ ? 1 : 0;\n  for (const child of node.children(false)) {\n    const c = nodeCount(child);\n    count += c.count;\n    dirtyCount += c.dirtyCount;\n    visibleCount += c.visibleCount;\n  }\n  return { count, visibleCount, dirtyCount };\n}\n\n// packages/ag-charts-community/src/scene/matrix.ts\nvar IDENTITY_MATRIX_ELEMENTS = Object.freeze([1, 0, 0, 1, 0, 0]);\nfunction closeValue(val, ref, errorMargin = 1e-8) {\n  return val === ref || Math.abs(ref - val) < errorMargin;\n}\nvar _Matrix = class _Matrix {\n  get e() {\n    return [...this.elements];\n  }\n  constructor(elements2 = [...IDENTITY_MATRIX_ELEMENTS]) {\n    this.elements = elements2;\n  }\n  setElements(elements2) {\n    const e = this.elements;\n    e[0] = elements2[0];\n    e[1] = elements2[1];\n    e[2] = elements2[2];\n    e[3] = elements2[3];\n    e[4] = elements2[4];\n    e[5] = elements2[5];\n    return this;\n  }\n  get identity() {\n    const e = this.elements;\n    return closeValue(e[0], 1) && closeValue(e[1], 0) && closeValue(e[2], 0) && closeValue(e[3], 1) && closeValue(e[4], 0) && closeValue(e[5], 0);\n  }\n  /**\n   * Performs the AxB matrix multiplication and saves the result\n   * to `C`, if given, or to `A` otherwise.\n   */\n  AxB(A, B, C) {\n    const a = A[0] * B[0] + A[2] * B[1], b = A[1] * B[0] + A[3] * B[1], c = A[0] * B[2] + A[2] * B[3], d = A[1] * B[2] + A[3] * B[3], e = A[0] * B[4] + A[2] * B[5] + A[4], f = A[1] * B[4] + A[3] * B[5] + A[5];\n    C = C ?? A;\n    C[0] = a;\n    C[1] = b;\n    C[2] = c;\n    C[3] = d;\n    C[4] = e;\n    C[5] = f;\n  }\n  /**\n   * The `other` matrix gets post-multiplied to the current matrix.\n   * Returns the current matrix.\n   * @param other\n   */\n  multiplySelf(other) {\n    this.AxB(this.elements, other.elements);\n    return this;\n  }\n  /**\n   * The `other` matrix gets post-multiplied to the current matrix.\n   * Returns a new matrix.\n   * @param other\n   */\n  multiply(other) {\n    const elements2 = new Array(6);\n    if (other instanceof _Matrix) {\n      this.AxB(this.elements, other.elements, elements2);\n    } else {\n      this.AxB(this.elements, [other.a, other.b, other.c, other.d, other.e, other.f], elements2);\n    }\n    return new _Matrix(elements2);\n  }\n  preMultiplySelf(other) {\n    this.AxB(other.elements, this.elements, this.elements);\n    return this;\n  }\n  /**\n   * Returns the inverse of this matrix as a new matrix.\n   */\n  inverse() {\n    const el = this.elements;\n    let a = el[0], b = el[1], c = el[2], d = el[3];\n    const e = el[4], f = el[5];\n    const rD = 1 / (a * d - b * c);\n    a *= rD;\n    b *= rD;\n    c *= rD;\n    d *= rD;\n    return new _Matrix([d, -b, -c, a, c * f - d * e, b * e - a * f]);\n  }\n  /**\n   * Save the inverse of this matrix to the given matrix.\n   */\n  inverseTo(other) {\n    const el = this.elements;\n    let a = el[0], b = el[1], c = el[2], d = el[3];\n    const e = el[4], f = el[5];\n    const rD = 1 / (a * d - b * c);\n    a *= rD;\n    b *= rD;\n    c *= rD;\n    d *= rD;\n    other.setElements([d, -b, -c, a, c * f - d * e, b * e - a * f]);\n    return this;\n  }\n  invertSelf() {\n    const el = this.elements;\n    let a = el[0], b = el[1], c = el[2], d = el[3];\n    const e = el[4], f = el[5];\n    const rD = 1 / (a * d - b * c);\n    a *= rD;\n    b *= rD;\n    c *= rD;\n    d *= rD;\n    el[0] = d;\n    el[1] = -b;\n    el[2] = -c;\n    el[3] = a;\n    el[4] = c * f - d * e;\n    el[5] = b * e - a * f;\n    return this;\n  }\n  transformPoint(x, y) {\n    const e = this.elements;\n    return {\n      x: x * e[0] + y * e[2] + e[4],\n      y: x * e[1] + y * e[3] + e[5]\n    };\n  }\n  transformBBox(bbox, target) {\n    const el = this.elements;\n    const xx = el[0];\n    const xy = el[1];\n    const yx = el[2];\n    const yy = el[3];\n    const h_w = bbox.width * 0.5;\n    const h_h = bbox.height * 0.5;\n    const cx = bbox.x + h_w;\n    const cy = bbox.y + h_h;\n    const w = Math.abs(h_w * xx) + Math.abs(h_h * yx);\n    const h = Math.abs(h_w * xy) + Math.abs(h_h * yy);\n    target ?? (target = new BBox(0, 0, 0, 0));\n    target.x = cx * xx + cy * yx + el[4] - w;\n    target.y = cx * xy + cy * yy + el[5] - h;\n    target.width = w + w;\n    target.height = h + h;\n    return target;\n  }\n  toContext(ctx) {\n    if (this.identity) {\n      return;\n    }\n    const e = this.elements;\n    ctx.transform(e[0], e[1], e[2], e[3], e[4], e[5]);\n  }\n  static flyweight(sourceMatrix) {\n    return _Matrix.instance.setElements(sourceMatrix.elements);\n  }\n  static updateTransformMatrix(matrix, scalingX, scalingY, rotation, translationX, translationY, opts) {\n    const sx = scalingX;\n    const sy = scalingY;\n    let scx;\n    let scy;\n    if (sx === 1 && sy === 1) {\n      scx = 0;\n      scy = 0;\n    } else {\n      scx = opts?.scalingCenterX ?? 0;\n      scy = opts?.scalingCenterY ?? 0;\n    }\n    const r = rotation;\n    const cos = Math.cos(r);\n    const sin = Math.sin(r);\n    let rcx;\n    let rcy;\n    if (r === 0) {\n      rcx = 0;\n      rcy = 0;\n    } else {\n      rcx = opts?.rotationCenterX ?? 0;\n      rcy = opts?.rotationCenterY ?? 0;\n    }\n    const tx = translationX;\n    const ty = translationY;\n    const tx4 = scx * (1 - sx) - rcx;\n    const ty4 = scy * (1 - sy) - rcy;\n    matrix.setElements([\n      cos * sx,\n      sin * sx,\n      -sin * sy,\n      cos * sy,\n      cos * tx4 - sin * ty4 + rcx + tx,\n      sin * tx4 + cos * ty4 + rcy + ty\n    ]);\n    return matrix;\n  }\n  static fromContext(ctx) {\n    const domMatrix = ctx.getTransform();\n    return new _Matrix([domMatrix.a, domMatrix.b, domMatrix.c, domMatrix.d, domMatrix.e, domMatrix.f]);\n  }\n};\n_Matrix.instance = new _Matrix();\nvar Matrix = _Matrix;\n\n// packages/ag-charts-community/src/scene/transformable.ts\nfunction isMatrixTransform(node) {\n  return isMatrixTransformType(node.constructor);\n}\nvar MATRIX_TRANSFORM_TYPE = Symbol(\"isMatrixTransform\");\nfunction isMatrixTransformType(cstr) {\n  return cstr[MATRIX_TRANSFORM_TYPE] === true;\n}\nfunction MatrixTransform(Parent) {\n  var _a, _b;\n  const ParentNode = Parent;\n  if (isMatrixTransformType(Parent)) {\n    return Parent;\n  }\n  const TRANSFORM_MATRIX = Symbol(\"matrix_combined_transform\");\n  class MatrixTransformInternal extends ParentNode {\n    constructor() {\n      super(...arguments);\n      this[_b] = new Matrix();\n      this._dirtyTransform = true;\n    }\n    markDirtyTransform() {\n      this._dirtyTransform = true;\n      super.markDirty(3 /* MAJOR */);\n    }\n    updateMatrix(_matrix) {\n    }\n    computeTransformMatrix() {\n      if (!this._dirtyTransform)\n        return;\n      this[TRANSFORM_MATRIX].setElements(IDENTITY_MATRIX_ELEMENTS);\n      this.updateMatrix(this[TRANSFORM_MATRIX]);\n      this._dirtyTransform = false;\n    }\n    toParent(bbox) {\n      this.computeTransformMatrix();\n      if (this[TRANSFORM_MATRIX].identity)\n        return bbox.clone();\n      return this[TRANSFORM_MATRIX].transformBBox(bbox);\n    }\n    toParentPoint(x, y) {\n      this.computeTransformMatrix();\n      if (this[TRANSFORM_MATRIX].identity)\n        return { x, y };\n      return this[TRANSFORM_MATRIX].transformPoint(x, y);\n    }\n    fromParent(bbox) {\n      this.computeTransformMatrix();\n      if (this[TRANSFORM_MATRIX].identity)\n        return bbox.clone();\n      return this[TRANSFORM_MATRIX].inverse().transformBBox(bbox);\n    }\n    fromParentPoint(x, y) {\n      this.computeTransformMatrix();\n      if (this[TRANSFORM_MATRIX].identity)\n        return { x, y };\n      return this[TRANSFORM_MATRIX].inverse().transformPoint(x, y);\n    }\n    computeBBox() {\n      const bbox = super.computeBBox();\n      if (!bbox)\n        return bbox;\n      return this.toParent(bbox);\n    }\n    computeBBoxWithoutTransforms() {\n      return super.computeBBox();\n    }\n    pickNode(x, y, localCoords = false) {\n      if (!localCoords) {\n        ({ x, y } = this.fromParentPoint(x, y));\n      }\n      return super.pickNode(x, y);\n    }\n    render(renderCtx) {\n      if (this._dirtyTransform) {\n        this.computeTransformMatrix();\n        if (!renderCtx.forceRender) {\n          renderCtx = { ...renderCtx, forceRender: \"dirtyTransform\" };\n        }\n      }\n      const matrix = this[TRANSFORM_MATRIX];\n      let performRestore = false;\n      if (!matrix.identity) {\n        renderCtx.ctx.save();\n        performRestore = true;\n        matrix.toContext(renderCtx.ctx);\n      }\n      super.render(renderCtx);\n      if (performRestore) {\n        renderCtx.ctx.restore();\n      }\n    }\n    toSVG() {\n      const svg = super.toSVG();\n      const matrix = this[TRANSFORM_MATRIX];\n      if (matrix.identity || svg == null)\n        return svg;\n      const g = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n      g.append(...svg.elements);\n      const [a, b, c, d, e, f] = matrix.e;\n      g.setAttribute(\"transform\", `matrix(${a} ${b} ${c} ${d} ${e} ${f})`);\n      return {\n        elements: [g],\n        defs: svg.defs\n      };\n    }\n  }\n  _a = MATRIX_TRANSFORM_TYPE, _b = TRANSFORM_MATRIX;\n  MatrixTransformInternal[_a] = true;\n  return MatrixTransformInternal;\n}\nfunction Rotatable(Parent) {\n  var _a;\n  const ParentNode = Parent;\n  const ROTATABLE_MATRIX = Symbol(\"matrix_rotation\");\n  class RotatableInternal extends MatrixTransform(ParentNode) {\n    constructor() {\n      super(...arguments);\n      this[_a] = new Matrix();\n      this.rotationCenterX = null;\n      this.rotationCenterY = null;\n      this.rotation = 0;\n    }\n    updateMatrix(matrix) {\n      super.updateMatrix(matrix);\n      const { rotation, rotationCenterX, rotationCenterY } = this;\n      if (rotation === 0)\n        return;\n      Matrix.updateTransformMatrix(this[ROTATABLE_MATRIX], 1, 1, rotation, 0, 0, {\n        rotationCenterX,\n        rotationCenterY\n      });\n      matrix.multiplySelf(this[ROTATABLE_MATRIX]);\n    }\n  }\n  _a = ROTATABLE_MATRIX;\n  __decorateClass([\n    SceneChangeDetection({ type: \"transform\" })\n  ], RotatableInternal.prototype, \"rotationCenterX\", 2);\n  __decorateClass([\n    SceneChangeDetection({ type: \"transform\" })\n  ], RotatableInternal.prototype, \"rotationCenterY\", 2);\n  __decorateClass([\n    SceneChangeDetection({ type: \"transform\" })\n  ], RotatableInternal.prototype, \"rotation\", 2);\n  return RotatableInternal;\n}\nfunction Scalable(Parent) {\n  var _a;\n  const ParentNode = Parent;\n  const SCALABLE_MATRIX = Symbol(\"matrix_scale\");\n  class ScalableInternal extends MatrixTransform(ParentNode) {\n    constructor() {\n      super(...arguments);\n      this[_a] = new Matrix();\n      this.scalingX = 1;\n      this.scalingY = 1;\n      this.scalingCenterX = null;\n      this.scalingCenterY = null;\n    }\n    updateMatrix(matrix) {\n      super.updateMatrix(matrix);\n      const { scalingX, scalingY, scalingCenterX, scalingCenterY } = this;\n      if (scalingX === 1 && scalingY === 1)\n        return;\n      Matrix.updateTransformMatrix(this[SCALABLE_MATRIX], scalingX, scalingY, 0, 0, 0, {\n        scalingCenterX,\n        scalingCenterY\n      });\n      matrix.multiplySelf(this[SCALABLE_MATRIX]);\n    }\n  }\n  _a = SCALABLE_MATRIX;\n  __decorateClass([\n    SceneChangeDetection({ type: \"transform\" })\n  ], ScalableInternal.prototype, \"scalingX\", 2);\n  __decorateClass([\n    SceneChangeDetection({ type: \"transform\" })\n  ], ScalableInternal.prototype, \"scalingY\", 2);\n  __decorateClass([\n    SceneChangeDetection({ type: \"transform\" })\n  ], ScalableInternal.prototype, \"scalingCenterX\", 2);\n  __decorateClass([\n    SceneChangeDetection({ type: \"transform\" })\n  ], ScalableInternal.prototype, \"scalingCenterY\", 2);\n  return ScalableInternal;\n}\nfunction Translatable(Parent) {\n  var _a;\n  const ParentNode = Parent;\n  const TRANSLATABLE_MATRIX = Symbol(\"matrix_translation\");\n  class TranslatableInternal extends MatrixTransform(ParentNode) {\n    constructor() {\n      super(...arguments);\n      this[_a] = new Matrix();\n      this.translationX = 0;\n      this.translationY = 0;\n    }\n    updateMatrix(matrix) {\n      super.updateMatrix(matrix);\n      const { translationX, translationY } = this;\n      if (translationX === 0 && translationY === 0)\n        return;\n      Matrix.updateTransformMatrix(this[TRANSLATABLE_MATRIX], 1, 1, 0, translationX, translationY);\n      matrix.multiplySelf(this[TRANSLATABLE_MATRIX]);\n    }\n  }\n  _a = TRANSLATABLE_MATRIX;\n  __decorateClass([\n    SceneChangeDetection({ type: \"transform\" })\n  ], TranslatableInternal.prototype, \"translationX\", 2);\n  __decorateClass([\n    SceneChangeDetection({ type: \"transform\" })\n  ], TranslatableInternal.prototype, \"translationY\", 2);\n  return TranslatableInternal;\n}\nvar Transformable = class {\n  /**\n   * Converts a BBox from canvas coordinate space into the coordinate space of the given Node.\n   */\n  static fromCanvas(node, bbox) {\n    const parents = [];\n    for (const parent of node.traverseUp()) {\n      if (isMatrixTransform(parent)) {\n        parents.unshift(parent);\n      }\n    }\n    for (const parent of parents) {\n      bbox = parent.fromParent(bbox);\n    }\n    if (isMatrixTransform(node)) {\n      bbox = node.fromParent(bbox);\n    }\n    return bbox;\n  }\n  /**\n   * Converts a Nodes BBox (or an arbitrary BBox if supplied) from local Node coordinate space\n   * into the Canvas coordinate space.\n   */\n  static toCanvas(node, bbox) {\n    if (bbox == null) {\n      bbox = node.getBBox();\n    } else if (isMatrixTransform(node)) {\n      bbox = node.toParent(bbox);\n    }\n    for (const parent of node.traverseUp()) {\n      if (isMatrixTransform(parent)) {\n        bbox = parent.toParent(bbox);\n      }\n    }\n    return bbox;\n  }\n  /**\n   * Converts a point from canvas coordinate space into the coordinate space of the given Node.\n   */\n  static fromCanvasPoint(node, x, y) {\n    const parents = [];\n    for (const parent of node.traverseUp()) {\n      if (isMatrixTransform(parent)) {\n        parents.unshift(parent);\n      }\n    }\n    for (const parent of parents) {\n      ({ x, y } = parent.fromParentPoint(x, y));\n    }\n    if (isMatrixTransform(node)) {\n      ({ x, y } = node.fromParentPoint(x, y));\n    }\n    return { x, y };\n  }\n  /**\n   * Converts a point from a Nodes local coordinate space into the Canvas coordinate space.\n   */\n  static toCanvasPoint(node, x, y) {\n    if (isMatrixTransform(node)) {\n      ({ x, y } = node.toParentPoint(x, y));\n    }\n    for (const parent of node.traverseUp()) {\n      if (isMatrixTransform(parent)) {\n        ({ x, y } = parent.toParentPoint(x, y));\n      }\n    }\n    return { x, y };\n  }\n};\n\n// packages/ag-charts-community/src/scene/group.ts\nvar _Group = class _Group extends Node {\n  constructor(opts) {\n    super(opts);\n    this.opts = opts;\n    this.opacity = 1;\n    this.isContainerNode = true;\n    this.zIndexSubOrder = opts?.zIndexSubOrder;\n  }\n  static is(value) {\n    return value instanceof _Group;\n  }\n  static computeChildrenBBox(nodes, skipInvisible = true) {\n    return BBox.merge(Node.extractBBoxes(nodes, skipInvisible));\n  }\n  static compareChildren(a, b) {\n    return compoundAscending(\n      [a.zIndex, ...a.zIndexSubOrder ?? [void 0, void 0], a.serialNumber],\n      [b.zIndex, ...b.zIndexSubOrder ?? [void 0, void 0], b.serialNumber],\n      ascendingStringNumberUndefined\n    );\n  }\n  // We consider a group to be boundless, thus any point belongs to it.\n  containsPoint(_x, _y) {\n    return true;\n  }\n  computeBBox() {\n    return _Group.computeChildrenBBox(this.children());\n  }\n  preRender() {\n    const counts = super.preRender();\n    counts.groups += 1;\n    counts.nonGroups -= 1;\n    return counts;\n  }\n  isDirty(renderCtx) {\n    const { resized } = renderCtx;\n    const { dirty, dirtyZIndex } = this;\n    const isDirty = dirty >= 2 /* MINOR */ || dirtyZIndex || resized;\n    let isChildDirty = isDirty;\n    let isChildLayerDirty = false;\n    for (const child of this.children()) {\n      isChildDirty || (isChildDirty = child.layerManager == null && child.dirty >= 1 /* TRIVIAL */);\n      isChildLayerDirty || (isChildLayerDirty = child.layerManager != null && child.dirty >= 1 /* TRIVIAL */);\n      if (isChildDirty)\n        break;\n    }\n    if (this.opts?.name) {\n      this._debug?.({ name: this.opts.name, group: this, isDirty, isChildDirty, renderCtx });\n    }\n    return { isDirty, isChildDirty, isChildLayerDirty };\n  }\n  debugSkip(renderCtx) {\n    if (renderCtx.stats && this.opts?.name) {\n      this._debug?.({\n        name: this.opts.name,\n        group: this,\n        result: \"skipping\",\n        counts: nodeCount(this),\n        renderCtx\n      });\n    }\n  }\n  render(renderCtx, skip) {\n    if (skip) {\n      return super.render(renderCtx);\n    }\n    const { opts: { name } = {}, _debug: debug3 } = this;\n    const { isDirty, isChildDirty, isChildLayerDirty } = this.isDirty(renderCtx);\n    const { ctx, stats } = renderCtx;\n    let { forceRender } = renderCtx;\n    if (!isDirty && !isChildDirty && !isChildLayerDirty && !forceRender) {\n      this.debugSkip(renderCtx);\n      this.markClean({ recursive: false });\n      return;\n    }\n    if (forceRender !== \"dirtyTransform\") {\n      forceRender || (forceRender = this.dirtyZIndex);\n    }\n    ctx.globalAlpha *= this.opacity;\n    if (this.dirtyZIndex) {\n      this.sortChildren(_Group.compareChildren);\n    }\n    const children = this.sortedChildren();\n    const clipBBox = this.renderClip(renderCtx) ?? renderCtx.clipBBox;\n    const renderCtxChanged = forceRender !== renderCtx.forceRender || clipBBox !== renderCtx.clipBBox;\n    this.renderChildren(children, renderCtxChanged ? { ...renderCtx, forceRender, clipBBox } : renderCtx);\n    super.render(renderCtx);\n    if (this.clipRect) {\n      ctx.restore();\n    }\n    for (const child of this.virtualChildren()) {\n      child.markClean({ recursive: \"virtual\" });\n    }\n    if (name && stats) {\n      debug3?.({\n        name,\n        renderCtx,\n        result: \"rendered\",\n        skipped: stats.nodesSkipped,\n        counts: nodeCount(this),\n        group: this\n      });\n    }\n  }\n  sortedChildren() {\n    let children = this.children();\n    if (this.hasVirtualChildren()) {\n      children = [...children].sort(_Group.compareChildren);\n    }\n    return children;\n  }\n  renderClip(renderCtx) {\n    if (!this.clipRect)\n      return;\n    const { x, y, width: width2, height: height2 } = this.clipRect;\n    const { ctx } = renderCtx;\n    ctx.save();\n    ctx.beginPath();\n    ctx.rect(x, y, width2, height2);\n    ctx.clip();\n    this._debug?.(() => ({\n      name: this.opts?.name,\n      clipRect: this.clipRect,\n      ctxTransform: ctx.getTransform(),\n      renderCtx,\n      group: this\n    }));\n    return Transformable.toCanvas(this, this.clipRect);\n  }\n  renderChildren(children, renderCtx) {\n    const { ctx, forceRender, stats } = renderCtx;\n    for (const child of children) {\n      if (!child.visible || !this.visible) {\n        child.markClean();\n        if (stats) {\n          stats.nodesSkipped += nodeCount(child).count;\n        }\n        continue;\n      }\n      if (!forceRender && child.dirty === 0 /* NONE */) {\n        if (stats) {\n          stats.nodesSkipped += nodeCount(child).count;\n        }\n        continue;\n      }\n      ctx.save();\n      child.render(renderCtx);\n      ctx.restore();\n    }\n  }\n  /**\n   * Transforms bbox given in the canvas coordinate space to bbox in this group's coordinate space and\n   * sets this group's clipRect to the transformed bbox.\n   * @param bbox clipRect bbox in the canvas coordinate space.\n   */\n  setClipRect(bbox) {\n    this.clipRect = bbox ? Transformable.fromCanvas(this, bbox) : void 0;\n  }\n  /**\n   * Set the clip rect within the canvas coordinate space.\n   * @param bbox clipRect bbox in the canvas coordinate space.\n   */\n  setClipRectCanvasSpace(bbox) {\n    this.clipRect = bbox;\n  }\n  toSVG() {\n    if (!this.visible)\n      return;\n    const defs = [];\n    const elements2 = [];\n    for (const child of this.sortedChildren()) {\n      const svg = child.toSVG();\n      if (svg != null) {\n        elements2.push(...svg.elements);\n        if (svg.defs != null) {\n          defs.push(...svg.defs);\n        }\n      }\n    }\n    return { elements: elements2, defs };\n  }\n};\n_Group.className = \"Group\";\n__decorateClass([\n  SceneChangeDetection({\n    redraw: 3 /* MAJOR */,\n    convertor: (v) => clamp(0, v, 1)\n  })\n], _Group.prototype, \"opacity\", 2);\nvar Group = _Group;\nvar ScalableGroup = class extends Scalable(Group) {\n};\nvar RotatableGroup = class extends Rotatable(Group) {\n};\nvar TranslatableGroup = class extends Translatable(Group) {\n};\nvar TransformableGroup = class extends Rotatable(Translatable(Group)) {\n};\n\n// packages/ag-charts-community/src/util/debug.ts\nvar LONG_TIME_PERIOD_THRESHOLD = 2e3;\nvar timeOfLastLog = Date.now();\nvar logTimeGap = () => {\n  const timeSinceLastLog = Date.now() - timeOfLastLog;\n  if (timeSinceLastLog > LONG_TIME_PERIOD_THRESHOLD) {\n    const prettyDuration = (Math.floor(timeSinceLastLog / 100) / 10).toFixed(1);\n    Logger.log(`**** ${prettyDuration}s since last log message ****`);\n  }\n  timeOfLastLog = Date.now();\n};\nvar Debug = {\n  create(...debugSelectors) {\n    const resultFn = (...logContent) => {\n      if (Debug.check(...debugSelectors)) {\n        if (typeof logContent[0] === \"function\") {\n          logContent = toArray(logContent[0]());\n        }\n        logTimeGap();\n        Logger.log(...logContent);\n      }\n    };\n    return Object.assign(resultFn, { check: () => Debug.check(...debugSelectors) });\n  },\n  check(...debugSelectors) {\n    if (debugSelectors.length === 0) {\n      debugSelectors.push(true);\n    }\n    const chartDebug = toArray(getWindow(\"agChartsDebug\"));\n    return chartDebug.some((selector) => debugSelectors.includes(selector));\n  }\n};\n\n// packages/ag-charts-community/src/scene/selection.ts\nvar Selection = class _Selection {\n  constructor(parentNode, classOrFactory, autoCleanup = true) {\n    this.parentNode = parentNode;\n    this.autoCleanup = autoCleanup;\n    this.garbageBin = /* @__PURE__ */ new Set();\n    this._nodesMap = /* @__PURE__ */ new Map();\n    this._nodes = [];\n    this.data = [];\n    this.debug = Debug.create(true, \"scene\", \"scene:selections\");\n    this.nodeFactory = Object.prototype.isPrototypeOf.call(Node, classOrFactory) ? () => new classOrFactory() : classOrFactory;\n  }\n  static select(parent, classOrFactory, garbageCollection = true) {\n    return new _Selection(parent, classOrFactory, garbageCollection);\n  }\n  static selectAll(parent, predicate) {\n    const results = [];\n    const traverse = (node) => {\n      if (predicate(node)) {\n        results.push(node);\n      }\n      for (const child of node.children()) {\n        traverse(child);\n      }\n    };\n    traverse(parent);\n    return results;\n  }\n  static selectByClass(node, ...Classes) {\n    return _Selection.selectAll(node, (n) => Classes.some((C) => n instanceof C));\n  }\n  static selectByTag(node, tag) {\n    return _Selection.selectAll(node, (n) => n.tag === tag);\n  }\n  createNode(datum, initializer, idx) {\n    const node = this.nodeFactory(datum);\n    node.datum = datum;\n    initializer?.(node);\n    if (idx == null) {\n      this._nodes.push(node);\n    } else {\n      this._nodes.splice(idx, 0, node);\n    }\n    this.parentNode.appendChild(node);\n    return node;\n  }\n  /**\n   * Update the data in a selection. If an `getDatumId()` function is provided, maintain a list of ids related to\n   * the nodes. Otherwise, take the more efficient route of simply creating and destroying nodes at the end\n   * of the array.\n   */\n  update(data, initializer, getDatumId) {\n    if (this.garbageBin.size > 0) {\n      this.debug(`Selection - update() called with pending garbage: ${data}`);\n    }\n    if (getDatumId) {\n      const dataMap = new Map(\n        data.map((datum, idx) => [getDatumId(datum), [datum, idx]])\n      );\n      for (const [node, datumId] of this._nodesMap.entries()) {\n        if (dataMap.has(datumId)) {\n          const [newDatum] = dataMap.get(datumId);\n          node.datum = newDatum;\n          this.garbageBin.delete(node);\n          dataMap.delete(datumId);\n        } else {\n          this.garbageBin.add(node);\n        }\n      }\n      for (const [datumId, [datum, idx]] of dataMap.entries()) {\n        this._nodesMap.set(this.createNode(datum, initializer, idx), datumId);\n      }\n    } else {\n      const maxLength = Math.max(data.length, this.data.length);\n      for (let i = 0; i < maxLength; i++) {\n        if (i >= data.length) {\n          this.garbageBin.add(this._nodes[i]);\n        } else if (i >= this._nodes.length) {\n          this.createNode(data[i], initializer);\n        } else {\n          this._nodes[i].datum = data[i];\n          this.garbageBin.delete(this._nodes[i]);\n        }\n      }\n    }\n    this.data = data.slice();\n    if (this.autoCleanup) {\n      this.cleanup();\n    }\n    return this;\n  }\n  cleanup() {\n    if (this.garbageBin.size === 0) {\n      return this;\n    }\n    this._nodes = this._nodes.filter((node) => {\n      if (this.garbageBin.has(node)) {\n        this._nodesMap.delete(node);\n        this.garbageBin.delete(node);\n        node.destroy();\n        return false;\n      }\n      return true;\n    });\n    return this;\n  }\n  clear() {\n    this.update([]);\n    return this;\n  }\n  isGarbage(node) {\n    return this.garbageBin.has(node);\n  }\n  hasGarbage() {\n    return this.garbageBin.size > 0;\n  }\n  each(iterate2) {\n    for (const entry of this._nodes.entries()) {\n      iterate2(entry[1], entry[1].datum, entry[0]);\n    }\n    return this;\n  }\n  *[Symbol.iterator]() {\n    for (let index = 0; index < this._nodes.length; index++) {\n      const node = this._nodes[index];\n      yield { node, datum: node.datum, index };\n    }\n  }\n  select(predicate) {\n    return _Selection.selectAll(this.parentNode, predicate);\n  }\n  selectByClass(Class) {\n    return _Selection.selectByClass(this.parentNode, Class);\n  }\n  selectByTag(tag) {\n    return _Selection.selectByTag(this.parentNode, tag);\n  }\n  nodes() {\n    return this._nodes;\n  }\n  at(index) {\n    return this._nodes.at(index);\n  }\n};\n\n// packages/ag-charts-community/src/util/angle.ts\nvar twoPi = Math.PI * 2;\nfunction normalizeAngle360(radians) {\n  radians %= twoPi;\n  radians += twoPi;\n  radians %= twoPi;\n  return radians;\n}\nfunction normalizeAngle360Inclusive(radians) {\n  radians %= twoPi;\n  radians += twoPi;\n  if (radians !== twoPi) {\n    radians %= twoPi;\n  }\n  return radians;\n}\nfunction normalizeAngle180(radians) {\n  radians %= twoPi;\n  if (radians < -Math.PI) {\n    radians += twoPi;\n  } else if (radians >= Math.PI) {\n    radians -= twoPi;\n  }\n  return radians;\n}\nfunction isBetweenAngles(targetAngle, startAngle, endAngle) {\n  const t = normalizeAngle360(targetAngle);\n  const a0 = normalizeAngle360(startAngle);\n  const a1 = normalizeAngle360(endAngle);\n  if (a0 < a1) {\n    return a0 <= t && t <= a1;\n  } else if (a0 > a1) {\n    return a0 <= t || t <= a1;\n  } else {\n    return true;\n  }\n}\nfunction toRadians(degrees) {\n  return degrees / 180 * Math.PI;\n}\nfunction toDegrees(radians) {\n  return radians / Math.PI * 180;\n}\nfunction angleDiff(angle0, angle1, counterClockwise) {\n  if (counterClockwise) {\n    [angle0, angle1] = [angle1, angle0];\n  }\n  const a0 = normalizeAngle360(angle0);\n  const a1 = normalizeAngle360(angle1) + twoPi;\n  return (a1 - a0) % twoPi;\n}\nfunction angleBetween(angle0, angle1) {\n  angle0 = normalizeAngle360(angle0);\n  angle1 = normalizeAngle360(angle1);\n  return angle1 - angle0 + (angle0 > angle1 ? 2 * Math.PI : 0);\n}\nfunction displacePointFromVector(centerX, centerY, radius, angle2) {\n  const x = centerX + radius * Math.cos(angle2);\n  const y = centerY + radius * Math.sin(angle2);\n  return { x, y };\n}\nvar delta = 1e-6;\nfunction clockwiseAngle(angle2, relativeToStartAngle) {\n  if (angleBetween(angle2, relativeToStartAngle) < delta) {\n    return relativeToStartAngle;\n  } else {\n    return normalizeAngle360(angle2 - relativeToStartAngle) + relativeToStartAngle;\n  }\n}\nfunction clockwiseAngles(startAngle, endAngle, relativeToStartAngle = 0) {\n  const fullPie = Math.abs(endAngle - startAngle) >= 2 * Math.PI;\n  const sweepAngle = fullPie ? 2 * Math.PI : normalizeAngle360(endAngle - startAngle);\n  startAngle = clockwiseAngle(startAngle, relativeToStartAngle);\n  endAngle = startAngle + sweepAngle;\n  return { startAngle, endAngle };\n}\n\n// packages/ag-charts-community/src/util/distance.ts\nfunction pointsDistanceSquared(x1, y1, x2, y2) {\n  const dx = x1 - x2;\n  const dy = y1 - y2;\n  return dx * dx + dy * dy;\n}\nfunction lineDistanceSquared(x, y, x1, y1, x2, y2, best) {\n  if (x1 === x2 && y1 === y2) {\n    return Math.min(best, pointsDistanceSquared(x, y, x1, y1));\n  }\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  const t = Math.max(0, Math.min(1, ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy)));\n  const ix = x1 + t * dx;\n  const iy = y1 + t * dy;\n  return Math.min(best, pointsDistanceSquared(x, y, ix, iy));\n}\nfunction arcDistanceSquared(x, y, cx, cy, radius, startAngle, endAngle, counterClockwise, best) {\n  if (counterClockwise) {\n    [endAngle, startAngle] = [startAngle, endAngle];\n  }\n  const angle2 = Math.atan2(y - cy, x - cx);\n  if (!isBetweenAngles(angle2, startAngle, endAngle)) {\n    const startX = cx + Math.cos(startAngle) * radius;\n    const startY = cy + Math.sin(startAngle) * radius;\n    const endX = cx + Math.cos(startAngle) * radius;\n    const endY = cy + Math.sin(startAngle) * radius;\n    return Math.min(best, pointsDistanceSquared(x, y, startX, startY), pointsDistanceSquared(x, y, endX, endY));\n  }\n  const distToArc = radius - Math.sqrt(pointsDistanceSquared(x, y, cx, cy));\n  return Math.min(best, distToArc * distToArc);\n}\n\n// packages/ag-charts-community/src/scale/colorScale.ts\nvar convertColorStringToOklcha = (v) => {\n  const color = Color.fromString(v);\n  const [l, c, h] = Color.RGBtoOKLCH(color.r, color.g, color.b);\n  return { l, c, h, a: color.a };\n};\nvar delta2 = 1e-6;\nvar isAchromatic = (x) => x.c < delta2 || x.l < delta2 || x.l > 1 - delta2;\nvar interpolateOklch = (x, y, d) => {\n  d = clamp(0, d, 1);\n  let h;\n  if (isAchromatic(x)) {\n    h = y.h;\n  } else if (isAchromatic(y)) {\n    h = x.h;\n  } else {\n    const xH = x.h;\n    let yH = y.h;\n    const deltaH = y.h - x.h;\n    if (deltaH > 180) {\n      yH -= 360;\n    } else if (deltaH < -180) {\n      yH += 360;\n    }\n    h = xH * (1 - d) + yH * d;\n  }\n  const c = x.c * (1 - d) + y.c * d;\n  const l = x.l * (1 - d) + y.l * d;\n  const a = x.a * (1 - d) + y.a * d;\n  return Color.fromOKLCH(l, c, h, a);\n};\nvar ColorScale = class {\n  constructor() {\n    this.type = \"color\";\n    this.invalid = true;\n    this.domain = [0, 1];\n    this.range = [\"red\", \"blue\"];\n    this.parsedRange = this.range.map(convertColorStringToOklcha);\n  }\n  update() {\n    const { domain, range: range3 } = this;\n    if (domain.length < 2) {\n      Logger.warnOnce(\"`colorDomain` should have at least 2 values.\");\n      if (domain.length === 0) {\n        domain.push(0, 1);\n      } else if (domain.length === 1) {\n        domain.push(domain[0] + 1);\n      }\n    }\n    for (let i = 1; i < domain.length; i++) {\n      const a = domain[i - 1];\n      const b = domain[i];\n      if (a >= b) {\n        Logger.warnOnce(\"`colorDomain` values should be supplied in ascending order.\");\n        domain.sort((a2, b2) => a2 - b2);\n        break;\n      }\n    }\n    if (range3.length < domain.length) {\n      for (let i = range3.length; i < domain.length; i++) {\n        range3.push(range3.length > 0 ? range3[0] : \"black\");\n      }\n    }\n    this.parsedRange = this.range.map(convertColorStringToOklcha);\n  }\n  convert(x) {\n    this.refresh();\n    const { domain, range: range3, parsedRange } = this;\n    const d0 = domain[0];\n    const d1 = domain.at(-1);\n    const r0 = range3[0];\n    const r1 = range3[range3.length - 1];\n    if (x <= d0) {\n      return r0;\n    }\n    if (x >= d1) {\n      return r1;\n    }\n    let index;\n    let q;\n    if (domain.length === 2) {\n      const t = (x - d0) / (d1 - d0);\n      const step = 1 / (range3.length - 1);\n      index = range3.length <= 2 ? 0 : Math.min(Math.floor(t * (range3.length - 1)), range3.length - 2);\n      q = (t - index * step) / step;\n    } else {\n      for (index = 0; index < domain.length - 2; index++) {\n        if (x < domain[index + 1]) {\n          break;\n        }\n      }\n      const a = domain[index];\n      const b = domain[index + 1];\n      q = (x - a) / (b - a);\n    }\n    const c0 = parsedRange[index];\n    const c1 = parsedRange[index + 1];\n    return interpolateOklch(c0, c1, q).toRgbaString();\n  }\n  refresh() {\n    if (!this.invalid)\n      return;\n    this.invalid = false;\n    this.update();\n    if (this.invalid) {\n      Logger.warnOnce(\"Expected update to not invalidate scale\");\n    }\n  }\n};\n__decorateClass([\n  Invalidating\n], ColorScale.prototype, \"domain\", 2);\n__decorateClass([\n  Invalidating\n], ColorScale.prototype, \"range\", 2);\n\n// packages/ag-charts-community/src/scene/gradient/gradient.ts\nvar Gradient = class {\n  constructor(colorSpace, stops = [], bbox) {\n    this.colorSpace = colorSpace;\n    this.stops = stops;\n    this.bbox = bbox;\n    this._cache = void 0;\n  }\n  createGradient(ctx, shapeBbox) {\n    const bbox = this.bbox ?? shapeBbox;\n    if (this._cache != null && this._cache.ctx === ctx && this._cache.bbox.equals(bbox)) {\n      return this._cache.gradient;\n    }\n    const { stops, colorSpace } = this;\n    if (stops.length === 0)\n      return;\n    if (stops.length === 1)\n      return stops[0].color;\n    let gradient2 = this.createCanvasGradient(ctx, bbox);\n    if (gradient2 == null)\n      return;\n    const isOkLch = colorSpace === \"oklch\";\n    const step = 0.05;\n    let c0 = stops[0];\n    gradient2.addColorStop(c0.offset, c0.color);\n    for (let i = 1; i < stops.length; i += 1) {\n      const c1 = stops[i];\n      if (isOkLch) {\n        const scale2 = new ColorScale();\n        scale2.domain = [c0.offset, c1.offset];\n        scale2.range = [c0.color, c1.color];\n        for (let offset4 = c0.offset + step; offset4 < c1.offset; offset4 += step) {\n          gradient2.addColorStop(offset4, scale2.convert(offset4));\n        }\n      }\n      gradient2.addColorStop(c1.offset, c1.color);\n      c0 = c1;\n    }\n    if (\"createPattern\" in gradient2) {\n      gradient2 = gradient2.createPattern();\n    }\n    this._cache = { ctx, bbox, gradient: gradient2 };\n    return gradient2;\n  }\n};\n\n// packages/ag-charts-community/src/scene/gradient/linearGradient.ts\nvar LinearGradient = class extends Gradient {\n  constructor(colorSpace, stops, angle2 = 0, bbox) {\n    super(colorSpace, stops, bbox);\n    this.angle = angle2;\n  }\n  createCanvasGradient(ctx, bbox) {\n    const angleOffset = 90;\n    const { angle: angle2 } = this;\n    const radians = normalizeAngle360(toRadians(angle2 + angleOffset));\n    const cos = Math.cos(radians);\n    const sin = Math.sin(radians);\n    const w = bbox.width;\n    const h = bbox.height;\n    const cx = bbox.x + w * 0.5;\n    const cy = bbox.y + h * 0.5;\n    const diagonal = Math.sqrt(h * h + w * w) / 2;\n    const diagonalAngle = Math.atan2(h, w);\n    let quarteredAngle;\n    if (radians < Math.PI / 2) {\n      quarteredAngle = radians;\n    } else if (radians < Math.PI) {\n      quarteredAngle = Math.PI - radians;\n    } else if (radians < 1.5 * Math.PI) {\n      quarteredAngle = radians - Math.PI;\n    } else {\n      quarteredAngle = 2 * Math.PI - radians;\n    }\n    const l = diagonal * Math.abs(Math.cos(quarteredAngle - diagonalAngle));\n    return ctx.createLinearGradient(cx + cos * l, cy + sin * l, cx - cos * l, cy - sin * l);\n  }\n};\n\n// packages/ag-charts-community/src/scene/shape/shape.ts\nvar LINEAR_GRADIENT_REGEXP = /^linear-gradient\\((-?[\\d.]+)deg,(.*?)\\)$/i;\nvar _Shape = class _Shape extends Node {\n  constructor() {\n    super(...arguments);\n    this.fillOpacity = 1;\n    this.strokeOpacity = 1;\n    this.fill = _Shape.defaultStyles.fill;\n    this.stroke = _Shape.defaultStyles.stroke;\n    this.strokeWidth = _Shape.defaultStyles.strokeWidth;\n    this.lineDash = _Shape.defaultStyles.lineDash;\n    this.lineDashOffset = _Shape.defaultStyles.lineDashOffset;\n    this.lineCap = _Shape.defaultStyles.lineCap;\n    this.lineJoin = _Shape.defaultStyles.lineJoin;\n    this.miterLimit = void 0;\n    this.opacity = _Shape.defaultStyles.opacity;\n    this.fillShadow = _Shape.defaultStyles.fillShadow;\n  }\n  /**\n   * Restores the default styles introduced by this subclass.\n   */\n  restoreOwnStyles() {\n    const { defaultStyles } = this.constructor;\n    Object.assign(this, defaultStyles);\n  }\n  onFillChange() {\n    const { fill } = this;\n    let linearGradientMatch;\n    if (fill instanceof Gradient) {\n      this.gradient = fill;\n    } else if (fill?.startsWith(\"linear-gradient\") && (linearGradientMatch = LINEAR_GRADIENT_REGEXP.exec(fill))) {\n      const angle2 = parseFloat(linearGradientMatch[1]);\n      const colors = [];\n      const colorsPart = linearGradientMatch[2];\n      const colorRegex = /(#[0-9a-f]+)|(rgba?\\(.+?\\))|([a-z]+)/gi;\n      let c;\n      while (c = colorRegex.exec(colorsPart)) {\n        colors.push(c[0]);\n      }\n      this.gradient = new LinearGradient(\n        \"rgb\",\n        colors.map((color, index) => ({ color, offset: index / (colors.length - 1) })),\n        angle2\n      );\n    } else {\n      this.gradient = void 0;\n    }\n  }\n  /**\n   * Returns a device-pixel aligned coordinate (or length if length is supplied).\n   *\n   * NOTE: Not suitable for strokes, since the stroke needs to be offset to the middle\n   * of a device pixel.\n   */\n  align(start2, length2) {\n    const pixelRatio = this.layerManager?.canvas?.pixelRatio ?? 1;\n    const alignedStart = Math.round(start2 * pixelRatio) / pixelRatio;\n    if (length2 == null) {\n      return alignedStart;\n    } else if (length2 === 0) {\n      return 0;\n    } else if (length2 < 1) {\n      return Math.ceil(length2 * pixelRatio) / pixelRatio;\n    }\n    return Math.round((length2 + start2) * pixelRatio) / pixelRatio - alignedStart;\n  }\n  fillStroke(ctx, path) {\n    this.renderFill(ctx, path);\n    this.renderStroke(ctx, path);\n  }\n  renderFill(ctx, path) {\n    if (this.fill) {\n      const { globalAlpha } = ctx;\n      this.applyFill(ctx);\n      this.applyFillAlpha(ctx);\n      this.applyShadow(ctx);\n      this.executeFill(ctx, path);\n      ctx.globalAlpha = globalAlpha;\n    }\n    ctx.shadowColor = \"rgba(0, 0, 0, 0)\";\n  }\n  executeFill(ctx, path) {\n    path ? ctx.fill(path) : ctx.fill();\n  }\n  applyFill(ctx) {\n    ctx.fillStyle = this.gradient?.createGradient(ctx, this.getBBox()) ?? (typeof this.fill === \"string\" ? this.fill : void 0) ?? \"black\";\n  }\n  applyFillAlpha(ctx) {\n    ctx.globalAlpha *= this.opacity * this.fillOpacity;\n  }\n  applyShadow(ctx) {\n    const pixelRatio = this.layerManager?.canvas.pixelRatio ?? 1;\n    const fillShadow = this.fillShadow;\n    if (fillShadow?.enabled) {\n      ctx.shadowColor = fillShadow.color;\n      ctx.shadowOffsetX = fillShadow.xOffset * pixelRatio;\n      ctx.shadowOffsetY = fillShadow.yOffset * pixelRatio;\n      ctx.shadowBlur = fillShadow.blur * pixelRatio;\n    }\n  }\n  renderStroke(ctx, path) {\n    if (this.stroke && this.strokeWidth) {\n      const { globalAlpha } = ctx;\n      ctx.strokeStyle = this.stroke;\n      ctx.globalAlpha *= this.opacity * this.strokeOpacity;\n      ctx.lineWidth = this.strokeWidth;\n      if (this.lineDash) {\n        ctx.setLineDash(this.lineDash);\n      }\n      if (this.lineDashOffset) {\n        ctx.lineDashOffset = this.lineDashOffset;\n      }\n      if (this.lineCap) {\n        ctx.lineCap = this.lineCap;\n      }\n      if (this.lineJoin) {\n        ctx.lineJoin = this.lineJoin;\n      }\n      if (this.miterLimit != null) {\n        ctx.miterLimit = this.miterLimit;\n      }\n      this.executeStroke(ctx, path);\n      ctx.globalAlpha = globalAlpha;\n    }\n  }\n  executeStroke(ctx, path) {\n    path ? ctx.stroke(path) : ctx.stroke();\n  }\n  containsPoint(x, y) {\n    return this.isPointInPath(x, y);\n  }\n};\n/**\n * Defaults for style properties. Note that properties that affect the position\n * and shape of the node are not considered style properties, for example:\n * `x`, `y`, `width`, `height`, `radius`, `rotation`, etc.\n * Can be used to reset to the original styling after some custom styling\n * has been applied (using the `restoreOwnStyles` method).\n * These static defaults are meant to be inherited by subclasses.\n */\n_Shape.defaultStyles = {\n  fill: \"black\",\n  stroke: void 0,\n  strokeWidth: 0,\n  lineDash: void 0,\n  lineDashOffset: 0,\n  lineCap: void 0,\n  lineJoin: void 0,\n  opacity: 1,\n  fillShadow: void 0\n};\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */, changeCb: (s) => s.onFillChange() })\n], _Shape.prototype, \"fill\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"stroke\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"lineDash\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"lineCap\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"lineJoin\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"miterLimit\", 2);\n__decorateClass([\n  SceneChangeDetection({\n    redraw: 2 /* MINOR */,\n    convertor: (v) => clamp(0, v, 1)\n  })\n], _Shape.prototype, \"opacity\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */, checkDirtyOnAssignment: true })\n], _Shape.prototype, \"fillShadow\", 2);\nvar Shape = _Shape;\n\n// packages/ag-charts-community/src/scene/shape/line.ts\nvar Line = class extends Shape {\n  constructor(opts = {}) {\n    super(opts);\n    this.x1 = 0;\n    this.y1 = 0;\n    this.x2 = 0;\n    this.y2 = 0;\n    this.restoreOwnStyles();\n  }\n  set x(value) {\n    this.x1 = value;\n    this.x2 = value;\n  }\n  set y(value) {\n    this.y1 = value;\n    this.y2 = value;\n  }\n  get midPoint() {\n    return { x: (this.x1 + this.x2) / 2, y: (this.y1 + this.y2) / 2 };\n  }\n  computeBBox() {\n    return new BBox(\n      Math.min(this.x1, this.x2),\n      Math.min(this.y1, this.y2),\n      Math.abs(this.x2 - this.x1),\n      Math.abs(this.y2 - this.y1)\n    );\n  }\n  isPointInPath(x, y) {\n    if (this.x1 === this.x2 || this.y1 === this.y2) {\n      return this.getBBox().clone().grow(this.strokeWidth / 2).containsPoint(x, y);\n    }\n    return false;\n  }\n  distanceSquared(px, py) {\n    const { x1, y1, x2, y2 } = this;\n    return lineDistanceSquared(px, py, x1, y1, x2, y2, Infinity);\n  }\n  render(renderCtx) {\n    const { ctx, forceRender, stats, devicePixelRatio } = renderCtx;\n    if (this.dirty === 0 /* NONE */ && !forceRender) {\n      if (stats)\n        stats.nodesSkipped += nodeCount(this).count;\n      return;\n    }\n    let { x1, y1, x2, y2 } = this;\n    if (x1 === x2) {\n      const { strokeWidth } = this;\n      const x = Math.round(x1 * devicePixelRatio) / devicePixelRatio + Math.trunc(strokeWidth * devicePixelRatio) % 2 / (devicePixelRatio * 2);\n      x1 = x;\n      x2 = x;\n    } else if (y1 === y2) {\n      const { strokeWidth } = this;\n      const y = Math.round(y1 * devicePixelRatio) / devicePixelRatio + Math.trunc(strokeWidth * devicePixelRatio) % 2 / (devicePixelRatio * 2);\n      y1 = y;\n      y2 = y;\n    }\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n    this.fillStroke(ctx);\n    this.fillShadow?.markClean();\n    super.render(renderCtx);\n  }\n  toSVG() {\n    if (!this.visible)\n      return;\n    const element2 = document.createElementNS(\"http://www.w3.org/2000/svg\", \"line\");\n    element2.setAttribute(\"x1\", String(this.x1));\n    element2.setAttribute(\"y1\", String(this.y1));\n    element2.setAttribute(\"x2\", String(this.x2));\n    element2.setAttribute(\"y2\", String(this.y2));\n    element2.setAttribute(\"stroke\", this.stroke ?? \"none\");\n    element2.setAttribute(\"stroke-opacity\", String(this.strokeOpacity));\n    element2.setAttribute(\"stroke-width\", String(this.strokeWidth));\n    return {\n      elements: [element2]\n    };\n  }\n};\nLine.className = \"Line\";\nLine.defaultStyles = { ...Shape.defaultStyles, fill: void 0, strokeWidth: 1 };\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Line.prototype, \"x1\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Line.prototype, \"y1\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Line.prototype, \"x2\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Line.prototype, \"y2\", 2);\n\n// packages/ag-charts-community/src/util/canvas.util.ts\nfunction createCanvasContext(width2 = 0, height2 = 0) {\n  const canvas = createElement(\"canvas\");\n  canvas.style.display = \"block\";\n  canvas.style.width = width2 + \"px\";\n  canvas.style.height = height2 + \"px\";\n  return canvas.getContext(\"2d\");\n}\n\n// packages/ag-charts-community/src/util/lruCache.ts\nvar LRUCache = class {\n  constructor(maxCacheSize = 5) {\n    this.maxCacheSize = maxCacheSize;\n    this.store = /* @__PURE__ */ new Map();\n  }\n  get(key) {\n    if (!this.store.has(key))\n      return void 0;\n    const hit = this.store.get(key);\n    this.store.delete(key);\n    this.store.set(key, hit);\n    return hit;\n  }\n  has(key) {\n    return this.store.has(key);\n  }\n  set(key, value) {\n    this.store.set(key, value);\n    if (this.store.size > this.maxCacheSize) {\n      const iterator = this.store.keys();\n      let evictCount = this.store.size - this.maxCacheSize;\n      while (evictCount > 0) {\n        const evictKeyIterator = iterator.next();\n        if (!evictKeyIterator.done) {\n          this.store.delete(evictKeyIterator.value);\n        }\n        evictCount--;\n      }\n    }\n    return value;\n  }\n  clear() {\n    this.store.clear();\n  }\n};\n\n// packages/ag-charts-community/src/util/textMeasurer.ts\nvar CachedTextMeasurerPool = class {\n  // Measures the dimensions of the provided text, handling multiline if needed.\n  static measureText(text, options) {\n    const textMeasurer = this.getMeasurer(options);\n    return textMeasurer.measureText(text);\n  }\n  static measureLines(text, options) {\n    const textMeasurer = this.getMeasurer(options);\n    return textMeasurer.measureLines(text);\n  }\n  // Gets a TextMeasurer instance, configuring text alignment and baseline if provided.\n  static getMeasurer(options) {\n    const font = typeof options.font === \"string\" ? options.font : TextUtils.toFontString(options.font);\n    const key = `${font}-${options.textAlign ?? \"start\"}-${options.textBaseline ?? \"alphabetic\"}`;\n    return this.instanceMap.get(key) ?? this.createFontMeasurer(font, options, key);\n  }\n  // Creates or retrieves a TextMeasurer instance for a specific font.\n  static createFontMeasurer(font, options, key) {\n    const ctx = createCanvasContext();\n    ctx.font = font;\n    ctx.textAlign = options.textAlign ?? \"start\";\n    ctx.textBaseline = options.textBaseline ?? \"alphabetic\";\n    const measurer = new CachedTextMeasurer(ctx, options);\n    this.instanceMap.set(key, measurer);\n    return measurer;\n  }\n};\nCachedTextMeasurerPool.instanceMap = new LRUCache(10);\nvar CachedTextMeasurer = class {\n  constructor(ctx, options) {\n    this.ctx = ctx;\n    // cached text measurements\n    this.measureMap = new LRUCache(100);\n    if (options.textAlign) {\n      ctx.textAlign = options.textAlign;\n    }\n    if (options.textBaseline) {\n      ctx.textBaseline = options.textBaseline;\n    }\n    ctx.font = typeof options.font === \"string\" ? options.font : TextUtils.toFontString(options.font);\n    this.textMeasurer = new SimpleTextMeasurer(\n      (t) => this.cachedCtxMeasureText(t),\n      options.textBaseline ?? \"alphabetic\"\n    );\n  }\n  textWidth(text, estimate) {\n    return this.textMeasurer.textWidth(text, estimate);\n  }\n  measureText(text) {\n    return this.textMeasurer.measureText(text);\n  }\n  measureLines(text) {\n    return this.textMeasurer.measureLines(text);\n  }\n  cachedCtxMeasureText(text) {\n    if (!this.measureMap.has(text)) {\n      const rawResult = this.ctx.measureText(text);\n      this.measureMap.set(text, {\n        actualBoundingBoxAscent: rawResult.actualBoundingBoxAscent,\n        emHeightAscent: rawResult.emHeightAscent,\n        emHeightDescent: rawResult.emHeightDescent,\n        actualBoundingBoxDescent: rawResult.actualBoundingBoxDescent,\n        actualBoundingBoxLeft: rawResult.actualBoundingBoxLeft,\n        actualBoundingBoxRight: rawResult.actualBoundingBoxRight,\n        alphabeticBaseline: rawResult.alphabeticBaseline,\n        fontBoundingBoxAscent: rawResult.fontBoundingBoxAscent,\n        fontBoundingBoxDescent: rawResult.fontBoundingBoxDescent,\n        hangingBaseline: rawResult.hangingBaseline,\n        ideographicBaseline: rawResult.ideographicBaseline,\n        width: rawResult.width\n      });\n    }\n    return this.measureMap.get(text);\n  }\n};\nvar TextUtils = class {\n  static toFontString({ fontSize = 10, fontStyle, fontWeight, fontFamily, lineHeight }) {\n    let fontString = \"\";\n    if (fontStyle) {\n      fontString += `${fontStyle} `;\n    }\n    if (fontWeight) {\n      fontString += `${fontWeight} `;\n    }\n    fontString += `${fontSize}px`;\n    if (lineHeight) {\n      fontString += `/${lineHeight}px`;\n    }\n    fontString += ` ${fontFamily}`;\n    return fontString.trim();\n  }\n  static getLineHeight(fontSize) {\n    return Math.ceil(fontSize * this.defaultLineHeight);\n  }\n  // Determines vertical offset modifier based on text baseline.\n  static getVerticalModifier(textBaseline) {\n    switch (textBaseline) {\n      case \"hanging\":\n      case \"top\":\n        return 0;\n      case \"middle\":\n        return 0.5;\n      case \"alphabetic\":\n      case \"bottom\":\n      case \"ideographic\":\n      default:\n        return 1;\n    }\n  }\n};\nTextUtils.EllipsisChar = \"\\u2026\";\n// Representation for text clipping.\nTextUtils.defaultLineHeight = 1.15;\n// Normally between 1.1 and 1.2\nTextUtils.lineSplitter = /\\r?\\n/g;\nvar SimpleTextMeasurer = class {\n  constructor(measureTextFn, textBaseline = \"alphabetic\") {\n    this.measureTextFn = measureTextFn;\n    this.textBaseline = textBaseline;\n    // local chars width cache per TextMeasurer\n    this.charMap = /* @__PURE__ */ new Map();\n  }\n  // Measures metrics for a single line of text.\n  getMetrics(text) {\n    const m = this.measureTextFn(text);\n    m.fontBoundingBoxAscent ?? (m.fontBoundingBoxAscent = m.emHeightAscent);\n    m.fontBoundingBoxDescent ?? (m.fontBoundingBoxDescent = m.emHeightDescent);\n    return {\n      width: m.width,\n      height: m.actualBoundingBoxAscent + m.actualBoundingBoxDescent,\n      lineHeight: m.fontBoundingBoxAscent + m.fontBoundingBoxDescent,\n      offsetTop: m.actualBoundingBoxAscent,\n      offsetLeft: m.actualBoundingBoxLeft\n    };\n  }\n  // Calculates aggregated metrics for multiline text.\n  getMultilineMetrics(lines) {\n    let width2 = 0;\n    let height2 = 0;\n    let offsetTop = 0;\n    let offsetLeft = 0;\n    let baselineDistance = 0;\n    const verticalModifier = TextUtils.getVerticalModifier(this.textBaseline);\n    const lineMetrics = [];\n    let index = 0;\n    const length2 = lines.length;\n    for (const line of lines) {\n      const m = this.measureTextFn(line);\n      m.fontBoundingBoxAscent ?? (m.fontBoundingBoxAscent = m.emHeightAscent);\n      m.fontBoundingBoxDescent ?? (m.fontBoundingBoxDescent = m.emHeightDescent);\n      if (width2 < m.width) {\n        width2 = m.width;\n      }\n      if (offsetLeft < m.actualBoundingBoxLeft) {\n        offsetLeft = m.actualBoundingBoxLeft;\n      }\n      if (index === 0) {\n        height2 += m.actualBoundingBoxAscent;\n        offsetTop += m.actualBoundingBoxAscent;\n      } else {\n        baselineDistance += m.fontBoundingBoxAscent;\n      }\n      if (index === length2 - 1) {\n        height2 += m.actualBoundingBoxDescent;\n      } else {\n        baselineDistance += m.fontBoundingBoxDescent;\n      }\n      lineMetrics.push({\n        text: line,\n        width: m.width,\n        height: m.actualBoundingBoxAscent + m.actualBoundingBoxDescent,\n        lineHeight: m.fontBoundingBoxAscent + m.fontBoundingBoxDescent,\n        offsetTop: m.actualBoundingBoxAscent,\n        offsetLeft: m.actualBoundingBoxLeft\n      });\n      index++;\n    }\n    height2 += baselineDistance;\n    offsetTop += baselineDistance * verticalModifier;\n    return { width: width2, height: height2, offsetTop, offsetLeft, lineMetrics };\n  }\n  textWidth(text, estimate) {\n    if (estimate) {\n      let estimatedWidth = 0;\n      for (let i = 0; i < text.length; i++) {\n        estimatedWidth += this.textWidth(text.charAt(i));\n      }\n      return estimatedWidth;\n    }\n    if (text.length > 1) {\n      return this.measureTextFn(text).width;\n    }\n    return this.charMap.get(text) ?? this.charWidth(text);\n  }\n  measureText(text) {\n    return this.getMetrics(text);\n  }\n  // Measures the dimensions of the provided text, handling multiline if needed.\n  measureLines(text) {\n    const lines = typeof text === \"string\" ? text.split(TextUtils.lineSplitter) : text;\n    return this.getMultilineMetrics(lines);\n  }\n  charWidth(char) {\n    const { width: width2 } = this.measureTextFn(char);\n    this.charMap.set(char, width2);\n    return width2;\n  }\n};\n\n// packages/ag-charts-community/src/scene/shape/text.ts\nvar _Text = class _Text extends Shape {\n  constructor() {\n    super(...arguments);\n    this.x = 0;\n    this.y = 0;\n    this.lines = [];\n    this.text = void 0;\n    this.fontSize = 10;\n    this.fontFamily = \"sans-serif\";\n    this.textAlign = _Text.defaultStyles.textAlign;\n    this.textBaseline = _Text.defaultStyles.textBaseline;\n  }\n  onTextChange() {\n    this.lines = this.text?.split(\"\\n\").map((s) => s.trim()) ?? [];\n  }\n  static computeBBox(lines, x, y, opts) {\n    const { offsetTop, offsetLeft, width: width2, height: height2 } = CachedTextMeasurerPool.measureLines(lines, opts);\n    return new BBox(x - offsetLeft, y - offsetTop, width2, height2);\n  }\n  computeBBox() {\n    const { x, y, lines, textBaseline, textAlign } = this;\n    return _Text.computeBBox(lines, x, y, { font: this, textBaseline, textAlign });\n  }\n  isPointInPath(x, y) {\n    const bbox = this.getBBox();\n    return bbox ? bbox.containsPoint(x, y) : false;\n  }\n  render(renderCtx) {\n    const { ctx, forceRender, stats } = renderCtx;\n    if (this.dirty === 0 /* NONE */ && !forceRender) {\n      if (stats)\n        stats.nodesSkipped += nodeCount(this).count;\n      return;\n    }\n    if (!this.lines.length || !this.layerManager) {\n      if (stats)\n        stats.nodesSkipped += nodeCount(this).count;\n      return;\n    }\n    const { fill, stroke, strokeWidth } = this;\n    const { pixelRatio } = this.layerManager.canvas;\n    ctx.font = TextUtils.toFontString(this);\n    ctx.textAlign = this.textAlign;\n    ctx.textBaseline = this.textBaseline;\n    if (fill) {\n      this.applyFill(ctx);\n      ctx.globalAlpha *= this.opacity * this.fillOpacity;\n      const { fillShadow } = this;\n      if (fillShadow?.enabled) {\n        ctx.shadowColor = fillShadow.color;\n        ctx.shadowOffsetX = fillShadow.xOffset * pixelRatio;\n        ctx.shadowOffsetY = fillShadow.yOffset * pixelRatio;\n        ctx.shadowBlur = fillShadow.blur * pixelRatio;\n      }\n      this.renderLines((line, x, y) => ctx.fillText(line, x, y));\n    }\n    if (stroke && strokeWidth) {\n      ctx.strokeStyle = stroke;\n      ctx.lineWidth = strokeWidth;\n      ctx.globalAlpha *= this.opacity * this.strokeOpacity;\n      const { lineDash, lineDashOffset, lineCap, lineJoin } = this;\n      if (lineDash) {\n        ctx.setLineDash(lineDash);\n      }\n      if (lineDashOffset) {\n        ctx.lineDashOffset = lineDashOffset;\n      }\n      if (lineCap) {\n        ctx.lineCap = lineCap;\n      }\n      if (lineJoin) {\n        ctx.lineJoin = lineJoin;\n      }\n      this.renderLines((line, x, y) => ctx.strokeText(line, x, y));\n    }\n    super.render(renderCtx);\n  }\n  renderLines(renderCallback) {\n    const { lines, x, y } = this;\n    const lineHeight = this.lineHeight ?? TextUtils.getLineHeight(this.fontSize);\n    let offsetY = (lineHeight - lineHeight * lines.length) * TextUtils.getVerticalModifier(this.textBaseline);\n    for (const line of lines) {\n      renderCallback(line, x, y + offsetY);\n      offsetY += lineHeight;\n    }\n  }\n  setFont(props) {\n    this.fontFamily = props.fontFamily;\n    this.fontSize = props.fontSize;\n    this.fontStyle = props.fontStyle;\n    this.fontWeight = props.fontWeight;\n  }\n  setAlign(props) {\n    this.textAlign = props.textAlign;\n    this.textBaseline = props.textBaseline;\n  }\n  toSVG() {\n    if (!this.visible || !this.text)\n      return;\n    const element2 = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n    element2.setAttribute(\"font-family\", this.fontFamily?.split(\",\")[0] ?? \"\");\n    element2.setAttribute(\"font-size\", String(this.fontSize));\n    element2.setAttribute(\"font-style\", this.fontStyle ?? \"\");\n    element2.setAttribute(\"font-weight\", String(this.fontWeight ?? \"\"));\n    element2.setAttribute(\n      \"text-anchor\",\n      {\n        center: \"middle\",\n        left: \"start\",\n        right: \"end\",\n        start: \"start\",\n        end: \"end\"\n      }[this.textAlign ?? \"start\"]\n    );\n    element2.setAttribute(\n      \"alignment-baseline\",\n      {\n        alphabetic: \"alphabetic\",\n        top: \"top\",\n        bottom: \"bottom\",\n        hanging: \"hanging\",\n        middle: \"middle\",\n        ideographic: \"ideographic\"\n      }[this.textBaseline ?? \"alphabetic\"]\n    );\n    element2.setAttribute(\"x\", String(this.x));\n    element2.setAttribute(\"y\", String(this.y));\n    element2.textContent = this.text ?? \"\";\n    return { elements: [element2] };\n  }\n};\n_Text.className = \"Text\";\n_Text.defaultStyles = {\n  ...Shape.defaultStyles,\n  textAlign: \"start\",\n  fontStyle: void 0,\n  fontWeight: void 0,\n  fontSize: 10,\n  fontFamily: \"sans-serif\",\n  textBaseline: \"alphabetic\"\n};\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], _Text.prototype, \"x\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], _Text.prototype, \"y\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */, changeCb: (o) => o.onTextChange() })\n], _Text.prototype, \"text\", 2);\n__decorateClass([\n  SceneChangeDetection()\n], _Text.prototype, \"fontStyle\", 2);\n__decorateClass([\n  SceneChangeDetection()\n], _Text.prototype, \"fontWeight\", 2);\n__decorateClass([\n  SceneChangeDetection()\n], _Text.prototype, \"fontSize\", 2);\n__decorateClass([\n  SceneChangeDetection()\n], _Text.prototype, \"fontFamily\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], _Text.prototype, \"textAlign\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], _Text.prototype, \"textBaseline\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], _Text.prototype, \"lineHeight\", 2);\nvar Text = _Text;\nvar RotatableText = class extends Rotatable(Text) {\n};\nvar TransformableText = class extends Rotatable(Translatable(Text)) {\n};\n\n// packages/ag-charts-community/src/scene/util/labelPlacement.ts\nfunction circleRectOverlap(c, unitCenter, x, y, w, h) {\n  if (c.size === 0) {\n    return false;\n  }\n  let cx = c.x;\n  let cy = c.y;\n  if (unitCenter != null) {\n    cx -= (unitCenter.x - 0.5) * c.size;\n    cy -= (unitCenter.y - 0.5) * c.size;\n  }\n  let edgeX = cx;\n  if (cx < x) {\n    edgeX = x;\n  } else if (cx > x + w) {\n    edgeX = x + w;\n  }\n  let edgeY = cy;\n  if (cy < y) {\n    edgeY = y;\n  } else if (cy > y + h) {\n    edgeY = y + h;\n  }\n  const dx = cx - edgeX;\n  const dy = cy - edgeY;\n  const d = Math.sqrt(dx * dx + dy * dy);\n  return d <= c.size * 0.5;\n}\nfunction rectRectOverlap(r1, x2, y2, w2, h2) {\n  const xOverlap = r1.x + r1.width > x2 && r1.x < x2 + w2;\n  const yOverlap = r1.y + r1.height > y2 && r1.y < y2 + h2;\n  return xOverlap && yOverlap;\n}\nfunction rectContainsRect(r1, r2x, r2y, r2w, r2h) {\n  return r2x + r2w < r1.x + r1.width && r2x > r1.x && r2y > r1.y && r2y + r2h < r1.y + r1.height;\n}\nfunction isPointLabelDatum(x) {\n  return x != null && typeof x.point === \"object\" && typeof x.label === \"object\";\n}\nvar labelPlacements = {\n  top: { x: 0, y: -1 },\n  bottom: { x: 0, y: 1 },\n  left: { x: -1, y: 0 },\n  right: { x: 1, y: 0 },\n  \"top-left\": { x: -1, y: -1 },\n  \"top-right\": { x: 1, y: -1 },\n  \"bottom-left\": { x: -1, y: 1 },\n  \"bottom-right\": { x: 1, y: 1 }\n};\nfunction placeLabels(data, bounds, padding = 5) {\n  const result = [];\n  data = data.map((d) => d.slice().sort((a, b) => b.point.size - a.point.size));\n  for (let j = 0; j < data.length; j++) {\n    const labels = result[j] = [];\n    const datum = data[j];\n    if (!(datum?.length && datum[0].label)) {\n      continue;\n    }\n    for (let index = 0, ln = datum.length; index < ln; index++) {\n      const d = datum[index];\n      const { point, label, marker } = d;\n      const { text, width: width2, height: height2 } = label;\n      const r = point.size * 0.5;\n      let dx = 0;\n      let dy = 0;\n      if (r > 0 && d.placement != null) {\n        const placement = labelPlacements[d.placement];\n        dx = (width2 * 0.5 + r + padding) * placement.x;\n        dy = (height2 * 0.5 + r + padding) * placement.y;\n      }\n      const x = point.x - width2 * 0.5 + dx - ((marker?.center.x ?? 0.5) - 0.5) * point.size;\n      const y = point.y - height2 * 0.5 + dy - ((marker?.center.y ?? 0.5) - 0.5) * point.size;\n      const withinBounds = !bounds || rectContainsRect(bounds, x, y, width2, height2);\n      if (!withinBounds) {\n        continue;\n      }\n      const overlapPoints = data.some(\n        (dataDatums) => dataDatums.some(\n          (dataDatum) => circleRectOverlap(dataDatum.point, dataDatum.marker?.center, x, y, width2, height2)\n        )\n      );\n      if (overlapPoints) {\n        continue;\n      }\n      const overlapLabels = result.some((l2) => l2.some((l3) => rectRectOverlap(l3, x, y, width2, height2)));\n      if (overlapLabels) {\n        continue;\n      }\n      labels.push({ index, text, x, y, width: width2, height: height2, datum: d });\n    }\n  }\n  return result;\n}\nfunction axisLabelsOverlap(data, padding = 0) {\n  const result = [];\n  for (let index = 0; index < data.length; index++) {\n    const datum = data[index];\n    const {\n      point: { x, y },\n      label: { text }\n    } = datum;\n    let { width: width2, height: height2 } = datum.label;\n    width2 += padding;\n    height2 += padding;\n    if (result.some((l) => rectRectOverlap(l, x, y, width2, height2))) {\n      return true;\n    }\n    result.push({ index, text, x, y, width: width2, height: height2, datum });\n  }\n  return false;\n}\n\n// packages/ag-charts-community/src/util/equal.ts\nfunction areArrayNumbersEqual(arrA, arrB) {\n  return arrA.length === arrB.length && arrA.every((item, i) => Number(item) === Number(arrB[i]));\n}\n\n// packages/ag-charts-community/src/util/json.ts\nvar CLASS_INSTANCE_TYPE = \"class-instance\";\nfunction jsonDiff(source, target, skip) {\n  if (isArray(target)) {\n    if (!isArray(source) || source.length !== target.length || target.some((v, i) => jsonDiff(source[i], v) != null)) {\n      return target;\n    }\n  } else if (isPlainObject(target)) {\n    if (!isPlainObject(source)) {\n      return target;\n    }\n    const result = {};\n    const allKeys = /* @__PURE__ */ new Set([\n      ...Object.keys(source),\n      ...Object.keys(target)\n    ]);\n    for (const key of allKeys) {\n      if (source[key] === target[key] || skip?.includes(key)) {\n        continue;\n      }\n      if (typeof source[key] === typeof target[key]) {\n        const diff2 = jsonDiff(source[key], target[key]);\n        if (diff2 !== null) {\n          result[key] = diff2;\n        }\n      } else {\n        result[key] = target[key];\n      }\n    }\n    return Object.keys(result).length ? result : null;\n  } else if (source !== target) {\n    return target;\n  }\n  return null;\n}\nfunction deepClone(source, options) {\n  if (isArray(source)) {\n    return source.map((item) => deepClone(item, options));\n  }\n  if (isPlainObject(source)) {\n    return mapValues(\n      source,\n      (value, key) => options?.shallow?.includes(key) ? shallowClone(value) : deepClone(value, options)\n    );\n  }\n  if (source instanceof Map) {\n    return new Map(deepClone(Array.from(source)));\n  }\n  return shallowClone(source);\n}\nfunction shallowClone(source) {\n  if (isArray(source)) {\n    return [...source];\n  }\n  if (isPlainObject(source)) {\n    return { ...source };\n  }\n  if (isDate(source)) {\n    return new Date(source);\n  }\n  if (isRegExp(source)) {\n    return new RegExp(source.source, source.flags);\n  }\n  return source;\n}\nfunction jsonWalk(json, visit, opts, ...jsons) {\n  if (isArray(json)) {\n    visit(json, ...jsons);\n    json.forEach((node, index) => {\n      jsonWalk(node, visit, opts, ...keyMapper(jsons, index));\n    });\n  } else if (isPlainObject(json)) {\n    visit(json, ...jsons);\n    for (const key of Object.keys(json)) {\n      if (opts?.skip?.includes(key)) {\n        continue;\n      }\n      const value = json[key];\n      if (isArray(value) || isPlainObject(value)) {\n        jsonWalk(value, visit, opts, ...keyMapper(jsons, key));\n      }\n    }\n  }\n}\nfunction jsonApply(target, source, params = {}) {\n  const { path, matcherPath = path?.replace(/(\\[[0-9+]+])/i, \"[]\"), skip = [] } = params;\n  if (target == null) {\n    throw new Error(`AG Charts - target is uninitialised: ${path ?? \"<root>\"}`);\n  }\n  if (source == null) {\n    return target;\n  }\n  if (isProperties(target)) {\n    return target.set(source);\n  }\n  const targetAny = target;\n  const targetType = classify(target);\n  for (const property in source) {\n    if (SKIP_JS_BUILTINS.has(property))\n      continue;\n    const propertyMatcherPath = `${matcherPath ? matcherPath + \".\" : \"\"}${property}`;\n    if (skip.includes(propertyMatcherPath))\n      continue;\n    const newValue = source[property];\n    const propertyPath = `${path ? path + \".\" : \"\"}${property}`;\n    const targetClass = targetAny.constructor;\n    const currentValue = targetAny[property];\n    try {\n      const currentValueType = classify(currentValue);\n      const newValueType = classify(newValue);\n      if (targetType === CLASS_INSTANCE_TYPE && !(property in target)) {\n        Logger.warn(`unable to set [${propertyPath}] in ${targetClass?.name} - property is unknown`);\n        continue;\n      }\n      if (currentValueType != null && newValueType != null && newValueType !== currentValueType && (currentValueType !== CLASS_INSTANCE_TYPE || newValueType !== \"object\")) {\n        Logger.warn(\n          `unable to set [${propertyPath}] in ${targetClass?.name} - can't apply type of [${newValueType}], allowed types are: [${currentValueType}]`\n        );\n        continue;\n      }\n      if (isProperties(currentValue)) {\n        targetAny[property].set(newValue);\n      } else if (newValueType === \"object\") {\n        if (currentValue == null) {\n          targetAny[property] = {};\n        }\n        jsonApply(currentValue ?? targetAny[property], newValue, {\n          ...params,\n          path: propertyPath,\n          matcherPath: propertyMatcherPath\n        });\n      } else {\n        targetAny[property] = newValue;\n      }\n    } catch (error) {\n      Logger.warn(`unable to set [${propertyPath}] in [${targetClass?.name}]; nested error is: ${error.message}`);\n    }\n  }\n  return target;\n}\nfunction keyMapper(data, key) {\n  return data.map((dataObject) => dataObject?.[key]);\n}\nfunction classify(value) {\n  if (value == null) {\n    return null;\n  }\n  if (isHtmlElement(value) || isDate(value)) {\n    return \"primitive\";\n  }\n  if (isArray(value)) {\n    return \"array\";\n  }\n  if (isObject(value)) {\n    return isPlainObject(value) ? \"object\" : CLASS_INSTANCE_TYPE;\n  }\n  if (isFunction(value)) {\n    return \"function\";\n  }\n  return \"primitive\";\n}\n\n// packages/ag-charts-community/src/util/proxy.ts\nfunction ProxyProperty(proxyPath, configMetadata) {\n  const pathArray = isArray(proxyPath) ? proxyPath : proxyPath.split(\".\");\n  if (pathArray.length === 1) {\n    const [property] = pathArray;\n    return addTransformToInstanceProperty(\n      (target, _, value) => target[property] = value,\n      (target) => target[property],\n      configMetadata\n    );\n  }\n  return addTransformToInstanceProperty(\n    (target, _, value) => setPath(target, pathArray, value),\n    (target) => getPath(target, pathArray),\n    configMetadata\n  );\n}\nfunction ProxyOnWrite(proxyProperty) {\n  return addTransformToInstanceProperty((target, _, value) => target[proxyProperty] = value);\n}\nfunction ProxyPropertyOnWrite(childName, childProperty) {\n  return addTransformToInstanceProperty((target, key, value) => target[childName][childProperty ?? key] = value);\n}\nfunction ActionOnSet(opts) {\n  const { newValue: newValueFn, oldValue: oldValueFn, changeValue: changeValueFn } = opts;\n  return addTransformToInstanceProperty((target, _, newValue, oldValue) => {\n    if (newValue !== oldValue) {\n      if (oldValue !== void 0) {\n        oldValueFn?.call(target, oldValue);\n      }\n      if (newValue !== void 0) {\n        newValueFn?.call(target, newValue);\n      }\n      changeValueFn?.call(target, newValue, oldValue);\n    }\n    return newValue;\n  });\n}\nfunction ObserveChanges(observerFn) {\n  return addObserverToInstanceProperty(observerFn);\n}\n\n// packages/ag-charts-community/src/util/stateMachine.ts\nvar debugColor = \"color: green\";\nvar debugQuietColor = \"color: grey\";\nvar _StateMachine = class _StateMachine {\n  constructor(defaultState, states, enterEach) {\n    this.defaultState = defaultState;\n    this.states = states;\n    this.enterEach = enterEach;\n    this.debug = Debug.create(true, \"animation\");\n    this.state = defaultState;\n    this.debug(`%c${this.constructor.name} | init -> ${defaultState}`, debugColor);\n  }\n  transition(event, data) {\n    const shouldTransitionSelf = this.transitionChild(event, data);\n    if (!shouldTransitionSelf || this.state === _StateMachine.child || this.state === _StateMachine.parent) {\n      return;\n    }\n    const currentState = this.state;\n    const currentStateConfig = this.states[this.state];\n    let destination = currentStateConfig[event];\n    const debugPrefix = `%c${this.constructor.name} | ${this.state} -> ${event} ->`;\n    if (Array.isArray(destination)) {\n      destination = destination.find((transition) => {\n        if (!transition.guard)\n          return true;\n        const valid = transition.guard(data);\n        if (!valid) {\n          this.debug(`${debugPrefix} ${transition.target} (guarded)`, debugQuietColor);\n        }\n        return valid;\n      });\n    } else if (typeof destination === \"object\" && !(destination instanceof _StateMachine) && destination.guard && !destination.guard(data)) {\n      this.debug(`${debugPrefix} ${destination.target} (guarded)`, debugQuietColor);\n      return;\n    }\n    if (!destination) {\n      this.debug(`${debugPrefix} ${this.state}`, debugQuietColor);\n      return;\n    }\n    const destinationState = this.getDestinationState(destination);\n    const exitFn = destinationState === this.state ? void 0 : currentStateConfig.onExit;\n    this.debug(`${debugPrefix} ${destinationState}`, debugColor);\n    this.state = destinationState;\n    if (typeof destination === \"function\") {\n      destination(data);\n    } else if (typeof destination === \"object\" && !(destination instanceof _StateMachine)) {\n      destination.action?.(data);\n    }\n    exitFn?.();\n    this.enterEach?.(currentState, destinationState);\n    if (destinationState !== currentState && destinationState !== _StateMachine.child && destinationState !== _StateMachine.parent) {\n      this.states[destinationState].onEnter?.(currentState, data);\n    }\n  }\n  transitionAsync(event, data) {\n    setTimeout(() => {\n      this.transition(event, data);\n    }, 0);\n  }\n  is(value) {\n    if (this.state === _StateMachine.child && this.childState) {\n      return this.childState.is(value);\n    }\n    return this.state === value;\n  }\n  resetHierarchy() {\n    this.debug(\n      `%c${this.constructor.name} | ${this.state} -> [resetHierarchy] -> ${this.defaultState}`,\n      \"color: green\"\n    );\n    this.state = this.defaultState;\n  }\n  transitionChild(event, data) {\n    if (this.state !== _StateMachine.child || !this.childState)\n      return true;\n    this.childState.transition(event, data);\n    if (!this.childState.is(_StateMachine.parent))\n      return true;\n    this.debug(`%c${this.constructor.name} | ${this.state} -> ${event} -> ${this.defaultState}`, debugColor);\n    this.state = this.defaultState;\n    this.states[this.state].onEnter?.();\n    this.childState.resetHierarchy();\n    return false;\n  }\n  getDestinationState(destination) {\n    let state = this.state;\n    if (typeof destination === \"string\") {\n      state = destination;\n    } else if (destination instanceof _StateMachine) {\n      this.childState = destination;\n      state = _StateMachine.child;\n    } else if (typeof destination === \"object\") {\n      if (destination.target instanceof _StateMachine) {\n        this.childState = destination.target;\n        state = _StateMachine.child;\n      } else if (destination.target != null) {\n        state = destination.target;\n      }\n    }\n    return state;\n  }\n};\n_StateMachine.child = \"__child\";\n_StateMachine.parent = \"__parent\";\nvar StateMachine = _StateMachine;\n\n// packages/ag-charts-community/src/util/textWrapper.ts\nvar TextWrapper = class {\n  static wrapText(text, options) {\n    return this.wrapLines(text, options).join(\"\\n\");\n  }\n  static wrapLines(text, options) {\n    const clippedResult = this.textWrap(text, options);\n    if (options.overflow === \"hide\" && clippedResult.some((l) => l.endsWith(TextUtils.EllipsisChar))) {\n      return [];\n    }\n    return clippedResult;\n  }\n  static appendEllipsis(text) {\n    return text.replace(/[.,]{1,5}$/, \"\") + TextUtils.EllipsisChar;\n  }\n  static truncateLine(text, measurer, maxWidth, ellipsisForce) {\n    const ellipsisWidth = measurer.textWidth(TextUtils.EllipsisChar);\n    let estimatedWidth = 0;\n    let i = 0;\n    for (; i < text.length; i++) {\n      const charWidth = measurer.textWidth(text.charAt(i));\n      if (estimatedWidth + charWidth > maxWidth)\n        break;\n      estimatedWidth += charWidth;\n    }\n    if (text.length === i && (!ellipsisForce || estimatedWidth + ellipsisWidth <= maxWidth)) {\n      return ellipsisForce ? text + TextUtils.EllipsisChar : text;\n    }\n    text = text.slice(0, i).trimEnd();\n    while (text.length && measurer.textWidth(text) + ellipsisWidth > maxWidth) {\n      text = text.slice(0, -1).trimEnd();\n    }\n    return text + TextUtils.EllipsisChar;\n  }\n  static textWrap(text, options) {\n    const lines = text.split(TextUtils.lineSplitter);\n    const measurer = CachedTextMeasurerPool.getMeasurer(options);\n    if (options.textWrap === \"never\") {\n      return lines.map((line) => this.truncateLine(line.trimEnd(), measurer, options.maxWidth));\n    }\n    const result = [];\n    const wrapHyphenate = options.textWrap === \"hyphenate\";\n    const wrapOnSpace = options.textWrap == null || options.textWrap === \"on-space\";\n    for (let line of lines) {\n      line = line.trimEnd();\n      if (line === \"\") {\n        result.push(line);\n        continue;\n      }\n      for (let i = 0, estimatedWidth = 0, lastSpaceIndex = 0; i < line.length; i++) {\n        const char = line.charAt(i);\n        estimatedWidth += measurer.textWidth(char);\n        if (char === \" \") {\n          lastSpaceIndex = i;\n        }\n        if (estimatedWidth > options.maxWidth) {\n          if (i === 0)\n            break;\n          const actualWidth = measurer.textWidth(line.slice(0, i + 1));\n          if (actualWidth <= options.maxWidth) {\n            estimatedWidth = actualWidth;\n            continue;\n          }\n          if (lastSpaceIndex) {\n            const nextWord = this.getWordAt(line, lastSpaceIndex + 1);\n            const textWidth = measurer.textWidth(nextWord);\n            if (textWidth <= options.maxWidth) {\n              result.push(line.slice(0, lastSpaceIndex).trimEnd());\n              line = line.slice(lastSpaceIndex).trimStart();\n              i = -1;\n              estimatedWidth = 0;\n              lastSpaceIndex = 0;\n              continue;\n            } else if (wrapOnSpace && textWidth > options.maxWidth) {\n              result.push(\n                line.slice(0, lastSpaceIndex).trimEnd(),\n                this.truncateLine(\n                  line.slice(lastSpaceIndex).trimStart(),\n                  measurer,\n                  options.maxWidth,\n                  true\n                )\n              );\n            }\n          } else if (wrapOnSpace) {\n            result.push(this.truncateLine(line, measurer, options.maxWidth, true));\n          }\n          if (wrapOnSpace) {\n            line = \"\";\n            break;\n          }\n          const postfix = wrapHyphenate ? \"-\" : \"\";\n          let newLine = line.slice(0, i).trim();\n          while (newLine.length && measurer.textWidth(newLine + postfix) > options.maxWidth) {\n            newLine = newLine.slice(0, -1).trimEnd();\n          }\n          result.push(newLine + postfix);\n          if (!newLine.length) {\n            line = \"\";\n            break;\n          }\n          line = line.slice(newLine.length).trimStart();\n          i = -1;\n          estimatedWidth = 0;\n          lastSpaceIndex = 0;\n        }\n      }\n      if (line) {\n        result.push(line);\n      }\n    }\n    this.avoidOrphans(result, measurer, options);\n    return this.clipLines(result, measurer, options);\n  }\n  static getWordAt(text, position) {\n    const nextSpaceIndex = text.indexOf(\" \", position);\n    return nextSpaceIndex === -1 ? text.slice(position) : text.slice(position, nextSpaceIndex);\n  }\n  static clipLines(lines, measurer, options) {\n    if (!options.maxHeight) {\n      return lines;\n    }\n    const { height: height2, lineMetrics } = measurer.measureLines(lines);\n    if (height2 <= options.maxHeight) {\n      return lines;\n    }\n    for (let i = 0, cumulativeHeight = 0; i < lineMetrics.length; i++) {\n      const { lineHeight } = lineMetrics[i];\n      cumulativeHeight += lineHeight;\n      if (cumulativeHeight > options.maxHeight) {\n        if (options.overflow === \"hide\") {\n          return [];\n        }\n        const clippedResults = lines.slice(0, i || 1);\n        const lastLine = clippedResults.pop();\n        return clippedResults.concat(this.truncateLine(lastLine, measurer, options.maxWidth, true));\n      }\n    }\n    return lines;\n  }\n  static avoidOrphans(lines, measurer, options) {\n    if (options.avoidOrphans === false || lines.length < 2)\n      return;\n    const { length: length2 } = lines;\n    const lastLine = lines[length2 - 1];\n    const beforeLast = lines[length2 - 2];\n    if (beforeLast.length < lastLine.length)\n      return;\n    const lastSpaceIndex = beforeLast.lastIndexOf(\" \");\n    if (lastSpaceIndex === -1 || lastSpaceIndex === beforeLast.indexOf(\" \") || lastLine.includes(\" \"))\n      return;\n    const lastWord = beforeLast.slice(lastSpaceIndex + 1);\n    if (measurer.textWidth(lastLine + lastWord) <= options.maxWidth) {\n      lines[length2 - 2] = beforeLast.slice(0, lastSpaceIndex);\n      lines[length2 - 1] = lastWord + \" \" + lastLine;\n    }\n  }\n};\n\n// packages/ag-charts-community/src/module/enterpriseModule.ts\nvar enterpriseModule = {\n  isEnterprise: false\n};\n\n// packages/ag-charts-community/src/util/attributeUtil.ts\nfunction setAttribute(e, qualifiedName, value) {\n  if (value === void 0 || value === \"\") {\n    e?.removeAttribute(qualifiedName);\n  } else {\n    e?.setAttribute(qualifiedName, value.toString());\n  }\n}\nfunction setAttributes(e, attrs) {\n  if (attrs == null)\n    return;\n  let key;\n  for (key in attrs) {\n    if (key === \"class\")\n      continue;\n    setAttribute(e, key, attrs[key]);\n  }\n}\nfunction getAttribute(e, qualifiedName, defaultValue) {\n  if (!(e instanceof HTMLElement))\n    return void 0;\n  const value = e.getAttribute(qualifiedName);\n  if (value === null)\n    return defaultValue;\n  const type = typeof {}[qualifiedName];\n  if (type === \"boolean\")\n    return value === \"true\";\n  if (type === \"number\")\n    return Number(value);\n  if (type === \"string\")\n    return value;\n  return void 0;\n}\nfunction setElementStyle(e, property, value) {\n  if (e == null)\n    return;\n  if (value == null) {\n    e.style.removeProperty(property);\n  } else {\n    e.style.setProperty(property, value);\n  }\n}\n\n// packages/ag-charts-community/src/util/placement.ts\nfunction calculatePlacement(naturalWidth, naturalHeight, container, bounds) {\n  let { top, right, bottom, left, width: width2, height: height2 } = bounds;\n  if (left != null) {\n    if (width2 != null) {\n      right = container.width - left + width2;\n    } else if (right != null) {\n      width2 = container.width - left - right;\n    }\n  } else if (right != null && width2 != null) {\n    left = container.width - right - width2;\n  }\n  if (top != null) {\n    if (height2 != null) {\n      bottom = container.height - top - height2;\n    } else if (bottom != null) {\n      height2 = container.height - bottom - top;\n    }\n  } else if (bottom != null && height2 != null) {\n    top = container.height - bottom - height2;\n  }\n  if (width2 == null) {\n    if (height2 == null) {\n      width2 = naturalWidth;\n      height2 = naturalHeight;\n    } else {\n      width2 = Math.ceil(naturalWidth * height2 / naturalHeight);\n    }\n  } else if (height2 == null) {\n    height2 = Math.ceil(naturalHeight * width2 / naturalWidth);\n  }\n  if (left == null) {\n    if (right == null) {\n      left = Math.floor((container.width - width2) / 2);\n    } else {\n      left = container.width - right - width2;\n    }\n  }\n  if (top == null) {\n    if (bottom == null) {\n      top = Math.floor((container.height - height2) / 2);\n    } else {\n      top = container.height - height2 - bottom;\n    }\n  }\n  return { x: left, y: top, width: width2, height: height2 };\n}\n\n// packages/ag-charts-community/src/chart/tooltip/tooltip.ts\nvar DEFAULT_TOOLTIP_CLASS = \"ag-chart-tooltip\";\nvar DEFAULT_TOOLTIP_DARK_CLASS = \"ag-chart-dark-tooltip\";\nvar EMPTY_TOOLTIP_CONTENT = { html: \"\", ariaLabel: \"\" };\nfunction toAccessibleText(inputHtml) {\n  const lineConverter = (_match, offset4, str) => {\n    if (offset4 === 0 || str[offset4 - 1] !== \".\") {\n      return \". \";\n    }\n    return \" \";\n  };\n  return inputHtml.replace(/<br\\s*\\/?>/g, lineConverter).replace(/<\\/p\\s+>/g, lineConverter).replace(/<\\/li\\s*>/g, lineConverter).replace(/<[^<>]+>/g, \"\").replace(/\\n+/g, \" \").replace(/\\s+/g, \" \");\n}\nfunction toTooltipHtml(input, defaults) {\n  if (typeof input === \"string\") {\n    return { html: input, ariaLabel: input };\n  }\n  const {\n    content = defaults?.content ?? \"\",\n    title = defaults?.title,\n    color = defaults?.color ?? \"white\",\n    backgroundColor = defaults?.backgroundColor ?? \"#888\"\n  } = input;\n  const titleHtml = title ? `<div class=\"${DEFAULT_TOOLTIP_CLASS}-title\"\n        style=\"color: ${color}; background-color: ${backgroundColor}\">${title}</div>` : \"\";\n  const titleAria = title ? `${title}: ` : \"\";\n  const contentHtml = content ? `<div class=\"${DEFAULT_TOOLTIP_CLASS}-content\">${content}</div>` : \"\";\n  return {\n    html: `${titleHtml}${contentHtml}`,\n    ariaLabel: toAccessibleText(`${titleAria}${content}`)\n  };\n}\nvar TooltipPosition = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    /** The type of positioning for the tooltip. By default, the tooltip follows the pointer. */\n    this.type = \"pointer\";\n    /** The horizontal offset in pixels for the position of the tooltip. */\n    this.xOffset = 0;\n    /** The vertical offset in pixels for the position of the tooltip. */\n    this.yOffset = 0;\n  }\n};\n__decorateClass([\n  Validate(\n    UNION(\n      [\n        \"pointer\",\n        \"node\",\n        \"top\",\n        \"right\",\n        \"bottom\",\n        \"left\",\n        \"top-left\",\n        \"top-right\",\n        \"bottom-right\",\n        \"bottom-left\",\n        { value: \"sparkline\", undocumented: true }\n      ],\n      \"a position type\"\n    )\n  )\n], TooltipPosition.prototype, \"type\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], TooltipPosition.prototype, \"xOffset\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], TooltipPosition.prototype, \"yOffset\", 2);\nvar Tooltip = class extends BaseProperties {\n  constructor() {\n    super();\n    this.enabled = true;\n    this.delay = 0;\n    this.range = void 0;\n    this.wrapping = \"hyphenate\";\n    this.position = new TooltipPosition();\n    this.darkTheme = false;\n    this.bounds = \"extended\";\n    this.enableInteraction = false;\n    this.lastVisibilityChange = Date.now();\n    this.wrapTypes = [\"always\", \"hyphenate\", \"on-space\", \"never\"];\n    this.showTimeout = 0;\n    this._showArrow = true;\n  }\n  get interactive() {\n    return this.enableInteraction;\n  }\n  setup(domManager) {\n    this.element = domManager.addChild(\"canvas-overlay\", DEFAULT_TOOLTIP_CLASS);\n    this.element.classList.add(DEFAULT_TOOLTIP_CLASS);\n  }\n  destroy(domManager) {\n    domManager.removeChild(\"canvas-overlay\", DEFAULT_TOOLTIP_CLASS);\n  }\n  isVisible() {\n    return !this.element?.classList.contains(DEFAULT_TOOLTIP_CLASS + \"-hidden\");\n  }\n  /**\n   * Shows tooltip at the given event's coordinates.\n   * If the `html` parameter is missing, moves the existing tooltip to the new position.\n   */\n  show(boundingRect, canvasRect, meta, content, instantly = false) {\n    const { element: element2 } = this;\n    const existingPosition = element2?.getBoundingClientRect();\n    if (content != null && element2 != null) {\n      element2.innerHTML = content.html;\n    } else if (!element2?.innerHTML) {\n      this.toggle(false);\n      return;\n    }\n    const positionType = meta.position?.type ?? this.position.type;\n    const xOffset = meta.position?.xOffset ?? 0;\n    const yOffset = meta.position?.yOffset ?? 0;\n    const tooltipBounds = this.getTooltipBounds({ positionType, meta, yOffset, xOffset, canvasRect });\n    const relativeRect = {\n      x: boundingRect.x - canvasRect.x,\n      y: boundingRect.y - canvasRect.y,\n      width: boundingRect.width,\n      height: boundingRect.height\n    };\n    const position = calculatePlacement(element2.clientWidth, element2.clientHeight, relativeRect, tooltipBounds);\n    const minX = relativeRect.x;\n    const minY = relativeRect.y;\n    const maxX = relativeRect.width - element2.clientWidth - 1 + minX;\n    const maxY = relativeRect.height - element2.clientHeight + minY;\n    const left = clamp(minX, position.x, maxX);\n    const top = clamp(minY, position.y, maxY);\n    let willExistOutsideBoundingRectDuringTransition = false;\n    if (existingPosition != null) {\n      const maxXWithPreviousPosition = relativeRect.width - existingPosition.width - 1 + minX;\n      const maxYWithPreviousPosition = relativeRect.height - existingPosition.height + minY;\n      willExistOutsideBoundingRectDuringTransition = maxXWithPreviousPosition > maxX || maxYWithPreviousPosition > maxY;\n    }\n    const constrained = left !== position.x || top !== position.y;\n    const defaultShowArrow = (positionType === \"node\" || positionType === \"pointer\" || positionType === \"sparkline\") && !constrained && !xOffset && !yOffset;\n    const showArrow = meta.showArrow ?? this.showArrow ?? defaultShowArrow;\n    this.updateShowArrow(showArrow);\n    if (willExistOutsideBoundingRectDuringTransition) {\n      element2.style.transition = \"none\";\n    }\n    element2.style.transform = `translate(${Math.round(left)}px, ${Math.round(top)}px)`;\n    if (willExistOutsideBoundingRectDuringTransition) {\n      element2.style.transition = \"\";\n    }\n    if (meta.enableInteraction) {\n      this.enableInteraction = true;\n      element2.style.pointerEvents = \"auto\";\n      setAttribute(element2, \"aria-hidden\", void 0);\n    } else {\n      this.enableInteraction = false;\n      element2.style.pointerEvents = \"none\";\n      setAttribute(element2, \"aria-hidden\", true);\n    }\n    if (this.delay > 0 && !instantly) {\n      this.toggle(false);\n      this.showTimeout = setTimeout(() => {\n        this.toggle(true);\n      }, this.delay);\n    } else {\n      this.toggle(true);\n    }\n  }\n  toggle(visible) {\n    if (!this.element)\n      return;\n    const { classList } = this.element;\n    const toggleClass = (name, include) => classList.toggle(`${DEFAULT_TOOLTIP_CLASS}-${name}`, include);\n    const wasVisible = this.isVisible();\n    let timeSinceLastVisibilityChangeMs = Infinity;\n    if (!visible) {\n      clearTimeout(this.showTimeout);\n    }\n    if (wasVisible !== visible) {\n      const now = Date.now();\n      timeSinceLastVisibilityChangeMs = now - this.lastVisibilityChange;\n      this.lastVisibilityChange = now;\n    }\n    const animatedMoveThresholdMs = 100;\n    const thrashingThresholdMs = 5;\n    const noAnimation = !wasVisible && visible && timeSinceLastVisibilityChangeMs > animatedMoveThresholdMs;\n    if (timeSinceLastVisibilityChangeMs > thrashingThresholdMs) {\n      toggleClass(\"no-animation\", noAnimation);\n    }\n    toggleClass(\"no-interaction\", !this.enableInteraction);\n    toggleClass(\"hidden\", !visible);\n    toggleClass(\"arrow\", this._showArrow);\n    classList.toggle(DEFAULT_TOOLTIP_DARK_CLASS, this.darkTheme);\n    for (const wrapType of this.wrapTypes) {\n      classList.toggle(`${DEFAULT_TOOLTIP_CLASS}-wrap-${wrapType}`, wrapType === this.wrapping);\n    }\n  }\n  updateShowArrow(show) {\n    this._showArrow = show;\n  }\n  getTooltipBounds(opts) {\n    if (!this.element)\n      return {};\n    const { positionType, meta, yOffset, xOffset, canvasRect } = opts;\n    const { clientWidth: tooltipWidth, clientHeight: tooltipHeight } = this.element;\n    const bounds = { width: tooltipWidth, height: tooltipHeight };\n    switch (positionType) {\n      case \"node\":\n      case \"pointer\": {\n        bounds.top = meta.offsetY + yOffset - tooltipHeight - 8;\n        bounds.left = meta.offsetX + xOffset - tooltipWidth / 2;\n        return bounds;\n      }\n      case \"top\": {\n        bounds.top = yOffset;\n        bounds.left = canvasRect.width / 2 - tooltipWidth / 2 + xOffset;\n        return bounds;\n      }\n      case \"right\": {\n        bounds.top = canvasRect.height / 2 - tooltipHeight / 2 + yOffset;\n        bounds.left = canvasRect.width - tooltipWidth / 2 + xOffset;\n        return bounds;\n      }\n      case \"left\": {\n        bounds.top = canvasRect.height / 2 - tooltipHeight / 2 + yOffset;\n        bounds.left = xOffset;\n        return bounds;\n      }\n      case \"bottom\": {\n        bounds.top = canvasRect.height - tooltipHeight + yOffset;\n        bounds.left = canvasRect.width / 2 - tooltipWidth / 2 + xOffset;\n        return bounds;\n      }\n      case \"top-left\": {\n        bounds.top = yOffset;\n        bounds.left = xOffset;\n        return bounds;\n      }\n      case \"top-right\": {\n        bounds.top = yOffset;\n        bounds.left = canvasRect.width - tooltipWidth + xOffset;\n        return bounds;\n      }\n      case \"bottom-right\": {\n        bounds.top = canvasRect.height - tooltipHeight + yOffset;\n        bounds.left = canvasRect.width - tooltipWidth + xOffset;\n        return bounds;\n      }\n      case \"bottom-left\": {\n        bounds.top = canvasRect.height - tooltipHeight + yOffset;\n        bounds.left = xOffset;\n        return bounds;\n      }\n      case \"sparkline\": {\n        if (enterpriseModule.isEnterprise) {\n          bounds.top = yOffset - tooltipHeight - 8;\n        } else {\n          bounds.top = meta.offsetY + yOffset - tooltipHeight - 8;\n        }\n        bounds.left = meta.offsetX + xOffset - tooltipWidth / 2;\n        return bounds;\n      }\n    }\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], Tooltip.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], Tooltip.prototype, \"showArrow\", 2);\n__decorateClass([\n  ObserveChanges((target, newValue, oldValue) => {\n    if (newValue) {\n      target.element?.classList.add(newValue);\n    }\n    if (oldValue) {\n      target.element?.classList.remove(oldValue);\n    }\n  }),\n  Validate(STRING, { optional: true })\n], Tooltip.prototype, \"class\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Tooltip.prototype, \"delay\", 2);\n__decorateClass([\n  Validate(INTERACTION_RANGE, { optional: true })\n], Tooltip.prototype, \"range\", 2);\n__decorateClass([\n  Validate(TEXT_WRAP)\n], Tooltip.prototype, \"wrapping\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Tooltip.prototype, \"position\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], Tooltip.prototype, \"darkTheme\", 2);\n__decorateClass([\n  Validate(UNION([\"extended\", \"canvas\"]))\n], Tooltip.prototype, \"bounds\", 2);\n\n// packages/ag-charts-community/src/chart/caption.ts\nvar Caption = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.id = createId(this);\n    this.node = new RotatableText({ zIndex: 1 }).setProperties({\n      textAlign: \"center\",\n      pointerEvents: 1 /* None */\n    });\n    this.enabled = false;\n    this.textAlign = \"center\";\n    this.fontSize = 10;\n    this.fontFamily = \"sans-serif\";\n    this.wrapping = \"always\";\n    this.padding = 0;\n    this.layoutStyle = \"block\";\n    this.truncated = false;\n  }\n  registerInteraction(moduleCtx, where) {\n    const { regionManager, proxyInteractionService, layoutManager } = moduleCtx;\n    const region = regionManager.getRegion(\"root\");\n    const destroyFns = [\n      layoutManager.addListener(\"layout:complete\", () => this.updateA11yText(proxyInteractionService, where)),\n      region.addListener(\"hover\", (event) => this.handleMouseMove(moduleCtx, event)),\n      region.addListener(\"leave\", (event) => this.handleMouseLeave(moduleCtx, event))\n    ];\n    return joinFunctions(...destroyFns);\n  }\n  computeTextWrap(containerWidth, containerHeight) {\n    const { text, padding, wrapping } = this;\n    const maxWidth = Math.min(this.maxWidth ?? Infinity, containerWidth) - padding * 2;\n    const maxHeight = this.maxHeight ?? containerHeight - padding * 2;\n    if (!isFinite(maxWidth) && !isFinite(maxHeight)) {\n      this.node.text = text;\n      return;\n    }\n    const wrappedText = TextWrapper.wrapText(text ?? \"\", { maxWidth, maxHeight, font: this, textWrap: wrapping });\n    this.node.text = wrappedText;\n    this.truncated = wrappedText.includes(TextUtils.EllipsisChar);\n  }\n  updateA11yText(proxyService, where) {\n    if (this.enabled && this.text) {\n      const bbox = Transformable.toCanvas(this.node);\n      if (bbox) {\n        const { id } = this;\n        this.proxyText ?? (this.proxyText = proxyService.createProxyElement({ type: \"text\", id, parent: where }));\n        this.proxyText.textContent = this.text;\n        this.proxyText.updateBounds(bbox);\n      }\n    } else {\n      this.proxyText?.remove();\n      this.proxyText = void 0;\n    }\n  }\n  handleMouseMove(moduleCtx, event) {\n    if (event !== void 0 && this.enabled && this.node.visible && this.truncated) {\n      const { offsetX, offsetY } = event;\n      moduleCtx.tooltipManager.updateTooltip(\n        this.id,\n        { offsetX, offsetY, lastPointerEvent: event, showArrow: false },\n        toTooltipHtml({ content: this.text })\n      );\n    }\n  }\n  handleMouseLeave(moduleCtx, _event) {\n    moduleCtx.tooltipManager.removeTooltip(this.id);\n  }\n};\nCaption.SMALL_PADDING = 10;\nCaption.LARGE_PADDING = 20;\n__decorateClass([\n  Validate(BOOLEAN),\n  ProxyPropertyOnWrite(\"node\", \"visible\")\n], Caption.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true }),\n  ProxyPropertyOnWrite(\"node\")\n], Caption.prototype, \"text\", 2);\n__decorateClass([\n  Validate(TEXT_ALIGN, { optional: true }),\n  ProxyPropertyOnWrite(\"node\")\n], Caption.prototype, \"textAlign\", 2);\n__decorateClass([\n  Validate(FONT_STYLE, { optional: true }),\n  ProxyPropertyOnWrite(\"node\")\n], Caption.prototype, \"fontStyle\", 2);\n__decorateClass([\n  Validate(FONT_WEIGHT, { optional: true }),\n  ProxyPropertyOnWrite(\"node\")\n], Caption.prototype, \"fontWeight\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  ProxyPropertyOnWrite(\"node\")\n], Caption.prototype, \"fontSize\", 2);\n__decorateClass([\n  Validate(STRING),\n  ProxyPropertyOnWrite(\"node\")\n], Caption.prototype, \"fontFamily\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true }),\n  ProxyPropertyOnWrite(\"node\", \"fill\")\n], Caption.prototype, \"color\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], Caption.prototype, \"spacing\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], Caption.prototype, \"maxWidth\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], Caption.prototype, \"maxHeight\", 2);\n__decorateClass([\n  Validate(TEXT_WRAP)\n], Caption.prototype, \"wrapping\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Caption.prototype, \"padding\", 2);\n__decorateClass([\n  Validate(STRING)\n], Caption.prototype, \"layoutStyle\", 2);\n\n// packages/ag-charts-community/src/scene/layer.ts\nvar _Layer = class _Layer extends Group {\n  constructor(opts) {\n    super(opts);\n    this.opts = opts;\n    this.lastBBox = void 0;\n  }\n  static is(value) {\n    return value instanceof _Layer;\n  }\n  markDirty(type = 1 /* TRIVIAL */) {\n    super.markDirty(type, 1 /* TRIVIAL */);\n  }\n  preRender() {\n    const counts = super.preRender();\n    if (counts.nonGroups > 0) {\n      this.layer ?? (this.layer = this._layerManager?.addLayer({\n        name: this.name,\n        zIndex: this.zIndex,\n        zIndexSubOrder: this.zIndexSubOrder,\n        getComputedOpacity: () => this.getComputedOpacity(),\n        getVisibility: () => this.getVisibility()\n      }));\n      if (this.opts?.deriveZIndexFromChildren) {\n        this.deriveZIndexFromChildren();\n      }\n    }\n    return counts;\n  }\n  debugSkip(renderCtx) {\n    super.debugSkip(renderCtx);\n    const { stats } = renderCtx;\n    if (stats) {\n      stats.layersSkipped++;\n      stats.nodesSkipped += nodeCount(this).count;\n    }\n  }\n  render(renderCtx) {\n    if (!this.layer) {\n      return super.render(renderCtx);\n    }\n    const { opts: { name } = {}, _debug: debug3, clipRect } = this;\n    const { isDirty, isChildDirty, isChildLayerDirty } = this.isDirty(renderCtx);\n    const { stats } = renderCtx;\n    let { forceRender, clipBBox } = renderCtx;\n    const currentBBox = this.getBBox();\n    if (!this.lastBBox?.equals(currentBBox)) {\n      forceRender = \"dirtyTransform\";\n      this.lastBBox = currentBBox;\n    }\n    if (!isDirty && !isChildDirty && !isChildLayerDirty && !forceRender) {\n      this.debugSkip(renderCtx);\n      this.markClean({ recursive: false });\n      return;\n    }\n    if (forceRender !== \"dirtyTransform\") {\n      forceRender = isChildDirty || this.dirtyZIndex;\n    }\n    if (forceRender) {\n      this.layer.clear();\n    }\n    if (this.dirtyZIndex) {\n      this.sortChildren(Group.compareChildren);\n    }\n    const children = this.sortedChildren();\n    const renderCtxTransform = renderCtx.ctx.getTransform();\n    const { context: ctx } = this.layer;\n    ctx.save();\n    if (clipBBox) {\n      const { width: width2, height: height2, x, y } = clipBBox;\n      ctx.beginPath();\n      ctx.rect(x, y, width2, height2);\n      ctx.clip();\n      debug3?.(() => ({ name, clipBBox, renderCtx, group: this, ctxTransform: ctx.getTransform() }));\n    }\n    ctx.setTransform(renderCtxTransform);\n    if (this.clipRect) {\n      clipBBox = this.renderClip({ ...renderCtx, ctx });\n    }\n    this.renderChildren(children, { ...renderCtx, ctx, forceRender, clipBBox });\n    super.render(renderCtx, true);\n    if (clipRect) {\n      ctx.restore();\n    }\n    for (const child of this.virtualChildren()) {\n      child.markClean({ recursive: \"virtual\" });\n    }\n    if (stats)\n      stats.layersRendered++;\n    ctx.restore();\n    ctx.verifyDepthZero?.();\n    if (name && stats) {\n      debug3?.({\n        name,\n        renderCtx,\n        result: \"rendered\",\n        skipped: stats.nodesSkipped,\n        counts: nodeCount(this),\n        group: this\n      });\n    }\n  }\n  deriveZIndexFromChildren() {\n    let lastChild;\n    for (const child of this.children()) {\n      if (!child.childNodeCounts.nonGroups)\n        continue;\n      if (!lastChild || Group.compareChildren(lastChild, child) < 0) {\n        lastChild = child;\n      }\n    }\n    this.zIndex = lastChild?.zIndex ?? -Infinity;\n    this.zIndexSubOrder = lastChild?.zIndexSubOrder;\n  }\n  _setLayerManager(layersManager) {\n    if (this.layer) {\n      this._layerManager?.removeLayer(this.layer);\n      this.layer = void 0;\n    }\n    super._setLayerManager(layersManager);\n  }\n  getComputedOpacity() {\n    let opacity = 1;\n    for (const node of this.traverseUp(true)) {\n      if (node instanceof Group) {\n        opacity *= node.opacity;\n      }\n    }\n    return opacity;\n  }\n  getVisibility() {\n    for (const node of this.traverseUp(true)) {\n      if (!node.visible) {\n        return false;\n      }\n    }\n    return true;\n  }\n  onVisibleChange() {\n    if (this.layer) {\n      this.layer.enabled = this.visible;\n    }\n  }\n  onZIndexChange() {\n    super.onZIndexChange();\n    if (this.layer) {\n      this._layerManager?.moveLayer(this.layer, this.zIndex, this.zIndexSubOrder);\n    }\n  }\n};\n_Layer.className = \"Layer\";\nvar Layer = _Layer;\nvar TranslatableLayer = class extends Translatable(Layer) {\n};\n\n// packages/ag-charts-community/src/scene/shape/range.ts\nvar Range = class extends Shape {\n  constructor(opts = {}) {\n    super(opts);\n    this.x1 = 0;\n    this.y1 = 0;\n    this.x2 = 0;\n    this.y2 = 0;\n    this.startLine = false;\n    this.endLine = false;\n    this.isRange = false;\n    this.restoreOwnStyles();\n  }\n  computeBBox() {\n    return new BBox(this.x1, this.y1, this.x2 - this.x1, this.y2 - this.y1);\n  }\n  isPointInPath(_x, _y) {\n    return false;\n  }\n  render(renderCtx) {\n    const { ctx, forceRender, stats } = renderCtx;\n    if (this.dirty === 0 /* NONE */ && !forceRender) {\n      if (stats)\n        stats.nodesSkipped += nodeCount(this).count;\n      return;\n    }\n    let { x1, y1, x2, y2 } = this;\n    x1 = this.align(x1);\n    y1 = this.align(y1);\n    x2 = this.align(x2);\n    y2 = this.align(y2);\n    const { fill, opacity, isRange } = this;\n    const fillActive = !!(isRange && fill);\n    if (fillActive) {\n      const { fillOpacity } = this;\n      this.applyFill(ctx);\n      ctx.globalAlpha = opacity * fillOpacity;\n      ctx.beginPath();\n      ctx.moveTo(x1, y1);\n      ctx.lineTo(x2, y1);\n      ctx.lineTo(x2, y2);\n      ctx.lineTo(x1, y2);\n      ctx.closePath();\n      ctx.fill();\n    }\n    const { stroke, strokeWidth, startLine, endLine } = this;\n    const strokeActive = !!((startLine || endLine) && stroke && strokeWidth);\n    if (strokeActive) {\n      const { strokeOpacity, lineDash, lineDashOffset, lineCap, lineJoin } = this;\n      ctx.strokeStyle = stroke;\n      ctx.globalAlpha = opacity * strokeOpacity;\n      ctx.lineWidth = strokeWidth;\n      if (lineDash) {\n        ctx.setLineDash(lineDash);\n      }\n      if (lineDashOffset) {\n        ctx.lineDashOffset = lineDashOffset;\n      }\n      if (lineCap) {\n        ctx.lineCap = lineCap;\n      }\n      if (lineJoin) {\n        ctx.lineJoin = lineJoin;\n      }\n      ctx.beginPath();\n      if (startLine) {\n        ctx.moveTo(x1, y1);\n        ctx.lineTo(x2, y1);\n      }\n      if (endLine) {\n        ctx.moveTo(x2, y2);\n        ctx.lineTo(x1, y2);\n      }\n      ctx.stroke();\n    }\n    this.fillShadow?.markClean();\n    super.render(renderCtx);\n  }\n};\nRange.className = \"Range\";\nRange.defaultStyles = {\n  ...Shape.defaultStyles,\n  strokeWidth: 1\n};\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], Range.prototype, \"x1\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], Range.prototype, \"y1\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], Range.prototype, \"x2\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], Range.prototype, \"y2\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], Range.prototype, \"startLine\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], Range.prototype, \"endLine\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], Range.prototype, \"isRange\", 2);\n\n// packages/ag-charts-community/src/chart/label.ts\nvar Label = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n    this.fontSize = 12;\n    this.fontFamily = \"Verdana, sans-serif\";\n  }\n  getFont() {\n    return TextUtils.toFontString(this);\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], Label.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], Label.prototype, \"color\", 2);\n__decorateClass([\n  Validate(FONT_STYLE, { optional: true })\n], Label.prototype, \"fontStyle\", 2);\n__decorateClass([\n  Validate(FONT_WEIGHT, { optional: true })\n], Label.prototype, \"fontWeight\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Label.prototype, \"fontSize\", 2);\n__decorateClass([\n  Validate(STRING)\n], Label.prototype, \"fontFamily\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], Label.prototype, \"formatter\", 2);\nfunction calculateLabelRotation(opts) {\n  const { parallelFlipRotation = 0, regularFlipRotation = 0 } = opts;\n  const configuredRotation = opts.rotation ? normalizeAngle360(toRadians(opts.rotation)) : 0;\n  const parallelFlipFlag = !configuredRotation && parallelFlipRotation >= 0 && parallelFlipRotation <= Math.PI ? -1 : 1;\n  const regularFlipFlag = !configuredRotation && regularFlipRotation >= 0 && regularFlipRotation <= Math.PI ? -1 : 1;\n  let defaultRotation = 0;\n  if (opts.parallel) {\n    defaultRotation = parallelFlipFlag * Math.PI / 2;\n  } else if (regularFlipFlag === -1) {\n    defaultRotation = Math.PI;\n  }\n  return { configuredRotation, defaultRotation, parallelFlipFlag, regularFlipFlag };\n}\nfunction getLabelSpacing(minSpacing, rotated) {\n  if (!isNaN(minSpacing)) {\n    return minSpacing;\n  }\n  return rotated ? 0 : 10;\n}\nfunction getTextBaseline(parallel, labelRotation, sideFlag, parallelFlipFlag) {\n  if (parallel && !labelRotation) {\n    return sideFlag * parallelFlipFlag === -1 ? \"hanging\" : \"bottom\";\n  }\n  return \"middle\";\n}\nfunction getTextAlign(parallel, labelRotation, labelAutoRotation, sideFlag, regularFlipFlag) {\n  const labelRotated = labelRotation > 0 && labelRotation <= Math.PI;\n  const labelAutoRotated = labelAutoRotation > 0 && labelAutoRotation <= Math.PI;\n  const alignFlag = labelRotated || labelAutoRotated ? -1 : 1;\n  if (parallel) {\n    if (labelRotation || labelAutoRotation) {\n      if (sideFlag * alignFlag === -1) {\n        return \"end\";\n      }\n    } else {\n      return \"center\";\n    }\n  } else if (sideFlag * regularFlipFlag === -1) {\n    return \"end\";\n  }\n  return \"start\";\n}\nfunction calculateLabelBBox(text, bbox, labelMatrix) {\n  const { x: labelX, y: labelY, width: width2, height: height2 } = bbox;\n  const translatedBBox = new BBox(labelX, labelY, 0, 0);\n  labelMatrix.transformBBox(translatedBBox, bbox);\n  const { x, y } = bbox;\n  return {\n    point: { x, y },\n    label: { text, width: width2, height: height2 }\n  };\n}\n\n// packages/ag-charts-community/src/chart/zIndexMap.ts\nvar ZIndexMap = /* @__PURE__ */ ((ZIndexMap2) => {\n  ZIndexMap2[ZIndexMap2[\"SERIES_BACKGROUND\"] = 0] = \"SERIES_BACKGROUND\";\n  ZIndexMap2[ZIndexMap2[\"AXIS_GRID\"] = 1] = \"AXIS_GRID\";\n  ZIndexMap2[ZIndexMap2[\"AXIS\"] = 2] = \"AXIS\";\n  ZIndexMap2[ZIndexMap2[\"SERIES_CROSSLINE_RANGE\"] = 3] = \"SERIES_CROSSLINE_RANGE\";\n  ZIndexMap2[ZIndexMap2[\"SERIES_LAYER\"] = 4] = \"SERIES_LAYER\";\n  ZIndexMap2[ZIndexMap2[\"SERIES_HIGHLIGHT\"] = 5] = \"SERIES_HIGHLIGHT\";\n  ZIndexMap2[ZIndexMap2[\"AXIS_FOREGROUND\"] = 6] = \"AXIS_FOREGROUND\";\n  ZIndexMap2[ZIndexMap2[\"SERIES_CROSSHAIR\"] = 7] = \"SERIES_CROSSHAIR\";\n  ZIndexMap2[ZIndexMap2[\"CHART_OVERLAY\"] = 8] = \"CHART_OVERLAY\";\n  ZIndexMap2[ZIndexMap2[\"SERIES_CROSSLINE_LINE\"] = 9] = \"SERIES_CROSSLINE_LINE\";\n  ZIndexMap2[ZIndexMap2[\"SERIES_ANNOTATION\"] = 10] = \"SERIES_ANNOTATION\";\n  ZIndexMap2[ZIndexMap2[\"CHART_ANNOTATION\"] = 11] = \"CHART_ANNOTATION\";\n  ZIndexMap2[ZIndexMap2[\"CHART_ANNOTATION_FOCUSED\"] = 12] = \"CHART_ANNOTATION_FOCUSED\";\n  ZIndexMap2[ZIndexMap2[\"STATUS_BAR\"] = 13] = \"STATUS_BAR\";\n  ZIndexMap2[ZIndexMap2[\"SERIES_LABEL\"] = 14] = \"SERIES_LABEL\";\n  ZIndexMap2[ZIndexMap2[\"LEGEND\"] = 15] = \"LEGEND\";\n  ZIndexMap2[ZIndexMap2[\"NAVIGATOR\"] = 16] = \"NAVIGATOR\";\n  ZIndexMap2[ZIndexMap2[\"FOREGROUND\"] = 17] = \"FOREGROUND\";\n  return ZIndexMap2;\n})(ZIndexMap || {});\n\n// packages/ag-charts-community/src/util/value.ts\nfunction isStringObject(value) {\n  return value != null && Object.hasOwn(value, \"toString\") && isString(value.toString());\n}\nfunction isNumberObject(value) {\n  return value != null && Object.hasOwn(value, \"valueOf\") && isFiniteNumber(value.valueOf());\n}\nfunction isContinuous(value) {\n  return isFiniteNumber(value) || isValidDate(value) || isNumberObject(value);\n}\nfunction checkDatum(value, isContinuousScale) {\n  return value != null && (!isContinuousScale || isContinuous(value));\n}\nfunction transformIntegratedCategoryValue(value) {\n  if (isStringObject(value) && Object.hasOwn(value, \"id\")) {\n    return value.id;\n  }\n  return value;\n}\n\n// packages/ag-charts-community/src/chart/crossline/crossLine.ts\nvar MATCHING_CROSSLINE_TYPE = (property) => {\n  return property === \"value\" ? predicateWithMessage(\n    (_, ctx) => ctx.target[\"type\"] === \"line\",\n    (ctx) => ctx.target[\"type\"] === \"range\" ? `crossLine type 'range' to have a 'range' property instead of 'value'` : `crossLine property 'type' to be 'line'`\n  ) : predicateWithMessage(\n    (_, ctx) => ctx.target[\"type\"] === \"range\",\n    (ctx) => ctx.target.type === \"line\" ? `crossLine type 'line' to have a 'value' property instead of 'range'` : `crossLine property 'type' to be 'range'`\n  );\n};\nvar validateCrossLineValues = (type, value, range3, scale2, visibilityCheck) => {\n  const lineCrossLine = type === \"line\" && value !== void 0;\n  const rangeCrossLine = type === \"range\" && range3 !== void 0;\n  if (!lineCrossLine && !rangeCrossLine) {\n    return true;\n  }\n  const [start2, end2] = range3 ?? [value, void 0];\n  const isContinuous2 = ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2);\n  const validStart = checkDatum(start2, isContinuous2) && !isNaN(scale2.convert(start2));\n  const validEnd = checkDatum(end2, isContinuous2) && !isNaN(scale2.convert(end2));\n  if (lineCrossLine && validStart || rangeCrossLine && validStart && validEnd) {\n    return visibilityCheck?.() ?? true;\n  }\n  const message = [`Expecting crossLine`];\n  if (rangeCrossLine) {\n    if (!validStart) {\n      message.push(`range start ${stringify(start2)}`);\n    }\n    if (!validEnd) {\n      message.push(`${validStart ? \"\" : \"and \"}range end ${stringify(end2)}`);\n    }\n  } else {\n    message.push(`value ${stringify(start2)}`);\n  }\n  message.push(`to match the axis scale domain.`);\n  Logger.warnOnce(message.join(\" \"));\n  return false;\n};\n\n// packages/ag-charts-community/src/chart/crossline/crossLineLabelPosition.ts\nvar horizontalCrosslineTranslationDirections = {\n  top: { xTranslationDirection: 0, yTranslationDirection: -1 },\n  bottom: { xTranslationDirection: 0, yTranslationDirection: 1 },\n  left: { xTranslationDirection: -1, yTranslationDirection: 0 },\n  right: { xTranslationDirection: 1, yTranslationDirection: 0 },\n  topLeft: { xTranslationDirection: 1, yTranslationDirection: -1 },\n  topRight: { xTranslationDirection: -1, yTranslationDirection: -1 },\n  bottomLeft: { xTranslationDirection: 1, yTranslationDirection: 1 },\n  bottomRight: { xTranslationDirection: -1, yTranslationDirection: 1 },\n  inside: { xTranslationDirection: 0, yTranslationDirection: 0 },\n  insideLeft: { xTranslationDirection: 1, yTranslationDirection: 0 },\n  insideRight: { xTranslationDirection: -1, yTranslationDirection: 0 },\n  insideTop: { xTranslationDirection: 0, yTranslationDirection: 1 },\n  insideBottom: { xTranslationDirection: 0, yTranslationDirection: -1 },\n  insideTopLeft: { xTranslationDirection: 1, yTranslationDirection: 1 },\n  insideBottomLeft: { xTranslationDirection: 1, yTranslationDirection: -1 },\n  insideTopRight: { xTranslationDirection: -1, yTranslationDirection: 1 },\n  insideBottomRight: { xTranslationDirection: -1, yTranslationDirection: -1 }\n};\nvar verticalCrossLineTranslationDirections = {\n  top: { xTranslationDirection: 1, yTranslationDirection: 0 },\n  bottom: { xTranslationDirection: -1, yTranslationDirection: 0 },\n  left: { xTranslationDirection: 0, yTranslationDirection: -1 },\n  right: { xTranslationDirection: 0, yTranslationDirection: 1 },\n  topLeft: { xTranslationDirection: -1, yTranslationDirection: -1 },\n  topRight: { xTranslationDirection: -1, yTranslationDirection: 1 },\n  bottomLeft: { xTranslationDirection: 1, yTranslationDirection: -1 },\n  bottomRight: { xTranslationDirection: 1, yTranslationDirection: 1 },\n  inside: { xTranslationDirection: 0, yTranslationDirection: 0 },\n  insideLeft: { xTranslationDirection: 0, yTranslationDirection: 1 },\n  insideRight: { xTranslationDirection: 0, yTranslationDirection: -1 },\n  insideTop: { xTranslationDirection: -1, yTranslationDirection: 0 },\n  insideBottom: { xTranslationDirection: 1, yTranslationDirection: 0 },\n  insideTopLeft: { xTranslationDirection: -1, yTranslationDirection: 1 },\n  insideBottomLeft: { xTranslationDirection: 1, yTranslationDirection: 1 },\n  insideTopRight: { xTranslationDirection: -1, yTranslationDirection: -1 },\n  insideBottomRight: { xTranslationDirection: 1, yTranslationDirection: -1 }\n};\nfunction calculateLabelTranslation({\n  yDirection,\n  padding = 0,\n  position = \"top\",\n  bbox\n}) {\n  const crossLineTranslationDirections = yDirection ? horizontalCrosslineTranslationDirections : verticalCrossLineTranslationDirections;\n  const { xTranslationDirection, yTranslationDirection } = crossLineTranslationDirections[position];\n  const xTranslation = xTranslationDirection * (padding + bbox.width / 2);\n  const yTranslation = yTranslationDirection * (padding + bbox.height / 2);\n  return {\n    xTranslation,\n    yTranslation\n  };\n}\nfunction calculateLabelChartPadding({\n  yDirection,\n  bbox,\n  padding = 0,\n  position = \"top\"\n}) {\n  const chartPadding = {};\n  if (position.startsWith(\"inside\"))\n    return chartPadding;\n  if (position === \"top\" && !yDirection) {\n    chartPadding.top = padding + bbox.height;\n  } else if (position === \"bottom\" && !yDirection) {\n    chartPadding.bottom = padding + bbox.height;\n  } else if (position === \"left\" && yDirection) {\n    chartPadding.left = padding + bbox.width;\n  } else if (position === \"right\" && yDirection) {\n    chartPadding.right = padding + bbox.width;\n  }\n  return chartPadding;\n}\nvar POSITION_TOP_COORDINATES = ({ direction, xEnd, yStart, yEnd }) => {\n  if (direction === \"y\" /* Y */) {\n    return { x: xEnd / 2, y: yStart };\n  } else {\n    return { x: xEnd, y: isNaN(yEnd) ? yStart : (yStart + yEnd) / 2 };\n  }\n};\nvar POSITION_LEFT_COORDINATES = ({ direction, xStart, xEnd, yStart, yEnd }) => {\n  if (direction === \"y\" /* Y */) {\n    return { x: xStart, y: isNaN(yEnd) ? yStart : (yStart + yEnd) / 2 };\n  } else {\n    return { x: xEnd / 2, y: yStart };\n  }\n};\nvar POSITION_RIGHT_COORDINATES = ({ direction, xEnd, yStart, yEnd }) => {\n  if (direction === \"y\" /* Y */) {\n    return { x: xEnd, y: isNaN(yEnd) ? yStart : (yStart + yEnd) / 2 };\n  } else {\n    return { x: xEnd / 2, y: isNaN(yEnd) ? yStart : yEnd };\n  }\n};\nvar POSITION_BOTTOM_COORDINATES = ({ direction, xStart, xEnd, yStart, yEnd }) => {\n  if (direction === \"y\" /* Y */) {\n    return { x: xEnd / 2, y: isNaN(yEnd) ? yStart : yEnd };\n  } else {\n    return { x: xStart, y: isNaN(yEnd) ? yStart : (yStart + yEnd) / 2 };\n  }\n};\nvar POSITION_INSIDE_COORDINATES = ({ xEnd, yStart, yEnd }) => {\n  return { x: xEnd / 2, y: isNaN(yEnd) ? yStart : (yStart + yEnd) / 2 };\n};\nvar POSITION_TOP_LEFT_COORDINATES = ({ direction, xStart, xEnd, yStart }) => {\n  if (direction === \"y\" /* Y */) {\n    return { x: xStart / 2, y: yStart };\n  } else {\n    return { x: xEnd, y: yStart };\n  }\n};\nvar POSITION_BOTTOM_LEFT_COORDINATES = ({ direction, xStart, yStart, yEnd }) => {\n  if (direction === \"y\" /* Y */) {\n    return { x: xStart, y: isNaN(yEnd) ? yStart : yEnd };\n  } else {\n    return { x: xStart, y: yStart };\n  }\n};\nvar POSITION_TOP_RIGHT_COORDINATES = ({ direction, xEnd, yStart, yEnd }) => {\n  if (direction === \"y\" /* Y */) {\n    return { x: xEnd, y: yStart };\n  } else {\n    return { x: xEnd, y: isNaN(yEnd) ? yStart : yEnd };\n  }\n};\nvar POSITION_BOTTOM_RIGHT_COORDINATES = ({ direction, xStart, xEnd, yStart, yEnd }) => {\n  if (direction === \"y\" /* Y */) {\n    return { x: xEnd, y: isNaN(yEnd) ? yStart : yEnd };\n  } else {\n    return { x: xStart, y: isNaN(yEnd) ? yStart : yEnd };\n  }\n};\nvar labelDirectionHandling = {\n  top: { c: POSITION_TOP_COORDINATES },\n  bottom: { c: POSITION_BOTTOM_COORDINATES },\n  left: { c: POSITION_LEFT_COORDINATES },\n  right: { c: POSITION_RIGHT_COORDINATES },\n  topLeft: { c: POSITION_TOP_LEFT_COORDINATES },\n  topRight: { c: POSITION_TOP_RIGHT_COORDINATES },\n  bottomLeft: { c: POSITION_BOTTOM_LEFT_COORDINATES },\n  bottomRight: { c: POSITION_BOTTOM_RIGHT_COORDINATES },\n  inside: { c: POSITION_INSIDE_COORDINATES },\n  insideLeft: { c: POSITION_LEFT_COORDINATES },\n  insideRight: { c: POSITION_RIGHT_COORDINATES },\n  insideTop: { c: POSITION_TOP_COORDINATES },\n  insideBottom: { c: POSITION_BOTTOM_COORDINATES },\n  insideTopLeft: { c: POSITION_TOP_LEFT_COORDINATES },\n  insideBottomLeft: { c: POSITION_BOTTOM_LEFT_COORDINATES },\n  insideTopRight: { c: POSITION_TOP_RIGHT_COORDINATES },\n  insideBottomRight: { c: POSITION_BOTTOM_RIGHT_COORDINATES }\n};\n\n// packages/ag-charts-community/src/chart/crossline/cartesianCrossLine.ts\nvar CROSSLINE_LABEL_POSITION = UNION(\n  [\n    \"top\",\n    \"left\",\n    \"right\",\n    \"bottom\",\n    \"topLeft\",\n    \"topRight\",\n    \"bottomLeft\",\n    \"bottomRight\",\n    \"inside\",\n    \"insideLeft\",\n    \"insideRight\",\n    \"insideTop\",\n    \"insideBottom\",\n    \"insideTopLeft\",\n    \"insideBottomLeft\",\n    \"insideTopRight\",\n    \"insideBottomRight\"\n  ],\n  \"crossLine label position\"\n);\nvar CartesianCrossLineLabel = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.fontSize = 14;\n    this.fontFamily = \"Verdana, sans-serif\";\n    this.padding = 5;\n    this.color = \"rgba(87, 87, 87, 1)\";\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], CartesianCrossLineLabel.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], CartesianCrossLineLabel.prototype, \"text\", 2);\n__decorateClass([\n  Validate(FONT_STYLE, { optional: true })\n], CartesianCrossLineLabel.prototype, \"fontStyle\", 2);\n__decorateClass([\n  Validate(FONT_WEIGHT, { optional: true })\n], CartesianCrossLineLabel.prototype, \"fontWeight\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], CartesianCrossLineLabel.prototype, \"fontSize\", 2);\n__decorateClass([\n  Validate(STRING)\n], CartesianCrossLineLabel.prototype, \"fontFamily\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], CartesianCrossLineLabel.prototype, \"padding\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], CartesianCrossLineLabel.prototype, \"color\", 2);\n__decorateClass([\n  Validate(CROSSLINE_LABEL_POSITION, { optional: true })\n], CartesianCrossLineLabel.prototype, \"position\", 2);\n__decorateClass([\n  Validate(DEGREE, { optional: true })\n], CartesianCrossLineLabel.prototype, \"rotation\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], CartesianCrossLineLabel.prototype, \"parallel\", 2);\nvar _CartesianCrossLine = class _CartesianCrossLine extends BaseProperties {\n  constructor() {\n    super();\n    this.id = createId(this);\n    this.label = new CartesianCrossLineLabel();\n    this.scale = void 0;\n    this.clippedRange = [-Infinity, Infinity];\n    this.gridLength = 0;\n    this.sideFlag = -1;\n    this.parallelFlipRotation = 0;\n    this.regularFlipRotation = 0;\n    this.direction = \"x\" /* X */;\n    this.group = new Layer({ name: this.id, zIndex: _CartesianCrossLine.LINE_LAYER_ZINDEX });\n    this.labelGroup = new Layer({ name: this.id, zIndex: _CartesianCrossLine.LABEL_LAYER_ZINDEX });\n    this.crossLineRange = new Range();\n    this.crossLineLabel = new TransformableText();\n    this.labelPoint = void 0;\n    this.data = [];\n    this.startLine = false;\n    this.endLine = false;\n    this.isRange = false;\n    this.group.append(this.crossLineRange);\n    this.labelGroup.append(this.crossLineLabel);\n    this.crossLineRange.pointerEvents = 1 /* None */;\n  }\n  update(visible) {\n    const { enabled, data, type, value, range: range3, scale: scale2 } = this;\n    if (!type || !scale2 || !enabled || !visible || !validateCrossLineValues(type, value, range3, scale2) || data.length === 0) {\n      this.group.visible = false;\n      this.labelGroup.visible = false;\n      return;\n    }\n    this.group.visible = visible;\n    this.labelGroup.visible = visible;\n    this.group.zIndex = this.getZIndex(this.isRange);\n    this.updateNodes();\n  }\n  calculateLayout(visible, reversedAxis) {\n    if (!visible)\n      return;\n    const {\n      scale: scale2,\n      gridLength,\n      sideFlag,\n      direction,\n      label: { position = \"top\" },\n      clippedRange,\n      strokeWidth = 0\n    } = this;\n    this.data = [];\n    if (!scale2)\n      return;\n    const bandwidth = scale2.bandwidth ?? 0;\n    const step = scale2.step ?? 0;\n    const padding = (reversedAxis ? -1 : 1) * (scale2 instanceof BandScale ? (step - bandwidth) / 2 : 0);\n    const [xStart, xEnd] = [0, sideFlag * gridLength];\n    let [yStart, yEnd] = this.getRange();\n    const ordinalTimeScalePadding = yEnd === void 0 && OrdinalTimeScale.is(scale2) ? bandwidth / 2 + padding : 0;\n    let [clampedYStart, clampedYEnd] = [\n      Number(scale2.convert(yStart, { clampMode: \"clamped\" })) - padding + ordinalTimeScalePadding,\n      scale2.convert(yEnd, { clampMode: \"clamped\" }) + bandwidth + padding\n    ];\n    clampedYStart = clampArray(clampedYStart, clippedRange);\n    clampedYEnd = clampArray(clampedYEnd, clippedRange);\n    [yStart, yEnd] = [Number(scale2.convert(yStart)) + ordinalTimeScalePadding, scale2.convert(yEnd) + bandwidth];\n    const validRange = (yStart === clampedYStart || yEnd === clampedYEnd || clampedYStart !== clampedYEnd) && Math.abs(clampedYEnd - clampedYStart) > 0;\n    if (validRange && clampedYStart > clampedYEnd) {\n      [clampedYStart, clampedYEnd] = [clampedYEnd, clampedYStart];\n      [yStart, yEnd] = [yEnd, yStart];\n    }\n    if (yStart - padding >= clampedYStart)\n      yStart -= padding;\n    if (yEnd + padding <= clampedYEnd)\n      yEnd += padding;\n    this.isRange = validRange;\n    this.startLine = strokeWidth > 0 && yStart >= clampedYStart && yStart <= clampedYStart + padding;\n    this.endLine = strokeWidth > 0 && yEnd >= clampedYEnd - bandwidth - padding && yEnd <= clampedYEnd;\n    if (!validRange && !this.startLine && !this.endLine)\n      return;\n    this.data = [clampedYStart, clampedYEnd];\n    if (!this.label.enabled)\n      return;\n    const { c = POSITION_TOP_COORDINATES } = labelDirectionHandling[position] ?? {};\n    const { x: labelX, y: labelY } = c({\n      direction,\n      xStart,\n      xEnd,\n      yStart: clampedYStart,\n      yEnd: clampedYEnd\n    });\n    this.labelPoint = {\n      x: labelX,\n      y: labelY\n    };\n  }\n  updateNodes() {\n    this.updateRangeNode();\n    if (this.label.enabled) {\n      this.updateLabel();\n      this.positionLabel();\n    }\n  }\n  updateRangeNode() {\n    const {\n      crossLineRange,\n      sideFlag,\n      gridLength,\n      data,\n      startLine,\n      endLine,\n      isRange,\n      fill,\n      fillOpacity,\n      stroke,\n      strokeWidth,\n      lineDash\n    } = this;\n    crossLineRange.x1 = 0;\n    crossLineRange.x2 = sideFlag * gridLength;\n    crossLineRange.y1 = data[0];\n    crossLineRange.y2 = data[1];\n    crossLineRange.startLine = startLine;\n    crossLineRange.endLine = endLine;\n    crossLineRange.isRange = isRange;\n    crossLineRange.fill = fill;\n    crossLineRange.fillOpacity = fillOpacity ?? 1;\n    crossLineRange.stroke = stroke;\n    crossLineRange.strokeWidth = strokeWidth ?? 1;\n    crossLineRange.strokeOpacity = this.strokeOpacity ?? 1;\n    crossLineRange.lineDash = lineDash;\n  }\n  updateLabel() {\n    const { crossLineLabel, label } = this;\n    if (!label.text)\n      return;\n    crossLineLabel.fontStyle = label.fontStyle;\n    crossLineLabel.fontWeight = label.fontWeight;\n    crossLineLabel.fontSize = label.fontSize;\n    crossLineLabel.fontFamily = label.fontFamily;\n    crossLineLabel.fill = label.color;\n    crossLineLabel.text = label.text;\n  }\n  positionLabel() {\n    const {\n      crossLineLabel,\n      labelPoint: { x = void 0, y = void 0 } = {},\n      label: { parallel, rotation, position = \"top\", padding = 0 },\n      direction,\n      parallelFlipRotation,\n      regularFlipRotation\n    } = this;\n    if (x === void 0 || y === void 0)\n      return;\n    const { defaultRotation, configuredRotation } = calculateLabelRotation({\n      rotation,\n      parallel,\n      regularFlipRotation,\n      parallelFlipRotation\n    });\n    crossLineLabel.rotation = defaultRotation + configuredRotation;\n    crossLineLabel.textBaseline = \"middle\";\n    crossLineLabel.textAlign = \"center\";\n    const bbox = crossLineLabel.getBBox();\n    if (!bbox)\n      return;\n    const yDirection = direction === \"y\" /* Y */;\n    const { xTranslation, yTranslation } = calculateLabelTranslation({\n      yDirection,\n      padding,\n      position,\n      bbox\n    });\n    crossLineLabel.translationX = x + xTranslation;\n    crossLineLabel.translationY = y + yTranslation;\n  }\n  getZIndex(isRange = false) {\n    return isRange ? _CartesianCrossLine.RANGE_LAYER_ZINDEX : _CartesianCrossLine.LINE_LAYER_ZINDEX;\n  }\n  getRange() {\n    const { value, range: range3, scale: scale2 } = this;\n    const isContinuous2 = ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2);\n    const start2 = range3?.[0] ?? value;\n    let end2 = range3?.[1];\n    if (!isContinuous2 && end2 === void 0) {\n      end2 = start2;\n    }\n    if (isContinuous2 && start2 === end2) {\n      end2 = void 0;\n    }\n    return [start2, end2];\n  }\n  computeLabelBBox() {\n    const { label } = this;\n    if (!label.enabled)\n      return;\n    const tempText = new TransformableText();\n    tempText.fontFamily = label.fontFamily;\n    tempText.fontSize = label.fontSize;\n    tempText.fontStyle = label.fontStyle;\n    tempText.fontWeight = label.fontWeight;\n    tempText.text = label.text;\n    const {\n      labelPoint: { x = void 0, y = void 0 } = {},\n      label: { parallel, rotation, position = \"top\", padding = 0 },\n      direction,\n      parallelFlipRotation,\n      regularFlipRotation\n    } = this;\n    if (x === void 0 || y === void 0)\n      return;\n    const { configuredRotation } = calculateLabelRotation({\n      rotation,\n      parallel,\n      regularFlipRotation,\n      parallelFlipRotation\n    });\n    tempText.rotation = configuredRotation;\n    tempText.textBaseline = \"middle\";\n    tempText.textAlign = \"center\";\n    const bbox = tempText.getBBox();\n    if (!bbox)\n      return;\n    const yDirection = direction === \"y\" /* Y */;\n    const { xTranslation, yTranslation } = calculateLabelTranslation({\n      yDirection,\n      padding,\n      position,\n      bbox\n    });\n    tempText.x = x + xTranslation;\n    tempText.y = y + yTranslation;\n    return tempText.getBBox();\n  }\n  calculatePadding(padding) {\n    const {\n      isRange,\n      startLine,\n      endLine,\n      direction,\n      label: { padding: labelPadding = 0, position = \"top\" }\n    } = this;\n    if (!isRange && !startLine && !endLine)\n      return;\n    const crossLineLabelBBox = this.computeLabelBBox();\n    if (crossLineLabelBBox?.x == null || crossLineLabelBBox?.y == null)\n      return;\n    const chartPadding = calculateLabelChartPadding({\n      yDirection: direction === \"y\" /* Y */,\n      padding: labelPadding,\n      position,\n      bbox: crossLineLabelBBox\n    });\n    padding.left = Math.max(padding.left ?? 0, chartPadding.left ?? 0);\n    padding.right = Math.max(padding.right ?? 0, chartPadding.right ?? 0);\n    padding.top = Math.max(padding.top ?? 0, chartPadding.top ?? 0);\n    padding.bottom = Math.max(padding.bottom ?? 0, chartPadding.bottom ?? 0);\n  }\n};\n_CartesianCrossLine.LINE_LAYER_ZINDEX = 9 /* SERIES_CROSSLINE_LINE */;\n_CartesianCrossLine.RANGE_LAYER_ZINDEX = 3 /* SERIES_CROSSLINE_RANGE */;\n_CartesianCrossLine.LABEL_LAYER_ZINDEX = 14 /* SERIES_LABEL */;\n_CartesianCrossLine.className = \"CrossLine\";\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], _CartesianCrossLine.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(UNION([\"range\", \"line\"], \"a crossLine type\"), { optional: true })\n], _CartesianCrossLine.prototype, \"type\", 2);\n__decorateClass([\n  Validate(AND(MATCHING_CROSSLINE_TYPE(\"range\"), ARRAY.restrict({ length: 2 })), {\n    optional: true\n  })\n], _CartesianCrossLine.prototype, \"range\", 2);\n__decorateClass([\n  Validate(MATCHING_CROSSLINE_TYPE(\"value\"), { optional: true })\n], _CartesianCrossLine.prototype, \"value\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], _CartesianCrossLine.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], _CartesianCrossLine.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], _CartesianCrossLine.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(NUMBER, { optional: true })\n], _CartesianCrossLine.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], _CartesianCrossLine.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH, { optional: true })\n], _CartesianCrossLine.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], _CartesianCrossLine.prototype, \"label\", 2);\nvar CartesianCrossLine = _CartesianCrossLine;\n\n// packages/ag-charts-community/src/chart/axis/axisGridLine.ts\nvar GRID_STYLE_KEYS = [\"stroke\", \"lineDash\"];\nvar GRID_STYLE = ARRAY_OF(\n  (value) => isObject(value) && Object.keys(value).every((key) => GRID_STYLE_KEYS.includes(key)),\n  \"objects with gridline style properties such as 'stroke' or 'lineDash'\"\n);\nvar AxisGridLine = class {\n  constructor() {\n    this.enabled = true;\n    this.width = 1;\n    this.style = [\n      {\n        stroke: void 0,\n        lineDash: []\n      }\n    ];\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisGridLine.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AxisGridLine.prototype, \"width\", 2);\n__decorateClass([\n  Validate(GRID_STYLE)\n], AxisGridLine.prototype, \"style\", 2);\n\n// packages/ag-charts-community/src/util/default.ts\nfunction Default(defaultValue, replaces = [void 0]) {\n  return addTransformToInstanceProperty((_, __, v) => {\n    if (replaces.includes(v)) {\n      return isFunction(defaultValue) ? defaultValue(v) : defaultValue;\n    }\n    return v;\n  });\n}\n\n// packages/ag-charts-community/src/chart/axis/axisInterval.ts\nvar TICK_INTERVAL = predicateWithMessage(\n  (value) => isFiniteNumber(value) && value > 0 || value instanceof TimeInterval,\n  `a non-zero positive Number value or, for a time axis, a Time Interval such as 'agCharts.time.month'`\n);\nvar AxisInterval = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.minSpacing = NaN;\n    this.maxSpacing = NaN;\n  }\n};\n__decorateClass([\n  Validate(TICK_INTERVAL, { optional: true })\n], AxisInterval.prototype, \"step\", 2);\n__decorateClass([\n  Validate(ARRAY, { optional: true })\n], AxisInterval.prototype, \"values\", 2);\n__decorateClass([\n  Validate(MIN_SPACING),\n  Default(NaN)\n], AxisInterval.prototype, \"minSpacing\", 2);\n__decorateClass([\n  Validate(MAX_SPACING),\n  Default(NaN)\n], AxisInterval.prototype, \"maxSpacing\", 2);\n\n// packages/ag-charts-community/src/chart/axis/axisLabel.ts\nvar AxisLabel = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n    this.fontSize = 12;\n    this.fontFamily = \"Verdana, sans-serif\";\n    this.padding = 5;\n    this.minSpacing = NaN;\n    this.color = \"#575757\";\n    this.avoidCollisions = true;\n    this.mirrored = false;\n    this.parallel = false;\n  }\n  /**\n   * The side of the axis line to position the labels on.\n   * -1 = left (default)\n   * 1 = right\n   */\n  getSideFlag() {\n    return this.mirrored ? 1 : -1;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisLabel.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(FONT_STYLE, { optional: true })\n], AxisLabel.prototype, \"fontStyle\", 2);\n__decorateClass([\n  Validate(FONT_WEIGHT, { optional: true })\n], AxisLabel.prototype, \"fontWeight\", 2);\n__decorateClass([\n  Validate(NUMBER.restrict({ min: 1 }))\n], AxisLabel.prototype, \"fontSize\", 2);\n__decorateClass([\n  Validate(STRING)\n], AxisLabel.prototype, \"fontFamily\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AxisLabel.prototype, \"padding\", 2);\n__decorateClass([\n  Validate(NUMBER_OR_NAN),\n  Default(NaN)\n], AxisLabel.prototype, \"minSpacing\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], AxisLabel.prototype, \"color\", 2);\n__decorateClass([\n  Validate(DEGREE, { optional: true })\n], AxisLabel.prototype, \"rotation\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisLabel.prototype, \"avoidCollisions\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisLabel.prototype, \"mirrored\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisLabel.prototype, \"parallel\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], AxisLabel.prototype, \"formatter\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], AxisLabel.prototype, \"format\", 2);\n\n// packages/ag-charts-community/src/chart/axis/axisLine.ts\nvar AxisLine = class {\n  constructor() {\n    this.enabled = true;\n    this.width = 1;\n    this.stroke = void 0;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisLine.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AxisLine.prototype, \"width\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], AxisLine.prototype, \"stroke\", 2);\n\n// packages/ag-charts-community/src/chart/axis/axisTick.ts\nvar AxisTick = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n    this.width = 1;\n    this.size = 6;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisTick.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AxisTick.prototype, \"width\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AxisTick.prototype, \"size\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], AxisTick.prototype, \"stroke\", 2);\n\n// packages/ag-charts-community/src/chart/axis/axisTitle.ts\nvar AxisTitle = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.caption = new Caption();\n    this.enabled = false;\n    this.spacing = Caption.SMALL_PADDING;\n    this.fontSize = 10;\n    this.fontFamily = \"sans-serif\";\n    this.wrapping = \"always\";\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisTitle.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], AxisTitle.prototype, \"text\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], AxisTitle.prototype, \"spacing\", 2);\n__decorateClass([\n  Validate(FONT_STYLE, { optional: true })\n], AxisTitle.prototype, \"fontStyle\", 2);\n__decorateClass([\n  Validate(FONT_WEIGHT, { optional: true })\n], AxisTitle.prototype, \"fontWeight\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AxisTitle.prototype, \"fontSize\", 2);\n__decorateClass([\n  Validate(STRING)\n], AxisTitle.prototype, \"fontFamily\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], AxisTitle.prototype, \"color\", 2);\n__decorateClass([\n  Validate(TEXT_WRAP)\n], AxisTitle.prototype, \"wrapping\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], AxisTitle.prototype, \"formatter\", 2);\n\n// packages/ag-charts-community/src/chart/axis/axisUtil.ts\nfunction prepareAxisAnimationContext(axis) {\n  const [requestedRangeMin, requestedRangeMax] = findMinMax(axis.range);\n  const min = Math.floor(requestedRangeMin);\n  const max = Math.ceil(requestedRangeMax);\n  return { min, max, visible: min !== max };\n}\nvar fullCircle = Math.PI * 2;\nvar halfCircle = fullCircle / 2;\nfunction normaliseEndRotation(start2, end2) {\n  const directDistance = Math.abs(end2 - start2);\n  if (directDistance < halfCircle) {\n    return end2;\n  } else if (start2 > end2) {\n    return end2 + fullCircle;\n  }\n  return end2 - fullCircle;\n}\nfunction prepareAxisAnimationFunctions(ctx) {\n  const outOfBounds = (y, range3) => {\n    const [min = ctx.min, max = ctx.max] = findMinMax(range3 ?? []);\n    return y < min || y > max;\n  };\n  const tick = {\n    fromFn(node, datum, status) {\n      let y = node.y1 + node.translationY;\n      let opacity = node.opacity;\n      if (status === \"added\" || outOfBounds(node.datum.translationY, node.datum.range)) {\n        y = datum.translationY;\n        opacity = 0;\n      }\n      return { y: 0, translationY: y, opacity, phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[status] };\n    },\n    toFn(_node, datum, status) {\n      const y = datum.translationY;\n      let opacity = 1;\n      if (status === \"removed\") {\n        opacity = 0;\n      }\n      return {\n        y: 0,\n        translationY: y,\n        opacity,\n        finish: {\n          // Set explicit y after animation so it's pixel aligned\n          y,\n          translationY: 0\n        }\n      };\n    },\n    applyFn(node, props) {\n      node.setProperties(props);\n      node.visible = !outOfBounds(node.y);\n    }\n  };\n  const label = {\n    fromFn(node, newDatum, status) {\n      const datum = node.previousDatum ?? newDatum;\n      const x = datum.x;\n      const y = datum.y;\n      const rotationCenterX = datum.rotationCenterX;\n      let translationY = Math.round(node.translationY);\n      let rotation = datum.rotation;\n      let opacity = node.opacity;\n      if (status === \"removed\" || outOfBounds(datum.y, datum.range)) {\n        rotation = newDatum.rotation;\n      } else if (status === \"added\" || outOfBounds(node.datum.y, node.datum.range)) {\n        translationY = Math.round(datum.translationY);\n        opacity = 0;\n        rotation = newDatum.rotation;\n      }\n      return {\n        x,\n        y,\n        rotationCenterX,\n        translationY,\n        rotation,\n        opacity,\n        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[status]\n      };\n    },\n    toFn(node, datum, status) {\n      const x = datum.x;\n      const y = datum.y;\n      const rotationCenterX = datum.rotationCenterX;\n      const translationY = Math.round(datum.translationY);\n      let rotation = 0;\n      let opacity = 1;\n      if (status === \"added\") {\n        opacity = 1;\n        rotation = datum.rotation;\n      } else if (status === \"removed\") {\n        opacity = 0;\n        rotation = datum.rotation;\n      } else {\n        rotation = normaliseEndRotation(node.previousDatum?.rotation ?? datum.rotation, datum.rotation);\n      }\n      return { x, y, rotationCenterX, translationY, rotation, opacity, finish: { rotation: datum.rotation } };\n    }\n  };\n  const line = {\n    fromFn(node, datum) {\n      return {\n        ...node.previousDatum ?? datum,\n        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[\"updated\"]\n      };\n    },\n    toFn(_node, datum) {\n      return { ...datum };\n    }\n  };\n  const group = {\n    fromFn(node, _datum) {\n      const { rotation, translationX, translationY } = node;\n      return {\n        rotation,\n        translationX,\n        translationY,\n        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[\"updated\"]\n      };\n    },\n    toFn(_node, datum) {\n      const { rotation, translationX, translationY } = datum;\n      return {\n        rotation,\n        translationX,\n        translationY\n      };\n    }\n  };\n  return { tick, line, label, group };\n}\nfunction resetAxisGroupFn() {\n  return (_node, datum) => {\n    return {\n      rotation: datum.rotation,\n      rotationCenterX: datum.rotationCenterX,\n      rotationCenterY: datum.rotationCenterY,\n      translationX: datum.translationX,\n      translationY: datum.translationY\n    };\n  };\n}\nfunction resetAxisSelectionFn(ctx) {\n  const { visible: rangeVisible, min, max } = ctx;\n  return (_node, datum) => {\n    const y = datum.translationY;\n    const visible = rangeVisible && y >= min && y <= max;\n    return {\n      y,\n      translationY: 0,\n      opacity: 1,\n      visible\n    };\n  };\n}\nfunction resetAxisLabelSelectionFn() {\n  return (_node, datum) => {\n    return {\n      x: datum.x,\n      y: datum.y,\n      translationY: datum.translationY,\n      rotation: datum.rotation,\n      rotationCenterX: datum.rotationCenterX\n    };\n  };\n}\nfunction resetAxisLineSelectionFn() {\n  return (_node, datum) => {\n    return { ...datum };\n  };\n}\n\n// packages/ag-charts-community/src/chart/axis/axis.ts\nvar TranslatableLine = class extends Translatable(Line) {\n};\nvar _Axis = class _Axis {\n  constructor(moduleCtx, scale2) {\n    this.moduleCtx = moduleCtx;\n    this.scale = scale2;\n    this.id = createId(this);\n    this.nice = true;\n    this.reverse = false;\n    this.keys = [];\n    this.interval = new AxisInterval();\n    this.dataDomain = { domain: [], clipped: false };\n    this.layoutConstraints = {\n      stacked: true,\n      align: \"start\",\n      width: 100,\n      unit: \"percent\"\n    };\n    this.boundSeries = [];\n    this.includeInvisibleDomains = false;\n    this.interactionEnabled = true;\n    this.axisGroup = new TransformableGroup({ name: `${this.id}-axis`, zIndex: 2 /* AXIS */ });\n    this.lineNode = this.axisGroup.appendChild(new TranslatableLine({ name: `${this.id}-Axis-line` }));\n    this.tickLineGroup = this.axisGroup.appendChild(\n      new Group({ name: `${this.id}-Axis-tick-lines`, zIndex: 2 /* AXIS */ })\n    );\n    this.tickLabelGroup = this.axisGroup.appendChild(\n      new Group({ name: `${this.id}-Axis-tick-labels`, zIndex: 2 /* AXIS */ })\n    );\n    this.crossLineGroup = new TransformableGroup({ name: `${this.id}-CrossLines` });\n    this.labelGroup = new Group({ name: `${this.id}-Labels`, zIndex: 10 /* SERIES_ANNOTATION */ });\n    this.gridGroup = new TransformableGroup({ name: `${this.id}-Axis-grid` });\n    this.gridLineGroup = this.gridGroup.appendChild(\n      new Group({\n        name: `${this.id}-gridLines`,\n        zIndex: 1 /* AXIS_GRID */\n      })\n    );\n    this.tickLineGroupSelection = Selection.select(this.tickLineGroup, TranslatableLine, false);\n    this.tickLabelGroupSelection = Selection.select(\n      this.tickLabelGroup,\n      TransformableText,\n      false\n    );\n    this.gridLineGroupSelection = Selection.select(this.gridLineGroup, TranslatableLine, false);\n    this._crossLines = [];\n    this.line = new AxisLine();\n    this.tick = new AxisTick();\n    this.gridLine = new AxisGridLine();\n    this.label = this.createLabel();\n    this.defaultTickMinSpacing = _Axis.defaultTickMinSpacing;\n    this.translation = { x: 0, y: 0 };\n    this.rotation = 0;\n    // axis rotation angle in degrees\n    this.layout = {\n      label: {\n        fractionDigits: 0,\n        padding: this.label.padding,\n        format: this.label.format\n      }\n    };\n    this.destroyFns = [];\n    this.range = [0, 1];\n    this.visibleRange = [0, 1];\n    this.title = new AxisTitle();\n    this.gridLength = 0;\n    /**\n     * The distance between the grid ticks and the axis ticks.\n     */\n    this.gridPadding = 0;\n    /**\n     * Is used to avoid collisions between axis labels and series.\n     */\n    this.seriesAreaPadding = 0;\n    this.tickGenerationResult = void 0;\n    this.moduleMap = new ModuleMap();\n    this.range = this.scale.range.slice();\n    this.crossLines.forEach((crossLine) => this.initCrossLine(crossLine));\n    this.axisGroup.appendChild(this.title.caption.node);\n    this.animationManager = moduleCtx.animationManager;\n    this.animationState = new StateMachine(\"empty\", {\n      empty: {\n        update: {\n          target: \"ready\",\n          action: () => this.resetSelectionNodes()\n        },\n        reset: \"empty\"\n      },\n      ready: {\n        update: (data) => this.animateReadyUpdate(data),\n        resize: () => this.resetSelectionNodes(),\n        reset: \"empty\"\n      }\n    });\n    let previousSize = void 0;\n    this.destroyFns.push(\n      this.title.caption.registerInteraction(this.moduleCtx, \"afterend\"),\n      moduleCtx.layoutManager.addListener(\"layout:complete\", (e) => {\n        if (previousSize != null && jsonDiff(e.chart, previousSize) != null) {\n          this.animationState.transition(\"resize\");\n        }\n        previousSize = { ...e.chart };\n      })\n    );\n  }\n  get type() {\n    return this.constructor.type ?? \"\";\n  }\n  set crossLines(value) {\n    const { CrossLineConstructor } = this.constructor;\n    this._crossLines.forEach((crossLine) => this.detachCrossLine(crossLine));\n    this._crossLines = value.map((crossLine) => {\n      const instance = new CrossLineConstructor();\n      instance.set(crossLine);\n      return instance;\n    });\n    this._crossLines.forEach((crossLine) => {\n      this.attachCrossLine(crossLine);\n      this.initCrossLine(crossLine);\n    });\n  }\n  get crossLines() {\n    return this._crossLines;\n  }\n  resetAnimation(phase) {\n    if (phase === \"initial\") {\n      this.animationState.transition(\"reset\");\n    }\n  }\n  attachCrossLine(crossLine) {\n    this.crossLineGroup.appendChild(crossLine.group);\n    this.crossLineGroup.appendChild(crossLine.labelGroup);\n  }\n  detachCrossLine(crossLine) {\n    this.crossLineGroup.removeChild(crossLine.group);\n    this.crossLineGroup.removeChild(crossLine.labelGroup);\n  }\n  destroy() {\n    this.moduleMap.destroy();\n    this.destroyFns.forEach((f) => f());\n  }\n  updateRange() {\n    const { range: rr, visibleRange: vr, scale: scale2 } = this;\n    const span = (rr[1] - rr[0]) / (vr[1] - vr[0]);\n    const shift = span * vr[0];\n    const start2 = rr[0] - shift;\n    scale2.setVisibleRange?.(vr);\n    scale2.range = [start2, start2 + span];\n    this.crossLines.forEach((crossLine) => {\n      crossLine.clippedRange = [rr[0], rr[1]];\n    });\n  }\n  setCrossLinesVisible(visible) {\n    this.crossLineGroup.visible = visible;\n  }\n  attachAxis(axisNode, gridNode) {\n    gridNode.appendChild(this.gridGroup);\n    axisNode.appendChild(this.axisGroup);\n    axisNode.appendChild(this.crossLineGroup);\n    axisNode.appendChild(this.labelGroup);\n  }\n  attachLabel(axisLabelNode) {\n    this.labelGroup.append(axisLabelNode);\n  }\n  detachAxis(axisNode, gridNode) {\n    gridNode.removeChild(this.gridGroup);\n    axisNode.removeChild(this.axisGroup);\n    axisNode.removeChild(this.crossLineGroup);\n    axisNode.removeChild(this.labelGroup);\n  }\n  /**\n   * Checks if a point or an object is in range.\n   * @param x A point (or object's starting point).\n   * @param tolerance Expands the range on both ends by this amount.\n   */\n  inRange(x, tolerance = 0) {\n    const [min, max] = findMinMax(this.range);\n    return x >= min - tolerance && x <= max + tolerance;\n  }\n  onFormatChange(ticks, fractionDigits, _domain, format) {\n    const { scale: scale2 } = this;\n    const logScale = scale2 instanceof LogScale;\n    const defaultFormatter = (formatOffset) => logScale ? String : (x) => typeof x === \"number\" ? x.toFixed(fractionDigits + formatOffset) : String(x);\n    if (format && scale2 && scale2.tickFormat) {\n      try {\n        const formatter = scale2.tickFormat({ ticks, specifier: format });\n        this.labelFormatter = formatter;\n        this.datumFormatter = formatter;\n      } catch (e) {\n        this.labelFormatter = defaultFormatter(0);\n        this.datumFormatter = defaultFormatter(1);\n        Logger.warnOnce(`the axis label format string ${format} is invalid. No formatting will be applied`);\n      }\n    } else {\n      this.labelFormatter = defaultFormatter(0);\n      this.datumFormatter = defaultFormatter(1);\n    }\n  }\n  onGridLengthChange(value, prevValue) {\n    if (prevValue ^ value) {\n      this.onGridVisibilityChange();\n    }\n    this.crossLines.forEach((crossLine) => this.initCrossLine(crossLine));\n  }\n  onGridVisibilityChange() {\n    this.gridLineGroupSelection.clear();\n  }\n  createLabel() {\n    return new AxisLabel();\n  }\n  /**\n   * Creates/removes/updates the scene graph nodes that constitute the axis.\n   */\n  update(animated = true) {\n    if (!this.tickGenerationResult) {\n      return;\n    }\n    const { rotation, parallelFlipRotation, regularFlipRotation } = this.calculateRotations();\n    const sideFlag = this.label.getSideFlag();\n    this.updatePosition();\n    const lineData = this.getAxisLineCoordinates();\n    const { tickData, combinedRotation, textBaseline, textAlign, primaryTickCount } = this.tickGenerationResult;\n    const previousTicks = this.tickLabelGroupSelection.nodes().map((node) => node.datum.tickId);\n    this.updateSelections(lineData, tickData.ticks, {\n      combinedRotation,\n      textAlign,\n      textBaseline,\n      range: this.scale.range\n    });\n    if (!animated || this.animationManager.isSkipped()) {\n      this.resetSelectionNodes();\n    } else {\n      const diff2 = this.calculateUpdateDiff(previousTicks, tickData);\n      this.animationState.transition(\"update\", diff2);\n    }\n    this.updateAxisLine();\n    this.updateLabels();\n    this.updateVisibility();\n    this.updateGridLines(sideFlag);\n    this.updateTickLines();\n    this.updateTitle({ anyTickVisible: tickData.ticks.length > 0 });\n    this.updateCrossLines({ rotation, parallelFlipRotation, regularFlipRotation });\n    this.updateLayoutState(tickData.fractionDigits);\n    return primaryTickCount;\n  }\n  getAxisLineCoordinates() {\n    const [min, max] = findMinMax(this.range);\n    return { x: 0, y1: min, y2: max };\n  }\n  getTickLineCoordinates(datum) {\n    const sideFlag = this.label.getSideFlag();\n    const x = sideFlag * this.getTickSize();\n    const x1 = Math.min(0, x);\n    const x2 = x1 + Math.abs(x);\n    const y = datum.translationY;\n    return { x1, x2, y };\n  }\n  getTickLabelProps(datum, params) {\n    const { label } = this;\n    const { combinedRotation, textBaseline, textAlign, range: range3 } = params;\n    const text = datum.tickLabel;\n    const sideFlag = label.getSideFlag();\n    const labelX = sideFlag * (this.getTickSize() + label.padding + this.seriesAreaPadding);\n    const visible = text !== \"\" && text != null;\n    return {\n      tickId: datum.tickId,\n      translationY: datum.translationY,\n      fill: label.color,\n      fontFamily: label.fontFamily,\n      fontSize: label.fontSize,\n      fontStyle: label.fontStyle,\n      fontWeight: label.fontWeight,\n      rotation: combinedRotation,\n      rotationCenterX: labelX,\n      text,\n      textAlign,\n      textBaseline,\n      visible,\n      x: labelX,\n      y: 0,\n      range: range3\n    };\n  }\n  getTickSize() {\n    return this.tick.enabled ? this.tick.size : 6;\n  }\n  setTitleProps(caption, params) {\n    const { title } = this;\n    if (!title.enabled) {\n      caption.enabled = false;\n      caption.node.visible = false;\n      return;\n    }\n    caption.color = title.color;\n    caption.fontFamily = title.fontFamily;\n    caption.fontSize = title.fontSize;\n    caption.fontStyle = title.fontStyle;\n    caption.fontWeight = title.fontWeight;\n    caption.enabled = title.enabled;\n    caption.wrapping = title.wrapping;\n    const titleNode = caption.node;\n    const padding = (title.spacing ?? 0) + params.spacing;\n    const sideFlag = this.label.getSideFlag();\n    const parallelFlipRotation = normalizeAngle360(this.rotation);\n    const titleRotationFlag = sideFlag === -1 && parallelFlipRotation > Math.PI && parallelFlipRotation < Math.PI * 2 ? -1 : 1;\n    const rotation = titleRotationFlag * sideFlag * Math.PI / 2;\n    const textBaseline = titleRotationFlag === 1 ? \"bottom\" : \"top\";\n    const { range: range3 } = this;\n    const x = Math.floor(titleRotationFlag * sideFlag * (range3[0] + range3[1]) / 2);\n    const y = sideFlag === -1 ? Math.floor(titleRotationFlag * -padding) : Math.floor(-padding);\n    const { callbackCache } = this.moduleCtx;\n    const { formatter = (p) => p.defaultValue } = title;\n    const text = callbackCache.call(formatter, this.getTitleFormatterParams());\n    caption.text = text;\n    titleNode.setProperties({ visible: true, text, textBaseline, x, y, rotation });\n  }\n  calculateLayout(domain, primaryTickCount) {\n    const { rotation, parallelFlipRotation, regularFlipRotation } = this.calculateRotations();\n    const sideFlag = this.label.getSideFlag();\n    const labelX = sideFlag * (this.getTickSize() + this.label.padding + this.seriesAreaPadding);\n    this.updateScale(domain);\n    this.tickGenerationResult = this.generateTicks({\n      primaryTickCount,\n      parallelFlipRotation,\n      regularFlipRotation,\n      labelX,\n      sideFlag\n    });\n    const { tickData, combinedRotation, textBaseline, textAlign, ...ticksResult } = this.tickGenerationResult;\n    this.updateLayoutState(tickData.fractionDigits);\n    const boxes = [];\n    const { x, y1, y2 } = this.getAxisLineCoordinates();\n    const lineBox = new BBox(\n      x + Math.min(sideFlag * this.seriesAreaPadding, 0),\n      y1,\n      this.seriesAreaPadding,\n      y2 - y1\n    );\n    boxes.push(lineBox);\n    if (this.tick.enabled) {\n      tickData.ticks.forEach((datum) => {\n        const { x1, x2, y } = this.getTickLineCoordinates(datum);\n        const tickLineBox = new BBox(x1, y, x2 - x1, 0);\n        boxes.push(tickLineBox);\n      });\n    }\n    if (this.label.enabled) {\n      const tempText = new TransformableText();\n      tickData.ticks.forEach((datum) => {\n        const labelProps = this.getTickLabelProps(datum, {\n          combinedRotation,\n          textAlign,\n          textBaseline,\n          range: this.scale.range\n        });\n        if (!labelProps.visible) {\n          return;\n        }\n        tempText.setProperties({\n          ...labelProps,\n          translationY: Math.round(datum.translationY)\n        });\n        const box = tempText.getBBox();\n        if (box) {\n          boxes.push(box);\n        }\n      });\n    }\n    if (this.title?.enabled) {\n      const caption = new Caption();\n      const spacing = BBox.merge(boxes).width;\n      this.setTitleProps(caption, { spacing });\n      const titleBox = caption.node.getBBox();\n      if (titleBox) {\n        boxes.push(titleBox);\n      }\n    }\n    const bbox = BBox.merge(boxes);\n    const transformedBBox = this.getTransformBox(bbox);\n    const anySeriesActive = this.isAnySeriesActive();\n    this.crossLines.forEach((crossLine) => {\n      var _a;\n      crossLine.sideFlag = -sideFlag;\n      crossLine.direction = rotation === -Math.PI / 2 ? \"x\" /* X */ : \"y\" /* Y */;\n      if (crossLine instanceof CartesianCrossLine) {\n        (_a = crossLine.label).parallel ?? (_a.parallel = this.label.parallel);\n      }\n      crossLine.parallelFlipRotation = parallelFlipRotation;\n      crossLine.regularFlipRotation = regularFlipRotation;\n      crossLine.calculateLayout?.(anySeriesActive, this.reverse);\n    });\n    return {\n      primaryTickCount: ticksResult.primaryTickCount,\n      bbox: transformedBBox\n    };\n  }\n  updateLayoutState(fractionDigits) {\n    this.layout.label = {\n      fractionDigits,\n      padding: this.label.padding,\n      format: this.label.format\n    };\n  }\n  getTransformBox(bbox) {\n    const matrix = new Matrix();\n    const { rotation, translationX, translationY } = this.getAxisTransform();\n    Matrix.updateTransformMatrix(matrix, 1, 1, rotation, translationX, translationY);\n    return matrix.transformBBox(bbox);\n  }\n  setDomain(domain) {\n    this.dataDomain = this.normaliseDataDomain(domain);\n    if (this.reverse) {\n      this.dataDomain.domain.reverse();\n    }\n    this.scale.domain = this.dataDomain.domain;\n  }\n  updateScale(domain) {\n    if (domain) {\n      this.setDomain(domain);\n    } else {\n      this.calculateDomain();\n    }\n    this.updateRange();\n    this.scale.interval = this.interval.step;\n    if (ContinuousScale.is(this.scale)) {\n      this.scale.nice = this.nice;\n      this.scale.update();\n    }\n  }\n  calculateRotations() {\n    const rotation = toRadians(this.rotation);\n    const parallelFlipRotation = normalizeAngle360(rotation);\n    const regularFlipRotation = normalizeAngle360(rotation - Math.PI / 2);\n    return { rotation, parallelFlipRotation, regularFlipRotation };\n  }\n  generateTicks({\n    primaryTickCount,\n    parallelFlipRotation,\n    regularFlipRotation,\n    labelX,\n    sideFlag\n  }) {\n    const {\n      scale: scale2,\n      interval: { minSpacing, maxSpacing },\n      label: { parallel, rotation, fontFamily, fontSize, fontStyle, fontWeight }\n    } = this;\n    const secondaryAxis = primaryTickCount !== void 0;\n    const { defaultRotation, configuredRotation, parallelFlipFlag, regularFlipFlag } = calculateLabelRotation({\n      rotation,\n      parallel,\n      regularFlipRotation,\n      parallelFlipRotation\n    });\n    const initialRotation = configuredRotation + defaultRotation;\n    const labelMatrix = new Matrix();\n    const { maxTickCount } = this.estimateTickCount({ minSpacing, maxSpacing });\n    const continuous = ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2);\n    const maxIterations = !continuous || isNaN(maxTickCount) ? 10 : maxTickCount;\n    let textAlign = getTextAlign(parallel, configuredRotation, 0, sideFlag, regularFlipFlag);\n    const textBaseline = getTextBaseline(parallel, configuredRotation, sideFlag, parallelFlipFlag);\n    const font = TextUtils.toFontString({ fontFamily, fontSize, fontStyle, fontWeight });\n    const textMeasurer = CachedTextMeasurerPool.getMeasurer({ font });\n    const textProps = {\n      fontFamily,\n      fontSize,\n      fontStyle,\n      fontWeight,\n      textBaseline,\n      textAlign\n    };\n    let tickData = {\n      rawTicks: [],\n      fractionDigits: 0,\n      ticks: [],\n      labelCount: 0\n    };\n    let index = 0;\n    let autoRotation = 0;\n    let labelOverlap = true;\n    let labelData = [];\n    let terminate = false;\n    while (labelOverlap && index <= maxIterations) {\n      if (terminate) {\n        break;\n      }\n      autoRotation = 0;\n      textAlign = getTextAlign(parallel, configuredRotation, 0, sideFlag, regularFlipFlag);\n      const tickStrategies = this.getTickStrategies({ secondaryAxis, index });\n      for (const strategy of tickStrategies) {\n        ({ tickData, index, autoRotation, terminate } = strategy({\n          index,\n          tickData,\n          textProps,\n          labelOverlap,\n          terminate,\n          primaryTickCount\n        }));\n        const rotated = configuredRotation !== 0 || autoRotation !== 0;\n        const labelRotation = initialRotation + autoRotation;\n        const labelSpacing = getLabelSpacing(this.label.minSpacing, rotated);\n        Matrix.updateTransformMatrix(labelMatrix, 1, 1, labelRotation, 0, 0);\n        textAlign = getTextAlign(parallel, configuredRotation, autoRotation, sideFlag, regularFlipFlag);\n        labelData = this.createLabelData(tickData.ticks, labelX, labelMatrix, textMeasurer);\n        labelOverlap = this.label.avoidCollisions ? axisLabelsOverlap(labelData, labelSpacing) : false;\n      }\n    }\n    const combinedRotation = defaultRotation + configuredRotation + autoRotation;\n    if (!secondaryAxis && tickData.rawTicks.length > 0) {\n      primaryTickCount = tickData.rawTicks.length;\n    }\n    return { tickData, primaryTickCount, combinedRotation, textBaseline, textAlign, labelData };\n  }\n  getTickStrategies({\n    index: iteration,\n    secondaryAxis\n  }) {\n    const { scale: scale2, label } = this;\n    const { minSpacing } = this.interval;\n    const continuous = ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2);\n    const avoidLabelCollisions = label.enabled && label.avoidCollisions;\n    const filterTicks = !continuous && iteration !== 0 && avoidLabelCollisions;\n    const autoRotate = label.autoRotate === true && label.rotation === void 0;\n    const strategies = [];\n    let tickGenerationType;\n    if (this.interval.values) {\n      tickGenerationType = 3 /* VALUES */;\n    } else if (secondaryAxis) {\n      tickGenerationType = 1 /* CREATE_SECONDARY */;\n    } else if (filterTicks) {\n      tickGenerationType = 2 /* FILTER */;\n    } else {\n      tickGenerationType = 0 /* CREATE */;\n    }\n    const tickGenerationStrategy = ({ index, tickData, primaryTickCount, terminate }) => this.createTickData(tickGenerationType, index, tickData, terminate, primaryTickCount);\n    strategies.push(tickGenerationStrategy);\n    if (!continuous && !isNaN(minSpacing)) {\n      const tickFilterStrategy = ({ index, tickData, primaryTickCount, terminate }) => this.createTickData(2 /* FILTER */, index, tickData, terminate, primaryTickCount);\n      strategies.push(tickFilterStrategy);\n    }\n    if (!avoidLabelCollisions) {\n      return strategies;\n    }\n    if (autoRotate) {\n      const autoRotateStrategy = ({ index, tickData, labelOverlap, terminate }) => ({\n        index,\n        tickData,\n        autoRotation: this.getAutoRotation(labelOverlap),\n        terminate\n      });\n      strategies.push(autoRotateStrategy);\n    }\n    return strategies;\n  }\n  createTickData(tickGenerationType, index, tickData, terminate, primaryTickCount) {\n    const { scale: scale2 } = this;\n    const { step, values, minSpacing, maxSpacing } = this.interval;\n    const { maxTickCount, minTickCount, defaultTickCount } = this.estimateTickCount({ minSpacing, maxSpacing });\n    const continuous = ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2);\n    const maxIterations = !continuous || isNaN(maxTickCount) ? 10 : maxTickCount;\n    let tickCount = continuous ? Math.max(defaultTickCount - index, minTickCount) : maxTickCount;\n    const regenerateTicks = step === void 0 && values === void 0 && tickCount > minTickCount && (continuous || tickGenerationType === 2 /* FILTER */);\n    let unchanged = true;\n    while (unchanged && index <= maxIterations) {\n      const prevTicks = tickData.rawTicks;\n      tickCount = continuous ? Math.max(defaultTickCount - index, minTickCount) : maxTickCount;\n      const { rawTicks, fractionDigits, ticks, labelCount } = this.getTicks({\n        tickGenerationType,\n        previousTicks: prevTicks,\n        tickCount,\n        minTickCount,\n        maxTickCount,\n        primaryTickCount\n      });\n      tickData.rawTicks = rawTicks;\n      tickData.fractionDigits = fractionDigits;\n      tickData.ticks = ticks;\n      tickData.labelCount = labelCount;\n      unchanged = regenerateTicks ? areArrayNumbersEqual(rawTicks, prevTicks) : false;\n      index++;\n    }\n    const shouldTerminate = step !== void 0 || values !== void 0;\n    terminate || (terminate = shouldTerminate);\n    return { tickData, index, autoRotation: 0, terminate };\n  }\n  createLabelData(tickData, labelX, labelMatrix, textMeasurer) {\n    const labelData = [];\n    for (const { tickLabel, translationY } of tickData) {\n      if (!tickLabel)\n        continue;\n      const { width: width2, height: height2 } = textMeasurer.measureLines(tickLabel);\n      const bbox = new BBox(labelX, translationY, width2, height2);\n      const labelDatum = calculateLabelBBox(tickLabel, bbox, labelMatrix);\n      labelData.push(labelDatum);\n    }\n    return labelData;\n  }\n  getAutoRotation(labelOverlap) {\n    return labelOverlap ? normalizeAngle360(toRadians(this.label.autoRotateAngle ?? 0)) : 0;\n  }\n  getTicks({\n    tickGenerationType,\n    previousTicks,\n    tickCount,\n    minTickCount,\n    maxTickCount,\n    primaryTickCount\n  }) {\n    const { range: range3, scale: scale2, visibleRange } = this;\n    let rawTicks;\n    switch (tickGenerationType) {\n      case 3 /* VALUES */:\n        rawTicks = this.interval.values;\n        if (ContinuousScale.is(scale2)) {\n          const [d0, d1] = findMinMax(scale2.getDomain().map(Number));\n          rawTicks = rawTicks.filter((value) => value >= d0 && value <= d1).sort((a, b) => a - b);\n        }\n        break;\n      case 1 /* CREATE_SECONDARY */:\n        if (ContinuousScale.is(scale2)) {\n          rawTicks = this.updateSecondaryAxisTicks(primaryTickCount);\n        } else {\n          rawTicks = this.createTicks(tickCount, minTickCount, maxTickCount);\n        }\n        break;\n      case 2 /* FILTER */:\n        rawTicks = this.filterTicks(previousTicks, tickCount);\n        break;\n      default:\n        rawTicks = this.createTicks(tickCount, minTickCount, maxTickCount);\n        break;\n    }\n    const fractionDigits = rawTicks.reduce(\n      (max, tick) => Math.max(max, typeof tick === \"number\" ? countFractionDigits(tick) : 0),\n      0\n    );\n    const halfBandwidth = (scale2.bandwidth ?? 0) / 2;\n    const ticks = [];\n    let labelCount = 0;\n    const tickIdCounts = /* @__PURE__ */ new Map();\n    const start2 = Math.max(0, Math.floor(visibleRange[0] * rawTicks.length));\n    const end2 = Math.min(rawTicks.length, Math.ceil(visibleRange[1] * rawTicks.length));\n    const filteredTicks = rawTicks.slice(start2, end2);\n    this.onFormatChange(filteredTicks, fractionDigits, rawTicks, this.label.format);\n    for (let i = 0; i < filteredTicks.length; i++) {\n      const tick = filteredTicks[i];\n      const translationY = scale2.convert(tick) + halfBandwidth;\n      if (range3.length > 0 && !this.inRange(translationY, 1e-3))\n        continue;\n      const tickLabel = this.formatTick(tick, fractionDigits, start2 + i);\n      let tickId = tickLabel;\n      if (tickIdCounts.has(tickId)) {\n        const count = tickIdCounts.get(tickId);\n        tickIdCounts.set(tickId, count + 1);\n        tickId = `${tickId}_${count}`;\n      } else {\n        tickIdCounts.set(tickId, 1);\n      }\n      ticks.push({ tick, tickId, tickLabel, translationY: Math.floor(translationY) });\n      if (tickLabel === \"\" || tickLabel == null) {\n        continue;\n      }\n      labelCount++;\n    }\n    return { rawTicks, fractionDigits, ticks, labelCount };\n  }\n  filterTicks(ticks, tickCount) {\n    const { minSpacing, maxSpacing } = this.interval;\n    const tickSpacing = !isNaN(minSpacing) || !isNaN(maxSpacing);\n    const keepEvery = tickSpacing ? Math.ceil(ticks.length / tickCount) : 2;\n    return ticks.filter((_, i) => i % keepEvery === 0);\n  }\n  createTicks(tickCount, minTickCount, maxTickCount) {\n    const { scale: scale2 } = this;\n    if (tickCount && (ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2))) {\n      scale2.tickCount = tickCount;\n      scale2.minTickCount = minTickCount ?? 0;\n      scale2.maxTickCount = maxTickCount ?? Infinity;\n    }\n    return scale2.ticks?.() ?? [];\n  }\n  estimateTickCount({ minSpacing, maxSpacing }) {\n    if (!this.label.avoidCollisions) {\n      return {\n        minTickCount: ContinuousScale.defaultMaxTickCount,\n        maxTickCount: ContinuousScale.defaultMaxTickCount,\n        defaultTickCount: ContinuousScale.defaultMaxTickCount\n      };\n    }\n    const rangeWithBleed = this.calculateRangeWithBleed();\n    const defaultMinSpacing = Math.max(\n      this.defaultTickMinSpacing,\n      rangeWithBleed / ContinuousScale.defaultMaxTickCount\n    );\n    let clampMaxTickCount = !isNaN(maxSpacing);\n    if (isNaN(minSpacing)) {\n      minSpacing = defaultMinSpacing;\n    }\n    if (isNaN(maxSpacing)) {\n      maxSpacing = rangeWithBleed;\n    }\n    if (minSpacing > maxSpacing) {\n      if (minSpacing === defaultMinSpacing) {\n        minSpacing = maxSpacing;\n      } else {\n        maxSpacing = minSpacing;\n      }\n    }\n    const minRectDistance = 2;\n    clampMaxTickCount && (clampMaxTickCount = minRectDistance < defaultMinSpacing);\n    const maxTickCount = clamp(\n      1,\n      Math.floor(rangeWithBleed / minSpacing),\n      clampMaxTickCount ? Math.min(Math.floor(rangeWithBleed / minRectDistance), 100) : 100\n    );\n    const minTickCount = Math.min(maxTickCount, Math.ceil(rangeWithBleed / maxSpacing));\n    const defaultTickCount = clamp(minTickCount, ContinuousScale.defaultTickCount, maxTickCount);\n    return { minTickCount, maxTickCount, defaultTickCount };\n  }\n  updateVisibility() {\n    if (this.moduleCtx.animationManager.isSkipped()) {\n      this.resetSelectionNodes();\n    }\n    this.tickLineGroup.visible = this.tick.enabled;\n    this.gridLineGroup.visible = this.gridLine.enabled;\n    this.tickLabelGroup.visible = this.label.enabled;\n  }\n  updateCrossLines({\n    rotation,\n    parallelFlipRotation,\n    regularFlipRotation\n  }) {\n    const sideFlag = this.label.getSideFlag();\n    const anySeriesActive = this.isAnySeriesActive();\n    this.crossLines.forEach((crossLine) => {\n      var _a;\n      crossLine.sideFlag = -sideFlag;\n      crossLine.direction = rotation === -Math.PI / 2 ? \"x\" /* X */ : \"y\" /* Y */;\n      if (crossLine instanceof CartesianCrossLine) {\n        (_a = crossLine.label).parallel ?? (_a.parallel = this.label.parallel);\n      }\n      crossLine.parallelFlipRotation = parallelFlipRotation;\n      crossLine.regularFlipRotation = regularFlipRotation;\n      crossLine.update(anySeriesActive);\n    });\n  }\n  updateTickLines() {\n    const { tick, label } = this;\n    const sideFlag = label.getSideFlag();\n    this.tickLineGroupSelection.each((line) => {\n      line.strokeWidth = tick.width;\n      line.stroke = tick.stroke;\n      line.x1 = sideFlag * this.getTickSize();\n      line.x2 = 0;\n    });\n  }\n  calculateAvailableRange() {\n    return findRangeExtent(this.range);\n  }\n  /**\n   * Calculates the available range with an additional \"bleed\" beyond the canvas that encompasses the full axis when\n   * the visible range is only a portion of the axis.\n   */\n  calculateRangeWithBleed() {\n    const visibleScale = 1 / findRangeExtent(this.visibleRange);\n    return round(this.calculateAvailableRange() * visibleScale, 2);\n  }\n  calculateDomain() {\n    const visibleSeries = this.boundSeries.filter((s) => this.includeInvisibleDomains || s.isEnabled());\n    const domains = visibleSeries.flatMap((series) => series.getDomain(this.direction));\n    this.setDomain(domains);\n  }\n  getAxisTransform() {\n    return {\n      rotation: toRadians(this.rotation),\n      translationX: Math.floor(this.translation.x),\n      translationY: Math.floor(this.translation.y)\n    };\n  }\n  updatePosition() {\n    const { crossLineGroup, axisGroup, gridGroup, translation } = this;\n    const { rotation } = this.calculateRotations();\n    const translationX = Math.floor(translation.x);\n    const translationY = Math.floor(translation.y);\n    crossLineGroup.setProperties({ rotation, translationX, translationY });\n    gridGroup.setProperties({ rotation, translationX, translationY });\n    axisGroup.datum = this.getAxisTransform();\n  }\n  updateSecondaryAxisTicks(_primaryTickCount) {\n    throw new Error(\"AG Charts - unexpected call to updateSecondaryAxisTicks() - check axes configuration.\");\n  }\n  updateSelections(lineData, data, params) {\n    const getDatumId = (datum) => datum.tickId;\n    const labelsData = data.map((d) => this.getTickLabelProps(d, params));\n    this.lineNode.datum = lineData;\n    this.gridLineGroupSelection.update(this.gridLength ? data : [], void 0, getDatumId);\n    this.tickLineGroupSelection.update(data, void 0, getDatumId);\n    this.tickLabelGroupSelection.update(labelsData, void 0, getDatumId);\n  }\n  updateAxisLine() {\n    const { enabled, stroke, width: width2 } = this.line;\n    this.lineNode.setProperties({ stroke, strokeWidth: enabled ? width2 : 0 });\n  }\n  updateGridLines(sideFlag) {\n    const {\n      gridLine: { style, width: width2 },\n      gridPadding,\n      gridLength\n    } = this;\n    if (gridLength === 0 || style.length === 0) {\n      return;\n    }\n    this.gridLineGroupSelection.each((line, _, index) => {\n      const { stroke, lineDash } = style[index % style.length];\n      line.setProperties({\n        x1: gridPadding,\n        x2: -sideFlag * gridLength + gridPadding,\n        stroke,\n        strokeWidth: width2,\n        lineDash\n      });\n    });\n  }\n  updateLabels() {\n    if (!this.label.enabled)\n      return;\n    this.tickLabelGroupSelection.each((node, datum) => {\n      node.setProperties(datum, [\n        \"fill\",\n        \"fontFamily\",\n        \"fontSize\",\n        \"fontStyle\",\n        \"fontWeight\",\n        \"text\",\n        \"textAlign\",\n        \"textBaseline\"\n      ]);\n    });\n  }\n  updateTitle(params) {\n    const { title, lineNode, tickLineGroup, tickLabelGroup } = this;\n    let spacing = 0;\n    if (title.enabled && params.anyTickVisible) {\n      const tickBBox = Group.computeChildrenBBox([tickLineGroup, tickLabelGroup, lineNode]);\n      spacing += tickBBox.width + (this.tickLabelGroup.visible ? 0 : this.seriesAreaPadding);\n    }\n    this.setTitleProps(title.caption, { spacing });\n  }\n  // For formatting (nice rounded) tick values.\n  formatTick(datum, fractionDigits, index) {\n    return String(this.getFormatter(index, true)(datum, fractionDigits));\n  }\n  // For formatting arbitrary values between the ticks.\n  formatDatum(datum) {\n    return String(this.getFormatter()(datum));\n  }\n  getFormatter(index = 0, isTickLabel) {\n    const {\n      label,\n      labelFormatter,\n      datumFormatter,\n      moduleCtx: { callbackCache }\n    } = this;\n    if (label.formatter) {\n      return (datum, fractionDigits) => callbackCache.call(label.formatter, { value: datum, index, fractionDigits }) ?? datum;\n    } else if (!isTickLabel && datumFormatter) {\n      return (datum) => callbackCache.call(datumFormatter, datum) ?? String(datum);\n    } else if (labelFormatter) {\n      return (datum) => callbackCache.call(labelFormatter, datum) ?? String(datum);\n    }\n    return (datum) => String(datum);\n  }\n  getBBox() {\n    return this.axisGroup.getBBox();\n  }\n  getRegionNode() {\n    return void 0;\n  }\n  initCrossLine(crossLine) {\n    crossLine.scale = this.scale;\n    crossLine.gridLength = this.gridLength;\n  }\n  isAnySeriesActive() {\n    return this.boundSeries.some((s) => this.includeInvisibleDomains || s.isEnabled());\n  }\n  clipTickLines(x, y, width2, height2) {\n    this.tickLineGroup.setClipRect(new BBox(x, y, width2, height2));\n  }\n  clipGrid(x, y, width2, height2) {\n    this.gridGroup.setClipRect(new BBox(x, y, width2, height2));\n  }\n  getTitleFormatterParams() {\n    const { direction } = this;\n    const boundSeries = [];\n    for (const series of this.boundSeries) {\n      const keys = series.getKeys(direction);\n      const names = series.getNames(direction);\n      for (let idx = 0; idx < keys.length; idx++) {\n        boundSeries.push({ key: keys[idx], name: names[idx] });\n      }\n    }\n    return { direction, boundSeries, defaultValue: this.title?.text };\n  }\n  normaliseDataDomain(d) {\n    return { domain: [...d], clipped: false };\n  }\n  getLayoutState() {\n    return {\n      id: this.id,\n      rect: this.getBBox(),\n      gridPadding: this.gridPadding,\n      seriesAreaPadding: this.seriesAreaPadding,\n      tickSize: this.getTickSize(),\n      direction: this.direction,\n      domain: this.dataDomain.domain,\n      scale: this.scale,\n      ...this.layout\n    };\n  }\n  getModuleMap() {\n    return this.moduleMap;\n  }\n  createModuleContext() {\n    this.axisContext ?? (this.axisContext = this.createAxisContext());\n    return { ...this.moduleCtx, parent: this.axisContext };\n  }\n  createAxisContext() {\n    const { scale: scale2 } = this;\n    return {\n      axisId: this.id,\n      scale: this.scale,\n      direction: this.direction,\n      continuous: ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2),\n      keys: () => this.boundSeries.flatMap((s) => s.getKeys(this.direction)),\n      seriesKeyProperties: () => this.boundSeries.reduce((keys, series) => {\n        const seriesKeys = series.getKeyProperties(this.direction);\n        seriesKeys.forEach((key) => {\n          if (keys.indexOf(key) < 0) {\n            keys.push(key);\n          }\n        });\n        return keys;\n      }, []),\n      scaleValueFormatter: (specifier) => this.getScaleValueFormatter(specifier),\n      scaleBandwidth: () => scale2.bandwidth ?? 0,\n      scaleDomain: () => scale2.getDomain?.(),\n      scaleConvert: (val) => scale2.convert(val),\n      scaleInvert: OrdinalTimeScale.is(scale2) ? (val) => scale2.invertNearest?.(val) : (val) => scale2.invert?.(val),\n      scaleInvertNearest: (val) => scale2.invertNearest?.(val),\n      scaleStep: () => scale2.step ?? 0,\n      attachLabel: (node) => this.attachLabel(node),\n      inRange: (x, tolerance) => this.inRange(x, tolerance)\n    };\n  }\n  getScaleValueFormatter(format) {\n    const { scale: scale2 } = this;\n    if (format && scale2 && scale2.tickFormat) {\n      try {\n        return scale2.tickFormat({ specifier: format });\n      } catch (e) {\n        Logger.warnOnce(`the format string ${format} is invalid, ignoring.`);\n      }\n    }\n    return this.getFormatter();\n  }\n  animateReadyUpdate(diff2) {\n    const { animationManager } = this.moduleCtx;\n    const selectionCtx = prepareAxisAnimationContext(this);\n    const fns = prepareAxisAnimationFunctions(selectionCtx);\n    fromToMotion(this.id, \"axis-group\", animationManager, [this.axisGroup], fns.group);\n    fromToMotion(this.id, \"line\", animationManager, [this.lineNode], fns.line);\n    fromToMotion(\n      this.id,\n      \"line-paths\",\n      animationManager,\n      [this.gridLineGroupSelection, this.tickLineGroupSelection],\n      fns.tick,\n      (_, d) => d.tickId,\n      diff2\n    );\n    fromToMotion(\n      this.id,\n      \"tick-labels\",\n      animationManager,\n      [this.tickLabelGroupSelection],\n      fns.label,\n      (_, d) => d.tickId,\n      diff2\n    );\n  }\n  resetSelectionNodes() {\n    const { gridLineGroupSelection, tickLineGroupSelection, tickLabelGroupSelection, lineNode } = this;\n    const selectionCtx = prepareAxisAnimationContext(this);\n    resetMotion([this.axisGroup], resetAxisGroupFn());\n    resetMotion([gridLineGroupSelection, tickLineGroupSelection], resetAxisSelectionFn(selectionCtx));\n    resetMotion([tickLabelGroupSelection], resetAxisLabelSelectionFn());\n    resetMotion([lineNode], resetAxisLineSelectionFn());\n  }\n  calculateUpdateDiff(previous, tickData) {\n    const added = /* @__PURE__ */ new Set();\n    const removed = /* @__PURE__ */ new Set();\n    const tickMap = {};\n    const tickCount = Math.max(previous.length, tickData.ticks.length);\n    for (let i = 0; i < tickCount; i++) {\n      const tickDatum = tickData.ticks[i];\n      const prev = previous[i];\n      const tick = tickDatum?.tickId;\n      tickMap[tick ?? prev] = tickDatum;\n      if (prev === tick) {\n        continue;\n      }\n      if (removed.has(tick)) {\n        removed.delete(tick);\n      } else if (tick) {\n        added.add(tick);\n      }\n      if (added.has(prev)) {\n        added.delete(prev);\n      } else if (prev) {\n        removed.add(prev);\n      }\n    }\n    return { changed: added.size > 0 || removed.size > 0, added, removed };\n  }\n  isReversed() {\n    return this.reverse;\n  }\n};\n_Axis.defaultTickMinSpacing = 50;\n_Axis.CrossLineConstructor = CartesianCrossLine;\n__decorateClass([\n  Validate(BOOLEAN)\n], _Axis.prototype, \"nice\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], _Axis.prototype, \"reverse\", 2);\n__decorateClass([\n  Validate(STRING_ARRAY)\n], _Axis.prototype, \"keys\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], _Axis.prototype, \"interval\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], _Axis.prototype, \"title\", 2);\n__decorateClass([\n  ObserveChanges((target, value, oldValue) => target.onGridLengthChange(value, oldValue))\n], _Axis.prototype, \"gridLength\", 2);\nvar Axis = _Axis;\n\n// packages/ag-charts-community/src/chart/axis/cartesianAxisLabel.ts\nvar CartesianAxisLabel = class extends AxisLabel {\n  constructor() {\n    super(...arguments);\n    this.autoRotateAngle = 335;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], CartesianAxisLabel.prototype, \"autoRotate\", 2);\n__decorateClass([\n  Validate(DEGREE)\n], CartesianAxisLabel.prototype, \"autoRotateAngle\", 2);\n\n// packages/ag-charts-community/src/chart/axis/cartesianAxis.ts\nvar _CartesianAxis = class _CartesianAxis extends Axis {\n  constructor() {\n    super(...arguments);\n    this.thickness = 0;\n  }\n  static is(value) {\n    return value instanceof _CartesianAxis;\n  }\n  get direction() {\n    return this.position === \"top\" || this.position === \"bottom\" ? \"x\" /* X */ : \"y\" /* Y */;\n  }\n  updateDirection() {\n    switch (this.position) {\n      case \"top\":\n        this.rotation = -90;\n        this.label.mirrored = true;\n        this.label.parallel = true;\n        break;\n      case \"right\":\n        this.rotation = 0;\n        this.label.mirrored = true;\n        this.label.parallel = false;\n        break;\n      case \"bottom\":\n        this.rotation = -90;\n        this.label.mirrored = false;\n        this.label.parallel = true;\n        break;\n      case \"left\":\n        this.rotation = 0;\n        this.label.mirrored = false;\n        this.label.parallel = false;\n        break;\n    }\n    if (this.axisContext) {\n      this.axisContext.position = this.position;\n      this.axisContext.direction = this.direction;\n    }\n  }\n  update(animated) {\n    this.updateDirection();\n    return super.update(animated);\n  }\n  calculateLayout(domain, primaryTickCount) {\n    this.updateDirection();\n    return super.calculateLayout(domain, primaryTickCount);\n  }\n  createAxisContext() {\n    return { ...super.createAxisContext(), position: this.position };\n  }\n  createLabel() {\n    return new CartesianAxisLabel();\n  }\n  getRegionNode() {\n    return this.axisGroup;\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], _CartesianAxis.prototype, \"thickness\", 2);\n__decorateClass([\n  Validate(POSITION)\n], _CartesianAxis.prototype, \"position\", 2);\nvar CartesianAxis = _CartesianAxis;\n\n// packages/ag-charts-community/src/chart/axis/categoryAxis.ts\nvar _CategoryAxis = class _CategoryAxis extends CartesianAxis {\n  constructor(moduleCtx, scale2 = new BandScale()) {\n    super(moduleCtx, scale2);\n    this.groupPaddingInner = 0.1;\n    this.includeInvisibleDomains = true;\n  }\n  static is(value) {\n    return value instanceof _CategoryAxis;\n  }\n  normaliseDataDomain(d) {\n    const domain = [];\n    const uniqueValues = /* @__PURE__ */ new Set();\n    for (const v of d) {\n      const key = v instanceof Date ? v.getTime() : v;\n      if (!uniqueValues.has(key)) {\n        uniqueValues.add(key);\n        domain.push(v);\n      }\n    }\n    return { domain, clipped: false };\n  }\n  updateScale(domain) {\n    let { paddingInner, paddingOuter } = this;\n    if (!isFiniteNumber(paddingInner) || !isFiniteNumber(paddingOuter)) {\n      const padding = this.reduceBandScalePadding();\n      paddingInner ?? (paddingInner = padding.inner);\n      paddingOuter ?? (paddingOuter = padding.outer);\n    }\n    this.scale.paddingInner = paddingInner ?? 0;\n    this.scale.paddingOuter = paddingOuter ?? 0;\n    super.updateScale(domain);\n  }\n  reduceBandScalePadding() {\n    return this.boundSeries.reduce(\n      (result, series) => {\n        const padding = series.getBandScalePadding?.();\n        if (padding) {\n          if (result.inner > padding.inner) {\n            result.inner = padding.inner;\n          }\n          if (result.outer < padding.outer) {\n            result.outer = padding.outer;\n          }\n        }\n        return result;\n      },\n      { inner: Infinity, outer: -Infinity }\n    );\n  }\n};\n_CategoryAxis.className = \"CategoryAxis\";\n_CategoryAxis.type = \"category\";\n__decorateClass([\n  Validate(RATIO)\n], _CategoryAxis.prototype, \"groupPaddingInner\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], _CategoryAxis.prototype, \"paddingInner\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], _CategoryAxis.prototype, \"paddingOuter\", 2);\nvar CategoryAxis = _CategoryAxis;\n\n// packages/ag-charts-community/src/chart/axis/tree.ts\nvar TreeNode = class {\n  // current number in sibling group (index)\n  constructor(label = \"\", parent, number2 = 0) {\n    this.x = 0;\n    this.y = 0;\n    this.subtreeLeft = NaN;\n    this.subtreeRight = NaN;\n    this.screenX = 0;\n    this.screenY = 0;\n    this.children = [];\n    this.leafCount = 0;\n    this.prelim = 0;\n    this.mod = 0;\n    this.ancestor = this;\n    this.change = 0;\n    this.shift = 0;\n    this.label = label;\n    this.parent = parent;\n    this.depth = parent ? parent.depth + 1 : 0;\n    this.number = number2;\n  }\n  getLeftSibling() {\n    return this.number > 0 && this.parent ? this.parent.children[this.number - 1] : void 0;\n  }\n  getLeftmostSibling() {\n    return this.number > 0 && this.parent ? this.parent.children[0] : void 0;\n  }\n  // traverse the left contour of a subtree, return the successor of v on this contour\n  nextLeft() {\n    return this.children ? this.children[0] : this.thread;\n  }\n  // traverse the right contour of a subtree, return the successor of v on this contour\n  nextRight() {\n    return this.children ? this.children[this.children.length - 1] : this.thread;\n  }\n  getSiblings() {\n    return this.parent ? this.parent.children.filter((_, i) => i !== this.number) : [];\n  }\n};\nfunction ticksToTree(ticks, pad2 = true) {\n  const root = new TreeNode();\n  let depth = 0;\n  if (pad2) {\n    ticks.forEach((tick) => depth = Math.max(depth, tick.labels.length));\n  }\n  ticks.forEach((tick) => {\n    if (pad2) {\n      while (tick.labels.length < depth) {\n        tick.labels.unshift(\"\");\n      }\n    }\n    insertTick(root, tick);\n  });\n  return root;\n}\nfunction insertTick(root, tick) {\n  const pathParts = tick.labels.slice().reverse();\n  const lastPartIndex = pathParts.length - 1;\n  pathParts.forEach((pathPart, partIndex) => {\n    const children = root.children;\n    const existingNode = children.find((child) => child.label === pathPart);\n    const isNotLeaf = partIndex !== lastPartIndex;\n    if (existingNode && isNotLeaf) {\n      root = existingNode;\n    } else {\n      const node = new TreeNode(pathPart, root);\n      node.number = children.length;\n      children.push(node);\n      if (isNotLeaf) {\n        root = node;\n      }\n    }\n  });\n}\nfunction moveSubtree(wm, wp, shift) {\n  const subtrees = wp.number - wm.number;\n  const ratio2 = shift / subtrees;\n  wp.change -= ratio2;\n  wp.shift += shift;\n  wm.change += ratio2;\n  wp.prelim += shift;\n  wp.mod += shift;\n}\nfunction ancestor(vim, v, defaultAncestor) {\n  return v.getSiblings().indexOf(vim.ancestor) >= 0 ? vim.ancestor : defaultAncestor;\n}\nfunction executeShifts(v) {\n  const children = v.children;\n  if (children) {\n    let shift = 0;\n    let change = 0;\n    for (let i = children.length - 1; i >= 0; i--) {\n      const w = children[i];\n      w.prelim += shift;\n      w.mod += shift;\n      change += w.change;\n      shift += w.shift + change;\n    }\n  }\n}\nfunction apportion(v, defaultAncestor, distance3) {\n  const w = v.getLeftSibling();\n  if (w) {\n    let vop = v;\n    let vip = v;\n    let vim = w;\n    let vom = vip.getLeftmostSibling();\n    let sip = vip.mod;\n    let sop = vop.mod;\n    let sim = vim.mod;\n    let som = vom.mod;\n    while (vim.nextRight() && vip.nextLeft()) {\n      vim = vim.nextRight();\n      vip = vip.nextLeft();\n      vom = vom.nextLeft();\n      vop = vop.nextRight();\n      vop.ancestor = v;\n      const shift = vim.prelim + sim - (vip.prelim + sip) + distance3;\n      if (shift > 0) {\n        moveSubtree(ancestor(vim, v, defaultAncestor), v, shift);\n        sip += shift;\n        sop += shift;\n      }\n      sim += vim.mod;\n      sip += vip.mod;\n      som += vom.mod;\n      sop += vop.mod;\n    }\n    if (vim.nextRight() && !vop.nextRight()) {\n      vop.thread = vim.nextRight();\n      vop.mod += sim - sop;\n    } else {\n      if (vip.nextLeft() && !vom.nextLeft()) {\n        vom.thread = vip.nextLeft();\n        vom.mod += sip - som;\n      }\n      defaultAncestor = v;\n    }\n  }\n  return defaultAncestor;\n}\nfunction firstWalk(node, distance3) {\n  const children = node.children;\n  if (children.length) {\n    let defaultAncestor = children[0];\n    children.forEach((child) => {\n      firstWalk(child, distance3);\n      defaultAncestor = apportion(child, defaultAncestor, distance3);\n    });\n    executeShifts(node);\n    const midpoint = (children[0].prelim + children.at(-1).prelim) / 2;\n    const leftSibling = node.getLeftSibling();\n    if (leftSibling) {\n      node.prelim = leftSibling.prelim + distance3;\n      node.mod = node.prelim - midpoint;\n    } else {\n      node.prelim = midpoint;\n    }\n  } else {\n    const leftSibling = node.getLeftSibling();\n    node.prelim = leftSibling ? leftSibling.prelim + distance3 : 0;\n  }\n}\nvar Dimensions = class {\n  constructor() {\n    this.top = Infinity;\n    this.right = -Infinity;\n    this.bottom = -Infinity;\n    this.left = Infinity;\n  }\n  update(node, xy) {\n    const { x, y } = xy(node);\n    if (x > this.right) {\n      this.right = x;\n    }\n    if (x < this.left) {\n      this.left = x;\n    }\n    if (y > this.bottom) {\n      this.bottom = y;\n    }\n    if (y < this.top) {\n      this.top = y;\n    }\n  }\n};\nfunction secondWalk(v, m, layout) {\n  v.x = v.prelim + m;\n  v.y = v.depth;\n  layout.update(v);\n  v.children.forEach((w) => secondWalk(w, m + v.mod, layout));\n}\nfunction thirdWalk(v) {\n  const children = v.children;\n  let leafCount = 0;\n  children.forEach((w) => {\n    thirdWalk(w);\n    if (w.children.length) {\n      leafCount += w.leafCount;\n    } else {\n      leafCount++;\n    }\n  });\n  v.leafCount = leafCount;\n  if (children.length) {\n    v.subtreeLeft = children[0].subtreeLeft;\n    v.subtreeRight = children[v.children.length - 1].subtreeRight;\n    v.x = (v.subtreeLeft + v.subtreeRight) / 2;\n  } else {\n    v.subtreeLeft = v.x;\n    v.subtreeRight = v.x;\n  }\n}\nfunction treeLayout(root) {\n  const layout = new TreeLayout();\n  firstWalk(root, 1);\n  secondWalk(root, -root.prelim, layout);\n  thirdWalk(root);\n  return layout;\n}\nvar TreeLayout = class {\n  constructor() {\n    this.dimensions = new Dimensions();\n    this.leafCount = 0;\n    this.nodes = [];\n    // One might want to process leaf nodes separately from the rest of the tree.\n    // For example, position labels corresponding to leafs vertically, rather than horizontally.\n    this.leafNodes = [];\n    this.nonLeafNodes = [];\n    this.depth = 0;\n  }\n  update(node) {\n    this.dimensions.update(node, (n) => ({ x: n.x, y: n.y }));\n    if (node.children.length) {\n      this.nonLeafNodes.push(node);\n    } else {\n      this.leafCount++;\n      this.leafNodes.push(node);\n    }\n    if (node.depth > this.depth) {\n      this.depth = node.depth;\n    }\n    this.nodes.push(node);\n  }\n  resize(width2, height2, shiftX = 0, shiftY = 0, flipX = false) {\n    const xSteps = this.leafCount - 1;\n    const ySteps = this.depth;\n    const dimensions = this.dimensions;\n    let scalingX = 1;\n    let scalingY = 1;\n    if (width2 > 0 && xSteps) {\n      const existingSpacingX = (dimensions.right - dimensions.left) / xSteps;\n      const desiredSpacingX = width2 / xSteps;\n      scalingX = desiredSpacingX / existingSpacingX;\n      if (flipX) {\n        scalingX = -scalingX;\n      }\n    }\n    if (height2 > 0 && ySteps) {\n      const existingSpacingY = (dimensions.bottom - dimensions.top) / ySteps;\n      const desiredSpacingY = height2 / ySteps;\n      scalingY = desiredSpacingY / existingSpacingY;\n    }\n    const screenDimensions = new Dimensions();\n    this.nodes.forEach((node) => {\n      node.screenX = node.x * scalingX;\n      node.screenY = node.y * scalingY;\n      screenDimensions.update(node, (n) => ({ x: n.screenX, y: n.screenY }));\n    });\n    const offsetX = -screenDimensions.left;\n    const offsetY = -screenDimensions.top;\n    this.nodes.forEach((node) => {\n      node.screenX += offsetX + shiftX;\n      node.screenY += offsetY + shiftY;\n    });\n  }\n};\n\n// packages/ag-charts-community/src/chart/axis/groupedCategoryAxis.ts\nvar GroupedCategoryAxisLabel = class extends AxisLabel {\n  constructor() {\n    super(...arguments);\n    this.grid = false;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], GroupedCategoryAxisLabel.prototype, \"grid\", 2);\nvar GroupedCategoryAxis = class extends CartesianAxis {\n  constructor(moduleCtx) {\n    const scale2 = new BandScale();\n    scale2.paddingOuter = 0.1;\n    scale2.paddingInner = scale2.paddingOuter * 2;\n    super(moduleCtx, scale2);\n    // Label scale (labels are positioned between ticks, tick count = label count + 1).\n    // We don't call is `labelScale` for consistency with other axes.\n    this.tickScale = new BandScale();\n    this.line = new AxisLine();\n    this.label = new GroupedCategoryAxisLabel();\n    this.labelColor = \"rgba(87, 87, 87, 1)\";\n    this.includeInvisibleDomains = true;\n    const { tickLineGroup, tickLabelGroup, gridLineGroup, tickScale } = this;\n    tickScale.paddingInner = 1;\n    tickScale.paddingOuter = 0;\n    this.gridLineSelection = Selection.select(gridLineGroup, Line);\n    this.axisLineSelection = Selection.select(tickLineGroup, Line);\n    this.separatorSelection = Selection.select(tickLineGroup, Line);\n    this.labelSelection = Selection.select(tickLabelGroup, TransformableText);\n    this.lineNode.visible = false;\n  }\n  updateRange() {\n    const { range: rr, visibleRange: vr, scale: scale2 } = this;\n    const span = (rr[1] - rr[0]) / (vr[1] - vr[0]);\n    const shift = span * vr[0];\n    const start2 = rr[0] - shift;\n    this.tickScale.range = scale2.range = [start2, start2 + span];\n    this.resizeTickTree();\n  }\n  resizeTickTree() {\n    const s = this.scale;\n    const range3 = s.domain.length ? [s.convert(s.domain[0]), s.convert(s.domain[s.domain.length - 1])] : s.range;\n    const layout = this.tickTreeLayout;\n    const lineHeight = this.lineHeight;\n    if (layout) {\n      layout.resize(\n        Math.abs(range3[1] - range3[0]),\n        layout.depth * lineHeight,\n        (Math.min(range3[0], range3[1]) || 0) + (s.bandwidth ?? 0) / 2,\n        -layout.depth * lineHeight,\n        range3[1] - range3[0] < 0\n      );\n    }\n  }\n  get lineHeight() {\n    return this.label.fontSize * 1.5;\n  }\n  /**\n   * The length of the grid. The grid is only visible in case of a non-zero value.\n   */\n  onGridVisibilityChange() {\n    this.gridLineSelection.clear();\n    this.labelSelection.clear();\n  }\n  calculateDomain() {\n    const { direction } = this;\n    let isNumericX = null;\n    const flatDomains = this.boundSeries.filter((s) => s.visible).flatMap((series) => {\n      if (direction === \"y\" /* Y */ || isNumericX) {\n        return series.getDomain(direction);\n      }\n      if (isNumericX === null) {\n        const domain2 = series.getDomain(direction);\n        isNumericX = isNumber(domain2[0]);\n        return domain2;\n      }\n      return [];\n    });\n    this.setDomain(extent(flatDomains) ?? unique(flatDomains));\n    const { domain } = this.dataDomain;\n    this.tickTreeLayout = treeLayout(ticksToTree(domain));\n    this.tickScale.domain = domain.concat(\"\");\n    this.resizeTickTree();\n  }\n  /**\n   * Creates/removes/updates the scene graph nodes that constitute the axis.\n   * Supposed to be called _manually_ after changing _any_ of the axis properties.\n   * This allows to bulk set axis properties before updating the nodes.\n   * The node changes made by this method are rendered on the next animation frame.\n   * We could schedule this method call automatically on the next animation frame\n   * when any of the axis properties change (the way we do when properties of scene graph's\n   * nodes change), but this will mean that we first wait for the next animation\n   * frame to make changes to the nodes of the axis, then wait for another animation\n   * frame to render those changes. It's nice to have everything update automatically,\n   * but this extra level of async indirection will not just introduce an unwanted delay,\n   * it will also make it harder to reason about the program.\n   */\n  update() {\n    if (!this.computedLayout) {\n      return;\n    }\n    this.updatePosition();\n    this.updateTitleCaption();\n    this.updateCategoryLabels();\n    this.updateSeparators();\n    this.updateAxisLines();\n    this.updateCategoryGridLines();\n    this.resetSelectionNodes();\n  }\n  updateTitleCaption() {\n    this.title.caption.node.visible = false;\n  }\n  updateCategoryLabels() {\n    if (!this.computedLayout)\n      return;\n    const { tickLabelLayout } = this.computedLayout;\n    const labelSelection = this.labelSelection.update(tickLabelLayout);\n    labelSelection.each((node, datum) => {\n      node.setProperties(datum);\n    });\n  }\n  updateSeparators() {\n    if (!this.computedLayout)\n      return;\n    const { separatorLayout } = this.computedLayout;\n    const { range: range3 } = this;\n    const epsilon2 = 1e-7;\n    const separatorSelection = this.separatorSelection.update(separatorLayout);\n    separatorSelection.each((line, datum) => {\n      line.x1 = datum.x1;\n      line.x2 = datum.x2;\n      line.y1 = datum.y;\n      line.y2 = datum.y;\n      line.visible = this.tick.enabled && datum.y >= range3[0] - epsilon2 && datum.y <= range3[1] + epsilon2;\n      line.stroke = this.tick.stroke;\n      line.strokeWidth = 1;\n    });\n  }\n  updateAxisLines() {\n    if (!this.computedLayout)\n      return;\n    const { axisLineLayout } = this.computedLayout;\n    const axisLineSelection = this.axisLineSelection.update(axisLineLayout);\n    axisLineSelection.each((line, datum) => {\n      line.setProperties(datum);\n      line.stroke = this.line.stroke;\n      line.strokeWidth = this.line.width;\n    });\n  }\n  updateCategoryGridLines() {\n    const { gridLength, gridLine, label, range: range3, tickScale } = this;\n    const ticks = tickScale.ticks();\n    const sideFlag = label.getSideFlag();\n    const gridSelection = this.gridLineSelection.update(gridLength ? ticks : []);\n    if (gridLength) {\n      const { width: width2, style } = gridLine;\n      const styleCount = style.length;\n      gridSelection.each((line, datum, index) => {\n        const y = Math.round(tickScale.convert(datum));\n        const { stroke, lineDash } = style[index % styleCount];\n        line.visible = gridLine.enabled && y >= range3[0] && y <= range3[1];\n        line.x1 = 0;\n        line.x2 = -sideFlag * gridLength;\n        line.y1 = y;\n        line.y2 = y;\n        line.stroke = stroke;\n        line.strokeWidth = width2;\n        line.lineDash = lineDash;\n      });\n    }\n  }\n  computeLayout() {\n    this.updateDirection();\n    this.calculateDomain();\n    this.updateRange();\n    const {\n      scale: scale2,\n      label,\n      label: { parallel },\n      moduleCtx: { callbackCache },\n      range: range3,\n      title,\n      title: { formatter = (p) => p.defaultValue } = {}\n    } = this;\n    const rangeStart = scale2.range[0];\n    const rangeEnd = scale2.range[1];\n    const rangeLength = Math.abs(rangeEnd - rangeStart);\n    const bandwidth = rangeLength / scale2.domain.length || 0;\n    const keepEvery = Math.ceil(label.fontSize / bandwidth);\n    const rotation = toRadians(this.rotation);\n    const isHorizontal = Math.abs(Math.cos(rotation)) < 1e-8;\n    const sideFlag = label.getSideFlag();\n    const lineHeight = this.lineHeight;\n    const tickTreeLayout = this.tickTreeLayout;\n    const labels = scale2.ticks();\n    const treeLabels = tickTreeLayout ? tickTreeLayout.nodes : [];\n    const isLabelTree = tickTreeLayout ? tickTreeLayout.depth > 1 : false;\n    const isCaptionEnabled = title?.enabled && labels.length > 0;\n    const { defaultRotation, configuredRotation, parallelFlipFlag } = calculateLabelRotation({\n      rotation: label.rotation,\n      parallel,\n      regularFlipRotation: normalizeAngle360(rotation - Math.PI / 2),\n      parallelFlipRotation: normalizeAngle360(rotation)\n    });\n    const tickLabelLayout = [];\n    const copyLabelProps = (node) => {\n      return {\n        fill: node.fill,\n        fontFamily: node.fontFamily,\n        fontSize: node.fontSize,\n        fontStyle: node.fontStyle,\n        fontWeight: node.fontWeight,\n        rotation: node.rotation,\n        rotationCenterX: node.rotationCenterX,\n        rotationCenterY: node.rotationCenterY,\n        text: node.text,\n        textAlign: node.textAlign,\n        textBaseline: node.textBaseline,\n        translationX: node.translationX,\n        translationY: node.translationY,\n        visible: node.visible,\n        x: node.x,\n        y: node.y\n      };\n    };\n    const labelBBoxes = /* @__PURE__ */ new Map();\n    let maxLeafLabelWidth = 0;\n    const tempText = new TransformableText();\n    const setLabelProps = (datum, index) => {\n      if (index === 0) {\n        if (isCaptionEnabled) {\n          const text = callbackCache.call(formatter, this.getTitleFormatterParams());\n          tempText.setProperties({\n            text,\n            fill: title.color,\n            fontFamily: title.fontFamily,\n            fontSize: title.fontSize,\n            fontStyle: title.fontStyle,\n            fontWeight: title.fontWeight,\n            textAlign: \"center\",\n            textBaseline: \"hanging\",\n            translationX: datum.screenY - title.fontSize * 0.25,\n            translationY: datum.screenX\n          });\n          return true;\n        }\n        return false;\n      }\n      tempText.setProperties({\n        fill: label.color,\n        fontFamily: label.fontFamily,\n        fontSize: label.fontSize,\n        fontStyle: label.fontStyle,\n        fontWeight: label.fontWeight,\n        textAlign: \"center\",\n        textBaseline: parallelFlipFlag === -1 ? \"bottom\" : \"hanging\",\n        translationX: datum.screenY - label.fontSize * 0.25,\n        translationY: datum.screenX\n      });\n      if (index % keepEvery !== 0) {\n        return false;\n      }\n      if (datum.screenX < range3[0] || datum.screenX > range3[1]) {\n        return false;\n      }\n      if (label.formatter) {\n        tempText.text = callbackCache.call(label.formatter, {\n          value: String(datum.label),\n          index\n        }) ?? String(datum.label);\n      } else {\n        tempText.text = String(datum.label);\n      }\n      return true;\n    };\n    treeLabels.forEach((datum, index) => {\n      const isVisible = setLabelProps(datum, index);\n      if (!isVisible)\n        return;\n      const bbox2 = tempText.getBBox();\n      if (!bbox2)\n        return;\n      labelBBoxes.set(index, bbox2);\n      const isLeaf = !datum.children.length;\n      if (isLeaf && bbox2.width > maxLeafLabelWidth) {\n        maxLeafLabelWidth = bbox2.width;\n      }\n    });\n    const labelX = sideFlag * label.padding;\n    const labelGrid = this.label.grid;\n    const separatorData = [];\n    treeLabels.forEach((datum, index) => {\n      const isLeaf = !datum.children.length;\n      let visible = setLabelProps(datum, index);\n      tempText.x = labelX;\n      tempText.y = index === 0 && isCaptionEnabled ? title.spacing ?? 0 : 0;\n      tempText.rotationCenterX = labelX;\n      if (isLeaf) {\n        tempText.rotation = configuredRotation;\n        tempText.textAlign = \"end\";\n        tempText.textBaseline = \"middle\";\n      } else {\n        const availableRange = datum.leafCount * bandwidth;\n        const bbox2 = labelBBoxes.get(index);\n        tempText.translationX -= maxLeafLabelWidth - lineHeight + this.label.padding;\n        if (bbox2 && bbox2.width > availableRange) {\n          visible = false;\n          labelBBoxes.delete(index);\n        } else {\n          tempText.rotation = isHorizontal ? defaultRotation : -Math.PI / 2;\n        }\n      }\n      if (datum.parent && isLabelTree) {\n        const y = isLeaf ? datum.screenX - bandwidth / 2 : datum.screenX - datum.leafCount * bandwidth / 2;\n        if (isLeaf) {\n          if (datum.number !== datum.children.length - 1 || labelGrid) {\n            separatorData.push({\n              y,\n              x1: 0,\n              x2: -maxLeafLabelWidth - this.label.padding * 2\n            });\n          }\n        } else {\n          const x = -maxLeafLabelWidth - this.label.padding * 2 + datum.screenY;\n          separatorData.push({\n            y,\n            x1: x + lineHeight,\n            x2: x\n          });\n        }\n      }\n      let props;\n      if (visible) {\n        const bbox2 = Transformable.toCanvas(tempText);\n        if (bbox2) {\n          labelBBoxes.set(index, bbox2);\n        }\n        props = { ...copyLabelProps(tempText), visible };\n      } else {\n        labelBBoxes.delete(index);\n        props = { visible };\n      }\n      tickLabelLayout.push(props);\n    });\n    let minX = 0;\n    separatorData.forEach((d) => minX = Math.min(minX, d.x2));\n    separatorData.push({\n      y: Math.max(rangeStart, rangeEnd),\n      x1: 0,\n      x2: minX\n    });\n    const separatorLayout = [];\n    const separatorBoxes = [];\n    const epsilon2 = 1e-7;\n    separatorData.forEach((datum) => {\n      if (datum.y >= range3[0] - epsilon2 && datum.y <= range3[1] + epsilon2) {\n        const { x1, x2, y } = datum;\n        const separatorBox = new BBox(Math.min(x1, x2), y, Math.abs(x1 - x2), 0);\n        separatorBoxes.push(separatorBox);\n        separatorLayout.push({ x1, x2, y });\n      }\n    });\n    const axisLineLayout = [];\n    const axisLineBoxes = [];\n    const lineCount = tickTreeLayout ? tickTreeLayout.depth + 1 : 1;\n    for (let i = 0; i < lineCount; i++) {\n      const visible = labels.length > 0 && (i === 0 || labelGrid && isLabelTree);\n      const x = i > 0 ? -maxLeafLabelWidth - this.label.padding * 2 - (i - 1) * lineHeight : 0;\n      const lineBox = new BBox(x, Math.min(...range3), 0, Math.abs(range3[1] - range3[0]));\n      axisLineBoxes.push(lineBox);\n      axisLineLayout.push({ x, y1: range3[0], y2: range3[1], visible });\n    }\n    const bbox = BBox.merge(iterate(labelBBoxes.values(), separatorBoxes, axisLineBoxes));\n    const transformedBBox = this.getTransformBox(bbox);\n    return {\n      bbox: transformedBBox,\n      tickLabelLayout,\n      separatorLayout,\n      axisLineLayout\n    };\n  }\n  calculateLayout() {\n    const { axisLineLayout, separatorLayout, tickLabelLayout, bbox } = this.computeLayout();\n    this.computedLayout = { axisLineLayout, separatorLayout, tickLabelLayout };\n    return { bbox, primaryTickCount: void 0 };\n  }\n};\nGroupedCategoryAxis.className = \"GroupedCategoryAxis\";\nGroupedCategoryAxis.type = \"grouped-category\";\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], GroupedCategoryAxis.prototype, \"labelColor\", 2);\n\n// packages/ag-charts-community/src/module/module.ts\nvar BaseModuleInstance = class {\n  constructor() {\n    this.destroyFns = [];\n  }\n  destroy() {\n    for (const destroyFn of this.destroyFns) {\n      destroyFn();\n    }\n  }\n};\nvar ModuleRegistry = class {\n  constructor() {\n    this.modules = [];\n    this.dependencies = /* @__PURE__ */ new Map();\n    this.dependents = /* @__PURE__ */ new Map();\n  }\n  register(...modules) {\n    for (const module of modules) {\n      this.registerDependencies(module);\n      const otherModule = this.modules.find(\n        (other) => module.type === other.type && module.optionsKey === other.optionsKey && module.identifier === other.identifier\n      );\n      if (otherModule) {\n        if (module.packageType === \"enterprise\" && otherModule.packageType === \"community\") {\n          const index = this.modules.indexOf(otherModule);\n          this.modules.splice(index, 1, module);\n        }\n      } else {\n        this.modules.push(module);\n      }\n    }\n  }\n  hasEnterpriseModules() {\n    return this.modules.some((m) => m.packageType === \"enterprise\");\n  }\n  *byType(...types) {\n    const { dependents } = this;\n    const yielded = /* @__PURE__ */ new Set();\n    let count = 0;\n    const maxCount = 3;\n    const modulesByType = this.modules.filter((module) => types.includes(module.type));\n    do {\n      for (const module of modulesByType) {\n        if (yielded.has(module.optionsKey) || dependents.has(module.optionsKey)) {\n          continue;\n        }\n        yield module;\n        yielded.add(module.optionsKey);\n        for (const [key, dependencies] of dependents.entries()) {\n          dependencies.delete(module.optionsKey);\n          if (dependencies.size === 0) {\n            dependents.delete(key);\n          }\n        }\n      }\n      count++;\n    } while (yielded.size < modulesByType.length && count < maxCount);\n    if (dependents.size > 0) {\n      throw new Error(`Could not resolve module dependencies: [${[...dependents.keys()]}]`);\n    }\n  }\n  registerDependencies(module) {\n    if (module.dependencies == null || module.dependencies.length === 0)\n      return;\n    for (const key of module.dependencies) {\n      const dependencies = this.dependencies.get(key) ?? /* @__PURE__ */ new Set();\n      dependencies.add(module.optionsKey);\n      this.dependencies.set(key, dependencies);\n    }\n    this.dependents.set(module.optionsKey, new Set(module.dependencies));\n  }\n};\nvar moduleRegistry = new ModuleRegistry();\n\n// packages/ag-charts-community/src/util/async.ts\nfunction sleep(sleepTimeoutMs) {\n  return new Promise((resolve) => {\n    setTimeout(() => resolve(void 0), sleepTimeoutMs);\n  });\n}\n\n// packages/ag-charts-community/src/util/mutex.ts\nvar Mutex = class {\n  constructor() {\n    this.available = true;\n    this.acquireQueue = [];\n  }\n  acquire(cb) {\n    return new Promise((resolve) => {\n      this.acquireQueue.push([cb, resolve]);\n      if (this.available) {\n        this.dispatchNext().catch((e) => Logger.errorOnce(e));\n      }\n    });\n  }\n  async acquireImmediately(cb) {\n    if (!this.available) {\n      return false;\n    }\n    await this.acquire(cb);\n    return true;\n  }\n  async waitForClearAcquireQueue() {\n    return this.acquire(async () => void 0);\n  }\n  async dispatchNext() {\n    this.available = false;\n    let [next, done] = this.acquireQueue.shift() ?? [];\n    while (next) {\n      try {\n        await next();\n        done?.();\n      } catch (error) {\n        Logger.error(\"mutex callback error\", error);\n        done?.();\n      }\n      [next, done] = this.acquireQueue.shift() ?? [];\n    }\n    this.available = true;\n  }\n};\n\n// packages/ag-charts-community/src/util/observable.ts\nvar Observable = class {\n  constructor() {\n    this.eventListeners = /* @__PURE__ */ new Map();\n  }\n  addEventListener(eventType, listener) {\n    if (typeof listener !== \"function\") {\n      throw new Error(\"AG Charts - listener must be a Function\");\n    }\n    const eventTypeListeners = this.eventListeners.get(eventType);\n    if (eventTypeListeners) {\n      eventTypeListeners.add(listener);\n    } else {\n      this.eventListeners.set(eventType, /* @__PURE__ */ new Set([listener]));\n    }\n  }\n  removeEventListener(type, listener) {\n    this.eventListeners.get(type)?.delete(listener);\n    if (this.eventListeners.size === 0) {\n      this.eventListeners.delete(type);\n    }\n  }\n  hasEventListener(type) {\n    return this.eventListeners.has(type);\n  }\n  clearEventListeners() {\n    this.eventListeners.clear();\n  }\n  fireEvent(event) {\n    this.eventListeners.get(event.type)?.forEach((listener) => listener(event));\n  }\n};\n\n// packages/ag-charts-community/src/util/padding.ts\nvar Padding = class extends BaseProperties {\n  constructor(top = 0, right = top, bottom = top, left = right) {\n    super();\n    this.top = top;\n    this.right = right;\n    this.bottom = bottom;\n    this.left = left;\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Padding.prototype, \"top\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Padding.prototype, \"right\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Padding.prototype, \"bottom\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Padding.prototype, \"left\", 2);\n\n// packages/ag-charts-community/src/util/render.ts\nfunction debouncedAnimationFrame(cb) {\n  return buildScheduler((innerCb, _delayMs) => getWindow().requestAnimationFrame(innerCb), cb);\n}\nfunction debouncedCallback(cb) {\n  return buildScheduler((innerCb, delayMs = 0) => setTimeout(innerCb, delayMs), cb);\n}\nfunction buildScheduler(scheduleFn, cb) {\n  let scheduleCount = 0;\n  let promiseRunning = false;\n  let awaitingPromise;\n  let awaitingDone;\n  const busy = () => {\n    return promiseRunning;\n  };\n  const done = () => {\n    promiseRunning = false;\n    awaitingDone?.();\n    awaitingDone = void 0;\n    awaitingPromise = void 0;\n    if (scheduleCount > 0) {\n      scheduleFn(scheduleCb);\n    }\n  };\n  const scheduleCb = () => {\n    const count = scheduleCount;\n    scheduleCount = 0;\n    promiseRunning = true;\n    const maybePromise = cb({ count });\n    if (!maybePromise) {\n      done();\n      return;\n    }\n    maybePromise.then(done, done);\n  };\n  return {\n    schedule(delayMs) {\n      if (scheduleCount === 0 && !busy()) {\n        scheduleFn(scheduleCb, delayMs);\n      }\n      scheduleCount++;\n    },\n    async await() {\n      if (!busy()) {\n        return;\n      }\n      if (awaitingPromise == null) {\n        awaitingPromise = new Promise((resolve) => {\n          awaitingDone = resolve;\n        });\n      }\n      while (busy()) {\n        await awaitingPromise;\n      }\n    }\n  };\n}\n\n// packages/ag-charts-community/src/util/eventEmitter.ts\nvar EventEmitter = class {\n  constructor() {\n    this.events = /* @__PURE__ */ new Map();\n  }\n  /**\n   * Registers an event listener.\n   * @param eventName The event name to listen for.\n   * @param listener The callback to be invoked on the event.\n   * @returns A function to unregister the listener.\n   */\n  on(eventName, listener) {\n    if (!this.events.has(eventName)) {\n      this.events.set(eventName, /* @__PURE__ */ new Set());\n    }\n    this.events.get(eventName)?.add(listener);\n    return () => this.off(eventName, listener);\n  }\n  /**\n   * Unregisters an event listener.\n   * @param eventName The event name to stop listening for.\n   * @param listener The callback to be removed.\n   */\n  off(eventName, listener) {\n    const eventListeners = this.events.get(eventName);\n    if (eventListeners) {\n      eventListeners.delete(listener);\n      if (eventListeners.size === 0) {\n        this.events.delete(eventName);\n      }\n    }\n  }\n  /**\n   * Emits an event to all registered listeners.\n   * @param eventName The name of the event to emit.\n   * @param event The event payload.\n   */\n  emit(eventName, event) {\n    this.events.get(eventName)?.forEach((callback2) => callback2(event));\n  }\n  /**\n   * Clears all listeners for a specific event or all events if no event name is provided.\n   * @param eventName (Optional) The name of the event to clear listeners for. If not provided, all listeners for all events are cleared.\n   */\n  clear(eventName) {\n    if (eventName) {\n      this.events.delete(eventName);\n    } else {\n      this.events.clear();\n    }\n  }\n};\n\n// packages/ag-charts-community/src/chart/layout/layoutManager.ts\nvar LayoutElement = /* @__PURE__ */ ((LayoutElement2) => {\n  LayoutElement2[LayoutElement2[\"Caption\"] = 0] = \"Caption\";\n  LayoutElement2[LayoutElement2[\"Legend\"] = 1] = \"Legend\";\n  LayoutElement2[LayoutElement2[\"Toolbar\"] = 2] = \"Toolbar\";\n  LayoutElement2[LayoutElement2[\"Navigator\"] = 3] = \"Navigator\";\n  LayoutElement2[LayoutElement2[\"Overlay\"] = 4] = \"Overlay\";\n  return LayoutElement2;\n})(LayoutElement || {});\nvar LayoutManager = class {\n  constructor() {\n    this.events = new EventEmitter();\n    this.elements = /* @__PURE__ */ new Map();\n  }\n  addListener(eventName, listener) {\n    return this.events.on(eventName, listener);\n  }\n  registerElement(element2, listener) {\n    if (this.elements.has(element2)) {\n      this.elements.get(element2).add(listener);\n    } else {\n      this.elements.set(element2, /* @__PURE__ */ new Set([listener]));\n    }\n    return () => this.elements.get(element2)?.delete(listener);\n  }\n  createContext(width2, height2) {\n    const context = new LayoutContext(width2, height2);\n    for (const element2 of Object.values(LayoutElement)) {\n      if (typeof element2 !== \"number\")\n        continue;\n      this.elements.get(element2)?.forEach((listener) => listener(context));\n    }\n    return context;\n  }\n  emitLayoutComplete(context, options) {\n    const eventType = \"layout:complete\";\n    const { width: width2, height: height2 } = context;\n    this.events.emit(eventType, {\n      type: eventType,\n      axes: options.axes ?? [],\n      chart: { width: width2, height: height2 },\n      clipSeries: options.clipSeries ?? false,\n      series: options.series\n    });\n  }\n};\nvar LayoutContext = class {\n  constructor(width2, height2) {\n    this.width = width2;\n    this.height = height2;\n    this.layoutBox = new BBox(0, 0, width2, height2);\n  }\n};\n\n// packages/ag-charts-community/src/chart/chartCaptions.ts\nvar ChartCaptions = class {\n  constructor() {\n    this.title = new Caption();\n    this.subtitle = new Caption();\n    this.footnote = new Caption();\n  }\n  positionCaptions(ctx) {\n    const { title, subtitle, footnote } = this;\n    const maxHeight = ctx.layoutBox.height / 10;\n    if (title.enabled) {\n      const { spacing = subtitle.enabled ? Caption.SMALL_PADDING : Caption.LARGE_PADDING } = title;\n      this.positionCaption(\"top\", title, ctx.layoutBox, maxHeight);\n      this.shrinkLayoutByCaption(\"top\", title, ctx.layoutBox, spacing);\n    }\n    if (subtitle.enabled) {\n      this.positionCaption(\"top\", subtitle, ctx.layoutBox, maxHeight);\n      this.shrinkLayoutByCaption(\"top\", subtitle, ctx.layoutBox, subtitle.spacing);\n    }\n    if (footnote.enabled) {\n      this.positionCaption(\"bottom\", footnote, ctx.layoutBox, maxHeight);\n      this.shrinkLayoutByCaption(\"bottom\", footnote, ctx.layoutBox, footnote.spacing);\n    }\n  }\n  positionAbsoluteCaptions(ctx) {\n    const { title, subtitle, footnote } = this;\n    const { rect } = ctx.series;\n    for (const caption of [title, subtitle, footnote]) {\n      if (caption.layoutStyle !== \"overlay\")\n        continue;\n      if (caption.textAlign === \"left\") {\n        caption.node.x = rect.x + caption.padding;\n      } else if (caption.textAlign === \"right\") {\n        const bbox = caption.node.getBBox();\n        caption.node.x = rect.x + rect.width - bbox.width - caption.padding;\n      }\n    }\n  }\n  computeX(align, layoutBox) {\n    if (align === \"left\") {\n      return layoutBox.x;\n    } else if (align === \"right\") {\n      return layoutBox.x + layoutBox.width;\n    }\n    return layoutBox.x + layoutBox.width / 2;\n  }\n  positionCaption(vAlign, caption, layoutBox, maxHeight) {\n    const containerHeight = Math.max(TextUtils.getLineHeight(caption.fontSize), maxHeight);\n    caption.node.x = this.computeX(caption.textAlign, layoutBox) + caption.padding;\n    caption.node.y = layoutBox.y + (vAlign === \"top\" ? 0 : layoutBox.height) + caption.padding;\n    caption.node.textBaseline = vAlign;\n    caption.computeTextWrap(layoutBox.width, containerHeight);\n  }\n  shrinkLayoutByCaption(vAlign, caption, layoutBox, spacing = 0) {\n    if (caption.layoutStyle === \"block\") {\n      const bbox = caption.node.getBBox();\n      layoutBox.shrink(\n        vAlign === \"top\" ? Math.ceil(bbox.y - layoutBox.y + bbox.height + spacing) : Math.ceil(layoutBox.y + layoutBox.height - bbox.y + spacing),\n        vAlign\n      );\n    }\n  }\n};\n__decorateClass([\n  Validate(OBJECT)\n], ChartCaptions.prototype, \"title\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], ChartCaptions.prototype, \"subtitle\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], ChartCaptions.prototype, \"footnote\", 2);\n\n// packages/ag-charts-community/src/util/listeners.ts\nvar Listeners = class {\n  constructor() {\n    this.registeredListeners = /* @__PURE__ */ new Map();\n  }\n  addListener(eventType, handler) {\n    const record = { symbol: Symbol(eventType), handler };\n    if (this.registeredListeners.has(eventType)) {\n      this.registeredListeners.get(eventType).push(record);\n    } else {\n      this.registeredListeners.set(eventType, [record]);\n    }\n    return () => this.removeListener(record.symbol);\n  }\n  removeListener(eventSymbol) {\n    for (const [type, listeners] of this.registeredListeners.entries()) {\n      const matchIndex = listeners.findIndex((listener) => listener.symbol === eventSymbol);\n      if (matchIndex >= 0) {\n        listeners.splice(matchIndex, 1);\n        if (listeners.length === 0) {\n          this.registeredListeners.delete(type);\n        }\n        break;\n      }\n    }\n  }\n  dispatch(eventType, ...params) {\n    for (const listener of this.getListenersByType(eventType)) {\n      try {\n        listener.handler(...params);\n      } catch (e) {\n        Logger.errorOnce(e);\n      }\n    }\n  }\n  dispatchWrapHandlers(eventType, wrapFn, ...params) {\n    for (const listener of this.getListenersByType(eventType)) {\n      try {\n        wrapFn(listener.handler, ...params);\n      } catch (e) {\n        Logger.errorOnce(e);\n      }\n    }\n  }\n  getListenersByType(eventType) {\n    return this.registeredListeners.get(eventType) ?? [];\n  }\n  destroy() {\n    this.registeredListeners.clear();\n  }\n};\n\n// packages/ag-charts-community/src/chart/baseManager.ts\nvar BaseManager = class {\n  constructor() {\n    this.listeners = new Listeners();\n    this.destroyFns = [];\n  }\n  addListener(type, handler) {\n    return this.listeners.addListener(type, handler);\n  }\n  destroy() {\n    this.listeners.destroy();\n    this.destroyFns.forEach((fn) => fn());\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/interactionStateListener.ts\nvar InteractionState = /* @__PURE__ */ ((InteractionState2) => {\n  InteractionState2[InteractionState2[\"Default\"] = 32] = \"Default\";\n  InteractionState2[InteractionState2[\"ZoomDrag\"] = 16] = \"ZoomDrag\";\n  InteractionState2[InteractionState2[\"Annotations\"] = 8] = \"Annotations\";\n  InteractionState2[InteractionState2[\"ContextMenu\"] = 4] = \"ContextMenu\";\n  InteractionState2[InteractionState2[\"Animation\"] = 2] = \"Animation\";\n  InteractionState2[InteractionState2[\"AnnotationsSelected\"] = 1] = \"AnnotationsSelected\";\n  InteractionState2[InteractionState2[\"All\"] = 63] = \"All\";\n  return InteractionState2;\n})(InteractionState || {});\nvar InteractionStateListener = class extends BaseManager {\n  // Wrapper to only broadcast events when the InteractionManager is a given state.\n  addListener(type, handler, triggeringStates = 32 /* Default */) {\n    return super.addListener(type, (e) => {\n      const currentState = this.getState();\n      if (currentState & triggeringStates) {\n        handler(e);\n      }\n    });\n  }\n};\n\n// packages/ag-charts-community/src/util/destroy.ts\nvar DestroyFns = class {\n  constructor() {\n    this.destroyFns = [];\n  }\n  destroy() {\n    this.destroyFns.forEach((fn) => fn());\n    this.destroyFns.length = 0;\n  }\n  setFns(destroyFns) {\n    this.destroy();\n    this.destroyFns = destroyFns;\n  }\n};\n\n// packages/ag-charts-community/src/version.ts\nvar VERSION = \"10.3.3\";\n\n// packages/ag-charts-community/src/api/state/historyManager.ts\nvar NOT_FOUND = Symbol(\"previous-memento-not-found\");\nvar HistoryManager = class {\n  constructor(keyNavManager) {\n    this.history = [];\n    this.historyIndex = -1;\n    this.originators = /* @__PURE__ */ new Map();\n    this.clearState = /* @__PURE__ */ new Map();\n    this.maxHistoryLength = 100;\n    this.debug = Debug.create(true, \"history\");\n    this.destroyFns = new DestroyFns();\n    this.destroyFns.setFns([\n      keyNavManager.addListener(\"undo\", this.undo.bind(this), 63 /* All */),\n      keyNavManager.addListener(\"redo\", this.redo.bind(this), 63 /* All */)\n    ]);\n  }\n  destroy() {\n    this.destroyFns.destroy();\n  }\n  addMementoOriginator(originator) {\n    this.originators.set(originator.mementoOriginatorKey, originator);\n    this.clearState.set(originator.mementoOriginatorKey, originator.createMemento());\n    this.debugEvent(\"History add originator:\", originator.mementoOriginatorKey);\n  }\n  clear() {\n    this.debug(`History clear:`, Object.keys(this.originators));\n    this.history = [];\n    this.historyIndex = -1;\n    for (const [mementoOriginatorKey, originator] of this.originators.entries()) {\n      this.clearState.set(mementoOriginatorKey, originator.createMemento());\n    }\n  }\n  record(label, ...originators) {\n    if (this.historyIndex < this.history.length - 1) {\n      this.history = this.history.slice(0, this.historyIndex + 1);\n    }\n    if (this.history.length > this.maxHistoryLength) {\n      this.history = this.history.slice(-this.maxHistoryLength);\n    }\n    const mementos = /* @__PURE__ */ new Map();\n    for (const originator of originators) {\n      if (!this.originators.has(originator.mementoOriginatorKey)) {\n        throw new Error(\n          `Originator [${originator.mementoOriginatorKey}] has not been added to the HistoryManager.`\n        );\n      }\n      mementos.set(originator.mementoOriginatorKey, originator.createMemento());\n    }\n    this.history.push({ label, mementos });\n    this.historyIndex = this.history.length - 1;\n    this.debugEvent(`History record: [${label}]`);\n  }\n  undo() {\n    const undoAction = this.history[this.historyIndex];\n    if (!undoAction)\n      return;\n    for (const mementoOriginatorKey of undoAction.mementos.keys()) {\n      const previousMemento = this.findPreviousMemento(mementoOriginatorKey);\n      if (previousMemento === NOT_FOUND) {\n        throw new Error(`Could not find previous memento for [${mementoOriginatorKey}].`);\n      }\n      this.restoreMemento(mementoOriginatorKey, previousMemento);\n    }\n    this.historyIndex -= 1;\n    this.debugEvent(`History undo: [${undoAction.label}]`);\n  }\n  redo() {\n    const redoAction = this.history[this.historyIndex + 1];\n    if (!redoAction)\n      return;\n    for (const [mementoOriginatorKey, memento] of redoAction.mementos.entries()) {\n      this.restoreMemento(mementoOriginatorKey, memento);\n    }\n    this.historyIndex += 1;\n    this.debugEvent(`History redo: [${redoAction.label}]`);\n  }\n  findPreviousMemento(mementoOriginatorKey) {\n    for (let i = this.historyIndex - 1; i >= 0; i--) {\n      if (this.history[i].mementos.has(mementoOriginatorKey)) {\n        return this.history[i].mementos.get(mementoOriginatorKey);\n      }\n    }\n    if (this.clearState.has(mementoOriginatorKey)) {\n      return this.clearState.get(mementoOriginatorKey);\n    }\n    return NOT_FOUND;\n  }\n  restoreMemento(mementoOriginatorKey, memento) {\n    this.originators.get(mementoOriginatorKey)?.restoreMemento(VERSION, VERSION, memento);\n  }\n  debugEvent(...logContent) {\n    this.debug(\n      ...logContent,\n      this.history.map((action, index) => index === this.historyIndex ? `** ${action.label} **` : action.label)\n    );\n  }\n};\n\n// packages/ag-charts-community/src/api/state/memento.ts\nvar MementoCaretaker = class {\n  constructor(version) {\n    this.version = version.split(\"-\")[0];\n  }\n  save(...originators) {\n    const packet = { version: this.version };\n    for (const originator of Object.values(originators)) {\n      packet[originator.mementoOriginatorKey] = this.encode(originator, originator.createMemento());\n    }\n    return packet;\n  }\n  restore(blob, ...originators) {\n    if (typeof blob !== \"object\") {\n      Logger.warnOnce(`Could not restore data of type [${typeof blob}], expecting an object, ignoring.`);\n      return;\n    }\n    if (blob == null) {\n      Logger.warnOnce(`Could not restore data of type [null], expecting an object, ignoring.`);\n      return;\n    }\n    if (!(\"version\" in blob) || typeof blob.version !== \"string\") {\n      Logger.warnOnce(`Could not restore data, missing [version] string in object, ignoring.`);\n      return;\n    }\n    for (const originator of originators) {\n      if (!(originator.mementoOriginatorKey in blob)) {\n        continue;\n      }\n      const memento = this.decode(originator, blob[originator.mementoOriginatorKey]);\n      if (!originator.guardMemento(memento)) {\n        Logger.warnOnce(\n          `Could not restore [${originator.mementoOriginatorKey}] data, value was invalid, ignoring.`,\n          memento\n        );\n        return;\n      }\n      originator.restoreMemento(this.version, blob.version, memento);\n    }\n  }\n  /**\n   * Encode a memento as a serializable object, encoding any non-serializble types.\n   */\n  encode(originator, memento) {\n    try {\n      return JSON.parse(JSON.stringify(memento, this.encodeTypes));\n    } catch (error) {\n      throw new Error(`Failed to encode [${originator.mementoOriginatorKey}] value [${error}].`, {\n        cause: error\n      });\n    }\n  }\n  /**\n   * Decode an encoded memento, decoding any non-serializable types.\n   */\n  decode(originator, encoded) {\n    try {\n      return JSON.parse(JSON.stringify(encoded), this.decodeTypes);\n    } catch (error) {\n      throw new Error(`Failed to decode [${originator.mementoOriginatorKey}] value [${error}].`, {\n        cause: error\n      });\n    }\n  }\n  encodeTypes(key, value) {\n    if (isDate(this[key])) {\n      return { __type: \"date\", value: String(this[key]) };\n    }\n    return value;\n  }\n  decodeTypes(key, value) {\n    if (isObject(this[key]) && \"__type\" in this[key] && this[key].__type === \"date\") {\n      return new Date(this[key].value);\n    }\n    return value;\n  }\n};\n\n// packages/ag-charts-community/src/api/state/stateManager.ts\nvar StateManager = class {\n  constructor() {\n    this.caretaker = new MementoCaretaker(VERSION);\n    this.state = /* @__PURE__ */ new Map();\n  }\n  setState(originator, value) {\n    if (jsonDiff(this.state.get(originator.mementoOriginatorKey), value) == null) {\n      return;\n    }\n    this.state.set(originator.mementoOriginatorKey, value);\n    this.restoreState(originator);\n  }\n  restoreState(originator) {\n    const { caretaker, state } = this;\n    if (!state.has(originator.mementoOriginatorKey))\n      return;\n    const value = state.get(originator.mementoOriginatorKey);\n    caretaker.restore({ version: caretaker.version, [originator.mementoOriginatorKey]: value }, originator);\n  }\n};\n\n// packages/ag-charts-community/src/styles.css\nvar styles_default = '.ag-charts-wrapper,.ag-charts-wrapper:focus,.ag-charts-wrapper:after,.ag-charts-wrapper:before,.ag-charts-wrapper *,.ag-charts-wrapper *:focus,.ag-charts-wrapper *:after,.ag-charts-wrapper *:before{box-sizing:border-box;outline:none}.ag-charts-wrapper{position:relative;user-select:none}.ag-charts-canvas-center{width:100%;height:100%;position:absolute;touch-action:auto;display:flex;align-items:var(--ag-charts-align);justify-content:var(--ag-charts-justify)}.ag-charts-canvas-container,.ag-charts-canvas{position:relative;user-select:none}.ag-charts-canvas-container>*,.ag-charts-canvas>*{display:block;pointer-events:none}.ag-charts-series-area{opacity:0;pointer-events:auto;position:absolute}.ag-charts-series-area:focus-visible{opacity:1}.ag-charts-canvas-proxy,.ag-charts-canvas-overlay{inset:0;pointer-events:none;position:absolute;user-select:none}.ag-charts-canvas-overlay>*{position:absolute;pointer-events:auto}.ag-charts-theme-default,.ag-charts-theme-default-dark{--ag-charts-active-color: var(--ag-active-color, #2196f3);--ag-charts-background-color: var(--ag-background-color, #fff);--ag-charts-foreground-color: var(--ag-foreground-color, #181d1f);--ag-charts-border-color: var(--ag-border-color, #dddddd);--ag-charts-hover-color: color-mix(in srgb, var(--ag-charts-background-color), var(--ag-charts-active-color) 12%);--ag-charts-font-family: \"Verdana\", sans-serif;--ag-charts-font-size: var(--ag-font-size, 14px);--ag-charts-size: var(--ag-grid-size, 8px);--ag-charts-border: var(--ag-charts-border-color) var(--ag-borders, solid 1px);--ag-charts-border-critical: var(--ag-borders-critical, solid 1px);--ag-charts-layer-ui-overlay: 5;--ag-charts-layer-tooltip: 4;--ag-charts-layer-toolbar: 3;--ag-charts-layer-crosshair: 2;--ag-charts-layer-annotations: 1;--ag-charts-align: center;--ag-charts-justify: center;--ag-charts-axis-label-background-color: #474747;--ag-charts-axis-label-color: #ffffff;--ag-charts-toolbar-foreground-color: var(--ag-header-foreground-color, var(--ag-charts-foreground-color));--ag-charts-toolbar-background-color: var( --ag-header-background-color, color-mix(in srgb, var(--ag-charts-background-color), var(--ag-charts-foreground-color) 2%) );--ag-charts-toolbar-size: 34px;--ag-charts-toolbar-size-small: 24px;--ag-charts-toolbar-border: var(--ag-charts-border-critical, solid 1px) var(--ag-charts-border-color);--ag-charts-toolbar-hover-color: color-mix( in srgb, var(--ag-charts-background-color), var(--ag-charts-active-color) 12% );--ag-charts-toolbar-focus-color: var(--ag-charts-active-color);--ag-charts-toolbar-active-background-color: var(--ag-charts-toolbar-hover-color);--ag-charts-toolbar-active-color: var(--ag-charts-active-color);--ag-charts-toolbar-disabled-foreground-color: var( --ag-disabled-foreground-color, color-mix(in srgb, transparent, var(--ag-charts-toolbar-foreground-color) 50%) );--ag-charts-toolbar-disabled-background-color: color-mix( in srgb, var(--ag-charts-toolbar-background-color), var(--ag-charts-toolbar-foreground-color) 6% );--ag-charts-toolbar-gap: var(--ag-charts-size);--ag-charts-toolbar-font-size: 13px;--ag-charts-toolbar-font-size-small: 12px;--ag-charts-toolbar-button-padding: 6px;--ag-charts-toolbar-button-padding-small: 1px;--ag-charts-popover-background-color: var(--ag-charts-toolbar-background-color);--ag-charts-popover-foreground-color: var(--ag-charts-toolbar-foreground-color);--ag-charts-popover-border: var(--ag-charts-toolbar-border);--ag-charts-popover-border-radius: var(--ag-border-radius, 4px);--ag-charts-popover-active-color: var(--ag-charts-toolbar-active-color);--ag-charts-popover-hover-color: var(--ag-charts-toolbar-hover-color);--ag-charts-popover-active-background-color: var(--ag-charts-toolbar-active-background-color);--ag-charts-popover-font-size: 14px;--ag-charts-popover-font-size-small: var(--ag-charts-toolbar-font-size-small);--ag-charts-dialog-input-group-label-color: color-mix(in srgb, transparent, var(--ag-charts-foreground-color) 55%);--ag-charts-dialog-tab-color--inactive: color-mix(in srgb, transparent, var(--ag-charts-foreground-color) 55%);--ag-charts-button-radius: var(--ag-border-radius, 4px);--ag-charts-focus-border-color: var(--ag-input-focus-border-color, var(--ag-charts-active-color));--ag-charts-focus-border: solid 1px var(--ag-charts-focus-border-color);--ag-charts-focus-border-shadow: var( --ag-input-focus-box-shadow, 0 0 0 3px color-mix(in srgb, transparent, var(--ag-input-focus-border-color, var(--ag-charts-active-color)) 20%) );--ag-charts-focus-box-shadow: var(--box-shadow), 0 0 0 2px #fff8, var(--ag-charts-focus-border-shadow);--ag-charts-icon-font-family: \"agChartsDefault\";--ag-charts-icon-font-weight: normal;--ag-charts-icon-font-color: color-mix(in srgb, transparent, var(--ag-charts-foreground-color), 90%);--ag-charts-icon-size: 20px;--ag-charts-input-background-color: var(--ag-charts-background-color);--ag-charts-input-background-color--hover: var(--ag-charts-hover-color);--ag-charts-input-background-color--active: var(--ag-charts-hover-color);--ag-charts-input-border-color: var(--ag-charts-border-color);--ag-charts-input-border-color--active: var(--ag-charts-active-color);--ag-charts-input-border-radius: var(--ag-border-radius, 4px);--ag-charts-input-color--active: var(--ag-charts-active-color);--ag-charts-input-focus-outline: var(--ag-charts-focus-border);--ag-charts-input-focus-box-shadow: var(--ag-charts-focus-border-shadow);--ag-charts-input-font-family: var(--ag-charts-font-family);--ag-charts-input-font-size: var(--ag-charts-font-size);--ag-charts-input-padding: 8px;--ag-charts-input-padding-large: 10px;--ag-charts-input-placeholder-color: #888888;--ag-charts-input-spacing: 8px;--ag-charts-input-transition-duration: .25s;--ag-charts-input-transition-duration--fast: .1s;--ag-charts-input-transition-timing-function: ease-out;--ag-charts-input-checkbox-background-color: #babbbc;--ag-charts-input-checkbox-background-color--checked: var(--ag-charts-active-color)}.ag-charts-theme-default-dark{--ag-charts-background-color: var(--ag-background-color, color-mix(in srgb, #fff, #182230 97%));--ag-charts-foreground-color: var(--ag-foreground-color, #fff);--ag-charts-border-color: var(--ag-border-color, rgba(255, 255, 255, .16));--ag-charts-hover-color: color-mix(in srgb, var(--ag-charts-background-color), var(--ag-charts-active-color) 18%);--ag-charts-axis-label-background-color: #9caebb;--ag-charts-axis-label-color: #000000;--ag-charts-toolbar-background-color: var(--ag-header-background-color, color-mix(in srgb, #fff, #182230 93%));--ag-charts-toolbar-hover-color: color-mix( in srgb, var(--ag-charts-background-color), var(--ag-charts-active-color) 18% );--ag-charts-dialog-input-group-label-text-color: #ffffff;--ag-charts-focus-border-shadow: var( --ag-input-focus-box-shadow, 0 0 0 3px color-mix(in srgb, transparent, var(--ag-input-focus-border-color, var(--ag-charts-active-color)) 20%) );--ag-charts-input-placeholder-color: #aaaaaa}.ag-charts-icon{display:block;width:var(--ag-charts-icon-size);height:var(--ag-charts-icon-size);speak:none;speak:never;mask:var(--icon) center / contain no-repeat;background-color:currentColor;transition:background-color .25s ease-in-out}.ag-charts-icon-align-center{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJNNyAxMGg2djFIN3pNNCA3aDEydjFINHptMSA2aDEwdjFINXoiLz48L3N2Zz4=)}.ag-charts-icon-align-left{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJNNCAxMGg2djFINHptMC0zaDEydjFINHptMCA2aDEwdjFINHoiLz48L3N2Zz4=)}.ag-charts-icon-align-right{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMTAgMTBoNnYxaC02ek00IDdoMTJ2MUg0em0yIDZoMTB2MUg2eiIvPjwvc3ZnPg==)}.ag-charts-icon-arrow-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE1LjI5MyA0LjVIMTIuNXYtMUgxN3Y0aC0xVjUuMjA3bC05LjY0NiA5LjY0Ny0uNzA4LS43MDh6IiBmaWxsPSIjMDAwIi8+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik03IDE2YTIuNSAyLjUgMCAxIDEtNSAwIDIuNSAyLjUgMCAwIDEgNSAwbS0yLjUgMS41YTEuNSAxLjUgMCAxIDAgMC0zIDEuNSAxLjUgMCAwIDAgMCAzIiBmaWxsPSIjMDAwIi8+PC9zdmc+)}.ag-charts-icon-arrow-down-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik02IDhMMS41IDhMMTAgMThMMTguNSA4TDE0IDhMMTQgM0w2IDNMNiA4Wk03IDRMNyA5SDMuNjYyNDRMMTAgMTYuNDU2TDE2LjMzNzYgOUwxMyA5TDEzIDRMNyA0WiIgZmlsbD0iYmxhY2siLz4KPC9zdmc+Cg==)}.ag-charts-icon-arrow-up-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNCAxMkgxOC41TDEwIDJMMS41IDEySDZMNi4wMDAwMiAxN0gxNFYxMlpNMTMgMTZWMTFIMTYuMzM3NkwxMCAzLjU0NDA1TDMuNjYyNDQgMTFIN0w3LjAwMDAyIDE2SDEzWiIgZmlsbD0iYmxhY2siLz4KPC9zdmc+Cg==)}.ag-charts-icon-callout-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMyA0LjVBMS41IDEuNSAwIDAgMSA0LjUgM2gxMUExLjUgMS41IDAgMCAxIDE3IDQuNXY4YTEuNSAxLjUgMCAwIDEtMS41IDEuNWgtNC41MTRhMjYgMjYgMCAwIDAtMi4wMTcgMS41NGwtLjMxNC4yNmMtLjU1LjQ1Ny0xLjExNS45MjYtMS43NiAxLjQtLjY2OS40OTEtMS41NjItLjAxMi0xLjU2Mi0uOFYxNEg0LjVBMS41IDEuNSAwIDAgMSAzIDEyLjV6TTQuNSA0YS41LjUgMCAwIDAtLjUuNXY4YS41LjUgMCAwIDAgLjUuNWgxLjgzM3YzLjM3MmEzNiAzNiAwIDAgMCAxLjY3OC0xLjMzOGwuMzItLjI2NWEyNiAyNiAwIDAgMSAyLjIyNS0xLjY4NWwuMTI2LS4wODRIMTUuNWEuNS41IDAgMCAwIC41LS41di04YS41LjUgMCAwIDAtLjUtLjV6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-candlestick-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNyAxdjNoMnYxMkg3djNINnYtM0g0VjRoMlYxek01IDVoM3YxMEg1ek0xMSAxNFY2aDJWMy4yNWgxVjZoMnY4aC0ydjIuNzVoLTFWMTR6bTEtN2gzdjZoLTN6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-close{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJtNSA1IDEwIDEwTTUgMTUgMTUgNSIgc3Ryb2tlPSIjMDAwIi8+PC9zdmc+)}.ag-charts-icon-comment-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNy41MTMgMy45OTVhNi41IDYuNSAwIDAgMSA2LjA5OCAxMS40MWMtLjU4OC4zOTMtMS4yMTcuNTM2LTEuODI5LjU4NWExMyAxMyAwIDAgMS0xLjI3LjAxN0EyNyAyNyAwIDAgMCAxMCAxNkg0LjVhLjUuNSAwIDAgMS0uNS0uNVYxMHEwLS4yNDctLjAwNy0uNTEzYy0uMDA4LS40MTYtLjAxNi0uODU3LjAxNy0xLjI2OS4wNS0uNjEyLjE5Mi0xLjI0LjU4NS0xLjgzYTYuNSA2LjUgMCAwIDEgMi45MTgtMi4zOTNtMy41Ni42MWE1LjUgNS41IDAgMCAwLTUuNjQ2IDIuMzRjLS4yNjYuMzk3LS4zNzkuODQyLS40MiAxLjM1NC0uMDMuMzYtLjAyMi43MTgtLjAxNSAxLjEwOFE1IDkuNjg5IDUgMTB2NWg1cS4zMTEuMDAxLjU5My4wMDhjLjM5LjAwNy43NDcuMDE1IDEuMTA4LS4wMTUuNTEyLS4wNDEuOTU3LS4xNTQgMS4zNTUtLjQyYTUuNSA1LjUgMCAwIDAtMS45ODMtOS45NjciIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-crosshair-add-line{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZD0iTTEwIDUuNWEuNS41IDAgMCAxIC41LjV2My41aDMuODc1YS41LjUgMCAwIDEgMCAxSDEwLjV2NC4yNWEuNS41IDAgMSAxLTEgMFYxMC41SDUuNjI1YS41LjUgMCAxIDEgMC0xSDkuNVY2YS41LjUgMCAwIDEgLjUtLjUiLz48L3N2Zz4=)}.ag-charts-icon-date-range-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNMiAyaDF2MTZIMnptMTUgMGgxdjE2aC0xeiIgZmlsbD0iIzE4MUQxRiIvPjxwYXRoIGQ9Ik0xMy4xNTcgMTFINXYtMWg3Ljc5M0wxMSA4LjIwN2wuNzA3LS43MDcgMy4xODIgMy4xODItMy4xODIgMy4xODItLjcwNy0uNzA3eiIgZmlsbD0iIzAwMCIvPjwvc3ZnPg==)}.ag-charts-icon-date-price-range-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNMyAySDJ2MTZoMXptMy41MDcgNC44OUw4LjUgNC44OTVWMTBINXYxaDMuNXY3aDF2LTdoNS4wODhsLTEuOTU3IDEuOTU3LjcwNy43MDcgMy4xODItMy4xODJMMTMuMzM4IDcuM2wtLjcwNy43MDdMMTQuNjI0IDEwSDkuNVY0LjkzMmwxLjk1NyAxLjk1Ny43MDctLjcwN0w4Ljk4MiAzIDUuOCA2LjE4MnoiIGZpbGw9IiMxODFEMUYiLz48L3N2Zz4=)}.ag-charts-icon-delete{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZD0iTTguNDk2IDguOTk2QS41LjUgMCAwIDEgOSA5LjQ5MnY0YS41LjUgMCAxIDEtMSAuMDA4di00YS41LjUgMCAwIDEgLjQ5Ni0uNTA0TTEyIDkuNWEuNS41IDAgMCAwLTEgMHY0YS41LjUgMCAwIDAgMSAweiIvPjxwYXRoIGZpbGw9IiMxMzE3MjIiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTYgNVYzLjVBMi41IDIuNSAwIDAgMSA4LjUgMWgzQTIuNSAyLjUgMCAwIDEgMTQgMy41VjVoMi44MzNhLjUuNSAwIDAgMSAwIDFIMTV2MTAuMjVjMCAuNDE1LS4wNjYuODYzLS4zIDEuMjIxLS4yNTcuMzk0LS42NzIuNjEyLTEuMi42MTJoLTdjLS41MjggMC0uOTQzLS4yMTgtMS4yLS42MTItLjIzNC0uMzU4LS4zLS44MDYtLjMtMS4yMjFWNkgzLjMzM2EuNS41IDAgMCAxIDAtMXptMS0xLjVBMS41IDEuNSAwIDAgMSA4LjUgMmgzQTEuNSAxLjUgMCAwIDEgMTMgMy41VjVIN3pNNiAxNi4yNVY2aDh2MTAuMjVjMCAuMzM1LS4wNTkuNTU0LS4xMzguNjc1LS4wNTUuMDg1LS4xNC4xNTgtLjM2Mi4xNThoLTdjLS4yMjIgMC0uMzA3LS4wNzMtLjM2Mi0uMTU4LS4wOC0uMTIxLS4xMzgtLjM0LS4xMzgtLjY3NSIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-disjoint-channel,.ag-charts-icon-disjoint-channel-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTkuMDI4IDE3LjQ2YTIuMjUgMi4yNSAwIDAgMC00LjA5Mi0xLjg1bC05LjUxMS0yLjM3OGEyLjI1IDIuMjUgMCAxIDAtLjIyNS45NzRsOS40NzUgMi4zNjlhMi4yNTEgMi4yNTEgMCAwIDAgNC4zNTMuODg2bS0xLjY2Mi0xLjk2NWExLjI1IDEuMjUgMCAxIDEtLjg4NSAyLjMzOCAxLjI1IDEuMjUgMCAwIDEgLjg4NS0yLjMzOE00LjM0MyAxMy42NjlhMS4yNSAxLjI1IDAgMSAwLTIuMzM4LS44ODUgMS4yNSAxLjI1IDAgMCAwIDIuMzM4Ljg4NU0zLjk3IDguNzY5YTIuMjUgMi4yNSAwIDAgMCAxLjQ1NS0yLjExbDkuNTExLTIuMzc4YTIuMjUgMi4yNSAwIDEgMC0uMjYtLjk2NUw1LjIgNS42ODVhMi4yNSAyLjI1IDAgMSAwLTEuMjMgMy4wODRtLjM3My0yLjU0N2ExLjI1IDEuMjUgMCAxIDEtMi4zMzguODg1IDEuMjUgMS4yNSAwIDAgMSAyLjMzOC0uODg1bTEzLjc1LTMuNDM4YTEuMjUgMS4yNSAwIDEgMS0yLjMzOC44ODUgMS4yNSAxLjI1IDAgMCAxIDIuMzM4LS44ODUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-drag-handle{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48Y2lyY2xlIGN4PSI1Ljc1IiBjeT0iNy43NSIgcj0iLjc1IiBmaWxsPSIjMDAwIiBmaWxsLW9wYWNpdHk9Ii41Ii8+PGNpcmNsZSBjeD0iOS43NSIgY3k9IjcuNzUiIHI9Ii43NSIgZmlsbD0iIzAwMCIgZmlsbC1vcGFjaXR5PSIuNSIvPjxjaXJjbGUgY3g9IjEzLjc1IiBjeT0iNy43NSIgcj0iLjc1IiBmaWxsPSIjMDAwIiBmaWxsLW9wYWNpdHk9Ii41Ii8+PGNpcmNsZSBjeD0iMTMuNzUiIGN5PSIxMS43NSIgcj0iLjc1IiBmaWxsPSIjMDAwIiBmaWxsLW9wYWNpdHk9Ii41Ii8+PGNpcmNsZSBjeD0iOS43NSIgY3k9IjExLjc1IiByPSIuNzUiIGZpbGw9IiMwMDAiIGZpbGwtb3BhY2l0eT0iLjUiLz48Y2lyY2xlIGN4PSI1Ljc1IiBjeT0iMTEuNzUiIHI9Ii43NSIgZmlsbD0iIzAwMCIgZmlsbC1vcGFjaXR5PSIuNSIvPjwvc3ZnPg==)}.ag-charts-icon-fill-color{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJtOC4wNzEgNC4wNi0uOTI0LS45MjQuNzA3LS43MDcgNy4yODggNy4yODgtNC45NSA0Ljk1YTMuNSAzLjUgMCAwIDEtNC45NSAwbC0xLjQxNC0xLjQxNGEzLjUgMy41IDAgMCAxIDAtNC45NXptLjcwNy43MDhMNC41MzYgOS4wMWEyLjUgMi41IDAgMCAwIDAgMy41MzZMNS45NSAxMy45NmEyLjUgMi41IDAgMCAwIDMuNTM1IDBsNC4yNDMtNC4yNDN6bTYuOSA3LjIwMi0uMzQ1LjM2My0uMzQ0LS4zNjNhLjUuNSAwIDAgMSAuNjg4IDBtLS4zNDUgMS4wOGE4IDggMCAwIDAtLjI4LjMyMyA0LjMgNC4zIDAgMCAwLS40MDkuNTgyYy0uMTEzLjIwMS0uMTQ0LjMyNi0uMTQ0LjM3OGEuODMzLjgzMyAwIDAgMCAxLjY2NyAwYzAtLjA1Mi0uMDMxLS4xNzctLjE0NC0uMzc4YTQuMyA0LjMgMCAwIDAtLjQxLS41ODIgOCA4IDAgMCAwLS4yOC0uMzIybS0uMzQ0LTEuMDguMzQ0LjM2My4zNDQtLjM2My4wMDIuMDAyLjAwNC4wMDQuMDEzLjAxMmE2IDYgMCAwIDEgLjIwNi4yMDhjLjEzMS4xMzYuMzA4LjMyNy40ODUuNTQ1LjE3Ni4yMTUuMzYzLjQ2Ny41MDcuNzI0LjEzNy4yNDMuMjczLjU1My4yNzMuODY4YTEuODMzIDEuODMzIDAgMSAxLTMuNjY3IDBjMC0uMzE1LjEzNi0uNjI1LjI3My0uODY4LjE0NC0uMjU3LjMzLS41MDkuNTA3LS43MjRhOSA5IDAgMCAxIC42NDUtLjcwOGwuMDQ2LS4wNDUuMDEzLS4wMTIuMDA0LS4wMDR6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-hollow-candlestick-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1vcGFjaXR5PSIuMTUiIGQ9Ik01IDVoM3YxMEg1eiIvPjxwYXRoIGZpbGw9IiMxMzE3MjIiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTcgMXYzaDJ2MTJIN3YzSDZ2LTNINFY0aDJWMXpNNSA1aDN2MTBINXptNyAyaDN2NmgtM3ptLTEgN1Y2aDJWMy4yNWgxVjZoMnY4aC0ydjIuNzVoLTFWMTR6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-horizontal-line,.ag-charts-icon-horizontal-line-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNLjUgOS41aDcuMzA2YTIuMjUgMi4yNSAwIDAgMSA0LjM4OCAwSDE5LjV2MWgtNy4zMDZhMi4yNSAyLjI1IDAgMCAxLTQuMzg4IDBILjV6bTkuNSAxLjc1YTEuMjUgMS4yNSAwIDEgMCAwLTIuNSAxLjI1IDEuMjUgMCAwIDAgMCAyLjUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-line-color{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTQuMjQyIDIuNzIyYy0uNjEyIDAtMS4yLjI0My0xLjYzMi42NzVsLTEuMzQzIDEuMzQ0YS41LjUgMCAwIDAtLjExMi4xMTJMNC4wNSAxMS45NTljLS4yMDcuMjA3LS4zNi40Ni0uNDQ2Ljc0di4wMDFsLS42OSAyLjc2N3YuMDAyYS44Mi44MiAwIDAgMCAxLjAyMiAxLjAyMWguMDAybDIuNjM0LS44MjJjLjI4LS4wODUuNTM0LS4yMzcuNzQtLjQ0M2w3LjEwNy03LjEwOGEuNS41IDAgMCAwIC4xMTItLjExMmwxLjM0My0xLjM0M2EyLjMwOCAyLjMwOCAwIDAgMC0xLjYzMi0zLjk0TTE0LjEyMiA3bDEuMDQ0LTEuMDQ1YTEuMzA4IDEuMzA4IDAgMSAwLTEuODQ5LTEuODVMMTIuMjcxIDUuMTV6bS0yLjU1OC0xLjE0Mi02LjgwNyA2LjgwOWEuOC44IDAgMCAwLS4xOTYuMzI1bC0uNzUgMi40NjggMi40Ny0uNzQ5YS44LjggMCAwIDAgLjMyNS0uMTk0bDYuODA4LTYuODF6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-line-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJtMTcuMzYyIDQuODczLTQuNTk0IDYuNjU0LTQuODUtMy4zMTctNC4yNTEgNi45NzctLjg1NC0uNTJMNy42MTIgNi43OWw0Ljg5OSAzLjM1IDQuMDI4LTUuODM2eiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-line-style-dashed{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMiA5aDR2MUgyem0xMiAwaDR2MWgtNHpNOCA5aDR2MUg4eiIvPjwvc3ZnPg==)}.ag-charts-icon-line-style-dotted{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48Y2lyY2xlIGN4PSIyLjUiIGN5PSI5LjUiIHI9Ii41IiBmaWxsPSIjMDAwIi8+PGNpcmNsZSBjeD0iNC41IiBjeT0iOS41IiByPSIuNSIgZmlsbD0iIzAwMCIvPjxjaXJjbGUgY3g9IjYuNSIgY3k9IjkuNSIgcj0iLjUiIGZpbGw9IiMwMDAiLz48Y2lyY2xlIGN4PSI4LjUiIGN5PSI5LjUiIHI9Ii41IiBmaWxsPSIjMDAwIi8+PGNpcmNsZSBjeD0iMTAuNSIgY3k9IjkuNSIgcj0iLjUiIGZpbGw9IiMwMDAiLz48Y2lyY2xlIGN4PSIxMi41IiBjeT0iOS41IiByPSIuNSIgZmlsbD0iIzAwMCIvPjxjaXJjbGUgY3g9IjE0LjUiIGN5PSI5LjUiIHI9Ii41IiBmaWxsPSIjMDAwIi8+PGNpcmNsZSBjeD0iMTYuNSIgY3k9IjkuNSIgcj0iLjUiIGZpbGw9IiMwMDAiLz48L3N2Zz4=)}.ag-charts-icon-line-style-solid{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMiA5aDE2djFIMnoiLz48L3N2Zz4=)}.ag-charts-icon-line-with-markers-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJtMTguMTk4IDQuODg4LTMuNTU2IDQuOTE4YTIuMjUgMi4yNSAwIDEgMS0zLjg2Ni43NWwtMS40MzItLjlhMi4yNCAyLjI0IDAgMCAxLTIuMDA5LjQzNWwtMy44MjggNi40MjgtLjg2LS41MTJMNi40NSA5LjYyM2EyLjI1IDIuMjUgMCAxIDEgMy41MS0uNzYxbDEuMzI5LjgzNWEyLjI0IDIuMjQgMCAwIDEgMi41NTctLjQ5N2wzLjU0Mi00Ljg5OHptLTQuOTYgNS4xNTNhMS4yNSAxLjI1IDAgMSAwLS42NCAyLjQxOSAxLjI1IDEuMjUgMCAwIDAgLjY0LTIuNDE5TTkuMSA4LjMyMXEuMDY2LS4xOTIuMDY3LS40MDRhMS4yNSAxLjI1IDAgMSAwLS4wNjcuNDA0IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-lock,.ag-charts-icon-locked{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTAuMjA3IDMuNzY0YTIuODk0IDIuODk0IDAgMCAwLTIuODk1IDIuODk0VjloNS43ODlWNi42NThhMi44OTQgMi44OTQgMCAwIDAtMi44OTUtMi44OTRNMTQuMSA5VjYuNjU4YTMuODk0IDMuODk0IDAgMSAwLTcuNzg5IDB2Mi4zNDlBMi41IDIuNSAwIDAgMCA0IDExLjV2M0EyLjUgMi41IDAgMCAwIDYuNSAxN2g4YTIuNSAyLjUgMCAwIDAgMi41LTIuNXYtM0EyLjUgMi41IDAgMCAwIDE0LjUgOXpNNi41IDEwQTEuNSAxLjUgMCAwIDAgNSAxMS41djNBMS41IDEuNSAwIDAgMCA2LjUgMTZoOGExLjUgMS41IDAgMCAwIDEuNS0xLjV2LTNhMS41IDEuNSAwIDAgMC0xLjUtMS41eiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-measurer-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0ibTQuNDYxIDEyLjcxIDEuNTMyLTEuNTMxIDEuNDE0IDEuNDE0LjcwNy0uNzA3TDYuNyAxMC40NzJsMS41MzItMS41MzMgMiAyIC43MDctLjcwNy0yLTIgNi4wMS02LjAxIDIuODMgMi44MjhMNS4wNSAxNy43NzggMi4yMjIgMTQuOTVsMS41MzItMS41MzIgMS40MTQgMS40MTQuNzA3LS43MDd6TS44MDggMTQuOTVsLjcwNy0uNzA3TDE0LjI0MyAxLjUxNWwuNzA3LS43MDcuNzA3LjcwNyAyLjgyOCAyLjgyOC43MDcuNzA3LS43MDcuNzA3TDUuNzU3IDE4LjQ4NWwtLjcwNy43MDctLjcwNy0uNzA3LTIuODI4LTIuODI4em0xMS4wNzgtNi44MzVMMTAuNDcgNi43bC43MDctLjcwNyAxLjQxNSAxLjQxNHptLjgyNC0zLjY1NCAxIDEgLjcwOC0uNzA3LTEtMXoiIGZpbGw9IiMxODFEMUYiLz48L3N2Zz4=)}.ag-charts-icon-note-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMyA0LjVBMS41IDEuNSAwIDAgMSA0LjUgM2gxMUExLjUgMS41IDAgMCAxIDE3IDQuNXY4YTEuNSAxLjUgMCAwIDEtMS41IDEuNWgtMy4yMWwtMS40NjkgMi41N2ExIDEgMCAwIDEtMS42ODIuMDg1TDcuMjQzIDE0SDQuNUExLjUgMS41IDAgMCAxIDMgMTIuNXpNNC41IDRhLjUuNSAwIDAgMC0uNS41djhhLjUuNSAwIDAgMCAuNS41aDMuMjU3bDIuMTk2IDMuMDc0TDExLjcxIDEzaDMuNzlhLjUuNSAwIDAgMCAuNS0uNXYtOGEuNS41IDAgMCAwLS41LS41eiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNi41IDYuNUEuNS41IDAgMCAxIDcgNmg2YS41LjUgMCAwIDEgMCAxSDdhLjUuNSAwIDAgMS0uNS0uNU02LjUgOS41QS41LjUgMCAwIDEgNyA5aDZhLjUuNSAwIDAgMSAwIDFIN2EuNS41IDAgMCAxLS41LS41IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-ohlc-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZD0iTTEzIDExaC0zdi0xaDNWM2gxdjJoNHYxaC00djExaC0xek02IDE3di0yaDN2LTFINlY0SDV2MUgydjFoM3YxMXoiLz48L3N2Zz4=)}.ag-charts-icon-pan-end{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZD0ibTYuNjQ2IDEzLjgxMy0uMzUzLjM1NC43MDcuNzA3LjM1NC0uMzU0ek0xMS4xNjYgMTBsLjM1NC4zNTQuMzU0LS4zNTQtLjM1NC0uMzU0ek03LjM1NSA1LjQ4IDcgNS4xMjZsLS43MDcuNzA3LjM1My4zNTR6bTAgOS4wNCA0LjE2Ni00LjE2Ni0uNzA3LS43MDgtNC4xNjcgNC4xNjd6bTQuMTY2LTQuODc0TDcuMzU0IDUuNDhsLS43MDguNzA3IDQuMTY3IDQuMTY3ek0xMy4wODMgNXYxMGgxVjV6Ii8+PC9zdmc+)}.ag-charts-icon-pan-left{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTIuNzkgNS44MzMgOC42MjUgMTBsNC4xNjYgNC4xNjctLjcwNy43MDdMNy4yMSAxMGw0Ljg3My00Ljg3NHoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-pan-right{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNy4yMSAxNC4xNjcgMTEuMzc2IDEwIDcuMjEgNS44MzNsLjcwNy0uNzA3TDEyLjc5IDEwbC00Ljg3MyA0Ljg3NHoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-pan-start{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZD0iTTYgNXYxMGgxVjV6TTkuNjI0IDEwbDQuMTY2LTQuMTY3LS43MDctLjcwN0w4LjIxIDEwbDQuODc0IDQuODc0LjcwNy0uNzA3eiIvPjwvc3ZnPg==)}.ag-charts-icon-parallel-channel,.ag-charts-icon-parallel-channel-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTcuNzIgNS4zMzFBMi4yNSAyLjI1IDAgMSAwIDE0LjcwNSAzLjZsLTkuNDkgNC41NjJhMi4yNSAyLjI1IDAgMSAwIC4yMDkgMS4wMWw5LjY2Mi00LjY0NmEyLjI1IDIuMjUgMCAwIDAgMi42MzQuODA1bS4zNzMtMi41NDdhMS4yNSAxLjI1IDAgMSAxLTIuMzM4Ljg4NSAxLjI1IDEuMjUgMCAwIDEgMi4zMzgtLjg4NU00LjM0MyA4LjY3YTEuMjUgMS4yNSAwIDEgMS0yLjMzOC44ODUgMS4yNSAxLjI1IDAgMCAxIDIuMzM4LS44ODVNNS4zMDcgMTYuNzI4YTIuMjUgMi4yNSAwIDEgMS0uNTI1LS44NThsOS45MjMtNC43N2EyLjI1IDIuMjUgMCAxIDEgLjM4MS45MjZ6bS0uOTY0LjI3NGExLjI1IDEuMjUgMCAxIDEtMi4zMzguODg1IDEuMjUgMS4yNSAwIDAgMSAyLjMzOC0uODg1bTEzLjAyMy01LjEwNmExLjI1IDEuMjUgMCAxIDAtLjg4NS0yLjMzOSAxLjI1IDEuMjUgMCAwIDAgLjg4NSAyLjMzOSIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-position-bottom{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBmaWxsLW9wYWNpdHk9Ii4yNSIgZD0iTTMgMTBoMTR2MUgzem0zLTNoOHYxSDZ6Ii8+PHBhdGggZmlsbD0iIzAwMCIgZD0iTTYgMTNoOHYxSDZ6Ii8+PC9zdmc+)}.ag-charts-icon-position-center{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMyAxMGgxNHYxSDN6Ii8+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1vcGFjaXR5PSIuMjUiIGQ9Ik02IDdoOHYxSDZ6bTAgNmg4djFINnoiLz48L3N2Zz4=)}.ag-charts-icon-position-top{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBmaWxsLW9wYWNpdHk9Ii4yNSIgZD0iTTMgMTBoMTR2MUgzeiIvPjxwYXRoIGZpbGw9IiMwMDAiIGQ9Ik02IDdoOHYxSDZ6Ii8+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1vcGFjaXR5PSIuMjUiIGQ9Ik02IDEzaDh2MUg2eiIvPjwvc3ZnPg==)}.ag-charts-icon-price-label-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNC41IDNBMS41IDEuNSAwIDAgMCAzIDQuNVYxM2ExLjUgMS41IDAgMCAwIDEuNSAxLjVoLjgzM3YuMDU3Yy4yNDItLjI5OS41OTctLjUwMyAxLS41NDhWMTMuNUg0LjVBLjUuNSAwIDAgMSA0IDEzVjQuNWEuNS41IDAgMCAxIC41LS41aDExYS41LjUgMCAwIDEgLjUuNXY4YS41LjUgMCAwIDEtLjUuNWgtNC44MThsLS4xMjYuMDg0YTI2IDI2IDAgMCAwLTIuMjI1IDEuNjg1bC0uMzIuMjY1LS4wNjguMDU2YTEuNSAxLjUgMCAwIDEtMi42MDkgMS4zNTRjLjAzMy43NjMuOTA1IDEuMjM4IDEuNTYuNzU2LjY0Ni0uNDc0IDEuMjEtLjk0MyAxLjc2MS0xLjRsLjMxMy0uMjZBMjYgMjYgMCAwIDEgMTAuOTg2IDE0SDE1LjVhMS41IDEuNSAwIDAgMCAxLjUtMS41di04QTEuNSAxLjUgMCAwIDAgMTUuNSAzeiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNOC43MTYgMTQuODE1YTIuMjUgMi4yNSAwIDEgMS00LjIxIDEuNTkzIDIuMjUgMi4yNSAwIDAgMSA0LjIxLTEuNTkzbS0xLjY2MiAxLjk2NmExLjI1IDEuMjUgMCAxIDAtLjg4NS0yLjMzOSAxLjI1IDEuMjUgMCAwIDAgLjg4NSAyLjMzOSIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-price-range-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNOS4wNDYgMTVWNS44NzdoLjk0MlYxNXoiIGZpbGw9IiMxODFEMUYiLz48cGF0aCBkPSJNOS4wNDYgMTVWNS44NzdoLjk0MlYxNXoiIGZpbGw9IiMxODFEMUYiLz48cGF0aCBkPSJNOS41IDYuMjI4IDcuMTY3IDguMzc2IDYuNSA3Ljc2MiA5LjUgNWwzIDIuNzYyLS42NjcuNjE0eiIgZmlsbD0iIzAwMCIvPjxwYXRoIGQ9Ik0yIDE4di0xaDE2djF6TTIgM1YyaDE2djF6IiBmaWxsPSIjMTgxRDFGIi8+PC9zdmc+)}.ag-charts-icon-reset{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTIuMDQgNC40NDVhNS44MSA1LjgxIDAgMCAwLTcuMjU3IDIuNDUzLjUuNSAwIDAgMS0uODY1LS41MDJBNi44MSA2LjgxIDAgMSAxIDMgOS44MTNhLjUuNSAwIDAgMSAxIDAgNS44MSA1LjgxIDAgMSAwIDguMDQtNS4zNjgiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjxwYXRoIGZpbGw9IiMwMDAiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTQuMjg5IDMuMDAyYS41LjUgMCAwIDEgLjUuNXYyLjY1NWgyLjY1NWEuNS41IDAgMCAxIDAgMUg0LjI5YS41LjUgMCAwIDEtLjUtLjVWMy41MDJhLjUuNSAwIDAgMSAuNS0uNSIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-settings{--icon: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIgc3R5bGU9ImZpbGwtcnVsZTpldmVub2RkIj48cGF0aCBkPSJNMTAgMTNhMyAzIDAgMSAwIDAtNiAzIDMgMCAwIDAgMCA2bTAtMWEyIDIgMCAxIDEtLjAwMS0zLjk5OUEyIDIgMCAwIDEgMTAgMTIiLz48cGF0aCBkPSJNMi4zMSAxNC4zNDVjLS44MTctMS40OTEuMDI3LTIuNDk5LjQ3NC0yLjg2NS41MzEtLjQzNC45NjktLjM2NS45NzItMS40OC0uMDAzLTEuMTE1LS40NDEtMS4wNDYtLjk3Mi0xLjQ4MS0uNDU0LS4zNzEtMS4zMTctMS40MDUtLjQzNC0yLjkzNmwuMDA1LS4wMDljLjg4NC0xLjUyIDIuMjA3LTEuMjkgMi43NTUtMS4wODMuNjQxLjI0My44MDEuNjU2IDEuNzY4LjEwMS45NjQtLjU2LjY4Ni0uOTA0Ljc5Ni0xLjU4Mi4wOTQtLjU3OC41NTktMS44NDMgMi4zMjYtMS44NDNoLjAxYzEuNzU5LjAwNSAyLjIyMiAxLjI2NiAyLjMxNiAxLjg0My4xMS42NzgtLjE2OCAxLjAyMi43OTYgMS41ODIuOTY3LjU1NSAxLjEyNy4xNDIgMS43NjgtLjEwMS41NDktLjIwOCAxLjg3Ni0uNDM4IDIuNzYgMS4wOTJzLjAyIDIuNTY1LS40MzQgMi45MzZjLS41MzEuNDM1LS45NjkuMzY2LS45NzIgMS40ODEuMDAzIDEuMTE1LjQ0MSAxLjA0Ni45NzIgMS40OC40NTQuMzcyIDEuMzE3IDEuNDA2LjQzNCAyLjkzN2wtLjAwNS4wMDljLS44ODQgMS41Mi0yLjIwNyAxLjI5LTIuNzU1IDEuMDgzLS42NDEtLjI0My0uODAxLS42NTYtMS43NjgtLjEwMS0uOTY0LjU2LS42ODYuOTA0LS43OTYgMS41ODEtLjA5NC41NzktLjU1OSAxLjg0NC0yLjMyNiAxLjg0NGgtLjAxYy0xLjc1OS0uMDA1LTIuMjIyLTEuMjY2LTIuMzE2LTEuODQ0LS4xMS0uNjc3LjE2OC0xLjAyMS0uNzk2LTEuNTgxLS45NjctLjU1NS0xLjEyNy0uMTQyLTEuNzY4LjEwMS0uNTQ5LjIwOC0xLjg3Ni40MzgtMi43Ni0xLjA5MmwtLjAyLS4wMzZ6TTkuOTg0IDIuMTYySDEwYzEuMzU1IDAgMS4zNDIgMS4wMzkgMS4zNTMgMS40MjUuMDA4LjMxMi4wNCAxLjE2IDEuMjU5IDEuODcybC4wMTUuMDA4YzEuMjI1LjcgMS45NzYuMzA0IDIuMjUxLjE1NS4zMzctLjE4MyAxLjIyNi0uNzExIDEuOTAyLjQ0NWwuMDA4LjAxNGMuNjc4IDEuMTczLS4yMjkgMS42ODItLjU1OCAxLjg4NC0uMjY2LjE2My0uOTg0LjYxNS0uOTkxIDIuMDI3di4wMTZjLjAwNyAxLjQxMi43MjUgMS44NjQuOTkxIDIuMDI3LjMyOC4yMDEgMS4yMjkuNzA3LjU2NiAxLjg3bC0uMDA4LjAxNGMtLjY3NyAxLjE3NC0xLjU3MS42NDMtMS45MS40NTktLjI3NS0uMTQ5LTEuMDI2LS41NDUtMi4yNTEuMTU0bC0uMDE1LjAwOWMtMS4yMTkuNzEyLTEuMjUxIDEuNTYtMS4yNTkgMS44NzItLjAxMS4zODYuMDAyIDEuNDI1LTEuMzUzIDEuNDI1cy0xLjM0Mi0xLjAzOS0xLjM1My0xLjQyNWMtLjAwOC0uMzEyLS4wNC0xLjE2LTEuMjU5LTEuODcybC0uMDE1LS4wMDljLTEuMjI1LS42OTktMS45NzYtLjMwMy0yLjI1MS0uMTU0LS4zMzYuMTgzLTEuMjE5LjcwNi0xLjg5NC0uNDMybC0uMDE2LS4wMjdjLS42NzgtMS4xNzQuMjI5LTEuNjgyLjU1OC0xLjg4NC4yNjYtLjE2My45ODQtLjYxNS45OTEtMi4wMjd2LS4wMTZjLS4wMDctMS40MTItLjcyNS0xLjg2NC0uOTkxLTIuMDI3LS4zMjgtLjIwMS0xLjIyOS0uNzA3LS41NjYtMS44N2wuMDA4LS4wMTRjLjY3Ny0xLjE3NCAxLjU3MS0uNjQzIDEuOTEtLjQ1OS4yNzUuMTQ5IDEuMDI2LjU0NSAyLjI1MS0uMTU1bC4wMTUtLjAwOGMxLjIxOS0uNzEyIDEuMjUxLTEuNTYgMS4yNTktMS44NzIuMDEtLjM4NC0uMDAyLTEuNDE3IDEuMzM3LTEuNDI1Ii8+PC9zdmc+)}.ag-charts-icon-step-line-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzE4MUQxRiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNiA0aDV2OGgzVjhoNXYxaC00djRoLTVWNUg3djEwSDJ2LTFoNHoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-text-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00IDRIMTZWN0gxNVY1SDEwLjVWMTVIMTRWMTZINlYxNUg5LjVWNUg1VjdINFY0WiIgZmlsbD0iYmxhY2siLz4KPC9zdmc+Cg==)}.ag-charts-icon-trend-line,.ag-charts-icon-trend-line-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNS4zMTQgMTAuOTM4YTIuMjUgMi4yNSAwIDEgMSAuMDEtMWg5LjM1MmEyLjI1IDIuMjUgMCAxIDEgLjAxIDF6bS0yLjE4OS43MjlhMS4yNSAxLjI1IDAgMSAwIDAtMi41IDEuMjUgMS4yNSAwIDAgMCAwIDIuNW0xMy43NSAwYTEuMjUgMS4yNSAwIDEgMCAwLTIuNSAxLjI1IDEuMjUgMCAwIDAgMCAyLjUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-unlock,.ag-charts-icon-unlocked{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTAuNjUxIDMuNWEyLjg5NCAyLjg5NCAwIDAgMC0yLjg5NCAyLjg5NFY5SDE0LjVhMi41IDIuNSAwIDAgMSAyLjUgMi41djNhMi41IDIuNSAwIDAgMS0yLjUgMi41aC04QTIuNSAyLjUgMCAwIDEgNCAxNC41di0zQTIuNSAyLjUgMCAwIDEgNi41IDloLjI1N1Y2LjM5NGEzLjg5NCAzLjg5NCAwIDEgMSA3Ljc4OSAwIC41LjUgMCAwIDEtMSAwQTIuODk0IDIuODk0IDAgMCAwIDEwLjY1IDMuNU02LjUgMTBBMS41IDEuNSAwIDAgMCA1IDExLjV2M0ExLjUgMS41IDAgMCAwIDYuNSAxNmg4YTEuNSAxLjUgMCAwIDAgMS41LTEuNXYtM2ExLjUgMS41IDAgMCAwLTEuNS0xLjV6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-vertical-line,.ag-charts-icon-vertical-line-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTAuNSA3LjgwNmEyLjI1IDIuMjUgMCAwIDEgMCA0LjM4OFYxOS41aC0xdi03LjMwNmEyLjI1IDIuMjUgMCAwIDEgMC00LjM4OFYuNWgxem0tLjUuOTQ0YTEuMjUgMS4yNSAwIDEgMSAwIDIuNSAxLjI1IDEuMjUgMCAwIDEgMC0yLjUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-zoom-in{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZD0iTTEwIDUuNWEuNS41IDAgMCAxIC41LjV2My41aDMuODc1YS41LjUgMCAwIDEgMCAxSDEwLjV2NC4yNWEuNS41IDAgMSAxLTEgMFYxMC41SDUuNjI1YS41LjUgMCAxIDEgMC0xSDkuNVY2YS41LjUgMCAwIDEgLjUtLjUiLz48L3N2Zz4=)}.ag-charts-icon-zoom-out{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNS41IDEwYS41LjUgMCAwIDEgLjUtLjVoOGEuNS41IDAgMCAxIDAgMUg2YS41LjUgMCAwIDEtLjUtLjUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-high-low-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNyA0aDJ2MTJINFY0aDNNNSA1aDN2MTBINXpNMTEgMTRWNmg1djhoLTVtMS03aDN2NmgtM3oiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-hlc-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJtMTguMTYzIDEuODM3LTUuMzM0IDExLjYyMUw2Ljk1NyA4LjEybC00LjE5OSA5LjYyMi0uOTE2LS40IDQuNzU2LTEwLjlMMTIuNDkgMTEuOCAxNy4yNTQgMS40MnoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjxwYXRoIGZpbGw9IiMwMDAiIGZpbGwtb3BhY2l0eT0iLjQiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTUuODI1IDIuNzA0LjU1IDEzLjc4NWwuOTAyLjQzIDQuNzI0LTkuOTE5IDYuMDM0IDUuMDI5IDMuMjU1LTguMTQtLjkyOC0uMzctMi43NDUgNi44NnptNy44NTIgMTQuNjM2IDUuNzgtMTMuMTM5LS45MTUtLjQwMi01LjIxOSAxMS44Ni02LjAwNS01LjUwNC0zLjI3OCA3LjY0OC45Mi4zOTQgMi43MjItNi4zNTJ6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-zoom-in-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik04Ljc1IDQuNWEuNzUuNzUgMCAwIDAtMS41IDB2Mi43NUg0LjVhLjc1Ljc1IDAgMCAwIDAgMS41aDIuNzV2Mi43NWEuNzUuNzUgMCAwIDAgMS41IDBWOC43NWgyLjc1YS43NS43NSAwIDAgMCAwLTEuNUg4Ljc1VjQuNVoiIGZpbGw9IiMwMDAiLz48L3N2Zz4=)}.ag-charts-icon-zoom-out-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0zLjc1IDhhLjc1Ljc1IDAgMCAxIC43NS0uNzVoN2EuNzUuNzUgMCAwIDEgMCAxLjVoLTdBLjc1Ljc1IDAgMCAxIDMuNzUgOFoiIGZpbGw9IiMwMDAiLz48L3N2Zz4=)}.ag-charts-icon-zoom-in-alt,.ag-charts-icon-zoom-in-alt-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLXpvb20taW4iPjxjaXJjbGUgY3g9IjExIiBjeT0iMTEiIHI9IjgiLz48bGluZSB4MT0iMjEiIHgyPSIxNi42NSIgeTE9IjIxIiB5Mj0iMTYuNjUiLz48bGluZSB4MT0iMTEiIHgyPSIxMSIgeTE9IjgiIHkyPSIxNCIvPjxsaW5lIHgxPSI4IiB4Mj0iMTQiIHkxPSIxMSIgeTI9IjExIi8+PC9zdmc+)}.ag-charts-icon-zoom-out-alt,.ag-charts-icon-zoom-out-alt-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLXpvb20tb3V0Ij48Y2lyY2xlIGN4PSIxMSIgY3k9IjExIiByPSI4Ii8+PGxpbmUgeDE9IjIxIiB4Mj0iMTYuNjUiIHkxPSIyMSIgeTI9IjE2LjY1Ii8+PGxpbmUgeDE9IjgiIHgyPSIxNCIgeTE9IjExIiB5Mj0iMTEiLz48L3N2Zz4=)}.ag-charts-icon-reset-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00LjQxMiA0LjA1OCAyLjc1IDIuMzk2VjYuNzVoLjc0NGEuNzYuNzYgMCAwIDAgLjAxMiAwaDMuNTk4TDUuNDc4IDUuMTI1YTQuMTI1IDQuMTI1IDAgMCAxIDIuNTIzLS44NzUgMy43NSAzLjc1IDAgMSAxLTMuMTE5IDUuODMzLjc1Ljc1IDAgMCAwLTEuMjQ3LjgzNEE1LjI1IDUuMjUgMCAxIDAgOCAyLjc1aC0uMDAzYTUuNjI1IDUuNjI1IDAgMCAwLTMuNTg1IDEuMzA4WiIgZmlsbD0iIzAwMCIvPjwvc3ZnPg==)}.ag-charts-icon-pan-left-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xMC4wMyA0LjQ3YS43NS43NSAwIDAgMSAwIDEuMDZMNy41NiA4bDIuNDcgMi40N2EuNzUuNzUgMCAxIDEtMS4wNiAxLjA2bC0zLTNhLjc1Ljc1IDAgMCAxIDAtMS4wNmwzLTNhLjc1Ljc1IDAgMCAxIDEuMDYgMFoiIGZpbGw9IiMwMDAiLz48L3N2Zz4=)}.ag-charts-icon-pan-right-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik01Ljk3IDExLjUzYS43NS43NSAwIDAgMSAwLTEuMDZMOC40NCA4IDUuOTcgNS41M2EuNzUuNzUgMCAwIDEgMS4wNi0xLjA2bDMgM2EuNzUuNzUgMCAwIDEgMCAxLjA2bC0zIDNhLjc1Ljc1IDAgMCAxLTEuMDYgMFoiIGZpbGw9IiMwMDAiLz48L3N2Zz4=)}.ag-charts-icon-pan-start-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLWNoZXZyb24tZmlyc3QiPjxwYXRoIGQ9Im0xNyAxOC02LTYgNi02Ii8+PHBhdGggZD0iTTcgNnYxMiIvPjwvc3ZnPg==)}.ag-charts-icon-pan-end-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLWNoZXZyb24tbGFzdCI+PHBhdGggZD0ibTcgMTggNi02LTYtNiIvPjxwYXRoIGQ9Ik0xNyA2djEyIi8+PC9zdmc+)}.ag-charts-icon-trend-line-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGNpcmNsZSBjeD0iMi41IiBjeT0iOCIgcj0iMS43NSIgc3Ryb2tlPSIjMDAwIiBzdHJva2Utd2lkdGg9IjEuNSIvPjxjaXJjbGUgY3g9IjEzLjUiIGN5PSI4IiByPSIxLjc1IiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iMS41Ii8+PHBhdGggc3Ryb2tlPSIjMDAwIiBzdHJva2Utd2lkdGg9IjEuNSIgZD0iTTQgOGg4Ii8+PC9zdmc+)}.ag-charts-icon-horizontal-line-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xMC4zODYgOC43NWEyLjUwMSAyLjUwMSAwIDAgMS00Ljc3MiAwSC43NWEuNzUuNzUgMCAwIDEgMC0xLjVoNC44NjRhMi41MDEgMi41MDEgMCAwIDEgNC43NzIgMGg0Ljg2NGEuNzUuNzUgMCAwIDEgMCAxLjVoLTQuODY0Wk05IDhhMSAxIDAgMSAxLTIgMCAxIDEgMCAwIDEgMiAwWiIgZmlsbD0iIzAwMCIvPjwvc3ZnPg==)}.ag-charts-icon-vertical-line-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik04Ljc1IDUuNjE0YTIuNTAxIDIuNTAxIDAgMCAxIDAgNC43NzJ2NC44NjRhLjc1Ljc1IDAgMCAxLTEuNSAwdi00Ljg2NGEyLjUwMSAyLjUwMSAwIDAgMSAwLTQuNzcyVi43NWEuNzUuNzUgMCAwIDEgMS41IDB2NC44NjRaTTggN2ExIDEgMCAxIDEgMCAyIDEgMSAwIDAgMSAwLTJaIiBmaWxsPSIjMDAwIi8+PC9zdmc+)}.ag-charts-icon-parallel-channel-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTciIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNC40MjQgNC45MmEyLjUgMi41IDAgMSAwLTMuMzc3LTIuMTRsLTYuNjMgMi45YTIuNTAxIDIuNTAxIDAgMSAwIC42MDcgMS4zNzJsNi41ODUtMi44OGEyLjUwMSAyLjUwMSAwIDAgMCAyLjgxNS43NDhabS4wNS0yLjY5M2ExIDEgMCAxIDEtMS44Ny43MDggMSAxIDAgMCAxIDEuODctLjcwOFptLTExIDQuNzVhMSAxIDAgMSAxLTEuODcuNzA4IDEgMSAwIDAgMSAxLjg3LS43MDhabTEuNTUgNi4wNzVhMi41MDEgMi41MDEgMCAxIDEtLjYwNy0xLjM3Mmw2LjYzLTIuOWEyLjUwMSAyLjUwMSAwIDEgMSAuNTYyIDEuMzkxbC02LjU4NSAyLjg4Wm0tMS41NS0uMDc1YTEgMSAwIDEgMS0xLjg3LjcwOCAxIDEgMCAwIDEgMS44Ny0uNzA4Wm0xMC40Mi0zLjQ2YTEgMSAwIDEgMC0uNzA5LTEuODcgMSAxIDAgMCAwIC43MDggMS44N1oiIGZpbGw9IiMwMDAiLz48L3N2Zz4=)}.ag-charts-icon-disjoint-channel-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTciIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNC40MjQgNC45MmEyLjUgMi41IDAgMSAwLTMuMzgzLTIuNDUzTDQuNjkgNC4wNTVhMi41IDIuNSAwIDEgMCAuMzQ0IDEuNDZsNi4zOTItMS41OThhMi41MDEgMi41MDEgMCAwIDAgMyAxLjAwM1ptLjA1LTIuNjkzYTEgMSAwIDEgMS0xLjg3LjcwOCAxIDEgMCAwIDEgMS44Ny0uNzA4Wm0tMTEgMi43NWExIDEgMCAxIDEtMS44Ny43MDggMSAxIDAgMCAxIDEuODctLjcwOFptMS41NiA1LjQyYTIuNSAyLjUgMCAxIDAtLjM0NSAxLjQ2MWw2LjM1MiAxLjU4OGEyLjUgMi41IDAgMSAwIC4zODQtMS40NWwtNi4zOTItMS41OThabS0xLjU2LjUzOGExIDEgMCAxIDAtMS44Ny0uNzA4IDEgMSAwIDAgMCAxLjg3LjcwOFptMTAuNDIgMS40NjFhMSAxIDAgMSAxLS43MDkgMS44NyAxIDEgMCAwIDEgLjcwOC0xLjg3WiIgZmlsbD0iIzAwMCIvPjwvc3ZnPg==)}.ag-charts-icon-line-color-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgY2xpcC1wYXRoPSJ1cmwoI2EpIj48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEyLjc4OC41ODNhMi42MyAyLjYzIDAgMCAwLTEuODYuNzdMOS41NDQgMi43MzhhLjc1Ny43NTcgMCAwIDAtLjE0LjE0TDIuMDMyIDEwLjI1di4wMDFjLS4yNDIuMjQxLS40Mi41MzgtLjUyLjg2NGwtLjAwMi4wMDItLjg4IDIuOTAyLS4wMDEuMDAzYTEuMDgzIDEuMDgzIDAgMCAwIDEuMzUgMS4zNDdoLjAwMWwyLjkwMi0uODhoLjAwMWMuMzI2LS4xLjYyMy0uMjc3Ljg2NS0uNTE4di0uMDAxbDcuMzc1LTcuMzc2YS43NjMuNzYzIDAgMCAwIC4xMzktLjEzOWwxLjM4NC0xLjM4NEEyLjYzIDIuNjMgMCAwIDAgMTIuNzg4LjU4M1ptLS4xMjYgNC4zNTIuOTI0LS45MjRhMS4xMyAxLjEzIDAgMCAwLTEuNTk3LTEuNTk3bC0uOTI0LjkyNCAxLjU5NyAxLjU5N1ptLTIuNjU3LS41MzYtNi45MTMgNi45MTRIMy4wOWEuNTgzLjU4MyAwIDAgMC0uMTQ2LjI0MmwtLjY1MyAyLjE1MyAyLjE1NS0uNjU0YS41ODMuNTgzIDAgMCAwIC4yNDEtLjE0NGw2LjkxNC02LjkxNC0xLjU5Ny0xLjU5N1oiIGZpbGw9IiMwMDAiLz48L2c+PGRlZnM+PGNsaXBQYXRoIGlkPSJhIj48cGF0aCBmaWxsPSIjZmZmIiBkPSJNMCAwaDE2djE2SDB6Ii8+PC9jbGlwUGF0aD48L2RlZnM+PC9zdmc+)}.ag-charts-icon-delete-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik02LjA4MyAyLjY2N2MwLS4wOS4wNTMtLjI0Mi4xOTctLjM4Ny4xNDUtLjE0NC4yOTctLjE5Ny4zODctLjE5N2gyLjY2N2MuMDg5IDAgLjI0MS4wNTMuMzg2LjE5Ny4xNDUuMTQ1LjE5Ny4yOTcuMTk3LjM4N3YuNTgzSDYuMDg0di0uNTgzWk01LjMzIDQuNzVIMTEuOTE3djguNTgzYzAgLjA5LS4wNTIuMjQyLS4xOTcuMzg3LS4xNDUuMTQ0LS4yOTcuMTk3LS4zODYuMTk3SDQuNjY3Yy0uMDkgMC0uMjQyLS4wNTMtLjM4Ny0uMTk3LS4xNDQtLjE0NS0uMTk3LS4yOTctLjE5Ny0uMzg3VjQuNzVINS4zM1ptLS43NDUtMS41di0uNTgzYzAtLjU3OC4yOC0xLjA5Mi42MzYtMS40NDcuMzU1LS4zNTYuODctLjYzNyAxLjQ0Ny0uNjM3aDIuNjY3Yy41NzcgMCAxLjA5MS4yODEgMS40NDcuNjM3LjM1NS4zNTUuNjM2Ljg3LjYzNiAxLjQ0N3YuNTgzSDE0YS43NS43NSAwIDAgMSAwIDEuNWgtLjU4M3Y4LjU4M2MwIC41NzgtLjI4MSAxLjA5Mi0uNjM2IDEuNDQ3LS4zNTYuMzU2LS44Ny42MzctMS40NDcuNjM3SDQuNjY3Yy0uNTc3IDAtMS4wOTItLjI4MS0xLjQ0Ny0uNjM3LS4zNTUtLjM1NS0uNjM3LS44Ny0uNjM3LTEuNDQ3VjQuNzVIMmEuNzUuNzUgMCAwIDEgMC0xLjVoMi41ODNabTIuMDgzIDMuMzMzYS43NS43NSAwIDAgMSAuNzUuNzV2NGEuNzUuNzUgMCAxIDEtMS41IDB2LTRhLjc1Ljc1IDAgMCAxIC43NS0uNzVabTMuNDE3Ljc1YS43NS43NSAwIDAgMC0xLjUgMHY0YS43NS43NSAwIDEgMCAxLjUgMHYtNFoiIGZpbGw9IiMwMDAiLz48L3N2Zz4=)}.ag-charts-icon-lock-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik02LjE3MyAyLjg0YTIuNTgzIDIuNTgzIDAgMCAxIDQuNDEgMS44Mjd2MS45MTZINS40MTZWNC42NjdjMC0uNjg1LjI3My0xLjM0My43NTctMS44MjdaTTMuOTE3IDYuNTgzVjQuNjY3YTQuMDgzIDQuMDgzIDAgMCAxIDguMTY2IDB2MS45MTZoLjU4NGMxLjE1IDAgMi4wODMuOTMzIDIuMDgzIDIuMDg0djQuNjY2YzAgMS4xNS0uOTMzIDIuMDg0LTIuMDgzIDIuMDg0SDMuMzMzYTIuMDgzIDIuMDgzIDAgMCAxLTIuMDgzLTIuMDg0VjguNjY3YzAtMS4xNTEuOTMzLTIuMDg0IDIuMDgzLTIuMDg0aC41ODNabTcuNDE2IDEuNWgtOGEuNTgzLjU4MyAwIDAgMC0uNTgzLjU4NHY0LjY2NmMwIC4zMjIuMjYxLjU4NC41ODMuNTg0aDkuMzM0YS41ODMuNTgzIDAgMCAwIC41ODMtLjU4NFY4LjY2N2EuNTgzLjU4MyAwIDAgMC0uNTgzLS41ODRoLTEuMzM0WiIgZmlsbD0iIzAwMCIvPjwvc3ZnPg==)}.ag-charts-icon-unlock-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTciIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik02LjkyMyAyLjg0YTIuNTgzIDIuNTgzIDAgMCAxIDMuNjUzIDAgMyAzIDAgMCAxIC41Ny43OThjLjEzNC4yNzguMTcuNDc0LjE3LjU0NWEuNzUuNzUgMCAwIDAgMS41IDBjMC0uMzgxLS4xMzItLjgwOS0uMzItMS4xOThhNC41MDEgNC41MDEgMCAwIDAtLjg1OS0xLjIwNiA0LjA4MyA0LjA4MyAwIDAgMC02Ljk3IDIuODg4djEuOTE2aC0uNTg0QzIuOTMzIDYuNTgzIDIgNy41MTYgMiA4LjY2N3Y0LjY2NmMwIDEuMTUuOTMzIDIuMDg0IDIuMDgzIDIuMDg0aDkuMzM0YzEuMTUgMCAyLjA4My0uOTMzIDIuMDgzLTIuMDg0VjguNjY3YzAtMS4xNTEtLjkzMy0yLjA4NC0yLjA4My0yLjA4NGgtNy4yNVY0LjY2N2MwLS42ODUuMjcyLTEuMzQzLjc1Ni0xLjgyN1pNNS40MTcgOC4wODNINC4wODJhLjU4My41ODMgMCAwIDAtLjU4My41ODR2NC42NjZjMCAuMzIyLjI2MS41ODQuNTgzLjU4NGg5LjMzNGEuNTgzLjU4MyAwIDAgMCAuNTgzLS41ODRWOC42NjdhLjU4My41ODMgMCAwIDAtLjU4My0uNTg0aC04WiIgZmlsbD0iIzAwMCIvPjwvc3ZnPg==)}.ag-charts-icon-plus-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLXBsdXMiPjxwYXRoIGQ9Ik01IDEyaDE0Ii8+PHBhdGggZD0iTTEyIDV2MTQiLz48L3N2Zz4=)}.ag-charts-icon-crossline-add-line-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNOC43NSA0LjVhLjc1Ljc1IDAgMCAwLTEuNSAwdjIuNzVINC41YS43NS43NSAwIDAgMCAwIDEuNWgyLjc1djIuNzVhLjc1Ljc1IDAgMCAwIDEuNSAwVjguNzVoMi43NWEuNzUuNzUgMCAwIDAgMC0xLjVIOC43NXoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-input{--input-layer-active: 1;--input-layer-focus: 2;color:inherit;font-family:var(--ag-charts-input-font-family);font-size:var(--ag-charts-input-font-size);transition-duration:var(--ag-charts-input-transition-duration);transition-property:none;transition-timing-function:var(--ag-charts-input-transition-timing-function)}.ag-charts-input:focus-visible{outline:var(--ag-charts-input-focus-outline);box-shadow:var(--ag-charts-input-focus-box-shadow);z-index:var(--input-layer-focus)}.ag-charts-button{background:var(--ag-charts-input-background-color);border:1px solid var(--ag-charts-input-border-color);border-radius:var(--ag-charts-input-border-radius);cursor:pointer;padding:var(--ag-charts-input-padding);transition-property:background,border-color}.ag-charts-button:hover{background:var(--ag-charts-input-background-color--hover)}.ag-charts-button:has(.ag-charts-icon){padding:2px}.ag-charts-checkbox{appearance:none;background:var(--ag-charts-input-checkbox-background-color);border-radius:9px;cursor:pointer;height:18px;margin:0;transition-duration:var(--ag-charts-input-transition-duration--fast);transition-property:margin;width:29px}.ag-charts-checkbox:before{display:block;background:var(--ag-charts-input-background-color);border-radius:7px;content:\" \";height:14px;margin:2px;transition-duration:var(--ag-charts-input-transition-duration--fast);transition-property:margin;transition-timing-function:var(--ag-charts-input-transition-easing);width:14px}.ag-charts-checkbox:checked{background:var(--ag-charts-input-checkbox-background-color--checked)}.ag-charts-checkbox:checked:before{margin-left:13px}.ag-charts-select{background:var(--ag-charts-input-background-color);border:1px solid var(--ag-charts-input-border-color);border-radius:var(--ag-charts-input-border-radius);padding:3px 2px 4px;font-size:inherit}.ag-charts-textarea{--line-height: 1.38;background:var(--ag-charts-input-background-color);border:1px solid var(--ag-charts-input-border-color);border-radius:var(--ag-charts-input-border-radius);line-height:var(--line-height);font-family:var(--ag-charts-input-font-family);font-size:var(--ag-charts-input-font-size);padding:var(--ag-charts-input-padding-large) var(--ag-charts-input-padding)}.ag-charts-textarea[placeholder]:empty:before{color:var(--ag-charts-input-placeholder);content:attr(placeholder)}.ag-charts-proxy-container{pointer-events:none;position:absolute}.ag-charts-proxy-elem{-webkit-appearance:none;appearance:none;background:none;border:none;color:#0000;overflow:hidden;pointer-events:none;position:absolute}.ag-charts-proxy-elem::-moz-range-thumb,.ag-charts-proxy-elem::-moz-range-track{opacity:0}.ag-charts-proxy-elem::-webkit-slider-runnable-track,.ag-charts-proxy-elem::-webkit-slider-thumb{opacity:0}.ag-charts-proxy-elem:focus-visible{outline:var(--ag-charts-focus-border);box-shadow:var(--ag-charts-focus-border-shadow)}.ag-charts-focus-indicator{position:absolute;display:block;pointer-events:none;user-select:none;width:100%;height:100%}.ag-charts-focus-indicator>div{position:absolute;outline:var(--ag-charts-focus-border);outline-width:2px;box-shadow:var(--ag-charts-focus-border-shadow)}.ag-charts-focus-indicator>svg{width:100%;height:100%;fill:none;stroke:var(--ag-charts-focus-border-color);stroke-width:2px}.ag-charts-toolbar{align-items:center;background:none;border:none;display:flex;flex-wrap:nowrap;opacity:1;position:absolute;transform:translateY(0);transition:opacity .2s ease-in-out,transform .2s ease-in-out}.ag-charts-toolbar--hidden,.ag-charts-toolbar--prevent-flash{visibility:hidden}.ag-charts-toolbar--floating-hidden{opacity:0;transition:opacity .4s ease-in-out}.ag-charts-toolbar--small{--ag-charts-toolbar-size: var(--ag-charts-toolbar-size-small);--ag-charts-toolbar-font-size: var(--ag-charts-toolbar-font-size-small);--ag-charts-toolbar-button-padding: var(--ag-charts-toolbar-button-padding-small)}.ag-charts-toolbar--top,.ag-charts-toolbar--bottom{flex-direction:row;width:100%}.ag-charts-toolbar--left,.ag-charts-toolbar--right{flex-direction:column}.ag-charts-toolbar--floating,.ag-charts-toolbar--floating-top,.ag-charts-toolbar--floating-bottom{background:none;border:none;flex-direction:row;pointer-events:none;width:100%}.ag-charts-toolbar--floating{padding:0;width:auto;z-index:var(--ag-charts-layer-toolbar)}.ag-charts-toolbar--floating-top{height:calc(var(--ag-charts-toolbar-size) + 10px);padding-top:10px}.ag-charts-toolbar--floating-bottom{height:calc(var(--ag-charts-toolbar-size) + 10px);padding-bottom:10px;overflow:hidden}.ag-charts-toolbar__align{display:flex;flex-direction:inherit;flex-wrap:inherit;gap:var(--ag-charts-toolbar-gap);max-width:100%;width:100%}.ag-charts-toolbar__align--start{justify-content:start}.ag-charts-toolbar__align--center{justify-content:center}.ag-charts-toolbar__align--end{justify-content:end}.ag-charts-toolbar__align--center,.ag-charts-toolbar__align--end{margin-left:auto}.ag-charts-toolbar--left .ag-charts-toolbar__align--center,.ag-charts-toolbar--left .ag-charts-toolbar__align--end,.ag-charts-toolbar--right .ag-charts-toolbar__align--center,.ag-charts-toolbar--right .ag-charts-toolbar__align--end{margin-left:0;margin-top:auto}.ag-charts-toolbar--floating-top .ag-charts-toolbar__align,.ag-charts-toolbar--floating-bottom .ag-charts-toolbar__align{transition:transform .4s ease-in-out;width:auto}.ag-charts-toolbar__section{display:inherit;flex-direction:inherit;flex-wrap:inherit;justify-content:inherit;max-width:inherit;width:inherit}.ag-charts-toolbar__button{align-items:center;background:var(--ag-charts-toolbar-background-color);border:var(--ag-charts-toolbar-border);color:var(--ag-charts-toolbar-foreground-color);display:flex;font:var(--ag-charts-toolbar-font-size) var(--ag-charts-font-family);justify-content:center;margin:0 0 0 -1px;min-height:var(--ag-charts-toolbar-size);min-width:var(--ag-charts-toolbar-size);padding:var(--ag-charts-toolbar-button-padding);pointer-events:all;position:relative;white-space:nowrap;--stroke-width-color: var(--ag-charts-toolbar-foreground-color)}.ag-charts-toolbar__no-pointer-events{pointer-events:none}.ag-charts-toolbar__button--drag-handle{min-width:24px;padding-left:0;padding-right:0}.ag-charts-toolbar__button--with-transition{transition:background-color .25s ease-in-out,border-color .25s ease-in-out,color .25s ease-in-out}.ag-charts-toolbar__button[data-toolbar-group=ranges]{padding:var(--ag-charts-toolbar-button-padding) calc(var(--ag-charts-toolbar-button-padding) * 1.5)}.ag-charts-toolbar--top,.ag-charts-toolbar--bottom,.ag-charts-toolbar--floating,.ag-charts-toolbar--floating-top,.ag-charts-toolbar--floating-bottom{.ag-charts-toolbar__button--first{border-bottom-left-radius:var(--ag-charts-button-radius);border-top-left-radius:var(--ag-charts-button-radius);margin:0}.ag-charts-toolbar__button--last{border-bottom-right-radius:var(--ag-charts-button-radius);border-top-right-radius:var(--ag-charts-button-radius)}}.ag-charts-toolbar--left,.ag-charts-toolbar--right{.ag-charts-toolbar__button{border-radius:0;margin:-1px 0 0;max-width:100%}.ag-charts-toolbar__button--first{border-top-left-radius:var(--ag-charts-button-radius);border-top-right-radius:var(--ag-charts-button-radius);margin:0}.ag-charts-toolbar__button--last{border-bottom-left-radius:var(--ag-charts-button-radius);border-bottom-right-radius:var(--ag-charts-button-radius)}}.ag-charts-toolbar__button--hidden-value,.ag-charts-toolbar__button--hidden-toggled{display:none}.ag-charts-toolbar__button:hover:not([aria-disabled=true],.ag-charts-toolbar__button--drag-handle){background:var(--ag-charts-toolbar-hover-color);z-index:1}.ag-charts-toolbar__button:focus-visible{outline:var(--ag-charts-focus-border);box-shadow:var(--ag-charts-focus-border-shadow);z-index:calc(var(--ag-charts-layer-ui-overlay) + 1)}.ag-charts-toolbar__button.ag-charts-toolbar__button--active{background:var(--ag-charts-toolbar-active-background-color);border-color:var(--ag-charts-toolbar-active-color);color:var(--ag-charts-toolbar-active-color);z-index:2;--stroke-width-color: var(--ag-charts-toolbar-active-color)}.ag-charts-toolbar__button[aria-disabled=true]{background:var(--ag-charts-toolbar-disabled-background-color);color:var(--ag-charts-toolbar-disabled-foreground-color)}.ag-charts-toolbar__button:not([aria-disabled=true]){cursor:pointer}.ag-charts-toolbar__button.ag-charts-toolbar__button--drag-handle{cursor:grab}.ag-charts-toolbar__button.ag-charts-toolbar__button--dragging{cursor:grabbing}.ag-charts-toolbar__button--fill-visible:after{content:\"\";display:block;position:absolute;bottom:3px;left:5px;right:5px;height:4px;border-radius:99px;box-shadow:inset 0 0 0 1px color-mix(in srgb,var(--ag-charts-foreground-color) 10%,transparent);background:var(--fill)}.ag-charts-toolbar__button--fill-visible[aria-disabled=true]:after{filter:grayscale(1);opacity:.5}.ag-charts-toolbar__button--stroke-width-visible:before{content:\"\";height:min(var(--strokeWidth),20px);width:12px;background:var(--stroke-width-color);margin-right:var(--ag-charts-toolbar-button-padding)}.ag-charts-toolbar__button--stroke-width-visible[aria-disabled=true]:before{filter:grayscale(1);opacity:.5}.ag-charts-toolbar__icon+.ag-charts-toolbar__label{margin-left:var(--ag-charts-toolbar-gap)}.ag-charts-toolbar__icon,.ag-charts-toolbar__label{pointer-events:none}.ag-chart-overlay{color:#181d1f;pointer-events:none}.ag-chart-overlay.ag-chart-dark-overlay{color:#fff}.ag-chart-overlay--loading{color:#8c8c8c}.ag-chart-overlay__loading-background{background:#fff;pointer-events:none}.ag-chart-overlay.ag-chart-dark-overlay .ag-chart-overlay__loading-background{background:#192232}.ag-chart-tooltip{transition:transform .1s ease;width:max-content;z-index:99999;font:12px Verdana,sans-serif;color:#464646;box-shadow:0 4px 8px #00000014}.ag-chart-tooltip-wrap-always{overflow-wrap:break-word;word-break:break-word;hyphens:none}.ag-chart-tooltip-wrap-hyphenate{overflow-wrap:break-word;word-break:break-word;hyphens:auto}.ag-chart-tooltip-wrap-on-space{overflow-wrap:normal;word-break:normal}.ag-chart-tooltip-wrap-never{white-space:pre;text-overflow:ellipsis}.ag-chart-tooltip-no-interaction{pointer-events:none;user-select:none}.ag-chart-tooltip-no-animation{transition:none!important}.ag-chart-tooltip-hidden{visibility:hidden}.ag-chart-tooltip-title{overflow:hidden;position:relative;padding:8px 14px;border-top-left-radius:2px;border-top-right-radius:2px;color:#fff;background-color:#888;z-index:1;text-overflow:inherit}.ag-chart-tooltip-title:only-child{border-bottom-left-radius:2px;border-bottom-right-radius:2px}.ag-chart-tooltip-content{overflow:hidden;padding:6px 14px;line-height:1.7em;background:#fff;border-bottom-left-radius:2px;border-bottom-right-radius:2px;border:1px solid rgba(0,0,0,.15);text-overflow:inherit}.ag-chart-tooltip-arrow:before{content:\"\";position:absolute;top:100%;left:50%;transform:translate(-50%);border:5px solid #d9d9d9;border-left-color:transparent;border-right-color:transparent;border-bottom-color:transparent;width:0;height:0;margin:0 auto}.ag-chart-tooltip-arrow:after{content:\"\";position:absolute;top:calc(100% - 1px);left:50%;transform:translate(-50%);border:5px solid white;border-left-color:transparent;border-right-color:transparent;border-bottom-color:transparent;width:0;height:0;margin:0 auto}\\n';\n\n// packages/ag-charts-community/src/util/keynavUtil.ts\nfunction addRemovableEventListener(destroyFns, elem, type, listener) {\n  elem.addEventListener(type, listener);\n  const remover = () => elem.removeEventListener(type, listener);\n  destroyFns.push(remover);\n  return remover;\n}\nfunction addEscapeEventListener(destroyFns, elem, onEscape) {\n  addRemovableEventListener(destroyFns, elem, \"keydown\", (event) => {\n    if (event.key === \"Escape\") {\n      onEscape(event);\n    }\n  });\n}\nfunction addMouseCloseListener(destroyFns, menu, hideCallback) {\n  const self = addRemovableEventListener(destroyFns, window, \"mousedown\", (event) => {\n    if ([0, 2].includes(event.button) && !containsPoint(menu, event)) {\n      hideCallback();\n      self();\n    }\n  });\n  return self;\n}\nfunction containsPoint(container, event) {\n  if (event.target instanceof Element) {\n    const { x, y, width: width2, height: height2 } = container.getBoundingClientRect();\n    const { clientX: ex, clientY: ey } = event;\n    return ex >= x && ey >= y && ex <= x + width2 && ey <= y + height2;\n  }\n  return false;\n}\nfunction hasNoModifiers(event) {\n  return !(event.shiftKey || event.altKey || event.ctrlKey || event.metaKey);\n}\nfunction matchesKey(event, key, ...morekeys) {\n  return hasNoModifiers(event) && (event.key === key || morekeys.some((altkey) => event.key === altkey));\n}\nfunction linkTwoButtons(destroyFns, src, dst, key) {\n  if (!dst)\n    return;\n  addRemovableEventListener(destroyFns, src, \"keydown\", (event) => {\n    if (matchesKey(event, key)) {\n      dst.focus();\n    }\n  });\n}\nfunction linkThreeButtons(destroyFns, curr, next, nextKey, prev, prevKey) {\n  linkTwoButtons(destroyFns, curr, prev, prevKey);\n  linkTwoButtons(destroyFns, curr, next, nextKey);\n  addRemovableEventListener(destroyFns, curr, \"keydown\", (event) => {\n    if (matchesKey(event, nextKey, prevKey)) {\n      event.preventDefault();\n    }\n  });\n}\nvar PREV_NEXT_KEYS = {\n  horizontal: { nextKey: \"ArrowRight\", prevKey: \"ArrowLeft\" },\n  vertical: { nextKey: \"ArrowDown\", prevKey: \"ArrowUp\" }\n};\nfunction initToolbarKeyNav(opts) {\n  opts.toolbar.role = \"toolbar\";\n  opts.toolbar.ariaOrientation = opts.orientation;\n  opts.toolbar.ariaHidden = (opts.buttons.length === 0).toString();\n  return initRovingTabIndex(opts);\n}\nfunction initRovingTabIndex(opts) {\n  const { orientation, buttons, wrapAround = false, onEscape, onFocus, onBlur } = opts;\n  const { nextKey, prevKey } = PREV_NEXT_KEYS[orientation];\n  const setTabIndices = (event) => {\n    if (event.target && \"tabIndex\" in event.target) {\n      buttons.forEach((b) => b.tabIndex = -1);\n      event.target.tabIndex = 0;\n    }\n  };\n  const [c, m] = wrapAround ? [buttons.length, buttons.length] : [0, Infinity];\n  const destroyFns = [];\n  for (let i = 0; i < buttons.length; i++) {\n    const prev = buttons[(c + i - 1) % m];\n    const curr = buttons[i];\n    const next = buttons[(c + i + 1) % m];\n    addRemovableEventListener(destroyFns, curr, \"focus\", setTabIndices);\n    if (onFocus)\n      addRemovableEventListener(destroyFns, curr, \"focus\", onFocus);\n    if (onBlur)\n      addRemovableEventListener(destroyFns, curr, \"blur\", onBlur);\n    if (onEscape)\n      addEscapeEventListener(destroyFns, curr, onEscape);\n    linkThreeButtons(destroyFns, curr, prev, prevKey, next, nextKey);\n    curr.tabIndex = i === 0 ? 0 : -1;\n  }\n  return destroyFns;\n}\nvar MenuCloserImp = class {\n  constructor(menu, lastFocus, closeCallback) {\n    this.lastFocus = lastFocus;\n    this.closeCallback = closeCallback;\n    this.destroyFns = [];\n    this.destroyFns.push(addMouseCloseListener(this.destroyFns, menu, () => this.close()));\n  }\n  close() {\n    this.destroyFns.forEach((d) => d());\n    this.destroyFns.length = 0;\n    this.closeCallback();\n    this.finishClosing();\n  }\n  finishClosing() {\n    this.destroyFns.forEach((d) => d());\n    this.destroyFns.length = 0;\n    setAttribute(this.lastFocus, \"aria-expanded\", false);\n    this.lastFocus?.focus();\n    this.lastFocus = void 0;\n  }\n};\nfunction initMenuKeyNav(opts) {\n  const { sourceEvent, orientation, menu, buttons, closeCallback, autoCloseOnBlur = false } = opts;\n  const { nextKey, prevKey } = PREV_NEXT_KEYS[orientation];\n  const lastFocus = getLastFocus(sourceEvent);\n  setAttribute(lastFocus, \"aria-expanded\", true);\n  const menuCloser = new MenuCloserImp(menu, lastFocus, closeCallback);\n  const onEscape = () => menuCloser.close();\n  const { destroyFns } = menuCloser;\n  menu.role = \"menu\";\n  menu.ariaOrientation = orientation;\n  destroyFns.push(...initRovingTabIndex({ orientation, buttons, onEscape, wrapAround: true }));\n  menu.tabIndex = -1;\n  addEscapeEventListener(destroyFns, menu, onEscape);\n  addRemovableEventListener(destroyFns, menu, \"keydown\", (ev) => {\n    if (ev.target === menu && (ev.key === nextKey || ev.key === prevKey)) {\n      ev.preventDefault();\n      buttons[0]?.focus();\n    }\n  });\n  if (autoCloseOnBlur) {\n    const handler = (ev) => {\n      const buttonArray = buttons;\n      const isLeavingMenu = !buttonArray.includes(ev.relatedTarget);\n      if (isLeavingMenu) {\n        onEscape();\n      }\n    };\n    for (const button of buttons) {\n      addRemovableEventListener(destroyFns, button, \"blur\", handler);\n    }\n  }\n  buttons[0]?.focus();\n  return menuCloser;\n}\nfunction makeAccessibleClickListener(element2, onclick) {\n  return (event) => {\n    if (element2.ariaDisabled === \"true\") {\n      return event.preventDefault();\n    }\n    onclick(event);\n  };\n}\nfunction isButtonClickEvent(event) {\n  if (\"button\" in event) {\n    return event.button === 0;\n  }\n  return hasNoModifiers(event) && (event.code === \"Space\" || event.key === \"Enter\");\n}\nfunction getLastFocus(sourceEvent) {\n  if (sourceEvent?.target instanceof HTMLElement && \"tabindex\" in sourceEvent.target.attributes) {\n    return sourceEvent.target;\n  }\n  return void 0;\n}\nfunction stopPageScrolling(element2) {\n  const handler = (event) => {\n    if (event.defaultPrevented)\n      return;\n    const shouldPrevent = getAttribute(event.target, \"data-preventdefault\", true);\n    if (shouldPrevent && matchesKey(event, \"ArrowRight\", \"ArrowLeft\", \"ArrowDown\", \"ArrowUp\")) {\n      event.preventDefault();\n    }\n  };\n  element2.addEventListener(\"keydown\", handler);\n  return () => element2.removeEventListener(\"keydown\", handler);\n}\n\n// packages/ag-charts-community/src/util/sizeMonitor.ts\nvar SizeMonitor = class {\n  constructor() {\n    this.elements = /* @__PURE__ */ new Map();\n    this.documentReady = false;\n    this.queuedObserveRequests = [];\n    this.onLoad = () => {\n      this.documentReady = true;\n      this.queuedObserveRequests.forEach(([el, cb]) => this.observe(el, cb));\n      this.queuedObserveRequests = [];\n    };\n    if (typeof ResizeObserver === \"undefined\")\n      return;\n    this.resizeObserver = new ResizeObserver((entries) => {\n      for (const {\n        target,\n        contentRect: { width: width2, height: height2 }\n      } of entries) {\n        const entry = this.elements.get(target);\n        this.checkSize(entry, target, width2, height2);\n      }\n    });\n    this.documentReady = getDocument(\"readyState\") === \"complete\";\n    if (!this.documentReady) {\n      getWindow()?.addEventListener(\"load\", this.onLoad);\n    }\n  }\n  destroy() {\n    getWindow()?.removeEventListener(\"load\", this.onLoad);\n    this.resizeObserver?.disconnect();\n    this.resizeObserver = null;\n  }\n  checkSize(entry, element2, width2, height2) {\n    if (!entry)\n      return;\n    if (width2 !== entry.size?.width || height2 !== entry.size?.height) {\n      entry.size = { width: width2, height: height2 };\n      entry.cb(entry.size, element2);\n    }\n  }\n  // Only a single callback is supported.\n  observe(element2, cb) {\n    if (!this.documentReady) {\n      this.queuedObserveRequests.push([element2, cb]);\n      return;\n    }\n    if (this.elements.has(element2)) {\n      this.removeFromQueue(element2);\n    } else {\n      this.resizeObserver?.observe(element2);\n    }\n    const entry = { cb };\n    this.elements.set(element2, entry);\n  }\n  unobserve(element2) {\n    this.resizeObserver?.unobserve(element2);\n    this.elements.delete(element2);\n    this.removeFromQueue(element2);\n    if (!this.elements.size) {\n      this.destroy();\n    }\n  }\n  removeFromQueue(element2) {\n    this.queuedObserveRequests = this.queuedObserveRequests.filter(([el]) => el !== element2);\n  }\n};\n\n// packages/ag-charts-community/src/dom/domLayout.html\nvar domLayout_default = '<div role=\"presentation\" class=\"ag-charts-wrapper ag-charts-styles\" data-ag-charts><div role=\"presentation\" class=\"ag-charts-canvas-center\"><div role=\"presentation\" class=\"ag-charts-canvas-container\"><div role=\"presentation\" class=\"ag-charts-canvas\" aria-hidden=\"true\"></div><div role=\"figure\" class=\"ag-charts-canvas-proxy\"><div role=\"img\" class=\"ag-charts-series-area\" tabindex=\"-1\"></div></div><div role=\"presentation\" class=\"ag-charts-canvas-overlay\"></div></div></div></div>';\n\n// packages/ag-charts-community/src/dom/domManager.ts\nvar DOM_ELEMENT_CLASSES = [\n  \"styles\",\n  \"canvas\",\n  \"canvas-center\",\n  \"canvas-overlay\",\n  \"canvas-proxy\",\n  \"series-area\"\n];\nvar domElementConfig = /* @__PURE__ */ new Map([\n  [\"styles\", { childElementType: \"style\" }],\n  [\"canvas\", { childElementType: \"canvas\" }],\n  [\"canvas-proxy\", { childElementType: \"div\" }],\n  [\"canvas-overlay\", { childElementType: \"div\" }],\n  [\"canvas-center\", { childElementType: \"div\" }],\n  [\"series-area\", { childElementType: \"div\" }]\n]);\nfunction setupObserver(element2, cb) {\n  if (typeof IntersectionObserver === \"undefined\")\n    return;\n  const observer = new IntersectionObserver(\n    (entries) => {\n      for (const entry of entries) {\n        if (entry.target === element2) {\n          cb(entry.intersectionRatio);\n        }\n      }\n    },\n    { root: element2 }\n  );\n  observer.observe(element2);\n  return observer;\n}\nvar NULL_DOMRECT = {\n  x: 0,\n  y: 0,\n  width: 0,\n  height: 0,\n  top: 0,\n  bottom: 0,\n  left: 0,\n  right: 0,\n  toJSON() {\n    return NULL_DOMRECT;\n  }\n};\nvar DOMManager = class extends BaseManager {\n  constructor(container, styleContainer) {\n    super();\n    this.styles = /* @__PURE__ */ new Map();\n    this.container = void 0;\n    this.containerSize = void 0;\n    this.sizeMonitor = new SizeMonitor();\n    const templateEl = createElement(\"div\");\n    templateEl.innerHTML = domLayout_default;\n    this.element = templateEl.children.item(0);\n    this.styleRootElement = styleContainer;\n    this.rootElements = DOM_ELEMENT_CLASSES.reduce(\n      (r, c) => {\n        const cssClass = `ag-charts-${c}`;\n        const el = this.element.classList.contains(cssClass) ? this.element : this.element.querySelector(`.${cssClass}`);\n        if (!el)\n          throw new Error(`AG Charts - unable to find DOM element ${cssClass}`);\n        r[c] = { element: el, children: /* @__PURE__ */ new Map(), listeners: [] };\n        return r;\n      },\n      {}\n    );\n    let hidden = false;\n    this.observer = setupObserver(this.element, (intersectionRatio) => {\n      if (intersectionRatio === 0 && !hidden) {\n        this.listeners.dispatch(\"hidden\", { type: \"hidden\" });\n      }\n      hidden = intersectionRatio === 0;\n    });\n    this.setSizeOptions();\n    this.addStyles(\"ag-charts-community\", styles_default);\n    if (container) {\n      this.setContainer(container);\n    }\n    this.destroyFns.push(stopPageScrolling(this.element));\n  }\n  destroy() {\n    super.destroy();\n    this.observer?.unobserve(this.element);\n    if (this.container) {\n      this.sizeMonitor.unobserve(this.container);\n    }\n    Object.values(this.rootElements).forEach((el) => {\n      el.children.forEach((c) => c.remove());\n      el.element.remove();\n    });\n    this.element.remove();\n  }\n  setSizeOptions(minWidth = 300, minHeight = 300, optionsWidth, optionsHeight) {\n    const { style } = this.element;\n    style.width = `${optionsWidth ?? minWidth}px`;\n    style.height = `${optionsHeight ?? minHeight}px`;\n  }\n  updateContainerSize() {\n    const { style: centerStyle } = this.rootElements[\"canvas-center\"].element;\n    centerStyle.width = `${this.containerSize?.width ?? 0}px`;\n    centerStyle.height = `${this.containerSize?.height ?? 0}px`;\n  }\n  setContainer(newContainer) {\n    if (newContainer === this.container)\n      return;\n    if (this.container) {\n      this.container.removeChild(this.element);\n      this.sizeMonitor.unobserve(this.container);\n    }\n    const isShadowDom = this.getShadowDocumentRoot(newContainer) != null;\n    if (!isShadowDom) {\n      for (const id of this.rootElements[\"styles\"].children.keys()) {\n        this.removeChild(\"styles\", id);\n      }\n    }\n    this.container = newContainer;\n    for (const [id, styles] of this.styles) {\n      this.addStyles(id, styles);\n    }\n    newContainer.appendChild(this.element);\n    this.sizeMonitor.observe(newContainer, (size) => {\n      this.containerSize = size;\n      this.updateContainerSize();\n      this.listeners.dispatch(\"resize\", { type: \"resize\" });\n    });\n    this.listeners.dispatch(\"container-changed\", { type: \"container-changed\" });\n  }\n  setThemeClass(themeClassName) {\n    const themeClassNamePrefix = \"ag-charts-theme-\";\n    this.element.classList.forEach((className) => {\n      if (className.startsWith(themeClassNamePrefix) && className !== themeClassName) {\n        this.element.classList.remove(className);\n      }\n    });\n    this.element.classList.add(themeClassName);\n  }\n  setTabIndex(tabIndex) {\n    this.rootElements[\"series-area\"].element.tabIndex = tabIndex;\n  }\n  updateCanvasLabel(ariaLabel) {\n    setAttribute(this.rootElements[\"canvas-proxy\"].element, \"aria-label\", ariaLabel);\n  }\n  getEventElement(defaultElem, eventType) {\n    const events = [\"focus\", \"blur\", \"keydown\", \"keyup\"];\n    return events.includes(eventType) ? this.rootElements[\"series-area\"].element : defaultElem;\n  }\n  addEventListener(type, listener, options) {\n    this.getEventElement(this.element, type).addEventListener(type, listener, options);\n  }\n  removeEventListener(type, listener, options) {\n    this.getEventElement(this.element, type).removeEventListener(type, listener, options);\n  }\n  /** Get the main chart area client bound rect. */\n  getBoundingClientRect() {\n    return this.rootElements[\"canvas\"].element.getBoundingClientRect();\n  }\n  /**\n   * Get the client bounding rect for overlay elements that might float outside the bounds of the\n   * main chart area.\n   */\n  getOverlayClientRect() {\n    const window2 = getWindow();\n    const windowBBox = new BBox(0, 0, window2.innerWidth, window2.innerHeight);\n    const container = this.getRawOverlayClientRect();\n    const containerBBox = BBox.fromDOMRect(container ?? this.getBoundingClientRect());\n    return windowBBox.intersection(containerBBox)?.toDOMRect() ?? NULL_DOMRECT;\n  }\n  getRawOverlayClientRect() {\n    let element2 = this.element;\n    while (element2 != null) {\n      const styleMap = element2.computedStyleMap?.();\n      const overflowX = styleMap?.get(\"overflow-x\")?.toString();\n      const overflowY = styleMap?.get(\"overflow-y\")?.toString();\n      if (overflowX != null && overflowX !== \"visible\" || overflowY && overflowY !== \"visible\") {\n        return element2.getBoundingClientRect();\n      }\n      element2 = element2.parentElement;\n    }\n    const docRoot = this.getShadowDocumentRoot();\n    if (docRoot) {\n      return docRoot.getBoundingClientRect();\n    }\n  }\n  getShadowDocumentRoot(current = this.container) {\n    const docRoot = current?.ownerDocument?.body ?? getDocument(\"body\");\n    while (current != null) {\n      if (current === docRoot) {\n        return void 0;\n      }\n      if (current.parentNode instanceof DocumentFragment) {\n        return current;\n      }\n      current = current.parentNode;\n    }\n    return this.container;\n  }\n  getChildBoundingClientRect(type) {\n    const { children } = this.rootElements[type];\n    const childRects = [];\n    for (const child of children.values()) {\n      childRects.push(BBox.fromDOMRect(child.getBoundingClientRect()));\n    }\n    return BBox.merge(childRects);\n  }\n  calculateCanvasPosition(el) {\n    let x = 0;\n    let y = 0;\n    const { x: cx = 0, y: cy = 0 } = this.getChildBoundingClientRect(\"canvas\") ?? {};\n    const elRect = el.getBoundingClientRect();\n    x = elRect.x - cx;\n    y = elRect.y - cy;\n    return { x, y };\n  }\n  isManagedChildDOMElement(el, domElementClass, id) {\n    const { children } = this.rootElements[domElementClass];\n    const search = children?.get(id);\n    return search != null && el.contains(search);\n  }\n  isEventOverElement(event) {\n    const element2 = event.target;\n    return element2 != null && this.element.contains(element2);\n  }\n  addStyles(id, styles) {\n    const dataAttribute = \"data-ag-charts\";\n    this.styles.set(id, styles);\n    if (this.container == null)\n      return;\n    const checkId = (el) => {\n      return el.getAttribute(dataAttribute) === id;\n    };\n    const addStyleElement = (el) => {\n      for (const child of el.children) {\n        if (checkId(child))\n          return;\n      }\n      const styleEl = createElement(\"style\");\n      el.appendChild(styleEl);\n      return styleEl;\n    };\n    let styleElement;\n    if (this.styleRootElement) {\n      styleElement = addStyleElement(this.styleRootElement);\n    } else {\n      const documentRoot = this.getShadowDocumentRoot(this.container);\n      if (documentRoot != null) {\n        styleElement = this.addChild(\"styles\", id);\n      } else {\n        styleElement = addStyleElement(getDocument(\"head\"));\n      }\n    }\n    if (styleElement == null || checkId(styleElement))\n      return;\n    styleElement.setAttribute(dataAttribute, id);\n    styleElement.innerHTML = styles;\n  }\n  removeStyles(id) {\n    this.removeChild(\"styles\", id);\n  }\n  updateCursor(style) {\n    this.element.style.cursor = style;\n  }\n  getCursor() {\n    return this.element.style.cursor;\n  }\n  addChild(domElementClass, id, child, insert) {\n    const { element: element2, children, listeners } = this.rootElements[domElementClass];\n    if (!children) {\n      throw new Error(\"AG Charts - unable to create DOM elements after destroy()\");\n    }\n    if (children.has(id)) {\n      return children.get(id);\n    }\n    const { childElementType = \"div\" } = domElementConfig.get(domElementClass) ?? {};\n    if (child && child.tagName.toLowerCase() !== childElementType.toLowerCase()) {\n      throw new Error(\"AG Charts - mismatching DOM element type\");\n    }\n    const newChild = child ?? createElement(childElementType);\n    for (const [type, fn, opts] of listeners) {\n      newChild.addEventListener(type, fn, opts);\n    }\n    children.set(id, newChild);\n    if (insert) {\n      const queryResult = element2.querySelector(insert.query);\n      if (queryResult == null) {\n        throw new Error(`AG Charts - addChild query failed ${insert.query}`);\n      }\n      queryResult.insertAdjacentElement(insert.where, newChild);\n    } else {\n      element2?.appendChild(newChild);\n    }\n    return newChild;\n  }\n  removeChild(domElementClass, id) {\n    const { children } = this.rootElements[domElementClass];\n    if (!children)\n      return;\n    children.get(id)?.remove();\n    children.delete(id);\n  }\n  incrementDataCounter(name) {\n    const { dataset } = this.element;\n    dataset[name] ?? (dataset[name] = \"0\");\n    dataset[name] = String(Number(dataset[name]) + 1);\n  }\n  setDataBoolean(name, value) {\n    this.element.dataset[name] = String(value);\n  }\n  getIconClassNames(icon) {\n    return `ag-charts-icon ag-charts-icon-${icon}`;\n  }\n};\n\n// packages/ag-charts-community/src/scene/polyRoots.ts\nfunction linearRoot(a, b) {\n  const t = -b / a;\n  return a !== 0 && t >= 0 && t <= 1 ? [t] : [];\n}\nfunction quadraticRoots(a, b, c) {\n  if (a === 0) {\n    return linearRoot(b, c);\n  }\n  const D = b * b - 4 * a * c;\n  const roots = [];\n  if (D === 0) {\n    const t = -b / (2 * a);\n    if (t >= 0 && t <= 1) {\n      roots.push(t);\n    }\n  } else if (D > 0) {\n    const rD = Math.sqrt(D);\n    const t1 = (-b - rD) / (2 * a);\n    const t2 = (-b + rD) / (2 * a);\n    if (t1 >= 0 && t1 <= 1) {\n      roots.push(t1);\n    }\n    if (t2 >= 0 && t2 <= 1) {\n      roots.push(t2);\n    }\n  }\n  return roots;\n}\nfunction cubicRoots(a, b, c, d) {\n  if (a === 0) {\n    return quadraticRoots(b, c, d);\n  }\n  const A = b / a;\n  const B = c / a;\n  const C = d / a;\n  const Q = (3 * B - A * A) / 9;\n  const R = (9 * A * B - 27 * C - 2 * A * A * A) / 54;\n  const D = Q * Q * Q + R * R;\n  const third = 1 / 3;\n  const roots = [];\n  if (D >= 0) {\n    const rD = Math.sqrt(D);\n    const S = Math.sign(R + rD) * Math.pow(Math.abs(R + rD), third);\n    const T = Math.sign(R - rD) * Math.pow(Math.abs(R - rD), third);\n    const Im = Math.abs(Math.sqrt(3) * (S - T) / 2);\n    const t = -third * A + (S + T);\n    if (t >= 0 && t <= 1) {\n      roots.push(t);\n    }\n    if (Im === 0) {\n      const t2 = -third * A - (S + T) / 2;\n      if (t2 >= 0 && t2 <= 1) {\n        roots.push(t2);\n      }\n    }\n  } else {\n    const theta = Math.acos(R / Math.sqrt(-Q * Q * Q));\n    const thirdA = third * A;\n    const twoSqrtQ = 2 * Math.sqrt(-Q);\n    const t1 = twoSqrtQ * Math.cos(third * theta) - thirdA;\n    const t2 = twoSqrtQ * Math.cos(third * (theta + 2 * Math.PI)) - thirdA;\n    const t3 = twoSqrtQ * Math.cos(third * (theta + 4 * Math.PI)) - thirdA;\n    if (t1 >= 0 && t1 <= 1) {\n      roots.push(t1);\n    }\n    if (t2 >= 0 && t2 <= 1) {\n      roots.push(t2);\n    }\n    if (t3 >= 0 && t3 <= 1) {\n      roots.push(t3);\n    }\n  }\n  return roots;\n}\n\n// packages/ag-charts-community/src/scene/intersection.ts\nfunction segmentIntersection(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {\n  const d = (ax2 - ax1) * (by2 - by1) - (ay2 - ay1) * (bx2 - bx1);\n  if (d === 0) {\n    return 0;\n  }\n  const ua = ((bx2 - bx1) * (ay1 - by1) - (ax1 - bx1) * (by2 - by1)) / d;\n  const ub = ((ax2 - ax1) * (ay1 - by1) - (ay2 - ay1) * (ax1 - bx1)) / d;\n  if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {\n    return 1;\n  }\n  return 0;\n}\nfunction cubicSegmentIntersections(px1, py1, px2, py2, px3, py3, px4, py4, x1, y1, x2, y2) {\n  let intersections = 0;\n  const A = y1 - y2;\n  const B = x2 - x1;\n  const C = x1 * (y2 - y1) - y1 * (x2 - x1);\n  const bx = bezierCoefficients(px1, px2, px3, px4);\n  const by = bezierCoefficients(py1, py2, py3, py4);\n  const a = A * bx[0] + B * by[0];\n  const b = A * bx[1] + B * by[1];\n  const c = A * bx[2] + B * by[2];\n  const d = A * bx[3] + B * by[3] + C;\n  const roots = cubicRoots(a, b, c, d);\n  for (const t of roots) {\n    const tt = t * t;\n    const ttt = t * tt;\n    const x = bx[0] * ttt + bx[1] * tt + bx[2] * t + bx[3];\n    const y = by[0] * ttt + by[1] * tt + by[2] * t + by[3];\n    let s;\n    if (x1 === x2) {\n      s = (y - y1) / (y2 - y1);\n    } else {\n      s = (x - x1) / (x2 - x1);\n    }\n    if (s >= 0 && s <= 1) {\n      intersections++;\n    }\n  }\n  return intersections;\n}\nfunction bezierCoefficients(P1, P2, P3, P4) {\n  return [\n    // Bézier expressed as matrix operations:\n    -P1 + 3 * P2 - 3 * P3 + P4,\n    //                 |-1  3 -3  1| |P1|\n    3 * P1 - 6 * P2 + 3 * P3,\n    //   [t^3 t^2 t 1] | 3 -6  3  0| |P2|\n    -3 * P1 + 3 * P2,\n    //                 |-3  3  0  0| |P3|\n    P1\n    //                 | 1  0  0  0| |P4|\n  ];\n}\nfunction arcIntersections(cx, cy, r, startAngle, endAngle, counterClockwise, x1, y1, x2, y2) {\n  if (isNaN(cx) || isNaN(cy)) {\n    return 0;\n  }\n  if (counterClockwise) {\n    [endAngle, startAngle] = [startAngle, endAngle];\n  }\n  const k = (y2 - y1) / (x2 - x1);\n  const y0 = y1 - k * x1;\n  const a = Math.pow(k, 2) + 1;\n  const b = 2 * (k * (y0 - cy) - cx);\n  const c = Math.pow(cx, 2) + Math.pow(y0 - cy, 2) - Math.pow(r, 2);\n  const d = Math.pow(b, 2) - 4 * a * c;\n  if (d < 0) {\n    return 0;\n  }\n  const i1x = (-b + Math.sqrt(d)) / 2 / a;\n  const i2x = (-b - Math.sqrt(d)) / 2 / a;\n  let intersections = 0;\n  [i1x, i2x].forEach((x) => {\n    const isXInsideLine = x >= Math.min(x1, x2) && x <= Math.max(x1, x2);\n    if (!isXInsideLine) {\n      return;\n    }\n    const y = k * x + y0;\n    const adjacent = x - cx;\n    const opposite = y - cy;\n    const angle2 = Math.atan2(opposite, adjacent);\n    if (isBetweenAngles(angle2, startAngle, endAngle)) {\n      intersections++;\n    }\n  });\n  return intersections;\n}\n\n// packages/ag-charts-community/src/scene/util/bezier.ts\nfunction evaluateBezier(p0, p1, p2, p3, t) {\n  return (1 - t) ** 3 * p0 + 3 * (1 - t) ** 2 * t * p1 + 3 * (1 - t) * t ** 2 * p2 + t ** 3 * p3;\n}\nfunction solveBezier(p0, p1, p2, p3, value) {\n  if (value <= Math.min(p0, p3)) {\n    return p0 < p3 ? 0 : 1;\n  } else if (value >= Math.max(p0, p3)) {\n    return p0 < p3 ? 1 : 0;\n  }\n  let t0 = 0;\n  let t1 = 1;\n  let t = NaN;\n  for (let i = 0; i < 12; i += 1) {\n    t = (t0 + t1) / 2;\n    const curveValue = evaluateBezier(p0, p1, p2, p3, t);\n    if (curveValue < value) {\n      t0 = t;\n    } else {\n      t1 = t;\n    }\n  }\n  return t;\n}\nfunction splitBezier(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y, t) {\n  const x01 = (1 - t) * p0x + t * p1x;\n  const y01 = (1 - t) * p0y + t * p1y;\n  const x12 = (1 - t) * p1x + t * p2x;\n  const y12 = (1 - t) * p1y + t * p2y;\n  const x23 = (1 - t) * p2x + t * p3x;\n  const y23 = (1 - t) * p2y + t * p3y;\n  const x012 = (1 - t) * x01 + t * x12;\n  const y012 = (1 - t) * y01 + t * y12;\n  const x123 = (1 - t) * x12 + t * x23;\n  const y123 = (1 - t) * y12 + t * y23;\n  const x0123 = (1 - t) * x012 + t * x123;\n  const y0123 = (1 - t) * y012 + t * y123;\n  return [\n    [\n      { x: p0x, y: p0y },\n      { x: x01, y: y01 },\n      { x: x012, y: y012 },\n      { x: x0123, y: y0123 }\n    ],\n    [\n      { x: x0123, y: y0123 },\n      { x: x123, y: y123 },\n      { x: x23, y: y23 },\n      { x: p3x, y: p3y }\n    ]\n  ];\n}\nfunction calculateDerivativeExtrema(p0, p1, p2, p3) {\n  const a = -p0 + 3 * p1 - 3 * p2 + p3;\n  const b = 3 * p0 - 6 * p1 + 3 * p2;\n  const c = -3 * p0 + 3 * p1;\n  if (a === 0) {\n    if (b !== 0) {\n      const t = -c / b;\n      if (t > 0 && t < 1) {\n        return [t];\n      }\n    }\n    return [];\n  }\n  const discriminant = b * b - 4 * a * c;\n  if (discriminant >= 0) {\n    const sqrtDiscriminant = Math.sqrt(discriminant);\n    const t1 = (-b + sqrtDiscriminant) / (2 * a);\n    const t2 = (-b - sqrtDiscriminant) / (2 * a);\n    return [t1, t2].filter((t) => t > 0 && t < 1);\n  }\n  return [];\n}\nfunction calculateDerivativeExtremaXY(sx, sy, cp1x, cp1y, cp2x, cp2y, x, y) {\n  const tx = calculateDerivativeExtrema(sx, cp1x, cp2x, x);\n  const ty = calculateDerivativeExtrema(sy, cp1y, cp2y, y);\n  return [...tx, ...ty];\n}\n\n// packages/ag-charts-community/src/scene/extendedPath2D.ts\nvar ExtendedPath2D = class {\n  constructor() {\n    // The methods of this class will likely be called many times per animation frame,\n    // and any allocation can trigger a GC cycle during animation, so we attempt\n    // to minimize the number of allocations.\n    this.path2d = new Path2D();\n    this.previousCommands = [];\n    this.previousParams = [];\n    this.previousClosedPath = false;\n    this.commands = [];\n    this.params = [];\n    this.openedPath = false;\n    this.closedPath = false;\n  }\n  isDirty() {\n    return this.closedPath !== this.previousClosedPath || this.previousCommands.length !== this.commands.length || this.previousParams.length !== this.params.length || this.previousCommands.toString() !== this.commands.toString() || this.previousParams.toString() !== this.params.toString();\n  }\n  getPath2D() {\n    return this.path2d;\n  }\n  moveTo(x, y) {\n    this.openedPath = true;\n    this.path2d.moveTo(x, y);\n    this.commands.push(0 /* Move */);\n    this.params.push(x, y);\n  }\n  lineTo(x, y) {\n    if (this.openedPath) {\n      this.path2d.lineTo(x, y);\n      this.commands.push(1 /* Line */);\n      this.params.push(x, y);\n    } else {\n      this.moveTo(x, y);\n    }\n  }\n  rect(x, y, width2, height2) {\n    this.moveTo(x, y);\n    this.lineTo(x + width2, y);\n    this.lineTo(x + width2, y + height2);\n    this.lineTo(x, y + height2);\n    this.closePath();\n  }\n  roundRect(x, y, width2, height2, radii) {\n    radii = Math.min(radii, width2 / 2, height2 / 2);\n    this.moveTo(x, y + radii);\n    this.arc(x + radii, y + radii, radii, Math.PI, 1.5 * Math.PI);\n    this.lineTo(x + radii, y);\n    this.lineTo(x + width2 - radii, y);\n    this.arc(x + width2 - radii, y + radii, radii, 1.5 * Math.PI, 2 * Math.PI);\n    this.lineTo(x + width2, y + radii);\n    this.lineTo(x + width2, y + height2 - radii);\n    this.arc(x + width2 - radii, y + height2 - radii, radii, 0, Math.PI / 2);\n    this.lineTo(x + width2 - radii, y + height2);\n    this.lineTo(x + radii, y + height2);\n    this.arc(x + +radii, y + height2 - radii, radii, Math.PI / 2, Math.PI);\n    this.lineTo(x, y + height2 - radii);\n    this.closePath();\n  }\n  arc(x, y, r, sAngle, eAngle, counterClockwise) {\n    this.openedPath = true;\n    this.path2d.arc(x, y, r, sAngle, eAngle, counterClockwise);\n    this.commands.push(2 /* Arc */);\n    this.params.push(x, y, r, sAngle, eAngle, counterClockwise ? 1 : 0);\n  }\n  cubicCurveTo(cx1, cy1, cx2, cy2, x, y) {\n    if (!this.openedPath) {\n      this.moveTo(cx1, cy1);\n    }\n    this.path2d.bezierCurveTo(cx1, cy1, cx2, cy2, x, y);\n    this.commands.push(3 /* Curve */);\n    this.params.push(cx1, cy1, cx2, cy2, x, y);\n  }\n  closePath() {\n    if (this.openedPath) {\n      this.path2d.closePath();\n      this.commands.push(4 /* ClosePath */);\n      this.openedPath = false;\n      this.closedPath = true;\n    }\n  }\n  clear(trackChanges) {\n    if (trackChanges) {\n      this.previousCommands = this.commands;\n      this.previousParams = this.params;\n      this.previousClosedPath = this.closedPath;\n    }\n    this.path2d = new Path2D();\n    this.openedPath = false;\n    this.closedPath = false;\n    this.commands = [];\n    this.params = [];\n  }\n  isPointInPath(x, y) {\n    const commands = this.commands;\n    const params = this.params;\n    const cn = commands.length;\n    const ox = -1e4;\n    const oy = -1e4;\n    let sx = NaN;\n    let sy = NaN;\n    let px = 0;\n    let py = 0;\n    let intersectionCount = 0;\n    for (let ci = 0, pi = 0; ci < cn; ci++) {\n      switch (commands[ci]) {\n        case 0 /* Move */:\n          intersectionCount += segmentIntersection(sx, sy, px, py, ox, oy, x, y);\n          px = params[pi++];\n          sx = px;\n          py = params[pi++];\n          sy = py;\n          break;\n        case 1 /* Line */:\n          intersectionCount += segmentIntersection(px, py, params[pi++], params[pi++], ox, oy, x, y);\n          px = params[pi - 2];\n          py = params[pi - 1];\n          break;\n        case 3 /* Curve */:\n          intersectionCount += cubicSegmentIntersections(\n            px,\n            py,\n            params[pi++],\n            params[pi++],\n            params[pi++],\n            params[pi++],\n            params[pi++],\n            params[pi++],\n            ox,\n            oy,\n            x,\n            y\n          );\n          px = params[pi - 2];\n          py = params[pi - 1];\n          break;\n        case 2 /* Arc */: {\n          const cx = params[pi++];\n          const cy = params[pi++];\n          const r = params[pi++];\n          const startAngle = params[pi++];\n          const endAngle = params[pi++];\n          const counterClockwise = Boolean(params[pi++]);\n          intersectionCount += arcIntersections(\n            cx,\n            cy,\n            r,\n            startAngle,\n            endAngle,\n            counterClockwise,\n            ox,\n            oy,\n            x,\n            y\n          );\n          if (!isNaN(sx)) {\n            const startX = cx + Math.cos(startAngle) * r;\n            const startY = cy + Math.sin(startAngle) * r;\n            intersectionCount += segmentIntersection(px, py, startX, startY, ox, oy, x, y);\n          }\n          px = cx + Math.cos(endAngle) * r;\n          py = cy + Math.sin(endAngle) * r;\n          break;\n        }\n        case 4 /* ClosePath */:\n          intersectionCount += segmentIntersection(sx, sy, px, py, ox, oy, x, y);\n          break;\n      }\n    }\n    return intersectionCount % 2 === 1;\n  }\n  distanceSquared(x, y) {\n    let best = Infinity;\n    const commands = this.commands;\n    const params = this.params;\n    const cn = commands.length;\n    let sx = NaN;\n    let sy = NaN;\n    let px = 0;\n    let py = 0;\n    for (let ci = 0, pi = 0; ci < cn; ci++) {\n      switch (commands[ci]) {\n        case 0 /* Move */:\n          px = sx = params[pi++];\n          py = sy = params[pi++];\n          break;\n        case 1 /* Line */: {\n          const nx = params[pi++];\n          const ny = params[pi++];\n          best = lineDistanceSquared(x, y, px, py, nx, ny, best);\n          break;\n        }\n        case 3 /* Curve */:\n          Logger.error(\"Command.Curve distanceSquare not implemented\");\n          break;\n        case 2 /* Arc */: {\n          const cx = params[pi++];\n          const cy = params[pi++];\n          const r = params[pi++];\n          const startAngle = params[pi++];\n          const endAngle = params[pi++];\n          const startX = cx + Math.cos(startAngle) * r;\n          const startY = cy + Math.sin(startAngle) * r;\n          const counterClockwise = Boolean(params[pi++]);\n          best = lineDistanceSquared(x, y, px, py, startX, startY, best);\n          best = arcDistanceSquared(x, y, cx, cy, r, startAngle, endAngle, counterClockwise, best);\n          px = cx + Math.cos(endAngle) * r;\n          py = cy + Math.sin(endAngle) * r;\n          break;\n        }\n        case 4 /* ClosePath */:\n          best = lineDistanceSquared(x, y, px, py, sx, sy, best);\n          break;\n      }\n    }\n    return best;\n  }\n  getPoints() {\n    const { commands, params } = this;\n    const coords = [];\n    let pi = 0;\n    for (const command of commands) {\n      switch (command) {\n        case 0 /* Move */:\n        case 1 /* Line */:\n          coords.push({ x: params[pi++], y: params[pi++] });\n          break;\n        case 3 /* Curve */:\n          pi += 4;\n          coords.push({ x: params[pi++], y: params[pi++] });\n          break;\n        case 2 /* Arc */:\n          coords.push({ x: params[pi++], y: params[pi++] });\n          pi += 4;\n          break;\n        case 4 /* ClosePath */:\n          break;\n      }\n    }\n    return coords;\n  }\n  // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d\n  toSVG(transform = (x, y) => ({ x, y })) {\n    const buffer = [];\n    const { commands, params } = this;\n    const addCommand = (command, ...points) => {\n      buffer.push(command);\n      for (let i = 0; i < points.length; i += 2) {\n        const { x, y } = transform(points[i], points[i + 1]);\n        buffer.push(x, y);\n      }\n    };\n    let pi = 0;\n    for (const command of commands) {\n      switch (command) {\n        case 0 /* Move */:\n          addCommand(\"M\", params[pi++], params[pi++]);\n          break;\n        case 1 /* Line */:\n          addCommand(\"L\", params[pi++], params[pi++]);\n          break;\n        case 3 /* Curve */:\n          addCommand(\"C\", params[pi++], params[pi++], params[pi++], params[pi++], params[pi++], params[pi++]);\n          break;\n        case 2 /* Arc */: {\n          const cx = params[pi++];\n          const cy = params[pi++];\n          const r = params[pi++];\n          const A0 = params[pi++];\n          const A1 = params[pi++];\n          const ccw = params[pi++];\n          let sweep = ccw ? A0 - A1 : A1 - A0;\n          if (sweep < 0) {\n            sweep += Math.ceil(-sweep / (2 * Math.PI)) * 2 * Math.PI;\n          }\n          if (ccw) {\n            sweep = -sweep;\n          }\n          const arcSections = Math.max(Math.ceil(Math.abs(sweep) / (Math.PI / 2)), 1);\n          const step = sweep / arcSections;\n          const h = 4 / 3 * Math.tan(step / 4);\n          const move = buffer.length === 0 ? \"M\" : \"L\";\n          addCommand(move, cx + Math.cos(A0) * r, cy + Math.sin(A0) * r);\n          for (let i = 0; i < arcSections; i += 1) {\n            const a0 = A0 + step * (i + 0);\n            const a1 = A0 + step * (i + 1);\n            const rSinStart = r * Math.sin(a0);\n            const rCosStart = r * Math.cos(a0);\n            const rSinEnd = r * Math.sin(a1);\n            const rCosEnd = r * Math.cos(a1);\n            addCommand(\n              \"C\",\n              cx + rCosStart - h * rSinStart,\n              cy + rSinStart + h * rCosStart,\n              cx + rCosEnd + h * rSinEnd,\n              cy + rSinEnd - h * rCosEnd,\n              cx + rCosEnd,\n              cy + rSinEnd\n            );\n          }\n          break;\n        }\n        case 4 /* ClosePath */:\n          buffer.push(\"Z\");\n          break;\n      }\n    }\n    return buffer.join(\" \");\n  }\n  computeBBox() {\n    const { commands, params } = this;\n    let [top, left, right, bot] = [Infinity, Infinity, -Infinity, -Infinity];\n    let [sx, sy] = [NaN, NaN];\n    let [mx, my] = [NaN, NaN];\n    const joinPoint = (x, y, updatestart) => {\n      top = Math.min(y, top);\n      left = Math.min(x, left);\n      right = Math.max(x, right);\n      bot = Math.max(y, bot);\n      if (updatestart) {\n        [sx, sy] = [x, y];\n      }\n    };\n    let pi = 0;\n    for (const command of commands) {\n      switch (command) {\n        case 0 /* Move */:\n          joinPoint(params[pi++], params[pi++], true);\n          [mx, my] = [sx, sy];\n          break;\n        case 1 /* Line */:\n          joinPoint(params[pi++], params[pi++], true);\n          break;\n        case 3 /* Curve */: {\n          const cp1x = params[pi++];\n          const cp1y = params[pi++];\n          const cp2x = params[pi++];\n          const cp2y = params[pi++];\n          const x = params[pi++];\n          const y = params[pi++];\n          joinPoint(x, y, true);\n          const Ts = calculateDerivativeExtremaXY(sx, sy, cp1x, cp1y, cp2x, cp2y, x, y);\n          Ts.forEach((t) => {\n            const px = evaluateBezier(sx, cp1x, cp2x, x, t);\n            const py = evaluateBezier(sy, cp1y, cp2y, y, t);\n            joinPoint(px, py);\n          });\n          break;\n        }\n        case 2 /* Arc */: {\n          const cx = params[pi++];\n          const cy = params[pi++];\n          const r = params[pi++];\n          let A0 = normalizeAngle360(params[pi++]);\n          let A1 = normalizeAngle360(params[pi++]);\n          const ccw = params[pi++];\n          if (ccw) {\n            [A0, A1] = [A1, A0];\n          }\n          const joinAngle = (angle2, updatestart) => {\n            const px = cx + r * Math.cos(angle2);\n            const py = cy + r * Math.sin(angle2);\n            joinPoint(px, py, updatestart);\n          };\n          joinAngle(A0);\n          joinAngle(A1, true);\n          const criticalAngles = [0, Math.PI / 2, Math.PI, 3 * Math.PI / 2];\n          for (const crit of criticalAngles) {\n            if (A0 < A1 && A0 <= crit && crit <= A1 || A0 > A1 && (A0 <= crit || crit <= A1)) {\n              joinAngle(crit);\n            }\n          }\n          break;\n        }\n        case 4 /* ClosePath */:\n          [sx, sy] = [mx, my];\n          break;\n      }\n    }\n    return new BBox(left, top, right - left, bot - top);\n  }\n};\n\n// packages/ag-charts-community/src/scene/shape/path.ts\nfunction ScenePathChangeDetection(opts) {\n  const { redraw = 3 /* MAJOR */, changeCb, convertor } = opts ?? {};\n  return SceneChangeDetection({ redraw, type: \"path\", convertor, changeCb });\n}\nvar Path = class extends Shape {\n  constructor() {\n    super(...arguments);\n    /**\n     * Declare a path to retain for later rendering and hit testing\n     * using custom Path2D class. Think of it as a TypeScript version\n     * of the native Path2D (with some differences) that works in all browsers.\n     */\n    this.path = new ExtendedPath2D();\n    this._clipX = NaN;\n    this._clipY = NaN;\n    this.clip = false;\n    /**\n     * The path only has to be updated when certain attributes change.\n     * For example, if transform attributes (such as `translationX`)\n     * are changed, we don't have to update the path. The `dirtyPath` flag\n     * is how we keep track if the path has to be updated or not.\n     */\n    this._dirtyPath = true;\n  }\n  set clipX(value) {\n    this._clipX = value;\n    this.dirtyPath = true;\n  }\n  set clipY(value) {\n    this._clipY = value;\n    this.dirtyPath = true;\n  }\n  set dirtyPath(value) {\n    if (this._dirtyPath !== value) {\n      this._dirtyPath = value;\n      if (value) {\n        this.markDirty(3 /* MAJOR */);\n      }\n    }\n  }\n  get dirtyPath() {\n    return this._dirtyPath;\n  }\n  checkPathDirty() {\n    if (this._dirtyPath) {\n      return;\n    }\n    this.dirtyPath = this.path.isDirty() || (this.fillShadow?.isDirty() ?? false) || (this._clipPath?.isDirty() ?? false);\n  }\n  isPointInPath(x, y) {\n    this.updatePathIfDirty();\n    return this.path.closedPath && this.path.isPointInPath(x, y);\n  }\n  distanceSquared(x, y) {\n    return this.distanceSquaredTransformedPoint(x, y);\n  }\n  svgPathData(transform) {\n    if (this.dirtyPath) {\n      this.updatePath();\n      this.dirtyPath = false;\n    }\n    return this.path.toSVG(transform);\n  }\n  distanceSquaredTransformedPoint(x, y) {\n    this.updatePathIfDirty();\n    if (this.path.closedPath && this.path.isPointInPath(x, y)) {\n      return 0;\n    }\n    return this.path.distanceSquared(x, y);\n  }\n  isDirtyPath() {\n    return false;\n  }\n  updatePath() {\n  }\n  updatePathIfDirty() {\n    if (this.dirtyPath || this.isDirtyPath()) {\n      this.updatePath();\n      this.dirtyPath = false;\n    }\n  }\n  preRender() {\n    this.updatePathIfDirty();\n    return super.preRender();\n  }\n  render(renderCtx) {\n    const { ctx, forceRender, stats } = renderCtx;\n    if (this.dirty === 0 /* NONE */ && !forceRender) {\n      if (stats)\n        stats.nodesSkipped += nodeCount(this).count;\n      return;\n    }\n    if (this.clip && !isNaN(this._clipX) && !isNaN(this._clipY)) {\n      ctx.save();\n      const margin = this.strokeWidth / 2;\n      this._clipPath ?? (this._clipPath = new ExtendedPath2D());\n      this._clipPath.clear();\n      this._clipPath.rect(-margin, -margin, this._clipX + margin, this._clipY + margin + margin);\n      ctx.clip(this._clipPath?.getPath2D());\n      if (this._clipX > 0 && this._clipY > 0) {\n        this.drawPath(ctx);\n      }\n      ctx.restore();\n    } else {\n      this._clipPath = void 0;\n      this.drawPath(ctx);\n    }\n    this.fillShadow?.markClean();\n    super.render(renderCtx);\n  }\n  drawPath(ctx) {\n    this.fillStroke(ctx, this.path.getPath2D());\n  }\n  toSVG() {\n    if (!this.visible)\n      return;\n    const element2 = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n    element2.setAttribute(\"d\", this.svgPathData());\n    element2.setAttribute(\"fill\", typeof this.fill === \"string\" ? this.fill : \"none\");\n    element2.setAttribute(\"fill-opacity\", String(this.fillOpacity));\n    if (this.stroke != null) {\n      element2.setAttribute(\"stroke\", this.stroke);\n      element2.setAttribute(\"stroke-opacity\", String(this.strokeOpacity));\n      element2.setAttribute(\"stroke-width\", String(this.strokeWidth));\n    }\n    return {\n      elements: [element2]\n    };\n  }\n};\nPath.className = \"Path\";\n__decorateClass([\n  ScenePathChangeDetection()\n], Path.prototype, \"clip\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Path.prototype, \"clipX\", 1);\n__decorateClass([\n  ScenePathChangeDetection()\n], Path.prototype, \"clipY\", 1);\n\n// packages/ag-charts-community/src/dom/focusIndicator.ts\nvar FOCUS_INDICATOR_CSS_CLASS = \"ag-charts-focus-indicator\";\nvar FocusIndicator = class {\n  constructor(domManager) {\n    this.domManager = domManager;\n    this.div = getDocument().createElement(\"div\");\n    this.svg = getDocument().createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n    this.path = getDocument().createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n    this.svg.append(this.path);\n    this.element = domManager.addChild(\"series-area\", FOCUS_INDICATOR_CSS_CLASS);\n    this.element.classList.add(FOCUS_INDICATOR_CSS_CLASS);\n    this.element.ariaHidden = \"true\";\n    this.element.append(this.svg);\n  }\n  destroy() {\n    this.domManager.removeStyles(FOCUS_INDICATOR_CSS_CLASS);\n    this.domManager.removeChild(\"series-area\", FOCUS_INDICATOR_CSS_CLASS);\n  }\n  updateBounds(bounds) {\n    if (bounds === void 0) {\n    } else if (bounds instanceof Path) {\n      const transform = (x, y) => Transformable.toCanvasPoint(bounds, x, y);\n      this.path.setAttribute(\"d\", bounds.svgPathData(transform));\n      this.show(this.svg);\n    } else {\n      setElementBBox(this.div, bounds);\n      this.show(this.div);\n    }\n  }\n  show(child) {\n    this.element.innerHTML = \"\";\n    this.element.append(child);\n  }\n  getFocusableElement() {\n    const focusable = this.element.parentElement;\n    if (focusable == null || focusable.tabIndex !== 0 && focusable.tabIndex !== -1)\n      throw new Error(\"AG Charts - the focus indicator must be a child of a focusable element\");\n    return focusable;\n  }\n  // Use with caution! The focus must be visible when using the keyboard.\n  overrideFocusVisible(focusVisible) {\n    const opacity = { true: \"1\", false: \"0\", undefined: \"\" };\n    this.getFocusableElement().style.setProperty(\"opacity\", opacity[`${focusVisible}`]);\n  }\n  // Get the `:focus-visible` CSS state.\n  isFocusVisible() {\n    const focusable = this.getFocusableElement();\n    return focusable != null && getWindow().getComputedStyle(focusable).opacity === \"1\";\n  }\n};\n\n// packages/ag-charts-community/src/dom/boundedText.ts\nvar BoundedText = class {\n  set textContent(text) {\n    this.textElement.textContent = text;\n    const bboxCalculator = this.textElement;\n    const bbox = bboxCalculator.getBBox?.();\n    if (bbox) {\n      this.svgElement.setAttribute(\"viewBox\", `${bbox.x} ${bbox.y} ${bbox.width} ${bbox.height}`);\n    }\n  }\n  get textContent() {\n    return this.textElement.textContent;\n  }\n  constructor() {\n    this.textElement = createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n    this.textElement.role = \"presentation\";\n    this.svgElement = createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n    this.svgElement.appendChild(this.textElement);\n    this.svgElement.style.width = \"100%\";\n    this.svgElement.style.opacity = \"0\";\n    this.svgElement.role = \"presentation\";\n    this.boundedContainer = createElement(\"div\");\n    this.boundedContainer.appendChild(this.svgElement);\n    this.boundedContainer.role = \"presentation\";\n  }\n  remove() {\n    this.boundedContainer.remove();\n  }\n  getContainer() {\n    return this.boundedContainer;\n  }\n  updateBounds(bounds) {\n    setElementBBox(this.boundedContainer, bounds);\n  }\n};\n\n// packages/ag-charts-community/src/dom/proxyInteractionService.ts\nfunction checkType(type, meta) {\n  return meta.params?.type === type;\n}\nfunction allocateResult(type) {\n  if (\"button\" === type) {\n    return createElement(\"button\");\n  } else if (\"slider\" === type) {\n    return createElement(\"input\");\n  } else if ([\"toolbar\", \"group\", \"list\"].includes(type)) {\n    return createElement(\"div\");\n  } else if (\"text\" === type) {\n    return new BoundedText();\n  } else if (\"listswitch\" === type) {\n    return { button: createElement(\"button\"), listitem: createElement(\"div\") };\n  } else {\n    throw Error(\"AG Charts - error allocating meta\");\n  }\n}\nfunction allocateMeta(params) {\n  const meta = { params, result: void 0 };\n  meta.result = allocateResult(meta.params.type);\n  return meta;\n}\nvar ProxyInteractionService = class {\n  constructor(localeManager, domManager) {\n    this.localeManager = localeManager;\n    this.domManager = domManager;\n    this.destroyFns = [];\n  }\n  destroy() {\n    this.destroyFns.forEach((fn) => fn());\n  }\n  addLocalisation(fn) {\n    fn();\n    this.destroyFns.push(this.localeManager.addListener(\"locale-changed\", fn));\n  }\n  createProxyContainer(args) {\n    const meta = allocateMeta(args);\n    const { params, result: div } = meta;\n    this.domManager.addChild(\"canvas-proxy\", params.id, div);\n    div.classList.add(...params.classList, \"ag-charts-proxy-container\");\n    div.role = params.type;\n    if (\"ariaOrientation\" in params) {\n      div.ariaOrientation = params.ariaOrientation;\n    }\n    if (typeof params.ariaHidden === \"boolean\") {\n      div.ariaHidden = params.ariaHidden.toString();\n    }\n    this.addLocalisation(() => {\n      div.ariaLabel = this.localeManager.t(params.ariaLabel.id, params.ariaLabel.params);\n    });\n    return div;\n  }\n  createProxyElement(args) {\n    const meta = allocateMeta(args);\n    if (checkType(\"button\", meta)) {\n      const { params, result: button } = meta;\n      this.initInteract(params, button);\n      button.style.pointerEvents = \"auto\";\n      if (typeof params.textContent === \"string\") {\n        button.textContent = params.textContent;\n      } else {\n        const { textContent } = params;\n        this.addLocalisation(() => {\n          button.textContent = this.localeManager.t(textContent.id, textContent.params);\n        });\n      }\n      this.setParent(params, button);\n    }\n    if (checkType(\"slider\", meta)) {\n      const { params, result: slider } = meta;\n      this.initInteract(params, slider);\n      slider.type = \"range\";\n      slider.role = \"presentation\";\n      slider.style.margin = \"0px\";\n      slider.ariaOrientation = params.ariaOrientation;\n      this.addLocalisation(() => {\n        slider.ariaLabel = this.localeManager.t(params.ariaLabel.id, params.ariaLabel.params);\n      });\n      this.setParent(params, slider);\n    }\n    if (checkType(\"text\", meta)) {\n      const { params, result: text } = meta;\n      this.initElement(params, text.getContainer());\n      this.setParent(params, text.getContainer());\n    }\n    if (checkType(\"listswitch\", meta)) {\n      const {\n        params,\n        result: { button, listitem }\n      } = meta;\n      this.initInteract(params, button);\n      button.style.width = \"100%\";\n      button.style.height = \"100%\";\n      button.textContent = params.textContent;\n      button.role = \"switch\";\n      button.ariaChecked = params.ariaChecked.toString();\n      button.style.pointerEvents = \"auto\";\n      button.setAttribute(\"aria-describedby\", params.ariaDescribedBy);\n      listitem.role = \"listitem\";\n      listitem.style.position = \"absolute\";\n      listitem.replaceChildren(button);\n      this.setParent(params, listitem);\n    }\n    return meta.result;\n  }\n  initElement(params, element2) {\n    const { id } = params;\n    element2.id = id;\n    element2.classList.toggle(\"ag-charts-proxy-elem\", true);\n  }\n  initInteract(params, element2) {\n    const { onclick, ondblclick, onmouseenter, onmouseleave, oncontextmenu, onchange, onfocus, onblur, tabIndex } = params;\n    this.initElement(params, element2);\n    if (tabIndex !== void 0) {\n      element2.tabIndex = tabIndex;\n    }\n    if (onclick) {\n      element2.addEventListener(\"click\", onclick);\n    }\n    if (ondblclick) {\n      element2.addEventListener(\"dblclick\", ondblclick);\n    }\n    if (onmouseenter) {\n      element2.addEventListener(\"mouseenter\", onmouseenter);\n    }\n    if (onmouseleave) {\n      element2.addEventListener(\"mouseleave\", onmouseleave);\n    }\n    if (oncontextmenu) {\n      element2.addEventListener(\"contextmenu\", oncontextmenu);\n    }\n    if (onfocus) {\n      element2.addEventListener(\"focus\", onfocus);\n    }\n    if (onblur) {\n      element2.addEventListener(\"blur\", onblur);\n    }\n    if (onchange) {\n      element2.addEventListener(\"change\", onchange);\n    }\n  }\n  setParent(params, element2) {\n    const { id, parent } = params;\n    if (typeof parent === \"string\") {\n      const insert = { where: parent, query: \".ag-charts-series-area\" };\n      this.domManager.addChild(\"canvas-proxy\", id, element2, insert);\n    } else {\n      parent.appendChild(element2);\n    }\n  }\n};\n\n// packages/ag-charts-community/src/locale/defaultMessageFormatter.ts\nvar messageRegExp = /\\$\\{(\\w+)}(?:\\[(\\w+)])?/gi;\nvar formatters = {\n  number: new Intl.NumberFormat(\"en-US\"),\n  percent: new Intl.NumberFormat(\"en-US\", { style: \"percent\", minimumFractionDigits: 2, maximumFractionDigits: 2 }),\n  date: new Intl.DateTimeFormat(\"en-US\", { dateStyle: \"full\" }),\n  time: new Intl.DateTimeFormat(\"en-US\", { timeStyle: \"full\" }),\n  datetime: new Intl.DateTimeFormat(\"en-US\", { dateStyle: \"full\", timeStyle: \"full\" })\n};\nvar defaultMessageFormatter = ({ defaultValue, variables }) => {\n  return defaultValue?.replaceAll(messageRegExp, (_, match, format) => {\n    const value = variables[match];\n    const formatter = format != null ? formatters[format] : null;\n    if (format != null && formatter == null) {\n      Logger.warnOnce(`Format style [${format}] is not supported`);\n    }\n    if (formatter != null) {\n      return formatter.format(value);\n    } else if (typeof value === \"number\") {\n      return formatters.number.format(value);\n    } else if (value instanceof Date) {\n      return formatters.datetime.format(value);\n    }\n    return String(value);\n  });\n};\n\n// packages/ag-charts-community/src/locale/localeManager.ts\nvar LocaleManager = class extends Listeners {\n  constructor() {\n    super(...arguments);\n    this.localeText = void 0;\n    this.getLocaleText = void 0;\n  }\n  setLocaleText(localeText) {\n    if (this.localeText !== localeText) {\n      this.localeText = localeText;\n      this.dispatch(\"locale-changed\");\n    }\n  }\n  setLocaleTextFormatter(getLocaleText) {\n    this.getLocaleText = getLocaleText;\n    if (this.getLocaleText !== getLocaleText) {\n      this.getLocaleText = getLocaleText;\n      this.dispatch(\"locale-changed\");\n    }\n  }\n  t(key, variables = {}) {\n    const { localeText = AG_CHARTS_LOCALE_EN_US, getLocaleText } = this;\n    const defaultValue = localeText[key];\n    return getLocaleText?.({ key, defaultValue, variables }) ?? defaultMessageFormatter({ key, defaultValue, variables }) ?? key;\n  }\n};\n\n// packages/ag-charts-community/src/util/userAgent.ts\nfunction hasConstrainedCanvasMemory() {\n  if (typeof navigator === \"undefined\") {\n    return false;\n  }\n  const iPhoneOSMatch = /\\(iPhone; CPU iPhone OS (\\d+_\\d+_\\d+) like Mac OS X\\)/.exec(navigator.userAgent);\n  if (iPhoneOSMatch == null) {\n    return false;\n  }\n  const [major, minor] = iPhoneOSMatch[1].split(\"_\").map(Number);\n  return major < 16 || major === 16 && minor < 6;\n}\n\n// packages/ag-charts-community/src/scene/canvas/hdpiCanvas.ts\nvar _HdpiCanvas = class _HdpiCanvas {\n  constructor(options) {\n    this.enabled = true;\n    this.width = 600;\n    this.height = 300;\n    const { width: width2, height: height2, pixelRatio, canvasElement, willReadFrequently = false } = options;\n    this.pixelRatio = hasConstrainedCanvasMemory() ? 1 : pixelRatio ?? getWindow(\"devicePixelRatio\");\n    this.element = canvasElement ?? createElement(\"canvas\");\n    this.element.style.display = \"block\";\n    this.element.style.width = (width2 ?? this.width) + \"px\";\n    this.element.style.height = (height2 ?? this.height) + \"px\";\n    this.element.width = Math.round((width2 ?? this.width) * this.pixelRatio);\n    this.element.height = Math.round((height2 ?? this.height) * this.pixelRatio);\n    this.context = this.element.getContext(\"2d\", { willReadFrequently });\n    this.onEnabledChange();\n    this.resize(width2 ?? 0, height2 ?? 0);\n    _HdpiCanvas.debugContext(this.context);\n  }\n  static is(value) {\n    return value instanceof _HdpiCanvas;\n  }\n  drawImage(context, dx = 0, dy = 0) {\n    return context.drawImage(this.context.canvas, dx, dy);\n  }\n  toDataURL(type) {\n    return this.element.toDataURL(type);\n  }\n  resize(width2, height2) {\n    if (!(width2 > 0 && height2 > 0))\n      return;\n    const { element: element2, context, pixelRatio } = this;\n    element2.width = Math.round(width2 * pixelRatio);\n    element2.height = Math.round(height2 * pixelRatio);\n    context.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n    element2.style.width = width2 + \"px\";\n    element2.style.height = height2 + \"px\";\n    this.width = width2;\n    this.height = height2;\n  }\n  clear() {\n    this.context.save();\n    this.context.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);\n    this.context.clearRect(0, 0, this.width, this.height);\n    this.context.restore();\n  }\n  destroy() {\n    this.element.remove();\n    this.element.width = 0;\n    this.element.height = 0;\n    this.context.clearRect(0, 0, 0, 0);\n    Object.freeze(this);\n  }\n  onEnabledChange() {\n    if (this.element) {\n      this.element.style.display = this.enabled ? \"\" : \"none\";\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\n  static debugContext(ctx) {\n    if (Debug.check(\"canvas\")) {\n      const save = ctx.save.bind(ctx);\n      const restore = ctx.restore.bind(ctx);\n      let depth = 0;\n      Object.assign(ctx, {\n        save() {\n          save();\n          depth++;\n        },\n        restore() {\n          if (depth === 0) {\n            throw new Error(\"AG Charts - Unable to restore() past depth 0\");\n          }\n          restore();\n          depth--;\n        },\n        verifyDepthZero() {\n          if (depth !== 0) {\n            throw new Error(`AG Charts - Save/restore depth is non-zero: ${depth}`);\n          }\n        }\n      });\n    }\n  }\n};\n__decorateClass([\n  ObserveChanges((target) => target.onEnabledChange())\n], _HdpiCanvas.prototype, \"enabled\", 2);\nvar HdpiCanvas = _HdpiCanvas;\n\n// packages/ag-charts-community/src/scene/layersManager.ts\nvar LayersManager = class _LayersManager {\n  constructor(canvas, markDirty) {\n    this.canvas = canvas;\n    this.markDirty = markDirty;\n    this.debug = Debug.create(true, \"scene\");\n    this.layersMap = /* @__PURE__ */ new Map();\n    this.nextZIndex = 0;\n    this.nextLayerId = 0;\n  }\n  static sortLayers(a, b) {\n    return compoundAscending(\n      [a.zIndex, ...a.zIndexSubOrder ?? [void 0, void 0], a.id],\n      [b.zIndex, ...b.zIndexSubOrder ?? [void 0, void 0], b.id],\n      ascendingStringNumberUndefined\n    );\n  }\n  get size() {\n    return this.layersMap.size;\n  }\n  forEach(callback2) {\n    Array.from(this.layersMap.values()).sort(_LayersManager.sortLayers).forEach(callback2);\n  }\n  resize(width2, height2) {\n    this.canvas.resize(width2, height2);\n    this.layersMap.forEach(({ canvas }) => canvas.resize(width2, height2));\n  }\n  addLayer(opts) {\n    const { width: width2, height: height2, pixelRatio } = this.canvas;\n    const { zIndex = this.nextZIndex++, name, zIndexSubOrder, getComputedOpacity, getVisibility } = opts;\n    const canvas = new HdpiCanvas({ width: width2, height: height2, pixelRatio });\n    if (zIndex >= this.nextZIndex) {\n      this.nextZIndex = zIndex + 1;\n    }\n    this.layersMap.set(canvas, {\n      id: this.nextLayerId++,\n      name,\n      canvas,\n      zIndex,\n      zIndexSubOrder,\n      getComputedOpacity,\n      getVisibility\n    });\n    this.debug(\"Scene.addLayer() - layers\", this.layersMap);\n    return canvas;\n  }\n  removeLayer(canvas) {\n    if (this.layersMap.has(canvas)) {\n      this.layersMap.delete(canvas);\n      canvas.destroy();\n      this.markDirty();\n      this.debug(\"Scene.removeLayer() -  layers\", this.layersMap);\n    }\n  }\n  moveLayer(canvas, newZIndex, newZIndexSubOrder) {\n    const layer = this.layersMap.get(canvas);\n    if (layer) {\n      layer.zIndex = newZIndex;\n      layer.zIndexSubOrder = newZIndexSubOrder;\n      this.markDirty();\n      this.debug(\"Scene.moveLayer() -  layers\", this.layersMap);\n    }\n  }\n  clear() {\n    this.layersMap.clear();\n  }\n};\n\n// packages/ag-charts-community/src/scene/spriteRenderer.ts\nvar _SpriteRenderer = class _SpriteRenderer {\n  constructor() {\n    this.offscreenCanvas = typeof OffscreenCanvas !== \"undefined\" ? new OffscreenCanvas(0, 0) : createElement(\"canvas\");\n    _SpriteRenderer.offscreenCanvasCount++;\n    const ctx = this.offscreenCanvas.getContext(\"2d\");\n    if (ctx == null)\n      throw new TypeError(`AG Charts - invalid 2d context`);\n    this.renderCtx = {\n      ctx,\n      devicePixelRatio: 1,\n      forceRender: true,\n      resized: false,\n      debugNodes: {}\n    };\n  }\n  resize({ spritePixelRatio, spriteWidth, spriteHeight }) {\n    this.offscreenCanvas.width = Math.max(spriteWidth, 0) * spritePixelRatio;\n    this.offscreenCanvas.height = Math.max(spriteHeight, 0) * spritePixelRatio;\n  }\n  renderSprite(nodes, opts) {\n    nodes = toIterable(nodes);\n    const {\n      renderCtx,\n      renderCtx: { ctx },\n      offscreenCanvas\n    } = this;\n    const { scale: scale2 = 1, translateX = 0, translateY = 0 } = opts ?? {};\n    ctx.resetTransform();\n    ctx.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);\n    ctx.save();\n    ctx.beginPath();\n    ctx.setTransform(scale2, 0, 0, scale2, translateX, translateY);\n    for (const node of nodes) {\n      node.preRender();\n      node.render(renderCtx);\n    }\n    ctx.closePath();\n    ctx.restore();\n    if (\"transferToImageBitmap\" in this.offscreenCanvas) {\n      return this.offscreenCanvas.transferToImageBitmap();\n    }\n    const canvas = createElement(\"canvas\");\n    canvas.style.display = \"block\";\n    canvas.style.width = offscreenCanvas.width + \"px\";\n    canvas.style.height = offscreenCanvas.height + \"px\";\n    canvas.getContext(\"2d\")?.putImageData(ctx.getImageData(0, 0, offscreenCanvas.width, offscreenCanvas.height), 0, 0);\n    return canvas;\n  }\n};\n_SpriteRenderer.offscreenCanvasCount = 0;\nvar SpriteRenderer = _SpriteRenderer;\n\n// packages/ag-charts-community/src/scene/sceneDebug.ts\nfunction debugStats(layersManager, debugSplitTimes, ctx, renderCtxStats, extraDebugStats = {}, seriesRect = BBox.zero) {\n  if (!Debug.check(\"scene:stats\" /* SCENE_STATS */, \"scene:stats:verbose\" /* SCENE_STATS_VERBOSE */))\n    return;\n  const { layersRendered = 0, layersSkipped = 0, nodesRendered = 0, nodesSkipped = 0 } = renderCtxStats ?? {};\n  const end2 = performance.now();\n  const { start: start2, ...durations } = debugSplitTimes;\n  const splits = Object.entries(durations).map(([n, t]) => {\n    return time(n, t);\n  }).filter((v) => v != null).join(\" + \");\n  const extras = Object.entries(extraDebugStats).map(([k, v]) => `${k}: ${v}`).join(\" ; \");\n  const detailedStats = Debug.check(\"scene:stats:verbose\" /* SCENE_STATS_VERBOSE */);\n  const stats = [\n    `${time(\"\\u23F1\\uFE0F\", start2, end2)} (${splits})`,\n    `${extras}`,\n    `Layers: ${detailedStats ? pct(layersRendered, layersSkipped) : layersManager.size}; Sprites: ${SpriteRenderer.offscreenCanvasCount}`,\n    detailedStats ? `Nodes: ${pct(nodesRendered, nodesSkipped)}` : null\n  ].filter(isString);\n  const measurer = new SimpleTextMeasurer((t) => ctx.measureText(t));\n  const statsSize = new Map(stats.map((t) => [t, measurer.measureLines(t)]));\n  const width2 = Math.max(...Array.from(statsSize.values(), (s) => s.width));\n  const height2 = accumulate(statsSize.values(), (s) => s.height);\n  const x = 2 + seriesRect.x;\n  ctx.save();\n  ctx.fillStyle = \"white\";\n  ctx.fillRect(x, 0, width2, height2);\n  ctx.fillStyle = \"black\";\n  let y = 0;\n  for (const [stat, size] of statsSize.entries()) {\n    y += size.height;\n    ctx.fillText(stat, x, y);\n  }\n  ctx.restore();\n}\nfunction prepareSceneNodeHighlight(ctx) {\n  const config = toArray(getWindow(\"agChartsSceneDebug\"));\n  const result = [];\n  for (const name of config) {\n    if (name === \"layout\") {\n      result.push(\"seriesRoot\", \"legend\", \"root\", /.*Axis-\\d+-axis.*/);\n    } else {\n      result.push(name);\n    }\n  }\n  ctx.debugNodeSearch = result;\n}\nfunction debugSceneNodeHighlight(ctx, debugNodes) {\n  ctx.save();\n  for (const [name, node] of Object.entries(debugNodes)) {\n    const bbox = Transformable.toCanvas(node);\n    if (!bbox) {\n      Logger.log(`Scene.render() - no bbox for debugged node [${name}].`);\n      continue;\n    }\n    ctx.globalAlpha = 0.8;\n    ctx.strokeStyle = \"red\";\n    ctx.lineWidth = 1;\n    ctx.strokeRect(bbox.x, bbox.y, bbox.width, bbox.height);\n    ctx.fillStyle = \"red\";\n    ctx.strokeStyle = \"white\";\n    ctx.font = \"16px sans-serif\";\n    ctx.textBaseline = \"top\";\n    ctx.textAlign = \"left\";\n    ctx.lineWidth = 2;\n    ctx.strokeText(name, bbox.x, bbox.y, bbox.width);\n    ctx.fillText(name, bbox.x, bbox.y, bbox.width);\n  }\n  ctx.restore();\n}\nvar skippedProperties = /* @__PURE__ */ new Set();\nvar allowedProperties = /* @__PURE__ */ new Set([\n  \"gradient\",\n  // '_datum',\n  \"zIndex\",\n  \"clipRect\",\n  \"cachedBBox\",\n  \"childNodeCounts\",\n  \"path\",\n  \"__zIndex\",\n  \"name\",\n  \"__scalingCenterX\",\n  \"__scalingCenterY\",\n  \"__rotationCenterX\",\n  \"__rotationCenterY\",\n  \"_previousDatum\",\n  \"__fill\",\n  \"__lineDash\",\n  \"borderPath\",\n  \"borderClipPath\",\n  \"_clipPath\"\n]);\nfunction nodeProps(node) {\n  const { ...allProps } = node;\n  for (const prop in allProps) {\n    if (allowedProperties.has(prop))\n      continue;\n    if (typeof allProps[prop] === \"number\")\n      continue;\n    if (typeof allProps[prop] === \"string\")\n      continue;\n    if (typeof allProps[prop] === \"boolean\")\n      continue;\n    skippedProperties.add(prop);\n    delete allProps[prop];\n  }\n  return allProps;\n}\nfunction buildTree(node, mode) {\n  if (!Debug.check(true, \"scene\" /* SCENE */)) {\n    return {};\n  }\n  const { parentNode } = node;\n  let order = 0;\n  return {\n    node: mode === \"json\" ? nodeProps(node) : node,\n    name: node.name ?? node.id,\n    dirty: RedrawType[node.dirty],\n    ...parentNode?.isVirtual ? {\n      virtualParentDirty: RedrawType[parentNode.dirty],\n      virtualParent: parentNode\n    } : {},\n    ...Array.from(node.children(false), (c) => buildTree(c, mode)).reduce(\n      (result, childTree) => {\n        let { name: treeNodeName } = childTree;\n        const {\n          node: {\n            visible,\n            opacity,\n            zIndex,\n            zIndexSubOrder,\n            translationX,\n            translationY,\n            rotation,\n            scalingX,\n            scalingY\n          },\n          node: childNode,\n          virtualParent\n        } = childTree;\n        if (!visible || opacity <= 0) {\n          treeNodeName = `(${treeNodeName})`;\n        }\n        if (Layer.is(childNode)) {\n          treeNodeName = `*${treeNodeName}*`;\n        }\n        const subOrder = zIndexSubOrder?.map((v) => typeof v === \"function\" ? `${v()} (fn)` : v).join(\" / \");\n        const key = [\n          `${(order++).toString().padStart(3, \"0\")}|`,\n          `${treeNodeName ?? \"<unknown>\"}`,\n          `z: ${zIndex}`,\n          subOrder && `zo: ${subOrder}`,\n          virtualParent && `(virtual parent)`,\n          translationX && `x: ${translationX}`,\n          translationY && `y: ${translationY}`,\n          rotation && `r: ${rotation}`,\n          scalingX != null && scalingX !== 1 && `sx: ${scalingX}`,\n          scalingY != null && scalingY !== 1 && `sy: ${scalingY}`\n        ].filter((v) => !!v).join(\" \");\n        let selectedKey = key;\n        let index = 1;\n        while (result[selectedKey] != null && index < 100) {\n          selectedKey = `${key} (${index++})`;\n        }\n        result[selectedKey] = childTree;\n        return result;\n      },\n      {}\n    )\n  };\n}\nfunction buildDirtyTree(node) {\n  if (node.dirty === 0 /* NONE */) {\n    return { dirtyTree: {}, paths: [] };\n  }\n  const childrenDirtyTree = Array.from(node.children(), (c) => buildDirtyTree(c)).filter((c) => c.paths.length > 0);\n  const name = Group.is(node) ? node.name ?? node.id : node.id;\n  const paths = childrenDirtyTree.length ? childrenDirtyTree.flatMap((c) => c.paths).map((p) => `${name}.${p}`) : [name];\n  return {\n    dirtyTree: {\n      name,\n      node,\n      dirty: RedrawType[node.dirty],\n      ...childrenDirtyTree.map((c) => c.dirtyTree).filter((t) => t.dirty != null).reduce((result, childTree) => {\n        result[childTree.name ?? \"<unknown>\"] = childTree;\n        return result;\n      }, {})\n    },\n    paths\n  };\n}\nfunction pct(rendered, skipped) {\n  const total = rendered + skipped;\n  return `${rendered} / ${total} (${Math.round(100 * rendered / total)}%)`;\n}\nfunction time(name, start2, end2) {\n  const duration = end2 != null ? end2 - start2 : start2;\n  return `${name}: ${Math.round(duration * 100) / 100}ms`;\n}\nfunction accumulate(iterator, mapper) {\n  let sum2 = 0;\n  for (const item of iterator) {\n    sum2 += mapper(item);\n  }\n  return sum2;\n}\n\n// packages/ag-charts-community/src/scene/scene.ts\nvar Scene = class {\n  constructor(canvasOptions) {\n    this.debug = Debug.create(true, \"scene\" /* SCENE */);\n    this.id = createId(this);\n    this.root = null;\n    this.pendingSize = null;\n    this.isDirty = false;\n    this.canvas = new HdpiCanvas(canvasOptions);\n    this.layersManager = new LayersManager(this.canvas, () => {\n      this.isDirty = true;\n    });\n  }\n  get width() {\n    return this.pendingSize?.[0] ?? this.canvas.width;\n  }\n  get height() {\n    return this.pendingSize?.[1] ?? this.canvas.height;\n  }\n  /** @deprecated v10.2.0 Only used by AG Grid Sparklines */\n  setContainer(value) {\n    const { element: element2 } = this.canvas;\n    element2.parentElement?.removeChild(element2);\n    value.appendChild(element2);\n    return this;\n  }\n  setRoot(node) {\n    if (this.root === node) {\n      return this;\n    }\n    this.isDirty = true;\n    this.root?._setLayerManager();\n    this.root = node;\n    if (node) {\n      node.visible = true;\n      node._setLayerManager(this.layersManager);\n    }\n    return this;\n  }\n  attachNode(node) {\n    this.appendChild(node);\n    return () => this.removeChild(node);\n  }\n  appendChild(node) {\n    this.root?.appendChild(node);\n    return this;\n  }\n  removeChild(node) {\n    this.root?.removeChild(node);\n    return this;\n  }\n  download(fileName, fileFormat) {\n    downloadUrl(this.canvas.toDataURL(fileFormat), fileName?.trim() ?? \"image\");\n  }\n  /** NOTE: Integrated Charts undocumented image download method. */\n  getDataURL(fileFormat) {\n    return this.canvas.toDataURL(fileFormat);\n  }\n  resize(width2, height2) {\n    width2 = Math.round(width2);\n    height2 = Math.round(height2);\n    if (width2 > 0 && height2 > 0 && (width2 !== this.width || height2 !== this.height)) {\n      this.pendingSize = [width2, height2];\n      this.isDirty = true;\n      return true;\n    }\n    return false;\n  }\n  async render(opts) {\n    const { debugSplitTimes = { start: performance.now() }, extraDebugStats, seriesRect } = opts ?? {};\n    const { canvas, canvas: { context: ctx } = {}, root, pendingSize } = this;\n    if (!ctx) {\n      return;\n    }\n    const renderStartTime = performance.now();\n    if (pendingSize) {\n      this.layersManager.resize(...pendingSize);\n      this.pendingSize = null;\n    }\n    if (root && !root.visible) {\n      this.isDirty = false;\n      return;\n    }\n    if (root && !this.isDirty) {\n      if (this.debug.check()) {\n        this.debug(\"Scene.render() - no-op\", {\n          redrawType: RedrawType[root.dirty],\n          tree: buildTree(root, \"console\")\n        });\n      }\n      debugStats(this.layersManager, debugSplitTimes, ctx, void 0, extraDebugStats, seriesRect);\n      return;\n    }\n    const renderCtx = {\n      ctx,\n      devicePixelRatio: this.canvas.pixelRatio ?? 1,\n      forceRender: true,\n      resized: Boolean(pendingSize),\n      debugNodes: {}\n    };\n    if (Debug.check(\"scene:stats:verbose\" /* SCENE_STATS_VERBOSE */)) {\n      renderCtx.stats = { layersRendered: 0, layersSkipped: 0, nodesRendered: 0, nodesSkipped: 0 };\n    }\n    prepareSceneNodeHighlight(renderCtx);\n    let canvasCleared = false;\n    if (!root || root.dirty >= 1 /* TRIVIAL */) {\n      canvasCleared = true;\n      canvas.clear();\n    }\n    if (root && Debug.check(\"scene:dirtyTree\" /* SCENE_DIRTY_TREE */)) {\n      const { dirtyTree, paths } = buildDirtyTree(root);\n      Debug.create(\"scene:dirtyTree\" /* SCENE_DIRTY_TREE */)(\"Scene.render() - dirtyTree\", { dirtyTree, paths });\n    }\n    if (root && canvasCleared) {\n      if (root.visible) {\n        root.preRender();\n      }\n      if (this.debug.check()) {\n        const tree = buildTree(root, \"console\");\n        this.debug(\"Scene.render() - before\", {\n          redrawType: RedrawType[root.dirty],\n          canvasCleared,\n          tree\n        });\n      }\n      if (root.visible) {\n        ctx.save();\n        root.render(renderCtx);\n        ctx.restore();\n      }\n    }\n    debugSplitTimes[\"\\u270D\\uFE0F\"] = performance.now() - renderStartTime;\n    if (this.layersManager.size && canvasCleared) {\n      const layerRenderStart = performance.now();\n      ctx.save();\n      ctx.resetTransform();\n      this.layersManager.forEach((layer) => {\n        if (layer.canvas.enabled && layer.getVisibility()) {\n          ctx.globalAlpha = layer.getComputedOpacity();\n          layer.canvas.drawImage(ctx);\n        }\n      });\n      ctx.restore();\n      debugSplitTimes[\"\\u26D9\"] = performance.now() - layerRenderStart;\n    }\n    ctx.verifyDepthZero?.();\n    this.isDirty = false;\n    debugStats(this.layersManager, debugSplitTimes, ctx, renderCtx.stats, extraDebugStats, seriesRect);\n    debugSceneNodeHighlight(ctx, renderCtx.debugNodes);\n    if (root && this.debug.check()) {\n      this.debug(\"Scene.render() - after\", {\n        redrawType: RedrawType[root.dirty],\n        tree: buildTree(root, \"console\"),\n        canvasCleared\n      });\n    }\n  }\n  toSVG() {\n    const svg = this.root?.toSVG();\n    if (svg == null)\n      return;\n    const root = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n    root.setAttribute(\"width\", String(this.width));\n    root.setAttribute(\"height\", String(this.height));\n    if (svg.defs != null) {\n      const defs = document.createElementNS(\"http://www.w3.org/2000/svg\", \"defs\");\n      defs.append(...svg.defs);\n      root.append(defs);\n    }\n    root.append(...svg.elements);\n    return root.outerHTML;\n  }\n  /** Alternative to destroy() that preserves re-usable resources. */\n  strip() {\n    const { context, pixelRatio } = this.canvas;\n    context.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n    this.layersManager.clear();\n    this.setRoot(null);\n    this.isDirty = false;\n  }\n  destroy() {\n    this.strip();\n    this.canvas.destroy();\n    Object.assign(this, { canvas: void 0 });\n  }\n};\nScene.className = \"Scene\";\n\n// packages/ag-charts-community/src/util/callbackCache.ts\nvar CallbackCache = class {\n  constructor() {\n    this.cache = /* @__PURE__ */ new WeakMap();\n  }\n  call(fn, ...params) {\n    let serialisedParams;\n    let paramCache = this.cache.get(fn);\n    try {\n      serialisedParams = JSON.stringify(params);\n    } catch (e) {\n      return this.invoke(fn, params, paramCache);\n    }\n    if (paramCache == null) {\n      paramCache = /* @__PURE__ */ new Map();\n      this.cache.set(fn, paramCache);\n    }\n    if (!paramCache.has(serialisedParams)) {\n      return this.invoke(fn, params, paramCache, serialisedParams);\n    }\n    return paramCache.get(serialisedParams);\n  }\n  invoke(fn, params, paramCache, serialisedParams) {\n    try {\n      const result = fn(...params);\n      if (paramCache && serialisedParams != null) {\n        paramCache.set(serialisedParams, result);\n      }\n      return result;\n    } catch (e) {\n      Logger.warnOnce(`User callback errored, ignoring`, e);\n      return;\n    }\n  }\n  invalidateCache() {\n    this.cache = /* @__PURE__ */ new WeakMap();\n  }\n};\n\n// packages/ag-charts-community/src/chart/annotation/annotationManager.ts\nvar AnnotationManager = class extends BaseManager {\n  constructor(annotationRoot) {\n    super();\n    this.annotationRoot = annotationRoot;\n    this.mementoOriginatorKey = \"annotations\";\n    this.annotations = [];\n  }\n  createMemento() {\n    return this.annotations;\n  }\n  guardMemento(blob) {\n    return isArray(blob);\n  }\n  restoreMemento(_version, _mementoVersion, memento) {\n    this.annotations = this.cleanData(memento).map((annotation) => {\n      const annotationTheme = this.getAnnotationTypeStyles(annotation.type);\n      return mergeDefaults(annotation, annotationTheme);\n    });\n    this.listeners.dispatch(\"restore-annotations\", {\n      type: \"restore-annotations\",\n      annotations: this.annotations\n    });\n  }\n  updateData(annotations2) {\n    this.annotations = this.cleanData(annotations2 ?? []);\n  }\n  attachNode(node) {\n    this.annotationRoot.append(node);\n    return () => {\n      this.annotationRoot?.removeChild(node);\n      return this;\n    };\n  }\n  setAnnotationStyles(styles) {\n    this.styles = styles;\n  }\n  getAnnotationTypeStyles(type) {\n    return this.styles?.[type];\n  }\n  cleanData(annotations2) {\n    for (const annotation of annotations2) {\n      if (\"textAlign\" in annotation)\n        delete annotation.textAlign;\n    }\n    return annotations2;\n  }\n};\n\n// packages/ag-charts-community/src/chart/axis/axisManager.ts\nvar AxisManager = class {\n  constructor(sceneRoot) {\n    this.sceneRoot = sceneRoot;\n    this.axes = /* @__PURE__ */ new Map();\n    this.axisGridGroup = new Layer({ name: \"Axes-Grids\", zIndex: 1 /* AXIS_GRID */ });\n    this.axisGroup = new Layer({ name: \"Axes\", zIndex: 2 /* AXIS */ });\n    this.sceneRoot.appendChild(this.axisGroup);\n    this.sceneRoot.appendChild(this.axisGridGroup);\n  }\n  updateAxes(oldAxes, newAxes) {\n    for (const axis of oldAxes) {\n      if (newAxes.includes(axis))\n        continue;\n      axis.detachAxis(this.axisGroup, this.axisGridGroup);\n      axis.destroy();\n    }\n    for (const axis of newAxes) {\n      if (oldAxes?.includes(axis))\n        continue;\n      axis.attachAxis(this.axisGroup, this.axisGridGroup);\n    }\n    this.axes.clear();\n    for (const axis of newAxes) {\n      const ctx = axis.createAxisContext();\n      if (this.axes.has(ctx.direction)) {\n        this.axes.get(ctx.direction)?.push(ctx);\n      } else {\n        this.axes.set(ctx.direction, [ctx]);\n      }\n    }\n  }\n  getAxisContext(direction) {\n    return this.axes.get(direction) ?? [];\n  }\n  destroy() {\n    this.axes.clear();\n    this.sceneRoot.removeChild(this.axisGroup);\n    this.sceneRoot.removeChild(this.axisGridGroup);\n  }\n};\n\n// packages/ag-charts-community/src/chart/data/dataService.ts\nvar DataService = class extends Listeners {\n  constructor(animationManager) {\n    super();\n    this.animationManager = animationManager;\n    this.dispatchOnlyLatest = true;\n    this.dispatchThrottle = 0;\n    this.requestThrottle = 300;\n    this.isLoadingInitialData = false;\n    this.isLoadingData = false;\n    this.freshRequests = [];\n    this.requestCounter = 0;\n    this.debug = Debug.create(true, \"data-model\", \"data-source\");\n    this.throttledFetch = this.createThrottledFetch(this.requestThrottle);\n    this.throttledDispatch = this.createThrottledDispatch(this.dispatchThrottle);\n  }\n  updateCallback(dataSourceCallback) {\n    if (typeof dataSourceCallback !== \"function\")\n      return;\n    this.debug(\"DataService - updated data source callback\");\n    this.dataSourceCallback = dataSourceCallback;\n    this.isLoadingInitialData = true;\n    this.animationManager.skip();\n    this.dispatch(\"data-source-change\");\n  }\n  clearCallback() {\n    this.dataSourceCallback = void 0;\n  }\n  load(params) {\n    this.isLoadingData = true;\n    this.throttledFetch(params);\n  }\n  isLazy() {\n    return this.dataSourceCallback != null;\n  }\n  isLoading() {\n    return this.isLazy() && (this.isLoadingInitialData || this.isLoadingData);\n  }\n  createThrottledFetch(requestThrottle) {\n    return throttle((params) => this.fetch(params), requestThrottle, {\n      leading: false,\n      trailing: true\n    });\n  }\n  createThrottledDispatch(dispatchThrottle) {\n    return throttle(\n      (id, data) => {\n        this.debug(`DataService - dispatching 'data-load' | ${id}`);\n        this.dispatch(\"data-load\", { type: \"data-load\", data });\n      },\n      dispatchThrottle,\n      {\n        leading: true,\n        trailing: true\n      }\n    );\n  }\n  async fetch(params) {\n    if (!this.dataSourceCallback) {\n      throw new Error(\"DataService - [dataSource.getData] callback not initialised\");\n    }\n    const start2 = performance.now();\n    const id = this.requestCounter++;\n    this.debug(`DataService - requesting | ${id}`);\n    this.freshRequests.push(id);\n    let response;\n    try {\n      response = await this.dataSourceCallback(params);\n      this.debug(`DataService - response | ${performance.now() - start2}ms | ${id}`);\n    } catch (error) {\n      this.debug(`DataService - request failed | ${id}`);\n      Logger.errorOnce(`DataService - request failed | [${error}]`);\n    }\n    this.isLoadingInitialData = false;\n    const requestIndex = this.freshRequests.findIndex((rid) => rid === id);\n    if (requestIndex === -1 || this.dispatchOnlyLatest && requestIndex !== this.freshRequests.length - 1) {\n      this.debug(`DataService - discarding stale request | ${id}`);\n      return;\n    }\n    this.freshRequests = this.freshRequests.slice(requestIndex + 1);\n    if (this.freshRequests.length === 0) {\n      this.isLoadingData = false;\n    }\n    if (Array.isArray(response)) {\n      this.throttledDispatch(id, response);\n    } else {\n      this.dispatch(\"data-error\");\n    }\n  }\n};\n__decorateClass([\n  ActionOnSet({\n    newValue(dispatchThrottle) {\n      this.throttledDispatch = this.createThrottledDispatch(dispatchThrottle);\n    }\n  })\n], DataService.prototype, \"dispatchThrottle\", 2);\n__decorateClass([\n  ActionOnSet({\n    newValue(requestThrottle) {\n      this.throttledFetch = this.createThrottledFetch(requestThrottle);\n    }\n  })\n], DataService.prototype, \"requestThrottle\", 2);\n\n// packages/ag-charts-community/src/chart/interaction/animationBatch.ts\nvar AnimationBatch = class {\n  constructor(maxAnimationTime) {\n    this.maxAnimationTime = maxAnimationTime;\n    this.debug = Debug.create(true, \"animation\");\n    this.controllers = /* @__PURE__ */ new Map();\n    this.stoppedCbs = /* @__PURE__ */ new Set();\n    this.currentPhase = 0;\n    this.phases = new Map(PHASE_ORDER.map((p) => [p, []]));\n    this.skipAnimations = false;\n    this.animationTimeConsumed = 0;\n    /** Guard against premature animation execution. */\n    this.isReady = false;\n  }\n  get size() {\n    return this.controllers.size;\n  }\n  get consumedTimeMs() {\n    return this.animationTimeConsumed;\n  }\n  isActive() {\n    return this.controllers.size > 0;\n  }\n  getActiveControllers() {\n    return this.phases.get(PHASE_ORDER[this.currentPhase]) ?? [];\n  }\n  checkOverlappingId(id) {\n    if (id != null && this.controllers.has(id)) {\n      this.controllers.get(id).stop();\n      this.debug(`Skipping animation batch due to update of existing animation: ${id}`);\n      this.skip();\n    }\n  }\n  addAnimation(animation) {\n    if (animation.isComplete)\n      return;\n    const animationPhaseIdx = PHASE_ORDER.indexOf(animation.phase);\n    if (animationPhaseIdx < this.currentPhase) {\n      this.debug(`Skipping animation due to being for an earlier phase`, animation.id);\n      animation.stop();\n      return;\n    }\n    this.controllers.set(animation.id, animation);\n    this.phases.get(animation.phase)?.push(animation);\n  }\n  removeAnimation(animation) {\n    this.controllers.delete(animation.id);\n    const phase = this.phases.get(animation.phase);\n    const index = phase?.indexOf(animation);\n    if (index != null && index >= 0) {\n      phase?.splice(index, 1);\n    }\n  }\n  progress(deltaTime) {\n    if (!this.isReady)\n      return;\n    let unusedTime = deltaTime === 0 ? 0.01 : deltaTime;\n    const refresh = () => {\n      const phase2 = PHASE_ORDER[this.currentPhase];\n      return {\n        phaseControllers: [...this.getActiveControllers()],\n        phase: phase2,\n        phaseMeta: PHASE_METADATA[phase2]\n      };\n    };\n    let { phase, phaseControllers, phaseMeta } = refresh();\n    const arePhasesComplete = () => PHASE_ORDER[this.currentPhase] == null;\n    const progressPhase = () => {\n      ({ phase, phaseControllers, phaseMeta } = refresh());\n      while (!arePhasesComplete() && phaseControllers.length === 0) {\n        this.currentPhase++;\n        ({ phase, phaseControllers, phaseMeta } = refresh());\n        this.debug(`AnimationBatch - phase changing to ${phase}`, { unusedTime }, phaseControllers);\n      }\n    };\n    const total = this.controllers.size;\n    this.debug(`AnimationBatch - ${deltaTime}ms; phase ${phase} with ${phaseControllers?.length} of ${total}`);\n    do {\n      const phaseDeltaTime = unusedTime;\n      const skipPhase = phaseMeta.skipIfNoEarlierAnimations && this.animationTimeConsumed === 0;\n      let completeCount = 0;\n      for (const controller of phaseControllers) {\n        if (skipPhase) {\n          controller.stop();\n        } else {\n          unusedTime = Math.min(controller.update(phaseDeltaTime), unusedTime);\n        }\n        if (controller.isComplete) {\n          completeCount++;\n          this.removeAnimation(controller);\n        }\n      }\n      this.animationTimeConsumed += phaseDeltaTime - unusedTime;\n      this.debug(`AnimationBatch - updated ${phaseControllers.length} controllers; ${completeCount} completed`);\n      this.debug(`AnimationBatch - animationTimeConsumed: ${this.animationTimeConsumed}`);\n      progressPhase();\n    } while (unusedTime > 0 && !arePhasesComplete());\n    if (this.animationTimeConsumed > this.maxAnimationTime) {\n      this.debug(`Animation batch exceeded max animation time, skipping`, [...this.controllers]);\n      this.stop();\n    }\n  }\n  ready() {\n    if (this.isReady)\n      return;\n    this.isReady = true;\n    this.debug(`AnimationBatch - ready; skipped: ${this.skipAnimations}`, [...this.controllers]);\n    let skipAll = true;\n    for (const [, controller] of this.controllers) {\n      if (controller.duration > 0 && PHASE_METADATA[controller.phase].skipIfNoEarlierAnimations !== true) {\n        skipAll = false;\n        break;\n      }\n    }\n    if (!skipAll) {\n      for (const [, controller] of this.controllers) {\n        if (controller.autoplay) {\n          controller.play(true);\n        }\n      }\n    }\n  }\n  skip(skip = true) {\n    if (this.skipAnimations === false && skip === true) {\n      for (const controller of this.controllers.values()) {\n        controller.stop();\n      }\n      this.controllers.clear();\n    }\n    this.skipAnimations = skip;\n  }\n  play() {\n    for (const controller of this.controllers.values()) {\n      controller.play();\n    }\n  }\n  pause() {\n    for (const controller of this.controllers.values()) {\n      controller.pause();\n    }\n  }\n  stop() {\n    for (const controller of this.controllers.values()) {\n      try {\n        controller.stop();\n        this.removeAnimation(controller);\n      } catch (error) {\n        Logger.error(\"Error during animation stop\", error);\n      }\n    }\n    this.dispatchStopped();\n  }\n  stopByAnimationId(id) {\n    if (id != null && this.controllers.has(id)) {\n      const controller = this.controllers.get(id);\n      if (controller) {\n        controller.stop();\n        this.removeAnimation(controller);\n      }\n    }\n  }\n  stopByAnimationGroupId(id) {\n    for (const controller of this.controllers.values()) {\n      if (controller.groupId === id) {\n        this.stopByAnimationId(controller.id);\n      }\n    }\n  }\n  dispatchStopped() {\n    this.stoppedCbs.forEach((cb) => cb());\n    this.stoppedCbs.clear();\n  }\n  isSkipped() {\n    return this.skipAnimations;\n  }\n  destroy() {\n    this.stop();\n    this.controllers.clear();\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/preventableEvent.ts\nfunction buildPreventable(obj) {\n  const self = {\n    ...obj,\n    preventDefault() {\n      self.sourceEvent?.preventDefault();\n    }\n  };\n  return self;\n}\nfunction dispatchTypedEvent(listeners, event) {\n  listeners.dispatchWrapHandlers(event.type, (handler, e) => handler(e), buildPreventable(event));\n}\n\n// packages/ag-charts-community/src/chart/interaction/interactionManager.ts\nvar DRAG_INTERACTION_TYPES = [\"drag-start\", \"drag\", \"drag-end\"];\nvar POINTER_INTERACTION_TYPES = [\n  ...DRAG_INTERACTION_TYPES,\n  \"click\",\n  \"dblclick\",\n  \"contextmenu\",\n  \"hover\",\n  \"leave\",\n  \"enter\",\n  \"page-left\",\n  \"wheel\"\n];\nvar FOCUS_INTERACTION_TYPES = [\"blur\", \"focus\"];\nvar KEY_INTERACTION_TYPES = [\"keydown\", \"keyup\"];\nvar SHADOW_DOM_HANDLERS = [\"mousemove\", \"mouseup\"];\nvar WINDOW_EVENT_HANDLERS = [\"pagehide\", \"mousemove\", \"mouseup\"];\nvar EVENT_HANDLERS = [\n  \"dblclick\",\n  \"contextmenu\",\n  \"mousedown\",\n  \"mouseleave\",\n  \"mouseenter\",\n  \"touchstart\",\n  \"touchmove\",\n  \"touchend\",\n  \"touchcancel\",\n  \"wheel\",\n  \"blur\",\n  \"focus\",\n  \"keydown\",\n  \"keyup\"\n];\nfunction isPointerEvent(type) {\n  return POINTER_INTERACTION_TYPES.includes(type);\n}\nfunction isFocusEvent(type) {\n  return FOCUS_INTERACTION_TYPES.includes(type);\n}\nfunction isKeyEvent(type) {\n  return KEY_INTERACTION_TYPES.includes(type);\n}\nvar _InteractionManager = class _InteractionManager extends InteractionStateListener {\n  constructor(keyboardOptions, domManager) {\n    super();\n    this.keyboardOptions = keyboardOptions;\n    this.domManager = domManager;\n    this.debug = Debug.create(true, \"interaction\");\n    this.eventHandler = (event) => this.processEvent(event);\n    this.mouseDown = false;\n    this.touchDown = false;\n    this.clickHistory = [{ offsetX: NaN, offsetY: NaN, type: \"mousedown\" }];\n    this.dblclickHistory = [\n      { offsetX: NaN, offsetY: NaN, type: \"mousedown\" },\n      { offsetX: NaN, offsetY: NaN, type: \"mouseup\" },\n      { offsetX: NaN, offsetY: NaN, type: \"mousedown\" }\n    ];\n    this.stateQueue = 32 /* Default */ | 2 /* Animation */;\n    this.rootElement = this.domManager.getShadowDocumentRoot();\n    for (const type of EVENT_HANDLERS) {\n      if (type.startsWith(\"touch\") || type === \"wheel\") {\n        this.domManager.addEventListener(type, this.eventHandler, { passive: false });\n      } else {\n        this.domManager.addEventListener(type, this.eventHandler);\n      }\n    }\n    for (const type of WINDOW_EVENT_HANDLERS) {\n      getWindow().addEventListener(type, this.eventHandler);\n    }\n    this.containerChanged(true);\n    this.domManager.addListener(\"container-changed\", () => this.containerChanged());\n  }\n  containerChanged(force = false) {\n    const newRoot = this.domManager.getShadowDocumentRoot();\n    if (!force && newRoot === this.rootElement)\n      return;\n    for (const type of SHADOW_DOM_HANDLERS) {\n      this.rootElement?.removeEventListener(type, this.eventHandler);\n    }\n    this.rootElement = newRoot;\n    this.debug(\"[InteractionManager] Switching rootElement to:\", this.rootElement);\n    for (const type of SHADOW_DOM_HANDLERS) {\n      this.rootElement?.addEventListener(type, this.eventHandler);\n    }\n  }\n  destroy() {\n    super.destroy();\n    for (const type of WINDOW_EVENT_HANDLERS) {\n      getWindow().removeEventListener(type, this.eventHandler);\n    }\n    for (const type of SHADOW_DOM_HANDLERS) {\n      this.rootElement?.removeEventListener(type, this.eventHandler);\n    }\n    for (const type of EVENT_HANDLERS) {\n      this.domManager.removeEventListener(type, this.eventHandler);\n    }\n    this.domManager.removeStyles(\"interactionManager\");\n  }\n  pushState(state) {\n    this.stateQueue |= state;\n  }\n  popState(state) {\n    this.stateQueue &= ~state;\n  }\n  getState() {\n    return this.stateQueue & -this.stateQueue;\n  }\n  processEvent(event) {\n    this.debug(\"Received raw event\", event);\n    let types = this.decideInteractionEventTypes(event);\n    if (types != null && !Array.isArray(types)) {\n      types = [types];\n    }\n    for (const type of types ?? []) {\n      this.dispatchEvent(event, type).catch((e) => Logger.errorOnce(e));\n    }\n  }\n  async dispatchEvent(event, type) {\n    if (isPointerEvent(type)) {\n      this.dispatchPointerEvent(event, type);\n      return;\n    }\n    const { relatedElement, targetElement } = this.extractElements(event);\n    if (isFocusEvent(type)) {\n      const sourceEvent = event;\n      this.dispatchTypedEvent(this.listeners, { type, sourceEvent, relatedElement, targetElement });\n    } else if (isKeyEvent(type)) {\n      const sourceEvent = event;\n      this.dispatchTypedEvent(this.listeners, { type, sourceEvent, relatedElement, targetElement });\n    }\n  }\n  dispatchTypedEvent(listeners, event) {\n    const preventableEvent = buildPreventable(event);\n    this.debug(\"Dispatching typed event\", preventableEvent, this.getState());\n    listeners.dispatchWrapHandlers(event.type, (handler, e) => handler(e), preventableEvent);\n  }\n  extractElements(event) {\n    let relatedElement;\n    let targetElement;\n    if (\"relatedTarget\" in event && event[\"relatedTarget\"] instanceof HTMLElement) {\n      relatedElement = event[\"relatedTarget\"];\n    }\n    if (\"target\" in event && event[\"target\"] instanceof HTMLElement) {\n      targetElement = event[\"target\"];\n    }\n    return { relatedElement, targetElement };\n  }\n  dispatchPointerEvent(event, type) {\n    const coords = this.calculateCoordinates(event);\n    if (coords == null)\n      return;\n    const pointerEvent = this.buildPointerEvent({ type, event, ...coords });\n    this.debug(\"Dispatching pointer event\", pointerEvent, this.getState());\n    dispatchTypedEvent(this.listeners, pointerEvent);\n  }\n  getEventHTMLTarget(event) {\n    if (event.target instanceof HTMLElement) {\n      return event.target;\n    } else if (event.currentTarget instanceof HTMLElement) {\n      return event.currentTarget;\n    }\n    return void 0;\n  }\n  recordDown(event) {\n    if (event instanceof MouseEvent) {\n      partialAssign([\"offsetX\", \"offsetY\"], this.clickHistory[0], event);\n      partialAssign([\"offsetX\", \"offsetY\"], this.dblclickHistory[2], this.dblclickHistory[0]);\n      partialAssign([\"offsetX\", \"offsetY\"], this.dblclickHistory[0], event);\n    }\n    this.dragPreStartElement = this.getEventHTMLTarget(event);\n  }\n  recordUp(event) {\n    if (event instanceof MouseEvent) {\n      partialAssign([\"offsetX\", \"offsetY\"], this.dblclickHistory[1], event);\n    }\n    this.dragPreStartElement = void 0;\n    if (this.dragStartElement) {\n      this.dragStartElement = void 0;\n      return true;\n    }\n    return false;\n  }\n  decideInteractionEventTypes(event) {\n    const dragStart = \"drag-start\";\n    switch (event.type) {\n      case \"blur\":\n      case \"focus\":\n      case \"keydown\":\n      case \"keyup\":\n        return this.keyboardOptions.enabled ? event.type : void 0;\n      case \"dblclick\":\n        return event.type;\n      case \"contextmenu\":\n      case \"wheel\":\n        return event.type;\n      case \"mousedown\":\n        if (!this.isEventOverElement(event)) {\n          return;\n        }\n        this.mouseDown = true;\n        this.recordDown(event);\n        return;\n      case \"touchstart\":\n        if (!this.isEventOverElement(event)) {\n          return;\n        }\n        this.touchDown = true;\n        this.recordDown(event);\n        return;\n      case \"touchmove\":\n      case \"mousemove\":\n        if (!this.mouseDown && !this.touchDown && !this.isEventOverElement(event)) {\n          return;\n        }\n        if (!this.mouseDown && !this.touchDown)\n          return \"hover\";\n        if (this.dragStartElement)\n          return \"drag\";\n        this.dragStartElement = this.dragPreStartElement;\n        this.dragPreStartElement = void 0;\n        return [dragStart, \"drag\"];\n      case \"mouseup\":\n        if (!this.mouseDown && !this.isEventOverElement(event)) {\n          return;\n        }\n        this.mouseDown = false;\n        return this.recordUp(event) ? \"drag-end\" : \"click\";\n      case \"touchend\":\n        if (!this.touchDown && !this.isEventOverElement(event)) {\n          return;\n        }\n        this.touchDown = false;\n        return this.recordUp(event) ? \"drag-end\" : \"click\";\n      case \"mouseleave\":\n      case \"touchcancel\":\n        return \"leave\";\n      case \"mouseenter\":\n        return \"enter\";\n      case \"pagehide\":\n        return \"page-left\";\n    }\n  }\n  isEventOverElement(event) {\n    return this.domManager.isEventOverElement(event);\n  }\n  calculateCoordinates(event) {\n    if (event instanceof MouseEvent) {\n      return this.getMouseEventCoords(event);\n    } else if (typeof TouchEvent !== \"undefined\" && event instanceof TouchEvent) {\n      const lastTouch = event.touches[0] ?? event.changedTouches[0];\n      const { clientX, clientY, pageX, pageY } = lastTouch;\n      return { ..._InteractionManager.NULL_COORDS, clientX, clientY, pageX, pageY };\n    } else if (event instanceof PageTransitionEvent) {\n      if (event.persisted) {\n        return;\n      }\n      return _InteractionManager.NULL_COORDS;\n    }\n  }\n  getMouseEventCoords(event) {\n    const { clientX, clientY, pageX, pageY } = event;\n    let { offsetX, offsetY } = event;\n    const target = this.getEventHTMLTarget(event);\n    const { x = 0, y = 0 } = target ? this.domManager.calculateCanvasPosition(target) : {};\n    if (this.dragStartElement != null && event.target !== this.dragStartElement) {\n      const offsetDragStart = this.domManager.calculateCanvasPosition(this.dragStartElement);\n      offsetX -= offsetDragStart.x - x;\n      offsetY -= offsetDragStart.y - y;\n    } else {\n      offsetX += x;\n      offsetY += y;\n    }\n    return { clientX, clientY, pageX, pageY, offsetX, offsetY };\n  }\n  isWheelEvent(event) {\n    return event.type === \"wheel\";\n  }\n  buildPointerEvent(opts) {\n    const { type, event, clientX, clientY } = opts;\n    let { offsetX, offsetY, pageX, pageY } = opts;\n    if (!isFiniteNumber(offsetX) || !isFiniteNumber(offsetY)) {\n      const rect = this.domManager.getBoundingClientRect();\n      offsetX = clientX - rect.left;\n      offsetY = clientY - rect.top;\n    }\n    if (!isFiniteNumber(pageX) || !isFiniteNumber(pageY)) {\n      const pageRect = this.rootElement?.getBoundingClientRect();\n      pageX = clientX - (pageRect?.left ?? 0);\n      pageY = clientY - (pageRect?.top ?? 0);\n    }\n    let [deltaX, deltaY] = [NaN, NaN];\n    if (this.isWheelEvent(event)) {\n      const factor = event.deltaMode === 0 ? 0.01 : 1;\n      deltaX = event.deltaX * factor;\n      deltaY = event.deltaY * factor;\n    }\n    let pointerHistory = [];\n    if (event.type === \"click\") {\n      pointerHistory = this.clickHistory;\n    } else if (event.type === \"dblclick\") {\n      pointerHistory = this.dblclickHistory;\n    }\n    const { relatedElement, targetElement } = this.extractElements(event);\n    const button = \"button\" in event ? Number(event.button) : 0;\n    const builtEvent = {\n      type,\n      offsetX,\n      offsetY,\n      pageX,\n      pageY,\n      deltaX,\n      deltaY,\n      button,\n      pointerHistory,\n      sourceEvent: event,\n      relatedElement,\n      targetElement\n    };\n    this.debug(\"InteractionManager - builtEvent: \", builtEvent, this.getState());\n    return builtEvent;\n  }\n};\n_InteractionManager.NULL_COORDS = {\n  clientX: -Infinity,\n  clientY: -Infinity,\n  pageX: -Infinity,\n  pageY: -Infinity,\n  offsetX: -Infinity,\n  offsetY: -Infinity\n};\nvar InteractionManager = _InteractionManager;\n\n// packages/ag-charts-community/src/chart/interaction/animationManager.ts\nfunction validAnimationDuration(testee) {\n  if (testee == null)\n    return true;\n  return !isNaN(testee) && testee >= 0 && testee <= 2;\n}\nvar AnimationManager = class {\n  constructor(interactionManager, chartUpdateMutex) {\n    this.interactionManager = interactionManager;\n    this.chartUpdateMutex = chartUpdateMutex;\n    this.defaultDuration = 1e3;\n    this.batch = new AnimationBatch(this.defaultDuration * 1.5);\n    this.debug = Debug.create(true, \"animation\");\n    this.events = new EventEmitter();\n    this.rafAvailable = typeof requestAnimationFrame !== \"undefined\";\n    this.isPlaying = true;\n    this.requestId = null;\n    this.skipAnimations = true;\n    this.currentAnonymousAnimationId = 0;\n  }\n  addListener(eventName, listener) {\n    return this.events.on(eventName, listener);\n  }\n  /**\n   * Create an animation to tween a value between the `from` and `to` properties. If an animation already exists\n   * with the same `id`, immediately stop it.\n   */\n  animate(opts) {\n    const batch = this.batch;\n    try {\n      batch.checkOverlappingId(opts.id);\n    } catch (error) {\n      this.failsafeOnError(error);\n      return;\n    }\n    let { id } = opts;\n    if (id == null) {\n      id = `__${this.currentAnonymousAnimationId}`;\n      this.currentAnonymousAnimationId += 1;\n    }\n    const skip = this.isSkipped() || opts.phase === \"none\";\n    if (skip) {\n      this.debug(\"AnimationManager - skipping animation\");\n    }\n    const { delay, duration } = opts;\n    if (!validAnimationDuration(delay)) {\n      throw new Error(`Animation delay of ${delay} is unsupported (${id})`);\n    }\n    if (!validAnimationDuration(duration)) {\n      throw new Error(`Animation duration of ${duration} is unsupported (${id})`);\n    }\n    const animation = new Animation({\n      ...opts,\n      id,\n      skip,\n      autoplay: this.isPlaying ? opts.autoplay : false,\n      phase: opts.phase,\n      defaultDuration: this.defaultDuration\n    });\n    if (this.forceTimeJump(animation, this.defaultDuration)) {\n      return;\n    }\n    this.batch.addAnimation(animation);\n    return animation;\n  }\n  play() {\n    if (this.isPlaying) {\n      return;\n    }\n    this.isPlaying = true;\n    this.debug(\"AnimationManager.play()\");\n    try {\n      this.batch.play();\n    } catch (error) {\n      this.failsafeOnError(error);\n    }\n    this.requestAnimation();\n  }\n  pause() {\n    if (!this.isPlaying) {\n      return;\n    }\n    this.isPlaying = false;\n    this.cancelAnimation();\n    this.debug(\"AnimationManager.pause()\");\n    try {\n      this.batch.pause();\n    } catch (error) {\n      this.failsafeOnError(error);\n    }\n  }\n  stop() {\n    this.isPlaying = false;\n    this.cancelAnimation();\n    this.debug(\"AnimationManager.stop()\");\n    this.batch.stop();\n  }\n  stopByAnimationId(id) {\n    try {\n      this.batch.stopByAnimationId(id);\n    } catch (error) {\n      this.failsafeOnError(error);\n    }\n  }\n  stopByAnimationGroupId(id) {\n    try {\n      this.batch.stopByAnimationGroupId(id);\n    } catch (error) {\n      this.failsafeOnError(error);\n    }\n  }\n  reset() {\n    if (this.isPlaying) {\n      this.stop();\n      this.play();\n    } else {\n      this.stop();\n    }\n  }\n  skip(skip = true) {\n    this.skipAnimations = skip;\n  }\n  isSkipped() {\n    return !this.rafAvailable || this.skipAnimations || this.batch.isSkipped();\n  }\n  isActive() {\n    return this.isPlaying && this.batch.isActive();\n  }\n  skipCurrentBatch() {\n    if (this.debug.check()) {\n      this.debug(`AnimationManager - skipCurrentBatch()`, { stack: new Error().stack });\n    }\n    this.batch.skip();\n  }\n  /** Mocking point for tests to guarantee that animation updates happen. */\n  isSkippingFrames() {\n    return true;\n  }\n  /** Mocking point for tests to capture requestAnimationFrame callbacks. */\n  scheduleAnimationFrame(cb) {\n    this.requestId = getWindow().requestAnimationFrame(cb);\n  }\n  /** Mocking point for tests to skip animations to a specific point in time. */\n  forceTimeJump(_animation, _defaultDuration) {\n    return false;\n  }\n  requestAnimation() {\n    if (!this.rafAvailable)\n      return;\n    if (!this.batch.isActive() || this.requestId !== null)\n      return;\n    let prevTime;\n    const onAnimationFrame = async (time2) => {\n      const executeAnimationFrame = async () => {\n        const deltaTime = time2 - (prevTime ?? time2);\n        prevTime = time2;\n        this.debug(\"AnimationManager - onAnimationFrame()\", {\n          controllersCount: this.batch.size,\n          deltaTime\n        });\n        this.interactionManager.pushState(2 /* Animation */);\n        try {\n          this.batch.progress(deltaTime);\n        } catch (error) {\n          this.failsafeOnError(error);\n        }\n        this.events.emit(\"animation-frame\", {\n          type: \"animation-frame\",\n          deltaMs: deltaTime\n        });\n      };\n      if (this.isSkippingFrames()) {\n        await this.chartUpdateMutex.acquireImmediately(executeAnimationFrame);\n      } else {\n        await this.chartUpdateMutex.acquire(executeAnimationFrame);\n      }\n      if (this.batch.isActive()) {\n        this.scheduleAnimationFrame(onAnimationFrame);\n      } else {\n        this.batch.stop();\n        this.events.emit(\"animation-stop\", {\n          type: \"animation-stop\",\n          deltaMs: this.batch.consumedTimeMs\n        });\n      }\n    };\n    this.events.emit(\"animation-start\", {\n      type: \"animation-start\",\n      deltaMs: 0\n    });\n    this.scheduleAnimationFrame(onAnimationFrame);\n  }\n  cancelAnimation() {\n    if (this.requestId === null)\n      return;\n    cancelAnimationFrame(this.requestId);\n    this.requestId = null;\n    this.startBatch();\n  }\n  failsafeOnError(error, cancelAnimation = true) {\n    Logger.error(\"Error during animation, skipping animations\", error);\n    if (cancelAnimation) {\n      this.cancelAnimation();\n    }\n  }\n  startBatch(skipAnimations) {\n    this.debug(`AnimationManager - startBatch() with skipAnimations=${skipAnimations}.`);\n    this.reset();\n    this.batch.destroy();\n    this.batch = new AnimationBatch(this.defaultDuration * 1.5);\n    if (skipAnimations === true) {\n      this.batch.skip();\n    }\n  }\n  endBatch() {\n    if (this.batch.isActive()) {\n      this.batch.ready();\n      this.requestAnimation();\n    } else {\n      this.interactionManager.popState(2 /* Animation */);\n      if (this.batch.isSkipped()) {\n        this.batch.skip(false);\n      }\n    }\n  }\n  onBatchStop(cb) {\n    this.batch.stoppedCbs.add(cb);\n  }\n  destroy() {\n    this.stop();\n    this.events.clear();\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/chartEventManager.ts\nvar ChartEventManager = class extends BaseManager {\n  legendItemClick(series, itemId, enabled, legendItemName) {\n    const event = {\n      type: \"legend-item-click\",\n      series,\n      itemId,\n      enabled,\n      legendItemName\n    };\n    this.listeners.dispatch(\"legend-item-click\", event);\n  }\n  legendItemDoubleClick(series, itemId, enabled, numVisibleItems, legendItemName) {\n    const event = {\n      type: \"legend-item-double-click\",\n      series,\n      itemId,\n      enabled,\n      legendItemName,\n      numVisibleItems\n    };\n    this.listeners.dispatch(\"legend-item-double-click\", event);\n  }\n  axisHover(axisId, direction) {\n    const event = {\n      type: \"axis-hover\",\n      axisId,\n      direction\n    };\n    this.listeners.dispatch(\"axis-hover\", event);\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/contextMenuRegistry.ts\nvar ContextMenuRegistry = class _ContextMenuRegistry {\n  constructor(regionManager) {\n    this.defaultActions = [];\n    this.disabledActions = /* @__PURE__ */ new Set();\n    this.hiddenActions = /* @__PURE__ */ new Set();\n    this.listeners = new Listeners();\n    const { Default: Default2, ContextMenu } = InteractionState;\n    this.destroyFns = [regionManager.listenAll(\"contextmenu\", (e) => this.onContextMenu(e), Default2 | ContextMenu)];\n  }\n  destroy() {\n    this.destroyFns.forEach((d) => d());\n  }\n  onContextMenu(event) {\n    const type = _ContextMenuRegistry.toContextType(event.region);\n    if (type === \"all\") {\n      this.dispatchContext(\"all\", event, {});\n    }\n  }\n  static toContextType(region) {\n    if (region === \"legend\" || region === \"series\") {\n      return region;\n    }\n    return \"all\";\n  }\n  static check(type, event) {\n    return event.type === type;\n  }\n  static checkCallback(desiredType, type, _callback) {\n    return desiredType === type;\n  }\n  dispatchContext(type, pointerEvent, context, position) {\n    const { sourceEvent } = pointerEvent;\n    const x = position?.x ?? pointerEvent.offsetX;\n    const y = position?.y ?? pointerEvent.offsetY;\n    sourceEvent.stopPropagation();\n    this.listeners.dispatch(\"\", buildPreventable({ type, x, y, context, sourceEvent }));\n  }\n  addListener(handler) {\n    return this.listeners.addListener(\"\", handler);\n  }\n  filterActions(type) {\n    return this.defaultActions.filter((action) => {\n      return action.id && !this.hiddenActions.has(action.id) && [\"all\", type].includes(action.type);\n    });\n  }\n  registerDefaultAction(action) {\n    const didAdd = action.id != null && !this.defaultActions.some(({ id }) => id === action.id);\n    if (didAdd) {\n      this.defaultActions.push(action);\n    }\n    return () => {\n      const index = didAdd ? this.defaultActions.findIndex(({ id }) => id === action.id) : -1;\n      if (index !== -1) {\n        this.defaultActions.splice(index, 1);\n      }\n    };\n  }\n  enableAction(actionId) {\n    this.disabledActions.delete(actionId);\n  }\n  disableAction(actionId) {\n    this.disabledActions.add(actionId);\n  }\n  showAction(actionId) {\n    this.hiddenActions.add(actionId);\n  }\n  hideAction(actionId) {\n    this.hiddenActions.delete(actionId);\n  }\n  isDisabled(actionId) {\n    return this.disabledActions.has(actionId);\n  }\n};\n\n// packages/ag-charts-community/src/util/stateTracker.ts\nvar StateTracker = class extends Map {\n  constructor(defaultValue, defaultState) {\n    super();\n    this.defaultValue = defaultValue;\n    this.defaultState = defaultState;\n  }\n  set(key, value) {\n    this.delete(key);\n    if (typeof value !== \"undefined\") {\n      super.set(key, value);\n    }\n    return this;\n  }\n  stateId() {\n    return Array.from(this.keys()).pop() ?? this.defaultState;\n  }\n  stateValue() {\n    return Array.from(this.values()).pop() ?? this.defaultValue;\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/cursorManager.ts\nvar Cursor = /* @__PURE__ */ ((Cursor2) => {\n  Cursor2[\"Auto\"] = \"auto\";\n  Cursor2[\"Default\"] = \"default\";\n  Cursor2[\"Grab\"] = \"grab\";\n  Cursor2[\"Grabbing\"] = \"grabbing\";\n  Cursor2[\"Move\"] = \"move\";\n  Cursor2[\"NotAllowed\"] = \"not-allowed\";\n  Cursor2[\"Pointer\"] = \"pointer\";\n  Cursor2[\"EWResize\"] = \"ew-resize\";\n  Cursor2[\"NSResize\"] = \"ns-resize\";\n  Cursor2[\"ZoomIn\"] = \"zoom-in\";\n  Cursor2[\"ZoomOut\"] = \"zoom-out\";\n  return Cursor2;\n})(Cursor || {});\nvar CursorManager = class {\n  constructor(domManager) {\n    this.domManager = domManager;\n    this.stateTracker = new StateTracker(\"default\");\n  }\n  updateCursor(callerId, style) {\n    this.stateTracker.set(callerId, style);\n    this.domManager.updateCursor(this.stateTracker.stateValue());\n  }\n  getCursor() {\n    return this.domManager.getCursor();\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/gestureDetector.ts\nfunction distanceSquared(finger1, finger2) {\n  const dx = finger1.screenX - finger2.screenX;\n  const dy = finger1.screenY - finger2.screenY;\n  return dx * dx + dy * dy;\n}\nfunction distance(finger1, finger2) {\n  return Math.sqrt(distanceSquared(finger1, finger2));\n}\nvar MIN_DISTANCE_TO_START_PINCH = 1;\nvar GestureDetector = class extends BaseManager {\n  constructor(domManager) {\n    super();\n    this.domManager = domManager;\n    this.touchstart = (event) => this.onTouchStart(event);\n    this.touchmove = (event) => this.onTouchMove(event);\n    this.touchend = (event) => this.onTouchEnd(event);\n    this.touchcancel = (event) => this.onTouchCancel(event);\n    this.pinch = {\n      finger1: { identifier: NaN, screenX: NaN, screenY: NaN },\n      finger2: { identifier: NaN, screenX: NaN, screenY: NaN },\n      origin: { x: NaN, y: NaN },\n      distance: NaN,\n      status: 0 /* Off */\n    };\n    this.domManager.addEventListener(\"touchstart\", this.touchstart, { passive: true });\n    this.domManager.addEventListener(\"touchmove\", this.touchmove, { passive: false });\n    this.domManager.addEventListener(\"touchend\", this.touchend);\n    this.domManager.addEventListener(\"touchcancel\", this.touchcancel);\n  }\n  destroy() {\n    this.domManager.removeEventListener(\"touchstart\", this.touchstart);\n    this.domManager.removeEventListener(\"touchmove\", this.touchmove);\n    this.domManager.removeEventListener(\"touchend\", this.touchend);\n    this.domManager.removeEventListener(\"touchcancel\", this.touchcancel);\n  }\n  findPinchTouches(moveEvent) {\n    const { touches } = moveEvent;\n    const { finger1, finger2 } = this.pinch;\n    if (this.pinch.status !== 0 /* Off */ && touches.length === 2) {\n      if (touches[0].identifier === finger1.identifier && touches[1].identifier === finger2.identifier) {\n        return [touches[0], touches[1]];\n      }\n      if (touches[0].identifier === finger2.identifier && touches[1].identifier === finger1.identifier) {\n        return [touches[1], touches[0]];\n      }\n    }\n  }\n  copyTouchData(event) {\n    const keys = [\"identifier\", \"screenX\", \"screenY\"];\n    partialAssign(keys, this.pinch.finger1, event.touches[0]);\n    partialAssign(keys, this.pinch.finger2, event.touches[1]);\n    this.pinch.distance = distance(this.pinch.finger1, this.pinch.finger2);\n  }\n  dispatchPinchEvent(type, deltaDistance, sourceEvent) {\n    const { finger1, finger2, origin: origin3 } = this.pinch;\n    this.listeners.dispatch(type, buildPreventable({ sourceEvent, type, finger1, finger2, deltaDistance, origin: origin3 }));\n  }\n  onTouchStart(event) {\n    this.stopPinchTracking(event);\n    const { pinch } = this;\n    if (event.touches.length === 2) {\n      pinch.status = 1 /* Initialized */;\n      this.copyTouchData(event);\n      pinch.origin.x = (event.touches[0].clientX + event.touches[1].clientX) / 2;\n      pinch.origin.y = (event.touches[0].clientY + event.touches[1].clientY) / 2;\n    }\n  }\n  onTouchMove(event) {\n    const pinchTouches = this.findPinchTouches(event);\n    if (pinchTouches !== void 0) {\n      const [touch1, touch2] = pinchTouches;\n      const { pinch } = this;\n      const newDistance = distance(touch1, touch2);\n      const deltaDistance = newDistance - pinch.distance;\n      if (pinch.status === 1 /* Initialized */) {\n        if (Math.abs(deltaDistance) > MIN_DISTANCE_TO_START_PINCH) {\n          pinch.status = 2 /* Running */;\n          this.copyTouchData(event);\n          this.dispatchPinchEvent(\"pinch-start\", 0, event);\n        }\n      } else if (pinch.status === 2 /* Running */) {\n        pinch.distance = newDistance;\n        this.copyTouchData(event);\n        this.dispatchPinchEvent(\"pinch-move\", deltaDistance, event);\n      } else {\n        Logger.error(`unexpected pinch.status: ${pinch.status}`);\n      }\n    }\n  }\n  onTouchEnd(event) {\n    this.stopPinchTracking(event);\n  }\n  onTouchCancel(event) {\n    this.stopPinchTracking(event);\n  }\n  stopPinchTracking(event) {\n    const { pinch } = this;\n    if (pinch.status === 2 /* Running */) {\n      this.dispatchPinchEvent(\"pinch-end\", 0, event);\n    }\n    this.pinch.status = 0 /* Off */;\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/highlightManager.ts\nvar HighlightManager = class extends BaseManager {\n  constructor() {\n    super(...arguments);\n    this.highlightStates = new StateTracker();\n  }\n  updateHighlight(callerId, highlightedDatum) {\n    const { activeHighlight: previousHighlight } = this;\n    this.highlightStates.set(callerId, highlightedDatum);\n    this.activeHighlight = this.highlightStates.stateValue();\n    if (!this.isEqual(this.activeHighlight, previousHighlight)) {\n      this.listeners.dispatch(\"highlight-change\", {\n        type: \"highlight-change\",\n        currentHighlight: this.activeHighlight,\n        previousHighlight,\n        callerId\n      });\n    }\n  }\n  getActiveHighlight() {\n    return this.activeHighlight;\n  }\n  isEqual(a, b) {\n    return a === b || a != null && b != null && a?.series === b?.series && a?.itemId === b?.itemId && a?.datum === b?.datum;\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/keyNavManager.ts\nvar KeyNavManager = class extends InteractionStateListener {\n  constructor(focusIndicator, interactionManager, mode) {\n    super();\n    this.focusIndicator = focusIndicator;\n    this.interactionManager = interactionManager;\n    // This is the \"second last\" input event. It can be useful for keydown\n    // events that for which don't to set the isFocusVisible state\n    // (e.g. Backspace/Delete key on FC annotations, see AG-13041).\n    //\n    // Use with caution! The focus indicator must ALWAYS be visible for\n    // keyboard-only users.\n    this.previousInputDevice = \"keyboard\";\n    const mouseStates = 32 /* Default */ | 8 /* Annotations */ | 1 /* AnnotationsSelected */;\n    this.destroyFns.push(\n      interactionManager.addListener(\"click\", () => this.onClick(), mouseStates),\n      interactionManager.addListener(\"hover\", () => this.onMouse(), mouseStates),\n      interactionManager.addListener(\"drag-start\", () => this.onMouse(), mouseStates),\n      interactionManager.addListener(\"blur\", (e) => this.onBlur(e), 63 /* All */),\n      interactionManager.addListener(\"focus\", (e) => this.onFocus(e), 63 /* All */),\n      interactionManager.addListener(\"keydown\", (e) => this.onKeyDown(e), 63 /* All */)\n    );\n    this.focusIndicator.overrideFocusVisible(mode === \"integrated\" ? false : void 0);\n  }\n  getState() {\n    return this.interactionManager.getState();\n  }\n  destroy() {\n    super.destroy();\n  }\n  onClick() {\n    this.focusIndicator.overrideFocusVisible(false);\n    this.previousInputDevice = \"mouse\";\n  }\n  onMouse() {\n    this.previousInputDevice = \"mouse\";\n  }\n  onBlur(event) {\n    this.focusIndicator.overrideFocusVisible(void 0);\n    this.dispatch(\"blur\", 0, event);\n  }\n  onFocus(event) {\n    this.dispatch(\"focus\", 0, event);\n  }\n  onKeyDown(event) {\n    const state = this.getState();\n    const { key, code, altKey, shiftKey, metaKey, ctrlKey } = event.sourceEvent;\n    if (ctrlKey || metaKey) {\n      if (key === \"y\" || key === \"z\" && shiftKey) {\n        this.focusIndicator.overrideFocusVisible(this.previousInputDevice === \"keyboard\");\n        return this.dispatch(\"redo\", 0, event);\n      } else if (key === \"z\") {\n        this.focusIndicator.overrideFocusVisible(this.previousInputDevice === \"keyboard\");\n        return this.dispatch(\"undo\", 0, event);\n      }\n    }\n    if (state & (8 /* Annotations */ | 1 /* AnnotationsSelected */)) {\n      this.focusIndicator.overrideFocusVisible(false);\n      return;\n    }\n    switch (key) {\n      case \"+\":\n        return this.dispatch(\"nav-zoom\", 1, event);\n      case \"-\":\n        return this.dispatch(\"nav-zoom\", -1, event);\n    }\n    if (altKey || shiftKey || metaKey || ctrlKey)\n      return;\n    this.focusIndicator.overrideFocusVisible(true);\n    switch (code) {\n      case \"ArrowDown\":\n        return this.dispatch(\"nav-vert\", 1, event);\n      case \"ArrowUp\":\n        return this.dispatch(\"nav-vert\", -1, event);\n      case \"ArrowLeft\":\n        return this.dispatch(\"nav-hori\", -1, event);\n      case \"ArrowRight\":\n        return this.dispatch(\"nav-hori\", 1, event);\n      case \"ZoomIn\":\n      case \"Add\":\n        return this.dispatch(\"nav-zoom\", 1, event);\n      case \"ZoomOut\":\n      case \"Substract\":\n        return this.dispatch(\"nav-zoom\", -1, event);\n      case \"Space\":\n      case \"Enter\":\n        return this.dispatch(\"submit\", 0, event);\n    }\n  }\n  dispatch(type, delta4, sourceEvent) {\n    const { previousInputDevice } = this;\n    dispatchTypedEvent(this.listeners, { type, delta: delta4, sourceEvent, previousInputDevice });\n    const sharedKbmTypes = [\"redo\", \"undo\", \"nav-zoom\"];\n    if (sourceEvent.type === \"keydown\" && !sharedKbmTypes.includes(type)) {\n      this.previousInputDevice = \"keyboard\";\n    }\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/regions.ts\nvar REGIONS = /* @__PURE__ */ ((REGIONS2) => {\n  REGIONS2[\"NAVIGATOR\"] = \"navigator\";\n  REGIONS2[\"ROOT\"] = \"root\";\n  REGIONS2[\"SERIES\"] = \"series\";\n  REGIONS2[\"HORIZONTAL_AXES\"] = \"horizontal-axes\";\n  REGIONS2[\"VERTICAL_AXES\"] = \"vertical-axes\";\n  return REGIONS2;\n})(REGIONS || {});\nvar NodeRegionBBoxProvider = class {\n  constructor(node, overrideId) {\n    this.node = node;\n    this.overrideId = overrideId;\n  }\n  get id() {\n    return this.overrideId ?? this.node.id;\n  }\n  get visible() {\n    return this.node.visible;\n  }\n  toCanvasBBox() {\n    return Transformable.toCanvas(this.node);\n  }\n  fromCanvasPoint(x, y) {\n    return Transformable.fromCanvasPoint(this.node, x, y);\n  }\n};\nvar SimpleRegionBBoxProvider = class extends NodeRegionBBoxProvider {\n  constructor(node, bboxFn, overrideId) {\n    super(node, overrideId);\n    this.bboxFn = bboxFn;\n  }\n  toCanvasBBox() {\n    return this.bboxFn();\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/regionManager.ts\nvar RegionListeners = class extends Listeners {\n};\nfunction addHandler(listeners, interactionManager, type, handler, triggeringStates = 32 /* Default */) {\n  return listeners?.addListener(type, (e) => {\n    const currentState = interactionManager.getState();\n    if (currentState & triggeringStates) {\n      handler(e);\n    }\n  }) ?? (() => {\n  });\n}\nfunction nodeToBBoxProvider(node) {\n  if (node instanceof Node) {\n    return new NodeRegionBBoxProvider(node);\n  }\n  if (node instanceof NodeRegionBBoxProvider) {\n    return node;\n  }\n  return new NodeRegionBBoxProvider(node.node, node.id);\n}\nfunction getTooltipContainer(target) {\n  if (target == null || !(target instanceof HTMLElement))\n    return void 0;\n  let current = target;\n  while (current != null && !current?.classList.contains(\"ag-charts-wrapper\")) {\n    if (current.classList.contains(\"ag-chart-tooltip\")) {\n      return current;\n    }\n    current = current.parentElement;\n  }\n  return void 0;\n}\nfunction shouldIgnore(event) {\n  const { type, sourceEvent } = event;\n  const { id, className, classList, ariaHidden } = sourceEvent?.target ?? {};\n  if (!(classList instanceof DOMTokenList))\n    return \"leave\";\n  const dragTypes = DRAG_INTERACTION_TYPES;\n  if (\n    // Handle drag event on the axis 'add horizontal line annotation' button as canvas events.\n    classList.contains(\"ag-charts-annotations__axis-button-icon\") && !dragTypes.includes(type) || className === \"ag-charts-series-area\" || className === \"ag-charts-canvas-proxy\" || className === \"ag-charts-proxy-elem\" && !id?.toString().startsWith(\"ag-charts-legend-item-\") || // legend <buttons>\n    sourceEvent?.target instanceof HTMLCanvasElement\n  ) {\n    return \"none\";\n  }\n  if (getTooltipContainer(sourceEvent.target) && ariaHidden !== \"true\") {\n    return \"wait\";\n  }\n  return \"leave\";\n}\nvar RegionManager = class {\n  constructor(interactionManager) {\n    this.interactionManager = interactionManager;\n    this.debug = Debug.create(true, \"region\");\n    this.isDragging = false;\n    this.leftCanvas = false;\n    this.regions = /* @__PURE__ */ new Map();\n    this.destroyFns = [];\n    this.allRegionsListeners = new RegionListeners();\n    this.destroyFns.push(\n      ...POINTER_INTERACTION_TYPES.map(\n        (eventName) => interactionManager.addListener(eventName, this.processPointerEvent.bind(this), 63 /* All */)\n      )\n    );\n  }\n  destroy() {\n    this.destroyFns.forEach((fn) => fn());\n    this.current = void 0;\n    for (const region of this.regions.values()) {\n      region.listeners.destroy();\n    }\n    this.regions.clear();\n  }\n  addRegion(name, ...nodes) {\n    if (this.regions.has(name)) {\n      throw new Error(`AG Charts - Region: ${name} already exists`);\n    }\n    const region = {\n      properties: { name, bboxproviders: nodes.map(nodeToBBoxProvider) },\n      listeners: new RegionListeners()\n    };\n    this.regions.set(name, region);\n    return this.makeObserver(region);\n  }\n  updateRegion(name, ...nodes) {\n    const region = this.regions.get(name);\n    if (region) {\n      region.properties.bboxproviders = nodes.map(nodeToBBoxProvider);\n    } else {\n      throw new Error(\"AG Charts - unknown region: \" + name);\n    }\n  }\n  getRegion(name) {\n    return this.makeObserver(this.regions.get(name));\n  }\n  listenAll(type, handler, triggeringStates = 32 /* Default */) {\n    return addHandler(this.allRegionsListeners, this.interactionManager, type, handler, triggeringStates);\n  }\n  // This method return a wrapper object that matches the interface of InteractionManager.addListener.\n  // The intent is to allow the InteractionManager and RegionManager to be used almost interchangeably.\n  makeObserver(region) {\n    const { interactionManager } = this;\n    class ObservableRegionImplementation {\n      addListener(type, handler, triggeringStates = 32 /* Default */) {\n        return addHandler(region?.listeners, interactionManager, type, handler, triggeringStates);\n      }\n    }\n    return new ObservableRegionImplementation();\n  }\n  checkPointerHistory(targetRegion, event) {\n    for (const historyEvent of event.pointerHistory) {\n      const { region: historyRegion } = this.pickRegion(historyEvent.offsetX, historyEvent.offsetY) ?? {};\n      if (targetRegion.properties.name !== historyRegion?.properties.name) {\n        return false;\n      }\n    }\n    return true;\n  }\n  // Create and dispatch a copy of the InteractionEvent.\n  dispatch(current, partialEvent) {\n    if (current == null)\n      return;\n    const mainBBoxProvider = current.region.properties.bboxproviders[0];\n    let regionOffsetX = 0;\n    let regionOffsetY = 0;\n    if (\"offsetX\" in partialEvent && \"offsetY\" in partialEvent) {\n      ({ x: regionOffsetX, y: regionOffsetY } = mainBBoxProvider.fromCanvasPoint(\n        partialEvent.offsetX,\n        partialEvent.offsetY\n      ));\n    } else {\n      const regionBBox = mainBBoxProvider.toCanvasBBox();\n      regionOffsetX = regionBBox.width / 2;\n      regionOffsetY = regionBBox.height / 2;\n    }\n    const event = buildPreventable({\n      ...partialEvent,\n      region: current.region.properties.name,\n      bboxProviderId: current.bboxProvider?.id,\n      regionOffsetX,\n      regionOffsetY\n    });\n    this.debug(\"Dispatching region event: \", event);\n    this.allRegionsListeners.dispatch(event.type, event);\n    current.region.listeners.dispatch(event.type, event);\n  }\n  // Process events during a drag action. Returns false if this event should follow the standard\n  // RegionManager.processEvent flow, or true if this event already processed by this function.\n  handleDragging(event) {\n    const { current } = this;\n    switch (event.type) {\n      case \"drag-start\":\n        this.isDragging = true;\n        this.leftCanvas = false;\n        break;\n      case \"leave\":\n        this.leftCanvas = true;\n        return this.isDragging;\n      case \"enter\":\n        this.leftCanvas = false;\n        return this.isDragging;\n      case \"drag\":\n        if (this.isDragging) {\n          this.dispatch(current, event);\n          return true;\n        }\n        break;\n      case \"drag-end\":\n        if (this.isDragging) {\n          this.isDragging = false;\n          this.dispatch(current, event);\n          if (this.leftCanvas) {\n            this.dispatch(current, { ...event, type: \"leave\" });\n          }\n          return true;\n        }\n        break;\n    }\n    return false;\n  }\n  processPointerEvent(event) {\n    if (this.handleDragging(event)) {\n      return;\n    }\n    const { current } = this;\n    const ignore = shouldIgnore(event);\n    let newCurrent;\n    switch (ignore) {\n      case \"wait\":\n        return;\n      case \"none\":\n        newCurrent = this.pickRegion(event.offsetX, event.offsetY);\n        break;\n      case \"leave\":\n        newCurrent = void 0;\n        break;\n    }\n    const newRegion = newCurrent?.region;\n    if (current !== void 0 && newRegion?.properties.name !== current.region.properties.name) {\n      this.dispatch(current, { ...event, type: \"leave\" });\n    }\n    if (newRegion !== void 0 && newRegion.properties.name !== current?.region.properties.name) {\n      this.dispatch(newCurrent, { ...event, type: \"enter\" });\n    }\n    if (newRegion !== void 0 && this.checkPointerHistory(newRegion, event)) {\n      this.dispatch(newCurrent, event);\n    }\n    this.current = newCurrent;\n  }\n  pickRegion(x, y) {\n    let currentArea = Infinity;\n    let currentRegion;\n    let currentBBoxProvider;\n    for (const region of this.regions.values()) {\n      for (const provider of region.properties.bboxproviders) {\n        if (provider.visible === false)\n          continue;\n        const bbox = provider.toCanvasBBox();\n        const area2 = bbox.width * bbox.height;\n        if (area2 < currentArea && bbox.containsPoint(x, y)) {\n          currentArea = area2;\n          currentRegion = region;\n          currentBBoxProvider = provider;\n        }\n      }\n    }\n    return currentRegion ? { region: currentRegion, bboxProvider: currentBBoxProvider } : void 0;\n  }\n};\n\n// packages/ag-charts-community/src/chart/toolbar/toolbarTypes.ts\nvar TOOLBAR_ALIGNMENTS = [\"start\", \"center\", \"end\"];\nvar TOOLBAR_GROUPS = [\"seriesType\", \"annotations\", \"annotationOptions\", \"ranges\", \"zoom\"];\nvar TOOLBAR_GROUP_ORDERING = {\n  seriesType: 0,\n  annotations: 1,\n  annotationOptions: 2,\n  ranges: 3,\n  zoom: 4\n};\nvar ToolbarPosition = /* @__PURE__ */ ((ToolbarPosition2) => {\n  ToolbarPosition2[\"Top\"] = \"top\";\n  ToolbarPosition2[\"Left\"] = \"left\";\n  ToolbarPosition2[\"Right\"] = \"right\";\n  ToolbarPosition2[\"Bottom\"] = \"bottom\";\n  ToolbarPosition2[\"Floating\"] = \"floating\";\n  ToolbarPosition2[\"FloatingTop\"] = \"floating-top\";\n  ToolbarPosition2[\"FloatingBottom\"] = \"floating-bottom\";\n  return ToolbarPosition2;\n})(ToolbarPosition || {});\nvar TOOLBAR_POSITIONS = Object.values(ToolbarPosition);\nfunction isAnimatingFloatingPosition(position) {\n  return [\"floating-top\" /* FloatingTop */, \"floating-bottom\" /* FloatingBottom */].includes(position);\n}\n\n// packages/ag-charts-community/src/chart/interaction/toolbarManager.ts\nvar ToolbarManager = class extends BaseManager {\n  static isGroup(group, event) {\n    return event.group === group;\n  }\n  static isChildElement(domManager, element2) {\n    for (const position of TOOLBAR_POSITIONS) {\n      if (domManager.isManagedChildDOMElement(element2, \"canvas-overlay\", `toolbar-${position}`)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  pressButton(group, id, value, rect, sourceEvent) {\n    this.listeners.dispatch(\"button-pressed\", { type: \"button-pressed\", group, id, value, rect, sourceEvent });\n  }\n  cancel(group) {\n    this.listeners.dispatch(\"cancelled\", { type: \"cancelled\", group });\n  }\n  toggleButton(group, id, options) {\n    const { active = false, enabled = true, visible = true, checked = false } = options;\n    this.listeners.dispatch(\"button-toggled\", {\n      type: \"button-toggled\",\n      group,\n      id,\n      active,\n      enabled,\n      visible,\n      checked\n    });\n  }\n  updateButton(group, id, options) {\n    this.listeners.dispatch(\"button-updated\", { type: \"button-updated\", group, id, ...options });\n  }\n  toggleGroup(caller, group, options) {\n    const { active, visible } = options;\n    this.listeners.dispatch(\"group-toggled\", { type: \"group-toggled\", caller, group, active, visible });\n  }\n  updateGroup(group) {\n    this.listeners.dispatch(\"group-updated\", { type: \"group-updated\", group });\n  }\n  groupMoved(group) {\n    this.listeners.dispatch(\"group-moved\", { type: \"group-moved\", group });\n  }\n  changeFloatingAnchor(group, anchor) {\n    this.listeners.dispatch(\"floating-anchor-changed\", {\n      type: \"floating-anchor-changed\",\n      group,\n      anchor\n    });\n  }\n  buttonMoved(group, value, rect, groupRect) {\n    this.listeners.dispatch(\"button-moved\", { type: \"button-moved\", group, value, rect, groupRect });\n  }\n  proxyGroupOptions(caller, group, options) {\n    this.listeners.dispatch(\"proxy-group-options\", { type: \"proxy-group-options\", caller, group, options });\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/tooltipManager.ts\nvar TooltipManager = class {\n  constructor(domManager, tooltip) {\n    this.domManager = domManager;\n    this.tooltip = tooltip;\n    this.stateTracker = new StateTracker();\n    this.suppressState = new StateTracker(false);\n    this.appliedState = null;\n    tooltip.setup(domManager);\n    domManager.addListener(\"hidden\", () => this.tooltip.toggle(false));\n  }\n  updateTooltip(callerId, meta, content) {\n    if (!this.tooltip.enabled)\n      return;\n    content ?? (content = this.stateTracker.get(callerId)?.content);\n    this.stateTracker.set(callerId, { content, meta });\n    this.applyStates();\n  }\n  removeTooltip(callerId) {\n    if (!this.tooltip.enabled)\n      return;\n    this.stateTracker.delete(callerId);\n    this.applyStates();\n  }\n  suppressTooltip(callerId) {\n    this.suppressState.set(callerId, true);\n  }\n  unsuppressTooltip(callerId) {\n    this.suppressState.delete(callerId);\n  }\n  getTooltipMeta(callerId) {\n    return this.stateTracker.get(callerId)?.meta;\n  }\n  destroy() {\n    this.domManager.removeStyles(\"tooltip\");\n  }\n  applyStates() {\n    const id = this.stateTracker.stateId();\n    const state = id ? this.stateTracker.get(id) : null;\n    if (this.suppressState.stateValue() || state?.meta == null || state?.content == null) {\n      this.appliedState = null;\n      this.tooltip.toggle(false);\n      return;\n    }\n    const canvasRect = this.domManager.getBoundingClientRect();\n    const boundingRect = this.tooltip.bounds === \"extended\" ? this.domManager.getOverlayClientRect() : canvasRect;\n    if (this.appliedState?.content === state?.content) {\n      const renderInstantly = this.tooltip.isVisible();\n      this.tooltip.show(boundingRect, canvasRect, state?.meta, null, renderInstantly);\n    } else {\n      this.tooltip.show(boundingRect, canvasRect, state?.meta, state?.content);\n    }\n    this.appliedState = state;\n  }\n  static makeTooltipMeta(event, datum) {\n    const { offsetX, offsetY } = event;\n    const tooltip = datum.series.properties.tooltip;\n    const meta = {\n      offsetX,\n      offsetY,\n      enableInteraction: tooltip.interaction?.enabled ?? false,\n      lastPointerEvent: { type: event.type, offsetX, offsetY },\n      showArrow: tooltip.showArrow,\n      position: {\n        type: tooltip.position.type,\n        xOffset: tooltip.position.xOffset,\n        yOffset: tooltip.position.yOffset\n      }\n    };\n    const refPoint = datum.yBar?.upperPoint ?? datum.midPoint ?? datum.series.datumMidPoint?.(datum);\n    if ((tooltip.position.type === \"node\" || tooltip.position.type === \"sparkline\") && refPoint) {\n      const { x, y } = refPoint;\n      const point = Transformable.toCanvasPoint(datum.series.contentGroup, x, y);\n      return {\n        ...meta,\n        offsetX: Math.round(point.x),\n        offsetY: Math.round(point.y)\n      };\n    }\n    return meta;\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/zoomManager.ts\nvar ZoomManager = class extends BaseManager {\n  constructor() {\n    super(...arguments);\n    this.mementoOriginatorKey = \"zoom\";\n    this.axisZoomManagers = /* @__PURE__ */ new Map();\n    this.state = new StateTracker(void 0, \"initial\");\n    this.rejectCallbacks = /* @__PURE__ */ new Map();\n  }\n  addLayoutListeners(layoutManager) {\n    this.destroyFns.push(\n      layoutManager.addListener(\"layout:complete\", (event) => {\n        this.axes = event.axes;\n      })\n    );\n  }\n  createMemento() {\n    const zoom2 = this.getDefinedZoom();\n    return {\n      rangeX: this.getRangeDirection(zoom2, \"x\" /* X */),\n      rangeY: this.getRangeDirection(zoom2, \"y\" /* Y */),\n      ratioX: { start: zoom2.x.min, end: zoom2.x.max },\n      ratioY: { start: zoom2.y.min, end: zoom2.y.max }\n    };\n  }\n  guardMemento(blob) {\n    return isObject(blob) && (blob.ratioX != null || blob.ratioY != null || blob.rangeX != null || blob.rangeY != null);\n  }\n  restoreMemento(_version, _mementoVersion, memento) {\n    this.listeners.dispatch(\"restore-zoom\", { ...memento, type: \"restore-zoom\" });\n  }\n  updateAxes(axes) {\n    const zoomManagers = new Map(axes.map((axis) => [axis.id, this.axisZoomManagers.get(axis.id)]));\n    this.axisZoomManagers.clear();\n    for (const axis of axes) {\n      this.axisZoomManagers.set(axis.id, zoomManagers.get(axis.id) ?? new AxisZoomManager(axis));\n    }\n    if (this.state.size > 0 && axes.length > 0) {\n      this.updateZoom(this.state.stateId(), this.state.stateValue());\n    }\n  }\n  updateZoom(callerId, newZoom, canChangeInitial = true, rejectCallback) {\n    if (rejectCallback) {\n      this.rejectCallbacks.set(callerId, rejectCallback);\n    }\n    if (this.axisZoomManagers.size === 0) {\n      const stateId = this.state.stateId();\n      if (stateId === \"initial\" || stateId === callerId || canChangeInitial) {\n        this.state.set(callerId, newZoom);\n        if (stateId !== callerId) {\n          this.rejectCallbacks.get(stateId)?.(callerId);\n        }\n      } else {\n        rejectCallback?.(stateId);\n      }\n      return;\n    }\n    this.state.set(callerId, newZoom);\n    this.axisZoomManagers.forEach((axis) => {\n      axis.updateZoom(callerId, newZoom?.[axis.getDirection()]);\n    });\n    this.applyChanges(callerId);\n  }\n  updateAxisZoom(callerId, axisId, newZoom) {\n    this.axisZoomManagers.get(axisId)?.updateZoom(callerId, newZoom);\n    this.applyChanges(callerId);\n  }\n  // Fire this event to signal to listeners that the view is changing through a zoom and/or pan change.\n  fireZoomPanStartEvent(callerId) {\n    this.listeners.dispatch(\"zoom-pan-start\", { type: \"zoom-pan-start\", callerId });\n  }\n  getZoom() {\n    let x;\n    let y;\n    this.axisZoomManagers.forEach((axis) => {\n      if (axis.getDirection() === \"x\" /* X */) {\n        x ?? (x = axis.getZoom());\n      } else if (axis.getDirection() === \"y\" /* Y */) {\n        y ?? (y = axis.getZoom());\n      }\n    });\n    if (x || y) {\n      return { x, y };\n    }\n  }\n  getAxisZoom(axisId) {\n    return this.axisZoomManagers.get(axisId)?.getZoom() ?? { min: 0, max: 1 };\n  }\n  getAxisZooms() {\n    const axes = {};\n    for (const [axisId, axis] of this.axisZoomManagers.entries()) {\n      axes[axisId] = {\n        direction: axis.getDirection(),\n        zoom: axis.getZoom()\n      };\n    }\n    return axes;\n  }\n  applyChanges(callerId) {\n    const changed = Array.from(this.axisZoomManagers.values(), (axis) => axis.applyChanges()).some(Boolean);\n    if (!changed) {\n      return;\n    }\n    const axes = {};\n    for (const [axisId, axis] of this.axisZoomManagers.entries()) {\n      axes[axisId] = axis.getZoom();\n    }\n    this.listeners.dispatch(\"zoom-change\", { type: \"zoom-change\", ...this.getZoom(), axes, callerId });\n  }\n  getRangeDirection(zoom2, direction) {\n    for (const axis of this.axes ?? []) {\n      if (axis.direction !== direction)\n        continue;\n      const domain = axis.scale.getDomain?.();\n      const d0 = axis.scale.convert?.(domain?.at(0));\n      const d1 = axis.scale.convert?.(domain?.at(-1));\n      if (!isFiniteNumber(d0) || !isFiniteNumber(d1))\n        return;\n      let start2;\n      let end2;\n      if (d0 <= d1) {\n        const diff2 = d1 - d0;\n        start2 = axis.scale.invert?.(0);\n        end2 = axis.scale.invert?.(d0 + diff2 * zoom2[direction].max);\n      } else {\n        const diff2 = d0 - d1;\n        start2 = axis.scale.invert?.(d0 - diff2 * zoom2[direction].min);\n        end2 = axis.scale.invert?.(0);\n      }\n      return { start: start2, end: end2 };\n    }\n  }\n  getDefinedZoom() {\n    const zoom2 = this.getZoom();\n    return {\n      x: { min: zoom2?.x?.min ?? 0, max: zoom2?.x?.max ?? 1 },\n      y: { min: zoom2?.y?.min ?? 0, max: zoom2?.y?.max ?? 1 }\n    };\n  }\n};\nvar AxisZoomManager = class {\n  constructor(axis) {\n    this.axis = axis;\n    const [min = 0, max = 1] = axis.visibleRange;\n    this.state = new StateTracker({ min, max });\n    this.currentZoom = this.state.stateValue();\n  }\n  getDirection() {\n    return this.axis.direction;\n  }\n  updateZoom(callerId, newZoom) {\n    this.state.set(callerId, newZoom);\n  }\n  getZoom() {\n    return deepClone(this.state.stateValue());\n  }\n  applyChanges() {\n    const prevZoom = this.currentZoom;\n    this.currentZoom = this.state.stateValue();\n    return prevZoom.min !== this.currentZoom.min || prevZoom.max !== this.currentZoom.max;\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/seriesStateManager.ts\nvar SeriesStateManager = class {\n  constructor() {\n    this.groups = {};\n  }\n  registerSeries({ internalId, seriesGrouping, visible, type }) {\n    var _a;\n    if (!seriesGrouping)\n      return;\n    (_a = this.groups)[type] ?? (_a[type] = {});\n    this.groups[type][internalId] = { grouping: seriesGrouping, visible };\n  }\n  updateSeries({ internalId, seriesGrouping, visible, type }) {\n    if (!seriesGrouping)\n      return;\n    const entry = this.groups[type]?.[internalId];\n    if (entry) {\n      entry.grouping = seriesGrouping;\n      entry.visible = visible;\n    }\n  }\n  deregisterSeries({ internalId, type }) {\n    if (this.groups[type]) {\n      delete this.groups[type][internalId];\n    }\n    if (this.groups[type] && Object.keys(this.groups[type]).length === 0) {\n      delete this.groups[type];\n    }\n  }\n  getVisiblePeerGroupIndex({ type, seriesGrouping, visible }) {\n    if (!seriesGrouping)\n      return { visibleGroupCount: visible ? 1 : 0, visibleSameStackCount: visible ? 1 : 0, index: 0 };\n    const visibleGroupsSet = /* @__PURE__ */ new Set();\n    const visibleSameStackSet = /* @__PURE__ */ new Set();\n    for (const entry of Object.values(this.groups[type] ?? {})) {\n      if (!entry.visible)\n        continue;\n      visibleGroupsSet.add(entry.grouping.groupIndex);\n      if (entry.grouping.groupIndex === seriesGrouping.groupIndex) {\n        visibleSameStackSet.add(entry.grouping.stackIndex);\n      }\n    }\n    const visibleGroups = Array.from(visibleGroupsSet);\n    visibleGroups.sort((a, b) => a - b);\n    return {\n      visibleGroupCount: visibleGroups.length,\n      visibleSameStackCount: visibleSameStackSet.size,\n      index: visibleGroups.indexOf(seriesGrouping.groupIndex)\n    };\n  }\n};\n\n// packages/ag-charts-community/src/chart/chartUpdateType.ts\nvar ChartUpdateType = /* @__PURE__ */ ((ChartUpdateType2) => {\n  ChartUpdateType2[ChartUpdateType2[\"FULL\"] = 0] = \"FULL\";\n  ChartUpdateType2[ChartUpdateType2[\"UPDATE_DATA\"] = 1] = \"UPDATE_DATA\";\n  ChartUpdateType2[ChartUpdateType2[\"PROCESS_DATA\"] = 2] = \"PROCESS_DATA\";\n  ChartUpdateType2[ChartUpdateType2[\"PERFORM_LAYOUT\"] = 3] = \"PERFORM_LAYOUT\";\n  ChartUpdateType2[ChartUpdateType2[\"SERIES_UPDATE\"] = 4] = \"SERIES_UPDATE\";\n  ChartUpdateType2[ChartUpdateType2[\"PRE_SCENE_RENDER\"] = 5] = \"PRE_SCENE_RENDER\";\n  ChartUpdateType2[ChartUpdateType2[\"SCENE_RENDER\"] = 6] = \"SCENE_RENDER\";\n  ChartUpdateType2[ChartUpdateType2[\"NONE\"] = 7] = \"NONE\";\n  return ChartUpdateType2;\n})(ChartUpdateType || {});\n\n// packages/ag-charts-community/src/chart/updateService.ts\nvar UpdateService = class extends Listeners {\n  constructor(updateCallback) {\n    super();\n    this.updateCallback = updateCallback;\n  }\n  update(type = 0 /* FULL */, options) {\n    this.updateCallback(type, options);\n  }\n  dispatchUpdateComplete(rects) {\n    this.dispatch(\"update-complete\", {\n      type: \"update-complete\",\n      minRect: rects?.minRect,\n      minVisibleRect: rects?.minVisibleRect\n    });\n  }\n  dispatchPreDomUpdate() {\n    this.dispatch(\"pre-dom-update\", { type: \"pre-dom-update\" });\n  }\n  dispatchPreSceneRender(rects) {\n    this.dispatch(\"pre-scene-render\", { type: \"pre-scene-render\", ...rects });\n  }\n};\n\n// packages/ag-charts-community/src/chart/chartContext.ts\nvar ChartContext = class {\n  constructor(chart, vars) {\n    this.callbackCache = new CallbackCache();\n    this.chartEventManager = new ChartEventManager();\n    this.highlightManager = new HighlightManager();\n    this.layoutManager = new LayoutManager();\n    this.localeManager = new LocaleManager();\n    this.seriesStateManager = new SeriesStateManager();\n    this.stateManager = new StateManager();\n    this.toolbarManager = new ToolbarManager();\n    this.zoomManager = new ZoomManager();\n    const { scene, root, syncManager, container, updateCallback, updateMutex, pixelRatio, styleContainer } = vars;\n    this.chartService = chart;\n    this.syncManager = syncManager;\n    this.domManager = new DOMManager(container, styleContainer);\n    const canvasElement = this.domManager.addChild(\n      \"canvas\",\n      \"scene-canvas\",\n      scene?.canvas.element\n    );\n    this.scene = scene ?? new Scene({ pixelRatio, canvasElement });\n    this.scene.setRoot(root);\n    this.axisManager = new AxisManager(root);\n    this.annotationManager = new AnnotationManager(chart.annotationRoot);\n    this.cursorManager = new CursorManager(this.domManager);\n    this.interactionManager = new InteractionManager(chart.keyboard, this.domManager);\n    this.focusIndicator = new FocusIndicator(this.domManager);\n    this.keyNavManager = new KeyNavManager(this.focusIndicator, this.interactionManager, chart.mode);\n    this.regionManager = new RegionManager(this.interactionManager);\n    this.contextMenuRegistry = new ContextMenuRegistry(this.regionManager);\n    this.gestureDetector = new GestureDetector(this.domManager);\n    this.updateService = new UpdateService(updateCallback);\n    this.proxyInteractionService = new ProxyInteractionService(this.localeManager, this.domManager);\n    this.historyManager = new HistoryManager(this.keyNavManager);\n    this.animationManager = new AnimationManager(this.interactionManager, updateMutex);\n    this.dataService = new DataService(this.animationManager);\n    this.tooltipManager = new TooltipManager(this.domManager, chart.tooltip);\n    this.zoomManager.addLayoutListeners(this.layoutManager);\n  }\n  destroy() {\n    this.animationManager.destroy();\n    this.highlightManager.destroy();\n    this.axisManager.destroy();\n    this.callbackCache.invalidateCache();\n    this.chartEventManager.destroy();\n    this.contextMenuRegistry.destroy();\n    this.domManager.destroy();\n    this.highlightManager.destroy();\n    this.interactionManager.destroy();\n    this.keyNavManager.destroy();\n    this.focusIndicator.destroy();\n    this.proxyInteractionService.destroy();\n    this.regionManager.destroy();\n    this.syncManager.destroy();\n    this.tooltipManager.destroy();\n    this.zoomManager.destroy();\n  }\n};\n\n// packages/ag-charts-community/src/chart/chartHighlight.ts\nvar ChartHighlight = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.range = \"tooltip\";\n  }\n};\n__decorateClass([\n  Validate(UNION([\"tooltip\", \"node\"], \"a range\"))\n], ChartHighlight.prototype, \"range\", 2);\n\n// packages/ag-charts-community/src/chart/data/dataDomain.ts\nvar DiscreteDomain = class _DiscreteDomain {\n  constructor() {\n    this.domain = /* @__PURE__ */ new Set();\n  }\n  static is(value) {\n    return value instanceof _DiscreteDomain;\n  }\n  extend(val) {\n    this.domain.add(val);\n  }\n  getDomain() {\n    return Array.from(this.domain);\n  }\n};\nvar ContinuousDomain = class _ContinuousDomain {\n  constructor() {\n    this.domain = [Infinity, -Infinity];\n  }\n  static is(value) {\n    return value instanceof _ContinuousDomain;\n  }\n  static extendDomain(values, domain = [Infinity, -Infinity]) {\n    for (const value of values) {\n      if (typeof value !== \"number\") {\n        continue;\n      }\n      if (domain[0] > value) {\n        domain[0] = value;\n      }\n      if (domain[1] < value) {\n        domain[1] = value;\n      }\n    }\n    return domain;\n  }\n  extend(value) {\n    if (this.domain[0] > value) {\n      this.domain[0] = value;\n    }\n    if (this.domain[1] < value) {\n      this.domain[1] = value;\n    }\n  }\n  getDomain() {\n    return [...this.domain];\n  }\n};\n\n// packages/ag-charts-community/src/chart/data/dataModel.ts\nfunction toKeyString(keys) {\n  return keys.map((key) => isObject(key) ? JSON.stringify(key) : key).join(\"-\");\n}\nfunction round2(val) {\n  const accuracy = 1e4;\n  if (Number.isInteger(val)) {\n    return val;\n  } else if (Math.abs(val) > accuracy) {\n    return Math.trunc(val);\n  }\n  return Math.round(val * accuracy) / accuracy;\n}\nfunction fixNumericExtent(extent2) {\n  if (extent2 == null) {\n    return [];\n  }\n  const [min, max] = extent2.map(Number);\n  if (min === 0 && max === 0) {\n    return [0, 1];\n  }\n  return isFiniteNumber(min) && isFiniteNumber(max) ? [min, max] : [];\n}\nfunction getMissCount(scopeProvider, missMap) {\n  return missMap?.get(scopeProvider.id) ?? 0;\n}\nvar INVALID_VALUE = Symbol(\"invalid\");\nfunction getPathComponents(path) {\n  const components = [];\n  let matchIndex = 0;\n  let matchGroup;\n  const regExp = /((?:(?:^|\\.)\\s*\\w+|\\[\\s*(?:'(?:[^']|\\\\')*'|\"(?:[^\"]|\\\\\")*\"|-?\\d+)\\s*\\])\\s*)/g;\n  while (matchGroup = regExp.exec(path)) {\n    if (matchGroup.index !== matchIndex) {\n      return;\n    }\n    matchIndex = matchGroup.index + matchGroup[0].length;\n    const match = matchGroup[1].trim();\n    if (match.startsWith(\".\")) {\n      components.push(match.slice(1).trim());\n    } else if (match.startsWith(\"[\")) {\n      const accessor = match.slice(1, -1).trim();\n      if (accessor.startsWith(`'`)) {\n        components.push(accessor.slice(1, -1).replace(/\\\\'/g, `'`));\n      } else if (accessor.startsWith(`\"`)) {\n        components.push(accessor.slice(1, -1).replace(/\\\\\"/g, `\"`));\n      } else {\n        components.push(accessor);\n      }\n    } else {\n      components.push(match);\n    }\n  }\n  if (matchIndex !== path.length)\n    return;\n  return components;\n}\nfunction createPathAccessor(components) {\n  return (datum) => {\n    let current = datum;\n    for (const component of components) {\n      current = current[component];\n    }\n    return current;\n  };\n}\nvar DataModel = class {\n  constructor(opts, mode = \"standalone\") {\n    this.opts = opts;\n    this.mode = mode;\n    this.debug = Debug.create(true, \"data-model\");\n    this.scopeCache = /* @__PURE__ */ new Map();\n    this.keys = [];\n    this.values = [];\n    this.aggregates = [];\n    this.groupProcessors = [];\n    this.propertyProcessors = [];\n    this.reducers = [];\n    this.processors = [];\n    let keys = true;\n    for (const next of opts.props) {\n      if (next.type === \"key\" && !keys) {\n        throw new Error(\"AG Charts - internal config error: keys must come before values.\");\n      }\n      if (next.type === \"value\" && keys) {\n        keys = false;\n      }\n    }\n    const verifyMatchGroupId = ({ matchGroupIds = [] }) => {\n      for (const matchGroupId of matchGroupIds) {\n        if (this.values.every((def) => def.groupId !== matchGroupId)) {\n          throw new Error(\n            `AG Charts - internal config error: matchGroupIds properties must match defined groups (${matchGroupId}).`\n          );\n        }\n      }\n    };\n    for (const def of opts.props) {\n      switch (def.type) {\n        case \"key\":\n          this.keys.push({ ...def, index: this.keys.length, missing: /* @__PURE__ */ new Map() });\n          break;\n        case \"value\":\n          if (def.property == null) {\n            throw new Error(\n              `AG Charts - internal config error: no properties specified for value definitions: ${JSON.stringify(\n                def\n              )}`\n            );\n          }\n          this.values.push({ ...def, index: this.values.length, missing: /* @__PURE__ */ new Map() });\n          break;\n        case \"aggregate\":\n          verifyMatchGroupId(def);\n          this.aggregates.push({ ...def, index: this.aggregates.length });\n          break;\n        case \"group-value-processor\":\n          verifyMatchGroupId(def);\n          this.groupProcessors.push({ ...def, index: this.groupProcessors.length });\n          break;\n        case \"property-value-processor\":\n          this.propertyProcessors.push({ ...def, index: this.propertyProcessors.length });\n          break;\n        case \"reducer\":\n          this.reducers.push({ ...def, index: this.reducers.length });\n          break;\n        case \"processor\":\n          this.processors.push({ ...def, index: this.processors.length });\n          break;\n      }\n    }\n  }\n  resolveProcessedDataDefById(scope, searchId) {\n    const def = this.scopeCache.get(scope.id)?.get(searchId);\n    if (!def) {\n      throw new Error(`AG Charts - didn't find property definition for [${searchId}, ${scope.id}]`);\n    }\n    return { index: def.index, def };\n  }\n  resolveProcessedDataIndexById(scope, searchId) {\n    return this.resolveProcessedDataDefById(scope, searchId).index;\n  }\n  resolveProcessedDataDefsByIds(scope, searchIds) {\n    return searchIds.map((searchId) => [searchId, this.resolveProcessedDataDefById(scope, searchId)]);\n  }\n  resolveProcessedDataDefsValues(defs, { keys, values }) {\n    const result = {};\n    for (const [searchId, { index, def }] of defs) {\n      const processedData = def.type === \"key\" ? keys : values;\n      result[searchId] = processedData[index];\n    }\n    return result;\n  }\n  getDomain(scope, searchId, type = \"value\", processedData) {\n    const domains = this.getDomainsByType(type, processedData);\n    return domains?.[this.resolveProcessedDataIndexById(scope, searchId)] ?? [];\n  }\n  getDomainsByType(type, processedData) {\n    switch (type) {\n      case \"key\":\n        return processedData.domain.keys;\n      case \"value\":\n        return processedData.domain.values;\n      case \"aggregate\":\n        return processedData.domain.aggValues;\n      case \"group-value-processor\":\n        return processedData.domain.groups;\n      default:\n        return null;\n    }\n  }\n  processData(data, sources) {\n    const {\n      opts: { groupByKeys, groupByFn },\n      aggregates,\n      groupProcessors,\n      reducers,\n      processors,\n      propertyProcessors\n    } = this;\n    const start2 = performance.now();\n    if (groupByKeys && this.keys.length === 0) {\n      return;\n    }\n    let processedData = this.extractData(data, sources);\n    if (groupByKeys) {\n      processedData = this.groupData(processedData);\n    } else if (groupByFn) {\n      processedData = this.groupData(processedData, groupByFn(processedData));\n    }\n    if (groupProcessors.length > 0) {\n      this.postProcessGroups(processedData);\n    }\n    if (aggregates.length > 0) {\n      this.aggregateData(processedData);\n    }\n    if (propertyProcessors.length > 0) {\n      this.postProcessProperties(processedData);\n    }\n    if (reducers.length > 0) {\n      this.reduceData(processedData);\n    }\n    if (processors.length > 0) {\n      this.postProcessData(processedData);\n    }\n    if (data.length > 0) {\n      for (const def of iterate(this.keys, this.values)) {\n        for (const [scope, missCount] of def.missing) {\n          if (missCount >= data.length) {\n            const scopeHint = scope == null ? \"\" : ` for ${scope}`;\n            Logger.warnOnce(`the key '${def.property}' was not found in any data element${scopeHint}.`);\n          }\n        }\n      }\n    }\n    const end2 = performance.now();\n    processedData.time = end2 - start2;\n    if (this.debug.check()) {\n      logProcessedData(processedData);\n    }\n    this.scopeCache.clear();\n    for (const def of iterate(this.keys, this.values, this.aggregates)) {\n      if (!def.idsMap)\n        continue;\n      for (const [scope, ids] of def.idsMap) {\n        for (const id of ids) {\n          if (!this.scopeCache.has(scope)) {\n            this.scopeCache.set(scope, /* @__PURE__ */ new Map([[id, def]]));\n          } else if (this.scopeCache.get(scope)?.has(id)) {\n            throw new Error(\"duplicate definition ids on the same scope are not allowed.\");\n          } else {\n            this.scopeCache.get(scope).set(id, def);\n          }\n        }\n      }\n    }\n    return processedData;\n  }\n  valueGroupIdxLookup({ matchGroupIds }) {\n    const result = [];\n    for (const [index, def] of this.values.entries()) {\n      if (!matchGroupIds || def.groupId && matchGroupIds.includes(def.groupId)) {\n        result.push(index);\n      }\n    }\n    return result;\n  }\n  valueIdxLookup(scopes, prop) {\n    const noScopesToMatch = scopes == null || scopes.length === 0;\n    const propId = typeof prop === \"string\" ? prop : prop.id;\n    const hasMatchingScopeId = (def) => {\n      if (def.idsMap) {\n        for (const [scope, ids] of def.idsMap) {\n          if (scopes?.includes(scope) && ids.has(propId)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    };\n    const result = this.values.findIndex((def) => {\n      const validDefScopes = def.scopes == null || noScopesToMatch && !def.scopes.length || def.scopes.some((s) => scopes?.includes(s));\n      return validDefScopes && (def.property === propId || def.id === propId || hasMatchingScopeId(def));\n    });\n    if (result === -1) {\n      throw new Error(\n        `AG Charts - configuration error, unknown property ${JSON.stringify(prop)} in scope(s) ${JSON.stringify(\n          scopes\n        )}`\n      );\n    }\n    return result;\n  }\n  extractData(data, sources) {\n    const { dataDomain, processValue, scopes, allScopesHaveSameDefs } = this.initDataDomainProcessor();\n    const sourcesById = new Map(sources?.map((s) => [s.id, s]));\n    const { keys: keyDefs, values: valueDefs } = this;\n    const resultData = new Array(data.length);\n    let resultDataIdx = 0;\n    let partialValidDataCount = 0;\n    for (const [datumIdx, datum] of data.entries()) {\n      const sourceDatums = {};\n      const validScopes = scopes.size > 0 ? new Set(scopes) : void 0;\n      const keys = new Array(keyDefs.length);\n      let keyIdx = 0;\n      let key;\n      for (const def of keyDefs) {\n        key = processValue(def, datum, key);\n        if (key === INVALID_VALUE)\n          break;\n        if (keys) {\n          keys[keyIdx++] = key;\n        }\n      }\n      if (key === INVALID_VALUE)\n        continue;\n      const values = valueDefs.length > 0 ? new Array(valueDefs.length) : void 0;\n      let value;\n      for (const [valueDefIdx, def] of valueDefs.entries()) {\n        for (const scope of def.scopes ?? scopes) {\n          const source = sourcesById.get(scope);\n          const valueDatum = source?.data[datumIdx] ?? datum;\n          value = processValue(def, valueDatum, value, scope);\n          if (value === INVALID_VALUE || !values)\n            continue;\n          if (source != null && def.includeProperty !== false) {\n            const property = def.includeProperty && def.id != null ? def.id : def.property;\n            sourceDatums[scope] ?? (sourceDatums[scope] = {});\n            sourceDatums[scope][property] = value;\n          }\n          values[valueDefIdx] = value;\n        }\n        if (value === INVALID_VALUE) {\n          if (allScopesHaveSameDefs)\n            break;\n          for (const scope of def.scopes ?? scopes) {\n            validScopes?.delete(scope);\n          }\n          if (validScopes?.size === 0)\n            break;\n        }\n      }\n      if (value === INVALID_VALUE && allScopesHaveSameDefs)\n        continue;\n      if (validScopes?.size === 0)\n        continue;\n      const result = { datum: { ...datum, ...sourceDatums }, keys, values };\n      if (!allScopesHaveSameDefs && validScopes && validScopes.size < scopes.size) {\n        partialValidDataCount++;\n        result.validScopes = new Set(validScopes);\n      }\n      resultData[resultDataIdx++] = result;\n    }\n    resultData.length = resultDataIdx;\n    const propertyDomain = (def) => {\n      const defDomain = dataDomain.get(def);\n      const result = defDomain.getDomain();\n      if (ContinuousDomain.is(defDomain) && result[0] > result[1]) {\n        return [];\n      }\n      return result;\n    };\n    return {\n      type: \"ungrouped\",\n      input: { count: data.length },\n      data: resultData,\n      domain: {\n        keys: keyDefs.map(propertyDomain),\n        values: valueDefs.map(propertyDomain)\n      },\n      defs: {\n        allScopesHaveSameDefs,\n        keys: keyDefs,\n        values: valueDefs\n      },\n      partialValidDataCount,\n      time: 0\n    };\n  }\n  groupData(data, groupingFn) {\n    const processedData = /* @__PURE__ */ new Map();\n    for (const dataEntry of data.data) {\n      const { keys, values, datum, validScopes } = dataEntry;\n      const group = groupingFn?.(dataEntry) ?? keys;\n      const groupStr = toKeyString(group);\n      if (processedData.has(groupStr)) {\n        const existingData = processedData.get(groupStr);\n        existingData.values.push(values);\n        existingData.datum.push(datum);\n        if (validScopes != null && existingData.validScopes != null) {\n          for (const scope of existingData.validScopes) {\n            if (!validScopes.has(scope)) {\n              existingData.validScopes.delete(scope);\n            }\n          }\n        }\n      } else {\n        processedData.set(groupStr, {\n          keys: group,\n          values: [values],\n          datum: [datum],\n          validScopes\n        });\n      }\n    }\n    const resultData = new Array(processedData.size);\n    const resultGroups = new Array(processedData.size);\n    let dataIndex = 0;\n    for (const { keys, values, datum, validScopes } of processedData.values()) {\n      if (validScopes?.size === 0)\n        continue;\n      resultGroups[dataIndex] = keys;\n      resultData[dataIndex++] = {\n        keys,\n        values,\n        datum,\n        validScopes\n      };\n    }\n    return {\n      ...data,\n      type: \"grouped\",\n      data: resultData,\n      domain: {\n        ...data.domain,\n        groups: resultGroups\n      }\n    };\n  }\n  aggregateData(processedData) {\n    const isUngrouped = processedData.type === \"ungrouped\";\n    processedData.domain.aggValues = [];\n    for (const [index, def] of this.aggregates.entries()) {\n      const indices = this.valueGroupIdxLookup(def);\n      const domain = [Infinity, -Infinity];\n      for (const datum of processedData.data) {\n        datum.aggValues ?? (datum.aggValues = new Array(this.aggregates.length));\n        if (datum.validScopes)\n          continue;\n        const values = isUngrouped ? [datum.values] : datum.values;\n        let groupAggValues = def.groupAggregateFunction?.() ?? [Infinity, -Infinity];\n        for (const distinctValues of values) {\n          const valuesToAgg = indices.map((valueIdx) => distinctValues[valueIdx]);\n          const valuesAgg = def.aggregateFunction(valuesToAgg, datum.keys);\n          if (valuesAgg) {\n            groupAggValues = def.groupAggregateFunction?.(valuesAgg, groupAggValues) ?? ContinuousDomain.extendDomain(valuesAgg, groupAggValues);\n          }\n        }\n        const finalValues = (def.finalFunction?.(groupAggValues) ?? groupAggValues).map((v) => round2(v));\n        datum.aggValues[index] = finalValues;\n        ContinuousDomain.extendDomain(finalValues, domain);\n      }\n      processedData.domain.aggValues.push(domain);\n    }\n  }\n  postProcessGroups(processedData) {\n    const { groupProcessors } = this;\n    const affectedIndices = /* @__PURE__ */ new Set();\n    const updatedDomains = /* @__PURE__ */ new Map();\n    const groupProcessorIndices = /* @__PURE__ */ new Map();\n    const groupProcessorInitFns = /* @__PURE__ */ new Map();\n    for (const processor of groupProcessors) {\n      const indices = this.valueGroupIdxLookup(processor);\n      groupProcessorIndices.set(processor, indices);\n      groupProcessorInitFns.set(processor, processor.adjust());\n      for (const idx of indices) {\n        const valueDef = this.values[idx];\n        const isDiscrete = valueDef.valueType === \"category\";\n        affectedIndices.add(idx);\n        updatedDomains.set(idx, isDiscrete ? new DiscreteDomain() : new ContinuousDomain());\n      }\n    }\n    const updateDomains = (values) => {\n      for (const valueIndex of affectedIndices) {\n        updatedDomains.get(valueIndex)?.extend(values[valueIndex]);\n      }\n    };\n    for (const group of processedData.data) {\n      for (const processor of groupProcessors) {\n        if (group.validScopes)\n          continue;\n        const valueIndexes = groupProcessorIndices.get(processor) ?? [];\n        const adjustFn = groupProcessorInitFns.get(processor)?.();\n        if (!adjustFn)\n          continue;\n        if (processedData.type === \"grouped\") {\n          for (const values of group.values) {\n            if (values) {\n              adjustFn(values, valueIndexes);\n            }\n          }\n        } else if (group.values) {\n          adjustFn(group.values, valueIndexes);\n        }\n      }\n      if (processedData.type === \"grouped\") {\n        for (const values of group.values) {\n          updateDomains(values);\n        }\n      } else {\n        updateDomains(group.values);\n      }\n    }\n    for (const [idx, dataDomain] of updatedDomains) {\n      processedData.domain.values[idx] = dataDomain.getDomain();\n    }\n  }\n  postProcessProperties(processedData) {\n    for (const { adjust, property, scopes } of this.propertyProcessors) {\n      adjust()(processedData, this.valueIdxLookup(scopes, property));\n    }\n  }\n  reduceData(processedData) {\n    processedData.reduced ?? (processedData.reduced = {});\n    for (const def of this.reducers) {\n      const reducer = def.reducer();\n      let accValue = def.initialValue;\n      for (const datum of processedData.data) {\n        if (!datum.validScopes || def.scopes?.some((s) => datum.validScopes?.has(s))) {\n          accValue = reducer(accValue, datum);\n        }\n      }\n      processedData.reduced[def.property] = accValue;\n    }\n  }\n  postProcessData(processedData) {\n    processedData.reduced ?? (processedData.reduced = {});\n    for (const def of this.processors) {\n      processedData.reduced[def.property] = def.calculate(processedData);\n    }\n  }\n  initDataDomainProcessor() {\n    const { keys: keyDefs, values: valueDefs } = this;\n    const scopes = /* @__PURE__ */ new Set();\n    for (const valueDef of valueDefs) {\n      if (!valueDef.scopes)\n        continue;\n      for (const scope of valueDef.scopes) {\n        scopes.add(scope);\n      }\n    }\n    const dataDomain = /* @__PURE__ */ new Map();\n    const processorFns = /* @__PURE__ */ new Map();\n    let allScopesHaveSameDefs = true;\n    const initDataDomain = () => {\n      for (const def of iterate(keyDefs, valueDefs)) {\n        if (def.valueType === \"category\") {\n          dataDomain.set(def, new DiscreteDomain());\n        } else {\n          dataDomain.set(def, new ContinuousDomain());\n          allScopesHaveSameDefs && (allScopesHaveSameDefs = (def.scopes ?? []).length === scopes.size);\n        }\n      }\n    };\n    initDataDomain();\n    const accessors = this.buildAccessors(iterate(keyDefs, valueDefs));\n    const processValue = (def, datum, previousDatum, scope) => {\n      let valueInDatum;\n      let value;\n      if (accessors.has(def.property)) {\n        try {\n          value = accessors.get(def.property)(datum);\n        } catch (error) {\n        }\n        valueInDatum = value != null;\n      } else {\n        valueInDatum = def.property in datum;\n        value = valueInDatum ? datum[def.property] : def.missingValue;\n      }\n      if (def.forceValue != null) {\n        const valueNegative = valueInDatum && isNegative(value);\n        value = valueNegative ? -1 * def.forceValue : def.forceValue;\n        valueInDatum = true;\n      }\n      const missingValueDef = \"missingValue\" in def;\n      if (!valueInDatum && !missingValueDef) {\n        const missCount = def.missing.get(scope) ?? 0;\n        def.missing.set(scope, missCount + 1);\n      }\n      if (!dataDomain.has(def)) {\n        initDataDomain();\n      }\n      if (valueInDatum && def.validation?.(value, datum) === false) {\n        if (\"invalidValue\" in def) {\n          value = def.invalidValue;\n        } else {\n          if (this.mode !== \"integrated\") {\n            Logger.warnOnce(\n              `invalid value of type [${typeof value}] for [${def.scopes} / ${def.id}] ignored:`,\n              `[${value}]`\n            );\n          }\n          return INVALID_VALUE;\n        }\n      }\n      if (def.processor) {\n        if (!processorFns.has(def)) {\n          processorFns.set(def, def.processor());\n        }\n        value = processorFns.get(def)?.(value, previousDatum === INVALID_VALUE ? void 0 : previousDatum);\n      }\n      dataDomain.get(def)?.extend(value);\n      return value;\n    };\n    return { dataDomain, processValue, initDataDomain, scopes, allScopesHaveSameDefs };\n  }\n  buildAccessors(defs) {\n    const result = /* @__PURE__ */ new Map();\n    if (this.mode === \"integrated\") {\n      return result;\n    }\n    for (const def of defs) {\n      const isPath = def.property.includes(\".\") || def.property.includes(\"[\");\n      if (!isPath)\n        continue;\n      const components = getPathComponents(def.property);\n      if (components == null) {\n        Logger.warnOnce(\"Invalid property path [%s]\", def.property);\n        continue;\n      }\n      const accessor = createPathAccessor(components);\n      result.set(def.property, accessor);\n    }\n    return result;\n  }\n};\nfunction logProcessedData(processedData) {\n  const logValues = (name, data) => {\n    if (data.length > 0) {\n      Logger.log(`DataModel.processData() - ${name}`);\n      Logger.table(data);\n    }\n  };\n  Logger.log(\"DataModel.processData() - processedData\", processedData);\n  logValues(\"Key Domains\", processedData.domain.keys);\n  logValues(\"Group Domains\", processedData.domain.groups ?? []);\n  logValues(\"Value Domains\", processedData.domain.values);\n  logValues(\"Aggregate Domains\", processedData.domain.aggValues ?? []);\n  if (processedData.type === \"grouped\") {\n    const flattenedValues = processedData.data.reduce((acc, next) => {\n      const keys = next.keys ?? [];\n      const aggValues = next.aggValues ?? [];\n      const skipKeys = next.keys.map(() => void 0);\n      const skipAggValues = aggValues?.map(() => void 0);\n      acc.push(\n        ...next.values.map((v, i) => [\n          ...i === 0 ? keys : skipKeys,\n          ...v ?? [],\n          ...i == 0 ? aggValues : skipAggValues\n        ])\n      );\n      return acc;\n    }, []);\n    logValues(\"Values\", flattenedValues);\n  } else {\n    const flattenedValues = processedData.data.reduce((acc, next) => {\n      const aggValues = next.aggValues ?? [];\n      acc.push([...next.keys, ...next.values, ...aggValues]);\n      return acc;\n    }, []);\n    logValues(\"Values\", flattenedValues);\n  }\n}\n\n// packages/ag-charts-community/src/chart/data/dataController.ts\nvar _DataController = class _DataController {\n  constructor(mode) {\n    this.mode = mode;\n    this.debug = Debug.create(true, \"data-model\");\n    this.requested = [];\n    this.status = \"setup\";\n  }\n  async request(id, data, opts) {\n    if (this.status !== \"setup\") {\n      throw new Error(`AG Charts - data request after data setup phase.`);\n    }\n    return new Promise((resolve, reject) => {\n      this.requested.push({ id, opts, data, resolve, reject });\n    });\n  }\n  execute() {\n    if (this.status !== \"setup\") {\n      throw new Error(`AG Charts - data request after data setup phase.`);\n    }\n    this.status = \"executed\";\n    this.debug(\"DataController.execute() - requested\", this.requested);\n    const valid = this.validateRequests(this.requested);\n    this.debug(\"DataController.execute() - validated\", valid);\n    const merged = this.mergeRequested(valid);\n    this.debug(\"DataController.execute() - merged\", merged);\n    if (this.debug.check()) {\n      getWindow().processedData = [];\n    }\n    const scopes = this.requested.map(({ id }) => id);\n    const needsValueExtraction = this.hasMultipleDataSources(valid);\n    for (const { opts, data, resolves, rejects, ids } of merged) {\n      try {\n        const dataModel = new DataModel(opts, this.mode);\n        const processedData = dataModel.processData(data, valid);\n        if (this.debug.check()) {\n          getWindow(\"processedData\").push(processedData);\n        }\n        if (processedData?.partialValidDataCount === 0) {\n          resolves.forEach(\n            (resolve, requestIdx) => resolve({\n              dataModel,\n              processedData: this.processScopedData(\n                ids[requestIdx],\n                processedData,\n                scopes,\n                needsValueExtraction\n              )\n            })\n          );\n        } else if (processedData) {\n          this.splitResult(dataModel, processedData, ids, resolves);\n        } else {\n          rejects.forEach((cb) => cb(new Error(`AG Charts - no processed data generated`)));\n        }\n      } catch (error) {\n        rejects.forEach((cb) => cb(error));\n      }\n    }\n  }\n  hasMultipleDataSources(validRequests) {\n    if (validRequests.length) {\n      const [{ data }, ...restRequests] = validRequests;\n      return restRequests.some((v) => data !== v.data);\n    }\n    return false;\n  }\n  processScopedData(id, processedData, ids, needsValueExtraction) {\n    const extractDatum = (datum) => {\n      if (Array.isArray(datum)) {\n        return datum.map(extractDatum);\n      }\n      const extracted = needsValueExtraction ? { ...datum, ...datum[id] } : datum;\n      for (const otherId of ids) {\n        delete extracted[otherId];\n      }\n      return extracted;\n    };\n    const extractValues = (values) => {\n      if (Array.isArray(values)) {\n        return values.map(extractValues);\n      }\n      return values?.[id] ?? values;\n    };\n    return {\n      ...processedData,\n      data: processedData.data.map((datum) => ({\n        ...datum,\n        datum: extractDatum(datum.datum),\n        values: needsValueExtraction ? datum.values?.map(extractValues) : datum.values\n      }))\n    };\n  }\n  validateRequests(requested) {\n    const valid = [];\n    for (const [index, request] of requested.entries()) {\n      if (index > 0 && request.data.length !== requested[0].data.length && request.opts.groupByData === false) {\n        request.reject(\n          new Error(\"all series[].data arrays must be of the same length and have matching keys.\")\n        );\n      } else {\n        valid.push(request);\n      }\n    }\n    return valid;\n  }\n  mergeRequested(requested) {\n    const grouped = [];\n    for (const request of requested) {\n      const match = grouped.find(_DataController.groupMatch(request));\n      if (match) {\n        match.push(request);\n      } else {\n        grouped.push([request]);\n      }\n    }\n    return grouped.map(_DataController.mergeRequests);\n  }\n  splitResult(dataModel, processedData, scopes, resolves) {\n    for (let i = 0; i < scopes.length; i++) {\n      const scope = scopes[i];\n      const resolve = resolves[i];\n      resolve({\n        dataModel,\n        processedData: {\n          ...processedData,\n          data: processedData.data.filter(({ validScopes }) => validScopes?.has(scope) ?? true)\n        }\n      });\n    }\n  }\n  static groupMatch({ data, opts }) {\n    function keys(props) {\n      return props.filter((p) => p.type === \"key\").map((p) => p.property).join(\";\");\n    }\n    return ([group]) => (opts.groupByData === false || group.data === data) && group.opts.groupByKeys === opts.groupByKeys && group.opts.groupByFn === opts.groupByFn && keys(group.opts.props) === keys(opts.props);\n  }\n  static mergeRequests(requests) {\n    return requests.reduce(\n      (result, { id, data, resolve, reject, opts: { props, ...opts } }) => {\n        result.ids.push(id);\n        result.rejects.push(reject);\n        result.resolves.push(resolve);\n        result.data ?? (result.data = data);\n        result.opts ?? (result.opts = { ...opts, props: [] });\n        for (const prop of props) {\n          const clone2 = { ...prop, scopes: [id] };\n          _DataController.createIdsMap(id, clone2);\n          const match = result.opts.props.find(\n            (existing) => existing.type === clone2.type && _DataController.deepEqual(existing, clone2)\n          );\n          if (!match) {\n            result.opts.props.push(clone2);\n            continue;\n          }\n          match.scopes ?? (match.scopes = []);\n          match.scopes.push(...clone2.scopes ?? []);\n          if ((match.type === \"key\" || match.type === \"value\") && clone2.idsMap?.size) {\n            _DataController.mergeIdsMap(clone2.idsMap, match.idsMap);\n          }\n        }\n        return result;\n      },\n      { ids: [], rejects: [], resolves: [], data: null, opts: null }\n    );\n  }\n  static mergeIdsMap(fromMap, toMap) {\n    for (const [scope, ids] of fromMap) {\n      const toMapValue = toMap.get(scope);\n      if (toMapValue != null) {\n        for (const id of ids) {\n          toMapValue.add(id);\n        }\n      } else {\n        toMap.set(scope, new Set(ids));\n      }\n    }\n  }\n  static createIdsMap(scope, prop) {\n    if (prop.id == null)\n      return;\n    prop.idsMap ?? (prop.idsMap = /* @__PURE__ */ new Map());\n    if (prop.idsMap.has(scope)) {\n      prop.idsMap.get(scope).add(prop.id);\n    } else {\n      prop.idsMap.set(scope, /* @__PURE__ */ new Set([prop.id]));\n    }\n  }\n  static deepEqual(a, b) {\n    if (a === b) {\n      return true;\n    }\n    if (a && b && typeof a == \"object\" && typeof b == \"object\") {\n      if (a.constructor !== b.constructor) {\n        return false;\n      }\n      let i, length2;\n      if (Array.isArray(a)) {\n        length2 = a.length;\n        if (length2 !== b.length) {\n          return false;\n        }\n        for (i = length2 - 1; i >= 0; i--) {\n          if (!_DataController.deepEqual(a[i], b[i])) {\n            return false;\n          }\n        }\n        return true;\n      }\n      const keys = Object.keys(a);\n      length2 = keys.length;\n      if (length2 !== Object.keys(b).length) {\n        return false;\n      }\n      for (i = length2 - 1; i >= 0; i--) {\n        const key = keys[i];\n        if (!_DataController.skipKeys.has(key) && (!Object.hasOwn(b, key) || !_DataController.deepEqual(a[key], b[key]))) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n};\n// optimized version of deep equality for `mergeRequests` which can potentially loop over 1M times\n_DataController.skipKeys = /* @__PURE__ */ new Set([\"id\", \"idsMap\", \"type\", \"scopes\"]);\nvar DataController = _DataController;\n\n// packages/ag-charts-community/src/chart/factory/axisRegistry.ts\nvar AxisRegistry = class {\n  constructor() {\n    this.axesMap = /* @__PURE__ */ new Map();\n    this.hidden = /* @__PURE__ */ new Set();\n    this.themeTemplates = /* @__PURE__ */ new Map();\n  }\n  register(axisType, module) {\n    this.axesMap.set(axisType, module.moduleFactory);\n    if (module.themeTemplate) {\n      this.setThemeTemplate(axisType, module.themeTemplate);\n    }\n    if (module.hidden) {\n      this.hidden.add(axisType);\n    }\n  }\n  create(axisType, moduleContext) {\n    const axisFactory = this.axesMap.get(axisType);\n    if (axisFactory) {\n      return axisFactory(moduleContext);\n    }\n    throw new Error(`AG Charts - unknown axis type: ${axisType}`);\n  }\n  has(axisType) {\n    return this.axesMap.has(axisType);\n  }\n  keys() {\n    return this.axesMap.keys();\n  }\n  publicKeys() {\n    return [...this.keys()].filter((k) => !this.hidden.has(k));\n  }\n  setThemeTemplate(axisType, themeTemplate) {\n    this.themeTemplates.set(axisType, themeTemplate);\n    return this;\n  }\n  getThemeTemplate(axisType) {\n    return this.themeTemplates.get(axisType);\n  }\n};\nvar axisRegistry = new AxisRegistry();\n\n// packages/ag-charts-community/src/chart/factory/expectedEnterpriseModules.ts\nvar EXPECTED_ENTERPRISE_MODULES = [\n  {\n    type: \"root\",\n    optionsKey: \"animation\",\n    chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\", \"standalone\", \"gauge\"]\n  },\n  { type: \"root\", optionsKey: \"annotations\", chartTypes: [\"cartesian\"] },\n  {\n    type: \"root\",\n    optionsKey: \"background\",\n    chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\", \"standalone\", \"gauge\"],\n    optionsInnerKey: \"image\"\n  },\n  {\n    type: \"root\",\n    optionsKey: \"foreground\",\n    chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\", \"standalone\", \"gauge\"],\n    optionsInnerKey: \"image\"\n  },\n  {\n    type: \"root\",\n    optionsKey: \"chartToolbar\",\n    chartTypes: [\"cartesian\"]\n  },\n  {\n    type: \"root\",\n    optionsKey: \"contextMenu\",\n    chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\", \"standalone\", \"gauge\"]\n  },\n  { type: \"root\", optionsKey: \"statusBar\", chartTypes: [\"cartesian\"], identifier: \"status-bar\" },\n  {\n    type: \"root\",\n    optionsKey: \"dataSource\",\n    chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\", \"standalone\", \"gauge\"]\n  },\n  { type: \"root\", optionsKey: \"sync\", chartTypes: [\"cartesian\"] },\n  { type: \"root\", optionsKey: \"zoom\", chartTypes: [\"cartesian\", \"topology\"] },\n  {\n    type: \"legend\",\n    optionsKey: \"gradientLegend\",\n    chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\", \"standalone\", \"gauge\"],\n    identifier: \"gradient\"\n  },\n  { type: \"root\", optionsKey: \"navigator\", chartTypes: [\"cartesian\"], optionsInnerKey: \"miniChart\" },\n  { type: \"axis\", optionsKey: \"axes[]\", chartTypes: [\"polar\"], identifier: \"angle-category\" },\n  { type: \"axis\", optionsKey: \"axes[]\", chartTypes: [\"polar\"], identifier: \"angle-number\" },\n  { type: \"axis\", optionsKey: \"axes[]\", chartTypes: [\"polar\"], identifier: \"radius-category\" },\n  { type: \"axis\", optionsKey: \"axes[]\", chartTypes: [\"polar\"], identifier: \"radius-number\" },\n  { type: \"axis\", optionsKey: \"axes[]\", chartTypes: [\"cartesian\"], identifier: \"ordinal-time\" },\n  { type: \"axis-option\", optionsKey: \"crosshair\", chartTypes: [\"cartesian\"] },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"box-plot\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"candlestick\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"cone-funnel\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"funnel\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"ohlc\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"bullet\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"heatmap\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"range-area\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"range-bar\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"waterfall\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"polar\"], identifier: \"nightingale\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"polar\"], identifier: \"radar-area\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"polar\"], identifier: \"radar-line\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"polar\"], identifier: \"radial-bar\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"polar\"], identifier: \"radial-column\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"hierarchy\"], identifier: \"sunburst\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"hierarchy\"], identifier: \"treemap\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"topology\"], identifier: \"map-shape\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"topology\"], identifier: \"map-line\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"topology\"], identifier: \"map-marker\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"topology\"], identifier: \"map-shape-background\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"topology\"], identifier: \"map-line-background\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"flow-proportion\"], identifier: \"chord\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"flow-proportion\"], identifier: \"sankey\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"standalone\"], identifier: \"pyramid\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"gauge\"], identifier: \"linear-gauge\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"gauge\"], identifier: \"radial-gauge\" },\n  { type: \"series-option\", optionsKey: \"errorBar\", chartTypes: [\"cartesian\"], identifier: \"error-bars\" }\n];\nfunction isEnterpriseSeriesType(type) {\n  return EXPECTED_ENTERPRISE_MODULES.some((s) => s.type === \"series\" && s.identifier === type);\n}\nfunction getEnterpriseSeriesChartTypes(type) {\n  return EXPECTED_ENTERPRISE_MODULES.find((s) => s.type === \"series\" && s.identifier === type)?.chartTypes;\n}\nfunction isEnterpriseCartesian(seriesType2) {\n  const type = getEnterpriseSeriesChartTypes(seriesType2)?.find((v) => v === \"cartesian\");\n  return type === \"cartesian\";\n}\nfunction isEnterprisePolar(seriesType2) {\n  const type = getEnterpriseSeriesChartTypes(seriesType2)?.find((v) => v === \"polar\");\n  return type === \"polar\";\n}\nfunction isEnterpriseHierarchy(seriesType2) {\n  const type = getEnterpriseSeriesChartTypes(seriesType2)?.find((v) => v === \"hierarchy\");\n  return type === \"hierarchy\";\n}\nfunction isEnterpriseTopology(seriesType2) {\n  const type = getEnterpriseSeriesChartTypes(seriesType2)?.find((v) => v === \"topology\");\n  return type === \"topology\";\n}\nfunction isEnterpriseFlowProportion(seriesType2) {\n  const type = getEnterpriseSeriesChartTypes(seriesType2)?.find((v) => v === \"flow-proportion\");\n  return type === \"flow-proportion\";\n}\nfunction isEnterpriseStandalone(seriesType2) {\n  const type = getEnterpriseSeriesChartTypes(seriesType2)?.find((v) => v === \"standalone\");\n  return type === \"standalone\";\n}\nfunction isEnterpriseGauge(seriesType2) {\n  const type = getEnterpriseSeriesChartTypes(seriesType2)?.find((v) => v === \"gauge\");\n  return type === \"gauge\";\n}\nfunction isEnterpriseModule(module) {\n  return module.packageType === \"enterprise\";\n}\nfunction verifyIfModuleExpected(module) {\n  if (!isEnterpriseModule(module)) {\n    throw new Error(\"AG Charts - internal configuration error, only enterprise modules need verification.\");\n  }\n  const stub = EXPECTED_ENTERPRISE_MODULES.find((s) => {\n    return s.type === module.type && s.optionsKey === module.optionsKey && s.identifier === module.identifier && module.chartTypes.every((t) => s.chartTypes.includes(t));\n  });\n  if (stub) {\n    stub.useCount ?? (stub.useCount = 0);\n    stub.useCount++;\n  }\n  return stub != null;\n}\nfunction getUnusedExpectedModules() {\n  return EXPECTED_ENTERPRISE_MODULES.filter(({ useCount }) => useCount == null || useCount === 0);\n}\n\n// packages/ag-charts-community/src/chart/factory/legendRegistry.ts\nvar LegendRegistry = class {\n  constructor() {\n    this.legendMap = /* @__PURE__ */ new Map();\n    this.themeTemplates = /* @__PURE__ */ new Map();\n  }\n  register(legendType, { optionsKey, moduleFactory, themeTemplate }) {\n    this.legendMap.set(legendType, { optionsKey, moduleFactory });\n    this.themeTemplates.set(optionsKey, themeTemplate);\n  }\n  create(legendType, moduleContext) {\n    const legendFactory = this.legendMap.get(legendType)?.moduleFactory;\n    if (legendFactory) {\n      return legendFactory(moduleContext);\n    }\n    throw new Error(`AG Charts - unknown legend type: ${legendType}`);\n  }\n  getThemeTemplates() {\n    return Object.fromEntries(this.themeTemplates);\n  }\n  getKeys() {\n    return Array.from(this.legendMap.entries()).reduce(\n      (result, [legendType, record]) => {\n        result[legendType] = record.optionsKey;\n        return result;\n      },\n      {}\n    );\n  }\n};\nvar legendRegistry = new LegendRegistry();\n\n// packages/ag-charts-community/src/chart/factory/chartTypes.ts\nvar ChartTypes = class extends Map {\n  get(seriesType2) {\n    return super.get(seriesType2) ?? \"unknown\";\n  }\n  isCartesian(seriesType2) {\n    return this.get(seriesType2) === \"cartesian\";\n  }\n  isPolar(seriesType2) {\n    return this.get(seriesType2) === \"polar\";\n  }\n  isHierarchy(seriesType2) {\n    return this.get(seriesType2) === \"hierarchy\";\n  }\n  isTopology(seriesType2) {\n    return this.get(seriesType2) === \"topology\";\n  }\n  isFlowProportion(seriesType2) {\n    return this.get(seriesType2) === \"flow-proportion\";\n  }\n  isStandalone(seriesType2) {\n    return this.get(seriesType2) === \"standalone\";\n  }\n  isGauge(seriesType2) {\n    return this.get(seriesType2) === \"gauge\";\n  }\n  get seriesTypes() {\n    return Array.from(this.keys());\n  }\n  get cartesianTypes() {\n    return this.seriesTypes.filter((t) => this.isCartesian(t));\n  }\n  get polarTypes() {\n    return this.seriesTypes.filter((t) => this.isPolar(t));\n  }\n  get hierarchyTypes() {\n    return this.seriesTypes.filter((t) => this.isHierarchy(t));\n  }\n  get topologyTypes() {\n    return this.seriesTypes.filter((t) => this.isTopology(t));\n  }\n  get flowProportionTypes() {\n    return this.seriesTypes.filter((t) => this.isFlowProportion(t));\n  }\n  get standaloneTypes() {\n    return this.seriesTypes.filter((t) => this.isStandalone(t));\n  }\n  get gaugeTypes() {\n    return this.seriesTypes.filter((t) => this.isGauge(t));\n  }\n};\nvar ChartDefaults = class extends Map {\n  set(chartType2, defaults) {\n    return super.set(chartType2, mergeDefaults(defaults, this.get(chartType2)));\n  }\n};\nvar chartTypes = new ChartTypes();\nvar publicChartTypes = new ChartTypes();\nvar chartDefaults = new ChartDefaults();\n\n// packages/ag-charts-community/src/chart/factory/seriesRegistry.ts\nvar SeriesRegistry = class {\n  constructor() {\n    this.seriesMap = /* @__PURE__ */ new Map();\n    this.themeTemplates = /* @__PURE__ */ new Map();\n  }\n  register(seriesType2, {\n    chartTypes: [chartType2],\n    moduleFactory,\n    tooltipDefaults,\n    defaultAxes,\n    themeTemplate,\n    paletteFactory,\n    solo,\n    stackable,\n    groupable,\n    stackedByDefault,\n    hidden\n  }) {\n    this.setThemeTemplate(seriesType2, themeTemplate);\n    this.seriesMap.set(seriesType2, {\n      moduleFactory,\n      tooltipDefaults,\n      defaultAxes,\n      paletteFactory,\n      solo,\n      stackable,\n      groupable,\n      stackedByDefault\n    });\n    chartTypes.set(seriesType2, chartType2);\n    if (!hidden) {\n      publicChartTypes.set(seriesType2, chartType2);\n    }\n  }\n  create(seriesType2, moduleContext) {\n    const seriesFactory = this.seriesMap.get(seriesType2)?.moduleFactory;\n    if (seriesFactory) {\n      return seriesFactory(moduleContext);\n    }\n    throw new Error(`AG Charts - unknown series type: ${seriesType2}`);\n  }\n  cloneDefaultAxes(seriesType2, options) {\n    const defaultAxes = this.seriesMap.get(seriesType2)?.defaultAxes;\n    if (defaultAxes == null)\n      return null;\n    const axes = typeof defaultAxes === \"function\" ? defaultAxes(options) : defaultAxes;\n    return { axes: deepClone(axes) };\n  }\n  setThemeTemplate(seriesType2, themeTemplate) {\n    const currentTemplate = this.themeTemplates.get(seriesType2);\n    this.themeTemplates.set(seriesType2, mergeDefaults(themeTemplate, currentTemplate));\n  }\n  getThemeTemplate(seriesType2) {\n    return this.themeTemplates.get(seriesType2);\n  }\n  getPaletteFactory(seriesType2) {\n    return this.seriesMap.get(seriesType2)?.paletteFactory;\n  }\n  getTooltipDefauls(seriesType2) {\n    return this.seriesMap.get(seriesType2)?.tooltipDefaults;\n  }\n  isSolo(seriesType2) {\n    return this.seriesMap.get(seriesType2)?.solo ?? false;\n  }\n  isGroupable(seriesType2) {\n    return this.seriesMap.get(seriesType2)?.groupable ?? false;\n  }\n  isStackable(seriesType2) {\n    return this.seriesMap.get(seriesType2)?.stackable ?? false;\n  }\n  isStackedByDefault(seriesType2) {\n    return this.seriesMap.get(seriesType2)?.stackedByDefault ?? false;\n  }\n};\nvar seriesRegistry = new SeriesRegistry();\n\n// packages/ag-charts-community/src/chart/interaction/syncManager.ts\nvar _SyncManager = class _SyncManager extends BaseManager {\n  constructor(chart) {\n    super();\n    this.chart = chart;\n  }\n  subscribe(groupId = _SyncManager.DEFAULT_GROUP) {\n    let syncGroup = this.get(groupId);\n    if (!syncGroup) {\n      syncGroup = /* @__PURE__ */ new Set();\n      _SyncManager.chartsGroups.set(groupId, syncGroup);\n    }\n    syncGroup.add(this.chart);\n    return this;\n  }\n  unsubscribe(groupId = _SyncManager.DEFAULT_GROUP) {\n    this.get(groupId)?.delete(this.chart);\n    return this;\n  }\n  getChart() {\n    return this.chart;\n  }\n  getGroup(groupId = _SyncManager.DEFAULT_GROUP) {\n    const syncGroup = this.get(groupId);\n    return syncGroup ? Array.from(syncGroup) : [];\n  }\n  getGroupSiblings(groupId = _SyncManager.DEFAULT_GROUP) {\n    return this.getGroup(groupId).filter((chart) => chart !== this.chart);\n  }\n  get(groupId) {\n    return _SyncManager.chartsGroups.get(groupId);\n  }\n};\n_SyncManager.chartsGroups = /* @__PURE__ */ new Map();\n_SyncManager.DEFAULT_GROUP = Symbol(\"sync-group-default\");\nvar SyncManager = _SyncManager;\n\n// packages/ag-charts-community/src/chart/keyboard.ts\nvar Keyboard = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = false;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], Keyboard.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], Keyboard.prototype, \"tabIndex\", 2);\n\n// packages/ag-charts-community/src/chart/mapping/prepareAxis.ts\nvar CartesianAxisPositions = [\"top\", \"right\", \"bottom\", \"left\"];\nfunction isAxisPosition(position) {\n  return typeof position === \"string\" && CartesianAxisPositions.includes(position);\n}\nfunction guessInvalidPositions(axes) {\n  const invalidAxes = [];\n  const usedPositions = [];\n  const guesses = [...CartesianAxisPositions];\n  for (const axis of axes) {\n    if (axis instanceof CartesianAxis) {\n      if (isAxisPosition(axis.position)) {\n        usedPositions.push(axis.position);\n      } else {\n        invalidAxes.push(axis);\n      }\n    }\n  }\n  for (const axis of invalidAxes) {\n    let nextGuess;\n    do {\n      nextGuess = guesses.pop();\n    } while (nextGuess && usedPositions.includes(nextGuess));\n    if (nextGuess == null)\n      break;\n    axis.position = nextGuess;\n  }\n}\n\n// packages/ag-charts-community/src/chart/mapping/prepareSeries.ts\nvar MATCHING_KEYS = [\"direction\", \"xKey\", \"yKey\", \"sizeKey\", \"angleKey\", \"radiusKey\", \"normalizedTo\"];\nfunction matchSeriesOptions(series, optSeries, oldOptsSeries) {\n  const generateKey = (type, i, opts) => {\n    const result = [type];\n    for (const key of MATCHING_KEYS) {\n      if (key in i && i[key] != null)\n        result.push(`${key}=${i[key]}`);\n    }\n    if (opts?.seriesGrouping) {\n      result.push(`seriesGrouping.groupId=${opts?.seriesGrouping.groupId}`);\n    }\n    return result.join(\";\");\n  };\n  const seriesMap = /* @__PURE__ */ new Map();\n  let idx = 0;\n  for (const s of series) {\n    const key = generateKey(s.type, s.properties, oldOptsSeries?.[idx]);\n    if (!seriesMap.has(key)) {\n      seriesMap.set(key, []);\n    }\n    seriesMap.get(key)?.push([s, idx++]);\n  }\n  const optsMap = /* @__PURE__ */ new Map();\n  for (const o of optSeries) {\n    const key = generateKey(o.type, o, o);\n    if (!optsMap.has(key)) {\n      optsMap.set(key, []);\n    }\n    optsMap.get(key)?.push(o);\n  }\n  const overlap = [...seriesMap.keys()].some((k) => optsMap.has(k));\n  if (!overlap) {\n    return { status: \"no-overlap\", oldKeys: seriesMap.keys(), newKeys: optsMap.keys() };\n  }\n  const changes = [];\n  let targetIdx = -1;\n  for (const [key, optArray] of optsMap.entries()) {\n    for (const opts of optArray) {\n      targetIdx++;\n      const seriesArray = seriesMap.get(key);\n      if (seriesArray == null || seriesArray.length < 1) {\n        changes.push({ opts, idx: targetIdx, status: \"add\" });\n        seriesMap.delete(key);\n        continue;\n      }\n      const [outputSeries, outputIdx] = seriesArray.shift();\n      const previousOpts = oldOptsSeries?.[outputIdx] ?? {};\n      const diff2 = jsonDiff(previousOpts, opts ?? {});\n      const { groupIndex, stackIndex } = diff2?.seriesGrouping ?? {};\n      if (groupIndex != null || stackIndex != null) {\n        changes.push({ opts, series: outputSeries, diff: diff2, idx: outputIdx, status: \"series-grouping\" });\n      } else if (diff2) {\n        changes.push({ opts, series: outputSeries, diff: diff2, idx: outputIdx, status: \"update\" });\n      } else {\n        changes.push({ opts, series: outputSeries, idx: outputIdx, status: \"no-op\" });\n      }\n      if (seriesArray.length === 0) {\n        seriesMap.delete(key);\n      }\n    }\n  }\n  for (const seriesArray of seriesMap.values()) {\n    for (const [outputSeries, outputIdx] of seriesArray) {\n      changes.push({ series: outputSeries, idx: outputIdx, status: \"remove\" });\n    }\n  }\n  return { status: \"overlap\", changes };\n}\n\n// packages/ag-charts-community/src/chart/mapping/types.ts\nfunction optionsType(input) {\n  const { series } = input;\n  if (!series)\n    return;\n  return series[0]?.type ?? \"line\";\n}\nfunction isAgCartesianChartOptions(input) {\n  const specifiedType = optionsType(input);\n  if (specifiedType == null) {\n    return false;\n  }\n  return chartTypes.isCartesian(specifiedType) || isEnterpriseCartesian(specifiedType);\n}\nfunction isAgPolarChartOptions(input) {\n  const specifiedType = optionsType(input);\n  if (specifiedType == null) {\n    return false;\n  }\n  if (specifiedType === \"polar\") {\n    Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);\n    return true;\n  }\n  return chartTypes.isPolar(specifiedType) || isEnterprisePolar(specifiedType);\n}\nfunction isAgHierarchyChartOptions(input) {\n  const specifiedType = optionsType(input);\n  if (specifiedType == null) {\n    return false;\n  }\n  if (specifiedType === \"hierarchy\") {\n    Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);\n    return true;\n  }\n  return chartTypes.isHierarchy(specifiedType) || isEnterpriseHierarchy(specifiedType);\n}\nfunction isAgTopologyChartOptions(input) {\n  const specifiedType = optionsType(input);\n  if (specifiedType == null) {\n    return false;\n  }\n  if (specifiedType === \"topology\") {\n    Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);\n    return true;\n  }\n  return chartTypes.isTopology(specifiedType) || isEnterpriseTopology(specifiedType);\n}\nfunction isAgFlowProportionChartOptions(input) {\n  const specifiedType = optionsType(input);\n  if (specifiedType == null) {\n    return false;\n  }\n  if (specifiedType === \"flow-proportion\") {\n    Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);\n    return true;\n  }\n  return chartTypes.isFlowProportion(specifiedType) || isEnterpriseFlowProportion(specifiedType);\n}\nfunction isAgStandaloneChartOptions(input) {\n  const specifiedType = optionsType(input);\n  if (specifiedType == null) {\n    return false;\n  }\n  if (specifiedType === \"standalone\") {\n    Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);\n    return true;\n  }\n  return chartTypes.isStandalone(specifiedType) || isEnterpriseStandalone(specifiedType);\n}\nfunction isAgGaugeChartOptions(input) {\n  const specifiedType = optionsType(input);\n  if (specifiedType == null) {\n    return false;\n  }\n  if (specifiedType === \"gauge\") {\n    Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);\n    return true;\n  }\n  return chartTypes.isGauge(specifiedType) || isEnterpriseGauge(specifiedType);\n}\nfunction isAgPolarChartOptionsWithSeriesBasedLegend(input) {\n  const specifiedType = optionsType(input);\n  return isAgPolarChartOptions(input) && specifiedType !== \"pie\" && specifiedType !== \"donut\";\n}\nfunction isSeriesOptionType(input) {\n  if (input == null) {\n    return false;\n  }\n  return chartTypes.has(input);\n}\nfunction isAxisOptionType(input) {\n  if (input == null) {\n    return false;\n  }\n  return axisRegistry.has(input);\n}\n\n// packages/ag-charts-community/src/chart/modulesManager.ts\nvar ModulesManager = class extends ModuleMap {\n  applyOptions(options) {\n    for (const m of this.moduleMap.values()) {\n      if (m.module.optionsKey in options && isProperties(m.moduleInstance)) {\n        m.moduleInstance.set(options[m.module.optionsKey]);\n      }\n    }\n  }\n  *legends() {\n    for (const { module, moduleInstance } of this.moduleMap.values()) {\n      if (module.type !== \"legend\")\n        continue;\n      yield {\n        legendType: module.identifier,\n        legend: moduleInstance\n      };\n    }\n  }\n};\n\n// packages/ag-charts-community/src/chart/overlay/overlay.ts\nvar DEFAULT_OVERLAY_CLASS = \"ag-chart-overlay\";\nvar DEFAULT_OVERLAY_DARK_CLASS = \"ag-chart-dark-overlay\";\nvar Overlay = class extends BaseProperties {\n  constructor(className, defaultMessageId) {\n    super();\n    this.className = className;\n    this.defaultMessageId = defaultMessageId;\n  }\n  getText(localeManager) {\n    return localeManager.t(this.text ?? this.defaultMessageId);\n  }\n  getElement(animationManager, localeManager, rect) {\n    this.content?.remove();\n    this.focusBox = rect;\n    if (this.renderer) {\n      const htmlContent = this.renderer();\n      if (htmlContent instanceof HTMLElement) {\n        this.content = htmlContent;\n      } else {\n        const tempDiv = createElement(\"div\");\n        tempDiv.innerHTML = htmlContent;\n        this.content = tempDiv.firstElementChild;\n      }\n    } else {\n      const content = createElement(\"div\", {\n        display: \"flex\",\n        alignItems: \"center\",\n        justifyContent: \"center\",\n        boxSizing: \"border-box\",\n        height: \"100%\",\n        margin: \"8px\",\n        font: \"12px Verdana, sans-serif\"\n      });\n      content.innerText = this.getText(localeManager);\n      this.content = content;\n      animationManager?.animate({\n        from: 0,\n        to: 1,\n        id: \"overlay\",\n        phase: \"add\",\n        groupId: \"opacity\",\n        onUpdate(value) {\n          content.style.opacity = String(value);\n        },\n        onStop() {\n          content.style.opacity = \"1\";\n        }\n      });\n    }\n    return this.content;\n  }\n  removeElement(cleanup = () => this.content?.remove(), animationManager) {\n    if (!this.content)\n      return;\n    if (animationManager) {\n      const { content } = this;\n      animationManager.animate({\n        from: 1,\n        to: 0,\n        phase: \"remove\",\n        id: \"overlay\",\n        groupId: \"opacity\",\n        onUpdate(value) {\n          content.style.opacity = String(value);\n        },\n        onStop() {\n          cleanup?.();\n        }\n      });\n    } else {\n      cleanup?.();\n    }\n    this.content = void 0;\n    this.focusBox = void 0;\n  }\n};\n__decorateClass([\n  Validate(STRING, { optional: true })\n], Overlay.prototype, \"text\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], Overlay.prototype, \"renderer\", 2);\n\n// packages/ag-charts-community/src/chart/overlay/chartOverlays.ts\nvar ChartOverlays = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.darkTheme = false;\n    this.loading = new Overlay(\"ag-chart-loading-overlay\", \"overlayLoadingData\");\n    this.noData = new Overlay(\"ag-chart-no-data-overlay\", \"overlayNoData\");\n    this.noVisibleSeries = new Overlay(\"ag-chart-no-visible-series\", \"overlayNoVisibleSeries\");\n  }\n  getFocusInfo(localeManager) {\n    for (const overlay of [this.loading, this.noData, this.noVisibleSeries]) {\n      if (overlay.focusBox !== void 0) {\n        return { text: overlay.getText(localeManager), rect: overlay.focusBox };\n      }\n    }\n    return void 0;\n  }\n  destroy() {\n    this.loading.removeElement();\n    this.noData.removeElement();\n    this.noVisibleSeries.removeElement();\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], ChartOverlays.prototype, \"darkTheme\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], ChartOverlays.prototype, \"loading\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], ChartOverlays.prototype, \"noData\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], ChartOverlays.prototype, \"noVisibleSeries\", 2);\n\n// packages/ag-charts-community/src/chart/overlay/loadingSpinner.ts\nfunction getLoadingSpinner(text, defaultDuration) {\n  const { animationDuration } = PHASE_METADATA[\"add\"];\n  const duration = animationDuration * defaultDuration;\n  const container = createElement(\"div\", `${DEFAULT_OVERLAY_CLASS}--loading`, {\n    display: \"flex\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    flexDirection: \"column\",\n    height: \"100%\",\n    boxSizing: \"border-box\",\n    font: \"13px Verdana, sans-serif\",\n    // FONT_SIZE.MEDIUM\n    userSelect: \"none\",\n    animation: `ag-charts-loading ${duration}ms linear 50ms both`\n  });\n  const matrix = createElement(\"span\", {\n    width: \"45px\",\n    height: \"40px\",\n    backgroundImage: [\n      \"linear-gradient(#0000 calc(1 * 100% / 6), #ccc 0 calc(3 * 100% / 6), #0000 0), \",\n      \"linear-gradient(#0000 calc(2 * 100% / 6), #ccc 0 calc(4 * 100% / 6), #0000 0), \",\n      \"linear-gradient(#0000 calc(3 * 100% / 6), #ccc 0 calc(5 * 100% / 6), #0000 0)\"\n    ].join(\"\"),\n    backgroundSize: \"10px 400%\",\n    backgroundRepeat: \"no-repeat\",\n    animation: \"ag-charts-loading-matrix 1s infinite linear\"\n  });\n  const label = createElement(\"p\", { marginTop: \"1em\" });\n  label.innerText = text;\n  const background = createElement(\"div\", `${DEFAULT_OVERLAY_CLASS}__loading-background`, {\n    position: \"absolute\",\n    inset: \"0\",\n    opacity: \"0.5\",\n    zIndex: \"-1\"\n  });\n  const animationStyles = createElement(\"style\");\n  animationStyles.innerText = [\n    \"@keyframes ag-charts-loading { from { opacity: 0 } to { opacity: 1 } }\",\n    \"@keyframes ag-charts-loading-matrix {\",\n    \"0% { background-position: 0% 0%, 50% 0%, 100% 0%; }\",\n    \"100% { background-position: 0% 100%, 50% 100%, 100% 100%; }\",\n    \"}\"\n  ].join(\" \");\n  container.replaceChildren(animationStyles, matrix, label, background);\n  return container;\n}\n\n// packages/ag-charts-community/src/chart/series/series.ts\nvar SeriesNodePickMode = /* @__PURE__ */ ((SeriesNodePickMode2) => {\n  SeriesNodePickMode2[SeriesNodePickMode2[\"EXACT_SHAPE_MATCH\"] = 0] = \"EXACT_SHAPE_MATCH\";\n  SeriesNodePickMode2[SeriesNodePickMode2[\"NEAREST_NODE\"] = 1] = \"NEAREST_NODE\";\n  SeriesNodePickMode2[SeriesNodePickMode2[\"AXIS_ALIGNED\"] = 2] = \"AXIS_ALIGNED\";\n  return SeriesNodePickMode2;\n})(SeriesNodePickMode || {});\nvar CROSS_FILTER_MARKER_FILL_OPACITY_FACTOR = 0.25;\nvar CROSS_FILTER_MARKER_STROKE_OPACITY_FACTOR = 0.125;\nvar SeriesNodeEvent = class {\n  constructor(type, event, { datum }, series) {\n    this.type = type;\n    this.event = event;\n    this.datum = datum;\n    this.seriesId = series.id;\n  }\n};\nvar SeriesGroupingChangedEvent = class {\n  constructor(series, seriesGrouping, oldGrouping) {\n    this.series = series;\n    this.seriesGrouping = seriesGrouping;\n    this.oldGrouping = oldGrouping;\n    this.type = \"groupingChanged\";\n  }\n};\nvar Series = class extends Observable {\n  constructor(seriesOpts) {\n    super();\n    this.destroyFns = [];\n    this.seriesGrouping = void 0;\n    this.NodeEvent = SeriesNodeEvent;\n    this.internalId = createId(this);\n    // The group node that contains all the nodes used to render this series.\n    this.rootGroup = new Group({ name: \"seriesRoot\", isVirtual: true });\n    this.axes = {\n      [\"x\" /* X */]: void 0,\n      [\"y\" /* Y */]: void 0\n    };\n    this.directions = [\"x\" /* X */, \"y\" /* Y */];\n    // Flag to determine if we should recalculate node data.\n    this.nodeDataRefresh = true;\n    this.moduleMap = new ModuleMap();\n    this._declarationOrder = -1;\n    this.seriesListeners = new Listeners();\n    this._pickNodeCache = new LRUCache();\n    const {\n      moduleCtx,\n      pickModes,\n      directionKeys = {},\n      directionNames = {},\n      contentGroupVirtual = true,\n      canHaveAxes = false\n    } = seriesOpts;\n    this.ctx = moduleCtx;\n    this.directionKeys = directionKeys;\n    this.directionNames = directionNames;\n    this.canHaveAxes = canHaveAxes;\n    this.contentGroup = this.rootGroup.appendChild(\n      new TranslatableGroup({\n        name: `${this.internalId}-content`,\n        isVirtual: contentGroupVirtual,\n        zIndex: 4 /* SERIES_LAYER */,\n        zIndexSubOrder: this.getGroupZIndexSubOrder(\"data\")\n      })\n    );\n    this.highlightGroup = new TranslatableGroup({\n      name: `${this.internalId}-highlight`,\n      isVirtual: contentGroupVirtual,\n      zIndex: 4 /* SERIES_LAYER */,\n      zIndexSubOrder: this.getGroupZIndexSubOrder(\"highlight\")\n    });\n    this.highlightNode = this.highlightGroup.appendChild(new Group({ name: \"highlightNode\", zIndex: 0 }));\n    this.highlightLabel = this.highlightGroup.appendChild(new Group({ name: \"highlightLabel\", zIndex: 10 }));\n    this.pickModes = pickModes;\n    this.labelGroup = this.rootGroup.appendChild(\n      new TranslatableGroup({\n        name: `${this.internalId}-series-labels`,\n        zIndex: 14 /* SERIES_LABEL */\n      })\n    );\n    this.annotationGroup = new Group({\n      name: `${this.id}-annotation`,\n      isVirtual: contentGroupVirtual,\n      zIndex: 4 /* SERIES_LAYER */,\n      zIndexSubOrder: this.getGroupZIndexSubOrder(\"annotation\")\n    });\n  }\n  get pickModeAxis() {\n    return \"main\";\n  }\n  get id() {\n    return this.properties?.id ?? this.internalId;\n  }\n  get type() {\n    return this.constructor.type ?? \"\";\n  }\n  get data() {\n    return this._data ?? this._chartData;\n  }\n  set visible(value) {\n    this.properties.visible = value;\n    this.visibleMaybeChanged();\n  }\n  get visible() {\n    return this.properties.visible;\n  }\n  get hasData() {\n    return this.data != null && this.data.length > 0;\n  }\n  get tooltipEnabled() {\n    return this.properties.tooltip?.enabled ?? false;\n  }\n  onDataChange() {\n    this.nodeDataRefresh = true;\n    this._pickNodeCache.clear();\n  }\n  setOptionsData(input) {\n    this._data = input;\n    this.onDataChange();\n  }\n  setChartData(input) {\n    this._chartData = input;\n    if (this.data === input) {\n      this.onDataChange();\n    }\n  }\n  onSeriesGroupingChange(prev, next) {\n    const { internalId, type, visible } = this;\n    if (prev) {\n      this.ctx.seriesStateManager.deregisterSeries(this);\n    }\n    if (next) {\n      this.ctx.seriesStateManager.registerSeries({ internalId, type, visible, seriesGrouping: next });\n    }\n    this.fireEvent(new SeriesGroupingChangedEvent(this, next, prev));\n  }\n  getBandScalePadding() {\n    return { inner: 1, outer: 0 };\n  }\n  getGroupZIndexSubOrder(type, subIndex = 0) {\n    let mainAdjust = 0;\n    switch (type) {\n      case \"data\":\n      case \"paths\":\n        break;\n      case \"labels\":\n        mainAdjust += 2e4;\n        break;\n      case \"marker\":\n        mainAdjust += 1e4;\n        break;\n      case \"highlight\":\n        subIndex += 15e3;\n        break;\n      case \"annotation\":\n        mainAdjust += 15e3;\n        break;\n    }\n    const main = () => this._declarationOrder + mainAdjust;\n    return [main, subIndex];\n  }\n  addListener(type, listener) {\n    return this.seriesListeners.addListener(type, listener);\n  }\n  dispatch(type, event) {\n    this.seriesListeners.dispatch(type, event);\n  }\n  addChartEventListeners() {\n    return;\n  }\n  destroy() {\n    this.destroyFns.forEach((f) => f());\n    this.destroyFns = [];\n    this.ctx.seriesStateManager.deregisterSeries(this);\n  }\n  getDirectionValues(direction, properties) {\n    const resolvedDirection = this.resolveKeyDirection(direction);\n    const keys = properties?.[resolvedDirection];\n    const values = [];\n    if (!keys) {\n      return values;\n    }\n    const addValues = (...items) => {\n      for (const value of items) {\n        if (Array.isArray(value)) {\n          addValues(...value);\n        } else if (typeof value === \"object\") {\n          addValues(...Object.values(value));\n        } else {\n          values.push(value);\n        }\n      }\n    };\n    addValues(...keys.map((key) => this.properties[key]));\n    return values;\n  }\n  getKeys(direction) {\n    return this.getDirectionValues(direction, this.directionKeys);\n  }\n  getKeyProperties(direction) {\n    return this.directionKeys[this.resolveKeyDirection(direction)] ?? [];\n  }\n  getNames(direction) {\n    return this.getDirectionValues(direction, this.directionNames);\n  }\n  resolveKeyDirection(direction) {\n    return direction;\n  }\n  // The union of the series domain ('community') and series-option domains ('enterprise').\n  getDomain(direction) {\n    const seriesDomain = this.getSeriesDomain(direction);\n    const moduleDomains = this.moduleMap.mapModules((module) => module.getDomain(direction));\n    return seriesDomain.concat(moduleDomains.flat());\n  }\n  // Indicate that something external changed and we should recalculate nodeData.\n  markNodeDataDirty() {\n    this.nodeDataRefresh = true;\n    this._pickNodeCache.clear();\n    this.visibleMaybeChanged();\n  }\n  visibleMaybeChanged() {\n    this.ctx.seriesStateManager.updateSeries(this);\n  }\n  getOpacity() {\n    const defaultOpacity = 1;\n    const { dimOpacity = 1, enabled = true } = this.properties.highlightStyle.series;\n    if (!enabled || dimOpacity === defaultOpacity) {\n      return defaultOpacity;\n    }\n    switch (this.isItemIdHighlighted()) {\n      case 0 /* None */:\n      case 1 /* This */:\n        return defaultOpacity;\n      case 2 /* Other */:\n      default:\n        return dimOpacity;\n    }\n  }\n  getStrokeWidth(defaultStrokeWidth) {\n    const { strokeWidth, enabled = true } = this.properties.highlightStyle.series;\n    if (!enabled || strokeWidth === void 0) {\n      return defaultStrokeWidth;\n    }\n    switch (this.isItemIdHighlighted()) {\n      case 1 /* This */:\n        return strokeWidth;\n      case 0 /* None */:\n      case 2 /* Other */:\n        return defaultStrokeWidth;\n    }\n  }\n  isItemIdHighlighted() {\n    const series = this.ctx.highlightManager?.getActiveHighlight()?.series;\n    if (series == null) {\n      return 0 /* None */;\n    }\n    if (series !== this) {\n      return 2 /* Other */;\n    }\n    return 1 /* This */;\n  }\n  getModuleTooltipParams() {\n    return this.moduleMap.mapModules((module) => module.getTooltipParams()).reduce((total, current) => Object.assign(total, current), {});\n  }\n  pickNode(point, intent, exactMatchOnly = false) {\n    const { pickModes, pickModeAxis, visible, rootGroup } = this;\n    if (!visible || !rootGroup.visible)\n      return;\n    if (intent === \"highlight\" && !this.properties.highlight.enabled)\n      return;\n    if (intent === \"highlight-tooltip\" && !this.properties.highlight.enabled)\n      return;\n    let maxDistance = Infinity;\n    if (intent === \"tooltip\" || intent === \"highlight-tooltip\") {\n      const { tooltip } = this.properties;\n      maxDistance = typeof tooltip.range === \"number\" ? tooltip.range : Infinity;\n      exactMatchOnly || (exactMatchOnly = tooltip.range === \"exact\");\n    } else if (intent === \"event\" || intent === \"context-menu\") {\n      const { nodeClickRange } = this.properties;\n      maxDistance = typeof nodeClickRange === \"number\" ? nodeClickRange : Infinity;\n      exactMatchOnly || (exactMatchOnly = nodeClickRange === \"exact\");\n    }\n    const selectedPickModes = pickModes.filter(\n      (m) => !exactMatchOnly || m === 0 /* EXACT_SHAPE_MATCH */\n    );\n    const { x, y } = point;\n    const key = JSON.stringify({ x, y, maxDistance, selectedPickModes });\n    if (this._pickNodeCache.has(key)) {\n      return this._pickNodeCache.get(key);\n    }\n    for (const pickMode of selectedPickModes) {\n      let match;\n      switch (pickMode) {\n        case 0 /* EXACT_SHAPE_MATCH */:\n          match = this.pickNodeExactShape(point);\n          break;\n        case 1 /* NEAREST_NODE */:\n          match = this.pickNodeClosestDatum(point);\n          break;\n        case 2 /* AXIS_ALIGNED */:\n          match = pickMode != null ? this.pickNodeMainAxisFirst(point, pickModeAxis === \"main-category\") : void 0;\n          break;\n      }\n      if (match && match.distance <= maxDistance) {\n        return this._pickNodeCache.set(key, { pickMode, match: match.datum, distance: match.distance });\n      }\n    }\n    return this._pickNodeCache.set(key, void 0);\n  }\n  pickNodeExactShape(point) {\n    const match = this.contentGroup.pickNode(point.x, point.y);\n    if (match && match.datum.missing !== true) {\n      return { datum: match.datum, distance: 0 };\n    }\n    return void 0;\n  }\n  pickNodeClosestDatum(_point) {\n    throw new Error(\"AG Charts - Series.pickNodeClosestDatum() not implemented\");\n  }\n  pickNodeNearestDistantObject(point, items) {\n    const match = nearestSquared(point.x, point.y, items);\n    if (match.nearest !== void 0 && match.nearest.datum.missing !== true) {\n      return { datum: match.nearest.datum, distance: Math.sqrt(match.distanceSquared) };\n    }\n    return void 0;\n  }\n  pickNodeMainAxisFirst(_point, _requireCategoryAxis) {\n    throw new Error(\"AG Charts - Series.pickNodeMainAxisFirst() not implemented\");\n  }\n  fireNodeClickEvent(event, datum) {\n    this.fireEvent(new this.NodeEvent(\"nodeClick\", event, datum, this));\n  }\n  fireNodeDoubleClickEvent(event, datum) {\n    this.fireEvent(new this.NodeEvent(\"nodeDoubleClick\", event, datum, this));\n  }\n  createNodeContextMenuActionEvent(event, datum) {\n    return new this.NodeEvent(\"nodeContextMenuAction\", event, datum, this);\n  }\n  toggleSeriesItem(itemId, enabled) {\n    this.visible = enabled;\n    this.nodeDataRefresh = true;\n    this._pickNodeCache.clear();\n    this.dispatch(\"visibility-changed\", { itemId, enabled });\n  }\n  isEnabled() {\n    return this.visible;\n  }\n  getModuleMap() {\n    return this.moduleMap;\n  }\n  createModuleContext() {\n    return { ...this.ctx, series: this };\n  }\n  getLabelText(label, params, defaultFormatter = String) {\n    if (label.formatter) {\n      return this.ctx.callbackCache.call(label.formatter, { seriesId: this.id, ...params }) ?? defaultFormatter(params.value);\n    }\n    return defaultFormatter(params.value);\n  }\n  getMarkerStyle(marker, params, defaultStyle = marker.getStyle()) {\n    const defaultSize = { size: params.datum.point?.size ?? 0 };\n    const markerStyle = mergeDefaults(defaultSize, defaultStyle);\n    if (marker.itemStyler) {\n      const style = this.ctx.callbackCache.call(marker.itemStyler, {\n        seriesId: this.id,\n        ...markerStyle,\n        ...params,\n        datum: params.datum.datum\n      });\n      return mergeDefaults(style, markerStyle);\n    }\n    return markerStyle;\n  }\n  updateMarkerStyle(markerNode, marker, params, defaultStyle = marker.getStyle(), { applyTranslation = true, selected = true } = {}) {\n    const { point } = params.datum;\n    const activeStyle = this.getMarkerStyle(marker, params, defaultStyle);\n    const visible = this.visible && activeStyle.size > 0 && point && !isNaN(point.x) && !isNaN(point.y);\n    if (applyTranslation) {\n      markerNode.setProperties({ visible, ...activeStyle, translationX: point?.x, translationY: point?.y });\n    } else {\n      markerNode.setProperties({ visible, ...activeStyle });\n    }\n    if (!selected) {\n      markerNode.fillOpacity *= CROSS_FILTER_MARKER_FILL_OPACITY_FACTOR;\n      markerNode.strokeOpacity *= CROSS_FILTER_MARKER_STROKE_OPACITY_FACTOR;\n    }\n    if (typeof marker.shape === \"function\" && !markerNode.dirtyPath) {\n      markerNode.path.clear(true);\n      markerNode.updatePath();\n      markerNode.checkPathDirty();\n      const bb = markerNode.getBBox();\n      if (point !== void 0 && bb.isFinite()) {\n        const center2 = bb.computeCenter();\n        const [dx, dy] = [\"x\", \"y\"].map(\n          (key) => (activeStyle.strokeWidth ?? 0) + Math.abs(center2[key] - point[key])\n        );\n        const customSize = Math.max(bb.width + dx, bb.height + dy);\n        point.focusSize = customSize;\n      }\n    }\n  }\n  getMinRects(_width, _height) {\n    return;\n  }\n  get nodeDataDependencies() {\n    return this._nodeDataDependencies ?? { seriesRectWidth: NaN, seriesRectHeight: NaN };\n  }\n  checkResize(newSeriesRect) {\n    const { width: seriesRectWidth, height: seriesRectHeight } = newSeriesRect ?? { width: NaN, height: NaN };\n    const newNodeDataDependencies = newSeriesRect ? { seriesRectWidth, seriesRectHeight } : void 0;\n    const resize = jsonDiff(this.nodeDataDependencies, newNodeDataDependencies) != null;\n    if (resize) {\n      this._nodeDataDependencies = newNodeDataDependencies;\n      this.markNodeDataDirty();\n    }\n    return resize;\n  }\n  pickFocus(_opts) {\n    return void 0;\n  }\n};\nSeries.highlightedZIndex = 1e12;\n__decorateClass([\n  ActionOnSet({\n    changeValue: function(newVal, oldVal) {\n      this.onSeriesGroupingChange(oldVal, newVal);\n    }\n  })\n], Series.prototype, \"seriesGrouping\", 2);\n\n// packages/ag-charts-community/src/chart/keyboardUtil.ts\nfunction computeCenter(bboxOrPath) {\n  if (bboxOrPath == null)\n    return;\n  if (bboxOrPath instanceof BBox) {\n    return bboxOrPath.computeCenter();\n  }\n  return Transformable.toCanvas(bboxOrPath).computeCenter();\n}\nfunction drawPickedFocus(focusIndicator, pick) {\n  const { bounds, showFocusBox } = pick;\n  if (showFocusBox) {\n    focusIndicator?.updateBounds(bounds);\n  }\n}\nfunction makeKeyboardPointerEvent(focusIndicator, pick) {\n  drawPickedFocus(focusIndicator, pick);\n  const { x: offsetX, y: offsetY } = computeCenter(pick.bounds) ?? {};\n  if (offsetX !== void 0 && offsetY !== void 0) {\n    return { type: \"keyboard\", offsetX, offsetY };\n  }\n  return void 0;\n}\n\n// packages/ag-charts-community/src/chart/series/util.ts\nfunction convertValuesToScaleByDefs({\n  defs,\n  values,\n  xAxis,\n  yAxis\n}) {\n  if (!(xAxis && yAxis)) {\n    throw new Error(\"Axes must be defined\");\n  }\n  const result = {};\n  for (const [searchId, { def }] of defs) {\n    if (Object.hasOwn(values, searchId)) {\n      const { scale: scale2 } = def.type === \"key\" ? xAxis : yAxis;\n      result[searchId] = Math.round(scale2.convert(values[searchId]));\n    }\n  }\n  return result;\n}\nfunction pickNode(inputSeries, point, intent, exactMatchOnly) {\n  const reverseSeries = [...inputSeries].reverse();\n  let result;\n  for (const series of reverseSeries) {\n    if (!series.visible || !series.rootGroup.visible) {\n      continue;\n    }\n    const { match, distance: distance3 } = series.pickNode(point, intent, exactMatchOnly) ?? {};\n    if (!match || distance3 == null) {\n      continue;\n    }\n    if (!result || result.distance > distance3) {\n      result = { series, distance: distance3, datum: match };\n    }\n    if (distance3 === 0) {\n      break;\n    }\n  }\n  return result;\n}\n\n// packages/ag-charts-community/src/chart/series/seriesAreaManager.ts\nvar SeriesAreaAriaLabel = class {\n  constructor(element2, id) {\n    this.element = element2;\n    this.id = id;\n    element2.id = id;\n    element2.style.display = \"none\";\n    setAttribute(element2.parentElement, \"aria-labelledby\", id);\n  }\n  layoutComplete(event) {\n    this.element.parentElement.style.width = `${event.chart.width}px`;\n    this.element.parentElement.style.height = `${event.chart.height}px`;\n  }\n  set text(text) {\n    this.element.textContent = text;\n  }\n};\nvar SeriesAreaManager = class extends BaseManager {\n  constructor(chart) {\n    super();\n    this.chart = chart;\n    this.id = createId(this);\n    this.series = [];\n    this.highlight = {\n      /** Last received event that still needs to be applied. */\n      pendingHoverEvent: void 0,\n      /** Last applied event. */\n      appliedHoverEvent: void 0,\n      /** Last applied event, which has been temporarily stashed during the main chart update cycle. */\n      stashedHoverEvent: void 0\n    };\n    this.tooltip = {\n      lastHover: void 0\n    };\n    /**\n     * A11y Requirements for Tooltip/Highlight (see AG-13051 for details):\n     *\n     *   -   When the series-area is blurred, always the mouse to update the tooltip/highlight.\n     *\n     *   -   When the series-area receives a `focus` event, use `:focus-visible` to guess the input device.\n     *       (this is decided by the browser).\n     *\n     *   -   For keyboard users, `focus` and `keydown` events always updates & shows the tooltip/highlight on\n     *       the currently (or newly) focused datum.\n     *\n     *   -   For keyboard users, `mousemove` events update the tooltip/highlight iff `pickNode` finds a match\n     *       for the mouse event offsets.\n     */\n    this.hoverDevice = \"mouse\";\n    this.focus = {\n      sortedSeries: [],\n      series: void 0,\n      seriesIndex: 0,\n      datumIndex: 0,\n      datum: void 0\n    };\n    this.hoverScheduler = debouncedAnimationFrame(() => {\n      if (!this.tooltip.lastHover && !this.highlight.pendingHoverEvent)\n        return;\n      if (this.chart.getUpdateType() <= 4 /* SERIES_UPDATE */) {\n        this.hoverScheduler.schedule();\n        return;\n      }\n      if (this.highlight.pendingHoverEvent) {\n        this.handleHoverHighlight(false);\n      }\n      if (this.tooltip.lastHover) {\n        this.handleHoverTooltip(this.tooltip.lastHover, false);\n      }\n    });\n    const seriesRegion = chart.ctx.regionManager.getRegion(\"series\" /* SERIES */);\n    const horizontalAxesRegion = chart.ctx.regionManager.getRegion(\"horizontal-axes\" /* HORIZONTAL_AXES */);\n    const verticalAxesRegion = chart.ctx.regionManager.getRegion(\"vertical-axes\" /* VERTICAL_AXES */);\n    const mouseMoveStates = 32 /* Default */ | 8 /* Annotations */ | 1 /* AnnotationsSelected */;\n    const keyState = 32 /* Default */ | 2 /* Animation */;\n    const labelEl = chart.ctx.domManager.addChild(\"series-area\", \"series-area-aria-label\");\n    this.ariaLabel = new SeriesAreaAriaLabel(labelEl, `${this.id}-aria-label`);\n    this.destroyFns.push(\n      () => chart.ctx.domManager.removeChild(\"series-area\", \"series-area-aria-label\"),\n      seriesRegion.addListener(\"contextmenu\", (event) => this.onContextMenu(event), 63 /* All */),\n      seriesRegion.addListener(\"drag\", (event) => this.onHoverLikeEvent(event), mouseMoveStates),\n      seriesRegion.addListener(\"hover\", (event) => this.onHover(event), mouseMoveStates),\n      seriesRegion.addListener(\"leave\", () => this.onLeave(), mouseMoveStates),\n      horizontalAxesRegion.addListener(\"hover\", (event) => this.onHover(event), mouseMoveStates),\n      horizontalAxesRegion.addListener(\"leave\", () => this.onLeave()),\n      verticalAxesRegion.addListener(\"hover\", (event) => this.onHover(event), mouseMoveStates),\n      verticalAxesRegion.addListener(\"leave\", () => this.onLeave()),\n      chart.ctx.animationManager.addListener(\"animation-start\", () => this.clearAll()),\n      chart.ctx.domManager.addListener(\"resize\", () => this.clearAll()),\n      chart.ctx.highlightManager.addListener(\"highlight-change\", (event) => this.changeHighlightDatum(event)),\n      chart.ctx.keyNavManager.addListener(\"blur\", () => this.onBlur()),\n      chart.ctx.keyNavManager.addListener(\"focus\", (event) => this.onFocus(event), keyState),\n      chart.ctx.keyNavManager.addListener(\"nav-hori\", (event) => this.onNavHori(event), keyState),\n      chart.ctx.keyNavManager.addListener(\"nav-vert\", (event) => this.onNavVert(event), keyState),\n      chart.ctx.keyNavManager.addListener(\"submit\", (event) => this.onSubmit(event), keyState),\n      chart.ctx.layoutManager.addListener(\"layout:complete\", (event) => this.layoutComplete(event)),\n      chart.ctx.regionManager.listenAll(\"click\", (event) => this.onClick(event)),\n      chart.ctx.regionManager.listenAll(\"dblclick\", (event) => this.onClick(event)),\n      chart.ctx.updateService.addListener(\"pre-scene-render\", () => this.preSceneRender()),\n      chart.ctx.zoomManager.addListener(\"zoom-change\", () => this.clearAll()),\n      chart.ctx.zoomManager.addListener(\"zoom-pan-start\", () => this.clearAll())\n    );\n  }\n  dataChanged() {\n    var _a;\n    (_a = this.highlight).stashedHoverEvent ?? (_a.stashedHoverEvent = this.highlight.appliedHoverEvent);\n    this.chart.ctx.tooltipManager.removeTooltip(this.id);\n    this.chart.ctx.focusIndicator.updateBounds(void 0);\n    this.clearHighlight();\n  }\n  preSceneRender() {\n    this.refreshFocus();\n    if (this.highlight.stashedHoverEvent != null) {\n      this.highlight.pendingHoverEvent = this.highlight.stashedHoverEvent;\n      this.highlight.stashedHoverEvent = void 0;\n      this.handleHoverHighlight(true);\n    }\n    if (this.tooltip.lastHover != null) {\n      this.handleHoverTooltip(this.tooltip.lastHover, true);\n    }\n  }\n  update(type, opts) {\n    this.chart.ctx.updateService.update(type, opts);\n  }\n  seriesChanged(series) {\n    this.focus.sortedSeries = [...series].sort((a, b) => {\n      let fpA = a.properties.focusPriority ?? Infinity;\n      let fpB = b.properties.focusPriority ?? Infinity;\n      if (fpA === fpB) {\n        [fpA, fpB] = [a._declarationOrder, b._declarationOrder];\n      }\n      if (fpA < fpB) {\n        return -1;\n      } else if (fpA > fpB) {\n        return 1;\n      }\n      return 0;\n    });\n    this.series = series;\n  }\n  layoutComplete(event) {\n    this.seriesRect = event.series.rect;\n    this.hoverRect = event.series.paddedRect;\n    this.ariaLabel.layoutComplete(event);\n  }\n  onContextMenu(event) {\n    const { Default: Default2, ContextMenu } = InteractionState;\n    let pickedNode;\n    let position;\n    if (this.chart.ctx.focusIndicator.isFocusVisible()) {\n      pickedNode = this.chart.ctx.highlightManager.getActiveHighlight();\n      if (pickedNode && this.seriesRect && pickedNode.midPoint) {\n        position = Transformable.toCanvasPoint(\n          pickedNode.series.contentGroup,\n          pickedNode.midPoint.x,\n          pickedNode.midPoint.y\n        );\n      }\n    } else if (this.chart.ctx.interactionManager.getState() & (Default2 | ContextMenu)) {\n      const match = pickNode(this.series, { x: event.regionOffsetX, y: event.regionOffsetY }, \"context-menu\");\n      if (match) {\n        this.chart.ctx.highlightManager.updateHighlight(this.id);\n        pickedNode = match.datum;\n      }\n    }\n    this.clearAll();\n    this.chart.ctx.contextMenuRegistry.dispatchContext(\"series\", event, { pickedNode }, position);\n  }\n  onLeave() {\n    this.chart.ctx.cursorManager.updateCursor(this.id);\n    if (!this.chart.ctx.focusIndicator.isFocusVisible())\n      this.clearAll();\n  }\n  onHover(event) {\n    this.hoverDevice = \"mouse\";\n    this.onHoverLikeEvent(event);\n  }\n  onHoverLikeEvent(event) {\n    if (excludesType(event, \"drag\")) {\n      this.tooltip.lastHover = event;\n    }\n    this.highlight.pendingHoverEvent = event;\n    this.hoverScheduler.schedule();\n    if (this.chart.ctx.interactionManager.getState() === 32 /* Default */) {\n      const { regionOffsetX, regionOffsetY } = event;\n      const found = pickNode(this.series, { x: regionOffsetX, y: regionOffsetY }, \"event\");\n      if (found?.series.hasEventListener(\"nodeClick\") || found?.series.hasEventListener(\"nodeDoubleClick\")) {\n        this.chart.ctx.cursorManager.updateCursor(this.id, \"pointer\");\n      } else {\n        this.chart.ctx.cursorManager.updateCursor(this.id);\n      }\n    }\n  }\n  onClick(event) {\n    this.hoverDevice = \"mouse\";\n    this.onHoverLikeEvent(event);\n    if (this.seriesRect?.containsPoint(event.offsetX, event.offsetY) && this.checkSeriesNodeClick(event)) {\n      this.update(4 /* SERIES_UPDATE */);\n      event.preventDefault();\n      return;\n    }\n    const newEvent = { type: event.type === \"click\" ? \"click\" : \"doubleClick\", event: event.sourceEvent };\n    this.chart.fireEvent(newEvent);\n  }\n  onFocus(event) {\n    this.hoverDevice = this.chart.ctx.focusIndicator.isFocusVisible() ? \"keyboard\" : \"mouse\";\n    this.handleFocus(0, 0);\n    event.preventDefault();\n  }\n  onBlur() {\n    this.hoverDevice = \"mouse\";\n    this.clearAll();\n  }\n  onNavVert(event) {\n    this.hoverDevice = \"keyboard\";\n    this.focus.seriesIndex += event.delta;\n    this.handleFocus(event.delta, 0);\n    event.preventDefault();\n  }\n  onNavHori(event) {\n    this.hoverDevice = \"keyboard\";\n    this.focus.datumIndex += event.delta;\n    this.handleFocus(0, event.delta);\n    event.preventDefault();\n  }\n  onSubmit(event) {\n    const { series, datum } = this.focus;\n    const sourceEvent = event.sourceEvent.sourceEvent;\n    if (series !== void 0 && datum !== void 0) {\n      series.fireNodeClickEvent(sourceEvent, datum);\n    } else {\n      this.chart.fireEvent({\n        type: \"click\",\n        event: sourceEvent\n      });\n    }\n    event.preventDefault();\n  }\n  checkSeriesNodeClick(event) {\n    let point = { x: event.regionOffsetX, y: event.regionOffsetY };\n    if (event.region !== \"series\") {\n      point = Transformable.fromCanvasPoint(this.chart.seriesRoot, event.offsetX, event.offsetY);\n    }\n    const result = pickNode(this.series, point, \"event\");\n    if (result == null)\n      return false;\n    if (event.type === \"click\") {\n      result.series.fireNodeClickEvent(event.sourceEvent, result.datum);\n      return true;\n    }\n    if (event.type === \"dblclick\") {\n      event.preventZoomDblClick = result.distance === 0;\n      result.series.fireNodeDoubleClickEvent(event.sourceEvent, result.datum);\n      return true;\n    }\n    return false;\n  }\n  refreshFocus() {\n    if (this.chart.ctx.focusIndicator.isFocusVisible()) {\n      this.handleSeriesFocus(0, 0);\n    }\n  }\n  handleFocus(seriesIndexDelta, datumIndexDelta) {\n    const overlayFocus = this.chart.overlays.getFocusInfo(this.chart.ctx.localeManager);\n    if (overlayFocus == null) {\n      this.handleSeriesFocus(seriesIndexDelta, datumIndexDelta);\n    } else {\n      this.chart.ctx.focusIndicator.updateBounds(overlayFocus.rect);\n    }\n  }\n  handleSeriesFocus(otherIndexDelta, datumIndexDelta) {\n    if (this.chart.chartType === \"hierarchy\") {\n      this.handleHierarchySeriesFocus(otherIndexDelta, datumIndexDelta);\n      return;\n    }\n    const { focus, seriesRect } = this;\n    const visibleSeries = focus.sortedSeries.filter((s) => s.visible);\n    if (visibleSeries.length === 0)\n      return;\n    focus.seriesIndex = clamp(0, focus.seriesIndex, visibleSeries.length - 1);\n    focus.series = visibleSeries[focus.seriesIndex];\n    const { datumIndex, seriesIndex: otherIndex } = focus;\n    const pick = focus.series.pickFocus({ datumIndex, datumIndexDelta, otherIndex, otherIndexDelta, seriesRect });\n    this.updatePickedFocus(pick);\n  }\n  handleHierarchySeriesFocus(otherIndexDelta, datumIndexDelta) {\n    this.focus.series = this.focus.sortedSeries[0];\n    const {\n      focus: { series, seriesIndex: otherIndex, datumIndex },\n      seriesRect\n    } = this;\n    if (series === void 0)\n      return;\n    const pick = series.pickFocus({ datumIndex, datumIndexDelta, otherIndex, otherIndexDelta, seriesRect });\n    this.updatePickedFocus(pick);\n  }\n  updatePickedFocus(pick) {\n    const { focus } = this;\n    if (pick === void 0 || focus.series === void 0)\n      return;\n    const { datum, datumIndex } = pick;\n    focus.datumIndex = datumIndex;\n    focus.datum = datum;\n    if (this.chart.ctx.focusIndicator.isFocusVisible()) {\n      this.chart.ctx.animationManager.reset();\n    }\n    const keyboardEvent = makeKeyboardPointerEvent(this.chart.ctx.focusIndicator, pick);\n    if (keyboardEvent !== void 0 && this.hoverDevice === \"keyboard\") {\n      this.tooltip.lastHover = void 0;\n      this.highlight.appliedHoverEvent = void 0;\n      this.highlight.pendingHoverEvent = void 0;\n      this.highlight.stashedHoverEvent = void 0;\n      const html = focus.series.getTooltipHtml(datum);\n      const meta = TooltipManager.makeTooltipMeta(keyboardEvent, datum);\n      this.chart.ctx.highlightManager.updateHighlight(this.id, datum);\n      this.chart.ctx.tooltipManager.updateTooltip(this.id, meta, html);\n      this.ariaLabel.text = this.getDatumAriaText(datum, html);\n    }\n  }\n  getDatumAriaText(datum, html) {\n    const description = html.ariaLabel;\n    return this.chart.ctx.localeManager.t(\"ariaAnnounceHoverDatum\", {\n      datum: datum.series.getDatumAriaText?.(datum, description) ?? description\n    });\n  }\n  clearHighlight() {\n    this.highlight.pendingHoverEvent = void 0;\n    this.highlight.appliedHoverEvent = void 0;\n    this.chart.ctx.highlightManager.updateHighlight(this.id);\n  }\n  clearTooltip() {\n    this.chart.ctx.tooltipManager.removeTooltip(this.id);\n    this.tooltip.lastHover = void 0;\n  }\n  clearAll() {\n    this.clearHighlight();\n    this.clearTooltip();\n    this.chart.ctx.focusIndicator.updateBounds(void 0);\n  }\n  handleHoverHighlight(redisplay) {\n    this.highlight.appliedHoverEvent = this.highlight.pendingHoverEvent;\n    this.highlight.pendingHoverEvent = void 0;\n    const event = this.highlight.appliedHoverEvent;\n    if (!event)\n      return;\n    const state = this.chart.ctx.interactionManager.getState();\n    if (state !== 32 /* Default */ && state !== 8 /* Annotations */ && state !== 1 /* AnnotationsSelected */)\n      return;\n    const { offsetX, offsetY } = event;\n    if (redisplay ? this.chart.ctx.animationManager.isActive() : !this.hoverRect?.containsPoint(offsetX, offsetY)) {\n      this.clearHighlight();\n      return;\n    }\n    let pickCoords = { x: event.regionOffsetX, y: event.regionOffsetY };\n    if (event.region !== \"series\") {\n      pickCoords = Transformable.fromCanvasPoint(this.chart.seriesRoot, offsetX, offsetY);\n    }\n    const { range: range3 } = this.chart.highlight;\n    const intent = range3 === \"tooltip\" ? \"highlight-tooltip\" : \"highlight\";\n    const found = pickNode(this.series, pickCoords, intent);\n    if (found) {\n      this.chart.ctx.highlightManager.updateHighlight(this.id, found.datum);\n      this.hoverDevice = \"mouse\";\n      return;\n    }\n    this.chart.ctx.highlightManager.updateHighlight(this.id);\n  }\n  handleHoverTooltip(event, redisplay) {\n    const state = this.chart.ctx.interactionManager.getState();\n    if (state !== 32 /* Default */ && state !== 8 /* Annotations */ && state !== 1 /* AnnotationsSelected */)\n      return;\n    const { offsetX, offsetY, targetElement, regionOffsetX, regionOffsetY } = event;\n    if (redisplay ? this.chart.ctx.animationManager.isActive() : !this.hoverRect?.containsPoint(offsetX, offsetY)) {\n      if (this.hoverDevice == \"mouse\")\n        this.clearTooltip();\n      return;\n    }\n    if (targetElement && this.chart.tooltip.interactive && this.chart.ctx.domManager.isManagedChildDOMElement(targetElement, \"canvas-overlay\", DEFAULT_TOOLTIP_CLASS)) {\n      return;\n    }\n    let pickCoords = { x: regionOffsetX, y: regionOffsetY };\n    if (event.region !== \"series\") {\n      pickCoords = Transformable.fromCanvasPoint(this.chart.seriesRoot, offsetX, offsetY);\n    }\n    const pick = pickNode(this.series, pickCoords, \"tooltip\");\n    if (!pick) {\n      if (this.hoverDevice == \"mouse\")\n        this.clearTooltip();\n      return;\n    }\n    this.hoverDevice = \"mouse\";\n    const html = pick.series.getTooltipHtml(pick.datum);\n    const tooltipEnabled = this.chart.tooltip.enabled && pick.series.tooltipEnabled;\n    const shouldUpdateTooltip = tooltipEnabled && html != null;\n    if (shouldUpdateTooltip) {\n      const meta = TooltipManager.makeTooltipMeta(event, pick.datum);\n      this.chart.ctx.tooltipManager.updateTooltip(this.id, meta, html);\n    }\n  }\n  changeHighlightDatum(event) {\n    const seriesToUpdate = /* @__PURE__ */ new Set();\n    const { series: newSeries = void 0, datum: newDatum } = event.currentHighlight ?? {};\n    const { series: lastSeries = void 0, datum: lastDatum } = event.previousHighlight ?? {};\n    if (lastSeries) {\n      seriesToUpdate.add(lastSeries);\n    }\n    if (newSeries) {\n      seriesToUpdate.add(newSeries);\n    }\n    if (lastSeries?.properties.cursor && lastDatum) {\n      this.chart.ctx.cursorManager.updateCursor(lastSeries.id);\n    }\n    if (newSeries?.properties.cursor && newSeries?.properties.cursor !== \"default\" && newDatum) {\n      this.chart.ctx.cursorManager.updateCursor(newSeries.id, newSeries.properties.cursor);\n    }\n    const updateAll = newSeries == null || lastSeries == null;\n    if (updateAll) {\n      this.update(4 /* SERIES_UPDATE */);\n    } else {\n      this.update(4 /* SERIES_UPDATE */, { seriesToUpdate });\n    }\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/seriesLayerManager.ts\nvar SERIES_THRESHOLD_FOR_AGGRESSIVE_LAYER_REDUCTION = 30;\nvar SeriesLayerManager = class {\n  constructor(seriesRoot, highlightRoot, annotationRoot) {\n    this.seriesRoot = seriesRoot;\n    this.highlightRoot = highlightRoot;\n    this.annotationRoot = annotationRoot;\n    this.groups = {};\n    this.series = {};\n    this.expectedSeriesCount = 1;\n    this.mode = \"normal\";\n  }\n  setSeriesCount(count) {\n    this.expectedSeriesCount = count;\n  }\n  requestGroup(seriesConfig) {\n    var _a, _b;\n    const {\n      internalId,\n      type,\n      rootGroup: seriesRootGroup,\n      highlightGroup: seriesHighlightGroup,\n      annotationGroup: seriesAnnotationGroup,\n      seriesGrouping\n    } = seriesConfig;\n    const { groupIndex = internalId } = seriesGrouping ?? {};\n    if (this.series[internalId] != null) {\n      throw new Error(`AG Charts - series already has an allocated layer: ${this.series[internalId]}`);\n    }\n    if (Object.keys(this.series).length === 0) {\n      this.mode = this.expectedSeriesCount >= SERIES_THRESHOLD_FOR_AGGRESSIVE_LAYER_REDUCTION ? \"aggressive-grouping\" : \"normal\";\n    }\n    (_a = this.groups)[type] ?? (_a[type] = {});\n    const lookupIndex = this.lookupIdx(groupIndex);\n    const groupInfo = (_b = this.groups[type])[lookupIndex] ?? (_b[lookupIndex] = {\n      type,\n      id: lookupIndex,\n      seriesIds: [],\n      group: this.seriesRoot.appendChild(\n        new Layer({\n          name: `${type}-content`,\n          zIndex: 4 /* SERIES_LAYER */,\n          zIndexSubOrder: seriesConfig.getGroupZIndexSubOrder(\"data\")\n        })\n      ),\n      highlight: this.highlightRoot.appendChild(\n        new Group({\n          name: `${type}-highlight`,\n          zIndex: 4 /* SERIES_LAYER */,\n          zIndexSubOrder: seriesConfig.getGroupZIndexSubOrder(\"highlight\")\n        })\n      ),\n      annotation: this.annotationRoot.appendChild(\n        new Group({\n          name: `${type}-annotation`,\n          zIndex: 4 /* SERIES_LAYER */,\n          zIndexSubOrder: seriesConfig.getGroupZIndexSubOrder(\"annotation\")\n        })\n      )\n    });\n    this.series[internalId] = { layerState: groupInfo, seriesConfig };\n    groupInfo.seriesIds.push(internalId);\n    groupInfo.group.appendChild(seriesRootGroup);\n    groupInfo.highlight.appendChild(seriesHighlightGroup);\n    groupInfo.annotation.appendChild(seriesAnnotationGroup);\n    return groupInfo.group;\n  }\n  changeGroup(seriesConfig) {\n    const { internalId, seriesGrouping, type, rootGroup, highlightGroup, annotationGroup, oldGrouping } = seriesConfig;\n    const { groupIndex = internalId } = seriesGrouping ?? {};\n    if (this.groups[type]?.[groupIndex]?.seriesIds.includes(internalId)) {\n      return;\n    }\n    if (this.series[internalId] != null) {\n      this.releaseGroup({\n        internalId,\n        seriesGrouping: oldGrouping,\n        type,\n        rootGroup,\n        highlightGroup,\n        annotationGroup\n      });\n    }\n    this.requestGroup(seriesConfig);\n  }\n  releaseGroup(seriesConfig) {\n    const { internalId, rootGroup, highlightGroup, annotationGroup, type } = seriesConfig;\n    if (this.series[internalId] == null) {\n      throw new Error(`AG Charts - series doesn't have an allocated layer: ${internalId}`);\n    }\n    const groupInfo = this.series[internalId]?.layerState;\n    if (groupInfo) {\n      groupInfo.seriesIds = groupInfo.seriesIds.filter((v) => v !== internalId);\n      groupInfo.group.removeChild(rootGroup);\n      groupInfo.highlight.removeChild(highlightGroup);\n      groupInfo.annotation.removeChild(annotationGroup);\n    }\n    if (groupInfo?.seriesIds.length === 0) {\n      this.seriesRoot.removeChild(groupInfo.group);\n      this.highlightRoot.removeChild(groupInfo.highlight);\n      this.annotationRoot.removeChild(groupInfo.annotation);\n      delete this.groups[groupInfo.type][groupInfo.id];\n      delete this.groups[type][internalId];\n    } else if (groupInfo?.seriesIds.length > 0) {\n      const leadSeriesConfig = this.series[groupInfo?.seriesIds?.[0]]?.seriesConfig;\n      groupInfo.group.zIndexSubOrder = leadSeriesConfig?.getGroupZIndexSubOrder(\"data\");\n      groupInfo.highlight.zIndexSubOrder = leadSeriesConfig?.getGroupZIndexSubOrder(\"highlight\");\n      groupInfo.annotation.zIndexSubOrder = leadSeriesConfig?.getGroupZIndexSubOrder(\"annotation\");\n    }\n    delete this.series[internalId];\n  }\n  lookupIdx(groupIndex) {\n    if (this.mode === \"normal\") {\n      return groupIndex;\n    }\n    if (typeof groupIndex === \"string\") {\n      groupIndex = Number(groupIndex.split(\"-\").at(-1));\n      if (!groupIndex) {\n        return 0;\n      }\n    }\n    return Math.floor(\n      clamp(0, groupIndex / this.expectedSeriesCount, 1) * SERIES_THRESHOLD_FOR_AGGRESSIVE_LAYER_REDUCTION\n    );\n  }\n  destroy() {\n    for (const groups of Object.values(this.groups)) {\n      for (const groupInfo of Object.values(groups)) {\n        this.seriesRoot.removeChild(groupInfo.group);\n        this.highlightRoot.removeChild(groupInfo.highlight);\n        this.annotationRoot.removeChild(groupInfo.annotation);\n      }\n    }\n    this.groups = {};\n    this.series = {};\n  }\n};\n\n// packages/ag-charts-community/src/chart/update/dataWindowProcessor.ts\nvar DataWindowProcessor = class {\n  constructor(chart, dataService, updateService, zoomManager) {\n    this.chart = chart;\n    this.dataService = dataService;\n    this.updateService = updateService;\n    this.zoomManager = zoomManager;\n    this.dirtyZoom = false;\n    this.dirtyDataSource = false;\n    this.lastAxisZooms = /* @__PURE__ */ new Map();\n    this.destroyFns = [];\n    this.destroyFns.push(\n      this.dataService.addListener(\"data-source-change\", () => this.onDataSourceChange()),\n      this.dataService.addListener(\"data-load\", () => this.onDataLoad()),\n      this.dataService.addListener(\"data-error\", () => this.onDataError()),\n      this.updateService.addListener(\"update-complete\", () => this.onUpdateComplete()),\n      this.zoomManager.addListener(\"zoom-change\", () => this.onZoomChange())\n    );\n  }\n  destroy() {\n    this.destroyFns.forEach((cb) => cb());\n  }\n  onDataLoad() {\n    this.updateService.update(1 /* UPDATE_DATA */);\n  }\n  onDataError() {\n    this.updateService.update(3 /* PERFORM_LAYOUT */);\n  }\n  onDataSourceChange() {\n    this.dirtyDataSource = true;\n  }\n  onUpdateComplete() {\n    if (!this.dirtyZoom && !this.dirtyDataSource)\n      return;\n    this.updateWindow().catch((e) => Logger.errorOnce(e));\n  }\n  onZoomChange() {\n    this.dirtyZoom = true;\n  }\n  async updateWindow() {\n    if (!this.dataService.isLazy())\n      return;\n    const axis = this.getValidAxis();\n    let window2;\n    let shouldRefresh = true;\n    if (axis) {\n      const zoom2 = this.zoomManager.getAxisZoom(axis.id);\n      window2 = this.getAxisWindow(axis, zoom2);\n      shouldRefresh = this.shouldRefresh(axis, zoom2);\n    }\n    this.dirtyZoom = false;\n    this.dirtyDataSource = false;\n    if (!shouldRefresh)\n      return;\n    this.dataService.load({ windowStart: window2?.min, windowEnd: window2?.max });\n  }\n  getValidAxis() {\n    return this.chart.axes.find((axis) => axis.type === \"time\");\n  }\n  shouldRefresh(axis, zoom2) {\n    if (this.dirtyDataSource)\n      return true;\n    if (!this.dirtyZoom)\n      return false;\n    const lastZoom = this.lastAxisZooms.get(axis.id);\n    if (lastZoom && zoom2.min === lastZoom.min && zoom2.max === lastZoom.max) {\n      return false;\n    }\n    this.lastAxisZooms.set(axis.id, zoom2);\n    return true;\n  }\n  getAxisWindow(axis, zoom2) {\n    const domain = axis.scale.getDomain?.();\n    if (!zoom2 || !domain || domain.length === 0 || isNaN(Number(domain[0])))\n      return;\n    const diff2 = Number(domain[1]) - Number(domain[0]);\n    const min = new Date(Number(domain[0]) + diff2 * zoom2.min);\n    const max = new Date(Number(domain[0]) + diff2 * zoom2.max);\n    return { min, max };\n  }\n};\n\n// packages/ag-charts-community/src/chart/update/overlaysProcessor.ts\nvar OverlaysProcessor = class {\n  constructor(chartLike, overlays, dataService, layoutManager, localeManager, animationManager, domManager) {\n    this.chartLike = chartLike;\n    this.overlays = overlays;\n    this.dataService = dataService;\n    this.layoutManager = layoutManager;\n    this.localeManager = localeManager;\n    this.animationManager = animationManager;\n    this.domManager = domManager;\n    this.destroyFns = [];\n    this.overlayElem = this.domManager.addChild(\"canvas-overlay\", \"overlay\");\n    this.overlayElem.role = \"status\";\n    this.overlayElem.ariaAtomic = \"false\";\n    this.overlayElem.ariaLive = \"polite\";\n    this.overlayElem.classList.toggle(DEFAULT_OVERLAY_CLASS);\n    this.destroyFns.push(this.layoutManager.addListener(\"layout:complete\", (e) => this.onLayoutComplete(e)));\n  }\n  destroy() {\n    this.destroyFns.forEach((cb) => cb());\n    this.domManager.removeStyles(\"overlays\");\n    this.domManager.removeChild(\"canvas-overlay\", \"overlay\");\n  }\n  onLayoutComplete({ series: { rect } }) {\n    const isLoading = this.dataService.isLoading();\n    const hasData = this.chartLike.series.some((s) => s.hasData);\n    const anySeriesVisible = this.chartLike.series.some((s) => s.visible);\n    if (this.overlays.darkTheme) {\n      this.overlayElem.classList.add(DEFAULT_OVERLAY_DARK_CLASS);\n    } else {\n      this.overlayElem.classList.remove(DEFAULT_OVERLAY_DARK_CLASS);\n    }\n    this.overlayElem.style.left = `${rect.x}px`;\n    this.overlayElem.style.top = `${rect.y}px`;\n    this.overlayElem.style.width = `${rect.width}px`;\n    this.overlayElem.style.height = `${rect.height}px`;\n    const loadingShown = isLoading;\n    const noDataShown = !isLoading && !hasData;\n    const noVisibleSeriesShown = hasData && !anySeriesVisible;\n    if (loadingShown) {\n      this.showOverlay(this.overlays.loading, rect);\n    } else {\n      this.hideOverlay(this.overlays.loading);\n    }\n    if (noDataShown) {\n      this.showOverlay(this.overlays.noData, rect);\n    } else {\n      this.hideOverlay(this.overlays.noData);\n    }\n    if (noVisibleSeriesShown) {\n      this.showOverlay(this.overlays.noVisibleSeries, rect);\n    } else {\n      this.hideOverlay(this.overlays.noVisibleSeries);\n    }\n    const shown = loadingShown || noDataShown || noVisibleSeriesShown;\n    setAttribute(this.overlayElem, \"aria-hidden\", !shown);\n  }\n  showOverlay(overlay, seriesRect) {\n    const element2 = overlay.getElement(this.animationManager, this.localeManager, seriesRect);\n    this.overlayElem.appendChild(element2);\n  }\n  hideOverlay(overlay) {\n    overlay.removeElement(() => {\n      this.overlayElem.innerText = \"\\xA0\";\n    }, this.animationManager);\n  }\n};\n\n// packages/ag-charts-community/src/chart/chart.ts\nvar debug = Debug.create(true, \"opts\");\nvar SeriesArea = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.padding = new Padding(0);\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], SeriesArea.prototype, \"clip\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], SeriesArea.prototype, \"padding\", 2);\nvar _Chart = class _Chart extends Observable {\n  constructor(options, resources) {\n    var _a;\n    super();\n    this.id = createId(this);\n    this.seriesRoot = new TranslatableGroup({ name: `${this.id}-series-root` });\n    this.highlightRoot = new TranslatableLayer({\n      name: `${this.id}-highlight-root`,\n      zIndex: 5 /* SERIES_HIGHLIGHT */,\n      deriveZIndexFromChildren: true\n      // TODO remove feature\n    });\n    this.annotationRoot = new TranslatableLayer({\n      name: `${this.id}-annotation-root`,\n      zIndex: 10 /* SERIES_ANNOTATION */\n    });\n    this.debug = Debug.create();\n    this.extraDebugStats = {};\n    this.data = [];\n    this._firstAutoSize = true;\n    this.padding = new Padding(20);\n    this.seriesArea = new SeriesArea();\n    this.keyboard = new Keyboard();\n    this.mode = \"standalone\";\n    this.chartCaptions = new ChartCaptions();\n    this.destroyed = false;\n    this._destroyFns = [];\n    // Used to prevent infinite update loops when syncing charts.\n    this.skipSync = false;\n    this.chartAnimationPhase = \"initial\";\n    this.modulesManager = new ModulesManager();\n    this.processors = [];\n    this.queuedUserOptions = [];\n    this._pendingFactoryUpdatesCount = 0;\n    this._performUpdateNoRenderCount = 0;\n    this._performUpdateSkipAnimations = false;\n    this.performUpdateType = 7 /* NONE */;\n    this.updateShortcutCount = 0;\n    this.seriesToUpdate = /* @__PURE__ */ new Set();\n    this.updateMutex = new Mutex();\n    this.updateRequestors = {};\n    this.performUpdateTrigger = debouncedCallback(async ({ count }) => {\n      if (this.destroyed)\n        return;\n      this.updateMutex.acquire(async () => {\n        try {\n          await this.performUpdate(count);\n        } catch (error) {\n          Logger.error(\"update error\", error);\n        }\n      }).catch((e) => Logger.errorOnce(e));\n    });\n    this._performUpdateSplits = {};\n    this.axes = [];\n    this.series = [];\n    this.onSeriesNodeClick = (event) => {\n      this.fireEvent({ ...event, type: \"seriesNodeClick\" });\n    };\n    this.onSeriesNodeDoubleClick = (event) => {\n      this.fireEvent({ ...event, type: \"seriesNodeDoubleClick\" });\n    };\n    this.seriesGroupingChanged = (event) => {\n      if (!(event instanceof SeriesGroupingChangedEvent))\n        return;\n      const { series, seriesGrouping, oldGrouping } = event;\n      if (series.rootGroup.isRoot())\n        return;\n      this.seriesLayerManager.changeGroup({\n        internalId: series.internalId,\n        type: series.type,\n        rootGroup: series.rootGroup,\n        highlightGroup: series.highlightGroup,\n        annotationGroup: series.annotationGroup,\n        getGroupZIndexSubOrder: (type) => series.getGroupZIndexSubOrder(type),\n        seriesGrouping,\n        oldGrouping\n      });\n    };\n    this.chartOptions = options;\n    const scene = resources?.scene;\n    const container = resources?.container ?? options.processedOptions.container ?? void 0;\n    const styleContainer = resources?.styleContainer ?? options.specialOverrides.styleContainer;\n    const root = new Group({ name: \"root\" });\n    const titleGroup = new Layer({ name: \"titles\", zIndex: 14 /* SERIES_LABEL */ });\n    root.visible = false;\n    root.append(titleGroup);\n    root.append(this.seriesRoot);\n    root.append(this.highlightRoot);\n    root.append(this.annotationRoot);\n    titleGroup.append(this.title.node);\n    titleGroup.append(this.subtitle.node);\n    titleGroup.append(this.footnote.node);\n    this.tooltip = new Tooltip();\n    this.seriesLayerManager = new SeriesLayerManager(this.seriesRoot, this.highlightRoot, this.annotationRoot);\n    this.mode = options.userOptions.mode ?? this.mode;\n    const ctx = this.ctx = new ChartContext(this, {\n      scene,\n      root,\n      container,\n      styleContainer,\n      syncManager: new SyncManager(this),\n      pixelRatio: options.specialOverrides.overrideDevicePixelRatio,\n      updateCallback: (type = 0 /* FULL */, opts) => this.update(type, opts),\n      updateMutex: this.updateMutex\n    });\n    this._destroyFns.push(\n      ctx.domManager.addListener(\"resize\", () => this.parentResize(ctx.domManager.containerSize))\n    );\n    this.overlays = new ChartOverlays();\n    (_a = this.overlays.loading).renderer ?? (_a.renderer = () => getLoadingSpinner(this.overlays.loading.getText(ctx.localeManager), ctx.animationManager.defaultDuration));\n    this.processors = [\n      new DataWindowProcessor(this, ctx.dataService, ctx.updateService, ctx.zoomManager),\n      new OverlaysProcessor(\n        this,\n        this.overlays,\n        ctx.dataService,\n        ctx.layoutManager,\n        ctx.localeManager,\n        ctx.animationManager,\n        ctx.domManager\n      )\n    ];\n    this.highlight = new ChartHighlight();\n    this.container = container;\n    const moduleContext = this.getModuleContext();\n    ctx.regionManager.addRegion(\n      \"series\" /* SERIES */,\n      this.seriesRoot,\n      new SimpleRegionBBoxProvider(this.seriesRoot, () => this.seriesRect ?? BBox.zero),\n      this.ctx.axisManager.axisGridGroup\n    );\n    ctx.regionManager.addRegion(\"horizontal-axes\" /* HORIZONTAL_AXES */);\n    ctx.regionManager.addRegion(\"vertical-axes\" /* VERTICAL_AXES */);\n    ctx.regionManager.addRegion(\"root\", root);\n    ctx.domManager.setDataBoolean(\"animating\", false);\n    this.seriesAreaManager = new SeriesAreaManager(this.initSeriesAreaDependencies());\n    this._destroyFns.push(\n      ctx.layoutManager.registerElement(0 /* Caption */, (e) => {\n        e.layoutBox.shrink(this.padding.toJson());\n        this.chartCaptions.positionCaptions(e);\n      }),\n      ctx.layoutManager.addListener(\"layout:complete\", (e) => this.chartCaptions.positionAbsoluteCaptions(e)),\n      ctx.dataService.addListener(\"data-load\", (event) => {\n        this.data = event.data;\n      }),\n      this.title.registerInteraction(moduleContext, \"beforebegin\"),\n      this.subtitle.registerInteraction(moduleContext, \"beforebegin\"),\n      this.footnote.registerInteraction(moduleContext, \"afterend\"),\n      ctx.interactionManager.addListener(\"page-left\", () => this.destroy()),\n      ctx.animationManager.addListener(\"animation-frame\", () => {\n        this.update(6 /* SCENE_RENDER */);\n      }),\n      ctx.animationManager.addListener(\"animation-start\", () => ctx.domManager.setDataBoolean(\"animating\", true)),\n      ctx.animationManager.addListener(\"animation-stop\", () => ctx.domManager.setDataBoolean(\"animating\", false)),\n      ctx.zoomManager.addListener(\"zoom-change\", () => {\n        this.series.forEach((s) => s.animationState?.transition(\"updateData\"));\n        const skipAnimations = this.chartAnimationPhase !== \"initial\";\n        this.update(3 /* PERFORM_LAYOUT */, { forceNodeDataRefresh: true, skipAnimations });\n      })\n    );\n    this.parentResize(ctx.domManager.containerSize);\n  }\n  static getInstance(element2) {\n    return _Chart.chartsInstances.get(element2);\n  }\n  /** NOTE: This is exposed for use by Integrated charts only. */\n  get canvasElement() {\n    return this.ctx.scene.canvas.element;\n  }\n  download(fileName, fileFormat) {\n    this.ctx.scene.download(fileName, fileFormat);\n  }\n  getCanvasDataURL(fileFormat) {\n    return this.ctx.scene.getDataURL(fileFormat);\n  }\n  toSVG() {\n    return this.ctx.scene.toSVG();\n  }\n  getOptions() {\n    return this.queuedUserOptions.at(-1) ?? this.chartOptions.userOptions;\n  }\n  initSeriesAreaDependencies() {\n    const { ctx, tooltip, highlight, overlays, seriesRoot } = this;\n    const chartType2 = this.getChartType();\n    const fireEvent = this.fireEvent.bind(this);\n    const getUpdateType = () => this.performUpdateType;\n    return { fireEvent, getUpdateType, chartType: chartType2, ctx, tooltip, highlight, overlays, seriesRoot };\n  }\n  getModuleContext() {\n    return this.ctx;\n  }\n  getCaptionText() {\n    return [this.title, this.subtitle, this.footnote].filter((caption) => caption.enabled && caption.text).map((caption) => caption.text).join(\". \");\n  }\n  getAriaLabel() {\n    return this.ctx.localeManager.t(\"ariaAnnounceChart\", { seriesCount: this.series.length });\n  }\n  resetAnimations() {\n    this.chartAnimationPhase = \"initial\";\n    for (const series of this.series) {\n      series.resetAnimation(this.chartAnimationPhase);\n    }\n    for (const axis of this.axes) {\n      axis.resetAnimation(this.chartAnimationPhase);\n    }\n    this.animationRect = void 0;\n    this.ctx.animationManager.reset();\n  }\n  skipAnimations() {\n    this.ctx.animationManager.skipCurrentBatch();\n    this._performUpdateSkipAnimations = true;\n  }\n  destroy(opts) {\n    if (this.destroyed) {\n      return;\n    }\n    const keepTransferableResources = opts?.keepTransferableResources;\n    let result;\n    this.performUpdateType = 7 /* NONE */;\n    this._destroyFns.forEach((fn) => fn());\n    this.processors.forEach((p) => p.destroy());\n    this.tooltip.destroy(this.ctx.domManager);\n    this.overlays.destroy();\n    this.modulesManager.destroy();\n    if (keepTransferableResources) {\n      this.ctx.scene.strip();\n      result = {\n        container: this.container,\n        scene: this.ctx.scene\n      };\n    } else {\n      this.ctx.scene.destroy();\n      this.container = void 0;\n    }\n    this.destroySeries(this.series);\n    this.seriesLayerManager.destroy();\n    this.axes.forEach((a) => a.destroy());\n    this.axes = [];\n    this.animationRect = void 0;\n    this.ctx.destroy();\n    this.destroyed = true;\n    Object.freeze(this);\n    return result;\n  }\n  requestFactoryUpdate(cb) {\n    if (this.destroyed)\n      return;\n    this._pendingFactoryUpdatesCount++;\n    this.updateMutex.acquire(async () => {\n      if (this.destroyed)\n        return;\n      await cb(this);\n      if (this.destroyed)\n        return;\n      this._pendingFactoryUpdatesCount--;\n    }).catch((e) => Logger.errorOnce(e));\n  }\n  update(type = 0 /* FULL */, opts) {\n    const {\n      forceNodeDataRefresh = false,\n      skipAnimations,\n      seriesToUpdate = this.series,\n      newAnimationBatch\n    } = opts ?? {};\n    if (forceNodeDataRefresh) {\n      this.series.forEach((series) => series.markNodeDataDirty());\n    }\n    for (const series of seriesToUpdate) {\n      this.seriesToUpdate.add(series);\n    }\n    if (skipAnimations) {\n      this.ctx.animationManager.skipCurrentBatch();\n      this._performUpdateSkipAnimations = true;\n    }\n    if (newAnimationBatch && this.ctx.animationManager.isActive()) {\n      this._performUpdateSkipAnimations = true;\n    }\n    this.skipSync = opts?.skipSync ?? false;\n    if (this.debug.check()) {\n      let stack = new Error().stack ?? \"<unknown>\";\n      stack = stack.replace(/\\([^)]*/g, \"\");\n      this.updateRequestors[stack] = type;\n    }\n    if (type < this.performUpdateType) {\n      this.performUpdateType = type;\n      this.ctx.domManager.setDataBoolean(\"updatePending\", true);\n      this.performUpdateTrigger.schedule(opts?.backOffMs);\n    }\n  }\n  async performUpdate(count) {\n    const { performUpdateType, extraDebugStats, _performUpdateSplits: splits, ctx } = this;\n    const seriesToUpdate = [...this.seriesToUpdate];\n    this.performUpdateType = 7 /* NONE */;\n    this.seriesToUpdate.clear();\n    if (this.updateShortcutCount === 0 && performUpdateType < 6 /* SCENE_RENDER */) {\n      ctx.animationManager.startBatch(this._performUpdateSkipAnimations);\n      ctx.animationManager.onBatchStop(() => this.chartAnimationPhase = \"ready\");\n    }\n    this.debug(\"Chart.performUpdate() - start\", ChartUpdateType[performUpdateType]);\n    let previousSplit = performance.now();\n    splits.start ?? (splits.start = previousSplit);\n    const updateSplits = (splitName) => {\n      splits[splitName] ?? (splits[splitName] = 0);\n      splits[splitName] += performance.now() - previousSplit;\n      previousSplit = performance.now();\n    };\n    let updateDeferred = false;\n    switch (performUpdateType) {\n      case 0 /* FULL */:\n        this.ctx.updateService.dispatchPreDomUpdate();\n        this.updateDOM();\n      case 1 /* UPDATE_DATA */:\n        await this.updateData();\n        updateSplits(\"\\u2B07\\uFE0F\");\n      case 2 /* PROCESS_DATA */:\n        await this.processData();\n        this.seriesAreaManager.dataChanged();\n        updateSplits(\"\\u{1F3ED}\");\n      case 3 /* PERFORM_LAYOUT */:\n        if (this.checkUpdateShortcut(3 /* PERFORM_LAYOUT */))\n          break;\n        if (!this.checkFirstAutoSize(seriesToUpdate)) {\n          updateDeferred = true;\n          break;\n        }\n        await this.processLayout();\n        updateSplits(\"\\u2316\");\n      case 4 /* SERIES_UPDATE */: {\n        if (this.checkUpdateShortcut(4 /* SERIES_UPDATE */))\n          break;\n        const { seriesRect } = this;\n        await Promise.all(seriesToUpdate.map((series) => series.update({ seriesRect })));\n        updateSplits(\"\\u{1F914}\");\n        this.updateAriaLabels();\n      }\n      case 5 /* PRE_SCENE_RENDER */:\n        if (this.checkUpdateShortcut(5 /* PRE_SCENE_RENDER */))\n          break;\n        ctx.updateService.dispatchPreSceneRender(this.getMinRects());\n        updateSplits(\"\\u2196\");\n      case 6 /* SCENE_RENDER */:\n        if (this.checkUpdateShortcut(6 /* SCENE_RENDER */))\n          break;\n        ctx.animationManager.endBatch();\n        extraDebugStats[\"updateShortcutCount\"] = this.updateShortcutCount;\n        await ctx.scene.render({ debugSplitTimes: splits, extraDebugStats, seriesRect: this.seriesRect });\n        this.extraDebugStats = {};\n        for (const key in splits) {\n          delete splits[key];\n        }\n        this.ctx.domManager.incrementDataCounter(\"sceneRenders\");\n      case 7 /* NONE */:\n        this.updateShortcutCount = 0;\n        this.updateRequestors = {};\n        this._performUpdateSkipAnimations = false;\n        ctx.animationManager.endBatch();\n    }\n    if (!updateDeferred) {\n      ctx.updateService.dispatchUpdateComplete(this.getMinRects());\n      this.ctx.domManager.setDataBoolean(\"updatePending\", false);\n    }\n    const end2 = performance.now();\n    this.debug(\"Chart.performUpdate() - end\", {\n      chart: this,\n      durationMs: Math.round((end2 - splits[\"start\"]) * 100) / 100,\n      count,\n      performUpdateType: ChartUpdateType[performUpdateType]\n    });\n  }\n  updateThemeClassName() {\n    const { theme } = this.chartOptions.processedOptions;\n    const themeClassNamePrefix = \"ag-charts-theme-\";\n    const validThemeClassNames = [`${themeClassNamePrefix}default`, `${themeClassNamePrefix}default-dark`];\n    let themeClassName = validThemeClassNames[0];\n    let isDark = false;\n    if (typeof theme === \"string\") {\n      themeClassName = theme.replace(\"ag-\", themeClassNamePrefix);\n      isDark = theme.includes(\"-dark\");\n    } else if (typeof theme?.baseTheme === \"string\") {\n      themeClassName = theme.baseTheme.replace(\"ag-\", themeClassNamePrefix);\n      isDark = theme.baseTheme.includes(\"-dark\");\n    }\n    if (!validThemeClassNames.includes(themeClassName)) {\n      themeClassName = isDark ? validThemeClassNames[1] : validThemeClassNames[0];\n    }\n    this.ctx.domManager.setThemeClass(themeClassName);\n  }\n  updateDOM() {\n    this.updateThemeClassName();\n    const { enabled, tabIndex } = this.keyboard;\n    this.ctx.domManager.setTabIndex(enabled ? tabIndex ?? 0 : -1);\n  }\n  updateAriaLabels() {\n    this.ctx.domManager.updateCanvasLabel(this.getAriaLabel());\n  }\n  checkUpdateShortcut(checkUpdateType) {\n    const maxShortcuts = 3;\n    if (this.updateShortcutCount > maxShortcuts) {\n      Logger.warn(\n        `exceeded the maximum number of simultaneous updates (${maxShortcuts + 1}), discarding changes and rendering`,\n        this.updateRequestors\n      );\n      return false;\n    }\n    if (this.performUpdateType <= checkUpdateType) {\n      this.updateShortcutCount++;\n      return true;\n    }\n    return false;\n  }\n  checkFirstAutoSize(seriesToUpdate) {\n    if (this.width != null && this.height != null) {\n    } else if (!this._lastAutoSize) {\n      const count = this._performUpdateNoRenderCount++;\n      const backOffMs = (count + 1) ** 2 * 40;\n      if (count < 8) {\n        this.update(3 /* PERFORM_LAYOUT */, { seriesToUpdate, backOffMs });\n        this.debug(\"Chart.checkFirstAutoSize() - backing off until first size update\", backOffMs);\n        return false;\n      }\n      this.debug(\"Chart.checkFirstAutoSize() - timeout for first size update.\");\n    }\n    this._performUpdateNoRenderCount = 0;\n    return true;\n  }\n  onAxisChange(newValue, oldValue) {\n    if (oldValue == null && newValue.length === 0)\n      return;\n    this.ctx.axisManager.updateAxes(oldValue ?? [], newValue);\n  }\n  onSeriesChange(newValue, oldValue) {\n    const seriesToDestroy = oldValue?.filter((series) => !newValue.includes(series)) ?? [];\n    this.destroySeries(seriesToDestroy);\n    this.seriesLayerManager?.setSeriesCount(newValue.length);\n    for (const series of newValue) {\n      if (oldValue?.includes(series))\n        continue;\n      if (series.rootGroup.isRoot()) {\n        this.seriesLayerManager.requestGroup(series);\n      }\n      const chart = this;\n      series.chart = {\n        get mode() {\n          return chart.mode;\n        },\n        get isMiniChart() {\n          return false;\n        },\n        get seriesRect() {\n          return chart.seriesRect;\n        },\n        placeLabels(padding) {\n          return chart.placeLabels(padding);\n        }\n      };\n      series.resetAnimation(this.chartAnimationPhase);\n      this.addSeriesListeners(series);\n      series.addChartEventListeners();\n    }\n    this.seriesAreaManager?.seriesChanged(newValue);\n  }\n  destroySeries(allSeries) {\n    allSeries?.forEach((series) => {\n      series.removeEventListener(\"nodeClick\", this.onSeriesNodeClick);\n      series.removeEventListener(\"nodeDoubleClick\", this.onSeriesNodeDoubleClick);\n      series.removeEventListener(\"groupingChanged\", this.seriesGroupingChanged);\n      series.destroy();\n      this.seriesLayerManager.releaseGroup(series);\n      series.chart = void 0;\n    });\n  }\n  addSeriesListeners(series) {\n    if (this.hasEventListener(\"seriesNodeClick\")) {\n      series.addEventListener(\"nodeClick\", this.onSeriesNodeClick);\n    }\n    if (this.hasEventListener(\"seriesNodeDoubleClick\")) {\n      series.addEventListener(\"nodeDoubleClick\", this.onSeriesNodeDoubleClick);\n    }\n    series.addEventListener(\"groupingChanged\", this.seriesGroupingChanged);\n  }\n  assignSeriesToAxes() {\n    for (const axis of this.axes) {\n      axis.boundSeries = this.series.filter((s) => s.axes[axis.direction] === axis);\n    }\n  }\n  assignAxesToSeries() {\n    const directionToAxesMap = groupBy(this.axes, (axis) => axis.direction);\n    this.series.forEach((series) => {\n      series.directions.forEach((direction) => {\n        const directionAxes = directionToAxesMap[direction];\n        if (!directionAxes) {\n          Logger.warnOnce(\n            `no available axis for direction [${direction}]; check series and axes configuration.`\n          );\n          return;\n        }\n        const seriesKeys = series.getKeys(direction);\n        const newAxis = directionAxes.find(\n          (axis) => !axis.keys.length || seriesKeys.some((key) => axis.keys.includes(key))\n        );\n        if (!newAxis) {\n          Logger.warnOnce(\n            `no matching axis for direction [${direction}] and keys [${seriesKeys}]; check series and axes configuration.`\n          );\n          return;\n        }\n        series.axes[direction] = newAxis;\n      });\n    });\n  }\n  parentResize(size) {\n    if (size == null || this.width != null && this.height != null)\n      return;\n    let { width: width2, height: height2 } = size;\n    width2 = Math.floor(width2);\n    height2 = Math.floor(height2);\n    if (width2 === 0 && height2 === 0)\n      return;\n    const [autoWidth = 0, authHeight = 0] = this._lastAutoSize ?? [];\n    if (autoWidth === width2 && authHeight === height2)\n      return;\n    this._lastAutoSize = [width2, height2];\n    this.resize(\"SizeMonitor\", {});\n  }\n  resize(source, opts) {\n    const { scene, animationManager } = this.ctx;\n    const { inWidth, inHeight, inMinWidth, inMinHeight } = opts;\n    this.ctx.domManager.setSizeOptions(\n      inMinWidth ?? this.minWidth,\n      inMinHeight ?? this.minHeight,\n      inWidth ?? this.width,\n      inHeight ?? this.height\n    );\n    const width2 = inWidth ?? this.width ?? this._lastAutoSize?.[0];\n    const height2 = inHeight ?? this.height ?? this._lastAutoSize?.[1];\n    this.debug(`Chart.resize() from ${source}`, { width: width2, height: height2, stack: new Error().stack });\n    if (width2 == null || height2 == null || !isFiniteNumber(width2) || !isFiniteNumber(height2))\n      return;\n    if (scene.resize(width2, height2)) {\n      animationManager.reset();\n      let skipAnimations = true;\n      if ((this.width == null || this.height == null) && this._firstAutoSize) {\n        skipAnimations = false;\n        this._firstAutoSize = false;\n      }\n      this.update(3 /* PERFORM_LAYOUT */, { forceNodeDataRefresh: true, skipAnimations });\n    }\n  }\n  async updateData() {\n    this.series.forEach((s) => s.setChartData(this.data));\n    const modulePromises = this.modulesManager.mapModules((m) => m.updateData?.(this.data));\n    await Promise.all(modulePromises);\n  }\n  async processData() {\n    if (this.series.some((s) => s.canHaveAxes)) {\n      this.assignAxesToSeries();\n      this.assignSeriesToAxes();\n    }\n    const dataController = new DataController(this.mode);\n    const seriesPromises = this.series.map((s) => s.processData(dataController));\n    const modulePromises = this.modulesManager.mapModules((m) => m.processData?.(dataController));\n    dataController.execute();\n    await Promise.all([...seriesPromises, ...modulePromises]);\n    for (const { legendType, legend } of this.modulesManager.legends()) {\n      legend.data = this.getLegendData(legendType, this.mode !== \"integrated\");\n    }\n  }\n  placeLabels(padding) {\n    const visibleSeries = [];\n    const data = [];\n    for (const series of this.series) {\n      if (!series.visible)\n        continue;\n      const labelData = series.getLabelData();\n      if (isPointLabelDatum(labelData?.[0])) {\n        data.push(labelData);\n        visibleSeries.push(series);\n      }\n    }\n    const { seriesRect } = this;\n    const { top, right, bottom, left } = this.seriesArea.padding;\n    const labels = seriesRect && data.length > 0 ? placeLabels(\n      data,\n      {\n        x: -left,\n        y: -top,\n        width: seriesRect.width + left + right,\n        height: seriesRect.height + top + bottom\n      },\n      padding\n    ) : [];\n    return new Map(labels.map((l, i) => [visibleSeries[i], l]));\n  }\n  getLegendData(legendType, warnConflicts) {\n    var _a;\n    const legendData = this.series.filter((s) => s.properties.showInLegend).flatMap((s) => s.getLegendData(legendType));\n    const isCategoryLegendData = (data) => data.every((d) => d.legendType === \"category\");\n    if (warnConflicts && isCategoryLegendData(legendData)) {\n      const seriesMarkerFills = {};\n      const seriesTypeMap = new Map(this.series.map((s) => [s.id, s.type]));\n      for (const {\n        seriesId,\n        symbols: [{ marker }],\n        label\n      } of legendData) {\n        if (marker.fill == null)\n          continue;\n        const seriesType2 = seriesTypeMap.get(seriesId);\n        const markerFill = seriesMarkerFills[seriesType2] ?? (seriesMarkerFills[seriesType2] = {});\n        markerFill[_a = label.text] ?? (markerFill[_a] = marker.fill);\n        if (markerFill[label.text] !== marker.fill) {\n          Logger.warnOnce(\n            `legend item '${label.text}' has multiple fill colors, this may cause unexpected behaviour.`\n          );\n        }\n      }\n    }\n    return legendData;\n  }\n  async processLayout() {\n    const oldRect = this.animationRect;\n    const { width: width2, height: height2 } = this.ctx.scene;\n    const ctx = this.ctx.layoutManager.createContext(width2, height2);\n    await this.performLayout(ctx);\n    if (oldRect && !this.animationRect?.equals(oldRect)) {\n      this.ctx.animationManager.skipCurrentBatch();\n    }\n    this.debug(\"Chart.performUpdate() - seriesRect\", this.seriesRect);\n  }\n  async waitForUpdate(timeoutMs = 1e4, failOnTimeout = false) {\n    const start2 = performance.now();\n    if (this._pendingFactoryUpdatesCount > 0) {\n      await this.updateMutex.waitForClearAcquireQueue();\n    }\n    while (this.performUpdateType !== 7 /* NONE */) {\n      if (performance.now() - start2 > timeoutMs) {\n        const message = `Chart.waitForUpdate() timeout of ${timeoutMs} reached - first chart update taking too long.`;\n        if (failOnTimeout) {\n          throw new Error(message);\n        } else {\n          Logger.warnOnce(message);\n        }\n      }\n      await sleep(50);\n    }\n    await this.updateMutex.waitForClearAcquireQueue();\n  }\n  getMinRects() {\n    const { width: width2, height: height2 } = this.ctx.scene;\n    const minRects = this.series.map((series) => series.getMinRects(width2, height2)).filter(isDefined);\n    if (minRects.length === 0)\n      return;\n    let maxWidth = 0;\n    let maxHeight = 0;\n    let maxVisibleWidth = 0;\n    let maxVisibleHeight = 0;\n    for (const { minRect: minRect2, minVisibleRect: minVisibleRect2 } of minRects) {\n      maxWidth = Math.max(maxWidth, minRect2.width);\n      maxHeight = Math.max(maxHeight, minRect2.height);\n      maxVisibleWidth = Math.max(maxVisibleWidth, minVisibleRect2.width);\n      maxVisibleHeight = Math.max(maxVisibleHeight, minVisibleRect2.height);\n    }\n    const minRect = new BBox(0, 0, maxWidth, maxHeight);\n    let minVisibleRect = minRect.clone();\n    if (maxVisibleWidth > 0 && maxVisibleHeight > 0) {\n      minVisibleRect = new BBox(0, 0, maxVisibleWidth, maxVisibleHeight);\n    }\n    return { minRect, minVisibleRect };\n  }\n  filterMiniChartSeries(series) {\n    return series?.filter((s) => s.showInMiniChart !== false);\n  }\n  applyOptions(newChartOptions) {\n    const isDifferentOpts = newChartOptions !== this.chartOptions;\n    const oldOpts = isDifferentOpts ? this.chartOptions.processedOptions : {};\n    const newOpts = newChartOptions.processedOptions;\n    const deltaOptions = newChartOptions.diffOptions(oldOpts);\n    if (deltaOptions == null)\n      return;\n    debug(\"Chart.applyOptions() - applying delta\", deltaOptions);\n    const modulesChanged = this.applyModules(newOpts);\n    const skip = [\n      \"type\",\n      \"data\",\n      \"series\",\n      \"listeners\",\n      \"preset\",\n      \"theme\",\n      \"legend.listeners\",\n      \"navigator.miniChart.series\",\n      \"navigator.miniChart.label\",\n      \"locale.localeText\",\n      \"axes\",\n      \"topology\",\n      \"nodes\",\n      \"initialState\",\n      \"styleContainer\"\n    ];\n    if (deltaOptions.listeners) {\n      this.registerListeners(this, deltaOptions.listeners);\n    }\n    jsonApply(this, deltaOptions, { skip });\n    let forceNodeDataRefresh = false;\n    let seriesStatus = \"no-op\";\n    if (deltaOptions.series != null) {\n      seriesStatus = this.applySeries(this, deltaOptions.series, oldOpts?.series);\n      forceNodeDataRefresh = true;\n    }\n    if (seriesStatus === \"replaced\") {\n      this.resetAnimations();\n    }\n    if (this.applyAxes(this, newOpts, oldOpts, seriesStatus, [], true)) {\n      forceNodeDataRefresh = true;\n    }\n    if (deltaOptions.data) {\n      this.data = deltaOptions.data;\n    }\n    if (deltaOptions.legend?.listeners && this.modulesManager.isEnabled(\"legend\")) {\n      Object.assign(this.legend.listeners, deltaOptions.legend.listeners);\n    }\n    if (deltaOptions.locale?.localeText) {\n      this.modulesManager.getModule(\"locale\").localeText = deltaOptions.locale?.localeText;\n    }\n    this.chartOptions = newChartOptions;\n    const navigatorModule = this.modulesManager.getModule(\"navigator\");\n    const zoomModule = this.modulesManager.getModule(\"zoom\");\n    if (!navigatorModule?.enabled && !zoomModule?.enabled) {\n      this.ctx.zoomManager.updateZoom(\"chart\");\n    }\n    const miniChart = navigatorModule?.miniChart;\n    const miniChartSeries = newOpts.navigator?.miniChart?.series ?? newOpts.series;\n    if (miniChart?.enabled === true && miniChartSeries != null) {\n      this.applyMiniChartOptions(miniChart, miniChartSeries, newOpts, oldOpts);\n    } else if (miniChart?.enabled === false) {\n      miniChart.series = [];\n      miniChart.axes = [];\n    }\n    this.ctx.annotationManager.setAnnotationStyles(newChartOptions.annotationThemes);\n    forceNodeDataRefresh || (forceNodeDataRefresh = this.shouldForceNodeDataRefresh(deltaOptions, seriesStatus));\n    const majorChange = forceNodeDataRefresh || modulesChanged;\n    const updateType = majorChange ? 0 /* FULL */ : 3 /* PERFORM_LAYOUT */;\n    this.maybeResetAnimations(seriesStatus);\n    debug(\"Chart.applyOptions() - update type\", ChartUpdateType[updateType], {\n      seriesStatus,\n      forceNodeDataRefresh\n    });\n    this.update(updateType, { forceNodeDataRefresh, newAnimationBatch: true });\n    if (deltaOptions.initialState || deltaOptions.theme) {\n      this.applyInitialState(newChartOptions.userOptions.initialState);\n    }\n  }\n  applyInitialState(initialState) {\n    const {\n      ctx: { annotationManager, historyManager, stateManager }\n    } = this;\n    if (initialState?.annotations != null) {\n      const annotations2 = initialState.annotations.map((annotation) => {\n        const annotationTheme = annotationManager.getAnnotationTypeStyles(annotation.type);\n        return mergeDefaults(annotation, annotationTheme);\n      });\n      stateManager.setState(annotationManager, annotations2);\n    }\n    if (initialState != null) {\n      historyManager.clear();\n    }\n  }\n  maybeResetAnimations(seriesStatus) {\n    if (this.mode !== \"standalone\")\n      return;\n    switch (seriesStatus) {\n      case \"series-grouping-change\":\n      case \"replaced\":\n        this.resetAnimations();\n        break;\n      default:\n    }\n  }\n  shouldForceNodeDataRefresh(deltaOptions, seriesStatus) {\n    const seriesDataUpdate = !!deltaOptions.data || seriesStatus === \"data-change\" || seriesStatus === \"replaced\";\n    const legendKeys = legendRegistry.getKeys();\n    const optionsHaveLegend = Object.values(legendKeys).some(\n      (legendKey) => deltaOptions[legendKey] != null\n    );\n    const otherRefreshUpdate = deltaOptions.title != null && deltaOptions.subtitle != null;\n    return seriesDataUpdate || optionsHaveLegend || otherRefreshUpdate;\n  }\n  applyMiniChartOptions(miniChart, miniChartSeries, completeOptions, oldOpts) {\n    const oldSeries = oldOpts?.navigator?.miniChart?.series ?? oldOpts?.series;\n    const miniChartSeriesStatus = this.applySeries(\n      miniChart,\n      this.filterMiniChartSeries(miniChartSeries),\n      this.filterMiniChartSeries(oldSeries)\n    );\n    this.applyAxes(miniChart, completeOptions, oldOpts, miniChartSeriesStatus, [\n      \"axes[].tick\",\n      \"axes[].thickness\",\n      \"axes[].title\",\n      \"axes[].crosshair\",\n      \"axes[].gridLine\",\n      \"axes[].label\"\n    ]);\n    const series = miniChart.series;\n    for (const s of series) {\n      s.properties.id = void 0;\n    }\n    const axes = miniChart.axes;\n    const horizontalAxis = axes.find((axis) => axis.direction === \"x\" /* X */);\n    for (const axis of axes) {\n      axis.gridLine.enabled = false;\n      axis.label.enabled = axis === horizontalAxis;\n      axis.tick.enabled = false;\n      axis.interactionEnabled = false;\n    }\n    if (horizontalAxis != null) {\n      const miniChartOpts = completeOptions.navigator?.miniChart;\n      const labelOptions = miniChartOpts?.label;\n      const intervalOptions = miniChartOpts?.label?.interval;\n      horizontalAxis.line.enabled = false;\n      horizontalAxis.label.set(\n        without(labelOptions, [\"interval\", \"rotation\", \"minSpacing\", \"autoRotate\", \"autoRotateAngle\"])\n      );\n      horizontalAxis.tick.set(\n        without(intervalOptions, [\"enabled\", \"width\", \"size\", \"color\", \"interval\", \"step\"])\n      );\n      const step = intervalOptions?.step;\n      if (step != null) {\n        horizontalAxis.interval.step = step;\n      }\n    }\n  }\n  applyModules(options) {\n    const { type: chartType2 } = this.constructor;\n    let modulesChanged = false;\n    for (const module of moduleRegistry.byType(\"root\", \"legend\")) {\n      const isConfigured = options[module.optionsKey] != null;\n      const shouldBeEnabled = isConfigured && module.chartTypes.includes(chartType2);\n      if (shouldBeEnabled === this.modulesManager.isEnabled(module))\n        continue;\n      if (shouldBeEnabled) {\n        this.modulesManager.addModule(module, (m) => m.moduleFactory(this.getModuleContext()));\n        if (module.type === \"legend\") {\n          this.modulesManager.getModule(module)?.attachLegend(this.ctx.scene);\n        }\n        this[module.optionsKey] = this.modulesManager.getModule(module);\n      } else {\n        this.modulesManager.removeModule(module);\n        delete this[module.optionsKey];\n      }\n      modulesChanged = true;\n    }\n    return modulesChanged;\n  }\n  initSeriesDeclarationOrder(series) {\n    for (let idx = 0; idx < series.length; idx++) {\n      series[idx]._declarationOrder = idx;\n    }\n  }\n  applySeries(chart, optSeries, oldOptSeries) {\n    if (!optSeries) {\n      return \"no-change\";\n    }\n    const matchResult = matchSeriesOptions(chart.series, optSeries, oldOptSeries);\n    if (matchResult.status === \"no-overlap\") {\n      debug(`Chart.applySeries() - creating new series instances, status: ${matchResult.status}`, matchResult);\n      chart.series = optSeries.map((opts) => this.createSeries(opts));\n      this.initSeriesDeclarationOrder(chart.series);\n      return \"replaced\";\n    }\n    debug(`Chart.applySeries() - matchResult`, matchResult);\n    const seriesInstances = [];\n    let dataChanged = false;\n    let groupingChanged = false;\n    let isUpdated = false;\n    for (const change of matchResult.changes) {\n      groupingChanged || (groupingChanged = change.status === \"series-grouping\");\n      dataChanged || (dataChanged = change.diff?.data != null);\n      isUpdated || (isUpdated = change.status !== \"no-op\");\n      switch (change.status) {\n        case \"add\": {\n          const newSeries = this.createSeries(change.opts);\n          seriesInstances.push(newSeries);\n          debug(`Chart.applySeries() - created new series`, newSeries);\n          break;\n        }\n        case \"remove\":\n          debug(`Chart.applySeries() - removing series at previous idx ${change.idx}`, change.series);\n          break;\n        case \"no-op\":\n          seriesInstances.push(change.series);\n          debug(`Chart.applySeries() - no change to series at previous idx ${change.idx}`, change.series);\n          break;\n        case \"series-grouping\":\n        case \"update\":\n        default: {\n          const { series, diff: diff2, idx } = change;\n          debug(`Chart.applySeries() - applying series diff previous idx ${idx}`, diff2, series);\n          this.applySeriesValues(series, diff2);\n          series.markNodeDataDirty();\n          seriesInstances.push(series);\n        }\n      }\n    }\n    this.initSeriesDeclarationOrder(seriesInstances);\n    debug(`Chart.applySeries() - final series instances`, seriesInstances);\n    chart.series = seriesInstances;\n    if (groupingChanged) {\n      return \"series-grouping-change\";\n    }\n    if (dataChanged) {\n      return \"data-change\";\n    }\n    return isUpdated ? \"updated\" : \"no-op\";\n  }\n  applyAxes(chart, options, oldOpts, seriesStatus, skip = [], registerRegions = false) {\n    if (!(\"axes\" in options) || !options.axes) {\n      return false;\n    }\n    skip = [\"axes[].type\", ...skip];\n    const { axes } = options;\n    const forceRecreate = seriesStatus === \"replaced\";\n    const matchingTypes = !forceRecreate && chart.axes.length === axes.length && chart.axes.every((a, i) => a.type === axes[i].type);\n    if (matchingTypes && isAgCartesianChartOptions(oldOpts)) {\n      chart.axes.forEach((axis, index) => {\n        const previousOpts = oldOpts.axes?.[index] ?? {};\n        const axisDiff = jsonDiff(previousOpts, axes[index]);\n        debug(`Chart.applyAxes() - applying axis diff idx ${index}`, axisDiff);\n        const path = `axes[${index}]`;\n        jsonApply(axis, axisDiff, { path, skip });\n      });\n      return true;\n    }\n    debug(`Chart.applyAxes() - creating new axes instances; seriesStatus: ${seriesStatus}`);\n    chart.axes = this.createAxis(axes, skip);\n    const axisGroups = {\n      [\"x\" /* X */]: [],\n      [\"y\" /* Y */]: []\n    };\n    chart.axes.forEach((axis) => {\n      const { id } = axis;\n      const node = axis.getRegionNode();\n      if (node != null) {\n        axisGroups[axis.direction].push({ id, node });\n      }\n    });\n    if (registerRegions) {\n      this.ctx.regionManager.updateRegion(\"horizontal-axes\" /* HORIZONTAL_AXES */, ...axisGroups[\"x\" /* X */]);\n      this.ctx.regionManager.updateRegion(\"vertical-axes\" /* VERTICAL_AXES */, ...axisGroups[\"y\" /* Y */]);\n    }\n    return true;\n  }\n  createSeries(seriesOptions) {\n    const seriesInstance = seriesRegistry.create(seriesOptions.type, this.getModuleContext());\n    this.applySeriesOptionModules(seriesInstance, seriesOptions);\n    this.applySeriesValues(seriesInstance, seriesOptions);\n    return seriesInstance;\n  }\n  applySeriesOptionModules(series, options) {\n    const moduleContext = series.createModuleContext();\n    const moduleMap = series.getModuleMap();\n    for (const module of moduleRegistry.byType(\"series-option\")) {\n      if (module.optionsKey in options && module.seriesTypes.includes(series.type)) {\n        moduleMap.addModule(module, (m) => m.moduleFactory(moduleContext));\n      }\n    }\n  }\n  applySeriesValues(target, options) {\n    const moduleMap = target.getModuleMap();\n    const { type: _, data, listeners, seriesGrouping, showInMiniChart: __, ...seriesOptions } = options;\n    for (const moduleDef of EXPECTED_ENTERPRISE_MODULES) {\n      if (moduleDef.type !== \"series-option\")\n        continue;\n      if (moduleDef.optionsKey in seriesOptions) {\n        const module = moduleMap.getModule(moduleDef.optionsKey);\n        if (module) {\n          const moduleOptions = seriesOptions[moduleDef.optionsKey];\n          delete seriesOptions[moduleDef.optionsKey];\n          module.properties.set(moduleOptions);\n        }\n      }\n    }\n    target.properties.set(seriesOptions);\n    if (\"data\" in options) {\n      target.setOptionsData(data);\n    }\n    if (listeners) {\n      this.registerListeners(target, listeners);\n    }\n    if (\"seriesGrouping\" in options) {\n      if (seriesGrouping == null) {\n        target.seriesGrouping = void 0;\n      } else {\n        target.seriesGrouping = { ...target.seriesGrouping, ...seriesGrouping };\n      }\n    }\n  }\n  createAxis(options, skip) {\n    const newAxes = [];\n    const moduleContext = this.getModuleContext();\n    for (let index = 0; index < options.length; index++) {\n      const axisOptions = options[index];\n      const axis = axisRegistry.create(axisOptions.type, moduleContext);\n      this.applyAxisModules(axis, axisOptions);\n      jsonApply(axis, axisOptions, { path: `axes[${index}]`, skip });\n      newAxes.push(axis);\n    }\n    guessInvalidPositions(newAxes);\n    return newAxes;\n  }\n  applyAxisModules(axis, options) {\n    const moduleContext = axis.createModuleContext();\n    const moduleMap = axis.getModuleMap();\n    for (const module of moduleRegistry.byType(\"axis-option\")) {\n      const shouldBeEnabled = options[module.optionsKey] != null;\n      if (shouldBeEnabled === moduleMap.isEnabled(module))\n        continue;\n      if (shouldBeEnabled) {\n        moduleMap.addModule(module, (m) => m.moduleFactory(moduleContext));\n        axis[module.optionsKey] = moduleMap.getModule(module);\n      } else {\n        moduleMap.removeModule(module);\n        delete axis[module.optionsKey];\n      }\n    }\n  }\n  registerListeners(source, listeners) {\n    source.clearEventListeners();\n    for (const [property, listener] of Object.entries(listeners)) {\n      if (isFunction(listener)) {\n        source.addEventListener(property, listener);\n      }\n    }\n  }\n};\n_Chart.chartsInstances = /* @__PURE__ */ new WeakMap();\n__decorateClass([\n  ActionOnSet({\n    newValue(value) {\n      if (this.destroyed)\n        return;\n      this.ctx.domManager.setContainer(value);\n      _Chart.chartsInstances.set(value, this);\n    },\n    oldValue(value) {\n      _Chart.chartsInstances.delete(value);\n    }\n  })\n], _Chart.prototype, \"container\", 2);\n__decorateClass([\n  ActionOnSet({\n    newValue(value) {\n      this.resize(\"width option\", { inWidth: value });\n    }\n  })\n], _Chart.prototype, \"width\", 2);\n__decorateClass([\n  ActionOnSet({\n    newValue(value) {\n      this.resize(\"height option\", { inHeight: value });\n    }\n  })\n], _Chart.prototype, \"height\", 2);\n__decorateClass([\n  ActionOnSet({\n    newValue(value) {\n      this.resize(\"minWidth option\", { inMinWidth: value });\n    }\n  })\n], _Chart.prototype, \"minWidth\", 2);\n__decorateClass([\n  ActionOnSet({\n    newValue(value) {\n      this.resize(\"minHeight option\", { inMinHeight: value });\n    }\n  })\n], _Chart.prototype, \"minHeight\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], _Chart.prototype, \"padding\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], _Chart.prototype, \"seriesArea\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], _Chart.prototype, \"keyboard\", 2);\n__decorateClass([\n  Validate(UNION([\"standalone\", \"integrated\"], \"a chart mode\"))\n], _Chart.prototype, \"mode\", 2);\n__decorateClass([\n  ProxyProperty(\"chartCaptions.title\")\n], _Chart.prototype, \"title\", 2);\n__decorateClass([\n  ProxyProperty(\"chartCaptions.subtitle\")\n], _Chart.prototype, \"subtitle\", 2);\n__decorateClass([\n  ProxyProperty(\"chartCaptions.footnote\")\n], _Chart.prototype, \"footnote\", 2);\n__decorateClass([\n  ActionOnSet({\n    changeValue(newValue, oldValue) {\n      this.onAxisChange(newValue, oldValue);\n    }\n  })\n], _Chart.prototype, \"axes\", 2);\n__decorateClass([\n  ActionOnSet({\n    changeValue(newValue, oldValue) {\n      this.onSeriesChange(newValue, oldValue);\n    }\n  })\n], _Chart.prototype, \"series\", 2);\nvar Chart = _Chart;\n\n// packages/ag-charts-community/src/scene/util/quadtree.ts\nvar QuadtreeNearest = class {\n  constructor(capacity, maxdepth, boundary) {\n    this.root = new QuadtreeNodeNearest(capacity, maxdepth, boundary);\n  }\n  clear(boundary) {\n    this.root.clear(boundary);\n  }\n  addValue(hitTester, value) {\n    const elem = {\n      hitTester,\n      value,\n      distanceSquared: (x, y) => {\n        return hitTester.distanceSquared(x, y);\n      }\n    };\n    this.root.addElem(elem);\n  }\n  find(x, y) {\n    const arg = { best: { nearest: void 0, distanceSquared: Infinity } };\n    this.root.find(x, y, arg);\n    return arg.best;\n  }\n};\nvar QuadtreeSubdivisions = class {\n  constructor(nw, ne, sw, se) {\n    this.nw = nw;\n    this.ne = ne;\n    this.sw = sw;\n    this.se = se;\n  }\n  addElem(elem) {\n    this.nw.addElem(elem);\n    this.ne.addElem(elem);\n    this.sw.addElem(elem);\n    this.se.addElem(elem);\n  }\n  find(x, y, arg) {\n    this.nw.find(x, y, arg);\n    this.ne.find(x, y, arg);\n    this.sw.find(x, y, arg);\n    this.se.find(x, y, arg);\n  }\n};\nvar QuadtreeNode = class {\n  constructor(capacity, maxdepth, boundary) {\n    this.capacity = capacity;\n    this.maxdepth = maxdepth;\n    this.boundary = boundary ?? BBox.NaN;\n    this.elems = [];\n    this.subdivisions = void 0;\n  }\n  clear(boundary) {\n    this.elems.length = 0;\n    this.boundary = boundary;\n    this.subdivisions = void 0;\n  }\n  addElem(e) {\n    if (this.addCondition(e)) {\n      if (this.subdivisions === void 0) {\n        if (this.maxdepth === 0 || this.elems.length < this.capacity) {\n          this.elems.push(e);\n        } else {\n          this.subdivide(e);\n        }\n      } else {\n        this.subdivisions.addElem(e);\n      }\n    }\n  }\n  find(x, y, arg) {\n    if (this.findCondition(x, y, arg)) {\n      if (this.subdivisions === void 0) {\n        this.findAction(x, y, arg);\n      } else {\n        this.subdivisions.find(x, y, arg);\n      }\n    }\n  }\n  subdivide(newElem) {\n    this.subdivisions = this.makeSubdivisions();\n    for (const e of this.elems) {\n      this.subdivisions.addElem(e);\n    }\n    this.subdivisions.addElem(newElem);\n    this.elems.length = 0;\n  }\n  makeSubdivisions() {\n    const { x, y, width: width2, height: height2 } = this.boundary;\n    const { capacity } = this;\n    const depth = this.maxdepth - 1;\n    const halfWidth = width2 / 2;\n    const halfHeight = height2 / 2;\n    const nwBoundary = new BBox(x, y, halfWidth, halfHeight);\n    const neBoundary = new BBox(x + halfWidth, y, halfWidth, halfHeight);\n    const swBoundary = new BBox(x, y + halfHeight, halfWidth, halfHeight);\n    const seBoundary = new BBox(x + halfWidth, y + halfHeight, halfWidth, halfHeight);\n    return new QuadtreeSubdivisions(\n      this.child(capacity, depth, nwBoundary),\n      this.child(capacity, depth, neBoundary),\n      this.child(capacity, depth, swBoundary),\n      this.child(capacity, depth, seBoundary)\n    );\n  }\n};\nvar QuadtreeNodeNearest = class _QuadtreeNodeNearest extends QuadtreeNode {\n  addCondition(e) {\n    const { x, y } = e.hitTester.midPoint;\n    return this.boundary.containsPoint(x, y);\n  }\n  findCondition(x, y, arg) {\n    const { best } = arg;\n    return best.distanceSquared !== 0 && this.boundary.distanceSquared(x, y) < best.distanceSquared;\n  }\n  findAction(x, y, arg) {\n    const other = nearestSquared(x, y, this.elems, arg.best.distanceSquared);\n    if (other.nearest !== void 0 && other.distanceSquared < arg.best.distanceSquared) {\n      arg.best = other;\n    }\n  }\n  child(capacity, depth, boundary) {\n    return new _QuadtreeNodeNearest(capacity, depth, boundary);\n  }\n};\n\n// packages/ag-charts-community/src/chart/marker/marker.ts\nvar BUILTIN_MARKERS = [\n  \"ArrowDown\",\n  \"ArrowUp\",\n  \"Circle\",\n  \"Cross\",\n  \"Diamond\",\n  \"Heart\",\n  \"MapPin\",\n  \"Plus\",\n  \"Square\",\n  \"Star\",\n  \"Triangle\"\n];\nvar DEFAULT_CENTER_POINT = Object.freeze({ x: 0.5, y: 0.5 });\nvar InternalMarker = class extends Path {\n  constructor() {\n    super(...arguments);\n    this.x = 0;\n    this.y = 0;\n    this.size = 12;\n  }\n  isBuiltIn() {\n    return BUILTIN_MARKERS.includes(this.constructor.className ?? \"\");\n  }\n  computeBBox() {\n    if (!this.isBuiltIn()) {\n      return this.path.computeBBox();\n    }\n    const { x, y, size } = this;\n    const { center: center2 } = this.constructor;\n    return new BBox(x - size * center2.x, y - size * center2.y, size, size);\n  }\n  applyPath(s, moves) {\n    const { path } = this;\n    let { x, y } = this;\n    path.clear();\n    for (const { x: mx, y: my, t } of moves) {\n      x += mx * s;\n      y += my * s;\n      if (t === \"move\") {\n        path.moveTo(x, y);\n      } else {\n        path.lineTo(x, y);\n      }\n    }\n    path.closePath();\n  }\n  executeFill(ctx, path) {\n    if (!path)\n      return;\n    return super.executeFill(ctx, path);\n  }\n  executeStroke(ctx, path) {\n    if (!path)\n      return;\n    return super.executeStroke(ctx, path);\n  }\n};\n__decorateClass([\n  ScenePathChangeDetection()\n], InternalMarker.prototype, \"x\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], InternalMarker.prototype, \"y\", 2);\n__decorateClass([\n  ScenePathChangeDetection({ convertor: Math.abs })\n], InternalMarker.prototype, \"size\", 2);\nvar Marker = class extends Rotatable(Scalable(Translatable(InternalMarker))) {\n};\nMarker.center = DEFAULT_CENTER_POINT;\n\n// packages/ag-charts-community/src/chart/marker/circle.ts\nvar Circle = class extends Marker {\n  updatePath() {\n    const { x, y, path, size } = this;\n    const r = size / 2;\n    path.clear();\n    path.arc(x, y, r, 0, Math.PI * 2);\n    path.closePath();\n  }\n};\nCircle.className = \"Circle\";\n\n// packages/ag-charts-community/src/chart/marker/cross.ts\nvar _Cross = class _Cross extends Marker {\n  updatePath() {\n    const s = this.size / 4.2;\n    super.applyPath(s, _Cross.moves);\n  }\n};\n_Cross.className = \"Cross\";\n_Cross.moves = [\n  { x: -1, y: 0, t: \"move\" },\n  { x: -1, y: -1 },\n  { x: 1, y: -1 },\n  { x: 1, y: 1 },\n  { x: 1, y: -1 },\n  { x: 1, y: 1 },\n  { x: -1, y: 1 },\n  { x: 1, y: 1 },\n  { x: -1, y: 1 },\n  { x: -1, y: -1 },\n  { x: -1, y: 1 },\n  { x: -1, y: -1 }\n];\nvar Cross = _Cross;\n\n// packages/ag-charts-community/src/chart/marker/diamond.ts\nvar _Diamond = class _Diamond extends Marker {\n  updatePath() {\n    const s = this.size / 2;\n    super.applyPath(s, _Diamond.moves);\n  }\n};\n_Diamond.className = \"Diamond\";\n_Diamond.moves = [\n  { x: 0, y: -1, t: \"move\" },\n  { x: 1, y: 1 },\n  { x: -1, y: 1 },\n  { x: -1, y: -1 },\n  { x: 1, y: -1 }\n];\nvar Diamond = _Diamond;\n\n// packages/ag-charts-community/src/chart/marker/heart.ts\nvar Heart = class extends Marker {\n  rad(degree2) {\n    return degree2 / 180 * Math.PI;\n  }\n  updatePath() {\n    const { x, path, size, rad } = this;\n    const r = size / 4;\n    const y = this.y + r / 2;\n    path.clear();\n    path.arc(x - r, y - r, r, rad(130), rad(330));\n    path.arc(x + r, y - r, r, rad(220), rad(50));\n    path.lineTo(x, y + r);\n    path.closePath();\n  }\n};\nHeart.className = \"Heart\";\n\n// packages/ag-charts-community/src/chart/marker/pin.ts\nvar Pin = class extends Marker {\n  updatePath() {\n    const { path, x, y } = this;\n    const s = this.size;\n    const cx = 0.5;\n    const cy = 1;\n    path.clear();\n    path.moveTo(x + (0.15625 - cx) * s, y + (0.34375 - cy) * s);\n    path.cubicCurveTo(\n      x + (0.15625 - cx) * s,\n      y + (0.151491 - cy) * s,\n      x + (0.307741 - cx) * s,\n      y + (0 - cy) * s,\n      x + (0.5 - cx) * s,\n      y + (0 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.692259 - cx) * s,\n      y + (0 - cy) * s,\n      x + (0.84375 - cx) * s,\n      y + (0.151491 - cy) * s,\n      x + (0.84375 - cx) * s,\n      y + (0.34375 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.84375 - cx) * s,\n      y + (0.493824 - cy) * s,\n      x + (0.784625 - cx) * s,\n      y + (0.600181 - cy) * s,\n      x + (0.716461 - cx) * s,\n      y + (0.695393 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.699009 - cx) * s,\n      y + (0.719769 - cy) * s,\n      x + (0.681271 - cx) * s,\n      y + (0.743104 - cy) * s,\n      x + (0.663785 - cx) * s,\n      y + (0.766105 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.611893 - cx) * s,\n      y + (0.834367 - cy) * s,\n      x + (0.562228 - cx) * s,\n      y + (0.899699 - cy) * s,\n      x + (0.528896 - cx) * s,\n      y + (0.980648 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.524075 - cx) * s,\n      y + (0.992358 - cy) * s,\n      x + (0.512663 - cx) * s,\n      y + (1 - cy) * s,\n      x + (0.5 - cx) * s,\n      y + (1 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.487337 - cx) * s,\n      y + (1 - cy) * s,\n      x + (0.475925 - cx) * s,\n      y + (0.992358 - cy) * s,\n      x + (0.471104 - cx) * s,\n      y + (0.980648 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.487337 - cx) * s,\n      y + (1 - cy) * s,\n      x + (0.475925 - cx) * s,\n      y + (0.992358 - cy) * s,\n      x + (0.471104 - cx) * s,\n      y + (0.980648 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.437772 - cx) * s,\n      y + (0.899699 - cy) * s,\n      x + (0.388107 - cx) * s,\n      y + (0.834367 - cy) * s,\n      x + (0.336215 - cx) * s,\n      y + (0.766105 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.318729 - cx) * s,\n      y + (0.743104 - cy) * s,\n      x + (0.300991 - cx) * s,\n      y + (0.719769 - cy) * s,\n      x + (0.283539 - cx) * s,\n      y + (0.695393 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.215375 - cx) * s,\n      y + (0.600181 - cy) * s,\n      x + (0.15625 - cx) * s,\n      y + (0.493824 - cy) * s,\n      x + (0.15625 - cx) * s,\n      y + (0.34375 - cy) * s\n    );\n    path.closePath();\n  }\n};\nPin.className = \"MapPin\";\nPin.center = { x: 0.5, y: 1 };\n\n// packages/ag-charts-community/src/chart/marker/plus.ts\nvar _Plus = class _Plus extends Marker {\n  updatePath() {\n    const s = this.size / 3;\n    super.applyPath(s, _Plus.moves);\n  }\n};\n_Plus.className = \"Plus\";\n_Plus.moves = [\n  { x: -0.5, y: -0.5, t: \"move\" },\n  { x: 0, y: -1 },\n  { x: 1, y: 0 },\n  { x: 0, y: 1 },\n  { x: 1, y: 0 },\n  { x: 0, y: 1 },\n  { x: -1, y: 0 },\n  { x: 0, y: 1 },\n  { x: -1, y: 0 },\n  { x: 0, y: -1 },\n  { x: -1, y: 0 },\n  { x: 0, y: -1 }\n];\nvar Plus = _Plus;\n\n// packages/ag-charts-community/src/chart/marker/square.ts\nvar Square = class extends Marker {\n  updatePath() {\n    const { path, x, y } = this;\n    const hs = this.size / 2;\n    path.clear();\n    path.moveTo(this.align(x - hs), this.align(y - hs));\n    path.lineTo(this.align(x + hs), this.align(y - hs));\n    path.lineTo(this.align(x + hs), this.align(y + hs));\n    path.lineTo(this.align(x - hs), this.align(y + hs));\n    path.closePath();\n  }\n};\nSquare.className = \"Square\";\n\n// packages/ag-charts-community/src/chart/marker/star.ts\nvar Star = class extends Marker {\n  updatePath() {\n    const { x, y, path, size } = this;\n    const spikes = 5;\n    const innerRadius = size / 2;\n    const rotation = Math.PI / 2;\n    path.clear();\n    for (let i = 0; i < spikes * 2; i++) {\n      const radius = i % 2 === 0 ? size : innerRadius;\n      const angle2 = i * Math.PI / spikes - rotation;\n      const xCoordinate = x + Math.cos(angle2) * radius;\n      const yCoordinate = y + Math.sin(angle2) * radius;\n      path.lineTo(xCoordinate, yCoordinate);\n    }\n    path.closePath();\n  }\n};\nStar.className = \"Star\";\n\n// packages/ag-charts-community/src/chart/marker/triangle.ts\nvar _Triangle = class _Triangle extends Marker {\n  updatePath() {\n    const s = this.size * 1.1;\n    super.applyPath(s, _Triangle.moves);\n  }\n};\n_Triangle.className = \"Triangle\";\n_Triangle.moves = [\n  { x: 0, y: -0.48, t: \"move\" },\n  { x: 0.5, y: 0.87 },\n  { x: -1, y: 0 }\n];\nvar Triangle = _Triangle;\n\n// packages/ag-charts-community/src/chart/marker/util.ts\nvar MARKER_SHAPES = {\n  circle: Circle,\n  cross: Cross,\n  diamond: Diamond,\n  heart: Heart,\n  pin: Pin,\n  plus: Plus,\n  square: Square,\n  star: Star,\n  triangle: Triangle\n};\nvar MARKER_SUPPORTED_SHAPES = Object.keys(MARKER_SHAPES);\nfunction isMarkerShape(shape) {\n  return typeof shape === \"string\" && MARKER_SUPPORTED_SHAPES.includes(shape);\n}\nfunction getMarker(shape = Square) {\n  if (isMarkerShape(shape)) {\n    return MARKER_SHAPES[shape];\n  }\n  if (typeof shape === \"function\") {\n    return shape;\n  }\n  return Square;\n}\n\n// packages/ag-charts-community/src/chart/series/dataModelSeries.ts\nvar DataModelSeries = class extends Series {\n  constructor() {\n    super(...arguments);\n    this.showFocusBox = true;\n  }\n  getScaleInformation({\n    xScale,\n    yScale\n  }) {\n    const isContinuousX = ContinuousScale.is(xScale);\n    const isContinuousY = ContinuousScale.is(yScale);\n    return { isContinuousX, isContinuousY, xScaleType: xScale?.type, yScaleType: yScale?.type };\n  }\n  getModulePropertyDefinitions() {\n    const xScale = this.axes[\"x\" /* X */]?.scale;\n    const yScale = this.axes[\"y\" /* Y */]?.scale;\n    return this.moduleMap.mapModules((mod2) => mod2.getPropertyDefinitions(this.getScaleInformation({ xScale, yScale }))).flat();\n  }\n  // Request data, but with message dispatching to series-options (modules).\n  async requestDataModel(dataController, data, opts) {\n    opts.props.push(...this.getModulePropertyDefinitions());\n    const { dataModel, processedData } = await dataController.request(this.id, data ?? [], opts);\n    this.dataModel = dataModel;\n    this.processedData = processedData;\n    this.dispatch(\"data-processed\", { dataModel, processedData });\n    return { dataModel, processedData };\n  }\n  isProcessedDataAnimatable() {\n    const validationResults = this.processedData?.reduced?.animationValidation;\n    if (!validationResults) {\n      return true;\n    }\n    const { orderedKeys, uniqueKeys } = validationResults;\n    return orderedKeys && uniqueKeys;\n  }\n  checkProcessedDataAnimatable() {\n    if (!this.isProcessedDataAnimatable()) {\n      this.ctx.animationManager.skipCurrentBatch();\n    }\n  }\n  pickFocus(opts) {\n    const nodeData = this.getNodeData();\n    if (nodeData === void 0 || nodeData.length === 0) {\n      return;\n    }\n    const datumIndex = this.computeFocusDatumIndex(opts, nodeData);\n    if (datumIndex === void 0) {\n      return;\n    }\n    const { showFocusBox } = this;\n    const datum = nodeData[datumIndex];\n    const derivedOpts = { ...opts, datumIndex };\n    const bounds = this.computeFocusBounds(derivedOpts);\n    if (bounds !== void 0) {\n      return { bounds, showFocusBox, datum, datumIndex };\n    }\n  }\n  computeFocusDatumIndex(opts, nodeData) {\n    const isDatumEnabled = (datumIndex2) => {\n      const { missing = false, enabled = true, focusable = true } = nodeData[datumIndex2];\n      return !missing && enabled && focusable;\n    };\n    const searchBackward = (datumIndex2) => {\n      while (datumIndex2 >= 0 && !isDatumEnabled(datumIndex2)) {\n        datumIndex2--;\n      }\n      return datumIndex2 === -1 ? void 0 : datumIndex2;\n    };\n    const searchForward = (datumIndex2) => {\n      while (datumIndex2 < nodeData.length && !isDatumEnabled(datumIndex2)) {\n        datumIndex2++;\n      }\n      return datumIndex2 === nodeData.length ? void 0 : datumIndex2;\n    };\n    let datumIndex;\n    const clampedIndex = clamp(0, opts.datumIndex, nodeData.length - 1);\n    if (opts.datumIndexDelta < 0) {\n      datumIndex = searchBackward(clampedIndex);\n    } else if (opts.datumIndexDelta > 0) {\n      datumIndex = searchForward(clampedIndex);\n    } else {\n      datumIndex = searchForward(clampedIndex) ?? searchBackward(clampedIndex);\n    }\n    if (datumIndex === void 0) {\n      if (opts.datumIndexDelta === 0) {\n        return;\n      } else {\n        return opts.datumIndex - opts.datumIndexDelta;\n      }\n    } else {\n      return datumIndex;\n    }\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/seriesProperties.ts\nvar SeriesItemHighlightStyle = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.fill = \"rgba(255,255,255, 0.33)\";\n    this.stroke = `rgba(0, 0, 0, 0.4)`;\n    this.strokeWidth = 2;\n  }\n};\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], SeriesItemHighlightStyle.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], SeriesItemHighlightStyle.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], SeriesItemHighlightStyle.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], SeriesItemHighlightStyle.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], SeriesItemHighlightStyle.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH, { optional: true })\n], SeriesItemHighlightStyle.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], SeriesItemHighlightStyle.prototype, \"lineDashOffset\", 2);\nvar SeriesHighlightStyle = class extends BaseProperties {\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], SeriesHighlightStyle.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], SeriesHighlightStyle.prototype, \"dimOpacity\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], SeriesHighlightStyle.prototype, \"enabled\", 2);\nvar TextHighlightStyle = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.color = \"black\";\n  }\n};\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], TextHighlightStyle.prototype, \"color\", 2);\nvar HighlightProperties = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], HighlightProperties.prototype, \"enabled\", 2);\nvar HighlightStyle = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.item = new SeriesItemHighlightStyle();\n    this.series = new SeriesHighlightStyle();\n    this.text = new TextHighlightStyle();\n  }\n};\n__decorateClass([\n  Validate(OBJECT)\n], HighlightStyle.prototype, \"item\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], HighlightStyle.prototype, \"series\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], HighlightStyle.prototype, \"text\", 2);\nvar SeriesProperties = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.visible = true;\n    this.focusPriority = Infinity;\n    this.showInLegend = true;\n    this.cursor = \"default\";\n    this.nodeClickRange = \"exact\";\n    this.highlight = new HighlightProperties();\n    this.highlightStyle = new HighlightStyle();\n  }\n};\n__decorateClass([\n  Validate(STRING, { optional: true })\n], SeriesProperties.prototype, \"id\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], SeriesProperties.prototype, \"visible\", 2);\n__decorateClass([\n  Validate(REAL_NUMBER, { optional: true })\n], SeriesProperties.prototype, \"focusPriority\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], SeriesProperties.prototype, \"showInLegend\", 2);\n__decorateClass([\n  Validate(STRING)\n], SeriesProperties.prototype, \"cursor\", 2);\n__decorateClass([\n  Validate(INTERACTION_RANGE)\n], SeriesProperties.prototype, \"nodeClickRange\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], SeriesProperties.prototype, \"highlight\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], SeriesProperties.prototype, \"highlightStyle\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/cartesianSeries.ts\nvar DEFAULT_CARTESIAN_DIRECTION_KEYS = {\n  [\"x\" /* X */]: [\"xKey\"],\n  [\"y\" /* Y */]: [\"yKey\"]\n};\nvar DEFAULT_CARTESIAN_DIRECTION_NAMES = {\n  [\"x\" /* X */]: [\"xName\"],\n  [\"y\" /* Y */]: [\"yName\"]\n};\nvar CartesianSeriesNodeEvent = class extends SeriesNodeEvent {\n  constructor(type, nativeEvent, datum, series) {\n    super(type, nativeEvent, datum, series);\n    this.xKey = series.properties.xKey;\n    this.yKey = series.properties.yKey;\n  }\n};\nvar CartesianSeriesProperties = class extends SeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.pickOutsideVisibleMinorAxis = false;\n  }\n};\n__decorateClass([\n  Validate(STRING, { optional: true })\n], CartesianSeriesProperties.prototype, \"legendItemName\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], CartesianSeriesProperties.prototype, \"pickOutsideVisibleMinorAxis\", 2);\nvar CartesianSeries = class extends DataModelSeries {\n  constructor({\n    pathsPerSeries = [\"path\"],\n    hasMarkers = false,\n    hasHighlightedLabels = false,\n    pathsZIndexSubOrderOffset = [],\n    datumSelectionGarbageCollection = true,\n    markerSelectionGarbageCollection = true,\n    animationAlwaysUpdateSelections = false,\n    animationResetFns,\n    directionKeys,\n    directionNames,\n    ...otherOpts\n  }) {\n    super({\n      directionKeys,\n      directionNames,\n      canHaveAxes: true,\n      ...otherOpts\n    });\n    this.NodeEvent = CartesianSeriesNodeEvent;\n    this.dataNodeGroup = this.contentGroup.appendChild(\n      new Group({\n        name: `${this.id}-series-dataNodes`,\n        zIndex: 4 /* SERIES_LAYER */,\n        zIndexSubOrder: this.getGroupZIndexSubOrder(\"data\")\n      })\n    );\n    this.markerGroup = this.contentGroup.appendChild(\n      new Group({\n        name: `${this.id}-series-markers`,\n        zIndex: 4 /* SERIES_LAYER */,\n        zIndexSubOrder: this.getGroupZIndexSubOrder(\"marker\")\n      })\n    );\n    this.labelGroup = this.contentGroup.appendChild(\n      new TranslatableGroup({\n        name: `${this.id}-series-labels`,\n        zIndex: 14 /* SERIES_LABEL */,\n        zIndexSubOrder: this.getGroupZIndexSubOrder(\"labels\")\n      })\n    );\n    this.labelSelection = Selection.select(this.labelGroup, Text);\n    this.highlightSelection = Selection.select(\n      this.highlightNode,\n      () => this.opts.hasMarkers ? this.markerFactory() : this.nodeFactory()\n    );\n    this.highlightLabelSelection = Selection.select(this.highlightLabel, Text);\n    this.annotationSelections = /* @__PURE__ */ new Set();\n    this.minRectsCache = {\n      dirtyNodeData: true\n    };\n    this.debug = Debug.create();\n    if (!directionKeys || !directionNames)\n      throw new Error(`Unable to initialise series type ${this.type}`);\n    this.opts = {\n      pathsPerSeries,\n      hasMarkers,\n      hasHighlightedLabels,\n      pathsZIndexSubOrderOffset,\n      directionKeys,\n      directionNames,\n      animationResetFns,\n      animationAlwaysUpdateSelections,\n      datumSelectionGarbageCollection,\n      markerSelectionGarbageCollection\n    };\n    this.paths = [];\n    for (let index = 0; index < pathsPerSeries.length; index++) {\n      this.paths[index] = new Path({ name: `${this.id}-${pathsPerSeries[index]}` });\n      this.paths[index].zIndex = 4 /* SERIES_LAYER */;\n      this.paths[index].zIndexSubOrder = this.getGroupZIndexSubOrder(\"paths\", index);\n      this.contentGroup.appendChild(this.paths[index]);\n    }\n    this.datumSelection = Selection.select(\n      this.dataNodeGroup,\n      () => this.nodeFactory(),\n      datumSelectionGarbageCollection\n    );\n    this.markerSelection = Selection.select(\n      this.markerGroup,\n      () => this.markerFactory(),\n      markerSelectionGarbageCollection\n    );\n    this.animationState = new StateMachine(\n      \"empty\",\n      {\n        empty: {\n          update: {\n            target: \"ready\",\n            action: (data) => this.animateEmptyUpdateReady(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\",\n          disable: \"disabled\"\n        },\n        ready: {\n          updateData: \"waiting\",\n          clear: \"clearing\",\n          highlight: (data) => this.animateReadyHighlight(data),\n          highlightMarkers: (data) => this.animateReadyHighlightMarkers(data),\n          resize: (data) => this.animateReadyResize(data),\n          reset: \"empty\",\n          skip: \"ready\",\n          disable: \"disabled\"\n        },\n        waiting: {\n          update: {\n            target: \"ready\",\n            action: (data) => {\n              if (this.ctx.animationManager.isSkipped()) {\n                this.resetAllAnimation(data);\n              } else {\n                this.animateWaitingUpdateReady(data);\n              }\n            }\n          },\n          reset: \"empty\",\n          skip: \"ready\",\n          disable: \"disabled\"\n        },\n        disabled: {\n          update: (data) => this.resetAllAnimation(data),\n          reset: \"empty\"\n        },\n        clearing: {\n          update: {\n            target: \"empty\",\n            action: (data) => this.animateClearingUpdateEmpty(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\"\n        }\n      },\n      () => this.checkProcessedDataAnimatable()\n    );\n  }\n  get contextNodeData() {\n    return this._contextNodeData;\n  }\n  getNodeData() {\n    return this.contextNodeData?.nodeData;\n  }\n  resetAnimation(phase) {\n    if (phase === \"initial\") {\n      this.animationState.transition(\"reset\");\n    } else if (phase === \"ready\") {\n      this.animationState.transition(\"skip\");\n    } else if (phase === \"disabled\") {\n      this.animationState.transition(\"disable\");\n    }\n  }\n  addChartEventListeners() {\n    this.destroyFns.push(\n      this.ctx.chartEventManager.addListener(\"legend-item-click\", (event) => this.onLegendItemClick(event)),\n      this.ctx.chartEventManager.addListener(\n        \"legend-item-double-click\",\n        (event) => this.onLegendItemDoubleClick(event)\n      )\n    );\n  }\n  destroy() {\n    super.destroy();\n    this._contextNodeData = void 0;\n  }\n  async update({ seriesRect }) {\n    const { visible, _contextNodeData: previousContextData } = this;\n    const series = this.ctx.highlightManager?.getActiveHighlight()?.series;\n    const seriesHighlighted = series === this;\n    const resize = this.checkResize(seriesRect);\n    const highlightItems = await this.updateHighlightSelection(seriesHighlighted);\n    await this.updateSelections(visible);\n    await this.updateNodes(highlightItems, seriesHighlighted, visible);\n    const animationData = this.getAnimationData(seriesRect, previousContextData);\n    if (!animationData)\n      return;\n    if (resize) {\n      this.animationState.transition(\"resize\", animationData);\n    }\n    this.animationState.transition(\"update\", animationData);\n  }\n  async updateSelections(anySeriesItemEnabled) {\n    var _a;\n    const animationSkipUpdate = !this.opts.animationAlwaysUpdateSelections && this.ctx.animationManager.isSkipped();\n    if (!anySeriesItemEnabled && animationSkipUpdate) {\n      return;\n    }\n    if (!this.nodeDataRefresh && !this.isPathOrSelectionDirty()) {\n      return;\n    }\n    if (this.nodeDataRefresh) {\n      this.nodeDataRefresh = false;\n      this.debug(`CartesianSeries.updateSelections() - calling createNodeData() for`, this.id);\n      this.markQuadtreeDirty();\n      this._contextNodeData = await this.createNodeData();\n      const animationValid = this.isProcessedDataAnimatable();\n      if (this._contextNodeData) {\n        (_a = this._contextNodeData).animationValid ?? (_a.animationValid = animationValid);\n      }\n      this.minRectsCache.dirtyNodeData = true;\n      const { dataModel, processedData } = this;\n      if (dataModel !== void 0 && processedData !== void 0) {\n        this.dispatch(\"data-update\", { dataModel, processedData });\n      }\n    }\n    await this.updateSeriesSelections();\n  }\n  async updateSeriesSelections(seriesHighlighted) {\n    const { datumSelection, labelSelection, markerSelection, paths } = this;\n    const contextData = this._contextNodeData;\n    if (!contextData)\n      return;\n    const { nodeData, labelData, itemId } = contextData;\n    await this.updatePaths({ seriesHighlighted, itemId, contextData, paths });\n    this.datumSelection = await this.updateDatumSelection({ nodeData, datumSelection });\n    this.labelSelection = await this.updateLabelSelection({ labelData, labelSelection });\n    if (this.opts.hasMarkers) {\n      this.markerSelection = await this.updateMarkerSelection({ nodeData, markerSelection });\n    }\n  }\n  markerFactory() {\n    const MarkerShape = getMarker();\n    return new MarkerShape();\n  }\n  getGroupZIndexSubOrder(type, subIndex = 0) {\n    const result = super.getGroupZIndexSubOrder(type, subIndex);\n    if (type === \"paths\") {\n      const [superFn] = result;\n      const pathOffset = this.opts.pathsZIndexSubOrderOffset[subIndex] ?? 0;\n      result[0] = isFunction(superFn) ? () => Number(superFn()) + pathOffset : Number(superFn) + pathOffset;\n    }\n    return result;\n  }\n  async updateNodes(highlightedItems, seriesHighlighted, anySeriesItemEnabled) {\n    const {\n      highlightSelection,\n      highlightLabelSelection,\n      opts: { hasMarkers, hasHighlightedLabels }\n    } = this;\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    const visible = this.visible && this._contextNodeData != null && anySeriesItemEnabled;\n    this.rootGroup.visible = animationEnabled || visible;\n    this.contentGroup.visible = animationEnabled || visible;\n    this.highlightGroup.visible = (animationEnabled || visible) && seriesHighlighted;\n    const opacity = this.getOpacity();\n    if (hasMarkers) {\n      await this.updateMarkerNodes({\n        markerSelection: highlightSelection,\n        isHighlight: true\n      });\n      this.animationState.transition(\"highlightMarkers\", highlightSelection);\n    } else {\n      await this.updateDatumNodes({\n        datumSelection: highlightSelection,\n        isHighlight: true\n      });\n      this.animationState.transition(\"highlight\", highlightSelection);\n    }\n    if (hasHighlightedLabels) {\n      await this.updateLabelNodes({ labelSelection: highlightLabelSelection });\n    }\n    const { dataNodeGroup, markerGroup, datumSelection, labelSelection, markerSelection, paths, labelGroup } = this;\n    const { itemId } = this.contextNodeData ?? {};\n    dataNodeGroup.opacity = opacity;\n    dataNodeGroup.visible = animationEnabled || visible;\n    labelGroup.visible = visible;\n    if (hasMarkers) {\n      markerGroup.opacity = opacity;\n      markerGroup.zIndex = dataNodeGroup.zIndex >= 4 /* SERIES_LAYER */ ? dataNodeGroup.zIndex : dataNodeGroup.zIndex + 1;\n      markerGroup.visible = visible;\n    }\n    if (labelGroup) {\n      labelGroup.opacity = opacity;\n    }\n    await this.updatePathNodes({\n      seriesHighlighted,\n      itemId,\n      paths,\n      opacity,\n      visible,\n      animationEnabled\n    });\n    if (!dataNodeGroup.visible) {\n      return;\n    }\n    await this.updateDatumNodes({ datumSelection, highlightedItems, isHighlight: false });\n    await this.updateLabelNodes({ labelSelection });\n    if (hasMarkers) {\n      await this.updateMarkerNodes({ markerSelection, isHighlight: false });\n    }\n  }\n  getHighlightLabelData(labelData, highlightedItem) {\n    const labelItems = labelData.filter(\n      (ld) => ld.datum === highlightedItem.datum && ld.itemId === highlightedItem.itemId\n    );\n    return labelItems.length === 0 ? void 0 : labelItems;\n  }\n  getHighlightData(_nodeData, highlightedItem) {\n    return highlightedItem ? [highlightedItem] : void 0;\n  }\n  async updateHighlightSelection(seriesHighlighted) {\n    const { highlightSelection, highlightLabelSelection, _contextNodeData: contextNodeData } = this;\n    if (!contextNodeData)\n      return;\n    const highlightedDatum = this.ctx.highlightManager?.getActiveHighlight();\n    const item = seriesHighlighted && highlightedDatum?.datum ? highlightedDatum : void 0;\n    let labelItems;\n    let highlightItems;\n    if (item != null) {\n      const labelsEnabled = this.isLabelEnabled();\n      const { labelData, nodeData } = contextNodeData;\n      highlightItems = this.getHighlightData(nodeData, item);\n      labelItems = labelsEnabled ? this.getHighlightLabelData(labelData, item) : void 0;\n    }\n    this.highlightSelection = await this.updateHighlightSelectionItem({\n      items: highlightItems,\n      highlightSelection\n    });\n    this.highlightLabelSelection = await this.updateHighlightSelectionLabel({\n      items: labelItems,\n      highlightLabelSelection\n    });\n    return highlightItems;\n  }\n  markQuadtreeDirty() {\n    this.quadtree = void 0;\n  }\n  *datumNodesIter() {\n    for (const { node } of this.datumSelection) {\n      if (node.datum.missing === true)\n        continue;\n      yield node;\n    }\n  }\n  getQuadTree() {\n    if (this.quadtree === void 0) {\n      const { width: width2, height: height2 } = this.ctx.scene.canvas;\n      const canvasRect = new BBox(0, 0, width2, height2);\n      this.quadtree = new QuadtreeNearest(100, 10, canvasRect);\n      this.initQuadTree(this.quadtree);\n    }\n    return this.quadtree;\n  }\n  initQuadTree(_quadtree) {\n  }\n  pickNodeExactShape(point) {\n    const result = super.pickNodeExactShape(point);\n    if (result) {\n      return result;\n    }\n    const { x, y } = point;\n    const {\n      opts: { hasMarkers }\n    } = this;\n    let match;\n    const { dataNodeGroup, markerGroup } = this;\n    match = dataNodeGroup.pickNode(x, y);\n    if (!match && hasMarkers) {\n      match = markerGroup?.pickNode(x, y);\n    }\n    if (match && match.datum.missing !== true) {\n      return { datum: match.datum, distance: 0 };\n    }\n    for (const mod2 of this.moduleMap.modules()) {\n      const { datum } = mod2.pickNodeExact(point) ?? {};\n      if (datum == null)\n        continue;\n      if (datum?.missing === true)\n        continue;\n      return { datum, distance: 0 };\n    }\n  }\n  pickNodeClosestDatum(point) {\n    const { x, y } = point;\n    const { axes, _contextNodeData: contextNodeData } = this;\n    if (!contextNodeData)\n      return;\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    const hitPoint = { x, y };\n    let minDistance = Infinity;\n    let closestDatum;\n    for (const datum of contextNodeData.nodeData) {\n      const { point: { x: datumX = NaN, y: datumY = NaN } = {} } = datum;\n      if (isNaN(datumX) || isNaN(datumY)) {\n        continue;\n      }\n      const isInRange = xAxis?.inRange(datumX) && yAxis?.inRange(datumY);\n      if (!isInRange) {\n        continue;\n      }\n      const distance3 = Math.max((hitPoint.x - datumX) ** 2 + (hitPoint.y - datumY) ** 2, 0);\n      if (distance3 < minDistance) {\n        minDistance = distance3;\n        closestDatum = datum;\n      }\n    }\n    for (const mod2 of this.moduleMap.modules()) {\n      const modPick = mod2.pickNodeNearest(point);\n      if (modPick !== void 0 && modPick.distanceSquared < minDistance) {\n        minDistance = modPick.distanceSquared;\n        closestDatum = modPick.datum;\n        break;\n      }\n    }\n    if (closestDatum) {\n      const distance3 = Math.max(Math.sqrt(minDistance) - (closestDatum.point?.size ?? 0), 0);\n      return { datum: closestDatum, distance: distance3 };\n    }\n  }\n  pickNodeMainAxisFirst(point, requireCategoryAxis) {\n    const { x, y } = point;\n    const { axes, _contextNodeData: contextNodeData } = this;\n    const { pickOutsideVisibleMinorAxis } = this.properties;\n    if (!contextNodeData)\n      return;\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    const directions2 = [xAxis, yAxis].filter(CategoryAxis.is).map((a) => a.direction);\n    if (requireCategoryAxis && directions2.length === 0)\n      return;\n    const [majorDirection = \"x\" /* X */] = directions2;\n    const hitPointCoords = [x, y];\n    if (majorDirection !== \"x\" /* X */)\n      hitPointCoords.reverse();\n    const minDistance = [Infinity, Infinity];\n    let closestDatum;\n    for (const datum of contextNodeData.nodeData) {\n      const { x: datumX = NaN, y: datumY = NaN } = datum.point ?? datum.midPoint ?? {};\n      if (isNaN(datumX) || isNaN(datumY) || datum.missing === true)\n        continue;\n      const visible = [xAxis?.inRange(datumX), yAxis?.inRange(datumY)];\n      if (majorDirection !== \"x\" /* X */) {\n        visible.reverse();\n      }\n      if (!visible[0] || !pickOutsideVisibleMinorAxis && !visible[1])\n        continue;\n      const datumPoint = [datumX, datumY];\n      if (majorDirection !== \"x\" /* X */) {\n        datumPoint.reverse();\n      }\n      let newMinDistance = true;\n      for (let i = 0; i < datumPoint.length; i++) {\n        const dist = Math.abs(datumPoint[i] - hitPointCoords[i]);\n        if (dist > minDistance[i]) {\n          newMinDistance = false;\n          break;\n        } else if (dist < minDistance[i]) {\n          minDistance[i] = dist;\n          minDistance.fill(Infinity, i + 1, minDistance.length);\n        }\n      }\n      if (newMinDistance) {\n        closestDatum = datum;\n      }\n    }\n    if (closestDatum) {\n      let closestDistanceSquared = Math.max(\n        minDistance[0] ** 2 + minDistance[1] ** 2 - (closestDatum.point?.size ?? 0),\n        0\n      );\n      for (const mod2 of this.moduleMap.modules()) {\n        const modPick = mod2.pickNodeMainAxisFirst(point);\n        if (modPick !== void 0 && modPick.distanceSquared < closestDistanceSquared) {\n          closestDatum = modPick.datum;\n          closestDistanceSquared = modPick.distanceSquared;\n          break;\n        }\n      }\n      return { datum: closestDatum, distance: Math.sqrt(closestDistanceSquared) };\n    }\n  }\n  onLegendItemClick(event) {\n    const { legendItemName } = this.properties;\n    const { enabled, itemId, series } = event;\n    const matchedLegendItemName = legendItemName != null && legendItemName === event.legendItemName;\n    if (series.id === this.id || matchedLegendItemName) {\n      this.toggleSeriesItem(itemId, enabled);\n    }\n  }\n  onLegendItemDoubleClick(event) {\n    const { enabled, itemId, series, numVisibleItems } = event;\n    const { legendItemName } = this.properties;\n    const matchedLegendItemName = legendItemName != null && legendItemName === event.legendItemName;\n    if (series.id === this.id || matchedLegendItemName) {\n      this.toggleSeriesItem(itemId, true);\n    } else if (enabled && numVisibleItems === 1) {\n      this.toggleSeriesItem(itemId, true);\n    } else {\n      this.toggleSeriesItem(itemId, false);\n    }\n  }\n  isPathOrSelectionDirty() {\n    return false;\n  }\n  getLabelData() {\n    return [];\n  }\n  shouldFlipXY() {\n    return false;\n  }\n  /**\n   * Get the minimum bounding box that contains any adjacent two nodes. The axes are treated independently, so this\n   * may not represent the same two points for both directions. The dimensions represent the greatest distance\n   * between any two adjacent nodes.\n   */\n  getMinRects(width2, height2) {\n    const { dirtyNodeData, sizeCache, minRect, minVisibleRect } = this.minRectsCache;\n    const newSizeCache = JSON.stringify({ width: width2, height: height2 });\n    const dirtySize = newSizeCache !== sizeCache;\n    if (!dirtySize && !dirtyNodeData && minRect && minVisibleRect) {\n      return { minRect, minVisibleRect };\n    }\n    const rects = this.computeMinRects(width2, height2);\n    this.minRectsCache = {\n      dirtyNodeData: false,\n      sizeCache: newSizeCache,\n      minRect: rects?.minRect,\n      minVisibleRect: rects?.minVisibleRect\n    };\n    return rects;\n  }\n  computeMinRects(width2, height2) {\n    const context = this._contextNodeData;\n    if (!context?.nodeData.length) {\n      return;\n    }\n    const { nodeData } = context;\n    const minRectXs = Array(nodeData.length);\n    const minRectYs = Array(nodeData.length);\n    for (const [i, { midPoint }] of nodeData.entries()) {\n      minRectXs[i] = midPoint?.x ?? 0;\n      minRectYs[i] = midPoint?.y ?? 0;\n    }\n    minRectXs.sort((a, b) => a - b);\n    minRectYs.sort((a, b) => a - b);\n    let zeroX, widthX, zeroY, heightY;\n    let maxWidth = 0;\n    let maxHeight = 0;\n    for (let i = 1; i < nodeData.length; i++) {\n      if (minRectXs[i] >= 0)\n        zeroX ?? (zeroX = i);\n      if (minRectXs[i] > width2)\n        widthX ?? (widthX = i);\n      if (minRectYs[i] >= 0)\n        zeroY ?? (zeroY = i);\n      if (minRectYs[i] > height2)\n        heightY ?? (heightY = i);\n      maxWidth = Math.max(maxWidth, minRectXs[i] - minRectXs[i - 1]);\n      maxHeight = Math.max(maxHeight, minRectYs[i] - minRectYs[i - 1]);\n    }\n    widthX ?? (widthX = nodeData.length);\n    heightY ?? (heightY = nodeData.length);\n    const minVisibleRectXs = zeroX != null && widthX != null ? minRectXs.slice(zeroX, widthX) : [];\n    const minVisibleRectYs = zeroY != null && heightY != null ? minRectYs.slice(zeroY, heightY) : [];\n    let maxVisibleWidth = 0;\n    let maxVisibleHeight = 0;\n    for (let i = 1; i < Math.max(minVisibleRectXs.length, minVisibleRectYs.length); i++) {\n      const x1 = minVisibleRectXs[i];\n      const x2 = minVisibleRectXs[i - 1];\n      const y1 = minVisibleRectYs[i];\n      const y2 = minVisibleRectYs[i - 1];\n      if (x1 != null && x2 != null) {\n        maxVisibleWidth = Math.max(maxVisibleWidth, x1 - x2);\n      }\n      if (y1 != null && y2 != null) {\n        maxVisibleHeight = Math.max(maxVisibleHeight, y1 - y2);\n      }\n    }\n    const minRect = new BBox(0, 0, maxWidth, maxHeight);\n    const minVisibleRect = new BBox(0, 0, maxVisibleWidth, maxVisibleHeight);\n    return { minRect, minVisibleRect };\n  }\n  updateHighlightSelectionItem(opts) {\n    const {\n      opts: { hasMarkers }\n    } = this;\n    const { items, highlightSelection } = opts;\n    const nodeData = items ?? [];\n    if (hasMarkers) {\n      const markerSelection = highlightSelection;\n      return this.updateMarkerSelection({ nodeData, markerSelection });\n    } else {\n      return this.updateDatumSelection({\n        nodeData,\n        datumSelection: highlightSelection\n      });\n    }\n  }\n  updateHighlightSelectionLabel(opts) {\n    return this.updateLabelSelection({\n      labelData: opts.items ?? [],\n      labelSelection: opts.highlightLabelSelection\n    });\n  }\n  async updateDatumSelection(opts) {\n    return opts.datumSelection;\n  }\n  async updateDatumNodes(_opts) {\n  }\n  async updateMarkerSelection(opts) {\n    return opts.markerSelection;\n  }\n  async updateMarkerNodes(_opts) {\n  }\n  async updatePaths(opts) {\n    opts.paths.forEach((p) => p.visible = false);\n  }\n  async updatePathNodes(opts) {\n    const { paths, opacity, visible } = opts;\n    for (const path of paths) {\n      path.opacity = opacity;\n      path.visible = visible;\n    }\n  }\n  resetPathAnimation(data) {\n    const { path } = this.opts?.animationResetFns ?? {};\n    if (path) {\n      data.paths.forEach((paths) => {\n        resetMotion([paths], path);\n      });\n    }\n  }\n  resetDatumAnimation(data) {\n    const { datum } = this.opts?.animationResetFns ?? {};\n    if (datum) {\n      resetMotion([data.datumSelection], datum);\n    }\n  }\n  resetLabelAnimation(data) {\n    const { label } = this.opts?.animationResetFns ?? {};\n    if (label) {\n      resetMotion([data.labelSelection], label);\n    }\n  }\n  resetMarkerAnimation(data) {\n    const { marker } = this.opts?.animationResetFns ?? {};\n    if (marker && this.opts.hasMarkers) {\n      resetMotion([data.markerSelection], marker);\n    }\n  }\n  resetAllAnimation(data) {\n    this.ctx.animationManager.stopByAnimationGroupId(this.id);\n    this.resetPathAnimation(data);\n    this.resetDatumAnimation(data);\n    this.resetLabelAnimation(data);\n    this.resetMarkerAnimation(data);\n    if (data.contextData?.animationValid === false) {\n      this.ctx.animationManager.skipCurrentBatch();\n    }\n  }\n  animateEmptyUpdateReady(data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation(data);\n  }\n  animateWaitingUpdateReady(data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation(data);\n  }\n  animateReadyHighlight(data) {\n    const { datum } = this.opts?.animationResetFns ?? {};\n    if (datum) {\n      resetMotion([data], datum);\n    }\n  }\n  animateReadyHighlightMarkers(data) {\n    const { marker } = this.opts?.animationResetFns ?? {};\n    if (marker) {\n      resetMotion([data], marker);\n    }\n  }\n  animateReadyResize(data) {\n    this.resetAllAnimation(data);\n  }\n  animateClearingUpdateEmpty(data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation(data);\n  }\n  animationTransitionClear() {\n    const animationData = this.getAnimationData();\n    if (!animationData)\n      return;\n    this.animationState.transition(\"clear\", animationData);\n  }\n  getAnimationData(seriesRect, previousContextData) {\n    const { _contextNodeData: contextData } = this;\n    if (!contextData)\n      return;\n    const animationData = {\n      datumSelection: this.datumSelection,\n      markerSelection: this.markerSelection,\n      labelSelection: this.labelSelection,\n      annotationSelections: [...this.annotationSelections],\n      contextData,\n      previousContextData,\n      paths: this.paths,\n      seriesRect\n    };\n    return animationData;\n  }\n  calculateScaling() {\n    const result = {};\n    for (const direction of Object.values(ChartAxisDirection)) {\n      const axis = this.axes[direction];\n      if (!axis)\n        continue;\n      if (axis.scale instanceof LogScale) {\n        const { range: range3, domain } = axis.scale;\n        result[direction] = {\n          type: \"log\",\n          convert: (d) => axis.scale.convert(d),\n          domain: [domain[0], domain[1]],\n          range: [range3[0], range3[1]]\n        };\n      } else if (axis.scale instanceof ContinuousScale) {\n        const { range: range3 } = axis.scale;\n        const domain = axis.scale.getDomain();\n        result[direction] = {\n          type: \"continuous\",\n          domain: [domain[0], domain[1]],\n          range: [range3[0], range3[1]]\n        };\n      } else if (axis.scale) {\n        const { domain } = axis.scale;\n        result[direction] = {\n          type: \"category\",\n          domain,\n          range: domain.map((d) => axis.scale.convert(d))\n        };\n      }\n    }\n    return result;\n  }\n};\n\n// packages/ag-charts-community/src/chart/cartesianChart.ts\nvar directions = [\"top\", \"right\", \"bottom\", \"left\"];\nvar CartesianChart = class extends Chart {\n  constructor(options, resources) {\n    super(options, resources);\n    /** Integrated Charts feature state - not used in Standalone Charts. */\n    this.paired = true;\n    this.firstSeriesTranslation = true;\n    this.lastUpdateClipRect = void 0;\n    this._lastCrossLineIds = void 0;\n    this._lastAxisAreaWidths = /* @__PURE__ */ new Map();\n    this._lastClipSeries = false;\n    this._lastVisibility = {\n      crossLines: true,\n      series: true\n    };\n  }\n  onAxisChange(newValue, oldValue) {\n    super.onAxisChange(newValue, oldValue);\n    this.ctx?.zoomManager.updateAxes(newValue);\n  }\n  destroySeries(series) {\n    super.destroySeries(series);\n    this.firstSeriesTranslation = true;\n  }\n  getChartType() {\n    return \"cartesian\";\n  }\n  setRootClipRects(clipRect) {\n    const { seriesRoot, annotationRoot, highlightRoot } = this;\n    seriesRoot.setClipRect(clipRect);\n    highlightRoot.setClipRect(clipRect);\n    annotationRoot.setClipRect(clipRect);\n  }\n  performLayout(ctx) {\n    const { firstSeriesTranslation, seriesRoot, annotationRoot, highlightRoot } = this;\n    const { seriesRect, visibility, clipSeries } = this.updateAxes(ctx.layoutBox);\n    this.seriesRoot.visible = visibility.series;\n    this.seriesRect = seriesRect;\n    this.animationRect = ctx.layoutBox;\n    const { x, y } = seriesRect;\n    if (firstSeriesTranslation) {\n      for (const group of [seriesRoot, annotationRoot, highlightRoot]) {\n        group.translationX = Math.floor(x);\n        group.translationY = Math.floor(y);\n      }\n      this.firstSeriesTranslation = false;\n    } else {\n      const { translationX, translationY } = seriesRoot;\n      staticFromToMotion(\n        this.id,\n        \"seriesRect\",\n        this.ctx.animationManager,\n        [seriesRoot, highlightRoot, annotationRoot],\n        { translationX, translationY },\n        { translationX: Math.floor(x), translationY: Math.floor(y) },\n        { phase: \"update\" }\n      );\n    }\n    const seriesPaddedRect = seriesRect.clone().grow(this.seriesArea.padding);\n    const clipRect = this.seriesArea.clip || clipSeries ? seriesPaddedRect : void 0;\n    const { lastUpdateClipRect } = this;\n    this.lastUpdateClipRect = clipRect;\n    if (this.ctx.animationManager.isActive() && lastUpdateClipRect != null) {\n      this.ctx.animationManager.animate({\n        id: this.id,\n        groupId: \"clip-rect\",\n        phase: \"update\",\n        from: lastUpdateClipRect,\n        to: seriesPaddedRect,\n        onUpdate: (interpolatedClipRect) => this.setRootClipRects(interpolatedClipRect),\n        onComplete: () => this.setRootClipRects(clipRect)\n      });\n    } else {\n      this.setRootClipRects(clipRect);\n    }\n    this.ctx.layoutManager.emitLayoutComplete(ctx, {\n      axes: this.axes.map((axis) => axis.getLayoutState()),\n      series: {\n        rect: seriesRect,\n        paddedRect: seriesPaddedRect,\n        visible: visibility.series,\n        shouldFlipXY: this.shouldFlipXY()\n      },\n      clipSeries\n    });\n  }\n  updateAxes(layoutBox) {\n    const crossLineIds = this.axes.flatMap((axis) => axis.crossLines ?? []).map((crossLine) => crossLine.id);\n    const axesValid = this._lastCrossLineIds != null && this._lastCrossLineIds.length === crossLineIds.length && this._lastCrossLineIds.every((id, index) => crossLineIds[index] === id);\n    let axisAreaWidths;\n    let clipSeries;\n    let visibility;\n    if (axesValid) {\n      axisAreaWidths = new Map(this._lastAxisAreaWidths.entries());\n      clipSeries = this._lastClipSeries;\n      visibility = { ...this._lastVisibility };\n    } else {\n      axisAreaWidths = /* @__PURE__ */ new Map();\n      clipSeries = false;\n      visibility = { crossLines: true, series: true };\n      this._lastCrossLineIds = crossLineIds;\n    }\n    const liveAxisWidths = new Set(this.axes.map((a) => a.position));\n    for (const position of axisAreaWidths.keys()) {\n      if (!liveAxisWidths.has(position)) {\n        axisAreaWidths.delete(position);\n      }\n    }\n    const stableOutputs = (otherAxisWidths, otherClipSeries, otherVisibility) => {\n      if ([...otherAxisWidths.keys()].some((k) => !axisAreaWidths.has(k))) {\n        return false;\n      }\n      if (visibility.crossLines !== otherVisibility.crossLines || visibility.series !== otherVisibility.series || clipSeries !== otherClipSeries) {\n        return false;\n      }\n      for (const [p, w] of axisAreaWidths.entries()) {\n        const otherW = otherAxisWidths.get(p);\n        if ((w != null || otherW != null) && w !== otherW) {\n          return false;\n        }\n      }\n      return true;\n    };\n    const ceilValues = (map) => {\n      for (const [key, value] of map.entries()) {\n        if (value && Math.abs(value) === Infinity) {\n          map.set(key, 0);\n          continue;\n        }\n        map.set(key, value != null ? Math.ceil(value) : value);\n      }\n      return map;\n    };\n    let lastPassAxisAreaWidths = /* @__PURE__ */ new Map();\n    let lastPassVisibility = {};\n    let lastPassClipSeries = false;\n    let seriesRect = this.seriesRect?.clone();\n    let count = 0;\n    do {\n      axisAreaWidths = new Map(lastPassAxisAreaWidths.entries());\n      clipSeries = lastPassClipSeries;\n      Object.assign(visibility, lastPassVisibility);\n      const result = this.updateAxesPass(axisAreaWidths, layoutBox.clone(), seriesRect);\n      lastPassAxisAreaWidths = ceilValues(result.axisAreaWidths);\n      lastPassVisibility = result.visibility;\n      lastPassClipSeries = result.clipSeries;\n      ({ seriesRect } = result);\n      if (count++ > 10) {\n        Logger.warn(\"unable to find stable axis layout.\");\n        break;\n      }\n    } while (!stableOutputs(lastPassAxisAreaWidths, lastPassClipSeries, lastPassVisibility));\n    this.axes.forEach((axis) => {\n      axis.update();\n    });\n    const clipRectPadding = 5;\n    this.axes.forEach((axis) => {\n      axis.setCrossLinesVisible(visibility.crossLines);\n      if (!seriesRect) {\n        return;\n      }\n      axis.clipGrid(\n        seriesRect.x,\n        seriesRect.y,\n        seriesRect.width + clipRectPadding,\n        seriesRect.height + clipRectPadding\n      );\n      switch (axis.position) {\n        case \"left\":\n        case \"right\":\n          axis.clipTickLines(\n            layoutBox.x,\n            seriesRect.y,\n            layoutBox.width + clipRectPadding,\n            seriesRect.height + clipRectPadding\n          );\n          break;\n        case \"top\":\n        case \"bottom\":\n          axis.clipTickLines(\n            seriesRect.x,\n            layoutBox.y,\n            seriesRect.width + clipRectPadding,\n            layoutBox.height + clipRectPadding\n          );\n          break;\n      }\n    });\n    this._lastAxisAreaWidths = axisAreaWidths;\n    this._lastVisibility = visibility;\n    this._lastClipSeries = clipSeries;\n    return { seriesRect, visibility, clipSeries };\n  }\n  updateAxesPass(axisAreaWidths, bounds, lastPassSeriesRect) {\n    const axisWidths = /* @__PURE__ */ new Map();\n    const axisGroups = /* @__PURE__ */ new Map();\n    const visibility = {\n      series: true,\n      crossLines: true\n    };\n    let clipSeries = false;\n    const primaryTickCounts = {};\n    const paddedBounds = this.applySeriesPadding(bounds);\n    const crossLinePadding = lastPassSeriesRect ? this.buildCrossLinePadding(axisAreaWidths) : {};\n    const axisAreaBound = this.buildAxisBound(paddedBounds, axisAreaWidths, crossLinePadding, visibility);\n    const seriesRect = this.buildSeriesRect(axisAreaBound, axisAreaWidths);\n    for (const axis of this.axes) {\n      const { position = \"left\" } = axis;\n      const { clipSeries: newClipSeries, axisThickness } = this.calculateAxisDimensions({\n        axis,\n        seriesRect,\n        primaryTickCounts,\n        clipSeries\n      });\n      axisWidths.set(axis.id, axisThickness);\n      if (!axisGroups.has(position))\n        axisGroups.set(position, []);\n      axisGroups.get(position)?.push(axis);\n      clipSeries = clipSeries || newClipSeries;\n    }\n    const newAxisAreaWidths = /* @__PURE__ */ new Map();\n    const axisOffsets = /* @__PURE__ */ new Map();\n    for (const [position, axes] of axisGroups.entries()) {\n      const isVertical = position === \"left\" || position === \"right\";\n      newAxisAreaWidths.set(position, this.calculateAxisArea(axes, axisWidths, axisOffsets, isVertical));\n    }\n    for (const [position, axes] of axisGroups.entries()) {\n      this.positionAxes({\n        axes,\n        position,\n        axisWidths,\n        axisOffsets,\n        axisAreaWidths: newAxisAreaWidths,\n        axisBound: axisAreaBound,\n        seriesRect\n      });\n    }\n    return { clipSeries, seriesRect, axisAreaWidths: newAxisAreaWidths, visibility };\n  }\n  buildCrossLinePadding(axisAreaSize) {\n    const crossLinePadding = {};\n    this.axes.forEach((axis) => {\n      axis.crossLines?.forEach((crossLine) => {\n        crossLine.calculatePadding?.(crossLinePadding);\n      });\n    });\n    for (const [side, padding = 0] of Object.entries(crossLinePadding)) {\n      crossLinePadding[side] = Math.max(padding - (axisAreaSize.get(side) ?? 0), 0);\n    }\n    return crossLinePadding;\n  }\n  applySeriesPadding(bounds) {\n    const paddedRect = bounds.clone();\n    directions.forEach((dir) => {\n      const padding = this.seriesArea.padding[dir];\n      const axis = this.axes.findLast((a) => a.position === dir);\n      if (axis) {\n        axis.seriesAreaPadding = padding;\n      } else {\n        paddedRect.shrink(padding, dir);\n      }\n    });\n    return paddedRect;\n  }\n  buildAxisBound(bounds, axisAreaWidths, crossLinePadding, visibility) {\n    const result = bounds.clone();\n    const { top = 0, right = 0, bottom = 0, left = 0 } = crossLinePadding;\n    const horizontalPadding = left + right;\n    const verticalPadding = top + bottom;\n    const totalWidth = (axisAreaWidths.get(\"left\") ?? 0) + (axisAreaWidths.get(\"right\") ?? 0) + horizontalPadding;\n    const totalHeight = (axisAreaWidths.get(\"top\") ?? 0) + (axisAreaWidths.get(\"bottom\") ?? 0) + verticalPadding;\n    if (result.width <= totalWidth || result.height <= totalHeight) {\n      visibility.crossLines = false;\n      visibility.series = false;\n      return result;\n    }\n    result.x += left;\n    result.y += top;\n    result.width -= horizontalPadding;\n    result.height -= verticalPadding;\n    return result;\n  }\n  buildSeriesRect(axisBound, axisAreaWidths) {\n    const result = axisBound.clone();\n    result.x += axisAreaWidths.get(\"left\") ?? 0;\n    result.y += axisAreaWidths.get(\"top\") ?? 0;\n    result.width -= (axisAreaWidths.get(\"left\") ?? 0) + (axisAreaWidths.get(\"right\") ?? 0);\n    result.height -= (axisAreaWidths.get(\"top\") ?? 0) + (axisAreaWidths.get(\"bottom\") ?? 0);\n    result.width = Math.max(0, result.width);\n    result.height = Math.max(0, result.height);\n    return result;\n  }\n  clampToOutsideSeriesRect(seriesRect, value, dimension, direction) {\n    const { x, y, width: width2, height: height2 } = seriesRect;\n    const clampBounds = [x, y, x + width2, y + height2];\n    const compareTo = clampBounds[(dimension === \"x\" ? 0 : 1) + (direction === 1 ? 0 : 2)];\n    const clampFn = direction === 1 ? Math.min : Math.max;\n    return clampFn(value, compareTo);\n  }\n  calculateAxisDimensions(opts) {\n    const { axis, seriesRect, primaryTickCounts } = opts;\n    let { clipSeries } = opts;\n    const { position = \"left\", direction } = axis;\n    this.sizeAxis(axis, seriesRect, position);\n    const syncedDomain = this.getSyncedDomain(axis);\n    const layout = axis.calculateLayout(syncedDomain, axis.nice ? primaryTickCounts[direction] : void 0);\n    const isVertical = direction === \"y\" /* Y */;\n    primaryTickCounts[direction] ?? (primaryTickCounts[direction] = layout.primaryTickCount);\n    clipSeries || (clipSeries = axis.dataDomain.clipped || axis.visibleRange[0] > 0 || axis.visibleRange[1] < 1);\n    let axisThickness;\n    if (axis.thickness != null && axis.thickness > 0) {\n      axisThickness = axis.thickness;\n    } else {\n      axisThickness = isVertical ? layout.bbox.width : layout.bbox.height;\n    }\n    axisThickness = Math.ceil(axisThickness);\n    return { clipSeries, axisThickness };\n  }\n  getSyncedDomain(axis) {\n    const syncModule = this.modulesManager.getModule(\"sync\");\n    if (!syncModule?.enabled)\n      return;\n    const syncedDomain = syncModule.getSyncedDomain(axis);\n    if (syncedDomain && axis.dataDomain.domain.length) {\n      let shouldUpdate;\n      const { domain } = axis.scale;\n      if (ContinuousScale.is(axis.scale)) {\n        const [min, max] = findMinMax(syncedDomain);\n        shouldUpdate = min !== domain[0] || max !== domain[1];\n      } else {\n        shouldUpdate = !arraysEqual(syncedDomain, domain);\n      }\n      if (shouldUpdate && !this.skipSync) {\n        syncModule.updateSiblings();\n      }\n    }\n    return syncedDomain;\n  }\n  sizeAxis(axis, seriesRect, position) {\n    const isCategory = axis instanceof CategoryAxis || axis instanceof GroupedCategoryAxis;\n    const isLeftRight = position === \"left\" || position === \"right\";\n    let { min, max } = this.ctx.zoomManager.getAxisZoom(axis.id);\n    const { width: width2, height: height2 } = seriesRect;\n    const minStart = 0;\n    const maxEnd = isLeftRight ? height2 : width2;\n    let start2 = minStart;\n    let end2 = maxEnd;\n    const { width: axisWidth, unit, align } = axis.layoutConstraints;\n    if (unit === \"px\") {\n      end2 = start2 + axisWidth;\n    } else {\n      end2 = end2 * axisWidth / 100;\n    }\n    if (align === \"end\") {\n      start2 = maxEnd - (end2 - start2);\n      end2 = maxEnd;\n    }\n    if (isCategory && isLeftRight) {\n      [min, max] = [1 - max, 1 - min];\n    } else if (isLeftRight) {\n      [start2, end2] = [end2, start2];\n    }\n    axis.range = [start2, end2];\n    axis.visibleRange = [min, max];\n    axis.gridLength = isLeftRight ? width2 : height2;\n  }\n  calculateAxisArea(axes, axisWidths, axisOffsets, isVertical) {\n    const { width: width2, height: height2, canvas } = this.ctx.scene;\n    let currentOffset = isVertical ? height2 % canvas.pixelRatio : width2 % canvas.pixelRatio;\n    let totalAxisWidth = 0;\n    for (const axis of axes) {\n      axisOffsets.set(axis.id, currentOffset);\n      const axisThickness = axisWidths.get(axis.id) ?? 0;\n      totalAxisWidth = Math.max(totalAxisWidth, currentOffset + axisThickness);\n      if (axis.layoutConstraints.stacked) {\n        currentOffset += axisThickness + 15;\n      }\n    }\n    return totalAxisWidth;\n  }\n  positionAxes(opts) {\n    const { axes, axisBound, axisWidths, axisOffsets, axisAreaWidths, seriesRect, position } = opts;\n    const axisAreaWidth = axisAreaWidths.get(position) ?? 0;\n    let mainDimension = \"x\";\n    let minorDimension = \"y\";\n    let direction = 1;\n    let axisBoundMainOffset = 0;\n    if (position === \"top\" || position === \"bottom\") {\n      mainDimension = \"y\";\n      minorDimension = \"x\";\n      axisBoundMainOffset += 1;\n    }\n    axisBoundMainOffset += axisBound[mainDimension];\n    if (position === \"right\" || position === \"bottom\") {\n      direction = -1;\n      axisBoundMainOffset += mainDimension === \"x\" ? axisBound.width : axisBound.height;\n    }\n    for (const axis of axes) {\n      const minorOffset = axisAreaWidths.get(minorDimension === \"x\" ? \"left\" : \"top\") ?? 0;\n      axis.translation[minorDimension] = axisBound[minorDimension] + minorOffset;\n      const axisThickness = axisWidths.get(axis.id) ?? 0;\n      const axisOffset = axisOffsets.get(axis.id) ?? 0;\n      axis.translation[mainDimension] = this.clampToOutsideSeriesRect(\n        seriesRect,\n        axisBoundMainOffset + direction * (axisOffset + axisThickness),\n        mainDimension,\n        direction\n      );\n      axis.gridPadding = axisAreaWidth - axisOffset - axisThickness;\n      axis.updatePosition();\n    }\n  }\n  shouldFlipXY() {\n    return this.series.every((series) => series instanceof CartesianSeries && series.shouldFlipXY());\n  }\n};\nCartesianChart.className = \"CartesianChart\";\nCartesianChart.type = \"cartesian\";\n\n// packages/ag-charts-community/src/chart/chartProxy.ts\nvar _AgChartInstanceProxy = class _AgChartInstanceProxy {\n  constructor(chart, factoryApi, licenseManager) {\n    this.factoryApi = factoryApi;\n    this.licenseManager = licenseManager;\n    this.chart = chart;\n  }\n  static isInstance(x) {\n    if (x instanceof _AgChartInstanceProxy) {\n      return true;\n    }\n    if (x.constructor?.name === \"AgChartInstanceProxy\" && x.chart != null) {\n      return true;\n    }\n    return x.chart != null && this.validateImplementation(x);\n  }\n  static validateImplementation(x) {\n    const chartProps = [\"getOptions\", \"destroy\"];\n    const signatureProps = Object.keys(Object.getPrototypeOf(x) ?? {});\n    return chartProps.every((prop) => signatureProps.includes(prop));\n  }\n  async update(options) {\n    this.factoryApi.update(options, this);\n    await this.chart.waitForUpdate();\n  }\n  async updateDelta(deltaOptions) {\n    this.factoryApi.updateUserDelta(this, deltaOptions);\n    await this.chart.waitForUpdate();\n  }\n  getOptions() {\n    const options = deepClone(this.chart.getOptions());\n    for (const key in options) {\n      if (key.startsWith(\"_\")) {\n        delete options[key];\n      }\n    }\n    return options;\n  }\n  waitForUpdate() {\n    return this.chart.waitForUpdate();\n  }\n  async download(opts) {\n    const clone2 = await this.prepareResizedChart(this, opts);\n    try {\n      clone2.chart.download(opts?.fileName, opts?.fileFormat);\n    } finally {\n      clone2.destroy();\n    }\n  }\n  async __toSVG(opts) {\n    const clone2 = await this.prepareResizedChart(this, { width: 600, height: 300, ...opts });\n    try {\n      return clone2.chart.toSVG();\n    } finally {\n      clone2.destroy();\n    }\n  }\n  async getImageDataURL(opts) {\n    const clone2 = await this.prepareResizedChart(this, opts);\n    try {\n      return clone2.chart.getCanvasDataURL(opts?.fileFormat);\n    } finally {\n      clone2.destroy();\n    }\n  }\n  getState() {\n    const {\n      factoryApi: { caretaker },\n      chart: {\n        ctx: { annotationManager }\n      }\n    } = this;\n    return caretaker.save(annotationManager);\n  }\n  async setState(state) {\n    const {\n      factoryApi: { caretaker },\n      chart: {\n        ctx: { annotationManager }\n      }\n    } = this;\n    caretaker.restore(state, annotationManager);\n    await this.chart.waitForUpdate();\n  }\n  resetAnimations() {\n    this.chart.resetAnimations();\n  }\n  skipAnimations() {\n    this.chart.skipAnimations();\n  }\n  destroy() {\n    this.chart.publicApi = void 0;\n    this.chart.destroy();\n  }\n  async prepareResizedChart(proxy, opts = {}) {\n    const { chart } = proxy;\n    const width2 = opts.width ?? chart.width ?? chart.ctx.scene.canvas.width;\n    const height2 = opts.height ?? chart.height ?? chart.ctx.scene.canvas.height;\n    const state = proxy.getState();\n    const isEnterprise = moduleRegistry.hasEnterpriseModules();\n    const processedOverrides = {\n      ...chart.chartOptions.processedOverrides,\n      container: document.createElement(\"div\"),\n      width: width2,\n      height: height2\n    };\n    const userOptions = chart.getOptions();\n    if (isEnterprise) {\n      processedOverrides.animation = { enabled: false };\n      if (isAgCartesianChartOptions(userOptions)) {\n        processedOverrides.toolbar = { enabled: false };\n      }\n      if (this.licenseManager?.isDisplayWatermark()) {\n        processedOverrides.foreground = {\n          text: this.licenseManager.getWatermarkMessage(),\n          image: {\n            url: `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjU4IiBoZWlnaHQ9IjQwIiB2aWV3Qm94PSIwIDAgMjU4IDQwIiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8cGF0aCBkPSJNMjUuNzc5IDI4LjY1N0gxMy4zNTlMMTEuMTczIDM0LjAxMkg1LjY3Mjk3TDE3LjE4MiA3LjA1OTk5SDIxLjk1M0wzMy40NjIgMzQuMDEySDI3Ljk2MkwyNS43NzYgMjguNjU3SDI1Ljc3OVpNMjQuMDY4IDI0LjM5N0wxOS41ODggMTMuNDM0TDE1LjEwNyAyNC4zOTdIMjQuMDY4Wk02Mi4wOTIgMTguODIzSDQ5LjgxN1YyMy4wODZINTYuNzc1QzU2LjU1NSAyNS4yMjIgNTUuNzU1IDI2LjkyNyA1NC4zNzIgMjguMjAyQzUyLjk4OSAyOS40NzYgNTEuMTY2IDMwLjExNSA0OC45MDkgMzAuMTE1QzQ3LjYyMiAzMC4xMTUgNDYuNDUgMjkuODg1IDQ1LjM5MyAyOS40MjNDNDQuMzU4MyAyOC45NzgxIDQzLjQzMjYgMjguMzEzOCA0Mi42OCAyNy40NzZDNDEuOTI3IDI2LjYzOSA0MS4zNDQgMjUuNjMxIDQwLjkzMSAyNC40NTNDNDAuNTE5IDIzLjI3NSA0MC4zMTEgMjEuOTcgNDAuMzExIDIwLjUzN0M0MC4zMTEgMTkuMTA1IDQwLjUxNiAxNy44IDQwLjkzMSAxNi42MjFDNDEuMzQ0IDE1LjQ0MyA0MS45MjcgMTQuNDM2IDQyLjY4IDEzLjU5OEM0My40Mzc2IDEyLjc1NzcgNDQuMzY5NiAxMi4wOTMyIDQ1LjQxMSAxMS42NTFDNDYuNDc4IDExLjE4OSA0Ny42NTYgMTAuOTYgNDguOTQ2IDEwLjk2QzUxLjYxMiAxMC45NiA1My42MzcgMTEuNjAyIDU1LjAyIDEyLjg4NUw1OC4zIDkuNjA0OTlDNTUuODE3IDcuNjY5OTkgNTIuNjc2IDYuNjk5OTkgNDguODcyIDYuNjk5OTlDNDYuNzYgNi42OTk5OSA0NC44NTMgNy4wMzQ5OSA0My4xNTQgNy43MDA5OUM0MS40NTUgOC4zNjc5OSAzOS45OTggOS4zMDM5OSAzOC43ODMgMTAuNTA0QzM3LjU2NyAxMS43MDcgMzYuNjM0IDEzLjE1OCAzNS45NzcgMTQuODU3QzM1LjMxOSAxNi41NTYgMzQuOTk0IDE4LjQ1MSAzNC45OTQgMjAuNTRDMzQuOTk0IDIyLjYzIDM1LjMyOSAyNC40OTQgMzUuOTk1IDI2LjIwNUMzNi42NjIgMjcuOTE2IDM3LjYwNSAyOS4zNzQgMzguODE3IDMwLjU3N0M0MC4wMzIgMzEuNzggNDEuNDg2IDMyLjcxMyA0My4xODggMzMuMzgzQzQ0Ljg4OCAzNC4wNDkgNDYuNzgyIDM0LjM4NCA0OC44NzIgMzQuMzg0QzUwLjk2MSAzNC4zODQgNTIuNzUgMzQuMDQ5IDU0LjM5IDMzLjM4M0M1Ni4wMzEgMzIuNzE2IDU3LjQyNiAzMS43OCA1OC41NzkgMzAuNTc3QzU5LjczMyAyOS4zNzQgNjAuNjE5IDI3LjkxNiA2MS4yMzkgMjYuMjA1QzYxLjg2IDI0LjQ5NCA2Mi4xNyAyMi42MDUgNjIuMTcgMjAuNTRDNjIuMTY5NiAxOS45Njg4IDYyLjE0NDUgMTkuMzk4IDYyLjA5NSAxOC44MjlMNjIuMDkyIDE4LjgyM1pNMTUxLjgxIDE2Ljk4MUMxNTMuNDEgMTQuNjA5IDE1Ny40MTkgMTQuMzU4IDE1OS4wMjIgMTQuMzU4VjE4LjkxQzE1Ni45NTcgMTguOTEgMTU0Ljk4NSAxOC45OTYgMTUzLjc1NyAxOS44OTJDMTUyLjUyOSAyMC43OTIgMTUxLjkxOSAyMS45ODIgMTUxLjkxOSAyMy40NjRWMzMuOTlIMTQ2Ljk2NFYxNC4zNThIMTUxLjczNkwxNTEuODEgMTYuOTgxWk0xNDMuMDExIDE0LjM2MVYzNC4wMzFIMTM4LjI0TDEzOC4xMzEgMzEuMDQ1QzEzNy40NjYgMzIuMDc2IDEzNi41NTEgMzIuOTIxOSAxMzUuNDcxIDMzLjUwNEMxMzQuMzc2IDM0LjA5OSAxMzMuMDY4IDM0LjM5NiAxMzEuNTM2IDM0LjM5NkMxMzAuMiAzNC4zOTYgMTI4Ljk2MyAzNC4xNTIgMTI3LjgyMiAzMy42NjhDMTI2LjcgMzMuMTk2NCAxMjUuNjg5IDMyLjQ5NSAxMjQuODU1IDMxLjYwOUMxMjQuMDE4IDMwLjcyMiAxMjMuMzU0IDI5LjY2MiAxMjIuODcxIDI4LjQyMkMxMjIuMzg0IDI3LjE4NSAxMjIuMTQyIDI1LjgxMSAxMjIuMTQyIDI0LjMwNEMxMjIuMTQyIDIyLjc5OCAxMjIuMzg0IDIxLjM3OCAxMjIuODcxIDIwLjExNkMxMjMuMzU3IDE4Ljg1NCAxMjQuMDE4IDE3Ljc3MiAxMjQuODU1IDE2Ljg3M0MxMjUuNjg4IDE1Ljk3NjQgMTI2LjY5OCAxNS4yNjM2IDEyNy44MjIgMTQuNzhDMTI4Ljk2MyAxNC4yODEgMTMwLjIwMyAxNC4wMzMgMTMxLjUzNiAxNC4wMzNDMTMzLjA0MyAxNC4wMzMgMTM0LjMzIDE0LjMxOCAxMzUuMzk3IDE0Ljg4OEMxMzYuNDYyIDE1LjQ1ODkgMTM3LjM3NSAxNi4yNzggMTM4LjA1NyAxNy4yNzZWMTQuMzYxSDE0My4wMTFaTTEzMi42MzEgMzAuMTMzQzEzNC4yNTYgMzAuMTMzIDEzNS41NjcgMjkuNTk0IDEzNi41NjUgMjguNTEyQzEzNy41NjEgMjcuNDMgMTM4LjA2IDI1Ljk5MSAxMzguMDYgMjQuMTk2QzEzOC4wNiAyMi40MDEgMTM3LjU2MSAyMC45OSAxMzYuNTY1IDE5Ljg5OUMxMzUuNTcgMTguODA3IDEzNC4yNTkgMTguMjU4IDEzMi42MzEgMTguMjU4QzEzMS4wMDMgMTguMjU4IDEyOS43MjkgMTguODA0IDEyOC43MzQgMTkuODk5QzEyNy43MzggMjAuOTkzIDEyNy4yMzkgMjIuNDM4IDEyNy4yMzkgMjQuMjMzQzEyNy4yMzkgMjYuMDI4IDEyNy43MzUgMjcuNDMzIDEyOC43MzQgMjguNTE1QzEyOS43MjkgMjkuNTk0IDEzMS4wMjggMzAuMTM2IDEzMi42MzEgMzAuMTM2VjMwLjEzM1pNOTMuNjk4IDI3Ljg3NkM5My41Nzk1IDI4LjAwMjUgOTMuNDU2NCAyOC4xMjQ2IDkzLjMyOSAyOC4yNDJDOTEuOTQ3IDI5LjUxNiA5MC4xMjMgMzAuMTU1IDg3Ljg2NiAzMC4xNTVDODYuNTggMzAuMTU1IDg1LjQwOCAyOS45MjYgODQuMzUgMjkuNDY0QzgzLjMxNTUgMjkuMDE4OSA4Mi4zODk4IDI4LjM1NDYgODEuNjM3IDI3LjUxN0M4MC44ODQgMjYuNjc5IDgwLjMwMSAyNS42NzIgNzkuODg5IDI0LjQ5NEM3OS40NzYgMjMuMzE1IDc5LjI2OSAyMi4wMSA3OS4yNjkgMjAuNTc4Qzc5LjI2OSAxOS4xNDUgNzkuNDczIDE3Ljg0IDc5Ljg4OSAxNi42NjJDODAuMzAxIDE1LjQ4NCA4MC44ODQgMTQuNDc2IDgxLjYzNyAxMy42MzlDODIuMzk0OSAxMi43OTg3IDgzLjMyNzMgMTIuMTM0MiA4NC4zNjkgMTEuNjkyQzg1LjQzNiAxMS4yMyA4Ni42MTQgMTEgODcuOTAzIDExQzkwLjU3IDExIDkyLjU5NSAxMS42NDIgOTMuOTc3IDEyLjkyNkw5Ny4yNTggOS42NDQ5OUM5NC43NzQgNy43MTA5OSA5MS42MzMgNi43Mzk5OSA4Ny44MjkgNi43Mzk5OUM4NS43MTggNi43Mzk5OSA4My44MTEgNy4wNzQ5OSA4Mi4xMTIgNy43NDE5OUM4MC40MTMgOC40MDc5OSA3OC45NTYgOS4zNDQ5OSA3Ny43NCAxMC41NDVDNzYuNTI1IDExLjc0NyA3NS41OTIgMTMuMTk5IDc0LjkzNCAxNC44OThDNzQuMjc3IDE2LjU5NyA3My45NTEgMTguNDkxIDczLjk1MSAyMC41ODFDNzMuOTUxIDIyLjY3IDc0LjI4NiAyNC41MzQgNzQuOTUzIDI2LjI0NUM3NS42MTkgMjcuOTU3IDc2LjU2MiAyOS40MTQgNzcuNzc0IDMwLjYxN0M3OC45OSAzMS44MiA4MC40NDQgMzIuNzUzIDgyLjE0NiAzMy40MjNDODMuODQ1IDM0LjA5IDg1LjczOSAzNC40MjQgODcuODI5IDM0LjQyNEM4OS45MTkgMzQuNDI0IDkxLjcwOCAzNC4wOSA5My4zNDggMzMuNDIzQzk0LjcxOCAzMi44NjUgOTUuOTE4IDMyLjEyMSA5Ni45NDggMzEuMTkxQzk3LjE0OSAzMS4wMDggOTcuMzQ4IDMwLjgxNSA5Ny41MzcgMzAuNjJMOTMuNzAxIDI3Ljg4NUw5My42OTggMjcuODc2Wk0xMTAuODAyIDE0LjAxNUMxMDkuMTk5IDE0LjAxNSAxMDYuODM2IDE0LjQ3MSAxMDUuNjExIDE2LjE1OEwxMDUuNTM3IDYuMDE1OTlIMTAwLjc2NVYzMy45MzlIMTA1LjcyVjIyLjY0MUMxMDUuNzcxIDIxLjQ2MDcgMTA2LjI4OCAyMC4zNDg4IDEwNy4xNTcgMTkuNTQ4OUMxMDguMDI3IDE4Ljc0OTEgMTA5LjE3OCAxOC4zMjY2IDExMC4zNTggMTguMzc0QzExMy4zOTcgMTguMzc0IDExNC4yNjggMjEuMTU5IDExNC4yNjggMjIuNjQxVjMzLjkzOUgxMTkuMjIzVjIxLjA1OUMxMTkuMjIzIDIxLjA1OSAxMTkuMTQyIDE0LjAxNSAxMTAuODAyIDE0LjAxNVpNMTczLjc2MyAxNC4zNThIMTY5Ljk5OVY4LjcxNDk5SDE2NS4wNDhWMTQuMzU4SDE2MS4yODRWMTguOTE2SDE2NS4wNDhWMzQuMDAzSDE2OS45OTlWMTguOTE2SDE3My43NjNWMTQuMzU4Wk0xOTAuNzg3IDI1LjI2MkMxOTAuMTI5IDI0LjUwMTQgMTg5LjMwNyAyMy44OTk0IDE4OC4zODQgMjMuNTAxQzE4Ny40ODggMjMuMTE3IDE4Ni4zMzEgMjIuNzMyIDE4NC45NDggMjIuMzY0QzE4NC4xNjUgMjIuMTQzOSAxODMuMzkgMjEuODk3OCAxODIuNjIzIDIxLjYyNkMxODIuMTYzIDIxLjQ2MjEgMTgxLjc0MSAyMS4yMDY2IDE4MS4zODMgMjAuODc1QzE4MS4yMzUgMjAuNzQyMSAxODEuMTE4IDIwLjU3ODkgMTgxLjAzOSAyMC4zOTY0QzE4MC45NjEgMjAuMjE0IDE4MC45MjIgMjAuMDE2NiAxODAuOTI3IDE5LjgxOEMxODAuOTI3IDE5LjI3MiAxODEuMTU2IDE4Ljg0NCAxODEuNjI1IDE4LjUxQzE4Mi4xMjEgMTguMTU2IDE4Mi44NjIgMTcuOTc2IDE4My44MjYgMTcuOTc2QzE4NC43OSAxNy45NzYgMTg1LjU4NyAxOC4yMDkgMTg2LjE0OCAxOC42NjhDMTg2LjcwNiAxOS4xMjQgMTg3LjAwNyAxOS43MjUgMTg3LjA3MiAyMC41TDE4Ny4wOTQgMjAuNzgySDE5MS42MzNMMTkxLjYxNyAyMC40NkMxOTEuNTIxIDE4LjQ4NSAxOTAuNzcxIDE2LjkgMTg5LjM4NSAxNS43NUMxODguMDEyIDE0LjYxMiAxODYuMTg1IDE0LjAzMyAxODMuOTYyIDE0LjAzM0MxODIuNDc3IDE0LjAzMyAxODEuMTQxIDE0LjI4NyAxNzkuOTk0IDE0Ljc4NkMxNzguODMxIDE1LjI5MSAxNzcuOTI2IDE1Ljk5NSAxNzcuMjk2IDE2Ljg4MkMxNzYuNjczIDE3Ljc0NTUgMTc2LjMzOCAxOC43ODQgMTc2LjM0MSAxOS44NDlDMTc2LjM0MSAyMS4xNjcgMTc2LjY5OCAyMi4yNDkgMTc3LjM5OSAyMy4wNjRDMTc4LjA2IDIzLjg0MzIgMTc4Ljg5OCAyNC40NTM0IDE3OS44NDIgMjQuODQ0QzE4MC43NDQgMjUuMjE2IDE4MS45MjggMjUuNjA3IDE4My4zNjEgMjZDMTg0LjgwNiAyNi40MSAxODUuODcyIDI2Ljc4NSAxODYuNTMgMjcuMTIzQzE4Ny4xIDI3LjQxNCAxODcuMzc5IDI3Ljg0NSAxODcuMzc5IDI4LjQ0NEMxODcuMzc5IDI5LjA0MiAxODcuMTIyIDI5LjQ2NyAxODYuNTk1IDI5LjgzOUMxODYuMDQzIDMwLjIyNiAxODUuMjM3IDMwLjQyNSAxODQuMjAxIDMwLjQyNUMxODMuMTY2IDMwLjQyNSAxODIuMzk0IDMwLjE3NCAxODEuNzQ5IDI5LjY3NEMxODEuMTEzIDI5LjE4MSAxODAuNzcyIDI4LjU4OSAxODAuNzEgMjcuODY0TDE4MC42ODUgMjcuNTgySDE3Ni4wMTNMMTc2LjAyNSAyNy45MDFDMTc2LjA2NyAyOS4wOTU1IDE3Ni40NzIgMzAuMjQ4NyAxNzcuMTg4IDMxLjIwNkMxNzcuOTA3IDMyLjE4IDE3OC44OTMgMzIuOTU4IDE4MC4xMTggMzMuNTE5QzE4MS4zMzYgMzQuMDc3IDE4Mi43MzIgMzQuMzYyIDE4NC4yNjYgMzQuMzYyQzE4NS44MDEgMzQuMzYyIDE4Ny4xMDkgMzQuMTA4IDE4OC4yMzggMzMuNjA5QzE4OS4zNzYgMzMuMTA0IDE5MC4yNzIgMzIuMzk0IDE5MC45MDEgMzEuNDk0QzE5MS41MzQgMzAuNTkyIDE5MS44NTMgMjkuNTU0IDE5MS44NTMgMjguNDAzQzE5MS44MjggMjcuMTEgMTkxLjQ2NiAyNi4wNTMgMTkwLjc3NyAyNS4yNjJIMTkwLjc4N1oiIGZpbGw9IiM5QjlCOUIiLz4KPHBhdGggZD0iTTI0MS45ODIgMjUuNjU4MlYxNy43MTE3SDIyOC40NDFMMjIwLjQ5NCAyNS42NTgySDI0MS45ODJaIiBmaWxsPSIjOUI5QjlCIi8+CjxwYXRoIGQ9Ik0yNTcuMjM5IDUuOTUwODFIMjQwLjI2NUwyMzIuMjU1IDEzLjg5NzNIMjU3LjIzOVY1Ljk1MDgxWiIgZmlsbD0iIzlCOUI5QiIvPgo8cGF0aCBkPSJNMjEyLjYxMSAzMy42MDQ4TDIxNi42OCAyOS41MzYxSDIzMC40MTJWMzcuNDgyN0gyMTIuNjExVjMzLjYwNDhaIiBmaWxsPSIjOUI5QjlCIi8+CjxwYXRoIGQ9Ik0yMTUuNTk5IDIxLjc4MDNIMjI0LjM3MkwyMzIuMzgyIDEzLjgzMzdIMjE1LjU5OVYyMS43ODAzWiIgZmlsbD0iIzlCOUI5QiIvPgo8cGF0aCBkPSJNMjA2IDMzLjYwNDdIMjEyLjYxMUwyMjAuNDk0IDI1LjY1ODJIMjA2VjMzLjYwNDdaIiBmaWxsPSIjOUI5QjlCIi8+CjxwYXRoIGQ9Ik0yNDAuMjY1IDUuOTUwODFMMjM2LjE5NyAxMC4wMTk0SDIxMC4yNTlWMi4wNzI4OEgyNDAuMjY1VjUuOTUwODFaIiBmaWxsPSIjOUI5QjlCIi8+Cjwvc3ZnPgo=`,\n            width: 170,\n            height: 25,\n            right: 25,\n            bottom: 50,\n            opacity: 0.7\n          }\n        };\n      }\n    }\n    const specialOverrides = { ...chart.chartOptions.specialOverrides };\n    const optionsMetadata = { ...chart.chartOptions.optionMetadata };\n    if (opts.width != null && opts.height != null) {\n      specialOverrides.overrideDevicePixelRatio = 1;\n    }\n    const cloneProxy = await this.factoryApi.create(\n      userOptions,\n      processedOverrides,\n      specialOverrides,\n      optionsMetadata\n    );\n    await cloneProxy.setState(state);\n    cloneProxy.chart.ctx.zoomManager.updateZoom(\"chartProxy\", chart.ctx.zoomManager.getZoom());\n    chart.series.forEach((series, index) => {\n      if (!series.visible) {\n        cloneProxy.chart.series[index].visible = false;\n      }\n    });\n    cloneProxy.chart.update(0 /* FULL */, { forceNodeDataRefresh: true });\n    await cloneProxy.waitForUpdate();\n    return cloneProxy;\n  }\n};\n_AgChartInstanceProxy.chartInstances = /* @__PURE__ */ new WeakMap();\n__decorateClass([\n  ActionOnSet({\n    oldValue(chart) {\n      if (!chart.destroyed) {\n        chart.publicApi = void 0;\n      }\n      _AgChartInstanceProxy.chartInstances.delete(chart);\n    },\n    newValue(chart) {\n      chart.publicApi = this;\n      _AgChartInstanceProxy.chartInstances.set(chart, this);\n    }\n  })\n], _AgChartInstanceProxy.prototype, \"chart\", 2);\nvar AgChartInstanceProxy = _AgChartInstanceProxy;\n\n// packages/ag-charts-community/src/locale/locale.ts\nvar Locale = class extends BaseModuleInstance {\n  constructor(ctx) {\n    super();\n    this.ctx = ctx;\n    this.localeText = void 0;\n  }\n};\n__decorateClass([\n  ObserveChanges((target) => {\n    target.ctx.localeManager.setLocaleText(target.localeText);\n  }),\n  Validate(PLAIN_OBJECT, { optional: true })\n], Locale.prototype, \"localeText\", 2);\n__decorateClass([\n  ObserveChanges((target) => {\n    target.ctx.localeManager.setLocaleTextFormatter(target.getLocaleText);\n  }),\n  Validate(FUNCTION, { optional: true })\n], Locale.prototype, \"getLocaleText\", 2);\n\n// packages/ag-charts-community/src/locale/localeModule.ts\nvar LocaleModule = {\n  type: \"root\",\n  optionsKey: \"locale\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\", \"standalone\", \"gauge\"],\n  moduleFactory: (ctx) => new Locale(ctx)\n};\n\n// packages/ag-charts-community/src/scale/linearScale.ts\nvar LinearScale = class extends ContinuousScale {\n  constructor() {\n    super([0, 1], [0, 1]);\n    this.type = \"number\";\n  }\n  toDomain(d) {\n    return d;\n  }\n  ticks() {\n    const count = this.tickCount ?? ContinuousScale.defaultTickCount;\n    if (!this.domain || this.domain.length < 2 || count < 1 || !this.domain.every(isFinite)) {\n      return [];\n    }\n    this.refresh();\n    const [d0, d1] = this.getDomain();\n    if (this.interval) {\n      const step = Math.abs(this.interval);\n      if (!isDenseInterval((d1 - d0) / step, this.getPixelRange())) {\n        return range(d0, d1, step);\n      }\n    }\n    return createTicks(d0, d1, count, this.minTickCount, this.maxTickCount);\n  }\n  update() {\n    if (!this.domain || this.domain.length < 2) {\n      return;\n    }\n    if (this.nice) {\n      this.updateNiceDomain();\n    }\n  }\n  getTickStep(start2, stop) {\n    return this.interval ?? tickStep(start2, stop, this.tickCount, this.minTickCount, this.maxTickCount);\n  }\n  /**\n   * Extends the domain so that it starts and ends on nice round values.\n   */\n  updateNiceDomain() {\n    const count = this.tickCount;\n    if (count < 1) {\n      this.niceDomain = [...this.domain];\n      return;\n    }\n    let [start2, stop] = this.domain;\n    if (count === 1) {\n      [start2, stop] = niceTicksDomain(start2, stop);\n    } else {\n      const roundStart = start2 > stop ? Math.ceil : Math.floor;\n      const roundStop = stop < start2 ? Math.floor : Math.ceil;\n      const maxAttempts = 4;\n      for (let i = 0; i < maxAttempts; i++) {\n        const prev0 = start2;\n        const prev1 = stop;\n        const step = this.getTickStep(start2, stop);\n        const [d0, d1] = this.domain;\n        if (step >= 1) {\n          start2 = roundStart(d0 / step) * step;\n          stop = roundStop(d1 / step) * step;\n        } else {\n          const s = 1 / step;\n          start2 = roundStart(d0 * s) / s;\n          stop = roundStop(d1 * s) / s;\n        }\n        if (start2 === prev0 && stop === prev1) {\n          break;\n        }\n      }\n    }\n    this.niceDomain = [start2, stop];\n  }\n  tickFormat({ ticks: specifiedTicks, specifier }) {\n    return tickFormat(specifiedTicks ?? this.ticks(), specifier);\n  }\n};\n\n// packages/ag-charts-community/src/util/secondaryAxisTicks.ts\nfunction calculateNiceSecondaryAxis(domain, primaryTickCount, reverse) {\n  let [start2, stop] = findMinMax(domain);\n  start2 = calculateNiceStart(Math.floor(start2), stop, primaryTickCount);\n  const step = getTickStep(start2, stop, primaryTickCount);\n  const segments = primaryTickCount - 1;\n  stop = start2 + segments * step;\n  const d = reverse ? [stop, start2] : [start2, stop];\n  const ticks = getTicks(start2, step, primaryTickCount);\n  return { domain: d, ticks };\n}\nfunction calculateNiceStart(a, b, count) {\n  const rawStep = Math.abs(b - a) / (count - 1);\n  const order = Math.floor(Math.log10(rawStep));\n  const magnitude = Math.pow(10, order);\n  return Math.floor(a / magnitude) * magnitude;\n}\nfunction getTicks(start2, step, count) {\n  const stepPower = Math.floor(Math.log10(step));\n  const fractionDigits = step > 0 && step < 1 ? Math.abs(stepPower) : 0;\n  const f = Math.pow(10, fractionDigits);\n  const ticks = [];\n  for (let i = 0; i < count; i++) {\n    const tick = start2 + step * i;\n    ticks[i] = Math.round(tick * f) / f;\n  }\n  return ticks;\n}\nfunction getTickStep(start2, stop, count) {\n  const segments = count - 1;\n  const rawStep = (stop - start2) / segments;\n  return calculateNextNiceStep(rawStep);\n}\nfunction calculateNextNiceStep(rawStep) {\n  const order = Math.floor(Math.log10(rawStep));\n  const magnitude = Math.pow(10, order);\n  const step = rawStep / magnitude * 10;\n  if (step > 0 && step <= 1) {\n    return magnitude / 10;\n  }\n  if (step > 1 && step <= 2) {\n    return 2 * magnitude / 10;\n  }\n  if (step > 1 && step <= 5) {\n    return 5 * magnitude / 10;\n  }\n  if (step > 5 && step <= 10) {\n    return 10 * magnitude / 10;\n  }\n  if (step > 10 && step <= 20) {\n    return 20 * magnitude / 10;\n  }\n  if (step > 20 && step <= 40) {\n    return 40 * magnitude / 10;\n  }\n  if (step > 40 && step <= 50) {\n    return 50 * magnitude / 10;\n  }\n  if (step > 50 && step <= 100) {\n    return 100 * magnitude / 10;\n  }\n  return step;\n}\n\n// packages/ag-charts-community/src/chart/axis/numberAxis.ts\nvar NumberAxis = class extends CartesianAxis {\n  constructor(moduleCtx, scale2 = new LinearScale()) {\n    super(moduleCtx, scale2);\n    this.min = NaN;\n    this.max = NaN;\n  }\n  normaliseDataDomain(d) {\n    const { min, max } = this;\n    const { extent: extent2, clipped } = normalisedExtentWithMetadata(d, min, max);\n    return { domain: extent2, clipped };\n  }\n  updateSecondaryAxisTicks(primaryTickCount) {\n    if (this.dataDomain == null) {\n      throw new Error(\"AG Charts - dataDomain not calculated, cannot perform tick calculation.\");\n    }\n    if (this.dataDomain.domain.length === 0) {\n      return [];\n    }\n    const { domain, ticks } = calculateNiceSecondaryAxis(\n      this.dataDomain.domain,\n      primaryTickCount ?? 0,\n      this.reverse\n    );\n    this.scale.nice = false;\n    this.scale.domain = domain;\n    this.scale.update();\n    return ticks;\n  }\n};\nNumberAxis.className = \"NumberAxis\";\nNumberAxis.type = \"number\";\n__decorateClass([\n  Validate(AND(NUMBER_OR_NAN, LESS_THAN(\"max\"))),\n  Default(NaN)\n], NumberAxis.prototype, \"min\", 2);\n__decorateClass([\n  Validate(AND(NUMBER_OR_NAN, GREATER_THAN(\"min\"))),\n  Default(NaN)\n], NumberAxis.prototype, \"max\", 2);\n\n// packages/ag-charts-community/src/chart/axis/logAxis.ts\nvar NON_ZERO_NUMBER = predicateWithMessage((value) => isNumber(value) && value !== 0, \"a non-zero number\");\nvar LogAxis = class extends NumberAxis {\n  constructor(moduleCtx) {\n    super(moduleCtx, new LogScale());\n    this.min = NaN;\n    this.max = NaN;\n  }\n  normaliseDataDomain(d) {\n    const { min, max } = this;\n    const { extent: extent2, clipped } = normalisedExtentWithMetadata(d, min, max);\n    const isInverted = extent2[0] > extent2[1];\n    const crossesZero = extent2[0] < 0 && extent2[1] > 0;\n    const hasZeroExtent = extent2[0] === 0 && extent2[1] === 0;\n    const invalidDomain = isInverted || crossesZero || hasZeroExtent;\n    if (invalidDomain) {\n      if (crossesZero) {\n        Logger.warn(\n          `the data domain crosses zero, the chart data cannot be rendered. See log axis documentation for more information.`\n        );\n      } else if (hasZeroExtent) {\n        Logger.warn(`the data domain has 0 extent, no data is rendered.`);\n      }\n    }\n    if (extent2[0] === 0) {\n      extent2[0] = 1;\n    }\n    if (extent2[1] === 0) {\n      extent2[1] = -1;\n    }\n    return { domain: extent2, clipped };\n  }\n  set base(value) {\n    this.scale.base = value;\n  }\n  get base() {\n    return this.scale.base;\n  }\n};\nLogAxis.className = \"LogAxis\";\nLogAxis.type = \"log\";\n__decorateClass([\n  Validate(AND(NUMBER_OR_NAN, NON_ZERO_NUMBER, LESS_THAN(\"max\"))),\n  Default(NaN)\n], LogAxis.prototype, \"min\", 2);\n__decorateClass([\n  Validate(AND(NUMBER_OR_NAN, NON_ZERO_NUMBER, GREATER_THAN(\"min\"))),\n  Default(NaN)\n], LogAxis.prototype, \"max\", 2);\n\n// packages/ag-charts-community/src/chart/axis/timeAxis.ts\nvar TimeAxis = class extends CartesianAxis {\n  constructor(moduleCtx) {\n    super(moduleCtx, new TimeScale());\n    this.min = void 0;\n    this.max = void 0;\n  }\n  normaliseDataDomain(d) {\n    let { min, max } = this;\n    let clipped = false;\n    if (typeof min === \"number\") {\n      min = new Date(min);\n    }\n    if (typeof max === \"number\") {\n      max = new Date(max);\n    }\n    if (d.length > 2) {\n      d = extent(d)?.map((x) => new Date(x)) ?? [];\n    }\n    if (min instanceof Date) {\n      clipped || (clipped = min > d[0]);\n      d = [min, d[1]];\n    }\n    if (max instanceof Date) {\n      clipped || (clipped = max < d[1]);\n      d = [d[0], max];\n    }\n    if (d[0] > d[1]) {\n      d = [];\n    }\n    return { domain: d, clipped };\n  }\n  onFormatChange(ticks, fractionDigits, domain, format) {\n    if (format) {\n      super.onFormatChange(ticks, fractionDigits, domain, format);\n    } else {\n      this.labelFormatter = this.scale.tickFormat({ ticks, domain });\n      this.datumFormatter = this.scale.tickFormat({ ticks, domain, formatOffset: 1 });\n    }\n  }\n};\nTimeAxis.className = \"TimeAxis\";\nTimeAxis.type = \"time\";\n__decorateClass([\n  Validate(AND(DATE_OR_DATETIME_MS, LESS_THAN(\"max\")), { optional: true })\n], TimeAxis.prototype, \"min\", 2);\n__decorateClass([\n  Validate(AND(DATE_OR_DATETIME_MS, GREATER_THAN(\"min\")), { optional: true })\n], TimeAxis.prototype, \"max\", 2);\n\n// packages/ag-charts-community/src/scene/util/corner.ts\nvar drawCorner = (path, { x0, y0, x1, y1, cx, cy }, cornerRadius, move) => {\n  if (move) {\n    path.moveTo(x0, y0);\n  }\n  if (x0 !== x1 || y0 !== y1) {\n    const r0 = Math.atan2(y0 - cy, x0 - cx);\n    const r1 = Math.atan2(y1 - cy, x1 - cx);\n    path.arc(cx, cy, cornerRadius, r0, r1);\n  } else {\n    path.lineTo(x0, y0);\n  }\n};\n\n// packages/ag-charts-community/src/scene/shape/rect.ts\nvar epsilon = 1e-6;\nvar cornerEdges = (leadingEdge, trailingEdge, leadingInset, trailingInset, cornerRadius) => {\n  let leadingClipped = false;\n  let trailingClipped = false;\n  let leading0 = trailingInset - Math.sqrt(Math.max(cornerRadius ** 2 - leadingInset ** 2, 0));\n  let leading1 = 0;\n  let trailing0 = 0;\n  let trailing1 = leadingInset - Math.sqrt(Math.max(cornerRadius ** 2 - trailingInset ** 2, 0));\n  if (leading0 > leadingEdge) {\n    leadingClipped = true;\n    leading0 = leadingEdge;\n    leading1 = leadingInset - Math.sqrt(Math.max(cornerRadius ** 2 - (trailingInset - leadingEdge) ** 2));\n  } else if (leading0 < epsilon) {\n    leading0 = 0;\n  }\n  if (trailing1 > trailingEdge) {\n    trailingClipped = true;\n    trailing0 = trailingInset - Math.sqrt(Math.max(cornerRadius ** 2 - (leadingInset - trailingEdge) ** 2));\n    trailing1 = trailingEdge;\n  } else if (trailing1 < epsilon) {\n    trailing1 = 0;\n  }\n  return { leading0, leading1, trailing0, trailing1, leadingClipped, trailingClipped };\n};\nvar insetCornerRadiusRect = (path, x, y, width2, height2, cornerRadii, clipBBox) => {\n  let {\n    topLeft: topLeftCornerRadius,\n    topRight: topRightCornerRadius,\n    bottomRight: bottomRightCornerRadius,\n    bottomLeft: bottomLeftCornerRadius\n  } = cornerRadii;\n  const maxVerticalCornerRadius = Math.max(\n    topLeftCornerRadius + bottomLeftCornerRadius,\n    topRightCornerRadius + bottomRightCornerRadius\n  );\n  const maxHorizontalCornerRadius = Math.max(\n    topLeftCornerRadius + topRightCornerRadius,\n    bottomLeftCornerRadius + bottomRightCornerRadius\n  );\n  if (maxVerticalCornerRadius <= 0 && maxHorizontalCornerRadius <= 0) {\n    if (clipBBox == null) {\n      path.rect(x, y, width2, height2);\n    } else {\n      path.rect(clipBBox.x, clipBBox.y, clipBBox.width, clipBBox.height);\n    }\n    return;\n  } else if (clipBBox == null && topLeftCornerRadius === topRightCornerRadius && topLeftCornerRadius === bottomRightCornerRadius && topLeftCornerRadius === bottomLeftCornerRadius) {\n    path.roundRect(x, y, width2, height2, topLeftCornerRadius);\n    return;\n  }\n  if (width2 < 0) {\n    x += width2;\n    width2 = Math.abs(width2);\n  }\n  if (height2 < 0) {\n    y += height2;\n    height2 = Math.abs(height2);\n  }\n  if (width2 <= 0 || height2 <= 0)\n    return;\n  if (clipBBox == null) {\n    clipBBox = new BBox(x, y, width2, height2);\n  } else {\n    const x0 = Math.max(x, clipBBox.x);\n    const x1 = Math.min(x + width2, clipBBox.x + clipBBox.width);\n    const y0 = Math.max(y, clipBBox.y);\n    const y1 = Math.min(y + height2, clipBBox.y + clipBBox.height);\n    clipBBox = new BBox(x0, y0, x1 - x0, y1 - y0);\n  }\n  const borderScale = Math.max(maxVerticalCornerRadius / height2, maxHorizontalCornerRadius / width2, 1);\n  if (borderScale > 1) {\n    topLeftCornerRadius /= borderScale;\n    topRightCornerRadius /= borderScale;\n    bottomRightCornerRadius /= borderScale;\n    bottomLeftCornerRadius /= borderScale;\n  }\n  let drawTopLeftCorner = true;\n  let drawTopRightCorner = true;\n  let drawBottomRightCorner = true;\n  let drawBottomLeftCorner = true;\n  let topLeftCorner;\n  let topRightCorner;\n  let bottomRightCorner;\n  let bottomLeftCorner;\n  if (drawTopLeftCorner) {\n    const nodes = cornerEdges(\n      clipBBox.height,\n      clipBBox.width,\n      Math.max(x + topLeftCornerRadius - clipBBox.x, 0),\n      Math.max(y + topLeftCornerRadius - clipBBox.y, 0),\n      topLeftCornerRadius\n    );\n    if (nodes.leadingClipped)\n      drawBottomLeftCorner = false;\n    if (nodes.trailingClipped)\n      drawTopRightCorner = false;\n    const x0 = Math.max(clipBBox.x + nodes.leading1, clipBBox.x);\n    const y0 = Math.max(clipBBox.y + nodes.leading0, clipBBox.y);\n    const x1 = Math.max(clipBBox.x + nodes.trailing1, clipBBox.x);\n    const y1 = Math.max(clipBBox.y + nodes.trailing0, clipBBox.y);\n    const cx = x + topLeftCornerRadius;\n    const cy = y + topLeftCornerRadius;\n    topLeftCorner = { x0, y0, x1, y1, cx, cy };\n  }\n  if (drawTopRightCorner) {\n    const nodes = cornerEdges(\n      clipBBox.width,\n      clipBBox.height,\n      Math.max(y + topRightCornerRadius - clipBBox.y, 0),\n      Math.max(clipBBox.x + clipBBox.width - (x + width2 - topRightCornerRadius), 0),\n      topRightCornerRadius\n    );\n    if (nodes.leadingClipped)\n      drawTopLeftCorner = false;\n    if (nodes.trailingClipped)\n      drawBottomRightCorner = false;\n    const x0 = Math.min(clipBBox.x + clipBBox.width - nodes.leading0, clipBBox.x + clipBBox.width);\n    const y0 = Math.max(clipBBox.y + nodes.leading1, clipBBox.y);\n    const x1 = Math.min(clipBBox.x + clipBBox.width - nodes.trailing0, clipBBox.x + clipBBox.width);\n    const y1 = Math.max(clipBBox.y + nodes.trailing1, clipBBox.y);\n    const cx = x + width2 - topRightCornerRadius;\n    const cy = y + topRightCornerRadius;\n    topRightCorner = { x0, y0, x1, y1, cx, cy };\n  }\n  if (drawBottomRightCorner) {\n    const nodes = cornerEdges(\n      clipBBox.height,\n      clipBBox.width,\n      Math.max(clipBBox.x + clipBBox.width - (x + width2 - bottomRightCornerRadius), 0),\n      Math.max(clipBBox.y + clipBBox.height - (y + height2 - bottomRightCornerRadius), 0),\n      bottomRightCornerRadius\n    );\n    if (nodes.leadingClipped)\n      drawTopRightCorner = false;\n    if (nodes.trailingClipped)\n      drawBottomLeftCorner = false;\n    const x0 = Math.min(clipBBox.x + clipBBox.width - nodes.leading1, clipBBox.x + clipBBox.width);\n    const y0 = Math.min(clipBBox.y + clipBBox.height - nodes.leading0, clipBBox.y + clipBBox.height);\n    const x1 = Math.min(clipBBox.x + clipBBox.width - nodes.trailing1, clipBBox.x + clipBBox.width);\n    const y1 = Math.min(clipBBox.y + clipBBox.height - nodes.trailing0, clipBBox.y + clipBBox.height);\n    const cx = x + width2 - bottomRightCornerRadius;\n    const cy = y + height2 - bottomRightCornerRadius;\n    bottomRightCorner = { x0, y0, x1, y1, cx, cy };\n  }\n  if (drawBottomLeftCorner) {\n    const nodes = cornerEdges(\n      clipBBox.width,\n      clipBBox.height,\n      Math.max(clipBBox.y + clipBBox.height - (y + height2 - bottomLeftCornerRadius), 0),\n      Math.max(x + bottomLeftCornerRadius - clipBBox.x, 0),\n      bottomLeftCornerRadius\n    );\n    if (nodes.leadingClipped)\n      drawBottomRightCorner = false;\n    if (nodes.trailingClipped)\n      drawTopLeftCorner = false;\n    const x0 = Math.max(clipBBox.x + nodes.leading0, clipBBox.x);\n    const y0 = Math.min(clipBBox.y + clipBBox.height - nodes.leading1, clipBBox.y + clipBBox.height);\n    const x1 = Math.max(clipBBox.x + nodes.trailing0, clipBBox.x);\n    const y1 = Math.min(clipBBox.y + clipBBox.height - nodes.trailing1, clipBBox.y + clipBBox.height);\n    const cx = x + bottomLeftCornerRadius;\n    const cy = y + height2 - bottomLeftCornerRadius;\n    bottomLeftCorner = { x0, y0, x1, y1, cx, cy };\n  }\n  let didMove = false;\n  if (drawTopLeftCorner && topLeftCorner != null) {\n    drawCorner(path, topLeftCorner, topLeftCornerRadius, !didMove);\n    didMove || (didMove = true);\n  }\n  if (drawTopRightCorner && topRightCorner != null) {\n    drawCorner(path, topRightCorner, topRightCornerRadius, !didMove);\n    didMove || (didMove = true);\n  }\n  if (drawBottomRightCorner && bottomRightCorner != null) {\n    drawCorner(path, bottomRightCorner, bottomRightCornerRadius, !didMove);\n    didMove || (didMove = true);\n  }\n  if (drawBottomLeftCorner && bottomLeftCorner != null) {\n    drawCorner(path, bottomLeftCorner, bottomLeftCornerRadius, !didMove);\n    didMove || (didMove = true);\n  }\n  path.closePath();\n};\nvar Rect = class extends Path {\n  constructor() {\n    super(...arguments);\n    this.borderPath = new ExtendedPath2D();\n    this.x = 0;\n    this.y = 0;\n    this.width = 10;\n    this.height = 10;\n    this.topLeftCornerRadius = 0;\n    this.topRightCornerRadius = 0;\n    this.bottomRightCornerRadius = 0;\n    this.bottomLeftCornerRadius = 0;\n    this.clipBBox = void 0;\n    this.crisp = false;\n    this.lastUpdatePathStrokeWidth = Shape.defaultStyles.strokeWidth;\n    this.effectiveStrokeWidth = Shape.defaultStyles.strokeWidth;\n    this.hittester = super.isPointInPath;\n    this.distanceCalculator = super.distanceSquaredTransformedPoint;\n    /**\n     * When the rectangle's width or height is less than a pixel\n     * and crisp mode is on, the rectangle will still fit into the pixel,\n     * but will be less opaque to make an effect of holding less space.\n     */\n    this.microPixelEffectOpacity = 1;\n  }\n  set cornerRadius(cornerRadius) {\n    this.topLeftCornerRadius = cornerRadius;\n    this.topRightCornerRadius = cornerRadius;\n    this.bottomRightCornerRadius = cornerRadius;\n    this.bottomLeftCornerRadius = cornerRadius;\n  }\n  isDirtyPath() {\n    return this.lastUpdatePathStrokeWidth !== this.strokeWidth || Boolean(this.path.isDirty() || this.borderPath.isDirty());\n  }\n  updatePath() {\n    const {\n      path,\n      borderPath,\n      crisp,\n      topLeftCornerRadius: topLeft,\n      topRightCornerRadius: topRight,\n      bottomRightCornerRadius: bottomRight,\n      bottomLeftCornerRadius: bottomLeft\n    } = this;\n    let { x, y, width: w, height: h, strokeWidth, clipBBox } = this;\n    const pixelRatio = this.layerManager?.canvas.pixelRatio ?? 1;\n    const pixelSize = 1 / pixelRatio;\n    let microPixelEffectOpacity = 1;\n    path.clear(true);\n    borderPath.clear(true);\n    if (crisp) {\n      if (w <= pixelSize) {\n        microPixelEffectOpacity *= w / pixelSize;\n      }\n      if (h <= pixelSize) {\n        microPixelEffectOpacity *= h / pixelSize;\n      }\n      w = this.align(x, w);\n      h = this.align(y, h);\n      x = this.align(x);\n      y = this.align(y);\n      clipBBox = clipBBox != null ? new BBox(\n        this.align(clipBBox.x),\n        this.align(clipBBox.y),\n        this.align(clipBBox.x, clipBBox.width),\n        this.align(clipBBox.y, clipBBox.height)\n      ) : void 0;\n    }\n    if (strokeWidth) {\n      if (w < pixelSize) {\n        const lx = x + pixelSize / 2;\n        borderPath.moveTo(lx, y);\n        borderPath.lineTo(lx, y + h);\n        strokeWidth = pixelSize;\n        this.borderClipPath = void 0;\n      } else if (h < pixelSize) {\n        const ly = y + pixelSize / 2;\n        borderPath.moveTo(x, ly);\n        borderPath.lineTo(x + w, ly);\n        strokeWidth = pixelSize;\n        this.borderClipPath = void 0;\n      } else if (strokeWidth < w && strokeWidth < h) {\n        const halfStrokeWidth = strokeWidth / 2;\n        x += halfStrokeWidth;\n        y += halfStrokeWidth;\n        w -= strokeWidth;\n        h -= strokeWidth;\n        const adjustedClipBBox = clipBBox?.clone().shrink(halfStrokeWidth);\n        const cornerRadii = {\n          topLeft: topLeft > 0 ? topLeft - strokeWidth : 0,\n          topRight: topRight > 0 ? topRight - strokeWidth : 0,\n          bottomRight: bottomRight > 0 ? bottomRight - strokeWidth : 0,\n          bottomLeft: bottomLeft > 0 ? bottomLeft - strokeWidth : 0\n        };\n        this.borderClipPath = void 0;\n        if (w > 0 && h > 0 && (adjustedClipBBox == null || adjustedClipBBox?.width > 0 && adjustedClipBBox?.height > 0)) {\n          insetCornerRadiusRect(path, x, y, w, h, cornerRadii, adjustedClipBBox);\n          insetCornerRadiusRect(borderPath, x, y, w, h, cornerRadii, adjustedClipBBox);\n        }\n      } else {\n        this.borderClipPath = this.borderClipPath ?? new ExtendedPath2D();\n        this.borderClipPath.clear(true);\n        this.borderClipPath.rect(x, y, w, h);\n        borderPath.rect(x, y, w, h);\n      }\n    } else {\n      const cornerRadii = { topLeft, topRight, bottomRight, bottomLeft };\n      this.borderClipPath = void 0;\n      insetCornerRadiusRect(path, x, y, w, h, cornerRadii, clipBBox);\n    }\n    if ([topLeft, topRight, bottomRight, bottomLeft].every((r) => r === 0)) {\n      const bbox = this.getBBox();\n      this.hittester = bbox.containsPoint.bind(bbox);\n      this.distanceSquared = (hitX, hitY) => this.getBBox().distanceSquared(hitX, hitY);\n    } else {\n      this.hittester = super.isPointInPath;\n      this.distanceCalculator = super.distanceSquaredTransformedPoint;\n    }\n    this.effectiveStrokeWidth = strokeWidth;\n    this.lastUpdatePathStrokeWidth = strokeWidth;\n    this.microPixelEffectOpacity = microPixelEffectOpacity;\n  }\n  computeBBox() {\n    const { x, y, width: width2, height: height2, clipBBox } = this;\n    return clipBBox?.clone() ?? new BBox(x, y, width2, height2);\n  }\n  isPointInPath(x, y) {\n    return this.hittester(x, y);\n  }\n  get midPoint() {\n    return { x: this.x + this.width / 2, y: this.y + this.height / 2 };\n  }\n  distanceSquared(x, y) {\n    return this.distanceCalculator(x, y);\n  }\n  applyFillAlpha(ctx) {\n    const { fillOpacity, microPixelEffectOpacity, opacity } = this;\n    ctx.globalAlpha *= opacity * fillOpacity * microPixelEffectOpacity;\n  }\n  renderStroke(ctx) {\n    const { stroke, effectiveStrokeWidth } = this;\n    if (stroke && effectiveStrokeWidth) {\n      const { globalAlpha } = ctx;\n      const {\n        strokeOpacity,\n        lineDash,\n        lineDashOffset,\n        lineCap,\n        lineJoin,\n        borderPath,\n        borderClipPath,\n        opacity,\n        microPixelEffectOpacity\n      } = this;\n      if (borderClipPath) {\n        ctx.clip(borderClipPath.getPath2D());\n      }\n      ctx.strokeStyle = stroke;\n      ctx.globalAlpha *= opacity * strokeOpacity * microPixelEffectOpacity;\n      ctx.lineWidth = effectiveStrokeWidth;\n      if (lineDash) {\n        ctx.setLineDash(lineDash);\n      }\n      if (lineDashOffset) {\n        ctx.lineDashOffset = lineDashOffset;\n      }\n      if (lineCap) {\n        ctx.lineCap = lineCap;\n      }\n      if (lineJoin) {\n        ctx.lineJoin = lineJoin;\n      }\n      ctx.stroke(borderPath.getPath2D());\n      ctx.globalAlpha = globalAlpha;\n    }\n  }\n};\nRect.className = \"Rect\";\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"x\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"y\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"width\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"height\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"topLeftCornerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"topRightCornerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"bottomRightCornerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"bottomLeftCornerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"clipBBox\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"crisp\", 2);\n\n// packages/ag-charts-community/src/chart/background/background.ts\nvar Background = class extends BaseModuleInstance {\n  constructor(ctx) {\n    super();\n    this.ctx = ctx;\n    this.rectNode = new Rect();\n    this.textNode = new Text();\n    this.fill = \"white\";\n    this.node = this.createNode();\n    this.node.append([this.rectNode, this.textNode]);\n    this.visible = true;\n    this.destroyFns.push(\n      ctx.scene.attachNode(this.node),\n      ctx.layoutManager.addListener(\"layout:complete\", (e) => this.onLayoutComplete(e))\n    );\n  }\n  createNode() {\n    return new Group({ name: \"background\", zIndex: 0 /* SERIES_BACKGROUND */ });\n  }\n  onLayoutComplete(e) {\n    const { width: width2, height: height2 } = e.chart;\n    this.rectNode.width = width2;\n    this.rectNode.height = height2;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN),\n  ProxyPropertyOnWrite(\"node\", \"visible\")\n], Background.prototype, \"visible\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true }),\n  ProxyPropertyOnWrite(\"rectNode\", \"fill\")\n], Background.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(OBJECT, { optional: true })\n], Background.prototype, \"image\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true }),\n  ProxyPropertyOnWrite(\"textNode\")\n], Background.prototype, \"text\", 2);\n\n// packages/ag-charts-community/src/chart/background/backgroundModule.ts\nvar BackgroundModule = {\n  type: \"root\",\n  optionsKey: \"background\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\", \"standalone\", \"gauge\"],\n  moduleFactory: (ctx) => new Background(ctx)\n};\n\n// packages/ag-charts-community/src/chart/gridLayout.ts\nfunction gridLayout({\n  orientation,\n  bboxes,\n  maxHeight,\n  maxWidth,\n  itemPaddingY = 0,\n  itemPaddingX = 0,\n  forceResult = false\n}) {\n  const horizontal = orientation === \"horizontal\";\n  const primary = {\n    max: horizontal ? maxWidth : maxHeight,\n    fn: horizontal ? (b) => b.width : (b) => b.height,\n    padding: horizontal ? itemPaddingX : itemPaddingY\n  };\n  const secondary = {\n    max: horizontal ? maxHeight : maxWidth,\n    fn: horizontal ? (b) => b.height : (b) => b.width,\n    padding: horizontal ? itemPaddingY : itemPaddingX\n  };\n  let processedBBoxCount = 0;\n  const rawPages = [];\n  while (processedBBoxCount < bboxes.length) {\n    const unprocessedBBoxes = bboxes.slice(processedBBoxCount);\n    const result = processBBoxes(unprocessedBBoxes, processedBBoxCount, primary, secondary, forceResult);\n    if (!result) {\n      return;\n    }\n    processedBBoxCount += result.processedBBoxCount;\n    rawPages.push(result.pageIndices);\n  }\n  return buildPages(rawPages, orientation, bboxes, itemPaddingY, itemPaddingX);\n}\nfunction processBBoxes(bboxes, indexOffset, primary, secondary, forceResult) {\n  const minGuess = 1;\n  let startingGuess = estimateStartingGuess(bboxes, primary);\n  if (startingGuess < minGuess) {\n    if (!forceResult) {\n      return;\n    }\n    startingGuess = minGuess;\n  }\n  let guess = startingGuess;\n  while (guess >= minGuess) {\n    const pageIndices = calculatePage(bboxes, indexOffset, guess, primary, secondary, forceResult);\n    if (pageIndices == null && guess <= minGuess) {\n      return;\n    }\n    if (pageIndices == null) {\n      guess--;\n      continue;\n    }\n    if (typeof pageIndices === \"number\") {\n      if (pageIndices <= minGuess) {\n        return;\n      }\n      guess = pageIndices < guess && pageIndices > minGuess ? pageIndices : guess;\n      guess--;\n      continue;\n    }\n    const processedBBoxCount = pageIndices.length * pageIndices[0].length;\n    return { processedBBoxCount, pageIndices };\n  }\n}\nfunction calculatePage(bboxes, indexOffset, primaryCount, primary, secondary, forceResult) {\n  const result = [];\n  let sumSecondary = 0;\n  let currentMaxSecondary = 0;\n  let currentPrimaryIndices = [];\n  const maxPrimaryValues = [];\n  for (let bboxIndex = 0; bboxIndex < bboxes.length; bboxIndex++) {\n    const primaryValueIdx = (bboxIndex + primaryCount) % primaryCount;\n    if (primaryValueIdx === 0) {\n      sumSecondary += currentMaxSecondary;\n      currentMaxSecondary = 0;\n      if (currentPrimaryIndices.length > 0) {\n        result.push(currentPrimaryIndices);\n      }\n      currentPrimaryIndices = [];\n    }\n    const primaryValue = primary.fn(bboxes[bboxIndex]) + primary.padding;\n    maxPrimaryValues[primaryValueIdx] = Math.max(maxPrimaryValues[primaryValueIdx] ?? 0, primaryValue);\n    currentMaxSecondary = Math.max(currentMaxSecondary, secondary.fn(bboxes[bboxIndex]) + secondary.padding);\n    const currentSecondaryDimension = sumSecondary + currentMaxSecondary;\n    const returnResult = !forceResult || result.length > 0;\n    if (currentSecondaryDimension > secondary.max && returnResult) {\n      currentPrimaryIndices = [];\n      break;\n    }\n    const sumPrimary = maxPrimaryValues.reduce((sum2, next) => sum2 + next, 0);\n    if (sumPrimary > primary.max && !forceResult) {\n      if (maxPrimaryValues.length < primaryCount) {\n        return maxPrimaryValues.length;\n      }\n      return;\n    }\n    currentPrimaryIndices.push(bboxIndex + indexOffset);\n  }\n  if (currentPrimaryIndices.length > 0) {\n    result.push(currentPrimaryIndices);\n  }\n  return result.length > 0 ? result : void 0;\n}\nfunction buildPages(rawPages, orientation, bboxes, itemPaddingY, itemPaddingX) {\n  let maxPageWidth = 0;\n  let maxPageHeight = 0;\n  const pages = rawPages.map((indices) => {\n    if (orientation === \"horizontal\") {\n      indices = transpose(indices);\n    }\n    let endIndex = 0;\n    const columns = indices.map((colIndices) => {\n      const colBBoxes = colIndices.map((bboxIndex) => {\n        endIndex = Math.max(bboxIndex, endIndex);\n        return bboxes[bboxIndex];\n      });\n      let columnHeight = 0;\n      let columnWidth = 0;\n      colBBoxes.forEach((bbox) => {\n        columnHeight += bbox.height + itemPaddingY;\n        columnWidth = Math.max(columnWidth, bbox.width + itemPaddingX);\n      });\n      return {\n        indices: colIndices,\n        bboxes: colBBoxes,\n        columnHeight: Math.ceil(columnHeight),\n        columnWidth: Math.ceil(columnWidth)\n      };\n    });\n    let pageWidth = 0;\n    let pageHeight = 0;\n    columns.forEach((column) => {\n      pageWidth += column.columnWidth;\n      pageHeight = Math.max(pageHeight, column.columnHeight);\n    });\n    maxPageWidth = Math.max(pageWidth, maxPageWidth);\n    maxPageHeight = Math.max(pageHeight, maxPageHeight);\n    return {\n      columns,\n      startIndex: indices[0][0],\n      endIndex,\n      pageWidth,\n      pageHeight\n    };\n  });\n  return { pages, maxPageWidth, maxPageHeight };\n}\nfunction transpose(data) {\n  const result = [];\n  for (const _ of data[0]) {\n    result.push([]);\n  }\n  data.forEach((innerData, dataIdx) => {\n    innerData.forEach((item, itemIdx) => {\n      result[itemIdx][dataIdx] = item;\n    });\n  });\n  return result;\n}\nfunction estimateStartingGuess(bboxes, primary) {\n  const n = bboxes.length;\n  let primarySum = 0;\n  for (let bboxIndex = 0; bboxIndex < n; bboxIndex++) {\n    primarySum += primary.fn(bboxes[bboxIndex]) + primary.padding;\n    if (primarySum > primary.max) {\n      const ratio2 = n / bboxIndex;\n      if (ratio2 < 2) {\n        return Math.ceil(n / 2);\n      }\n      return bboxIndex;\n    }\n  }\n  return n;\n}\n\n// packages/ag-charts-community/src/scene/image.ts\nvar Image = class extends Node {\n  constructor(sourceImage) {\n    super();\n    this.sourceImage = sourceImage;\n    this.x = 0;\n    this.y = 0;\n    this.width = 0;\n    this.height = 0;\n    this.opacity = 1;\n  }\n  updateBitmap(newBitmap, bitmapPixelRatio, x, y) {\n    this.sourceImage = newBitmap;\n    this.width = newBitmap.width / bitmapPixelRatio;\n    this.height = newBitmap.height / bitmapPixelRatio;\n    this.x = x / bitmapPixelRatio;\n    this.y = y / bitmapPixelRatio;\n    this.markDirty(3 /* MAJOR */);\n  }\n  render(renderCtx) {\n    const { ctx, forceRender, stats } = renderCtx;\n    if (this.dirty === 0 /* NONE */ && !forceRender) {\n      if (stats)\n        stats.nodesSkipped++;\n      return;\n    }\n    const image = this.sourceImage;\n    if (!image)\n      return;\n    ctx.globalAlpha = this.opacity;\n    ctx.drawImage(image, 0, 0, image.width, image.height, this.x, this.y, this.width, this.height);\n    super.render(renderCtx);\n  }\n};\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Image.prototype, \"x\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Image.prototype, \"y\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Image.prototype, \"width\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Image.prototype, \"height\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Image.prototype, \"opacity\", 2);\n\n// packages/ag-charts-community/src/chart/legendMarkerLabel.ts\nvar LegendMarkerLabel = class extends Translatable(Group) {\n  constructor() {\n    super({ name: \"markerLabelGroup\" });\n    this.label = new Text();\n    this.symbolsGroup = new Group({\n      name: \"legend-markerLabel-symbols\"\n    });\n    this.bitmap = new Image();\n    this.bitmapDirty = true;\n    this.enabled = true;\n    this.pageIndex = NaN;\n    this._markers = [];\n    this._lines = [];\n    const { markers, label, lines } = this;\n    label.textBaseline = \"middle\";\n    label.fontSize = 12;\n    label.fontFamily = \"Verdana, sans-serif\";\n    label.fill = \"black\";\n    label.y = 1;\n    this.updateSymbols(markers, lines);\n    this.append([this.symbolsGroup, label]);\n  }\n  destroy() {\n    super.destroy();\n    this.destroyProxyButton();\n  }\n  destroyProxyButton() {\n    this.proxyButton?.button.remove();\n    this.proxyButton?.listitem.remove();\n    this.proxyButton = void 0;\n  }\n  get markers() {\n    return this._markers;\n  }\n  get lines() {\n    return this._lines;\n  }\n  updateSymbols(markers, lines) {\n    if (arraysEqual(this._markers, markers) && arraysEqual(this._lines, lines))\n      return;\n    this.bitmapDirty = true;\n    this._markers = markers;\n    this._lines = lines;\n    this.symbolsGroup.clear();\n    this.symbolsGroup.append([this.bitmap, ...lines, ...markers]);\n  }\n  setEnabled(enabled) {\n    this.enabled = enabled;\n    this.refreshVisibilities();\n  }\n  refreshVisibilities() {\n    const opacity = this.enabled ? 1 : 0.5;\n    this.label.opacity = opacity;\n    this.opacity = opacity;\n    this.bitmap.opacity = opacity;\n    this.setBitmapVisibility(!this.enabled);\n  }\n  setBitmapVisibility(visible) {\n    const { lines, markers } = this;\n    [lines, markers].forEach((shapes) => shapes.forEach((shape) => shape.visible = !visible));\n    this.bitmap.visible = visible;\n  }\n  // The BBox of this.bitmap is `spritePadding` pixels bigger in each direction than BBox of the markers and lines.\n  // This padding allows the SpriteRenderer to draw antialiasing pixels that can extend beyond the shapes' bounds.\n  update(spriteRenderer, { spriteAAPadding, spritePixelRatio: scale2 }, dimensionProps) {\n    const { markers, lines } = this;\n    let spriteX = 0;\n    let spriteY = 0;\n    let shift = 0;\n    for (let i = 0; i < Math.max(markers.length, lines.length); i++) {\n      const { length: length2, spacing, isCustomMarker } = dimensionProps[i] ?? 0;\n      const marker = markers[i];\n      const line = lines[i];\n      const size = marker?.size ?? 0;\n      let lineTop = Infinity;\n      let lineX1 = Infinity;\n      let lineX2 = Infinity;\n      let markerTop = Infinity;\n      let markerLeft = Infinity;\n      if (marker) {\n        const center2 = marker.constructor.center;\n        const radius = (size + marker.strokeWidth) / 2;\n        if (isCustomMarker) {\n          marker.x = 0;\n          marker.y = 0;\n          marker.translationX = (center2.x - 0.5) * size + length2 / 2 + shift;\n          marker.translationY = (center2.y - 0.5) * size;\n          markerTop = marker.translationY - radius;\n          markerLeft = marker.translationX - radius;\n        } else {\n          marker.x = (center2.x - 0.5) * size + length2 / 2 + shift;\n          marker.y = (center2.y - 0.5) * size;\n          markerTop = marker.y - radius;\n          markerLeft = marker.x - radius;\n        }\n      }\n      if (line) {\n        line.x1 = shift;\n        line.x2 = shift + length2;\n        line.y1 = 0;\n        line.y2 = 0;\n        line.markDirty(3 /* MAJOR */);\n        lineTop = -line.strokeWidth / 2;\n        lineX1 = line.x1;\n        lineX2 = line.x2;\n      }\n      shift += spacing + Math.max(length2, size);\n      spriteX = Math.min(spriteX, lineX1, lineX2, markerLeft);\n      spriteY = Math.min(spriteY, lineTop, markerTop);\n    }\n    const lastSymbolProps = dimensionProps.at(-1);\n    const lastLine = this.lines.at(-1);\n    const lastMarker = this.markers.at(-1);\n    const lineEnd = lastLine ? lastLine.x2 : -Infinity;\n    const markerEnd = (lastMarker?.x ?? 0) + (lastMarker?.size ?? 0) / 2;\n    this.label.x = Math.max(lineEnd, markerEnd) + (lastSymbolProps?.spacing ?? 0);\n    if (this.bitmapDirty) {\n      this.setBitmapVisibility(false);\n      const translateX = (spriteAAPadding + spriteX) * scale2;\n      const translateY = (spriteAAPadding - spriteY) * scale2;\n      const sprite = spriteRenderer.renderSprite(this.symbolsGroup, {\n        scale: scale2,\n        translateX: Math.floor(translateX),\n        translateY: Math.floor(translateY)\n      });\n      this.bitmap.updateBitmap(sprite, scale2, Math.ceil(-translateX), Math.ceil(-translateY));\n      this.bitmapDirty = false;\n      this.refreshVisibilities();\n    }\n    if (dimensionProps.length < 2) {\n      return;\n    }\n    const bbox = this.symbolsGroup.getBBox();\n    const clippedWidth = Math.max(lastMarker?.size ?? 0, lastSymbolProps?.length ?? 0);\n    const clipRect = new BBox(bbox.x + clippedWidth / 2, bbox.y, clippedWidth, bbox.height);\n    this.symbolsGroup.setClipRect(clipRect);\n  }\n  computeBBox() {\n    const { label, lines, markers } = this;\n    return this.toParent(Group.computeChildrenBBox(iterate([label], lines, markers), false));\n  }\n};\nLegendMarkerLabel.className = \"MarkerLabel\";\n__decorateClass([\n  ProxyPropertyOnWrite(\"label\")\n], LegendMarkerLabel.prototype, \"text\", 2);\n__decorateClass([\n  ProxyPropertyOnWrite(\"label\")\n], LegendMarkerLabel.prototype, \"fontStyle\", 2);\n__decorateClass([\n  ProxyPropertyOnWrite(\"label\")\n], LegendMarkerLabel.prototype, \"fontWeight\", 2);\n__decorateClass([\n  ProxyPropertyOnWrite(\"label\")\n], LegendMarkerLabel.prototype, \"fontSize\", 2);\n__decorateClass([\n  ProxyPropertyOnWrite(\"label\")\n], LegendMarkerLabel.prototype, \"fontFamily\", 2);\n__decorateClass([\n  ProxyPropertyOnWrite(\"label\", \"fill\")\n], LegendMarkerLabel.prototype, \"color\", 2);\n\n// packages/ag-charts-community/src/chart/pagination/pagination.ts\nvar PaginationLabel = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.color = \"black\";\n    this.fontStyle = void 0;\n    this.fontWeight = void 0;\n    this.fontSize = 12;\n    this.fontFamily = \"Verdana, sans-serif\";\n  }\n};\n__decorateClass([\n  Validate(COLOR_STRING)\n], PaginationLabel.prototype, \"color\", 2);\n__decorateClass([\n  Validate(FONT_STYLE, { optional: true })\n], PaginationLabel.prototype, \"fontStyle\", 2);\n__decorateClass([\n  Validate(FONT_WEIGHT, { optional: true })\n], PaginationLabel.prototype, \"fontWeight\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PaginationLabel.prototype, \"fontSize\", 2);\n__decorateClass([\n  Validate(STRING)\n], PaginationLabel.prototype, \"fontFamily\", 2);\nvar PaginationMarkerStyle = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.size = 15;\n    this.fill = void 0;\n    this.fillOpacity = void 0;\n    this.stroke = void 0;\n    this.strokeWidth = 1;\n    this.strokeOpacity = 1;\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PaginationMarkerStyle.prototype, \"size\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], PaginationMarkerStyle.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], PaginationMarkerStyle.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], PaginationMarkerStyle.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PaginationMarkerStyle.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO)\n], PaginationMarkerStyle.prototype, \"strokeOpacity\", 2);\nvar PaginationMarker = class extends BaseProperties {\n  constructor(parent) {\n    super();\n    this.parent = parent;\n    this.shape = Triangle;\n    this.size = 15;\n    this.padding = 8;\n  }\n};\n__decorateClass([\n  ActionOnSet({\n    changeValue() {\n      if (this.parent.marker === this) {\n        this.parent.onMarkerShapeChange();\n      }\n    }\n  })\n], PaginationMarker.prototype, \"shape\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PaginationMarker.prototype, \"size\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PaginationMarker.prototype, \"padding\", 2);\nvar Pagination = class extends BaseProperties {\n  constructor(chartUpdateCallback, pageUpdateCallback) {\n    super();\n    this.chartUpdateCallback = chartUpdateCallback;\n    this.pageUpdateCallback = pageUpdateCallback;\n    this.id = createId(this);\n    this.marker = new PaginationMarker(this);\n    this.activeStyle = new PaginationMarkerStyle();\n    this.inactiveStyle = new PaginationMarkerStyle();\n    this.highlightStyle = new PaginationMarkerStyle();\n    this.label = new PaginationLabel();\n    this.group = new TranslatableGroup({ name: \"pagination\" });\n    this.labelNode = new Text();\n    this.destroyFns = [];\n    this.totalPages = 0;\n    this.currentPage = 0;\n    this.translationX = 0;\n    this.translationY = 0;\n    this.nextButtonDisabled = false;\n    this.previousButtonDisabled = false;\n    this._visible = true;\n    this._enabled = true;\n    this._orientation = \"vertical\";\n    this._nextButton = new Triangle();\n    this._previousButton = new Triangle();\n    this.labelNode.setProperties({\n      textBaseline: \"middle\",\n      fontSize: 12,\n      fontFamily: \"Verdana, sans-serif\",\n      fill: \"black\",\n      y: 1\n    });\n    this.group.append([this.nextButton, this.previousButton, this.labelNode]);\n    this.update();\n    this.updateMarkers();\n  }\n  destroy() {\n    this.destroyFns.forEach((f) => f());\n  }\n  set visible(value) {\n    this._visible = value;\n    this.updateGroupVisibility();\n  }\n  get visible() {\n    return this._visible;\n  }\n  set enabled(value) {\n    this._enabled = value;\n    this.updateGroupVisibility();\n  }\n  get enabled() {\n    return this._enabled;\n  }\n  updateGroupVisibility() {\n    this.group.visible = this.enabled && this.visible;\n  }\n  set orientation(value) {\n    this._orientation = value;\n    switch (value) {\n      case \"horizontal\": {\n        this.previousButton.rotation = -Math.PI / 2;\n        this.nextButton.rotation = Math.PI / 2;\n        break;\n      }\n      case \"vertical\":\n      default: {\n        this.previousButton.rotation = 0;\n        this.nextButton.rotation = Math.PI;\n      }\n    }\n  }\n  get orientation() {\n    return this._orientation;\n  }\n  set nextButton(value) {\n    if (this._nextButton !== value) {\n      this.group.removeChild(this._nextButton);\n      this._nextButton = value;\n      this.group.appendChild(value);\n    }\n  }\n  get nextButton() {\n    return this._nextButton;\n  }\n  set previousButton(value) {\n    if (this._previousButton !== value) {\n      this.group.removeChild(this._previousButton);\n      this._previousButton = value;\n      this.group.appendChild(value);\n    }\n  }\n  get previousButton() {\n    return this._previousButton;\n  }\n  update() {\n    this.updateLabel();\n    this.updatePositions();\n    this.enableOrDisableButtons();\n  }\n  updatePositions() {\n    this.group.translationX = this.translationX;\n    this.group.translationY = this.translationY;\n    this.updateLabelPosition();\n    this.updateNextButtonPosition();\n  }\n  updateLabelPosition() {\n    const { size: markerSize, padding: markerPadding } = this.marker;\n    this.nextButton.size = markerSize;\n    this.previousButton.size = markerSize;\n    this.labelNode.x = markerSize / 2 + markerPadding;\n  }\n  updateNextButtonPosition() {\n    const labelBBox = this.labelNode.getBBox();\n    this.nextButton.translationX = labelBBox.width + (this.marker.size / 2 + this.marker.padding) * 2;\n  }\n  updateLabel() {\n    const {\n      currentPage,\n      totalPages: pages,\n      labelNode,\n      label: { color, fontStyle, fontWeight, fontSize, fontFamily }\n    } = this;\n    labelNode.text = `${currentPage + 1} / ${pages}`;\n    labelNode.fill = color;\n    labelNode.fontStyle = fontStyle;\n    labelNode.fontWeight = fontWeight;\n    labelNode.fontSize = fontSize;\n    labelNode.fontFamily = fontFamily;\n  }\n  updateMarkers() {\n    const {\n      nextButton,\n      previousButton,\n      nextButtonDisabled,\n      previousButtonDisabled,\n      activeStyle,\n      inactiveStyle,\n      highlightStyle,\n      highlightActive\n    } = this;\n    const buttonStyle = (button, disabled) => {\n      if (disabled) {\n        return inactiveStyle;\n      } else if (button === highlightActive) {\n        return highlightStyle;\n      }\n      return activeStyle;\n    };\n    this.updateMarker(nextButton, buttonStyle(\"next\", nextButtonDisabled));\n    this.updateMarker(previousButton, buttonStyle(\"previous\", previousButtonDisabled));\n  }\n  updateMarker(marker, style) {\n    const { size } = this.marker;\n    marker.size = size;\n    marker.fill = style.fill;\n    marker.fillOpacity = style.fillOpacity ?? 1;\n    marker.stroke = style.stroke;\n    marker.strokeWidth = style.strokeWidth;\n    marker.strokeOpacity = style.strokeOpacity;\n  }\n  enableOrDisableButtons() {\n    const { currentPage, totalPages } = this;\n    const zeroPagesToDisplay = totalPages === 0;\n    const onLastPage = currentPage === totalPages - 1;\n    const onFirstPage = currentPage === 0;\n    this.nextButtonDisabled = onLastPage || zeroPagesToDisplay;\n    this.previousButtonDisabled = onFirstPage || zeroPagesToDisplay;\n  }\n  setPage(pageNumber) {\n    pageNumber = clamp(0, pageNumber, this.totalPages - 1);\n    if (this.currentPage !== pageNumber) {\n      this.currentPage = pageNumber;\n      this.onPaginationChanged();\n    }\n  }\n  getCursor(node) {\n    return { previous: this.previousButtonDisabled, next: this.nextButtonDisabled }[node] ? void 0 : \"pointer\";\n  }\n  onClick(event, node) {\n    event.preventDefault();\n    if (node === \"next\" && !this.nextButtonDisabled) {\n      this.incrementPage();\n      this.onPaginationChanged();\n    } else if (node === \"previous\" && !this.previousButtonDisabled) {\n      this.decrementPage();\n      this.onPaginationChanged();\n    }\n  }\n  onMouseHover(node) {\n    this.highlightActive = node;\n    this.updateMarkers();\n    this.chartUpdateCallback(6 /* SCENE_RENDER */);\n  }\n  onPaginationChanged() {\n    this.pageUpdateCallback(this.currentPage);\n  }\n  incrementPage() {\n    this.currentPage = Math.min(this.currentPage + 1, this.totalPages - 1);\n  }\n  decrementPage() {\n    this.currentPage = Math.max(this.currentPage - 1, 0);\n  }\n  onMarkerShapeChange() {\n    const Marker2 = Rotatable(getMarker(this.marker.shape || Triangle));\n    this.previousButton = new Marker2();\n    this.nextButton = new Marker2();\n    this.updatePositions();\n    this.updateMarkers();\n    this.chartUpdateCallback(6 /* SCENE_RENDER */);\n  }\n  attachPagination(node) {\n    node.append(this.group);\n  }\n  getBBox() {\n    return this.group.getBBox();\n  }\n  computeCSSBounds() {\n    const prev = Transformable.toCanvas(this.previousButton);\n    const next = Transformable.toCanvas(this.nextButton);\n    return { prev, next };\n  }\n};\nPagination.className = \"Pagination\";\n__decorateClass([\n  Validate(OBJECT)\n], Pagination.prototype, \"marker\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Pagination.prototype, \"activeStyle\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Pagination.prototype, \"inactiveStyle\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Pagination.prototype, \"highlightStyle\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Pagination.prototype, \"label\", 2);\n\n// packages/ag-charts-community/src/chart/legend.ts\nvar LegendLabel = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.maxLength = void 0;\n    this.color = \"black\";\n    this.fontStyle = void 0;\n    this.fontWeight = void 0;\n    this.fontSize = 12;\n    this.fontFamily = \"Verdana, sans-serif\";\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], LegendLabel.prototype, \"maxLength\", 2);\n__decorateClass([\n  Validate(COLOR_STRING)\n], LegendLabel.prototype, \"color\", 2);\n__decorateClass([\n  Validate(FONT_STYLE, { optional: true })\n], LegendLabel.prototype, \"fontStyle\", 2);\n__decorateClass([\n  Validate(FONT_WEIGHT, { optional: true })\n], LegendLabel.prototype, \"fontWeight\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], LegendLabel.prototype, \"fontSize\", 2);\n__decorateClass([\n  Validate(STRING)\n], LegendLabel.prototype, \"fontFamily\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], LegendLabel.prototype, \"formatter\", 2);\nvar LegendMarker = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.size = 15;\n    this.padding = 8;\n  }\n};\n__decorateClass([\n  ObserveChanges((target) => target.parent?.onMarkerShapeChange())\n], LegendMarker.prototype, \"shape\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], LegendMarker.prototype, \"size\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], LegendMarker.prototype, \"padding\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], LegendMarker.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], LegendMarker.prototype, \"enabled\", 2);\nvar LegendLine = class extends BaseProperties {\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], LegendLine.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], LegendLine.prototype, \"length\", 2);\nvar LegendItem = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.paddingX = 16;\n    this.paddingY = 8;\n    this.showSeriesStroke = false;\n    this.marker = new LegendMarker();\n    this.label = new LegendLabel();\n    this.line = new LegendLine();\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], LegendItem.prototype, \"maxWidth\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], LegendItem.prototype, \"paddingX\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], LegendItem.prototype, \"paddingY\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], LegendItem.prototype, \"showSeriesStroke\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], LegendItem.prototype, \"marker\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], LegendItem.prototype, \"label\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], LegendItem.prototype, \"line\", 2);\nvar LegendListeners = class extends BaseProperties {\n};\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], LegendListeners.prototype, \"legendItemClick\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], LegendListeners.prototype, \"legendItemDoubleClick\", 2);\nvar ID_LEGEND_VISIBILITY = \"legend-visibility\";\nvar ID_LEGEND_OTHER_SERIES = \"legend-other-series\";\nvar LegendItemEvent = class {\n  constructor(type, enabled, itemId, seriesId, event) {\n    this.type = type;\n    this.enabled = enabled;\n    this.itemId = itemId;\n    this.seriesId = seriesId;\n    this.event = event;\n    this.defaultPrevented = false;\n  }\n  preventDefault() {\n    this.defaultPrevented = true;\n  }\n};\nvar Legend = class extends BaseProperties {\n  constructor(ctx) {\n    super();\n    this.ctx = ctx;\n    this.id = createId(this);\n    this.group = new TranslatableLayer({ name: \"legend\", zIndex: 15 /* LEGEND */ });\n    this.itemSelection = Selection.select(\n      this.group,\n      LegendMarkerLabel\n    );\n    this.spriteRenderer = void 0;\n    this.oldSize = [0, 0];\n    this.pages = [];\n    this.maxPageSize = [0, 0];\n    /** Item index to track on re-pagination, so current page updates appropriately. */\n    this.paginationTrackingIndex = 0;\n    this.truncatedItems = /* @__PURE__ */ new Set();\n    this._data = [];\n    this._symbolsDirty = true;\n    this.toggleSeries = true;\n    this.item = new LegendItem();\n    this.listeners = new LegendListeners();\n    this.enabled = true;\n    this.position = \"bottom\";\n    this.spacing = 20;\n    this.destroyFns = [];\n    this.proxyLegendDirty = true;\n    this.proxyLegendToolbarDestroyFns = new DestroyFns();\n    this.size = [0, 0];\n    this._visible = true;\n    this.item.marker.parent = this;\n    this.pagination = new Pagination(\n      (type) => ctx.updateService.update(type),\n      (page) => this.updatePageNumber(page)\n    );\n    this.pagination.attachPagination(this.group);\n    this.destroyFns.push(\n      ctx.contextMenuRegistry.registerDefaultAction({\n        id: ID_LEGEND_VISIBILITY,\n        type: \"legend\",\n        label: \"contextMenuToggleSeriesVisibility\",\n        action: (params) => this.contextToggleVisibility(params)\n      }),\n      ctx.contextMenuRegistry.registerDefaultAction({\n        id: ID_LEGEND_OTHER_SERIES,\n        type: \"legend\",\n        label: \"contextMenuToggleOtherSeries\",\n        action: (params) => this.contextToggleOtherSeries(params)\n      })\n    );\n    this.destroyFns.push(\n      ctx.layoutManager.registerElement(1 /* Legend */, (e) => this.positionLegend(e)),\n      ctx.localeManager.addListener(\"locale-changed\", () => this.onLocaleChanged()),\n      () => this.group.remove()\n    );\n    this.proxyLegendToolbar = this.ctx.proxyInteractionService.createProxyContainer({\n      type: \"list\",\n      id: `${this.id}-toolbar`,\n      classList: [\"ag-charts-proxy-legend-toolbar\"],\n      ariaLabel: { id: \"ariaLabelLegend\" },\n      ariaHidden: true\n    });\n    this.proxyLegendPagination = this.ctx.proxyInteractionService.createProxyContainer({\n      type: \"group\",\n      id: `${this.id}-pagination`,\n      classList: [\"ag-charts-proxy-legend-pagination\"],\n      ariaLabel: { id: \"ariaLabelLegendPagination\" },\n      ariaOrientation: \"horizontal\",\n      ariaHidden: true\n    });\n    this.proxyLegendItemDescription = createElement(\"p\");\n    this.proxyLegendItemDescription.style.display = \"none\";\n    this.proxyLegendItemDescription.id = `${this.id}-ariaDescription`;\n    this.proxyLegendItemDescription.textContent = this.getItemAriaDescription();\n    this.proxyLegendToolbar.append(this.proxyLegendItemDescription);\n  }\n  set data(value) {\n    this.onDataUpdate(this._data, value);\n    this._data = value;\n    this._symbolsDirty = true;\n    this.updateGroupVisibility();\n  }\n  get data() {\n    return this._data;\n  }\n  destroy() {\n    this.ctx.domManager.removeChild(\"canvas-overlay\", `${this.id}-toolbar`);\n    this.ctx.domManager.removeChild(\"canvas-overlay\", `${this.id}-pagination`);\n    this.destroyFns.forEach((f) => f());\n    this.pagination.destroy();\n    this.itemSelection.clear();\n    this.proxyLegendToolbarDestroyFns.destroy();\n  }\n  initLegendItemToolbar() {\n    if (!this.proxyLegendDirty)\n      return;\n    this.itemSelection.each((markerLabel, _, i) => {\n      markerLabel.destroyProxyButton();\n      markerLabel.proxyButton ?? (markerLabel.proxyButton = this.ctx.proxyInteractionService.createProxyElement({\n        type: \"listswitch\",\n        id: `ag-charts-legend-item-${i}`,\n        textContent: this.getItemAriaText(i),\n        ariaChecked: !!markerLabel.datum.enabled,\n        ariaDescribedBy: this.proxyLegendItemDescription.id,\n        parent: this.proxyLegendToolbar,\n        // Retrieve the datum from the node rather than from the method parameter.\n        // The method parameter `datum` gets destroyed when the data is refreshed\n        // using Series.getLegendData(). But the scene node will stay the same.\n        onclick: (ev) => this.onClick(ev, markerLabel.datum, markerLabel.proxyButton.button),\n        ondblclick: (ev) => this.onDoubleClick(ev, markerLabel.datum),\n        onmouseenter: (ev) => this.onHover(ev, markerLabel),\n        onmouseleave: () => this.onLeave(),\n        oncontextmenu: (ev) => this.onContextClick(ev, markerLabel),\n        onblur: () => this.onLeave(),\n        onfocus: (ev) => this.onHover(ev, markerLabel)\n      }));\n    });\n    const buttons = this.itemSelection.nodes().map((markerLabel) => markerLabel.proxyButton?.button).filter(isDefined);\n    this.proxyLegendToolbarDestroyFns.setFns([\n      ...initRovingTabIndex({ orientation: \"horizontal\", buttons }),\n      ...initRovingTabIndex({ orientation: \"vertical\", buttons })\n    ]);\n    this.proxyLegendToolbar.ariaHidden = (buttons.length === 0).toString();\n    this.proxyLegendDirty = false;\n  }\n  onDataUpdate(oldData, newData) {\n    this.proxyLegendDirty = oldData.length !== newData.length || oldData.some((_v, index, _a) => {\n      const [newValue, oldValue] = [newData[index], oldData[index]];\n      return newValue.id !== oldValue.id;\n    });\n  }\n  onMarkerShapeChange() {\n    this.itemSelection.clear();\n    this.group.markDirty(2 /* MINOR */);\n  }\n  getOrientation() {\n    if (this.orientation !== void 0) {\n      return this.orientation;\n    }\n    switch (this.position) {\n      case \"right\":\n      case \"left\":\n        return \"vertical\";\n      case \"bottom\":\n      case \"top\":\n        return \"horizontal\";\n    }\n  }\n  set visible(value) {\n    this._visible = value;\n    this.updateGroupVisibility();\n  }\n  get visible() {\n    return this._visible;\n  }\n  updateGroupVisibility() {\n    this.group.visible = this.enabled && this.visible && this.data.length > 0;\n  }\n  attachLegend(scene) {\n    scene.appendChild(this.group);\n  }\n  getItemLabel(datum) {\n    const {\n      ctx: { callbackCache }\n    } = this;\n    const { formatter } = this.item.label;\n    if (formatter) {\n      return callbackCache.call(formatter, {\n        itemId: datum.itemId,\n        value: datum.label.text,\n        seriesId: datum.seriesId\n      });\n    }\n    return datum.label.text;\n  }\n  /**\n   * The method is given the desired size of the legend, which only serves as a hint.\n   * The vertically oriented legend will take as much horizontal space as needed, but will\n   * respect the height constraints, and the horizontal legend will take as much vertical\n   * space as needed in an attempt not to exceed the given width.\n   * After the layout is done, the {@link size} will contain the actual size of the legend.\n   * If the actual size is not the same as the previous actual size, the legend will fire\n   * the 'layoutChange' event to communicate that another layout is needed, and the above\n   * process should be repeated.\n   * @param width\n   * @param height\n   */\n  calcLayout(width2, height2) {\n    const {\n      paddingX,\n      paddingY,\n      label,\n      maxWidth,\n      label: { maxLength = Infinity, fontStyle, fontWeight, fontSize, fontFamily }\n    } = this.item;\n    const data = [...this.data];\n    if (this.reverseOrder) {\n      data.reverse();\n    }\n    this.itemSelection.update(data);\n    this.initLegendItemToolbar();\n    const bboxes = [];\n    const font = TextUtils.toFontString(label);\n    const itemMaxWidthPercentage = 0.8;\n    const maxItemWidth = maxWidth ?? width2 * itemMaxWidthPercentage;\n    const spriteDims = this.calculateSpriteDimensions();\n    this.spriteRenderer ?? (this.spriteRenderer = new SpriteRenderer());\n    this.spriteRenderer.resize(spriteDims);\n    this.itemSelection.each((markerLabel, datum) => {\n      markerLabel.fontStyle = fontStyle;\n      markerLabel.fontWeight = fontWeight;\n      markerLabel.fontSize = fontSize;\n      markerLabel.fontFamily = fontFamily;\n      const paddedSymbolWidth = this.updateMarkerLabel(this.spriteRenderer, markerLabel, datum, spriteDims);\n      const id = datum.itemId ?? datum.id;\n      const labelText = this.getItemLabel(datum);\n      const text = (labelText ?? \"<unknown>\").replace(/\\r?\\n/g, \" \");\n      markerLabel.text = this.truncate(text, maxLength, maxItemWidth, paddedSymbolWidth, font, id);\n      bboxes.push(markerLabel.getBBox());\n    });\n    this._symbolsDirty = false;\n    width2 = Math.max(1, width2);\n    height2 = Math.max(1, height2);\n    if (!isFinite(width2)) {\n      return {};\n    }\n    const size = this.size;\n    const oldSize = this.oldSize;\n    size[0] = width2;\n    size[1] = height2;\n    if (size[0] !== oldSize[0] || size[1] !== oldSize[1]) {\n      oldSize[0] = size[0];\n      oldSize[1] = size[1];\n    }\n    const { pages, maxPageHeight, maxPageWidth } = this.updatePagination(bboxes, width2, height2);\n    const oldPages = this.pages;\n    this.pages = pages;\n    this.maxPageSize = [maxPageWidth - paddingX, maxPageHeight - paddingY];\n    const pageNumber = this.pagination.currentPage;\n    const page = this.pages[pageNumber];\n    if (this.pages.length < 1 || !page) {\n      this.visible = false;\n      return { oldPages };\n    }\n    this.visible = true;\n    this.updatePositions(pageNumber);\n    this.update();\n    return { oldPages };\n  }\n  isCustomMarker(markerEnabled, shape) {\n    return markerEnabled && shape !== void 0 && typeof shape !== \"string\";\n  }\n  calcSymbolsEnabled(symbol) {\n    const { showSeriesStroke, marker } = this.item;\n    const markerEnabled = !!marker.enabled || !showSeriesStroke || (symbol.marker.enabled ?? true);\n    const lineEnabled = !!(symbol.line && showSeriesStroke);\n    const isCustomMarker = this.isCustomMarker(markerEnabled, symbol.marker.shape);\n    return { markerEnabled, lineEnabled, isCustomMarker };\n  }\n  calcSymbolsLengths(symbol) {\n    const { marker, line } = this.item;\n    const { markerEnabled, lineEnabled } = this.calcSymbolsEnabled(symbol);\n    const { strokeWidth: markerStrokeWidth } = this.getMarkerStyles(symbol);\n    const { strokeWidth: lineStrokeWidth } = lineEnabled ? this.getLineStyles(symbol) : { strokeWidth: 0 };\n    let customMarkerSize;\n    const { shape } = symbol.marker;\n    if (this.isCustomMarker(markerEnabled, shape)) {\n      const tmpShape = new shape();\n      tmpShape.updatePath();\n      const bbox = tmpShape.getBBox();\n      customMarkerSize = Math.max(bbox.width, bbox.height);\n    }\n    const markerLength = markerEnabled ? marker.size : 0;\n    const lineLength = lineEnabled ? line.length ?? 25 : 0;\n    return { markerLength, markerStrokeWidth, lineLength, lineStrokeWidth, customMarkerSize };\n  }\n  calculateSpriteDimensions() {\n    let spriteAAPadding = 0;\n    let spriteWidth = 0;\n    let spriteHeight = 0;\n    let markerWidth = 0;\n    this.itemSelection.each((_, datum) => {\n      datum.symbols.forEach((symbol) => {\n        const {\n          markerLength,\n          markerStrokeWidth,\n          lineLength,\n          lineStrokeWidth,\n          customMarkerSize = -Infinity\n        } = this.calcSymbolsLengths(symbol);\n        const markerTotalLength = markerLength + markerStrokeWidth;\n        markerWidth = Math.max(markerWidth, lineLength, customMarkerSize, markerLength);\n        spriteWidth = Math.max(spriteWidth, lineLength, customMarkerSize, markerTotalLength);\n        spriteHeight = Math.max(spriteHeight, lineStrokeWidth, markerTotalLength);\n        spriteAAPadding = Math.max(spriteAAPadding, markerStrokeWidth + 0.5);\n      });\n    });\n    spriteWidth += spriteAAPadding * 2;\n    spriteHeight += spriteAAPadding * 2;\n    const spritePixelRatio = getWindow().devicePixelRatio;\n    return { spritePixelRatio, spriteAAPadding, spriteWidth, spriteHeight, markerWidth };\n  }\n  updateMarkerLabel(spriteRenderer, markerLabel, datum, spriteDims) {\n    const { marker: itemMarker, paddingX } = this.item;\n    const { markerWidth } = spriteDims;\n    const dimensionProps = [];\n    let paddedSymbolWidth = paddingX;\n    if (this._symbolsDirty) {\n      const markers = [];\n      const lines = [];\n      datum.symbols.forEach((symbol) => {\n        const { shape: markerShape = symbol.marker.shape } = itemMarker;\n        const MarkerCtr = getMarker(markerShape);\n        lines.push(new Line({ zIndex: 0 }));\n        markers.push(new MarkerCtr({ zIndex: 1 }));\n      });\n      markerLabel.updateSymbols(markers, lines);\n    }\n    datum.symbols.forEach((symbol, i) => {\n      const spacing = symbol.marker.padding ?? itemMarker.padding;\n      const { markerEnabled, lineEnabled, isCustomMarker } = this.calcSymbolsEnabled(symbol);\n      markerLabel.markers[i].size = markerEnabled || !lineEnabled ? itemMarker.size : 0;\n      dimensionProps.push({ length: markerWidth, spacing, isCustomMarker });\n      if (markerEnabled || lineEnabled) {\n        paddedSymbolWidth += spacing + markerWidth;\n      }\n      const marker = markerLabel.markers[i];\n      const line = markerLabel.lines[i];\n      if (marker) {\n        const { strokeWidth, fill, stroke, fillOpacity, strokeOpacity } = this.getMarkerStyles(symbol);\n        marker.fill = fill;\n        marker.stroke = stroke;\n        marker.strokeWidth = strokeWidth;\n        marker.fillOpacity = fillOpacity;\n        marker.strokeOpacity = strokeOpacity;\n      }\n      if (line) {\n        const lineStyles = this.getLineStyles(symbol);\n        line.stroke = lineStyles.stroke;\n        line.strokeOpacity = lineStyles.strokeOpacity;\n        line.strokeWidth = lineStyles.strokeWidth;\n        line.lineDash = lineStyles.lineDash;\n      }\n    });\n    markerLabel.update(spriteRenderer, spriteDims, dimensionProps);\n    return paddedSymbolWidth;\n  }\n  truncate(text, maxCharLength, maxItemWidth, paddedMarkerWidth, font, id) {\n    let addEllipsis = false;\n    if (text.length > maxCharLength) {\n      text = text.substring(0, maxCharLength);\n      addEllipsis = true;\n    }\n    const measurer = CachedTextMeasurerPool.getMeasurer({ font });\n    const result = TextWrapper.truncateLine(text, measurer, maxItemWidth - paddedMarkerWidth, addEllipsis);\n    if (result.endsWith(TextUtils.EllipsisChar)) {\n      this.truncatedItems.add(id);\n    } else {\n      this.truncatedItems.delete(id);\n    }\n    return result;\n  }\n  updatePagination(bboxes, width2, height2) {\n    const orientation = this.getOrientation();\n    const trackingIndex = Math.min(this.paginationTrackingIndex, bboxes.length);\n    this.pagination.orientation = orientation;\n    this.pagination.translationX = 0;\n    this.pagination.translationY = 0;\n    const { pages, maxPageHeight, maxPageWidth, paginationBBox, paginationVertical } = this.calculatePagination(\n      bboxes,\n      width2,\n      height2\n    );\n    const newCurrentPage = pages.findIndex((p) => p.endIndex >= trackingIndex);\n    this.pagination.currentPage = clamp(0, newCurrentPage, pages.length - 1);\n    const { paddingX: itemPaddingX, paddingY: itemPaddingY } = this.item;\n    const paginationComponentPadding = 8;\n    const legendItemsWidth = maxPageWidth - itemPaddingX;\n    const legendItemsHeight = maxPageHeight - itemPaddingY;\n    let paginationX = 0;\n    let paginationY = -paginationBBox.y - this.item.marker.size / 2;\n    if (paginationVertical) {\n      paginationY += legendItemsHeight + paginationComponentPadding;\n    } else {\n      paginationX += -paginationBBox.x + legendItemsWidth + paginationComponentPadding;\n      paginationY += (legendItemsHeight - paginationBBox.height) / 2;\n    }\n    this.pagination.translationX = paginationX;\n    this.pagination.translationY = paginationY;\n    this.pagination.update();\n    this.pagination.updateMarkers();\n    let pageIndex = 0;\n    this.itemSelection.each((markerLabel, _, nodeIndex) => {\n      if (nodeIndex > (pages[pageIndex]?.endIndex ?? Infinity)) {\n        pageIndex++;\n      }\n      markerLabel.pageIndex = pageIndex;\n    });\n    return {\n      maxPageHeight,\n      maxPageWidth,\n      pages\n    };\n  }\n  updateItemProxyButtons() {\n    const pointer = this.toggleSeries ? \"pointer\" : void 0;\n    const maxHeight = Math.max(...this.itemSelection.nodes().map((l) => l.getBBox().height));\n    this.itemSelection.each((l) => {\n      if (l.proxyButton) {\n        const { listitem, button } = l.proxyButton;\n        const visible = l.pageIndex === this.pagination.currentPage;\n        let bbox = Transformable.toCanvas(l);\n        if (bbox.height !== maxHeight) {\n          const margin = (maxHeight - bbox.height) / 2;\n          bbox = { x: bbox.x, y: bbox.y - margin, height: maxHeight, width: bbox.width };\n        }\n        setElementStyle(button, \"pointer-events\", visible ? \"auto\" : \"none\");\n        setElementStyle(button, \"cursor\", pointer);\n        setElementBBox(listitem, bbox);\n      }\n    });\n  }\n  updatePaginationProxyButtons(oldPages) {\n    this.proxyLegendPagination.style.display = this.pagination.visible ? \"absolute\" : \"none\";\n    const oldNeedsButtons = (oldPages?.length ?? this.pages.length) > 1;\n    const newNeedsButtons = this.pages.length > 1;\n    if (oldNeedsButtons !== newNeedsButtons) {\n      if (newNeedsButtons) {\n        this.proxyPrevButton = this.ctx.proxyInteractionService.createProxyElement({\n          type: \"button\",\n          id: `${this.id}-prev-page`,\n          textContent: { id: \"ariaLabelLegendPagePrevious\" },\n          tabIndex: 0,\n          parent: this.proxyLegendPagination,\n          onclick: (ev) => this.pagination.onClick(ev, \"previous\"),\n          onmouseenter: () => this.pagination.onMouseHover(\"previous\"),\n          onmouseleave: () => this.pagination.onMouseHover(void 0)\n        });\n        this.proxyNextButton ?? (this.proxyNextButton = this.ctx.proxyInteractionService.createProxyElement({\n          type: \"button\",\n          id: `${this.id}-next-page`,\n          textContent: { id: \"ariaLabelLegendPageNext\" },\n          tabIndex: 0,\n          parent: this.proxyLegendPagination,\n          onclick: (ev) => this.pagination.onClick(ev, \"next\"),\n          onmouseenter: () => this.pagination.onMouseHover(\"next\"),\n          onmouseleave: () => this.pagination.onMouseHover(void 0)\n        }));\n        this.proxyLegendPagination.ariaHidden = \"false\";\n      } else {\n        this.proxyNextButton?.remove();\n        this.proxyPrevButton?.remove();\n        [this.proxyNextButton, this.proxyPrevButton] = [void 0, void 0];\n        this.proxyLegendPagination.ariaHidden = \"true\";\n      }\n    }\n    const { prev, next } = this.pagination.computeCSSBounds();\n    setElementBBox(this.proxyPrevButton, prev);\n    setElementBBox(this.proxyNextButton, next);\n    setElementStyle(this.proxyNextButton, \"cursor\", this.pagination.getCursor(\"next\"));\n    setElementStyle(this.proxyPrevButton, \"cursor\", this.pagination.getCursor(\"previous\"));\n  }\n  calculatePagination(bboxes, width2, height2) {\n    const { paddingX: itemPaddingX, paddingY: itemPaddingY } = this.item;\n    const orientation = this.getOrientation();\n    const paginationVertical = [\"left\", \"right\"].includes(this.position);\n    let paginationBBox = this.pagination.getBBox();\n    let lastPassPaginationBBox = new BBox(0, 0, 0, 0);\n    let pages = [];\n    let maxPageWidth = 0;\n    let maxPageHeight = 0;\n    let count = 0;\n    const stableOutput = (bbox) => {\n      return bbox.width === paginationBBox.width && bbox.height === paginationBBox.height;\n    };\n    const forceResult = this.maxWidth !== void 0 && this.maxHeight !== void 0;\n    do {\n      if (count++ > 10) {\n        Logger.warn(\"unable to find stable legend layout.\");\n        break;\n      }\n      paginationBBox = lastPassPaginationBBox;\n      const maxWidth = width2 - (paginationVertical ? 0 : paginationBBox.width);\n      const maxHeight = height2 - (paginationVertical ? paginationBBox.height : 0);\n      const layout = gridLayout({\n        orientation,\n        bboxes,\n        maxHeight,\n        maxWidth,\n        itemPaddingY,\n        itemPaddingX,\n        forceResult\n      });\n      pages = layout?.pages ?? [];\n      maxPageWidth = layout?.maxPageWidth ?? 0;\n      maxPageHeight = layout?.maxPageHeight ?? 0;\n      const totalPages = pages.length;\n      this.pagination.visible = totalPages > 1;\n      this.pagination.totalPages = totalPages;\n      this.pagination.update();\n      this.pagination.updateMarkers();\n      lastPassPaginationBBox = this.pagination.getBBox();\n      if (!this.pagination.visible) {\n        break;\n      }\n    } while (!stableOutput(lastPassPaginationBBox));\n    return { maxPageWidth, maxPageHeight, pages, paginationBBox: lastPassPaginationBBox, paginationVertical };\n  }\n  updatePositions(pageNumber = 0) {\n    const {\n      item: { paddingY },\n      itemSelection,\n      pages\n    } = this;\n    if (pages.length < 1 || !pages[pageNumber]) {\n      return;\n    }\n    const { columns, startIndex: visibleStart, endIndex: visibleEnd } = pages[pageNumber];\n    let x = 0;\n    let y = 0;\n    const columnCount = columns.length;\n    const rowCount = columns[0].indices.length;\n    const horizontal = this.getOrientation() === \"horizontal\";\n    const itemHeight = columns[0].bboxes[0].height + paddingY;\n    const rowSumColumnWidths = [];\n    itemSelection.each((markerLabel, _, i) => {\n      if (i < visibleStart || i > visibleEnd) {\n        markerLabel.visible = false;\n        return;\n      }\n      const pageIndex = i - visibleStart;\n      let columnIndex;\n      let rowIndex;\n      if (horizontal) {\n        columnIndex = pageIndex % columnCount;\n        rowIndex = Math.floor(pageIndex / columnCount);\n      } else {\n        columnIndex = Math.floor(pageIndex / rowCount);\n        rowIndex = pageIndex % rowCount;\n      }\n      markerLabel.visible = true;\n      const column = columns[columnIndex];\n      if (!column) {\n        return;\n      }\n      y = Math.floor(itemHeight * rowIndex);\n      x = Math.floor(rowSumColumnWidths[rowIndex] ?? 0);\n      rowSumColumnWidths[rowIndex] = (rowSumColumnWidths[rowIndex] ?? 0) + column.columnWidth;\n      markerLabel.translationX = x;\n      markerLabel.translationY = y;\n    });\n    this.updateItemProxyButtons();\n  }\n  updatePageNumber(pageNumber) {\n    const { pages } = this;\n    const { startIndex, endIndex } = pages[pageNumber];\n    if (startIndex === 0) {\n      this.paginationTrackingIndex = 0;\n    } else if (pageNumber === pages.length - 1) {\n      this.paginationTrackingIndex = endIndex;\n    } else {\n      this.paginationTrackingIndex = Math.floor((startIndex + endIndex) / 2);\n    }\n    this.pagination.update();\n    this.pagination.updateMarkers();\n    this.updatePositions(pageNumber);\n    setElementStyle(this.proxyNextButton, \"cursor\", this.pagination.getCursor(\"next\"));\n    setElementStyle(this.proxyPrevButton, \"cursor\", this.pagination.getCursor(\"previous\"));\n    this.ctx.updateService.update(6 /* SCENE_RENDER */);\n  }\n  update() {\n    const {\n      label: { color }\n    } = this.item;\n    this.itemSelection.each((markerLabel, datum) => {\n      markerLabel.setEnabled(datum.enabled);\n      markerLabel.color = color;\n    });\n    this.updateContextMenu();\n  }\n  updateContextMenu() {\n    const {\n      toggleSeries,\n      ctx: { contextMenuRegistry }\n    } = this;\n    if (toggleSeries) {\n      contextMenuRegistry.hideAction(ID_LEGEND_VISIBILITY);\n      contextMenuRegistry.hideAction(ID_LEGEND_OTHER_SERIES);\n    } else {\n      contextMenuRegistry.showAction(ID_LEGEND_VISIBILITY);\n      contextMenuRegistry.showAction(ID_LEGEND_OTHER_SERIES);\n    }\n  }\n  getLineStyles(datum) {\n    const { stroke, strokeOpacity = 1, strokeWidth, lineDash } = datum.line ?? {};\n    const defaultLineStrokeWidth = Math.min(2, strokeWidth ?? 1);\n    return {\n      stroke,\n      strokeOpacity,\n      strokeWidth: this.item.line.strokeWidth ?? defaultLineStrokeWidth,\n      lineDash\n    };\n  }\n  getMarkerStyles(datum) {\n    const { fill, stroke, strokeOpacity = 1, fillOpacity = 1, strokeWidth } = datum.marker;\n    const defaultLineStrokeWidth = Math.min(2, strokeWidth ?? 1);\n    return {\n      fill,\n      stroke,\n      strokeOpacity,\n      fillOpacity,\n      strokeWidth: this.item.marker.strokeWidth ?? defaultLineStrokeWidth\n    };\n  }\n  computePagedBBox() {\n    const actualBBox = Group.computeChildrenBBox(this.group.children());\n    if (this.pages.length > 1) {\n      const [maxPageWidth, maxPageHeight] = this.maxPageSize;\n      actualBBox.height = Math.max(maxPageHeight, actualBBox.height);\n      actualBBox.width = Math.max(maxPageWidth, actualBBox.width);\n    }\n    return actualBBox;\n  }\n  findNode(params) {\n    const { datum, proxyButton } = this.itemSelection.select((ml) => ml.datum?.itemId === params.itemId)[0] ?? {};\n    if (datum === void 0 || proxyButton === void 0) {\n      throw new Error(`AG Charts - Missing required properties { datum: ${datum}, proxyButton: ${proxyButton} }`);\n    }\n    return { datum, proxyButton };\n  }\n  contextToggleVisibility(params) {\n    const { datum, proxyButton } = this.findNode(params);\n    this.doClick(params.event, datum, proxyButton.button);\n  }\n  contextToggleOtherSeries(params) {\n    this.doDoubleClick(params.event, this.findNode(params).datum);\n  }\n  onContextClick(sourceEvent, node) {\n    const legendItem = node.datum;\n    if (this.preventHidingAll && this.contextMenuDatum?.enabled && this.getVisibleItemCount() <= 1) {\n      this.ctx.contextMenuRegistry.disableAction(ID_LEGEND_VISIBILITY);\n    } else {\n      this.ctx.contextMenuRegistry.enableAction(ID_LEGEND_VISIBILITY);\n    }\n    const { button, offsetX, offsetY } = sourceEvent;\n    const { x: canvasOffsetX, y: canvasOffsetY } = Transformable.toCanvasPoint(node, offsetX, offsetY);\n    const event = {\n      type: \"contextmenu\",\n      sourceEvent,\n      button,\n      offsetX: canvasOffsetX,\n      offsetY: canvasOffsetY,\n      deltaX: 0,\n      deltaY: 0,\n      pageX: NaN,\n      pageY: NaN,\n      preventDefault: () => sourceEvent.preventDefault(),\n      pointerHistory: []\n    };\n    this.ctx.contextMenuRegistry.dispatchContext(\"legend\", event, { legendItem });\n  }\n  onClick(event, datum, proxyButton) {\n    if (this.doClick(event, datum, proxyButton)) {\n      event.preventDefault();\n    }\n  }\n  getVisibleItemCount() {\n    return this.ctx.chartService.series.flatMap((s) => s.getLegendData(\"category\")).filter((d) => d.enabled).length;\n  }\n  doClick(event, datum, proxyButton) {\n    const {\n      listeners: { legendItemClick },\n      ctx: { chartService, highlightManager },\n      preventHidingAll,\n      toggleSeries\n    } = this;\n    if (!datum) {\n      return false;\n    }\n    const { id, itemId, enabled } = datum;\n    const series = chartService.series.find((s) => s.id === id);\n    if (!series) {\n      return false;\n    }\n    let newEnabled = enabled;\n    const clickEvent = new LegendItemEvent(\"click\", newEnabled, itemId, series.id, event);\n    legendItemClick?.(clickEvent);\n    if (clickEvent.defaultPrevented)\n      return true;\n    if (toggleSeries) {\n      newEnabled = !enabled;\n      if (preventHidingAll && !newEnabled) {\n        const numVisibleItems = this.getVisibleItemCount();\n        if (numVisibleItems < 2) {\n          newEnabled = true;\n        }\n      }\n      proxyButton.ariaChecked = newEnabled.toString();\n      this.ctx.chartEventManager.legendItemClick(series, itemId, newEnabled, datum.legendItemName);\n    }\n    if (newEnabled) {\n      highlightManager.updateHighlight(this.id, {\n        series,\n        itemId,\n        datum: void 0\n      });\n    } else {\n      highlightManager.updateHighlight(this.id);\n    }\n    this.ctx.updateService.update(2 /* PROCESS_DATA */, { forceNodeDataRefresh: true });\n    return true;\n  }\n  onDoubleClick(event, datum) {\n    if (this.doDoubleClick(event, datum)) {\n      event.preventDefault();\n    }\n  }\n  doDoubleClick(event, datum) {\n    const {\n      listeners: { legendItemDoubleClick },\n      ctx: { chartService },\n      toggleSeries\n    } = this;\n    if (chartService.mode === \"integrated\") {\n      return false;\n    }\n    if (!datum) {\n      return false;\n    }\n    const { id, itemId, seriesId } = datum;\n    const series = chartService.series.find((s) => s.id === id);\n    if (!series) {\n      return false;\n    }\n    const doubleClickEvent = new LegendItemEvent(\"dblclick\", true, itemId, series.id, event);\n    legendItemDoubleClick?.(doubleClickEvent);\n    if (doubleClickEvent.defaultPrevented)\n      return true;\n    if (toggleSeries) {\n      const legendData = chartService.series.flatMap((s) => s.getLegendData(\"category\"));\n      const numVisibleItems = legendData.filter((d) => d.enabled).length;\n      const clickedItem = legendData.find((d) => d.itemId === itemId && d.seriesId === seriesId);\n      this.ctx.chartEventManager.legendItemDoubleClick(\n        series,\n        itemId,\n        clickedItem?.enabled ?? false,\n        numVisibleItems,\n        clickedItem?.legendItemName\n      );\n    }\n    this.ctx.updateService.update(2 /* PROCESS_DATA */, { forceNodeDataRefresh: true });\n    return true;\n  }\n  toTooltipMeta(event, node) {\n    let lastPointerEvent;\n    if (event instanceof FocusEvent) {\n      const { x, y } = Transformable.toCanvas(node).computeCenter();\n      lastPointerEvent = { type: \"keyboard\", offsetX: x, offsetY: y };\n    } else {\n      event.preventDefault();\n      const { x, y } = Transformable.toCanvasPoint(node, event.offsetX, event.offsetY);\n      lastPointerEvent = { type: \"hover\", offsetX: x, offsetY: y };\n    }\n    const { offsetX, offsetY } = lastPointerEvent;\n    return { offsetX, offsetY, lastPointerEvent, showArrow: false };\n  }\n  onHover(event, node) {\n    if (!this.enabled)\n      throw new Error(\"AG Charts - onHover handler called on disabled legend\");\n    this.pagination.setPage(node.pageIndex);\n    const datum = node.datum;\n    const series = datum ? this.ctx.chartService.series.find((s) => s.id === datum?.id) : void 0;\n    if (datum && this.truncatedItems.has(datum.itemId ?? datum.id)) {\n      const meta = this.toTooltipMeta(event, node);\n      this.ctx.tooltipManager.updateTooltip(this.id, meta, toTooltipHtml({ content: this.getItemLabel(datum) }));\n    } else {\n      this.ctx.tooltipManager.removeTooltip(this.id);\n    }\n    if (datum?.enabled && series) {\n      this.updateHighlight({ series, itemId: datum?.itemId, datum: void 0 });\n    } else {\n      this.updateHighlight();\n    }\n  }\n  onLeave() {\n    this.ctx.tooltipManager.removeTooltip(this.id);\n    this.updateHighlight();\n  }\n  updateHighlight(datum) {\n    const state = this.ctx.interactionManager.getState();\n    if (state === 32 /* Default */) {\n      this.ctx.highlightManager.updateHighlight(this.id, datum);\n    } else if (state === 2 /* Animation */) {\n      this.pendingHighlightDatum = datum;\n      this.ctx.animationManager.onBatchStop(() => {\n        this.ctx.highlightManager.updateHighlight(this.id, this.pendingHighlightDatum);\n      });\n    }\n  }\n  onLocaleChanged() {\n    this.itemSelection.each(({ proxyButton }, _, i) => {\n      if (proxyButton?.button != null) {\n        proxyButton.button.textContent = this.getItemAriaText(i);\n      }\n    });\n    this.proxyLegendItemDescription.textContent = this.getItemAriaDescription();\n  }\n  getItemAriaText(nodeIndex) {\n    const datum = this.data[nodeIndex];\n    const label = datum && this.getItemLabel(datum);\n    const lm = this.ctx.localeManager;\n    if (nodeIndex >= 0 && label) {\n      const index = nodeIndex + 1;\n      const count = this.data.length;\n      return lm.t(\"ariaLabelLegendItem\", { label, index, count });\n    }\n    return lm.t(\"ariaLabelLegendItemUnknown\");\n  }\n  getItemAriaDescription() {\n    return this.ctx.localeManager.t(\"ariaDescriptionLegendItem\");\n  }\n  positionLegend(ctx) {\n    setElementStyle(this.proxyLegendToolbar, \"display\", this.visible && this.enabled ? void 0 : \"none\");\n    if (!this.enabled || !this.data.length)\n      return;\n    const { layoutBox } = ctx;\n    const { x, y, width: width2, height: height2 } = layoutBox;\n    const [legendWidth, legendHeight] = this.calculateLegendDimensions(layoutBox);\n    const { oldPages } = this.calcLayout(legendWidth, legendHeight);\n    const legendBBox = this.computePagedBBox();\n    const calculateTranslationPerpendicularDimension = () => {\n      switch (this.position) {\n        case \"top\":\n        case \"left\":\n          return 0;\n        case \"bottom\":\n          return height2 - legendBBox.height;\n        case \"right\":\n        default:\n          return width2 - legendBBox.width;\n      }\n    };\n    if (this.visible) {\n      const legendPadding = this.spacing;\n      let translationX;\n      let translationY;\n      switch (this.position) {\n        case \"top\":\n        case \"bottom\":\n          translationX = (width2 - legendBBox.width) / 2;\n          translationY = calculateTranslationPerpendicularDimension();\n          layoutBox.shrink(legendBBox.height + legendPadding, this.position);\n          break;\n        case \"left\":\n        case \"right\":\n        default:\n          translationX = calculateTranslationPerpendicularDimension();\n          translationY = (height2 - legendBBox.height) / 2;\n          layoutBox.shrink(legendBBox.width + legendPadding, this.position);\n      }\n      this.group.translationX = Math.floor(x + translationX - legendBBox.x);\n      this.group.translationY = Math.floor(y + translationY - legendBBox.y);\n      this.proxyLegendToolbar.ariaOrientation = this.getOrientation();\n    }\n    this.updateItemProxyButtons();\n    this.updatePaginationProxyButtons(oldPages);\n  }\n  calculateLegendDimensions(shrinkRect) {\n    const { width: width2, height: height2 } = shrinkRect;\n    const aspectRatio = width2 / height2;\n    const maxCoefficient = 0.5;\n    const minHeightCoefficient = 0.2;\n    const minWidthCoefficient = 0.25;\n    let legendWidth, legendHeight;\n    switch (this.position) {\n      case \"top\":\n      case \"bottom\": {\n        const heightCoefficient = aspectRatio < 1 ? Math.min(maxCoefficient, minHeightCoefficient * (1 / aspectRatio)) : minHeightCoefficient;\n        legendWidth = this.maxWidth ? Math.min(this.maxWidth, width2) : width2;\n        legendHeight = this.maxHeight ? Math.min(this.maxHeight, height2) : Math.round(height2 * heightCoefficient);\n        break;\n      }\n      case \"left\":\n      case \"right\":\n      default: {\n        const widthCoefficient = aspectRatio > 1 ? Math.min(maxCoefficient, minWidthCoefficient * aspectRatio) : minWidthCoefficient;\n        legendWidth = this.maxWidth ? Math.min(this.maxWidth, width2) : Math.round(width2 * widthCoefficient);\n        legendHeight = this.maxHeight ? Math.min(this.maxHeight, height2) : height2;\n      }\n    }\n    return [legendWidth, legendHeight];\n  }\n};\nLegend.className = \"Legend\";\n__decorateClass([\n  Validate(BOOLEAN)\n], Legend.prototype, \"toggleSeries\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Legend.prototype, \"pagination\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Legend.prototype, \"item\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Legend.prototype, \"listeners\", 2);\n__decorateClass([\n  ObserveChanges((target) => target.updateGroupVisibility()),\n  Validate(BOOLEAN)\n], Legend.prototype, \"enabled\", 2);\n__decorateClass([\n  ObserveChanges((target) => target.proxyLegendDirty = true),\n  Validate(POSITION)\n], Legend.prototype, \"position\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], Legend.prototype, \"maxWidth\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], Legend.prototype, \"maxHeight\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], Legend.prototype, \"reverseOrder\", 2);\n__decorateClass([\n  Validate(UNION([\"horizontal\", \"vertical\"], \"an orientation\"), { optional: true })\n], Legend.prototype, \"orientation\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], Legend.prototype, \"preventHidingAll\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Legend.prototype, \"spacing\", 2);\n\n// packages/ag-charts-community/src/chart/legendModule.ts\nvar CommunityLegendModule = {\n  type: \"legend\",\n  optionsKey: \"legend\",\n  identifier: \"category\",\n  chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\", \"standalone\", \"gauge\"],\n  moduleFactory: (ctx) => new Legend(ctx),\n  packageType: \"community\"\n};\n\n// packages/ag-charts-community/src/chart/navigator/shapes/rangeHandle.ts\nvar RangeHandle = class extends Path {\n  constructor() {\n    super(...arguments);\n    this.zIndex = 3;\n    this.centerX = 0;\n    this.centerY = 0;\n    this.width = 8;\n    this.height = 16;\n    this.gripLineGap = 2;\n    this.gripLineLength = 8;\n  }\n  setCenter(x, y) {\n    this.dirtyPath = true;\n    if (this.centerX !== x || this.centerY !== y) {\n      this.centerX = x;\n      this.centerY = y;\n      this.markDirty(3 /* MAJOR */);\n    }\n  }\n  static align(minHandle, maxHandle, x, y, width2, height2, min, max) {\n    const handlePixelAlign = minHandle.strokeWidth / 2;\n    const minHandleX = minHandle.align(x + width2 * min) + handlePixelAlign;\n    const maxHandleX = minHandleX + minHandle.align(x + width2 * min, width2 * (max - min)) - 2 * handlePixelAlign;\n    const handleY = minHandle.align(y + height2 / 2) + handlePixelAlign;\n    minHandle.setCenter(minHandleX, handleY);\n    maxHandle.setCenter(maxHandleX, handleY);\n  }\n  computeBBox() {\n    const { centerX, centerY, width: width2, height: height2 } = this;\n    const x = centerX - width2 / 2;\n    const y = centerY - height2 / 2;\n    return new BBox(x, y, width2, height2);\n  }\n  isPointInPath(x, y) {\n    const bbox = this.getBBox();\n    return bbox.containsPoint(x, y);\n  }\n  updatePath() {\n    const { centerX, centerY, path, strokeWidth, gripLineGap, gripLineLength } = this;\n    const pixelRatio = this.layerManager?.canvas?.pixelRatio ?? 1;\n    path.clear();\n    const halfWidth = Math.floor(this.width / 2 * pixelRatio) / pixelRatio;\n    const halfHeight = Math.floor(this.height / 2 * pixelRatio) / pixelRatio;\n    path.moveTo(centerX - halfWidth, centerY - halfHeight);\n    path.lineTo(centerX + halfWidth, centerY - halfHeight);\n    path.lineTo(centerX + halfWidth, centerY + halfHeight);\n    path.lineTo(centerX - halfWidth, centerY + halfHeight);\n    path.closePath();\n    const dx = Math.floor((gripLineGap + strokeWidth) / 2 * pixelRatio) / pixelRatio;\n    const dy = Math.floor(gripLineLength / 2 * pixelRatio) / pixelRatio;\n    path.moveTo(centerX - dx, centerY - dy);\n    path.lineTo(centerX - dx, centerY + dy);\n    path.moveTo(centerX + dx, centerY - dy);\n    path.lineTo(centerX + dx, centerY + dy);\n  }\n};\nRangeHandle.className = \"RangeHandle\";\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */, type: \"path\" })\n], RangeHandle.prototype, \"width\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */, type: \"path\" })\n], RangeHandle.prototype, \"height\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */, type: \"path\" })\n], RangeHandle.prototype, \"gripLineGap\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */, type: \"path\" })\n], RangeHandle.prototype, \"gripLineLength\", 2);\n\n// packages/ag-charts-community/src/chart/navigator/shapes/rangeMask.ts\nvar RangeMask = class extends Path {\n  constructor() {\n    super(...arguments);\n    this.zIndex = 2;\n    this.x = 0;\n    this.y = 0;\n    this.width = 200;\n    this.height = 30;\n    this.min = 0;\n    this.max = 1;\n  }\n  layout(x, y, width2, height2) {\n    if (x !== this.x || y !== this.y || width2 !== this.width || this.height !== height2) {\n      this.x = x;\n      this.y = y;\n      this.width = width2;\n      this.height = height2;\n      this.dirtyPath = true;\n      this.markDirty(3 /* MAJOR */);\n    }\n  }\n  update(min, max) {\n    min = isNaN(min) ? this.min : min;\n    max = isNaN(max) ? this.max : max;\n    if (min !== this.min || max !== this.max) {\n      this.min = min;\n      this.max = max;\n      this.dirtyPath = true;\n      this.markDirty(3 /* MAJOR */);\n    }\n  }\n  computeBBox() {\n    const { x, y, width: width2, height: height2 } = this;\n    return new BBox(x, y, width2, height2);\n  }\n  computeVisibleRangeBBox() {\n    const { x, y, width: width2, height: height2, min, max } = this;\n    const minX = x + width2 * min;\n    const maxX = x + width2 * max;\n    return new BBox(minX, y, maxX - minX, height2);\n  }\n  updatePath() {\n    const { path, x, y, width: width2, height: height2, min, max, strokeWidth } = this;\n    const pixelAlign = strokeWidth / 2;\n    path.clear();\n    const ax = this.align(x) + pixelAlign;\n    const ay = this.align(y) + pixelAlign;\n    const axw = ax + this.align(x, width2) - 2 * pixelAlign;\n    const ayh = ay + this.align(y, height2) - 2 * pixelAlign;\n    path.moveTo(ax, ay);\n    path.lineTo(axw, ay);\n    path.lineTo(axw, ayh);\n    path.lineTo(ax, ayh);\n    path.closePath();\n    const minX = this.align(x + width2 * min) + pixelAlign;\n    const maxX = minX + this.align(x + width2 * min, width2 * (max - min)) - 2 * pixelAlign;\n    path.moveTo(minX, ay);\n    path.lineTo(minX, ayh);\n    path.lineTo(maxX, ayh);\n    path.lineTo(maxX, ay);\n    path.closePath();\n  }\n};\nRangeMask.className = \"RangeMask\";\n\n// packages/ag-charts-community/src/chart/navigator/shapes/rangeSelector.ts\nvar RangeSelector = class extends Layer {\n  constructor(children) {\n    super({ name: \"rangeSelectorGroup\", zIndex: 16 /* NAVIGATOR */ });\n    this.x = 0;\n    this.y = 0;\n    this.width = 200;\n    this.height = 30;\n    this.lOffset = 0;\n    this.rOffset = 0;\n    this.background = this.appendChild(new TranslatableGroup({ name: \"navigator-background\", zIndex: 1 }));\n    this.append(children);\n  }\n  layout(x, y, width2, height2, lOffset, rOffset) {\n    this.x = x;\n    this.y = y;\n    this.width = width2;\n    this.height = height2;\n    this.lOffset = lOffset;\n    this.rOffset = rOffset;\n    this.background.translationX = x;\n    this.background.translationY = y;\n    this.markDirty(3 /* MAJOR */);\n  }\n  updateBackground(oldGroup, newGroup) {\n    if (oldGroup != null) {\n      this.background.removeChild(oldGroup);\n    }\n    if (newGroup != null) {\n      this.background.appendChild(newGroup);\n    }\n    this.markDirty(3 /* MAJOR */);\n  }\n  computeBBox() {\n    const { x, y, width: width2, height: height2, lOffset, rOffset } = this;\n    return new BBox(x - lOffset, y, width2 + (lOffset + rOffset), height2);\n  }\n};\n\n// packages/ag-charts-community/src/chart/navigator/navigator.ts\nvar Navigator = class extends BaseModuleInstance {\n  constructor(ctx) {\n    super();\n    this.ctx = ctx;\n    this.miniChart = void 0;\n    this.enabled = false;\n    this.mask = new RangeMask();\n    this.minHandle = new RangeHandle();\n    this.maxHandle = new RangeHandle();\n    this.maskVisibleRange = {\n      id: \"navigator-mask-visible-range\",\n      getBBox: () => this.mask.computeVisibleRangeBBox(),\n      toCanvasBBox: () => this.mask.computeVisibleRangeBBox(),\n      fromCanvasPoint: (x, y) => ({ x, y })\n    };\n    this.height = 30;\n    this.spacing = 10;\n    this.x = 0;\n    this.y = 0;\n    this.width = 0;\n    this.rangeSelector = new RangeSelector([this.mask, this.minHandle, this.maxHandle]);\n    this._min = 0;\n    this._max = 1;\n    this.minRange = 1e-3;\n    const region = ctx.regionManager.addRegion(\"navigator\", this.rangeSelector);\n    const dragStates = 32 /* Default */ | 2 /* Animation */ | 16 /* ZoomDrag */;\n    this.destroyFns.push(\n      ctx.scene.attachNode(this.rangeSelector),\n      region.addListener(\"hover\", (event) => this.onHover(event), dragStates),\n      region.addListener(\"drag-start\", (event) => this.onDragStart(event), dragStates),\n      region.addListener(\"drag\", (event) => this.onDrag(event), dragStates),\n      region.addListener(\"drag-end\", (event) => this.onDragEnd(event), dragStates),\n      region.addListener(\"leave\", (event) => this.onLeave(event), dragStates),\n      this.ctx.localeManager.addListener(\"locale-changed\", () => this.updateZoom()),\n      this.ctx.layoutManager.registerElement(3 /* Navigator */, (e) => this.onLayoutStart(e)),\n      this.ctx.layoutManager.addListener(\"layout:complete\", (e) => this.onLayoutComplete(e)),\n      ctx.zoomManager.addListener(\"zoom-change\", (event) => this.onZoomChange(event))\n    );\n    this.proxyNavigatorToolbar = this.ctx.proxyInteractionService.createProxyContainer({\n      type: \"toolbar\",\n      id: `navigator-toolbar`,\n      classList: [\"ag-charts-proxy-navigator-toolbar\"],\n      ariaOrientation: \"vertical\",\n      ariaLabel: { id: \"ariaLabelNavigator\" }\n    });\n    this.updateGroupVisibility();\n    this.proxyNavigatorElements = [\n      this.ctx.proxyInteractionService.createProxyElement({\n        type: \"slider\",\n        id: \"ag-charts-navigator-min\",\n        ariaLabel: { id: \"ariaLabelNavigatorMinimum\" },\n        ariaOrientation: \"horizontal\",\n        parent: this.proxyNavigatorToolbar,\n        onchange: (ev) => this.onMinSliderChange(ev)\n      }),\n      this.ctx.proxyInteractionService.createProxyElement({\n        type: \"slider\",\n        id: \"ag-charts-navigator-pan\",\n        ariaLabel: { id: \"ariaLabelNavigatorRange\" },\n        ariaOrientation: \"horizontal\",\n        parent: this.proxyNavigatorToolbar,\n        onchange: (ev) => this.onPanSliderChange(ev)\n      }),\n      this.ctx.proxyInteractionService.createProxyElement({\n        type: \"slider\",\n        id: \"ag-charts-navigator-max\",\n        ariaLabel: { id: \"ariaLabelNavigatorMaximum\" },\n        ariaOrientation: \"horizontal\",\n        parent: this.proxyNavigatorToolbar,\n        onchange: (ev) => this.onMaxSliderChange(ev)\n      })\n    ];\n    this.proxyNavigatorElements.forEach((slider) => setAttribute(slider, \"data-preventdefault\", false));\n    this.setSliderRatio(this.proxyNavigatorElements[0], this._min);\n    this.setSliderRatio(this.proxyNavigatorElements[2], this._max);\n    this.setPanSliderValue(this._min, this._max);\n    initToolbarKeyNav({\n      orientation: \"vertical\",\n      toolbar: this.proxyNavigatorToolbar,\n      buttons: this.proxyNavigatorElements\n    });\n    this.destroyFns.push(() => {\n      this.proxyNavigatorElements.forEach((e) => e.remove());\n      this.proxyNavigatorToolbar.remove();\n    });\n  }\n  updateBackground(oldGroup, newGroup) {\n    this.rangeSelector?.updateBackground(oldGroup, newGroup);\n  }\n  updateGroupVisibility() {\n    const { enabled } = this;\n    if (this.rangeSelector == null || enabled === this.rangeSelector.visible)\n      return;\n    this.rangeSelector.visible = enabled;\n    this.proxyNavigatorToolbar.ariaHidden = (!enabled).toString();\n    if (enabled) {\n      this.updateZoom();\n    } else {\n      this.ctx.zoomManager.updateZoom(\"navigator\");\n    }\n  }\n  onLayoutStart(ctx) {\n    if (this.enabled) {\n      const { layoutBox } = ctx;\n      const navigatorTotalHeight = this.height + this.spacing;\n      layoutBox.shrink(navigatorTotalHeight, \"bottom\");\n      this.y = layoutBox.y + layoutBox.height + this.spacing;\n    } else {\n      this.y = 0;\n    }\n  }\n  onLayoutComplete(opts) {\n    const { x, width: width2 } = opts.series.rect;\n    if (this.enabled) {\n      const { y, height: height2 } = this;\n      this.layoutNodes(x, y, width2, height2);\n      setElementBBox(this.proxyNavigatorToolbar, { x, y, width: width2, height: height2 });\n      this.proxyNavigatorToolbar.style.removeProperty(\"display\");\n    } else {\n      this.proxyNavigatorToolbar.style.display = \"none\";\n    }\n    this.x = x;\n    this.width = width2;\n  }\n  onHover(event) {\n    if (!this.enabled)\n      return;\n    this.updateCursor(event);\n  }\n  updateCursor(event) {\n    if (!this.enabled)\n      return;\n    const { mask, minHandle, maxHandle } = this;\n    const { regionOffsetX, regionOffsetY } = event;\n    if (minHandle.containsPoint(regionOffsetX, regionOffsetY) || maxHandle.containsPoint(regionOffsetX, regionOffsetY)) {\n      this.ctx.cursorManager.updateCursor(\"navigator\", \"ew-resize\");\n    } else if (mask.computeVisibleRangeBBox().containsPoint(regionOffsetX, regionOffsetY)) {\n      this.ctx.cursorManager.updateCursor(\"navigator\", \"grab\");\n    } else {\n      this.ctx.cursorManager.updateCursor(\"navigator\");\n    }\n  }\n  onDragStart(event) {\n    if (!this.enabled)\n      return;\n    this.updateCursor(event);\n    const { mask, minHandle, maxHandle, x, width: width2, _min: min } = this;\n    const { regionOffsetX, regionOffsetY } = event;\n    if (minHandle.zIndex < maxHandle.zIndex) {\n      if (maxHandle.containsPoint(regionOffsetX, regionOffsetY)) {\n        this.dragging = \"max\";\n      } else if (minHandle.containsPoint(regionOffsetX, regionOffsetY)) {\n        this.dragging = \"min\";\n      }\n    } else if (minHandle.containsPoint(regionOffsetX, regionOffsetY)) {\n      this.dragging = \"min\";\n    } else if (maxHandle.containsPoint(regionOffsetX, regionOffsetY)) {\n      this.dragging = \"max\";\n    }\n    if (this.dragging == null && mask.computeVisibleRangeBBox().containsPoint(regionOffsetX, regionOffsetY)) {\n      this.dragging = \"pan\";\n      this.panStart = (regionOffsetX - x) / width2 - min;\n    }\n    if (this.dragging != null) {\n      this.ctx.zoomManager.fireZoomPanStartEvent(\"navigator\");\n    }\n  }\n  onDrag(event) {\n    if (!this.enabled || this.dragging == null)\n      return;\n    const { dragging, minRange, panStart, x, width: width2 } = this;\n    let { _min: min, _max: max } = this;\n    const { regionOffsetX } = event;\n    const ratio2 = (regionOffsetX - x) / width2;\n    if (dragging === \"min\") {\n      min = clamp(0, ratio2, max - minRange);\n    } else if (dragging === \"max\") {\n      max = clamp(min + minRange, ratio2, 1);\n    } else if (dragging === \"pan\" && panStart != null) {\n      const span = max - min;\n      min = clamp(0, ratio2 - panStart, 1 - span);\n      max = min + span;\n    }\n    this._min = min;\n    this._max = max;\n    this.updateZoom();\n  }\n  onDragEnd(event) {\n    this.dragging = void 0;\n    this.updateCursor(event);\n  }\n  onLeave(_event) {\n    this.ctx.cursorManager.updateCursor(\"navigator\");\n  }\n  onZoomChange(event) {\n    const { x } = event;\n    if (!x)\n      return;\n    this._min = x.min;\n    this._max = x.max;\n    this.updateNodes(x.min, x.max);\n    this.setPanSliderValue(x.min, x.max);\n    this.setSliderRatio(this.proxyNavigatorElements[0], x.min);\n    this.setSliderRatio(this.proxyNavigatorElements[2], x.max);\n  }\n  onPanSliderChange(_event) {\n    const ratio2 = this.getSliderRatio(this.proxyNavigatorElements[1]);\n    const span = this._max - this._min;\n    this._min = clamp(0, ratio2, 1 - span);\n    this._max = this._min + span;\n    this.updateZoom();\n  }\n  onMinSliderChange(_event) {\n    const slider = this.proxyNavigatorElements[0];\n    this._min = this.setSliderRatioClamped(slider, 0, this._max - this.minRange);\n    this.updateZoom();\n  }\n  onMaxSliderChange(_event) {\n    const slider = this.proxyNavigatorElements[2];\n    this._max = this.setSliderRatioClamped(slider, this._min + this.minRange, 1);\n    this.updateZoom();\n  }\n  setPanSliderValue(min, max) {\n    this.proxyNavigatorElements[1].value = `${Math.round(min * 100)}`;\n    this.proxyNavigatorElements[1].ariaValueText = this.ctx.localeManager.t(\"ariaValuePanRange\", { min, max });\n  }\n  setSliderRatioClamped(slider, clampMin, clampMax) {\n    const ratio2 = this.getSliderRatio(slider);\n    const clampedRatio = clamp(clampMin, ratio2, clampMax);\n    if (clampedRatio !== ratio2) {\n      this.setSliderRatio(slider, clampedRatio);\n    }\n    return clampedRatio;\n  }\n  setSliderRatio(slider, ratio2) {\n    const value = Math.round(ratio2 * 100);\n    slider.value = `${value}`;\n    slider.ariaValueText = formatPercentage(value);\n  }\n  getSliderRatio(slider) {\n    return parseFloat(slider.value) / 100;\n  }\n  layoutNodes(x, y, width2, height2) {\n    const { rangeSelector, mask, minHandle, maxHandle, _min: min, _max: max } = this;\n    rangeSelector.layout(x, y, width2, height2, minHandle.width / 2, maxHandle.width / 2);\n    mask.layout(x, y, width2, height2);\n    RangeHandle.align(minHandle, maxHandle, x, y, width2, height2, min, max);\n    if (min + (max - min) / 2 < 0.5) {\n      minHandle.zIndex = 3;\n      maxHandle.zIndex = 4;\n    } else {\n      minHandle.zIndex = 4;\n      maxHandle.zIndex = 3;\n    }\n    [minHandle, this.maskVisibleRange, maxHandle].forEach((node, index) => {\n      const bbox = node.getBBox();\n      const tbox = { x: bbox.x - x, y: bbox.y - y, height: bbox.height, width: bbox.width };\n      setElementBBox(this.proxyNavigatorElements[index], tbox);\n    });\n  }\n  updateNodes(min, max) {\n    this.mask.update(min, max);\n  }\n  updateZoom() {\n    if (!this.enabled)\n      return;\n    const { _min: min, _max: max } = this;\n    if (min == null || max == null)\n      return;\n    const warnOnConflict = (stateId) => {\n      if (this.min == null && this.max == null)\n        return;\n      Logger.warnOnce(\n        `Could not apply [navigator.min] or [navigator.max] as [${stateId}] has modified the initial zoom state.`\n      );\n    };\n    return this.ctx.zoomManager.updateZoom(\"navigator\", { x: { min, max } }, false, warnOnConflict);\n  }\n};\n__decorateClass([\n  Validate(OBJECT, { optional: true })\n], Navigator.prototype, \"miniChart\", 2);\n__decorateClass([\n  Validate(BOOLEAN),\n  ObserveChanges((target) => target.updateGroupVisibility())\n], Navigator.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Navigator.prototype, \"height\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Navigator.prototype, \"spacing\", 2);\n__decorateClass([\n  ActionOnSet({\n    newValue(min) {\n      this._min = min;\n      this.updateZoom();\n    }\n  }),\n  Validate(AND(RATIO, LESS_THAN(\"max\")), { optional: true })\n], Navigator.prototype, \"min\", 2);\n__decorateClass([\n  ActionOnSet({\n    newValue(max) {\n      this._max = max;\n      this.updateZoom();\n    }\n  }),\n  Validate(AND(RATIO, GREATER_THAN(\"min\")), { optional: true })\n], Navigator.prototype, \"max\", 2);\n\n// packages/ag-charts-community/src/chart/navigator/navigatorModule.ts\nvar NavigatorModule = {\n  type: \"root\",\n  optionsKey: \"navigator\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  moduleFactory: (ctx) => new Navigator(ctx),\n  themeTemplate: {\n    navigator: {\n      enabled: false,\n      height: 30,\n      mask: {\n        fill: \"#999999\",\n        stroke: \"#999999\",\n        strokeWidth: 1,\n        fillOpacity: 0.2\n      },\n      minHandle: {\n        fill: \"#f2f2f2\",\n        stroke: \"#999999\",\n        strokeWidth: 1,\n        width: 9,\n        height: 16,\n        gripLineGap: 1,\n        gripLineLength: 8\n      },\n      maxHandle: {\n        fill: \"#f2f2f2\",\n        stroke: \"#999999\",\n        strokeWidth: 1,\n        width: 9,\n        height: 16,\n        gripLineGap: 1,\n        gripLineLength: 8\n      }\n    }\n  }\n};\n\n// packages/ag-charts-community/src/module/theme.ts\nfunction singleSeriesPaletteFactory({ takeColors }) {\n  const {\n    fills: [fill],\n    strokes: [stroke]\n  } = takeColors(1);\n  return { fill, stroke };\n}\nfunction markerPaletteFactory(params) {\n  return { marker: singleSeriesPaletteFactory(params) };\n}\n\n// packages/ag-charts-community/src/chart/themes/constants.ts\nvar FONT_SIZE = /* @__PURE__ */ ((FONT_SIZE2) => {\n  FONT_SIZE2[FONT_SIZE2[\"SMALL\"] = 12] = \"SMALL\";\n  FONT_SIZE2[FONT_SIZE2[\"MEDIUM\"] = 13] = \"MEDIUM\";\n  FONT_SIZE2[FONT_SIZE2[\"LARGE\"] = 17] = \"LARGE\";\n  return FONT_SIZE2;\n})(FONT_SIZE || {});\nvar FONT_WEIGHT2 = /* @__PURE__ */ ((FONT_WEIGHT3) => {\n  FONT_WEIGHT3[\"NORMAL\"] = \"normal\";\n  FONT_WEIGHT3[\"BOLD\"] = \"bold\";\n  FONT_WEIGHT3[\"BOLDER\"] = \"bolder\";\n  FONT_WEIGHT3[\"LIGHTER\"] = \"lighter\";\n  return FONT_WEIGHT3;\n})(FONT_WEIGHT2 || {});\nvar CARTESIAN_POSITION = /* @__PURE__ */ ((CARTESIAN_POSITION2) => {\n  CARTESIAN_POSITION2[\"TOP\"] = \"top\";\n  CARTESIAN_POSITION2[\"RIGHT\"] = \"right\";\n  CARTESIAN_POSITION2[\"BOTTOM\"] = \"bottom\";\n  CARTESIAN_POSITION2[\"LEFT\"] = \"left\";\n  return CARTESIAN_POSITION2;\n})(CARTESIAN_POSITION || {});\nvar CARTESIAN_AXIS_TYPE = /* @__PURE__ */ ((CARTESIAN_AXIS_TYPE2) => {\n  CARTESIAN_AXIS_TYPE2[\"CATEGORY\"] = \"category\";\n  CARTESIAN_AXIS_TYPE2[\"ORDINAL_TIME\"] = \"ordinal-time\";\n  CARTESIAN_AXIS_TYPE2[\"NUMBER\"] = \"number\";\n  CARTESIAN_AXIS_TYPE2[\"TIME\"] = \"time\";\n  CARTESIAN_AXIS_TYPE2[\"LOG\"] = \"log\";\n  return CARTESIAN_AXIS_TYPE2;\n})(CARTESIAN_AXIS_TYPE || {});\nvar POLAR_AXIS_TYPE = /* @__PURE__ */ ((POLAR_AXIS_TYPE2) => {\n  POLAR_AXIS_TYPE2[\"ANGLE_CATEGORY\"] = \"angle-category\";\n  POLAR_AXIS_TYPE2[\"ANGLE_NUMBER\"] = \"angle-number\";\n  POLAR_AXIS_TYPE2[\"RADIUS_CATEGORY\"] = \"radius-category\";\n  POLAR_AXIS_TYPE2[\"RADIUS_NUMBER\"] = \"radius-number\";\n  return POLAR_AXIS_TYPE2;\n})(POLAR_AXIS_TYPE || {});\nvar POLAR_AXIS_SHAPE = /* @__PURE__ */ ((POLAR_AXIS_SHAPE2) => {\n  POLAR_AXIS_SHAPE2[\"CIRCLE\"] = \"circle\";\n  POLAR_AXIS_SHAPE2[\"POLYGON\"] = \"polygon\";\n  return POLAR_AXIS_SHAPE2;\n})(POLAR_AXIS_SHAPE || {});\n\n// packages/ag-charts-community/src/chart/themes/symbols.ts\nvar IS_DARK_THEME = Symbol(\"is-dark-theme\");\nvar IS_COMMUNITY = Symbol(\"is-community\");\nvar IS_ENTERPRISE = Symbol(\"is-enterprise\");\nvar DEFAULT_FONT_FAMILY = Symbol(\"default-font\");\nvar DEFAULT_LABEL_COLOUR = Symbol(\"default-label-colour\");\nvar DEFAULT_INVERTED_LABEL_COLOUR = Symbol(\"default-inverted-label-colour\");\nvar DEFAULT_INSIDE_SERIES_LABEL_COLOUR = Symbol(\"default-inside-series-label-colour\");\nvar DEFAULT_MUTED_LABEL_COLOUR = Symbol(\"default-muted-label-colour\");\nvar DEFAULT_AXIS_GRID_COLOUR = Symbol(\"default-axis-grid-colour\");\nvar DEFAULT_AXIS_LINE_COLOUR = Symbol(\"default-axis-line-colour\");\nvar DEFAULT_CROSS_LINES_COLOUR = Symbol(\"default-cross-lines-colour\");\nvar DEFAULT_BACKGROUND_COLOUR = Symbol(\"default-background-colour\");\nvar DEFAULT_SHADOW_COLOUR = Symbol(\"default-shadow-colour\");\nvar DEFAULT_COLOURS = Symbol(\"default-colours\");\nvar DEFAULT_PADDING = Symbol(\"default-padding\");\nvar DEFAULT_CAPTION_LAYOUT_STYLE = Symbol(\"default-caption-layout-style\");\nvar DEFAULT_CAPTION_ALIGNMENT = Symbol(\"default-caption-alignment\");\nvar PALETTE_UP_STROKE = Symbol(\"palette-up-stroke\");\nvar PALETTE_DOWN_STROKE = Symbol(\"palette-down-stroke\");\nvar PALETTE_UP_FILL = Symbol(\"palette-up-fill\");\nvar PALETTE_DOWN_FILL = Symbol(\"palette-down-fill\");\nvar PALETTE_NEUTRAL_STROKE = Symbol(\"palette-neutral-stroke\");\nvar PALETTE_NEUTRAL_FILL = Symbol(\"palette-neutral-fill\");\nvar PALETTE_ALT_UP_STROKE = Symbol(\"palette-alt-up-stroke\");\nvar PALETTE_ALT_DOWN_STROKE = Symbol(\"palette-alt-down-stroke\");\nvar PALETTE_ALT_UP_FILL = Symbol(\"palette-alt-up-fill\");\nvar PALETTE_ALT_DOWN_FILL = Symbol(\"palette-alt-down-fill\");\nvar PALETTE_ALT_NEUTRAL_FILL = Symbol(\"palette-gray-fill\");\nvar PALETTE_ALT_NEUTRAL_STROKE = Symbol(\"palette-gray-stroke\");\nvar DEFAULT_POLAR_SERIES_STROKE = Symbol(\"default-polar-series-stroke\");\nvar DEFAULT_DIVERGING_SERIES_COLOR_RANGE = Symbol(\n  \"default-diverging-series-colour-range\"\n);\nvar DEFAULT_GAUGE_SERIES_COLOR_RANGE = Symbol(\"default-gauge-series-colour-range\");\nvar DEFAULT_FUNNEL_SERIES_COLOR_RANGE = Symbol(\"default-funnel-series-colour-range\");\nvar DEFAULT_HIERARCHY_FILLS = Symbol(\"default-hierarchy-fills\");\nvar DEFAULT_HIERARCHY_STROKES = Symbol(\"default-hierarchy-strokes\");\nvar DEFAULT_ANNOTATION_COLOR = Symbol(\"default-annotation-stroke\");\nvar DEFAULT_TEXT_ANNOTATION_COLOR = Symbol(\"default-text-annotation-color\");\nvar DEFAULT_ANNOTATION_BACKGROUND_FILL = Symbol(\"default-annotation-background-fill\");\nvar DEFAULT_ANNOTATION_HANDLE_FILL = Symbol(\"default-annotation-handle-fill\");\nvar DEFAULT_ANNOTATION_STATISTICS_FILL = Symbol(\"default-annotation-statistics-fill\");\nvar DEFAULT_ANNOTATION_STATISTICS_STROKE = Symbol(\"default-annotation-statistics-stroke\");\nvar DEFAULT_ANNOTATION_STATISTICS_COLOR = Symbol(\"default-annotation-statistics-color\");\nvar DEFAULT_ANNOTATION_STATISTICS_DIVIDER_STROKE = Symbol(\n  \"default-annotation-statistics-divider-stroke\"\n);\nvar DEFAULT_ANNOTATION_STATISTICS_DOWN_FILL = Symbol(\n  \"default-annotation-statistics-fill\"\n);\nvar DEFAULT_ANNOTATION_STATISTICS_DOWN_STROKE = Symbol(\n  \"default-annotation-statistics-stroke\"\n);\nvar DEFAULT_TEXTBOX_FILL = Symbol(\"default-textbox-fill\");\nvar DEFAULT_TEXTBOX_STROKE = Symbol(\"default-textbox-stroke\");\nvar DEFAULT_TEXTBOX_COLOR = Symbol(\"default-textbox-color\");\nvar DEFAULT_TOOLBAR_POSITION = Symbol(\"default-toolbar-position\");\nvar DEFAULT_GRIDLINE_ENABLED = Symbol(\"default-gridline-enabled\");\n\n// packages/ag-charts-community/src/motion/pathMotion.ts\nfunction pathMotion(groupId, subId, animationManager, paths, fns) {\n  const { addPhaseFn, updatePhaseFn, removePhaseFn } = fns;\n  const animate = (phase, path, updateFn) => {\n    animationManager.animate({\n      id: `${groupId}_${subId}_${path.id}_${phase}`,\n      groupId,\n      from: 0,\n      to: 1,\n      ease: easeOut,\n      collapsable: false,\n      onUpdate(ratio2, preInit) {\n        if (preInit && phase !== \"removed\")\n          return;\n        path.path.clear(true);\n        updateFn(ratio2, path);\n        path.checkPathDirty();\n      },\n      onStop() {\n        if (phase !== \"added\")\n          return;\n        path.path.clear(true);\n        updateFn(1, path);\n        path.checkPathDirty();\n      },\n      phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[phase]\n    });\n  };\n  for (const path of paths) {\n    if (!animationManager.isSkipped()) {\n      animate(\"removed\", path, removePhaseFn);\n      animate(\"updated\", path, updatePhaseFn);\n    }\n    animate(\"added\", path, addPhaseFn);\n  }\n}\n\n// packages/ag-charts-community/src/util/format.util.ts\nfunction formatValue(value) {\n  if (typeof value === \"number\") {\n    return value.toFixed(2);\n  }\n  return String(value ?? \"\");\n}\n\n// packages/ag-charts-community/src/util/sanitize.ts\nvar element = null;\nfunction sanitizeHtml(text) {\n  if (text == null) {\n    return;\n  } else if (text === \"\") {\n    return \"\";\n  }\n  element ?? (element = createElement(\"div\"));\n  element.textContent = String(text);\n  return element.innerHTML;\n}\n\n// packages/ag-charts-community/src/util/memo.ts\nvar memorizedFns = /* @__PURE__ */ new WeakMap();\nfunction memo(params, fnGenerator) {\n  const serialisedParams = JSON.stringify(params, null, 0);\n  if (!memorizedFns.has(fnGenerator)) {\n    memorizedFns.set(fnGenerator, /* @__PURE__ */ new Map());\n  }\n  if (!memorizedFns.get(fnGenerator)?.has(serialisedParams)) {\n    memorizedFns.get(fnGenerator)?.set(serialisedParams, fnGenerator(params));\n  }\n  return memorizedFns.get(fnGenerator)?.get(serialisedParams);\n}\n\n// packages/ag-charts-community/src/chart/data/aggregateFunctions.ts\nfunction sumValues(values, accumulator = [0, 0]) {\n  for (const value of values) {\n    if (typeof value !== \"number\") {\n      continue;\n    }\n    if (value < 0) {\n      accumulator[0] += value;\n    }\n    if (value > 0) {\n      accumulator[1] += value;\n    }\n  }\n  return accumulator;\n}\nfunction sum(id, matchGroupId) {\n  const result = {\n    id,\n    matchGroupIds: [matchGroupId],\n    type: \"aggregate\",\n    aggregateFunction: (values) => sumValues(values)\n  };\n  return result;\n}\nfunction groupSum(id, matchGroupId) {\n  return {\n    id,\n    type: \"aggregate\",\n    matchGroupIds: matchGroupId ? [matchGroupId] : void 0,\n    aggregateFunction: (values) => sumValues(values),\n    groupAggregateFunction: (next, acc = [0, 0]) => {\n      acc[0] += next?.[0] ?? 0;\n      acc[1] += next?.[1] ?? 0;\n      return acc;\n    }\n  };\n}\nfunction range2(id, matchGroupId) {\n  const result = {\n    id,\n    matchGroupIds: [matchGroupId],\n    type: \"aggregate\",\n    aggregateFunction: (values) => ContinuousDomain.extendDomain(values)\n  };\n  return result;\n}\nfunction groupCount(id) {\n  return {\n    id,\n    type: \"aggregate\",\n    aggregateFunction: () => [0, 1],\n    groupAggregateFunction: (next, acc = [0, 0]) => {\n      acc[0] += next?.[0] ?? 0;\n      acc[1] += next?.[1] ?? 0;\n      return acc;\n    }\n  };\n}\nfunction groupAverage(id, matchGroupId) {\n  const def = {\n    id,\n    matchGroupIds: matchGroupId ? [matchGroupId] : void 0,\n    type: \"aggregate\",\n    aggregateFunction: (values) => sumValues(values),\n    groupAggregateFunction: (next, acc = [0, 0, -1]) => {\n      acc[0] += next?.[0] ?? 0;\n      acc[1] += next?.[1] ?? 0;\n      acc[2]++;\n      return acc;\n    },\n    finalFunction: (acc = [0, 0, 0]) => {\n      const result = acc[0] + acc[1];\n      if (result >= 0) {\n        return [0, result / acc[2]];\n      }\n      return [result / acc[2], 0];\n    }\n  };\n  return def;\n}\nfunction area(id, aggFn, matchGroupId) {\n  const result = {\n    id,\n    matchGroupIds: matchGroupId ? [matchGroupId] : void 0,\n    type: \"aggregate\",\n    aggregateFunction: (values, keyRange = []) => {\n      const keyWidth = keyRange[1] - keyRange[0];\n      return aggFn.aggregateFunction(values).map((v) => v / keyWidth);\n    }\n  };\n  if (aggFn.groupAggregateFunction) {\n    result.groupAggregateFunction = aggFn.groupAggregateFunction;\n  }\n  return result;\n}\nfunction accumulatedValue(onlyPositive) {\n  return () => {\n    let value = 0;\n    return (datum) => {\n      if (!isFiniteNumber(datum)) {\n        return datum;\n      }\n      value += onlyPositive ? Math.max(0, datum) : datum;\n      return value;\n    };\n  };\n}\nfunction trailingAccumulatedValue() {\n  return () => {\n    let value = 0;\n    return (datum) => {\n      if (!isFiniteNumber(datum)) {\n        return datum;\n      }\n      const trailingValue = value;\n      value += datum;\n      return trailingValue;\n    };\n  };\n}\n\n// packages/ag-charts-community/src/chart/data/processors.ts\nfunction basicContinuousCheckDatumValidation(value) {\n  return value != null && isContinuous(value);\n}\nfunction basicDiscreteCheckDatumValidation(value) {\n  return value != null;\n}\nfunction getValidationFn(scaleType) {\n  switch (scaleType) {\n    case \"number\":\n    case \"log\":\n    case \"ordinal-time\":\n    case \"time\":\n    case \"color\":\n      return basicContinuousCheckDatumValidation;\n    default:\n      return basicDiscreteCheckDatumValidation;\n  }\n}\nfunction getValueType(scaleType) {\n  switch (scaleType) {\n    case \"number\":\n    case \"log\":\n    case \"time\":\n    case \"color\":\n      return \"range\";\n    default:\n      return \"category\";\n  }\n}\nfunction keyProperty(propName, scaleType, opts = {}) {\n  const result = {\n    property: propName,\n    type: \"key\",\n    valueType: getValueType(scaleType),\n    validation: getValidationFn(scaleType),\n    ...opts\n  };\n  return result;\n}\nfunction valueProperty(propName, scaleType, opts = {}) {\n  const result = {\n    property: propName,\n    type: \"value\",\n    valueType: getValueType(scaleType),\n    validation: getValidationFn(scaleType),\n    ...opts\n  };\n  return result;\n}\nfunction rangedValueProperty(propName, opts = {}) {\n  const { min = -Infinity, max = Infinity, ...defOpts } = opts;\n  return {\n    type: \"value\",\n    property: propName,\n    valueType: \"range\",\n    validation: basicContinuousCheckDatumValidation,\n    processor: () => (datum) => isFiniteNumber(datum) ? clamp(min, datum, max) : datum,\n    ...defOpts\n  };\n}\nfunction accumulativeValueProperty(propName, scaleType, opts = {}) {\n  const { onlyPositive, ...defOpts } = opts;\n  const result = {\n    ...valueProperty(propName, scaleType, defOpts),\n    processor: accumulatedValue(onlyPositive)\n  };\n  return result;\n}\nfunction trailingAccumulatedValueProperty(propName, scaleType, opts = {}) {\n  const result = {\n    ...valueProperty(propName, scaleType, opts),\n    processor: trailingAccumulatedValue()\n  };\n  return result;\n}\nfunction groupAccumulativeValueProperty(propName, mode, sum2 = \"current\", opts, scaleType) {\n  return [\n    valueProperty(propName, scaleType, opts),\n    accumulateGroup(opts.groupId, mode, sum2, opts.separateNegative),\n    ...opts.rangeId != null ? [range2(opts.rangeId, opts.groupId)] : []\n  ];\n}\nfunction groupStackValueProperty(propName, scaleType, opts) {\n  return [valueProperty(propName, scaleType, opts), accumulateStack(opts.groupId)];\n}\nvar SMALLEST_KEY_INTERVAL = {\n  type: \"reducer\",\n  property: \"smallestKeyInterval\",\n  initialValue: Infinity,\n  reducer: () => {\n    let prevX = NaN;\n    return (smallestSoFar = Infinity, next) => {\n      const nextX = next.keys[0];\n      const interval = Math.abs(nextX - prevX);\n      prevX = nextX;\n      if (!isNaN(interval) && interval > 0 && interval < smallestSoFar) {\n        return interval;\n      }\n      return smallestSoFar;\n    };\n  }\n};\nvar LARGEST_KEY_INTERVAL = {\n  type: \"reducer\",\n  property: \"largestKeyInterval\",\n  initialValue: -Infinity,\n  reducer: () => {\n    let prevX = NaN;\n    return (largestSoFar = -Infinity, next) => {\n      const nextX = next.keys[0];\n      const interval = Math.abs(nextX - prevX);\n      prevX = nextX;\n      if (!isNaN(interval) && interval > 0 && interval > largestSoFar) {\n        return interval;\n      }\n      return largestSoFar;\n    };\n  }\n};\nvar SORT_DOMAIN_GROUPS = {\n  type: \"processor\",\n  property: \"sortedGroupDomain\",\n  calculate: ({ domain: { groups } }) => groups?.slice().sort((a, b) => {\n    for (let i = 0; i < a.length; i++) {\n      const result = a[i] - b[i];\n      if (result !== 0) {\n        return result;\n      }\n    }\n    return 0;\n  })\n};\nfunction normaliseFnBuilder({ normaliseTo, mode }) {\n  const normalise = (val, extent2) => {\n    const result = val * normaliseTo / extent2;\n    if (result >= 0) {\n      return Math.min(normaliseTo, result);\n    }\n    return Math.max(-normaliseTo, result);\n  };\n  return () => () => (values, valueIndexes) => {\n    const valuesExtent = [0, 0];\n    for (const valueIdx of valueIndexes) {\n      const value = values[valueIdx];\n      const valueExtent = typeof value === \"number\" ? value : Math.max(...value);\n      const valIdx = valueExtent < 0 ? 0 : 1;\n      if (mode === \"sum\") {\n        valuesExtent[valIdx] += valueExtent;\n      } else if (valIdx === 0) {\n        valuesExtent[valIdx] = Math.min(valuesExtent[valIdx], valueExtent);\n      } else {\n        valuesExtent[valIdx] = Math.max(valuesExtent[valIdx], valueExtent);\n      }\n    }\n    const extent2 = Math.max(Math.abs(valuesExtent[0]), valuesExtent[1]);\n    for (const valueIdx of valueIndexes) {\n      const value = values[valueIdx];\n      values[valueIdx] = typeof value === \"number\" ? normalise(value, extent2) : value.map((v) => normalise(v, extent2));\n    }\n  };\n}\nfunction normaliseGroupTo(matchGroupIds, normaliseTo, mode = \"sum\") {\n  return {\n    type: \"group-value-processor\",\n    matchGroupIds,\n    adjust: memo({ normaliseTo, mode }, normaliseFnBuilder)\n  };\n}\nfunction normalisePropertyFnBuilder({\n  normaliseTo,\n  zeroDomain,\n  rangeMin,\n  rangeMax\n}) {\n  const normaliseSpan = normaliseTo[1] - normaliseTo[0];\n  const normalise = (val, start2, span) => {\n    const result = normaliseTo[0] + (val - start2) / span * normaliseSpan;\n    if (span === 0) {\n      return zeroDomain;\n    } else if (result >= normaliseTo[1]) {\n      return normaliseTo[1];\n    } else if (result < normaliseTo[0]) {\n      return normaliseTo[0];\n    }\n    return result;\n  };\n  return () => (pData, pIdx) => {\n    let [start2, end2] = pData.domain.values[pIdx];\n    if (rangeMin != null)\n      start2 = rangeMin;\n    if (rangeMax != null)\n      end2 = rangeMax;\n    const span = end2 - start2;\n    pData.domain.values[pIdx] = [normaliseTo[0], normaliseTo[1]];\n    for (const group of pData.data) {\n      let groupValues = group.values;\n      if (pData.type === \"ungrouped\") {\n        groupValues = [groupValues];\n      }\n      for (const values of groupValues) {\n        values[pIdx] = normalise(values[pIdx], start2, span);\n      }\n    }\n  };\n}\nfunction normalisePropertyTo(property, normaliseTo, zeroDomain, rangeMin, rangeMax) {\n  return {\n    type: \"property-value-processor\",\n    property,\n    adjust: memo({ normaliseTo, rangeMin, rangeMax, zeroDomain }, normalisePropertyFnBuilder)\n  };\n}\nfunction animationValidation(valueKeyIds) {\n  return {\n    type: \"processor\",\n    property: \"animationValidation\",\n    calculate(result) {\n      const { keys, values } = result.defs;\n      const { input, data } = result;\n      let uniqueKeys = true;\n      let orderedKeys = true;\n      const valueKeys = [];\n      for (let k = 0; k < values.length; k++) {\n        if (!valueKeyIds?.includes(values[k].id))\n          continue;\n        valueKeys.push([k, values[k]]);\n      }\n      const processKey = (idx, def, type) => {\n        if (def.valueType === \"category\") {\n          const keyValues = result.domain[type][idx];\n          uniqueKeys && (uniqueKeys = keyValues.length === input.count);\n          return;\n        }\n        let lastValue = data[0]?.[type][idx];\n        for (let d = 1; (uniqueKeys || orderedKeys) && d < data.length; d++) {\n          const keyValue = data[d][type][idx];\n          orderedKeys && (orderedKeys = lastValue <= keyValue);\n          uniqueKeys && (uniqueKeys = lastValue !== keyValue);\n          lastValue = keyValue;\n        }\n      };\n      for (let k = 0; (uniqueKeys || orderedKeys) && k < keys.length; k++) {\n        processKey(k, keys[k], \"keys\");\n      }\n      for (let k = 0; (uniqueKeys || orderedKeys) && k < valueKeys.length; k++) {\n        const [idx, key] = valueKeys[k];\n        processKey(idx, key, \"values\");\n      }\n      return { uniqueKeys, orderedKeys };\n    }\n  };\n}\nfunction buildGroupAccFn({ mode, separateNegative }) {\n  return () => () => (values, valueIndexes) => {\n    const acc = [0, 0];\n    for (const valueIdx of valueIndexes) {\n      const currentVal = values[valueIdx];\n      const accIndex = isNegative(currentVal) && separateNegative ? 0 : 1;\n      if (!isFiniteNumber(currentVal))\n        continue;\n      if (mode === \"normal\")\n        acc[accIndex] += currentVal;\n      values[valueIdx] = acc[accIndex];\n      if (mode === \"trailing\")\n        acc[accIndex] += currentVal;\n    }\n  };\n}\nfunction buildGroupWindowAccFn({ mode, sum: sum2 }) {\n  return () => {\n    const lastValues = [];\n    let firstRow = true;\n    return () => {\n      return (values, valueIndexes) => {\n        let acc = 0;\n        for (const valueIdx of valueIndexes) {\n          const currentVal = values[valueIdx];\n          const lastValue = firstRow && sum2 === \"current\" ? 0 : lastValues[valueIdx];\n          lastValues[valueIdx] = currentVal;\n          const sumValue = sum2 === \"current\" ? currentVal : lastValue;\n          if (!isFiniteNumber(currentVal) || !isFiniteNumber(lastValue)) {\n            values[valueIdx] = acc;\n            continue;\n          }\n          if (mode === \"normal\") {\n            acc += sumValue;\n          }\n          values[valueIdx] = acc;\n          if (mode === \"trailing\") {\n            acc += sumValue;\n          }\n        }\n        firstRow = false;\n      };\n    };\n  };\n}\nfunction accumulateGroup(matchGroupId, mode, sum2, separateNegative = false) {\n  let adjust;\n  if (mode.startsWith(\"window\")) {\n    const modeParam = mode.endsWith(\"-trailing\") ? \"trailing\" : \"normal\";\n    adjust = memo({ mode: modeParam, sum: sum2 }, buildGroupWindowAccFn);\n  } else {\n    adjust = memo({ mode, separateNegative }, buildGroupAccFn);\n  }\n  return {\n    type: \"group-value-processor\",\n    matchGroupIds: [matchGroupId],\n    adjust\n  };\n}\nfunction groupStackAccFn() {\n  return () => (values, valueIndexes) => {\n    const acc = new Float64Array(32);\n    let stackCount = 0;\n    for (const valueIdx of valueIndexes) {\n      const currentValue = values[valueIdx];\n      acc[stackCount] = Number.isFinite(currentValue) ? currentValue : NaN;\n      stackCount += 1;\n      values[valueIdx] = acc.subarray(0, stackCount);\n    }\n  };\n}\nfunction accumulateStack(matchGroupId) {\n  return {\n    type: \"group-value-processor\",\n    matchGroupIds: [matchGroupId],\n    adjust: groupStackAccFn\n  };\n}\nfunction diff(previousData, updateMovedData = true) {\n  return {\n    type: \"processor\",\n    property: \"diff\",\n    calculate: (processedData) => {\n      const moved = /* @__PURE__ */ new Map();\n      const added = /* @__PURE__ */ new Map();\n      const updated = /* @__PURE__ */ new Map();\n      const removed = /* @__PURE__ */ new Map();\n      const length2 = Math.max(previousData.data.length, processedData.data.length);\n      for (let i = 0; i < length2; i++) {\n        const prev = previousData.data[i];\n        const datum = processedData.data[i];\n        const prevId = prev ? createDatumId(prev.keys) : \"\";\n        const datumId = datum ? createDatumId(datum.keys) : \"\";\n        if (datum && prev && prevId === datumId) {\n          if (!arraysEqual(prev.values, datum.values)) {\n            updated.set(datumId, datum);\n          }\n          continue;\n        }\n        if (removed.has(datumId)) {\n          if (updateMovedData || !arraysEqual(removed.get(datumId).values, datum.values)) {\n            updated.set(datumId, datum);\n            moved.set(datumId, datum);\n          }\n          removed.delete(datumId);\n        } else if (datum) {\n          added.set(datumId, datum);\n        }\n        if (added.has(prevId)) {\n          if (updateMovedData || !arraysEqual(added.get(prevId).values, prev.values)) {\n            updated.set(prevId, prev);\n            moved.set(prevId, prev);\n          }\n          added.delete(prevId);\n        } else if (prev) {\n          updated.delete(prevId);\n          removed.set(prevId, prev);\n        }\n      }\n      const changed = added.size > 0 || updated.size > 0 || removed.size > 0;\n      return { changed, added, updated, removed, moved };\n    }\n  };\n}\nfunction createDatumId(keys, ...extraKeys) {\n  let result;\n  if (isArray(keys)) {\n    result = keys.map((key) => transformIntegratedCategoryValue(key)).join(\"___\");\n  } else {\n    result = transformIntegratedCategoryValue(keys);\n  }\n  const primitiveType = typeof result === \"string\" || typeof result === \"number\" || typeof result === \"boolean\" || result instanceof Date;\n  if (primitiveType && extraKeys.length > 0) {\n    result += `___${extraKeys.join(\"___\")}`;\n  }\n  return result;\n}\n\n// packages/ag-charts-community/src/chart/series/seriesLabelUtil.ts\nfunction seriesLabelFadeInAnimation({ id }, subId, animationManager, ...labelSelections) {\n  staticFromToMotion(\n    id,\n    subId,\n    animationManager,\n    labelSelections,\n    { opacity: 0 },\n    { opacity: 1 },\n    { phase: \"trailing\" }\n  );\n}\nfunction seriesLabelFadeOutAnimation({ id }, subId, animationManager, ...labelSelections) {\n  staticFromToMotion(\n    id,\n    subId,\n    animationManager,\n    labelSelections,\n    { opacity: 1 },\n    { opacity: 0 },\n    { phase: \"remove\" }\n  );\n}\nfunction resetLabelFn(_node) {\n  return { opacity: 1 };\n}\n\n// packages/ag-charts-community/src/scene/util/changeDetectableProperties.ts\nvar ChangeDetectableProperties = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this._dirty = 3 /* MAJOR */;\n  }\n  markDirty(type = 1 /* TRIVIAL */) {\n    if (this._dirty < type) {\n      this._dirty = type;\n    }\n  }\n  markClean(_opts) {\n    this._dirty = 0 /* NONE */;\n  }\n  isDirty() {\n    return this._dirty > 0 /* NONE */;\n  }\n};\n\n// packages/ag-charts-community/src/scene/dropShadow.ts\nvar DropShadow = class extends ChangeDetectableProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n    this.color = \"rgba(0, 0, 0, 0.5)\";\n    this.xOffset = 0;\n    this.yOffset = 0;\n    this.blur = 5;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], DropShadow.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(COLOR_STRING),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], DropShadow.prototype, \"color\", 2);\n__decorateClass([\n  Validate(NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], DropShadow.prototype, \"xOffset\", 2);\n__decorateClass([\n  Validate(NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], DropShadow.prototype, \"yOffset\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], DropShadow.prototype, \"blur\", 2);\n\n// packages/ag-charts-community/src/chart/series/seriesMarker.ts\nvar MARKER_SHAPE = predicateWithMessage(\n  (value) => isMarkerShape(value) || typeof value === \"function\" && Object.create(value.prototype) instanceof Marker,\n  `a marker shape keyword such as 'circle', 'diamond' or 'square' or an object extending the Marker class`\n);\nvar SeriesMarker = class extends ChangeDetectableProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n    this.shape = Circle;\n    this.size = 6;\n    this.fillOpacity = 1;\n    this.strokeWidth = 1;\n    this.strokeOpacity = 1;\n  }\n  getStyle() {\n    const { size, shape, fill, fillOpacity, stroke, strokeWidth, strokeOpacity } = this;\n    return { size, shape, fill, fillOpacity, stroke, strokeWidth, strokeOpacity };\n  }\n  getDiameter() {\n    return this.size + this.strokeWidth;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(MARKER_SHAPE),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"shape\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"size\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true }),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true }),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true }),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"itemStyler\", 2);\n\n// packages/ag-charts-community/src/chart/series/seriesTooltip.ts\nvar SeriesTooltipInteraction = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = false;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], SeriesTooltipInteraction.prototype, \"enabled\", 2);\nvar SeriesTooltip = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n    this.interaction = new SeriesTooltipInteraction();\n    this.position = new TooltipPosition();\n    this.range = void 0;\n  }\n  toTooltipHtml(defaults, params) {\n    if (this.renderer) {\n      return toTooltipHtml(this.renderer(params), defaults);\n    }\n    return toTooltipHtml(defaults);\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], SeriesTooltip.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], SeriesTooltip.prototype, \"showArrow\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], SeriesTooltip.prototype, \"renderer\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], SeriesTooltip.prototype, \"interaction\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], SeriesTooltip.prototype, \"position\", 2);\n__decorateClass([\n  Validate(INTERACTION_RANGE, { optional: true })\n], SeriesTooltip.prototype, \"range\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/interpolationProperties.ts\nvar INTERPOLATION_TYPE = UNION([\"linear\", \"smooth\", \"step\"], \"a line style\");\nvar INTERPOLATION_STEP_POSITION = UNION([\"start\", \"middle\", \"end\"]);\nvar InterpolationProperties = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.type = \"linear\";\n    this.tension = 1;\n    this.position = \"end\";\n  }\n};\n__decorateClass([\n  Validate(INTERPOLATION_TYPE)\n], InterpolationProperties.prototype, \"type\", 2);\n__decorateClass([\n  Validate(RATIO)\n], InterpolationProperties.prototype, \"tension\", 2);\n__decorateClass([\n  Validate(INTERPOLATION_STEP_POSITION)\n], InterpolationProperties.prototype, \"position\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/areaSeriesProperties.ts\nvar AreaSeriesProperties = class extends CartesianSeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.xName = void 0;\n    this.fill = \"#c16068\";\n    this.fillOpacity = 1;\n    this.stroke = \"#874349\";\n    this.strokeWidth = 2;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.interpolation = new InterpolationProperties();\n    this.shadow = new DropShadow();\n    this.marker = new SeriesMarker();\n    this.label = new Label();\n    this.tooltip = new SeriesTooltip();\n    this.connectMissingData = false;\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], AreaSeriesProperties.prototype, \"xKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], AreaSeriesProperties.prototype, \"xName\", 2);\n__decorateClass([\n  Validate(STRING)\n], AreaSeriesProperties.prototype, \"yKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], AreaSeriesProperties.prototype, \"yName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], AreaSeriesProperties.prototype, \"yFilterKey\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], AreaSeriesProperties.prototype, \"normalizedTo\", 2);\n__decorateClass([\n  Validate(COLOR_STRING)\n], AreaSeriesProperties.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO)\n], AreaSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(COLOR_STRING)\n], AreaSeriesProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AreaSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO)\n], AreaSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH)\n], AreaSeriesProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AreaSeriesProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], AreaSeriesProperties.prototype, \"interpolation\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], AreaSeriesProperties.prototype, \"shadow\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], AreaSeriesProperties.prototype, \"marker\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], AreaSeriesProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], AreaSeriesProperties.prototype, \"tooltip\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], AreaSeriesProperties.prototype, \"connectMissingData\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/lineInterpolation.ts\nfunction spanRange(span) {\n  switch (span.type) {\n    case \"linear\":\n    case \"step\":\n      return [\n        { x: span.x0, y: span.y0 },\n        { x: span.x1, y: span.y1 }\n      ];\n    case \"cubic\":\n      return [\n        { x: span.cp0x, y: span.cp0y },\n        { x: span.cp3x, y: span.cp3y }\n      ];\n  }\n}\nfunction spanRangeNormalized(span) {\n  const range3 = spanRange(span);\n  if (range3[0].x > range3[1].x) {\n    range3.reverse();\n  }\n  return range3;\n}\nfunction rescaleSpan(span, nextStart, nextEnd) {\n  const [prevStart, prevEnd] = spanRange(span);\n  const widthScale = prevEnd.x !== prevStart.x ? (nextEnd.x - nextStart.x) / (prevEnd.x - prevStart.x) : 0;\n  const heightScale = prevEnd.y !== prevStart.y ? (nextEnd.y - nextStart.y) / (prevEnd.y - prevStart.y) : 0;\n  switch (span.type) {\n    case \"linear\":\n      return {\n        type: \"linear\",\n        moveTo: span.moveTo,\n        x0: nextStart.x,\n        y0: nextStart.y,\n        x1: nextEnd.x,\n        y1: nextEnd.y\n      };\n    case \"cubic\":\n      return {\n        type: \"cubic\",\n        moveTo: span.moveTo,\n        cp0x: nextStart.x,\n        cp0y: nextStart.y,\n        cp1x: nextEnd.x - (span.cp2x - prevStart.x) * widthScale,\n        cp1y: nextEnd.y - (span.cp2y - prevStart.y) * heightScale,\n        cp2x: nextEnd.x - (span.cp1x - prevStart.x) * widthScale,\n        cp2y: nextEnd.y - (span.cp1y - prevStart.y) * heightScale,\n        cp3x: nextEnd.x,\n        cp3y: nextEnd.y\n      };\n    case \"step\":\n      return {\n        type: \"step\",\n        moveTo: span.moveTo,\n        x0: nextStart.x,\n        y0: nextStart.y,\n        x1: nextEnd.x,\n        y1: nextEnd.y,\n        stepX: nextEnd.x - (span.stepX - prevStart.x) * widthScale\n      };\n  }\n}\nfunction clipSpanX(span, x0, x1) {\n  const { moveTo } = span;\n  const [start2, end2] = spanRangeNormalized(span);\n  const { x: spanX0, y: spanY0 } = start2;\n  const { x: spanX1, y: spanY1 } = end2;\n  if (x1 < spanX0) {\n    return rescaleSpan(span, start2, start2);\n  } else if (x0 > spanX1) {\n    return rescaleSpan(span, end2, end2);\n  }\n  switch (span.type) {\n    case \"linear\": {\n      const m = spanY0 === spanY1 ? void 0 : (spanY1 - spanY0) / (spanX1 - spanX0);\n      const y0 = m == null ? spanY0 : m * (x0 - spanX0) + spanY0;\n      const y1 = m == null ? spanY0 : m * (x1 - spanX0) + spanY0;\n      return { type: \"linear\", moveTo, x0, y0, x1, y1 };\n    }\n    case \"step\":\n      if (x1 <= span.stepX) {\n        const y = span.y0;\n        return { type: \"step\", moveTo, x0, y0: y, x1, y1: y, stepX: x1 };\n      } else if (x0 >= span.stepX) {\n        const y = span.y1;\n        return { type: \"step\", moveTo, x0, y0: y, x1, y1: y, stepX: x0 };\n      } else {\n        const { y0, y1, stepX } = span;\n        return { type: \"step\", moveTo, x0, y0, x1, y1, stepX };\n      }\n    case \"cubic\": {\n      const t0 = solveBezier(span.cp0x, span.cp1x, span.cp2x, span.cp3x, x0);\n      let [_unused, bezier] = splitBezier(\n        span.cp0x,\n        span.cp0y,\n        span.cp1x,\n        span.cp1y,\n        span.cp2x,\n        span.cp2y,\n        span.cp3x,\n        span.cp3y,\n        t0\n      );\n      const t1 = solveBezier(bezier[0].x, bezier[1].x, bezier[2].x, bezier[3].x, x1);\n      [bezier, _unused] = splitBezier(\n        bezier[0].x,\n        bezier[0].y,\n        bezier[1].x,\n        bezier[1].y,\n        bezier[2].x,\n        bezier[2].y,\n        bezier[3].x,\n        bezier[3].y,\n        t1\n      );\n      return {\n        type: \"cubic\",\n        moveTo,\n        cp0x: bezier[0].x,\n        cp0y: bezier[0].y,\n        cp1x: bezier[1].x,\n        cp1y: bezier[1].y,\n        cp2x: bezier[2].x,\n        cp2y: bezier[2].y,\n        cp3x: bezier[3].x,\n        cp3y: bezier[3].y\n      };\n    }\n  }\n}\nfunction linearPoints(points) {\n  const spans = [];\n  let i = 0;\n  let x0 = NaN;\n  let y0 = NaN;\n  for (const { x: x1, y: y1 } of points) {\n    if (i > 0) {\n      const moveTo = i === 1;\n      spans.push({ type: \"linear\", moveTo, x0, y0, x1, y1 });\n    }\n    i += 1;\n    x0 = x1;\n    y0 = y1;\n  }\n  return spans;\n}\nvar lineSteps = {\n  start: 0,\n  middle: 0.5,\n  end: 1\n};\nfunction stepPoints(points, position) {\n  const spans = [];\n  let i = 0;\n  let x0 = NaN;\n  let y0 = NaN;\n  const p0 = typeof position === \"number\" ? position : lineSteps[position];\n  for (const { x: x1, y: y1 } of points) {\n    if (i > 0) {\n      const moveTo = i === 1;\n      const stepX = x0 + (x1 - x0) * p0;\n      spans.push({ type: \"step\", moveTo, x0, y0, x1, y1, stepX });\n    }\n    i += 1;\n    x0 = x1;\n    y0 = y1;\n  }\n  return spans;\n}\nvar flatnessRatio = 0.05;\nfunction smoothPoints(iPoints, tension) {\n  const points = Array.isArray(iPoints) ? iPoints : Array.from(iPoints);\n  if (points.length <= 1)\n    return [];\n  const gradients = points.map((c, i) => {\n    const p = i === 0 ? c : points[i - 1];\n    const n = i === points.length - 1 ? c : points[i + 1];\n    const isTerminalPoint = i === 0 || i === points.length - 1;\n    if (Math.sign(p.y - c.y) === Math.sign(n.y - c.y)) {\n      return 0;\n    }\n    if (!isTerminalPoint) {\n      const range3 = Math.abs(p.y - n.y);\n      const prevRatio = Math.abs(c.y - p.y) / range3;\n      const nextRatio = Math.abs(c.y - n.y) / range3;\n      if (prevRatio <= flatnessRatio || 1 - prevRatio <= flatnessRatio || nextRatio <= flatnessRatio || 1 - nextRatio <= flatnessRatio) {\n        return 0;\n      }\n    }\n    return (n.y - p.y) / (n.x - p.x);\n  });\n  if (gradients[1] === 0) {\n    gradients[0] *= 2;\n  }\n  if (gradients[gradients.length - 2] === 0) {\n    gradients[gradients.length - 1] *= 2;\n  }\n  const spans = [];\n  for (let i = 1; i < points.length; i += 1) {\n    const prev = points[i - 1];\n    const prevM = gradients[i - 1];\n    const cur = points[i];\n    const curM = gradients[i];\n    const dx = cur.x - prev.x;\n    const dy = cur.y - prev.y;\n    let dcp1x = dx * tension / 3;\n    let dcp1y = dx * prevM * tension / 3;\n    let dcp2x = dx * tension / 3;\n    let dcp2y = dx * curM * tension / 3;\n    if (curM === 0 && Math.abs(dcp1y) > Math.abs(dy)) {\n      dcp1x *= Math.abs(dy / dcp1y);\n      dcp1y = Math.sign(dcp1y) * Math.abs(dy);\n    }\n    if (prevM === 0 && Math.abs(dcp2y) > Math.abs(dy)) {\n      dcp2x *= Math.abs(dy / dcp2y);\n      dcp2y = Math.sign(dcp2y) * Math.abs(dy);\n    }\n    spans.push({\n      type: \"cubic\",\n      moveTo: i === 1,\n      cp0x: prev.x,\n      cp0y: prev.y,\n      cp1x: prev.x + dcp1x,\n      cp1y: prev.y + dcp1y,\n      cp2x: cur.x - dcp2x,\n      cp2y: cur.y - dcp2y,\n      cp3x: cur.x,\n      cp3y: cur.y\n    });\n  }\n  return spans;\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/lineInterpolationPlotting.ts\nfunction lerp2(a, b, ratio2) {\n  return (b - a) * ratio2 + a;\n}\nfunction linearSupertype(span, stepX) {\n  const { x0, y0, x1, y1 } = span;\n  const m = (y1 - y0) / (x1 - x0);\n  const stepY = m * (stepX - x0) + y0;\n  return {\n    leftCp1x: x0,\n    leftCp1y: y0,\n    leftCp2x: stepX,\n    leftCp2y: stepY,\n    stepX,\n    stepY0: stepY,\n    stepY1: stepY,\n    rightCp1x: stepX,\n    rightCp1y: stepY,\n    rightCp2x: x1,\n    rightCp2y: y1\n  };\n}\nfunction bezierSupertype(span, stepX) {\n  const { cp0x, cp0y, cp1x, cp1y, cp2x, cp2y, cp3x, cp3y } = span;\n  const t = solveBezier(cp0x, cp1x, cp2x, cp3x, stepX);\n  const [left, right] = splitBezier(cp0x, cp0y, cp1x, cp1y, cp2x, cp2y, cp3x, cp3y, t);\n  const stepY = left[3].y;\n  return {\n    leftCp1x: left[1].x,\n    leftCp1y: left[1].y,\n    leftCp2x: left[2].x,\n    leftCp2y: left[2].y,\n    stepX,\n    stepY0: stepY,\n    stepY1: stepY,\n    rightCp1x: right[1].x,\n    rightCp1y: right[1].y,\n    rightCp2x: right[2].x,\n    rightCp2y: right[2].y\n  };\n}\nfunction stepSupertype(span) {\n  const { x0, y0, x1, y1, stepX } = span;\n  return {\n    leftCp1x: (x0 + stepX) / 2,\n    leftCp1y: y0,\n    leftCp2x: (x0 + stepX) / 2,\n    leftCp2y: y0,\n    stepX,\n    stepY0: y0,\n    stepY1: y1,\n    rightCp1x: (stepX + x1) / 2,\n    rightCp1y: y1,\n    rightCp2x: (stepX + x1) / 2,\n    rightCp2y: y1\n  };\n}\nfunction spanSupertype(span, stepX) {\n  if (span.type === \"linear\") {\n    return linearSupertype(span, stepX);\n  } else if (span.type === \"cubic\") {\n    return bezierSupertype(span, stepX);\n  } else {\n    return stepSupertype(span);\n  }\n}\nfunction plotStart(path, moveTo, x0, y0, x1, y1, reversed) {\n  switch (moveTo) {\n    case 1 /* MoveTo */:\n      if (reversed) {\n        path.moveTo(x1, y1);\n      } else {\n        path.moveTo(x0, y0);\n      }\n      break;\n    case 2 /* LineTo */:\n      if (reversed) {\n        path.lineTo(x1, y1);\n      } else {\n        path.lineTo(x0, y0);\n      }\n      break;\n  }\n}\nfunction plotLinear(path, x0, y0, x1, y1, reversed) {\n  if (reversed) {\n    path.lineTo(x0, y0);\n  } else {\n    path.lineTo(x1, y1);\n  }\n}\nfunction plotCubic(path, cp0x, cp0y, cp1x, cp1y, cp2x, cp2y, cp3x, cp3y, reversed) {\n  if (reversed) {\n    path.cubicCurveTo(cp2x, cp2y, cp1x, cp1y, cp0x, cp0y);\n  } else {\n    path.cubicCurveTo(cp1x, cp1y, cp2x, cp2y, cp3x, cp3y);\n  }\n}\nfunction plotStep(path, x0, y0, x1, y1, stepX, reversed) {\n  if (reversed) {\n    path.lineTo(stepX, y1);\n    path.lineTo(stepX, y0);\n    path.lineTo(x0, y0);\n  } else {\n    path.lineTo(stepX, y0);\n    path.lineTo(stepX, y1);\n    path.lineTo(x1, y1);\n  }\n}\nfunction plotSpan(path, span, moveTo, reversed) {\n  const [start2, end2] = spanRange(span);\n  plotStart(path, moveTo, start2.x, start2.y, end2.x, end2.y, reversed);\n  switch (span.type) {\n    case \"linear\":\n      plotLinear(path, span.x0, span.y0, span.x1, span.y1, reversed);\n      break;\n    case \"cubic\":\n      plotCubic(\n        path,\n        span.cp0x,\n        span.cp0y,\n        span.cp1x,\n        span.cp1y,\n        span.cp2x,\n        span.cp2y,\n        span.cp3x,\n        span.cp3y,\n        reversed\n      );\n      break;\n    case \"step\":\n      plotStep(path, span.x0, span.y0, span.x1, span.y1, span.stepX, reversed);\n      break;\n  }\n}\nfunction plotInterpolatedSpans(path, a, b, ratio2, moveTo, reversed) {\n  const [aStart, aEnd] = spanRange(a);\n  const [bStart, bEnd] = spanRange(b);\n  const x0 = lerp2(aStart.x, bStart.x, ratio2);\n  const y0 = lerp2(aStart.y, bStart.y, ratio2);\n  const x1 = lerp2(aEnd.x, bEnd.x, ratio2);\n  const y1 = lerp2(aEnd.y, bEnd.y, ratio2);\n  plotStart(path, moveTo, x0, y0, x1, y1, reversed);\n  if (a.type === \"cubic\" && b.type === \"cubic\") {\n    const cp1x = lerp2(a.cp1x, b.cp1x, ratio2);\n    const cp1y = lerp2(a.cp1y, b.cp1y, ratio2);\n    const cp2x = lerp2(a.cp2x, b.cp2x, ratio2);\n    const cp2y = lerp2(a.cp2y, b.cp2y, ratio2);\n    plotCubic(path, x0, y0, cp1x, cp1y, cp2x, cp2y, x1, y1, reversed);\n  } else if (a.type === \"step\" && b.type === \"step\") {\n    const stepX = lerp2(a.stepX, b.stepX, ratio2);\n    plotStep(path, x0, y0, x1, y1, stepX, reversed);\n  } else if (a.type === \"linear\" && b.type === \"linear\") {\n    plotLinear(path, x0, y0, x1, y1, reversed);\n  } else {\n    let defaultStepX;\n    if (a.type === \"step\") {\n      defaultStepX = a.stepX;\n    } else if (b.type === \"step\") {\n      defaultStepX = b.stepX;\n    } else {\n      defaultStepX = (x0 + x1) / 2;\n    }\n    const as = spanSupertype(a, defaultStepX);\n    const bs = spanSupertype(b, defaultStepX);\n    const leftCp1x = lerp2(as.leftCp1x, bs.leftCp1x, ratio2);\n    const leftCp1y = lerp2(as.leftCp1y, bs.leftCp1y, ratio2);\n    const leftCp2x = lerp2(as.leftCp2x, bs.leftCp2x, ratio2);\n    const leftCp2y = lerp2(as.leftCp2y, bs.leftCp2y, ratio2);\n    const stepX = lerp2(as.stepX, bs.stepX, ratio2);\n    const stepY0 = lerp2(as.stepY0, bs.stepY0, ratio2);\n    const stepY1 = lerp2(as.stepY1, bs.stepY1, ratio2);\n    const rightCp1x = lerp2(as.rightCp1x, bs.rightCp1x, ratio2);\n    const rightCp1y = lerp2(as.rightCp1y, bs.rightCp1y, ratio2);\n    const rightCp2x = lerp2(as.rightCp2x, bs.rightCp2x, ratio2);\n    const rightCp2y = lerp2(as.rightCp2y, bs.rightCp2y, ratio2);\n    if (reversed) {\n      path.cubicCurveTo(rightCp2x, rightCp2y, rightCp1x, rightCp1y, stepX, stepY1);\n      path.lineTo(stepX, stepY0);\n      path.cubicCurveTo(leftCp2x, leftCp2y, leftCp1x, leftCp1y, x0, y0);\n    } else {\n      path.cubicCurveTo(leftCp1x, leftCp1y, leftCp2x, leftCp2y, stepX, stepY0);\n      path.lineTo(stepX, stepY1);\n      path.cubicCurveTo(rightCp1x, rightCp1y, rightCp2x, rightCp2y, x1, y1);\n    }\n  }\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/markerUtil.ts\nfunction markerFadeInAnimation({ id }, animationManager, status, ...markerSelections) {\n  const params = { phase: status ? NODE_UPDATE_STATE_TO_PHASE_MAPPING[status] : \"trailing\" };\n  staticFromToMotion(id, \"markers\", animationManager, markerSelections, { opacity: 0 }, { opacity: 1 }, params);\n  markerSelections.forEach((s) => s.cleanup());\n}\nfunction markerScaleInAnimation({ id }, animationManager, ...markerSelections) {\n  staticFromToMotion(\n    id,\n    \"markers\",\n    animationManager,\n    markerSelections,\n    { scalingX: 0, scalingY: 0 },\n    { scalingX: 1, scalingY: 1 },\n    { phase: \"initial\" }\n  );\n  markerSelections.forEach((s) => s.cleanup());\n}\nfunction markerSwipeScaleInAnimation({ id, nodeDataDependencies }, animationManager, ...markerSelections) {\n  const seriesWidth = nodeDataDependencies.seriesRectWidth;\n  const fromFn = (_, datum) => {\n    const x = datum.midPoint?.x ?? seriesWidth;\n    let delay = clamp(0, inverseEaseOut(x / seriesWidth), 1);\n    if (isNaN(delay)) {\n      delay = 0;\n    }\n    return { scalingX: 0, scalingY: 0, delay, duration: QUICK_TRANSITION, phase: \"initial\" };\n  };\n  const toFn = () => {\n    return { scalingX: 1, scalingY: 1 };\n  };\n  fromToMotion(id, \"markers\", animationManager, markerSelections, { fromFn, toFn });\n}\nfunction resetMarkerFn(_node) {\n  return { opacity: 1, scalingX: 1, scalingY: 1 };\n}\nfunction resetMarkerPositionFn(_node, datum) {\n  return {\n    translationX: datum.point?.x ?? NaN,\n    translationY: datum.point?.y ?? NaN\n  };\n}\nfunction prepareMarkerAnimation(pairMap, parentStatus) {\n  const readFirstPair = (xValue, type) => {\n    const val = pairMap[type][xValue];\n    return Array.isArray(val) ? val[0] : val;\n  };\n  const markerStatus = (datum) => {\n    const { xValue } = datum;\n    if (pairMap.moved[xValue]) {\n      return { point: readFirstPair(xValue, \"moved\"), status: \"updated\" };\n    } else if (pairMap.removed[xValue]) {\n      return { point: readFirstPair(xValue, \"removed\"), status: \"removed\" };\n    } else if (pairMap.added[xValue]) {\n      return { point: readFirstPair(xValue, \"added\"), status: \"added\" };\n    }\n    return { status: \"unknown\" };\n  };\n  const fromFn = (marker, datum) => {\n    const { status, point } = markerStatus(datum);\n    if (status === \"unknown\")\n      return { opacity: 0 };\n    const defaults = {\n      translationX: point?.from?.x ?? marker.translationX,\n      translationY: point?.from?.y ?? marker.translationY,\n      opacity: marker.opacity,\n      phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[status]\n    };\n    if (parentStatus === \"added\") {\n      return {\n        ...defaults,\n        opacity: 0,\n        translationX: point?.to?.x,\n        translationY: point?.to?.y,\n        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[\"added\"]\n      };\n    }\n    if (status === \"added\") {\n      defaults.opacity = 0;\n    }\n    return defaults;\n  };\n  const toFn = (_marker, datum) => {\n    const { status, point } = markerStatus(datum);\n    if (status === \"unknown\")\n      return { opacity: 0 };\n    const defaults = {\n      translationX: datum.point.x,\n      translationY: datum.point.y,\n      opacity: 1,\n      phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[status]\n    };\n    if (status === \"removed\" || parentStatus === \"removed\") {\n      return {\n        ...defaults,\n        translationX: point?.to?.x,\n        translationY: point?.to?.y,\n        opacity: 0,\n        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[\"removed\"]\n      };\n    }\n    return defaults;\n  };\n  return { fromFn, toFn };\n}\nfunction computeMarkerFocusBounds(series, { datumIndex }) {\n  const nodeData = series.getNodeData();\n  if (nodeData === void 0)\n    return void 0;\n  const datum = nodeData[datumIndex];\n  const { point } = datum;\n  if (datum == null || point == null)\n    return void 0;\n  const size = point.focusSize ?? series.getFormattedMarkerStyle(datum).size;\n  const radius = size / 2;\n  const x = datum.point.x - radius;\n  const y = datum.point.y - radius;\n  return Transformable.toCanvas(series.contentGroup, new BBox(x, y, size, size));\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/linePlotter.ts\nfunction plotLinearPoints(path, points, continuePath) {\n  let didMove = continuePath;\n  for (const { x, y } of points) {\n    if (didMove) {\n      path.lineTo(x, y);\n    } else {\n      path.moveTo(x, y);\n      didMove = true;\n    }\n  }\n}\nvar flatnessRatio2 = 0.05;\nfunction plotSmoothPoints(path, iPoints, tension, continuePath) {\n  const points = Array.isArray(iPoints) ? iPoints : Array.from(iPoints);\n  if (points.length === 0)\n    return;\n  if (continuePath) {\n    path.lineTo(points[0].x, points[0].y);\n  } else {\n    path.moveTo(points[0].x, points[0].y);\n  }\n  if (points.length <= 1)\n    return;\n  const gradients = points.map((c, i) => {\n    const p = i === 0 ? c : points[i - 1];\n    const n = i === points.length - 1 ? c : points[i + 1];\n    const isTerminalPoint = i === 0 || i === points.length - 1;\n    if (Math.sign(p.y - c.y) === Math.sign(n.y - c.y)) {\n      return 0;\n    }\n    if (!isTerminalPoint) {\n      const range3 = Math.abs(p.y - n.y);\n      const prevRatio = Math.abs(c.y - p.y) / range3;\n      const nextRatio = Math.abs(c.y - n.y) / range3;\n      if (prevRatio <= flatnessRatio2 || 1 - prevRatio <= flatnessRatio2 || nextRatio <= flatnessRatio2 || 1 - nextRatio <= flatnessRatio2) {\n        return 0;\n      }\n    }\n    return (n.y - p.y) / (n.x - p.x);\n  });\n  if (gradients[1] === 0) {\n    gradients[0] *= 2;\n  }\n  if (gradients[gradients.length - 2] === 0) {\n    gradients[gradients.length - 1] *= 2;\n  }\n  for (let i = 1; i < points.length; i += 1) {\n    const prev = points[i - 1];\n    const prevM = gradients[i - 1];\n    const cur = points[i];\n    const curM = gradients[i];\n    const dx = cur.x - prev.x;\n    const dy = cur.y - prev.y;\n    let dcp1x = dx * tension / 3;\n    let dcp1y = dx * prevM * tension / 3;\n    let dcp2x = dx * tension / 3;\n    let dcp2y = dx * curM * tension / 3;\n    if (curM === 0 && Math.abs(dcp1y) > Math.abs(dy)) {\n      dcp1x *= Math.abs(dy / dcp1y);\n      dcp1y = Math.sign(dcp1y) * Math.abs(dy);\n    }\n    if (prevM === 0 && Math.abs(dcp2y) > Math.abs(dy)) {\n      dcp2x *= Math.abs(dy / dcp2y);\n      dcp2y = Math.sign(dcp2y) * Math.abs(dy);\n    }\n    path.cubicCurveTo(prev.x + dcp1x, prev.y + dcp1y, cur.x - dcp2x, cur.y - dcp2y, cur.x, cur.y);\n  }\n}\nfunction plotStepPoints(path, points, align, continuePath) {\n  let lastPoint;\n  for (const point of points) {\n    if (lastPoint != null) {\n      const directionalAlign = lastPoint.x < point.x ? align : 1 - align;\n      const x = (point.x - lastPoint.x) * directionalAlign + lastPoint.x;\n      path.lineTo(x, lastPoint?.y ?? point.y);\n      path.lineTo(x, point.y);\n      path.lineTo(point.x, point.y);\n    } else if (continuePath) {\n      path.lineTo(point.x, point.y);\n    } else {\n      path.moveTo(point.x, point.y);\n    }\n    lastPoint = point;\n  }\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/pathUtil.ts\nfunction minMax(nodeData) {\n  return nodeData.reduce(\n    ({ min, max }, node) => {\n      if (min == null || min.point.x > node.point.x) {\n        min = node;\n      }\n      if (max == null || max.point.x < node.point.x) {\n        max = node;\n      }\n      return { min, max };\n    },\n    {}\n  );\n}\nfunction intersectionOnLine(a, b, targetX) {\n  const m = (b.y - a.y) / (b.x - a.x);\n  const y = (targetX - a.x) * m + a.y;\n  return { x: targetX, y };\n}\nfunction backfillPathPoint(results, process, skip, processFn) {\n  let prevMarkerIdx = -1, nextMarkerIdx = 0;\n  const toProcess = [];\n  while (nextMarkerIdx < results.length) {\n    if (results[nextMarkerIdx].change === process) {\n      toProcess.push(results[nextMarkerIdx]);\n      nextMarkerIdx++;\n      continue;\n    }\n    if (results[nextMarkerIdx].change === skip) {\n      nextMarkerIdx++;\n      continue;\n    }\n    if (toProcess.length > 0) {\n      processFn(toProcess, prevMarkerIdx, nextMarkerIdx);\n      toProcess.length = 0;\n    }\n    prevMarkerIdx = nextMarkerIdx;\n    nextMarkerIdx++;\n  }\n  if (toProcess.length > 0) {\n    processFn(toProcess, prevMarkerIdx, nextMarkerIdx);\n  }\n}\nfunction backfillPathPointData(result, splitMode) {\n  backfillPathPoint(result, \"out\", \"in\", (toProcess, sIdx, eIdx) => {\n    if (sIdx === -1 && result[eIdx]) {\n      toProcess.forEach((d) => d.to = result[eIdx].from);\n    } else if (eIdx === result.length && result[sIdx]) {\n      toProcess.forEach((d) => d.to = result[sIdx].from);\n    } else if (splitMode === \"intersect\" && result[sIdx]?.from && result[eIdx]?.from) {\n      toProcess.forEach((d) => d.to = intersectionOnLine(result[sIdx].from, result[eIdx].from, d.from.x));\n    } else {\n      toProcess.forEach((d) => d.to = d.from);\n    }\n  });\n  backfillPathPoint(result, \"in\", \"out\", (toProcess, sIdx, eIdx) => {\n    if (sIdx === -1 && result[eIdx]) {\n      toProcess.forEach((d) => d.from = result[eIdx].to);\n    } else if (eIdx === result.length && result[sIdx]) {\n      toProcess.forEach((d) => d.from = result[sIdx].to);\n    } else if (splitMode === \"intersect\" && result[sIdx]?.to && result[eIdx]?.to) {\n      toProcess.forEach((d) => d.from = intersectionOnLine(result[sIdx].to, result[eIdx].to, d.to.x));\n    } else {\n      toProcess.forEach((d) => d.from = d.to);\n    }\n  });\n}\nfunction calculatePoint(from3, to, ratio2) {\n  const x1 = isNaN(from3.x) ? to.x : from3.x;\n  const y1 = isNaN(from3.y) ? to.y : from3.y;\n  const xd = to.x - from3.x;\n  const yd = to.y - from3.y;\n  const xr = isNaN(xd) ? 0 : xd * ratio2;\n  const yr = isNaN(yd) ? 0 : yd * ratio2;\n  return {\n    x: x1 + xr,\n    y: y1 + yr\n  };\n}\nvar lineSteps2 = {\n  start: 0,\n  middle: 0.5,\n  end: 1\n};\nfunction plotPath(points, path, interpolation, continuePath = false) {\n  const { path: linePath } = path;\n  if (interpolation?.type === \"smooth\") {\n    plotSmoothPoints(linePath, points, interpolation.tension ?? 1, continuePath);\n  } else if (interpolation?.type === \"step\") {\n    plotStepPoints(linePath, points, lineSteps2[interpolation.position ?? \"end\"], continuePath);\n  } else {\n    plotLinearPoints(linePath, points, continuePath);\n  }\n}\nfunction splitPairData(pairData, ratios) {\n  let previousTo;\n  let points = void 0;\n  const out = [];\n  const flushCurrent = () => {\n    if (points != null) {\n      out.push(points);\n      points = void 0;\n    }\n  };\n  for (const data of pairData) {\n    const { from: from3, to } = data;\n    const ratio2 = ratios[data.change];\n    if (ratio2 == null || from3 == null || to == null)\n      continue;\n    const point = calculatePoint(from3, to, ratio2);\n    if (data.moveTo === false) {\n      points ?? (points = []);\n      points.push(point);\n    } else if (data.moveTo === true || !previousTo) {\n      flushCurrent();\n      points = [point];\n    } else if (previousTo) {\n      const moveToRatio = data.moveTo === \"in\" ? ratio2 : 1 - ratio2;\n      const { x: midPointX, y: midPointY } = calculatePoint(previousTo, point, moveToRatio);\n      points ?? (points = []);\n      points.push({ x: midPointX, y: midPointY });\n      flushCurrent();\n      points = [point];\n    }\n    previousTo = point;\n  }\n  flushCurrent();\n  return out;\n}\nfunction renderPartialPath(pairData, ratios, path, interpolation) {\n  splitPairData(pairData, ratios).forEach((points) => {\n    plotPath(points, path, interpolation);\n  });\n}\nfunction pathSwipeInAnimation({ id, visible, nodeDataDependencies }, animationManager, ...paths) {\n  const { seriesRectWidth: width2, seriesRectHeight: height2 } = nodeDataDependencies;\n  staticFromToMotion(\n    id,\n    \"path_properties\",\n    animationManager,\n    paths,\n    { clipX: 0 },\n    { clipX: width2 },\n    {\n      phase: \"initial\",\n      start: { clip: true, clipY: height2, visible },\n      finish: { clip: false, visible }\n    }\n  );\n}\nfunction pathFadeInAnimation({ id }, subId, animationManager, phase = \"add\", ...selection) {\n  staticFromToMotion(id, subId, animationManager, selection, { opacity: 0 }, { opacity: 1 }, { phase });\n}\nfunction pathFadeOutAnimation({ id }, subId, animationManager, ...selection) {\n  staticFromToMotion(id, subId, animationManager, selection, { opacity: 1 }, { opacity: 0 }, { phase: \"remove\" });\n}\nfunction buildResetPathFn(opts) {\n  return (_node) => ({\n    visible: opts.getVisible(),\n    opacity: opts.getOpacity(),\n    clipScalingX: 1,\n    clip: false\n  });\n}\nfunction updateClipPath({ nodeDataDependencies }, path) {\n  const toFinite = (value) => isFinite(value) ? value : 0;\n  path.clipX = toFinite(nodeDataDependencies.seriesRectWidth);\n  path.clipY = toFinite(nodeDataDependencies.seriesRectHeight);\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/scaling.ts\nfunction isContinuousScaling(scaling) {\n  return scaling.type === \"continuous\" || scaling.type === \"log\";\n}\nfunction isCategoryScaling(scaling) {\n  return scaling.type === \"category\";\n}\nfunction areEqual(a, b) {\n  return a.domain.length === b.domain.length && a.range.length === b.range.length && a.domain.every((val, index) => val === b.domain[index]) && a.range.every((val, index) => val === b.range[index]);\n}\nfunction areScalingEqual(a, b) {\n  if (a === void 0 || b === void 0) {\n    return a !== void 0 || b !== void 0;\n  }\n  if (isContinuousScaling(a) && isContinuousScaling(b)) {\n    return a.type === b.type && areEqual(a, b);\n  }\n  if (isCategoryScaling(a) && isCategoryScaling(b)) {\n    return areEqual(a, b);\n  }\n  return false;\n}\nfunction isScaleValid(scale2) {\n  if (scale2 == null)\n    return false;\n  if (!scale2.range.every((v) => Number.isFinite(v)))\n    return false;\n  if (scale2.type === \"category\") {\n    return scale2.domain.every((v) => v != null);\n  }\n  return scale2.domain.every((v) => Number.isFinite(v) || v instanceof Date);\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/lineUtil.ts\nfunction* pathRanges(points) {\n  let start2 = -1;\n  let end2 = 0;\n  for (const { point } of points) {\n    if (point.moveTo) {\n      const range3 = start2 >= 0 ? { start: start2, end: end2 } : void 0;\n      start2 = end2;\n      end2 = start2;\n      if (range3 !== void 0) {\n        yield range3;\n      }\n    }\n    end2 += 1;\n  }\n  if (start2 !== -1) {\n    yield { start: start2, end: end2 };\n  }\n}\nfunction* pathRangePoints(points, { start: start2, end: end2 }) {\n  for (let i = start2; i < end2; i += 1) {\n    yield points[i].point;\n  }\n}\nfunction* pathRangePointsReverse(points, { start: start2, end: end2 }) {\n  for (let i = end2 - 1; i >= start2; i -= 1) {\n    yield points[i].point;\n  }\n}\nfunction integratedCategoryMatch(a, b) {\n  if (a == null || b == null)\n    return false;\n  if (typeof a !== \"object\" || typeof b !== \"object\")\n    return false;\n  if (\"id\" in a && \"id\" in b) {\n    return a.id === b.id;\n  }\n  return a.toString() === b.toString();\n}\nfunction scale(val, scaling) {\n  if (!scaling)\n    return NaN;\n  if (val instanceof Date) {\n    val = val.getTime();\n  }\n  if (scaling.type === \"continuous\" && typeof val === \"number\") {\n    const domainRatio = (val - scaling.domain[0]) / (scaling.domain[1] - scaling.domain[0]);\n    return domainRatio * (scaling.range[1] - scaling.range[0]) + scaling.range[0];\n  }\n  if (scaling.type === \"log\" && typeof val === \"number\") {\n    return scaling.convert(val);\n  }\n  const matchingIndex = scaling.domain.findIndex((d) => d === val);\n  if (matchingIndex >= 0) {\n    return scaling.range[matchingIndex];\n  }\n  const matchingIntegratedIndex = scaling.domain.findIndex((d) => integratedCategoryMatch(val, d));\n  if (matchingIntegratedIndex >= 0) {\n    return scaling.range[matchingIntegratedIndex];\n  }\n  return NaN;\n}\nfunction scalesChanged(newData, oldData) {\n  return !areScalingEqual(newData.scales.x, oldData.scales.x) || !areScalingEqual(newData.scales.y, oldData.scales.y);\n}\nfunction closeMatch(a, b) {\n  const an = Number(a);\n  const bn = Number(b);\n  if (!isNaN(an) && !isNaN(bn)) {\n    return Math.abs(bn - an) < 0.25;\n  }\n  return a === b;\n}\nfunction calculateMoveTo(from3 = false, to = false) {\n  if (from3 === to) {\n    return Boolean(from3);\n  }\n  return from3 ? \"in\" : \"out\";\n}\nfunction pairContinuousData(newData, oldData, opts = {}) {\n  const { backfillSplitMode = \"intersect\" } = opts;\n  const result = [];\n  const resultMap = {\n    added: {},\n    moved: {},\n    removed: {}\n  };\n  const pairUp = (from3, to, xValue, change = \"move\") => {\n    if (from3 && (isNaN(from3.point.x) || isNaN(from3.point.y))) {\n      from3 = to;\n    }\n    const resultPoint = {\n      from: from3?.point,\n      to: to?.point,\n      moveTo: calculateMoveTo(from3?.point.moveTo, to?.point.moveTo),\n      change\n    };\n    if (change === \"move\") {\n      resultMap.moved[xValue] = resultPoint;\n      oldIdx++;\n      newIdx++;\n    } else if (change === \"in\") {\n      resultMap.added[xValue] = resultPoint;\n      newIdx++;\n    } else if (change === \"out\") {\n      resultMap.removed[xValue] = resultPoint;\n      oldIdx++;\n    }\n    result.push(resultPoint);\n  };\n  const { min: minFromNode, max: maxFromNode } = minMax(oldData.nodeData);\n  const { min: minToNode, max: maxToNode } = minMax(newData.nodeData);\n  let oldIdx = 0;\n  let newIdx = 0;\n  while (oldIdx < oldData.nodeData.length || newIdx < newData.nodeData.length) {\n    const from3 = oldData.nodeData[oldIdx];\n    const to = newData.nodeData[newIdx];\n    const fromShifted = from3 ? scale(from3.xValue ?? NaN, newData.scales.x) : void 0;\n    const toUnshifted = to ? scale(to.xValue ?? NaN, oldData.scales.x) : void 0;\n    const NA = void 0;\n    if (fromShifted != null && closeMatch(fromShifted, to?.point.x)) {\n      pairUp(from3, to, to.xValue, \"move\");\n    } else if (fromShifted != null && fromShifted < (minToNode?.point.x ?? -Infinity)) {\n      pairUp(from3, NA, from3.xValue, \"out\");\n    } else if (fromShifted != null && fromShifted > (maxToNode?.point.x ?? Infinity)) {\n      pairUp(from3, NA, from3.xValue, \"out\");\n    } else if (toUnshifted != null && toUnshifted < (minFromNode?.point.x ?? -Infinity)) {\n      pairUp(NA, to, to.xValue, \"in\");\n    } else if (toUnshifted != null && toUnshifted > (maxFromNode?.point.x ?? Infinity)) {\n      pairUp(NA, to, to.xValue, \"in\");\n    } else if (fromShifted != null && fromShifted < to?.point.x) {\n      pairUp(from3, NA, from3.xValue, \"out\");\n    } else if (toUnshifted != null && toUnshifted < from3?.point.x) {\n      pairUp(NA, to, to.xValue, \"in\");\n    } else if (from3) {\n      pairUp(from3, NA, from3.xValue, \"out\");\n    } else if (to) {\n      pairUp(NA, to, to.xValue, \"in\");\n    } else {\n      throw new Error(\"Unable to process points\");\n    }\n  }\n  backfillPathPointData(result, backfillSplitMode);\n  return { result, resultMap };\n}\nfunction pairCategoryData(newData, oldData, diff2, opts = {}) {\n  const { backfillSplitMode = \"intersect\", multiDatum = false } = opts;\n  const result = [];\n  const resultMapSingle = {\n    added: {},\n    moved: {},\n    removed: {}\n  };\n  const resultMapMulti = {\n    added: {},\n    moved: {},\n    removed: {}\n  };\n  const pointResultMapping = {\n    in: \"added\",\n    move: \"moved\",\n    out: \"removed\"\n  };\n  let previousResultPoint = void 0;\n  let previousXValue = void 0;\n  const addToResultMap = (xValue, newPoint) => {\n    var _a;\n    const type = pointResultMapping[newPoint.change];\n    if (multiDatum) {\n      (_a = resultMapMulti[type])[xValue] ?? (_a[xValue] = []);\n      resultMapMulti[type][xValue].push(newPoint);\n    } else {\n      resultMapSingle[type][xValue] = newPoint;\n    }\n    previousResultPoint = newPoint;\n    previousXValue = transformIntegratedCategoryValue(xValue);\n  };\n  let oldIndex = 0;\n  let newIndex = 0;\n  let isXUnordered = false;\n  while (oldIndex < oldData.nodeData.length || newIndex < newData.nodeData.length) {\n    const before = oldData.nodeData[oldIndex];\n    const after = newData.nodeData[newIndex];\n    const bXValue = transformIntegratedCategoryValue(before?.xValue);\n    const aXValue = transformIntegratedCategoryValue(after?.xValue);\n    let resultPoint;\n    if (bXValue === aXValue) {\n      resultPoint = {\n        change: \"move\",\n        moveTo: calculateMoveTo(before.point.moveTo ?? false, after.point.moveTo),\n        from: before.point,\n        to: after.point\n      };\n      addToResultMap(before?.xValue, resultPoint);\n      oldIndex++;\n      newIndex++;\n    } else if (diff2?.removed.has(String(bXValue))) {\n      resultPoint = {\n        change: \"out\",\n        moveTo: before.point.moveTo ?? false,\n        from: before.point\n      };\n      addToResultMap(before?.xValue, resultPoint);\n      oldIndex++;\n    } else if (diff2?.added.has(String(aXValue))) {\n      resultPoint = {\n        change: \"in\",\n        moveTo: after.point.moveTo ?? false,\n        to: after.point\n      };\n      addToResultMap(after?.xValue, resultPoint);\n      newIndex++;\n    } else if (multiDatum && previousResultPoint && previousXValue === bXValue) {\n      resultPoint = {\n        ...previousResultPoint\n      };\n      addToResultMap(before?.xValue, resultPoint);\n      oldIndex++;\n    } else if (multiDatum && previousResultPoint && previousXValue === aXValue) {\n      resultPoint = {\n        ...previousResultPoint\n      };\n      addToResultMap(after?.xValue, resultPoint);\n      newIndex++;\n    } else {\n      isXUnordered = true;\n      break;\n    }\n    result.push(resultPoint);\n  }\n  let previousX = -Infinity;\n  isXUnordered || (isXUnordered = result.some((pathPoint) => {\n    const { change: marker, to: { x = -Infinity } = {} } = pathPoint;\n    if (marker === \"out\")\n      return;\n    const unordered = x < previousX;\n    previousX = x;\n    return unordered;\n  }));\n  if (isXUnordered) {\n    return { result: void 0, resultMap: void 0 };\n  }\n  backfillPathPointData(result, backfillSplitMode);\n  return { result, resultMap: multiDatum ? resultMapMulti : resultMapSingle };\n}\nfunction determinePathStatus(newData, oldData, pairData) {\n  let status = \"updated\";\n  const visible = (data) => {\n    return data.visible;\n  };\n  if (!visible(oldData) && visible(newData)) {\n    status = \"added\";\n  } else if (visible(oldData) && !visible(newData)) {\n    status = \"removed\";\n  } else {\n    for (let i = 0; i < pairData.length; i++) {\n      if (pairData[i].change !== \"move\")\n        break;\n      if (pairData[i].from?.x !== pairData[i].to?.x)\n        break;\n      if (pairData[i].from?.y !== pairData[i].to?.y)\n        break;\n      if (i === pairData.length - 1)\n        return \"no-op\";\n    }\n  }\n  return status;\n}\nfunction prepareLinePathPropertyAnimation(status, visibleToggleMode) {\n  const phase = visibleToggleMode === \"none\" ? \"updated\" : status;\n  const result = {\n    fromFn: (_path) => {\n      let mixin;\n      if (status === \"removed\") {\n        mixin = { finish: { visible: false } };\n      } else if (status === \"added\") {\n        mixin = { start: { visible: true } };\n      } else {\n        mixin = {};\n      }\n      return { phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[phase], ...mixin };\n    },\n    toFn: (_path) => {\n      return { phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[phase] };\n    }\n  };\n  if (visibleToggleMode === \"fade\") {\n    return {\n      fromFn: (path) => {\n        const opacity = status === \"added\" ? 0 : path.opacity;\n        return { opacity, ...result.fromFn(path) };\n      },\n      toFn: (path) => {\n        const opacity = status === \"removed\" ? 0 : 1;\n        return { opacity, ...result.toFn(path) };\n      }\n    };\n  }\n  return result;\n}\nfunction prepareLinePathAnimationFns(newData, oldData, pairData, visibleToggleMode, interpolation, render) {\n  const status = determinePathStatus(newData, oldData, pairData);\n  const removePhaseFn = (ratio2, path) => {\n    render(pairData, { move: 0, out: ratio2 }, path, interpolation);\n  };\n  const updatePhaseFn = (ratio2, path) => {\n    render(pairData, { move: ratio2 }, path, interpolation);\n  };\n  const addPhaseFn = (ratio2, path) => {\n    render(pairData, { move: 1, in: ratio2 }, path, interpolation);\n  };\n  const pathProperties = prepareLinePathPropertyAnimation(status, visibleToggleMode);\n  return { status, path: { addPhaseFn, updatePhaseFn, removePhaseFn }, pathProperties };\n}\nfunction prepareLinePathAnimation(newData, oldData, diff2, interpolation) {\n  const isCategoryBased = newData.scales.x?.type === \"category\";\n  const wasCategoryBased = oldData.scales.x?.type === \"category\";\n  if (isCategoryBased !== wasCategoryBased || !isScaleValid(newData.scales.x) || !isScaleValid(oldData.scales.x)) {\n    return;\n  }\n  const { result: pairData, resultMap: pairMap } = isCategoryBased ? pairCategoryData(newData, oldData, diff2) : pairContinuousData(newData, oldData);\n  let status = \"updated\";\n  if (oldData.visible && !newData.visible) {\n    status = \"removed\";\n  } else if (!oldData.visible && newData.visible) {\n    status = \"added\";\n  }\n  if (pairData === void 0 || pairMap === void 0) {\n    return;\n  }\n  const hasMotion = (diff2?.changed ?? true) || scalesChanged(newData, oldData) || status !== \"updated\";\n  const pathFns = prepareLinePathAnimationFns(newData, oldData, pairData, \"fade\", interpolation, renderPartialPath);\n  const marker = prepareMarkerAnimation(pairMap, status);\n  return { ...pathFns, marker, hasMotion };\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/lineInterpolationUtil.ts\nfunction toAxisValue(value) {\n  return transformIntegratedCategoryValue(value).valueOf();\n}\nfunction getAxisIndices({ data }, axisValues) {\n  return data.map((datum, datumIndex) => ({\n    xValue0Index: axisValues.indexOf(toAxisValue(datum.xValue0)),\n    xValue1Index: axisValues.indexOf(toAxisValue(datum.xValue1)),\n    datumIndex\n  }));\n}\nfunction validateAxisValuesOrder(axisValues, data) {\n  let x0 = -Infinity;\n  for (const axisValue of axisValues) {\n    const x = scale(axisValue, data.scales.x);\n    if (!Number.isFinite(x)) {\n      continue;\n    } else if (x < x0) {\n      return false;\n    } else {\n      x0 = x;\n    }\n  }\n  return true;\n}\nfunction getAxisValues(newData, oldData) {\n  const allAxisValues = /* @__PURE__ */ new Set();\n  for (const { xValue0, xValue1 } of newData.data) {\n    const xValue0Value = toAxisValue(xValue0);\n    const xValue1Value = toAxisValue(xValue1);\n    allAxisValues.add(xValue0Value).add(xValue1Value);\n  }\n  const newAxisValues = Array.from(allAxisValues).sort((a, b) => {\n    return scale(a, newData.scales.x) - scale(b, newData.scales.x);\n  });\n  const exclusivelyOldAxisValues = [];\n  for (const { xValue0, xValue1 } of oldData.data) {\n    const xValue0Value = toAxisValue(xValue0);\n    const xValue1Value = toAxisValue(xValue1);\n    if (!allAxisValues.has(xValue0Value)) {\n      allAxisValues.add(xValue0Value);\n      exclusivelyOldAxisValues.push(xValue0Value);\n    }\n    if (!allAxisValues.has(xValue1Value)) {\n      allAxisValues.add(xValue1Value);\n      exclusivelyOldAxisValues.push(xValue1Value);\n    }\n  }\n  exclusivelyOldAxisValues.sort((a, b) => {\n    return scale(a, oldData.scales.x) - scale(b, oldData.scales.x);\n  });\n  const axisValues = newAxisValues;\n  let insertionIndex = 0;\n  for (const oldValue of exclusivelyOldAxisValues) {\n    inner:\n      for (let i = axisValues.length; i > insertionIndex; i -= 1) {\n        const oldValueX = scale(oldValue, oldData.scales.x);\n        const newValueX = scale(axisValues[i], oldData.scales.x);\n        if (oldValueX > newValueX) {\n          insertionIndex = i + 1;\n          break inner;\n        }\n      }\n    axisValues.splice(insertionIndex, 0, oldValue);\n    insertionIndex += 1;\n  }\n  if (!validateAxisValuesOrder(axisValues, oldData))\n    return;\n  const oldDataAxisIndices = getAxisIndices(oldData, axisValues);\n  const newDataAxisIndices = getAxisIndices(newData, axisValues);\n  return { axisValues, oldDataAxisIndices, newDataAxisIndices };\n}\nfunction clipSpan(span, xValue0Index, xIndices) {\n  if (xIndices.xValue1Index === xIndices.xValue0Index + 1)\n    return span;\n  const range3 = spanRange(span);\n  const step = (range3[1].x - range3[0].x) / (xIndices.xValue1Index - xIndices.xValue0Index);\n  const start2 = range3[0].x + (xValue0Index - xIndices.xValue0Index) * step;\n  const end2 = start2 + step;\n  return clipSpanX(span, start2, end2);\n}\nfunction axisZeroSpan(span, data) {\n  const [r0, r1] = spanRange(span);\n  const y0 = scale(0, data.scales.y);\n  return rescaleSpan(span, { x: r0.x, y: y0 }, { x: r1.x, y: y0 });\n}\nfunction collapseSpan(span, data, axisIndices, indices, range3) {\n  let xValue;\n  let yValue;\n  if (indices.xValue0Index >= range3.xValue1Index) {\n    const datumIndex = axisIndices.findLast((i) => i.xValue1Index <= range3.xValue1Index)?.datumIndex;\n    const datum = datumIndex != null ? data.data[datumIndex] : void 0;\n    xValue = datum?.xValue1;\n    yValue = datum?.yValue1;\n  } else if (indices.xValue0Index <= range3.xValue0Index) {\n    const datumIndex = axisIndices.find((i) => i.xValue0Index >= range3.xValue0Index)?.datumIndex;\n    const datum = datumIndex != null ? data.data[datumIndex] : void 0;\n    xValue = datum?.xValue0;\n    yValue = datum?.yValue0;\n  }\n  if (xValue == null || yValue == null) {\n    return axisZeroSpan(span, data);\n  }\n  const x = scale(xValue, data.scales.x);\n  const y = scale(yValue, data.scales.y);\n  const point = { x, y };\n  return rescaleSpan(span, point, point);\n}\nfunction zeroDataSpan(spanDatum, zeroData) {\n  const newSpanXValue0 = toAxisValue(spanDatum.xValue0);\n  const newSpanXValue1 = toAxisValue(spanDatum.xValue1);\n  return zeroData?.find(\n    (span) => toAxisValue(span.xValue0) === newSpanXValue0 && toAxisValue(span.xValue1) === newSpanXValue1\n  )?.span;\n}\nfunction addSpan(newData, newAxisIndices, newIndices, oldZeroData, range3, out) {\n  const newSpanDatum = newData.data[newIndices.datumIndex];\n  const newSpan = newSpanDatum.span;\n  const zeroSpan = zeroDataSpan(newSpanDatum, oldZeroData);\n  if (zeroSpan != null) {\n    out.removed.push({ from: zeroSpan, to: zeroSpan });\n    out.moved.push({ from: zeroSpan, to: newSpan });\n    out.added.push({ from: newSpan, to: newSpan });\n  } else {\n    const oldSpan = collapseSpan(newSpan, newData, newAxisIndices, newIndices, range3);\n    out.added.push({ from: oldSpan, to: newSpan });\n  }\n}\nfunction removeSpan(oldData, oldAxisIndices, oldIndices, newZeroData, range3, out) {\n  const oldSpanDatum = oldData.data[oldIndices.datumIndex];\n  const oldSpan = oldSpanDatum.span;\n  const zeroSpan = zeroDataSpan(oldSpanDatum, newZeroData);\n  if (zeroSpan != null) {\n    out.removed.push({ from: oldSpan, to: oldSpan });\n    out.moved.push({ from: oldSpan, to: zeroSpan });\n    out.added.push({ from: zeroSpan, to: zeroSpan });\n  } else {\n    const newSpan = collapseSpan(oldSpan, oldData, oldAxisIndices, oldIndices, range3);\n    out.removed.push({ from: oldSpan, to: newSpan });\n  }\n}\nfunction alignSpanToContainingSpan(span, axisValues, preData, postData, postSpanIndices) {\n  const startXValue0 = axisValues[postSpanIndices.xValue0Index];\n  const startDatum = preData.data.find((spanDatum) => toAxisValue(spanDatum.xValue0) === startXValue0);\n  const endXValue1 = axisValues[postSpanIndices.xValue1Index];\n  const endDatum = preData.data.find((spanDatum) => toAxisValue(spanDatum.xValue1) === endXValue1);\n  if (startDatum == null || endDatum == null)\n    return;\n  const [{ x: x0 }, { x: x1 }] = spanRange(span);\n  const startX = scale(startDatum.xValue0, preData.scales.x);\n  const startY = scale(startDatum.yValue0, preData.scales.y);\n  const endX = scale(endDatum.xValue1, preData.scales.x);\n  const endY = scale(endDatum.yValue1, preData.scales.y);\n  let altSpan = postData.data[postSpanIndices.datumIndex].span;\n  altSpan = rescaleSpan(altSpan, { x: startX, y: startY }, { x: endX, y: endY });\n  altSpan = clipSpanX(altSpan, x0, x1);\n  return altSpan;\n}\nfunction appendSpanPhases(newData, oldData, axisValues, xValue0Index, newAxisIndices, oldAxisIndices, range3, out) {\n  const xValue1Index = xValue0Index + 1;\n  const oldIndices = oldAxisIndices.find((i) => i.xValue0Index <= xValue0Index && i.xValue1Index >= xValue1Index);\n  const newIndices = newAxisIndices.find((i) => i.xValue0Index <= xValue0Index && i.xValue1Index >= xValue1Index);\n  const oldZeroData = oldData.zeroData;\n  const newZeroData = newData.zeroData;\n  if (oldIndices == null && newIndices != null) {\n    addSpan(newData, newAxisIndices, newIndices, oldZeroData, range3, out);\n    return;\n  } else if (oldIndices != null && newIndices == null) {\n    removeSpan(oldData, oldAxisIndices, oldIndices, newZeroData, range3, out);\n    return;\n  } else if (oldIndices == null || newIndices == null) {\n    return;\n  }\n  let ordering;\n  if (oldIndices.xValue0Index === newIndices.xValue0Index && oldIndices.xValue1Index === newIndices.xValue1Index) {\n    ordering = 0;\n  } else if (oldIndices.xValue0Index <= newIndices.xValue0Index && oldIndices.xValue1Index >= newIndices.xValue1Index) {\n    ordering = -1;\n  } else if (oldIndices.xValue0Index >= newIndices.xValue0Index && oldIndices.xValue1Index <= newIndices.xValue1Index) {\n    ordering = 1;\n  } else {\n    ordering = 0;\n  }\n  const oldSpanDatum = oldData.data[oldIndices.datumIndex];\n  const clippedOldSpanOldScale = clipSpan(oldSpanDatum.span, xValue0Index, oldIndices);\n  const newSpanDatum = newData.data[newIndices.datumIndex];\n  const clippedNewSpanNewScale = clipSpan(newSpanDatum.span, xValue0Index, newIndices);\n  if (ordering === 1) {\n    const clippedPostRemoveOldSpanOldScale = alignSpanToContainingSpan(\n      clippedOldSpanOldScale,\n      axisValues,\n      oldData,\n      newData,\n      newIndices\n    );\n    if (clippedPostRemoveOldSpanOldScale != null) {\n      out.removed.push({ from: clippedOldSpanOldScale, to: clippedPostRemoveOldSpanOldScale });\n      out.moved.push({ from: clippedPostRemoveOldSpanOldScale, to: clippedNewSpanNewScale });\n      out.added.push({ from: clippedNewSpanNewScale, to: clippedNewSpanNewScale });\n    } else {\n      removeSpan(oldData, oldAxisIndices, oldIndices, newZeroData, range3, out);\n    }\n  } else if (ordering === -1) {\n    const clippedPreAddedNewSpanNewScale = alignSpanToContainingSpan(\n      clippedNewSpanNewScale,\n      axisValues,\n      newData,\n      oldData,\n      oldIndices\n    );\n    if (clippedPreAddedNewSpanNewScale != null) {\n      out.removed.push({ from: clippedOldSpanOldScale, to: clippedOldSpanOldScale });\n      out.moved.push({ from: clippedOldSpanOldScale, to: clippedPreAddedNewSpanNewScale });\n      out.added.push({ from: clippedPreAddedNewSpanNewScale, to: clippedNewSpanNewScale });\n    } else {\n      addSpan(newData, newAxisIndices, newIndices, oldZeroData, range3, out);\n    }\n  } else {\n    out.removed.push({ from: clippedOldSpanOldScale, to: clippedOldSpanOldScale });\n    out.moved.push({ from: clippedOldSpanOldScale, to: clippedNewSpanNewScale });\n    out.added.push({ from: clippedNewSpanNewScale, to: clippedNewSpanNewScale });\n  }\n}\nfunction phaseAnimation(axisContext, newData, oldData, out) {\n  const { axisValues, oldDataAxisIndices, newDataAxisIndices } = axisContext;\n  const range3 = {\n    xValue0Index: Math.max(\n      oldDataAxisIndices.at(0)?.xValue0Index ?? -Infinity,\n      newDataAxisIndices.at(0)?.xValue0Index ?? -Infinity\n    ),\n    xValue1Index: Math.min(\n      oldDataAxisIndices.at(-1)?.xValue1Index ?? Infinity,\n      newDataAxisIndices.at(-1)?.xValue1Index ?? Infinity\n    )\n  };\n  for (let xValue0Index = 0; xValue0Index < axisValues.length - 1; xValue0Index += 1) {\n    appendSpanPhases(\n      newData,\n      oldData,\n      axisValues,\n      xValue0Index,\n      newDataAxisIndices,\n      oldDataAxisIndices,\n      range3,\n      out\n    );\n  }\n}\nfunction resetAnimation(newData, oldData, out) {\n  for (const oldSpanDatum of oldData.data) {\n    const oldSpan = oldSpanDatum.span;\n    const zeroSpan = zeroDataSpan(oldSpanDatum, oldData.zeroData) ?? axisZeroSpan(oldSpan, oldData);\n    out.removed.push({ from: oldSpan, to: zeroSpan });\n  }\n  for (const newSpanDatum of newData.data) {\n    const newSpan = newSpanDatum.span;\n    const zeroSpan = zeroDataSpan(newSpanDatum, newData.zeroData) ?? axisZeroSpan(newSpan, newData);\n    out.added.push({ from: zeroSpan, to: newSpan });\n  }\n}\nfunction pairUpSpans(newData, oldData) {\n  const out = {\n    removed: [],\n    moved: [],\n    added: []\n  };\n  const axisContext = getAxisValues(newData, oldData);\n  if (axisContext == null) {\n    resetAnimation(newData, oldData, out);\n  } else {\n    phaseAnimation(axisContext, newData, oldData, out);\n  }\n  return out;\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/areaUtil.ts\nfunction plotFillSpans(ratio2, path, spans, fillPhantomSpans) {\n  for (let i = 0; i < spans.length; i += 1) {\n    const span = spans[i];\n    const reversedPhantomSpan = fillPhantomSpans[i];\n    plotInterpolatedSpans(path.path, span.from, span.to, ratio2, 1 /* MoveTo */, false);\n    plotInterpolatedSpans(\n      path.path,\n      reversedPhantomSpan.from,\n      reversedPhantomSpan.to,\n      ratio2,\n      2 /* LineTo */,\n      true\n    );\n    path.path.closePath();\n  }\n}\nfunction prepareAreaFillAnimationFns(status, spans, fillPhantomSpans, visibleToggleMode) {\n  const removePhaseFn = (ratio2, path) => plotFillSpans(ratio2, path, spans.removed, fillPhantomSpans.removed);\n  const updatePhaseFn = (ratio2, path) => plotFillSpans(ratio2, path, spans.moved, fillPhantomSpans.moved);\n  const addPhaseFn = (ratio2, path) => plotFillSpans(ratio2, path, spans.added, fillPhantomSpans.added);\n  const pathProperties = prepareLinePathPropertyAnimation(status, visibleToggleMode);\n  return { status, path: { addPhaseFn, updatePhaseFn, removePhaseFn }, pathProperties };\n}\nfunction plotStrokeSpans(ratio2, path, spans) {\n  for (const span of spans) {\n    plotInterpolatedSpans(path.path, span.from, span.to, ratio2, 1 /* MoveTo */, false);\n  }\n}\nfunction prepareAreaStrokeAnimationFns(status, spans, visibleToggleMode) {\n  const removePhaseFn = (ratio2, path) => plotStrokeSpans(ratio2, path, spans.removed);\n  const updatePhaseFn = (ratio2, path) => plotStrokeSpans(ratio2, path, spans.moved);\n  const addPhaseFn = (ratio2, path) => plotStrokeSpans(ratio2, path, spans.added);\n  const pathProperties = prepareLinePathPropertyAnimation(status, visibleToggleMode);\n  return { status, path: { addPhaseFn, updatePhaseFn, removePhaseFn }, pathProperties };\n}\nfunction prepareAreaPathAnimation(newData, oldData) {\n  const isCategoryBased = newData.scales.x?.type === \"category\";\n  const wasCategoryBased = oldData.scales.x?.type === \"category\";\n  if (isCategoryBased !== wasCategoryBased || !isScaleValid(newData.scales.x) || !isScaleValid(oldData.scales.x)) {\n    return;\n  }\n  let status = \"updated\";\n  if (oldData.visible && !newData.visible) {\n    status = \"removed\";\n  } else if (!oldData.visible && newData.visible) {\n    status = \"added\";\n  }\n  const fillSpans = pairUpSpans(\n    { scales: newData.scales, data: newData.fillData.spans, visible: newData.visible },\n    { scales: oldData.scales, data: oldData.fillData.spans, visible: oldData.visible }\n  );\n  const fillPhantomSpans = pairUpSpans(\n    { scales: newData.scales, data: newData.fillData.phantomSpans, visible: newData.visible },\n    { scales: oldData.scales, data: oldData.fillData.phantomSpans, visible: oldData.visible }\n  );\n  const strokeSpans = pairUpSpans(\n    {\n      scales: newData.scales,\n      data: newData.strokeData.spans,\n      visible: newData.visible,\n      zeroData: newData.fillData.phantomSpans\n    },\n    {\n      scales: oldData.scales,\n      data: oldData.strokeData.spans,\n      visible: oldData.visible,\n      zeroData: oldData.fillData.phantomSpans\n    }\n  );\n  const fadeMode = \"none\";\n  const fill = prepareAreaFillAnimationFns(status, fillSpans, fillPhantomSpans, fadeMode);\n  const stroke = prepareAreaStrokeAnimationFns(status, strokeSpans, fadeMode);\n  return { status, fill, stroke };\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/areaSeries.ts\nvar CROSS_FILTER_AREA_FILL_OPACITY_FACTOR = 0.125;\nvar CROSS_FILTER_AREA_STROKE_OPACITY_FACTOR = 0.25;\nvar AreaSeries = class extends CartesianSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,\n      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,\n      pathsPerSeries: [\"fill\", \"stroke\"],\n      pathsZIndexSubOrderOffset: [0, 1e3],\n      hasMarkers: true,\n      markerSelectionGarbageCollection: false,\n      pickModes: [2 /* AXIS_ALIGNED */, 0 /* EXACT_SHAPE_MATCH */],\n      animationResetFns: {\n        path: buildResetPathFn({ getVisible: () => this.visible, getOpacity: () => this.getOpacity() }),\n        label: resetLabelFn,\n        marker: (node, datum) => ({ ...resetMarkerFn(node), ...resetMarkerPositionFn(node, datum) })\n      }\n    });\n    this.properties = new AreaSeriesProperties();\n  }\n  async processData(dataController) {\n    if (this.data == null || !this.properties.isValid()) {\n      return;\n    }\n    const { data, visible, seriesGrouping: { groupIndex = this.id, stackCount = 1 } = {} } = this;\n    const { xKey, yKey, yFilterKey, connectMissingData, normalizedTo } = this.properties;\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    const xScale = this.axes[\"x\" /* X */]?.scale;\n    const yScale = this.axes[\"y\" /* Y */]?.scale;\n    const { xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });\n    const idMap = {\n      value: `area-stack-${groupIndex}-yValue`,\n      values: `area-stack-${groupIndex}-yValues`,\n      stack: `area-stack-${groupIndex}-yValue-stack`,\n      marker: `area-stack-${groupIndex}-yValues-marker`\n    };\n    const extraProps = [];\n    if (isDefined(normalizedTo)) {\n      extraProps.push(normaliseGroupTo(Object.values(idMap), normalizedTo, \"range\"));\n    }\n    if (animationEnabled) {\n      extraProps.push(animationValidation());\n    }\n    const common = { invalidValue: null };\n    if (connectMissingData && stackCount > 1) {\n      common.invalidValue = 0;\n    }\n    if (!visible) {\n      common.forceValue = 0;\n    }\n    await this.requestDataModel(dataController, data, {\n      props: [\n        keyProperty(xKey, xScaleType, { id: \"xValue\" }),\n        valueProperty(yKey, yScaleType, { id: `yValueRaw`, ...common }),\n        ...yFilterKey != null ? [valueProperty(yFilterKey, yScaleType, { id: \"yFilterRaw\" })] : [],\n        ...groupStackValueProperty(yKey, yScaleType, { id: `yValueStack`, ...common, groupId: idMap.stack }),\n        valueProperty(yKey, yScaleType, { id: `yValue`, ...common, groupId: idMap.value }),\n        ...groupAccumulativeValueProperty(\n          yKey,\n          \"window\",\n          \"current\",\n          { id: `yValueEnd`, ...common, groupId: idMap.values },\n          yScaleType\n        ),\n        ...groupAccumulativeValueProperty(\n          yKey,\n          \"normal\",\n          \"current\",\n          { id: `yValueCumulative`, ...common, groupId: idMap.marker },\n          yScaleType\n        ),\n        ...extraProps\n      ],\n      groupByKeys: true,\n      groupByData: false\n    });\n    this.animationState.transition(\"updateData\");\n  }\n  getSeriesDomain(direction) {\n    const { processedData, dataModel, axes } = this;\n    if (!processedData || !dataModel || processedData.data.length === 0)\n      return [];\n    const yAxis = axes[\"y\" /* Y */];\n    const keyDef = dataModel.resolveProcessedDataDefById(this, `xValue`);\n    const keys = dataModel.getDomain(this, `xValue`, \"key\", processedData);\n    const yExtent = dataModel.getDomain(this, `yValueEnd`, \"value\", processedData);\n    if (direction === \"x\" /* X */) {\n      if (keyDef?.def.type === \"key\" && keyDef.def.valueType === \"category\") {\n        return keys;\n      }\n      return fixNumericExtent(extent(keys));\n    } else if (yAxis instanceof LogAxis || yAxis instanceof TimeAxis) {\n      return fixNumericExtent(yExtent);\n    } else {\n      const fixedYExtent = [yExtent[0] > 0 ? 0 : yExtent[0], yExtent[1] < 0 ? 0 : yExtent[1]];\n      return fixNumericExtent(fixedYExtent);\n    }\n  }\n  async createNodeData() {\n    const { axes, data, processedData: { data: groupedData } = {}, dataModel } = this;\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    if (!xAxis || !yAxis || !data || !dataModel || !this.properties.isValid()) {\n      return;\n    }\n    const {\n      yKey,\n      xKey,\n      yFilterKey,\n      marker,\n      label,\n      fill: seriesFill,\n      stroke: seriesStroke,\n      connectMissingData\n    } = this.properties;\n    const { scale: xScale } = xAxis;\n    const { scale: yScale } = yAxis;\n    const { isContinuousY } = this.getScaleInformation({ xScale, yScale });\n    const xOffset = (xScale.bandwidth ?? 0) / 2;\n    const defs = dataModel.resolveProcessedDataDefsByIds(this, [`yValueEnd`, `yValueRaw`, `yValueCumulative`]);\n    const yFilterIndex = yFilterKey != null ? dataModel.resolveProcessedDataIndexById(this, \"yFilterRaw\") : void 0;\n    const yValueStackIndex = dataModel.resolveProcessedDataIndexById(this, \"yValueStack\");\n    const createMarkerCoordinate = (xDatum, yEnd, rawYDatum) => {\n      let currY;\n      if (isDefined(this.properties.normalizedTo) ? isContinuousY && isContinuous(rawYDatum) : !isNaN(rawYDatum)) {\n        currY = yEnd;\n      }\n      return {\n        x: xScale.convert(xDatum) + xOffset,\n        y: yScale.convert(currY),\n        size: marker.size\n      };\n    };\n    const itemId = yKey;\n    const labelData = [];\n    const markerData = [];\n    const { visibleSameStackCount } = this.ctx.seriesStateManager.getVisiblePeerGroupIndex(this);\n    let datumIdx = -1;\n    let crossFiltering = false;\n    groupedData?.forEach((datumGroup) => {\n      const {\n        keys,\n        keys: [xDatum],\n        datum: datumArray,\n        values: valuesArray\n      } = datumGroup;\n      valuesArray.forEach((values, valueIdx) => {\n        datumIdx++;\n        const seriesDatum = datumArray[valueIdx];\n        const dataValues2 = dataModel.resolveProcessedDataDefsValues(defs, { keys, values });\n        const { yValueRaw: yDatum, yValueCumulative, yValueEnd } = dataValues2;\n        const validPoint = Number.isFinite(yDatum);\n        const point = createMarkerCoordinate(xDatum, +yValueCumulative, yDatum);\n        const selected = yFilterIndex != null ? values[yFilterIndex] === yDatum : void 0;\n        if (selected === false) {\n          crossFiltering = true;\n        }\n        if (validPoint && marker) {\n          markerData.push({\n            index: datumIdx,\n            series: this,\n            itemId,\n            datum: seriesDatum,\n            midPoint: { x: point.x, y: point.y },\n            cumulativeValue: yValueEnd,\n            yValue: yDatum,\n            xValue: xDatum,\n            yKey,\n            xKey,\n            point,\n            fill: marker.fill ?? seriesFill,\n            stroke: marker.stroke ?? seriesStroke,\n            strokeWidth: marker.strokeWidth ?? this.getStrokeWidth(this.properties.strokeWidth),\n            selected\n          });\n        }\n        if (validPoint && label) {\n          const labelText = this.getLabelText(\n            label,\n            {\n              value: yDatum,\n              datum: seriesDatum,\n              xKey,\n              yKey,\n              xName: this.properties.xName,\n              yName: this.properties.yName\n            },\n            formatValue\n          );\n          labelData.push({\n            index: datumIdx,\n            series: this,\n            itemId: yKey,\n            datum: seriesDatum,\n            x: point.x,\n            y: point.y,\n            labelText\n          });\n        }\n      });\n    });\n    const { interpolation } = this.properties;\n    const interpolatePoints = (points) => {\n      let spans;\n      const pointsIter = points.map((point) => point.point);\n      switch (interpolation.type) {\n        case \"linear\":\n          spans = linearPoints(pointsIter);\n          break;\n        case \"smooth\":\n          spans = smoothPoints(pointsIter, interpolation.tension);\n          break;\n        case \"step\":\n          spans = stepPoints(pointsIter, interpolation.position);\n          break;\n      }\n      return spans.map((span, i) => ({\n        span,\n        xValue0: points[i].xDatum,\n        yValue0: points[i].yDatum,\n        xValue1: points[i + 1].xDatum,\n        yValue1: points[i + 1].yDatum\n      }));\n    };\n    const spansForPoints = (points) => {\n      return points.flatMap((p) => {\n        return Array.isArray(p) ? interpolatePoints(p) : new Array(p.skip).fill(null);\n      });\n    };\n    const dataValues = groupedData?.flatMap((datumGroup) => {\n      const {\n        keys: [xDatum],\n        values: valuesArray\n      } = datumGroup;\n      return valuesArray.map((values) => ({ xDatum, values }));\n    });\n    const createPoint = (xDatum, yDatum) => ({\n      point: {\n        x: xScale.convert(xDatum) + xOffset,\n        y: yScale.convert(yDatum)\n      },\n      xDatum,\n      yDatum\n    });\n    const getSeriesSpans = (index) => {\n      const points = [];\n      if (dataValues == null)\n        return [];\n      for (let i = 0; i < dataValues.length; i += 1) {\n        const { xDatum, values } = dataValues[i];\n        const yValueStack = values[yValueStackIndex];\n        const yDatum = yValueStack[index];\n        const yDatumIsFinite = Number.isFinite(yDatum);\n        if (connectMissingData && !yDatumIsFinite)\n          continue;\n        const lastYValueStack = dataValues[i - 1]?.values[yValueStackIndex];\n        const nextYValueStack = dataValues[i + 1]?.values[yValueStackIndex];\n        let yValueEndBackwards = 0;\n        let yValueEndForwards = 0;\n        for (let j = 0; j <= index; j += 1) {\n          const value = yValueStack[j];\n          if (Number.isFinite(value)) {\n            const lastWasFinite = lastYValueStack == null || Number.isFinite(lastYValueStack[j]);\n            const nextWasFinite = nextYValueStack == null || Number.isFinite(nextYValueStack[j]);\n            if (lastWasFinite) {\n              yValueEndBackwards += value;\n            }\n            if (nextWasFinite) {\n              yValueEndForwards += value;\n            }\n          }\n        }\n        const currentPoints = points[points.length - 1];\n        if (!connectMissingData && (yValueEndBackwards !== yValueEndForwards || !yDatumIsFinite)) {\n          if (!yDatumIsFinite && Array.isArray(currentPoints) && currentPoints.length === 1) {\n            points[points.length - 1] = { skip: 1 };\n          } else {\n            const pointBackwards = createPoint(xDatum, yValueEndBackwards);\n            const pointForwards = createPoint(xDatum, yValueEndForwards);\n            if (Array.isArray(currentPoints)) {\n              currentPoints.push(pointBackwards);\n            } else if (currentPoints != null) {\n              currentPoints.skip += 1;\n            }\n            points.push(yDatumIsFinite ? [pointForwards] : { skip: 0 });\n          }\n        } else {\n          const yValueEnd = Math.max(yValueEndBackwards, yValueEndForwards);\n          const point = createPoint(xDatum, yValueEnd);\n          if (Array.isArray(currentPoints)) {\n            currentPoints.push(point);\n          } else if (currentPoints != null) {\n            currentPoints.skip += 1;\n            points.push([point]);\n          } else {\n            points.push([point]);\n          }\n        }\n      }\n      return spansForPoints(points);\n    };\n    const stackIndex = this.seriesGrouping?.stackIndex ?? 0;\n    const getAxisSpans = () => {\n      if (dataValues == null)\n        return [];\n      const yValueZeroPoints = dataValues.map(({ xDatum, values }) => {\n        const yValueStack = values[yValueStackIndex];\n        const yDatum = yValueStack[stackIndex];\n        if (connectMissingData && !Number.isFinite(yDatum))\n          return;\n        return createPoint(xDatum, 0);\n      }).filter((x) => x != null);\n      return interpolatePoints(yValueZeroPoints);\n    };\n    const currentSeriesSpans = getSeriesSpans(stackIndex);\n    const phantomSpans = currentSeriesSpans.map(() => null);\n    for (let j = stackIndex - 1; j >= -1; j -= 1) {\n      let spans;\n      for (let i = 0; i < phantomSpans.length; i += 1) {\n        if (phantomSpans[i] != null)\n          continue;\n        spans ?? (spans = j !== -1 ? getSeriesSpans(j) : getAxisSpans());\n        phantomSpans[i] = spans[i];\n      }\n    }\n    const fillSpans = currentSeriesSpans.map((span, index) => span ?? phantomSpans[index]);\n    const strokeSpans = currentSeriesSpans.filter((span) => span != null);\n    const context = {\n      itemId,\n      fillData: { itemId, spans: fillSpans, phantomSpans },\n      strokeData: { itemId, spans: strokeSpans },\n      labelData,\n      nodeData: markerData,\n      scales: this.calculateScaling(),\n      visible: this.visible,\n      stackVisible: visibleSameStackCount > 0,\n      crossFiltering\n    };\n    return context;\n  }\n  isPathOrSelectionDirty() {\n    return this.properties.marker.isDirty();\n  }\n  markerFactory() {\n    const { shape } = this.properties.marker;\n    const MarkerShape = getMarker(shape);\n    return new MarkerShape();\n  }\n  async updatePathNodes(opts) {\n    const { opacity, visible, animationEnabled } = opts;\n    const [fill, stroke] = opts.paths;\n    const crossFiltering = this.contextNodeData?.crossFiltering === true;\n    const strokeWidth = this.getStrokeWidth(this.properties.strokeWidth);\n    stroke.setProperties({\n      fill: void 0,\n      lineJoin: stroke.lineCap = \"round\",\n      pointerEvents: 1 /* None */,\n      stroke: this.properties.stroke,\n      strokeWidth,\n      strokeOpacity: this.properties.strokeOpacity * (crossFiltering ? CROSS_FILTER_AREA_STROKE_OPACITY_FACTOR : 1),\n      lineDash: this.properties.lineDash,\n      lineDashOffset: this.properties.lineDashOffset,\n      opacity,\n      visible: visible || animationEnabled\n    });\n    fill.setProperties({\n      stroke: void 0,\n      lineJoin: \"round\",\n      pointerEvents: 1 /* None */,\n      fill: this.properties.fill,\n      fillOpacity: this.properties.fillOpacity * (crossFiltering ? CROSS_FILTER_AREA_FILL_OPACITY_FACTOR : 1),\n      fillShadow: this.properties.shadow,\n      opacity,\n      visible: visible || animationEnabled\n    });\n    updateClipPath(this, stroke);\n    updateClipPath(this, fill);\n  }\n  async updatePaths(opts) {\n    this.updateAreaPaths(opts.paths, opts.contextData);\n  }\n  updateAreaPaths(paths, contextData) {\n    for (const path of paths) {\n      path.visible = contextData.visible;\n    }\n    if (contextData.visible) {\n      this.updateFillPath(paths, contextData);\n      this.updateStrokePath(paths, contextData);\n    } else {\n      for (const path of paths) {\n        path.path.clear();\n        path.checkPathDirty();\n      }\n    }\n  }\n  updateFillPath(paths, contextData) {\n    const { spans, phantomSpans } = contextData.fillData;\n    const [fill] = paths;\n    const { path } = fill;\n    path.clear(true);\n    for (let i = 0; i < spans.length; i += 1) {\n      const { span } = spans[i];\n      const phantomSpan = phantomSpans[i].span;\n      plotSpan(path, span, 1 /* MoveTo */, false);\n      plotSpan(path, phantomSpan, 2 /* LineTo */, true);\n      path.closePath();\n    }\n    fill.checkPathDirty();\n  }\n  updateStrokePath(paths, contextData) {\n    const { spans } = contextData.strokeData;\n    const [, stroke] = paths;\n    const { path } = stroke;\n    path.clear(true);\n    for (const { span } of spans) {\n      plotSpan(path, span, 1 /* MoveTo */, false);\n    }\n    stroke.checkPathDirty();\n  }\n  async updateMarkerSelection(opts) {\n    const { nodeData, markerSelection } = opts;\n    const markersEnabled = this.properties.marker.enabled || this.contextNodeData?.crossFiltering === true;\n    if (this.properties.marker.isDirty()) {\n      markerSelection.clear();\n      markerSelection.cleanup();\n    }\n    return markerSelection.update(markersEnabled ? nodeData : []);\n  }\n  async updateMarkerNodes(opts) {\n    const { markerSelection, isHighlight: highlighted } = opts;\n    const { xKey, yKey, marker, fill, stroke, strokeWidth, fillOpacity, strokeOpacity, highlightStyle } = this.properties;\n    const baseStyle = mergeDefaults(highlighted && highlightStyle.item, marker.getStyle(), {\n      fill,\n      stroke,\n      strokeWidth,\n      fillOpacity,\n      strokeOpacity\n    });\n    markerSelection.each((node, datum) => {\n      this.updateMarkerStyle(node, marker, { datum, highlighted, xKey, yKey }, baseStyle, {\n        selected: datum.selected\n      });\n    });\n    if (!highlighted) {\n      this.properties.marker.markClean();\n    }\n  }\n  async updateLabelSelection(opts) {\n    const { labelData, labelSelection } = opts;\n    return labelSelection.update(labelData);\n  }\n  async updateLabelNodes(opts) {\n    const { labelSelection } = opts;\n    const { enabled: labelEnabled, fontStyle, fontWeight, fontSize, fontFamily, color } = this.properties.label;\n    labelSelection.each((text, datum) => {\n      const { x, y, labelText } = datum;\n      if (labelText && labelEnabled && this.visible) {\n        text.fontStyle = fontStyle;\n        text.fontWeight = fontWeight;\n        text.fontSize = fontSize;\n        text.fontFamily = fontFamily;\n        text.textAlign = \"center\";\n        text.textBaseline = \"bottom\";\n        text.text = labelText;\n        text.x = x;\n        text.y = y - 10;\n        text.fill = color;\n        text.visible = true;\n      } else {\n        text.visible = false;\n      }\n    });\n  }\n  getTooltipHtml(nodeDatum) {\n    const { id: seriesId, axes, dataModel } = this;\n    const { xKey, xName, yName, tooltip, marker } = this.properties;\n    const { yKey, xValue, yValue, datum, itemId } = nodeDatum;\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    if (!this.properties.isValid() || !(xAxis && yAxis && isFiniteNumber(yValue)) || !dataModel) {\n      return EMPTY_TOOLTIP_CONTENT;\n    }\n    const xString = xAxis.formatDatum(xValue);\n    const yString = yAxis.formatDatum(yValue);\n    const title = sanitizeHtml(yName);\n    const content = sanitizeHtml(xString + \": \" + yString);\n    const baseStyle = mergeDefaults({ fill: this.properties.fill }, marker.getStyle(), {\n      stroke: this.properties.stroke,\n      strokeWidth: this.properties.strokeWidth\n    });\n    const { fill: color } = this.getMarkerStyle(\n      marker,\n      { datum: nodeDatum, xKey, yKey, highlighted: false },\n      baseStyle\n    );\n    return tooltip.toTooltipHtml(\n      { title, content, backgroundColor: color },\n      {\n        datum,\n        itemId,\n        xKey,\n        xName,\n        yKey,\n        yName,\n        color,\n        title,\n        seriesId\n      }\n    );\n  }\n  getLegendData(legendType) {\n    if (!this.data?.length || !this.properties.isValid() || !this.properties.showInLegend || legendType !== \"category\") {\n      return [];\n    }\n    const {\n      yKey,\n      yName,\n      fill,\n      stroke,\n      fillOpacity,\n      strokeOpacity,\n      strokeWidth,\n      lineDash,\n      marker,\n      visible,\n      legendItemName\n    } = this.properties;\n    const useAreaFill = !marker.enabled || marker.fill === void 0;\n    return [\n      {\n        legendType,\n        id: this.id,\n        itemId: yKey,\n        seriesId: this.id,\n        enabled: visible,\n        label: {\n          text: legendItemName ?? yName ?? yKey\n        },\n        symbols: [\n          {\n            marker: {\n              shape: marker.shape,\n              fill: useAreaFill ? fill : marker.fill,\n              fillOpacity: useAreaFill ? fillOpacity : marker.fillOpacity,\n              stroke: marker.stroke ?? stroke,\n              strokeOpacity: marker.strokeOpacity ?? strokeOpacity,\n              strokeWidth: marker.strokeWidth ?? 0,\n              enabled: marker.enabled || strokeWidth <= 0\n            },\n            line: {\n              stroke,\n              strokeOpacity,\n              strokeWidth,\n              lineDash\n            }\n          }\n        ],\n        legendItemName\n      }\n    ];\n  }\n  animateEmptyUpdateReady(animationData) {\n    const { markerSelection, labelSelection, contextData, paths } = animationData;\n    const { animationManager } = this.ctx;\n    this.updateAreaPaths(paths, contextData);\n    pathSwipeInAnimation(this, animationManager, ...paths);\n    resetMotion([markerSelection], resetMarkerPositionFn);\n    markerSwipeScaleInAnimation(this, animationManager, markerSelection);\n    seriesLabelFadeInAnimation(this, \"labels\", animationManager, labelSelection);\n  }\n  animateReadyResize(animationData) {\n    const { contextData, paths } = animationData;\n    this.updateAreaPaths(paths, contextData);\n    super.animateReadyResize(animationData);\n  }\n  animateWaitingUpdateReady(animationData) {\n    const { animationManager } = this.ctx;\n    const { markerSelection, labelSelection, contextData, paths, previousContextData } = animationData;\n    const [fill, stroke] = paths;\n    if (fill == null && stroke == null)\n      return;\n    this.resetMarkerAnimation(animationData);\n    this.resetLabelAnimation(animationData);\n    const update = () => {\n      this.resetPathAnimation(animationData);\n      this.updateAreaPaths(paths, contextData);\n    };\n    const skip = () => {\n      animationManager.skipCurrentBatch();\n      update();\n    };\n    if (contextData == null || previousContextData == null) {\n      update();\n      markerFadeInAnimation(this, animationManager, \"added\", markerSelection);\n      pathFadeInAnimation(this, \"fill_path_properties\", animationManager, \"add\", fill);\n      pathFadeInAnimation(this, \"stroke_path_properties\", animationManager, \"add\", stroke);\n      seriesLabelFadeInAnimation(this, \"labels\", animationManager, labelSelection);\n      return;\n    }\n    if (contextData.crossFiltering !== previousContextData.crossFiltering) {\n      skip();\n      return;\n    }\n    const fns = prepareAreaPathAnimation(contextData, previousContextData);\n    if (fns === void 0) {\n      skip();\n      return;\n    } else if (fns.status === \"no-op\") {\n      return;\n    }\n    markerFadeInAnimation(this, animationManager, void 0, markerSelection);\n    fromToMotion(this.id, \"fill_path_properties\", animationManager, [fill], fns.fill.pathProperties);\n    pathMotion(this.id, \"fill_path_update\", animationManager, [fill], fns.fill.path);\n    fromToMotion(this.id, \"stroke_path_properties\", animationManager, [stroke], fns.stroke.pathProperties);\n    pathMotion(this.id, \"stroke_path_update\", animationManager, [stroke], fns.stroke.path);\n    seriesLabelFadeInAnimation(this, \"labels\", animationManager, labelSelection);\n    this.ctx.animationManager.animate({\n      id: this.id,\n      groupId: \"reset_after_animation\",\n      phase: \"trailing\",\n      from: {},\n      to: {},\n      onComplete: () => this.updateAreaPaths(paths, contextData)\n    });\n  }\n  isLabelEnabled() {\n    return this.properties.label.enabled;\n  }\n  nodeFactory() {\n    return new Group();\n  }\n  getFormattedMarkerStyle(datum) {\n    const { xKey, yKey } = datum;\n    return this.getMarkerStyle(this.properties.marker, { datum, xKey, yKey, highlighted: true });\n  }\n  computeFocusBounds(opts) {\n    return computeMarkerFocusBounds(this, opts);\n  }\n};\nAreaSeries.className = \"AreaSeries\";\nAreaSeries.type = \"area\";\n\n// packages/ag-charts-community/src/chart/series/cartesian/areaSeriesModule.ts\nvar AreaSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  identifier: \"area\",\n  moduleFactory: (ctx) => new AreaSeries(ctx),\n  stackable: true,\n  tooltipDefaults: { range: \"nearest\" },\n  defaultAxes: [\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"left\" /* LEFT */\n    },\n    {\n      type: \"category\" /* CATEGORY */,\n      position: \"bottom\" /* BOTTOM */\n    }\n  ],\n  themeTemplate: {\n    series: {\n      nodeClickRange: \"nearest\",\n      tooltip: { position: { type: \"node\" } },\n      fillOpacity: 0.8,\n      strokeOpacity: 1,\n      strokeWidth: 0,\n      lineDash: [0],\n      lineDashOffset: 0,\n      shadow: {\n        enabled: false,\n        color: DEFAULT_SHADOW_COLOUR,\n        xOffset: 3,\n        yOffset: 3,\n        blur: 5\n      },\n      interpolation: {\n        type: \"linear\",\n        // @ts-expect-error - users shouldn't specify all options, but we have to for theming to work\n        tension: 1,\n        position: \"end\"\n      },\n      marker: {\n        enabled: false,\n        shape: \"circle\",\n        size: 7,\n        strokeWidth: 0\n      },\n      label: {\n        enabled: false,\n        fontSize: 12,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_LABEL_COLOUR\n      }\n    }\n  },\n  paletteFactory: (params) => {\n    const { marker } = markerPaletteFactory(params);\n    return { fill: marker.fill, stroke: marker.stroke, marker };\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/util.ts\nfunction swapAxisCondition(axes, swap) {\n  return (series) => {\n    if (!swap(series))\n      return axes;\n    return [\n      { ...axes[0], position: axes[1].position },\n      { ...axes[1], position: axes[0].position }\n    ];\n  };\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/quadtreeUtil.ts\nfunction addHitTestersToQuadtree(quadtree, hitTesters) {\n  for (const node of hitTesters) {\n    const datum = node.datum;\n    if (datum === void 0) {\n      Logger.error(\"undefined datum\");\n    } else {\n      quadtree.addValue(node, datum);\n    }\n  }\n}\nfunction findQuadtreeMatch(series, point) {\n  const { x, y } = point;\n  const { nearest, distanceSquared: distanceSquared3 } = series.getQuadTree().find(x, y);\n  if (nearest !== void 0) {\n    return { datum: nearest.value, distance: Math.sqrt(distanceSquared3) };\n  }\n  return void 0;\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/abstractBarSeries.ts\nvar AbstractBarSeriesProperties = class extends CartesianSeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.direction = \"vertical\";\n  }\n};\n__decorateClass([\n  Validate(DIRECTION)\n], AbstractBarSeriesProperties.prototype, \"direction\", 2);\nvar AbstractBarSeries = class extends CartesianSeries {\n  constructor() {\n    super(...arguments);\n    /**\n     * Used to get the position of bars within each group.\n     */\n    this.groupScale = new BandScale();\n    this.smallestDataInterval = void 0;\n    this.largestDataInterval = void 0;\n  }\n  padBandExtent(keys, alignStart) {\n    const ratio2 = typeof alignStart === \"boolean\" ? 1 : 0.5;\n    const scalePadding = isFiniteNumber(this.smallestDataInterval) ? this.smallestDataInterval * ratio2 : 0;\n    const keysExtent = extent(keys) ?? [NaN, NaN];\n    if (typeof alignStart === \"boolean\") {\n      keysExtent[alignStart ? 0 : 1] -= (alignStart ? 1 : -1) * scalePadding;\n    } else {\n      keysExtent[0] -= scalePadding;\n      keysExtent[1] += scalePadding;\n    }\n    return fixNumericExtent(keysExtent);\n  }\n  getBandScalePadding() {\n    return { inner: 0.3, outer: 0.15 };\n  }\n  shouldFlipXY() {\n    return !this.isVertical();\n  }\n  isVertical() {\n    return this.properties.direction === \"vertical\";\n  }\n  getBarDirection() {\n    return this.shouldFlipXY() ? \"x\" /* X */ : \"y\" /* Y */;\n  }\n  getCategoryDirection() {\n    return this.shouldFlipXY() ? \"y\" /* Y */ : \"x\" /* X */;\n  }\n  getValueAxis() {\n    const direction = this.getBarDirection();\n    return this.axes[direction];\n  }\n  getCategoryAxis() {\n    const direction = this.getCategoryDirection();\n    return this.axes[direction];\n  }\n  getBandwidth(xAxis) {\n    return ContinuousScale.is(xAxis.scale) ? xAxis.scale.calcBandwidth(this.smallestDataInterval) : xAxis.scale.bandwidth;\n  }\n  updateGroupScale(xAxis) {\n    const domain = [];\n    const { groupScale } = this;\n    const xBandWidth = this.getBandwidth(xAxis);\n    const { index: groupIndex, visibleGroupCount } = this.ctx.seriesStateManager.getVisiblePeerGroupIndex(this);\n    for (let groupIdx = 0; groupIdx < visibleGroupCount; groupIdx++) {\n      domain.push(String(groupIdx));\n    }\n    groupScale.domain = domain;\n    groupScale.range = [0, xBandWidth ?? 0];\n    if (xAxis instanceof CategoryAxis) {\n      groupScale.paddingInner = xAxis.groupPaddingInner;\n    } else if (xAxis instanceof GroupedCategoryAxis) {\n      groupScale.padding = 0.1;\n    } else {\n      groupScale.padding = 0;\n    }\n    groupScale.round = groupScale.padding !== 0;\n    const barWidth = groupScale.bandwidth >= 1 ? (\n      // Pixel-rounded value for low-volume bar charts.\n      groupScale.bandwidth\n    ) : (\n      // Handle high-volume bar charts gracefully.\n      groupScale.rawBandwidth\n    );\n    return { barWidth, groupIndex };\n  }\n  resolveKeyDirection(direction) {\n    if (this.getBarDirection() === \"x\" /* X */) {\n      if (direction === \"x\" /* X */) {\n        return \"y\" /* Y */;\n      }\n      return \"x\" /* X */;\n    }\n    return direction;\n  }\n  initQuadTree(quadtree) {\n    addHitTestersToQuadtree(quadtree, this.datumNodesIter());\n  }\n  pickNodeClosestDatum(point) {\n    return findQuadtreeMatch(this, point);\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/cartesian/barSeriesProperties.ts\nvar BarSeriesLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.placement = \"inside-center\";\n    this.padding = 0;\n  }\n};\n__decorateClass([\n  Validate(\n    UNION(\n      [\n        \"inside-center\",\n        \"inside-start\",\n        \"inside-end\",\n        \"outside-start\",\n        \"outside-end\",\n        // @todo(AG-5950) Deprecate\n        { value: \"inside\", deprecatedTo: \"inside-center\" },\n        { value: \"outside\", deprecatedTo: \"outside-end\" }\n      ],\n      \"a placement\"\n    )\n  )\n], BarSeriesLabel.prototype, \"placement\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], BarSeriesLabel.prototype, \"padding\", 2);\nvar BarSeriesProperties = class extends AbstractBarSeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.fill = \"#c16068\";\n    this.fillOpacity = 1;\n    this.stroke = \"#874349\";\n    this.strokeWidth = 1;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.cornerRadius = 0;\n    this.crisp = void 0;\n    this.shadow = new DropShadow();\n    this.label = new BarSeriesLabel();\n    this.tooltip = new SeriesTooltip();\n    this.sparklineMode = false;\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], BarSeriesProperties.prototype, \"xKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BarSeriesProperties.prototype, \"xName\", 2);\n__decorateClass([\n  Validate(STRING)\n], BarSeriesProperties.prototype, \"yKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BarSeriesProperties.prototype, \"yName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BarSeriesProperties.prototype, \"yFilterKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BarSeriesProperties.prototype, \"stackGroup\", 2);\n__decorateClass([\n  Validate(NUMBER, { optional: true })\n], BarSeriesProperties.prototype, \"normalizedTo\", 2);\n__decorateClass([\n  Validate(COLOR_STRING)\n], BarSeriesProperties.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO)\n], BarSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(COLOR_STRING)\n], BarSeriesProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], BarSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO)\n], BarSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH)\n], BarSeriesProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], BarSeriesProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], BarSeriesProperties.prototype, \"cornerRadius\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], BarSeriesProperties.prototype, \"crisp\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], BarSeriesProperties.prototype, \"itemStyler\", 2);\n__decorateClass([\n  Validate(OBJECT, { optional: true })\n], BarSeriesProperties.prototype, \"shadow\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], BarSeriesProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], BarSeriesProperties.prototype, \"tooltip\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], BarSeriesProperties.prototype, \"sparklineMode\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/barUtil.ts\nfunction updateRect(rect, config) {\n  rect.crisp = config.crisp ?? true;\n  rect.fill = config.fill;\n  rect.stroke = config.stroke;\n  rect.strokeWidth = config.strokeWidth;\n  rect.fillOpacity = config.fillOpacity;\n  rect.strokeOpacity = config.strokeOpacity;\n  rect.lineDash = config.lineDash;\n  rect.lineDashOffset = config.lineDashOffset;\n  rect.fillShadow = config.fillShadow;\n  rect.topLeftCornerRadius = config.topLeftCornerRadius !== false ? config.cornerRadius ?? 0 : 0;\n  rect.topRightCornerRadius = config.topRightCornerRadius !== false ? config.cornerRadius ?? 0 : 0;\n  rect.bottomRightCornerRadius = config.bottomRightCornerRadius !== false ? config.cornerRadius ?? 0 : 0;\n  rect.bottomLeftCornerRadius = config.bottomLeftCornerRadius !== false ? config.cornerRadius ?? 0 : 0;\n  rect.visible = config.visible ?? true;\n}\nfunction getRectConfig({\n  datum,\n  isHighlighted,\n  style,\n  highlightStyle,\n  itemStyler,\n  seriesId,\n  ctx: { callbackCache },\n  ...opts\n}) {\n  const {\n    fill,\n    fillOpacity,\n    stroke,\n    strokeWidth,\n    strokeOpacity,\n    lineDash,\n    lineDashOffset,\n    cornerRadius = 0\n  } = mergeDefaults(isHighlighted && highlightStyle, style);\n  let format;\n  if (itemStyler) {\n    format = callbackCache.call(itemStyler, {\n      datum: datum.datum,\n      xKey: datum.xKey,\n      fill,\n      fillOpacity,\n      stroke,\n      strokeWidth,\n      strokeOpacity,\n      lineDash,\n      lineDashOffset,\n      cornerRadius,\n      highlighted: isHighlighted,\n      seriesId,\n      ...opts\n    });\n  }\n  return {\n    fill: format?.fill ?? fill,\n    fillOpacity: format?.fillOpacity ?? fillOpacity,\n    stroke: format?.stroke ?? stroke,\n    strokeWidth: format?.strokeWidth ?? strokeWidth,\n    strokeOpacity: format?.strokeOpacity ?? strokeOpacity,\n    lineDash: format?.lineDash ?? lineDash,\n    lineDashOffset: format?.lineDashOffset ?? lineDashOffset,\n    cornerRadius: format?.cornerRadius ?? cornerRadius,\n    topLeftCornerRadius: style.topLeftCornerRadius,\n    topRightCornerRadius: style.topRightCornerRadius,\n    bottomRightCornerRadius: style.bottomRightCornerRadius,\n    bottomLeftCornerRadius: style.bottomLeftCornerRadius,\n    fillShadow: style.fillShadow\n  };\n}\nfunction checkCrisp(scale2, visibleRange, smallestDataInterval, largestDataInterval) {\n  if (visibleRange != null) {\n    const [visibleMin, visibleMax] = visibleRange;\n    const isZoomed = visibleMin !== 0 || visibleMax !== 1;\n    if (isZoomed)\n      return false;\n  }\n  if (ContinuousScale.is(scale2)) {\n    const spacing = scale2.calcBandwidth(largestDataInterval) - scale2.calcBandwidth(smallestDataInterval);\n    if (spacing > 0 && spacing < 1)\n      return false;\n  }\n  return true;\n}\nvar isDatumNegative = (datum) => {\n  return isNegative(datum.yValue ?? 0);\n};\nfunction collapsedStartingBarPosition(isVertical, axes, mode) {\n  const { startingX, startingY } = getStartingValues(isVertical, axes);\n  const calculate = (datum, prevDatum) => {\n    let x = isVertical ? datum.x : startingX;\n    let y = isVertical ? startingY : datum.y;\n    let width2 = isVertical ? datum.width : 0;\n    let height2 = isVertical ? 0 : datum.height;\n    const { opacity } = datum;\n    if (prevDatum && (isNaN(x) || isNaN(y))) {\n      ({ x, y } = prevDatum);\n      width2 = isVertical ? prevDatum.width : 0;\n      height2 = isVertical ? 0 : prevDatum.height;\n      if (isVertical && !isDatumNegative(prevDatum)) {\n        y += prevDatum.height;\n      } else if (!isVertical && isDatumNegative(prevDatum)) {\n        x += prevDatum.width;\n      }\n    }\n    let clipBBox;\n    if (datum.clipBBox == null) {\n      clipBBox = void 0;\n    } else if (isDatumNegative(datum)) {\n      clipBBox = isVertical ? new BBox(x, y - height2, width2, height2) : new BBox(x - width2, y, width2, height2);\n    } else {\n      clipBBox = new BBox(x, y, width2, height2);\n    }\n    return { x, y, width: width2, height: height2, clipBBox, opacity };\n  };\n  return { isVertical, calculate, mode };\n}\nfunction midpointStartingBarPosition(isVertical, mode) {\n  return {\n    isVertical,\n    calculate: (datum) => {\n      return {\n        x: isVertical ? datum.x : datum.x + datum.width / 2,\n        y: isVertical ? datum.y + datum.height / 2 : datum.y,\n        width: isVertical ? datum.width : 0,\n        height: isVertical ? 0 : datum.height,\n        clipBBox: datum.clipBBox,\n        opacity: datum.opacity\n      };\n    },\n    mode\n  };\n}\nfunction prepareBarAnimationFunctions(initPos) {\n  const isRemoved = (datum) => datum == null || isNaN(datum.x) || isNaN(datum.y);\n  const fromFn = (rect, datum, status) => {\n    if (status === \"updated\" && isRemoved(datum)) {\n      status = \"removed\";\n    } else if (status === \"updated\" && isRemoved(rect.previousDatum)) {\n      status = \"added\";\n    }\n    let source;\n    if (status === \"added\" && rect.previousDatum == null && initPos.mode === \"fade\") {\n      source = { ...resetBarSelectionsFn(rect, datum), opacity: 0 };\n    } else if (status === \"unknown\" || status === \"added\") {\n      source = initPos.calculate(datum, rect.previousDatum);\n    } else {\n      source = {\n        x: rect.x,\n        y: rect.y,\n        width: rect.width,\n        height: rect.height,\n        clipBBox: rect.clipBBox,\n        opacity: rect.opacity\n      };\n    }\n    const phase = NODE_UPDATE_STATE_TO_PHASE_MAPPING[status];\n    return { ...source, phase };\n  };\n  const toFn = (rect, datum, status) => {\n    let source;\n    if (status === \"removed\" && rect.datum == null && initPos.mode === \"fade\") {\n      source = { ...resetBarSelectionsFn(rect, datum), opacity: 0 };\n    } else if (status === \"removed\" || isRemoved(datum)) {\n      source = initPos.calculate(datum, rect.previousDatum);\n    } else {\n      source = {\n        x: datum.x,\n        y: datum.y,\n        width: datum.width,\n        height: datum.height,\n        clipBBox: datum.clipBBox,\n        opacity: datum.opacity\n      };\n    }\n    return source;\n  };\n  return { toFn, fromFn };\n}\nfunction getStartingValues(isVertical, axes) {\n  const axis = axes[isVertical ? \"y\" /* Y */ : \"x\" /* X */];\n  let startingX = Infinity;\n  let startingY = 0;\n  if (!axis) {\n    return { startingX, startingY };\n  }\n  if (isVertical) {\n    startingY = axis.scale.convert(ContinuousScale.is(axis.scale) ? 0 : Math.max(...axis.range));\n  } else {\n    startingX = axis.scale.convert(ContinuousScale.is(axis.scale) ? 0 : Math.min(...axis.range));\n  }\n  return { startingX, startingY };\n}\nfunction resetBarSelectionsFn(_node, { x, y, width: width2, height: height2, clipBBox, opacity }) {\n  return { x, y, width: width2, height: height2, clipBBox, opacity };\n}\nfunction computeBarFocusBounds(datum, barGroup, seriesRect) {\n  if (datum === void 0)\n    return void 0;\n  const { x, y, width: width2, height: height2 } = datum;\n  return Transformable.toCanvas(barGroup, new BBox(x, y, width2, height2)).clip(seriesRect);\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/labelUtil.ts\nfunction updateLabelNode(textNode, label, labelDatum) {\n  if (label.enabled && labelDatum) {\n    const { x, y, text, textAlign, textBaseline } = labelDatum;\n    const { color: fill, fontStyle, fontWeight, fontSize, fontFamily } = label;\n    textNode.setProperties({\n      visible: true,\n      x,\n      y,\n      text,\n      fill,\n      fontStyle,\n      fontWeight,\n      fontSize,\n      fontFamily,\n      textAlign,\n      textBaseline\n    });\n  } else {\n    textNode.visible = false;\n  }\n}\nvar placements = {\n  \"inside-start\": { inside: true, direction: -1, textAlignment: 1 },\n  \"inside-end\": { inside: true, direction: 1, textAlignment: -1 },\n  \"outside-start\": { inside: false, direction: -1, textAlignment: -1 },\n  \"outside-end\": { inside: false, direction: 1, textAlignment: 1 }\n};\nfunction adjustLabelPlacement({\n  isUpward,\n  isVertical,\n  placement,\n  padding = 0,\n  rect\n}) {\n  let x = rect.x + rect.width / 2;\n  let y = rect.y + rect.height / 2;\n  let textAlign = \"center\";\n  let textBaseline = \"middle\";\n  if (placement !== \"inside-center\") {\n    const barDirection = (isUpward ? 1 : -1) * (isVertical ? -1 : 1);\n    const { direction, textAlignment } = placements[placement];\n    const displacementRatio = (direction + 1) * 0.5;\n    if (isVertical) {\n      const y0 = isUpward ? rect.y + rect.height : rect.y;\n      const height2 = rect.height * barDirection;\n      y = y0 + height2 * displacementRatio + padding * textAlignment * barDirection;\n      textBaseline = textAlignment === barDirection ? \"top\" : \"bottom\";\n    } else {\n      const x0 = isUpward ? rect.x : rect.x + rect.width;\n      const width2 = rect.width * barDirection;\n      x = x0 + width2 * displacementRatio + padding * textAlignment * barDirection;\n      textAlign = textAlignment === barDirection ? \"left\" : \"right\";\n    }\n  }\n  return { x, y, textAlign, textBaseline };\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/barSeries.ts\nvar labelPlacements2 = {\n  \"inside-center\": \"inside-center\",\n  \"inside-start\": \"inside-start\",\n  \"inside-end\": \"inside-end\",\n  \"outside-start\": \"outside-start\",\n  \"outside-end\": \"outside-end\",\n  inside: \"inside-center\",\n  outside: \"outside-end\"\n};\nvar BarSeries = class extends AbstractBarSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,\n      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,\n      pickModes: [\n        2 /* AXIS_ALIGNED */,\n        // Only used in sparklineMode\n        1 /* NEAREST_NODE */,\n        0 /* EXACT_SHAPE_MATCH */\n      ],\n      pathsPerSeries: [],\n      hasHighlightedLabels: true,\n      datumSelectionGarbageCollection: false,\n      animationAlwaysUpdateSelections: true,\n      animationResetFns: {\n        datum: resetBarSelectionsFn,\n        label: resetLabelFn\n      }\n    });\n    this.properties = new BarSeriesProperties();\n  }\n  get pickModeAxis() {\n    return this.properties.sparklineMode ? \"main\" : void 0;\n  }\n  crossFilteringEnabled() {\n    return this.properties.yFilterKey != null && (this.seriesGrouping == null || this.seriesGrouping.stackIndex === 0);\n  }\n  async processData(dataController) {\n    if (!this.properties.isValid() || !this.data) {\n      return;\n    }\n    const { seriesGrouping: { groupIndex = this.id } = {}, data = [] } = this;\n    const { xKey, yKey, yFilterKey, normalizedTo } = this.properties;\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    const xScale = this.getCategoryAxis()?.scale;\n    const yScale = this.getValueAxis()?.scale;\n    const { isContinuousX, xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });\n    const stackGroupName = `bar-stack-${groupIndex}-yValues`;\n    const stackGroupTrailingName = `${stackGroupName}-trailing`;\n    const extraProps = [];\n    if (isFiniteNumber(normalizedTo)) {\n      extraProps.push(\n        normaliseGroupTo([stackGroupName, stackGroupTrailingName], Math.abs(normalizedTo), \"range\")\n      );\n    }\n    if (animationEnabled && this.processedData) {\n      extraProps.push(diff(this.processedData));\n    }\n    if (animationEnabled) {\n      extraProps.push(animationValidation());\n    }\n    const visibleProps = this.visible ? {} : { forceValue: 0 };\n    const { processedData } = await this.requestDataModel(dataController, data, {\n      props: [\n        keyProperty(xKey, xScaleType, { id: \"xValue\" }),\n        valueProperty(yKey, yScaleType, { id: `yValue-raw`, invalidValue: null, ...visibleProps }),\n        ...this.crossFilteringEnabled() ? [\n          valueProperty(yFilterKey, yScaleType, {\n            id: `yFilterValue`,\n            invalidValue: null,\n            ...visibleProps\n          })\n        ] : [],\n        ...groupAccumulativeValueProperty(\n          yKey,\n          \"normal\",\n          \"current\",\n          {\n            id: `yValue-end`,\n            rangeId: `yValue-range`,\n            invalidValue: null,\n            missingValue: 0,\n            groupId: stackGroupName,\n            separateNegative: true,\n            ...visibleProps\n          },\n          yScaleType\n        ),\n        ...groupAccumulativeValueProperty(\n          yKey,\n          \"trailing\",\n          \"current\",\n          {\n            id: `yValue-start`,\n            invalidValue: null,\n            missingValue: 0,\n            groupId: stackGroupTrailingName,\n            separateNegative: true,\n            ...visibleProps\n          },\n          yScaleType\n        ),\n        ...isContinuousX ? [SMALLEST_KEY_INTERVAL, LARGEST_KEY_INTERVAL] : [],\n        ...extraProps\n      ],\n      groupByKeys: true,\n      groupByData: false\n    });\n    this.smallestDataInterval = processedData.reduced?.smallestKeyInterval;\n    this.largestDataInterval = processedData.reduced?.largestKeyInterval;\n    this.animationState.transition(\"updateData\");\n  }\n  getSeriesDomain(direction) {\n    const { processedData, dataModel } = this;\n    if (!dataModel || !processedData?.data.length)\n      return [];\n    const keyDef = dataModel.resolveProcessedDataDefById(this, `xValue`);\n    const keys = dataModel.getDomain(this, `xValue`, \"key\", processedData);\n    let yExtent = dataModel.getDomain(this, `yValue-end`, \"value\", processedData);\n    const yFilterExtent = this.crossFilteringEnabled() ? dataModel.getDomain(this, `yFilterValue`, \"value\", processedData) : void 0;\n    if (yFilterExtent != null) {\n      yExtent = [Math.min(yExtent[0], yFilterExtent[0]), Math.max(yExtent[1], yFilterExtent[1])];\n    }\n    if (direction === this.getCategoryDirection()) {\n      if (keyDef?.def.type === \"key\" && keyDef.def.valueType === \"category\") {\n        return keys;\n      }\n      return this.padBandExtent(keys);\n    } else if (this.getValueAxis() instanceof LogAxis) {\n      return fixNumericExtent(yExtent);\n    } else {\n      const fixedYExtent = [Math.min(0, yExtent[0]), Math.max(0, yExtent[1])];\n      return fixNumericExtent(fixedYExtent);\n    }\n  }\n  async createNodeData() {\n    const { dataModel } = this;\n    const xAxis = this.getCategoryAxis();\n    const yAxis = this.getValueAxis();\n    if (!dataModel || !xAxis || !yAxis || !this.properties.isValid())\n      return;\n    const xScale = xAxis.scale;\n    const yScale = yAxis.scale;\n    const { xKey, yKey, xName, yName, fill, stroke, strokeWidth, cornerRadius, legendItemName, label } = this.properties;\n    const yReversed = yAxis.isReversed();\n    const { barWidth, groupIndex } = this.updateGroupScale(xAxis);\n    const barOffset = ContinuousScale.is(xScale) ? barWidth * -0.5 : 0;\n    const xIndex = dataModel.resolveProcessedDataIndexById(this, `xValue`);\n    const yRawIndex = dataModel.resolveProcessedDataIndexById(this, `yValue-raw`);\n    const yFilterIndex = this.crossFilteringEnabled() ? dataModel.resolveProcessedDataIndexById(this, `yFilterValue`) : void 0;\n    const yStartIndex = dataModel.resolveProcessedDataIndexById(this, `yValue-start`);\n    const yEndIndex = dataModel.resolveProcessedDataIndexById(this, `yValue-end`);\n    const yRangeIndex = dataModel.resolveProcessedDataIndexById(this, `yValue-range`);\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    const nodeDatum = ({\n      datum,\n      valueIndex,\n      xValue,\n      yValue,\n      cumulativeValue,\n      phantom,\n      currY,\n      prevY,\n      isPositive,\n      yRange,\n      labelText,\n      crossScale = 1\n    }) => {\n      const x = xScale.convert(xValue);\n      const isUpward = isPositive !== yReversed;\n      const barX = x + groupScale.convert(String(groupIndex)) + barOffset;\n      const y = yScale.convert(currY);\n      const bottomY = yScale.convert(prevY);\n      const barAlongX = this.getBarDirection() === \"x\" /* X */;\n      const bboxHeight = yScale.convert(yRange);\n      const bboxBottom = yScale.convert(0);\n      const xOffset = barWidth * 0.5 * (1 - crossScale);\n      const rect = {\n        x: barAlongX ? Math.min(y, bottomY) : barX + xOffset,\n        y: barAlongX ? barX + xOffset : Math.min(y, bottomY),\n        width: barAlongX ? Math.abs(bottomY - y) : barWidth * crossScale,\n        height: barAlongX ? barWidth * crossScale : Math.abs(bottomY - y)\n      };\n      const clipBBox = new BBox(rect.x, rect.y, rect.width, rect.height);\n      const barRect = {\n        x: barAlongX ? Math.min(bboxBottom, bboxHeight) : barX + xOffset,\n        y: barAlongX ? barX + xOffset : Math.min(bboxBottom, bboxHeight),\n        width: barAlongX ? Math.abs(bboxBottom - bboxHeight) : barWidth * crossScale,\n        height: barAlongX ? barWidth * crossScale : Math.abs(bboxBottom - bboxHeight)\n      };\n      const lengthRatioMultiplier = this.shouldFlipXY() ? rect.height : rect.width;\n      return {\n        series: this,\n        itemId: phantom ? createDatumId(yKey, phantom) : yKey,\n        datum,\n        valueIndex,\n        cumulativeValue,\n        phantom,\n        xValue,\n        yValue,\n        yKey,\n        xKey,\n        capDefaults: {\n          lengthRatioMultiplier,\n          lengthMax: lengthRatioMultiplier\n        },\n        x: barRect.x,\n        y: barRect.y,\n        width: barRect.width,\n        height: barRect.height,\n        midPoint: { x: rect.x + rect.width / 2, y: rect.y + rect.height / 2 },\n        fill,\n        stroke,\n        opacity: 1,\n        strokeWidth,\n        cornerRadius,\n        topLeftCornerRadius: barAlongX !== isUpward,\n        topRightCornerRadius: isUpward,\n        bottomRightCornerRadius: barAlongX === isUpward,\n        bottomLeftCornerRadius: !isUpward,\n        clipBBox,\n        label: labelText != null ? {\n          text: labelText,\n          ...adjustLabelPlacement({\n            isUpward,\n            isVertical: !barAlongX,\n            placement: labelPlacements2[label.placement],\n            padding: label.padding,\n            rect\n          })\n        } : void 0,\n        missing: yValue == null,\n        focusable: !phantom\n      };\n    };\n    const { groupScale, processedData } = this;\n    const phantomNodes = [];\n    const nodes = [];\n    const labels = [];\n    processedData?.data.forEach(({ keys, datum: seriesDatum, values, aggValues }) => {\n      values.forEach((value, valueIndex) => {\n        const xValue = keys[xIndex];\n        const yRawValue = value[yRawIndex];\n        const yStart = Number(value[yStartIndex]);\n        const yFilterValue = yFilterIndex != null ? Number(value[yFilterIndex]) : void 0;\n        const yEnd = Number(value[yEndIndex]);\n        const isPositive = yRawValue >= 0 && !Object.is(yRawValue, -0);\n        const yRange = aggValues?.[yRangeIndex][isPositive ? 1 : 0] ?? 0;\n        if (!Number.isFinite(yEnd))\n          return;\n        if (yFilterValue != null && !Number.isFinite(yFilterValue))\n          return;\n        const labelText = yRawValue != null ? this.getLabelText(\n          this.properties.label,\n          {\n            datum: seriesDatum[valueIndex],\n            value: yFilterValue ?? yRawValue,\n            xKey,\n            yKey,\n            xName,\n            yName,\n            legendItemName\n          },\n          formatValue\n        ) : void 0;\n        const inset = yFilterValue != null && yFilterValue > yRawValue;\n        const nodeData = nodeDatum({\n          datum: seriesDatum[valueIndex],\n          valueIndex,\n          xValue,\n          yValue: yFilterValue ?? yRawValue,\n          cumulativeValue: yFilterValue ?? yEnd,\n          phantom: false,\n          currY: yFilterValue != null ? yStart + yFilterValue : yEnd,\n          prevY: yStart,\n          isPositive,\n          yRange: Math.max(yStart + (yFilterValue ?? -Infinity), yRange),\n          labelText,\n          crossScale: inset ? 0.6 : void 0\n        });\n        nodes.push(nodeData);\n        labels.push(nodeData);\n        if (yFilterValue != null) {\n          const phantomNodeData = nodeDatum({\n            datum: seriesDatum[valueIndex],\n            valueIndex,\n            xValue,\n            yValue: yFilterValue,\n            cumulativeValue: yFilterValue,\n            phantom: true,\n            currY: yEnd,\n            prevY: yStart,\n            isPositive,\n            yRange,\n            labelText: void 0,\n            crossScale: void 0\n          });\n          phantomNodes.push(phantomNodeData);\n        }\n      });\n    });\n    return {\n      itemId: yKey,\n      nodeData: phantomNodes.length > 0 ? [...phantomNodes, ...nodes] : nodes,\n      labelData: labels,\n      scales: this.calculateScaling(),\n      visible: this.visible || animationEnabled\n    };\n  }\n  nodeFactory() {\n    return new Rect();\n  }\n  getHighlightData(nodeData, highlightedItem) {\n    const highlightItem = nodeData.find(\n      (nodeDatum) => nodeDatum.datum === highlightedItem.datum && !nodeDatum.phantom\n    );\n    return highlightItem != null ? [highlightItem] : void 0;\n  }\n  async updateDatumSelection(opts) {\n    return opts.datumSelection.update(\n      opts.nodeData,\n      void 0,\n      (datum) => createDatumId(datum.xValue, datum.valueIndex, datum.phantom)\n    );\n  }\n  async updateDatumNodes(opts) {\n    if (!this.properties.isValid()) {\n      return;\n    }\n    const {\n      yKey,\n      stackGroup,\n      fill,\n      fillOpacity,\n      stroke,\n      strokeWidth,\n      strokeOpacity,\n      lineDash,\n      lineDashOffset,\n      itemStyler,\n      shadow,\n      highlightStyle: { item: itemHighlightStyle }\n    } = this.properties;\n    const xAxis = this.axes[\"x\" /* X */];\n    const crisp = this.properties.crisp ?? checkCrisp(xAxis?.scale, xAxis?.visibleRange, this.smallestDataInterval, this.largestDataInterval);\n    const categoryAlongX = this.getCategoryDirection() === \"x\" /* X */;\n    const style = {\n      fill,\n      stroke,\n      lineDash,\n      lineDashOffset,\n      fillShadow: shadow,\n      strokeWidth: this.getStrokeWidth(strokeWidth),\n      fillOpacity: 0,\n      strokeOpacity: 0\n    };\n    const rectParams = {\n      datum: void 0,\n      ctx: this.ctx,\n      seriesId: this.id,\n      isHighlighted: opts.isHighlight,\n      highlightStyle: itemHighlightStyle,\n      yKey,\n      style,\n      itemStyler,\n      stackGroup\n    };\n    opts.datumSelection.each((rect, datum) => {\n      style.fillOpacity = fillOpacity * (datum.phantom ? 0.2 : 1);\n      style.strokeOpacity = strokeOpacity * (datum.phantom ? 0.2 : 1);\n      style.cornerRadius = datum.cornerRadius;\n      style.topLeftCornerRadius = datum.topLeftCornerRadius;\n      style.topRightCornerRadius = datum.topRightCornerRadius;\n      style.bottomRightCornerRadius = datum.bottomRightCornerRadius;\n      style.bottomLeftCornerRadius = datum.bottomLeftCornerRadius;\n      const visible = categoryAlongX ? (datum.clipBBox?.width ?? datum.width) > 0 : (datum.clipBBox?.height ?? datum.height) > 0;\n      rectParams.datum = datum;\n      const config = getRectConfig(rectParams);\n      config.crisp = crisp;\n      config.visible = visible;\n      updateRect(rect, config);\n    });\n  }\n  async updateLabelSelection(opts) {\n    const data = this.isLabelEnabled() ? opts.labelData : [];\n    return opts.labelSelection.update(data, (text) => {\n      text.pointerEvents = 1 /* None */;\n    });\n  }\n  async updateLabelNodes(opts) {\n    opts.labelSelection.each((textNode, datum) => {\n      updateLabelNode(textNode, this.properties.label, datum.label);\n    });\n  }\n  getTooltipHtml(nodeDatum) {\n    const {\n      id: seriesId,\n      processedData,\n      ctx: { callbackCache }\n    } = this;\n    const xAxis = this.getCategoryAxis();\n    const yAxis = this.getValueAxis();\n    if (!processedData || !this.properties.isValid() || !xAxis || !yAxis) {\n      return EMPTY_TOOLTIP_CONTENT;\n    }\n    const { xKey, yKey, xName, yName, fill, stroke, strokeWidth, tooltip, itemStyler, stackGroup, legendItemName } = this.properties;\n    const { xValue, yValue, datum, itemId } = nodeDatum;\n    const xString = xAxis.formatDatum(xValue);\n    const yString = yAxis.formatDatum(yValue);\n    const title = sanitizeHtml(yName);\n    const content = sanitizeHtml(xString + \": \" + yString);\n    let format;\n    if (itemStyler) {\n      format = callbackCache.call(itemStyler, {\n        seriesId,\n        datum,\n        xKey,\n        yKey,\n        stackGroup,\n        fill,\n        stroke,\n        strokeWidth: this.getStrokeWidth(strokeWidth),\n        highlighted: false,\n        cornerRadius: this.properties.cornerRadius,\n        fillOpacity: this.properties.fillOpacity,\n        strokeOpacity: this.properties.strokeOpacity,\n        lineDash: this.properties.lineDash ?? [],\n        lineDashOffset: this.properties.lineDashOffset\n      });\n    }\n    const color = format?.fill ?? fill;\n    return tooltip.toTooltipHtml(\n      { title, content, backgroundColor: color },\n      {\n        seriesId,\n        itemId,\n        datum,\n        xKey,\n        yKey,\n        xName,\n        yName,\n        stackGroup,\n        title,\n        color,\n        legendItemName,\n        ...this.getModuleTooltipParams()\n      }\n    );\n  }\n  getLegendData(legendType) {\n    const { showInLegend } = this.properties;\n    if (legendType !== \"category\" || !this.data?.length || !this.properties.isValid() || !showInLegend) {\n      return [];\n    }\n    const { yKey, yName, fill, stroke, strokeWidth, fillOpacity, strokeOpacity, legendItemName, visible } = this.properties;\n    return [\n      {\n        legendType: \"category\",\n        id: this.id,\n        itemId: yKey,\n        seriesId: this.id,\n        enabled: visible,\n        label: { text: legendItemName ?? yName ?? yKey },\n        symbols: [{ marker: { fill, fillOpacity, stroke, strokeWidth, strokeOpacity } }],\n        legendItemName\n      }\n    ];\n  }\n  animateEmptyUpdateReady({ datumSelection, labelSelection, annotationSelections }) {\n    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(this.isVertical(), this.axes, \"normal\"));\n    fromToMotion(this.id, \"nodes\", this.ctx.animationManager, [datumSelection], fns);\n    seriesLabelFadeInAnimation(this, \"labels\", this.ctx.animationManager, labelSelection);\n    seriesLabelFadeInAnimation(this, \"annotations\", this.ctx.animationManager, ...annotationSelections);\n  }\n  animateWaitingUpdateReady(data) {\n    const { datumSelection, labelSelection, annotationSelections, previousContextData } = data;\n    this.ctx.animationManager.stopByAnimationGroupId(this.id);\n    const dataDiff = this.processedData?.reduced?.diff;\n    const mode = previousContextData == null ? \"fade\" : \"normal\";\n    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(this.isVertical(), this.axes, mode));\n    fromToMotion(\n      this.id,\n      \"nodes\",\n      this.ctx.animationManager,\n      [datumSelection],\n      fns,\n      (_, datum) => createDatumId(datum.xValue, datum.valueIndex, datum.phantom),\n      dataDiff\n    );\n    const hasMotion = dataDiff?.changed ?? true;\n    if (hasMotion) {\n      seriesLabelFadeInAnimation(this, \"labels\", this.ctx.animationManager, labelSelection);\n      seriesLabelFadeInAnimation(this, \"annotations\", this.ctx.animationManager, ...annotationSelections);\n    }\n  }\n  isLabelEnabled() {\n    return this.properties.label.enabled;\n  }\n  computeFocusBounds({ datumIndex, seriesRect }) {\n    const datumBox = this.contextNodeData?.nodeData[datumIndex].clipBBox;\n    return computeBarFocusBounds(datumBox, this.contentGroup, seriesRect);\n  }\n};\nBarSeries.className = \"BarSeries\";\nBarSeries.type = \"bar\";\n\n// packages/ag-charts-community/src/chart/series/cartesian/barSeriesModule.ts\nvar BarSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  identifier: \"bar\",\n  moduleFactory: (ctx) => new BarSeries(ctx),\n  stackable: true,\n  groupable: true,\n  tooltipDefaults: { range: \"exact\" },\n  defaultAxes: swapAxisCondition(\n    [\n      { type: \"number\" /* NUMBER */, position: \"left\" /* LEFT */ },\n      { type: \"category\" /* CATEGORY */, position: \"bottom\" /* BOTTOM */ }\n    ],\n    (series) => series?.direction === \"horizontal\"\n  ),\n  themeTemplate: {\n    series: {\n      direction: \"vertical\",\n      fillOpacity: 1,\n      strokeWidth: 0,\n      lineDash: [0],\n      lineDashOffset: 0,\n      label: {\n        enabled: false,\n        fontWeight: \"normal\" /* NORMAL */,\n        fontSize: 12,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR,\n        placement: \"inside-center\"\n      },\n      shadow: {\n        enabled: false,\n        color: DEFAULT_SHADOW_COLOUR,\n        xOffset: 3,\n        yOffset: 3,\n        blur: 5\n      },\n      errorBar: {\n        cap: {\n          lengthRatio: 0.3\n        }\n      }\n    }\n  },\n  paletteFactory: singleSeriesPaletteFactory\n};\n\n// packages/ag-charts-community/src/chart/series/cartesian/bubbleSeriesProperties.ts\nvar BubbleSeriesMarker = class extends SeriesMarker {\n  constructor() {\n    super(...arguments);\n    this.maxSize = 30;\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], BubbleSeriesMarker.prototype, \"maxSize\", 2);\n__decorateClass([\n  Validate(NUMBER_ARRAY, { optional: true }),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], BubbleSeriesMarker.prototype, \"domain\", 2);\nvar BubbleSeriesLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.placement = \"top\";\n  }\n};\n__decorateClass([\n  Validate(LABEL_PLACEMENT)\n], BubbleSeriesLabel.prototype, \"placement\", 2);\nvar BubbleSeriesProperties = class extends CartesianSeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.colorRange = [\"#ffff00\", \"#00ff00\", \"#0000ff\"];\n    this.label = new BubbleSeriesLabel();\n    this.tooltip = new SeriesTooltip();\n    // No validation. Not a part of the options contract.\n    this.marker = new BubbleSeriesMarker();\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], BubbleSeriesProperties.prototype, \"xKey\", 2);\n__decorateClass([\n  Validate(STRING)\n], BubbleSeriesProperties.prototype, \"yKey\", 2);\n__decorateClass([\n  Validate(STRING)\n], BubbleSeriesProperties.prototype, \"sizeKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"labelKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"colorKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"xFilterKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"yFilterKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"sizeFilterKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"xName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"yName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"sizeName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"labelName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"colorName\", 2);\n__decorateClass([\n  Validate(NUMBER_ARRAY, { optional: true })\n], BubbleSeriesProperties.prototype, \"colorDomain\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], BubbleSeriesProperties.prototype, \"colorRange\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"title\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.shape\")\n], BubbleSeriesProperties.prototype, \"shape\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.size\")\n], BubbleSeriesProperties.prototype, \"size\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.maxSize\")\n], BubbleSeriesProperties.prototype, \"maxSize\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.domain\", { optional: true })\n], BubbleSeriesProperties.prototype, \"domain\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.fill\", { optional: true })\n], BubbleSeriesProperties.prototype, \"fill\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.fillOpacity\")\n], BubbleSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.stroke\", { optional: true })\n], BubbleSeriesProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.strokeWidth\")\n], BubbleSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.strokeOpacity\")\n], BubbleSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.itemStyler\", { optional: true })\n], BubbleSeriesProperties.prototype, \"itemStyler\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], BubbleSeriesProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], BubbleSeriesProperties.prototype, \"tooltip\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/bubbleSeries.ts\nvar BubbleSeriesNodeEvent = class extends CartesianSeriesNodeEvent {\n  constructor(type, nativeEvent, datum, series) {\n    super(type, nativeEvent, datum, series);\n    this.sizeKey = series.properties.sizeKey;\n  }\n};\nvar BubbleSeries = class extends CartesianSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,\n      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,\n      pickModes: [\n        2 /* AXIS_ALIGNED */,\n        1 /* NEAREST_NODE */,\n        0 /* EXACT_SHAPE_MATCH */\n      ],\n      pathsPerSeries: [],\n      hasMarkers: true,\n      markerSelectionGarbageCollection: false,\n      animationResetFns: {\n        label: resetLabelFn,\n        marker: resetMarkerFn\n      }\n    });\n    this.NodeEvent = BubbleSeriesNodeEvent;\n    this.properties = new BubbleSeriesProperties();\n    this.sizeScale = new LinearScale();\n    this.colorScale = new ColorScale();\n  }\n  get pickModeAxis() {\n    return \"main-category\";\n  }\n  async processData(dataController) {\n    if (!this.properties.isValid() || this.data == null || !this.visible)\n      return;\n    const xScale = this.axes[\"x\" /* X */]?.scale;\n    const yScale = this.axes[\"y\" /* Y */]?.scale;\n    const { xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });\n    const colorScaleType = this.colorScale.type;\n    const sizeScaleType = this.sizeScale.type;\n    const {\n      xKey,\n      yKey,\n      sizeKey,\n      xFilterKey,\n      yFilterKey,\n      sizeFilterKey,\n      labelKey,\n      colorDomain,\n      colorRange,\n      colorKey,\n      marker\n    } = this.properties;\n    const { dataModel, processedData } = await this.requestDataModel(dataController, this.data, {\n      props: [\n        valueProperty(xKey, xScaleType, { id: `xValue` }),\n        valueProperty(yKey, yScaleType, { id: `yValue` }),\n        ...xFilterKey != null ? [valueProperty(xFilterKey, xScaleType, { id: `xFilterValue` })] : [],\n        ...yFilterKey != null ? [valueProperty(yFilterKey, yScaleType, { id: `yFilterValue` })] : [],\n        ...sizeFilterKey != null ? [valueProperty(sizeFilterKey, sizeScaleType, { id: `sizeFilterValue` })] : [],\n        valueProperty(sizeKey, sizeScaleType, { id: `sizeValue` }),\n        ...colorKey ? [valueProperty(colorKey, colorScaleType, { id: `colorValue` })] : [],\n        ...labelKey ? [valueProperty(labelKey, \"band\", { id: `labelValue` })] : []\n      ]\n    });\n    const sizeKeyIdx = dataModel.resolveProcessedDataIndexById(this, `sizeValue`);\n    const processedSize = processedData.domain.values[sizeKeyIdx] ?? [];\n    this.sizeScale.domain = marker.domain ? marker.domain : processedSize;\n    if (colorKey) {\n      const colorKeyIdx = dataModel.resolveProcessedDataIndexById(this, `colorValue`);\n      this.colorScale.domain = colorDomain ?? processedData.domain.values[colorKeyIdx] ?? [];\n      this.colorScale.range = colorRange;\n      this.colorScale.update();\n    }\n    this.animationState.transition(\"updateData\");\n  }\n  getSeriesDomain(direction) {\n    const { dataModel, processedData } = this;\n    if (!processedData || !dataModel)\n      return [];\n    const id = direction === \"x\" /* X */ ? `xValue` : `yValue`;\n    const dataDef = dataModel.resolveProcessedDataDefById(this, id);\n    const domain = dataModel.getDomain(this, id, \"value\", processedData);\n    if (dataDef?.def.type === \"value\" && dataDef?.def.valueType === \"category\") {\n      return domain;\n    }\n    return fixNumericExtent(extent(domain));\n  }\n  async createNodeData() {\n    const { axes, dataModel, processedData, colorScale, sizeScale } = this;\n    const {\n      xKey,\n      yKey,\n      sizeKey,\n      xFilterKey,\n      yFilterKey,\n      sizeFilterKey,\n      labelKey,\n      xName,\n      yName,\n      sizeName,\n      labelName,\n      label,\n      colorKey,\n      marker,\n      visible\n    } = this.properties;\n    const markerShape = getMarker(marker.shape);\n    const { placement } = label;\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    if (!(dataModel && processedData && visible && xAxis && yAxis)) {\n      return;\n    }\n    const xDataIdx = dataModel.resolveProcessedDataIndexById(this, `xValue`);\n    const yDataIdx = dataModel.resolveProcessedDataIndexById(this, `yValue`);\n    const sizeDataIdx = sizeKey != null ? dataModel.resolveProcessedDataIndexById(this, `sizeValue`) : void 0;\n    const colorDataIdx = colorKey != null ? dataModel.resolveProcessedDataIndexById(this, `colorValue`) : -1;\n    const labelDataIdx = labelKey != null ? dataModel.resolveProcessedDataIndexById(this, `labelValue`) : -1;\n    const xFilterDataIdx = xFilterKey != null ? dataModel.resolveProcessedDataIndexById(this, `xFilterValue`) : void 0;\n    const yFilterDataIdx = yFilterKey != null ? dataModel.resolveProcessedDataIndexById(this, `yFilterValue`) : void 0;\n    const sizeFilterDataIdx = sizeFilterKey != null ? dataModel.resolveProcessedDataIndexById(this, `sizeFilterValue`) : void 0;\n    const xScale = xAxis.scale;\n    const yScale = yAxis.scale;\n    const xOffset = (xScale.bandwidth ?? 0) / 2;\n    const yOffset = (yScale.bandwidth ?? 0) / 2;\n    const nodeData = [];\n    sizeScale.range = [marker.size, marker.maxSize];\n    const font = label.getFont();\n    const textMeasurer = CachedTextMeasurerPool.getMeasurer({ font });\n    for (const { values, datum } of processedData.data ?? []) {\n      const xDatum = values[xDataIdx];\n      const yDatum = values[yDataIdx];\n      const sizeValue = sizeDataIdx != null ? values[sizeDataIdx] : void 0;\n      const x = xScale.convert(xDatum) + xOffset;\n      const y = yScale.convert(yDatum) + yOffset;\n      let selected;\n      if (xFilterDataIdx != null && yFilterDataIdx != null) {\n        selected = values[xFilterDataIdx] === xDatum && values[yFilterDataIdx] === yDatum;\n        if (sizeFilterDataIdx != null) {\n          selected && (selected = values[sizeFilterDataIdx] === sizeValue);\n        }\n      }\n      const labelText = this.getLabelText(label, {\n        value: labelKey ? values[labelDataIdx] : yDatum,\n        datum,\n        xKey,\n        yKey,\n        sizeKey,\n        labelKey,\n        xName,\n        yName,\n        sizeName,\n        labelName\n      });\n      const size = textMeasurer.measureText(String(labelText));\n      const markerSize = sizeValue ? sizeScale.convert(sizeValue) : marker.size;\n      const fill = colorKey ? colorScale.convert(values[colorDataIdx]) : void 0;\n      nodeData.push({\n        series: this,\n        itemId: yKey,\n        yKey,\n        xKey,\n        datum,\n        xValue: xDatum,\n        yValue: yDatum,\n        sizeValue,\n        point: { x, y, size: markerSize },\n        midPoint: { x, y },\n        fill,\n        label: { text: labelText, ...size },\n        marker: markerShape,\n        placement,\n        selected\n      });\n    }\n    return {\n      itemId: yKey,\n      nodeData,\n      labelData: nodeData,\n      scales: this.calculateScaling(),\n      visible: this.visible\n    };\n  }\n  isPathOrSelectionDirty() {\n    return this.properties.marker.isDirty();\n  }\n  getLabelData() {\n    return this.contextNodeData?.labelData ?? [];\n  }\n  markerFactory() {\n    const { shape } = this.properties.marker;\n    const MarkerShape = getMarker(shape);\n    return new MarkerShape();\n  }\n  async updateMarkerSelection(opts) {\n    const { nodeData, markerSelection } = opts;\n    if (this.properties.marker.isDirty()) {\n      markerSelection.clear();\n      markerSelection.cleanup();\n    }\n    const data = this.properties.marker.enabled ? nodeData : [];\n    return markerSelection.update(\n      data,\n      void 0,\n      (datum) => createDatumId([datum.xValue, datum.yValue, datum.label.text])\n    );\n  }\n  async updateMarkerNodes(opts) {\n    const { markerSelection, isHighlight: highlighted } = opts;\n    const { xKey, yKey, sizeKey, labelKey, marker } = this.properties;\n    const { size, shape, fill, fillOpacity, stroke, strokeWidth, strokeOpacity } = mergeDefaults(\n      highlighted && this.properties.highlightStyle.item,\n      marker.getStyle()\n    );\n    const baseStyle = { size, shape, fill, fillOpacity, stroke, strokeWidth, strokeOpacity };\n    this.sizeScale.range = [marker.size, marker.maxSize];\n    markerSelection.each((node, datum) => {\n      this.updateMarkerStyle(node, marker, { datum, highlighted, xKey, yKey, sizeKey, labelKey }, baseStyle, {\n        selected: datum.selected\n      });\n    });\n    if (!highlighted) {\n      this.properties.marker.markClean();\n    }\n  }\n  async updateLabelSelection(opts) {\n    const placedLabels = this.properties.label.enabled ? this.chart?.placeLabels().get(this) ?? [] : [];\n    return opts.labelSelection.update(\n      placedLabels.map((v) => ({\n        ...v.datum,\n        point: {\n          x: v.x,\n          y: v.y,\n          size: v.datum.point.size\n        }\n      }))\n    );\n  }\n  async updateLabelNodes(opts) {\n    const { label } = this.properties;\n    opts.labelSelection.each((text, datum) => {\n      text.text = datum.label.text;\n      text.fill = label.color;\n      text.x = datum.point?.x ?? 0;\n      text.y = datum.point?.y ?? 0;\n      text.fontStyle = label.fontStyle;\n      text.fontWeight = label.fontWeight;\n      text.fontSize = label.fontSize;\n      text.fontFamily = label.fontFamily;\n      text.textAlign = \"left\";\n      text.textBaseline = \"top\";\n    });\n  }\n  getTooltipHtml(nodeDatum) {\n    const xAxis = this.axes[\"x\" /* X */];\n    const yAxis = this.axes[\"y\" /* Y */];\n    if (!this.properties.isValid() || !xAxis || !yAxis) {\n      return EMPTY_TOOLTIP_CONTENT;\n    }\n    const { xKey, yKey, sizeKey, labelKey, xName, yName, sizeName, labelName, marker, tooltip } = this.properties;\n    const title = this.properties.title ?? yName;\n    const baseStyle = mergeDefaults(\n      { fill: nodeDatum.fill, strokeWidth: this.getStrokeWidth(marker.strokeWidth) },\n      marker.getStyle()\n    );\n    const { fill: color = \"gray\" } = this.getMarkerStyle(\n      marker,\n      { datum: nodeDatum, highlighted: false, xKey, yKey, sizeKey, labelKey },\n      baseStyle\n    );\n    const {\n      datum,\n      xValue,\n      yValue,\n      sizeValue,\n      label: { text: labelText },\n      itemId\n    } = nodeDatum;\n    const xString = sanitizeHtml(xAxis.formatDatum(xValue));\n    const yString = sanitizeHtml(yAxis.formatDatum(yValue));\n    let content = `<b>${sanitizeHtml(xName ?? xKey)}</b>: ${xString}<br><b>${sanitizeHtml(yName ?? yKey)}</b>: ${yString}`;\n    if (sizeKey) {\n      content += `<br><b>${sanitizeHtml(sizeName ?? sizeKey)}</b>: ${sanitizeHtml(String(sizeValue))}`;\n    }\n    if (labelKey) {\n      content = `<b>${sanitizeHtml(labelName ?? labelKey)}</b>: ${sanitizeHtml(labelText)}<br>` + content;\n    }\n    return tooltip.toTooltipHtml(\n      { title, content, backgroundColor: color },\n      {\n        datum,\n        itemId,\n        xKey,\n        xName,\n        yKey,\n        yName,\n        sizeKey,\n        sizeName,\n        labelKey,\n        labelName,\n        title,\n        color,\n        seriesId: this.id\n      }\n    );\n  }\n  getLegendData() {\n    if (!this.data?.length || !this.properties.isValid()) {\n      return [];\n    }\n    const { yKey, yName, title, marker, visible } = this.properties;\n    const { shape, fill, stroke, fillOpacity, strokeOpacity, strokeWidth } = marker;\n    return [\n      {\n        legendType: \"category\",\n        id: this.id,\n        itemId: yKey,\n        seriesId: this.id,\n        enabled: visible,\n        label: {\n          text: title ?? yName ?? yKey\n        },\n        symbols: [\n          {\n            marker: {\n              shape,\n              fill: fill ?? \"rgba(0, 0, 0, 0)\",\n              stroke: stroke ?? \"rgba(0, 0, 0, 0)\",\n              fillOpacity: fillOpacity ?? 1,\n              strokeOpacity: strokeOpacity ?? 1,\n              strokeWidth: strokeWidth ?? 0\n            }\n          }\n        ]\n      }\n    ];\n  }\n  animateEmptyUpdateReady({ markerSelection, labelSelection }) {\n    markerScaleInAnimation(this, this.ctx.animationManager, markerSelection);\n    seriesLabelFadeInAnimation(this, \"labels\", this.ctx.animationManager, labelSelection);\n  }\n  isLabelEnabled() {\n    return this.properties.label.enabled;\n  }\n  nodeFactory() {\n    return new Group();\n  }\n  getFormattedMarkerStyle(datum) {\n    const { xKey, yKey, sizeKey, labelKey } = this.properties;\n    return this.getMarkerStyle(this.properties.marker, {\n      datum,\n      xKey,\n      yKey,\n      sizeKey,\n      labelKey,\n      highlighted: false\n    });\n  }\n  computeFocusBounds(opts) {\n    return computeMarkerFocusBounds(this, opts);\n  }\n};\nBubbleSeries.className = \"BubbleSeries\";\nBubbleSeries.type = \"bubble\";\n\n// packages/ag-charts-community/src/chart/series/cartesian/bubbleSeriesModule.ts\nvar BubbleSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  identifier: \"bubble\",\n  moduleFactory: (ctx) => new BubbleSeries(ctx),\n  tooltipDefaults: { range: \"nearest\" },\n  defaultAxes: [\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"bottom\" /* BOTTOM */\n    },\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"left\" /* LEFT */\n    }\n  ],\n  themeTemplate: {\n    series: {\n      shape: \"circle\",\n      size: 7,\n      maxSize: 30,\n      fillOpacity: 0.8,\n      tooltip: { position: { type: \"node\" } },\n      label: {\n        enabled: false,\n        fontSize: 12,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_LABEL_COLOUR\n      }\n    }\n  },\n  paletteFactory: singleSeriesPaletteFactory\n};\n\n// packages/ag-charts-community/src/chart/series/cartesian/histogramSeriesProperties.ts\nvar HistogramSeriesProperties = class extends CartesianSeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.fillOpacity = 1;\n    this.strokeWidth = 1;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.cornerRadius = 0;\n    this.areaPlot = false;\n    this.aggregation = \"sum\";\n    this.shadow = new DropShadow();\n    this.label = new Label();\n    this.tooltip = new SeriesTooltip();\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], HistogramSeriesProperties.prototype, \"xKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], HistogramSeriesProperties.prototype, \"yKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], HistogramSeriesProperties.prototype, \"xName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], HistogramSeriesProperties.prototype, \"yName\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], HistogramSeriesProperties.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO)\n], HistogramSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], HistogramSeriesProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], HistogramSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO)\n], HistogramSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH)\n], HistogramSeriesProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], HistogramSeriesProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], HistogramSeriesProperties.prototype, \"cornerRadius\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], HistogramSeriesProperties.prototype, \"areaPlot\", 2);\n__decorateClass([\n  Validate(ARRAY, { optional: true })\n], HistogramSeriesProperties.prototype, \"bins\", 2);\n__decorateClass([\n  Validate(UNION([\"count\", \"sum\", \"mean\"], \"a histogram aggregation\"))\n], HistogramSeriesProperties.prototype, \"aggregation\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], HistogramSeriesProperties.prototype, \"binCount\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], HistogramSeriesProperties.prototype, \"shadow\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], HistogramSeriesProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], HistogramSeriesProperties.prototype, \"tooltip\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/histogramSeries.ts\nvar defaultBinCount = 10;\nvar HistogramSeries = class extends CartesianSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,\n      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,\n      pickModes: [1 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */],\n      datumSelectionGarbageCollection: false,\n      animationResetFns: {\n        datum: resetBarSelectionsFn,\n        label: resetLabelFn\n      }\n    });\n    this.properties = new HistogramSeriesProperties();\n    this.calculatedBins = [];\n  }\n  // During processData phase, used to unify different ways of the user specifying\n  // the bins. Returns bins in format[[min1, max1], [min2, max2], ... ].\n  deriveBins(xDomain) {\n    const binStarts = createTicks(xDomain[0], xDomain[1], defaultBinCount);\n    const binSize = tickStep(xDomain[0], xDomain[1], defaultBinCount);\n    const [firstBinEnd] = binStarts;\n    const expandStartToBin = (n) => [n, n + binSize];\n    return [[firstBinEnd - binSize, firstBinEnd], ...binStarts.map(expandStartToBin)];\n  }\n  calculateNiceBins(domain, binCount) {\n    const startGuess = Math.floor(domain[0]);\n    const stop = domain[1];\n    const segments = binCount || 1;\n    const { start: start2, binSize } = this.calculateNiceStart(startGuess, stop, segments);\n    return this.getBins(start2, stop, binSize, segments);\n  }\n  getBins(start2, stop, step, count) {\n    const bins = [];\n    const precision = this.calculatePrecision(step);\n    for (let i = 0; i < count; i++) {\n      const a = Math.round((start2 + i * step) * precision) / precision;\n      let b = Math.round((start2 + (i + 1) * step) * precision) / precision;\n      if (i === count - 1) {\n        b = Math.max(b, stop);\n      }\n      bins[i] = [a, b];\n    }\n    return bins;\n  }\n  calculatePrecision(step) {\n    let precision = 10;\n    if (isFinite(step) && step > 0) {\n      while (step < 1) {\n        precision *= 10;\n        step *= 10;\n      }\n    }\n    return precision;\n  }\n  calculateNiceStart(a, b, segments) {\n    const binSize = Math.abs(b - a) / segments;\n    const order = Math.floor(Math.log10(binSize));\n    const magnitude = Math.pow(10, order);\n    const start2 = Math.floor(a / magnitude) * magnitude;\n    return {\n      start: start2,\n      binSize\n    };\n  }\n  async processData(dataController) {\n    if (!this.visible) {\n      this.processedData = void 0;\n      this.animationState.transition(\"updateData\");\n    }\n    const { xKey, yKey, areaPlot, aggregation } = this.properties;\n    const xScale = this.axes[\"x\" /* X */]?.scale;\n    const yScale = this.axes[\"y\" /* Y */]?.scale;\n    const { xScaleType, yScaleType } = this.getScaleInformation({ yScale, xScale });\n    const props = [keyProperty(xKey, xScaleType), SORT_DOMAIN_GROUPS];\n    if (yKey) {\n      let aggProp = groupCount(\"groupAgg\");\n      if (aggregation === \"count\") {\n      } else if (aggregation === \"sum\") {\n        aggProp = groupSum(\"groupAgg\");\n      } else if (aggregation === \"mean\") {\n        aggProp = groupAverage(\"groupAgg\");\n      }\n      if (areaPlot) {\n        aggProp = area(\"groupAgg\", aggProp);\n      }\n      props.push(valueProperty(yKey, yScaleType, { invalidValue: void 0 }), aggProp);\n    } else {\n      let aggProp = groupCount(\"groupAgg\");\n      if (areaPlot) {\n        aggProp = area(\"groupAgg\", aggProp);\n      }\n      props.push(aggProp);\n    }\n    const groupByFn = (dataSet) => {\n      const xExtent = fixNumericExtent(dataSet.domain.keys[0]);\n      if (xExtent.length === 0) {\n        dataSet.domain.groups = [];\n        return () => [];\n      }\n      const bins = isNumber(this.properties.binCount) ? this.calculateNiceBins(xExtent, this.properties.binCount) : this.properties.bins ?? this.deriveBins(xExtent);\n      const binCount = bins.length;\n      this.calculatedBins = [...bins];\n      return (item) => {\n        const xValue = item.keys[0];\n        for (let i = 0; i < binCount; i++) {\n          const nextBin = bins[i];\n          if (xValue >= nextBin[0] && xValue < nextBin[1]) {\n            return nextBin;\n          }\n          if (i === binCount - 1 && xValue <= nextBin[1]) {\n            return nextBin;\n          }\n        }\n        return [];\n      };\n    };\n    if (!this.ctx.animationManager.isSkipped() && this.processedData) {\n      props.push(diff(this.processedData, false));\n    }\n    await this.requestDataModel(dataController, this.data, { props, groupByFn });\n    this.animationState.transition(\"updateData\");\n  }\n  getSeriesDomain(direction) {\n    const { processedData, dataModel } = this;\n    if (!processedData || !dataModel || !this.calculatedBins.length)\n      return [];\n    const yDomain = dataModel.getDomain(this, `groupAgg`, \"aggregate\", processedData);\n    const xDomainMin = this.calculatedBins?.[0][0];\n    const xDomainMax = this.calculatedBins?.[(this.calculatedBins?.length ?? 0) - 1][1];\n    if (direction === \"x\" /* X */) {\n      return fixNumericExtent([xDomainMin, xDomainMax]);\n    }\n    return fixNumericExtent(yDomain);\n  }\n  async createNodeData() {\n    const {\n      id: seriesId,\n      axes,\n      processedData,\n      ctx: { callbackCache }\n    } = this;\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    if (!xAxis || !yAxis) {\n      return;\n    }\n    const { scale: xScale } = xAxis;\n    const { scale: yScale } = yAxis;\n    const { xKey, yKey, xName, yName, fill, stroke, strokeWidth, cornerRadius } = this.properties;\n    const labelFormatter = this.properties.label.formatter ?? ((params) => String(params.value));\n    const nodeData = [];\n    const context = {\n      itemId: this.properties.yKey ?? this.id,\n      nodeData,\n      labelData: nodeData,\n      scales: this.calculateScaling(),\n      animationValid: true,\n      visible: this.visible\n    };\n    if (!this.visible || !processedData || processedData.type !== \"grouped\")\n      return context;\n    processedData.data.forEach((group) => {\n      const {\n        aggValues: [[negativeAgg, positiveAgg]] = [[0, 0]],\n        datum,\n        datum: { length: frequency },\n        keys: domain,\n        keys: [xDomainMin, xDomainMax]\n      } = group;\n      const xMinPx = xScale.convert(xDomainMin);\n      const xMaxPx = xScale.convert(xDomainMax);\n      const total = negativeAgg + positiveAgg;\n      const yZeroPx = yScale.convert(0);\n      const yMaxPx = yScale.convert(total);\n      const w = Math.abs(xMaxPx - xMinPx);\n      const h = Math.abs(yMaxPx - yZeroPx);\n      const x = Math.min(xMinPx, xMaxPx);\n      const y = Math.min(yZeroPx, yMaxPx);\n      let selectionDatumLabel = void 0;\n      if (total !== 0) {\n        selectionDatumLabel = {\n          x: x + w / 2,\n          y: y + h / 2,\n          text: callbackCache.call(labelFormatter, {\n            value: total,\n            datum,\n            seriesId,\n            xKey,\n            yKey,\n            xName,\n            yName\n          }) ?? String(total)\n        };\n      }\n      const nodeMidPoint = {\n        x: x + w / 2,\n        y: y + h / 2\n      };\n      const yAxisReversed = yAxis.isReversed();\n      nodeData.push({\n        series: this,\n        datum,\n        // required by SeriesNodeDatum, but might not make sense here\n        // since each selection is an aggregation of multiple data.\n        aggregatedValue: total,\n        frequency,\n        domain,\n        yKey,\n        xKey,\n        x,\n        y,\n        xValue: xMinPx,\n        yValue: yMaxPx,\n        width: w,\n        height: h,\n        midPoint: nodeMidPoint,\n        fill,\n        stroke,\n        cornerRadius,\n        topLeftCornerRadius: !yAxisReversed,\n        topRightCornerRadius: !yAxisReversed,\n        bottomRightCornerRadius: yAxisReversed,\n        bottomLeftCornerRadius: yAxisReversed,\n        opacity: 1,\n        strokeWidth,\n        label: selectionDatumLabel\n      });\n    });\n    nodeData.sort((a, b) => a.x - b.x);\n    return context;\n  }\n  nodeFactory() {\n    return new Rect();\n  }\n  async updateDatumSelection(opts) {\n    const { nodeData, datumSelection } = opts;\n    return datumSelection.update(\n      nodeData,\n      (rect) => {\n        rect.crisp = true;\n      },\n      (datum) => datum.domain.join(\"_\")\n    );\n  }\n  async updateDatumNodes(opts) {\n    const { isHighlight: isDatumHighlighted } = opts;\n    const {\n      fillOpacity: seriesFillOpacity,\n      strokeOpacity,\n      lineDash,\n      lineDashOffset,\n      shadow,\n      highlightStyle: {\n        item: {\n          fill: highlightedFill,\n          fillOpacity: highlightFillOpacity = seriesFillOpacity,\n          stroke: highlightedStroke,\n          strokeWidth: highlightedDatumStrokeWidth\n        }\n      }\n    } = this.properties;\n    opts.datumSelection.each((rect, datum, index) => {\n      const {\n        cornerRadius,\n        topLeftCornerRadius,\n        topRightCornerRadius,\n        bottomRightCornerRadius,\n        bottomLeftCornerRadius\n      } = datum;\n      const strokeWidth = isDatumHighlighted && highlightedDatumStrokeWidth !== void 0 ? highlightedDatumStrokeWidth : datum.strokeWidth;\n      const fillOpacity = isDatumHighlighted ? highlightFillOpacity : seriesFillOpacity;\n      rect.fill = (isDatumHighlighted ? highlightedFill : void 0) ?? datum.fill;\n      rect.stroke = (isDatumHighlighted ? highlightedStroke : void 0) ?? datum.stroke;\n      rect.fillOpacity = fillOpacity;\n      rect.strokeOpacity = strokeOpacity;\n      rect.strokeWidth = strokeWidth;\n      rect.lineDash = lineDash;\n      rect.lineDashOffset = lineDashOffset;\n      rect.topLeftCornerRadius = topLeftCornerRadius ? cornerRadius : 0;\n      rect.topRightCornerRadius = topRightCornerRadius ? cornerRadius : 0;\n      rect.bottomRightCornerRadius = bottomRightCornerRadius ? cornerRadius : 0;\n      rect.bottomLeftCornerRadius = bottomLeftCornerRadius ? cornerRadius : 0;\n      rect.fillShadow = shadow;\n      rect.zIndex = isDatumHighlighted ? Series.highlightedZIndex : index;\n      rect.visible = datum.height > 0;\n    });\n  }\n  async updateLabelSelection(opts) {\n    const { labelData, labelSelection } = opts;\n    return labelSelection.update(labelData, (text) => {\n      text.pointerEvents = 1 /* None */;\n      text.textAlign = \"center\";\n      text.textBaseline = \"middle\";\n    });\n  }\n  async updateLabelNodes(opts) {\n    const { fontStyle, fontWeight, fontFamily, fontSize, color } = this.properties.label;\n    const labelEnabled = this.isLabelEnabled();\n    opts.labelSelection.each((text, datum) => {\n      if (labelEnabled && datum?.label) {\n        text.text = datum.label.text;\n        text.x = datum.label.x;\n        text.y = datum.label.y;\n        text.fontStyle = fontStyle;\n        text.fontWeight = fontWeight;\n        text.fontFamily = fontFamily;\n        text.fontSize = fontSize;\n        text.fill = color;\n        text.visible = true;\n      } else {\n        text.visible = false;\n      }\n    });\n  }\n  initQuadTree(quadtree) {\n    const { value: childNode } = this.contentGroup.children().next();\n    if (childNode) {\n      addHitTestersToQuadtree(quadtree, childNode.children());\n    }\n  }\n  pickNodeClosestDatum(point) {\n    return findQuadtreeMatch(this, point);\n  }\n  getTooltipHtml(nodeDatum) {\n    const xAxis = this.axes[\"x\" /* X */];\n    const yAxis = this.axes[\"y\" /* Y */];\n    if (!this.properties.isValid() || !xAxis || !yAxis) {\n      return EMPTY_TOOLTIP_CONTENT;\n    }\n    const { xKey, yKey, xName, yName, fill: color, aggregation, tooltip } = this.properties;\n    const {\n      aggregatedValue,\n      frequency,\n      domain: [rangeMin, rangeMax],\n      itemId\n    } = nodeDatum;\n    const title = `${sanitizeHtml(xName ?? xKey)}: ${xAxis.formatDatum(rangeMin)} - ${xAxis.formatDatum(rangeMax)}`;\n    let content = yKey ? `<b>${sanitizeHtml(yName ?? yKey)} (${aggregation})</b>: ${yAxis.formatDatum(aggregatedValue)}<br>` : \"\";\n    content += `<b>Frequency</b>: ${frequency}`;\n    const defaults = {\n      title,\n      backgroundColor: color,\n      content\n    };\n    return tooltip.toTooltipHtml(defaults, {\n      datum: {\n        data: nodeDatum.datum,\n        aggregatedValue: nodeDatum.aggregatedValue,\n        domain: nodeDatum.domain,\n        frequency: nodeDatum.frequency\n      },\n      itemId,\n      xKey,\n      xName,\n      yKey,\n      yName,\n      color,\n      title,\n      seriesId: this.id\n    });\n  }\n  getLegendData(legendType) {\n    if (!this.data?.length || legendType !== \"category\") {\n      return [];\n    }\n    const { xKey, yName, fill, fillOpacity, stroke, strokeWidth, strokeOpacity, visible } = this.properties;\n    return [\n      {\n        legendType: \"category\",\n        id: this.id,\n        itemId: xKey,\n        seriesId: this.id,\n        enabled: visible,\n        label: {\n          text: yName ?? xKey ?? \"Frequency\"\n        },\n        symbols: [\n          {\n            marker: {\n              fill: fill ?? \"rgba(0, 0, 0, 0)\",\n              stroke: stroke ?? \"rgba(0, 0, 0, 0)\",\n              fillOpacity,\n              strokeOpacity,\n              strokeWidth\n            }\n          }\n        ]\n      }\n    ];\n  }\n  animateEmptyUpdateReady({ datumSelection, labelSelection }) {\n    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(true, this.axes, \"normal\"));\n    fromToMotion(this.id, \"datums\", this.ctx.animationManager, [datumSelection], fns);\n    seriesLabelFadeInAnimation(this, \"labels\", this.ctx.animationManager, labelSelection);\n  }\n  animateWaitingUpdateReady(data) {\n    const dataDiff = this.processedData?.reduced?.diff;\n    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(true, this.axes, \"normal\"));\n    fromToMotion(\n      this.id,\n      \"datums\",\n      this.ctx.animationManager,\n      [data.datumSelection],\n      fns,\n      (_, datum) => createDatumId(datum.domain),\n      dataDiff\n    );\n    seriesLabelFadeInAnimation(this, \"labels\", this.ctx.animationManager, data.labelSelection);\n  }\n  isLabelEnabled() {\n    return this.properties.label.enabled;\n  }\n  computeFocusBounds({ datumIndex, seriesRect }) {\n    return computeBarFocusBounds(this.contextNodeData?.nodeData[datumIndex], this.contentGroup, seriesRect);\n  }\n};\nHistogramSeries.className = \"HistogramSeries\";\nHistogramSeries.type = \"histogram\";\n\n// packages/ag-charts-community/src/chart/series/cartesian/histogramSeriesModule.ts\nvar HistogramSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  identifier: \"histogram\",\n  moduleFactory: (ctx) => new HistogramSeries(ctx),\n  tooltipDefaults: { range: \"exact\" },\n  defaultAxes: [\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"bottom\" /* BOTTOM */\n    },\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"left\" /* LEFT */\n    }\n  ],\n  themeTemplate: {\n    series: {\n      strokeWidth: 1,\n      fillOpacity: 1,\n      strokeOpacity: 1,\n      lineDash: [0],\n      lineDashOffset: 0,\n      label: {\n        enabled: false,\n        fontSize: 12,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR\n      },\n      shadow: {\n        enabled: false,\n        color: DEFAULT_SHADOW_COLOUR,\n        xOffset: 3,\n        yOffset: 3,\n        blur: 5\n      }\n    }\n  },\n  paletteFactory: ({ takeColors }) => {\n    const {\n      fills: [fill],\n      strokes: [stroke]\n    } = takeColors(1);\n    return { fill, stroke };\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/cartesian/lineSeriesProperties.ts\nvar LineSeriesProperties = class extends CartesianSeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.stroke = \"#874349\";\n    this.strokeWidth = 2;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.interpolation = new InterpolationProperties();\n    this.marker = new SeriesMarker();\n    this.label = new Label();\n    this.tooltip = new SeriesTooltip();\n    this.connectMissingData = false;\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], LineSeriesProperties.prototype, \"xKey\", 2);\n__decorateClass([\n  Validate(STRING)\n], LineSeriesProperties.prototype, \"yKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], LineSeriesProperties.prototype, \"xName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], LineSeriesProperties.prototype, \"yName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], LineSeriesProperties.prototype, \"yFilterKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], LineSeriesProperties.prototype, \"stackGroup\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], LineSeriesProperties.prototype, \"normalizedTo\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], LineSeriesProperties.prototype, \"title\", 2);\n__decorateClass([\n  Validate(COLOR_STRING)\n], LineSeriesProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], LineSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO)\n], LineSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH)\n], LineSeriesProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], LineSeriesProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], LineSeriesProperties.prototype, \"interpolation\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], LineSeriesProperties.prototype, \"marker\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], LineSeriesProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], LineSeriesProperties.prototype, \"tooltip\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], LineSeriesProperties.prototype, \"connectMissingData\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/lineSeries.ts\nvar CROSS_FILTER_LINE_STROKE_OPACITY_FACTOR = 0.25;\nvar LineSeries = class extends CartesianSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,\n      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,\n      hasMarkers: true,\n      pickModes: [\n        2 /* AXIS_ALIGNED */,\n        1 /* NEAREST_NODE */,\n        0 /* EXACT_SHAPE_MATCH */\n      ],\n      markerSelectionGarbageCollection: false,\n      animationResetFns: {\n        path: buildResetPathFn({ getVisible: () => this.visible, getOpacity: () => this.getOpacity() }),\n        label: resetLabelFn,\n        marker: (node, datum) => ({ ...resetMarkerFn(node), ...resetMarkerPositionFn(node, datum) })\n      }\n    });\n    this.properties = new LineSeriesProperties();\n  }\n  get pickModeAxis() {\n    return \"main-category\";\n  }\n  async processData(dataController) {\n    if (this.data == null || !this.properties.isValid()) {\n      return;\n    }\n    const { data, visible, seriesGrouping: { groupIndex = this.id, stackCount = 1 } = {} } = this;\n    const { xKey, yKey, yFilterKey, connectMissingData, normalizedTo } = this.properties;\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    const xScale = this.axes[\"x\" /* X */]?.scale;\n    const yScale = this.axes[\"y\" /* Y */]?.scale;\n    const { isContinuousX, xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });\n    const common = { invalidValue: null };\n    if (connectMissingData && stackCount > 1) {\n      common.invalidValue = 0;\n    }\n    if (!visible) {\n      common.forceValue = 0;\n    }\n    const props = [];\n    if (!isContinuousX) {\n      props.push(keyProperty(xKey, xScaleType, { id: \"xKey\" }));\n    }\n    props.push(\n      valueProperty(xKey, xScaleType, { id: \"xValue\" }),\n      valueProperty(yKey, yScaleType, {\n        id: `yValueRaw`,\n        ...common,\n        invalidValue: void 0\n      })\n    );\n    if (yFilterKey != null) {\n      props.push(valueProperty(yFilterKey, yScaleType, { id: \"yFilterRaw\" }));\n    }\n    if (stackCount > 1) {\n      const ids = [\n        `line-stack-${groupIndex}-yValues`,\n        `line-stack-${groupIndex}-yValues-trailing`,\n        `line-stack-${groupIndex}-yValues-marker`\n      ];\n      props.push(\n        ...groupAccumulativeValueProperty(\n          yKey,\n          \"window\",\n          \"current\",\n          { id: `yValueEnd`, ...common, groupId: ids[0] },\n          yScaleType\n        ),\n        ...groupAccumulativeValueProperty(\n          yKey,\n          \"window-trailing\",\n          \"current\",\n          { id: `yValueStart`, ...common, groupId: ids[1] },\n          yScaleType\n        ),\n        ...groupAccumulativeValueProperty(\n          yKey,\n          \"normal\",\n          \"current\",\n          { id: `yValueCumulative`, ...common, groupId: ids[2] },\n          yScaleType\n        )\n      );\n      if (isDefined(normalizedTo)) {\n        props.push(normaliseGroupTo([ids[0], ids[1], ids[2]], normalizedTo, \"range\"));\n      }\n    }\n    if (animationEnabled) {\n      props.push(animationValidation(isContinuousX ? [\"xValue\"] : void 0));\n      if (this.processedData) {\n        props.push(diff(this.processedData));\n      }\n    }\n    await this.requestDataModel(dataController, data, { props });\n    this.animationState.transition(\"updateData\");\n  }\n  getSeriesDomain(direction) {\n    const { dataModel, processedData } = this;\n    if (!dataModel || !processedData?.data.length)\n      return [];\n    const xDef = dataModel.resolveProcessedDataDefById(this, `xValue`);\n    if (direction === \"x\" /* X */) {\n      const domain = dataModel.getDomain(this, `xValue`, \"value\", processedData);\n      if (xDef?.def.type === \"value\" && xDef.def.valueType === \"category\") {\n        return domain;\n      }\n      return fixNumericExtent(extent(domain));\n    } else {\n      const stackCount = this.seriesGrouping?.stackCount ?? 1;\n      const domain = stackCount > 1 ? dataModel.getDomain(this, `yValueEnd`, \"value\", processedData) : dataModel.getDomain(this, `yValueRaw`, \"value\", processedData);\n      return fixNumericExtent(domain);\n    }\n  }\n  async createNodeData() {\n    const { processedData, dataModel, axes } = this;\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    if (!processedData || !dataModel || !xAxis || !yAxis) {\n      return;\n    }\n    const { xKey, yKey, yFilterKey, xName, yName, marker, label, connectMissingData, legendItemName } = this.properties;\n    const stacked = (this.seriesGrouping?.stackCount ?? 1) > 1;\n    const xScale = xAxis.scale;\n    const yScale = yAxis.scale;\n    const xOffset = (xScale.bandwidth ?? 0) / 2;\n    const yOffset = (yScale.bandwidth ?? 0) / 2;\n    const nodeData = [];\n    const size = marker.enabled ? marker.size : 0;\n    const xIdx = dataModel.resolveProcessedDataIndexById(this, `xValue`);\n    const yIdx = dataModel.resolveProcessedDataIndexById(this, `yValueRaw`);\n    const ySelectionIdx = yFilterKey != null ? dataModel.resolveProcessedDataIndexById(this, `yFilterRaw`) : void 0;\n    const yCumulativeIdx = stacked ? dataModel.resolveProcessedDataIndexById(this, `yValueCumulative`) : yIdx;\n    const yEndIdx = stacked ? dataModel.resolveProcessedDataIndexById(this, `yValueEnd`) : void 0;\n    let moveTo = true;\n    let crossFiltering = false;\n    processedData.data?.forEach(({ datum, values }) => {\n      const xDatum = values[xIdx];\n      const yDatum = values[yIdx];\n      const yCumulativeDatum = values[yCumulativeIdx];\n      const yEndDatum = yEndIdx != null ? values[yEndIdx] : void 0;\n      if (yDatum == null) {\n        moveTo || (moveTo = !connectMissingData);\n        return;\n      }\n      const x = xScale.convert(xDatum) + xOffset;\n      if (isNaN(x)) {\n        moveTo || (moveTo = !connectMissingData);\n        return;\n      }\n      const y = yScale.convert(yCumulativeDatum) + yOffset;\n      const selected = ySelectionIdx != null ? values[ySelectionIdx] === yDatum : void 0;\n      if (selected === false) {\n        crossFiltering = true;\n      }\n      const labelText = this.getLabelText(\n        label,\n        { value: yDatum, datum, xKey, yKey, xName, yName, legendItemName },\n        formatValue\n      );\n      nodeData.push({\n        series: this,\n        datum,\n        yKey,\n        xKey,\n        point: { x, y, moveTo, size },\n        midPoint: { x, y },\n        cumulativeValue: yEndDatum,\n        yValue: yDatum,\n        xValue: xDatum,\n        capDefaults: {\n          lengthRatioMultiplier: this.properties.marker.getDiameter(),\n          lengthMax: Infinity\n        },\n        labelText,\n        selected\n      });\n      moveTo = false;\n    });\n    return {\n      itemId: yKey,\n      nodeData,\n      labelData: nodeData,\n      scales: this.calculateScaling(),\n      visible: this.visible,\n      crossFiltering\n    };\n  }\n  isPathOrSelectionDirty() {\n    return this.properties.marker.isDirty();\n  }\n  markerFactory() {\n    const { shape } = this.properties.marker;\n    const MarkerShape = getMarker(shape);\n    return new MarkerShape();\n  }\n  async updatePathNodes(opts) {\n    const {\n      paths: [lineNode],\n      opacity,\n      visible,\n      animationEnabled\n    } = opts;\n    const crossFiltering = this.contextNodeData?.crossFiltering === true;\n    lineNode.setProperties({\n      fill: void 0,\n      lineJoin: \"round\",\n      pointerEvents: 1 /* None */,\n      opacity,\n      stroke: this.properties.stroke,\n      strokeWidth: this.getStrokeWidth(this.properties.strokeWidth),\n      strokeOpacity: this.properties.strokeOpacity * (crossFiltering ? CROSS_FILTER_LINE_STROKE_OPACITY_FACTOR : 1),\n      lineDash: this.properties.lineDash,\n      lineDashOffset: this.properties.lineDashOffset\n    });\n    if (!animationEnabled) {\n      lineNode.visible = visible;\n    }\n    updateClipPath(this, lineNode);\n  }\n  async updateMarkerSelection(opts) {\n    let { nodeData } = opts;\n    const { markerSelection } = opts;\n    const markersEnabled = this.properties.marker.enabled || this.contextNodeData?.crossFiltering === true;\n    nodeData = markersEnabled ? nodeData : [];\n    if (this.properties.marker.isDirty()) {\n      markerSelection.clear();\n      markerSelection.cleanup();\n    }\n    return markerSelection.update(nodeData, void 0, (datum) => createDatumId(datum.xValue));\n  }\n  async updateMarkerNodes(opts) {\n    const { markerSelection, isHighlight: highlighted } = opts;\n    const { xKey, yKey, stroke, strokeWidth, strokeOpacity, marker, highlightStyle } = this.properties;\n    const baseStyle = mergeDefaults(highlighted && highlightStyle.item, marker.getStyle(), {\n      stroke,\n      strokeWidth,\n      strokeOpacity\n    });\n    const applyTranslation = this.ctx.animationManager.isSkipped();\n    markerSelection.each((node, datum) => {\n      this.updateMarkerStyle(node, marker, { datum, highlighted, xKey, yKey }, baseStyle, {\n        applyTranslation,\n        selected: datum.selected\n      });\n    });\n    if (!highlighted) {\n      marker.markClean();\n    }\n  }\n  async updateLabelSelection(opts) {\n    return opts.labelSelection.update(this.isLabelEnabled() ? opts.labelData : []);\n  }\n  async updateLabelNodes(opts) {\n    const { enabled, fontStyle, fontWeight, fontSize, fontFamily, color } = this.properties.label;\n    opts.labelSelection.each((text, datum) => {\n      if (enabled && datum?.labelText) {\n        text.fontStyle = fontStyle;\n        text.fontWeight = fontWeight;\n        text.fontSize = fontSize;\n        text.fontFamily = fontFamily;\n        text.textAlign = \"center\";\n        text.textBaseline = \"bottom\";\n        text.text = datum.labelText;\n        text.x = datum.point.x;\n        text.y = datum.point.y - 10;\n        text.fill = color;\n        text.visible = true;\n      } else {\n        text.visible = false;\n      }\n    });\n  }\n  getTooltipHtml(nodeDatum) {\n    const xAxis = this.axes[\"x\" /* X */];\n    const yAxis = this.axes[\"y\" /* Y */];\n    if (!this.properties.isValid() || !xAxis || !yAxis) {\n      return EMPTY_TOOLTIP_CONTENT;\n    }\n    const { xKey, yKey, xName, yName, strokeWidth, marker, tooltip } = this.properties;\n    const { datum, xValue, yValue, itemId } = nodeDatum;\n    const xString = xAxis.formatDatum(xValue);\n    const yString = yAxis.formatDatum(yValue);\n    const title = sanitizeHtml(this.properties.title ?? yName);\n    const content = sanitizeHtml(xString + \": \" + yString);\n    const baseStyle = mergeDefaults({ fill: marker.stroke }, marker.getStyle(), { strokeWidth });\n    const { fill: color } = this.getMarkerStyle(\n      marker,\n      { datum: nodeDatum, xKey, yKey, highlighted: false },\n      baseStyle\n    );\n    return tooltip.toTooltipHtml(\n      { title, content, backgroundColor: color },\n      {\n        datum,\n        itemId,\n        xKey,\n        xName,\n        yKey,\n        yName,\n        title,\n        color,\n        seriesId: this.id,\n        ...this.getModuleTooltipParams()\n      }\n    );\n  }\n  getLegendData(legendType) {\n    if (!(this.data?.length && this.properties.isValid() && legendType === \"category\")) {\n      return [];\n    }\n    const { yKey, yName, stroke, strokeOpacity, strokeWidth, lineDash, title, marker, visible, legendItemName } = this.properties;\n    const color0 = \"rgba(0, 0, 0, 0)\";\n    return [\n      {\n        legendType: \"category\",\n        id: this.id,\n        itemId: yKey,\n        legendItemName,\n        seriesId: this.id,\n        enabled: visible,\n        label: {\n          text: legendItemName ?? title ?? yName ?? yKey\n        },\n        symbols: [\n          {\n            marker: {\n              shape: marker.shape,\n              fill: marker.fill ?? color0,\n              stroke: marker.stroke ?? stroke ?? color0,\n              fillOpacity: marker.fillOpacity ?? 1,\n              strokeOpacity: marker.strokeOpacity ?? strokeOpacity ?? 1,\n              strokeWidth: marker.strokeWidth ?? 0,\n              enabled: marker.enabled\n            },\n            line: {\n              stroke: stroke ?? color0,\n              strokeOpacity,\n              strokeWidth,\n              lineDash\n            }\n          }\n        ]\n      }\n    ];\n  }\n  async updatePaths(opts) {\n    this.updateLinePaths(opts.paths, opts.contextData);\n  }\n  updateLinePaths(paths, contextData) {\n    const { interpolation } = this.properties;\n    const { nodeData } = contextData;\n    const [lineNode] = paths;\n    lineNode.path.clear(true);\n    for (const range3 of pathRanges(nodeData)) {\n      plotPath(pathRangePoints(nodeData, range3), lineNode, interpolation);\n    }\n    lineNode.checkPathDirty();\n  }\n  animateEmptyUpdateReady(animationData) {\n    const { markerSelection, labelSelection, annotationSelections, contextData, paths } = animationData;\n    const { animationManager } = this.ctx;\n    this.updateLinePaths(paths, contextData);\n    pathSwipeInAnimation(this, animationManager, ...paths);\n    resetMotion([markerSelection], resetMarkerPositionFn);\n    markerSwipeScaleInAnimation(this, animationManager, markerSelection);\n    seriesLabelFadeInAnimation(this, \"labels\", animationManager, labelSelection);\n    seriesLabelFadeInAnimation(this, \"annotations\", animationManager, ...annotationSelections);\n  }\n  animateReadyResize(animationData) {\n    const { contextData, paths } = animationData;\n    this.updateLinePaths(paths, contextData);\n    super.animateReadyResize(animationData);\n  }\n  animateWaitingUpdateReady(animationData) {\n    const { animationManager } = this.ctx;\n    const {\n      markerSelection: markerSelections,\n      labelSelection: labelSelections,\n      annotationSelections,\n      contextData,\n      paths,\n      previousContextData\n    } = animationData;\n    const [path] = paths;\n    this.resetMarkerAnimation(animationData);\n    this.resetLabelAnimation(animationData);\n    const update = () => {\n      this.resetPathAnimation(animationData);\n      this.updateLinePaths(paths, contextData);\n    };\n    const skip = () => {\n      animationManager.skipCurrentBatch();\n      update();\n    };\n    if (contextData == null || previousContextData == null) {\n      update();\n      markerFadeInAnimation(this, animationManager, \"added\", markerSelections);\n      pathFadeInAnimation(this, \"path_properties\", animationManager, \"add\", path);\n      seriesLabelFadeInAnimation(this, \"labels\", animationManager, labelSelections);\n      seriesLabelFadeInAnimation(this, \"annotations\", animationManager, ...annotationSelections);\n      return;\n    }\n    if (contextData.crossFiltering !== previousContextData.crossFiltering) {\n      skip();\n      return;\n    }\n    let fns;\n    try {\n      fns = prepareLinePathAnimation(\n        contextData,\n        previousContextData,\n        this.processedData?.reduced?.diff,\n        this.properties.interpolation\n      );\n    } catch {\n      fns = void 0;\n    }\n    if (fns === void 0) {\n      skip();\n      return;\n    } else if (fns.status === \"no-op\") {\n      return;\n    }\n    markerFadeInAnimation(this, animationManager, void 0, markerSelections);\n    fromToMotion(this.id, \"path_properties\", animationManager, [path], fns.pathProperties);\n    if (fns.status === \"added\") {\n      this.updateLinePaths(paths, contextData);\n    } else if (fns.status === \"removed\") {\n      this.updateLinePaths(paths, previousContextData);\n    } else {\n      pathMotion(this.id, \"path_update\", animationManager, [path], fns.path);\n    }\n    if (fns.hasMotion) {\n      seriesLabelFadeInAnimation(this, \"labels\", animationManager, labelSelections);\n      seriesLabelFadeInAnimation(this, \"annotations\", animationManager, ...annotationSelections);\n    }\n  }\n  isLabelEnabled() {\n    return this.properties.label.enabled;\n  }\n  getBandScalePadding() {\n    return { inner: 1, outer: 0.1 };\n  }\n  nodeFactory() {\n    return new Group();\n  }\n  getFormattedMarkerStyle(datum) {\n    const { xKey, yKey } = this.properties;\n    return this.getMarkerStyle(this.properties.marker, { datum, xKey, yKey, highlighted: true });\n  }\n  computeFocusBounds(opts) {\n    return computeMarkerFocusBounds(this, opts);\n  }\n};\nLineSeries.className = \"LineSeries\";\nLineSeries.type = \"line\";\n\n// packages/ag-charts-community/src/chart/series/cartesian/lineSeriesModule.ts\nvar LineSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  identifier: \"line\",\n  moduleFactory: (ctx) => new LineSeries(ctx),\n  stackable: true,\n  tooltipDefaults: { range: \"nearest\" },\n  defaultAxes: [\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"left\" /* LEFT */\n    },\n    {\n      type: \"category\" /* CATEGORY */,\n      position: \"bottom\" /* BOTTOM */\n    }\n  ],\n  themeTemplate: {\n    series: {\n      tooltip: { position: { type: \"node\" } },\n      strokeWidth: 2,\n      strokeOpacity: 1,\n      lineDash: [0],\n      lineDashOffset: 0,\n      interpolation: {\n        type: \"linear\",\n        // @ts-expect-error - users shouldn't specify all options, but we have to for theming to work\n        tension: 1,\n        position: \"end\"\n      },\n      marker: {\n        shape: \"circle\",\n        size: 7,\n        strokeWidth: 0\n      },\n      label: {\n        enabled: false,\n        fontSize: 12,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_LABEL_COLOUR\n      },\n      errorBar: {\n        cap: {\n          lengthRatio: 1\n        }\n      }\n    }\n  },\n  paletteFactory: (params) => {\n    const { marker } = markerPaletteFactory(params);\n    return { stroke: marker.fill, marker };\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/cartesian/scatterSeriesProperties.ts\nvar ScatterSeriesLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.placement = \"top\";\n  }\n};\n__decorateClass([\n  Validate(LABEL_PLACEMENT)\n], ScatterSeriesLabel.prototype, \"placement\", 2);\nvar ScatterSeriesProperties = class extends CartesianSeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.colorRange = [\"#ffff00\", \"#00ff00\", \"#0000ff\"];\n    this.label = new ScatterSeriesLabel();\n    this.tooltip = new SeriesTooltip();\n    // No validation. Not a part of the options contract.\n    this.marker = new SeriesMarker();\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], ScatterSeriesProperties.prototype, \"xKey\", 2);\n__decorateClass([\n  Validate(STRING)\n], ScatterSeriesProperties.prototype, \"yKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"labelKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"colorKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"xFilterKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"yFilterKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"xName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"yName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"labelName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"colorName\", 2);\n__decorateClass([\n  Validate(NUMBER_ARRAY, { optional: true })\n], ScatterSeriesProperties.prototype, \"colorDomain\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], ScatterSeriesProperties.prototype, \"colorRange\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"title\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.shape\")\n], ScatterSeriesProperties.prototype, \"shape\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.size\")\n], ScatterSeriesProperties.prototype, \"size\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.fill\")\n], ScatterSeriesProperties.prototype, \"fill\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.fillOpacity\")\n], ScatterSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.stroke\")\n], ScatterSeriesProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.strokeWidth\")\n], ScatterSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.strokeOpacity\")\n], ScatterSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.itemStyler\", { optional: true })\n], ScatterSeriesProperties.prototype, \"itemStyler\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], ScatterSeriesProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], ScatterSeriesProperties.prototype, \"tooltip\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/scatterSeries.ts\nvar ScatterSeries = class extends CartesianSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,\n      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,\n      pickModes: [\n        2 /* AXIS_ALIGNED */,\n        1 /* NEAREST_NODE */,\n        0 /* EXACT_SHAPE_MATCH */\n      ],\n      pathsPerSeries: [],\n      hasMarkers: true,\n      markerSelectionGarbageCollection: false,\n      animationResetFns: {\n        marker: resetMarkerFn,\n        label: resetLabelFn\n      }\n    });\n    this.properties = new ScatterSeriesProperties();\n    this.colorScale = new ColorScale();\n  }\n  get pickModeAxis() {\n    return \"main-category\";\n  }\n  async processData(dataController) {\n    if (!this.properties.isValid() || this.data == null || !this.visible)\n      return;\n    const xScale = this.axes[\"x\" /* X */]?.scale;\n    const yScale = this.axes[\"y\" /* Y */]?.scale;\n    const { xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });\n    const colorScaleType = this.colorScale.type;\n    const { xKey, yKey, xFilterKey, yFilterKey, labelKey, colorKey, colorDomain, colorRange } = this.properties;\n    const { dataModel, processedData } = await this.requestDataModel(dataController, this.data, {\n      props: [\n        valueProperty(xKey, xScaleType, { id: `xValue` }),\n        valueProperty(yKey, yScaleType, { id: `yValue` }),\n        ...xFilterKey != null ? [valueProperty(xFilterKey, xScaleType, { id: \"xFilterValue\" })] : [],\n        ...yFilterKey != null ? [valueProperty(yFilterKey, yScaleType, { id: \"yFilterValue\" })] : [],\n        ...colorKey ? [valueProperty(colorKey, colorScaleType, { id: `colorValue` })] : [],\n        ...labelKey ? [valueProperty(labelKey, \"band\", { id: `labelValue` })] : []\n      ]\n    });\n    if (colorKey) {\n      const colorKeyIdx = dataModel.resolveProcessedDataIndexById(this, `colorValue`);\n      this.colorScale.domain = colorDomain ?? processedData.domain.values[colorKeyIdx] ?? [];\n      this.colorScale.range = colorRange;\n      this.colorScale.update();\n    }\n    this.animationState.transition(\"updateData\");\n  }\n  getSeriesDomain(direction) {\n    const { dataModel, processedData } = this;\n    if (!processedData || !dataModel)\n      return [];\n    const id = direction === \"x\" /* X */ ? `xValue` : `yValue`;\n    const dataDef = dataModel.resolveProcessedDataDefById(this, id);\n    const domain = dataModel.getDomain(this, id, \"value\", processedData);\n    if (dataDef?.def.type === \"value\" && dataDef?.def.valueType === \"category\") {\n      return domain;\n    }\n    return fixNumericExtent(extent(domain));\n  }\n  async createNodeData() {\n    const { axes, dataModel, processedData, colorScale } = this;\n    const {\n      xKey,\n      yKey,\n      xFilterKey,\n      yFilterKey,\n      labelKey,\n      colorKey,\n      xName,\n      yName,\n      labelName,\n      marker,\n      label,\n      visible\n    } = this.properties;\n    const { placement } = label;\n    const markerShape = getMarker(marker.shape);\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    if (!(dataModel && processedData && visible && xAxis && yAxis)) {\n      return;\n    }\n    const xDataIdx = dataModel.resolveProcessedDataIndexById(this, `xValue`);\n    const yDataIdx = dataModel.resolveProcessedDataIndexById(this, `yValue`);\n    const colorDataIdx = colorKey != null ? dataModel.resolveProcessedDataIndexById(this, `colorValue`) : -1;\n    const labelDataIdx = labelKey != null ? dataModel.resolveProcessedDataIndexById(this, `labelValue`) : -1;\n    const xFilterDataIdx = xFilterKey != null ? dataModel.resolveProcessedDataIndexById(this, `xFilterValue`) : void 0;\n    const yFilterDataIdx = yFilterKey != null ? dataModel.resolveProcessedDataIndexById(this, `yFilterValue`) : void 0;\n    const xScale = xAxis.scale;\n    const yScale = yAxis.scale;\n    const xOffset = (xScale.bandwidth ?? 0) / 2;\n    const yOffset = (yScale.bandwidth ?? 0) / 2;\n    const nodeData = [];\n    const font = label.getFont();\n    const textMeasurer = CachedTextMeasurerPool.getMeasurer({ font });\n    for (const { values, datum } of processedData.data ?? []) {\n      const xDatum = values[xDataIdx];\n      const yDatum = values[yDataIdx];\n      const x = xScale.convert(xDatum) + xOffset;\n      const y = yScale.convert(yDatum) + yOffset;\n      const selected = xFilterDataIdx != null && yFilterDataIdx != null ? values[xFilterDataIdx] === xDatum && values[yFilterDataIdx] === yDatum : void 0;\n      const labelText = this.getLabelText(label, {\n        value: labelKey ? values[labelDataIdx] : yDatum,\n        datum,\n        xKey,\n        yKey,\n        labelKey,\n        xName,\n        yName,\n        labelName\n      });\n      const size = textMeasurer.measureText(labelText);\n      const fill = colorKey ? colorScale.convert(values[colorDataIdx]) : void 0;\n      nodeData.push({\n        series: this,\n        itemId: yKey,\n        yKey,\n        xKey,\n        datum,\n        xValue: xDatum,\n        yValue: yDatum,\n        capDefaults: { lengthRatioMultiplier: marker.getDiameter(), lengthMax: Infinity },\n        point: { x, y, size: marker.size },\n        midPoint: { x, y },\n        fill,\n        label: { text: labelText, ...size },\n        marker: markerShape,\n        placement,\n        selected\n      });\n    }\n    return {\n      itemId: yKey,\n      nodeData,\n      labelData: nodeData,\n      scales: this.calculateScaling(),\n      visible: this.visible\n    };\n  }\n  isPathOrSelectionDirty() {\n    return this.properties.marker.isDirty();\n  }\n  getLabelData() {\n    return this.contextNodeData?.labelData ?? [];\n  }\n  markerFactory() {\n    const { shape } = this.properties.marker;\n    const MarkerShape = getMarker(shape);\n    return new MarkerShape();\n  }\n  async updateMarkerSelection(opts) {\n    const { nodeData, markerSelection } = opts;\n    if (this.properties.marker.isDirty()) {\n      markerSelection.clear();\n      markerSelection.cleanup();\n    }\n    return markerSelection.update(this.properties.marker.enabled ? nodeData : []);\n  }\n  async updateMarkerNodes(opts) {\n    const { markerSelection, isHighlight: highlighted } = opts;\n    const { xKey, yKey, labelKey, marker, highlightStyle } = this.properties;\n    const baseStyle = mergeDefaults(highlighted && highlightStyle.item, marker.getStyle());\n    markerSelection.each((node, datum) => {\n      this.updateMarkerStyle(node, marker, { datum, highlighted, xKey, yKey, labelKey }, baseStyle, {\n        selected: datum.selected\n      });\n    });\n    if (!highlighted) {\n      marker.markClean();\n    }\n  }\n  async updateLabelSelection(opts) {\n    const placedLabels = this.isLabelEnabled() ? this.chart?.placeLabels().get(this) ?? [] : [];\n    return opts.labelSelection.update(\n      placedLabels.map(({ datum, x, y }) => ({\n        ...datum,\n        point: { x, y, size: datum.point.size },\n        placement: \"top\"\n      })),\n      (text) => {\n        text.pointerEvents = 1 /* None */;\n      }\n    );\n  }\n  async updateLabelNodes(opts) {\n    const { label } = this.properties;\n    opts.labelSelection.each((text, datum) => {\n      text.text = datum.label.text;\n      text.fill = label.color;\n      text.x = datum.point?.x ?? 0;\n      text.y = datum.point?.y ?? 0;\n      text.fontStyle = label.fontStyle;\n      text.fontWeight = label.fontWeight;\n      text.fontSize = label.fontSize;\n      text.fontFamily = label.fontFamily;\n      text.textAlign = \"left\";\n      text.textBaseline = \"top\";\n    });\n  }\n  getTooltipHtml(nodeDatum) {\n    const xAxis = this.axes[\"x\" /* X */];\n    const yAxis = this.axes[\"y\" /* Y */];\n    if (!this.properties.isValid() || !xAxis || !yAxis) {\n      return EMPTY_TOOLTIP_CONTENT;\n    }\n    const { xKey, yKey, labelKey, xName, yName, labelName, title = yName, marker, tooltip } = this.properties;\n    const { datum, xValue, yValue, label, itemId } = nodeDatum;\n    const baseStyle = mergeDefaults(\n      { fill: nodeDatum.fill, strokeWidth: this.getStrokeWidth(marker.strokeWidth) },\n      marker.getStyle()\n    );\n    const { fill: color = \"gray\" } = this.getMarkerStyle(\n      marker,\n      { datum: nodeDatum, highlighted: false, xKey, yKey, labelKey },\n      baseStyle\n    );\n    const xString = sanitizeHtml(xAxis.formatDatum(xValue));\n    const yString = sanitizeHtml(yAxis.formatDatum(yValue));\n    let content = `<b>${sanitizeHtml(xName ?? xKey)}</b>: ${xString}<br><b>${sanitizeHtml(yName ?? yKey)}</b>: ${yString}`;\n    if (labelKey) {\n      content = `<b>${sanitizeHtml(labelName ?? labelKey)}</b>: ${sanitizeHtml(label.text)}<br>` + content;\n    }\n    return tooltip.toTooltipHtml(\n      { title, content, backgroundColor: color },\n      {\n        datum,\n        itemId,\n        xKey,\n        xName,\n        yKey,\n        yName,\n        labelKey,\n        labelName,\n        title,\n        color,\n        seriesId: this.id,\n        ...this.getModuleTooltipParams()\n      }\n    );\n  }\n  getLegendData(legendType) {\n    const { yKey, yName, title, marker, visible } = this.properties;\n    const { fill, stroke, fillOpacity, strokeOpacity, strokeWidth } = marker;\n    if (!this.data?.length || !this.properties.isValid() || legendType !== \"category\") {\n      return [];\n    }\n    return [\n      {\n        legendType: \"category\",\n        id: this.id,\n        itemId: yKey,\n        seriesId: this.id,\n        enabled: visible,\n        label: {\n          text: title ?? yName ?? yKey\n        },\n        symbols: [\n          {\n            marker: {\n              shape: marker.shape,\n              fill: marker.fill ?? fill ?? \"rgba(0, 0, 0, 0)\",\n              stroke: marker.stroke ?? stroke ?? \"rgba(0, 0, 0, 0)\",\n              fillOpacity: fillOpacity ?? 1,\n              strokeOpacity: strokeOpacity ?? 1,\n              strokeWidth: strokeWidth ?? 0\n            }\n          }\n        ]\n      }\n    ];\n  }\n  animateEmptyUpdateReady(data) {\n    const { markerSelection, labelSelection, annotationSelections } = data;\n    markerScaleInAnimation(this, this.ctx.animationManager, markerSelection);\n    seriesLabelFadeInAnimation(this, \"labels\", this.ctx.animationManager, labelSelection);\n    seriesLabelFadeInAnimation(this, \"annotations\", this.ctx.animationManager, ...annotationSelections);\n  }\n  isLabelEnabled() {\n    return this.properties.label.enabled;\n  }\n  nodeFactory() {\n    return new Group();\n  }\n  getFormattedMarkerStyle(datum) {\n    const { xKey, yKey, labelKey } = this.properties;\n    return this.getMarkerStyle(this.properties.marker, { datum, xKey, yKey, labelKey, highlighted: true });\n  }\n  computeFocusBounds(opts) {\n    return computeMarkerFocusBounds(this, opts);\n  }\n};\nScatterSeries.className = \"ScatterSeries\";\nScatterSeries.type = \"scatter\";\n\n// packages/ag-charts-community/src/chart/series/cartesian/scatterSeriesModule.ts\nvar ScatterSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  identifier: \"scatter\",\n  moduleFactory: (ctx) => new ScatterSeries(ctx),\n  tooltipDefaults: { range: \"nearest\" },\n  defaultAxes: [\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"bottom\" /* BOTTOM */\n    },\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"left\" /* LEFT */\n    }\n  ],\n  themeTemplate: {\n    series: {\n      shape: \"circle\",\n      size: 7,\n      fillOpacity: 0.8,\n      tooltip: { position: { type: \"node\" } },\n      label: {\n        enabled: false,\n        fontSize: 12,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_LABEL_COLOUR\n      },\n      errorBar: {\n        cap: {\n          lengthRatio: 1\n        }\n      }\n    }\n  },\n  paletteFactory: singleSeriesPaletteFactory\n};\n\n// packages/ag-charts-community/src/scene/sectorBox.ts\nvar SectorBox = class _SectorBox {\n  constructor(startAngle, endAngle, innerRadius, outerRadius) {\n    this.startAngle = startAngle;\n    this.endAngle = endAngle;\n    this.innerRadius = innerRadius;\n    this.outerRadius = outerRadius;\n  }\n  clone() {\n    const { startAngle, endAngle, innerRadius, outerRadius } = this;\n    return new _SectorBox(startAngle, endAngle, innerRadius, outerRadius);\n  }\n  equals(other) {\n    return this.startAngle === other.startAngle && this.endAngle === other.endAngle && this.innerRadius === other.innerRadius && this.outerRadius === other.outerRadius;\n  }\n  [interpolate](other, d) {\n    return new _SectorBox(\n      this.startAngle * (1 - d) + other.startAngle * d,\n      this.endAngle * (1 - d) + other.endAngle * d,\n      this.innerRadius * (1 - d) + other.innerRadius * d,\n      this.outerRadius * (1 - d) + other.outerRadius * d\n    );\n  }\n};\n\n// packages/ag-charts-community/src/scene/util/sector.ts\nfunction sectorBox({ startAngle, endAngle, innerRadius, outerRadius }) {\n  let x0 = Infinity;\n  let y0 = Infinity;\n  let x1 = -Infinity;\n  let y1 = -Infinity;\n  const addPoint = (x, y) => {\n    x0 = Math.min(x, x0);\n    y0 = Math.min(y, y0);\n    x1 = Math.max(x, x1);\n    y1 = Math.max(y, y1);\n  };\n  addPoint(innerRadius * Math.cos(startAngle), innerRadius * Math.sin(startAngle));\n  addPoint(innerRadius * Math.cos(endAngle), innerRadius * Math.sin(endAngle));\n  addPoint(outerRadius * Math.cos(startAngle), outerRadius * Math.sin(startAngle));\n  addPoint(outerRadius * Math.cos(endAngle), outerRadius * Math.sin(endAngle));\n  if (isBetweenAngles(0, startAngle, endAngle)) {\n    addPoint(outerRadius, 0);\n  }\n  if (isBetweenAngles(Math.PI * 0.5, startAngle, endAngle)) {\n    addPoint(0, outerRadius);\n  }\n  if (isBetweenAngles(Math.PI, startAngle, endAngle)) {\n    addPoint(-outerRadius, 0);\n  }\n  if (isBetweenAngles(Math.PI * 1.5, startAngle, endAngle)) {\n    addPoint(0, -outerRadius);\n  }\n  return new BBox(x0, y0, x1 - x0, y1 - y0);\n}\nfunction isPointInSector(x, y, sector) {\n  const radius = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));\n  const { innerRadius, outerRadius } = sector;\n  if (sector.startAngle === sector.endAngle || radius < Math.min(innerRadius, outerRadius) || radius > Math.max(innerRadius, outerRadius)) {\n    return false;\n  }\n  const startAngle = normalizeAngle180(sector.startAngle);\n  const endAngle = normalizeAngle180(sector.endAngle);\n  const angle2 = Math.atan2(y, x);\n  return startAngle < endAngle ? angle2 <= endAngle && angle2 >= startAngle : angle2 <= endAngle && angle2 >= -Math.PI || angle2 >= startAngle && angle2 <= Math.PI;\n}\nfunction lineCollidesSector(line, sector) {\n  const { startAngle, endAngle, innerRadius, outerRadius } = sector;\n  const outerStart = { x: outerRadius * Math.cos(startAngle), y: outerRadius * Math.sin(startAngle) };\n  const outerEnd = { x: outerRadius * Math.cos(endAngle), y: outerRadius * Math.sin(endAngle) };\n  const innerStart = innerRadius === 0 ? { x: 0, y: 0 } : { x: innerRadius * Math.cos(startAngle), y: innerRadius * Math.sin(startAngle) };\n  const innerEnd = innerRadius === 0 ? { x: 0, y: 0 } : { x: innerRadius * Math.cos(endAngle), y: innerRadius * Math.sin(endAngle) };\n  return segmentIntersection(\n    line.start.x,\n    line.start.y,\n    line.end.x,\n    line.end.y,\n    outerStart.x,\n    outerStart.y,\n    innerStart.x,\n    innerStart.y\n  ) || segmentIntersection(\n    line.start.x,\n    line.start.y,\n    line.end.x,\n    line.end.y,\n    outerEnd.x,\n    outerEnd.y,\n    innerEnd.x,\n    innerEnd.y\n  ) || arcIntersections(\n    0,\n    0,\n    outerRadius,\n    startAngle,\n    endAngle,\n    true,\n    line.start.x,\n    line.start.y,\n    line.end.x,\n    line.end.y\n  );\n}\nfunction boxCollidesSector(box, sector) {\n  const topLeft = { x: box.x, y: box.y };\n  const topRight = { x: box.x + box.width, y: box.y };\n  const bottomLeft = { x: box.x, y: box.y + box.height };\n  const bottomRight = { x: box.x + box.width, y: box.y + box.height };\n  return lineCollidesSector({ start: topLeft, end: topRight }, sector) || lineCollidesSector({ start: bottomLeft, end: bottomRight }, sector);\n}\nfunction radiiScalingFactor(r, sweep, a, b) {\n  if (a === 0 && b === 0)\n    return 0;\n  const fs1 = Math.asin(Math.abs(1 * a) / (r + 1 * a)) + Math.asin(Math.abs(1 * b) / (r + 1 * b)) - sweep;\n  if (fs1 < 0)\n    return 1;\n  let start2 = 0;\n  let end2 = 1;\n  for (let i = 0; i < 8; i += 1) {\n    const s = (start2 + end2) / 2;\n    const fs = Math.asin(Math.abs(s * a) / (r + s * a)) + Math.asin(Math.abs(s * b) / (r + s * b)) - sweep;\n    if (fs < 0) {\n      start2 = s;\n    } else {\n      end2 = s;\n    }\n  }\n  return start2;\n}\nvar delta3 = 1e-6;\nfunction clockwiseAngle2(angle2, relativeToStartAngle) {\n  if (angleBetween(angle2, relativeToStartAngle) < delta3) {\n    return relativeToStartAngle;\n  } else {\n    return normalizeAngle360(angle2 - relativeToStartAngle) + relativeToStartAngle;\n  }\n}\nfunction clockwiseAngles2(startAngle, endAngle, relativeToStartAngle = 0) {\n  const fullPie = Math.abs(endAngle - startAngle) >= 2 * Math.PI;\n  const sweepAngle = fullPie ? 2 * Math.PI : normalizeAngle360(endAngle - startAngle);\n  startAngle = clockwiseAngle2(startAngle, relativeToStartAngle);\n  endAngle = startAngle + sweepAngle;\n  return { startAngle, endAngle };\n}\nfunction arcRadialLineIntersectionAngle(cx, cy, r, startAngle, endAngle, clipAngle) {\n  const sinA = Math.sin(clipAngle);\n  const cosA = Math.cos(clipAngle);\n  const c = cx ** 2 + cy ** 2 - r ** 2;\n  let p0x = NaN;\n  let p0y = NaN;\n  let p1x = NaN;\n  let p1y = NaN;\n  if (cosA > 0.5) {\n    const tanA = sinA / cosA;\n    const a = 1 + tanA ** 2;\n    const b = -2 * (cx + cy * tanA);\n    const d = b ** 2 - 4 * a * c;\n    if (d < 0)\n      return;\n    const x0 = (-b + Math.sqrt(d)) / (2 * a);\n    const x1 = (-b - Math.sqrt(d)) / (2 * a);\n    p0x = x0;\n    p0y = x0 * tanA;\n    p1x = x1;\n    p1y = x1 * tanA;\n  } else {\n    const cotA = cosA / sinA;\n    const a = 1 + cotA ** 2;\n    const b = -2 * (cy + cx * cotA);\n    const d = b ** 2 - 4 * a * c;\n    if (d < 0)\n      return;\n    const y0 = (-b + Math.sqrt(d)) / (2 * a);\n    const y1 = (-b - Math.sqrt(d)) / (2 * a);\n    p0x = y0 * cotA;\n    p0y = y0;\n    p1x = y1 * cotA;\n    p1y = y1;\n  }\n  const normalisedX = cosA;\n  const normalisedY = sinA;\n  const p0DotNormalized = p0x * normalisedX + p0y * normalisedY;\n  const p1DotNormalized = p1x * normalisedX + p1y * normalisedY;\n  const a0 = p0DotNormalized > 0 ? clockwiseAngle2(Math.atan2(p0y - cy, p0x - cx), startAngle) : NaN;\n  const a1 = p1DotNormalized > 0 ? clockwiseAngle2(Math.atan2(p1y - cy, p1x - cx), startAngle) : NaN;\n  if (a0 >= startAngle && a0 <= endAngle) {\n    return a0;\n  } else if (a1 >= startAngle && a1 <= endAngle) {\n    return a1;\n  }\n}\nfunction arcCircleIntersectionAngle(cx, cy, r, startAngle, endAngle, circleR) {\n  const d = Math.hypot(cx, cy);\n  const d1 = (d ** 2 - r ** 2 + circleR ** 2) / (2 * d);\n  const d2 = d - d1;\n  const theta = Math.atan2(cy, cx);\n  const deltaTheta = Math.acos(-d2 / r);\n  const a0 = clockwiseAngle2(theta + deltaTheta, startAngle);\n  const a1 = clockwiseAngle2(theta - deltaTheta, startAngle);\n  if (a0 >= startAngle && a0 <= endAngle) {\n    return a0;\n  } else if (a1 >= startAngle && a1 <= endAngle) {\n    return a1;\n  }\n}\n\n// packages/ag-charts-community/src/scene/shape/sector.ts\nvar Arc = class {\n  constructor(cx, cy, r, a0, a1) {\n    this.cx = cx;\n    this.cy = cy;\n    this.r = r;\n    this.a0 = a0;\n    this.a1 = a1;\n    if (this.a0 >= this.a1) {\n      this.a0 = NaN;\n      this.a1 = NaN;\n    }\n  }\n  isValid() {\n    return Number.isFinite(this.a0) && Number.isFinite(this.a1);\n  }\n  pointAt(a) {\n    return {\n      x: this.cx + this.r * Math.cos(a),\n      y: this.cy + this.r * Math.sin(a)\n    };\n  }\n  clipStart(a) {\n    if (a == null || !this.isValid() || a < this.a0)\n      return;\n    this.a0 = a;\n    if (Number.isNaN(a) || this.a0 >= this.a1) {\n      this.a0 = NaN;\n      this.a1 = NaN;\n    }\n  }\n  clipEnd(a) {\n    if (a == null || !this.isValid() || a > this.a1)\n      return;\n    this.a1 = a;\n    if (Number.isNaN(a) || this.a0 >= this.a1) {\n      this.a0 = NaN;\n      this.a1 = NaN;\n    }\n  }\n};\nvar Sector = class extends Path {\n  constructor() {\n    super(...arguments);\n    this.centerX = 0;\n    this.centerY = 0;\n    this.innerRadius = 10;\n    this.outerRadius = 20;\n    this.startAngle = 0;\n    this.endAngle = Math.PI * 2;\n    this.clipSector = void 0;\n    this.concentricEdgeInset = 0;\n    this.radialEdgeInset = 0;\n    this.startOuterCornerRadius = 0;\n    this.endOuterCornerRadius = 0;\n    this.startInnerCornerRadius = 0;\n    this.endInnerCornerRadius = 0;\n  }\n  set inset(value) {\n    this.concentricEdgeInset = value;\n    this.radialEdgeInset = value;\n  }\n  set cornerRadius(value) {\n    this.startOuterCornerRadius = value;\n    this.endOuterCornerRadius = value;\n    this.startInnerCornerRadius = value;\n    this.endInnerCornerRadius = value;\n  }\n  computeBBox() {\n    return sectorBox(this).translate(this.centerX, this.centerY);\n  }\n  normalizedRadii() {\n    const { concentricEdgeInset } = this;\n    let { innerRadius, outerRadius } = this;\n    innerRadius = innerRadius > 0 ? innerRadius + concentricEdgeInset : 0;\n    outerRadius = Math.max(outerRadius - concentricEdgeInset, 0);\n    return { innerRadius, outerRadius };\n  }\n  normalizedClipSector() {\n    const { clipSector } = this;\n    if (clipSector == null)\n      return;\n    const { startAngle, endAngle } = clockwiseAngles2(this.startAngle, this.endAngle);\n    const { innerRadius, outerRadius } = this.normalizedRadii();\n    const clipAngles = clockwiseAngles2(clipSector.startAngle, clipSector.endAngle, startAngle);\n    return new SectorBox(\n      Math.max(startAngle, clipAngles.startAngle),\n      Math.min(endAngle, clipAngles.endAngle),\n      Math.max(innerRadius, clipSector.innerRadius),\n      Math.min(outerRadius, clipSector.outerRadius)\n    );\n  }\n  getAngleOffset(radius) {\n    return radius > 0 ? this.radialEdgeInset / radius : 0;\n  }\n  arc(r, angleSweep, a0, a1, outerArc, innerArc, start2, inner) {\n    if (r <= 0)\n      return;\n    const { startAngle, endAngle } = clockwiseAngles2(this.startAngle, this.endAngle);\n    const { innerRadius, outerRadius } = this.normalizedRadii();\n    const clipSector = this.normalizedClipSector();\n    if (inner && innerRadius <= 0)\n      return;\n    const angleOffset = inner ? this.getAngleOffset(innerRadius + r) : this.getAngleOffset(outerRadius - r);\n    const angle2 = start2 ? startAngle + angleOffset + angleSweep : endAngle - angleOffset - angleSweep;\n    const radius = inner ? innerRadius + r : outerRadius - r;\n    const cx = radius * Math.cos(angle2);\n    const cy = radius * Math.sin(angle2);\n    if (clipSector != null) {\n      const delta4 = 1e-6;\n      if (!start2 && !(angle2 >= startAngle - delta4 && angle2 <= clipSector.endAngle - delta4))\n        return;\n      if (start2 && !(angle2 >= clipSector.startAngle + delta4 && angle2 <= endAngle - delta4))\n        return;\n      if (inner && radius < clipSector.innerRadius - delta4)\n        return;\n      if (!inner && radius > clipSector.outerRadius + delta4)\n        return;\n    }\n    const arc = new Arc(cx, cy, r, a0, a1);\n    if (clipSector != null) {\n      if (inner) {\n        arc.clipStart(arcRadialLineIntersectionAngle(cx, cy, r, a0, a1, clipSector.endAngle));\n        arc.clipEnd(arcRadialLineIntersectionAngle(cx, cy, r, a0, a1, clipSector.startAngle));\n      } else {\n        arc.clipStart(arcRadialLineIntersectionAngle(cx, cy, r, a0, a1, clipSector.startAngle));\n        arc.clipEnd(arcRadialLineIntersectionAngle(cx, cy, r, a0, a1, clipSector.endAngle));\n      }\n      let circleClipStart;\n      let circleClipEnd;\n      if (start2) {\n        circleClipStart = arcCircleIntersectionAngle(cx, cy, r, a0, a1, clipSector.innerRadius);\n        circleClipEnd = arcCircleIntersectionAngle(cx, cy, r, a0, a1, clipSector.outerRadius);\n      } else {\n        circleClipStart = arcCircleIntersectionAngle(cx, cy, r, a0, a1, clipSector.outerRadius);\n        circleClipEnd = arcCircleIntersectionAngle(cx, cy, r, a0, a1, clipSector.innerRadius);\n      }\n      arc.clipStart(circleClipStart);\n      arc.clipEnd(circleClipEnd);\n      if (circleClipStart != null) {\n        const { x: x2, y: y2 } = arc.pointAt(circleClipStart);\n        const theta2 = clockwiseAngle2(Math.atan2(y2, x2), startAngle);\n        if (start2) {\n          innerArc?.clipStart(theta2);\n        } else {\n          outerArc.clipEnd(theta2);\n        }\n      }\n      if (circleClipEnd != null) {\n        const { x: x2, y: y2 } = arc.pointAt(circleClipEnd);\n        const theta2 = clockwiseAngle2(Math.atan2(y2, x2), startAngle);\n        if (start2) {\n          outerArc.clipStart(theta2);\n        } else {\n          innerArc?.clipEnd(theta2);\n        }\n      }\n    }\n    if (clipSector != null) {\n      const { x: x2, y: y2 } = arc.pointAt((arc.a0 + arc.a1) / 2);\n      if (!isPointInSector(x2, y2, clipSector))\n        return;\n    }\n    const { x, y } = arc.pointAt(start2 === inner ? arc.a0 : arc.a1);\n    const theta = clockwiseAngle2(Math.atan2(y, x), startAngle);\n    const radialArc = inner ? innerArc : outerArc;\n    if (start2) {\n      radialArc?.clipStart(theta);\n    } else {\n      radialArc?.clipEnd(theta);\n    }\n    return arc;\n  }\n  updatePath() {\n    const delta4 = 1e-6;\n    const { path, centerX, centerY, concentricEdgeInset, radialEdgeInset } = this;\n    let { startOuterCornerRadius, endOuterCornerRadius, startInnerCornerRadius, endInnerCornerRadius } = this;\n    const { startAngle, endAngle } = clockwiseAngles2(this.startAngle, this.endAngle);\n    const { innerRadius, outerRadius } = this.normalizedRadii();\n    const clipSector = this.normalizedClipSector();\n    const sweepAngle = endAngle - startAngle;\n    const fullPie = sweepAngle >= 2 * Math.PI - delta4;\n    path.clear();\n    if (innerRadius === 0 && outerRadius === 0 || innerRadius > outerRadius) {\n      return;\n    } else if ((clipSector?.startAngle ?? startAngle) === (clipSector?.endAngle ?? endAngle)) {\n      return;\n    } else if (fullPie && this.clipSector == null && startOuterCornerRadius === 0 && endOuterCornerRadius === 0 && startInnerCornerRadius === 0 && endInnerCornerRadius === 0) {\n      path.moveTo(centerX + outerRadius * Math.cos(startAngle), centerY + outerRadius * Math.sin(startAngle));\n      path.arc(centerX, centerY, outerRadius, startAngle, endAngle);\n      if (innerRadius > concentricEdgeInset) {\n        path.moveTo(centerX + innerRadius * Math.cos(endAngle), centerY + innerRadius * Math.sin(endAngle));\n        path.arc(centerX, centerY, innerRadius, endAngle, startAngle, true);\n      }\n      path.closePath();\n      return;\n    } else if (this.clipSector == null && Math.abs(innerRadius - outerRadius) < 1e-6) {\n      path.arc(centerX, centerY, outerRadius, startAngle, endAngle, false);\n      path.arc(centerX, centerY, outerRadius, endAngle, startAngle, true);\n      path.closePath();\n      return;\n    }\n    const innerAngleOffset = this.getAngleOffset(innerRadius);\n    const outerAngleOffset = this.getAngleOffset(outerRadius);\n    const outerAngleExceeded = sweepAngle < 2 * outerAngleOffset;\n    if (outerAngleExceeded)\n      return;\n    const hasInnerSweep = (clipSector?.innerRadius ?? innerRadius) > concentricEdgeInset;\n    const innerAngleExceeded = innerRadius < concentricEdgeInset || sweepAngle < 2 * innerAngleOffset;\n    const radialLength = outerRadius - innerRadius;\n    const maxRadialLength = Math.max(\n      startOuterCornerRadius,\n      startInnerCornerRadius,\n      endOuterCornerRadius,\n      endInnerCornerRadius\n    );\n    const initialScalingFactor = maxRadialLength > 0 ? Math.min(radialLength / maxRadialLength, 1) : 1;\n    startOuterCornerRadius *= initialScalingFactor;\n    endOuterCornerRadius *= initialScalingFactor;\n    startInnerCornerRadius *= initialScalingFactor;\n    endInnerCornerRadius *= initialScalingFactor;\n    const outerScalingFactor = radiiScalingFactor(\n      outerRadius,\n      sweepAngle - 2 * outerAngleOffset,\n      -startOuterCornerRadius,\n      -endOuterCornerRadius\n    );\n    startOuterCornerRadius *= outerScalingFactor;\n    endOuterCornerRadius *= outerScalingFactor;\n    if (!innerAngleExceeded && hasInnerSweep) {\n      const innerScalingFactor = radiiScalingFactor(\n        innerRadius,\n        sweepAngle - 2 * innerAngleOffset,\n        startInnerCornerRadius,\n        endInnerCornerRadius\n      );\n      startInnerCornerRadius *= innerScalingFactor;\n      endInnerCornerRadius *= innerScalingFactor;\n    } else {\n      startInnerCornerRadius = 0;\n      endInnerCornerRadius = 0;\n    }\n    const maxCombinedRadialLength = Math.max(\n      startOuterCornerRadius + startInnerCornerRadius,\n      endOuterCornerRadius + endInnerCornerRadius\n    );\n    const edgesScalingFactor = maxCombinedRadialLength > 0 ? Math.min(radialLength / maxCombinedRadialLength, 1) : 1;\n    startOuterCornerRadius *= edgesScalingFactor;\n    endOuterCornerRadius *= edgesScalingFactor;\n    startInnerCornerRadius *= edgesScalingFactor;\n    endInnerCornerRadius *= edgesScalingFactor;\n    let startOuterCornerRadiusAngleSweep = 0;\n    let endOuterCornerRadiusAngleSweep = 0;\n    const startOuterCornerRadiusSweep = startOuterCornerRadius / (outerRadius - startOuterCornerRadius);\n    const endOuterCornerRadiusSweep = endOuterCornerRadius / (outerRadius - endOuterCornerRadius);\n    if (startOuterCornerRadiusSweep >= 0 && startOuterCornerRadiusSweep < 1 - delta4) {\n      startOuterCornerRadiusAngleSweep = Math.asin(startOuterCornerRadiusSweep);\n    } else {\n      startOuterCornerRadiusAngleSweep = sweepAngle / 2;\n      const maxStartOuterCornerRadius = outerRadius / (1 / Math.sin(startOuterCornerRadiusAngleSweep) + 1);\n      startOuterCornerRadius = Math.min(maxStartOuterCornerRadius, startOuterCornerRadius);\n    }\n    if (endOuterCornerRadiusSweep >= 0 && endOuterCornerRadiusSweep < 1 - delta4) {\n      endOuterCornerRadiusAngleSweep = Math.asin(endOuterCornerRadiusSweep);\n    } else {\n      endOuterCornerRadiusAngleSweep = sweepAngle / 2;\n      const maxEndOuterCornerRadius = outerRadius / (1 / Math.sin(endOuterCornerRadiusAngleSweep) + 1);\n      endOuterCornerRadius = Math.min(maxEndOuterCornerRadius, endOuterCornerRadius);\n    }\n    const startInnerCornerRadiusAngleSweep = Math.asin(\n      startInnerCornerRadius / (innerRadius + startInnerCornerRadius)\n    );\n    const endInnerCornerRadiusAngleSweep = Math.asin(endInnerCornerRadius / (innerRadius + endInnerCornerRadius));\n    const outerArcRadius = clipSector?.outerRadius ?? outerRadius;\n    const outerArcRadiusOffset = this.getAngleOffset(outerArcRadius);\n    const outerArc = new Arc(\n      0,\n      0,\n      outerArcRadius,\n      startAngle + outerArcRadiusOffset,\n      endAngle - outerArcRadiusOffset\n    );\n    const innerArcRadius = clipSector?.innerRadius ?? innerRadius;\n    const innerArcRadiusOffset = this.getAngleOffset(innerArcRadius);\n    const innerArc = hasInnerSweep ? new Arc(0, 0, innerArcRadius, startAngle + innerArcRadiusOffset, endAngle - innerArcRadiusOffset) : void 0;\n    if (clipSector != null) {\n      outerArc.clipStart(clipSector.startAngle);\n      outerArc.clipEnd(clipSector.endAngle);\n      innerArc?.clipStart(clipSector.startAngle);\n      innerArc?.clipEnd(clipSector.endAngle);\n    }\n    const startOuterArc = this.arc(\n      startOuterCornerRadius,\n      startOuterCornerRadiusAngleSweep,\n      startAngle - Math.PI * 0.5,\n      startAngle + startOuterCornerRadiusAngleSweep,\n      outerArc,\n      innerArc,\n      true,\n      false\n    );\n    const endOuterArc = this.arc(\n      endOuterCornerRadius,\n      endOuterCornerRadiusAngleSweep,\n      endAngle - endOuterCornerRadiusAngleSweep,\n      endAngle + Math.PI * 0.5,\n      outerArc,\n      innerArc,\n      false,\n      false\n    );\n    const endInnerArc = this.arc(\n      endInnerCornerRadius,\n      endInnerCornerRadiusAngleSweep,\n      endAngle + Math.PI * 0.5,\n      endAngle + Math.PI - endInnerCornerRadiusAngleSweep,\n      outerArc,\n      innerArc,\n      false,\n      true\n    );\n    const startInnerArc = this.arc(\n      startInnerCornerRadius,\n      startInnerCornerRadiusAngleSweep,\n      startAngle + Math.PI + startInnerCornerRadiusAngleSweep,\n      startAngle + Math.PI * 1.5,\n      outerArc,\n      innerArc,\n      true,\n      true\n    );\n    if (innerAngleExceeded) {\n      const x = sweepAngle < Math.PI * 0.5 ? radialEdgeInset * (1 + Math.cos(sweepAngle)) / Math.sin(sweepAngle) : NaN;\n      let r;\n      if (x > 0 && x < outerRadius) {\n        r = Math.max(Math.hypot(radialEdgeInset, x), innerRadius);\n      } else {\n        r = radialEdgeInset;\n      }\n      r = Math.max(r, innerRadius);\n      const midAngle = startAngle + sweepAngle * 0.5;\n      path.moveTo(centerX + r * Math.cos(midAngle), centerY + r * Math.sin(midAngle));\n    } else if (startInnerArc?.isValid() === true || innerArc?.isValid() === true) {\n    } else {\n      const midAngle = startAngle + sweepAngle / 2;\n      const cx = innerRadius * Math.cos(midAngle);\n      const cy = innerRadius * Math.sin(midAngle);\n      path.moveTo(centerX + cx, centerY + cy);\n    }\n    if (startOuterArc?.isValid() === true) {\n      const { cx, cy, r, a0, a1 } = startOuterArc;\n      path.arc(centerX + cx, centerY + cy, r, a0, a1);\n    }\n    if (outerArc.isValid()) {\n      const { r, a0, a1 } = outerArc;\n      path.arc(centerX, centerY, r, a0, a1);\n    }\n    if (endOuterArc?.isValid() === true) {\n      const { cx, cy, r, a0, a1 } = endOuterArc;\n      path.arc(centerX + cx, centerY + cy, r, a0, a1);\n    }\n    if (!innerAngleExceeded) {\n      if (endInnerArc?.isValid() === true) {\n        const { cx, cy, r, a0, a1 } = endInnerArc;\n        path.arc(centerX + cx, centerY + cy, r, a0, a1);\n      }\n      if (innerArc?.isValid() === true) {\n        const { r, a0, a1 } = innerArc;\n        path.arc(centerX, centerY, r, a1, a0, true);\n      }\n      if (startInnerArc?.isValid() === true) {\n        const { cx, cy, r, a0, a1 } = startInnerArc;\n        path.arc(centerX + cx, centerY + cy, r, a0, a1);\n      }\n    }\n    path.closePath();\n  }\n  isPointInPath(x, y) {\n    const { startAngle, endAngle, innerRadius, outerRadius } = this.clipSector ?? this;\n    return isPointInSector(x - this.centerX, y - this.centerY, {\n      startAngle,\n      endAngle,\n      innerRadius: Math.min(innerRadius, outerRadius),\n      outerRadius: Math.max(innerRadius, outerRadius)\n    });\n  }\n};\nSector.className = \"Sector\";\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"centerX\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"centerY\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"innerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"outerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"startAngle\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"endAngle\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"clipSector\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"concentricEdgeInset\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"radialEdgeInset\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"startOuterCornerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"endOuterCornerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"startInnerCornerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"endInnerCornerRadius\", 2);\n\n// packages/ag-charts-community/src/chart/themes/defaultColors.ts\nvar DEFAULT_FILLS = {\n  BLUE: \"#5090dc\",\n  ORANGE: \"#ffa03a\",\n  GREEN: \"#459d55\",\n  CYAN: \"#34bfe1\",\n  YELLOW: \"#e1cc00\",\n  VIOLET: \"#9669cb\",\n  GRAY: \"#b5b5b5\",\n  MAGENTA: \"#bd5aa7\",\n  BROWN: \"#8a6224\",\n  RED: \"#ef5452\"\n};\nvar DEFAULT_STROKES = {\n  BLUE: \"#2b5c95\",\n  ORANGE: \"#cc6f10\",\n  GREEN: \"#1e652e\",\n  CYAN: \"#18859e\",\n  YELLOW: \"#a69400\",\n  VIOLET: \"#603c88\",\n  GRAY: \"#575757\",\n  MAGENTA: \"#7d2f6d\",\n  BROWN: \"#4f3508\",\n  RED: \"#a82529\"\n};\n\n// packages/ag-charts-community/src/chart/series/polar/donutSeriesProperties.ts\nvar DonutTitle = class extends Caption {\n  constructor() {\n    super(...arguments);\n    this.showInLegend = false;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], DonutTitle.prototype, \"showInLegend\", 2);\nvar DonutInnerLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.spacing = 2;\n  }\n  set(properties, _reset) {\n    return super.set(properties);\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], DonutInnerLabel.prototype, \"text\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], DonutInnerLabel.prototype, \"spacing\", 2);\nvar DonutInnerCircle = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.fill = \"transparent\";\n    this.fillOpacity = 1;\n  }\n};\n__decorateClass([\n  Validate(COLOR_STRING)\n], DonutInnerCircle.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO)\n], DonutInnerCircle.prototype, \"fillOpacity\", 2);\nvar DonutSeriesCalloutLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.offset = 3;\n    this.minAngle = 0;\n    this.minSpacing = 4;\n    this.maxCollisionOffset = 50;\n    this.avoidCollisions = true;\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesCalloutLabel.prototype, \"offset\", 2);\n__decorateClass([\n  Validate(DEGREE)\n], DonutSeriesCalloutLabel.prototype, \"minAngle\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesCalloutLabel.prototype, \"minSpacing\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesCalloutLabel.prototype, \"maxCollisionOffset\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], DonutSeriesCalloutLabel.prototype, \"avoidCollisions\", 2);\nvar DonutSeriesSectorLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.positionOffset = 0;\n    this.positionRatio = 0.5;\n  }\n};\n__decorateClass([\n  Validate(NUMBER)\n], DonutSeriesSectorLabel.prototype, \"positionOffset\", 2);\n__decorateClass([\n  Validate(RATIO)\n], DonutSeriesSectorLabel.prototype, \"positionRatio\", 2);\nvar DonutSeriesCalloutLine = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.length = 10;\n    this.strokeWidth = 1;\n  }\n};\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY, { optional: true })\n], DonutSeriesCalloutLine.prototype, \"colors\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesCalloutLine.prototype, \"length\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesCalloutLine.prototype, \"strokeWidth\", 2);\nvar DonutSeriesProperties = class extends SeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.fills = Object.values(DEFAULT_FILLS);\n    this.strokes = Object.values(DEFAULT_STROKES);\n    this.fillOpacity = 1;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.cornerRadius = 0;\n    this.rotation = 0;\n    this.outerRadiusOffset = 0;\n    this.outerRadiusRatio = 1;\n    this.strokeWidth = 1;\n    this.sectorSpacing = 0;\n    this.innerLabels = new PropertiesArray(DonutInnerLabel);\n    this.title = new DonutTitle();\n    this.innerCircle = new DonutInnerCircle();\n    this.shadow = new DropShadow();\n    this.calloutLabel = new DonutSeriesCalloutLabel();\n    this.sectorLabel = new DonutSeriesSectorLabel();\n    this.calloutLine = new DonutSeriesCalloutLine();\n    this.tooltip = new SeriesTooltip();\n  }\n  isValid() {\n    const superIsValid = super.isValid();\n    if (this.innerRadiusRatio == null && this.innerRadiusOffset == null) {\n      Logger.warnOnce(\n        \"Either an [innerRadiusRatio] or an [innerRadiusOffset] must be set to render a donut series.\"\n      );\n      return false;\n    }\n    return superIsValid;\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], DonutSeriesProperties.prototype, \"angleKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"angleName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"angleFilterKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"radiusKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"radiusName\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], DonutSeriesProperties.prototype, \"radiusMin\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], DonutSeriesProperties.prototype, \"radiusMax\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"calloutLabelKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"calloutLabelName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"sectorLabelKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"sectorLabelName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"legendItemKey\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], DonutSeriesProperties.prototype, \"fills\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], DonutSeriesProperties.prototype, \"strokes\", 2);\n__decorateClass([\n  Validate(RATIO)\n], DonutSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(RATIO)\n], DonutSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH)\n], DonutSeriesProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesProperties.prototype, \"cornerRadius\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], DonutSeriesProperties.prototype, \"itemStyler\", 2);\n__decorateClass([\n  Validate(DEGREE)\n], DonutSeriesProperties.prototype, \"rotation\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], DonutSeriesProperties.prototype, \"outerRadiusOffset\", 2);\n__decorateClass([\n  Validate(RATIO)\n], DonutSeriesProperties.prototype, \"outerRadiusRatio\", 2);\n__decorateClass([\n  Validate(NUMBER, { optional: true })\n], DonutSeriesProperties.prototype, \"innerRadiusOffset\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], DonutSeriesProperties.prototype, \"innerRadiusRatio\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], DonutSeriesProperties.prototype, \"sectorSpacing\", 2);\n__decorateClass([\n  Validate(OBJECT_ARRAY)\n], DonutSeriesProperties.prototype, \"innerLabels\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], DonutSeriesProperties.prototype, \"title\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], DonutSeriesProperties.prototype, \"innerCircle\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], DonutSeriesProperties.prototype, \"shadow\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], DonutSeriesProperties.prototype, \"calloutLabel\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], DonutSeriesProperties.prototype, \"sectorLabel\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], DonutSeriesProperties.prototype, \"calloutLine\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], DonutSeriesProperties.prototype, \"tooltip\", 2);\n\n// packages/ag-charts-community/src/chart/series/polar/pieUtil.ts\nfunction preparePieSeriesAnimationFunctions(initialLoad, rotationDegrees, scaleFn, oldScaleFn) {\n  const scale2 = [scaleFn.convert(0), scaleFn.convert(1)];\n  const oldScale = [oldScaleFn.convert(0), oldScaleFn.convert(1)];\n  const rotation = Math.PI / -2 + toRadians(rotationDegrees);\n  const phase = initialLoad ? \"initial\" : \"update\";\n  const scaleToNewRadius = ({ radius }) => {\n    return { innerRadius: scale2[0], outerRadius: scale2[0] + (scale2[1] - scale2[0]) * radius };\n  };\n  const scaleToOldRadius = ({ radius }) => {\n    return { innerRadius: oldScale[0], outerRadius: oldScale[0] + (oldScale[1] - oldScale[0]) * radius };\n  };\n  const fromFn = (sect, datum, status, { prevFromProps }) => {\n    let { startAngle, endAngle, innerRadius, outerRadius } = sect;\n    let { fill, stroke } = datum.sectorFormat;\n    if (status === \"unknown\" || status === \"added\" && !prevFromProps) {\n      startAngle = rotation;\n      endAngle = rotation;\n      innerRadius = datum.innerRadius;\n      outerRadius = datum.outerRadius;\n    } else if (status === \"added\" && prevFromProps) {\n      startAngle = prevFromProps.endAngle ?? rotation;\n      endAngle = prevFromProps.endAngle ?? rotation;\n      innerRadius = prevFromProps.innerRadius ?? datum.innerRadius;\n      outerRadius = prevFromProps.outerRadius ?? datum.outerRadius;\n    }\n    if (status === \"added\" && !initialLoad) {\n      const radii = scaleToOldRadius(datum);\n      innerRadius = radii.innerRadius;\n      outerRadius = radii.outerRadius;\n    }\n    if (status === \"updated\") {\n      fill = sect.fill ?? fill;\n      stroke = sect.stroke ?? stroke;\n    }\n    return { startAngle, endAngle, innerRadius, outerRadius, fill, stroke, phase };\n  };\n  const toFn = (_sect, datum, status, { prevLive }) => {\n    let { startAngle, endAngle, innerRadius, outerRadius } = datum;\n    const { stroke, fill } = datum.sectorFormat;\n    if (status === \"removed\" && prevLive) {\n      startAngle = prevLive.datum?.endAngle;\n      endAngle = prevLive.datum?.endAngle;\n    } else if (status === \"removed\" && !prevLive) {\n      startAngle = rotation;\n      endAngle = rotation;\n    }\n    if (status === \"removed\") {\n      const radii = scaleToNewRadius(datum);\n      innerRadius = radii.innerRadius;\n      outerRadius = radii.outerRadius;\n    }\n    return { startAngle, endAngle, outerRadius, innerRadius, stroke, fill };\n  };\n  const innerCircleFromFn = (node, _) => {\n    return { size: node.previousDatum?.radius ?? node.size ?? 0, phase };\n  };\n  const innerCircleToFn = (_, datum) => {\n    return { size: datum.radius ?? 0 };\n  };\n  return { nodes: { toFn, fromFn }, innerCircle: { fromFn: innerCircleFromFn, toFn: innerCircleToFn } };\n}\nfunction resetPieSelectionsFn(_node, datum) {\n  return {\n    startAngle: datum.startAngle,\n    endAngle: datum.endAngle,\n    innerRadius: datum.innerRadius,\n    outerRadius: datum.outerRadius,\n    fill: datum.sectorFormat.fill,\n    stroke: datum.sectorFormat.stroke\n  };\n}\nfunction pickByMatchingAngle(series, point) {\n  const dy = point.y - series.centerY;\n  const dx = point.x - series.centerX;\n  const angle2 = Math.atan2(dy, dx);\n  const sectors = series.getItemNodes();\n  for (const sector of sectors) {\n    if (sector.datum.missing === true)\n      continue;\n    if (isBetweenAngles(angle2, sector.startAngle, sector.endAngle)) {\n      const radius = Math.sqrt(dx * dx + dy * dy);\n      let distance3 = 0;\n      if (radius < sector.innerRadius) {\n        distance3 = sector.innerRadius - radius;\n      } else if (radius > sector.outerRadius) {\n        distance3 = radius - sector.outerRadius;\n      }\n      return { datum: sector.datum, distance: distance3 };\n    }\n  }\n  return void 0;\n}\n\n// packages/ag-charts-community/src/chart/series/polar/polarSeries.ts\nvar PolarSeries = class extends DataModelSeries {\n  constructor({\n    useLabelLayer = false,\n    pickModes = [1 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */],\n    canHaveAxes = false,\n    animationResetFns,\n    ...opts\n  }) {\n    super({\n      ...opts,\n      useLabelLayer,\n      pickModes,\n      contentGroupVirtual: false,\n      directionKeys: {\n        [\"x\" /* X */]: [\"angleKey\"],\n        [\"y\" /* Y */]: [\"radiusKey\"]\n      },\n      directionNames: {\n        [\"x\" /* X */]: [\"angleName\"],\n        [\"y\" /* Y */]: [\"radiusName\"]\n      },\n      canHaveAxes\n    });\n    this.itemGroup = this.contentGroup.appendChild(new Group());\n    this.nodeData = [];\n    this.itemSelection = Selection.select(\n      this.itemGroup,\n      () => this.nodeFactory(),\n      false\n    );\n    this.labelSelection = Selection.select(\n      this.labelGroup,\n      () => this.labelFactory(),\n      false\n    );\n    this.highlightSelection = Selection.select(\n      this.highlightGroup,\n      () => this.nodeFactory()\n    );\n    this.highlightLabelSelection = Selection.select(\n      this.highlightLabel,\n      () => this.labelFactory()\n    );\n    /**\n     * The center of the polar series (for example, the center of a pie).\n     * If the polar chart has multiple series, all of them will have their\n     * center set to the same value as a result of the polar chart layout.\n     * The center coordinates are not supposed to be set by the user.\n     */\n    this.centerX = 0;\n    this.centerY = 0;\n    /**\n     * The maximum radius the series can use.\n     * This value is set automatically as a result of the polar chart layout\n     * and is not supposed to be set by the user.\n     */\n    this.radius = 0;\n    this.itemGroup.zIndexSubOrder = [() => this._declarationOrder, 1];\n    this.animationResetFns = animationResetFns;\n    this.animationState = new StateMachine(\n      \"empty\",\n      {\n        empty: {\n          update: {\n            target: \"ready\",\n            action: (data) => this.animateEmptyUpdateReady(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\"\n        },\n        ready: {\n          updateData: \"waiting\",\n          clear: \"clearing\",\n          highlight: (data) => this.animateReadyHighlight(data),\n          highlightMarkers: (data) => this.animateReadyHighlightMarkers(data),\n          resize: (data) => this.animateReadyResize(data),\n          reset: \"empty\",\n          skip: \"ready\"\n        },\n        waiting: {\n          update: {\n            target: \"ready\",\n            action: (data) => this.animateWaitingUpdateReady(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\"\n        },\n        clearing: {\n          update: {\n            target: \"empty\",\n            action: (data) => this.animateClearingUpdateEmpty(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\"\n        }\n      },\n      () => this.checkProcessedDataAnimatable()\n    );\n  }\n  getItemNodes() {\n    return [...this.itemGroup.children()];\n  }\n  getNodeData() {\n    return this.nodeData;\n  }\n  resetAnimation(phase) {\n    if (phase === \"initial\") {\n      this.animationState.transition(\"reset\");\n    } else if (phase === \"ready\") {\n      this.animationState.transition(\"skip\");\n    }\n  }\n  labelFactory() {\n    const text = new Text();\n    text.pointerEvents = 1 /* None */;\n    return text;\n  }\n  getInnerRadius() {\n    return 0;\n  }\n  getLabelData() {\n    return [];\n  }\n  computeLabelsBBox(_options, _seriesRect) {\n    return null;\n  }\n  resetAllAnimation() {\n    const { item, label } = this.animationResetFns ?? {};\n    this.ctx.animationManager.stopByAnimationGroupId(this.id);\n    if (item) {\n      resetMotion([this.itemSelection, this.highlightSelection], item);\n    }\n    if (label) {\n      resetMotion([this.labelSelection, this.highlightLabelSelection], label);\n    }\n    this.itemSelection.cleanup();\n    this.labelSelection.cleanup();\n    this.highlightSelection.cleanup();\n    this.highlightLabelSelection.cleanup();\n  }\n  animateEmptyUpdateReady(_data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation();\n  }\n  animateWaitingUpdateReady(_data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation();\n  }\n  animateReadyHighlight(_data) {\n    const { item, label } = this.animationResetFns ?? {};\n    if (item) {\n      resetMotion([this.highlightSelection], item);\n    }\n    if (label) {\n      resetMotion([this.highlightLabelSelection], label);\n    }\n  }\n  animateReadyHighlightMarkers(_data) {\n  }\n  animateReadyResize(_data) {\n    this.resetAllAnimation();\n  }\n  animateClearingUpdateEmpty(_data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation();\n  }\n  animationTransitionClear() {\n    this.animationState.transition(\"clear\", this.getAnimationData());\n  }\n  getAnimationData(seriesRect) {\n    return { seriesRect };\n  }\n  computeFocusBounds(opts) {\n    const datum = this.getNodeData()?.[opts.datumIndex];\n    if (datum !== void 0) {\n      return this.itemSelection.select((node) => node instanceof Path && node.datum === datum)[0];\n    }\n    return void 0;\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/polar/donutSeries.ts\nvar DonutSeriesNodeEvent = class extends SeriesNodeEvent {\n  constructor(type, nativeEvent, datum, series) {\n    super(type, nativeEvent, datum, series);\n    this.angleKey = series.properties.angleKey;\n    this.radiusKey = series.properties.radiusKey;\n    this.calloutLabelKey = series.properties.calloutLabelKey;\n    this.sectorLabelKey = series.properties.sectorLabelKey;\n  }\n};\nvar DonutSeries = class extends PolarSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      pickModes: [1 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */],\n      useLabelLayer: true,\n      animationResetFns: { item: resetPieSelectionsFn, label: resetLabelFn }\n    });\n    this.properties = new DonutSeriesProperties();\n    this.phantomNodeData = void 0;\n    this.previousRadiusScale = new LinearScale();\n    this.radiusScale = new LinearScale();\n    this.phantomGroup = this.contentGroup.appendChild(new Group());\n    this.phantomSelection = Selection.select(\n      this.phantomGroup,\n      () => this.nodeFactory(),\n      false\n    );\n    this.calloutLabelGroup = this.contentGroup.appendChild(new Group({ name: \"pieCalloutLabels\" }));\n    this.calloutLabelSelection = new Selection(\n      this.calloutLabelGroup,\n      Group\n    );\n    // The group node that contains the background graphics.\n    this.backgroundGroup = this.rootGroup.appendChild(\n      new TranslatableLayer({\n        name: `${this.id}-background`,\n        zIndex: 0 /* SERIES_BACKGROUND */\n      })\n    );\n    // AG-6193 If the sum of all datums is 0, then we'll draw 1 or 2 rings to represent the empty series.\n    this.zerosumRingsGroup = this.backgroundGroup.appendChild(new Group({ name: `${this.id}-zerosumRings` }));\n    this.zerosumOuterRing = this.zerosumRingsGroup.appendChild(new Circle());\n    this.zerosumInnerRing = this.zerosumRingsGroup.appendChild(new Circle());\n    this.innerLabelsGroup = this.contentGroup.appendChild(new Group({ name: \"innerLabels\" }));\n    this.innerCircleGroup = this.backgroundGroup.appendChild(new Group({ name: `${this.id}-innerCircle` }));\n    this.innerLabelsSelection = Selection.select(this.innerLabelsGroup, Text);\n    this.innerCircleSelection = Selection.select(\n      this.innerCircleGroup,\n      Circle\n    );\n    // When a user toggles a series item (e.g. from the legend), its boolean state is recorded here.\n    this.seriesItemEnabled = [];\n    this.legendItemEnabled = [];\n    this.surroundingRadius = void 0;\n    this.NodeEvent = DonutSeriesNodeEvent;\n    this.angleScale = new LinearScale();\n    this.angleScale.domain = [0, 1];\n    this.angleScale.range = [-Math.PI, Math.PI].map((angle2) => angle2 + Math.PI / 2);\n    this.phantomGroup.opacity = 0.2;\n    this.phantomGroup.zIndexSubOrder = [() => this._declarationOrder, 0];\n  }\n  get calloutNodeData() {\n    return this.phantomNodeData ?? this.nodeData;\n  }\n  addChartEventListeners() {\n    this.destroyFns.push(\n      this.ctx.chartEventManager?.addListener(\"legend-item-click\", (event) => this.onLegendItemClick(event))\n    );\n  }\n  get visible() {\n    return super.visible && (this.seriesItemEnabled.length === 0 || this.seriesItemEnabled.includes(true));\n  }\n  nodeFactory() {\n    return new Sector();\n  }\n  getSeriesDomain(direction) {\n    if (direction === \"x\" /* X */) {\n      return this.angleScale.domain;\n    } else {\n      return this.radiusScale.domain;\n    }\n  }\n  async processData(dataController) {\n    if (this.data == null || !this.properties.isValid()) {\n      return;\n    }\n    let { data } = this;\n    const { visible, seriesItemEnabled } = this;\n    const { angleKey, angleFilterKey, radiusKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    const extraKeyProps = [];\n    const extraProps = [];\n    if (legendItemKey) {\n      extraKeyProps.push(keyProperty(legendItemKey, \"band\", { id: `legendItemKey` }));\n    } else if (calloutLabelKey) {\n      extraKeyProps.push(keyProperty(calloutLabelKey, \"band\", { id: `calloutLabelKey` }));\n    } else if (sectorLabelKey) {\n      extraKeyProps.push(keyProperty(sectorLabelKey, \"band\", { id: `sectorLabelKey` }));\n    }\n    const radiusScaleType = this.radiusScale.type;\n    const angleScaleType = this.radiusScale.type;\n    if (radiusKey) {\n      extraProps.push(\n        rangedValueProperty(radiusKey, {\n          id: \"radiusValue\",\n          min: this.properties.radiusMin ?? 0,\n          max: this.properties.radiusMax\n        }),\n        valueProperty(radiusKey, radiusScaleType, { id: `radiusRaw` }),\n        // Raw value pass-through.\n        normalisePropertyTo(\"radiusValue\", [0, 1], 1, this.properties.radiusMin ?? 0, this.properties.radiusMax)\n      );\n    }\n    if (calloutLabelKey) {\n      extraProps.push(valueProperty(calloutLabelKey, \"band\", { id: `calloutLabelValue` }));\n    }\n    if (sectorLabelKey) {\n      extraProps.push(valueProperty(sectorLabelKey, \"band\", { id: `sectorLabelValue` }));\n    }\n    if (legendItemKey) {\n      extraProps.push(valueProperty(legendItemKey, \"band\", { id: `legendItemValue` }));\n    }\n    if (angleFilterKey) {\n      extraProps.push(\n        accumulativeValueProperty(angleFilterKey, angleScaleType, {\n          id: `angleFilterValue`,\n          onlyPositive: true\n        }),\n        valueProperty(angleFilterKey, angleScaleType, { id: `angleFilterRaw` }),\n        normalisePropertyTo(\"angleFilterValue\", [0, 1], 0, 0)\n      );\n    }\n    if (animationEnabled && this.processedData && extraKeyProps.length > 0) {\n      extraProps.push(diff(this.processedData));\n    }\n    extraProps.push(animationValidation());\n    data = data.map((d, idx) => visible && seriesItemEnabled[idx] ? d : { ...d, [angleKey]: 0 });\n    await this.requestDataModel(dataController, data, {\n      props: [\n        ...extraKeyProps,\n        accumulativeValueProperty(angleKey, angleScaleType, { id: `angleValue`, onlyPositive: true }),\n        valueProperty(angleKey, angleScaleType, { id: `angleRaw` }),\n        // Raw value pass-through.\n        normalisePropertyTo(\"angleValue\", [0, 1], 0, 0),\n        ...extraProps\n      ]\n    });\n    for (const valueDef of this.processedData?.defs?.values ?? []) {\n      const { id, missing, property } = valueDef;\n      const missCount = getMissCount(this, missing);\n      if (id !== \"angleRaw\" && missCount > 0) {\n        Logger.warnOnce(\n          `no value was found for the key '${String(property)}' on ${missCount} data element${missCount > 1 ? \"s\" : \"\"}`\n        );\n      }\n    }\n    this.animationState.transition(\"updateData\");\n  }\n  async maybeRefreshNodeData() {\n    if (!this.nodeDataRefresh)\n      return;\n    const { nodeData = [], phantomNodeData } = await this.createNodeData() ?? {};\n    this.nodeData = nodeData;\n    this.phantomNodeData = phantomNodeData;\n    this.nodeDataRefresh = false;\n  }\n  getProcessedDataIndexes(dataModel) {\n    const angleIdx = dataModel.resolveProcessedDataIndexById(this, `angleValue`);\n    const angleRawIdx = dataModel.resolveProcessedDataIndexById(this, `angleRaw`);\n    const angleFilterIdx = this.properties.angleFilterKey != null ? dataModel.resolveProcessedDataIndexById(this, `angleFilterValue`) : void 0;\n    const angleFilterRawIdx = this.properties.angleFilterKey != null ? dataModel.resolveProcessedDataIndexById(this, `angleFilterRaw`) : void 0;\n    const radiusIdx = this.properties.radiusKey ? dataModel.resolveProcessedDataIndexById(this, `radiusValue`) : void 0;\n    const radiusRawIdx = this.properties.radiusKey ? dataModel.resolveProcessedDataIndexById(this, `radiusRaw`) : void 0;\n    const calloutLabelIdx = this.properties.calloutLabelKey ? dataModel.resolveProcessedDataIndexById(this, `calloutLabelValue`) : void 0;\n    const sectorLabelIdx = this.properties.sectorLabelKey ? dataModel.resolveProcessedDataIndexById(this, `sectorLabelValue`) : void 0;\n    const legendItemIdx = this.properties.legendItemKey ? dataModel.resolveProcessedDataIndexById(this, `legendItemValue`) : void 0;\n    return {\n      angleIdx,\n      angleRawIdx,\n      angleFilterIdx,\n      angleFilterRawIdx,\n      radiusIdx,\n      radiusRawIdx,\n      calloutLabelIdx,\n      sectorLabelIdx,\n      legendItemIdx\n    };\n  }\n  async createNodeData() {\n    const { id: seriesId, processedData, dataModel, angleScale } = this;\n    const { rotation, innerRadiusRatio } = this.properties;\n    if (!this.properties.isValid()) {\n      this.zerosumOuterRing.visible = true;\n      this.zerosumInnerRing.visible = true;\n      return { itemId: seriesId, nodeData: [], labelData: [] };\n    }\n    if (!processedData || !dataModel || processedData.type !== \"ungrouped\")\n      return;\n    const {\n      angleIdx,\n      angleRawIdx,\n      angleFilterIdx,\n      angleFilterRawIdx,\n      radiusIdx,\n      radiusRawIdx,\n      calloutLabelIdx,\n      sectorLabelIdx,\n      legendItemIdx\n    } = this.getProcessedDataIndexes(dataModel);\n    const useFilterAngles = angleFilterRawIdx != null && processedData.data.some(({ values }) => {\n      return values[angleFilterRawIdx] > values[angleRawIdx];\n    });\n    let currentStart = 0;\n    let sum2 = 0;\n    const nodes = [];\n    const phantomNodes = angleFilterRawIdx != null ? [] : void 0;\n    processedData.data.forEach((group, index) => {\n      const { datum, values } = group;\n      const currentValue = useFilterAngles ? values[angleFilterIdx] : values[angleIdx];\n      const crossFilterScale = angleFilterRawIdx != null && !useFilterAngles ? Math.sqrt(values[angleFilterRawIdx] / values[angleRawIdx]) : 1;\n      const startAngle = angleScale.convert(currentStart) + toRadians(rotation);\n      currentStart = currentValue;\n      sum2 += currentValue;\n      const endAngle = angleScale.convert(currentStart) + toRadians(rotation);\n      const span = Math.abs(endAngle - startAngle);\n      const midAngle = startAngle + span / 2;\n      const angleValue = values[angleRawIdx];\n      const radiusRaw = radiusIdx != null ? values[radiusIdx] ?? 1 : 1;\n      const radius = radiusRaw * crossFilterScale;\n      const radiusValue = radiusRawIdx != null ? values[radiusRawIdx] : void 0;\n      const legendItemValue = legendItemIdx != null ? values[legendItemIdx] : void 0;\n      const nodeLabels = this.getLabels(\n        datum,\n        midAngle,\n        span,\n        true,\n        calloutLabelIdx != null ? values[calloutLabelIdx] : void 0,\n        sectorLabelIdx != null ? values[sectorLabelIdx] : void 0,\n        legendItemValue\n      );\n      const sectorFormat = this.getSectorFormat(datum, index, false);\n      const node = {\n        itemId: index,\n        series: this,\n        datum,\n        index,\n        angleValue,\n        midAngle,\n        midCos: Math.cos(midAngle),\n        midSin: Math.sin(midAngle),\n        startAngle,\n        endAngle,\n        radius,\n        innerRadius: Math.max(this.radiusScale.convert(0), 0),\n        outerRadius: Math.max(this.radiusScale.convert(radius), 0),\n        sectorFormat,\n        radiusValue,\n        legendItemValue,\n        enabled: this.seriesItemEnabled[index],\n        focusable: true,\n        ...nodeLabels\n      };\n      nodes.push(node);\n      if (phantomNodes != null) {\n        phantomNodes.push({\n          ...node,\n          radius: 1,\n          innerRadius: Math.max(this.radiusScale.convert(0), 0),\n          outerRadius: Math.max(this.radiusScale.convert(1), 0),\n          focusable: false\n        });\n      }\n    });\n    this.zerosumOuterRing.visible = sum2 === 0;\n    this.zerosumInnerRing.visible = sum2 === 0 && innerRadiusRatio != null && innerRadiusRatio !== 1 && innerRadiusRatio > 0;\n    return {\n      itemId: seriesId,\n      nodeData: nodes,\n      labelData: nodes,\n      phantomNodeData: phantomNodes\n    };\n  }\n  getLabels(datum, midAngle, span, skipDisabled, calloutLabelValue, sectorLabelValue, legendItemValue) {\n    const { calloutLabel, sectorLabel, legendItemKey } = this.properties;\n    const calloutLabelKey = !skipDisabled || calloutLabel.enabled ? this.properties.calloutLabelKey : void 0;\n    const sectorLabelKey = !skipDisabled || sectorLabel.enabled ? this.properties.sectorLabelKey : void 0;\n    if (!calloutLabelKey && !sectorLabelKey && !legendItemKey) {\n      return {};\n    }\n    const labelFormatterParams = {\n      datum,\n      angleKey: this.properties.angleKey,\n      angleName: this.properties.angleName,\n      radiusKey: this.properties.radiusKey,\n      radiusName: this.properties.radiusName,\n      calloutLabelKey: this.properties.calloutLabelKey,\n      calloutLabelName: this.properties.calloutLabelName,\n      sectorLabelKey: this.properties.sectorLabelKey,\n      sectorLabelName: this.properties.sectorLabelName,\n      legendItemKey: this.properties.legendItemKey\n    };\n    const result = {};\n    if (calloutLabelKey && span > toRadians(calloutLabel.minAngle)) {\n      result.calloutLabel = {\n        ...this.getTextAlignment(midAngle),\n        text: this.getLabelText(calloutLabel, {\n          ...labelFormatterParams,\n          value: calloutLabelValue\n        }),\n        hidden: false,\n        collisionTextAlign: void 0,\n        collisionOffsetY: 0,\n        box: void 0\n      };\n    }\n    if (sectorLabelKey) {\n      result.sectorLabel = {\n        text: this.getLabelText(sectorLabel, {\n          ...labelFormatterParams,\n          value: sectorLabelValue\n        })\n      };\n    }\n    if (legendItemKey != null && legendItemValue != null) {\n      result.legendItem = { key: legendItemKey, text: legendItemValue };\n    }\n    return result;\n  }\n  getTextAlignment(midAngle) {\n    const quadrantTextOpts = [\n      { textAlign: \"center\", textBaseline: \"bottom\" },\n      { textAlign: \"left\", textBaseline: \"middle\" },\n      { textAlign: \"center\", textBaseline: \"hanging\" },\n      { textAlign: \"right\", textBaseline: \"middle\" }\n    ];\n    const midAngle180 = normalizeAngle180(midAngle);\n    const quadrantStart = -0.75 * Math.PI;\n    const quadrantOffset = midAngle180 - quadrantStart;\n    const quadrant = Math.floor(quadrantOffset / (Math.PI / 2));\n    const quadrantIndex = mod(quadrant, quadrantTextOpts.length);\n    return quadrantTextOpts[quadrantIndex];\n  }\n  getSectorFormat(datum, formatIndex, highlighted) {\n    const { callbackCache } = this.ctx;\n    const { angleKey, radiusKey, calloutLabelKey, sectorLabelKey, legendItemKey, fills, strokes, itemStyler } = this.properties;\n    const defaultStroke = strokes[formatIndex % strokes.length];\n    const { fill, fillOpacity, stroke, strokeWidth, strokeOpacity, lineDash, lineDashOffset, cornerRadius } = mergeDefaults(\n      highlighted && this.properties.highlightStyle.item,\n      {\n        fill: fills.length > 0 ? fills[formatIndex % fills.length] : void 0,\n        stroke: defaultStroke,\n        strokeWidth: this.getStrokeWidth(this.properties.strokeWidth),\n        strokeOpacity: this.getOpacity()\n      },\n      this.properties\n    );\n    let format;\n    if (itemStyler) {\n      format = callbackCache.call(itemStyler, {\n        datum,\n        angleKey,\n        radiusKey,\n        calloutLabelKey,\n        sectorLabelKey,\n        legendItemKey,\n        fill,\n        fillOpacity,\n        stroke,\n        strokeWidth,\n        strokeOpacity,\n        lineDash,\n        lineDashOffset,\n        cornerRadius,\n        highlighted,\n        seriesId: this.id\n      });\n    }\n    return {\n      fill: format?.fill ?? fill,\n      fillOpacity: format?.fillOpacity ?? fillOpacity,\n      stroke: format?.stroke ?? stroke,\n      strokeWidth: format?.strokeWidth ?? strokeWidth,\n      strokeOpacity: format?.strokeOpacity ?? strokeOpacity,\n      lineDash: format?.lineDash ?? lineDash,\n      lineDashOffset: format?.lineDashOffset ?? lineDashOffset,\n      cornerRadius: format?.cornerRadius ?? cornerRadius\n    };\n  }\n  getInnerRadius() {\n    const { radius } = this;\n    const { innerRadiusRatio = 1, innerRadiusOffset = 0 } = this.properties;\n    const innerRadius = radius * innerRadiusRatio + innerRadiusOffset;\n    if (innerRadius === radius || innerRadius < 0) {\n      return 0;\n    }\n    return innerRadius;\n  }\n  getOuterRadius() {\n    const { outerRadiusRatio, outerRadiusOffset } = this.properties;\n    return Math.max(this.radius * outerRadiusRatio + outerRadiusOffset, 0);\n  }\n  updateRadiusScale(resize) {\n    const newRange = [this.getInnerRadius(), this.getOuterRadius()];\n    this.radiusScale.range = newRange;\n    if (resize) {\n      this.previousRadiusScale.range = newRange;\n    }\n    const setRadii = (d) => ({\n      ...d,\n      innerRadius: Math.max(this.radiusScale.convert(0), 0),\n      outerRadius: Math.max(this.radiusScale.convert(d.radius), 0)\n    });\n    this.nodeData = this.nodeData.map(setRadii);\n    this.phantomNodeData = this.phantomNodeData?.map(setRadii);\n  }\n  getTitleTranslationY() {\n    const outerRadius = Math.max(0, this.radiusScale.range[1]);\n    if (outerRadius === 0) {\n      return NaN;\n    }\n    const spacing = this.properties.title?.spacing ?? 0;\n    const titleOffset = 2 + spacing;\n    const dy = Math.max(0, -outerRadius);\n    return -outerRadius - titleOffset - dy;\n  }\n  async update({ seriesRect }) {\n    const { title } = this.properties;\n    const newNodeDataDependencies = {\n      seriesRectWidth: seriesRect?.width,\n      seriesRectHeight: seriesRect?.height\n    };\n    const resize = jsonDiff(this.nodeDataDependencies, newNodeDataDependencies) != null;\n    if (resize) {\n      this._nodeDataDependencies = newNodeDataDependencies;\n    }\n    await this.maybeRefreshNodeData();\n    this.updateTitleNodes();\n    this.updateRadiusScale(resize);\n    this.contentGroup.translationX = this.centerX;\n    this.contentGroup.translationY = this.centerY;\n    this.highlightGroup.translationX = this.centerX;\n    this.highlightGroup.translationY = this.centerY;\n    this.backgroundGroup.translationX = this.centerX;\n    this.backgroundGroup.translationY = this.centerY;\n    if (this.labelGroup) {\n      this.labelGroup.translationX = this.centerX;\n      this.labelGroup.translationY = this.centerY;\n    }\n    if (title) {\n      const dy = this.getTitleTranslationY();\n      title.node.y = isFinite(dy) ? dy : 0;\n      const titleBox = title.node.getBBox();\n      title.node.visible = title.enabled && isFinite(dy) && !this.bboxIntersectsSurroundingSeries(titleBox);\n    }\n    for (const circle of [this.zerosumInnerRing, this.zerosumOuterRing]) {\n      circle.fillOpacity = 0;\n      circle.stroke = this.properties.calloutLabel.color;\n      circle.strokeWidth = 1;\n      circle.strokeOpacity = 1;\n    }\n    this.updateNodeMidPoint();\n    await this.updateSelections();\n    await this.updateNodes(seriesRect);\n  }\n  updateTitleNodes() {\n    const { oldTitle } = this;\n    const { title } = this.properties;\n    if (oldTitle !== title) {\n      if (oldTitle) {\n        this.labelGroup?.removeChild(oldTitle.node);\n      }\n      if (title) {\n        title.node.textBaseline = \"bottom\";\n        this.labelGroup?.appendChild(title.node);\n      }\n      this.oldTitle = title;\n    }\n  }\n  updateNodeMidPoint() {\n    const setMidPoint = (d) => {\n      const radius = d.innerRadius + (d.outerRadius - d.innerRadius) / 2;\n      d.midPoint = {\n        x: d.midCos * Math.max(0, radius),\n        y: d.midSin * Math.max(0, radius)\n      };\n    };\n    this.nodeData.forEach(setMidPoint);\n    this.phantomNodeData?.forEach(setMidPoint);\n  }\n  async updateSelections() {\n    await this.updateGroupSelection();\n    this.updateInnerCircleSelection();\n  }\n  async updateGroupSelection() {\n    const {\n      itemSelection,\n      highlightSelection,\n      phantomSelection,\n      highlightLabelSelection,\n      calloutLabelSelection,\n      labelSelection,\n      innerLabelsSelection\n    } = this;\n    const highlightedNodeData = this.nodeData.map((datum) => ({\n      ...datum,\n      // Allow mutable sectorFormat, so formatted sector styles can be updated and varied\n      // between normal and highlighted cases.\n      sectorFormat: { ...datum.sectorFormat }\n    }));\n    const update = (selection, nodeData) => {\n      selection.update(nodeData, void 0, (datum) => this.getDatumId(datum));\n      if (this.ctx.animationManager.isSkipped()) {\n        selection.cleanup();\n      }\n    };\n    update(itemSelection, this.nodeData);\n    update(highlightSelection, highlightedNodeData);\n    update(phantomSelection, this.phantomNodeData ?? []);\n    calloutLabelSelection.update(this.calloutNodeData, (group) => {\n      const line = new Line();\n      line.tag = 0 /* Callout */;\n      line.pointerEvents = 1 /* None */;\n      group.appendChild(line);\n      const text = new Text();\n      text.tag = 1 /* Label */;\n      text.pointerEvents = 1 /* None */;\n      group.appendChild(text);\n    });\n    labelSelection.update(this.nodeData);\n    highlightLabelSelection.update(highlightedNodeData);\n    innerLabelsSelection.update(this.properties.innerLabels, (node) => {\n      node.pointerEvents = 1 /* None */;\n    });\n  }\n  updateInnerCircleSelection() {\n    const { innerCircle } = this.properties;\n    let radius = 0;\n    const innerRadius = this.getInnerRadius();\n    if (innerRadius > 0) {\n      const circleRadius = Math.min(innerRadius, this.getOuterRadius());\n      const antiAliasingPadding = 1;\n      radius = Math.ceil(circleRadius * 2 + antiAliasingPadding);\n    }\n    const datums = innerCircle ? [{ radius }] : [];\n    this.innerCircleSelection.update(datums);\n  }\n  async updateNodes(seriesRect) {\n    const highlightedDatum = this.ctx.highlightManager.getActiveHighlight();\n    const isVisible = this.visible && this.seriesItemEnabled.includes(true);\n    this.rootGroup.visible = isVisible;\n    this.backgroundGroup.visible = isVisible;\n    this.contentGroup.visible = isVisible;\n    this.highlightGroup.visible = isVisible && highlightedDatum?.series === this;\n    this.highlightLabel.visible = isVisible && highlightedDatum?.series === this;\n    this.labelGroup.visible = isVisible;\n    this.contentGroup.opacity = this.getOpacity();\n    this.innerCircleSelection.each((node, { radius }) => {\n      node.setProperties({\n        fill: this.properties.innerCircle?.fill,\n        opacity: this.properties.innerCircle?.fillOpacity,\n        size: radius\n      });\n    });\n    const animationDisabled = this.ctx.animationManager.isSkipped();\n    const updateSectorFn = (sector, datum, _index, isDatumHighlighted) => {\n      const format = this.getSectorFormat(datum.datum, datum.itemId, isDatumHighlighted);\n      datum.sectorFormat.fill = format.fill;\n      datum.sectorFormat.stroke = format.stroke;\n      if (animationDisabled) {\n        sector.startAngle = datum.startAngle;\n        sector.endAngle = datum.endAngle;\n        sector.innerRadius = datum.innerRadius;\n        sector.outerRadius = datum.outerRadius;\n      }\n      if (isDatumHighlighted || animationDisabled) {\n        sector.fill = format.fill;\n        sector.stroke = format.stroke;\n      }\n      sector.strokeWidth = format.strokeWidth;\n      sector.fillOpacity = format.fillOpacity;\n      sector.strokeOpacity = format.strokeOpacity;\n      sector.lineDash = format.lineDash;\n      sector.lineDashOffset = format.lineDashOffset;\n      sector.cornerRadius = format.cornerRadius;\n      sector.fillShadow = this.properties.shadow;\n      const inset = Math.max(\n        (this.properties.sectorSpacing + (format.stroke != null ? format.strokeWidth : 0)) / 2,\n        0\n      );\n      sector.inset = inset;\n      sector.lineJoin = this.properties.sectorSpacing >= 0 || inset > 0 ? \"miter\" : \"round\";\n    };\n    this.itemSelection.each((node, datum, index) => updateSectorFn(node, datum, index, false));\n    this.highlightSelection.each((node, datum, index) => {\n      updateSectorFn(node, datum, index, true);\n      node.visible = datum.itemId === highlightedDatum?.itemId;\n    });\n    this.phantomSelection.each((node, datum, index) => updateSectorFn(node, datum, index, false));\n    this.updateCalloutLineNodes();\n    this.updateCalloutLabelNodes(seriesRect);\n    this.updateSectorLabelNodes();\n    this.updateInnerLabelNodes();\n    this.updateZerosumRings();\n    this.animationState.transition(\"update\");\n  }\n  updateCalloutLineNodes() {\n    const { calloutLine } = this.properties;\n    const calloutLength = calloutLine.length;\n    const calloutStrokeWidth = calloutLine.strokeWidth;\n    const calloutColors = calloutLine.colors ?? this.properties.strokes;\n    const { offset: offset4 } = this.properties.calloutLabel;\n    this.calloutLabelSelection.selectByTag(0 /* Callout */).forEach((line, index) => {\n      const datum = line.datum;\n      const { calloutLabel: label, outerRadius } = datum;\n      if (label?.text && !label.hidden && outerRadius !== 0) {\n        line.visible = true;\n        line.strokeWidth = calloutStrokeWidth;\n        line.stroke = calloutColors[index % calloutColors.length];\n        line.fill = void 0;\n        const x1 = datum.midCos * outerRadius;\n        const y1 = datum.midSin * outerRadius;\n        let x2 = datum.midCos * (outerRadius + calloutLength);\n        let y2 = datum.midSin * (outerRadius + calloutLength);\n        const isMoved = label.collisionTextAlign ?? label.collisionOffsetY !== 0;\n        if (isMoved && label.box != null) {\n          const box = label.box;\n          let cx = x2;\n          let cy = y2;\n          if (x2 < box.x) {\n            cx = box.x;\n          } else if (x2 > box.x + box.width) {\n            cx = box.x + box.width;\n          }\n          if (y2 < box.y) {\n            cy = box.y;\n          } else if (y2 > box.y + box.height) {\n            cy = box.y + box.height;\n          }\n          const dx = cx - x2;\n          const dy = cy - y2;\n          const length2 = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n          const paddedLength = length2 - offset4;\n          if (paddedLength > 0) {\n            x2 = x2 + dx * paddedLength / length2;\n            y2 = y2 + dy * paddedLength / length2;\n          }\n        }\n        line.x1 = x1;\n        line.y1 = y1;\n        line.x2 = x2;\n        line.y2 = y2;\n      } else {\n        line.visible = false;\n      }\n    });\n  }\n  getLabelOverflow(text, box, seriesRect) {\n    const seriesLeft = seriesRect.x - this.centerX;\n    const seriesRight = seriesRect.x + seriesRect.width - this.centerX;\n    const seriesTop = seriesRect.y - this.centerY;\n    const seriesBottom = seriesRect.y + seriesRect.height - this.centerY;\n    const errPx = 1;\n    let visibleTextPart = 1;\n    if (box.x + errPx < seriesLeft) {\n      visibleTextPart = (box.x + box.width - seriesLeft) / box.width;\n    } else if (box.x + box.width - errPx > seriesRight) {\n      visibleTextPart = (seriesRight - box.x) / box.width;\n    }\n    const hasVerticalOverflow = box.y + errPx < seriesTop || box.y + box.height - errPx > seriesBottom;\n    const textLength = visibleTextPart === 1 ? text.length : Math.floor(text.length * visibleTextPart) - 1;\n    const hasSurroundingSeriesOverflow = this.bboxIntersectsSurroundingSeries(box);\n    return { textLength, hasVerticalOverflow, hasSurroundingSeriesOverflow };\n  }\n  bboxIntersectsSurroundingSeries(box) {\n    const { surroundingRadius } = this;\n    if (surroundingRadius == null) {\n      return false;\n    }\n    const corners = [\n      { x: box.x, y: box.y },\n      { x: box.x + box.width, y: box.y },\n      { x: box.x + box.width, y: box.y + box.height },\n      { x: box.x, y: box.y + box.height }\n    ];\n    const sur2 = surroundingRadius ** 2;\n    return corners.some((corner) => corner.x ** 2 + corner.y ** 2 > sur2);\n  }\n  computeCalloutLabelCollisionOffsets() {\n    const { radiusScale } = this;\n    const { calloutLabel, calloutLine } = this.properties;\n    const { offset: offset4, minSpacing } = calloutLabel;\n    const innerRadius = radiusScale.convert(0);\n    const shouldSkip = (datum) => {\n      const label = datum.calloutLabel;\n      return !label || datum.outerRadius === 0;\n    };\n    const fullData = this.calloutNodeData;\n    const data = fullData.filter((t) => !shouldSkip(t));\n    data.forEach((datum) => {\n      const label = datum.calloutLabel;\n      if (label == null)\n        return;\n      label.hidden = false;\n      label.collisionTextAlign = void 0;\n      label.collisionOffsetY = 0;\n    });\n    if (data.length <= 1) {\n      return;\n    }\n    const leftLabels = data.filter((d) => d.midCos < 0).sort((a, b) => a.midSin - b.midSin);\n    const rightLabels = data.filter((d) => d.midCos >= 0).sort((a, b) => a.midSin - b.midSin);\n    const topLabels = data.filter((d) => d.midSin < 0 && d.calloutLabel?.textAlign === \"center\").sort((a, b) => a.midCos - b.midCos);\n    const bottomLabels = data.filter((d) => d.midSin >= 0 && d.calloutLabel?.textAlign === \"center\").sort((a, b) => a.midCos - b.midCos);\n    const getTextBBox = (datum) => {\n      const label = datum.calloutLabel;\n      if (label == null)\n        return BBox.zero.clone();\n      const labelRadius = datum.outerRadius + calloutLine.length + offset4;\n      const x = datum.midCos * labelRadius;\n      const y = datum.midSin * labelRadius + label.collisionOffsetY;\n      const textAlign = label.collisionTextAlign ?? label.textAlign;\n      const textBaseline = label.textBaseline;\n      return Text.computeBBox(label.text, x, y, {\n        font: this.properties.calloutLabel,\n        textAlign,\n        textBaseline\n      });\n    };\n    const avoidNeighbourYCollision = (label, next, direction) => {\n      const box = getTextBBox(label).grow(minSpacing / 2);\n      const other = getTextBBox(next).grow(minSpacing / 2);\n      const collidesOrBehind = box.x < other.x + other.width && box.x + box.width > other.x && (direction === \"to-top\" ? box.y < other.y + other.height : box.y + box.height > other.y);\n      if (collidesOrBehind) {\n        const dy = direction === \"to-top\" ? box.y - other.y - other.height : box.y + box.height - other.y;\n        next.calloutLabel.collisionOffsetY = dy;\n      }\n    };\n    const avoidYCollisions = (labels) => {\n      const midLabel = labels.slice().sort((a, b) => Math.abs(a.midSin) - Math.abs(b.midSin))[0];\n      const midIndex = labels.indexOf(midLabel);\n      for (let i = midIndex - 1; i >= 0; i--) {\n        const prev = labels[i + 1];\n        const next = labels[i];\n        avoidNeighbourYCollision(prev, next, \"to-top\");\n      }\n      for (let i = midIndex + 1; i < labels.length; i++) {\n        const prev = labels[i - 1];\n        const next = labels[i];\n        avoidNeighbourYCollision(prev, next, \"to-bottom\");\n      }\n    };\n    const avoidXCollisions = (labels) => {\n      const labelsCollideLabelsByY = data.some((datum) => datum.calloutLabel.collisionOffsetY !== 0);\n      const boxes = labels.map((label) => getTextBBox(label));\n      const paddedBoxes = boxes.map((box) => box.clone().grow(minSpacing / 2));\n      let labelsCollideLabelsByX = false;\n      for (let i = 0; i < paddedBoxes.length && !labelsCollideLabelsByX; i++) {\n        const box = paddedBoxes[i];\n        for (let j = i + 1; j < labels.length; j++) {\n          const other = paddedBoxes[j];\n          if (box.collidesBBox(other)) {\n            labelsCollideLabelsByX = true;\n            break;\n          }\n        }\n      }\n      const sectors = fullData.map((datum) => {\n        const { startAngle, endAngle, outerRadius } = datum;\n        return { startAngle, endAngle, innerRadius, outerRadius };\n      });\n      const labelsCollideSectors = boxes.some((box) => {\n        return sectors.some((sector) => boxCollidesSector(box, sector));\n      });\n      if (!labelsCollideLabelsByX && !labelsCollideLabelsByY && !labelsCollideSectors) {\n        return;\n      }\n      labels.filter((d) => d.calloutLabel.textAlign === \"center\").forEach((d) => {\n        const label = d.calloutLabel;\n        if (d.midCos < 0) {\n          label.collisionTextAlign = \"right\";\n        } else if (d.midCos > 0) {\n          label.collisionTextAlign = \"left\";\n        } else {\n          label.collisionTextAlign = \"center\";\n        }\n      });\n    };\n    avoidYCollisions(leftLabels);\n    avoidYCollisions(rightLabels);\n    avoidXCollisions(topLabels);\n    avoidXCollisions(bottomLabels);\n  }\n  updateCalloutLabelNodes(seriesRect) {\n    const { radiusScale } = this;\n    const { calloutLabel, calloutLine } = this.properties;\n    const calloutLength = calloutLine.length;\n    const { offset: offset4, color } = calloutLabel;\n    const tempTextNode = new Text();\n    this.calloutLabelSelection.selectByTag(1 /* Label */).forEach((text) => {\n      const { datum } = text;\n      const label = datum.calloutLabel;\n      const radius = radiusScale.convert(datum.radius);\n      const outerRadius = Math.max(0, radius);\n      if (!label?.text || outerRadius === 0 || label.hidden) {\n        text.visible = false;\n        return;\n      }\n      const labelRadius = outerRadius + calloutLength + offset4;\n      const x = datum.midCos * labelRadius;\n      const y = datum.midSin * labelRadius + label.collisionOffsetY;\n      const align = {\n        textAlign: label.collisionTextAlign ?? label.textAlign,\n        textBaseline: label.textBaseline\n      };\n      tempTextNode.text = label.text;\n      tempTextNode.x = x;\n      tempTextNode.y = y;\n      tempTextNode.setFont(this.properties.calloutLabel);\n      tempTextNode.setAlign(align);\n      const box = tempTextNode.getBBox();\n      let displayText = label.text;\n      let visible = true;\n      if (calloutLabel.avoidCollisions) {\n        const { textLength, hasVerticalOverflow } = this.getLabelOverflow(label.text, box, seriesRect);\n        displayText = label.text.length === textLength ? label.text : `${label.text.substring(0, textLength)}\\u2026`;\n        visible = !hasVerticalOverflow;\n      }\n      text.text = displayText;\n      text.x = x;\n      text.y = y;\n      text.setFont(this.properties.calloutLabel);\n      text.setAlign(align);\n      text.fill = color;\n      text.visible = visible;\n    });\n  }\n  async computeLabelsBBox(options, seriesRect) {\n    const { calloutLabel, calloutLine } = this.properties;\n    const calloutLength = calloutLine.length;\n    const { offset: offset4, maxCollisionOffset, minSpacing } = calloutLabel;\n    if (!calloutLabel.avoidCollisions) {\n      return null;\n    }\n    await this.maybeRefreshNodeData();\n    this.updateRadiusScale(false);\n    this.computeCalloutLabelCollisionOffsets();\n    const textBoxes = [];\n    const text = new Text();\n    let titleBox;\n    const { title } = this.properties;\n    if (title?.text && title.enabled) {\n      const dy = this.getTitleTranslationY();\n      if (isFinite(dy)) {\n        text.text = title.text;\n        text.x = 0;\n        text.y = dy;\n        text.setFont(title);\n        text.setAlign({\n          textBaseline: \"bottom\",\n          textAlign: \"center\"\n        });\n        titleBox = text.getBBox();\n        textBoxes.push(titleBox);\n      }\n    }\n    this.calloutNodeData.forEach((datum) => {\n      const label = datum.calloutLabel;\n      if (!label || datum.outerRadius === 0) {\n        return null;\n      }\n      const labelRadius = datum.outerRadius + calloutLength + offset4;\n      const x = datum.midCos * labelRadius;\n      const y = datum.midSin * labelRadius + label.collisionOffsetY;\n      text.text = label.text;\n      text.x = x;\n      text.y = y;\n      text.setFont(this.properties.calloutLabel);\n      text.setAlign({\n        textAlign: label.collisionTextAlign ?? label.textAlign,\n        textBaseline: label.textBaseline\n      });\n      const box = text.getBBox();\n      label.box = box;\n      if (Math.abs(label.collisionOffsetY) > maxCollisionOffset) {\n        label.hidden = true;\n        return;\n      }\n      if (titleBox) {\n        const seriesTop = seriesRect.y - this.centerY;\n        const titleCleanArea = new BBox(\n          titleBox.x - minSpacing,\n          seriesTop,\n          titleBox.width + 2 * minSpacing,\n          titleBox.y + titleBox.height + minSpacing - seriesTop\n        );\n        if (box.collidesBBox(titleCleanArea)) {\n          label.hidden = true;\n          return;\n        }\n      }\n      if (options.hideWhenNecessary) {\n        const { textLength, hasVerticalOverflow, hasSurroundingSeriesOverflow } = this.getLabelOverflow(\n          label.text,\n          box,\n          seriesRect\n        );\n        const isTooShort = label.text.length > 2 && textLength < 2;\n        if (hasVerticalOverflow || isTooShort || hasSurroundingSeriesOverflow) {\n          label.hidden = true;\n          return;\n        }\n      }\n      label.hidden = false;\n      textBoxes.push(box);\n    });\n    if (textBoxes.length === 0) {\n      return null;\n    }\n    return BBox.merge(textBoxes);\n  }\n  updateSectorLabelNodes() {\n    const { radiusScale } = this;\n    const innerRadius = radiusScale.convert(0);\n    const { fontSize, fontStyle, fontWeight, fontFamily, positionOffset, positionRatio, color } = this.properties.sectorLabel;\n    const updateSectorLabel = (text, datum) => {\n      const { sectorLabel, outerRadius } = datum;\n      let isTextVisible = false;\n      if (sectorLabel && outerRadius !== 0) {\n        const labelRadius = innerRadius * (1 - positionRatio) + outerRadius * positionRatio + positionOffset;\n        text.fill = color;\n        text.fontStyle = fontStyle;\n        text.fontWeight = fontWeight;\n        text.fontSize = fontSize;\n        text.fontFamily = fontFamily;\n        text.text = sectorLabel.text;\n        text.x = datum.midCos * labelRadius;\n        text.y = datum.midSin * labelRadius;\n        text.textAlign = \"center\";\n        text.textBaseline = \"middle\";\n        const bbox = text.getBBox();\n        const corners = [\n          [bbox.x, bbox.y],\n          [bbox.x + bbox.width, bbox.y],\n          [bbox.x + bbox.width, bbox.y + bbox.height],\n          [bbox.x, bbox.y + bbox.height]\n        ];\n        const { startAngle, endAngle } = datum;\n        const sectorBounds = { startAngle, endAngle, innerRadius, outerRadius };\n        if (corners.every(([x, y]) => isPointInSector(x, y, sectorBounds))) {\n          isTextVisible = true;\n        }\n      }\n      text.visible = isTextVisible;\n    };\n    this.labelSelection.each(updateSectorLabel);\n    this.highlightLabelSelection.each(updateSectorLabel);\n  }\n  updateInnerLabelNodes() {\n    const textBBoxes = [];\n    const margins = [];\n    this.innerLabelsSelection.each((text, datum) => {\n      const { fontStyle, fontWeight, fontSize, fontFamily, color } = datum;\n      text.fontStyle = fontStyle;\n      text.fontWeight = fontWeight;\n      text.fontSize = fontSize;\n      text.fontFamily = fontFamily;\n      text.text = datum.text;\n      text.x = 0;\n      text.y = 0;\n      text.fill = color;\n      text.textAlign = \"center\";\n      text.textBaseline = \"alphabetic\";\n      textBBoxes.push(text.getBBox());\n      margins.push(datum.spacing);\n    });\n    const getMarginTop = (index) => index === 0 ? 0 : margins[index];\n    const getMarginBottom = (index) => index === margins.length - 1 ? 0 : margins[index];\n    const totalHeight = textBBoxes.reduce((sum2, bbox, i) => {\n      return sum2 + bbox.height + getMarginTop(i) + getMarginBottom(i);\n    }, 0);\n    const totalWidth = Math.max(...textBBoxes.map((bbox) => bbox.width));\n    const innerRadius = this.getInnerRadius();\n    const labelRadius = Math.sqrt(Math.pow(totalWidth / 2, 2) + Math.pow(totalHeight / 2, 2));\n    const labelsVisible = labelRadius <= (innerRadius > 0 ? innerRadius : this.getOuterRadius());\n    const textBottoms = [];\n    for (let i = 0, prev = -totalHeight / 2; i < textBBoxes.length; i++) {\n      const bbox = textBBoxes[i];\n      const bottom = bbox.height + prev + getMarginTop(i);\n      textBottoms.push(bottom);\n      prev = bottom + getMarginBottom(i);\n    }\n    this.innerLabelsSelection.each((text, _datum, index) => {\n      text.y = textBottoms[index];\n      text.visible = labelsVisible;\n    });\n  }\n  updateZerosumRings() {\n    this.zerosumOuterRing.size = this.getOuterRadius() * 2;\n    this.zerosumInnerRing.size = this.getInnerRadius() * 2;\n  }\n  getDatumLegendName(nodeDatum) {\n    const { angleKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;\n    const { sectorLabel, calloutLabel, legendItem } = nodeDatum;\n    if (legendItemKey && legendItem !== void 0) {\n      return legendItem.text;\n    } else if (calloutLabelKey && calloutLabelKey !== angleKey && calloutLabel?.text !== void 0) {\n      return calloutLabel.text;\n    } else if (sectorLabelKey && sectorLabelKey !== angleKey && sectorLabel?.text !== void 0) {\n      return sectorLabel.text;\n    }\n  }\n  pickNodeClosestDatum(point) {\n    return pickByMatchingAngle(this, point);\n  }\n  getTooltipHtml(nodeDatum) {\n    if (!this.properties.isValid()) {\n      return EMPTY_TOOLTIP_CONTENT;\n    }\n    const {\n      datum,\n      angleValue,\n      sectorFormat: { fill: color },\n      itemId\n    } = nodeDatum;\n    const title = sanitizeHtml(this.properties.title?.text);\n    const content = isFiniteNumber(angleValue) ? toFixed(angleValue) : String(angleValue);\n    const labelText = this.getDatumLegendName(nodeDatum);\n    return this.properties.tooltip.toTooltipHtml(\n      {\n        title: title ?? labelText,\n        content: title && labelText ? `${labelText}: ${content}` : content,\n        backgroundColor: color\n      },\n      {\n        datum,\n        itemId,\n        title,\n        color,\n        seriesId: this.id,\n        angleKey: this.properties.angleKey,\n        angleName: this.properties.angleName,\n        radiusKey: this.properties.radiusKey,\n        radiusName: this.properties.radiusName,\n        calloutLabelKey: this.properties.calloutLabelKey,\n        calloutLabelName: this.properties.calloutLabelName,\n        sectorLabelKey: this.properties.sectorLabelKey,\n        sectorLabelName: this.properties.sectorLabelName,\n        legendItemKey: this.properties.legendItemKey\n      }\n    );\n  }\n  getLegendData(legendType) {\n    const { visible, processedData, dataModel } = this;\n    if (!dataModel || !processedData?.data.length || !this.properties.isValid() || legendType !== \"category\") {\n      return [];\n    }\n    const { angleKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;\n    if (!legendItemKey && (!calloutLabelKey || calloutLabelKey === angleKey) && (!sectorLabelKey || sectorLabelKey === angleKey))\n      return [];\n    const { calloutLabelIdx, sectorLabelIdx, legendItemIdx } = this.getProcessedDataIndexes(dataModel);\n    const titleText = this.properties.title?.showInLegend && this.properties.title.text;\n    const legendData = [];\n    for (let index = 0; index < processedData.data.length; index++) {\n      const { datum, values } = processedData.data[index];\n      const labelParts = [];\n      if (titleText) {\n        labelParts.push(titleText);\n      }\n      const labels = this.getLabels(\n        datum,\n        2 * Math.PI,\n        2 * Math.PI,\n        false,\n        calloutLabelIdx != null ? values[calloutLabelIdx] : void 0,\n        sectorLabelIdx != null ? values[sectorLabelIdx] : void 0,\n        legendItemIdx != null ? values[legendItemIdx] : void 0\n      );\n      if (legendItemKey && labels.legendItem !== void 0) {\n        labelParts.push(labels.legendItem.text);\n      } else if (calloutLabelKey && calloutLabelKey !== angleKey && labels.calloutLabel?.text !== void 0) {\n        labelParts.push(labels.calloutLabel?.text);\n      } else if (sectorLabelKey && sectorLabelKey !== angleKey && labels.sectorLabel?.text !== void 0) {\n        labelParts.push(labels.sectorLabel?.text);\n      }\n      if (labelParts.length === 0)\n        continue;\n      const sectorFormat = this.getSectorFormat(datum, index, false);\n      legendData.push({\n        legendType: \"category\",\n        id: this.id,\n        itemId: index,\n        seriesId: this.id,\n        enabled: visible && this.legendItemEnabled[index],\n        label: {\n          text: labelParts.join(\" - \")\n        },\n        symbols: [\n          {\n            marker: {\n              fill: sectorFormat.fill,\n              stroke: sectorFormat.stroke,\n              fillOpacity: this.properties.fillOpacity,\n              strokeOpacity: this.properties.strokeOpacity,\n              strokeWidth: this.properties.strokeWidth\n            }\n          }\n        ],\n        legendItemName: legendItemKey != null ? datum[legendItemKey] : void 0\n      });\n    }\n    return legendData;\n  }\n  onLegendItemClick(event) {\n    const { enabled, itemId, series, legendItemName } = event;\n    if (series.id === this.id) {\n      this.toggleSeriesItem(itemId, enabled);\n    } else if (legendItemName != null) {\n      this.toggleOtherSeriesItems(legendItemName, enabled);\n    }\n  }\n  toggleSeriesItem(itemId, enabled) {\n    this.seriesItemEnabled[itemId] = enabled;\n    this.legendItemEnabled[itemId] = enabled;\n    if (this.nodeData[itemId]) {\n      this.nodeData[itemId].enabled = enabled;\n    }\n    this.nodeDataRefresh = true;\n  }\n  // Used for grid\n  setLegendState(enabledItems) {\n    this.legendItemEnabled = enabledItems;\n    this.ctx.updateService.update(4 /* SERIES_UPDATE */);\n  }\n  toggleOtherSeriesItems(legendItemName, enabled) {\n    if (!this.properties.legendItemKey || !this.dataModel) {\n      return;\n    }\n    const legendItemIdx = this.dataModel.resolveProcessedDataIndexById(this, `legendItemValue`);\n    this.processedData?.data.forEach(({ values }, datumItemId) => {\n      if (values[legendItemIdx] === legendItemName) {\n        this.toggleSeriesItem(datumItemId, enabled);\n      }\n    });\n  }\n  animateEmptyUpdateReady(_data) {\n    const { animationManager } = this.ctx;\n    const fns = preparePieSeriesAnimationFunctions(\n      true,\n      this.properties.rotation,\n      this.radiusScale,\n      this.previousRadiusScale\n    );\n    fromToMotion(\n      this.id,\n      \"nodes\",\n      animationManager,\n      [this.itemSelection, this.highlightSelection, this.phantomSelection],\n      fns.nodes,\n      (_, datum) => this.getDatumId(datum)\n    );\n    fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);\n    seriesLabelFadeInAnimation(this, \"callout\", animationManager, this.calloutLabelSelection);\n    seriesLabelFadeInAnimation(this, \"sector\", animationManager, this.labelSelection);\n    seriesLabelFadeInAnimation(this, \"highlight\", animationManager, this.highlightLabelSelection);\n    seriesLabelFadeInAnimation(this, \"inner\", animationManager, this.innerLabelsSelection);\n    this.previousRadiusScale.range = this.radiusScale.range;\n  }\n  animateWaitingUpdateReady() {\n    const { itemSelection, highlightSelection, phantomSelection, processedData, radiusScale, previousRadiusScale } = this;\n    const { animationManager } = this.ctx;\n    const dataDiff = processedData?.reduced?.diff;\n    this.ctx.animationManager.stopByAnimationGroupId(this.id);\n    const supportedDiff = (dataDiff?.moved.size ?? 0) === 0;\n    const hasKeys = (processedData?.defs.keys.length ?? 0) > 0;\n    const hasUniqueKeys = processedData?.reduced?.animationValidation?.uniqueKeys ?? true;\n    if (!supportedDiff || !hasKeys || !hasUniqueKeys) {\n      this.ctx.animationManager.skipCurrentBatch();\n    }\n    const fns = preparePieSeriesAnimationFunctions(\n      false,\n      this.properties.rotation,\n      radiusScale,\n      previousRadiusScale\n    );\n    fromToMotion(\n      this.id,\n      \"nodes\",\n      animationManager,\n      [itemSelection, highlightSelection, phantomSelection],\n      fns.nodes,\n      (_, datum) => this.getDatumId(datum),\n      dataDiff\n    );\n    fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);\n    seriesLabelFadeInAnimation(this, \"callout\", this.ctx.animationManager, this.calloutLabelSelection);\n    seriesLabelFadeInAnimation(this, \"sector\", this.ctx.animationManager, this.labelSelection);\n    seriesLabelFadeInAnimation(this, \"highlight\", this.ctx.animationManager, this.highlightLabelSelection);\n    seriesLabelFadeInAnimation(this, \"inner\", this.ctx.animationManager, this.innerLabelsSelection);\n    this.previousRadiusScale.range = this.radiusScale.range;\n  }\n  animateClearingUpdateEmpty() {\n    const { itemSelection, highlightSelection, phantomSelection, radiusScale, previousRadiusScale } = this;\n    const { animationManager } = this.ctx;\n    const fns = preparePieSeriesAnimationFunctions(\n      false,\n      this.properties.rotation,\n      radiusScale,\n      previousRadiusScale\n    );\n    fromToMotion(\n      this.id,\n      \"nodes\",\n      animationManager,\n      [itemSelection, highlightSelection, phantomSelection],\n      fns.nodes,\n      (_, datum) => this.getDatumId(datum)\n    );\n    fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);\n    seriesLabelFadeOutAnimation(this, \"callout\", this.ctx.animationManager, this.calloutLabelSelection);\n    seriesLabelFadeOutAnimation(this, \"sector\", this.ctx.animationManager, this.labelSelection);\n    seriesLabelFadeOutAnimation(this, \"highlight\", this.ctx.animationManager, this.highlightLabelSelection);\n    seriesLabelFadeOutAnimation(this, \"inner\", this.ctx.animationManager, this.innerLabelsSelection);\n    this.previousRadiusScale.range = this.radiusScale.range;\n  }\n  getDatumIdFromData(datum) {\n    const { calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;\n    if (!this.processedData?.reduced?.animationValidation?.uniqueKeys) {\n      return;\n    }\n    if (legendItemKey) {\n      return datum[legendItemKey];\n    } else if (calloutLabelKey) {\n      return datum[calloutLabelKey];\n    } else if (sectorLabelKey) {\n      return datum[sectorLabelKey];\n    }\n  }\n  getDatumId(datum) {\n    const { index } = datum;\n    const datumId = this.getDatumIdFromData(datum.datum);\n    return datumId != null ? String(datumId) : `${index}`;\n  }\n  onDataChange() {\n    const { data, seriesItemEnabled, legendItemEnabled } = this;\n    this.seriesItemEnabled = data?.map((_, index) => seriesItemEnabled[index] ?? true) ?? [];\n    this.legendItemEnabled = data?.map((_, index) => legendItemEnabled[index] ?? true) ?? [];\n  }\n};\nDonutSeries.className = \"DonutSeries\";\nDonutSeries.type = \"donut\";\n\n// packages/ag-charts-community/src/chart/series/polar/donutTheme.ts\nvar donutTheme = {\n  series: {\n    title: {\n      enabled: true,\n      fontWeight: \"normal\" /* NORMAL */,\n      fontSize: 14,\n      fontFamily: DEFAULT_FONT_FAMILY,\n      color: DEFAULT_MUTED_LABEL_COLOUR,\n      spacing: 5\n    },\n    calloutLabel: {\n      enabled: true,\n      fontSize: 12 /* SMALL */,\n      fontFamily: DEFAULT_FONT_FAMILY,\n      color: DEFAULT_LABEL_COLOUR,\n      offset: 3,\n      minAngle: 0\n    },\n    sectorLabel: {\n      enabled: true,\n      fontWeight: \"normal\" /* NORMAL */,\n      fontSize: 12 /* SMALL */,\n      fontFamily: DEFAULT_FONT_FAMILY,\n      color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR,\n      positionOffset: 0,\n      positionRatio: 0.5\n    },\n    calloutLine: {\n      length: 10,\n      strokeWidth: 2\n    },\n    fillOpacity: 1,\n    strokeOpacity: 1,\n    strokeWidth: 0,\n    lineDash: [0],\n    lineDashOffset: 0,\n    rotation: 0,\n    sectorSpacing: 1,\n    shadow: {\n      enabled: false,\n      color: DEFAULT_SHADOW_COLOUR,\n      xOffset: 3,\n      yOffset: 3,\n      blur: 5\n    },\n    innerLabels: {\n      fontSize: 12 /* SMALL */,\n      fontFamily: DEFAULT_FONT_FAMILY,\n      color: DEFAULT_LABEL_COLOUR,\n      spacing: 2\n    }\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/polar/pieTheme.ts\nvar pieTheme = {\n  series: {\n    title: {\n      enabled: true,\n      fontWeight: \"normal\" /* NORMAL */,\n      fontSize: 14,\n      fontFamily: DEFAULT_FONT_FAMILY,\n      color: DEFAULT_MUTED_LABEL_COLOUR,\n      spacing: 5\n    },\n    calloutLabel: {\n      enabled: true,\n      fontSize: 12 /* SMALL */,\n      fontFamily: DEFAULT_FONT_FAMILY,\n      color: DEFAULT_LABEL_COLOUR,\n      offset: 3,\n      minAngle: 0\n    },\n    sectorLabel: {\n      enabled: true,\n      fontWeight: \"normal\" /* NORMAL */,\n      fontSize: 12 /* SMALL */,\n      fontFamily: DEFAULT_FONT_FAMILY,\n      color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR,\n      positionOffset: 0,\n      positionRatio: 0.5\n    },\n    calloutLine: {\n      length: 10,\n      strokeWidth: 2\n    },\n    fillOpacity: 1,\n    strokeOpacity: 1,\n    strokeWidth: 0,\n    lineDash: [0],\n    lineDashOffset: 0,\n    rotation: 0,\n    sectorSpacing: 1,\n    shadow: {\n      enabled: false,\n      color: DEFAULT_SHADOW_COLOUR,\n      xOffset: 3,\n      yOffset: 3,\n      blur: 5\n    }\n  }\n};\nvar piePaletteFactory = ({ takeColors, colorsCount }) => {\n  const { fills, strokes } = takeColors(colorsCount);\n  return { fills, strokes, calloutLine: { colors: strokes } };\n};\n\n// packages/ag-charts-community/src/chart/series/polar/donutSeriesModule.ts\nvar DonutSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"polar\"],\n  identifier: \"donut\",\n  moduleFactory: (ctx) => new DonutSeries(ctx),\n  tooltipDefaults: { range: \"exact\" },\n  themeTemplate: donutTheme,\n  paletteFactory: piePaletteFactory\n};\n\n// packages/ag-charts-community/src/chart/series/polar/pieSeriesProperties.ts\nvar PieTitle = class extends Caption {\n  constructor() {\n    super(...arguments);\n    this.showInLegend = false;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], PieTitle.prototype, \"showInLegend\", 2);\nvar PieSeriesCalloutLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.offset = 3;\n    this.minAngle = 0;\n    this.minSpacing = 4;\n    this.maxCollisionOffset = 50;\n    this.avoidCollisions = true;\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesCalloutLabel.prototype, \"offset\", 2);\n__decorateClass([\n  Validate(DEGREE)\n], PieSeriesCalloutLabel.prototype, \"minAngle\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesCalloutLabel.prototype, \"minSpacing\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesCalloutLabel.prototype, \"maxCollisionOffset\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], PieSeriesCalloutLabel.prototype, \"avoidCollisions\", 2);\nvar PieSeriesSectorLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.positionOffset = 0;\n    this.positionRatio = 0.5;\n  }\n};\n__decorateClass([\n  Validate(NUMBER)\n], PieSeriesSectorLabel.prototype, \"positionOffset\", 2);\n__decorateClass([\n  Validate(RATIO)\n], PieSeriesSectorLabel.prototype, \"positionRatio\", 2);\nvar PieSeriesCalloutLine = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.length = 10;\n    this.strokeWidth = 1;\n  }\n};\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY, { optional: true })\n], PieSeriesCalloutLine.prototype, \"colors\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesCalloutLine.prototype, \"length\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesCalloutLine.prototype, \"strokeWidth\", 2);\nvar PieSeriesProperties = class extends SeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.fills = Object.values(DEFAULT_FILLS);\n    this.strokes = Object.values(DEFAULT_STROKES);\n    this.fillOpacity = 1;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.cornerRadius = 0;\n    this.rotation = 0;\n    this.outerRadiusOffset = 0;\n    this.outerRadiusRatio = 1;\n    this.strokeWidth = 1;\n    this.sectorSpacing = 0;\n    this.title = new PieTitle();\n    this.shadow = new DropShadow();\n    this.calloutLabel = new PieSeriesCalloutLabel();\n    this.sectorLabel = new PieSeriesSectorLabel();\n    this.calloutLine = new PieSeriesCalloutLine();\n    this.tooltip = new SeriesTooltip();\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], PieSeriesProperties.prototype, \"angleKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"angleName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"angleFilterKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"radiusKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"radiusName\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], PieSeriesProperties.prototype, \"radiusMin\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], PieSeriesProperties.prototype, \"radiusMax\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"calloutLabelKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"calloutLabelName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"sectorLabelKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"sectorLabelName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"legendItemKey\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], PieSeriesProperties.prototype, \"fills\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], PieSeriesProperties.prototype, \"strokes\", 2);\n__decorateClass([\n  Validate(RATIO)\n], PieSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(RATIO)\n], PieSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH)\n], PieSeriesProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesProperties.prototype, \"cornerRadius\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], PieSeriesProperties.prototype, \"itemStyler\", 2);\n__decorateClass([\n  Validate(DEGREE)\n], PieSeriesProperties.prototype, \"rotation\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], PieSeriesProperties.prototype, \"outerRadiusOffset\", 2);\n__decorateClass([\n  Validate(RATIO)\n], PieSeriesProperties.prototype, \"outerRadiusRatio\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], PieSeriesProperties.prototype, \"sectorSpacing\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], PieSeriesProperties.prototype, \"title\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], PieSeriesProperties.prototype, \"shadow\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], PieSeriesProperties.prototype, \"calloutLabel\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], PieSeriesProperties.prototype, \"sectorLabel\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], PieSeriesProperties.prototype, \"calloutLine\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], PieSeriesProperties.prototype, \"tooltip\", 2);\n\n// packages/ag-charts-community/src/chart/series/polar/pieSeries.ts\nvar PieSeriesNodeEvent = class extends SeriesNodeEvent {\n  constructor(type, nativeEvent, datum, series) {\n    super(type, nativeEvent, datum, series);\n    this.angleKey = series.properties.angleKey;\n    this.radiusKey = series.properties.radiusKey;\n    this.calloutLabelKey = series.properties.calloutLabelKey;\n    this.sectorLabelKey = series.properties.sectorLabelKey;\n  }\n};\nvar PieSeries = class extends PolarSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      pickModes: [1 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */],\n      useLabelLayer: true,\n      animationResetFns: { item: resetPieSelectionsFn, label: resetLabelFn }\n    });\n    this.properties = new PieSeriesProperties();\n    this.phantomNodeData = void 0;\n    this.previousRadiusScale = new LinearScale();\n    this.radiusScale = new LinearScale();\n    this.phantomGroup = this.contentGroup.appendChild(new Group());\n    this.phantomSelection = Selection.select(\n      this.phantomGroup,\n      () => this.nodeFactory(),\n      false\n    );\n    this.calloutLabelGroup = this.contentGroup.appendChild(new Group({ name: \"pieCalloutLabels\" }));\n    this.calloutLabelSelection = new Selection(\n      this.calloutLabelGroup,\n      Group\n    );\n    // The group node that contains the background graphics.\n    this.backgroundGroup = this.rootGroup.appendChild(\n      new TranslatableLayer({\n        name: `${this.id}-background`,\n        zIndex: 0 /* SERIES_BACKGROUND */\n      })\n    );\n    // AG-6193 If the sum of all datums is 0, then we'll draw 1 or 2 rings to represent the empty series.\n    this.zerosumRingsGroup = this.backgroundGroup.appendChild(new Group({ name: `${this.id}-zerosumRings` }));\n    this.zerosumOuterRing = this.zerosumRingsGroup.appendChild(new Circle());\n    // When a user toggles a series item (e.g. from the legend), its boolean state is recorded here.\n    this.seriesItemEnabled = [];\n    this.legendItemEnabled = [];\n    this.surroundingRadius = void 0;\n    this.NodeEvent = PieSeriesNodeEvent;\n    this.angleScale = new LinearScale();\n    this.angleScale.domain = [0, 1];\n    this.angleScale.range = [-Math.PI, Math.PI].map((angle2) => angle2 + Math.PI / 2);\n    this.phantomGroup.opacity = 0.2;\n    this.phantomGroup.zIndexSubOrder = [() => this._declarationOrder, 0];\n  }\n  get calloutNodeData() {\n    return this.phantomNodeData ?? this.nodeData;\n  }\n  addChartEventListeners() {\n    this.destroyFns.push(\n      this.ctx.chartEventManager?.addListener(\"legend-item-click\", (event) => this.onLegendItemClick(event))\n    );\n  }\n  get visible() {\n    return super.visible && (this.seriesItemEnabled.length === 0 || this.seriesItemEnabled.includes(true));\n  }\n  nodeFactory() {\n    const sector = new Sector();\n    sector.miterLimit = 1e9;\n    return sector;\n  }\n  getSeriesDomain(direction) {\n    if (direction === \"x\" /* X */) {\n      return this.angleScale.domain;\n    } else {\n      return this.radiusScale.domain;\n    }\n  }\n  async processData(dataController) {\n    if (this.data == null || !this.properties.isValid()) {\n      return;\n    }\n    let { data } = this;\n    const { visible, seriesItemEnabled } = this;\n    const { angleKey, angleFilterKey, radiusKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    const extraKeyProps = [];\n    const extraProps = [];\n    if (legendItemKey) {\n      extraKeyProps.push(keyProperty(legendItemKey, \"band\", { id: `legendItemKey` }));\n    } else if (calloutLabelKey) {\n      extraKeyProps.push(keyProperty(calloutLabelKey, \"band\", { id: `calloutLabelKey` }));\n    } else if (sectorLabelKey) {\n      extraKeyProps.push(keyProperty(sectorLabelKey, \"band\", { id: `sectorLabelKey` }));\n    }\n    const radiusScaleType = this.radiusScale.type;\n    const angleScaleType = this.radiusScale.type;\n    if (radiusKey) {\n      extraProps.push(\n        rangedValueProperty(radiusKey, {\n          id: \"radiusValue\",\n          min: this.properties.radiusMin ?? 0,\n          max: this.properties.radiusMax\n        }),\n        valueProperty(radiusKey, radiusScaleType, { id: `radiusRaw` }),\n        // Raw value pass-through.\n        normalisePropertyTo(\"radiusValue\", [0, 1], 1, this.properties.radiusMin ?? 0, this.properties.radiusMax)\n      );\n    }\n    if (calloutLabelKey) {\n      extraProps.push(valueProperty(calloutLabelKey, \"band\", { id: `calloutLabelValue` }));\n    }\n    if (sectorLabelKey) {\n      extraProps.push(valueProperty(sectorLabelKey, \"band\", { id: `sectorLabelValue` }));\n    }\n    if (legendItemKey) {\n      extraProps.push(valueProperty(legendItemKey, \"band\", { id: `legendItemValue` }));\n    }\n    if (angleFilterKey) {\n      extraProps.push(\n        accumulativeValueProperty(angleFilterKey, angleScaleType, {\n          id: `angleFilterValue`,\n          onlyPositive: true\n        }),\n        valueProperty(angleFilterKey, angleScaleType, { id: `angleFilterRaw` }),\n        normalisePropertyTo(\"angleFilterValue\", [0, 1], 0, 0)\n      );\n    }\n    if (animationEnabled && this.processedData?.reduced?.animationValidation?.uniqueKeys && extraKeyProps.length > 0) {\n      extraProps.push(diff(this.processedData));\n    }\n    extraProps.push(animationValidation());\n    data = data.map((d, idx) => visible && seriesItemEnabled[idx] ? d : { ...d, [angleKey]: 0 });\n    await this.requestDataModel(dataController, data, {\n      props: [\n        ...extraKeyProps,\n        accumulativeValueProperty(angleKey, angleScaleType, { id: `angleValue`, onlyPositive: true }),\n        valueProperty(angleKey, angleScaleType, { id: `angleRaw` }),\n        // Raw value pass-through.\n        normalisePropertyTo(\"angleValue\", [0, 1], 0, 0),\n        ...extraProps\n      ]\n    });\n    for (const valueDef of this.processedData?.defs?.values ?? []) {\n      const { id, missing, property } = valueDef;\n      const missCount = getMissCount(this, missing);\n      if (id !== \"angleRaw\" && missCount > 0) {\n        Logger.warnOnce(\n          `no value was found for the key '${String(property)}' on ${missCount} data element${missCount > 1 ? \"s\" : \"\"}`\n        );\n      }\n    }\n    this.animationState.transition(\"updateData\");\n  }\n  async maybeRefreshNodeData() {\n    if (!this.nodeDataRefresh)\n      return;\n    const { nodeData = [], phantomNodeData } = await this.createNodeData() ?? {};\n    this.nodeData = nodeData;\n    this.phantomNodeData = phantomNodeData;\n    this.nodeDataRefresh = false;\n  }\n  getProcessedDataIndexes(dataModel) {\n    const angleIdx = dataModel.resolveProcessedDataIndexById(this, `angleValue`);\n    const angleRawIdx = dataModel.resolveProcessedDataIndexById(this, `angleRaw`);\n    const angleFilterIdx = this.properties.angleFilterKey != null ? dataModel.resolveProcessedDataIndexById(this, `angleFilterValue`) : void 0;\n    const angleFilterRawIdx = this.properties.angleFilterKey != null ? dataModel.resolveProcessedDataIndexById(this, `angleFilterRaw`) : void 0;\n    const radiusIdx = this.properties.radiusKey ? dataModel.resolveProcessedDataIndexById(this, `radiusValue`) : void 0;\n    const radiusRawIdx = this.properties.radiusKey ? dataModel.resolveProcessedDataIndexById(this, `radiusRaw`) : void 0;\n    const calloutLabelIdx = this.properties.calloutLabelKey ? dataModel.resolveProcessedDataIndexById(this, `calloutLabelValue`) : void 0;\n    const sectorLabelIdx = this.properties.sectorLabelKey ? dataModel.resolveProcessedDataIndexById(this, `sectorLabelValue`) : void 0;\n    const legendItemIdx = this.properties.legendItemKey ? dataModel.resolveProcessedDataIndexById(this, `legendItemValue`) : void 0;\n    return {\n      angleIdx,\n      angleRawIdx,\n      angleFilterIdx,\n      angleFilterRawIdx,\n      radiusIdx,\n      radiusRawIdx,\n      calloutLabelIdx,\n      sectorLabelIdx,\n      legendItemIdx\n    };\n  }\n  async createNodeData() {\n    const { id: seriesId, processedData, dataModel, angleScale } = this;\n    const { rotation } = this.properties;\n    if (!processedData || !dataModel || processedData.type !== \"ungrouped\")\n      return;\n    const {\n      angleIdx,\n      angleRawIdx,\n      angleFilterIdx,\n      angleFilterRawIdx,\n      radiusIdx,\n      radiusRawIdx,\n      calloutLabelIdx,\n      sectorLabelIdx,\n      legendItemIdx\n    } = this.getProcessedDataIndexes(dataModel);\n    const useFilterAngles = angleFilterRawIdx != null && processedData.data.some(({ values }) => {\n      return values[angleFilterRawIdx] > values[angleRawIdx];\n    });\n    let currentStart = 0;\n    let sum2 = 0;\n    const nodes = [];\n    const phantomNodes = angleFilterRawIdx != null ? [] : void 0;\n    processedData.data.forEach((group, index) => {\n      const { datum, values } = group;\n      const currentValue = useFilterAngles ? values[angleFilterIdx] : values[angleIdx];\n      const crossFilterScale = angleFilterRawIdx != null && !useFilterAngles ? Math.sqrt(values[angleFilterRawIdx] / values[angleRawIdx]) : 1;\n      const startAngle = angleScale.convert(currentStart) + toRadians(rotation);\n      currentStart = currentValue;\n      sum2 += currentValue;\n      const endAngle = angleScale.convert(currentStart) + toRadians(rotation);\n      const span = Math.abs(endAngle - startAngle);\n      const midAngle = startAngle + span / 2;\n      const angleValue = values[angleRawIdx];\n      const radiusRaw = radiusIdx != null ? values[radiusIdx] ?? 1 : 1;\n      const radius = radiusRaw * crossFilterScale;\n      const radiusValue = radiusRawIdx != null ? values[radiusRawIdx] : void 0;\n      const legendItemValue = legendItemIdx != null ? values[legendItemIdx] : void 0;\n      const nodeLabels = this.getLabels(\n        datum,\n        midAngle,\n        span,\n        true,\n        calloutLabelIdx != null ? values[calloutLabelIdx] : void 0,\n        sectorLabelIdx != null ? values[sectorLabelIdx] : void 0,\n        legendItemValue\n      );\n      const sectorFormat = this.getSectorFormat(datum, index, false);\n      const node = {\n        itemId: index,\n        series: this,\n        datum,\n        index,\n        angleValue,\n        midAngle,\n        midCos: Math.cos(midAngle),\n        midSin: Math.sin(midAngle),\n        startAngle,\n        endAngle,\n        radius,\n        innerRadius: Math.max(this.radiusScale.convert(0), 0),\n        outerRadius: Math.max(this.radiusScale.convert(radius), 0),\n        sectorFormat,\n        radiusValue,\n        legendItemValue,\n        enabled: this.seriesItemEnabled[index],\n        ...nodeLabels\n      };\n      nodes.push(node);\n      if (phantomNodes != null) {\n        phantomNodes.push({\n          ...node,\n          radius: 1,\n          innerRadius: Math.max(this.radiusScale.convert(0), 0),\n          outerRadius: Math.max(this.radiusScale.convert(1), 0)\n        });\n      }\n    });\n    this.zerosumOuterRing.visible = sum2 === 0;\n    return {\n      itemId: seriesId,\n      nodeData: nodes,\n      labelData: nodes,\n      phantomNodeData: phantomNodes\n    };\n  }\n  getLabels(datum, midAngle, span, skipDisabled, calloutLabelValue, sectorLabelValue, legendItemValue) {\n    const { calloutLabel, sectorLabel, legendItemKey } = this.properties;\n    const calloutLabelKey = !skipDisabled || calloutLabel.enabled ? this.properties.calloutLabelKey : void 0;\n    const sectorLabelKey = !skipDisabled || sectorLabel.enabled ? this.properties.sectorLabelKey : void 0;\n    if (!calloutLabelKey && !sectorLabelKey && !legendItemKey) {\n      return {};\n    }\n    const labelFormatterParams = {\n      datum,\n      angleKey: this.properties.angleKey,\n      angleName: this.properties.angleName,\n      radiusKey: this.properties.radiusKey,\n      radiusName: this.properties.radiusName,\n      calloutLabelKey: this.properties.calloutLabelKey,\n      calloutLabelName: this.properties.calloutLabelName,\n      sectorLabelKey: this.properties.sectorLabelKey,\n      sectorLabelName: this.properties.sectorLabelName,\n      legendItemKey: this.properties.legendItemKey\n    };\n    const result = {};\n    if (calloutLabelKey && span > toRadians(calloutLabel.minAngle)) {\n      result.calloutLabel = {\n        ...this.getTextAlignment(midAngle),\n        text: this.getLabelText(calloutLabel, {\n          ...labelFormatterParams,\n          value: calloutLabelValue\n        }),\n        hidden: false,\n        collisionTextAlign: void 0,\n        collisionOffsetY: 0,\n        box: void 0\n      };\n    }\n    if (sectorLabelKey) {\n      result.sectorLabel = {\n        text: this.getLabelText(sectorLabel, {\n          ...labelFormatterParams,\n          value: sectorLabelValue\n        })\n      };\n    }\n    if (legendItemKey != null && legendItemValue != null) {\n      result.legendItem = { key: legendItemKey, text: legendItemValue };\n    }\n    return result;\n  }\n  getTextAlignment(midAngle) {\n    const quadrantTextOpts = [\n      { textAlign: \"center\", textBaseline: \"bottom\" },\n      { textAlign: \"left\", textBaseline: \"middle\" },\n      { textAlign: \"center\", textBaseline: \"hanging\" },\n      { textAlign: \"right\", textBaseline: \"middle\" }\n    ];\n    const midAngle180 = normalizeAngle180(midAngle);\n    const quadrantStart = -0.75 * Math.PI;\n    const quadrantOffset = midAngle180 - quadrantStart;\n    const quadrant = Math.floor(quadrantOffset / (Math.PI / 2));\n    const quadrantIndex = mod(quadrant, quadrantTextOpts.length);\n    return quadrantTextOpts[quadrantIndex];\n  }\n  getSectorFormat(datum, formatIndex, highlighted) {\n    const { callbackCache } = this.ctx;\n    const { angleKey, radiusKey, calloutLabelKey, sectorLabelKey, legendItemKey, fills, strokes, itemStyler } = this.properties;\n    const defaultStroke = strokes[formatIndex % strokes.length];\n    const { fill, fillOpacity, stroke, strokeWidth, strokeOpacity, lineDash, lineDashOffset, cornerRadius } = mergeDefaults(\n      highlighted && this.properties.highlightStyle.item,\n      {\n        fill: fills.length > 0 ? fills[formatIndex % fills.length] : void 0,\n        stroke: defaultStroke,\n        strokeWidth: this.getStrokeWidth(this.properties.strokeWidth),\n        strokeOpacity: this.getOpacity()\n      },\n      this.properties\n    );\n    let format;\n    if (itemStyler) {\n      format = callbackCache.call(itemStyler, {\n        datum,\n        angleKey,\n        radiusKey,\n        calloutLabelKey,\n        sectorLabelKey,\n        legendItemKey,\n        fill,\n        strokeOpacity,\n        stroke,\n        strokeWidth,\n        fillOpacity,\n        lineDash,\n        lineDashOffset,\n        cornerRadius,\n        highlighted,\n        seriesId: this.id\n      });\n    }\n    return {\n      fill: format?.fill ?? fill,\n      fillOpacity: format?.fillOpacity ?? fillOpacity,\n      stroke: format?.stroke ?? stroke,\n      strokeWidth: format?.strokeWidth ?? strokeWidth,\n      strokeOpacity: format?.strokeOpacity ?? strokeOpacity,\n      lineDash: format?.lineDash ?? lineDash,\n      lineDashOffset: format?.lineDashOffset ?? lineDashOffset,\n      cornerRadius: format?.cornerRadius ?? cornerRadius\n    };\n  }\n  getOuterRadius() {\n    return Math.max(this.radius * this.properties.outerRadiusRatio + this.properties.outerRadiusOffset, 0);\n  }\n  updateRadiusScale(resize) {\n    const newRange = [0, this.getOuterRadius()];\n    this.radiusScale.range = newRange;\n    if (resize) {\n      this.previousRadiusScale.range = newRange;\n    }\n    const setRadii = (d) => ({\n      ...d,\n      innerRadius: Math.max(this.radiusScale.convert(0), 0),\n      outerRadius: Math.max(this.radiusScale.convert(d.radius), 0)\n    });\n    this.nodeData = this.nodeData.map(setRadii);\n    this.phantomNodeData = this.phantomNodeData?.map(setRadii);\n  }\n  getTitleTranslationY() {\n    const outerRadius = Math.max(0, this.radiusScale.range[1]);\n    if (outerRadius === 0) {\n      return NaN;\n    }\n    const spacing = this.properties.title?.spacing ?? 0;\n    const titleOffset = 2 + spacing;\n    const dy = Math.max(0, -outerRadius);\n    return -outerRadius - titleOffset - dy;\n  }\n  async update({ seriesRect }) {\n    const { title } = this.properties;\n    const newNodeDataDependencies = {\n      seriesRectWidth: seriesRect?.width,\n      seriesRectHeight: seriesRect?.height\n    };\n    const resize = jsonDiff(this.nodeDataDependencies, newNodeDataDependencies) != null;\n    if (resize) {\n      this._nodeDataDependencies = newNodeDataDependencies;\n    }\n    await this.maybeRefreshNodeData();\n    this.updateTitleNodes();\n    this.updateRadiusScale(resize);\n    this.contentGroup.translationX = this.centerX;\n    this.contentGroup.translationY = this.centerY;\n    this.highlightGroup.translationX = this.centerX;\n    this.highlightGroup.translationY = this.centerY;\n    this.backgroundGroup.translationX = this.centerX;\n    this.backgroundGroup.translationY = this.centerY;\n    if (this.labelGroup) {\n      this.labelGroup.translationX = this.centerX;\n      this.labelGroup.translationY = this.centerY;\n    }\n    if (title) {\n      const dy = this.getTitleTranslationY();\n      title.node.y = isFinite(dy) ? dy : 0;\n      const titleBox = title.node.getBBox();\n      title.node.visible = title.enabled && isFinite(dy) && !this.bboxIntersectsSurroundingSeries(titleBox);\n    }\n    this.zerosumOuterRing.fillOpacity = 0;\n    this.zerosumOuterRing.stroke = this.properties.calloutLabel.color;\n    this.zerosumOuterRing.strokeWidth = 1;\n    this.zerosumOuterRing.strokeOpacity = 1;\n    this.updateNodeMidPoint();\n    await this.updateSelections();\n    await this.updateNodes(seriesRect);\n  }\n  updateTitleNodes() {\n    const { oldTitle } = this;\n    const { title } = this.properties;\n    if (oldTitle !== title) {\n      if (oldTitle) {\n        this.labelGroup?.removeChild(oldTitle.node);\n      }\n      if (title) {\n        title.node.textBaseline = \"bottom\";\n        this.labelGroup?.appendChild(title.node);\n      }\n      this.oldTitle = title;\n    }\n  }\n  updateNodeMidPoint() {\n    const setMidPoint = (d) => {\n      const radius = d.innerRadius + (d.outerRadius - d.innerRadius) / 2;\n      d.midPoint = {\n        x: d.midCos * Math.max(0, radius),\n        y: d.midSin * Math.max(0, radius)\n      };\n    };\n    this.nodeData.forEach(setMidPoint);\n    this.phantomNodeData?.forEach(setMidPoint);\n  }\n  async updateSelections() {\n    await this.updateGroupSelection();\n  }\n  async updateGroupSelection() {\n    const {\n      itemSelection,\n      highlightSelection,\n      phantomSelection,\n      highlightLabelSelection,\n      calloutLabelSelection,\n      labelSelection\n    } = this;\n    const highlightedNodeData = this.nodeData.map((datum) => ({\n      ...datum,\n      // Allow mutable sectorFormat, so formatted sector styles can be updated and varied\n      // between normal and highlighted cases.\n      sectorFormat: { ...datum.sectorFormat }\n    }));\n    const update = (selection, nodeData) => {\n      selection.update(nodeData, void 0, (datum) => this.getDatumId(datum));\n      if (this.ctx.animationManager.isSkipped()) {\n        selection.cleanup();\n      }\n    };\n    update(itemSelection, this.nodeData);\n    update(highlightSelection, highlightedNodeData);\n    update(phantomSelection, this.phantomNodeData ?? []);\n    calloutLabelSelection.update(this.calloutNodeData, (group) => {\n      const line = new Line();\n      line.tag = 0 /* Callout */;\n      line.pointerEvents = 1 /* None */;\n      group.appendChild(line);\n      const text = new Text();\n      text.tag = 1 /* Label */;\n      text.pointerEvents = 1 /* None */;\n      group.appendChild(text);\n    });\n    labelSelection.update(this.nodeData);\n    highlightLabelSelection.update(highlightedNodeData);\n  }\n  async updateNodes(seriesRect) {\n    const highlightedDatum = this.ctx.highlightManager.getActiveHighlight();\n    const isVisible = this.visible && this.seriesItemEnabled.includes(true);\n    this.rootGroup.visible = isVisible;\n    this.backgroundGroup.visible = isVisible;\n    this.contentGroup.visible = isVisible;\n    this.highlightGroup.visible = isVisible && highlightedDatum?.series === this;\n    this.highlightLabel.visible = isVisible && highlightedDatum?.series === this;\n    if (this.labelGroup) {\n      this.labelGroup.visible = isVisible;\n    }\n    this.contentGroup.opacity = this.getOpacity();\n    const animationDisabled = this.ctx.animationManager.isSkipped();\n    const updateSectorFn = (sector, datum, _index, isDatumHighlighted) => {\n      const format = this.getSectorFormat(datum.datum, datum.itemId, isDatumHighlighted);\n      datum.sectorFormat.fill = format.fill;\n      datum.sectorFormat.stroke = format.stroke;\n      if (animationDisabled) {\n        sector.startAngle = datum.startAngle;\n        sector.endAngle = datum.endAngle;\n        sector.innerRadius = datum.innerRadius;\n        sector.outerRadius = datum.outerRadius;\n      }\n      if (isDatumHighlighted || animationDisabled) {\n        sector.fill = format.fill;\n        sector.stroke = format.stroke;\n      }\n      sector.strokeWidth = format.strokeWidth;\n      sector.fillOpacity = format.fillOpacity;\n      sector.strokeOpacity = format.strokeOpacity;\n      sector.lineDash = format.lineDash;\n      sector.lineDashOffset = format.lineDashOffset;\n      sector.cornerRadius = format.cornerRadius;\n      sector.fillShadow = this.properties.shadow;\n      const inset = Math.max(\n        (this.properties.sectorSpacing + (format.stroke != null ? format.strokeWidth : 0)) / 2,\n        0\n      );\n      sector.inset = inset;\n      sector.lineJoin = this.properties.sectorSpacing >= 0 || inset > 0 ? \"miter\" : \"round\";\n    };\n    this.itemSelection.each((node, datum, index) => updateSectorFn(node, datum, index, false));\n    this.highlightSelection.each((node, datum, index) => {\n      updateSectorFn(node, datum, index, true);\n      node.visible = datum.itemId === highlightedDatum?.itemId;\n    });\n    this.phantomSelection.each((node, datum, index) => updateSectorFn(node, datum, index, false));\n    this.updateCalloutLineNodes();\n    this.updateCalloutLabelNodes(seriesRect);\n    this.updateSectorLabelNodes();\n    this.updateZerosumRings();\n    this.animationState.transition(\"update\");\n  }\n  updateCalloutLineNodes() {\n    const { calloutLine } = this.properties;\n    const calloutLength = calloutLine.length;\n    const calloutStrokeWidth = calloutLine.strokeWidth;\n    const calloutColors = calloutLine.colors ?? this.properties.strokes;\n    const { offset: offset4 } = this.properties.calloutLabel;\n    this.calloutLabelSelection.selectByTag(0 /* Callout */).forEach((line, index) => {\n      const datum = line.datum;\n      const { calloutLabel: label, outerRadius } = datum;\n      if (label?.text && !label.hidden && outerRadius !== 0) {\n        line.visible = true;\n        line.strokeWidth = calloutStrokeWidth;\n        line.stroke = calloutColors[index % calloutColors.length];\n        line.fill = void 0;\n        const x1 = datum.midCos * outerRadius;\n        const y1 = datum.midSin * outerRadius;\n        let x2 = datum.midCos * (outerRadius + calloutLength);\n        let y2 = datum.midSin * (outerRadius + calloutLength);\n        const isMoved = label.collisionTextAlign ?? label.collisionOffsetY !== 0;\n        if (isMoved && label.box != null) {\n          const box = label.box;\n          let cx = x2;\n          let cy = y2;\n          if (x2 < box.x) {\n            cx = box.x;\n          } else if (x2 > box.x + box.width) {\n            cx = box.x + box.width;\n          }\n          if (y2 < box.y) {\n            cy = box.y;\n          } else if (y2 > box.y + box.height) {\n            cy = box.y + box.height;\n          }\n          const dx = cx - x2;\n          const dy = cy - y2;\n          const length2 = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n          const paddedLength = length2 - offset4;\n          if (paddedLength > 0) {\n            x2 = x2 + dx * paddedLength / length2;\n            y2 = y2 + dy * paddedLength / length2;\n          }\n        }\n        line.x1 = x1;\n        line.y1 = y1;\n        line.x2 = x2;\n        line.y2 = y2;\n      } else {\n        line.visible = false;\n      }\n    });\n  }\n  getLabelOverflow(text, box, seriesRect) {\n    const seriesLeft = seriesRect.x - this.centerX;\n    const seriesRight = seriesRect.x + seriesRect.width - this.centerX;\n    const seriesTop = seriesRect.y - this.centerY;\n    const seriesBottom = seriesRect.y + seriesRect.height - this.centerY;\n    const errPx = 1;\n    let visibleTextPart = 1;\n    if (box.x + errPx < seriesLeft) {\n      visibleTextPart = (box.x + box.width - seriesLeft) / box.width;\n    } else if (box.x + box.width - errPx > seriesRight) {\n      visibleTextPart = (seriesRight - box.x) / box.width;\n    }\n    const hasVerticalOverflow = box.y + errPx < seriesTop || box.y + box.height - errPx > seriesBottom;\n    const textLength = visibleTextPart === 1 ? text.length : Math.floor(text.length * visibleTextPart) - 1;\n    const hasSurroundingSeriesOverflow = this.bboxIntersectsSurroundingSeries(box);\n    return { textLength, hasVerticalOverflow, hasSurroundingSeriesOverflow };\n  }\n  bboxIntersectsSurroundingSeries(box) {\n    const { surroundingRadius } = this;\n    if (surroundingRadius == null) {\n      return false;\n    }\n    const corners = [\n      { x: box.x, y: box.y },\n      { x: box.x + box.width, y: box.y },\n      { x: box.x + box.width, y: box.y + box.height },\n      { x: box.x, y: box.y + box.height }\n    ];\n    const sur2 = surroundingRadius ** 2;\n    return corners.some((corner) => corner.x ** 2 + corner.y ** 2 > sur2);\n  }\n  computeCalloutLabelCollisionOffsets() {\n    const { radiusScale } = this;\n    const { calloutLabel, calloutLine } = this.properties;\n    const { offset: offset4, minSpacing } = calloutLabel;\n    const innerRadius = radiusScale.convert(0);\n    const shouldSkip = (datum) => {\n      const label = datum.calloutLabel;\n      return !label || datum.outerRadius === 0;\n    };\n    const fullData = this.calloutNodeData;\n    const data = fullData.filter((t) => !shouldSkip(t));\n    data.forEach((datum) => {\n      const label = datum.calloutLabel;\n      if (label == null)\n        return;\n      label.hidden = false;\n      label.collisionTextAlign = void 0;\n      label.collisionOffsetY = 0;\n    });\n    if (data.length <= 1) {\n      return;\n    }\n    const leftLabels = data.filter((d) => d.midCos < 0).sort((a, b) => a.midSin - b.midSin);\n    const rightLabels = data.filter((d) => d.midCos >= 0).sort((a, b) => a.midSin - b.midSin);\n    const topLabels = data.filter((d) => d.midSin < 0 && d.calloutLabel?.textAlign === \"center\").sort((a, b) => a.midCos - b.midCos);\n    const bottomLabels = data.filter((d) => d.midSin >= 0 && d.calloutLabel?.textAlign === \"center\").sort((a, b) => a.midCos - b.midCos);\n    const getTextBBox = (datum) => {\n      const label = datum.calloutLabel;\n      if (label == null)\n        return BBox.zero.clone();\n      const labelRadius = datum.outerRadius + calloutLine.length + offset4;\n      const x = datum.midCos * labelRadius;\n      const y = datum.midSin * labelRadius + label.collisionOffsetY;\n      const textAlign = label.collisionTextAlign ?? label.textAlign;\n      const textBaseline = label.textBaseline;\n      return Text.computeBBox(label.text, x, y, {\n        font: this.properties.calloutLabel,\n        textAlign,\n        textBaseline\n      });\n    };\n    const avoidNeighbourYCollision = (label, next, direction) => {\n      const box = getTextBBox(label).grow(minSpacing / 2);\n      const other = getTextBBox(next).grow(minSpacing / 2);\n      const collidesOrBehind = box.x < other.x + other.width && box.x + box.width > other.x && (direction === \"to-top\" ? box.y < other.y + other.height : box.y + box.height > other.y);\n      if (collidesOrBehind) {\n        const dy = direction === \"to-top\" ? box.y - other.y - other.height : box.y + box.height - other.y;\n        next.calloutLabel.collisionOffsetY = dy;\n      }\n    };\n    const avoidYCollisions = (labels) => {\n      const midLabel = labels.slice().sort((a, b) => Math.abs(a.midSin) - Math.abs(b.midSin))[0];\n      const midIndex = labels.indexOf(midLabel);\n      for (let i = midIndex - 1; i >= 0; i--) {\n        const prev = labels[i + 1];\n        const next = labels[i];\n        avoidNeighbourYCollision(prev, next, \"to-top\");\n      }\n      for (let i = midIndex + 1; i < labels.length; i++) {\n        const prev = labels[i - 1];\n        const next = labels[i];\n        avoidNeighbourYCollision(prev, next, \"to-bottom\");\n      }\n    };\n    const avoidXCollisions = (labels) => {\n      const labelsCollideLabelsByY = data.some((datum) => datum.calloutLabel.collisionOffsetY !== 0);\n      const boxes = labels.map((label) => getTextBBox(label));\n      const paddedBoxes = boxes.map((box) => box.clone().grow(minSpacing / 2));\n      let labelsCollideLabelsByX = false;\n      for (let i = 0; i < paddedBoxes.length && !labelsCollideLabelsByX; i++) {\n        const box = paddedBoxes[i];\n        for (let j = i + 1; j < labels.length; j++) {\n          const other = paddedBoxes[j];\n          if (box.collidesBBox(other)) {\n            labelsCollideLabelsByX = true;\n            break;\n          }\n        }\n      }\n      const sectors = fullData.map((datum) => {\n        const { startAngle, endAngle, outerRadius } = datum;\n        return { startAngle, endAngle, innerRadius, outerRadius };\n      });\n      const labelsCollideSectors = boxes.some((box) => {\n        return sectors.some((sector) => boxCollidesSector(box, sector));\n      });\n      if (!labelsCollideLabelsByX && !labelsCollideLabelsByY && !labelsCollideSectors) {\n        return;\n      }\n      labels.filter((d) => d.calloutLabel.textAlign === \"center\").forEach((d) => {\n        const label = d.calloutLabel;\n        if (d.midCos < 0) {\n          label.collisionTextAlign = \"right\";\n        } else if (d.midCos > 0) {\n          label.collisionTextAlign = \"left\";\n        } else {\n          label.collisionTextAlign = \"center\";\n        }\n      });\n    };\n    avoidYCollisions(leftLabels);\n    avoidYCollisions(rightLabels);\n    avoidXCollisions(topLabels);\n    avoidXCollisions(bottomLabels);\n  }\n  updateCalloutLabelNodes(seriesRect) {\n    const { radiusScale } = this;\n    const { calloutLabel, calloutLine } = this.properties;\n    const calloutLength = calloutLine.length;\n    const { offset: offset4, color } = calloutLabel;\n    const tempTextNode = new Text();\n    this.calloutLabelSelection.selectByTag(1 /* Label */).forEach((text) => {\n      const { datum } = text;\n      const label = datum.calloutLabel;\n      const radius = radiusScale.convert(datum.radius);\n      const outerRadius = Math.max(0, radius);\n      if (!label?.text || outerRadius === 0 || label.hidden) {\n        text.visible = false;\n        return;\n      }\n      const labelRadius = outerRadius + calloutLength + offset4;\n      const x = datum.midCos * labelRadius;\n      const y = datum.midSin * labelRadius + label.collisionOffsetY;\n      const align = {\n        textAlign: label.collisionTextAlign ?? label.textAlign,\n        textBaseline: label.textBaseline\n      };\n      tempTextNode.text = label.text;\n      tempTextNode.x = x;\n      tempTextNode.y = y;\n      tempTextNode.setFont(this.properties.calloutLabel);\n      tempTextNode.setAlign(align);\n      const box = tempTextNode.getBBox();\n      let displayText = label.text;\n      let visible = true;\n      if (calloutLabel.avoidCollisions) {\n        const { textLength, hasVerticalOverflow } = this.getLabelOverflow(label.text, box, seriesRect);\n        displayText = label.text.length === textLength ? label.text : `${label.text.substring(0, textLength)}\\u2026`;\n        visible = !hasVerticalOverflow;\n      }\n      text.text = displayText;\n      text.x = x;\n      text.y = y;\n      text.setFont(this.properties.calloutLabel);\n      text.setAlign(align);\n      text.fill = color;\n      text.visible = visible;\n    });\n  }\n  async computeLabelsBBox(options, seriesRect) {\n    const { calloutLabel, calloutLine } = this.properties;\n    const calloutLength = calloutLine.length;\n    const { offset: offset4, maxCollisionOffset, minSpacing } = calloutLabel;\n    if (!calloutLabel.avoidCollisions) {\n      return null;\n    }\n    await this.maybeRefreshNodeData();\n    this.updateRadiusScale(false);\n    this.computeCalloutLabelCollisionOffsets();\n    const textBoxes = [];\n    const text = new Text();\n    let titleBox;\n    const { title } = this.properties;\n    if (title?.text && title.enabled) {\n      const dy = this.getTitleTranslationY();\n      if (isFinite(dy)) {\n        text.text = title.text;\n        text.x = 0;\n        text.y = dy;\n        text.setFont(title);\n        text.setAlign({\n          textBaseline: \"bottom\",\n          textAlign: \"center\"\n        });\n        titleBox = text.getBBox();\n        textBoxes.push(titleBox);\n      }\n    }\n    this.calloutNodeData.forEach((datum) => {\n      const label = datum.calloutLabel;\n      if (!label || datum.outerRadius === 0) {\n        return null;\n      }\n      const labelRadius = datum.outerRadius + calloutLength + offset4;\n      const x = datum.midCos * labelRadius;\n      const y = datum.midSin * labelRadius + label.collisionOffsetY;\n      text.text = label.text;\n      text.x = x;\n      text.y = y;\n      text.setFont(this.properties.calloutLabel);\n      text.setAlign({\n        textAlign: label.collisionTextAlign ?? label.textAlign,\n        textBaseline: label.textBaseline\n      });\n      const box = text.getBBox();\n      label.box = box;\n      if (Math.abs(label.collisionOffsetY) > maxCollisionOffset) {\n        label.hidden = true;\n        return;\n      }\n      if (titleBox) {\n        const seriesTop = seriesRect.y - this.centerY;\n        const titleCleanArea = new BBox(\n          titleBox.x - minSpacing,\n          seriesTop,\n          titleBox.width + 2 * minSpacing,\n          titleBox.y + titleBox.height + minSpacing - seriesTop\n        );\n        if (box.collidesBBox(titleCleanArea)) {\n          label.hidden = true;\n          return;\n        }\n      }\n      if (options.hideWhenNecessary) {\n        const { textLength, hasVerticalOverflow, hasSurroundingSeriesOverflow } = this.getLabelOverflow(\n          label.text,\n          box,\n          seriesRect\n        );\n        const isTooShort = label.text.length > 2 && textLength < 2;\n        if (hasVerticalOverflow || isTooShort || hasSurroundingSeriesOverflow) {\n          label.hidden = true;\n          return;\n        }\n      }\n      label.hidden = false;\n      textBoxes.push(box);\n    });\n    if (textBoxes.length === 0) {\n      return null;\n    }\n    return BBox.merge(textBoxes);\n  }\n  updateSectorLabelNodes() {\n    const { radiusScale } = this;\n    const innerRadius = radiusScale.convert(0);\n    const { fontSize, fontStyle, fontWeight, fontFamily, positionOffset, positionRatio, color } = this.properties.sectorLabel;\n    const isDonut = innerRadius > 0;\n    const singleVisibleSector = this.seriesItemEnabled.filter(Boolean).length === 1;\n    const updateSectorLabel = (text, datum) => {\n      const { sectorLabel, outerRadius, startAngle, endAngle } = datum;\n      let isTextVisible = false;\n      if (sectorLabel && outerRadius !== 0) {\n        const labelRadius = innerRadius * (1 - positionRatio) + outerRadius * positionRatio + positionOffset;\n        text.fill = color;\n        text.fontStyle = fontStyle;\n        text.fontWeight = fontWeight;\n        text.fontSize = fontSize;\n        text.fontFamily = fontFamily;\n        text.text = sectorLabel.text;\n        const shouldPutTextInCenter = !isDonut && singleVisibleSector;\n        if (shouldPutTextInCenter) {\n          text.x = 0;\n          text.y = 0;\n        } else {\n          text.x = datum.midCos * labelRadius;\n          text.y = datum.midSin * labelRadius;\n        }\n        text.textAlign = \"center\";\n        text.textBaseline = \"middle\";\n        const bbox = text.getBBox();\n        const corners = [\n          [bbox.x, bbox.y],\n          [bbox.x + bbox.width, bbox.y],\n          [bbox.x + bbox.width, bbox.y + bbox.height],\n          [bbox.x, bbox.y + bbox.height]\n        ];\n        const sectorBounds = { startAngle, endAngle, innerRadius, outerRadius };\n        if (corners.every(([x, y]) => isPointInSector(x, y, sectorBounds))) {\n          isTextVisible = true;\n        }\n      }\n      text.visible = isTextVisible;\n    };\n    this.labelSelection.each(updateSectorLabel);\n    this.highlightLabelSelection.each(updateSectorLabel);\n  }\n  updateZerosumRings() {\n    this.zerosumOuterRing.size = this.getOuterRadius() * 2;\n  }\n  getDatumLegendName(nodeDatum) {\n    const { angleKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;\n    const { sectorLabel, calloutLabel, legendItem } = nodeDatum;\n    if (legendItemKey && legendItem !== void 0) {\n      return legendItem.text;\n    } else if (calloutLabelKey && calloutLabelKey !== angleKey && calloutLabel?.text !== void 0) {\n      return calloutLabel.text;\n    } else if (sectorLabelKey && sectorLabelKey !== angleKey && sectorLabel?.text !== void 0) {\n      return sectorLabel.text;\n    }\n  }\n  pickNodeClosestDatum(point) {\n    return pickByMatchingAngle(this, point);\n  }\n  getTooltipHtml(nodeDatum) {\n    if (!this.properties.isValid()) {\n      return EMPTY_TOOLTIP_CONTENT;\n    }\n    const {\n      datum,\n      angleValue,\n      sectorFormat: { fill: color },\n      itemId\n    } = nodeDatum;\n    const title = sanitizeHtml(this.properties.title?.text);\n    const content = isFiniteNumber(angleValue) ? toFixed(angleValue) : String(angleValue);\n    const labelText = this.getDatumLegendName(nodeDatum);\n    return this.properties.tooltip.toTooltipHtml(\n      {\n        title: title ?? labelText,\n        content: title && labelText ? `${labelText}: ${content}` : content,\n        backgroundColor: color\n      },\n      {\n        datum,\n        itemId,\n        title,\n        color,\n        seriesId: this.id,\n        angleKey: this.properties.angleKey,\n        angleName: this.properties.angleName,\n        radiusKey: this.properties.radiusKey,\n        radiusName: this.properties.radiusName,\n        calloutLabelKey: this.properties.calloutLabelKey,\n        calloutLabelName: this.properties.calloutLabelName,\n        sectorLabelKey: this.properties.sectorLabelKey,\n        sectorLabelName: this.properties.sectorLabelName,\n        legendItemKey: this.properties.legendItemKey\n      }\n    );\n  }\n  getLegendData(legendType) {\n    const { visible, processedData, dataModel } = this;\n    if (!dataModel || !processedData?.data.length || legendType !== \"category\") {\n      return [];\n    }\n    const { angleKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;\n    if (!legendItemKey && (!calloutLabelKey || calloutLabelKey === angleKey) && (!sectorLabelKey || sectorLabelKey === angleKey)) {\n      return [];\n    }\n    const { calloutLabelIdx, sectorLabelIdx, legendItemIdx } = this.getProcessedDataIndexes(dataModel);\n    const titleText = this.properties.title?.showInLegend && this.properties.title.text;\n    const legendData = [];\n    for (let index = 0; index < processedData.data.length; index++) {\n      const { datum, values } = processedData.data[index];\n      const labelParts = [];\n      if (titleText) {\n        labelParts.push(titleText);\n      }\n      const labels = this.getLabels(\n        datum,\n        2 * Math.PI,\n        2 * Math.PI,\n        false,\n        calloutLabelIdx != null ? values[calloutLabelIdx] : void 0,\n        sectorLabelIdx != null ? values[sectorLabelIdx] : void 0,\n        legendItemIdx != null ? values[legendItemIdx] : void 0\n      );\n      if (legendItemKey && labels.legendItem !== void 0) {\n        labelParts.push(labels.legendItem.text);\n      } else if (calloutLabelKey && calloutLabelKey !== angleKey && labels.calloutLabel?.text !== void 0) {\n        labelParts.push(labels.calloutLabel?.text);\n      } else if (sectorLabelKey && sectorLabelKey !== angleKey && labels.sectorLabel?.text !== void 0) {\n        labelParts.push(labels.sectorLabel?.text);\n      }\n      if (labelParts.length === 0)\n        continue;\n      const sectorFormat = this.getSectorFormat(datum, index, false);\n      legendData.push({\n        legendType: \"category\",\n        id: this.id,\n        itemId: index,\n        seriesId: this.id,\n        enabled: visible && this.legendItemEnabled[index],\n        label: {\n          text: labelParts.join(\" - \")\n        },\n        symbols: [\n          {\n            marker: {\n              fill: sectorFormat.fill,\n              stroke: sectorFormat.stroke,\n              fillOpacity: this.properties.fillOpacity,\n              strokeOpacity: this.properties.strokeOpacity,\n              strokeWidth: this.properties.strokeWidth\n            }\n          }\n        ],\n        legendItemName: legendItemKey != null ? datum[legendItemKey] : void 0\n      });\n    }\n    return legendData;\n  }\n  onLegendItemClick(event) {\n    const { enabled, itemId, series, legendItemName } = event;\n    if (series.id === this.id) {\n      this.toggleSeriesItem(itemId, enabled);\n    } else if (legendItemName != null) {\n      this.toggleOtherSeriesItems(legendItemName, enabled);\n    }\n  }\n  toggleSeriesItem(itemId, enabled) {\n    this.seriesItemEnabled[itemId] = enabled;\n    this.legendItemEnabled[itemId] = enabled;\n    if (this.nodeData[itemId]) {\n      this.nodeData[itemId].enabled = enabled;\n    }\n    this.nodeDataRefresh = true;\n  }\n  // Used for grid\n  setLegendState(enabledItems) {\n    this.legendItemEnabled = enabledItems;\n    this.ctx.updateService.update(4 /* SERIES_UPDATE */);\n  }\n  toggleOtherSeriesItems(legendItemName, enabled) {\n    if (!this.properties.legendItemKey || !this.dataModel) {\n      return;\n    }\n    const legendItemIdx = this.dataModel.resolveProcessedDataIndexById(this, `legendItemValue`);\n    this.processedData?.data.forEach(({ values }, datumItemId) => {\n      if (values[legendItemIdx] === legendItemName) {\n        this.toggleSeriesItem(datumItemId, enabled);\n      }\n    });\n  }\n  animateEmptyUpdateReady(_data) {\n    const { animationManager } = this.ctx;\n    const fns = preparePieSeriesAnimationFunctions(\n      true,\n      this.properties.rotation,\n      this.radiusScale,\n      this.previousRadiusScale\n    );\n    fromToMotion(\n      this.id,\n      \"nodes\",\n      animationManager,\n      [this.itemSelection, this.highlightSelection, this.phantomSelection],\n      fns.nodes,\n      (_, datum) => this.getDatumId(datum)\n    );\n    seriesLabelFadeInAnimation(this, \"callout\", animationManager, this.calloutLabelSelection);\n    seriesLabelFadeInAnimation(this, \"sector\", animationManager, this.labelSelection);\n    seriesLabelFadeInAnimation(this, \"highlight\", animationManager, this.highlightLabelSelection);\n    this.previousRadiusScale.range = this.radiusScale.range;\n  }\n  animateWaitingUpdateReady() {\n    const { itemSelection, highlightSelection, phantomSelection, processedData, radiusScale, previousRadiusScale } = this;\n    const { animationManager } = this.ctx;\n    const dataDiff = processedData?.reduced?.diff;\n    this.ctx.animationManager.stopByAnimationGroupId(this.id);\n    const supportedDiff = (dataDiff?.moved.size ?? 0) === 0;\n    const hasKeys = (processedData?.defs.keys.length ?? 0) > 0;\n    const hasUniqueKeys = processedData?.reduced?.animationValidation?.uniqueKeys ?? true;\n    if (!supportedDiff || !hasKeys || !hasUniqueKeys) {\n      this.ctx.animationManager.skipCurrentBatch();\n    }\n    const fns = preparePieSeriesAnimationFunctions(\n      false,\n      this.properties.rotation,\n      radiusScale,\n      previousRadiusScale\n    );\n    fromToMotion(\n      this.id,\n      \"nodes\",\n      animationManager,\n      [itemSelection, highlightSelection, phantomSelection],\n      fns.nodes,\n      (_, datum) => this.getDatumId(datum),\n      dataDiff\n    );\n    seriesLabelFadeInAnimation(this, \"callout\", this.ctx.animationManager, this.calloutLabelSelection);\n    seriesLabelFadeInAnimation(this, \"sector\", this.ctx.animationManager, this.labelSelection);\n    seriesLabelFadeInAnimation(this, \"highlight\", this.ctx.animationManager, this.highlightLabelSelection);\n    this.previousRadiusScale.range = this.radiusScale.range;\n  }\n  animateClearingUpdateEmpty() {\n    const { itemSelection, highlightSelection, phantomSelection, radiusScale, previousRadiusScale } = this;\n    const { animationManager } = this.ctx;\n    const fns = preparePieSeriesAnimationFunctions(\n      false,\n      this.properties.rotation,\n      radiusScale,\n      previousRadiusScale\n    );\n    fromToMotion(\n      this.id,\n      \"nodes\",\n      animationManager,\n      [itemSelection, highlightSelection, phantomSelection],\n      fns.nodes,\n      (_, datum) => this.getDatumId(datum)\n    );\n    seriesLabelFadeOutAnimation(this, \"callout\", this.ctx.animationManager, this.calloutLabelSelection);\n    seriesLabelFadeOutAnimation(this, \"sector\", this.ctx.animationManager, this.labelSelection);\n    seriesLabelFadeOutAnimation(this, \"highlight\", this.ctx.animationManager, this.highlightLabelSelection);\n    this.previousRadiusScale.range = this.radiusScale.range;\n  }\n  getDatumIdFromData(datum) {\n    const { calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;\n    if (!this.processedData?.reduced?.animationValidation?.uniqueKeys) {\n      return;\n    }\n    if (legendItemKey) {\n      return datum[legendItemKey];\n    } else if (calloutLabelKey) {\n      return datum[calloutLabelKey];\n    } else if (sectorLabelKey) {\n      return datum[sectorLabelKey];\n    }\n  }\n  getDatumId(datum) {\n    const { index } = datum;\n    const datumId = this.getDatumIdFromData(datum.datum);\n    return datumId != null ? String(datumId) : `${index}`;\n  }\n  onDataChange() {\n    const { data, seriesItemEnabled, legendItemEnabled } = this;\n    this.seriesItemEnabled = data?.map((_, index) => seriesItemEnabled[index] ?? true) ?? [];\n    this.legendItemEnabled = data?.map((_, index) => legendItemEnabled[index] ?? true) ?? [];\n  }\n};\nPieSeries.className = \"PieSeries\";\nPieSeries.type = \"pie\";\n\n// packages/ag-charts-community/src/chart/series/polar/pieSeriesModule.ts\nvar PieSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"polar\"],\n  identifier: \"pie\",\n  moduleFactory: (ctx) => new PieSeries(ctx),\n  tooltipDefaults: { range: \"exact\" },\n  themeTemplate: pieTheme,\n  paletteFactory: piePaletteFactory\n};\n\n// packages/ag-charts-community/src/util/vector.ts\nvar Vec2 = {\n  add,\n  angle,\n  apply,\n  equal,\n  distance: distance2,\n  distanceSquared: distanceSquared2,\n  from,\n  gradient,\n  intercept,\n  intersectAtX,\n  intersectAtY,\n  length,\n  lengthSquared,\n  multiply,\n  normalized,\n  origin,\n  required,\n  rotate,\n  round: round3,\n  sub\n};\nfunction add(a, b) {\n  if (typeof b === \"number\") {\n    return { x: a.x + b, y: a.y + b };\n  }\n  return { x: a.x + b.x, y: a.y + b.y };\n}\nfunction sub(a, b) {\n  if (typeof b === \"number\") {\n    return { x: a.x - b, y: a.y - b };\n  }\n  return { x: a.x - b.x, y: a.y - b.y };\n}\nfunction multiply(a, b) {\n  if (typeof b === \"number\") {\n    return { x: a.x * b, y: a.y * b };\n  }\n  return { x: a.x * b.x, y: a.y * b.y };\n}\nfunction length(a) {\n  return Math.sqrt(a.x * a.x + a.y * a.y);\n}\nfunction lengthSquared(a) {\n  return a.x * a.x + a.y * a.y;\n}\nfunction distance2(a, b) {\n  const d = sub(a, b);\n  return Math.sqrt(d.x * d.x + d.y * d.y);\n}\nfunction distanceSquared2(a, b) {\n  const d = sub(a, b);\n  return d.x * d.x + d.y * d.y;\n}\nfunction normalized(a) {\n  const l = length(a);\n  return { x: a.x / l, y: a.y / l };\n}\nfunction angle(a, b = origin()) {\n  return Math.atan2(a.y, a.x) - Math.atan2(b.y, b.x);\n}\nfunction rotate(a, theta, b = origin()) {\n  const l = length(a);\n  return { x: b.x + l * Math.cos(theta), y: b.y + l * Math.sin(theta) };\n}\nfunction gradient(a, b, reflection) {\n  const dx = b.x - a.x;\n  const dy = reflection == null ? b.y - a.y : reflection - b.y - (reflection - a.y);\n  return dy / dx;\n}\nfunction intercept(a, gradient2, reflection) {\n  const y = reflection == null ? a.y : reflection - a.y;\n  return y - gradient2 * a.x;\n}\nfunction intersectAtY(gradient2, coefficient, y = 0, reflection) {\n  return {\n    x: gradient2 === Infinity ? Infinity : (y - coefficient) / gradient2,\n    y: reflection == null ? y : reflection - y\n  };\n}\nfunction intersectAtX(gradient2, coefficient, x = 0, reflection) {\n  const y = gradient2 === Infinity ? Infinity : gradient2 * x + coefficient;\n  return { x, y: reflection == null ? y : reflection - y };\n}\nfunction round3(a) {\n  return { x: Math.round(a.x), y: Math.round(a.y) };\n}\nfunction equal(a, b) {\n  return a.x === b.x && a.y === b.y;\n}\nfunction from(a, b) {\n  if (typeof a === \"number\") {\n    return { x: a, y: b };\n  }\n  if (\"regionOffsetX\" in a) {\n    return { x: a.regionOffsetX, y: a.regionOffsetY };\n  }\n  if (\"offsetWidth\" in a) {\n    return { x: a.offsetWidth, y: a.offsetHeight };\n  }\n  if (\"width\" in a) {\n    return [\n      { x: a.x, y: a.y },\n      { x: a.x + a.width, y: a.y + a.height }\n    ];\n  }\n  if (\"x1\" in a) {\n    return [\n      { x: a.x1, y: a.y1 },\n      { x: a.x2, y: a.y2 }\n    ];\n  }\n  throw new Error(`Values can not be converted into a vector: [${a}] [${b}]`);\n}\nfunction apply(a, b) {\n  a.x = b.x;\n  a.y = b.y;\n  return a;\n}\nfunction required(a) {\n  return { x: a?.x ?? 0, y: a?.y ?? 0 };\n}\nfunction origin() {\n  return { x: 0, y: 0 };\n}\n\n// packages/ag-charts-community/src/chart/toolbar/toolbarProperties.ts\nvar ToolbarGroupProperties = class extends BaseProperties {\n  constructor(onChange, onButtonsChange) {\n    super();\n    this.onChange = onChange;\n    this.onButtonsChange = onButtonsChange;\n    this.align = \"start\";\n    this.position = \"top\" /* Top */;\n    this.size = \"normal\";\n    this.buttonOverrides = /* @__PURE__ */ new Map();\n  }\n  buttonConfigurations() {\n    const buttons = [...this.buttons ?? []];\n    if (this.draggable) {\n      buttons.unshift({\n        icon: \"drag-handle\",\n        tooltip: \"toolbarAnnotationsDragHandle\",\n        value: \"drag\",\n        id: \"drag\"\n      });\n    }\n    return buttons?.map((button) => {\n      const id = button.id ?? button.value;\n      const overrides = this.buttonOverrides.get(id);\n      return overrides != null ? { ...button, ...overrides } : button;\n    }) ?? [];\n  }\n  buttonsChanged(configurationOnly) {\n    this.onButtonsChange(this.buttonConfigurations(), configurationOnly);\n  }\n  overrideButtonConfiguration(id, options) {\n    let overrides = this.buttonOverrides.get(id);\n    if (overrides == null) {\n      overrides = /* @__PURE__ */ Object.create(null);\n      this.buttonOverrides.set(id, overrides);\n    }\n    for (const key in options) {\n      const value = options[key];\n      if (value == null) {\n        delete overrides[key];\n      } else {\n        overrides[key] = value;\n      }\n    }\n    this.buttonsChanged(true);\n  }\n};\n__decorateClass([\n  ObserveChanges((target) => {\n    target.onChange(target.enabled);\n  }),\n  Validate(BOOLEAN)\n], ToolbarGroupProperties.prototype, \"enabled\", 2);\n__decorateClass([\n  ObserveChanges((target) => {\n    target.onChange(target.enabled);\n  }),\n  Validate(UNION([...TOOLBAR_ALIGNMENTS]), { optional: true })\n], ToolbarGroupProperties.prototype, \"align\", 2);\n__decorateClass([\n  ObserveChanges((target) => {\n    target.onChange(target.enabled);\n  }),\n  Validate(UNION(TOOLBAR_POSITIONS), { optional: true })\n], ToolbarGroupProperties.prototype, \"position\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], ToolbarGroupProperties.prototype, \"draggable\", 2);\n__decorateClass([\n  ObserveChanges((target) => {\n    target.onChange(target.enabled);\n  }),\n  Validate(UNION([\"small\", \"normal\"]), { optional: true })\n], ToolbarGroupProperties.prototype, \"size\", 2);\n__decorateClass([\n  ObserveChanges((target) => {\n    for (const button of target.buttons ?? []) {\n      if (button.icon != null && ICONS_LEGACY.includes(button.icon)) {\n        Logger.warnOnce(`Icon '${button.icon}' is deprecated, use another icon instead.`);\n      }\n      if (button.ariaLabel === \"toolbarAnnotationsColor\") {\n        Logger.warnOnce(\n          `Aria label '${button.ariaLabel}' is deprecated, use 'toolbarAnnotationsLineColor' instead.`\n        );\n      }\n    }\n    target.buttonsChanged(false);\n  }),\n  Validate(ARRAY, { optional: true })\n], ToolbarGroupProperties.prototype, \"buttons\", 2);\n\n// packages/ag-charts-community/src/chart/toolbar/toolbarStyles.ts\nvar block = \"ag-charts-toolbar\";\nvar elements = {\n  align: \"ag-charts-toolbar__align\",\n  section: \"ag-charts-toolbar__section\",\n  button: \"ag-charts-toolbar__button\",\n  icon: \"ag-charts-toolbar__icon\",\n  label: \"ag-charts-toolbar__label\"\n};\nvar modifiers = {\n  [\"top\" /* Top */]: \"ag-charts-toolbar--top\",\n  [\"right\" /* Right */]: \"ag-charts-toolbar--right\",\n  [\"bottom\" /* Bottom */]: \"ag-charts-toolbar--bottom\",\n  [\"left\" /* Left */]: \"ag-charts-toolbar--left\",\n  [\"floating\" /* Floating */]: \"ag-charts-toolbar--floating\",\n  [\"floating-top\" /* FloatingTop */]: \"ag-charts-toolbar--floating-top\",\n  [\"floating-bottom\" /* FloatingBottom */]: \"ag-charts-toolbar--floating-bottom\",\n  small: \"ag-charts-toolbar--small\",\n  normal: \"ag-charts-toolbar--normal\",\n  hidden: \"ag-charts-toolbar--hidden\",\n  preventFlash: \"ag-charts-toolbar--prevent-flash\",\n  floatingHidden: \"ag-charts-toolbar--floating-hidden\",\n  align: {\n    start: \"ag-charts-toolbar__align--start\",\n    center: \"ag-charts-toolbar__align--center\",\n    end: \"ag-charts-toolbar__align--end\"\n  },\n  button: {\n    first: \"ag-charts-toolbar__button--first\",\n    last: \"ag-charts-toolbar__button--last\",\n    active: \"ag-charts-toolbar__button--active\",\n    hiddenValue: \"ag-charts-toolbar__button--hidden-value\",\n    hiddenToggled: \"ag-charts-toolbar__button--hidden-toggled\",\n    fillVisible: \"ag-charts-toolbar__button--fill-visible\",\n    strokeWidthVisible: \"ag-charts-toolbar__button--stroke-width-visible\",\n    withTransition: \"ag-charts-toolbar__button--with-transition\",\n    dragHandle: \"ag-charts-toolbar__button--drag-handle\",\n    dragging: \"ag-charts-toolbar__button--dragging\"\n  }\n};\n\n// packages/ag-charts-community/src/chart/toolbar/toolbar.ts\nvar Toolbar = class extends BaseModuleInstance {\n  constructor(ctx) {\n    super();\n    this.ctx = ctx;\n    this.enabled = true;\n    this.seriesType = new ToolbarGroupProperties(\n      this.onGroupChanged.bind(this, \"seriesType\"),\n      this.onGroupButtonsChanged.bind(this, \"seriesType\")\n    );\n    this.annotations = new ToolbarGroupProperties(\n      this.onGroupChanged.bind(this, \"annotations\"),\n      this.onGroupButtonsChanged.bind(this, \"annotations\")\n    );\n    this.annotationOptions = new ToolbarGroupProperties(\n      this.onGroupChanged.bind(this, \"annotationOptions\"),\n      this.onGroupButtonsChanged.bind(this, \"annotationOptions\")\n    );\n    this.ranges = new ToolbarGroupProperties(\n      this.onGroupChanged.bind(this, \"ranges\"),\n      this.onGroupButtonsChanged.bind(this, \"ranges\")\n    );\n    this.zoom = new ToolbarGroupProperties(\n      this.onGroupChanged.bind(this, \"zoom\"),\n      this.onGroupButtonsChanged.bind(this, \"zoom\")\n    );\n    this.dragState = {\n      client: { x: 0, y: 0 },\n      position: {\n        x: 0,\n        y: 0\n      },\n      detached: false\n    };\n    this.horizontalSpacing = 10;\n    this.verticalSpacing = 10;\n    this.floatingDetectionRange = 38;\n    this.positions = {\n      [\"top\" /* Top */]: /* @__PURE__ */ new Set(),\n      [\"left\" /* Left */]: /* @__PURE__ */ new Set(),\n      [\"right\" /* Right */]: /* @__PURE__ */ new Set(),\n      [\"bottom\" /* Bottom */]: /* @__PURE__ */ new Set(),\n      [\"floating\" /* Floating */]: /* @__PURE__ */ new Set(),\n      [\"floating-top\" /* FloatingTop */]: /* @__PURE__ */ new Set(),\n      [\"floating-bottom\" /* FloatingBottom */]: /* @__PURE__ */ new Set()\n    };\n    this.positionAlignments = {\n      [\"top\" /* Top */]: {},\n      [\"left\" /* Left */]: {},\n      [\"right\" /* Right */]: {},\n      [\"bottom\" /* Bottom */]: {},\n      [\"floating\" /* Floating */]: {},\n      [\"floating-top\" /* FloatingTop */]: {},\n      [\"floating-bottom\" /* FloatingBottom */]: {}\n    };\n    this.groupCallers = {\n      seriesType: /* @__PURE__ */ new Set(),\n      annotations: /* @__PURE__ */ new Set(),\n      annotationOptions: /* @__PURE__ */ new Set(),\n      ranges: /* @__PURE__ */ new Set(),\n      zoom: /* @__PURE__ */ new Set()\n    };\n    this.groupButtons = {\n      seriesType: [],\n      annotations: [],\n      annotationOptions: [],\n      ranges: [],\n      zoom: []\n    };\n    this.ariaToolbars = [\n      { groups: [\"seriesType\", \"annotations\"], destroyFns: [], resetListeners: () => {\n      } },\n      { groups: [\"annotationOptions\"], destroyFns: [], resetListeners: () => {\n      } },\n      { groups: [\"ranges\"], destroyFns: [], resetListeners: () => {\n      } },\n      { groups: [\"zoom\"], destroyFns: [], resetListeners: () => {\n      } }\n    ];\n    this.pendingButtonToggledEvents = [];\n    this.groupProxied = /* @__PURE__ */ new Map();\n    this.hasNewLocale = true;\n    this.elements = {};\n    for (const position of TOOLBAR_POSITIONS) {\n      this.elements[position] = ctx.domManager.addChild(\"canvas-overlay\", `toolbar-${position}`);\n      this.elements[position].role = \"presentation\";\n      this.renderToolbar(position);\n    }\n    this.toggleVisibilities();\n    const dragStates = 32 /* Default */ | 8 /* Annotations */;\n    const seriesRegion = ctx.regionManager.getRegion(\"series\");\n    this.destroyFns.push(\n      ctx.interactionManager.addListener(\"hover\", this.onHover.bind(this), 63 /* All */),\n      ctx.interactionManager.addListener(\"leave\", this.onLeave.bind(this), 63 /* All */),\n      seriesRegion.addListener(\"drag-start\", this.toggleNoPointerEvents.bind(this, true), dragStates),\n      seriesRegion.addListener(\"drag-end\", this.toggleNoPointerEvents.bind(this, false), 63 /* All */),\n      ctx.toolbarManager.addListener(\"button-toggled\", this.onButtonToggled.bind(this)),\n      ctx.toolbarManager.addListener(\"button-updated\", this.onButtonUpdated.bind(this)),\n      ctx.toolbarManager.addListener(\"group-toggled\", this.onGroupToggled.bind(this)),\n      ctx.toolbarManager.addListener(\"group-updated\", this.onGroupUpdated.bind(this)),\n      ctx.toolbarManager.addListener(\"floating-anchor-changed\", this.onFloatingAnchorChanged.bind(this)),\n      ctx.toolbarManager.addListener(\"proxy-group-options\", this.onProxyGroupOptions.bind(this)),\n      ctx.layoutManager.registerElement(2 /* Toolbar */, this.onLayoutStart.bind(this)),\n      ctx.layoutManager.addListener(\"layout:complete\", this.onLayoutComplete.bind(this)),\n      ctx.updateService.addListener(\"pre-dom-update\", this.onPreDomUpdate.bind(this)),\n      ctx.updateService.addListener(\"update-complete\", this.onUpdateComplete.bind(this)),\n      ctx.localeManager.addListener(\"locale-changed\", () => {\n        this.hasNewLocale = true;\n      }),\n      () => this.destroyElements()\n    );\n  }\n  destroyElements() {\n    this.ctx.domManager.removeStyles(block);\n    for (const element2 of Object.keys(this.elements)) {\n      this.ctx.domManager.removeChild(\"canvas-overlay\", `toolbar-${element2}`);\n    }\n  }\n  onHover(event) {\n    const {\n      enabled,\n      elements: elements2,\n      floatingDetectionRange,\n      ctx: { scene }\n    } = this;\n    const {\n      offsetY,\n      sourceEvent: { target }\n    } = event;\n    const { FloatingBottom, FloatingTop } = ToolbarPosition;\n    if (!enabled)\n      return;\n    const bottom = elements2[FloatingBottom];\n    const top = elements2[FloatingTop];\n    const bottomDetectionY = bottom.offsetTop - floatingDetectionRange;\n    const bottomVisible = offsetY > bottomDetectionY && offsetY < scene.canvas.element.offsetHeight || target === bottom;\n    const topDetectionY = top.offsetTop + top.offsetHeight + floatingDetectionRange;\n    const topVisible = offsetY > 0 && offsetY < topDetectionY || target === top;\n    this.translateFloatingElements(FloatingBottom, bottomVisible);\n    this.translateFloatingElements(FloatingTop, topVisible);\n  }\n  onLeave(event) {\n    const {\n      enabled,\n      ctx: { scene }\n    } = this;\n    const { relatedElement, targetElement } = event;\n    const { FloatingBottom, FloatingTop } = ToolbarPosition;\n    if (!enabled || targetElement !== scene.canvas.element)\n      return;\n    const isTargetButton = TOOLBAR_GROUPS.some(\n      (group) => this.groupButtons[group].some((button) => button === relatedElement)\n    );\n    if (isTargetButton)\n      return;\n    this.translateFloatingElements(FloatingBottom, false);\n    this.translateFloatingElements(FloatingTop, false);\n  }\n  // AG-12695 Temporarily set `pointer-events: none` on the annotationOptions when dragging, because the\n  // buttons block to mouse from hovering over the canvas.\n  toggleNoPointerEvents(on) {\n    const className = \"ag-charts-toolbar__no-pointer-events\";\n    this.groupButtons[\"annotationOptions\"].forEach((b) => b.classList.toggle(className, on));\n  }\n  onGroupChanged(group) {\n    if (this[group] == null || this.groupProxied.has(group))\n      return;\n    this.createGroup(group);\n    this.toggleVisibilities();\n  }\n  onGroupButtonsChanged(group, buttons, configurationOnly) {\n    if (!this.enabled || this.groupProxied.has(group))\n      return;\n    if (configurationOnly) {\n      for (const buttonOptions of this[group].buttonConfigurations()) {\n        this.refreshButtonContent(group, buttonOptions);\n      }\n    } else {\n      this.createGroupButtons(group, buttons);\n    }\n    this.toggleVisibilities();\n  }\n  onLayoutComplete(opts) {\n    for (const position of TOOLBAR_POSITIONS) {\n      this.elements[position].classList.remove(modifiers.preventFlash);\n    }\n    if (this.enabled) {\n      this.refreshInnerLayout(opts.series.rect);\n    }\n  }\n  toggleButtonsTransition(enabled) {\n    const className = modifiers.button.withTransition;\n    for (const button of Object.values(this.groupButtons).flat()) {\n      if (enabled && !button.classList.contains(className)) {\n        button.getBoundingClientRect();\n      }\n      button.classList.toggle(className, enabled);\n    }\n  }\n  onPreDomUpdate() {\n    this.toggleButtonsTransition(false);\n  }\n  onUpdateComplete() {\n    this.toggleButtonsTransition(true);\n  }\n  onButtonUpdated(event) {\n    const { type: _type, group, id, ...params } = event;\n    this[group].overrideButtonConfiguration(id, params);\n  }\n  setButtonActive(button, active) {\n    button.classList.toggle(modifiers.button.active, active);\n  }\n  setButtonChecked(button, checked) {\n    if (button.role === \"switch\") {\n      button.ariaChecked = checked.toString();\n    }\n  }\n  setButtonGroupFirstLast(group) {\n    const childNodes = Array.from(group.childNodes ?? []);\n    const setFirstClass = (first2, button, modifier) => {\n      const buttonVisible = !button.classList.contains(modifiers.button.hiddenToggled);\n      button.classList.toggle(modifier, buttonVisible && first2);\n      return buttonVisible ? false : first2;\n    };\n    let first = true;\n    childNodes.forEach((button) => first = setFirstClass(first, button, modifiers.button.first));\n    let last = true;\n    childNodes.toReversed().forEach((button) => last = setFirstClass(last, button, modifiers.button.last));\n  }\n  onButtonToggled(event) {\n    const { group, id, active, enabled, visible, checked } = event;\n    if (this.groupButtons[group].length === 0) {\n      this.pendingButtonToggledEvents.push(event);\n      return;\n    }\n    const button = this.groupButtons[group].find((b) => b.dataset.toolbarId === `${id}`);\n    if (button == null)\n      return;\n    button.ariaDisabled = `${!enabled}`;\n    button.classList.toggle(modifiers.button.hiddenToggled, !visible);\n    this.setButtonActive(button, active);\n    this.setButtonChecked(button, checked);\n    this.setButtonGroupFirstLast(button.parentNode);\n  }\n  onGroupToggled(event) {\n    const { caller, group, active, visible } = event;\n    this.toggleGroup(caller, group, active, visible);\n    this.toggleVisibilities();\n  }\n  onGroupUpdated(event) {\n    const { group } = event;\n    for (const ariaToolbar of this.ariaToolbars) {\n      if (ariaToolbar.groups.includes(group)) {\n        ariaToolbar.resetListeners();\n        return;\n      }\n    }\n  }\n  onFloatingAnchorChanged(event) {\n    const { elements: elements2, positions, horizontalSpacing, verticalSpacing } = this;\n    const { group, anchor } = event;\n    const element2 = elements2[\"floating\" /* Floating */];\n    if (this.dragState.detached || element2.classList.contains(modifiers.hidden)) {\n      return;\n    }\n    this.dragState.detached = false;\n    if (!positions[\"floating\" /* Floating */].has(group))\n      return;\n    const position = anchor.position ?? \"above\";\n    const { offsetWidth: width2, offsetHeight: height2 } = element2;\n    let top = anchor.y - height2 - verticalSpacing;\n    let left = anchor.x - width2 / 2;\n    if (position === \"below\") {\n      top = anchor.y + verticalSpacing;\n    } else if (position === \"right\") {\n      top = anchor.y - height2 / 2;\n      left = anchor.x + horizontalSpacing;\n    } else if (position === \"above-left\") {\n      left = anchor.x;\n    }\n    const groupBBox = new BBox(left, top, width2, height2);\n    this.positionGroup(element2, group, groupBBox);\n  }\n  positionGroup(element2, group, bbox) {\n    const {\n      ctx: { domManager }\n    } = this;\n    const canvasRect = domManager.getBoundingClientRect();\n    bbox.x = clamp(0, bbox.x, canvasRect.width - bbox.width);\n    bbox.y = clamp(0, bbox.y, canvasRect.height - bbox.height);\n    const left = `${Math.floor(bbox.x)}px`;\n    const top = `${Math.floor(bbox.y)}px`;\n    const dirty = element2.style.getPropertyValue(\"left\") !== left || element2.style.getPropertyValue(\"top\") !== top;\n    if (!dirty)\n      return;\n    element2.style.setProperty(\"left\", left);\n    element2.style.setProperty(\"top\", top);\n    this.onGroupMoved(group, bbox);\n  }\n  onGroupMoved(group, bbox) {\n    const {\n      groupButtons,\n      ctx: { toolbarManager }\n    } = this;\n    for (const button of groupButtons[group]) {\n      if (button.classList.contains(modifiers.button.hiddenToggled))\n        continue;\n      const parent = button.offsetParent;\n      toolbarManager.buttonMoved(\n        group,\n        button.dataset.toolbarId,\n        new BBox(\n          button.offsetLeft + (parent?.offsetLeft ?? 0),\n          button.offsetTop + (parent?.offsetTop ?? 0),\n          button.offsetWidth,\n          button.offsetHeight\n        ),\n        bbox\n      );\n    }\n  }\n  buttonRect(button, canvasRect = this.ctx.domManager.getBoundingClientRect()) {\n    const buttonRect = button.getBoundingClientRect();\n    return new BBox(\n      buttonRect.left - canvasRect.left,\n      buttonRect.top - canvasRect.top,\n      buttonRect.width,\n      buttonRect.height\n    );\n  }\n  onProxyGroupOptions(event) {\n    if (!this.enabled)\n      return;\n    const { caller, group, options } = event;\n    this.groupProxied.set(group, options);\n    this[group].set(options);\n    this.toggleGroup(caller, group, void 0, options.enabled);\n    this.createGroup(group, options.enabled, options.position);\n    if (options.enabled) {\n      this.createGroupButtons(group, options.buttons);\n    }\n  }\n  createGroup(group, enabled, position) {\n    enabled ?? (enabled = this[group].enabled);\n    position ?? (position = this[group].position);\n    for (const pos of TOOLBAR_POSITIONS) {\n      if (enabled && position === pos) {\n        this.positions[pos].add(group);\n      } else {\n        this.positions[pos].delete(group);\n      }\n    }\n  }\n  createGroupButtons(group, buttons = []) {\n    for (const button of this.groupButtons[group]) {\n      button.remove();\n    }\n    this.groupButtons[group] = [];\n    if (buttons.length === 0)\n      return;\n    const { align, position } = this[group];\n    const alignElement = this.positionAlignments[position][align];\n    if (!alignElement)\n      return;\n    const nextSection = (section2) => {\n      const alignElementChildren = Array.from(alignElement.children);\n      const dataGroup = \"data-group\";\n      const dataSection = \"data-section\";\n      let sectionElement = alignElementChildren.find((prevSection2) => {\n        return prevSection2.getAttribute(dataGroup) === group && prevSection2.getAttribute(dataSection) === (section2 ?? \"\");\n      });\n      if (!sectionElement) {\n        sectionElement = createElement(\"div\");\n        sectionElement.role = \"presentation\";\n        sectionElement.setAttribute(dataGroup, group);\n        sectionElement.setAttribute(dataSection, section2 ?? \"\");\n        const groupIndex = TOOLBAR_GROUP_ORDERING[group];\n        const insertBeforeElement = alignElementChildren.find((prevSection2) => {\n          const prevGroup = prevSection2.getAttribute(dataGroup);\n          const prevGroupIndex = TOOLBAR_GROUP_ORDERING[prevGroup];\n          return prevGroupIndex > groupIndex;\n        });\n        if (insertBeforeElement != null) {\n          alignElement.insertBefore(sectionElement, insertBeforeElement);\n        } else {\n          alignElement.appendChild(sectionElement);\n        }\n        this.destroyFns.push(() => sectionElement.remove());\n      }\n      sectionElement.classList.add(elements.section, modifiers[this[group].size]);\n      return sectionElement;\n    };\n    let prevSection = buttons.at(0)?.section;\n    let section = nextSection(prevSection);\n    for (const options of buttons) {\n      if (prevSection !== options.section) {\n        this.setButtonGroupFirstLast(section);\n        section = nextSection(options.section);\n      }\n      prevSection = options.section;\n      const button = this.createButtonElement(group, options);\n      section.appendChild(button);\n      this.groupButtons[group].push(button);\n    }\n    this.setButtonGroupFirstLast(section);\n    const onEscape = () => {\n      this.ctx.toolbarManager.cancel(group);\n    };\n    let onFocus;\n    let onBlur;\n    if (isAnimatingFloatingPosition(position)) {\n      onFocus = () => this.translateFloatingElements(position, true);\n      onBlur = () => this.translateFloatingElements(position, false);\n    }\n    this.createAriaToolbar(group, alignElement, onFocus, onBlur, onEscape);\n  }\n  createAriaToolbar(group, toolbar, onFocus, onBlur, onEscape) {\n    const orientation = this.computeAriaOrientation(this[group].position);\n    const ariaToolbar = this.getAriaToolbar(group);\n    ariaToolbar.resetListeners = () => {\n      const buttons = ariaToolbar.groups.map((g) => this.groupButtons[g]).flat().filter(\n        (b) => !b.classList.contains(modifiers.button.hiddenToggled) && !b.classList.contains(modifiers.button.dragHandle)\n      );\n      ariaToolbar.destroyFns.forEach((d) => d());\n      ariaToolbar.destroyFns = initToolbarKeyNav({ orientation, toolbar, buttons, onEscape, onFocus, onBlur });\n    };\n    ariaToolbar.resetListeners();\n    this.updateToolbarAriaLabel(group, toolbar);\n  }\n  computeAriaOrientation(position) {\n    return {\n      top: \"horizontal\",\n      right: \"vertical\",\n      bottom: \"horizontal\",\n      left: \"vertical\",\n      floating: \"horizontal\",\n      \"floating-top\": \"horizontal\",\n      \"floating-bottom\": \"horizontal\"\n    }[position];\n  }\n  toggleGroup(caller, group, active, enabled) {\n    if (enabled === true) {\n      this.groupCallers[group].add(caller);\n    } else if (enabled === false) {\n      this.groupCallers[group].delete(caller);\n    }\n    if (active != null) {\n      for (const button of this.groupButtons[group]) {\n        this.setButtonActive(button, active);\n      }\n    }\n  }\n  processPendingEvents() {\n    const pendingButtonToggledEvents = (this.pendingButtonToggledEvents ?? []).slice();\n    for (const event of pendingButtonToggledEvents) {\n      this.onButtonToggled(event);\n    }\n    this.pendingButtonToggledEvents = [];\n  }\n  onLayoutStart(ctx) {\n    if (this.enabled) {\n      this.refreshOuterLayout(ctx.layoutBox);\n      this.refreshLocale();\n    }\n  }\n  refreshOuterLayout(shrinkRect) {\n    const { elements: elements2, horizontalSpacing, verticalSpacing } = this;\n    if (!elements2.top.classList.contains(modifiers.hidden)) {\n      shrinkRect.shrink(elements2.top.offsetHeight + verticalSpacing, \"top\");\n    }\n    if (!elements2.right.classList.contains(modifiers.hidden)) {\n      shrinkRect.shrink(elements2.right.offsetWidth + horizontalSpacing, \"right\");\n    }\n    if (!elements2.bottom.classList.contains(modifiers.hidden)) {\n      shrinkRect.shrink(elements2.bottom.offsetHeight + verticalSpacing, \"bottom\");\n      elements2.bottom.style.top = `${shrinkRect.y + shrinkRect.height + verticalSpacing}px`;\n    }\n    if (!elements2.left.classList.contains(modifiers.hidden)) {\n      shrinkRect.shrink(elements2.left.offsetWidth + horizontalSpacing, \"left\");\n    }\n  }\n  refreshLocale() {\n    const { hasNewLocale } = this;\n    if (!hasNewLocale)\n      return;\n    for (const group of TOOLBAR_GROUPS) {\n      const buttons = this[group].buttonConfigurations();\n      for (const buttonOptions of buttons) {\n        this.refreshButtonContent(group, buttonOptions);\n      }\n      this.updateToolbarAriaLabel(group);\n    }\n    this.hasNewLocale = false;\n  }\n  refreshInnerLayout(rect) {\n    const { elements: elements2, verticalSpacing } = this;\n    const { FloatingBottom, FloatingTop } = ToolbarPosition;\n    elements2.top.style.top = `${rect.y - elements2.top.offsetHeight - verticalSpacing}px`;\n    elements2.top.style.left = `${rect.x}px`;\n    elements2.top.style.width = `${rect.width}px`;\n    elements2.bottom.style.left = `${rect.x}px`;\n    elements2.bottom.style.width = `${rect.width}px`;\n    elements2.right.style.top = `${rect.y}px`;\n    elements2.right.style.right = `0px`;\n    elements2.right.style.height = `${rect.height}px`;\n    elements2.left.style.top = `${rect.y}px`;\n    elements2.left.style.left = `0px`;\n    elements2.left.style.height = `${rect.height}px`;\n    elements2[FloatingTop].style.top = `${rect.y}px`;\n    elements2[FloatingBottom].style.top = `${rect.y + rect.height - elements2[FloatingBottom].offsetHeight}px`;\n  }\n  refreshButtonContent(group, buttonOptions) {\n    const id = this.buttonId(buttonOptions);\n    const button = this.groupProxied.get(group)?.buttons?.find((b) => this.buttonId(b) === id) ?? buttonOptions;\n    const element2 = this.groupButtons[group].find((b) => b.getAttribute(\"data-toolbar-id\") === id);\n    if (element2 == null)\n      return;\n    this.updateButton(element2, button);\n  }\n  toggleVisibilities() {\n    if (this.elements == null)\n      return;\n    const isGroupVisible = (group) => this[group].enabled && this.groupCallers[group].size > 0;\n    const isButtonVisible = (element2) => (button) => {\n      const id = this.buttonId(button);\n      return id == null || id === element2.dataset.toolbarId;\n    };\n    for (const position of TOOLBAR_POSITIONS) {\n      const visible = this.enabled && Array.from(this.positions[position].values()).some(isGroupVisible);\n      if (position === \"floating\" /* Floating */ && !visible) {\n        this.dragState.detached = false;\n      }\n      this.elements[position].classList.toggle(modifiers.hidden, !visible);\n    }\n    for (const group of TOOLBAR_GROUPS) {\n      if (this[group] == null)\n        continue;\n      const groupVisible = isGroupVisible(group);\n      for (const button of this.groupButtons[group]) {\n        const buttonVisible = groupVisible && this[group].buttonConfigurations().some(isButtonVisible(button));\n        button.classList.toggle(modifiers.button.hiddenValue, !buttonVisible);\n      }\n    }\n  }\n  translateFloatingElements(position, visible) {\n    const { elements: elements2, verticalSpacing: verticalMargin, positionAlignments } = this;\n    const element2 = elements2[position];\n    const alignments = Object.values(positionAlignments[position]);\n    element2.classList.toggle(modifiers.floatingHidden, !visible);\n    const dir = position === \"floating-bottom\" /* FloatingBottom */ ? 1 : -1;\n    for (const align of alignments) {\n      align.style.transform = visible && align.style.transform !== \"\" ? \"translateY(0)\" : `translateY(${(element2.offsetHeight + verticalMargin) * dir}px)`;\n    }\n  }\n  renderToolbar(position = \"top\" /* Top */) {\n    const element2 = this.elements[position];\n    element2.classList.add(block, modifiers[position], modifiers.preventFlash);\n    if (isAnimatingFloatingPosition(position)) {\n      element2.classList.add(modifiers.floatingHidden);\n    }\n    for (const align of TOOLBAR_ALIGNMENTS) {\n      const alignmentElement = createElement(\"div\");\n      alignmentElement.role = \"presentation\";\n      alignmentElement.classList.add(elements.align, modifiers.align[align]);\n      element2.appendChild(alignmentElement);\n      this.positionAlignments[position][align] = alignmentElement;\n    }\n  }\n  createButtonElement(group, options) {\n    const button = createElement(\"button\");\n    button.classList.add(elements.button);\n    button.dataset.toolbarGroup = group;\n    setAttribute(button, \"tabindex\", -1);\n    if (options.haspopup) {\n      setAttributes(button, { \"aria-haspopup\": true, \"aria-expanded\": false });\n    }\n    button.dataset.toolbarId = this.buttonId(options);\n    button.addEventListener(\n      \"click\",\n      makeAccessibleClickListener(\n        button,\n        (event) => this.onButtonPress(event, button, group, options.id, options.value)\n      )\n    );\n    if (options.value === \"drag\") {\n      button.addEventListener(\n        \"mousedown\",\n        makeAccessibleClickListener(button, (event) => this.onDragStart(event, button, group))\n      );\n      button.classList.add(modifiers.button.dragHandle);\n    }\n    if (options.role === \"switch\") {\n      setAttributes(button, { role: options.role, \"aria-checked\": false });\n    }\n    this.updateButton(button, options);\n    this.destroyFns.push(() => button.remove());\n    return button;\n  }\n  getAriaToolbar(group) {\n    for (const ariaToolbar of this.ariaToolbars) {\n      if (ariaToolbar.groups.includes(group)) {\n        return ariaToolbar;\n      }\n    }\n    throw new Error(`AG Charts - cannot find aria-toolbar of '${group}'`);\n  }\n  updateToolbarAriaLabel(group, alignElement) {\n    if (!alignElement) {\n      const { align, position } = this[group];\n      alignElement = this.positionAlignments[position][align];\n      if (!alignElement)\n        return;\n    }\n    const map = {\n      seriesType: \"ariaLabelFinancialCharts\",\n      annotations: \"ariaLabelFinancialCharts\",\n      annotationOptions: \"ariaLabelAnnotationOptionsToolbar\",\n      ranges: \"ariaLabelRangesToolbar\",\n      zoom: \"ariaLabelZoomToolbar\"\n    };\n    alignElement.ariaLabel = this.ctx.localeManager.t(map[group]);\n  }\n  expandButtonConfig(button, options) {\n    if (options.role !== \"switch\" || button.ariaChecked !== \"true\" || options.checkedOverrides === void 0)\n      return options;\n    return {\n      icon: options.checkedOverrides.icon ?? options.icon,\n      label: options.checkedOverrides.label ?? options.label,\n      ariaLabel: options.checkedOverrides.ariaLabel ?? options.ariaLabel,\n      tooltip: options.checkedOverrides.tooltip ?? options.tooltip\n    };\n  }\n  updateButton(button, options) {\n    const { domManager, localeManager } = this.ctx;\n    const { icon, label, ariaLabel, tooltip } = this.expandButtonConfig(button, options);\n    if (tooltip) {\n      button.title = localeManager.t(tooltip);\n    }\n    let inner = \"\";\n    if (icon != null) {\n      inner = `<span class=\"${domManager.getIconClassNames(icon)} ${elements.icon}\"></span>`;\n    }\n    if (label != null) {\n      const tlabel = localeManager.t(label);\n      inner = `${inner}<span class=\"${elements.label}\">${tlabel}</span>`;\n    }\n    button.innerHTML = inner;\n    button.classList.toggle(modifiers.button.fillVisible, options.fill != null);\n    button.style.setProperty(\"--fill\", options.fill ?? null);\n    const strokeWidthVisible = options.strokeWidth != null;\n    button.classList.toggle(modifiers.button.strokeWidthVisible, strokeWidthVisible);\n    button.style.setProperty(\"--strokeWidth\", strokeWidthVisible ? `${options.strokeWidth}px` : null);\n    const tAriaLabel = ariaLabel ? this.ctx.localeManager.t(ariaLabel) : void 0;\n    setAttribute(button, \"aria-label\", tAriaLabel);\n  }\n  onButtonPress(event, button, group, id, value) {\n    this.ctx.toolbarManager.pressButton(group, this.buttonId({ id, value }), value, this.buttonRect(button), event);\n  }\n  onDragStart(event, button, group) {\n    const element2 = this.elements[\"floating\" /* Floating */];\n    event.preventDefault();\n    event.stopPropagation();\n    this.dragState = {\n      client: Vec2.from(event.clientX, event.clientY),\n      position: Vec2.from(\n        Number(element2.style.getPropertyValue(\"left\").replace(\"px\", \"\")),\n        Number(element2.style.getPropertyValue(\"top\").replace(\"px\", \"\"))\n      ),\n      detached: true\n    };\n    button.classList.toggle(modifiers.button.dragging, true);\n    const onDrag = (e) => this.onDrag(e, group);\n    const onDragEnd = () => {\n      button.classList.toggle(modifiers.button.dragging, false);\n      window2.removeEventListener(\"mousemove\", onDrag);\n    };\n    const window2 = getWindow();\n    window2.addEventListener(\"mousemove\", onDrag);\n    window2.addEventListener(\"mouseup\", onDragEnd, {\n      once: true\n    });\n    this.ctx.toolbarManager.groupMoved(group);\n  }\n  onDrag(event, group) {\n    const { elements: elements2, dragState } = this;\n    const element2 = elements2[\"floating\" /* Floating */];\n    const { offsetWidth: width2, offsetHeight: height2 } = element2;\n    const offset4 = Vec2.sub(Vec2.from(event.clientX, event.clientY), dragState.client);\n    const position = Vec2.add(dragState.position, offset4);\n    const groupBBox = new BBox(position.x, position.y, width2, height2);\n    this.positionGroup(element2, group, groupBBox);\n  }\n  buttonId(button) {\n    const { id, value, label } = button;\n    if (id != null) {\n      return id;\n    } else if (value != null && typeof value !== \"object\") {\n      return String(value);\n    }\n    return label ?? \"\";\n  }\n};\n__decorateClass([\n  ObserveChanges((target) => {\n    target.processPendingEvents();\n    target.toggleVisibilities();\n  }),\n  Validate(BOOLEAN)\n], Toolbar.prototype, \"enabled\", 2);\n\n// packages/ag-charts-community/src/chart/toolbar/toolbarModule.ts\nvar DAY = 1e3 * 60 * 60 * 24;\nvar MONTH = DAY * 30;\nvar YEAR = DAY * 365;\nvar seriesType = {\n  enabled: false,\n  position: \"left\",\n  align: \"start\",\n  buttons: [\n    {\n      tooltip: \"toolbarSeriesTypeDropdown\",\n      value: \"type\",\n      // @ts-expect-error\n      haspopup: true\n    }\n  ]\n};\nvar annotations = {\n  enabled: true,\n  position: \"left\",\n  align: \"start\",\n  buttons: [\n    {\n      icon: \"trend-line-drawing\",\n      tooltip: \"toolbarAnnotationsLineAnnotations\",\n      value: \"line-menu\",\n      section: \"line-annotations\",\n      // @ts-expect-error\n      haspopup: true\n    },\n    {\n      icon: \"text-annotation\",\n      tooltip: \"toolbarAnnotationsTextAnnotations\",\n      value: \"text-menu\",\n      section: \"text-annotations\",\n      // @ts-expect-error\n      haspopup: true\n    },\n    {\n      icon: \"arrow-drawing\",\n      tooltip: \"toolbarAnnotationsShapeAnnotations\",\n      value: \"shape-menu\",\n      section: \"shape-annotations\",\n      // @ts-expect-error\n      haspopup: true\n    },\n    {\n      icon: \"measurer-drawing\",\n      tooltip: \"toolbarAnnotationsMeasurerAnnotations\",\n      value: \"measurer-menu\",\n      section: \"measure-annotations\",\n      // @ts-expect-error\n      haspopup: true\n    },\n    {\n      icon: \"delete\",\n      tooltip: \"toolbarAnnotationsClearAll\",\n      value: \"clear\",\n      section: \"tools\"\n    }\n  ]\n};\nvar annotationOptions = {\n  enabled: true,\n  position: \"floating\",\n  align: \"start\",\n  draggable: true,\n  buttons: [\n    {\n      icon: \"text-annotation\",\n      tooltip: \"toolbarAnnotationsTextColor\",\n      value: \"text-color\",\n      // @ts-expect-error\n      haspopup: true\n    },\n    {\n      icon: \"line-color\",\n      tooltip: \"toolbarAnnotationsLineColor\",\n      value: \"line-color\",\n      // @ts-expect-error\n      haspopup: true\n    },\n    {\n      icon: \"fill-color\",\n      tooltip: \"toolbarAnnotationsFillColor\",\n      value: \"fill-color\",\n      // @ts-expect-error\n      haspopup: true\n    },\n    {\n      tooltip: \"toolbarAnnotationsTextSize\",\n      value: \"text-size\",\n      // @ts-expect-error\n      haspopup: true\n    },\n    {\n      tooltip: \"toolbarAnnotationsLineStrokeWidth\",\n      value: \"line-stroke-width\",\n      // @ts-expect-error\n      haspopup: true\n    },\n    {\n      icon: \"line-style-solid\",\n      tooltip: \"toolbarAnnotationsLineStyle\",\n      value: \"line-style-type\",\n      // @ts-expect-error\n      haspopup: true\n    },\n    {\n      icon: \"settings\",\n      tooltip: \"toolbarAnnotationsSettings\",\n      value: \"settings\",\n      // @ts-expect-error\n      haspopup: true\n    },\n    {\n      role: \"switch\",\n      icon: \"unlocked\",\n      tooltip: \"toolbarAnnotationsLock\",\n      ariaLabel: \"toolbarAnnotationsLock\",\n      checkedOverrides: {\n        icon: \"locked\",\n        tooltip: \"toolbarAnnotationsUnlock\"\n      },\n      value: \"lock\"\n    },\n    {\n      icon: \"delete\",\n      tooltip: \"toolbarAnnotationsDelete\",\n      value: \"delete\"\n    }\n  ]\n};\nvar ranges = {\n  enabled: false,\n  position: DEFAULT_TOOLBAR_POSITION,\n  align: \"start\",\n  buttons: [\n    {\n      label: \"toolbarRange1Month\",\n      ariaLabel: \"toolbarRange1MonthAria\",\n      value: MONTH\n    },\n    {\n      label: \"toolbarRange3Months\",\n      ariaLabel: \"toolbarRange3MonthsAria\",\n      value: 3 * MONTH\n    },\n    {\n      label: \"toolbarRange6Months\",\n      ariaLabel: \"toolbarRange6MonthsAria\",\n      value: 6 * MONTH\n    },\n    {\n      label: \"toolbarRangeYearToDate\",\n      ariaLabel: \"toolbarRangeYearToDateAria\",\n      value: (_start, end2) => [(/* @__PURE__ */ new Date(`${new Date(end2).getFullYear()}-01-01`)).getTime(), end2],\n      id: \"year-to-date\"\n    },\n    {\n      label: \"toolbarRange1Year\",\n      ariaLabel: \"toolbarRange1YearAria\",\n      value: YEAR\n    },\n    {\n      label: \"toolbarRangeAll\",\n      ariaLabel: \"toolbarRangeAllAria\",\n      value: (start2, end2) => [start2, end2],\n      id: \"all\"\n    }\n  ]\n};\nvar zoom = {\n  enabled: true,\n  position: \"top\",\n  align: \"end\",\n  buttons: [\n    {\n      icon: \"zoom-out\",\n      tooltip: \"toolbarZoomZoomOut\",\n      value: \"zoom-out\"\n    },\n    {\n      icon: \"zoom-in\",\n      tooltip: \"toolbarZoomZoomIn\",\n      value: \"zoom-in\"\n    },\n    {\n      icon: \"pan-left\",\n      tooltip: \"toolbarZoomPanLeft\",\n      value: \"pan-left\"\n    },\n    {\n      icon: \"pan-right\",\n      tooltip: \"toolbarZoomPanRight\",\n      value: \"pan-right\"\n    },\n    {\n      icon: \"pan-start\",\n      tooltip: \"toolbarZoomPanStart\",\n      value: \"pan-start\"\n    },\n    {\n      icon: \"pan-end\",\n      tooltip: \"toolbarZoomPanEnd\",\n      value: \"pan-end\"\n    },\n    {\n      icon: \"reset\",\n      tooltip: \"toolbarZoomReset\",\n      value: \"reset\"\n    }\n  ]\n};\nvar ToolbarModule = {\n  type: \"root\",\n  optionsKey: \"toolbar\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  moduleFactory: (ctx) => new Toolbar(ctx),\n  themeTemplate: {\n    toolbar: {\n      enabled: true,\n      seriesType,\n      annotations,\n      annotationOptions,\n      ranges,\n      zoom\n    }\n  }\n};\n\n// packages/ag-charts-community/src/chart/factory/registerInbuiltModules.ts\nfunction registerInbuiltModules() {\n  moduleRegistry.register(\n    BackgroundModule,\n    CommunityLegendModule,\n    LocaleModule,\n    NavigatorModule,\n    ToolbarModule,\n    AreaSeriesModule,\n    BarSeriesModule,\n    BubbleSeriesModule,\n    LineSeriesModule,\n    ScatterSeriesModule,\n    DonutSeriesModule,\n    PieSeriesModule,\n    HistogramSeriesModule\n  );\n  for (const AxisConstructor of [NumberAxis, CategoryAxis, TimeAxis, GroupedCategoryAxis, LogAxis]) {\n    axisRegistry.register(AxisConstructor.type, {\n      moduleFactory: (ctx) => new AxisConstructor(ctx),\n      hidden: AxisConstructor === GroupedCategoryAxis\n    });\n  }\n}\n\n// packages/ag-charts-community/src/chart/factory/setupModules.ts\nfunction setupModules() {\n  for (const m of moduleRegistry.modules) {\n    if (m.packageType === \"enterprise\" && !verifyIfModuleExpected(m)) {\n      Logger.errorOnce(\"Unexpected enterprise module registered: \" + m.identifier);\n    }\n    if (m.type === \"root\" && m.themeTemplate) {\n      for (const chartType2 of m.chartTypes) {\n        chartDefaults.set(chartType2, m.themeTemplate);\n      }\n    }\n    if (m.type === \"series\") {\n      if (m.chartTypes.length > 1) {\n        throw new Error(`AG Charts - Module definition error: ${m.identifier}`);\n      }\n      seriesRegistry.register(m.identifier, m);\n    }\n    if (m.type === \"series-option\" && m.themeTemplate) {\n      for (const seriesType2 of m.seriesTypes) {\n        seriesRegistry.setThemeTemplate(seriesType2, m.themeTemplate);\n      }\n    }\n    if (m.type === \"axis-option\" && m.themeTemplate) {\n      for (const axisType of m.axisTypes) {\n        const axisTypeTheme = axisRegistry.getThemeTemplate(axisType);\n        const theme = mergeDefaults(m.themeTemplate, axisTypeTheme);\n        axisRegistry.setThemeTemplate(axisType, theme);\n      }\n    }\n    if (m.type === \"axis\") {\n      axisRegistry.register(m.identifier, m);\n    }\n    if (m.type === \"legend\") {\n      legendRegistry.register(m.identifier, m);\n    }\n  }\n  if (moduleRegistry.hasEnterpriseModules()) {\n    const expectedButUnused = getUnusedExpectedModules();\n    if (expectedButUnused.length > 0) {\n      Logger.errorOnce(\"Enterprise modules expected but not registered: \", expectedButUnused);\n    }\n  }\n}\n\n// packages/ag-charts-community/src/chart/flowProportionChart.ts\nfunction isFlowProportion(series) {\n  return series.type === \"sankey\" || series.type === \"chord\";\n}\nvar FlowProportionChart = class extends Chart {\n  getChartType() {\n    return \"flow-proportion\";\n  }\n  async updateData() {\n    await super.updateData();\n    const { nodes } = this.getOptions();\n    this.series.forEach((series) => {\n      if (isFlowProportion(series)) {\n        series.setChartNodes(nodes);\n      }\n    });\n  }\n  performLayout(ctx) {\n    const { seriesRoot, annotationRoot, highlightRoot } = this;\n    const { layoutBox } = ctx;\n    const seriesRect = layoutBox.clone();\n    layoutBox.shrink(this.seriesArea.padding.toJson());\n    this.seriesRect = layoutBox;\n    this.animationRect = layoutBox;\n    seriesRoot.visible = this.series.some((s) => s.visible);\n    for (const group of [seriesRoot, annotationRoot, highlightRoot]) {\n      group.translationX = Math.floor(layoutBox.x);\n      group.translationY = Math.floor(layoutBox.y);\n      group.setClipRect(seriesRect.clone());\n    }\n    this.ctx.layoutManager.emitLayoutComplete(ctx, {\n      series: { visible: seriesRoot.visible, rect: seriesRect, paddedRect: layoutBox }\n    });\n  }\n};\nFlowProportionChart.className = \"FlowProportionChart\";\nFlowProportionChart.type = \"flow-proportion\";\n\n// packages/ag-charts-community/src/chart/axis/polarAxis.ts\nvar PolarAxis = class extends Axis {\n  constructor() {\n    super(...arguments);\n    this.shape = \"polygon\";\n    this.innerRadiusRatio = 0;\n    this.defaultTickMinSpacing = 20;\n  }\n  computeLabelsBBox(_options, _seriesRect) {\n    return null;\n  }\n  computeRange() {\n  }\n  getAxisLinePoints() {\n    return void 0;\n  }\n};\n__decorateClass([\n  Validate(UNION([\"polygon\", \"circle\"], \"a polar axis shape\"))\n], PolarAxis.prototype, \"shape\", 2);\n__decorateClass([\n  Validate(RATIO)\n], PolarAxis.prototype, \"innerRadiusRatio\", 2);\n\n// packages/ag-charts-community/src/chart/gaugeChart.ts\nfunction isRadialGaugeSeries(series) {\n  return series.type === \"radial-gauge\";\n}\nfunction isLinearGaugeSeries(series) {\n  return series.type === \"linear-gauge\";\n}\nvar GaugeChart = class extends Chart {\n  getChartType() {\n    return \"gauge\";\n  }\n  updateRadialGauge(seriesRect, series) {\n    const angleAxis = this.axes.find((axis) => axis.direction === \"x\" /* X */);\n    if (!(angleAxis instanceof PolarAxis))\n      return;\n    angleAxis.computeRange();\n    const seriesRectX0 = seriesRect.x;\n    const seriesRectX1 = seriesRectX0 + seriesRect.width;\n    const seriesRectY0 = seriesRect.y;\n    const seriesRectY1 = seriesRectY0 + seriesRect.height;\n    const [startAngle, endAngle] = angleAxis.range;\n    const sweepAngle = normalizeAngle360Inclusive(endAngle - startAngle);\n    const largerThanHalf = sweepAngle > Math.PI;\n    const containsTop = largerThanHalf || isBetweenAngles(1.5 * Math.PI, startAngle, endAngle);\n    const containsRight = largerThanHalf || isBetweenAngles(0 * Math.PI, startAngle, endAngle);\n    const containsBottom = largerThanHalf || isBetweenAngles(0.5 * Math.PI, startAngle, endAngle);\n    const containsLeft = largerThanHalf || isBetweenAngles(1 * Math.PI, startAngle, endAngle);\n    let textAlign;\n    if (containsLeft && !containsRight) {\n      textAlign = \"right\";\n    } else if (!containsLeft && containsRight) {\n      textAlign = \"left\";\n    } else {\n      textAlign = \"center\";\n    }\n    let verticalAlign;\n    if (containsTop && !containsBottom) {\n      verticalAlign = \"bottom\";\n    } else if (!containsTop && containsBottom) {\n      verticalAlign = \"top\";\n    } else {\n      verticalAlign = \"middle\";\n    }\n    const unitBox = sectorBox({\n      startAngle,\n      endAngle,\n      innerRadius: 0,\n      outerRadius: 0.5\n    });\n    const centerXOffset = -(unitBox.x + unitBox.width / 2) * 2;\n    const centerYOffset = -(unitBox.y + unitBox.height / 2) * 2;\n    const { minimumRadius = 0, maximumRadius } = series;\n    const radiusBounds = Math.max(\n      0.5 * Math.min(seriesRect.width / unitBox.width, seriesRect.height / unitBox.height),\n      // seriesRect may have negative size\n      0\n    );\n    let radius = Math.min(maximumRadius ?? Infinity, Math.max(radiusBounds, minimumRadius ?? 0));\n    const MAX_ITERATIONS = 8;\n    for (let i = 0; i < MAX_ITERATIONS; i += 1) {\n      const isFinalIteration = radius <= minimumRadius || i === MAX_ITERATIONS - 1;\n      const centerX = seriesRect.x + seriesRect.width / 2 + centerXOffset * radius;\n      const centerY = seriesRect.y + seriesRect.height / 2 + centerYOffset * radius;\n      angleAxis.translation.x = centerX;\n      angleAxis.translation.y = centerY;\n      angleAxis.gridLength = radius;\n      angleAxis.calculateLayout();\n      const bbox = angleAxis.computeLabelsBBox({ hideWhenNecessary: isFinalIteration }, seriesRect);\n      if (isFinalIteration)\n        break;\n      let shrinkDelta = 0;\n      if (bbox != null) {\n        const bboxX0 = bbox.x + centerX;\n        const bboxX1 = bboxX0 + bbox.width;\n        const bboxY0 = bbox.y + centerY;\n        const bboxY1 = bboxY0 + bbox.height;\n        shrinkDelta = Math.max(\n          seriesRectY0 - bboxY0,\n          seriesRectX0 - bboxX0,\n          bboxY1 - seriesRectY1,\n          bboxX1 - seriesRectX1,\n          0\n        );\n      }\n      if (shrinkDelta > 0) {\n        radius = Math.max(radius - shrinkDelta, minimumRadius);\n      } else {\n        break;\n      }\n    }\n    angleAxis.translation.x = seriesRect.x + seriesRect.width / 2 + centerXOffset * radius;\n    angleAxis.translation.y = seriesRect.y + seriesRect.height / 2 + centerYOffset * radius;\n    series.centerX = seriesRect.width / 2 + centerXOffset * radius;\n    series.centerY = seriesRect.height / 2 + centerYOffset * radius;\n    series.radius = radius;\n    series.textAlign = textAlign;\n    series.verticalAlign = verticalAlign;\n    if (radius === 0 || radius > radiusBounds) {\n      Logger.warnOnce(\"There was insufficient space to display the Radial Gauge.\");\n    }\n  }\n  updateLinearGauge(seriesRect, series) {\n    const xAxis = this.axes.find((axis) => axis.direction === \"x\" /* X */);\n    const yAxis = this.axes.find((axis) => axis.direction === \"y\" /* Y */);\n    if (!(xAxis instanceof CartesianAxis))\n      return seriesRect;\n    if (!(yAxis instanceof CartesianAxis))\n      return seriesRect;\n    const { horizontal, thickness } = series;\n    let horizontalInset = 0;\n    let verticalInset = 0;\n    const scale2 = new LinearScale();\n    scale2.domain = [0, 100];\n    scale2.range = horizontal ? xAxis.range : yAxis.range;\n    const ticks = scale2.ticks();\n    if (horizontal) {\n      horizontalInset = series.computeInset(\"x\" /* X */, ticks);\n    } else {\n      verticalInset = series.computeInset(\"y\" /* Y */, ticks);\n    }\n    const seriesWidth = seriesRect.width - Math.abs(horizontalInset);\n    const seriesHeight = seriesRect.height - Math.abs(verticalInset);\n    const width2 = Math.max(horizontal ? seriesWidth : thickness, 0);\n    const height2 = Math.max(horizontal ? thickness : seriesHeight, 0);\n    const x0 = seriesRect.x + (seriesWidth - width2) / 2 + Math.max(horizontalInset, 0);\n    const y0 = seriesRect.y + (seriesHeight - height2) / 2 - Math.min(verticalInset, 0);\n    xAxis.range = [0, width2];\n    xAxis.gridLength = width2;\n    xAxis.calculateLayout();\n    xAxis.translation.x = x0;\n    xAxis.translation.y = y0 + (xAxis.position === \"bottom\" ? thickness : 0);\n    yAxis.range = [0, height2];\n    yAxis.gridLength = height2;\n    yAxis.calculateLayout();\n    yAxis.translation.x = x0 + (yAxis.position === \"right\" ? thickness : 0);\n    yAxis.translation.y = y0;\n    series.originX = x0 - seriesRect.x;\n    series.originY = y0 - seriesRect.y;\n    if (width2 === 0 || height2 === 0) {\n      Logger.warnOnce(\"There was insufficient space to display the Linear Gauge.\");\n    }\n  }\n  performLayout(ctx) {\n    const { seriesRoot, annotationRoot, highlightRoot, series, seriesArea } = this;\n    const { layoutBox } = ctx;\n    const seriesRect = layoutBox.clone();\n    layoutBox.shrink(seriesArea.padding.toJson());\n    const firstSeries = this.series[0];\n    if (isRadialGaugeSeries(firstSeries)) {\n      this.updateRadialGauge(layoutBox, firstSeries);\n    } else if (isLinearGaugeSeries(firstSeries)) {\n      this.updateLinearGauge(layoutBox, firstSeries);\n    }\n    this.axes.forEach((axis) => axis.update());\n    this.seriesRect = seriesRect.clone().translate(seriesRect.x - layoutBox.x, seriesRect.y - layoutBox.y);\n    this.animationRect = layoutBox;\n    seriesRoot.visible = series.some((s) => s.visible);\n    for (const group of [seriesRoot, annotationRoot, highlightRoot]) {\n      group.translationX = Math.floor(layoutBox.x);\n      group.translationY = Math.floor(layoutBox.y);\n    }\n    this.ctx.layoutManager.emitLayoutComplete(ctx, {\n      series: { visible: seriesRoot.visible, rect: seriesRect, paddedRect: layoutBox }\n    });\n  }\n  getAriaLabel() {\n    const captions = [];\n    const chartCaption = this.getCaptionText();\n    if (chartCaption.length !== 0) {\n      captions.push(chartCaption);\n    }\n    for (const series of this.series) {\n      captions.push(series.getCaptionText());\n    }\n    const caption = captions.join(\". \");\n    return this.ctx.localeManager.t(\"ariaAnnounceGaugeChart\", { caption });\n  }\n};\nGaugeChart.className = \"GaugeChart\";\nGaugeChart.type = \"gauge\";\n\n// packages/ag-charts-community/src/chart/hierarchyChart.ts\nvar HierarchyChart = class extends Chart {\n  constructor(options, resources) {\n    super(options, resources);\n  }\n  getChartType() {\n    return \"hierarchy\";\n  }\n  performLayout(ctx) {\n    const { seriesRoot, annotationRoot, highlightRoot } = this;\n    const { layoutBox } = ctx;\n    const seriesRect = layoutBox.clone();\n    layoutBox.shrink(this.seriesArea.padding.toJson());\n    this.seriesRect = layoutBox;\n    this.animationRect = layoutBox;\n    for (const group of [seriesRoot, annotationRoot, highlightRoot]) {\n      group.translationX = Math.floor(layoutBox.x);\n      group.translationY = Math.floor(layoutBox.y);\n    }\n    seriesRoot.visible = this.series[0].visible;\n    seriesRoot.setClipRect(layoutBox.clone());\n    this.ctx.layoutManager.emitLayoutComplete(ctx, {\n      series: { visible: true, rect: seriesRect, paddedRect: layoutBox }\n    });\n  }\n  getAriaLabel() {\n    const caption = this.getCaptionText();\n    return this.ctx.localeManager.t(\"ariaAnnounceHierarchyChart\", { caption });\n  }\n};\nHierarchyChart.className = \"HierarchyChart\";\nHierarchyChart.type = \"hierarchy\";\n\n// packages/ag-charts-community/src/chart/polarChart.ts\nvar PolarChart = class extends Chart {\n  constructor(options, resources) {\n    super(options, resources);\n    this.padding = new Padding(40);\n    this.ctx.axisManager.axisGroup.zIndex = 6 /* AXIS_FOREGROUND */;\n  }\n  getChartType() {\n    return \"polar\";\n  }\n  async performLayout(ctx) {\n    const { layoutBox } = ctx;\n    const seriesRect = layoutBox.clone();\n    layoutBox.shrink(this.seriesArea.padding.toJson());\n    this.seriesRect = layoutBox;\n    this.animationRect = layoutBox;\n    await this.computeCircle(layoutBox);\n    this.axes.forEach((axis) => axis.update());\n    this.ctx.layoutManager.emitLayoutComplete(ctx, {\n      series: { visible: true, rect: seriesRect, paddedRect: layoutBox }\n    });\n  }\n  updateAxes(cx, cy, radius) {\n    const angleAxis = this.axes.find((axis) => axis.direction === \"x\" /* X */);\n    const radiusAxis = this.axes.find((axis) => axis.direction === \"y\" /* Y */);\n    if (!(angleAxis instanceof PolarAxis) || !(radiusAxis instanceof PolarAxis))\n      return;\n    const angleScale = angleAxis.scale;\n    const innerRadiusRatio = radiusAxis.innerRadiusRatio;\n    angleAxis.innerRadiusRatio = innerRadiusRatio;\n    angleAxis.computeRange();\n    angleAxis.gridLength = radius;\n    radiusAxis.gridAngles = angleScale.ticks?.().map((value) => angleScale.convert(value));\n    radiusAxis.gridRange = angleAxis.range;\n    radiusAxis.range = [radius, radius * innerRadiusRatio];\n    [angleAxis, radiusAxis].forEach((axis) => {\n      axis.translation.x = cx;\n      axis.translation.y = cy;\n      axis.calculateLayout();\n    });\n  }\n  async computeCircle(seriesBox) {\n    const polarSeries = this.series.filter(isPolarSeries);\n    const polarAxes = this.axes.filter(isPolarAxis);\n    const setSeriesCircle = (cx, cy, r) => {\n      this.updateAxes(cx, cy, r);\n      polarSeries.forEach((series) => {\n        series.centerX = cx;\n        series.centerY = cy;\n        series.radius = r;\n      });\n      const pieSeries = polarSeries.filter((s) => s.type === \"donut\" || s.type === \"pie\");\n      if (pieSeries.length > 1) {\n        const innerRadii = pieSeries.map((series) => {\n          const innerRadius = series.getInnerRadius();\n          return { series, innerRadius };\n        }).sort((a, b) => a.innerRadius - b.innerRadius);\n        innerRadii.at(-1).series.surroundingRadius = void 0;\n        for (let i = 0; i < innerRadii.length - 1; i++) {\n          innerRadii[i].series.surroundingRadius = innerRadii[i + 1].innerRadius;\n        }\n      }\n    };\n    const centerX = seriesBox.x + seriesBox.width / 2;\n    const centerY = seriesBox.y + seriesBox.height / 2;\n    const initialRadius = Math.max(0, Math.min(seriesBox.width, seriesBox.height) / 2);\n    let radius = initialRadius;\n    setSeriesCircle(centerX, centerY, radius);\n    const shake = async ({ hideWhenNecessary = false } = {}) => {\n      const labelBoxes = [];\n      for (const series of iterate(polarAxes, polarSeries)) {\n        const box = await series.computeLabelsBBox({ hideWhenNecessary }, seriesBox);\n        if (box) {\n          labelBoxes.push(box);\n        }\n      }\n      if (labelBoxes.length === 0) {\n        setSeriesCircle(centerX, centerY, initialRadius);\n        return;\n      }\n      const labelBox = BBox.merge(labelBoxes);\n      const refined = this.refineCircle(labelBox, radius, seriesBox);\n      setSeriesCircle(refined.centerX, refined.centerY, refined.radius);\n      radius = refined.radius;\n    };\n    await shake();\n    await shake();\n    await shake();\n    await shake({ hideWhenNecessary: true });\n    await shake({ hideWhenNecessary: true });\n    for (const series of iterate(polarAxes, polarSeries)) {\n      await series.computeLabelsBBox({ hideWhenNecessary: true }, seriesBox);\n    }\n    return { radius, centerX, centerY };\n  }\n  refineCircle(labelsBox, radius, seriesBox) {\n    const minCircleRatio = 0.5;\n    const circleLeft = -radius;\n    const circleTop = -radius;\n    const circleRight = radius;\n    const circleBottom = radius;\n    let padLeft = Math.max(0, circleLeft - labelsBox.x);\n    let padTop = Math.max(0, circleTop - labelsBox.y);\n    let padRight = Math.max(0, labelsBox.x + labelsBox.width - circleRight);\n    let padBottom = Math.max(0, labelsBox.y + labelsBox.height - circleBottom);\n    padLeft = padRight = Math.max(padLeft, padRight);\n    padTop = padBottom = Math.max(padTop, padBottom);\n    const availCircleWidth = seriesBox.width - padLeft - padRight;\n    const availCircleHeight = seriesBox.height - padTop - padBottom;\n    let newRadius = Math.min(availCircleWidth, availCircleHeight) / 2;\n    const minHorizontalRadius = minCircleRatio * seriesBox.width / 2;\n    const minVerticalRadius = minCircleRatio * seriesBox.height / 2;\n    const minRadius = Math.min(minHorizontalRadius, minVerticalRadius);\n    if (newRadius < minRadius) {\n      newRadius = minRadius;\n      const horizontalPadding = padLeft + padRight;\n      const verticalPadding = padTop + padBottom;\n      if (2 * newRadius + verticalPadding > seriesBox.height) {\n        const padHeight = seriesBox.height - 2 * newRadius;\n        if (Math.min(padTop, padBottom) * 2 > padHeight) {\n          padTop = padHeight / 2;\n          padBottom = padHeight / 2;\n        } else if (padTop > padBottom) {\n          padTop = padHeight - padBottom;\n        } else {\n          padBottom = padHeight - padTop;\n        }\n      }\n      if (2 * newRadius + horizontalPadding > seriesBox.width) {\n        const padWidth = seriesBox.width - 2 * newRadius;\n        if (Math.min(padLeft, padRight) * 2 > padWidth) {\n          padLeft = padWidth / 2;\n          padRight = padWidth / 2;\n        } else if (padLeft > padRight) {\n          padLeft = padWidth - padRight;\n        } else {\n          padRight = padWidth - padLeft;\n        }\n      }\n    }\n    const newWidth = padLeft + 2 * newRadius + padRight;\n    const newHeight = padTop + 2 * newRadius + padBottom;\n    return {\n      centerX: seriesBox.x + (seriesBox.width - newWidth) / 2 + padLeft + newRadius,\n      centerY: seriesBox.y + (seriesBox.height - newHeight) / 2 + padTop + newRadius,\n      radius: newRadius\n    };\n  }\n};\nPolarChart.className = \"PolarChart\";\nPolarChart.type = \"polar\";\nfunction isPolarSeries(series) {\n  return series instanceof PolarSeries;\n}\nfunction isPolarAxis(axis) {\n  return axis instanceof PolarAxis;\n}\n\n// packages/ag-charts-community/src/chart/standaloneChart.ts\nvar StandaloneChart = class extends Chart {\n  constructor(options, resources) {\n    super(options, resources);\n  }\n  getChartType() {\n    return \"standalone\";\n  }\n  performLayout(ctx) {\n    const { seriesRoot, annotationRoot, highlightRoot } = this;\n    const { layoutBox } = ctx;\n    const seriesRect = layoutBox.clone();\n    layoutBox.shrink(this.seriesArea.padding.toJson());\n    this.seriesRect = layoutBox;\n    this.animationRect = layoutBox;\n    for (const group of [seriesRoot, annotationRoot, highlightRoot]) {\n      group.translationX = Math.floor(layoutBox.x);\n      group.translationY = Math.floor(layoutBox.y);\n    }\n    seriesRoot.visible = this.series[0].visible;\n    this.ctx.layoutManager.emitLayoutComplete(ctx, {\n      series: { visible: true, rect: seriesRect, paddedRect: layoutBox }\n    });\n  }\n  getAriaLabel() {\n    const caption = this.getCaptionText();\n    return this.ctx.localeManager.t(\"ariaAnnounceHierarchyChart\", { caption });\n  }\n};\nStandaloneChart.className = \"StandaloneChart\";\nStandaloneChart.type = \"standalone\";\n\n// packages/ag-charts-community/src/chart/series/topology/mercatorScale.ts\nvar radsInDeg = Math.PI / 180;\nvar lonX = (lon) => lon * radsInDeg;\nvar latY = (lat) => -Math.log(Math.tan(Math.PI * 0.25 + lat * radsInDeg * 0.5));\nvar xLon = (x) => x / radsInDeg;\nvar yLat = (y) => (Math.atan(Math.exp(-y)) - Math.PI * 0.25) / (radsInDeg * 0.5);\nvar MercatorScale = class _MercatorScale {\n  constructor(domain, range3) {\n    this.domain = domain;\n    this.range = range3;\n    this.type = \"mercator\";\n    this.bounds = _MercatorScale.bounds(domain);\n  }\n  static bounds(domain) {\n    const [[lon0, lat0], [lon1, lat1]] = domain;\n    const x0 = lonX(lon0);\n    const y0 = latY(lat0);\n    const x1 = lonX(lon1);\n    const y1 = latY(lat1);\n    return new BBox(Math.min(x0, x1), Math.min(y0, y1), Math.abs(x1 - x0), Math.abs(y1 - y0));\n  }\n  static fixedScale() {\n    return new _MercatorScale(\n      [\n        [xLon(0), yLat(0)],\n        [xLon(1), yLat(1)]\n      ],\n      [\n        [0, 0],\n        [1, 1]\n      ]\n    );\n  }\n  convert([lon, lat]) {\n    const [[x0, y0], [x1, y1]] = this.range;\n    const xScale = (x1 - x0) / this.bounds.width;\n    const yScale = (y1 - y0) / this.bounds.height;\n    return [(lonX(lon) - this.bounds.x) * xScale + x0, (latY(lat) - this.bounds.y) * yScale + y0];\n  }\n  invert([x, y]) {\n    const [[x0, y0], [x1, y1]] = this.range;\n    const xScale = (x1 - x0) / this.bounds.width;\n    const yScale = (y1 - y0) / this.bounds.height;\n    return [xLon((x - x0) / xScale + this.bounds.x), yLat((y - y0) / yScale + this.bounds.y)];\n  }\n};\n\n// packages/ag-charts-community/src/chart/topologyChart.ts\nfunction isTopologySeries(series) {\n  return series.type === \"map-shape\" || series.type === \"map-line\" || series.type === \"map-marker\" || series.type === \"map-shape-background\" || series.type === \"map-line-background\";\n}\nvar TopologyChart = class extends Chart {\n  constructor(options, resources) {\n    super(options, resources);\n    this.xAxis = new NumberAxis(this.getModuleContext());\n    this.xAxis.position = \"bottom\";\n    this.yAxis = new NumberAxis(this.getModuleContext());\n    this.yAxis.position = \"left\";\n    this.ctx.zoomManager.updateAxes([this.xAxis, this.yAxis]);\n  }\n  getChartType() {\n    return \"topology\";\n  }\n  async updateData() {\n    await super.updateData();\n    const { topology } = this.getOptions();\n    this.series.forEach((series) => {\n      if (isTopologySeries(series)) {\n        series.setChartTopology(topology);\n      }\n    });\n  }\n  performLayout(ctx) {\n    const { seriesRoot, annotationRoot, highlightRoot } = this;\n    const { layoutBox } = ctx;\n    const seriesRect = layoutBox.clone();\n    layoutBox.shrink(this.seriesArea.padding.toJson());\n    this.seriesRect = layoutBox;\n    this.animationRect = layoutBox;\n    const mapSeries = this.series.filter(isTopologySeries);\n    const combinedBbox = mapSeries.reduce((combined, series) => {\n      if (!series.visible)\n        return combined;\n      const bbox = series.topologyBounds;\n      if (bbox == null)\n        return combined;\n      if (combined == null)\n        return bbox;\n      combined.merge(bbox);\n      return combined;\n    }, void 0);\n    let scale2;\n    if (combinedBbox != null) {\n      const { lon0, lat0, lon1, lat1 } = combinedBbox;\n      const domain = [\n        [lon0, lat0],\n        [lon1, lat1]\n      ];\n      const bounds = MercatorScale.bounds(domain);\n      const { width: width2, height: height2 } = layoutBox;\n      const viewBoxScale = Math.min(width2 / bounds.width, height2 / bounds.height);\n      const viewBoxWidth = bounds.width * viewBoxScale;\n      const viewBoxHeight = bounds.height * viewBoxScale;\n      const viewBoxOriginX = (width2 - viewBoxWidth) / 2;\n      const viewBoxOriginY = (height2 - viewBoxHeight) / 2;\n      const x0 = viewBoxOriginX;\n      const y0 = viewBoxOriginY;\n      const x1 = viewBoxOriginX + viewBoxWidth;\n      const y1 = viewBoxOriginY + viewBoxHeight;\n      const xZoom = this.ctx.zoomManager.getAxisZoom(this.xAxis.id);\n      const yZoom = this.ctx.zoomManager.getAxisZoom(this.yAxis.id);\n      const xSpan = (x1 - x0) / (xZoom.max - xZoom.min);\n      const xStart = x0 - xSpan * xZoom.min;\n      const ySpan = (y1 - y0) / (1 - yZoom.min - (1 - yZoom.max));\n      const yStart = y0 - ySpan * (1 - yZoom.max);\n      scale2 = new MercatorScale(domain, [\n        [xStart, yStart],\n        [xStart + xSpan, yStart + ySpan]\n      ]);\n    }\n    mapSeries.forEach((series) => {\n      series.scale = scale2;\n    });\n    const seriesVisible = this.series.some((s) => s.visible);\n    seriesRoot.visible = seriesVisible;\n    for (const group of [seriesRoot, annotationRoot, highlightRoot]) {\n      group.translationX = Math.floor(layoutBox.x);\n      group.translationY = Math.floor(layoutBox.y);\n      group.setClipRect(layoutBox.clone());\n    }\n    this.ctx.layoutManager.emitLayoutComplete(ctx, {\n      series: { visible: seriesVisible, rect: seriesRect, paddedRect: layoutBox }\n    });\n  }\n};\nTopologyChart.className = \"TopologyChart\";\nTopologyChart.type = \"topology\";\n\n// packages/ag-charts-community/src/api/preset/presetUtils.ts\nfunction assertEmpty(_t) {\n}\nvar IGNORED_PROP = Symbol(\"IGNORED_PROP\");\nfunction pickProps(opts, values) {\n  const out = {};\n  for (const key in values) {\n    const value = values[key];\n    if (value !== IGNORED_PROP && Object.hasOwn(opts, key)) {\n      out[key] = value;\n    }\n  }\n  return out;\n}\n\n// packages/ag-charts-community/src/api/preset/gauge.ts\nfunction isRadialGauge(opts) {\n  return opts.type === \"radial-gauge\";\n}\nfunction isLinearGauge(opts) {\n  return opts.type === \"linear-gauge\";\n}\nfunction radialGaugeOptions(opts) {\n  const {\n    animation,\n    background,\n    container,\n    contextMenu,\n    footnote,\n    height: height2,\n    listeners,\n    locale,\n    minHeight,\n    minWidth,\n    padding,\n    subtitle,\n    theme,\n    title,\n    width: width2,\n    type,\n    cursor,\n    nodeClickRange,\n    tooltip,\n    value,\n    scale: scale2 = {},\n    startAngle,\n    endAngle,\n    highlightStyle,\n    segmentation,\n    bar,\n    needle,\n    targets,\n    outerRadius,\n    innerRadius,\n    outerRadiusRatio,\n    innerRadiusRatio,\n    cornerRadius,\n    cornerMode,\n    label,\n    secondaryLabel,\n    spacing,\n    ...rest\n  } = opts;\n  assertEmpty(rest);\n  const {\n    fills: scaleFills,\n    fillMode: scaleFillMode,\n    fill: scaleFill,\n    fillOpacity: scaleFillOpacity,\n    stroke: scaleStroke,\n    strokeWidth: scaleStrokeWidth,\n    strokeOpacity: scaleStrokeOpacity,\n    lineDash: scaleLineDash,\n    lineDashOffset: scaleLineDashOffset,\n    min: scaleMin = 0,\n    max: scaleMax = 1,\n    interval: scaleInterval = {},\n    label: scaleLabel = {},\n    ...scaleRest\n  } = scale2;\n  assertEmpty(scaleRest);\n  const chartOpts = pickProps(opts, {\n    animation,\n    background,\n    container,\n    contextMenu,\n    footnote,\n    height: height2,\n    listeners,\n    locale,\n    minHeight,\n    minWidth,\n    padding,\n    subtitle,\n    theme,\n    title,\n    width: width2\n  });\n  const scaleOpts = pickProps(scale2, {\n    fills: scaleFills,\n    fillMode: scaleFillMode,\n    fill: scaleFill,\n    fillOpacity: scaleFillOpacity,\n    stroke: scaleStroke,\n    strokeWidth: scaleStrokeWidth,\n    strokeOpacity: scaleStrokeOpacity,\n    lineDash: scaleLineDash,\n    lineDashOffset: scaleLineDashOffset\n  });\n  const seriesOpts = pickProps(opts, {\n    startAngle: IGNORED_PROP,\n    endAngle: IGNORED_PROP,\n    needle: needle != null ? { enabled: true, ...needle } : IGNORED_PROP,\n    scale: scaleOpts,\n    type,\n    cursor,\n    nodeClickRange,\n    listeners,\n    tooltip,\n    value,\n    highlightStyle,\n    segmentation,\n    bar,\n    targets,\n    outerRadius,\n    innerRadius,\n    outerRadiusRatio,\n    innerRadiusRatio,\n    cornerRadius,\n    cornerMode,\n    label,\n    secondaryLabel,\n    spacing,\n    ...rest\n  });\n  const axesOpts = [\n    {\n      type: \"angle-number\",\n      min: scaleMin,\n      max: scaleMax,\n      startAngle,\n      endAngle,\n      interval: scaleInterval ?? {},\n      label: scaleLabel ?? {}\n    },\n    { type: \"radius-number\" }\n  ];\n  return {\n    ...chartOpts,\n    series: [seriesOpts],\n    axes: axesOpts\n  };\n}\nfunction linearGaugeOptions(opts) {\n  const {\n    animation,\n    background,\n    container,\n    contextMenu,\n    footnote,\n    height: height2,\n    listeners,\n    locale,\n    minHeight,\n    minWidth,\n    padding,\n    subtitle,\n    theme,\n    title,\n    width: width2,\n    type,\n    cursor,\n    nodeClickRange,\n    tooltip,\n    value,\n    scale: scale2 = {},\n    direction = \"vertical\",\n    thickness,\n    highlightStyle,\n    segmentation,\n    bar,\n    targets,\n    cornerRadius,\n    cornerMode,\n    label,\n    ...rest\n  } = opts;\n  assertEmpty(rest);\n  const {\n    fills: scaleFills,\n    fillMode: scaleFillMode,\n    fill: scaleFill,\n    fillOpacity: scaleFillOpacity,\n    stroke: scaleStroke,\n    strokeWidth: scaleStrokeWidth,\n    strokeOpacity: scaleStrokeOpacity,\n    lineDash: scaleLineDash,\n    lineDashOffset: scaleLineDashOffset,\n    min: scaleMin = 0,\n    max: scaleMax = 1,\n    interval: scaleInterval = {},\n    label: scaleLabel = {},\n    ...scaleRest\n  } = scale2;\n  assertEmpty(scaleRest);\n  const chartOpts = pickProps(opts, {\n    animation,\n    background,\n    container,\n    contextMenu,\n    footnote,\n    height: height2,\n    listeners,\n    locale,\n    minHeight,\n    minWidth,\n    padding,\n    subtitle,\n    theme,\n    title,\n    width: width2\n  });\n  const scaleOpts = pickProps(scale2, {\n    fills: scaleFills,\n    fillMode: scaleFillMode,\n    fill: scaleFill,\n    fillOpacity: scaleFillOpacity,\n    stroke: scaleStroke,\n    strokeWidth: scaleStrokeWidth,\n    strokeOpacity: scaleStrokeOpacity,\n    lineDash: scaleLineDash,\n    lineDashOffset: scaleLineDashOffset\n  });\n  const seriesOpts = pickProps(opts, {\n    scale: scaleOpts,\n    type,\n    cursor,\n    nodeClickRange,\n    listeners,\n    tooltip,\n    value,\n    direction,\n    thickness,\n    highlightStyle,\n    segmentation,\n    bar,\n    targets,\n    cornerRadius,\n    cornerMode,\n    label,\n    ...rest\n  });\n  const { placement: labelPlacement, ...axisLabel } = scaleLabel;\n  let mainAxisPosition;\n  let crossAxisPosition;\n  const horizontal = direction === \"horizontal\";\n  if (horizontal) {\n    mainAxisPosition = labelPlacement === \"before\" ? \"top\" : \"bottom\";\n    crossAxisPosition = \"left\";\n  } else {\n    mainAxisPosition = labelPlacement === \"after\" ? \"right\" : \"left\";\n    crossAxisPosition = \"bottom\";\n  }\n  const mainAxis = {\n    type: \"number\",\n    position: mainAxisPosition,\n    min: scaleMin,\n    max: scaleMax,\n    reverse: !horizontal,\n    interval: scaleInterval,\n    label: axisLabel,\n    nice: false\n  };\n  const crossAxis = {\n    type: \"number\",\n    position: crossAxisPosition,\n    min: 0,\n    max: 1,\n    label: {\n      enabled: false\n    }\n  };\n  const axesOpts = horizontal ? [mainAxis, crossAxis] : [crossAxis, mainAxis];\n  return {\n    ...chartOpts,\n    series: [seriesOpts],\n    axes: axesOpts\n  };\n}\nfunction applyThemeDefaults(opts, presetTheme) {\n  if (presetTheme == null)\n    return opts;\n  const { targets: targetsTheme, ...gaugeTheme } = presetTheme;\n  opts = mergeDefaults(opts, gaugeTheme);\n  if (opts.targets != null && targetsTheme != null) {\n    opts.targets = mergeArrayDefaults(opts.targets, targetsTheme);\n  }\n  return opts;\n}\nfunction gauge(opts, presetTheme) {\n  if (isRadialGauge(opts)) {\n    const radialGaugeOpts = applyThemeDefaults(opts, presetTheme);\n    return radialGaugeOptions(radialGaugeOpts);\n  } else if (isLinearGauge(opts)) {\n    const linearGaugeOpts = applyThemeDefaults(opts, presetTheme);\n    return linearGaugeOptions(linearGaugeOpts);\n  }\n  const {\n    animation,\n    background,\n    container,\n    contextMenu,\n    footnote,\n    height: height2,\n    listeners,\n    locale,\n    minHeight,\n    minWidth,\n    padding,\n    subtitle,\n    theme,\n    title,\n    width: width2\n  } = opts;\n  return pickProps(opts, {\n    animation,\n    background,\n    container,\n    contextMenu,\n    footnote,\n    height: height2,\n    listeners,\n    locale,\n    minHeight,\n    minWidth,\n    padding,\n    subtitle,\n    theme,\n    title,\n    width: width2\n  });\n}\n\n// packages/ag-charts-community/src/api/preset/priceVolumePreset.ts\nfunction fromTheme(theme, cb) {\n  if (isObject(theme)) {\n    return cb(theme);\n  }\n}\nvar chartTypes2 = [\"ohlc\", \"line\", \"step-line\", \"hlc\", \"high-low\", \"candlestick\", \"hollow-candlestick\"];\nfunction priceVolume(opts, _presetTheme, getTheme) {\n  const {\n    xKey,\n    dateKey = xKey ?? \"date\",\n    highKey = \"high\",\n    openKey = \"open\",\n    lowKey = \"low\",\n    closeKey = \"close\",\n    volumeKey = \"volume\",\n    chartType: chartType2 = \"candlestick\",\n    navigator: navigator2 = false,\n    volume = true,\n    rangeToolbar,\n    rangeButtons = rangeToolbar ?? true,\n    statusBar = true,\n    annotations: annotations2,\n    toolbar = annotations2 ?? true,\n    zoom: zoom2 = true,\n    theme,\n    data,\n    ...unusedOpts\n  } = opts;\n  if (xKey != null) {\n    Logger.warnOnce(\"Property [xKey] is deprecated, use [dateKey] instead.\");\n  }\n  if (rangeToolbar != null) {\n    Logger.warnOnce(\"Property [rangeToolbar] is deprecated, use [rangeButtons] instead.\");\n  }\n  if (annotations2 != null) {\n    Logger.warnOnce(\"Property [annotations] is deprecated, use [toolbar] instead.\");\n  }\n  const priceSeries = createPriceSeries(theme, chartType2, dateKey, highKey, lowKey, openKey, closeKey);\n  const volumeSeries = createVolumeSeries(theme, getTheme, openKey, closeKey, volume, volumeKey);\n  const miniChart = volume ? {\n    miniChart: {\n      enabled: navigator2,\n      series: [\n        {\n          type: \"line\",\n          xKey: dateKey,\n          yKey: volumeKey,\n          marker: { enabled: false }\n        }\n      ]\n    }\n  } : null;\n  const navigatorOpts = {\n    navigator: {\n      enabled: navigator2,\n      ...miniChart\n    }\n  };\n  const annotationOpts = {\n    annotations: {\n      enabled: toolbar,\n      // @ts-expect-error\n      data,\n      xKey: dateKey,\n      volumeKey: volume ? volumeKey : void 0\n    }\n  };\n  const statusBarOpts = statusBar ? {\n    statusBar: {\n      enabled: true,\n      data,\n      highKey,\n      openKey,\n      lowKey,\n      closeKey,\n      volumeKey: volume ? volumeKey : void 0\n    }\n  } : null;\n  const zoomOpts = {\n    zoom: {\n      enabled: zoom2,\n      // @ts-expect-error\n      enableIndependentAxes: true\n    }\n  };\n  const toolbarOpts = {\n    chartToolbar: { enabled: true },\n    toolbar: {\n      seriesType: {\n        enabled: toolbar\n      },\n      annotationOptions: {\n        enabled: toolbar\n      },\n      annotations: {\n        enabled: toolbar\n      },\n      ranges: {\n        enabled: rangeButtons\n      }\n    }\n  };\n  const volumeAxis = volume ? [\n    {\n      type: \"number\",\n      position: \"left\",\n      keys: [volumeKey],\n      label: { enabled: false },\n      crosshair: { enabled: false },\n      gridLine: { enabled: false },\n      nice: false,\n      // @ts-expect-error\n      layoutConstraints: {\n        stacked: false,\n        width: 20,\n        unit: \"percentage\",\n        align: \"end\"\n      }\n    }\n  ] : [];\n  return {\n    theme: {\n      baseTheme: typeof theme === \"string\" ? theme : \"ag-financial\",\n      ...mergeDefaults(typeof theme === \"object\" ? theme : null, {\n        overrides: {\n          common: {\n            title: { padding: 4 },\n            padding: {\n              top: 6,\n              right: 8,\n              bottom: 5\n            }\n          }\n        }\n      })\n    },\n    animation: { enabled: false },\n    legend: { enabled: false },\n    series: [...volumeSeries, ...priceSeries],\n    axes: [\n      {\n        type: \"number\",\n        position: \"right\",\n        keys: [openKey, closeKey, highKey, lowKey],\n        interval: {\n          maxSpacing: fromTheme(theme, (t) => t.overrides?.common?.axes?.number?.interval?.maxSpacing) ?? 45\n        },\n        label: {\n          format: fromTheme(theme, (t) => t.overrides?.common?.axes?.number?.label?.format) ?? \".2f\"\n        },\n        crosshair: {\n          enabled: true,\n          snap: false\n        },\n        // @ts-expect-error\n        layoutConstraints: {\n          stacked: false,\n          width: 100,\n          unit: \"percentage\",\n          align: \"start\"\n        }\n      },\n      ...volumeAxis,\n      {\n        type: \"ordinal-time\",\n        position: \"bottom\",\n        line: {\n          enabled: false\n        },\n        label: {\n          enabled: true\n        },\n        crosshair: {\n          enabled: true\n        }\n      }\n    ],\n    tooltip: { enabled: false },\n    data,\n    ...annotationOpts,\n    ...navigatorOpts,\n    ...statusBarOpts,\n    ...zoomOpts,\n    ...toolbarOpts,\n    ...unusedOpts\n  };\n}\nfunction createVolumeSeries(theme, getTheme, openKey, closeKey, volume, volumeKey) {\n  if (!volume)\n    return [];\n  const barSeriesFill = fromTheme(theme, (t) => t.overrides?.bar?.series?.fill);\n  const itemStyler = barSeriesFill ? { fill: barSeriesFill } : {\n    itemStyler({ datum }) {\n      const { up, down } = getTheme().palette;\n      return { fill: datum[openKey] < datum[closeKey] ? up?.fill : down?.fill };\n    }\n  };\n  return [\n    {\n      type: \"bar\",\n      xKey: \"date\",\n      yKey: volumeKey,\n      // @ts-expect-error\n      focusPriority: 1,\n      tooltip: { enabled: false },\n      highlight: { enabled: false },\n      fillOpacity: fromTheme(theme, (t) => t.overrides?.bar?.series?.fillOpacity) ?? 0.5,\n      ...itemStyler\n    }\n  ];\n}\nvar RANGE_AREA_TYPE = \"range-area\";\nfunction createPriceSeries(theme, chartType2, xKey, highKey, lowKey, openKey, closeKey) {\n  if (chartType2 === RANGE_AREA_TYPE) {\n    Logger.warnOnce(`type '${chartType2}' is deprecated, use 'hlc' chart type instead`);\n    chartType2 = \"hlc\";\n  }\n  const keys = {\n    xKey,\n    openKey,\n    closeKey,\n    highKey,\n    lowKey\n  };\n  const singleKeys = {\n    xKey,\n    yKey: closeKey\n  };\n  const common = {\n    pickOutsideVisibleMinorAxis: true\n  };\n  switch (chartType2 ?? \"candlestick\") {\n    case \"ohlc\":\n      return [\n        {\n          type: \"ohlc\",\n          // @ts-expect-error\n          focusPriority: 0,\n          ...common,\n          ...keys\n        }\n      ];\n    case \"line\":\n      return [\n        {\n          type: \"line\",\n          // @ts-expect-error\n          focusPriority: 0,\n          ...common,\n          ...singleKeys,\n          stroke: fromTheme(theme, (t) => t.overrides?.line?.series?.stroke) ?? PALETTE_NEUTRAL_STROKE,\n          marker: fromTheme(theme, (t) => t.overrides?.line?.series?.marker) ?? { enabled: false }\n        }\n      ];\n    case \"step-line\":\n      return [\n        {\n          type: \"line\",\n          // @ts-expect-error\n          focusPriority: 0,\n          ...common,\n          ...singleKeys,\n          stroke: fromTheme(theme, (t) => t.overrides?.line?.series?.stroke) ?? PALETTE_NEUTRAL_STROKE,\n          interpolation: fromTheme(theme, (t) => t.overrides?.line?.series?.interpolation) ?? {\n            type: \"step\"\n          },\n          marker: fromTheme(theme, (t) => t.overrides?.line?.series?.marker) ?? { enabled: false }\n        }\n      ];\n    case \"hlc\": {\n      const rangeAreaColors = getThemeColors(RANGE_AREA_TYPE, theme);\n      return [\n        {\n          type: RANGE_AREA_TYPE,\n          // @ts-expect-error\n          focusPriority: 0,\n          ...common,\n          xKey,\n          yHighKey: highKey,\n          yLowKey: closeKey,\n          fill: rangeAreaColors.fill ?? PALETTE_UP_FILL,\n          stroke: rangeAreaColors.stroke ?? PALETTE_UP_STROKE,\n          fillOpacity: fromTheme(theme, (t) => t.overrides?.[\"range-area\"]?.series?.fillOpacity) ?? 0.3,\n          strokeWidth: fromTheme(theme, (t) => t.overrides?.[\"range-area\"]?.series?.strokeWidth) ?? 2\n        },\n        {\n          type: RANGE_AREA_TYPE,\n          // @ts-expect-error\n          focusPriority: 0,\n          ...common,\n          xKey,\n          yHighKey: closeKey,\n          yLowKey: lowKey,\n          fill: rangeAreaColors.fill ?? PALETTE_DOWN_FILL,\n          stroke: rangeAreaColors.stroke ?? PALETTE_DOWN_STROKE,\n          fillOpacity: fromTheme(theme, (t) => t.overrides?.[\"range-area\"]?.series?.fillOpacity) ?? 0.3,\n          strokeWidth: fromTheme(theme, (t) => t.overrides?.[\"range-area\"]?.series?.strokeWidth) ?? 2\n        },\n        {\n          type: \"line\",\n          ...common,\n          ...singleKeys,\n          stroke: fromTheme(theme, (t) => t.overrides?.line?.series?.stroke) ?? PALETTE_ALT_NEUTRAL_STROKE,\n          strokeWidth: fromTheme(theme, (t) => t.overrides?.line?.series?.strokeWidth) ?? 2,\n          marker: fromTheme(theme, (t) => t.overrides?.line?.series?.marker) ?? { enabled: false }\n        }\n      ];\n    }\n    case \"high-low\": {\n      const rangeBarColors = getThemeColors(\"range-bar\", theme);\n      return [\n        {\n          type: \"range-bar\",\n          // @ts-expect-error\n          focusPriority: 0,\n          ...common,\n          xKey,\n          yHighKey: highKey,\n          yLowKey: lowKey,\n          fill: rangeBarColors.fill ?? PALETTE_NEUTRAL_FILL,\n          stroke: rangeBarColors.stroke ?? PALETTE_NEUTRAL_STROKE,\n          tooltip: {\n            range: \"nearest\"\n          }\n        }\n      ];\n    }\n    case \"candlestick\":\n      return [\n        {\n          type: \"candlestick\",\n          // @ts-expect-error\n          focusPriority: 0,\n          ...common,\n          ...keys\n        }\n      ];\n    case \"hollow-candlestick\": {\n      const item = fromTheme(theme, (t) => t.overrides?.candlestick?.series?.item);\n      return [\n        {\n          type: \"candlestick\",\n          // @ts-expect-error\n          focusPriority: 0,\n          ...common,\n          ...keys,\n          item: {\n            up: {\n              fill: item?.up?.fill ?? \"transparent\"\n            }\n          }\n        }\n      ];\n    }\n    default:\n      Logger.warnOnce(`unknown chart type: ${chartType2}; expected one of: ${chartTypes2.join(\", \")}`);\n      return [\n        {\n          type: \"candlestick\",\n          // @ts-expect-error\n          focusPriority: 0,\n          ...common,\n          ...keys\n        }\n      ];\n  }\n}\nfunction getThemeColors(seriesType2, theme) {\n  const fill = fromTheme(theme, (t) => t.overrides?.[seriesType2]?.series?.fill);\n  const stroke = fromTheme(theme, (t) => t.overrides?.[seriesType2]?.series?.stroke);\n  return { fill, stroke };\n}\n\n// packages/ag-charts-community/src/api/preset/sparkline.ts\nvar commonAxisProperties = {\n  line: {\n    enabled: false\n  },\n  title: {\n    enabled: false\n  },\n  label: {\n    enabled: false\n  },\n  crosshair: {\n    enabled: false,\n    strokeOpacity: 0.25,\n    lineDash: [0],\n    label: {\n      enabled: false\n    }\n  }\n};\nvar numericAxisProperties = {\n  ...commonAxisProperties,\n  nice: false\n};\nvar bottomCrossHairAxisProperties = {\n  bottom: {\n    crosshair: {\n      enabled: IS_ENTERPRISE\n    }\n  }\n};\nvar crossHairAxes = {\n  category: bottomCrossHairAxisProperties,\n  number: bottomCrossHairAxisProperties,\n  log: bottomCrossHairAxisProperties,\n  time: bottomCrossHairAxisProperties\n};\nvar crossHairTooltip = {\n  position: {\n    type: \"sparkline\"\n  }\n};\nvar SPARKLINE_THEME = {\n  overrides: {\n    common: {\n      animation: {\n        enabled: false\n      },\n      padding: {\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0\n      },\n      axes: {\n        number: {\n          ...numericAxisProperties,\n          interval: {\n            values: [0]\n          }\n        },\n        log: {\n          ...numericAxisProperties\n        },\n        time: {\n          ...numericAxisProperties\n        },\n        category: {\n          ...commonAxisProperties,\n          gridLine: {\n            enabled: false\n          }\n        }\n      }\n    },\n    bar: {\n      series: {\n        // @ts-expect-error\n        sparklineMode: true\n      },\n      tooltip: {\n        range: \"nearest\"\n      }\n    },\n    line: {\n      seriesArea: {\n        padding: {\n          top: 2,\n          right: 2,\n          bottom: 2,\n          left: 2\n        }\n      },\n      axes: crossHairAxes,\n      series: {\n        strokeWidth: 1,\n        marker: {\n          enabled: false,\n          size: 3\n        },\n        tooltip: crossHairTooltip\n      }\n    },\n    area: {\n      seriesArea: {\n        padding: {\n          top: 1,\n          right: 0,\n          bottom: 1,\n          left: 0\n        }\n      },\n      axes: crossHairAxes,\n      series: {\n        strokeWidth: 1,\n        fillOpacity: 0.4,\n        tooltip: crossHairTooltip\n      }\n    }\n  }\n};\nfunction setInitialBaseTheme(baseTheme, initialBaseTheme) {\n  if (typeof baseTheme === \"string\") {\n    return {\n      ...initialBaseTheme,\n      baseTheme\n    };\n  }\n  if (baseTheme != null) {\n    return {\n      ...baseTheme,\n      // @ts-expect-error internal implementation\n      baseTheme: setInitialBaseTheme(baseTheme.baseTheme, initialBaseTheme)\n    };\n  }\n  return initialBaseTheme;\n}\nfunction sparkline(opts) {\n  const {\n    background,\n    container,\n    height: height2,\n    listeners,\n    locale,\n    minHeight,\n    minWidth,\n    padding,\n    width: width2,\n    theme: baseTheme,\n    data,\n    xAxis,\n    yAxis,\n    ...optsRest\n  } = opts;\n  assertEmpty(optsRest);\n  const seriesOptions = optsRest;\n  const swapAxes = seriesOptions.type !== \"bar\" || seriesOptions.direction !== \"horizontal\";\n  const chartOpts = pickProps(opts, {\n    background,\n    container,\n    height: height2,\n    listeners,\n    locale,\n    minHeight,\n    minWidth,\n    padding,\n    width: width2,\n    data,\n    xAxis: IGNORED_PROP,\n    yAxis: IGNORED_PROP,\n    theme: IGNORED_PROP\n  });\n  chartOpts.theme = setInitialBaseTheme(baseTheme, SPARKLINE_THEME);\n  chartOpts.series = [seriesOptions];\n  chartOpts.axes = swapAxes ? [\n    { type: \"number\", ...yAxis, position: \"left\" },\n    { type: \"category\", ...xAxis, position: \"bottom\" }\n  ] : [\n    { type: \"category\", ...xAxis, position: \"left\" },\n    { type: \"number\", ...yAxis, position: \"bottom\" }\n  ];\n  return chartOpts;\n}\n\n// packages/ag-charts-community/src/api/preset/presets.ts\nvar PRESETS = {\n  \"price-volume\": priceVolume,\n  gauge,\n  sparkline\n};\n\n// packages/ag-charts-community/src/chart/factory/processEnterpriseOptions.ts\nfunction removeUsedEnterpriseOptions(options, silent) {\n  let usedOptions = [];\n  const isGaugeChart = isAgGaugeChartOptions(options);\n  const type = optionsType(options);\n  const optionsChartType = type ? chartTypes.get(type) : \"unknown\";\n  for (const {\n    type: type2,\n    chartTypes: moduleChartTypes,\n    optionsKey,\n    optionsInnerKey,\n    identifier\n  } of EXPECTED_ENTERPRISE_MODULES) {\n    if (optionsChartType !== \"unknown\" && !moduleChartTypes.includes(optionsChartType))\n      continue;\n    if (type2 === \"root\" || type2 === \"legend\") {\n      const optionValue = options[optionsKey];\n      if (optionValue == null)\n        continue;\n      if (!optionsInnerKey) {\n        usedOptions.push(optionsKey);\n        delete options[optionsKey];\n      } else if (optionValue[optionsInnerKey]) {\n        usedOptions.push(`${optionsKey}.${optionsInnerKey}`);\n        delete optionValue[optionsInnerKey];\n      }\n    } else if (type2 === \"axis\") {\n      if (!(\"axes\" in options) || !options.axes?.some((axis) => axis.type === identifier))\n        continue;\n      usedOptions.push(`axis[type=${identifier}]`);\n      options.axes = options.axes.filter((axis) => axis.type !== identifier);\n    } else if (type2 === \"axis-option\") {\n      if (!(\"axes\" in options) || !options.axes?.some((axis) => axis[optionsKey]))\n        continue;\n      usedOptions.push(`axis.${optionsKey}`);\n      options.axes.forEach((axis) => {\n        if (axis[optionsKey]) {\n          delete axis[optionsKey];\n        }\n      });\n    } else if (type2 === \"series\") {\n      if (!options.series?.some((series) => series.type === identifier))\n        continue;\n      usedOptions.push(`series[type=${identifier}]`);\n      options.series = options.series.filter((series) => series.type !== identifier);\n    } else if (type2 === \"series-option\") {\n      if (!options.series?.some((series) => series[optionsKey]))\n        continue;\n      usedOptions.push(`series.${optionsKey}`);\n      options.series.forEach((series) => {\n        if (series[optionsKey]) {\n          delete series[optionsKey];\n        }\n      });\n    }\n  }\n  if (usedOptions.length && !silent) {\n    if (isGaugeChart) {\n      usedOptions = [\"AgCharts.createGauge\"];\n    }\n    let enterprisePackageName = \"ag-charts-enterprise\";\n    let enterpriseReferenceUrl = \"https://ag-grid.com/charts/javascript/installation/\";\n    if (options.mode === \"integrated\") {\n      enterprisePackageName = \"ag-grid-charts-enterprise' or 'ag-grid-enterprise/charts-enterprise\";\n      enterpriseReferenceUrl = \"https://www.ag-grid.com/javascript-data-grid/integrated-charts-installation/\";\n    }\n    Logger.warnOnce(\n      [\n        `unable to use these enterprise features as '${enterprisePackageName}' has not been loaded:`,\n        \"\",\n        ...usedOptions,\n        \"\",\n        `See: ${enterpriseReferenceUrl}`\n      ].join(\"\\n\")\n    );\n  }\n}\n\n// packages/ag-charts-community/src/util/string.util.ts\nfunction stringifyValue(value, maxLength = Infinity) {\n  switch (typeof value) {\n    case \"undefined\":\n      return \"undefined\";\n    case \"number\":\n      if (isNaN(value)) {\n        return \"NaN\";\n      } else if (value === Infinity) {\n        return \"Infinity\";\n      } else if (value === -Infinity) {\n        return \"-Infinity\";\n      }\n    default:\n      value = JSON.stringify(value);\n      if (value.length > maxLength) {\n        return `${value.slice(0, maxLength)}... (+${value.length - maxLength} characters)`;\n      }\n      return value;\n  }\n}\n\n// packages/ag-charts-community/src/util/validate.ts\nvar descriptionSymbol = Symbol(\"description\");\nvar requiredSymbol = Symbol(\"required\");\nfunction isValid(options, optionsDefs, path) {\n  const { errors } = validate(options, optionsDefs, path);\n  for (const { message } of errors) {\n    Logger.warn(message);\n  }\n  return errors.length === 0;\n}\nfunction validateMessage(path, value, validatorOrDefs) {\n  const description = isString(validatorOrDefs) ? validatorOrDefs : validatorOrDefs[descriptionSymbol];\n  const expecting = description ? `; expecting ${description}` : \"\";\n  const prefix = path ? `Option \\`${path}\\`` : \"Value\";\n  return `${prefix} cannot be set to \\`${stringifyValue(value)}\\`${expecting}, ignoring.`;\n}\nfunction validate(options, optionsDefs, path = \"\") {\n  if (!isObject(options)) {\n    return {\n      valid: null,\n      errors: [{ path, value: options, message: validateMessage(path, options, \"an object\") }]\n    };\n  }\n  const optionsKeys = new Set(Object.keys(options));\n  const errors = [];\n  const valid = {};\n  function extendPath(key) {\n    if (isArray(optionsDefs)) {\n      return `${path}[${key}]`;\n    }\n    return path ? `${path}.${key}` : key;\n  }\n  for (const [key, validatorOrDefs] of Object.entries(optionsDefs)) {\n    optionsKeys.delete(key);\n    const value = options[key];\n    if (!validatorOrDefs[requiredSymbol] && typeof value === \"undefined\")\n      continue;\n    if (isFunction(validatorOrDefs)) {\n      if (validatorOrDefs(value)) {\n        valid[key] = value;\n      } else {\n        errors.push({ key, path, value, message: validateMessage(extendPath(key), value, validatorOrDefs) });\n      }\n    } else {\n      const nestedResult = validate(value, validatorOrDefs, extendPath(key));\n      valid[key] = nestedResult.valid;\n      errors.push(...nestedResult.errors);\n    }\n  }\n  for (const key of optionsKeys) {\n    errors.push({\n      key,\n      path,\n      unknown: true,\n      message: `Unknown option \\`${extendPath(key)}\\`, ignoring.`\n    });\n  }\n  return { valid, errors };\n}\nfunction attachDescription(validator, description) {\n  return Object.assign((value) => validator(value), { [descriptionSymbol]: description });\n}\nvar or = (...validators) => attachDescription(\n  (value) => validators.some((validator) => validator(value)),\n  validators.map((v) => v[descriptionSymbol]).filter(Boolean).join(\" or \")\n);\nvar array = attachDescription(isArray, \"an array\");\nvar boolean = attachDescription(isBoolean, \"a boolean\");\nvar callback = attachDescription(isFunction, \"a function\");\nvar number = attachDescription(isFiniteNumber, \"a number\");\nvar object = attachDescription(isObject, \"an object\");\nvar string = attachDescription(isString, \"a string\");\nvar numberMin = (min, inclusive = true) => attachDescription(\n  (value) => isFiniteNumber(value) && (value > min || inclusive && value === min),\n  `a number greater than ${inclusive ? \"or equal to \" : \"\"}${min}`\n);\nvar numberRange = (min, max) => attachDescription(\n  (value) => isFiniteNumber(value) && value >= min && value <= max,\n  `a number between ${min} and ${max} inclusive`\n);\nvar positiveNumber = numberMin(0);\nvar minOneNumber = numberMin(1);\nvar ratio = numberRange(0, 1);\nvar degree = numberRange(0, 360);\nvar arrayOf = (validator, description) => attachDescription(\n  (value) => isArray(value) && value.every(validator),\n  description ?? `${validator[descriptionSymbol]} array`\n);\n\n// packages/ag-charts-community/src/module/coreModulesTypes.ts\nfunction paletteType(partial) {\n  if (partial?.up || partial?.down || partial?.neutral) {\n    return \"user-full\";\n  } else if (partial?.fills || partial?.strokes) {\n    return \"user-indexed\";\n  }\n  return \"inbuilt\";\n}\n\n// packages/ag-charts-community/src/chart/themes/chartTheme.ts\nvar DEFAULT_BACKGROUND_FILL = \"white\";\nvar CHART_TYPE_CONFIG = {\n  get cartesian() {\n    return { seriesTypes: chartTypes.cartesianTypes, commonOptions: [\"zoom\", \"navigator\"] };\n  },\n  get polar() {\n    return { seriesTypes: chartTypes.polarTypes, commonOptions: [] };\n  },\n  get hierarchy() {\n    return { seriesTypes: chartTypes.hierarchyTypes, commonOptions: [] };\n  },\n  get topology() {\n    return { seriesTypes: chartTypes.topologyTypes, commonOptions: [] };\n  },\n  get \"flow-proportion\"() {\n    return { seriesTypes: chartTypes.flowProportionTypes, commonOptions: [] };\n  },\n  get standalone() {\n    return { seriesTypes: chartTypes.standaloneTypes, commonOptions: [] };\n  },\n  get gauge() {\n    return { seriesTypes: chartTypes.gaugeTypes, commonOptions: [] };\n  }\n};\nvar PRESET_OVERRIDES_TYPES = {\n  \"radial-gauge\": true,\n  \"linear-gauge\": true\n};\nfunction isPresetOverridesType(type) {\n  return PRESET_OVERRIDES_TYPES[type] === true;\n}\nvar CHART_TYPE_SPECIFIC_COMMON_OPTIONS = Object.values(CHART_TYPE_CONFIG).reduce((r, { commonOptions }) => r.concat(commonOptions), []);\nvar _ChartTheme = class _ChartTheme {\n  static getAxisDefaults(overrideDefaults) {\n    return mergeDefaults(overrideDefaults, {\n      title: {\n        enabled: false,\n        text: \"Axis Title\",\n        spacing: 25,\n        fontWeight: \"normal\" /* NORMAL */,\n        fontSize: 13 /* MEDIUM */,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_LABEL_COLOUR\n      },\n      label: {\n        fontSize: 12 /* SMALL */,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        padding: 5,\n        color: DEFAULT_LABEL_COLOUR,\n        avoidCollisions: true\n      },\n      line: {\n        enabled: true,\n        width: 1,\n        stroke: DEFAULT_AXIS_LINE_COLOUR\n      },\n      tick: {\n        enabled: false,\n        width: 1,\n        stroke: DEFAULT_AXIS_LINE_COLOUR\n      },\n      gridLine: {\n        enabled: true,\n        style: [{ stroke: DEFAULT_AXIS_GRID_COLOUR, lineDash: [] }]\n      },\n      crossLines: {\n        enabled: false,\n        fill: DEFAULT_CROSS_LINES_COLOUR,\n        stroke: DEFAULT_CROSS_LINES_COLOUR,\n        fillOpacity: 0.1,\n        strokeWidth: 1,\n        label: {\n          enabled: false,\n          fontSize: 12 /* SMALL */,\n          fontFamily: DEFAULT_FONT_FAMILY,\n          padding: 5,\n          color: DEFAULT_LABEL_COLOUR\n        }\n      },\n      crosshair: {\n        enabled: true\n      }\n    });\n  }\n  getChartDefaults() {\n    return {\n      minHeight: 300,\n      minWidth: 300,\n      background: { visible: true, fill: DEFAULT_BACKGROUND_COLOUR },\n      padding: { top: DEFAULT_PADDING, right: DEFAULT_PADDING, bottom: DEFAULT_PADDING, left: DEFAULT_PADDING },\n      keyboard: { enabled: true },\n      title: {\n        enabled: false,\n        text: \"Title\",\n        fontWeight: \"normal\" /* NORMAL */,\n        fontSize: 17 /* LARGE */,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_LABEL_COLOUR,\n        wrapping: \"hyphenate\",\n        layoutStyle: DEFAULT_CAPTION_LAYOUT_STYLE,\n        textAlign: DEFAULT_CAPTION_ALIGNMENT\n      },\n      subtitle: {\n        enabled: false,\n        text: \"Subtitle\",\n        spacing: 20,\n        fontSize: 13 /* MEDIUM */,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_MUTED_LABEL_COLOUR,\n        wrapping: \"hyphenate\",\n        layoutStyle: DEFAULT_CAPTION_LAYOUT_STYLE,\n        textAlign: DEFAULT_CAPTION_ALIGNMENT\n      },\n      footnote: {\n        enabled: false,\n        text: \"Footnote\",\n        spacing: 20,\n        fontSize: 13 /* MEDIUM */,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: \"rgb(140, 140, 140)\",\n        wrapping: \"hyphenate\",\n        layoutStyle: DEFAULT_CAPTION_LAYOUT_STYLE,\n        textAlign: DEFAULT_CAPTION_ALIGNMENT\n      },\n      legend: {\n        position: \"bottom\" /* BOTTOM */,\n        spacing: 30,\n        listeners: {},\n        toggleSeries: true,\n        item: {\n          paddingX: 16,\n          paddingY: 8,\n          marker: { size: 15, padding: 8 },\n          showSeriesStroke: true,\n          label: {\n            color: DEFAULT_LABEL_COLOUR,\n            fontSize: 12 /* SMALL */,\n            fontFamily: DEFAULT_FONT_FAMILY\n          }\n        },\n        reverseOrder: false,\n        pagination: {\n          marker: { size: 12 },\n          activeStyle: { fill: DEFAULT_LABEL_COLOUR },\n          inactiveStyle: { fill: DEFAULT_MUTED_LABEL_COLOUR },\n          highlightStyle: { fill: DEFAULT_LABEL_COLOUR },\n          label: { color: DEFAULT_LABEL_COLOUR }\n        }\n      },\n      tooltip: {\n        enabled: true,\n        darkTheme: IS_DARK_THEME,\n        delay: 0\n      },\n      overlays: { darkTheme: IS_DARK_THEME },\n      listeners: {}\n    };\n  }\n  constructor(options = {}) {\n    const { overrides, palette } = deepClone(options);\n    const defaults = this.createChartConfigPerChartType(this.getDefaults());\n    const presets = {};\n    if (overrides) {\n      this.mergeOverrides(defaults, presets, overrides);\n    }\n    const { fills, strokes, ...otherColors } = this.getDefaultColors();\n    this.palette = mergeDefaults(palette, {\n      fills: Object.values(fills),\n      strokes: Object.values(strokes),\n      ...otherColors\n    });\n    this.paletteType = paletteType(palette);\n    this.config = Object.freeze(this.templateTheme(defaults));\n    this.presets = presets;\n  }\n  mergeOverrides(defaults, presets, overrides) {\n    for (const { seriesTypes, commonOptions } of Object.values(CHART_TYPE_CONFIG)) {\n      const cleanedCommon = { ...overrides.common };\n      for (const commonKey of CHART_TYPE_SPECIFIC_COMMON_OPTIONS) {\n        if (!commonOptions.includes(commonKey)) {\n          delete cleanedCommon[commonKey];\n        }\n      }\n      if (!cleanedCommon)\n        continue;\n      for (const s of seriesTypes) {\n        const seriesType2 = s;\n        if (!isPresetOverridesType(seriesType2)) {\n          defaults[seriesType2] = mergeDefaults(cleanedCommon, defaults[seriesType2]);\n        }\n      }\n    }\n    chartTypes.seriesTypes.forEach((s) => {\n      const seriesType2 = s;\n      const seriesOverrides = overrides[seriesType2];\n      if (isPresetOverridesType(seriesType2)) {\n        presets[seriesType2] = seriesOverrides;\n      } else {\n        defaults[seriesType2] = mergeDefaults(seriesOverrides, defaults[seriesType2]);\n      }\n    });\n  }\n  createChartConfigPerChartType(config) {\n    for (const [nextType, { seriesTypes }] of Object.entries(CHART_TYPE_CONFIG)) {\n      const typeDefaults = chartDefaults.get(nextType);\n      for (const seriesType2 of seriesTypes) {\n        config[seriesType2] || (config[seriesType2] = deepClone(typeDefaults));\n      }\n    }\n    return config;\n  }\n  getDefaults() {\n    const getOverridesByType = (chartType2, seriesTypes) => {\n      const result = {};\n      const chartTypeDefaults = {\n        axes: {},\n        ...legendRegistry.getThemeTemplates(),\n        ...this.getChartDefaults(),\n        ...chartDefaults.get(chartType2)\n      };\n      for (const seriesType2 of seriesTypes) {\n        result[seriesType2] = mergeDefaults(\n          seriesRegistry.getThemeTemplate(seriesType2),\n          result[seriesType2] ?? deepClone(chartTypeDefaults)\n        );\n        const { axes } = result[seriesType2];\n        for (const axisType of axisRegistry.keys()) {\n          axes[axisType] = mergeDefaults(\n            axes[axisType],\n            axisRegistry.getThemeTemplate(axisType),\n            _ChartTheme.cartesianAxisDefault[axisType]\n          );\n        }\n      }\n      return result;\n    };\n    return mergeDefaults(\n      getOverridesByType(\"cartesian\", chartTypes.cartesianTypes),\n      getOverridesByType(\"polar\", chartTypes.polarTypes),\n      getOverridesByType(\"hierarchy\", chartTypes.hierarchyTypes),\n      getOverridesByType(\"topology\", chartTypes.topologyTypes),\n      getOverridesByType(\"flow-proportion\", chartTypes.flowProportionTypes),\n      getOverridesByType(\"standalone\", chartTypes.standaloneTypes),\n      getOverridesByType(\"gauge\", chartTypes.gaugeTypes)\n    );\n  }\n  templateTheme(themeTemplate) {\n    const themeInstance = deepClone(themeTemplate);\n    const params = this.getTemplateParameters();\n    jsonWalk(themeInstance, (node) => {\n      if (isArray(node)) {\n        for (let i = 0; i < node.length; i++) {\n          const symbol = node[i];\n          if (params.has(symbol)) {\n            node[i] = params.get(symbol);\n          }\n        }\n      } else {\n        for (const [name, value] of Object.entries(node)) {\n          if (params.has(value)) {\n            node[name] = params.get(value);\n          }\n        }\n      }\n    });\n    return deepClone(themeInstance);\n  }\n  getDefaultColors() {\n    return {\n      fills: DEFAULT_FILLS,\n      strokes: DEFAULT_STROKES,\n      up: { fill: DEFAULT_FILLS.GREEN, stroke: DEFAULT_STROKES.GREEN },\n      down: { fill: DEFAULT_FILLS.RED, stroke: DEFAULT_STROKES.RED },\n      neutral: { fill: DEFAULT_FILLS.GRAY, stroke: DEFAULT_STROKES.GRAY },\n      altUp: { fill: DEFAULT_FILLS.BLUE, stroke: DEFAULT_STROKES.BLUE },\n      altDown: { fill: DEFAULT_FILLS.ORANGE, stroke: DEFAULT_STROKES.ORANGE },\n      altNeutral: { fill: DEFAULT_FILLS.GRAY, stroke: DEFAULT_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const { isEnterprise } = enterpriseModule;\n    const params = /* @__PURE__ */ new Map();\n    params.set(IS_DARK_THEME, false);\n    params.set(IS_ENTERPRISE, isEnterprise);\n    params.set(IS_COMMUNITY, !isEnterprise);\n    params.set(DEFAULT_FONT_FAMILY, \"Verdana, sans-serif\");\n    params.set(DEFAULT_LABEL_COLOUR, \"rgb(70, 70, 70)\");\n    params.set(DEFAULT_INVERTED_LABEL_COLOUR, \"white\");\n    params.set(DEFAULT_MUTED_LABEL_COLOUR, \"rgb(140, 140, 140)\");\n    params.set(DEFAULT_AXIS_GRID_COLOUR, \"rgb(224,234,241)\");\n    params.set(DEFAULT_AXIS_LINE_COLOUR, \"rgb(195, 195, 195)\");\n    params.set(DEFAULT_CROSS_LINES_COLOUR, \"rgb(70, 70, 70)\");\n    params.set(DEFAULT_INSIDE_SERIES_LABEL_COLOUR, DEFAULT_BACKGROUND_FILL);\n    params.set(DEFAULT_BACKGROUND_COLOUR, DEFAULT_BACKGROUND_FILL);\n    params.set(DEFAULT_SHADOW_COLOUR, \"rgba(0, 0, 0, 0.5)\");\n    params.set(DEFAULT_DIVERGING_SERIES_COLOR_RANGE, [\n      DEFAULT_FILLS.ORANGE,\n      DEFAULT_FILLS.YELLOW,\n      DEFAULT_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_GAUGE_SERIES_COLOR_RANGE, [DEFAULT_FILLS.GREEN, DEFAULT_FILLS.YELLOW, DEFAULT_FILLS.RED]);\n    params.set(DEFAULT_FUNNEL_SERIES_COLOR_RANGE, [\n      \"#5090dc\",\n      \"#629be0\",\n      \"#73a6e3\",\n      \"#85b1e7\",\n      \"#96bcea\",\n      \"#a8c8ee\",\n      \"#b9d3f1\",\n      \"#cbdef5\"\n    ]);\n    params.set(DEFAULT_PADDING, 20);\n    params.set(DEFAULT_CAPTION_LAYOUT_STYLE, \"block\");\n    params.set(DEFAULT_CAPTION_ALIGNMENT, \"center\");\n    params.set(DEFAULT_HIERARCHY_FILLS, [\"#ffffff\", \"#e0e5ea\", \"#c1ccd5\", \"#a3b4c1\", \"#859cad\"]);\n    params.set(DEFAULT_HIERARCHY_STROKES, [\"#ffffff\", \"#c5cbd1\", \"#a4b1bd\", \"#8498a9\", \"#648096\"]);\n    params.set(DEFAULT_POLAR_SERIES_STROKE, DEFAULT_BACKGROUND_FILL);\n    params.set(DEFAULT_ANNOTATION_COLOR, DEFAULT_FILLS.BLUE);\n    params.set(DEFAULT_TEXT_ANNOTATION_COLOR, DEFAULT_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, DEFAULT_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_HANDLE_FILL, DEFAULT_BACKGROUND_FILL);\n    params.set(DEFAULT_ANNOTATION_STATISTICS_FILL, \"#fafafa\");\n    params.set(DEFAULT_ANNOTATION_STATISTICS_STROKE, \"#dddddd\");\n    params.set(DEFAULT_ANNOTATION_STATISTICS_COLOR, \"#000000\");\n    params.set(DEFAULT_ANNOTATION_STATISTICS_DIVIDER_STROKE, \"#181d1f\");\n    params.set(DEFAULT_ANNOTATION_STATISTICS_DOWN_FILL, \"#e35c5c\");\n    params.set(DEFAULT_ANNOTATION_STATISTICS_DOWN_STROKE, \"#e35c5c\");\n    params.set(DEFAULT_TEXTBOX_FILL, \"#fafafa\");\n    params.set(DEFAULT_TEXTBOX_STROKE, \"#dddddd\");\n    params.set(DEFAULT_TEXTBOX_COLOR, \"#000000\");\n    params.set(DEFAULT_TOOLBAR_POSITION, \"top\");\n    params.set(DEFAULT_GRIDLINE_ENABLED, false);\n    const defaultColors = this.getDefaultColors();\n    params.set(PALETTE_UP_STROKE, this.palette.up?.stroke ?? defaultColors.up.stroke);\n    params.set(PALETTE_UP_FILL, this.palette.up?.fill ?? defaultColors.up.fill);\n    params.set(PALETTE_DOWN_STROKE, this.palette.down?.stroke ?? defaultColors.down.stroke);\n    params.set(PALETTE_DOWN_FILL, this.palette.down?.fill ?? defaultColors.down.fill);\n    params.set(PALETTE_NEUTRAL_STROKE, this.palette.neutral?.stroke ?? defaultColors.neutral.stroke);\n    params.set(PALETTE_NEUTRAL_FILL, this.palette.neutral?.fill ?? defaultColors.neutral.fill);\n    params.set(PALETTE_ALT_UP_STROKE, this.palette.altUp?.stroke ?? defaultColors.up.stroke);\n    params.set(PALETTE_ALT_UP_FILL, this.palette.altUp?.fill ?? defaultColors.up.fill);\n    params.set(PALETTE_ALT_DOWN_STROKE, this.palette.altDown?.stroke ?? defaultColors.down.stroke);\n    params.set(PALETTE_ALT_DOWN_FILL, this.palette.altDown?.fill ?? defaultColors.down.fill);\n    params.set(PALETTE_ALT_NEUTRAL_FILL, this.palette.altNeutral?.fill ?? defaultColors.altNeutral.fill);\n    params.set(PALETTE_ALT_NEUTRAL_STROKE, this.palette.altNeutral?.stroke ?? defaultColors.altNeutral.stroke);\n    return params;\n  }\n};\n_ChartTheme.cartesianAxisDefault = {\n  [\"number\" /* NUMBER */]: _ChartTheme.getAxisDefaults({\n    line: { enabled: false }\n  }),\n  [\"log\" /* LOG */]: _ChartTheme.getAxisDefaults({\n    base: 10,\n    line: { enabled: false },\n    interval: { minSpacing: NaN }\n  }),\n  [\"category\" /* CATEGORY */]: _ChartTheme.getAxisDefaults({\n    groupPaddingInner: 0.1,\n    label: { autoRotate: true },\n    gridLine: { enabled: DEFAULT_GRIDLINE_ENABLED },\n    crosshair: { enabled: false }\n  }),\n  [\"time\" /* TIME */]: _ChartTheme.getAxisDefaults({ gridLine: { enabled: DEFAULT_GRIDLINE_ENABLED } }),\n  [\"ordinal-time\" /* ORDINAL_TIME */]: _ChartTheme.getAxisDefaults({\n    groupPaddingInner: 0,\n    label: { autoRotate: false },\n    gridLine: { enabled: DEFAULT_GRIDLINE_ENABLED }\n  }),\n  [\"angle-category\" /* ANGLE_CATEGORY */]: _ChartTheme.getAxisDefaults({\n    gridLine: { enabled: DEFAULT_GRIDLINE_ENABLED }\n  }),\n  [\"angle-number\" /* ANGLE_NUMBER */]: _ChartTheme.getAxisDefaults({ gridLine: { enabled: DEFAULT_GRIDLINE_ENABLED } }),\n  [\"radius-category\" /* RADIUS_CATEGORY */]: _ChartTheme.getAxisDefaults({\n    line: { enabled: false }\n  }),\n  [\"radius-number\" /* RADIUS_NUMBER */]: _ChartTheme.getAxisDefaults({\n    line: { enabled: false }\n  }),\n  \"grouped-category\": _ChartTheme.getAxisDefaults({\n    tick: { enabled: true }\n  })\n};\nvar ChartTheme = _ChartTheme;\n\n// packages/ag-charts-community/src/chart/themes/darkTheme.ts\nvar DEFAULT_DARK_BACKGROUND_FILL = \"#192232\";\nvar DEFAULT_DARK_FILLS = {\n  BLUE: \"#5090dc\",\n  ORANGE: \"#ffa03a\",\n  GREEN: \"#459d55\",\n  CYAN: \"#34bfe1\",\n  YELLOW: \"#e1cc00\",\n  VIOLET: \"#9669cb\",\n  GRAY: \"#b5b5b5\",\n  MAGENTA: \"#bd5aa7\",\n  BROWN: \"#8a6224\",\n  RED: \"#ef5452\"\n};\nvar DEFAULT_DARK_STROKES = {\n  BLUE: \"#74a8e6\",\n  ORANGE: \"#ffbe70\",\n  GREEN: \"#6cb176\",\n  CYAN: \"#75d4ef\",\n  YELLOW: \"#f6e559\",\n  VIOLET: \"#aa86d8\",\n  GRAY: \"#a1a1a1\",\n  MAGENTA: \"#ce7ab9\",\n  BROWN: \"#997b52\",\n  RED: \"#ff7872\"\n};\nvar DarkTheme = class extends ChartTheme {\n  getDefaultColors() {\n    return {\n      fills: DEFAULT_DARK_FILLS,\n      strokes: DEFAULT_DARK_STROKES,\n      up: { fill: DEFAULT_DARK_FILLS.GREEN, stroke: DEFAULT_DARK_STROKES.GREEN },\n      down: { fill: DEFAULT_DARK_FILLS.RED, stroke: DEFAULT_DARK_STROKES.RED },\n      neutral: { fill: DEFAULT_DARK_FILLS.GRAY, stroke: DEFAULT_DARK_STROKES.GRAY },\n      altUp: { fill: DEFAULT_DARK_FILLS.BLUE, stroke: DEFAULT_DARK_STROKES.BLUE },\n      altDown: { fill: DEFAULT_DARK_FILLS.ORANGE, stroke: DEFAULT_DARK_STROKES.ORANGE },\n      altNeutral: { fill: DEFAULT_DARK_FILLS.GRAY, stroke: DEFAULT_DARK_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(IS_DARK_THEME, true);\n    params.set(DEFAULT_POLAR_SERIES_STROKE, DEFAULT_DARK_BACKGROUND_FILL);\n    params.set(DEFAULT_LABEL_COLOUR, \"white\");\n    params.set(DEFAULT_MUTED_LABEL_COLOUR, \"#7D91A0\");\n    params.set(DEFAULT_AXIS_GRID_COLOUR, \"#545A6E\");\n    params.set(DEFAULT_CROSS_LINES_COLOUR, \"white\");\n    params.set(DEFAULT_DIVERGING_SERIES_COLOR_RANGE, [\n      DEFAULT_DARK_FILLS.ORANGE,\n      DEFAULT_DARK_FILLS.YELLOW,\n      DEFAULT_DARK_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_GAUGE_SERIES_COLOR_RANGE, [\n      DEFAULT_DARK_FILLS.GREEN,\n      DEFAULT_DARK_FILLS.YELLOW,\n      DEFAULT_DARK_FILLS.RED\n    ]);\n    params.set(DEFAULT_FUNNEL_SERIES_COLOR_RANGE, [\n      \"#5090dc\",\n      \"#4882c6\",\n      \"#4073b0\",\n      \"#38659a\",\n      \"#305684\",\n      \"#28486e\",\n      \"#203a58\",\n      \"#182b42\"\n    ]);\n    params.set(DEFAULT_HIERARCHY_FILLS, [\"#192834\", \"#253746\", \"#324859\", \"#3f596c\", \"#4d6a80\"]);\n    params.set(DEFAULT_HIERARCHY_STROKES, [\"#192834\", \"#3b5164\", \"#496275\", \"#577287\", \"#668399\"]);\n    params.set(DEFAULT_BACKGROUND_COLOUR, DEFAULT_DARK_BACKGROUND_FILL);\n    params.set(DEFAULT_INSIDE_SERIES_LABEL_COLOUR, DEFAULT_DARK_BACKGROUND_FILL);\n    params.set(DEFAULT_ANNOTATION_COLOR, DEFAULT_DARK_FILLS.BLUE);\n    params.set(DEFAULT_TEXT_ANNOTATION_COLOR, \"white\");\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, DEFAULT_DARK_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_HANDLE_FILL, DEFAULT_DARK_BACKGROUND_FILL);\n    params.set(DEFAULT_ANNOTATION_STATISTICS_FILL, \"#28313e\");\n    params.set(DEFAULT_ANNOTATION_STATISTICS_STROKE, \"#4b525d\");\n    params.set(DEFAULT_ANNOTATION_STATISTICS_COLOR, \"#ffffff\");\n    params.set(DEFAULT_ANNOTATION_STATISTICS_DIVIDER_STROKE, \"#ffffff\");\n    params.set(DEFAULT_TEXTBOX_FILL, \"#28313e\");\n    params.set(DEFAULT_TEXTBOX_STROKE, \"#4b525d\");\n    params.set(DEFAULT_TEXTBOX_COLOR, \"#ffffff\");\n    return params;\n  }\n  constructor(options) {\n    super(options);\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/financialDark.ts\nvar FINANCIAL_DARK_FILLS = {\n  GREEN: \"#089981\",\n  RED: \"#F23645\",\n  BLUE: \"#5090dc\",\n  GRAY: \"#A9A9A9\"\n};\nvar FINANCIAL_DARK_STROKES = {\n  GREEN: \"#089981\",\n  RED: \"#F23645\",\n  BLUE: \"#5090dc\",\n  GRAY: \"#909090\"\n};\nvar FinancialDark = class extends DarkTheme {\n  getDefaultColors() {\n    return {\n      fills: { ...FINANCIAL_DARK_FILLS },\n      strokes: { ...FINANCIAL_DARK_STROKES },\n      up: { fill: FINANCIAL_DARK_FILLS.GREEN, stroke: FINANCIAL_DARK_STROKES.GREEN },\n      down: { fill: FINANCIAL_DARK_FILLS.RED, stroke: FINANCIAL_DARK_STROKES.RED },\n      neutral: { fill: FINANCIAL_DARK_FILLS.BLUE, stroke: FINANCIAL_DARK_STROKES.BLUE },\n      altUp: { fill: FINANCIAL_DARK_FILLS.GREEN, stroke: FINANCIAL_DARK_STROKES.GREEN },\n      altDown: { fill: FINANCIAL_DARK_FILLS.RED, stroke: FINANCIAL_DARK_STROKES.RED },\n      altNeutral: { fill: FINANCIAL_DARK_FILLS.GRAY, stroke: FINANCIAL_DARK_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOR_RANGE, [\n      FINANCIAL_DARK_FILLS.GREEN,\n      FINANCIAL_DARK_FILLS.BLUE,\n      FINANCIAL_DARK_FILLS.RED\n    ]);\n    params.set(DEFAULT_ANNOTATION_COLOR, FINANCIAL_DARK_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, FINANCIAL_DARK_FILLS.BLUE);\n    params.set(DEFAULT_AXIS_GRID_COLOUR, \"#343A4E\");\n    params.set(DEFAULT_PADDING, 0);\n    params.set(DEFAULT_CAPTION_LAYOUT_STYLE, \"overlay\");\n    params.set(DEFAULT_CAPTION_ALIGNMENT, \"left\");\n    params.set(DEFAULT_TOOLBAR_POSITION, \"bottom\");\n    params.set(DEFAULT_GRIDLINE_ENABLED, true);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/financialLight.ts\nvar FINANCIAL_LIGHT_FILLS = {\n  GREEN: \"#089981\",\n  RED: \"#F23645\",\n  BLUE: \"#5090dc\",\n  GRAY: \"#A9A9A9\"\n};\nvar FINANCIAL_LIGHT_STROKES = {\n  GREEN: \"#089981\",\n  RED: \"#F23645\",\n  BLUE: \"#5090dc\",\n  GRAY: \"#909090\"\n};\nvar FinancialLight = class extends ChartTheme {\n  getDefaultColors() {\n    return {\n      fills: { ...FINANCIAL_LIGHT_FILLS },\n      strokes: { ...FINANCIAL_LIGHT_STROKES },\n      up: { fill: FINANCIAL_LIGHT_FILLS.GREEN, stroke: FINANCIAL_LIGHT_STROKES.GREEN },\n      down: { fill: FINANCIAL_LIGHT_FILLS.RED, stroke: FINANCIAL_LIGHT_STROKES.RED },\n      neutral: { fill: FINANCIAL_LIGHT_FILLS.BLUE, stroke: FINANCIAL_LIGHT_STROKES.BLUE },\n      altUp: { fill: FINANCIAL_LIGHT_FILLS.GREEN, stroke: FINANCIAL_LIGHT_STROKES.GREEN },\n      altDown: { fill: FINANCIAL_LIGHT_FILLS.RED, stroke: FINANCIAL_LIGHT_STROKES.RED },\n      altNeutral: { fill: FINANCIAL_LIGHT_FILLS.GRAY, stroke: FINANCIAL_LIGHT_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOR_RANGE, [\n      FINANCIAL_LIGHT_FILLS.GREEN,\n      FINANCIAL_LIGHT_FILLS.BLUE,\n      FINANCIAL_LIGHT_FILLS.RED\n    ]);\n    params.set(DEFAULT_ANNOTATION_COLOR, FINANCIAL_LIGHT_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, FINANCIAL_LIGHT_FILLS.BLUE);\n    params.set(DEFAULT_AXIS_GRID_COLOUR, \"#F2F3F3\");\n    params.set(DEFAULT_PADDING, 0);\n    params.set(DEFAULT_CAPTION_LAYOUT_STYLE, \"overlay\");\n    params.set(DEFAULT_CAPTION_ALIGNMENT, \"left\");\n    params.set(DEFAULT_TOOLBAR_POSITION, \"bottom\");\n    params.set(DEFAULT_GRIDLINE_ENABLED, true);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/materialDark.ts\nvar MATERIAL_DARK_FILLS = {\n  BLUE: \"#2196F3\",\n  ORANGE: \"#FF9800\",\n  GREEN: \"#4CAF50\",\n  CYAN: \"#00BCD4\",\n  YELLOW: \"#FFEB3B\",\n  VIOLET: \"#7E57C2\",\n  GRAY: \"#9E9E9E\",\n  MAGENTA: \"#F06292\",\n  BROWN: \"#795548\",\n  RED: \"#F44336\"\n};\nvar MATERIAL_DARK_STROKES = {\n  BLUE: \"#90CAF9\",\n  ORANGE: \"#FFCC80\",\n  GREEN: \"#A5D6A7\",\n  CYAN: \"#80DEEA\",\n  YELLOW: \"#FFF9C4\",\n  VIOLET: \"#B39DDB\",\n  GRAY: \"#E0E0E0\",\n  MAGENTA: \"#F48FB1\",\n  BROWN: \"#A1887F\",\n  RED: \"#EF9A9A\"\n};\nvar MaterialDark = class extends DarkTheme {\n  getDefaultColors() {\n    return {\n      fills: MATERIAL_DARK_FILLS,\n      strokes: MATERIAL_DARK_STROKES,\n      up: { fill: MATERIAL_DARK_FILLS.GREEN, stroke: MATERIAL_DARK_STROKES.GREEN },\n      down: { fill: MATERIAL_DARK_FILLS.RED, stroke: MATERIAL_DARK_STROKES.RED },\n      neutral: { fill: MATERIAL_DARK_FILLS.GRAY, stroke: MATERIAL_DARK_STROKES.GRAY },\n      altUp: { fill: MATERIAL_DARK_FILLS.BLUE, stroke: MATERIAL_DARK_STROKES.BLUE },\n      altDown: { fill: MATERIAL_DARK_FILLS.RED, stroke: MATERIAL_DARK_STROKES.RED },\n      altNeutral: { fill: MATERIAL_DARK_FILLS.GRAY, stroke: MATERIAL_DARK_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOR_RANGE, [\n      MATERIAL_DARK_FILLS.ORANGE,\n      MATERIAL_DARK_FILLS.YELLOW,\n      MATERIAL_DARK_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_FUNNEL_SERIES_COLOR_RANGE, [\n      \"#2196f3\",\n      // 500\n      \"#208FEC\",\n      // (interpolated)\n      \"#1E88E5\",\n      // 600\n      \"#1C7FDC\",\n      // (interpolated)\n      \"#1976d2\",\n      // 700\n      \"#176EC9\",\n      // (interpolated)\n      \"#1565c0\"\n      // 800\n    ]);\n    params.set(DEFAULT_GAUGE_SERIES_COLOR_RANGE, [\n      MATERIAL_DARK_FILLS.GREEN,\n      MATERIAL_DARK_FILLS.YELLOW,\n      MATERIAL_DARK_FILLS.RED\n    ]);\n    params.set(DEFAULT_ANNOTATION_COLOR, MATERIAL_DARK_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, MATERIAL_DARK_FILLS.BLUE);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/materialLight.ts\nvar MATERIAL_LIGHT_FILLS = {\n  BLUE: \"#2196F3\",\n  ORANGE: \"#FF9800\",\n  GREEN: \"#4CAF50\",\n  CYAN: \"#00BCD4\",\n  YELLOW: \"#FFEB3B\",\n  VIOLET: \"#7E57C2\",\n  GRAY: \"#9E9E9E\",\n  MAGENTA: \"#F06292\",\n  BROWN: \"#795548\",\n  RED: \"#F44336\"\n};\nvar MATERIAL_LIGHT_STROKES = {\n  BLUE: \"#1565C0\",\n  ORANGE: \"#E65100\",\n  GREEN: \"#2E7D32\",\n  CYAN: \"#00838F\",\n  YELLOW: \"#F9A825\",\n  VIOLET: \"#4527A0\",\n  GRAY: \"#616161\",\n  MAGENTA: \"#C2185B\",\n  BROWN: \"#4E342E\",\n  RED: \"#B71C1C\"\n};\nvar MaterialLight = class extends ChartTheme {\n  getDefaultColors() {\n    return {\n      fills: MATERIAL_LIGHT_FILLS,\n      strokes: MATERIAL_LIGHT_STROKES,\n      up: { fill: MATERIAL_LIGHT_FILLS.GREEN, stroke: MATERIAL_LIGHT_STROKES.GREEN },\n      down: { fill: MATERIAL_LIGHT_FILLS.RED, stroke: MATERIAL_LIGHT_STROKES.RED },\n      neutral: { fill: MATERIAL_LIGHT_FILLS.GRAY, stroke: MATERIAL_LIGHT_STROKES.GRAY },\n      altUp: { fill: MATERIAL_LIGHT_FILLS.BLUE, stroke: MATERIAL_LIGHT_STROKES.BLUE },\n      altDown: { fill: MATERIAL_LIGHT_FILLS.RED, stroke: MATERIAL_LIGHT_STROKES.RED },\n      altNeutral: { fill: MATERIAL_LIGHT_FILLS.GRAY, stroke: MATERIAL_LIGHT_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOR_RANGE, [\n      MATERIAL_LIGHT_FILLS.ORANGE,\n      MATERIAL_LIGHT_FILLS.YELLOW,\n      MATERIAL_LIGHT_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_FUNNEL_SERIES_COLOR_RANGE, [\n      \"#2196f3\",\n      // 500\n      \"#329EF4\",\n      // (interpolated)\n      \"#42a5f5\",\n      // 400\n      \"#53ADF6\",\n      // (interpolated)\n      \"#64b5f6\",\n      // 300\n      \"#7AC0F8\",\n      // (interpolated)\n      \"#90caf9\"\n      // 200\n    ]);\n    params.set(DEFAULT_GAUGE_SERIES_COLOR_RANGE, [\n      MATERIAL_LIGHT_FILLS.GREEN,\n      MATERIAL_LIGHT_FILLS.YELLOW,\n      MATERIAL_LIGHT_FILLS.RED\n    ]);\n    params.set(DEFAULT_ANNOTATION_COLOR, MATERIAL_LIGHT_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, MATERIAL_LIGHT_FILLS.BLUE);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/polychromaDark.ts\nvar POLYCHROMA_DARK_FILLS = {\n  BLUE: \"#436ff4\",\n  PURPLE: \"#9a7bff\",\n  MAGENTA: \"#d165d2\",\n  PINK: \"#f0598b\",\n  RED: \"#f47348\",\n  ORANGE: \"#f2a602\",\n  YELLOW: \"#e9e201\",\n  GREEN: \"#21b448\",\n  CYAN: \"#00b9a2\",\n  MODERATE_BLUE: \"#00aee4\",\n  GRAY: \"#bbbbbb\"\n};\nvar POLYCHROMA_DARK_STROKES = {\n  BLUE: \"#6698ff\",\n  PURPLE: \"#c0a3ff\",\n  MAGENTA: \"#fc8dfc\",\n  PINK: \"#ff82b1\",\n  RED: \"#ff9b70\",\n  ORANGE: \"#ffcf4e\",\n  YELLOW: \"#ffff58\",\n  GREEN: \"#58dd70\",\n  CYAN: \"#51e2c9\",\n  MODERATE_BLUE: \"#4fd7ff\",\n  GRAY: \"#eeeeee\"\n};\nvar PolychromaDark = class extends DarkTheme {\n  getDefaultColors() {\n    return {\n      fills: POLYCHROMA_DARK_FILLS,\n      strokes: POLYCHROMA_DARK_STROKES,\n      up: { fill: POLYCHROMA_DARK_FILLS.GREEN, stroke: POLYCHROMA_DARK_STROKES.GREEN },\n      down: { fill: POLYCHROMA_DARK_FILLS.RED, stroke: POLYCHROMA_DARK_STROKES.RED },\n      neutral: { fill: POLYCHROMA_DARK_FILLS.GRAY, stroke: POLYCHROMA_DARK_STROKES.GRAY },\n      altUp: { fill: POLYCHROMA_DARK_FILLS.BLUE, stroke: POLYCHROMA_DARK_STROKES.BLUE },\n      altDown: { fill: POLYCHROMA_DARK_FILLS.RED, stroke: POLYCHROMA_DARK_STROKES.RED },\n      altNeutral: { fill: POLYCHROMA_DARK_FILLS.GRAY, stroke: POLYCHROMA_DARK_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOR_RANGE, [POLYCHROMA_DARK_FILLS.BLUE, POLYCHROMA_DARK_FILLS.RED]);\n    params.set(DEFAULT_FUNNEL_SERIES_COLOR_RANGE, [\n      POLYCHROMA_DARK_FILLS.BLUE,\n      POLYCHROMA_DARK_FILLS.PURPLE,\n      POLYCHROMA_DARK_FILLS.MAGENTA,\n      POLYCHROMA_DARK_FILLS.PINK,\n      POLYCHROMA_DARK_FILLS.RED,\n      POLYCHROMA_DARK_FILLS.ORANGE,\n      POLYCHROMA_DARK_FILLS.YELLOW,\n      POLYCHROMA_DARK_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_GAUGE_SERIES_COLOR_RANGE, [POLYCHROMA_DARK_FILLS.BLUE, POLYCHROMA_DARK_FILLS.RED]);\n    params.set(DEFAULT_ANNOTATION_COLOR, POLYCHROMA_DARK_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, POLYCHROMA_DARK_FILLS.BLUE);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/polychromaLight.ts\nvar POLYCHROMA_LIGHT_FILLS = {\n  BLUE: \"#436ff4\",\n  PURPLE: \"#9a7bff\",\n  MAGENTA: \"#d165d2\",\n  PINK: \"#f0598b\",\n  RED: \"#f47348\",\n  ORANGE: \"#f2a602\",\n  YELLOW: \"#e9e201\",\n  GREEN: \"#21b448\",\n  CYAN: \"#00b9a2\",\n  MODERATE_BLUE: \"#00aee4\",\n  GRAY: \"#bbbbbb\"\n};\nvar POLYCHROMA_LIGHT_STROKES = {\n  BLUE: \"#2346c9\",\n  PURPLE: \"#7653d4\",\n  MAGENTA: \"#a73da9\",\n  PINK: \"#c32d66\",\n  RED: \"#c84b1c\",\n  ORANGE: \"#c87f00\",\n  YELLOW: \"#c1b900\",\n  GREEN: \"#008c1c\",\n  CYAN: \"#00927c\",\n  MODERATE_BLUE: \"#0087bb\",\n  GRAY: \"#888888\"\n};\nvar PolychromaLight = class extends ChartTheme {\n  getDefaultColors() {\n    return {\n      fills: POLYCHROMA_LIGHT_FILLS,\n      strokes: POLYCHROMA_LIGHT_STROKES,\n      up: { fill: POLYCHROMA_LIGHT_FILLS.GREEN, stroke: POLYCHROMA_LIGHT_STROKES.GREEN },\n      down: { fill: POLYCHROMA_LIGHT_FILLS.RED, stroke: POLYCHROMA_LIGHT_STROKES.RED },\n      neutral: { fill: POLYCHROMA_LIGHT_FILLS.GRAY, stroke: POLYCHROMA_LIGHT_STROKES.GRAY },\n      altUp: { fill: POLYCHROMA_LIGHT_FILLS.BLUE, stroke: POLYCHROMA_LIGHT_STROKES.BLUE },\n      altDown: { fill: POLYCHROMA_LIGHT_FILLS.RED, stroke: POLYCHROMA_LIGHT_STROKES.RED },\n      altNeutral: { fill: POLYCHROMA_LIGHT_FILLS.GRAY, stroke: POLYCHROMA_LIGHT_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOR_RANGE, [POLYCHROMA_LIGHT_FILLS.BLUE, POLYCHROMA_LIGHT_FILLS.RED]);\n    params.set(DEFAULT_FUNNEL_SERIES_COLOR_RANGE, [\n      POLYCHROMA_LIGHT_FILLS.BLUE,\n      POLYCHROMA_LIGHT_FILLS.PURPLE,\n      POLYCHROMA_LIGHT_FILLS.MAGENTA,\n      POLYCHROMA_LIGHT_FILLS.PINK,\n      POLYCHROMA_LIGHT_FILLS.RED,\n      POLYCHROMA_LIGHT_FILLS.ORANGE,\n      POLYCHROMA_LIGHT_FILLS.YELLOW,\n      POLYCHROMA_LIGHT_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_GAUGE_SERIES_COLOR_RANGE, [POLYCHROMA_LIGHT_FILLS.BLUE, POLYCHROMA_LIGHT_FILLS.RED]);\n    params.set(DEFAULT_ANNOTATION_COLOR, POLYCHROMA_LIGHT_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, POLYCHROMA_LIGHT_FILLS.BLUE);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/sheetsDark.ts\nvar SHEETS_DARK_FILLS = {\n  BLUE: \"#4472C4\",\n  ORANGE: \"#ED7D31\",\n  GRAY: \"#A5A5A5\",\n  YELLOW: \"#FFC000\",\n  MODERATE_BLUE: \"#5B9BD5\",\n  GREEN: \"#70AD47\",\n  DARK_GRAY: \"#7B7B7B\",\n  DARK_BLUE: \"#264478\",\n  VERY_DARK_GRAY: \"#636363\",\n  DARK_YELLOW: \"#997300\"\n};\nvar SHEETS_DARK_STROKES = {\n  BLUE: \"#6899ee\",\n  ORANGE: \"#ffa55d\",\n  GRAY: \"#cdcdcd\",\n  YELLOW: \"#ffea53\",\n  MODERATE_BLUE: \"#82c3ff\",\n  GREEN: \"#96d56f\",\n  DARK_GRAY: \"#a1a1a1\",\n  DARK_BLUE: \"#47689f\",\n  VERY_DARK_GRAY: \"#878787\",\n  DARK_YELLOW: \"#c0993d\"\n};\nvar SheetsDark = class extends DarkTheme {\n  getDefaultColors() {\n    return {\n      fills: { ...SHEETS_DARK_FILLS, RED: SHEETS_DARK_FILLS.ORANGE },\n      strokes: { ...SHEETS_DARK_STROKES, RED: SHEETS_DARK_STROKES.ORANGE },\n      up: { fill: SHEETS_DARK_FILLS.GREEN, stroke: SHEETS_DARK_STROKES.GREEN },\n      down: { fill: SHEETS_DARK_FILLS.ORANGE, stroke: SHEETS_DARK_STROKES.ORANGE },\n      neutral: { fill: SHEETS_DARK_FILLS.GRAY, stroke: SHEETS_DARK_STROKES.GRAY },\n      altUp: { fill: SHEETS_DARK_FILLS.BLUE, stroke: SHEETS_DARK_STROKES.BLUE },\n      altDown: { fill: SHEETS_DARK_FILLS.ORANGE, stroke: SHEETS_DARK_STROKES.ORANGE },\n      altNeutral: { fill: SHEETS_DARK_FILLS.GRAY, stroke: SHEETS_DARK_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOR_RANGE, [\n      SHEETS_DARK_FILLS.ORANGE,\n      SHEETS_DARK_FILLS.YELLOW,\n      SHEETS_DARK_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_GAUGE_SERIES_COLOR_RANGE, [\n      SHEETS_DARK_FILLS.GREEN,\n      SHEETS_DARK_FILLS.YELLOW,\n      SHEETS_DARK_FILLS.ORANGE\n    ]);\n    params.set(DEFAULT_ANNOTATION_COLOR, SHEETS_DARK_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, SHEETS_DARK_FILLS.BLUE);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/sheetsLight.ts\nvar SHEETS_LIGHT_FILLS = {\n  BLUE: \"#5281d5\",\n  ORANGE: \"#ff8d44\",\n  GRAY: \"#b5b5b5\",\n  YELLOW: \"#ffd02f\",\n  MODERATE_BLUE: \"#6aabe6\",\n  GREEN: \"#7fbd57\",\n  DARK_GRAY: \"#8a8a8a\",\n  DARK_BLUE: \"#335287\",\n  VERY_DARK_GRAY: \"#717171\",\n  DARK_YELLOW: \"#a98220\"\n};\nvar SHEETS_LIGHT_STROKES = {\n  BLUE: \"#214d9b\",\n  ORANGE: \"#c25600\",\n  GRAY: \"#7f7f7f\",\n  YELLOW: \"#d59800\",\n  MODERATE_BLUE: \"#3575ac\",\n  GREEN: \"#4b861a\",\n  DARK_GRAY: \"#575757\",\n  DARK_BLUE: \"#062253\",\n  VERY_DARK_GRAY: \"#414141\",\n  DARK_YELLOW: \"#734f00\"\n};\nvar SheetsLight = class extends ChartTheme {\n  getDefaultColors() {\n    return {\n      fills: { ...SHEETS_LIGHT_FILLS, RED: SHEETS_LIGHT_FILLS.ORANGE },\n      strokes: { ...SHEETS_LIGHT_STROKES, RED: SHEETS_LIGHT_STROKES.ORANGE },\n      up: { fill: SHEETS_LIGHT_FILLS.GREEN, stroke: SHEETS_LIGHT_STROKES.GREEN },\n      down: { fill: SHEETS_LIGHT_FILLS.ORANGE, stroke: SHEETS_LIGHT_STROKES.ORANGE },\n      neutral: { fill: SHEETS_LIGHT_STROKES.GRAY, stroke: SHEETS_LIGHT_STROKES.GRAY },\n      altUp: { fill: SHEETS_LIGHT_FILLS.BLUE, stroke: SHEETS_LIGHT_STROKES.BLUE },\n      altDown: { fill: SHEETS_LIGHT_FILLS.ORANGE, stroke: SHEETS_LIGHT_STROKES.ORANGE },\n      altNeutral: { fill: SHEETS_LIGHT_FILLS.GRAY, stroke: SHEETS_LIGHT_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOR_RANGE, [\n      SHEETS_LIGHT_FILLS.ORANGE,\n      SHEETS_LIGHT_FILLS.YELLOW,\n      SHEETS_LIGHT_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_GAUGE_SERIES_COLOR_RANGE, [\n      SHEETS_LIGHT_FILLS.GREEN,\n      SHEETS_LIGHT_FILLS.YELLOW,\n      SHEETS_LIGHT_FILLS.ORANGE\n    ]);\n    params.set(DEFAULT_ANNOTATION_COLOR, SHEETS_LIGHT_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, SHEETS_LIGHT_FILLS.BLUE);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/vividDark.ts\nvar VIVID_DARK_FILLS = {\n  BLUE: \"#0083ff\",\n  ORANGE: \"#ff6600\",\n  GREEN: \"#00af00\",\n  CYAN: \"#00ccff\",\n  YELLOW: \"#f7c700\",\n  VIOLET: \"#ac26ff\",\n  GRAY: \"#a7a7b7\",\n  MAGENTA: \"#e800c5\",\n  BROWN: \"#b54300\",\n  RED: \"#ff0000\"\n};\nvar VIVID_DARK_STROKES = {\n  BLUE: \"#67b7ff\",\n  ORANGE: \"#ffc24d\",\n  GREEN: \"#5cc86f\",\n  CYAN: \"#54ebff\",\n  VIOLET: \"#fff653\",\n  YELLOW: \"#c18aff\",\n  GRAY: \"#aeaeae\",\n  MAGENTA: \"#f078d4\",\n  BROWN: \"#ba8438\",\n  RED: \"#ff726e\"\n};\nvar VividDark = class extends DarkTheme {\n  getDefaultColors() {\n    return {\n      fills: VIVID_DARK_FILLS,\n      strokes: VIVID_DARK_STROKES,\n      up: { fill: VIVID_DARK_FILLS.GREEN, stroke: VIVID_DARK_STROKES.GREEN },\n      down: { fill: VIVID_DARK_FILLS.RED, stroke: VIVID_DARK_STROKES.RED },\n      neutral: { fill: VIVID_DARK_FILLS.GRAY, stroke: VIVID_DARK_STROKES.GRAY },\n      altUp: { fill: VIVID_DARK_FILLS.BLUE, stroke: VIVID_DARK_STROKES.BLUE },\n      altDown: { fill: VIVID_DARK_FILLS.ORANGE, stroke: VIVID_DARK_STROKES.ORANGE },\n      altNeutral: { fill: VIVID_DARK_FILLS.GRAY, stroke: VIVID_DARK_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOR_RANGE, [\n      VIVID_DARK_FILLS.ORANGE,\n      VIVID_DARK_FILLS.YELLOW,\n      VIVID_DARK_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_FUNNEL_SERIES_COLOR_RANGE, [\n      \"#0083ff\",\n      \"#0076e6\",\n      \"#0069cc\",\n      \"#005cb3\",\n      \"#004f99\",\n      \"#004280\",\n      \"#003466\",\n      \"#00274c\"\n    ]);\n    params.set(DEFAULT_GAUGE_SERIES_COLOR_RANGE, [\n      VIVID_DARK_FILLS.GREEN,\n      VIVID_DARK_FILLS.YELLOW,\n      VIVID_DARK_FILLS.RED\n    ]);\n    params.set(DEFAULT_ANNOTATION_COLOR, VIVID_DARK_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, VIVID_DARK_FILLS.BLUE);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/vividLight.ts\nvar VIVID_FILLS = {\n  BLUE: \"#0083ff\",\n  ORANGE: \"#ff6600\",\n  GREEN: \"#00af00\",\n  CYAN: \"#00ccff\",\n  YELLOW: \"#f7c700\",\n  VIOLET: \"#ac26ff\",\n  GRAY: \"#a7a7b7\",\n  MAGENTA: \"#e800c5\",\n  BROWN: \"#b54300\",\n  RED: \"#ff0000\"\n};\nvar VIVID_STROKES = {\n  BLUE: \"#0f68c0\",\n  ORANGE: \"#d47100\",\n  GREEN: \"#007922\",\n  CYAN: \"#009ac2\",\n  VIOLET: \"#bca400\",\n  YELLOW: \"#753cac\",\n  GRAY: \"#646464\",\n  MAGENTA: \"#9b2685\",\n  BROWN: \"#6c3b00\",\n  RED: \"#cb0021\"\n};\nvar VividLight = class extends ChartTheme {\n  getDefaultColors() {\n    return {\n      fills: VIVID_FILLS,\n      strokes: VIVID_STROKES,\n      up: { fill: VIVID_FILLS.GREEN, stroke: VIVID_STROKES.GREEN },\n      down: { fill: VIVID_FILLS.RED, stroke: VIVID_STROKES.RED },\n      neutral: { fill: VIVID_FILLS.GRAY, stroke: VIVID_STROKES.GRAY },\n      altUp: { fill: VIVID_FILLS.BLUE, stroke: VIVID_STROKES.BLUE },\n      altDown: { fill: VIVID_FILLS.ORANGE, stroke: VIVID_STROKES.ORANGE },\n      altNeutral: { fill: VIVID_FILLS.GRAY, stroke: VIVID_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOR_RANGE, [VIVID_FILLS.ORANGE, VIVID_FILLS.YELLOW, VIVID_FILLS.GREEN]);\n    params.set(DEFAULT_FUNNEL_SERIES_COLOR_RANGE, [\n      \"#0083ff\",\n      \"#1a8fff\",\n      \"#339cff\",\n      \"#4da8ff\",\n      \"#66b5ff\",\n      \"#80c1ff\",\n      \"#99cdff\",\n      \"#b3daff\"\n    ]);\n    params.set(DEFAULT_GAUGE_SERIES_COLOR_RANGE, [VIVID_FILLS.GREEN, VIVID_FILLS.YELLOW, VIVID_FILLS.RED]);\n    params.set(DEFAULT_ANNOTATION_COLOR, VIVID_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, VIVID_FILLS.BLUE);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/mapping/themes.ts\nvar lightTheme = () => new ChartTheme();\nvar darkTheme = () => new DarkTheme();\nvar themes = {\n  // darkThemes,\n  \"ag-default-dark\": darkTheme,\n  \"ag-sheets-dark\": () => new SheetsDark(),\n  \"ag-polychroma-dark\": () => new PolychromaDark(),\n  \"ag-vivid-dark\": () => new VividDark(),\n  \"ag-material-dark\": () => new MaterialDark(),\n  \"ag-financial-dark\": () => new FinancialDark(),\n  // lightThemes,\n  null: lightTheme,\n  undefined: lightTheme,\n  \"ag-default\": lightTheme,\n  \"ag-sheets\": () => new SheetsLight(),\n  \"ag-polychroma\": () => new PolychromaLight(),\n  \"ag-vivid\": () => new VividLight(),\n  \"ag-material\": () => new MaterialLight(),\n  \"ag-financial\": () => new FinancialLight()\n};\nfunction getChartTheme(value) {\n  if (value instanceof ChartTheme) {\n    return value;\n  }\n  if (value == null || typeof value === \"string\") {\n    const stockTheme = themes[value];\n    if (stockTheme) {\n      return stockTheme();\n    }\n    Logger.warnOnce(`the theme [${value}] is invalid, using [ag-default] instead.`);\n    return lightTheme();\n  }\n  if (isValid(value, themeOptionsDef, \"theme\")) {\n    const flattenedTheme = reduceThemeOptions(value);\n    const baseTheme = flattenedTheme.baseTheme ? getChartTheme(flattenedTheme.baseTheme) : lightTheme();\n    return new baseTheme.constructor(flattenedTheme);\n  }\n  return lightTheme();\n}\nfunction reduceThemeOptions(options) {\n  let maybeNested = options;\n  let palette;\n  const overrides = [];\n  while (typeof maybeNested === \"object\") {\n    palette ?? (palette = maybeNested.palette);\n    if (maybeNested.overrides) {\n      overrides.push(maybeNested.overrides);\n    }\n    maybeNested = maybeNested.baseTheme;\n  }\n  return {\n    baseTheme: maybeNested,\n    overrides: mergeDefaults(...overrides),\n    palette\n  };\n}\nvar themeOptionsDef = {\n  baseTheme: or(string, object),\n  overrides: object,\n  palette: {\n    fills: arrayOf(string),\n    strokes: arrayOf(string),\n    up: { fill: string, stroke: string },\n    down: { fill: string, stroke: string },\n    neutral: { fill: string, stroke: string }\n  }\n};\n\n// packages/ag-charts-community/src/module/optionsModule.ts\nvar unthemedSeries = /* @__PURE__ */ new Set([\"map-shape-background\", \"map-line-background\"]);\nvar ChartOptions = class {\n  constructor(userOptions, processedOverrides, specialOverrides, metadata) {\n    this.debug = Debug.create(true, \"opts\");\n    var _a;\n    this.optionMetadata = metadata ?? {};\n    this.processedOverrides = processedOverrides ?? {};\n    const cloneOptions = { shallow: [\"data\"] };\n    this.userOptions = deepClone(userOptions, cloneOptions);\n    let options = deepClone(userOptions, cloneOptions);\n    const { presetType } = this.optionMetadata;\n    if (presetType != null) {\n      const presetConstructor = PRESETS[presetType];\n      const presetParams = options;\n      const presetSubType = options.type;\n      const presetTheme = presetSubType != null ? getChartTheme(options.theme).presets[presetSubType] : void 0;\n      this.debug(\">>> AgCharts.createOrUpdate() - applying preset\", presetParams);\n      options = presetConstructor?.(presetParams, presetTheme, () => this.activeTheme) ?? options;\n    }\n    if (!enterpriseModule.isEnterprise) {\n      removeUsedEnterpriseOptions(options);\n    }\n    this.activeTheme = getChartTheme(options.theme);\n    if (presetType) {\n      options = this.activeTheme.templateTheme(options);\n    }\n    this.sanityCheckAndCleanup(options);\n    this.defaultAxes = this.getDefaultAxes(options);\n    this.specialOverrides = this.specialOverridesDefaults({ ...specialOverrides });\n    const chartType2 = this.optionsType(options);\n    const {\n      axes: axesThemes = {},\n      annotations: { axesButtons = null, ...annotationsThemes } = {},\n      series: _,\n      ...themeDefaults\n    } = this.getSeriesThemeConfig(chartType2);\n    this.processedOptions = deepClone(\n      mergeDefaults(\n        processedOverrides,\n        options,\n        axesButtons != null ? { annotations: { axesButtons } } : {},\n        themeDefaults,\n        this.defaultAxes\n      ),\n      cloneOptions\n    );\n    this.processAxesOptions(this.processedOptions, axesThemes);\n    this.processSeriesOptions(this.processedOptions);\n    this.processMiniChartSeriesOptions(this.processedOptions);\n    this.annotationThemes = annotationsThemes;\n    if ((isAgCartesianChartOptions(this.processedOptions) || isAgPolarChartOptionsWithSeriesBasedLegend(this.processedOptions)) && this.processedOptions.legend?.enabled == null) {\n      (_a = this.processedOptions).legend ?? (_a.legend = {});\n      this.processedOptions.legend.enabled = this.processedOptions.series.length > 1;\n    }\n    this.enableConfiguredOptions(this.processedOptions, options);\n    if (!enterpriseModule.isEnterprise) {\n      removeUsedEnterpriseOptions(this.processedOptions, true);\n    }\n  }\n  getOptions() {\n    return this.processedOptions ?? {};\n  }\n  diffOptions(options) {\n    return jsonDiff(options, this.processedOptions);\n  }\n  getSeriesThemeConfig(seriesType2) {\n    const themeConfig = deepClone(this.activeTheme?.config[seriesType2] ?? {});\n    this.removeLeftoverSymbols(themeConfig);\n    return themeConfig;\n  }\n  getDefaultAxes(options) {\n    const optionsType2 = this.optionsType(options);\n    const firstSeriesOptions = options.series?.find((series) => (series.type ?? \"line\") === optionsType2) ?? {};\n    return seriesRegistry.cloneDefaultAxes(optionsType2, firstSeriesOptions);\n  }\n  optionsType(options) {\n    return options.series?.[0]?.type ?? \"line\";\n  }\n  sanityCheckAndCleanup(options) {\n    this.deprecationWarnings(options);\n    this.axesTypeIntegrity(options);\n    this.seriesTypeIntegrity(options);\n    this.soloSeriesIntegrity(options);\n    this.removeDisabledOptions(options);\n    this.removeLeftoverSymbols(options);\n    if (options.series?.some((s) => s.type === \"bullet\") && options.sync != null && options.sync.enabled !== false) {\n      Logger.warnOnce(\"bullet series cannot be synced, disabling synchronization.\");\n      delete options.sync;\n    }\n  }\n  processAxesOptions(options, axesThemes) {\n    if (!(\"axes\" in options))\n      return;\n    options.axes = options.axes.map((axis) => {\n      const { crossLines: crossLinesTheme, ...axisTheme } = mergeDefaults(\n        axesThemes[axis.type]?.[axis.position],\n        axesThemes[axis.type]\n      );\n      if (axis.crossLines) {\n        axis.crossLines = mergeArrayDefaults(axis.crossLines, crossLinesTheme);\n      }\n      const gridLineStyle = axisTheme.gridLine?.style;\n      if (axis.gridLine?.style && gridLineStyle?.length) {\n        axis.gridLine.style = axis.gridLine.style.map(\n          (style, index) => style.stroke != null || style.lineDash != null ? mergeDefaults(style, gridLineStyle.at(index % gridLineStyle.length)) : style\n        );\n      }\n      const { top: _1, right: _2, bottom: _3, left: _4, ...axisOptions } = mergeDefaults(axis, axisTheme);\n      return axisOptions;\n    });\n  }\n  processSeriesOptions(options) {\n    const defaultTooltipPosition = this.getTooltipPositionDefaults(options);\n    const userPalette = isObject(options.theme) ? paletteType(options.theme?.palette) : \"inbuilt\";\n    const paletteOptions = {\n      colourIndex: 0,\n      userPalette\n    };\n    const processedSeries = options.series?.map((series) => {\n      series.type ?? (series.type = this.getDefaultSeriesType(options));\n      const { innerLabels: innerLabelsTheme, ...seriesTheme } = this.getSeriesThemeConfig(series.type).series ?? {};\n      const seriesPaletteOptions = unthemedSeries.has(series.type) ? { colourIndex: 0, userPalette } : paletteOptions;\n      const palette = this.getSeriesPalette(series.type, seriesPaletteOptions);\n      const defaultTooltipRange = this.getTooltipRangeDefaults(options, series.type);\n      const seriesOptions = mergeDefaults(\n        this.getSeriesGroupingOptions(series),\n        series,\n        defaultTooltipPosition,\n        defaultTooltipRange,\n        seriesTheme,\n        palette,\n        { visible: true }\n      );\n      if (seriesOptions.innerLabels) {\n        seriesOptions.innerLabels = mergeArrayDefaults(seriesOptions.innerLabels, innerLabelsTheme);\n      }\n      return this.activeTheme.templateTheme(seriesOptions);\n    });\n    options.series = this.setSeriesGroupingOptions(processedSeries ?? []);\n  }\n  processMiniChartSeriesOptions(options) {\n    let miniChartSeries = options.navigator?.miniChart?.series;\n    if (miniChartSeries == null)\n      return;\n    const paletteOptions = {\n      colourIndex: 0,\n      userPalette: isObject(options.theme) ? paletteType(options.theme.palette) : \"inbuilt\"\n    };\n    miniChartSeries = miniChartSeries.map((series) => {\n      series.type ?? (series.type = \"line\");\n      const { innerLabels: _, ...seriesTheme } = this.getSeriesThemeConfig(series.type).series ?? {};\n      const seriesOptions = mergeDefaults(\n        this.getSeriesGroupingOptions(series),\n        series,\n        seriesTheme,\n        this.getSeriesPalette(series.type, paletteOptions)\n      );\n      return this.activeTheme.templateTheme(seriesOptions);\n    });\n    options.navigator.miniChart.series = this.setSeriesGroupingOptions(miniChartSeries);\n  }\n  getSeriesPalette(seriesType2, options) {\n    const paletteFactory = seriesRegistry.getPaletteFactory(seriesType2);\n    const { colourIndex: colourOffset, userPalette } = options;\n    const { fills = [], strokes = [] } = this.activeTheme.palette;\n    return paletteFactory?.({\n      userPalette,\n      colorsCount: Math.max(fills.length, strokes.length),\n      themeTemplateParameters: this.activeTheme.getTemplateParameters(),\n      palette: this.activeTheme.palette,\n      takeColors(count) {\n        options.colourIndex += count;\n        return {\n          fills: circularSliceArray(fills, count, colourOffset),\n          strokes: circularSliceArray(strokes, count, colourOffset)\n        };\n      }\n    });\n  }\n  getSeriesGroupingOptions(series) {\n    const groupable = seriesRegistry.isGroupable(series.type);\n    const stackable = seriesRegistry.isStackable(series.type);\n    const stackedByDefault = seriesRegistry.isStackedByDefault(series.type);\n    if (series.grouped && !groupable) {\n      Logger.warnOnce(`unsupported grouping of series type \"${series.type}\".`);\n    }\n    if ((series.stacked || series.stackGroup) && !stackable) {\n      Logger.warnOnce(`unsupported stacking of series type \"${series.type}\".`);\n    }\n    let { grouped, stacked } = series;\n    stacked ?? (stacked = (stackedByDefault || series.stackGroup != null) && !(groupable && grouped));\n    grouped ?? (grouped = true);\n    return {\n      stacked: stackable && stacked,\n      grouped: groupable && grouped && !(stackable && stacked)\n    };\n  }\n  setSeriesGroupingOptions(allSeries) {\n    const seriesGroups = this.getSeriesGrouping(allSeries);\n    this.debug(\"setSeriesGroupingOptions() - series grouping: \", seriesGroups);\n    const groupIdx = {};\n    const groupCount2 = seriesGroups.reduce((countMap, seriesGroup) => {\n      var _a;\n      if (seriesGroup.groupType === \"default\" /* DEFAULT */) {\n        return countMap;\n      }\n      countMap[_a = seriesGroup.seriesType] ?? (countMap[_a] = 0);\n      countMap[seriesGroup.seriesType] += seriesGroup.groupType === \"stack\" /* STACK */ ? 1 : seriesGroup.series.length;\n      return countMap;\n    }, {});\n    return seriesGroups.flatMap((seriesGroup) => {\n      var _a;\n      groupIdx[_a = seriesGroup.seriesType] ?? (groupIdx[_a] = 0);\n      switch (seriesGroup.groupType) {\n        case \"stack\" /* STACK */: {\n          const groupIndex = groupIdx[seriesGroup.seriesType]++;\n          return seriesGroup.series.map(\n            (series, stackIndex) => Object.assign(series, {\n              seriesGrouping: {\n                groupId: seriesGroup.groupId,\n                groupIndex,\n                groupCount: groupCount2[seriesGroup.seriesType],\n                stackIndex,\n                stackCount: seriesGroup.series.length\n              }\n            })\n          );\n        }\n        case \"group\" /* GROUP */:\n          return seriesGroup.series.map(\n            (series) => Object.assign(series, {\n              seriesGrouping: {\n                groupId: seriesGroup.groupId,\n                groupIndex: groupIdx[seriesGroup.seriesType]++,\n                groupCount: groupCount2[seriesGroup.seriesType],\n                stackIndex: 0,\n                stackCount: 0\n              }\n            })\n          );\n      }\n      return seriesGroup.series;\n    }).map(({ stacked: _, grouped: __, ...seriesOptions }) => seriesOptions);\n  }\n  getSeriesGroupId(series) {\n    return [series.type, series.xKey, series.stacked ? series.stackGroup ?? \"stacked\" : \"grouped\"].filter(Boolean).join(\"-\");\n  }\n  getSeriesGrouping(allSeries) {\n    const groupMap = /* @__PURE__ */ new Map();\n    return allSeries.reduce((result, series) => {\n      const seriesType2 = series.type;\n      if (!series.stacked && !series.grouped) {\n        result.push({ groupType: \"default\" /* DEFAULT */, seriesType: seriesType2, series: [series], groupId: \"__default__\" });\n      } else {\n        const groupId = this.getSeriesGroupId(series);\n        if (!groupMap.has(groupId)) {\n          const groupType = series.stacked ? \"stack\" /* STACK */ : \"group\" /* GROUP */;\n          const record = { groupType, seriesType: seriesType2, series: [], groupId };\n          groupMap.set(groupId, record);\n          result.push(record);\n        }\n        groupMap.get(groupId).series.push(series);\n      }\n      return result;\n    }, []);\n  }\n  getDefaultSeriesType(options) {\n    if (isAgCartesianChartOptions(options)) {\n      return \"line\";\n    } else if (isAgPolarChartOptions(options)) {\n      return \"pie\";\n    } else if (isAgHierarchyChartOptions(options)) {\n      return \"treemap\";\n    } else if (isAgTopologyChartOptions(options)) {\n      return \"map-shape\";\n    } else if (isAgFlowProportionChartOptions(options)) {\n      return \"sankey\";\n    } else if (isAgStandaloneChartOptions(options)) {\n      return \"pyramid\";\n    } else if (isAgGaugeChartOptions(options)) {\n      return \"radial-gauge\";\n    }\n    throw new Error(\"Invalid chart options type detected.\");\n  }\n  getTooltipPositionDefaults(options) {\n    const position = options.tooltip?.position;\n    if (!isPlainObject(position)) {\n      return;\n    }\n    const { type, xOffset, yOffset } = position;\n    const result = {};\n    if (isString(type) && isEnumValue(AgTooltipPositionType, type)) {\n      result.type = type;\n    }\n    if (isFiniteNumber(xOffset)) {\n      result.xOffset = xOffset;\n    }\n    if (isFiniteNumber(yOffset)) {\n      result.yOffset = yOffset;\n    }\n    return { tooltip: { position: result } };\n  }\n  // AG-11591 Support for new series-specific & legacy chart-global 'tooltip.range' options\n  //\n  // The `chart.series[].tooltip.range` option is a bit different for legacy reason. This use to be\n  // global option (`chart.tooltip.range`) that could override the theme. But now, the tooltip range\n  // option is series-specific.\n  //\n  // To preserve backward compatiblity, the `chart.tooltip.range` theme default has been changed from\n  // 'nearest' to undefined.\n  getTooltipRangeDefaults(options, seriesType2) {\n    return {\n      tooltip: {\n        range: options.tooltip?.range ?? seriesRegistry.getTooltipDefauls(seriesType2)?.range\n      }\n    };\n  }\n  deprecationWarnings(options) {\n    const deprecatedArrayProps = { yKeys: \"yKey\", yNames: \"yName\" };\n    Object.entries(deprecatedArrayProps).forEach(([oldProp, newProp]) => {\n      if (options.series?.some((s) => s[oldProp] != null)) {\n        Logger.warnOnce(\n          `Property [series.${oldProp}] is deprecated, please use [series.${newProp}] and multiple series instead.`\n        );\n      }\n    });\n  }\n  axesTypeIntegrity(options) {\n    if (\"axes\" in options) {\n      const axes = options.axes ?? [];\n      for (const { type } of axes) {\n        if (!isAxisOptionType(type)) {\n          delete options.axes;\n          const expectedTypes = axisRegistry.publicKeys().join(\", \");\n          Logger.warnOnce(`unknown axis type: ${type}; expected one of: ${expectedTypes}`);\n        }\n      }\n    }\n  }\n  seriesTypeIntegrity(options) {\n    options.series = options.series?.filter(({ type }) => {\n      if (type == null || isSeriesOptionType(type) || isEnterpriseSeriesType(type)) {\n        return true;\n      }\n      Logger.warnOnce(\n        `unknown series type: ${type}; expected one of: ${publicChartTypes.seriesTypes.join(\", \")}`\n      );\n    });\n  }\n  soloSeriesIntegrity(options) {\n    const allSeries = options.series;\n    if (allSeries && allSeries.length > 1 && allSeries.some((series) => seriesRegistry.isSolo(series.type))) {\n      const mainSeriesType = this.optionsType(options);\n      if (seriesRegistry.isSolo(mainSeriesType)) {\n        Logger.warn(\n          `series[0] of type '${mainSeriesType}' is incompatible with other series types. Only processing series[0]`\n        );\n        options.series = allSeries.slice(0, 1);\n      } else {\n        const { solo, nonSolo } = groupBy(\n          allSeries,\n          (s) => seriesRegistry.isSolo(s.type) ? \"solo\" : \"nonSolo\"\n        );\n        const rejects = unique(solo.map((s) => s.type)).join(\", \");\n        Logger.warn(`Unable to mix these series types with the lead series type: ${rejects}`);\n        options.series = nonSolo;\n      }\n    }\n  }\n  enableConfiguredOptions(options, userOptions) {\n    jsonWalk(\n      userOptions,\n      (visitingUserOpts, visitingMergedOpts) => {\n        if (visitingMergedOpts && \"enabled\" in visitingMergedOpts && !visitingMergedOpts._enabledFromTheme && visitingUserOpts.enabled == null) {\n          visitingMergedOpts.enabled = true;\n        }\n      },\n      { skip: [\"data\", \"theme\"] },\n      options\n    );\n    jsonWalk(\n      options,\n      (visitingMergedOpts) => {\n        if (visitingMergedOpts._enabledFromTheme != null) {\n          delete visitingMergedOpts._enabledFromTheme;\n        }\n      },\n      { skip: [\"data\", \"theme\"] }\n    );\n  }\n  removeDisabledOptions(options) {\n    jsonWalk(\n      options,\n      (optionsNode) => {\n        if (\"enabled\" in optionsNode && optionsNode.enabled === false) {\n          Object.keys(optionsNode).forEach((key) => {\n            if (key === \"enabled\")\n              return;\n            delete optionsNode[key];\n          });\n        }\n      },\n      { skip: [\"data\", \"theme\"] }\n    );\n  }\n  removeLeftoverSymbols(options) {\n    jsonWalk(\n      options,\n      (optionsNode) => {\n        if (!optionsNode || !isObject(optionsNode))\n          return;\n        for (const [key, value] of Object.entries(optionsNode)) {\n          if (isSymbol(value)) {\n            delete optionsNode[key];\n          }\n        }\n      },\n      { skip: [\"data\"] }\n    );\n  }\n  specialOverridesDefaults(options) {\n    if (options.window != null) {\n      setWindow(options.window);\n    } else if (typeof window !== \"undefined\") {\n      options.window = window;\n    } else if (typeof global !== \"undefined\") {\n      options.window = global.window;\n    }\n    if (options.document != null) {\n      setDocument(options.document);\n    } else if (typeof document !== \"undefined\") {\n      options.document = document;\n    } else if (typeof global !== \"undefined\") {\n      options.document = global.document;\n    }\n    if (options.window == null) {\n      throw new Error(\"AG Charts - unable to resolve global window\");\n    }\n    if (options.document == null) {\n      throw new Error(\"AG Charts - unable to resolve global document\");\n    }\n    return options;\n  }\n};\n\n// packages/ag-charts-community/src/api/agCharts.ts\nvar debug2 = Debug.create(true, \"opts\");\nfunction chartType(options) {\n  if (isAgCartesianChartOptions(options)) {\n    return \"cartesian\";\n  } else if (isAgPolarChartOptions(options)) {\n    return \"polar\";\n  } else if (isAgHierarchyChartOptions(options)) {\n    return \"hierarchy\";\n  } else if (isAgTopologyChartOptions(options)) {\n    return \"topology\";\n  } else if (isAgFlowProportionChartOptions(options)) {\n    return \"flow-proportion\";\n  } else if (isAgStandaloneChartOptions(options)) {\n    return \"standalone\";\n  } else if (isAgGaugeChartOptions(options)) {\n    return \"gauge\";\n  }\n  throw new Error(`AG Chart - unknown type of chart for options with type: ${options.type}`);\n}\nvar AgCharts = class {\n  static licenseCheck(options) {\n    if (this.licenseChecked)\n      return;\n    this.licenseManager = enterpriseModule.licenseManager?.(options);\n    this.licenseManager?.setLicenseKey(this.licenseKey, this.gridContext);\n    this.licenseManager?.validateLicense();\n    this.licenseChecked = true;\n  }\n  static setLicenseKey(licenseKey) {\n    this.licenseKey = licenseKey;\n  }\n  static setGridContext(gridContext) {\n    this.gridContext = gridContext;\n  }\n  static getLicenseDetails(licenseKey) {\n    return enterpriseModule.licenseManager?.({}).getLicenseDetails(licenseKey);\n  }\n  /**\n   * Returns the `AgChartInstance` for a DOM node, if there is one.\n   */\n  static getInstance(element2) {\n    return AgChartsInternal.getInstance(element2);\n  }\n  /**\n   * Create a new `AgChartInstance` based upon the given configuration options.\n   */\n  static create(userOptions, optionsMetadata) {\n    this.licenseCheck(userOptions);\n    const chart = AgChartsInternal.createOrUpdate({\n      userOptions,\n      licenseManager: this.licenseManager,\n      styles: enterpriseModule.styles != null ? [[\"ag-charts-enterprise\", enterpriseModule.styles]] : [],\n      optionsMetadata\n    });\n    if (this.licenseManager?.isDisplayWatermark() && this.licenseManager) {\n      enterpriseModule.injectWatermark?.(chart.chart.ctx.domManager, this.licenseManager.getWatermarkMessage());\n    }\n    return chart;\n  }\n  static createFinancialChart(options) {\n    return this.create(options, { presetType: \"price-volume\" });\n  }\n  static createGauge(options) {\n    return this.create(options, { presetType: \"gauge\" });\n  }\n  static __createSparkline(options) {\n    return this.create(options, { presetType: \"sparkline\" });\n  }\n};\nAgCharts.licenseChecked = false;\nAgCharts.gridContext = false;\nvar _AgChartsInternal = class _AgChartsInternal {\n  static getInstance(element2) {\n    const chart = Chart.getInstance(element2);\n    return chart ? AgChartInstanceProxy.chartInstances.get(chart) : void 0;\n  }\n  static initialiseModules() {\n    if (_AgChartsInternal.initialised)\n      return;\n    registerInbuiltModules();\n    setupModules();\n    _AgChartsInternal.initialised = true;\n  }\n  static createOrUpdate(opts) {\n    let { proxy } = opts;\n    const {\n      userOptions,\n      licenseManager,\n      styles,\n      processedOverrides = proxy?.chart.chartOptions.processedOverrides ?? {},\n      specialOverrides = proxy?.chart.chartOptions.specialOverrides ?? {},\n      optionsMetadata = proxy?.chart.chartOptions.optionMetadata ?? {}\n    } = opts;\n    const { presetType } = optionsMetadata;\n    _AgChartsInternal.initialiseModules();\n    debug2(\">>> AgCharts.createOrUpdate() user options\", userOptions);\n    let mutableOptions = userOptions;\n    if (AgCharts.optionsMutationFn) {\n      mutableOptions = AgCharts.optionsMutationFn(mutableOptions, presetType);\n      debug2(\">>> AgCharts.createOrUpdate() MUTATED user options\", mutableOptions);\n    }\n    const { overrideDevicePixelRatio, document: document2, window: userWindow, styleContainer, ...options } = mutableOptions;\n    const chartOptions = new ChartOptions(\n      options,\n      processedOverrides,\n      {\n        ...specialOverrides,\n        document: document2,\n        window: userWindow,\n        overrideDevicePixelRatio,\n        styleContainer\n      },\n      optionsMetadata\n    );\n    let chart = proxy?.chart;\n    if (chart == null || chartType(chartOptions.processedOptions) !== chartType(chart?.chartOptions.processedOptions)) {\n      chart = _AgChartsInternal.createChartInstance(chartOptions, chart);\n      styles?.forEach(([id, css]) => {\n        chart?.ctx.domManager.addStyles(id, css);\n      });\n    }\n    if (proxy == null) {\n      proxy = new AgChartInstanceProxy(chart, _AgChartsInternal.callbackApi, licenseManager);\n    } else {\n      proxy.chart = chart;\n    }\n    if (debug2.check() && typeof window !== \"undefined\") {\n      window.agChartInstances ?? (window.agChartInstances = {});\n      window.agChartInstances[chart.id] = chart;\n    }\n    chart.queuedUserOptions.push(userOptions);\n    chart.requestFactoryUpdate((chartRef) => {\n      chartRef.applyOptions(chartOptions);\n      const queueIdx = chartRef.queuedUserOptions.indexOf(userOptions) + 1;\n      chartRef.queuedUserOptions.splice(0, queueIdx);\n    });\n    return proxy;\n  }\n  static updateUserDelta(proxy, deltaOptions) {\n    deltaOptions = deepClone(deltaOptions, { shallow: [\"data\"] });\n    jsonWalk(\n      deltaOptions,\n      (node) => {\n        if (typeof node !== \"object\")\n          return;\n        for (const [key, value] of Object.entries(node)) {\n          if (typeof value === \"undefined\") {\n            Object.assign(node, { [key]: Symbol(\"UNSET\") });\n          }\n        }\n      },\n      { skip: [\"data\"] }\n    );\n    const { chart } = proxy;\n    const lastUpdateOptions = chart.getOptions();\n    const userOptions = mergeDefaults(deltaOptions, lastUpdateOptions);\n    debug2(\">>> AgCharts.updateUserDelta() user delta\", deltaOptions);\n    debug2(\"AgCharts.updateUserDelta() - base options\", lastUpdateOptions);\n    _AgChartsInternal.createOrUpdate({ userOptions, proxy });\n  }\n  static createChartInstance(options, oldChart) {\n    const transferableResource = oldChart?.destroy({ keepTransferableResources: true });\n    const ChartConstructor = _AgChartsInternal.getChartByOptions(options.processedOptions);\n    return new ChartConstructor(options, transferableResource);\n  }\n  static getChartByOptions(options) {\n    if (isAgCartesianChartOptions(options)) {\n      return CartesianChart;\n    } else if (isAgHierarchyChartOptions(options)) {\n      return HierarchyChart;\n    } else if (isAgPolarChartOptions(options)) {\n      return PolarChart;\n    } else if (isAgTopologyChartOptions(options)) {\n      return TopologyChart;\n    } else if (isAgFlowProportionChartOptions(options)) {\n      return FlowProportionChart;\n    } else if (isAgStandaloneChartOptions(options)) {\n      return StandaloneChart;\n    } else if (isAgGaugeChartOptions(options)) {\n      return GaugeChart;\n    }\n    throw new Error(\n      `AG Charts - couldn't apply configuration, check options are correctly structured and series types are specified`\n    );\n  }\n};\n_AgChartsInternal.caretaker = new MementoCaretaker(VERSION);\n_AgChartsInternal.initialised = false;\n_AgChartsInternal.callbackApi = {\n  caretaker: _AgChartsInternal.caretaker,\n  create(userOptions, processedOverrides, specialOverrides, optionsMetadata) {\n    return _AgChartsInternal.createOrUpdate({\n      userOptions,\n      processedOverrides,\n      specialOverrides,\n      optionsMetadata\n    });\n  },\n  update(opts, chart) {\n    return _AgChartsInternal.createOrUpdate({ userOptions: opts, proxy: chart });\n  },\n  updateUserDelta(chart, deltaOptions) {\n    return _AgChartsInternal.updateUserDelta(chart, deltaOptions);\n  }\n};\nvar AgChartsInternal = _AgChartsInternal;\n\n// packages/ag-charts-community/src/main-modules.ts\nfunction setupCommunityModules() {\n  registerInbuiltModules();\n  return { AgCharts, version: VERSION };\n}\n\n// packages/ag-charts-community/src/integrated-charts-scene.ts\nvar integrated_charts_scene_exports = {};\n__export(integrated_charts_scene_exports, {\n  Arc: () => Arc2,\n  ArrowDown: () => ArrowDown,\n  ArrowUp: () => ArrowUp,\n  BBox: () => BBox,\n  BandScale: () => BandScale,\n  Caption: () => Caption,\n  ChangeDetectableProperties: () => ChangeDetectableProperties,\n  Circle: () => Circle,\n  ConicGradient: () => ConicGradient,\n  ContinuousScale: () => ContinuousScale,\n  Diamond: () => Diamond,\n  DropShadow: () => DropShadow,\n  ExtendedPath2D: () => ExtendedPath2D,\n  Gradient: () => Gradient,\n  Group: () => Group,\n  HdpiCanvas: () => HdpiCanvas,\n  Image: () => Image,\n  Label: () => Label,\n  Layer: () => Layer,\n  Line: () => Line,\n  LinearGradient: () => LinearGradient,\n  LinearScale: () => LinearScale,\n  Marker: () => Marker,\n  Node: () => Node,\n  OrdinalTimeScale: () => OrdinalTimeScale,\n  Path: () => Path,\n  PointerEvents: () => PointerEvents,\n  RadialColumnShape: () => RadialColumnShape,\n  Rect: () => Rect,\n  RedrawType: () => RedrawType,\n  Rotatable: () => Rotatable,\n  RotatableGroup: () => RotatableGroup,\n  RotatableText: () => RotatableText,\n  Scalable: () => Scalable,\n  ScalableGroup: () => ScalableGroup,\n  Scene: () => Scene,\n  SceneChangeDetection: () => SceneChangeDetection,\n  ScenePathChangeDetection: () => ScenePathChangeDetection,\n  Sector: () => Sector,\n  SectorBox: () => SectorBox,\n  Selection: () => Selection,\n  Shape: () => Shape,\n  Square: () => Square,\n  SvgPath: () => SvgPath,\n  Text: () => Text,\n  Tooltip: () => Tooltip,\n  Transformable: () => Transformable,\n  TransformableText: () => TransformableText,\n  Translatable: () => Translatable,\n  TranslatableGroup: () => TranslatableGroup,\n  TranslatableLayer: () => TranslatableLayer,\n  Triangle: () => Triangle,\n  calculateDerivativeExtrema: () => calculateDerivativeExtrema,\n  calculateDerivativeExtremaXY: () => calculateDerivativeExtremaXY,\n  drawCorner: () => drawCorner,\n  easing: () => easing_exports,\n  evaluateBezier: () => evaluateBezier,\n  getFont: () => getFont,\n  getMarker: () => getMarker,\n  getRadialColumnWidth: () => getRadialColumnWidth,\n  motion: () => motion,\n  sectorBox: () => sectorBox,\n  solveBezier: () => solveBezier,\n  splitBezier: () => splitBezier,\n  toRadians: () => toRadians,\n  toTooltipHtml: () => toTooltipHtml\n});\n\n// packages/ag-charts-community/src/scene/shape/arc.ts\nvar Arc2 = class extends Path {\n  constructor() {\n    super();\n    this.centerX = 0;\n    this.centerY = 0;\n    this.radius = 10;\n    this.startAngle = 0;\n    this.endAngle = Math.PI * 2;\n    this.counterClockwise = false;\n    this.type = 0 /* Open */;\n    this.restoreOwnStyles();\n  }\n  get fullPie() {\n    return isEqual(normalizeAngle360(this.startAngle), normalizeAngle360(this.endAngle));\n  }\n  updatePath() {\n    const path = this.path;\n    path.clear();\n    path.arc(this.centerX, this.centerY, this.radius, this.startAngle, this.endAngle, this.counterClockwise);\n    if (this.type === 1 /* Chord */) {\n      path.closePath();\n    } else if (this.type === 2 /* Round */ && !this.fullPie) {\n      path.lineTo(this.centerX, this.centerY);\n      path.closePath();\n    }\n  }\n  computeBBox() {\n    return new BBox(this.centerX - this.radius, this.centerY - this.radius, this.radius * 2, this.radius * 2);\n  }\n  isPointInPath(x, y) {\n    const bbox = this.getBBox();\n    return this.type !== 0 /* Open */ && bbox.containsPoint(x, y) && this.path.isPointInPath(x, y);\n  }\n};\nArc2.className = \"Arc\";\nArc2.defaultStyles = { ...Shape.defaultStyles, lineWidth: 1, fillStyle: null };\n__decorateClass([\n  ScenePathChangeDetection()\n], Arc2.prototype, \"centerX\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Arc2.prototype, \"centerY\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Arc2.prototype, \"radius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Arc2.prototype, \"startAngle\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Arc2.prototype, \"endAngle\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Arc2.prototype, \"counterClockwise\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Arc2.prototype, \"type\", 2);\n\n// packages/ag-charts-community/src/scene/gradient/conicGradient.ts\nvar ConicGradient = class extends Gradient {\n  constructor(colorSpace, stops, angle2 = 0, bbox) {\n    super(colorSpace, stops, bbox);\n    this.angle = angle2;\n  }\n  createCanvasGradient(ctx, bbox) {\n    const angleOffset = 90;\n    const { colorSpace, stops, angle: angle2 } = this;\n    const radians = normalizeAngle360(toRadians(angle2 + angleOffset));\n    if (!(\"createConicGradient\" in ctx)) {\n      const linearGradient = new LinearGradient(colorSpace, stops, angle2);\n      return linearGradient.createCanvasGradient(ctx, bbox);\n    }\n    const cx = bbox.x + bbox.width * 0.5;\n    const cy = bbox.y + bbox.height * 0.5;\n    return ctx.createConicGradient(radians, cx, cy);\n  }\n};\n\n// packages/ag-charts-community/src/scene/shape/radialColumnShape.ts\nfunction rotatePoint(x, y, rotation) {\n  const radius = Math.sqrt(x ** 2 + y ** 2);\n  const angle2 = Math.atan2(y, x);\n  const rotated = angle2 + rotation;\n  return {\n    x: Math.cos(rotated) * radius,\n    y: Math.sin(rotated) * radius\n  };\n}\nvar RadialColumnShape = class extends Path {\n  constructor() {\n    super(...arguments);\n    this.isBeveled = true;\n    this.columnWidth = 0;\n    this.startAngle = 0;\n    this.endAngle = 0;\n    this.outerRadius = 0;\n    this.innerRadius = 0;\n    this.axisInnerRadius = 0;\n    this.axisOuterRadius = 0;\n    this.isRadiusAxisReversed = false;\n  }\n  set cornerRadius(_value) {\n  }\n  computeBBox() {\n    const { innerRadius, outerRadius, columnWidth } = this;\n    const rotation = this.getRotation();\n    const left = -columnWidth / 2;\n    const right = columnWidth / 2;\n    const top = -outerRadius;\n    const bottom = -innerRadius;\n    let x0 = Infinity;\n    let y0 = Infinity;\n    let x1 = -Infinity;\n    let y1 = -Infinity;\n    for (let i = 0; i < 4; i += 1) {\n      const { x, y } = rotatePoint(i % 2 === 0 ? left : right, i < 2 ? top : bottom, rotation);\n      x0 = Math.min(x, x0);\n      y0 = Math.min(y, y0);\n      x1 = Math.max(x, x1);\n      y1 = Math.max(y, y1);\n    }\n    return new BBox(x0, y0, x1 - x0, y1 - y0);\n  }\n  getRotation() {\n    const { startAngle, endAngle } = this;\n    const midAngle = angleBetween(startAngle, endAngle);\n    return normalizeAngle360(startAngle + midAngle / 2 + Math.PI / 2);\n  }\n  updatePath() {\n    const { isBeveled } = this;\n    if (isBeveled) {\n      this.updateBeveledPath();\n    } else {\n      this.updateRectangularPath();\n    }\n    this.checkPathDirty();\n  }\n  updateRectangularPath() {\n    const { columnWidth, innerRadius, outerRadius, path } = this;\n    const left = -columnWidth / 2;\n    const right = columnWidth / 2;\n    const top = -outerRadius;\n    const bottom = -innerRadius;\n    const rotation = this.getRotation();\n    const points = [\n      [left, bottom],\n      [left, top],\n      [right, top],\n      [right, bottom]\n    ].map(([x, y]) => rotatePoint(x, y, rotation));\n    path.clear(true);\n    path.moveTo(points[0].x, points[0].y);\n    path.lineTo(points[1].x, points[1].y);\n    path.lineTo(points[2].x, points[2].y);\n    path.lineTo(points[3].x, points[3].y);\n    path.closePath();\n  }\n  updateBeveledPath() {\n    const { columnWidth, path, outerRadius, innerRadius, axisInnerRadius, axisOuterRadius, isRadiusAxisReversed } = this;\n    const isStackBottom = isEqual(innerRadius, axisInnerRadius);\n    const sideRotation = Math.asin(columnWidth / 2 / innerRadius);\n    const pointRotation = this.getRotation();\n    const rotate2 = (x, y) => rotatePoint(x, y, pointRotation);\n    const getTriangleHypotenuse = (leg, otherLeg) => Math.sqrt(leg ** 2 + otherLeg ** 2);\n    const getTriangleLeg = (hypotenuse, otherLeg) => {\n      if (otherLeg > hypotenuse) {\n        return 0;\n      }\n      return Math.sqrt(hypotenuse ** 2 - otherLeg ** 2);\n    };\n    const compare = (value, otherValue, lessThan) => lessThan ? value < otherValue : value > otherValue;\n    const shouldConnectBottomCircle = isStackBottom && !isNaN(sideRotation) && sideRotation < Math.PI / 6;\n    let left = -columnWidth / 2;\n    let right = columnWidth / 2;\n    const top = -outerRadius;\n    const bottom = -innerRadius * (shouldConnectBottomCircle ? Math.cos(sideRotation) : 1);\n    const hasBottomIntersection = compare(\n      axisOuterRadius,\n      getTriangleHypotenuse(innerRadius, columnWidth / 2),\n      !isRadiusAxisReversed\n    );\n    if (hasBottomIntersection) {\n      const bottomIntersectionX = getTriangleLeg(axisOuterRadius, innerRadius);\n      left = -bottomIntersectionX;\n      right = bottomIntersectionX;\n    }\n    path.clear(true);\n    const bottomLeftPt = rotate2(left, bottom);\n    path.moveTo(bottomLeftPt.x, bottomLeftPt.y);\n    const isEmpty = isEqual(innerRadius, outerRadius);\n    const hasSideIntersection = compare(\n      axisOuterRadius,\n      getTriangleHypotenuse(outerRadius, columnWidth / 2),\n      !isRadiusAxisReversed\n    );\n    if (isEmpty && shouldConnectBottomCircle) {\n      path.arc(\n        0,\n        0,\n        innerRadius,\n        normalizeAngle360(-sideRotation - Math.PI / 2) + pointRotation,\n        normalizeAngle360(sideRotation - Math.PI / 2) + pointRotation,\n        false\n      );\n    } else if (hasSideIntersection) {\n      const sideIntersectionY = -getTriangleLeg(axisOuterRadius, columnWidth / 2);\n      const topIntersectionX = getTriangleLeg(axisOuterRadius, outerRadius);\n      if (!hasBottomIntersection) {\n        const topLeftPt = rotate2(left, sideIntersectionY);\n        path.lineTo(topLeftPt.x, topLeftPt.y);\n      }\n      path.arc(\n        0,\n        0,\n        axisOuterRadius,\n        Math.atan2(sideIntersectionY, left) + pointRotation,\n        Math.atan2(top, -topIntersectionX) + pointRotation,\n        false\n      );\n      if (!isEqual(topIntersectionX, 0)) {\n        const topRightBevelPt = rotate2(topIntersectionX, top);\n        path.lineTo(topRightBevelPt.x, topRightBevelPt.y);\n      }\n      path.arc(\n        0,\n        0,\n        axisOuterRadius,\n        Math.atan2(top, topIntersectionX) + pointRotation,\n        Math.atan2(sideIntersectionY, right) + pointRotation,\n        false\n      );\n    } else {\n      const topLeftPt = rotate2(left, top);\n      const topRightPt = rotate2(right, top);\n      path.lineTo(topLeftPt.x, topLeftPt.y);\n      path.lineTo(topRightPt.x, topRightPt.y);\n    }\n    const bottomRightPt = rotate2(right, bottom);\n    path.lineTo(bottomRightPt.x, bottomRightPt.y);\n    if (shouldConnectBottomCircle) {\n      path.arc(\n        0,\n        0,\n        innerRadius,\n        normalizeAngle360(sideRotation - Math.PI / 2) + pointRotation,\n        normalizeAngle360(-sideRotation - Math.PI / 2) + pointRotation,\n        true\n      );\n    } else {\n      const rotatedBottomLeftPt = rotate2(left, bottom);\n      path.lineTo(rotatedBottomLeftPt.x, rotatedBottomLeftPt.y);\n    }\n    path.closePath();\n  }\n};\nRadialColumnShape.className = \"RadialColumnShape\";\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"isBeveled\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"columnWidth\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"startAngle\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"endAngle\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"outerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"innerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"axisInnerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"axisOuterRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"isRadiusAxisReversed\", 2);\nfunction getRadialColumnWidth(startAngle, endAngle, axisOuterRadius, columnWidthRatio, maxColumnWidthRatio) {\n  const rotation = angleBetween(startAngle, endAngle);\n  const pad2 = rotation * (1 - columnWidthRatio) / 2;\n  startAngle += pad2;\n  endAngle -= pad2;\n  if (rotation < 1e-3) {\n    return 2 * axisOuterRadius * maxColumnWidthRatio;\n  }\n  if (rotation >= 2 * Math.PI) {\n    const midAngle = startAngle + rotation / 2;\n    startAngle = midAngle - Math.PI;\n    endAngle = midAngle + Math.PI;\n  }\n  const startX = axisOuterRadius * Math.cos(startAngle);\n  const startY = axisOuterRadius * Math.sin(startAngle);\n  const endX = axisOuterRadius * Math.cos(endAngle);\n  const endY = axisOuterRadius * Math.sin(endAngle);\n  const colWidth = Math.floor(Math.sqrt((startX - endX) ** 2 + (startY - endY) ** 2));\n  const maxWidth = 2 * axisOuterRadius * maxColumnWidthRatio;\n  return Math.max(1, Math.min(maxWidth, colWidth));\n}\n\n// packages/ag-charts-community/src/scene/shape/svgPath.ts\nvar SvgPath = class extends Path {\n  constructor(d = \"\") {\n    super();\n    this.x = 0;\n    this.y = 0;\n    this.commands = [];\n    this._d = \"\";\n    this.d = d;\n  }\n  get d() {\n    return this._d;\n  }\n  set d(d) {\n    if (d === this._d)\n      return;\n    this._d = d;\n    this.commands.length = 0;\n    for (const [_, command, paramsString] of d.matchAll(/([A-Z])([0-9. ]*)/g)) {\n      const params = paramsString.split(/\\s+/g).map(Number);\n      this.commands.push([command, params]);\n    }\n    this.checkPathDirty();\n  }\n  updatePath() {\n    const { path, x, y } = this;\n    path.clear();\n    let lastX = x;\n    let lastY = y;\n    for (const [command, params] of this.commands) {\n      switch (command) {\n        case \"M\":\n          path.moveTo(x + params[0], y + params[1]);\n          lastX = x + params[0];\n          break;\n        case \"C\":\n          path.cubicCurveTo(\n            x + params[0],\n            y + params[1],\n            x + params[2],\n            y + params[3],\n            x + params[4],\n            y + params[5]\n          );\n          lastX = x + params[4];\n          lastY = y + params[5];\n          break;\n        case \"H\":\n          path.lineTo(x + params[0], lastY);\n          lastX = y + params[0];\n          break;\n        case \"L\":\n          path.lineTo(x + params[0], y + params[1]);\n          lastX = x + params[0];\n          lastY = y + params[1];\n          break;\n        case \"V\":\n          path.lineTo(lastX, y + params[0]);\n          lastY = y + params[0];\n          break;\n        case \"Z\":\n          path.closePath();\n          break;\n        default:\n          throw new Error(`Could not translate command '${command}' with '${params.join(\" \")}'`);\n      }\n    }\n    path.closePath();\n  }\n};\n__decorateClass([\n  ScenePathChangeDetection()\n], SvgPath.prototype, \"x\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], SvgPath.prototype, \"y\", 2);\n\n// packages/ag-charts-community/src/chart/marker/arrowUp.ts\nvar _ArrowUp = class _ArrowUp extends Marker {\n  updatePath() {\n    const s = this.size / 2;\n    super.applyPath(s, _ArrowUp.moves);\n  }\n};\n_ArrowUp.className = \"ArrowUp\";\n_ArrowUp.moves = [\n  { x: 0, y: 0, t: \"move\" },\n  { x: 1, y: 1.2 },\n  { x: -0.5, y: 0 },\n  { x: 0, y: 0.8 },\n  { x: -1, y: 0 },\n  { x: 0, y: -0.8 },\n  { x: -0.5, y: 0 }\n];\nvar ArrowUp = _ArrowUp;\n\n// packages/ag-charts-community/src/chart/marker/arrowDown.ts\nvar ArrowDown = class extends Marker {\n  updatePath() {\n    const s = this.size / 2;\n    super.applyPath(\n      s,\n      ArrowUp.moves.map((m) => ({ x: m.x * -1, y: m.y * -1 }))\n    );\n  }\n};\nArrowDown.className = \"ArrowDown\";\n\n// packages/ag-charts-community/src/integrated-charts-scene.ts\nvar motion = { ...fromToMotion_exports, ...resetMotion_exports };\nvar getFont = TextUtils.toFontString;\n\n// packages/ag-charts-community/src/integrated-charts-theme.ts\nvar integrated_charts_theme_exports = {};\n__export(integrated_charts_theme_exports, {\n  CARTESIAN_AXIS_TYPE: () => CARTESIAN_AXIS_TYPE,\n  CARTESIAN_POSITION: () => CARTESIAN_POSITION,\n  ChartTheme: () => ChartTheme,\n  DEFAULT_ANNOTATION_BACKGROUND_FILL: () => DEFAULT_ANNOTATION_BACKGROUND_FILL,\n  DEFAULT_ANNOTATION_COLOR: () => DEFAULT_ANNOTATION_COLOR,\n  DEFAULT_ANNOTATION_HANDLE_FILL: () => DEFAULT_ANNOTATION_HANDLE_FILL,\n  DEFAULT_ANNOTATION_STATISTICS_COLOR: () => DEFAULT_ANNOTATION_STATISTICS_COLOR,\n  DEFAULT_ANNOTATION_STATISTICS_DIVIDER_STROKE: () => DEFAULT_ANNOTATION_STATISTICS_DIVIDER_STROKE,\n  DEFAULT_ANNOTATION_STATISTICS_DOWN_FILL: () => DEFAULT_ANNOTATION_STATISTICS_DOWN_FILL,\n  DEFAULT_ANNOTATION_STATISTICS_DOWN_STROKE: () => DEFAULT_ANNOTATION_STATISTICS_DOWN_STROKE,\n  DEFAULT_ANNOTATION_STATISTICS_FILL: () => DEFAULT_ANNOTATION_STATISTICS_FILL,\n  DEFAULT_ANNOTATION_STATISTICS_STROKE: () => DEFAULT_ANNOTATION_STATISTICS_STROKE,\n  DEFAULT_AXIS_GRID_COLOUR: () => DEFAULT_AXIS_GRID_COLOUR,\n  DEFAULT_AXIS_LINE_COLOUR: () => DEFAULT_AXIS_LINE_COLOUR,\n  DEFAULT_BACKGROUND_COLOUR: () => DEFAULT_BACKGROUND_COLOUR,\n  DEFAULT_CAPTION_ALIGNMENT: () => DEFAULT_CAPTION_ALIGNMENT,\n  DEFAULT_CAPTION_LAYOUT_STYLE: () => DEFAULT_CAPTION_LAYOUT_STYLE,\n  DEFAULT_COLOURS: () => DEFAULT_COLOURS,\n  DEFAULT_CROSS_LINES_COLOUR: () => DEFAULT_CROSS_LINES_COLOUR,\n  DEFAULT_DIVERGING_SERIES_COLOR_RANGE: () => DEFAULT_DIVERGING_SERIES_COLOR_RANGE,\n  DEFAULT_FONT_FAMILY: () => DEFAULT_FONT_FAMILY,\n  DEFAULT_FUNNEL_SERIES_COLOR_RANGE: () => DEFAULT_FUNNEL_SERIES_COLOR_RANGE,\n  DEFAULT_GAUGE_SERIES_COLOR_RANGE: () => DEFAULT_GAUGE_SERIES_COLOR_RANGE,\n  DEFAULT_GRIDLINE_ENABLED: () => DEFAULT_GRIDLINE_ENABLED,\n  DEFAULT_HIERARCHY_FILLS: () => DEFAULT_HIERARCHY_FILLS,\n  DEFAULT_HIERARCHY_STROKES: () => DEFAULT_HIERARCHY_STROKES,\n  DEFAULT_INSIDE_SERIES_LABEL_COLOUR: () => DEFAULT_INSIDE_SERIES_LABEL_COLOUR,\n  DEFAULT_INVERTED_LABEL_COLOUR: () => DEFAULT_INVERTED_LABEL_COLOUR,\n  DEFAULT_LABEL_COLOUR: () => DEFAULT_LABEL_COLOUR,\n  DEFAULT_MUTED_LABEL_COLOUR: () => DEFAULT_MUTED_LABEL_COLOUR,\n  DEFAULT_PADDING: () => DEFAULT_PADDING,\n  DEFAULT_POLAR_SERIES_STROKE: () => DEFAULT_POLAR_SERIES_STROKE,\n  DEFAULT_SHADOW_COLOUR: () => DEFAULT_SHADOW_COLOUR,\n  DEFAULT_TEXTBOX_COLOR: () => DEFAULT_TEXTBOX_COLOR,\n  DEFAULT_TEXTBOX_FILL: () => DEFAULT_TEXTBOX_FILL,\n  DEFAULT_TEXTBOX_STROKE: () => DEFAULT_TEXTBOX_STROKE,\n  DEFAULT_TEXT_ANNOTATION_COLOR: () => DEFAULT_TEXT_ANNOTATION_COLOR,\n  DEFAULT_TOOLBAR_POSITION: () => DEFAULT_TOOLBAR_POSITION,\n  FONT_SIZE: () => FONT_SIZE,\n  FONT_WEIGHT: () => FONT_WEIGHT2,\n  IS_COMMUNITY: () => IS_COMMUNITY,\n  IS_DARK_THEME: () => IS_DARK_THEME,\n  IS_ENTERPRISE: () => IS_ENTERPRISE,\n  PALETTE_ALT_DOWN_FILL: () => PALETTE_ALT_DOWN_FILL,\n  PALETTE_ALT_DOWN_STROKE: () => PALETTE_ALT_DOWN_STROKE,\n  PALETTE_ALT_NEUTRAL_FILL: () => PALETTE_ALT_NEUTRAL_FILL,\n  PALETTE_ALT_NEUTRAL_STROKE: () => PALETTE_ALT_NEUTRAL_STROKE,\n  PALETTE_ALT_UP_FILL: () => PALETTE_ALT_UP_FILL,\n  PALETTE_ALT_UP_STROKE: () => PALETTE_ALT_UP_STROKE,\n  PALETTE_DOWN_FILL: () => PALETTE_DOWN_FILL,\n  PALETTE_DOWN_STROKE: () => PALETTE_DOWN_STROKE,\n  PALETTE_NEUTRAL_FILL: () => PALETTE_NEUTRAL_FILL,\n  PALETTE_NEUTRAL_STROKE: () => PALETTE_NEUTRAL_STROKE,\n  PALETTE_UP_FILL: () => PALETTE_UP_FILL,\n  PALETTE_UP_STROKE: () => PALETTE_UP_STROKE,\n  POLAR_AXIS_SHAPE: () => POLAR_AXIS_SHAPE,\n  POLAR_AXIS_TYPE: () => POLAR_AXIS_TYPE,\n  getChartTheme: () => getChartTheme,\n  markerPaletteFactory: () => markerPaletteFactory,\n  singleSeriesPaletteFactory: () => singleSeriesPaletteFactory,\n  swapAxisCondition: () => swapAxisCondition,\n  themes: () => themes2\n});\nvar themes2 = mapValues(\n  themes,\n  (themeFactory) => themeFactory?.()\n);\n\n// packages/ag-charts-community/src/sparklines-scale.ts\nvar sparklines_scale_exports = {};\n__export(sparklines_scale_exports, {\n  BandScale: () => BandScale,\n  ColorScale: () => ColorScale,\n  ContinuousScale: () => ContinuousScale,\n  Invalidating: () => Invalidating,\n  LinearScale: () => LinearScale,\n  OrdinalTimeScale: () => OrdinalTimeScale,\n  TimeScale: () => TimeScale\n});\n\n// packages/ag-charts-community/src/sparklines-util.ts\nvar sparklines_util_exports = {};\n__export(sparklines_util_exports, {\n  Color: () => Color,\n  Debug: () => Debug,\n  Logger: () => Logger,\n  Padding: () => Padding,\n  TimeInterval: () => TimeInterval,\n  angleBetween: () => angleBetween,\n  angleDiff: () => angleDiff,\n  arcDistanceSquared: () => arcDistanceSquared,\n  areArrayNumbersEqual: () => areArrayNumbersEqual,\n  checkDatum: () => checkDatum,\n  clamp: () => clamp,\n  clampArray: () => clampArray,\n  clockwiseAngle: () => clockwiseAngle,\n  clockwiseAngles: () => clockwiseAngles,\n  countFractionDigits: () => countFractionDigits,\n  createId: () => createId,\n  day: () => day,\n  deepClone: () => deepClone,\n  displacePointFromVector: () => displacePointFromVector,\n  extent: () => extent,\n  findMinMax: () => findMinMax,\n  findRangeExtent: () => findRangeExtent,\n  formatNormalizedPercentage: () => formatNormalizedPercentage,\n  formatPercentage: () => formatPercentage,\n  friday: () => friday,\n  generateUUID: () => generateUUID,\n  getAttribute: () => getAttribute,\n  hour: () => hour,\n  interpolateColor: () => interpolateColor,\n  interpolateNumber: () => interpolateNumber,\n  isBetweenAngles: () => isBetweenAngles,\n  isContinuous: () => isContinuous,\n  isDate: () => isValidDate,\n  isDenseInterval: () => isDenseInterval,\n  isEqual: () => isEqual,\n  isNegative: () => isNegative,\n  isNumber: () => isFiniteNumber,\n  isNumberEqual: () => isEqual,\n  isNumberObject: () => isNumberObject,\n  isString: () => isString,\n  isStringObject: () => isStringObject,\n  jsonApply: () => jsonApply,\n  jsonDiff: () => jsonDiff,\n  jsonWalk: () => jsonWalk,\n  lineDistanceSquared: () => lineDistanceSquared,\n  millisecond: () => millisecond,\n  minute: () => minute,\n  mod: () => mod,\n  monday: () => monday,\n  month: () => month,\n  normalisedExtentWithMetadata: () => normalisedExtentWithMetadata,\n  normalizeAngle180: () => normalizeAngle180,\n  normalizeAngle360: () => normalizeAngle360,\n  normalizeAngle360Inclusive: () => normalizeAngle360Inclusive,\n  range: () => range,\n  resetIds: () => resetIds,\n  round: () => round,\n  sanitizeHtml: () => sanitizeHtml,\n  saturday: () => saturday,\n  second: () => second,\n  setAttribute: () => setAttribute,\n  setAttributes: () => setAttributes,\n  setElementStyle: () => setElementStyle,\n  shallowClone: () => shallowClone,\n  sunday: () => sunday,\n  thursday: () => thursday,\n  tickFormat: () => tickFormat,\n  tickStep: () => tickStep,\n  ticks: () => createTicks,\n  toDegrees: () => toDegrees,\n  toFixed: () => toFixed,\n  toRadians: () => toRadians,\n  transformIntegratedCategoryValue: () => transformIntegratedCategoryValue,\n  tuesday: () => tuesday,\n  utcDay: () => utcDay,\n  utcHour: () => utcHour,\n  utcMinute: () => utcMinute,\n  utcMonth: () => utcMonth,\n  utcYear: () => utcYear,\n  wednesday: () => wednesday,\n  year: () => year\n});\n\n// packages/ag-charts-community/src/module-support.ts\nvar module_support_exports = {};\n__export(module_support_exports, {\n  AND: () => AND,\n  ARRAY: () => ARRAY,\n  ARRAY_OF: () => ARRAY_OF,\n  AbstractBarSeries: () => AbstractBarSeries,\n  AbstractBarSeriesProperties: () => AbstractBarSeriesProperties,\n  ActionOnSet: () => ActionOnSet,\n  Animation: () => Animation,\n  AnimationManager: () => AnimationManager,\n  Axis: () => Axis,\n  AxisInterval: () => AxisInterval,\n  AxisLabel: () => AxisLabel,\n  AxisTick: () => AxisTick,\n  AxisTicks: () => AxisTicks,\n  BOOLEAN: () => BOOLEAN,\n  BOOLEAN_ARRAY: () => BOOLEAN_ARRAY,\n  Background: () => Background,\n  BackgroundModule: () => BackgroundModule,\n  BaseModuleInstance: () => BaseModuleInstance,\n  BaseProperties: () => BaseProperties,\n  COLOR_STRING: () => COLOR_STRING,\n  COLOR_STRING_ARRAY: () => COLOR_STRING_ARRAY,\n  CachedTextMeasurer: () => CachedTextMeasurer,\n  CachedTextMeasurerPool: () => CachedTextMeasurerPool,\n  CartesianAxis: () => CartesianAxis,\n  CartesianSeries: () => CartesianSeries,\n  CartesianSeriesNodeEvent: () => CartesianSeriesNodeEvent,\n  CartesianSeriesProperties: () => CartesianSeriesProperties,\n  CategoryAxis: () => CategoryAxis,\n  ChartAxisDirection: () => ChartAxisDirection,\n  ChartEventManager: () => ChartEventManager,\n  ChartOptions: () => ChartOptions,\n  ChartUpdateType: () => ChartUpdateType,\n  ContextMenuRegistry: () => ContextMenuRegistry,\n  Cursor: () => Cursor,\n  CursorManager: () => CursorManager,\n  DATE: () => DATE,\n  DATE_ARRAY: () => DATE_ARRAY,\n  DATE_OR_DATETIME_MS: () => DATE_OR_DATETIME_MS,\n  DEFAULT_CARTESIAN_DIRECTION_KEYS: () => DEFAULT_CARTESIAN_DIRECTION_KEYS,\n  DEFAULT_CARTESIAN_DIRECTION_NAMES: () => DEFAULT_CARTESIAN_DIRECTION_NAMES,\n  DEFAULT_TOOLTIP_CLASS: () => DEFAULT_TOOLTIP_CLASS,\n  DEFAULT_TOOLTIP_DARK_CLASS: () => DEFAULT_TOOLTIP_DARK_CLASS,\n  DEGREE: () => DEGREE,\n  DIRECTION: () => DIRECTION,\n  DOMManager: () => DOMManager,\n  DRAG_INTERACTION_TYPES: () => DRAG_INTERACTION_TYPES,\n  DataController: () => DataController,\n  DataModel: () => DataModel,\n  DataModelSeries: () => DataModelSeries,\n  DataService: () => DataService,\n  Default: () => Default,\n  Deprecated: () => Deprecated,\n  DeprecatedAndRenamedTo: () => DeprecatedAndRenamedTo,\n  EMPTY_TOOLTIP_CONTENT: () => EMPTY_TOOLTIP_CONTENT,\n  FONT_STYLE: () => FONT_STYLE,\n  FONT_WEIGHT: () => FONT_WEIGHT,\n  FUNCTION: () => FUNCTION,\n  GREATER_THAN: () => GREATER_THAN,\n  GestureDetector: () => GestureDetector,\n  GroupedCategoryAxis: () => GroupedCategoryAxis,\n  HierarchyNode: () => HierarchyNode,\n  HierarchySeries: () => HierarchySeries,\n  HierarchySeriesProperties: () => HierarchySeriesProperties,\n  HighlightManager: () => HighlightManager,\n  HighlightProperties: () => HighlightProperties,\n  HighlightStyle: () => HighlightStyle,\n  INTERACTION_RANGE: () => INTERACTION_RANGE,\n  INTERPOLATION_STEP_POSITION: () => INTERPOLATION_STEP_POSITION,\n  INTERPOLATION_TYPE: () => INTERPOLATION_TYPE,\n  InteractionManager: () => InteractionManager,\n  InteractionState: () => InteractionState,\n  InterpolationProperties: () => InterpolationProperties,\n  KeyNavManager: () => KeyNavManager,\n  LABEL_PLACEMENT: () => LABEL_PLACEMENT,\n  LARGEST_KEY_INTERVAL: () => LARGEST_KEY_INTERVAL,\n  LESS_THAN: () => LESS_THAN,\n  LINE_CAP: () => LINE_CAP,\n  LINE_DASH: () => LINE_DASH,\n  LINE_JOIN: () => LINE_JOIN,\n  LINE_STYLE: () => LINE_STYLE,\n  LayoutElement: () => LayoutElement,\n  LayoutManager: () => LayoutManager,\n  LonLatBBox: () => LonLatBBox,\n  MARKER_SHAPE: () => MARKER_SHAPE,\n  MATCHING_CROSSLINE_TYPE: () => MATCHING_CROSSLINE_TYPE,\n  MAX_SPACING: () => MAX_SPACING,\n  MIN_SPACING: () => MIN_SPACING,\n  MercatorScale: () => MercatorScale,\n  ModuleRegistry: () => ModuleRegistry,\n  Motion: () => easing_exports,\n  NAN: () => NAN,\n  NODE_UPDATE_STATE_TO_PHASE_MAPPING: () => NODE_UPDATE_STATE_TO_PHASE_MAPPING,\n  NUMBER: () => NUMBER,\n  NUMBER_ARRAY: () => NUMBER_ARRAY,\n  NUMBER_OR_NAN: () => NUMBER_OR_NAN,\n  Navigator: () => Navigator,\n  NavigatorModule: () => NavigatorModule,\n  NodeRegionBBoxProvider: () => NodeRegionBBoxProvider,\n  OBJECT: () => OBJECT,\n  OBJECT_ARRAY: () => OBJECT_ARRAY,\n  OR: () => OR,\n  OVERFLOW_STRATEGY: () => OVERFLOW_STRATEGY,\n  ObserveChanges: () => ObserveChanges,\n  PHASE_METADATA: () => PHASE_METADATA,\n  PHASE_ORDER: () => PHASE_ORDER,\n  PLACEMENT: () => PLACEMENT,\n  PLAIN_OBJECT: () => PLAIN_OBJECT,\n  POINTER_INTERACTION_TYPES: () => POINTER_INTERACTION_TYPES,\n  POSITION: () => POSITION,\n  POSITION_TOP_COORDINATES: () => POSITION_TOP_COORDINATES,\n  POSITIVE_NUMBER: () => POSITIVE_NUMBER,\n  PolarAxis: () => PolarAxis,\n  PolarSeries: () => PolarSeries,\n  PropertiesArray: () => PropertiesArray,\n  ProxyOnWrite: () => ProxyOnWrite,\n  ProxyProperty: () => ProxyProperty,\n  ProxyPropertyOnWrite: () => ProxyPropertyOnWrite,\n  QUICK_TRANSITION: () => QUICK_TRANSITION,\n  RATIO: () => RATIO,\n  REAL_NUMBER: () => REAL_NUMBER,\n  REGIONS: () => REGIONS,\n  RegionManager: () => RegionManager,\n  RepeatType: () => RepeatType,\n  SKIP_JS_BUILTINS: () => SKIP_JS_BUILTINS,\n  SMALLEST_KEY_INTERVAL: () => SMALLEST_KEY_INTERVAL,\n  SORT_DOMAIN_GROUPS: () => SORT_DOMAIN_GROUPS,\n  STRING: () => STRING,\n  STRING_ARRAY: () => STRING_ARRAY,\n  Series: () => Series,\n  SeriesGroupingChangedEvent: () => SeriesGroupingChangedEvent,\n  SeriesItemHighlightStyle: () => SeriesItemHighlightStyle,\n  SeriesMarker: () => SeriesMarker,\n  SeriesNodeEvent: () => SeriesNodeEvent,\n  SeriesNodePickMode: () => SeriesNodePickMode,\n  SeriesProperties: () => SeriesProperties,\n  SeriesTooltip: () => SeriesTooltip,\n  SimpleRegionBBoxProvider: () => SimpleRegionBBoxProvider,\n  SimpleTextMeasurer: () => SimpleTextMeasurer,\n  StateMachine: () => StateMachine,\n  TEXT_ALIGN: () => TEXT_ALIGN,\n  TEXT_WRAP: () => TEXT_WRAP,\n  TICK_INTERVAL: () => TICK_INTERVAL,\n  TOOLBAR_ALIGNMENTS: () => TOOLBAR_ALIGNMENTS,\n  TOOLBAR_GROUPS: () => TOOLBAR_GROUPS,\n  TOOLBAR_GROUP_ORDERING: () => TOOLBAR_GROUP_ORDERING,\n  TOOLBAR_POSITIONS: () => TOOLBAR_POSITIONS,\n  TextUtils: () => TextUtils,\n  TextWrapper: () => TextWrapper,\n  ToolbarManager: () => ToolbarManager,\n  ToolbarPosition: () => ToolbarPosition,\n  Tooltip: () => Tooltip,\n  TooltipManager: () => TooltipManager,\n  TooltipPosition: () => TooltipPosition,\n  UNION: () => UNION,\n  UpdateService: () => UpdateService,\n  VERTICAL_ALIGN: () => VERTICAL_ALIGN,\n  Validate: () => Validate,\n  Vec2: () => Vec2,\n  Vec4: () => Vec4,\n  ZIndexMap: () => ZIndexMap,\n  ZoomManager: () => ZoomManager,\n  __FORCE_MODULE_DETECTION: () => __FORCE_MODULE_DETECTION,\n  accumulateGroup: () => accumulateGroup,\n  accumulateStack: () => accumulateStack,\n  accumulatedValue: () => accumulatedValue,\n  accumulativeValueProperty: () => accumulativeValueProperty,\n  addHitTestersToQuadtree: () => addHitTestersToQuadtree,\n  adjustLabelPlacement: () => adjustLabelPlacement,\n  animationValidation: () => animationValidation,\n  area: () => area,\n  arraysEqual: () => arraysEqual,\n  backfillPathPointData: () => backfillPathPointData,\n  buildFormatter: () => buildFormatter,\n  buildResetPathFn: () => buildResetPathFn,\n  calculateDefaultTimeTickFormat: () => calculateDefaultTimeTickFormat,\n  calculateLabelChartPadding: () => calculateLabelChartPadding,\n  calculateLabelTranslation: () => calculateLabelTranslation,\n  calculatePlacement: () => calculatePlacement,\n  checkCrisp: () => checkCrisp,\n  circularSliceArray: () => circularSliceArray,\n  clamp: () => clamp,\n  clampArray: () => clampArray,\n  collapsedStartingBarPosition: () => collapsedStartingBarPosition,\n  computeBarFocusBounds: () => computeBarFocusBounds,\n  computeMarkerFocusBounds: () => computeMarkerFocusBounds,\n  convertValuesToScaleByDefs: () => convertValuesToScaleByDefs,\n  countFractionDigits: () => countFractionDigits,\n  createButton: () => createButton,\n  createCheckbox: () => createCheckbox,\n  createDatumId: () => createDatumId,\n  createDeprecationWarning: () => createDeprecationWarning,\n  createElement: () => createElement,\n  createElementId: () => createElementId,\n  createElementNS: () => createElementNS,\n  createIcon: () => createIcon,\n  createSelect: () => createSelect,\n  createTextArea: () => createTextArea,\n  dateToNumber: () => dateToNumber,\n  deconstructSelectionsOrNodes: () => deconstructSelectionsOrNodes,\n  deepClone: () => deepClone,\n  deepMerge: () => deepMerge,\n  defaultTimeTickFormat: () => defaultTimeTickFormat,\n  determinePathStatus: () => determinePathStatus,\n  diff: () => diff,\n  downloadUrl: () => downloadUrl,\n  enterpriseModule: () => enterpriseModule,\n  excludesType: () => excludesType,\n  extent: () => extent,\n  extractDecoratedProperties: () => extractDecoratedProperties,\n  findMaxValue: () => findMaxValue,\n  findMinMax: () => findMinMax,\n  findQuadtreeMatch: () => findQuadtreeMatch,\n  findRangeExtent: () => findRangeExtent,\n  fixNumericExtent: () => fixNumericExtent,\n  focusCursorAtEnd: () => focusCursorAtEnd,\n  formatNormalizedPercentage: () => formatNormalizedPercentage,\n  formatPercentage: () => formatPercentage,\n  formatValue: () => formatValue,\n  fromToMotion: () => fromToMotion,\n  getDocument: () => getDocument,\n  getLastFocus: () => getLastFocus,\n  getMissCount: () => getMissCount,\n  getPath: () => getPath,\n  getPathComponents: () => getPathComponents,\n  getRectConfig: () => getRectConfig,\n  getWindow: () => getWindow,\n  groupAccumulativeValueProperty: () => groupAccumulativeValueProperty,\n  groupAverage: () => groupAverage,\n  groupBy: () => groupBy,\n  groupCount: () => groupCount,\n  groupStackValueProperty: () => groupStackValueProperty,\n  groupSum: () => groupSum,\n  initMenuKeyNav: () => initMenuKeyNav,\n  initRovingTabIndex: () => initRovingTabIndex,\n  initToolbarKeyNav: () => initToolbarKeyNav,\n  isAnimatingFloatingPosition: () => isAnimatingFloatingPosition,\n  isArray: () => isArray,\n  isBoolean: () => isBoolean,\n  isButtonClickEvent: () => isButtonClickEvent,\n  isDate: () => isDate,\n  isDecoratedObject: () => isDecoratedObject,\n  isDefined: () => isDefined,\n  isEnumKey: () => isEnumKey,\n  isEnumValue: () => isEnumValue,\n  isEqual: () => isEqual,\n  isFiniteNumber: () => isFiniteNumber,\n  isFunction: () => isFunction,\n  isHtmlElement: () => isHtmlElement,\n  isNegative: () => isNegative,\n  isNumber: () => isNumber,\n  isObject: () => isObject,\n  isObjectLike: () => isObjectLike,\n  isPlainObject: () => isPlainObject,\n  isProperties: () => isProperties,\n  isRegExp: () => isRegExp,\n  isString: () => isString,\n  isSymbol: () => isSymbol,\n  isValidDate: () => isValidDate,\n  jsonApply: () => jsonApply,\n  jsonDiff: () => jsonDiff,\n  jsonWalk: () => jsonWalk,\n  keyProperty: () => keyProperty,\n  labelDirectionHandling: () => labelDirectionHandling,\n  listDecoratedProperties: () => listDecoratedProperties,\n  makeAccessibleClickListener: () => makeAccessibleClickListener,\n  mapValues: () => mapValues,\n  markerFadeInAnimation: () => markerFadeInAnimation,\n  markerPaletteFactory: () => markerPaletteFactory,\n  markerScaleInAnimation: () => markerScaleInAnimation,\n  markerSwipeScaleInAnimation: () => markerSwipeScaleInAnimation,\n  mergeArrayDefaults: () => mergeArrayDefaults,\n  mergeDefaults: () => mergeDefaults,\n  midpointStartingBarPosition: () => midpointStartingBarPosition,\n  minMax: () => minMax,\n  mod: () => mod,\n  moduleRegistry: () => moduleRegistry,\n  nearestSquared: () => nearestSquared,\n  nearestSquaredInContainer: () => nearestSquaredInContainer,\n  normaliseGroupTo: () => normaliseGroupTo,\n  normalisePropertyTo: () => normalisePropertyTo,\n  normalisedExtentWithMetadata: () => normalisedExtentWithMetadata,\n  objectEqualWith: () => objectEqualWith,\n  pairCategoryData: () => pairCategoryData,\n  pairContinuousData: () => pairContinuousData,\n  partialAssign: () => partialAssign,\n  pathFadeInAnimation: () => pathFadeInAnimation,\n  pathFadeOutAnimation: () => pathFadeOutAnimation,\n  pathRangePoints: () => pathRangePoints,\n  pathRangePointsReverse: () => pathRangePointsReverse,\n  pathRanges: () => pathRanges,\n  pathSwipeInAnimation: () => pathSwipeInAnimation,\n  pickByMatchingAngle: () => pickByMatchingAngle,\n  pickNode: () => pickNode,\n  plotPath: () => plotPath,\n  predicateWithMessage: () => predicateWithMessage,\n  prepareAreaPathAnimation: () => prepareAreaPathAnimation,\n  prepareAxisAnimationContext: () => prepareAxisAnimationContext,\n  prepareAxisAnimationFunctions: () => prepareAxisAnimationFunctions,\n  prepareBarAnimationFunctions: () => prepareBarAnimationFunctions,\n  prepareLinePathAnimation: () => prepareLinePathAnimation,\n  prepareLinePathAnimationFns: () => prepareLinePathAnimationFns,\n  prepareLinePathPropertyAnimation: () => prepareLinePathPropertyAnimation,\n  prepareMarkerAnimation: () => prepareMarkerAnimation,\n  preparePieSeriesAnimationFunctions: () => preparePieSeriesAnimationFunctions,\n  range: () => range2,\n  rangedValueProperty: () => rangedValueProperty,\n  renderPartialPath: () => renderPartialPath,\n  resetAxisGroupFn: () => resetAxisGroupFn,\n  resetAxisLabelSelectionFn: () => resetAxisLabelSelectionFn,\n  resetAxisLineSelectionFn: () => resetAxisLineSelectionFn,\n  resetAxisSelectionFn: () => resetAxisSelectionFn,\n  resetBarSelectionsFn: () => resetBarSelectionsFn,\n  resetIds: () => resetIds,\n  resetLabelFn: () => resetLabelFn,\n  resetMarkerFn: () => resetMarkerFn,\n  resetMarkerPositionFn: () => resetMarkerPositionFn,\n  resetMotion: () => resetMotion,\n  resetPieSelectionsFn: () => resetPieSelectionsFn,\n  round: () => round,\n  scale: () => scale,\n  seriesLabelFadeInAnimation: () => seriesLabelFadeInAnimation,\n  seriesLabelFadeOutAnimation: () => seriesLabelFadeOutAnimation,\n  setDocument: () => setDocument,\n  setElementBBox: () => setElementBBox,\n  setPath: () => setPath,\n  setWindow: () => setWindow,\n  shallowClone: () => shallowClone,\n  singleSeriesPaletteFactory: () => singleSeriesPaletteFactory,\n  sortBasedOnArray: () => sortBasedOnArray,\n  splitPairData: () => splitPairData,\n  staticFromToMotion: () => staticFromToMotion,\n  stopPageScrolling: () => stopPageScrolling,\n  stringify: () => stringify,\n  sum: () => sum,\n  sumValues: () => sumValues,\n  toArray: () => toArray,\n  toFixed: () => toFixed,\n  toTooltipHtml: () => toTooltipHtml,\n  trailingAccumulatedValue: () => trailingAccumulatedValue,\n  trailingAccumulatedValueProperty: () => trailingAccumulatedValueProperty,\n  unique: () => unique,\n  updateClipPath: () => updateClipPath,\n  updateLabelNode: () => updateLabelNode,\n  updateRect: () => updateRect,\n  validateCrossLineValues: () => validateCrossLineValues,\n  valueProperty: () => valueProperty,\n  without: () => without\n});\n\n// packages/ag-charts-community/src/util/deprecation.ts\nfunction createDeprecationWarning() {\n  return (key, message) => {\n    const msg = [`Property [${key}] is deprecated.`, message].filter(Boolean).join(\" \");\n    Logger.warnOnce(msg);\n  };\n}\nfunction Deprecated(message, opts) {\n  const warnDeprecated = createDeprecationWarning();\n  const def = opts?.default;\n  return addTransformToInstanceProperty((_, key, value) => {\n    if (value !== def) {\n      warnDeprecated(key.toString(), message);\n    }\n    return value;\n  });\n}\nfunction DeprecatedAndRenamedTo(newPropName, mapValue) {\n  const warnDeprecated = createDeprecationWarning();\n  return addTransformToInstanceProperty(\n    (target, key, value) => {\n      if (value !== target[newPropName]) {\n        warnDeprecated(key.toString(), `Use [${newPropName}] instead.`);\n        setPath(target, newPropName, mapValue ? mapValue(value) : value);\n      }\n      return BREAK_TRANSFORM_CHAIN;\n    },\n    (target, key) => {\n      warnDeprecated(key.toString(), `Use [${newPropName}] instead.`);\n      return getPath(target, newPropName);\n    }\n  );\n}\n\n// packages/ag-charts-community/src/util/search.util.ts\nfunction findMaxValue(min, max, iteratee) {\n  if (min > max)\n    return;\n  let found;\n  while (max >= min) {\n    const index = Math.floor((max + min) / 2);\n    const value = iteratee(index);\n    if (value == null) {\n      max = index - 1;\n    } else {\n      found = value;\n      min = index + 1;\n    }\n  }\n  return found;\n}\n\n// packages/ag-charts-community/src/util/vector4.ts\nvar Vec4 = {\n  bottomCenter,\n  center,\n  clone,\n  end,\n  from: from2,\n  height,\n  round: round4,\n  start,\n  topCenter,\n  origin: origin2,\n  width\n};\nfunction start(a) {\n  return { x: a.x1, y: a.y1 };\n}\nfunction end(a) {\n  return { x: a.x2, y: a.y2 };\n}\nfunction topCenter(a) {\n  return { x: (a.x1 + a.x2) / 2, y: Math.min(a.y1, a.y2) };\n}\nfunction center(a) {\n  return { x: (a.x1 + a.x2) / 2, y: (a.y1 + a.y2) / 2 };\n}\nfunction bottomCenter(a) {\n  return { x: (a.x1 + a.x2) / 2, y: Math.max(a.y1, a.y2) };\n}\nfunction width(a) {\n  return Math.abs(a.x2 - a.x1);\n}\nfunction height(a) {\n  return Math.abs(a.y2 - a.y1);\n}\nfunction round4(a) {\n  return { x1: Math.round(a.x1), y1: Math.round(a.y1), x2: Math.round(a.x2), y2: Math.round(a.y2) };\n}\nfunction clone(a) {\n  return { x1: a.x1, y1: a.y1, x2: a.x2, y2: a.y2 };\n}\nfunction from2(a, b, c, d) {\n  if (typeof a === \"number\") {\n    return { x1: a, y1: b, x2: c, y2: d };\n  }\n  if (\"width\" in a) {\n    return {\n      x1: a.x,\n      y1: a.y,\n      x2: a.x + a.width,\n      y2: a.y + a.height\n    };\n  }\n  throw new Error(`Values can not be converted into a vector4: [${a}] [${b}] [${c}] [${d}]`);\n}\nfunction origin2() {\n  return { x1: 0, y1: 0, x2: 0, y2: 0 };\n}\n\n// packages/ag-charts-community/src/chart/series/hierarchy/hierarchySeries.ts\nvar _HierarchyNode = class _HierarchyNode {\n  constructor(series, index, datum, size, colorValue, fill, stroke, sumSize, depth, parent, children) {\n    this.series = series;\n    this.index = index;\n    this.datum = datum;\n    this.size = size;\n    this.colorValue = colorValue;\n    this.fill = fill;\n    this.stroke = stroke;\n    this.sumSize = sumSize;\n    this.depth = depth;\n    this.parent = parent;\n    this.children = children;\n    this.midPoint = { x: 0, y: 0 };\n  }\n  contains(other) {\n    let current = other;\n    while (current != null && current.index >= this.index) {\n      if (current === this) {\n        return true;\n      }\n      current = current.parent;\n    }\n    return false;\n  }\n  walk(callback2, order = _HierarchyNode.Walk.PreOrder) {\n    if (order === _HierarchyNode.Walk.PreOrder) {\n      callback2(this);\n    }\n    this.children.forEach((child) => {\n      child.walk(callback2, order);\n    });\n    if (order === _HierarchyNode.Walk.PostOrder) {\n      callback2(this);\n    }\n  }\n  *[Symbol.iterator]() {\n    yield this;\n    for (const child of this.children) {\n      yield* child;\n    }\n  }\n};\n_HierarchyNode.Walk = {\n  PreOrder: 0,\n  PostOrder: 1\n};\nvar HierarchyNode = _HierarchyNode;\nvar HierarchySeries = class extends Series {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      pickModes: [1 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */],\n      contentGroupVirtual: false\n    });\n    this.rootNode = new HierarchyNode(\n      this,\n      0,\n      void 0,\n      0,\n      void 0,\n      void 0,\n      void 0,\n      0,\n      void 0,\n      void 0,\n      []\n    );\n    this.colorDomain = [0, 0];\n    this.maxDepth = 0;\n    this.focusPath = [];\n    this.animationState = new StateMachine(\n      \"empty\",\n      {\n        empty: {\n          update: {\n            target: \"ready\",\n            action: (data) => this.animateEmptyUpdateReady(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\"\n        },\n        ready: {\n          updateData: \"waiting\",\n          clear: \"clearing\",\n          highlight: (data) => this.animateReadyHighlight(data),\n          resize: (data) => this.animateReadyResize(data),\n          reset: \"empty\",\n          skip: \"ready\"\n        },\n        waiting: {\n          update: {\n            target: \"ready\",\n            action: (data) => this.animateWaitingUpdateReady(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\"\n        },\n        clearing: {\n          update: {\n            target: \"empty\",\n            action: (data) => this.animateClearingUpdateEmpty(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\"\n        }\n      },\n      () => this.checkProcessedDataAnimatable()\n    );\n  }\n  resetAnimation(phase) {\n    if (phase === \"initial\") {\n      this.animationState.transition(\"reset\");\n    } else if (phase === \"ready\") {\n      this.animationState.transition(\"skip\");\n    }\n  }\n  async processData() {\n    const { childrenKey, sizeKey, colorKey, fills, strokes, colorRange } = this.properties;\n    let index = 0;\n    const getIndex = () => {\n      index += 1;\n      return index;\n    };\n    let maxDepth = 0;\n    let minColor = Infinity;\n    let maxColor = -Infinity;\n    const colors = new Array((this.data?.length ?? 0) + 1).fill(void 0);\n    const createNode = (datum, parent) => {\n      const nodeIndex = getIndex();\n      const depth = parent.depth != null ? parent.depth + 1 : 0;\n      const children = childrenKey != null ? datum[childrenKey] : void 0;\n      const isLeaf = children == null || children.length === 0;\n      let size = sizeKey != null ? datum[sizeKey] : void 0;\n      if (Number.isFinite(size)) {\n        size = Math.max(size, 0);\n      } else {\n        size = isLeaf ? 1 : 0;\n      }\n      const sumSize = size;\n      maxDepth = Math.max(maxDepth, depth);\n      const color = colorKey != null ? datum[colorKey] : void 0;\n      if (typeof color === \"number\") {\n        colors[nodeIndex] = color;\n        minColor = Math.min(minColor, color);\n        maxColor = Math.max(maxColor, color);\n      }\n      return appendChildren(\n        new HierarchyNode(\n          this,\n          nodeIndex,\n          datum,\n          size,\n          color,\n          void 0,\n          void 0,\n          sumSize,\n          depth,\n          parent,\n          []\n        ),\n        children\n      );\n    };\n    const appendChildren = (node, data) => {\n      data?.forEach((datum) => {\n        const child = createNode(datum, node);\n        node.children.push(child);\n        node.sumSize += child.sumSize;\n      });\n      return node;\n    };\n    const rootNode = appendChildren(\n      new HierarchyNode(\n        this,\n        0,\n        void 0,\n        0,\n        void 0,\n        void 0,\n        void 0,\n        0,\n        void 0,\n        void 0,\n        []\n      ),\n      this.data\n    );\n    const colorDomain = [minColor, maxColor];\n    let colorScale;\n    if (colorRange != null && Number.isFinite(minColor) && Number.isFinite(maxColor)) {\n      colorScale = new ColorScale();\n      colorScale.domain = colorDomain;\n      colorScale.range = colorRange;\n      colorScale.update();\n    }\n    rootNode.children.forEach((child, childIndex) => {\n      child.walk((node) => {\n        let fill;\n        const color = colors[node.index];\n        if (color != null) {\n          fill = colorScale?.convert(color);\n        }\n        fill ?? (fill = fills?.[childIndex % fills.length]);\n        node.fill = fill;\n        node.stroke = colorScale == null ? strokes?.[childIndex % strokes.length] : \"rgba(0, 0, 0, 0.2)\";\n      });\n    });\n    this.rootNode = rootNode;\n    this.maxDepth = maxDepth;\n    this.colorDomain = colorDomain;\n    this.focusPath = [{ nodeDatum: this.rootNode, childIndex: 0 }];\n  }\n  async update({ seriesRect }) {\n    await this.updateSelections();\n    await this.updateNodes();\n    const animationData = this.getAnimationData();\n    const resize = this.checkResize(seriesRect);\n    if (resize) {\n      this.animationState.transition(\"resize\", animationData);\n    }\n    this.animationState.transition(\"update\", animationData);\n  }\n  resetAllAnimation(data) {\n    const datum = this.animationResetFns?.datum;\n    this.ctx.animationManager.stopByAnimationGroupId(this.id);\n    if (datum != null) {\n      resetMotion(data.datumSelections, datum);\n    }\n  }\n  animateEmptyUpdateReady(data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation(data);\n  }\n  animateWaitingUpdateReady(data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation(data);\n  }\n  animateReadyHighlight(data) {\n    const datum = this.animationResetFns?.datum;\n    if (datum != null) {\n      resetMotion([data], datum);\n    }\n  }\n  animateReadyResize(data) {\n    this.resetAllAnimation(data);\n  }\n  animateClearingUpdateEmpty(data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation(data);\n  }\n  animationTransitionClear() {\n    this.animationState.transition(\"clear\", this.getAnimationData());\n  }\n  getAnimationData() {\n    const animationData = {\n      datumSelections: [this.groupSelection]\n    };\n    return animationData;\n  }\n  isProcessedDataAnimatable() {\n    return true;\n  }\n  checkProcessedDataAnimatable() {\n    if (!this.isProcessedDataAnimatable()) {\n      this.ctx.animationManager.skipCurrentBatch();\n    }\n  }\n  getLabelData() {\n    return [];\n  }\n  getSeriesDomain() {\n    return [NaN, NaN];\n  }\n  getLegendData(legendType) {\n    const { colorKey, colorName, colorRange, visible } = this.properties;\n    return legendType === \"gradient\" && colorKey != null && colorRange != null ? [\n      {\n        legendType: \"gradient\",\n        enabled: visible,\n        seriesId: this.id,\n        colorName,\n        colorRange,\n        colorDomain: this.colorDomain\n      }\n    ] : [];\n  }\n  getDatumIdFromData(node) {\n    return `${node.index}`;\n  }\n  getDatumId(node) {\n    return this.getDatumIdFromData(node);\n  }\n  pickFocus(opts) {\n    if (this.rootNode.children.length === 0)\n      return void 0;\n    if (this.focusPath.length === 0) {\n      Logger.error(\"this.focusPath should not be empty\");\n    }\n    const { datumIndexDelta: childDelta, otherIndexDelta: depthDelta } = opts;\n    const { focusPath: path } = this;\n    const depth = path.length - 2;\n    if (depthDelta !== 0 || path.length === 1) {\n      const targetDepth = Math.max(0, depth + depthDelta);\n      if (path[targetDepth + 1] !== void 0) {\n        path.length = targetDepth + 2;\n        return this.computeFocusOutputs(path[targetDepth + 1]);\n      } else {\n        let deepest = path[path.length - 1];\n        while (deepest.nodeDatum.children.length > 0 && (deepest.nodeDatum.depth ?? -1) < targetDepth) {\n          const nextDeepest = { nodeDatum: deepest.nodeDatum.children[0], childIndex: 0 };\n          path.push(nextDeepest);\n          deepest = nextDeepest;\n        }\n        return this.computeFocusOutputs(deepest);\n      }\n    } else if (childDelta !== 0) {\n      const targetChild = path[depth + 1].childIndex + childDelta;\n      const currentParent = path[depth].nodeDatum;\n      const childCount = currentParent?.children?.length;\n      if (childCount !== void 0) {\n        const newChild = clamp(0, targetChild, childCount - 1);\n        const newFocus = { nodeDatum: currentParent.children[newChild], childIndex: newChild };\n        path[depth + 1] = newFocus;\n        path.length = depth + 2;\n        return this.computeFocusOutputs(newFocus);\n      }\n    } else {\n      return this.computeFocusOutputs(path[path.length - 1]);\n    }\n  }\n  getDatumAriaText(datum, description) {\n    if (!(datum instanceof HierarchyNode)) {\n      Logger.error(`datum is not HierarchyNode: ${datum}`);\n      return;\n    }\n    return this.ctx.localeManager.t(\"ariaAnnounceHierarchyDatum\", {\n      level: (datum.depth ?? -1) + 1,\n      count: datum.children.length,\n      description\n    });\n  }\n  computeFocusOutputs({ nodeDatum, childIndex }) {\n    const bounds = this.computeFocusBounds(nodeDatum);\n    if (bounds) {\n      return {\n        datum: nodeDatum,\n        datumIndex: childIndex,\n        otherIndex: nodeDatum.depth,\n        bounds,\n        showFocusBox: true\n      };\n    }\n    return void 0;\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/hierarchy/hierarchySeriesProperties.ts\nvar HierarchySeriesProperties = class extends SeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.childrenKey = \"children\";\n    this.fills = Object.values(DEFAULT_FILLS);\n    this.strokes = Object.values(DEFAULT_STROKES);\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], HierarchySeriesProperties.prototype, \"childrenKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], HierarchySeriesProperties.prototype, \"sizeKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], HierarchySeriesProperties.prototype, \"colorKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], HierarchySeriesProperties.prototype, \"colorName\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], HierarchySeriesProperties.prototype, \"fills\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], HierarchySeriesProperties.prototype, \"strokes\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY, { optional: true })\n], HierarchySeriesProperties.prototype, \"colorRange\", 2);\n\n// packages/ag-charts-community/src/chart/series/topology/lonLatBbox.ts\nvar LonLatBBox = class {\n  constructor(lon0, lat0, lon1, lat1) {\n    this.lon0 = lon0;\n    this.lat0 = lat0;\n    this.lon1 = lon1;\n    this.lat1 = lat1;\n  }\n  merge(other) {\n    this.lon0 = Math.min(this.lon0, other.lon0);\n    this.lat0 = Math.min(this.lat0, other.lat0);\n    this.lon1 = Math.max(this.lon1, other.lon1);\n    this.lat1 = Math.max(this.lat1, other.lat1);\n  }\n};\n\n// packages/ag-charts-community/src/util/tempUtils.ts\nfunction createIdsGenerator() {\n  const idsCounter = /* @__PURE__ */ new Map();\n  return (name) => {\n    const counter = idsCounter.get(name);\n    if (counter) {\n      idsCounter.set(name, counter + 1);\n      return `${name}${counter}`;\n    }\n    idsCounter.set(name, 1);\n    return name;\n  };\n}\n\n// packages/ag-charts-community/src/chart/axis/axisTicks.ts\nvar _AxisTicks = class _AxisTicks {\n  constructor() {\n    this.id = createId(this);\n    this.axisGroup = new TranslatableGroup({ name: `${this.id}-AxisTicks`, zIndex: 2 /* AXIS */ });\n    this.labelSelection = Selection.select(this.axisGroup, Text);\n    this.interval = new AxisInterval();\n    this.label = new AxisLabel();\n    this.scale = new LinearScale();\n    this.position = \"bottom\";\n    this.translationX = 0;\n    this.translationY = 0;\n    this.padding = 0;\n  }\n  attachAxis(axisNode) {\n    axisNode.appendChild(this.axisGroup);\n  }\n  calculateLayout() {\n    this.scale.interval = this.interval.step;\n    const boxes = [];\n    const tickData = this.generateTicks();\n    const { translationX, translationY } = this;\n    this.labelSelection.update(\n      tickData.ticks.map((d) => this.createLabelDatum(d)),\n      void 0,\n      (datum) => datum.tickId\n    );\n    this.labelSelection.each((node, datum) => {\n      node.setProperties(datum);\n      if (datum.visible) {\n        boxes.push(node.getBBox());\n      }\n    });\n    this.axisGroup.setProperties({ translationX, translationY });\n    return BBox.merge(boxes);\n  }\n  getLabelParams(datum) {\n    const { padding } = this;\n    const { translate } = datum;\n    switch (this.position) {\n      case \"top\":\n      case \"bottom\":\n        return {\n          x: translate,\n          y: padding,\n          textAlign: \"center\",\n          textBaseline: \"top\"\n        };\n      case \"left\":\n      case \"right\":\n        return {\n          x: padding,\n          y: translate,\n          textAlign: \"start\",\n          textBaseline: \"middle\"\n        };\n    }\n  }\n  inRange(x, tolerance = 1e-3) {\n    const [min, max] = findMinMax(this.scale.range);\n    return x >= min - tolerance && x <= max + tolerance;\n  }\n  createLabelDatum(datum) {\n    const { x, y, textBaseline, textAlign } = this.getLabelParams(datum);\n    return {\n      visible: Boolean(datum.tickLabel),\n      tickId: datum.tickId,\n      fill: this.label.color,\n      fontFamily: this.label.fontFamily,\n      fontSize: this.label.fontSize,\n      fontStyle: this.label.fontStyle,\n      fontWeight: this.label.fontWeight,\n      rotation: 0,\n      rotationCenterX: 0,\n      text: datum.tickLabel,\n      textAlign,\n      textBaseline,\n      x,\n      y\n    };\n  }\n  generateTicks() {\n    const { minSpacing, maxSpacing } = this.interval;\n    const extentWithBleed = round(findRangeExtent(this.scale.range), 2);\n    const { maxTickCount, minTickCount, tickCount } = estimateTickCount(\n      extentWithBleed,\n      minSpacing,\n      maxSpacing,\n      _AxisTicks.DefaultTickCount,\n      _AxisTicks.DefaultMinSpacing\n    );\n    if (tickCount) {\n      this.scale.tickCount = tickCount;\n      this.scale.minTickCount = minTickCount;\n      this.scale.maxTickCount = maxTickCount;\n    }\n    const tickData = this.getTicksData();\n    if (this.position === \"bottom\" || this.position === \"top\") {\n      const measurer = CachedTextMeasurerPool.getMeasurer({ font: this.label });\n      const domain = this.scale.getDomain();\n      const reversed = domain[0] > domain[1];\n      const direction = reversed ? -1 : 1;\n      let lastTickPosition = -Infinity * direction;\n      tickData.ticks = tickData.ticks.filter((data) => {\n        if (Math.sign(data.translate - lastTickPosition) !== direction)\n          return false;\n        lastTickPosition = data.translate + measurer.textWidth(data.tickLabel, true) * direction;\n        return true;\n      });\n    }\n    return tickData;\n  }\n  getTicksData() {\n    const ticks = [];\n    const rawTicks = this.scale.ticks();\n    const fractionDigits = rawTicks.reduce(\n      (max, tick) => Math.max(max, typeof tick === \"number\" ? countFractionDigits(tick) : 0),\n      0\n    );\n    const idGenerator = createIdsGenerator();\n    const labelFormatter = this.label.format ? this.scale.tickFormat({ ticks: rawTicks, specifier: this.label.format }) : (x) => isNumber(x) ? x.toFixed(fractionDigits) : String(x);\n    for (let index = 0; index < rawTicks.length; index++) {\n      const tick = rawTicks[index];\n      const translate = this.scale.convert(tick);\n      if (!this.inRange(translate))\n        continue;\n      const tickLabel = this.label.formatter?.({ value: tick, index, fractionDigits }) ?? labelFormatter(tick);\n      const tickId = idGenerator(tickLabel);\n      ticks.push({ tick, tickId, tickLabel, translate });\n    }\n    return { rawTicks, fractionDigits, ticks };\n  }\n};\n_AxisTicks.DefaultTickCount = 5;\n_AxisTicks.DefaultMinSpacing = 50;\nvar AxisTicks = _AxisTicks;\n\n// packages/ag-charts-community/src/chart/legendDatum.ts\nvar __FORCE_MODULE_DETECTION = 0;\n\n// packages/ag-charts-community/src/dom/elements.ts\nfunction createButton(options, attrs) {\n  const button = createElement(\"button\", getClassName(\"ag-charts-input ag-charts-button\", attrs));\n  if (options.label !== void 0) {\n    button.append(options.label);\n  } else {\n    button.append(createIcon(options.icon));\n    button.ariaLabel = options.altText;\n  }\n  button.addEventListener(\"click\", options.onPress);\n  setAttributes(button, attrs);\n  return button;\n}\nfunction createCheckbox(options, attrs) {\n  const checkbox = createElement(\"input\", getClassName(\"ag-charts-input ag-charts-checkbox\", attrs));\n  checkbox.type = \"checkbox\";\n  checkbox.checked = options.checked;\n  checkbox.addEventListener(\"change\", (event) => options.onChange(checkbox.checked, event));\n  checkbox.addEventListener(\"keydown\", (event) => {\n    if (isButtonClickEvent(event)) {\n      event.preventDefault();\n      checkbox.click();\n    }\n  });\n  setAttributes(checkbox, attrs);\n  return checkbox;\n}\nfunction createSelect(options, attrs) {\n  const select = createElement(\"select\", getClassName(\"ag-charts-input ag-charts-select\", attrs));\n  select.append(\n    ...options.options.map((option) => {\n      const optionEl = createElement(\"option\");\n      optionEl.value = option.value;\n      optionEl.textContent = option.label;\n      return optionEl;\n    })\n  );\n  setAttribute(select, \"data-preventdefault\", false);\n  select.value = options.value;\n  select.addEventListener(\"change\", (event) => options.onChange(select.value, event));\n  setAttributes(select, attrs);\n  return select;\n}\nfunction createTextArea(options, attrs) {\n  const textArea = createElement(\"textarea\", getClassName(\"ag-charts-input ag-charts-textarea\", attrs));\n  textArea.value = options.value;\n  textArea.addEventListener(\"input\", (event) => options.onChange(textArea.value, event));\n  setAttributes(textArea, attrs);\n  return textArea;\n}\nfunction createIcon(icon) {\n  const el = createElement(\"span\", `ag-charts-icon ag-charts-icon-${icon}`);\n  setAttribute(el, \"aria-hidden\", true);\n  return el;\n}\nfunction getClassName(baseClass, attrs) {\n  if (attrs == null)\n    return baseClass;\n  return `${baseClass} ${attrs.class}`;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9hZy1jaGFydHMtY29tbXVuaXR5L2Rpc3QvcGFja2FnZS9tYWluLmVzbS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFFBQVE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixNQUFNO0FBQ25DO0FBQ0EsK0JBQStCLFlBQVk7QUFDM0M7QUFDQSxrREFBa0QsUUFBUTtBQUMxRDtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0EsdUNBQXVDLE1BQU0sWUFBWSxNQUFNLHFCQUFxQixZQUFZO0FBQ2hHO0FBQ0EsMENBQTBDLE9BQU8sS0FBSyxNQUFNLFNBQVMsTUFBTSxLQUFLLEdBQUcsSUFBSSxVQUFVLEVBQUUsS0FBSztBQUN4RztBQUNBLDBDQUEwQyxPQUFPLEtBQUssTUFBTSxJQUFJLFlBQVk7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsTUFBTSxnQkFBZ0IsTUFBTSxjQUFjLE1BQU07QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixJQUFJLGVBQWUsSUFBSTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVSxHQUFHLE9BQU87QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx1QkFBdUI7QUFDakMsbUJBQW1CO0FBQ25CO0FBQ0EsWUFBWSw2Q0FBNkM7QUFDekQ7QUFDQSxlQUFlO0FBQ2YsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQix3Q0FBd0MsaUJBQWlCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsV0FBVztBQUN6QywrQkFBK0IsWUFBWTtBQUMzQyw2QkFBNkIsT0FBTztBQUNwQyw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZCQUE2QixHQUFHLE1BQU07QUFDbEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNDQUFzQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVDQUF1QztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdUNBQXVDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtCQUFrQjtBQUNuQjtBQUNBO0FBQ0EsNEJBQTRCLElBQUk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0oseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsV0FBVztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHlCQUF5QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHFDQUFxQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDJCQUEyQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwyQkFBMkI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMscUJBQXFCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsb0JBQW9CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsV0FBVztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFVBQVU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEtBQUssRUFBRSw2Q0FBNkMsRUFBRSw2Q0FBNkM7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFDQUFxQyxFQUFFLE9BQU87QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOLDBCQUEwQixlQUFlLEVBQUUsd0JBQXdCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGNBQWM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4QkFBOEI7QUFDeEMsWUFBWSw2Q0FBNkM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0Esc0JBQXNCLFVBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3REFBd0Q7QUFDcEU7QUFDQTtBQUNBLDhDQUE4QyxxRUFBcUUsa0NBQWtDLDREQUE0RDtBQUNqTixNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHdDQUF3Qyw0REFBNEQ7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLDhDQUE4Qyw4REFBOEQ7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLCtCQUErQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsS0FBSztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw0QkFBNEI7QUFDcEQ7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDRDQUE0QztBQUNwRjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBLHlCQUF5QiwwREFBMEQ7QUFDbkY7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EseUJBQXlCLHFEQUFxRDtBQUM5RTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxZQUFZLDRDQUE0QztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxpQkFBaUI7QUFDM0I7QUFDQSxjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixLQUFLLEdBQUcsNkJBQTZCLEdBQUcscUNBQXFDO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw4REFBOEQ7QUFDdEY7QUFDQTtBQUNBLHVCQUF1QixXQUFXO0FBQ2xDO0FBQ0E7QUFDQSx1QkFBdUIsWUFBWTtBQUNuQztBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0Esd0JBQXdCLFdBQVc7QUFDbkM7QUFDQSxzQkFBc0IsV0FBVztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdEQUF3RDtBQUNwRTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVDQUF1QztBQUNuRCw0Q0FBNEMscUNBQXFDO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMEJBQTBCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0QkFBNEI7QUFDeEMsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsYUFBYTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDhDQUE4QztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBLHlCQUF5QiwwREFBMEQ7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsYUFBYTtBQUN0QixZQUFZLFlBQVk7QUFDeEIsVUFBVSxhQUFhO0FBQ3ZCLFdBQVcsWUFBWTtBQUN2QixnQkFBZ0IsY0FBYztBQUM5QixpQkFBaUIsYUFBYTtBQUM5QixtQkFBbUIsYUFBYTtBQUNoQyxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsWUFBWTtBQUN2RDtBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDLGNBQWMsdUNBQXVDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkRBQTZEO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlO0FBQ2YsTUFBTTtBQUNOLFVBQVUsaUNBQWlDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMERBQTBEO0FBQzVFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMsVUFBVSxzRUFBc0U7QUFDaEY7QUFDQSw0REFBNEQsaUJBQWlCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxxQ0FBcUMsRUFBRSxTQUFTO0FBQ25GO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1QkFBdUIsRUFBRSxTQUFTO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxhQUFhLE9BQU8sbUJBQW1CO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGFBQWEsT0FBTyxtQkFBbUIseUJBQXlCLGFBQWEseUJBQXlCLGlCQUFpQjtBQUNuSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOLG9DQUFvQyxhQUFhLFFBQVEsa0JBQWtCLEdBQUcsbUJBQW1CLGNBQWM7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx5RUFBeUU7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUIsWUFBWSxhQUFhO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix1QkFBdUIsSUFBSSxZQUFZLEtBQUssT0FBTztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsYUFBYSxFQUFFLG1CQUFtQjtBQUMxRDtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTixvQkFBb0IsYUFBYSxFQUFFLG9CQUFvQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYSxFQUFFLFdBQVc7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsYUFBYSxFQUFFLGlCQUFpQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QixJQUFJLFlBQVkseUJBQXlCLGtCQUFrQjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUIsSUFBSSxZQUFZLEtBQUssT0FBTyxLQUFLLGtCQUFrQjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLElBQUk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsaUJBQWlCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtCQUErQjtBQUMzQztBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsd0JBQXdCO0FBQ2xFLGNBQWMsYUFBYTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUSwyREFBMkQ7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osMkNBQTJDLHNCQUFzQjtBQUNqRSx3QkFBd0IsUUFBUSxvQkFBb0IsZ0JBQWdCLElBQUksTUFBTTtBQUM5RSwrQkFBK0IsTUFBTTtBQUNyQywrQ0FBK0Msc0JBQXNCLFlBQVksUUFBUTtBQUN6RjtBQUNBLGFBQWEsVUFBVSxFQUFFLFlBQVk7QUFDckMsbUNBQW1DLFVBQVUsRUFBRSxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGtEQUFrRDtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGlCQUFpQixNQUFNLGdCQUFnQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEIsK0RBQStELHNCQUFzQixHQUFHLEtBQUs7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHNCQUFzQixRQUFRLFNBQVM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbURBQW1EO0FBQy9ELFlBQVkseURBQXlEO0FBQ3JFLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnQkFBZ0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxXQUFXO0FBQy9DO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdEQUF3RDtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBCQUEwQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQscURBQXFEO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLEtBQUs7QUFDckIsOEVBQThFLGlDQUFpQztBQUMvRztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBbUI7QUFDakM7QUFDQTtBQUNBLFVBQVUsNkRBQTZEO0FBQ3ZFLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdCQUFnQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0JBQWdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixnQkFBZ0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnQkFBZ0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGdCQUFnQjtBQUM5QztBQUNBO0FBQ0EsOEJBQThCLGdCQUFnQjtBQUM5QztBQUNBO0FBQ0EsOEJBQThCLGdCQUFnQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUSxPQUFPLElBQUksNkJBQTZCO0FBQzVELFlBQVksMkNBQTJDO0FBQ3ZELFlBQVksUUFBUTtBQUNwQixVQUFVLHdCQUF3QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBLGNBQWMsdUNBQXVDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwwRUFBMEU7QUFDbEc7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG1CQUFtQjtBQUN0RDtBQUNBLG9DQUFvQywwQ0FBMEM7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMEJBQTBCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUJBQXlCO0FBQ3JDO0FBQ0E7QUFDQSxjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBDQUEwQztBQUN0RDtBQUNBO0FBQ0EsY0FBYyw2REFBNkQ7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnQkFBZ0I7QUFDM0M7QUFDQTtBQUNBLHlCQUF5QixnQkFBZ0I7QUFDekM7QUFDQTtBQUNBLDBCQUEwQixnQkFBZ0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBLFVBQVUsb0RBQW9EO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsdURBQXVEO0FBQ2pFO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakI7QUFDQSxhQUFhLE1BQU07QUFDbkIsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxpQkFBaUI7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msa0JBQWtCO0FBQ3BEO0FBQ0E7QUFDQSxzQkFBc0IseUJBQXlCLFlBQVksZ0JBQWdCO0FBQzNFO0FBQ0EsSUFBSTtBQUNKLDBCQUEwQixrQkFBa0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUyxxREFBcUQ7QUFDOUQsWUFBWSxvREFBb0Q7QUFDaEUsVUFBVSxxREFBcUQ7QUFDL0QsV0FBVyxvREFBb0Q7QUFDL0QsYUFBYSxxREFBcUQ7QUFDbEUsY0FBYyxzREFBc0Q7QUFDcEUsZ0JBQWdCLG9EQUFvRDtBQUNwRSxpQkFBaUIscURBQXFEO0FBQ3RFLFlBQVksb0RBQW9EO0FBQ2hFLGdCQUFnQixvREFBb0Q7QUFDcEUsaUJBQWlCLHFEQUFxRDtBQUN0RSxlQUFlLG9EQUFvRDtBQUNuRSxrQkFBa0IscURBQXFEO0FBQ3ZFLG1CQUFtQixvREFBb0Q7QUFDdkUsc0JBQXNCLHFEQUFxRDtBQUMzRSxvQkFBb0IscURBQXFEO0FBQ3pFLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsU0FBUyxvREFBb0Q7QUFDN0QsWUFBWSxxREFBcUQ7QUFDakUsVUFBVSxxREFBcUQ7QUFDL0QsV0FBVyxvREFBb0Q7QUFDL0QsYUFBYSxzREFBc0Q7QUFDbkUsY0FBYyxxREFBcUQ7QUFDbkUsZ0JBQWdCLHFEQUFxRDtBQUNyRSxpQkFBaUIsb0RBQW9EO0FBQ3JFLFlBQVksb0RBQW9EO0FBQ2hFLGdCQUFnQixvREFBb0Q7QUFDcEUsaUJBQWlCLHFEQUFxRDtBQUN0RSxlQUFlLHFEQUFxRDtBQUNwRSxrQkFBa0Isb0RBQW9EO0FBQ3RFLG1CQUFtQixxREFBcUQ7QUFDeEUsc0JBQXNCLG9EQUFvRDtBQUMxRSxvQkFBb0Isc0RBQXNEO0FBQzFFLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxVQUFVLCtDQUErQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywrQkFBK0I7QUFDakU7QUFDQSxhQUFhO0FBQ2IsSUFBSTtBQUNKLGFBQWE7QUFDYjtBQUNBO0FBQ0EsbUNBQW1DLHVDQUF1QztBQUMxRTtBQUNBLGFBQWE7QUFDYixJQUFJO0FBQ0osYUFBYTtBQUNiO0FBQ0E7QUFDQSxvQ0FBb0MsK0JBQStCO0FBQ25FO0FBQ0EsYUFBYTtBQUNiLElBQUk7QUFDSixhQUFhO0FBQ2I7QUFDQTtBQUNBLHFDQUFxQyx1Q0FBdUM7QUFDNUU7QUFDQSxhQUFhO0FBQ2IsSUFBSTtBQUNKLGFBQWE7QUFDYjtBQUNBO0FBQ0EscUNBQXFDLG9CQUFvQjtBQUN6RCxXQUFXO0FBQ1g7QUFDQSx1Q0FBdUMsaUNBQWlDO0FBQ3hFO0FBQ0EsYUFBYTtBQUNiLElBQUk7QUFDSixhQUFhO0FBQ2I7QUFDQTtBQUNBLDBDQUEwQyxpQ0FBaUM7QUFDM0U7QUFDQSxhQUFhO0FBQ2IsSUFBSTtBQUNKLGFBQWE7QUFDYjtBQUNBO0FBQ0Esd0NBQXdDLCtCQUErQjtBQUN2RTtBQUNBLGFBQWE7QUFDYixJQUFJO0FBQ0osYUFBYTtBQUNiO0FBQ0E7QUFDQSwyQ0FBMkMsdUNBQXVDO0FBQ2xGO0FBQ0EsYUFBYTtBQUNiLElBQUk7QUFDSixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUyw2QkFBNkI7QUFDdEMsWUFBWSxnQ0FBZ0M7QUFDNUMsVUFBVSw4QkFBOEI7QUFDeEMsV0FBVywrQkFBK0I7QUFDMUMsYUFBYSxrQ0FBa0M7QUFDL0MsY0FBYyxtQ0FBbUM7QUFDakQsZ0JBQWdCLHFDQUFxQztBQUNyRCxpQkFBaUIsc0NBQXNDO0FBQ3ZELFlBQVksZ0NBQWdDO0FBQzVDLGdCQUFnQiw4QkFBOEI7QUFDOUMsaUJBQWlCLCtCQUErQjtBQUNoRCxlQUFlLDZCQUE2QjtBQUM1QyxrQkFBa0IsZ0NBQWdDO0FBQ2xELG1CQUFtQixrQ0FBa0M7QUFDckQsc0JBQXNCLHFDQUFxQztBQUMzRCxvQkFBb0IsbUNBQW1DO0FBQ3ZELHVCQUF1QjtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSx5QkFBeUIsZ0JBQWdCO0FBQ3pDO0FBQ0E7QUFDQSwwQkFBMEIsZ0JBQWdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQSx1Q0FBdUMsZ0JBQWdCO0FBQ3ZEO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhEQUE4RDtBQUMzRixrQ0FBa0MsK0RBQStEO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkRBQTJEO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msc0JBQXNCO0FBQzVELDZCQUE2QixzQkFBc0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrQkFBK0I7QUFDM0MsWUFBWSx1QkFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksd0JBQXdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUIsSUFBSTtBQUNqRCxlQUFlLG1EQUFtRDtBQUNsRTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFlBQVksc0NBQXNDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw2QkFBNkI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNDQUFzQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QixJQUFJO0FBQ2pELGVBQWUsbURBQW1EO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZCQUE2QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBLDJEQUEyRCxnQkFBZ0I7QUFDM0U7QUFDQTtBQUNBLGtFQUFrRSxXQUFXO0FBQzdFO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSwrQ0FBK0MsZ0JBQWdCO0FBQy9EO0FBQ0E7QUFDQSwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQSwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdCQUFnQjtBQUM1QztBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdCQUFnQjtBQUN6QztBQUNBO0FBQ0EsMEJBQTBCLGdCQUFnQjtBQUMxQztBQUNBO0FBQ0EsNkJBQTZCLFFBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdCQUFnQjtBQUMzQztBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0JBQWdCO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdCQUFnQjtBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBLDhCQUE4QixnQkFBZ0I7QUFDOUM7QUFDQTtBQUNBLHlCQUF5QixnQkFBZ0I7QUFDekM7QUFDQTtBQUNBLDBCQUEwQixnQkFBZ0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnQkFBZ0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxlQUFlLGtFQUFrRTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx1Q0FBdUM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsY0FBYyx1Q0FBdUM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtDQUFrQztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFNBQVMsUUFBUSw4QkFBOEI7QUFDN0Ysc0VBQXNFLFNBQVMsUUFBUSxhQUFhO0FBQ3BHO0FBQ0Esa0JBQWtCLFNBQVMsUUFBUSx5Q0FBeUM7QUFDNUU7QUFDQTtBQUNBLGtCQUFrQixTQUFTLFFBQVEsMENBQTBDO0FBQzdFO0FBQ0EsbURBQW1ELFNBQVMsUUFBUSxjQUFjO0FBQ2xGLGtDQUFrQyxTQUFTLFFBQVEsOENBQThDO0FBQ2pHLDhDQUE4QyxTQUFTLFFBQVEsYUFBYTtBQUM1RTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1QkFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZDQUE2QztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsMEJBQTBCO0FBQ3hFO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLHdEQUF3RCxRQUFRO0FBQ2hFO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNEQUFzRDtBQUNsRTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdFQUF3RTtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDJDQUEyQztBQUNsRSw0QkFBNEIscURBQXFEO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLDJEQUEyRDtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUIsWUFBWSxvQ0FBb0M7QUFDaEQ7QUFDQTtBQUNBLDhCQUE4QixtREFBbUQ7QUFDakY7QUFDQTtBQUNBLFlBQVksc0RBQXNEO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZLHNFQUFzRTtBQUNsRjtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1Q0FBdUM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGtCQUFrQix3QkFBd0I7QUFDMUMsZUFBZTtBQUNmLE1BQU07QUFDTjtBQUNBLFlBQVkseUVBQXlFO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZLGVBQWUsMkJBQTJCLHdCQUF3QjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyw2Q0FBNkM7QUFDdkYsOERBQThELE1BQU07QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Qsc0JBQXNCO0FBQzVFO0FBQ0EsV0FBVywyQ0FBMkM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFlBQVksdUJBQXVCO0FBQ25DLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxzQ0FBc0MsOENBQThDO0FBQ3BGO0FBQ0E7QUFDQSxvQ0FBb0MsOENBQThDO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywwQ0FBMEM7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCLFlBQVksdUNBQXVDO0FBQ25ELFlBQVksK0NBQStDLDJCQUEyQix3QkFBd0I7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsOENBQThDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDBCQUEwQjtBQUMzQztBQUNBO0FBQ0EsY0FBYyxpQ0FBaUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsWUFBWSw2Q0FBNkM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTyxHQUFHLE1BQU07QUFDcEMsUUFBUTtBQUNSO0FBQ0E7QUFDQSxtQkFBbUIsaUVBQWlFO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFlBQVkseUJBQXlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix3QkFBd0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0RBQW9EO0FBQ2hFLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0EsbUNBQW1DLHNDQUFzQztBQUN6RSw4QkFBOEIsc0NBQXNDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlDQUFpQztBQUM3QyxrQ0FBa0MsMkNBQTJDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQW1CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZLGlEQUFpRDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixNQUFNO0FBQ047QUFDQSw4RUFBOEUscUNBQXFDO0FBQ25ILE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDLDJCQUEyQixrQ0FBa0M7QUFDN0Q7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBLG1DQUFtQyxtQkFBbUI7QUFDdEQsUUFBUTtBQUNSLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9GQUFvRjtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxVQUFVLDZCQUE2QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxnQkFBZ0I7QUFDM0Q7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyw0QkFBNEI7QUFDMUUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwREFBMEQ7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw2Q0FBNkM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsT0FBTztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0JBQWdCO0FBQ3hCLFFBQVEsZ0JBQWdCO0FBQ3hCLFFBQVEsa0JBQWtCO0FBQzFCLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUSxvQkFBb0I7QUFDNUIsUUFBUSxrQkFBa0I7QUFDMUIsUUFBUSxnQkFBZ0I7QUFDeEIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQ0FBa0M7QUFDMUQ7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtDQUFrQztBQUMxRDtBQUNBO0FBQ0Esd0JBQXdCLGtDQUFrQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsTUFBTTtBQUN2QztBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlCQUFpQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLDhDQUE4QztBQUN4RCxnQ0FBZ0MsMkNBQTJDO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBCQUEwQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsdUVBQXVFLGFBQWE7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsUUFBUSxFQUFFLFFBQVEsRUFBRSxZQUFZLEVBQUUsWUFB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Z0JBQWdCO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsK0NBQStDO0FBQ3BGLGlDQUFpQyxvQ0FBb0M7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxjQUFjLGlDQUFpQztBQUMvQyxlQUFlO0FBQ2YsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpQ0FBaUM7QUFDN0MsVUFBVSxtQkFBbUI7QUFDN0I7QUFDQSxZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdDQUFnQztBQUM1QyxVQUFVLGlDQUFpQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsWUFBWSxnQ0FBZ0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsVUFBVSxLQUFLO0FBQ2Y7QUFDQSxnQkFBZ0IsaUNBQWlDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0EsNENBQTRDLE9BQU8sa0JBQWtCLEdBQUc7QUFDeEU7QUFDQTtBQUNBLCtDQUErQyxVQUFVLGtCQUFrQixHQUFHO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsMEJBQTBCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLGVBQWU7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlDQUFpQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsa0NBQWtDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxxRUFBcUUsSUFBSTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxJQUFJO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsY0FBYztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDZDQUE2QztBQUM5RCxpQkFBaUIsNkNBQTZDO0FBQzlELGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLGVBQWU7QUFDckYsb0VBQW9FLGdCQUFnQjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QixZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0NBQW9DO0FBQ2hELHFEQUFxRCxxRUFBcUU7QUFDMUg7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsaURBQWlELGFBQWE7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQ0FBcUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdEQUFnRDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzQkFBc0I7QUFDbEMseUNBQXlDLHVEQUF1RDtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxZQUFZO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Qsa0JBQWtCO0FBQ2xFLGlEQUFpRCxtQkFBbUI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxRQUFRO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlDQUFpQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDRDQUE0QyxnREFBZ0Q7QUFDNUY7QUFD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Q0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNkJBQTZCO0FBQ2pDLElBQUksYUFBYTtBQUNqQixJQUFJLFlBQVk7QUFDaEIsSUFBSSxZQUFZO0FBQ2hCLElBQUksWUFBWTtBQUNoQixJQUFJLFlBQVk7QUFDaEIsSUFBSSxhQUFhO0FBQ2pCLElBQUksWUFBWTtBQUNoQixJQUFJLGFBQWE7QUFDakIsSUFBSSxhQUFhO0FBQ2pCLElBQUksYUFBYTtBQUNqQixJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZ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QUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixNQUFNO0FBQ047QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsYUFBYTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsb0JBQW9CO0FBQ2xDLGNBQWMsMkNBQTJDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGFBQWE7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsV0FBVztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCLFlBQVksMkJBQTJCO0FBQ3ZDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkIsWUFBWSwyQkFBMkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsV0FBVztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sb0RBQW9ELGVBQWU7QUFDbkUsb0RBQW9ELGdDQUFnQztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsZ0JBQWdCO0FBQ3pFO0FBQ0E7QUFDQSw0REFBNEQsZ0JBQWdCO0FBQzVFOztBQUVBO0FBQ0EsMEJBQTBCLHdCQUF3QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sVUFBVSxtREFBbUQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpREFBaUQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdEQUFnRDtBQUM1RDtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtCQUErQjtBQUMzQztBQUNBLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1REFBdUQ7QUFDOUU7QUFDQTtBQUNBLFlBQVksaUNBQWlDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnQkFBZ0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0Es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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRCxVQUFVLDhDQUE4QztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakUsVUFBVSwyQkFBMkI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVSxVQUFVO0FBQ3BDLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDhCQUE4QixtQkFBbUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDZDQUE2QztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZUFBZTtBQUM3QixjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdEQUFnRDtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0RBQWdEO0FBQ3RFO0FBQ0E7QUFDQSxzQkFBc0IscURBQXFEO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsd0JBQXdCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxpQkFBaUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0QkFBNEI7QUFDaEQsSUFBSTtBQUNKLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGFBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0MsSUFBSTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxZQUFZO0FBQ2xCLE1BQU0sWUFBWTtBQUNsQixNQUFNO0FBQ047QUFDQTtBQUNBLHVDQUF1QyxJQUFJO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFlBQVk7QUFDbEIsTUFBTSxZQUFZO0FBQ2xCLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxRUFBcUU7QUFDakYsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBLDJCQUEyQixnQkFBZ0I7QUFDM0MseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQSwyQkFBMkIsZ0JBQWdCO0FBQzNDLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDLHlCQUF5Qix1QkFBdUI7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnQkFBZ0I7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSw4QkFBOEIsZ0JBQWdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsd0JBQXdCO0FBQ2xDLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVLDRCQUE0QjtBQUN0QyxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsU0FBUztBQUNuQjtBQUNBLFVBQVUsdUJBQXVCO0FBQ2pDLFVBQVUsdUJBQXVCO0FBQ2pDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsUUFBUTtBQUNSO0FBQ0EsaUJBQWlCO0FBQ2pCLFFBQVE7QUFDUixnQkFBZ0IsZ0JBQWdCO0FBQ2hDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0EsbUJBQW1CLHdDQUF3QztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDZDQUE2QztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaUJBQWlCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlEQUFpRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHdCQUF3QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyxJQUFJO0FBQ3JDLG1CQUFtQjtBQUNuQiwwRUFBMEUsWUFBWSxJQUFJLFlBQVk7QUFDdEc7QUFDQTtBQUNBLGtDQUFrQyxJQUFJO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDBCQUEwQjtBQUNoQyxNQUFNLDBCQUEwQjtBQUNoQyxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDBCQUEwQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esb0VBQW9FLGNBQWM7QUFDbEY7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBLGVBQWU7QUFDZixNQUFNO0FBQ04sZUFBZTtBQUNmLE1BQU07QUFDTixlQUFlO0FBQ2Y7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSw0Q0FBNEMsWUFBWTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTyxVQUFVO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaUJBQWlCO0FBQzNCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxjQUFjLDZCQUE2QjtBQUMzQztBQUNBLG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGdDQUFnQyxtQ0FBbUM7QUFDbkUsVUFBVSxxREFBcUQ7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sVUFBVTtBQUNoQixNQUFNLGVBQWU7QUFDckI7QUFDQTtBQUNBLGVBQWUscUNBQXFDO0FBQ3BELGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsSUFBSTtBQUNuQywrREFBK0QsWUFBWSxJQUFJLFlBQVksSUFBSSxPQUFPO0FBQ3RHO0FBQ0EsZ0NBQWdDLElBQUk7QUFDcEMsK0RBQStELFlBQVksSUFBSSxZQUFZLElBQUksaUJBQWlCO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsMEJBQTBCLHNCQUFzQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EscUNBQXFDLDJCQUEyQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLG9DQUFvQywwQkFBMEI7QUFDOUQsdUJBQXVCLFVBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDBCQUEwQjtBQUNyRSx5QkFBeUIsYUFBYTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZELFVBQVUsa0NBQWtDO0FBQzVDO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUscUNBQXFDO0FBQy9DLFVBQVUsaUNBQWlDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsNERBQTREO0FBQzVELFVBQVUsc0RBQXNEO0FBQ2hFO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNCQUFzQixnQkFBZ0IsT0FBTztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSixvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixVQUFVO0FBQzVCLFFBQVE7QUFDUixrQkFBa0IsU0FBUztBQUMzQixRQUFRO0FBQ1I7QUFDQTtBQUNBLGVBQWU7QUFDZixLQUFLO0FBQ0w7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLE9BQU87QUFDUDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQSx1QkFBdUIsY0FBYztBQUNyQztBQUNBO0FBQ0EsdUJBQXVCLHFCQUFxQjtBQUM1QztBQUNBO0FBQ0EsV0FBVyxnQkFBZ0IsMENBQTBDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx1Q0FBdUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsTUFBTTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLG9CQUFvQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdCQUFnQixJQUFJLGdCQUFnQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw4QkFBOEI7QUFDckQscUJBQXFCLDZCQUE2QjtBQUNsRCxxQkFBcUIsNEJBQTRCO0FBQ2pELElBQUk7QUFDSjtBQUNBLHFCQUFxQiw0QkFBNEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNEJBQTRCO0FBQ25ELHFCQUFxQiw2QkFBNkI7QUFDbEQscUJBQXFCLDhCQUE4QjtBQUNuRCxJQUFJO0FBQ0o7QUFDQSx1QkFBdUIsNEJBQTRCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTyxJQUFJLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxzQkFBc0IsSUFBSSxrQkFBa0I7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsb0VBQW9FO0FBQzdGLHVCQUF1QixvRUFBb0U7QUFDM0YsdUJBQXVCLDBEQUEwRDtBQUNqRixNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDBEQUEwRDtBQUNuRix1QkFBdUIsa0VBQWtFO0FBQ3pGLHVCQUF1QixrRUFBa0U7QUFDekYsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0osdUJBQXVCLDBEQUEwRDtBQUNqRixxQkFBcUIsMERBQTBEO0FBQy9FLHFCQUFxQiwwREFBMEQ7QUFDL0U7QUFDQTtBQUNBO0FBQ0EsVUFBVSxxREFBcUQ7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsc0NBQXNDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDZCQUE2QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw2QkFBNkI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCLDBDQUEwQztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0IsMENBQTBDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU0sZ0ZBQWdGO0FBQ3RGLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTSx1RkFBdUY7QUFDN0YsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxxRUFBcUU7QUFDdEc7QUFDQSxvQ0FBb0MsK0RBQStEO0FBQ25HO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUNBQWlDLHVDQUF1QyxPQUFPO0FBQzNGLFlBQVksMkRBQTJEO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUJBQXlCLDZCQUE2QixnQkFBZ0I7QUFDbEY7QUFDQSwyQkFBMkIsV0FBVztBQUN0Qyw0QkFBNEIsV0FBVztBQUN2QywyQkFBMkIsV0FBVztBQUN0Qyw0QkFBNEIsV0FBVztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RCwwQ0FBMEMsNEJBQTRCO0FBQ3RFLHlFQUF5RSxrQkFBa0I7QUFDM0YsdURBQXVELG9EQUFvRDtBQUMzRywwQ0FBMEMsK0NBQStDO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtREFBbUQ7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwREFBMEQ7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUNBQWlDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkJBQTZCLG9CQUFvQixJQUFJLGNBQWM7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixZQUFZLGdCQUFnQjtBQUM1QixZQUFZLGdCQUFnQjtBQUM1QixZQUFZLGdCQUFnQiw2QkFBNkIsZ0JBQWdCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksd0JBQXdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLGNBQWM7QUFDM0YsZ0JBQWdCLGlEQUFpRDtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUiw0Q0FBNEMsZ0JBQWdCO0FBQzVELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVCQUF1QjtBQUM3QyxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLDZEQUE2RCxTQUFTO0FBQ3RFO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsZ0JBQWdCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsU0FBUztBQUMxQztBQUNBLHNCQUFzQix5QkFBeUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0NBQXdDO0FBQzFELG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFDQUFxQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QyxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDRCQUE0QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0Q0FBNEM7QUFDeEQsWUFBWSw0RkFBNEY7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNkNBQTZDLGdDQUFnQztBQUM3RTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNEJBQTRCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCLFlBQVksNEVBQTRFO0FBQ3hGO0FBQ0EsY0FBYyxrQkFBa0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVksZ0NBQWdDO0FBQzVDLFlBQVksc0NBQXNDO0FBQ2xELFlBQVksc0NBQXNDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyw0QkFBNEI7QUFDbEU7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZLGNBQWM7QUFDMUI7QUFDQSxRQUFRLGtEQUFrRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxRQUFRLHdDQUF3QztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzREFBc0Q7QUFDbEUsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CLFlBQVksMkVBQTJFO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLFlBQVk7QUFDWjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCLHlEQUF5RCxzQ0FBc0M7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVksZ0JBQWdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsd0NBQXdDO0FBQ2hELFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakIsVUFBVSw2Q0FBNkM7QUFDdkQ7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQSxZQUFZLHVDQUF1QztBQUNuRCwyQkFBMkIsOEJBQThCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0RBQWdEO0FBQzFELFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsZUFB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Z0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGVBQWU7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0RBQStEO0FBQzNFLFVBQVUsNkZBQTZGO0FBQ3ZHLFlBQVksdUJBQXVCO0FBQ25DLFlBQVksMkJBQTJCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsb0JBQW9CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLGNBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxjQUFjLG9CQUFvQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlEQUFpRDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZ0JBQWdCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0EsOEJBQThCLGdCQUFnQjtBQUM5QztBQUNBO0FBQ0EsOEJBQThCLGdCQUFnQjtBQUM5QztBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsUUFBUTtBQUN0QyxhQUFhO0FBQ2I7QUFDQSw4QkFBOEIsUUFBUTtBQUN0QyxhQUFhO0FBQ2I7QUFDQSx5Q0FBeUMsZUFBZTtBQUN4RCxVQUFVLGlEQUFpRDtBQUMzRCxVQUFVLGVBQWU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esd0NBQXdDLFVBQVU7QUFDbEQsVUFBVSxpREFBaUQ7QUFDM0QsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVcsU0FBUyxjQUFjLGlCQUFpQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQSxjQUFjLG1DQUFtQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxZQUFZLG9CQUFv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QUN4RDtBQUNBO0FBQ0EsWUFBWSw2Q0FBNkM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIseUJBQXlCO0FBQ3BELFVBQVUsaUJBQWlCO0FBQzNCLFdBQVcsK0JBQStCO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdCQUFnQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBLDhCQUE4QixnQkFBZ0I7QUFDOUM7QUFDQTtBQUNBLDhCQUE4QixnQkFBZ0I7QUFDOUM7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQSxjQUFjLG1DQUFtQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUJBQXlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCwwREFBMEQ7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsNkJBQTZCO0FBQzFGO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGFBQWE7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWSw0Q0FBNEM7QUFDeEQsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsS0FBSztBQUNMO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQywwQkFBMEI7QUFDMUI7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMkJBQTJCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBLEtBQUs7QUFDTCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQywwQkFBMEI7QUFDMUI7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsVUFBVSwwQ0FBMEM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHVDQUF1QztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsYUFBYSxtQkFBbUIsdUJBQXVCO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQ0FBbUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksd0NBQXdDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1QkFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw4Q0FBOEM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNHQUFzRztBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFFBQVEsVUFBVSxpQkFBaUI7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHVCQUF1QjtBQUMzQixJQUFJLGNBQWM7QUFDbEIsSUFBSSxlQUFlO0FBQ25CLElBQUksY0FBYztBQUNsQixJQUFJLGFBQWE7QUFDakIsSUFBSSxlQUFlO0FBQ25CLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywwQkFBMEI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsSUFBSTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxZQUFZO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDZDQUE2QyxZQUFZO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFO0FBQ3pGO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7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O0FBQ0E7QUFDQSx1RUFBdUUsK0NBQStDO0FBQ3RILHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsb0NBQW9DO0FBQ3JGO0FBQ0EsbUJBQW1CLG9DQUFvQztBQUN2RDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLEtBQUs7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXLEVBQUUsWUFBWTtBQUNyQztBQWdCRSIsInNvdXJjZXMiOlsiL1VzZXJzL3Bhd2VsbmllZHp3aWVkei9EZXNrdG9wL3ZvdXktYnVzaW5lc3Mvbm9kZV9tb2R1bGVzL2FnLWNoYXJ0cy1jb21tdW5pdHkvZGlzdC9wYWNrYWdlL21haW4uZXNtLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fZGVjb3JhdGVDbGFzcyA9IChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwga2luZCkgPT4ge1xuICB2YXIgcmVzdWx0ID0ga2luZCA+IDEgPyB2b2lkIDAgOiBraW5kID8gX19nZXRPd25Qcm9wRGVzYyh0YXJnZXQsIGtleSkgOiB0YXJnZXQ7XG4gIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDEsIGRlY29yYXRvcjsgaSA+PSAwOyBpLS0pXG4gICAgaWYgKGRlY29yYXRvciA9IGRlY29yYXRvcnNbaV0pXG4gICAgICByZXN1bHQgPSAoa2luZCA/IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcmVzdWx0KSA6IGRlY29yYXRvcihyZXN1bHQpKSB8fCByZXN1bHQ7XG4gIGlmIChraW5kICYmIHJlc3VsdClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBrZXksIHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtbG9jYWxlL3NyYy9lbi1VUy50c1xudmFyIEFHX0NIQVJUU19MT0NBTEVfRU5fVVMgPSB7XG4gIC8vIFNjcmVlbiByZWFkZXIgYW5ub3VuY2VtZW50IHdoZW4gZm9jdXNpbmcgYW4gaXRlbSBpbiB0aGUgY2hhcnRcbiAgYXJpYUFubm91bmNlSG92ZXJEYXR1bTogXCIke2RhdHVtfVwiLFxuICAvLyBTY3JlZW4gcmVhZGVyIGFubm91bmNlbWVudCB3aGVuIGZvY3VzaW5nIGEgY2hhcnRcbiAgYXJpYUFubm91bmNlQ2hhcnQ6IFwiY2hhcnQsICR7c2VyaWVzQ291bnR9W251bWJlcl0gc2VyaWVzXCIsXG4gIC8vIFNjcmVlbiByZWFkZXIgYW5ub3VuY2VtZW50IHdoZW4gZm9jdXNpbmcgYSBoaWVyYXJjaHkgY2hhcnRcbiAgYXJpYUFubm91bmNlSGllcmFyY2h5Q2hhcnQ6IFwiaGllcmFyY2h5IGNoYXJ0LCAke2NhcHRpb259XCIsXG4gIC8vIFNjcmVlbiByZWFkZXIgYW5ub3VuY2VtZW50IHdoZW4gZm9jdXNpbmcgYSBnYXVnZSBjaGFydFxuICBhcmlhQW5ub3VuY2VHYXVnZUNoYXJ0OiBcImdhdWdlIGNoYXJ0LCAke2NhcHRpb259XCIsXG4gIC8vIFNjcmVlbiByZWFkZXIgYW5ub3VuY2VtZW50IHdoZW4gZm9jdXNpbmcgYW4gaXRlbSBpbiBhIHRyZWVtYXAgb3Igc3VuYnVyc3QgY2hhcnRcbiAgYXJpYUFubm91bmNlSGllcmFyY2h5RGF0dW06IFwibGV2ZWwgJHtsZXZlbH1bbnVtYmVyXSwgJHtjb3VudH1bbnVtYmVyXSBjaGlsZHJlbiwgJHtkZXNjcmlwdGlvbn1cIixcbiAgLy8gU2NyZWVuIHJlYWRlciBhbm5vdW5jZW1lbnQgd2hlbiBmb2N1c2luZyBhIGxpbmsgaW4gYSBTYW5rZXkgb3IgY2hvcmQgY2hhcnRcbiAgYXJpYUFubm91bmNlRmxvd1Byb3BvcnRpb25MaW5rOiBcImxpbmsgJHtpbmRleH0gb2YgJHtjb3VudH0sIGZyb20gJHtmcm9tfSB0byAke3RvfSwgJHtzaXplTmFtZX0gJHtzaXplfVwiLFxuICAvLyBTY3JlZW4gcmVhZGVyIGFubm91bmNlbWVudCB3aGVuIGZvY3VzaW5nIGEgbm9kZSBpbiBhIFNhbmtleSBvciBjaG9yZCBjaGFydFxuICBhcmlhQW5ub3VuY2VGbG93UHJvcG9ydGlvbk5vZGU6IFwibm9kZSAke2luZGV4fSBvZiAke2NvdW50fSwgJHtkZXNjcmlwdGlvbn1cIixcbiAgLy8gU2NyZWVuIHJlYWRlciBkZXNjcmlwdGlvbiBmb3IgbGVnZW5kIGl0ZW1zXG4gIGFyaWFEZXNjcmlwdGlvbkxlZ2VuZEl0ZW06IFwiUHJlc3MgU3BhY2Ugb3IgRW50ZXIgdG8gdG9nZ2xlIHZpc2liaWxpdHlcIixcbiAgLy8gU2NyZWVuIHJlYWRlciB0ZXh0IGZvciBhbm5vdGF0aW9uLW9wdGlvbnMgdG9vbGJhclxuICBhcmlhTGFiZWxBbm5vdGF0aW9uT3B0aW9uc1Rvb2xiYXI6IFwiQW5ub3RhdGlvbiBPcHRpb25zXCIsXG4gIC8vIFNjcmVlbiByZWFkZXIgdGV4dCBmb3IgYW5ub3RhdGlvbi1zZXR0aW5ncyBkaWFsb2dcbiAgYXJpYUxhYmVsQW5ub3RhdGlvblNldHRpbmdzRGlhbG9nOiBcIkFubm90YXRpb24gU2V0dGluZ3NcIixcbiAgLy8gU2NyZWVuIHJlYWRlciB0ZXh0IGZvciB0aGUgY29sb3IgcGlja2VyIGRpYWxvZ1xuICBhcmlhTGFiZWxDb2xvclBpY2tlcjogXCJDb2xvciBwaWNrZXJcIixcbiAgLy8gU2NyZWVuIHJlYWRlciB0ZXh0IGZvciB0aGUgZmluYW5jaWFsIGNoYXJ0cyB0b29sYmFyXG4gIGFyaWFMYWJlbEZpbmFuY2lhbENoYXJ0czogXCJGaW5hbmNpYWwgQ2hhcnRzXCIsXG4gIC8vIFNjcmVlbiByZWFkZXIgdGV4dCBmb3IgdGhlIGxlZ2VuZCB0b29sYmFyXG4gIGFyaWFMYWJlbExlZ2VuZDogXCJMZWdlbmRcIixcbiAgLy8gU2NyZWVuIHJlYWRlciB0ZXh0IGZvciB0aGUgbGVnZW5kIHBhZ2luYXRpb24gYnV0dG9uXG4gIGFyaWFMYWJlbExlZ2VuZFBhZ2luYXRpb246IFwiTGVnZW5kIFBhZ2luYXRpb25cIixcbiAgLy8gU2NyZWVuIHJlYWRlciB0ZXh0IGZvciB0aGUgcHJldmlvdXMgbGVnZW5kIHBhZ2UgYnV0dG9uXG4gIGFyaWFMYWJlbExlZ2VuZFBhZ2VQcmV2aW91czogXCJQcmV2aW91cyBMZWdlbmQgUGFnZVwiLFxuICAvLyBTY3JlZW4gcmVhZGVyIHRleHQgZm9yIHRoZSBuZXh0IGxlZ2VuZCBwYWdlIGJ1dHRvblxuICBhcmlhTGFiZWxMZWdlbmRQYWdlTmV4dDogXCJOZXh0IExlZ2VuZCBQYWdlXCIsXG4gIC8vIFNjcmVlbiByZWFkZXIgdGV4dCBmb3IgdGhlIGFuIGl0ZW0gaW4gdGhlIGxlZ2VuZFxuICBhcmlhTGFiZWxMZWdlbmRJdGVtOiBcIiR7bGFiZWx9LCBMZWdlbmQgaXRlbSAke2luZGV4fVtudW1iZXJdIG9mICR7Y291bnR9W251bWJlcl1cIixcbiAgLy8gU2NyZWVuIHJlYWRlciB0ZXh0IGZvciB0aGUgYW4gdW5rbm93biBpdGVtIGluIHRoZSBsZWdlbmRcbiAgYXJpYUxhYmVsTGVnZW5kSXRlbVVua25vd246IFwiVW5rbm93biBsZWdlbmQgaXRlbVwiLFxuICAvLyBTY3JlZW4gcmVhZGVyIHRleHQgZm9yIHRoZSBuYXZpZ2F0b3IgZWxlbWVudFxuICBhcmlhTGFiZWxOYXZpZ2F0b3I6IFwiTmF2aWdhdG9yXCIsXG4gIC8vIFNjcmVlbiByZWFkZXIgdGV4dCBmb3IgYW4gYWNjZXNzaWJpbGl0eSBjb250cm9sIHRoYXQgY2hhbmdlcyB0aGUgcG9zaXRpb24gb2YgdGhlIG5hdmlnYXRvcidzIHJhbmdlXG4gIGFyaWFMYWJlbE5hdmlnYXRvclJhbmdlOiBcIlJhbmdlXCIsXG4gIC8vIFNjcmVlbiByZWFkZXIgdGV4dCBmb3IgYW4gYWNjZXNzaWJpbGl0eSBjb250cm9sIHRoYXQgY2hhbmdlcyB0aGUgc3RhcnQgb2YgdGhlIG5hdmlnYXRvcidzIHJhbmdlXG4gIGFyaWFMYWJlbE5hdmlnYXRvck1pbmltdW06IFwiTWluaW11bVwiLFxuICAvLyBTY3JlZW4gcmVhZGVyIHRleHQgZm9yIGFuIGFjY2Vzc2liaWxpdHkgY29udHJvbCB0aGF0IGNoYW5nZXMgdGhlIGVuZCBvZiB0aGUgbmF2aWdhdG9yJ3MgcmFuZ2VcbiAgYXJpYUxhYmVsTmF2aWdhdG9yTWF4aW11bTogXCJNYXhpbXVtXCIsXG4gIC8vIFNjcmVlbiByZWFkZXIgdGV4dCBmb3IgcmFuZ2VzIHRvb2xiYXJcbiAgYXJpYUxhYmVsUmFuZ2VzVG9vbGJhcjogXCJSYW5nZXNcIixcbiAgLy8gU2NyZWVuIHJlYWRlciB0ZXh0IGZvciB0aGUgc2V0dGluZ3MgZGlhbG9nIHRhYi1iYXJcbiAgYXJpYUxhYmVsU2V0dGluZ3NUYWJCYXI6IFwiU2V0dGluZ3NcIixcbiAgLy8gU2NyZWVuIHJlYWRlciB0ZXh0IGZvciB6b29tIHRvb2xiYXJcbiAgYXJpYUxhYmVsWm9vbVRvb2xiYXI6IFwiWm9vbVwiLFxuICAvLyBTY3JlZW4gcmVhZGVyIHRleHQgZm9yIHRoZSB2YWx1ZSBvZiB0aGUgbmF2aWdhdG9yJ3MgcmFuZ2VcbiAgYXJpYVZhbHVlUGFuUmFuZ2U6IFwiJHttaW59W3BlcmNlbnRdIHRvICR7bWF4fVtwZXJjZW50XVwiLFxuICAvLyBBbHQtdGV4dCBmb3IgdGhlIHNvbGlkIGxpbmUgZGFzaCBzdHlsZSBtZW51IGl0ZW0gaWNvblxuICBpY29uQWx0VGV4dExpbmVTdHlsZVNvbGlkOiBcIlNvbGlkXCIsXG4gIC8vIEFsdC10ZXh0IGZvciB0aGUgbG9uZy1kYXNoZWQgbGluZSBkYXNoIHN0eWxlIG1lbnUgaXRlbSBpY29uXG4gIGljb25BbHRUZXh0TGluZVN0eWxlRGFzaGVkOiBcIkxvbmctZGFzaGVkXCIsXG4gIC8vIEFsdC10ZXh0IGZvciB0aGUgc2hvcnQtZGFzaGVkIGxpbmUgZGFzaCBzdHlsZSBtZW51IGl0ZW0gaWNvblxuICBpY29uQWx0VGV4dExpbmVTdHlsZURvdHRlZDogXCJTaG9ydC1kYXNoZWRcIixcbiAgLy8gQWx0LXRleHQgZm9yIHRoZSAncG9zaXRpb24tdG9wJyBpY29uXG4gIGljb25BbHRUZXh0UG9zaXRpb25Ub3A6IFwiVG9wXCIsXG4gIC8vIEFsdC10ZXh0IGZvciB0aGUgJ3Bvc2l0aW9uLWNlbnRlcicgaWNvblxuICBpY29uQWx0VGV4dFBvc2l0aW9uQ2VudGVyOiBcIkNlbnRlclwiLFxuICAvLyBBbHQtdGV4dCBmb3IgdGhlICdwb3NpdGlvbi1ib3R0b20nIGljb25cbiAgaWNvbkFsdFRleHRQb3NpdGlvbkJvdHRvbTogXCJCb3R0b21cIixcbiAgLy8gQWx0LXRleHQgZm9yIHRoZSAncG9zaXRpb24tbGVmdCcgaWNvblxuICBpY29uQWx0VGV4dEFsaWduTGVmdDogXCJMZWZ0XCIsXG4gIC8vIEFsdC10ZXh0IGZvciB0aGUgJ2FsaWduLWNlbnRlcicgaWNvblxuICBpY29uQWx0VGV4dEFsaWduQ2VudGVyOiBcIkNlbnRlclwiLFxuICAvLyBBbHQtdGV4dCBmb3IgdGhlICdwb3NpdGlvbi1yaWdodCcgaWNvblxuICBpY29uQWx0VGV4dEFsaWduUmlnaHQ6IFwiUmlnaHRcIixcbiAgLy8gQWx0LXRleHQgZm9yIHRoZSAnY2xvc2UnIGljb25cbiAgaWNvbkFsdFRleHRDbG9zZTogXCJDbG9zZVwiLFxuICAvLyBEZWZhdWx0IHRleHQgZm9yIHRoZSAnbG9hZGluZyBkYXRhJyBvdmVybGF5XG4gIG92ZXJsYXlMb2FkaW5nRGF0YTogXCJMb2FkaW5nIGRhdGEuLi5cIixcbiAgLy8gRGVmYXVsdCB0ZXh0IGZvciB0aGUgJ25vIGRhdGEnIG92ZXJsYXlcbiAgb3ZlcmxheU5vRGF0YTogXCJObyBkYXRhIHRvIGRpc3BsYXlcIixcbiAgLy8gRGVmYXVsdCB0ZXh0IGZvciB0aGUgJ25vIHZpc2libGUgc2VyaWVzJyBvdmVybGF5XG4gIG92ZXJsYXlOb1Zpc2libGVTZXJpZXM6IFwiTm8gdmlzaWJsZSBzZXJpZXNcIixcbiAgLy8gVGV4dCBmb3IgdGhlIHNlcmllcyB0eXBlIHRvb2xiYXIncyBjaGFydCB0eXBlIGJ1dHRvblxuICB0b29sYmFyU2VyaWVzVHlwZURyb3Bkb3duOiBcIkNoYXJ0IFR5cGVcIixcbiAgLy8gVGV4dCBmb3IgdGhlIHNlcmllcyB0eXBlIHRvb2xiYXIncyBPSExDIGNoYXJ0IHR5cGUgYnV0dG9uXG4gIHRvb2xiYXJTZXJpZXNUeXBlT0hMQzogXCJPSExDXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBzZXJpZXMgdHlwZSB0b29sYmFyJ3MgSExDIGNoYXJ0IHR5cGUgYnV0dG9uXG4gIHRvb2xiYXJTZXJpZXNUeXBlSExDOiBcIkhMQ1wiLFxuICAvLyBUZXh0IGZvciB0aGUgc2VyaWVzIHR5cGUgdG9vbGJhcidzIGhpZ2ggbG93IGNoYXJ0IHR5cGUgYnV0dG9uXG4gIHRvb2xiYXJTZXJpZXNUeXBlSGlnaExvdzogXCJIaWdoIExvd1wiLFxuICAvLyBUZXh0IGZvciB0aGUgc2VyaWVzIHR5cGUgdG9vbGJhcidzIGNhbmRsZXMgY2hhcnQgdHlwZSBidXR0b25cbiAgdG9vbGJhclNlcmllc1R5cGVDYW5kbGVzOiBcIkNhbmRsZXNcIixcbiAgLy8gVGV4dCBmb3IgdGhlIHNlcmllcyB0eXBlIHRvb2xiYXIncyBob2xsb3cgY2FuZGxlcyBjaGFydCB0eXBlIGJ1dHRvblxuICB0b29sYmFyU2VyaWVzVHlwZUhvbGxvd0NhbmRsZXM6IFwiSG9sbG93IENhbmRsZXNcIixcbiAgLy8gVGV4dCBmb3IgdGhlIHNlcmllcyB0eXBlIHRvb2xiYXIncyBsaW5lIGNoYXJ0IHR5cGUgYnV0dG9uXG4gIHRvb2xiYXJTZXJpZXNUeXBlTGluZTogXCJMaW5lXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBzZXJpZXMgdHlwZSB0b29sYmFyJ3MgbGluZSB3aXRoIG1hcmtlcnMgY2hhcnQgdHlwZSBidXR0b25cbiAgdG9vbGJhclNlcmllc1R5cGVMaW5lV2l0aE1hcmtlcnM6IFwiTGluZSB3aXRoIE1hcmtlcnNcIixcbiAgLy8gVGV4dCBmb3IgdGhlIHNlcmllcyB0eXBlIHRvb2xiYXIncyBsaW5lIHdpdGggc3RlcCBsaW5lIGNoYXJ0IHR5cGUgYnV0dG9uXG4gIHRvb2xiYXJTZXJpZXNUeXBlU3RlcExpbmU6IFwiU3RlcCBMaW5lXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIHRvb2xiYXIncyB0cmVuZCBsaW5lIGJ1dHRvblxuICB0b29sYmFyQW5ub3RhdGlvbnNUcmVuZExpbmU6IFwiVHJlbmQgTGluZVwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiB0b29sYmFyJ3MgaG9yaXpvbnRhbCBsaW5lIGJ1dHRvblxuICB0b29sYmFyQW5ub3RhdGlvbnNIb3Jpem9udGFsTGluZTogXCJIb3Jpem9udGFsIExpbmVcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIHZlcnRpY2FsIGxpbmUgYnV0dG9uXG4gIHRvb2xiYXJBbm5vdGF0aW9uc1ZlcnRpY2FsTGluZTogXCJWZXJ0aWNhbCBMaW5lXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIHRvb2xiYXIncyBwYXJhbGxlbCBjaGFubmVsIGJ1dHRvblxuICB0b29sYmFyQW5ub3RhdGlvbnNQYXJhbGxlbENoYW5uZWw6IFwiUGFyYWxsZWwgQ2hhbm5lbFwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiB0b29sYmFyJ3MgZGlzam9pbnQgY2hhbm5lbCBidXR0b25cbiAgdG9vbGJhckFubm90YXRpb25zRGlzam9pbnRDaGFubmVsOiBcIkRpc2pvaW50IENoYW5uZWxcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIGNsZWFyIGFsbCBidXR0b25cbiAgdG9vbGJhckFubm90YXRpb25zQ2xlYXJBbGw6IFwiQ2xlYXIgQWxsXCIsXG4gIC8qKlxuICAgKiBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiB0b29sYmFyJ3MgY29sb3IgcGlja2VyIGFubm90YXRpb24gYnV0dG9uXG4gICAqIEBkZXByZWNhdGVkIHYxMC4xLjAgdXNlIGB0b29sYmFyQW5ub3RhdGlvbnNMaW5lQ29sb3JgIGluc3RlYWQuXG4gICAqL1xuICB0b29sYmFyQW5ub3RhdGlvbnNDb2xvcjogXCJDb2xvclwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiB0b29sYmFyJ3MgZmlsbCBjb2xvciBwaWNrZXIgYW5ub3RhdGlvbiBidXR0b25cbiAgdG9vbGJhckFubm90YXRpb25zRmlsbENvbG9yOiBcIkZpbGwgQ29sb3JcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIGxpbmUgY29sb3IgcGlja2VyIGFubm90YXRpb24gYnV0dG9uXG4gIHRvb2xiYXJBbm5vdGF0aW9uc0xpbmVDb2xvcjogXCJMaW5lIENvbG9yXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIHRvb2xiYXIncyBsaW5lIHN0eWxlIHR5cGUgYnV0dG9uXG4gIHRvb2xiYXJBbm5vdGF0aW9uc0xpbmVTdHlsZTogXCJMaW5lIFN0eWxlXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIHRvb2xiYXIncyBsaW5lIHN0cm9rZSB3aWR0aCBidXR0b25cbiAgdG9vbGJhckFubm90YXRpb25zTGluZVN0cm9rZVdpZHRoOiBcIkxpbmUgU3Ryb2tlIFdpZHRoXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIHRvb2xiYXIncyBzZXR0aW5ncyBhbm5vdGF0aW9uIGJ1dHRvblxuICB0b29sYmFyQW5ub3RhdGlvbnNTZXR0aW5nczogXCJTZXR0aW5nc1wiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiB0b29sYmFyJ3MgdGV4dCBjb2xvciBwaWNrZXIgYW5ub3RhdGlvbiBidXR0b25cbiAgdG9vbGJhckFubm90YXRpb25zVGV4dENvbG9yOiBcIlRleHQgQ29sb3JcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIHRleHQgc2l6ZSBwaWNrZXIgYW5ub3RhdGlvbiBidXR0b25cbiAgdG9vbGJhckFubm90YXRpb25zVGV4dFNpemU6IFwiVGV4dCBTaXplXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIHRvb2xiYXIncyBsb2NrIGFubm90YXRpb24gYnV0dG9uXG4gIHRvb2xiYXJBbm5vdGF0aW9uc0xvY2s6IFwiTG9ja1wiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiB0b29sYmFyJ3MgdW5sb2NrIGFubm90YXRpb24gYnV0dG9uXG4gIHRvb2xiYXJBbm5vdGF0aW9uc1VubG9jazogXCJVbmxvY2tcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIGRlbGV0ZSBhbm5vdGF0aW9uIGJ1dHRvblxuICB0b29sYmFyQW5ub3RhdGlvbnNEZWxldGU6IFwiRGVsZXRlXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIHRvb2xiYXIncyBkcmFnIGhhbmRsZVxuICB0b29sYmFyQW5ub3RhdGlvbnNEcmFnSGFuZGxlOiBcIkRyYWcgVG9vbGJhclwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiB0b29sYmFyJ3MgbGluZSBkcmF3aW5ncyBtZW51IGJ1dHRvblxuICB0b29sYmFyQW5ub3RhdGlvbnNMaW5lQW5ub3RhdGlvbnM6IFwiVHJlbmQgTGluZXNcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIHRleHQgYW5ub3RhdGlvbnMgbWVudSBidXR0b25cbiAgdG9vbGJhckFubm90YXRpb25zVGV4dEFubm90YXRpb25zOiBcIlRleHQgQW5ub3RhdGlvbnNcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIHNoYXBlcyBtZW51IGJ1dHRvblxuICB0b29sYmFyQW5ub3RhdGlvbnNTaGFwZUFubm90YXRpb25zOiBcIkFycm93c1wiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiB0b29sYmFyJ3MgbWVhc3VyZXJzIG1lbnUgYnV0dG9uXG4gIHRvb2xiYXJBbm5vdGF0aW9uc01lYXN1cmVyQW5ub3RhdGlvbnM6IFwiTWVhc3VyZXJzXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIHRvb2xiYXIncyBjYWxsb3V0IGJ1dHRvblxuICB0b29sYmFyQW5ub3RhdGlvbnNDYWxsb3V0OiBcIkNhbGxvdXRcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIGNvbW1lbnQgYnV0dG9uXG4gIHRvb2xiYXJBbm5vdGF0aW9uc0NvbW1lbnQ6IFwiQ29tbWVudFwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiB0b29sYmFyJ3Mgbm90ZSBidXR0b25cbiAgdG9vbGJhckFubm90YXRpb25zTm90ZTogXCJOb3RlXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIHRvb2xiYXIncyB0ZXh0IGJ1dHRvblxuICB0b29sYmFyQW5ub3RhdGlvbnNUZXh0OiBcIlRleHRcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIGFycm93IGJ1dHRvblxuICB0b29sYmFyQW5ub3RhdGlvbnNBcnJvdzogXCJBcnJvd1wiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiB0b29sYmFyJ3MgYXJyb3cgdXAgYnV0dG9uXG4gIHRvb2xiYXJBbm5vdGF0aW9uc0Fycm93VXA6IFwiQXJyb3cgVXBcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIGFycm93IGRvd24gYnV0dG9uXG4gIHRvb2xiYXJBbm5vdGF0aW9uc0Fycm93RG93bjogXCJBcnJvdyBEb3duXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIHRvb2xiYXIncyBkYXRlIHJhbmdlIGJ1dHRvblxuICB0b29sYmFyQW5ub3RhdGlvbnNEYXRlUmFuZ2U6IFwiRGF0ZSBSYW5nZVwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiB0b29sYmFyJ3MgcHJpY2UgcmFuZ2UgYnV0dG9uXG4gIHRvb2xiYXJBbm5vdGF0aW9uc1ByaWNlUmFuZ2U6IFwiUHJpY2UgUmFuZ2VcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIGRhdGUgYW5kIHByaWNlIHJhbmdlIGJ1dHRvblxuICB0b29sYmFyQW5ub3RhdGlvbnNEYXRlUHJpY2VSYW5nZTogXCJEYXRlIGFuZCBQcmljZVwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiB0b29sYmFyJ3MgcXVpY2sgZGF0ZSBhbmQgcHJpY2UgcmFuZ2UgYnV0dG9uXG4gIHRvb2xiYXJBbm5vdGF0aW9uc1F1aWNrRGF0ZVByaWNlUmFuZ2U6IFwiTWVhc3VyZVwiLFxuICAvLyBUZXh0IGZvciB0aGUgcmFuZ2UgdG9vbGJhcidzIDEgbW9udGggYnV0dG9uXG4gIHRvb2xiYXJSYW5nZTFNb250aDogXCIxTVwiLFxuICAvLyBBcmlhIGxhYmVsIGZvciB0aGUgcmFuZ2UgdG9vbGJhcidzIDEgbW9udGggYnV0dG9uXG4gIHRvb2xiYXJSYW5nZTFNb250aEFyaWE6IFwiMSBtb250aFwiLFxuICAvLyBUZXh0IGZvciB0aGUgcmFuZ2UgdG9vbGJhcidzIDMgbW9udGggYnV0dG9uXG4gIHRvb2xiYXJSYW5nZTNNb250aHM6IFwiM01cIixcbiAgLy8gQXJpYSBsYWJlbCBmb3IgdGhlIHJhbmdlIHRvb2xiYXIncyAzIG1vbnRoIGJ1dHRvblxuICB0b29sYmFyUmFuZ2UzTW9udGhzQXJpYTogXCIzIG1vbnRoc1wiLFxuICAvLyBUZXh0IGZvciB0aGUgcmFuZ2UgdG9vbGJhcidzIDYgbW9udGggYnV0dG9uXG4gIHRvb2xiYXJSYW5nZTZNb250aHM6IFwiNk1cIixcbiAgLy8gQXJpYSBsYWJlbCBmb3IgdGhlIHJhbmdlIHRvb2xiYXIncyA2IG1vbnRoIGJ1dHRvblxuICB0b29sYmFyUmFuZ2U2TW9udGhzQXJpYTogXCI2IG1vbnRoc1wiLFxuICAvLyBUZXh0IGZvciB0aGUgcmFuZ2UgdG9vbGJhcidzIHllYXIgdG8gZGF0ZSBidXR0b25cbiAgdG9vbGJhclJhbmdlWWVhclRvRGF0ZTogXCJZVERcIixcbiAgLy8gQXJpYSBsYWJlbCBmb3IgdGhlIHJhbmdlIHRvb2xiYXIncyB5ZWFyIHRvIGRhdGUgbW9udGggYnV0dG9uXG4gIHRvb2xiYXJSYW5nZVllYXJUb0RhdGVBcmlhOiBcIlllYXIgdG8gZGF0ZVwiLFxuICAvLyBUZXh0IGZvciB0aGUgcmFuZ2UgdG9vbGJhcidzIDEgeWVhciBidXR0b25cbiAgdG9vbGJhclJhbmdlMVllYXI6IFwiMVlcIixcbiAgLy8gQXJpYSBsYWJlbCBmb3IgdGhlIHJhbmdlIHRvb2xiYXIncyAxIHllYXIgYnV0dG9uXG4gIHRvb2xiYXJSYW5nZTFZZWFyQXJpYTogXCIxIHllYXJcIixcbiAgLy8gVGV4dCBmb3IgdGhlIHJhbmdlIHRvb2xiYXIncyBmdWxsIHJhbmdlIGJ1dHRvblxuICB0b29sYmFyUmFuZ2VBbGw6IFwiQWxsXCIsXG4gIC8vIEFyaWEgbGFiZWwgZm9yIHRoZSByYW5nZSB0b29sYmFyJ3MgZnVsbCByYW5nZSBidXR0b25cbiAgdG9vbGJhclJhbmdlQWxsQXJpYTogXCJBbGxcIixcbiAgLy8gVGV4dCBmb3IgdGhlIHpvb20gdG9vbGJhcidzIHpvb20gb3V0IGJ1dHRvblxuICB0b29sYmFyWm9vbVpvb21PdXQ6IFwiWm9vbSBvdXRcIixcbiAgLy8gVGV4dCBmb3IgdGhlIHpvb20gdG9vbGJhcidzIHpvb20gaW4gYnV0dG9uXG4gIHRvb2xiYXJab29tWm9vbUluOiBcIlpvb20gaW5cIixcbiAgLy8gVGV4dCBmb3IgdGhlIHpvb20gdG9vbGJhcidzIHBhbiBsZWZ0IGJ1dHRvblxuICB0b29sYmFyWm9vbVBhbkxlZnQ6IFwiUGFuIGxlZnRcIixcbiAgLy8gVGV4dCBmb3IgdGhlIHpvb20gdG9vbGJhcidzIHBhbiByaWdodCBidXR0b25cbiAgdG9vbGJhclpvb21QYW5SaWdodDogXCJQYW4gcmlnaHRcIixcbiAgLy8gVGV4dCBmb3IgdGhlIHpvb20gdG9vbGJhcidzIHBhbiB0byB0aGUgc3RhcnQgYnV0dG9uXG4gIHRvb2xiYXJab29tUGFuU3RhcnQ6IFwiUGFuIHRvIHRoZSBzdGFydFwiLFxuICAvLyBUZXh0IGZvciB0aGUgem9vbSB0b29sYmFyJ3MgcGFuIHRvIHRoZSBlbmQgYnV0dG9uXG4gIHRvb2xiYXJab29tUGFuRW5kOiBcIlBhbiB0byB0aGUgZW5kXCIsXG4gIC8vIFRleHQgZm9yIHRoZSB6b29tIHRvb2xiYXIncyBwYW4gcmVzZXQgYnV0dG9uXG4gIHRvb2xiYXJab29tUmVzZXQ6IFwiUmVzZXQgdGhlIHpvb21cIixcbiAgLy8gVGV4dCBmb3IgdGhlIGNvbnRleHQgbWVudSdzIGRvd25sb2FkIGJ1dHRvblxuICBjb250ZXh0TWVudURvd25sb2FkOiBcIkRvd25sb2FkXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBjb250ZXh0IG1lbnUncyB0b2dnbGUgc2VyaWVzIHZpc2liaWxpdHkgYnV0dG9uXG4gIGNvbnRleHRNZW51VG9nZ2xlU2VyaWVzVmlzaWJpbGl0eTogXCJUb2dnbGUgVmlzaWJpbGl0eVwiLFxuICAvLyBUZXh0IGZvciB0aGUgY29udGV4dCBtZW51J3MgdG9nZ2xlIG90aGVyIHNlcmllcyB2aXNpYmlsaXR5IGJ1dHRvblxuICBjb250ZXh0TWVudVRvZ2dsZU90aGVyU2VyaWVzOiBcIlRvZ2dsZSBPdGhlciBTZXJpZXNcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGNvbnRleHQgbWVudSdzIHpvb20gdG8gcG9pbnQgYnV0dG9uXG4gIGNvbnRleHRNZW51Wm9vbVRvQ3Vyc29yOiBcIlpvb20gdG8gaGVyZVwiLFxuICAvLyBUZXh0IGZvciB0aGUgY29udGV4dCBtZW51J3MgcGFuIHRvIHBvaW50IGJ1dHRvblxuICBjb250ZXh0TWVudVBhblRvQ3Vyc29yOiBcIlBhbiB0byBoZXJlXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIGRpYWxvZydzIGhlYWRlciBjaGFubmVsIHRhYiBsYWJlbFxuICBkaWFsb2dIZWFkZXJDaGFubmVsOiBcIkNoYW5uZWxcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gZGlhbG9nJ3MgaGVhZGVyIGxpbmUgdGFiIGxhYmVsXG4gIGRpYWxvZ0hlYWRlckxpbmU6IFwiTGluZVwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiBkaWFsb2cncyBoZWFkZXIgZGF0ZSByYW5nZSB0YWIgbGFiZWxcbiAgZGlhbG9nSGVhZGVyRGF0ZVJhbmdlOiBcIkRhdGUgUmFuZ2VcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gZGlhbG9nJ3MgaGVhZGVyIHByaWNlIHJhbmdlIHRhYiBsYWJlbFxuICBkaWFsb2dIZWFkZXJQcmljZVJhbmdlOiBcIlByaWNlIFJhbmdlXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIGRpYWxvZydzIGhlYWRlciBkYXRlIGFuZCBwcmljZSByYW5nZSB0YWIgbGFiZWxcbiAgZGlhbG9nSGVhZGVyRGF0ZVByaWNlUmFuZ2U6IFwiRGF0ZSBhbmQgUHJpY2VcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gZGlhbG9nJ3MgaGVhZGVyIHRleHQgdGFiIGxhYmVsXG4gIGRpYWxvZ0hlYWRlclRleHQ6IFwiVGV4dFwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiBkaWFsb2cncyB0ZXh0IGFsaWdubWVudCByYWRpbyBsYWJlbFxuICBkaWFsb2dJbnB1dEFsaWduOiBcIkFsaWduXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIGRpYWxvZydzIGNvbG9yIHBpY2tlciBsYWJlbFxuICBkaWFsb2dJbnB1dENvbG9yUGlja2VyOiBcIkNvbG9yXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIGRpYWxvZydzIGNvbG9yIHBpY2tlciBhbHQgdGV4dFxuICBkaWFsb2dJbnB1dENvbG9yUGlja2VyQWx0VGV4dDogXCJUZXh0IENvbG9yXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIGRpYWxvZydzIGZpbGwgY29sb3IgcGlja2VyIGxhYmVsXG4gIGRpYWxvZ0lucHV0RmlsbENvbG9yUGlja2VyOiBcIkZpbGxcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gZGlhbG9nJ3MgZmlsbCBjb2xvciBwaWNrZXIgYWx0IHRleHRcbiAgZGlhbG9nSW5wdXRGaWxsQ29sb3JQaWNrZXJBbHRUZXh0OiBcIkZpbGwgQ29sb3JcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gZGlhbG9nJ3MgZXh0ZW5kIGNoYW5uZWwgc3RhcnQgY2hlY2tib3hcbiAgZGlhbG9nSW5wdXRFeHRlbmRDaGFubmVsU3RhcnQ6IFwiRXh0ZW5kIGNoYW5uZWwgc3RhcnRcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gZGlhbG9nJ3MgZXh0ZW5kIGNoYW5uZWwgZW5kIGNoZWNrYm94XG4gIGRpYWxvZ0lucHV0RXh0ZW5kQ2hhbm5lbEVuZDogXCJFeHRlbmQgY2hhbm5lbCBlbmRcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gZGlhbG9nJ3MgZXh0ZW5kIGxpbmUgc3RhcnQgY2hlY2tib3hcbiAgZGlhbG9nSW5wdXRFeHRlbmRMaW5lU3RhcnQ6IFwiRXh0ZW5kIGxpbmUgc3RhcnRcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gZGlhbG9nJ3MgZXh0ZW5kIGxpbmUgZW5kIGNoZWNrYm94XG4gIGRpYWxvZ0lucHV0RXh0ZW5kTGluZUVuZDogXCJFeHRlbmQgbGluZSBlbmRcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gZGlhbG9nJ3MgZXh0ZW5kIGFib3ZlIGNoZWNrYm94XG4gIGRpYWxvZ0lucHV0RXh0ZW5kQWJvdmU6IFwiRXh0ZW5kIGFib3ZlXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIGRpYWxvZydzIGV4dGVuZCBiZWxvdyBjaGVja2JveFxuICBkaWFsb2dJbnB1dEV4dGVuZEJlbG93OiBcIkV4dGVuZCBiZWxvd1wiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiBkaWFsb2cncyBleHRlbmQgbGVmdCBjaGVja2JveFxuICBkaWFsb2dJbnB1dEV4dGVuZExlZnQ6IFwiRXh0ZW5kIGxlZnRcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gZGlhbG9nJ3MgZXh0ZW5kIHJpZ2h0IGNoZWNrYm94XG4gIGRpYWxvZ0lucHV0RXh0ZW5kUmlnaHQ6IFwiRXh0ZW5kIHJpZ2h0XCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIGRpYWxvZydzIGZvbnQgc2l6ZSBzZWxlY3QgYm94IGxhYmVsXG4gIGRpYWxvZ0lucHV0Rm9udFNpemU6IFwiU2l6ZVwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiBkaWFsb2cncyBmb250IHNpemUgc2VsZWN0IGJveCBhbHQgdGV4dFxuICBkaWFsb2dJbnB1dEZvbnRTaXplQWx0VGV4dDogXCJGb250IFNpemVcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gZGlhbG9nJ3MgbGluZSBzdHlsZSByYWRpbyBsYWJlbFxuICBkaWFsb2dJbnB1dExpbmVTdHlsZTogXCJEYXNoXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIGRpYWxvZydzIHRleHQgcG9zaXRpb24gcmFkaW8gbGFiZWxcbiAgZGlhbG9nSW5wdXRQb3NpdGlvbjogXCJQb3NpdGlvblwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiBkaWFsb2cncyBzdHJva2Ugd2lkdGggbGFiZWxcbiAgZGlhbG9nSW5wdXRTdHJva2VXaWR0aDogXCJXZWlnaHRcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gZGlhbG9nJ3Mgc3Ryb2tlIHdpZHRoIGxhYmVsXG4gIGRpYWxvZ0lucHV0U3Ryb2tlV2lkdGhBbHRUZXh0OiBcIkxpbmUgV2VpZ2h0XCIsXG4gIC8vIFRleHQgZm9yIHRleHQgYXJlYSBpbnB1dCBwbGFjZWhvbGRlcnNcbiAgaW5wdXRUZXh0YXJlYVBsYWNlaG9sZGVyOiBcIkFkZCBUZXh0XCIsXG4gIC8vIFRleHQgZm9yIHRoZSBtZWFzdXJlciBzdGF0aXN0aWNzIGRhdGUgcmFuZ2UgYmFycyB2YWx1ZVxuICBtZWFzdXJlckRhdGVSYW5nZUJhcnM6IFwiJHt2YWx1ZX1bbnVtYmVyXSBiYXJzXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBtZWFzdXJlciBzdGF0aXN0aWNzIHByaWNlIHJhbmdlIHZhbHVlXG4gIG1lYXN1cmVyUHJpY2VSYW5nZVZhbHVlOiBcIiR7dmFsdWV9W251bWJlcl1cIixcbiAgLy8gVGV4dCBmb3IgdGhlIG1lYXN1cmVyIHN0YXRpc3RpY3MgcHJpY2UgcmFuZ2UgcGVyY2VudGFnZVxuICBtZWFzdXJlclByaWNlUmFuZ2VQZXJjZW50OiBcIiR7dmFsdWV9W3BlcmNlbnRdXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBtZWFzdXJlciBzdGF0aXN0aWNzIHZvbHVtZSB2YWx1ZVxuICBtZWFzdXJlclZvbHVtZTogXCJWb2wgJHt2YWx1ZX1cIlxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLXR5cGVzL3NyYy9jaGFydC9lcnJvckJhck9wdGlvbnMudHNcbnZhciBBZ0Vycm9yQmFyU3VwcG9ydGVkU2VyaWVzVHlwZXMgPSBbXCJiYXJcIiwgXCJsaW5lXCIsIFwic2NhdHRlclwiXTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLXR5cGVzL3NyYy9jaGFydC9pY29ucy50c1xudmFyIElDT05TX0xFR0FDWSA9IFtcbiAgXCJkZWxldGUtbGVnYWN5XCIsXG4gIFwiZGlzam9pbnQtY2hhbm5lbFwiLFxuICBcImRpc2pvaW50LWNoYW5uZWwtbGVnYWN5XCIsXG4gIFwiaG9yaXpvbnRhbC1saW5lLWxlZ2FjeVwiLFxuICBcImxpbmUtY29sb3ItbGVnYWN5XCIsXG4gIFwibG9ja1wiLFxuICBcImxvY2stbGVnYWN5XCIsXG4gIFwicGFuLWVuZC1sZWdhY3lcIixcbiAgXCJwYW4tbGVmdC1sZWdhY3lcIixcbiAgXCJwYW4tcmlnaHQtbGVnYWN5XCIsXG4gIFwicGFuLXN0YXJ0LWxlZ2FjeVwiLFxuICBcInBhcmFsbGVsLWNoYW5uZWxcIixcbiAgXCJwYXJhbGxlbC1jaGFubmVsLWxlZ2FjeVwiLFxuICBcInJlc2V0LWxlZ2FjeVwiLFxuICBcInRyZW5kLWxpbmVcIixcbiAgXCJ0cmVuZC1saW5lLWxlZ2FjeVwiLFxuICBcInVubG9ja1wiLFxuICBcInVubG9jay1sZWdhY3lcIixcbiAgXCJ2ZXJ0aWNhbC1saW5lXCIsXG4gIFwidmVydGljYWwtbGluZS1sZWdhY3lcIixcbiAgXCJ6b29tLWluLWxlZ2FjeVwiLFxuICBcInpvb20taW4tYWx0XCIsXG4gIFwiem9vbS1pbi1hbHQtbGVnYWN5XCIsXG4gIFwiem9vbS1vdXQtbGVnYWN5XCIsXG4gIFwiem9vbS1vdXQtYWx0XCIsXG4gIFwiem9vbS1vdXQtYWx0LWxlZ2FjeVwiXG5dO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtdHlwZXMvc3JjL2NoYXJ0L25hdmlnYXRvck9wdGlvbnMudHNcbnZhciBfX01JTklfQ0hBUlRfU0VSSUVTX09QVElPTlMgPSB2b2lkIDA7XG52YXIgX19WRVJJRllfTUlOSV9DSEFSVF9TRVJJRVNfT1BUSU9OUyA9IHZvaWQgMDtcbl9fVkVSSUZZX01JTklfQ0hBUlRfU0VSSUVTX09QVElPTlMgPSBfX01JTklfQ0hBUlRfU0VSSUVTX09QVElPTlM7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy10eXBlcy9zcmMvY2hhcnQvdGhlbWVPcHRpb25zLnRzXG52YXIgX19USEVNRV9PVkVSUklERVMgPSB2b2lkIDA7XG52YXIgX19WRVJJRllfVEhFTUVfT1ZFUlJJREVTID0gdm9pZCAwO1xuX19WRVJJRllfVEhFTUVfT1ZFUlJJREVTID0gX19USEVNRV9PVkVSUklERVM7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy10eXBlcy9zcmMvY2hhcnQvdG9vbHRpcE9wdGlvbnMudHNcbnZhciBBZ1Rvb2x0aXBQb3NpdGlvblR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChBZ1Rvb2x0aXBQb3NpdGlvblR5cGUyKSA9PiB7XG4gIEFnVG9vbHRpcFBvc2l0aW9uVHlwZTJbXCJQT0lOVEVSXCJdID0gXCJwb2ludGVyXCI7XG4gIEFnVG9vbHRpcFBvc2l0aW9uVHlwZTJbXCJOT0RFXCJdID0gXCJub2RlXCI7XG4gIEFnVG9vbHRpcFBvc2l0aW9uVHlwZTJbXCJUT1BcIl0gPSBcInRvcFwiO1xuICBBZ1Rvb2x0aXBQb3NpdGlvblR5cGUyW1wiUklHSFRcIl0gPSBcInJpZ2h0XCI7XG4gIEFnVG9vbHRpcFBvc2l0aW9uVHlwZTJbXCJCT1RUT01cIl0gPSBcImJvdHRvbVwiO1xuICBBZ1Rvb2x0aXBQb3NpdGlvblR5cGUyW1wiTEVGVFwiXSA9IFwibGVmdFwiO1xuICBBZ1Rvb2x0aXBQb3NpdGlvblR5cGUyW1wiVE9QX0xFRlRcIl0gPSBcInRvcC1sZWZ0XCI7XG4gIEFnVG9vbHRpcFBvc2l0aW9uVHlwZTJbXCJUT1BfUklHSFRcIl0gPSBcInRvcC1yaWdodFwiO1xuICBBZ1Rvb2x0aXBQb3NpdGlvblR5cGUyW1wiQk9UVE9NX1JJR0hUXCJdID0gXCJib3R0b20tcmlnaHRcIjtcbiAgQWdUb29sdGlwUG9zaXRpb25UeXBlMltcIkJPVFRPTV9MRUZUXCJdID0gXCJib3R0b20tbGVmdFwiO1xuICByZXR1cm4gQWdUb29sdGlwUG9zaXRpb25UeXBlMjtcbn0pKEFnVG9vbHRpcFBvc2l0aW9uVHlwZSB8fCB7fSk7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy10eXBlcy9zcmMvcHJlc2V0cy9nYXVnZS9jb21tb25PcHRpb25zLnRzXG52YXIgX19USEVNRUFCTEVfT1BUSU9OUyA9IHZvaWQgMDtcbnZhciBfX1ZFUklGWV9USEVNRUFCTEVfT1BUSU9OUyA9IHZvaWQgMDtcbl9fVkVSSUZZX1RIRU1FQUJMRV9PUFRJT05TID0gX19USEVNRUFCTEVfT1BUSU9OUztcbnZhciBfX0FYSVNfTEFCRUxfT1BUSU9OUyA9IHZvaWQgMDtcbnZhciBfX1ZFUklGWV9BWElTX0xBQkVMX09QVElPTlMgPSB2b2lkIDA7XG5fX1ZFUklGWV9BWElTX0xBQkVMX09QVElPTlMgPSBfX0FYSVNfTEFCRUxfT1BUSU9OUztcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC90aW1lL2luZGV4LnRzXG52YXIgdGltZV9leHBvcnRzID0ge307XG5fX2V4cG9ydCh0aW1lX2V4cG9ydHMsIHtcbiAgVGltZUludGVydmFsOiAoKSA9PiBUaW1lSW50ZXJ2YWwsXG4gIGRheTogKCkgPT4gZGF5LFxuICBmcmlkYXk6ICgpID0+IGZyaWRheSxcbiAgaG91cjogKCkgPT4gaG91cixcbiAgbWlsbGlzZWNvbmQ6ICgpID0+IG1pbGxpc2Vjb25kLFxuICBtaW51dGU6ICgpID0+IG1pbnV0ZSxcbiAgbW9uZGF5OiAoKSA9PiBtb25kYXksXG4gIG1vbnRoOiAoKSA9PiBtb250aCxcbiAgc2F0dXJkYXk6ICgpID0+IHNhdHVyZGF5LFxuICBzZWNvbmQ6ICgpID0+IHNlY29uZCxcbiAgc3VuZGF5OiAoKSA9PiBzdW5kYXksXG4gIHRodXJzZGF5OiAoKSA9PiB0aHVyc2RheSxcbiAgdHVlc2RheTogKCkgPT4gdHVlc2RheSxcbiAgdXRjRGF5OiAoKSA9PiB1dGNEYXksXG4gIHV0Y0hvdXI6ICgpID0+IHV0Y0hvdXIsXG4gIHV0Y01pbnV0ZTogKCkgPT4gdXRjTWludXRlLFxuICB1dGNNb250aDogKCkgPT4gdXRjTW9udGgsXG4gIHV0Y1llYXI6ICgpID0+IHV0Y1llYXIsXG4gIHdlZG5lc2RheTogKCkgPT4gd2VkbmVzZGF5LFxuICB5ZWFyOiAoKSA9PiB5ZWFyXG59KTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9mdW5jdGlvbi50c1xudmFyIGRvT25jZVN0YXRlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGRvT25jZShmdW5jLCBrZXkpIHtcbiAgaWYgKGRvT25jZVN0YXRlLmhhcyhrZXkpKVxuICAgIHJldHVybjtcbiAgZG9PbmNlU3RhdGUuc2V0KGtleSwgdHJ1ZSk7XG4gIGZ1bmMoKTtcbn1cbmRvT25jZS5jbGVhciA9ICgpID0+IGRvT25jZVN0YXRlLmNsZWFyKCk7XG5mdW5jdGlvbiBpZGVudGl0eSh4KSB7XG4gIHJldHVybiB4O1xufVxuZnVuY3Rpb24gdGhyb3R0bGUoY2FsbGJhY2syLCB3YWl0TXMgPSAwLCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgbGVhZGluZyA9IHRydWUsIHRyYWlsaW5nID0gdHJ1ZSB9ID0gb3B0aW9ucyA/PyB7fTtcbiAgbGV0IHRpbWVySWQ7XG4gIGxldCBsYXN0QXJncztcbiAgbGV0IHNob3VsZFdhaXQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gdGltZW91dEhhbmRsZXIoKSB7XG4gICAgaWYgKHRyYWlsaW5nICYmIGxhc3RBcmdzKSB7XG4gICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lb3V0SGFuZGxlciwgd2FpdE1zKTtcbiAgICAgIGNhbGxiYWNrMiguLi5sYXN0QXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNob3VsZFdhaXQgPSBmYWxzZTtcbiAgICB9XG4gICAgbGFzdEFyZ3MgPSBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIHRocm90dGxlQ2FsbGJhY2soLi4uYXJncykge1xuICAgIGlmIChzaG91bGRXYWl0KSB7XG4gICAgICBsYXN0QXJncyA9IGFyZ3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNob3VsZFdhaXQgPSB0cnVlO1xuICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZW91dEhhbmRsZXIsIHdhaXRNcyk7XG4gICAgICBpZiAobGVhZGluZykge1xuICAgICAgICBjYWxsYmFjazIoLi4uYXJncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXN0QXJncyA9IGFyZ3M7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHRocm90dGxlQ2FsbGJhY2ssIHtcbiAgICBjYW5jZWwoKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgICBzaG91bGRXYWl0ID0gZmFsc2U7XG4gICAgICBsYXN0QXJncyA9IG51bGw7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGpvaW5GdW5jdGlvbnMoLi4uZm5zKSB7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgZm9yIChjb25zdCBmbiBvZiBmbnMpIHtcbiAgICAgIGZuKCk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2xvZ2dlci50c1xudmFyIExvZ2dlciA9IHtcbiAgbG9nKC4uLmxvZ0NvbnRlbnQpIHtcbiAgICBjb25zb2xlLmxvZyguLi5sb2dDb250ZW50KTtcbiAgfSxcbiAgd2FybihtZXNzYWdlLCAuLi5sb2dDb250ZW50KSB7XG4gICAgY29uc29sZS53YXJuKGBBRyBDaGFydHMgLSAke21lc3NhZ2V9YCwgLi4ubG9nQ29udGVudCk7XG4gIH0sXG4gIGVycm9yKG1lc3NhZ2UsIC4uLmxvZ0NvbnRlbnQpIHtcbiAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEFHIENoYXJ0cyBlcnJvcmAsIG1lc3NhZ2UsIC4uLmxvZ0NvbnRlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBBRyBDaGFydHMgLSAke21lc3NhZ2V9YCwgLi4ubG9nQ29udGVudCk7XG4gICAgfVxuICB9LFxuICB0YWJsZSguLi5sb2dDb250ZW50KSB7XG4gICAgY29uc29sZS50YWJsZSguLi5sb2dDb250ZW50KTtcbiAgfSxcbiAgd2Fybk9uY2UobWVzc2FnZSwgLi4ubG9nQ29udGVudCkge1xuICAgIGRvT25jZSgoKSA9PiBMb2dnZXIud2FybihtZXNzYWdlLCAuLi5sb2dDb250ZW50KSwgYExvZ2dlci53YXJuOiAke21lc3NhZ2V9YCk7XG4gIH0sXG4gIGVycm9yT25jZShtZXNzYWdlLCAuLi5sb2dDb250ZW50KSB7XG4gICAgZG9PbmNlKCgpID0+IExvZ2dlci5lcnJvcihtZXNzYWdlLCAuLi5sb2dDb250ZW50KSwgYExvZ2dlci5lcnJvcjogJHttZXNzYWdlfWApO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3RpbWUvaW50ZXJ2YWwudHNcbnZhciBUaW1lSW50ZXJ2YWwgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKF9lbmNvZGUsIF9kZWNvZGUsIF9yYW5nZUNhbGxiYWNrKSB7XG4gICAgdGhpcy5fZW5jb2RlID0gX2VuY29kZTtcbiAgICB0aGlzLl9kZWNvZGUgPSBfZGVjb2RlO1xuICAgIHRoaXMuX3JhbmdlQ2FsbGJhY2sgPSBfcmFuZ2VDYWxsYmFjaztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBkYXRlIHJlcHJlc2VudGluZyB0aGUgbGF0ZXN0IGludGVydmFsIGJvdW5kYXJ5IGRhdGUgYmVmb3JlIG9yIGVxdWFsIHRvIGRhdGUuXG4gICAqIEZvciBleGFtcGxlLCBgZGF5LmZsb29yKGRhdGUpYCB0eXBpY2FsbHkgcmV0dXJucyAxMjowMCBBTSBsb2NhbCB0aW1lIG9uIHRoZSBnaXZlbiBkYXRlLlxuICAgKiBAcGFyYW0gZGF0ZVxuICAgKi9cbiAgZmxvb3IoZGF0ZSkge1xuICAgIGNvbnN0IGQgPSBuZXcgRGF0ZShkYXRlKTtcbiAgICBjb25zdCBlID0gdGhpcy5fZW5jb2RlKGQpO1xuICAgIHJldHVybiB0aGlzLl9kZWNvZGUoZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgZGF0ZSByZXByZXNlbnRpbmcgdGhlIGVhcmxpZXN0IGludGVydmFsIGJvdW5kYXJ5IGRhdGUgYWZ0ZXIgb3IgZXF1YWwgdG8gZGF0ZS5cbiAgICogQHBhcmFtIGRhdGVcbiAgICovXG4gIGNlaWwoZGF0ZSkge1xuICAgIGNvbnN0IGQgPSBuZXcgRGF0ZShOdW1iZXIoZGF0ZSkgLSAxKTtcbiAgICBjb25zdCBlID0gdGhpcy5fZW5jb2RlKGQpO1xuICAgIHJldHVybiB0aGlzLl9kZWNvZGUoZSArIDEpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGRhdGVzIHJlcHJlc2VudGluZyBldmVyeSBpbnRlcnZhbCBib3VuZGFyeSBhZnRlciBvciBlcXVhbCB0byBzdGFydCAoaW5jbHVzaXZlKSBhbmQgYmVmb3JlIHN0b3AgKGV4Y2x1c2l2ZSkuXG4gICAqIEBwYXJhbSBzdGFydCBSYW5nZSBzdGFydC5cbiAgICogQHBhcmFtIHN0b3AgUmFuZ2UgZW5kLlxuICAgKiBAcGFyYW0gZXh0ZW5kIElmIHNwZWNpZmllZCwgdGhlIHJlcXVlc3RlZCByYW5nZSB3aWxsIGJlIGV4dGVuZGVkIHRvIHRoZSBjbG9zZXN0IFwibmljZVwiIHZhbHVlcy5cbiAgICovXG4gIHJhbmdlKHN0YXJ0Miwgc3RvcCwgZXh0ZW5kKSB7XG4gICAgY29uc3QgcmFuZ2VDYWxsYmFjayA9IHRoaXMuX3JhbmdlQ2FsbGJhY2s/LihzdGFydDIsIHN0b3ApO1xuICAgIGNvbnN0IGUwID0gdGhpcy5fZW5jb2RlKGV4dGVuZCA/IHRoaXMuZmxvb3Ioc3RhcnQyKSA6IHRoaXMuY2VpbChzdGFydDIpKTtcbiAgICBjb25zdCBlMSA9IHRoaXMuX2VuY29kZShleHRlbmQgPyB0aGlzLmNlaWwoc3RvcCkgOiB0aGlzLmZsb29yKHN0b3ApKTtcbiAgICBpZiAoZTEgPCBlMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCByYW5nZTMgPSBbXTtcbiAgICBmb3IgKGxldCBlID0gZTA7IGUgPD0gZTE7IGUrKykge1xuICAgICAgY29uc3QgZCA9IHRoaXMuX2RlY29kZShlKTtcbiAgICAgIHJhbmdlMy5wdXNoKGQpO1xuICAgIH1cbiAgICByYW5nZUNhbGxiYWNrPy4oKTtcbiAgICByZXR1cm4gcmFuZ2UzO1xuICB9XG59O1xudmFyIENvdW50YWJsZVRpbWVJbnRlcnZhbCA9IGNsYXNzIGV4dGVuZHMgVGltZUludGVydmFsIHtcbiAgZ2V0T2Zmc2V0KHNuYXBUbywgc3RlcCkge1xuICAgIGNvbnN0IHMgPSB0eXBlb2Ygc25hcFRvID09PSBcIm51bWJlclwiIHx8IHNuYXBUbyBpbnN0YW5jZW9mIERhdGUgPyB0aGlzLl9lbmNvZGUobmV3IERhdGUoc25hcFRvKSkgOiAwO1xuICAgIHJldHVybiBNYXRoLmZsb29yKHMpICUgc3RlcDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIGZpbHRlcmVkIHZpZXcgb2YgdGhpcyBpbnRlcnZhbCByZXByZXNlbnRpbmcgZXZlcnkgc3RlcCd0aCBkYXRlLlxuICAgKiBJdCBjYW4gYmUgYSBudW1iZXIgb2YgbWludXRlcywgaG91cnMsIGRheXMgZXRjLlxuICAgKiBNdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlci5cbiAgICogQHBhcmFtIHN0ZXBcbiAgICovXG4gIGV2ZXJ5KHN0ZXAsIG9wdGlvbnMpIHtcbiAgICBsZXQgb2Zmc2V0NCA9IDA7XG4gICAgbGV0IHJhbmdlQ2FsbGJhY2s7XG4gICAgY29uc3QgdW5zYWZlU3RlcCA9IHN0ZXA7XG4gICAgc3RlcCA9IE1hdGgubWF4KDEsIE1hdGgucm91bmQoc3RlcCkpO1xuICAgIGlmICh1bnNhZmVTdGVwICE9PSBzdGVwKSB7XG4gICAgICBMb2dnZXIud2Fybk9uY2UoYGludGVydmFsIHN0ZXAgb2YgWyR7dW5zYWZlU3RlcH1dIHJvdW5kZWQgdG8gWyR7c3RlcH1dLmApO1xuICAgIH1cbiAgICBjb25zdCB7IHNuYXBUbyA9IFwic3RhcnRcIiB9ID0gb3B0aW9ucyA/PyB7fTtcbiAgICBpZiAodHlwZW9mIHNuYXBUbyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgY29uc3QgaW5pdGlhbE9mZnNldCA9IG9mZnNldDQ7XG4gICAgICByYW5nZUNhbGxiYWNrID0gKHN0YXJ0Miwgc3RvcCkgPT4ge1xuICAgICAgICBjb25zdCBzID0gc25hcFRvID09PSBcInN0YXJ0XCIgPyBzdGFydDIgOiBzdG9wO1xuICAgICAgICBvZmZzZXQ0ID0gdGhpcy5nZXRPZmZzZXQocywgc3RlcCk7XG4gICAgICAgIHJldHVybiAoKSA9PiBvZmZzZXQ0ID0gaW5pdGlhbE9mZnNldDtcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc25hcFRvID09PSBcIm51bWJlclwiKSB7XG4gICAgICBvZmZzZXQ0ID0gdGhpcy5nZXRPZmZzZXQobmV3IERhdGUoc25hcFRvKSwgc3RlcCk7XG4gICAgfSBlbHNlIGlmIChzbmFwVG8gaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICBvZmZzZXQ0ID0gdGhpcy5nZXRPZmZzZXQoc25hcFRvLCBzdGVwKTtcbiAgICB9XG4gICAgY29uc3QgZW5jb2RlMTMgPSAoZGF0ZSkgPT4ge1xuICAgICAgY29uc3QgZSA9IHRoaXMuX2VuY29kZShkYXRlKTtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKChlIC0gb2Zmc2V0NCkgLyBzdGVwKTtcbiAgICB9O1xuICAgIGNvbnN0IGRlY29kZTEzID0gKGVuY29kZWQpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLl9kZWNvZGUoZW5jb2RlZCAqIHN0ZXAgKyBvZmZzZXQ0KTtcbiAgICB9O1xuICAgIHJldHVybiBuZXcgVGltZUludGVydmFsKGVuY29kZTEzLCBkZWNvZGUxMywgcmFuZ2VDYWxsYmFjayk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvdGltZS9taWxsaXNlY29uZC50c1xuZnVuY3Rpb24gZW5jb2RlKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0VGltZSgpO1xufVxuZnVuY3Rpb24gZGVjb2RlKGVuY29kZWQpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKGVuY29kZWQpO1xufVxudmFyIG1pbGxpc2Vjb25kID0gbmV3IENvdW50YWJsZVRpbWVJbnRlcnZhbChlbmNvZGUsIGRlY29kZSk7XG52YXIgbWlsbGlzZWNvbmRfZGVmYXVsdCA9IG1pbGxpc2Vjb25kO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3RpbWUvZHVyYXRpb24udHNcbnZhciBlcG9jaFllYXIgPSAoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKDApKS5nZXRGdWxsWWVhcigpO1xudmFyIGR1cmF0aW9uU2Vjb25kID0gMWUzO1xudmFyIGR1cmF0aW9uTWludXRlID0gZHVyYXRpb25TZWNvbmQgKiA2MDtcbnZhciBkdXJhdGlvbkhvdXIgPSBkdXJhdGlvbk1pbnV0ZSAqIDYwO1xudmFyIGR1cmF0aW9uRGF5ID0gZHVyYXRpb25Ib3VyICogMjQ7XG52YXIgZHVyYXRpb25XZWVrID0gZHVyYXRpb25EYXkgKiA3O1xudmFyIGR1cmF0aW9uTW9udGggPSBkdXJhdGlvbkRheSAqIDMwO1xudmFyIGR1cmF0aW9uWWVhciA9IGR1cmF0aW9uRGF5ICogMzY1O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3RpbWUvc2Vjb25kLnRzXG52YXIgb2Zmc2V0ID0gKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS5nZXRUaW1lem9uZU9mZnNldCgpICogZHVyYXRpb25NaW51dGU7XG5mdW5jdGlvbiBlbmNvZGUyKGRhdGUpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoKGRhdGUuZ2V0VGltZSgpIC0gb2Zmc2V0KSAvIGR1cmF0aW9uU2Vjb25kKTtcbn1cbmZ1bmN0aW9uIGRlY29kZTIoZW5jb2RlZCkge1xuICByZXR1cm4gbmV3IERhdGUob2Zmc2V0ICsgZW5jb2RlZCAqIGR1cmF0aW9uU2Vjb25kKTtcbn1cbnZhciBzZWNvbmQgPSBuZXcgQ291bnRhYmxlVGltZUludGVydmFsKGVuY29kZTIsIGRlY29kZTIpO1xudmFyIHNlY29uZF9kZWZhdWx0ID0gc2Vjb25kO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3RpbWUvbWludXRlLnRzXG52YXIgb2Zmc2V0MiA9ICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIGR1cmF0aW9uTWludXRlO1xuZnVuY3Rpb24gZW5jb2RlMyhkYXRlKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKChkYXRlLmdldFRpbWUoKSAtIG9mZnNldDIpIC8gZHVyYXRpb25NaW51dGUpO1xufVxuZnVuY3Rpb24gZGVjb2RlMyhlbmNvZGVkKSB7XG4gIHJldHVybiBuZXcgRGF0ZShvZmZzZXQyICsgZW5jb2RlZCAqIGR1cmF0aW9uTWludXRlKTtcbn1cbnZhciBtaW51dGUgPSBuZXcgQ291bnRhYmxlVGltZUludGVydmFsKGVuY29kZTMsIGRlY29kZTMpO1xudmFyIG1pbnV0ZV9kZWZhdWx0ID0gbWludXRlO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3RpbWUvaG91ci50c1xudmFyIG9mZnNldDMgPSAoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLmdldFRpbWV6b25lT2Zmc2V0KCkgKiBkdXJhdGlvbk1pbnV0ZTtcbmZ1bmN0aW9uIGVuY29kZTQoZGF0ZSkge1xuICByZXR1cm4gTWF0aC5mbG9vcigoZGF0ZS5nZXRUaW1lKCkgLSBvZmZzZXQzKSAvIGR1cmF0aW9uSG91cik7XG59XG5mdW5jdGlvbiBkZWNvZGU0KGVuY29kZWQpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKG9mZnNldDMgKyBlbmNvZGVkICogZHVyYXRpb25Ib3VyKTtcbn1cbnZhciBob3VyID0gbmV3IENvdW50YWJsZVRpbWVJbnRlcnZhbChlbmNvZGU0LCBkZWNvZGU0KTtcbnZhciBob3VyX2RlZmF1bHQgPSBob3VyO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3RpbWUvZGF5LnRzXG5mdW5jdGlvbiBlbmNvZGU1KGRhdGUpIHtcbiAgY29uc3QgdHpPZmZzZXRNcyA9IGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIGR1cmF0aW9uTWludXRlO1xuICByZXR1cm4gTWF0aC5mbG9vcigoZGF0ZS5nZXRUaW1lKCkgLSB0ek9mZnNldE1zKSAvIGR1cmF0aW9uRGF5KTtcbn1cbmZ1bmN0aW9uIGRlY29kZTUoZW5jb2RlZCkge1xuICBjb25zdCBkID0gbmV3IERhdGUoMTk3MCwgMCwgMSk7XG4gIGQuc2V0RGF0ZShkLmdldERhdGUoKSArIGVuY29kZWQpO1xuICByZXR1cm4gZDtcbn1cbnZhciBkYXkgPSBuZXcgQ291bnRhYmxlVGltZUludGVydmFsKGVuY29kZTUsIGRlY29kZTUpO1xudmFyIGRheV9kZWZhdWx0ID0gZGF5O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3RpbWUvd2Vlay50c1xuZnVuY3Rpb24gd2Vla2RheSh3ZWVrU3RhcnQpIHtcbiAgY29uc3QgdGh1cnNkYXkyID0gNDtcbiAgY29uc3QgZGF5U2hpZnQgPSAoNyArIHdlZWtTdGFydCAtIHRodXJzZGF5MikgJSA3O1xuICBmdW5jdGlvbiBlbmNvZGUxMyhkYXRlKSB7XG4gICAgY29uc3QgdHpPZmZzZXRNcyA9IGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIGR1cmF0aW9uTWludXRlO1xuICAgIHJldHVybiBNYXRoLmZsb29yKChkYXRlLmdldFRpbWUoKSAtIHR6T2Zmc2V0TXMpIC8gZHVyYXRpb25XZWVrIC0gZGF5U2hpZnQgLyA3KTtcbiAgfVxuICBmdW5jdGlvbiBkZWNvZGUxMyhlbmNvZGVkKSB7XG4gICAgY29uc3QgZCA9IG5ldyBEYXRlKDE5NzAsIDAsIDEpO1xuICAgIGQuc2V0RGF0ZShkLmdldERhdGUoKSArIGVuY29kZWQgKiA3ICsgZGF5U2hpZnQpO1xuICAgIHJldHVybiBkO1xuICB9XG4gIHJldHVybiBuZXcgQ291bnRhYmxlVGltZUludGVydmFsKGVuY29kZTEzLCBkZWNvZGUxMyk7XG59XG52YXIgc3VuZGF5ID0gd2Vla2RheSgwKTtcbnZhciBtb25kYXkgPSB3ZWVrZGF5KDEpO1xudmFyIHR1ZXNkYXkgPSB3ZWVrZGF5KDIpO1xudmFyIHdlZG5lc2RheSA9IHdlZWtkYXkoMyk7XG52YXIgdGh1cnNkYXkgPSB3ZWVrZGF5KDQpO1xudmFyIGZyaWRheSA9IHdlZWtkYXkoNSk7XG52YXIgc2F0dXJkYXkgPSB3ZWVrZGF5KDYpO1xudmFyIHdlZWtfZGVmYXVsdCA9IHN1bmRheTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC90aW1lL21vbnRoLnRzXG5mdW5jdGlvbiBlbmNvZGU2KGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0RnVsbFllYXIoKSAqIDEyICsgZGF0ZS5nZXRNb250aCgpO1xufVxuZnVuY3Rpb24gZGVjb2RlNihlbmNvZGVkKSB7XG4gIGNvbnN0IHllYXIyID0gTWF0aC5mbG9vcihlbmNvZGVkIC8gMTIpO1xuICBjb25zdCBtb250aDIgPSBlbmNvZGVkIC0geWVhcjIgKiAxMjtcbiAgcmV0dXJuIG5ldyBEYXRlKHllYXIyLCBtb250aDIsIDEpO1xufVxudmFyIG1vbnRoID0gbmV3IENvdW50YWJsZVRpbWVJbnRlcnZhbChlbmNvZGU2LCBkZWNvZGU2KTtcbnZhciBtb250aF9kZWZhdWx0ID0gbW9udGg7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvdGltZS95ZWFyLnRzXG5mdW5jdGlvbiBlbmNvZGU3KGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0RnVsbFllYXIoKTtcbn1cbmZ1bmN0aW9uIGRlY29kZTcoZW5jb2RlZCkge1xuICBjb25zdCBkID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gIGQuc2V0RnVsbFllYXIoZW5jb2RlZCk7XG4gIGQuc2V0TW9udGgoMCwgMSk7XG4gIGQuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gIHJldHVybiBkO1xufVxudmFyIHllYXIgPSBuZXcgQ291bnRhYmxlVGltZUludGVydmFsKGVuY29kZTcsIGRlY29kZTcpO1xudmFyIHllYXJfZGVmYXVsdCA9IHllYXI7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvdGltZS91dGNNaW51dGUudHNcbmZ1bmN0aW9uIGVuY29kZTgoZGF0ZSkge1xuICByZXR1cm4gTWF0aC5mbG9vcihkYXRlLmdldFRpbWUoKSAvIGR1cmF0aW9uTWludXRlKTtcbn1cbmZ1bmN0aW9uIGRlY29kZTgoZW5jb2RlZCkge1xuICByZXR1cm4gbmV3IERhdGUoZW5jb2RlZCAqIGR1cmF0aW9uTWludXRlKTtcbn1cbnZhciB1dGNNaW51dGUgPSBuZXcgQ291bnRhYmxlVGltZUludGVydmFsKGVuY29kZTgsIGRlY29kZTgpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3RpbWUvdXRjSG91ci50c1xuZnVuY3Rpb24gZW5jb2RlOShkYXRlKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKGRhdGUuZ2V0VGltZSgpIC8gZHVyYXRpb25Ib3VyKTtcbn1cbmZ1bmN0aW9uIGRlY29kZTkoZW5jb2RlZCkge1xuICByZXR1cm4gbmV3IERhdGUoZW5jb2RlZCAqIGR1cmF0aW9uSG91cik7XG59XG52YXIgdXRjSG91ciA9IG5ldyBDb3VudGFibGVUaW1lSW50ZXJ2YWwoZW5jb2RlOSwgZGVjb2RlOSk7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvdGltZS91dGNEYXkudHNcbmZ1bmN0aW9uIGVuY29kZTEwKGRhdGUpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoZGF0ZS5nZXRUaW1lKCkgLyBkdXJhdGlvbkRheSk7XG59XG5mdW5jdGlvbiBkZWNvZGUxMChlbmNvZGVkKSB7XG4gIGNvbnN0IGQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoMCk7XG4gIGQuc2V0VVRDRGF0ZShkLmdldFVUQ0RhdGUoKSArIGVuY29kZWQpO1xuICBkLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICByZXR1cm4gZDtcbn1cbnZhciB1dGNEYXkgPSBuZXcgQ291bnRhYmxlVGltZUludGVydmFsKGVuY29kZTEwLCBkZWNvZGUxMCk7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvdGltZS91dGNNb250aC50c1xuZnVuY3Rpb24gZW5jb2RlMTEoZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRVVENGdWxsWWVhcigpICogMTIgKyBkYXRlLmdldFVUQ01vbnRoKCk7XG59XG5mdW5jdGlvbiBkZWNvZGUxMShlbmNvZGVkKSB7XG4gIGNvbnN0IHllYXIyID0gTWF0aC5mbG9vcihlbmNvZGVkIC8gMTIpO1xuICBjb25zdCBtb250aDIgPSBlbmNvZGVkIC0geWVhcjIgKiAxMjtcbiAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKHllYXIyLCBtb250aDIsIDEpKTtcbn1cbnZhciB1dGNNb250aCA9IG5ldyBDb3VudGFibGVUaW1lSW50ZXJ2YWwoZW5jb2RlMTEsIGRlY29kZTExKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC90aW1lL3V0Y1llYXIudHNcbmZ1bmN0aW9uIGVuY29kZTEyKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0VVRDRnVsbFllYXIoKTtcbn1cbmZ1bmN0aW9uIGRlY29kZTEyKGVuY29kZWQpIHtcbiAgY29uc3QgZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICBkLnNldFVUQ0Z1bGxZZWFyKGVuY29kZWQpO1xuICBkLnNldFVUQ01vbnRoKDAsIDEpO1xuICBkLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICByZXR1cm4gZDtcbn1cbnZhciB1dGNZZWFyID0gbmV3IENvdW50YWJsZVRpbWVJbnRlcnZhbChlbmNvZGUxMiwgZGVjb2RlMTIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9tb3Rpb24vZnJvbVRvTW90aW9uLnRzXG52YXIgZnJvbVRvTW90aW9uX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGZyb21Ub01vdGlvbl9leHBvcnRzLCB7XG4gIE5PREVfVVBEQVRFX1NUQVRFX1RPX1BIQVNFX01BUFBJTkc6ICgpID0+IE5PREVfVVBEQVRFX1NUQVRFX1RPX1BIQVNFX01BUFBJTkcsXG4gIGZyb21Ub01vdGlvbjogKCkgPT4gZnJvbVRvTW90aW9uLFxuICBzdGF0aWNGcm9tVG9Nb3Rpb246ICgpID0+IHN0YXRpY0Zyb21Ub01vdGlvblxufSk7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvaWQudHNcbnZhciBJRF9NQVAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuZnVuY3Rpb24gcmVzZXRJZHMoKSB7XG4gIElEX01BUC5jbGVhcigpO1xufVxuZnVuY3Rpb24gY3JlYXRlSWQoaW5zdGFuY2UpIHtcbiAgY29uc3QgY29uc3RydWN0b3IgPSBpbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgY29uc3QgY2xhc3NOYW1lID0gT2JqZWN0Lmhhc093bihjb25zdHJ1Y3RvciwgXCJjbGFzc05hbWVcIikgPyBjb25zdHJ1Y3Rvci5jbGFzc05hbWUgOiBjb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAoIWNsYXNzTmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlICR7Y29uc3RydWN0b3J9IGlzIG1pc3NpbmcgdGhlICdjbGFzc05hbWUnIHByb3BlcnR5LmApO1xuICB9XG4gIGNvbnN0IG5leHRJZCA9IChJRF9NQVAuZ2V0KGNsYXNzTmFtZSkgPz8gMCkgKyAxO1xuICBJRF9NQVAuc2V0KGNsYXNzTmFtZSwgbmV4dElkKTtcbiAgcmV0dXJuIGAke2NsYXNzTmFtZX0tJHtuZXh0SWR9YDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVVVJRCgpIHtcbiAgcmV0dXJuIGNyeXB0by5yYW5kb21VVUlEPy4oKSA/PyBnZW5lcmF0ZVVVSUR2NCgpO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVVVUlEdjQoKSB7XG4gIGNvbnN0IHV1aWRBcnJheSA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyh1dWlkQXJyYXkpO1xuICB1dWlkQXJyYXlbNl0gPSB1dWlkQXJyYXlbNl0gJiAxNSB8IDY0O1xuICB1dWlkQXJyYXlbOF0gPSB1dWlkQXJyYXlbOF0gJiA2MyB8IDEyODtcbiAgbGV0IHV1aWQgPSBcIlwiO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHV1aWRBcnJheS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChpID09PSA0IHx8IGkgPT09IDYgfHwgaSA9PT0gOCB8fCBpID09PSAxMCkge1xuICAgICAgdXVpZCArPSBcIi1cIjtcbiAgICB9XG4gICAgdXVpZCArPSB1dWlkQXJyYXlbaV0udG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKTtcbiAgfVxuICByZXR1cm4gdXVpZDtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9pdGVyYXRvci50c1xuZnVuY3Rpb24qIGl0ZXJhdGUoLi4uaXRlcmF0b3JzKSB7XG4gIGZvciAoY29uc3QgaXRlcmF0b3Igb2YgaXRlcmF0b3JzKSB7XG4gICAgeWllbGQqIGl0ZXJhdG9yO1xuICB9XG59XG5mdW5jdGlvbiB0b0l0ZXJhYmxlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gdmFsdWUgPyB2YWx1ZSA6IFt2YWx1ZV07XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvaW50ZXJwb2xhdGluZy50c1xudmFyIGludGVycG9sYXRlID0gU3ltYm9sKFwiaW50ZXJwb2xhdGVcIik7XG52YXIgaXNJbnRlcnBvbGF0aW5nID0gKHgpID0+IHhbaW50ZXJwb2xhdGVdICE9IG51bGw7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvbmVhcmVzdC50c1xuZnVuY3Rpb24gbmVhcmVzdFNxdWFyZWQoeCwgeSwgb2JqZWN0cywgbWF4RGlzdGFuY2VTcXVhcmVkID0gSW5maW5pdHkpIHtcbiAgY29uc3QgcmVzdWx0ID0geyBuZWFyZXN0OiB2b2lkIDAsIGRpc3RhbmNlU3F1YXJlZDogbWF4RGlzdGFuY2VTcXVhcmVkIH07XG4gIGZvciAoY29uc3Qgb2JqIG9mIG9iamVjdHMpIHtcbiAgICBjb25zdCB0aGlzRGlzdGFuY2UgPSBvYmouZGlzdGFuY2VTcXVhcmVkKHgsIHkpO1xuICAgIGlmICh0aGlzRGlzdGFuY2UgPT09IDApIHtcbiAgICAgIHJldHVybiB7IG5lYXJlc3Q6IG9iaiwgZGlzdGFuY2VTcXVhcmVkOiAwIH07XG4gICAgfSBlbHNlIGlmICh0aGlzRGlzdGFuY2UgPCByZXN1bHQuZGlzdGFuY2VTcXVhcmVkKSB7XG4gICAgICByZXN1bHQubmVhcmVzdCA9IG9iajtcbiAgICAgIHJlc3VsdC5kaXN0YW5jZVNxdWFyZWQgPSB0aGlzRGlzdGFuY2U7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBuZWFyZXN0U3F1YXJlZEluQ29udGFpbmVyKHgsIHksIGNvbnRhaW5lciwgbWF4RGlzdGFuY2VTcXVhcmVkID0gSW5maW5pdHkpIHtcbiAgY29uc3QgeyB4OiB0eCA9IHgsIHk6IHR5ID0geSB9ID0gY29udGFpbmVyLnRyYW5zZm9ybVBvaW50Py4oeCwgeSkgPz8ge307XG4gIGNvbnN0IHJlc3VsdCA9IHsgbmVhcmVzdDogdm9pZCAwLCBkaXN0YW5jZVNxdWFyZWQ6IG1heERpc3RhbmNlU3F1YXJlZCB9O1xuICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNvbnRhaW5lci5jaGlsZHJlbikge1xuICAgIGNvbnN0IHsgbmVhcmVzdCwgZGlzdGFuY2VTcXVhcmVkOiBkaXN0YW5jZVNxdWFyZWQzIH0gPSBjaGlsZC5uZWFyZXN0U3F1YXJlZCh0eCwgdHksIHJlc3VsdC5kaXN0YW5jZVNxdWFyZWQpO1xuICAgIGlmIChkaXN0YW5jZVNxdWFyZWQzID09PSAwKSB7XG4gICAgICByZXR1cm4geyBuZWFyZXN0LCBkaXN0YW5jZVNxdWFyZWQ6IGRpc3RhbmNlU3F1YXJlZDMgfTtcbiAgICB9IGVsc2UgaWYgKGRpc3RhbmNlU3F1YXJlZDMgPCByZXN1bHQuZGlzdGFuY2VTcXVhcmVkKSB7XG4gICAgICByZXN1bHQubmVhcmVzdCA9IG5lYXJlc3Q7XG4gICAgICByZXN1bHQuZGlzdGFuY2VTcXVhcmVkID0gZGlzdGFuY2VTcXVhcmVkMztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9kb20udHNcbnZhciB2ZXJpZmllZEdsb2JhbHMgPSB7fTtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIHZlcmlmaWVkR2xvYmFscy53aW5kb3cgPSB3aW5kb3c7XG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgdmVyaWZpZWRHbG9iYWxzLndpbmRvdyA9IGdsb2JhbC53aW5kb3c7XG59XG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIHZlcmlmaWVkR2xvYmFscy5kb2N1bWVudCA9IGRvY3VtZW50O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIHZlcmlmaWVkR2xvYmFscy5kb2N1bWVudCA9IGdsb2JhbC5kb2N1bWVudDtcbn1cbmZ1bmN0aW9uIGdldERvY3VtZW50KHByb3BlcnR5TmFtZSkge1xuICByZXR1cm4gcHJvcGVydHlOYW1lID8gdmVyaWZpZWRHbG9iYWxzLmRvY3VtZW50Py5bcHJvcGVydHlOYW1lXSA6IHZlcmlmaWVkR2xvYmFscy5kb2N1bWVudDtcbn1cbmZ1bmN0aW9uIGdldFdpbmRvdyhwcm9wZXJ0eU5hbWUpIHtcbiAgcmV0dXJuIHByb3BlcnR5TmFtZSA/IHZlcmlmaWVkR2xvYmFscy53aW5kb3c/Lltwcm9wZXJ0eU5hbWVdIDogdmVyaWZpZWRHbG9iYWxzLndpbmRvdztcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodGFnTmFtZSwgY2xhc3NOYW1lLCBzdHlsZSkge1xuICBjb25zdCBlbGVtZW50MiA9IGdldERvY3VtZW50KCkuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgaWYgKHR5cGVvZiBjbGFzc05hbWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICBzdHlsZSA9IGNsYXNzTmFtZTtcbiAgICBjbGFzc05hbWUgPSB2b2lkIDA7XG4gIH1cbiAgaWYgKGNsYXNzTmFtZSkge1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBjbGFzc05hbWUuc3BsaXQoXCIgXCIpKSB7XG4gICAgICBlbGVtZW50Mi5jbGFzc0xpc3QuYWRkKG5hbWUpO1xuICAgIH1cbiAgfVxuICBpZiAoc3R5bGUpIHtcbiAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQyLnN0eWxlLCBzdHlsZSk7XG4gIH1cbiAgcmV0dXJuIGVsZW1lbnQyO1xufVxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZVVSSSwgcXVhbGlmaWVkTmFtZSkge1xuICByZXR1cm4gZ2V0RG9jdW1lbnQoKS5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlVVJJLCBxdWFsaWZpZWROYW1lKTtcbn1cbmZ1bmN0aW9uIGRvd25sb2FkVXJsKGRhdGFVcmwsIGZpbGVOYW1lKSB7XG4gIGNvbnN0IHsgYm9keSB9ID0gZ2V0RG9jdW1lbnQoKTtcbiAgY29uc3QgZWxlbWVudDIgPSBjcmVhdGVFbGVtZW50KFwiYVwiLCB7IGRpc3BsYXk6IFwibm9uZVwiIH0pO1xuICBlbGVtZW50Mi5ocmVmID0gZGF0YVVybDtcbiAgZWxlbWVudDIuZG93bmxvYWQgPSBmaWxlTmFtZTtcbiAgYm9keS5hcHBlbmRDaGlsZChlbGVtZW50Mik7XG4gIGVsZW1lbnQyLmNsaWNrKCk7XG4gIHNldFRpbWVvdXQoKCkgPT4gYm9keS5yZW1vdmVDaGlsZChlbGVtZW50MikpO1xufVxuZnVuY3Rpb24gc2V0RG9jdW1lbnQoZG9jdW1lbnQyKSB7XG4gIHZlcmlmaWVkR2xvYmFscy5kb2N1bWVudCA9IGRvY3VtZW50Mjtcbn1cbmZ1bmN0aW9uIHNldFdpbmRvdyh3aW5kb3cyKSB7XG4gIHZlcmlmaWVkR2xvYmFscy53aW5kb3cgPSB3aW5kb3cyO1xufVxuZnVuY3Rpb24gc2V0RWxlbWVudEJCb3goZWxlbWVudDIsIGJib3gpIHtcbiAgaWYgKGVsZW1lbnQyKSB7XG4gICAgZWxlbWVudDIuc3R5bGUud2lkdGggPSBgJHtiYm94LndpZHRofXB4YDtcbiAgICBlbGVtZW50Mi5zdHlsZS5oZWlnaHQgPSBgJHtiYm94LmhlaWdodH1weGA7XG4gICAgZWxlbWVudDIuc3R5bGUubGVmdCA9IGAke2Jib3gueH1weGA7XG4gICAgZWxlbWVudDIuc3R5bGUudG9wID0gYCR7YmJveC55fXB4YDtcbiAgfVxufVxuZnVuY3Rpb24gZm9jdXNDdXJzb3JBdEVuZChlbGVtZW50Mikge1xuICBlbGVtZW50Mi5mb2N1cyh7IHByZXZlbnRTY3JvbGw6IHRydWUgfSk7XG4gIGlmIChlbGVtZW50Mi5sYXN0Q2hpbGQ/LnRleHRDb250ZW50ID09IG51bGwpXG4gICAgcmV0dXJuO1xuICBjb25zdCByYW5nZTMgPSBnZXREb2N1bWVudCgpLmNyZWF0ZVJhbmdlKCk7XG4gIHJhbmdlMy5zZXRTdGFydChlbGVtZW50Mi5sYXN0Q2hpbGQsIGVsZW1lbnQyLmxhc3RDaGlsZC50ZXh0Q29udGVudC5sZW5ndGgpO1xuICByYW5nZTMuc2V0RW5kKGVsZW1lbnQyLmxhc3RDaGlsZCwgZWxlbWVudDIubGFzdENoaWxkLnRleHRDb250ZW50Lmxlbmd0aCk7XG4gIGNvbnN0IHNlbGVjdGlvbiA9IGdldFdpbmRvdygpLmdldFNlbGVjdGlvbigpO1xuICBzZWxlY3Rpb24/LnJlbW92ZUFsbFJhbmdlcygpO1xuICBzZWxlY3Rpb24/LmFkZFJhbmdlKHJhbmdlMyk7XG59XG52YXIgX2lkID0gMDtcbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRJZChsYWJlbCkge1xuICByZXR1cm4gYCR7bGFiZWwgPz8gXCJhZy1jaGFydHMtZWxlbWVudFwifS0ke19pZCsrfWA7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvbnVtYmVyLnRzXG5mdW5jdGlvbiBjbGFtcChtaW4sIHZhbHVlLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGgubWluKG1heCwgTWF0aC5tYXgobWluLCB2YWx1ZSkpO1xufVxuZnVuY3Rpb24gY2xhbXBBcnJheSh2YWx1ZSwgYXJyYXkyKSB7XG4gIGNvbnN0IFttaW4sIG1heF0gPSBmaW5kTWluTWF4KGFycmF5Mik7XG4gIHJldHVybiBjbGFtcChtaW4sIHZhbHVlLCBtYXgpO1xufVxuZnVuY3Rpb24gZmluZE1pbk1heChhcnJheTIpIHtcbiAgaWYgKGFycmF5Mi5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIFtdO1xuICBjb25zdCByZXN1bHQgPSBbSW5maW5pdHksIC1JbmZpbml0eV07XG4gIGZvciAoY29uc3QgdmFsIG9mIGFycmF5Mikge1xuICAgIGlmICh2YWwgPCByZXN1bHRbMF0pXG4gICAgICByZXN1bHRbMF0gPSB2YWw7XG4gICAgaWYgKHZhbCA+IHJlc3VsdFsxXSlcbiAgICAgIHJlc3VsdFsxXSA9IHZhbDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZmluZFJhbmdlRXh0ZW50KGFycmF5Mikge1xuICBjb25zdCBbbWluLCBtYXhdID0gZmluZE1pbk1heChhcnJheTIpO1xuICByZXR1cm4gbWF4IC0gbWluO1xufVxuZnVuY3Rpb24gaXNFcXVhbChhLCBiLCBlcHNpbG9uMiA9IDFlLTEwKSB7XG4gIHJldHVybiBNYXRoLmFicyhhIC0gYikgPCBlcHNpbG9uMjtcbn1cbmZ1bmN0aW9uIGlzTmVnYXRpdmUodmFsdWUpIHtcbiAgcmV0dXJuIE1hdGguc2lnbih2YWx1ZSkgPT09IC0xIHx8IE9iamVjdC5pcyh2YWx1ZSwgLTApO1xufVxuZnVuY3Rpb24gcm91bmQodmFsdWUsIGRlY2ltYWxzID0gMikge1xuICBjb25zdCBiYXNlID0gMTAgKiogZGVjaW1hbHM7XG4gIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogYmFzZSkgLyBiYXNlO1xufVxuZnVuY3Rpb24gdG9GaXhlZCh2YWx1ZSwgZnJhY3Rpb25PclNpZ25pZmljYW50RGlnaXRzID0gMikge1xuICBjb25zdCBwb3dlciA9IE1hdGguZmxvb3IoTWF0aC5sb2coTWF0aC5hYnModmFsdWUpKSAvIE1hdGguTE4xMCk7XG4gIGlmIChwb3dlciA+PSAwIHx8ICFpc0Zpbml0ZShwb3dlcikpIHtcbiAgICByZXR1cm4gdmFsdWUudG9GaXhlZChmcmFjdGlvbk9yU2lnbmlmaWNhbnREaWdpdHMpO1xuICB9XG4gIHJldHVybiB2YWx1ZS50b0ZpeGVkKE1hdGguYWJzKHBvd2VyKSAtIDEgKyBmcmFjdGlvbk9yU2lnbmlmaWNhbnREaWdpdHMpO1xufVxuZnVuY3Rpb24gbW9kKG4sIG0pIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IobiAlIG0gKyAobiA8IDAgPyBtIDogMCkpO1xufVxuZnVuY3Rpb24gY291bnRGcmFjdGlvbkRpZ2l0cyh2YWx1ZSkge1xuICBpZiAoTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlKVxuICAgIHJldHVybiAwO1xuICBsZXQgdmFsdWVTdHJpbmcgPSBTdHJpbmcodmFsdWUpO1xuICBsZXQgZXhwb25lbnQgPSAwO1xuICBpZiAodmFsdWUgPCAxZS02IHx8IHZhbHVlID49IDFlMjEpIHtcbiAgICBsZXQgZXhwb25lbnRTdHJpbmc7XG4gICAgW3ZhbHVlU3RyaW5nLCBleHBvbmVudFN0cmluZ10gPSB2YWx1ZVN0cmluZy5zcGxpdChcImVcIik7XG4gICAgaWYgKGV4cG9uZW50U3RyaW5nICE9IG51bGwpIHtcbiAgICAgIGV4cG9uZW50ID0gTnVtYmVyKGV4cG9uZW50U3RyaW5nKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZGVjaW1hbFBsYWNlczIgPSB2YWx1ZVN0cmluZy5zcGxpdChcIi5cIilbMV0/Lmxlbmd0aCA/PyAwO1xuICByZXR1cm4gTWF0aC5tYXgoZGVjaW1hbFBsYWNlczIgLSBleHBvbmVudCwgMCk7XG59XG5mdW5jdGlvbiBmb3JtYXROb3JtYWxpemVkUGVyY2VudGFnZShyYXRpbzIsIGxvY2FsZSkge1xuICBsb2NhbGUgPSBsb2NhbGUgPz8gZ2V0V2luZG93KFwibmF2aWdhdG9yXCIpLmxhbmd1YWdlO1xuICByZXR1cm4gbmV3IEludGwuTnVtYmVyRm9ybWF0KGxvY2FsZSwge1xuICAgIHN0eWxlOiBcInBlcmNlbnRcIixcbiAgICBtaW5pbXVtRnJhY3Rpb25EaWdpdHM6IDIsXG4gICAgbWF4aW11bUZyYWN0aW9uRGlnaXRzOiAyXG4gIH0pLmZvcm1hdChyYXRpbzIpO1xufVxuZnVuY3Rpb24gZm9ybWF0UGVyY2VudGFnZShwZXJjZW50LCBsb2NhbGUpIHtcbiAgcmV0dXJuIGZvcm1hdE5vcm1hbGl6ZWRQZXJjZW50YWdlKHBlcmNlbnQgLyAxMDAsIGxvY2FsZSk7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL2Jib3gudHNcbnZhciBfQkJveCA9IGNsYXNzIF9CQm94IHtcbiAgY29uc3RydWN0b3IoeCwgeSwgd2lkdGgyLCBoZWlnaHQyKSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDI7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQyO1xuICB9XG4gIHN0YXRpYyBmcm9tRE9NUmVjdCh7IHgsIHksIHdpZHRoOiB3aWR0aDIsIGhlaWdodDogaGVpZ2h0MiB9KSB7XG4gICAgcmV0dXJuIG5ldyBfQkJveCh4LCB5LCB3aWR0aDIsIGhlaWdodDIpO1xuICB9XG4gIHRvRE9NUmVjdCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogdGhpcy54LFxuICAgICAgeTogdGhpcy55LFxuICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgdG9wOiB0aGlzLnksXG4gICAgICBsZWZ0OiB0aGlzLngsXG4gICAgICByaWdodDogdGhpcy54ICsgdGhpcy53aWR0aCxcbiAgICAgIGJvdHRvbTogdGhpcy55ICsgdGhpcy5oZWlnaHQsXG4gICAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGNsb25lKCkge1xuICAgIGNvbnN0IHsgeCwgeSwgd2lkdGg6IHdpZHRoMiwgaGVpZ2h0OiBoZWlnaHQyIH0gPSB0aGlzO1xuICAgIHJldHVybiBuZXcgX0JCb3goeCwgeSwgd2lkdGgyLCBoZWlnaHQyKTtcbiAgfVxuICBlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy54ID09PSBvdGhlci54ICYmIHRoaXMueSA9PT0gb3RoZXIueSAmJiB0aGlzLndpZHRoID09PSBvdGhlci53aWR0aCAmJiB0aGlzLmhlaWdodCA9PT0gb3RoZXIuaGVpZ2h0O1xuICB9XG4gIGNvbnRhaW5zUG9pbnQoeCwgeSkge1xuICAgIHJldHVybiB4ID49IHRoaXMueCAmJiB4IDw9IHRoaXMueCArIHRoaXMud2lkdGggJiYgeSA+PSB0aGlzLnkgJiYgeSA8PSB0aGlzLnkgKyB0aGlzLmhlaWdodDtcbiAgfVxuICBpbnRlcnNlY3Rpb24ob3RoZXIpIHtcbiAgICBpZiAoIXRoaXMuY29sbGlkZXNCQm94KG90aGVyKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBuZXdYMSA9IGNsYW1wKG90aGVyLngsIHRoaXMueCwgb3RoZXIueCArIG90aGVyLndpZHRoKTtcbiAgICBjb25zdCBuZXdZMSA9IGNsYW1wKG90aGVyLnksIHRoaXMueSwgb3RoZXIueSArIG90aGVyLmhlaWdodCk7XG4gICAgY29uc3QgbmV3WDIgPSBjbGFtcChvdGhlci54LCB0aGlzLnggKyB0aGlzLndpZHRoLCBvdGhlci54ICsgb3RoZXIud2lkdGgpO1xuICAgIGNvbnN0IG5ld1kyID0gY2xhbXAob3RoZXIueSwgdGhpcy55ICsgdGhpcy5oZWlnaHQsIG90aGVyLnkgKyBvdGhlci5oZWlnaHQpO1xuICAgIHJldHVybiBuZXcgX0JCb3gobmV3WDEsIG5ld1kxLCBuZXdYMiAtIG5ld1gxLCBuZXdZMiAtIG5ld1kxKTtcbiAgfVxuICBjb2xsaWRlc0JCb3gob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy54IDwgb3RoZXIueCArIG90aGVyLndpZHRoICYmIHRoaXMueCArIHRoaXMud2lkdGggPiBvdGhlci54ICYmIHRoaXMueSA8IG90aGVyLnkgKyBvdGhlci5oZWlnaHQgJiYgdGhpcy55ICsgdGhpcy5oZWlnaHQgPiBvdGhlci55O1xuICB9XG4gIGNvbXB1dGVDZW50ZXIoKSB7XG4gICAgcmV0dXJuIHsgeDogdGhpcy54ICsgdGhpcy53aWR0aCAvIDIsIHk6IHRoaXMueSArIHRoaXMuaGVpZ2h0IC8gMiB9O1xuICB9XG4gIGlzRmluaXRlKCkge1xuICAgIHJldHVybiBOdW1iZXIuaXNGaW5pdGUodGhpcy54KSAmJiBOdW1iZXIuaXNGaW5pdGUodGhpcy55KSAmJiBOdW1iZXIuaXNGaW5pdGUodGhpcy53aWR0aCkgJiYgTnVtYmVyLmlzRmluaXRlKHRoaXMuaGVpZ2h0KTtcbiAgfVxuICBkaXN0YW5jZVNxdWFyZWQoeCwgeSkge1xuICAgIGlmICh0aGlzLmNvbnRhaW5zUG9pbnQoeCwgeSkpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBjb25zdCBkeCA9IHggLSBjbGFtcCh0aGlzLngsIHgsIHRoaXMueCArIHRoaXMud2lkdGgpO1xuICAgIGNvbnN0IGR5ID0geSAtIGNsYW1wKHRoaXMueSwgeSwgdGhpcy55ICsgdGhpcy5oZWlnaHQpO1xuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgfVxuICBzdGF0aWMgbmVhcmVzdEJveCh4LCB5LCBib3hlcykge1xuICAgIHJldHVybiBuZWFyZXN0U3F1YXJlZCh4LCB5LCBib3hlcyk7XG4gIH1cbiAgY2xpcChjbGlwUmVjdCkge1xuICAgIGlmIChjbGlwUmVjdCA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgeDEgPSBNYXRoLm1heCh0aGlzLngsIGNsaXBSZWN0LngpO1xuICAgIGNvbnN0IHkxID0gTWF0aC5tYXgodGhpcy55LCBjbGlwUmVjdC55KTtcbiAgICBjb25zdCB4MiA9IE1hdGgubWluKHRoaXMueCArIHRoaXMud2lkdGgsIGNsaXBSZWN0LnggKyBjbGlwUmVjdC53aWR0aCk7XG4gICAgY29uc3QgeTIgPSBNYXRoLm1pbih0aGlzLnkgKyB0aGlzLmhlaWdodCwgY2xpcFJlY3QueSArIGNsaXBSZWN0LmhlaWdodCk7XG4gICAgdGhpcy54ID0geDE7XG4gICAgdGhpcy55ID0geTE7XG4gICAgdGhpcy53aWR0aCA9IE1hdGgubWF4KDAsIHgyIC0geDEpO1xuICAgIHRoaXMuaGVpZ2h0ID0gTWF0aC5tYXgoMCwgeTIgLSB5MSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2hyaW5rKGFtb3VudCwgcG9zaXRpb24pIHtcbiAgICBjb25zdCBhcHBseTIgPSAocG9zLCBhbXQpID0+IHtcbiAgICAgIHN3aXRjaCAocG9zKSB7XG4gICAgICAgIGNhc2UgXCJ0b3BcIjpcbiAgICAgICAgICB0aGlzLnkgKz0gYW10O1xuICAgICAgICBjYXNlIFwiYm90dG9tXCI6XG4gICAgICAgICAgdGhpcy5oZWlnaHQgLT0gYW10O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgICAgIHRoaXMueCArPSBhbXQ7XG4gICAgICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgICAgIHRoaXMud2lkdGggLT0gYW10O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwidmVydGljYWxcIjpcbiAgICAgICAgICB0aGlzLnkgKz0gYW10O1xuICAgICAgICAgIHRoaXMuaGVpZ2h0IC09IGFtdCAqIDI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJob3Jpem9udGFsXCI6XG4gICAgICAgICAgdGhpcy54ICs9IGFtdDtcbiAgICAgICAgICB0aGlzLndpZHRoIC09IGFtdCAqIDI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugdm9pZCAwOlxuICAgICAgICAgIHRoaXMueCArPSBhbXQ7XG4gICAgICAgICAgdGhpcy53aWR0aCAtPSBhbXQgKiAyO1xuICAgICAgICAgIHRoaXMueSArPSBhbXQ7XG4gICAgICAgICAgdGhpcy5oZWlnaHQgLT0gYW10ICogMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmICh0eXBlb2YgYW1vdW50ID09PSBcIm51bWJlclwiKSB7XG4gICAgICBhcHBseTIocG9zaXRpb24sIGFtb3VudCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYW1vdW50ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBPYmplY3QuZW50cmllcyhhbW91bnQpLmZvckVhY2goKFtwb3MsIGFtdF0pID0+IGFwcGx5Mihwb3MsIGFtdCkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBncm93KGFtb3VudCwgcG9zaXRpb24pIHtcbiAgICBpZiAodHlwZW9mIGFtb3VudCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgdGhpcy5zaHJpbmsoLWFtb3VudCwgcG9zaXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwYWRkaW5nQ29weSA9IHsgLi4uYW1vdW50IH07XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYWRkaW5nQ29weSkge1xuICAgICAgICBwYWRkaW5nQ29weVtrZXldICo9IC0xO1xuICAgICAgfVxuICAgICAgdGhpcy5zaHJpbmsocGFkZGluZ0NvcHkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB0cmFuc2xhdGUoeCwgeSkge1xuICAgIHRoaXMueCArPSB4O1xuICAgIHRoaXMueSArPSB5O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGNvbWJpbmUob3RoZXIpIHtcbiAgICBjb25zdCB7IHgsIHksIHdpZHRoOiB3aWR0aDIsIGhlaWdodDogaGVpZ2h0MiB9ID0gdGhpcztcbiAgICB0aGlzLnggPSBNYXRoLm1pbih4LCBvdGhlci54KTtcbiAgICB0aGlzLnkgPSBNYXRoLm1pbih5LCBvdGhlci55KTtcbiAgICB0aGlzLndpZHRoID0gTWF0aC5tYXgoeCArIHdpZHRoMiwgb3RoZXIueCArIG90aGVyLndpZHRoKSAtIHRoaXMueDtcbiAgICB0aGlzLmhlaWdodCA9IE1hdGgubWF4KHkgKyBoZWlnaHQyLCBvdGhlci55ICsgb3RoZXIuaGVpZ2h0KSAtIHRoaXMueTtcbiAgfVxuICBzdGF0aWMgbWVyZ2UoYm94ZXMpIHtcbiAgICBsZXQgbGVmdCA9IEluZmluaXR5O1xuICAgIGxldCB0b3AgPSBJbmZpbml0eTtcbiAgICBsZXQgcmlnaHQgPSAtSW5maW5pdHk7XG4gICAgbGV0IGJvdHRvbSA9IC1JbmZpbml0eTtcbiAgICBmb3IgKGNvbnN0IGJveCBvZiBib3hlcykge1xuICAgICAgaWYgKGJveC54IDwgbGVmdCkge1xuICAgICAgICBsZWZ0ID0gYm94Lng7XG4gICAgICB9XG4gICAgICBpZiAoYm94LnkgPCB0b3ApIHtcbiAgICAgICAgdG9wID0gYm94Lnk7XG4gICAgICB9XG4gICAgICBpZiAoYm94LnggKyBib3gud2lkdGggPiByaWdodCkge1xuICAgICAgICByaWdodCA9IGJveC54ICsgYm94LndpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKGJveC55ICsgYm94LmhlaWdodCA+IGJvdHRvbSkge1xuICAgICAgICBib3R0b20gPSBib3gueSArIGJveC5oZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgX0JCb3gobGVmdCwgdG9wLCByaWdodCAtIGxlZnQsIGJvdHRvbSAtIHRvcCk7XG4gIH1cbiAgW2ludGVycG9sYXRlXShvdGhlciwgZCkge1xuICAgIHJldHVybiBuZXcgX0JCb3goXG4gICAgICB0aGlzLnggKiAoMSAtIGQpICsgb3RoZXIueCAqIGQsXG4gICAgICB0aGlzLnkgKiAoMSAtIGQpICsgb3RoZXIueSAqIGQsXG4gICAgICB0aGlzLndpZHRoICogKDEgLSBkKSArIG90aGVyLndpZHRoICogZCxcbiAgICAgIHRoaXMuaGVpZ2h0ICogKDEgLSBkKSArIG90aGVyLmhlaWdodCAqIGRcbiAgICApO1xuICB9XG59O1xuX0JCb3guemVybyA9IE9iamVjdC5mcmVlemUobmV3IF9CQm94KDAsIDAsIDAsIDApKTtcbl9CQm94Lk5hTiA9IE9iamVjdC5mcmVlemUobmV3IF9CQm94KE5hTiwgTmFOLCBOYU4sIE5hTikpO1xudmFyIEJCb3ggPSBfQkJveDtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvY2hhbmdlRGV0ZWN0YWJsZS50c1xudmFyIFJlZHJhd1R5cGUgPSAvKiBAX19QVVJFX18gKi8gKChSZWRyYXdUeXBlMikgPT4ge1xuICBSZWRyYXdUeXBlMltSZWRyYXdUeXBlMltcIk5PTkVcIl0gPSAwXSA9IFwiTk9ORVwiO1xuICBSZWRyYXdUeXBlMltSZWRyYXdUeXBlMltcIlRSSVZJQUxcIl0gPSAxXSA9IFwiVFJJVklBTFwiO1xuICBSZWRyYXdUeXBlMltSZWRyYXdUeXBlMltcIk1JTk9SXCJdID0gMl0gPSBcIk1JTk9SXCI7XG4gIFJlZHJhd1R5cGUyW1JlZHJhd1R5cGUyW1wiTUFKT1JcIl0gPSAzXSA9IFwiTUFKT1JcIjtcbiAgcmV0dXJuIFJlZHJhd1R5cGUyO1xufSkoUmVkcmF3VHlwZSB8fCB7fSk7XG5mdW5jdGlvbiBTY2VuZUNoYW5nZURldGVjdGlvbihvcHRzKSB7XG4gIHJldHVybiBmdW5jdGlvbih0YXJnZXQsIGtleSkge1xuICAgIGNvbnN0IHByaXZhdGVLZXkgPSBgX18ke2tleX1gO1xuICAgIGlmICh0YXJnZXRba2V5XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwcmVwYXJlR2V0U2V0KHRhcmdldCwga2V5LCBwcml2YXRlS2V5LCBvcHRzKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVHZXRTZXQodGFyZ2V0LCBrZXksIHByaXZhdGVLZXksIG9wdHMpIHtcbiAgY29uc3Qge1xuICAgIHJlZHJhdyA9IDEgLyogVFJJVklBTCAqLyxcbiAgICB0eXBlID0gXCJub3JtYWxcIixcbiAgICBjaGFuZ2VDYixcbiAgICBjb252ZXJ0b3IsXG4gICAgY2hlY2tEaXJ0eU9uQXNzaWdubWVudCA9IGZhbHNlXG4gIH0gPSBvcHRzID8/IHt9O1xuICBjb25zdCByZXF1aXJlZE9wdHMgPSB7IHJlZHJhdywgdHlwZSwgY2hhbmdlQ2IsIGNoZWNrRGlydHlPbkFzc2lnbm1lbnQsIGNvbnZlcnRvciB9O1xuICBsZXQgc2V0dGVyO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFwibm9ybWFsXCI6XG4gICAgICBzZXR0ZXIgPSBidWlsZE5vcm1hbFNldHRlcihwcml2YXRlS2V5LCByZXF1aXJlZE9wdHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInRyYW5zZm9ybVwiOlxuICAgICAgc2V0dGVyID0gYnVpbGRUcmFuc2Zvcm1TZXR0ZXIocHJpdmF0ZUtleSwgcmVxdWlyZWRPcHRzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJwYXRoXCI6XG4gICAgICBzZXR0ZXIgPSBidWlsZFBhdGhTZXR0ZXIocHJpdmF0ZUtleSwgcmVxdWlyZWRPcHRzKTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHNldHRlciA9IGJ1aWxkQ2hlY2tEaXJ0eUNoYWluKFxuICAgIGJ1aWxkQ2hhbmdlQ2FsbGJhY2tDaGFpbihidWlsZENvbnZlcnRvckNoYWluKHNldHRlciwgcmVxdWlyZWRPcHRzKSwgcmVxdWlyZWRPcHRzKSxcbiAgICByZXF1aXJlZE9wdHNcbiAgKTtcbiAgY29uc3QgZ2V0dGVyID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXNbcHJpdmF0ZUtleV07XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwge1xuICAgIHNldDogc2V0dGVyLFxuICAgIGdldDogZ2V0dGVyLFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuZnVuY3Rpb24gYnVpbGRDb252ZXJ0b3JDaGFpbihzZXR0ZXJGbiwgb3B0cykge1xuICBjb25zdCB7IGNvbnZlcnRvciB9ID0gb3B0cztcbiAgaWYgKGNvbnZlcnRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgc2V0dGVyRm4uY2FsbCh0aGlzLCBjb252ZXJ0b3IodmFsdWUpKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBzZXR0ZXJGbjtcbn1cbnZhciBOT19DSEFOR0UgPSBTeW1ib2woXCJuby1jaGFuZ2VcIik7XG5mdW5jdGlvbiBidWlsZENoYW5nZUNhbGxiYWNrQ2hhaW4oc2V0dGVyRm4sIG9wdHMpIHtcbiAgY29uc3QgeyBjaGFuZ2VDYiB9ID0gb3B0cztcbiAgaWYgKGNoYW5nZUNiKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBjb25zdCBjaGFuZ2UgPSBzZXR0ZXJGbi5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgIGlmIChjaGFuZ2UgIT09IE5PX0NIQU5HRSkge1xuICAgICAgICBjaGFuZ2VDYi5jYWxsKHRoaXMsIHRoaXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBzZXR0ZXJGbjtcbn1cbmZ1bmN0aW9uIGJ1aWxkQ2hlY2tEaXJ0eUNoYWluKHNldHRlckZuLCBvcHRzKSB7XG4gIGNvbnN0IHsgY2hlY2tEaXJ0eU9uQXNzaWdubWVudCB9ID0gb3B0cztcbiAgaWYgKGNoZWNrRGlydHlPbkFzc2lnbm1lbnQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGNvbnN0IGNoYW5nZSA9IHNldHRlckZuLmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgaWYgKGNoYW5nZSAhPT0gTk9fQ0hBTkdFICYmIHZhbHVlICE9IG51bGwgJiYgdmFsdWUuX2RpcnR5ID4gMCAvKiBOT05FICovKSB7XG4gICAgICAgIHRoaXMubWFya0RpcnR5KHZhbHVlLl9kaXJ0eSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2hhbmdlO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHNldHRlckZuO1xufVxuZnVuY3Rpb24gYnVpbGROb3JtYWxTZXR0ZXIocHJpdmF0ZUtleSwgb3B0cykge1xuICBjb25zdCB7IHJlZHJhdyA9IDEgLyogVFJJVklBTCAqLywgY2hhbmdlQ2IgfSA9IG9wdHM7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpc1twcml2YXRlS2V5XTtcbiAgICBpZiAodmFsdWUgIT09IG9sZFZhbHVlKSB7XG4gICAgICB0aGlzW3ByaXZhdGVLZXldID0gdmFsdWU7XG4gICAgICB0aGlzLm1hcmtEaXJ0eShyZWRyYXcpO1xuICAgICAgY2hhbmdlQ2I/Lih0aGlzKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIE5PX0NIQU5HRTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkVHJhbnNmb3JtU2V0dGVyKHByaXZhdGVLZXksIG9wdHMpIHtcbiAgY29uc3QgeyByZWRyYXcgPSAxIC8qIFRSSVZJQUwgKi8gfSA9IG9wdHM7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpc1twcml2YXRlS2V5XTtcbiAgICBpZiAodmFsdWUgIT09IG9sZFZhbHVlKSB7XG4gICAgICB0aGlzW3ByaXZhdGVLZXldID0gdmFsdWU7XG4gICAgICB0aGlzLm1hcmtEaXJ0eVRyYW5zZm9ybShyZWRyYXcpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gTk9fQ0hBTkdFO1xuICB9O1xufVxuZnVuY3Rpb24gYnVpbGRQYXRoU2V0dGVyKHByaXZhdGVLZXksIG9wdHMpIHtcbiAgY29uc3QgeyByZWRyYXcgPSAxIC8qIFRSSVZJQUwgKi8gfSA9IG9wdHM7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpc1twcml2YXRlS2V5XTtcbiAgICBpZiAodmFsdWUgIT09IG9sZFZhbHVlKSB7XG4gICAgICB0aGlzW3ByaXZhdGVLZXldID0gdmFsdWU7XG4gICAgICBpZiAoIXRoaXMuX2RpcnR5UGF0aCkge1xuICAgICAgICB0aGlzLl9kaXJ0eVBhdGggPSB0cnVlO1xuICAgICAgICB0aGlzLm1hcmtEaXJ0eShyZWRyYXcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gTk9fQ0hBTkdFO1xuICB9O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9ub2RlLnRzXG52YXIgUG9pbnRlckV2ZW50cyA9IC8qIEBfX1BVUkVfXyAqLyAoKFBvaW50ZXJFdmVudHMyKSA9PiB7XG4gIFBvaW50ZXJFdmVudHMyW1BvaW50ZXJFdmVudHMyW1wiQWxsXCJdID0gMF0gPSBcIkFsbFwiO1xuICBQb2ludGVyRXZlbnRzMltQb2ludGVyRXZlbnRzMltcIk5vbmVcIl0gPSAxXSA9IFwiTm9uZVwiO1xuICByZXR1cm4gUG9pbnRlckV2ZW50czI7XG59KShQb2ludGVyRXZlbnRzIHx8IHt9KTtcbnZhciBfTm9kZSA9IGNsYXNzIF9Ob2RlIHtcbiAgLy8gRGlzY3JpbWluYXRvcnMgZm9yIHJlbmRlciBvcmRlciB3aXRoaW4gYSB6SW5kZXhcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIC8qKiBVbmlxdWUgbnVtYmVyIHRvIGFsbG93IGNyZWF0aW9uIG9yZGVyIHRvIGJlIGVhc2lseSBkZXRlcm1pbmVkLiAqL1xuICAgIHRoaXMuc2VyaWFsTnVtYmVyID0gX05vZGUuX25leHRTZXJpYWxOdW1iZXIrKztcbiAgICB0aGlzLmNoaWxkTm9kZUNvdW50cyA9IHsgZ3JvdXBzOiAwLCBub25Hcm91cHM6IDAgfTtcbiAgICAvKiogVW5pcXVlIG5vZGUgSUQgaW4gdGhlIGZvcm0gYENsYXNzTmFtZS1OYXR1cmFsTnVtYmVyYC4gKi9cbiAgICB0aGlzLmlkID0gY3JlYXRlSWQodGhpcyk7XG4gICAgdGhpcy5wb2ludGVyRXZlbnRzID0gMCAvKiBBbGwgKi87XG4gICAgdGhpcy5fZGlydHkgPSAzIC8qIE1BSk9SICovO1xuICAgIHRoaXMuZGlydHlaSW5kZXggPSBmYWxzZTtcbiAgICB0aGlzLnZpcnR1YWxDaGlsZHJlbkNvdW50ID0gMDtcbiAgICAvKipcbiAgICAgKiBUbyBzaW1wbGlmeSB0aGUgdHlwZSBzeXN0ZW0gKGVzcGVjaWFsbHkgaW4gU2VsZWN0aW9ucykgd2UgZG9uJ3QgaGF2ZSB0aGUgYFBhcmVudGAgbm9kZVxuICAgICAqIChvbmUgdGhhdCBoYXMgY2hpbGRyZW4pLiBJbnN0ZWFkLCB3ZSBtaW1pYyBIVE1MIERPTSwgd2hlcmUgYW55IG5vZGUgY2FuIGhhdmUgY2hpbGRyZW4uXG4gICAgICogQnV0IHdlIHN0aWxsIG5lZWQgdG8gZGlzdGluZ3Vpc2ggcmVndWxhciBsZWFmIG5vZGVzIGZyb20gY29udGFpbmVyIGxlYWZzIHNvbWVob3cuXG4gICAgICovXG4gICAgdGhpcy5pc0NvbnRhaW5lck5vZGUgPSBmYWxzZTtcbiAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuICAgIHRoaXMuekluZGV4ID0gMDtcbiAgICB0aGlzLnpJbmRleFN1Yk9yZGVyID0gdm9pZCAwO1xuICAgIHRoaXMubmFtZSA9IG9wdGlvbnM/Lm5hbWU7XG4gICAgdGhpcy5pc1ZpcnR1YWwgPSBvcHRpb25zPy5pc1ZpcnR1YWwgPz8gZmFsc2U7XG4gICAgdGhpcy50YWcgPSBvcHRpb25zPy50YWcgPz8gTmFOO1xuICAgIHRoaXMuekluZGV4ID0gb3B0aW9ucz8uekluZGV4ID8/IDA7XG4gIH1cbiAgc3RhdGljICpleHRyYWN0QkJveGVzKG5vZGVzLCBza2lwSW52aXNpYmxlKSB7XG4gICAgZm9yIChjb25zdCBuIG9mIG5vZGVzKSB7XG4gICAgICBpZiAoIXNraXBJbnZpc2libGUgfHwgbi52aXNpYmxlICYmICFuLnRyYW5zaXRpb25PdXQpIHtcbiAgICAgICAgY29uc3QgYmJveCA9IG4uZ2V0QkJveCgpO1xuICAgICAgICBpZiAoYmJveClcbiAgICAgICAgICB5aWVsZCBiYm94O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogU29tZSBhcmJpdHJhcnkgZGF0YSBib3VuZCB0byB0aGUgbm9kZS5cbiAgICovXG4gIGdldCBkYXR1bSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0dW0gPz8gdGhpcy5wYXJlbnROb2RlPy5kYXR1bTtcbiAgfVxuICBzZXQgZGF0dW0oZGF0dW0pIHtcbiAgICBpZiAodGhpcy5fZGF0dW0gIT09IGRhdHVtKSB7XG4gICAgICB0aGlzLl9wcmV2aW91c0RhdHVtID0gdGhpcy5fZGF0dW07XG4gICAgICB0aGlzLl9kYXR1bSA9IGRhdHVtO1xuICAgIH1cbiAgfVxuICBnZXQgcHJldmlvdXNEYXR1bSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJldmlvdXNEYXR1bTtcbiAgfVxuICBnZXQgbGF5ZXJNYW5hZ2VyKCkge1xuICAgIHJldHVybiB0aGlzLl9sYXllck1hbmFnZXI7XG4gIH1cbiAgZ2V0IGRpcnR5KCkge1xuICAgIHJldHVybiB0aGlzLl9kaXJ0eTtcbiAgfVxuICAvKiogUGVyZm9ybSBhbnkgcHJlLXJlbmRlcmluZyBpbml0aWFsaXphdGlvbi4gKi9cbiAgcHJlUmVuZGVyKCkge1xuICAgIHRoaXMuY2hpbGROb2RlQ291bnRzLmdyb3VwcyA9IDA7XG4gICAgdGhpcy5jaGlsZE5vZGVDb3VudHMubm9uR3JvdXBzID0gMTtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4oKSkge1xuICAgICAgY29uc3QgY2hpbGRDb3VudHMgPSBjaGlsZC5wcmVSZW5kZXIoKTtcbiAgICAgIHRoaXMuY2hpbGROb2RlQ291bnRzLmdyb3VwcyArPSBjaGlsZENvdW50cy5ncm91cHM7XG4gICAgICB0aGlzLmNoaWxkTm9kZUNvdW50cy5ub25Hcm91cHMgKz0gY2hpbGRDb3VudHMubm9uR3JvdXBzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jaGlsZE5vZGVDb3VudHM7XG4gIH1cbiAgcmVuZGVyKHJlbmRlckN0eCkge1xuICAgIGNvbnN0IHsgc3RhdHMgfSA9IHJlbmRlckN0eDtcbiAgICB0aGlzLl9kaXJ0eSA9IDAgLyogTk9ORSAqLztcbiAgICBpZiAocmVuZGVyQ3R4LmRlYnVnTm9kZVNlYXJjaCkge1xuICAgICAgY29uc3QgaWRPck5hbWUgPSB0aGlzLm5hbWUgPz8gdGhpcy5pZDtcbiAgICAgIGlmIChyZW5kZXJDdHguZGVidWdOb2RlU2VhcmNoLnNvbWUoKHYpID0+IHR5cGVvZiB2ID09PSBcInN0cmluZ1wiID8gdiA9PT0gaWRPck5hbWUgOiB2LnRlc3QoaWRPck5hbWUpKSkge1xuICAgICAgICByZW5kZXJDdHguZGVidWdOb2Rlc1t0aGlzLm5hbWUgPz8gdGhpcy5pZF0gPSB0aGlzO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhdHMpIHtcbiAgICAgIHN0YXRzLm5vZGVzUmVuZGVyZWQrKztcbiAgICB9XG4gIH1cbiAgX3NldExheWVyTWFuYWdlcih2YWx1ZSkge1xuICAgIHRoaXMuX2xheWVyTWFuYWdlciA9IHZhbHVlO1xuICAgIHRoaXMuX2RlYnVnID0gdmFsdWU/LmRlYnVnO1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbihmYWxzZSkpIHtcbiAgICAgIGNoaWxkLl9zZXRMYXllck1hbmFnZXIodmFsdWUpO1xuICAgIH1cbiAgfVxuICBzb3J0Q2hpbGRyZW4oY29tcGFyZUZuKSB7XG4gICAgdGhpcy5kaXJ0eVpJbmRleCA9IGZhbHNlO1xuICAgIGlmICghdGhpcy5jaGlsZE5vZGVzKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICh0aGlzLmhhc1ZpcnR1YWxDaGlsZHJlbigpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHNvcnRlZENoaWxkcmVuID0gWy4uLnRoaXMuY2hpbGROb2Rlc10uc29ydChjb21wYXJlRm4pO1xuICAgIHRoaXMuY2hpbGROb2Rlcy5jbGVhcigpO1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2Ygc29ydGVkQ2hpbGRyZW4pIHtcbiAgICAgIHRoaXMuY2hpbGROb2Rlcy5hZGQoY2hpbGQpO1xuICAgIH1cbiAgfVxuICAqdHJhdmVyc2VVcChpbmNsdWRlU2VsZikge1xuICAgIGxldCBub2RlID0gdGhpcztcbiAgICBpZiAoaW5jbHVkZVNlbGYpIHtcbiAgICAgIHlpZWxkIG5vZGU7XG4gICAgfVxuICAgIHdoaWxlIChub2RlID0gbm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICB5aWVsZCBub2RlO1xuICAgIH1cbiAgfVxuICAqY2hpbGRyZW4oZmxhdHRlblZpcnR1YWwgPSB0cnVlKSB7XG4gICAgaWYgKCF0aGlzLmNoaWxkTm9kZXMpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdmlydHVhbENoaWxkcmVuID0gW107XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLmNoaWxkTm9kZXMpIHtcbiAgICAgIGlmIChmbGF0dGVuVmlydHVhbCAmJiBjaGlsZC5pc1ZpcnR1YWwpIHtcbiAgICAgICAgdmlydHVhbENoaWxkcmVuLnB1c2goY2hpbGQuY2hpbGRyZW4oKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5aWVsZCBjaGlsZDtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCB2Q2hpbGRyZW4gb2YgdmlydHVhbENoaWxkcmVuKSB7XG4gICAgICB5aWVsZCogdkNoaWxkcmVuO1xuICAgIH1cbiAgfVxuICAqdmlydHVhbENoaWxkcmVuKCkge1xuICAgIGlmICghdGhpcy5jaGlsZE5vZGVzIHx8ICF0aGlzLnZpcnR1YWxDaGlsZHJlbkNvdW50KVxuICAgICAgcmV0dXJuO1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5jaGlsZE5vZGVzKSB7XG4gICAgICBpZiAoY2hpbGQuaXNWaXJ0dWFsKSB7XG4gICAgICAgIHlpZWxkIGNoaWxkO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBoYXNWaXJ0dWFsQ2hpbGRyZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMudmlydHVhbENoaWxkcmVuQ291bnQgPiAwO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIG5vZGUgaXMgYSBsZWFmIChoYXMgbm8gY2hpbGRyZW4pLlxuICAgKi9cbiAgaXNMZWFmKCkge1xuICAgIHJldHVybiAhdGhpcy5jaGlsZE5vZGVzPy5zaXplO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIG5vZGUgaXMgdGhlIHJvb3QgKGhhcyBubyBwYXJlbnQpLlxuICAgKi9cbiAgaXNSb290KCkge1xuICAgIHJldHVybiAhdGhpcy5wYXJlbnROb2RlO1xuICB9XG4gIC8qKlxuICAgKiBBcHBlbmRzIG9uZSBvciBtb3JlIG5ldyBub2RlIGluc3RhbmNlcyB0byB0aGlzIHBhcmVudC5cbiAgICogSWYgb25lIG5lZWRzIHRvOlxuICAgKiAtIG1vdmUgYSBjaGlsZCB0byB0aGUgZW5kIG9mIHRoZSBsaXN0IG9mIGNoaWxkcmVuXG4gICAqIC0gbW92ZSBhIGNoaWxkIGZyb20gb25lIHBhcmVudCB0byBhbm90aGVyIChpbmNsdWRpbmcgcGFyZW50cyBpbiBvdGhlciBzY2VuZXMpXG4gICAqIG9uZSBzaG91bGQgdXNlIHRoZSB7QGxpbmsgaW5zZXJ0QmVmb3JlfSBtZXRob2QgaW5zdGVhZC5cbiAgICogQHBhcmFtIG5vZGVzIEEgbm9kZSBvciBub2RlcyB0byBhcHBlbmQuXG4gICAqL1xuICBhcHBlbmQobm9kZXMpIHtcbiAgICB0aGlzLmNoaWxkTm9kZXMgPz8gKHRoaXMuY2hpbGROb2RlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpO1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiB0b0l0ZXJhYmxlKG5vZGVzKSkge1xuICAgICAgbm9kZS5wYXJlbnROb2RlPy5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgIHRoaXMuY2hpbGROb2Rlcy5hZGQobm9kZSk7XG4gICAgICBub2RlLnBhcmVudE5vZGUgPSB0aGlzO1xuICAgICAgbm9kZS5fc2V0TGF5ZXJNYW5hZ2VyKHRoaXMubGF5ZXJNYW5hZ2VyKTtcbiAgICAgIGlmIChub2RlLmlzVmlydHVhbCkge1xuICAgICAgICB0aGlzLnZpcnR1YWxDaGlsZHJlbkNvdW50Kys7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuaW52YWxpZGF0ZUNhY2hlZEJCb3goKTtcbiAgICB0aGlzLmRpcnR5WkluZGV4ID0gdHJ1ZTtcbiAgICB0aGlzLm1hcmtEaXJ0eSgzIC8qIE1BSk9SICovKTtcbiAgfVxuICBhcHBlbmRDaGlsZChub2RlKSB7XG4gICAgdGhpcy5hcHBlbmQobm9kZSk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgcmVtb3ZlQ2hpbGQobm9kZSkge1xuICAgIGlmICghdGhpcy5jaGlsZE5vZGVzPy5kZWxldGUobm9kZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZGVsZXRlIG5vZGUucGFyZW50Tm9kZTtcbiAgICBub2RlLl9zZXRMYXllck1hbmFnZXIoKTtcbiAgICBpZiAobm9kZS5pc1ZpcnR1YWwpIHtcbiAgICAgIHRoaXMudmlydHVhbENoaWxkcmVuQ291bnQtLTtcbiAgICB9XG4gICAgdGhpcy5pbnZhbGlkYXRlQ2FjaGVkQkJveCgpO1xuICAgIHRoaXMuZGlydHlaSW5kZXggPSB0cnVlO1xuICAgIHRoaXMubWFya0RpcnR5KDMgLyogTUFKT1IgKi8pO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJlbW92ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnROb2RlPy5yZW1vdmVDaGlsZCh0aGlzKSA/PyBmYWxzZTtcbiAgfVxuICBjbGVhcigpIHtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4oZmFsc2UpKSB7XG4gICAgICBkZWxldGUgY2hpbGQucGFyZW50Tm9kZTtcbiAgICAgIGNoaWxkLl9zZXRMYXllck1hbmFnZXIoKTtcbiAgICB9XG4gICAgdGhpcy5jaGlsZE5vZGVzPy5jbGVhcigpO1xuICAgIHRoaXMuaW52YWxpZGF0ZUNhY2hlZEJCb3goKTtcbiAgICB0aGlzLnZpcnR1YWxDaGlsZHJlbkNvdW50ID0gMDtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMucGFyZW50Tm9kZT8ucmVtb3ZlQ2hpbGQodGhpcyk7XG4gIH1cbiAgc2V0UHJvcGVydGllcyhzdHlsZXMsIHBpY2tLZXlzKSB7XG4gICAgaWYgKHBpY2tLZXlzKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBwaWNrS2V5cykge1xuICAgICAgICB0aGlzW2tleV0gPSBzdHlsZXNba2V5XTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBzdHlsZXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjb250YWluc1BvaW50KF94LCBfeSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogSGl0IHRlc3RpbmcgbWV0aG9kLlxuICAgKiBSZWN1cnNpdmVseSBjaGVja3MgaWYgdGhlIGdpdmVuIHBvaW50IGlzIGluc2lkZSB0aGlzIG5vZGUgb3IgYW55IG9mIGl0cyBjaGlsZHJlbi5cbiAgICogUmV0dXJucyB0aGUgZmlyc3QgbWF0Y2hpbmcgbm9kZSBvciBgdW5kZWZpbmVkYC5cbiAgICogTm9kZXMgdGhhdCByZW5kZXIgbGF0ZXIgKHNob3cgb24gdG9wKSBhcmUgaGl0IHRlc3RlZCBmaXJzdC5cbiAgICovXG4gIHBpY2tOb2RlKHgsIHksIF9sb2NhbENvb3JkcyA9IGZhbHNlKSB7XG4gICAgaWYgKCF0aGlzLnZpc2libGUgfHwgdGhpcy5wb2ludGVyRXZlbnRzID09PSAxIC8qIE5vbmUgKi8gfHwgIXRoaXMuY29udGFpbnNQb2ludCh4LCB5KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjaGlsZHJlbiA9IFsuLi50aGlzLmNoaWxkcmVuKCldO1xuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAxZTMpIHtcbiAgICAgIGZvciAobGV0IGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICBjb25zdCBjb250YWluc1BvaW50MiA9IGNoaWxkLmNvbnRhaW5zUG9pbnQoeCwgeSk7XG4gICAgICAgIGNvbnN0IGhpdCA9IGNvbnRhaW5zUG9pbnQyID8gY2hpbGQucGlja05vZGUoeCwgeSkgOiB2b2lkIDA7XG4gICAgICAgIGlmIChoaXQpIHtcbiAgICAgICAgICByZXR1cm4gaGl0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIGZvciAobGV0IGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBoaXQgPSBjaGlsZHJlbltpXS5waWNrTm9kZSh4LCB5KTtcbiAgICAgICAgaWYgKGhpdCkge1xuICAgICAgICAgIHJldHVybiBoaXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCF0aGlzLmlzQ29udGFpbmVyTm9kZSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG4gIGludmFsaWRhdGVDYWNoZWRCQm94KCkge1xuICAgIHRoaXMuY2FjaGVkQkJveCA9IHZvaWQgMDtcbiAgICB0aGlzLnBhcmVudE5vZGU/LmludmFsaWRhdGVDYWNoZWRCQm94KCk7XG4gIH1cbiAgZ2V0QkJveCgpIHtcbiAgICBpZiAodGhpcy5jYWNoZWRCQm94ID09IG51bGwpIHtcbiAgICAgIHRoaXMuY2FjaGVkQkJveCA9IE9iamVjdC5mcmVlemUodGhpcy5jb21wdXRlQkJveCgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2FjaGVkQkJveDtcbiAgfVxuICBjb21wdXRlQkJveCgpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbWFya0RpcnR5KHR5cGUgPSAxIC8qIFRSSVZJQUwgKi8sIHBhcmVudFR5cGUgPSB0eXBlKSB7XG4gICAgY29uc3QgeyBfZGlydHkgfSA9IHRoaXM7XG4gICAgY29uc3QgZGlydHlUeXBlQmVsb3dIaWdoV2F0ZXJtYXJrID0gX2RpcnR5ID4gdHlwZSB8fCBfZGlydHkgPT09IHR5cGUgJiYgdHlwZSA9PT0gcGFyZW50VHlwZTtcbiAgICBjb25zdCBub1BhcmVudENhY2hlZEJCb3ggPSB0aGlzLmNhY2hlZEJCb3ggPT0gbnVsbDtcbiAgICBpZiAobm9QYXJlbnRDYWNoZWRCQm94ICYmIGRpcnR5VHlwZUJlbG93SGlnaFdhdGVybWFyaylcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmludmFsaWRhdGVDYWNoZWRCQm94KCk7XG4gICAgdGhpcy5fZGlydHkgPSBNYXRoLm1heChfZGlydHksIHR5cGUpO1xuICAgIGlmICh0aGlzLnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMucGFyZW50Tm9kZS5tYXJrRGlydHkocGFyZW50VHlwZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmxheWVyTWFuYWdlcikge1xuICAgICAgdGhpcy5sYXllck1hbmFnZXIubWFya0RpcnR5KCk7XG4gICAgfVxuICB9XG4gIG1hcmtDbGVhbihvcHRzKSB7XG4gICAgY29uc3QgeyBmb3JjZSA9IGZhbHNlLCByZWN1cnNpdmUgPSB0cnVlIH0gPSBvcHRzID8/IHt9O1xuICAgIGlmICh0aGlzLl9kaXJ0eSA9PT0gMCAvKiBOT05FICovICYmICFmb3JjZSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9kaXJ0eSA9IDAgLyogTk9ORSAqLztcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4oZmFsc2UpKSB7XG4gICAgICBpZiAoY2hpbGQuaXNWaXJ0dWFsID8gcmVjdXJzaXZlICE9PSBmYWxzZSA6IHJlY3Vyc2l2ZSA9PT0gdHJ1ZSkge1xuICAgICAgICBjaGlsZC5tYXJrQ2xlYW4oeyBmb3JjZSB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgb25WaXNpYmxlQ2hhbmdlKCkge1xuICB9XG4gIG9uWkluZGV4Q2hhbmdlKCkge1xuICAgIGlmICh0aGlzLnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMucGFyZW50Tm9kZS5kaXJ0eVpJbmRleCA9IHRydWU7XG4gICAgfVxuICB9XG4gIHRvU1ZHKCkge1xuICAgIHJldHVybjtcbiAgfVxufTtcbl9Ob2RlLl9uZXh0U2VyaWFsTnVtYmVyID0gMDtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHtcbiAgICByZWRyYXc6IDMgLyogTUFKT1IgKi8sXG4gICAgY2hhbmdlQ2I6ICh0YXJnZXQpID0+IHRhcmdldC5vblZpc2libGVDaGFuZ2UoKVxuICB9KVxuXSwgX05vZGUucHJvdG90eXBlLCBcInZpc2libGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7XG4gICAgcmVkcmF3OiAxIC8qIFRSSVZJQUwgKi8sXG4gICAgY2hhbmdlQ2I6ICh0YXJnZXQpID0+IHRhcmdldC5vblpJbmRleENoYW5nZSgpXG4gIH0pXG5dLCBfTm9kZS5wcm90b3R5cGUsIFwiekluZGV4XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oe1xuICAgIHJlZHJhdzogMSAvKiBUUklWSUFMICovLFxuICAgIGNoYW5nZUNiOiAodGFyZ2V0KSA9PiB0YXJnZXQub25aSW5kZXhDaGFuZ2UoKVxuICB9KVxuXSwgX05vZGUucHJvdG90eXBlLCBcInpJbmRleFN1Yk9yZGVyXCIsIDIpO1xudmFyIE5vZGUgPSBfTm9kZTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9jb2xvci50c1xudmFyIGxlcnAgPSAoeCwgeSwgdCkgPT4geCAqICgxIC0gdCkgKyB5ICogdDtcbnZhciBzcmdiVG9MaW5lYXIgPSAodmFsdWUpID0+IHtcbiAgY29uc3Qgc2lnbiA9IHZhbHVlIDwgMCA/IC0xIDogMTtcbiAgY29uc3QgYWJzID0gTWF0aC5hYnModmFsdWUpO1xuICBpZiAoYWJzIDw9IDAuMDQwNDUpXG4gICAgcmV0dXJuIHZhbHVlIC8gMTIuOTI7XG4gIHJldHVybiBzaWduICogKChhYnMgKyAwLjA1NSkgLyAxLjA1NSkgKiogMi40O1xufTtcbnZhciBzcmdiRnJvbUxpbmVhciA9ICh2YWx1ZSkgPT4ge1xuICBjb25zdCBzaWduID0gdmFsdWUgPCAwID8gLTEgOiAxO1xuICBjb25zdCBhYnMgPSBNYXRoLmFicyh2YWx1ZSk7XG4gIGlmIChhYnMgPiAzMTMwOGUtNykge1xuICAgIHJldHVybiBzaWduICogKDEuMDU1ICogYWJzICoqICgxIC8gMi40KSAtIDAuMDU1KTtcbiAgfVxuICByZXR1cm4gMTIuOTIgKiB2YWx1ZTtcbn07XG52YXIgX0NvbG9yID0gY2xhc3MgX0NvbG9yIHtcbiAgLyoqXG4gICAqIEV2ZXJ5IGNvbG9yIGNvbXBvbmVudCBzaG91bGQgYmUgaW4gdGhlIFswLCAxXSByYW5nZS5cbiAgICogU29tZSBlYXNpbmcgZnVuY3Rpb25zIChzdWNoIGFzIGVsYXN0aWMgZWFzaW5nKSBjYW4gb3ZlcnNob290IHRoZSB0YXJnZXQgdmFsdWUgYnkgc29tZSBhbW91bnQuXG4gICAqIFNvLCB3aGVuIGFuaW1hdGluZyBjb2xvcnMsIGlmIHRoZSBzb3VyY2Ugb3IgdGFyZ2V0IGNvbG9yIGNvbXBvbmVudHMgYXJlIGFscmVhZHkgbmVhclxuICAgKiBvciBhdCB0aGUgZWRnZSBvZiB0aGUgYWxsb3dlZCBbMCwgMV0gcmFuZ2UsIGl0IGlzIHBvc3NpYmxlIGZvciB0aGUgaW50ZXJtZWRpYXRlIGNvbG9yXG4gICAqIGNvbXBvbmVudCB2YWx1ZSB0byBlbmQgdXAgb3V0c2lkZSBvZiB0aGF0IHJhbmdlIG1pZC1hbmltYXRpb24uIEZvciB0aGlzIHJlYXNvbiB0aGUgY29uc3RydWN0b3JcbiAgICogcGVyZm9ybXMgcmFuZ2UgY2hlY2tpbmcvY29uc3RyYWluaW5nLlxuICAgKiBAcGFyYW0gciBSZWQgY29tcG9uZW50LlxuICAgKiBAcGFyYW0gZyBHcmVlbiBjb21wb25lbnQuXG4gICAqIEBwYXJhbSBiIEJsdWUgY29tcG9uZW50LlxuICAgKiBAcGFyYW0gYSBBbHBoYSAob3BhY2l0eSkgY29tcG9uZW50LlxuICAgKi9cbiAgY29uc3RydWN0b3IociwgZywgYiwgYSA9IDEpIHtcbiAgICB0aGlzLnIgPSBjbGFtcCgwLCByIHx8IDAsIDEpO1xuICAgIHRoaXMuZyA9IGNsYW1wKDAsIGcgfHwgMCwgMSk7XG4gICAgdGhpcy5iID0gY2xhbXAoMCwgYiB8fCAwLCAxKTtcbiAgICB0aGlzLmEgPSBjbGFtcCgwLCBhIHx8IDAsIDEpO1xuICB9XG4gIC8qKlxuICAgKiBBIGNvbG9yIHN0cmluZyBjYW4gYmUgaW4gb25lIG9mIHRoZSBmb2xsb3dpbmcgZm9ybWF0cyB0byBiZSB2YWxpZDpcbiAgICogLSAjcmdiXG4gICAqIC0gI3JyZ2diYlxuICAgKiAtIHJnYihyLCBnLCBiKVxuICAgKiAtIHJnYmEociwgZywgYiwgYSlcbiAgICogLSBDU1MgY29sb3IgbmFtZSBzdWNoIGFzICd3aGl0ZScsICdvcmFuZ2UnLCAnY3lhbicsIGV0Yy5cbiAgICovXG4gIHN0YXRpYyB2YWxpZENvbG9yU3RyaW5nKHN0cikge1xuICAgIGlmIChzdHIuaW5kZXhPZihcIiNcIikgPj0gMCkge1xuICAgICAgcmV0dXJuICEhX0NvbG9yLnBhcnNlSGV4KHN0cik7XG4gICAgfVxuICAgIGlmIChzdHIuaW5kZXhPZihcInJnYlwiKSA+PSAwKSB7XG4gICAgICByZXR1cm4gISFfQ29sb3Iuc3RyaW5nVG9SZ2JhKHN0cik7XG4gICAgfVxuICAgIHJldHVybiAhIV9Db2xvci5uYW1lVG9IZXhbc3RyLnRvTG93ZXJDYXNlKCldO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZ2l2ZW4gc3RyaW5nIGNhbiBiZSBpbiBvbmUgb2YgdGhlIGZvbGxvd2luZyBmb3JtYXRzOlxuICAgKiAtICNyZ2JcbiAgICogLSAjcnJnZ2JiXG4gICAqIC0gcmdiKHIsIGcsIGIpXG4gICAqIC0gcmdiYShyLCBnLCBiLCBhKVxuICAgKiAtIENTUyBjb2xvciBuYW1lIHN1Y2ggYXMgJ3doaXRlJywgJ29yYW5nZScsICdjeWFuJywgZXRjLlxuICAgKiBAcGFyYW0gc3RyXG4gICAqL1xuICBzdGF0aWMgZnJvbVN0cmluZyhzdHIpIHtcbiAgICBpZiAoc3RyLmluZGV4T2YoXCIjXCIpID49IDApIHtcbiAgICAgIHJldHVybiBfQ29sb3IuZnJvbUhleFN0cmluZyhzdHIpO1xuICAgIH1cbiAgICBjb25zdCBoZXggPSBfQ29sb3IubmFtZVRvSGV4W3N0ci50b0xvd2VyQ2FzZSgpXTtcbiAgICBpZiAoaGV4KSB7XG4gICAgICByZXR1cm4gX0NvbG9yLmZyb21IZXhTdHJpbmcoaGV4KTtcbiAgICB9XG4gICAgaWYgKHN0ci5pbmRleE9mKFwicmdiXCIpID49IDApIHtcbiAgICAgIHJldHVybiBfQ29sb3IuZnJvbVJnYmFTdHJpbmcoc3RyKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNvbG9yIHN0cmluZzogJyR7c3RyfSdgKTtcbiAgfVxuICAvLyBTZWUgaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzcy1jb2xvci8jaGV4LW5vdGF0aW9uXG4gIHN0YXRpYyBwYXJzZUhleChpbnB1dCkge1xuICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvIC9nLCBcIlwiKS5zbGljZSgxKTtcbiAgICBsZXQgcGFydHM7XG4gICAgc3dpdGNoIChpbnB1dC5sZW5ndGgpIHtcbiAgICAgIGNhc2UgNjpcbiAgICAgIGNhc2UgODpcbiAgICAgICAgcGFydHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgIHBhcnRzLnB1c2gocGFyc2VJbnQoYCR7aW5wdXRbaV19JHtpbnB1dFtpICsgMV19YCwgMTYpKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgcGFydHMgPSBpbnB1dC5zcGxpdChcIlwiKS5tYXAoKHApID0+IHBhcnNlSW50KHAsIDE2KSkubWFwKChwKSA9PiBwICsgcCAqIDE2KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChwYXJ0cz8ubGVuZ3RoID49IDMgJiYgcGFydHMuZXZlcnkoKHApID0+IHAgPj0gMCkpIHtcbiAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgcGFydHMucHVzaCgyNTUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnRzO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZnJvbUhleFN0cmluZyhzdHIpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBfQ29sb3IucGFyc2VIZXgoc3RyKTtcbiAgICBpZiAodmFsdWVzKSB7XG4gICAgICBjb25zdCBbciwgZywgYiwgYV0gPSB2YWx1ZXM7XG4gICAgICByZXR1cm4gbmV3IF9Db2xvcihyIC8gMjU1LCBnIC8gMjU1LCBiIC8gMjU1LCBhIC8gMjU1KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBNYWxmb3JtZWQgaGV4YWRlY2ltYWwgY29sb3Igc3RyaW5nOiAnJHtzdHJ9J2ApO1xuICB9XG4gIHN0YXRpYyBzdHJpbmdUb1JnYmEoc3RyKSB7XG4gICAgbGV0IHBvID0gLTE7XG4gICAgbGV0IHBjID0gLTE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGMgPSBzdHJbaV07XG4gICAgICBpZiAocG8gPT09IC0xICYmIGMgPT09IFwiKFwiKSB7XG4gICAgICAgIHBvID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoYyA9PT0gXCIpXCIpIHtcbiAgICAgICAgcGMgPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBvID09PSAtMSB8fCBwYyA9PT0gLTEpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgY29udGVudHMgPSBzdHIuc3Vic3RyaW5nKHBvICsgMSwgcGMpO1xuICAgIGNvbnN0IHBhcnRzID0gY29udGVudHMuc3BsaXQoXCIsXCIpO1xuICAgIGNvbnN0IHJnYmEgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwYXJ0ID0gcGFydHNbaV07XG4gICAgICBsZXQgdmFsdWUgPSBwYXJzZUZsb2F0KHBhcnQpO1xuICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJ0LmluZGV4T2YoXCIlXCIpID49IDApIHtcbiAgICAgICAgdmFsdWUgPSBjbGFtcCgwLCB2YWx1ZSwgMTAwKTtcbiAgICAgICAgdmFsdWUgLz0gMTAwO1xuICAgICAgfSBlbHNlIGlmIChpID09PSAzKSB7XG4gICAgICAgIHZhbHVlID0gY2xhbXAoMCwgdmFsdWUsIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBjbGFtcCgwLCB2YWx1ZSwgMjU1KTtcbiAgICAgICAgdmFsdWUgLz0gMjU1O1xuICAgICAgfVxuICAgICAgcmdiYS5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJnYmE7XG4gIH1cbiAgc3RhdGljIGZyb21SZ2JhU3RyaW5nKHN0cikge1xuICAgIGNvbnN0IHJnYmEgPSBfQ29sb3Iuc3RyaW5nVG9SZ2JhKHN0cik7XG4gICAgaWYgKHJnYmEpIHtcbiAgICAgIGlmIChyZ2JhLmxlbmd0aCA9PT0gMykge1xuICAgICAgICByZXR1cm4gbmV3IF9Db2xvcihyZ2JhWzBdLCByZ2JhWzFdLCByZ2JhWzJdKTtcbiAgICAgIH0gZWxzZSBpZiAocmdiYS5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBfQ29sb3IocmdiYVswXSwgcmdiYVsxXSwgcmdiYVsyXSwgcmdiYVszXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgTWFsZm9ybWVkIHJnYi9yZ2JhIGNvbG9yIHN0cmluZzogJyR7c3RyfSdgKTtcbiAgfVxuICBzdGF0aWMgZnJvbUFycmF5KGFycikge1xuICAgIGlmIChhcnIubGVuZ3RoID09PSA0KSB7XG4gICAgICByZXR1cm4gbmV3IF9Db2xvcihhcnJbMF0sIGFyclsxXSwgYXJyWzJdLCBhcnJbM10pO1xuICAgIH1cbiAgICBpZiAoYXJyLmxlbmd0aCA9PT0gMykge1xuICAgICAgcmV0dXJuIG5ldyBfQ29sb3IoYXJyWzBdLCBhcnJbMV0sIGFyclsyXSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBnaXZlbiBhcnJheSBzaG91bGQgY29udGFpbiAzIG9yIDQgY29sb3IgY29tcG9uZW50cyAobnVtYmVycykuXCIpO1xuICB9XG4gIHN0YXRpYyBmcm9tSFNCKGgsIHMsIGIsIGFscGhhID0gMSkge1xuICAgIGNvbnN0IHJnYiA9IF9Db2xvci5IU0J0b1JHQihoLCBzLCBiKTtcbiAgICByZXR1cm4gbmV3IF9Db2xvcihyZ2JbMF0sIHJnYlsxXSwgcmdiWzJdLCBhbHBoYSk7XG4gIH1cbiAgc3RhdGljIGZyb21IU0woaCwgcywgbCwgYWxwaGEgPSAxKSB7XG4gICAgY29uc3QgcmdiID0gX0NvbG9yLkhTTHRvUkdCKGgsIHMsIGwpO1xuICAgIHJldHVybiBuZXcgX0NvbG9yKHJnYlswXSwgcmdiWzFdLCByZ2JbMl0sIGFscGhhKTtcbiAgfVxuICBzdGF0aWMgZnJvbU9LTENIKGwsIGMsIGgsIGFscGhhID0gMSkge1xuICAgIGNvbnN0IHJnYiA9IF9Db2xvci5PS0xDSHRvUkdCKGwsIGMsIGgpO1xuICAgIHJldHVybiBuZXcgX0NvbG9yKHJnYlswXSwgcmdiWzFdLCByZ2JbMl0sIGFscGhhKTtcbiAgfVxuICBzdGF0aWMgcGFkSGV4KHN0cikge1xuICAgIHJldHVybiBzdHIubGVuZ3RoID09PSAxID8gXCIwXCIgKyBzdHIgOiBzdHI7XG4gIH1cbiAgdG9IZXhTdHJpbmcoKSB7XG4gICAgbGV0IGhleCA9IFwiI1wiICsgX0NvbG9yLnBhZEhleChNYXRoLnJvdW5kKHRoaXMuciAqIDI1NSkudG9TdHJpbmcoMTYpKSArIF9Db2xvci5wYWRIZXgoTWF0aC5yb3VuZCh0aGlzLmcgKiAyNTUpLnRvU3RyaW5nKDE2KSkgKyBfQ29sb3IucGFkSGV4KE1hdGgucm91bmQodGhpcy5iICogMjU1KS50b1N0cmluZygxNikpO1xuICAgIGlmICh0aGlzLmEgPCAxKSB7XG4gICAgICBoZXggKz0gX0NvbG9yLnBhZEhleChNYXRoLnJvdW5kKHRoaXMuYSAqIDI1NSkudG9TdHJpbmcoMTYpKTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbiAgfVxuICB0b1JnYmFTdHJpbmcoZnJhY3Rpb25EaWdpdHMgPSAzKSB7XG4gICAgY29uc3QgY29tcG9uZW50cyA9IFtNYXRoLnJvdW5kKHRoaXMuciAqIDI1NSksIE1hdGgucm91bmQodGhpcy5nICogMjU1KSwgTWF0aC5yb3VuZCh0aGlzLmIgKiAyNTUpXTtcbiAgICBjb25zdCBrID0gTWF0aC5wb3coMTAsIGZyYWN0aW9uRGlnaXRzKTtcbiAgICBpZiAodGhpcy5hICE9PSAxKSB7XG4gICAgICBjb21wb25lbnRzLnB1c2goTWF0aC5yb3VuZCh0aGlzLmEgKiBrKSAvIGspO1xuICAgICAgcmV0dXJuIGByZ2JhKCR7Y29tcG9uZW50cy5qb2luKFwiLCBcIil9KWA7XG4gICAgfVxuICAgIHJldHVybiBgcmdiKCR7Y29tcG9uZW50cy5qb2luKFwiLCBcIil9KWA7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgaWYgKHRoaXMuYSA9PT0gMSkge1xuICAgICAgcmV0dXJuIHRoaXMudG9IZXhTdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudG9SZ2JhU3RyaW5nKCk7XG4gIH1cbiAgdG9IU0IoKSB7XG4gICAgcmV0dXJuIF9Db2xvci5SR0J0b0hTQih0aGlzLnIsIHRoaXMuZywgdGhpcy5iKTtcbiAgfVxuICBzdGF0aWMgUkdCdG9PS0xDSChyLCBnLCBiKSB7XG4gICAgY29uc3QgTFNSR0IwID0gc3JnYlRvTGluZWFyKHIpO1xuICAgIGNvbnN0IExTUkdCMSA9IHNyZ2JUb0xpbmVhcihnKTtcbiAgICBjb25zdCBMU1JHQjIgPSBzcmdiVG9MaW5lYXIoYik7XG4gICAgY29uc3QgTE1TMCA9IE1hdGguY2JydCgwLjQxMjIyMTQ3MDggKiBMU1JHQjAgKyAwLjUzNjMzMjUzNjMgKiBMU1JHQjEgKyAwLjA1MTQ0NTk5MjkgKiBMU1JHQjIpO1xuICAgIGNvbnN0IExNUzEgPSBNYXRoLmNicnQoMC4yMTE5MDM0OTgyICogTFNSR0IwICsgMC42ODA2OTk1NDUxICogTFNSR0IxICsgMC4xMDczOTY5NTY2ICogTFNSR0IyKTtcbiAgICBjb25zdCBMTVMyID0gTWF0aC5jYnJ0KDAuMDg4MzAyNDYxOSAqIExTUkdCMCArIDAuMjgxNzE4ODM3NiAqIExTUkdCMSArIDAuNjI5OTc4NzAwNSAqIExTUkdCMik7XG4gICAgY29uc3QgT0tMQUIwID0gMC4yMTA0NTQyNTUzICogTE1TMCArIDAuNzkzNjE3Nzg1ICogTE1TMSAtIDAuMDA0MDcyMDQ2OCAqIExNUzI7XG4gICAgY29uc3QgT0tMQUIxID0gMS45Nzc5OTg0OTUxICogTE1TMCAtIDIuNDI4NTkyMjA1ICogTE1TMSArIDAuNDUwNTkzNzA5OSAqIExNUzI7XG4gICAgY29uc3QgT0tMQUIyID0gMC4wMjU5MDQwMzcxICogTE1TMCArIDAuNzgyNzcxNzY2MiAqIExNUzEgLSAwLjgwODY3NTc2NiAqIExNUzI7XG4gICAgY29uc3QgaHVlID0gTWF0aC5hdGFuMihPS0xBQjIsIE9LTEFCMSkgKiAxODAgLyBNYXRoLlBJO1xuICAgIGNvbnN0IE9LTENIMCA9IE9LTEFCMDtcbiAgICBjb25zdCBPS0xDSDEgPSBNYXRoLmh5cG90KE9LTEFCMSwgT0tMQUIyKTtcbiAgICBjb25zdCBPS0xDSDIgPSBodWUgPj0gMCA/IGh1ZSA6IGh1ZSArIDM2MDtcbiAgICByZXR1cm4gW09LTENIMCwgT0tMQ0gxLCBPS0xDSDJdO1xuICB9XG4gIHN0YXRpYyBPS0xDSHRvUkdCKGwsIGMsIGgpIHtcbiAgICBjb25zdCBPS0xBQjAgPSBsO1xuICAgIGNvbnN0IE9LTEFCMSA9IGMgKiBNYXRoLmNvcyhoICogTWF0aC5QSSAvIDE4MCk7XG4gICAgY29uc3QgT0tMQUIyID0gYyAqIE1hdGguc2luKGggKiBNYXRoLlBJIC8gMTgwKTtcbiAgICBjb25zdCBMTVMwID0gKE9LTEFCMCArIDAuMzk2MzM3Nzc3NCAqIE9LTEFCMSArIDAuMjE1ODAzNzU3MyAqIE9LTEFCMikgKiogMztcbiAgICBjb25zdCBMTVMxID0gKE9LTEFCMCAtIDAuMTA1NTYxMzQ1OCAqIE9LTEFCMSAtIDAuMDYzODU0MTcyOCAqIE9LTEFCMikgKiogMztcbiAgICBjb25zdCBMTVMyID0gKE9LTEFCMCAtIDAuMDg5NDg0MTc3NSAqIE9LTEFCMSAtIDEuMjkxNDg1NTQ4ICogT0tMQUIyKSAqKiAzO1xuICAgIGNvbnN0IExTUkdCMCA9IDQuMDc2NzQxNjYyMSAqIExNUzAgLSAzLjMwNzcxMTU5MTMgKiBMTVMxICsgMC4yMzA5Njk5MjkyICogTE1TMjtcbiAgICBjb25zdCBMU1JHQjEgPSAtMS4yNjg0MzgwMDQ2ICogTE1TMCArIDIuNjA5NzU3NDAxMSAqIExNUzEgLSAwLjM0MTMxOTM5NjUgKiBMTVMyO1xuICAgIGNvbnN0IExTUkdCMiA9IC0wLjAwNDE5NjA4NjMgKiBMTVMwIC0gMC43MDM0MTg2MTQ3ICogTE1TMSArIDEuNzA3NjE0NzAxICogTE1TMjtcbiAgICBjb25zdCBTUkdCMCA9IHNyZ2JGcm9tTGluZWFyKExTUkdCMCk7XG4gICAgY29uc3QgU1JHQjEgPSBzcmdiRnJvbUxpbmVhcihMU1JHQjEpO1xuICAgIGNvbnN0IFNSR0IyID0gc3JnYkZyb21MaW5lYXIoTFNSR0IyKTtcbiAgICByZXR1cm4gW1NSR0IwLCBTUkdCMSwgU1JHQjJdO1xuICB9XG4gIHN0YXRpYyBSR0J0b0hTTChyLCBnLCBiKSB7XG4gICAgY29uc3QgbWluID0gTWF0aC5taW4ociwgZywgYik7XG4gICAgY29uc3QgbWF4ID0gTWF0aC5tYXgociwgZywgYik7XG4gICAgY29uc3QgbCA9IChtYXggKyBtaW4pIC8gMjtcbiAgICBsZXQgaDtcbiAgICBsZXQgcztcbiAgICBpZiAobWF4ID09PSBtaW4pIHtcbiAgICAgIGggPSAwO1xuICAgICAgcyA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGRlbHRhNCA9IG1heCAtIG1pbjtcbiAgICAgIHMgPSBsID4gMC41ID8gZGVsdGE0IC8gKDIgLSBtYXggLSBtaW4pIDogZGVsdGE0IC8gKG1heCArIG1pbik7XG4gICAgICBpZiAobWF4ID09PSByKSB7XG4gICAgICAgIGggPSAoZyAtIGIpIC8gZGVsdGE0ICsgKGcgPCBiID8gNiA6IDApO1xuICAgICAgfSBlbHNlIGlmIChtYXggPT09IGcpIHtcbiAgICAgICAgaCA9IChiIC0gcikgLyBkZWx0YTQgKyAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaCA9IChyIC0gZykgLyBkZWx0YTQgKyA0O1xuICAgICAgfVxuICAgICAgaCAqPSAzNjAgLyA2O1xuICAgIH1cbiAgICByZXR1cm4gW2gsIHMsIGxdO1xuICB9XG4gIHN0YXRpYyBIU0x0b1JHQihoLCBzLCBsKSB7XG4gICAgaCA9IChoICUgMzYwICsgMzYwKSAlIDM2MDtcbiAgICBpZiAocyA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtsLCBsLCBsXTtcbiAgICB9XG4gICAgY29uc3QgcSA9IGwgPCAwLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHM7XG4gICAgY29uc3QgcCA9IDIgKiBsIC0gcTtcbiAgICBmdW5jdGlvbiBodWVUb1JnYih0KSB7XG4gICAgICBpZiAodCA8IDApXG4gICAgICAgIHQgKz0gMTtcbiAgICAgIGlmICh0ID4gMSlcbiAgICAgICAgdCAtPSAxO1xuICAgICAgaWYgKHQgPCAxIC8gNilcbiAgICAgICAgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHQ7XG4gICAgICBpZiAodCA8IDEgLyAyKVxuICAgICAgICByZXR1cm4gcTtcbiAgICAgIGlmICh0IDwgMiAvIDMpXG4gICAgICAgIHJldHVybiBwICsgKHEgLSBwKSAqICgyIC8gMyAtIHQpICogNjtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICBjb25zdCByID0gaHVlVG9SZ2IoaCAvIDM2MCArIDEgLyAzKTtcbiAgICBjb25zdCBnID0gaHVlVG9SZ2IoaCAvIDM2MCk7XG4gICAgY29uc3QgYiA9IGh1ZVRvUmdiKGggLyAzNjAgLSAxIC8gMyk7XG4gICAgcmV0dXJuIFtyLCBnLCBiXTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgdGhlIGdpdmVuIFJHQiB0cmlwbGUgdG8gYW4gYXJyYXkgb2YgSFNCIChIU1YpIGNvbXBvbmVudHMuXG4gICAqL1xuICBzdGF0aWMgUkdCdG9IU0IociwgZywgYikge1xuICAgIGNvbnN0IG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuICAgIGNvbnN0IFMgPSBtYXggPT09IDAgPyAwIDogKG1heCAtIG1pbikgLyBtYXg7XG4gICAgbGV0IEggPSAwO1xuICAgIGlmIChtaW4gIT09IG1heCkge1xuICAgICAgY29uc3QgZGVsdGE0ID0gbWF4IC0gbWluO1xuICAgICAgY29uc3QgcmMgPSAobWF4IC0gcikgLyBkZWx0YTQ7XG4gICAgICBjb25zdCBnYyA9IChtYXggLSBnKSAvIGRlbHRhNDtcbiAgICAgIGNvbnN0IGJjID0gKG1heCAtIGIpIC8gZGVsdGE0O1xuICAgICAgaWYgKHIgPT09IG1heCkge1xuICAgICAgICBIID0gYmMgLSBnYztcbiAgICAgIH0gZWxzZSBpZiAoZyA9PT0gbWF4KSB7XG4gICAgICAgIEggPSAyICsgcmMgLSBiYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEggPSA0ICsgZ2MgLSByYztcbiAgICAgIH1cbiAgICAgIEggLz0gNjtcbiAgICAgIGlmIChIIDwgMCkge1xuICAgICAgICBIID0gSCArIDE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbSCAqIDM2MCwgUywgbWF4XTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgdGhlIGdpdmVuIEhTQiAoSFNWKSB0cmlwbGUgdG8gYW4gYXJyYXkgb2YgUkdCIGNvbXBvbmVudHMuXG4gICAqL1xuICBzdGF0aWMgSFNCdG9SR0IoSCwgUywgQikge1xuICAgIEggPSAoSCAlIDM2MCArIDM2MCkgJSAzNjAgLyAzNjA7XG4gICAgbGV0IHIgPSAwO1xuICAgIGxldCBnID0gMDtcbiAgICBsZXQgYiA9IDA7XG4gICAgaWYgKFMgPT09IDApIHtcbiAgICAgIHIgPSBnID0gYiA9IEI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGggPSAoSCAtIE1hdGguZmxvb3IoSCkpICogNjtcbiAgICAgIGNvbnN0IGYgPSBoIC0gTWF0aC5mbG9vcihoKTtcbiAgICAgIGNvbnN0IHAgPSBCICogKDEgLSBTKTtcbiAgICAgIGNvbnN0IHEgPSBCICogKDEgLSBTICogZik7XG4gICAgICBjb25zdCB0ID0gQiAqICgxIC0gUyAqICgxIC0gZikpO1xuICAgICAgc3dpdGNoIChoID4+IDApIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHIgPSBCO1xuICAgICAgICAgIGcgPSB0O1xuICAgICAgICAgIGIgPSBwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgciA9IHE7XG4gICAgICAgICAgZyA9IEI7XG4gICAgICAgICAgYiA9IHA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICByID0gcDtcbiAgICAgICAgICBnID0gQjtcbiAgICAgICAgICBiID0gdDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHIgPSBwO1xuICAgICAgICAgIGcgPSBxO1xuICAgICAgICAgIGIgPSBCO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgciA9IHQ7XG4gICAgICAgICAgZyA9IHA7XG4gICAgICAgICAgYiA9IEI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICByID0gQjtcbiAgICAgICAgICBnID0gcDtcbiAgICAgICAgICBiID0gcTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtyLCBnLCBiXTtcbiAgfVxuICBzdGF0aWMgbWl4KGMwLCBjMSwgdCkge1xuICAgIHJldHVybiBuZXcgX0NvbG9yKGxlcnAoYzAuciwgYzEuciwgdCksIGxlcnAoYzAuZywgYzEuZywgdCksIGxlcnAoYzAuYiwgYzEuYiwgdCksIGxlcnAoYzAuYSwgYzEuYSwgdCkpO1xuICB9XG59O1xuLyoqXG4gKiBDU1MgQ29sb3IgTW9kdWxlIExldmVsIDQ6XG4gKiBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3NzLWNvbG9yLyNuYW1lZC1jb2xvcnNcbiAqL1xuX0NvbG9yLm5hbWVUb0hleCA9IHtcbiAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICBfX3Byb3RvX186IG51bGwsXG4gIGFsaWNlYmx1ZTogXCIjRjBGOEZGXCIsXG4gIGFudGlxdWV3aGl0ZTogXCIjRkFFQkQ3XCIsXG4gIGFxdWE6IFwiIzAwRkZGRlwiLFxuICBhcXVhbWFyaW5lOiBcIiM3RkZGRDRcIixcbiAgYXp1cmU6IFwiI0YwRkZGRlwiLFxuICBiZWlnZTogXCIjRjVGNURDXCIsXG4gIGJpc3F1ZTogXCIjRkZFNEM0XCIsXG4gIGJsYWNrOiBcIiMwMDAwMDBcIixcbiAgYmxhbmNoZWRhbG1vbmQ6IFwiI0ZGRUJDRFwiLFxuICBibHVlOiBcIiMwMDAwRkZcIixcbiAgYmx1ZXZpb2xldDogXCIjOEEyQkUyXCIsXG4gIGJyb3duOiBcIiNBNTJBMkFcIixcbiAgYnVybHl3b29kOiBcIiNERUI4ODdcIixcbiAgY2FkZXRibHVlOiBcIiM1RjlFQTBcIixcbiAgY2hhcnRyZXVzZTogXCIjN0ZGRjAwXCIsXG4gIGNob2NvbGF0ZTogXCIjRDI2OTFFXCIsXG4gIGNvcmFsOiBcIiNGRjdGNTBcIixcbiAgY29ybmZsb3dlcmJsdWU6IFwiIzY0OTVFRFwiLFxuICBjb3Juc2lsazogXCIjRkZGOERDXCIsXG4gIGNyaW1zb246IFwiI0RDMTQzQ1wiLFxuICBjeWFuOiBcIiMwMEZGRkZcIixcbiAgZGFya2JsdWU6IFwiIzAwMDA4QlwiLFxuICBkYXJrY3lhbjogXCIjMDA4QjhCXCIsXG4gIGRhcmtnb2xkZW5yb2Q6IFwiI0I4ODYwQlwiLFxuICBkYXJrZ3JheTogXCIjQTlBOUE5XCIsXG4gIGRhcmtncmVlbjogXCIjMDA2NDAwXCIsXG4gIGRhcmtncmV5OiBcIiNBOUE5QTlcIixcbiAgZGFya2toYWtpOiBcIiNCREI3NkJcIixcbiAgZGFya21hZ2VudGE6IFwiIzhCMDA4QlwiLFxuICBkYXJrb2xpdmVncmVlbjogXCIjNTU2QjJGXCIsXG4gIGRhcmtvcmFuZ2U6IFwiI0ZGOEMwMFwiLFxuICBkYXJrb3JjaGlkOiBcIiM5OTMyQ0NcIixcbiAgZGFya3JlZDogXCIjOEIwMDAwXCIsXG4gIGRhcmtzYWxtb246IFwiI0U5OTY3QVwiLFxuICBkYXJrc2VhZ3JlZW46IFwiIzhGQkM4RlwiLFxuICBkYXJrc2xhdGVibHVlOiBcIiM0ODNEOEJcIixcbiAgZGFya3NsYXRlZ3JheTogXCIjMkY0RjRGXCIsXG4gIGRhcmtzbGF0ZWdyZXk6IFwiIzJGNEY0RlwiLFxuICBkYXJrdHVycXVvaXNlOiBcIiMwMENFRDFcIixcbiAgZGFya3Zpb2xldDogXCIjOTQwMEQzXCIsXG4gIGRlZXBwaW5rOiBcIiNGRjE0OTNcIixcbiAgZGVlcHNreWJsdWU6IFwiIzAwQkZGRlwiLFxuICBkaW1ncmF5OiBcIiM2OTY5NjlcIixcbiAgZGltZ3JleTogXCIjNjk2OTY5XCIsXG4gIGRvZGdlcmJsdWU6IFwiIzFFOTBGRlwiLFxuICBmaXJlYnJpY2s6IFwiI0IyMjIyMlwiLFxuICBmbG9yYWx3aGl0ZTogXCIjRkZGQUYwXCIsXG4gIGZvcmVzdGdyZWVuOiBcIiMyMjhCMjJcIixcbiAgZnVjaHNpYTogXCIjRkYwMEZGXCIsXG4gIGdhaW5zYm9ybzogXCIjRENEQ0RDXCIsXG4gIGdob3N0d2hpdGU6IFwiI0Y4RjhGRlwiLFxuICBnb2xkOiBcIiNGRkQ3MDBcIixcbiAgZ29sZGVucm9kOiBcIiNEQUE1MjBcIixcbiAgZ3JheTogXCIjODA4MDgwXCIsXG4gIGdyZWVuOiBcIiMwMDgwMDBcIixcbiAgZ3JlZW55ZWxsb3c6IFwiI0FERkYyRlwiLFxuICBncmV5OiBcIiM4MDgwODBcIixcbiAgaG9uZXlkZXc6IFwiI0YwRkZGMFwiLFxuICBob3RwaW5rOiBcIiNGRjY5QjRcIixcbiAgaW5kaWFucmVkOiBcIiNDRDVDNUNcIixcbiAgaW5kaWdvOiBcIiM0QjAwODJcIixcbiAgaXZvcnk6IFwiI0ZGRkZGMFwiLFxuICBraGFraTogXCIjRjBFNjhDXCIsXG4gIGxhdmVuZGVyOiBcIiNFNkU2RkFcIixcbiAgbGF2ZW5kZXJibHVzaDogXCIjRkZGMEY1XCIsXG4gIGxhd25ncmVlbjogXCIjN0NGQzAwXCIsXG4gIGxlbW9uY2hpZmZvbjogXCIjRkZGQUNEXCIsXG4gIGxpZ2h0Ymx1ZTogXCIjQUREOEU2XCIsXG4gIGxpZ2h0Y29yYWw6IFwiI0YwODA4MFwiLFxuICBsaWdodGN5YW46IFwiI0UwRkZGRlwiLFxuICBsaWdodGdvbGRlbnJvZHllbGxvdzogXCIjRkFGQUQyXCIsXG4gIGxpZ2h0Z3JheTogXCIjRDNEM0QzXCIsXG4gIGxpZ2h0Z3JlZW46IFwiIzkwRUU5MFwiLFxuICBsaWdodGdyZXk6IFwiI0QzRDNEM1wiLFxuICBsaWdodHBpbms6IFwiI0ZGQjZDMVwiLFxuICBsaWdodHNhbG1vbjogXCIjRkZBMDdBXCIsXG4gIGxpZ2h0c2VhZ3JlZW46IFwiIzIwQjJBQVwiLFxuICBsaWdodHNreWJsdWU6IFwiIzg3Q0VGQVwiLFxuICBsaWdodHNsYXRlZ3JheTogXCIjNzc4ODk5XCIsXG4gIGxpZ2h0c2xhdGVncmV5OiBcIiM3Nzg4OTlcIixcbiAgbGlnaHRzdGVlbGJsdWU6IFwiI0IwQzRERVwiLFxuICBsaWdodHllbGxvdzogXCIjRkZGRkUwXCIsXG4gIGxpbWU6IFwiIzAwRkYwMFwiLFxuICBsaW1lZ3JlZW46IFwiIzMyQ0QzMlwiLFxuICBsaW5lbjogXCIjRkFGMEU2XCIsXG4gIG1hZ2VudGE6IFwiI0ZGMDBGRlwiLFxuICBtYXJvb246IFwiIzgwMDAwMFwiLFxuICBtZWRpdW1hcXVhbWFyaW5lOiBcIiM2NkNEQUFcIixcbiAgbWVkaXVtYmx1ZTogXCIjMDAwMENEXCIsXG4gIG1lZGl1bW9yY2hpZDogXCIjQkE1NUQzXCIsXG4gIG1lZGl1bXB1cnBsZTogXCIjOTM3MERCXCIsXG4gIG1lZGl1bXNlYWdyZWVuOiBcIiMzQ0IzNzFcIixcbiAgbWVkaXVtc2xhdGVibHVlOiBcIiM3QjY4RUVcIixcbiAgbWVkaXVtc3ByaW5nZ3JlZW46IFwiIzAwRkE5QVwiLFxuICBtZWRpdW10dXJxdW9pc2U6IFwiIzQ4RDFDQ1wiLFxuICBtZWRpdW12aW9sZXRyZWQ6IFwiI0M3MTU4NVwiLFxuICBtaWRuaWdodGJsdWU6IFwiIzE5MTk3MFwiLFxuICBtaW50Y3JlYW06IFwiI0Y1RkZGQVwiLFxuICBtaXN0eXJvc2U6IFwiI0ZGRTRFMVwiLFxuICBtb2NjYXNpbjogXCIjRkZFNEI1XCIsXG4gIG5hdmFqb3doaXRlOiBcIiNGRkRFQURcIixcbiAgbmF2eTogXCIjMDAwMDgwXCIsXG4gIG9sZGxhY2U6IFwiI0ZERjVFNlwiLFxuICBvbGl2ZTogXCIjODA4MDAwXCIsXG4gIG9saXZlZHJhYjogXCIjNkI4RTIzXCIsXG4gIG9yYW5nZTogXCIjRkZBNTAwXCIsXG4gIG9yYW5nZXJlZDogXCIjRkY0NTAwXCIsXG4gIG9yY2hpZDogXCIjREE3MEQ2XCIsXG4gIHBhbGVnb2xkZW5yb2Q6IFwiI0VFRThBQVwiLFxuICBwYWxlZ3JlZW46IFwiIzk4RkI5OFwiLFxuICBwYWxldHVycXVvaXNlOiBcIiNBRkVFRUVcIixcbiAgcGFsZXZpb2xldHJlZDogXCIjREI3MDkzXCIsXG4gIHBhcGF5YXdoaXA6IFwiI0ZGRUZENVwiLFxuICBwZWFjaHB1ZmY6IFwiI0ZGREFCOVwiLFxuICBwZXJ1OiBcIiNDRDg1M0ZcIixcbiAgcGluazogXCIjRkZDMENCXCIsXG4gIHBsdW06IFwiI0REQTBERFwiLFxuICBwb3dkZXJibHVlOiBcIiNCMEUwRTZcIixcbiAgcHVycGxlOiBcIiM4MDAwODBcIixcbiAgcmViZWNjYXB1cnBsZTogXCIjNjYzMzk5XCIsXG4gIHJlZDogXCIjRkYwMDAwXCIsXG4gIHJvc3licm93bjogXCIjQkM4RjhGXCIsXG4gIHJveWFsYmx1ZTogXCIjNDE2OUUxXCIsXG4gIHNhZGRsZWJyb3duOiBcIiM4QjQ1MTNcIixcbiAgc2FsbW9uOiBcIiNGQTgwNzJcIixcbiAgc2FuZHlicm93bjogXCIjRjRBNDYwXCIsXG4gIHNlYWdyZWVuOiBcIiMyRThCNTdcIixcbiAgc2Vhc2hlbGw6IFwiI0ZGRjVFRVwiLFxuICBzaWVubmE6IFwiI0EwNTIyRFwiLFxuICBzaWx2ZXI6IFwiI0MwQzBDMFwiLFxuICBza3libHVlOiBcIiM4N0NFRUJcIixcbiAgc2xhdGVibHVlOiBcIiM2QTVBQ0RcIixcbiAgc2xhdGVncmF5OiBcIiM3MDgwOTBcIixcbiAgc2xhdGVncmV5OiBcIiM3MDgwOTBcIixcbiAgc25vdzogXCIjRkZGQUZBXCIsXG4gIHNwcmluZ2dyZWVuOiBcIiMwMEZGN0ZcIixcbiAgc3RlZWxibHVlOiBcIiM0NjgyQjRcIixcbiAgdGFuOiBcIiNEMkI0OENcIixcbiAgdGVhbDogXCIjMDA4MDgwXCIsXG4gIHRoaXN0bGU6IFwiI0Q4QkZEOFwiLFxuICB0b21hdG86IFwiI0ZGNjM0N1wiLFxuICB0cmFuc3BhcmVudDogXCIjMDAwMDAwMDBcIixcbiAgdHVycXVvaXNlOiBcIiM0MEUwRDBcIixcbiAgdmlvbGV0OiBcIiNFRTgyRUVcIixcbiAgd2hlYXQ6IFwiI0Y1REVCM1wiLFxuICB3aGl0ZTogXCIjRkZGRkZGXCIsXG4gIHdoaXRlc21va2U6IFwiI0Y1RjVGNVwiLFxuICB5ZWxsb3c6IFwiI0ZGRkYwMFwiLFxuICB5ZWxsb3dncmVlbjogXCIjOUFDRDMyXCJcbn07XG52YXIgQ29sb3IgPSBfQ29sb3I7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvaW50ZXJwb2xhdGUudHNcbmZ1bmN0aW9uIGludGVycG9sYXRlTnVtYmVyKGEsIGIpIHtcbiAgcmV0dXJuIChkKSA9PiBOdW1iZXIoYSkgKiAoMSAtIGQpICsgTnVtYmVyKGIpICogZDtcbn1cbmZ1bmN0aW9uIGludGVycG9sYXRlQ29sb3IoYSwgYikge1xuICBpZiAodHlwZW9mIGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICB0cnkge1xuICAgICAgYSA9IENvbG9yLmZyb21TdHJpbmcoYSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgYSA9IENvbG9yLmZyb21BcnJheShbMCwgMCwgMF0pO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIGIgPT09IFwic3RyaW5nXCIpIHtcbiAgICB0cnkge1xuICAgICAgYiA9IENvbG9yLmZyb21TdHJpbmcoYik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgYiA9IENvbG9yLmZyb21BcnJheShbMCwgMCwgMF0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gKGQpID0+IENvbG9yLm1peChhLCBiLCBkKS50b1JnYmFTdHJpbmcoKTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9kZWNvcmF0b3IudHNcbnZhciBCUkVBS19UUkFOU0ZPUk1fQ0hBSU4gPSBTeW1ib2woXCJCUkVBS1wiKTtcbnZhciBDT05GSUdfS0VZID0gXCJfX2RlY29yYXRvcl9jb25maWdcIjtcbmZ1bmN0aW9uIGluaXRpYWxpc2VDb25maWcodGFyZ2V0LCBwcm9wZXJ0eUtleU9yU3ltYm9sKSB7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgQ09ORklHX0tFWSkgPT0gbnVsbCkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIENPTkZJR19LRVksIHsgdmFsdWU6IHt9IH0pO1xuICB9XG4gIGNvbnN0IGNvbmZpZyA9IHRhcmdldFtDT05GSUdfS0VZXTtcbiAgY29uc3QgcHJvcGVydHlLZXkgPSBwcm9wZXJ0eUtleU9yU3ltYm9sLnRvU3RyaW5nKCk7XG4gIGlmICh0eXBlb2YgY29uZmlnW3Byb3BlcnR5S2V5XSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBjb25maWdbcHJvcGVydHlLZXldO1xuICB9XG4gIGNvbnN0IHZhbHVlc01hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICBjb25maWdbcHJvcGVydHlLZXldID0geyBzZXR0ZXJzOiBbXSwgZ2V0dGVyczogW10sIG9ic2VydmVyczogW10sIHZhbHVlc01hcCB9O1xuICBjb25zdCBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3BlcnR5S2V5T3JTeW1ib2wpO1xuICBjb25zdCBwcmV2U2V0ID0gZGVzY3JpcHRvcj8uc2V0O1xuICBjb25zdCBwcmV2R2V0ID0gZGVzY3JpcHRvcj8uZ2V0O1xuICBjb25zdCBnZXR0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICBsZXQgdmFsdWUgPSBwcmV2R2V0ID8gcHJldkdldC5jYWxsKHRoaXMpIDogdmFsdWVzTWFwLmdldCh0aGlzKTtcbiAgICBmb3IgKGNvbnN0IHRyYW5zZm9ybUZuIG9mIGNvbmZpZ1twcm9wZXJ0eUtleV0uZ2V0dGVycykge1xuICAgICAgdmFsdWUgPSB0cmFuc2Zvcm1Gbih0aGlzLCBwcm9wZXJ0eUtleU9yU3ltYm9sLCB2YWx1ZSk7XG4gICAgICBpZiAodmFsdWUgPT09IEJSRUFLX1RSQU5TRk9STV9DSEFJTikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbiAgY29uc3Qgc2V0dGVyID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICBjb25zdCB7IHNldHRlcnMsIG9ic2VydmVycyB9ID0gY29uZmlnW3Byb3BlcnR5S2V5XTtcbiAgICBsZXQgb2xkVmFsdWU7XG4gICAgaWYgKHNldHRlcnMuc29tZSgoZikgPT4gZi5sZW5ndGggPiAyKSkge1xuICAgICAgb2xkVmFsdWUgPSBwcmV2R2V0ID8gcHJldkdldC5jYWxsKHRoaXMpIDogdmFsdWVzTWFwLmdldCh0aGlzKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCB0cmFuc2Zvcm1GbiBvZiBzZXR0ZXJzKSB7XG4gICAgICB2YWx1ZSA9IHRyYW5zZm9ybUZuKHRoaXMsIHByb3BlcnR5S2V5T3JTeW1ib2wsIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICBpZiAodmFsdWUgPT09IEJSRUFLX1RSQU5TRk9STV9DSEFJTikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcmV2U2V0KSB7XG4gICAgICBwcmV2U2V0LmNhbGwodGhpcywgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZXNNYXAuc2V0KHRoaXMsIHZhbHVlKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBvYnNlcnZlckZuIG9mIG9ic2VydmVycykge1xuICAgICAgb2JzZXJ2ZXJGbih0aGlzLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgIH1cbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXlPclN5bWJvbCwge1xuICAgIHNldDogc2V0dGVyLFxuICAgIGdldDogZ2V0dGVyLFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICB9KTtcbiAgcmV0dXJuIGNvbmZpZ1twcm9wZXJ0eUtleV07XG59XG5mdW5jdGlvbiBhZGRUcmFuc2Zvcm1Ub0luc3RhbmNlUHJvcGVydHkoc2V0VHJhbnNmb3JtLCBnZXRUcmFuc2Zvcm0sIGNvbmZpZ01ldGFkYXRhKSB7XG4gIHJldHVybiAodGFyZ2V0LCBwcm9wZXJ0eUtleU9yU3ltYm9sKSA9PiB7XG4gICAgY29uc3QgY29uZmlnID0gaW5pdGlhbGlzZUNvbmZpZyh0YXJnZXQsIHByb3BlcnR5S2V5T3JTeW1ib2wpO1xuICAgIGNvbmZpZy5zZXR0ZXJzLnB1c2goc2V0VHJhbnNmb3JtKTtcbiAgICBpZiAoZ2V0VHJhbnNmb3JtKSB7XG4gICAgICBjb25maWcuZ2V0dGVycy51bnNoaWZ0KGdldFRyYW5zZm9ybSk7XG4gICAgfVxuICAgIGlmIChjb25maWdNZXRhZGF0YSkge1xuICAgICAgT2JqZWN0LmFzc2lnbihjb25maWcsIGNvbmZpZ01ldGFkYXRhKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBhZGRPYnNlcnZlclRvSW5zdGFuY2VQcm9wZXJ0eShzZXRPYnNlcnZlcikge1xuICByZXR1cm4gKHRhcmdldCwgcHJvcGVydHlLZXlPclN5bWJvbCkgPT4ge1xuICAgIGluaXRpYWxpc2VDb25maWcodGFyZ2V0LCBwcm9wZXJ0eUtleU9yU3ltYm9sKS5vYnNlcnZlcnMucHVzaChzZXRPYnNlcnZlcik7XG4gIH07XG59XG5mdW5jdGlvbiBpc0RlY29yYXRlZE9iamVjdCh0YXJnZXQpIHtcbiAgcmV0dXJuIHR5cGVvZiB0YXJnZXQgIT09IFwidW5kZWZpbmVkXCIgJiYgQ09ORklHX0tFWSBpbiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBsaXN0RGVjb3JhdGVkUHJvcGVydGllcyh0YXJnZXQpIHtcbiAgY29uc3QgdGFyZ2V0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIHdoaWxlIChpc0RlY29yYXRlZE9iamVjdCh0YXJnZXQpKSB7XG4gICAgdGFyZ2V0cy5hZGQodGFyZ2V0Py5bQ09ORklHX0tFWV0pO1xuICAgIHRhcmdldCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpO1xuICB9XG4gIHJldHVybiBBcnJheS5mcm9tKHRhcmdldHMpLmZsYXRNYXAoKGNvbmZpZ01hcCkgPT4gT2JqZWN0LmtleXMoY29uZmlnTWFwKSk7XG59XG5mdW5jdGlvbiBleHRyYWN0RGVjb3JhdGVkUHJvcGVydGllcyh0YXJnZXQpIHtcbiAgcmV0dXJuIGxpc3REZWNvcmF0ZWRQcm9wZXJ0aWVzKHRhcmdldCkucmVkdWNlKChyZXN1bHQsIGtleSkgPT4ge1xuICAgIHJlc3VsdFtrZXldID0gdGFyZ2V0W2tleV0gPz8gbnVsbDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LCB7fSk7XG59XG5mdW5jdGlvbiBleHRyYWN0RGVjb3JhdGVkUHJvcGVydHlNZXRhZGF0YSh0YXJnZXQsIHByb3BlcnR5S2V5T3JTeW1ib2wpIHtcbiAgY29uc3QgcHJvcGVydHlLZXkgPSBwcm9wZXJ0eUtleU9yU3ltYm9sLnRvU3RyaW5nKCk7XG4gIHdoaWxlIChpc0RlY29yYXRlZE9iamVjdCh0YXJnZXQpKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGFyZ2V0W0NPTkZJR19LRVldO1xuICAgIGlmIChPYmplY3QuaGFzT3duKGNvbmZpZywgcHJvcGVydHlLZXkpKSB7XG4gICAgICByZXR1cm4gY29uZmlnW3Byb3BlcnR5S2V5XTtcbiAgICB9XG4gICAgdGFyZ2V0ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldCk7XG4gIH1cbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC90eXBlLWd1YXJkcy50c1xuZnVuY3Rpb24gaXNEZWZpbmVkKHZhbCkge1xuICByZXR1cm4gdmFsICE9IG51bGw7XG59XG5mdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIjtcbn1cbmZ1bmN0aW9uIGlzRGF0ZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBEYXRlO1xufVxuZnVuY3Rpb24gaXNWYWxpZERhdGUodmFsdWUpIHtcbiAgcmV0dXJuIGlzRGF0ZSh2YWx1ZSkgJiYgIWlzTmFOKE51bWJlcih2YWx1ZSkpO1xufVxuZnVuY3Rpb24gaXNSZWdFeHAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwO1xufVxuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsICYmICFpc0FycmF5KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSA9PT0gT2JqZWN0LnByb3RvdHlwZTtcbn1cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCI7XG59XG5mdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiO1xufVxuZnVuY3Rpb24gaXNGaW5pdGVOdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBpc0h0bWxFbGVtZW50KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHZhbHVlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG59XG5mdW5jdGlvbiBpc0VudW1LZXkoZW51bU9iamVjdCwgZW51bUtleSkge1xuICByZXR1cm4gaXNTdHJpbmcoZW51bUtleSkgJiYgT2JqZWN0LmtleXMoZW51bU9iamVjdCkuaW5jbHVkZXMoZW51bUtleSk7XG59XG5mdW5jdGlvbiBpc0VudW1WYWx1ZShlbnVtT2JqZWN0LCBlbnVtVmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdC52YWx1ZXMoZW51bU9iamVjdCkuaW5jbHVkZXMoZW51bVZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3ltYm9sXCI7XG59XG5mdW5jdGlvbiBleGNsdWRlc1R5cGUob2JqLCBleGNsdWRlZCkge1xuICByZXR1cm4gb2JqLnR5cGUgIT09IGV4Y2x1ZGVkO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL29iamVjdC50c1xuZnVuY3Rpb24gb2JqZWN0RXF1YWxXaXRoKGEsIGIsIGNtcCkge1xuICBmb3IgKGNvbnN0IGtleSBpbiBiKSB7XG4gICAgaWYgKCEoa2V5IGluIGEpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIGEpIHtcbiAgICBpZiAoIShrZXkgaW4gYikpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFjbXAoYVtrZXldLCBiW2tleV0pKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZGVlcE1lcmdlKC4uLnNvdXJjZXMpIHtcbiAgcmV0dXJuIG1lcmdlRGVmYXVsdHMoLi4uc291cmNlcy5yZXZlcnNlKCkpO1xufVxuZnVuY3Rpb24gbWVyZ2VEZWZhdWx0cyguLi5zb3VyY2VzKSB7XG4gIGNvbnN0IHRhcmdldCA9IHt9O1xuICBmb3IgKGNvbnN0IHNvdXJjZSBvZiBzb3VyY2VzKSB7XG4gICAgaWYgKCFpc09iamVjdChzb3VyY2UpKVxuICAgICAgY29udGludWU7XG4gICAgY29uc3Qga2V5cyA9IGlzRGVjb3JhdGVkT2JqZWN0KHNvdXJjZSkgPyBsaXN0RGVjb3JhdGVkUHJvcGVydGllcyhzb3VyY2UpIDogT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICBpZiAoaXNQbGFpbk9iamVjdCh0YXJnZXRba2V5XSkgJiYgaXNQbGFpbk9iamVjdChzb3VyY2Vba2V5XSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBtZXJnZURlZmF1bHRzKHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRba2V5XSA/PyAodGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBtZXJnZUFycmF5RGVmYXVsdHMoZGF0YUFycmF5LCAuLi5pdGVtRGVmYXVsdHMpIHtcbiAgaWYgKGl0ZW1EZWZhdWx0cyAmJiBpc0FycmF5KGRhdGFBcnJheSkpIHtcbiAgICByZXR1cm4gZGF0YUFycmF5Lm1hcCgoaXRlbSkgPT4gbWVyZ2VEZWZhdWx0cyhpdGVtLCAuLi5pdGVtRGVmYXVsdHMpKTtcbiAgfVxuICByZXR1cm4gZGF0YUFycmF5O1xufVxuZnVuY3Rpb24gbWFwVmFsdWVzKG9iamVjdDIsIG1hcHBlcikge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMob2JqZWN0MikucmVkdWNlKFxuICAgIChyZXN1bHQsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgcmVzdWx0W2tleV0gPSBtYXBwZXIodmFsdWUsIGtleSwgb2JqZWN0Mik7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAge31cbiAgKTtcbn1cbmZ1bmN0aW9uIHdpdGhvdXQob2JqZWN0Miwga2V5cykge1xuICBjb25zdCBjbG9uZTIgPSB7IC4uLm9iamVjdDIgfTtcbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIGRlbGV0ZSBjbG9uZTJba2V5XTtcbiAgfVxuICByZXR1cm4gY2xvbmUyO1xufVxuZnVuY3Rpb24gZ2V0UGF0aChvYmplY3QyLCBwYXRoKSB7XG4gIGNvbnN0IHBhdGhBcnJheSA9IGlzQXJyYXkocGF0aCkgPyBwYXRoIDogcGF0aC5zcGxpdChcIi5cIik7XG4gIHJldHVybiBwYXRoQXJyYXkucmVkdWNlKCh2YWx1ZSwgcGF0aEtleSkgPT4gdmFsdWVbcGF0aEtleV0sIG9iamVjdDIpO1xufVxudmFyIFNLSVBfSlNfQlVJTFRJTlMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJfX3Byb3RvX19cIiwgXCJjb25zdHJ1Y3RvclwiLCBcInByb3RvdHlwZVwiXSk7XG5mdW5jdGlvbiBzZXRQYXRoKG9iamVjdDIsIHBhdGgsIG5ld1ZhbHVlKSB7XG4gIGNvbnN0IHBhdGhBcnJheSA9IGlzQXJyYXkocGF0aCkgPyBwYXRoLnNsaWNlKCkgOiBwYXRoLnNwbGl0KFwiLlwiKTtcbiAgY29uc3QgbGFzdEtleSA9IHBhdGhBcnJheS5wb3AoKTtcbiAgaWYgKHBhdGhBcnJheS5zb21lKChwKSA9PiBTS0lQX0pTX0JVSUxUSU5TLmhhcyhwKSkpXG4gICAgcmV0dXJuO1xuICBjb25zdCBsYXN0T2JqZWN0ID0gcGF0aEFycmF5LnJlZHVjZSgodmFsdWUsIHBhdGhLZXkpID0+IHZhbHVlW3BhdGhLZXldLCBvYmplY3QyKTtcbiAgbGFzdE9iamVjdFtsYXN0S2V5XSA9IG5ld1ZhbHVlO1xuICByZXR1cm4gbGFzdE9iamVjdFtsYXN0S2V5XTtcbn1cbmZ1bmN0aW9uIHBhcnRpYWxBc3NpZ24oa2V5c1RvQ29weSwgdGFyZ2V0LCBzb3VyY2UpIHtcbiAgaWYgKHNvdXJjZSA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzVG9Db3B5KSB7XG4gICAgY29uc3QgdmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvbW90aW9uL2Vhc2luZy50c1xudmFyIGVhc2luZ19leHBvcnRzID0ge307XG5fX2V4cG9ydChlYXNpbmdfZXhwb3J0cywge1xuICBlYXNlSW46ICgpID0+IGVhc2VJbixcbiAgZWFzZUluT3V0OiAoKSA9PiBlYXNlSW5PdXQsXG4gIGVhc2VJbk91dFF1YWQ6ICgpID0+IGVhc2VJbk91dFF1YWQsXG4gIGVhc2VJblF1YWQ6ICgpID0+IGVhc2VJblF1YWQsXG4gIGVhc2VPdXQ6ICgpID0+IGVhc2VPdXQsXG4gIGVhc2VPdXRRdWFkOiAoKSA9PiBlYXNlT3V0UXVhZCxcbiAgaW52ZXJzZUVhc2VPdXQ6ICgpID0+IGludmVyc2VFYXNlT3V0LFxuICBsaW5lYXI6ICgpID0+IGxpbmVhclxufSk7XG52YXIgbGluZWFyID0gKG4pID0+IG47XG52YXIgZWFzZUluID0gKG4pID0+IDEgLSBNYXRoLmNvcyhuICogTWF0aC5QSSAvIDIpO1xudmFyIGVhc2VPdXQgPSAobikgPT4gTWF0aC5zaW4obiAqIE1hdGguUEkgLyAyKTtcbnZhciBlYXNlSW5PdXQgPSAobikgPT4gLShNYXRoLmNvcyhuICogTWF0aC5QSSkgLSAxKSAvIDI7XG52YXIgZWFzZUluUXVhZCA9IChuKSA9PiBuICogbjtcbnZhciBlYXNlT3V0UXVhZCA9IChuKSA9PiAxIC0gKDEgLSBuKSAqKiAyO1xudmFyIGVhc2VJbk91dFF1YWQgPSAobikgPT4gbiA8IDAuNSA/IDIgKiBuICogbiA6IDEgLSAoLTIgKiBuICsgMikgKiogMiAvIDI7XG52YXIgaW52ZXJzZUVhc2VPdXQgPSAoeCkgPT4gMiAqIE1hdGguYXNpbih4KSAvIE1hdGguUEk7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL21vdGlvbi9hbmltYXRpb24udHNcbnZhciBRVUlDS19UUkFOU0lUSU9OID0gMC4yO1xudmFyIFBIQVNFX09SREVSID0gW1wiaW5pdGlhbFwiLCBcInJlbW92ZVwiLCBcInVwZGF0ZVwiLCBcImFkZFwiLCBcInRyYWlsaW5nXCIsIFwiZW5kXCIsIFwibm9uZVwiXTtcbnZhciBQSEFTRV9NRVRBREFUQSA9IHtcbiAgaW5pdGlhbDoge1xuICAgIGFuaW1hdGlvbkR1cmF0aW9uOiAxLFxuICAgIGFuaW1hdGlvbkRlbGF5OiAwXG4gIH0sXG4gIGFkZDoge1xuICAgIGFuaW1hdGlvbkR1cmF0aW9uOiAwLjI1LFxuICAgIGFuaW1hdGlvbkRlbGF5OiAwLjc1XG4gIH0sXG4gIHJlbW92ZToge1xuICAgIGFuaW1hdGlvbkR1cmF0aW9uOiAwLjI1LFxuICAgIGFuaW1hdGlvbkRlbGF5OiAwXG4gIH0sXG4gIHVwZGF0ZToge1xuICAgIGFuaW1hdGlvbkR1cmF0aW9uOiAwLjUsXG4gICAgYW5pbWF0aW9uRGVsYXk6IDAuMjVcbiAgfSxcbiAgdHJhaWxpbmc6IHtcbiAgICBhbmltYXRpb25EdXJhdGlvbjogUVVJQ0tfVFJBTlNJVElPTixcbiAgICBhbmltYXRpb25EZWxheTogMSxcbiAgICBza2lwSWZOb0VhcmxpZXJBbmltYXRpb25zOiB0cnVlXG4gIH0sXG4gIGVuZDoge1xuICAgIGFuaW1hdGlvbkRlbGF5OiAxICsgUVVJQ0tfVFJBTlNJVElPTixcbiAgICBhbmltYXRpb25EdXJhdGlvbjogMCxcbiAgICBza2lwSWZOb0VhcmxpZXJBbmltYXRpb25zOiB0cnVlXG4gIH0sXG4gIG5vbmU6IHtcbiAgICBhbmltYXRpb25EdXJhdGlvbjogMCxcbiAgICBhbmltYXRpb25EZWxheTogMFxuICB9XG59O1xudmFyIFJlcGVhdFR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChSZXBlYXRUeXBlMikgPT4ge1xuICBSZXBlYXRUeXBlMltcIkxvb3BcIl0gPSBcImxvb3BcIjtcbiAgUmVwZWF0VHlwZTJbXCJSZXZlcnNlXCJdID0gXCJyZXZlcnNlXCI7XG4gIHJldHVybiBSZXBlYXRUeXBlMjtcbn0pKFJlcGVhdFR5cGUgfHwge30pO1xuZnVuY3Rpb24gaXNOb2RlQXJyYXkoYXJyYXkyKSB7XG4gIHJldHVybiBhcnJheTIuZXZlcnkoKG4pID0+IG4gaW5zdGFuY2VvZiBOb2RlKTtcbn1cbmZ1bmN0aW9uIGRlY29uc3RydWN0U2VsZWN0aW9uc09yTm9kZXMoc2VsZWN0aW9uc09yTm9kZXMpIHtcbiAgcmV0dXJuIGlzTm9kZUFycmF5KHNlbGVjdGlvbnNPck5vZGVzKSA/IHsgbm9kZXM6IHNlbGVjdGlvbnNPck5vZGVzLCBzZWxlY3Rpb25zOiBbXSB9IDogeyBub2RlczogW10sIHNlbGVjdGlvbnM6IHNlbGVjdGlvbnNPck5vZGVzIH07XG59XG5mdW5jdGlvbiBhbmltYXRpb25WYWx1ZXNFcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhKSAmJiBBcnJheS5pc0FycmF5KGIpKSB7XG4gICAgcmV0dXJuIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KCh2LCBpKSA9PiBhbmltYXRpb25WYWx1ZXNFcXVhbCh2LCBiW2ldKSk7XG4gIH0gZWxzZSBpZiAoaXNJbnRlcnBvbGF0aW5nKGEpICYmIGlzSW50ZXJwb2xhdGluZyhiKSkge1xuICAgIHJldHVybiBhLmVxdWFscyhiKTtcbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KGEpICYmIGlzUGxhaW5PYmplY3QoYikpIHtcbiAgICByZXR1cm4gb2JqZWN0RXF1YWxXaXRoKGEsIGIsIGFuaW1hdGlvblZhbHVlc0VxdWFsKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG52YXIgQW5pbWF0aW9uID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgdGhpcy5pc0NvbXBsZXRlID0gZmFsc2U7XG4gICAgdGhpcy5lbGFwc2VkID0gMDtcbiAgICB0aGlzLml0ZXJhdGlvbiA9IDA7XG4gICAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmlzUmV2ZXJzZSA9IGZhbHNlO1xuICAgIHRoaXMuaWQgPSBvcHRzLmlkO1xuICAgIHRoaXMuZ3JvdXBJZCA9IG9wdHMuZ3JvdXBJZDtcbiAgICB0aGlzLmF1dG9wbGF5ID0gb3B0cy5hdXRvcGxheSA/PyB0cnVlO1xuICAgIHRoaXMuZWFzZSA9IG9wdHMuZWFzZSA/PyBsaW5lYXI7XG4gICAgdGhpcy5waGFzZSA9IG9wdHMucGhhc2U7XG4gICAgY29uc3QgZHVyYXRpb25Qcm9wb3J0aW9uID0gb3B0cy5kdXJhdGlvbiA/PyBQSEFTRV9NRVRBREFUQVt0aGlzLnBoYXNlXS5hbmltYXRpb25EdXJhdGlvbjtcbiAgICB0aGlzLmR1cmF0aW9uID0gZHVyYXRpb25Qcm9wb3J0aW9uICogb3B0cy5kZWZhdWx0RHVyYXRpb247XG4gICAgdGhpcy5kZWxheSA9IChvcHRzLmRlbGF5ID8/IDApICogb3B0cy5kZWZhdWx0RHVyYXRpb247XG4gICAgdGhpcy5vbkNvbXBsZXRlID0gb3B0cy5vbkNvbXBsZXRlO1xuICAgIHRoaXMub25QbGF5ID0gb3B0cy5vblBsYXk7XG4gICAgdGhpcy5vblN0b3AgPSBvcHRzLm9uU3RvcDtcbiAgICB0aGlzLm9uVXBkYXRlID0gb3B0cy5vblVwZGF0ZTtcbiAgICB0aGlzLmludGVycG9sYXRlID0gdGhpcy5jcmVhdGVJbnRlcnBvbGF0b3Iob3B0cy5mcm9tLCBvcHRzLnRvKTtcbiAgICB0aGlzLmZyb20gPSBvcHRzLmZyb207XG4gICAgaWYgKG9wdHMuc2tpcCA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5vblVwZGF0ZT8uKG9wdHMudG8sIGZhbHNlLCB0aGlzKTtcbiAgICAgIHRoaXMub25TdG9wPy4odGhpcyk7XG4gICAgICB0aGlzLm9uQ29tcGxldGU/Lih0aGlzKTtcbiAgICAgIHRoaXMuaXNDb21wbGV0ZSA9IHRydWU7XG4gICAgfVxuICAgIGlmIChvcHRzLmNvbGxhcHNhYmxlICE9PSBmYWxzZSkge1xuICAgICAgdGhpcy5kdXJhdGlvbiA9IHRoaXMuY2hlY2tDb2xsYXBzZShvcHRzLCB0aGlzLmR1cmF0aW9uKTtcbiAgICB9XG4gIH1cbiAgY2hlY2tDb2xsYXBzZShvcHRzLCBjYWxjdWxhdGVkRHVyYXRpb24pIHtcbiAgICByZXR1cm4gYW5pbWF0aW9uVmFsdWVzRXF1YWwob3B0cy5mcm9tLCBvcHRzLnRvKSA/IDAgOiBjYWxjdWxhdGVkRHVyYXRpb247XG4gIH1cbiAgcGxheShpbml0aWFsVXBkYXRlID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy5pc1BsYXlpbmcgfHwgdGhpcy5pc0NvbXBsZXRlKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuaXNQbGF5aW5nID0gdHJ1ZTtcbiAgICB0aGlzLm9uUGxheT8uKHRoaXMpO1xuICAgIGlmICghdGhpcy5hdXRvcGxheSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmF1dG9wbGF5ID0gZmFsc2U7XG4gICAgaWYgKCFpbml0aWFsVXBkYXRlKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMub25VcGRhdGU/Lih0aGlzLmZyb20sIHRydWUsIHRoaXMpO1xuICB9XG4gIHBhdXNlKCkge1xuICAgIHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG4gIH1cbiAgc3RvcCgpIHtcbiAgICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuICAgIGlmICghdGhpcy5pc0NvbXBsZXRlKSB7XG4gICAgICB0aGlzLmlzQ29tcGxldGUgPSB0cnVlO1xuICAgICAgdGhpcy5vblN0b3A/Lih0aGlzKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlKHRpbWUyKSB7XG4gICAgaWYgKHRoaXMuaXNDb21wbGV0ZSlcbiAgICAgIHJldHVybiB0aW1lMjtcbiAgICBpZiAoIXRoaXMuaXNQbGF5aW5nICYmIHRoaXMuYXV0b3BsYXkpIHtcbiAgICAgIHRoaXMucGxheSh0cnVlKTtcbiAgICB9XG4gICAgY29uc3QgcHJldmlvdXNFbGFwc2VkID0gdGhpcy5lbGFwc2VkO1xuICAgIHRoaXMuZWxhcHNlZCArPSB0aW1lMjtcbiAgICBpZiAodGhpcy5kZWxheSA+IHRoaXMuZWxhcHNlZClcbiAgICAgIHJldHVybiAwO1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5pbnRlcnBvbGF0ZSh0aGlzLmlzUmV2ZXJzZSA/IDEgLSB0aGlzLmRlbHRhIDogdGhpcy5kZWx0YSk7XG4gICAgdGhpcy5vblVwZGF0ZT8uKHZhbHVlLCBmYWxzZSwgdGhpcyk7XG4gICAgY29uc3QgdG90YWxEdXJhdGlvbiA9IHRoaXMuZGVsYXkgKyB0aGlzLmR1cmF0aW9uO1xuICAgIGlmICh0aGlzLmVsYXBzZWQgPj0gdG90YWxEdXJhdGlvbikge1xuICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICB0aGlzLmlzQ29tcGxldGUgPSB0cnVlO1xuICAgICAgdGhpcy5vbkNvbXBsZXRlPy4odGhpcyk7XG4gICAgICByZXR1cm4gdGltZTIgLSAodG90YWxEdXJhdGlvbiAtIHByZXZpb3VzRWxhcHNlZCk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG4gIGdldCBkZWx0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5lYXNlKGNsYW1wKDAsICh0aGlzLmVsYXBzZWQgLSB0aGlzLmRlbGF5KSAvIHRoaXMuZHVyYXRpb24sIDEpKTtcbiAgfVxuICBjcmVhdGVJbnRlcnBvbGF0b3IoZnJvbTMsIHRvKSB7XG4gICAgaWYgKHR5cGVvZiB0byAhPT0gXCJvYmplY3RcIiB8fCBpc0ludGVycG9sYXRpbmcodG8pKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbnRlcnBvbGF0ZVZhbHVlKGZyb20zLCB0byk7XG4gICAgfVxuICAgIGNvbnN0IGludGVycG9sYXRvckVudHJpZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB0bykge1xuICAgICAgY29uc3QgaW50ZXJwb2xhdG9yID0gdGhpcy5pbnRlcnBvbGF0ZVZhbHVlKGZyb20zW2tleV0sIHRvW2tleV0pO1xuICAgICAgaWYgKGludGVycG9sYXRvciAhPSBudWxsKSB7XG4gICAgICAgIGludGVycG9sYXRvckVudHJpZXMucHVzaChba2V5LCBpbnRlcnBvbGF0b3JdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIChkKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgaW50ZXJwb2xhdG9yXSBvZiBpbnRlcnBvbGF0b3JFbnRyaWVzKSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gaW50ZXJwb2xhdG9yKGQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9XG4gIGludGVycG9sYXRlVmFsdWUoYSwgYikge1xuICAgIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChpc0ludGVycG9sYXRpbmcoYSkpIHtcbiAgICAgIHJldHVybiAoZCkgPT4gYVtpbnRlcnBvbGF0ZV0oYiwgZCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBzd2l0Y2ggKHR5cGVvZiBhKSB7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICByZXR1cm4gaW50ZXJwb2xhdGVOdW1iZXIoYSwgYik7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICByZXR1cm4gaW50ZXJwb2xhdGVDb2xvcihhLCBiKTtcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IGE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gaW50ZXJwb2xhdGUgdmFsdWVzOiAke2F9LCAke2J9YCk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL21vdGlvbi9mcm9tVG9Nb3Rpb24udHNcbnZhciBOT0RFX1VQREFURV9TVEFURV9UT19QSEFTRV9NQVBQSU5HID0ge1xuICBhZGRlZDogXCJhZGRcIixcbiAgdXBkYXRlZDogXCJ1cGRhdGVcIixcbiAgcmVtb3ZlZDogXCJyZW1vdmVcIixcbiAgdW5rbm93bjogXCJpbml0aWFsXCIsXG4gIFwibm8tb3BcIjogXCJub25lXCJcbn07XG5mdW5jdGlvbiBmcm9tVG9Nb3Rpb24oZ3JvdXBJZCwgc3ViSWQsIGFuaW1hdGlvbk1hbmFnZXIsIHNlbGVjdGlvbnNPck5vZGVzLCBmbnMsIGdldERhdHVtSWQsIGRpZmYyKSB7XG4gIGNvbnN0IHsgZnJvbUZuLCB0b0ZuLCBhcHBseUZuID0gKG5vZGUsIHByb3BzKSA9PiBub2RlLnNldFByb3BlcnRpZXMocHJvcHMpIH0gPSBmbnM7XG4gIGNvbnN0IHsgbm9kZXMsIHNlbGVjdGlvbnMgfSA9IGRlY29uc3RydWN0U2VsZWN0aW9uc09yTm9kZXMoc2VsZWN0aW9uc09yTm9kZXMpO1xuICBjb25zdCBwcm9jZXNzTm9kZXMgPSAobGl2ZU5vZGVzLCBzdWJOb2RlcykgPT4ge1xuICAgIGxldCBwcmV2RnJvbVByb3BzO1xuICAgIGxldCBsaXZlTm9kZUluZGV4ID0gMDtcbiAgICBsZXQgbm9kZUluZGV4ID0gMDtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygc3ViTm9kZXMpIHtcbiAgICAgIGNvbnN0IGlzTGl2ZSA9IGxpdmVOb2Rlc1tsaXZlTm9kZUluZGV4XSA9PT0gbm9kZTtcbiAgICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgICAgbGFzdDogbm9kZUluZGV4ID49IHN1Yk5vZGVzLmxlbmd0aCAtIDEsXG4gICAgICAgIGxhc3RMaXZlOiBsaXZlTm9kZUluZGV4ID49IGxpdmVOb2Rlcy5sZW5ndGggLSAxLFxuICAgICAgICBwcmV2OiBzdWJOb2Rlc1tub2RlSW5kZXggLSAxXSxcbiAgICAgICAgcHJldkZyb21Qcm9wcyxcbiAgICAgICAgcHJldkxpdmU6IGxpdmVOb2Rlc1tsaXZlTm9kZUluZGV4IC0gMV0sXG4gICAgICAgIG5leHQ6IHN1Yk5vZGVzW25vZGVJbmRleCArIDFdLFxuICAgICAgICBuZXh0TGl2ZTogbGl2ZU5vZGVzW2xpdmVOb2RlSW5kZXggKyAoaXNMaXZlID8gMSA6IDApXVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGFuaW1hdGlvbklkID0gYCR7Z3JvdXBJZH1fJHtzdWJJZH1fJHtub2RlLmlkfWA7XG4gICAgICBhbmltYXRpb25NYW5hZ2VyLnN0b3BCeUFuaW1hdGlvbklkKGFuaW1hdGlvbklkKTtcbiAgICAgIGxldCBzdGF0dXMgPSBcInVua25vd25cIjtcbiAgICAgIGlmICghaXNMaXZlKSB7XG4gICAgICAgIHN0YXR1cyA9IFwicmVtb3ZlZFwiO1xuICAgICAgfSBlbHNlIGlmIChnZXREYXR1bUlkICYmIGRpZmYyKSB7XG4gICAgICAgIHN0YXR1cyA9IGNhbGN1bGF0ZVN0YXR1cyhub2RlLCBub2RlLmRhdHVtLCBnZXREYXR1bUlkLCBkaWZmMik7XG4gICAgICB9XG4gICAgICBub2RlLnRyYW5zaXRpb25PdXQgPSBzdGF0dXMgPT09IFwicmVtb3ZlZFwiO1xuICAgICAgY29uc3QgeyBwaGFzZSwgc3RhcnQ6IHN0YXJ0MiwgZmluaXNoLCBkZWxheSwgZHVyYXRpb24sIC4uLmZyb20zIH0gPSBmcm9tRm4obm9kZSwgbm9kZS5kYXR1bSwgc3RhdHVzLCBjdHgpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBwaGFzZTogdG9QaGFzZSxcbiAgICAgICAgc3RhcnQ6IHRvU3RhcnQsXG4gICAgICAgIGZpbmlzaDogdG9GaW5pc2gsXG4gICAgICAgIGRlbGF5OiB0b0RlbGF5LFxuICAgICAgICBkdXJhdGlvbjogdG9EdXJhdGlvbixcbiAgICAgICAgLi4udG9cbiAgICAgIH0gPSB0b0ZuKG5vZGUsIG5vZGUuZGF0dW0sIHN0YXR1cywgY3R4KTtcbiAgICAgIGNvbnN0IGNvbGxhcHNhYmxlID0gZmluaXNoID09IG51bGw7XG4gICAgICBhbmltYXRpb25NYW5hZ2VyLmFuaW1hdGUoe1xuICAgICAgICBpZDogYW5pbWF0aW9uSWQsXG4gICAgICAgIGdyb3VwSWQsXG4gICAgICAgIHBoYXNlOiBwaGFzZSA/PyB0b1BoYXNlID8/IFwidXBkYXRlXCIsXG4gICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbiA/PyB0b0R1cmF0aW9uLFxuICAgICAgICBkZWxheTogZGVsYXkgPz8gdG9EZWxheSxcbiAgICAgICAgZnJvbTogZnJvbTMsXG4gICAgICAgIHRvLFxuICAgICAgICBlYXNlOiBlYXNlT3V0LFxuICAgICAgICBjb2xsYXBzYWJsZSxcbiAgICAgICAgb25QbGF5OiAoKSA9PiB7XG4gICAgICAgICAgYXBwbHlGbihub2RlLCB7IC4uLnN0YXJ0MiwgLi4udG9TdGFydCwgLi4uZnJvbTMgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uVXBkYXRlKHByb3BzKSB7XG4gICAgICAgICAgYXBwbHlGbihub2RlLCBwcm9wcyk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uU3RvcDogKCkgPT4ge1xuICAgICAgICAgIGFwcGx5Rm4obm9kZSwge1xuICAgICAgICAgICAgLi4uc3RhcnQyLFxuICAgICAgICAgICAgLi4udG9TdGFydCxcbiAgICAgICAgICAgIC4uLmZyb20zLFxuICAgICAgICAgICAgLi4udG8sXG4gICAgICAgICAgICAuLi5maW5pc2gsXG4gICAgICAgICAgICAuLi50b0ZpbmlzaFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChpc0xpdmUpIHtcbiAgICAgICAgbGl2ZU5vZGVJbmRleCsrO1xuICAgICAgfVxuICAgICAgbm9kZUluZGV4Kys7XG4gICAgICBwcmV2RnJvbVByb3BzID0gZnJvbTM7XG4gICAgfVxuICB9O1xuICBsZXQgc2VsZWN0aW9uSW5kZXggPSAwO1xuICBmb3IgKGNvbnN0IHNlbGVjdGlvbiBvZiBzZWxlY3Rpb25zKSB7XG4gICAgY29uc3Qgc2VsZWN0aW9uTm9kZXMgPSBzZWxlY3Rpb24ubm9kZXMoKTtcbiAgICBjb25zdCBsaXZlTm9kZXMgPSBzZWxlY3Rpb25Ob2Rlcy5maWx0ZXIoKG4pID0+ICFzZWxlY3Rpb24uaXNHYXJiYWdlKG4pKTtcbiAgICBwcm9jZXNzTm9kZXMobGl2ZU5vZGVzLCBzZWxlY3Rpb25Ob2Rlcyk7XG4gICAgYW5pbWF0aW9uTWFuYWdlci5hbmltYXRlKHtcbiAgICAgIGlkOiBgJHtncm91cElkfV8ke3N1YklkfV9zZWxlY3Rpb25fJHtzZWxlY3Rpb25JbmRleH1gLFxuICAgICAgZ3JvdXBJZCxcbiAgICAgIHBoYXNlOiBcImVuZFwiLFxuICAgICAgZnJvbTogMCxcbiAgICAgIHRvOiAxLFxuICAgICAgZWFzZTogZWFzZU91dCxcbiAgICAgIG9uU3RvcCgpIHtcbiAgICAgICAgc2VsZWN0aW9uLmNsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBzZWxlY3Rpb25JbmRleCsrO1xuICB9XG4gIHByb2Nlc3NOb2Rlcyhub2Rlcywgbm9kZXMpO1xufVxuZnVuY3Rpb24gc3RhdGljRnJvbVRvTW90aW9uKGdyb3VwSWQsIHN1YklkLCBhbmltYXRpb25NYW5hZ2VyLCBzZWxlY3Rpb25zT3JOb2RlcywgZnJvbTMsIHRvLCBleHRyYU9wdHMpIHtcbiAgY29uc3QgeyBub2Rlcywgc2VsZWN0aW9ucyB9ID0gZGVjb25zdHJ1Y3RTZWxlY3Rpb25zT3JOb2RlcyhzZWxlY3Rpb25zT3JOb2Rlcyk7XG4gIGNvbnN0IHsgc3RhcnQ6IHN0YXJ0MiwgZmluaXNoLCBwaGFzZSB9ID0gZXh0cmFPcHRzO1xuICBhbmltYXRpb25NYW5hZ2VyLmFuaW1hdGUoe1xuICAgIGlkOiBgJHtncm91cElkfV8ke3N1YklkfWAsXG4gICAgZ3JvdXBJZCxcbiAgICBwaGFzZTogcGhhc2UgPz8gXCJ1cGRhdGVcIixcbiAgICBmcm9tOiBmcm9tMyxcbiAgICB0byxcbiAgICBlYXNlOiBlYXNlT3V0LFxuICAgIG9uUGxheTogKCkgPT4ge1xuICAgICAgaWYgKCFzdGFydDIpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xuICAgICAgICBub2RlLnNldFByb3BlcnRpZXMoc3RhcnQyKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3Qgc2VsZWN0aW9uIG9mIHNlbGVjdGlvbnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIHNlbGVjdGlvbi5ub2RlcygpKSB7XG4gICAgICAgICAgbm9kZS5zZXRQcm9wZXJ0aWVzKHN0YXJ0Mik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIG9uVXBkYXRlKHByb3BzKSB7XG4gICAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICAgICAgbm9kZS5zZXRQcm9wZXJ0aWVzKHByb3BzKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3Qgc2VsZWN0aW9uIG9mIHNlbGVjdGlvbnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIHNlbGVjdGlvbi5ub2RlcygpKSB7XG4gICAgICAgICAgbm9kZS5zZXRQcm9wZXJ0aWVzKHByb3BzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgb25TdG9wOiAoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICAgICAgbm9kZS5zZXRQcm9wZXJ0aWVzKHsgLi4udG8sIC4uLmZpbmlzaCB9KTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3Qgc2VsZWN0aW9uIG9mIHNlbGVjdGlvbnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIHNlbGVjdGlvbi5ub2RlcygpKSB7XG4gICAgICAgICAgbm9kZS5zZXRQcm9wZXJ0aWVzKHsgLi4udG8sIC4uLmZpbmlzaCB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZWxlY3Rpb24uY2xlYW51cCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVTdGF0dXMobm9kZSwgZGF0dW0sIGdldERhdHVtSWQsIGRpZmYyKSB7XG4gIGNvbnN0IGlkID0gZ2V0RGF0dW1JZChub2RlLCBkYXR1bSk7XG4gIGlmIChkaWZmMi5hZGRlZC5oYXMoaWQpKSB7XG4gICAgcmV0dXJuIFwiYWRkZWRcIjtcbiAgfVxuICBpZiAoZGlmZjIucmVtb3ZlZC5oYXMoaWQpKSB7XG4gICAgcmV0dXJuIFwicmVtb3ZlZFwiO1xuICB9XG4gIHJldHVybiBcInVwZGF0ZWRcIjtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NhbGUvaW52YWxpZGF0aW5nLnRzXG52YXIgSW52YWxpZGF0aW5nID0gKHRhcmdldCwgcHJvcGVydHlLZXkpID0+IHtcbiAgY29uc3QgbWFwcGVkUHJvcGVydHkgPSBTeW1ib2woU3RyaW5nKHByb3BlcnR5S2V5KSk7XG4gIHRhcmdldFttYXBwZWRQcm9wZXJ0eV0gPSB2b2lkIDA7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5LCB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXNbbWFwcGVkUHJvcGVydHldO1xuICAgIH0sXG4gICAgc2V0KG5ld1ZhbHVlKSB7XG4gICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXNbbWFwcGVkUHJvcGVydHldO1xuICAgICAgaWYgKG9sZFZhbHVlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgICB0aGlzW21hcHBlZFByb3BlcnR5XSA9IG5ld1ZhbHVlO1xuICAgICAgICB0aGlzLmludmFsaWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gIH0pO1xufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NhbGUvY29udGludW91c1NjYWxlLnRzXG52YXIgX0NvbnRpbnVvdXNTY2FsZSA9IGNsYXNzIF9Db250aW51b3VzU2NhbGUge1xuICBjb25zdHJ1Y3Rvcihkb21haW4sIHJhbmdlMykge1xuICAgIHRoaXMuaW52YWxpZCA9IHRydWU7XG4gICAgdGhpcy5uaWNlID0gZmFsc2U7XG4gICAgdGhpcy5pbnRlcnZhbCA9IHZvaWQgMDtcbiAgICB0aGlzLnRpY2tDb3VudCA9IF9Db250aW51b3VzU2NhbGUuZGVmYXVsdFRpY2tDb3VudDtcbiAgICB0aGlzLm1pblRpY2tDb3VudCA9IDA7XG4gICAgdGhpcy5tYXhUaWNrQ291bnQgPSBJbmZpbml0eTtcbiAgICAvLyBUT0RPKG9sZWdhdCkgc2hvdWxkIGJlIG9mIHR5cGUgRFtdXG4gICAgdGhpcy5uaWNlRG9tYWluID0gW107XG4gICAgdGhpcy5kZWZhdWx0Q2xhbXBNb2RlID0gXCJyYXdcIjtcbiAgICB0aGlzLmRvbWFpbiA9IGRvbWFpbjtcbiAgICB0aGlzLnJhbmdlID0gcmFuZ2UzO1xuICB9XG4gIHN0YXRpYyBpcyh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIF9Db250aW51b3VzU2NhbGU7XG4gIH1cbiAgdHJhbnNmb3JtKHgpIHtcbiAgICByZXR1cm4geDtcbiAgfVxuICB0cmFuc2Zvcm1JbnZlcnQoeCkge1xuICAgIHJldHVybiB4O1xuICB9XG4gIGNhbGNCYW5kd2lkdGgoc21hbGxlc3RJbnRlcnZhbCA9IDEpIHtcbiAgICBjb25zdCBkb21haW4gPSB0aGlzLmdldERvbWFpbigpO1xuICAgIGNvbnN0IHJhbmdlRGlzdGFuY2UgPSB0aGlzLmdldFBpeGVsUmFuZ2UoKTtcbiAgICBjb25zdCBpbnRlcnZhbHMgPSBNYXRoLmFicyhkb21haW5bMV0gLSBkb21haW5bMF0pIC8gc21hbGxlc3RJbnRlcnZhbCArIDE7XG4gICAgY29uc3QgbWF4QmFuZHMgPSBNYXRoLmZsb29yKHJhbmdlRGlzdGFuY2UpO1xuICAgIGNvbnN0IGJhbmRzID0gTWF0aC5taW4oaW50ZXJ2YWxzLCBtYXhCYW5kcyk7XG4gICAgcmV0dXJuIHJhbmdlRGlzdGFuY2UgLyBNYXRoLm1heCgxLCBiYW5kcyk7XG4gIH1cbiAgZ2V0RG9tYWluKCkge1xuICAgIGlmICh0aGlzLm5pY2UpIHtcbiAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgICAgaWYgKHRoaXMubmljZURvbWFpbi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmljZURvbWFpbjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZG9tYWluO1xuICB9XG4gIGNvbnZlcnQoeCwgb3B0cykge1xuICAgIGNvbnN0IGNsYW1wTW9kZSA9IG9wdHM/LmNsYW1wTW9kZSA/PyB0aGlzLmRlZmF1bHRDbGFtcE1vZGU7XG4gICAgaWYgKCF0aGlzLmRvbWFpbiB8fCB0aGlzLmRvbWFpbi5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICB0aGlzLnJlZnJlc2goKTtcbiAgICBjb25zdCBkb21haW4gPSB0aGlzLmdldERvbWFpbigpLm1hcCgoZCkgPT4gdGhpcy50cmFuc2Zvcm0oZCkpO1xuICAgIGNvbnN0IFtkMCwgZDFdID0gZG9tYWluO1xuICAgIGNvbnN0IHsgcmFuZ2U6IHJhbmdlMyB9ID0gdGhpcztcbiAgICBjb25zdCBbcjAsIHIxXSA9IHJhbmdlMztcbiAgICB4ID0gdGhpcy50cmFuc2Zvcm0oeCk7XG4gICAgaWYgKGNsYW1wTW9kZSA9PT0gXCJjbGFtcGVkXCIpIHtcbiAgICAgIGNvbnN0IFtzdGFydDIsIHN0b3BdID0gZmluZE1pbk1heChkb21haW4ubWFwKE51bWJlcikpO1xuICAgICAgaWYgKE51bWJlcih4KSA8IHN0YXJ0Mikge1xuICAgICAgICByZXR1cm4gcjA7XG4gICAgICB9IGVsc2UgaWYgKE51bWJlcih4KSA+IHN0b3ApIHtcbiAgICAgICAgcmV0dXJuIHIxO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZDAgPT09IGQxKSB7XG4gICAgICByZXR1cm4gKHIwICsgcjEpIC8gMjtcbiAgICB9IGVsc2UgaWYgKHggPT09IGQwKSB7XG4gICAgICByZXR1cm4gcjA7XG4gICAgfSBlbHNlIGlmICh4ID09PSBkMSkge1xuICAgICAgcmV0dXJuIHIxO1xuICAgIH1cbiAgICByZXR1cm4gcjAgKyAoTnVtYmVyKHgpIC0gTnVtYmVyKGQwKSkgLyAoTnVtYmVyKGQxKSAtIE51bWJlcihkMCkpICogKHIxIC0gcjApO1xuICB9XG4gIGludmVydCh4KSB7XG4gICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgY29uc3QgZG9tYWluID0gdGhpcy5nZXREb21haW4oKS5tYXAoKGQyKSA9PiB0aGlzLnRyYW5zZm9ybShkMikpO1xuICAgIGNvbnN0IFtkMCwgZDFdID0gZG9tYWluO1xuICAgIGNvbnN0IHsgcmFuZ2U6IHJhbmdlMyB9ID0gdGhpcztcbiAgICBjb25zdCBbcjAsIHIxXSA9IHJhbmdlMztcbiAgICBjb25zdCBpc1JldmVyc2VkID0gcjAgPiByMTtcbiAgICBjb25zdCByTWluID0gaXNSZXZlcnNlZCA/IHIxIDogcjA7XG4gICAgY29uc3Qgck1heCA9IGlzUmV2ZXJzZWQgPyByMCA6IHIxO1xuICAgIGxldCBkO1xuICAgIGlmICh4IDwgck1pbikge1xuICAgICAgcmV0dXJuIGlzUmV2ZXJzZWQgPyBkMSA6IGQwO1xuICAgIH0gZWxzZSBpZiAoeCA+IHJNYXgpIHtcbiAgICAgIHJldHVybiBpc1JldmVyc2VkID8gZDAgOiBkMTtcbiAgICB9IGVsc2UgaWYgKHIwID09PSByMSkge1xuICAgICAgZCA9IHRoaXMudG9Eb21haW4oKE51bWJlcihkMCkgKyBOdW1iZXIoZDEpKSAvIDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkID0gdGhpcy50b0RvbWFpbihOdW1iZXIoZDApICsgKHggLSByMCkgLyAocjEgLSByMCkgKiAoTnVtYmVyKGQxKSAtIE51bWJlcihkMCkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtSW52ZXJ0KGQpO1xuICB9XG4gIHJlZnJlc2goKSB7XG4gICAgaWYgKCF0aGlzLmludmFsaWQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5pbnZhbGlkID0gZmFsc2U7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgICBpZiAodGhpcy5pbnZhbGlkKSB7XG4gICAgICBMb2dnZXIud2Fybk9uY2UoXCJFeHBlY3RlZCB1cGRhdGUgdG8gbm90IGludmFsaWRhdGUgc2NhbGVcIik7XG4gICAgfVxuICB9XG4gIGdldFBpeGVsUmFuZ2UoKSB7XG4gICAgY29uc3QgW2EsIGJdID0gdGhpcy5yYW5nZTtcbiAgICByZXR1cm4gTWF0aC5hYnMoYiAtIGEpO1xuICB9XG59O1xuX0NvbnRpbnVvdXNTY2FsZS5kZWZhdWx0VGlja0NvdW50ID0gNTtcbl9Db250aW51b3VzU2NhbGUuZGVmYXVsdE1heFRpY2tDb3VudCA9IDY7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBJbnZhbGlkYXRpbmdcbl0sIF9Db250aW51b3VzU2NhbGUucHJvdG90eXBlLCBcImRvbWFpblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEludmFsaWRhdGluZ1xuXSwgX0NvbnRpbnVvdXNTY2FsZS5wcm90b3R5cGUsIFwicmFuZ2VcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBJbnZhbGlkYXRpbmdcbl0sIF9Db250aW51b3VzU2NhbGUucHJvdG90eXBlLCBcIm5pY2VcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBJbnZhbGlkYXRpbmdcbl0sIF9Db250aW51b3VzU2NhbGUucHJvdG90eXBlLCBcImludGVydmFsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgSW52YWxpZGF0aW5nXG5dLCBfQ29udGludW91c1NjYWxlLnByb3RvdHlwZSwgXCJ0aWNrQ291bnRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBJbnZhbGlkYXRpbmdcbl0sIF9Db250aW51b3VzU2NhbGUucHJvdG90eXBlLCBcIm1pblRpY2tDb3VudFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEludmFsaWRhdGluZ1xuXSwgX0NvbnRpbnVvdXNTY2FsZS5wcm90b3R5cGUsIFwibWF4VGlja0NvdW50XCIsIDIpO1xudmFyIENvbnRpbnVvdXNTY2FsZSA9IF9Db250aW51b3VzU2NhbGU7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvYXJyYXkudHNcbmZ1bmN0aW9uIGV4dGVudCh2YWx1ZXMpIHtcbiAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBsZXQgbWluID0gSW5maW5pdHk7XG4gIGxldCBtYXggPSAtSW5maW5pdHk7XG4gIGZvciAobGV0IG4gb2YgdmFsdWVzKSB7XG4gICAgaWYgKG4gaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICBuID0gbi5nZXRUaW1lKCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbiAhPT0gXCJudW1iZXJcIikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChuIDwgbWluKSB7XG4gICAgICBtaW4gPSBuO1xuICAgIH1cbiAgICBpZiAobiA+IG1heCkge1xuICAgICAgbWF4ID0gbjtcbiAgICB9XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gW21pbiwgbWF4XTtcbiAgcmV0dXJuIHJlc3VsdC5ldmVyeShpc0Zpbml0ZSkgPyByZXN1bHQgOiBudWxsO1xufVxuZnVuY3Rpb24gbm9ybWFsaXNlZEV4dGVudFdpdGhNZXRhZGF0YShkLCBtaW4sIG1heCkge1xuICBsZXQgY2xpcHBlZCA9IGZhbHNlO1xuICBpZiAoZC5sZW5ndGggPiAyKSB7XG4gICAgZCA9IGV4dGVudChkKSA/PyBbTmFOLCBOYU5dO1xuICB9XG4gIGlmICghaXNOYU4obWluKSkge1xuICAgIGNsaXBwZWQgfHwgKGNsaXBwZWQgPSBtaW4gPiBkWzBdKTtcbiAgICBkID0gW21pbiwgZFsxXV07XG4gIH1cbiAgaWYgKCFpc05hTihtYXgpKSB7XG4gICAgY2xpcHBlZCB8fCAoY2xpcHBlZCA9IG1heCA8IGRbMV0pO1xuICAgIGQgPSBbZFswXSwgbWF4XTtcbiAgfVxuICBpZiAoZFswXSA+IGRbMV0pIHtcbiAgICBkID0gW107XG4gIH1cbiAgcmV0dXJuIHsgZXh0ZW50OiBkLCBjbGlwcGVkIH07XG59XG5mdW5jdGlvbiBhcnJheXNFcXVhbChhLCBiKSB7XG4gIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsIHx8IGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhW2ldKSAmJiBBcnJheS5pc0FycmF5KGJbaV0pKSB7XG4gICAgICBpZiAoIWFycmF5c0VxdWFsKGFbaV0sIGJbaV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiB0b0FycmF5KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xufVxuZnVuY3Rpb24gdW5pcXVlKGFycmF5Mikge1xuICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KGFycmF5MikpO1xufVxuZnVuY3Rpb24gZ3JvdXBCeShhcnJheTIsIGl0ZXJhdGVlKSB7XG4gIHJldHVybiBhcnJheTIucmVkdWNlKChyZXN1bHQsIGl0ZW0pID0+IHtcbiAgICBjb25zdCBncm91cEtleSA9IGl0ZXJhdGVlKGl0ZW0pO1xuICAgIHJlc3VsdFtncm91cEtleV0gPz8gKHJlc3VsdFtncm91cEtleV0gPSBbXSk7XG4gICAgcmVzdWx0W2dyb3VwS2V5XS5wdXNoKGl0ZW0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIGNpcmN1bGFyU2xpY2VBcnJheShkYXRhLCBzaXplLCBvZmZzZXQ0ID0gMCkge1xuICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgcmVzdWx0LnB1c2goZGF0YS5hdCgoaSArIG9mZnNldDQpICUgZGF0YS5sZW5ndGgpKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gc29ydEJhc2VkT25BcnJheShiYXNlQXJyYXksIG9yZGVyQXJyYXkpIHtcbiAgY29uc3Qgb3JkZXJNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBvcmRlckFycmF5LmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgb3JkZXJNYXAuc2V0KGl0ZW0sIGluZGV4KTtcbiAgfSk7XG4gIHJldHVybiBiYXNlQXJyYXkuc29ydCgoYSwgYikgPT4ge1xuICAgIGNvbnN0IGluZGV4QSA9IG9yZGVyTWFwLmdldChhKSA/PyBJbmZpbml0eTtcbiAgICBjb25zdCBpbmRleEIgPSBvcmRlck1hcC5nZXQoYikgPz8gSW5maW5pdHk7XG4gICAgcmV0dXJuIGluZGV4QSAtIGluZGV4QjtcbiAgfSk7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvdGltZUZvcm1hdC50c1xudmFyIENPTlNUQU5UUyA9IHtcbiAgcGVyaW9kczogW1wiQU1cIiwgXCJQTVwiXSxcbiAgZGF5czogW1wiU3VuZGF5XCIsIFwiTW9uZGF5XCIsIFwiVHVlc2RheVwiLCBcIldlZG5lc2RheVwiLCBcIlRodXJzZGF5XCIsIFwiRnJpZGF5XCIsIFwiU2F0dXJkYXlcIl0sXG4gIHNob3J0RGF5czogW1wiU3VuXCIsIFwiTW9uXCIsIFwiVHVlXCIsIFwiV2VkXCIsIFwiVGh1XCIsIFwiRnJpXCIsIFwiU2F0XCJdLFxuICBtb250aHM6IFtcbiAgICBcIkphbnVhcnlcIixcbiAgICBcIkZlYnJ1YXJ5XCIsXG4gICAgXCJNYXJjaFwiLFxuICAgIFwiQXByaWxcIixcbiAgICBcIk1heVwiLFxuICAgIFwiSnVuZVwiLFxuICAgIFwiSnVseVwiLFxuICAgIFwiQXVndXN0XCIsXG4gICAgXCJTZXB0ZW1iZXJcIixcbiAgICBcIk9jdG9iZXJcIixcbiAgICBcIk5vdmVtYmVyXCIsXG4gICAgXCJEZWNlbWJlclwiXG4gIF0sXG4gIHNob3J0TW9udGhzOiBbXCJKYW5cIiwgXCJGZWJcIiwgXCJNYXJcIiwgXCJBcHJcIiwgXCJNYXlcIiwgXCJKdW5cIiwgXCJKdWxcIiwgXCJBdWdcIiwgXCJTZXBcIiwgXCJPY3RcIiwgXCJOb3ZcIiwgXCJEZWNcIl1cbn07XG5mdW5jdGlvbiBkYXlPZlllYXIoZGF0ZSwgc3RhcnRPZlllYXIgPSBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIDAsIDEpKSB7XG4gIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpIC0gc3RhcnRPZlllYXIuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgY29uc3QgdGltZURpZmYgPSBkYXRlLmdldFRpbWUoKSAtIHN0YXJ0T2ZZZWFyLmdldFRpbWUoKSArIHN0YXJ0T2Zmc2V0ICogNmU0O1xuICBjb25zdCB0aW1lT25lRGF5ID0gMzZlNSAqIDI0O1xuICByZXR1cm4gTWF0aC5mbG9vcih0aW1lRGlmZiAvIHRpbWVPbmVEYXkpO1xufVxuZnVuY3Rpb24gd2Vla09mWWVhcihkYXRlLCBzdGFydERheSkge1xuICBjb25zdCBzdGFydE9mWWVhciA9IG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgMCwgMSk7XG4gIGNvbnN0IHN0YXJ0T2ZZZWFyRGF5ID0gc3RhcnRPZlllYXIuZ2V0RGF5KCk7XG4gIGNvbnN0IGZpcnN0V2Vla1N0YXJ0T2Zmc2V0ID0gKHN0YXJ0RGF5IC0gc3RhcnRPZlllYXJEYXkgKyA3KSAlIDc7XG4gIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCAwLCBmaXJzdFdlZWtTdGFydE9mZnNldCArIDEpO1xuICBpZiAoc3RhcnRPZmZzZXQgPD0gZGF0ZSkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKGRheU9mWWVhcihkYXRlLCBzdGFydE9mZnNldCkgLyA3KSArIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG52YXIgU1VOREFZID0gMDtcbnZhciBNT05EQVkgPSAxO1xudmFyIFRIVVJTREFZID0gNDtcbmZ1bmN0aW9uIGlzb1dlZWtPZlllYXIoZGF0ZSwgeWVhcjIgPSBkYXRlLmdldEZ1bGxZZWFyKCkpIHtcbiAgY29uc3QgZmlyc3RPZlllYXIgPSBuZXcgRGF0ZSh5ZWFyMiwgMCwgMSk7XG4gIGNvbnN0IGZpcnN0T2ZZZWFyRGF5ID0gZmlyc3RPZlllYXIuZ2V0RGF5KCk7XG4gIGNvbnN0IGZpcnN0VGh1cnNkYXlPZmZzZXQgPSAoVEhVUlNEQVkgLSBmaXJzdE9mWWVhckRheSArIDcpICUgNztcbiAgY29uc3Qgc3RhcnRPZmZzZXQgPSBuZXcgRGF0ZSh5ZWFyMiwgMCwgZmlyc3RUaHVyc2RheU9mZnNldCAtIChUSFVSU0RBWSAtIE1PTkRBWSkgKyAxKTtcbiAgaWYgKHN0YXJ0T2Zmc2V0IDw9IGRhdGUpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihkYXlPZlllYXIoZGF0ZSwgc3RhcnRPZmZzZXQpIC8gNykgKyAxO1xuICB9XG4gIHJldHVybiBpc29XZWVrT2ZZZWFyKGRhdGUsIHllYXIyIC0gMSk7XG59XG5mdW5jdGlvbiB0aW1lem9uZShkYXRlKSB7XG4gIGNvbnN0IG9mZnNldDQgPSBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gIGNvbnN0IHVuc2lnbmVkT2Zmc2V0ID0gTWF0aC5hYnMob2Zmc2V0NCk7XG4gIGNvbnN0IHNpZ24gPSBvZmZzZXQ0ID4gMCA/IFwiLVwiIDogXCIrXCI7XG4gIHJldHVybiBgJHtzaWdufSR7cGFkKE1hdGguZmxvb3IodW5zaWduZWRPZmZzZXQgLyA2MCksIDIsIFwiMFwiKX0ke3BhZChNYXRoLmZsb29yKHVuc2lnbmVkT2Zmc2V0ICUgNjApLCAyLCBcIjBcIil9YDtcbn1cbnZhciBGT1JNQVRURVJTID0ge1xuICBhOiAoZCkgPT4gQ09OU1RBTlRTLnNob3J0RGF5c1tkLmdldERheSgpXSxcbiAgQTogKGQpID0+IENPTlNUQU5UUy5kYXlzW2QuZ2V0RGF5KCldLFxuICBiOiAoZCkgPT4gQ09OU1RBTlRTLnNob3J0TW9udGhzW2QuZ2V0TW9udGgoKV0sXG4gIEI6IChkKSA9PiBDT05TVEFOVFMubW9udGhzW2QuZ2V0TW9udGgoKV0sXG4gIGM6IFwiJXgsICVYXCIsXG4gIGQ6IChkLCBwKSA9PiBwYWQoZC5nZXREYXRlKCksIDIsIHAgPz8gXCIwXCIpLFxuICBlOiBcIiVfZFwiLFxuICBmOiAoZCwgcCkgPT4gcGFkKGQuZ2V0TWlsbGlzZWNvbmRzKCkgKiAxZTMsIDYsIHAgPz8gXCIwXCIpLFxuICBIOiAoZCwgcCkgPT4gcGFkKGQuZ2V0SG91cnMoKSwgMiwgcCA/PyBcIjBcIiksXG4gIEk6IChkLCBwKSA9PiB7XG4gICAgY29uc3QgaG91cnMgPSBkLmdldEhvdXJzKCkgJSAxMjtcbiAgICByZXR1cm4gaG91cnMgPT09IDAgPyBcIjEyXCIgOiBwYWQoaG91cnMsIDIsIHAgPz8gXCIwXCIpO1xuICB9LFxuICBqOiAoZCwgcCkgPT4gcGFkKGRheU9mWWVhcihkKSArIDEsIDMsIHAgPz8gXCIwXCIpLFxuICBtOiAoZCwgcCkgPT4gcGFkKGQuZ2V0TW9udGgoKSArIDEsIDIsIHAgPz8gXCIwXCIpLFxuICBNOiAoZCwgcCkgPT4gcGFkKGQuZ2V0TWludXRlcygpLCAyLCBwID8/IFwiMFwiKSxcbiAgTDogKGQsIHApID0+IHBhZChkLmdldE1pbGxpc2Vjb25kcygpLCAzLCBwID8/IFwiMFwiKSxcbiAgcDogKGQpID0+IGQuZ2V0SG91cnMoKSA8IDEyID8gXCJBTVwiIDogXCJQTVwiLFxuICBROiAoZCkgPT4gU3RyaW5nKGQuZ2V0VGltZSgpKSxcbiAgczogKGQpID0+IFN0cmluZyhNYXRoLmZsb29yKGQuZ2V0VGltZSgpIC8gMWUzKSksXG4gIFM6IChkLCBwKSA9PiBwYWQoZC5nZXRTZWNvbmRzKCksIDIsIHAgPz8gXCIwXCIpLFxuICB1OiAoZCkgPT4ge1xuICAgIGxldCBkYXkyID0gZC5nZXREYXkoKTtcbiAgICBpZiAoZGF5MiA8IDEpXG4gICAgICBkYXkyICs9IDc7XG4gICAgcmV0dXJuIFN0cmluZyhkYXkyICUgNyk7XG4gIH0sXG4gIFU6IChkLCBwKSA9PiBwYWQod2Vla09mWWVhcihkLCBTVU5EQVkpLCAyLCBwID8/IFwiMFwiKSxcbiAgVjogKGQsIHApID0+IHBhZChpc29XZWVrT2ZZZWFyKGQpLCAyLCBwID8/IFwiMFwiKSxcbiAgdzogKGQsIHApID0+IHBhZChkLmdldERheSgpLCAyLCBwID8/IFwiMFwiKSxcbiAgVzogKGQsIHApID0+IHBhZCh3ZWVrT2ZZZWFyKGQsIE1PTkRBWSksIDIsIHAgPz8gXCIwXCIpLFxuICB4OiBcIiUtbS8lLWQvJVlcIixcbiAgWDogXCIlLUk6JU06JVMgJXBcIixcbiAgeTogKGQsIHApID0+IHBhZChkLmdldEZ1bGxZZWFyKCkgJSAxMDAsIDIsIHAgPz8gXCIwXCIpLFxuICBZOiAoZCwgcCkgPT4gcGFkKGQuZ2V0RnVsbFllYXIoKSwgNCwgcCA/PyBcIjBcIiksXG4gIFo6IChkKSA9PiB0aW1lem9uZShkKSxcbiAgXCIlXCI6ICgpID0+IFwiJVwiXG59O1xudmFyIFBBRFMgPSB7XG4gIF86IFwiIFwiLFxuICBcIjBcIjogXCIwXCIsXG4gIFwiLVwiOiBcIlwiXG59O1xuZnVuY3Rpb24gcGFkKHZhbHVlLCBzaXplLCBwYWRDaGFyKSB7XG4gIGNvbnN0IG91dHB1dCA9IFN0cmluZyhNYXRoLmZsb29yKHZhbHVlKSk7XG4gIGlmIChvdXRwdXQubGVuZ3RoID49IHNpemUpIHtcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG4gIHJldHVybiBgJHtwYWRDaGFyLnJlcGVhdChzaXplIC0gb3V0cHV0Lmxlbmd0aCl9JHtvdXRwdXR9YDtcbn1cbmZ1bmN0aW9uIGJ1aWxkRm9ybWF0dGVyKGZvcm1hdFN0cmluZykge1xuICBjb25zdCBmb3JtYXRQYXJ0cyA9IFtdO1xuICB3aGlsZSAoZm9ybWF0U3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICBsZXQgbmV4dEVzY2FwZUlkeCA9IGZvcm1hdFN0cmluZy5pbmRleE9mKFwiJVwiKTtcbiAgICBpZiAobmV4dEVzY2FwZUlkeCAhPT0gMCkge1xuICAgICAgY29uc3QgbGl0ZXJhbFBhcnQgPSBuZXh0RXNjYXBlSWR4ID4gMCA/IGZvcm1hdFN0cmluZy5zdWJzdHJpbmcoMCwgbmV4dEVzY2FwZUlkeCkgOiBmb3JtYXRTdHJpbmc7XG4gICAgICBmb3JtYXRQYXJ0cy5wdXNoKGxpdGVyYWxQYXJ0KTtcbiAgICB9XG4gICAgaWYgKG5leHRFc2NhcGVJZHggPCAwKVxuICAgICAgYnJlYWs7XG4gICAgY29uc3QgbWF5YmVQYWRTcGVjaWZpZXIgPSBmb3JtYXRTdHJpbmdbbmV4dEVzY2FwZUlkeCArIDFdO1xuICAgIGNvbnN0IG1heWJlUGFkID0gUEFEU1ttYXliZVBhZFNwZWNpZmllcl07XG4gICAgaWYgKG1heWJlUGFkICE9IG51bGwpIHtcbiAgICAgIG5leHRFc2NhcGVJZHgrKztcbiAgICB9XG4gICAgY29uc3QgbWF5YmVGb3JtYXR0ZXJTcGVjaWZpZXIgPSBmb3JtYXRTdHJpbmdbbmV4dEVzY2FwZUlkeCArIDFdO1xuICAgIGNvbnN0IG1heWJlRm9ybWF0dGVyID0gRk9STUFUVEVSU1ttYXliZUZvcm1hdHRlclNwZWNpZmllcl07XG4gICAgaWYgKHR5cGVvZiBtYXliZUZvcm1hdHRlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBmb3JtYXRQYXJ0cy5wdXNoKFttYXliZUZvcm1hdHRlciwgbWF5YmVQYWRdKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtYXliZUZvcm1hdHRlciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgY29uc3QgZm9ybWF0dGVyID0gYnVpbGRGb3JtYXR0ZXIobWF5YmVGb3JtYXR0ZXIpO1xuICAgICAgZm9ybWF0UGFydHMucHVzaChbZm9ybWF0dGVyLCBtYXliZVBhZF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3JtYXRQYXJ0cy5wdXNoKGAke21heWJlUGFkID8/IFwiXCJ9JHttYXliZUZvcm1hdHRlclNwZWNpZmllcn1gKTtcbiAgICB9XG4gICAgZm9ybWF0U3RyaW5nID0gZm9ybWF0U3RyaW5nLnN1YnN0cmluZyhuZXh0RXNjYXBlSWR4ICsgMik7XG4gIH1cbiAgcmV0dXJuIChkYXRlVGltZSkgPT4ge1xuICAgIGNvbnN0IGRhdGVUaW1lQXNEYXRlID0gdHlwZW9mIGRhdGVUaW1lID09PSBcIm51bWJlclwiID8gbmV3IERhdGUoZGF0ZVRpbWUpIDogZGF0ZVRpbWU7XG4gICAgcmV0dXJuIGZvcm1hdFBhcnRzLm1hcCgoYykgPT4gdHlwZW9mIGMgPT09IFwic3RyaW5nXCIgPyBjIDogY1swXShkYXRlVGltZUFzRGF0ZSwgY1sxXSkpLmpvaW4oXCJcIik7XG4gIH07XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvdGltZUZvcm1hdERlZmF1bHRzLnRzXG5mdW5jdGlvbiBkYXRlVG9OdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRGF0ZSA/IHZhbHVlLmdldFRpbWUoKSA6IHZhbHVlO1xufVxuZnVuY3Rpb24gZGVmYXVsdFRpbWVUaWNrRm9ybWF0KHRpY2tzLCBkb21haW4sIGZvcm1hdE9mZnNldCkge1xuICBjb25zdCBmb3JtYXRTdHJpbmcgPSBjYWxjdWxhdGVEZWZhdWx0VGltZVRpY2tGb3JtYXQodGlja3MsIGRvbWFpbiwgZm9ybWF0T2Zmc2V0KTtcbiAgY29uc3QgZm9ybWF0dGVyID0gYnVpbGRGb3JtYXR0ZXIoZm9ybWF0U3RyaW5nKTtcbiAgcmV0dXJuIChkYXRlKSA9PiBmb3JtYXR0ZXIoZGF0ZSk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVEZWZhdWx0VGltZVRpY2tGb3JtYXQodGlja3MgPSBbXSwgZG9tYWluID0gdGlja3MsIGZvcm1hdE9mZnNldCA9IDApIHtcbiAgbGV0IG1pbkludGVydmFsID0gSW5maW5pdHk7XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgdGlja3MubGVuZ3RoOyBpKyspIHtcbiAgICBtaW5JbnRlcnZhbCA9IE1hdGgubWluKG1pbkludGVydmFsLCBNYXRoLmFicyh0aWNrc1tpXSAtIHRpY2tzW2kgLSAxXSkpO1xuICB9XG4gIGNvbnN0IHN0YXJ0WWVhciA9IG5ldyBEYXRlKGRvbWFpblswXSkuZ2V0RnVsbFllYXIoKTtcbiAgY29uc3Qgc3RvcFllYXIgPSBuZXcgRGF0ZShkb21haW4uYXQoLTEpKS5nZXRGdWxsWWVhcigpO1xuICBjb25zdCB5ZWFyQ2hhbmdlID0gc3RvcFllYXIgLSBzdGFydFllYXIgPiAwO1xuICBjb25zdCB0aW1lRm9ybWF0ID0gaXNGaW5pdGUobWluSW50ZXJ2YWwpID8gZ2V0SW50ZXJ2YWxMb3dlc3RHcmFudWxhcml0eUZvcm1hdChtaW5JbnRlcnZhbCwgdGlja3MpIDogZ2V0TG93ZXN0R3JhbnVsYXJpdHlGb3JtYXQodGlja3NbMF0pO1xuICByZXR1cm4gZm9ybWF0U3RyaW5nQnVpbGRlcihNYXRoLm1heCh0aW1lRm9ybWF0IC0gZm9ybWF0T2Zmc2V0LCAwKSwgeWVhckNoYW5nZSwgdGlja3MpO1xufVxuZnVuY3Rpb24gZ2V0SW50ZXJ2YWxMb3dlc3RHcmFudWxhcml0eUZvcm1hdCh2YWx1ZSwgdGlja3MpIHtcbiAgaWYgKHZhbHVlIDwgZHVyYXRpb25TZWNvbmQpIHtcbiAgICByZXR1cm4gMCAvKiBNSUxMSVNFQ09ORCAqLztcbiAgfSBlbHNlIGlmICh2YWx1ZSA8IGR1cmF0aW9uTWludXRlKSB7XG4gICAgcmV0dXJuIDEgLyogU0VDT05EICovO1xuICB9IGVsc2UgaWYgKHZhbHVlIDwgZHVyYXRpb25Ib3VyKSB7XG4gICAgcmV0dXJuIDIgLyogTUlOVVRFICovO1xuICB9IGVsc2UgaWYgKHZhbHVlIDwgZHVyYXRpb25EYXkpIHtcbiAgICByZXR1cm4gMyAvKiBIT1VSICovO1xuICB9IGVsc2UgaWYgKHZhbHVlIDwgZHVyYXRpb25XZWVrKSB7XG4gICAgcmV0dXJuIDQgLyogV0VFS19EQVkgKi87XG4gIH0gZWxzZSBpZiAodmFsdWUgPCBkdXJhdGlvbkRheSAqIDI4IHx8IHZhbHVlIDwgZHVyYXRpb25EYXkgKiAzMSAmJiBoYXNEdXBsaWNhdGVNb250aCh0aWNrcykpIHtcbiAgICByZXR1cm4gNSAvKiBTSE9SVF9NT05USCAqLztcbiAgfSBlbHNlIGlmICh2YWx1ZSA8IGR1cmF0aW9uWWVhcikge1xuICAgIHJldHVybiA2IC8qIE1PTlRIICovO1xuICB9XG4gIHJldHVybiA3IC8qIFlFQVIgKi87XG59XG5mdW5jdGlvbiBnZXRMb3dlc3RHcmFudWxhcml0eUZvcm1hdCh2YWx1ZSkge1xuICBpZiAoc2Vjb25kX2RlZmF1bHQuZmxvb3IodmFsdWUpIDwgdmFsdWUpIHtcbiAgICByZXR1cm4gMCAvKiBNSUxMSVNFQ09ORCAqLztcbiAgfSBlbHNlIGlmIChtaW51dGVfZGVmYXVsdC5mbG9vcih2YWx1ZSkgPCB2YWx1ZSkge1xuICAgIHJldHVybiAxIC8qIFNFQ09ORCAqLztcbiAgfSBlbHNlIGlmIChob3VyX2RlZmF1bHQuZmxvb3IodmFsdWUpIDwgdmFsdWUpIHtcbiAgICByZXR1cm4gMiAvKiBNSU5VVEUgKi87XG4gIH0gZWxzZSBpZiAoZGF5X2RlZmF1bHQuZmxvb3IodmFsdWUpIDwgdmFsdWUpIHtcbiAgICByZXR1cm4gMyAvKiBIT1VSICovO1xuICB9IGVsc2UgaWYgKG1vbnRoX2RlZmF1bHQuZmxvb3IodmFsdWUpIDwgdmFsdWUpIHtcbiAgICBpZiAod2Vla19kZWZhdWx0LmZsb29yKHZhbHVlKSA8IHZhbHVlKSB7XG4gICAgICByZXR1cm4gNCAvKiBXRUVLX0RBWSAqLztcbiAgICB9XG4gICAgcmV0dXJuIDUgLyogU0hPUlRfTU9OVEggKi87XG4gIH0gZWxzZSBpZiAoeWVhcl9kZWZhdWx0LmZsb29yKHZhbHVlKSA8IHZhbHVlKSB7XG4gICAgcmV0dXJuIDYgLyogTU9OVEggKi87XG4gIH1cbiAgcmV0dXJuIDcgLyogWUVBUiAqLztcbn1cbmZ1bmN0aW9uIGhhc0R1cGxpY2F0ZU1vbnRoKHRpY2tzKSB7XG4gIGxldCBwcmV2TW9udGggPSBuZXcgRGF0ZSh0aWNrc1swXSkuZ2V0TW9udGgoKTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCB0aWNrcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRpY2tNb250aCA9IG5ldyBEYXRlKHRpY2tzW2ldKS5nZXRNb250aCgpO1xuICAgIGlmIChwcmV2TW9udGggPT09IHRpY2tNb250aCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHByZXZNb250aCA9IHRpY2tNb250aDtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBmb3JtYXRTdHJpbmdCdWlsZGVyKGRlZmF1bHRUaW1lRm9ybWF0LCB5ZWFyQ2hhbmdlLCB0aWNrcykge1xuICBjb25zdCBmaXJzdFRpY2sgPSBkYXRlVG9OdW1iZXIodGlja3NbMF0pO1xuICBjb25zdCBsYXN0VGljayA9IGRhdGVUb051bWJlcih0aWNrcy5hdCgtMSkpO1xuICBjb25zdCBleHRlbnQyID0gTWF0aC5hYnMobGFzdFRpY2sgLSBmaXJzdFRpY2spO1xuICBjb25zdCBhY3RpdmVZZWFyID0geWVhckNoYW5nZSB8fCBkZWZhdWx0VGltZUZvcm1hdCA9PT0gNyAvKiBZRUFSICovO1xuICBjb25zdCBhY3RpdmVEYXRlID0gZXh0ZW50MiA9PT0gMDtcbiAgY29uc3QgcGFydHMgPSBbXG4gICAgW1wiaG91clwiLCA2ICogZHVyYXRpb25Ib3VyLCAxNCAqIGR1cmF0aW9uRGF5LCAzIC8qIEhPVVIgKi8sIFwiJUkgJXBcIl0sXG4gICAgW1wiaG91clwiLCBkdXJhdGlvbk1pbnV0ZSwgNiAqIGR1cmF0aW9uSG91ciwgMyAvKiBIT1VSICovLCBcIiVJOiVNXCJdLFxuICAgIFtcInNlY29uZFwiLCAxZTMsIDYgKiBkdXJhdGlvbkhvdXIsIDEgLyogU0VDT05EICovLCBcIjolU1wiXSxcbiAgICBbXCJtc1wiLCAwLCA2ICogZHVyYXRpb25Ib3VyLCAwIC8qIE1JTExJU0VDT05EICovLCBcIi4lTFwiXSxcbiAgICBbXCJhbS9wbVwiLCBkdXJhdGlvbk1pbnV0ZSwgNiAqIGR1cmF0aW9uSG91ciwgMyAvKiBIT1VSICovLCBcIiVwXCJdLFxuICAgIFwiIFwiLFxuICAgIFtcImRheVwiLCBkdXJhdGlvbkRheSwgZHVyYXRpb25XZWVrLCA0IC8qIFdFRUtfREFZICovLCBcIiVhXCJdLFxuICAgIFtcIm1vbnRoXCIsIGFjdGl2ZURhdGUgPyAwIDogZHVyYXRpb25XZWVrLCA1MiAqIGR1cmF0aW9uV2VlaywgNSAvKiBTSE9SVF9NT05USCAqLywgXCIlYiAlZFwiXSxcbiAgICBbXCJtb250aFwiLCA1ICogZHVyYXRpb25XZWVrLCAxMCAqIGR1cmF0aW9uWWVhciwgNiAvKiBNT05USCAqLywgXCIlQlwiXSxcbiAgICBcIiBcIixcbiAgICBbXCJ5ZWFyXCIsIGFjdGl2ZVllYXIgPyAwIDogZHVyYXRpb25ZZWFyLCBJbmZpbml0eSwgNyAvKiBZRUFSICovLCBcIiVZXCJdXG4gIF07XG4gIGNvbnN0IGZvcm1hdFBhcnRzID0gcGFydHMuZmlsdGVyKCh2KSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgW18sIG1pbiwgbWF4LCBmb3JtYXRdID0gdjtcbiAgICByZXR1cm4gZm9ybWF0ID49IGRlZmF1bHRUaW1lRm9ybWF0ICYmIG1pbiA8PSBleHRlbnQyICYmIGV4dGVudDIgPCBtYXg7XG4gIH0pLnJlZHVjZShcbiAgICAociwgbmV4dCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBuZXh0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHIucmVzdWx0LnB1c2gobmV4dCk7XG4gICAgICB9IGVsc2UgaWYgKCFyLnVzZWQuaGFzKG5leHRbMF0pKSB7XG4gICAgICAgIHIucmVzdWx0LnB1c2gobmV4dCk7XG4gICAgICAgIHIudXNlZC5hZGQobmV4dFswXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcjtcbiAgICB9LFxuICAgIHsgcmVzdWx0OiBbXSwgdXNlZDogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSB9XG4gICkucmVzdWx0O1xuICBjb25zdCBmaXJzdEZvcm1hdCA9IGZvcm1hdFBhcnRzLmZpbmRJbmRleCgodikgPT4gdHlwZW9mIHYgIT09IFwic3RyaW5nXCIpO1xuICBjb25zdCBsYXN0Rm9ybWF0ID0gZm9ybWF0UGFydHMuZmluZExhc3RJbmRleCgodikgPT4gdHlwZW9mIHYgIT09IFwic3RyaW5nXCIpO1xuICByZXR1cm4gZm9ybWF0UGFydHMuc2xpY2UoZmlyc3RGb3JtYXQsIGxhc3RGb3JtYXQgKyAxKS5tYXAoKHYpID0+IHR5cGVvZiB2ID09PSBcInN0cmluZ1wiID8gdiA6IHZbNF0pLmpvaW4oXCJcIikucmVwbGFjZUFsbCgvXFxzKy9nLCBcIiBcIikudHJpbSgpO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2FsZS9iYW5kU2NhbGUudHNcbnZhciBfQmFuZFNjYWxlID0gY2xhc3MgX0JhbmRTY2FsZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMudHlwZSA9IFwiYmFuZFwiO1xuICAgIHRoaXMuaW52YWxpZCA9IHRydWU7XG4gICAgdGhpcy5yYW5nZSA9IFswLCAxXTtcbiAgICB0aGlzLnJvdW5kID0gZmFsc2U7XG4gICAgdGhpcy5pbnRlcnZhbCA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBNYXBzIGRhdHVtIHRvIGl0cyBpbmRleCBpbiB0aGUge0BsaW5rIGRvbWFpbn0gYXJyYXkuXG4gICAgICogVXNlZCB0byBjaGVjayBmb3IgZHVwbGljYXRlIGRhdGEgKG5vdCBhbGxvd2VkKS5cbiAgICAgKi9cbiAgICB0aGlzLmluZGV4ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAvKipcbiAgICAgKiBUaGUgb3V0cHV0IHJhbmdlIHZhbHVlcyBmb3IgZGF0dW0gYXQgZWFjaCBpbmRleC5cbiAgICAgKi9cbiAgICB0aGlzLm9yZGluYWxSYW5nZSA9IFtdO1xuICAgIC8qKlxuICAgICAqIENvbnRhaW5zIHVuaXF1ZSBkYXRhIG9ubHkuXG4gICAgICovXG4gICAgdGhpcy5fZG9tYWluID0gW107XG4gICAgdGhpcy5fYmFuZHdpZHRoID0gMTtcbiAgICB0aGlzLl9zdGVwID0gMTtcbiAgICB0aGlzLl9pbnNldCA9IDE7XG4gICAgdGhpcy5fcmF3QmFuZHdpZHRoID0gMTtcbiAgICAvKipcbiAgICAgKiBUaGUgcmF0aW8gb2YgdGhlIHJhbmdlIHRoYXQgaXMgcmVzZXJ2ZWQgZm9yIHNwYWNlIGJldHdlZW4gYmFuZHMuXG4gICAgICovXG4gICAgdGhpcy5fcGFkZGluZ0lubmVyID0gMDtcbiAgICAvKipcbiAgICAgKiBUaGUgcmF0aW8gb2YgdGhlIHJhbmdlIHRoYXQgaXMgcmVzZXJ2ZWQgZm9yIHNwYWNlIGJlZm9yZSB0aGUgZmlyc3RcbiAgICAgKiBhbmQgYWZ0ZXIgdGhlIGxhc3QgYmFuZC5cbiAgICAgKi9cbiAgICB0aGlzLl9wYWRkaW5nT3V0ZXIgPSAwO1xuICB9XG4gIHN0YXRpYyBpcyh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIF9CYW5kU2NhbGU7XG4gIH1cbiAgcmVmcmVzaCgpIHtcbiAgICBpZiAoIXRoaXMuaW52YWxpZClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmludmFsaWQgPSBmYWxzZTtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIGlmICh0aGlzLmludmFsaWQpIHtcbiAgICAgIExvZ2dlci53YXJuT25jZShcIkV4cGVjdGVkIHVwZGF0ZSB0byBub3QgaW52YWxpZGF0ZSBzY2FsZVwiKTtcbiAgICB9XG4gIH1cbiAgc2V0IGRvbWFpbih2YWx1ZXMpIHtcbiAgICB0aGlzLmluZGV4ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLmludmFsaWQgPSB0cnVlO1xuICAgIHRoaXMuX2RvbWFpbiA9IFtdO1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBjb25zdCBrZXkgPSBkYXRlVG9OdW1iZXIodmFsdWUpO1xuICAgICAgaWYgKHRoaXMuZ2V0SW5kZXgoa2V5KSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRoaXMuaW5kZXguc2V0KGtleSwgdGhpcy5fZG9tYWluLnB1c2godmFsdWUpIC0gMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldCBkb21haW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RvbWFpbjtcbiAgfVxuICBnZXREb21haW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RvbWFpbjtcbiAgfVxuICB0aWNrcygpIHtcbiAgICB0aGlzLnJlZnJlc2goKTtcbiAgICByZXR1cm4gdGhpcy5fZG9tYWluO1xuICB9XG4gIGNvbnZlcnQoZCkge1xuICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIGNvbnN0IGkgPSB0aGlzLmdldEluZGV4KGQpO1xuICAgIGlmIChpID09IG51bGwpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm9yZGluYWxSYW5nZVtpXSA/PyBOYU47XG4gIH1cbiAgaW52ZXJ0KHBvc2l0aW9uKSB7XG4gICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLm9yZGluYWxSYW5nZS5maW5kSW5kZXgoKHApID0+IHAgPT09IHBvc2l0aW9uKTtcbiAgICByZXR1cm4gdGhpcy5kb21haW5baW5kZXhdO1xuICB9XG4gIGludmVydE5lYXJlc3QocG9zaXRpb24pIHtcbiAgICB0aGlzLnJlZnJlc2goKTtcbiAgICBsZXQgbmVhcmVzdCA9IC0xO1xuICAgIGxldCBtaW5EaXN0YW5jZSA9IEluZmluaXR5O1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5vcmRpbmFsUmFuZ2UuZmluZEluZGV4KChwLCBpKSA9PiB7XG4gICAgICBpZiAocCA9PT0gcG9zaXRpb24pXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY29uc3QgZGlzdGFuY2UzID0gTWF0aC5hYnMocG9zaXRpb24gLSBwKTtcbiAgICAgIGlmIChkaXN0YW5jZTMgPCBtaW5EaXN0YW5jZSkge1xuICAgICAgICBtaW5EaXN0YW5jZSA9IGRpc3RhbmNlMztcbiAgICAgICAgbmVhcmVzdCA9IGk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuZG9tYWluW2luZGV4XSA/PyB0aGlzLmRvbWFpbltuZWFyZXN0XTtcbiAgfVxuICBnZXQgYmFuZHdpZHRoKCkge1xuICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIHJldHVybiB0aGlzLl9iYW5kd2lkdGg7XG4gIH1cbiAgZ2V0IHN0ZXAoKSB7XG4gICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgcmV0dXJuIHRoaXMuX3N0ZXA7XG4gIH1cbiAgZ2V0IGluc2V0KCkge1xuICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIHJldHVybiB0aGlzLl9pbnNldDtcbiAgfVxuICBnZXQgcmF3QmFuZHdpZHRoKCkge1xuICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIHJldHVybiB0aGlzLl9yYXdCYW5kd2lkdGg7XG4gIH1cbiAgc2V0IHBhZGRpbmcodmFsdWUpIHtcbiAgICB2YWx1ZSA9IGNsYW1wKDAsIHZhbHVlLCAxKTtcbiAgICB0aGlzLl9wYWRkaW5nSW5uZXIgPSB2YWx1ZTtcbiAgICB0aGlzLl9wYWRkaW5nT3V0ZXIgPSB2YWx1ZTtcbiAgfVxuICBnZXQgcGFkZGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFkZGluZ0lubmVyO1xuICB9XG4gIHNldCBwYWRkaW5nSW5uZXIodmFsdWUpIHtcbiAgICB0aGlzLl9wYWRkaW5nSW5uZXIgPSBjbGFtcCgwLCB2YWx1ZSwgMSk7XG4gIH1cbiAgZ2V0IHBhZGRpbmdJbm5lcigpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFkZGluZ0lubmVyO1xuICB9XG4gIHNldCBwYWRkaW5nT3V0ZXIodmFsdWUpIHtcbiAgICB0aGlzLl9wYWRkaW5nT3V0ZXIgPSBjbGFtcCgwLCB2YWx1ZSwgMSk7XG4gIH1cbiAgZ2V0IHBhZGRpbmdPdXRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFkZGluZ091dGVyO1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICBjb25zdCBjb3VudCA9IHRoaXMuX2RvbWFpbi5sZW5ndGg7XG4gICAgaWYgKGNvdW50ID09PSAwKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IFtyMCwgcjFdID0gdGhpcy5yYW5nZTtcbiAgICBsZXQgeyBfcGFkZGluZ0lubmVyOiBwYWRkaW5nSW5uZXIgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBfcGFkZGluZ091dGVyOiBwYWRkaW5nT3V0ZXIsIHJvdW5kOiByb3VuZDUgfSA9IHRoaXM7XG4gICAgY29uc3QgcmFuZ2VEaXN0YW5jZSA9IHIxIC0gcjA7XG4gICAgbGV0IHJhd1N0ZXA7XG4gICAgaWYgKGNvdW50ID09PSAxKSB7XG4gICAgICBwYWRkaW5nSW5uZXIgPSAwO1xuICAgICAgcmF3U3RlcCA9IHJhbmdlRGlzdGFuY2UgKiAoMSAtIHBhZGRpbmdPdXRlciAqIDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByYXdTdGVwID0gcmFuZ2VEaXN0YW5jZSAvIE1hdGgubWF4KDEsIGNvdW50IC0gcGFkZGluZ0lubmVyICsgcGFkZGluZ091dGVyICogMik7XG4gICAgfVxuICAgIGNvbnN0IHN0ZXAgPSByb3VuZDUgPyBNYXRoLmZsb29yKHJhd1N0ZXApIDogcmF3U3RlcDtcbiAgICBsZXQgaW5zZXQgPSByMCArIChyYW5nZURpc3RhbmNlIC0gc3RlcCAqIChjb3VudCAtIHBhZGRpbmdJbm5lcikpIC8gMjtcbiAgICBsZXQgYmFuZHdpZHRoID0gc3RlcCAqICgxIC0gcGFkZGluZ0lubmVyKTtcbiAgICBpZiAocm91bmQ1KSB7XG4gICAgICBpbnNldCA9IE1hdGgucm91bmQoaW5zZXQpO1xuICAgICAgYmFuZHdpZHRoID0gTWF0aC5yb3VuZChiYW5kd2lkdGgpO1xuICAgIH1cbiAgICB0aGlzLl9zdGVwID0gc3RlcDtcbiAgICB0aGlzLl9pbnNldCA9IGluc2V0O1xuICAgIHRoaXMuX2JhbmR3aWR0aCA9IGJhbmR3aWR0aDtcbiAgICB0aGlzLl9yYXdCYW5kd2lkdGggPSByYXdTdGVwICogKDEgLSBwYWRkaW5nSW5uZXIpO1xuICAgIHRoaXMub3JkaW5hbFJhbmdlID0gdGhpcy5fZG9tYWluLm1hcCgoXywgaSkgPT4gaW5zZXQgKyBzdGVwICogaSk7XG4gIH1cbiAgZ2V0SW5kZXgodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5pbmRleC5nZXQodmFsdWUgaW5zdGFuY2VvZiBEYXRlID8gdmFsdWUuZ2V0VGltZSgpIDogdmFsdWUpO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgSW52YWxpZGF0aW5nXG5dLCBfQmFuZFNjYWxlLnByb3RvdHlwZSwgXCJyYW5nZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEludmFsaWRhdGluZ1xuXSwgX0JhbmRTY2FsZS5wcm90b3R5cGUsIFwicm91bmRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBJbnZhbGlkYXRpbmdcbl0sIF9CYW5kU2NhbGUucHJvdG90eXBlLCBcImludGVydmFsXCIsIDIpO1xudmFyIEJhbmRTY2FsZSA9IF9CYW5kU2NhbGU7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvcHJvcGVydGllcy50c1xudmFyIEJhc2VQcm9wZXJ0aWVzID0gY2xhc3Mge1xuICBzZXQocHJvcGVydGllcykge1xuICAgIGNvbnN0IHsgY2xhc3NOYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lIH0gPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgIGlmICh0eXBlb2YgcHJvcGVydGllcyAhPT0gXCJvYmplY3RcIikge1xuICAgICAgTG9nZ2VyLndhcm4oYHVuYWJsZSB0byBzZXQgJHtjbGFzc05hbWV9IC0gZXhwZWN0aW5nIGEgcHJvcGVydGllcyBvYmplY3RgKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjb25zdCBrZXlzID0gbmV3IFNldChPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSk7XG4gICAgZm9yIChjb25zdCBwcm9wZXJ0eUtleSBvZiBsaXN0RGVjb3JhdGVkUHJvcGVydGllcyh0aGlzKSkge1xuICAgICAgaWYgKGtleXMuaGFzKHByb3BlcnR5S2V5KSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHByb3BlcnRpZXNbcHJvcGVydHlLZXldO1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKGlzUHJvcGVydGllcyhzZWxmW3Byb3BlcnR5S2V5XSkpIHtcbiAgICAgICAgICBpZiAoc2VsZltwcm9wZXJ0eUtleV0gaW5zdGFuY2VvZiBQcm9wZXJ0aWVzQXJyYXkpIHtcbiAgICAgICAgICAgIGNvbnN0IGFycmF5MiA9IHNlbGZbcHJvcGVydHlLZXldLnJlc2V0KHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChhcnJheTIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBzZWxmW3Byb3BlcnR5S2V5XSA9IGFycmF5MjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIExvZ2dlci53YXJuKGB1bmFibGUgdG8gc2V0IFske3Byb3BlcnR5S2V5fV0gLSBleHBlY3RpbmcgYSBwcm9wZXJ0aWVzIGFycmF5YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGZbcHJvcGVydHlLZXldLnNldCh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGZbcHJvcGVydHlLZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAga2V5cy5kZWxldGUocHJvcGVydHlLZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IHVua25vd25LZXkgb2Yga2V5cykge1xuICAgICAgTG9nZ2VyLndhcm4oYHVuYWJsZSB0byBzZXQgWyR7dW5rbm93bktleX1dIGluICR7Y2xhc3NOYW1lfSAtIHByb3BlcnR5IGlzIHVua25vd25gKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaXNWYWxpZCh3YXJuaW5nUHJlZml4KSB7XG4gICAgcmV0dXJuIGxpc3REZWNvcmF0ZWRQcm9wZXJ0aWVzKHRoaXMpLmV2ZXJ5KChwcm9wZXJ0eUtleSkgPT4ge1xuICAgICAgY29uc3QgeyBvcHRpb25hbCB9ID0gZXh0cmFjdERlY29yYXRlZFByb3BlcnR5TWV0YWRhdGEodGhpcywgcHJvcGVydHlLZXkpO1xuICAgICAgY29uc3QgdmFsaWQgPSBvcHRpb25hbCA9PT0gdHJ1ZSB8fCB0eXBlb2YgdGhpc1twcm9wZXJ0eUtleV0gIT09IFwidW5kZWZpbmVkXCI7XG4gICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgIExvZ2dlci53YXJuT25jZShgJHt3YXJuaW5nUHJlZml4ID8/IFwiXCJ9WyR7cHJvcGVydHlLZXl9XSBpcyByZXF1aXJlZC5gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWxpZDtcbiAgICB9KTtcbiAgfVxuICB0b0pzb24oKSB7XG4gICAgcmV0dXJuIGxpc3REZWNvcmF0ZWRQcm9wZXJ0aWVzKHRoaXMpLnJlZHVjZSgob2JqZWN0MiwgcHJvcGVydHlLZXkpID0+IHtcbiAgICAgIGNvbnN0IHByb3BlcnR5VmFsdWUgPSB0aGlzW3Byb3BlcnR5S2V5XTtcbiAgICAgIG9iamVjdDJbcHJvcGVydHlLZXldID0gaXNQcm9wZXJ0aWVzKHByb3BlcnR5VmFsdWUpID8gcHJvcGVydHlWYWx1ZS50b0pzb24oKSA6IHByb3BlcnR5VmFsdWU7XG4gICAgICByZXR1cm4gb2JqZWN0MjtcbiAgICB9LCB7fSk7XG4gIH1cbn07XG52YXIgUHJvcGVydGllc0FycmF5ID0gY2xhc3MgX1Byb3BlcnRpZXNBcnJheSBleHRlbmRzIEFycmF5IHtcbiAgY29uc3RydWN0b3IoaXRlbUZhY3RvcnksIC4uLnByb3BlcnRpZXMpIHtcbiAgICBzdXBlcihwcm9wZXJ0aWVzLmxlbmd0aCk7XG4gICAgY29uc3QgaXNDb25zdHJ1Y3RvciA9ICh2YWx1ZTIpID0+IEJvb2xlYW4odmFsdWUyPy5wcm90b3R5cGU/LmNvbnN0cnVjdG9yPy5uYW1lKTtcbiAgICBjb25zdCB2YWx1ZSA9IGlzQ29uc3RydWN0b3IoaXRlbUZhY3RvcnkpID8gKHBhcmFtcykgPT4gbmV3IGl0ZW1GYWN0b3J5KCkuc2V0KHBhcmFtcykgOiBpdGVtRmFjdG9yeTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpdGVtRmFjdG9yeVwiLCB7IHZhbHVlLCBlbnVtZXJhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiBmYWxzZSB9KTtcbiAgICB0aGlzLnNldChwcm9wZXJ0aWVzKTtcbiAgfVxuICBzZXQocHJvcGVydGllcykge1xuICAgIGlmIChpc0FycmF5KHByb3BlcnRpZXMpKSB7XG4gICAgICB0aGlzLmxlbmd0aCA9IHByb3BlcnRpZXMubGVuZ3RoO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXNbaV0gPSB0aGlzLml0ZW1GYWN0b3J5KHByb3BlcnRpZXNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZXNldChwcm9wZXJ0aWVzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcGVydGllcykpIHtcbiAgICAgIHJldHVybiBuZXcgX1Byb3BlcnRpZXNBcnJheSh0aGlzLml0ZW1GYWN0b3J5LCAuLi5wcm9wZXJ0aWVzKTtcbiAgICB9XG4gIH1cbiAgdG9Kc29uKCkge1xuICAgIHJldHVybiB0aGlzLm1hcCgodmFsdWUpID0+IHZhbHVlPy50b0pzb24/LigpID8/IHZhbHVlKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGlzUHJvcGVydGllcyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBCYXNlUHJvcGVydGllcyB8fCB2YWx1ZSBpbnN0YW5jZW9mIFByb3BlcnRpZXNBcnJheTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC92YWxpZGF0aW9uLnRzXG5mdW5jdGlvbiBWYWxpZGF0ZShwcmVkaWNhdGUsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IG9wdGlvbmFsID0gZmFsc2UsIHByb3BlcnR5OiBvdmVycmlkZVByb3BlcnR5IH0gPSBvcHRpb25zO1xuICByZXR1cm4gYWRkVHJhbnNmb3JtVG9JbnN0YW5jZVByb3BlcnR5KFxuICAgICh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkgPT4ge1xuICAgICAgY29uc3QgY29udGV4dCA9IHsgLi4ub3B0aW9ucywgdGFyZ2V0LCBwcm9wZXJ0eSB9O1xuICAgICAgaWYgKG9wdGlvbmFsICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIiB8fCBwcmVkaWNhdGUodmFsdWUsIGNvbnRleHQpKSB7XG4gICAgICAgIGlmIChpc1Byb3BlcnRpZXModGFyZ2V0W3Byb3BlcnR5XSkgJiYgIWlzUHJvcGVydGllcyh2YWx1ZSkpIHtcbiAgICAgICAgICB0YXJnZXRbcHJvcGVydHldLnNldCh2YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIHRhcmdldFtwcm9wZXJ0eV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgY29uc3QgY2xlYW5LZXkgPSBvdmVycmlkZVByb3BlcnR5ID8/IFN0cmluZyhwcm9wZXJ0eSkucmVwbGFjZSgvXl8qLywgXCJcIik7XG4gICAgICBjb25zdCB0YXJnZXROYW1lID0gdGFyZ2V0LmNvbnN0cnVjdG9yLmNsYXNzTmFtZSA/PyB0YXJnZXQuY29uc3RydWN0b3IubmFtZS5yZXBsYWNlKC9Qcm9wZXJ0aWVzJC8sIFwiXCIpO1xuICAgICAgbGV0IHZhbHVlU3RyaW5nID0gc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgIGNvbnN0IG1heExlbmd0aCA9IDUwO1xuICAgICAgaWYgKHZhbHVlU3RyaW5nICE9IG51bGwgJiYgdmFsdWVTdHJpbmcubGVuZ3RoID4gbWF4TGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGV4Y2Vzc0NoYXJhY3RlcnMgPSB2YWx1ZVN0cmluZy5sZW5ndGggLSBtYXhMZW5ndGg7XG4gICAgICAgIHZhbHVlU3RyaW5nID0gdmFsdWVTdHJpbmcuc2xpY2UoMCwgbWF4TGVuZ3RoKSArIGAuLi4gKCske2V4Y2Vzc0NoYXJhY3RlcnN9IGNoYXJhY3RlcnMpYDtcbiAgICAgIH1cbiAgICAgIExvZ2dlci53YXJuKFxuICAgICAgICBgUHJvcGVydHkgWyR7Y2xlYW5LZXl9XSBvZiBbJHt0YXJnZXROYW1lfV0gY2Fubm90IGJlIHNldCB0byBbJHt2YWx1ZVN0cmluZ31dJHtwcmVkaWNhdGUubWVzc2FnZSA/IGA7IGV4cGVjdGluZyAke2dldFByZWRpY2F0ZU1lc3NhZ2UocHJlZGljYXRlLCBjb250ZXh0KX1gIDogXCJcIn0sIGlnbm9yaW5nLmBcbiAgICAgICk7XG4gICAgICByZXR1cm4gQlJFQUtfVFJBTlNGT1JNX0NIQUlOO1xuICAgIH0sXG4gICAgdm9pZCAwLFxuICAgIHsgb3B0aW9uYWwgfVxuICApO1xufVxudmFyIEFORCA9ICguLi5wcmVkaWNhdGVzKSA9PiB7XG4gIGNvbnN0IG1lc3NhZ2VzID0gW107XG4gIHJldHVybiBwcmVkaWNhdGVXaXRoTWVzc2FnZShcbiAgICAodmFsdWUsIGN0eCkgPT4ge1xuICAgICAgbWVzc2FnZXMubGVuZ3RoID0gMDtcbiAgICAgIHJldHVybiBwcmVkaWNhdGVzLmV2ZXJ5KChwcmVkaWNhdGUpID0+IHtcbiAgICAgICAgY29uc3QgaXNWYWxpZDIgPSBwcmVkaWNhdGUodmFsdWUsIGN0eCk7XG4gICAgICAgIGlmICghaXNWYWxpZDIpIHtcbiAgICAgICAgICBtZXNzYWdlcy5wdXNoKGdldFByZWRpY2F0ZU1lc3NhZ2UocHJlZGljYXRlLCBjdHgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNWYWxpZDI7XG4gICAgICB9KTtcbiAgICB9LFxuICAgICgpID0+IG1lc3NhZ2VzLmZpbHRlcihCb29sZWFuKS5qb2luKFwiIEFORCBcIilcbiAgKTtcbn07XG52YXIgT1IgPSAoLi4ucHJlZGljYXRlcykgPT4gcHJlZGljYXRlV2l0aE1lc3NhZ2UoXG4gICh2YWx1ZSwgY3R4KSA9PiBwcmVkaWNhdGVzLnNvbWUoKHByZWRpY2F0ZSkgPT4gcHJlZGljYXRlKHZhbHVlLCBjdHgpKSxcbiAgKGN0eCkgPT4gcHJlZGljYXRlcy5tYXAoZ2V0UHJlZGljYXRlTWVzc2FnZU1hcHBlcihjdHgpKS5maWx0ZXIoQm9vbGVhbikuam9pbihcIiBPUiBcIilcbik7XG52YXIgT0JKRUNUID0gYXR0YWNoT2JqZWN0UmVzdHJpY3Rpb25zKFxuICBwcmVkaWNhdGVXaXRoTWVzc2FnZShcbiAgICAodmFsdWUsIGN0eCkgPT4gaXNQcm9wZXJ0aWVzKHZhbHVlKSB8fCBpc09iamVjdCh2YWx1ZSkgJiYgaXNQcm9wZXJ0aWVzKGN0eC50YXJnZXRbY3R4LnByb3BlcnR5XSksXG4gICAgXCJhIHByb3BlcnRpZXMgb2JqZWN0XCJcbiAgKVxuKTtcbnZhciBQTEFJTl9PQkpFQ1QgPSBhdHRhY2hPYmplY3RSZXN0cmljdGlvbnMocHJlZGljYXRlV2l0aE1lc3NhZ2UoKHZhbHVlKSA9PiBpc09iamVjdCh2YWx1ZSksIFwiYW4gb2JqZWN0XCIpKTtcbnZhciBCT09MRUFOID0gcHJlZGljYXRlV2l0aE1lc3NhZ2UoaXNCb29sZWFuLCBcImEgYm9vbGVhblwiKTtcbnZhciBGVU5DVElPTiA9IHByZWRpY2F0ZVdpdGhNZXNzYWdlKGlzRnVuY3Rpb24sIFwiYSBmdW5jdGlvblwiKTtcbnZhciBTVFJJTkcgPSBwcmVkaWNhdGVXaXRoTWVzc2FnZShpc1N0cmluZywgXCJhIHN0cmluZ1wiKTtcbnZhciBOVU1CRVIgPSBhdHRhY2hOdW1iZXJSZXN0cmljdGlvbnMocHJlZGljYXRlV2l0aE1lc3NhZ2UoaXNGaW5pdGVOdW1iZXIsIFwiYSBudW1iZXJcIikpO1xudmFyIFJFQUxfTlVNQkVSID0gcHJlZGljYXRlV2l0aE1lc3NhZ2UoKHZhbHVlKSA9PiBpc051bWJlcih2YWx1ZSkgJiYgIWlzTmFOKHZhbHVlKSwgXCJhIHJlYWwgbnVtYmVyXCIpO1xudmFyIE5BTiA9IHByZWRpY2F0ZVdpdGhNZXNzYWdlKCh2YWx1ZSkgPT4gaXNOdW1iZXIodmFsdWUpICYmIGlzTmFOKHZhbHVlKSwgXCJOYU5cIik7XG52YXIgUE9TSVRJVkVfTlVNQkVSID0gTlVNQkVSLnJlc3RyaWN0KHsgbWluOiAwIH0pO1xudmFyIFJBVElPID0gTlVNQkVSLnJlc3RyaWN0KHsgbWluOiAwLCBtYXg6IDEgfSk7XG52YXIgREVHUkVFID0gTlVNQkVSLnJlc3RyaWN0KHsgbWluOiAtMzYwLCBtYXg6IDM2MCB9KTtcbnZhciBOVU1CRVJfT1JfTkFOID0gT1IoTlVNQkVSLCBOQU4pO1xudmFyIEFSUkFZID0gYXR0YWNoQXJyYXlSZXN0cmljdGlvbnMocHJlZGljYXRlV2l0aE1lc3NhZ2UoaXNBcnJheSwgXCJhbiBhcnJheVwiKSk7XG52YXIgQVJSQVlfT0YgPSAocHJlZGljYXRlLCBtZXNzYWdlKSA9PiBwcmVkaWNhdGVXaXRoTWVzc2FnZShcbiAgKHZhbHVlLCBjdHgpID0+IGlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmV2ZXJ5KChpdGVtKSA9PiBwcmVkaWNhdGUoaXRlbSwgY3R4KSksXG4gIChjdHgpID0+IHtcbiAgICBjb25zdCBhcnJheU1lc3NhZ2UgPSBnZXRQcmVkaWNhdGVNZXNzYWdlKEFSUkFZLCBjdHgpID8/IFwiXCI7XG4gICAgcmV0dXJuIG1lc3NhZ2UgPyBgJHthcnJheU1lc3NhZ2V9IG9mICR7bWVzc2FnZX1gIDogYXJyYXlNZXNzYWdlO1xuICB9XG4pO1xudmFyIGlzQ29tcGFyYWJsZSA9ICh2YWx1ZSkgPT4gaXNGaW5pdGVOdW1iZXIodmFsdWUpIHx8IGlzVmFsaWREYXRlKHZhbHVlKTtcbnZhciBMRVNTX1RIQU4gPSAob3RoZXJGaWVsZCkgPT4gcHJlZGljYXRlV2l0aE1lc3NhZ2UoXG4gICh2LCBjdHgpID0+ICFpc0NvbXBhcmFibGUodikgfHwgIWlzQ29tcGFyYWJsZShjdHgudGFyZ2V0W290aGVyRmllbGRdKSB8fCB2IDwgY3R4LnRhcmdldFtvdGhlckZpZWxkXSxcbiAgYHRvIGJlIGxlc3MgdGhhbiAke290aGVyRmllbGR9YFxuKTtcbnZhciBHUkVBVEVSX1RIQU4gPSAob3RoZXJGaWVsZCkgPT4gcHJlZGljYXRlV2l0aE1lc3NhZ2UoXG4gICh2LCBjdHgpID0+ICFpc0NvbXBhcmFibGUodikgfHwgIWlzQ29tcGFyYWJsZShjdHgudGFyZ2V0W290aGVyRmllbGRdKSB8fCB2ID4gY3R4LnRhcmdldFtvdGhlckZpZWxkXSxcbiAgYHRvIGJlIGdyZWF0ZXIgdGhhbiAke290aGVyRmllbGR9YFxuKTtcbnZhciBEQVRFID0gcHJlZGljYXRlV2l0aE1lc3NhZ2UoaXNWYWxpZERhdGUsIFwiRGF0ZSBvYmplY3RcIik7XG52YXIgREFURV9PUl9EQVRFVElNRV9NUyA9IE9SKERBVEUsIFBPU0lUSVZFX05VTUJFUik7XG52YXIgY29sb3JNZXNzYWdlID0gYEEgY29sb3Igc3RyaW5nIGNhbiBiZSBpbiBvbmUgb2YgdGhlIGZvbGxvd2luZyBmb3JtYXRzIHRvIGJlIHZhbGlkOiAjcmdiLCAjcnJnZ2JiLCByZ2IociwgZywgYiksIHJnYmEociwgZywgYiwgYSkgb3IgYSBDU1MgY29sb3IgbmFtZSBzdWNoIGFzICd3aGl0ZScsICdvcmFuZ2UnLCAnY3lhbicsIGV0Y2A7XG52YXIgQ09MT1JfU1RSSU5HID0gcHJlZGljYXRlV2l0aE1lc3NhZ2UoXG4gICh2KSA9PiBpc1N0cmluZyh2KSAmJiBDb2xvci52YWxpZENvbG9yU3RyaW5nKHYpLFxuICBgY29sb3IgU3RyaW5nLiAke2NvbG9yTWVzc2FnZX1gXG4pO1xudmFyIENPTE9SX1NUUklOR19BUlJBWSA9IHByZWRpY2F0ZVdpdGhNZXNzYWdlKEFSUkFZX09GKENPTE9SX1NUUklORyksIGBjb2xvciBzdHJpbmdzLiAke2NvbG9yTWVzc2FnZX1gKTtcbnZhciBCT09MRUFOX0FSUkFZID0gQVJSQVlfT0YoQk9PTEVBTiwgXCJib29sZWFuIHZhbHVlc1wiKTtcbnZhciBOVU1CRVJfQVJSQVkgPSBBUlJBWV9PRihOVU1CRVIsIFwibnVtYmVyc1wiKTtcbnZhciBTVFJJTkdfQVJSQVkgPSBBUlJBWV9PRihTVFJJTkcsIFwic3RyaW5nc1wiKTtcbnZhciBEQVRFX0FSUkFZID0gcHJlZGljYXRlV2l0aE1lc3NhZ2UoQVJSQVlfT0YoREFURSksIFwiRGF0ZSBvYmplY3RzXCIpO1xudmFyIE9CSkVDVF9BUlJBWSA9IHByZWRpY2F0ZVdpdGhNZXNzYWdlKEFSUkFZX09GKE9CSkVDVCksIFwib2JqZWN0c1wiKTtcbnZhciBMSU5FX0NBUCA9IFVOSU9OKFtcImJ1dHRcIiwgXCJyb3VuZFwiLCBcInNxdWFyZVwiXSwgXCJhIGxpbmUgY2FwXCIpO1xudmFyIExJTkVfSk9JTiA9IFVOSU9OKFtcInJvdW5kXCIsIFwiYmV2ZWxcIiwgXCJtaXRlclwiXSwgXCJhIGxpbmUgam9pblwiKTtcbnZhciBMSU5FX1NUWUxFID0gVU5JT04oW1wic29saWRcIiwgXCJkYXNoZWRcIiwgXCJkb3R0ZWRcIl0sIFwiYSBsaW5lIHN0eWxlXCIpO1xudmFyIExJTkVfREFTSCA9IHByZWRpY2F0ZVdpdGhNZXNzYWdlKFxuICBBUlJBWV9PRihQT1NJVElWRV9OVU1CRVIpLFxuICBcIm51bWJlcnMgc3BlY2lmeWluZyB0aGUgbGVuZ3RoIGluIHBpeGVscyBvZiBhbHRlcm5hdGluZyBkYXNoZXMgYW5kIGdhcHMsIGZvciBleGFtcGxlLCBbNiwgM10gbWVhbnMgZGFzaGVzIHdpdGggYSBsZW5ndGggb2YgNiBwaXhlbHMgd2l0aCBnYXBzIGJldHdlZW4gb2YgMyBwaXhlbHMuXCJcbik7XG52YXIgUE9TSVRJT04gPSBVTklPTihbXCJ0b3BcIiwgXCJyaWdodFwiLCBcImJvdHRvbVwiLCBcImxlZnRcIl0sIFwiYSBwb3NpdGlvblwiKTtcbnZhciBGT05UX1NUWUxFID0gVU5JT04oW1wibm9ybWFsXCIsIFwiaXRhbGljXCIsIFwib2JsaXF1ZVwiXSwgXCJhIGZvbnQgc3R5bGVcIik7XG52YXIgRk9OVF9XRUlHSFQgPSBPUihcbiAgVU5JT04oW1wibm9ybWFsXCIsIFwiYm9sZFwiLCBcImJvbGRlclwiLCBcImxpZ2h0ZXJcIl0sIFwiYSBmb250IHdlaWdodFwiKSxcbiAgTlVNQkVSLnJlc3RyaWN0KHsgbWluOiAxLCBtYXg6IDFlMyB9KVxuKTtcbnZhciBURVhUX1dSQVAgPSBVTklPTihbXCJuZXZlclwiLCBcImFsd2F5c1wiLCBcImh5cGhlbmF0ZVwiLCBcIm9uLXNwYWNlXCJdLCBcImEgdGV4dCB3cmFwIHN0cmF0ZWd5XCIpO1xudmFyIFRFWFRfQUxJR04gPSBVTklPTihbXCJsZWZ0XCIsIFwiY2VudGVyXCIsIFwicmlnaHRcIl0sIFwiYSB0ZXh0IGFsaWduXCIpO1xudmFyIFZFUlRJQ0FMX0FMSUdOID0gVU5JT04oW1widG9wXCIsIFwibWlkZGxlXCIsIFwiYm90dG9tXCJdLCBcImEgdmVydGljYWwgYWxpZ25cIik7XG52YXIgT1ZFUkZMT1dfU1RSQVRFR1kgPSBVTklPTihbXCJlbGxpcHNpc1wiLCBcImhpZGVcIl0sIFwiYW4gb3ZlcmZsb3cgc3RyYXRlZ3lcIik7XG52YXIgRElSRUNUSU9OID0gVU5JT04oW1wiaG9yaXpvbnRhbFwiLCBcInZlcnRpY2FsXCJdLCBcImEgZGlyZWN0aW9uXCIpO1xudmFyIFBMQUNFTUVOVCA9IFVOSU9OKFtcImluc2lkZVwiLCBcIm91dHNpZGVcIl0sIFwiYSBwbGFjZW1lbnRcIik7XG52YXIgSU5URVJBQ1RJT05fUkFOR0UgPSBPUihVTklPTihbXCJleGFjdFwiLCBcIm5lYXJlc3RcIl0sIFwiaW50ZXJhY3Rpb24gcmFuZ2VcIiksIE5VTUJFUik7XG52YXIgTEFCRUxfUExBQ0VNRU5UID0gVU5JT04oW1widG9wXCIsIFwiYm90dG9tXCIsIFwibGVmdFwiLCBcInJpZ2h0XCJdKTtcbmZ1bmN0aW9uIFVOSU9OKG9wdGlvbnMsIG1lc3NhZ2UgPSBcImFcIikge1xuICByZXR1cm4gcHJlZGljYXRlV2l0aE1lc3NhZ2UoXG4gICAgKHYsIGN0eCkgPT4ge1xuICAgICAgY29uc3Qgb3B0aW9uID0gb3B0aW9ucy5maW5kKChvKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdHlwZW9mIG8gPT09IFwic3RyaW5nXCIgPyBvIDogby52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHYgPT09IHZhbHVlO1xuICAgICAgfSk7XG4gICAgICBpZiAob3B0aW9uID09IG51bGwpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uICE9PSBcInN0cmluZ1wiICYmIChvcHRpb24uZGVwcmVjYXRlZCA9PT0gdHJ1ZSB8fCBvcHRpb24uZGVwcmVjYXRlZFRvICE9IG51bGwpKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VzID0gW2BQcm9wZXJ0eSBbJXNdIHdpdGggdmFsdWUgJyR7b3B0aW9uLnZhbHVlfScgaXMgZGVwcmVjYXRlZC5gXTtcbiAgICAgICAgaWYgKG9wdGlvbi5kZXByZWNhdGVkVG8pIHtcbiAgICAgICAgICBtZXNzYWdlcy5wdXNoKGBVc2UgJHtvcHRpb24uZGVwcmVjYXRlZFRvfSBpbnN0ZWFkLmApO1xuICAgICAgICB9XG4gICAgICAgIExvZ2dlci53YXJuT25jZShtZXNzYWdlcy5qb2luKFwiIFwiKSwgY3R4LnByb3BlcnR5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgYCR7bWVzc2FnZX0ga2V5d29yZCBzdWNoIGFzICR7am9pblVuaW9uT3B0aW9ucyhvcHRpb25zKX1gXG4gICk7XG59XG52YXIgTUlOX1NQQUNJTkcgPSBPUihBTkQoTlVNQkVSLnJlc3RyaWN0KHsgbWluOiAxIH0pLCBMRVNTX1RIQU4oXCJtYXhTcGFjaW5nXCIpKSwgTkFOKTtcbnZhciBNQVhfU1BBQ0lORyA9IE9SKEFORChOVU1CRVIucmVzdHJpY3QoeyBtaW46IDEgfSksIEdSRUFURVJfVEhBTihcIm1pblNwYWNpbmdcIikpLCBOQU4pO1xuZnVuY3Rpb24gcHJlZGljYXRlV2l0aE1lc3NhZ2UocHJlZGljYXRlLCBtZXNzYWdlKSB7XG4gIHByZWRpY2F0ZS5tZXNzYWdlID0gbWVzc2FnZTtcbiAgcmV0dXJuIHByZWRpY2F0ZTtcbn1cbmZ1bmN0aW9uIGpvaW5Vbmlvbk9wdGlvbnMob3B0aW9ucykge1xuICBjb25zdCB2YWx1ZXMgPSBvcHRpb25zLmZpbHRlcigob3B0aW9uKSA9PiB0eXBlb2Ygb3B0aW9uID09PSBcInN0cmluZ1wiIHx8IG9wdGlvbi51bmRvY3VtZW50ZWQgIT09IHRydWUpLm1hcCgob3B0aW9uKSA9PiBgJyR7dHlwZW9mIG9wdGlvbiA9PT0gXCJzdHJpbmdcIiA/IG9wdGlvbiA6IG9wdGlvbi52YWx1ZX0nYCk7XG4gIGlmICh2YWx1ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHZhbHVlc1swXTtcbiAgfVxuICBjb25zdCBsYXN0VmFsdWUgPSB2YWx1ZXMucG9wKCk7XG4gIHJldHVybiBgJHt2YWx1ZXMuam9pbihcIiwgXCIpfSBvciAke2xhc3RWYWx1ZX1gO1xufVxuZnVuY3Rpb24gZ2V0UHJlZGljYXRlTWVzc2FnZShwcmVkaWNhdGUsIGN0eCkge1xuICByZXR1cm4gaXNGdW5jdGlvbihwcmVkaWNhdGUubWVzc2FnZSkgPyBwcmVkaWNhdGUubWVzc2FnZShjdHgpIDogcHJlZGljYXRlLm1lc3NhZ2U7XG59XG5mdW5jdGlvbiBnZXRQcmVkaWNhdGVNZXNzYWdlTWFwcGVyKGN0eCkge1xuICByZXR1cm4gKHByZWRpY2F0ZSkgPT4gZ2V0UHJlZGljYXRlTWVzc2FnZShwcmVkaWNhdGUsIGN0eCk7XG59XG5mdW5jdGlvbiBhdHRhY2hBcnJheVJlc3RyaWN0aW9ucyhwcmVkaWNhdGUpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24ocHJlZGljYXRlLCB7XG4gICAgcmVzdHJpY3QoeyBsZW5ndGg6IGxlbmd0aDIsIG1pbkxlbmd0aCB9ID0ge30pIHtcbiAgICAgIGxldCBtZXNzYWdlID0gXCJhbiBhcnJheVwiO1xuICAgICAgaWYgKGlzTnVtYmVyKG1pbkxlbmd0aCkgJiYgbWluTGVuZ3RoID4gMCkge1xuICAgICAgICBtZXNzYWdlID0gXCJhIG5vbi1lbXB0eSBhcnJheVwiO1xuICAgICAgfSBlbHNlIGlmIChpc051bWJlcihsZW5ndGgyKSkge1xuICAgICAgICBtZXNzYWdlID0gYGFuIGFycmF5IG9mIGxlbmd0aCAke2xlbmd0aDJ9YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcmVkaWNhdGVXaXRoTWVzc2FnZShcbiAgICAgICAgKHZhbHVlKSA9PiBpc0FycmF5KHZhbHVlKSAmJiAoaXNOdW1iZXIobGVuZ3RoMikgPyB2YWx1ZS5sZW5ndGggPT09IGxlbmd0aDIgOiB0cnVlKSAmJiAoaXNOdW1iZXIobWluTGVuZ3RoKSA/IHZhbHVlLmxlbmd0aCA+PSBtaW5MZW5ndGggOiB0cnVlKSxcbiAgICAgICAgbWVzc2FnZVxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gYXR0YWNoTnVtYmVyUmVzdHJpY3Rpb25zKHByZWRpY2F0ZSkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihwcmVkaWNhdGUsIHtcbiAgICByZXN0cmljdCh7IG1pbiwgbWF4IH0gPSB7fSkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IFtcImEgbnVtYmVyXCJdO1xuICAgICAgY29uc3QgaGFzTWluID0gaXNOdW1iZXIobWluKTtcbiAgICAgIGNvbnN0IGhhc01heCA9IGlzTnVtYmVyKG1heCk7XG4gICAgICBpZiAoaGFzTWluICYmIGhhc01heCkge1xuICAgICAgICBtZXNzYWdlLnB1c2goYGJldHdlZW4gJHttaW59IGFuZCAke21heH0gaW5jbHVzaXZlYCk7XG4gICAgICB9IGVsc2UgaWYgKGhhc01pbikge1xuICAgICAgICBtZXNzYWdlLnB1c2goYGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAke21pbn1gKTtcbiAgICAgIH0gZWxzZSBpZiAoaGFzTWF4KSB7XG4gICAgICAgIG1lc3NhZ2UucHVzaChgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICR7bWF4fWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByZWRpY2F0ZVdpdGhNZXNzYWdlKFxuICAgICAgICAodmFsdWUpID0+IGlzRmluaXRlTnVtYmVyKHZhbHVlKSAmJiAoaGFzTWluID8gdmFsdWUgPj0gbWluIDogdHJ1ZSkgJiYgKGhhc01heCA/IHZhbHVlIDw9IG1heCA6IHRydWUpLFxuICAgICAgICBtZXNzYWdlLmpvaW4oXCIgXCIpXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBhdHRhY2hPYmplY3RSZXN0cmljdGlvbnMocHJlZGljYXRlKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHByZWRpY2F0ZSwge1xuICAgIHJlc3RyaWN0KG9iamVjdFR5cGUpIHtcbiAgICAgIHJldHVybiBwcmVkaWNhdGVXaXRoTWVzc2FnZShcbiAgICAgICAgKHZhbHVlKSA9PiB2YWx1ZSBpbnN0YW5jZW9mIG9iamVjdFR5cGUsXG4gICAgICAgIChjdHgpID0+IGdldFByZWRpY2F0ZU1lc3NhZ2UocHJlZGljYXRlLCBjdHgpID8/IGBhbiBpbnN0YW5jZSBvZiAke29iamVjdFR5cGUubmFtZX1gXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgIGlmIChpc05hTih2YWx1ZSkpXG4gICAgICByZXR1cm4gXCJOYU5cIjtcbiAgICBpZiAodmFsdWUgPT09IEluZmluaXR5KVxuICAgICAgcmV0dXJuIFwiSW5maW5pdHlcIjtcbiAgICBpZiAodmFsdWUgPT09IC1JbmZpbml0eSlcbiAgICAgIHJldHVybiBcIi1JbmZpbml0eVwiO1xuICB9XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2NoYXJ0QXhpc0RpcmVjdGlvbi50c1xudmFyIENoYXJ0QXhpc0RpcmVjdGlvbiA9IC8qIEBfX1BVUkVfXyAqLyAoKENoYXJ0QXhpc0RpcmVjdGlvbjIpID0+IHtcbiAgQ2hhcnRBeGlzRGlyZWN0aW9uMltcIlhcIl0gPSBcInhcIjtcbiAgQ2hhcnRBeGlzRGlyZWN0aW9uMltcIllcIl0gPSBcInlcIjtcbiAgcmV0dXJuIENoYXJ0QXhpc0RpcmVjdGlvbjI7XG59KShDaGFydEF4aXNEaXJlY3Rpb24gfHwge30pO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9tb2R1bGUvbW9kdWxlTWFwLnRzXG52YXIgTW9kdWxlTWFwID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm1vZHVsZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgKm1vZHVsZXMoKSB7XG4gICAgZm9yIChjb25zdCBtIG9mIHRoaXMubW9kdWxlTWFwLnZhbHVlcygpKSB7XG4gICAgICB5aWVsZCBtLm1vZHVsZUluc3RhbmNlO1xuICAgIH1cbiAgfVxuICBhZGRNb2R1bGUobW9kdWxlLCBtb2R1bGVGYWN0b3J5KSB7XG4gICAgaWYgKHRoaXMubW9kdWxlTWFwLmhhcyhtb2R1bGUub3B0aW9uc0tleSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQUcgQ2hhcnRzIC0gbW9kdWxlIGFscmVhZHkgaW5pdGlhbGlzZWQ6ICR7bW9kdWxlLm9wdGlvbnNLZXl9YCk7XG4gICAgfVxuICAgIHRoaXMubW9kdWxlTWFwLnNldChtb2R1bGUub3B0aW9uc0tleSwgeyBtb2R1bGUsIG1vZHVsZUluc3RhbmNlOiBtb2R1bGVGYWN0b3J5KG1vZHVsZSkgfSk7XG4gIH1cbiAgcmVtb3ZlTW9kdWxlKG1vZHVsZSkge1xuICAgIGNvbnN0IG1vZHVsZUtleSA9IGlzU3RyaW5nKG1vZHVsZSkgPyBtb2R1bGUgOiBtb2R1bGUub3B0aW9uc0tleTtcbiAgICB0aGlzLm1vZHVsZU1hcC5nZXQobW9kdWxlS2V5KT8ubW9kdWxlSW5zdGFuY2UuZGVzdHJveSgpO1xuICAgIHRoaXMubW9kdWxlTWFwLmRlbGV0ZShtb2R1bGVLZXkpO1xuICB9XG4gIGdldE1vZHVsZShtb2R1bGUpIHtcbiAgICByZXR1cm4gdGhpcy5tb2R1bGVNYXAuZ2V0KGlzU3RyaW5nKG1vZHVsZSkgPyBtb2R1bGUgOiBtb2R1bGUub3B0aW9uc0tleSk/Lm1vZHVsZUluc3RhbmNlO1xuICB9XG4gIGlzRW5hYmxlZChtb2R1bGUpIHtcbiAgICByZXR1cm4gdGhpcy5tb2R1bGVNYXAuaGFzKGlzU3RyaW5nKG1vZHVsZSkgPyBtb2R1bGUgOiBtb2R1bGUub3B0aW9uc0tleSk7XG4gIH1cbiAgbWFwTW9kdWxlcyhjYWxsYmFjazIpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLm1vZHVsZU1hcC52YWx1ZXMoKSwgKG0sIGkpID0+IGNhbGxiYWNrMihtLm1vZHVsZUluc3RhbmNlLCBpKSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBmb3IgKGNvbnN0IG1vZHVsZUtleSBvZiB0aGlzLm1vZHVsZU1hcC5rZXlzKCkpIHtcbiAgICAgIHRoaXMubW9kdWxlTWFwLmdldChtb2R1bGVLZXkpPy5tb2R1bGVJbnN0YW5jZS5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMubW9kdWxlTWFwLmNsZWFyKCk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL21vdGlvbi9yZXNldE1vdGlvbi50c1xudmFyIHJlc2V0TW90aW9uX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHJlc2V0TW90aW9uX2V4cG9ydHMsIHtcbiAgcmVzZXRNb3Rpb246ICgpID0+IHJlc2V0TW90aW9uXG59KTtcbmZ1bmN0aW9uIHJlc2V0TW90aW9uKHNlbGVjdGlvbnNPck5vZGVzLCBwcm9wc0ZuKSB7XG4gIGNvbnN0IHsgbm9kZXMsIHNlbGVjdGlvbnMgfSA9IGRlY29uc3RydWN0U2VsZWN0aW9uc09yTm9kZXMoc2VsZWN0aW9uc09yTm9kZXMpO1xuICBmb3IgKGNvbnN0IHNlbGVjdGlvbiBvZiBzZWxlY3Rpb25zKSB7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIHNlbGVjdGlvbi5ub2RlcygpKSB7XG4gICAgICBjb25zdCBmcm9tMyA9IHByb3BzRm4obm9kZSwgbm9kZS5kYXR1bSk7XG4gICAgICBub2RlLnNldFByb3BlcnRpZXMoZnJvbTMpO1xuICAgIH1cbiAgICBzZWxlY3Rpb24uY2xlYW51cCgpO1xuICB9XG4gIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xuICAgIGNvbnN0IGZyb20zID0gcHJvcHNGbihub2RlLCBub2RlLmRhdHVtKTtcbiAgICBub2RlLnNldFByb3BlcnRpZXMoZnJvbTMpO1xuICB9XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvbnVtYmVyRm9ybWF0LnRzXG5mdW5jdGlvbiBwYXJzZUZvcm1hdChmb3JtYXQpIHtcbiAgbGV0IHByZWZpeDtcbiAgbGV0IHN1ZmZpeDtcbiAgY29uc3Qgc3Vycm91bmRlZCA9IHN1cnJvdW5kZWRSZWdFeC5leGVjKGZvcm1hdCk7XG4gIGlmIChzdXJyb3VuZGVkKSB7XG4gICAgWywgcHJlZml4LCBmb3JtYXQsIHN1ZmZpeF0gPSBzdXJyb3VuZGVkO1xuICB9XG4gIGNvbnN0IG1hdGNoID0gZm9ybWF0UmVnRXguZXhlYyhmb3JtYXQpO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgbnVtYmVyIGZvcm1hdHRlciBpcyBpbnZhbGlkOiAke2Zvcm1hdH1gKTtcbiAgfVxuICBjb25zdCBbLCBmaWxsLCBhbGlnbiwgc2lnbiwgc3ltYm9sLCB6ZXJvLCB3aWR0aDIsIGNvbW1hLCBwcmVjaXNpb24sIHRyaW0sIHR5cGVdID0gbWF0Y2g7XG4gIHJldHVybiB7XG4gICAgZmlsbCxcbiAgICBhbGlnbixcbiAgICBzaWduLFxuICAgIHN5bWJvbCxcbiAgICB6ZXJvLFxuICAgIHdpZHRoOiBwYXJzZUludCh3aWR0aDIpLFxuICAgIGNvbW1hLFxuICAgIHByZWNpc2lvbjogcGFyc2VJbnQocHJlY2lzaW9uKSxcbiAgICB0cmltOiBCb29sZWFuKHRyaW0pLFxuICAgIHR5cGUsXG4gICAgcHJlZml4LFxuICAgIHN1ZmZpeFxuICB9O1xufVxuZnVuY3Rpb24gbnVtYmVyRm9ybWF0KGZvcm1hdCkge1xuICBjb25zdCBvcHRpb25zID0gdHlwZW9mIGZvcm1hdCA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlRm9ybWF0KGZvcm1hdCkgOiBmb3JtYXQ7XG4gIGNvbnN0IHsgZmlsbCwgYWxpZ24sIHNpZ24gPSBcIi1cIiwgc3ltYm9sLCB6ZXJvLCB3aWR0aDogd2lkdGgyLCBjb21tYSwgdHlwZSwgcHJlZml4ID0gXCJcIiwgc3VmZml4ID0gXCJcIiwgcHJlY2lzaW9uIH0gPSBvcHRpb25zO1xuICBsZXQgeyB0cmltIH0gPSBvcHRpb25zO1xuICBjb25zdCBwcmVjaXNpb25Jc05hTiA9IHByZWNpc2lvbiA9PSBudWxsIHx8IGlzTmFOKHByZWNpc2lvbik7XG4gIGxldCBmb3JtYXRCb2R5O1xuICBpZiAoIXR5cGUpIHtcbiAgICBmb3JtYXRCb2R5ID0gZGVjaW1hbFR5cGVzW1wiZ1wiXTtcbiAgICB0cmltID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0eXBlIGluIGRlY2ltYWxUeXBlcyAmJiB0eXBlIGluIGludGVnZXJUeXBlcykge1xuICAgIGZvcm1hdEJvZHkgPSBwcmVjaXNpb25Jc05hTiA/IGludGVnZXJUeXBlc1t0eXBlXSA6IGRlY2ltYWxUeXBlc1t0eXBlXTtcbiAgfSBlbHNlIGlmICh0eXBlIGluIGRlY2ltYWxUeXBlcykge1xuICAgIGZvcm1hdEJvZHkgPSBkZWNpbWFsVHlwZXNbdHlwZV07XG4gIH0gZWxzZSBpZiAodHlwZSBpbiBpbnRlZ2VyVHlwZXMpIHtcbiAgICBmb3JtYXRCb2R5ID0gaW50ZWdlclR5cGVzW3R5cGVdO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlIG51bWJlciBmb3JtYXR0ZXIgdHlwZSBpcyBpbnZhbGlkOiAke3R5cGV9YCk7XG4gIH1cbiAgbGV0IGZvcm1hdHRlclByZWNpc2lvbjtcbiAgaWYgKHByZWNpc2lvbiA9PSBudWxsIHx8IHByZWNpc2lvbklzTmFOKSB7XG4gICAgZm9ybWF0dGVyUHJlY2lzaW9uID0gdHlwZSA/IDYgOiAxMjtcbiAgfSBlbHNlIHtcbiAgICBmb3JtYXR0ZXJQcmVjaXNpb24gPSBwcmVjaXNpb247XG4gIH1cbiAgcmV0dXJuIChuKSA9PiB7XG4gICAgbGV0IHJlc3VsdCA9IGZvcm1hdEJvZHkobiwgZm9ybWF0dGVyUHJlY2lzaW9uKTtcbiAgICBpZiAodHJpbSkge1xuICAgICAgcmVzdWx0ID0gcmVtb3ZlVHJhaWxpbmdaZXJvcyhyZXN1bHQpO1xuICAgIH1cbiAgICBpZiAoY29tbWEpIHtcbiAgICAgIHJlc3VsdCA9IGluc2VydFNlcGFyYXRvcihyZXN1bHQsIGNvbW1hKTtcbiAgICB9XG4gICAgcmVzdWx0ID0gYWRkU2lnbihuLCByZXN1bHQsIHNpZ24pO1xuICAgIGlmIChzeW1ib2wgJiYgc3ltYm9sICE9PSBcIiNcIikge1xuICAgICAgcmVzdWx0ID0gYCR7c3ltYm9sfSR7cmVzdWx0fWA7XG4gICAgfVxuICAgIGlmIChzeW1ib2wgPT09IFwiI1wiICYmIHR5cGUgPT09IFwieFwiKSB7XG4gICAgICByZXN1bHQgPSBgMHgke3Jlc3VsdH1gO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gXCJzXCIpIHtcbiAgICAgIHJlc3VsdCA9IGAke3Jlc3VsdH0ke2dldFNJUHJlZml4KG4pfWA7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBcIiVcIiB8fCB0eXBlID09PSBcInBcIikge1xuICAgICAgcmVzdWx0ID0gYCR7cmVzdWx0fSVgO1xuICAgIH1cbiAgICBpZiAod2lkdGgyICE9IG51bGwgJiYgIWlzTmFOKHdpZHRoMikpIHtcbiAgICAgIHJlc3VsdCA9IGFkZFBhZGRpbmcocmVzdWx0LCB3aWR0aDIsIGZpbGwgPz8gemVybywgYWxpZ24pO1xuICAgIH1cbiAgICByZXN1bHQgPSBgJHtwcmVmaXh9JHtyZXN1bHR9JHtzdWZmaXh9YDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxudmFyIGZvcm1hdFJlZ0V4ID0gL14oPzooLik/KFs8Pj1eXSkpPyhbK1xcLSggXSk/KFsk4oKswqPCpeKCo+KCuSNdKT8oMCk/KFxcZCspPygsKT8oPzpcXC4oXFxkKykpPyh+KT8oWyVhLXpdKT8kL2k7XG52YXIgc3Vycm91bmRlZFJlZ0V4ID0gL14oKD86W14jXXwjW157XSkqKSN7KFtefV0rKX0oLiopJC87XG52YXIgaW50ZWdlclR5cGVzID0ge1xuICBiOiAobikgPT4gYWJzRmxvb3IobikudG9TdHJpbmcoMiksXG4gIGM6IChuKSA9PiBTdHJpbmcuZnJvbUNoYXJDb2RlKG4pLFxuICBkOiAobikgPT4gTWF0aC5yb3VuZChNYXRoLmFicyhuKSkudG9GaXhlZCgwKSxcbiAgbzogKG4pID0+IGFic0Zsb29yKG4pLnRvU3RyaW5nKDgpLFxuICB4OiAobikgPT4gYWJzRmxvb3IobikudG9TdHJpbmcoMTYpLFxuICBYOiAobikgPT4gaW50ZWdlclR5cGVzLngobikudG9VcHBlckNhc2UoKSxcbiAgbjogKG4pID0+IGludGVnZXJUeXBlcy5kKG4pLFxuICBcIiVcIjogKG4pID0+IGAke2Fic0Zsb29yKG4gKiAxMDApLnRvRml4ZWQoMCl9YFxufTtcbnZhciBkZWNpbWFsVHlwZXMgPSB7XG4gIGU6IChuLCBmKSA9PiBNYXRoLmFicyhuKS50b0V4cG9uZW50aWFsKGYpLFxuICBFOiAobiwgZikgPT4gZGVjaW1hbFR5cGVzLmUobiwgZikudG9VcHBlckNhc2UoKSxcbiAgZjogKG4sIGYpID0+IE1hdGguYWJzKG4pLnRvRml4ZWQoZiksXG4gIEY6IChuLCBmKSA9PiBkZWNpbWFsVHlwZXMuZihuLCBmKS50b1VwcGVyQ2FzZSgpLFxuICBnOiAobiwgZikgPT4ge1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICByZXR1cm4gXCIwXCI7XG4gICAgfVxuICAgIGNvbnN0IGEgPSBNYXRoLmFicyhuKTtcbiAgICBjb25zdCBwID0gTWF0aC5mbG9vcihNYXRoLmxvZzEwKGEpKTtcbiAgICBpZiAocCA+PSAtNCAmJiBwIDwgZikge1xuICAgICAgcmV0dXJuIGEudG9GaXhlZChmIC0gMSAtIHApO1xuICAgIH1cbiAgICByZXR1cm4gYS50b0V4cG9uZW50aWFsKGYgLSAxKTtcbiAgfSxcbiAgRzogKG4sIGYpID0+IGRlY2ltYWxUeXBlcy5nKG4sIGYpLnRvVXBwZXJDYXNlKCksXG4gIG46IChuLCBmKSA9PiBkZWNpbWFsVHlwZXMuZyhuLCBmKSxcbiAgcDogKG4sIGYpID0+IGRlY2ltYWxUeXBlcy5yKG4gKiAxMDAsIGYpLFxuICByOiAobiwgZikgPT4ge1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICByZXR1cm4gXCIwXCI7XG4gICAgfVxuICAgIGNvbnN0IGEgPSBNYXRoLmFicyhuKTtcbiAgICBjb25zdCBwID0gTWF0aC5mbG9vcihNYXRoLmxvZzEwKGEpKTtcbiAgICBjb25zdCBxID0gcCAtIChmIC0gMSk7XG4gICAgaWYgKHEgPD0gMCkge1xuICAgICAgcmV0dXJuIGEudG9GaXhlZCgtcSk7XG4gICAgfVxuICAgIGNvbnN0IHggPSAxMCAqKiBxO1xuICAgIHJldHVybiAoTWF0aC5yb3VuZChhIC8geCkgKiB4KS50b0ZpeGVkKCk7XG4gIH0sXG4gIHM6IChuLCBmKSA9PiB7XG4gICAgY29uc3QgcCA9IGdldFNJUHJlZml4UG93ZXIobik7XG4gICAgcmV0dXJuIGRlY2ltYWxUeXBlcy5yKG4gLyAxMCAqKiBwLCBmKTtcbiAgfSxcbiAgXCIlXCI6IChuLCBmKSA9PiBkZWNpbWFsVHlwZXMuZihuICogMTAwLCBmKVxufTtcbnZhciBtaW5TSVByZWZpeCA9IC0yNDtcbnZhciBtYXhTSVByZWZpeCA9IDI0O1xudmFyIHNpUHJlZml4ZXMgPSB7XG4gIFttaW5TSVByZWZpeF06IFwieVwiLFxuICBbLTIxXTogXCJ6XCIsXG4gIFstMThdOiBcImFcIixcbiAgWy0xNV06IFwiZlwiLFxuICBbLTEyXTogXCJwXCIsXG4gIFstOV06IFwiblwiLFxuICBbLTZdOiBcIlxceEI1XCIsXG4gIFstM106IFwibVwiLFxuICBbMF06IFwiXCIsXG4gIFszXTogXCJrXCIsXG4gIFs2XTogXCJNXCIsXG4gIFs5XTogXCJHXCIsXG4gIFsxMl06IFwiVFwiLFxuICBbMTVdOiBcIlBcIixcbiAgWzE4XTogXCJFXCIsXG4gIFsyMV06IFwiWlwiLFxuICBbbWF4U0lQcmVmaXhdOiBcIllcIlxufTtcbnZhciBtaW51c1NpZ24gPSBcIlxcdTIyMTJcIjtcbmZ1bmN0aW9uIGFic0Zsb29yKG4pIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5hYnMobikpO1xufVxuZnVuY3Rpb24gcmVtb3ZlVHJhaWxpbmdaZXJvcyhudW1TdHJpbmcpIHtcbiAgcmV0dXJuIG51bVN0cmluZy5yZXBsYWNlKC9cXC4wKyQvLCBcIlwiKS5yZXBsYWNlKC8oXFwuWzEtOV0pMCskLywgXCIkMVwiKTtcbn1cbmZ1bmN0aW9uIGluc2VydFNlcGFyYXRvcihudW1TdHJpbmcsIHNlcGFyYXRvcikge1xuICBsZXQgZG90SW5kZXggPSBudW1TdHJpbmcuaW5kZXhPZihcIi5cIik7XG4gIGlmIChkb3RJbmRleCA8IDApIHtcbiAgICBkb3RJbmRleCA9IG51bVN0cmluZy5sZW5ndGg7XG4gIH1cbiAgY29uc3QgaW50ZWdlckNoYXJzID0gbnVtU3RyaW5nLnN1YnN0cmluZygwLCBkb3RJbmRleCkuc3BsaXQoXCJcIik7XG4gIGNvbnN0IGZyYWN0aW9uYWxQYXJ0ID0gbnVtU3RyaW5nLnN1YnN0cmluZyhkb3RJbmRleCk7XG4gIGZvciAobGV0IGkgPSBpbnRlZ2VyQ2hhcnMubGVuZ3RoIC0gMzsgaSA+IDA7IGkgLT0gMykge1xuICAgIGludGVnZXJDaGFycy5zcGxpY2UoaSwgMCwgc2VwYXJhdG9yKTtcbiAgfVxuICByZXR1cm4gYCR7aW50ZWdlckNoYXJzLmpvaW4oXCJcIil9JHtmcmFjdGlvbmFsUGFydH1gO1xufVxuZnVuY3Rpb24gZ2V0U0lQcmVmaXgobikge1xuICByZXR1cm4gc2lQcmVmaXhlc1tnZXRTSVByZWZpeFBvd2VyKG4pXTtcbn1cbmZ1bmN0aW9uIGdldFNJUHJlZml4UG93ZXIobikge1xuICByZXR1cm4gY2xhbXAobWluU0lQcmVmaXgsIG4gPyBNYXRoLmZsb29yKE1hdGgubG9nMTAoTWF0aC5hYnMobikpIC8gMykgKiAzIDogMCwgbWF4U0lQcmVmaXgpO1xufVxuZnVuY3Rpb24gYWRkU2lnbihudW0sIG51bVN0cmluZywgc2lnblR5cGUgPSBcIlwiKSB7XG4gIGlmIChzaWduVHlwZSA9PT0gXCIoXCIpIHtcbiAgICByZXR1cm4gbnVtID49IDAgPyBudW1TdHJpbmcgOiBgKCR7bnVtU3RyaW5nfSlgO1xuICB9XG4gIGNvbnN0IHBsdXNTaWduID0gc2lnblR5cGUgPT09IFwiK1wiID8gXCIrXCIgOiBcIlwiO1xuICByZXR1cm4gYCR7bnVtID49IDAgPyBwbHVzU2lnbiA6IG1pbnVzU2lnbn0ke251bVN0cmluZ31gO1xufVxuZnVuY3Rpb24gYWRkUGFkZGluZyhudW1TdHJpbmcsIHdpZHRoMiwgZmlsbCA9IFwiIFwiLCBhbGlnbiA9IFwiPlwiKSB7XG4gIGxldCByZXN1bHQgPSBudW1TdHJpbmc7XG4gIGlmIChhbGlnbiA9PT0gXCI+XCIgfHwgIWFsaWduKSB7XG4gICAgcmVzdWx0ID0gcmVzdWx0LnBhZFN0YXJ0KHdpZHRoMiwgZmlsbCk7XG4gIH0gZWxzZSBpZiAoYWxpZ24gPT09IFwiPFwiKSB7XG4gICAgcmVzdWx0ID0gcmVzdWx0LnBhZEVuZCh3aWR0aDIsIGZpbGwpO1xuICB9IGVsc2UgaWYgKGFsaWduID09PSBcIl5cIikge1xuICAgIGNvbnN0IHBhZFdpZHRoID0gTWF0aC5tYXgoMCwgd2lkdGgyIC0gcmVzdWx0Lmxlbmd0aCk7XG4gICAgY29uc3QgcGFkTGVmdCA9IE1hdGguY2VpbChwYWRXaWR0aCAvIDIpO1xuICAgIGNvbnN0IHBhZFJpZ2h0ID0gTWF0aC5mbG9vcihwYWRXaWR0aCAvIDIpO1xuICAgIHJlc3VsdCA9IHJlc3VsdC5wYWRTdGFydChwYWRMZWZ0ICsgcmVzdWx0Lmxlbmd0aCwgZmlsbCk7XG4gICAgcmVzdWx0ID0gcmVzdWx0LnBhZEVuZChwYWRSaWdodCArIHJlc3VsdC5sZW5ndGgsIGZpbGwpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvdGlja3MudHNcbnZhciB0SW50ZXJ2YWwgPSAodGltZUludGVydmFsLCBiYXNlRHVyYXRpb24sIHN0ZXApID0+ICh7XG4gIGR1cmF0aW9uOiBiYXNlRHVyYXRpb24gKiBzdGVwLFxuICB0aW1lSW50ZXJ2YWwsXG4gIHN0ZXBcbn0pO1xudmFyIFRpY2tJbnRlcnZhbHMgPSBbXG4gIHRJbnRlcnZhbChzZWNvbmRfZGVmYXVsdCwgZHVyYXRpb25TZWNvbmQsIDEpLFxuICB0SW50ZXJ2YWwoc2Vjb25kX2RlZmF1bHQsIGR1cmF0aW9uU2Vjb25kLCA1KSxcbiAgdEludGVydmFsKHNlY29uZF9kZWZhdWx0LCBkdXJhdGlvblNlY29uZCwgMTUpLFxuICB0SW50ZXJ2YWwoc2Vjb25kX2RlZmF1bHQsIGR1cmF0aW9uU2Vjb25kLCAzMCksXG4gIHRJbnRlcnZhbChtaW51dGVfZGVmYXVsdCwgZHVyYXRpb25NaW51dGUsIDEpLFxuICB0SW50ZXJ2YWwobWludXRlX2RlZmF1bHQsIGR1cmF0aW9uTWludXRlLCA1KSxcbiAgdEludGVydmFsKG1pbnV0ZV9kZWZhdWx0LCBkdXJhdGlvbk1pbnV0ZSwgMTUpLFxuICB0SW50ZXJ2YWwobWludXRlX2RlZmF1bHQsIGR1cmF0aW9uTWludXRlLCAzMCksXG4gIHRJbnRlcnZhbChob3VyX2RlZmF1bHQsIGR1cmF0aW9uSG91ciwgMSksXG4gIHRJbnRlcnZhbChob3VyX2RlZmF1bHQsIGR1cmF0aW9uSG91ciwgMyksXG4gIHRJbnRlcnZhbChob3VyX2RlZmF1bHQsIGR1cmF0aW9uSG91ciwgNiksXG4gIHRJbnRlcnZhbChob3VyX2RlZmF1bHQsIGR1cmF0aW9uSG91ciwgMTIpLFxuICB0SW50ZXJ2YWwoZGF5X2RlZmF1bHQsIGR1cmF0aW9uRGF5LCAxKSxcbiAgdEludGVydmFsKGRheV9kZWZhdWx0LCBkdXJhdGlvbkRheSwgMiksXG4gIHRJbnRlcnZhbCh3ZWVrX2RlZmF1bHQsIGR1cmF0aW9uV2VlaywgMSksXG4gIHRJbnRlcnZhbCh3ZWVrX2RlZmF1bHQsIGR1cmF0aW9uV2VlaywgMiksXG4gIHRJbnRlcnZhbCh3ZWVrX2RlZmF1bHQsIGR1cmF0aW9uV2VlaywgMyksXG4gIHRJbnRlcnZhbChtb250aF9kZWZhdWx0LCBkdXJhdGlvbk1vbnRoLCAxKSxcbiAgdEludGVydmFsKG1vbnRoX2RlZmF1bHQsIGR1cmF0aW9uTW9udGgsIDIpLFxuICB0SW50ZXJ2YWwobW9udGhfZGVmYXVsdCwgZHVyYXRpb25Nb250aCwgMyksXG4gIHRJbnRlcnZhbChtb250aF9kZWZhdWx0LCBkdXJhdGlvbk1vbnRoLCA0KSxcbiAgdEludGVydmFsKG1vbnRoX2RlZmF1bHQsIGR1cmF0aW9uTW9udGgsIDYpLFxuICB0SW50ZXJ2YWwoeWVhcl9kZWZhdWx0LCBkdXJhdGlvblllYXIsIDEpXG5dO1xudmFyIFRpY2tNdWx0aXBsaWVycyA9IFsxLCAyLCA1LCAxMF07XG5mdW5jdGlvbiBpc0Nsb3NlVG9JbnRlZ2VyKG4sIGRlbHRhNCkge1xuICByZXR1cm4gTWF0aC5hYnMoTWF0aC5yb3VuZChuKSAtIG4pIDwgZGVsdGE0O1xufVxuZnVuY3Rpb24gY3JlYXRlVGlja3Moc3RhcnQyLCBzdG9wLCBjb3VudCwgbWluQ291bnQsIG1heENvdW50KSB7XG4gIGlmIChjb3VudCA8IDIpIHtcbiAgICByZXR1cm4gW3N0YXJ0Miwgc3RvcF07XG4gIH1cbiAgY29uc3Qgc3RlcCA9IHRpY2tTdGVwKHN0YXJ0Miwgc3RvcCwgY291bnQsIG1pbkNvdW50LCBtYXhDb3VudCk7XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKHN0ZXApKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGlmICghaXNDbG9zZVRvSW50ZWdlcihzdGFydDIgLyBzdGVwLCAxZS0xMikpIHtcbiAgICBzdGFydDIgPSBNYXRoLmNlaWwoc3RhcnQyIC8gc3RlcCkgKiBzdGVwO1xuICB9XG4gIGlmICghaXNDbG9zZVRvSW50ZWdlcihzdG9wIC8gc3RlcCwgMWUtMTIpKSB7XG4gICAgc3RvcCA9IE1hdGguZmxvb3Ioc3RvcCAvIHN0ZXApICogc3RlcDtcbiAgfVxuICByZXR1cm4gcmFuZ2Uoc3RhcnQyLCBzdG9wLCBzdGVwKTtcbn1cbmZ1bmN0aW9uIGdldFRpY2tJbnRlcnZhbChzdGFydDIsIHN0b3AsIGNvdW50LCBtaW5Db3VudCwgbWF4Q291bnQsIHRhcmdldEludGVydmFsKSB7XG4gIGNvbnN0IHRhcmdldCA9IHRhcmdldEludGVydmFsID8/IE1hdGguYWJzKHN0b3AgLSBzdGFydDIpIC8gTWF0aC5tYXgoY291bnQsIDEpO1xuICBsZXQgaSA9IDA7XG4gIGZvciAoY29uc3QgdGlja0ludGVydmFsIG9mIFRpY2tJbnRlcnZhbHMpIHtcbiAgICBpZiAodGFyZ2V0IDw9IHRpY2tJbnRlcnZhbC5kdXJhdGlvbilcbiAgICAgIGJyZWFrO1xuICAgIGkrKztcbiAgfVxuICBpZiAoaSA9PT0gMCkge1xuICAgIGNvbnN0IHN0ZXAyID0gTWF0aC5tYXgodGlja1N0ZXAoc3RhcnQyLCBzdG9wLCBjb3VudCwgbWluQ291bnQsIG1heENvdW50KSwgMSk7XG4gICAgcmV0dXJuIG1pbGxpc2Vjb25kX2RlZmF1bHQuZXZlcnkoc3RlcDIpO1xuICB9IGVsc2UgaWYgKGkgPT09IFRpY2tJbnRlcnZhbHMubGVuZ3RoKSB7XG4gICAgY29uc3Qgc3RlcDIgPSB0YXJnZXRJbnRlcnZhbCA9PSBudWxsID8gdGlja1N0ZXAoc3RhcnQyIC8gZHVyYXRpb25ZZWFyLCBzdG9wIC8gZHVyYXRpb25ZZWFyLCBjb3VudCwgbWluQ291bnQsIG1heENvdW50KSA6IDE7XG4gICAgcmV0dXJuIHllYXJfZGVmYXVsdC5ldmVyeShzdGVwMik7XG4gIH1cbiAgY29uc3QgaTAgPSBUaWNrSW50ZXJ2YWxzW2kgLSAxXTtcbiAgY29uc3QgaTEgPSBUaWNrSW50ZXJ2YWxzW2ldO1xuICBjb25zdCB7IHRpbWVJbnRlcnZhbCwgc3RlcCB9ID0gdGFyZ2V0IC0gaTAuZHVyYXRpb24gPCBpMS5kdXJhdGlvbiAtIHRhcmdldCA/IGkwIDogaTE7XG4gIHJldHVybiB0aW1lSW50ZXJ2YWwuZXZlcnkoc3RlcCk7XG59XG5mdW5jdGlvbiB0aWNrU3RlcChzdGFydDIsIGVuZDIsIGNvdW50LCBtaW5Db3VudCA9IDAsIG1heENvdW50ID0gSW5maW5pdHkpIHtcbiAgaWYgKHN0YXJ0MiA9PT0gZW5kMikge1xuICAgIHJldHVybiBjbGFtcCgxLCBtaW5Db3VudCwgbWF4Q291bnQpO1xuICB9IGVsc2UgaWYgKGNvdW50IDwgMSkge1xuICAgIHJldHVybiBOYU47XG4gIH1cbiAgY29uc3QgZXh0ZW50MiA9IE1hdGguYWJzKGVuZDIgLSBzdGFydDIpO1xuICBjb25zdCBzdGVwID0gMTAgKiogTWF0aC5mbG9vcihNYXRoLmxvZzEwKGV4dGVudDIgLyBjb3VudCkpO1xuICBsZXQgbSA9IE5hTiwgbWluRGlmZiA9IEluZmluaXR5LCBpc0luQm91bmRzID0gZmFsc2U7XG4gIGZvciAoY29uc3QgbXVsdGlwbGllciBvZiBUaWNrTXVsdGlwbGllcnMpIHtcbiAgICBjb25zdCBjID0gTWF0aC5jZWlsKGV4dGVudDIgLyAobXVsdGlwbGllciAqIHN0ZXApKTtcbiAgICBjb25zdCB2YWxpZEJvdW5kcyA9IGMgPj0gbWluQ291bnQgJiYgYyA8PSBtYXhDb3VudDtcbiAgICBpZiAoaXNJbkJvdW5kcyAmJiAhdmFsaWRCb3VuZHMpXG4gICAgICBjb250aW51ZTtcbiAgICBjb25zdCBkaWZmQ291bnQgPSBNYXRoLmFicyhjIC0gY291bnQpO1xuICAgIGlmIChtaW5EaWZmID4gZGlmZkNvdW50IHx8IGlzSW5Cb3VuZHMgIT09IHZhbGlkQm91bmRzKSB7XG4gICAgICBpc0luQm91bmRzIHx8IChpc0luQm91bmRzID0gdmFsaWRCb3VuZHMpO1xuICAgICAgbWluRGlmZiA9IGRpZmZDb3VudDtcbiAgICAgIG0gPSBtdWx0aXBsaWVyO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbSAqIHN0ZXA7XG59XG5mdW5jdGlvbiBkZWNpbWFsUGxhY2VzKGRlY2ltYWwpIHtcbiAgZm9yIChsZXQgaSA9IGRlY2ltYWwubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICBpZiAoZGVjaW1hbFtpXSAhPT0gXCIwXCIpIHtcbiAgICAgIHJldHVybiBpICsgMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiB0aWNrRm9ybWF0KHRpY2tzLCBmb3JtYXQpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHBhcnNlRm9ybWF0KGZvcm1hdCA/PyBcIixmXCIpO1xuICBpZiAob3B0aW9ucy5wcmVjaXNpb24gPT0gbnVsbCB8fCBpc05hTihvcHRpb25zLnByZWNpc2lvbikpIHtcbiAgICBpZiAoIW9wdGlvbnMudHlwZSB8fCBcImVFRmdHbnByc1wiLmluY2x1ZGVzKG9wdGlvbnMudHlwZSkpIHtcbiAgICAgIG9wdGlvbnMucHJlY2lzaW9uID0gTWF0aC5tYXgoXG4gICAgICAgIC4uLnRpY2tzLm1hcCgoeCkgPT4ge1xuICAgICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHgpKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgY29uc3QgW2ludGVnZXIsIGRlY2ltYWxdID0geC50b0V4cG9uZW50aWFsKChvcHRpb25zLnR5cGUgPyA2IDogMTIpIC0gMSkuc3BsaXQoL1xcLnxlL2cpO1xuICAgICAgICAgIHJldHVybiAoaW50ZWdlciAhPT0gXCIxXCIgJiYgaW50ZWdlciAhPT0gXCItMVwiID8gMSA6IDApICsgZGVjaW1hbFBsYWNlcyhkZWNpbWFsKSArIDE7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoXCJmJVwiLmluY2x1ZGVzKG9wdGlvbnMudHlwZSkpIHtcbiAgICAgIG9wdGlvbnMucHJlY2lzaW9uID0gTWF0aC5tYXgoXG4gICAgICAgIC4uLnRpY2tzLm1hcCgoeCkgPT4ge1xuICAgICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHgpIHx8IHggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICBjb25zdCBsID0gTWF0aC5mbG9vcihNYXRoLmxvZzEwKE1hdGguYWJzKHgpKSk7XG4gICAgICAgICAgY29uc3QgZGlnaXRzID0gb3B0aW9ucy50eXBlID8gNiA6IDEyO1xuICAgICAgICAgIGNvbnN0IGRlY2ltYWwgPSB4LnRvRXhwb25lbnRpYWwoZGlnaXRzIC0gMSkuc3BsaXQoL1xcLnxlL2cpWzFdO1xuICAgICAgICAgIGNvbnN0IGRlY2ltYWxMZW5ndGggPSBkZWNpbWFsUGxhY2VzKGRlY2ltYWwpO1xuICAgICAgICAgIHJldHVybiBNYXRoLm1heCgwLCBkZWNpbWFsTGVuZ3RoIC0gbCk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBjb25zdCBmb3JtYXR0ZXIgPSBudW1iZXJGb3JtYXQob3B0aW9ucyk7XG4gIHJldHVybiAobikgPT4gZm9ybWF0dGVyKE51bWJlcihuKSk7XG59XG5mdW5jdGlvbiByYW5nZShzdGFydDIsIGVuZDIsIHN0ZXApIHtcbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoc3RlcCkgfHwgc3RlcCA8PSAwKVxuICAgIHJldHVybiBbXTtcbiAgY29uc3QgZiA9IDEwICoqIGNvdW50RnJhY3Rpb25EaWdpdHMoc3RlcCk7XG4gIGNvbnN0IGQwID0gTWF0aC5taW4oc3RhcnQyLCBlbmQyKTtcbiAgY29uc3QgZDEgPSBNYXRoLm1heChzdGFydDIsIGVuZDIpO1xuICBjb25zdCBvdXQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IDsgaSArPSAxKSB7XG4gICAgY29uc3QgcCA9IE1hdGgucm91bmQoKGQwICsgc3RlcCAqIGkpICogZikgLyBmO1xuICAgIGlmIChwIDw9IGQxKSB7XG4gICAgICBvdXQucHVzaChwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59XG5mdW5jdGlvbiBpc0RlbnNlSW50ZXJ2YWwoY291bnQsIGF2YWlsYWJsZVJhbmdlKSB7XG4gIGlmIChjb3VudCA+PSBhdmFpbGFibGVSYW5nZSkge1xuICAgIExvZ2dlci53YXJuT25jZShcbiAgICAgIGB0aGUgY29uZmlndXJlZCBpbnRlcnZhbCByZXN1bHRzIGluIG1vcmUgdGhhbiAxIGl0ZW0gcGVyIHBpeGVsLCBpZ25vcmluZy4gU3VwcGx5IGEgbGFyZ2VyIGludGVydmFsIG9yIG9taXQgdGhpcyBjb25maWd1cmF0aW9uYFxuICAgICk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gbmljZVRpY2tzRG9tYWluKHN0YXJ0MiwgZW5kMikge1xuICBjb25zdCBleHRlbnQyID0gTWF0aC5hYnMoZW5kMiAtIHN0YXJ0Mik7XG4gIGNvbnN0IHN0ZXAgPSAxMCAqKiBNYXRoLmZsb29yKE1hdGgubG9nMTAoZXh0ZW50MikpO1xuICBsZXQgbWluRXJyb3IgPSBJbmZpbml0eSwgdGlja3MgPSBbc3RhcnQyLCBlbmQyXTtcbiAgZm9yIChjb25zdCBtdWx0aXBsaWVyIG9mIFRpY2tNdWx0aXBsaWVycykge1xuICAgIGNvbnN0IG0gPSBtdWx0aXBsaWVyICogc3RlcDtcbiAgICBjb25zdCBkMCA9IE1hdGguZmxvb3Ioc3RhcnQyIC8gbSkgKiBtO1xuICAgIGNvbnN0IGQxID0gTWF0aC5jZWlsKGVuZDIgLyBtKSAqIG07XG4gICAgY29uc3QgZXJyb3IgPSAxIC0gZXh0ZW50MiAvIE1hdGguYWJzKGQxIC0gZDApO1xuICAgIGlmIChtaW5FcnJvciA+IGVycm9yKSB7XG4gICAgICBtaW5FcnJvciA9IGVycm9yO1xuICAgICAgdGlja3MgPSBbZDAsIGQxXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRpY2tzO1xufVxuZnVuY3Rpb24gZXN0aW1hdGVUaWNrQ291bnQocmFuZ2VFeHRlbnQsIG1pblNwYWNpbmcsIG1heFNwYWNpbmcsIGRlZmF1bHRUaWNrQ291bnQsIGRlZmF1bHRNaW5TcGFjaW5nKSB7XG4gIGRlZmF1bHRNaW5TcGFjaW5nID0gTWF0aC5tYXgoZGVmYXVsdE1pblNwYWNpbmcsIHJhbmdlRXh0ZW50IC8gKGRlZmF1bHRUaWNrQ291bnQgKyAxKSk7XG4gIGlmIChpc05hTihtaW5TcGFjaW5nKSkge1xuICAgIG1pblNwYWNpbmcgPSBkZWZhdWx0TWluU3BhY2luZztcbiAgfVxuICBpZiAoaXNOYU4obWF4U3BhY2luZykpIHtcbiAgICBtYXhTcGFjaW5nID0gcmFuZ2VFeHRlbnQ7XG4gIH1cbiAgaWYgKG1pblNwYWNpbmcgPiBtYXhTcGFjaW5nKSB7XG4gICAgaWYgKG1pblNwYWNpbmcgPT09IGRlZmF1bHRNaW5TcGFjaW5nKSB7XG4gICAgICBtaW5TcGFjaW5nID0gbWF4U3BhY2luZztcbiAgICB9IGVsc2Uge1xuICAgICAgbWF4U3BhY2luZyA9IG1pblNwYWNpbmc7XG4gICAgfVxuICB9XG4gIGNvbnN0IG1heFRpY2tDb3VudCA9IGNsYW1wKDEsIE1hdGguZmxvb3IocmFuZ2VFeHRlbnQgLyBtaW5TcGFjaW5nKSwgTWF0aC5taW4oTWF0aC5mbG9vcihyYW5nZUV4dGVudCksIDEwMCkpO1xuICBjb25zdCBtaW5UaWNrQ291bnQgPSBNYXRoLm1pbihtYXhUaWNrQ291bnQsIE1hdGguY2VpbChyYW5nZUV4dGVudCAvIG1heFNwYWNpbmcpKTtcbiAgY29uc3QgdGlja0NvdW50ID0gY2xhbXAobWluVGlja0NvdW50LCBkZWZhdWx0VGlja0NvdW50LCBtYXhUaWNrQ291bnQpO1xuICByZXR1cm4geyBtaW5UaWNrQ291bnQsIG1heFRpY2tDb3VudCwgdGlja0NvdW50IH07XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjYWxlL2xvZ1NjYWxlLnRzXG52YXIgX0xvZ1NjYWxlID0gY2xhc3MgX0xvZ1NjYWxlIGV4dGVuZHMgQ29udGludW91c1NjYWxlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoWzEsIDEwXSwgWzAsIDFdKTtcbiAgICB0aGlzLnR5cGUgPSBcImxvZ1wiO1xuICAgIHRoaXMuYmFzZSA9IDEwO1xuICAgIHRoaXMuYmFzZUxvZyA9IGlkZW50aXR5O1xuICAgIHRoaXMuYmFzZVBvdyA9IGlkZW50aXR5O1xuICAgIHRoaXMubG9nID0gKHgpID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0MiA9IE1hdGgubWluKC4uLnRoaXMuZG9tYWluKTtcbiAgICAgIHJldHVybiBzdGFydDIgPj0gMCA/IHRoaXMuYmFzZUxvZyh4KSA6IC10aGlzLmJhc2VMb2coLXgpO1xuICAgIH07XG4gICAgdGhpcy5wb3cgPSAoeCkgPT4ge1xuICAgICAgY29uc3Qgc3RhcnQyID0gTWF0aC5taW4oLi4udGhpcy5kb21haW4pO1xuICAgICAgcmV0dXJuIHN0YXJ0MiA+PSAwID8gdGhpcy5iYXNlUG93KHgpIDogLXRoaXMuYmFzZVBvdygteCk7XG4gICAgfTtcbiAgICB0aGlzLmRlZmF1bHRDbGFtcE1vZGUgPSBcImNsYW1wZWRcIjtcbiAgfVxuICB0b0RvbWFpbihkKSB7XG4gICAgcmV0dXJuIGQ7XG4gIH1cbiAgdHJhbnNmb3JtKHgpIHtcbiAgICBjb25zdCBzdGFydDIgPSBNYXRoLm1pbiguLi50aGlzLmRvbWFpbik7XG4gICAgcmV0dXJuIHN0YXJ0MiA+PSAwID8gTWF0aC5sb2coeCkgOiAtTWF0aC5sb2coLXgpO1xuICB9XG4gIHRyYW5zZm9ybUludmVydCh4KSB7XG4gICAgY29uc3Qgc3RhcnQyID0gTWF0aC5taW4oLi4udGhpcy5kb21haW4pO1xuICAgIHJldHVybiBzdGFydDIgPj0gMCA/IE1hdGguZXhwKHgpIDogLU1hdGguZXhwKC14KTtcbiAgfVxuICByZWZyZXNoKCkge1xuICAgIGlmICh0aGlzLmJhc2UgPD0gMCkge1xuICAgICAgdGhpcy5iYXNlID0gMDtcbiAgICAgIExvZ2dlci53YXJuT25jZShcImV4cGVjdGluZyBhIGZpbml0ZSBOdW1iZXIgZ3JlYXRlciB0aGFuIHRvIDBcIik7XG4gICAgfVxuICAgIHN1cGVyLnJlZnJlc2goKTtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgaWYgKCF0aGlzLmRvbWFpbiB8fCB0aGlzLmRvbWFpbi5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYmFzZUxvZyA9IF9Mb2dTY2FsZS5nZXRCYXNlTG9nTWV0aG9kKHRoaXMuYmFzZSk7XG4gICAgdGhpcy5iYXNlUG93ID0gX0xvZ1NjYWxlLmdldEJhc2VQb3dlck1ldGhvZCh0aGlzLmJhc2UpO1xuICAgIGlmICh0aGlzLm5pY2UpIHtcbiAgICAgIHRoaXMudXBkYXRlTmljZURvbWFpbigpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVOaWNlRG9tYWluKCkge1xuICAgIGNvbnN0IFtkMCwgZDFdID0gdGhpcy5kb21haW47XG4gICAgY29uc3Qgcm91bmRTdGFydCA9IGQwID4gZDEgPyBNYXRoLmNlaWwgOiBNYXRoLmZsb29yO1xuICAgIGNvbnN0IHJvdW5kU3RvcCA9IGQwID4gZDEgPyBNYXRoLmZsb29yIDogTWF0aC5jZWlsO1xuICAgIGNvbnN0IG4wID0gdGhpcy5wb3cocm91bmRTdGFydCh0aGlzLmxvZyhkMCkpKTtcbiAgICBjb25zdCBuMSA9IHRoaXMucG93KHJvdW5kU3RvcCh0aGlzLmxvZyhkMSkpKTtcbiAgICB0aGlzLm5pY2VEb21haW4gPSBbbjAsIG4xXTtcbiAgfVxuICB0aWNrcygpIHtcbiAgICBjb25zdCBjb3VudCA9IHRoaXMudGlja0NvdW50ID8/IDEwO1xuICAgIGlmICghdGhpcy5kb21haW4gfHwgdGhpcy5kb21haW4ubGVuZ3RoIDwgMiB8fCBjb3VudCA8IDEpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgY29uc3QgYmFzZSA9IHRoaXMuYmFzZTtcbiAgICBjb25zdCBbZDAsIGQxXSA9IHRoaXMuZ2V0RG9tYWluKCk7XG4gICAgY29uc3Qgc3RhcnQyID0gTWF0aC5taW4oZDAsIGQxKTtcbiAgICBjb25zdCBzdG9wID0gTWF0aC5tYXgoZDAsIGQxKTtcbiAgICBsZXQgcDAgPSB0aGlzLmxvZyhzdGFydDIpO1xuICAgIGxldCBwMSA9IHRoaXMubG9nKHN0b3ApO1xuICAgIGlmICh0aGlzLmludGVydmFsKSB7XG4gICAgICBjb25zdCBpbkJvdW5kcyA9ICh0aWNrKSA9PiB0aWNrID49IHN0YXJ0MiAmJiB0aWNrIDw9IHN0b3A7XG4gICAgICBjb25zdCBzdGVwID0gTWF0aC5taW4oTWF0aC5hYnModGhpcy5pbnRlcnZhbCksIE1hdGguYWJzKHAxIC0gcDApKTtcbiAgICAgIGNvbnN0IHRpY2tzMiA9IHJhbmdlKHAwLCBwMSwgc3RlcCkubWFwKHRoaXMucG93KS5maWx0ZXIoaW5Cb3VuZHMpO1xuICAgICAgaWYgKCFpc0RlbnNlSW50ZXJ2YWwodGlja3MyLmxlbmd0aCwgdGhpcy5nZXRQaXhlbFJhbmdlKCkpKSB7XG4gICAgICAgIHJldHVybiB0aWNrczI7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGlzQmFzZUludGVnZXIgPSBiYXNlICUgMSA9PT0gMDtcbiAgICBjb25zdCBpc0RpZmZMYXJnZSA9IHAxIC0gcDAgPj0gY291bnQ7XG4gICAgaWYgKCFpc0Jhc2VJbnRlZ2VyIHx8IGlzRGlmZkxhcmdlKSB7XG4gICAgICByZXR1cm4gY3JlYXRlVGlja3MocDAsIHAxLCBNYXRoLm1pbihwMSAtIHAwLCBjb3VudCkpLm1hcCh0aGlzLnBvdyk7XG4gICAgfVxuICAgIGNvbnN0IHRpY2tzID0gW107XG4gICAgY29uc3QgaXNQb3NpdGl2ZSA9IHN0YXJ0MiA+IDA7XG4gICAgcDAgPSBNYXRoLmZsb29yKHAwKSAtIDE7XG4gICAgcDEgPSBNYXRoLnJvdW5kKHAxKSArIDE7XG4gICAgY29uc3QgYXZhaWxhYmxlU3BhY2luZyA9IGZpbmRSYW5nZUV4dGVudCh0aGlzLnJhbmdlKSAvIGNvdW50O1xuICAgIGxldCBsYXN0VGlja1Bvc2l0aW9uID0gSW5maW5pdHk7XG4gICAgZm9yIChsZXQgcCA9IHAwOyBwIDw9IHAxOyBwKyspIHtcbiAgICAgIGNvbnN0IG5leHRNYWduaXR1ZGVUaWNrUG9zaXRpb24gPSB0aGlzLmNvbnZlcnQodGhpcy5wb3cocCArIDEpKTtcbiAgICAgIGZvciAobGV0IGsgPSAxOyBrIDwgYmFzZTsgaysrKSB7XG4gICAgICAgIGNvbnN0IHEgPSBpc1Bvc2l0aXZlID8gayA6IGJhc2UgLSBrICsgMTtcbiAgICAgICAgY29uc3QgdCA9IHRoaXMucG93KHApICogcTtcbiAgICAgICAgY29uc3QgdGlja1Bvc2l0aW9uID0gdGhpcy5jb252ZXJ0KHQpO1xuICAgICAgICBjb25zdCBwcmV2U3BhY2luZyA9IE1hdGguYWJzKGxhc3RUaWNrUG9zaXRpb24gLSB0aWNrUG9zaXRpb24pO1xuICAgICAgICBjb25zdCBuZXh0U3BhY2luZyA9IE1hdGguYWJzKHRpY2tQb3NpdGlvbiAtIG5leHRNYWduaXR1ZGVUaWNrUG9zaXRpb24pO1xuICAgICAgICBjb25zdCBmaXRzID0gcHJldlNwYWNpbmcgPj0gYXZhaWxhYmxlU3BhY2luZyAmJiBuZXh0U3BhY2luZyA+PSBhdmFpbGFibGVTcGFjaW5nO1xuICAgICAgICBpZiAodCA+PSBzdGFydDIgJiYgdCA8PSBzdG9wICYmIChrID09PSAxIHx8IGZpdHMgfHwgdGlja3MubGVuZ3RoID09PSAwKSkge1xuICAgICAgICAgIHRpY2tzLnB1c2godCk7XG4gICAgICAgICAgbGFzdFRpY2tQb3NpdGlvbiA9IHRpY2tQb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGlja3M7XG4gIH1cbiAgdGlja0Zvcm1hdCh7XG4gICAgY291bnQsXG4gICAgdGlja3MsXG4gICAgc3BlY2lmaWVyXG4gIH0pIHtcbiAgICBpZiAoY291bnQgIT09IEluZmluaXR5ICYmIHRpY2tzID09IG51bGwpIHtcbiAgICAgIHRoaXMudGlja3MoKTtcbiAgICB9XG4gICAgc3BlY2lmaWVyID8/IChzcGVjaWZpZXIgPSB0aGlzLmJhc2UgPT09IDEwID8gXCIuMGVcIiA6IFwiLFwiKTtcbiAgICByZXR1cm4gaXNTdHJpbmcoc3BlY2lmaWVyKSA/IG51bWJlckZvcm1hdChzcGVjaWZpZXIpIDogc3BlY2lmaWVyO1xuICB9XG4gIHN0YXRpYyBnZXRCYXNlTG9nTWV0aG9kKGJhc2UpIHtcbiAgICBzd2l0Y2ggKGJhc2UpIHtcbiAgICAgIGNhc2UgMTA6XG4gICAgICAgIHJldHVybiBNYXRoLmxvZzEwO1xuICAgICAgY2FzZSBNYXRoLkU6XG4gICAgICAgIHJldHVybiBNYXRoLmxvZztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIE1hdGgubG9nMjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAoeCkgPT4gTWF0aC5sb2coeCkgLyBNYXRoLmxvZyhiYXNlKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGdldEJhc2VQb3dlck1ldGhvZChiYXNlKSB7XG4gICAgc3dpdGNoIChiYXNlKSB7XG4gICAgICBjYXNlIDEwOlxuICAgICAgICByZXR1cm4gKHgpID0+IHggPj0gMCA/IDEwICoqIHggOiAxIC8gMTAgKiogLXg7XG4gICAgICBjYXNlIE1hdGguRTpcbiAgICAgICAgcmV0dXJuIE1hdGguZXhwO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuICh4KSA9PiBiYXNlICoqIHg7XG4gICAgfVxuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgSW52YWxpZGF0aW5nXG5dLCBfTG9nU2NhbGUucHJvdG90eXBlLCBcImJhc2VcIiwgMik7XG52YXIgTG9nU2NhbGUgPSBfTG9nU2NhbGU7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjYWxlL3RpbWVTY2FsZS50c1xudmFyIFRpbWVTY2FsZSA9IGNsYXNzIF9UaW1lU2NhbGUgZXh0ZW5kcyBDb250aW51b3VzU2NhbGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihbXSwgWzAsIDFdKTtcbiAgICB0aGlzLnR5cGUgPSBcInRpbWVcIjtcbiAgfVxuICB0b0RvbWFpbihkKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKGQpO1xuICB9XG4gIGNvbnZlcnQoeCwgb3B0cykge1xuICAgIHJldHVybiBzdXBlci5jb252ZXJ0KG5ldyBEYXRlKHgpLCBvcHRzKTtcbiAgfVxuICBpbnZlcnQoeSkge1xuICAgIHJldHVybiBuZXcgRGF0ZShzdXBlci5pbnZlcnQoeSkpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHVuaWZvcm1seS1zcGFjZWQgZGF0ZXMgdGhhdCByZXByZXNlbnQgdGhlIHNjYWxlJ3MgZG9tYWluLlxuICAgKi9cbiAgdGlja3MoKSB7XG4gICAgaWYgKCF0aGlzLmRvbWFpbiB8fCB0aGlzLmRvbWFpbi5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIGNvbnN0IHsgaW50ZXJ2YWwsIG5pY2UsIHRpY2tDb3VudCwgbWluVGlja0NvdW50LCBtYXhUaWNrQ291bnQgfSA9IHRoaXM7XG4gICAgY29uc3QgW3N0YXJ0Miwgc3RvcF0gPSBmaW5kTWluTWF4KHRoaXMuZ2V0RG9tYWluKCkubWFwKGRhdGVUb051bWJlcikpO1xuICAgIGlmIChpbnRlcnZhbCAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gX1RpbWVTY2FsZS5nZXRUaWNrc0ZvckludGVydmFsKHsgc3RhcnQ6IHN0YXJ0Miwgc3RvcCwgaW50ZXJ2YWwsIGF2YWlsYWJsZVJhbmdlOiB0aGlzLmdldFBpeGVsUmFuZ2UoKSB9KSA/PyBfVGltZVNjYWxlLmdldERlZmF1bHRUaWNrcyh7IHN0YXJ0OiBzdGFydDIsIHN0b3AsIHRpY2tDb3VudCwgbWluVGlja0NvdW50LCBtYXhUaWNrQ291bnQgfSk7XG4gICAgfSBlbHNlIGlmIChuaWNlICYmIHRpY2tDb3VudCA9PT0gMikge1xuICAgICAgcmV0dXJuIHRoaXMubmljZURvbWFpbjtcbiAgICB9IGVsc2UgaWYgKG5pY2UgJiYgdGlja0NvdW50ID09PSAxKSB7XG4gICAgICByZXR1cm4gdGhpcy5uaWNlRG9tYWluLnNsaWNlKDAsIDEpO1xuICAgIH1cbiAgICByZXR1cm4gX1RpbWVTY2FsZS5nZXREZWZhdWx0VGlja3MoeyBzdGFydDogc3RhcnQyLCBzdG9wLCB0aWNrQ291bnQsIG1pblRpY2tDb3VudCwgbWF4VGlja0NvdW50IH0pO1xuICB9XG4gIHN0YXRpYyBnZXREZWZhdWx0VGlja3Moe1xuICAgIHN0YXJ0OiBzdGFydDIsXG4gICAgc3RvcCxcbiAgICB0aWNrQ291bnQsXG4gICAgbWluVGlja0NvdW50LFxuICAgIG1heFRpY2tDb3VudFxuICB9KSB7XG4gICAgY29uc3QgdCA9IGdldFRpY2tJbnRlcnZhbChzdGFydDIsIHN0b3AsIHRpY2tDb3VudCwgbWluVGlja0NvdW50LCBtYXhUaWNrQ291bnQpO1xuICAgIHJldHVybiB0ID8gdC5yYW5nZShuZXcgRGF0ZShzdGFydDIpLCBuZXcgRGF0ZShzdG9wKSkgOiBbXTtcbiAgfVxuICBzdGF0aWMgZ2V0VGlja3NGb3JJbnRlcnZhbCh7XG4gICAgc3RhcnQ6IHN0YXJ0MixcbiAgICBzdG9wLFxuICAgIGludGVydmFsLFxuICAgIGF2YWlsYWJsZVJhbmdlXG4gIH0pIHtcbiAgICBpZiAoIWludGVydmFsKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGlmIChpbnRlcnZhbCBpbnN0YW5jZW9mIFRpbWVJbnRlcnZhbCkge1xuICAgICAgY29uc3QgdGlja3MyID0gaW50ZXJ2YWwucmFuZ2UobmV3IERhdGUoc3RhcnQyKSwgbmV3IERhdGUoc3RvcCkpO1xuICAgICAgaWYgKGlzRGVuc2VJbnRlcnZhbCh0aWNrczIubGVuZ3RoLCBhdmFpbGFibGVSYW5nZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRpY2tzMjtcbiAgICB9XG4gICAgY29uc3QgYWJzSW50ZXJ2YWwgPSBNYXRoLmFicyhpbnRlcnZhbCk7XG4gICAgaWYgKGlzRGVuc2VJbnRlcnZhbCgoc3RvcCAtIHN0YXJ0MikgLyBhYnNJbnRlcnZhbCwgYXZhaWxhYmxlUmFuZ2UpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHRpbWVJbnRlcnZhbCA9IFRpY2tJbnRlcnZhbHMuZmluZExhc3QoKHRpY2tJbnRlcnZhbCkgPT4gYWJzSW50ZXJ2YWwgJSB0aWNrSW50ZXJ2YWwuZHVyYXRpb24gPT09IDApO1xuICAgIGlmICh0aW1lSW50ZXJ2YWwpIHtcbiAgICAgIGNvbnN0IGkgPSB0aW1lSW50ZXJ2YWwudGltZUludGVydmFsLmV2ZXJ5KGFic0ludGVydmFsIC8gKHRpbWVJbnRlcnZhbC5kdXJhdGlvbiAvIHRpbWVJbnRlcnZhbC5zdGVwKSk7XG4gICAgICByZXR1cm4gaS5yYW5nZShuZXcgRGF0ZShzdGFydDIpLCBuZXcgRGF0ZShzdG9wKSk7XG4gICAgfVxuICAgIGxldCBkYXRlID0gbmV3IERhdGUoc3RhcnQyKTtcbiAgICBjb25zdCBzdG9wRGF0ZSA9IG5ldyBEYXRlKHN0b3ApO1xuICAgIGNvbnN0IHRpY2tzID0gW107XG4gICAgd2hpbGUgKGRhdGUgPD0gc3RvcERhdGUpIHtcbiAgICAgIHRpY2tzLnB1c2goZGF0ZSk7XG4gICAgICBkYXRlID0gbmV3IERhdGUoZGF0ZSk7XG4gICAgICBkYXRlLnNldE1pbGxpc2Vjb25kcyhkYXRlLmdldE1pbGxpc2Vjb25kcygpICsgYWJzSW50ZXJ2YWwpO1xuICAgIH1cbiAgICByZXR1cm4gdGlja3M7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSB0aW1lIGZvcm1hdCBmdW5jdGlvbiBzdWl0YWJsZSBmb3IgZGlzcGxheWluZyB0aWNrIHZhbHVlcy5cbiAgICpcbiAgICogQHBhcmFtIHRpY2tzIE9wdGlvbmFsIGFycmF5IG9mIHRpY2sgdmFsdWVzIGZvciBjdXN0b20gZm9ybWF0dGluZy5cbiAgICogQHBhcmFtIGRvbWFpbiBPcHRpb25hbCBhcnJheSByZXByZXNlbnRpbmcgdGhlIFttaW4sIG1heF0gdmFsdWVzIG9mIHRoZSB0aW1lIGF4aXMuXG4gICAqIEBwYXJhbSBzcGVjaWZpZXIgT3B0aW9uYWwgZm9ybWF0IHNwZWNpZmllciBzdHJpbmcgZm9yIGN1c3RvbSBkYXRlIGZvcm1hdHRpbmcgKGUuZy4sIGAlWWAsIGAlbWAsIGAlZGApLlxuICAgKiBAcGFyYW0gZm9ybWF0T2Zmc2V0IE9wdGlvbmFsIG51bWJlciBmb3IgYXBwbHlpbmcgYW4gb2Zmc2V0IHRvIHRoZSBmb3JtYXQgKGUuZy4sIHRpbWV6b25lIHNoaWZ0cykuXG4gICAqIEByZXR1cm5zIEEgZnVuY3Rpb24gdGhhdCBmb3JtYXRzIGEgYERhdGVgIG9iamVjdCBpbnRvIGEgc3RyaW5nIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBzcGVjaWZpZXIgb3IgZGVmYXVsdCBmb3JtYXQuXG4gICAqL1xuICB0aWNrRm9ybWF0KHtcbiAgICB0aWNrcyxcbiAgICBkb21haW4sXG4gICAgc3BlY2lmaWVyLFxuICAgIGZvcm1hdE9mZnNldFxuICB9KSB7XG4gICAgcmV0dXJuIHNwZWNpZmllciA9PSBudWxsID8gZGVmYXVsdFRpbWVUaWNrRm9ybWF0KHRpY2tzLCBkb21haW4sIGZvcm1hdE9mZnNldCkgOiBidWlsZEZvcm1hdHRlcihzcGVjaWZpZXIpO1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICBpZiAoIXRoaXMuZG9tYWluIHx8IHRoaXMuZG9tYWluLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMubmljZSkge1xuICAgICAgdGhpcy51cGRhdGVOaWNlRG9tYWluKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBFeHRlbmRzIHRoZSBkb21haW4gc28gdGhhdCBpdCBzdGFydHMgYW5kIGVuZHMgb24gbmljZSByb3VuZCB2YWx1ZXMuXG4gICAqIFRoaXMgbWV0aG9kIHR5cGljYWxseSBtb2RpZmllcyB0aGUgc2NhbGXigJlzIGRvbWFpbiwgYW5kIG1heSBvbmx5IGV4dGVuZCB0aGUgYm91bmRzIHRvIHRoZSBuZWFyZXN0IHJvdW5kIHZhbHVlLlxuICAgKi9cbiAgdXBkYXRlTmljZURvbWFpbigpIHtcbiAgICBjb25zdCBtYXhBdHRlbXB0cyA9IDQ7XG4gICAgbGV0IFtkMCwgZDFdID0gdGhpcy5kb21haW47XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhBdHRlbXB0czsgaSsrKSB7XG4gICAgICB0aGlzLnVwZGF0ZU5pY2VEb21haW5JdGVyYXRpb24oZDAsIGQxKTtcbiAgICAgIGNvbnN0IFtuMCwgbjFdID0gdGhpcy5uaWNlRG9tYWluO1xuICAgICAgaWYgKGRhdGVUb051bWJlcihkMCkgPT09IGRhdGVUb051bWJlcihuMCkgJiYgZGF0ZVRvTnVtYmVyKGQxKSA9PT0gZGF0ZVRvTnVtYmVyKG4xKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGQwID0gbjA7XG4gICAgICBkMSA9IG4xO1xuICAgIH1cbiAgfVxuICB1cGRhdGVOaWNlRG9tYWluSXRlcmF0aW9uKGQwLCBkMSkge1xuICAgIGNvbnN0IHN0YXJ0MiA9IE1hdGgubWluKGRhdGVUb051bWJlcihkMCksIGRhdGVUb051bWJlcihkMSkpO1xuICAgIGNvbnN0IHN0b3AgPSBNYXRoLm1heChkYXRlVG9OdW1iZXIoZDApLCBkYXRlVG9OdW1iZXIoZDEpKTtcbiAgICBjb25zdCBpc1JldmVyc2VkID0gZDAgPiBkMTtcbiAgICBjb25zdCB7IGludGVydmFsIH0gPSB0aGlzO1xuICAgIGxldCBpO1xuICAgIGlmIChpbnRlcnZhbCBpbnN0YW5jZW9mIFRpbWVJbnRlcnZhbCkge1xuICAgICAgaSA9IGludGVydmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0aWNrQ291bnQgPSB0eXBlb2YgaW50ZXJ2YWwgPT09IFwibnVtYmVyXCIgPyAoc3RvcCAtIHN0YXJ0MikgLyBNYXRoLm1heChpbnRlcnZhbCwgMSkgOiB0aGlzLnRpY2tDb3VudDtcbiAgICAgIGkgPSBnZXRUaWNrSW50ZXJ2YWwoc3RhcnQyLCBzdG9wLCB0aWNrQ291bnQsIHRoaXMubWluVGlja0NvdW50LCB0aGlzLm1heFRpY2tDb3VudCk7XG4gICAgfVxuICAgIGlmIChpKSB7XG4gICAgICBjb25zdCBpbnRlcnZhbFJhbmdlID0gaS5yYW5nZShuZXcgRGF0ZShzdGFydDIpLCBuZXcgRGF0ZShzdG9wKSwgdHJ1ZSk7XG4gICAgICBjb25zdCBkb21haW4gPSBpc1JldmVyc2VkID8gWy4uLmludGVydmFsUmFuZ2VdLnJldmVyc2UoKSA6IGludGVydmFsUmFuZ2U7XG4gICAgICBjb25zdCBuMCA9IGRvbWFpblswXTtcbiAgICAgIGNvbnN0IG4xID0gZG9tYWluLmF0KC0xKTtcbiAgICAgIHRoaXMubmljZURvbWFpbiA9IFtuMCwgbjFdO1xuICAgIH1cbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NhbGUvb3JkaW5hbFRpbWVTY2FsZS50c1xuZnVuY3Rpb24gY29tcGFyZU51bWJlcnMoYSwgYikge1xuICByZXR1cm4gYSAtIGI7XG59XG52YXIgX09yZGluYWxUaW1lU2NhbGUgPSBjbGFzcyBfT3JkaW5hbFRpbWVTY2FsZSBleHRlbmRzIEJhbmRTY2FsZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gXCJvcmRpbmFsLXRpbWVcIjtcbiAgICB0aGlzLnRpY2tDb3VudCA9IENvbnRpbnVvdXNTY2FsZS5kZWZhdWx0VGlja0NvdW50O1xuICAgIHRoaXMubWluVGlja0NvdW50ID0gMDtcbiAgICB0aGlzLm1heFRpY2tDb3VudCA9IEluZmluaXR5O1xuICAgIHRoaXMuaW50ZXJ2YWwgPSB2b2lkIDA7XG4gICAgdGhpcy5fZG9tYWluID0gW107XG4gICAgdGhpcy50aW1lc3RhbXBzID0gW107XG4gICAgdGhpcy5zb3J0ZWRUaW1lc3RhbXBzID0gW107XG4gICAgdGhpcy52aXNpYmxlUmFuZ2UgPSBbMCwgMV07XG4gIH1cbiAgc3RhdGljIGlzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgX09yZGluYWxUaW1lU2NhbGU7XG4gIH1cbiAgc2V0VmlzaWJsZVJhbmdlKHZpc2libGVSYW5nZSkge1xuICAgIHRoaXMudmlzaWJsZVJhbmdlID0gdmlzaWJsZVJhbmdlO1xuICB9XG4gIHNldCBkb21haW4odmFsdWVzKSB7XG4gICAgdGhpcy5pbnZhbGlkID0gdHJ1ZTtcbiAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5fZG9tYWluID0gW107XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2RvbWFpbiA9IHZhbHVlcztcbiAgICB0aGlzLnRpbWVzdGFtcHMgPSB1bmlxdWUodmFsdWVzLm1hcChkYXRlVG9OdW1iZXIpKTtcbiAgICB0aGlzLnNvcnRlZFRpbWVzdGFtcHMgPSB0aGlzLnRpbWVzdGFtcHMuc2xpY2UoKS5zb3J0KGNvbXBhcmVOdW1iZXJzKTtcbiAgfVxuICBnZXQgZG9tYWluKCkge1xuICAgIHJldHVybiB0aGlzLl9kb21haW47XG4gIH1cbiAgdGlja3MoKSB7XG4gICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgY29uc3QgW3QwLCB0MV0gPSBbdGhpcy50aW1lc3RhbXBzWzBdLCB0aGlzLnRpbWVzdGFtcHMuYXQoLTEpXTtcbiAgICBjb25zdCBzdGFydDIgPSBNYXRoLm1pbih0MCwgdDEpO1xuICAgIGNvbnN0IHN0b3AgPSBNYXRoLm1heCh0MCwgdDEpO1xuICAgIGNvbnN0IGlzUmV2ZXJzZWQgPSB0MCA+IHQxO1xuICAgIGxldCB0aWNrcztcbiAgICBpZiAodGhpcy5pbnRlcnZhbCA9PSBudWxsKSB7XG4gICAgICB0aWNrcyA9IHRoaXMuZ2V0RGVmYXVsdFRpY2tzKHRoaXMubWF4VGlja0NvdW50LCBpc1JldmVyc2VkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgW3IwLCByMV0gPSB0aGlzLnJhbmdlO1xuICAgICAgY29uc3QgYXZhaWxhYmxlUmFuZ2UgPSBNYXRoLmFicyhyMSAtIHIwKTtcbiAgICAgIHRpY2tzID0gVGltZVNjYWxlLmdldFRpY2tzRm9ySW50ZXJ2YWwoeyBzdGFydDogc3RhcnQyLCBzdG9wLCBpbnRlcnZhbDogdGhpcy5pbnRlcnZhbCwgYXZhaWxhYmxlUmFuZ2UgfSkgPz8gW107XG4gICAgfVxuICAgIGNvbnN0IHRpY2tQb3NpdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHJldHVybiB0aWNrcy5maWx0ZXIoKHRpY2spID0+IHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5jb252ZXJ0KHRpY2spO1xuICAgICAgaWYgKGlzTmFOKHBvc2l0aW9uKSB8fCB0aWNrUG9zaXRpb25zLmhhcyhwb3NpdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdGlja1Bvc2l0aW9ucy5hZGQocG9zaXRpb24pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gIH1cbiAgZ2V0RGVmYXVsdFRpY2tzKG1heFRpY2tDb3VudCwgaXNSZXZlcnNlZCkge1xuICAgIGNvbnN0IHRpY2tzID0gW107XG4gICAgY29uc3QgY291bnQgPSB0aGlzLnRpbWVzdGFtcHMubGVuZ3RoO1xuICAgIGNvbnN0IHRpY2tFdmVyeSA9IE1hdGguY2VpbChjb3VudCAqICh0aGlzLnZpc2libGVSYW5nZVsxXSAtIHRoaXMudmlzaWJsZVJhbmdlWzBdKSAvIG1heFRpY2tDb3VudCk7XG4gICAgY29uc3QgdGlja09mZnNldCA9IE1hdGguZmxvb3IodGlja0V2ZXJ5IC8gMik7XG4gICAgZm9yIChjb25zdCBbaW5kZXgsIHZhbHVlXSBvZiB0aGlzLnRpbWVzdGFtcHMuZW50cmllcygpKSB7XG4gICAgICBpZiAodGlja0V2ZXJ5ID4gMCAmJiAoaW5kZXggKyB0aWNrT2Zmc2V0KSAlIHRpY2tFdmVyeSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBpZiAoaXNSZXZlcnNlZCkge1xuICAgICAgICB0aWNrcy5wdXNoKG5ldyBEYXRlKHRoaXMudGltZXN0YW1wc1tjb3VudCAtIGluZGV4IC0gMV0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpY2tzLnB1c2gobmV3IERhdGUodmFsdWUpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRpY2tzO1xuICB9XG4gIGNvbnZlcnQoZCkge1xuICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIGNvbnN0IG4gPSBOdW1iZXIoZCk7XG4gICAgaWYgKG4gPCB0aGlzLnNvcnRlZFRpbWVzdGFtcHNbMF0pIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIGxldCBpID0gdGhpcy5maW5kSW50ZXJ2YWwobik7XG4gICAgaWYgKHRoaXMudGltZXN0YW1wc1swXSAhPT0gdGhpcy5zb3J0ZWRUaW1lc3RhbXBzWzBdKSB7XG4gICAgICBpID0gdGhpcy50aW1lc3RhbXBzLmxlbmd0aCAtIGkgLSAxO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5vcmRpbmFsUmFuZ2VbaV0gPz8gTmFOO1xuICB9XG4gIGZpbmRJbnRlcnZhbCh0YXJnZXQpIHtcbiAgICBjb25zdCB7IHNvcnRlZFRpbWVzdGFtcHMgfSA9IHRoaXM7XG4gICAgbGV0IGxvdyA9IDA7XG4gICAgbGV0IGhpZ2ggPSBzb3J0ZWRUaW1lc3RhbXBzLmxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKGxvdyA8PSBoaWdoKSB7XG4gICAgICBjb25zdCBtaWQgPSBNYXRoLmZsb29yKChsb3cgKyBoaWdoKSAvIDIpO1xuICAgICAgaWYgKHNvcnRlZFRpbWVzdGFtcHNbbWlkXSA9PT0gdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBtaWQ7XG4gICAgICB9IGVsc2UgaWYgKHNvcnRlZFRpbWVzdGFtcHNbbWlkXSA8IHRhcmdldCkge1xuICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGlnaCA9IG1pZCAtIDE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsb3c7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSB0aW1lIGZvcm1hdCBmdW5jdGlvbiBzdWl0YWJsZSBmb3IgZGlzcGxheWluZyB0aWNrIHZhbHVlcy5cbiAgICogQHBhcmFtIHNwZWNpZmllciBJZiB0aGUgc3BlY2lmaWVyIHN0cmluZyBpcyBwcm92aWRlZCwgdGhpcyBtZXRob2QgaXMgZXF1aXZhbGVudCB0b1xuICAgKiB0aGUge0BsaW5rIFRpbWVMb2NhbGVPYmplY3QuZm9ybWF0fSBtZXRob2QuXG4gICAqIElmIG5vIHNwZWNpZmllciBpcyBwcm92aWRlZCwgdGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZGVmYXVsdCB0aW1lIGZvcm1hdCBmdW5jdGlvbi5cbiAgICovXG4gIHRpY2tGb3JtYXQoe1xuICAgIHRpY2tzLFxuICAgIGRvbWFpbixcbiAgICBzcGVjaWZpZXJcbiAgfSkge1xuICAgIHJldHVybiBzcGVjaWZpZXIgPT0gbnVsbCA/IGRlZmF1bHRUaW1lVGlja0Zvcm1hdCh0aWNrcywgZG9tYWluKSA6IGJ1aWxkRm9ybWF0dGVyKHNwZWNpZmllcik7XG4gIH1cbiAgaW52ZXJ0KHBvc2l0aW9uKSB7XG4gICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLm9yZGluYWxSYW5nZS5maW5kSW5kZXgoKHApID0+IHBvc2l0aW9uIDw9IHApO1xuICAgIHJldHVybiB0aGlzLmRvbWFpbltpbmRleF07XG4gIH1cbiAgaW52ZXJ0TmVhcmVzdCh5KSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHN1cGVyLmludmVydE5lYXJlc3QoeSkpO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgSW52YWxpZGF0aW5nXG5dLCBfT3JkaW5hbFRpbWVTY2FsZS5wcm90b3R5cGUsIFwidGlja0NvdW50XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgSW52YWxpZGF0aW5nXG5dLCBfT3JkaW5hbFRpbWVTY2FsZS5wcm90b3R5cGUsIFwibWluVGlja0NvdW50XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgSW52YWxpZGF0aW5nXG5dLCBfT3JkaW5hbFRpbWVTY2FsZS5wcm90b3R5cGUsIFwibWF4VGlja0NvdW50XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgSW52YWxpZGF0aW5nXG5dLCBfT3JkaW5hbFRpbWVTY2FsZS5wcm90b3R5cGUsIFwiaW50ZXJ2YWxcIiwgMik7XG52YXIgT3JkaW5hbFRpbWVTY2FsZSA9IF9PcmRpbmFsVGltZVNjYWxlO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2NvbXBhcmUudHNcbmZ1bmN0aW9uIGFzY2VuZGluZ1N0cmluZ051bWJlclVuZGVmaW5lZChhLCBiKSB7XG4gIGlmICh0eXBlb2YgYSA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgYiA9PT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiBhIC0gYjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYSA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgYiA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBhLmxvY2FsZUNvbXBhcmUoYik7XG4gIH0gZWxzZSBpZiAoYSA9PSBudWxsICYmIGIgPT0gbnVsbCkge1xuICAgIHJldHVybiAwO1xuICB9IGVsc2UgaWYgKGEgPT0gbnVsbCkge1xuICAgIHJldHVybiAtMTtcbiAgfSBlbHNlIGlmIChiID09IG51bGwpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gU3RyaW5nKGEpLmxvY2FsZUNvbXBhcmUoU3RyaW5nKGIpKTtcbn1cbmZ1bmN0aW9uIHRvTGl0ZXJhbCh2KSB7XG4gIHJldHVybiB0eXBlb2YgdiA9PT0gXCJmdW5jdGlvblwiID8gdigpIDogdjtcbn1cbmZ1bmN0aW9uIGNvbXBvdW5kQXNjZW5kaW5nKGEsIGIsIGNvbXBhcmF0b3IpIHtcbiAgZm9yIChjb25zdCBpZHggaW4gYSkge1xuICAgIGNvbnN0IGRpZmYyID0gY29tcGFyYXRvcih0b0xpdGVyYWwoYVtpZHhdKSwgdG9MaXRlcmFsKGJbaWR4XSkpO1xuICAgIGlmIChkaWZmMiAhPT0gMCkge1xuICAgICAgcmV0dXJuIGRpZmYyO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvZGVidWcudXRpbC50c1xuZnVuY3Rpb24gbm9kZUNvdW50KG5vZGUpIHtcbiAgbGV0IGNvdW50ID0gMTtcbiAgbGV0IHZpc2libGVDb3VudCA9IG5vZGUudmlzaWJsZSA/IDEgOiAwO1xuICBsZXQgZGlydHlDb3VudCA9IG5vZGUuZGlydHkgPiAwIC8qIE5PTkUgKi8gPyAxIDogMDtcbiAgZm9yIChjb25zdCBjaGlsZCBvZiBub2RlLmNoaWxkcmVuKGZhbHNlKSkge1xuICAgIGNvbnN0IGMgPSBub2RlQ291bnQoY2hpbGQpO1xuICAgIGNvdW50ICs9IGMuY291bnQ7XG4gICAgZGlydHlDb3VudCArPSBjLmRpcnR5Q291bnQ7XG4gICAgdmlzaWJsZUNvdW50ICs9IGMudmlzaWJsZUNvdW50O1xuICB9XG4gIHJldHVybiB7IGNvdW50LCB2aXNpYmxlQ291bnQsIGRpcnR5Q291bnQgfTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvbWF0cml4LnRzXG52YXIgSURFTlRJVFlfTUFUUklYX0VMRU1FTlRTID0gT2JqZWN0LmZyZWV6ZShbMSwgMCwgMCwgMSwgMCwgMF0pO1xuZnVuY3Rpb24gY2xvc2VWYWx1ZSh2YWwsIHJlZiwgZXJyb3JNYXJnaW4gPSAxZS04KSB7XG4gIHJldHVybiB2YWwgPT09IHJlZiB8fCBNYXRoLmFicyhyZWYgLSB2YWwpIDwgZXJyb3JNYXJnaW47XG59XG52YXIgX01hdHJpeCA9IGNsYXNzIF9NYXRyaXgge1xuICBnZXQgZSgpIHtcbiAgICByZXR1cm4gWy4uLnRoaXMuZWxlbWVudHNdO1xuICB9XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnRzMiA9IFsuLi5JREVOVElUWV9NQVRSSVhfRUxFTUVOVFNdKSB7XG4gICAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnRzMjtcbiAgfVxuICBzZXRFbGVtZW50cyhlbGVtZW50czIpIHtcbiAgICBjb25zdCBlID0gdGhpcy5lbGVtZW50cztcbiAgICBlWzBdID0gZWxlbWVudHMyWzBdO1xuICAgIGVbMV0gPSBlbGVtZW50czJbMV07XG4gICAgZVsyXSA9IGVsZW1lbnRzMlsyXTtcbiAgICBlWzNdID0gZWxlbWVudHMyWzNdO1xuICAgIGVbNF0gPSBlbGVtZW50czJbNF07XG4gICAgZVs1XSA9IGVsZW1lbnRzMls1XTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBnZXQgaWRlbnRpdHkoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgcmV0dXJuIGNsb3NlVmFsdWUoZVswXSwgMSkgJiYgY2xvc2VWYWx1ZShlWzFdLCAwKSAmJiBjbG9zZVZhbHVlKGVbMl0sIDApICYmIGNsb3NlVmFsdWUoZVszXSwgMSkgJiYgY2xvc2VWYWx1ZShlWzRdLCAwKSAmJiBjbG9zZVZhbHVlKGVbNV0sIDApO1xuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtcyB0aGUgQXhCIG1hdHJpeCBtdWx0aXBsaWNhdGlvbiBhbmQgc2F2ZXMgdGhlIHJlc3VsdFxuICAgKiB0byBgQ2AsIGlmIGdpdmVuLCBvciB0byBgQWAgb3RoZXJ3aXNlLlxuICAgKi9cbiAgQXhCKEEsIEIsIEMpIHtcbiAgICBjb25zdCBhID0gQVswXSAqIEJbMF0gKyBBWzJdICogQlsxXSwgYiA9IEFbMV0gKiBCWzBdICsgQVszXSAqIEJbMV0sIGMgPSBBWzBdICogQlsyXSArIEFbMl0gKiBCWzNdLCBkID0gQVsxXSAqIEJbMl0gKyBBWzNdICogQlszXSwgZSA9IEFbMF0gKiBCWzRdICsgQVsyXSAqIEJbNV0gKyBBWzRdLCBmID0gQVsxXSAqIEJbNF0gKyBBWzNdICogQls1XSArIEFbNV07XG4gICAgQyA9IEMgPz8gQTtcbiAgICBDWzBdID0gYTtcbiAgICBDWzFdID0gYjtcbiAgICBDWzJdID0gYztcbiAgICBDWzNdID0gZDtcbiAgICBDWzRdID0gZTtcbiAgICBDWzVdID0gZjtcbiAgfVxuICAvKipcbiAgICogVGhlIGBvdGhlcmAgbWF0cml4IGdldHMgcG9zdC1tdWx0aXBsaWVkIHRvIHRoZSBjdXJyZW50IG1hdHJpeC5cbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBtYXRyaXguXG4gICAqIEBwYXJhbSBvdGhlclxuICAgKi9cbiAgbXVsdGlwbHlTZWxmKG90aGVyKSB7XG4gICAgdGhpcy5BeEIodGhpcy5lbGVtZW50cywgb3RoZXIuZWxlbWVudHMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYG90aGVyYCBtYXRyaXggZ2V0cyBwb3N0LW11bHRpcGxpZWQgdG8gdGhlIGN1cnJlbnQgbWF0cml4LlxuICAgKiBSZXR1cm5zIGEgbmV3IG1hdHJpeC5cbiAgICogQHBhcmFtIG90aGVyXG4gICAqL1xuICBtdWx0aXBseShvdGhlcikge1xuICAgIGNvbnN0IGVsZW1lbnRzMiA9IG5ldyBBcnJheSg2KTtcbiAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBfTWF0cml4KSB7XG4gICAgICB0aGlzLkF4Qih0aGlzLmVsZW1lbnRzLCBvdGhlci5lbGVtZW50cywgZWxlbWVudHMyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5BeEIodGhpcy5lbGVtZW50cywgW290aGVyLmEsIG90aGVyLmIsIG90aGVyLmMsIG90aGVyLmQsIG90aGVyLmUsIG90aGVyLmZdLCBlbGVtZW50czIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IF9NYXRyaXgoZWxlbWVudHMyKTtcbiAgfVxuICBwcmVNdWx0aXBseVNlbGYob3RoZXIpIHtcbiAgICB0aGlzLkF4QihvdGhlci5lbGVtZW50cywgdGhpcy5lbGVtZW50cywgdGhpcy5lbGVtZW50cyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhpcyBtYXRyaXggYXMgYSBuZXcgbWF0cml4LlxuICAgKi9cbiAgaW52ZXJzZSgpIHtcbiAgICBjb25zdCBlbCA9IHRoaXMuZWxlbWVudHM7XG4gICAgbGV0IGEgPSBlbFswXSwgYiA9IGVsWzFdLCBjID0gZWxbMl0sIGQgPSBlbFszXTtcbiAgICBjb25zdCBlID0gZWxbNF0sIGYgPSBlbFs1XTtcbiAgICBjb25zdCByRCA9IDEgLyAoYSAqIGQgLSBiICogYyk7XG4gICAgYSAqPSByRDtcbiAgICBiICo9IHJEO1xuICAgIGMgKj0gckQ7XG4gICAgZCAqPSByRDtcbiAgICByZXR1cm4gbmV3IF9NYXRyaXgoW2QsIC1iLCAtYywgYSwgYyAqIGYgLSBkICogZSwgYiAqIGUgLSBhICogZl0pO1xuICB9XG4gIC8qKlxuICAgKiBTYXZlIHRoZSBpbnZlcnNlIG9mIHRoaXMgbWF0cml4IHRvIHRoZSBnaXZlbiBtYXRyaXguXG4gICAqL1xuICBpbnZlcnNlVG8ob3RoZXIpIHtcbiAgICBjb25zdCBlbCA9IHRoaXMuZWxlbWVudHM7XG4gICAgbGV0IGEgPSBlbFswXSwgYiA9IGVsWzFdLCBjID0gZWxbMl0sIGQgPSBlbFszXTtcbiAgICBjb25zdCBlID0gZWxbNF0sIGYgPSBlbFs1XTtcbiAgICBjb25zdCByRCA9IDEgLyAoYSAqIGQgLSBiICogYyk7XG4gICAgYSAqPSByRDtcbiAgICBiICo9IHJEO1xuICAgIGMgKj0gckQ7XG4gICAgZCAqPSByRDtcbiAgICBvdGhlci5zZXRFbGVtZW50cyhbZCwgLWIsIC1jLCBhLCBjICogZiAtIGQgKiBlLCBiICogZSAtIGEgKiBmXSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaW52ZXJ0U2VsZigpIHtcbiAgICBjb25zdCBlbCA9IHRoaXMuZWxlbWVudHM7XG4gICAgbGV0IGEgPSBlbFswXSwgYiA9IGVsWzFdLCBjID0gZWxbMl0sIGQgPSBlbFszXTtcbiAgICBjb25zdCBlID0gZWxbNF0sIGYgPSBlbFs1XTtcbiAgICBjb25zdCByRCA9IDEgLyAoYSAqIGQgLSBiICogYyk7XG4gICAgYSAqPSByRDtcbiAgICBiICo9IHJEO1xuICAgIGMgKj0gckQ7XG4gICAgZCAqPSByRDtcbiAgICBlbFswXSA9IGQ7XG4gICAgZWxbMV0gPSAtYjtcbiAgICBlbFsyXSA9IC1jO1xuICAgIGVsWzNdID0gYTtcbiAgICBlbFs0XSA9IGMgKiBmIC0gZCAqIGU7XG4gICAgZWxbNV0gPSBiICogZSAtIGEgKiBmO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRyYW5zZm9ybVBvaW50KHgsIHkpIHtcbiAgICBjb25zdCBlID0gdGhpcy5lbGVtZW50cztcbiAgICByZXR1cm4ge1xuICAgICAgeDogeCAqIGVbMF0gKyB5ICogZVsyXSArIGVbNF0sXG4gICAgICB5OiB4ICogZVsxXSArIHkgKiBlWzNdICsgZVs1XVxuICAgIH07XG4gIH1cbiAgdHJhbnNmb3JtQkJveChiYm94LCB0YXJnZXQpIHtcbiAgICBjb25zdCBlbCA9IHRoaXMuZWxlbWVudHM7XG4gICAgY29uc3QgeHggPSBlbFswXTtcbiAgICBjb25zdCB4eSA9IGVsWzFdO1xuICAgIGNvbnN0IHl4ID0gZWxbMl07XG4gICAgY29uc3QgeXkgPSBlbFszXTtcbiAgICBjb25zdCBoX3cgPSBiYm94LndpZHRoICogMC41O1xuICAgIGNvbnN0IGhfaCA9IGJib3guaGVpZ2h0ICogMC41O1xuICAgIGNvbnN0IGN4ID0gYmJveC54ICsgaF93O1xuICAgIGNvbnN0IGN5ID0gYmJveC55ICsgaF9oO1xuICAgIGNvbnN0IHcgPSBNYXRoLmFicyhoX3cgKiB4eCkgKyBNYXRoLmFicyhoX2ggKiB5eCk7XG4gICAgY29uc3QgaCA9IE1hdGguYWJzKGhfdyAqIHh5KSArIE1hdGguYWJzKGhfaCAqIHl5KTtcbiAgICB0YXJnZXQgPz8gKHRhcmdldCA9IG5ldyBCQm94KDAsIDAsIDAsIDApKTtcbiAgICB0YXJnZXQueCA9IGN4ICogeHggKyBjeSAqIHl4ICsgZWxbNF0gLSB3O1xuICAgIHRhcmdldC55ID0gY3ggKiB4eSArIGN5ICogeXkgKyBlbFs1XSAtIGg7XG4gICAgdGFyZ2V0LndpZHRoID0gdyArIHc7XG4gICAgdGFyZ2V0LmhlaWdodCA9IGggKyBoO1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgdG9Db250ZXh0KGN0eCkge1xuICAgIGlmICh0aGlzLmlkZW50aXR5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgIGN0eC50cmFuc2Zvcm0oZVswXSwgZVsxXSwgZVsyXSwgZVszXSwgZVs0XSwgZVs1XSk7XG4gIH1cbiAgc3RhdGljIGZseXdlaWdodChzb3VyY2VNYXRyaXgpIHtcbiAgICByZXR1cm4gX01hdHJpeC5pbnN0YW5jZS5zZXRFbGVtZW50cyhzb3VyY2VNYXRyaXguZWxlbWVudHMpO1xuICB9XG4gIHN0YXRpYyB1cGRhdGVUcmFuc2Zvcm1NYXRyaXgobWF0cml4LCBzY2FsaW5nWCwgc2NhbGluZ1ksIHJvdGF0aW9uLCB0cmFuc2xhdGlvblgsIHRyYW5zbGF0aW9uWSwgb3B0cykge1xuICAgIGNvbnN0IHN4ID0gc2NhbGluZ1g7XG4gICAgY29uc3Qgc3kgPSBzY2FsaW5nWTtcbiAgICBsZXQgc2N4O1xuICAgIGxldCBzY3k7XG4gICAgaWYgKHN4ID09PSAxICYmIHN5ID09PSAxKSB7XG4gICAgICBzY3ggPSAwO1xuICAgICAgc2N5ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgc2N4ID0gb3B0cz8uc2NhbGluZ0NlbnRlclggPz8gMDtcbiAgICAgIHNjeSA9IG9wdHM/LnNjYWxpbmdDZW50ZXJZID8/IDA7XG4gICAgfVxuICAgIGNvbnN0IHIgPSByb3RhdGlvbjtcbiAgICBjb25zdCBjb3MgPSBNYXRoLmNvcyhyKTtcbiAgICBjb25zdCBzaW4gPSBNYXRoLnNpbihyKTtcbiAgICBsZXQgcmN4O1xuICAgIGxldCByY3k7XG4gICAgaWYgKHIgPT09IDApIHtcbiAgICAgIHJjeCA9IDA7XG4gICAgICByY3kgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICByY3ggPSBvcHRzPy5yb3RhdGlvbkNlbnRlclggPz8gMDtcbiAgICAgIHJjeSA9IG9wdHM/LnJvdGF0aW9uQ2VudGVyWSA/PyAwO1xuICAgIH1cbiAgICBjb25zdCB0eCA9IHRyYW5zbGF0aW9uWDtcbiAgICBjb25zdCB0eSA9IHRyYW5zbGF0aW9uWTtcbiAgICBjb25zdCB0eDQgPSBzY3ggKiAoMSAtIHN4KSAtIHJjeDtcbiAgICBjb25zdCB0eTQgPSBzY3kgKiAoMSAtIHN5KSAtIHJjeTtcbiAgICBtYXRyaXguc2V0RWxlbWVudHMoW1xuICAgICAgY29zICogc3gsXG4gICAgICBzaW4gKiBzeCxcbiAgICAgIC1zaW4gKiBzeSxcbiAgICAgIGNvcyAqIHN5LFxuICAgICAgY29zICogdHg0IC0gc2luICogdHk0ICsgcmN4ICsgdHgsXG4gICAgICBzaW4gKiB0eDQgKyBjb3MgKiB0eTQgKyByY3kgKyB0eVxuICAgIF0pO1xuICAgIHJldHVybiBtYXRyaXg7XG4gIH1cbiAgc3RhdGljIGZyb21Db250ZXh0KGN0eCkge1xuICAgIGNvbnN0IGRvbU1hdHJpeCA9IGN0eC5nZXRUcmFuc2Zvcm0oKTtcbiAgICByZXR1cm4gbmV3IF9NYXRyaXgoW2RvbU1hdHJpeC5hLCBkb21NYXRyaXguYiwgZG9tTWF0cml4LmMsIGRvbU1hdHJpeC5kLCBkb21NYXRyaXguZSwgZG9tTWF0cml4LmZdKTtcbiAgfVxufTtcbl9NYXRyaXguaW5zdGFuY2UgPSBuZXcgX01hdHJpeCgpO1xudmFyIE1hdHJpeCA9IF9NYXRyaXg7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL3RyYW5zZm9ybWFibGUudHNcbmZ1bmN0aW9uIGlzTWF0cml4VHJhbnNmb3JtKG5vZGUpIHtcbiAgcmV0dXJuIGlzTWF0cml4VHJhbnNmb3JtVHlwZShub2RlLmNvbnN0cnVjdG9yKTtcbn1cbnZhciBNQVRSSVhfVFJBTlNGT1JNX1RZUEUgPSBTeW1ib2woXCJpc01hdHJpeFRyYW5zZm9ybVwiKTtcbmZ1bmN0aW9uIGlzTWF0cml4VHJhbnNmb3JtVHlwZShjc3RyKSB7XG4gIHJldHVybiBjc3RyW01BVFJJWF9UUkFOU0ZPUk1fVFlQRV0gPT09IHRydWU7XG59XG5mdW5jdGlvbiBNYXRyaXhUcmFuc2Zvcm0oUGFyZW50KSB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IFBhcmVudE5vZGUgPSBQYXJlbnQ7XG4gIGlmIChpc01hdHJpeFRyYW5zZm9ybVR5cGUoUGFyZW50KSkge1xuICAgIHJldHVybiBQYXJlbnQ7XG4gIH1cbiAgY29uc3QgVFJBTlNGT1JNX01BVFJJWCA9IFN5bWJvbChcIm1hdHJpeF9jb21iaW5lZF90cmFuc2Zvcm1cIik7XG4gIGNsYXNzIE1hdHJpeFRyYW5zZm9ybUludGVybmFsIGV4dGVuZHMgUGFyZW50Tm9kZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgdGhpc1tfYl0gPSBuZXcgTWF0cml4KCk7XG4gICAgICB0aGlzLl9kaXJ0eVRyYW5zZm9ybSA9IHRydWU7XG4gICAgfVxuICAgIG1hcmtEaXJ0eVRyYW5zZm9ybSgpIHtcbiAgICAgIHRoaXMuX2RpcnR5VHJhbnNmb3JtID0gdHJ1ZTtcbiAgICAgIHN1cGVyLm1hcmtEaXJ0eSgzIC8qIE1BSk9SICovKTtcbiAgICB9XG4gICAgdXBkYXRlTWF0cml4KF9tYXRyaXgpIHtcbiAgICB9XG4gICAgY29tcHV0ZVRyYW5zZm9ybU1hdHJpeCgpIHtcbiAgICAgIGlmICghdGhpcy5fZGlydHlUcmFuc2Zvcm0pXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXNbVFJBTlNGT1JNX01BVFJJWF0uc2V0RWxlbWVudHMoSURFTlRJVFlfTUFUUklYX0VMRU1FTlRTKTtcbiAgICAgIHRoaXMudXBkYXRlTWF0cml4KHRoaXNbVFJBTlNGT1JNX01BVFJJWF0pO1xuICAgICAgdGhpcy5fZGlydHlUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgICB9XG4gICAgdG9QYXJlbnQoYmJveCkge1xuICAgICAgdGhpcy5jb21wdXRlVHJhbnNmb3JtTWF0cml4KCk7XG4gICAgICBpZiAodGhpc1tUUkFOU0ZPUk1fTUFUUklYXS5pZGVudGl0eSlcbiAgICAgICAgcmV0dXJuIGJib3guY2xvbmUoKTtcbiAgICAgIHJldHVybiB0aGlzW1RSQU5TRk9STV9NQVRSSVhdLnRyYW5zZm9ybUJCb3goYmJveCk7XG4gICAgfVxuICAgIHRvUGFyZW50UG9pbnQoeCwgeSkge1xuICAgICAgdGhpcy5jb21wdXRlVHJhbnNmb3JtTWF0cml4KCk7XG4gICAgICBpZiAodGhpc1tUUkFOU0ZPUk1fTUFUUklYXS5pZGVudGl0eSlcbiAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgICAgcmV0dXJuIHRoaXNbVFJBTlNGT1JNX01BVFJJWF0udHJhbnNmb3JtUG9pbnQoeCwgeSk7XG4gICAgfVxuICAgIGZyb21QYXJlbnQoYmJveCkge1xuICAgICAgdGhpcy5jb21wdXRlVHJhbnNmb3JtTWF0cml4KCk7XG4gICAgICBpZiAodGhpc1tUUkFOU0ZPUk1fTUFUUklYXS5pZGVudGl0eSlcbiAgICAgICAgcmV0dXJuIGJib3guY2xvbmUoKTtcbiAgICAgIHJldHVybiB0aGlzW1RSQU5TRk9STV9NQVRSSVhdLmludmVyc2UoKS50cmFuc2Zvcm1CQm94KGJib3gpO1xuICAgIH1cbiAgICBmcm9tUGFyZW50UG9pbnQoeCwgeSkge1xuICAgICAgdGhpcy5jb21wdXRlVHJhbnNmb3JtTWF0cml4KCk7XG4gICAgICBpZiAodGhpc1tUUkFOU0ZPUk1fTUFUUklYXS5pZGVudGl0eSlcbiAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgICAgcmV0dXJuIHRoaXNbVFJBTlNGT1JNX01BVFJJWF0uaW52ZXJzZSgpLnRyYW5zZm9ybVBvaW50KHgsIHkpO1xuICAgIH1cbiAgICBjb21wdXRlQkJveCgpIHtcbiAgICAgIGNvbnN0IGJib3ggPSBzdXBlci5jb21wdXRlQkJveCgpO1xuICAgICAgaWYgKCFiYm94KVxuICAgICAgICByZXR1cm4gYmJveDtcbiAgICAgIHJldHVybiB0aGlzLnRvUGFyZW50KGJib3gpO1xuICAgIH1cbiAgICBjb21wdXRlQkJveFdpdGhvdXRUcmFuc2Zvcm1zKCkge1xuICAgICAgcmV0dXJuIHN1cGVyLmNvbXB1dGVCQm94KCk7XG4gICAgfVxuICAgIHBpY2tOb2RlKHgsIHksIGxvY2FsQ29vcmRzID0gZmFsc2UpIHtcbiAgICAgIGlmICghbG9jYWxDb29yZHMpIHtcbiAgICAgICAgKHsgeCwgeSB9ID0gdGhpcy5mcm9tUGFyZW50UG9pbnQoeCwgeSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN1cGVyLnBpY2tOb2RlKHgsIHkpO1xuICAgIH1cbiAgICByZW5kZXIocmVuZGVyQ3R4KSB7XG4gICAgICBpZiAodGhpcy5fZGlydHlUcmFuc2Zvcm0pIHtcbiAgICAgICAgdGhpcy5jb21wdXRlVHJhbnNmb3JtTWF0cml4KCk7XG4gICAgICAgIGlmICghcmVuZGVyQ3R4LmZvcmNlUmVuZGVyKSB7XG4gICAgICAgICAgcmVuZGVyQ3R4ID0geyAuLi5yZW5kZXJDdHgsIGZvcmNlUmVuZGVyOiBcImRpcnR5VHJhbnNmb3JtXCIgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgbWF0cml4ID0gdGhpc1tUUkFOU0ZPUk1fTUFUUklYXTtcbiAgICAgIGxldCBwZXJmb3JtUmVzdG9yZSA9IGZhbHNlO1xuICAgICAgaWYgKCFtYXRyaXguaWRlbnRpdHkpIHtcbiAgICAgICAgcmVuZGVyQ3R4LmN0eC5zYXZlKCk7XG4gICAgICAgIHBlcmZvcm1SZXN0b3JlID0gdHJ1ZTtcbiAgICAgICAgbWF0cml4LnRvQ29udGV4dChyZW5kZXJDdHguY3R4KTtcbiAgICAgIH1cbiAgICAgIHN1cGVyLnJlbmRlcihyZW5kZXJDdHgpO1xuICAgICAgaWYgKHBlcmZvcm1SZXN0b3JlKSB7XG4gICAgICAgIHJlbmRlckN0eC5jdHgucmVzdG9yZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0b1NWRygpIHtcbiAgICAgIGNvbnN0IHN2ZyA9IHN1cGVyLnRvU1ZHKCk7XG4gICAgICBjb25zdCBtYXRyaXggPSB0aGlzW1RSQU5TRk9STV9NQVRSSVhdO1xuICAgICAgaWYgKG1hdHJpeC5pZGVudGl0eSB8fCBzdmcgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIHN2ZztcbiAgICAgIGNvbnN0IGcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcImdcIik7XG4gICAgICBnLmFwcGVuZCguLi5zdmcuZWxlbWVudHMpO1xuICAgICAgY29uc3QgW2EsIGIsIGMsIGQsIGUsIGZdID0gbWF0cml4LmU7XG4gICAgICBnLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCBgbWF0cml4KCR7YX0gJHtifSAke2N9ICR7ZH0gJHtlfSAke2Z9KWApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZWxlbWVudHM6IFtnXSxcbiAgICAgICAgZGVmczogc3ZnLmRlZnNcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIF9hID0gTUFUUklYX1RSQU5TRk9STV9UWVBFLCBfYiA9IFRSQU5TRk9STV9NQVRSSVg7XG4gIE1hdHJpeFRyYW5zZm9ybUludGVybmFsW19hXSA9IHRydWU7XG4gIHJldHVybiBNYXRyaXhUcmFuc2Zvcm1JbnRlcm5hbDtcbn1cbmZ1bmN0aW9uIFJvdGF0YWJsZShQYXJlbnQpIHtcbiAgdmFyIF9hO1xuICBjb25zdCBQYXJlbnROb2RlID0gUGFyZW50O1xuICBjb25zdCBST1RBVEFCTEVfTUFUUklYID0gU3ltYm9sKFwibWF0cml4X3JvdGF0aW9uXCIpO1xuICBjbGFzcyBSb3RhdGFibGVJbnRlcm5hbCBleHRlbmRzIE1hdHJpeFRyYW5zZm9ybShQYXJlbnROb2RlKSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgdGhpc1tfYV0gPSBuZXcgTWF0cml4KCk7XG4gICAgICB0aGlzLnJvdGF0aW9uQ2VudGVyWCA9IG51bGw7XG4gICAgICB0aGlzLnJvdGF0aW9uQ2VudGVyWSA9IG51bGw7XG4gICAgICB0aGlzLnJvdGF0aW9uID0gMDtcbiAgICB9XG4gICAgdXBkYXRlTWF0cml4KG1hdHJpeCkge1xuICAgICAgc3VwZXIudXBkYXRlTWF0cml4KG1hdHJpeCk7XG4gICAgICBjb25zdCB7IHJvdGF0aW9uLCByb3RhdGlvbkNlbnRlclgsIHJvdGF0aW9uQ2VudGVyWSB9ID0gdGhpcztcbiAgICAgIGlmIChyb3RhdGlvbiA9PT0gMClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgTWF0cml4LnVwZGF0ZVRyYW5zZm9ybU1hdHJpeCh0aGlzW1JPVEFUQUJMRV9NQVRSSVhdLCAxLCAxLCByb3RhdGlvbiwgMCwgMCwge1xuICAgICAgICByb3RhdGlvbkNlbnRlclgsXG4gICAgICAgIHJvdGF0aW9uQ2VudGVyWVxuICAgICAgfSk7XG4gICAgICBtYXRyaXgubXVsdGlwbHlTZWxmKHRoaXNbUk9UQVRBQkxFX01BVFJJWF0pO1xuICAgIH1cbiAgfVxuICBfYSA9IFJPVEFUQUJMRV9NQVRSSVg7XG4gIF9fZGVjb3JhdGVDbGFzcyhbXG4gICAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyB0eXBlOiBcInRyYW5zZm9ybVwiIH0pXG4gIF0sIFJvdGF0YWJsZUludGVybmFsLnByb3RvdHlwZSwgXCJyb3RhdGlvbkNlbnRlclhcIiwgMik7XG4gIF9fZGVjb3JhdGVDbGFzcyhbXG4gICAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyB0eXBlOiBcInRyYW5zZm9ybVwiIH0pXG4gIF0sIFJvdGF0YWJsZUludGVybmFsLnByb3RvdHlwZSwgXCJyb3RhdGlvbkNlbnRlcllcIiwgMik7XG4gIF9fZGVjb3JhdGVDbGFzcyhbXG4gICAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyB0eXBlOiBcInRyYW5zZm9ybVwiIH0pXG4gIF0sIFJvdGF0YWJsZUludGVybmFsLnByb3RvdHlwZSwgXCJyb3RhdGlvblwiLCAyKTtcbiAgcmV0dXJuIFJvdGF0YWJsZUludGVybmFsO1xufVxuZnVuY3Rpb24gU2NhbGFibGUoUGFyZW50KSB7XG4gIHZhciBfYTtcbiAgY29uc3QgUGFyZW50Tm9kZSA9IFBhcmVudDtcbiAgY29uc3QgU0NBTEFCTEVfTUFUUklYID0gU3ltYm9sKFwibWF0cml4X3NjYWxlXCIpO1xuICBjbGFzcyBTY2FsYWJsZUludGVybmFsIGV4dGVuZHMgTWF0cml4VHJhbnNmb3JtKFBhcmVudE5vZGUpIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICB0aGlzW19hXSA9IG5ldyBNYXRyaXgoKTtcbiAgICAgIHRoaXMuc2NhbGluZ1ggPSAxO1xuICAgICAgdGhpcy5zY2FsaW5nWSA9IDE7XG4gICAgICB0aGlzLnNjYWxpbmdDZW50ZXJYID0gbnVsbDtcbiAgICAgIHRoaXMuc2NhbGluZ0NlbnRlclkgPSBudWxsO1xuICAgIH1cbiAgICB1cGRhdGVNYXRyaXgobWF0cml4KSB7XG4gICAgICBzdXBlci51cGRhdGVNYXRyaXgobWF0cml4KTtcbiAgICAgIGNvbnN0IHsgc2NhbGluZ1gsIHNjYWxpbmdZLCBzY2FsaW5nQ2VudGVyWCwgc2NhbGluZ0NlbnRlclkgfSA9IHRoaXM7XG4gICAgICBpZiAoc2NhbGluZ1ggPT09IDEgJiYgc2NhbGluZ1kgPT09IDEpXG4gICAgICAgIHJldHVybjtcbiAgICAgIE1hdHJpeC51cGRhdGVUcmFuc2Zvcm1NYXRyaXgodGhpc1tTQ0FMQUJMRV9NQVRSSVhdLCBzY2FsaW5nWCwgc2NhbGluZ1ksIDAsIDAsIDAsIHtcbiAgICAgICAgc2NhbGluZ0NlbnRlclgsXG4gICAgICAgIHNjYWxpbmdDZW50ZXJZXG4gICAgICB9KTtcbiAgICAgIG1hdHJpeC5tdWx0aXBseVNlbGYodGhpc1tTQ0FMQUJMRV9NQVRSSVhdKTtcbiAgICB9XG4gIH1cbiAgX2EgPSBTQ0FMQUJMRV9NQVRSSVg7XG4gIF9fZGVjb3JhdGVDbGFzcyhbXG4gICAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyB0eXBlOiBcInRyYW5zZm9ybVwiIH0pXG4gIF0sIFNjYWxhYmxlSW50ZXJuYWwucHJvdG90eXBlLCBcInNjYWxpbmdYXCIsIDIpO1xuICBfX2RlY29yYXRlQ2xhc3MoW1xuICAgIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgdHlwZTogXCJ0cmFuc2Zvcm1cIiB9KVxuICBdLCBTY2FsYWJsZUludGVybmFsLnByb3RvdHlwZSwgXCJzY2FsaW5nWVwiLCAyKTtcbiAgX19kZWNvcmF0ZUNsYXNzKFtcbiAgICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHR5cGU6IFwidHJhbnNmb3JtXCIgfSlcbiAgXSwgU2NhbGFibGVJbnRlcm5hbC5wcm90b3R5cGUsIFwic2NhbGluZ0NlbnRlclhcIiwgMik7XG4gIF9fZGVjb3JhdGVDbGFzcyhbXG4gICAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyB0eXBlOiBcInRyYW5zZm9ybVwiIH0pXG4gIF0sIFNjYWxhYmxlSW50ZXJuYWwucHJvdG90eXBlLCBcInNjYWxpbmdDZW50ZXJZXCIsIDIpO1xuICByZXR1cm4gU2NhbGFibGVJbnRlcm5hbDtcbn1cbmZ1bmN0aW9uIFRyYW5zbGF0YWJsZShQYXJlbnQpIHtcbiAgdmFyIF9hO1xuICBjb25zdCBQYXJlbnROb2RlID0gUGFyZW50O1xuICBjb25zdCBUUkFOU0xBVEFCTEVfTUFUUklYID0gU3ltYm9sKFwibWF0cml4X3RyYW5zbGF0aW9uXCIpO1xuICBjbGFzcyBUcmFuc2xhdGFibGVJbnRlcm5hbCBleHRlbmRzIE1hdHJpeFRyYW5zZm9ybShQYXJlbnROb2RlKSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgdGhpc1tfYV0gPSBuZXcgTWF0cml4KCk7XG4gICAgICB0aGlzLnRyYW5zbGF0aW9uWCA9IDA7XG4gICAgICB0aGlzLnRyYW5zbGF0aW9uWSA9IDA7XG4gICAgfVxuICAgIHVwZGF0ZU1hdHJpeChtYXRyaXgpIHtcbiAgICAgIHN1cGVyLnVwZGF0ZU1hdHJpeChtYXRyaXgpO1xuICAgICAgY29uc3QgeyB0cmFuc2xhdGlvblgsIHRyYW5zbGF0aW9uWSB9ID0gdGhpcztcbiAgICAgIGlmICh0cmFuc2xhdGlvblggPT09IDAgJiYgdHJhbnNsYXRpb25ZID09PSAwKVxuICAgICAgICByZXR1cm47XG4gICAgICBNYXRyaXgudXBkYXRlVHJhbnNmb3JtTWF0cml4KHRoaXNbVFJBTlNMQVRBQkxFX01BVFJJWF0sIDEsIDEsIDAsIHRyYW5zbGF0aW9uWCwgdHJhbnNsYXRpb25ZKTtcbiAgICAgIG1hdHJpeC5tdWx0aXBseVNlbGYodGhpc1tUUkFOU0xBVEFCTEVfTUFUUklYXSk7XG4gICAgfVxuICB9XG4gIF9hID0gVFJBTlNMQVRBQkxFX01BVFJJWDtcbiAgX19kZWNvcmF0ZUNsYXNzKFtcbiAgICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHR5cGU6IFwidHJhbnNmb3JtXCIgfSlcbiAgXSwgVHJhbnNsYXRhYmxlSW50ZXJuYWwucHJvdG90eXBlLCBcInRyYW5zbGF0aW9uWFwiLCAyKTtcbiAgX19kZWNvcmF0ZUNsYXNzKFtcbiAgICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHR5cGU6IFwidHJhbnNmb3JtXCIgfSlcbiAgXSwgVHJhbnNsYXRhYmxlSW50ZXJuYWwucHJvdG90eXBlLCBcInRyYW5zbGF0aW9uWVwiLCAyKTtcbiAgcmV0dXJuIFRyYW5zbGF0YWJsZUludGVybmFsO1xufVxudmFyIFRyYW5zZm9ybWFibGUgPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIEJCb3ggZnJvbSBjYW52YXMgY29vcmRpbmF0ZSBzcGFjZSBpbnRvIHRoZSBjb29yZGluYXRlIHNwYWNlIG9mIHRoZSBnaXZlbiBOb2RlLlxuICAgKi9cbiAgc3RhdGljIGZyb21DYW52YXMobm9kZSwgYmJveCkge1xuICAgIGNvbnN0IHBhcmVudHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHBhcmVudCBvZiBub2RlLnRyYXZlcnNlVXAoKSkge1xuICAgICAgaWYgKGlzTWF0cml4VHJhbnNmb3JtKHBhcmVudCkpIHtcbiAgICAgICAgcGFyZW50cy51bnNoaWZ0KHBhcmVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgcGFyZW50IG9mIHBhcmVudHMpIHtcbiAgICAgIGJib3ggPSBwYXJlbnQuZnJvbVBhcmVudChiYm94KTtcbiAgICB9XG4gICAgaWYgKGlzTWF0cml4VHJhbnNmb3JtKG5vZGUpKSB7XG4gICAgICBiYm94ID0gbm9kZS5mcm9tUGFyZW50KGJib3gpO1xuICAgIH1cbiAgICByZXR1cm4gYmJveDtcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgYSBOb2RlcyBCQm94IChvciBhbiBhcmJpdHJhcnkgQkJveCBpZiBzdXBwbGllZCkgZnJvbSBsb2NhbCBOb2RlIGNvb3JkaW5hdGUgc3BhY2VcbiAgICogaW50byB0aGUgQ2FudmFzIGNvb3JkaW5hdGUgc3BhY2UuXG4gICAqL1xuICBzdGF0aWMgdG9DYW52YXMobm9kZSwgYmJveCkge1xuICAgIGlmIChiYm94ID09IG51bGwpIHtcbiAgICAgIGJib3ggPSBub2RlLmdldEJCb3goKTtcbiAgICB9IGVsc2UgaWYgKGlzTWF0cml4VHJhbnNmb3JtKG5vZGUpKSB7XG4gICAgICBiYm94ID0gbm9kZS50b1BhcmVudChiYm94KTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBwYXJlbnQgb2Ygbm9kZS50cmF2ZXJzZVVwKCkpIHtcbiAgICAgIGlmIChpc01hdHJpeFRyYW5zZm9ybShwYXJlbnQpKSB7XG4gICAgICAgIGJib3ggPSBwYXJlbnQudG9QYXJlbnQoYmJveCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBiYm94O1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIHBvaW50IGZyb20gY2FudmFzIGNvb3JkaW5hdGUgc3BhY2UgaW50byB0aGUgY29vcmRpbmF0ZSBzcGFjZSBvZiB0aGUgZ2l2ZW4gTm9kZS5cbiAgICovXG4gIHN0YXRpYyBmcm9tQ2FudmFzUG9pbnQobm9kZSwgeCwgeSkge1xuICAgIGNvbnN0IHBhcmVudHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHBhcmVudCBvZiBub2RlLnRyYXZlcnNlVXAoKSkge1xuICAgICAgaWYgKGlzTWF0cml4VHJhbnNmb3JtKHBhcmVudCkpIHtcbiAgICAgICAgcGFyZW50cy51bnNoaWZ0KHBhcmVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgcGFyZW50IG9mIHBhcmVudHMpIHtcbiAgICAgICh7IHgsIHkgfSA9IHBhcmVudC5mcm9tUGFyZW50UG9pbnQoeCwgeSkpO1xuICAgIH1cbiAgICBpZiAoaXNNYXRyaXhUcmFuc2Zvcm0obm9kZSkpIHtcbiAgICAgICh7IHgsIHkgfSA9IG5vZGUuZnJvbVBhcmVudFBvaW50KHgsIHkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgeCwgeSB9O1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIHBvaW50IGZyb20gYSBOb2RlcyBsb2NhbCBjb29yZGluYXRlIHNwYWNlIGludG8gdGhlIENhbnZhcyBjb29yZGluYXRlIHNwYWNlLlxuICAgKi9cbiAgc3RhdGljIHRvQ2FudmFzUG9pbnQobm9kZSwgeCwgeSkge1xuICAgIGlmIChpc01hdHJpeFRyYW5zZm9ybShub2RlKSkge1xuICAgICAgKHsgeCwgeSB9ID0gbm9kZS50b1BhcmVudFBvaW50KHgsIHkpKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBwYXJlbnQgb2Ygbm9kZS50cmF2ZXJzZVVwKCkpIHtcbiAgICAgIGlmIChpc01hdHJpeFRyYW5zZm9ybShwYXJlbnQpKSB7XG4gICAgICAgICh7IHgsIHkgfSA9IHBhcmVudC50b1BhcmVudFBvaW50KHgsIHkpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgeCwgeSB9O1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9ncm91cC50c1xudmFyIF9Hcm91cCA9IGNsYXNzIF9Hcm91cCBleHRlbmRzIE5vZGUge1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgc3VwZXIob3B0cyk7XG4gICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICB0aGlzLm9wYWNpdHkgPSAxO1xuICAgIHRoaXMuaXNDb250YWluZXJOb2RlID0gdHJ1ZTtcbiAgICB0aGlzLnpJbmRleFN1Yk9yZGVyID0gb3B0cz8uekluZGV4U3ViT3JkZXI7XG4gIH1cbiAgc3RhdGljIGlzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgX0dyb3VwO1xuICB9XG4gIHN0YXRpYyBjb21wdXRlQ2hpbGRyZW5CQm94KG5vZGVzLCBza2lwSW52aXNpYmxlID0gdHJ1ZSkge1xuICAgIHJldHVybiBCQm94Lm1lcmdlKE5vZGUuZXh0cmFjdEJCb3hlcyhub2Rlcywgc2tpcEludmlzaWJsZSkpO1xuICB9XG4gIHN0YXRpYyBjb21wYXJlQ2hpbGRyZW4oYSwgYikge1xuICAgIHJldHVybiBjb21wb3VuZEFzY2VuZGluZyhcbiAgICAgIFthLnpJbmRleCwgLi4uYS56SW5kZXhTdWJPcmRlciA/PyBbdm9pZCAwLCB2b2lkIDBdLCBhLnNlcmlhbE51bWJlcl0sXG4gICAgICBbYi56SW5kZXgsIC4uLmIuekluZGV4U3ViT3JkZXIgPz8gW3ZvaWQgMCwgdm9pZCAwXSwgYi5zZXJpYWxOdW1iZXJdLFxuICAgICAgYXNjZW5kaW5nU3RyaW5nTnVtYmVyVW5kZWZpbmVkXG4gICAgKTtcbiAgfVxuICAvLyBXZSBjb25zaWRlciBhIGdyb3VwIHRvIGJlIGJvdW5kbGVzcywgdGh1cyBhbnkgcG9pbnQgYmVsb25ncyB0byBpdC5cbiAgY29udGFpbnNQb2ludChfeCwgX3kpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb21wdXRlQkJveCgpIHtcbiAgICByZXR1cm4gX0dyb3VwLmNvbXB1dGVDaGlsZHJlbkJCb3godGhpcy5jaGlsZHJlbigpKTtcbiAgfVxuICBwcmVSZW5kZXIoKSB7XG4gICAgY29uc3QgY291bnRzID0gc3VwZXIucHJlUmVuZGVyKCk7XG4gICAgY291bnRzLmdyb3VwcyArPSAxO1xuICAgIGNvdW50cy5ub25Hcm91cHMgLT0gMTtcbiAgICByZXR1cm4gY291bnRzO1xuICB9XG4gIGlzRGlydHkocmVuZGVyQ3R4KSB7XG4gICAgY29uc3QgeyByZXNpemVkIH0gPSByZW5kZXJDdHg7XG4gICAgY29uc3QgeyBkaXJ0eSwgZGlydHlaSW5kZXggfSA9IHRoaXM7XG4gICAgY29uc3QgaXNEaXJ0eSA9IGRpcnR5ID49IDIgLyogTUlOT1IgKi8gfHwgZGlydHlaSW5kZXggfHwgcmVzaXplZDtcbiAgICBsZXQgaXNDaGlsZERpcnR5ID0gaXNEaXJ0eTtcbiAgICBsZXQgaXNDaGlsZExheWVyRGlydHkgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4oKSkge1xuICAgICAgaXNDaGlsZERpcnR5IHx8IChpc0NoaWxkRGlydHkgPSBjaGlsZC5sYXllck1hbmFnZXIgPT0gbnVsbCAmJiBjaGlsZC5kaXJ0eSA+PSAxIC8qIFRSSVZJQUwgKi8pO1xuICAgICAgaXNDaGlsZExheWVyRGlydHkgfHwgKGlzQ2hpbGRMYXllckRpcnR5ID0gY2hpbGQubGF5ZXJNYW5hZ2VyICE9IG51bGwgJiYgY2hpbGQuZGlydHkgPj0gMSAvKiBUUklWSUFMICovKTtcbiAgICAgIGlmIChpc0NoaWxkRGlydHkpXG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRzPy5uYW1lKSB7XG4gICAgICB0aGlzLl9kZWJ1Zz8uKHsgbmFtZTogdGhpcy5vcHRzLm5hbWUsIGdyb3VwOiB0aGlzLCBpc0RpcnR5LCBpc0NoaWxkRGlydHksIHJlbmRlckN0eCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHsgaXNEaXJ0eSwgaXNDaGlsZERpcnR5LCBpc0NoaWxkTGF5ZXJEaXJ0eSB9O1xuICB9XG4gIGRlYnVnU2tpcChyZW5kZXJDdHgpIHtcbiAgICBpZiAocmVuZGVyQ3R4LnN0YXRzICYmIHRoaXMub3B0cz8ubmFtZSkge1xuICAgICAgdGhpcy5fZGVidWc/Lih7XG4gICAgICAgIG5hbWU6IHRoaXMub3B0cy5uYW1lLFxuICAgICAgICBncm91cDogdGhpcyxcbiAgICAgICAgcmVzdWx0OiBcInNraXBwaW5nXCIsXG4gICAgICAgIGNvdW50czogbm9kZUNvdW50KHRoaXMpLFxuICAgICAgICByZW5kZXJDdHhcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZW5kZXIocmVuZGVyQ3R4LCBza2lwKSB7XG4gICAgaWYgKHNraXApIHtcbiAgICAgIHJldHVybiBzdXBlci5yZW5kZXIocmVuZGVyQ3R4KTtcbiAgICB9XG4gICAgY29uc3QgeyBvcHRzOiB7IG5hbWUgfSA9IHt9LCBfZGVidWc6IGRlYnVnMyB9ID0gdGhpcztcbiAgICBjb25zdCB7IGlzRGlydHksIGlzQ2hpbGREaXJ0eSwgaXNDaGlsZExheWVyRGlydHkgfSA9IHRoaXMuaXNEaXJ0eShyZW5kZXJDdHgpO1xuICAgIGNvbnN0IHsgY3R4LCBzdGF0cyB9ID0gcmVuZGVyQ3R4O1xuICAgIGxldCB7IGZvcmNlUmVuZGVyIH0gPSByZW5kZXJDdHg7XG4gICAgaWYgKCFpc0RpcnR5ICYmICFpc0NoaWxkRGlydHkgJiYgIWlzQ2hpbGRMYXllckRpcnR5ICYmICFmb3JjZVJlbmRlcikge1xuICAgICAgdGhpcy5kZWJ1Z1NraXAocmVuZGVyQ3R4KTtcbiAgICAgIHRoaXMubWFya0NsZWFuKHsgcmVjdXJzaXZlOiBmYWxzZSB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGZvcmNlUmVuZGVyICE9PSBcImRpcnR5VHJhbnNmb3JtXCIpIHtcbiAgICAgIGZvcmNlUmVuZGVyIHx8IChmb3JjZVJlbmRlciA9IHRoaXMuZGlydHlaSW5kZXgpO1xuICAgIH1cbiAgICBjdHguZ2xvYmFsQWxwaGEgKj0gdGhpcy5vcGFjaXR5O1xuICAgIGlmICh0aGlzLmRpcnR5WkluZGV4KSB7XG4gICAgICB0aGlzLnNvcnRDaGlsZHJlbihfR3JvdXAuY29tcGFyZUNoaWxkcmVuKTtcbiAgICB9XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLnNvcnRlZENoaWxkcmVuKCk7XG4gICAgY29uc3QgY2xpcEJCb3ggPSB0aGlzLnJlbmRlckNsaXAocmVuZGVyQ3R4KSA/PyByZW5kZXJDdHguY2xpcEJCb3g7XG4gICAgY29uc3QgcmVuZGVyQ3R4Q2hhbmdlZCA9IGZvcmNlUmVuZGVyICE9PSByZW5kZXJDdHguZm9yY2VSZW5kZXIgfHwgY2xpcEJCb3ggIT09IHJlbmRlckN0eC5jbGlwQkJveDtcbiAgICB0aGlzLnJlbmRlckNoaWxkcmVuKGNoaWxkcmVuLCByZW5kZXJDdHhDaGFuZ2VkID8geyAuLi5yZW5kZXJDdHgsIGZvcmNlUmVuZGVyLCBjbGlwQkJveCB9IDogcmVuZGVyQ3R4KTtcbiAgICBzdXBlci5yZW5kZXIocmVuZGVyQ3R4KTtcbiAgICBpZiAodGhpcy5jbGlwUmVjdCkge1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLnZpcnR1YWxDaGlsZHJlbigpKSB7XG4gICAgICBjaGlsZC5tYXJrQ2xlYW4oeyByZWN1cnNpdmU6IFwidmlydHVhbFwiIH0pO1xuICAgIH1cbiAgICBpZiAobmFtZSAmJiBzdGF0cykge1xuICAgICAgZGVidWczPy4oe1xuICAgICAgICBuYW1lLFxuICAgICAgICByZW5kZXJDdHgsXG4gICAgICAgIHJlc3VsdDogXCJyZW5kZXJlZFwiLFxuICAgICAgICBza2lwcGVkOiBzdGF0cy5ub2Rlc1NraXBwZWQsXG4gICAgICAgIGNvdW50czogbm9kZUNvdW50KHRoaXMpLFxuICAgICAgICBncm91cDogdGhpc1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHNvcnRlZENoaWxkcmVuKCkge1xuICAgIGxldCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4oKTtcbiAgICBpZiAodGhpcy5oYXNWaXJ0dWFsQ2hpbGRyZW4oKSkge1xuICAgICAgY2hpbGRyZW4gPSBbLi4uY2hpbGRyZW5dLnNvcnQoX0dyb3VwLmNvbXBhcmVDaGlsZHJlbik7XG4gICAgfVxuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuICByZW5kZXJDbGlwKHJlbmRlckN0eCkge1xuICAgIGlmICghdGhpcy5jbGlwUmVjdClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IHgsIHksIHdpZHRoOiB3aWR0aDIsIGhlaWdodDogaGVpZ2h0MiB9ID0gdGhpcy5jbGlwUmVjdDtcbiAgICBjb25zdCB7IGN0eCB9ID0gcmVuZGVyQ3R4O1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5yZWN0KHgsIHksIHdpZHRoMiwgaGVpZ2h0Mik7XG4gICAgY3R4LmNsaXAoKTtcbiAgICB0aGlzLl9kZWJ1Zz8uKCgpID0+ICh7XG4gICAgICBuYW1lOiB0aGlzLm9wdHM/Lm5hbWUsXG4gICAgICBjbGlwUmVjdDogdGhpcy5jbGlwUmVjdCxcbiAgICAgIGN0eFRyYW5zZm9ybTogY3R4LmdldFRyYW5zZm9ybSgpLFxuICAgICAgcmVuZGVyQ3R4LFxuICAgICAgZ3JvdXA6IHRoaXNcbiAgICB9KSk7XG4gICAgcmV0dXJuIFRyYW5zZm9ybWFibGUudG9DYW52YXModGhpcywgdGhpcy5jbGlwUmVjdCk7XG4gIH1cbiAgcmVuZGVyQ2hpbGRyZW4oY2hpbGRyZW4sIHJlbmRlckN0eCkge1xuICAgIGNvbnN0IHsgY3R4LCBmb3JjZVJlbmRlciwgc3RhdHMgfSA9IHJlbmRlckN0eDtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuKSB7XG4gICAgICBpZiAoIWNoaWxkLnZpc2libGUgfHwgIXRoaXMudmlzaWJsZSkge1xuICAgICAgICBjaGlsZC5tYXJrQ2xlYW4oKTtcbiAgICAgICAgaWYgKHN0YXRzKSB7XG4gICAgICAgICAgc3RhdHMubm9kZXNTa2lwcGVkICs9IG5vZGVDb3VudChjaGlsZCkuY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoIWZvcmNlUmVuZGVyICYmIGNoaWxkLmRpcnR5ID09PSAwIC8qIE5PTkUgKi8pIHtcbiAgICAgICAgaWYgKHN0YXRzKSB7XG4gICAgICAgICAgc3RhdHMubm9kZXNTa2lwcGVkICs9IG5vZGVDb3VudChjaGlsZCkuY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY2hpbGQucmVuZGVyKHJlbmRlckN0eCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVHJhbnNmb3JtcyBiYm94IGdpdmVuIGluIHRoZSBjYW52YXMgY29vcmRpbmF0ZSBzcGFjZSB0byBiYm94IGluIHRoaXMgZ3JvdXAncyBjb29yZGluYXRlIHNwYWNlIGFuZFxuICAgKiBzZXRzIHRoaXMgZ3JvdXAncyBjbGlwUmVjdCB0byB0aGUgdHJhbnNmb3JtZWQgYmJveC5cbiAgICogQHBhcmFtIGJib3ggY2xpcFJlY3QgYmJveCBpbiB0aGUgY2FudmFzIGNvb3JkaW5hdGUgc3BhY2UuXG4gICAqL1xuICBzZXRDbGlwUmVjdChiYm94KSB7XG4gICAgdGhpcy5jbGlwUmVjdCA9IGJib3ggPyBUcmFuc2Zvcm1hYmxlLmZyb21DYW52YXModGhpcywgYmJveCkgOiB2b2lkIDA7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgY2xpcCByZWN0IHdpdGhpbiB0aGUgY2FudmFzIGNvb3JkaW5hdGUgc3BhY2UuXG4gICAqIEBwYXJhbSBiYm94IGNsaXBSZWN0IGJib3ggaW4gdGhlIGNhbnZhcyBjb29yZGluYXRlIHNwYWNlLlxuICAgKi9cbiAgc2V0Q2xpcFJlY3RDYW52YXNTcGFjZShiYm94KSB7XG4gICAgdGhpcy5jbGlwUmVjdCA9IGJib3g7XG4gIH1cbiAgdG9TVkcoKSB7XG4gICAgaWYgKCF0aGlzLnZpc2libGUpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZGVmcyA9IFtdO1xuICAgIGNvbnN0IGVsZW1lbnRzMiA9IFtdO1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5zb3J0ZWRDaGlsZHJlbigpKSB7XG4gICAgICBjb25zdCBzdmcgPSBjaGlsZC50b1NWRygpO1xuICAgICAgaWYgKHN2ZyAhPSBudWxsKSB7XG4gICAgICAgIGVsZW1lbnRzMi5wdXNoKC4uLnN2Zy5lbGVtZW50cyk7XG4gICAgICAgIGlmIChzdmcuZGVmcyAhPSBudWxsKSB7XG4gICAgICAgICAgZGVmcy5wdXNoKC4uLnN2Zy5kZWZzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBlbGVtZW50czogZWxlbWVudHMyLCBkZWZzIH07XG4gIH1cbn07XG5fR3JvdXAuY2xhc3NOYW1lID0gXCJHcm91cFwiO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oe1xuICAgIHJlZHJhdzogMyAvKiBNQUpPUiAqLyxcbiAgICBjb252ZXJ0b3I6ICh2KSA9PiBjbGFtcCgwLCB2LCAxKVxuICB9KVxuXSwgX0dyb3VwLnByb3RvdHlwZSwgXCJvcGFjaXR5XCIsIDIpO1xudmFyIEdyb3VwID0gX0dyb3VwO1xudmFyIFNjYWxhYmxlR3JvdXAgPSBjbGFzcyBleHRlbmRzIFNjYWxhYmxlKEdyb3VwKSB7XG59O1xudmFyIFJvdGF0YWJsZUdyb3VwID0gY2xhc3MgZXh0ZW5kcyBSb3RhdGFibGUoR3JvdXApIHtcbn07XG52YXIgVHJhbnNsYXRhYmxlR3JvdXAgPSBjbGFzcyBleHRlbmRzIFRyYW5zbGF0YWJsZShHcm91cCkge1xufTtcbnZhciBUcmFuc2Zvcm1hYmxlR3JvdXAgPSBjbGFzcyBleHRlbmRzIFJvdGF0YWJsZShUcmFuc2xhdGFibGUoR3JvdXApKSB7XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2RlYnVnLnRzXG52YXIgTE9OR19USU1FX1BFUklPRF9USFJFU0hPTEQgPSAyZTM7XG52YXIgdGltZU9mTGFzdExvZyA9IERhdGUubm93KCk7XG52YXIgbG9nVGltZUdhcCA9ICgpID0+IHtcbiAgY29uc3QgdGltZVNpbmNlTGFzdExvZyA9IERhdGUubm93KCkgLSB0aW1lT2ZMYXN0TG9nO1xuICBpZiAodGltZVNpbmNlTGFzdExvZyA+IExPTkdfVElNRV9QRVJJT0RfVEhSRVNIT0xEKSB7XG4gICAgY29uc3QgcHJldHR5RHVyYXRpb24gPSAoTWF0aC5mbG9vcih0aW1lU2luY2VMYXN0TG9nIC8gMTAwKSAvIDEwKS50b0ZpeGVkKDEpO1xuICAgIExvZ2dlci5sb2coYCoqKiogJHtwcmV0dHlEdXJhdGlvbn1zIHNpbmNlIGxhc3QgbG9nIG1lc3NhZ2UgKioqKmApO1xuICB9XG4gIHRpbWVPZkxhc3RMb2cgPSBEYXRlLm5vdygpO1xufTtcbnZhciBEZWJ1ZyA9IHtcbiAgY3JlYXRlKC4uLmRlYnVnU2VsZWN0b3JzKSB7XG4gICAgY29uc3QgcmVzdWx0Rm4gPSAoLi4ubG9nQ29udGVudCkgPT4ge1xuICAgICAgaWYgKERlYnVnLmNoZWNrKC4uLmRlYnVnU2VsZWN0b3JzKSkge1xuICAgICAgICBpZiAodHlwZW9mIGxvZ0NvbnRlbnRbMF0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGxvZ0NvbnRlbnQgPSB0b0FycmF5KGxvZ0NvbnRlbnRbMF0oKSk7XG4gICAgICAgIH1cbiAgICAgICAgbG9nVGltZUdhcCgpO1xuICAgICAgICBMb2dnZXIubG9nKC4uLmxvZ0NvbnRlbnQpO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ocmVzdWx0Rm4sIHsgY2hlY2s6ICgpID0+IERlYnVnLmNoZWNrKC4uLmRlYnVnU2VsZWN0b3JzKSB9KTtcbiAgfSxcbiAgY2hlY2soLi4uZGVidWdTZWxlY3RvcnMpIHtcbiAgICBpZiAoZGVidWdTZWxlY3RvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBkZWJ1Z1NlbGVjdG9ycy5wdXNoKHRydWUpO1xuICAgIH1cbiAgICBjb25zdCBjaGFydERlYnVnID0gdG9BcnJheShnZXRXaW5kb3coXCJhZ0NoYXJ0c0RlYnVnXCIpKTtcbiAgICByZXR1cm4gY2hhcnREZWJ1Zy5zb21lKChzZWxlY3RvcikgPT4gZGVidWdTZWxlY3RvcnMuaW5jbHVkZXMoc2VsZWN0b3IpKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvc2VsZWN0aW9uLnRzXG52YXIgU2VsZWN0aW9uID0gY2xhc3MgX1NlbGVjdGlvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcmVudE5vZGUsIGNsYXNzT3JGYWN0b3J5LCBhdXRvQ2xlYW51cCA9IHRydWUpIHtcbiAgICB0aGlzLnBhcmVudE5vZGUgPSBwYXJlbnROb2RlO1xuICAgIHRoaXMuYXV0b0NsZWFudXAgPSBhdXRvQ2xlYW51cDtcbiAgICB0aGlzLmdhcmJhZ2VCaW4gPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMuX25vZGVzTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLl9ub2RlcyA9IFtdO1xuICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgIHRoaXMuZGVidWcgPSBEZWJ1Zy5jcmVhdGUodHJ1ZSwgXCJzY2VuZVwiLCBcInNjZW5lOnNlbGVjdGlvbnNcIik7XG4gICAgdGhpcy5ub2RlRmFjdG9yeSA9IE9iamVjdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZi5jYWxsKE5vZGUsIGNsYXNzT3JGYWN0b3J5KSA/ICgpID0+IG5ldyBjbGFzc09yRmFjdG9yeSgpIDogY2xhc3NPckZhY3Rvcnk7XG4gIH1cbiAgc3RhdGljIHNlbGVjdChwYXJlbnQsIGNsYXNzT3JGYWN0b3J5LCBnYXJiYWdlQ29sbGVjdGlvbiA9IHRydWUpIHtcbiAgICByZXR1cm4gbmV3IF9TZWxlY3Rpb24ocGFyZW50LCBjbGFzc09yRmFjdG9yeSwgZ2FyYmFnZUNvbGxlY3Rpb24pO1xuICB9XG4gIHN0YXRpYyBzZWxlY3RBbGwocGFyZW50LCBwcmVkaWNhdGUpIHtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgY29uc3QgdHJhdmVyc2UgPSAobm9kZSkgPT4ge1xuICAgICAgaWYgKHByZWRpY2F0ZShub2RlKSkge1xuICAgICAgICByZXN1bHRzLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIG5vZGUuY2hpbGRyZW4oKSkge1xuICAgICAgICB0cmF2ZXJzZShjaGlsZCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0cmF2ZXJzZShwYXJlbnQpO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG4gIHN0YXRpYyBzZWxlY3RCeUNsYXNzKG5vZGUsIC4uLkNsYXNzZXMpIHtcbiAgICByZXR1cm4gX1NlbGVjdGlvbi5zZWxlY3RBbGwobm9kZSwgKG4pID0+IENsYXNzZXMuc29tZSgoQykgPT4gbiBpbnN0YW5jZW9mIEMpKTtcbiAgfVxuICBzdGF0aWMgc2VsZWN0QnlUYWcobm9kZSwgdGFnKSB7XG4gICAgcmV0dXJuIF9TZWxlY3Rpb24uc2VsZWN0QWxsKG5vZGUsIChuKSA9PiBuLnRhZyA9PT0gdGFnKTtcbiAgfVxuICBjcmVhdGVOb2RlKGRhdHVtLCBpbml0aWFsaXplciwgaWR4KSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMubm9kZUZhY3RvcnkoZGF0dW0pO1xuICAgIG5vZGUuZGF0dW0gPSBkYXR1bTtcbiAgICBpbml0aWFsaXplcj8uKG5vZGUpO1xuICAgIGlmIChpZHggPT0gbnVsbCkge1xuICAgICAgdGhpcy5fbm9kZXMucHVzaChub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbm9kZXMuc3BsaWNlKGlkeCwgMCwgbm9kZSk7XG4gICAgfVxuICAgIHRoaXMucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChub2RlKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlIHRoZSBkYXRhIGluIGEgc2VsZWN0aW9uLiBJZiBhbiBgZ2V0RGF0dW1JZCgpYCBmdW5jdGlvbiBpcyBwcm92aWRlZCwgbWFpbnRhaW4gYSBsaXN0IG9mIGlkcyByZWxhdGVkIHRvXG4gICAqIHRoZSBub2Rlcy4gT3RoZXJ3aXNlLCB0YWtlIHRoZSBtb3JlIGVmZmljaWVudCByb3V0ZSBvZiBzaW1wbHkgY3JlYXRpbmcgYW5kIGRlc3Ryb3lpbmcgbm9kZXMgYXQgdGhlIGVuZFxuICAgKiBvZiB0aGUgYXJyYXkuXG4gICAqL1xuICB1cGRhdGUoZGF0YSwgaW5pdGlhbGl6ZXIsIGdldERhdHVtSWQpIHtcbiAgICBpZiAodGhpcy5nYXJiYWdlQmluLnNpemUgPiAwKSB7XG4gICAgICB0aGlzLmRlYnVnKGBTZWxlY3Rpb24gLSB1cGRhdGUoKSBjYWxsZWQgd2l0aCBwZW5kaW5nIGdhcmJhZ2U6ICR7ZGF0YX1gKTtcbiAgICB9XG4gICAgaWYgKGdldERhdHVtSWQpIHtcbiAgICAgIGNvbnN0IGRhdGFNYXAgPSBuZXcgTWFwKFxuICAgICAgICBkYXRhLm1hcCgoZGF0dW0sIGlkeCkgPT4gW2dldERhdHVtSWQoZGF0dW0pLCBbZGF0dW0sIGlkeF1dKVxuICAgICAgKTtcbiAgICAgIGZvciAoY29uc3QgW25vZGUsIGRhdHVtSWRdIG9mIHRoaXMuX25vZGVzTWFwLmVudHJpZXMoKSkge1xuICAgICAgICBpZiAoZGF0YU1hcC5oYXMoZGF0dW1JZCkpIHtcbiAgICAgICAgICBjb25zdCBbbmV3RGF0dW1dID0gZGF0YU1hcC5nZXQoZGF0dW1JZCk7XG4gICAgICAgICAgbm9kZS5kYXR1bSA9IG5ld0RhdHVtO1xuICAgICAgICAgIHRoaXMuZ2FyYmFnZUJpbi5kZWxldGUobm9kZSk7XG4gICAgICAgICAgZGF0YU1hcC5kZWxldGUoZGF0dW1JZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5nYXJiYWdlQmluLmFkZChub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBbZGF0dW1JZCwgW2RhdHVtLCBpZHhdXSBvZiBkYXRhTWFwLmVudHJpZXMoKSkge1xuICAgICAgICB0aGlzLl9ub2Rlc01hcC5zZXQodGhpcy5jcmVhdGVOb2RlKGRhdHVtLCBpbml0aWFsaXplciwgaWR4KSwgZGF0dW1JZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1heExlbmd0aCA9IE1hdGgubWF4KGRhdGEubGVuZ3RoLCB0aGlzLmRhdGEubGVuZ3RoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4TGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGkgPj0gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLmdhcmJhZ2VCaW4uYWRkKHRoaXMuX25vZGVzW2ldKTtcbiAgICAgICAgfSBlbHNlIGlmIChpID49IHRoaXMuX25vZGVzLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuY3JlYXRlTm9kZShkYXRhW2ldLCBpbml0aWFsaXplcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fbm9kZXNbaV0uZGF0dW0gPSBkYXRhW2ldO1xuICAgICAgICAgIHRoaXMuZ2FyYmFnZUJpbi5kZWxldGUodGhpcy5fbm9kZXNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZGF0YSA9IGRhdGEuc2xpY2UoKTtcbiAgICBpZiAodGhpcy5hdXRvQ2xlYW51cCkge1xuICAgICAgdGhpcy5jbGVhbnVwKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGNsZWFudXAoKSB7XG4gICAgaWYgKHRoaXMuZ2FyYmFnZUJpbi5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGhpcy5fbm9kZXMgPSB0aGlzLl9ub2Rlcy5maWx0ZXIoKG5vZGUpID0+IHtcbiAgICAgIGlmICh0aGlzLmdhcmJhZ2VCaW4uaGFzKG5vZGUpKSB7XG4gICAgICAgIHRoaXMuX25vZGVzTWFwLmRlbGV0ZShub2RlKTtcbiAgICAgICAgdGhpcy5nYXJiYWdlQmluLmRlbGV0ZShub2RlKTtcbiAgICAgICAgbm9kZS5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMudXBkYXRlKFtdKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBpc0dhcmJhZ2Uobm9kZSkge1xuICAgIHJldHVybiB0aGlzLmdhcmJhZ2VCaW4uaGFzKG5vZGUpO1xuICB9XG4gIGhhc0dhcmJhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2FyYmFnZUJpbi5zaXplID4gMDtcbiAgfVxuICBlYWNoKGl0ZXJhdGUyKSB7XG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiB0aGlzLl9ub2Rlcy5lbnRyaWVzKCkpIHtcbiAgICAgIGl0ZXJhdGUyKGVudHJ5WzFdLCBlbnRyeVsxXS5kYXR1bSwgZW50cnlbMF0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuX25vZGVzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuX25vZGVzW2luZGV4XTtcbiAgICAgIHlpZWxkIHsgbm9kZSwgZGF0dW06IG5vZGUuZGF0dW0sIGluZGV4IH07XG4gICAgfVxuICB9XG4gIHNlbGVjdChwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gX1NlbGVjdGlvbi5zZWxlY3RBbGwodGhpcy5wYXJlbnROb2RlLCBwcmVkaWNhdGUpO1xuICB9XG4gIHNlbGVjdEJ5Q2xhc3MoQ2xhc3MpIHtcbiAgICByZXR1cm4gX1NlbGVjdGlvbi5zZWxlY3RCeUNsYXNzKHRoaXMucGFyZW50Tm9kZSwgQ2xhc3MpO1xuICB9XG4gIHNlbGVjdEJ5VGFnKHRhZykge1xuICAgIHJldHVybiBfU2VsZWN0aW9uLnNlbGVjdEJ5VGFnKHRoaXMucGFyZW50Tm9kZSwgdGFnKTtcbiAgfVxuICBub2RlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fbm9kZXM7XG4gIH1cbiAgYXQoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fbm9kZXMuYXQoaW5kZXgpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2FuZ2xlLnRzXG52YXIgdHdvUGkgPSBNYXRoLlBJICogMjtcbmZ1bmN0aW9uIG5vcm1hbGl6ZUFuZ2xlMzYwKHJhZGlhbnMpIHtcbiAgcmFkaWFucyAlPSB0d29QaTtcbiAgcmFkaWFucyArPSB0d29QaTtcbiAgcmFkaWFucyAlPSB0d29QaTtcbiAgcmV0dXJuIHJhZGlhbnM7XG59XG5mdW5jdGlvbiBub3JtYWxpemVBbmdsZTM2MEluY2x1c2l2ZShyYWRpYW5zKSB7XG4gIHJhZGlhbnMgJT0gdHdvUGk7XG4gIHJhZGlhbnMgKz0gdHdvUGk7XG4gIGlmIChyYWRpYW5zICE9PSB0d29QaSkge1xuICAgIHJhZGlhbnMgJT0gdHdvUGk7XG4gIH1cbiAgcmV0dXJuIHJhZGlhbnM7XG59XG5mdW5jdGlvbiBub3JtYWxpemVBbmdsZTE4MChyYWRpYW5zKSB7XG4gIHJhZGlhbnMgJT0gdHdvUGk7XG4gIGlmIChyYWRpYW5zIDwgLU1hdGguUEkpIHtcbiAgICByYWRpYW5zICs9IHR3b1BpO1xuICB9IGVsc2UgaWYgKHJhZGlhbnMgPj0gTWF0aC5QSSkge1xuICAgIHJhZGlhbnMgLT0gdHdvUGk7XG4gIH1cbiAgcmV0dXJuIHJhZGlhbnM7XG59XG5mdW5jdGlvbiBpc0JldHdlZW5BbmdsZXModGFyZ2V0QW5nbGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKSB7XG4gIGNvbnN0IHQgPSBub3JtYWxpemVBbmdsZTM2MCh0YXJnZXRBbmdsZSk7XG4gIGNvbnN0IGEwID0gbm9ybWFsaXplQW5nbGUzNjAoc3RhcnRBbmdsZSk7XG4gIGNvbnN0IGExID0gbm9ybWFsaXplQW5nbGUzNjAoZW5kQW5nbGUpO1xuICBpZiAoYTAgPCBhMSkge1xuICAgIHJldHVybiBhMCA8PSB0ICYmIHQgPD0gYTE7XG4gIH0gZWxzZSBpZiAoYTAgPiBhMSkge1xuICAgIHJldHVybiBhMCA8PSB0IHx8IHQgPD0gYTE7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbmZ1bmN0aW9uIHRvUmFkaWFucyhkZWdyZWVzKSB7XG4gIHJldHVybiBkZWdyZWVzIC8gMTgwICogTWF0aC5QSTtcbn1cbmZ1bmN0aW9uIHRvRGVncmVlcyhyYWRpYW5zKSB7XG4gIHJldHVybiByYWRpYW5zIC8gTWF0aC5QSSAqIDE4MDtcbn1cbmZ1bmN0aW9uIGFuZ2xlRGlmZihhbmdsZTAsIGFuZ2xlMSwgY291bnRlckNsb2Nrd2lzZSkge1xuICBpZiAoY291bnRlckNsb2Nrd2lzZSkge1xuICAgIFthbmdsZTAsIGFuZ2xlMV0gPSBbYW5nbGUxLCBhbmdsZTBdO1xuICB9XG4gIGNvbnN0IGEwID0gbm9ybWFsaXplQW5nbGUzNjAoYW5nbGUwKTtcbiAgY29uc3QgYTEgPSBub3JtYWxpemVBbmdsZTM2MChhbmdsZTEpICsgdHdvUGk7XG4gIHJldHVybiAoYTEgLSBhMCkgJSB0d29QaTtcbn1cbmZ1bmN0aW9uIGFuZ2xlQmV0d2VlbihhbmdsZTAsIGFuZ2xlMSkge1xuICBhbmdsZTAgPSBub3JtYWxpemVBbmdsZTM2MChhbmdsZTApO1xuICBhbmdsZTEgPSBub3JtYWxpemVBbmdsZTM2MChhbmdsZTEpO1xuICByZXR1cm4gYW5nbGUxIC0gYW5nbGUwICsgKGFuZ2xlMCA+IGFuZ2xlMSA/IDIgKiBNYXRoLlBJIDogMCk7XG59XG5mdW5jdGlvbiBkaXNwbGFjZVBvaW50RnJvbVZlY3RvcihjZW50ZXJYLCBjZW50ZXJZLCByYWRpdXMsIGFuZ2xlMikge1xuICBjb25zdCB4ID0gY2VudGVyWCArIHJhZGl1cyAqIE1hdGguY29zKGFuZ2xlMik7XG4gIGNvbnN0IHkgPSBjZW50ZXJZICsgcmFkaXVzICogTWF0aC5zaW4oYW5nbGUyKTtcbiAgcmV0dXJuIHsgeCwgeSB9O1xufVxudmFyIGRlbHRhID0gMWUtNjtcbmZ1bmN0aW9uIGNsb2Nrd2lzZUFuZ2xlKGFuZ2xlMiwgcmVsYXRpdmVUb1N0YXJ0QW5nbGUpIHtcbiAgaWYgKGFuZ2xlQmV0d2VlbihhbmdsZTIsIHJlbGF0aXZlVG9TdGFydEFuZ2xlKSA8IGRlbHRhKSB7XG4gICAgcmV0dXJuIHJlbGF0aXZlVG9TdGFydEFuZ2xlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBub3JtYWxpemVBbmdsZTM2MChhbmdsZTIgLSByZWxhdGl2ZVRvU3RhcnRBbmdsZSkgKyByZWxhdGl2ZVRvU3RhcnRBbmdsZTtcbiAgfVxufVxuZnVuY3Rpb24gY2xvY2t3aXNlQW5nbGVzKHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCByZWxhdGl2ZVRvU3RhcnRBbmdsZSA9IDApIHtcbiAgY29uc3QgZnVsbFBpZSA9IE1hdGguYWJzKGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSkgPj0gMiAqIE1hdGguUEk7XG4gIGNvbnN0IHN3ZWVwQW5nbGUgPSBmdWxsUGllID8gMiAqIE1hdGguUEkgOiBub3JtYWxpemVBbmdsZTM2MChlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpO1xuICBzdGFydEFuZ2xlID0gY2xvY2t3aXNlQW5nbGUoc3RhcnRBbmdsZSwgcmVsYXRpdmVUb1N0YXJ0QW5nbGUpO1xuICBlbmRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBzd2VlcEFuZ2xlO1xuICByZXR1cm4geyBzdGFydEFuZ2xlLCBlbmRBbmdsZSB9O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2Rpc3RhbmNlLnRzXG5mdW5jdGlvbiBwb2ludHNEaXN0YW5jZVNxdWFyZWQoeDEsIHkxLCB4MiwgeTIpIHtcbiAgY29uc3QgZHggPSB4MSAtIHgyO1xuICBjb25zdCBkeSA9IHkxIC0geTI7XG4gIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cbmZ1bmN0aW9uIGxpbmVEaXN0YW5jZVNxdWFyZWQoeCwgeSwgeDEsIHkxLCB4MiwgeTIsIGJlc3QpIHtcbiAgaWYgKHgxID09PSB4MiAmJiB5MSA9PT0geTIpIHtcbiAgICByZXR1cm4gTWF0aC5taW4oYmVzdCwgcG9pbnRzRGlzdGFuY2VTcXVhcmVkKHgsIHksIHgxLCB5MSkpO1xuICB9XG4gIGNvbnN0IGR4ID0geDIgLSB4MTtcbiAgY29uc3QgZHkgPSB5MiAtIHkxO1xuICBjb25zdCB0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgKCh4IC0geDEpICogZHggKyAoeSAtIHkxKSAqIGR5KSAvIChkeCAqIGR4ICsgZHkgKiBkeSkpKTtcbiAgY29uc3QgaXggPSB4MSArIHQgKiBkeDtcbiAgY29uc3QgaXkgPSB5MSArIHQgKiBkeTtcbiAgcmV0dXJuIE1hdGgubWluKGJlc3QsIHBvaW50c0Rpc3RhbmNlU3F1YXJlZCh4LCB5LCBpeCwgaXkpKTtcbn1cbmZ1bmN0aW9uIGFyY0Rpc3RhbmNlU3F1YXJlZCh4LCB5LCBjeCwgY3ksIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGNvdW50ZXJDbG9ja3dpc2UsIGJlc3QpIHtcbiAgaWYgKGNvdW50ZXJDbG9ja3dpc2UpIHtcbiAgICBbZW5kQW5nbGUsIHN0YXJ0QW5nbGVdID0gW3N0YXJ0QW5nbGUsIGVuZEFuZ2xlXTtcbiAgfVxuICBjb25zdCBhbmdsZTIgPSBNYXRoLmF0YW4yKHkgLSBjeSwgeCAtIGN4KTtcbiAgaWYgKCFpc0JldHdlZW5BbmdsZXMoYW5nbGUyLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSkpIHtcbiAgICBjb25zdCBzdGFydFggPSBjeCArIE1hdGguY29zKHN0YXJ0QW5nbGUpICogcmFkaXVzO1xuICAgIGNvbnN0IHN0YXJ0WSA9IGN5ICsgTWF0aC5zaW4oc3RhcnRBbmdsZSkgKiByYWRpdXM7XG4gICAgY29uc3QgZW5kWCA9IGN4ICsgTWF0aC5jb3Moc3RhcnRBbmdsZSkgKiByYWRpdXM7XG4gICAgY29uc3QgZW5kWSA9IGN5ICsgTWF0aC5zaW4oc3RhcnRBbmdsZSkgKiByYWRpdXM7XG4gICAgcmV0dXJuIE1hdGgubWluKGJlc3QsIHBvaW50c0Rpc3RhbmNlU3F1YXJlZCh4LCB5LCBzdGFydFgsIHN0YXJ0WSksIHBvaW50c0Rpc3RhbmNlU3F1YXJlZCh4LCB5LCBlbmRYLCBlbmRZKSk7XG4gIH1cbiAgY29uc3QgZGlzdFRvQXJjID0gcmFkaXVzIC0gTWF0aC5zcXJ0KHBvaW50c0Rpc3RhbmNlU3F1YXJlZCh4LCB5LCBjeCwgY3kpKTtcbiAgcmV0dXJuIE1hdGgubWluKGJlc3QsIGRpc3RUb0FyYyAqIGRpc3RUb0FyYyk7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjYWxlL2NvbG9yU2NhbGUudHNcbnZhciBjb252ZXJ0Q29sb3JTdHJpbmdUb09rbGNoYSA9ICh2KSA9PiB7XG4gIGNvbnN0IGNvbG9yID0gQ29sb3IuZnJvbVN0cmluZyh2KTtcbiAgY29uc3QgW2wsIGMsIGhdID0gQ29sb3IuUkdCdG9PS0xDSChjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iKTtcbiAgcmV0dXJuIHsgbCwgYywgaCwgYTogY29sb3IuYSB9O1xufTtcbnZhciBkZWx0YTIgPSAxZS02O1xudmFyIGlzQWNocm9tYXRpYyA9ICh4KSA9PiB4LmMgPCBkZWx0YTIgfHwgeC5sIDwgZGVsdGEyIHx8IHgubCA+IDEgLSBkZWx0YTI7XG52YXIgaW50ZXJwb2xhdGVPa2xjaCA9ICh4LCB5LCBkKSA9PiB7XG4gIGQgPSBjbGFtcCgwLCBkLCAxKTtcbiAgbGV0IGg7XG4gIGlmIChpc0FjaHJvbWF0aWMoeCkpIHtcbiAgICBoID0geS5oO1xuICB9IGVsc2UgaWYgKGlzQWNocm9tYXRpYyh5KSkge1xuICAgIGggPSB4Lmg7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgeEggPSB4Lmg7XG4gICAgbGV0IHlIID0geS5oO1xuICAgIGNvbnN0IGRlbHRhSCA9IHkuaCAtIHguaDtcbiAgICBpZiAoZGVsdGFIID4gMTgwKSB7XG4gICAgICB5SCAtPSAzNjA7XG4gICAgfSBlbHNlIGlmIChkZWx0YUggPCAtMTgwKSB7XG4gICAgICB5SCArPSAzNjA7XG4gICAgfVxuICAgIGggPSB4SCAqICgxIC0gZCkgKyB5SCAqIGQ7XG4gIH1cbiAgY29uc3QgYyA9IHguYyAqICgxIC0gZCkgKyB5LmMgKiBkO1xuICBjb25zdCBsID0geC5sICogKDEgLSBkKSArIHkubCAqIGQ7XG4gIGNvbnN0IGEgPSB4LmEgKiAoMSAtIGQpICsgeS5hICogZDtcbiAgcmV0dXJuIENvbG9yLmZyb21PS0xDSChsLCBjLCBoLCBhKTtcbn07XG52YXIgQ29sb3JTY2FsZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy50eXBlID0gXCJjb2xvclwiO1xuICAgIHRoaXMuaW52YWxpZCA9IHRydWU7XG4gICAgdGhpcy5kb21haW4gPSBbMCwgMV07XG4gICAgdGhpcy5yYW5nZSA9IFtcInJlZFwiLCBcImJsdWVcIl07XG4gICAgdGhpcy5wYXJzZWRSYW5nZSA9IHRoaXMucmFuZ2UubWFwKGNvbnZlcnRDb2xvclN0cmluZ1RvT2tsY2hhKTtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgY29uc3QgeyBkb21haW4sIHJhbmdlOiByYW5nZTMgfSA9IHRoaXM7XG4gICAgaWYgKGRvbWFpbi5sZW5ndGggPCAyKSB7XG4gICAgICBMb2dnZXIud2Fybk9uY2UoXCJgY29sb3JEb21haW5gIHNob3VsZCBoYXZlIGF0IGxlYXN0IDIgdmFsdWVzLlwiKTtcbiAgICAgIGlmIChkb21haW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGRvbWFpbi5wdXNoKDAsIDEpO1xuICAgICAgfSBlbHNlIGlmIChkb21haW4ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGRvbWFpbi5wdXNoKGRvbWFpblswXSArIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGRvbWFpbi5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYSA9IGRvbWFpbltpIC0gMV07XG4gICAgICBjb25zdCBiID0gZG9tYWluW2ldO1xuICAgICAgaWYgKGEgPj0gYikge1xuICAgICAgICBMb2dnZXIud2Fybk9uY2UoXCJgY29sb3JEb21haW5gIHZhbHVlcyBzaG91bGQgYmUgc3VwcGxpZWQgaW4gYXNjZW5kaW5nIG9yZGVyLlwiKTtcbiAgICAgICAgZG9tYWluLnNvcnQoKGEyLCBiMikgPT4gYTIgLSBiMik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmFuZ2UzLmxlbmd0aCA8IGRvbWFpbi5sZW5ndGgpIHtcbiAgICAgIGZvciAobGV0IGkgPSByYW5nZTMubGVuZ3RoOyBpIDwgZG9tYWluLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJhbmdlMy5wdXNoKHJhbmdlMy5sZW5ndGggPiAwID8gcmFuZ2UzWzBdIDogXCJibGFja1wiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5wYXJzZWRSYW5nZSA9IHRoaXMucmFuZ2UubWFwKGNvbnZlcnRDb2xvclN0cmluZ1RvT2tsY2hhKTtcbiAgfVxuICBjb252ZXJ0KHgpIHtcbiAgICB0aGlzLnJlZnJlc2goKTtcbiAgICBjb25zdCB7IGRvbWFpbiwgcmFuZ2U6IHJhbmdlMywgcGFyc2VkUmFuZ2UgfSA9IHRoaXM7XG4gICAgY29uc3QgZDAgPSBkb21haW5bMF07XG4gICAgY29uc3QgZDEgPSBkb21haW4uYXQoLTEpO1xuICAgIGNvbnN0IHIwID0gcmFuZ2UzWzBdO1xuICAgIGNvbnN0IHIxID0gcmFuZ2UzW3JhbmdlMy5sZW5ndGggLSAxXTtcbiAgICBpZiAoeCA8PSBkMCkge1xuICAgICAgcmV0dXJuIHIwO1xuICAgIH1cbiAgICBpZiAoeCA+PSBkMSkge1xuICAgICAgcmV0dXJuIHIxO1xuICAgIH1cbiAgICBsZXQgaW5kZXg7XG4gICAgbGV0IHE7XG4gICAgaWYgKGRvbWFpbi5sZW5ndGggPT09IDIpIHtcbiAgICAgIGNvbnN0IHQgPSAoeCAtIGQwKSAvIChkMSAtIGQwKTtcbiAgICAgIGNvbnN0IHN0ZXAgPSAxIC8gKHJhbmdlMy5sZW5ndGggLSAxKTtcbiAgICAgIGluZGV4ID0gcmFuZ2UzLmxlbmd0aCA8PSAyID8gMCA6IE1hdGgubWluKE1hdGguZmxvb3IodCAqIChyYW5nZTMubGVuZ3RoIC0gMSkpLCByYW5nZTMubGVuZ3RoIC0gMik7XG4gICAgICBxID0gKHQgLSBpbmRleCAqIHN0ZXApIC8gc3RlcDtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgZG9tYWluLmxlbmd0aCAtIDI7IGluZGV4KyspIHtcbiAgICAgICAgaWYgKHggPCBkb21haW5baW5kZXggKyAxXSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBhID0gZG9tYWluW2luZGV4XTtcbiAgICAgIGNvbnN0IGIgPSBkb21haW5baW5kZXggKyAxXTtcbiAgICAgIHEgPSAoeCAtIGEpIC8gKGIgLSBhKTtcbiAgICB9XG4gICAgY29uc3QgYzAgPSBwYXJzZWRSYW5nZVtpbmRleF07XG4gICAgY29uc3QgYzEgPSBwYXJzZWRSYW5nZVtpbmRleCArIDFdO1xuICAgIHJldHVybiBpbnRlcnBvbGF0ZU9rbGNoKGMwLCBjMSwgcSkudG9SZ2JhU3RyaW5nKCk7XG4gIH1cbiAgcmVmcmVzaCgpIHtcbiAgICBpZiAoIXRoaXMuaW52YWxpZClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmludmFsaWQgPSBmYWxzZTtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIGlmICh0aGlzLmludmFsaWQpIHtcbiAgICAgIExvZ2dlci53YXJuT25jZShcIkV4cGVjdGVkIHVwZGF0ZSB0byBub3QgaW52YWxpZGF0ZSBzY2FsZVwiKTtcbiAgICB9XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBJbnZhbGlkYXRpbmdcbl0sIENvbG9yU2NhbGUucHJvdG90eXBlLCBcImRvbWFpblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEludmFsaWRhdGluZ1xuXSwgQ29sb3JTY2FsZS5wcm90b3R5cGUsIFwicmFuZ2VcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL2dyYWRpZW50L2dyYWRpZW50LnRzXG52YXIgR3JhZGllbnQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNvbG9yU3BhY2UsIHN0b3BzID0gW10sIGJib3gpIHtcbiAgICB0aGlzLmNvbG9yU3BhY2UgPSBjb2xvclNwYWNlO1xuICAgIHRoaXMuc3RvcHMgPSBzdG9wcztcbiAgICB0aGlzLmJib3ggPSBiYm94O1xuICAgIHRoaXMuX2NhY2hlID0gdm9pZCAwO1xuICB9XG4gIGNyZWF0ZUdyYWRpZW50KGN0eCwgc2hhcGVCYm94KSB7XG4gICAgY29uc3QgYmJveCA9IHRoaXMuYmJveCA/PyBzaGFwZUJib3g7XG4gICAgaWYgKHRoaXMuX2NhY2hlICE9IG51bGwgJiYgdGhpcy5fY2FjaGUuY3R4ID09PSBjdHggJiYgdGhpcy5fY2FjaGUuYmJveC5lcXVhbHMoYmJveCkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jYWNoZS5ncmFkaWVudDtcbiAgICB9XG4gICAgY29uc3QgeyBzdG9wcywgY29sb3JTcGFjZSB9ID0gdGhpcztcbiAgICBpZiAoc3RvcHMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChzdG9wcy5sZW5ndGggPT09IDEpXG4gICAgICByZXR1cm4gc3RvcHNbMF0uY29sb3I7XG4gICAgbGV0IGdyYWRpZW50MiA9IHRoaXMuY3JlYXRlQ2FudmFzR3JhZGllbnQoY3R4LCBiYm94KTtcbiAgICBpZiAoZ3JhZGllbnQyID09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgaXNPa0xjaCA9IGNvbG9yU3BhY2UgPT09IFwib2tsY2hcIjtcbiAgICBjb25zdCBzdGVwID0gMC4wNTtcbiAgICBsZXQgYzAgPSBzdG9wc1swXTtcbiAgICBncmFkaWVudDIuYWRkQ29sb3JTdG9wKGMwLm9mZnNldCwgYzAuY29sb3IpO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc3RvcHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGNvbnN0IGMxID0gc3RvcHNbaV07XG4gICAgICBpZiAoaXNPa0xjaCkge1xuICAgICAgICBjb25zdCBzY2FsZTIgPSBuZXcgQ29sb3JTY2FsZSgpO1xuICAgICAgICBzY2FsZTIuZG9tYWluID0gW2MwLm9mZnNldCwgYzEub2Zmc2V0XTtcbiAgICAgICAgc2NhbGUyLnJhbmdlID0gW2MwLmNvbG9yLCBjMS5jb2xvcl07XG4gICAgICAgIGZvciAobGV0IG9mZnNldDQgPSBjMC5vZmZzZXQgKyBzdGVwOyBvZmZzZXQ0IDwgYzEub2Zmc2V0OyBvZmZzZXQ0ICs9IHN0ZXApIHtcbiAgICAgICAgICBncmFkaWVudDIuYWRkQ29sb3JTdG9wKG9mZnNldDQsIHNjYWxlMi5jb252ZXJ0KG9mZnNldDQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZ3JhZGllbnQyLmFkZENvbG9yU3RvcChjMS5vZmZzZXQsIGMxLmNvbG9yKTtcbiAgICAgIGMwID0gYzE7XG4gICAgfVxuICAgIGlmIChcImNyZWF0ZVBhdHRlcm5cIiBpbiBncmFkaWVudDIpIHtcbiAgICAgIGdyYWRpZW50MiA9IGdyYWRpZW50Mi5jcmVhdGVQYXR0ZXJuKCk7XG4gICAgfVxuICAgIHRoaXMuX2NhY2hlID0geyBjdHgsIGJib3gsIGdyYWRpZW50OiBncmFkaWVudDIgfTtcbiAgICByZXR1cm4gZ3JhZGllbnQyO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9ncmFkaWVudC9saW5lYXJHcmFkaWVudC50c1xudmFyIExpbmVhckdyYWRpZW50ID0gY2xhc3MgZXh0ZW5kcyBHcmFkaWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbG9yU3BhY2UsIHN0b3BzLCBhbmdsZTIgPSAwLCBiYm94KSB7XG4gICAgc3VwZXIoY29sb3JTcGFjZSwgc3RvcHMsIGJib3gpO1xuICAgIHRoaXMuYW5nbGUgPSBhbmdsZTI7XG4gIH1cbiAgY3JlYXRlQ2FudmFzR3JhZGllbnQoY3R4LCBiYm94KSB7XG4gICAgY29uc3QgYW5nbGVPZmZzZXQgPSA5MDtcbiAgICBjb25zdCB7IGFuZ2xlOiBhbmdsZTIgfSA9IHRoaXM7XG4gICAgY29uc3QgcmFkaWFucyA9IG5vcm1hbGl6ZUFuZ2xlMzYwKHRvUmFkaWFucyhhbmdsZTIgKyBhbmdsZU9mZnNldCkpO1xuICAgIGNvbnN0IGNvcyA9IE1hdGguY29zKHJhZGlhbnMpO1xuICAgIGNvbnN0IHNpbiA9IE1hdGguc2luKHJhZGlhbnMpO1xuICAgIGNvbnN0IHcgPSBiYm94LndpZHRoO1xuICAgIGNvbnN0IGggPSBiYm94LmhlaWdodDtcbiAgICBjb25zdCBjeCA9IGJib3gueCArIHcgKiAwLjU7XG4gICAgY29uc3QgY3kgPSBiYm94LnkgKyBoICogMC41O1xuICAgIGNvbnN0IGRpYWdvbmFsID0gTWF0aC5zcXJ0KGggKiBoICsgdyAqIHcpIC8gMjtcbiAgICBjb25zdCBkaWFnb25hbEFuZ2xlID0gTWF0aC5hdGFuMihoLCB3KTtcbiAgICBsZXQgcXVhcnRlcmVkQW5nbGU7XG4gICAgaWYgKHJhZGlhbnMgPCBNYXRoLlBJIC8gMikge1xuICAgICAgcXVhcnRlcmVkQW5nbGUgPSByYWRpYW5zO1xuICAgIH0gZWxzZSBpZiAocmFkaWFucyA8IE1hdGguUEkpIHtcbiAgICAgIHF1YXJ0ZXJlZEFuZ2xlID0gTWF0aC5QSSAtIHJhZGlhbnM7XG4gICAgfSBlbHNlIGlmIChyYWRpYW5zIDwgMS41ICogTWF0aC5QSSkge1xuICAgICAgcXVhcnRlcmVkQW5nbGUgPSByYWRpYW5zIC0gTWF0aC5QSTtcbiAgICB9IGVsc2Uge1xuICAgICAgcXVhcnRlcmVkQW5nbGUgPSAyICogTWF0aC5QSSAtIHJhZGlhbnM7XG4gICAgfVxuICAgIGNvbnN0IGwgPSBkaWFnb25hbCAqIE1hdGguYWJzKE1hdGguY29zKHF1YXJ0ZXJlZEFuZ2xlIC0gZGlhZ29uYWxBbmdsZSkpO1xuICAgIHJldHVybiBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoY3ggKyBjb3MgKiBsLCBjeSArIHNpbiAqIGwsIGN4IC0gY29zICogbCwgY3kgLSBzaW4gKiBsKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvc2hhcGUvc2hhcGUudHNcbnZhciBMSU5FQVJfR1JBRElFTlRfUkVHRVhQID0gL15saW5lYXItZ3JhZGllbnRcXCgoLT9bXFxkLl0rKWRlZywoLio/KVxcKSQvaTtcbnZhciBfU2hhcGUgPSBjbGFzcyBfU2hhcGUgZXh0ZW5kcyBOb2RlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmZpbGxPcGFjaXR5ID0gMTtcbiAgICB0aGlzLnN0cm9rZU9wYWNpdHkgPSAxO1xuICAgIHRoaXMuZmlsbCA9IF9TaGFwZS5kZWZhdWx0U3R5bGVzLmZpbGw7XG4gICAgdGhpcy5zdHJva2UgPSBfU2hhcGUuZGVmYXVsdFN0eWxlcy5zdHJva2U7XG4gICAgdGhpcy5zdHJva2VXaWR0aCA9IF9TaGFwZS5kZWZhdWx0U3R5bGVzLnN0cm9rZVdpZHRoO1xuICAgIHRoaXMubGluZURhc2ggPSBfU2hhcGUuZGVmYXVsdFN0eWxlcy5saW5lRGFzaDtcbiAgICB0aGlzLmxpbmVEYXNoT2Zmc2V0ID0gX1NoYXBlLmRlZmF1bHRTdHlsZXMubGluZURhc2hPZmZzZXQ7XG4gICAgdGhpcy5saW5lQ2FwID0gX1NoYXBlLmRlZmF1bHRTdHlsZXMubGluZUNhcDtcbiAgICB0aGlzLmxpbmVKb2luID0gX1NoYXBlLmRlZmF1bHRTdHlsZXMubGluZUpvaW47XG4gICAgdGhpcy5taXRlckxpbWl0ID0gdm9pZCAwO1xuICAgIHRoaXMub3BhY2l0eSA9IF9TaGFwZS5kZWZhdWx0U3R5bGVzLm9wYWNpdHk7XG4gICAgdGhpcy5maWxsU2hhZG93ID0gX1NoYXBlLmRlZmF1bHRTdHlsZXMuZmlsbFNoYWRvdztcbiAgfVxuICAvKipcbiAgICogUmVzdG9yZXMgdGhlIGRlZmF1bHQgc3R5bGVzIGludHJvZHVjZWQgYnkgdGhpcyBzdWJjbGFzcy5cbiAgICovXG4gIHJlc3RvcmVPd25TdHlsZXMoKSB7XG4gICAgY29uc3QgeyBkZWZhdWx0U3R5bGVzIH0gPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgZGVmYXVsdFN0eWxlcyk7XG4gIH1cbiAgb25GaWxsQ2hhbmdlKCkge1xuICAgIGNvbnN0IHsgZmlsbCB9ID0gdGhpcztcbiAgICBsZXQgbGluZWFyR3JhZGllbnRNYXRjaDtcbiAgICBpZiAoZmlsbCBpbnN0YW5jZW9mIEdyYWRpZW50KSB7XG4gICAgICB0aGlzLmdyYWRpZW50ID0gZmlsbDtcbiAgICB9IGVsc2UgaWYgKGZpbGw/LnN0YXJ0c1dpdGgoXCJsaW5lYXItZ3JhZGllbnRcIikgJiYgKGxpbmVhckdyYWRpZW50TWF0Y2ggPSBMSU5FQVJfR1JBRElFTlRfUkVHRVhQLmV4ZWMoZmlsbCkpKSB7XG4gICAgICBjb25zdCBhbmdsZTIgPSBwYXJzZUZsb2F0KGxpbmVhckdyYWRpZW50TWF0Y2hbMV0pO1xuICAgICAgY29uc3QgY29sb3JzID0gW107XG4gICAgICBjb25zdCBjb2xvcnNQYXJ0ID0gbGluZWFyR3JhZGllbnRNYXRjaFsyXTtcbiAgICAgIGNvbnN0IGNvbG9yUmVnZXggPSAvKCNbMC05YS1mXSspfChyZ2JhP1xcKC4rP1xcKSl8KFthLXpdKykvZ2k7XG4gICAgICBsZXQgYztcbiAgICAgIHdoaWxlIChjID0gY29sb3JSZWdleC5leGVjKGNvbG9yc1BhcnQpKSB7XG4gICAgICAgIGNvbG9ycy5wdXNoKGNbMF0pO1xuICAgICAgfVxuICAgICAgdGhpcy5ncmFkaWVudCA9IG5ldyBMaW5lYXJHcmFkaWVudChcbiAgICAgICAgXCJyZ2JcIixcbiAgICAgICAgY29sb3JzLm1hcCgoY29sb3IsIGluZGV4KSA9PiAoeyBjb2xvciwgb2Zmc2V0OiBpbmRleCAvIChjb2xvcnMubGVuZ3RoIC0gMSkgfSkpLFxuICAgICAgICBhbmdsZTJcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZ3JhZGllbnQgPSB2b2lkIDA7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgZGV2aWNlLXBpeGVsIGFsaWduZWQgY29vcmRpbmF0ZSAob3IgbGVuZ3RoIGlmIGxlbmd0aCBpcyBzdXBwbGllZCkuXG4gICAqXG4gICAqIE5PVEU6IE5vdCBzdWl0YWJsZSBmb3Igc3Ryb2tlcywgc2luY2UgdGhlIHN0cm9rZSBuZWVkcyB0byBiZSBvZmZzZXQgdG8gdGhlIG1pZGRsZVxuICAgKiBvZiBhIGRldmljZSBwaXhlbC5cbiAgICovXG4gIGFsaWduKHN0YXJ0MiwgbGVuZ3RoMikge1xuICAgIGNvbnN0IHBpeGVsUmF0aW8gPSB0aGlzLmxheWVyTWFuYWdlcj8uY2FudmFzPy5waXhlbFJhdGlvID8/IDE7XG4gICAgY29uc3QgYWxpZ25lZFN0YXJ0ID0gTWF0aC5yb3VuZChzdGFydDIgKiBwaXhlbFJhdGlvKSAvIHBpeGVsUmF0aW87XG4gICAgaWYgKGxlbmd0aDIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGFsaWduZWRTdGFydDtcbiAgICB9IGVsc2UgaWYgKGxlbmd0aDIgPT09IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSBpZiAobGVuZ3RoMiA8IDEpIHtcbiAgICAgIHJldHVybiBNYXRoLmNlaWwobGVuZ3RoMiAqIHBpeGVsUmF0aW8pIC8gcGl4ZWxSYXRpbztcbiAgICB9XG4gICAgcmV0dXJuIE1hdGgucm91bmQoKGxlbmd0aDIgKyBzdGFydDIpICogcGl4ZWxSYXRpbykgLyBwaXhlbFJhdGlvIC0gYWxpZ25lZFN0YXJ0O1xuICB9XG4gIGZpbGxTdHJva2UoY3R4LCBwYXRoKSB7XG4gICAgdGhpcy5yZW5kZXJGaWxsKGN0eCwgcGF0aCk7XG4gICAgdGhpcy5yZW5kZXJTdHJva2UoY3R4LCBwYXRoKTtcbiAgfVxuICByZW5kZXJGaWxsKGN0eCwgcGF0aCkge1xuICAgIGlmICh0aGlzLmZpbGwpIHtcbiAgICAgIGNvbnN0IHsgZ2xvYmFsQWxwaGEgfSA9IGN0eDtcbiAgICAgIHRoaXMuYXBwbHlGaWxsKGN0eCk7XG4gICAgICB0aGlzLmFwcGx5RmlsbEFscGhhKGN0eCk7XG4gICAgICB0aGlzLmFwcGx5U2hhZG93KGN0eCk7XG4gICAgICB0aGlzLmV4ZWN1dGVGaWxsKGN0eCwgcGF0aCk7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgPSBnbG9iYWxBbHBoYTtcbiAgICB9XG4gICAgY3R4LnNoYWRvd0NvbG9yID0gXCJyZ2JhKDAsIDAsIDAsIDApXCI7XG4gIH1cbiAgZXhlY3V0ZUZpbGwoY3R4LCBwYXRoKSB7XG4gICAgcGF0aCA/IGN0eC5maWxsKHBhdGgpIDogY3R4LmZpbGwoKTtcbiAgfVxuICBhcHBseUZpbGwoY3R4KSB7XG4gICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuZ3JhZGllbnQ/LmNyZWF0ZUdyYWRpZW50KGN0eCwgdGhpcy5nZXRCQm94KCkpID8/ICh0eXBlb2YgdGhpcy5maWxsID09PSBcInN0cmluZ1wiID8gdGhpcy5maWxsIDogdm9pZCAwKSA/PyBcImJsYWNrXCI7XG4gIH1cbiAgYXBwbHlGaWxsQWxwaGEoY3R4KSB7XG4gICAgY3R4Lmdsb2JhbEFscGhhICo9IHRoaXMub3BhY2l0eSAqIHRoaXMuZmlsbE9wYWNpdHk7XG4gIH1cbiAgYXBwbHlTaGFkb3coY3R4KSB7XG4gICAgY29uc3QgcGl4ZWxSYXRpbyA9IHRoaXMubGF5ZXJNYW5hZ2VyPy5jYW52YXMucGl4ZWxSYXRpbyA/PyAxO1xuICAgIGNvbnN0IGZpbGxTaGFkb3cgPSB0aGlzLmZpbGxTaGFkb3c7XG4gICAgaWYgKGZpbGxTaGFkb3c/LmVuYWJsZWQpIHtcbiAgICAgIGN0eC5zaGFkb3dDb2xvciA9IGZpbGxTaGFkb3cuY29sb3I7XG4gICAgICBjdHguc2hhZG93T2Zmc2V0WCA9IGZpbGxTaGFkb3cueE9mZnNldCAqIHBpeGVsUmF0aW87XG4gICAgICBjdHguc2hhZG93T2Zmc2V0WSA9IGZpbGxTaGFkb3cueU9mZnNldCAqIHBpeGVsUmF0aW87XG4gICAgICBjdHguc2hhZG93Qmx1ciA9IGZpbGxTaGFkb3cuYmx1ciAqIHBpeGVsUmF0aW87XG4gICAgfVxuICB9XG4gIHJlbmRlclN0cm9rZShjdHgsIHBhdGgpIHtcbiAgICBpZiAodGhpcy5zdHJva2UgJiYgdGhpcy5zdHJva2VXaWR0aCkge1xuICAgICAgY29uc3QgeyBnbG9iYWxBbHBoYSB9ID0gY3R4O1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5zdHJva2U7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgKj0gdGhpcy5vcGFjaXR5ICogdGhpcy5zdHJva2VPcGFjaXR5O1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuc3Ryb2tlV2lkdGg7XG4gICAgICBpZiAodGhpcy5saW5lRGFzaCkge1xuICAgICAgICBjdHguc2V0TGluZURhc2godGhpcy5saW5lRGFzaCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5saW5lRGFzaE9mZnNldCkge1xuICAgICAgICBjdHgubGluZURhc2hPZmZzZXQgPSB0aGlzLmxpbmVEYXNoT2Zmc2V0O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubGluZUNhcCkge1xuICAgICAgICBjdHgubGluZUNhcCA9IHRoaXMubGluZUNhcDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmxpbmVKb2luKSB7XG4gICAgICAgIGN0eC5saW5lSm9pbiA9IHRoaXMubGluZUpvaW47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5taXRlckxpbWl0ICE9IG51bGwpIHtcbiAgICAgICAgY3R4Lm1pdGVyTGltaXQgPSB0aGlzLm1pdGVyTGltaXQ7XG4gICAgICB9XG4gICAgICB0aGlzLmV4ZWN1dGVTdHJva2UoY3R4LCBwYXRoKTtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGdsb2JhbEFscGhhO1xuICAgIH1cbiAgfVxuICBleGVjdXRlU3Ryb2tlKGN0eCwgcGF0aCkge1xuICAgIHBhdGggPyBjdHguc3Ryb2tlKHBhdGgpIDogY3R4LnN0cm9rZSgpO1xuICB9XG4gIGNvbnRhaW5zUG9pbnQoeCwgeSkge1xuICAgIHJldHVybiB0aGlzLmlzUG9pbnRJblBhdGgoeCwgeSk7XG4gIH1cbn07XG4vKipcbiAqIERlZmF1bHRzIGZvciBzdHlsZSBwcm9wZXJ0aWVzLiBOb3RlIHRoYXQgcHJvcGVydGllcyB0aGF0IGFmZmVjdCB0aGUgcG9zaXRpb25cbiAqIGFuZCBzaGFwZSBvZiB0aGUgbm9kZSBhcmUgbm90IGNvbnNpZGVyZWQgc3R5bGUgcHJvcGVydGllcywgZm9yIGV4YW1wbGU6XG4gKiBgeGAsIGB5YCwgYHdpZHRoYCwgYGhlaWdodGAsIGByYWRpdXNgLCBgcm90YXRpb25gLCBldGMuXG4gKiBDYW4gYmUgdXNlZCB0byByZXNldCB0byB0aGUgb3JpZ2luYWwgc3R5bGluZyBhZnRlciBzb21lIGN1c3RvbSBzdHlsaW5nXG4gKiBoYXMgYmVlbiBhcHBsaWVkICh1c2luZyB0aGUgYHJlc3RvcmVPd25TdHlsZXNgIG1ldGhvZCkuXG4gKiBUaGVzZSBzdGF0aWMgZGVmYXVsdHMgYXJlIG1lYW50IHRvIGJlIGluaGVyaXRlZCBieSBzdWJjbGFzc2VzLlxuICovXG5fU2hhcGUuZGVmYXVsdFN0eWxlcyA9IHtcbiAgZmlsbDogXCJibGFja1wiLFxuICBzdHJva2U6IHZvaWQgMCxcbiAgc3Ryb2tlV2lkdGg6IDAsXG4gIGxpbmVEYXNoOiB2b2lkIDAsXG4gIGxpbmVEYXNoT2Zmc2V0OiAwLFxuICBsaW5lQ2FwOiB2b2lkIDAsXG4gIGxpbmVKb2luOiB2b2lkIDAsXG4gIG9wYWNpdHk6IDEsXG4gIGZpbGxTaGFkb3c6IHZvaWQgMFxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAyIC8qIE1JTk9SICovIH0pXG5dLCBfU2hhcGUucHJvdG90eXBlLCBcImZpbGxPcGFjaXR5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDIgLyogTUlOT1IgKi8gfSlcbl0sIF9TaGFwZS5wcm90b3R5cGUsIFwic3Ryb2tlT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAyIC8qIE1JTk9SICovLCBjaGFuZ2VDYjogKHMpID0+IHMub25GaWxsQ2hhbmdlKCkgfSlcbl0sIF9TaGFwZS5wcm90b3R5cGUsIFwiZmlsbFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAyIC8qIE1JTk9SICovIH0pXG5dLCBfU2hhcGUucHJvdG90eXBlLCBcInN0cm9rZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAyIC8qIE1JTk9SICovIH0pXG5dLCBfU2hhcGUucHJvdG90eXBlLCBcInN0cm9rZVdpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDIgLyogTUlOT1IgKi8gfSlcbl0sIF9TaGFwZS5wcm90b3R5cGUsIFwibGluZURhc2hcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMiAvKiBNSU5PUiAqLyB9KVxuXSwgX1NoYXBlLnByb3RvdHlwZSwgXCJsaW5lRGFzaE9mZnNldFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAyIC8qIE1JTk9SICovIH0pXG5dLCBfU2hhcGUucHJvdG90eXBlLCBcImxpbmVDYXBcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMiAvKiBNSU5PUiAqLyB9KVxuXSwgX1NoYXBlLnByb3RvdHlwZSwgXCJsaW5lSm9pblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAyIC8qIE1JTk9SICovIH0pXG5dLCBfU2hhcGUucHJvdG90eXBlLCBcIm1pdGVyTGltaXRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7XG4gICAgcmVkcmF3OiAyIC8qIE1JTk9SICovLFxuICAgIGNvbnZlcnRvcjogKHYpID0+IGNsYW1wKDAsIHYsIDEpXG4gIH0pXG5dLCBfU2hhcGUucHJvdG90eXBlLCBcIm9wYWNpdHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMiAvKiBNSU5PUiAqLywgY2hlY2tEaXJ0eU9uQXNzaWdubWVudDogdHJ1ZSB9KVxuXSwgX1NoYXBlLnByb3RvdHlwZSwgXCJmaWxsU2hhZG93XCIsIDIpO1xudmFyIFNoYXBlID0gX1NoYXBlO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9zaGFwZS9saW5lLnRzXG52YXIgTGluZSA9IGNsYXNzIGV4dGVuZHMgU2hhcGUge1xuICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICBzdXBlcihvcHRzKTtcbiAgICB0aGlzLngxID0gMDtcbiAgICB0aGlzLnkxID0gMDtcbiAgICB0aGlzLngyID0gMDtcbiAgICB0aGlzLnkyID0gMDtcbiAgICB0aGlzLnJlc3RvcmVPd25TdHlsZXMoKTtcbiAgfVxuICBzZXQgeCh2YWx1ZSkge1xuICAgIHRoaXMueDEgPSB2YWx1ZTtcbiAgICB0aGlzLngyID0gdmFsdWU7XG4gIH1cbiAgc2V0IHkodmFsdWUpIHtcbiAgICB0aGlzLnkxID0gdmFsdWU7XG4gICAgdGhpcy55MiA9IHZhbHVlO1xuICB9XG4gIGdldCBtaWRQb2ludCgpIHtcbiAgICByZXR1cm4geyB4OiAodGhpcy54MSArIHRoaXMueDIpIC8gMiwgeTogKHRoaXMueTEgKyB0aGlzLnkyKSAvIDIgfTtcbiAgfVxuICBjb21wdXRlQkJveCgpIHtcbiAgICByZXR1cm4gbmV3IEJCb3goXG4gICAgICBNYXRoLm1pbih0aGlzLngxLCB0aGlzLngyKSxcbiAgICAgIE1hdGgubWluKHRoaXMueTEsIHRoaXMueTIpLFxuICAgICAgTWF0aC5hYnModGhpcy54MiAtIHRoaXMueDEpLFxuICAgICAgTWF0aC5hYnModGhpcy55MiAtIHRoaXMueTEpXG4gICAgKTtcbiAgfVxuICBpc1BvaW50SW5QYXRoKHgsIHkpIHtcbiAgICBpZiAodGhpcy54MSA9PT0gdGhpcy54MiB8fCB0aGlzLnkxID09PSB0aGlzLnkyKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRCQm94KCkuY2xvbmUoKS5ncm93KHRoaXMuc3Ryb2tlV2lkdGggLyAyKS5jb250YWluc1BvaW50KHgsIHkpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZGlzdGFuY2VTcXVhcmVkKHB4LCBweSkge1xuICAgIGNvbnN0IHsgeDEsIHkxLCB4MiwgeTIgfSA9IHRoaXM7XG4gICAgcmV0dXJuIGxpbmVEaXN0YW5jZVNxdWFyZWQocHgsIHB5LCB4MSwgeTEsIHgyLCB5MiwgSW5maW5pdHkpO1xuICB9XG4gIHJlbmRlcihyZW5kZXJDdHgpIHtcbiAgICBjb25zdCB7IGN0eCwgZm9yY2VSZW5kZXIsIHN0YXRzLCBkZXZpY2VQaXhlbFJhdGlvIH0gPSByZW5kZXJDdHg7XG4gICAgaWYgKHRoaXMuZGlydHkgPT09IDAgLyogTk9ORSAqLyAmJiAhZm9yY2VSZW5kZXIpIHtcbiAgICAgIGlmIChzdGF0cylcbiAgICAgICAgc3RhdHMubm9kZXNTa2lwcGVkICs9IG5vZGVDb3VudCh0aGlzKS5jb3VudDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHsgeDEsIHkxLCB4MiwgeTIgfSA9IHRoaXM7XG4gICAgaWYgKHgxID09PSB4Mikge1xuICAgICAgY29uc3QgeyBzdHJva2VXaWR0aCB9ID0gdGhpcztcbiAgICAgIGNvbnN0IHggPSBNYXRoLnJvdW5kKHgxICogZGV2aWNlUGl4ZWxSYXRpbykgLyBkZXZpY2VQaXhlbFJhdGlvICsgTWF0aC50cnVuYyhzdHJva2VXaWR0aCAqIGRldmljZVBpeGVsUmF0aW8pICUgMiAvIChkZXZpY2VQaXhlbFJhdGlvICogMik7XG4gICAgICB4MSA9IHg7XG4gICAgICB4MiA9IHg7XG4gICAgfSBlbHNlIGlmICh5MSA9PT0geTIpIHtcbiAgICAgIGNvbnN0IHsgc3Ryb2tlV2lkdGggfSA9IHRoaXM7XG4gICAgICBjb25zdCB5ID0gTWF0aC5yb3VuZCh5MSAqIGRldmljZVBpeGVsUmF0aW8pIC8gZGV2aWNlUGl4ZWxSYXRpbyArIE1hdGgudHJ1bmMoc3Ryb2tlV2lkdGggKiBkZXZpY2VQaXhlbFJhdGlvKSAlIDIgLyAoZGV2aWNlUGl4ZWxSYXRpbyAqIDIpO1xuICAgICAgeTEgPSB5O1xuICAgICAgeTIgPSB5O1xuICAgIH1cbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4Lm1vdmVUbyh4MSwgeTEpO1xuICAgIGN0eC5saW5lVG8oeDIsIHkyKTtcbiAgICB0aGlzLmZpbGxTdHJva2UoY3R4KTtcbiAgICB0aGlzLmZpbGxTaGFkb3c/Lm1hcmtDbGVhbigpO1xuICAgIHN1cGVyLnJlbmRlcihyZW5kZXJDdHgpO1xuICB9XG4gIHRvU1ZHKCkge1xuICAgIGlmICghdGhpcy52aXNpYmxlKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGVsZW1lbnQyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJsaW5lXCIpO1xuICAgIGVsZW1lbnQyLnNldEF0dHJpYnV0ZShcIngxXCIsIFN0cmluZyh0aGlzLngxKSk7XG4gICAgZWxlbWVudDIuc2V0QXR0cmlidXRlKFwieTFcIiwgU3RyaW5nKHRoaXMueTEpKTtcbiAgICBlbGVtZW50Mi5zZXRBdHRyaWJ1dGUoXCJ4MlwiLCBTdHJpbmcodGhpcy54MikpO1xuICAgIGVsZW1lbnQyLnNldEF0dHJpYnV0ZShcInkyXCIsIFN0cmluZyh0aGlzLnkyKSk7XG4gICAgZWxlbWVudDIuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIHRoaXMuc3Ryb2tlID8/IFwibm9uZVwiKTtcbiAgICBlbGVtZW50Mi5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utb3BhY2l0eVwiLCBTdHJpbmcodGhpcy5zdHJva2VPcGFjaXR5KSk7XG4gICAgZWxlbWVudDIuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsIFN0cmluZyh0aGlzLnN0cm9rZVdpZHRoKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVsZW1lbnRzOiBbZWxlbWVudDJdXG4gICAgfTtcbiAgfVxufTtcbkxpbmUuY2xhc3NOYW1lID0gXCJMaW5lXCI7XG5MaW5lLmRlZmF1bHRTdHlsZXMgPSB7IC4uLlNoYXBlLmRlZmF1bHRTdHlsZXMsIGZpbGw6IHZvaWQgMCwgc3Ryb2tlV2lkdGg6IDEgfTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBMaW5lLnByb3RvdHlwZSwgXCJ4MVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBMaW5lLnByb3RvdHlwZSwgXCJ5MVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBMaW5lLnByb3RvdHlwZSwgXCJ4MlwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBMaW5lLnByb3RvdHlwZSwgXCJ5MlwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9jYW52YXMudXRpbC50c1xuZnVuY3Rpb24gY3JlYXRlQ2FudmFzQ29udGV4dCh3aWR0aDIgPSAwLCBoZWlnaHQyID0gMCkge1xuICBjb25zdCBjYW52YXMgPSBjcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICBjYW52YXMuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgY2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGgyICsgXCJweFwiO1xuICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0MiArIFwicHhcIjtcbiAgcmV0dXJuIGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvbHJ1Q2FjaGUudHNcbnZhciBMUlVDYWNoZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IobWF4Q2FjaGVTaXplID0gNSkge1xuICAgIHRoaXMubWF4Q2FjaGVTaXplID0gbWF4Q2FjaGVTaXplO1xuICAgIHRoaXMuc3RvcmUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIGdldChrZXkpIHtcbiAgICBpZiAoIXRoaXMuc3RvcmUuaGFzKGtleSkpXG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIGNvbnN0IGhpdCA9IHRoaXMuc3RvcmUuZ2V0KGtleSk7XG4gICAgdGhpcy5zdG9yZS5kZWxldGUoa2V5KTtcbiAgICB0aGlzLnN0b3JlLnNldChrZXksIGhpdCk7XG4gICAgcmV0dXJuIGhpdDtcbiAgfVxuICBoYXMoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuc3RvcmUuaGFzKGtleSk7XG4gIH1cbiAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLnN0b3JlLnNldChrZXksIHZhbHVlKTtcbiAgICBpZiAodGhpcy5zdG9yZS5zaXplID4gdGhpcy5tYXhDYWNoZVNpemUpIHtcbiAgICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5zdG9yZS5rZXlzKCk7XG4gICAgICBsZXQgZXZpY3RDb3VudCA9IHRoaXMuc3RvcmUuc2l6ZSAtIHRoaXMubWF4Q2FjaGVTaXplO1xuICAgICAgd2hpbGUgKGV2aWN0Q291bnQgPiAwKSB7XG4gICAgICAgIGNvbnN0IGV2aWN0S2V5SXRlcmF0b3IgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmICghZXZpY3RLZXlJdGVyYXRvci5kb25lKSB7XG4gICAgICAgICAgdGhpcy5zdG9yZS5kZWxldGUoZXZpY3RLZXlJdGVyYXRvci52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZXZpY3RDb3VudC0tO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5zdG9yZS5jbGVhcigpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3RleHRNZWFzdXJlci50c1xudmFyIENhY2hlZFRleHRNZWFzdXJlclBvb2wgPSBjbGFzcyB7XG4gIC8vIE1lYXN1cmVzIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBwcm92aWRlZCB0ZXh0LCBoYW5kbGluZyBtdWx0aWxpbmUgaWYgbmVlZGVkLlxuICBzdGF0aWMgbWVhc3VyZVRleHQodGV4dCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHRleHRNZWFzdXJlciA9IHRoaXMuZ2V0TWVhc3VyZXIob3B0aW9ucyk7XG4gICAgcmV0dXJuIHRleHRNZWFzdXJlci5tZWFzdXJlVGV4dCh0ZXh0KTtcbiAgfVxuICBzdGF0aWMgbWVhc3VyZUxpbmVzKHRleHQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0ZXh0TWVhc3VyZXIgPSB0aGlzLmdldE1lYXN1cmVyKG9wdGlvbnMpO1xuICAgIHJldHVybiB0ZXh0TWVhc3VyZXIubWVhc3VyZUxpbmVzKHRleHQpO1xuICB9XG4gIC8vIEdldHMgYSBUZXh0TWVhc3VyZXIgaW5zdGFuY2UsIGNvbmZpZ3VyaW5nIHRleHQgYWxpZ25tZW50IGFuZCBiYXNlbGluZSBpZiBwcm92aWRlZC5cbiAgc3RhdGljIGdldE1lYXN1cmVyKG9wdGlvbnMpIHtcbiAgICBjb25zdCBmb250ID0gdHlwZW9mIG9wdGlvbnMuZm9udCA9PT0gXCJzdHJpbmdcIiA/IG9wdGlvbnMuZm9udCA6IFRleHRVdGlscy50b0ZvbnRTdHJpbmcob3B0aW9ucy5mb250KTtcbiAgICBjb25zdCBrZXkgPSBgJHtmb250fS0ke29wdGlvbnMudGV4dEFsaWduID8/IFwic3RhcnRcIn0tJHtvcHRpb25zLnRleHRCYXNlbGluZSA/PyBcImFscGhhYmV0aWNcIn1gO1xuICAgIHJldHVybiB0aGlzLmluc3RhbmNlTWFwLmdldChrZXkpID8/IHRoaXMuY3JlYXRlRm9udE1lYXN1cmVyKGZvbnQsIG9wdGlvbnMsIGtleSk7XG4gIH1cbiAgLy8gQ3JlYXRlcyBvciByZXRyaWV2ZXMgYSBUZXh0TWVhc3VyZXIgaW5zdGFuY2UgZm9yIGEgc3BlY2lmaWMgZm9udC5cbiAgc3RhdGljIGNyZWF0ZUZvbnRNZWFzdXJlcihmb250LCBvcHRpb25zLCBrZXkpIHtcbiAgICBjb25zdCBjdHggPSBjcmVhdGVDYW52YXNDb250ZXh0KCk7XG4gICAgY3R4LmZvbnQgPSBmb250O1xuICAgIGN0eC50ZXh0QWxpZ24gPSBvcHRpb25zLnRleHRBbGlnbiA/PyBcInN0YXJ0XCI7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9IG9wdGlvbnMudGV4dEJhc2VsaW5lID8/IFwiYWxwaGFiZXRpY1wiO1xuICAgIGNvbnN0IG1lYXN1cmVyID0gbmV3IENhY2hlZFRleHRNZWFzdXJlcihjdHgsIG9wdGlvbnMpO1xuICAgIHRoaXMuaW5zdGFuY2VNYXAuc2V0KGtleSwgbWVhc3VyZXIpO1xuICAgIHJldHVybiBtZWFzdXJlcjtcbiAgfVxufTtcbkNhY2hlZFRleHRNZWFzdXJlclBvb2wuaW5zdGFuY2VNYXAgPSBuZXcgTFJVQ2FjaGUoMTApO1xudmFyIENhY2hlZFRleHRNZWFzdXJlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY3R4LCBvcHRpb25zKSB7XG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgLy8gY2FjaGVkIHRleHQgbWVhc3VyZW1lbnRzXG4gICAgdGhpcy5tZWFzdXJlTWFwID0gbmV3IExSVUNhY2hlKDEwMCk7XG4gICAgaWYgKG9wdGlvbnMudGV4dEFsaWduKSB7XG4gICAgICBjdHgudGV4dEFsaWduID0gb3B0aW9ucy50ZXh0QWxpZ247XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnRleHRCYXNlbGluZSkge1xuICAgICAgY3R4LnRleHRCYXNlbGluZSA9IG9wdGlvbnMudGV4dEJhc2VsaW5lO1xuICAgIH1cbiAgICBjdHguZm9udCA9IHR5cGVvZiBvcHRpb25zLmZvbnQgPT09IFwic3RyaW5nXCIgPyBvcHRpb25zLmZvbnQgOiBUZXh0VXRpbHMudG9Gb250U3RyaW5nKG9wdGlvbnMuZm9udCk7XG4gICAgdGhpcy50ZXh0TWVhc3VyZXIgPSBuZXcgU2ltcGxlVGV4dE1lYXN1cmVyKFxuICAgICAgKHQpID0+IHRoaXMuY2FjaGVkQ3R4TWVhc3VyZVRleHQodCksXG4gICAgICBvcHRpb25zLnRleHRCYXNlbGluZSA/PyBcImFscGhhYmV0aWNcIlxuICAgICk7XG4gIH1cbiAgdGV4dFdpZHRoKHRleHQsIGVzdGltYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dE1lYXN1cmVyLnRleHRXaWR0aCh0ZXh0LCBlc3RpbWF0ZSk7XG4gIH1cbiAgbWVhc3VyZVRleHQodGV4dCkge1xuICAgIHJldHVybiB0aGlzLnRleHRNZWFzdXJlci5tZWFzdXJlVGV4dCh0ZXh0KTtcbiAgfVxuICBtZWFzdXJlTGluZXModGV4dCkge1xuICAgIHJldHVybiB0aGlzLnRleHRNZWFzdXJlci5tZWFzdXJlTGluZXModGV4dCk7XG4gIH1cbiAgY2FjaGVkQ3R4TWVhc3VyZVRleHQodGV4dCkge1xuICAgIGlmICghdGhpcy5tZWFzdXJlTWFwLmhhcyh0ZXh0KSkge1xuICAgICAgY29uc3QgcmF3UmVzdWx0ID0gdGhpcy5jdHgubWVhc3VyZVRleHQodGV4dCk7XG4gICAgICB0aGlzLm1lYXN1cmVNYXAuc2V0KHRleHQsIHtcbiAgICAgICAgYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQ6IHJhd1Jlc3VsdC5hY3R1YWxCb3VuZGluZ0JveEFzY2VudCxcbiAgICAgICAgZW1IZWlnaHRBc2NlbnQ6IHJhd1Jlc3VsdC5lbUhlaWdodEFzY2VudCxcbiAgICAgICAgZW1IZWlnaHREZXNjZW50OiByYXdSZXN1bHQuZW1IZWlnaHREZXNjZW50LFxuICAgICAgICBhY3R1YWxCb3VuZGluZ0JveERlc2NlbnQ6IHJhd1Jlc3VsdC5hY3R1YWxCb3VuZGluZ0JveERlc2NlbnQsXG4gICAgICAgIGFjdHVhbEJvdW5kaW5nQm94TGVmdDogcmF3UmVzdWx0LmFjdHVhbEJvdW5kaW5nQm94TGVmdCxcbiAgICAgICAgYWN0dWFsQm91bmRpbmdCb3hSaWdodDogcmF3UmVzdWx0LmFjdHVhbEJvdW5kaW5nQm94UmlnaHQsXG4gICAgICAgIGFscGhhYmV0aWNCYXNlbGluZTogcmF3UmVzdWx0LmFscGhhYmV0aWNCYXNlbGluZSxcbiAgICAgICAgZm9udEJvdW5kaW5nQm94QXNjZW50OiByYXdSZXN1bHQuZm9udEJvdW5kaW5nQm94QXNjZW50LFxuICAgICAgICBmb250Qm91bmRpbmdCb3hEZXNjZW50OiByYXdSZXN1bHQuZm9udEJvdW5kaW5nQm94RGVzY2VudCxcbiAgICAgICAgaGFuZ2luZ0Jhc2VsaW5lOiByYXdSZXN1bHQuaGFuZ2luZ0Jhc2VsaW5lLFxuICAgICAgICBpZGVvZ3JhcGhpY0Jhc2VsaW5lOiByYXdSZXN1bHQuaWRlb2dyYXBoaWNCYXNlbGluZSxcbiAgICAgICAgd2lkdGg6IHJhd1Jlc3VsdC53aWR0aFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1lYXN1cmVNYXAuZ2V0KHRleHQpO1xuICB9XG59O1xudmFyIFRleHRVdGlscyA9IGNsYXNzIHtcbiAgc3RhdGljIHRvRm9udFN0cmluZyh7IGZvbnRTaXplID0gMTAsIGZvbnRTdHlsZSwgZm9udFdlaWdodCwgZm9udEZhbWlseSwgbGluZUhlaWdodCB9KSB7XG4gICAgbGV0IGZvbnRTdHJpbmcgPSBcIlwiO1xuICAgIGlmIChmb250U3R5bGUpIHtcbiAgICAgIGZvbnRTdHJpbmcgKz0gYCR7Zm9udFN0eWxlfSBgO1xuICAgIH1cbiAgICBpZiAoZm9udFdlaWdodCkge1xuICAgICAgZm9udFN0cmluZyArPSBgJHtmb250V2VpZ2h0fSBgO1xuICAgIH1cbiAgICBmb250U3RyaW5nICs9IGAke2ZvbnRTaXplfXB4YDtcbiAgICBpZiAobGluZUhlaWdodCkge1xuICAgICAgZm9udFN0cmluZyArPSBgLyR7bGluZUhlaWdodH1weGA7XG4gICAgfVxuICAgIGZvbnRTdHJpbmcgKz0gYCAke2ZvbnRGYW1pbHl9YDtcbiAgICByZXR1cm4gZm9udFN0cmluZy50cmltKCk7XG4gIH1cbiAgc3RhdGljIGdldExpbmVIZWlnaHQoZm9udFNpemUpIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKGZvbnRTaXplICogdGhpcy5kZWZhdWx0TGluZUhlaWdodCk7XG4gIH1cbiAgLy8gRGV0ZXJtaW5lcyB2ZXJ0aWNhbCBvZmZzZXQgbW9kaWZpZXIgYmFzZWQgb24gdGV4dCBiYXNlbGluZS5cbiAgc3RhdGljIGdldFZlcnRpY2FsTW9kaWZpZXIodGV4dEJhc2VsaW5lKSB7XG4gICAgc3dpdGNoICh0ZXh0QmFzZWxpbmUpIHtcbiAgICAgIGNhc2UgXCJoYW5naW5nXCI6XG4gICAgICBjYXNlIFwidG9wXCI6XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgY2FzZSBcIm1pZGRsZVwiOlxuICAgICAgICByZXR1cm4gMC41O1xuICAgICAgY2FzZSBcImFscGhhYmV0aWNcIjpcbiAgICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgIGNhc2UgXCJpZGVvZ3JhcGhpY1wiOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9XG59O1xuVGV4dFV0aWxzLkVsbGlwc2lzQ2hhciA9IFwiXFx1MjAyNlwiO1xuLy8gUmVwcmVzZW50YXRpb24gZm9yIHRleHQgY2xpcHBpbmcuXG5UZXh0VXRpbHMuZGVmYXVsdExpbmVIZWlnaHQgPSAxLjE1O1xuLy8gTm9ybWFsbHkgYmV0d2VlbiAxLjEgYW5kIDEuMlxuVGV4dFV0aWxzLmxpbmVTcGxpdHRlciA9IC9cXHI/XFxuL2c7XG52YXIgU2ltcGxlVGV4dE1lYXN1cmVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihtZWFzdXJlVGV4dEZuLCB0ZXh0QmFzZWxpbmUgPSBcImFscGhhYmV0aWNcIikge1xuICAgIHRoaXMubWVhc3VyZVRleHRGbiA9IG1lYXN1cmVUZXh0Rm47XG4gICAgdGhpcy50ZXh0QmFzZWxpbmUgPSB0ZXh0QmFzZWxpbmU7XG4gICAgLy8gbG9jYWwgY2hhcnMgd2lkdGggY2FjaGUgcGVyIFRleHRNZWFzdXJlclxuICAgIHRoaXMuY2hhck1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgLy8gTWVhc3VyZXMgbWV0cmljcyBmb3IgYSBzaW5nbGUgbGluZSBvZiB0ZXh0LlxuICBnZXRNZXRyaWNzKHRleHQpIHtcbiAgICBjb25zdCBtID0gdGhpcy5tZWFzdXJlVGV4dEZuKHRleHQpO1xuICAgIG0uZm9udEJvdW5kaW5nQm94QXNjZW50ID8/IChtLmZvbnRCb3VuZGluZ0JveEFzY2VudCA9IG0uZW1IZWlnaHRBc2NlbnQpO1xuICAgIG0uZm9udEJvdW5kaW5nQm94RGVzY2VudCA/PyAobS5mb250Qm91bmRpbmdCb3hEZXNjZW50ID0gbS5lbUhlaWdodERlc2NlbnQpO1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogbS53aWR0aCxcbiAgICAgIGhlaWdodDogbS5hY3R1YWxCb3VuZGluZ0JveEFzY2VudCArIG0uYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50LFxuICAgICAgbGluZUhlaWdodDogbS5mb250Qm91bmRpbmdCb3hBc2NlbnQgKyBtLmZvbnRCb3VuZGluZ0JveERlc2NlbnQsXG4gICAgICBvZmZzZXRUb3A6IG0uYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQsXG4gICAgICBvZmZzZXRMZWZ0OiBtLmFjdHVhbEJvdW5kaW5nQm94TGVmdFxuICAgIH07XG4gIH1cbiAgLy8gQ2FsY3VsYXRlcyBhZ2dyZWdhdGVkIG1ldHJpY3MgZm9yIG11bHRpbGluZSB0ZXh0LlxuICBnZXRNdWx0aWxpbmVNZXRyaWNzKGxpbmVzKSB7XG4gICAgbGV0IHdpZHRoMiA9IDA7XG4gICAgbGV0IGhlaWdodDIgPSAwO1xuICAgIGxldCBvZmZzZXRUb3AgPSAwO1xuICAgIGxldCBvZmZzZXRMZWZ0ID0gMDtcbiAgICBsZXQgYmFzZWxpbmVEaXN0YW5jZSA9IDA7XG4gICAgY29uc3QgdmVydGljYWxNb2RpZmllciA9IFRleHRVdGlscy5nZXRWZXJ0aWNhbE1vZGlmaWVyKHRoaXMudGV4dEJhc2VsaW5lKTtcbiAgICBjb25zdCBsaW5lTWV0cmljcyA9IFtdO1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgY29uc3QgbGVuZ3RoMiA9IGxpbmVzLmxlbmd0aDtcbiAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcbiAgICAgIGNvbnN0IG0gPSB0aGlzLm1lYXN1cmVUZXh0Rm4obGluZSk7XG4gICAgICBtLmZvbnRCb3VuZGluZ0JveEFzY2VudCA/PyAobS5mb250Qm91bmRpbmdCb3hBc2NlbnQgPSBtLmVtSGVpZ2h0QXNjZW50KTtcbiAgICAgIG0uZm9udEJvdW5kaW5nQm94RGVzY2VudCA/PyAobS5mb250Qm91bmRpbmdCb3hEZXNjZW50ID0gbS5lbUhlaWdodERlc2NlbnQpO1xuICAgICAgaWYgKHdpZHRoMiA8IG0ud2lkdGgpIHtcbiAgICAgICAgd2lkdGgyID0gbS53aWR0aDtcbiAgICAgIH1cbiAgICAgIGlmIChvZmZzZXRMZWZ0IDwgbS5hY3R1YWxCb3VuZGluZ0JveExlZnQpIHtcbiAgICAgICAgb2Zmc2V0TGVmdCA9IG0uYWN0dWFsQm91bmRpbmdCb3hMZWZ0O1xuICAgICAgfVxuICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgIGhlaWdodDIgKz0gbS5hY3R1YWxCb3VuZGluZ0JveEFzY2VudDtcbiAgICAgICAgb2Zmc2V0VG9wICs9IG0uYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYXNlbGluZURpc3RhbmNlICs9IG0uZm9udEJvdW5kaW5nQm94QXNjZW50O1xuICAgICAgfVxuICAgICAgaWYgKGluZGV4ID09PSBsZW5ndGgyIC0gMSkge1xuICAgICAgICBoZWlnaHQyICs9IG0uYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFzZWxpbmVEaXN0YW5jZSArPSBtLmZvbnRCb3VuZGluZ0JveERlc2NlbnQ7XG4gICAgICB9XG4gICAgICBsaW5lTWV0cmljcy5wdXNoKHtcbiAgICAgICAgdGV4dDogbGluZSxcbiAgICAgICAgd2lkdGg6IG0ud2lkdGgsXG4gICAgICAgIGhlaWdodDogbS5hY3R1YWxCb3VuZGluZ0JveEFzY2VudCArIG0uYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50LFxuICAgICAgICBsaW5lSGVpZ2h0OiBtLmZvbnRCb3VuZGluZ0JveEFzY2VudCArIG0uZm9udEJvdW5kaW5nQm94RGVzY2VudCxcbiAgICAgICAgb2Zmc2V0VG9wOiBtLmFjdHVhbEJvdW5kaW5nQm94QXNjZW50LFxuICAgICAgICBvZmZzZXRMZWZ0OiBtLmFjdHVhbEJvdW5kaW5nQm94TGVmdFxuICAgICAgfSk7XG4gICAgICBpbmRleCsrO1xuICAgIH1cbiAgICBoZWlnaHQyICs9IGJhc2VsaW5lRGlzdGFuY2U7XG4gICAgb2Zmc2V0VG9wICs9IGJhc2VsaW5lRGlzdGFuY2UgKiB2ZXJ0aWNhbE1vZGlmaWVyO1xuICAgIHJldHVybiB7IHdpZHRoOiB3aWR0aDIsIGhlaWdodDogaGVpZ2h0Miwgb2Zmc2V0VG9wLCBvZmZzZXRMZWZ0LCBsaW5lTWV0cmljcyB9O1xuICB9XG4gIHRleHRXaWR0aCh0ZXh0LCBlc3RpbWF0ZSkge1xuICAgIGlmIChlc3RpbWF0ZSkge1xuICAgICAgbGV0IGVzdGltYXRlZFdpZHRoID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICBlc3RpbWF0ZWRXaWR0aCArPSB0aGlzLnRleHRXaWR0aCh0ZXh0LmNoYXJBdChpKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXN0aW1hdGVkV2lkdGg7XG4gICAgfVxuICAgIGlmICh0ZXh0Lmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVybiB0aGlzLm1lYXN1cmVUZXh0Rm4odGV4dCkud2lkdGg7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNoYXJNYXAuZ2V0KHRleHQpID8/IHRoaXMuY2hhcldpZHRoKHRleHQpO1xuICB9XG4gIG1lYXN1cmVUZXh0KHRleHQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRNZXRyaWNzKHRleHQpO1xuICB9XG4gIC8vIE1lYXN1cmVzIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBwcm92aWRlZCB0ZXh0LCBoYW5kbGluZyBtdWx0aWxpbmUgaWYgbmVlZGVkLlxuICBtZWFzdXJlTGluZXModGV4dCkge1xuICAgIGNvbnN0IGxpbmVzID0gdHlwZW9mIHRleHQgPT09IFwic3RyaW5nXCIgPyB0ZXh0LnNwbGl0KFRleHRVdGlscy5saW5lU3BsaXR0ZXIpIDogdGV4dDtcbiAgICByZXR1cm4gdGhpcy5nZXRNdWx0aWxpbmVNZXRyaWNzKGxpbmVzKTtcbiAgfVxuICBjaGFyV2lkdGgoY2hhcikge1xuICAgIGNvbnN0IHsgd2lkdGg6IHdpZHRoMiB9ID0gdGhpcy5tZWFzdXJlVGV4dEZuKGNoYXIpO1xuICAgIHRoaXMuY2hhck1hcC5zZXQoY2hhciwgd2lkdGgyKTtcbiAgICByZXR1cm4gd2lkdGgyO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9zaGFwZS90ZXh0LnRzXG52YXIgX1RleHQgPSBjbGFzcyBfVGV4dCBleHRlbmRzIFNoYXBlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gICAgdGhpcy5saW5lcyA9IFtdO1xuICAgIHRoaXMudGV4dCA9IHZvaWQgMDtcbiAgICB0aGlzLmZvbnRTaXplID0gMTA7XG4gICAgdGhpcy5mb250RmFtaWx5ID0gXCJzYW5zLXNlcmlmXCI7XG4gICAgdGhpcy50ZXh0QWxpZ24gPSBfVGV4dC5kZWZhdWx0U3R5bGVzLnRleHRBbGlnbjtcbiAgICB0aGlzLnRleHRCYXNlbGluZSA9IF9UZXh0LmRlZmF1bHRTdHlsZXMudGV4dEJhc2VsaW5lO1xuICB9XG4gIG9uVGV4dENoYW5nZSgpIHtcbiAgICB0aGlzLmxpbmVzID0gdGhpcy50ZXh0Py5zcGxpdChcIlxcblwiKS5tYXAoKHMpID0+IHMudHJpbSgpKSA/PyBbXTtcbiAgfVxuICBzdGF0aWMgY29tcHV0ZUJCb3gobGluZXMsIHgsIHksIG9wdHMpIHtcbiAgICBjb25zdCB7IG9mZnNldFRvcCwgb2Zmc2V0TGVmdCwgd2lkdGg6IHdpZHRoMiwgaGVpZ2h0OiBoZWlnaHQyIH0gPSBDYWNoZWRUZXh0TWVhc3VyZXJQb29sLm1lYXN1cmVMaW5lcyhsaW5lcywgb3B0cyk7XG4gICAgcmV0dXJuIG5ldyBCQm94KHggLSBvZmZzZXRMZWZ0LCB5IC0gb2Zmc2V0VG9wLCB3aWR0aDIsIGhlaWdodDIpO1xuICB9XG4gIGNvbXB1dGVCQm94KCkge1xuICAgIGNvbnN0IHsgeCwgeSwgbGluZXMsIHRleHRCYXNlbGluZSwgdGV4dEFsaWduIH0gPSB0aGlzO1xuICAgIHJldHVybiBfVGV4dC5jb21wdXRlQkJveChsaW5lcywgeCwgeSwgeyBmb250OiB0aGlzLCB0ZXh0QmFzZWxpbmUsIHRleHRBbGlnbiB9KTtcbiAgfVxuICBpc1BvaW50SW5QYXRoKHgsIHkpIHtcbiAgICBjb25zdCBiYm94ID0gdGhpcy5nZXRCQm94KCk7XG4gICAgcmV0dXJuIGJib3ggPyBiYm94LmNvbnRhaW5zUG9pbnQoeCwgeSkgOiBmYWxzZTtcbiAgfVxuICByZW5kZXIocmVuZGVyQ3R4KSB7XG4gICAgY29uc3QgeyBjdHgsIGZvcmNlUmVuZGVyLCBzdGF0cyB9ID0gcmVuZGVyQ3R4O1xuICAgIGlmICh0aGlzLmRpcnR5ID09PSAwIC8qIE5PTkUgKi8gJiYgIWZvcmNlUmVuZGVyKSB7XG4gICAgICBpZiAoc3RhdHMpXG4gICAgICAgIHN0YXRzLm5vZGVzU2tpcHBlZCArPSBub2RlQ291bnQodGhpcykuY291bnQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5saW5lcy5sZW5ndGggfHwgIXRoaXMubGF5ZXJNYW5hZ2VyKSB7XG4gICAgICBpZiAoc3RhdHMpXG4gICAgICAgIHN0YXRzLm5vZGVzU2tpcHBlZCArPSBub2RlQ291bnQodGhpcykuY291bnQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgZmlsbCwgc3Ryb2tlLCBzdHJva2VXaWR0aCB9ID0gdGhpcztcbiAgICBjb25zdCB7IHBpeGVsUmF0aW8gfSA9IHRoaXMubGF5ZXJNYW5hZ2VyLmNhbnZhcztcbiAgICBjdHguZm9udCA9IFRleHRVdGlscy50b0ZvbnRTdHJpbmcodGhpcyk7XG4gICAgY3R4LnRleHRBbGlnbiA9IHRoaXMudGV4dEFsaWduO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSB0aGlzLnRleHRCYXNlbGluZTtcbiAgICBpZiAoZmlsbCkge1xuICAgICAgdGhpcy5hcHBseUZpbGwoY3R4KTtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSAqPSB0aGlzLm9wYWNpdHkgKiB0aGlzLmZpbGxPcGFjaXR5O1xuICAgICAgY29uc3QgeyBmaWxsU2hhZG93IH0gPSB0aGlzO1xuICAgICAgaWYgKGZpbGxTaGFkb3c/LmVuYWJsZWQpIHtcbiAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gZmlsbFNoYWRvdy5jb2xvcjtcbiAgICAgICAgY3R4LnNoYWRvd09mZnNldFggPSBmaWxsU2hhZG93LnhPZmZzZXQgKiBwaXhlbFJhdGlvO1xuICAgICAgICBjdHguc2hhZG93T2Zmc2V0WSA9IGZpbGxTaGFkb3cueU9mZnNldCAqIHBpeGVsUmF0aW87XG4gICAgICAgIGN0eC5zaGFkb3dCbHVyID0gZmlsbFNoYWRvdy5ibHVyICogcGl4ZWxSYXRpbztcbiAgICAgIH1cbiAgICAgIHRoaXMucmVuZGVyTGluZXMoKGxpbmUsIHgsIHkpID0+IGN0eC5maWxsVGV4dChsaW5lLCB4LCB5KSk7XG4gICAgfVxuICAgIGlmIChzdHJva2UgJiYgc3Ryb2tlV2lkdGgpIHtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZTtcbiAgICAgIGN0eC5saW5lV2lkdGggPSBzdHJva2VXaWR0aDtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSAqPSB0aGlzLm9wYWNpdHkgKiB0aGlzLnN0cm9rZU9wYWNpdHk7XG4gICAgICBjb25zdCB7IGxpbmVEYXNoLCBsaW5lRGFzaE9mZnNldCwgbGluZUNhcCwgbGluZUpvaW4gfSA9IHRoaXM7XG4gICAgICBpZiAobGluZURhc2gpIHtcbiAgICAgICAgY3R4LnNldExpbmVEYXNoKGxpbmVEYXNoKTtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lRGFzaE9mZnNldCkge1xuICAgICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBsaW5lRGFzaE9mZnNldDtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lQ2FwKSB7XG4gICAgICAgIGN0eC5saW5lQ2FwID0gbGluZUNhcDtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lSm9pbikge1xuICAgICAgICBjdHgubGluZUpvaW4gPSBsaW5lSm9pbjtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVuZGVyTGluZXMoKGxpbmUsIHgsIHkpID0+IGN0eC5zdHJva2VUZXh0KGxpbmUsIHgsIHkpKTtcbiAgICB9XG4gICAgc3VwZXIucmVuZGVyKHJlbmRlckN0eCk7XG4gIH1cbiAgcmVuZGVyTGluZXMocmVuZGVyQ2FsbGJhY2spIHtcbiAgICBjb25zdCB7IGxpbmVzLCB4LCB5IH0gPSB0aGlzO1xuICAgIGNvbnN0IGxpbmVIZWlnaHQgPSB0aGlzLmxpbmVIZWlnaHQgPz8gVGV4dFV0aWxzLmdldExpbmVIZWlnaHQodGhpcy5mb250U2l6ZSk7XG4gICAgbGV0IG9mZnNldFkgPSAobGluZUhlaWdodCAtIGxpbmVIZWlnaHQgKiBsaW5lcy5sZW5ndGgpICogVGV4dFV0aWxzLmdldFZlcnRpY2FsTW9kaWZpZXIodGhpcy50ZXh0QmFzZWxpbmUpO1xuICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgICAgcmVuZGVyQ2FsbGJhY2sobGluZSwgeCwgeSArIG9mZnNldFkpO1xuICAgICAgb2Zmc2V0WSArPSBsaW5lSGVpZ2h0O1xuICAgIH1cbiAgfVxuICBzZXRGb250KHByb3BzKSB7XG4gICAgdGhpcy5mb250RmFtaWx5ID0gcHJvcHMuZm9udEZhbWlseTtcbiAgICB0aGlzLmZvbnRTaXplID0gcHJvcHMuZm9udFNpemU7XG4gICAgdGhpcy5mb250U3R5bGUgPSBwcm9wcy5mb250U3R5bGU7XG4gICAgdGhpcy5mb250V2VpZ2h0ID0gcHJvcHMuZm9udFdlaWdodDtcbiAgfVxuICBzZXRBbGlnbihwcm9wcykge1xuICAgIHRoaXMudGV4dEFsaWduID0gcHJvcHMudGV4dEFsaWduO1xuICAgIHRoaXMudGV4dEJhc2VsaW5lID0gcHJvcHMudGV4dEJhc2VsaW5lO1xuICB9XG4gIHRvU1ZHKCkge1xuICAgIGlmICghdGhpcy52aXNpYmxlIHx8ICF0aGlzLnRleHQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZWxlbWVudDIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcInRleHRcIik7XG4gICAgZWxlbWVudDIuc2V0QXR0cmlidXRlKFwiZm9udC1mYW1pbHlcIiwgdGhpcy5mb250RmFtaWx5Py5zcGxpdChcIixcIilbMF0gPz8gXCJcIik7XG4gICAgZWxlbWVudDIuc2V0QXR0cmlidXRlKFwiZm9udC1zaXplXCIsIFN0cmluZyh0aGlzLmZvbnRTaXplKSk7XG4gICAgZWxlbWVudDIuc2V0QXR0cmlidXRlKFwiZm9udC1zdHlsZVwiLCB0aGlzLmZvbnRTdHlsZSA/PyBcIlwiKTtcbiAgICBlbGVtZW50Mi5zZXRBdHRyaWJ1dGUoXCJmb250LXdlaWdodFwiLCBTdHJpbmcodGhpcy5mb250V2VpZ2h0ID8/IFwiXCIpKTtcbiAgICBlbGVtZW50Mi5zZXRBdHRyaWJ1dGUoXG4gICAgICBcInRleHQtYW5jaG9yXCIsXG4gICAgICB7XG4gICAgICAgIGNlbnRlcjogXCJtaWRkbGVcIixcbiAgICAgICAgbGVmdDogXCJzdGFydFwiLFxuICAgICAgICByaWdodDogXCJlbmRcIixcbiAgICAgICAgc3RhcnQ6IFwic3RhcnRcIixcbiAgICAgICAgZW5kOiBcImVuZFwiXG4gICAgICB9W3RoaXMudGV4dEFsaWduID8/IFwic3RhcnRcIl1cbiAgICApO1xuICAgIGVsZW1lbnQyLnNldEF0dHJpYnV0ZShcbiAgICAgIFwiYWxpZ25tZW50LWJhc2VsaW5lXCIsXG4gICAgICB7XG4gICAgICAgIGFscGhhYmV0aWM6IFwiYWxwaGFiZXRpY1wiLFxuICAgICAgICB0b3A6IFwidG9wXCIsXG4gICAgICAgIGJvdHRvbTogXCJib3R0b21cIixcbiAgICAgICAgaGFuZ2luZzogXCJoYW5naW5nXCIsXG4gICAgICAgIG1pZGRsZTogXCJtaWRkbGVcIixcbiAgICAgICAgaWRlb2dyYXBoaWM6IFwiaWRlb2dyYXBoaWNcIlxuICAgICAgfVt0aGlzLnRleHRCYXNlbGluZSA/PyBcImFscGhhYmV0aWNcIl1cbiAgICApO1xuICAgIGVsZW1lbnQyLnNldEF0dHJpYnV0ZShcInhcIiwgU3RyaW5nKHRoaXMueCkpO1xuICAgIGVsZW1lbnQyLnNldEF0dHJpYnV0ZShcInlcIiwgU3RyaW5nKHRoaXMueSkpO1xuICAgIGVsZW1lbnQyLnRleHRDb250ZW50ID0gdGhpcy50ZXh0ID8/IFwiXCI7XG4gICAgcmV0dXJuIHsgZWxlbWVudHM6IFtlbGVtZW50Ml0gfTtcbiAgfVxufTtcbl9UZXh0LmNsYXNzTmFtZSA9IFwiVGV4dFwiO1xuX1RleHQuZGVmYXVsdFN0eWxlcyA9IHtcbiAgLi4uU2hhcGUuZGVmYXVsdFN0eWxlcyxcbiAgdGV4dEFsaWduOiBcInN0YXJ0XCIsXG4gIGZvbnRTdHlsZTogdm9pZCAwLFxuICBmb250V2VpZ2h0OiB2b2lkIDAsXG4gIGZvbnRTaXplOiAxMCxcbiAgZm9udEZhbWlseTogXCJzYW5zLXNlcmlmXCIsXG4gIHRleHRCYXNlbGluZTogXCJhbHBoYWJldGljXCJcbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLyB9KVxuXSwgX1RleHQucHJvdG90eXBlLCBcInhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLyB9KVxuXSwgX1RleHQucHJvdG90eXBlLCBcInlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLywgY2hhbmdlQ2I6IChvKSA9PiBvLm9uVGV4dENoYW5nZSgpIH0pXG5dLCBfVGV4dC5wcm90b3R5cGUsIFwidGV4dFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIF9UZXh0LnByb3RvdHlwZSwgXCJmb250U3R5bGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbigpXG5dLCBfVGV4dC5wcm90b3R5cGUsIFwiZm9udFdlaWdodFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIF9UZXh0LnByb3RvdHlwZSwgXCJmb250U2l6ZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIF9UZXh0LnByb3RvdHlwZSwgXCJmb250RmFtaWx5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8gfSlcbl0sIF9UZXh0LnByb3RvdHlwZSwgXCJ0ZXh0QWxpZ25cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLyB9KVxuXSwgX1RleHQucHJvdG90eXBlLCBcInRleHRCYXNlbGluZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBfVGV4dC5wcm90b3R5cGUsIFwibGluZUhlaWdodFwiLCAyKTtcbnZhciBUZXh0ID0gX1RleHQ7XG52YXIgUm90YXRhYmxlVGV4dCA9IGNsYXNzIGV4dGVuZHMgUm90YXRhYmxlKFRleHQpIHtcbn07XG52YXIgVHJhbnNmb3JtYWJsZVRleHQgPSBjbGFzcyBleHRlbmRzIFJvdGF0YWJsZShUcmFuc2xhdGFibGUoVGV4dCkpIHtcbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL3V0aWwvbGFiZWxQbGFjZW1lbnQudHNcbmZ1bmN0aW9uIGNpcmNsZVJlY3RPdmVybGFwKGMsIHVuaXRDZW50ZXIsIHgsIHksIHcsIGgpIHtcbiAgaWYgKGMuc2l6ZSA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsZXQgY3ggPSBjLng7XG4gIGxldCBjeSA9IGMueTtcbiAgaWYgKHVuaXRDZW50ZXIgIT0gbnVsbCkge1xuICAgIGN4IC09ICh1bml0Q2VudGVyLnggLSAwLjUpICogYy5zaXplO1xuICAgIGN5IC09ICh1bml0Q2VudGVyLnkgLSAwLjUpICogYy5zaXplO1xuICB9XG4gIGxldCBlZGdlWCA9IGN4O1xuICBpZiAoY3ggPCB4KSB7XG4gICAgZWRnZVggPSB4O1xuICB9IGVsc2UgaWYgKGN4ID4geCArIHcpIHtcbiAgICBlZGdlWCA9IHggKyB3O1xuICB9XG4gIGxldCBlZGdlWSA9IGN5O1xuICBpZiAoY3kgPCB5KSB7XG4gICAgZWRnZVkgPSB5O1xuICB9IGVsc2UgaWYgKGN5ID4geSArIGgpIHtcbiAgICBlZGdlWSA9IHkgKyBoO1xuICB9XG4gIGNvbnN0IGR4ID0gY3ggLSBlZGdlWDtcbiAgY29uc3QgZHkgPSBjeSAtIGVkZ2VZO1xuICBjb25zdCBkID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgcmV0dXJuIGQgPD0gYy5zaXplICogMC41O1xufVxuZnVuY3Rpb24gcmVjdFJlY3RPdmVybGFwKHIxLCB4MiwgeTIsIHcyLCBoMikge1xuICBjb25zdCB4T3ZlcmxhcCA9IHIxLnggKyByMS53aWR0aCA+IHgyICYmIHIxLnggPCB4MiArIHcyO1xuICBjb25zdCB5T3ZlcmxhcCA9IHIxLnkgKyByMS5oZWlnaHQgPiB5MiAmJiByMS55IDwgeTIgKyBoMjtcbiAgcmV0dXJuIHhPdmVybGFwICYmIHlPdmVybGFwO1xufVxuZnVuY3Rpb24gcmVjdENvbnRhaW5zUmVjdChyMSwgcjJ4LCByMnksIHIydywgcjJoKSB7XG4gIHJldHVybiByMnggKyByMncgPCByMS54ICsgcjEud2lkdGggJiYgcjJ4ID4gcjEueCAmJiByMnkgPiByMS55ICYmIHIyeSArIHIyaCA8IHIxLnkgKyByMS5oZWlnaHQ7XG59XG5mdW5jdGlvbiBpc1BvaW50TGFiZWxEYXR1bSh4KSB7XG4gIHJldHVybiB4ICE9IG51bGwgJiYgdHlwZW9mIHgucG9pbnQgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHgubGFiZWwgPT09IFwib2JqZWN0XCI7XG59XG52YXIgbGFiZWxQbGFjZW1lbnRzID0ge1xuICB0b3A6IHsgeDogMCwgeTogLTEgfSxcbiAgYm90dG9tOiB7IHg6IDAsIHk6IDEgfSxcbiAgbGVmdDogeyB4OiAtMSwgeTogMCB9LFxuICByaWdodDogeyB4OiAxLCB5OiAwIH0sXG4gIFwidG9wLWxlZnRcIjogeyB4OiAtMSwgeTogLTEgfSxcbiAgXCJ0b3AtcmlnaHRcIjogeyB4OiAxLCB5OiAtMSB9LFxuICBcImJvdHRvbS1sZWZ0XCI6IHsgeDogLTEsIHk6IDEgfSxcbiAgXCJib3R0b20tcmlnaHRcIjogeyB4OiAxLCB5OiAxIH1cbn07XG5mdW5jdGlvbiBwbGFjZUxhYmVscyhkYXRhLCBib3VuZHMsIHBhZGRpbmcgPSA1KSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBkYXRhID0gZGF0YS5tYXAoKGQpID0+IGQuc2xpY2UoKS5zb3J0KChhLCBiKSA9PiBiLnBvaW50LnNpemUgLSBhLnBvaW50LnNpemUpKTtcbiAgZm9yIChsZXQgaiA9IDA7IGogPCBkYXRhLmxlbmd0aDsgaisrKSB7XG4gICAgY29uc3QgbGFiZWxzID0gcmVzdWx0W2pdID0gW107XG4gICAgY29uc3QgZGF0dW0gPSBkYXRhW2pdO1xuICAgIGlmICghKGRhdHVtPy5sZW5ndGggJiYgZGF0dW1bMF0ubGFiZWwpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaW5kZXggPSAwLCBsbiA9IGRhdHVtLmxlbmd0aDsgaW5kZXggPCBsbjsgaW5kZXgrKykge1xuICAgICAgY29uc3QgZCA9IGRhdHVtW2luZGV4XTtcbiAgICAgIGNvbnN0IHsgcG9pbnQsIGxhYmVsLCBtYXJrZXIgfSA9IGQ7XG4gICAgICBjb25zdCB7IHRleHQsIHdpZHRoOiB3aWR0aDIsIGhlaWdodDogaGVpZ2h0MiB9ID0gbGFiZWw7XG4gICAgICBjb25zdCByID0gcG9pbnQuc2l6ZSAqIDAuNTtcbiAgICAgIGxldCBkeCA9IDA7XG4gICAgICBsZXQgZHkgPSAwO1xuICAgICAgaWYgKHIgPiAwICYmIGQucGxhY2VtZW50ICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgcGxhY2VtZW50ID0gbGFiZWxQbGFjZW1lbnRzW2QucGxhY2VtZW50XTtcbiAgICAgICAgZHggPSAod2lkdGgyICogMC41ICsgciArIHBhZGRpbmcpICogcGxhY2VtZW50Lng7XG4gICAgICAgIGR5ID0gKGhlaWdodDIgKiAwLjUgKyByICsgcGFkZGluZykgKiBwbGFjZW1lbnQueTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHggPSBwb2ludC54IC0gd2lkdGgyICogMC41ICsgZHggLSAoKG1hcmtlcj8uY2VudGVyLnggPz8gMC41KSAtIDAuNSkgKiBwb2ludC5zaXplO1xuICAgICAgY29uc3QgeSA9IHBvaW50LnkgLSBoZWlnaHQyICogMC41ICsgZHkgLSAoKG1hcmtlcj8uY2VudGVyLnkgPz8gMC41KSAtIDAuNSkgKiBwb2ludC5zaXplO1xuICAgICAgY29uc3Qgd2l0aGluQm91bmRzID0gIWJvdW5kcyB8fCByZWN0Q29udGFpbnNSZWN0KGJvdW5kcywgeCwgeSwgd2lkdGgyLCBoZWlnaHQyKTtcbiAgICAgIGlmICghd2l0aGluQm91bmRzKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3ZlcmxhcFBvaW50cyA9IGRhdGEuc29tZShcbiAgICAgICAgKGRhdGFEYXR1bXMpID0+IGRhdGFEYXR1bXMuc29tZShcbiAgICAgICAgICAoZGF0YURhdHVtKSA9PiBjaXJjbGVSZWN0T3ZlcmxhcChkYXRhRGF0dW0ucG9pbnQsIGRhdGFEYXR1bS5tYXJrZXI/LmNlbnRlciwgeCwgeSwgd2lkdGgyLCBoZWlnaHQyKVxuICAgICAgICApXG4gICAgICApO1xuICAgICAgaWYgKG92ZXJsYXBQb2ludHMpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBvdmVybGFwTGFiZWxzID0gcmVzdWx0LnNvbWUoKGwyKSA9PiBsMi5zb21lKChsMykgPT4gcmVjdFJlY3RPdmVybGFwKGwzLCB4LCB5LCB3aWR0aDIsIGhlaWdodDIpKSk7XG4gICAgICBpZiAob3ZlcmxhcExhYmVscykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGxhYmVscy5wdXNoKHsgaW5kZXgsIHRleHQsIHgsIHksIHdpZHRoOiB3aWR0aDIsIGhlaWdodDogaGVpZ2h0MiwgZGF0dW06IGQgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBheGlzTGFiZWxzT3ZlcmxhcChkYXRhLCBwYWRkaW5nID0gMCkge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGRhdGEubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgY29uc3QgZGF0dW0gPSBkYXRhW2luZGV4XTtcbiAgICBjb25zdCB7XG4gICAgICBwb2ludDogeyB4LCB5IH0sXG4gICAgICBsYWJlbDogeyB0ZXh0IH1cbiAgICB9ID0gZGF0dW07XG4gICAgbGV0IHsgd2lkdGg6IHdpZHRoMiwgaGVpZ2h0OiBoZWlnaHQyIH0gPSBkYXR1bS5sYWJlbDtcbiAgICB3aWR0aDIgKz0gcGFkZGluZztcbiAgICBoZWlnaHQyICs9IHBhZGRpbmc7XG4gICAgaWYgKHJlc3VsdC5zb21lKChsKSA9PiByZWN0UmVjdE92ZXJsYXAobCwgeCwgeSwgd2lkdGgyLCBoZWlnaHQyKSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXN1bHQucHVzaCh7IGluZGV4LCB0ZXh0LCB4LCB5LCB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIsIGRhdHVtIH0pO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9lcXVhbC50c1xuZnVuY3Rpb24gYXJlQXJyYXlOdW1iZXJzRXF1YWwoYXJyQSwgYXJyQikge1xuICByZXR1cm4gYXJyQS5sZW5ndGggPT09IGFyckIubGVuZ3RoICYmIGFyckEuZXZlcnkoKGl0ZW0sIGkpID0+IE51bWJlcihpdGVtKSA9PT0gTnVtYmVyKGFyckJbaV0pKTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9qc29uLnRzXG52YXIgQ0xBU1NfSU5TVEFOQ0VfVFlQRSA9IFwiY2xhc3MtaW5zdGFuY2VcIjtcbmZ1bmN0aW9uIGpzb25EaWZmKHNvdXJjZSwgdGFyZ2V0LCBza2lwKSB7XG4gIGlmIChpc0FycmF5KHRhcmdldCkpIHtcbiAgICBpZiAoIWlzQXJyYXkoc291cmNlKSB8fCBzb3VyY2UubGVuZ3RoICE9PSB0YXJnZXQubGVuZ3RoIHx8IHRhcmdldC5zb21lKCh2LCBpKSA9PiBqc29uRGlmZihzb3VyY2VbaV0sIHYpICE9IG51bGwpKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHRhcmdldCkpIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgY29uc3QgYWxsS2V5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgICAgIC4uLk9iamVjdC5rZXlzKHNvdXJjZSksXG4gICAgICAuLi5PYmplY3Qua2V5cyh0YXJnZXQpXG4gICAgXSk7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgYWxsS2V5cykge1xuICAgICAgaWYgKHNvdXJjZVtrZXldID09PSB0YXJnZXRba2V5XSB8fCBza2lwPy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBzb3VyY2Vba2V5XSA9PT0gdHlwZW9mIHRhcmdldFtrZXldKSB7XG4gICAgICAgIGNvbnN0IGRpZmYyID0ganNvbkRpZmYoc291cmNlW2tleV0sIHRhcmdldFtrZXldKTtcbiAgICAgICAgaWYgKGRpZmYyICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSBkaWZmMjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSB0YXJnZXRba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHJlc3VsdCkubGVuZ3RoID8gcmVzdWx0IDogbnVsbDtcbiAgfSBlbHNlIGlmIChzb3VyY2UgIT09IHRhcmdldCkge1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBkZWVwQ2xvbmUoc291cmNlLCBvcHRpb25zKSB7XG4gIGlmIChpc0FycmF5KHNvdXJjZSkpIHtcbiAgICByZXR1cm4gc291cmNlLm1hcCgoaXRlbSkgPT4gZGVlcENsb25lKGl0ZW0sIG9wdGlvbnMpKTtcbiAgfVxuICBpZiAoaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgcmV0dXJuIG1hcFZhbHVlcyhcbiAgICAgIHNvdXJjZSxcbiAgICAgICh2YWx1ZSwga2V5KSA9PiBvcHRpb25zPy5zaGFsbG93Py5pbmNsdWRlcyhrZXkpID8gc2hhbGxvd0Nsb25lKHZhbHVlKSA6IGRlZXBDbG9uZSh2YWx1ZSwgb3B0aW9ucylcbiAgICApO1xuICB9XG4gIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBNYXApIHtcbiAgICByZXR1cm4gbmV3IE1hcChkZWVwQ2xvbmUoQXJyYXkuZnJvbShzb3VyY2UpKSk7XG4gIH1cbiAgcmV0dXJuIHNoYWxsb3dDbG9uZShzb3VyY2UpO1xufVxuZnVuY3Rpb24gc2hhbGxvd0Nsb25lKHNvdXJjZSkge1xuICBpZiAoaXNBcnJheShzb3VyY2UpKSB7XG4gICAgcmV0dXJuIFsuLi5zb3VyY2VdO1xuICB9XG4gIGlmIChpc1BsYWluT2JqZWN0KHNvdXJjZSkpIHtcbiAgICByZXR1cm4geyAuLi5zb3VyY2UgfTtcbiAgfVxuICBpZiAoaXNEYXRlKHNvdXJjZSkpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoc291cmNlKTtcbiAgfVxuICBpZiAoaXNSZWdFeHAoc291cmNlKSkge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKHNvdXJjZS5zb3VyY2UsIHNvdXJjZS5mbGFncyk7XG4gIH1cbiAgcmV0dXJuIHNvdXJjZTtcbn1cbmZ1bmN0aW9uIGpzb25XYWxrKGpzb24sIHZpc2l0LCBvcHRzLCAuLi5qc29ucykge1xuICBpZiAoaXNBcnJheShqc29uKSkge1xuICAgIHZpc2l0KGpzb24sIC4uLmpzb25zKTtcbiAgICBqc29uLmZvckVhY2goKG5vZGUsIGluZGV4KSA9PiB7XG4gICAgICBqc29uV2Fsayhub2RlLCB2aXNpdCwgb3B0cywgLi4ua2V5TWFwcGVyKGpzb25zLCBpbmRleCkpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QoanNvbikpIHtcbiAgICB2aXNpdChqc29uLCAuLi5qc29ucyk7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoanNvbikpIHtcbiAgICAgIGlmIChvcHRzPy5za2lwPy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsdWUgPSBqc29uW2tleV07XG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAganNvbldhbGsodmFsdWUsIHZpc2l0LCBvcHRzLCAuLi5rZXlNYXBwZXIoanNvbnMsIGtleSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24ganNvbkFwcGx5KHRhcmdldCwgc291cmNlLCBwYXJhbXMgPSB7fSkge1xuICBjb25zdCB7IHBhdGgsIG1hdGNoZXJQYXRoID0gcGF0aD8ucmVwbGFjZSgvKFxcW1swLTkrXStdKS9pLCBcIltdXCIpLCBza2lwID0gW10gfSA9IHBhcmFtcztcbiAgaWYgKHRhcmdldCA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBBRyBDaGFydHMgLSB0YXJnZXQgaXMgdW5pbml0aWFsaXNlZDogJHtwYXRoID8/IFwiPHJvb3Q+XCJ9YCk7XG4gIH1cbiAgaWYgKHNvdXJjZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICBpZiAoaXNQcm9wZXJ0aWVzKHRhcmdldCkpIHtcbiAgICByZXR1cm4gdGFyZ2V0LnNldChzb3VyY2UpO1xuICB9XG4gIGNvbnN0IHRhcmdldEFueSA9IHRhcmdldDtcbiAgY29uc3QgdGFyZ2V0VHlwZSA9IGNsYXNzaWZ5KHRhcmdldCk7XG4gIGZvciAoY29uc3QgcHJvcGVydHkgaW4gc291cmNlKSB7XG4gICAgaWYgKFNLSVBfSlNfQlVJTFRJTlMuaGFzKHByb3BlcnR5KSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIGNvbnN0IHByb3BlcnR5TWF0Y2hlclBhdGggPSBgJHttYXRjaGVyUGF0aCA/IG1hdGNoZXJQYXRoICsgXCIuXCIgOiBcIlwifSR7cHJvcGVydHl9YDtcbiAgICBpZiAoc2tpcC5pbmNsdWRlcyhwcm9wZXJ0eU1hdGNoZXJQYXRoKSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIGNvbnN0IG5ld1ZhbHVlID0gc291cmNlW3Byb3BlcnR5XTtcbiAgICBjb25zdCBwcm9wZXJ0eVBhdGggPSBgJHtwYXRoID8gcGF0aCArIFwiLlwiIDogXCJcIn0ke3Byb3BlcnR5fWA7XG4gICAgY29uc3QgdGFyZ2V0Q2xhc3MgPSB0YXJnZXRBbnkuY29uc3RydWN0b3I7XG4gICAgY29uc3QgY3VycmVudFZhbHVlID0gdGFyZ2V0QW55W3Byb3BlcnR5XTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY3VycmVudFZhbHVlVHlwZSA9IGNsYXNzaWZ5KGN1cnJlbnRWYWx1ZSk7XG4gICAgICBjb25zdCBuZXdWYWx1ZVR5cGUgPSBjbGFzc2lmeShuZXdWYWx1ZSk7XG4gICAgICBpZiAodGFyZ2V0VHlwZSA9PT0gQ0xBU1NfSU5TVEFOQ0VfVFlQRSAmJiAhKHByb3BlcnR5IGluIHRhcmdldCkpIHtcbiAgICAgICAgTG9nZ2VyLndhcm4oYHVuYWJsZSB0byBzZXQgWyR7cHJvcGVydHlQYXRofV0gaW4gJHt0YXJnZXRDbGFzcz8ubmFtZX0gLSBwcm9wZXJ0eSBpcyB1bmtub3duYCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRWYWx1ZVR5cGUgIT0gbnVsbCAmJiBuZXdWYWx1ZVR5cGUgIT0gbnVsbCAmJiBuZXdWYWx1ZVR5cGUgIT09IGN1cnJlbnRWYWx1ZVR5cGUgJiYgKGN1cnJlbnRWYWx1ZVR5cGUgIT09IENMQVNTX0lOU1RBTkNFX1RZUEUgfHwgbmV3VmFsdWVUeXBlICE9PSBcIm9iamVjdFwiKSkge1xuICAgICAgICBMb2dnZXIud2FybihcbiAgICAgICAgICBgdW5hYmxlIHRvIHNldCBbJHtwcm9wZXJ0eVBhdGh9XSBpbiAke3RhcmdldENsYXNzPy5uYW1lfSAtIGNhbid0IGFwcGx5IHR5cGUgb2YgWyR7bmV3VmFsdWVUeXBlfV0sIGFsbG93ZWQgdHlwZXMgYXJlOiBbJHtjdXJyZW50VmFsdWVUeXBlfV1gXG4gICAgICAgICk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzUHJvcGVydGllcyhjdXJyZW50VmFsdWUpKSB7XG4gICAgICAgIHRhcmdldEFueVtwcm9wZXJ0eV0uc2V0KG5ld1ZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAobmV3VmFsdWVUeXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmIChjdXJyZW50VmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgIHRhcmdldEFueVtwcm9wZXJ0eV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBqc29uQXBwbHkoY3VycmVudFZhbHVlID8/IHRhcmdldEFueVtwcm9wZXJ0eV0sIG5ld1ZhbHVlLCB7XG4gICAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICAgIHBhdGg6IHByb3BlcnR5UGF0aCxcbiAgICAgICAgICBtYXRjaGVyUGF0aDogcHJvcGVydHlNYXRjaGVyUGF0aFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldEFueVtwcm9wZXJ0eV0gPSBuZXdWYWx1ZTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgTG9nZ2VyLndhcm4oYHVuYWJsZSB0byBzZXQgWyR7cHJvcGVydHlQYXRofV0gaW4gWyR7dGFyZ2V0Q2xhc3M/Lm5hbWV9XTsgbmVzdGVkIGVycm9yIGlzOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBrZXlNYXBwZXIoZGF0YSwga2V5KSB7XG4gIHJldHVybiBkYXRhLm1hcCgoZGF0YU9iamVjdCkgPT4gZGF0YU9iamVjdD8uW2tleV0pO1xufVxuZnVuY3Rpb24gY2xhc3NpZnkodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoaXNIdG1sRWxlbWVudCh2YWx1ZSkgfHwgaXNEYXRlKHZhbHVlKSkge1xuICAgIHJldHVybiBcInByaW1pdGl2ZVwiO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBcImFycmF5XCI7XG4gIH1cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBpc1BsYWluT2JqZWN0KHZhbHVlKSA/IFwib2JqZWN0XCIgOiBDTEFTU19JTlNUQU5DRV9UWVBFO1xuICB9XG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHJldHVybiBcImZ1bmN0aW9uXCI7XG4gIH1cbiAgcmV0dXJuIFwicHJpbWl0aXZlXCI7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvcHJveHkudHNcbmZ1bmN0aW9uIFByb3h5UHJvcGVydHkocHJveHlQYXRoLCBjb25maWdNZXRhZGF0YSkge1xuICBjb25zdCBwYXRoQXJyYXkgPSBpc0FycmF5KHByb3h5UGF0aCkgPyBwcm94eVBhdGggOiBwcm94eVBhdGguc3BsaXQoXCIuXCIpO1xuICBpZiAocGF0aEFycmF5Lmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbnN0IFtwcm9wZXJ0eV0gPSBwYXRoQXJyYXk7XG4gICAgcmV0dXJuIGFkZFRyYW5zZm9ybVRvSW5zdGFuY2VQcm9wZXJ0eShcbiAgICAgICh0YXJnZXQsIF8sIHZhbHVlKSA9PiB0YXJnZXRbcHJvcGVydHldID0gdmFsdWUsXG4gICAgICAodGFyZ2V0KSA9PiB0YXJnZXRbcHJvcGVydHldLFxuICAgICAgY29uZmlnTWV0YWRhdGFcbiAgICApO1xuICB9XG4gIHJldHVybiBhZGRUcmFuc2Zvcm1Ub0luc3RhbmNlUHJvcGVydHkoXG4gICAgKHRhcmdldCwgXywgdmFsdWUpID0+IHNldFBhdGgodGFyZ2V0LCBwYXRoQXJyYXksIHZhbHVlKSxcbiAgICAodGFyZ2V0KSA9PiBnZXRQYXRoKHRhcmdldCwgcGF0aEFycmF5KSxcbiAgICBjb25maWdNZXRhZGF0YVxuICApO1xufVxuZnVuY3Rpb24gUHJveHlPbldyaXRlKHByb3h5UHJvcGVydHkpIHtcbiAgcmV0dXJuIGFkZFRyYW5zZm9ybVRvSW5zdGFuY2VQcm9wZXJ0eSgodGFyZ2V0LCBfLCB2YWx1ZSkgPT4gdGFyZ2V0W3Byb3h5UHJvcGVydHldID0gdmFsdWUpO1xufVxuZnVuY3Rpb24gUHJveHlQcm9wZXJ0eU9uV3JpdGUoY2hpbGROYW1lLCBjaGlsZFByb3BlcnR5KSB7XG4gIHJldHVybiBhZGRUcmFuc2Zvcm1Ub0luc3RhbmNlUHJvcGVydHkoKHRhcmdldCwga2V5LCB2YWx1ZSkgPT4gdGFyZ2V0W2NoaWxkTmFtZV1bY2hpbGRQcm9wZXJ0eSA/PyBrZXldID0gdmFsdWUpO1xufVxuZnVuY3Rpb24gQWN0aW9uT25TZXQob3B0cykge1xuICBjb25zdCB7IG5ld1ZhbHVlOiBuZXdWYWx1ZUZuLCBvbGRWYWx1ZTogb2xkVmFsdWVGbiwgY2hhbmdlVmFsdWU6IGNoYW5nZVZhbHVlRm4gfSA9IG9wdHM7XG4gIHJldHVybiBhZGRUcmFuc2Zvcm1Ub0luc3RhbmNlUHJvcGVydHkoKHRhcmdldCwgXywgbmV3VmFsdWUsIG9sZFZhbHVlKSA9PiB7XG4gICAgaWYgKG5ld1ZhbHVlICE9PSBvbGRWYWx1ZSkge1xuICAgICAgaWYgKG9sZFZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgb2xkVmFsdWVGbj8uY2FsbCh0YXJnZXQsIG9sZFZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChuZXdWYWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIG5ld1ZhbHVlRm4/LmNhbGwodGFyZ2V0LCBuZXdWYWx1ZSk7XG4gICAgICB9XG4gICAgICBjaGFuZ2VWYWx1ZUZuPy5jYWxsKHRhcmdldCwgbmV3VmFsdWUsIG9sZFZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld1ZhbHVlO1xuICB9KTtcbn1cbmZ1bmN0aW9uIE9ic2VydmVDaGFuZ2VzKG9ic2VydmVyRm4pIHtcbiAgcmV0dXJuIGFkZE9ic2VydmVyVG9JbnN0YW5jZVByb3BlcnR5KG9ic2VydmVyRm4pO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3N0YXRlTWFjaGluZS50c1xudmFyIGRlYnVnQ29sb3IgPSBcImNvbG9yOiBncmVlblwiO1xudmFyIGRlYnVnUXVpZXRDb2xvciA9IFwiY29sb3I6IGdyZXlcIjtcbnZhciBfU3RhdGVNYWNoaW5lID0gY2xhc3MgX1N0YXRlTWFjaGluZSB7XG4gIGNvbnN0cnVjdG9yKGRlZmF1bHRTdGF0ZSwgc3RhdGVzLCBlbnRlckVhY2gpIHtcbiAgICB0aGlzLmRlZmF1bHRTdGF0ZSA9IGRlZmF1bHRTdGF0ZTtcbiAgICB0aGlzLnN0YXRlcyA9IHN0YXRlcztcbiAgICB0aGlzLmVudGVyRWFjaCA9IGVudGVyRWFjaDtcbiAgICB0aGlzLmRlYnVnID0gRGVidWcuY3JlYXRlKHRydWUsIFwiYW5pbWF0aW9uXCIpO1xuICAgIHRoaXMuc3RhdGUgPSBkZWZhdWx0U3RhdGU7XG4gICAgdGhpcy5kZWJ1ZyhgJWMke3RoaXMuY29uc3RydWN0b3IubmFtZX0gfCBpbml0IC0+ICR7ZGVmYXVsdFN0YXRlfWAsIGRlYnVnQ29sb3IpO1xuICB9XG4gIHRyYW5zaXRpb24oZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCBzaG91bGRUcmFuc2l0aW9uU2VsZiA9IHRoaXMudHJhbnNpdGlvbkNoaWxkKGV2ZW50LCBkYXRhKTtcbiAgICBpZiAoIXNob3VsZFRyYW5zaXRpb25TZWxmIHx8IHRoaXMuc3RhdGUgPT09IF9TdGF0ZU1hY2hpbmUuY2hpbGQgfHwgdGhpcy5zdGF0ZSA9PT0gX1N0YXRlTWFjaGluZS5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBjdXJyZW50U3RhdGVDb25maWcgPSB0aGlzLnN0YXRlc1t0aGlzLnN0YXRlXTtcbiAgICBsZXQgZGVzdGluYXRpb24gPSBjdXJyZW50U3RhdGVDb25maWdbZXZlbnRdO1xuICAgIGNvbnN0IGRlYnVnUHJlZml4ID0gYCVjJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9IHwgJHt0aGlzLnN0YXRlfSAtPiAke2V2ZW50fSAtPmA7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGVzdGluYXRpb24pKSB7XG4gICAgICBkZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uLmZpbmQoKHRyYW5zaXRpb24pID0+IHtcbiAgICAgICAgaWYgKCF0cmFuc2l0aW9uLmd1YXJkKVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjb25zdCB2YWxpZCA9IHRyYW5zaXRpb24uZ3VhcmQoZGF0YSk7XG4gICAgICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgICB0aGlzLmRlYnVnKGAke2RlYnVnUHJlZml4fSAke3RyYW5zaXRpb24udGFyZ2V0fSAoZ3VhcmRlZClgLCBkZWJ1Z1F1aWV0Q29sb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWxpZDtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlc3RpbmF0aW9uID09PSBcIm9iamVjdFwiICYmICEoZGVzdGluYXRpb24gaW5zdGFuY2VvZiBfU3RhdGVNYWNoaW5lKSAmJiBkZXN0aW5hdGlvbi5ndWFyZCAmJiAhZGVzdGluYXRpb24uZ3VhcmQoZGF0YSkpIHtcbiAgICAgIHRoaXMuZGVidWcoYCR7ZGVidWdQcmVmaXh9ICR7ZGVzdGluYXRpb24udGFyZ2V0fSAoZ3VhcmRlZClgLCBkZWJ1Z1F1aWV0Q29sb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWRlc3RpbmF0aW9uKSB7XG4gICAgICB0aGlzLmRlYnVnKGAke2RlYnVnUHJlZml4fSAke3RoaXMuc3RhdGV9YCwgZGVidWdRdWlldENvbG9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGVzdGluYXRpb25TdGF0ZSA9IHRoaXMuZ2V0RGVzdGluYXRpb25TdGF0ZShkZXN0aW5hdGlvbik7XG4gICAgY29uc3QgZXhpdEZuID0gZGVzdGluYXRpb25TdGF0ZSA9PT0gdGhpcy5zdGF0ZSA/IHZvaWQgMCA6IGN1cnJlbnRTdGF0ZUNvbmZpZy5vbkV4aXQ7XG4gICAgdGhpcy5kZWJ1ZyhgJHtkZWJ1Z1ByZWZpeH0gJHtkZXN0aW5hdGlvblN0YXRlfWAsIGRlYnVnQ29sb3IpO1xuICAgIHRoaXMuc3RhdGUgPSBkZXN0aW5hdGlvblN0YXRlO1xuICAgIGlmICh0eXBlb2YgZGVzdGluYXRpb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgZGVzdGluYXRpb24oZGF0YSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGVzdGluYXRpb24gPT09IFwib2JqZWN0XCIgJiYgIShkZXN0aW5hdGlvbiBpbnN0YW5jZW9mIF9TdGF0ZU1hY2hpbmUpKSB7XG4gICAgICBkZXN0aW5hdGlvbi5hY3Rpb24/LihkYXRhKTtcbiAgICB9XG4gICAgZXhpdEZuPy4oKTtcbiAgICB0aGlzLmVudGVyRWFjaD8uKGN1cnJlbnRTdGF0ZSwgZGVzdGluYXRpb25TdGF0ZSk7XG4gICAgaWYgKGRlc3RpbmF0aW9uU3RhdGUgIT09IGN1cnJlbnRTdGF0ZSAmJiBkZXN0aW5hdGlvblN0YXRlICE9PSBfU3RhdGVNYWNoaW5lLmNoaWxkICYmIGRlc3RpbmF0aW9uU3RhdGUgIT09IF9TdGF0ZU1hY2hpbmUucGFyZW50KSB7XG4gICAgICB0aGlzLnN0YXRlc1tkZXN0aW5hdGlvblN0YXRlXS5vbkVudGVyPy4oY3VycmVudFN0YXRlLCBkYXRhKTtcbiAgICB9XG4gIH1cbiAgdHJhbnNpdGlvbkFzeW5jKGV2ZW50LCBkYXRhKSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnRyYW5zaXRpb24oZXZlbnQsIGRhdGEpO1xuICAgIH0sIDApO1xuICB9XG4gIGlzKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IF9TdGF0ZU1hY2hpbmUuY2hpbGQgJiYgdGhpcy5jaGlsZFN0YXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGlsZFN0YXRlLmlzKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IHZhbHVlO1xuICB9XG4gIHJlc2V0SGllcmFyY2h5KCkge1xuICAgIHRoaXMuZGVidWcoXG4gICAgICBgJWMke3RoaXMuY29uc3RydWN0b3IubmFtZX0gfCAke3RoaXMuc3RhdGV9IC0+IFtyZXNldEhpZXJhcmNoeV0gLT4gJHt0aGlzLmRlZmF1bHRTdGF0ZX1gLFxuICAgICAgXCJjb2xvcjogZ3JlZW5cIlxuICAgICk7XG4gICAgdGhpcy5zdGF0ZSA9IHRoaXMuZGVmYXVsdFN0YXRlO1xuICB9XG4gIHRyYW5zaXRpb25DaGlsZChldmVudCwgZGF0YSkge1xuICAgIGlmICh0aGlzLnN0YXRlICE9PSBfU3RhdGVNYWNoaW5lLmNoaWxkIHx8ICF0aGlzLmNoaWxkU3RhdGUpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB0aGlzLmNoaWxkU3RhdGUudHJhbnNpdGlvbihldmVudCwgZGF0YSk7XG4gICAgaWYgKCF0aGlzLmNoaWxkU3RhdGUuaXMoX1N0YXRlTWFjaGluZS5wYXJlbnQpKVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgdGhpcy5kZWJ1ZyhgJWMke3RoaXMuY29uc3RydWN0b3IubmFtZX0gfCAke3RoaXMuc3RhdGV9IC0+ICR7ZXZlbnR9IC0+ICR7dGhpcy5kZWZhdWx0U3RhdGV9YCwgZGVidWdDb2xvcik7XG4gICAgdGhpcy5zdGF0ZSA9IHRoaXMuZGVmYXVsdFN0YXRlO1xuICAgIHRoaXMuc3RhdGVzW3RoaXMuc3RhdGVdLm9uRW50ZXI/LigpO1xuICAgIHRoaXMuY2hpbGRTdGF0ZS5yZXNldEhpZXJhcmNoeSgpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBnZXREZXN0aW5hdGlvblN0YXRlKGRlc3RpbmF0aW9uKSB7XG4gICAgbGV0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAodHlwZW9mIGRlc3RpbmF0aW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBzdGF0ZSA9IGRlc3RpbmF0aW9uO1xuICAgIH0gZWxzZSBpZiAoZGVzdGluYXRpb24gaW5zdGFuY2VvZiBfU3RhdGVNYWNoaW5lKSB7XG4gICAgICB0aGlzLmNoaWxkU3RhdGUgPSBkZXN0aW5hdGlvbjtcbiAgICAgIHN0YXRlID0gX1N0YXRlTWFjaGluZS5jaGlsZDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZXN0aW5hdGlvbiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgaWYgKGRlc3RpbmF0aW9uLnRhcmdldCBpbnN0YW5jZW9mIF9TdGF0ZU1hY2hpbmUpIHtcbiAgICAgICAgdGhpcy5jaGlsZFN0YXRlID0gZGVzdGluYXRpb24udGFyZ2V0O1xuICAgICAgICBzdGF0ZSA9IF9TdGF0ZU1hY2hpbmUuY2hpbGQ7XG4gICAgICB9IGVsc2UgaWYgKGRlc3RpbmF0aW9uLnRhcmdldCAhPSBudWxsKSB7XG4gICAgICAgIHN0YXRlID0gZGVzdGluYXRpb24udGFyZ2V0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn07XG5fU3RhdGVNYWNoaW5lLmNoaWxkID0gXCJfX2NoaWxkXCI7XG5fU3RhdGVNYWNoaW5lLnBhcmVudCA9IFwiX19wYXJlbnRcIjtcbnZhciBTdGF0ZU1hY2hpbmUgPSBfU3RhdGVNYWNoaW5lO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3RleHRXcmFwcGVyLnRzXG52YXIgVGV4dFdyYXBwZXIgPSBjbGFzcyB7XG4gIHN0YXRpYyB3cmFwVGV4dCh0ZXh0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMud3JhcExpbmVzKHRleHQsIG9wdGlvbnMpLmpvaW4oXCJcXG5cIik7XG4gIH1cbiAgc3RhdGljIHdyYXBMaW5lcyh0ZXh0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgY2xpcHBlZFJlc3VsdCA9IHRoaXMudGV4dFdyYXAodGV4dCwgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMub3ZlcmZsb3cgPT09IFwiaGlkZVwiICYmIGNsaXBwZWRSZXN1bHQuc29tZSgobCkgPT4gbC5lbmRzV2l0aChUZXh0VXRpbHMuRWxsaXBzaXNDaGFyKSkpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIGNsaXBwZWRSZXN1bHQ7XG4gIH1cbiAgc3RhdGljIGFwcGVuZEVsbGlwc2lzKHRleHQpIHtcbiAgICByZXR1cm4gdGV4dC5yZXBsYWNlKC9bLixdezEsNX0kLywgXCJcIikgKyBUZXh0VXRpbHMuRWxsaXBzaXNDaGFyO1xuICB9XG4gIHN0YXRpYyB0cnVuY2F0ZUxpbmUodGV4dCwgbWVhc3VyZXIsIG1heFdpZHRoLCBlbGxpcHNpc0ZvcmNlKSB7XG4gICAgY29uc3QgZWxsaXBzaXNXaWR0aCA9IG1lYXN1cmVyLnRleHRXaWR0aChUZXh0VXRpbHMuRWxsaXBzaXNDaGFyKTtcbiAgICBsZXQgZXN0aW1hdGVkV2lkdGggPSAwO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoYXJXaWR0aCA9IG1lYXN1cmVyLnRleHRXaWR0aCh0ZXh0LmNoYXJBdChpKSk7XG4gICAgICBpZiAoZXN0aW1hdGVkV2lkdGggKyBjaGFyV2lkdGggPiBtYXhXaWR0aClcbiAgICAgICAgYnJlYWs7XG4gICAgICBlc3RpbWF0ZWRXaWR0aCArPSBjaGFyV2lkdGg7XG4gICAgfVxuICAgIGlmICh0ZXh0Lmxlbmd0aCA9PT0gaSAmJiAoIWVsbGlwc2lzRm9yY2UgfHwgZXN0aW1hdGVkV2lkdGggKyBlbGxpcHNpc1dpZHRoIDw9IG1heFdpZHRoKSkge1xuICAgICAgcmV0dXJuIGVsbGlwc2lzRm9yY2UgPyB0ZXh0ICsgVGV4dFV0aWxzLkVsbGlwc2lzQ2hhciA6IHRleHQ7XG4gICAgfVxuICAgIHRleHQgPSB0ZXh0LnNsaWNlKDAsIGkpLnRyaW1FbmQoKTtcbiAgICB3aGlsZSAodGV4dC5sZW5ndGggJiYgbWVhc3VyZXIudGV4dFdpZHRoKHRleHQpICsgZWxsaXBzaXNXaWR0aCA+IG1heFdpZHRoKSB7XG4gICAgICB0ZXh0ID0gdGV4dC5zbGljZSgwLCAtMSkudHJpbUVuZCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dCArIFRleHRVdGlscy5FbGxpcHNpc0NoYXI7XG4gIH1cbiAgc3RhdGljIHRleHRXcmFwKHRleHQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBsaW5lcyA9IHRleHQuc3BsaXQoVGV4dFV0aWxzLmxpbmVTcGxpdHRlcik7XG4gICAgY29uc3QgbWVhc3VyZXIgPSBDYWNoZWRUZXh0TWVhc3VyZXJQb29sLmdldE1lYXN1cmVyKG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLnRleHRXcmFwID09PSBcIm5ldmVyXCIpIHtcbiAgICAgIHJldHVybiBsaW5lcy5tYXAoKGxpbmUpID0+IHRoaXMudHJ1bmNhdGVMaW5lKGxpbmUudHJpbUVuZCgpLCBtZWFzdXJlciwgb3B0aW9ucy5tYXhXaWR0aCkpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBjb25zdCB3cmFwSHlwaGVuYXRlID0gb3B0aW9ucy50ZXh0V3JhcCA9PT0gXCJoeXBoZW5hdGVcIjtcbiAgICBjb25zdCB3cmFwT25TcGFjZSA9IG9wdGlvbnMudGV4dFdyYXAgPT0gbnVsbCB8fCBvcHRpb25zLnRleHRXcmFwID09PSBcIm9uLXNwYWNlXCI7XG4gICAgZm9yIChsZXQgbGluZSBvZiBsaW5lcykge1xuICAgICAgbGluZSA9IGxpbmUudHJpbUVuZCgpO1xuICAgICAgaWYgKGxpbmUgPT09IFwiXCIpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobGluZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDAsIGVzdGltYXRlZFdpZHRoID0gMCwgbGFzdFNwYWNlSW5kZXggPSAwOyBpIDwgbGluZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjaGFyID0gbGluZS5jaGFyQXQoaSk7XG4gICAgICAgIGVzdGltYXRlZFdpZHRoICs9IG1lYXN1cmVyLnRleHRXaWR0aChjaGFyKTtcbiAgICAgICAgaWYgKGNoYXIgPT09IFwiIFwiKSB7XG4gICAgICAgICAgbGFzdFNwYWNlSW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlc3RpbWF0ZWRXaWR0aCA+IG9wdGlvbnMubWF4V2lkdGgpIHtcbiAgICAgICAgICBpZiAoaSA9PT0gMClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNvbnN0IGFjdHVhbFdpZHRoID0gbWVhc3VyZXIudGV4dFdpZHRoKGxpbmUuc2xpY2UoMCwgaSArIDEpKTtcbiAgICAgICAgICBpZiAoYWN0dWFsV2lkdGggPD0gb3B0aW9ucy5tYXhXaWR0aCkge1xuICAgICAgICAgICAgZXN0aW1hdGVkV2lkdGggPSBhY3R1YWxXaWR0aDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobGFzdFNwYWNlSW5kZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRXb3JkID0gdGhpcy5nZXRXb3JkQXQobGluZSwgbGFzdFNwYWNlSW5kZXggKyAxKTtcbiAgICAgICAgICAgIGNvbnN0IHRleHRXaWR0aCA9IG1lYXN1cmVyLnRleHRXaWR0aChuZXh0V29yZCk7XG4gICAgICAgICAgICBpZiAodGV4dFdpZHRoIDw9IG9wdGlvbnMubWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobGluZS5zbGljZSgwLCBsYXN0U3BhY2VJbmRleCkudHJpbUVuZCgpKTtcbiAgICAgICAgICAgICAgbGluZSA9IGxpbmUuc2xpY2UobGFzdFNwYWNlSW5kZXgpLnRyaW1TdGFydCgpO1xuICAgICAgICAgICAgICBpID0gLTE7XG4gICAgICAgICAgICAgIGVzdGltYXRlZFdpZHRoID0gMDtcbiAgICAgICAgICAgICAgbGFzdFNwYWNlSW5kZXggPSAwO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAod3JhcE9uU3BhY2UgJiYgdGV4dFdpZHRoID4gb3B0aW9ucy5tYXhXaWR0aCkge1xuICAgICAgICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICAgICAgICBsaW5lLnNsaWNlKDAsIGxhc3RTcGFjZUluZGV4KS50cmltRW5kKCksXG4gICAgICAgICAgICAgICAgdGhpcy50cnVuY2F0ZUxpbmUoXG4gICAgICAgICAgICAgICAgICBsaW5lLnNsaWNlKGxhc3RTcGFjZUluZGV4KS50cmltU3RhcnQoKSxcbiAgICAgICAgICAgICAgICAgIG1lYXN1cmVyLFxuICAgICAgICAgICAgICAgICAgb3B0aW9ucy5tYXhXaWR0aCxcbiAgICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh3cmFwT25TcGFjZSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy50cnVuY2F0ZUxpbmUobGluZSwgbWVhc3VyZXIsIG9wdGlvbnMubWF4V2lkdGgsIHRydWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHdyYXBPblNwYWNlKSB7XG4gICAgICAgICAgICBsaW5lID0gXCJcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBwb3N0Zml4ID0gd3JhcEh5cGhlbmF0ZSA/IFwiLVwiIDogXCJcIjtcbiAgICAgICAgICBsZXQgbmV3TGluZSA9IGxpbmUuc2xpY2UoMCwgaSkudHJpbSgpO1xuICAgICAgICAgIHdoaWxlIChuZXdMaW5lLmxlbmd0aCAmJiBtZWFzdXJlci50ZXh0V2lkdGgobmV3TGluZSArIHBvc3RmaXgpID4gb3B0aW9ucy5tYXhXaWR0aCkge1xuICAgICAgICAgICAgbmV3TGluZSA9IG5ld0xpbmUuc2xpY2UoMCwgLTEpLnRyaW1FbmQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2gobmV3TGluZSArIHBvc3RmaXgpO1xuICAgICAgICAgIGlmICghbmV3TGluZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxpbmUgPSBcIlwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxpbmUgPSBsaW5lLnNsaWNlKG5ld0xpbmUubGVuZ3RoKS50cmltU3RhcnQoKTtcbiAgICAgICAgICBpID0gLTE7XG4gICAgICAgICAgZXN0aW1hdGVkV2lkdGggPSAwO1xuICAgICAgICAgIGxhc3RTcGFjZUluZGV4ID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxpbmUpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobGluZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYXZvaWRPcnBoYW5zKHJlc3VsdCwgbWVhc3VyZXIsIG9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzLmNsaXBMaW5lcyhyZXN1bHQsIG1lYXN1cmVyLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZ2V0V29yZEF0KHRleHQsIHBvc2l0aW9uKSB7XG4gICAgY29uc3QgbmV4dFNwYWNlSW5kZXggPSB0ZXh0LmluZGV4T2YoXCIgXCIsIHBvc2l0aW9uKTtcbiAgICByZXR1cm4gbmV4dFNwYWNlSW5kZXggPT09IC0xID8gdGV4dC5zbGljZShwb3NpdGlvbikgOiB0ZXh0LnNsaWNlKHBvc2l0aW9uLCBuZXh0U3BhY2VJbmRleCk7XG4gIH1cbiAgc3RhdGljIGNsaXBMaW5lcyhsaW5lcywgbWVhc3VyZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMubWF4SGVpZ2h0KSB7XG4gICAgICByZXR1cm4gbGluZXM7XG4gICAgfVxuICAgIGNvbnN0IHsgaGVpZ2h0OiBoZWlnaHQyLCBsaW5lTWV0cmljcyB9ID0gbWVhc3VyZXIubWVhc3VyZUxpbmVzKGxpbmVzKTtcbiAgICBpZiAoaGVpZ2h0MiA8PSBvcHRpb25zLm1heEhlaWdodCkge1xuICAgICAgcmV0dXJuIGxpbmVzO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMCwgY3VtdWxhdGl2ZUhlaWdodCA9IDA7IGkgPCBsaW5lTWV0cmljcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgeyBsaW5lSGVpZ2h0IH0gPSBsaW5lTWV0cmljc1tpXTtcbiAgICAgIGN1bXVsYXRpdmVIZWlnaHQgKz0gbGluZUhlaWdodDtcbiAgICAgIGlmIChjdW11bGF0aXZlSGVpZ2h0ID4gb3B0aW9ucy5tYXhIZWlnaHQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMub3ZlcmZsb3cgPT09IFwiaGlkZVwiKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsaXBwZWRSZXN1bHRzID0gbGluZXMuc2xpY2UoMCwgaSB8fCAxKTtcbiAgICAgICAgY29uc3QgbGFzdExpbmUgPSBjbGlwcGVkUmVzdWx0cy5wb3AoKTtcbiAgICAgICAgcmV0dXJuIGNsaXBwZWRSZXN1bHRzLmNvbmNhdCh0aGlzLnRydW5jYXRlTGluZShsYXN0TGluZSwgbWVhc3VyZXIsIG9wdGlvbnMubWF4V2lkdGgsIHRydWUpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxpbmVzO1xuICB9XG4gIHN0YXRpYyBhdm9pZE9ycGhhbnMobGluZXMsIG1lYXN1cmVyLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuYXZvaWRPcnBoYW5zID09PSBmYWxzZSB8fCBsaW5lcy5sZW5ndGggPCAyKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgbGVuZ3RoOiBsZW5ndGgyIH0gPSBsaW5lcztcbiAgICBjb25zdCBsYXN0TGluZSA9IGxpbmVzW2xlbmd0aDIgLSAxXTtcbiAgICBjb25zdCBiZWZvcmVMYXN0ID0gbGluZXNbbGVuZ3RoMiAtIDJdO1xuICAgIGlmIChiZWZvcmVMYXN0Lmxlbmd0aCA8IGxhc3RMaW5lLmxlbmd0aClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBsYXN0U3BhY2VJbmRleCA9IGJlZm9yZUxhc3QubGFzdEluZGV4T2YoXCIgXCIpO1xuICAgIGlmIChsYXN0U3BhY2VJbmRleCA9PT0gLTEgfHwgbGFzdFNwYWNlSW5kZXggPT09IGJlZm9yZUxhc3QuaW5kZXhPZihcIiBcIikgfHwgbGFzdExpbmUuaW5jbHVkZXMoXCIgXCIpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGxhc3RXb3JkID0gYmVmb3JlTGFzdC5zbGljZShsYXN0U3BhY2VJbmRleCArIDEpO1xuICAgIGlmIChtZWFzdXJlci50ZXh0V2lkdGgobGFzdExpbmUgKyBsYXN0V29yZCkgPD0gb3B0aW9ucy5tYXhXaWR0aCkge1xuICAgICAgbGluZXNbbGVuZ3RoMiAtIDJdID0gYmVmb3JlTGFzdC5zbGljZSgwLCBsYXN0U3BhY2VJbmRleCk7XG4gICAgICBsaW5lc1tsZW5ndGgyIC0gMV0gPSBsYXN0V29yZCArIFwiIFwiICsgbGFzdExpbmU7XG4gICAgfVxuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9tb2R1bGUvZW50ZXJwcmlzZU1vZHVsZS50c1xudmFyIGVudGVycHJpc2VNb2R1bGUgPSB7XG4gIGlzRW50ZXJwcmlzZTogZmFsc2Vcbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvYXR0cmlidXRlVXRpbC50c1xuZnVuY3Rpb24gc2V0QXR0cmlidXRlKGUsIHF1YWxpZmllZE5hbWUsIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gdm9pZCAwIHx8IHZhbHVlID09PSBcIlwiKSB7XG4gICAgZT8ucmVtb3ZlQXR0cmlidXRlKHF1YWxpZmllZE5hbWUpO1xuICB9IGVsc2Uge1xuICAgIGU/LnNldEF0dHJpYnV0ZShxdWFsaWZpZWROYW1lLCB2YWx1ZS50b1N0cmluZygpKTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0QXR0cmlidXRlcyhlLCBhdHRycykge1xuICBpZiAoYXR0cnMgPT0gbnVsbClcbiAgICByZXR1cm47XG4gIGxldCBrZXk7XG4gIGZvciAoa2V5IGluIGF0dHJzKSB7XG4gICAgaWYgKGtleSA9PT0gXCJjbGFzc1wiKVxuICAgICAgY29udGludWU7XG4gICAgc2V0QXR0cmlidXRlKGUsIGtleSwgYXR0cnNba2V5XSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEF0dHJpYnV0ZShlLCBxdWFsaWZpZWROYW1lLCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKCEoZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSlcbiAgICByZXR1cm4gdm9pZCAwO1xuICBjb25zdCB2YWx1ZSA9IGUuZ2V0QXR0cmlidXRlKHF1YWxpZmllZE5hbWUpO1xuICBpZiAodmFsdWUgPT09IG51bGwpXG4gICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgY29uc3QgdHlwZSA9IHR5cGVvZiB7fVtxdWFsaWZpZWROYW1lXTtcbiAgaWYgKHR5cGUgPT09IFwiYm9vbGVhblwiKVxuICAgIHJldHVybiB2YWx1ZSA9PT0gXCJ0cnVlXCI7XG4gIGlmICh0eXBlID09PSBcIm51bWJlclwiKVxuICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xuICBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gdmFsdWU7XG4gIHJldHVybiB2b2lkIDA7XG59XG5mdW5jdGlvbiBzZXRFbGVtZW50U3R5bGUoZSwgcHJvcGVydHksIHZhbHVlKSB7XG4gIGlmIChlID09IG51bGwpXG4gICAgcmV0dXJuO1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIGUuc3R5bGUucmVtb3ZlUHJvcGVydHkocHJvcGVydHkpO1xuICB9IGVsc2Uge1xuICAgIGUuc3R5bGUuc2V0UHJvcGVydHkocHJvcGVydHksIHZhbHVlKTtcbiAgfVxufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3BsYWNlbWVudC50c1xuZnVuY3Rpb24gY2FsY3VsYXRlUGxhY2VtZW50KG5hdHVyYWxXaWR0aCwgbmF0dXJhbEhlaWdodCwgY29udGFpbmVyLCBib3VuZHMpIHtcbiAgbGV0IHsgdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0LCB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIgfSA9IGJvdW5kcztcbiAgaWYgKGxlZnQgIT0gbnVsbCkge1xuICAgIGlmICh3aWR0aDIgIT0gbnVsbCkge1xuICAgICAgcmlnaHQgPSBjb250YWluZXIud2lkdGggLSBsZWZ0ICsgd2lkdGgyO1xuICAgIH0gZWxzZSBpZiAocmlnaHQgIT0gbnVsbCkge1xuICAgICAgd2lkdGgyID0gY29udGFpbmVyLndpZHRoIC0gbGVmdCAtIHJpZ2h0O1xuICAgIH1cbiAgfSBlbHNlIGlmIChyaWdodCAhPSBudWxsICYmIHdpZHRoMiAhPSBudWxsKSB7XG4gICAgbGVmdCA9IGNvbnRhaW5lci53aWR0aCAtIHJpZ2h0IC0gd2lkdGgyO1xuICB9XG4gIGlmICh0b3AgIT0gbnVsbCkge1xuICAgIGlmIChoZWlnaHQyICE9IG51bGwpIHtcbiAgICAgIGJvdHRvbSA9IGNvbnRhaW5lci5oZWlnaHQgLSB0b3AgLSBoZWlnaHQyO1xuICAgIH0gZWxzZSBpZiAoYm90dG9tICE9IG51bGwpIHtcbiAgICAgIGhlaWdodDIgPSBjb250YWluZXIuaGVpZ2h0IC0gYm90dG9tIC0gdG9wO1xuICAgIH1cbiAgfSBlbHNlIGlmIChib3R0b20gIT0gbnVsbCAmJiBoZWlnaHQyICE9IG51bGwpIHtcbiAgICB0b3AgPSBjb250YWluZXIuaGVpZ2h0IC0gYm90dG9tIC0gaGVpZ2h0MjtcbiAgfVxuICBpZiAod2lkdGgyID09IG51bGwpIHtcbiAgICBpZiAoaGVpZ2h0MiA9PSBudWxsKSB7XG4gICAgICB3aWR0aDIgPSBuYXR1cmFsV2lkdGg7XG4gICAgICBoZWlnaHQyID0gbmF0dXJhbEhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgd2lkdGgyID0gTWF0aC5jZWlsKG5hdHVyYWxXaWR0aCAqIGhlaWdodDIgLyBuYXR1cmFsSGVpZ2h0KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaGVpZ2h0MiA9PSBudWxsKSB7XG4gICAgaGVpZ2h0MiA9IE1hdGguY2VpbChuYXR1cmFsSGVpZ2h0ICogd2lkdGgyIC8gbmF0dXJhbFdpZHRoKTtcbiAgfVxuICBpZiAobGVmdCA9PSBudWxsKSB7XG4gICAgaWYgKHJpZ2h0ID09IG51bGwpIHtcbiAgICAgIGxlZnQgPSBNYXRoLmZsb29yKChjb250YWluZXIud2lkdGggLSB3aWR0aDIpIC8gMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlZnQgPSBjb250YWluZXIud2lkdGggLSByaWdodCAtIHdpZHRoMjtcbiAgICB9XG4gIH1cbiAgaWYgKHRvcCA9PSBudWxsKSB7XG4gICAgaWYgKGJvdHRvbSA9PSBudWxsKSB7XG4gICAgICB0b3AgPSBNYXRoLmZsb29yKChjb250YWluZXIuaGVpZ2h0IC0gaGVpZ2h0MikgLyAyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9wID0gY29udGFpbmVyLmhlaWdodCAtIGhlaWdodDIgLSBib3R0b207XG4gICAgfVxuICB9XG4gIHJldHVybiB7IHg6IGxlZnQsIHk6IHRvcCwgd2lkdGg6IHdpZHRoMiwgaGVpZ2h0OiBoZWlnaHQyIH07XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Rvb2x0aXAvdG9vbHRpcC50c1xudmFyIERFRkFVTFRfVE9PTFRJUF9DTEFTUyA9IFwiYWctY2hhcnQtdG9vbHRpcFwiO1xudmFyIERFRkFVTFRfVE9PTFRJUF9EQVJLX0NMQVNTID0gXCJhZy1jaGFydC1kYXJrLXRvb2x0aXBcIjtcbnZhciBFTVBUWV9UT09MVElQX0NPTlRFTlQgPSB7IGh0bWw6IFwiXCIsIGFyaWFMYWJlbDogXCJcIiB9O1xuZnVuY3Rpb24gdG9BY2Nlc3NpYmxlVGV4dChpbnB1dEh0bWwpIHtcbiAgY29uc3QgbGluZUNvbnZlcnRlciA9IChfbWF0Y2gsIG9mZnNldDQsIHN0cikgPT4ge1xuICAgIGlmIChvZmZzZXQ0ID09PSAwIHx8IHN0cltvZmZzZXQ0IC0gMV0gIT09IFwiLlwiKSB7XG4gICAgICByZXR1cm4gXCIuIFwiO1xuICAgIH1cbiAgICByZXR1cm4gXCIgXCI7XG4gIH07XG4gIHJldHVybiBpbnB1dEh0bWwucmVwbGFjZSgvPGJyXFxzKlxcLz8+L2csIGxpbmVDb252ZXJ0ZXIpLnJlcGxhY2UoLzxcXC9wXFxzKz4vZywgbGluZUNvbnZlcnRlcikucmVwbGFjZSgvPFxcL2xpXFxzKj4vZywgbGluZUNvbnZlcnRlcikucmVwbGFjZSgvPFtePD5dKz4vZywgXCJcIikucmVwbGFjZSgvXFxuKy9nLCBcIiBcIikucmVwbGFjZSgvXFxzKy9nLCBcIiBcIik7XG59XG5mdW5jdGlvbiB0b1Rvb2x0aXBIdG1sKGlucHV0LCBkZWZhdWx0cykge1xuICBpZiAodHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHsgaHRtbDogaW5wdXQsIGFyaWFMYWJlbDogaW5wdXQgfTtcbiAgfVxuICBjb25zdCB7XG4gICAgY29udGVudCA9IGRlZmF1bHRzPy5jb250ZW50ID8/IFwiXCIsXG4gICAgdGl0bGUgPSBkZWZhdWx0cz8udGl0bGUsXG4gICAgY29sb3IgPSBkZWZhdWx0cz8uY29sb3IgPz8gXCJ3aGl0ZVwiLFxuICAgIGJhY2tncm91bmRDb2xvciA9IGRlZmF1bHRzPy5iYWNrZ3JvdW5kQ29sb3IgPz8gXCIjODg4XCJcbiAgfSA9IGlucHV0O1xuICBjb25zdCB0aXRsZUh0bWwgPSB0aXRsZSA/IGA8ZGl2IGNsYXNzPVwiJHtERUZBVUxUX1RPT0xUSVBfQ0xBU1N9LXRpdGxlXCJcbiAgICAgICAgc3R5bGU9XCJjb2xvcjogJHtjb2xvcn07IGJhY2tncm91bmQtY29sb3I6ICR7YmFja2dyb3VuZENvbG9yfVwiPiR7dGl0bGV9PC9kaXY+YCA6IFwiXCI7XG4gIGNvbnN0IHRpdGxlQXJpYSA9IHRpdGxlID8gYCR7dGl0bGV9OiBgIDogXCJcIjtcbiAgY29uc3QgY29udGVudEh0bWwgPSBjb250ZW50ID8gYDxkaXYgY2xhc3M9XCIke0RFRkFVTFRfVE9PTFRJUF9DTEFTU30tY29udGVudFwiPiR7Y29udGVudH08L2Rpdj5gIDogXCJcIjtcbiAgcmV0dXJuIHtcbiAgICBodG1sOiBgJHt0aXRsZUh0bWx9JHtjb250ZW50SHRtbH1gLFxuICAgIGFyaWFMYWJlbDogdG9BY2Nlc3NpYmxlVGV4dChgJHt0aXRsZUFyaWF9JHtjb250ZW50fWApXG4gIH07XG59XG52YXIgVG9vbHRpcFBvc2l0aW9uID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgLyoqIFRoZSB0eXBlIG9mIHBvc2l0aW9uaW5nIGZvciB0aGUgdG9vbHRpcC4gQnkgZGVmYXVsdCwgdGhlIHRvb2x0aXAgZm9sbG93cyB0aGUgcG9pbnRlci4gKi9cbiAgICB0aGlzLnR5cGUgPSBcInBvaW50ZXJcIjtcbiAgICAvKiogVGhlIGhvcml6b250YWwgb2Zmc2V0IGluIHBpeGVscyBmb3IgdGhlIHBvc2l0aW9uIG9mIHRoZSB0b29sdGlwLiAqL1xuICAgIHRoaXMueE9mZnNldCA9IDA7XG4gICAgLyoqIFRoZSB2ZXJ0aWNhbCBvZmZzZXQgaW4gcGl4ZWxzIGZvciB0aGUgcG9zaXRpb24gb2YgdGhlIHRvb2x0aXAuICovXG4gICAgdGhpcy55T2Zmc2V0ID0gMDtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFxuICAgIFVOSU9OKFxuICAgICAgW1xuICAgICAgICBcInBvaW50ZXJcIixcbiAgICAgICAgXCJub2RlXCIsXG4gICAgICAgIFwidG9wXCIsXG4gICAgICAgIFwicmlnaHRcIixcbiAgICAgICAgXCJib3R0b21cIixcbiAgICAgICAgXCJsZWZ0XCIsXG4gICAgICAgIFwidG9wLWxlZnRcIixcbiAgICAgICAgXCJ0b3AtcmlnaHRcIixcbiAgICAgICAgXCJib3R0b20tcmlnaHRcIixcbiAgICAgICAgXCJib3R0b20tbGVmdFwiLFxuICAgICAgICB7IHZhbHVlOiBcInNwYXJrbGluZVwiLCB1bmRvY3VtZW50ZWQ6IHRydWUgfVxuICAgICAgXSxcbiAgICAgIFwiYSBwb3NpdGlvbiB0eXBlXCJcbiAgICApXG4gIClcbl0sIFRvb2x0aXBQb3NpdGlvbi5wcm90b3R5cGUsIFwidHlwZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE5VTUJFUilcbl0sIFRvb2x0aXBQb3NpdGlvbi5wcm90b3R5cGUsIFwieE9mZnNldFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE5VTUJFUilcbl0sIFRvb2x0aXBQb3NpdGlvbi5wcm90b3R5cGUsIFwieU9mZnNldFwiLCAyKTtcbnZhciBUb29sdGlwID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLmRlbGF5ID0gMDtcbiAgICB0aGlzLnJhbmdlID0gdm9pZCAwO1xuICAgIHRoaXMud3JhcHBpbmcgPSBcImh5cGhlbmF0ZVwiO1xuICAgIHRoaXMucG9zaXRpb24gPSBuZXcgVG9vbHRpcFBvc2l0aW9uKCk7XG4gICAgdGhpcy5kYXJrVGhlbWUgPSBmYWxzZTtcbiAgICB0aGlzLmJvdW5kcyA9IFwiZXh0ZW5kZWRcIjtcbiAgICB0aGlzLmVuYWJsZUludGVyYWN0aW9uID0gZmFsc2U7XG4gICAgdGhpcy5sYXN0VmlzaWJpbGl0eUNoYW5nZSA9IERhdGUubm93KCk7XG4gICAgdGhpcy53cmFwVHlwZXMgPSBbXCJhbHdheXNcIiwgXCJoeXBoZW5hdGVcIiwgXCJvbi1zcGFjZVwiLCBcIm5ldmVyXCJdO1xuICAgIHRoaXMuc2hvd1RpbWVvdXQgPSAwO1xuICAgIHRoaXMuX3Nob3dBcnJvdyA9IHRydWU7XG4gIH1cbiAgZ2V0IGludGVyYWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLmVuYWJsZUludGVyYWN0aW9uO1xuICB9XG4gIHNldHVwKGRvbU1hbmFnZXIpIHtcbiAgICB0aGlzLmVsZW1lbnQgPSBkb21NYW5hZ2VyLmFkZENoaWxkKFwiY2FudmFzLW92ZXJsYXlcIiwgREVGQVVMVF9UT09MVElQX0NMQVNTKTtcbiAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZChERUZBVUxUX1RPT0xUSVBfQ0xBU1MpO1xuICB9XG4gIGRlc3Ryb3koZG9tTWFuYWdlcikge1xuICAgIGRvbU1hbmFnZXIucmVtb3ZlQ2hpbGQoXCJjYW52YXMtb3ZlcmxheVwiLCBERUZBVUxUX1RPT0xUSVBfQ0xBU1MpO1xuICB9XG4gIGlzVmlzaWJsZSgpIHtcbiAgICByZXR1cm4gIXRoaXMuZWxlbWVudD8uY2xhc3NMaXN0LmNvbnRhaW5zKERFRkFVTFRfVE9PTFRJUF9DTEFTUyArIFwiLWhpZGRlblwiKTtcbiAgfVxuICAvKipcbiAgICogU2hvd3MgdG9vbHRpcCBhdCB0aGUgZ2l2ZW4gZXZlbnQncyBjb29yZGluYXRlcy5cbiAgICogSWYgdGhlIGBodG1sYCBwYXJhbWV0ZXIgaXMgbWlzc2luZywgbW92ZXMgdGhlIGV4aXN0aW5nIHRvb2x0aXAgdG8gdGhlIG5ldyBwb3NpdGlvbi5cbiAgICovXG4gIHNob3coYm91bmRpbmdSZWN0LCBjYW52YXNSZWN0LCBtZXRhLCBjb250ZW50LCBpbnN0YW50bHkgPSBmYWxzZSkge1xuICAgIGNvbnN0IHsgZWxlbWVudDogZWxlbWVudDIgfSA9IHRoaXM7XG4gICAgY29uc3QgZXhpc3RpbmdQb3NpdGlvbiA9IGVsZW1lbnQyPy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAoY29udGVudCAhPSBudWxsICYmIGVsZW1lbnQyICE9IG51bGwpIHtcbiAgICAgIGVsZW1lbnQyLmlubmVySFRNTCA9IGNvbnRlbnQuaHRtbDtcbiAgICB9IGVsc2UgaWYgKCFlbGVtZW50Mj8uaW5uZXJIVE1MKSB7XG4gICAgICB0aGlzLnRvZ2dsZShmYWxzZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBvc2l0aW9uVHlwZSA9IG1ldGEucG9zaXRpb24/LnR5cGUgPz8gdGhpcy5wb3NpdGlvbi50eXBlO1xuICAgIGNvbnN0IHhPZmZzZXQgPSBtZXRhLnBvc2l0aW9uPy54T2Zmc2V0ID8/IDA7XG4gICAgY29uc3QgeU9mZnNldCA9IG1ldGEucG9zaXRpb24/LnlPZmZzZXQgPz8gMDtcbiAgICBjb25zdCB0b29sdGlwQm91bmRzID0gdGhpcy5nZXRUb29sdGlwQm91bmRzKHsgcG9zaXRpb25UeXBlLCBtZXRhLCB5T2Zmc2V0LCB4T2Zmc2V0LCBjYW52YXNSZWN0IH0pO1xuICAgIGNvbnN0IHJlbGF0aXZlUmVjdCA9IHtcbiAgICAgIHg6IGJvdW5kaW5nUmVjdC54IC0gY2FudmFzUmVjdC54LFxuICAgICAgeTogYm91bmRpbmdSZWN0LnkgLSBjYW52YXNSZWN0LnksXG4gICAgICB3aWR0aDogYm91bmRpbmdSZWN0LndpZHRoLFxuICAgICAgaGVpZ2h0OiBib3VuZGluZ1JlY3QuaGVpZ2h0XG4gICAgfTtcbiAgICBjb25zdCBwb3NpdGlvbiA9IGNhbGN1bGF0ZVBsYWNlbWVudChlbGVtZW50Mi5jbGllbnRXaWR0aCwgZWxlbWVudDIuY2xpZW50SGVpZ2h0LCByZWxhdGl2ZVJlY3QsIHRvb2x0aXBCb3VuZHMpO1xuICAgIGNvbnN0IG1pblggPSByZWxhdGl2ZVJlY3QueDtcbiAgICBjb25zdCBtaW5ZID0gcmVsYXRpdmVSZWN0Lnk7XG4gICAgY29uc3QgbWF4WCA9IHJlbGF0aXZlUmVjdC53aWR0aCAtIGVsZW1lbnQyLmNsaWVudFdpZHRoIC0gMSArIG1pblg7XG4gICAgY29uc3QgbWF4WSA9IHJlbGF0aXZlUmVjdC5oZWlnaHQgLSBlbGVtZW50Mi5jbGllbnRIZWlnaHQgKyBtaW5ZO1xuICAgIGNvbnN0IGxlZnQgPSBjbGFtcChtaW5YLCBwb3NpdGlvbi54LCBtYXhYKTtcbiAgICBjb25zdCB0b3AgPSBjbGFtcChtaW5ZLCBwb3NpdGlvbi55LCBtYXhZKTtcbiAgICBsZXQgd2lsbEV4aXN0T3V0c2lkZUJvdW5kaW5nUmVjdER1cmluZ1RyYW5zaXRpb24gPSBmYWxzZTtcbiAgICBpZiAoZXhpc3RpbmdQb3NpdGlvbiAhPSBudWxsKSB7XG4gICAgICBjb25zdCBtYXhYV2l0aFByZXZpb3VzUG9zaXRpb24gPSByZWxhdGl2ZVJlY3Qud2lkdGggLSBleGlzdGluZ1Bvc2l0aW9uLndpZHRoIC0gMSArIG1pblg7XG4gICAgICBjb25zdCBtYXhZV2l0aFByZXZpb3VzUG9zaXRpb24gPSByZWxhdGl2ZVJlY3QuaGVpZ2h0IC0gZXhpc3RpbmdQb3NpdGlvbi5oZWlnaHQgKyBtaW5ZO1xuICAgICAgd2lsbEV4aXN0T3V0c2lkZUJvdW5kaW5nUmVjdER1cmluZ1RyYW5zaXRpb24gPSBtYXhYV2l0aFByZXZpb3VzUG9zaXRpb24gPiBtYXhYIHx8IG1heFlXaXRoUHJldmlvdXNQb3NpdGlvbiA+IG1heFk7XG4gICAgfVxuICAgIGNvbnN0IGNvbnN0cmFpbmVkID0gbGVmdCAhPT0gcG9zaXRpb24ueCB8fCB0b3AgIT09IHBvc2l0aW9uLnk7XG4gICAgY29uc3QgZGVmYXVsdFNob3dBcnJvdyA9IChwb3NpdGlvblR5cGUgPT09IFwibm9kZVwiIHx8IHBvc2l0aW9uVHlwZSA9PT0gXCJwb2ludGVyXCIgfHwgcG9zaXRpb25UeXBlID09PSBcInNwYXJrbGluZVwiKSAmJiAhY29uc3RyYWluZWQgJiYgIXhPZmZzZXQgJiYgIXlPZmZzZXQ7XG4gICAgY29uc3Qgc2hvd0Fycm93ID0gbWV0YS5zaG93QXJyb3cgPz8gdGhpcy5zaG93QXJyb3cgPz8gZGVmYXVsdFNob3dBcnJvdztcbiAgICB0aGlzLnVwZGF0ZVNob3dBcnJvdyhzaG93QXJyb3cpO1xuICAgIGlmICh3aWxsRXhpc3RPdXRzaWRlQm91bmRpbmdSZWN0RHVyaW5nVHJhbnNpdGlvbikge1xuICAgICAgZWxlbWVudDIuc3R5bGUudHJhbnNpdGlvbiA9IFwibm9uZVwiO1xuICAgIH1cbiAgICBlbGVtZW50Mi5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7TWF0aC5yb3VuZChsZWZ0KX1weCwgJHtNYXRoLnJvdW5kKHRvcCl9cHgpYDtcbiAgICBpZiAod2lsbEV4aXN0T3V0c2lkZUJvdW5kaW5nUmVjdER1cmluZ1RyYW5zaXRpb24pIHtcbiAgICAgIGVsZW1lbnQyLnN0eWxlLnRyYW5zaXRpb24gPSBcIlwiO1xuICAgIH1cbiAgICBpZiAobWV0YS5lbmFibGVJbnRlcmFjdGlvbikge1xuICAgICAgdGhpcy5lbmFibGVJbnRlcmFjdGlvbiA9IHRydWU7XG4gICAgICBlbGVtZW50Mi5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJhdXRvXCI7XG4gICAgICBzZXRBdHRyaWJ1dGUoZWxlbWVudDIsIFwiYXJpYS1oaWRkZW5cIiwgdm9pZCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbmFibGVJbnRlcmFjdGlvbiA9IGZhbHNlO1xuICAgICAgZWxlbWVudDIuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiO1xuICAgICAgc2V0QXR0cmlidXRlKGVsZW1lbnQyLCBcImFyaWEtaGlkZGVuXCIsIHRydWUpO1xuICAgIH1cbiAgICBpZiAodGhpcy5kZWxheSA+IDAgJiYgIWluc3RhbnRseSkge1xuICAgICAgdGhpcy50b2dnbGUoZmFsc2UpO1xuICAgICAgdGhpcy5zaG93VGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLnRvZ2dsZSh0cnVlKTtcbiAgICAgIH0sIHRoaXMuZGVsYXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRvZ2dsZSh0cnVlKTtcbiAgICB9XG4gIH1cbiAgdG9nZ2xlKHZpc2libGUpIHtcbiAgICBpZiAoIXRoaXMuZWxlbWVudClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IGNsYXNzTGlzdCB9ID0gdGhpcy5lbGVtZW50O1xuICAgIGNvbnN0IHRvZ2dsZUNsYXNzID0gKG5hbWUsIGluY2x1ZGUpID0+IGNsYXNzTGlzdC50b2dnbGUoYCR7REVGQVVMVF9UT09MVElQX0NMQVNTfS0ke25hbWV9YCwgaW5jbHVkZSk7XG4gICAgY29uc3Qgd2FzVmlzaWJsZSA9IHRoaXMuaXNWaXNpYmxlKCk7XG4gICAgbGV0IHRpbWVTaW5jZUxhc3RWaXNpYmlsaXR5Q2hhbmdlTXMgPSBJbmZpbml0eTtcbiAgICBpZiAoIXZpc2libGUpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnNob3dUaW1lb3V0KTtcbiAgICB9XG4gICAgaWYgKHdhc1Zpc2libGUgIT09IHZpc2libGUpIHtcbiAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICB0aW1lU2luY2VMYXN0VmlzaWJpbGl0eUNoYW5nZU1zID0gbm93IC0gdGhpcy5sYXN0VmlzaWJpbGl0eUNoYW5nZTtcbiAgICAgIHRoaXMubGFzdFZpc2liaWxpdHlDaGFuZ2UgPSBub3c7XG4gICAgfVxuICAgIGNvbnN0IGFuaW1hdGVkTW92ZVRocmVzaG9sZE1zID0gMTAwO1xuICAgIGNvbnN0IHRocmFzaGluZ1RocmVzaG9sZE1zID0gNTtcbiAgICBjb25zdCBub0FuaW1hdGlvbiA9ICF3YXNWaXNpYmxlICYmIHZpc2libGUgJiYgdGltZVNpbmNlTGFzdFZpc2liaWxpdHlDaGFuZ2VNcyA+IGFuaW1hdGVkTW92ZVRocmVzaG9sZE1zO1xuICAgIGlmICh0aW1lU2luY2VMYXN0VmlzaWJpbGl0eUNoYW5nZU1zID4gdGhyYXNoaW5nVGhyZXNob2xkTXMpIHtcbiAgICAgIHRvZ2dsZUNsYXNzKFwibm8tYW5pbWF0aW9uXCIsIG5vQW5pbWF0aW9uKTtcbiAgICB9XG4gICAgdG9nZ2xlQ2xhc3MoXCJuby1pbnRlcmFjdGlvblwiLCAhdGhpcy5lbmFibGVJbnRlcmFjdGlvbik7XG4gICAgdG9nZ2xlQ2xhc3MoXCJoaWRkZW5cIiwgIXZpc2libGUpO1xuICAgIHRvZ2dsZUNsYXNzKFwiYXJyb3dcIiwgdGhpcy5fc2hvd0Fycm93KTtcbiAgICBjbGFzc0xpc3QudG9nZ2xlKERFRkFVTFRfVE9PTFRJUF9EQVJLX0NMQVNTLCB0aGlzLmRhcmtUaGVtZSk7XG4gICAgZm9yIChjb25zdCB3cmFwVHlwZSBvZiB0aGlzLndyYXBUeXBlcykge1xuICAgICAgY2xhc3NMaXN0LnRvZ2dsZShgJHtERUZBVUxUX1RPT0xUSVBfQ0xBU1N9LXdyYXAtJHt3cmFwVHlwZX1gLCB3cmFwVHlwZSA9PT0gdGhpcy53cmFwcGluZyk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVNob3dBcnJvdyhzaG93KSB7XG4gICAgdGhpcy5fc2hvd0Fycm93ID0gc2hvdztcbiAgfVxuICBnZXRUb29sdGlwQm91bmRzKG9wdHMpIHtcbiAgICBpZiAoIXRoaXMuZWxlbWVudClcbiAgICAgIHJldHVybiB7fTtcbiAgICBjb25zdCB7IHBvc2l0aW9uVHlwZSwgbWV0YSwgeU9mZnNldCwgeE9mZnNldCwgY2FudmFzUmVjdCB9ID0gb3B0cztcbiAgICBjb25zdCB7IGNsaWVudFdpZHRoOiB0b29sdGlwV2lkdGgsIGNsaWVudEhlaWdodDogdG9vbHRpcEhlaWdodCB9ID0gdGhpcy5lbGVtZW50O1xuICAgIGNvbnN0IGJvdW5kcyA9IHsgd2lkdGg6IHRvb2x0aXBXaWR0aCwgaGVpZ2h0OiB0b29sdGlwSGVpZ2h0IH07XG4gICAgc3dpdGNoIChwb3NpdGlvblR5cGUpIHtcbiAgICAgIGNhc2UgXCJub2RlXCI6XG4gICAgICBjYXNlIFwicG9pbnRlclwiOiB7XG4gICAgICAgIGJvdW5kcy50b3AgPSBtZXRhLm9mZnNldFkgKyB5T2Zmc2V0IC0gdG9vbHRpcEhlaWdodCAtIDg7XG4gICAgICAgIGJvdW5kcy5sZWZ0ID0gbWV0YS5vZmZzZXRYICsgeE9mZnNldCAtIHRvb2x0aXBXaWR0aCAvIDI7XG4gICAgICAgIHJldHVybiBib3VuZHM7XG4gICAgICB9XG4gICAgICBjYXNlIFwidG9wXCI6IHtcbiAgICAgICAgYm91bmRzLnRvcCA9IHlPZmZzZXQ7XG4gICAgICAgIGJvdW5kcy5sZWZ0ID0gY2FudmFzUmVjdC53aWR0aCAvIDIgLSB0b29sdGlwV2lkdGggLyAyICsgeE9mZnNldDtcbiAgICAgICAgcmV0dXJuIGJvdW5kcztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJyaWdodFwiOiB7XG4gICAgICAgIGJvdW5kcy50b3AgPSBjYW52YXNSZWN0LmhlaWdodCAvIDIgLSB0b29sdGlwSGVpZ2h0IC8gMiArIHlPZmZzZXQ7XG4gICAgICAgIGJvdW5kcy5sZWZ0ID0gY2FudmFzUmVjdC53aWR0aCAtIHRvb2x0aXBXaWR0aCAvIDIgKyB4T2Zmc2V0O1xuICAgICAgICByZXR1cm4gYm91bmRzO1xuICAgICAgfVxuICAgICAgY2FzZSBcImxlZnRcIjoge1xuICAgICAgICBib3VuZHMudG9wID0gY2FudmFzUmVjdC5oZWlnaHQgLyAyIC0gdG9vbHRpcEhlaWdodCAvIDIgKyB5T2Zmc2V0O1xuICAgICAgICBib3VuZHMubGVmdCA9IHhPZmZzZXQ7XG4gICAgICAgIHJldHVybiBib3VuZHM7XG4gICAgICB9XG4gICAgICBjYXNlIFwiYm90dG9tXCI6IHtcbiAgICAgICAgYm91bmRzLnRvcCA9IGNhbnZhc1JlY3QuaGVpZ2h0IC0gdG9vbHRpcEhlaWdodCArIHlPZmZzZXQ7XG4gICAgICAgIGJvdW5kcy5sZWZ0ID0gY2FudmFzUmVjdC53aWR0aCAvIDIgLSB0b29sdGlwV2lkdGggLyAyICsgeE9mZnNldDtcbiAgICAgICAgcmV0dXJuIGJvdW5kcztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJ0b3AtbGVmdFwiOiB7XG4gICAgICAgIGJvdW5kcy50b3AgPSB5T2Zmc2V0O1xuICAgICAgICBib3VuZHMubGVmdCA9IHhPZmZzZXQ7XG4gICAgICAgIHJldHVybiBib3VuZHM7XG4gICAgICB9XG4gICAgICBjYXNlIFwidG9wLXJpZ2h0XCI6IHtcbiAgICAgICAgYm91bmRzLnRvcCA9IHlPZmZzZXQ7XG4gICAgICAgIGJvdW5kcy5sZWZ0ID0gY2FudmFzUmVjdC53aWR0aCAtIHRvb2x0aXBXaWR0aCArIHhPZmZzZXQ7XG4gICAgICAgIHJldHVybiBib3VuZHM7XG4gICAgICB9XG4gICAgICBjYXNlIFwiYm90dG9tLXJpZ2h0XCI6IHtcbiAgICAgICAgYm91bmRzLnRvcCA9IGNhbnZhc1JlY3QuaGVpZ2h0IC0gdG9vbHRpcEhlaWdodCArIHlPZmZzZXQ7XG4gICAgICAgIGJvdW5kcy5sZWZ0ID0gY2FudmFzUmVjdC53aWR0aCAtIHRvb2x0aXBXaWR0aCArIHhPZmZzZXQ7XG4gICAgICAgIHJldHVybiBib3VuZHM7XG4gICAgICB9XG4gICAgICBjYXNlIFwiYm90dG9tLWxlZnRcIjoge1xuICAgICAgICBib3VuZHMudG9wID0gY2FudmFzUmVjdC5oZWlnaHQgLSB0b29sdGlwSGVpZ2h0ICsgeU9mZnNldDtcbiAgICAgICAgYm91bmRzLmxlZnQgPSB4T2Zmc2V0O1xuICAgICAgICByZXR1cm4gYm91bmRzO1xuICAgICAgfVxuICAgICAgY2FzZSBcInNwYXJrbGluZVwiOiB7XG4gICAgICAgIGlmIChlbnRlcnByaXNlTW9kdWxlLmlzRW50ZXJwcmlzZSkge1xuICAgICAgICAgIGJvdW5kcy50b3AgPSB5T2Zmc2V0IC0gdG9vbHRpcEhlaWdodCAtIDg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYm91bmRzLnRvcCA9IG1ldGEub2Zmc2V0WSArIHlPZmZzZXQgLSB0b29sdGlwSGVpZ2h0IC0gODtcbiAgICAgICAgfVxuICAgICAgICBib3VuZHMubGVmdCA9IG1ldGEub2Zmc2V0WCArIHhPZmZzZXQgLSB0b29sdGlwV2lkdGggLyAyO1xuICAgICAgICByZXR1cm4gYm91bmRzO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBUb29sdGlwLnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgVG9vbHRpcC5wcm90b3R5cGUsIFwic2hvd0Fycm93XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgT2JzZXJ2ZUNoYW5nZXMoKHRhcmdldCwgbmV3VmFsdWUsIG9sZFZhbHVlKSA9PiB7XG4gICAgaWYgKG5ld1ZhbHVlKSB7XG4gICAgICB0YXJnZXQuZWxlbWVudD8uY2xhc3NMaXN0LmFkZChuZXdWYWx1ZSk7XG4gICAgfVxuICAgIGlmIChvbGRWYWx1ZSkge1xuICAgICAgdGFyZ2V0LmVsZW1lbnQ/LmNsYXNzTGlzdC5yZW1vdmUob2xkVmFsdWUpO1xuICAgIH1cbiAgfSksXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgVG9vbHRpcC5wcm90b3R5cGUsIFwiY2xhc3NcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBUb29sdGlwLnByb3RvdHlwZSwgXCJkZWxheVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKElOVEVSQUNUSU9OX1JBTkdFLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBUb29sdGlwLnByb3RvdHlwZSwgXCJyYW5nZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFRFWFRfV1JBUClcbl0sIFRvb2x0aXAucHJvdG90eXBlLCBcIndyYXBwaW5nXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgVG9vbHRpcC5wcm90b3R5cGUsIFwicG9zaXRpb25cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgVG9vbHRpcC5wcm90b3R5cGUsIFwiZGFya1RoZW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoVU5JT04oW1wiZXh0ZW5kZWRcIiwgXCJjYW52YXNcIl0pKVxuXSwgVG9vbHRpcC5wcm90b3R5cGUsIFwiYm91bmRzXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9jYXB0aW9uLnRzXG52YXIgQ2FwdGlvbiA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuaWQgPSBjcmVhdGVJZCh0aGlzKTtcbiAgICB0aGlzLm5vZGUgPSBuZXcgUm90YXRhYmxlVGV4dCh7IHpJbmRleDogMSB9KS5zZXRQcm9wZXJ0aWVzKHtcbiAgICAgIHRleHRBbGlnbjogXCJjZW50ZXJcIixcbiAgICAgIHBvaW50ZXJFdmVudHM6IDEgLyogTm9uZSAqL1xuICAgIH0pO1xuICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICB0aGlzLmZvbnRTaXplID0gMTA7XG4gICAgdGhpcy5mb250RmFtaWx5ID0gXCJzYW5zLXNlcmlmXCI7XG4gICAgdGhpcy53cmFwcGluZyA9IFwiYWx3YXlzXCI7XG4gICAgdGhpcy5wYWRkaW5nID0gMDtcbiAgICB0aGlzLmxheW91dFN0eWxlID0gXCJibG9ja1wiO1xuICAgIHRoaXMudHJ1bmNhdGVkID0gZmFsc2U7XG4gIH1cbiAgcmVnaXN0ZXJJbnRlcmFjdGlvbihtb2R1bGVDdHgsIHdoZXJlKSB7XG4gICAgY29uc3QgeyByZWdpb25NYW5hZ2VyLCBwcm94eUludGVyYWN0aW9uU2VydmljZSwgbGF5b3V0TWFuYWdlciB9ID0gbW9kdWxlQ3R4O1xuICAgIGNvbnN0IHJlZ2lvbiA9IHJlZ2lvbk1hbmFnZXIuZ2V0UmVnaW9uKFwicm9vdFwiKTtcbiAgICBjb25zdCBkZXN0cm95Rm5zID0gW1xuICAgICAgbGF5b3V0TWFuYWdlci5hZGRMaXN0ZW5lcihcImxheW91dDpjb21wbGV0ZVwiLCAoKSA9PiB0aGlzLnVwZGF0ZUExMXlUZXh0KHByb3h5SW50ZXJhY3Rpb25TZXJ2aWNlLCB3aGVyZSkpLFxuICAgICAgcmVnaW9uLmFkZExpc3RlbmVyKFwiaG92ZXJcIiwgKGV2ZW50KSA9PiB0aGlzLmhhbmRsZU1vdXNlTW92ZShtb2R1bGVDdHgsIGV2ZW50KSksXG4gICAgICByZWdpb24uYWRkTGlzdGVuZXIoXCJsZWF2ZVwiLCAoZXZlbnQpID0+IHRoaXMuaGFuZGxlTW91c2VMZWF2ZShtb2R1bGVDdHgsIGV2ZW50KSlcbiAgICBdO1xuICAgIHJldHVybiBqb2luRnVuY3Rpb25zKC4uLmRlc3Ryb3lGbnMpO1xuICB9XG4gIGNvbXB1dGVUZXh0V3JhcChjb250YWluZXJXaWR0aCwgY29udGFpbmVySGVpZ2h0KSB7XG4gICAgY29uc3QgeyB0ZXh0LCBwYWRkaW5nLCB3cmFwcGluZyB9ID0gdGhpcztcbiAgICBjb25zdCBtYXhXaWR0aCA9IE1hdGgubWluKHRoaXMubWF4V2lkdGggPz8gSW5maW5pdHksIGNvbnRhaW5lcldpZHRoKSAtIHBhZGRpbmcgKiAyO1xuICAgIGNvbnN0IG1heEhlaWdodCA9IHRoaXMubWF4SGVpZ2h0ID8/IGNvbnRhaW5lckhlaWdodCAtIHBhZGRpbmcgKiAyO1xuICAgIGlmICghaXNGaW5pdGUobWF4V2lkdGgpICYmICFpc0Zpbml0ZShtYXhIZWlnaHQpKSB7XG4gICAgICB0aGlzLm5vZGUudGV4dCA9IHRleHQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHdyYXBwZWRUZXh0ID0gVGV4dFdyYXBwZXIud3JhcFRleHQodGV4dCA/PyBcIlwiLCB7IG1heFdpZHRoLCBtYXhIZWlnaHQsIGZvbnQ6IHRoaXMsIHRleHRXcmFwOiB3cmFwcGluZyB9KTtcbiAgICB0aGlzLm5vZGUudGV4dCA9IHdyYXBwZWRUZXh0O1xuICAgIHRoaXMudHJ1bmNhdGVkID0gd3JhcHBlZFRleHQuaW5jbHVkZXMoVGV4dFV0aWxzLkVsbGlwc2lzQ2hhcik7XG4gIH1cbiAgdXBkYXRlQTExeVRleHQocHJveHlTZXJ2aWNlLCB3aGVyZSkge1xuICAgIGlmICh0aGlzLmVuYWJsZWQgJiYgdGhpcy50ZXh0KSB7XG4gICAgICBjb25zdCBiYm94ID0gVHJhbnNmb3JtYWJsZS50b0NhbnZhcyh0aGlzLm5vZGUpO1xuICAgICAgaWYgKGJib3gpIHtcbiAgICAgICAgY29uc3QgeyBpZCB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5wcm94eVRleHQgPz8gKHRoaXMucHJveHlUZXh0ID0gcHJveHlTZXJ2aWNlLmNyZWF0ZVByb3h5RWxlbWVudCh7IHR5cGU6IFwidGV4dFwiLCBpZCwgcGFyZW50OiB3aGVyZSB9KSk7XG4gICAgICAgIHRoaXMucHJveHlUZXh0LnRleHRDb250ZW50ID0gdGhpcy50ZXh0O1xuICAgICAgICB0aGlzLnByb3h5VGV4dC51cGRhdGVCb3VuZHMoYmJveCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHJveHlUZXh0Py5yZW1vdmUoKTtcbiAgICAgIHRoaXMucHJveHlUZXh0ID0gdm9pZCAwO1xuICAgIH1cbiAgfVxuICBoYW5kbGVNb3VzZU1vdmUobW9kdWxlQ3R4LCBldmVudCkge1xuICAgIGlmIChldmVudCAhPT0gdm9pZCAwICYmIHRoaXMuZW5hYmxlZCAmJiB0aGlzLm5vZGUudmlzaWJsZSAmJiB0aGlzLnRydW5jYXRlZCkge1xuICAgICAgY29uc3QgeyBvZmZzZXRYLCBvZmZzZXRZIH0gPSBldmVudDtcbiAgICAgIG1vZHVsZUN0eC50b29sdGlwTWFuYWdlci51cGRhdGVUb29sdGlwKFxuICAgICAgICB0aGlzLmlkLFxuICAgICAgICB7IG9mZnNldFgsIG9mZnNldFksIGxhc3RQb2ludGVyRXZlbnQ6IGV2ZW50LCBzaG93QXJyb3c6IGZhbHNlIH0sXG4gICAgICAgIHRvVG9vbHRpcEh0bWwoeyBjb250ZW50OiB0aGlzLnRleHQgfSlcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGhhbmRsZU1vdXNlTGVhdmUobW9kdWxlQ3R4LCBfZXZlbnQpIHtcbiAgICBtb2R1bGVDdHgudG9vbHRpcE1hbmFnZXIucmVtb3ZlVG9vbHRpcCh0aGlzLmlkKTtcbiAgfVxufTtcbkNhcHRpb24uU01BTExfUEFERElORyA9IDEwO1xuQ2FwdGlvbi5MQVJHRV9QQURESU5HID0gMjA7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKSxcbiAgUHJveHlQcm9wZXJ0eU9uV3JpdGUoXCJub2RlXCIsIFwidmlzaWJsZVwiKVxuXSwgQ2FwdGlvbi5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KSxcbiAgUHJveHlQcm9wZXJ0eU9uV3JpdGUoXCJub2RlXCIpXG5dLCBDYXB0aW9uLnByb3RvdHlwZSwgXCJ0ZXh0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoVEVYVF9BTElHTiwgeyBvcHRpb25hbDogdHJ1ZSB9KSxcbiAgUHJveHlQcm9wZXJ0eU9uV3JpdGUoXCJub2RlXCIpXG5dLCBDYXB0aW9uLnByb3RvdHlwZSwgXCJ0ZXh0QWxpZ25cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGT05UX1NUWUxFLCB7IG9wdGlvbmFsOiB0cnVlIH0pLFxuICBQcm94eVByb3BlcnR5T25Xcml0ZShcIm5vZGVcIilcbl0sIENhcHRpb24ucHJvdG90eXBlLCBcImZvbnRTdHlsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZPTlRfV0VJR0hULCB7IG9wdGlvbmFsOiB0cnVlIH0pLFxuICBQcm94eVByb3BlcnR5T25Xcml0ZShcIm5vZGVcIilcbl0sIENhcHRpb24ucHJvdG90eXBlLCBcImZvbnRXZWlnaHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpLFxuICBQcm94eVByb3BlcnR5T25Xcml0ZShcIm5vZGVcIilcbl0sIENhcHRpb24ucHJvdG90eXBlLCBcImZvbnRTaXplXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HKSxcbiAgUHJveHlQcm9wZXJ0eU9uV3JpdGUoXCJub2RlXCIpXG5dLCBDYXB0aW9uLnByb3RvdHlwZSwgXCJmb250RmFtaWx5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pLFxuICBQcm94eVByb3BlcnR5T25Xcml0ZShcIm5vZGVcIiwgXCJmaWxsXCIpXG5dLCBDYXB0aW9uLnByb3RvdHlwZSwgXCJjb2xvclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQ2FwdGlvbi5wcm90b3R5cGUsIFwic3BhY2luZ1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQ2FwdGlvbi5wcm90b3R5cGUsIFwibWF4V2lkdGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIENhcHRpb24ucHJvdG90eXBlLCBcIm1heEhlaWdodFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFRFWFRfV1JBUClcbl0sIENhcHRpb24ucHJvdG90eXBlLCBcIndyYXBwaW5nXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgQ2FwdGlvbi5wcm90b3R5cGUsIFwicGFkZGluZ1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORylcbl0sIENhcHRpb24ucHJvdG90eXBlLCBcImxheW91dFN0eWxlXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9sYXllci50c1xudmFyIF9MYXllciA9IGNsYXNzIF9MYXllciBleHRlbmRzIEdyb3VwIHtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHN1cGVyKG9wdHMpO1xuICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgdGhpcy5sYXN0QkJveCA9IHZvaWQgMDtcbiAgfVxuICBzdGF0aWMgaXModmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBfTGF5ZXI7XG4gIH1cbiAgbWFya0RpcnR5KHR5cGUgPSAxIC8qIFRSSVZJQUwgKi8pIHtcbiAgICBzdXBlci5tYXJrRGlydHkodHlwZSwgMSAvKiBUUklWSUFMICovKTtcbiAgfVxuICBwcmVSZW5kZXIoKSB7XG4gICAgY29uc3QgY291bnRzID0gc3VwZXIucHJlUmVuZGVyKCk7XG4gICAgaWYgKGNvdW50cy5ub25Hcm91cHMgPiAwKSB7XG4gICAgICB0aGlzLmxheWVyID8/ICh0aGlzLmxheWVyID0gdGhpcy5fbGF5ZXJNYW5hZ2VyPy5hZGRMYXllcih7XG4gICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgekluZGV4OiB0aGlzLnpJbmRleCxcbiAgICAgICAgekluZGV4U3ViT3JkZXI6IHRoaXMuekluZGV4U3ViT3JkZXIsXG4gICAgICAgIGdldENvbXB1dGVkT3BhY2l0eTogKCkgPT4gdGhpcy5nZXRDb21wdXRlZE9wYWNpdHkoKSxcbiAgICAgICAgZ2V0VmlzaWJpbGl0eTogKCkgPT4gdGhpcy5nZXRWaXNpYmlsaXR5KClcbiAgICAgIH0pKTtcbiAgICAgIGlmICh0aGlzLm9wdHM/LmRlcml2ZVpJbmRleEZyb21DaGlsZHJlbikge1xuICAgICAgICB0aGlzLmRlcml2ZVpJbmRleEZyb21DaGlsZHJlbigpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY291bnRzO1xuICB9XG4gIGRlYnVnU2tpcChyZW5kZXJDdHgpIHtcbiAgICBzdXBlci5kZWJ1Z1NraXAocmVuZGVyQ3R4KTtcbiAgICBjb25zdCB7IHN0YXRzIH0gPSByZW5kZXJDdHg7XG4gICAgaWYgKHN0YXRzKSB7XG4gICAgICBzdGF0cy5sYXllcnNTa2lwcGVkKys7XG4gICAgICBzdGF0cy5ub2Rlc1NraXBwZWQgKz0gbm9kZUNvdW50KHRoaXMpLmNvdW50O1xuICAgIH1cbiAgfVxuICByZW5kZXIocmVuZGVyQ3R4KSB7XG4gICAgaWYgKCF0aGlzLmxheWVyKSB7XG4gICAgICByZXR1cm4gc3VwZXIucmVuZGVyKHJlbmRlckN0eCk7XG4gICAgfVxuICAgIGNvbnN0IHsgb3B0czogeyBuYW1lIH0gPSB7fSwgX2RlYnVnOiBkZWJ1ZzMsIGNsaXBSZWN0IH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgaXNEaXJ0eSwgaXNDaGlsZERpcnR5LCBpc0NoaWxkTGF5ZXJEaXJ0eSB9ID0gdGhpcy5pc0RpcnR5KHJlbmRlckN0eCk7XG4gICAgY29uc3QgeyBzdGF0cyB9ID0gcmVuZGVyQ3R4O1xuICAgIGxldCB7IGZvcmNlUmVuZGVyLCBjbGlwQkJveCB9ID0gcmVuZGVyQ3R4O1xuICAgIGNvbnN0IGN1cnJlbnRCQm94ID0gdGhpcy5nZXRCQm94KCk7XG4gICAgaWYgKCF0aGlzLmxhc3RCQm94Py5lcXVhbHMoY3VycmVudEJCb3gpKSB7XG4gICAgICBmb3JjZVJlbmRlciA9IFwiZGlydHlUcmFuc2Zvcm1cIjtcbiAgICAgIHRoaXMubGFzdEJCb3ggPSBjdXJyZW50QkJveDtcbiAgICB9XG4gICAgaWYgKCFpc0RpcnR5ICYmICFpc0NoaWxkRGlydHkgJiYgIWlzQ2hpbGRMYXllckRpcnR5ICYmICFmb3JjZVJlbmRlcikge1xuICAgICAgdGhpcy5kZWJ1Z1NraXAocmVuZGVyQ3R4KTtcbiAgICAgIHRoaXMubWFya0NsZWFuKHsgcmVjdXJzaXZlOiBmYWxzZSB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGZvcmNlUmVuZGVyICE9PSBcImRpcnR5VHJhbnNmb3JtXCIpIHtcbiAgICAgIGZvcmNlUmVuZGVyID0gaXNDaGlsZERpcnR5IHx8IHRoaXMuZGlydHlaSW5kZXg7XG4gICAgfVxuICAgIGlmIChmb3JjZVJlbmRlcikge1xuICAgICAgdGhpcy5sYXllci5jbGVhcigpO1xuICAgIH1cbiAgICBpZiAodGhpcy5kaXJ0eVpJbmRleCkge1xuICAgICAgdGhpcy5zb3J0Q2hpbGRyZW4oR3JvdXAuY29tcGFyZUNoaWxkcmVuKTtcbiAgICB9XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLnNvcnRlZENoaWxkcmVuKCk7XG4gICAgY29uc3QgcmVuZGVyQ3R4VHJhbnNmb3JtID0gcmVuZGVyQ3R4LmN0eC5nZXRUcmFuc2Zvcm0oKTtcbiAgICBjb25zdCB7IGNvbnRleHQ6IGN0eCB9ID0gdGhpcy5sYXllcjtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGlmIChjbGlwQkJveCkge1xuICAgICAgY29uc3QgeyB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIsIHgsIHkgfSA9IGNsaXBCQm94O1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4LnJlY3QoeCwgeSwgd2lkdGgyLCBoZWlnaHQyKTtcbiAgICAgIGN0eC5jbGlwKCk7XG4gICAgICBkZWJ1ZzM/LigoKSA9PiAoeyBuYW1lLCBjbGlwQkJveCwgcmVuZGVyQ3R4LCBncm91cDogdGhpcywgY3R4VHJhbnNmb3JtOiBjdHguZ2V0VHJhbnNmb3JtKCkgfSkpO1xuICAgIH1cbiAgICBjdHguc2V0VHJhbnNmb3JtKHJlbmRlckN0eFRyYW5zZm9ybSk7XG4gICAgaWYgKHRoaXMuY2xpcFJlY3QpIHtcbiAgICAgIGNsaXBCQm94ID0gdGhpcy5yZW5kZXJDbGlwKHsgLi4ucmVuZGVyQ3R4LCBjdHggfSk7XG4gICAgfVxuICAgIHRoaXMucmVuZGVyQ2hpbGRyZW4oY2hpbGRyZW4sIHsgLi4ucmVuZGVyQ3R4LCBjdHgsIGZvcmNlUmVuZGVyLCBjbGlwQkJveCB9KTtcbiAgICBzdXBlci5yZW5kZXIocmVuZGVyQ3R4LCB0cnVlKTtcbiAgICBpZiAoY2xpcFJlY3QpIHtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy52aXJ0dWFsQ2hpbGRyZW4oKSkge1xuICAgICAgY2hpbGQubWFya0NsZWFuKHsgcmVjdXJzaXZlOiBcInZpcnR1YWxcIiB9KTtcbiAgICB9XG4gICAgaWYgKHN0YXRzKVxuICAgICAgc3RhdHMubGF5ZXJzUmVuZGVyZWQrKztcbiAgICBjdHgucmVzdG9yZSgpO1xuICAgIGN0eC52ZXJpZnlEZXB0aFplcm8/LigpO1xuICAgIGlmIChuYW1lICYmIHN0YXRzKSB7XG4gICAgICBkZWJ1ZzM/Lih7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIHJlbmRlckN0eCxcbiAgICAgICAgcmVzdWx0OiBcInJlbmRlcmVkXCIsXG4gICAgICAgIHNraXBwZWQ6IHN0YXRzLm5vZGVzU2tpcHBlZCxcbiAgICAgICAgY291bnRzOiBub2RlQ291bnQodGhpcyksXG4gICAgICAgIGdyb3VwOiB0aGlzXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZGVyaXZlWkluZGV4RnJvbUNoaWxkcmVuKCkge1xuICAgIGxldCBsYXN0Q2hpbGQ7XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKCkpIHtcbiAgICAgIGlmICghY2hpbGQuY2hpbGROb2RlQ291bnRzLm5vbkdyb3VwcylcbiAgICAgICAgY29udGludWU7XG4gICAgICBpZiAoIWxhc3RDaGlsZCB8fCBHcm91cC5jb21wYXJlQ2hpbGRyZW4obGFzdENoaWxkLCBjaGlsZCkgPCAwKSB7XG4gICAgICAgIGxhc3RDaGlsZCA9IGNoaWxkO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnpJbmRleCA9IGxhc3RDaGlsZD8uekluZGV4ID8/IC1JbmZpbml0eTtcbiAgICB0aGlzLnpJbmRleFN1Yk9yZGVyID0gbGFzdENoaWxkPy56SW5kZXhTdWJPcmRlcjtcbiAgfVxuICBfc2V0TGF5ZXJNYW5hZ2VyKGxheWVyc01hbmFnZXIpIHtcbiAgICBpZiAodGhpcy5sYXllcikge1xuICAgICAgdGhpcy5fbGF5ZXJNYW5hZ2VyPy5yZW1vdmVMYXllcih0aGlzLmxheWVyKTtcbiAgICAgIHRoaXMubGF5ZXIgPSB2b2lkIDA7XG4gICAgfVxuICAgIHN1cGVyLl9zZXRMYXllck1hbmFnZXIobGF5ZXJzTWFuYWdlcik7XG4gIH1cbiAgZ2V0Q29tcHV0ZWRPcGFjaXR5KCkge1xuICAgIGxldCBvcGFjaXR5ID0gMTtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgdGhpcy50cmF2ZXJzZVVwKHRydWUpKSB7XG4gICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgIG9wYWNpdHkgKj0gbm9kZS5vcGFjaXR5O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3BhY2l0eTtcbiAgfVxuICBnZXRWaXNpYmlsaXR5KCkge1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiB0aGlzLnRyYXZlcnNlVXAodHJ1ZSkpIHtcbiAgICAgIGlmICghbm9kZS52aXNpYmxlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgb25WaXNpYmxlQ2hhbmdlKCkge1xuICAgIGlmICh0aGlzLmxheWVyKSB7XG4gICAgICB0aGlzLmxheWVyLmVuYWJsZWQgPSB0aGlzLnZpc2libGU7XG4gICAgfVxuICB9XG4gIG9uWkluZGV4Q2hhbmdlKCkge1xuICAgIHN1cGVyLm9uWkluZGV4Q2hhbmdlKCk7XG4gICAgaWYgKHRoaXMubGF5ZXIpIHtcbiAgICAgIHRoaXMuX2xheWVyTWFuYWdlcj8ubW92ZUxheWVyKHRoaXMubGF5ZXIsIHRoaXMuekluZGV4LCB0aGlzLnpJbmRleFN1Yk9yZGVyKTtcbiAgICB9XG4gIH1cbn07XG5fTGF5ZXIuY2xhc3NOYW1lID0gXCJMYXllclwiO1xudmFyIExheWVyID0gX0xheWVyO1xudmFyIFRyYW5zbGF0YWJsZUxheWVyID0gY2xhc3MgZXh0ZW5kcyBUcmFuc2xhdGFibGUoTGF5ZXIpIHtcbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL3NoYXBlL3JhbmdlLnRzXG52YXIgUmFuZ2UgPSBjbGFzcyBleHRlbmRzIFNoYXBlIHtcbiAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgc3VwZXIob3B0cyk7XG4gICAgdGhpcy54MSA9IDA7XG4gICAgdGhpcy55MSA9IDA7XG4gICAgdGhpcy54MiA9IDA7XG4gICAgdGhpcy55MiA9IDA7XG4gICAgdGhpcy5zdGFydExpbmUgPSBmYWxzZTtcbiAgICB0aGlzLmVuZExpbmUgPSBmYWxzZTtcbiAgICB0aGlzLmlzUmFuZ2UgPSBmYWxzZTtcbiAgICB0aGlzLnJlc3RvcmVPd25TdHlsZXMoKTtcbiAgfVxuICBjb21wdXRlQkJveCgpIHtcbiAgICByZXR1cm4gbmV3IEJCb3godGhpcy54MSwgdGhpcy55MSwgdGhpcy54MiAtIHRoaXMueDEsIHRoaXMueTIgLSB0aGlzLnkxKTtcbiAgfVxuICBpc1BvaW50SW5QYXRoKF94LCBfeSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZW5kZXIocmVuZGVyQ3R4KSB7XG4gICAgY29uc3QgeyBjdHgsIGZvcmNlUmVuZGVyLCBzdGF0cyB9ID0gcmVuZGVyQ3R4O1xuICAgIGlmICh0aGlzLmRpcnR5ID09PSAwIC8qIE5PTkUgKi8gJiYgIWZvcmNlUmVuZGVyKSB7XG4gICAgICBpZiAoc3RhdHMpXG4gICAgICAgIHN0YXRzLm5vZGVzU2tpcHBlZCArPSBub2RlQ291bnQodGhpcykuY291bnQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCB7IHgxLCB5MSwgeDIsIHkyIH0gPSB0aGlzO1xuICAgIHgxID0gdGhpcy5hbGlnbih4MSk7XG4gICAgeTEgPSB0aGlzLmFsaWduKHkxKTtcbiAgICB4MiA9IHRoaXMuYWxpZ24oeDIpO1xuICAgIHkyID0gdGhpcy5hbGlnbih5Mik7XG4gICAgY29uc3QgeyBmaWxsLCBvcGFjaXR5LCBpc1JhbmdlIH0gPSB0aGlzO1xuICAgIGNvbnN0IGZpbGxBY3RpdmUgPSAhIShpc1JhbmdlICYmIGZpbGwpO1xuICAgIGlmIChmaWxsQWN0aXZlKSB7XG4gICAgICBjb25zdCB7IGZpbGxPcGFjaXR5IH0gPSB0aGlzO1xuICAgICAgdGhpcy5hcHBseUZpbGwoY3R4KTtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IG9wYWNpdHkgKiBmaWxsT3BhY2l0eTtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8oeDEsIHkxKTtcbiAgICAgIGN0eC5saW5lVG8oeDIsIHkxKTtcbiAgICAgIGN0eC5saW5lVG8oeDIsIHkyKTtcbiAgICAgIGN0eC5saW5lVG8oeDEsIHkyKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgfVxuICAgIGNvbnN0IHsgc3Ryb2tlLCBzdHJva2VXaWR0aCwgc3RhcnRMaW5lLCBlbmRMaW5lIH0gPSB0aGlzO1xuICAgIGNvbnN0IHN0cm9rZUFjdGl2ZSA9ICEhKChzdGFydExpbmUgfHwgZW5kTGluZSkgJiYgc3Ryb2tlICYmIHN0cm9rZVdpZHRoKTtcbiAgICBpZiAoc3Ryb2tlQWN0aXZlKSB7XG4gICAgICBjb25zdCB7IHN0cm9rZU9wYWNpdHksIGxpbmVEYXNoLCBsaW5lRGFzaE9mZnNldCwgbGluZUNhcCwgbGluZUpvaW4gfSA9IHRoaXM7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2U7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgPSBvcGFjaXR5ICogc3Ryb2tlT3BhY2l0eTtcbiAgICAgIGN0eC5saW5lV2lkdGggPSBzdHJva2VXaWR0aDtcbiAgICAgIGlmIChsaW5lRGFzaCkge1xuICAgICAgICBjdHguc2V0TGluZURhc2gobGluZURhc2gpO1xuICAgICAgfVxuICAgICAgaWYgKGxpbmVEYXNoT2Zmc2V0KSB7XG4gICAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IGxpbmVEYXNoT2Zmc2V0O1xuICAgICAgfVxuICAgICAgaWYgKGxpbmVDYXApIHtcbiAgICAgICAgY3R4LmxpbmVDYXAgPSBsaW5lQ2FwO1xuICAgICAgfVxuICAgICAgaWYgKGxpbmVKb2luKSB7XG4gICAgICAgIGN0eC5saW5lSm9pbiA9IGxpbmVKb2luO1xuICAgICAgfVxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgaWYgKHN0YXJ0TGluZSkge1xuICAgICAgICBjdHgubW92ZVRvKHgxLCB5MSk7XG4gICAgICAgIGN0eC5saW5lVG8oeDIsIHkxKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmRMaW5lKSB7XG4gICAgICAgIGN0eC5tb3ZlVG8oeDIsIHkyKTtcbiAgICAgICAgY3R4LmxpbmVUbyh4MSwgeTIpO1xuICAgICAgfVxuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH1cbiAgICB0aGlzLmZpbGxTaGFkb3c/Lm1hcmtDbGVhbigpO1xuICAgIHN1cGVyLnJlbmRlcihyZW5kZXJDdHgpO1xuICB9XG59O1xuUmFuZ2UuY2xhc3NOYW1lID0gXCJSYW5nZVwiO1xuUmFuZ2UuZGVmYXVsdFN0eWxlcyA9IHtcbiAgLi4uU2hhcGUuZGVmYXVsdFN0eWxlcyxcbiAgc3Ryb2tlV2lkdGg6IDFcbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMiAvKiBNSU5PUiAqLyB9KVxuXSwgUmFuZ2UucHJvdG90eXBlLCBcIngxXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDIgLyogTUlOT1IgKi8gfSlcbl0sIFJhbmdlLnByb3RvdHlwZSwgXCJ5MVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAyIC8qIE1JTk9SICovIH0pXG5dLCBSYW5nZS5wcm90b3R5cGUsIFwieDJcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMiAvKiBNSU5PUiAqLyB9KVxuXSwgUmFuZ2UucHJvdG90eXBlLCBcInkyXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDIgLyogTUlOT1IgKi8gfSlcbl0sIFJhbmdlLnByb3RvdHlwZSwgXCJzdGFydExpbmVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMiAvKiBNSU5PUiAqLyB9KVxuXSwgUmFuZ2UucHJvdG90eXBlLCBcImVuZExpbmVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMiAvKiBNSU5PUiAqLyB9KVxuXSwgUmFuZ2UucHJvdG90eXBlLCBcImlzUmFuZ2VcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2xhYmVsLnRzXG52YXIgTGFiZWwgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMuZm9udFNpemUgPSAxMjtcbiAgICB0aGlzLmZvbnRGYW1pbHkgPSBcIlZlcmRhbmEsIHNhbnMtc2VyaWZcIjtcbiAgfVxuICBnZXRGb250KCkge1xuICAgIHJldHVybiBUZXh0VXRpbHMudG9Gb250U3RyaW5nKHRoaXMpO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIExhYmVsLnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBMYWJlbC5wcm90b3R5cGUsIFwiY29sb3JcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGT05UX1NUWUxFLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBMYWJlbC5wcm90b3R5cGUsIFwiZm9udFN0eWxlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoRk9OVF9XRUlHSFQsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIExhYmVsLnByb3RvdHlwZSwgXCJmb250V2VpZ2h0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgTGFiZWwucHJvdG90eXBlLCBcImZvbnRTaXplXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HKVxuXSwgTGFiZWwucHJvdG90eXBlLCBcImZvbnRGYW1pbHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGVU5DVElPTiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGFiZWwucHJvdG90eXBlLCBcImZvcm1hdHRlclwiLCAyKTtcbmZ1bmN0aW9uIGNhbGN1bGF0ZUxhYmVsUm90YXRpb24ob3B0cykge1xuICBjb25zdCB7IHBhcmFsbGVsRmxpcFJvdGF0aW9uID0gMCwgcmVndWxhckZsaXBSb3RhdGlvbiA9IDAgfSA9IG9wdHM7XG4gIGNvbnN0IGNvbmZpZ3VyZWRSb3RhdGlvbiA9IG9wdHMucm90YXRpb24gPyBub3JtYWxpemVBbmdsZTM2MCh0b1JhZGlhbnMob3B0cy5yb3RhdGlvbikpIDogMDtcbiAgY29uc3QgcGFyYWxsZWxGbGlwRmxhZyA9ICFjb25maWd1cmVkUm90YXRpb24gJiYgcGFyYWxsZWxGbGlwUm90YXRpb24gPj0gMCAmJiBwYXJhbGxlbEZsaXBSb3RhdGlvbiA8PSBNYXRoLlBJID8gLTEgOiAxO1xuICBjb25zdCByZWd1bGFyRmxpcEZsYWcgPSAhY29uZmlndXJlZFJvdGF0aW9uICYmIHJlZ3VsYXJGbGlwUm90YXRpb24gPj0gMCAmJiByZWd1bGFyRmxpcFJvdGF0aW9uIDw9IE1hdGguUEkgPyAtMSA6IDE7XG4gIGxldCBkZWZhdWx0Um90YXRpb24gPSAwO1xuICBpZiAob3B0cy5wYXJhbGxlbCkge1xuICAgIGRlZmF1bHRSb3RhdGlvbiA9IHBhcmFsbGVsRmxpcEZsYWcgKiBNYXRoLlBJIC8gMjtcbiAgfSBlbHNlIGlmIChyZWd1bGFyRmxpcEZsYWcgPT09IC0xKSB7XG4gICAgZGVmYXVsdFJvdGF0aW9uID0gTWF0aC5QSTtcbiAgfVxuICByZXR1cm4geyBjb25maWd1cmVkUm90YXRpb24sIGRlZmF1bHRSb3RhdGlvbiwgcGFyYWxsZWxGbGlwRmxhZywgcmVndWxhckZsaXBGbGFnIH07XG59XG5mdW5jdGlvbiBnZXRMYWJlbFNwYWNpbmcobWluU3BhY2luZywgcm90YXRlZCkge1xuICBpZiAoIWlzTmFOKG1pblNwYWNpbmcpKSB7XG4gICAgcmV0dXJuIG1pblNwYWNpbmc7XG4gIH1cbiAgcmV0dXJuIHJvdGF0ZWQgPyAwIDogMTA7XG59XG5mdW5jdGlvbiBnZXRUZXh0QmFzZWxpbmUocGFyYWxsZWwsIGxhYmVsUm90YXRpb24sIHNpZGVGbGFnLCBwYXJhbGxlbEZsaXBGbGFnKSB7XG4gIGlmIChwYXJhbGxlbCAmJiAhbGFiZWxSb3RhdGlvbikge1xuICAgIHJldHVybiBzaWRlRmxhZyAqIHBhcmFsbGVsRmxpcEZsYWcgPT09IC0xID8gXCJoYW5naW5nXCIgOiBcImJvdHRvbVwiO1xuICB9XG4gIHJldHVybiBcIm1pZGRsZVwiO1xufVxuZnVuY3Rpb24gZ2V0VGV4dEFsaWduKHBhcmFsbGVsLCBsYWJlbFJvdGF0aW9uLCBsYWJlbEF1dG9Sb3RhdGlvbiwgc2lkZUZsYWcsIHJlZ3VsYXJGbGlwRmxhZykge1xuICBjb25zdCBsYWJlbFJvdGF0ZWQgPSBsYWJlbFJvdGF0aW9uID4gMCAmJiBsYWJlbFJvdGF0aW9uIDw9IE1hdGguUEk7XG4gIGNvbnN0IGxhYmVsQXV0b1JvdGF0ZWQgPSBsYWJlbEF1dG9Sb3RhdGlvbiA+IDAgJiYgbGFiZWxBdXRvUm90YXRpb24gPD0gTWF0aC5QSTtcbiAgY29uc3QgYWxpZ25GbGFnID0gbGFiZWxSb3RhdGVkIHx8IGxhYmVsQXV0b1JvdGF0ZWQgPyAtMSA6IDE7XG4gIGlmIChwYXJhbGxlbCkge1xuICAgIGlmIChsYWJlbFJvdGF0aW9uIHx8IGxhYmVsQXV0b1JvdGF0aW9uKSB7XG4gICAgICBpZiAoc2lkZUZsYWcgKiBhbGlnbkZsYWcgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBcImVuZFwiO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJjZW50ZXJcIjtcbiAgICB9XG4gIH0gZWxzZSBpZiAoc2lkZUZsYWcgKiByZWd1bGFyRmxpcEZsYWcgPT09IC0xKSB7XG4gICAgcmV0dXJuIFwiZW5kXCI7XG4gIH1cbiAgcmV0dXJuIFwic3RhcnRcIjtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZUxhYmVsQkJveCh0ZXh0LCBiYm94LCBsYWJlbE1hdHJpeCkge1xuICBjb25zdCB7IHg6IGxhYmVsWCwgeTogbGFiZWxZLCB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIgfSA9IGJib3g7XG4gIGNvbnN0IHRyYW5zbGF0ZWRCQm94ID0gbmV3IEJCb3gobGFiZWxYLCBsYWJlbFksIDAsIDApO1xuICBsYWJlbE1hdHJpeC50cmFuc2Zvcm1CQm94KHRyYW5zbGF0ZWRCQm94LCBiYm94KTtcbiAgY29uc3QgeyB4LCB5IH0gPSBiYm94O1xuICByZXR1cm4ge1xuICAgIHBvaW50OiB7IHgsIHkgfSxcbiAgICBsYWJlbDogeyB0ZXh0LCB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIgfVxuICB9O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC96SW5kZXhNYXAudHNcbnZhciBaSW5kZXhNYXAgPSAvKiBAX19QVVJFX18gKi8gKChaSW5kZXhNYXAyKSA9PiB7XG4gIFpJbmRleE1hcDJbWkluZGV4TWFwMltcIlNFUklFU19CQUNLR1JPVU5EXCJdID0gMF0gPSBcIlNFUklFU19CQUNLR1JPVU5EXCI7XG4gIFpJbmRleE1hcDJbWkluZGV4TWFwMltcIkFYSVNfR1JJRFwiXSA9IDFdID0gXCJBWElTX0dSSURcIjtcbiAgWkluZGV4TWFwMltaSW5kZXhNYXAyW1wiQVhJU1wiXSA9IDJdID0gXCJBWElTXCI7XG4gIFpJbmRleE1hcDJbWkluZGV4TWFwMltcIlNFUklFU19DUk9TU0xJTkVfUkFOR0VcIl0gPSAzXSA9IFwiU0VSSUVTX0NST1NTTElORV9SQU5HRVwiO1xuICBaSW5kZXhNYXAyW1pJbmRleE1hcDJbXCJTRVJJRVNfTEFZRVJcIl0gPSA0XSA9IFwiU0VSSUVTX0xBWUVSXCI7XG4gIFpJbmRleE1hcDJbWkluZGV4TWFwMltcIlNFUklFU19ISUdITElHSFRcIl0gPSA1XSA9IFwiU0VSSUVTX0hJR0hMSUdIVFwiO1xuICBaSW5kZXhNYXAyW1pJbmRleE1hcDJbXCJBWElTX0ZPUkVHUk9VTkRcIl0gPSA2XSA9IFwiQVhJU19GT1JFR1JPVU5EXCI7XG4gIFpJbmRleE1hcDJbWkluZGV4TWFwMltcIlNFUklFU19DUk9TU0hBSVJcIl0gPSA3XSA9IFwiU0VSSUVTX0NST1NTSEFJUlwiO1xuICBaSW5kZXhNYXAyW1pJbmRleE1hcDJbXCJDSEFSVF9PVkVSTEFZXCJdID0gOF0gPSBcIkNIQVJUX09WRVJMQVlcIjtcbiAgWkluZGV4TWFwMltaSW5kZXhNYXAyW1wiU0VSSUVTX0NST1NTTElORV9MSU5FXCJdID0gOV0gPSBcIlNFUklFU19DUk9TU0xJTkVfTElORVwiO1xuICBaSW5kZXhNYXAyW1pJbmRleE1hcDJbXCJTRVJJRVNfQU5OT1RBVElPTlwiXSA9IDEwXSA9IFwiU0VSSUVTX0FOTk9UQVRJT05cIjtcbiAgWkluZGV4TWFwMltaSW5kZXhNYXAyW1wiQ0hBUlRfQU5OT1RBVElPTlwiXSA9IDExXSA9IFwiQ0hBUlRfQU5OT1RBVElPTlwiO1xuICBaSW5kZXhNYXAyW1pJbmRleE1hcDJbXCJDSEFSVF9BTk5PVEFUSU9OX0ZPQ1VTRURcIl0gPSAxMl0gPSBcIkNIQVJUX0FOTk9UQVRJT05fRk9DVVNFRFwiO1xuICBaSW5kZXhNYXAyW1pJbmRleE1hcDJbXCJTVEFUVVNfQkFSXCJdID0gMTNdID0gXCJTVEFUVVNfQkFSXCI7XG4gIFpJbmRleE1hcDJbWkluZGV4TWFwMltcIlNFUklFU19MQUJFTFwiXSA9IDE0XSA9IFwiU0VSSUVTX0xBQkVMXCI7XG4gIFpJbmRleE1hcDJbWkluZGV4TWFwMltcIkxFR0VORFwiXSA9IDE1XSA9IFwiTEVHRU5EXCI7XG4gIFpJbmRleE1hcDJbWkluZGV4TWFwMltcIk5BVklHQVRPUlwiXSA9IDE2XSA9IFwiTkFWSUdBVE9SXCI7XG4gIFpJbmRleE1hcDJbWkluZGV4TWFwMltcIkZPUkVHUk9VTkRcIl0gPSAxN10gPSBcIkZPUkVHUk9VTkRcIjtcbiAgcmV0dXJuIFpJbmRleE1hcDI7XG59KShaSW5kZXhNYXAgfHwge30pO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3ZhbHVlLnRzXG5mdW5jdGlvbiBpc1N0cmluZ09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duKHZhbHVlLCBcInRvU3RyaW5nXCIpICYmIGlzU3RyaW5nKHZhbHVlLnRvU3RyaW5nKCkpO1xufVxuZnVuY3Rpb24gaXNOdW1iZXJPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093bih2YWx1ZSwgXCJ2YWx1ZU9mXCIpICYmIGlzRmluaXRlTnVtYmVyKHZhbHVlLnZhbHVlT2YoKSk7XG59XG5mdW5jdGlvbiBpc0NvbnRpbnVvdXModmFsdWUpIHtcbiAgcmV0dXJuIGlzRmluaXRlTnVtYmVyKHZhbHVlKSB8fCBpc1ZhbGlkRGF0ZSh2YWx1ZSkgfHwgaXNOdW1iZXJPYmplY3QodmFsdWUpO1xufVxuZnVuY3Rpb24gY2hlY2tEYXR1bSh2YWx1ZSwgaXNDb250aW51b3VzU2NhbGUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKCFpc0NvbnRpbnVvdXNTY2FsZSB8fCBpc0NvbnRpbnVvdXModmFsdWUpKTtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybUludGVncmF0ZWRDYXRlZ29yeVZhbHVlKHZhbHVlKSB7XG4gIGlmIChpc1N0cmluZ09iamVjdCh2YWx1ZSkgJiYgT2JqZWN0Lmhhc093bih2YWx1ZSwgXCJpZFwiKSkge1xuICAgIHJldHVybiB2YWx1ZS5pZDtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2Nyb3NzbGluZS9jcm9zc0xpbmUudHNcbnZhciBNQVRDSElOR19DUk9TU0xJTkVfVFlQRSA9IChwcm9wZXJ0eSkgPT4ge1xuICByZXR1cm4gcHJvcGVydHkgPT09IFwidmFsdWVcIiA/IHByZWRpY2F0ZVdpdGhNZXNzYWdlKFxuICAgIChfLCBjdHgpID0+IGN0eC50YXJnZXRbXCJ0eXBlXCJdID09PSBcImxpbmVcIixcbiAgICAoY3R4KSA9PiBjdHgudGFyZ2V0W1widHlwZVwiXSA9PT0gXCJyYW5nZVwiID8gYGNyb3NzTGluZSB0eXBlICdyYW5nZScgdG8gaGF2ZSBhICdyYW5nZScgcHJvcGVydHkgaW5zdGVhZCBvZiAndmFsdWUnYCA6IGBjcm9zc0xpbmUgcHJvcGVydHkgJ3R5cGUnIHRvIGJlICdsaW5lJ2BcbiAgKSA6IHByZWRpY2F0ZVdpdGhNZXNzYWdlKFxuICAgIChfLCBjdHgpID0+IGN0eC50YXJnZXRbXCJ0eXBlXCJdID09PSBcInJhbmdlXCIsXG4gICAgKGN0eCkgPT4gY3R4LnRhcmdldC50eXBlID09PSBcImxpbmVcIiA/IGBjcm9zc0xpbmUgdHlwZSAnbGluZScgdG8gaGF2ZSBhICd2YWx1ZScgcHJvcGVydHkgaW5zdGVhZCBvZiAncmFuZ2UnYCA6IGBjcm9zc0xpbmUgcHJvcGVydHkgJ3R5cGUnIHRvIGJlICdyYW5nZSdgXG4gICk7XG59O1xudmFyIHZhbGlkYXRlQ3Jvc3NMaW5lVmFsdWVzID0gKHR5cGUsIHZhbHVlLCByYW5nZTMsIHNjYWxlMiwgdmlzaWJpbGl0eUNoZWNrKSA9PiB7XG4gIGNvbnN0IGxpbmVDcm9zc0xpbmUgPSB0eXBlID09PSBcImxpbmVcIiAmJiB2YWx1ZSAhPT0gdm9pZCAwO1xuICBjb25zdCByYW5nZUNyb3NzTGluZSA9IHR5cGUgPT09IFwicmFuZ2VcIiAmJiByYW5nZTMgIT09IHZvaWQgMDtcbiAgaWYgKCFsaW5lQ3Jvc3NMaW5lICYmICFyYW5nZUNyb3NzTGluZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IFtzdGFydDIsIGVuZDJdID0gcmFuZ2UzID8/IFt2YWx1ZSwgdm9pZCAwXTtcbiAgY29uc3QgaXNDb250aW51b3VzMiA9IENvbnRpbnVvdXNTY2FsZS5pcyhzY2FsZTIpIHx8IE9yZGluYWxUaW1lU2NhbGUuaXMoc2NhbGUyKTtcbiAgY29uc3QgdmFsaWRTdGFydCA9IGNoZWNrRGF0dW0oc3RhcnQyLCBpc0NvbnRpbnVvdXMyKSAmJiAhaXNOYU4oc2NhbGUyLmNvbnZlcnQoc3RhcnQyKSk7XG4gIGNvbnN0IHZhbGlkRW5kID0gY2hlY2tEYXR1bShlbmQyLCBpc0NvbnRpbnVvdXMyKSAmJiAhaXNOYU4oc2NhbGUyLmNvbnZlcnQoZW5kMikpO1xuICBpZiAobGluZUNyb3NzTGluZSAmJiB2YWxpZFN0YXJ0IHx8IHJhbmdlQ3Jvc3NMaW5lICYmIHZhbGlkU3RhcnQgJiYgdmFsaWRFbmQpIHtcbiAgICByZXR1cm4gdmlzaWJpbGl0eUNoZWNrPy4oKSA/PyB0cnVlO1xuICB9XG4gIGNvbnN0IG1lc3NhZ2UgPSBbYEV4cGVjdGluZyBjcm9zc0xpbmVgXTtcbiAgaWYgKHJhbmdlQ3Jvc3NMaW5lKSB7XG4gICAgaWYgKCF2YWxpZFN0YXJ0KSB7XG4gICAgICBtZXNzYWdlLnB1c2goYHJhbmdlIHN0YXJ0ICR7c3RyaW5naWZ5KHN0YXJ0Mil9YCk7XG4gICAgfVxuICAgIGlmICghdmFsaWRFbmQpIHtcbiAgICAgIG1lc3NhZ2UucHVzaChgJHt2YWxpZFN0YXJ0ID8gXCJcIiA6IFwiYW5kIFwifXJhbmdlIGVuZCAke3N0cmluZ2lmeShlbmQyKX1gKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbWVzc2FnZS5wdXNoKGB2YWx1ZSAke3N0cmluZ2lmeShzdGFydDIpfWApO1xuICB9XG4gIG1lc3NhZ2UucHVzaChgdG8gbWF0Y2ggdGhlIGF4aXMgc2NhbGUgZG9tYWluLmApO1xuICBMb2dnZXIud2Fybk9uY2UobWVzc2FnZS5qb2luKFwiIFwiKSk7XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2Nyb3NzbGluZS9jcm9zc0xpbmVMYWJlbFBvc2l0aW9uLnRzXG52YXIgaG9yaXpvbnRhbENyb3NzbGluZVRyYW5zbGF0aW9uRGlyZWN0aW9ucyA9IHtcbiAgdG9wOiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogMCwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAtMSB9LFxuICBib3R0b206IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAwLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IDEgfSxcbiAgbGVmdDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IDAgfSxcbiAgcmlnaHQ6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IDAgfSxcbiAgdG9wTGVmdDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IDEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEgfSxcbiAgdG9wUmlnaHQ6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAtMSwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAtMSB9LFxuICBib3R0b21MZWZ0OiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxIH0sXG4gIGJvdHRvbVJpZ2h0OiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSB9LFxuICBpbnNpZGU6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAwLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IDAgfSxcbiAgaW5zaWRlTGVmdDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IDEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogMCB9LFxuICBpbnNpZGVSaWdodDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IDAgfSxcbiAgaW5zaWRlVG9wOiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogMCwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxIH0sXG4gIGluc2lkZUJvdHRvbTogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IDAsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEgfSxcbiAgaW5zaWRlVG9wTGVmdDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IDEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSB9LFxuICBpbnNpZGVCb3R0b21MZWZ0OiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAtMSB9LFxuICBpbnNpZGVUb3BSaWdodDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IDEgfSxcbiAgaW5zaWRlQm90dG9tUmlnaHQ6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAtMSwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAtMSB9XG59O1xudmFyIHZlcnRpY2FsQ3Jvc3NMaW5lVHJhbnNsYXRpb25EaXJlY3Rpb25zID0ge1xuICB0b3A6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IDAgfSxcbiAgYm90dG9tOiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogMCB9LFxuICBsZWZ0OiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogMCwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAtMSB9LFxuICByaWdodDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IDAsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSB9LFxuICB0b3BMZWZ0OiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEgfSxcbiAgdG9wUmlnaHQ6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAtMSwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxIH0sXG4gIGJvdHRvbUxlZnQ6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xIH0sXG4gIGJvdHRvbVJpZ2h0OiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxIH0sXG4gIGluc2lkZTogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IDAsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogMCB9LFxuICBpbnNpZGVMZWZ0OiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogMCwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxIH0sXG4gIGluc2lkZVJpZ2h0OiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogMCwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAtMSB9LFxuICBpbnNpZGVUb3A6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAtMSwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAwIH0sXG4gIGluc2lkZUJvdHRvbTogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IDEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogMCB9LFxuICBpbnNpZGVUb3BMZWZ0OiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSB9LFxuICBpbnNpZGVCb3R0b21MZWZ0OiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxIH0sXG4gIGluc2lkZVRvcFJpZ2h0OiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEgfSxcbiAgaW5zaWRlQm90dG9tUmlnaHQ6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xIH1cbn07XG5mdW5jdGlvbiBjYWxjdWxhdGVMYWJlbFRyYW5zbGF0aW9uKHtcbiAgeURpcmVjdGlvbixcbiAgcGFkZGluZyA9IDAsXG4gIHBvc2l0aW9uID0gXCJ0b3BcIixcbiAgYmJveFxufSkge1xuICBjb25zdCBjcm9zc0xpbmVUcmFuc2xhdGlvbkRpcmVjdGlvbnMgPSB5RGlyZWN0aW9uID8gaG9yaXpvbnRhbENyb3NzbGluZVRyYW5zbGF0aW9uRGlyZWN0aW9ucyA6IHZlcnRpY2FsQ3Jvc3NMaW5lVHJhbnNsYXRpb25EaXJlY3Rpb25zO1xuICBjb25zdCB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbiwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uIH0gPSBjcm9zc0xpbmVUcmFuc2xhdGlvbkRpcmVjdGlvbnNbcG9zaXRpb25dO1xuICBjb25zdCB4VHJhbnNsYXRpb24gPSB4VHJhbnNsYXRpb25EaXJlY3Rpb24gKiAocGFkZGluZyArIGJib3gud2lkdGggLyAyKTtcbiAgY29uc3QgeVRyYW5zbGF0aW9uID0geVRyYW5zbGF0aW9uRGlyZWN0aW9uICogKHBhZGRpbmcgKyBiYm94LmhlaWdodCAvIDIpO1xuICByZXR1cm4ge1xuICAgIHhUcmFuc2xhdGlvbixcbiAgICB5VHJhbnNsYXRpb25cbiAgfTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZUxhYmVsQ2hhcnRQYWRkaW5nKHtcbiAgeURpcmVjdGlvbixcbiAgYmJveCxcbiAgcGFkZGluZyA9IDAsXG4gIHBvc2l0aW9uID0gXCJ0b3BcIlxufSkge1xuICBjb25zdCBjaGFydFBhZGRpbmcgPSB7fTtcbiAgaWYgKHBvc2l0aW9uLnN0YXJ0c1dpdGgoXCJpbnNpZGVcIikpXG4gICAgcmV0dXJuIGNoYXJ0UGFkZGluZztcbiAgaWYgKHBvc2l0aW9uID09PSBcInRvcFwiICYmICF5RGlyZWN0aW9uKSB7XG4gICAgY2hhcnRQYWRkaW5nLnRvcCA9IHBhZGRpbmcgKyBiYm94LmhlaWdodDtcbiAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gXCJib3R0b21cIiAmJiAheURpcmVjdGlvbikge1xuICAgIGNoYXJ0UGFkZGluZy5ib3R0b20gPSBwYWRkaW5nICsgYmJveC5oZWlnaHQ7XG4gIH0gZWxzZSBpZiAocG9zaXRpb24gPT09IFwibGVmdFwiICYmIHlEaXJlY3Rpb24pIHtcbiAgICBjaGFydFBhZGRpbmcubGVmdCA9IHBhZGRpbmcgKyBiYm94LndpZHRoO1xuICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSBcInJpZ2h0XCIgJiYgeURpcmVjdGlvbikge1xuICAgIGNoYXJ0UGFkZGluZy5yaWdodCA9IHBhZGRpbmcgKyBiYm94LndpZHRoO1xuICB9XG4gIHJldHVybiBjaGFydFBhZGRpbmc7XG59XG52YXIgUE9TSVRJT05fVE9QX0NPT1JESU5BVEVTID0gKHsgZGlyZWN0aW9uLCB4RW5kLCB5U3RhcnQsIHlFbmQgfSkgPT4ge1xuICBpZiAoZGlyZWN0aW9uID09PSBcInlcIiAvKiBZICovKSB7XG4gICAgcmV0dXJuIHsgeDogeEVuZCAvIDIsIHk6IHlTdGFydCB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7IHg6IHhFbmQsIHk6IGlzTmFOKHlFbmQpID8geVN0YXJ0IDogKHlTdGFydCArIHlFbmQpIC8gMiB9O1xuICB9XG59O1xudmFyIFBPU0lUSU9OX0xFRlRfQ09PUkRJTkFURVMgPSAoeyBkaXJlY3Rpb24sIHhTdGFydCwgeEVuZCwgeVN0YXJ0LCB5RW5kIH0pID0+IHtcbiAgaWYgKGRpcmVjdGlvbiA9PT0gXCJ5XCIgLyogWSAqLykge1xuICAgIHJldHVybiB7IHg6IHhTdGFydCwgeTogaXNOYU4oeUVuZCkgPyB5U3RhcnQgOiAoeVN0YXJ0ICsgeUVuZCkgLyAyIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHsgeDogeEVuZCAvIDIsIHk6IHlTdGFydCB9O1xuICB9XG59O1xudmFyIFBPU0lUSU9OX1JJR0hUX0NPT1JESU5BVEVTID0gKHsgZGlyZWN0aW9uLCB4RW5kLCB5U3RhcnQsIHlFbmQgfSkgPT4ge1xuICBpZiAoZGlyZWN0aW9uID09PSBcInlcIiAvKiBZICovKSB7XG4gICAgcmV0dXJuIHsgeDogeEVuZCwgeTogaXNOYU4oeUVuZCkgPyB5U3RhcnQgOiAoeVN0YXJ0ICsgeUVuZCkgLyAyIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHsgeDogeEVuZCAvIDIsIHk6IGlzTmFOKHlFbmQpID8geVN0YXJ0IDogeUVuZCB9O1xuICB9XG59O1xudmFyIFBPU0lUSU9OX0JPVFRPTV9DT09SRElOQVRFUyA9ICh7IGRpcmVjdGlvbiwgeFN0YXJ0LCB4RW5kLCB5U3RhcnQsIHlFbmQgfSkgPT4ge1xuICBpZiAoZGlyZWN0aW9uID09PSBcInlcIiAvKiBZICovKSB7XG4gICAgcmV0dXJuIHsgeDogeEVuZCAvIDIsIHk6IGlzTmFOKHlFbmQpID8geVN0YXJ0IDogeUVuZCB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7IHg6IHhTdGFydCwgeTogaXNOYU4oeUVuZCkgPyB5U3RhcnQgOiAoeVN0YXJ0ICsgeUVuZCkgLyAyIH07XG4gIH1cbn07XG52YXIgUE9TSVRJT05fSU5TSURFX0NPT1JESU5BVEVTID0gKHsgeEVuZCwgeVN0YXJ0LCB5RW5kIH0pID0+IHtcbiAgcmV0dXJuIHsgeDogeEVuZCAvIDIsIHk6IGlzTmFOKHlFbmQpID8geVN0YXJ0IDogKHlTdGFydCArIHlFbmQpIC8gMiB9O1xufTtcbnZhciBQT1NJVElPTl9UT1BfTEVGVF9DT09SRElOQVRFUyA9ICh7IGRpcmVjdGlvbiwgeFN0YXJ0LCB4RW5kLCB5U3RhcnQgfSkgPT4ge1xuICBpZiAoZGlyZWN0aW9uID09PSBcInlcIiAvKiBZICovKSB7XG4gICAgcmV0dXJuIHsgeDogeFN0YXJ0IC8gMiwgeTogeVN0YXJ0IH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHsgeDogeEVuZCwgeTogeVN0YXJ0IH07XG4gIH1cbn07XG52YXIgUE9TSVRJT05fQk9UVE9NX0xFRlRfQ09PUkRJTkFURVMgPSAoeyBkaXJlY3Rpb24sIHhTdGFydCwgeVN0YXJ0LCB5RW5kIH0pID0+IHtcbiAgaWYgKGRpcmVjdGlvbiA9PT0gXCJ5XCIgLyogWSAqLykge1xuICAgIHJldHVybiB7IHg6IHhTdGFydCwgeTogaXNOYU4oeUVuZCkgPyB5U3RhcnQgOiB5RW5kIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHsgeDogeFN0YXJ0LCB5OiB5U3RhcnQgfTtcbiAgfVxufTtcbnZhciBQT1NJVElPTl9UT1BfUklHSFRfQ09PUkRJTkFURVMgPSAoeyBkaXJlY3Rpb24sIHhFbmQsIHlTdGFydCwgeUVuZCB9KSA9PiB7XG4gIGlmIChkaXJlY3Rpb24gPT09IFwieVwiIC8qIFkgKi8pIHtcbiAgICByZXR1cm4geyB4OiB4RW5kLCB5OiB5U3RhcnQgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geyB4OiB4RW5kLCB5OiBpc05hTih5RW5kKSA/IHlTdGFydCA6IHlFbmQgfTtcbiAgfVxufTtcbnZhciBQT1NJVElPTl9CT1RUT01fUklHSFRfQ09PUkRJTkFURVMgPSAoeyBkaXJlY3Rpb24sIHhTdGFydCwgeEVuZCwgeVN0YXJ0LCB5RW5kIH0pID0+IHtcbiAgaWYgKGRpcmVjdGlvbiA9PT0gXCJ5XCIgLyogWSAqLykge1xuICAgIHJldHVybiB7IHg6IHhFbmQsIHk6IGlzTmFOKHlFbmQpID8geVN0YXJ0IDogeUVuZCB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7IHg6IHhTdGFydCwgeTogaXNOYU4oeUVuZCkgPyB5U3RhcnQgOiB5RW5kIH07XG4gIH1cbn07XG52YXIgbGFiZWxEaXJlY3Rpb25IYW5kbGluZyA9IHtcbiAgdG9wOiB7IGM6IFBPU0lUSU9OX1RPUF9DT09SRElOQVRFUyB9LFxuICBib3R0b206IHsgYzogUE9TSVRJT05fQk9UVE9NX0NPT1JESU5BVEVTIH0sXG4gIGxlZnQ6IHsgYzogUE9TSVRJT05fTEVGVF9DT09SRElOQVRFUyB9LFxuICByaWdodDogeyBjOiBQT1NJVElPTl9SSUdIVF9DT09SRElOQVRFUyB9LFxuICB0b3BMZWZ0OiB7IGM6IFBPU0lUSU9OX1RPUF9MRUZUX0NPT1JESU5BVEVTIH0sXG4gIHRvcFJpZ2h0OiB7IGM6IFBPU0lUSU9OX1RPUF9SSUdIVF9DT09SRElOQVRFUyB9LFxuICBib3R0b21MZWZ0OiB7IGM6IFBPU0lUSU9OX0JPVFRPTV9MRUZUX0NPT1JESU5BVEVTIH0sXG4gIGJvdHRvbVJpZ2h0OiB7IGM6IFBPU0lUSU9OX0JPVFRPTV9SSUdIVF9DT09SRElOQVRFUyB9LFxuICBpbnNpZGU6IHsgYzogUE9TSVRJT05fSU5TSURFX0NPT1JESU5BVEVTIH0sXG4gIGluc2lkZUxlZnQ6IHsgYzogUE9TSVRJT05fTEVGVF9DT09SRElOQVRFUyB9LFxuICBpbnNpZGVSaWdodDogeyBjOiBQT1NJVElPTl9SSUdIVF9DT09SRElOQVRFUyB9LFxuICBpbnNpZGVUb3A6IHsgYzogUE9TSVRJT05fVE9QX0NPT1JESU5BVEVTIH0sXG4gIGluc2lkZUJvdHRvbTogeyBjOiBQT1NJVElPTl9CT1RUT01fQ09PUkRJTkFURVMgfSxcbiAgaW5zaWRlVG9wTGVmdDogeyBjOiBQT1NJVElPTl9UT1BfTEVGVF9DT09SRElOQVRFUyB9LFxuICBpbnNpZGVCb3R0b21MZWZ0OiB7IGM6IFBPU0lUSU9OX0JPVFRPTV9MRUZUX0NPT1JESU5BVEVTIH0sXG4gIGluc2lkZVRvcFJpZ2h0OiB7IGM6IFBPU0lUSU9OX1RPUF9SSUdIVF9DT09SRElOQVRFUyB9LFxuICBpbnNpZGVCb3R0b21SaWdodDogeyBjOiBQT1NJVElPTl9CT1RUT01fUklHSFRfQ09PUkRJTkFURVMgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvY3Jvc3NsaW5lL2NhcnRlc2lhbkNyb3NzTGluZS50c1xudmFyIENST1NTTElORV9MQUJFTF9QT1NJVElPTiA9IFVOSU9OKFxuICBbXG4gICAgXCJ0b3BcIixcbiAgICBcImxlZnRcIixcbiAgICBcInJpZ2h0XCIsXG4gICAgXCJib3R0b21cIixcbiAgICBcInRvcExlZnRcIixcbiAgICBcInRvcFJpZ2h0XCIsXG4gICAgXCJib3R0b21MZWZ0XCIsXG4gICAgXCJib3R0b21SaWdodFwiLFxuICAgIFwiaW5zaWRlXCIsXG4gICAgXCJpbnNpZGVMZWZ0XCIsXG4gICAgXCJpbnNpZGVSaWdodFwiLFxuICAgIFwiaW5zaWRlVG9wXCIsXG4gICAgXCJpbnNpZGVCb3R0b21cIixcbiAgICBcImluc2lkZVRvcExlZnRcIixcbiAgICBcImluc2lkZUJvdHRvbUxlZnRcIixcbiAgICBcImluc2lkZVRvcFJpZ2h0XCIsXG4gICAgXCJpbnNpZGVCb3R0b21SaWdodFwiXG4gIF0sXG4gIFwiY3Jvc3NMaW5lIGxhYmVsIHBvc2l0aW9uXCJcbik7XG52YXIgQ2FydGVzaWFuQ3Jvc3NMaW5lTGFiZWwgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmZvbnRTaXplID0gMTQ7XG4gICAgdGhpcy5mb250RmFtaWx5ID0gXCJWZXJkYW5hLCBzYW5zLXNlcmlmXCI7XG4gICAgdGhpcy5wYWRkaW5nID0gNTtcbiAgICB0aGlzLmNvbG9yID0gXCJyZ2JhKDg3LCA4NywgODcsIDEpXCI7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBDYXJ0ZXNpYW5Dcm9zc0xpbmVMYWJlbC5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQ2FydGVzaWFuQ3Jvc3NMaW5lTGFiZWwucHJvdG90eXBlLCBcInRleHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGT05UX1NUWUxFLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBDYXJ0ZXNpYW5Dcm9zc0xpbmVMYWJlbC5wcm90b3R5cGUsIFwiZm9udFN0eWxlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoRk9OVF9XRUlHSFQsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIENhcnRlc2lhbkNyb3NzTGluZUxhYmVsLnByb3RvdHlwZSwgXCJmb250V2VpZ2h0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgQ2FydGVzaWFuQ3Jvc3NMaW5lTGFiZWwucHJvdG90eXBlLCBcImZvbnRTaXplXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HKVxuXSwgQ2FydGVzaWFuQ3Jvc3NMaW5lTGFiZWwucHJvdG90eXBlLCBcImZvbnRGYW1pbHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShOVU1CRVIpXG5dLCBDYXJ0ZXNpYW5Dcm9zc0xpbmVMYWJlbC5wcm90b3R5cGUsIFwicGFkZGluZ1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQ2FydGVzaWFuQ3Jvc3NMaW5lTGFiZWwucHJvdG90eXBlLCBcImNvbG9yXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ1JPU1NMSU5FX0xBQkVMX1BPU0lUSU9OLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBDYXJ0ZXNpYW5Dcm9zc0xpbmVMYWJlbC5wcm90b3R5cGUsIFwicG9zaXRpb25cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShERUdSRUUsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIENhcnRlc2lhbkNyb3NzTGluZUxhYmVsLnByb3RvdHlwZSwgXCJyb3RhdGlvblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIENhcnRlc2lhbkNyb3NzTGluZUxhYmVsLnByb3RvdHlwZSwgXCJwYXJhbGxlbFwiLCAyKTtcbnZhciBfQ2FydGVzaWFuQ3Jvc3NMaW5lID0gY2xhc3MgX0NhcnRlc2lhbkNyb3NzTGluZSBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmlkID0gY3JlYXRlSWQodGhpcyk7XG4gICAgdGhpcy5sYWJlbCA9IG5ldyBDYXJ0ZXNpYW5Dcm9zc0xpbmVMYWJlbCgpO1xuICAgIHRoaXMuc2NhbGUgPSB2b2lkIDA7XG4gICAgdGhpcy5jbGlwcGVkUmFuZ2UgPSBbLUluZmluaXR5LCBJbmZpbml0eV07XG4gICAgdGhpcy5ncmlkTGVuZ3RoID0gMDtcbiAgICB0aGlzLnNpZGVGbGFnID0gLTE7XG4gICAgdGhpcy5wYXJhbGxlbEZsaXBSb3RhdGlvbiA9IDA7XG4gICAgdGhpcy5yZWd1bGFyRmxpcFJvdGF0aW9uID0gMDtcbiAgICB0aGlzLmRpcmVjdGlvbiA9IFwieFwiIC8qIFggKi87XG4gICAgdGhpcy5ncm91cCA9IG5ldyBMYXllcih7IG5hbWU6IHRoaXMuaWQsIHpJbmRleDogX0NhcnRlc2lhbkNyb3NzTGluZS5MSU5FX0xBWUVSX1pJTkRFWCB9KTtcbiAgICB0aGlzLmxhYmVsR3JvdXAgPSBuZXcgTGF5ZXIoeyBuYW1lOiB0aGlzLmlkLCB6SW5kZXg6IF9DYXJ0ZXNpYW5Dcm9zc0xpbmUuTEFCRUxfTEFZRVJfWklOREVYIH0pO1xuICAgIHRoaXMuY3Jvc3NMaW5lUmFuZ2UgPSBuZXcgUmFuZ2UoKTtcbiAgICB0aGlzLmNyb3NzTGluZUxhYmVsID0gbmV3IFRyYW5zZm9ybWFibGVUZXh0KCk7XG4gICAgdGhpcy5sYWJlbFBvaW50ID0gdm9pZCAwO1xuICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgIHRoaXMuc3RhcnRMaW5lID0gZmFsc2U7XG4gICAgdGhpcy5lbmRMaW5lID0gZmFsc2U7XG4gICAgdGhpcy5pc1JhbmdlID0gZmFsc2U7XG4gICAgdGhpcy5ncm91cC5hcHBlbmQodGhpcy5jcm9zc0xpbmVSYW5nZSk7XG4gICAgdGhpcy5sYWJlbEdyb3VwLmFwcGVuZCh0aGlzLmNyb3NzTGluZUxhYmVsKTtcbiAgICB0aGlzLmNyb3NzTGluZVJhbmdlLnBvaW50ZXJFdmVudHMgPSAxIC8qIE5vbmUgKi87XG4gIH1cbiAgdXBkYXRlKHZpc2libGUpIHtcbiAgICBjb25zdCB7IGVuYWJsZWQsIGRhdGEsIHR5cGUsIHZhbHVlLCByYW5nZTogcmFuZ2UzLCBzY2FsZTogc2NhbGUyIH0gPSB0aGlzO1xuICAgIGlmICghdHlwZSB8fCAhc2NhbGUyIHx8ICFlbmFibGVkIHx8ICF2aXNpYmxlIHx8ICF2YWxpZGF0ZUNyb3NzTGluZVZhbHVlcyh0eXBlLCB2YWx1ZSwgcmFuZ2UzLCBzY2FsZTIpIHx8IGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLmdyb3VwLnZpc2libGUgPSBmYWxzZTtcbiAgICAgIHRoaXMubGFiZWxHcm91cC52aXNpYmxlID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZ3JvdXAudmlzaWJsZSA9IHZpc2libGU7XG4gICAgdGhpcy5sYWJlbEdyb3VwLnZpc2libGUgPSB2aXNpYmxlO1xuICAgIHRoaXMuZ3JvdXAuekluZGV4ID0gdGhpcy5nZXRaSW5kZXgodGhpcy5pc1JhbmdlKTtcbiAgICB0aGlzLnVwZGF0ZU5vZGVzKCk7XG4gIH1cbiAgY2FsY3VsYXRlTGF5b3V0KHZpc2libGUsIHJldmVyc2VkQXhpcykge1xuICAgIGlmICghdmlzaWJsZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7XG4gICAgICBzY2FsZTogc2NhbGUyLFxuICAgICAgZ3JpZExlbmd0aCxcbiAgICAgIHNpZGVGbGFnLFxuICAgICAgZGlyZWN0aW9uLFxuICAgICAgbGFiZWw6IHsgcG9zaXRpb24gPSBcInRvcFwiIH0sXG4gICAgICBjbGlwcGVkUmFuZ2UsXG4gICAgICBzdHJva2VXaWR0aCA9IDBcbiAgICB9ID0gdGhpcztcbiAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICBpZiAoIXNjYWxlMilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBiYW5kd2lkdGggPSBzY2FsZTIuYmFuZHdpZHRoID8/IDA7XG4gICAgY29uc3Qgc3RlcCA9IHNjYWxlMi5zdGVwID8/IDA7XG4gICAgY29uc3QgcGFkZGluZyA9IChyZXZlcnNlZEF4aXMgPyAtMSA6IDEpICogKHNjYWxlMiBpbnN0YW5jZW9mIEJhbmRTY2FsZSA/IChzdGVwIC0gYmFuZHdpZHRoKSAvIDIgOiAwKTtcbiAgICBjb25zdCBbeFN0YXJ0LCB4RW5kXSA9IFswLCBzaWRlRmxhZyAqIGdyaWRMZW5ndGhdO1xuICAgIGxldCBbeVN0YXJ0LCB5RW5kXSA9IHRoaXMuZ2V0UmFuZ2UoKTtcbiAgICBjb25zdCBvcmRpbmFsVGltZVNjYWxlUGFkZGluZyA9IHlFbmQgPT09IHZvaWQgMCAmJiBPcmRpbmFsVGltZVNjYWxlLmlzKHNjYWxlMikgPyBiYW5kd2lkdGggLyAyICsgcGFkZGluZyA6IDA7XG4gICAgbGV0IFtjbGFtcGVkWVN0YXJ0LCBjbGFtcGVkWUVuZF0gPSBbXG4gICAgICBOdW1iZXIoc2NhbGUyLmNvbnZlcnQoeVN0YXJ0LCB7IGNsYW1wTW9kZTogXCJjbGFtcGVkXCIgfSkpIC0gcGFkZGluZyArIG9yZGluYWxUaW1lU2NhbGVQYWRkaW5nLFxuICAgICAgc2NhbGUyLmNvbnZlcnQoeUVuZCwgeyBjbGFtcE1vZGU6IFwiY2xhbXBlZFwiIH0pICsgYmFuZHdpZHRoICsgcGFkZGluZ1xuICAgIF07XG4gICAgY2xhbXBlZFlTdGFydCA9IGNsYW1wQXJyYXkoY2xhbXBlZFlTdGFydCwgY2xpcHBlZFJhbmdlKTtcbiAgICBjbGFtcGVkWUVuZCA9IGNsYW1wQXJyYXkoY2xhbXBlZFlFbmQsIGNsaXBwZWRSYW5nZSk7XG4gICAgW3lTdGFydCwgeUVuZF0gPSBbTnVtYmVyKHNjYWxlMi5jb252ZXJ0KHlTdGFydCkpICsgb3JkaW5hbFRpbWVTY2FsZVBhZGRpbmcsIHNjYWxlMi5jb252ZXJ0KHlFbmQpICsgYmFuZHdpZHRoXTtcbiAgICBjb25zdCB2YWxpZFJhbmdlID0gKHlTdGFydCA9PT0gY2xhbXBlZFlTdGFydCB8fCB5RW5kID09PSBjbGFtcGVkWUVuZCB8fCBjbGFtcGVkWVN0YXJ0ICE9PSBjbGFtcGVkWUVuZCkgJiYgTWF0aC5hYnMoY2xhbXBlZFlFbmQgLSBjbGFtcGVkWVN0YXJ0KSA+IDA7XG4gICAgaWYgKHZhbGlkUmFuZ2UgJiYgY2xhbXBlZFlTdGFydCA+IGNsYW1wZWRZRW5kKSB7XG4gICAgICBbY2xhbXBlZFlTdGFydCwgY2xhbXBlZFlFbmRdID0gW2NsYW1wZWRZRW5kLCBjbGFtcGVkWVN0YXJ0XTtcbiAgICAgIFt5U3RhcnQsIHlFbmRdID0gW3lFbmQsIHlTdGFydF07XG4gICAgfVxuICAgIGlmICh5U3RhcnQgLSBwYWRkaW5nID49IGNsYW1wZWRZU3RhcnQpXG4gICAgICB5U3RhcnQgLT0gcGFkZGluZztcbiAgICBpZiAoeUVuZCArIHBhZGRpbmcgPD0gY2xhbXBlZFlFbmQpXG4gICAgICB5RW5kICs9IHBhZGRpbmc7XG4gICAgdGhpcy5pc1JhbmdlID0gdmFsaWRSYW5nZTtcbiAgICB0aGlzLnN0YXJ0TGluZSA9IHN0cm9rZVdpZHRoID4gMCAmJiB5U3RhcnQgPj0gY2xhbXBlZFlTdGFydCAmJiB5U3RhcnQgPD0gY2xhbXBlZFlTdGFydCArIHBhZGRpbmc7XG4gICAgdGhpcy5lbmRMaW5lID0gc3Ryb2tlV2lkdGggPiAwICYmIHlFbmQgPj0gY2xhbXBlZFlFbmQgLSBiYW5kd2lkdGggLSBwYWRkaW5nICYmIHlFbmQgPD0gY2xhbXBlZFlFbmQ7XG4gICAgaWYgKCF2YWxpZFJhbmdlICYmICF0aGlzLnN0YXJ0TGluZSAmJiAhdGhpcy5lbmRMaW5lKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuZGF0YSA9IFtjbGFtcGVkWVN0YXJ0LCBjbGFtcGVkWUVuZF07XG4gICAgaWYgKCF0aGlzLmxhYmVsLmVuYWJsZWQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBjID0gUE9TSVRJT05fVE9QX0NPT1JESU5BVEVTIH0gPSBsYWJlbERpcmVjdGlvbkhhbmRsaW5nW3Bvc2l0aW9uXSA/PyB7fTtcbiAgICBjb25zdCB7IHg6IGxhYmVsWCwgeTogbGFiZWxZIH0gPSBjKHtcbiAgICAgIGRpcmVjdGlvbixcbiAgICAgIHhTdGFydCxcbiAgICAgIHhFbmQsXG4gICAgICB5U3RhcnQ6IGNsYW1wZWRZU3RhcnQsXG4gICAgICB5RW5kOiBjbGFtcGVkWUVuZFxuICAgIH0pO1xuICAgIHRoaXMubGFiZWxQb2ludCA9IHtcbiAgICAgIHg6IGxhYmVsWCxcbiAgICAgIHk6IGxhYmVsWVxuICAgIH07XG4gIH1cbiAgdXBkYXRlTm9kZXMoKSB7XG4gICAgdGhpcy51cGRhdGVSYW5nZU5vZGUoKTtcbiAgICBpZiAodGhpcy5sYWJlbC5lbmFibGVkKSB7XG4gICAgICB0aGlzLnVwZGF0ZUxhYmVsKCk7XG4gICAgICB0aGlzLnBvc2l0aW9uTGFiZWwoKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlUmFuZ2VOb2RlKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNyb3NzTGluZVJhbmdlLFxuICAgICAgc2lkZUZsYWcsXG4gICAgICBncmlkTGVuZ3RoLFxuICAgICAgZGF0YSxcbiAgICAgIHN0YXJ0TGluZSxcbiAgICAgIGVuZExpbmUsXG4gICAgICBpc1JhbmdlLFxuICAgICAgZmlsbCxcbiAgICAgIGZpbGxPcGFjaXR5LFxuICAgICAgc3Ryb2tlLFxuICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICBsaW5lRGFzaFxuICAgIH0gPSB0aGlzO1xuICAgIGNyb3NzTGluZVJhbmdlLngxID0gMDtcbiAgICBjcm9zc0xpbmVSYW5nZS54MiA9IHNpZGVGbGFnICogZ3JpZExlbmd0aDtcbiAgICBjcm9zc0xpbmVSYW5nZS55MSA9IGRhdGFbMF07XG4gICAgY3Jvc3NMaW5lUmFuZ2UueTIgPSBkYXRhWzFdO1xuICAgIGNyb3NzTGluZVJhbmdlLnN0YXJ0TGluZSA9IHN0YXJ0TGluZTtcbiAgICBjcm9zc0xpbmVSYW5nZS5lbmRMaW5lID0gZW5kTGluZTtcbiAgICBjcm9zc0xpbmVSYW5nZS5pc1JhbmdlID0gaXNSYW5nZTtcbiAgICBjcm9zc0xpbmVSYW5nZS5maWxsID0gZmlsbDtcbiAgICBjcm9zc0xpbmVSYW5nZS5maWxsT3BhY2l0eSA9IGZpbGxPcGFjaXR5ID8/IDE7XG4gICAgY3Jvc3NMaW5lUmFuZ2Uuc3Ryb2tlID0gc3Ryb2tlO1xuICAgIGNyb3NzTGluZVJhbmdlLnN0cm9rZVdpZHRoID0gc3Ryb2tlV2lkdGggPz8gMTtcbiAgICBjcm9zc0xpbmVSYW5nZS5zdHJva2VPcGFjaXR5ID0gdGhpcy5zdHJva2VPcGFjaXR5ID8/IDE7XG4gICAgY3Jvc3NMaW5lUmFuZ2UubGluZURhc2ggPSBsaW5lRGFzaDtcbiAgfVxuICB1cGRhdGVMYWJlbCgpIHtcbiAgICBjb25zdCB7IGNyb3NzTGluZUxhYmVsLCBsYWJlbCB9ID0gdGhpcztcbiAgICBpZiAoIWxhYmVsLnRleHQpXG4gICAgICByZXR1cm47XG4gICAgY3Jvc3NMaW5lTGFiZWwuZm9udFN0eWxlID0gbGFiZWwuZm9udFN0eWxlO1xuICAgIGNyb3NzTGluZUxhYmVsLmZvbnRXZWlnaHQgPSBsYWJlbC5mb250V2VpZ2h0O1xuICAgIGNyb3NzTGluZUxhYmVsLmZvbnRTaXplID0gbGFiZWwuZm9udFNpemU7XG4gICAgY3Jvc3NMaW5lTGFiZWwuZm9udEZhbWlseSA9IGxhYmVsLmZvbnRGYW1pbHk7XG4gICAgY3Jvc3NMaW5lTGFiZWwuZmlsbCA9IGxhYmVsLmNvbG9yO1xuICAgIGNyb3NzTGluZUxhYmVsLnRleHQgPSBsYWJlbC50ZXh0O1xuICB9XG4gIHBvc2l0aW9uTGFiZWwoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY3Jvc3NMaW5lTGFiZWwsXG4gICAgICBsYWJlbFBvaW50OiB7IHggPSB2b2lkIDAsIHkgPSB2b2lkIDAgfSA9IHt9LFxuICAgICAgbGFiZWw6IHsgcGFyYWxsZWwsIHJvdGF0aW9uLCBwb3NpdGlvbiA9IFwidG9wXCIsIHBhZGRpbmcgPSAwIH0sXG4gICAgICBkaXJlY3Rpb24sXG4gICAgICBwYXJhbGxlbEZsaXBSb3RhdGlvbixcbiAgICAgIHJlZ3VsYXJGbGlwUm90YXRpb25cbiAgICB9ID0gdGhpcztcbiAgICBpZiAoeCA9PT0gdm9pZCAwIHx8IHkgPT09IHZvaWQgMClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IGRlZmF1bHRSb3RhdGlvbiwgY29uZmlndXJlZFJvdGF0aW9uIH0gPSBjYWxjdWxhdGVMYWJlbFJvdGF0aW9uKHtcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgcGFyYWxsZWwsXG4gICAgICByZWd1bGFyRmxpcFJvdGF0aW9uLFxuICAgICAgcGFyYWxsZWxGbGlwUm90YXRpb25cbiAgICB9KTtcbiAgICBjcm9zc0xpbmVMYWJlbC5yb3RhdGlvbiA9IGRlZmF1bHRSb3RhdGlvbiArIGNvbmZpZ3VyZWRSb3RhdGlvbjtcbiAgICBjcm9zc0xpbmVMYWJlbC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xuICAgIGNyb3NzTGluZUxhYmVsLnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgY29uc3QgYmJveCA9IGNyb3NzTGluZUxhYmVsLmdldEJCb3goKTtcbiAgICBpZiAoIWJib3gpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeURpcmVjdGlvbiA9IGRpcmVjdGlvbiA9PT0gXCJ5XCIgLyogWSAqLztcbiAgICBjb25zdCB7IHhUcmFuc2xhdGlvbiwgeVRyYW5zbGF0aW9uIH0gPSBjYWxjdWxhdGVMYWJlbFRyYW5zbGF0aW9uKHtcbiAgICAgIHlEaXJlY3Rpb24sXG4gICAgICBwYWRkaW5nLFxuICAgICAgcG9zaXRpb24sXG4gICAgICBiYm94XG4gICAgfSk7XG4gICAgY3Jvc3NMaW5lTGFiZWwudHJhbnNsYXRpb25YID0geCArIHhUcmFuc2xhdGlvbjtcbiAgICBjcm9zc0xpbmVMYWJlbC50cmFuc2xhdGlvblkgPSB5ICsgeVRyYW5zbGF0aW9uO1xuICB9XG4gIGdldFpJbmRleChpc1JhbmdlID0gZmFsc2UpIHtcbiAgICByZXR1cm4gaXNSYW5nZSA/IF9DYXJ0ZXNpYW5Dcm9zc0xpbmUuUkFOR0VfTEFZRVJfWklOREVYIDogX0NhcnRlc2lhbkNyb3NzTGluZS5MSU5FX0xBWUVSX1pJTkRFWDtcbiAgfVxuICBnZXRSYW5nZSgpIHtcbiAgICBjb25zdCB7IHZhbHVlLCByYW5nZTogcmFuZ2UzLCBzY2FsZTogc2NhbGUyIH0gPSB0aGlzO1xuICAgIGNvbnN0IGlzQ29udGludW91czIgPSBDb250aW51b3VzU2NhbGUuaXMoc2NhbGUyKSB8fCBPcmRpbmFsVGltZVNjYWxlLmlzKHNjYWxlMik7XG4gICAgY29uc3Qgc3RhcnQyID0gcmFuZ2UzPy5bMF0gPz8gdmFsdWU7XG4gICAgbGV0IGVuZDIgPSByYW5nZTM/LlsxXTtcbiAgICBpZiAoIWlzQ29udGludW91czIgJiYgZW5kMiA9PT0gdm9pZCAwKSB7XG4gICAgICBlbmQyID0gc3RhcnQyO1xuICAgIH1cbiAgICBpZiAoaXNDb250aW51b3VzMiAmJiBzdGFydDIgPT09IGVuZDIpIHtcbiAgICAgIGVuZDIgPSB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBbc3RhcnQyLCBlbmQyXTtcbiAgfVxuICBjb21wdXRlTGFiZWxCQm94KCkge1xuICAgIGNvbnN0IHsgbGFiZWwgfSA9IHRoaXM7XG4gICAgaWYgKCFsYWJlbC5lbmFibGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHRlbXBUZXh0ID0gbmV3IFRyYW5zZm9ybWFibGVUZXh0KCk7XG4gICAgdGVtcFRleHQuZm9udEZhbWlseSA9IGxhYmVsLmZvbnRGYW1pbHk7XG4gICAgdGVtcFRleHQuZm9udFNpemUgPSBsYWJlbC5mb250U2l6ZTtcbiAgICB0ZW1wVGV4dC5mb250U3R5bGUgPSBsYWJlbC5mb250U3R5bGU7XG4gICAgdGVtcFRleHQuZm9udFdlaWdodCA9IGxhYmVsLmZvbnRXZWlnaHQ7XG4gICAgdGVtcFRleHQudGV4dCA9IGxhYmVsLnRleHQ7XG4gICAgY29uc3Qge1xuICAgICAgbGFiZWxQb2ludDogeyB4ID0gdm9pZCAwLCB5ID0gdm9pZCAwIH0gPSB7fSxcbiAgICAgIGxhYmVsOiB7IHBhcmFsbGVsLCByb3RhdGlvbiwgcG9zaXRpb24gPSBcInRvcFwiLCBwYWRkaW5nID0gMCB9LFxuICAgICAgZGlyZWN0aW9uLFxuICAgICAgcGFyYWxsZWxGbGlwUm90YXRpb24sXG4gICAgICByZWd1bGFyRmxpcFJvdGF0aW9uXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKHggPT09IHZvaWQgMCB8fCB5ID09PSB2b2lkIDApXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBjb25maWd1cmVkUm90YXRpb24gfSA9IGNhbGN1bGF0ZUxhYmVsUm90YXRpb24oe1xuICAgICAgcm90YXRpb24sXG4gICAgICBwYXJhbGxlbCxcbiAgICAgIHJlZ3VsYXJGbGlwUm90YXRpb24sXG4gICAgICBwYXJhbGxlbEZsaXBSb3RhdGlvblxuICAgIH0pO1xuICAgIHRlbXBUZXh0LnJvdGF0aW9uID0gY29uZmlndXJlZFJvdGF0aW9uO1xuICAgIHRlbXBUZXh0LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XG4gICAgdGVtcFRleHQudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICBjb25zdCBiYm94ID0gdGVtcFRleHQuZ2V0QkJveCgpO1xuICAgIGlmICghYmJveClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB5RGlyZWN0aW9uID0gZGlyZWN0aW9uID09PSBcInlcIiAvKiBZICovO1xuICAgIGNvbnN0IHsgeFRyYW5zbGF0aW9uLCB5VHJhbnNsYXRpb24gfSA9IGNhbGN1bGF0ZUxhYmVsVHJhbnNsYXRpb24oe1xuICAgICAgeURpcmVjdGlvbixcbiAgICAgIHBhZGRpbmcsXG4gICAgICBwb3NpdGlvbixcbiAgICAgIGJib3hcbiAgICB9KTtcbiAgICB0ZW1wVGV4dC54ID0geCArIHhUcmFuc2xhdGlvbjtcbiAgICB0ZW1wVGV4dC55ID0geSArIHlUcmFuc2xhdGlvbjtcbiAgICByZXR1cm4gdGVtcFRleHQuZ2V0QkJveCgpO1xuICB9XG4gIGNhbGN1bGF0ZVBhZGRpbmcocGFkZGluZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGlzUmFuZ2UsXG4gICAgICBzdGFydExpbmUsXG4gICAgICBlbmRMaW5lLFxuICAgICAgZGlyZWN0aW9uLFxuICAgICAgbGFiZWw6IHsgcGFkZGluZzogbGFiZWxQYWRkaW5nID0gMCwgcG9zaXRpb24gPSBcInRvcFwiIH1cbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIWlzUmFuZ2UgJiYgIXN0YXJ0TGluZSAmJiAhZW5kTGluZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBjcm9zc0xpbmVMYWJlbEJCb3ggPSB0aGlzLmNvbXB1dGVMYWJlbEJCb3goKTtcbiAgICBpZiAoY3Jvc3NMaW5lTGFiZWxCQm94Py54ID09IG51bGwgfHwgY3Jvc3NMaW5lTGFiZWxCQm94Py55ID09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgY2hhcnRQYWRkaW5nID0gY2FsY3VsYXRlTGFiZWxDaGFydFBhZGRpbmcoe1xuICAgICAgeURpcmVjdGlvbjogZGlyZWN0aW9uID09PSBcInlcIiAvKiBZICovLFxuICAgICAgcGFkZGluZzogbGFiZWxQYWRkaW5nLFxuICAgICAgcG9zaXRpb24sXG4gICAgICBiYm94OiBjcm9zc0xpbmVMYWJlbEJCb3hcbiAgICB9KTtcbiAgICBwYWRkaW5nLmxlZnQgPSBNYXRoLm1heChwYWRkaW5nLmxlZnQgPz8gMCwgY2hhcnRQYWRkaW5nLmxlZnQgPz8gMCk7XG4gICAgcGFkZGluZy5yaWdodCA9IE1hdGgubWF4KHBhZGRpbmcucmlnaHQgPz8gMCwgY2hhcnRQYWRkaW5nLnJpZ2h0ID8/IDApO1xuICAgIHBhZGRpbmcudG9wID0gTWF0aC5tYXgocGFkZGluZy50b3AgPz8gMCwgY2hhcnRQYWRkaW5nLnRvcCA/PyAwKTtcbiAgICBwYWRkaW5nLmJvdHRvbSA9IE1hdGgubWF4KHBhZGRpbmcuYm90dG9tID8/IDAsIGNoYXJ0UGFkZGluZy5ib3R0b20gPz8gMCk7XG4gIH1cbn07XG5fQ2FydGVzaWFuQ3Jvc3NMaW5lLkxJTkVfTEFZRVJfWklOREVYID0gOSAvKiBTRVJJRVNfQ1JPU1NMSU5FX0xJTkUgKi87XG5fQ2FydGVzaWFuQ3Jvc3NMaW5lLlJBTkdFX0xBWUVSX1pJTkRFWCA9IDMgLyogU0VSSUVTX0NST1NTTElORV9SQU5HRSAqLztcbl9DYXJ0ZXNpYW5Dcm9zc0xpbmUuTEFCRUxfTEFZRVJfWklOREVYID0gMTQgLyogU0VSSUVTX0xBQkVMICovO1xuX0NhcnRlc2lhbkNyb3NzTGluZS5jbGFzc05hbWUgPSBcIkNyb3NzTGluZVwiO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgX0NhcnRlc2lhbkNyb3NzTGluZS5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFVOSU9OKFtcInJhbmdlXCIsIFwibGluZVwiXSwgXCJhIGNyb3NzTGluZSB0eXBlXCIpLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBfQ2FydGVzaWFuQ3Jvc3NMaW5lLnByb3RvdHlwZSwgXCJ0eXBlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQU5EKE1BVENISU5HX0NST1NTTElORV9UWVBFKFwicmFuZ2VcIiksIEFSUkFZLnJlc3RyaWN0KHsgbGVuZ3RoOiAyIH0pKSwge1xuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0pXG5dLCBfQ2FydGVzaWFuQ3Jvc3NMaW5lLnByb3RvdHlwZSwgXCJyYW5nZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE1BVENISU5HX0NST1NTTElORV9UWVBFKFwidmFsdWVcIiksIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIF9DYXJ0ZXNpYW5Dcm9zc0xpbmUucHJvdG90eXBlLCBcInZhbHVlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBfQ2FydGVzaWFuQ3Jvc3NMaW5lLnByb3RvdHlwZSwgXCJmaWxsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIF9DYXJ0ZXNpYW5Dcm9zc0xpbmUucHJvdG90eXBlLCBcImZpbGxPcGFjaXR5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBfQ2FydGVzaWFuQ3Jvc3NMaW5lLnByb3RvdHlwZSwgXCJzdHJva2VcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShOVU1CRVIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIF9DYXJ0ZXNpYW5Dcm9zc0xpbmUucHJvdG90eXBlLCBcInN0cm9rZVdpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIF9DYXJ0ZXNpYW5Dcm9zc0xpbmUucHJvdG90eXBlLCBcInN0cm9rZU9wYWNpdHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShMSU5FX0RBU0gsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIF9DYXJ0ZXNpYW5Dcm9zc0xpbmUucHJvdG90eXBlLCBcImxpbmVEYXNoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgX0NhcnRlc2lhbkNyb3NzTGluZS5wcm90b3R5cGUsIFwibGFiZWxcIiwgMik7XG52YXIgQ2FydGVzaWFuQ3Jvc3NMaW5lID0gX0NhcnRlc2lhbkNyb3NzTGluZTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvYXhpcy9heGlzR3JpZExpbmUudHNcbnZhciBHUklEX1NUWUxFX0tFWVMgPSBbXCJzdHJva2VcIiwgXCJsaW5lRGFzaFwiXTtcbnZhciBHUklEX1NUWUxFID0gQVJSQVlfT0YoXG4gICh2YWx1ZSkgPT4gaXNPYmplY3QodmFsdWUpICYmIE9iamVjdC5rZXlzKHZhbHVlKS5ldmVyeSgoa2V5KSA9PiBHUklEX1NUWUxFX0tFWVMuaW5jbHVkZXMoa2V5KSksXG4gIFwib2JqZWN0cyB3aXRoIGdyaWRsaW5lIHN0eWxlIHByb3BlcnRpZXMgc3VjaCBhcyAnc3Ryb2tlJyBvciAnbGluZURhc2gnXCJcbik7XG52YXIgQXhpc0dyaWRMaW5lID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMud2lkdGggPSAxO1xuICAgIHRoaXMuc3R5bGUgPSBbXG4gICAgICB7XG4gICAgICAgIHN0cm9rZTogdm9pZCAwLFxuICAgICAgICBsaW5lRGFzaDogW11cbiAgICAgIH1cbiAgICBdO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIEF4aXNHcmlkTGluZS5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIEF4aXNHcmlkTGluZS5wcm90b3R5cGUsIFwid2lkdGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShHUklEX1NUWUxFKVxuXSwgQXhpc0dyaWRMaW5lLnByb3RvdHlwZSwgXCJzdHlsZVwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9kZWZhdWx0LnRzXG5mdW5jdGlvbiBEZWZhdWx0KGRlZmF1bHRWYWx1ZSwgcmVwbGFjZXMgPSBbdm9pZCAwXSkge1xuICByZXR1cm4gYWRkVHJhbnNmb3JtVG9JbnN0YW5jZVByb3BlcnR5KChfLCBfXywgdikgPT4ge1xuICAgIGlmIChyZXBsYWNlcy5pbmNsdWRlcyh2KSkge1xuICAgICAgcmV0dXJuIGlzRnVuY3Rpb24oZGVmYXVsdFZhbHVlKSA/IGRlZmF1bHRWYWx1ZSh2KSA6IGRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG4gIH0pO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9heGlzL2F4aXNJbnRlcnZhbC50c1xudmFyIFRJQ0tfSU5URVJWQUwgPSBwcmVkaWNhdGVXaXRoTWVzc2FnZShcbiAgKHZhbHVlKSA9PiBpc0Zpbml0ZU51bWJlcih2YWx1ZSkgJiYgdmFsdWUgPiAwIHx8IHZhbHVlIGluc3RhbmNlb2YgVGltZUludGVydmFsLFxuICBgYSBub24temVybyBwb3NpdGl2ZSBOdW1iZXIgdmFsdWUgb3IsIGZvciBhIHRpbWUgYXhpcywgYSBUaW1lIEludGVydmFsIHN1Y2ggYXMgJ2FnQ2hhcnRzLnRpbWUubW9udGgnYFxuKTtcbnZhciBBeGlzSW50ZXJ2YWwgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLm1pblNwYWNpbmcgPSBOYU47XG4gICAgdGhpcy5tYXhTcGFjaW5nID0gTmFOO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoVElDS19JTlRFUlZBTCwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQXhpc0ludGVydmFsLnByb3RvdHlwZSwgXCJzdGVwXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQVJSQVksIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEF4aXNJbnRlcnZhbC5wcm90b3R5cGUsIFwidmFsdWVzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTUlOX1NQQUNJTkcpLFxuICBEZWZhdWx0KE5hTilcbl0sIEF4aXNJbnRlcnZhbC5wcm90b3R5cGUsIFwibWluU3BhY2luZ1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE1BWF9TUEFDSU5HKSxcbiAgRGVmYXVsdChOYU4pXG5dLCBBeGlzSW50ZXJ2YWwucHJvdG90eXBlLCBcIm1heFNwYWNpbmdcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2F4aXMvYXhpc0xhYmVsLnRzXG52YXIgQXhpc0xhYmVsID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLmZvbnRTaXplID0gMTI7XG4gICAgdGhpcy5mb250RmFtaWx5ID0gXCJWZXJkYW5hLCBzYW5zLXNlcmlmXCI7XG4gICAgdGhpcy5wYWRkaW5nID0gNTtcbiAgICB0aGlzLm1pblNwYWNpbmcgPSBOYU47XG4gICAgdGhpcy5jb2xvciA9IFwiIzU3NTc1N1wiO1xuICAgIHRoaXMuYXZvaWRDb2xsaXNpb25zID0gdHJ1ZTtcbiAgICB0aGlzLm1pcnJvcmVkID0gZmFsc2U7XG4gICAgdGhpcy5wYXJhbGxlbCA9IGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgc2lkZSBvZiB0aGUgYXhpcyBsaW5lIHRvIHBvc2l0aW9uIHRoZSBsYWJlbHMgb24uXG4gICAqIC0xID0gbGVmdCAoZGVmYXVsdClcbiAgICogMSA9IHJpZ2h0XG4gICAqL1xuICBnZXRTaWRlRmxhZygpIHtcbiAgICByZXR1cm4gdGhpcy5taXJyb3JlZCA/IDEgOiAtMTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBBeGlzTGFiZWwucHJvdG90eXBlLCBcImVuYWJsZWRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGT05UX1NUWUxFLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBBeGlzTGFiZWwucHJvdG90eXBlLCBcImZvbnRTdHlsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZPTlRfV0VJR0hULCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBBeGlzTGFiZWwucHJvdG90eXBlLCBcImZvbnRXZWlnaHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShOVU1CRVIucmVzdHJpY3QoeyBtaW46IDEgfSkpXG5dLCBBeGlzTGFiZWwucHJvdG90eXBlLCBcImZvbnRTaXplXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HKVxuXSwgQXhpc0xhYmVsLnByb3RvdHlwZSwgXCJmb250RmFtaWx5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgQXhpc0xhYmVsLnByb3RvdHlwZSwgXCJwYWRkaW5nXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTlVNQkVSX09SX05BTiksXG4gIERlZmF1bHQoTmFOKVxuXSwgQXhpc0xhYmVsLnByb3RvdHlwZSwgXCJtaW5TcGFjaW5nXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBBeGlzTGFiZWwucHJvdG90eXBlLCBcImNvbG9yXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoREVHUkVFLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBBeGlzTGFiZWwucHJvdG90eXBlLCBcInJvdGF0aW9uXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIEF4aXNMYWJlbC5wcm90b3R5cGUsIFwiYXZvaWRDb2xsaXNpb25zXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIEF4aXNMYWJlbC5wcm90b3R5cGUsIFwibWlycm9yZWRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgQXhpc0xhYmVsLnByb3RvdHlwZSwgXCJwYXJhbGxlbFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZVTkNUSU9OLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBBeGlzTGFiZWwucHJvdG90eXBlLCBcImZvcm1hdHRlclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQXhpc0xhYmVsLnByb3RvdHlwZSwgXCJmb3JtYXRcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2F4aXMvYXhpc0xpbmUudHNcbnZhciBBeGlzTGluZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLndpZHRoID0gMTtcbiAgICB0aGlzLnN0cm9rZSA9IHZvaWQgMDtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBBeGlzTGluZS5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIEF4aXNMaW5lLnByb3RvdHlwZSwgXCJ3aWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQXhpc0xpbmUucHJvdG90eXBlLCBcInN0cm9rZVwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvYXhpcy9heGlzVGljay50c1xudmFyIEF4aXNUaWNrID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLndpZHRoID0gMTtcbiAgICB0aGlzLnNpemUgPSA2O1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIEF4aXNUaWNrLnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgQXhpc1RpY2sucHJvdG90eXBlLCBcIndpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgQXhpc1RpY2sucHJvdG90eXBlLCBcInNpemVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEF4aXNUaWNrLnByb3RvdHlwZSwgXCJzdHJva2VcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2F4aXMvYXhpc1RpdGxlLnRzXG52YXIgQXhpc1RpdGxlID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5jYXB0aW9uID0gbmV3IENhcHRpb24oKTtcbiAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLnNwYWNpbmcgPSBDYXB0aW9uLlNNQUxMX1BBRERJTkc7XG4gICAgdGhpcy5mb250U2l6ZSA9IDEwO1xuICAgIHRoaXMuZm9udEZhbWlseSA9IFwic2Fucy1zZXJpZlwiO1xuICAgIHRoaXMud3JhcHBpbmcgPSBcImFsd2F5c1wiO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIEF4aXNUaXRsZS5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQXhpc1RpdGxlLnByb3RvdHlwZSwgXCJ0ZXh0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBBeGlzVGl0bGUucHJvdG90eXBlLCBcInNwYWNpbmdcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGT05UX1NUWUxFLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBBeGlzVGl0bGUucHJvdG90eXBlLCBcImZvbnRTdHlsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZPTlRfV0VJR0hULCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBBeGlzVGl0bGUucHJvdG90eXBlLCBcImZvbnRXZWlnaHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBBeGlzVGl0bGUucHJvdG90eXBlLCBcImZvbnRTaXplXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HKVxuXSwgQXhpc1RpdGxlLnByb3RvdHlwZSwgXCJmb250RmFtaWx5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBBeGlzVGl0bGUucHJvdG90eXBlLCBcImNvbG9yXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoVEVYVF9XUkFQKVxuXSwgQXhpc1RpdGxlLnByb3RvdHlwZSwgXCJ3cmFwcGluZ1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZVTkNUSU9OLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBBeGlzVGl0bGUucHJvdG90eXBlLCBcImZvcm1hdHRlclwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvYXhpcy9heGlzVXRpbC50c1xuZnVuY3Rpb24gcHJlcGFyZUF4aXNBbmltYXRpb25Db250ZXh0KGF4aXMpIHtcbiAgY29uc3QgW3JlcXVlc3RlZFJhbmdlTWluLCByZXF1ZXN0ZWRSYW5nZU1heF0gPSBmaW5kTWluTWF4KGF4aXMucmFuZ2UpO1xuICBjb25zdCBtaW4gPSBNYXRoLmZsb29yKHJlcXVlc3RlZFJhbmdlTWluKTtcbiAgY29uc3QgbWF4ID0gTWF0aC5jZWlsKHJlcXVlc3RlZFJhbmdlTWF4KTtcbiAgcmV0dXJuIHsgbWluLCBtYXgsIHZpc2libGU6IG1pbiAhPT0gbWF4IH07XG59XG52YXIgZnVsbENpcmNsZSA9IE1hdGguUEkgKiAyO1xudmFyIGhhbGZDaXJjbGUgPSBmdWxsQ2lyY2xlIC8gMjtcbmZ1bmN0aW9uIG5vcm1hbGlzZUVuZFJvdGF0aW9uKHN0YXJ0MiwgZW5kMikge1xuICBjb25zdCBkaXJlY3REaXN0YW5jZSA9IE1hdGguYWJzKGVuZDIgLSBzdGFydDIpO1xuICBpZiAoZGlyZWN0RGlzdGFuY2UgPCBoYWxmQ2lyY2xlKSB7XG4gICAgcmV0dXJuIGVuZDI7XG4gIH0gZWxzZSBpZiAoc3RhcnQyID4gZW5kMikge1xuICAgIHJldHVybiBlbmQyICsgZnVsbENpcmNsZTtcbiAgfVxuICByZXR1cm4gZW5kMiAtIGZ1bGxDaXJjbGU7XG59XG5mdW5jdGlvbiBwcmVwYXJlQXhpc0FuaW1hdGlvbkZ1bmN0aW9ucyhjdHgpIHtcbiAgY29uc3Qgb3V0T2ZCb3VuZHMgPSAoeSwgcmFuZ2UzKSA9PiB7XG4gICAgY29uc3QgW21pbiA9IGN0eC5taW4sIG1heCA9IGN0eC5tYXhdID0gZmluZE1pbk1heChyYW5nZTMgPz8gW10pO1xuICAgIHJldHVybiB5IDwgbWluIHx8IHkgPiBtYXg7XG4gIH07XG4gIGNvbnN0IHRpY2sgPSB7XG4gICAgZnJvbUZuKG5vZGUsIGRhdHVtLCBzdGF0dXMpIHtcbiAgICAgIGxldCB5ID0gbm9kZS55MSArIG5vZGUudHJhbnNsYXRpb25ZO1xuICAgICAgbGV0IG9wYWNpdHkgPSBub2RlLm9wYWNpdHk7XG4gICAgICBpZiAoc3RhdHVzID09PSBcImFkZGVkXCIgfHwgb3V0T2ZCb3VuZHMobm9kZS5kYXR1bS50cmFuc2xhdGlvblksIG5vZGUuZGF0dW0ucmFuZ2UpKSB7XG4gICAgICAgIHkgPSBkYXR1bS50cmFuc2xhdGlvblk7XG4gICAgICAgIG9wYWNpdHkgPSAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgeTogMCwgdHJhbnNsYXRpb25ZOiB5LCBvcGFjaXR5LCBwaGFzZTogTk9ERV9VUERBVEVfU1RBVEVfVE9fUEhBU0VfTUFQUElOR1tzdGF0dXNdIH07XG4gICAgfSxcbiAgICB0b0ZuKF9ub2RlLCBkYXR1bSwgc3RhdHVzKSB7XG4gICAgICBjb25zdCB5ID0gZGF0dW0udHJhbnNsYXRpb25ZO1xuICAgICAgbGV0IG9wYWNpdHkgPSAxO1xuICAgICAgaWYgKHN0YXR1cyA9PT0gXCJyZW1vdmVkXCIpIHtcbiAgICAgICAgb3BhY2l0eSA9IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB5OiAwLFxuICAgICAgICB0cmFuc2xhdGlvblk6IHksXG4gICAgICAgIG9wYWNpdHksXG4gICAgICAgIGZpbmlzaDoge1xuICAgICAgICAgIC8vIFNldCBleHBsaWNpdCB5IGFmdGVyIGFuaW1hdGlvbiBzbyBpdCdzIHBpeGVsIGFsaWduZWRcbiAgICAgICAgICB5LFxuICAgICAgICAgIHRyYW5zbGF0aW9uWTogMFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgYXBwbHlGbihub2RlLCBwcm9wcykge1xuICAgICAgbm9kZS5zZXRQcm9wZXJ0aWVzKHByb3BzKTtcbiAgICAgIG5vZGUudmlzaWJsZSA9ICFvdXRPZkJvdW5kcyhub2RlLnkpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgbGFiZWwgPSB7XG4gICAgZnJvbUZuKG5vZGUsIG5ld0RhdHVtLCBzdGF0dXMpIHtcbiAgICAgIGNvbnN0IGRhdHVtID0gbm9kZS5wcmV2aW91c0RhdHVtID8/IG5ld0RhdHVtO1xuICAgICAgY29uc3QgeCA9IGRhdHVtLng7XG4gICAgICBjb25zdCB5ID0gZGF0dW0ueTtcbiAgICAgIGNvbnN0IHJvdGF0aW9uQ2VudGVyWCA9IGRhdHVtLnJvdGF0aW9uQ2VudGVyWDtcbiAgICAgIGxldCB0cmFuc2xhdGlvblkgPSBNYXRoLnJvdW5kKG5vZGUudHJhbnNsYXRpb25ZKTtcbiAgICAgIGxldCByb3RhdGlvbiA9IGRhdHVtLnJvdGF0aW9uO1xuICAgICAgbGV0IG9wYWNpdHkgPSBub2RlLm9wYWNpdHk7XG4gICAgICBpZiAoc3RhdHVzID09PSBcInJlbW92ZWRcIiB8fCBvdXRPZkJvdW5kcyhkYXR1bS55LCBkYXR1bS5yYW5nZSkpIHtcbiAgICAgICAgcm90YXRpb24gPSBuZXdEYXR1bS5yb3RhdGlvbjtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdHVzID09PSBcImFkZGVkXCIgfHwgb3V0T2ZCb3VuZHMobm9kZS5kYXR1bS55LCBub2RlLmRhdHVtLnJhbmdlKSkge1xuICAgICAgICB0cmFuc2xhdGlvblkgPSBNYXRoLnJvdW5kKGRhdHVtLnRyYW5zbGF0aW9uWSk7XG4gICAgICAgIG9wYWNpdHkgPSAwO1xuICAgICAgICByb3RhdGlvbiA9IG5ld0RhdHVtLnJvdGF0aW9uO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgcm90YXRpb25DZW50ZXJYLFxuICAgICAgICB0cmFuc2xhdGlvblksXG4gICAgICAgIHJvdGF0aW9uLFxuICAgICAgICBvcGFjaXR5LFxuICAgICAgICBwaGFzZTogTk9ERV9VUERBVEVfU1RBVEVfVE9fUEhBU0VfTUFQUElOR1tzdGF0dXNdXG4gICAgICB9O1xuICAgIH0sXG4gICAgdG9Gbihub2RlLCBkYXR1bSwgc3RhdHVzKSB7XG4gICAgICBjb25zdCB4ID0gZGF0dW0ueDtcbiAgICAgIGNvbnN0IHkgPSBkYXR1bS55O1xuICAgICAgY29uc3Qgcm90YXRpb25DZW50ZXJYID0gZGF0dW0ucm90YXRpb25DZW50ZXJYO1xuICAgICAgY29uc3QgdHJhbnNsYXRpb25ZID0gTWF0aC5yb3VuZChkYXR1bS50cmFuc2xhdGlvblkpO1xuICAgICAgbGV0IHJvdGF0aW9uID0gMDtcbiAgICAgIGxldCBvcGFjaXR5ID0gMTtcbiAgICAgIGlmIChzdGF0dXMgPT09IFwiYWRkZWRcIikge1xuICAgICAgICBvcGFjaXR5ID0gMTtcbiAgICAgICAgcm90YXRpb24gPSBkYXR1bS5yb3RhdGlvbjtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdHVzID09PSBcInJlbW92ZWRcIikge1xuICAgICAgICBvcGFjaXR5ID0gMDtcbiAgICAgICAgcm90YXRpb24gPSBkYXR1bS5yb3RhdGlvbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvdGF0aW9uID0gbm9ybWFsaXNlRW5kUm90YXRpb24obm9kZS5wcmV2aW91c0RhdHVtPy5yb3RhdGlvbiA/PyBkYXR1bS5yb3RhdGlvbiwgZGF0dW0ucm90YXRpb24pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgeCwgeSwgcm90YXRpb25DZW50ZXJYLCB0cmFuc2xhdGlvblksIHJvdGF0aW9uLCBvcGFjaXR5LCBmaW5pc2g6IHsgcm90YXRpb246IGRhdHVtLnJvdGF0aW9uIH0gfTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGxpbmUgPSB7XG4gICAgZnJvbUZuKG5vZGUsIGRhdHVtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5ub2RlLnByZXZpb3VzRGF0dW0gPz8gZGF0dW0sXG4gICAgICAgIHBoYXNlOiBOT0RFX1VQREFURV9TVEFURV9UT19QSEFTRV9NQVBQSU5HW1widXBkYXRlZFwiXVxuICAgICAgfTtcbiAgICB9LFxuICAgIHRvRm4oX25vZGUsIGRhdHVtKSB7XG4gICAgICByZXR1cm4geyAuLi5kYXR1bSB9O1xuICAgIH1cbiAgfTtcbiAgY29uc3QgZ3JvdXAgPSB7XG4gICAgZnJvbUZuKG5vZGUsIF9kYXR1bSkge1xuICAgICAgY29uc3QgeyByb3RhdGlvbiwgdHJhbnNsYXRpb25YLCB0cmFuc2xhdGlvblkgfSA9IG5vZGU7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByb3RhdGlvbixcbiAgICAgICAgdHJhbnNsYXRpb25YLFxuICAgICAgICB0cmFuc2xhdGlvblksXG4gICAgICAgIHBoYXNlOiBOT0RFX1VQREFURV9TVEFURV9UT19QSEFTRV9NQVBQSU5HW1widXBkYXRlZFwiXVxuICAgICAgfTtcbiAgICB9LFxuICAgIHRvRm4oX25vZGUsIGRhdHVtKSB7XG4gICAgICBjb25zdCB7IHJvdGF0aW9uLCB0cmFuc2xhdGlvblgsIHRyYW5zbGF0aW9uWSB9ID0gZGF0dW07XG4gICAgICByZXR1cm4ge1xuICAgICAgICByb3RhdGlvbixcbiAgICAgICAgdHJhbnNsYXRpb25YLFxuICAgICAgICB0cmFuc2xhdGlvbllcbiAgICAgIH07XG4gICAgfVxuICB9O1xuICByZXR1cm4geyB0aWNrLCBsaW5lLCBsYWJlbCwgZ3JvdXAgfTtcbn1cbmZ1bmN0aW9uIHJlc2V0QXhpc0dyb3VwRm4oKSB7XG4gIHJldHVybiAoX25vZGUsIGRhdHVtKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvdGF0aW9uOiBkYXR1bS5yb3RhdGlvbixcbiAgICAgIHJvdGF0aW9uQ2VudGVyWDogZGF0dW0ucm90YXRpb25DZW50ZXJYLFxuICAgICAgcm90YXRpb25DZW50ZXJZOiBkYXR1bS5yb3RhdGlvbkNlbnRlclksXG4gICAgICB0cmFuc2xhdGlvblg6IGRhdHVtLnRyYW5zbGF0aW9uWCxcbiAgICAgIHRyYW5zbGF0aW9uWTogZGF0dW0udHJhbnNsYXRpb25ZXG4gICAgfTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlc2V0QXhpc1NlbGVjdGlvbkZuKGN0eCkge1xuICBjb25zdCB7IHZpc2libGU6IHJhbmdlVmlzaWJsZSwgbWluLCBtYXggfSA9IGN0eDtcbiAgcmV0dXJuIChfbm9kZSwgZGF0dW0pID0+IHtcbiAgICBjb25zdCB5ID0gZGF0dW0udHJhbnNsYXRpb25ZO1xuICAgIGNvbnN0IHZpc2libGUgPSByYW5nZVZpc2libGUgJiYgeSA+PSBtaW4gJiYgeSA8PSBtYXg7XG4gICAgcmV0dXJuIHtcbiAgICAgIHksXG4gICAgICB0cmFuc2xhdGlvblk6IDAsXG4gICAgICBvcGFjaXR5OiAxLFxuICAgICAgdmlzaWJsZVxuICAgIH07XG4gIH07XG59XG5mdW5jdGlvbiByZXNldEF4aXNMYWJlbFNlbGVjdGlvbkZuKCkge1xuICByZXR1cm4gKF9ub2RlLCBkYXR1bSkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICB4OiBkYXR1bS54LFxuICAgICAgeTogZGF0dW0ueSxcbiAgICAgIHRyYW5zbGF0aW9uWTogZGF0dW0udHJhbnNsYXRpb25ZLFxuICAgICAgcm90YXRpb246IGRhdHVtLnJvdGF0aW9uLFxuICAgICAgcm90YXRpb25DZW50ZXJYOiBkYXR1bS5yb3RhdGlvbkNlbnRlclhcbiAgICB9O1xuICB9O1xufVxuZnVuY3Rpb24gcmVzZXRBeGlzTGluZVNlbGVjdGlvbkZuKCkge1xuICByZXR1cm4gKF9ub2RlLCBkYXR1bSkgPT4ge1xuICAgIHJldHVybiB7IC4uLmRhdHVtIH07XG4gIH07XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2F4aXMvYXhpcy50c1xudmFyIFRyYW5zbGF0YWJsZUxpbmUgPSBjbGFzcyBleHRlbmRzIFRyYW5zbGF0YWJsZShMaW5lKSB7XG59O1xudmFyIF9BeGlzID0gY2xhc3MgX0F4aXMge1xuICBjb25zdHJ1Y3Rvcihtb2R1bGVDdHgsIHNjYWxlMikge1xuICAgIHRoaXMubW9kdWxlQ3R4ID0gbW9kdWxlQ3R4O1xuICAgIHRoaXMuc2NhbGUgPSBzY2FsZTI7XG4gICAgdGhpcy5pZCA9IGNyZWF0ZUlkKHRoaXMpO1xuICAgIHRoaXMubmljZSA9IHRydWU7XG4gICAgdGhpcy5yZXZlcnNlID0gZmFsc2U7XG4gICAgdGhpcy5rZXlzID0gW107XG4gICAgdGhpcy5pbnRlcnZhbCA9IG5ldyBBeGlzSW50ZXJ2YWwoKTtcbiAgICB0aGlzLmRhdGFEb21haW4gPSB7IGRvbWFpbjogW10sIGNsaXBwZWQ6IGZhbHNlIH07XG4gICAgdGhpcy5sYXlvdXRDb25zdHJhaW50cyA9IHtcbiAgICAgIHN0YWNrZWQ6IHRydWUsXG4gICAgICBhbGlnbjogXCJzdGFydFwiLFxuICAgICAgd2lkdGg6IDEwMCxcbiAgICAgIHVuaXQ6IFwicGVyY2VudFwiXG4gICAgfTtcbiAgICB0aGlzLmJvdW5kU2VyaWVzID0gW107XG4gICAgdGhpcy5pbmNsdWRlSW52aXNpYmxlRG9tYWlucyA9IGZhbHNlO1xuICAgIHRoaXMuaW50ZXJhY3Rpb25FbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLmF4aXNHcm91cCA9IG5ldyBUcmFuc2Zvcm1hYmxlR3JvdXAoeyBuYW1lOiBgJHt0aGlzLmlkfS1heGlzYCwgekluZGV4OiAyIC8qIEFYSVMgKi8gfSk7XG4gICAgdGhpcy5saW5lTm9kZSA9IHRoaXMuYXhpc0dyb3VwLmFwcGVuZENoaWxkKG5ldyBUcmFuc2xhdGFibGVMaW5lKHsgbmFtZTogYCR7dGhpcy5pZH0tQXhpcy1saW5lYCB9KSk7XG4gICAgdGhpcy50aWNrTGluZUdyb3VwID0gdGhpcy5heGlzR3JvdXAuYXBwZW5kQ2hpbGQoXG4gICAgICBuZXcgR3JvdXAoeyBuYW1lOiBgJHt0aGlzLmlkfS1BeGlzLXRpY2stbGluZXNgLCB6SW5kZXg6IDIgLyogQVhJUyAqLyB9KVxuICAgICk7XG4gICAgdGhpcy50aWNrTGFiZWxHcm91cCA9IHRoaXMuYXhpc0dyb3VwLmFwcGVuZENoaWxkKFxuICAgICAgbmV3IEdyb3VwKHsgbmFtZTogYCR7dGhpcy5pZH0tQXhpcy10aWNrLWxhYmVsc2AsIHpJbmRleDogMiAvKiBBWElTICovIH0pXG4gICAgKTtcbiAgICB0aGlzLmNyb3NzTGluZUdyb3VwID0gbmV3IFRyYW5zZm9ybWFibGVHcm91cCh7IG5hbWU6IGAke3RoaXMuaWR9LUNyb3NzTGluZXNgIH0pO1xuICAgIHRoaXMubGFiZWxHcm91cCA9IG5ldyBHcm91cCh7IG5hbWU6IGAke3RoaXMuaWR9LUxhYmVsc2AsIHpJbmRleDogMTAgLyogU0VSSUVTX0FOTk9UQVRJT04gKi8gfSk7XG4gICAgdGhpcy5ncmlkR3JvdXAgPSBuZXcgVHJhbnNmb3JtYWJsZUdyb3VwKHsgbmFtZTogYCR7dGhpcy5pZH0tQXhpcy1ncmlkYCB9KTtcbiAgICB0aGlzLmdyaWRMaW5lR3JvdXAgPSB0aGlzLmdyaWRHcm91cC5hcHBlbmRDaGlsZChcbiAgICAgIG5ldyBHcm91cCh7XG4gICAgICAgIG5hbWU6IGAke3RoaXMuaWR9LWdyaWRMaW5lc2AsXG4gICAgICAgIHpJbmRleDogMSAvKiBBWElTX0dSSUQgKi9cbiAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzLnRpY2tMaW5lR3JvdXBTZWxlY3Rpb24gPSBTZWxlY3Rpb24uc2VsZWN0KHRoaXMudGlja0xpbmVHcm91cCwgVHJhbnNsYXRhYmxlTGluZSwgZmFsc2UpO1xuICAgIHRoaXMudGlja0xhYmVsR3JvdXBTZWxlY3Rpb24gPSBTZWxlY3Rpb24uc2VsZWN0KFxuICAgICAgdGhpcy50aWNrTGFiZWxHcm91cCxcbiAgICAgIFRyYW5zZm9ybWFibGVUZXh0LFxuICAgICAgZmFsc2VcbiAgICApO1xuICAgIHRoaXMuZ3JpZExpbmVHcm91cFNlbGVjdGlvbiA9IFNlbGVjdGlvbi5zZWxlY3QodGhpcy5ncmlkTGluZUdyb3VwLCBUcmFuc2xhdGFibGVMaW5lLCBmYWxzZSk7XG4gICAgdGhpcy5fY3Jvc3NMaW5lcyA9IFtdO1xuICAgIHRoaXMubGluZSA9IG5ldyBBeGlzTGluZSgpO1xuICAgIHRoaXMudGljayA9IG5ldyBBeGlzVGljaygpO1xuICAgIHRoaXMuZ3JpZExpbmUgPSBuZXcgQXhpc0dyaWRMaW5lKCk7XG4gICAgdGhpcy5sYWJlbCA9IHRoaXMuY3JlYXRlTGFiZWwoKTtcbiAgICB0aGlzLmRlZmF1bHRUaWNrTWluU3BhY2luZyA9IF9BeGlzLmRlZmF1bHRUaWNrTWluU3BhY2luZztcbiAgICB0aGlzLnRyYW5zbGF0aW9uID0geyB4OiAwLCB5OiAwIH07XG4gICAgdGhpcy5yb3RhdGlvbiA9IDA7XG4gICAgLy8gYXhpcyByb3RhdGlvbiBhbmdsZSBpbiBkZWdyZWVzXG4gICAgdGhpcy5sYXlvdXQgPSB7XG4gICAgICBsYWJlbDoge1xuICAgICAgICBmcmFjdGlvbkRpZ2l0czogMCxcbiAgICAgICAgcGFkZGluZzogdGhpcy5sYWJlbC5wYWRkaW5nLFxuICAgICAgICBmb3JtYXQ6IHRoaXMubGFiZWwuZm9ybWF0XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMgPSBbXTtcbiAgICB0aGlzLnJhbmdlID0gWzAsIDFdO1xuICAgIHRoaXMudmlzaWJsZVJhbmdlID0gWzAsIDFdO1xuICAgIHRoaXMudGl0bGUgPSBuZXcgQXhpc1RpdGxlKCk7XG4gICAgdGhpcy5ncmlkTGVuZ3RoID0gMDtcbiAgICAvKipcbiAgICAgKiBUaGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgZ3JpZCB0aWNrcyBhbmQgdGhlIGF4aXMgdGlja3MuXG4gICAgICovXG4gICAgdGhpcy5ncmlkUGFkZGluZyA9IDA7XG4gICAgLyoqXG4gICAgICogSXMgdXNlZCB0byBhdm9pZCBjb2xsaXNpb25zIGJldHdlZW4gYXhpcyBsYWJlbHMgYW5kIHNlcmllcy5cbiAgICAgKi9cbiAgICB0aGlzLnNlcmllc0FyZWFQYWRkaW5nID0gMDtcbiAgICB0aGlzLnRpY2tHZW5lcmF0aW9uUmVzdWx0ID0gdm9pZCAwO1xuICAgIHRoaXMubW9kdWxlTWFwID0gbmV3IE1vZHVsZU1hcCgpO1xuICAgIHRoaXMucmFuZ2UgPSB0aGlzLnNjYWxlLnJhbmdlLnNsaWNlKCk7XG4gICAgdGhpcy5jcm9zc0xpbmVzLmZvckVhY2goKGNyb3NzTGluZSkgPT4gdGhpcy5pbml0Q3Jvc3NMaW5lKGNyb3NzTGluZSkpO1xuICAgIHRoaXMuYXhpc0dyb3VwLmFwcGVuZENoaWxkKHRoaXMudGl0bGUuY2FwdGlvbi5ub2RlKTtcbiAgICB0aGlzLmFuaW1hdGlvbk1hbmFnZXIgPSBtb2R1bGVDdHguYW5pbWF0aW9uTWFuYWdlcjtcbiAgICB0aGlzLmFuaW1hdGlvblN0YXRlID0gbmV3IFN0YXRlTWFjaGluZShcImVtcHR5XCIsIHtcbiAgICAgIGVtcHR5OiB7XG4gICAgICAgIHVwZGF0ZToge1xuICAgICAgICAgIHRhcmdldDogXCJyZWFkeVwiLFxuICAgICAgICAgIGFjdGlvbjogKCkgPT4gdGhpcy5yZXNldFNlbGVjdGlvbk5vZGVzKClcbiAgICAgICAgfSxcbiAgICAgICAgcmVzZXQ6IFwiZW1wdHlcIlxuICAgICAgfSxcbiAgICAgIHJlYWR5OiB7XG4gICAgICAgIHVwZGF0ZTogKGRhdGEpID0+IHRoaXMuYW5pbWF0ZVJlYWR5VXBkYXRlKGRhdGEpLFxuICAgICAgICByZXNpemU6ICgpID0+IHRoaXMucmVzZXRTZWxlY3Rpb25Ob2RlcygpLFxuICAgICAgICByZXNldDogXCJlbXB0eVwiXG4gICAgICB9XG4gICAgfSk7XG4gICAgbGV0IHByZXZpb3VzU2l6ZSA9IHZvaWQgMDtcbiAgICB0aGlzLmRlc3Ryb3lGbnMucHVzaChcbiAgICAgIHRoaXMudGl0bGUuY2FwdGlvbi5yZWdpc3RlckludGVyYWN0aW9uKHRoaXMubW9kdWxlQ3R4LCBcImFmdGVyZW5kXCIpLFxuICAgICAgbW9kdWxlQ3R4LmxheW91dE1hbmFnZXIuYWRkTGlzdGVuZXIoXCJsYXlvdXQ6Y29tcGxldGVcIiwgKGUpID0+IHtcbiAgICAgICAgaWYgKHByZXZpb3VzU2l6ZSAhPSBudWxsICYmIGpzb25EaWZmKGUuY2hhcnQsIHByZXZpb3VzU2l6ZSkgIT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcInJlc2l6ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91c1NpemUgPSB7IC4uLmUuY2hhcnQgfTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50eXBlID8/IFwiXCI7XG4gIH1cbiAgc2V0IGNyb3NzTGluZXModmFsdWUpIHtcbiAgICBjb25zdCB7IENyb3NzTGluZUNvbnN0cnVjdG9yIH0gPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgIHRoaXMuX2Nyb3NzTGluZXMuZm9yRWFjaCgoY3Jvc3NMaW5lKSA9PiB0aGlzLmRldGFjaENyb3NzTGluZShjcm9zc0xpbmUpKTtcbiAgICB0aGlzLl9jcm9zc0xpbmVzID0gdmFsdWUubWFwKChjcm9zc0xpbmUpID0+IHtcbiAgICAgIGNvbnN0IGluc3RhbmNlID0gbmV3IENyb3NzTGluZUNvbnN0cnVjdG9yKCk7XG4gICAgICBpbnN0YW5jZS5zZXQoY3Jvc3NMaW5lKTtcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9KTtcbiAgICB0aGlzLl9jcm9zc0xpbmVzLmZvckVhY2goKGNyb3NzTGluZSkgPT4ge1xuICAgICAgdGhpcy5hdHRhY2hDcm9zc0xpbmUoY3Jvc3NMaW5lKTtcbiAgICAgIHRoaXMuaW5pdENyb3NzTGluZShjcm9zc0xpbmUpO1xuICAgIH0pO1xuICB9XG4gIGdldCBjcm9zc0xpbmVzKCkge1xuICAgIHJldHVybiB0aGlzLl9jcm9zc0xpbmVzO1xuICB9XG4gIHJlc2V0QW5pbWF0aW9uKHBoYXNlKSB7XG4gICAgaWYgKHBoYXNlID09PSBcImluaXRpYWxcIikge1xuICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwicmVzZXRcIik7XG4gICAgfVxuICB9XG4gIGF0dGFjaENyb3NzTGluZShjcm9zc0xpbmUpIHtcbiAgICB0aGlzLmNyb3NzTGluZUdyb3VwLmFwcGVuZENoaWxkKGNyb3NzTGluZS5ncm91cCk7XG4gICAgdGhpcy5jcm9zc0xpbmVHcm91cC5hcHBlbmRDaGlsZChjcm9zc0xpbmUubGFiZWxHcm91cCk7XG4gIH1cbiAgZGV0YWNoQ3Jvc3NMaW5lKGNyb3NzTGluZSkge1xuICAgIHRoaXMuY3Jvc3NMaW5lR3JvdXAucmVtb3ZlQ2hpbGQoY3Jvc3NMaW5lLmdyb3VwKTtcbiAgICB0aGlzLmNyb3NzTGluZUdyb3VwLnJlbW92ZUNoaWxkKGNyb3NzTGluZS5sYWJlbEdyb3VwKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMubW9kdWxlTWFwLmRlc3Ryb3koKTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMuZm9yRWFjaCgoZikgPT4gZigpKTtcbiAgfVxuICB1cGRhdGVSYW5nZSgpIHtcbiAgICBjb25zdCB7IHJhbmdlOiByciwgdmlzaWJsZVJhbmdlOiB2ciwgc2NhbGU6IHNjYWxlMiB9ID0gdGhpcztcbiAgICBjb25zdCBzcGFuID0gKHJyWzFdIC0gcnJbMF0pIC8gKHZyWzFdIC0gdnJbMF0pO1xuICAgIGNvbnN0IHNoaWZ0ID0gc3BhbiAqIHZyWzBdO1xuICAgIGNvbnN0IHN0YXJ0MiA9IHJyWzBdIC0gc2hpZnQ7XG4gICAgc2NhbGUyLnNldFZpc2libGVSYW5nZT8uKHZyKTtcbiAgICBzY2FsZTIucmFuZ2UgPSBbc3RhcnQyLCBzdGFydDIgKyBzcGFuXTtcbiAgICB0aGlzLmNyb3NzTGluZXMuZm9yRWFjaCgoY3Jvc3NMaW5lKSA9PiB7XG4gICAgICBjcm9zc0xpbmUuY2xpcHBlZFJhbmdlID0gW3JyWzBdLCByclsxXV07XG4gICAgfSk7XG4gIH1cbiAgc2V0Q3Jvc3NMaW5lc1Zpc2libGUodmlzaWJsZSkge1xuICAgIHRoaXMuY3Jvc3NMaW5lR3JvdXAudmlzaWJsZSA9IHZpc2libGU7XG4gIH1cbiAgYXR0YWNoQXhpcyhheGlzTm9kZSwgZ3JpZE5vZGUpIHtcbiAgICBncmlkTm9kZS5hcHBlbmRDaGlsZCh0aGlzLmdyaWRHcm91cCk7XG4gICAgYXhpc05vZGUuYXBwZW5kQ2hpbGQodGhpcy5heGlzR3JvdXApO1xuICAgIGF4aXNOb2RlLmFwcGVuZENoaWxkKHRoaXMuY3Jvc3NMaW5lR3JvdXApO1xuICAgIGF4aXNOb2RlLmFwcGVuZENoaWxkKHRoaXMubGFiZWxHcm91cCk7XG4gIH1cbiAgYXR0YWNoTGFiZWwoYXhpc0xhYmVsTm9kZSkge1xuICAgIHRoaXMubGFiZWxHcm91cC5hcHBlbmQoYXhpc0xhYmVsTm9kZSk7XG4gIH1cbiAgZGV0YWNoQXhpcyhheGlzTm9kZSwgZ3JpZE5vZGUpIHtcbiAgICBncmlkTm9kZS5yZW1vdmVDaGlsZCh0aGlzLmdyaWRHcm91cCk7XG4gICAgYXhpc05vZGUucmVtb3ZlQ2hpbGQodGhpcy5heGlzR3JvdXApO1xuICAgIGF4aXNOb2RlLnJlbW92ZUNoaWxkKHRoaXMuY3Jvc3NMaW5lR3JvdXApO1xuICAgIGF4aXNOb2RlLnJlbW92ZUNoaWxkKHRoaXMubGFiZWxHcm91cCk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhIHBvaW50IG9yIGFuIG9iamVjdCBpcyBpbiByYW5nZS5cbiAgICogQHBhcmFtIHggQSBwb2ludCAob3Igb2JqZWN0J3Mgc3RhcnRpbmcgcG9pbnQpLlxuICAgKiBAcGFyYW0gdG9sZXJhbmNlIEV4cGFuZHMgdGhlIHJhbmdlIG9uIGJvdGggZW5kcyBieSB0aGlzIGFtb3VudC5cbiAgICovXG4gIGluUmFuZ2UoeCwgdG9sZXJhbmNlID0gMCkge1xuICAgIGNvbnN0IFttaW4sIG1heF0gPSBmaW5kTWluTWF4KHRoaXMucmFuZ2UpO1xuICAgIHJldHVybiB4ID49IG1pbiAtIHRvbGVyYW5jZSAmJiB4IDw9IG1heCArIHRvbGVyYW5jZTtcbiAgfVxuICBvbkZvcm1hdENoYW5nZSh0aWNrcywgZnJhY3Rpb25EaWdpdHMsIF9kb21haW4sIGZvcm1hdCkge1xuICAgIGNvbnN0IHsgc2NhbGU6IHNjYWxlMiB9ID0gdGhpcztcbiAgICBjb25zdCBsb2dTY2FsZSA9IHNjYWxlMiBpbnN0YW5jZW9mIExvZ1NjYWxlO1xuICAgIGNvbnN0IGRlZmF1bHRGb3JtYXR0ZXIgPSAoZm9ybWF0T2Zmc2V0KSA9PiBsb2dTY2FsZSA/IFN0cmluZyA6ICh4KSA9PiB0eXBlb2YgeCA9PT0gXCJudW1iZXJcIiA/IHgudG9GaXhlZChmcmFjdGlvbkRpZ2l0cyArIGZvcm1hdE9mZnNldCkgOiBTdHJpbmcoeCk7XG4gICAgaWYgKGZvcm1hdCAmJiBzY2FsZTIgJiYgc2NhbGUyLnRpY2tGb3JtYXQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlciA9IHNjYWxlMi50aWNrRm9ybWF0KHsgdGlja3MsIHNwZWNpZmllcjogZm9ybWF0IH0pO1xuICAgICAgICB0aGlzLmxhYmVsRm9ybWF0dGVyID0gZm9ybWF0dGVyO1xuICAgICAgICB0aGlzLmRhdHVtRm9ybWF0dGVyID0gZm9ybWF0dGVyO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmxhYmVsRm9ybWF0dGVyID0gZGVmYXVsdEZvcm1hdHRlcigwKTtcbiAgICAgICAgdGhpcy5kYXR1bUZvcm1hdHRlciA9IGRlZmF1bHRGb3JtYXR0ZXIoMSk7XG4gICAgICAgIExvZ2dlci53YXJuT25jZShgdGhlIGF4aXMgbGFiZWwgZm9ybWF0IHN0cmluZyAke2Zvcm1hdH0gaXMgaW52YWxpZC4gTm8gZm9ybWF0dGluZyB3aWxsIGJlIGFwcGxpZWRgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sYWJlbEZvcm1hdHRlciA9IGRlZmF1bHRGb3JtYXR0ZXIoMCk7XG4gICAgICB0aGlzLmRhdHVtRm9ybWF0dGVyID0gZGVmYXVsdEZvcm1hdHRlcigxKTtcbiAgICB9XG4gIH1cbiAgb25HcmlkTGVuZ3RoQ2hhbmdlKHZhbHVlLCBwcmV2VmFsdWUpIHtcbiAgICBpZiAocHJldlZhbHVlIF4gdmFsdWUpIHtcbiAgICAgIHRoaXMub25HcmlkVmlzaWJpbGl0eUNoYW5nZSgpO1xuICAgIH1cbiAgICB0aGlzLmNyb3NzTGluZXMuZm9yRWFjaCgoY3Jvc3NMaW5lKSA9PiB0aGlzLmluaXRDcm9zc0xpbmUoY3Jvc3NMaW5lKSk7XG4gIH1cbiAgb25HcmlkVmlzaWJpbGl0eUNoYW5nZSgpIHtcbiAgICB0aGlzLmdyaWRMaW5lR3JvdXBTZWxlY3Rpb24uY2xlYXIoKTtcbiAgfVxuICBjcmVhdGVMYWJlbCgpIHtcbiAgICByZXR1cm4gbmV3IEF4aXNMYWJlbCgpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzL3JlbW92ZXMvdXBkYXRlcyB0aGUgc2NlbmUgZ3JhcGggbm9kZXMgdGhhdCBjb25zdGl0dXRlIHRoZSBheGlzLlxuICAgKi9cbiAgdXBkYXRlKGFuaW1hdGVkID0gdHJ1ZSkge1xuICAgIGlmICghdGhpcy50aWNrR2VuZXJhdGlvblJlc3VsdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IHJvdGF0aW9uLCBwYXJhbGxlbEZsaXBSb3RhdGlvbiwgcmVndWxhckZsaXBSb3RhdGlvbiB9ID0gdGhpcy5jYWxjdWxhdGVSb3RhdGlvbnMoKTtcbiAgICBjb25zdCBzaWRlRmxhZyA9IHRoaXMubGFiZWwuZ2V0U2lkZUZsYWcoKTtcbiAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uKCk7XG4gICAgY29uc3QgbGluZURhdGEgPSB0aGlzLmdldEF4aXNMaW5lQ29vcmRpbmF0ZXMoKTtcbiAgICBjb25zdCB7IHRpY2tEYXRhLCBjb21iaW5lZFJvdGF0aW9uLCB0ZXh0QmFzZWxpbmUsIHRleHRBbGlnbiwgcHJpbWFyeVRpY2tDb3VudCB9ID0gdGhpcy50aWNrR2VuZXJhdGlvblJlc3VsdDtcbiAgICBjb25zdCBwcmV2aW91c1RpY2tzID0gdGhpcy50aWNrTGFiZWxHcm91cFNlbGVjdGlvbi5ub2RlcygpLm1hcCgobm9kZSkgPT4gbm9kZS5kYXR1bS50aWNrSWQpO1xuICAgIHRoaXMudXBkYXRlU2VsZWN0aW9ucyhsaW5lRGF0YSwgdGlja0RhdGEudGlja3MsIHtcbiAgICAgIGNvbWJpbmVkUm90YXRpb24sXG4gICAgICB0ZXh0QWxpZ24sXG4gICAgICB0ZXh0QmFzZWxpbmUsXG4gICAgICByYW5nZTogdGhpcy5zY2FsZS5yYW5nZVxuICAgIH0pO1xuICAgIGlmICghYW5pbWF0ZWQgfHwgdGhpcy5hbmltYXRpb25NYW5hZ2VyLmlzU2tpcHBlZCgpKSB7XG4gICAgICB0aGlzLnJlc2V0U2VsZWN0aW9uTm9kZXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZGlmZjIgPSB0aGlzLmNhbGN1bGF0ZVVwZGF0ZURpZmYocHJldmlvdXNUaWNrcywgdGlja0RhdGEpO1xuICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwidXBkYXRlXCIsIGRpZmYyKTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVBeGlzTGluZSgpO1xuICAgIHRoaXMudXBkYXRlTGFiZWxzKCk7XG4gICAgdGhpcy51cGRhdGVWaXNpYmlsaXR5KCk7XG4gICAgdGhpcy51cGRhdGVHcmlkTGluZXMoc2lkZUZsYWcpO1xuICAgIHRoaXMudXBkYXRlVGlja0xpbmVzKCk7XG4gICAgdGhpcy51cGRhdGVUaXRsZSh7IGFueVRpY2tWaXNpYmxlOiB0aWNrRGF0YS50aWNrcy5sZW5ndGggPiAwIH0pO1xuICAgIHRoaXMudXBkYXRlQ3Jvc3NMaW5lcyh7IHJvdGF0aW9uLCBwYXJhbGxlbEZsaXBSb3RhdGlvbiwgcmVndWxhckZsaXBSb3RhdGlvbiB9KTtcbiAgICB0aGlzLnVwZGF0ZUxheW91dFN0YXRlKHRpY2tEYXRhLmZyYWN0aW9uRGlnaXRzKTtcbiAgICByZXR1cm4gcHJpbWFyeVRpY2tDb3VudDtcbiAgfVxuICBnZXRBeGlzTGluZUNvb3JkaW5hdGVzKCkge1xuICAgIGNvbnN0IFttaW4sIG1heF0gPSBmaW5kTWluTWF4KHRoaXMucmFuZ2UpO1xuICAgIHJldHVybiB7IHg6IDAsIHkxOiBtaW4sIHkyOiBtYXggfTtcbiAgfVxuICBnZXRUaWNrTGluZUNvb3JkaW5hdGVzKGRhdHVtKSB7XG4gICAgY29uc3Qgc2lkZUZsYWcgPSB0aGlzLmxhYmVsLmdldFNpZGVGbGFnKCk7XG4gICAgY29uc3QgeCA9IHNpZGVGbGFnICogdGhpcy5nZXRUaWNrU2l6ZSgpO1xuICAgIGNvbnN0IHgxID0gTWF0aC5taW4oMCwgeCk7XG4gICAgY29uc3QgeDIgPSB4MSArIE1hdGguYWJzKHgpO1xuICAgIGNvbnN0IHkgPSBkYXR1bS50cmFuc2xhdGlvblk7XG4gICAgcmV0dXJuIHsgeDEsIHgyLCB5IH07XG4gIH1cbiAgZ2V0VGlja0xhYmVsUHJvcHMoZGF0dW0sIHBhcmFtcykge1xuICAgIGNvbnN0IHsgbGFiZWwgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBjb21iaW5lZFJvdGF0aW9uLCB0ZXh0QmFzZWxpbmUsIHRleHRBbGlnbiwgcmFuZ2U6IHJhbmdlMyB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHRleHQgPSBkYXR1bS50aWNrTGFiZWw7XG4gICAgY29uc3Qgc2lkZUZsYWcgPSBsYWJlbC5nZXRTaWRlRmxhZygpO1xuICAgIGNvbnN0IGxhYmVsWCA9IHNpZGVGbGFnICogKHRoaXMuZ2V0VGlja1NpemUoKSArIGxhYmVsLnBhZGRpbmcgKyB0aGlzLnNlcmllc0FyZWFQYWRkaW5nKTtcbiAgICBjb25zdCB2aXNpYmxlID0gdGV4dCAhPT0gXCJcIiAmJiB0ZXh0ICE9IG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRpY2tJZDogZGF0dW0udGlja0lkLFxuICAgICAgdHJhbnNsYXRpb25ZOiBkYXR1bS50cmFuc2xhdGlvblksXG4gICAgICBmaWxsOiBsYWJlbC5jb2xvcixcbiAgICAgIGZvbnRGYW1pbHk6IGxhYmVsLmZvbnRGYW1pbHksXG4gICAgICBmb250U2l6ZTogbGFiZWwuZm9udFNpemUsXG4gICAgICBmb250U3R5bGU6IGxhYmVsLmZvbnRTdHlsZSxcbiAgICAgIGZvbnRXZWlnaHQ6IGxhYmVsLmZvbnRXZWlnaHQsXG4gICAgICByb3RhdGlvbjogY29tYmluZWRSb3RhdGlvbixcbiAgICAgIHJvdGF0aW9uQ2VudGVyWDogbGFiZWxYLFxuICAgICAgdGV4dCxcbiAgICAgIHRleHRBbGlnbixcbiAgICAgIHRleHRCYXNlbGluZSxcbiAgICAgIHZpc2libGUsXG4gICAgICB4OiBsYWJlbFgsXG4gICAgICB5OiAwLFxuICAgICAgcmFuZ2U6IHJhbmdlM1xuICAgIH07XG4gIH1cbiAgZ2V0VGlja1NpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMudGljay5lbmFibGVkID8gdGhpcy50aWNrLnNpemUgOiA2O1xuICB9XG4gIHNldFRpdGxlUHJvcHMoY2FwdGlvbiwgcGFyYW1zKSB7XG4gICAgY29uc3QgeyB0aXRsZSB9ID0gdGhpcztcbiAgICBpZiAoIXRpdGxlLmVuYWJsZWQpIHtcbiAgICAgIGNhcHRpb24uZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgY2FwdGlvbi5ub2RlLnZpc2libGUgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FwdGlvbi5jb2xvciA9IHRpdGxlLmNvbG9yO1xuICAgIGNhcHRpb24uZm9udEZhbWlseSA9IHRpdGxlLmZvbnRGYW1pbHk7XG4gICAgY2FwdGlvbi5mb250U2l6ZSA9IHRpdGxlLmZvbnRTaXplO1xuICAgIGNhcHRpb24uZm9udFN0eWxlID0gdGl0bGUuZm9udFN0eWxlO1xuICAgIGNhcHRpb24uZm9udFdlaWdodCA9IHRpdGxlLmZvbnRXZWlnaHQ7XG4gICAgY2FwdGlvbi5lbmFibGVkID0gdGl0bGUuZW5hYmxlZDtcbiAgICBjYXB0aW9uLndyYXBwaW5nID0gdGl0bGUud3JhcHBpbmc7XG4gICAgY29uc3QgdGl0bGVOb2RlID0gY2FwdGlvbi5ub2RlO1xuICAgIGNvbnN0IHBhZGRpbmcgPSAodGl0bGUuc3BhY2luZyA/PyAwKSArIHBhcmFtcy5zcGFjaW5nO1xuICAgIGNvbnN0IHNpZGVGbGFnID0gdGhpcy5sYWJlbC5nZXRTaWRlRmxhZygpO1xuICAgIGNvbnN0IHBhcmFsbGVsRmxpcFJvdGF0aW9uID0gbm9ybWFsaXplQW5nbGUzNjAodGhpcy5yb3RhdGlvbik7XG4gICAgY29uc3QgdGl0bGVSb3RhdGlvbkZsYWcgPSBzaWRlRmxhZyA9PT0gLTEgJiYgcGFyYWxsZWxGbGlwUm90YXRpb24gPiBNYXRoLlBJICYmIHBhcmFsbGVsRmxpcFJvdGF0aW9uIDwgTWF0aC5QSSAqIDIgPyAtMSA6IDE7XG4gICAgY29uc3Qgcm90YXRpb24gPSB0aXRsZVJvdGF0aW9uRmxhZyAqIHNpZGVGbGFnICogTWF0aC5QSSAvIDI7XG4gICAgY29uc3QgdGV4dEJhc2VsaW5lID0gdGl0bGVSb3RhdGlvbkZsYWcgPT09IDEgPyBcImJvdHRvbVwiIDogXCJ0b3BcIjtcbiAgICBjb25zdCB7IHJhbmdlOiByYW5nZTMgfSA9IHRoaXM7XG4gICAgY29uc3QgeCA9IE1hdGguZmxvb3IodGl0bGVSb3RhdGlvbkZsYWcgKiBzaWRlRmxhZyAqIChyYW5nZTNbMF0gKyByYW5nZTNbMV0pIC8gMik7XG4gICAgY29uc3QgeSA9IHNpZGVGbGFnID09PSAtMSA/IE1hdGguZmxvb3IodGl0bGVSb3RhdGlvbkZsYWcgKiAtcGFkZGluZykgOiBNYXRoLmZsb29yKC1wYWRkaW5nKTtcbiAgICBjb25zdCB7IGNhbGxiYWNrQ2FjaGUgfSA9IHRoaXMubW9kdWxlQ3R4O1xuICAgIGNvbnN0IHsgZm9ybWF0dGVyID0gKHApID0+IHAuZGVmYXVsdFZhbHVlIH0gPSB0aXRsZTtcbiAgICBjb25zdCB0ZXh0ID0gY2FsbGJhY2tDYWNoZS5jYWxsKGZvcm1hdHRlciwgdGhpcy5nZXRUaXRsZUZvcm1hdHRlclBhcmFtcygpKTtcbiAgICBjYXB0aW9uLnRleHQgPSB0ZXh0O1xuICAgIHRpdGxlTm9kZS5zZXRQcm9wZXJ0aWVzKHsgdmlzaWJsZTogdHJ1ZSwgdGV4dCwgdGV4dEJhc2VsaW5lLCB4LCB5LCByb3RhdGlvbiB9KTtcbiAgfVxuICBjYWxjdWxhdGVMYXlvdXQoZG9tYWluLCBwcmltYXJ5VGlja0NvdW50KSB7XG4gICAgY29uc3QgeyByb3RhdGlvbiwgcGFyYWxsZWxGbGlwUm90YXRpb24sIHJlZ3VsYXJGbGlwUm90YXRpb24gfSA9IHRoaXMuY2FsY3VsYXRlUm90YXRpb25zKCk7XG4gICAgY29uc3Qgc2lkZUZsYWcgPSB0aGlzLmxhYmVsLmdldFNpZGVGbGFnKCk7XG4gICAgY29uc3QgbGFiZWxYID0gc2lkZUZsYWcgKiAodGhpcy5nZXRUaWNrU2l6ZSgpICsgdGhpcy5sYWJlbC5wYWRkaW5nICsgdGhpcy5zZXJpZXNBcmVhUGFkZGluZyk7XG4gICAgdGhpcy51cGRhdGVTY2FsZShkb21haW4pO1xuICAgIHRoaXMudGlja0dlbmVyYXRpb25SZXN1bHQgPSB0aGlzLmdlbmVyYXRlVGlja3Moe1xuICAgICAgcHJpbWFyeVRpY2tDb3VudCxcbiAgICAgIHBhcmFsbGVsRmxpcFJvdGF0aW9uLFxuICAgICAgcmVndWxhckZsaXBSb3RhdGlvbixcbiAgICAgIGxhYmVsWCxcbiAgICAgIHNpZGVGbGFnXG4gICAgfSk7XG4gICAgY29uc3QgeyB0aWNrRGF0YSwgY29tYmluZWRSb3RhdGlvbiwgdGV4dEJhc2VsaW5lLCB0ZXh0QWxpZ24sIC4uLnRpY2tzUmVzdWx0IH0gPSB0aGlzLnRpY2tHZW5lcmF0aW9uUmVzdWx0O1xuICAgIHRoaXMudXBkYXRlTGF5b3V0U3RhdGUodGlja0RhdGEuZnJhY3Rpb25EaWdpdHMpO1xuICAgIGNvbnN0IGJveGVzID0gW107XG4gICAgY29uc3QgeyB4LCB5MSwgeTIgfSA9IHRoaXMuZ2V0QXhpc0xpbmVDb29yZGluYXRlcygpO1xuICAgIGNvbnN0IGxpbmVCb3ggPSBuZXcgQkJveChcbiAgICAgIHggKyBNYXRoLm1pbihzaWRlRmxhZyAqIHRoaXMuc2VyaWVzQXJlYVBhZGRpbmcsIDApLFxuICAgICAgeTEsXG4gICAgICB0aGlzLnNlcmllc0FyZWFQYWRkaW5nLFxuICAgICAgeTIgLSB5MVxuICAgICk7XG4gICAgYm94ZXMucHVzaChsaW5lQm94KTtcbiAgICBpZiAodGhpcy50aWNrLmVuYWJsZWQpIHtcbiAgICAgIHRpY2tEYXRhLnRpY2tzLmZvckVhY2goKGRhdHVtKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgeDEsIHgyLCB5IH0gPSB0aGlzLmdldFRpY2tMaW5lQ29vcmRpbmF0ZXMoZGF0dW0pO1xuICAgICAgICBjb25zdCB0aWNrTGluZUJveCA9IG5ldyBCQm94KHgxLCB5LCB4MiAtIHgxLCAwKTtcbiAgICAgICAgYm94ZXMucHVzaCh0aWNrTGluZUJveCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMubGFiZWwuZW5hYmxlZCkge1xuICAgICAgY29uc3QgdGVtcFRleHQgPSBuZXcgVHJhbnNmb3JtYWJsZVRleHQoKTtcbiAgICAgIHRpY2tEYXRhLnRpY2tzLmZvckVhY2goKGRhdHVtKSA9PiB7XG4gICAgICAgIGNvbnN0IGxhYmVsUHJvcHMgPSB0aGlzLmdldFRpY2tMYWJlbFByb3BzKGRhdHVtLCB7XG4gICAgICAgICAgY29tYmluZWRSb3RhdGlvbixcbiAgICAgICAgICB0ZXh0QWxpZ24sXG4gICAgICAgICAgdGV4dEJhc2VsaW5lLFxuICAgICAgICAgIHJhbmdlOiB0aGlzLnNjYWxlLnJhbmdlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWxhYmVsUHJvcHMudmlzaWJsZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0ZW1wVGV4dC5zZXRQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAuLi5sYWJlbFByb3BzLFxuICAgICAgICAgIHRyYW5zbGF0aW9uWTogTWF0aC5yb3VuZChkYXR1bS50cmFuc2xhdGlvblkpXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBib3ggPSB0ZW1wVGV4dC5nZXRCQm94KCk7XG4gICAgICAgIGlmIChib3gpIHtcbiAgICAgICAgICBib3hlcy5wdXNoKGJveCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy50aXRsZT8uZW5hYmxlZCkge1xuICAgICAgY29uc3QgY2FwdGlvbiA9IG5ldyBDYXB0aW9uKCk7XG4gICAgICBjb25zdCBzcGFjaW5nID0gQkJveC5tZXJnZShib3hlcykud2lkdGg7XG4gICAgICB0aGlzLnNldFRpdGxlUHJvcHMoY2FwdGlvbiwgeyBzcGFjaW5nIH0pO1xuICAgICAgY29uc3QgdGl0bGVCb3ggPSBjYXB0aW9uLm5vZGUuZ2V0QkJveCgpO1xuICAgICAgaWYgKHRpdGxlQm94KSB7XG4gICAgICAgIGJveGVzLnB1c2godGl0bGVCb3gpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBiYm94ID0gQkJveC5tZXJnZShib3hlcyk7XG4gICAgY29uc3QgdHJhbnNmb3JtZWRCQm94ID0gdGhpcy5nZXRUcmFuc2Zvcm1Cb3goYmJveCk7XG4gICAgY29uc3QgYW55U2VyaWVzQWN0aXZlID0gdGhpcy5pc0FueVNlcmllc0FjdGl2ZSgpO1xuICAgIHRoaXMuY3Jvc3NMaW5lcy5mb3JFYWNoKChjcm9zc0xpbmUpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNyb3NzTGluZS5zaWRlRmxhZyA9IC1zaWRlRmxhZztcbiAgICAgIGNyb3NzTGluZS5kaXJlY3Rpb24gPSByb3RhdGlvbiA9PT0gLU1hdGguUEkgLyAyID8gXCJ4XCIgLyogWCAqLyA6IFwieVwiIC8qIFkgKi87XG4gICAgICBpZiAoY3Jvc3NMaW5lIGluc3RhbmNlb2YgQ2FydGVzaWFuQ3Jvc3NMaW5lKSB7XG4gICAgICAgIChfYSA9IGNyb3NzTGluZS5sYWJlbCkucGFyYWxsZWwgPz8gKF9hLnBhcmFsbGVsID0gdGhpcy5sYWJlbC5wYXJhbGxlbCk7XG4gICAgICB9XG4gICAgICBjcm9zc0xpbmUucGFyYWxsZWxGbGlwUm90YXRpb24gPSBwYXJhbGxlbEZsaXBSb3RhdGlvbjtcbiAgICAgIGNyb3NzTGluZS5yZWd1bGFyRmxpcFJvdGF0aW9uID0gcmVndWxhckZsaXBSb3RhdGlvbjtcbiAgICAgIGNyb3NzTGluZS5jYWxjdWxhdGVMYXlvdXQ/LihhbnlTZXJpZXNBY3RpdmUsIHRoaXMucmV2ZXJzZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByaW1hcnlUaWNrQ291bnQ6IHRpY2tzUmVzdWx0LnByaW1hcnlUaWNrQ291bnQsXG4gICAgICBiYm94OiB0cmFuc2Zvcm1lZEJCb3hcbiAgICB9O1xuICB9XG4gIHVwZGF0ZUxheW91dFN0YXRlKGZyYWN0aW9uRGlnaXRzKSB7XG4gICAgdGhpcy5sYXlvdXQubGFiZWwgPSB7XG4gICAgICBmcmFjdGlvbkRpZ2l0cyxcbiAgICAgIHBhZGRpbmc6IHRoaXMubGFiZWwucGFkZGluZyxcbiAgICAgIGZvcm1hdDogdGhpcy5sYWJlbC5mb3JtYXRcbiAgICB9O1xuICB9XG4gIGdldFRyYW5zZm9ybUJveChiYm94KSB7XG4gICAgY29uc3QgbWF0cml4ID0gbmV3IE1hdHJpeCgpO1xuICAgIGNvbnN0IHsgcm90YXRpb24sIHRyYW5zbGF0aW9uWCwgdHJhbnNsYXRpb25ZIH0gPSB0aGlzLmdldEF4aXNUcmFuc2Zvcm0oKTtcbiAgICBNYXRyaXgudXBkYXRlVHJhbnNmb3JtTWF0cml4KG1hdHJpeCwgMSwgMSwgcm90YXRpb24sIHRyYW5zbGF0aW9uWCwgdHJhbnNsYXRpb25ZKTtcbiAgICByZXR1cm4gbWF0cml4LnRyYW5zZm9ybUJCb3goYmJveCk7XG4gIH1cbiAgc2V0RG9tYWluKGRvbWFpbikge1xuICAgIHRoaXMuZGF0YURvbWFpbiA9IHRoaXMubm9ybWFsaXNlRGF0YURvbWFpbihkb21haW4pO1xuICAgIGlmICh0aGlzLnJldmVyc2UpIHtcbiAgICAgIHRoaXMuZGF0YURvbWFpbi5kb21haW4ucmV2ZXJzZSgpO1xuICAgIH1cbiAgICB0aGlzLnNjYWxlLmRvbWFpbiA9IHRoaXMuZGF0YURvbWFpbi5kb21haW47XG4gIH1cbiAgdXBkYXRlU2NhbGUoZG9tYWluKSB7XG4gICAgaWYgKGRvbWFpbikge1xuICAgICAgdGhpcy5zZXREb21haW4oZG9tYWluKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jYWxjdWxhdGVEb21haW4oKTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVSYW5nZSgpO1xuICAgIHRoaXMuc2NhbGUuaW50ZXJ2YWwgPSB0aGlzLmludGVydmFsLnN0ZXA7XG4gICAgaWYgKENvbnRpbnVvdXNTY2FsZS5pcyh0aGlzLnNjYWxlKSkge1xuICAgICAgdGhpcy5zY2FsZS5uaWNlID0gdGhpcy5uaWNlO1xuICAgICAgdGhpcy5zY2FsZS51cGRhdGUoKTtcbiAgICB9XG4gIH1cbiAgY2FsY3VsYXRlUm90YXRpb25zKCkge1xuICAgIGNvbnN0IHJvdGF0aW9uID0gdG9SYWRpYW5zKHRoaXMucm90YXRpb24pO1xuICAgIGNvbnN0IHBhcmFsbGVsRmxpcFJvdGF0aW9uID0gbm9ybWFsaXplQW5nbGUzNjAocm90YXRpb24pO1xuICAgIGNvbnN0IHJlZ3VsYXJGbGlwUm90YXRpb24gPSBub3JtYWxpemVBbmdsZTM2MChyb3RhdGlvbiAtIE1hdGguUEkgLyAyKTtcbiAgICByZXR1cm4geyByb3RhdGlvbiwgcGFyYWxsZWxGbGlwUm90YXRpb24sIHJlZ3VsYXJGbGlwUm90YXRpb24gfTtcbiAgfVxuICBnZW5lcmF0ZVRpY2tzKHtcbiAgICBwcmltYXJ5VGlja0NvdW50LFxuICAgIHBhcmFsbGVsRmxpcFJvdGF0aW9uLFxuICAgIHJlZ3VsYXJGbGlwUm90YXRpb24sXG4gICAgbGFiZWxYLFxuICAgIHNpZGVGbGFnXG4gIH0pIHtcbiAgICBjb25zdCB7XG4gICAgICBzY2FsZTogc2NhbGUyLFxuICAgICAgaW50ZXJ2YWw6IHsgbWluU3BhY2luZywgbWF4U3BhY2luZyB9LFxuICAgICAgbGFiZWw6IHsgcGFyYWxsZWwsIHJvdGF0aW9uLCBmb250RmFtaWx5LCBmb250U2l6ZSwgZm9udFN0eWxlLCBmb250V2VpZ2h0IH1cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBzZWNvbmRhcnlBeGlzID0gcHJpbWFyeVRpY2tDb3VudCAhPT0gdm9pZCAwO1xuICAgIGNvbnN0IHsgZGVmYXVsdFJvdGF0aW9uLCBjb25maWd1cmVkUm90YXRpb24sIHBhcmFsbGVsRmxpcEZsYWcsIHJlZ3VsYXJGbGlwRmxhZyB9ID0gY2FsY3VsYXRlTGFiZWxSb3RhdGlvbih7XG4gICAgICByb3RhdGlvbixcbiAgICAgIHBhcmFsbGVsLFxuICAgICAgcmVndWxhckZsaXBSb3RhdGlvbixcbiAgICAgIHBhcmFsbGVsRmxpcFJvdGF0aW9uXG4gICAgfSk7XG4gICAgY29uc3QgaW5pdGlhbFJvdGF0aW9uID0gY29uZmlndXJlZFJvdGF0aW9uICsgZGVmYXVsdFJvdGF0aW9uO1xuICAgIGNvbnN0IGxhYmVsTWF0cml4ID0gbmV3IE1hdHJpeCgpO1xuICAgIGNvbnN0IHsgbWF4VGlja0NvdW50IH0gPSB0aGlzLmVzdGltYXRlVGlja0NvdW50KHsgbWluU3BhY2luZywgbWF4U3BhY2luZyB9KTtcbiAgICBjb25zdCBjb250aW51b3VzID0gQ29udGludW91c1NjYWxlLmlzKHNjYWxlMikgfHwgT3JkaW5hbFRpbWVTY2FsZS5pcyhzY2FsZTIpO1xuICAgIGNvbnN0IG1heEl0ZXJhdGlvbnMgPSAhY29udGludW91cyB8fCBpc05hTihtYXhUaWNrQ291bnQpID8gMTAgOiBtYXhUaWNrQ291bnQ7XG4gICAgbGV0IHRleHRBbGlnbiA9IGdldFRleHRBbGlnbihwYXJhbGxlbCwgY29uZmlndXJlZFJvdGF0aW9uLCAwLCBzaWRlRmxhZywgcmVndWxhckZsaXBGbGFnKTtcbiAgICBjb25zdCB0ZXh0QmFzZWxpbmUgPSBnZXRUZXh0QmFzZWxpbmUocGFyYWxsZWwsIGNvbmZpZ3VyZWRSb3RhdGlvbiwgc2lkZUZsYWcsIHBhcmFsbGVsRmxpcEZsYWcpO1xuICAgIGNvbnN0IGZvbnQgPSBUZXh0VXRpbHMudG9Gb250U3RyaW5nKHsgZm9udEZhbWlseSwgZm9udFNpemUsIGZvbnRTdHlsZSwgZm9udFdlaWdodCB9KTtcbiAgICBjb25zdCB0ZXh0TWVhc3VyZXIgPSBDYWNoZWRUZXh0TWVhc3VyZXJQb29sLmdldE1lYXN1cmVyKHsgZm9udCB9KTtcbiAgICBjb25zdCB0ZXh0UHJvcHMgPSB7XG4gICAgICBmb250RmFtaWx5LFxuICAgICAgZm9udFNpemUsXG4gICAgICBmb250U3R5bGUsXG4gICAgICBmb250V2VpZ2h0LFxuICAgICAgdGV4dEJhc2VsaW5lLFxuICAgICAgdGV4dEFsaWduXG4gICAgfTtcbiAgICBsZXQgdGlja0RhdGEgPSB7XG4gICAgICByYXdUaWNrczogW10sXG4gICAgICBmcmFjdGlvbkRpZ2l0czogMCxcbiAgICAgIHRpY2tzOiBbXSxcbiAgICAgIGxhYmVsQ291bnQ6IDBcbiAgICB9O1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgbGV0IGF1dG9Sb3RhdGlvbiA9IDA7XG4gICAgbGV0IGxhYmVsT3ZlcmxhcCA9IHRydWU7XG4gICAgbGV0IGxhYmVsRGF0YSA9IFtdO1xuICAgIGxldCB0ZXJtaW5hdGUgPSBmYWxzZTtcbiAgICB3aGlsZSAobGFiZWxPdmVybGFwICYmIGluZGV4IDw9IG1heEl0ZXJhdGlvbnMpIHtcbiAgICAgIGlmICh0ZXJtaW5hdGUpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBhdXRvUm90YXRpb24gPSAwO1xuICAgICAgdGV4dEFsaWduID0gZ2V0VGV4dEFsaWduKHBhcmFsbGVsLCBjb25maWd1cmVkUm90YXRpb24sIDAsIHNpZGVGbGFnLCByZWd1bGFyRmxpcEZsYWcpO1xuICAgICAgY29uc3QgdGlja1N0cmF0ZWdpZXMgPSB0aGlzLmdldFRpY2tTdHJhdGVnaWVzKHsgc2Vjb25kYXJ5QXhpcywgaW5kZXggfSk7XG4gICAgICBmb3IgKGNvbnN0IHN0cmF0ZWd5IG9mIHRpY2tTdHJhdGVnaWVzKSB7XG4gICAgICAgICh7IHRpY2tEYXRhLCBpbmRleCwgYXV0b1JvdGF0aW9uLCB0ZXJtaW5hdGUgfSA9IHN0cmF0ZWd5KHtcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICB0aWNrRGF0YSxcbiAgICAgICAgICB0ZXh0UHJvcHMsXG4gICAgICAgICAgbGFiZWxPdmVybGFwLFxuICAgICAgICAgIHRlcm1pbmF0ZSxcbiAgICAgICAgICBwcmltYXJ5VGlja0NvdW50XG4gICAgICAgIH0pKTtcbiAgICAgICAgY29uc3Qgcm90YXRlZCA9IGNvbmZpZ3VyZWRSb3RhdGlvbiAhPT0gMCB8fCBhdXRvUm90YXRpb24gIT09IDA7XG4gICAgICAgIGNvbnN0IGxhYmVsUm90YXRpb24gPSBpbml0aWFsUm90YXRpb24gKyBhdXRvUm90YXRpb247XG4gICAgICAgIGNvbnN0IGxhYmVsU3BhY2luZyA9IGdldExhYmVsU3BhY2luZyh0aGlzLmxhYmVsLm1pblNwYWNpbmcsIHJvdGF0ZWQpO1xuICAgICAgICBNYXRyaXgudXBkYXRlVHJhbnNmb3JtTWF0cml4KGxhYmVsTWF0cml4LCAxLCAxLCBsYWJlbFJvdGF0aW9uLCAwLCAwKTtcbiAgICAgICAgdGV4dEFsaWduID0gZ2V0VGV4dEFsaWduKHBhcmFsbGVsLCBjb25maWd1cmVkUm90YXRpb24sIGF1dG9Sb3RhdGlvbiwgc2lkZUZsYWcsIHJlZ3VsYXJGbGlwRmxhZyk7XG4gICAgICAgIGxhYmVsRGF0YSA9IHRoaXMuY3JlYXRlTGFiZWxEYXRhKHRpY2tEYXRhLnRpY2tzLCBsYWJlbFgsIGxhYmVsTWF0cml4LCB0ZXh0TWVhc3VyZXIpO1xuICAgICAgICBsYWJlbE92ZXJsYXAgPSB0aGlzLmxhYmVsLmF2b2lkQ29sbGlzaW9ucyA/IGF4aXNMYWJlbHNPdmVybGFwKGxhYmVsRGF0YSwgbGFiZWxTcGFjaW5nKSA6IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjb21iaW5lZFJvdGF0aW9uID0gZGVmYXVsdFJvdGF0aW9uICsgY29uZmlndXJlZFJvdGF0aW9uICsgYXV0b1JvdGF0aW9uO1xuICAgIGlmICghc2Vjb25kYXJ5QXhpcyAmJiB0aWNrRGF0YS5yYXdUaWNrcy5sZW5ndGggPiAwKSB7XG4gICAgICBwcmltYXJ5VGlja0NvdW50ID0gdGlja0RhdGEucmF3VGlja3MubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4geyB0aWNrRGF0YSwgcHJpbWFyeVRpY2tDb3VudCwgY29tYmluZWRSb3RhdGlvbiwgdGV4dEJhc2VsaW5lLCB0ZXh0QWxpZ24sIGxhYmVsRGF0YSB9O1xuICB9XG4gIGdldFRpY2tTdHJhdGVnaWVzKHtcbiAgICBpbmRleDogaXRlcmF0aW9uLFxuICAgIHNlY29uZGFyeUF4aXNcbiAgfSkge1xuICAgIGNvbnN0IHsgc2NhbGU6IHNjYWxlMiwgbGFiZWwgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBtaW5TcGFjaW5nIH0gPSB0aGlzLmludGVydmFsO1xuICAgIGNvbnN0IGNvbnRpbnVvdXMgPSBDb250aW51b3VzU2NhbGUuaXMoc2NhbGUyKSB8fCBPcmRpbmFsVGltZVNjYWxlLmlzKHNjYWxlMik7XG4gICAgY29uc3QgYXZvaWRMYWJlbENvbGxpc2lvbnMgPSBsYWJlbC5lbmFibGVkICYmIGxhYmVsLmF2b2lkQ29sbGlzaW9ucztcbiAgICBjb25zdCBmaWx0ZXJUaWNrcyA9ICFjb250aW51b3VzICYmIGl0ZXJhdGlvbiAhPT0gMCAmJiBhdm9pZExhYmVsQ29sbGlzaW9ucztcbiAgICBjb25zdCBhdXRvUm90YXRlID0gbGFiZWwuYXV0b1JvdGF0ZSA9PT0gdHJ1ZSAmJiBsYWJlbC5yb3RhdGlvbiA9PT0gdm9pZCAwO1xuICAgIGNvbnN0IHN0cmF0ZWdpZXMgPSBbXTtcbiAgICBsZXQgdGlja0dlbmVyYXRpb25UeXBlO1xuICAgIGlmICh0aGlzLmludGVydmFsLnZhbHVlcykge1xuICAgICAgdGlja0dlbmVyYXRpb25UeXBlID0gMyAvKiBWQUxVRVMgKi87XG4gICAgfSBlbHNlIGlmIChzZWNvbmRhcnlBeGlzKSB7XG4gICAgICB0aWNrR2VuZXJhdGlvblR5cGUgPSAxIC8qIENSRUFURV9TRUNPTkRBUlkgKi87XG4gICAgfSBlbHNlIGlmIChmaWx0ZXJUaWNrcykge1xuICAgICAgdGlja0dlbmVyYXRpb25UeXBlID0gMiAvKiBGSUxURVIgKi87XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpY2tHZW5lcmF0aW9uVHlwZSA9IDAgLyogQ1JFQVRFICovO1xuICAgIH1cbiAgICBjb25zdCB0aWNrR2VuZXJhdGlvblN0cmF0ZWd5ID0gKHsgaW5kZXgsIHRpY2tEYXRhLCBwcmltYXJ5VGlja0NvdW50LCB0ZXJtaW5hdGUgfSkgPT4gdGhpcy5jcmVhdGVUaWNrRGF0YSh0aWNrR2VuZXJhdGlvblR5cGUsIGluZGV4LCB0aWNrRGF0YSwgdGVybWluYXRlLCBwcmltYXJ5VGlja0NvdW50KTtcbiAgICBzdHJhdGVnaWVzLnB1c2godGlja0dlbmVyYXRpb25TdHJhdGVneSk7XG4gICAgaWYgKCFjb250aW51b3VzICYmICFpc05hTihtaW5TcGFjaW5nKSkge1xuICAgICAgY29uc3QgdGlja0ZpbHRlclN0cmF0ZWd5ID0gKHsgaW5kZXgsIHRpY2tEYXRhLCBwcmltYXJ5VGlja0NvdW50LCB0ZXJtaW5hdGUgfSkgPT4gdGhpcy5jcmVhdGVUaWNrRGF0YSgyIC8qIEZJTFRFUiAqLywgaW5kZXgsIHRpY2tEYXRhLCB0ZXJtaW5hdGUsIHByaW1hcnlUaWNrQ291bnQpO1xuICAgICAgc3RyYXRlZ2llcy5wdXNoKHRpY2tGaWx0ZXJTdHJhdGVneSk7XG4gICAgfVxuICAgIGlmICghYXZvaWRMYWJlbENvbGxpc2lvbnMpIHtcbiAgICAgIHJldHVybiBzdHJhdGVnaWVzO1xuICAgIH1cbiAgICBpZiAoYXV0b1JvdGF0ZSkge1xuICAgICAgY29uc3QgYXV0b1JvdGF0ZVN0cmF0ZWd5ID0gKHsgaW5kZXgsIHRpY2tEYXRhLCBsYWJlbE92ZXJsYXAsIHRlcm1pbmF0ZSB9KSA9PiAoe1xuICAgICAgICBpbmRleCxcbiAgICAgICAgdGlja0RhdGEsXG4gICAgICAgIGF1dG9Sb3RhdGlvbjogdGhpcy5nZXRBdXRvUm90YXRpb24obGFiZWxPdmVybGFwKSxcbiAgICAgICAgdGVybWluYXRlXG4gICAgICB9KTtcbiAgICAgIHN0cmF0ZWdpZXMucHVzaChhdXRvUm90YXRlU3RyYXRlZ3kpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyYXRlZ2llcztcbiAgfVxuICBjcmVhdGVUaWNrRGF0YSh0aWNrR2VuZXJhdGlvblR5cGUsIGluZGV4LCB0aWNrRGF0YSwgdGVybWluYXRlLCBwcmltYXJ5VGlja0NvdW50KSB7XG4gICAgY29uc3QgeyBzY2FsZTogc2NhbGUyIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgc3RlcCwgdmFsdWVzLCBtaW5TcGFjaW5nLCBtYXhTcGFjaW5nIH0gPSB0aGlzLmludGVydmFsO1xuICAgIGNvbnN0IHsgbWF4VGlja0NvdW50LCBtaW5UaWNrQ291bnQsIGRlZmF1bHRUaWNrQ291bnQgfSA9IHRoaXMuZXN0aW1hdGVUaWNrQ291bnQoeyBtaW5TcGFjaW5nLCBtYXhTcGFjaW5nIH0pO1xuICAgIGNvbnN0IGNvbnRpbnVvdXMgPSBDb250aW51b3VzU2NhbGUuaXMoc2NhbGUyKSB8fCBPcmRpbmFsVGltZVNjYWxlLmlzKHNjYWxlMik7XG4gICAgY29uc3QgbWF4SXRlcmF0aW9ucyA9ICFjb250aW51b3VzIHx8IGlzTmFOKG1heFRpY2tDb3VudCkgPyAxMCA6IG1heFRpY2tDb3VudDtcbiAgICBsZXQgdGlja0NvdW50ID0gY29udGludW91cyA/IE1hdGgubWF4KGRlZmF1bHRUaWNrQ291bnQgLSBpbmRleCwgbWluVGlja0NvdW50KSA6IG1heFRpY2tDb3VudDtcbiAgICBjb25zdCByZWdlbmVyYXRlVGlja3MgPSBzdGVwID09PSB2b2lkIDAgJiYgdmFsdWVzID09PSB2b2lkIDAgJiYgdGlja0NvdW50ID4gbWluVGlja0NvdW50ICYmIChjb250aW51b3VzIHx8IHRpY2tHZW5lcmF0aW9uVHlwZSA9PT0gMiAvKiBGSUxURVIgKi8pO1xuICAgIGxldCB1bmNoYW5nZWQgPSB0cnVlO1xuICAgIHdoaWxlICh1bmNoYW5nZWQgJiYgaW5kZXggPD0gbWF4SXRlcmF0aW9ucykge1xuICAgICAgY29uc3QgcHJldlRpY2tzID0gdGlja0RhdGEucmF3VGlja3M7XG4gICAgICB0aWNrQ291bnQgPSBjb250aW51b3VzID8gTWF0aC5tYXgoZGVmYXVsdFRpY2tDb3VudCAtIGluZGV4LCBtaW5UaWNrQ291bnQpIDogbWF4VGlja0NvdW50O1xuICAgICAgY29uc3QgeyByYXdUaWNrcywgZnJhY3Rpb25EaWdpdHMsIHRpY2tzLCBsYWJlbENvdW50IH0gPSB0aGlzLmdldFRpY2tzKHtcbiAgICAgICAgdGlja0dlbmVyYXRpb25UeXBlLFxuICAgICAgICBwcmV2aW91c1RpY2tzOiBwcmV2VGlja3MsXG4gICAgICAgIHRpY2tDb3VudCxcbiAgICAgICAgbWluVGlja0NvdW50LFxuICAgICAgICBtYXhUaWNrQ291bnQsXG4gICAgICAgIHByaW1hcnlUaWNrQ291bnRcbiAgICAgIH0pO1xuICAgICAgdGlja0RhdGEucmF3VGlja3MgPSByYXdUaWNrcztcbiAgICAgIHRpY2tEYXRhLmZyYWN0aW9uRGlnaXRzID0gZnJhY3Rpb25EaWdpdHM7XG4gICAgICB0aWNrRGF0YS50aWNrcyA9IHRpY2tzO1xuICAgICAgdGlja0RhdGEubGFiZWxDb3VudCA9IGxhYmVsQ291bnQ7XG4gICAgICB1bmNoYW5nZWQgPSByZWdlbmVyYXRlVGlja3MgPyBhcmVBcnJheU51bWJlcnNFcXVhbChyYXdUaWNrcywgcHJldlRpY2tzKSA6IGZhbHNlO1xuICAgICAgaW5kZXgrKztcbiAgICB9XG4gICAgY29uc3Qgc2hvdWxkVGVybWluYXRlID0gc3RlcCAhPT0gdm9pZCAwIHx8IHZhbHVlcyAhPT0gdm9pZCAwO1xuICAgIHRlcm1pbmF0ZSB8fCAodGVybWluYXRlID0gc2hvdWxkVGVybWluYXRlKTtcbiAgICByZXR1cm4geyB0aWNrRGF0YSwgaW5kZXgsIGF1dG9Sb3RhdGlvbjogMCwgdGVybWluYXRlIH07XG4gIH1cbiAgY3JlYXRlTGFiZWxEYXRhKHRpY2tEYXRhLCBsYWJlbFgsIGxhYmVsTWF0cml4LCB0ZXh0TWVhc3VyZXIpIHtcbiAgICBjb25zdCBsYWJlbERhdGEgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHsgdGlja0xhYmVsLCB0cmFuc2xhdGlvblkgfSBvZiB0aWNrRGF0YSkge1xuICAgICAgaWYgKCF0aWNrTGFiZWwpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3QgeyB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIgfSA9IHRleHRNZWFzdXJlci5tZWFzdXJlTGluZXModGlja0xhYmVsKTtcbiAgICAgIGNvbnN0IGJib3ggPSBuZXcgQkJveChsYWJlbFgsIHRyYW5zbGF0aW9uWSwgd2lkdGgyLCBoZWlnaHQyKTtcbiAgICAgIGNvbnN0IGxhYmVsRGF0dW0gPSBjYWxjdWxhdGVMYWJlbEJCb3godGlja0xhYmVsLCBiYm94LCBsYWJlbE1hdHJpeCk7XG4gICAgICBsYWJlbERhdGEucHVzaChsYWJlbERhdHVtKTtcbiAgICB9XG4gICAgcmV0dXJuIGxhYmVsRGF0YTtcbiAgfVxuICBnZXRBdXRvUm90YXRpb24obGFiZWxPdmVybGFwKSB7XG4gICAgcmV0dXJuIGxhYmVsT3ZlcmxhcCA/IG5vcm1hbGl6ZUFuZ2xlMzYwKHRvUmFkaWFucyh0aGlzLmxhYmVsLmF1dG9Sb3RhdGVBbmdsZSA/PyAwKSkgOiAwO1xuICB9XG4gIGdldFRpY2tzKHtcbiAgICB0aWNrR2VuZXJhdGlvblR5cGUsXG4gICAgcHJldmlvdXNUaWNrcyxcbiAgICB0aWNrQ291bnQsXG4gICAgbWluVGlja0NvdW50LFxuICAgIG1heFRpY2tDb3VudCxcbiAgICBwcmltYXJ5VGlja0NvdW50XG4gIH0pIHtcbiAgICBjb25zdCB7IHJhbmdlOiByYW5nZTMsIHNjYWxlOiBzY2FsZTIsIHZpc2libGVSYW5nZSB9ID0gdGhpcztcbiAgICBsZXQgcmF3VGlja3M7XG4gICAgc3dpdGNoICh0aWNrR2VuZXJhdGlvblR5cGUpIHtcbiAgICAgIGNhc2UgMyAvKiBWQUxVRVMgKi86XG4gICAgICAgIHJhd1RpY2tzID0gdGhpcy5pbnRlcnZhbC52YWx1ZXM7XG4gICAgICAgIGlmIChDb250aW51b3VzU2NhbGUuaXMoc2NhbGUyKSkge1xuICAgICAgICAgIGNvbnN0IFtkMCwgZDFdID0gZmluZE1pbk1heChzY2FsZTIuZ2V0RG9tYWluKCkubWFwKE51bWJlcikpO1xuICAgICAgICAgIHJhd1RpY2tzID0gcmF3VGlja3MuZmlsdGVyKCh2YWx1ZSkgPT4gdmFsdWUgPj0gZDAgJiYgdmFsdWUgPD0gZDEpLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMSAvKiBDUkVBVEVfU0VDT05EQVJZICovOlxuICAgICAgICBpZiAoQ29udGludW91c1NjYWxlLmlzKHNjYWxlMikpIHtcbiAgICAgICAgICByYXdUaWNrcyA9IHRoaXMudXBkYXRlU2Vjb25kYXJ5QXhpc1RpY2tzKHByaW1hcnlUaWNrQ291bnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJhd1RpY2tzID0gdGhpcy5jcmVhdGVUaWNrcyh0aWNrQ291bnQsIG1pblRpY2tDb3VudCwgbWF4VGlja0NvdW50KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMiAvKiBGSUxURVIgKi86XG4gICAgICAgIHJhd1RpY2tzID0gdGhpcy5maWx0ZXJUaWNrcyhwcmV2aW91c1RpY2tzLCB0aWNrQ291bnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJhd1RpY2tzID0gdGhpcy5jcmVhdGVUaWNrcyh0aWNrQ291bnQsIG1pblRpY2tDb3VudCwgbWF4VGlja0NvdW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNvbnN0IGZyYWN0aW9uRGlnaXRzID0gcmF3VGlja3MucmVkdWNlKFxuICAgICAgKG1heCwgdGljaykgPT4gTWF0aC5tYXgobWF4LCB0eXBlb2YgdGljayA9PT0gXCJudW1iZXJcIiA/IGNvdW50RnJhY3Rpb25EaWdpdHModGljaykgOiAwKSxcbiAgICAgIDBcbiAgICApO1xuICAgIGNvbnN0IGhhbGZCYW5kd2lkdGggPSAoc2NhbGUyLmJhbmR3aWR0aCA/PyAwKSAvIDI7XG4gICAgY29uc3QgdGlja3MgPSBbXTtcbiAgICBsZXQgbGFiZWxDb3VudCA9IDA7XG4gICAgY29uc3QgdGlja0lkQ291bnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBjb25zdCBzdGFydDIgPSBNYXRoLm1heCgwLCBNYXRoLmZsb29yKHZpc2libGVSYW5nZVswXSAqIHJhd1RpY2tzLmxlbmd0aCkpO1xuICAgIGNvbnN0IGVuZDIgPSBNYXRoLm1pbihyYXdUaWNrcy5sZW5ndGgsIE1hdGguY2VpbCh2aXNpYmxlUmFuZ2VbMV0gKiByYXdUaWNrcy5sZW5ndGgpKTtcbiAgICBjb25zdCBmaWx0ZXJlZFRpY2tzID0gcmF3VGlja3Muc2xpY2Uoc3RhcnQyLCBlbmQyKTtcbiAgICB0aGlzLm9uRm9ybWF0Q2hhbmdlKGZpbHRlcmVkVGlja3MsIGZyYWN0aW9uRGlnaXRzLCByYXdUaWNrcywgdGhpcy5sYWJlbC5mb3JtYXQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsdGVyZWRUaWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdGljayA9IGZpbHRlcmVkVGlja3NbaV07XG4gICAgICBjb25zdCB0cmFuc2xhdGlvblkgPSBzY2FsZTIuY29udmVydCh0aWNrKSArIGhhbGZCYW5kd2lkdGg7XG4gICAgICBpZiAocmFuZ2UzLmxlbmd0aCA+IDAgJiYgIXRoaXMuaW5SYW5nZSh0cmFuc2xhdGlvblksIDFlLTMpKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IHRpY2tMYWJlbCA9IHRoaXMuZm9ybWF0VGljayh0aWNrLCBmcmFjdGlvbkRpZ2l0cywgc3RhcnQyICsgaSk7XG4gICAgICBsZXQgdGlja0lkID0gdGlja0xhYmVsO1xuICAgICAgaWYgKHRpY2tJZENvdW50cy5oYXModGlja0lkKSkge1xuICAgICAgICBjb25zdCBjb3VudCA9IHRpY2tJZENvdW50cy5nZXQodGlja0lkKTtcbiAgICAgICAgdGlja0lkQ291bnRzLnNldCh0aWNrSWQsIGNvdW50ICsgMSk7XG4gICAgICAgIHRpY2tJZCA9IGAke3RpY2tJZH1fJHtjb3VudH1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGlja0lkQ291bnRzLnNldCh0aWNrSWQsIDEpO1xuICAgICAgfVxuICAgICAgdGlja3MucHVzaCh7IHRpY2ssIHRpY2tJZCwgdGlja0xhYmVsLCB0cmFuc2xhdGlvblk6IE1hdGguZmxvb3IodHJhbnNsYXRpb25ZKSB9KTtcbiAgICAgIGlmICh0aWNrTGFiZWwgPT09IFwiXCIgfHwgdGlja0xhYmVsID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBsYWJlbENvdW50Kys7XG4gICAgfVxuICAgIHJldHVybiB7IHJhd1RpY2tzLCBmcmFjdGlvbkRpZ2l0cywgdGlja3MsIGxhYmVsQ291bnQgfTtcbiAgfVxuICBmaWx0ZXJUaWNrcyh0aWNrcywgdGlja0NvdW50KSB7XG4gICAgY29uc3QgeyBtaW5TcGFjaW5nLCBtYXhTcGFjaW5nIH0gPSB0aGlzLmludGVydmFsO1xuICAgIGNvbnN0IHRpY2tTcGFjaW5nID0gIWlzTmFOKG1pblNwYWNpbmcpIHx8ICFpc05hTihtYXhTcGFjaW5nKTtcbiAgICBjb25zdCBrZWVwRXZlcnkgPSB0aWNrU3BhY2luZyA/IE1hdGguY2VpbCh0aWNrcy5sZW5ndGggLyB0aWNrQ291bnQpIDogMjtcbiAgICByZXR1cm4gdGlja3MuZmlsdGVyKChfLCBpKSA9PiBpICUga2VlcEV2ZXJ5ID09PSAwKTtcbiAgfVxuICBjcmVhdGVUaWNrcyh0aWNrQ291bnQsIG1pblRpY2tDb3VudCwgbWF4VGlja0NvdW50KSB7XG4gICAgY29uc3QgeyBzY2FsZTogc2NhbGUyIH0gPSB0aGlzO1xuICAgIGlmICh0aWNrQ291bnQgJiYgKENvbnRpbnVvdXNTY2FsZS5pcyhzY2FsZTIpIHx8IE9yZGluYWxUaW1lU2NhbGUuaXMoc2NhbGUyKSkpIHtcbiAgICAgIHNjYWxlMi50aWNrQ291bnQgPSB0aWNrQ291bnQ7XG4gICAgICBzY2FsZTIubWluVGlja0NvdW50ID0gbWluVGlja0NvdW50ID8/IDA7XG4gICAgICBzY2FsZTIubWF4VGlja0NvdW50ID0gbWF4VGlja0NvdW50ID8/IEluZmluaXR5O1xuICAgIH1cbiAgICByZXR1cm4gc2NhbGUyLnRpY2tzPy4oKSA/PyBbXTtcbiAgfVxuICBlc3RpbWF0ZVRpY2tDb3VudCh7IG1pblNwYWNpbmcsIG1heFNwYWNpbmcgfSkge1xuICAgIGlmICghdGhpcy5sYWJlbC5hdm9pZENvbGxpc2lvbnMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1pblRpY2tDb3VudDogQ29udGludW91c1NjYWxlLmRlZmF1bHRNYXhUaWNrQ291bnQsXG4gICAgICAgIG1heFRpY2tDb3VudDogQ29udGludW91c1NjYWxlLmRlZmF1bHRNYXhUaWNrQ291bnQsXG4gICAgICAgIGRlZmF1bHRUaWNrQ291bnQ6IENvbnRpbnVvdXNTY2FsZS5kZWZhdWx0TWF4VGlja0NvdW50XG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCByYW5nZVdpdGhCbGVlZCA9IHRoaXMuY2FsY3VsYXRlUmFuZ2VXaXRoQmxlZWQoKTtcbiAgICBjb25zdCBkZWZhdWx0TWluU3BhY2luZyA9IE1hdGgubWF4KFxuICAgICAgdGhpcy5kZWZhdWx0VGlja01pblNwYWNpbmcsXG4gICAgICByYW5nZVdpdGhCbGVlZCAvIENvbnRpbnVvdXNTY2FsZS5kZWZhdWx0TWF4VGlja0NvdW50XG4gICAgKTtcbiAgICBsZXQgY2xhbXBNYXhUaWNrQ291bnQgPSAhaXNOYU4obWF4U3BhY2luZyk7XG4gICAgaWYgKGlzTmFOKG1pblNwYWNpbmcpKSB7XG4gICAgICBtaW5TcGFjaW5nID0gZGVmYXVsdE1pblNwYWNpbmc7XG4gICAgfVxuICAgIGlmIChpc05hTihtYXhTcGFjaW5nKSkge1xuICAgICAgbWF4U3BhY2luZyA9IHJhbmdlV2l0aEJsZWVkO1xuICAgIH1cbiAgICBpZiAobWluU3BhY2luZyA+IG1heFNwYWNpbmcpIHtcbiAgICAgIGlmIChtaW5TcGFjaW5nID09PSBkZWZhdWx0TWluU3BhY2luZykge1xuICAgICAgICBtaW5TcGFjaW5nID0gbWF4U3BhY2luZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1heFNwYWNpbmcgPSBtaW5TcGFjaW5nO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBtaW5SZWN0RGlzdGFuY2UgPSAyO1xuICAgIGNsYW1wTWF4VGlja0NvdW50ICYmIChjbGFtcE1heFRpY2tDb3VudCA9IG1pblJlY3REaXN0YW5jZSA8IGRlZmF1bHRNaW5TcGFjaW5nKTtcbiAgICBjb25zdCBtYXhUaWNrQ291bnQgPSBjbGFtcChcbiAgICAgIDEsXG4gICAgICBNYXRoLmZsb29yKHJhbmdlV2l0aEJsZWVkIC8gbWluU3BhY2luZyksXG4gICAgICBjbGFtcE1heFRpY2tDb3VudCA/IE1hdGgubWluKE1hdGguZmxvb3IocmFuZ2VXaXRoQmxlZWQgLyBtaW5SZWN0RGlzdGFuY2UpLCAxMDApIDogMTAwXG4gICAgKTtcbiAgICBjb25zdCBtaW5UaWNrQ291bnQgPSBNYXRoLm1pbihtYXhUaWNrQ291bnQsIE1hdGguY2VpbChyYW5nZVdpdGhCbGVlZCAvIG1heFNwYWNpbmcpKTtcbiAgICBjb25zdCBkZWZhdWx0VGlja0NvdW50ID0gY2xhbXAobWluVGlja0NvdW50LCBDb250aW51b3VzU2NhbGUuZGVmYXVsdFRpY2tDb3VudCwgbWF4VGlja0NvdW50KTtcbiAgICByZXR1cm4geyBtaW5UaWNrQ291bnQsIG1heFRpY2tDb3VudCwgZGVmYXVsdFRpY2tDb3VudCB9O1xuICB9XG4gIHVwZGF0ZVZpc2liaWxpdHkoKSB7XG4gICAgaWYgKHRoaXMubW9kdWxlQ3R4LmFuaW1hdGlvbk1hbmFnZXIuaXNTa2lwcGVkKCkpIHtcbiAgICAgIHRoaXMucmVzZXRTZWxlY3Rpb25Ob2RlcygpO1xuICAgIH1cbiAgICB0aGlzLnRpY2tMaW5lR3JvdXAudmlzaWJsZSA9IHRoaXMudGljay5lbmFibGVkO1xuICAgIHRoaXMuZ3JpZExpbmVHcm91cC52aXNpYmxlID0gdGhpcy5ncmlkTGluZS5lbmFibGVkO1xuICAgIHRoaXMudGlja0xhYmVsR3JvdXAudmlzaWJsZSA9IHRoaXMubGFiZWwuZW5hYmxlZDtcbiAgfVxuICB1cGRhdGVDcm9zc0xpbmVzKHtcbiAgICByb3RhdGlvbixcbiAgICBwYXJhbGxlbEZsaXBSb3RhdGlvbixcbiAgICByZWd1bGFyRmxpcFJvdGF0aW9uXG4gIH0pIHtcbiAgICBjb25zdCBzaWRlRmxhZyA9IHRoaXMubGFiZWwuZ2V0U2lkZUZsYWcoKTtcbiAgICBjb25zdCBhbnlTZXJpZXNBY3RpdmUgPSB0aGlzLmlzQW55U2VyaWVzQWN0aXZlKCk7XG4gICAgdGhpcy5jcm9zc0xpbmVzLmZvckVhY2goKGNyb3NzTGluZSkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY3Jvc3NMaW5lLnNpZGVGbGFnID0gLXNpZGVGbGFnO1xuICAgICAgY3Jvc3NMaW5lLmRpcmVjdGlvbiA9IHJvdGF0aW9uID09PSAtTWF0aC5QSSAvIDIgPyBcInhcIiAvKiBYICovIDogXCJ5XCIgLyogWSAqLztcbiAgICAgIGlmIChjcm9zc0xpbmUgaW5zdGFuY2VvZiBDYXJ0ZXNpYW5Dcm9zc0xpbmUpIHtcbiAgICAgICAgKF9hID0gY3Jvc3NMaW5lLmxhYmVsKS5wYXJhbGxlbCA/PyAoX2EucGFyYWxsZWwgPSB0aGlzLmxhYmVsLnBhcmFsbGVsKTtcbiAgICAgIH1cbiAgICAgIGNyb3NzTGluZS5wYXJhbGxlbEZsaXBSb3RhdGlvbiA9IHBhcmFsbGVsRmxpcFJvdGF0aW9uO1xuICAgICAgY3Jvc3NMaW5lLnJlZ3VsYXJGbGlwUm90YXRpb24gPSByZWd1bGFyRmxpcFJvdGF0aW9uO1xuICAgICAgY3Jvc3NMaW5lLnVwZGF0ZShhbnlTZXJpZXNBY3RpdmUpO1xuICAgIH0pO1xuICB9XG4gIHVwZGF0ZVRpY2tMaW5lcygpIHtcbiAgICBjb25zdCB7IHRpY2ssIGxhYmVsIH0gPSB0aGlzO1xuICAgIGNvbnN0IHNpZGVGbGFnID0gbGFiZWwuZ2V0U2lkZUZsYWcoKTtcbiAgICB0aGlzLnRpY2tMaW5lR3JvdXBTZWxlY3Rpb24uZWFjaCgobGluZSkgPT4ge1xuICAgICAgbGluZS5zdHJva2VXaWR0aCA9IHRpY2sud2lkdGg7XG4gICAgICBsaW5lLnN0cm9rZSA9IHRpY2suc3Ryb2tlO1xuICAgICAgbGluZS54MSA9IHNpZGVGbGFnICogdGhpcy5nZXRUaWNrU2l6ZSgpO1xuICAgICAgbGluZS54MiA9IDA7XG4gICAgfSk7XG4gIH1cbiAgY2FsY3VsYXRlQXZhaWxhYmxlUmFuZ2UoKSB7XG4gICAgcmV0dXJuIGZpbmRSYW5nZUV4dGVudCh0aGlzLnJhbmdlKTtcbiAgfVxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgYXZhaWxhYmxlIHJhbmdlIHdpdGggYW4gYWRkaXRpb25hbCBcImJsZWVkXCIgYmV5b25kIHRoZSBjYW52YXMgdGhhdCBlbmNvbXBhc3NlcyB0aGUgZnVsbCBheGlzIHdoZW5cbiAgICogdGhlIHZpc2libGUgcmFuZ2UgaXMgb25seSBhIHBvcnRpb24gb2YgdGhlIGF4aXMuXG4gICAqL1xuICBjYWxjdWxhdGVSYW5nZVdpdGhCbGVlZCgpIHtcbiAgICBjb25zdCB2aXNpYmxlU2NhbGUgPSAxIC8gZmluZFJhbmdlRXh0ZW50KHRoaXMudmlzaWJsZVJhbmdlKTtcbiAgICByZXR1cm4gcm91bmQodGhpcy5jYWxjdWxhdGVBdmFpbGFibGVSYW5nZSgpICogdmlzaWJsZVNjYWxlLCAyKTtcbiAgfVxuICBjYWxjdWxhdGVEb21haW4oKSB7XG4gICAgY29uc3QgdmlzaWJsZVNlcmllcyA9IHRoaXMuYm91bmRTZXJpZXMuZmlsdGVyKChzKSA9PiB0aGlzLmluY2x1ZGVJbnZpc2libGVEb21haW5zIHx8IHMuaXNFbmFibGVkKCkpO1xuICAgIGNvbnN0IGRvbWFpbnMgPSB2aXNpYmxlU2VyaWVzLmZsYXRNYXAoKHNlcmllcykgPT4gc2VyaWVzLmdldERvbWFpbih0aGlzLmRpcmVjdGlvbikpO1xuICAgIHRoaXMuc2V0RG9tYWluKGRvbWFpbnMpO1xuICB9XG4gIGdldEF4aXNUcmFuc2Zvcm0oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvdGF0aW9uOiB0b1JhZGlhbnModGhpcy5yb3RhdGlvbiksXG4gICAgICB0cmFuc2xhdGlvblg6IE1hdGguZmxvb3IodGhpcy50cmFuc2xhdGlvbi54KSxcbiAgICAgIHRyYW5zbGF0aW9uWTogTWF0aC5mbG9vcih0aGlzLnRyYW5zbGF0aW9uLnkpXG4gICAgfTtcbiAgfVxuICB1cGRhdGVQb3NpdGlvbigpIHtcbiAgICBjb25zdCB7IGNyb3NzTGluZUdyb3VwLCBheGlzR3JvdXAsIGdyaWRHcm91cCwgdHJhbnNsYXRpb24gfSA9IHRoaXM7XG4gICAgY29uc3QgeyByb3RhdGlvbiB9ID0gdGhpcy5jYWxjdWxhdGVSb3RhdGlvbnMoKTtcbiAgICBjb25zdCB0cmFuc2xhdGlvblggPSBNYXRoLmZsb29yKHRyYW5zbGF0aW9uLngpO1xuICAgIGNvbnN0IHRyYW5zbGF0aW9uWSA9IE1hdGguZmxvb3IodHJhbnNsYXRpb24ueSk7XG4gICAgY3Jvc3NMaW5lR3JvdXAuc2V0UHJvcGVydGllcyh7IHJvdGF0aW9uLCB0cmFuc2xhdGlvblgsIHRyYW5zbGF0aW9uWSB9KTtcbiAgICBncmlkR3JvdXAuc2V0UHJvcGVydGllcyh7IHJvdGF0aW9uLCB0cmFuc2xhdGlvblgsIHRyYW5zbGF0aW9uWSB9KTtcbiAgICBheGlzR3JvdXAuZGF0dW0gPSB0aGlzLmdldEF4aXNUcmFuc2Zvcm0oKTtcbiAgfVxuICB1cGRhdGVTZWNvbmRhcnlBeGlzVGlja3MoX3ByaW1hcnlUaWNrQ291bnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBRyBDaGFydHMgLSB1bmV4cGVjdGVkIGNhbGwgdG8gdXBkYXRlU2Vjb25kYXJ5QXhpc1RpY2tzKCkgLSBjaGVjayBheGVzIGNvbmZpZ3VyYXRpb24uXCIpO1xuICB9XG4gIHVwZGF0ZVNlbGVjdGlvbnMobGluZURhdGEsIGRhdGEsIHBhcmFtcykge1xuICAgIGNvbnN0IGdldERhdHVtSWQgPSAoZGF0dW0pID0+IGRhdHVtLnRpY2tJZDtcbiAgICBjb25zdCBsYWJlbHNEYXRhID0gZGF0YS5tYXAoKGQpID0+IHRoaXMuZ2V0VGlja0xhYmVsUHJvcHMoZCwgcGFyYW1zKSk7XG4gICAgdGhpcy5saW5lTm9kZS5kYXR1bSA9IGxpbmVEYXRhO1xuICAgIHRoaXMuZ3JpZExpbmVHcm91cFNlbGVjdGlvbi51cGRhdGUodGhpcy5ncmlkTGVuZ3RoID8gZGF0YSA6IFtdLCB2b2lkIDAsIGdldERhdHVtSWQpO1xuICAgIHRoaXMudGlja0xpbmVHcm91cFNlbGVjdGlvbi51cGRhdGUoZGF0YSwgdm9pZCAwLCBnZXREYXR1bUlkKTtcbiAgICB0aGlzLnRpY2tMYWJlbEdyb3VwU2VsZWN0aW9uLnVwZGF0ZShsYWJlbHNEYXRhLCB2b2lkIDAsIGdldERhdHVtSWQpO1xuICB9XG4gIHVwZGF0ZUF4aXNMaW5lKCkge1xuICAgIGNvbnN0IHsgZW5hYmxlZCwgc3Ryb2tlLCB3aWR0aDogd2lkdGgyIH0gPSB0aGlzLmxpbmU7XG4gICAgdGhpcy5saW5lTm9kZS5zZXRQcm9wZXJ0aWVzKHsgc3Ryb2tlLCBzdHJva2VXaWR0aDogZW5hYmxlZCA/IHdpZHRoMiA6IDAgfSk7XG4gIH1cbiAgdXBkYXRlR3JpZExpbmVzKHNpZGVGbGFnKSB7XG4gICAgY29uc3Qge1xuICAgICAgZ3JpZExpbmU6IHsgc3R5bGUsIHdpZHRoOiB3aWR0aDIgfSxcbiAgICAgIGdyaWRQYWRkaW5nLFxuICAgICAgZ3JpZExlbmd0aFxuICAgIH0gPSB0aGlzO1xuICAgIGlmIChncmlkTGVuZ3RoID09PSAwIHx8IHN0eWxlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmdyaWRMaW5lR3JvdXBTZWxlY3Rpb24uZWFjaCgobGluZSwgXywgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHsgc3Ryb2tlLCBsaW5lRGFzaCB9ID0gc3R5bGVbaW5kZXggJSBzdHlsZS5sZW5ndGhdO1xuICAgICAgbGluZS5zZXRQcm9wZXJ0aWVzKHtcbiAgICAgICAgeDE6IGdyaWRQYWRkaW5nLFxuICAgICAgICB4MjogLXNpZGVGbGFnICogZ3JpZExlbmd0aCArIGdyaWRQYWRkaW5nLFxuICAgICAgICBzdHJva2UsXG4gICAgICAgIHN0cm9rZVdpZHRoOiB3aWR0aDIsXG4gICAgICAgIGxpbmVEYXNoXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICB1cGRhdGVMYWJlbHMoKSB7XG4gICAgaWYgKCF0aGlzLmxhYmVsLmVuYWJsZWQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy50aWNrTGFiZWxHcm91cFNlbGVjdGlvbi5lYWNoKChub2RlLCBkYXR1bSkgPT4ge1xuICAgICAgbm9kZS5zZXRQcm9wZXJ0aWVzKGRhdHVtLCBbXG4gICAgICAgIFwiZmlsbFwiLFxuICAgICAgICBcImZvbnRGYW1pbHlcIixcbiAgICAgICAgXCJmb250U2l6ZVwiLFxuICAgICAgICBcImZvbnRTdHlsZVwiLFxuICAgICAgICBcImZvbnRXZWlnaHRcIixcbiAgICAgICAgXCJ0ZXh0XCIsXG4gICAgICAgIFwidGV4dEFsaWduXCIsXG4gICAgICAgIFwidGV4dEJhc2VsaW5lXCJcbiAgICAgIF0pO1xuICAgIH0pO1xuICB9XG4gIHVwZGF0ZVRpdGxlKHBhcmFtcykge1xuICAgIGNvbnN0IHsgdGl0bGUsIGxpbmVOb2RlLCB0aWNrTGluZUdyb3VwLCB0aWNrTGFiZWxHcm91cCB9ID0gdGhpcztcbiAgICBsZXQgc3BhY2luZyA9IDA7XG4gICAgaWYgKHRpdGxlLmVuYWJsZWQgJiYgcGFyYW1zLmFueVRpY2tWaXNpYmxlKSB7XG4gICAgICBjb25zdCB0aWNrQkJveCA9IEdyb3VwLmNvbXB1dGVDaGlsZHJlbkJCb3goW3RpY2tMaW5lR3JvdXAsIHRpY2tMYWJlbEdyb3VwLCBsaW5lTm9kZV0pO1xuICAgICAgc3BhY2luZyArPSB0aWNrQkJveC53aWR0aCArICh0aGlzLnRpY2tMYWJlbEdyb3VwLnZpc2libGUgPyAwIDogdGhpcy5zZXJpZXNBcmVhUGFkZGluZyk7XG4gICAgfVxuICAgIHRoaXMuc2V0VGl0bGVQcm9wcyh0aXRsZS5jYXB0aW9uLCB7IHNwYWNpbmcgfSk7XG4gIH1cbiAgLy8gRm9yIGZvcm1hdHRpbmcgKG5pY2Ugcm91bmRlZCkgdGljayB2YWx1ZXMuXG4gIGZvcm1hdFRpY2soZGF0dW0sIGZyYWN0aW9uRGlnaXRzLCBpbmRleCkge1xuICAgIHJldHVybiBTdHJpbmcodGhpcy5nZXRGb3JtYXR0ZXIoaW5kZXgsIHRydWUpKGRhdHVtLCBmcmFjdGlvbkRpZ2l0cykpO1xuICB9XG4gIC8vIEZvciBmb3JtYXR0aW5nIGFyYml0cmFyeSB2YWx1ZXMgYmV0d2VlbiB0aGUgdGlja3MuXG4gIGZvcm1hdERhdHVtKGRhdHVtKSB7XG4gICAgcmV0dXJuIFN0cmluZyh0aGlzLmdldEZvcm1hdHRlcigpKGRhdHVtKSk7XG4gIH1cbiAgZ2V0Rm9ybWF0dGVyKGluZGV4ID0gMCwgaXNUaWNrTGFiZWwpIHtcbiAgICBjb25zdCB7XG4gICAgICBsYWJlbCxcbiAgICAgIGxhYmVsRm9ybWF0dGVyLFxuICAgICAgZGF0dW1Gb3JtYXR0ZXIsXG4gICAgICBtb2R1bGVDdHg6IHsgY2FsbGJhY2tDYWNoZSB9XG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKGxhYmVsLmZvcm1hdHRlcikge1xuICAgICAgcmV0dXJuIChkYXR1bSwgZnJhY3Rpb25EaWdpdHMpID0+IGNhbGxiYWNrQ2FjaGUuY2FsbChsYWJlbC5mb3JtYXR0ZXIsIHsgdmFsdWU6IGRhdHVtLCBpbmRleCwgZnJhY3Rpb25EaWdpdHMgfSkgPz8gZGF0dW07XG4gICAgfSBlbHNlIGlmICghaXNUaWNrTGFiZWwgJiYgZGF0dW1Gb3JtYXR0ZXIpIHtcbiAgICAgIHJldHVybiAoZGF0dW0pID0+IGNhbGxiYWNrQ2FjaGUuY2FsbChkYXR1bUZvcm1hdHRlciwgZGF0dW0pID8/IFN0cmluZyhkYXR1bSk7XG4gICAgfSBlbHNlIGlmIChsYWJlbEZvcm1hdHRlcikge1xuICAgICAgcmV0dXJuIChkYXR1bSkgPT4gY2FsbGJhY2tDYWNoZS5jYWxsKGxhYmVsRm9ybWF0dGVyLCBkYXR1bSkgPz8gU3RyaW5nKGRhdHVtKTtcbiAgICB9XG4gICAgcmV0dXJuIChkYXR1bSkgPT4gU3RyaW5nKGRhdHVtKTtcbiAgfVxuICBnZXRCQm94KCkge1xuICAgIHJldHVybiB0aGlzLmF4aXNHcm91cC5nZXRCQm94KCk7XG4gIH1cbiAgZ2V0UmVnaW9uTm9kZSgpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGluaXRDcm9zc0xpbmUoY3Jvc3NMaW5lKSB7XG4gICAgY3Jvc3NMaW5lLnNjYWxlID0gdGhpcy5zY2FsZTtcbiAgICBjcm9zc0xpbmUuZ3JpZExlbmd0aCA9IHRoaXMuZ3JpZExlbmd0aDtcbiAgfVxuICBpc0FueVNlcmllc0FjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5ib3VuZFNlcmllcy5zb21lKChzKSA9PiB0aGlzLmluY2x1ZGVJbnZpc2libGVEb21haW5zIHx8IHMuaXNFbmFibGVkKCkpO1xuICB9XG4gIGNsaXBUaWNrTGluZXMoeCwgeSwgd2lkdGgyLCBoZWlnaHQyKSB7XG4gICAgdGhpcy50aWNrTGluZUdyb3VwLnNldENsaXBSZWN0KG5ldyBCQm94KHgsIHksIHdpZHRoMiwgaGVpZ2h0MikpO1xuICB9XG4gIGNsaXBHcmlkKHgsIHksIHdpZHRoMiwgaGVpZ2h0Mikge1xuICAgIHRoaXMuZ3JpZEdyb3VwLnNldENsaXBSZWN0KG5ldyBCQm94KHgsIHksIHdpZHRoMiwgaGVpZ2h0MikpO1xuICB9XG4gIGdldFRpdGxlRm9ybWF0dGVyUGFyYW1zKCkge1xuICAgIGNvbnN0IHsgZGlyZWN0aW9uIH0gPSB0aGlzO1xuICAgIGNvbnN0IGJvdW5kU2VyaWVzID0gW107XG4gICAgZm9yIChjb25zdCBzZXJpZXMgb2YgdGhpcy5ib3VuZFNlcmllcykge1xuICAgICAgY29uc3Qga2V5cyA9IHNlcmllcy5nZXRLZXlzKGRpcmVjdGlvbik7XG4gICAgICBjb25zdCBuYW1lcyA9IHNlcmllcy5nZXROYW1lcyhkaXJlY3Rpb24pO1xuICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwga2V5cy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIGJvdW5kU2VyaWVzLnB1c2goeyBrZXk6IGtleXNbaWR4XSwgbmFtZTogbmFtZXNbaWR4XSB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgZGlyZWN0aW9uLCBib3VuZFNlcmllcywgZGVmYXVsdFZhbHVlOiB0aGlzLnRpdGxlPy50ZXh0IH07XG4gIH1cbiAgbm9ybWFsaXNlRGF0YURvbWFpbihkKSB7XG4gICAgcmV0dXJuIHsgZG9tYWluOiBbLi4uZF0sIGNsaXBwZWQ6IGZhbHNlIH07XG4gIH1cbiAgZ2V0TGF5b3V0U3RhdGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgcmVjdDogdGhpcy5nZXRCQm94KCksXG4gICAgICBncmlkUGFkZGluZzogdGhpcy5ncmlkUGFkZGluZyxcbiAgICAgIHNlcmllc0FyZWFQYWRkaW5nOiB0aGlzLnNlcmllc0FyZWFQYWRkaW5nLFxuICAgICAgdGlja1NpemU6IHRoaXMuZ2V0VGlja1NpemUoKSxcbiAgICAgIGRpcmVjdGlvbjogdGhpcy5kaXJlY3Rpb24sXG4gICAgICBkb21haW46IHRoaXMuZGF0YURvbWFpbi5kb21haW4sXG4gICAgICBzY2FsZTogdGhpcy5zY2FsZSxcbiAgICAgIC4uLnRoaXMubGF5b3V0XG4gICAgfTtcbiAgfVxuICBnZXRNb2R1bGVNYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMubW9kdWxlTWFwO1xuICB9XG4gIGNyZWF0ZU1vZHVsZUNvbnRleHQoKSB7XG4gICAgdGhpcy5heGlzQ29udGV4dCA/PyAodGhpcy5heGlzQ29udGV4dCA9IHRoaXMuY3JlYXRlQXhpc0NvbnRleHQoKSk7XG4gICAgcmV0dXJuIHsgLi4udGhpcy5tb2R1bGVDdHgsIHBhcmVudDogdGhpcy5heGlzQ29udGV4dCB9O1xuICB9XG4gIGNyZWF0ZUF4aXNDb250ZXh0KCkge1xuICAgIGNvbnN0IHsgc2NhbGU6IHNjYWxlMiB9ID0gdGhpcztcbiAgICByZXR1cm4ge1xuICAgICAgYXhpc0lkOiB0aGlzLmlkLFxuICAgICAgc2NhbGU6IHRoaXMuc2NhbGUsXG4gICAgICBkaXJlY3Rpb246IHRoaXMuZGlyZWN0aW9uLFxuICAgICAgY29udGludW91czogQ29udGludW91c1NjYWxlLmlzKHNjYWxlMikgfHwgT3JkaW5hbFRpbWVTY2FsZS5pcyhzY2FsZTIpLFxuICAgICAga2V5czogKCkgPT4gdGhpcy5ib3VuZFNlcmllcy5mbGF0TWFwKChzKSA9PiBzLmdldEtleXModGhpcy5kaXJlY3Rpb24pKSxcbiAgICAgIHNlcmllc0tleVByb3BlcnRpZXM6ICgpID0+IHRoaXMuYm91bmRTZXJpZXMucmVkdWNlKChrZXlzLCBzZXJpZXMpID0+IHtcbiAgICAgICAgY29uc3Qgc2VyaWVzS2V5cyA9IHNlcmllcy5nZXRLZXlQcm9wZXJ0aWVzKHRoaXMuZGlyZWN0aW9uKTtcbiAgICAgICAgc2VyaWVzS2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICBpZiAoa2V5cy5pbmRleE9mKGtleSkgPCAwKSB7XG4gICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ga2V5cztcbiAgICAgIH0sIFtdKSxcbiAgICAgIHNjYWxlVmFsdWVGb3JtYXR0ZXI6IChzcGVjaWZpZXIpID0+IHRoaXMuZ2V0U2NhbGVWYWx1ZUZvcm1hdHRlcihzcGVjaWZpZXIpLFxuICAgICAgc2NhbGVCYW5kd2lkdGg6ICgpID0+IHNjYWxlMi5iYW5kd2lkdGggPz8gMCxcbiAgICAgIHNjYWxlRG9tYWluOiAoKSA9PiBzY2FsZTIuZ2V0RG9tYWluPy4oKSxcbiAgICAgIHNjYWxlQ29udmVydDogKHZhbCkgPT4gc2NhbGUyLmNvbnZlcnQodmFsKSxcbiAgICAgIHNjYWxlSW52ZXJ0OiBPcmRpbmFsVGltZVNjYWxlLmlzKHNjYWxlMikgPyAodmFsKSA9PiBzY2FsZTIuaW52ZXJ0TmVhcmVzdD8uKHZhbCkgOiAodmFsKSA9PiBzY2FsZTIuaW52ZXJ0Py4odmFsKSxcbiAgICAgIHNjYWxlSW52ZXJ0TmVhcmVzdDogKHZhbCkgPT4gc2NhbGUyLmludmVydE5lYXJlc3Q/Lih2YWwpLFxuICAgICAgc2NhbGVTdGVwOiAoKSA9PiBzY2FsZTIuc3RlcCA/PyAwLFxuICAgICAgYXR0YWNoTGFiZWw6IChub2RlKSA9PiB0aGlzLmF0dGFjaExhYmVsKG5vZGUpLFxuICAgICAgaW5SYW5nZTogKHgsIHRvbGVyYW5jZSkgPT4gdGhpcy5pblJhbmdlKHgsIHRvbGVyYW5jZSlcbiAgICB9O1xuICB9XG4gIGdldFNjYWxlVmFsdWVGb3JtYXR0ZXIoZm9ybWF0KSB7XG4gICAgY29uc3QgeyBzY2FsZTogc2NhbGUyIH0gPSB0aGlzO1xuICAgIGlmIChmb3JtYXQgJiYgc2NhbGUyICYmIHNjYWxlMi50aWNrRm9ybWF0KSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gc2NhbGUyLnRpY2tGb3JtYXQoeyBzcGVjaWZpZXI6IGZvcm1hdCB9KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgTG9nZ2VyLndhcm5PbmNlKGB0aGUgZm9ybWF0IHN0cmluZyAke2Zvcm1hdH0gaXMgaW52YWxpZCwgaWdub3JpbmcuYCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldEZvcm1hdHRlcigpO1xuICB9XG4gIGFuaW1hdGVSZWFkeVVwZGF0ZShkaWZmMikge1xuICAgIGNvbnN0IHsgYW5pbWF0aW9uTWFuYWdlciB9ID0gdGhpcy5tb2R1bGVDdHg7XG4gICAgY29uc3Qgc2VsZWN0aW9uQ3R4ID0gcHJlcGFyZUF4aXNBbmltYXRpb25Db250ZXh0KHRoaXMpO1xuICAgIGNvbnN0IGZucyA9IHByZXBhcmVBeGlzQW5pbWF0aW9uRnVuY3Rpb25zKHNlbGVjdGlvbkN0eCk7XG4gICAgZnJvbVRvTW90aW9uKHRoaXMuaWQsIFwiYXhpcy1ncm91cFwiLCBhbmltYXRpb25NYW5hZ2VyLCBbdGhpcy5heGlzR3JvdXBdLCBmbnMuZ3JvdXApO1xuICAgIGZyb21Ub01vdGlvbih0aGlzLmlkLCBcImxpbmVcIiwgYW5pbWF0aW9uTWFuYWdlciwgW3RoaXMubGluZU5vZGVdLCBmbnMubGluZSk7XG4gICAgZnJvbVRvTW90aW9uKFxuICAgICAgdGhpcy5pZCxcbiAgICAgIFwibGluZS1wYXRoc1wiLFxuICAgICAgYW5pbWF0aW9uTWFuYWdlcixcbiAgICAgIFt0aGlzLmdyaWRMaW5lR3JvdXBTZWxlY3Rpb24sIHRoaXMudGlja0xpbmVHcm91cFNlbGVjdGlvbl0sXG4gICAgICBmbnMudGljayxcbiAgICAgIChfLCBkKSA9PiBkLnRpY2tJZCxcbiAgICAgIGRpZmYyXG4gICAgKTtcbiAgICBmcm9tVG9Nb3Rpb24oXG4gICAgICB0aGlzLmlkLFxuICAgICAgXCJ0aWNrLWxhYmVsc1wiLFxuICAgICAgYW5pbWF0aW9uTWFuYWdlcixcbiAgICAgIFt0aGlzLnRpY2tMYWJlbEdyb3VwU2VsZWN0aW9uXSxcbiAgICAgIGZucy5sYWJlbCxcbiAgICAgIChfLCBkKSA9PiBkLnRpY2tJZCxcbiAgICAgIGRpZmYyXG4gICAgKTtcbiAgfVxuICByZXNldFNlbGVjdGlvbk5vZGVzKCkge1xuICAgIGNvbnN0IHsgZ3JpZExpbmVHcm91cFNlbGVjdGlvbiwgdGlja0xpbmVHcm91cFNlbGVjdGlvbiwgdGlja0xhYmVsR3JvdXBTZWxlY3Rpb24sIGxpbmVOb2RlIH0gPSB0aGlzO1xuICAgIGNvbnN0IHNlbGVjdGlvbkN0eCA9IHByZXBhcmVBeGlzQW5pbWF0aW9uQ29udGV4dCh0aGlzKTtcbiAgICByZXNldE1vdGlvbihbdGhpcy5heGlzR3JvdXBdLCByZXNldEF4aXNHcm91cEZuKCkpO1xuICAgIHJlc2V0TW90aW9uKFtncmlkTGluZUdyb3VwU2VsZWN0aW9uLCB0aWNrTGluZUdyb3VwU2VsZWN0aW9uXSwgcmVzZXRBeGlzU2VsZWN0aW9uRm4oc2VsZWN0aW9uQ3R4KSk7XG4gICAgcmVzZXRNb3Rpb24oW3RpY2tMYWJlbEdyb3VwU2VsZWN0aW9uXSwgcmVzZXRBeGlzTGFiZWxTZWxlY3Rpb25GbigpKTtcbiAgICByZXNldE1vdGlvbihbbGluZU5vZGVdLCByZXNldEF4aXNMaW5lU2VsZWN0aW9uRm4oKSk7XG4gIH1cbiAgY2FsY3VsYXRlVXBkYXRlRGlmZihwcmV2aW91cywgdGlja0RhdGEpIHtcbiAgICBjb25zdCBhZGRlZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3QgcmVtb3ZlZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3QgdGlja01hcCA9IHt9O1xuICAgIGNvbnN0IHRpY2tDb3VudCA9IE1hdGgubWF4KHByZXZpb3VzLmxlbmd0aCwgdGlja0RhdGEudGlja3MubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRpY2tDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCB0aWNrRGF0dW0gPSB0aWNrRGF0YS50aWNrc1tpXTtcbiAgICAgIGNvbnN0IHByZXYgPSBwcmV2aW91c1tpXTtcbiAgICAgIGNvbnN0IHRpY2sgPSB0aWNrRGF0dW0/LnRpY2tJZDtcbiAgICAgIHRpY2tNYXBbdGljayA/PyBwcmV2XSA9IHRpY2tEYXR1bTtcbiAgICAgIGlmIChwcmV2ID09PSB0aWNrKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHJlbW92ZWQuaGFzKHRpY2spKSB7XG4gICAgICAgIHJlbW92ZWQuZGVsZXRlKHRpY2spO1xuICAgICAgfSBlbHNlIGlmICh0aWNrKSB7XG4gICAgICAgIGFkZGVkLmFkZCh0aWNrKTtcbiAgICAgIH1cbiAgICAgIGlmIChhZGRlZC5oYXMocHJldikpIHtcbiAgICAgICAgYWRkZWQuZGVsZXRlKHByZXYpO1xuICAgICAgfSBlbHNlIGlmIChwcmV2KSB7XG4gICAgICAgIHJlbW92ZWQuYWRkKHByZXYpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBjaGFuZ2VkOiBhZGRlZC5zaXplID4gMCB8fCByZW1vdmVkLnNpemUgPiAwLCBhZGRlZCwgcmVtb3ZlZCB9O1xuICB9XG4gIGlzUmV2ZXJzZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmV2ZXJzZTtcbiAgfVxufTtcbl9BeGlzLmRlZmF1bHRUaWNrTWluU3BhY2luZyA9IDUwO1xuX0F4aXMuQ3Jvc3NMaW5lQ29uc3RydWN0b3IgPSBDYXJ0ZXNpYW5Dcm9zc0xpbmU7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgX0F4aXMucHJvdG90eXBlLCBcIm5pY2VcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgX0F4aXMucHJvdG90eXBlLCBcInJldmVyc2VcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkdfQVJSQVkpXG5dLCBfQXhpcy5wcm90b3R5cGUsIFwia2V5c1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIF9BeGlzLnByb3RvdHlwZSwgXCJpbnRlcnZhbFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIF9BeGlzLnByb3RvdHlwZSwgXCJ0aXRsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIE9ic2VydmVDaGFuZ2VzKCh0YXJnZXQsIHZhbHVlLCBvbGRWYWx1ZSkgPT4gdGFyZ2V0Lm9uR3JpZExlbmd0aENoYW5nZSh2YWx1ZSwgb2xkVmFsdWUpKVxuXSwgX0F4aXMucHJvdG90eXBlLCBcImdyaWRMZW5ndGhcIiwgMik7XG52YXIgQXhpcyA9IF9BeGlzO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9heGlzL2NhcnRlc2lhbkF4aXNMYWJlbC50c1xudmFyIENhcnRlc2lhbkF4aXNMYWJlbCA9IGNsYXNzIGV4dGVuZHMgQXhpc0xhYmVsIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmF1dG9Sb3RhdGVBbmdsZSA9IDMzNTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIENhcnRlc2lhbkF4aXNMYWJlbC5wcm90b3R5cGUsIFwiYXV0b1JvdGF0ZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKERFR1JFRSlcbl0sIENhcnRlc2lhbkF4aXNMYWJlbC5wcm90b3R5cGUsIFwiYXV0b1JvdGF0ZUFuZ2xlXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9heGlzL2NhcnRlc2lhbkF4aXMudHNcbnZhciBfQ2FydGVzaWFuQXhpcyA9IGNsYXNzIF9DYXJ0ZXNpYW5BeGlzIGV4dGVuZHMgQXhpcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50aGlja25lc3MgPSAwO1xuICB9XG4gIHN0YXRpYyBpcyh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIF9DYXJ0ZXNpYW5BeGlzO1xuICB9XG4gIGdldCBkaXJlY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucG9zaXRpb24gPT09IFwidG9wXCIgfHwgdGhpcy5wb3NpdGlvbiA9PT0gXCJib3R0b21cIiA/IFwieFwiIC8qIFggKi8gOiBcInlcIiAvKiBZICovO1xuICB9XG4gIHVwZGF0ZURpcmVjdGlvbigpIHtcbiAgICBzd2l0Y2ggKHRoaXMucG9zaXRpb24pIHtcbiAgICAgIGNhc2UgXCJ0b3BcIjpcbiAgICAgICAgdGhpcy5yb3RhdGlvbiA9IC05MDtcbiAgICAgICAgdGhpcy5sYWJlbC5taXJyb3JlZCA9IHRydWU7XG4gICAgICAgIHRoaXMubGFiZWwucGFyYWxsZWwgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgICB0aGlzLnJvdGF0aW9uID0gMDtcbiAgICAgICAgdGhpcy5sYWJlbC5taXJyb3JlZCA9IHRydWU7XG4gICAgICAgIHRoaXMubGFiZWwucGFyYWxsZWwgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYm90dG9tXCI6XG4gICAgICAgIHRoaXMucm90YXRpb24gPSAtOTA7XG4gICAgICAgIHRoaXMubGFiZWwubWlycm9yZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sYWJlbC5wYXJhbGxlbCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgdGhpcy5yb3RhdGlvbiA9IDA7XG4gICAgICAgIHRoaXMubGFiZWwubWlycm9yZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sYWJlbC5wYXJhbGxlbCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKHRoaXMuYXhpc0NvbnRleHQpIHtcbiAgICAgIHRoaXMuYXhpc0NvbnRleHQucG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuICAgICAgdGhpcy5heGlzQ29udGV4dC5kaXJlY3Rpb24gPSB0aGlzLmRpcmVjdGlvbjtcbiAgICB9XG4gIH1cbiAgdXBkYXRlKGFuaW1hdGVkKSB7XG4gICAgdGhpcy51cGRhdGVEaXJlY3Rpb24oKTtcbiAgICByZXR1cm4gc3VwZXIudXBkYXRlKGFuaW1hdGVkKTtcbiAgfVxuICBjYWxjdWxhdGVMYXlvdXQoZG9tYWluLCBwcmltYXJ5VGlja0NvdW50KSB7XG4gICAgdGhpcy51cGRhdGVEaXJlY3Rpb24oKTtcbiAgICByZXR1cm4gc3VwZXIuY2FsY3VsYXRlTGF5b3V0KGRvbWFpbiwgcHJpbWFyeVRpY2tDb3VudCk7XG4gIH1cbiAgY3JlYXRlQXhpc0NvbnRleHQoKSB7XG4gICAgcmV0dXJuIHsgLi4uc3VwZXIuY3JlYXRlQXhpc0NvbnRleHQoKSwgcG9zaXRpb246IHRoaXMucG9zaXRpb24gfTtcbiAgfVxuICBjcmVhdGVMYWJlbCgpIHtcbiAgICByZXR1cm4gbmV3IENhcnRlc2lhbkF4aXNMYWJlbCgpO1xuICB9XG4gIGdldFJlZ2lvbk5vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXhpc0dyb3VwO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgX0NhcnRlc2lhbkF4aXMucHJvdG90eXBlLCBcInRoaWNrbmVzc1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSU9OKVxuXSwgX0NhcnRlc2lhbkF4aXMucHJvdG90eXBlLCBcInBvc2l0aW9uXCIsIDIpO1xudmFyIENhcnRlc2lhbkF4aXMgPSBfQ2FydGVzaWFuQXhpcztcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvYXhpcy9jYXRlZ29yeUF4aXMudHNcbnZhciBfQ2F0ZWdvcnlBeGlzID0gY2xhc3MgX0NhdGVnb3J5QXhpcyBleHRlbmRzIENhcnRlc2lhbkF4aXMge1xuICBjb25zdHJ1Y3Rvcihtb2R1bGVDdHgsIHNjYWxlMiA9IG5ldyBCYW5kU2NhbGUoKSkge1xuICAgIHN1cGVyKG1vZHVsZUN0eCwgc2NhbGUyKTtcbiAgICB0aGlzLmdyb3VwUGFkZGluZ0lubmVyID0gMC4xO1xuICAgIHRoaXMuaW5jbHVkZUludmlzaWJsZURvbWFpbnMgPSB0cnVlO1xuICB9XG4gIHN0YXRpYyBpcyh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIF9DYXRlZ29yeUF4aXM7XG4gIH1cbiAgbm9ybWFsaXNlRGF0YURvbWFpbihkKSB7XG4gICAgY29uc3QgZG9tYWluID0gW107XG4gICAgY29uc3QgdW5pcXVlVmFsdWVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IHYgb2YgZCkge1xuICAgICAgY29uc3Qga2V5ID0gdiBpbnN0YW5jZW9mIERhdGUgPyB2LmdldFRpbWUoKSA6IHY7XG4gICAgICBpZiAoIXVuaXF1ZVZhbHVlcy5oYXMoa2V5KSkge1xuICAgICAgICB1bmlxdWVWYWx1ZXMuYWRkKGtleSk7XG4gICAgICAgIGRvbWFpbi5wdXNoKHYpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBkb21haW4sIGNsaXBwZWQ6IGZhbHNlIH07XG4gIH1cbiAgdXBkYXRlU2NhbGUoZG9tYWluKSB7XG4gICAgbGV0IHsgcGFkZGluZ0lubmVyLCBwYWRkaW5nT3V0ZXIgfSA9IHRoaXM7XG4gICAgaWYgKCFpc0Zpbml0ZU51bWJlcihwYWRkaW5nSW5uZXIpIHx8ICFpc0Zpbml0ZU51bWJlcihwYWRkaW5nT3V0ZXIpKSB7XG4gICAgICBjb25zdCBwYWRkaW5nID0gdGhpcy5yZWR1Y2VCYW5kU2NhbGVQYWRkaW5nKCk7XG4gICAgICBwYWRkaW5nSW5uZXIgPz8gKHBhZGRpbmdJbm5lciA9IHBhZGRpbmcuaW5uZXIpO1xuICAgICAgcGFkZGluZ091dGVyID8/IChwYWRkaW5nT3V0ZXIgPSBwYWRkaW5nLm91dGVyKTtcbiAgICB9XG4gICAgdGhpcy5zY2FsZS5wYWRkaW5nSW5uZXIgPSBwYWRkaW5nSW5uZXIgPz8gMDtcbiAgICB0aGlzLnNjYWxlLnBhZGRpbmdPdXRlciA9IHBhZGRpbmdPdXRlciA/PyAwO1xuICAgIHN1cGVyLnVwZGF0ZVNjYWxlKGRvbWFpbik7XG4gIH1cbiAgcmVkdWNlQmFuZFNjYWxlUGFkZGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5ib3VuZFNlcmllcy5yZWR1Y2UoXG4gICAgICAocmVzdWx0LCBzZXJpZXMpID0+IHtcbiAgICAgICAgY29uc3QgcGFkZGluZyA9IHNlcmllcy5nZXRCYW5kU2NhbGVQYWRkaW5nPy4oKTtcbiAgICAgICAgaWYgKHBhZGRpbmcpIHtcbiAgICAgICAgICBpZiAocmVzdWx0LmlubmVyID4gcGFkZGluZy5pbm5lcikge1xuICAgICAgICAgICAgcmVzdWx0LmlubmVyID0gcGFkZGluZy5pbm5lcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdC5vdXRlciA8IHBhZGRpbmcub3V0ZXIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5vdXRlciA9IHBhZGRpbmcub3V0ZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LFxuICAgICAgeyBpbm5lcjogSW5maW5pdHksIG91dGVyOiAtSW5maW5pdHkgfVxuICAgICk7XG4gIH1cbn07XG5fQ2F0ZWdvcnlBeGlzLmNsYXNzTmFtZSA9IFwiQ2F0ZWdvcnlBeGlzXCI7XG5fQ2F0ZWdvcnlBeGlzLnR5cGUgPSBcImNhdGVnb3J5XCI7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTylcbl0sIF9DYXRlZ29yeUF4aXMucHJvdG90eXBlLCBcImdyb3VwUGFkZGluZ0lubmVyXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIF9DYXRlZ29yeUF4aXMucHJvdG90eXBlLCBcInBhZGRpbmdJbm5lclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBfQ2F0ZWdvcnlBeGlzLnByb3RvdHlwZSwgXCJwYWRkaW5nT3V0ZXJcIiwgMik7XG52YXIgQ2F0ZWdvcnlBeGlzID0gX0NhdGVnb3J5QXhpcztcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvYXhpcy90cmVlLnRzXG52YXIgVHJlZU5vZGUgPSBjbGFzcyB7XG4gIC8vIGN1cnJlbnQgbnVtYmVyIGluIHNpYmxpbmcgZ3JvdXAgKGluZGV4KVxuICBjb25zdHJ1Y3RvcihsYWJlbCA9IFwiXCIsIHBhcmVudCwgbnVtYmVyMiA9IDApIHtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gICAgdGhpcy5zdWJ0cmVlTGVmdCA9IE5hTjtcbiAgICB0aGlzLnN1YnRyZWVSaWdodCA9IE5hTjtcbiAgICB0aGlzLnNjcmVlblggPSAwO1xuICAgIHRoaXMuc2NyZWVuWSA9IDA7XG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIHRoaXMubGVhZkNvdW50ID0gMDtcbiAgICB0aGlzLnByZWxpbSA9IDA7XG4gICAgdGhpcy5tb2QgPSAwO1xuICAgIHRoaXMuYW5jZXN0b3IgPSB0aGlzO1xuICAgIHRoaXMuY2hhbmdlID0gMDtcbiAgICB0aGlzLnNoaWZ0ID0gMDtcbiAgICB0aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5kZXB0aCA9IHBhcmVudCA/IHBhcmVudC5kZXB0aCArIDEgOiAwO1xuICAgIHRoaXMubnVtYmVyID0gbnVtYmVyMjtcbiAgfVxuICBnZXRMZWZ0U2libGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5udW1iZXIgPiAwICYmIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQuY2hpbGRyZW5bdGhpcy5udW1iZXIgLSAxXSA6IHZvaWQgMDtcbiAgfVxuICBnZXRMZWZ0bW9zdFNpYmxpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubnVtYmVyID4gMCAmJiB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LmNoaWxkcmVuWzBdIDogdm9pZCAwO1xuICB9XG4gIC8vIHRyYXZlcnNlIHRoZSBsZWZ0IGNvbnRvdXIgb2YgYSBzdWJ0cmVlLCByZXR1cm4gdGhlIHN1Y2Nlc3NvciBvZiB2IG9uIHRoaXMgY29udG91clxuICBuZXh0TGVmdCgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlbiA/IHRoaXMuY2hpbGRyZW5bMF0gOiB0aGlzLnRocmVhZDtcbiAgfVxuICAvLyB0cmF2ZXJzZSB0aGUgcmlnaHQgY29udG91ciBvZiBhIHN1YnRyZWUsIHJldHVybiB0aGUgc3VjY2Vzc29yIG9mIHYgb24gdGhpcyBjb250b3VyXG4gIG5leHRSaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlbiA/IHRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXSA6IHRoaXMudGhyZWFkO1xuICB9XG4gIGdldFNpYmxpbmdzKCkge1xuICAgIHJldHVybiB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LmNoaWxkcmVuLmZpbHRlcigoXywgaSkgPT4gaSAhPT0gdGhpcy5udW1iZXIpIDogW107XG4gIH1cbn07XG5mdW5jdGlvbiB0aWNrc1RvVHJlZSh0aWNrcywgcGFkMiA9IHRydWUpIHtcbiAgY29uc3Qgcm9vdCA9IG5ldyBUcmVlTm9kZSgpO1xuICBsZXQgZGVwdGggPSAwO1xuICBpZiAocGFkMikge1xuICAgIHRpY2tzLmZvckVhY2goKHRpY2spID0+IGRlcHRoID0gTWF0aC5tYXgoZGVwdGgsIHRpY2subGFiZWxzLmxlbmd0aCkpO1xuICB9XG4gIHRpY2tzLmZvckVhY2goKHRpY2spID0+IHtcbiAgICBpZiAocGFkMikge1xuICAgICAgd2hpbGUgKHRpY2subGFiZWxzLmxlbmd0aCA8IGRlcHRoKSB7XG4gICAgICAgIHRpY2subGFiZWxzLnVuc2hpZnQoXCJcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGluc2VydFRpY2socm9vdCwgdGljayk7XG4gIH0pO1xuICByZXR1cm4gcm9vdDtcbn1cbmZ1bmN0aW9uIGluc2VydFRpY2socm9vdCwgdGljaykge1xuICBjb25zdCBwYXRoUGFydHMgPSB0aWNrLmxhYmVscy5zbGljZSgpLnJldmVyc2UoKTtcbiAgY29uc3QgbGFzdFBhcnRJbmRleCA9IHBhdGhQYXJ0cy5sZW5ndGggLSAxO1xuICBwYXRoUGFydHMuZm9yRWFjaCgocGF0aFBhcnQsIHBhcnRJbmRleCkgPT4ge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gcm9vdC5jaGlsZHJlbjtcbiAgICBjb25zdCBleGlzdGluZ05vZGUgPSBjaGlsZHJlbi5maW5kKChjaGlsZCkgPT4gY2hpbGQubGFiZWwgPT09IHBhdGhQYXJ0KTtcbiAgICBjb25zdCBpc05vdExlYWYgPSBwYXJ0SW5kZXggIT09IGxhc3RQYXJ0SW5kZXg7XG4gICAgaWYgKGV4aXN0aW5nTm9kZSAmJiBpc05vdExlYWYpIHtcbiAgICAgIHJvb3QgPSBleGlzdGluZ05vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBuZXcgVHJlZU5vZGUocGF0aFBhcnQsIHJvb3QpO1xuICAgICAgbm9kZS5udW1iZXIgPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICBjaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgaWYgKGlzTm90TGVhZikge1xuICAgICAgICByb290ID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gbW92ZVN1YnRyZWUod20sIHdwLCBzaGlmdCkge1xuICBjb25zdCBzdWJ0cmVlcyA9IHdwLm51bWJlciAtIHdtLm51bWJlcjtcbiAgY29uc3QgcmF0aW8yID0gc2hpZnQgLyBzdWJ0cmVlcztcbiAgd3AuY2hhbmdlIC09IHJhdGlvMjtcbiAgd3Auc2hpZnQgKz0gc2hpZnQ7XG4gIHdtLmNoYW5nZSArPSByYXRpbzI7XG4gIHdwLnByZWxpbSArPSBzaGlmdDtcbiAgd3AubW9kICs9IHNoaWZ0O1xufVxuZnVuY3Rpb24gYW5jZXN0b3IodmltLCB2LCBkZWZhdWx0QW5jZXN0b3IpIHtcbiAgcmV0dXJuIHYuZ2V0U2libGluZ3MoKS5pbmRleE9mKHZpbS5hbmNlc3RvcikgPj0gMCA/IHZpbS5hbmNlc3RvciA6IGRlZmF1bHRBbmNlc3Rvcjtcbn1cbmZ1bmN0aW9uIGV4ZWN1dGVTaGlmdHModikge1xuICBjb25zdCBjaGlsZHJlbiA9IHYuY2hpbGRyZW47XG4gIGlmIChjaGlsZHJlbikge1xuICAgIGxldCBzaGlmdCA9IDA7XG4gICAgbGV0IGNoYW5nZSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjb25zdCB3ID0gY2hpbGRyZW5baV07XG4gICAgICB3LnByZWxpbSArPSBzaGlmdDtcbiAgICAgIHcubW9kICs9IHNoaWZ0O1xuICAgICAgY2hhbmdlICs9IHcuY2hhbmdlO1xuICAgICAgc2hpZnQgKz0gdy5zaGlmdCArIGNoYW5nZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFwcG9ydGlvbih2LCBkZWZhdWx0QW5jZXN0b3IsIGRpc3RhbmNlMykge1xuICBjb25zdCB3ID0gdi5nZXRMZWZ0U2libGluZygpO1xuICBpZiAodykge1xuICAgIGxldCB2b3AgPSB2O1xuICAgIGxldCB2aXAgPSB2O1xuICAgIGxldCB2aW0gPSB3O1xuICAgIGxldCB2b20gPSB2aXAuZ2V0TGVmdG1vc3RTaWJsaW5nKCk7XG4gICAgbGV0IHNpcCA9IHZpcC5tb2Q7XG4gICAgbGV0IHNvcCA9IHZvcC5tb2Q7XG4gICAgbGV0IHNpbSA9IHZpbS5tb2Q7XG4gICAgbGV0IHNvbSA9IHZvbS5tb2Q7XG4gICAgd2hpbGUgKHZpbS5uZXh0UmlnaHQoKSAmJiB2aXAubmV4dExlZnQoKSkge1xuICAgICAgdmltID0gdmltLm5leHRSaWdodCgpO1xuICAgICAgdmlwID0gdmlwLm5leHRMZWZ0KCk7XG4gICAgICB2b20gPSB2b20ubmV4dExlZnQoKTtcbiAgICAgIHZvcCA9IHZvcC5uZXh0UmlnaHQoKTtcbiAgICAgIHZvcC5hbmNlc3RvciA9IHY7XG4gICAgICBjb25zdCBzaGlmdCA9IHZpbS5wcmVsaW0gKyBzaW0gLSAodmlwLnByZWxpbSArIHNpcCkgKyBkaXN0YW5jZTM7XG4gICAgICBpZiAoc2hpZnQgPiAwKSB7XG4gICAgICAgIG1vdmVTdWJ0cmVlKGFuY2VzdG9yKHZpbSwgdiwgZGVmYXVsdEFuY2VzdG9yKSwgdiwgc2hpZnQpO1xuICAgICAgICBzaXAgKz0gc2hpZnQ7XG4gICAgICAgIHNvcCArPSBzaGlmdDtcbiAgICAgIH1cbiAgICAgIHNpbSArPSB2aW0ubW9kO1xuICAgICAgc2lwICs9IHZpcC5tb2Q7XG4gICAgICBzb20gKz0gdm9tLm1vZDtcbiAgICAgIHNvcCArPSB2b3AubW9kO1xuICAgIH1cbiAgICBpZiAodmltLm5leHRSaWdodCgpICYmICF2b3AubmV4dFJpZ2h0KCkpIHtcbiAgICAgIHZvcC50aHJlYWQgPSB2aW0ubmV4dFJpZ2h0KCk7XG4gICAgICB2b3AubW9kICs9IHNpbSAtIHNvcDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHZpcC5uZXh0TGVmdCgpICYmICF2b20ubmV4dExlZnQoKSkge1xuICAgICAgICB2b20udGhyZWFkID0gdmlwLm5leHRMZWZ0KCk7XG4gICAgICAgIHZvbS5tb2QgKz0gc2lwIC0gc29tO1xuICAgICAgfVxuICAgICAgZGVmYXVsdEFuY2VzdG9yID0gdjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlZmF1bHRBbmNlc3Rvcjtcbn1cbmZ1bmN0aW9uIGZpcnN0V2Fsayhub2RlLCBkaXN0YW5jZTMpIHtcbiAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgbGV0IGRlZmF1bHRBbmNlc3RvciA9IGNoaWxkcmVuWzBdO1xuICAgIGNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICBmaXJzdFdhbGsoY2hpbGQsIGRpc3RhbmNlMyk7XG4gICAgICBkZWZhdWx0QW5jZXN0b3IgPSBhcHBvcnRpb24oY2hpbGQsIGRlZmF1bHRBbmNlc3RvciwgZGlzdGFuY2UzKTtcbiAgICB9KTtcbiAgICBleGVjdXRlU2hpZnRzKG5vZGUpO1xuICAgIGNvbnN0IG1pZHBvaW50ID0gKGNoaWxkcmVuWzBdLnByZWxpbSArIGNoaWxkcmVuLmF0KC0xKS5wcmVsaW0pIC8gMjtcbiAgICBjb25zdCBsZWZ0U2libGluZyA9IG5vZGUuZ2V0TGVmdFNpYmxpbmcoKTtcbiAgICBpZiAobGVmdFNpYmxpbmcpIHtcbiAgICAgIG5vZGUucHJlbGltID0gbGVmdFNpYmxpbmcucHJlbGltICsgZGlzdGFuY2UzO1xuICAgICAgbm9kZS5tb2QgPSBub2RlLnByZWxpbSAtIG1pZHBvaW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnByZWxpbSA9IG1pZHBvaW50O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBsZWZ0U2libGluZyA9IG5vZGUuZ2V0TGVmdFNpYmxpbmcoKTtcbiAgICBub2RlLnByZWxpbSA9IGxlZnRTaWJsaW5nID8gbGVmdFNpYmxpbmcucHJlbGltICsgZGlzdGFuY2UzIDogMDtcbiAgfVxufVxudmFyIERpbWVuc2lvbnMgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMudG9wID0gSW5maW5pdHk7XG4gICAgdGhpcy5yaWdodCA9IC1JbmZpbml0eTtcbiAgICB0aGlzLmJvdHRvbSA9IC1JbmZpbml0eTtcbiAgICB0aGlzLmxlZnQgPSBJbmZpbml0eTtcbiAgfVxuICB1cGRhdGUobm9kZSwgeHkpIHtcbiAgICBjb25zdCB7IHgsIHkgfSA9IHh5KG5vZGUpO1xuICAgIGlmICh4ID4gdGhpcy5yaWdodCkge1xuICAgICAgdGhpcy5yaWdodCA9IHg7XG4gICAgfVxuICAgIGlmICh4IDwgdGhpcy5sZWZ0KSB7XG4gICAgICB0aGlzLmxlZnQgPSB4O1xuICAgIH1cbiAgICBpZiAoeSA+IHRoaXMuYm90dG9tKSB7XG4gICAgICB0aGlzLmJvdHRvbSA9IHk7XG4gICAgfVxuICAgIGlmICh5IDwgdGhpcy50b3ApIHtcbiAgICAgIHRoaXMudG9wID0geTtcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBzZWNvbmRXYWxrKHYsIG0sIGxheW91dCkge1xuICB2LnggPSB2LnByZWxpbSArIG07XG4gIHYueSA9IHYuZGVwdGg7XG4gIGxheW91dC51cGRhdGUodik7XG4gIHYuY2hpbGRyZW4uZm9yRWFjaCgodykgPT4gc2Vjb25kV2Fsayh3LCBtICsgdi5tb2QsIGxheW91dCkpO1xufVxuZnVuY3Rpb24gdGhpcmRXYWxrKHYpIHtcbiAgY29uc3QgY2hpbGRyZW4gPSB2LmNoaWxkcmVuO1xuICBsZXQgbGVhZkNvdW50ID0gMDtcbiAgY2hpbGRyZW4uZm9yRWFjaCgodykgPT4ge1xuICAgIHRoaXJkV2Fsayh3KTtcbiAgICBpZiAody5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIGxlYWZDb3VudCArPSB3LmxlYWZDb3VudDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGVhZkNvdW50Kys7XG4gICAgfVxuICB9KTtcbiAgdi5sZWFmQ291bnQgPSBsZWFmQ291bnQ7XG4gIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICB2LnN1YnRyZWVMZWZ0ID0gY2hpbGRyZW5bMF0uc3VidHJlZUxlZnQ7XG4gICAgdi5zdWJ0cmVlUmlnaHQgPSBjaGlsZHJlblt2LmNoaWxkcmVuLmxlbmd0aCAtIDFdLnN1YnRyZWVSaWdodDtcbiAgICB2LnggPSAodi5zdWJ0cmVlTGVmdCArIHYuc3VidHJlZVJpZ2h0KSAvIDI7XG4gIH0gZWxzZSB7XG4gICAgdi5zdWJ0cmVlTGVmdCA9IHYueDtcbiAgICB2LnN1YnRyZWVSaWdodCA9IHYueDtcbiAgfVxufVxuZnVuY3Rpb24gdHJlZUxheW91dChyb290KSB7XG4gIGNvbnN0IGxheW91dCA9IG5ldyBUcmVlTGF5b3V0KCk7XG4gIGZpcnN0V2Fsayhyb290LCAxKTtcbiAgc2Vjb25kV2Fsayhyb290LCAtcm9vdC5wcmVsaW0sIGxheW91dCk7XG4gIHRoaXJkV2Fsayhyb290KTtcbiAgcmV0dXJuIGxheW91dDtcbn1cbnZhciBUcmVlTGF5b3V0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSBuZXcgRGltZW5zaW9ucygpO1xuICAgIHRoaXMubGVhZkNvdW50ID0gMDtcbiAgICB0aGlzLm5vZGVzID0gW107XG4gICAgLy8gT25lIG1pZ2h0IHdhbnQgdG8gcHJvY2VzcyBsZWFmIG5vZGVzIHNlcGFyYXRlbHkgZnJvbSB0aGUgcmVzdCBvZiB0aGUgdHJlZS5cbiAgICAvLyBGb3IgZXhhbXBsZSwgcG9zaXRpb24gbGFiZWxzIGNvcnJlc3BvbmRpbmcgdG8gbGVhZnMgdmVydGljYWxseSwgcmF0aGVyIHRoYW4gaG9yaXpvbnRhbGx5LlxuICAgIHRoaXMubGVhZk5vZGVzID0gW107XG4gICAgdGhpcy5ub25MZWFmTm9kZXMgPSBbXTtcbiAgICB0aGlzLmRlcHRoID0gMDtcbiAgfVxuICB1cGRhdGUobm9kZSkge1xuICAgIHRoaXMuZGltZW5zaW9ucy51cGRhdGUobm9kZSwgKG4pID0+ICh7IHg6IG4ueCwgeTogbi55IH0pKTtcbiAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHRoaXMubm9uTGVhZk5vZGVzLnB1c2gobm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGVhZkNvdW50Kys7XG4gICAgICB0aGlzLmxlYWZOb2Rlcy5wdXNoKG5vZGUpO1xuICAgIH1cbiAgICBpZiAobm9kZS5kZXB0aCA+IHRoaXMuZGVwdGgpIHtcbiAgICAgIHRoaXMuZGVwdGggPSBub2RlLmRlcHRoO1xuICAgIH1cbiAgICB0aGlzLm5vZGVzLnB1c2gobm9kZSk7XG4gIH1cbiAgcmVzaXplKHdpZHRoMiwgaGVpZ2h0Miwgc2hpZnRYID0gMCwgc2hpZnRZID0gMCwgZmxpcFggPSBmYWxzZSkge1xuICAgIGNvbnN0IHhTdGVwcyA9IHRoaXMubGVhZkNvdW50IC0gMTtcbiAgICBjb25zdCB5U3RlcHMgPSB0aGlzLmRlcHRoO1xuICAgIGNvbnN0IGRpbWVuc2lvbnMgPSB0aGlzLmRpbWVuc2lvbnM7XG4gICAgbGV0IHNjYWxpbmdYID0gMTtcbiAgICBsZXQgc2NhbGluZ1kgPSAxO1xuICAgIGlmICh3aWR0aDIgPiAwICYmIHhTdGVwcykge1xuICAgICAgY29uc3QgZXhpc3RpbmdTcGFjaW5nWCA9IChkaW1lbnNpb25zLnJpZ2h0IC0gZGltZW5zaW9ucy5sZWZ0KSAvIHhTdGVwcztcbiAgICAgIGNvbnN0IGRlc2lyZWRTcGFjaW5nWCA9IHdpZHRoMiAvIHhTdGVwcztcbiAgICAgIHNjYWxpbmdYID0gZGVzaXJlZFNwYWNpbmdYIC8gZXhpc3RpbmdTcGFjaW5nWDtcbiAgICAgIGlmIChmbGlwWCkge1xuICAgICAgICBzY2FsaW5nWCA9IC1zY2FsaW5nWDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGhlaWdodDIgPiAwICYmIHlTdGVwcykge1xuICAgICAgY29uc3QgZXhpc3RpbmdTcGFjaW5nWSA9IChkaW1lbnNpb25zLmJvdHRvbSAtIGRpbWVuc2lvbnMudG9wKSAvIHlTdGVwcztcbiAgICAgIGNvbnN0IGRlc2lyZWRTcGFjaW5nWSA9IGhlaWdodDIgLyB5U3RlcHM7XG4gICAgICBzY2FsaW5nWSA9IGRlc2lyZWRTcGFjaW5nWSAvIGV4aXN0aW5nU3BhY2luZ1k7XG4gICAgfVxuICAgIGNvbnN0IHNjcmVlbkRpbWVuc2lvbnMgPSBuZXcgRGltZW5zaW9ucygpO1xuICAgIHRoaXMubm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgbm9kZS5zY3JlZW5YID0gbm9kZS54ICogc2NhbGluZ1g7XG4gICAgICBub2RlLnNjcmVlblkgPSBub2RlLnkgKiBzY2FsaW5nWTtcbiAgICAgIHNjcmVlbkRpbWVuc2lvbnMudXBkYXRlKG5vZGUsIChuKSA9PiAoeyB4OiBuLnNjcmVlblgsIHk6IG4uc2NyZWVuWSB9KSk7XG4gICAgfSk7XG4gICAgY29uc3Qgb2Zmc2V0WCA9IC1zY3JlZW5EaW1lbnNpb25zLmxlZnQ7XG4gICAgY29uc3Qgb2Zmc2V0WSA9IC1zY3JlZW5EaW1lbnNpb25zLnRvcDtcbiAgICB0aGlzLm5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgIG5vZGUuc2NyZWVuWCArPSBvZmZzZXRYICsgc2hpZnRYO1xuICAgICAgbm9kZS5zY3JlZW5ZICs9IG9mZnNldFkgKyBzaGlmdFk7XG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2F4aXMvZ3JvdXBlZENhdGVnb3J5QXhpcy50c1xudmFyIEdyb3VwZWRDYXRlZ29yeUF4aXNMYWJlbCA9IGNsYXNzIGV4dGVuZHMgQXhpc0xhYmVsIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmdyaWQgPSBmYWxzZTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBHcm91cGVkQ2F0ZWdvcnlBeGlzTGFiZWwucHJvdG90eXBlLCBcImdyaWRcIiwgMik7XG52YXIgR3JvdXBlZENhdGVnb3J5QXhpcyA9IGNsYXNzIGV4dGVuZHMgQ2FydGVzaWFuQXhpcyB7XG4gIGNvbnN0cnVjdG9yKG1vZHVsZUN0eCkge1xuICAgIGNvbnN0IHNjYWxlMiA9IG5ldyBCYW5kU2NhbGUoKTtcbiAgICBzY2FsZTIucGFkZGluZ091dGVyID0gMC4xO1xuICAgIHNjYWxlMi5wYWRkaW5nSW5uZXIgPSBzY2FsZTIucGFkZGluZ091dGVyICogMjtcbiAgICBzdXBlcihtb2R1bGVDdHgsIHNjYWxlMik7XG4gICAgLy8gTGFiZWwgc2NhbGUgKGxhYmVscyBhcmUgcG9zaXRpb25lZCBiZXR3ZWVuIHRpY2tzLCB0aWNrIGNvdW50ID0gbGFiZWwgY291bnQgKyAxKS5cbiAgICAvLyBXZSBkb24ndCBjYWxsIGlzIGBsYWJlbFNjYWxlYCBmb3IgY29uc2lzdGVuY3kgd2l0aCBvdGhlciBheGVzLlxuICAgIHRoaXMudGlja1NjYWxlID0gbmV3IEJhbmRTY2FsZSgpO1xuICAgIHRoaXMubGluZSA9IG5ldyBBeGlzTGluZSgpO1xuICAgIHRoaXMubGFiZWwgPSBuZXcgR3JvdXBlZENhdGVnb3J5QXhpc0xhYmVsKCk7XG4gICAgdGhpcy5sYWJlbENvbG9yID0gXCJyZ2JhKDg3LCA4NywgODcsIDEpXCI7XG4gICAgdGhpcy5pbmNsdWRlSW52aXNpYmxlRG9tYWlucyA9IHRydWU7XG4gICAgY29uc3QgeyB0aWNrTGluZUdyb3VwLCB0aWNrTGFiZWxHcm91cCwgZ3JpZExpbmVHcm91cCwgdGlja1NjYWxlIH0gPSB0aGlzO1xuICAgIHRpY2tTY2FsZS5wYWRkaW5nSW5uZXIgPSAxO1xuICAgIHRpY2tTY2FsZS5wYWRkaW5nT3V0ZXIgPSAwO1xuICAgIHRoaXMuZ3JpZExpbmVTZWxlY3Rpb24gPSBTZWxlY3Rpb24uc2VsZWN0KGdyaWRMaW5lR3JvdXAsIExpbmUpO1xuICAgIHRoaXMuYXhpc0xpbmVTZWxlY3Rpb24gPSBTZWxlY3Rpb24uc2VsZWN0KHRpY2tMaW5lR3JvdXAsIExpbmUpO1xuICAgIHRoaXMuc2VwYXJhdG9yU2VsZWN0aW9uID0gU2VsZWN0aW9uLnNlbGVjdCh0aWNrTGluZUdyb3VwLCBMaW5lKTtcbiAgICB0aGlzLmxhYmVsU2VsZWN0aW9uID0gU2VsZWN0aW9uLnNlbGVjdCh0aWNrTGFiZWxHcm91cCwgVHJhbnNmb3JtYWJsZVRleHQpO1xuICAgIHRoaXMubGluZU5vZGUudmlzaWJsZSA9IGZhbHNlO1xuICB9XG4gIHVwZGF0ZVJhbmdlKCkge1xuICAgIGNvbnN0IHsgcmFuZ2U6IHJyLCB2aXNpYmxlUmFuZ2U6IHZyLCBzY2FsZTogc2NhbGUyIH0gPSB0aGlzO1xuICAgIGNvbnN0IHNwYW4gPSAocnJbMV0gLSByclswXSkgLyAodnJbMV0gLSB2clswXSk7XG4gICAgY29uc3Qgc2hpZnQgPSBzcGFuICogdnJbMF07XG4gICAgY29uc3Qgc3RhcnQyID0gcnJbMF0gLSBzaGlmdDtcbiAgICB0aGlzLnRpY2tTY2FsZS5yYW5nZSA9IHNjYWxlMi5yYW5nZSA9IFtzdGFydDIsIHN0YXJ0MiArIHNwYW5dO1xuICAgIHRoaXMucmVzaXplVGlja1RyZWUoKTtcbiAgfVxuICByZXNpemVUaWNrVHJlZSgpIHtcbiAgICBjb25zdCBzID0gdGhpcy5zY2FsZTtcbiAgICBjb25zdCByYW5nZTMgPSBzLmRvbWFpbi5sZW5ndGggPyBbcy5jb252ZXJ0KHMuZG9tYWluWzBdKSwgcy5jb252ZXJ0KHMuZG9tYWluW3MuZG9tYWluLmxlbmd0aCAtIDFdKV0gOiBzLnJhbmdlO1xuICAgIGNvbnN0IGxheW91dCA9IHRoaXMudGlja1RyZWVMYXlvdXQ7XG4gICAgY29uc3QgbGluZUhlaWdodCA9IHRoaXMubGluZUhlaWdodDtcbiAgICBpZiAobGF5b3V0KSB7XG4gICAgICBsYXlvdXQucmVzaXplKFxuICAgICAgICBNYXRoLmFicyhyYW5nZTNbMV0gLSByYW5nZTNbMF0pLFxuICAgICAgICBsYXlvdXQuZGVwdGggKiBsaW5lSGVpZ2h0LFxuICAgICAgICAoTWF0aC5taW4ocmFuZ2UzWzBdLCByYW5nZTNbMV0pIHx8IDApICsgKHMuYmFuZHdpZHRoID8/IDApIC8gMixcbiAgICAgICAgLWxheW91dC5kZXB0aCAqIGxpbmVIZWlnaHQsXG4gICAgICAgIHJhbmdlM1sxXSAtIHJhbmdlM1swXSA8IDBcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGdldCBsaW5lSGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmxhYmVsLmZvbnRTaXplICogMS41O1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbGVuZ3RoIG9mIHRoZSBncmlkLiBUaGUgZ3JpZCBpcyBvbmx5IHZpc2libGUgaW4gY2FzZSBvZiBhIG5vbi16ZXJvIHZhbHVlLlxuICAgKi9cbiAgb25HcmlkVmlzaWJpbGl0eUNoYW5nZSgpIHtcbiAgICB0aGlzLmdyaWRMaW5lU2VsZWN0aW9uLmNsZWFyKCk7XG4gICAgdGhpcy5sYWJlbFNlbGVjdGlvbi5jbGVhcigpO1xuICB9XG4gIGNhbGN1bGF0ZURvbWFpbigpIHtcbiAgICBjb25zdCB7IGRpcmVjdGlvbiB9ID0gdGhpcztcbiAgICBsZXQgaXNOdW1lcmljWCA9IG51bGw7XG4gICAgY29uc3QgZmxhdERvbWFpbnMgPSB0aGlzLmJvdW5kU2VyaWVzLmZpbHRlcigocykgPT4gcy52aXNpYmxlKS5mbGF0TWFwKChzZXJpZXMpID0+IHtcbiAgICAgIGlmIChkaXJlY3Rpb24gPT09IFwieVwiIC8qIFkgKi8gfHwgaXNOdW1lcmljWCkge1xuICAgICAgICByZXR1cm4gc2VyaWVzLmdldERvbWFpbihkaXJlY3Rpb24pO1xuICAgICAgfVxuICAgICAgaWYgKGlzTnVtZXJpY1ggPT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgZG9tYWluMiA9IHNlcmllcy5nZXREb21haW4oZGlyZWN0aW9uKTtcbiAgICAgICAgaXNOdW1lcmljWCA9IGlzTnVtYmVyKGRvbWFpbjJbMF0pO1xuICAgICAgICByZXR1cm4gZG9tYWluMjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbXTtcbiAgICB9KTtcbiAgICB0aGlzLnNldERvbWFpbihleHRlbnQoZmxhdERvbWFpbnMpID8/IHVuaXF1ZShmbGF0RG9tYWlucykpO1xuICAgIGNvbnN0IHsgZG9tYWluIH0gPSB0aGlzLmRhdGFEb21haW47XG4gICAgdGhpcy50aWNrVHJlZUxheW91dCA9IHRyZWVMYXlvdXQodGlja3NUb1RyZWUoZG9tYWluKSk7XG4gICAgdGhpcy50aWNrU2NhbGUuZG9tYWluID0gZG9tYWluLmNvbmNhdChcIlwiKTtcbiAgICB0aGlzLnJlc2l6ZVRpY2tUcmVlKCk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMvcmVtb3Zlcy91cGRhdGVzIHRoZSBzY2VuZSBncmFwaCBub2RlcyB0aGF0IGNvbnN0aXR1dGUgdGhlIGF4aXMuXG4gICAqIFN1cHBvc2VkIHRvIGJlIGNhbGxlZCBfbWFudWFsbHlfIGFmdGVyIGNoYW5naW5nIF9hbnlfIG9mIHRoZSBheGlzIHByb3BlcnRpZXMuXG4gICAqIFRoaXMgYWxsb3dzIHRvIGJ1bGsgc2V0IGF4aXMgcHJvcGVydGllcyBiZWZvcmUgdXBkYXRpbmcgdGhlIG5vZGVzLlxuICAgKiBUaGUgbm9kZSBjaGFuZ2VzIG1hZGUgYnkgdGhpcyBtZXRob2QgYXJlIHJlbmRlcmVkIG9uIHRoZSBuZXh0IGFuaW1hdGlvbiBmcmFtZS5cbiAgICogV2UgY291bGQgc2NoZWR1bGUgdGhpcyBtZXRob2QgY2FsbCBhdXRvbWF0aWNhbGx5IG9uIHRoZSBuZXh0IGFuaW1hdGlvbiBmcmFtZVxuICAgKiB3aGVuIGFueSBvZiB0aGUgYXhpcyBwcm9wZXJ0aWVzIGNoYW5nZSAodGhlIHdheSB3ZSBkbyB3aGVuIHByb3BlcnRpZXMgb2Ygc2NlbmUgZ3JhcGgnc1xuICAgKiBub2RlcyBjaGFuZ2UpLCBidXQgdGhpcyB3aWxsIG1lYW4gdGhhdCB3ZSBmaXJzdCB3YWl0IGZvciB0aGUgbmV4dCBhbmltYXRpb25cbiAgICogZnJhbWUgdG8gbWFrZSBjaGFuZ2VzIHRvIHRoZSBub2RlcyBvZiB0aGUgYXhpcywgdGhlbiB3YWl0IGZvciBhbm90aGVyIGFuaW1hdGlvblxuICAgKiBmcmFtZSB0byByZW5kZXIgdGhvc2UgY2hhbmdlcy4gSXQncyBuaWNlIHRvIGhhdmUgZXZlcnl0aGluZyB1cGRhdGUgYXV0b21hdGljYWxseSxcbiAgICogYnV0IHRoaXMgZXh0cmEgbGV2ZWwgb2YgYXN5bmMgaW5kaXJlY3Rpb24gd2lsbCBub3QganVzdCBpbnRyb2R1Y2UgYW4gdW53YW50ZWQgZGVsYXksXG4gICAqIGl0IHdpbGwgYWxzbyBtYWtlIGl0IGhhcmRlciB0byByZWFzb24gYWJvdXQgdGhlIHByb2dyYW0uXG4gICAqL1xuICB1cGRhdGUoKSB7XG4gICAgaWYgKCF0aGlzLmNvbXB1dGVkTGF5b3V0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudXBkYXRlUG9zaXRpb24oKTtcbiAgICB0aGlzLnVwZGF0ZVRpdGxlQ2FwdGlvbigpO1xuICAgIHRoaXMudXBkYXRlQ2F0ZWdvcnlMYWJlbHMoKTtcbiAgICB0aGlzLnVwZGF0ZVNlcGFyYXRvcnMoKTtcbiAgICB0aGlzLnVwZGF0ZUF4aXNMaW5lcygpO1xuICAgIHRoaXMudXBkYXRlQ2F0ZWdvcnlHcmlkTGluZXMoKTtcbiAgICB0aGlzLnJlc2V0U2VsZWN0aW9uTm9kZXMoKTtcbiAgfVxuICB1cGRhdGVUaXRsZUNhcHRpb24oKSB7XG4gICAgdGhpcy50aXRsZS5jYXB0aW9uLm5vZGUudmlzaWJsZSA9IGZhbHNlO1xuICB9XG4gIHVwZGF0ZUNhdGVnb3J5TGFiZWxzKCkge1xuICAgIGlmICghdGhpcy5jb21wdXRlZExheW91dClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IHRpY2tMYWJlbExheW91dCB9ID0gdGhpcy5jb21wdXRlZExheW91dDtcbiAgICBjb25zdCBsYWJlbFNlbGVjdGlvbiA9IHRoaXMubGFiZWxTZWxlY3Rpb24udXBkYXRlKHRpY2tMYWJlbExheW91dCk7XG4gICAgbGFiZWxTZWxlY3Rpb24uZWFjaCgobm9kZSwgZGF0dW0pID0+IHtcbiAgICAgIG5vZGUuc2V0UHJvcGVydGllcyhkYXR1bSk7XG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlU2VwYXJhdG9ycygpIHtcbiAgICBpZiAoIXRoaXMuY29tcHV0ZWRMYXlvdXQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBzZXBhcmF0b3JMYXlvdXQgfSA9IHRoaXMuY29tcHV0ZWRMYXlvdXQ7XG4gICAgY29uc3QgeyByYW5nZTogcmFuZ2UzIH0gPSB0aGlzO1xuICAgIGNvbnN0IGVwc2lsb24yID0gMWUtNztcbiAgICBjb25zdCBzZXBhcmF0b3JTZWxlY3Rpb24gPSB0aGlzLnNlcGFyYXRvclNlbGVjdGlvbi51cGRhdGUoc2VwYXJhdG9yTGF5b3V0KTtcbiAgICBzZXBhcmF0b3JTZWxlY3Rpb24uZWFjaCgobGluZSwgZGF0dW0pID0+IHtcbiAgICAgIGxpbmUueDEgPSBkYXR1bS54MTtcbiAgICAgIGxpbmUueDIgPSBkYXR1bS54MjtcbiAgICAgIGxpbmUueTEgPSBkYXR1bS55O1xuICAgICAgbGluZS55MiA9IGRhdHVtLnk7XG4gICAgICBsaW5lLnZpc2libGUgPSB0aGlzLnRpY2suZW5hYmxlZCAmJiBkYXR1bS55ID49IHJhbmdlM1swXSAtIGVwc2lsb24yICYmIGRhdHVtLnkgPD0gcmFuZ2UzWzFdICsgZXBzaWxvbjI7XG4gICAgICBsaW5lLnN0cm9rZSA9IHRoaXMudGljay5zdHJva2U7XG4gICAgICBsaW5lLnN0cm9rZVdpZHRoID0gMTtcbiAgICB9KTtcbiAgfVxuICB1cGRhdGVBeGlzTGluZXMoKSB7XG4gICAgaWYgKCF0aGlzLmNvbXB1dGVkTGF5b3V0KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgYXhpc0xpbmVMYXlvdXQgfSA9IHRoaXMuY29tcHV0ZWRMYXlvdXQ7XG4gICAgY29uc3QgYXhpc0xpbmVTZWxlY3Rpb24gPSB0aGlzLmF4aXNMaW5lU2VsZWN0aW9uLnVwZGF0ZShheGlzTGluZUxheW91dCk7XG4gICAgYXhpc0xpbmVTZWxlY3Rpb24uZWFjaCgobGluZSwgZGF0dW0pID0+IHtcbiAgICAgIGxpbmUuc2V0UHJvcGVydGllcyhkYXR1bSk7XG4gICAgICBsaW5lLnN0cm9rZSA9IHRoaXMubGluZS5zdHJva2U7XG4gICAgICBsaW5lLnN0cm9rZVdpZHRoID0gdGhpcy5saW5lLndpZHRoO1xuICAgIH0pO1xuICB9XG4gIHVwZGF0ZUNhdGVnb3J5R3JpZExpbmVzKCkge1xuICAgIGNvbnN0IHsgZ3JpZExlbmd0aCwgZ3JpZExpbmUsIGxhYmVsLCByYW5nZTogcmFuZ2UzLCB0aWNrU2NhbGUgfSA9IHRoaXM7XG4gICAgY29uc3QgdGlja3MgPSB0aWNrU2NhbGUudGlja3MoKTtcbiAgICBjb25zdCBzaWRlRmxhZyA9IGxhYmVsLmdldFNpZGVGbGFnKCk7XG4gICAgY29uc3QgZ3JpZFNlbGVjdGlvbiA9IHRoaXMuZ3JpZExpbmVTZWxlY3Rpb24udXBkYXRlKGdyaWRMZW5ndGggPyB0aWNrcyA6IFtdKTtcbiAgICBpZiAoZ3JpZExlbmd0aCkge1xuICAgICAgY29uc3QgeyB3aWR0aDogd2lkdGgyLCBzdHlsZSB9ID0gZ3JpZExpbmU7XG4gICAgICBjb25zdCBzdHlsZUNvdW50ID0gc3R5bGUubGVuZ3RoO1xuICAgICAgZ3JpZFNlbGVjdGlvbi5lYWNoKChsaW5lLCBkYXR1bSwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgeSA9IE1hdGgucm91bmQodGlja1NjYWxlLmNvbnZlcnQoZGF0dW0pKTtcbiAgICAgICAgY29uc3QgeyBzdHJva2UsIGxpbmVEYXNoIH0gPSBzdHlsZVtpbmRleCAlIHN0eWxlQ291bnRdO1xuICAgICAgICBsaW5lLnZpc2libGUgPSBncmlkTGluZS5lbmFibGVkICYmIHkgPj0gcmFuZ2UzWzBdICYmIHkgPD0gcmFuZ2UzWzFdO1xuICAgICAgICBsaW5lLngxID0gMDtcbiAgICAgICAgbGluZS54MiA9IC1zaWRlRmxhZyAqIGdyaWRMZW5ndGg7XG4gICAgICAgIGxpbmUueTEgPSB5O1xuICAgICAgICBsaW5lLnkyID0geTtcbiAgICAgICAgbGluZS5zdHJva2UgPSBzdHJva2U7XG4gICAgICAgIGxpbmUuc3Ryb2tlV2lkdGggPSB3aWR0aDI7XG4gICAgICAgIGxpbmUubGluZURhc2ggPSBsaW5lRGFzaDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBjb21wdXRlTGF5b3V0KCkge1xuICAgIHRoaXMudXBkYXRlRGlyZWN0aW9uKCk7XG4gICAgdGhpcy5jYWxjdWxhdGVEb21haW4oKTtcbiAgICB0aGlzLnVwZGF0ZVJhbmdlKCk7XG4gICAgY29uc3Qge1xuICAgICAgc2NhbGU6IHNjYWxlMixcbiAgICAgIGxhYmVsLFxuICAgICAgbGFiZWw6IHsgcGFyYWxsZWwgfSxcbiAgICAgIG1vZHVsZUN0eDogeyBjYWxsYmFja0NhY2hlIH0sXG4gICAgICByYW5nZTogcmFuZ2UzLFxuICAgICAgdGl0bGUsXG4gICAgICB0aXRsZTogeyBmb3JtYXR0ZXIgPSAocCkgPT4gcC5kZWZhdWx0VmFsdWUgfSA9IHt9XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgcmFuZ2VTdGFydCA9IHNjYWxlMi5yYW5nZVswXTtcbiAgICBjb25zdCByYW5nZUVuZCA9IHNjYWxlMi5yYW5nZVsxXTtcbiAgICBjb25zdCByYW5nZUxlbmd0aCA9IE1hdGguYWJzKHJhbmdlRW5kIC0gcmFuZ2VTdGFydCk7XG4gICAgY29uc3QgYmFuZHdpZHRoID0gcmFuZ2VMZW5ndGggLyBzY2FsZTIuZG9tYWluLmxlbmd0aCB8fCAwO1xuICAgIGNvbnN0IGtlZXBFdmVyeSA9IE1hdGguY2VpbChsYWJlbC5mb250U2l6ZSAvIGJhbmR3aWR0aCk7XG4gICAgY29uc3Qgcm90YXRpb24gPSB0b1JhZGlhbnModGhpcy5yb3RhdGlvbik7XG4gICAgY29uc3QgaXNIb3Jpem9udGFsID0gTWF0aC5hYnMoTWF0aC5jb3Mocm90YXRpb24pKSA8IDFlLTg7XG4gICAgY29uc3Qgc2lkZUZsYWcgPSBsYWJlbC5nZXRTaWRlRmxhZygpO1xuICAgIGNvbnN0IGxpbmVIZWlnaHQgPSB0aGlzLmxpbmVIZWlnaHQ7XG4gICAgY29uc3QgdGlja1RyZWVMYXlvdXQgPSB0aGlzLnRpY2tUcmVlTGF5b3V0O1xuICAgIGNvbnN0IGxhYmVscyA9IHNjYWxlMi50aWNrcygpO1xuICAgIGNvbnN0IHRyZWVMYWJlbHMgPSB0aWNrVHJlZUxheW91dCA/IHRpY2tUcmVlTGF5b3V0Lm5vZGVzIDogW107XG4gICAgY29uc3QgaXNMYWJlbFRyZWUgPSB0aWNrVHJlZUxheW91dCA/IHRpY2tUcmVlTGF5b3V0LmRlcHRoID4gMSA6IGZhbHNlO1xuICAgIGNvbnN0IGlzQ2FwdGlvbkVuYWJsZWQgPSB0aXRsZT8uZW5hYmxlZCAmJiBsYWJlbHMubGVuZ3RoID4gMDtcbiAgICBjb25zdCB7IGRlZmF1bHRSb3RhdGlvbiwgY29uZmlndXJlZFJvdGF0aW9uLCBwYXJhbGxlbEZsaXBGbGFnIH0gPSBjYWxjdWxhdGVMYWJlbFJvdGF0aW9uKHtcbiAgICAgIHJvdGF0aW9uOiBsYWJlbC5yb3RhdGlvbixcbiAgICAgIHBhcmFsbGVsLFxuICAgICAgcmVndWxhckZsaXBSb3RhdGlvbjogbm9ybWFsaXplQW5nbGUzNjAocm90YXRpb24gLSBNYXRoLlBJIC8gMiksXG4gICAgICBwYXJhbGxlbEZsaXBSb3RhdGlvbjogbm9ybWFsaXplQW5nbGUzNjAocm90YXRpb24pXG4gICAgfSk7XG4gICAgY29uc3QgdGlja0xhYmVsTGF5b3V0ID0gW107XG4gICAgY29uc3QgY29weUxhYmVsUHJvcHMgPSAobm9kZSkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZmlsbDogbm9kZS5maWxsLFxuICAgICAgICBmb250RmFtaWx5OiBub2RlLmZvbnRGYW1pbHksXG4gICAgICAgIGZvbnRTaXplOiBub2RlLmZvbnRTaXplLFxuICAgICAgICBmb250U3R5bGU6IG5vZGUuZm9udFN0eWxlLFxuICAgICAgICBmb250V2VpZ2h0OiBub2RlLmZvbnRXZWlnaHQsXG4gICAgICAgIHJvdGF0aW9uOiBub2RlLnJvdGF0aW9uLFxuICAgICAgICByb3RhdGlvbkNlbnRlclg6IG5vZGUucm90YXRpb25DZW50ZXJYLFxuICAgICAgICByb3RhdGlvbkNlbnRlclk6IG5vZGUucm90YXRpb25DZW50ZXJZLFxuICAgICAgICB0ZXh0OiBub2RlLnRleHQsXG4gICAgICAgIHRleHRBbGlnbjogbm9kZS50ZXh0QWxpZ24sXG4gICAgICAgIHRleHRCYXNlbGluZTogbm9kZS50ZXh0QmFzZWxpbmUsXG4gICAgICAgIHRyYW5zbGF0aW9uWDogbm9kZS50cmFuc2xhdGlvblgsXG4gICAgICAgIHRyYW5zbGF0aW9uWTogbm9kZS50cmFuc2xhdGlvblksXG4gICAgICAgIHZpc2libGU6IG5vZGUudmlzaWJsZSxcbiAgICAgICAgeDogbm9kZS54LFxuICAgICAgICB5OiBub2RlLnlcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBsYWJlbEJCb3hlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgbGV0IG1heExlYWZMYWJlbFdpZHRoID0gMDtcbiAgICBjb25zdCB0ZW1wVGV4dCA9IG5ldyBUcmFuc2Zvcm1hYmxlVGV4dCgpO1xuICAgIGNvbnN0IHNldExhYmVsUHJvcHMgPSAoZGF0dW0sIGluZGV4KSA9PiB7XG4gICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgaWYgKGlzQ2FwdGlvbkVuYWJsZWQpIHtcbiAgICAgICAgICBjb25zdCB0ZXh0ID0gY2FsbGJhY2tDYWNoZS5jYWxsKGZvcm1hdHRlciwgdGhpcy5nZXRUaXRsZUZvcm1hdHRlclBhcmFtcygpKTtcbiAgICAgICAgICB0ZW1wVGV4dC5zZXRQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICBmaWxsOiB0aXRsZS5jb2xvcixcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6IHRpdGxlLmZvbnRGYW1pbHksXG4gICAgICAgICAgICBmb250U2l6ZTogdGl0bGUuZm9udFNpemUsXG4gICAgICAgICAgICBmb250U3R5bGU6IHRpdGxlLmZvbnRTdHlsZSxcbiAgICAgICAgICAgIGZvbnRXZWlnaHQ6IHRpdGxlLmZvbnRXZWlnaHQsXG4gICAgICAgICAgICB0ZXh0QWxpZ246IFwiY2VudGVyXCIsXG4gICAgICAgICAgICB0ZXh0QmFzZWxpbmU6IFwiaGFuZ2luZ1wiLFxuICAgICAgICAgICAgdHJhbnNsYXRpb25YOiBkYXR1bS5zY3JlZW5ZIC0gdGl0bGUuZm9udFNpemUgKiAwLjI1LFxuICAgICAgICAgICAgdHJhbnNsYXRpb25ZOiBkYXR1bS5zY3JlZW5YXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdGVtcFRleHQuc2V0UHJvcGVydGllcyh7XG4gICAgICAgIGZpbGw6IGxhYmVsLmNvbG9yLFxuICAgICAgICBmb250RmFtaWx5OiBsYWJlbC5mb250RmFtaWx5LFxuICAgICAgICBmb250U2l6ZTogbGFiZWwuZm9udFNpemUsXG4gICAgICAgIGZvbnRTdHlsZTogbGFiZWwuZm9udFN0eWxlLFxuICAgICAgICBmb250V2VpZ2h0OiBsYWJlbC5mb250V2VpZ2h0LFxuICAgICAgICB0ZXh0QWxpZ246IFwiY2VudGVyXCIsXG4gICAgICAgIHRleHRCYXNlbGluZTogcGFyYWxsZWxGbGlwRmxhZyA9PT0gLTEgPyBcImJvdHRvbVwiIDogXCJoYW5naW5nXCIsXG4gICAgICAgIHRyYW5zbGF0aW9uWDogZGF0dW0uc2NyZWVuWSAtIGxhYmVsLmZvbnRTaXplICogMC4yNSxcbiAgICAgICAgdHJhbnNsYXRpb25ZOiBkYXR1bS5zY3JlZW5YXG4gICAgICB9KTtcbiAgICAgIGlmIChpbmRleCAlIGtlZXBFdmVyeSAhPT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoZGF0dW0uc2NyZWVuWCA8IHJhbmdlM1swXSB8fCBkYXR1bS5zY3JlZW5YID4gcmFuZ2UzWzFdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChsYWJlbC5mb3JtYXR0ZXIpIHtcbiAgICAgICAgdGVtcFRleHQudGV4dCA9IGNhbGxiYWNrQ2FjaGUuY2FsbChsYWJlbC5mb3JtYXR0ZXIsIHtcbiAgICAgICAgICB2YWx1ZTogU3RyaW5nKGRhdHVtLmxhYmVsKSxcbiAgICAgICAgICBpbmRleFxuICAgICAgICB9KSA/PyBTdHJpbmcoZGF0dW0ubGFiZWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGVtcFRleHQudGV4dCA9IFN0cmluZyhkYXR1bS5sYWJlbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIHRyZWVMYWJlbHMuZm9yRWFjaCgoZGF0dW0sIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBpc1Zpc2libGUgPSBzZXRMYWJlbFByb3BzKGRhdHVtLCBpbmRleCk7XG4gICAgICBpZiAoIWlzVmlzaWJsZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgYmJveDIgPSB0ZW1wVGV4dC5nZXRCQm94KCk7XG4gICAgICBpZiAoIWJib3gyKVxuICAgICAgICByZXR1cm47XG4gICAgICBsYWJlbEJCb3hlcy5zZXQoaW5kZXgsIGJib3gyKTtcbiAgICAgIGNvbnN0IGlzTGVhZiA9ICFkYXR1bS5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICBpZiAoaXNMZWFmICYmIGJib3gyLndpZHRoID4gbWF4TGVhZkxhYmVsV2lkdGgpIHtcbiAgICAgICAgbWF4TGVhZkxhYmVsV2lkdGggPSBiYm94Mi53aWR0aDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBsYWJlbFggPSBzaWRlRmxhZyAqIGxhYmVsLnBhZGRpbmc7XG4gICAgY29uc3QgbGFiZWxHcmlkID0gdGhpcy5sYWJlbC5ncmlkO1xuICAgIGNvbnN0IHNlcGFyYXRvckRhdGEgPSBbXTtcbiAgICB0cmVlTGFiZWxzLmZvckVhY2goKGRhdHVtLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgaXNMZWFmID0gIWRhdHVtLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgIGxldCB2aXNpYmxlID0gc2V0TGFiZWxQcm9wcyhkYXR1bSwgaW5kZXgpO1xuICAgICAgdGVtcFRleHQueCA9IGxhYmVsWDtcbiAgICAgIHRlbXBUZXh0LnkgPSBpbmRleCA9PT0gMCAmJiBpc0NhcHRpb25FbmFibGVkID8gdGl0bGUuc3BhY2luZyA/PyAwIDogMDtcbiAgICAgIHRlbXBUZXh0LnJvdGF0aW9uQ2VudGVyWCA9IGxhYmVsWDtcbiAgICAgIGlmIChpc0xlYWYpIHtcbiAgICAgICAgdGVtcFRleHQucm90YXRpb24gPSBjb25maWd1cmVkUm90YXRpb247XG4gICAgICAgIHRlbXBUZXh0LnRleHRBbGlnbiA9IFwiZW5kXCI7XG4gICAgICAgIHRlbXBUZXh0LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBhdmFpbGFibGVSYW5nZSA9IGRhdHVtLmxlYWZDb3VudCAqIGJhbmR3aWR0aDtcbiAgICAgICAgY29uc3QgYmJveDIgPSBsYWJlbEJCb3hlcy5nZXQoaW5kZXgpO1xuICAgICAgICB0ZW1wVGV4dC50cmFuc2xhdGlvblggLT0gbWF4TGVhZkxhYmVsV2lkdGggLSBsaW5lSGVpZ2h0ICsgdGhpcy5sYWJlbC5wYWRkaW5nO1xuICAgICAgICBpZiAoYmJveDIgJiYgYmJveDIud2lkdGggPiBhdmFpbGFibGVSYW5nZSkge1xuICAgICAgICAgIHZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICBsYWJlbEJCb3hlcy5kZWxldGUoaW5kZXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRlbXBUZXh0LnJvdGF0aW9uID0gaXNIb3Jpem9udGFsID8gZGVmYXVsdFJvdGF0aW9uIDogLU1hdGguUEkgLyAyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZGF0dW0ucGFyZW50ICYmIGlzTGFiZWxUcmVlKSB7XG4gICAgICAgIGNvbnN0IHkgPSBpc0xlYWYgPyBkYXR1bS5zY3JlZW5YIC0gYmFuZHdpZHRoIC8gMiA6IGRhdHVtLnNjcmVlblggLSBkYXR1bS5sZWFmQ291bnQgKiBiYW5kd2lkdGggLyAyO1xuICAgICAgICBpZiAoaXNMZWFmKSB7XG4gICAgICAgICAgaWYgKGRhdHVtLm51bWJlciAhPT0gZGF0dW0uY2hpbGRyZW4ubGVuZ3RoIC0gMSB8fCBsYWJlbEdyaWQpIHtcbiAgICAgICAgICAgIHNlcGFyYXRvckRhdGEucHVzaCh7XG4gICAgICAgICAgICAgIHksXG4gICAgICAgICAgICAgIHgxOiAwLFxuICAgICAgICAgICAgICB4MjogLW1heExlYWZMYWJlbFdpZHRoIC0gdGhpcy5sYWJlbC5wYWRkaW5nICogMlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHggPSAtbWF4TGVhZkxhYmVsV2lkdGggLSB0aGlzLmxhYmVsLnBhZGRpbmcgKiAyICsgZGF0dW0uc2NyZWVuWTtcbiAgICAgICAgICBzZXBhcmF0b3JEYXRhLnB1c2goe1xuICAgICAgICAgICAgeSxcbiAgICAgICAgICAgIHgxOiB4ICsgbGluZUhlaWdodCxcbiAgICAgICAgICAgIHgyOiB4XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCBwcm9wcztcbiAgICAgIGlmICh2aXNpYmxlKSB7XG4gICAgICAgIGNvbnN0IGJib3gyID0gVHJhbnNmb3JtYWJsZS50b0NhbnZhcyh0ZW1wVGV4dCk7XG4gICAgICAgIGlmIChiYm94Mikge1xuICAgICAgICAgIGxhYmVsQkJveGVzLnNldChpbmRleCwgYmJveDIpO1xuICAgICAgICB9XG4gICAgICAgIHByb3BzID0geyAuLi5jb3B5TGFiZWxQcm9wcyh0ZW1wVGV4dCksIHZpc2libGUgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxhYmVsQkJveGVzLmRlbGV0ZShpbmRleCk7XG4gICAgICAgIHByb3BzID0geyB2aXNpYmxlIH07XG4gICAgICB9XG4gICAgICB0aWNrTGFiZWxMYXlvdXQucHVzaChwcm9wcyk7XG4gICAgfSk7XG4gICAgbGV0IG1pblggPSAwO1xuICAgIHNlcGFyYXRvckRhdGEuZm9yRWFjaCgoZCkgPT4gbWluWCA9IE1hdGgubWluKG1pblgsIGQueDIpKTtcbiAgICBzZXBhcmF0b3JEYXRhLnB1c2goe1xuICAgICAgeTogTWF0aC5tYXgocmFuZ2VTdGFydCwgcmFuZ2VFbmQpLFxuICAgICAgeDE6IDAsXG4gICAgICB4MjogbWluWFxuICAgIH0pO1xuICAgIGNvbnN0IHNlcGFyYXRvckxheW91dCA9IFtdO1xuICAgIGNvbnN0IHNlcGFyYXRvckJveGVzID0gW107XG4gICAgY29uc3QgZXBzaWxvbjIgPSAxZS03O1xuICAgIHNlcGFyYXRvckRhdGEuZm9yRWFjaCgoZGF0dW0pID0+IHtcbiAgICAgIGlmIChkYXR1bS55ID49IHJhbmdlM1swXSAtIGVwc2lsb24yICYmIGRhdHVtLnkgPD0gcmFuZ2UzWzFdICsgZXBzaWxvbjIpIHtcbiAgICAgICAgY29uc3QgeyB4MSwgeDIsIHkgfSA9IGRhdHVtO1xuICAgICAgICBjb25zdCBzZXBhcmF0b3JCb3ggPSBuZXcgQkJveChNYXRoLm1pbih4MSwgeDIpLCB5LCBNYXRoLmFicyh4MSAtIHgyKSwgMCk7XG4gICAgICAgIHNlcGFyYXRvckJveGVzLnB1c2goc2VwYXJhdG9yQm94KTtcbiAgICAgICAgc2VwYXJhdG9yTGF5b3V0LnB1c2goeyB4MSwgeDIsIHkgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgYXhpc0xpbmVMYXlvdXQgPSBbXTtcbiAgICBjb25zdCBheGlzTGluZUJveGVzID0gW107XG4gICAgY29uc3QgbGluZUNvdW50ID0gdGlja1RyZWVMYXlvdXQgPyB0aWNrVHJlZUxheW91dC5kZXB0aCArIDEgOiAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZUNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHZpc2libGUgPSBsYWJlbHMubGVuZ3RoID4gMCAmJiAoaSA9PT0gMCB8fCBsYWJlbEdyaWQgJiYgaXNMYWJlbFRyZWUpO1xuICAgICAgY29uc3QgeCA9IGkgPiAwID8gLW1heExlYWZMYWJlbFdpZHRoIC0gdGhpcy5sYWJlbC5wYWRkaW5nICogMiAtIChpIC0gMSkgKiBsaW5lSGVpZ2h0IDogMDtcbiAgICAgIGNvbnN0IGxpbmVCb3ggPSBuZXcgQkJveCh4LCBNYXRoLm1pbiguLi5yYW5nZTMpLCAwLCBNYXRoLmFicyhyYW5nZTNbMV0gLSByYW5nZTNbMF0pKTtcbiAgICAgIGF4aXNMaW5lQm94ZXMucHVzaChsaW5lQm94KTtcbiAgICAgIGF4aXNMaW5lTGF5b3V0LnB1c2goeyB4LCB5MTogcmFuZ2UzWzBdLCB5MjogcmFuZ2UzWzFdLCB2aXNpYmxlIH0pO1xuICAgIH1cbiAgICBjb25zdCBiYm94ID0gQkJveC5tZXJnZShpdGVyYXRlKGxhYmVsQkJveGVzLnZhbHVlcygpLCBzZXBhcmF0b3JCb3hlcywgYXhpc0xpbmVCb3hlcykpO1xuICAgIGNvbnN0IHRyYW5zZm9ybWVkQkJveCA9IHRoaXMuZ2V0VHJhbnNmb3JtQm94KGJib3gpO1xuICAgIHJldHVybiB7XG4gICAgICBiYm94OiB0cmFuc2Zvcm1lZEJCb3gsXG4gICAgICB0aWNrTGFiZWxMYXlvdXQsXG4gICAgICBzZXBhcmF0b3JMYXlvdXQsXG4gICAgICBheGlzTGluZUxheW91dFxuICAgIH07XG4gIH1cbiAgY2FsY3VsYXRlTGF5b3V0KCkge1xuICAgIGNvbnN0IHsgYXhpc0xpbmVMYXlvdXQsIHNlcGFyYXRvckxheW91dCwgdGlja0xhYmVsTGF5b3V0LCBiYm94IH0gPSB0aGlzLmNvbXB1dGVMYXlvdXQoKTtcbiAgICB0aGlzLmNvbXB1dGVkTGF5b3V0ID0geyBheGlzTGluZUxheW91dCwgc2VwYXJhdG9yTGF5b3V0LCB0aWNrTGFiZWxMYXlvdXQgfTtcbiAgICByZXR1cm4geyBiYm94LCBwcmltYXJ5VGlja0NvdW50OiB2b2lkIDAgfTtcbiAgfVxufTtcbkdyb3VwZWRDYXRlZ29yeUF4aXMuY2xhc3NOYW1lID0gXCJHcm91cGVkQ2F0ZWdvcnlBeGlzXCI7XG5Hcm91cGVkQ2F0ZWdvcnlBeGlzLnR5cGUgPSBcImdyb3VwZWQtY2F0ZWdvcnlcIjtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgR3JvdXBlZENhdGVnb3J5QXhpcy5wcm90b3R5cGUsIFwibGFiZWxDb2xvclwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvbW9kdWxlL21vZHVsZS50c1xudmFyIEJhc2VNb2R1bGVJbnN0YW5jZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5kZXN0cm95Rm5zID0gW107XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBmb3IgKGNvbnN0IGRlc3Ryb3lGbiBvZiB0aGlzLmRlc3Ryb3lGbnMpIHtcbiAgICAgIGRlc3Ryb3lGbigpO1xuICAgIH1cbiAgfVxufTtcbnZhciBNb2R1bGVSZWdpc3RyeSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5tb2R1bGVzID0gW107XG4gICAgdGhpcy5kZXBlbmRlbmNpZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuZGVwZW5kZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgcmVnaXN0ZXIoLi4ubW9kdWxlcykge1xuICAgIGZvciAoY29uc3QgbW9kdWxlIG9mIG1vZHVsZXMpIHtcbiAgICAgIHRoaXMucmVnaXN0ZXJEZXBlbmRlbmNpZXMobW9kdWxlKTtcbiAgICAgIGNvbnN0IG90aGVyTW9kdWxlID0gdGhpcy5tb2R1bGVzLmZpbmQoXG4gICAgICAgIChvdGhlcikgPT4gbW9kdWxlLnR5cGUgPT09IG90aGVyLnR5cGUgJiYgbW9kdWxlLm9wdGlvbnNLZXkgPT09IG90aGVyLm9wdGlvbnNLZXkgJiYgbW9kdWxlLmlkZW50aWZpZXIgPT09IG90aGVyLmlkZW50aWZpZXJcbiAgICAgICk7XG4gICAgICBpZiAob3RoZXJNb2R1bGUpIHtcbiAgICAgICAgaWYgKG1vZHVsZS5wYWNrYWdlVHlwZSA9PT0gXCJlbnRlcnByaXNlXCIgJiYgb3RoZXJNb2R1bGUucGFja2FnZVR5cGUgPT09IFwiY29tbXVuaXR5XCIpIHtcbiAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMubW9kdWxlcy5pbmRleE9mKG90aGVyTW9kdWxlKTtcbiAgICAgICAgICB0aGlzLm1vZHVsZXMuc3BsaWNlKGluZGV4LCAxLCBtb2R1bGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm1vZHVsZXMucHVzaChtb2R1bGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBoYXNFbnRlcnByaXNlTW9kdWxlcygpIHtcbiAgICByZXR1cm4gdGhpcy5tb2R1bGVzLnNvbWUoKG0pID0+IG0ucGFja2FnZVR5cGUgPT09IFwiZW50ZXJwcmlzZVwiKTtcbiAgfVxuICAqYnlUeXBlKC4uLnR5cGVzKSB7XG4gICAgY29uc3QgeyBkZXBlbmRlbnRzIH0gPSB0aGlzO1xuICAgIGNvbnN0IHlpZWxkZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgY29uc3QgbWF4Q291bnQgPSAzO1xuICAgIGNvbnN0IG1vZHVsZXNCeVR5cGUgPSB0aGlzLm1vZHVsZXMuZmlsdGVyKChtb2R1bGUpID0+IHR5cGVzLmluY2x1ZGVzKG1vZHVsZS50eXBlKSk7XG4gICAgZG8ge1xuICAgICAgZm9yIChjb25zdCBtb2R1bGUgb2YgbW9kdWxlc0J5VHlwZSkge1xuICAgICAgICBpZiAoeWllbGRlZC5oYXMobW9kdWxlLm9wdGlvbnNLZXkpIHx8IGRlcGVuZGVudHMuaGFzKG1vZHVsZS5vcHRpb25zS2V5KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkIG1vZHVsZTtcbiAgICAgICAgeWllbGRlZC5hZGQobW9kdWxlLm9wdGlvbnNLZXkpO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIGRlcGVuZGVuY2llc10gb2YgZGVwZW5kZW50cy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICBkZXBlbmRlbmNpZXMuZGVsZXRlKG1vZHVsZS5vcHRpb25zS2V5KTtcbiAgICAgICAgICBpZiAoZGVwZW5kZW5jaWVzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIGRlcGVuZGVudHMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb3VudCsrO1xuICAgIH0gd2hpbGUgKHlpZWxkZWQuc2l6ZSA8IG1vZHVsZXNCeVR5cGUubGVuZ3RoICYmIGNvdW50IDwgbWF4Q291bnQpO1xuICAgIGlmIChkZXBlbmRlbnRzLnNpemUgPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCByZXNvbHZlIG1vZHVsZSBkZXBlbmRlbmNpZXM6IFske1suLi5kZXBlbmRlbnRzLmtleXMoKV19XWApO1xuICAgIH1cbiAgfVxuICByZWdpc3RlckRlcGVuZGVuY2llcyhtb2R1bGUpIHtcbiAgICBpZiAobW9kdWxlLmRlcGVuZGVuY2llcyA9PSBudWxsIHx8IG1vZHVsZS5kZXBlbmRlbmNpZXMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIG1vZHVsZS5kZXBlbmRlbmNpZXMpIHtcbiAgICAgIGNvbnN0IGRlcGVuZGVuY2llcyA9IHRoaXMuZGVwZW5kZW5jaWVzLmdldChrZXkpID8/IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICBkZXBlbmRlbmNpZXMuYWRkKG1vZHVsZS5vcHRpb25zS2V5KTtcbiAgICAgIHRoaXMuZGVwZW5kZW5jaWVzLnNldChrZXksIGRlcGVuZGVuY2llcyk7XG4gICAgfVxuICAgIHRoaXMuZGVwZW5kZW50cy5zZXQobW9kdWxlLm9wdGlvbnNLZXksIG5ldyBTZXQobW9kdWxlLmRlcGVuZGVuY2llcykpO1xuICB9XG59O1xudmFyIG1vZHVsZVJlZ2lzdHJ5ID0gbmV3IE1vZHVsZVJlZ2lzdHJ5KCk7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvYXN5bmMudHNcbmZ1bmN0aW9uIHNsZWVwKHNsZWVwVGltZW91dE1zKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHNldFRpbWVvdXQoKCkgPT4gcmVzb2x2ZSh2b2lkIDApLCBzbGVlcFRpbWVvdXRNcyk7XG4gIH0pO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL211dGV4LnRzXG52YXIgTXV0ZXggPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuYXZhaWxhYmxlID0gdHJ1ZTtcbiAgICB0aGlzLmFjcXVpcmVRdWV1ZSA9IFtdO1xuICB9XG4gIGFjcXVpcmUoY2IpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHRoaXMuYWNxdWlyZVF1ZXVlLnB1c2goW2NiLCByZXNvbHZlXSk7XG4gICAgICBpZiAodGhpcy5hdmFpbGFibGUpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaE5leHQoKS5jYXRjaCgoZSkgPT4gTG9nZ2VyLmVycm9yT25jZShlKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgYWNxdWlyZUltbWVkaWF0ZWx5KGNiKSB7XG4gICAgaWYgKCF0aGlzLmF2YWlsYWJsZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLmFjcXVpcmUoY2IpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGFzeW5jIHdhaXRGb3JDbGVhckFjcXVpcmVRdWV1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5hY3F1aXJlKGFzeW5jICgpID0+IHZvaWQgMCk7XG4gIH1cbiAgYXN5bmMgZGlzcGF0Y2hOZXh0KCkge1xuICAgIHRoaXMuYXZhaWxhYmxlID0gZmFsc2U7XG4gICAgbGV0IFtuZXh0LCBkb25lXSA9IHRoaXMuYWNxdWlyZVF1ZXVlLnNoaWZ0KCkgPz8gW107XG4gICAgd2hpbGUgKG5leHQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IG5leHQoKTtcbiAgICAgICAgZG9uZT8uKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBMb2dnZXIuZXJyb3IoXCJtdXRleCBjYWxsYmFjayBlcnJvclwiLCBlcnJvcik7XG4gICAgICAgIGRvbmU/LigpO1xuICAgICAgfVxuICAgICAgW25leHQsIGRvbmVdID0gdGhpcy5hY3F1aXJlUXVldWUuc2hpZnQoKSA/PyBbXTtcbiAgICB9XG4gICAgdGhpcy5hdmFpbGFibGUgPSB0cnVlO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL29ic2VydmFibGUudHNcbnZhciBPYnNlcnZhYmxlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmV2ZW50TGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICBhZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFHIENoYXJ0cyAtIGxpc3RlbmVyIG11c3QgYmUgYSBGdW5jdGlvblwiKTtcbiAgICB9XG4gICAgY29uc3QgZXZlbnRUeXBlTGlzdGVuZXJzID0gdGhpcy5ldmVudExpc3RlbmVycy5nZXQoZXZlbnRUeXBlKTtcbiAgICBpZiAoZXZlbnRUeXBlTGlzdGVuZXJzKSB7XG4gICAgICBldmVudFR5cGVMaXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ldmVudExpc3RlbmVycy5zZXQoZXZlbnRUeXBlLCAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbbGlzdGVuZXJdKSk7XG4gICAgfVxuICB9XG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICB0aGlzLmV2ZW50TGlzdGVuZXJzLmdldCh0eXBlKT8uZGVsZXRlKGxpc3RlbmVyKTtcbiAgICBpZiAodGhpcy5ldmVudExpc3RlbmVycy5zaXplID09PSAwKSB7XG4gICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzLmRlbGV0ZSh0eXBlKTtcbiAgICB9XG4gIH1cbiAgaGFzRXZlbnRMaXN0ZW5lcih0eXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZXZlbnRMaXN0ZW5lcnMuaGFzKHR5cGUpO1xuICB9XG4gIGNsZWFyRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5ldmVudExpc3RlbmVycy5jbGVhcigpO1xuICB9XG4gIGZpcmVFdmVudChldmVudCkge1xuICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMuZ2V0KGV2ZW50LnR5cGUpPy5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIoZXZlbnQpKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9wYWRkaW5nLnRzXG52YXIgUGFkZGluZyA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3Rvcih0b3AgPSAwLCByaWdodCA9IHRvcCwgYm90dG9tID0gdG9wLCBsZWZ0ID0gcmlnaHQpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMudG9wID0gdG9wO1xuICAgIHRoaXMucmlnaHQgPSByaWdodDtcbiAgICB0aGlzLmJvdHRvbSA9IGJvdHRvbTtcbiAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgUGFkZGluZy5wcm90b3R5cGUsIFwidG9wXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgUGFkZGluZy5wcm90b3R5cGUsIFwicmlnaHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBQYWRkaW5nLnByb3RvdHlwZSwgXCJib3R0b21cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBQYWRkaW5nLnByb3RvdHlwZSwgXCJsZWZ0XCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3JlbmRlci50c1xuZnVuY3Rpb24gZGVib3VuY2VkQW5pbWF0aW9uRnJhbWUoY2IpIHtcbiAgcmV0dXJuIGJ1aWxkU2NoZWR1bGVyKChpbm5lckNiLCBfZGVsYXlNcykgPT4gZ2V0V2luZG93KCkucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGlubmVyQ2IpLCBjYik7XG59XG5mdW5jdGlvbiBkZWJvdW5jZWRDYWxsYmFjayhjYikge1xuICByZXR1cm4gYnVpbGRTY2hlZHVsZXIoKGlubmVyQ2IsIGRlbGF5TXMgPSAwKSA9PiBzZXRUaW1lb3V0KGlubmVyQ2IsIGRlbGF5TXMpLCBjYik7XG59XG5mdW5jdGlvbiBidWlsZFNjaGVkdWxlcihzY2hlZHVsZUZuLCBjYikge1xuICBsZXQgc2NoZWR1bGVDb3VudCA9IDA7XG4gIGxldCBwcm9taXNlUnVubmluZyA9IGZhbHNlO1xuICBsZXQgYXdhaXRpbmdQcm9taXNlO1xuICBsZXQgYXdhaXRpbmdEb25lO1xuICBjb25zdCBidXN5ID0gKCkgPT4ge1xuICAgIHJldHVybiBwcm9taXNlUnVubmluZztcbiAgfTtcbiAgY29uc3QgZG9uZSA9ICgpID0+IHtcbiAgICBwcm9taXNlUnVubmluZyA9IGZhbHNlO1xuICAgIGF3YWl0aW5nRG9uZT8uKCk7XG4gICAgYXdhaXRpbmdEb25lID0gdm9pZCAwO1xuICAgIGF3YWl0aW5nUHJvbWlzZSA9IHZvaWQgMDtcbiAgICBpZiAoc2NoZWR1bGVDb3VudCA+IDApIHtcbiAgICAgIHNjaGVkdWxlRm4oc2NoZWR1bGVDYik7XG4gICAgfVxuICB9O1xuICBjb25zdCBzY2hlZHVsZUNiID0gKCkgPT4ge1xuICAgIGNvbnN0IGNvdW50ID0gc2NoZWR1bGVDb3VudDtcbiAgICBzY2hlZHVsZUNvdW50ID0gMDtcbiAgICBwcm9taXNlUnVubmluZyA9IHRydWU7XG4gICAgY29uc3QgbWF5YmVQcm9taXNlID0gY2IoeyBjb3VudCB9KTtcbiAgICBpZiAoIW1heWJlUHJvbWlzZSkge1xuICAgICAgZG9uZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBtYXliZVByb21pc2UudGhlbihkb25lLCBkb25lKTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBzY2hlZHVsZShkZWxheU1zKSB7XG4gICAgICBpZiAoc2NoZWR1bGVDb3VudCA9PT0gMCAmJiAhYnVzeSgpKSB7XG4gICAgICAgIHNjaGVkdWxlRm4oc2NoZWR1bGVDYiwgZGVsYXlNcyk7XG4gICAgICB9XG4gICAgICBzY2hlZHVsZUNvdW50Kys7XG4gICAgfSxcbiAgICBhc3luYyBhd2FpdCgpIHtcbiAgICAgIGlmICghYnVzeSgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChhd2FpdGluZ1Byb21pc2UgPT0gbnVsbCkge1xuICAgICAgICBhd2FpdGluZ1Byb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgIGF3YWl0aW5nRG9uZSA9IHJlc29sdmU7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgd2hpbGUgKGJ1c3koKSkge1xuICAgICAgICBhd2FpdCBhd2FpdGluZ1Byb21pc2U7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2V2ZW50RW1pdHRlci50c1xudmFyIEV2ZW50RW1pdHRlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5ldmVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIuXG4gICAqIEBwYXJhbSBldmVudE5hbWUgVGhlIGV2ZW50IG5hbWUgdG8gbGlzdGVuIGZvci5cbiAgICogQHBhcmFtIGxpc3RlbmVyIFRoZSBjYWxsYmFjayB0byBiZSBpbnZva2VkIG9uIHRoZSBldmVudC5cbiAgICogQHJldHVybnMgQSBmdW5jdGlvbiB0byB1bnJlZ2lzdGVyIHRoZSBsaXN0ZW5lci5cbiAgICovXG4gIG9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAoIXRoaXMuZXZlbnRzLmhhcyhldmVudE5hbWUpKSB7XG4gICAgICB0aGlzLmV2ZW50cy5zZXQoZXZlbnROYW1lLCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgICB9XG4gICAgdGhpcy5ldmVudHMuZ2V0KGV2ZW50TmFtZSk/LmFkZChsaXN0ZW5lcik7XG4gICAgcmV0dXJuICgpID0+IHRoaXMub2ZmKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICB9XG4gIC8qKlxuICAgKiBVbnJlZ2lzdGVycyBhbiBldmVudCBsaXN0ZW5lci5cbiAgICogQHBhcmFtIGV2ZW50TmFtZSBUaGUgZXZlbnQgbmFtZSB0byBzdG9wIGxpc3RlbmluZyBmb3IuXG4gICAqIEBwYXJhbSBsaXN0ZW5lciBUaGUgY2FsbGJhY2sgdG8gYmUgcmVtb3ZlZC5cbiAgICovXG4gIG9mZihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgY29uc3QgZXZlbnRMaXN0ZW5lcnMgPSB0aGlzLmV2ZW50cy5nZXQoZXZlbnROYW1lKTtcbiAgICBpZiAoZXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIGV2ZW50TGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgICBpZiAoZXZlbnRMaXN0ZW5lcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICB0aGlzLmV2ZW50cy5kZWxldGUoZXZlbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEVtaXRzIGFuIGV2ZW50IHRvIGFsbCByZWdpc3RlcmVkIGxpc3RlbmVycy5cbiAgICogQHBhcmFtIGV2ZW50TmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gZW1pdC5cbiAgICogQHBhcmFtIGV2ZW50IFRoZSBldmVudCBwYXlsb2FkLlxuICAgKi9cbiAgZW1pdChldmVudE5hbWUsIGV2ZW50KSB7XG4gICAgdGhpcy5ldmVudHMuZ2V0KGV2ZW50TmFtZSk/LmZvckVhY2goKGNhbGxiYWNrMikgPT4gY2FsbGJhY2syKGV2ZW50KSk7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFycyBhbGwgbGlzdGVuZXJzIGZvciBhIHNwZWNpZmljIGV2ZW50IG9yIGFsbCBldmVudHMgaWYgbm8gZXZlbnQgbmFtZSBpcyBwcm92aWRlZC5cbiAgICogQHBhcmFtIGV2ZW50TmFtZSAoT3B0aW9uYWwpIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBjbGVhciBsaXN0ZW5lcnMgZm9yLiBJZiBub3QgcHJvdmlkZWQsIGFsbCBsaXN0ZW5lcnMgZm9yIGFsbCBldmVudHMgYXJlIGNsZWFyZWQuXG4gICAqL1xuICBjbGVhcihldmVudE5hbWUpIHtcbiAgICBpZiAoZXZlbnROYW1lKSB7XG4gICAgICB0aGlzLmV2ZW50cy5kZWxldGUoZXZlbnROYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ldmVudHMuY2xlYXIoKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2xheW91dC9sYXlvdXRNYW5hZ2VyLnRzXG52YXIgTGF5b3V0RWxlbWVudCA9IC8qIEBfX1BVUkVfXyAqLyAoKExheW91dEVsZW1lbnQyKSA9PiB7XG4gIExheW91dEVsZW1lbnQyW0xheW91dEVsZW1lbnQyW1wiQ2FwdGlvblwiXSA9IDBdID0gXCJDYXB0aW9uXCI7XG4gIExheW91dEVsZW1lbnQyW0xheW91dEVsZW1lbnQyW1wiTGVnZW5kXCJdID0gMV0gPSBcIkxlZ2VuZFwiO1xuICBMYXlvdXRFbGVtZW50MltMYXlvdXRFbGVtZW50MltcIlRvb2xiYXJcIl0gPSAyXSA9IFwiVG9vbGJhclwiO1xuICBMYXlvdXRFbGVtZW50MltMYXlvdXRFbGVtZW50MltcIk5hdmlnYXRvclwiXSA9IDNdID0gXCJOYXZpZ2F0b3JcIjtcbiAgTGF5b3V0RWxlbWVudDJbTGF5b3V0RWxlbWVudDJbXCJPdmVybGF5XCJdID0gNF0gPSBcIk92ZXJsYXlcIjtcbiAgcmV0dXJuIExheW91dEVsZW1lbnQyO1xufSkoTGF5b3V0RWxlbWVudCB8fCB7fSk7XG52YXIgTGF5b3V0TWFuYWdlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5ldmVudHMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgdGhpcy5lbGVtZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgYWRkTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgIHJldHVybiB0aGlzLmV2ZW50cy5vbihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgfVxuICByZWdpc3RlckVsZW1lbnQoZWxlbWVudDIsIGxpc3RlbmVyKSB7XG4gICAgaWYgKHRoaXMuZWxlbWVudHMuaGFzKGVsZW1lbnQyKSkge1xuICAgICAgdGhpcy5lbGVtZW50cy5nZXQoZWxlbWVudDIpLmFkZChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZWxlbWVudHMuc2V0KGVsZW1lbnQyLCAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbbGlzdGVuZXJdKSk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB0aGlzLmVsZW1lbnRzLmdldChlbGVtZW50Mik/LmRlbGV0ZShsaXN0ZW5lcik7XG4gIH1cbiAgY3JlYXRlQ29udGV4dCh3aWR0aDIsIGhlaWdodDIpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gbmV3IExheW91dENvbnRleHQod2lkdGgyLCBoZWlnaHQyKTtcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQyIG9mIE9iamVjdC52YWx1ZXMoTGF5b3V0RWxlbWVudCkpIHtcbiAgICAgIGlmICh0eXBlb2YgZWxlbWVudDIgIT09IFwibnVtYmVyXCIpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgdGhpcy5lbGVtZW50cy5nZXQoZWxlbWVudDIpPy5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIoY29udGV4dCkpO1xuICAgIH1cbiAgICByZXR1cm4gY29udGV4dDtcbiAgfVxuICBlbWl0TGF5b3V0Q29tcGxldGUoY29udGV4dCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGV2ZW50VHlwZSA9IFwibGF5b3V0OmNvbXBsZXRlXCI7XG4gICAgY29uc3QgeyB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIgfSA9IGNvbnRleHQ7XG4gICAgdGhpcy5ldmVudHMuZW1pdChldmVudFR5cGUsIHtcbiAgICAgIHR5cGU6IGV2ZW50VHlwZSxcbiAgICAgIGF4ZXM6IG9wdGlvbnMuYXhlcyA/PyBbXSxcbiAgICAgIGNoYXJ0OiB7IHdpZHRoOiB3aWR0aDIsIGhlaWdodDogaGVpZ2h0MiB9LFxuICAgICAgY2xpcFNlcmllczogb3B0aW9ucy5jbGlwU2VyaWVzID8/IGZhbHNlLFxuICAgICAgc2VyaWVzOiBvcHRpb25zLnNlcmllc1xuICAgIH0pO1xuICB9XG59O1xudmFyIExheW91dENvbnRleHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHdpZHRoMiwgaGVpZ2h0Mikge1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDI7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQyO1xuICAgIHRoaXMubGF5b3V0Qm94ID0gbmV3IEJCb3goMCwgMCwgd2lkdGgyLCBoZWlnaHQyKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvY2hhcnRDYXB0aW9ucy50c1xudmFyIENoYXJ0Q2FwdGlvbnMgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMudGl0bGUgPSBuZXcgQ2FwdGlvbigpO1xuICAgIHRoaXMuc3VidGl0bGUgPSBuZXcgQ2FwdGlvbigpO1xuICAgIHRoaXMuZm9vdG5vdGUgPSBuZXcgQ2FwdGlvbigpO1xuICB9XG4gIHBvc2l0aW9uQ2FwdGlvbnMoY3R4KSB7XG4gICAgY29uc3QgeyB0aXRsZSwgc3VidGl0bGUsIGZvb3Rub3RlIH0gPSB0aGlzO1xuICAgIGNvbnN0IG1heEhlaWdodCA9IGN0eC5sYXlvdXRCb3guaGVpZ2h0IC8gMTA7XG4gICAgaWYgKHRpdGxlLmVuYWJsZWQpIHtcbiAgICAgIGNvbnN0IHsgc3BhY2luZyA9IHN1YnRpdGxlLmVuYWJsZWQgPyBDYXB0aW9uLlNNQUxMX1BBRERJTkcgOiBDYXB0aW9uLkxBUkdFX1BBRERJTkcgfSA9IHRpdGxlO1xuICAgICAgdGhpcy5wb3NpdGlvbkNhcHRpb24oXCJ0b3BcIiwgdGl0bGUsIGN0eC5sYXlvdXRCb3gsIG1heEhlaWdodCk7XG4gICAgICB0aGlzLnNocmlua0xheW91dEJ5Q2FwdGlvbihcInRvcFwiLCB0aXRsZSwgY3R4LmxheW91dEJveCwgc3BhY2luZyk7XG4gICAgfVxuICAgIGlmIChzdWJ0aXRsZS5lbmFibGVkKSB7XG4gICAgICB0aGlzLnBvc2l0aW9uQ2FwdGlvbihcInRvcFwiLCBzdWJ0aXRsZSwgY3R4LmxheW91dEJveCwgbWF4SGVpZ2h0KTtcbiAgICAgIHRoaXMuc2hyaW5rTGF5b3V0QnlDYXB0aW9uKFwidG9wXCIsIHN1YnRpdGxlLCBjdHgubGF5b3V0Qm94LCBzdWJ0aXRsZS5zcGFjaW5nKTtcbiAgICB9XG4gICAgaWYgKGZvb3Rub3RlLmVuYWJsZWQpIHtcbiAgICAgIHRoaXMucG9zaXRpb25DYXB0aW9uKFwiYm90dG9tXCIsIGZvb3Rub3RlLCBjdHgubGF5b3V0Qm94LCBtYXhIZWlnaHQpO1xuICAgICAgdGhpcy5zaHJpbmtMYXlvdXRCeUNhcHRpb24oXCJib3R0b21cIiwgZm9vdG5vdGUsIGN0eC5sYXlvdXRCb3gsIGZvb3Rub3RlLnNwYWNpbmcpO1xuICAgIH1cbiAgfVxuICBwb3NpdGlvbkFic29sdXRlQ2FwdGlvbnMoY3R4KSB7XG4gICAgY29uc3QgeyB0aXRsZSwgc3VidGl0bGUsIGZvb3Rub3RlIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgcmVjdCB9ID0gY3R4LnNlcmllcztcbiAgICBmb3IgKGNvbnN0IGNhcHRpb24gb2YgW3RpdGxlLCBzdWJ0aXRsZSwgZm9vdG5vdGVdKSB7XG4gICAgICBpZiAoY2FwdGlvbi5sYXlvdXRTdHlsZSAhPT0gXCJvdmVybGF5XCIpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgaWYgKGNhcHRpb24udGV4dEFsaWduID09PSBcImxlZnRcIikge1xuICAgICAgICBjYXB0aW9uLm5vZGUueCA9IHJlY3QueCArIGNhcHRpb24ucGFkZGluZztcbiAgICAgIH0gZWxzZSBpZiAoY2FwdGlvbi50ZXh0QWxpZ24gPT09IFwicmlnaHRcIikge1xuICAgICAgICBjb25zdCBiYm94ID0gY2FwdGlvbi5ub2RlLmdldEJCb3goKTtcbiAgICAgICAgY2FwdGlvbi5ub2RlLnggPSByZWN0LnggKyByZWN0LndpZHRoIC0gYmJveC53aWR0aCAtIGNhcHRpb24ucGFkZGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29tcHV0ZVgoYWxpZ24sIGxheW91dEJveCkge1xuICAgIGlmIChhbGlnbiA9PT0gXCJsZWZ0XCIpIHtcbiAgICAgIHJldHVybiBsYXlvdXRCb3gueDtcbiAgICB9IGVsc2UgaWYgKGFsaWduID09PSBcInJpZ2h0XCIpIHtcbiAgICAgIHJldHVybiBsYXlvdXRCb3gueCArIGxheW91dEJveC53aWR0aDtcbiAgICB9XG4gICAgcmV0dXJuIGxheW91dEJveC54ICsgbGF5b3V0Qm94LndpZHRoIC8gMjtcbiAgfVxuICBwb3NpdGlvbkNhcHRpb24odkFsaWduLCBjYXB0aW9uLCBsYXlvdXRCb3gsIG1heEhlaWdodCkge1xuICAgIGNvbnN0IGNvbnRhaW5lckhlaWdodCA9IE1hdGgubWF4KFRleHRVdGlscy5nZXRMaW5lSGVpZ2h0KGNhcHRpb24uZm9udFNpemUpLCBtYXhIZWlnaHQpO1xuICAgIGNhcHRpb24ubm9kZS54ID0gdGhpcy5jb21wdXRlWChjYXB0aW9uLnRleHRBbGlnbiwgbGF5b3V0Qm94KSArIGNhcHRpb24ucGFkZGluZztcbiAgICBjYXB0aW9uLm5vZGUueSA9IGxheW91dEJveC55ICsgKHZBbGlnbiA9PT0gXCJ0b3BcIiA/IDAgOiBsYXlvdXRCb3guaGVpZ2h0KSArIGNhcHRpb24ucGFkZGluZztcbiAgICBjYXB0aW9uLm5vZGUudGV4dEJhc2VsaW5lID0gdkFsaWduO1xuICAgIGNhcHRpb24uY29tcHV0ZVRleHRXcmFwKGxheW91dEJveC53aWR0aCwgY29udGFpbmVySGVpZ2h0KTtcbiAgfVxuICBzaHJpbmtMYXlvdXRCeUNhcHRpb24odkFsaWduLCBjYXB0aW9uLCBsYXlvdXRCb3gsIHNwYWNpbmcgPSAwKSB7XG4gICAgaWYgKGNhcHRpb24ubGF5b3V0U3R5bGUgPT09IFwiYmxvY2tcIikge1xuICAgICAgY29uc3QgYmJveCA9IGNhcHRpb24ubm9kZS5nZXRCQm94KCk7XG4gICAgICBsYXlvdXRCb3guc2hyaW5rKFxuICAgICAgICB2QWxpZ24gPT09IFwidG9wXCIgPyBNYXRoLmNlaWwoYmJveC55IC0gbGF5b3V0Qm94LnkgKyBiYm94LmhlaWdodCArIHNwYWNpbmcpIDogTWF0aC5jZWlsKGxheW91dEJveC55ICsgbGF5b3V0Qm94LmhlaWdodCAtIGJib3gueSArIHNwYWNpbmcpLFxuICAgICAgICB2QWxpZ25cbiAgICAgICk7XG4gICAgfVxuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgQ2hhcnRDYXB0aW9ucy5wcm90b3R5cGUsIFwidGl0bGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBDaGFydENhcHRpb25zLnByb3RvdHlwZSwgXCJzdWJ0aXRsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIENoYXJ0Q2FwdGlvbnMucHJvdG90eXBlLCBcImZvb3Rub3RlXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2xpc3RlbmVycy50c1xudmFyIExpc3RlbmVycyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5yZWdpc3RlcmVkTGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICBhZGRMaXN0ZW5lcihldmVudFR5cGUsIGhhbmRsZXIpIHtcbiAgICBjb25zdCByZWNvcmQgPSB7IHN5bWJvbDogU3ltYm9sKGV2ZW50VHlwZSksIGhhbmRsZXIgfTtcbiAgICBpZiAodGhpcy5yZWdpc3RlcmVkTGlzdGVuZXJzLmhhcyhldmVudFR5cGUpKSB7XG4gICAgICB0aGlzLnJlZ2lzdGVyZWRMaXN0ZW5lcnMuZ2V0KGV2ZW50VHlwZSkucHVzaChyZWNvcmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlZ2lzdGVyZWRMaXN0ZW5lcnMuc2V0KGV2ZW50VHlwZSwgW3JlY29yZF0pO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4gdGhpcy5yZW1vdmVMaXN0ZW5lcihyZWNvcmQuc3ltYm9sKTtcbiAgfVxuICByZW1vdmVMaXN0ZW5lcihldmVudFN5bWJvbCkge1xuICAgIGZvciAoY29uc3QgW3R5cGUsIGxpc3RlbmVyc10gb2YgdGhpcy5yZWdpc3RlcmVkTGlzdGVuZXJzLmVudHJpZXMoKSkge1xuICAgICAgY29uc3QgbWF0Y2hJbmRleCA9IGxpc3RlbmVycy5maW5kSW5kZXgoKGxpc3RlbmVyKSA9PiBsaXN0ZW5lci5zeW1ib2wgPT09IGV2ZW50U3ltYm9sKTtcbiAgICAgIGlmIChtYXRjaEluZGV4ID49IDApIHtcbiAgICAgICAgbGlzdGVuZXJzLnNwbGljZShtYXRjaEluZGV4LCAxKTtcbiAgICAgICAgaWYgKGxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLnJlZ2lzdGVyZWRMaXN0ZW5lcnMuZGVsZXRlKHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBkaXNwYXRjaChldmVudFR5cGUsIC4uLnBhcmFtcykge1xuICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5nZXRMaXN0ZW5lcnNCeVR5cGUoZXZlbnRUeXBlKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGlzdGVuZXIuaGFuZGxlciguLi5wYXJhbXMpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBMb2dnZXIuZXJyb3JPbmNlKGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBkaXNwYXRjaFdyYXBIYW5kbGVycyhldmVudFR5cGUsIHdyYXBGbiwgLi4ucGFyYW1zKSB7XG4gICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLmdldExpc3RlbmVyc0J5VHlwZShldmVudFR5cGUpKSB7XG4gICAgICB0cnkge1xuICAgICAgICB3cmFwRm4obGlzdGVuZXIuaGFuZGxlciwgLi4ucGFyYW1zKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgTG9nZ2VyLmVycm9yT25jZShlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0TGlzdGVuZXJzQnlUeXBlKGV2ZW50VHlwZSkge1xuICAgIHJldHVybiB0aGlzLnJlZ2lzdGVyZWRMaXN0ZW5lcnMuZ2V0KGV2ZW50VHlwZSkgPz8gW107XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJlZ2lzdGVyZWRMaXN0ZW5lcnMuY2xlYXIoKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvYmFzZU1hbmFnZXIudHNcbnZhciBCYXNlTWFuYWdlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMgPSBuZXcgTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5kZXN0cm95Rm5zID0gW107XG4gIH1cbiAgYWRkTGlzdGVuZXIodHlwZSwgaGFuZGxlcikge1xuICAgIHJldHVybiB0aGlzLmxpc3RlbmVycy5hZGRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMubGlzdGVuZXJzLmRlc3Ryb3koKTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMuZm9yRWFjaCgoZm4pID0+IGZuKCkpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9pbnRlcmFjdGlvbi9pbnRlcmFjdGlvblN0YXRlTGlzdGVuZXIudHNcbnZhciBJbnRlcmFjdGlvblN0YXRlID0gLyogQF9fUFVSRV9fICovICgoSW50ZXJhY3Rpb25TdGF0ZTIpID0+IHtcbiAgSW50ZXJhY3Rpb25TdGF0ZTJbSW50ZXJhY3Rpb25TdGF0ZTJbXCJEZWZhdWx0XCJdID0gMzJdID0gXCJEZWZhdWx0XCI7XG4gIEludGVyYWN0aW9uU3RhdGUyW0ludGVyYWN0aW9uU3RhdGUyW1wiWm9vbURyYWdcIl0gPSAxNl0gPSBcIlpvb21EcmFnXCI7XG4gIEludGVyYWN0aW9uU3RhdGUyW0ludGVyYWN0aW9uU3RhdGUyW1wiQW5ub3RhdGlvbnNcIl0gPSA4XSA9IFwiQW5ub3RhdGlvbnNcIjtcbiAgSW50ZXJhY3Rpb25TdGF0ZTJbSW50ZXJhY3Rpb25TdGF0ZTJbXCJDb250ZXh0TWVudVwiXSA9IDRdID0gXCJDb250ZXh0TWVudVwiO1xuICBJbnRlcmFjdGlvblN0YXRlMltJbnRlcmFjdGlvblN0YXRlMltcIkFuaW1hdGlvblwiXSA9IDJdID0gXCJBbmltYXRpb25cIjtcbiAgSW50ZXJhY3Rpb25TdGF0ZTJbSW50ZXJhY3Rpb25TdGF0ZTJbXCJBbm5vdGF0aW9uc1NlbGVjdGVkXCJdID0gMV0gPSBcIkFubm90YXRpb25zU2VsZWN0ZWRcIjtcbiAgSW50ZXJhY3Rpb25TdGF0ZTJbSW50ZXJhY3Rpb25TdGF0ZTJbXCJBbGxcIl0gPSA2M10gPSBcIkFsbFwiO1xuICByZXR1cm4gSW50ZXJhY3Rpb25TdGF0ZTI7XG59KShJbnRlcmFjdGlvblN0YXRlIHx8IHt9KTtcbnZhciBJbnRlcmFjdGlvblN0YXRlTGlzdGVuZXIgPSBjbGFzcyBleHRlbmRzIEJhc2VNYW5hZ2VyIHtcbiAgLy8gV3JhcHBlciB0byBvbmx5IGJyb2FkY2FzdCBldmVudHMgd2hlbiB0aGUgSW50ZXJhY3Rpb25NYW5hZ2VyIGlzIGEgZ2l2ZW4gc3RhdGUuXG4gIGFkZExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIHRyaWdnZXJpbmdTdGF0ZXMgPSAzMiAvKiBEZWZhdWx0ICovKSB7XG4gICAgcmV0dXJuIHN1cGVyLmFkZExpc3RlbmVyKHR5cGUsIChlKSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50U3RhdGUgPSB0aGlzLmdldFN0YXRlKCk7XG4gICAgICBpZiAoY3VycmVudFN0YXRlICYgdHJpZ2dlcmluZ1N0YXRlcykge1xuICAgICAgICBoYW5kbGVyKGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2Rlc3Ryb3kudHNcbnZhciBEZXN0cm95Rm5zID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmRlc3Ryb3lGbnMgPSBbXTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveUZucy5mb3JFYWNoKChmbikgPT4gZm4oKSk7XG4gICAgdGhpcy5kZXN0cm95Rm5zLmxlbmd0aCA9IDA7XG4gIH1cbiAgc2V0Rm5zKGRlc3Ryb3lGbnMpIHtcbiAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMgPSBkZXN0cm95Rm5zO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy92ZXJzaW9uLnRzXG52YXIgVkVSU0lPTiA9IFwiMTAuMy4zXCI7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2FwaS9zdGF0ZS9oaXN0b3J5TWFuYWdlci50c1xudmFyIE5PVF9GT1VORCA9IFN5bWJvbChcInByZXZpb3VzLW1lbWVudG8tbm90LWZvdW5kXCIpO1xudmFyIEhpc3RvcnlNYW5hZ2VyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihrZXlOYXZNYW5hZ2VyKSB7XG4gICAgdGhpcy5oaXN0b3J5ID0gW107XG4gICAgdGhpcy5oaXN0b3J5SW5kZXggPSAtMTtcbiAgICB0aGlzLm9yaWdpbmF0b3JzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLmNsZWFyU3RhdGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMubWF4SGlzdG9yeUxlbmd0aCA9IDEwMDtcbiAgICB0aGlzLmRlYnVnID0gRGVidWcuY3JlYXRlKHRydWUsIFwiaGlzdG9yeVwiKTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMgPSBuZXcgRGVzdHJveUZucygpO1xuICAgIHRoaXMuZGVzdHJveUZucy5zZXRGbnMoW1xuICAgICAga2V5TmF2TWFuYWdlci5hZGRMaXN0ZW5lcihcInVuZG9cIiwgdGhpcy51bmRvLmJpbmQodGhpcyksIDYzIC8qIEFsbCAqLyksXG4gICAgICBrZXlOYXZNYW5hZ2VyLmFkZExpc3RlbmVyKFwicmVkb1wiLCB0aGlzLnJlZG8uYmluZCh0aGlzKSwgNjMgLyogQWxsICovKVxuICAgIF0pO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXN0cm95Rm5zLmRlc3Ryb3koKTtcbiAgfVxuICBhZGRNZW1lbnRvT3JpZ2luYXRvcihvcmlnaW5hdG9yKSB7XG4gICAgdGhpcy5vcmlnaW5hdG9ycy5zZXQob3JpZ2luYXRvci5tZW1lbnRvT3JpZ2luYXRvcktleSwgb3JpZ2luYXRvcik7XG4gICAgdGhpcy5jbGVhclN0YXRlLnNldChvcmlnaW5hdG9yLm1lbWVudG9PcmlnaW5hdG9yS2V5LCBvcmlnaW5hdG9yLmNyZWF0ZU1lbWVudG8oKSk7XG4gICAgdGhpcy5kZWJ1Z0V2ZW50KFwiSGlzdG9yeSBhZGQgb3JpZ2luYXRvcjpcIiwgb3JpZ2luYXRvci5tZW1lbnRvT3JpZ2luYXRvcktleSk7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5kZWJ1ZyhgSGlzdG9yeSBjbGVhcjpgLCBPYmplY3Qua2V5cyh0aGlzLm9yaWdpbmF0b3JzKSk7XG4gICAgdGhpcy5oaXN0b3J5ID0gW107XG4gICAgdGhpcy5oaXN0b3J5SW5kZXggPSAtMTtcbiAgICBmb3IgKGNvbnN0IFttZW1lbnRvT3JpZ2luYXRvcktleSwgb3JpZ2luYXRvcl0gb2YgdGhpcy5vcmlnaW5hdG9ycy5lbnRyaWVzKCkpIHtcbiAgICAgIHRoaXMuY2xlYXJTdGF0ZS5zZXQobWVtZW50b09yaWdpbmF0b3JLZXksIG9yaWdpbmF0b3IuY3JlYXRlTWVtZW50bygpKTtcbiAgICB9XG4gIH1cbiAgcmVjb3JkKGxhYmVsLCAuLi5vcmlnaW5hdG9ycykge1xuICAgIGlmICh0aGlzLmhpc3RvcnlJbmRleCA8IHRoaXMuaGlzdG9yeS5sZW5ndGggLSAxKSB7XG4gICAgICB0aGlzLmhpc3RvcnkgPSB0aGlzLmhpc3Rvcnkuc2xpY2UoMCwgdGhpcy5oaXN0b3J5SW5kZXggKyAxKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaGlzdG9yeS5sZW5ndGggPiB0aGlzLm1heEhpc3RvcnlMZW5ndGgpIHtcbiAgICAgIHRoaXMuaGlzdG9yeSA9IHRoaXMuaGlzdG9yeS5zbGljZSgtdGhpcy5tYXhIaXN0b3J5TGVuZ3RoKTtcbiAgICB9XG4gICAgY29uc3QgbWVtZW50b3MgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3Qgb3JpZ2luYXRvciBvZiBvcmlnaW5hdG9ycykge1xuICAgICAgaWYgKCF0aGlzLm9yaWdpbmF0b3JzLmhhcyhvcmlnaW5hdG9yLm1lbWVudG9PcmlnaW5hdG9yS2V5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYE9yaWdpbmF0b3IgWyR7b3JpZ2luYXRvci5tZW1lbnRvT3JpZ2luYXRvcktleX1dIGhhcyBub3QgYmVlbiBhZGRlZCB0byB0aGUgSGlzdG9yeU1hbmFnZXIuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgbWVtZW50b3Muc2V0KG9yaWdpbmF0b3IubWVtZW50b09yaWdpbmF0b3JLZXksIG9yaWdpbmF0b3IuY3JlYXRlTWVtZW50bygpKTtcbiAgICB9XG4gICAgdGhpcy5oaXN0b3J5LnB1c2goeyBsYWJlbCwgbWVtZW50b3MgfSk7XG4gICAgdGhpcy5oaXN0b3J5SW5kZXggPSB0aGlzLmhpc3RvcnkubGVuZ3RoIC0gMTtcbiAgICB0aGlzLmRlYnVnRXZlbnQoYEhpc3RvcnkgcmVjb3JkOiBbJHtsYWJlbH1dYCk7XG4gIH1cbiAgdW5kbygpIHtcbiAgICBjb25zdCB1bmRvQWN0aW9uID0gdGhpcy5oaXN0b3J5W3RoaXMuaGlzdG9yeUluZGV4XTtcbiAgICBpZiAoIXVuZG9BY3Rpb24pXG4gICAgICByZXR1cm47XG4gICAgZm9yIChjb25zdCBtZW1lbnRvT3JpZ2luYXRvcktleSBvZiB1bmRvQWN0aW9uLm1lbWVudG9zLmtleXMoKSkge1xuICAgICAgY29uc3QgcHJldmlvdXNNZW1lbnRvID0gdGhpcy5maW5kUHJldmlvdXNNZW1lbnRvKG1lbWVudG9PcmlnaW5hdG9yS2V5KTtcbiAgICAgIGlmIChwcmV2aW91c01lbWVudG8gPT09IE5PVF9GT1VORCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIHByZXZpb3VzIG1lbWVudG8gZm9yIFske21lbWVudG9PcmlnaW5hdG9yS2V5fV0uYCk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlc3RvcmVNZW1lbnRvKG1lbWVudG9PcmlnaW5hdG9yS2V5LCBwcmV2aW91c01lbWVudG8pO1xuICAgIH1cbiAgICB0aGlzLmhpc3RvcnlJbmRleCAtPSAxO1xuICAgIHRoaXMuZGVidWdFdmVudChgSGlzdG9yeSB1bmRvOiBbJHt1bmRvQWN0aW9uLmxhYmVsfV1gKTtcbiAgfVxuICByZWRvKCkge1xuICAgIGNvbnN0IHJlZG9BY3Rpb24gPSB0aGlzLmhpc3RvcnlbdGhpcy5oaXN0b3J5SW5kZXggKyAxXTtcbiAgICBpZiAoIXJlZG9BY3Rpb24pXG4gICAgICByZXR1cm47XG4gICAgZm9yIChjb25zdCBbbWVtZW50b09yaWdpbmF0b3JLZXksIG1lbWVudG9dIG9mIHJlZG9BY3Rpb24ubWVtZW50b3MuZW50cmllcygpKSB7XG4gICAgICB0aGlzLnJlc3RvcmVNZW1lbnRvKG1lbWVudG9PcmlnaW5hdG9yS2V5LCBtZW1lbnRvKTtcbiAgICB9XG4gICAgdGhpcy5oaXN0b3J5SW5kZXggKz0gMTtcbiAgICB0aGlzLmRlYnVnRXZlbnQoYEhpc3RvcnkgcmVkbzogWyR7cmVkb0FjdGlvbi5sYWJlbH1dYCk7XG4gIH1cbiAgZmluZFByZXZpb3VzTWVtZW50byhtZW1lbnRvT3JpZ2luYXRvcktleSkge1xuICAgIGZvciAobGV0IGkgPSB0aGlzLmhpc3RvcnlJbmRleCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAodGhpcy5oaXN0b3J5W2ldLm1lbWVudG9zLmhhcyhtZW1lbnRvT3JpZ2luYXRvcktleSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGlzdG9yeVtpXS5tZW1lbnRvcy5nZXQobWVtZW50b09yaWdpbmF0b3JLZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5jbGVhclN0YXRlLmhhcyhtZW1lbnRvT3JpZ2luYXRvcktleSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmNsZWFyU3RhdGUuZ2V0KG1lbWVudG9PcmlnaW5hdG9yS2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIE5PVF9GT1VORDtcbiAgfVxuICByZXN0b3JlTWVtZW50byhtZW1lbnRvT3JpZ2luYXRvcktleSwgbWVtZW50bykge1xuICAgIHRoaXMub3JpZ2luYXRvcnMuZ2V0KG1lbWVudG9PcmlnaW5hdG9yS2V5KT8ucmVzdG9yZU1lbWVudG8oVkVSU0lPTiwgVkVSU0lPTiwgbWVtZW50byk7XG4gIH1cbiAgZGVidWdFdmVudCguLi5sb2dDb250ZW50KSB7XG4gICAgdGhpcy5kZWJ1ZyhcbiAgICAgIC4uLmxvZ0NvbnRlbnQsXG4gICAgICB0aGlzLmhpc3RvcnkubWFwKChhY3Rpb24sIGluZGV4KSA9PiBpbmRleCA9PT0gdGhpcy5oaXN0b3J5SW5kZXggPyBgKiogJHthY3Rpb24ubGFiZWx9ICoqYCA6IGFjdGlvbi5sYWJlbClcbiAgICApO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9hcGkvc3RhdGUvbWVtZW50by50c1xudmFyIE1lbWVudG9DYXJldGFrZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHZlcnNpb24pIHtcbiAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uLnNwbGl0KFwiLVwiKVswXTtcbiAgfVxuICBzYXZlKC4uLm9yaWdpbmF0b3JzKSB7XG4gICAgY29uc3QgcGFja2V0ID0geyB2ZXJzaW9uOiB0aGlzLnZlcnNpb24gfTtcbiAgICBmb3IgKGNvbnN0IG9yaWdpbmF0b3Igb2YgT2JqZWN0LnZhbHVlcyhvcmlnaW5hdG9ycykpIHtcbiAgICAgIHBhY2tldFtvcmlnaW5hdG9yLm1lbWVudG9PcmlnaW5hdG9yS2V5XSA9IHRoaXMuZW5jb2RlKG9yaWdpbmF0b3IsIG9yaWdpbmF0b3IuY3JlYXRlTWVtZW50bygpKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhY2tldDtcbiAgfVxuICByZXN0b3JlKGJsb2IsIC4uLm9yaWdpbmF0b3JzKSB7XG4gICAgaWYgKHR5cGVvZiBibG9iICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICBMb2dnZXIud2Fybk9uY2UoYENvdWxkIG5vdCByZXN0b3JlIGRhdGEgb2YgdHlwZSBbJHt0eXBlb2YgYmxvYn1dLCBleHBlY3RpbmcgYW4gb2JqZWN0LCBpZ25vcmluZy5gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGJsb2IgPT0gbnVsbCkge1xuICAgICAgTG9nZ2VyLndhcm5PbmNlKGBDb3VsZCBub3QgcmVzdG9yZSBkYXRhIG9mIHR5cGUgW251bGxdLCBleHBlY3RpbmcgYW4gb2JqZWN0LCBpZ25vcmluZy5gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCEoXCJ2ZXJzaW9uXCIgaW4gYmxvYikgfHwgdHlwZW9mIGJsb2IudmVyc2lvbiAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgTG9nZ2VyLndhcm5PbmNlKGBDb3VsZCBub3QgcmVzdG9yZSBkYXRhLCBtaXNzaW5nIFt2ZXJzaW9uXSBzdHJpbmcgaW4gb2JqZWN0LCBpZ25vcmluZy5gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBvcmlnaW5hdG9yIG9mIG9yaWdpbmF0b3JzKSB7XG4gICAgICBpZiAoIShvcmlnaW5hdG9yLm1lbWVudG9PcmlnaW5hdG9yS2V5IGluIGJsb2IpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgbWVtZW50byA9IHRoaXMuZGVjb2RlKG9yaWdpbmF0b3IsIGJsb2Jbb3JpZ2luYXRvci5tZW1lbnRvT3JpZ2luYXRvcktleV0pO1xuICAgICAgaWYgKCFvcmlnaW5hdG9yLmd1YXJkTWVtZW50byhtZW1lbnRvKSkge1xuICAgICAgICBMb2dnZXIud2Fybk9uY2UoXG4gICAgICAgICAgYENvdWxkIG5vdCByZXN0b3JlIFske29yaWdpbmF0b3IubWVtZW50b09yaWdpbmF0b3JLZXl9XSBkYXRhLCB2YWx1ZSB3YXMgaW52YWxpZCwgaWdub3JpbmcuYCxcbiAgICAgICAgICBtZW1lbnRvXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG9yaWdpbmF0b3IucmVzdG9yZU1lbWVudG8odGhpcy52ZXJzaW9uLCBibG9iLnZlcnNpb24sIG1lbWVudG8pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRW5jb2RlIGEgbWVtZW50byBhcyBhIHNlcmlhbGl6YWJsZSBvYmplY3QsIGVuY29kaW5nIGFueSBub24tc2VyaWFsaXpibGUgdHlwZXMuXG4gICAqL1xuICBlbmNvZGUob3JpZ2luYXRvciwgbWVtZW50bykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShtZW1lbnRvLCB0aGlzLmVuY29kZVR5cGVzKSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGVuY29kZSBbJHtvcmlnaW5hdG9yLm1lbWVudG9PcmlnaW5hdG9yS2V5fV0gdmFsdWUgWyR7ZXJyb3J9XS5gLCB7XG4gICAgICAgIGNhdXNlOiBlcnJvclxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBEZWNvZGUgYW4gZW5jb2RlZCBtZW1lbnRvLCBkZWNvZGluZyBhbnkgbm9uLXNlcmlhbGl6YWJsZSB0eXBlcy5cbiAgICovXG4gIGRlY29kZShvcmlnaW5hdG9yLCBlbmNvZGVkKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGVuY29kZWQpLCB0aGlzLmRlY29kZVR5cGVzKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZGVjb2RlIFske29yaWdpbmF0b3IubWVtZW50b09yaWdpbmF0b3JLZXl9XSB2YWx1ZSBbJHtlcnJvcn1dLmAsIHtcbiAgICAgICAgY2F1c2U6IGVycm9yXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZW5jb2RlVHlwZXMoa2V5LCB2YWx1ZSkge1xuICAgIGlmIChpc0RhdGUodGhpc1trZXldKSkge1xuICAgICAgcmV0dXJuIHsgX190eXBlOiBcImRhdGVcIiwgdmFsdWU6IFN0cmluZyh0aGlzW2tleV0pIH07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBkZWNvZGVUeXBlcyhrZXksIHZhbHVlKSB7XG4gICAgaWYgKGlzT2JqZWN0KHRoaXNba2V5XSkgJiYgXCJfX3R5cGVcIiBpbiB0aGlzW2tleV0gJiYgdGhpc1trZXldLl9fdHlwZSA9PT0gXCJkYXRlXCIpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzW2tleV0udmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2FwaS9zdGF0ZS9zdGF0ZU1hbmFnZXIudHNcbnZhciBTdGF0ZU1hbmFnZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY2FyZXRha2VyID0gbmV3IE1lbWVudG9DYXJldGFrZXIoVkVSU0lPTik7XG4gICAgdGhpcy5zdGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgc2V0U3RhdGUob3JpZ2luYXRvciwgdmFsdWUpIHtcbiAgICBpZiAoanNvbkRpZmYodGhpcy5zdGF0ZS5nZXQob3JpZ2luYXRvci5tZW1lbnRvT3JpZ2luYXRvcktleSksIHZhbHVlKSA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc3RhdGUuc2V0KG9yaWdpbmF0b3IubWVtZW50b09yaWdpbmF0b3JLZXksIHZhbHVlKTtcbiAgICB0aGlzLnJlc3RvcmVTdGF0ZShvcmlnaW5hdG9yKTtcbiAgfVxuICByZXN0b3JlU3RhdGUob3JpZ2luYXRvcikge1xuICAgIGNvbnN0IHsgY2FyZXRha2VyLCBzdGF0ZSB9ID0gdGhpcztcbiAgICBpZiAoIXN0YXRlLmhhcyhvcmlnaW5hdG9yLm1lbWVudG9PcmlnaW5hdG9yS2V5KSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB2YWx1ZSA9IHN0YXRlLmdldChvcmlnaW5hdG9yLm1lbWVudG9PcmlnaW5hdG9yS2V5KTtcbiAgICBjYXJldGFrZXIucmVzdG9yZSh7IHZlcnNpb246IGNhcmV0YWtlci52ZXJzaW9uLCBbb3JpZ2luYXRvci5tZW1lbnRvT3JpZ2luYXRvcktleV06IHZhbHVlIH0sIG9yaWdpbmF0b3IpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zdHlsZXMuY3NzXG52YXIgc3R5bGVzX2RlZmF1bHQgPSAnLmFnLWNoYXJ0cy13cmFwcGVyLC5hZy1jaGFydHMtd3JhcHBlcjpmb2N1cywuYWctY2hhcnRzLXdyYXBwZXI6YWZ0ZXIsLmFnLWNoYXJ0cy13cmFwcGVyOmJlZm9yZSwuYWctY2hhcnRzLXdyYXBwZXIgKiwuYWctY2hhcnRzLXdyYXBwZXIgKjpmb2N1cywuYWctY2hhcnRzLXdyYXBwZXIgKjphZnRlciwuYWctY2hhcnRzLXdyYXBwZXIgKjpiZWZvcmV7Ym94LXNpemluZzpib3JkZXItYm94O291dGxpbmU6bm9uZX0uYWctY2hhcnRzLXdyYXBwZXJ7cG9zaXRpb246cmVsYXRpdmU7dXNlci1zZWxlY3Q6bm9uZX0uYWctY2hhcnRzLWNhbnZhcy1jZW50ZXJ7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtwb3NpdGlvbjphYnNvbHV0ZTt0b3VjaC1hY3Rpb246YXV0bztkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6dmFyKC0tYWctY2hhcnRzLWFsaWduKTtqdXN0aWZ5LWNvbnRlbnQ6dmFyKC0tYWctY2hhcnRzLWp1c3RpZnkpfS5hZy1jaGFydHMtY2FudmFzLWNvbnRhaW5lciwuYWctY2hhcnRzLWNhbnZhc3twb3NpdGlvbjpyZWxhdGl2ZTt1c2VyLXNlbGVjdDpub25lfS5hZy1jaGFydHMtY2FudmFzLWNvbnRhaW5lcj4qLC5hZy1jaGFydHMtY2FudmFzPip7ZGlzcGxheTpibG9jaztwb2ludGVyLWV2ZW50czpub25lfS5hZy1jaGFydHMtc2VyaWVzLWFyZWF7b3BhY2l0eTowO3BvaW50ZXItZXZlbnRzOmF1dG87cG9zaXRpb246YWJzb2x1dGV9LmFnLWNoYXJ0cy1zZXJpZXMtYXJlYTpmb2N1cy12aXNpYmxle29wYWNpdHk6MX0uYWctY2hhcnRzLWNhbnZhcy1wcm94eSwuYWctY2hhcnRzLWNhbnZhcy1vdmVybGF5e2luc2V0OjA7cG9pbnRlci1ldmVudHM6bm9uZTtwb3NpdGlvbjphYnNvbHV0ZTt1c2VyLXNlbGVjdDpub25lfS5hZy1jaGFydHMtY2FudmFzLW92ZXJsYXk+Kntwb3NpdGlvbjphYnNvbHV0ZTtwb2ludGVyLWV2ZW50czphdXRvfS5hZy1jaGFydHMtdGhlbWUtZGVmYXVsdCwuYWctY2hhcnRzLXRoZW1lLWRlZmF1bHQtZGFya3stLWFnLWNoYXJ0cy1hY3RpdmUtY29sb3I6IHZhcigtLWFnLWFjdGl2ZS1jb2xvciwgIzIxOTZmMyk7LS1hZy1jaGFydHMtYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tYWctYmFja2dyb3VuZC1jb2xvciwgI2ZmZik7LS1hZy1jaGFydHMtZm9yZWdyb3VuZC1jb2xvcjogdmFyKC0tYWctZm9yZWdyb3VuZC1jb2xvciwgIzE4MWQxZik7LS1hZy1jaGFydHMtYm9yZGVyLWNvbG9yOiB2YXIoLS1hZy1ib3JkZXItY29sb3IsICNkZGRkZGQpOy0tYWctY2hhcnRzLWhvdmVyLWNvbG9yOiBjb2xvci1taXgoaW4gc3JnYiwgdmFyKC0tYWctY2hhcnRzLWJhY2tncm91bmQtY29sb3IpLCB2YXIoLS1hZy1jaGFydHMtYWN0aXZlLWNvbG9yKSAxMiUpOy0tYWctY2hhcnRzLWZvbnQtZmFtaWx5OiBcIlZlcmRhbmFcIiwgc2Fucy1zZXJpZjstLWFnLWNoYXJ0cy1mb250LXNpemU6IHZhcigtLWFnLWZvbnQtc2l6ZSwgMTRweCk7LS1hZy1jaGFydHMtc2l6ZTogdmFyKC0tYWctZ3JpZC1zaXplLCA4cHgpOy0tYWctY2hhcnRzLWJvcmRlcjogdmFyKC0tYWctY2hhcnRzLWJvcmRlci1jb2xvcikgdmFyKC0tYWctYm9yZGVycywgc29saWQgMXB4KTstLWFnLWNoYXJ0cy1ib3JkZXItY3JpdGljYWw6IHZhcigtLWFnLWJvcmRlcnMtY3JpdGljYWwsIHNvbGlkIDFweCk7LS1hZy1jaGFydHMtbGF5ZXItdWktb3ZlcmxheTogNTstLWFnLWNoYXJ0cy1sYXllci10b29sdGlwOiA0Oy0tYWctY2hhcnRzLWxheWVyLXRvb2xiYXI6IDM7LS1hZy1jaGFydHMtbGF5ZXItY3Jvc3NoYWlyOiAyOy0tYWctY2hhcnRzLWxheWVyLWFubm90YXRpb25zOiAxOy0tYWctY2hhcnRzLWFsaWduOiBjZW50ZXI7LS1hZy1jaGFydHMtanVzdGlmeTogY2VudGVyOy0tYWctY2hhcnRzLWF4aXMtbGFiZWwtYmFja2dyb3VuZC1jb2xvcjogIzQ3NDc0NzstLWFnLWNoYXJ0cy1heGlzLWxhYmVsLWNvbG9yOiAjZmZmZmZmOy0tYWctY2hhcnRzLXRvb2xiYXItZm9yZWdyb3VuZC1jb2xvcjogdmFyKC0tYWctaGVhZGVyLWZvcmVncm91bmQtY29sb3IsIHZhcigtLWFnLWNoYXJ0cy1mb3JlZ3JvdW5kLWNvbG9yKSk7LS1hZy1jaGFydHMtdG9vbGJhci1iYWNrZ3JvdW5kLWNvbG9yOiB2YXIoIC0tYWctaGVhZGVyLWJhY2tncm91bmQtY29sb3IsIGNvbG9yLW1peChpbiBzcmdiLCB2YXIoLS1hZy1jaGFydHMtYmFja2dyb3VuZC1jb2xvciksIHZhcigtLWFnLWNoYXJ0cy1mb3JlZ3JvdW5kLWNvbG9yKSAyJSkgKTstLWFnLWNoYXJ0cy10b29sYmFyLXNpemU6IDM0cHg7LS1hZy1jaGFydHMtdG9vbGJhci1zaXplLXNtYWxsOiAyNHB4Oy0tYWctY2hhcnRzLXRvb2xiYXItYm9yZGVyOiB2YXIoLS1hZy1jaGFydHMtYm9yZGVyLWNyaXRpY2FsLCBzb2xpZCAxcHgpIHZhcigtLWFnLWNoYXJ0cy1ib3JkZXItY29sb3IpOy0tYWctY2hhcnRzLXRvb2xiYXItaG92ZXItY29sb3I6IGNvbG9yLW1peCggaW4gc3JnYiwgdmFyKC0tYWctY2hhcnRzLWJhY2tncm91bmQtY29sb3IpLCB2YXIoLS1hZy1jaGFydHMtYWN0aXZlLWNvbG9yKSAxMiUgKTstLWFnLWNoYXJ0cy10b29sYmFyLWZvY3VzLWNvbG9yOiB2YXIoLS1hZy1jaGFydHMtYWN0aXZlLWNvbG9yKTstLWFnLWNoYXJ0cy10b29sYmFyLWFjdGl2ZS1iYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1ob3Zlci1jb2xvcik7LS1hZy1jaGFydHMtdG9vbGJhci1hY3RpdmUtY29sb3I6IHZhcigtLWFnLWNoYXJ0cy1hY3RpdmUtY29sb3IpOy0tYWctY2hhcnRzLXRvb2xiYXItZGlzYWJsZWQtZm9yZWdyb3VuZC1jb2xvcjogdmFyKCAtLWFnLWRpc2FibGVkLWZvcmVncm91bmQtY29sb3IsIGNvbG9yLW1peChpbiBzcmdiLCB0cmFuc3BhcmVudCwgdmFyKC0tYWctY2hhcnRzLXRvb2xiYXItZm9yZWdyb3VuZC1jb2xvcikgNTAlKSApOy0tYWctY2hhcnRzLXRvb2xiYXItZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjogY29sb3ItbWl4KCBpbiBzcmdiLCB2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1iYWNrZ3JvdW5kLWNvbG9yKSwgdmFyKC0tYWctY2hhcnRzLXRvb2xiYXItZm9yZWdyb3VuZC1jb2xvcikgNiUgKTstLWFnLWNoYXJ0cy10b29sYmFyLWdhcDogdmFyKC0tYWctY2hhcnRzLXNpemUpOy0tYWctY2hhcnRzLXRvb2xiYXItZm9udC1zaXplOiAxM3B4Oy0tYWctY2hhcnRzLXRvb2xiYXItZm9udC1zaXplLXNtYWxsOiAxMnB4Oy0tYWctY2hhcnRzLXRvb2xiYXItYnV0dG9uLXBhZGRpbmc6IDZweDstLWFnLWNoYXJ0cy10b29sYmFyLWJ1dHRvbi1wYWRkaW5nLXNtYWxsOiAxcHg7LS1hZy1jaGFydHMtcG9wb3Zlci1iYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1iYWNrZ3JvdW5kLWNvbG9yKTstLWFnLWNoYXJ0cy1wb3BvdmVyLWZvcmVncm91bmQtY29sb3I6IHZhcigtLWFnLWNoYXJ0cy10b29sYmFyLWZvcmVncm91bmQtY29sb3IpOy0tYWctY2hhcnRzLXBvcG92ZXItYm9yZGVyOiB2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1ib3JkZXIpOy0tYWctY2hhcnRzLXBvcG92ZXItYm9yZGVyLXJhZGl1czogdmFyKC0tYWctYm9yZGVyLXJhZGl1cywgNHB4KTstLWFnLWNoYXJ0cy1wb3BvdmVyLWFjdGl2ZS1jb2xvcjogdmFyKC0tYWctY2hhcnRzLXRvb2xiYXItYWN0aXZlLWNvbG9yKTstLWFnLWNoYXJ0cy1wb3BvdmVyLWhvdmVyLWNvbG9yOiB2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1ob3Zlci1jb2xvcik7LS1hZy1jaGFydHMtcG9wb3Zlci1hY3RpdmUtYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tYWctY2hhcnRzLXRvb2xiYXItYWN0aXZlLWJhY2tncm91bmQtY29sb3IpOy0tYWctY2hhcnRzLXBvcG92ZXItZm9udC1zaXplOiAxNHB4Oy0tYWctY2hhcnRzLXBvcG92ZXItZm9udC1zaXplLXNtYWxsOiB2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1mb250LXNpemUtc21hbGwpOy0tYWctY2hhcnRzLWRpYWxvZy1pbnB1dC1ncm91cC1sYWJlbC1jb2xvcjogY29sb3ItbWl4KGluIHNyZ2IsIHRyYW5zcGFyZW50LCB2YXIoLS1hZy1jaGFydHMtZm9yZWdyb3VuZC1jb2xvcikgNTUlKTstLWFnLWNoYXJ0cy1kaWFsb2ctdGFiLWNvbG9yLS1pbmFjdGl2ZTogY29sb3ItbWl4KGluIHNyZ2IsIHRyYW5zcGFyZW50LCB2YXIoLS1hZy1jaGFydHMtZm9yZWdyb3VuZC1jb2xvcikgNTUlKTstLWFnLWNoYXJ0cy1idXR0b24tcmFkaXVzOiB2YXIoLS1hZy1ib3JkZXItcmFkaXVzLCA0cHgpOy0tYWctY2hhcnRzLWZvY3VzLWJvcmRlci1jb2xvcjogdmFyKC0tYWctaW5wdXQtZm9jdXMtYm9yZGVyLWNvbG9yLCB2YXIoLS1hZy1jaGFydHMtYWN0aXZlLWNvbG9yKSk7LS1hZy1jaGFydHMtZm9jdXMtYm9yZGVyOiBzb2xpZCAxcHggdmFyKC0tYWctY2hhcnRzLWZvY3VzLWJvcmRlci1jb2xvcik7LS1hZy1jaGFydHMtZm9jdXMtYm9yZGVyLXNoYWRvdzogdmFyKCAtLWFnLWlucHV0LWZvY3VzLWJveC1zaGFkb3csIDAgMCAwIDNweCBjb2xvci1taXgoaW4gc3JnYiwgdHJhbnNwYXJlbnQsIHZhcigtLWFnLWlucHV0LWZvY3VzLWJvcmRlci1jb2xvciwgdmFyKC0tYWctY2hhcnRzLWFjdGl2ZS1jb2xvcikpIDIwJSkgKTstLWFnLWNoYXJ0cy1mb2N1cy1ib3gtc2hhZG93OiB2YXIoLS1ib3gtc2hhZG93KSwgMCAwIDAgMnB4ICNmZmY4LCB2YXIoLS1hZy1jaGFydHMtZm9jdXMtYm9yZGVyLXNoYWRvdyk7LS1hZy1jaGFydHMtaWNvbi1mb250LWZhbWlseTogXCJhZ0NoYXJ0c0RlZmF1bHRcIjstLWFnLWNoYXJ0cy1pY29uLWZvbnQtd2VpZ2h0OiBub3JtYWw7LS1hZy1jaGFydHMtaWNvbi1mb250LWNvbG9yOiBjb2xvci1taXgoaW4gc3JnYiwgdHJhbnNwYXJlbnQsIHZhcigtLWFnLWNoYXJ0cy1mb3JlZ3JvdW5kLWNvbG9yKSwgOTAlKTstLWFnLWNoYXJ0cy1pY29uLXNpemU6IDIwcHg7LS1hZy1jaGFydHMtaW5wdXQtYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tYWctY2hhcnRzLWJhY2tncm91bmQtY29sb3IpOy0tYWctY2hhcnRzLWlucHV0LWJhY2tncm91bmQtY29sb3ItLWhvdmVyOiB2YXIoLS1hZy1jaGFydHMtaG92ZXItY29sb3IpOy0tYWctY2hhcnRzLWlucHV0LWJhY2tncm91bmQtY29sb3ItLWFjdGl2ZTogdmFyKC0tYWctY2hhcnRzLWhvdmVyLWNvbG9yKTstLWFnLWNoYXJ0cy1pbnB1dC1ib3JkZXItY29sb3I6IHZhcigtLWFnLWNoYXJ0cy1ib3JkZXItY29sb3IpOy0tYWctY2hhcnRzLWlucHV0LWJvcmRlci1jb2xvci0tYWN0aXZlOiB2YXIoLS1hZy1jaGFydHMtYWN0aXZlLWNvbG9yKTstLWFnLWNoYXJ0cy1pbnB1dC1ib3JkZXItcmFkaXVzOiB2YXIoLS1hZy1ib3JkZXItcmFkaXVzLCA0cHgpOy0tYWctY2hhcnRzLWlucHV0LWNvbG9yLS1hY3RpdmU6IHZhcigtLWFnLWNoYXJ0cy1hY3RpdmUtY29sb3IpOy0tYWctY2hhcnRzLWlucHV0LWZvY3VzLW91dGxpbmU6IHZhcigtLWFnLWNoYXJ0cy1mb2N1cy1ib3JkZXIpOy0tYWctY2hhcnRzLWlucHV0LWZvY3VzLWJveC1zaGFkb3c6IHZhcigtLWFnLWNoYXJ0cy1mb2N1cy1ib3JkZXItc2hhZG93KTstLWFnLWNoYXJ0cy1pbnB1dC1mb250LWZhbWlseTogdmFyKC0tYWctY2hhcnRzLWZvbnQtZmFtaWx5KTstLWFnLWNoYXJ0cy1pbnB1dC1mb250LXNpemU6IHZhcigtLWFnLWNoYXJ0cy1mb250LXNpemUpOy0tYWctY2hhcnRzLWlucHV0LXBhZGRpbmc6IDhweDstLWFnLWNoYXJ0cy1pbnB1dC1wYWRkaW5nLWxhcmdlOiAxMHB4Oy0tYWctY2hhcnRzLWlucHV0LXBsYWNlaG9sZGVyLWNvbG9yOiAjODg4ODg4Oy0tYWctY2hhcnRzLWlucHV0LXNwYWNpbmc6IDhweDstLWFnLWNoYXJ0cy1pbnB1dC10cmFuc2l0aW9uLWR1cmF0aW9uOiAuMjVzOy0tYWctY2hhcnRzLWlucHV0LXRyYW5zaXRpb24tZHVyYXRpb24tLWZhc3Q6IC4xczstLWFnLWNoYXJ0cy1pbnB1dC10cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjogZWFzZS1vdXQ7LS1hZy1jaGFydHMtaW5wdXQtY2hlY2tib3gtYmFja2dyb3VuZC1jb2xvcjogI2JhYmJiYzstLWFnLWNoYXJ0cy1pbnB1dC1jaGVja2JveC1iYWNrZ3JvdW5kLWNvbG9yLS1jaGVja2VkOiB2YXIoLS1hZy1jaGFydHMtYWN0aXZlLWNvbG9yKX0uYWctY2hhcnRzLXRoZW1lLWRlZmF1bHQtZGFya3stLWFnLWNoYXJ0cy1iYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1hZy1iYWNrZ3JvdW5kLWNvbG9yLCBjb2xvci1taXgoaW4gc3JnYiwgI2ZmZiwgIzE4MjIzMCA5NyUpKTstLWFnLWNoYXJ0cy1mb3JlZ3JvdW5kLWNvbG9yOiB2YXIoLS1hZy1mb3JlZ3JvdW5kLWNvbG9yLCAjZmZmKTstLWFnLWNoYXJ0cy1ib3JkZXItY29sb3I6IHZhcigtLWFnLWJvcmRlci1jb2xvciwgcmdiYSgyNTUsIDI1NSwgMjU1LCAuMTYpKTstLWFnLWNoYXJ0cy1ob3Zlci1jb2xvcjogY29sb3ItbWl4KGluIHNyZ2IsIHZhcigtLWFnLWNoYXJ0cy1iYWNrZ3JvdW5kLWNvbG9yKSwgdmFyKC0tYWctY2hhcnRzLWFjdGl2ZS1jb2xvcikgMTglKTstLWFnLWNoYXJ0cy1heGlzLWxhYmVsLWJhY2tncm91bmQtY29sb3I6ICM5Y2FlYmI7LS1hZy1jaGFydHMtYXhpcy1sYWJlbC1jb2xvcjogIzAwMDAwMDstLWFnLWNoYXJ0cy10b29sYmFyLWJhY2tncm91bmQtY29sb3I6IHZhcigtLWFnLWhlYWRlci1iYWNrZ3JvdW5kLWNvbG9yLCBjb2xvci1taXgoaW4gc3JnYiwgI2ZmZiwgIzE4MjIzMCA5MyUpKTstLWFnLWNoYXJ0cy10b29sYmFyLWhvdmVyLWNvbG9yOiBjb2xvci1taXgoIGluIHNyZ2IsIHZhcigtLWFnLWNoYXJ0cy1iYWNrZ3JvdW5kLWNvbG9yKSwgdmFyKC0tYWctY2hhcnRzLWFjdGl2ZS1jb2xvcikgMTglICk7LS1hZy1jaGFydHMtZGlhbG9nLWlucHV0LWdyb3VwLWxhYmVsLXRleHQtY29sb3I6ICNmZmZmZmY7LS1hZy1jaGFydHMtZm9jdXMtYm9yZGVyLXNoYWRvdzogdmFyKCAtLWFnLWlucHV0LWZvY3VzLWJveC1zaGFkb3csIDAgMCAwIDNweCBjb2xvci1taXgoaW4gc3JnYiwgdHJhbnNwYXJlbnQsIHZhcigtLWFnLWlucHV0LWZvY3VzLWJvcmRlci1jb2xvciwgdmFyKC0tYWctY2hhcnRzLWFjdGl2ZS1jb2xvcikpIDIwJSkgKTstLWFnLWNoYXJ0cy1pbnB1dC1wbGFjZWhvbGRlci1jb2xvcjogI2FhYWFhYX0uYWctY2hhcnRzLWljb257ZGlzcGxheTpibG9jazt3aWR0aDp2YXIoLS1hZy1jaGFydHMtaWNvbi1zaXplKTtoZWlnaHQ6dmFyKC0tYWctY2hhcnRzLWljb24tc2l6ZSk7c3BlYWs6bm9uZTtzcGVhazpuZXZlcjttYXNrOnZhcigtLWljb24pIGNlbnRlciAvIGNvbnRhaW4gbm8tcmVwZWF0O2JhY2tncm91bmQtY29sb3I6Y3VycmVudENvbG9yO3RyYW5zaXRpb246YmFja2dyb3VuZC1jb2xvciAuMjVzIGVhc2UtaW4tb3V0fS5hZy1jaGFydHMtaWNvbi1hbGlnbi1jZW50ZXJ7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTWpBaUlHaGxhV2RvZEQwaU1qQWlJSFpwWlhkQ2IzZzlJakFnTUNBeU1DQXlNQ0lnWm1sc2JEMGlibTl1WlNJZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWo0OGNHRjBhQ0JtYVd4c1BTSWpNREF3SWlCa1BTSk5OeUF4TUdnMmRqRklOM3BOTkNBM2FERXlkakZJTkhwdE1TQTJhREV3ZGpGSU5Yb2lMejQ4TDNOMlp6ND0pfS5hZy1jaGFydHMtaWNvbi1hbGlnbi1sZWZ0ey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1qQWlJR2hsYVdkb2REMGlNakFpSUhacFpYZENiM2c5SWpBZ01DQXlNQ0F5TUNJZ1ptbHNiRDBpYm05dVpTSWdlRzFzYm5NOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6SXdNREF2YzNabklqNDhjR0YwYUNCbWFXeHNQU0lqTURBd0lpQmtQU0pOTkNBeE1HZzJkakZJTkhwdE1DMHphREV5ZGpGSU5IcHRNQ0EyYURFd2RqRklOSG9pTHo0OEwzTjJaejQ9KX0uYWctY2hhcnRzLWljb24tYWxpZ24tcmlnaHR7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTWpBaUlHaGxhV2RvZEQwaU1qQWlJSFpwWlhkQ2IzZzlJakFnTUNBeU1DQXlNQ0lnWm1sc2JEMGlibTl1WlNJZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWo0OGNHRjBhQ0JtYVd4c1BTSWpNREF3SWlCa1BTSk5NVEFnTVRCb05uWXhhQzAyZWswMElEZG9NVEoyTVVnMGVtMHlJRFpvTVRCMk1VZzJlaUl2UGp3dmMzWm5QZz09KX0uYWctY2hhcnRzLWljb24tYXJyb3ctZHJhd2luZ3stLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNakFpSUdobGFXZG9kRDBpTWpBaUlIWnBaWGRDYjNnOUlqQWdNQ0F5TUNBeU1DSWdabWxzYkQwaWJtOXVaU0lnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JajQ4Y0dGMGFDQm1hV3hzTFhKMWJHVTlJbVYyWlc1dlpHUWlJR05zYVhBdGNuVnNaVDBpWlhabGJtOWtaQ0lnWkQwaVRURTFMakk1TXlBMExqVklNVEl1TlhZdE1VZ3hOM1kwYUMweFZqVXVNakEzYkMwNUxqWTBOaUE1TGpZME55MHVOekE0TFM0M01EaDZJaUJtYVd4c1BTSWpNREF3SWk4K1BIQmhkR2dnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCamJHbHdMWEoxYkdVOUltVjJaVzV2WkdRaUlHUTlJazAzSURFMllUSXVOU0F5TGpVZ01DQXhJREV0TlNBd0lESXVOU0F5TGpVZ01DQXdJREVnTlNBd2JTMHlMalVnTVM0MVlURXVOU0F4TGpVZ01DQXhJREFnTUMweklERXVOU0F4TGpVZ01DQXdJREFnTUNBeklpQm1hV3hzUFNJak1EQXdJaTgrUEM5emRtYyspfS5hZy1jaGFydHMtaWNvbi1hcnJvdy1kb3duLWRyYXdpbmd7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTWpBaUlHaGxhV2RvZEQwaU1qQWlJSFpwWlhkQ2IzZzlJakFnTUNBeU1DQXlNQ0lnWm1sc2JEMGlibTl1WlNJZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWo0S1BIQmhkR2dnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCamJHbHdMWEoxYkdVOUltVjJaVzV2WkdRaUlHUTlJazAySURoTU1TNDFJRGhNTVRBZ01UaE1NVGd1TlNBNFRERTBJRGhNTVRRZ00wdzJJRE5NTmlBNFdrMDNJRFJNTnlBNVNETXVOall5TkRSTU1UQWdNVFl1TkRVMlRERTJMak16TnpZZ09Vd3hNeUE1VERFeklEUk1OeUEwV2lJZ1ptbHNiRDBpWW14aFkyc2lMejRLUEM5emRtYytDZz09KX0uYWctY2hhcnRzLWljb24tYXJyb3ctdXAtZHJhd2luZ3stLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNakFpSUdobGFXZG9kRDBpTWpBaUlIWnBaWGRDYjNnOUlqQWdNQ0F5TUNBeU1DSWdabWxzYkQwaWJtOXVaU0lnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JajRLUEhCaGRHZ2dabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJqYkdsd0xYSjFiR1U5SW1WMlpXNXZaR1FpSUdROUlrMHhOQ0F4TWtneE9DNDFUREV3SURKTU1TNDFJREV5U0RaTU5pNHdNREF3TWlBeE4wZ3hORll4TWxwTk1UTWdNVFpXTVRGSU1UWXVNek0zTmt3eE1DQXpMalUwTkRBMVRETXVOall5TkRRZ01URklOMHczTGpBd01EQXlJREUyU0RFeldpSWdabWxzYkQwaVlteGhZMnNpTHo0S1BDOXpkbWMrQ2c9PSl9LmFnLWNoYXJ0cy1pY29uLWNhbGxvdXQtYW5ub3RhdGlvbnstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpBd01DSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKTk15QTBMalZCTVM0MUlERXVOU0F3SURBZ01TQTBMalVnTTJneE1VRXhMalVnTVM0MUlEQWdNQ0F4SURFM0lEUXVOWFk0WVRFdU5TQXhMalVnTUNBd0lERXRNUzQxSURFdU5XZ3ROQzQxTVRSaE1qWWdNallnTUNBd0lEQXRNaTR3TVRjZ01TNDFOR3d0TGpNeE5DNHlObU10TGpVMUxqUTFOeTB4TGpFeE5TNDVNall0TVM0M05pQXhMalF0TGpZMk9TNDBPVEV0TVM0MU5qSXRMakF4TWkweExqVTJNaTB1T0ZZeE5FZzBMalZCTVM0MUlERXVOU0F3SURBZ01TQXpJREV5TGpWNlRUUXVOU0EwWVM0MUxqVWdNQ0F3SURBdExqVXVOWFk0WVM0MUxqVWdNQ0F3SURBZ0xqVXVOV2d4TGpnek0zWXpMak0zTW1Fek5pQXpOaUF3SURBZ01DQXhMalkzT0MweExqTXpPR3d1TXpJdExqSTJOV0V5TmlBeU5pQXdJREFnTVNBeUxqSXlOUzB4TGpZNE5Xd3VNVEkyTFM0d09EUklNVFV1TldFdU5TNDFJREFnTUNBd0lDNDFMUzQxZGkwNFlTNDFMalVnTUNBd0lEQXRMalV0TGpWNklpQmpiR2x3TFhKMWJHVTlJbVYyWlc1dlpHUWlMejQ4TDNOMlp6ND0pfS5hZy1jaGFydHMtaWNvbi1jYW5kbGVzdGljay1zZXJpZXN7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6RXpNVGN5TWlJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmtQU0pOTnlBeGRqTm9Nbll4TWtnM2RqTklObll0TTBnMFZqUm9NbFl4ZWswMUlEVm9NM1l4TUVnMWVrMHhNU0F4TkZZMmFESldNeTR5TldneFZqWm9Nblk0YUMweWRqSXVOelZvTFRGV01UUjZiVEV0TjJnemRqWm9MVE42SWlCamJHbHdMWEoxYkdVOUltVjJaVzV2WkdRaUx6NDhMM04yWno0PSl9LmFnLWNoYXJ0cy1pY29uLWNsb3Nley0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1qQWlJR2hsYVdkb2REMGlNakFpSUhacFpYZENiM2c5SWpBZ01DQXlNQ0F5TUNJZ1ptbHNiRDBpYm05dVpTSWdlRzFzYm5NOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6SXdNREF2YzNabklqNDhjR0YwYUNCa1BTSnROU0ExSURFd0lERXdUVFVnTVRVZ01UVWdOU0lnYzNSeWIydGxQU0lqTURBd0lpOCtQQzl6ZG1jKyl9LmFnLWNoYXJ0cy1pY29uLWNvbW1lbnQtYW5ub3RhdGlvbnstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpBd01DSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKTk55NDFNVE1nTXk0NU9UVmhOaTQxSURZdU5TQXdJREFnTVNBMkxqQTVPQ0F4TVM0ME1XTXRMalU0T0M0ek9UTXRNUzR5TVRjdU5UTTJMVEV1T0RJNUxqVTROV0V4TXlBeE15QXdJREFnTVMweExqSTNMakF4TjBFeU55QXlOeUF3SURBZ01DQXhNQ0F4TmtnMExqVmhMalV1TlNBd0lEQWdNUzB1TlMwdU5WWXhNSEV3TFM0eU5EY3RMakF3TnkwdU5URXpZeTB1TURBNExTNDBNVFl0TGpBeE5pMHVPRFUzTGpBeE55MHhMakkyT1M0d05TMHVOakV5TGpFNU1pMHhMakkwTGpVNE5TMHhMamd6WVRZdU5TQTJMalVnTUNBd0lERWdNaTQ1TVRndE1pNHpPVE50TXk0MU5pNDJNV0UxTGpVZ05TNDFJREFnTUNBd0xUVXVOalEySURJdU16UmpMUzR5TmpZdU16azNMUzR6TnprdU9EUXlMUzQwTWlBeExqTTFOQzB1TURNdU16WXRMakF5TWk0M01UZ3RMakF4TlNBeExqRXdPRkUxSURrdU5qZzVJRFVnTVRCMk5XZzFjUzR6TVRFdU1EQXhMalU1TXk0d01EaGpMak01TGpBd055NDNORGN1TURFMUlERXVNVEE0TFM0d01UVXVOVEV5TFM0d05ERXVPVFUzTFM0eE5UUWdNUzR6TlRVdExqUXlZVFV1TlNBMUxqVWdNQ0F3SURBdE1TNDVPRE10T1M0NU5qY2lJR05zYVhBdGNuVnNaVDBpWlhabGJtOWtaQ0l2UGp3dmMzWm5QZz09KX0uYWctY2hhcnRzLWljb24tY3Jvc3NoYWlyLWFkZC1saW5ley0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekF3TUNJZ1pEMGlUVEV3SURVdU5XRXVOUzQxSURBZ01DQXhJQzQxTGpWMk15NDFhRE11T0RjMVlTNDFMalVnTUNBd0lERWdNQ0F4U0RFd0xqVjJOQzR5TldFdU5TNDFJREFnTVNBeExURWdNRll4TUM0MVNEVXVOakkxWVM0MUxqVWdNQ0F4SURFZ01DMHhTRGt1TlZZMllTNDFMalVnTUNBd0lERWdMalV0TGpVaUx6NDhMM04yWno0PSl9LmFnLWNoYXJ0cy1pY29uLWRhdGUtcmFuZ2UtZHJhd2luZ3stLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNakFpSUdobGFXZG9kRDBpTWpBaUlIWnBaWGRDYjNnOUlqQWdNQ0F5TUNBeU1DSWdabWxzYkQwaWJtOXVaU0lnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JajQ4Y0dGMGFDQmtQU0pOTWlBeWFERjJNVFpJTW5wdE1UVWdNR2d4ZGpFMmFDMHhlaUlnWm1sc2JEMGlJekU0TVVReFJpSXZQanh3WVhSb0lHUTlJazB4TXk0eE5UY2dNVEZJTlhZdE1XZzNMamM1TTB3eE1TQTRMakl3TjJ3dU56QTNMUzQzTURjZ015NHhPRElnTXk0eE9ESXRNeTR4T0RJZ015NHhPREl0TGpjd055MHVOekEzZWlJZ1ptbHNiRDBpSXpBd01DSXZQand2YzNablBnPT0pfS5hZy1jaGFydHMtaWNvbi1kYXRlLXByaWNlLXJhbmdlLWRyYXdpbmd7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTWpBaUlHaGxhV2RvZEQwaU1qQWlJSFpwWlhkQ2IzZzlJakFnTUNBeU1DQXlNQ0lnWm1sc2JEMGlibTl1WlNJZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWo0OGNHRjBhQ0JrUFNKTk15QXlTREoyTVRab01YcHRNeTQxTURjZ05DNDRPVXc0TGpVZ05DNDRPVFZXTVRCSU5YWXhhRE11TlhZM2FERjJMVGRvTlM0d09EaHNMVEV1T1RVM0lERXVPVFUzTGpjd055NDNNRGNnTXk0eE9ESXRNeTR4T0RKTU1UTXVNek00SURjdU0yd3RMamN3Tnk0M01EZE1NVFF1TmpJMElERXdTRGt1TlZZMExqa3pNbXd4TGprMU55QXhMamsxTnk0M01EY3RMamN3TjB3NExqazRNaUF6SURVdU9DQTJMakU0TW5vaUlHWnBiR3c5SWlNeE9ERkVNVVlpTHo0OEwzTjJaejQ9KX0uYWctY2hhcnRzLWljb24tZGVsZXRley0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekV6TVRjeU1pSWdaRDBpVFRndU5EazJJRGd1T1RrMlFTNDFMalVnTUNBd0lERWdPU0E1TGpRNU1uWTBZUzQxTGpVZ01DQXhJREV0TVNBdU1EQTRkaTAwWVM0MUxqVWdNQ0F3SURFZ0xqUTVOaTB1TlRBMFRURXlJRGt1TldFdU5TNDFJREFnTUNBd0xURWdNSFkwWVM0MUxqVWdNQ0F3SURBZ01TQXdlaUl2UGp4d1lYUm9JR1pwYkd3OUlpTXhNekUzTWpJaUlHWnBiR3d0Y25Wc1pUMGlaWFpsYm05a1pDSWdaRDBpVFRZZ05WWXpMalZCTWk0MUlESXVOU0F3SURBZ01TQTRMalVnTVdnelFUSXVOU0F5TGpVZ01DQXdJREVnTVRRZ015NDFWalZvTWk0NE16TmhMalV1TlNBd0lEQWdNU0F3SURGSU1UVjJNVEF1TWpWak1DQXVOREUxTFM0d05qWXVPRFl6TFM0eklERXVNakl4TFM0eU5UY3VNemswTFM0Mk56SXVOakV5TFRFdU1pNDJNVEpvTFRkakxTNDFNamdnTUMwdU9UUXpMUzR5TVRndE1TNHlMUzQyTVRJdExqSXpOQzB1TXpVNExTNHpMUzQ0TURZdExqTXRNUzR5TWpGV05rZ3pMak16TTJFdU5TNDFJREFnTUNBeElEQXRNWHB0TVMweExqVkJNUzQxSURFdU5TQXdJREFnTVNBNExqVWdNbWd6UVRFdU5TQXhMalVnTUNBd0lERWdNVE1nTXk0MVZqVklOM3BOTmlBeE5pNHlOVlkyYURoMk1UQXVNalZqTUNBdU16TTFMUzR3TlRrdU5UVTBMUzR4TXpndU5qYzFMUzR3TlRVdU1EZzFMUzR4TkM0eE5UZ3RMak0yTWk0eE5UaG9MVGRqTFM0eU1qSWdNQzB1TXpBM0xTNHdOek10TGpNMk1pMHVNVFU0TFM0d09DMHVNVEl4TFM0eE16Z3RMak0wTFM0eE16Z3RMalkzTlNJZ1kyeHBjQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpOCtQQzl6ZG1jKyl9LmFnLWNoYXJ0cy1pY29uLWRpc2pvaW50LWNoYW5uZWwsLmFnLWNoYXJ0cy1pY29uLWRpc2pvaW50LWNoYW5uZWwtZHJhd2luZ3stLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpFek1UY3lNaUlnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSk5NVGt1TURJNElERTNMalEyWVRJdU1qVWdNaTR5TlNBd0lEQWdNQzAwTGpBNU1pMHhMamcxYkMwNUxqVXhNUzB5TGpNM09HRXlMakkxSURJdU1qVWdNQ0F4SURBdExqSXlOUzQ1TnpSc09TNDBOelVnTWk0ek5qbGhNaTR5TlRFZ01pNHlOVEVnTUNBd0lEQWdOQzR6TlRNdU9EZzJiUzB4TGpZMk1pMHhMamsyTldFeExqSTFJREV1TWpVZ01DQXhJREV0TGpnNE5TQXlMak16T0NBeExqSTFJREV1TWpVZ01DQXdJREVnTGpnNE5TMHlMak16T0UwMExqTTBNeUF4TXk0Mk5qbGhNUzR5TlNBeExqSTFJREFnTVNBd0xUSXVNek00TFM0NE9EVWdNUzR5TlNBeExqSTFJREFnTUNBd0lESXVNek00TGpnNE5VMHpMamszSURndU56WTVZVEl1TWpVZ01pNHlOU0F3SURBZ01DQXhMalExTlMweUxqRXhiRGt1TlRFeExUSXVNemM0WVRJdU1qVWdNaTR5TlNBd0lERWdNQzB1TWpZdExqazJOVXcxTGpJZ05TNDJPRFZoTWk0eU5TQXlMakkxSURBZ01TQXdMVEV1TWpNZ015NHdPRFJ0TGpNM015MHlMalUwTjJFeExqSTFJREV1TWpVZ01DQXhJREV0TWk0ek16Z3VPRGcxSURFdU1qVWdNUzR5TlNBd0lEQWdNU0F5TGpNek9DMHVPRGcxYlRFekxqYzFMVE11TkRNNFlURXVNalVnTVM0eU5TQXdJREVnTVMweUxqTXpPQzQ0T0RVZ01TNHlOU0F4TGpJMUlEQWdNQ0F4SURJdU16TTRMUzQ0T0RVaUlHTnNhWEF0Y25Wc1pUMGlaWFpsYm05a1pDSXZQand2YzNablBnPT0pfS5hZy1jaGFydHMtaWNvbi1kcmFnLWhhbmRsZXstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNakFpSUdobGFXZG9kRDBpTWpBaUlIWnBaWGRDYjNnOUlqQWdNQ0F5TUNBeU1DSWdabWxzYkQwaWJtOXVaU0lnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JajQ4WTJseVkyeGxJR040UFNJMUxqYzFJaUJqZVQwaU55NDNOU0lnY2owaUxqYzFJaUJtYVd4c1BTSWpNREF3SWlCbWFXeHNMVzl3WVdOcGRIazlJaTQxSWk4K1BHTnBjbU5zWlNCamVEMGlPUzQzTlNJZ1kzazlJamN1TnpVaUlISTlJaTQzTlNJZ1ptbHNiRDBpSXpBd01DSWdabWxzYkMxdmNHRmphWFI1UFNJdU5TSXZQanhqYVhKamJHVWdZM2c5SWpFekxqYzFJaUJqZVQwaU55NDNOU0lnY2owaUxqYzFJaUJtYVd4c1BTSWpNREF3SWlCbWFXeHNMVzl3WVdOcGRIazlJaTQxSWk4K1BHTnBjbU5zWlNCamVEMGlNVE11TnpVaUlHTjVQU0l4TVM0M05TSWdjajBpTGpjMUlpQm1hV3hzUFNJak1EQXdJaUJtYVd4c0xXOXdZV05wZEhrOUlpNDFJaTgrUEdOcGNtTnNaU0JqZUQwaU9TNDNOU0lnWTNrOUlqRXhMamMxSWlCeVBTSXVOelVpSUdacGJHdzlJaU13TURBaUlHWnBiR3d0YjNCaFkybDBlVDBpTGpVaUx6NDhZMmx5WTJ4bElHTjRQU0kxTGpjMUlpQmplVDBpTVRFdU56VWlJSEk5SWk0M05TSWdabWxzYkQwaUl6QXdNQ0lnWm1sc2JDMXZjR0ZqYVhSNVBTSXVOU0l2UGp3dmMzWm5QZz09KX0uYWctY2hhcnRzLWljb24tZmlsbC1jb2xvcnstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpBd01DSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKdE9DNHdOekVnTkM0d05pMHVPVEkwTFM0NU1qUXVOekEzTFM0M01EY2dOeTR5T0RnZ055NHlPRGd0TkM0NU5TQTBMamsxWVRNdU5TQXpMalVnTUNBd0lERXROQzQ1TlNBd2JDMHhMalF4TkMweExqUXhOR0V6TGpVZ015NDFJREFnTUNBeElEQXROQzQ1TlhwdExqY3dOeTQzTURoTU5DNDFNellnT1M0d01XRXlMalVnTWk0MUlEQWdNQ0F3SURBZ015NDFNelpNTlM0NU5TQXhNeTQ1Tm1FeUxqVWdNaTQxSURBZ01DQXdJRE11TlRNMUlEQnNOQzR5TkRNdE5DNHlORE42YlRZdU9TQTNMakl3TWkwdU16UTFMak0yTXkwdU16UTBMUzR6TmpOaExqVXVOU0F3SURBZ01TQXVOamc0SURCdExTNHpORFVnTVM0d09HRTRJRGdnTUNBd0lEQXRMakk0TGpNeU15QTBMak1nTkM0eklEQWdNQ0F3TFM0ME1Ea3VOVGd5WXkwdU1URXpMakl3TVMwdU1UUTBMak15TmkwdU1UUTBMak0zT0dFdU9ETXpMamd6TXlBd0lEQWdNQ0F4TGpZMk55QXdZekF0TGpBMU1pMHVNRE14TFM0eE56Y3RMakUwTkMwdU16YzRZVFF1TXlBMExqTWdNQ0F3SURBdExqUXhMUzQxT0RJZ09DQTRJREFnTUNBd0xTNHlPQzB1TXpJeWJTMHVNelEwTFRFdU1EZ3VNelEwTGpNMk15NHpORFF0TGpNMk15NHdNREl1TURBeUxqQXdOQzR3TURRdU1ERXpMakF4TW1FMklEWWdNQ0F3SURFZ0xqSXdOaTR5TURoakxqRXpNUzR4TXpZdU16QTRMak15Tnk0ME9EVXVOVFExTGpFM05pNHlNVFV1TXpZekxqUTJOeTQxTURjdU56STBMakV6Tnk0eU5ETXVNamN6TGpVMU15NHlOek11T0RZNFlURXVPRE16SURFdU9ETXpJREFnTVNBeExUTXVOalkzSURCak1DMHVNekUxTGpFek5pMHVOakkxTGpJM015MHVPRFk0TGpFME5DMHVNalUzTGpNekxTNDFNRGt1TlRBM0xTNDNNalJoT1NBNUlEQWdNQ0F4SUM0Mk5EVXRMamN3T0d3dU1EUTJMUzR3TkRVdU1ERXpMUzR3TVRJdU1EQTBMUzR3TURSNklpQmpiR2x3TFhKMWJHVTlJbVYyWlc1dlpHUWlMejQ4TDNOMlp6ND0pfS5hZy1jaGFydHMtaWNvbi1ob2xsb3ctY2FuZGxlc3RpY2stc2VyaWVzey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekV6TVRjeU1pSWdabWxzYkMxdmNHRmphWFI1UFNJdU1UVWlJR1E5SWswMUlEVm9NM1l4TUVnMWVpSXZQanh3WVhSb0lHWnBiR3c5SWlNeE16RTNNaklpSUdacGJHd3RjblZzWlQwaVpYWmxibTlrWkNJZ1pEMGlUVGNnTVhZemFESjJNVEpJTjNZelNEWjJMVE5JTkZZMGFESldNWHBOTlNBMWFETjJNVEJJTlhwdE55QXlhRE4yTm1ndE0zcHRMVEVnTjFZMmFESldNeTR5TldneFZqWm9Nblk0YUMweWRqSXVOelZvTFRGV01UUjZJaUJqYkdsd0xYSjFiR1U5SW1WMlpXNXZaR1FpTHo0OEwzTjJaejQ9KX0uYWctY2hhcnRzLWljb24taG9yaXpvbnRhbC1saW5lLC5hZy1jaGFydHMtaWNvbi1ob3Jpem9udGFsLWxpbmUtZHJhd2luZ3stLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpFek1UY3lNaUlnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSk5MalVnT1M0MWFEY3VNekEyWVRJdU1qVWdNaTR5TlNBd0lEQWdNU0EwTGpNNE9DQXdTREU1TGpWMk1XZ3ROeTR6TURaaE1pNHlOU0F5TGpJMUlEQWdNQ0F4TFRRdU16ZzRJREJJTGpWNmJUa3VOU0F4TGpjMVlURXVNalVnTVM0eU5TQXdJREVnTUNBd0xUSXVOU0F4TGpJMUlERXVNalVnTUNBd0lEQWdNQ0F5TGpVaUlHTnNhWEF0Y25Wc1pUMGlaWFpsYm05a1pDSXZQand2YzNablBnPT0pfS5hZy1jaGFydHMtaWNvbi1saW5lLWNvbG9yey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekF3TUNJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmtQU0pOTVRRdU1qUXlJREl1TnpJeVl5MHVOakV5SURBdE1TNHlMakkwTXkweExqWXpNaTQyTnpWc0xURXVNelF6SURFdU16UTBZUzQxTGpVZ01DQXdJREF0TGpFeE1pNHhNVEpNTkM0d05TQXhNUzQ1TlRsakxTNHlNRGN1TWpBM0xTNHpOaTQwTmkwdU5EUTJMamMwZGk0d01ERnNMUzQyT1NBeUxqYzJOM1l1TURBeVlTNDRNaTQ0TWlBd0lEQWdNQ0F4TGpBeU1pQXhMakF5TVdndU1EQXliREl1TmpNMExTNDRNakpqTGpJNExTNHdPRFV1TlRNMExTNHlNemN1TnpRdExqUTBNMnczTGpFd055MDNMakV3T0dFdU5TNDFJREFnTUNBd0lDNHhNVEl0TGpFeE1td3hMak0wTXkweExqTTBNMkV5TGpNd09DQXlMak13T0NBd0lEQWdNQzB4TGpZek1pMHpMamswVFRFMExqRXlNaUEzYkRFdU1EUTBMVEV1TURRMVlURXVNekE0SURFdU16QTRJREFnTVNBd0xURXVPRFE1TFRFdU9EVk1NVEl1TWpjeElEVXVNVFY2YlMweUxqVTFPQzB4TGpFME1pMDJMamd3TnlBMkxqZ3dPV0V1T0M0NElEQWdNQ0F3TFM0eE9UWXVNekkxYkMwdU56VWdNaTQwTmpnZ01pNDBOeTB1TnpRNVlTNDRMamdnTUNBd0lEQWdMak15TlMwdU1UazBiRFl1T0RBNExUWXVPREY2SWlCamJHbHdMWEoxYkdVOUltVjJaVzV2WkdRaUx6NDhMM04yWno0PSl9LmFnLWNoYXJ0cy1pY29uLWxpbmUtc2VyaWVzey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekV6TVRjeU1pSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKdE1UY3VNell5SURRdU9EY3pMVFF1TlRrMElEWXVOalUwTFRRdU9EVXRNeTR6TVRjdE5DNHlOVEVnTmk0NU56Y3RMamcxTkMwdU5USk1OeTQyTVRJZ05pNDNPV3cwTGpnNU9TQXpMak0xSURRdU1ESTRMVFV1T0RNMmVpSWdZMnhwY0MxeWRXeGxQU0psZG1WdWIyUmtJaTgrUEM5emRtYyspfS5hZy1jaGFydHMtaWNvbi1saW5lLXN0eWxlLWRhc2hlZHstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNakFpSUdobGFXZG9kRDBpTWpBaUlIWnBaWGRDYjNnOUlqQWdNQ0F5TUNBeU1DSWdabWxzYkQwaWJtOXVaU0lnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JajQ4Y0dGMGFDQm1hV3hzUFNJak1EQXdJaUJrUFNKTk1pQTVhRFIyTVVneWVtMHhNaUF3YURSMk1XZ3ROSHBOT0NBNWFEUjJNVWc0ZWlJdlBqd3ZjM1puUGc9PSl9LmFnLWNoYXJ0cy1pY29uLWxpbmUtc3R5bGUtZG90dGVkey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1qQWlJR2hsYVdkb2REMGlNakFpSUhacFpYZENiM2c5SWpBZ01DQXlNQ0F5TUNJZ1ptbHNiRDBpYm05dVpTSWdlRzFzYm5NOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6SXdNREF2YzNabklqNDhZMmx5WTJ4bElHTjRQU0l5TGpVaUlHTjVQU0k1TGpVaUlISTlJaTQxSWlCbWFXeHNQU0lqTURBd0lpOCtQR05wY21Oc1pTQmplRDBpTkM0MUlpQmplVDBpT1M0MUlpQnlQU0l1TlNJZ1ptbHNiRDBpSXpBd01DSXZQanhqYVhKamJHVWdZM2c5SWpZdU5TSWdZM2s5SWprdU5TSWdjajBpTGpVaUlHWnBiR3c5SWlNd01EQWlMejQ4WTJseVkyeGxJR040UFNJNExqVWlJR041UFNJNUxqVWlJSEk5SWk0MUlpQm1hV3hzUFNJak1EQXdJaTgrUEdOcGNtTnNaU0JqZUQwaU1UQXVOU0lnWTNrOUlqa3VOU0lnY2owaUxqVWlJR1pwYkd3OUlpTXdNREFpTHo0OFkybHlZMnhsSUdONFBTSXhNaTQxSWlCamVUMGlPUzQxSWlCeVBTSXVOU0lnWm1sc2JEMGlJekF3TUNJdlBqeGphWEpqYkdVZ1kzZzlJakUwTGpVaUlHTjVQU0k1TGpVaUlISTlJaTQxSWlCbWFXeHNQU0lqTURBd0lpOCtQR05wY21Oc1pTQmplRDBpTVRZdU5TSWdZM2s5SWprdU5TSWdjajBpTGpVaUlHWnBiR3c5SWlNd01EQWlMejQ4TDNOMlp6ND0pfS5hZy1jaGFydHMtaWNvbi1saW5lLXN0eWxlLXNvbGlkey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1qQWlJR2hsYVdkb2REMGlNakFpSUhacFpYZENiM2c5SWpBZ01DQXlNQ0F5TUNJZ1ptbHNiRDBpYm05dVpTSWdlRzFzYm5NOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6SXdNREF2YzNabklqNDhjR0YwYUNCbWFXeHNQU0lqTURBd0lpQmtQU0pOTWlBNWFERTJkakZJTW5vaUx6NDhMM04yWno0PSl9LmFnLWNoYXJ0cy1pY29uLWxpbmUtd2l0aC1tYXJrZXJzLXNlcmllc3stLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpFek1UY3lNaUlnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSnRNVGd1TVRrNElEUXVPRGc0TFRNdU5UVTJJRFF1T1RFNFlUSXVNalVnTWk0eU5TQXdJREVnTVMwekxqZzJOaTQzTld3dE1TNDBNekl0TGpsaE1pNHlOQ0F5TGpJMElEQWdNQ0F4TFRJdU1EQTVMalF6Tld3dE15NDRNamdnTmk0ME1qZ3RMamcyTFM0MU1USk1OaTQwTlNBNUxqWXlNMkV5TGpJMUlESXVNalVnTUNBeElERWdNeTQxTVMwdU56WXhiREV1TXpJNUxqZ3pOV0V5TGpJMElESXVNalFnTUNBd0lERWdNaTQxTlRjdExqUTVOMnd6TGpVME1pMDBMamc1T0hwdExUUXVPVFlnTlM0eE5UTmhNUzR5TlNBeExqSTFJREFnTVNBd0xTNDJOQ0F5TGpReE9TQXhMakkxSURFdU1qVWdNQ0F3SURBZ0xqWTBMVEl1TkRFNVRUa3VNU0E0TGpNeU1YRXVNRFkyTFM0eE9USXVNRFkzTFM0ME1EUmhNUzR5TlNBeExqSTFJREFnTVNBd0xTNHdOamN1TkRBMElpQmpiR2x3TFhKMWJHVTlJbVYyWlc1dlpHUWlMejQ4TDNOMlp6ND0pfS5hZy1jaGFydHMtaWNvbi1sb2NrLC5hZy1jaGFydHMtaWNvbi1sb2NrZWR7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6QXdNQ0lnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSk5NVEF1TWpBM0lETXVOelkwWVRJdU9EazBJREl1T0RrMElEQWdNQ0F3TFRJdU9EazFJREl1T0RrMFZqbG9OUzQzT0RsV05pNDJOVGhoTWk0NE9UUWdNaTQ0T1RRZ01DQXdJREF0TWk0NE9UVXRNaTQ0T1RSTk1UUXVNU0E1VmpZdU5qVTRZVE11T0RrMElETXVPRGswSURBZ01TQXdMVGN1TnpnNUlEQjJNaTR6TkRsQk1pNDFJREl1TlNBd0lEQWdNQ0EwSURFeExqVjJNMEV5TGpVZ01pNDFJREFnTUNBd0lEWXVOU0F4TjJnNFlUSXVOU0F5TGpVZ01DQXdJREFnTWk0MUxUSXVOWFl0TTBFeUxqVWdNaTQxSURBZ01DQXdJREUwTGpVZ09YcE5OaTQxSURFd1FURXVOU0F4TGpVZ01DQXdJREFnTlNBeE1TNDFkak5CTVM0MUlERXVOU0F3SURBZ01DQTJMalVnTVRab09HRXhMalVnTVM0MUlEQWdNQ0F3SURFdU5TMHhMalYyTFROaE1TNDFJREV1TlNBd0lEQWdNQzB4TGpVdE1TNDFlaUlnWTJ4cGNDMXlkV3hsUFNKbGRtVnViMlJrSWk4K1BDOXpkbWMrKX0uYWctY2hhcnRzLWljb24tbWVhc3VyZXItZHJhd2luZ3stLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNakFpSUdobGFXZG9kRDBpTWpBaUlIWnBaWGRDYjNnOUlqQWdNQ0F5TUNBeU1DSWdabWxzYkQwaWJtOXVaU0lnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JajQ4Y0dGMGFDQm1hV3hzTFhKMWJHVTlJbVYyWlc1dlpHUWlJR05zYVhBdGNuVnNaVDBpWlhabGJtOWtaQ0lnWkQwaWJUUXVORFl4SURFeUxqY3hJREV1TlRNeUxURXVOVE14SURFdU5ERTBJREV1TkRFMExqY3dOeTB1TnpBM1REWXVOeUF4TUM0ME56SnNNUzQxTXpJdE1TNDFNek1nTWlBeUlDNDNNRGN0TGpjd055MHlMVElnTmk0d01TMDJMakF4SURJdU9ETWdNaTQ0TWpoTU5TNHdOU0F4Tnk0M056Z2dNaTR5TWpJZ01UUXVPVFZzTVM0MU16SXRNUzQxTXpJZ01TNDBNVFFnTVM0ME1UUXVOekEzTFM0M01EZDZUUzQ0TURnZ01UUXVPVFZzTGpjd055MHVOekEzVERFMExqSTBNeUF4TGpVeE5Xd3VOekEzTFM0M01EY3VOekEzTGpjd055QXlMamd5T0NBeUxqZ3lPQzQzTURjdU56QTNMUzQzTURjdU56QTNURFV1TnpVM0lERTRMalE0Tld3dExqY3dOeTQzTURjdExqY3dOeTB1TnpBM0xUSXVPREk0TFRJdU9ESTRlbTB4TVM0d056Z3ROaTQ0TXpWTU1UQXVORGNnTmk0M2JDNDNNRGN0TGpjd055QXhMalF4TlNBeExqUXhOSHB0TGpneU5DMHpMalkxTkNBeElERWdMamN3T0MwdU56QTNMVEV0TVhvaUlHWnBiR3c5SWlNeE9ERkVNVVlpTHo0OEwzTjJaejQ9KX0uYWctY2hhcnRzLWljb24tbm90ZS1hbm5vdGF0aW9uey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekF3TUNJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmtQU0pOTXlBMExqVkJNUzQxSURFdU5TQXdJREFnTVNBMExqVWdNMmd4TVVFeExqVWdNUzQxSURBZ01DQXhJREUzSURRdU5YWTRZVEV1TlNBeExqVWdNQ0F3SURFdE1TNDFJREV1TldndE15NHlNV3d0TVM0ME5qa2dNaTQxTjJFeElERWdNQ0F3SURFdE1TNDJPREl1TURnMVREY3VNalF6SURFMFNEUXVOVUV4TGpVZ01TNDFJREFnTUNBeElETWdNVEl1TlhwTk5DNDFJRFJoTGpVdU5TQXdJREFnTUMwdU5TNDFkamhoTGpVdU5TQXdJREFnTUNBdU5TNDFhRE11TWpVM2JESXVNVGsySURNdU1EYzBUREV4TGpjeElERXphRE11TnpsaExqVXVOU0F3SURBZ01DQXVOUzB1TlhZdE9HRXVOUzQxSURBZ01DQXdMUzQxTFM0MWVpSWdZMnhwY0MxeWRXeGxQU0psZG1WdWIyUmtJaTgrUEhCaGRHZ2dabWxzYkQwaUl6QXdNQ0lnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSk5OaTQxSURZdU5VRXVOUzQxSURBZ01DQXhJRGNnTm1nMllTNDFMalVnTUNBd0lERWdNQ0F4U0RkaExqVXVOU0F3SURBZ01TMHVOUzB1TlUwMkxqVWdPUzQxUVM0MUxqVWdNQ0F3SURFZ055QTVhRFpoTGpVdU5TQXdJREFnTVNBd0lERklOMkV1TlM0MUlEQWdNQ0F4TFM0MUxTNDFJaUJqYkdsd0xYSjFiR1U5SW1WMlpXNXZaR1FpTHo0OEwzTjJaejQ9KX0uYWctY2hhcnRzLWljb24tb2hsYy1zZXJpZXN7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6RXpNVGN5TWlJZ1pEMGlUVEV6SURFeGFDMHpkaTB4YUROV00yZ3hkakpvTkhZeGFDMDBkakV4YUMweGVrMDJJREUzZGkweWFETjJMVEZJTmxZMFNEVjJNVWd5ZGpGb00zWXhNWG9pTHo0OEwzTjJaejQ9KX0uYWctY2hhcnRzLWljb24tcGFuLWVuZHstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpBd01DSWdaRDBpYlRZdU5qUTJJREV6TGpneE15MHVNelV6TGpNMU5DNDNNRGN1TnpBM0xqTTFOQzB1TXpVMGVrMHhNUzR4TmpZZ01UQnNMak0xTkM0ek5UUXVNelUwTFM0ek5UUXRMak0xTkMwdU16VTBlazAzTGpNMU5TQTFMalE0SURjZ05TNHhNalpzTFM0M01EY3VOekEzTGpNMU15NHpOVFI2YlRBZ09TNHdOQ0EwTGpFMk5pMDBMakUyTmkwdU56QTNMUzQzTURndE5DNHhOamNnTkM0eE5qZDZiVFF1TVRZMkxUUXVPRGMwVERjdU16VTBJRFV1TkRoc0xTNDNNRGd1TnpBM0lEUXVNVFkzSURRdU1UWTNlazB4TXk0d09ETWdOWFl4TUdneFZqVjZJaTgrUEM5emRtYyspfS5hZy1jaGFydHMtaWNvbi1wYW4tbGVmdHstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpBd01DSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKTk1USXVOemtnTlM0NE16TWdPQzQyTWpVZ01UQnNOQzR4TmpZZ05DNHhOamN0TGpjd055NDNNRGRNTnk0eU1TQXhNR3cwTGpnM015MDBMamczTkhvaUlHTnNhWEF0Y25Wc1pUMGlaWFpsYm05a1pDSXZQand2YzNablBnPT0pfS5hZy1jaGFydHMtaWNvbi1wYW4tcmlnaHR7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6QXdNQ0lnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSk5OeTR5TVNBeE5DNHhOamNnTVRFdU16YzJJREV3SURjdU1qRWdOUzQ0TXpOc0xqY3dOeTB1TnpBM1RERXlMamM1SURFd2JDMDBMamczTXlBMExqZzNOSG9pSUdOc2FYQXRjblZzWlQwaVpYWmxibTlrWkNJdlBqd3ZjM1puUGc9PSl9LmFnLWNoYXJ0cy1pY29uLXBhbi1zdGFydHstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpBd01DSWdaRDBpVFRZZ05YWXhNR2d4VmpWNlRUa3VOakkwSURFd2JEUXVNVFkyTFRRdU1UWTNMUzQzTURjdExqY3dOMHc0TGpJeElERXdiRFF1T0RjMElEUXVPRGMwTGpjd055MHVOekEzZWlJdlBqd3ZjM1puUGc9PSl9LmFnLWNoYXJ0cy1pY29uLXBhcmFsbGVsLWNoYW5uZWwsLmFnLWNoYXJ0cy1pY29uLXBhcmFsbGVsLWNoYW5uZWwtZHJhd2luZ3stLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpFek1UY3lNaUlnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSk5NVGN1TnpJZ05TNHpNekZCTWk0eU5TQXlMakkxSURBZ01TQXdJREUwTGpjd05TQXpMalpzTFRrdU5Ea2dOQzQxTmpKaE1pNHlOU0F5TGpJMUlEQWdNU0F3SUM0eU1Ea2dNUzR3TVd3NUxqWTJNaTAwTGpZME5tRXlMakkxSURJdU1qVWdNQ0F3SURBZ01pNDJNelF1T0RBMWJTNHpOek10TWk0MU5EZGhNUzR5TlNBeExqSTFJREFnTVNBeExUSXVNek00TGpnNE5TQXhMakkxSURFdU1qVWdNQ0F3SURFZ01pNHpNemd0TGpnNE5VMDBMak0wTXlBNExqWTNZVEV1TWpVZ01TNHlOU0F3SURFZ01TMHlMak16T0M0NE9EVWdNUzR5TlNBeExqSTFJREFnTUNBeElESXVNek00TFM0NE9EVk5OUzR6TURjZ01UWXVOekk0WVRJdU1qVWdNaTR5TlNBd0lERWdNUzB1TlRJMUxTNDROVGhzT1M0NU1qTXROQzQzTjJFeUxqSTFJREl1TWpVZ01DQXhJREVnTGpNNE1TNDVNalo2YlMwdU9UWTBMakkzTkdFeExqSTFJREV1TWpVZ01DQXhJREV0TWk0ek16Z3VPRGcxSURFdU1qVWdNUzR5TlNBd0lEQWdNU0F5TGpNek9DMHVPRGcxYlRFekxqQXlNeTAxTGpFd05tRXhMakkxSURFdU1qVWdNQ0F4SURBdExqZzROUzB5TGpNek9TQXhMakkxSURFdU1qVWdNQ0F3SURBZ0xqZzROU0F5TGpNek9TSWdZMnhwY0MxeWRXeGxQU0psZG1WdWIyUmtJaTgrUEM5emRtYyspfS5hZy1jaGFydHMtaWNvbi1wb3NpdGlvbi1ib3R0b217LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTWpBaUlHaGxhV2RvZEQwaU1qQWlJSFpwWlhkQ2IzZzlJakFnTUNBeU1DQXlNQ0lnWm1sc2JEMGlibTl1WlNJZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWo0OGNHRjBhQ0JtYVd4c1BTSWpNREF3SWlCbWFXeHNMVzl3WVdOcGRIazlJaTR5TlNJZ1pEMGlUVE1nTVRCb01UUjJNVWd6ZW0wekxUTm9PSFl4U0RaNklpOCtQSEJoZEdnZ1ptbHNiRDBpSXpBd01DSWdaRDBpVFRZZ01UTm9PSFl4U0RaNklpOCtQQzl6ZG1jKyl9LmFnLWNoYXJ0cy1pY29uLXBvc2l0aW9uLWNlbnRlcnstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNakFpSUdobGFXZG9kRDBpTWpBaUlIWnBaWGRDYjNnOUlqQWdNQ0F5TUNBeU1DSWdabWxzYkQwaWJtOXVaU0lnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JajQ4Y0dGMGFDQm1hV3hzUFNJak1EQXdJaUJrUFNKTk15QXhNR2d4TkhZeFNETjZJaTgrUEhCaGRHZ2dabWxzYkQwaUl6QXdNQ0lnWm1sc2JDMXZjR0ZqYVhSNVBTSXVNalVpSUdROUlrMDJJRGRvT0hZeFNEWjZiVEFnTm1nNGRqRklObm9pTHo0OEwzTjJaejQ9KX0uYWctY2hhcnRzLWljb24tcG9zaXRpb24tdG9wey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1qQWlJR2hsYVdkb2REMGlNakFpSUhacFpYZENiM2c5SWpBZ01DQXlNQ0F5TUNJZ1ptbHNiRDBpYm05dVpTSWdlRzFzYm5NOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6SXdNREF2YzNabklqNDhjR0YwYUNCbWFXeHNQU0lqTURBd0lpQm1hV3hzTFc5d1lXTnBkSGs5SWk0eU5TSWdaRDBpVFRNZ01UQm9NVFIyTVVnemVpSXZQanh3WVhSb0lHWnBiR3c5SWlNd01EQWlJR1E5SWswMklEZG9PSFl4U0RaNklpOCtQSEJoZEdnZ1ptbHNiRDBpSXpBd01DSWdabWxzYkMxdmNHRmphWFI1UFNJdU1qVWlJR1E5SWswMklERXphRGgyTVVnMmVpSXZQand2YzNablBnPT0pfS5hZy1jaGFydHMtaWNvbi1wcmljZS1sYWJlbC1hbm5vdGF0aW9uey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekF3TUNJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmtQU0pOTkM0MUlETkJNUzQxSURFdU5TQXdJREFnTUNBeklEUXVOVll4TTJFeExqVWdNUzQxSURBZ01DQXdJREV1TlNBeExqVm9Mamd6TTNZdU1EVTNZeTR5TkRJdExqSTVPUzQxT1RjdExqVXdNeUF4TFM0MU5EaFdNVE11TlVnMExqVkJMalV1TlNBd0lEQWdNU0EwSURFelZqUXVOV0V1TlM0MUlEQWdNQ0F4SUM0MUxTNDFhREV4WVM0MUxqVWdNQ0F3SURFZ0xqVXVOWFk0WVM0MUxqVWdNQ0F3SURFdExqVXVOV2d0TkM0NE1UaHNMUzR4TWpZdU1EZzBZVEkySURJMklEQWdNQ0F3TFRJdU1qSTFJREV1TmpnMWJDMHVNekl1TWpZMUxTNHdOamd1TURVMllURXVOU0F4TGpVZ01DQXdJREV0TWk0Mk1Ea2dNUzR6TlRSakxqQXpNeTQzTmpNdU9UQTFJREV1TWpNNElERXVOVFl1TnpVMkxqWTBOaTB1TkRjMElERXVNakV0TGprME15QXhMamMyTVMweExqUnNMak14TXkwdU1qWkJNallnTWpZZ01DQXdJREVnTVRBdU9UZzJJREUwU0RFMUxqVmhNUzQxSURFdU5TQXdJREFnTUNBeExqVXRNUzQxZGkwNFFURXVOU0F4TGpVZ01DQXdJREFnTVRVdU5TQXplaUlnWTJ4cGNDMXlkV3hsUFNKbGRtVnViMlJrSWk4K1BIQmhkR2dnWm1sc2JEMGlJekV6TVRjeU1pSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKTk9DNDNNVFlnTVRRdU9ERTFZVEl1TWpVZ01pNHlOU0F3SURFZ01TMDBMakl4SURFdU5Ua3pJREl1TWpVZ01pNHlOU0F3SURBZ01TQTBMakl4TFRFdU5Ua3piUzB4TGpZMk1pQXhMamsyTm1FeExqSTFJREV1TWpVZ01DQXhJREF0TGpnNE5TMHlMak16T1NBeExqSTFJREV1TWpVZ01DQXdJREFnTGpnNE5TQXlMak16T1NJZ1kyeHBjQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpOCtQQzl6ZG1jKyl9LmFnLWNoYXJ0cy1pY29uLXByaWNlLXJhbmdlLWRyYXdpbmd7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTWpBaUlHaGxhV2RvZEQwaU1qQWlJSFpwWlhkQ2IzZzlJakFnTUNBeU1DQXlNQ0lnWm1sc2JEMGlibTl1WlNJZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWo0OGNHRjBhQ0JrUFNKTk9TNHdORFlnTVRWV05TNDROemRvTGprME1sWXhOWG9pSUdacGJHdzlJaU14T0RGRU1VWWlMejQ4Y0dGMGFDQmtQU0pOT1M0d05EWWdNVFZXTlM0NE56ZG9MamswTWxZeE5Yb2lJR1pwYkd3OUlpTXhPREZFTVVZaUx6NDhjR0YwYUNCa1BTSk5PUzQxSURZdU1qSTRJRGN1TVRZM0lEZ3VNemMySURZdU5TQTNMamMyTWlBNUxqVWdOV3d6SURJdU56WXlMUzQyTmpjdU5qRTBlaUlnWm1sc2JEMGlJekF3TUNJdlBqeHdZWFJvSUdROUlrMHlJREU0ZGkweGFERTJkakY2VFRJZ00xWXlhREUyZGpGNklpQm1hV3hzUFNJak1UZ3hSREZHSWk4K1BDOXpkbWMrKX0uYWctY2hhcnRzLWljb24tcmVzZXR7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6QXdNQ0lnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSk5NVEl1TURRZ05DNDBORFZoTlM0NE1TQTFMamd4SURBZ01DQXdMVGN1TWpVM0lESXVORFV6TGpVdU5TQXdJREFnTVMwdU9EWTFMUzQxTURKQk5pNDRNU0EyTGpneElEQWdNU0F4SURNZ09TNDRNVE5oTGpVdU5TQXdJREFnTVNBeElEQWdOUzQ0TVNBMUxqZ3hJREFnTVNBd0lEZ3VNRFF0TlM0ek5qZ2lJR05zYVhBdGNuVnNaVDBpWlhabGJtOWtaQ0l2UGp4d1lYUm9JR1pwYkd3OUlpTXdNREFpSUdacGJHd3RjblZzWlQwaVpYWmxibTlrWkNJZ1pEMGlUVFF1TWpnNUlETXVNREF5WVM0MUxqVWdNQ0F3SURFZ0xqVXVOWFl5TGpZMU5XZ3lMalkxTldFdU5TNDFJREFnTUNBeElEQWdNVWcwTGpJNVlTNDFMalVnTUNBd0lERXRMalV0TGpWV015NDFNREpoTGpVdU5TQXdJREFnTVNBdU5TMHVOU0lnWTJ4cGNDMXlkV3hsUFNKbGRtVnViMlJrSWk4K1BDOXpkbWMrKX0uYWctY2hhcnRzLWljb24tc2V0dGluZ3N7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCMmFXVjNRbTk0UFNJd0lEQWdNakFnTWpBaUlIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJZ2VHMXNPbk53WVdObFBTSndjbVZ6WlhKMlpTSWdjM1I1YkdVOUltWnBiR3d0Y25Wc1pUcGxkbVZ1YjJSa0lqNDhjR0YwYUNCa1BTSk5NVEFnTVROaE15QXpJREFnTVNBd0lEQXROaUF6SURNZ01DQXdJREFnTUNBMmJUQXRNV0V5SURJZ01DQXhJREV0TGpBd01TMHpMams1T1VFeUlESWdNQ0F3SURFZ01UQWdNVElpTHo0OGNHRjBhQ0JrUFNKTk1pNHpNU0F4TkM0ek5EVmpMUzQ0TVRjdE1TNDBPVEV1TURJM0xUSXVORGs1TGpRM05DMHlMamcyTlM0MU16RXRMalF6TkM0NU5qa3RMak0yTlM0NU56SXRNUzQwT0MwdU1EQXpMVEV1TVRFMUxTNDBOREV0TVM0d05EWXRMamszTWkweExqUTRNUzB1TkRVMExTNHpOekV0TVM0ek1UY3RNUzQwTURVdExqUXpOQzB5TGprek5td3VNREExTFM0d01EbGpMamc0TkMweExqVXlJREl1TWpBM0xURXVNamtnTWk0M05UVXRNUzR3T0RNdU5qUXhMakkwTXk0NE1ERXVOalUySURFdU56WTRMakV3TVM0NU5qUXRMalUyTGpZNE5pMHVPVEEwTGpjNU5pMHhMalU0TWk0d09UUXRMalUzT0M0MU5Ua3RNUzQ0TkRNZ01pNHpNall0TVM0NE5ETm9MakF4WXpFdU56VTVMakF3TlNBeUxqSXlNaUF4TGpJMk5pQXlMak14TmlBeExqZzBNeTR4TVM0Mk56Z3RMakUyT0NBeExqQXlNaTQzT1RZZ01TNDFPREl1T1RZM0xqVTFOU0F4TGpFeU55NHhORElnTVM0M05qZ3RMakV3TVM0MU5Ea3RMakl3T0NBeExqZzNOaTB1TkRNNElESXVOellnTVM0d09USnpMakF5SURJdU5UWTFMUzQwTXpRZ01pNDVNelpqTFM0MU16RXVORE0xTFM0NU5qa3VNelkyTFM0NU56SWdNUzQwT0RFdU1EQXpJREV1TVRFMUxqUTBNU0F4TGpBME5pNDVOeklnTVM0ME9DNDBOVFF1TXpjeUlERXVNekUzSURFdU5EQTJMalF6TkNBeUxqa3pOMnd0TGpBd05TNHdNRGxqTFM0NE9EUWdNUzQxTWkweUxqSXdOeUF4TGpJNUxUSXVOelUxSURFdU1EZ3pMUzQyTkRFdExqSTBNeTB1T0RBeExTNDJOVFl0TVM0M05qZ3RMakV3TVMwdU9UWTBMalUyTFM0Mk9EWXVPVEEwTFM0M09UWWdNUzQxT0RFdExqQTVOQzQxTnprdExqVTFPU0F4TGpnME5DMHlMak15TmlBeExqZzBOR2d0TGpBeFl5MHhMamMxT1MwdU1EQTFMVEl1TWpJeUxURXVNalkyTFRJdU16RTJMVEV1T0RRMExTNHhNUzB1TmpjM0xqRTJPQzB4TGpBeU1TMHVOemsyTFRFdU5UZ3hMUzQ1TmpjdExqVTFOUzB4TGpFeU55MHVNVFF5TFRFdU56WTRMakV3TVMwdU5UUTVMakl3T0MweExqZzNOaTQwTXpndE1pNDNOaTB4TGpBNU1td3RMakF5TFM0d016WjZUVGt1T1RnMElESXVNVFl5U0RFd1l6RXVNelUxSURBZ01TNHpORElnTVM0d016a2dNUzR6TlRNZ01TNDBNalV1TURBNExqTXhNaTR3TkNBeExqRTJJREV1TWpVNUlERXVPRGN5YkM0d01UVXVNREE0WXpFdU1qSTFMamNnTVM0NU56WXVNekEwSURJdU1qVXhMakUxTlM0ek16Y3RMakU0TXlBeExqSXlOaTB1TnpFeElERXVPVEF5TGpRME5Xd3VNREE0TGpBeE5HTXVOamM0SURFdU1UY3pMUzR5TWprZ01TNDJPREl0TGpVMU9DQXhMamc0TkMwdU1qWTJMakUyTXkwdU9UZzBMall4TlMwdU9Ua3hJREl1TURJM2RpNHdNVFpqTGpBd055QXhMalF4TWk0M01qVWdNUzQ0TmpRdU9Ua3hJREl1TURJM0xqTXlPQzR5TURFZ01TNHlNamt1TnpBM0xqVTJOaUF4TGpnM2JDMHVNREE0TGpBeE5HTXRMalkzTnlBeExqRTNOQzB4TGpVM01TNDJORE10TVM0NU1TNDBOVGt0TGpJM05TMHVNVFE1TFRFdU1ESTJMUzQxTkRVdE1pNHlOVEV1TVRVMGJDMHVNREUxTGpBd09XTXRNUzR5TVRrdU56RXlMVEV1TWpVeElERXVOVFl0TVM0eU5Ua2dNUzQ0TnpJdExqQXhNUzR6T0RZdU1EQXlJREV1TkRJMUxURXVNelV6SURFdU5ESTFjeTB4TGpNME1pMHhMakF6T1MweExqTTFNeTB4TGpReU5XTXRMakF3T0MwdU16RXlMUzR3TkMweExqRTJMVEV1TWpVNUxURXVPRGN5YkMwdU1ERTFMUzR3TURsakxURXVNakkxTFM0Mk9Ua3RNUzQ1TnpZdExqTXdNeTB5TGpJMU1TMHVNVFUwTFM0ek16WXVNVGd6TFRFdU1qRTVMamN3TmkweExqZzVOQzB1TkRNeWJDMHVNREUyTFM0d01qZGpMUzQyTnpndE1TNHhOelF1TWpJNUxURXVOamd5TGpVMU9DMHhMamc0TkM0eU5qWXRMakUyTXk0NU9EUXRMall4TlM0NU9URXRNaTR3TWpkMkxTNHdNVFpqTFM0d01EY3RNUzQwTVRJdExqY3lOUzB4TGpnMk5DMHVPVGt4TFRJdU1ESTNMUzR6TWpndExqSXdNUzB4TGpJeU9TMHVOekEzTFM0MU5qWXRNUzQ0TjJ3dU1EQTRMUzR3TVRSakxqWTNOeTB4TGpFM05DQXhMalUzTVMwdU5qUXpJREV1T1RFdExqUTFPUzR5TnpVdU1UUTVJREV1TURJMkxqVTBOU0F5TGpJMU1TMHVNVFUxYkM0d01UVXRMakF3T0dNeExqSXhPUzB1TnpFeUlERXVNalV4TFRFdU5UWWdNUzR5TlRrdE1TNDROekl1TURFdExqTTROQzB1TURBeUxURXVOREUzSURFdU16TTNMVEV1TkRJMUlpOCtQQzl6ZG1jKyl9LmFnLWNoYXJ0cy1pY29uLXN0ZXAtbGluZS1zZXJpZXN7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6RTRNVVF4UmlJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmtQU0pOTmlBMGFEVjJPR2d6Vmpob05YWXhhQzAwZGpSb0xUVldOVWczZGpFd1NESjJMVEZvTkhvaUlHTnNhWEF0Y25Wc1pUMGlaWFpsYm05a1pDSXZQand2YzNablBnPT0pfS5hZy1jaGFydHMtaWNvbi10ZXh0LWFubm90YXRpb257LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTWpBaUlHaGxhV2RvZEQwaU1qQWlJSFpwWlhkQ2IzZzlJakFnTUNBeU1DQXlNQ0lnWm1sc2JEMGlibTl1WlNJZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWo0S1BIQmhkR2dnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCamJHbHdMWEoxYkdVOUltVjJaVzV2WkdRaUlHUTlJazAwSURSSU1UWldOMGd4TlZZMVNERXdMalZXTVRWSU1UUldNVFpJTmxZeE5VZzVMalZXTlVnMVZqZElORlkwV2lJZ1ptbHNiRDBpWW14aFkyc2lMejRLUEM5emRtYytDZz09KX0uYWctY2hhcnRzLWljb24tdHJlbmQtbGluZSwuYWctY2hhcnRzLWljb24tdHJlbmQtbGluZS1kcmF3aW5ney0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekV6TVRjeU1pSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKTk5TNHpNVFFnTVRBdU9UTTRZVEl1TWpVZ01pNHlOU0F3SURFZ01TQXVNREV0TVdnNUxqTTFNbUV5TGpJMUlESXVNalVnTUNBeElERWdMakF4SURGNmJTMHlMakU0T1M0M01qbGhNUzR5TlNBeExqSTFJREFnTVNBd0lEQXRNaTQxSURFdU1qVWdNUzR5TlNBd0lEQWdNQ0F3SURJdU5XMHhNeTQzTlNBd1lURXVNalVnTVM0eU5TQXdJREVnTUNBd0xUSXVOU0F4TGpJMUlERXVNalVnTUNBd0lEQWdNQ0F5TGpVaUlHTnNhWEF0Y25Wc1pUMGlaWFpsYm05a1pDSXZQand2YzNablBnPT0pfS5hZy1jaGFydHMtaWNvbi11bmxvY2ssLmFnLWNoYXJ0cy1pY29uLXVubG9ja2Vkey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekF3TUNJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmtQU0pOTVRBdU5qVXhJRE11TldFeUxqZzVOQ0F5TGpnNU5DQXdJREFnTUMweUxqZzVOQ0F5TGpnNU5GWTVTREUwTGpWaE1pNDFJREl1TlNBd0lEQWdNU0F5TGpVZ01pNDFkak5oTWk0MUlESXVOU0F3SURBZ01TMHlMalVnTWk0MWFDMDRRVEl1TlNBeUxqVWdNQ0F3SURFZ05DQXhOQzQxZGkwelFUSXVOU0F5TGpVZ01DQXdJREVnTmk0MUlEbG9MakkxTjFZMkxqTTVOR0V6TGpnNU5DQXpMamc1TkNBd0lERWdNU0EzTGpjNE9TQXdJQzQxTGpVZ01DQXdJREV0TVNBd1FUSXVPRGswSURJdU9EazBJREFnTUNBd0lERXdMalkxSURNdU5VMDJMalVnTVRCQk1TNDFJREV1TlNBd0lEQWdNQ0ExSURFeExqVjJNMEV4TGpVZ01TNDFJREFnTUNBd0lEWXVOU0F4Tm1nNFlURXVOU0F4TGpVZ01DQXdJREFnTVM0MUxURXVOWFl0TTJFeExqVWdNUzQxSURBZ01DQXdMVEV1TlMweExqVjZJaUJqYkdsd0xYSjFiR1U5SW1WMlpXNXZaR1FpTHo0OEwzTjJaejQ9KX0uYWctY2hhcnRzLWljb24tdmVydGljYWwtbGluZSwuYWctY2hhcnRzLWljb24tdmVydGljYWwtbGluZS1kcmF3aW5ney0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekV6TVRjeU1pSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKTk1UQXVOU0EzTGpnd05tRXlMakkxSURJdU1qVWdNQ0F3SURFZ01DQTBMak00T0ZZeE9TNDFhQzB4ZGkwM0xqTXdObUV5TGpJMUlESXVNalVnTUNBd0lERWdNQzAwTGpNNE9GWXVOV2d4ZW0wdExqVXVPVFEwWVRFdU1qVWdNUzR5TlNBd0lERWdNU0F3SURJdU5TQXhMakkxSURFdU1qVWdNQ0F3SURFZ01DMHlMalVpSUdOc2FYQXRjblZzWlQwaVpYWmxibTlrWkNJdlBqd3ZjM1puUGc9PSl9LmFnLWNoYXJ0cy1pY29uLXpvb20taW57LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6QXdNQ0lnWkQwaVRURXdJRFV1TldFdU5TNDFJREFnTUNBeElDNDFMalYyTXk0MWFETXVPRGMxWVM0MUxqVWdNQ0F3SURFZ01DQXhTREV3TGpWMk5DNHlOV0V1TlM0MUlEQWdNU0F4TFRFZ01GWXhNQzQxU0RVdU5qSTFZUzQxTGpVZ01DQXhJREVnTUMweFNEa3VOVlkyWVM0MUxqVWdNQ0F3SURFZ0xqVXRMalVpTHo0OEwzTjJaejQ9KX0uYWctY2hhcnRzLWljb24tem9vbS1vdXR7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6QXdNQ0lnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSk5OUzQxSURFd1lTNDFMalVnTUNBd0lERWdMalV0TGpWb09HRXVOUzQxSURBZ01DQXhJREFnTVVnMllTNDFMalVnTUNBd0lERXRMalV0TGpVaUlHTnNhWEF0Y25Wc1pUMGlaWFpsYm05a1pDSXZQand2YzNablBnPT0pfS5hZy1jaGFydHMtaWNvbi1oaWdoLWxvdy1zZXJpZXN7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6RXpNVGN5TWlJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmtQU0pOTnlBMGFESjJNVEpJTkZZMGFETk5OU0ExYUROMk1UQklOWHBOTVRFZ01UUldObWcxZGpob0xUVnRNUzAzYUROMk5tZ3RNM29pSUdOc2FYQXRjblZzWlQwaVpYWmxibTlrWkNJdlBqd3ZjM1puUGc9PSl9LmFnLWNoYXJ0cy1pY29uLWhsYy1zZXJpZXN7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6RXpNVGN5TWlJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmtQU0p0TVRndU1UWXpJREV1T0RNM0xUVXVNek0wSURFeExqWXlNVXcyTGprMU55QTRMakV5YkMwMExqRTVPU0E1TGpZeU1pMHVPVEUyTFM0MElEUXVOelUyTFRFd0xqbE1NVEl1TkRrZ01URXVPQ0F4Tnk0eU5UUWdNUzQwTW5vaUlHTnNhWEF0Y25Wc1pUMGlaWFpsYm05a1pDSXZQanh3WVhSb0lHWnBiR3c5SWlNd01EQWlJR1pwYkd3dGIzQmhZMmwwZVQwaUxqUWlJR1pwYkd3dGNuVnNaVDBpWlhabGJtOWtaQ0lnWkQwaVRUVXVPREkxSURJdU56QTBMalUxSURFekxqYzROV3d1T1RBeUxqUXpJRFF1TnpJMExUa3VPVEU1SURZdU1ETTBJRFV1TURJNUlETXVNalUxTFRndU1UUXRMamt5T0MwdU16Y3RNaTQzTkRVZ05pNDRObnB0Tnk0NE5USWdNVFF1TmpNMklEVXVOemd0TVRNdU1UTTVMUzQ1TVRVdExqUXdNaTAxTGpJeE9TQXhNUzQ0TmkwMkxqQXdOUzAxTGpVd05DMHpMakkzT0NBM0xqWTBPQzQ1TWk0ek9UUWdNaTQzTWpJdE5pNHpOVEo2SWlCamJHbHdMWEoxYkdVOUltVjJaVzV2WkdRaUx6NDhMM04yWno0PSl9LmFnLWNoYXJ0cy1pY29uLXpvb20taW4tbGVnYWN5ey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1UWWlJR2hsYVdkb2REMGlNVFlpSUdacGJHdzlJbTV2Ym1VaUlIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJK1BIQmhkR2dnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCamJHbHdMWEoxYkdVOUltVjJaVzV2WkdRaUlHUTlJazA0TGpjMUlEUXVOV0V1TnpVdU56VWdNQ0F3SURBdE1TNDFJREIyTWk0M05VZzBMalZoTGpjMUxqYzFJREFnTUNBd0lEQWdNUzQxYURJdU56VjJNaTQzTldFdU56VXVOelVnTUNBd0lEQWdNUzQxSURCV09DNDNOV2d5TGpjMVlTNDNOUzQzTlNBd0lEQWdNQ0F3TFRFdU5VZzRMamMxVmpRdU5Wb2lJR1pwYkd3OUlpTXdNREFpTHo0OEwzTjJaejQ9KX0uYWctY2hhcnRzLWljb24tem9vbS1vdXQtbGVnYWN5ey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1UWWlJR2hsYVdkb2REMGlNVFlpSUdacGJHdzlJbTV2Ym1VaUlIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJK1BIQmhkR2dnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCamJHbHdMWEoxYkdVOUltVjJaVzV2WkdRaUlHUTlJazB6TGpjMUlEaGhMamMxTGpjMUlEQWdNQ0F4SUM0M05TMHVOelZvTjJFdU56VXVOelVnTUNBd0lERWdNQ0F4TGpWb0xUZEJMamMxTGpjMUlEQWdNQ0F4SURNdU56VWdPRm9pSUdacGJHdzlJaU13TURBaUx6NDhMM04yWno0PSl9LmFnLWNoYXJ0cy1pY29uLXpvb20taW4tYWx0LC5hZy1jaGFydHMtaWNvbi16b29tLWluLWFsdC1sZWdhY3l7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TkNJZ2FHVnBaMmgwUFNJeU5DSWdkbWxsZDBKdmVEMGlNQ0F3SURJMElESTBJaUJtYVd4c1BTSnViMjVsSWlCemRISnZhMlU5SW1OMWNuSmxiblJEYjJ4dmNpSWdjM1J5YjJ0bExYZHBaSFJvUFNJeUlpQnpkSEp2YTJVdGJHbHVaV05oY0QwaWNtOTFibVFpSUhOMGNtOXJaUzFzYVc1bGFtOXBiajBpY205MWJtUWlJR05zWVhOelBTSnNkV05wWkdVZ2JIVmphV1JsTFhwdmIyMHRhVzRpUGp4amFYSmpiR1VnWTNnOUlqRXhJaUJqZVQwaU1URWlJSEk5SWpnaUx6NDhiR2x1WlNCNE1UMGlNakVpSUhneVBTSXhOaTQyTlNJZ2VURTlJakl4SWlCNU1qMGlNVFl1TmpVaUx6NDhiR2x1WlNCNE1UMGlNVEVpSUhneVBTSXhNU0lnZVRFOUlqZ2lJSGt5UFNJeE5DSXZQanhzYVc1bElIZ3hQU0k0SWlCNE1qMGlNVFFpSUhreFBTSXhNU0lnZVRJOUlqRXhJaTgrUEM5emRtYyspfS5hZy1jaGFydHMtaWNvbi16b29tLW91dC1hbHQsLmFnLWNoYXJ0cy1pY29uLXpvb20tb3V0LWFsdC1sZWdhY3l7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TkNJZ2FHVnBaMmgwUFNJeU5DSWdkbWxsZDBKdmVEMGlNQ0F3SURJMElESTBJaUJtYVd4c1BTSnViMjVsSWlCemRISnZhMlU5SW1OMWNuSmxiblJEYjJ4dmNpSWdjM1J5YjJ0bExYZHBaSFJvUFNJeUlpQnpkSEp2YTJVdGJHbHVaV05oY0QwaWNtOTFibVFpSUhOMGNtOXJaUzFzYVc1bGFtOXBiajBpY205MWJtUWlJR05zWVhOelBTSnNkV05wWkdVZ2JIVmphV1JsTFhwdmIyMHRiM1YwSWo0OFkybHlZMnhsSUdONFBTSXhNU0lnWTNrOUlqRXhJaUJ5UFNJNElpOCtQR3hwYm1VZ2VERTlJakl4SWlCNE1qMGlNVFl1TmpVaUlIa3hQU0l5TVNJZ2VUSTlJakUyTGpZMUlpOCtQR3hwYm1VZ2VERTlJamdpSUhneVBTSXhOQ0lnZVRFOUlqRXhJaUI1TWowaU1URWlMejQ4TDNOMlp6ND0pfS5hZy1jaGFydHMtaWNvbi1yZXNldC1sZWdhY3l7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTVRZaUlHaGxhV2RvZEQwaU1UWWlJR1pwYkd3OUltNXZibVVpSUhodGJHNXpQU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh5TURBd0wzTjJaeUkrUEhCaGRHZ2dabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJqYkdsd0xYSjFiR1U5SW1WMlpXNXZaR1FpSUdROUlrMDBMalF4TWlBMExqQTFPQ0F5TGpjMUlESXVNemsyVmpZdU56Vm9MamMwTkdFdU56WXVOellnTUNBd0lEQWdMakF4TWlBd2FETXVOVGs0VERVdU5EYzRJRFV1TVRJMVlUUXVNVEkxSURRdU1USTFJREFnTUNBeElESXVOVEl6TFM0NE56VWdNeTQzTlNBekxqYzFJREFnTVNBeExUTXVNVEU1SURVdU9ETXpMamMxTGpjMUlEQWdNQ0F3TFRFdU1qUTNMamd6TkVFMUxqSTFJRFV1TWpVZ01DQXhJREFnT0NBeUxqYzFhQzB1TURBellUVXVOakkxSURVdU5qSTFJREFnTUNBd0xUTXVOVGcxSURFdU16QTRXaUlnWm1sc2JEMGlJekF3TUNJdlBqd3ZjM1puUGc9PSl9LmFnLWNoYXJ0cy1pY29uLXBhbi1sZWZ0LWxlZ2FjeXstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNVFlpSUdobGFXZG9kRDBpTVRZaUlHWnBiR3c5SW01dmJtVWlJSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SStQSEJoZEdnZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmpiR2x3TFhKMWJHVTlJbVYyWlc1dlpHUWlJR1E5SWsweE1DNHdNeUEwTGpRM1lTNDNOUzQzTlNBd0lEQWdNU0F3SURFdU1EWk1OeTQxTmlBNGJESXVORGNnTWk0ME4yRXVOelV1TnpVZ01DQXhJREV0TVM0d05pQXhMakEyYkMwekxUTmhMamMxTGpjMUlEQWdNQ0F4SURBdE1TNHdObXd6TFROaExqYzFMamMxSURBZ01DQXhJREV1TURZZ01Gb2lJR1pwYkd3OUlpTXdNREFpTHo0OEwzTjJaejQ9KX0uYWctY2hhcnRzLWljb24tcGFuLXJpZ2h0LWxlZ2FjeXstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNVFlpSUdobGFXZG9kRDBpTVRZaUlHWnBiR3c5SW01dmJtVWlJSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SStQSEJoZEdnZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmpiR2x3TFhKMWJHVTlJbVYyWlc1dlpHUWlJR1E5SWswMUxqazNJREV4TGpVellTNDNOUzQzTlNBd0lEQWdNU0F3TFRFdU1EWk1PQzQwTkNBNElEVXVPVGNnTlM0MU0yRXVOelV1TnpVZ01DQXdJREVnTVM0d05pMHhMakEyYkRNZ00yRXVOelV1TnpVZ01DQXdJREVnTUNBeExqQTJiQzB6SUROaExqYzFMamMxSURBZ01DQXhMVEV1TURZZ01Gb2lJR1pwYkd3OUlpTXdNREFpTHo0OEwzTjJaejQ9KX0uYWctY2hhcnRzLWljb24tcGFuLXN0YXJ0LWxlZ2FjeXstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlOQ0lnYUdWcFoyaDBQU0l5TkNJZ2RtbGxkMEp2ZUQwaU1DQXdJREkwSURJMElpQm1hV3hzUFNKdWIyNWxJaUJ6ZEhKdmEyVTlJbU4xY25KbGJuUkRiMnh2Y2lJZ2MzUnliMnRsTFhkcFpIUm9QU0l5SWlCemRISnZhMlV0YkdsdVpXTmhjRDBpY205MWJtUWlJSE4wY205clpTMXNhVzVsYW05cGJqMGljbTkxYm1RaUlHTnNZWE56UFNKc2RXTnBaR1VnYkhWamFXUmxMV05vWlhaeWIyNHRabWx5YzNRaVBqeHdZWFJvSUdROUltMHhOeUF4T0MwMkxUWWdOaTAySWk4K1BIQmhkR2dnWkQwaVRUY2dObll4TWlJdlBqd3ZjM1puUGc9PSl9LmFnLWNoYXJ0cy1pY29uLXBhbi1lbmQtbGVnYWN5ey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU5DSWdhR1ZwWjJoMFBTSXlOQ0lnZG1sbGQwSnZlRDBpTUNBd0lESTBJREkwSWlCbWFXeHNQU0p1YjI1bElpQnpkSEp2YTJVOUltTjFjbkpsYm5SRGIyeHZjaUlnYzNSeWIydGxMWGRwWkhSb1BTSXlJaUJ6ZEhKdmEyVXRiR2x1WldOaGNEMGljbTkxYm1RaUlITjBjbTlyWlMxc2FXNWxhbTlwYmowaWNtOTFibVFpSUdOc1lYTnpQU0pzZFdOcFpHVWdiSFZqYVdSbExXTm9aWFp5YjI0dGJHRnpkQ0krUEhCaGRHZ2daRDBpYlRjZ01UZ2dOaTAyTFRZdE5pSXZQanh3WVhSb0lHUTlJazB4TnlBMmRqRXlJaTgrUEM5emRtYyspfS5hZy1jaGFydHMtaWNvbi10cmVuZC1saW5lLWxlZ2FjeXstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNVFlpSUdobGFXZG9kRDBpTVRZaUlHWnBiR3c5SW01dmJtVWlJSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SStQR05wY21Oc1pTQmplRDBpTWk0MUlpQmplVDBpT0NJZ2NqMGlNUzQzTlNJZ2MzUnliMnRsUFNJak1EQXdJaUJ6ZEhKdmEyVXRkMmxrZEdnOUlqRXVOU0l2UGp4amFYSmpiR1VnWTNnOUlqRXpMalVpSUdONVBTSTRJaUJ5UFNJeExqYzFJaUJ6ZEhKdmEyVTlJaU13TURBaUlITjBjbTlyWlMxM2FXUjBhRDBpTVM0MUlpOCtQSEJoZEdnZ2MzUnliMnRsUFNJak1EQXdJaUJ6ZEhKdmEyVXRkMmxrZEdnOUlqRXVOU0lnWkQwaVRUUWdPR2c0SWk4K1BDOXpkbWMrKX0uYWctY2hhcnRzLWljb24taG9yaXpvbnRhbC1saW5lLWxlZ2FjeXstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNVFlpSUdobGFXZG9kRDBpTVRZaUlHWnBiR3c5SW01dmJtVWlJSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SStQSEJoZEdnZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmpiR2x3TFhKMWJHVTlJbVYyWlc1dlpHUWlJR1E5SWsweE1DNHpPRFlnT0M0M05XRXlMalV3TVNBeUxqVXdNU0F3SURBZ01TMDBMamMzTWlBd1NDNDNOV0V1TnpVdU56VWdNQ0F3SURFZ01DMHhMalZvTkM0NE5qUmhNaTQxTURFZ01pNDFNREVnTUNBd0lERWdOQzQzTnpJZ01HZzBMamcyTkdFdU56VXVOelVnTUNBd0lERWdNQ0F4TGpWb0xUUXVPRFkwV2swNUlEaGhNU0F4SURBZ01TQXhMVElnTUNBeElERWdNQ0F3SURFZ01pQXdXaUlnWm1sc2JEMGlJekF3TUNJdlBqd3ZjM1puUGc9PSl9LmFnLWNoYXJ0cy1pY29uLXZlcnRpY2FsLWxpbmUtbGVnYWN5ey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1UWWlJR2hsYVdkb2REMGlNVFlpSUdacGJHdzlJbTV2Ym1VaUlIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJK1BIQmhkR2dnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCamJHbHdMWEoxYkdVOUltVjJaVzV2WkdRaUlHUTlJazA0TGpjMUlEVXVOakUwWVRJdU5UQXhJREl1TlRBeElEQWdNQ0F4SURBZ05DNDNOekoyTkM0NE5qUmhMamMxTGpjMUlEQWdNQ0F4TFRFdU5TQXdkaTAwTGpnMk5HRXlMalV3TVNBeUxqVXdNU0F3SURBZ01TQXdMVFF1TnpjeVZpNDNOV0V1TnpVdU56VWdNQ0F3SURFZ01TNDFJREIyTkM0NE5qUmFUVGdnTjJFeElERWdNQ0F4SURFZ01DQXlJREVnTVNBd0lEQWdNU0F3TFRKYUlpQm1hV3hzUFNJak1EQXdJaTgrUEM5emRtYyspfS5hZy1jaGFydHMtaWNvbi1wYXJhbGxlbC1jaGFubmVsLWxlZ2FjeXstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNVGNpSUdobGFXZG9kRDBpTVRZaUlHWnBiR3c5SW01dmJtVWlJSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SStQSEJoZEdnZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmpiR2x3TFhKMWJHVTlJbVYyWlc1dlpHUWlJR1E5SWsweE5DNDBNalFnTkM0NU1tRXlMalVnTWk0MUlEQWdNU0F3TFRNdU16YzNMVEl1TVRSc0xUWXVOak1nTWk0NVlUSXVOVEF4SURJdU5UQXhJREFnTVNBd0lDNDJNRGNnTVM0ek56SnNOaTQxT0RVdE1pNDRPR0V5TGpVd01TQXlMalV3TVNBd0lEQWdNQ0F5TGpneE5TNDNORGhhYlM0d05TMHlMalk1TTJFeElERWdNQ0F4SURFdE1TNDROeTQzTURnZ01TQXhJREFnTUNBeElERXVPRGN0TGpjd09GcHRMVEV4SURRdU56VmhNU0F4SURBZ01TQXhMVEV1T0RjdU56QTRJREVnTVNBd0lEQWdNU0F4TGpnM0xTNDNNRGhhYlRFdU5UVWdOaTR3TnpWaE1pNDFNREVnTWk0MU1ERWdNQ0F4SURFdExqWXdOeTB4TGpNM01tdzJMall6TFRJdU9XRXlMalV3TVNBeUxqVXdNU0F3SURFZ01TQXVOVFl5SURFdU16a3hiQzAyTGpVNE5TQXlMamc0V20wdE1TNDFOUzB1TURjMVlURWdNU0F3SURFZ01TMHhMamczTGpjd09DQXhJREVnTUNBd0lERWdNUzQ0TnkwdU56QTRXbTB4TUM0ME1pMHpMalEyWVRFZ01TQXdJREVnTUMwdU56QTVMVEV1T0RjZ01TQXhJREFnTUNBd0lDNDNNRGdnTVM0NE4xb2lJR1pwYkd3OUlpTXdNREFpTHo0OEwzTjJaejQ9KX0uYWctY2hhcnRzLWljb24tZGlzam9pbnQtY2hhbm5lbC1sZWdhY3l7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTVRjaUlHaGxhV2RvZEQwaU1UWWlJR1pwYkd3OUltNXZibVVpSUhodGJHNXpQU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh5TURBd0wzTjJaeUkrUEhCaGRHZ2dabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJqYkdsd0xYSjFiR1U5SW1WMlpXNXZaR1FpSUdROUlrMHhOQzQwTWpRZ05DNDVNbUV5TGpVZ01pNDFJREFnTVNBd0xUTXVNemd6TFRJdU5EVXpURFF1TmprZ05DNHdOVFZoTWk0MUlESXVOU0F3SURFZ01DQXVNelEwSURFdU5EWnNOaTR6T1RJdE1TNDFPVGhoTWk0MU1ERWdNaTQxTURFZ01DQXdJREFnTXlBeExqQXdNMXB0TGpBMUxUSXVOamt6WVRFZ01TQXdJREVnTVMweExqZzNMamN3T0NBeElERWdNQ0F3SURFZ01TNDROeTB1TnpBNFdtMHRNVEVnTWk0M05XRXhJREVnTUNBeElERXRNUzQ0Tnk0M01EZ2dNU0F4SURBZ01DQXhJREV1T0RjdExqY3dPRnB0TVM0MU5pQTFMalF5WVRJdU5TQXlMalVnTUNBeElEQXRMak0wTlNBeExqUTJNV3cyTGpNMU1pQXhMalU0T0dFeUxqVWdNaTQxSURBZ01TQXdJQzR6T0RRdE1TNDBOV3d0Tmk0ek9USXRNUzQxT1RoYWJTMHhMalUyTGpVek9HRXhJREVnTUNBeElEQXRNUzQ0TnkwdU56QTRJREVnTVNBd0lEQWdNQ0F4TGpnM0xqY3dPRnB0TVRBdU5ESWdNUzQwTmpGaE1TQXhJREFnTVNBeExTNDNNRGtnTVM0NE55QXhJREVnTUNBd0lERWdMamN3T0MweExqZzNXaUlnWm1sc2JEMGlJekF3TUNJdlBqd3ZjM1puUGc9PSl9LmFnLWNoYXJ0cy1pY29uLWxpbmUtY29sb3ItbGVnYWN5ey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1UWWlJR2hsYVdkb2REMGlNVFlpSUdacGJHdzlJbTV2Ym1VaUlIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJK1BHY2dZMnhwY0Mxd1lYUm9QU0oxY213b0kyRXBJajQ4Y0dGMGFDQm1hV3hzTFhKMWJHVTlJbVYyWlc1dlpHUWlJR05zYVhBdGNuVnNaVDBpWlhabGJtOWtaQ0lnWkQwaVRURXlMamM0T0M0MU9ETmhNaTQyTXlBeUxqWXpJREFnTUNBd0xURXVPRFl1TnpkTU9TNDFORFFnTWk0M016aGhMamMxTnk0M05UY2dNQ0F3SURBdExqRTBMakUwVERJdU1ETXlJREV3TGpJMWRpNHdNREZqTFM0eU5ESXVNalF4TFM0ME1pNDFNemd0TGpVeUxqZzJOR3d0TGpBd01pNHdNREl0TGpnNElESXVPVEF5TFM0d01ERXVNREF6WVRFdU1EZ3pJREV1TURneklEQWdNQ0F3SURFdU16VWdNUzR6TkRkb0xqQXdNV3d5TGprd01pMHVPRGhvTGpBd01XTXVNekkyTFM0eExqWXlNeTB1TWpjM0xqZzJOUzB1TlRFNGRpMHVNREF4YkRjdU16YzFMVGN1TXpjMllTNDNOak11TnpZeklEQWdNQ0F3SUM0eE16a3RMakV6T1d3eExqTTROQzB4TGpNNE5FRXlMall6SURJdU5qTWdNQ0F3SURBZ01USXVOemc0TGpVNE0xcHRMUzR4TWpZZ05DNHpOVEl1T1RJMExTNDVNalJoTVM0eE15QXhMakV6SURBZ01DQXdMVEV1TlRrM0xURXVOVGszYkMwdU9USTBMamt5TkNBeExqVTVOeUF4TGpVNU4xcHRMVEl1TmpVM0xTNDFNell0Tmk0NU1UTWdOaTQ1TVRSSU15NHdPV0V1TlRnekxqVTRNeUF3SURBZ01DMHVNVFEyTGpJME1td3RMalkxTXlBeUxqRTFNeUF5TGpFMU5TMHVOalUwWVM0MU9ETXVOVGd6SURBZ01DQXdJQzR5TkRFdExqRTBOR3cyTGpreE5DMDJMamt4TkMweExqVTVOeTB4TGpVNU4xb2lJR1pwYkd3OUlpTXdNREFpTHo0OEwyYytQR1JsWm5NK1BHTnNhWEJRWVhSb0lHbGtQU0poSWo0OGNHRjBhQ0JtYVd4c1BTSWpabVptSWlCa1BTSk5NQ0F3YURFMmRqRTJTREI2SWk4K1BDOWpiR2x3VUdGMGFENDhMMlJsWm5NK1BDOXpkbWMrKX0uYWctY2hhcnRzLWljb24tZGVsZXRlLWxlZ2FjeXstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNVFlpSUdobGFXZG9kRDBpTVRZaUlHWnBiR3c5SW01dmJtVWlJSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SStQSEJoZEdnZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmpiR2x3TFhKMWJHVTlJbVYyWlc1dlpHUWlJR1E5SWswMkxqQTRNeUF5TGpZMk4yTXdMUzR3T1M0d05UTXRMakkwTWk0eE9UY3RMak00Tnk0eE5EVXRMakUwTkM0eU9UY3RMakU1Tnk0ek9EY3RMakU1TjJneUxqWTJOMk11TURnNUlEQWdMakkwTVM0d05UTXVNemcyTGpFNU55NHhORFV1TVRRMUxqRTVOeTR5T1RjdU1UazNMak00TjNZdU5UZ3pTRFl1TURnMGRpMHVOVGd6V2swMUxqTXpJRFF1TnpWSU1URXVPVEUzZGpndU5UZ3pZekFnTGpBNUxTNHdOVEl1TWpReUxTNHhPVGN1TXpnM0xTNHhORFV1TVRRMExTNHlPVGN1TVRrM0xTNHpPRFl1TVRrM1NEUXVOalkzWXkwdU1Ea2dNQzB1TWpReUxTNHdOVE10TGpNNE55MHVNVGszTFM0eE5EUXRMakUwTlMwdU1UazNMUzR5T1RjdExqRTVOeTB1TXpnM1ZqUXVOelZJTlM0ek0xcHRMUzQzTkRVdE1TNDFkaTB1TlRnell6QXRMalUzT0M0eU9DMHhMakE1TWk0Mk16WXRNUzQwTkRjdU16VTFMUzR6TlRZdU9EY3RMall6TnlBeExqUTBOeTB1TmpNM2FESXVOalkzWXk0MU56Y2dNQ0F4TGpBNU1TNHlPREVnTVM0ME5EY3VOak0zTGpNMU5TNHpOVFV1TmpNMkxqZzNMall6TmlBeExqUTBOM1l1TlRnelNERTBZUzQzTlM0M05TQXdJREFnTVNBd0lERXVOV2d0TGpVNE0zWTRMalU0TTJNd0lDNDFOemd0TGpJNE1TQXhMakE1TWkwdU5qTTJJREV1TkRRM0xTNHpOVFl1TXpVMkxTNDROeTQyTXpjdE1TNDBORGN1TmpNM1NEUXVOalkzWXkwdU5UYzNJREF0TVM0d09USXRMakk0TVMweExqUTBOeTB1TmpNM0xTNHpOVFV0TGpNMU5TMHVOak0zTFM0NE55MHVOak0zTFRFdU5EUTNWalF1TnpWSU1tRXVOelV1TnpVZ01DQXdJREVnTUMweExqVm9NaTQxT0ROYWJUSXVNRGd6SURNdU16TXpZUzQzTlM0M05TQXdJREFnTVNBdU56VXVOelYyTkdFdU56VXVOelVnTUNBeElERXRNUzQxSURCMkxUUmhMamMxTGpjMUlEQWdNQ0F4SUM0M05TMHVOelZhYlRNdU5ERTNMamMxWVM0M05TNDNOU0F3SURBZ01DMHhMalVnTUhZMFlTNDNOUzQzTlNBd0lERWdNQ0F4TGpVZ01IWXRORm9pSUdacGJHdzlJaU13TURBaUx6NDhMM04yWno0PSl9LmFnLWNoYXJ0cy1pY29uLWxvY2stbGVnYWN5ey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1UWWlJR2hsYVdkb2REMGlNVFlpSUdacGJHdzlJbTV2Ym1VaUlIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJK1BIQmhkR2dnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCamJHbHdMWEoxYkdVOUltVjJaVzV2WkdRaUlHUTlJazAyTGpFM015QXlMamcwWVRJdU5UZ3pJREl1TlRneklEQWdNQ0F4SURRdU5ERWdNUzQ0TWpkMk1TNDVNVFpJTlM0ME1UWldOQzQyTmpkak1DMHVOamcxTGpJM015MHhMak0wTXk0M05UY3RNUzQ0TWpkYVRUTXVPVEUzSURZdU5UZ3pWalF1TmpZM1lUUXVNRGd6SURRdU1EZ3pJREFnTUNBeElEZ3VNVFkySURCMk1TNDVNVFpvTGpVNE5HTXhMakUxSURBZ01pNHdPRE11T1RNeklESXVNRGd6SURJdU1EZzBkalF1TmpZMll6QWdNUzR4TlMwdU9UTXpJREl1TURnMExUSXVNRGd6SURJdU1EZzBTRE11TXpNellUSXVNRGd6SURJdU1EZ3pJREFnTUNBeExUSXVNRGd6TFRJdU1EZzBWamd1TmpZM1l6QXRNUzR4TlRFdU9UTXpMVEl1TURnMElESXVNRGd6TFRJdU1EZzBhQzQxT0ROYWJUY3VOREUySURFdU5XZ3RPR0V1TlRnekxqVTRNeUF3SURBZ01DMHVOVGd6TGpVNE5IWTBMalkyTm1Nd0lDNHpNakl1TWpZeExqVTROQzQxT0RNdU5UZzBhRGt1TXpNMFlTNDFPRE11TlRneklEQWdNQ0F3SUM0MU9ETXRMalU0TkZZNExqWTJOMkV1TlRnekxqVTRNeUF3SURBZ01DMHVOVGd6TFM0MU9EUm9MVEV1TXpNMFdpSWdabWxzYkQwaUl6QXdNQ0l2UGp3dmMzWm5QZz09KX0uYWctY2hhcnRzLWljb24tdW5sb2NrLWxlZ2FjeXstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNVGNpSUdobGFXZG9kRDBpTVRZaUlHWnBiR3c5SW01dmJtVWlJSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SStQSEJoZEdnZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmpiR2x3TFhKMWJHVTlJbVYyWlc1dlpHUWlJR1E5SWswMkxqa3lNeUF5TGpnMFlUSXVOVGd6SURJdU5UZ3pJREFnTUNBeElETXVOalV6SURBZ015QXpJREFnTUNBeElDNDFOeTQzT1RoakxqRXpOQzR5TnpndU1UY3VORGMwTGpFM0xqVTBOV0V1TnpVdU56VWdNQ0F3SURBZ01TNDFJREJqTUMwdU16Z3hMUzR4TXpJdExqZ3dPUzB1TXpJdE1TNHhPVGhoTkM0MU1ERWdOQzQxTURFZ01DQXdJREF0TGpnMU9TMHhMakl3TmlBMExqQTRNeUEwTGpBNE15QXdJREFnTUMwMkxqazNJREl1T0RnNGRqRXVPVEUyYUMwdU5UZzBRekl1T1RNeklEWXVOVGd6SURJZ055NDFNVFlnTWlBNExqWTJOM1kwTGpZMk5tTXdJREV1TVRVdU9UTXpJREl1TURnMElESXVNRGd6SURJdU1EZzBhRGt1TXpNMFl6RXVNVFVnTUNBeUxqQTRNeTB1T1RNeklESXVNRGd6TFRJdU1EZzBWamd1TmpZM1l6QXRNUzR4TlRFdExqa3pNeTB5TGpBNE5DMHlMakE0TXkweUxqQTROR2d0Tnk0eU5WWTBMalkyTjJNd0xTNDJPRFV1TWpjeUxURXVNelF6TGpjMU5pMHhMamd5TjFwTk5TNDBNVGNnT0M0d09ETklOQzR3T0RKaExqVTRNeTQxT0RNZ01DQXdJREF0TGpVNE15NDFPRFIyTkM0Mk5qWmpNQ0F1TXpJeUxqSTJNUzQxT0RRdU5UZ3pMalU0TkdnNUxqTXpOR0V1TlRnekxqVTRNeUF3SURBZ01DQXVOVGd6TFM0MU9EUldPQzQyTmpkaExqVTRNeTQxT0RNZ01DQXdJREF0TGpVNE15MHVOVGcwYUMwNFdpSWdabWxzYkQwaUl6QXdNQ0l2UGp3dmMzWm5QZz09KX0uYWctY2hhcnRzLWljb24tcGx1cy1sZWdhY3l7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TkNJZ2FHVnBaMmgwUFNJeU5DSWdkbWxsZDBKdmVEMGlNQ0F3SURJMElESTBJaUJtYVd4c1BTSnViMjVsSWlCemRISnZhMlU5SW1OMWNuSmxiblJEYjJ4dmNpSWdjM1J5YjJ0bExYZHBaSFJvUFNJeUlpQnpkSEp2YTJVdGJHbHVaV05oY0QwaWNtOTFibVFpSUhOMGNtOXJaUzFzYVc1bGFtOXBiajBpY205MWJtUWlJR05zWVhOelBTSnNkV05wWkdVZ2JIVmphV1JsTFhCc2RYTWlQanh3WVhSb0lHUTlJazAxSURFeWFERTBJaTgrUEhCaGRHZ2daRDBpVFRFeUlEVjJNVFFpTHo0OEwzTjJaejQ9KX0uYWctY2hhcnRzLWljb24tY3Jvc3NsaW5lLWFkZC1saW5lLWxlZ2FjeXstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXhOaUlnYUdWcFoyaDBQU0l4TmlJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpBd01DSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKTk9DNDNOU0EwTGpWaExqYzFMamMxSURBZ01DQXdMVEV1TlNBd2RqSXVOelZJTkM0MVlTNDNOUzQzTlNBd0lEQWdNQ0F3SURFdU5XZ3lMamMxZGpJdU56VmhMamMxTGpjMUlEQWdNQ0F3SURFdU5TQXdWamd1TnpWb01pNDNOV0V1TnpVdU56VWdNQ0F3SURBZ01DMHhMalZJT0M0M05Yb2lJR05zYVhBdGNuVnNaVDBpWlhabGJtOWtaQ0l2UGp3dmMzWm5QZz09KX0uYWctY2hhcnRzLWlucHV0ey0taW5wdXQtbGF5ZXItYWN0aXZlOiAxOy0taW5wdXQtbGF5ZXItZm9jdXM6IDI7Y29sb3I6aW5oZXJpdDtmb250LWZhbWlseTp2YXIoLS1hZy1jaGFydHMtaW5wdXQtZm9udC1mYW1pbHkpO2ZvbnQtc2l6ZTp2YXIoLS1hZy1jaGFydHMtaW5wdXQtZm9udC1zaXplKTt0cmFuc2l0aW9uLWR1cmF0aW9uOnZhcigtLWFnLWNoYXJ0cy1pbnB1dC10cmFuc2l0aW9uLWR1cmF0aW9uKTt0cmFuc2l0aW9uLXByb3BlcnR5Om5vbmU7dHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246dmFyKC0tYWctY2hhcnRzLWlucHV0LXRyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uKX0uYWctY2hhcnRzLWlucHV0OmZvY3VzLXZpc2libGV7b3V0bGluZTp2YXIoLS1hZy1jaGFydHMtaW5wdXQtZm9jdXMtb3V0bGluZSk7Ym94LXNoYWRvdzp2YXIoLS1hZy1jaGFydHMtaW5wdXQtZm9jdXMtYm94LXNoYWRvdyk7ei1pbmRleDp2YXIoLS1pbnB1dC1sYXllci1mb2N1cyl9LmFnLWNoYXJ0cy1idXR0b257YmFja2dyb3VuZDp2YXIoLS1hZy1jaGFydHMtaW5wdXQtYmFja2dyb3VuZC1jb2xvcik7Ym9yZGVyOjFweCBzb2xpZCB2YXIoLS1hZy1jaGFydHMtaW5wdXQtYm9yZGVyLWNvbG9yKTtib3JkZXItcmFkaXVzOnZhcigtLWFnLWNoYXJ0cy1pbnB1dC1ib3JkZXItcmFkaXVzKTtjdXJzb3I6cG9pbnRlcjtwYWRkaW5nOnZhcigtLWFnLWNoYXJ0cy1pbnB1dC1wYWRkaW5nKTt0cmFuc2l0aW9uLXByb3BlcnR5OmJhY2tncm91bmQsYm9yZGVyLWNvbG9yfS5hZy1jaGFydHMtYnV0dG9uOmhvdmVye2JhY2tncm91bmQ6dmFyKC0tYWctY2hhcnRzLWlucHV0LWJhY2tncm91bmQtY29sb3ItLWhvdmVyKX0uYWctY2hhcnRzLWJ1dHRvbjpoYXMoLmFnLWNoYXJ0cy1pY29uKXtwYWRkaW5nOjJweH0uYWctY2hhcnRzLWNoZWNrYm94e2FwcGVhcmFuY2U6bm9uZTtiYWNrZ3JvdW5kOnZhcigtLWFnLWNoYXJ0cy1pbnB1dC1jaGVja2JveC1iYWNrZ3JvdW5kLWNvbG9yKTtib3JkZXItcmFkaXVzOjlweDtjdXJzb3I6cG9pbnRlcjtoZWlnaHQ6MThweDttYXJnaW46MDt0cmFuc2l0aW9uLWR1cmF0aW9uOnZhcigtLWFnLWNoYXJ0cy1pbnB1dC10cmFuc2l0aW9uLWR1cmF0aW9uLS1mYXN0KTt0cmFuc2l0aW9uLXByb3BlcnR5Om1hcmdpbjt3aWR0aDoyOXB4fS5hZy1jaGFydHMtY2hlY2tib3g6YmVmb3Jle2Rpc3BsYXk6YmxvY2s7YmFja2dyb3VuZDp2YXIoLS1hZy1jaGFydHMtaW5wdXQtYmFja2dyb3VuZC1jb2xvcik7Ym9yZGVyLXJhZGl1czo3cHg7Y29udGVudDpcIiBcIjtoZWlnaHQ6MTRweDttYXJnaW46MnB4O3RyYW5zaXRpb24tZHVyYXRpb246dmFyKC0tYWctY2hhcnRzLWlucHV0LXRyYW5zaXRpb24tZHVyYXRpb24tLWZhc3QpO3RyYW5zaXRpb24tcHJvcGVydHk6bWFyZ2luO3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOnZhcigtLWFnLWNoYXJ0cy1pbnB1dC10cmFuc2l0aW9uLWVhc2luZyk7d2lkdGg6MTRweH0uYWctY2hhcnRzLWNoZWNrYm94OmNoZWNrZWR7YmFja2dyb3VuZDp2YXIoLS1hZy1jaGFydHMtaW5wdXQtY2hlY2tib3gtYmFja2dyb3VuZC1jb2xvci0tY2hlY2tlZCl9LmFnLWNoYXJ0cy1jaGVja2JveDpjaGVja2VkOmJlZm9yZXttYXJnaW4tbGVmdDoxM3B4fS5hZy1jaGFydHMtc2VsZWN0e2JhY2tncm91bmQ6dmFyKC0tYWctY2hhcnRzLWlucHV0LWJhY2tncm91bmQtY29sb3IpO2JvcmRlcjoxcHggc29saWQgdmFyKC0tYWctY2hhcnRzLWlucHV0LWJvcmRlci1jb2xvcik7Ym9yZGVyLXJhZGl1czp2YXIoLS1hZy1jaGFydHMtaW5wdXQtYm9yZGVyLXJhZGl1cyk7cGFkZGluZzozcHggMnB4IDRweDtmb250LXNpemU6aW5oZXJpdH0uYWctY2hhcnRzLXRleHRhcmVhey0tbGluZS1oZWlnaHQ6IDEuMzg7YmFja2dyb3VuZDp2YXIoLS1hZy1jaGFydHMtaW5wdXQtYmFja2dyb3VuZC1jb2xvcik7Ym9yZGVyOjFweCBzb2xpZCB2YXIoLS1hZy1jaGFydHMtaW5wdXQtYm9yZGVyLWNvbG9yKTtib3JkZXItcmFkaXVzOnZhcigtLWFnLWNoYXJ0cy1pbnB1dC1ib3JkZXItcmFkaXVzKTtsaW5lLWhlaWdodDp2YXIoLS1saW5lLWhlaWdodCk7Zm9udC1mYW1pbHk6dmFyKC0tYWctY2hhcnRzLWlucHV0LWZvbnQtZmFtaWx5KTtmb250LXNpemU6dmFyKC0tYWctY2hhcnRzLWlucHV0LWZvbnQtc2l6ZSk7cGFkZGluZzp2YXIoLS1hZy1jaGFydHMtaW5wdXQtcGFkZGluZy1sYXJnZSkgdmFyKC0tYWctY2hhcnRzLWlucHV0LXBhZGRpbmcpfS5hZy1jaGFydHMtdGV4dGFyZWFbcGxhY2Vob2xkZXJdOmVtcHR5OmJlZm9yZXtjb2xvcjp2YXIoLS1hZy1jaGFydHMtaW5wdXQtcGxhY2Vob2xkZXIpO2NvbnRlbnQ6YXR0cihwbGFjZWhvbGRlcil9LmFnLWNoYXJ0cy1wcm94eS1jb250YWluZXJ7cG9pbnRlci1ldmVudHM6bm9uZTtwb3NpdGlvbjphYnNvbHV0ZX0uYWctY2hhcnRzLXByb3h5LWVsZW17LXdlYmtpdC1hcHBlYXJhbmNlOm5vbmU7YXBwZWFyYW5jZTpub25lO2JhY2tncm91bmQ6bm9uZTtib3JkZXI6bm9uZTtjb2xvcjojMDAwMDtvdmVyZmxvdzpoaWRkZW47cG9pbnRlci1ldmVudHM6bm9uZTtwb3NpdGlvbjphYnNvbHV0ZX0uYWctY2hhcnRzLXByb3h5LWVsZW06Oi1tb3otcmFuZ2UtdGh1bWIsLmFnLWNoYXJ0cy1wcm94eS1lbGVtOjotbW96LXJhbmdlLXRyYWNre29wYWNpdHk6MH0uYWctY2hhcnRzLXByb3h5LWVsZW06Oi13ZWJraXQtc2xpZGVyLXJ1bm5hYmxlLXRyYWNrLC5hZy1jaGFydHMtcHJveHktZWxlbTo6LXdlYmtpdC1zbGlkZXItdGh1bWJ7b3BhY2l0eTowfS5hZy1jaGFydHMtcHJveHktZWxlbTpmb2N1cy12aXNpYmxle291dGxpbmU6dmFyKC0tYWctY2hhcnRzLWZvY3VzLWJvcmRlcik7Ym94LXNoYWRvdzp2YXIoLS1hZy1jaGFydHMtZm9jdXMtYm9yZGVyLXNoYWRvdyl9LmFnLWNoYXJ0cy1mb2N1cy1pbmRpY2F0b3J7cG9zaXRpb246YWJzb2x1dGU7ZGlzcGxheTpibG9jaztwb2ludGVyLWV2ZW50czpub25lO3VzZXItc2VsZWN0Om5vbmU7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJX0uYWctY2hhcnRzLWZvY3VzLWluZGljYXRvcj5kaXZ7cG9zaXRpb246YWJzb2x1dGU7b3V0bGluZTp2YXIoLS1hZy1jaGFydHMtZm9jdXMtYm9yZGVyKTtvdXRsaW5lLXdpZHRoOjJweDtib3gtc2hhZG93OnZhcigtLWFnLWNoYXJ0cy1mb2N1cy1ib3JkZXItc2hhZG93KX0uYWctY2hhcnRzLWZvY3VzLWluZGljYXRvcj5zdmd7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtmaWxsOm5vbmU7c3Ryb2tlOnZhcigtLWFnLWNoYXJ0cy1mb2N1cy1ib3JkZXItY29sb3IpO3N0cm9rZS13aWR0aDoycHh9LmFnLWNoYXJ0cy10b29sYmFye2FsaWduLWl0ZW1zOmNlbnRlcjtiYWNrZ3JvdW5kOm5vbmU7Ym9yZGVyOm5vbmU7ZGlzcGxheTpmbGV4O2ZsZXgtd3JhcDpub3dyYXA7b3BhY2l0eToxO3Bvc2l0aW9uOmFic29sdXRlO3RyYW5zZm9ybTp0cmFuc2xhdGVZKDApO3RyYW5zaXRpb246b3BhY2l0eSAuMnMgZWFzZS1pbi1vdXQsdHJhbnNmb3JtIC4ycyBlYXNlLWluLW91dH0uYWctY2hhcnRzLXRvb2xiYXItLWhpZGRlbiwuYWctY2hhcnRzLXRvb2xiYXItLXByZXZlbnQtZmxhc2h7dmlzaWJpbGl0eTpoaWRkZW59LmFnLWNoYXJ0cy10b29sYmFyLS1mbG9hdGluZy1oaWRkZW57b3BhY2l0eTowO3RyYW5zaXRpb246b3BhY2l0eSAuNHMgZWFzZS1pbi1vdXR9LmFnLWNoYXJ0cy10b29sYmFyLS1zbWFsbHstLWFnLWNoYXJ0cy10b29sYmFyLXNpemU6IHZhcigtLWFnLWNoYXJ0cy10b29sYmFyLXNpemUtc21hbGwpOy0tYWctY2hhcnRzLXRvb2xiYXItZm9udC1zaXplOiB2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1mb250LXNpemUtc21hbGwpOy0tYWctY2hhcnRzLXRvb2xiYXItYnV0dG9uLXBhZGRpbmc6IHZhcigtLWFnLWNoYXJ0cy10b29sYmFyLWJ1dHRvbi1wYWRkaW5nLXNtYWxsKX0uYWctY2hhcnRzLXRvb2xiYXItLXRvcCwuYWctY2hhcnRzLXRvb2xiYXItLWJvdHRvbXtmbGV4LWRpcmVjdGlvbjpyb3c7d2lkdGg6MTAwJX0uYWctY2hhcnRzLXRvb2xiYXItLWxlZnQsLmFnLWNoYXJ0cy10b29sYmFyLS1yaWdodHtmbGV4LWRpcmVjdGlvbjpjb2x1bW59LmFnLWNoYXJ0cy10b29sYmFyLS1mbG9hdGluZywuYWctY2hhcnRzLXRvb2xiYXItLWZsb2F0aW5nLXRvcCwuYWctY2hhcnRzLXRvb2xiYXItLWZsb2F0aW5nLWJvdHRvbXtiYWNrZ3JvdW5kOm5vbmU7Ym9yZGVyOm5vbmU7ZmxleC1kaXJlY3Rpb246cm93O3BvaW50ZXItZXZlbnRzOm5vbmU7d2lkdGg6MTAwJX0uYWctY2hhcnRzLXRvb2xiYXItLWZsb2F0aW5ne3BhZGRpbmc6MDt3aWR0aDphdXRvO3otaW5kZXg6dmFyKC0tYWctY2hhcnRzLWxheWVyLXRvb2xiYXIpfS5hZy1jaGFydHMtdG9vbGJhci0tZmxvYXRpbmctdG9we2hlaWdodDpjYWxjKHZhcigtLWFnLWNoYXJ0cy10b29sYmFyLXNpemUpICsgMTBweCk7cGFkZGluZy10b3A6MTBweH0uYWctY2hhcnRzLXRvb2xiYXItLWZsb2F0aW5nLWJvdHRvbXtoZWlnaHQ6Y2FsYyh2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1zaXplKSArIDEwcHgpO3BhZGRpbmctYm90dG9tOjEwcHg7b3ZlcmZsb3c6aGlkZGVufS5hZy1jaGFydHMtdG9vbGJhcl9fYWxpZ257ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmluaGVyaXQ7ZmxleC13cmFwOmluaGVyaXQ7Z2FwOnZhcigtLWFnLWNoYXJ0cy10b29sYmFyLWdhcCk7bWF4LXdpZHRoOjEwMCU7d2lkdGg6MTAwJX0uYWctY2hhcnRzLXRvb2xiYXJfX2FsaWduLS1zdGFydHtqdXN0aWZ5LWNvbnRlbnQ6c3RhcnR9LmFnLWNoYXJ0cy10b29sYmFyX19hbGlnbi0tY2VudGVye2p1c3RpZnktY29udGVudDpjZW50ZXJ9LmFnLWNoYXJ0cy10b29sYmFyX19hbGlnbi0tZW5ke2p1c3RpZnktY29udGVudDplbmR9LmFnLWNoYXJ0cy10b29sYmFyX19hbGlnbi0tY2VudGVyLC5hZy1jaGFydHMtdG9vbGJhcl9fYWxpZ24tLWVuZHttYXJnaW4tbGVmdDphdXRvfS5hZy1jaGFydHMtdG9vbGJhci0tbGVmdCAuYWctY2hhcnRzLXRvb2xiYXJfX2FsaWduLS1jZW50ZXIsLmFnLWNoYXJ0cy10b29sYmFyLS1sZWZ0IC5hZy1jaGFydHMtdG9vbGJhcl9fYWxpZ24tLWVuZCwuYWctY2hhcnRzLXRvb2xiYXItLXJpZ2h0IC5hZy1jaGFydHMtdG9vbGJhcl9fYWxpZ24tLWNlbnRlciwuYWctY2hhcnRzLXRvb2xiYXItLXJpZ2h0IC5hZy1jaGFydHMtdG9vbGJhcl9fYWxpZ24tLWVuZHttYXJnaW4tbGVmdDowO21hcmdpbi10b3A6YXV0b30uYWctY2hhcnRzLXRvb2xiYXItLWZsb2F0aW5nLXRvcCAuYWctY2hhcnRzLXRvb2xiYXJfX2FsaWduLC5hZy1jaGFydHMtdG9vbGJhci0tZmxvYXRpbmctYm90dG9tIC5hZy1jaGFydHMtdG9vbGJhcl9fYWxpZ257dHJhbnNpdGlvbjp0cmFuc2Zvcm0gLjRzIGVhc2UtaW4tb3V0O3dpZHRoOmF1dG99LmFnLWNoYXJ0cy10b29sYmFyX19zZWN0aW9ue2Rpc3BsYXk6aW5oZXJpdDtmbGV4LWRpcmVjdGlvbjppbmhlcml0O2ZsZXgtd3JhcDppbmhlcml0O2p1c3RpZnktY29udGVudDppbmhlcml0O21heC13aWR0aDppbmhlcml0O3dpZHRoOmluaGVyaXR9LmFnLWNoYXJ0cy10b29sYmFyX19idXR0b257YWxpZ24taXRlbXM6Y2VudGVyO2JhY2tncm91bmQ6dmFyKC0tYWctY2hhcnRzLXRvb2xiYXItYmFja2dyb3VuZC1jb2xvcik7Ym9yZGVyOnZhcigtLWFnLWNoYXJ0cy10b29sYmFyLWJvcmRlcik7Y29sb3I6dmFyKC0tYWctY2hhcnRzLXRvb2xiYXItZm9yZWdyb3VuZC1jb2xvcik7ZGlzcGxheTpmbGV4O2ZvbnQ6dmFyKC0tYWctY2hhcnRzLXRvb2xiYXItZm9udC1zaXplKSB2YXIoLS1hZy1jaGFydHMtZm9udC1mYW1pbHkpO2p1c3RpZnktY29udGVudDpjZW50ZXI7bWFyZ2luOjAgMCAwIC0xcHg7bWluLWhlaWdodDp2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1zaXplKTttaW4td2lkdGg6dmFyKC0tYWctY2hhcnRzLXRvb2xiYXItc2l6ZSk7cGFkZGluZzp2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1idXR0b24tcGFkZGluZyk7cG9pbnRlci1ldmVudHM6YWxsO3Bvc2l0aW9uOnJlbGF0aXZlO3doaXRlLXNwYWNlOm5vd3JhcDstLXN0cm9rZS13aWR0aC1jb2xvcjogdmFyKC0tYWctY2hhcnRzLXRvb2xiYXItZm9yZWdyb3VuZC1jb2xvcil9LmFnLWNoYXJ0cy10b29sYmFyX19uby1wb2ludGVyLWV2ZW50c3twb2ludGVyLWV2ZW50czpub25lfS5hZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uLS1kcmFnLWhhbmRsZXttaW4td2lkdGg6MjRweDtwYWRkaW5nLWxlZnQ6MDtwYWRkaW5nLXJpZ2h0OjB9LmFnLWNoYXJ0cy10b29sYmFyX19idXR0b24tLXdpdGgtdHJhbnNpdGlvbnt0cmFuc2l0aW9uOmJhY2tncm91bmQtY29sb3IgLjI1cyBlYXNlLWluLW91dCxib3JkZXItY29sb3IgLjI1cyBlYXNlLWluLW91dCxjb2xvciAuMjVzIGVhc2UtaW4tb3V0fS5hZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uW2RhdGEtdG9vbGJhci1ncm91cD1yYW5nZXNde3BhZGRpbmc6dmFyKC0tYWctY2hhcnRzLXRvb2xiYXItYnV0dG9uLXBhZGRpbmcpIGNhbGModmFyKC0tYWctY2hhcnRzLXRvb2xiYXItYnV0dG9uLXBhZGRpbmcpICogMS41KX0uYWctY2hhcnRzLXRvb2xiYXItLXRvcCwuYWctY2hhcnRzLXRvb2xiYXItLWJvdHRvbSwuYWctY2hhcnRzLXRvb2xiYXItLWZsb2F0aW5nLC5hZy1jaGFydHMtdG9vbGJhci0tZmxvYXRpbmctdG9wLC5hZy1jaGFydHMtdG9vbGJhci0tZmxvYXRpbmctYm90dG9tey5hZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uLS1maXJzdHtib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOnZhcigtLWFnLWNoYXJ0cy1idXR0b24tcmFkaXVzKTtib3JkZXItdG9wLWxlZnQtcmFkaXVzOnZhcigtLWFnLWNoYXJ0cy1idXR0b24tcmFkaXVzKTttYXJnaW46MH0uYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvbi0tbGFzdHtib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czp2YXIoLS1hZy1jaGFydHMtYnV0dG9uLXJhZGl1cyk7Ym9yZGVyLXRvcC1yaWdodC1yYWRpdXM6dmFyKC0tYWctY2hhcnRzLWJ1dHRvbi1yYWRpdXMpfX0uYWctY2hhcnRzLXRvb2xiYXItLWxlZnQsLmFnLWNoYXJ0cy10b29sYmFyLS1yaWdodHsuYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvbntib3JkZXItcmFkaXVzOjA7bWFyZ2luOi0xcHggMCAwO21heC13aWR0aDoxMDAlfS5hZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uLS1maXJzdHtib3JkZXItdG9wLWxlZnQtcmFkaXVzOnZhcigtLWFnLWNoYXJ0cy1idXR0b24tcmFkaXVzKTtib3JkZXItdG9wLXJpZ2h0LXJhZGl1czp2YXIoLS1hZy1jaGFydHMtYnV0dG9uLXJhZGl1cyk7bWFyZ2luOjB9LmFnLWNoYXJ0cy10b29sYmFyX19idXR0b24tLWxhc3R7Ym9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czp2YXIoLS1hZy1jaGFydHMtYnV0dG9uLXJhZGl1cyk7Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6dmFyKC0tYWctY2hhcnRzLWJ1dHRvbi1yYWRpdXMpfX0uYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvbi0taGlkZGVuLXZhbHVlLC5hZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uLS1oaWRkZW4tdG9nZ2xlZHtkaXNwbGF5Om5vbmV9LmFnLWNoYXJ0cy10b29sYmFyX19idXR0b246aG92ZXI6bm90KFthcmlhLWRpc2FibGVkPXRydWVdLC5hZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uLS1kcmFnLWhhbmRsZSl7YmFja2dyb3VuZDp2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1ob3Zlci1jb2xvcik7ei1pbmRleDoxfS5hZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uOmZvY3VzLXZpc2libGV7b3V0bGluZTp2YXIoLS1hZy1jaGFydHMtZm9jdXMtYm9yZGVyKTtib3gtc2hhZG93OnZhcigtLWFnLWNoYXJ0cy1mb2N1cy1ib3JkZXItc2hhZG93KTt6LWluZGV4OmNhbGModmFyKC0tYWctY2hhcnRzLWxheWVyLXVpLW92ZXJsYXkpICsgMSl9LmFnLWNoYXJ0cy10b29sYmFyX19idXR0b24uYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvbi0tYWN0aXZle2JhY2tncm91bmQ6dmFyKC0tYWctY2hhcnRzLXRvb2xiYXItYWN0aXZlLWJhY2tncm91bmQtY29sb3IpO2JvcmRlci1jb2xvcjp2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1hY3RpdmUtY29sb3IpO2NvbG9yOnZhcigtLWFnLWNoYXJ0cy10b29sYmFyLWFjdGl2ZS1jb2xvcik7ei1pbmRleDoyOy0tc3Ryb2tlLXdpZHRoLWNvbG9yOiB2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1hY3RpdmUtY29sb3IpfS5hZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uW2FyaWEtZGlzYWJsZWQ9dHJ1ZV17YmFja2dyb3VuZDp2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yKTtjb2xvcjp2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1kaXNhYmxlZC1mb3JlZ3JvdW5kLWNvbG9yKX0uYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvbjpub3QoW2FyaWEtZGlzYWJsZWQ9dHJ1ZV0pe2N1cnNvcjpwb2ludGVyfS5hZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uLmFnLWNoYXJ0cy10b29sYmFyX19idXR0b24tLWRyYWctaGFuZGxle2N1cnNvcjpncmFifS5hZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uLmFnLWNoYXJ0cy10b29sYmFyX19idXR0b24tLWRyYWdnaW5ne2N1cnNvcjpncmFiYmluZ30uYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvbi0tZmlsbC12aXNpYmxlOmFmdGVye2NvbnRlbnQ6XCJcIjtkaXNwbGF5OmJsb2NrO3Bvc2l0aW9uOmFic29sdXRlO2JvdHRvbTozcHg7bGVmdDo1cHg7cmlnaHQ6NXB4O2hlaWdodDo0cHg7Ym9yZGVyLXJhZGl1czo5OXB4O2JveC1zaGFkb3c6aW5zZXQgMCAwIDAgMXB4IGNvbG9yLW1peChpbiBzcmdiLHZhcigtLWFnLWNoYXJ0cy1mb3JlZ3JvdW5kLWNvbG9yKSAxMCUsdHJhbnNwYXJlbnQpO2JhY2tncm91bmQ6dmFyKC0tZmlsbCl9LmFnLWNoYXJ0cy10b29sYmFyX19idXR0b24tLWZpbGwtdmlzaWJsZVthcmlhLWRpc2FibGVkPXRydWVdOmFmdGVye2ZpbHRlcjpncmF5c2NhbGUoMSk7b3BhY2l0eTouNX0uYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvbi0tc3Ryb2tlLXdpZHRoLXZpc2libGU6YmVmb3Jle2NvbnRlbnQ6XCJcIjtoZWlnaHQ6bWluKHZhcigtLXN0cm9rZVdpZHRoKSwyMHB4KTt3aWR0aDoxMnB4O2JhY2tncm91bmQ6dmFyKC0tc3Ryb2tlLXdpZHRoLWNvbG9yKTttYXJnaW4tcmlnaHQ6dmFyKC0tYWctY2hhcnRzLXRvb2xiYXItYnV0dG9uLXBhZGRpbmcpfS5hZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uLS1zdHJva2Utd2lkdGgtdmlzaWJsZVthcmlhLWRpc2FibGVkPXRydWVdOmJlZm9yZXtmaWx0ZXI6Z3JheXNjYWxlKDEpO29wYWNpdHk6LjV9LmFnLWNoYXJ0cy10b29sYmFyX19pY29uKy5hZy1jaGFydHMtdG9vbGJhcl9fbGFiZWx7bWFyZ2luLWxlZnQ6dmFyKC0tYWctY2hhcnRzLXRvb2xiYXItZ2FwKX0uYWctY2hhcnRzLXRvb2xiYXJfX2ljb24sLmFnLWNoYXJ0cy10b29sYmFyX19sYWJlbHtwb2ludGVyLWV2ZW50czpub25lfS5hZy1jaGFydC1vdmVybGF5e2NvbG9yOiMxODFkMWY7cG9pbnRlci1ldmVudHM6bm9uZX0uYWctY2hhcnQtb3ZlcmxheS5hZy1jaGFydC1kYXJrLW92ZXJsYXl7Y29sb3I6I2ZmZn0uYWctY2hhcnQtb3ZlcmxheS0tbG9hZGluZ3tjb2xvcjojOGM4YzhjfS5hZy1jaGFydC1vdmVybGF5X19sb2FkaW5nLWJhY2tncm91bmR7YmFja2dyb3VuZDojZmZmO3BvaW50ZXItZXZlbnRzOm5vbmV9LmFnLWNoYXJ0LW92ZXJsYXkuYWctY2hhcnQtZGFyay1vdmVybGF5IC5hZy1jaGFydC1vdmVybGF5X19sb2FkaW5nLWJhY2tncm91bmR7YmFja2dyb3VuZDojMTkyMjMyfS5hZy1jaGFydC10b29sdGlwe3RyYW5zaXRpb246dHJhbnNmb3JtIC4xcyBlYXNlO3dpZHRoOm1heC1jb250ZW50O3otaW5kZXg6OTk5OTk7Zm9udDoxMnB4IFZlcmRhbmEsc2Fucy1zZXJpZjtjb2xvcjojNDY0NjQ2O2JveC1zaGFkb3c6MCA0cHggOHB4ICMwMDAwMDAxNH0uYWctY2hhcnQtdG9vbHRpcC13cmFwLWFsd2F5c3tvdmVyZmxvdy13cmFwOmJyZWFrLXdvcmQ7d29yZC1icmVhazpicmVhay13b3JkO2h5cGhlbnM6bm9uZX0uYWctY2hhcnQtdG9vbHRpcC13cmFwLWh5cGhlbmF0ZXtvdmVyZmxvdy13cmFwOmJyZWFrLXdvcmQ7d29yZC1icmVhazpicmVhay13b3JkO2h5cGhlbnM6YXV0b30uYWctY2hhcnQtdG9vbHRpcC13cmFwLW9uLXNwYWNle292ZXJmbG93LXdyYXA6bm9ybWFsO3dvcmQtYnJlYWs6bm9ybWFsfS5hZy1jaGFydC10b29sdGlwLXdyYXAtbmV2ZXJ7d2hpdGUtc3BhY2U6cHJlO3RleHQtb3ZlcmZsb3c6ZWxsaXBzaXN9LmFnLWNoYXJ0LXRvb2x0aXAtbm8taW50ZXJhY3Rpb257cG9pbnRlci1ldmVudHM6bm9uZTt1c2VyLXNlbGVjdDpub25lfS5hZy1jaGFydC10b29sdGlwLW5vLWFuaW1hdGlvbnt0cmFuc2l0aW9uOm5vbmUhaW1wb3J0YW50fS5hZy1jaGFydC10b29sdGlwLWhpZGRlbnt2aXNpYmlsaXR5OmhpZGRlbn0uYWctY2hhcnQtdG9vbHRpcC10aXRsZXtvdmVyZmxvdzpoaWRkZW47cG9zaXRpb246cmVsYXRpdmU7cGFkZGluZzo4cHggMTRweDtib3JkZXItdG9wLWxlZnQtcmFkaXVzOjJweDtib3JkZXItdG9wLXJpZ2h0LXJhZGl1czoycHg7Y29sb3I6I2ZmZjtiYWNrZ3JvdW5kLWNvbG9yOiM4ODg7ei1pbmRleDoxO3RleHQtb3ZlcmZsb3c6aW5oZXJpdH0uYWctY2hhcnQtdG9vbHRpcC10aXRsZTpvbmx5LWNoaWxke2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6MnB4O2JvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOjJweH0uYWctY2hhcnQtdG9vbHRpcC1jb250ZW50e292ZXJmbG93OmhpZGRlbjtwYWRkaW5nOjZweCAxNHB4O2xpbmUtaGVpZ2h0OjEuN2VtO2JhY2tncm91bmQ6I2ZmZjtib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOjJweDtib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czoycHg7Ym9yZGVyOjFweCBzb2xpZCByZ2JhKDAsMCwwLC4xNSk7dGV4dC1vdmVyZmxvdzppbmhlcml0fS5hZy1jaGFydC10b29sdGlwLWFycm93OmJlZm9yZXtjb250ZW50OlwiXCI7cG9zaXRpb246YWJzb2x1dGU7dG9wOjEwMCU7bGVmdDo1MCU7dHJhbnNmb3JtOnRyYW5zbGF0ZSgtNTAlKTtib3JkZXI6NXB4IHNvbGlkICNkOWQ5ZDk7Ym9yZGVyLWxlZnQtY29sb3I6dHJhbnNwYXJlbnQ7Ym9yZGVyLXJpZ2h0LWNvbG9yOnRyYW5zcGFyZW50O2JvcmRlci1ib3R0b20tY29sb3I6dHJhbnNwYXJlbnQ7d2lkdGg6MDtoZWlnaHQ6MDttYXJnaW46MCBhdXRvfS5hZy1jaGFydC10b29sdGlwLWFycm93OmFmdGVye2NvbnRlbnQ6XCJcIjtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6Y2FsYygxMDAlIC0gMXB4KTtsZWZ0OjUwJTt0cmFuc2Zvcm06dHJhbnNsYXRlKC01MCUpO2JvcmRlcjo1cHggc29saWQgd2hpdGU7Ym9yZGVyLWxlZnQtY29sb3I6dHJhbnNwYXJlbnQ7Ym9yZGVyLXJpZ2h0LWNvbG9yOnRyYW5zcGFyZW50O2JvcmRlci1ib3R0b20tY29sb3I6dHJhbnNwYXJlbnQ7d2lkdGg6MDtoZWlnaHQ6MDttYXJnaW46MCBhdXRvfVxcbic7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwva2V5bmF2VXRpbC50c1xuZnVuY3Rpb24gYWRkUmVtb3ZhYmxlRXZlbnRMaXN0ZW5lcihkZXN0cm95Rm5zLCBlbGVtLCB0eXBlLCBsaXN0ZW5lcikge1xuICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpO1xuICBjb25zdCByZW1vdmVyID0gKCkgPT4gZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKTtcbiAgZGVzdHJveUZucy5wdXNoKHJlbW92ZXIpO1xuICByZXR1cm4gcmVtb3Zlcjtcbn1cbmZ1bmN0aW9uIGFkZEVzY2FwZUV2ZW50TGlzdGVuZXIoZGVzdHJveUZucywgZWxlbSwgb25Fc2NhcGUpIHtcbiAgYWRkUmVtb3ZhYmxlRXZlbnRMaXN0ZW5lcihkZXN0cm95Rm5zLCBlbGVtLCBcImtleWRvd25cIiwgKGV2ZW50KSA9PiB7XG4gICAgaWYgKGV2ZW50LmtleSA9PT0gXCJFc2NhcGVcIikge1xuICAgICAgb25Fc2NhcGUoZXZlbnQpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBhZGRNb3VzZUNsb3NlTGlzdGVuZXIoZGVzdHJveUZucywgbWVudSwgaGlkZUNhbGxiYWNrKSB7XG4gIGNvbnN0IHNlbGYgPSBhZGRSZW1vdmFibGVFdmVudExpc3RlbmVyKGRlc3Ryb3lGbnMsIHdpbmRvdywgXCJtb3VzZWRvd25cIiwgKGV2ZW50KSA9PiB7XG4gICAgaWYgKFswLCAyXS5pbmNsdWRlcyhldmVudC5idXR0b24pICYmICFjb250YWluc1BvaW50KG1lbnUsIGV2ZW50KSkge1xuICAgICAgaGlkZUNhbGxiYWNrKCk7XG4gICAgICBzZWxmKCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHNlbGY7XG59XG5mdW5jdGlvbiBjb250YWluc1BvaW50KGNvbnRhaW5lciwgZXZlbnQpIHtcbiAgaWYgKGV2ZW50LnRhcmdldCBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICBjb25zdCB7IHgsIHksIHdpZHRoOiB3aWR0aDIsIGhlaWdodDogaGVpZ2h0MiB9ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IHsgY2xpZW50WDogZXgsIGNsaWVudFk6IGV5IH0gPSBldmVudDtcbiAgICByZXR1cm4gZXggPj0geCAmJiBleSA+PSB5ICYmIGV4IDw9IHggKyB3aWR0aDIgJiYgZXkgPD0geSArIGhlaWdodDI7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaGFzTm9Nb2RpZmllcnMoZXZlbnQpIHtcbiAgcmV0dXJuICEoZXZlbnQuc2hpZnRLZXkgfHwgZXZlbnQuYWx0S2V5IHx8IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSk7XG59XG5mdW5jdGlvbiBtYXRjaGVzS2V5KGV2ZW50LCBrZXksIC4uLm1vcmVrZXlzKSB7XG4gIHJldHVybiBoYXNOb01vZGlmaWVycyhldmVudCkgJiYgKGV2ZW50LmtleSA9PT0ga2V5IHx8IG1vcmVrZXlzLnNvbWUoKGFsdGtleSkgPT4gZXZlbnQua2V5ID09PSBhbHRrZXkpKTtcbn1cbmZ1bmN0aW9uIGxpbmtUd29CdXR0b25zKGRlc3Ryb3lGbnMsIHNyYywgZHN0LCBrZXkpIHtcbiAgaWYgKCFkc3QpXG4gICAgcmV0dXJuO1xuICBhZGRSZW1vdmFibGVFdmVudExpc3RlbmVyKGRlc3Ryb3lGbnMsIHNyYywgXCJrZXlkb3duXCIsIChldmVudCkgPT4ge1xuICAgIGlmIChtYXRjaGVzS2V5KGV2ZW50LCBrZXkpKSB7XG4gICAgICBkc3QuZm9jdXMoKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gbGlua1RocmVlQnV0dG9ucyhkZXN0cm95Rm5zLCBjdXJyLCBuZXh0LCBuZXh0S2V5LCBwcmV2LCBwcmV2S2V5KSB7XG4gIGxpbmtUd29CdXR0b25zKGRlc3Ryb3lGbnMsIGN1cnIsIHByZXYsIHByZXZLZXkpO1xuICBsaW5rVHdvQnV0dG9ucyhkZXN0cm95Rm5zLCBjdXJyLCBuZXh0LCBuZXh0S2V5KTtcbiAgYWRkUmVtb3ZhYmxlRXZlbnRMaXN0ZW5lcihkZXN0cm95Rm5zLCBjdXJyLCBcImtleWRvd25cIiwgKGV2ZW50KSA9PiB7XG4gICAgaWYgKG1hdGNoZXNLZXkoZXZlbnQsIG5leHRLZXksIHByZXZLZXkpKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfSk7XG59XG52YXIgUFJFVl9ORVhUX0tFWVMgPSB7XG4gIGhvcml6b250YWw6IHsgbmV4dEtleTogXCJBcnJvd1JpZ2h0XCIsIHByZXZLZXk6IFwiQXJyb3dMZWZ0XCIgfSxcbiAgdmVydGljYWw6IHsgbmV4dEtleTogXCJBcnJvd0Rvd25cIiwgcHJldktleTogXCJBcnJvd1VwXCIgfVxufTtcbmZ1bmN0aW9uIGluaXRUb29sYmFyS2V5TmF2KG9wdHMpIHtcbiAgb3B0cy50b29sYmFyLnJvbGUgPSBcInRvb2xiYXJcIjtcbiAgb3B0cy50b29sYmFyLmFyaWFPcmllbnRhdGlvbiA9IG9wdHMub3JpZW50YXRpb247XG4gIG9wdHMudG9vbGJhci5hcmlhSGlkZGVuID0gKG9wdHMuYnV0dG9ucy5sZW5ndGggPT09IDApLnRvU3RyaW5nKCk7XG4gIHJldHVybiBpbml0Um92aW5nVGFiSW5kZXgob3B0cyk7XG59XG5mdW5jdGlvbiBpbml0Um92aW5nVGFiSW5kZXgob3B0cykge1xuICBjb25zdCB7IG9yaWVudGF0aW9uLCBidXR0b25zLCB3cmFwQXJvdW5kID0gZmFsc2UsIG9uRXNjYXBlLCBvbkZvY3VzLCBvbkJsdXIgfSA9IG9wdHM7XG4gIGNvbnN0IHsgbmV4dEtleSwgcHJldktleSB9ID0gUFJFVl9ORVhUX0tFWVNbb3JpZW50YXRpb25dO1xuICBjb25zdCBzZXRUYWJJbmRpY2VzID0gKGV2ZW50KSA9PiB7XG4gICAgaWYgKGV2ZW50LnRhcmdldCAmJiBcInRhYkluZGV4XCIgaW4gZXZlbnQudGFyZ2V0KSB7XG4gICAgICBidXR0b25zLmZvckVhY2goKGIpID0+IGIudGFiSW5kZXggPSAtMSk7XG4gICAgICBldmVudC50YXJnZXQudGFiSW5kZXggPSAwO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgW2MsIG1dID0gd3JhcEFyb3VuZCA/IFtidXR0b25zLmxlbmd0aCwgYnV0dG9ucy5sZW5ndGhdIDogWzAsIEluZmluaXR5XTtcbiAgY29uc3QgZGVzdHJveUZucyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1dHRvbnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwcmV2ID0gYnV0dG9uc1soYyArIGkgLSAxKSAlIG1dO1xuICAgIGNvbnN0IGN1cnIgPSBidXR0b25zW2ldO1xuICAgIGNvbnN0IG5leHQgPSBidXR0b25zWyhjICsgaSArIDEpICUgbV07XG4gICAgYWRkUmVtb3ZhYmxlRXZlbnRMaXN0ZW5lcihkZXN0cm95Rm5zLCBjdXJyLCBcImZvY3VzXCIsIHNldFRhYkluZGljZXMpO1xuICAgIGlmIChvbkZvY3VzKVxuICAgICAgYWRkUmVtb3ZhYmxlRXZlbnRMaXN0ZW5lcihkZXN0cm95Rm5zLCBjdXJyLCBcImZvY3VzXCIsIG9uRm9jdXMpO1xuICAgIGlmIChvbkJsdXIpXG4gICAgICBhZGRSZW1vdmFibGVFdmVudExpc3RlbmVyKGRlc3Ryb3lGbnMsIGN1cnIsIFwiYmx1clwiLCBvbkJsdXIpO1xuICAgIGlmIChvbkVzY2FwZSlcbiAgICAgIGFkZEVzY2FwZUV2ZW50TGlzdGVuZXIoZGVzdHJveUZucywgY3Vyciwgb25Fc2NhcGUpO1xuICAgIGxpbmtUaHJlZUJ1dHRvbnMoZGVzdHJveUZucywgY3VyciwgcHJldiwgcHJldktleSwgbmV4dCwgbmV4dEtleSk7XG4gICAgY3Vyci50YWJJbmRleCA9IGkgPT09IDAgPyAwIDogLTE7XG4gIH1cbiAgcmV0dXJuIGRlc3Ryb3lGbnM7XG59XG52YXIgTWVudUNsb3NlckltcCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IobWVudSwgbGFzdEZvY3VzLCBjbG9zZUNhbGxiYWNrKSB7XG4gICAgdGhpcy5sYXN0Rm9jdXMgPSBsYXN0Rm9jdXM7XG4gICAgdGhpcy5jbG9zZUNhbGxiYWNrID0gY2xvc2VDYWxsYmFjaztcbiAgICB0aGlzLmRlc3Ryb3lGbnMgPSBbXTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMucHVzaChhZGRNb3VzZUNsb3NlTGlzdGVuZXIodGhpcy5kZXN0cm95Rm5zLCBtZW51LCAoKSA9PiB0aGlzLmNsb3NlKCkpKTtcbiAgfVxuICBjbG9zZSgpIHtcbiAgICB0aGlzLmRlc3Ryb3lGbnMuZm9yRWFjaCgoZCkgPT4gZCgpKTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMubGVuZ3RoID0gMDtcbiAgICB0aGlzLmNsb3NlQ2FsbGJhY2soKTtcbiAgICB0aGlzLmZpbmlzaENsb3NpbmcoKTtcbiAgfVxuICBmaW5pc2hDbG9zaW5nKCkge1xuICAgIHRoaXMuZGVzdHJveUZucy5mb3JFYWNoKChkKSA9PiBkKCkpO1xuICAgIHRoaXMuZGVzdHJveUZucy5sZW5ndGggPSAwO1xuICAgIHNldEF0dHJpYnV0ZSh0aGlzLmxhc3RGb2N1cywgXCJhcmlhLWV4cGFuZGVkXCIsIGZhbHNlKTtcbiAgICB0aGlzLmxhc3RGb2N1cz8uZm9jdXMoKTtcbiAgICB0aGlzLmxhc3RGb2N1cyA9IHZvaWQgMDtcbiAgfVxufTtcbmZ1bmN0aW9uIGluaXRNZW51S2V5TmF2KG9wdHMpIHtcbiAgY29uc3QgeyBzb3VyY2VFdmVudCwgb3JpZW50YXRpb24sIG1lbnUsIGJ1dHRvbnMsIGNsb3NlQ2FsbGJhY2ssIGF1dG9DbG9zZU9uQmx1ciA9IGZhbHNlIH0gPSBvcHRzO1xuICBjb25zdCB7IG5leHRLZXksIHByZXZLZXkgfSA9IFBSRVZfTkVYVF9LRVlTW29yaWVudGF0aW9uXTtcbiAgY29uc3QgbGFzdEZvY3VzID0gZ2V0TGFzdEZvY3VzKHNvdXJjZUV2ZW50KTtcbiAgc2V0QXR0cmlidXRlKGxhc3RGb2N1cywgXCJhcmlhLWV4cGFuZGVkXCIsIHRydWUpO1xuICBjb25zdCBtZW51Q2xvc2VyID0gbmV3IE1lbnVDbG9zZXJJbXAobWVudSwgbGFzdEZvY3VzLCBjbG9zZUNhbGxiYWNrKTtcbiAgY29uc3Qgb25Fc2NhcGUgPSAoKSA9PiBtZW51Q2xvc2VyLmNsb3NlKCk7XG4gIGNvbnN0IHsgZGVzdHJveUZucyB9ID0gbWVudUNsb3NlcjtcbiAgbWVudS5yb2xlID0gXCJtZW51XCI7XG4gIG1lbnUuYXJpYU9yaWVudGF0aW9uID0gb3JpZW50YXRpb247XG4gIGRlc3Ryb3lGbnMucHVzaCguLi5pbml0Um92aW5nVGFiSW5kZXgoeyBvcmllbnRhdGlvbiwgYnV0dG9ucywgb25Fc2NhcGUsIHdyYXBBcm91bmQ6IHRydWUgfSkpO1xuICBtZW51LnRhYkluZGV4ID0gLTE7XG4gIGFkZEVzY2FwZUV2ZW50TGlzdGVuZXIoZGVzdHJveUZucywgbWVudSwgb25Fc2NhcGUpO1xuICBhZGRSZW1vdmFibGVFdmVudExpc3RlbmVyKGRlc3Ryb3lGbnMsIG1lbnUsIFwia2V5ZG93blwiLCAoZXYpID0+IHtcbiAgICBpZiAoZXYudGFyZ2V0ID09PSBtZW51ICYmIChldi5rZXkgPT09IG5leHRLZXkgfHwgZXYua2V5ID09PSBwcmV2S2V5KSkge1xuICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGJ1dHRvbnNbMF0/LmZvY3VzKCk7XG4gICAgfVxuICB9KTtcbiAgaWYgKGF1dG9DbG9zZU9uQmx1cikge1xuICAgIGNvbnN0IGhhbmRsZXIgPSAoZXYpID0+IHtcbiAgICAgIGNvbnN0IGJ1dHRvbkFycmF5ID0gYnV0dG9ucztcbiAgICAgIGNvbnN0IGlzTGVhdmluZ01lbnUgPSAhYnV0dG9uQXJyYXkuaW5jbHVkZXMoZXYucmVsYXRlZFRhcmdldCk7XG4gICAgICBpZiAoaXNMZWF2aW5nTWVudSkge1xuICAgICAgICBvbkVzY2FwZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgZm9yIChjb25zdCBidXR0b24gb2YgYnV0dG9ucykge1xuICAgICAgYWRkUmVtb3ZhYmxlRXZlbnRMaXN0ZW5lcihkZXN0cm95Rm5zLCBidXR0b24sIFwiYmx1clwiLCBoYW5kbGVyKTtcbiAgICB9XG4gIH1cbiAgYnV0dG9uc1swXT8uZm9jdXMoKTtcbiAgcmV0dXJuIG1lbnVDbG9zZXI7XG59XG5mdW5jdGlvbiBtYWtlQWNjZXNzaWJsZUNsaWNrTGlzdGVuZXIoZWxlbWVudDIsIG9uY2xpY2spIHtcbiAgcmV0dXJuIChldmVudCkgPT4ge1xuICAgIGlmIChlbGVtZW50Mi5hcmlhRGlzYWJsZWQgPT09IFwidHJ1ZVwiKSB7XG4gICAgICByZXR1cm4gZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgb25jbGljayhldmVudCk7XG4gIH07XG59XG5mdW5jdGlvbiBpc0J1dHRvbkNsaWNrRXZlbnQoZXZlbnQpIHtcbiAgaWYgKFwiYnV0dG9uXCIgaW4gZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQuYnV0dG9uID09PSAwO1xuICB9XG4gIHJldHVybiBoYXNOb01vZGlmaWVycyhldmVudCkgJiYgKGV2ZW50LmNvZGUgPT09IFwiU3BhY2VcIiB8fCBldmVudC5rZXkgPT09IFwiRW50ZXJcIik7XG59XG5mdW5jdGlvbiBnZXRMYXN0Rm9jdXMoc291cmNlRXZlbnQpIHtcbiAgaWYgKHNvdXJjZUV2ZW50Py50YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiBcInRhYmluZGV4XCIgaW4gc291cmNlRXZlbnQudGFyZ2V0LmF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gc291cmNlRXZlbnQudGFyZ2V0O1xuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG5mdW5jdGlvbiBzdG9wUGFnZVNjcm9sbGluZyhlbGVtZW50Mikge1xuICBjb25zdCBoYW5kbGVyID0gKGV2ZW50KSA9PiB7XG4gICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3Qgc2hvdWxkUHJldmVudCA9IGdldEF0dHJpYnV0ZShldmVudC50YXJnZXQsIFwiZGF0YS1wcmV2ZW50ZGVmYXVsdFwiLCB0cnVlKTtcbiAgICBpZiAoc2hvdWxkUHJldmVudCAmJiBtYXRjaGVzS2V5KGV2ZW50LCBcIkFycm93UmlnaHRcIiwgXCJBcnJvd0xlZnRcIiwgXCJBcnJvd0Rvd25cIiwgXCJBcnJvd1VwXCIpKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfTtcbiAgZWxlbWVudDIuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgaGFuZGxlcik7XG4gIHJldHVybiAoKSA9PiBlbGVtZW50Mi5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBoYW5kbGVyKTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9zaXplTW9uaXRvci50c1xudmFyIFNpemVNb25pdG9yID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmVsZW1lbnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLmRvY3VtZW50UmVhZHkgPSBmYWxzZTtcbiAgICB0aGlzLnF1ZXVlZE9ic2VydmVSZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMub25Mb2FkID0gKCkgPT4ge1xuICAgICAgdGhpcy5kb2N1bWVudFJlYWR5ID0gdHJ1ZTtcbiAgICAgIHRoaXMucXVldWVkT2JzZXJ2ZVJlcXVlc3RzLmZvckVhY2goKFtlbCwgY2JdKSA9PiB0aGlzLm9ic2VydmUoZWwsIGNiKSk7XG4gICAgICB0aGlzLnF1ZXVlZE9ic2VydmVSZXF1ZXN0cyA9IFtdO1xuICAgIH07XG4gICAgaWYgKHR5cGVvZiBSZXNpemVPYnNlcnZlciA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLnJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKChlbnRyaWVzKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IHtcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICBjb250ZW50UmVjdDogeyB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIgfVxuICAgICAgfSBvZiBlbnRyaWVzKSB7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5lbGVtZW50cy5nZXQodGFyZ2V0KTtcbiAgICAgICAgdGhpcy5jaGVja1NpemUoZW50cnksIHRhcmdldCwgd2lkdGgyLCBoZWlnaHQyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmRvY3VtZW50UmVhZHkgPSBnZXREb2N1bWVudChcInJlYWR5U3RhdGVcIikgPT09IFwiY29tcGxldGVcIjtcbiAgICBpZiAoIXRoaXMuZG9jdW1lbnRSZWFkeSkge1xuICAgICAgZ2V0V2luZG93KCk/LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIHRoaXMub25Mb2FkKTtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBnZXRXaW5kb3coKT8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgdGhpcy5vbkxvYWQpO1xuICAgIHRoaXMucmVzaXplT2JzZXJ2ZXI/LmRpc2Nvbm5lY3QoKTtcbiAgICB0aGlzLnJlc2l6ZU9ic2VydmVyID0gbnVsbDtcbiAgfVxuICBjaGVja1NpemUoZW50cnksIGVsZW1lbnQyLCB3aWR0aDIsIGhlaWdodDIpIHtcbiAgICBpZiAoIWVudHJ5KVxuICAgICAgcmV0dXJuO1xuICAgIGlmICh3aWR0aDIgIT09IGVudHJ5LnNpemU/LndpZHRoIHx8IGhlaWdodDIgIT09IGVudHJ5LnNpemU/LmhlaWdodCkge1xuICAgICAgZW50cnkuc2l6ZSA9IHsgd2lkdGg6IHdpZHRoMiwgaGVpZ2h0OiBoZWlnaHQyIH07XG4gICAgICBlbnRyeS5jYihlbnRyeS5zaXplLCBlbGVtZW50Mik7XG4gICAgfVxuICB9XG4gIC8vIE9ubHkgYSBzaW5nbGUgY2FsbGJhY2sgaXMgc3VwcG9ydGVkLlxuICBvYnNlcnZlKGVsZW1lbnQyLCBjYikge1xuICAgIGlmICghdGhpcy5kb2N1bWVudFJlYWR5KSB7XG4gICAgICB0aGlzLnF1ZXVlZE9ic2VydmVSZXF1ZXN0cy5wdXNoKFtlbGVtZW50MiwgY2JdKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuZWxlbWVudHMuaGFzKGVsZW1lbnQyKSkge1xuICAgICAgdGhpcy5yZW1vdmVGcm9tUXVldWUoZWxlbWVudDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyPy5vYnNlcnZlKGVsZW1lbnQyKTtcbiAgICB9XG4gICAgY29uc3QgZW50cnkgPSB7IGNiIH07XG4gICAgdGhpcy5lbGVtZW50cy5zZXQoZWxlbWVudDIsIGVudHJ5KTtcbiAgfVxuICB1bm9ic2VydmUoZWxlbWVudDIpIHtcbiAgICB0aGlzLnJlc2l6ZU9ic2VydmVyPy51bm9ic2VydmUoZWxlbWVudDIpO1xuICAgIHRoaXMuZWxlbWVudHMuZGVsZXRlKGVsZW1lbnQyKTtcbiAgICB0aGlzLnJlbW92ZUZyb21RdWV1ZShlbGVtZW50Mik7XG4gICAgaWYgKCF0aGlzLmVsZW1lbnRzLnNpemUpIHtcbiAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIH1cbiAgfVxuICByZW1vdmVGcm9tUXVldWUoZWxlbWVudDIpIHtcbiAgICB0aGlzLnF1ZXVlZE9ic2VydmVSZXF1ZXN0cyA9IHRoaXMucXVldWVkT2JzZXJ2ZVJlcXVlc3RzLmZpbHRlcigoW2VsXSkgPT4gZWwgIT09IGVsZW1lbnQyKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvZG9tL2RvbUxheW91dC5odG1sXG52YXIgZG9tTGF5b3V0X2RlZmF1bHQgPSAnPGRpdiByb2xlPVwicHJlc2VudGF0aW9uXCIgY2xhc3M9XCJhZy1jaGFydHMtd3JhcHBlciBhZy1jaGFydHMtc3R5bGVzXCIgZGF0YS1hZy1jaGFydHM+PGRpdiByb2xlPVwicHJlc2VudGF0aW9uXCIgY2xhc3M9XCJhZy1jaGFydHMtY2FudmFzLWNlbnRlclwiPjxkaXYgcm9sZT1cInByZXNlbnRhdGlvblwiIGNsYXNzPVwiYWctY2hhcnRzLWNhbnZhcy1jb250YWluZXJcIj48ZGl2IHJvbGU9XCJwcmVzZW50YXRpb25cIiBjbGFzcz1cImFnLWNoYXJ0cy1jYW52YXNcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L2Rpdj48ZGl2IHJvbGU9XCJmaWd1cmVcIiBjbGFzcz1cImFnLWNoYXJ0cy1jYW52YXMtcHJveHlcIj48ZGl2IHJvbGU9XCJpbWdcIiBjbGFzcz1cImFnLWNoYXJ0cy1zZXJpZXMtYXJlYVwiIHRhYmluZGV4PVwiLTFcIj48L2Rpdj48L2Rpdj48ZGl2IHJvbGU9XCJwcmVzZW50YXRpb25cIiBjbGFzcz1cImFnLWNoYXJ0cy1jYW52YXMtb3ZlcmxheVwiPjwvZGl2PjwvZGl2PjwvZGl2PjwvZGl2Pic7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2RvbS9kb21NYW5hZ2VyLnRzXG52YXIgRE9NX0VMRU1FTlRfQ0xBU1NFUyA9IFtcbiAgXCJzdHlsZXNcIixcbiAgXCJjYW52YXNcIixcbiAgXCJjYW52YXMtY2VudGVyXCIsXG4gIFwiY2FudmFzLW92ZXJsYXlcIixcbiAgXCJjYW52YXMtcHJveHlcIixcbiAgXCJzZXJpZXMtYXJlYVwiXG5dO1xudmFyIGRvbUVsZW1lbnRDb25maWcgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gIFtcInN0eWxlc1wiLCB7IGNoaWxkRWxlbWVudFR5cGU6IFwic3R5bGVcIiB9XSxcbiAgW1wiY2FudmFzXCIsIHsgY2hpbGRFbGVtZW50VHlwZTogXCJjYW52YXNcIiB9XSxcbiAgW1wiY2FudmFzLXByb3h5XCIsIHsgY2hpbGRFbGVtZW50VHlwZTogXCJkaXZcIiB9XSxcbiAgW1wiY2FudmFzLW92ZXJsYXlcIiwgeyBjaGlsZEVsZW1lbnRUeXBlOiBcImRpdlwiIH1dLFxuICBbXCJjYW52YXMtY2VudGVyXCIsIHsgY2hpbGRFbGVtZW50VHlwZTogXCJkaXZcIiB9XSxcbiAgW1wic2VyaWVzLWFyZWFcIiwgeyBjaGlsZEVsZW1lbnRUeXBlOiBcImRpdlwiIH1dXG5dKTtcbmZ1bmN0aW9uIHNldHVwT2JzZXJ2ZXIoZWxlbWVudDIsIGNiKSB7XG4gIGlmICh0eXBlb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgcmV0dXJuO1xuICBjb25zdCBvYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihcbiAgICAoZW50cmllcykgPT4ge1xuICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICAgIGlmIChlbnRyeS50YXJnZXQgPT09IGVsZW1lbnQyKSB7XG4gICAgICAgICAgY2IoZW50cnkuaW50ZXJzZWN0aW9uUmF0aW8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICB7IHJvb3Q6IGVsZW1lbnQyIH1cbiAgKTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50Mik7XG4gIHJldHVybiBvYnNlcnZlcjtcbn1cbnZhciBOVUxMX0RPTVJFQ1QgPSB7XG4gIHg6IDAsXG4gIHk6IDAsXG4gIHdpZHRoOiAwLFxuICBoZWlnaHQ6IDAsXG4gIHRvcDogMCxcbiAgYm90dG9tOiAwLFxuICBsZWZ0OiAwLFxuICByaWdodDogMCxcbiAgdG9KU09OKCkge1xuICAgIHJldHVybiBOVUxMX0RPTVJFQ1Q7XG4gIH1cbn07XG52YXIgRE9NTWFuYWdlciA9IGNsYXNzIGV4dGVuZHMgQmFzZU1hbmFnZXIge1xuICBjb25zdHJ1Y3Rvcihjb250YWluZXIsIHN0eWxlQ29udGFpbmVyKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnN0eWxlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5jb250YWluZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5jb250YWluZXJTaXplID0gdm9pZCAwO1xuICAgIHRoaXMuc2l6ZU1vbml0b3IgPSBuZXcgU2l6ZU1vbml0b3IoKTtcbiAgICBjb25zdCB0ZW1wbGF0ZUVsID0gY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0ZW1wbGF0ZUVsLmlubmVySFRNTCA9IGRvbUxheW91dF9kZWZhdWx0O1xuICAgIHRoaXMuZWxlbWVudCA9IHRlbXBsYXRlRWwuY2hpbGRyZW4uaXRlbSgwKTtcbiAgICB0aGlzLnN0eWxlUm9vdEVsZW1lbnQgPSBzdHlsZUNvbnRhaW5lcjtcbiAgICB0aGlzLnJvb3RFbGVtZW50cyA9IERPTV9FTEVNRU5UX0NMQVNTRVMucmVkdWNlKFxuICAgICAgKHIsIGMpID0+IHtcbiAgICAgICAgY29uc3QgY3NzQ2xhc3MgPSBgYWctY2hhcnRzLSR7Y31gO1xuICAgICAgICBjb25zdCBlbCA9IHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoY3NzQ2xhc3MpID8gdGhpcy5lbGVtZW50IDogdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoYC4ke2Nzc0NsYXNzfWApO1xuICAgICAgICBpZiAoIWVsKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQUcgQ2hhcnRzIC0gdW5hYmxlIHRvIGZpbmQgRE9NIGVsZW1lbnQgJHtjc3NDbGFzc31gKTtcbiAgICAgICAgcltjXSA9IHsgZWxlbWVudDogZWwsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCBsaXN0ZW5lcnM6IFtdIH07XG4gICAgICAgIHJldHVybiByO1xuICAgICAgfSxcbiAgICAgIHt9XG4gICAgKTtcbiAgICBsZXQgaGlkZGVuID0gZmFsc2U7XG4gICAgdGhpcy5vYnNlcnZlciA9IHNldHVwT2JzZXJ2ZXIodGhpcy5lbGVtZW50LCAoaW50ZXJzZWN0aW9uUmF0aW8pID0+IHtcbiAgICAgIGlmIChpbnRlcnNlY3Rpb25SYXRpbyA9PT0gMCAmJiAhaGlkZGVuKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzLmRpc3BhdGNoKFwiaGlkZGVuXCIsIHsgdHlwZTogXCJoaWRkZW5cIiB9KTtcbiAgICAgIH1cbiAgICAgIGhpZGRlbiA9IGludGVyc2VjdGlvblJhdGlvID09PSAwO1xuICAgIH0pO1xuICAgIHRoaXMuc2V0U2l6ZU9wdGlvbnMoKTtcbiAgICB0aGlzLmFkZFN0eWxlcyhcImFnLWNoYXJ0cy1jb21tdW5pdHlcIiwgc3R5bGVzX2RlZmF1bHQpO1xuICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgIHRoaXMuc2V0Q29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgfVxuICAgIHRoaXMuZGVzdHJveUZucy5wdXNoKHN0b3BQYWdlU2Nyb2xsaW5nKHRoaXMuZWxlbWVudCkpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIHRoaXMub2JzZXJ2ZXI/LnVub2JzZXJ2ZSh0aGlzLmVsZW1lbnQpO1xuICAgIGlmICh0aGlzLmNvbnRhaW5lcikge1xuICAgICAgdGhpcy5zaXplTW9uaXRvci51bm9ic2VydmUodGhpcy5jb250YWluZXIpO1xuICAgIH1cbiAgICBPYmplY3QudmFsdWVzKHRoaXMucm9vdEVsZW1lbnRzKS5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgZWwuY2hpbGRyZW4uZm9yRWFjaCgoYykgPT4gYy5yZW1vdmUoKSk7XG4gICAgICBlbC5lbGVtZW50LnJlbW92ZSgpO1xuICAgIH0pO1xuICAgIHRoaXMuZWxlbWVudC5yZW1vdmUoKTtcbiAgfVxuICBzZXRTaXplT3B0aW9ucyhtaW5XaWR0aCA9IDMwMCwgbWluSGVpZ2h0ID0gMzAwLCBvcHRpb25zV2lkdGgsIG9wdGlvbnNIZWlnaHQpIHtcbiAgICBjb25zdCB7IHN0eWxlIH0gPSB0aGlzLmVsZW1lbnQ7XG4gICAgc3R5bGUud2lkdGggPSBgJHtvcHRpb25zV2lkdGggPz8gbWluV2lkdGh9cHhgO1xuICAgIHN0eWxlLmhlaWdodCA9IGAke29wdGlvbnNIZWlnaHQgPz8gbWluSGVpZ2h0fXB4YDtcbiAgfVxuICB1cGRhdGVDb250YWluZXJTaXplKCkge1xuICAgIGNvbnN0IHsgc3R5bGU6IGNlbnRlclN0eWxlIH0gPSB0aGlzLnJvb3RFbGVtZW50c1tcImNhbnZhcy1jZW50ZXJcIl0uZWxlbWVudDtcbiAgICBjZW50ZXJTdHlsZS53aWR0aCA9IGAke3RoaXMuY29udGFpbmVyU2l6ZT8ud2lkdGggPz8gMH1weGA7XG4gICAgY2VudGVyU3R5bGUuaGVpZ2h0ID0gYCR7dGhpcy5jb250YWluZXJTaXplPy5oZWlnaHQgPz8gMH1weGA7XG4gIH1cbiAgc2V0Q29udGFpbmVyKG5ld0NvbnRhaW5lcikge1xuICAgIGlmIChuZXdDb250YWluZXIgPT09IHRoaXMuY29udGFpbmVyKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICh0aGlzLmNvbnRhaW5lcikge1xuICAgICAgdGhpcy5jb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5lbGVtZW50KTtcbiAgICAgIHRoaXMuc2l6ZU1vbml0b3IudW5vYnNlcnZlKHRoaXMuY29udGFpbmVyKTtcbiAgICB9XG4gICAgY29uc3QgaXNTaGFkb3dEb20gPSB0aGlzLmdldFNoYWRvd0RvY3VtZW50Um9vdChuZXdDb250YWluZXIpICE9IG51bGw7XG4gICAgaWYgKCFpc1NoYWRvd0RvbSkge1xuICAgICAgZm9yIChjb25zdCBpZCBvZiB0aGlzLnJvb3RFbGVtZW50c1tcInN0eWxlc1wiXS5jaGlsZHJlbi5rZXlzKCkpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVDaGlsZChcInN0eWxlc1wiLCBpZCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyID0gbmV3Q29udGFpbmVyO1xuICAgIGZvciAoY29uc3QgW2lkLCBzdHlsZXNdIG9mIHRoaXMuc3R5bGVzKSB7XG4gICAgICB0aGlzLmFkZFN0eWxlcyhpZCwgc3R5bGVzKTtcbiAgICB9XG4gICAgbmV3Q29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZWxlbWVudCk7XG4gICAgdGhpcy5zaXplTW9uaXRvci5vYnNlcnZlKG5ld0NvbnRhaW5lciwgKHNpemUpID0+IHtcbiAgICAgIHRoaXMuY29udGFpbmVyU2l6ZSA9IHNpemU7XG4gICAgICB0aGlzLnVwZGF0ZUNvbnRhaW5lclNpemUoKTtcbiAgICAgIHRoaXMubGlzdGVuZXJzLmRpc3BhdGNoKFwicmVzaXplXCIsIHsgdHlwZTogXCJyZXNpemVcIiB9KTtcbiAgICB9KTtcbiAgICB0aGlzLmxpc3RlbmVycy5kaXNwYXRjaChcImNvbnRhaW5lci1jaGFuZ2VkXCIsIHsgdHlwZTogXCJjb250YWluZXItY2hhbmdlZFwiIH0pO1xuICB9XG4gIHNldFRoZW1lQ2xhc3ModGhlbWVDbGFzc05hbWUpIHtcbiAgICBjb25zdCB0aGVtZUNsYXNzTmFtZVByZWZpeCA9IFwiYWctY2hhcnRzLXRoZW1lLVwiO1xuICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuZm9yRWFjaCgoY2xhc3NOYW1lKSA9PiB7XG4gICAgICBpZiAoY2xhc3NOYW1lLnN0YXJ0c1dpdGgodGhlbWVDbGFzc05hbWVQcmVmaXgpICYmIGNsYXNzTmFtZSAhPT0gdGhlbWVDbGFzc05hbWUpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZCh0aGVtZUNsYXNzTmFtZSk7XG4gIH1cbiAgc2V0VGFiSW5kZXgodGFiSW5kZXgpIHtcbiAgICB0aGlzLnJvb3RFbGVtZW50c1tcInNlcmllcy1hcmVhXCJdLmVsZW1lbnQudGFiSW5kZXggPSB0YWJJbmRleDtcbiAgfVxuICB1cGRhdGVDYW52YXNMYWJlbChhcmlhTGFiZWwpIHtcbiAgICBzZXRBdHRyaWJ1dGUodGhpcy5yb290RWxlbWVudHNbXCJjYW52YXMtcHJveHlcIl0uZWxlbWVudCwgXCJhcmlhLWxhYmVsXCIsIGFyaWFMYWJlbCk7XG4gIH1cbiAgZ2V0RXZlbnRFbGVtZW50KGRlZmF1bHRFbGVtLCBldmVudFR5cGUpIHtcbiAgICBjb25zdCBldmVudHMgPSBbXCJmb2N1c1wiLCBcImJsdXJcIiwgXCJrZXlkb3duXCIsIFwia2V5dXBcIl07XG4gICAgcmV0dXJuIGV2ZW50cy5pbmNsdWRlcyhldmVudFR5cGUpID8gdGhpcy5yb290RWxlbWVudHNbXCJzZXJpZXMtYXJlYVwiXS5lbGVtZW50IDogZGVmYXVsdEVsZW07XG4gIH1cbiAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgIHRoaXMuZ2V0RXZlbnRFbGVtZW50KHRoaXMuZWxlbWVudCwgdHlwZSkuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucyk7XG4gIH1cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgIHRoaXMuZ2V0RXZlbnRFbGVtZW50KHRoaXMuZWxlbWVudCwgdHlwZSkucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucyk7XG4gIH1cbiAgLyoqIEdldCB0aGUgbWFpbiBjaGFydCBhcmVhIGNsaWVudCBib3VuZCByZWN0LiAqL1xuICBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMucm9vdEVsZW1lbnRzW1wiY2FudmFzXCJdLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgY2xpZW50IGJvdW5kaW5nIHJlY3QgZm9yIG92ZXJsYXkgZWxlbWVudHMgdGhhdCBtaWdodCBmbG9hdCBvdXRzaWRlIHRoZSBib3VuZHMgb2YgdGhlXG4gICAqIG1haW4gY2hhcnQgYXJlYS5cbiAgICovXG4gIGdldE92ZXJsYXlDbGllbnRSZWN0KCkge1xuICAgIGNvbnN0IHdpbmRvdzIgPSBnZXRXaW5kb3coKTtcbiAgICBjb25zdCB3aW5kb3dCQm94ID0gbmV3IEJCb3goMCwgMCwgd2luZG93Mi5pbm5lcldpZHRoLCB3aW5kb3cyLmlubmVySGVpZ2h0KTtcbiAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmdldFJhd092ZXJsYXlDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgY29udGFpbmVyQkJveCA9IEJCb3guZnJvbURPTVJlY3QoY29udGFpbmVyID8/IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xuICAgIHJldHVybiB3aW5kb3dCQm94LmludGVyc2VjdGlvbihjb250YWluZXJCQm94KT8udG9ET01SZWN0KCkgPz8gTlVMTF9ET01SRUNUO1xuICB9XG4gIGdldFJhd092ZXJsYXlDbGllbnRSZWN0KCkge1xuICAgIGxldCBlbGVtZW50MiA9IHRoaXMuZWxlbWVudDtcbiAgICB3aGlsZSAoZWxlbWVudDIgIT0gbnVsbCkge1xuICAgICAgY29uc3Qgc3R5bGVNYXAgPSBlbGVtZW50Mi5jb21wdXRlZFN0eWxlTWFwPy4oKTtcbiAgICAgIGNvbnN0IG92ZXJmbG93WCA9IHN0eWxlTWFwPy5nZXQoXCJvdmVyZmxvdy14XCIpPy50b1N0cmluZygpO1xuICAgICAgY29uc3Qgb3ZlcmZsb3dZID0gc3R5bGVNYXA/LmdldChcIm92ZXJmbG93LXlcIik/LnRvU3RyaW5nKCk7XG4gICAgICBpZiAob3ZlcmZsb3dYICE9IG51bGwgJiYgb3ZlcmZsb3dYICE9PSBcInZpc2libGVcIiB8fCBvdmVyZmxvd1kgJiYgb3ZlcmZsb3dZICE9PSBcInZpc2libGVcIikge1xuICAgICAgICByZXR1cm4gZWxlbWVudDIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB9XG4gICAgICBlbGVtZW50MiA9IGVsZW1lbnQyLnBhcmVudEVsZW1lbnQ7XG4gICAgfVxuICAgIGNvbnN0IGRvY1Jvb3QgPSB0aGlzLmdldFNoYWRvd0RvY3VtZW50Um9vdCgpO1xuICAgIGlmIChkb2NSb290KSB7XG4gICAgICByZXR1cm4gZG9jUm9vdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9XG4gIH1cbiAgZ2V0U2hhZG93RG9jdW1lbnRSb290KGN1cnJlbnQgPSB0aGlzLmNvbnRhaW5lcikge1xuICAgIGNvbnN0IGRvY1Jvb3QgPSBjdXJyZW50Py5vd25lckRvY3VtZW50Py5ib2R5ID8/IGdldERvY3VtZW50KFwiYm9keVwiKTtcbiAgICB3aGlsZSAoY3VycmVudCAhPSBudWxsKSB7XG4gICAgICBpZiAoY3VycmVudCA9PT0gZG9jUm9vdCkge1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnQucGFyZW50Tm9kZSBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICB9XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgZ2V0Q2hpbGRCb3VuZGluZ0NsaWVudFJlY3QodHlwZSkge1xuICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IHRoaXMucm9vdEVsZW1lbnRzW3R5cGVdO1xuICAgIGNvbnN0IGNoaWxkUmVjdHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuLnZhbHVlcygpKSB7XG4gICAgICBjaGlsZFJlY3RzLnB1c2goQkJveC5mcm9tRE9NUmVjdChjaGlsZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSkpO1xuICAgIH1cbiAgICByZXR1cm4gQkJveC5tZXJnZShjaGlsZFJlY3RzKTtcbiAgfVxuICBjYWxjdWxhdGVDYW52YXNQb3NpdGlvbihlbCkge1xuICAgIGxldCB4ID0gMDtcbiAgICBsZXQgeSA9IDA7XG4gICAgY29uc3QgeyB4OiBjeCA9IDAsIHk6IGN5ID0gMCB9ID0gdGhpcy5nZXRDaGlsZEJvdW5kaW5nQ2xpZW50UmVjdChcImNhbnZhc1wiKSA/PyB7fTtcbiAgICBjb25zdCBlbFJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB4ID0gZWxSZWN0LnggLSBjeDtcbiAgICB5ID0gZWxSZWN0LnkgLSBjeTtcbiAgICByZXR1cm4geyB4LCB5IH07XG4gIH1cbiAgaXNNYW5hZ2VkQ2hpbGRET01FbGVtZW50KGVsLCBkb21FbGVtZW50Q2xhc3MsIGlkKSB7XG4gICAgY29uc3QgeyBjaGlsZHJlbiB9ID0gdGhpcy5yb290RWxlbWVudHNbZG9tRWxlbWVudENsYXNzXTtcbiAgICBjb25zdCBzZWFyY2ggPSBjaGlsZHJlbj8uZ2V0KGlkKTtcbiAgICByZXR1cm4gc2VhcmNoICE9IG51bGwgJiYgZWwuY29udGFpbnMoc2VhcmNoKTtcbiAgfVxuICBpc0V2ZW50T3ZlckVsZW1lbnQoZXZlbnQpIHtcbiAgICBjb25zdCBlbGVtZW50MiA9IGV2ZW50LnRhcmdldDtcbiAgICByZXR1cm4gZWxlbWVudDIgIT0gbnVsbCAmJiB0aGlzLmVsZW1lbnQuY29udGFpbnMoZWxlbWVudDIpO1xuICB9XG4gIGFkZFN0eWxlcyhpZCwgc3R5bGVzKSB7XG4gICAgY29uc3QgZGF0YUF0dHJpYnV0ZSA9IFwiZGF0YS1hZy1jaGFydHNcIjtcbiAgICB0aGlzLnN0eWxlcy5zZXQoaWQsIHN0eWxlcyk7XG4gICAgaWYgKHRoaXMuY29udGFpbmVyID09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgY2hlY2tJZCA9IChlbCkgPT4ge1xuICAgICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZShkYXRhQXR0cmlidXRlKSA9PT0gaWQ7XG4gICAgfTtcbiAgICBjb25zdCBhZGRTdHlsZUVsZW1lbnQgPSAoZWwpID0+IHtcbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgZWwuY2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKGNoZWNrSWQoY2hpbGQpKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0eWxlRWwgPSBjcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgICBlbC5hcHBlbmRDaGlsZChzdHlsZUVsKTtcbiAgICAgIHJldHVybiBzdHlsZUVsO1xuICAgIH07XG4gICAgbGV0IHN0eWxlRWxlbWVudDtcbiAgICBpZiAodGhpcy5zdHlsZVJvb3RFbGVtZW50KSB7XG4gICAgICBzdHlsZUVsZW1lbnQgPSBhZGRTdHlsZUVsZW1lbnQodGhpcy5zdHlsZVJvb3RFbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZG9jdW1lbnRSb290ID0gdGhpcy5nZXRTaGFkb3dEb2N1bWVudFJvb3QodGhpcy5jb250YWluZXIpO1xuICAgICAgaWYgKGRvY3VtZW50Um9vdCAhPSBudWxsKSB7XG4gICAgICAgIHN0eWxlRWxlbWVudCA9IHRoaXMuYWRkQ2hpbGQoXCJzdHlsZXNcIiwgaWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGVFbGVtZW50ID0gYWRkU3R5bGVFbGVtZW50KGdldERvY3VtZW50KFwiaGVhZFwiKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdHlsZUVsZW1lbnQgPT0gbnVsbCB8fCBjaGVja0lkKHN0eWxlRWxlbWVudCkpXG4gICAgICByZXR1cm47XG4gICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShkYXRhQXR0cmlidXRlLCBpZCk7XG4gICAgc3R5bGVFbGVtZW50LmlubmVySFRNTCA9IHN0eWxlcztcbiAgfVxuICByZW1vdmVTdHlsZXMoaWQpIHtcbiAgICB0aGlzLnJlbW92ZUNoaWxkKFwic3R5bGVzXCIsIGlkKTtcbiAgfVxuICB1cGRhdGVDdXJzb3Ioc3R5bGUpIHtcbiAgICB0aGlzLmVsZW1lbnQuc3R5bGUuY3Vyc29yID0gc3R5bGU7XG4gIH1cbiAgZ2V0Q3Vyc29yKCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnQuc3R5bGUuY3Vyc29yO1xuICB9XG4gIGFkZENoaWxkKGRvbUVsZW1lbnRDbGFzcywgaWQsIGNoaWxkLCBpbnNlcnQpIHtcbiAgICBjb25zdCB7IGVsZW1lbnQ6IGVsZW1lbnQyLCBjaGlsZHJlbiwgbGlzdGVuZXJzIH0gPSB0aGlzLnJvb3RFbGVtZW50c1tkb21FbGVtZW50Q2xhc3NdO1xuICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFHIENoYXJ0cyAtIHVuYWJsZSB0byBjcmVhdGUgRE9NIGVsZW1lbnRzIGFmdGVyIGRlc3Ryb3koKVwiKTtcbiAgICB9XG4gICAgaWYgKGNoaWxkcmVuLmhhcyhpZCkpIHtcbiAgICAgIHJldHVybiBjaGlsZHJlbi5nZXQoaWQpO1xuICAgIH1cbiAgICBjb25zdCB7IGNoaWxkRWxlbWVudFR5cGUgPSBcImRpdlwiIH0gPSBkb21FbGVtZW50Q29uZmlnLmdldChkb21FbGVtZW50Q2xhc3MpID8/IHt9O1xuICAgIGlmIChjaGlsZCAmJiBjaGlsZC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgIT09IGNoaWxkRWxlbWVudFR5cGUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQUcgQ2hhcnRzIC0gbWlzbWF0Y2hpbmcgRE9NIGVsZW1lbnQgdHlwZVwiKTtcbiAgICB9XG4gICAgY29uc3QgbmV3Q2hpbGQgPSBjaGlsZCA/PyBjcmVhdGVFbGVtZW50KGNoaWxkRWxlbWVudFR5cGUpO1xuICAgIGZvciAoY29uc3QgW3R5cGUsIGZuLCBvcHRzXSBvZiBsaXN0ZW5lcnMpIHtcbiAgICAgIG5ld0NoaWxkLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZm4sIG9wdHMpO1xuICAgIH1cbiAgICBjaGlsZHJlbi5zZXQoaWQsIG5ld0NoaWxkKTtcbiAgICBpZiAoaW5zZXJ0KSB7XG4gICAgICBjb25zdCBxdWVyeVJlc3VsdCA9IGVsZW1lbnQyLnF1ZXJ5U2VsZWN0b3IoaW5zZXJ0LnF1ZXJ5KTtcbiAgICAgIGlmIChxdWVyeVJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQUcgQ2hhcnRzIC0gYWRkQ2hpbGQgcXVlcnkgZmFpbGVkICR7aW5zZXJ0LnF1ZXJ5fWApO1xuICAgICAgfVxuICAgICAgcXVlcnlSZXN1bHQuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KGluc2VydC53aGVyZSwgbmV3Q2hpbGQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50Mj8uYXBwZW5kQ2hpbGQobmV3Q2hpbGQpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3Q2hpbGQ7XG4gIH1cbiAgcmVtb3ZlQ2hpbGQoZG9tRWxlbWVudENsYXNzLCBpZCkge1xuICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IHRoaXMucm9vdEVsZW1lbnRzW2RvbUVsZW1lbnRDbGFzc107XG4gICAgaWYgKCFjaGlsZHJlbilcbiAgICAgIHJldHVybjtcbiAgICBjaGlsZHJlbi5nZXQoaWQpPy5yZW1vdmUoKTtcbiAgICBjaGlsZHJlbi5kZWxldGUoaWQpO1xuICB9XG4gIGluY3JlbWVudERhdGFDb3VudGVyKG5hbWUpIHtcbiAgICBjb25zdCB7IGRhdGFzZXQgfSA9IHRoaXMuZWxlbWVudDtcbiAgICBkYXRhc2V0W25hbWVdID8/IChkYXRhc2V0W25hbWVdID0gXCIwXCIpO1xuICAgIGRhdGFzZXRbbmFtZV0gPSBTdHJpbmcoTnVtYmVyKGRhdGFzZXRbbmFtZV0pICsgMSk7XG4gIH1cbiAgc2V0RGF0YUJvb2xlYW4obmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLmVsZW1lbnQuZGF0YXNldFtuYW1lXSA9IFN0cmluZyh2YWx1ZSk7XG4gIH1cbiAgZ2V0SWNvbkNsYXNzTmFtZXMoaWNvbikge1xuICAgIHJldHVybiBgYWctY2hhcnRzLWljb24gYWctY2hhcnRzLWljb24tJHtpY29ufWA7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL3BvbHlSb290cy50c1xuZnVuY3Rpb24gbGluZWFyUm9vdChhLCBiKSB7XG4gIGNvbnN0IHQgPSAtYiAvIGE7XG4gIHJldHVybiBhICE9PSAwICYmIHQgPj0gMCAmJiB0IDw9IDEgPyBbdF0gOiBbXTtcbn1cbmZ1bmN0aW9uIHF1YWRyYXRpY1Jvb3RzKGEsIGIsIGMpIHtcbiAgaWYgKGEgPT09IDApIHtcbiAgICByZXR1cm4gbGluZWFyUm9vdChiLCBjKTtcbiAgfVxuICBjb25zdCBEID0gYiAqIGIgLSA0ICogYSAqIGM7XG4gIGNvbnN0IHJvb3RzID0gW107XG4gIGlmIChEID09PSAwKSB7XG4gICAgY29uc3QgdCA9IC1iIC8gKDIgKiBhKTtcbiAgICBpZiAodCA+PSAwICYmIHQgPD0gMSkge1xuICAgICAgcm9vdHMucHVzaCh0KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoRCA+IDApIHtcbiAgICBjb25zdCByRCA9IE1hdGguc3FydChEKTtcbiAgICBjb25zdCB0MSA9ICgtYiAtIHJEKSAvICgyICogYSk7XG4gICAgY29uc3QgdDIgPSAoLWIgKyByRCkgLyAoMiAqIGEpO1xuICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgIHJvb3RzLnB1c2godDEpO1xuICAgIH1cbiAgICBpZiAodDIgPj0gMCAmJiB0MiA8PSAxKSB7XG4gICAgICByb290cy5wdXNoKHQyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJvb3RzO1xufVxuZnVuY3Rpb24gY3ViaWNSb290cyhhLCBiLCBjLCBkKSB7XG4gIGlmIChhID09PSAwKSB7XG4gICAgcmV0dXJuIHF1YWRyYXRpY1Jvb3RzKGIsIGMsIGQpO1xuICB9XG4gIGNvbnN0IEEgPSBiIC8gYTtcbiAgY29uc3QgQiA9IGMgLyBhO1xuICBjb25zdCBDID0gZCAvIGE7XG4gIGNvbnN0IFEgPSAoMyAqIEIgLSBBICogQSkgLyA5O1xuICBjb25zdCBSID0gKDkgKiBBICogQiAtIDI3ICogQyAtIDIgKiBBICogQSAqIEEpIC8gNTQ7XG4gIGNvbnN0IEQgPSBRICogUSAqIFEgKyBSICogUjtcbiAgY29uc3QgdGhpcmQgPSAxIC8gMztcbiAgY29uc3Qgcm9vdHMgPSBbXTtcbiAgaWYgKEQgPj0gMCkge1xuICAgIGNvbnN0IHJEID0gTWF0aC5zcXJ0KEQpO1xuICAgIGNvbnN0IFMgPSBNYXRoLnNpZ24oUiArIHJEKSAqIE1hdGgucG93KE1hdGguYWJzKFIgKyByRCksIHRoaXJkKTtcbiAgICBjb25zdCBUID0gTWF0aC5zaWduKFIgLSByRCkgKiBNYXRoLnBvdyhNYXRoLmFicyhSIC0gckQpLCB0aGlyZCk7XG4gICAgY29uc3QgSW0gPSBNYXRoLmFicyhNYXRoLnNxcnQoMykgKiAoUyAtIFQpIC8gMik7XG4gICAgY29uc3QgdCA9IC10aGlyZCAqIEEgKyAoUyArIFQpO1xuICAgIGlmICh0ID49IDAgJiYgdCA8PSAxKSB7XG4gICAgICByb290cy5wdXNoKHQpO1xuICAgIH1cbiAgICBpZiAoSW0gPT09IDApIHtcbiAgICAgIGNvbnN0IHQyID0gLXRoaXJkICogQSAtIChTICsgVCkgLyAyO1xuICAgICAgaWYgKHQyID49IDAgJiYgdDIgPD0gMSkge1xuICAgICAgICByb290cy5wdXNoKHQyKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgdGhldGEgPSBNYXRoLmFjb3MoUiAvIE1hdGguc3FydCgtUSAqIFEgKiBRKSk7XG4gICAgY29uc3QgdGhpcmRBID0gdGhpcmQgKiBBO1xuICAgIGNvbnN0IHR3b1NxcnRRID0gMiAqIE1hdGguc3FydCgtUSk7XG4gICAgY29uc3QgdDEgPSB0d29TcXJ0USAqIE1hdGguY29zKHRoaXJkICogdGhldGEpIC0gdGhpcmRBO1xuICAgIGNvbnN0IHQyID0gdHdvU3FydFEgKiBNYXRoLmNvcyh0aGlyZCAqICh0aGV0YSArIDIgKiBNYXRoLlBJKSkgLSB0aGlyZEE7XG4gICAgY29uc3QgdDMgPSB0d29TcXJ0USAqIE1hdGguY29zKHRoaXJkICogKHRoZXRhICsgNCAqIE1hdGguUEkpKSAtIHRoaXJkQTtcbiAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICByb290cy5wdXNoKHQxKTtcbiAgICB9XG4gICAgaWYgKHQyID49IDAgJiYgdDIgPD0gMSkge1xuICAgICAgcm9vdHMucHVzaCh0Mik7XG4gICAgfVxuICAgIGlmICh0MyA+PSAwICYmIHQzIDw9IDEpIHtcbiAgICAgIHJvb3RzLnB1c2godDMpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcm9vdHM7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL2ludGVyc2VjdGlvbi50c1xuZnVuY3Rpb24gc2VnbWVudEludGVyc2VjdGlvbihheDEsIGF5MSwgYXgyLCBheTIsIGJ4MSwgYnkxLCBieDIsIGJ5Mikge1xuICBjb25zdCBkID0gKGF4MiAtIGF4MSkgKiAoYnkyIC0gYnkxKSAtIChheTIgLSBheTEpICogKGJ4MiAtIGJ4MSk7XG4gIGlmIChkID09PSAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgY29uc3QgdWEgPSAoKGJ4MiAtIGJ4MSkgKiAoYXkxIC0gYnkxKSAtIChheDEgLSBieDEpICogKGJ5MiAtIGJ5MSkpIC8gZDtcbiAgY29uc3QgdWIgPSAoKGF4MiAtIGF4MSkgKiAoYXkxIC0gYnkxKSAtIChheTIgLSBheTEpICogKGF4MSAtIGJ4MSkpIC8gZDtcbiAgaWYgKHVhID49IDAgJiYgdWEgPD0gMSAmJiB1YiA+PSAwICYmIHViIDw9IDEpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIGN1YmljU2VnbWVudEludGVyc2VjdGlvbnMocHgxLCBweTEsIHB4MiwgcHkyLCBweDMsIHB5MywgcHg0LCBweTQsIHgxLCB5MSwgeDIsIHkyKSB7XG4gIGxldCBpbnRlcnNlY3Rpb25zID0gMDtcbiAgY29uc3QgQSA9IHkxIC0geTI7XG4gIGNvbnN0IEIgPSB4MiAtIHgxO1xuICBjb25zdCBDID0geDEgKiAoeTIgLSB5MSkgLSB5MSAqICh4MiAtIHgxKTtcbiAgY29uc3QgYnggPSBiZXppZXJDb2VmZmljaWVudHMocHgxLCBweDIsIHB4MywgcHg0KTtcbiAgY29uc3QgYnkgPSBiZXppZXJDb2VmZmljaWVudHMocHkxLCBweTIsIHB5MywgcHk0KTtcbiAgY29uc3QgYSA9IEEgKiBieFswXSArIEIgKiBieVswXTtcbiAgY29uc3QgYiA9IEEgKiBieFsxXSArIEIgKiBieVsxXTtcbiAgY29uc3QgYyA9IEEgKiBieFsyXSArIEIgKiBieVsyXTtcbiAgY29uc3QgZCA9IEEgKiBieFszXSArIEIgKiBieVszXSArIEM7XG4gIGNvbnN0IHJvb3RzID0gY3ViaWNSb290cyhhLCBiLCBjLCBkKTtcbiAgZm9yIChjb25zdCB0IG9mIHJvb3RzKSB7XG4gICAgY29uc3QgdHQgPSB0ICogdDtcbiAgICBjb25zdCB0dHQgPSB0ICogdHQ7XG4gICAgY29uc3QgeCA9IGJ4WzBdICogdHR0ICsgYnhbMV0gKiB0dCArIGJ4WzJdICogdCArIGJ4WzNdO1xuICAgIGNvbnN0IHkgPSBieVswXSAqIHR0dCArIGJ5WzFdICogdHQgKyBieVsyXSAqIHQgKyBieVszXTtcbiAgICBsZXQgcztcbiAgICBpZiAoeDEgPT09IHgyKSB7XG4gICAgICBzID0gKHkgLSB5MSkgLyAoeTIgLSB5MSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMgPSAoeCAtIHgxKSAvICh4MiAtIHgxKTtcbiAgICB9XG4gICAgaWYgKHMgPj0gMCAmJiBzIDw9IDEpIHtcbiAgICAgIGludGVyc2VjdGlvbnMrKztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGludGVyc2VjdGlvbnM7XG59XG5mdW5jdGlvbiBiZXppZXJDb2VmZmljaWVudHMoUDEsIFAyLCBQMywgUDQpIHtcbiAgcmV0dXJuIFtcbiAgICAvLyBCw6l6aWVyIGV4cHJlc3NlZCBhcyBtYXRyaXggb3BlcmF0aW9uczpcbiAgICAtUDEgKyAzICogUDIgLSAzICogUDMgKyBQNCxcbiAgICAvLyAgICAgICAgICAgICAgICAgfC0xICAzIC0zICAxfCB8UDF8XG4gICAgMyAqIFAxIC0gNiAqIFAyICsgMyAqIFAzLFxuICAgIC8vICAgW3ReMyB0XjIgdCAxXSB8IDMgLTYgIDMgIDB8IHxQMnxcbiAgICAtMyAqIFAxICsgMyAqIFAyLFxuICAgIC8vICAgICAgICAgICAgICAgICB8LTMgIDMgIDAgIDB8IHxQM3xcbiAgICBQMVxuICAgIC8vICAgICAgICAgICAgICAgICB8IDEgIDAgIDAgIDB8IHxQNHxcbiAgXTtcbn1cbmZ1bmN0aW9uIGFyY0ludGVyc2VjdGlvbnMoY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgY291bnRlckNsb2Nrd2lzZSwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgaWYgKGlzTmFOKGN4KSB8fCBpc05hTihjeSkpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAoY291bnRlckNsb2Nrd2lzZSkge1xuICAgIFtlbmRBbmdsZSwgc3RhcnRBbmdsZV0gPSBbc3RhcnRBbmdsZSwgZW5kQW5nbGVdO1xuICB9XG4gIGNvbnN0IGsgPSAoeTIgLSB5MSkgLyAoeDIgLSB4MSk7XG4gIGNvbnN0IHkwID0geTEgLSBrICogeDE7XG4gIGNvbnN0IGEgPSBNYXRoLnBvdyhrLCAyKSArIDE7XG4gIGNvbnN0IGIgPSAyICogKGsgKiAoeTAgLSBjeSkgLSBjeCk7XG4gIGNvbnN0IGMgPSBNYXRoLnBvdyhjeCwgMikgKyBNYXRoLnBvdyh5MCAtIGN5LCAyKSAtIE1hdGgucG93KHIsIDIpO1xuICBjb25zdCBkID0gTWF0aC5wb3coYiwgMikgLSA0ICogYSAqIGM7XG4gIGlmIChkIDwgMCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGNvbnN0IGkxeCA9ICgtYiArIE1hdGguc3FydChkKSkgLyAyIC8gYTtcbiAgY29uc3QgaTJ4ID0gKC1iIC0gTWF0aC5zcXJ0KGQpKSAvIDIgLyBhO1xuICBsZXQgaW50ZXJzZWN0aW9ucyA9IDA7XG4gIFtpMXgsIGkyeF0uZm9yRWFjaCgoeCkgPT4ge1xuICAgIGNvbnN0IGlzWEluc2lkZUxpbmUgPSB4ID49IE1hdGgubWluKHgxLCB4MikgJiYgeCA8PSBNYXRoLm1heCh4MSwgeDIpO1xuICAgIGlmICghaXNYSW5zaWRlTGluZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB5ID0gayAqIHggKyB5MDtcbiAgICBjb25zdCBhZGphY2VudCA9IHggLSBjeDtcbiAgICBjb25zdCBvcHBvc2l0ZSA9IHkgLSBjeTtcbiAgICBjb25zdCBhbmdsZTIgPSBNYXRoLmF0YW4yKG9wcG9zaXRlLCBhZGphY2VudCk7XG4gICAgaWYgKGlzQmV0d2VlbkFuZ2xlcyhhbmdsZTIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKSkge1xuICAgICAgaW50ZXJzZWN0aW9ucysrO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBpbnRlcnNlY3Rpb25zO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS91dGlsL2Jlemllci50c1xuZnVuY3Rpb24gZXZhbHVhdGVCZXppZXIocDAsIHAxLCBwMiwgcDMsIHQpIHtcbiAgcmV0dXJuICgxIC0gdCkgKiogMyAqIHAwICsgMyAqICgxIC0gdCkgKiogMiAqIHQgKiBwMSArIDMgKiAoMSAtIHQpICogdCAqKiAyICogcDIgKyB0ICoqIDMgKiBwMztcbn1cbmZ1bmN0aW9uIHNvbHZlQmV6aWVyKHAwLCBwMSwgcDIsIHAzLCB2YWx1ZSkge1xuICBpZiAodmFsdWUgPD0gTWF0aC5taW4ocDAsIHAzKSkge1xuICAgIHJldHVybiBwMCA8IHAzID8gMCA6IDE7XG4gIH0gZWxzZSBpZiAodmFsdWUgPj0gTWF0aC5tYXgocDAsIHAzKSkge1xuICAgIHJldHVybiBwMCA8IHAzID8gMSA6IDA7XG4gIH1cbiAgbGV0IHQwID0gMDtcbiAgbGV0IHQxID0gMTtcbiAgbGV0IHQgPSBOYU47XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMTI7IGkgKz0gMSkge1xuICAgIHQgPSAodDAgKyB0MSkgLyAyO1xuICAgIGNvbnN0IGN1cnZlVmFsdWUgPSBldmFsdWF0ZUJlemllcihwMCwgcDEsIHAyLCBwMywgdCk7XG4gICAgaWYgKGN1cnZlVmFsdWUgPCB2YWx1ZSkge1xuICAgICAgdDAgPSB0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0MSA9IHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gc3BsaXRCZXppZXIocDB4LCBwMHksIHAxeCwgcDF5LCBwMngsIHAyeSwgcDN4LCBwM3ksIHQpIHtcbiAgY29uc3QgeDAxID0gKDEgLSB0KSAqIHAweCArIHQgKiBwMXg7XG4gIGNvbnN0IHkwMSA9ICgxIC0gdCkgKiBwMHkgKyB0ICogcDF5O1xuICBjb25zdCB4MTIgPSAoMSAtIHQpICogcDF4ICsgdCAqIHAyeDtcbiAgY29uc3QgeTEyID0gKDEgLSB0KSAqIHAxeSArIHQgKiBwMnk7XG4gIGNvbnN0IHgyMyA9ICgxIC0gdCkgKiBwMnggKyB0ICogcDN4O1xuICBjb25zdCB5MjMgPSAoMSAtIHQpICogcDJ5ICsgdCAqIHAzeTtcbiAgY29uc3QgeDAxMiA9ICgxIC0gdCkgKiB4MDEgKyB0ICogeDEyO1xuICBjb25zdCB5MDEyID0gKDEgLSB0KSAqIHkwMSArIHQgKiB5MTI7XG4gIGNvbnN0IHgxMjMgPSAoMSAtIHQpICogeDEyICsgdCAqIHgyMztcbiAgY29uc3QgeTEyMyA9ICgxIC0gdCkgKiB5MTIgKyB0ICogeTIzO1xuICBjb25zdCB4MDEyMyA9ICgxIC0gdCkgKiB4MDEyICsgdCAqIHgxMjM7XG4gIGNvbnN0IHkwMTIzID0gKDEgLSB0KSAqIHkwMTIgKyB0ICogeTEyMztcbiAgcmV0dXJuIFtcbiAgICBbXG4gICAgICB7IHg6IHAweCwgeTogcDB5IH0sXG4gICAgICB7IHg6IHgwMSwgeTogeTAxIH0sXG4gICAgICB7IHg6IHgwMTIsIHk6IHkwMTIgfSxcbiAgICAgIHsgeDogeDAxMjMsIHk6IHkwMTIzIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIHsgeDogeDAxMjMsIHk6IHkwMTIzIH0sXG4gICAgICB7IHg6IHgxMjMsIHk6IHkxMjMgfSxcbiAgICAgIHsgeDogeDIzLCB5OiB5MjMgfSxcbiAgICAgIHsgeDogcDN4LCB5OiBwM3kgfVxuICAgIF1cbiAgXTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZURlcml2YXRpdmVFeHRyZW1hKHAwLCBwMSwgcDIsIHAzKSB7XG4gIGNvbnN0IGEgPSAtcDAgKyAzICogcDEgLSAzICogcDIgKyBwMztcbiAgY29uc3QgYiA9IDMgKiBwMCAtIDYgKiBwMSArIDMgKiBwMjtcbiAgY29uc3QgYyA9IC0zICogcDAgKyAzICogcDE7XG4gIGlmIChhID09PSAwKSB7XG4gICAgaWYgKGIgIT09IDApIHtcbiAgICAgIGNvbnN0IHQgPSAtYyAvIGI7XG4gICAgICBpZiAodCA+IDAgJiYgdCA8IDEpIHtcbiAgICAgICAgcmV0dXJuIFt0XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGNvbnN0IGRpc2NyaW1pbmFudCA9IGIgKiBiIC0gNCAqIGEgKiBjO1xuICBpZiAoZGlzY3JpbWluYW50ID49IDApIHtcbiAgICBjb25zdCBzcXJ0RGlzY3JpbWluYW50ID0gTWF0aC5zcXJ0KGRpc2NyaW1pbmFudCk7XG4gICAgY29uc3QgdDEgPSAoLWIgKyBzcXJ0RGlzY3JpbWluYW50KSAvICgyICogYSk7XG4gICAgY29uc3QgdDIgPSAoLWIgLSBzcXJ0RGlzY3JpbWluYW50KSAvICgyICogYSk7XG4gICAgcmV0dXJuIFt0MSwgdDJdLmZpbHRlcigodCkgPT4gdCA+IDAgJiYgdCA8IDEpO1xuICB9XG4gIHJldHVybiBbXTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZURlcml2YXRpdmVFeHRyZW1hWFkoc3gsIHN5LCBjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCB4LCB5KSB7XG4gIGNvbnN0IHR4ID0gY2FsY3VsYXRlRGVyaXZhdGl2ZUV4dHJlbWEoc3gsIGNwMXgsIGNwMngsIHgpO1xuICBjb25zdCB0eSA9IGNhbGN1bGF0ZURlcml2YXRpdmVFeHRyZW1hKHN5LCBjcDF5LCBjcDJ5LCB5KTtcbiAgcmV0dXJuIFsuLi50eCwgLi4udHldO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9leHRlbmRlZFBhdGgyRC50c1xudmFyIEV4dGVuZGVkUGF0aDJEID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvLyBUaGUgbWV0aG9kcyBvZiB0aGlzIGNsYXNzIHdpbGwgbGlrZWx5IGJlIGNhbGxlZCBtYW55IHRpbWVzIHBlciBhbmltYXRpb24gZnJhbWUsXG4gICAgLy8gYW5kIGFueSBhbGxvY2F0aW9uIGNhbiB0cmlnZ2VyIGEgR0MgY3ljbGUgZHVyaW5nIGFuaW1hdGlvbiwgc28gd2UgYXR0ZW1wdFxuICAgIC8vIHRvIG1pbmltaXplIHRoZSBudW1iZXIgb2YgYWxsb2NhdGlvbnMuXG4gICAgdGhpcy5wYXRoMmQgPSBuZXcgUGF0aDJEKCk7XG4gICAgdGhpcy5wcmV2aW91c0NvbW1hbmRzID0gW107XG4gICAgdGhpcy5wcmV2aW91c1BhcmFtcyA9IFtdO1xuICAgIHRoaXMucHJldmlvdXNDbG9zZWRQYXRoID0gZmFsc2U7XG4gICAgdGhpcy5jb21tYW5kcyA9IFtdO1xuICAgIHRoaXMucGFyYW1zID0gW107XG4gICAgdGhpcy5vcGVuZWRQYXRoID0gZmFsc2U7XG4gICAgdGhpcy5jbG9zZWRQYXRoID0gZmFsc2U7XG4gIH1cbiAgaXNEaXJ0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9zZWRQYXRoICE9PSB0aGlzLnByZXZpb3VzQ2xvc2VkUGF0aCB8fCB0aGlzLnByZXZpb3VzQ29tbWFuZHMubGVuZ3RoICE9PSB0aGlzLmNvbW1hbmRzLmxlbmd0aCB8fCB0aGlzLnByZXZpb3VzUGFyYW1zLmxlbmd0aCAhPT0gdGhpcy5wYXJhbXMubGVuZ3RoIHx8IHRoaXMucHJldmlvdXNDb21tYW5kcy50b1N0cmluZygpICE9PSB0aGlzLmNvbW1hbmRzLnRvU3RyaW5nKCkgfHwgdGhpcy5wcmV2aW91c1BhcmFtcy50b1N0cmluZygpICE9PSB0aGlzLnBhcmFtcy50b1N0cmluZygpO1xuICB9XG4gIGdldFBhdGgyRCgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXRoMmQ7XG4gIH1cbiAgbW92ZVRvKHgsIHkpIHtcbiAgICB0aGlzLm9wZW5lZFBhdGggPSB0cnVlO1xuICAgIHRoaXMucGF0aDJkLm1vdmVUbyh4LCB5KTtcbiAgICB0aGlzLmNvbW1hbmRzLnB1c2goMCAvKiBNb3ZlICovKTtcbiAgICB0aGlzLnBhcmFtcy5wdXNoKHgsIHkpO1xuICB9XG4gIGxpbmVUbyh4LCB5KSB7XG4gICAgaWYgKHRoaXMub3BlbmVkUGF0aCkge1xuICAgICAgdGhpcy5wYXRoMmQubGluZVRvKHgsIHkpO1xuICAgICAgdGhpcy5jb21tYW5kcy5wdXNoKDEgLyogTGluZSAqLyk7XG4gICAgICB0aGlzLnBhcmFtcy5wdXNoKHgsIHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1vdmVUbyh4LCB5KTtcbiAgICB9XG4gIH1cbiAgcmVjdCh4LCB5LCB3aWR0aDIsIGhlaWdodDIpIHtcbiAgICB0aGlzLm1vdmVUbyh4LCB5KTtcbiAgICB0aGlzLmxpbmVUbyh4ICsgd2lkdGgyLCB5KTtcbiAgICB0aGlzLmxpbmVUbyh4ICsgd2lkdGgyLCB5ICsgaGVpZ2h0Mik7XG4gICAgdGhpcy5saW5lVG8oeCwgeSArIGhlaWdodDIpO1xuICAgIHRoaXMuY2xvc2VQYXRoKCk7XG4gIH1cbiAgcm91bmRSZWN0KHgsIHksIHdpZHRoMiwgaGVpZ2h0MiwgcmFkaWkpIHtcbiAgICByYWRpaSA9IE1hdGgubWluKHJhZGlpLCB3aWR0aDIgLyAyLCBoZWlnaHQyIC8gMik7XG4gICAgdGhpcy5tb3ZlVG8oeCwgeSArIHJhZGlpKTtcbiAgICB0aGlzLmFyYyh4ICsgcmFkaWksIHkgKyByYWRpaSwgcmFkaWksIE1hdGguUEksIDEuNSAqIE1hdGguUEkpO1xuICAgIHRoaXMubGluZVRvKHggKyByYWRpaSwgeSk7XG4gICAgdGhpcy5saW5lVG8oeCArIHdpZHRoMiAtIHJhZGlpLCB5KTtcbiAgICB0aGlzLmFyYyh4ICsgd2lkdGgyIC0gcmFkaWksIHkgKyByYWRpaSwgcmFkaWksIDEuNSAqIE1hdGguUEksIDIgKiBNYXRoLlBJKTtcbiAgICB0aGlzLmxpbmVUbyh4ICsgd2lkdGgyLCB5ICsgcmFkaWkpO1xuICAgIHRoaXMubGluZVRvKHggKyB3aWR0aDIsIHkgKyBoZWlnaHQyIC0gcmFkaWkpO1xuICAgIHRoaXMuYXJjKHggKyB3aWR0aDIgLSByYWRpaSwgeSArIGhlaWdodDIgLSByYWRpaSwgcmFkaWksIDAsIE1hdGguUEkgLyAyKTtcbiAgICB0aGlzLmxpbmVUbyh4ICsgd2lkdGgyIC0gcmFkaWksIHkgKyBoZWlnaHQyKTtcbiAgICB0aGlzLmxpbmVUbyh4ICsgcmFkaWksIHkgKyBoZWlnaHQyKTtcbiAgICB0aGlzLmFyYyh4ICsgK3JhZGlpLCB5ICsgaGVpZ2h0MiAtIHJhZGlpLCByYWRpaSwgTWF0aC5QSSAvIDIsIE1hdGguUEkpO1xuICAgIHRoaXMubGluZVRvKHgsIHkgKyBoZWlnaHQyIC0gcmFkaWkpO1xuICAgIHRoaXMuY2xvc2VQYXRoKCk7XG4gIH1cbiAgYXJjKHgsIHksIHIsIHNBbmdsZSwgZUFuZ2xlLCBjb3VudGVyQ2xvY2t3aXNlKSB7XG4gICAgdGhpcy5vcGVuZWRQYXRoID0gdHJ1ZTtcbiAgICB0aGlzLnBhdGgyZC5hcmMoeCwgeSwgciwgc0FuZ2xlLCBlQW5nbGUsIGNvdW50ZXJDbG9ja3dpc2UpO1xuICAgIHRoaXMuY29tbWFuZHMucHVzaCgyIC8qIEFyYyAqLyk7XG4gICAgdGhpcy5wYXJhbXMucHVzaCh4LCB5LCByLCBzQW5nbGUsIGVBbmdsZSwgY291bnRlckNsb2Nrd2lzZSA/IDEgOiAwKTtcbiAgfVxuICBjdWJpY0N1cnZlVG8oY3gxLCBjeTEsIGN4MiwgY3kyLCB4LCB5KSB7XG4gICAgaWYgKCF0aGlzLm9wZW5lZFBhdGgpIHtcbiAgICAgIHRoaXMubW92ZVRvKGN4MSwgY3kxKTtcbiAgICB9XG4gICAgdGhpcy5wYXRoMmQuYmV6aWVyQ3VydmVUbyhjeDEsIGN5MSwgY3gyLCBjeTIsIHgsIHkpO1xuICAgIHRoaXMuY29tbWFuZHMucHVzaCgzIC8qIEN1cnZlICovKTtcbiAgICB0aGlzLnBhcmFtcy5wdXNoKGN4MSwgY3kxLCBjeDIsIGN5MiwgeCwgeSk7XG4gIH1cbiAgY2xvc2VQYXRoKCkge1xuICAgIGlmICh0aGlzLm9wZW5lZFBhdGgpIHtcbiAgICAgIHRoaXMucGF0aDJkLmNsb3NlUGF0aCgpO1xuICAgICAgdGhpcy5jb21tYW5kcy5wdXNoKDQgLyogQ2xvc2VQYXRoICovKTtcbiAgICAgIHRoaXMub3BlbmVkUGF0aCA9IGZhbHNlO1xuICAgICAgdGhpcy5jbG9zZWRQYXRoID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgY2xlYXIodHJhY2tDaGFuZ2VzKSB7XG4gICAgaWYgKHRyYWNrQ2hhbmdlcykge1xuICAgICAgdGhpcy5wcmV2aW91c0NvbW1hbmRzID0gdGhpcy5jb21tYW5kcztcbiAgICAgIHRoaXMucHJldmlvdXNQYXJhbXMgPSB0aGlzLnBhcmFtcztcbiAgICAgIHRoaXMucHJldmlvdXNDbG9zZWRQYXRoID0gdGhpcy5jbG9zZWRQYXRoO1xuICAgIH1cbiAgICB0aGlzLnBhdGgyZCA9IG5ldyBQYXRoMkQoKTtcbiAgICB0aGlzLm9wZW5lZFBhdGggPSBmYWxzZTtcbiAgICB0aGlzLmNsb3NlZFBhdGggPSBmYWxzZTtcbiAgICB0aGlzLmNvbW1hbmRzID0gW107XG4gICAgdGhpcy5wYXJhbXMgPSBbXTtcbiAgfVxuICBpc1BvaW50SW5QYXRoKHgsIHkpIHtcbiAgICBjb25zdCBjb21tYW5kcyA9IHRoaXMuY29tbWFuZHM7XG4gICAgY29uc3QgcGFyYW1zID0gdGhpcy5wYXJhbXM7XG4gICAgY29uc3QgY24gPSBjb21tYW5kcy5sZW5ndGg7XG4gICAgY29uc3Qgb3ggPSAtMWU0O1xuICAgIGNvbnN0IG95ID0gLTFlNDtcbiAgICBsZXQgc3ggPSBOYU47XG4gICAgbGV0IHN5ID0gTmFOO1xuICAgIGxldCBweCA9IDA7XG4gICAgbGV0IHB5ID0gMDtcbiAgICBsZXQgaW50ZXJzZWN0aW9uQ291bnQgPSAwO1xuICAgIGZvciAobGV0IGNpID0gMCwgcGkgPSAwOyBjaSA8IGNuOyBjaSsrKSB7XG4gICAgICBzd2l0Y2ggKGNvbW1hbmRzW2NpXSkge1xuICAgICAgICBjYXNlIDAgLyogTW92ZSAqLzpcbiAgICAgICAgICBpbnRlcnNlY3Rpb25Db3VudCArPSBzZWdtZW50SW50ZXJzZWN0aW9uKHN4LCBzeSwgcHgsIHB5LCBveCwgb3ksIHgsIHkpO1xuICAgICAgICAgIHB4ID0gcGFyYW1zW3BpKytdO1xuICAgICAgICAgIHN4ID0gcHg7XG4gICAgICAgICAgcHkgPSBwYXJhbXNbcGkrK107XG4gICAgICAgICAgc3kgPSBweTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxIC8qIExpbmUgKi86XG4gICAgICAgICAgaW50ZXJzZWN0aW9uQ291bnQgKz0gc2VnbWVudEludGVyc2VjdGlvbihweCwgcHksIHBhcmFtc1twaSsrXSwgcGFyYW1zW3BpKytdLCBveCwgb3ksIHgsIHkpO1xuICAgICAgICAgIHB4ID0gcGFyYW1zW3BpIC0gMl07XG4gICAgICAgICAgcHkgPSBwYXJhbXNbcGkgLSAxXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzIC8qIEN1cnZlICovOlxuICAgICAgICAgIGludGVyc2VjdGlvbkNvdW50ICs9IGN1YmljU2VnbWVudEludGVyc2VjdGlvbnMoXG4gICAgICAgICAgICBweCxcbiAgICAgICAgICAgIHB5LFxuICAgICAgICAgICAgcGFyYW1zW3BpKytdLFxuICAgICAgICAgICAgcGFyYW1zW3BpKytdLFxuICAgICAgICAgICAgcGFyYW1zW3BpKytdLFxuICAgICAgICAgICAgcGFyYW1zW3BpKytdLFxuICAgICAgICAgICAgcGFyYW1zW3BpKytdLFxuICAgICAgICAgICAgcGFyYW1zW3BpKytdLFxuICAgICAgICAgICAgb3gsXG4gICAgICAgICAgICBveSxcbiAgICAgICAgICAgIHgsXG4gICAgICAgICAgICB5XG4gICAgICAgICAgKTtcbiAgICAgICAgICBweCA9IHBhcmFtc1twaSAtIDJdO1xuICAgICAgICAgIHB5ID0gcGFyYW1zW3BpIC0gMV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMiAvKiBBcmMgKi86IHtcbiAgICAgICAgICBjb25zdCBjeCA9IHBhcmFtc1twaSsrXTtcbiAgICAgICAgICBjb25zdCBjeSA9IHBhcmFtc1twaSsrXTtcbiAgICAgICAgICBjb25zdCByID0gcGFyYW1zW3BpKytdO1xuICAgICAgICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSBwYXJhbXNbcGkrK107XG4gICAgICAgICAgY29uc3QgZW5kQW5nbGUgPSBwYXJhbXNbcGkrK107XG4gICAgICAgICAgY29uc3QgY291bnRlckNsb2Nrd2lzZSA9IEJvb2xlYW4ocGFyYW1zW3BpKytdKTtcbiAgICAgICAgICBpbnRlcnNlY3Rpb25Db3VudCArPSBhcmNJbnRlcnNlY3Rpb25zKFxuICAgICAgICAgICAgY3gsXG4gICAgICAgICAgICBjeSxcbiAgICAgICAgICAgIHIsXG4gICAgICAgICAgICBzdGFydEFuZ2xlLFxuICAgICAgICAgICAgZW5kQW5nbGUsXG4gICAgICAgICAgICBjb3VudGVyQ2xvY2t3aXNlLFxuICAgICAgICAgICAgb3gsXG4gICAgICAgICAgICBveSxcbiAgICAgICAgICAgIHgsXG4gICAgICAgICAgICB5XG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoIWlzTmFOKHN4KSkge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRYID0gY3ggKyBNYXRoLmNvcyhzdGFydEFuZ2xlKSAqIHI7XG4gICAgICAgICAgICBjb25zdCBzdGFydFkgPSBjeSArIE1hdGguc2luKHN0YXJ0QW5nbGUpICogcjtcbiAgICAgICAgICAgIGludGVyc2VjdGlvbkNvdW50ICs9IHNlZ21lbnRJbnRlcnNlY3Rpb24ocHgsIHB5LCBzdGFydFgsIHN0YXJ0WSwgb3gsIG95LCB4LCB5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHggPSBjeCArIE1hdGguY29zKGVuZEFuZ2xlKSAqIHI7XG4gICAgICAgICAgcHkgPSBjeSArIE1hdGguc2luKGVuZEFuZ2xlKSAqIHI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSA0IC8qIENsb3NlUGF0aCAqLzpcbiAgICAgICAgICBpbnRlcnNlY3Rpb25Db3VudCArPSBzZWdtZW50SW50ZXJzZWN0aW9uKHN4LCBzeSwgcHgsIHB5LCBveCwgb3ksIHgsIHkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW50ZXJzZWN0aW9uQ291bnQgJSAyID09PSAxO1xuICB9XG4gIGRpc3RhbmNlU3F1YXJlZCh4LCB5KSB7XG4gICAgbGV0IGJlc3QgPSBJbmZpbml0eTtcbiAgICBjb25zdCBjb21tYW5kcyA9IHRoaXMuY29tbWFuZHM7XG4gICAgY29uc3QgcGFyYW1zID0gdGhpcy5wYXJhbXM7XG4gICAgY29uc3QgY24gPSBjb21tYW5kcy5sZW5ndGg7XG4gICAgbGV0IHN4ID0gTmFOO1xuICAgIGxldCBzeSA9IE5hTjtcbiAgICBsZXQgcHggPSAwO1xuICAgIGxldCBweSA9IDA7XG4gICAgZm9yIChsZXQgY2kgPSAwLCBwaSA9IDA7IGNpIDwgY247IGNpKyspIHtcbiAgICAgIHN3aXRjaCAoY29tbWFuZHNbY2ldKSB7XG4gICAgICAgIGNhc2UgMCAvKiBNb3ZlICovOlxuICAgICAgICAgIHB4ID0gc3ggPSBwYXJhbXNbcGkrK107XG4gICAgICAgICAgcHkgPSBzeSA9IHBhcmFtc1twaSsrXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxIC8qIExpbmUgKi86IHtcbiAgICAgICAgICBjb25zdCBueCA9IHBhcmFtc1twaSsrXTtcbiAgICAgICAgICBjb25zdCBueSA9IHBhcmFtc1twaSsrXTtcbiAgICAgICAgICBiZXN0ID0gbGluZURpc3RhbmNlU3F1YXJlZCh4LCB5LCBweCwgcHksIG54LCBueSwgYmVzdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAzIC8qIEN1cnZlICovOlxuICAgICAgICAgIExvZ2dlci5lcnJvcihcIkNvbW1hbmQuQ3VydmUgZGlzdGFuY2VTcXVhcmUgbm90IGltcGxlbWVudGVkXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIgLyogQXJjICovOiB7XG4gICAgICAgICAgY29uc3QgY3ggPSBwYXJhbXNbcGkrK107XG4gICAgICAgICAgY29uc3QgY3kgPSBwYXJhbXNbcGkrK107XG4gICAgICAgICAgY29uc3QgciA9IHBhcmFtc1twaSsrXTtcbiAgICAgICAgICBjb25zdCBzdGFydEFuZ2xlID0gcGFyYW1zW3BpKytdO1xuICAgICAgICAgIGNvbnN0IGVuZEFuZ2xlID0gcGFyYW1zW3BpKytdO1xuICAgICAgICAgIGNvbnN0IHN0YXJ0WCA9IGN4ICsgTWF0aC5jb3Moc3RhcnRBbmdsZSkgKiByO1xuICAgICAgICAgIGNvbnN0IHN0YXJ0WSA9IGN5ICsgTWF0aC5zaW4oc3RhcnRBbmdsZSkgKiByO1xuICAgICAgICAgIGNvbnN0IGNvdW50ZXJDbG9ja3dpc2UgPSBCb29sZWFuKHBhcmFtc1twaSsrXSk7XG4gICAgICAgICAgYmVzdCA9IGxpbmVEaXN0YW5jZVNxdWFyZWQoeCwgeSwgcHgsIHB5LCBzdGFydFgsIHN0YXJ0WSwgYmVzdCk7XG4gICAgICAgICAgYmVzdCA9IGFyY0Rpc3RhbmNlU3F1YXJlZCh4LCB5LCBjeCwgY3ksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBjb3VudGVyQ2xvY2t3aXNlLCBiZXN0KTtcbiAgICAgICAgICBweCA9IGN4ICsgTWF0aC5jb3MoZW5kQW5nbGUpICogcjtcbiAgICAgICAgICBweSA9IGN5ICsgTWF0aC5zaW4oZW5kQW5nbGUpICogcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDQgLyogQ2xvc2VQYXRoICovOlxuICAgICAgICAgIGJlc3QgPSBsaW5lRGlzdGFuY2VTcXVhcmVkKHgsIHksIHB4LCBweSwgc3gsIHN5LCBiZXN0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJlc3Q7XG4gIH1cbiAgZ2V0UG9pbnRzKCkge1xuICAgIGNvbnN0IHsgY29tbWFuZHMsIHBhcmFtcyB9ID0gdGhpcztcbiAgICBjb25zdCBjb29yZHMgPSBbXTtcbiAgICBsZXQgcGkgPSAwO1xuICAgIGZvciAoY29uc3QgY29tbWFuZCBvZiBjb21tYW5kcykge1xuICAgICAgc3dpdGNoIChjb21tYW5kKSB7XG4gICAgICAgIGNhc2UgMCAvKiBNb3ZlICovOlxuICAgICAgICBjYXNlIDEgLyogTGluZSAqLzpcbiAgICAgICAgICBjb29yZHMucHVzaCh7IHg6IHBhcmFtc1twaSsrXSwgeTogcGFyYW1zW3BpKytdIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDMgLyogQ3VydmUgKi86XG4gICAgICAgICAgcGkgKz0gNDtcbiAgICAgICAgICBjb29yZHMucHVzaCh7IHg6IHBhcmFtc1twaSsrXSwgeTogcGFyYW1zW3BpKytdIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIgLyogQXJjICovOlxuICAgICAgICAgIGNvb3Jkcy5wdXNoKHsgeDogcGFyYW1zW3BpKytdLCB5OiBwYXJhbXNbcGkrK10gfSk7XG4gICAgICAgICAgcGkgKz0gNDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0IC8qIENsb3NlUGF0aCAqLzpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvb3JkcztcbiAgfVxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL2RcbiAgdG9TVkcodHJhbnNmb3JtID0gKHgsIHkpID0+ICh7IHgsIHkgfSkpIHtcbiAgICBjb25zdCBidWZmZXIgPSBbXTtcbiAgICBjb25zdCB7IGNvbW1hbmRzLCBwYXJhbXMgfSA9IHRoaXM7XG4gICAgY29uc3QgYWRkQ29tbWFuZCA9IChjb21tYW5kLCAuLi5wb2ludHMpID0+IHtcbiAgICAgIGJ1ZmZlci5wdXNoKGNvbW1hbmQpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgY29uc3QgeyB4LCB5IH0gPSB0cmFuc2Zvcm0ocG9pbnRzW2ldLCBwb2ludHNbaSArIDFdKTtcbiAgICAgICAgYnVmZmVyLnB1c2goeCwgeSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBsZXQgcGkgPSAwO1xuICAgIGZvciAoY29uc3QgY29tbWFuZCBvZiBjb21tYW5kcykge1xuICAgICAgc3dpdGNoIChjb21tYW5kKSB7XG4gICAgICAgIGNhc2UgMCAvKiBNb3ZlICovOlxuICAgICAgICAgIGFkZENvbW1hbmQoXCJNXCIsIHBhcmFtc1twaSsrXSwgcGFyYW1zW3BpKytdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxIC8qIExpbmUgKi86XG4gICAgICAgICAgYWRkQ29tbWFuZChcIkxcIiwgcGFyYW1zW3BpKytdLCBwYXJhbXNbcGkrK10pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDMgLyogQ3VydmUgKi86XG4gICAgICAgICAgYWRkQ29tbWFuZChcIkNcIiwgcGFyYW1zW3BpKytdLCBwYXJhbXNbcGkrK10sIHBhcmFtc1twaSsrXSwgcGFyYW1zW3BpKytdLCBwYXJhbXNbcGkrK10sIHBhcmFtc1twaSsrXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMiAvKiBBcmMgKi86IHtcbiAgICAgICAgICBjb25zdCBjeCA9IHBhcmFtc1twaSsrXTtcbiAgICAgICAgICBjb25zdCBjeSA9IHBhcmFtc1twaSsrXTtcbiAgICAgICAgICBjb25zdCByID0gcGFyYW1zW3BpKytdO1xuICAgICAgICAgIGNvbnN0IEEwID0gcGFyYW1zW3BpKytdO1xuICAgICAgICAgIGNvbnN0IEExID0gcGFyYW1zW3BpKytdO1xuICAgICAgICAgIGNvbnN0IGNjdyA9IHBhcmFtc1twaSsrXTtcbiAgICAgICAgICBsZXQgc3dlZXAgPSBjY3cgPyBBMCAtIEExIDogQTEgLSBBMDtcbiAgICAgICAgICBpZiAoc3dlZXAgPCAwKSB7XG4gICAgICAgICAgICBzd2VlcCArPSBNYXRoLmNlaWwoLXN3ZWVwIC8gKDIgKiBNYXRoLlBJKSkgKiAyICogTWF0aC5QSTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNjdykge1xuICAgICAgICAgICAgc3dlZXAgPSAtc3dlZXA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGFyY1NlY3Rpb25zID0gTWF0aC5tYXgoTWF0aC5jZWlsKE1hdGguYWJzKHN3ZWVwKSAvIChNYXRoLlBJIC8gMikpLCAxKTtcbiAgICAgICAgICBjb25zdCBzdGVwID0gc3dlZXAgLyBhcmNTZWN0aW9ucztcbiAgICAgICAgICBjb25zdCBoID0gNCAvIDMgKiBNYXRoLnRhbihzdGVwIC8gNCk7XG4gICAgICAgICAgY29uc3QgbW92ZSA9IGJ1ZmZlci5sZW5ndGggPT09IDAgPyBcIk1cIiA6IFwiTFwiO1xuICAgICAgICAgIGFkZENvbW1hbmQobW92ZSwgY3ggKyBNYXRoLmNvcyhBMCkgKiByLCBjeSArIE1hdGguc2luKEEwKSAqIHIpO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJjU2VjdGlvbnM7IGkgKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgYTAgPSBBMCArIHN0ZXAgKiAoaSArIDApO1xuICAgICAgICAgICAgY29uc3QgYTEgPSBBMCArIHN0ZXAgKiAoaSArIDEpO1xuICAgICAgICAgICAgY29uc3QgclNpblN0YXJ0ID0gciAqIE1hdGguc2luKGEwKTtcbiAgICAgICAgICAgIGNvbnN0IHJDb3NTdGFydCA9IHIgKiBNYXRoLmNvcyhhMCk7XG4gICAgICAgICAgICBjb25zdCByU2luRW5kID0gciAqIE1hdGguc2luKGExKTtcbiAgICAgICAgICAgIGNvbnN0IHJDb3NFbmQgPSByICogTWF0aC5jb3MoYTEpO1xuICAgICAgICAgICAgYWRkQ29tbWFuZChcbiAgICAgICAgICAgICAgXCJDXCIsXG4gICAgICAgICAgICAgIGN4ICsgckNvc1N0YXJ0IC0gaCAqIHJTaW5TdGFydCxcbiAgICAgICAgICAgICAgY3kgKyByU2luU3RhcnQgKyBoICogckNvc1N0YXJ0LFxuICAgICAgICAgICAgICBjeCArIHJDb3NFbmQgKyBoICogclNpbkVuZCxcbiAgICAgICAgICAgICAgY3kgKyByU2luRW5kIC0gaCAqIHJDb3NFbmQsXG4gICAgICAgICAgICAgIGN4ICsgckNvc0VuZCxcbiAgICAgICAgICAgICAgY3kgKyByU2luRW5kXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDQgLyogQ2xvc2VQYXRoICovOlxuICAgICAgICAgIGJ1ZmZlci5wdXNoKFwiWlwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlci5qb2luKFwiIFwiKTtcbiAgfVxuICBjb21wdXRlQkJveCgpIHtcbiAgICBjb25zdCB7IGNvbW1hbmRzLCBwYXJhbXMgfSA9IHRoaXM7XG4gICAgbGV0IFt0b3AsIGxlZnQsIHJpZ2h0LCBib3RdID0gW0luZmluaXR5LCBJbmZpbml0eSwgLUluZmluaXR5LCAtSW5maW5pdHldO1xuICAgIGxldCBbc3gsIHN5XSA9IFtOYU4sIE5hTl07XG4gICAgbGV0IFtteCwgbXldID0gW05hTiwgTmFOXTtcbiAgICBjb25zdCBqb2luUG9pbnQgPSAoeCwgeSwgdXBkYXRlc3RhcnQpID0+IHtcbiAgICAgIHRvcCA9IE1hdGgubWluKHksIHRvcCk7XG4gICAgICBsZWZ0ID0gTWF0aC5taW4oeCwgbGVmdCk7XG4gICAgICByaWdodCA9IE1hdGgubWF4KHgsIHJpZ2h0KTtcbiAgICAgIGJvdCA9IE1hdGgubWF4KHksIGJvdCk7XG4gICAgICBpZiAodXBkYXRlc3RhcnQpIHtcbiAgICAgICAgW3N4LCBzeV0gPSBbeCwgeV07XG4gICAgICB9XG4gICAgfTtcbiAgICBsZXQgcGkgPSAwO1xuICAgIGZvciAoY29uc3QgY29tbWFuZCBvZiBjb21tYW5kcykge1xuICAgICAgc3dpdGNoIChjb21tYW5kKSB7XG4gICAgICAgIGNhc2UgMCAvKiBNb3ZlICovOlxuICAgICAgICAgIGpvaW5Qb2ludChwYXJhbXNbcGkrK10sIHBhcmFtc1twaSsrXSwgdHJ1ZSk7XG4gICAgICAgICAgW214LCBteV0gPSBbc3gsIHN5XTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxIC8qIExpbmUgKi86XG4gICAgICAgICAgam9pblBvaW50KHBhcmFtc1twaSsrXSwgcGFyYW1zW3BpKytdLCB0cnVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzIC8qIEN1cnZlICovOiB7XG4gICAgICAgICAgY29uc3QgY3AxeCA9IHBhcmFtc1twaSsrXTtcbiAgICAgICAgICBjb25zdCBjcDF5ID0gcGFyYW1zW3BpKytdO1xuICAgICAgICAgIGNvbnN0IGNwMnggPSBwYXJhbXNbcGkrK107XG4gICAgICAgICAgY29uc3QgY3AyeSA9IHBhcmFtc1twaSsrXTtcbiAgICAgICAgICBjb25zdCB4ID0gcGFyYW1zW3BpKytdO1xuICAgICAgICAgIGNvbnN0IHkgPSBwYXJhbXNbcGkrK107XG4gICAgICAgICAgam9pblBvaW50KHgsIHksIHRydWUpO1xuICAgICAgICAgIGNvbnN0IFRzID0gY2FsY3VsYXRlRGVyaXZhdGl2ZUV4dHJlbWFYWShzeCwgc3ksIGNwMXgsIGNwMXksIGNwMngsIGNwMnksIHgsIHkpO1xuICAgICAgICAgIFRzLmZvckVhY2goKHQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHB4ID0gZXZhbHVhdGVCZXppZXIoc3gsIGNwMXgsIGNwMngsIHgsIHQpO1xuICAgICAgICAgICAgY29uc3QgcHkgPSBldmFsdWF0ZUJlemllcihzeSwgY3AxeSwgY3AyeSwgeSwgdCk7XG4gICAgICAgICAgICBqb2luUG9pbnQocHgsIHB5KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDIgLyogQXJjICovOiB7XG4gICAgICAgICAgY29uc3QgY3ggPSBwYXJhbXNbcGkrK107XG4gICAgICAgICAgY29uc3QgY3kgPSBwYXJhbXNbcGkrK107XG4gICAgICAgICAgY29uc3QgciA9IHBhcmFtc1twaSsrXTtcbiAgICAgICAgICBsZXQgQTAgPSBub3JtYWxpemVBbmdsZTM2MChwYXJhbXNbcGkrK10pO1xuICAgICAgICAgIGxldCBBMSA9IG5vcm1hbGl6ZUFuZ2xlMzYwKHBhcmFtc1twaSsrXSk7XG4gICAgICAgICAgY29uc3QgY2N3ID0gcGFyYW1zW3BpKytdO1xuICAgICAgICAgIGlmIChjY3cpIHtcbiAgICAgICAgICAgIFtBMCwgQTFdID0gW0ExLCBBMF07XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGpvaW5BbmdsZSA9IChhbmdsZTIsIHVwZGF0ZXN0YXJ0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBweCA9IGN4ICsgciAqIE1hdGguY29zKGFuZ2xlMik7XG4gICAgICAgICAgICBjb25zdCBweSA9IGN5ICsgciAqIE1hdGguc2luKGFuZ2xlMik7XG4gICAgICAgICAgICBqb2luUG9pbnQocHgsIHB5LCB1cGRhdGVzdGFydCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBqb2luQW5nbGUoQTApO1xuICAgICAgICAgIGpvaW5BbmdsZShBMSwgdHJ1ZSk7XG4gICAgICAgICAgY29uc3QgY3JpdGljYWxBbmdsZXMgPSBbMCwgTWF0aC5QSSAvIDIsIE1hdGguUEksIDMgKiBNYXRoLlBJIC8gMl07XG4gICAgICAgICAgZm9yIChjb25zdCBjcml0IG9mIGNyaXRpY2FsQW5nbGVzKSB7XG4gICAgICAgICAgICBpZiAoQTAgPCBBMSAmJiBBMCA8PSBjcml0ICYmIGNyaXQgPD0gQTEgfHwgQTAgPiBBMSAmJiAoQTAgPD0gY3JpdCB8fCBjcml0IDw9IEExKSkge1xuICAgICAgICAgICAgICBqb2luQW5nbGUoY3JpdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgNCAvKiBDbG9zZVBhdGggKi86XG4gICAgICAgICAgW3N4LCBzeV0gPSBbbXgsIG15XTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCQm94KGxlZnQsIHRvcCwgcmlnaHQgLSBsZWZ0LCBib3QgLSB0b3ApO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9zaGFwZS9wYXRoLnRzXG5mdW5jdGlvbiBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24ob3B0cykge1xuICBjb25zdCB7IHJlZHJhdyA9IDMgLyogTUFKT1IgKi8sIGNoYW5nZUNiLCBjb252ZXJ0b3IgfSA9IG9wdHMgPz8ge307XG4gIHJldHVybiBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdywgdHlwZTogXCJwYXRoXCIsIGNvbnZlcnRvciwgY2hhbmdlQ2IgfSk7XG59XG52YXIgUGF0aCA9IGNsYXNzIGV4dGVuZHMgU2hhcGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIC8qKlxuICAgICAqIERlY2xhcmUgYSBwYXRoIHRvIHJldGFpbiBmb3IgbGF0ZXIgcmVuZGVyaW5nIGFuZCBoaXQgdGVzdGluZ1xuICAgICAqIHVzaW5nIGN1c3RvbSBQYXRoMkQgY2xhc3MuIFRoaW5rIG9mIGl0IGFzIGEgVHlwZVNjcmlwdCB2ZXJzaW9uXG4gICAgICogb2YgdGhlIG5hdGl2ZSBQYXRoMkQgKHdpdGggc29tZSBkaWZmZXJlbmNlcykgdGhhdCB3b3JrcyBpbiBhbGwgYnJvd3NlcnMuXG4gICAgICovXG4gICAgdGhpcy5wYXRoID0gbmV3IEV4dGVuZGVkUGF0aDJEKCk7XG4gICAgdGhpcy5fY2xpcFggPSBOYU47XG4gICAgdGhpcy5fY2xpcFkgPSBOYU47XG4gICAgdGhpcy5jbGlwID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogVGhlIHBhdGggb25seSBoYXMgdG8gYmUgdXBkYXRlZCB3aGVuIGNlcnRhaW4gYXR0cmlidXRlcyBjaGFuZ2UuXG4gICAgICogRm9yIGV4YW1wbGUsIGlmIHRyYW5zZm9ybSBhdHRyaWJ1dGVzIChzdWNoIGFzIGB0cmFuc2xhdGlvblhgKVxuICAgICAqIGFyZSBjaGFuZ2VkLCB3ZSBkb24ndCBoYXZlIHRvIHVwZGF0ZSB0aGUgcGF0aC4gVGhlIGBkaXJ0eVBhdGhgIGZsYWdcbiAgICAgKiBpcyBob3cgd2Uga2VlcCB0cmFjayBpZiB0aGUgcGF0aCBoYXMgdG8gYmUgdXBkYXRlZCBvciBub3QuXG4gICAgICovXG4gICAgdGhpcy5fZGlydHlQYXRoID0gdHJ1ZTtcbiAgfVxuICBzZXQgY2xpcFgodmFsdWUpIHtcbiAgICB0aGlzLl9jbGlwWCA9IHZhbHVlO1xuICAgIHRoaXMuZGlydHlQYXRoID0gdHJ1ZTtcbiAgfVxuICBzZXQgY2xpcFkodmFsdWUpIHtcbiAgICB0aGlzLl9jbGlwWSA9IHZhbHVlO1xuICAgIHRoaXMuZGlydHlQYXRoID0gdHJ1ZTtcbiAgfVxuICBzZXQgZGlydHlQYXRoKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX2RpcnR5UGF0aCAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuX2RpcnR5UGF0aCA9IHZhbHVlO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRoaXMubWFya0RpcnR5KDMgLyogTUFKT1IgKi8pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQgZGlydHlQYXRoKCkge1xuICAgIHJldHVybiB0aGlzLl9kaXJ0eVBhdGg7XG4gIH1cbiAgY2hlY2tQYXRoRGlydHkoKSB7XG4gICAgaWYgKHRoaXMuX2RpcnR5UGF0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmRpcnR5UGF0aCA9IHRoaXMucGF0aC5pc0RpcnR5KCkgfHwgKHRoaXMuZmlsbFNoYWRvdz8uaXNEaXJ0eSgpID8/IGZhbHNlKSB8fCAodGhpcy5fY2xpcFBhdGg/LmlzRGlydHkoKSA/PyBmYWxzZSk7XG4gIH1cbiAgaXNQb2ludEluUGF0aCh4LCB5KSB7XG4gICAgdGhpcy51cGRhdGVQYXRoSWZEaXJ0eSgpO1xuICAgIHJldHVybiB0aGlzLnBhdGguY2xvc2VkUGF0aCAmJiB0aGlzLnBhdGguaXNQb2ludEluUGF0aCh4LCB5KTtcbiAgfVxuICBkaXN0YW5jZVNxdWFyZWQoeCwgeSkge1xuICAgIHJldHVybiB0aGlzLmRpc3RhbmNlU3F1YXJlZFRyYW5zZm9ybWVkUG9pbnQoeCwgeSk7XG4gIH1cbiAgc3ZnUGF0aERhdGEodHJhbnNmb3JtKSB7XG4gICAgaWYgKHRoaXMuZGlydHlQYXRoKSB7XG4gICAgICB0aGlzLnVwZGF0ZVBhdGgoKTtcbiAgICAgIHRoaXMuZGlydHlQYXRoID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhdGgudG9TVkcodHJhbnNmb3JtKTtcbiAgfVxuICBkaXN0YW5jZVNxdWFyZWRUcmFuc2Zvcm1lZFBvaW50KHgsIHkpIHtcbiAgICB0aGlzLnVwZGF0ZVBhdGhJZkRpcnR5KCk7XG4gICAgaWYgKHRoaXMucGF0aC5jbG9zZWRQYXRoICYmIHRoaXMucGF0aC5pc1BvaW50SW5QYXRoKHgsIHkpKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGF0aC5kaXN0YW5jZVNxdWFyZWQoeCwgeSk7XG4gIH1cbiAgaXNEaXJ0eVBhdGgoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHVwZGF0ZVBhdGgoKSB7XG4gIH1cbiAgdXBkYXRlUGF0aElmRGlydHkoKSB7XG4gICAgaWYgKHRoaXMuZGlydHlQYXRoIHx8IHRoaXMuaXNEaXJ0eVBhdGgoKSkge1xuICAgICAgdGhpcy51cGRhdGVQYXRoKCk7XG4gICAgICB0aGlzLmRpcnR5UGF0aCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBwcmVSZW5kZXIoKSB7XG4gICAgdGhpcy51cGRhdGVQYXRoSWZEaXJ0eSgpO1xuICAgIHJldHVybiBzdXBlci5wcmVSZW5kZXIoKTtcbiAgfVxuICByZW5kZXIocmVuZGVyQ3R4KSB7XG4gICAgY29uc3QgeyBjdHgsIGZvcmNlUmVuZGVyLCBzdGF0cyB9ID0gcmVuZGVyQ3R4O1xuICAgIGlmICh0aGlzLmRpcnR5ID09PSAwIC8qIE5PTkUgKi8gJiYgIWZvcmNlUmVuZGVyKSB7XG4gICAgICBpZiAoc3RhdHMpXG4gICAgICAgIHN0YXRzLm5vZGVzU2tpcHBlZCArPSBub2RlQ291bnQodGhpcykuY291bnQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmNsaXAgJiYgIWlzTmFOKHRoaXMuX2NsaXBYKSAmJiAhaXNOYU4odGhpcy5fY2xpcFkpKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY29uc3QgbWFyZ2luID0gdGhpcy5zdHJva2VXaWR0aCAvIDI7XG4gICAgICB0aGlzLl9jbGlwUGF0aCA/PyAodGhpcy5fY2xpcFBhdGggPSBuZXcgRXh0ZW5kZWRQYXRoMkQoKSk7XG4gICAgICB0aGlzLl9jbGlwUGF0aC5jbGVhcigpO1xuICAgICAgdGhpcy5fY2xpcFBhdGgucmVjdCgtbWFyZ2luLCAtbWFyZ2luLCB0aGlzLl9jbGlwWCArIG1hcmdpbiwgdGhpcy5fY2xpcFkgKyBtYXJnaW4gKyBtYXJnaW4pO1xuICAgICAgY3R4LmNsaXAodGhpcy5fY2xpcFBhdGg/LmdldFBhdGgyRCgpKTtcbiAgICAgIGlmICh0aGlzLl9jbGlwWCA+IDAgJiYgdGhpcy5fY2xpcFkgPiAwKSB7XG4gICAgICAgIHRoaXMuZHJhd1BhdGgoY3R4KTtcbiAgICAgIH1cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2NsaXBQYXRoID0gdm9pZCAwO1xuICAgICAgdGhpcy5kcmF3UGF0aChjdHgpO1xuICAgIH1cbiAgICB0aGlzLmZpbGxTaGFkb3c/Lm1hcmtDbGVhbigpO1xuICAgIHN1cGVyLnJlbmRlcihyZW5kZXJDdHgpO1xuICB9XG4gIGRyYXdQYXRoKGN0eCkge1xuICAgIHRoaXMuZmlsbFN0cm9rZShjdHgsIHRoaXMucGF0aC5nZXRQYXRoMkQoKSk7XG4gIH1cbiAgdG9TVkcoKSB7XG4gICAgaWYgKCF0aGlzLnZpc2libGUpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZWxlbWVudDIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcInBhdGhcIik7XG4gICAgZWxlbWVudDIuc2V0QXR0cmlidXRlKFwiZFwiLCB0aGlzLnN2Z1BhdGhEYXRhKCkpO1xuICAgIGVsZW1lbnQyLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgdHlwZW9mIHRoaXMuZmlsbCA9PT0gXCJzdHJpbmdcIiA/IHRoaXMuZmlsbCA6IFwibm9uZVwiKTtcbiAgICBlbGVtZW50Mi5zZXRBdHRyaWJ1dGUoXCJmaWxsLW9wYWNpdHlcIiwgU3RyaW5nKHRoaXMuZmlsbE9wYWNpdHkpKTtcbiAgICBpZiAodGhpcy5zdHJva2UgIT0gbnVsbCkge1xuICAgICAgZWxlbWVudDIuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIHRoaXMuc3Ryb2tlKTtcbiAgICAgIGVsZW1lbnQyLnNldEF0dHJpYnV0ZShcInN0cm9rZS1vcGFjaXR5XCIsIFN0cmluZyh0aGlzLnN0cm9rZU9wYWNpdHkpKTtcbiAgICAgIGVsZW1lbnQyLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBTdHJpbmcodGhpcy5zdHJva2VXaWR0aCkpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZWxlbWVudHM6IFtlbGVtZW50Ml1cbiAgICB9O1xuICB9XG59O1xuUGF0aC5jbGFzc05hbWUgPSBcIlBhdGhcIjtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBQYXRoLnByb3RvdHlwZSwgXCJjbGlwXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFBhdGgucHJvdG90eXBlLCBcImNsaXBYXCIsIDEpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFBhdGgucHJvdG90eXBlLCBcImNsaXBZXCIsIDEpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9kb20vZm9jdXNJbmRpY2F0b3IudHNcbnZhciBGT0NVU19JTkRJQ0FUT1JfQ1NTX0NMQVNTID0gXCJhZy1jaGFydHMtZm9jdXMtaW5kaWNhdG9yXCI7XG52YXIgRm9jdXNJbmRpY2F0b3IgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGRvbU1hbmFnZXIpIHtcbiAgICB0aGlzLmRvbU1hbmFnZXIgPSBkb21NYW5hZ2VyO1xuICAgIHRoaXMuZGl2ID0gZ2V0RG9jdW1lbnQoKS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRoaXMuc3ZnID0gZ2V0RG9jdW1lbnQoKS5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcInN2Z1wiKTtcbiAgICB0aGlzLnBhdGggPSBnZXREb2N1bWVudCgpLmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwicGF0aFwiKTtcbiAgICB0aGlzLnN2Zy5hcHBlbmQodGhpcy5wYXRoKTtcbiAgICB0aGlzLmVsZW1lbnQgPSBkb21NYW5hZ2VyLmFkZENoaWxkKFwic2VyaWVzLWFyZWFcIiwgRk9DVVNfSU5ESUNBVE9SX0NTU19DTEFTUyk7XG4gICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoRk9DVVNfSU5ESUNBVE9SX0NTU19DTEFTUyk7XG4gICAgdGhpcy5lbGVtZW50LmFyaWFIaWRkZW4gPSBcInRydWVcIjtcbiAgICB0aGlzLmVsZW1lbnQuYXBwZW5kKHRoaXMuc3ZnKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZG9tTWFuYWdlci5yZW1vdmVTdHlsZXMoRk9DVVNfSU5ESUNBVE9SX0NTU19DTEFTUyk7XG4gICAgdGhpcy5kb21NYW5hZ2VyLnJlbW92ZUNoaWxkKFwic2VyaWVzLWFyZWFcIiwgRk9DVVNfSU5ESUNBVE9SX0NTU19DTEFTUyk7XG4gIH1cbiAgdXBkYXRlQm91bmRzKGJvdW5kcykge1xuICAgIGlmIChib3VuZHMgPT09IHZvaWQgMCkge1xuICAgIH0gZWxzZSBpZiAoYm91bmRzIGluc3RhbmNlb2YgUGF0aCkge1xuICAgICAgY29uc3QgdHJhbnNmb3JtID0gKHgsIHkpID0+IFRyYW5zZm9ybWFibGUudG9DYW52YXNQb2ludChib3VuZHMsIHgsIHkpO1xuICAgICAgdGhpcy5wYXRoLnNldEF0dHJpYnV0ZShcImRcIiwgYm91bmRzLnN2Z1BhdGhEYXRhKHRyYW5zZm9ybSkpO1xuICAgICAgdGhpcy5zaG93KHRoaXMuc3ZnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0RWxlbWVudEJCb3godGhpcy5kaXYsIGJvdW5kcyk7XG4gICAgICB0aGlzLnNob3codGhpcy5kaXYpO1xuICAgIH1cbiAgfVxuICBzaG93KGNoaWxkKSB7XG4gICAgdGhpcy5lbGVtZW50LmlubmVySFRNTCA9IFwiXCI7XG4gICAgdGhpcy5lbGVtZW50LmFwcGVuZChjaGlsZCk7XG4gIH1cbiAgZ2V0Rm9jdXNhYmxlRWxlbWVudCgpIHtcbiAgICBjb25zdCBmb2N1c2FibGUgPSB0aGlzLmVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICBpZiAoZm9jdXNhYmxlID09IG51bGwgfHwgZm9jdXNhYmxlLnRhYkluZGV4ICE9PSAwICYmIGZvY3VzYWJsZS50YWJJbmRleCAhPT0gLTEpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBRyBDaGFydHMgLSB0aGUgZm9jdXMgaW5kaWNhdG9yIG11c3QgYmUgYSBjaGlsZCBvZiBhIGZvY3VzYWJsZSBlbGVtZW50XCIpO1xuICAgIHJldHVybiBmb2N1c2FibGU7XG4gIH1cbiAgLy8gVXNlIHdpdGggY2F1dGlvbiEgVGhlIGZvY3VzIG11c3QgYmUgdmlzaWJsZSB3aGVuIHVzaW5nIHRoZSBrZXlib2FyZC5cbiAgb3ZlcnJpZGVGb2N1c1Zpc2libGUoZm9jdXNWaXNpYmxlKSB7XG4gICAgY29uc3Qgb3BhY2l0eSA9IHsgdHJ1ZTogXCIxXCIsIGZhbHNlOiBcIjBcIiwgdW5kZWZpbmVkOiBcIlwiIH07XG4gICAgdGhpcy5nZXRGb2N1c2FibGVFbGVtZW50KCkuc3R5bGUuc2V0UHJvcGVydHkoXCJvcGFjaXR5XCIsIG9wYWNpdHlbYCR7Zm9jdXNWaXNpYmxlfWBdKTtcbiAgfVxuICAvLyBHZXQgdGhlIGA6Zm9jdXMtdmlzaWJsZWAgQ1NTIHN0YXRlLlxuICBpc0ZvY3VzVmlzaWJsZSgpIHtcbiAgICBjb25zdCBmb2N1c2FibGUgPSB0aGlzLmdldEZvY3VzYWJsZUVsZW1lbnQoKTtcbiAgICByZXR1cm4gZm9jdXNhYmxlICE9IG51bGwgJiYgZ2V0V2luZG93KCkuZ2V0Q29tcHV0ZWRTdHlsZShmb2N1c2FibGUpLm9wYWNpdHkgPT09IFwiMVwiO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9kb20vYm91bmRlZFRleHQudHNcbnZhciBCb3VuZGVkVGV4dCA9IGNsYXNzIHtcbiAgc2V0IHRleHRDb250ZW50KHRleHQpIHtcbiAgICB0aGlzLnRleHRFbGVtZW50LnRleHRDb250ZW50ID0gdGV4dDtcbiAgICBjb25zdCBiYm94Q2FsY3VsYXRvciA9IHRoaXMudGV4dEVsZW1lbnQ7XG4gICAgY29uc3QgYmJveCA9IGJib3hDYWxjdWxhdG9yLmdldEJCb3g/LigpO1xuICAgIGlmIChiYm94KSB7XG4gICAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKFwidmlld0JveFwiLCBgJHtiYm94Lnh9ICR7YmJveC55fSAke2Jib3gud2lkdGh9ICR7YmJveC5oZWlnaHR9YCk7XG4gICAgfVxuICB9XG4gIGdldCB0ZXh0Q29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy50ZXh0RWxlbWVudC50ZXh0Q29udGVudDtcbiAgfVxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnRleHRFbGVtZW50ID0gY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJ0ZXh0XCIpO1xuICAgIHRoaXMudGV4dEVsZW1lbnQucm9sZSA9IFwicHJlc2VudGF0aW9uXCI7XG4gICAgdGhpcy5zdmdFbGVtZW50ID0gY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJzdmdcIik7XG4gICAgdGhpcy5zdmdFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMudGV4dEVsZW1lbnQpO1xuICAgIHRoaXMuc3ZnRWxlbWVudC5zdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xuICAgIHRoaXMuc3ZnRWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gXCIwXCI7XG4gICAgdGhpcy5zdmdFbGVtZW50LnJvbGUgPSBcInByZXNlbnRhdGlvblwiO1xuICAgIHRoaXMuYm91bmRlZENvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGhpcy5ib3VuZGVkQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuc3ZnRWxlbWVudCk7XG4gICAgdGhpcy5ib3VuZGVkQ29udGFpbmVyLnJvbGUgPSBcInByZXNlbnRhdGlvblwiO1xuICB9XG4gIHJlbW92ZSgpIHtcbiAgICB0aGlzLmJvdW5kZWRDb250YWluZXIucmVtb3ZlKCk7XG4gIH1cbiAgZ2V0Q29udGFpbmVyKCkge1xuICAgIHJldHVybiB0aGlzLmJvdW5kZWRDb250YWluZXI7XG4gIH1cbiAgdXBkYXRlQm91bmRzKGJvdW5kcykge1xuICAgIHNldEVsZW1lbnRCQm94KHRoaXMuYm91bmRlZENvbnRhaW5lciwgYm91bmRzKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvZG9tL3Byb3h5SW50ZXJhY3Rpb25TZXJ2aWNlLnRzXG5mdW5jdGlvbiBjaGVja1R5cGUodHlwZSwgbWV0YSkge1xuICByZXR1cm4gbWV0YS5wYXJhbXM/LnR5cGUgPT09IHR5cGU7XG59XG5mdW5jdGlvbiBhbGxvY2F0ZVJlc3VsdCh0eXBlKSB7XG4gIGlmIChcImJ1dHRvblwiID09PSB0eXBlKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gIH0gZWxzZSBpZiAoXCJzbGlkZXJcIiA9PT0gdHlwZSkge1xuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gIH0gZWxzZSBpZiAoW1widG9vbGJhclwiLCBcImdyb3VwXCIsIFwibGlzdFwiXS5pbmNsdWRlcyh0eXBlKSkge1xuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICB9IGVsc2UgaWYgKFwidGV4dFwiID09PSB0eXBlKSB7XG4gICAgcmV0dXJuIG5ldyBCb3VuZGVkVGV4dCgpO1xuICB9IGVsc2UgaWYgKFwibGlzdHN3aXRjaFwiID09PSB0eXBlKSB7XG4gICAgcmV0dXJuIHsgYnV0dG9uOiBjcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpLCBsaXN0aXRlbTogY3JlYXRlRWxlbWVudChcImRpdlwiKSB9O1xuICB9IGVsc2Uge1xuICAgIHRocm93IEVycm9yKFwiQUcgQ2hhcnRzIC0gZXJyb3IgYWxsb2NhdGluZyBtZXRhXCIpO1xuICB9XG59XG5mdW5jdGlvbiBhbGxvY2F0ZU1ldGEocGFyYW1zKSB7XG4gIGNvbnN0IG1ldGEgPSB7IHBhcmFtcywgcmVzdWx0OiB2b2lkIDAgfTtcbiAgbWV0YS5yZXN1bHQgPSBhbGxvY2F0ZVJlc3VsdChtZXRhLnBhcmFtcy50eXBlKTtcbiAgcmV0dXJuIG1ldGE7XG59XG52YXIgUHJveHlJbnRlcmFjdGlvblNlcnZpY2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGxvY2FsZU1hbmFnZXIsIGRvbU1hbmFnZXIpIHtcbiAgICB0aGlzLmxvY2FsZU1hbmFnZXIgPSBsb2NhbGVNYW5hZ2VyO1xuICAgIHRoaXMuZG9tTWFuYWdlciA9IGRvbU1hbmFnZXI7XG4gICAgdGhpcy5kZXN0cm95Rm5zID0gW107XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRlc3Ryb3lGbnMuZm9yRWFjaCgoZm4pID0+IGZuKCkpO1xuICB9XG4gIGFkZExvY2FsaXNhdGlvbihmbikge1xuICAgIGZuKCk7XG4gICAgdGhpcy5kZXN0cm95Rm5zLnB1c2godGhpcy5sb2NhbGVNYW5hZ2VyLmFkZExpc3RlbmVyKFwibG9jYWxlLWNoYW5nZWRcIiwgZm4pKTtcbiAgfVxuICBjcmVhdGVQcm94eUNvbnRhaW5lcihhcmdzKSB7XG4gICAgY29uc3QgbWV0YSA9IGFsbG9jYXRlTWV0YShhcmdzKTtcbiAgICBjb25zdCB7IHBhcmFtcywgcmVzdWx0OiBkaXYgfSA9IG1ldGE7XG4gICAgdGhpcy5kb21NYW5hZ2VyLmFkZENoaWxkKFwiY2FudmFzLXByb3h5XCIsIHBhcmFtcy5pZCwgZGl2KTtcbiAgICBkaXYuY2xhc3NMaXN0LmFkZCguLi5wYXJhbXMuY2xhc3NMaXN0LCBcImFnLWNoYXJ0cy1wcm94eS1jb250YWluZXJcIik7XG4gICAgZGl2LnJvbGUgPSBwYXJhbXMudHlwZTtcbiAgICBpZiAoXCJhcmlhT3JpZW50YXRpb25cIiBpbiBwYXJhbXMpIHtcbiAgICAgIGRpdi5hcmlhT3JpZW50YXRpb24gPSBwYXJhbXMuYXJpYU9yaWVudGF0aW9uO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHBhcmFtcy5hcmlhSGlkZGVuID09PSBcImJvb2xlYW5cIikge1xuICAgICAgZGl2LmFyaWFIaWRkZW4gPSBwYXJhbXMuYXJpYUhpZGRlbi50b1N0cmluZygpO1xuICAgIH1cbiAgICB0aGlzLmFkZExvY2FsaXNhdGlvbigoKSA9PiB7XG4gICAgICBkaXYuYXJpYUxhYmVsID0gdGhpcy5sb2NhbGVNYW5hZ2VyLnQocGFyYW1zLmFyaWFMYWJlbC5pZCwgcGFyYW1zLmFyaWFMYWJlbC5wYXJhbXMpO1xuICAgIH0pO1xuICAgIHJldHVybiBkaXY7XG4gIH1cbiAgY3JlYXRlUHJveHlFbGVtZW50KGFyZ3MpIHtcbiAgICBjb25zdCBtZXRhID0gYWxsb2NhdGVNZXRhKGFyZ3MpO1xuICAgIGlmIChjaGVja1R5cGUoXCJidXR0b25cIiwgbWV0YSkpIHtcbiAgICAgIGNvbnN0IHsgcGFyYW1zLCByZXN1bHQ6IGJ1dHRvbiB9ID0gbWV0YTtcbiAgICAgIHRoaXMuaW5pdEludGVyYWN0KHBhcmFtcywgYnV0dG9uKTtcbiAgICAgIGJ1dHRvbi5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJhdXRvXCI7XG4gICAgICBpZiAodHlwZW9mIHBhcmFtcy50ZXh0Q29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBidXR0b24udGV4dENvbnRlbnQgPSBwYXJhbXMudGV4dENvbnRlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB7IHRleHRDb250ZW50IH0gPSBwYXJhbXM7XG4gICAgICAgIHRoaXMuYWRkTG9jYWxpc2F0aW9uKCgpID0+IHtcbiAgICAgICAgICBidXR0b24udGV4dENvbnRlbnQgPSB0aGlzLmxvY2FsZU1hbmFnZXIudCh0ZXh0Q29udGVudC5pZCwgdGV4dENvbnRlbnQucGFyYW1zKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldFBhcmVudChwYXJhbXMsIGJ1dHRvbik7XG4gICAgfVxuICAgIGlmIChjaGVja1R5cGUoXCJzbGlkZXJcIiwgbWV0YSkpIHtcbiAgICAgIGNvbnN0IHsgcGFyYW1zLCByZXN1bHQ6IHNsaWRlciB9ID0gbWV0YTtcbiAgICAgIHRoaXMuaW5pdEludGVyYWN0KHBhcmFtcywgc2xpZGVyKTtcbiAgICAgIHNsaWRlci50eXBlID0gXCJyYW5nZVwiO1xuICAgICAgc2xpZGVyLnJvbGUgPSBcInByZXNlbnRhdGlvblwiO1xuICAgICAgc2xpZGVyLnN0eWxlLm1hcmdpbiA9IFwiMHB4XCI7XG4gICAgICBzbGlkZXIuYXJpYU9yaWVudGF0aW9uID0gcGFyYW1zLmFyaWFPcmllbnRhdGlvbjtcbiAgICAgIHRoaXMuYWRkTG9jYWxpc2F0aW9uKCgpID0+IHtcbiAgICAgICAgc2xpZGVyLmFyaWFMYWJlbCA9IHRoaXMubG9jYWxlTWFuYWdlci50KHBhcmFtcy5hcmlhTGFiZWwuaWQsIHBhcmFtcy5hcmlhTGFiZWwucGFyYW1zKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zZXRQYXJlbnQocGFyYW1zLCBzbGlkZXIpO1xuICAgIH1cbiAgICBpZiAoY2hlY2tUeXBlKFwidGV4dFwiLCBtZXRhKSkge1xuICAgICAgY29uc3QgeyBwYXJhbXMsIHJlc3VsdDogdGV4dCB9ID0gbWV0YTtcbiAgICAgIHRoaXMuaW5pdEVsZW1lbnQocGFyYW1zLCB0ZXh0LmdldENvbnRhaW5lcigpKTtcbiAgICAgIHRoaXMuc2V0UGFyZW50KHBhcmFtcywgdGV4dC5nZXRDb250YWluZXIoKSk7XG4gICAgfVxuICAgIGlmIChjaGVja1R5cGUoXCJsaXN0c3dpdGNoXCIsIG1ldGEpKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgcmVzdWx0OiB7IGJ1dHRvbiwgbGlzdGl0ZW0gfVxuICAgICAgfSA9IG1ldGE7XG4gICAgICB0aGlzLmluaXRJbnRlcmFjdChwYXJhbXMsIGJ1dHRvbik7XG4gICAgICBidXR0b24uc3R5bGUud2lkdGggPSBcIjEwMCVcIjtcbiAgICAgIGJ1dHRvbi5zdHlsZS5oZWlnaHQgPSBcIjEwMCVcIjtcbiAgICAgIGJ1dHRvbi50ZXh0Q29udGVudCA9IHBhcmFtcy50ZXh0Q29udGVudDtcbiAgICAgIGJ1dHRvbi5yb2xlID0gXCJzd2l0Y2hcIjtcbiAgICAgIGJ1dHRvbi5hcmlhQ2hlY2tlZCA9IHBhcmFtcy5hcmlhQ2hlY2tlZC50b1N0cmluZygpO1xuICAgICAgYnV0dG9uLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcImF1dG9cIjtcbiAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWRlc2NyaWJlZGJ5XCIsIHBhcmFtcy5hcmlhRGVzY3JpYmVkQnkpO1xuICAgICAgbGlzdGl0ZW0ucm9sZSA9IFwibGlzdGl0ZW1cIjtcbiAgICAgIGxpc3RpdGVtLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgbGlzdGl0ZW0ucmVwbGFjZUNoaWxkcmVuKGJ1dHRvbik7XG4gICAgICB0aGlzLnNldFBhcmVudChwYXJhbXMsIGxpc3RpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIG1ldGEucmVzdWx0O1xuICB9XG4gIGluaXRFbGVtZW50KHBhcmFtcywgZWxlbWVudDIpIHtcbiAgICBjb25zdCB7IGlkIH0gPSBwYXJhbXM7XG4gICAgZWxlbWVudDIuaWQgPSBpZDtcbiAgICBlbGVtZW50Mi5jbGFzc0xpc3QudG9nZ2xlKFwiYWctY2hhcnRzLXByb3h5LWVsZW1cIiwgdHJ1ZSk7XG4gIH1cbiAgaW5pdEludGVyYWN0KHBhcmFtcywgZWxlbWVudDIpIHtcbiAgICBjb25zdCB7IG9uY2xpY2ssIG9uZGJsY2xpY2ssIG9ubW91c2VlbnRlciwgb25tb3VzZWxlYXZlLCBvbmNvbnRleHRtZW51LCBvbmNoYW5nZSwgb25mb2N1cywgb25ibHVyLCB0YWJJbmRleCB9ID0gcGFyYW1zO1xuICAgIHRoaXMuaW5pdEVsZW1lbnQocGFyYW1zLCBlbGVtZW50Mik7XG4gICAgaWYgKHRhYkluZGV4ICE9PSB2b2lkIDApIHtcbiAgICAgIGVsZW1lbnQyLnRhYkluZGV4ID0gdGFiSW5kZXg7XG4gICAgfVxuICAgIGlmIChvbmNsaWNrKSB7XG4gICAgICBlbGVtZW50Mi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgb25jbGljayk7XG4gICAgfVxuICAgIGlmIChvbmRibGNsaWNrKSB7XG4gICAgICBlbGVtZW50Mi5hZGRFdmVudExpc3RlbmVyKFwiZGJsY2xpY2tcIiwgb25kYmxjbGljayk7XG4gICAgfVxuICAgIGlmIChvbm1vdXNlZW50ZXIpIHtcbiAgICAgIGVsZW1lbnQyLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWVudGVyXCIsIG9ubW91c2VlbnRlcik7XG4gICAgfVxuICAgIGlmIChvbm1vdXNlbGVhdmUpIHtcbiAgICAgIGVsZW1lbnQyLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIG9ubW91c2VsZWF2ZSk7XG4gICAgfVxuICAgIGlmIChvbmNvbnRleHRtZW51KSB7XG4gICAgICBlbGVtZW50Mi5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgb25jb250ZXh0bWVudSk7XG4gICAgfVxuICAgIGlmIChvbmZvY3VzKSB7XG4gICAgICBlbGVtZW50Mi5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgb25mb2N1cyk7XG4gICAgfVxuICAgIGlmIChvbmJsdXIpIHtcbiAgICAgIGVsZW1lbnQyLmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIG9uYmx1cik7XG4gICAgfVxuICAgIGlmIChvbmNoYW5nZSkge1xuICAgICAgZWxlbWVudDIuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBvbmNoYW5nZSk7XG4gICAgfVxuICB9XG4gIHNldFBhcmVudChwYXJhbXMsIGVsZW1lbnQyKSB7XG4gICAgY29uc3QgeyBpZCwgcGFyZW50IH0gPSBwYXJhbXM7XG4gICAgaWYgKHR5cGVvZiBwYXJlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnN0IGluc2VydCA9IHsgd2hlcmU6IHBhcmVudCwgcXVlcnk6IFwiLmFnLWNoYXJ0cy1zZXJpZXMtYXJlYVwiIH07XG4gICAgICB0aGlzLmRvbU1hbmFnZXIuYWRkQ2hpbGQoXCJjYW52YXMtcHJveHlcIiwgaWQsIGVsZW1lbnQyLCBpbnNlcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZWxlbWVudDIpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvbG9jYWxlL2RlZmF1bHRNZXNzYWdlRm9ybWF0dGVyLnRzXG52YXIgbWVzc2FnZVJlZ0V4cCA9IC9cXCRcXHsoXFx3Kyl9KD86XFxbKFxcdyspXSk/L2dpO1xudmFyIGZvcm1hdHRlcnMgPSB7XG4gIG51bWJlcjogbmV3IEludGwuTnVtYmVyRm9ybWF0KFwiZW4tVVNcIiksXG4gIHBlcmNlbnQ6IG5ldyBJbnRsLk51bWJlckZvcm1hdChcImVuLVVTXCIsIHsgc3R5bGU6IFwicGVyY2VudFwiLCBtaW5pbXVtRnJhY3Rpb25EaWdpdHM6IDIsIG1heGltdW1GcmFjdGlvbkRpZ2l0czogMiB9KSxcbiAgZGF0ZTogbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoXCJlbi1VU1wiLCB7IGRhdGVTdHlsZTogXCJmdWxsXCIgfSksXG4gIHRpbWU6IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KFwiZW4tVVNcIiwgeyB0aW1lU3R5bGU6IFwiZnVsbFwiIH0pLFxuICBkYXRldGltZTogbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoXCJlbi1VU1wiLCB7IGRhdGVTdHlsZTogXCJmdWxsXCIsIHRpbWVTdHlsZTogXCJmdWxsXCIgfSlcbn07XG52YXIgZGVmYXVsdE1lc3NhZ2VGb3JtYXR0ZXIgPSAoeyBkZWZhdWx0VmFsdWUsIHZhcmlhYmxlcyB9KSA9PiB7XG4gIHJldHVybiBkZWZhdWx0VmFsdWU/LnJlcGxhY2VBbGwobWVzc2FnZVJlZ0V4cCwgKF8sIG1hdGNoLCBmb3JtYXQpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IHZhcmlhYmxlc1ttYXRjaF07XG4gICAgY29uc3QgZm9ybWF0dGVyID0gZm9ybWF0ICE9IG51bGwgPyBmb3JtYXR0ZXJzW2Zvcm1hdF0gOiBudWxsO1xuICAgIGlmIChmb3JtYXQgIT0gbnVsbCAmJiBmb3JtYXR0ZXIgPT0gbnVsbCkge1xuICAgICAgTG9nZ2VyLndhcm5PbmNlKGBGb3JtYXQgc3R5bGUgWyR7Zm9ybWF0fV0gaXMgbm90IHN1cHBvcnRlZGApO1xuICAgIH1cbiAgICBpZiAoZm9ybWF0dGVyICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBmb3JtYXR0ZXIuZm9ybWF0KHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIGZvcm1hdHRlcnMubnVtYmVyLmZvcm1hdCh2YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIHJldHVybiBmb3JtYXR0ZXJzLmRhdGV0aW1lLmZvcm1hdCh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICB9KTtcbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2xvY2FsZS9sb2NhbGVNYW5hZ2VyLnRzXG52YXIgTG9jYWxlTWFuYWdlciA9IGNsYXNzIGV4dGVuZHMgTGlzdGVuZXJzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmxvY2FsZVRleHQgPSB2b2lkIDA7XG4gICAgdGhpcy5nZXRMb2NhbGVUZXh0ID0gdm9pZCAwO1xuICB9XG4gIHNldExvY2FsZVRleHQobG9jYWxlVGV4dCkge1xuICAgIGlmICh0aGlzLmxvY2FsZVRleHQgIT09IGxvY2FsZVRleHQpIHtcbiAgICAgIHRoaXMubG9jYWxlVGV4dCA9IGxvY2FsZVRleHQ7XG4gICAgICB0aGlzLmRpc3BhdGNoKFwibG9jYWxlLWNoYW5nZWRcIik7XG4gICAgfVxuICB9XG4gIHNldExvY2FsZVRleHRGb3JtYXR0ZXIoZ2V0TG9jYWxlVGV4dCkge1xuICAgIHRoaXMuZ2V0TG9jYWxlVGV4dCA9IGdldExvY2FsZVRleHQ7XG4gICAgaWYgKHRoaXMuZ2V0TG9jYWxlVGV4dCAhPT0gZ2V0TG9jYWxlVGV4dCkge1xuICAgICAgdGhpcy5nZXRMb2NhbGVUZXh0ID0gZ2V0TG9jYWxlVGV4dDtcbiAgICAgIHRoaXMuZGlzcGF0Y2goXCJsb2NhbGUtY2hhbmdlZFwiKTtcbiAgICB9XG4gIH1cbiAgdChrZXksIHZhcmlhYmxlcyA9IHt9KSB7XG4gICAgY29uc3QgeyBsb2NhbGVUZXh0ID0gQUdfQ0hBUlRTX0xPQ0FMRV9FTl9VUywgZ2V0TG9jYWxlVGV4dCB9ID0gdGhpcztcbiAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSBsb2NhbGVUZXh0W2tleV07XG4gICAgcmV0dXJuIGdldExvY2FsZVRleHQ/Lih7IGtleSwgZGVmYXVsdFZhbHVlLCB2YXJpYWJsZXMgfSkgPz8gZGVmYXVsdE1lc3NhZ2VGb3JtYXR0ZXIoeyBrZXksIGRlZmF1bHRWYWx1ZSwgdmFyaWFibGVzIH0pID8/IGtleTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC91c2VyQWdlbnQudHNcbmZ1bmN0aW9uIGhhc0NvbnN0cmFpbmVkQ2FudmFzTWVtb3J5KCkge1xuICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBpUGhvbmVPU01hdGNoID0gL1xcKGlQaG9uZTsgQ1BVIGlQaG9uZSBPUyAoXFxkK19cXGQrX1xcZCspIGxpa2UgTWFjIE9TIFhcXCkvLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIGlmIChpUGhvbmVPU01hdGNoID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgW21ham9yLCBtaW5vcl0gPSBpUGhvbmVPU01hdGNoWzFdLnNwbGl0KFwiX1wiKS5tYXAoTnVtYmVyKTtcbiAgcmV0dXJuIG1ham9yIDwgMTYgfHwgbWFqb3IgPT09IDE2ICYmIG1pbm9yIDwgNjtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvY2FudmFzL2hkcGlDYW52YXMudHNcbnZhciBfSGRwaUNhbnZhcyA9IGNsYXNzIF9IZHBpQ2FudmFzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy53aWR0aCA9IDYwMDtcbiAgICB0aGlzLmhlaWdodCA9IDMwMDtcbiAgICBjb25zdCB7IHdpZHRoOiB3aWR0aDIsIGhlaWdodDogaGVpZ2h0MiwgcGl4ZWxSYXRpbywgY2FudmFzRWxlbWVudCwgd2lsbFJlYWRGcmVxdWVudGx5ID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gICAgdGhpcy5waXhlbFJhdGlvID0gaGFzQ29uc3RyYWluZWRDYW52YXNNZW1vcnkoKSA/IDEgOiBwaXhlbFJhdGlvID8/IGdldFdpbmRvdyhcImRldmljZVBpeGVsUmF0aW9cIik7XG4gICAgdGhpcy5lbGVtZW50ID0gY2FudmFzRWxlbWVudCA/PyBjcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIHRoaXMuZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgIHRoaXMuZWxlbWVudC5zdHlsZS53aWR0aCA9ICh3aWR0aDIgPz8gdGhpcy53aWR0aCkgKyBcInB4XCI7XG4gICAgdGhpcy5lbGVtZW50LnN0eWxlLmhlaWdodCA9IChoZWlnaHQyID8/IHRoaXMuaGVpZ2h0KSArIFwicHhcIjtcbiAgICB0aGlzLmVsZW1lbnQud2lkdGggPSBNYXRoLnJvdW5kKCh3aWR0aDIgPz8gdGhpcy53aWR0aCkgKiB0aGlzLnBpeGVsUmF0aW8pO1xuICAgIHRoaXMuZWxlbWVudC5oZWlnaHQgPSBNYXRoLnJvdW5kKChoZWlnaHQyID8/IHRoaXMuaGVpZ2h0KSAqIHRoaXMucGl4ZWxSYXRpbyk7XG4gICAgdGhpcy5jb250ZXh0ID0gdGhpcy5lbGVtZW50LmdldENvbnRleHQoXCIyZFwiLCB7IHdpbGxSZWFkRnJlcXVlbnRseSB9KTtcbiAgICB0aGlzLm9uRW5hYmxlZENoYW5nZSgpO1xuICAgIHRoaXMucmVzaXplKHdpZHRoMiA/PyAwLCBoZWlnaHQyID8/IDApO1xuICAgIF9IZHBpQ2FudmFzLmRlYnVnQ29udGV4dCh0aGlzLmNvbnRleHQpO1xuICB9XG4gIHN0YXRpYyBpcyh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIF9IZHBpQ2FudmFzO1xuICB9XG4gIGRyYXdJbWFnZShjb250ZXh0LCBkeCA9IDAsIGR5ID0gMCkge1xuICAgIHJldHVybiBjb250ZXh0LmRyYXdJbWFnZSh0aGlzLmNvbnRleHQuY2FudmFzLCBkeCwgZHkpO1xuICB9XG4gIHRvRGF0YVVSTCh0eXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudC50b0RhdGFVUkwodHlwZSk7XG4gIH1cbiAgcmVzaXplKHdpZHRoMiwgaGVpZ2h0Mikge1xuICAgIGlmICghKHdpZHRoMiA+IDAgJiYgaGVpZ2h0MiA+IDApKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgZWxlbWVudDogZWxlbWVudDIsIGNvbnRleHQsIHBpeGVsUmF0aW8gfSA9IHRoaXM7XG4gICAgZWxlbWVudDIud2lkdGggPSBNYXRoLnJvdW5kKHdpZHRoMiAqIHBpeGVsUmF0aW8pO1xuICAgIGVsZW1lbnQyLmhlaWdodCA9IE1hdGgucm91bmQoaGVpZ2h0MiAqIHBpeGVsUmF0aW8pO1xuICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKHBpeGVsUmF0aW8sIDAsIDAsIHBpeGVsUmF0aW8sIDAsIDApO1xuICAgIGVsZW1lbnQyLnN0eWxlLndpZHRoID0gd2lkdGgyICsgXCJweFwiO1xuICAgIGVsZW1lbnQyLnN0eWxlLmhlaWdodCA9IGhlaWdodDIgKyBcInB4XCI7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoMjtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDI7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5jb250ZXh0LnNhdmUoKTtcbiAgICB0aGlzLmNvbnRleHQuc2V0VHJhbnNmb3JtKHRoaXMucGl4ZWxSYXRpbywgMCwgMCwgdGhpcy5waXhlbFJhdGlvLCAwLCAwKTtcbiAgICB0aGlzLmNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICB0aGlzLmNvbnRleHQucmVzdG9yZSgpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5lbGVtZW50LnJlbW92ZSgpO1xuICAgIHRoaXMuZWxlbWVudC53aWR0aCA9IDA7XG4gICAgdGhpcy5lbGVtZW50LmhlaWdodCA9IDA7XG4gICAgdGhpcy5jb250ZXh0LmNsZWFyUmVjdCgwLCAwLCAwLCAwKTtcbiAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICB9XG4gIG9uRW5hYmxlZENoYW5nZSgpIHtcbiAgICBpZiAodGhpcy5lbGVtZW50KSB7XG4gICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IHRoaXMuZW5hYmxlZCA/IFwiXCIgOiBcIm5vbmVcIjtcbiAgICB9XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZWR1bmRhbnQtdHlwZS1jb25zdGl0dWVudHNcbiAgc3RhdGljIGRlYnVnQ29udGV4dChjdHgpIHtcbiAgICBpZiAoRGVidWcuY2hlY2soXCJjYW52YXNcIikpIHtcbiAgICAgIGNvbnN0IHNhdmUgPSBjdHguc2F2ZS5iaW5kKGN0eCk7XG4gICAgICBjb25zdCByZXN0b3JlID0gY3R4LnJlc3RvcmUuYmluZChjdHgpO1xuICAgICAgbGV0IGRlcHRoID0gMDtcbiAgICAgIE9iamVjdC5hc3NpZ24oY3R4LCB7XG4gICAgICAgIHNhdmUoKSB7XG4gICAgICAgICAgc2F2ZSgpO1xuICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgIH0sXG4gICAgICAgIHJlc3RvcmUoKSB7XG4gICAgICAgICAgaWYgKGRlcHRoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBRyBDaGFydHMgLSBVbmFibGUgdG8gcmVzdG9yZSgpIHBhc3QgZGVwdGggMFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdG9yZSgpO1xuICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgIH0sXG4gICAgICAgIHZlcmlmeURlcHRoWmVybygpIHtcbiAgICAgICAgICBpZiAoZGVwdGggIT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQUcgQ2hhcnRzIC0gU2F2ZS9yZXN0b3JlIGRlcHRoIGlzIG5vbi16ZXJvOiAke2RlcHRofWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgT2JzZXJ2ZUNoYW5nZXMoKHRhcmdldCkgPT4gdGFyZ2V0Lm9uRW5hYmxlZENoYW5nZSgpKVxuXSwgX0hkcGlDYW52YXMucHJvdG90eXBlLCBcImVuYWJsZWRcIiwgMik7XG52YXIgSGRwaUNhbnZhcyA9IF9IZHBpQ2FudmFzO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9sYXllcnNNYW5hZ2VyLnRzXG52YXIgTGF5ZXJzTWFuYWdlciA9IGNsYXNzIF9MYXllcnNNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoY2FudmFzLCBtYXJrRGlydHkpIHtcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICB0aGlzLm1hcmtEaXJ0eSA9IG1hcmtEaXJ0eTtcbiAgICB0aGlzLmRlYnVnID0gRGVidWcuY3JlYXRlKHRydWUsIFwic2NlbmVcIik7XG4gICAgdGhpcy5sYXllcnNNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMubmV4dFpJbmRleCA9IDA7XG4gICAgdGhpcy5uZXh0TGF5ZXJJZCA9IDA7XG4gIH1cbiAgc3RhdGljIHNvcnRMYXllcnMoYSwgYikge1xuICAgIHJldHVybiBjb21wb3VuZEFzY2VuZGluZyhcbiAgICAgIFthLnpJbmRleCwgLi4uYS56SW5kZXhTdWJPcmRlciA/PyBbdm9pZCAwLCB2b2lkIDBdLCBhLmlkXSxcbiAgICAgIFtiLnpJbmRleCwgLi4uYi56SW5kZXhTdWJPcmRlciA/PyBbdm9pZCAwLCB2b2lkIDBdLCBiLmlkXSxcbiAgICAgIGFzY2VuZGluZ1N0cmluZ051bWJlclVuZGVmaW5lZFxuICAgICk7XG4gIH1cbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMubGF5ZXJzTWFwLnNpemU7XG4gIH1cbiAgZm9yRWFjaChjYWxsYmFjazIpIHtcbiAgICBBcnJheS5mcm9tKHRoaXMubGF5ZXJzTWFwLnZhbHVlcygpKS5zb3J0KF9MYXllcnNNYW5hZ2VyLnNvcnRMYXllcnMpLmZvckVhY2goY2FsbGJhY2syKTtcbiAgfVxuICByZXNpemUod2lkdGgyLCBoZWlnaHQyKSB7XG4gICAgdGhpcy5jYW52YXMucmVzaXplKHdpZHRoMiwgaGVpZ2h0Mik7XG4gICAgdGhpcy5sYXllcnNNYXAuZm9yRWFjaCgoeyBjYW52YXMgfSkgPT4gY2FudmFzLnJlc2l6ZSh3aWR0aDIsIGhlaWdodDIpKTtcbiAgfVxuICBhZGRMYXllcihvcHRzKSB7XG4gICAgY29uc3QgeyB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIsIHBpeGVsUmF0aW8gfSA9IHRoaXMuY2FudmFzO1xuICAgIGNvbnN0IHsgekluZGV4ID0gdGhpcy5uZXh0WkluZGV4KyssIG5hbWUsIHpJbmRleFN1Yk9yZGVyLCBnZXRDb21wdXRlZE9wYWNpdHksIGdldFZpc2liaWxpdHkgfSA9IG9wdHM7XG4gICAgY29uc3QgY2FudmFzID0gbmV3IEhkcGlDYW52YXMoeyB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIsIHBpeGVsUmF0aW8gfSk7XG4gICAgaWYgKHpJbmRleCA+PSB0aGlzLm5leHRaSW5kZXgpIHtcbiAgICAgIHRoaXMubmV4dFpJbmRleCA9IHpJbmRleCArIDE7XG4gICAgfVxuICAgIHRoaXMubGF5ZXJzTWFwLnNldChjYW52YXMsIHtcbiAgICAgIGlkOiB0aGlzLm5leHRMYXllcklkKyssXG4gICAgICBuYW1lLFxuICAgICAgY2FudmFzLFxuICAgICAgekluZGV4LFxuICAgICAgekluZGV4U3ViT3JkZXIsXG4gICAgICBnZXRDb21wdXRlZE9wYWNpdHksXG4gICAgICBnZXRWaXNpYmlsaXR5XG4gICAgfSk7XG4gICAgdGhpcy5kZWJ1ZyhcIlNjZW5lLmFkZExheWVyKCkgLSBsYXllcnNcIiwgdGhpcy5sYXllcnNNYXApO1xuICAgIHJldHVybiBjYW52YXM7XG4gIH1cbiAgcmVtb3ZlTGF5ZXIoY2FudmFzKSB7XG4gICAgaWYgKHRoaXMubGF5ZXJzTWFwLmhhcyhjYW52YXMpKSB7XG4gICAgICB0aGlzLmxheWVyc01hcC5kZWxldGUoY2FudmFzKTtcbiAgICAgIGNhbnZhcy5kZXN0cm95KCk7XG4gICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgdGhpcy5kZWJ1ZyhcIlNjZW5lLnJlbW92ZUxheWVyKCkgLSAgbGF5ZXJzXCIsIHRoaXMubGF5ZXJzTWFwKTtcbiAgICB9XG4gIH1cbiAgbW92ZUxheWVyKGNhbnZhcywgbmV3WkluZGV4LCBuZXdaSW5kZXhTdWJPcmRlcikge1xuICAgIGNvbnN0IGxheWVyID0gdGhpcy5sYXllcnNNYXAuZ2V0KGNhbnZhcyk7XG4gICAgaWYgKGxheWVyKSB7XG4gICAgICBsYXllci56SW5kZXggPSBuZXdaSW5kZXg7XG4gICAgICBsYXllci56SW5kZXhTdWJPcmRlciA9IG5ld1pJbmRleFN1Yk9yZGVyO1xuICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgIHRoaXMuZGVidWcoXCJTY2VuZS5tb3ZlTGF5ZXIoKSAtICBsYXllcnNcIiwgdGhpcy5sYXllcnNNYXApO1xuICAgIH1cbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLmxheWVyc01hcC5jbGVhcigpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9zcHJpdGVSZW5kZXJlci50c1xudmFyIF9TcHJpdGVSZW5kZXJlciA9IGNsYXNzIF9TcHJpdGVSZW5kZXJlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMub2Zmc2NyZWVuQ2FudmFzID0gdHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gXCJ1bmRlZmluZWRcIiA/IG5ldyBPZmZzY3JlZW5DYW52YXMoMCwgMCkgOiBjcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIF9TcHJpdGVSZW5kZXJlci5vZmZzY3JlZW5DYW52YXNDb3VudCsrO1xuICAgIGNvbnN0IGN0eCA9IHRoaXMub2Zmc2NyZWVuQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICBpZiAoY3R4ID09IG51bGwpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBBRyBDaGFydHMgLSBpbnZhbGlkIDJkIGNvbnRleHRgKTtcbiAgICB0aGlzLnJlbmRlckN0eCA9IHtcbiAgICAgIGN0eCxcbiAgICAgIGRldmljZVBpeGVsUmF0aW86IDEsXG4gICAgICBmb3JjZVJlbmRlcjogdHJ1ZSxcbiAgICAgIHJlc2l6ZWQ6IGZhbHNlLFxuICAgICAgZGVidWdOb2Rlczoge31cbiAgICB9O1xuICB9XG4gIHJlc2l6ZSh7IHNwcml0ZVBpeGVsUmF0aW8sIHNwcml0ZVdpZHRoLCBzcHJpdGVIZWlnaHQgfSkge1xuICAgIHRoaXMub2Zmc2NyZWVuQ2FudmFzLndpZHRoID0gTWF0aC5tYXgoc3ByaXRlV2lkdGgsIDApICogc3ByaXRlUGl4ZWxSYXRpbztcbiAgICB0aGlzLm9mZnNjcmVlbkNhbnZhcy5oZWlnaHQgPSBNYXRoLm1heChzcHJpdGVIZWlnaHQsIDApICogc3ByaXRlUGl4ZWxSYXRpbztcbiAgfVxuICByZW5kZXJTcHJpdGUobm9kZXMsIG9wdHMpIHtcbiAgICBub2RlcyA9IHRvSXRlcmFibGUobm9kZXMpO1xuICAgIGNvbnN0IHtcbiAgICAgIHJlbmRlckN0eCxcbiAgICAgIHJlbmRlckN0eDogeyBjdHggfSxcbiAgICAgIG9mZnNjcmVlbkNhbnZhc1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgc2NhbGU6IHNjYWxlMiA9IDEsIHRyYW5zbGF0ZVggPSAwLCB0cmFuc2xhdGVZID0gMCB9ID0gb3B0cyA/PyB7fTtcbiAgICBjdHgucmVzZXRUcmFuc2Zvcm0oKTtcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIG9mZnNjcmVlbkNhbnZhcy53aWR0aCwgb2Zmc2NyZWVuQ2FudmFzLmhlaWdodCk7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LnNldFRyYW5zZm9ybShzY2FsZTIsIDAsIDAsIHNjYWxlMiwgdHJhbnNsYXRlWCwgdHJhbnNsYXRlWSk7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgICBub2RlLnByZVJlbmRlcigpO1xuICAgICAgbm9kZS5yZW5kZXIocmVuZGVyQ3R4KTtcbiAgICB9XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgaWYgKFwidHJhbnNmZXJUb0ltYWdlQml0bWFwXCIgaW4gdGhpcy5vZmZzY3JlZW5DYW52YXMpIHtcbiAgICAgIHJldHVybiB0aGlzLm9mZnNjcmVlbkNhbnZhcy50cmFuc2ZlclRvSW1hZ2VCaXRtYXAoKTtcbiAgICB9XG4gICAgY29uc3QgY2FudmFzID0gY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICBjYW52YXMuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICBjYW52YXMuc3R5bGUud2lkdGggPSBvZmZzY3JlZW5DYW52YXMud2lkdGggKyBcInB4XCI7XG4gICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IG9mZnNjcmVlbkNhbnZhcy5oZWlnaHQgKyBcInB4XCI7XG4gICAgY2FudmFzLmdldENvbnRleHQoXCIyZFwiKT8ucHV0SW1hZ2VEYXRhKGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgb2Zmc2NyZWVuQ2FudmFzLndpZHRoLCBvZmZzY3JlZW5DYW52YXMuaGVpZ2h0KSwgMCwgMCk7XG4gICAgcmV0dXJuIGNhbnZhcztcbiAgfVxufTtcbl9TcHJpdGVSZW5kZXJlci5vZmZzY3JlZW5DYW52YXNDb3VudCA9IDA7XG52YXIgU3ByaXRlUmVuZGVyZXIgPSBfU3ByaXRlUmVuZGVyZXI7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL3NjZW5lRGVidWcudHNcbmZ1bmN0aW9uIGRlYnVnU3RhdHMobGF5ZXJzTWFuYWdlciwgZGVidWdTcGxpdFRpbWVzLCBjdHgsIHJlbmRlckN0eFN0YXRzLCBleHRyYURlYnVnU3RhdHMgPSB7fSwgc2VyaWVzUmVjdCA9IEJCb3guemVybykge1xuICBpZiAoIURlYnVnLmNoZWNrKFwic2NlbmU6c3RhdHNcIiAvKiBTQ0VORV9TVEFUUyAqLywgXCJzY2VuZTpzdGF0czp2ZXJib3NlXCIgLyogU0NFTkVfU1RBVFNfVkVSQk9TRSAqLykpXG4gICAgcmV0dXJuO1xuICBjb25zdCB7IGxheWVyc1JlbmRlcmVkID0gMCwgbGF5ZXJzU2tpcHBlZCA9IDAsIG5vZGVzUmVuZGVyZWQgPSAwLCBub2Rlc1NraXBwZWQgPSAwIH0gPSByZW5kZXJDdHhTdGF0cyA/PyB7fTtcbiAgY29uc3QgZW5kMiA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICBjb25zdCB7IHN0YXJ0OiBzdGFydDIsIC4uLmR1cmF0aW9ucyB9ID0gZGVidWdTcGxpdFRpbWVzO1xuICBjb25zdCBzcGxpdHMgPSBPYmplY3QuZW50cmllcyhkdXJhdGlvbnMpLm1hcCgoW24sIHRdKSA9PiB7XG4gICAgcmV0dXJuIHRpbWUobiwgdCk7XG4gIH0pLmZpbHRlcigodikgPT4gdiAhPSBudWxsKS5qb2luKFwiICsgXCIpO1xuICBjb25zdCBleHRyYXMgPSBPYmplY3QuZW50cmllcyhleHRyYURlYnVnU3RhdHMpLm1hcCgoW2ssIHZdKSA9PiBgJHtrfTogJHt2fWApLmpvaW4oXCIgOyBcIik7XG4gIGNvbnN0IGRldGFpbGVkU3RhdHMgPSBEZWJ1Zy5jaGVjayhcInNjZW5lOnN0YXRzOnZlcmJvc2VcIiAvKiBTQ0VORV9TVEFUU19WRVJCT1NFICovKTtcbiAgY29uc3Qgc3RhdHMgPSBbXG4gICAgYCR7dGltZShcIlxcdTIzRjFcXHVGRTBGXCIsIHN0YXJ0MiwgZW5kMil9ICgke3NwbGl0c30pYCxcbiAgICBgJHtleHRyYXN9YCxcbiAgICBgTGF5ZXJzOiAke2RldGFpbGVkU3RhdHMgPyBwY3QobGF5ZXJzUmVuZGVyZWQsIGxheWVyc1NraXBwZWQpIDogbGF5ZXJzTWFuYWdlci5zaXplfTsgU3ByaXRlczogJHtTcHJpdGVSZW5kZXJlci5vZmZzY3JlZW5DYW52YXNDb3VudH1gLFxuICAgIGRldGFpbGVkU3RhdHMgPyBgTm9kZXM6ICR7cGN0KG5vZGVzUmVuZGVyZWQsIG5vZGVzU2tpcHBlZCl9YCA6IG51bGxcbiAgXS5maWx0ZXIoaXNTdHJpbmcpO1xuICBjb25zdCBtZWFzdXJlciA9IG5ldyBTaW1wbGVUZXh0TWVhc3VyZXIoKHQpID0+IGN0eC5tZWFzdXJlVGV4dCh0KSk7XG4gIGNvbnN0IHN0YXRzU2l6ZSA9IG5ldyBNYXAoc3RhdHMubWFwKCh0KSA9PiBbdCwgbWVhc3VyZXIubWVhc3VyZUxpbmVzKHQpXSkpO1xuICBjb25zdCB3aWR0aDIgPSBNYXRoLm1heCguLi5BcnJheS5mcm9tKHN0YXRzU2l6ZS52YWx1ZXMoKSwgKHMpID0+IHMud2lkdGgpKTtcbiAgY29uc3QgaGVpZ2h0MiA9IGFjY3VtdWxhdGUoc3RhdHNTaXplLnZhbHVlcygpLCAocykgPT4gcy5oZWlnaHQpO1xuICBjb25zdCB4ID0gMiArIHNlcmllc1JlY3QueDtcbiAgY3R4LnNhdmUoKTtcbiAgY3R4LmZpbGxTdHlsZSA9IFwid2hpdGVcIjtcbiAgY3R4LmZpbGxSZWN0KHgsIDAsIHdpZHRoMiwgaGVpZ2h0Mik7XG4gIGN0eC5maWxsU3R5bGUgPSBcImJsYWNrXCI7XG4gIGxldCB5ID0gMDtcbiAgZm9yIChjb25zdCBbc3RhdCwgc2l6ZV0gb2Ygc3RhdHNTaXplLmVudHJpZXMoKSkge1xuICAgIHkgKz0gc2l6ZS5oZWlnaHQ7XG4gICAgY3R4LmZpbGxUZXh0KHN0YXQsIHgsIHkpO1xuICB9XG4gIGN0eC5yZXN0b3JlKCk7XG59XG5mdW5jdGlvbiBwcmVwYXJlU2NlbmVOb2RlSGlnaGxpZ2h0KGN0eCkge1xuICBjb25zdCBjb25maWcgPSB0b0FycmF5KGdldFdpbmRvdyhcImFnQ2hhcnRzU2NlbmVEZWJ1Z1wiKSk7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBmb3IgKGNvbnN0IG5hbWUgb2YgY29uZmlnKSB7XG4gICAgaWYgKG5hbWUgPT09IFwibGF5b3V0XCIpIHtcbiAgICAgIHJlc3VsdC5wdXNoKFwic2VyaWVzUm9vdFwiLCBcImxlZ2VuZFwiLCBcInJvb3RcIiwgLy4qQXhpcy1cXGQrLWF4aXMuKi8pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucHVzaChuYW1lKTtcbiAgICB9XG4gIH1cbiAgY3R4LmRlYnVnTm9kZVNlYXJjaCA9IHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGRlYnVnU2NlbmVOb2RlSGlnaGxpZ2h0KGN0eCwgZGVidWdOb2Rlcykge1xuICBjdHguc2F2ZSgpO1xuICBmb3IgKGNvbnN0IFtuYW1lLCBub2RlXSBvZiBPYmplY3QuZW50cmllcyhkZWJ1Z05vZGVzKSkge1xuICAgIGNvbnN0IGJib3ggPSBUcmFuc2Zvcm1hYmxlLnRvQ2FudmFzKG5vZGUpO1xuICAgIGlmICghYmJveCkge1xuICAgICAgTG9nZ2VyLmxvZyhgU2NlbmUucmVuZGVyKCkgLSBubyBiYm94IGZvciBkZWJ1Z2dlZCBub2RlIFske25hbWV9XS5gKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjdHguZ2xvYmFsQWxwaGEgPSAwLjg7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gXCJyZWRcIjtcbiAgICBjdHgubGluZVdpZHRoID0gMTtcbiAgICBjdHguc3Ryb2tlUmVjdChiYm94LngsIGJib3gueSwgYmJveC53aWR0aCwgYmJveC5oZWlnaHQpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBcInJlZFwiO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IFwid2hpdGVcIjtcbiAgICBjdHguZm9udCA9IFwiMTZweCBzYW5zLXNlcmlmXCI7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9IFwidG9wXCI7XG4gICAgY3R4LnRleHRBbGlnbiA9IFwibGVmdFwiO1xuICAgIGN0eC5saW5lV2lkdGggPSAyO1xuICAgIGN0eC5zdHJva2VUZXh0KG5hbWUsIGJib3gueCwgYmJveC55LCBiYm94LndpZHRoKTtcbiAgICBjdHguZmlsbFRleHQobmFtZSwgYmJveC54LCBiYm94LnksIGJib3gud2lkdGgpO1xuICB9XG4gIGN0eC5yZXN0b3JlKCk7XG59XG52YXIgc2tpcHBlZFByb3BlcnRpZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xudmFyIGFsbG93ZWRQcm9wZXJ0aWVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICBcImdyYWRpZW50XCIsXG4gIC8vICdfZGF0dW0nLFxuICBcInpJbmRleFwiLFxuICBcImNsaXBSZWN0XCIsXG4gIFwiY2FjaGVkQkJveFwiLFxuICBcImNoaWxkTm9kZUNvdW50c1wiLFxuICBcInBhdGhcIixcbiAgXCJfX3pJbmRleFwiLFxuICBcIm5hbWVcIixcbiAgXCJfX3NjYWxpbmdDZW50ZXJYXCIsXG4gIFwiX19zY2FsaW5nQ2VudGVyWVwiLFxuICBcIl9fcm90YXRpb25DZW50ZXJYXCIsXG4gIFwiX19yb3RhdGlvbkNlbnRlcllcIixcbiAgXCJfcHJldmlvdXNEYXR1bVwiLFxuICBcIl9fZmlsbFwiLFxuICBcIl9fbGluZURhc2hcIixcbiAgXCJib3JkZXJQYXRoXCIsXG4gIFwiYm9yZGVyQ2xpcFBhdGhcIixcbiAgXCJfY2xpcFBhdGhcIlxuXSk7XG5mdW5jdGlvbiBub2RlUHJvcHMobm9kZSkge1xuICBjb25zdCB7IC4uLmFsbFByb3BzIH0gPSBub2RlO1xuICBmb3IgKGNvbnN0IHByb3AgaW4gYWxsUHJvcHMpIHtcbiAgICBpZiAoYWxsb3dlZFByb3BlcnRpZXMuaGFzKHByb3ApKVxuICAgICAgY29udGludWU7XG4gICAgaWYgKHR5cGVvZiBhbGxQcm9wc1twcm9wXSA9PT0gXCJudW1iZXJcIilcbiAgICAgIGNvbnRpbnVlO1xuICAgIGlmICh0eXBlb2YgYWxsUHJvcHNbcHJvcF0gPT09IFwic3RyaW5nXCIpXG4gICAgICBjb250aW51ZTtcbiAgICBpZiAodHlwZW9mIGFsbFByb3BzW3Byb3BdID09PSBcImJvb2xlYW5cIilcbiAgICAgIGNvbnRpbnVlO1xuICAgIHNraXBwZWRQcm9wZXJ0aWVzLmFkZChwcm9wKTtcbiAgICBkZWxldGUgYWxsUHJvcHNbcHJvcF07XG4gIH1cbiAgcmV0dXJuIGFsbFByb3BzO1xufVxuZnVuY3Rpb24gYnVpbGRUcmVlKG5vZGUsIG1vZGUpIHtcbiAgaWYgKCFEZWJ1Zy5jaGVjayh0cnVlLCBcInNjZW5lXCIgLyogU0NFTkUgKi8pKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIGNvbnN0IHsgcGFyZW50Tm9kZSB9ID0gbm9kZTtcbiAgbGV0IG9yZGVyID0gMDtcbiAgcmV0dXJuIHtcbiAgICBub2RlOiBtb2RlID09PSBcImpzb25cIiA/IG5vZGVQcm9wcyhub2RlKSA6IG5vZGUsXG4gICAgbmFtZTogbm9kZS5uYW1lID8/IG5vZGUuaWQsXG4gICAgZGlydHk6IFJlZHJhd1R5cGVbbm9kZS5kaXJ0eV0sXG4gICAgLi4ucGFyZW50Tm9kZT8uaXNWaXJ0dWFsID8ge1xuICAgICAgdmlydHVhbFBhcmVudERpcnR5OiBSZWRyYXdUeXBlW3BhcmVudE5vZGUuZGlydHldLFxuICAgICAgdmlydHVhbFBhcmVudDogcGFyZW50Tm9kZVxuICAgIH0gOiB7fSxcbiAgICAuLi5BcnJheS5mcm9tKG5vZGUuY2hpbGRyZW4oZmFsc2UpLCAoYykgPT4gYnVpbGRUcmVlKGMsIG1vZGUpKS5yZWR1Y2UoXG4gICAgICAocmVzdWx0LCBjaGlsZFRyZWUpID0+IHtcbiAgICAgICAgbGV0IHsgbmFtZTogdHJlZU5vZGVOYW1lIH0gPSBjaGlsZFRyZWU7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBub2RlOiB7XG4gICAgICAgICAgICB2aXNpYmxlLFxuICAgICAgICAgICAgb3BhY2l0eSxcbiAgICAgICAgICAgIHpJbmRleCxcbiAgICAgICAgICAgIHpJbmRleFN1Yk9yZGVyLFxuICAgICAgICAgICAgdHJhbnNsYXRpb25YLFxuICAgICAgICAgICAgdHJhbnNsYXRpb25ZLFxuICAgICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgICBzY2FsaW5nWCxcbiAgICAgICAgICAgIHNjYWxpbmdZXG4gICAgICAgICAgfSxcbiAgICAgICAgICBub2RlOiBjaGlsZE5vZGUsXG4gICAgICAgICAgdmlydHVhbFBhcmVudFxuICAgICAgICB9ID0gY2hpbGRUcmVlO1xuICAgICAgICBpZiAoIXZpc2libGUgfHwgb3BhY2l0eSA8PSAwKSB7XG4gICAgICAgICAgdHJlZU5vZGVOYW1lID0gYCgke3RyZWVOb2RlTmFtZX0pYDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTGF5ZXIuaXMoY2hpbGROb2RlKSkge1xuICAgICAgICAgIHRyZWVOb2RlTmFtZSA9IGAqJHt0cmVlTm9kZU5hbWV9KmA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3ViT3JkZXIgPSB6SW5kZXhTdWJPcmRlcj8ubWFwKCh2KSA9PiB0eXBlb2YgdiA9PT0gXCJmdW5jdGlvblwiID8gYCR7digpfSAoZm4pYCA6IHYpLmpvaW4oXCIgLyBcIik7XG4gICAgICAgIGNvbnN0IGtleSA9IFtcbiAgICAgICAgICBgJHsob3JkZXIrKykudG9TdHJpbmcoKS5wYWRTdGFydCgzLCBcIjBcIil9fGAsXG4gICAgICAgICAgYCR7dHJlZU5vZGVOYW1lID8/IFwiPHVua25vd24+XCJ9YCxcbiAgICAgICAgICBgejogJHt6SW5kZXh9YCxcbiAgICAgICAgICBzdWJPcmRlciAmJiBgem86ICR7c3ViT3JkZXJ9YCxcbiAgICAgICAgICB2aXJ0dWFsUGFyZW50ICYmIGAodmlydHVhbCBwYXJlbnQpYCxcbiAgICAgICAgICB0cmFuc2xhdGlvblggJiYgYHg6ICR7dHJhbnNsYXRpb25YfWAsXG4gICAgICAgICAgdHJhbnNsYXRpb25ZICYmIGB5OiAke3RyYW5zbGF0aW9uWX1gLFxuICAgICAgICAgIHJvdGF0aW9uICYmIGByOiAke3JvdGF0aW9ufWAsXG4gICAgICAgICAgc2NhbGluZ1ggIT0gbnVsbCAmJiBzY2FsaW5nWCAhPT0gMSAmJiBgc3g6ICR7c2NhbGluZ1h9YCxcbiAgICAgICAgICBzY2FsaW5nWSAhPSBudWxsICYmIHNjYWxpbmdZICE9PSAxICYmIGBzeTogJHtzY2FsaW5nWX1gXG4gICAgICAgIF0uZmlsdGVyKCh2KSA9PiAhIXYpLmpvaW4oXCIgXCIpO1xuICAgICAgICBsZXQgc2VsZWN0ZWRLZXkgPSBrZXk7XG4gICAgICAgIGxldCBpbmRleCA9IDE7XG4gICAgICAgIHdoaWxlIChyZXN1bHRbc2VsZWN0ZWRLZXldICE9IG51bGwgJiYgaW5kZXggPCAxMDApIHtcbiAgICAgICAgICBzZWxlY3RlZEtleSA9IGAke2tleX0gKCR7aW5kZXgrK30pYDtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbc2VsZWN0ZWRLZXldID0gY2hpbGRUcmVlO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSxcbiAgICAgIHt9XG4gICAgKVxuICB9O1xufVxuZnVuY3Rpb24gYnVpbGREaXJ0eVRyZWUobm9kZSkge1xuICBpZiAobm9kZS5kaXJ0eSA9PT0gMCAvKiBOT05FICovKSB7XG4gICAgcmV0dXJuIHsgZGlydHlUcmVlOiB7fSwgcGF0aHM6IFtdIH07XG4gIH1cbiAgY29uc3QgY2hpbGRyZW5EaXJ0eVRyZWUgPSBBcnJheS5mcm9tKG5vZGUuY2hpbGRyZW4oKSwgKGMpID0+IGJ1aWxkRGlydHlUcmVlKGMpKS5maWx0ZXIoKGMpID0+IGMucGF0aHMubGVuZ3RoID4gMCk7XG4gIGNvbnN0IG5hbWUgPSBHcm91cC5pcyhub2RlKSA/IG5vZGUubmFtZSA/PyBub2RlLmlkIDogbm9kZS5pZDtcbiAgY29uc3QgcGF0aHMgPSBjaGlsZHJlbkRpcnR5VHJlZS5sZW5ndGggPyBjaGlsZHJlbkRpcnR5VHJlZS5mbGF0TWFwKChjKSA9PiBjLnBhdGhzKS5tYXAoKHApID0+IGAke25hbWV9LiR7cH1gKSA6IFtuYW1lXTtcbiAgcmV0dXJuIHtcbiAgICBkaXJ0eVRyZWU6IHtcbiAgICAgIG5hbWUsXG4gICAgICBub2RlLFxuICAgICAgZGlydHk6IFJlZHJhd1R5cGVbbm9kZS5kaXJ0eV0sXG4gICAgICAuLi5jaGlsZHJlbkRpcnR5VHJlZS5tYXAoKGMpID0+IGMuZGlydHlUcmVlKS5maWx0ZXIoKHQpID0+IHQuZGlydHkgIT0gbnVsbCkucmVkdWNlKChyZXN1bHQsIGNoaWxkVHJlZSkgPT4ge1xuICAgICAgICByZXN1bHRbY2hpbGRUcmVlLm5hbWUgPz8gXCI8dW5rbm93bj5cIl0gPSBjaGlsZFRyZWU7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LCB7fSlcbiAgICB9LFxuICAgIHBhdGhzXG4gIH07XG59XG5mdW5jdGlvbiBwY3QocmVuZGVyZWQsIHNraXBwZWQpIHtcbiAgY29uc3QgdG90YWwgPSByZW5kZXJlZCArIHNraXBwZWQ7XG4gIHJldHVybiBgJHtyZW5kZXJlZH0gLyAke3RvdGFsfSAoJHtNYXRoLnJvdW5kKDEwMCAqIHJlbmRlcmVkIC8gdG90YWwpfSUpYDtcbn1cbmZ1bmN0aW9uIHRpbWUobmFtZSwgc3RhcnQyLCBlbmQyKSB7XG4gIGNvbnN0IGR1cmF0aW9uID0gZW5kMiAhPSBudWxsID8gZW5kMiAtIHN0YXJ0MiA6IHN0YXJ0MjtcbiAgcmV0dXJuIGAke25hbWV9OiAke01hdGgucm91bmQoZHVyYXRpb24gKiAxMDApIC8gMTAwfW1zYDtcbn1cbmZ1bmN0aW9uIGFjY3VtdWxhdGUoaXRlcmF0b3IsIG1hcHBlcikge1xuICBsZXQgc3VtMiA9IDA7XG4gIGZvciAoY29uc3QgaXRlbSBvZiBpdGVyYXRvcikge1xuICAgIHN1bTIgKz0gbWFwcGVyKGl0ZW0pO1xuICB9XG4gIHJldHVybiBzdW0yO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9zY2VuZS50c1xudmFyIFNjZW5lID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjYW52YXNPcHRpb25zKSB7XG4gICAgdGhpcy5kZWJ1ZyA9IERlYnVnLmNyZWF0ZSh0cnVlLCBcInNjZW5lXCIgLyogU0NFTkUgKi8pO1xuICAgIHRoaXMuaWQgPSBjcmVhdGVJZCh0aGlzKTtcbiAgICB0aGlzLnJvb3QgPSBudWxsO1xuICAgIHRoaXMucGVuZGluZ1NpemUgPSBudWxsO1xuICAgIHRoaXMuaXNEaXJ0eSA9IGZhbHNlO1xuICAgIHRoaXMuY2FudmFzID0gbmV3IEhkcGlDYW52YXMoY2FudmFzT3B0aW9ucyk7XG4gICAgdGhpcy5sYXllcnNNYW5hZ2VyID0gbmV3IExheWVyc01hbmFnZXIodGhpcy5jYW52YXMsICgpID0+IHtcbiAgICAgIHRoaXMuaXNEaXJ0eSA9IHRydWU7XG4gICAgfSk7XG4gIH1cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLnBlbmRpbmdTaXplPy5bMF0gPz8gdGhpcy5jYW52YXMud2lkdGg7XG4gIH1cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5wZW5kaW5nU2l6ZT8uWzFdID8/IHRoaXMuY2FudmFzLmhlaWdodDtcbiAgfVxuICAvKiogQGRlcHJlY2F0ZWQgdjEwLjIuMCBPbmx5IHVzZWQgYnkgQUcgR3JpZCBTcGFya2xpbmVzICovXG4gIHNldENvbnRhaW5lcih2YWx1ZSkge1xuICAgIGNvbnN0IHsgZWxlbWVudDogZWxlbWVudDIgfSA9IHRoaXMuY2FudmFzO1xuICAgIGVsZW1lbnQyLnBhcmVudEVsZW1lbnQ/LnJlbW92ZUNoaWxkKGVsZW1lbnQyKTtcbiAgICB2YWx1ZS5hcHBlbmRDaGlsZChlbGVtZW50Mik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2V0Um9vdChub2RlKSB7XG4gICAgaWYgKHRoaXMucm9vdCA9PT0gbm9kZSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRoaXMuaXNEaXJ0eSA9IHRydWU7XG4gICAgdGhpcy5yb290Py5fc2V0TGF5ZXJNYW5hZ2VyKCk7XG4gICAgdGhpcy5yb290ID0gbm9kZTtcbiAgICBpZiAobm9kZSkge1xuICAgICAgbm9kZS52aXNpYmxlID0gdHJ1ZTtcbiAgICAgIG5vZGUuX3NldExheWVyTWFuYWdlcih0aGlzLmxheWVyc01hbmFnZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBhdHRhY2hOb2RlKG5vZGUpIHtcbiAgICB0aGlzLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgIHJldHVybiAoKSA9PiB0aGlzLnJlbW92ZUNoaWxkKG5vZGUpO1xuICB9XG4gIGFwcGVuZENoaWxkKG5vZGUpIHtcbiAgICB0aGlzLnJvb3Q/LmFwcGVuZENoaWxkKG5vZGUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlbW92ZUNoaWxkKG5vZGUpIHtcbiAgICB0aGlzLnJvb3Q/LnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGRvd25sb2FkKGZpbGVOYW1lLCBmaWxlRm9ybWF0KSB7XG4gICAgZG93bmxvYWRVcmwodGhpcy5jYW52YXMudG9EYXRhVVJMKGZpbGVGb3JtYXQpLCBmaWxlTmFtZT8udHJpbSgpID8/IFwiaW1hZ2VcIik7XG4gIH1cbiAgLyoqIE5PVEU6IEludGVncmF0ZWQgQ2hhcnRzIHVuZG9jdW1lbnRlZCBpbWFnZSBkb3dubG9hZCBtZXRob2QuICovXG4gIGdldERhdGFVUkwoZmlsZUZvcm1hdCkge1xuICAgIHJldHVybiB0aGlzLmNhbnZhcy50b0RhdGFVUkwoZmlsZUZvcm1hdCk7XG4gIH1cbiAgcmVzaXplKHdpZHRoMiwgaGVpZ2h0Mikge1xuICAgIHdpZHRoMiA9IE1hdGgucm91bmQod2lkdGgyKTtcbiAgICBoZWlnaHQyID0gTWF0aC5yb3VuZChoZWlnaHQyKTtcbiAgICBpZiAod2lkdGgyID4gMCAmJiBoZWlnaHQyID4gMCAmJiAod2lkdGgyICE9PSB0aGlzLndpZHRoIHx8IGhlaWdodDIgIT09IHRoaXMuaGVpZ2h0KSkge1xuICAgICAgdGhpcy5wZW5kaW5nU2l6ZSA9IFt3aWR0aDIsIGhlaWdodDJdO1xuICAgICAgdGhpcy5pc0RpcnR5ID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgYXN5bmMgcmVuZGVyKG9wdHMpIHtcbiAgICBjb25zdCB7IGRlYnVnU3BsaXRUaW1lcyA9IHsgc3RhcnQ6IHBlcmZvcm1hbmNlLm5vdygpIH0sIGV4dHJhRGVidWdTdGF0cywgc2VyaWVzUmVjdCB9ID0gb3B0cyA/PyB7fTtcbiAgICBjb25zdCB7IGNhbnZhcywgY2FudmFzOiB7IGNvbnRleHQ6IGN0eCB9ID0ge30sIHJvb3QsIHBlbmRpbmdTaXplIH0gPSB0aGlzO1xuICAgIGlmICghY3R4KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlbmRlclN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGlmIChwZW5kaW5nU2l6ZSkge1xuICAgICAgdGhpcy5sYXllcnNNYW5hZ2VyLnJlc2l6ZSguLi5wZW5kaW5nU2l6ZSk7XG4gICAgICB0aGlzLnBlbmRpbmdTaXplID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHJvb3QgJiYgIXJvb3QudmlzaWJsZSkge1xuICAgICAgdGhpcy5pc0RpcnR5ID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChyb290ICYmICF0aGlzLmlzRGlydHkpIHtcbiAgICAgIGlmICh0aGlzLmRlYnVnLmNoZWNrKCkpIHtcbiAgICAgICAgdGhpcy5kZWJ1ZyhcIlNjZW5lLnJlbmRlcigpIC0gbm8tb3BcIiwge1xuICAgICAgICAgIHJlZHJhd1R5cGU6IFJlZHJhd1R5cGVbcm9vdC5kaXJ0eV0sXG4gICAgICAgICAgdHJlZTogYnVpbGRUcmVlKHJvb3QsIFwiY29uc29sZVwiKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGRlYnVnU3RhdHModGhpcy5sYXllcnNNYW5hZ2VyLCBkZWJ1Z1NwbGl0VGltZXMsIGN0eCwgdm9pZCAwLCBleHRyYURlYnVnU3RhdHMsIHNlcmllc1JlY3QpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZW5kZXJDdHggPSB7XG4gICAgICBjdHgsXG4gICAgICBkZXZpY2VQaXhlbFJhdGlvOiB0aGlzLmNhbnZhcy5waXhlbFJhdGlvID8/IDEsXG4gICAgICBmb3JjZVJlbmRlcjogdHJ1ZSxcbiAgICAgIHJlc2l6ZWQ6IEJvb2xlYW4ocGVuZGluZ1NpemUpLFxuICAgICAgZGVidWdOb2Rlczoge31cbiAgICB9O1xuICAgIGlmIChEZWJ1Zy5jaGVjayhcInNjZW5lOnN0YXRzOnZlcmJvc2VcIiAvKiBTQ0VORV9TVEFUU19WRVJCT1NFICovKSkge1xuICAgICAgcmVuZGVyQ3R4LnN0YXRzID0geyBsYXllcnNSZW5kZXJlZDogMCwgbGF5ZXJzU2tpcHBlZDogMCwgbm9kZXNSZW5kZXJlZDogMCwgbm9kZXNTa2lwcGVkOiAwIH07XG4gICAgfVxuICAgIHByZXBhcmVTY2VuZU5vZGVIaWdobGlnaHQocmVuZGVyQ3R4KTtcbiAgICBsZXQgY2FudmFzQ2xlYXJlZCA9IGZhbHNlO1xuICAgIGlmICghcm9vdCB8fCByb290LmRpcnR5ID49IDEgLyogVFJJVklBTCAqLykge1xuICAgICAgY2FudmFzQ2xlYXJlZCA9IHRydWU7XG4gICAgICBjYW52YXMuY2xlYXIoKTtcbiAgICB9XG4gICAgaWYgKHJvb3QgJiYgRGVidWcuY2hlY2soXCJzY2VuZTpkaXJ0eVRyZWVcIiAvKiBTQ0VORV9ESVJUWV9UUkVFICovKSkge1xuICAgICAgY29uc3QgeyBkaXJ0eVRyZWUsIHBhdGhzIH0gPSBidWlsZERpcnR5VHJlZShyb290KTtcbiAgICAgIERlYnVnLmNyZWF0ZShcInNjZW5lOmRpcnR5VHJlZVwiIC8qIFNDRU5FX0RJUlRZX1RSRUUgKi8pKFwiU2NlbmUucmVuZGVyKCkgLSBkaXJ0eVRyZWVcIiwgeyBkaXJ0eVRyZWUsIHBhdGhzIH0pO1xuICAgIH1cbiAgICBpZiAocm9vdCAmJiBjYW52YXNDbGVhcmVkKSB7XG4gICAgICBpZiAocm9vdC52aXNpYmxlKSB7XG4gICAgICAgIHJvb3QucHJlUmVuZGVyKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5kZWJ1Zy5jaGVjaygpKSB7XG4gICAgICAgIGNvbnN0IHRyZWUgPSBidWlsZFRyZWUocm9vdCwgXCJjb25zb2xlXCIpO1xuICAgICAgICB0aGlzLmRlYnVnKFwiU2NlbmUucmVuZGVyKCkgLSBiZWZvcmVcIiwge1xuICAgICAgICAgIHJlZHJhd1R5cGU6IFJlZHJhd1R5cGVbcm9vdC5kaXJ0eV0sXG4gICAgICAgICAgY2FudmFzQ2xlYXJlZCxcbiAgICAgICAgICB0cmVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHJvb3QudmlzaWJsZSkge1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICByb290LnJlbmRlcihyZW5kZXJDdHgpO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBkZWJ1Z1NwbGl0VGltZXNbXCJcXHUyNzBEXFx1RkUwRlwiXSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gcmVuZGVyU3RhcnRUaW1lO1xuICAgIGlmICh0aGlzLmxheWVyc01hbmFnZXIuc2l6ZSAmJiBjYW52YXNDbGVhcmVkKSB7XG4gICAgICBjb25zdCBsYXllclJlbmRlclN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnJlc2V0VHJhbnNmb3JtKCk7XG4gICAgICB0aGlzLmxheWVyc01hbmFnZXIuZm9yRWFjaCgobGF5ZXIpID0+IHtcbiAgICAgICAgaWYgKGxheWVyLmNhbnZhcy5lbmFibGVkICYmIGxheWVyLmdldFZpc2liaWxpdHkoKSkge1xuICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGxheWVyLmdldENvbXB1dGVkT3BhY2l0eSgpO1xuICAgICAgICAgIGxheWVyLmNhbnZhcy5kcmF3SW1hZ2UoY3R4KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgZGVidWdTcGxpdFRpbWVzW1wiXFx1MjZEOVwiXSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gbGF5ZXJSZW5kZXJTdGFydDtcbiAgICB9XG4gICAgY3R4LnZlcmlmeURlcHRoWmVybz8uKCk7XG4gICAgdGhpcy5pc0RpcnR5ID0gZmFsc2U7XG4gICAgZGVidWdTdGF0cyh0aGlzLmxheWVyc01hbmFnZXIsIGRlYnVnU3BsaXRUaW1lcywgY3R4LCByZW5kZXJDdHguc3RhdHMsIGV4dHJhRGVidWdTdGF0cywgc2VyaWVzUmVjdCk7XG4gICAgZGVidWdTY2VuZU5vZGVIaWdobGlnaHQoY3R4LCByZW5kZXJDdHguZGVidWdOb2Rlcyk7XG4gICAgaWYgKHJvb3QgJiYgdGhpcy5kZWJ1Zy5jaGVjaygpKSB7XG4gICAgICB0aGlzLmRlYnVnKFwiU2NlbmUucmVuZGVyKCkgLSBhZnRlclwiLCB7XG4gICAgICAgIHJlZHJhd1R5cGU6IFJlZHJhd1R5cGVbcm9vdC5kaXJ0eV0sXG4gICAgICAgIHRyZWU6IGJ1aWxkVHJlZShyb290LCBcImNvbnNvbGVcIiksXG4gICAgICAgIGNhbnZhc0NsZWFyZWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICB0b1NWRygpIHtcbiAgICBjb25zdCBzdmcgPSB0aGlzLnJvb3Q/LnRvU1ZHKCk7XG4gICAgaWYgKHN2ZyA9PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHJvb3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcInN2Z1wiKTtcbiAgICByb290LnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFN0cmluZyh0aGlzLndpZHRoKSk7XG4gICAgcm9vdC5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgU3RyaW5nKHRoaXMuaGVpZ2h0KSk7XG4gICAgaWYgKHN2Zy5kZWZzICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IGRlZnMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcImRlZnNcIik7XG4gICAgICBkZWZzLmFwcGVuZCguLi5zdmcuZGVmcyk7XG4gICAgICByb290LmFwcGVuZChkZWZzKTtcbiAgICB9XG4gICAgcm9vdC5hcHBlbmQoLi4uc3ZnLmVsZW1lbnRzKTtcbiAgICByZXR1cm4gcm9vdC5vdXRlckhUTUw7XG4gIH1cbiAgLyoqIEFsdGVybmF0aXZlIHRvIGRlc3Ryb3koKSB0aGF0IHByZXNlcnZlcyByZS11c2FibGUgcmVzb3VyY2VzLiAqL1xuICBzdHJpcCgpIHtcbiAgICBjb25zdCB7IGNvbnRleHQsIHBpeGVsUmF0aW8gfSA9IHRoaXMuY2FudmFzO1xuICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKHBpeGVsUmF0aW8sIDAsIDAsIHBpeGVsUmF0aW8sIDAsIDApO1xuICAgIHRoaXMubGF5ZXJzTWFuYWdlci5jbGVhcigpO1xuICAgIHRoaXMuc2V0Um9vdChudWxsKTtcbiAgICB0aGlzLmlzRGlydHkgPSBmYWxzZTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuc3RyaXAoKTtcbiAgICB0aGlzLmNhbnZhcy5kZXN0cm95KCk7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7IGNhbnZhczogdm9pZCAwIH0pO1xuICB9XG59O1xuU2NlbmUuY2xhc3NOYW1lID0gXCJTY2VuZVwiO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2NhbGxiYWNrQ2FjaGUudHNcbnZhciBDYWxsYmFja0NhY2hlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gIH1cbiAgY2FsbChmbiwgLi4ucGFyYW1zKSB7XG4gICAgbGV0IHNlcmlhbGlzZWRQYXJhbXM7XG4gICAgbGV0IHBhcmFtQ2FjaGUgPSB0aGlzLmNhY2hlLmdldChmbik7XG4gICAgdHJ5IHtcbiAgICAgIHNlcmlhbGlzZWRQYXJhbXMgPSBKU09OLnN0cmluZ2lmeShwYXJhbXMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmludm9rZShmbiwgcGFyYW1zLCBwYXJhbUNhY2hlKTtcbiAgICB9XG4gICAgaWYgKHBhcmFtQ2FjaGUgPT0gbnVsbCkge1xuICAgICAgcGFyYW1DYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICB0aGlzLmNhY2hlLnNldChmbiwgcGFyYW1DYWNoZSk7XG4gICAgfVxuICAgIGlmICghcGFyYW1DYWNoZS5oYXMoc2VyaWFsaXNlZFBhcmFtcykpIHtcbiAgICAgIHJldHVybiB0aGlzLmludm9rZShmbiwgcGFyYW1zLCBwYXJhbUNhY2hlLCBzZXJpYWxpc2VkUGFyYW1zKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtQ2FjaGUuZ2V0KHNlcmlhbGlzZWRQYXJhbXMpO1xuICB9XG4gIGludm9rZShmbiwgcGFyYW1zLCBwYXJhbUNhY2hlLCBzZXJpYWxpc2VkUGFyYW1zKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGZuKC4uLnBhcmFtcyk7XG4gICAgICBpZiAocGFyYW1DYWNoZSAmJiBzZXJpYWxpc2VkUGFyYW1zICE9IG51bGwpIHtcbiAgICAgICAgcGFyYW1DYWNoZS5zZXQoc2VyaWFsaXNlZFBhcmFtcywgcmVzdWx0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgTG9nZ2VyLndhcm5PbmNlKGBVc2VyIGNhbGxiYWNrIGVycm9yZWQsIGlnbm9yaW5nYCwgZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGludmFsaWRhdGVDYWNoZSgpIHtcbiAgICB0aGlzLmNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2Fubm90YXRpb24vYW5ub3RhdGlvbk1hbmFnZXIudHNcbnZhciBBbm5vdGF0aW9uTWFuYWdlciA9IGNsYXNzIGV4dGVuZHMgQmFzZU1hbmFnZXIge1xuICBjb25zdHJ1Y3Rvcihhbm5vdGF0aW9uUm9vdCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5hbm5vdGF0aW9uUm9vdCA9IGFubm90YXRpb25Sb290O1xuICAgIHRoaXMubWVtZW50b09yaWdpbmF0b3JLZXkgPSBcImFubm90YXRpb25zXCI7XG4gICAgdGhpcy5hbm5vdGF0aW9ucyA9IFtdO1xuICB9XG4gIGNyZWF0ZU1lbWVudG8oKSB7XG4gICAgcmV0dXJuIHRoaXMuYW5ub3RhdGlvbnM7XG4gIH1cbiAgZ3VhcmRNZW1lbnRvKGJsb2IpIHtcbiAgICByZXR1cm4gaXNBcnJheShibG9iKTtcbiAgfVxuICByZXN0b3JlTWVtZW50byhfdmVyc2lvbiwgX21lbWVudG9WZXJzaW9uLCBtZW1lbnRvKSB7XG4gICAgdGhpcy5hbm5vdGF0aW9ucyA9IHRoaXMuY2xlYW5EYXRhKG1lbWVudG8pLm1hcCgoYW5ub3RhdGlvbikgPT4ge1xuICAgICAgY29uc3QgYW5ub3RhdGlvblRoZW1lID0gdGhpcy5nZXRBbm5vdGF0aW9uVHlwZVN0eWxlcyhhbm5vdGF0aW9uLnR5cGUpO1xuICAgICAgcmV0dXJuIG1lcmdlRGVmYXVsdHMoYW5ub3RhdGlvbiwgYW5ub3RhdGlvblRoZW1lKTtcbiAgICB9KTtcbiAgICB0aGlzLmxpc3RlbmVycy5kaXNwYXRjaChcInJlc3RvcmUtYW5ub3RhdGlvbnNcIiwge1xuICAgICAgdHlwZTogXCJyZXN0b3JlLWFubm90YXRpb25zXCIsXG4gICAgICBhbm5vdGF0aW9uczogdGhpcy5hbm5vdGF0aW9uc1xuICAgIH0pO1xuICB9XG4gIHVwZGF0ZURhdGEoYW5ub3RhdGlvbnMyKSB7XG4gICAgdGhpcy5hbm5vdGF0aW9ucyA9IHRoaXMuY2xlYW5EYXRhKGFubm90YXRpb25zMiA/PyBbXSk7XG4gIH1cbiAgYXR0YWNoTm9kZShub2RlKSB7XG4gICAgdGhpcy5hbm5vdGF0aW9uUm9vdC5hcHBlbmQobm9kZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHRoaXMuYW5ub3RhdGlvblJvb3Q/LnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgfVxuICBzZXRBbm5vdGF0aW9uU3R5bGVzKHN0eWxlcykge1xuICAgIHRoaXMuc3R5bGVzID0gc3R5bGVzO1xuICB9XG4gIGdldEFubm90YXRpb25UeXBlU3R5bGVzKHR5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5zdHlsZXM/Llt0eXBlXTtcbiAgfVxuICBjbGVhbkRhdGEoYW5ub3RhdGlvbnMyKSB7XG4gICAgZm9yIChjb25zdCBhbm5vdGF0aW9uIG9mIGFubm90YXRpb25zMikge1xuICAgICAgaWYgKFwidGV4dEFsaWduXCIgaW4gYW5ub3RhdGlvbilcbiAgICAgICAgZGVsZXRlIGFubm90YXRpb24udGV4dEFsaWduO1xuICAgIH1cbiAgICByZXR1cm4gYW5ub3RhdGlvbnMyO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9heGlzL2F4aXNNYW5hZ2VyLnRzXG52YXIgQXhpc01hbmFnZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHNjZW5lUm9vdCkge1xuICAgIHRoaXMuc2NlbmVSb290ID0gc2NlbmVSb290O1xuICAgIHRoaXMuYXhlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5heGlzR3JpZEdyb3VwID0gbmV3IExheWVyKHsgbmFtZTogXCJBeGVzLUdyaWRzXCIsIHpJbmRleDogMSAvKiBBWElTX0dSSUQgKi8gfSk7XG4gICAgdGhpcy5heGlzR3JvdXAgPSBuZXcgTGF5ZXIoeyBuYW1lOiBcIkF4ZXNcIiwgekluZGV4OiAyIC8qIEFYSVMgKi8gfSk7XG4gICAgdGhpcy5zY2VuZVJvb3QuYXBwZW5kQ2hpbGQodGhpcy5heGlzR3JvdXApO1xuICAgIHRoaXMuc2NlbmVSb290LmFwcGVuZENoaWxkKHRoaXMuYXhpc0dyaWRHcm91cCk7XG4gIH1cbiAgdXBkYXRlQXhlcyhvbGRBeGVzLCBuZXdBeGVzKSB7XG4gICAgZm9yIChjb25zdCBheGlzIG9mIG9sZEF4ZXMpIHtcbiAgICAgIGlmIChuZXdBeGVzLmluY2x1ZGVzKGF4aXMpKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGF4aXMuZGV0YWNoQXhpcyh0aGlzLmF4aXNHcm91cCwgdGhpcy5heGlzR3JpZEdyb3VwKTtcbiAgICAgIGF4aXMuZGVzdHJveSgpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGF4aXMgb2YgbmV3QXhlcykge1xuICAgICAgaWYgKG9sZEF4ZXM/LmluY2x1ZGVzKGF4aXMpKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGF4aXMuYXR0YWNoQXhpcyh0aGlzLmF4aXNHcm91cCwgdGhpcy5heGlzR3JpZEdyb3VwKTtcbiAgICB9XG4gICAgdGhpcy5heGVzLmNsZWFyKCk7XG4gICAgZm9yIChjb25zdCBheGlzIG9mIG5ld0F4ZXMpIHtcbiAgICAgIGNvbnN0IGN0eCA9IGF4aXMuY3JlYXRlQXhpc0NvbnRleHQoKTtcbiAgICAgIGlmICh0aGlzLmF4ZXMuaGFzKGN0eC5kaXJlY3Rpb24pKSB7XG4gICAgICAgIHRoaXMuYXhlcy5nZXQoY3R4LmRpcmVjdGlvbik/LnB1c2goY3R4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYXhlcy5zZXQoY3R4LmRpcmVjdGlvbiwgW2N0eF0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXRBeGlzQ29udGV4dChkaXJlY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy5heGVzLmdldChkaXJlY3Rpb24pID8/IFtdO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5heGVzLmNsZWFyKCk7XG4gICAgdGhpcy5zY2VuZVJvb3QucmVtb3ZlQ2hpbGQodGhpcy5heGlzR3JvdXApO1xuICAgIHRoaXMuc2NlbmVSb290LnJlbW92ZUNoaWxkKHRoaXMuYXhpc0dyaWRHcm91cCk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2RhdGEvZGF0YVNlcnZpY2UudHNcbnZhciBEYXRhU2VydmljZSA9IGNsYXNzIGV4dGVuZHMgTGlzdGVuZXJzIHtcbiAgY29uc3RydWN0b3IoYW5pbWF0aW9uTWFuYWdlcikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5hbmltYXRpb25NYW5hZ2VyID0gYW5pbWF0aW9uTWFuYWdlcjtcbiAgICB0aGlzLmRpc3BhdGNoT25seUxhdGVzdCA9IHRydWU7XG4gICAgdGhpcy5kaXNwYXRjaFRocm90dGxlID0gMDtcbiAgICB0aGlzLnJlcXVlc3RUaHJvdHRsZSA9IDMwMDtcbiAgICB0aGlzLmlzTG9hZGluZ0luaXRpYWxEYXRhID0gZmFsc2U7XG4gICAgdGhpcy5pc0xvYWRpbmdEYXRhID0gZmFsc2U7XG4gICAgdGhpcy5mcmVzaFJlcXVlc3RzID0gW107XG4gICAgdGhpcy5yZXF1ZXN0Q291bnRlciA9IDA7XG4gICAgdGhpcy5kZWJ1ZyA9IERlYnVnLmNyZWF0ZSh0cnVlLCBcImRhdGEtbW9kZWxcIiwgXCJkYXRhLXNvdXJjZVwiKTtcbiAgICB0aGlzLnRocm90dGxlZEZldGNoID0gdGhpcy5jcmVhdGVUaHJvdHRsZWRGZXRjaCh0aGlzLnJlcXVlc3RUaHJvdHRsZSk7XG4gICAgdGhpcy50aHJvdHRsZWREaXNwYXRjaCA9IHRoaXMuY3JlYXRlVGhyb3R0bGVkRGlzcGF0Y2godGhpcy5kaXNwYXRjaFRocm90dGxlKTtcbiAgfVxuICB1cGRhdGVDYWxsYmFjayhkYXRhU291cmNlQ2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIGRhdGFTb3VyY2VDYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuZGVidWcoXCJEYXRhU2VydmljZSAtIHVwZGF0ZWQgZGF0YSBzb3VyY2UgY2FsbGJhY2tcIik7XG4gICAgdGhpcy5kYXRhU291cmNlQ2FsbGJhY2sgPSBkYXRhU291cmNlQ2FsbGJhY2s7XG4gICAgdGhpcy5pc0xvYWRpbmdJbml0aWFsRGF0YSA9IHRydWU7XG4gICAgdGhpcy5hbmltYXRpb25NYW5hZ2VyLnNraXAoKTtcbiAgICB0aGlzLmRpc3BhdGNoKFwiZGF0YS1zb3VyY2UtY2hhbmdlXCIpO1xuICB9XG4gIGNsZWFyQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5kYXRhU291cmNlQ2FsbGJhY2sgPSB2b2lkIDA7XG4gIH1cbiAgbG9hZChwYXJhbXMpIHtcbiAgICB0aGlzLmlzTG9hZGluZ0RhdGEgPSB0cnVlO1xuICAgIHRoaXMudGhyb3R0bGVkRmV0Y2gocGFyYW1zKTtcbiAgfVxuICBpc0xhenkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZUNhbGxiYWNrICE9IG51bGw7XG4gIH1cbiAgaXNMb2FkaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmlzTGF6eSgpICYmICh0aGlzLmlzTG9hZGluZ0luaXRpYWxEYXRhIHx8IHRoaXMuaXNMb2FkaW5nRGF0YSk7XG4gIH1cbiAgY3JlYXRlVGhyb3R0bGVkRmV0Y2gocmVxdWVzdFRocm90dGxlKSB7XG4gICAgcmV0dXJuIHRocm90dGxlKChwYXJhbXMpID0+IHRoaXMuZmV0Y2gocGFyYW1zKSwgcmVxdWVzdFRocm90dGxlLCB7XG4gICAgICBsZWFkaW5nOiBmYWxzZSxcbiAgICAgIHRyYWlsaW5nOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgY3JlYXRlVGhyb3R0bGVkRGlzcGF0Y2goZGlzcGF0Y2hUaHJvdHRsZSkge1xuICAgIHJldHVybiB0aHJvdHRsZShcbiAgICAgIChpZCwgZGF0YSkgPT4ge1xuICAgICAgICB0aGlzLmRlYnVnKGBEYXRhU2VydmljZSAtIGRpc3BhdGNoaW5nICdkYXRhLWxvYWQnIHwgJHtpZH1gKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaChcImRhdGEtbG9hZFwiLCB7IHR5cGU6IFwiZGF0YS1sb2FkXCIsIGRhdGEgfSk7XG4gICAgICB9LFxuICAgICAgZGlzcGF0Y2hUaHJvdHRsZSxcbiAgICAgIHtcbiAgICAgICAgbGVhZGluZzogdHJ1ZSxcbiAgICAgICAgdHJhaWxpbmc6IHRydWVcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGFzeW5jIGZldGNoKHBhcmFtcykge1xuICAgIGlmICghdGhpcy5kYXRhU291cmNlQ2FsbGJhY2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGFTZXJ2aWNlIC0gW2RhdGFTb3VyY2UuZ2V0RGF0YV0gY2FsbGJhY2sgbm90IGluaXRpYWxpc2VkXCIpO1xuICAgIH1cbiAgICBjb25zdCBzdGFydDIgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBjb25zdCBpZCA9IHRoaXMucmVxdWVzdENvdW50ZXIrKztcbiAgICB0aGlzLmRlYnVnKGBEYXRhU2VydmljZSAtIHJlcXVlc3RpbmcgfCAke2lkfWApO1xuICAgIHRoaXMuZnJlc2hSZXF1ZXN0cy5wdXNoKGlkKTtcbiAgICBsZXQgcmVzcG9uc2U7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5kYXRhU291cmNlQ2FsbGJhY2socGFyYW1zKTtcbiAgICAgIHRoaXMuZGVidWcoYERhdGFTZXJ2aWNlIC0gcmVzcG9uc2UgfCAke3BlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnQyfW1zIHwgJHtpZH1gKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5kZWJ1ZyhgRGF0YVNlcnZpY2UgLSByZXF1ZXN0IGZhaWxlZCB8ICR7aWR9YCk7XG4gICAgICBMb2dnZXIuZXJyb3JPbmNlKGBEYXRhU2VydmljZSAtIHJlcXVlc3QgZmFpbGVkIHwgWyR7ZXJyb3J9XWApO1xuICAgIH1cbiAgICB0aGlzLmlzTG9hZGluZ0luaXRpYWxEYXRhID0gZmFsc2U7XG4gICAgY29uc3QgcmVxdWVzdEluZGV4ID0gdGhpcy5mcmVzaFJlcXVlc3RzLmZpbmRJbmRleCgocmlkKSA9PiByaWQgPT09IGlkKTtcbiAgICBpZiAocmVxdWVzdEluZGV4ID09PSAtMSB8fCB0aGlzLmRpc3BhdGNoT25seUxhdGVzdCAmJiByZXF1ZXN0SW5kZXggIT09IHRoaXMuZnJlc2hSZXF1ZXN0cy5sZW5ndGggLSAxKSB7XG4gICAgICB0aGlzLmRlYnVnKGBEYXRhU2VydmljZSAtIGRpc2NhcmRpbmcgc3RhbGUgcmVxdWVzdCB8ICR7aWR9YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZnJlc2hSZXF1ZXN0cyA9IHRoaXMuZnJlc2hSZXF1ZXN0cy5zbGljZShyZXF1ZXN0SW5kZXggKyAxKTtcbiAgICBpZiAodGhpcy5mcmVzaFJlcXVlc3RzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5pc0xvYWRpbmdEYXRhID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3BvbnNlKSkge1xuICAgICAgdGhpcy50aHJvdHRsZWREaXNwYXRjaChpZCwgcmVzcG9uc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRpc3BhdGNoKFwiZGF0YS1lcnJvclwiKTtcbiAgICB9XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBBY3Rpb25PblNldCh7XG4gICAgbmV3VmFsdWUoZGlzcGF0Y2hUaHJvdHRsZSkge1xuICAgICAgdGhpcy50aHJvdHRsZWREaXNwYXRjaCA9IHRoaXMuY3JlYXRlVGhyb3R0bGVkRGlzcGF0Y2goZGlzcGF0Y2hUaHJvdHRsZSk7XG4gICAgfVxuICB9KVxuXSwgRGF0YVNlcnZpY2UucHJvdG90eXBlLCBcImRpc3BhdGNoVGhyb3R0bGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBBY3Rpb25PblNldCh7XG4gICAgbmV3VmFsdWUocmVxdWVzdFRocm90dGxlKSB7XG4gICAgICB0aGlzLnRocm90dGxlZEZldGNoID0gdGhpcy5jcmVhdGVUaHJvdHRsZWRGZXRjaChyZXF1ZXN0VGhyb3R0bGUpO1xuICAgIH1cbiAgfSlcbl0sIERhdGFTZXJ2aWNlLnByb3RvdHlwZSwgXCJyZXF1ZXN0VGhyb3R0bGVcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2ludGVyYWN0aW9uL2FuaW1hdGlvbkJhdGNoLnRzXG52YXIgQW5pbWF0aW9uQmF0Y2ggPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG1heEFuaW1hdGlvblRpbWUpIHtcbiAgICB0aGlzLm1heEFuaW1hdGlvblRpbWUgPSBtYXhBbmltYXRpb25UaW1lO1xuICAgIHRoaXMuZGVidWcgPSBEZWJ1Zy5jcmVhdGUodHJ1ZSwgXCJhbmltYXRpb25cIik7XG4gICAgdGhpcy5jb250cm9sbGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5zdG9wcGVkQ2JzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLmN1cnJlbnRQaGFzZSA9IDA7XG4gICAgdGhpcy5waGFzZXMgPSBuZXcgTWFwKFBIQVNFX09SREVSLm1hcCgocCkgPT4gW3AsIFtdXSkpO1xuICAgIHRoaXMuc2tpcEFuaW1hdGlvbnMgPSBmYWxzZTtcbiAgICB0aGlzLmFuaW1hdGlvblRpbWVDb25zdW1lZCA9IDA7XG4gICAgLyoqIEd1YXJkIGFnYWluc3QgcHJlbWF0dXJlIGFuaW1hdGlvbiBleGVjdXRpb24uICovXG4gICAgdGhpcy5pc1JlYWR5ID0gZmFsc2U7XG4gIH1cbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udHJvbGxlcnMuc2l6ZTtcbiAgfVxuICBnZXQgY29uc3VtZWRUaW1lTXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYW5pbWF0aW9uVGltZUNvbnN1bWVkO1xuICB9XG4gIGlzQWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRyb2xsZXJzLnNpemUgPiAwO1xuICB9XG4gIGdldEFjdGl2ZUNvbnRyb2xsZXJzKCkge1xuICAgIHJldHVybiB0aGlzLnBoYXNlcy5nZXQoUEhBU0VfT1JERVJbdGhpcy5jdXJyZW50UGhhc2VdKSA/PyBbXTtcbiAgfVxuICBjaGVja092ZXJsYXBwaW5nSWQoaWQpIHtcbiAgICBpZiAoaWQgIT0gbnVsbCAmJiB0aGlzLmNvbnRyb2xsZXJzLmhhcyhpZCkpIHtcbiAgICAgIHRoaXMuY29udHJvbGxlcnMuZ2V0KGlkKS5zdG9wKCk7XG4gICAgICB0aGlzLmRlYnVnKGBTa2lwcGluZyBhbmltYXRpb24gYmF0Y2ggZHVlIHRvIHVwZGF0ZSBvZiBleGlzdGluZyBhbmltYXRpb246ICR7aWR9YCk7XG4gICAgICB0aGlzLnNraXAoKTtcbiAgICB9XG4gIH1cbiAgYWRkQW5pbWF0aW9uKGFuaW1hdGlvbikge1xuICAgIGlmIChhbmltYXRpb24uaXNDb21wbGV0ZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBhbmltYXRpb25QaGFzZUlkeCA9IFBIQVNFX09SREVSLmluZGV4T2YoYW5pbWF0aW9uLnBoYXNlKTtcbiAgICBpZiAoYW5pbWF0aW9uUGhhc2VJZHggPCB0aGlzLmN1cnJlbnRQaGFzZSkge1xuICAgICAgdGhpcy5kZWJ1ZyhgU2tpcHBpbmcgYW5pbWF0aW9uIGR1ZSB0byBiZWluZyBmb3IgYW4gZWFybGllciBwaGFzZWAsIGFuaW1hdGlvbi5pZCk7XG4gICAgICBhbmltYXRpb24uc3RvcCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmNvbnRyb2xsZXJzLnNldChhbmltYXRpb24uaWQsIGFuaW1hdGlvbik7XG4gICAgdGhpcy5waGFzZXMuZ2V0KGFuaW1hdGlvbi5waGFzZSk/LnB1c2goYW5pbWF0aW9uKTtcbiAgfVxuICByZW1vdmVBbmltYXRpb24oYW5pbWF0aW9uKSB7XG4gICAgdGhpcy5jb250cm9sbGVycy5kZWxldGUoYW5pbWF0aW9uLmlkKTtcbiAgICBjb25zdCBwaGFzZSA9IHRoaXMucGhhc2VzLmdldChhbmltYXRpb24ucGhhc2UpO1xuICAgIGNvbnN0IGluZGV4ID0gcGhhc2U/LmluZGV4T2YoYW5pbWF0aW9uKTtcbiAgICBpZiAoaW5kZXggIT0gbnVsbCAmJiBpbmRleCA+PSAwKSB7XG4gICAgICBwaGFzZT8uc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gIH1cbiAgcHJvZ3Jlc3MoZGVsdGFUaW1lKSB7XG4gICAgaWYgKCF0aGlzLmlzUmVhZHkpXG4gICAgICByZXR1cm47XG4gICAgbGV0IHVudXNlZFRpbWUgPSBkZWx0YVRpbWUgPT09IDAgPyAwLjAxIDogZGVsdGFUaW1lO1xuICAgIGNvbnN0IHJlZnJlc2ggPSAoKSA9PiB7XG4gICAgICBjb25zdCBwaGFzZTIgPSBQSEFTRV9PUkRFUlt0aGlzLmN1cnJlbnRQaGFzZV07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwaGFzZUNvbnRyb2xsZXJzOiBbLi4udGhpcy5nZXRBY3RpdmVDb250cm9sbGVycygpXSxcbiAgICAgICAgcGhhc2U6IHBoYXNlMixcbiAgICAgICAgcGhhc2VNZXRhOiBQSEFTRV9NRVRBREFUQVtwaGFzZTJdXG4gICAgICB9O1xuICAgIH07XG4gICAgbGV0IHsgcGhhc2UsIHBoYXNlQ29udHJvbGxlcnMsIHBoYXNlTWV0YSB9ID0gcmVmcmVzaCgpO1xuICAgIGNvbnN0IGFyZVBoYXNlc0NvbXBsZXRlID0gKCkgPT4gUEhBU0VfT1JERVJbdGhpcy5jdXJyZW50UGhhc2VdID09IG51bGw7XG4gICAgY29uc3QgcHJvZ3Jlc3NQaGFzZSA9ICgpID0+IHtcbiAgICAgICh7IHBoYXNlLCBwaGFzZUNvbnRyb2xsZXJzLCBwaGFzZU1ldGEgfSA9IHJlZnJlc2goKSk7XG4gICAgICB3aGlsZSAoIWFyZVBoYXNlc0NvbXBsZXRlKCkgJiYgcGhhc2VDb250cm9sbGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5jdXJyZW50UGhhc2UrKztcbiAgICAgICAgKHsgcGhhc2UsIHBoYXNlQ29udHJvbGxlcnMsIHBoYXNlTWV0YSB9ID0gcmVmcmVzaCgpKTtcbiAgICAgICAgdGhpcy5kZWJ1ZyhgQW5pbWF0aW9uQmF0Y2ggLSBwaGFzZSBjaGFuZ2luZyB0byAke3BoYXNlfWAsIHsgdW51c2VkVGltZSB9LCBwaGFzZUNvbnRyb2xsZXJzKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHRvdGFsID0gdGhpcy5jb250cm9sbGVycy5zaXplO1xuICAgIHRoaXMuZGVidWcoYEFuaW1hdGlvbkJhdGNoIC0gJHtkZWx0YVRpbWV9bXM7IHBoYXNlICR7cGhhc2V9IHdpdGggJHtwaGFzZUNvbnRyb2xsZXJzPy5sZW5ndGh9IG9mICR7dG90YWx9YCk7XG4gICAgZG8ge1xuICAgICAgY29uc3QgcGhhc2VEZWx0YVRpbWUgPSB1bnVzZWRUaW1lO1xuICAgICAgY29uc3Qgc2tpcFBoYXNlID0gcGhhc2VNZXRhLnNraXBJZk5vRWFybGllckFuaW1hdGlvbnMgJiYgdGhpcy5hbmltYXRpb25UaW1lQ29uc3VtZWQgPT09IDA7XG4gICAgICBsZXQgY29tcGxldGVDb3VudCA9IDA7XG4gICAgICBmb3IgKGNvbnN0IGNvbnRyb2xsZXIgb2YgcGhhc2VDb250cm9sbGVycykge1xuICAgICAgICBpZiAoc2tpcFBoYXNlKSB7XG4gICAgICAgICAgY29udHJvbGxlci5zdG9wKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdW51c2VkVGltZSA9IE1hdGgubWluKGNvbnRyb2xsZXIudXBkYXRlKHBoYXNlRGVsdGFUaW1lKSwgdW51c2VkVGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRyb2xsZXIuaXNDb21wbGV0ZSkge1xuICAgICAgICAgIGNvbXBsZXRlQ291bnQrKztcbiAgICAgICAgICB0aGlzLnJlbW92ZUFuaW1hdGlvbihjb250cm9sbGVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5hbmltYXRpb25UaW1lQ29uc3VtZWQgKz0gcGhhc2VEZWx0YVRpbWUgLSB1bnVzZWRUaW1lO1xuICAgICAgdGhpcy5kZWJ1ZyhgQW5pbWF0aW9uQmF0Y2ggLSB1cGRhdGVkICR7cGhhc2VDb250cm9sbGVycy5sZW5ndGh9IGNvbnRyb2xsZXJzOyAke2NvbXBsZXRlQ291bnR9IGNvbXBsZXRlZGApO1xuICAgICAgdGhpcy5kZWJ1ZyhgQW5pbWF0aW9uQmF0Y2ggLSBhbmltYXRpb25UaW1lQ29uc3VtZWQ6ICR7dGhpcy5hbmltYXRpb25UaW1lQ29uc3VtZWR9YCk7XG4gICAgICBwcm9ncmVzc1BoYXNlKCk7XG4gICAgfSB3aGlsZSAodW51c2VkVGltZSA+IDAgJiYgIWFyZVBoYXNlc0NvbXBsZXRlKCkpO1xuICAgIGlmICh0aGlzLmFuaW1hdGlvblRpbWVDb25zdW1lZCA+IHRoaXMubWF4QW5pbWF0aW9uVGltZSkge1xuICAgICAgdGhpcy5kZWJ1ZyhgQW5pbWF0aW9uIGJhdGNoIGV4Y2VlZGVkIG1heCBhbmltYXRpb24gdGltZSwgc2tpcHBpbmdgLCBbLi4udGhpcy5jb250cm9sbGVyc10pO1xuICAgICAgdGhpcy5zdG9wKCk7XG4gICAgfVxuICB9XG4gIHJlYWR5KCkge1xuICAgIGlmICh0aGlzLmlzUmVhZHkpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5pc1JlYWR5ID0gdHJ1ZTtcbiAgICB0aGlzLmRlYnVnKGBBbmltYXRpb25CYXRjaCAtIHJlYWR5OyBza2lwcGVkOiAke3RoaXMuc2tpcEFuaW1hdGlvbnN9YCwgWy4uLnRoaXMuY29udHJvbGxlcnNdKTtcbiAgICBsZXQgc2tpcEFsbCA9IHRydWU7XG4gICAgZm9yIChjb25zdCBbLCBjb250cm9sbGVyXSBvZiB0aGlzLmNvbnRyb2xsZXJzKSB7XG4gICAgICBpZiAoY29udHJvbGxlci5kdXJhdGlvbiA+IDAgJiYgUEhBU0VfTUVUQURBVEFbY29udHJvbGxlci5waGFzZV0uc2tpcElmTm9FYXJsaWVyQW5pbWF0aW9ucyAhPT0gdHJ1ZSkge1xuICAgICAgICBza2lwQWxsID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXNraXBBbGwpIHtcbiAgICAgIGZvciAoY29uc3QgWywgY29udHJvbGxlcl0gb2YgdGhpcy5jb250cm9sbGVycykge1xuICAgICAgICBpZiAoY29udHJvbGxlci5hdXRvcGxheSkge1xuICAgICAgICAgIGNvbnRyb2xsZXIucGxheSh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBza2lwKHNraXAgPSB0cnVlKSB7XG4gICAgaWYgKHRoaXMuc2tpcEFuaW1hdGlvbnMgPT09IGZhbHNlICYmIHNraXAgPT09IHRydWUpIHtcbiAgICAgIGZvciAoY29uc3QgY29udHJvbGxlciBvZiB0aGlzLmNvbnRyb2xsZXJzLnZhbHVlcygpKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuc3RvcCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5jb250cm9sbGVycy5jbGVhcigpO1xuICAgIH1cbiAgICB0aGlzLnNraXBBbmltYXRpb25zID0gc2tpcDtcbiAgfVxuICBwbGF5KCkge1xuICAgIGZvciAoY29uc3QgY29udHJvbGxlciBvZiB0aGlzLmNvbnRyb2xsZXJzLnZhbHVlcygpKSB7XG4gICAgICBjb250cm9sbGVyLnBsYXkoKTtcbiAgICB9XG4gIH1cbiAgcGF1c2UoKSB7XG4gICAgZm9yIChjb25zdCBjb250cm9sbGVyIG9mIHRoaXMuY29udHJvbGxlcnMudmFsdWVzKCkpIHtcbiAgICAgIGNvbnRyb2xsZXIucGF1c2UoKTtcbiAgICB9XG4gIH1cbiAgc3RvcCgpIHtcbiAgICBmb3IgKGNvbnN0IGNvbnRyb2xsZXIgb2YgdGhpcy5jb250cm9sbGVycy52YWx1ZXMoKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29udHJvbGxlci5zdG9wKCk7XG4gICAgICAgIHRoaXMucmVtb3ZlQW5pbWF0aW9uKGNvbnRyb2xsZXIpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgTG9nZ2VyLmVycm9yKFwiRXJyb3IgZHVyaW5nIGFuaW1hdGlvbiBzdG9wXCIsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5kaXNwYXRjaFN0b3BwZWQoKTtcbiAgfVxuICBzdG9wQnlBbmltYXRpb25JZChpZCkge1xuICAgIGlmIChpZCAhPSBudWxsICYmIHRoaXMuY29udHJvbGxlcnMuaGFzKGlkKSkge1xuICAgICAgY29uc3QgY29udHJvbGxlciA9IHRoaXMuY29udHJvbGxlcnMuZ2V0KGlkKTtcbiAgICAgIGlmIChjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuc3RvcCgpO1xuICAgICAgICB0aGlzLnJlbW92ZUFuaW1hdGlvbihjb250cm9sbGVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc3RvcEJ5QW5pbWF0aW9uR3JvdXBJZChpZCkge1xuICAgIGZvciAoY29uc3QgY29udHJvbGxlciBvZiB0aGlzLmNvbnRyb2xsZXJzLnZhbHVlcygpKSB7XG4gICAgICBpZiAoY29udHJvbGxlci5ncm91cElkID09PSBpZCkge1xuICAgICAgICB0aGlzLnN0b3BCeUFuaW1hdGlvbklkKGNvbnRyb2xsZXIuaWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBkaXNwYXRjaFN0b3BwZWQoKSB7XG4gICAgdGhpcy5zdG9wcGVkQ2JzLmZvckVhY2goKGNiKSA9PiBjYigpKTtcbiAgICB0aGlzLnN0b3BwZWRDYnMuY2xlYXIoKTtcbiAgfVxuICBpc1NraXBwZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2tpcEFuaW1hdGlvbnM7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnN0b3AoKTtcbiAgICB0aGlzLmNvbnRyb2xsZXJzLmNsZWFyKCk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2ludGVyYWN0aW9uL3ByZXZlbnRhYmxlRXZlbnQudHNcbmZ1bmN0aW9uIGJ1aWxkUHJldmVudGFibGUob2JqKSB7XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgLi4ub2JqLFxuICAgIHByZXZlbnREZWZhdWx0KCkge1xuICAgICAgc2VsZi5zb3VyY2VFdmVudD8ucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuZnVuY3Rpb24gZGlzcGF0Y2hUeXBlZEV2ZW50KGxpc3RlbmVycywgZXZlbnQpIHtcbiAgbGlzdGVuZXJzLmRpc3BhdGNoV3JhcEhhbmRsZXJzKGV2ZW50LnR5cGUsIChoYW5kbGVyLCBlKSA9PiBoYW5kbGVyKGUpLCBidWlsZFByZXZlbnRhYmxlKGV2ZW50KSk7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2ludGVyYWN0aW9uL2ludGVyYWN0aW9uTWFuYWdlci50c1xudmFyIERSQUdfSU5URVJBQ1RJT05fVFlQRVMgPSBbXCJkcmFnLXN0YXJ0XCIsIFwiZHJhZ1wiLCBcImRyYWctZW5kXCJdO1xudmFyIFBPSU5URVJfSU5URVJBQ1RJT05fVFlQRVMgPSBbXG4gIC4uLkRSQUdfSU5URVJBQ1RJT05fVFlQRVMsXG4gIFwiY2xpY2tcIixcbiAgXCJkYmxjbGlja1wiLFxuICBcImNvbnRleHRtZW51XCIsXG4gIFwiaG92ZXJcIixcbiAgXCJsZWF2ZVwiLFxuICBcImVudGVyXCIsXG4gIFwicGFnZS1sZWZ0XCIsXG4gIFwid2hlZWxcIlxuXTtcbnZhciBGT0NVU19JTlRFUkFDVElPTl9UWVBFUyA9IFtcImJsdXJcIiwgXCJmb2N1c1wiXTtcbnZhciBLRVlfSU5URVJBQ1RJT05fVFlQRVMgPSBbXCJrZXlkb3duXCIsIFwia2V5dXBcIl07XG52YXIgU0hBRE9XX0RPTV9IQU5ETEVSUyA9IFtcIm1vdXNlbW92ZVwiLCBcIm1vdXNldXBcIl07XG52YXIgV0lORE9XX0VWRU5UX0hBTkRMRVJTID0gW1wicGFnZWhpZGVcIiwgXCJtb3VzZW1vdmVcIiwgXCJtb3VzZXVwXCJdO1xudmFyIEVWRU5UX0hBTkRMRVJTID0gW1xuICBcImRibGNsaWNrXCIsXG4gIFwiY29udGV4dG1lbnVcIixcbiAgXCJtb3VzZWRvd25cIixcbiAgXCJtb3VzZWxlYXZlXCIsXG4gIFwibW91c2VlbnRlclwiLFxuICBcInRvdWNoc3RhcnRcIixcbiAgXCJ0b3VjaG1vdmVcIixcbiAgXCJ0b3VjaGVuZFwiLFxuICBcInRvdWNoY2FuY2VsXCIsXG4gIFwid2hlZWxcIixcbiAgXCJibHVyXCIsXG4gIFwiZm9jdXNcIixcbiAgXCJrZXlkb3duXCIsXG4gIFwia2V5dXBcIlxuXTtcbmZ1bmN0aW9uIGlzUG9pbnRlckV2ZW50KHR5cGUpIHtcbiAgcmV0dXJuIFBPSU5URVJfSU5URVJBQ1RJT05fVFlQRVMuaW5jbHVkZXModHlwZSk7XG59XG5mdW5jdGlvbiBpc0ZvY3VzRXZlbnQodHlwZSkge1xuICByZXR1cm4gRk9DVVNfSU5URVJBQ1RJT05fVFlQRVMuaW5jbHVkZXModHlwZSk7XG59XG5mdW5jdGlvbiBpc0tleUV2ZW50KHR5cGUpIHtcbiAgcmV0dXJuIEtFWV9JTlRFUkFDVElPTl9UWVBFUy5pbmNsdWRlcyh0eXBlKTtcbn1cbnZhciBfSW50ZXJhY3Rpb25NYW5hZ2VyID0gY2xhc3MgX0ludGVyYWN0aW9uTWFuYWdlciBleHRlbmRzIEludGVyYWN0aW9uU3RhdGVMaXN0ZW5lciB7XG4gIGNvbnN0cnVjdG9yKGtleWJvYXJkT3B0aW9ucywgZG9tTWFuYWdlcikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5rZXlib2FyZE9wdGlvbnMgPSBrZXlib2FyZE9wdGlvbnM7XG4gICAgdGhpcy5kb21NYW5hZ2VyID0gZG9tTWFuYWdlcjtcbiAgICB0aGlzLmRlYnVnID0gRGVidWcuY3JlYXRlKHRydWUsIFwiaW50ZXJhY3Rpb25cIik7XG4gICAgdGhpcy5ldmVudEhhbmRsZXIgPSAoZXZlbnQpID0+IHRoaXMucHJvY2Vzc0V2ZW50KGV2ZW50KTtcbiAgICB0aGlzLm1vdXNlRG93biA9IGZhbHNlO1xuICAgIHRoaXMudG91Y2hEb3duID0gZmFsc2U7XG4gICAgdGhpcy5jbGlja0hpc3RvcnkgPSBbeyBvZmZzZXRYOiBOYU4sIG9mZnNldFk6IE5hTiwgdHlwZTogXCJtb3VzZWRvd25cIiB9XTtcbiAgICB0aGlzLmRibGNsaWNrSGlzdG9yeSA9IFtcbiAgICAgIHsgb2Zmc2V0WDogTmFOLCBvZmZzZXRZOiBOYU4sIHR5cGU6IFwibW91c2Vkb3duXCIgfSxcbiAgICAgIHsgb2Zmc2V0WDogTmFOLCBvZmZzZXRZOiBOYU4sIHR5cGU6IFwibW91c2V1cFwiIH0sXG4gICAgICB7IG9mZnNldFg6IE5hTiwgb2Zmc2V0WTogTmFOLCB0eXBlOiBcIm1vdXNlZG93blwiIH1cbiAgICBdO1xuICAgIHRoaXMuc3RhdGVRdWV1ZSA9IDMyIC8qIERlZmF1bHQgKi8gfCAyIC8qIEFuaW1hdGlvbiAqLztcbiAgICB0aGlzLnJvb3RFbGVtZW50ID0gdGhpcy5kb21NYW5hZ2VyLmdldFNoYWRvd0RvY3VtZW50Um9vdCgpO1xuICAgIGZvciAoY29uc3QgdHlwZSBvZiBFVkVOVF9IQU5ETEVSUykge1xuICAgICAgaWYgKHR5cGUuc3RhcnRzV2l0aChcInRvdWNoXCIpIHx8IHR5cGUgPT09IFwid2hlZWxcIikge1xuICAgICAgICB0aGlzLmRvbU1hbmFnZXIuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCB0aGlzLmV2ZW50SGFuZGxlciwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZG9tTWFuYWdlci5hZGRFdmVudExpc3RlbmVyKHR5cGUsIHRoaXMuZXZlbnRIYW5kbGVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCB0eXBlIG9mIFdJTkRPV19FVkVOVF9IQU5ETEVSUykge1xuICAgICAgZ2V0V2luZG93KCkuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCB0aGlzLmV2ZW50SGFuZGxlcik7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyQ2hhbmdlZCh0cnVlKTtcbiAgICB0aGlzLmRvbU1hbmFnZXIuYWRkTGlzdGVuZXIoXCJjb250YWluZXItY2hhbmdlZFwiLCAoKSA9PiB0aGlzLmNvbnRhaW5lckNoYW5nZWQoKSk7XG4gIH1cbiAgY29udGFpbmVyQ2hhbmdlZChmb3JjZSA9IGZhbHNlKSB7XG4gICAgY29uc3QgbmV3Um9vdCA9IHRoaXMuZG9tTWFuYWdlci5nZXRTaGFkb3dEb2N1bWVudFJvb3QoKTtcbiAgICBpZiAoIWZvcmNlICYmIG5ld1Jvb3QgPT09IHRoaXMucm9vdEVsZW1lbnQpXG4gICAgICByZXR1cm47XG4gICAgZm9yIChjb25zdCB0eXBlIG9mIFNIQURPV19ET01fSEFORExFUlMpIHtcbiAgICAgIHRoaXMucm9vdEVsZW1lbnQ/LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgdGhpcy5ldmVudEhhbmRsZXIpO1xuICAgIH1cbiAgICB0aGlzLnJvb3RFbGVtZW50ID0gbmV3Um9vdDtcbiAgICB0aGlzLmRlYnVnKFwiW0ludGVyYWN0aW9uTWFuYWdlcl0gU3dpdGNoaW5nIHJvb3RFbGVtZW50IHRvOlwiLCB0aGlzLnJvb3RFbGVtZW50KTtcbiAgICBmb3IgKGNvbnN0IHR5cGUgb2YgU0hBRE9XX0RPTV9IQU5ETEVSUykge1xuICAgICAgdGhpcy5yb290RWxlbWVudD8uYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCB0aGlzLmV2ZW50SGFuZGxlcik7XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIGZvciAoY29uc3QgdHlwZSBvZiBXSU5ET1dfRVZFTlRfSEFORExFUlMpIHtcbiAgICAgIGdldFdpbmRvdygpLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgdGhpcy5ldmVudEhhbmRsZXIpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHR5cGUgb2YgU0hBRE9XX0RPTV9IQU5ETEVSUykge1xuICAgICAgdGhpcy5yb290RWxlbWVudD8ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCB0aGlzLmV2ZW50SGFuZGxlcik7XG4gICAgfVxuICAgIGZvciAoY29uc3QgdHlwZSBvZiBFVkVOVF9IQU5ETEVSUykge1xuICAgICAgdGhpcy5kb21NYW5hZ2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgdGhpcy5ldmVudEhhbmRsZXIpO1xuICAgIH1cbiAgICB0aGlzLmRvbU1hbmFnZXIucmVtb3ZlU3R5bGVzKFwiaW50ZXJhY3Rpb25NYW5hZ2VyXCIpO1xuICB9XG4gIHB1c2hTdGF0ZShzdGF0ZSkge1xuICAgIHRoaXMuc3RhdGVRdWV1ZSB8PSBzdGF0ZTtcbiAgfVxuICBwb3BTdGF0ZShzdGF0ZSkge1xuICAgIHRoaXMuc3RhdGVRdWV1ZSAmPSB+c3RhdGU7XG4gIH1cbiAgZ2V0U3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVRdWV1ZSAmIC10aGlzLnN0YXRlUXVldWU7XG4gIH1cbiAgcHJvY2Vzc0V2ZW50KGV2ZW50KSB7XG4gICAgdGhpcy5kZWJ1ZyhcIlJlY2VpdmVkIHJhdyBldmVudFwiLCBldmVudCk7XG4gICAgbGV0IHR5cGVzID0gdGhpcy5kZWNpZGVJbnRlcmFjdGlvbkV2ZW50VHlwZXMoZXZlbnQpO1xuICAgIGlmICh0eXBlcyAhPSBudWxsICYmICFBcnJheS5pc0FycmF5KHR5cGVzKSkge1xuICAgICAgdHlwZXMgPSBbdHlwZXNdO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHR5cGUgb2YgdHlwZXMgPz8gW10pIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCwgdHlwZSkuY2F0Y2goKGUpID0+IExvZ2dlci5lcnJvck9uY2UoZSkpO1xuICAgIH1cbiAgfVxuICBhc3luYyBkaXNwYXRjaEV2ZW50KGV2ZW50LCB0eXBlKSB7XG4gICAgaWYgKGlzUG9pbnRlckV2ZW50KHR5cGUpKSB7XG4gICAgICB0aGlzLmRpc3BhdGNoUG9pbnRlckV2ZW50KGV2ZW50LCB0eXBlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyByZWxhdGVkRWxlbWVudCwgdGFyZ2V0RWxlbWVudCB9ID0gdGhpcy5leHRyYWN0RWxlbWVudHMoZXZlbnQpO1xuICAgIGlmIChpc0ZvY3VzRXZlbnQodHlwZSkpIHtcbiAgICAgIGNvbnN0IHNvdXJjZUV2ZW50ID0gZXZlbnQ7XG4gICAgICB0aGlzLmRpc3BhdGNoVHlwZWRFdmVudCh0aGlzLmxpc3RlbmVycywgeyB0eXBlLCBzb3VyY2VFdmVudCwgcmVsYXRlZEVsZW1lbnQsIHRhcmdldEVsZW1lbnQgfSk7XG4gICAgfSBlbHNlIGlmIChpc0tleUV2ZW50KHR5cGUpKSB7XG4gICAgICBjb25zdCBzb3VyY2VFdmVudCA9IGV2ZW50O1xuICAgICAgdGhpcy5kaXNwYXRjaFR5cGVkRXZlbnQodGhpcy5saXN0ZW5lcnMsIHsgdHlwZSwgc291cmNlRXZlbnQsIHJlbGF0ZWRFbGVtZW50LCB0YXJnZXRFbGVtZW50IH0pO1xuICAgIH1cbiAgfVxuICBkaXNwYXRjaFR5cGVkRXZlbnQobGlzdGVuZXJzLCBldmVudCkge1xuICAgIGNvbnN0IHByZXZlbnRhYmxlRXZlbnQgPSBidWlsZFByZXZlbnRhYmxlKGV2ZW50KTtcbiAgICB0aGlzLmRlYnVnKFwiRGlzcGF0Y2hpbmcgdHlwZWQgZXZlbnRcIiwgcHJldmVudGFibGVFdmVudCwgdGhpcy5nZXRTdGF0ZSgpKTtcbiAgICBsaXN0ZW5lcnMuZGlzcGF0Y2hXcmFwSGFuZGxlcnMoZXZlbnQudHlwZSwgKGhhbmRsZXIsIGUpID0+IGhhbmRsZXIoZSksIHByZXZlbnRhYmxlRXZlbnQpO1xuICB9XG4gIGV4dHJhY3RFbGVtZW50cyhldmVudCkge1xuICAgIGxldCByZWxhdGVkRWxlbWVudDtcbiAgICBsZXQgdGFyZ2V0RWxlbWVudDtcbiAgICBpZiAoXCJyZWxhdGVkVGFyZ2V0XCIgaW4gZXZlbnQgJiYgZXZlbnRbXCJyZWxhdGVkVGFyZ2V0XCJdIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgIHJlbGF0ZWRFbGVtZW50ID0gZXZlbnRbXCJyZWxhdGVkVGFyZ2V0XCJdO1xuICAgIH1cbiAgICBpZiAoXCJ0YXJnZXRcIiBpbiBldmVudCAmJiBldmVudFtcInRhcmdldFwiXSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICB0YXJnZXRFbGVtZW50ID0gZXZlbnRbXCJ0YXJnZXRcIl07XG4gICAgfVxuICAgIHJldHVybiB7IHJlbGF0ZWRFbGVtZW50LCB0YXJnZXRFbGVtZW50IH07XG4gIH1cbiAgZGlzcGF0Y2hQb2ludGVyRXZlbnQoZXZlbnQsIHR5cGUpIHtcbiAgICBjb25zdCBjb29yZHMgPSB0aGlzLmNhbGN1bGF0ZUNvb3JkaW5hdGVzKGV2ZW50KTtcbiAgICBpZiAoY29vcmRzID09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgcG9pbnRlckV2ZW50ID0gdGhpcy5idWlsZFBvaW50ZXJFdmVudCh7IHR5cGUsIGV2ZW50LCAuLi5jb29yZHMgfSk7XG4gICAgdGhpcy5kZWJ1ZyhcIkRpc3BhdGNoaW5nIHBvaW50ZXIgZXZlbnRcIiwgcG9pbnRlckV2ZW50LCB0aGlzLmdldFN0YXRlKCkpO1xuICAgIGRpc3BhdGNoVHlwZWRFdmVudCh0aGlzLmxpc3RlbmVycywgcG9pbnRlckV2ZW50KTtcbiAgfVxuICBnZXRFdmVudEhUTUxUYXJnZXQoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBldmVudC50YXJnZXQ7XG4gICAgfSBlbHNlIGlmIChldmVudC5jdXJyZW50VGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJlY29yZERvd24oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQgaW5zdGFuY2VvZiBNb3VzZUV2ZW50KSB7XG4gICAgICBwYXJ0aWFsQXNzaWduKFtcIm9mZnNldFhcIiwgXCJvZmZzZXRZXCJdLCB0aGlzLmNsaWNrSGlzdG9yeVswXSwgZXZlbnQpO1xuICAgICAgcGFydGlhbEFzc2lnbihbXCJvZmZzZXRYXCIsIFwib2Zmc2V0WVwiXSwgdGhpcy5kYmxjbGlja0hpc3RvcnlbMl0sIHRoaXMuZGJsY2xpY2tIaXN0b3J5WzBdKTtcbiAgICAgIHBhcnRpYWxBc3NpZ24oW1wib2Zmc2V0WFwiLCBcIm9mZnNldFlcIl0sIHRoaXMuZGJsY2xpY2tIaXN0b3J5WzBdLCBldmVudCk7XG4gICAgfVxuICAgIHRoaXMuZHJhZ1ByZVN0YXJ0RWxlbWVudCA9IHRoaXMuZ2V0RXZlbnRIVE1MVGFyZ2V0KGV2ZW50KTtcbiAgfVxuICByZWNvcmRVcChldmVudCkge1xuICAgIGlmIChldmVudCBpbnN0YW5jZW9mIE1vdXNlRXZlbnQpIHtcbiAgICAgIHBhcnRpYWxBc3NpZ24oW1wib2Zmc2V0WFwiLCBcIm9mZnNldFlcIl0sIHRoaXMuZGJsY2xpY2tIaXN0b3J5WzFdLCBldmVudCk7XG4gICAgfVxuICAgIHRoaXMuZHJhZ1ByZVN0YXJ0RWxlbWVudCA9IHZvaWQgMDtcbiAgICBpZiAodGhpcy5kcmFnU3RhcnRFbGVtZW50KSB7XG4gICAgICB0aGlzLmRyYWdTdGFydEVsZW1lbnQgPSB2b2lkIDA7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGRlY2lkZUludGVyYWN0aW9uRXZlbnRUeXBlcyhldmVudCkge1xuICAgIGNvbnN0IGRyYWdTdGFydCA9IFwiZHJhZy1zdGFydFwiO1xuICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgY2FzZSBcImJsdXJcIjpcbiAgICAgIGNhc2UgXCJmb2N1c1wiOlxuICAgICAgY2FzZSBcImtleWRvd25cIjpcbiAgICAgIGNhc2UgXCJrZXl1cFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5rZXlib2FyZE9wdGlvbnMuZW5hYmxlZCA/IGV2ZW50LnR5cGUgOiB2b2lkIDA7XG4gICAgICBjYXNlIFwiZGJsY2xpY2tcIjpcbiAgICAgICAgcmV0dXJuIGV2ZW50LnR5cGU7XG4gICAgICBjYXNlIFwiY29udGV4dG1lbnVcIjpcbiAgICAgIGNhc2UgXCJ3aGVlbFwiOlxuICAgICAgICByZXR1cm4gZXZlbnQudHlwZTtcbiAgICAgIGNhc2UgXCJtb3VzZWRvd25cIjpcbiAgICAgICAgaWYgKCF0aGlzLmlzRXZlbnRPdmVyRWxlbWVudChldmVudCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb3VzZURvd24gPSB0cnVlO1xuICAgICAgICB0aGlzLnJlY29yZERvd24oZXZlbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwidG91Y2hzdGFydFwiOlxuICAgICAgICBpZiAoIXRoaXMuaXNFdmVudE92ZXJFbGVtZW50KGV2ZW50KSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRvdWNoRG93biA9IHRydWU7XG4gICAgICAgIHRoaXMucmVjb3JkRG93bihldmVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJ0b3VjaG1vdmVcIjpcbiAgICAgIGNhc2UgXCJtb3VzZW1vdmVcIjpcbiAgICAgICAgaWYgKCF0aGlzLm1vdXNlRG93biAmJiAhdGhpcy50b3VjaERvd24gJiYgIXRoaXMuaXNFdmVudE92ZXJFbGVtZW50KGV2ZW50KSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMubW91c2VEb3duICYmICF0aGlzLnRvdWNoRG93bilcbiAgICAgICAgICByZXR1cm4gXCJob3ZlclwiO1xuICAgICAgICBpZiAodGhpcy5kcmFnU3RhcnRFbGVtZW50KVxuICAgICAgICAgIHJldHVybiBcImRyYWdcIjtcbiAgICAgICAgdGhpcy5kcmFnU3RhcnRFbGVtZW50ID0gdGhpcy5kcmFnUHJlU3RhcnRFbGVtZW50O1xuICAgICAgICB0aGlzLmRyYWdQcmVTdGFydEVsZW1lbnQgPSB2b2lkIDA7XG4gICAgICAgIHJldHVybiBbZHJhZ1N0YXJ0LCBcImRyYWdcIl07XG4gICAgICBjYXNlIFwibW91c2V1cFwiOlxuICAgICAgICBpZiAoIXRoaXMubW91c2VEb3duICYmICF0aGlzLmlzRXZlbnRPdmVyRWxlbWVudChldmVudCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb3VzZURvd24gPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVjb3JkVXAoZXZlbnQpID8gXCJkcmFnLWVuZFwiIDogXCJjbGlja1wiO1xuICAgICAgY2FzZSBcInRvdWNoZW5kXCI6XG4gICAgICAgIGlmICghdGhpcy50b3VjaERvd24gJiYgIXRoaXMuaXNFdmVudE92ZXJFbGVtZW50KGV2ZW50KSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRvdWNoRG93biA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcy5yZWNvcmRVcChldmVudCkgPyBcImRyYWctZW5kXCIgOiBcImNsaWNrXCI7XG4gICAgICBjYXNlIFwibW91c2VsZWF2ZVwiOlxuICAgICAgY2FzZSBcInRvdWNoY2FuY2VsXCI6XG4gICAgICAgIHJldHVybiBcImxlYXZlXCI7XG4gICAgICBjYXNlIFwibW91c2VlbnRlclwiOlxuICAgICAgICByZXR1cm4gXCJlbnRlclwiO1xuICAgICAgY2FzZSBcInBhZ2VoaWRlXCI6XG4gICAgICAgIHJldHVybiBcInBhZ2UtbGVmdFwiO1xuICAgIH1cbiAgfVxuICBpc0V2ZW50T3ZlckVsZW1lbnQoZXZlbnQpIHtcbiAgICByZXR1cm4gdGhpcy5kb21NYW5hZ2VyLmlzRXZlbnRPdmVyRWxlbWVudChldmVudCk7XG4gIH1cbiAgY2FsY3VsYXRlQ29vcmRpbmF0ZXMoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQgaW5zdGFuY2VvZiBNb3VzZUV2ZW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRNb3VzZUV2ZW50Q29vcmRzKGV2ZW50KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBUb3VjaEV2ZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIGV2ZW50IGluc3RhbmNlb2YgVG91Y2hFdmVudCkge1xuICAgICAgY29uc3QgbGFzdFRvdWNoID0gZXZlbnQudG91Y2hlc1swXSA/PyBldmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICAgIGNvbnN0IHsgY2xpZW50WCwgY2xpZW50WSwgcGFnZVgsIHBhZ2VZIH0gPSBsYXN0VG91Y2g7XG4gICAgICByZXR1cm4geyAuLi5fSW50ZXJhY3Rpb25NYW5hZ2VyLk5VTExfQ09PUkRTLCBjbGllbnRYLCBjbGllbnRZLCBwYWdlWCwgcGFnZVkgfTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50IGluc3RhbmNlb2YgUGFnZVRyYW5zaXRpb25FdmVudCkge1xuICAgICAgaWYgKGV2ZW50LnBlcnNpc3RlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gX0ludGVyYWN0aW9uTWFuYWdlci5OVUxMX0NPT1JEUztcbiAgICB9XG4gIH1cbiAgZ2V0TW91c2VFdmVudENvb3JkcyhldmVudCkge1xuICAgIGNvbnN0IHsgY2xpZW50WCwgY2xpZW50WSwgcGFnZVgsIHBhZ2VZIH0gPSBldmVudDtcbiAgICBsZXQgeyBvZmZzZXRYLCBvZmZzZXRZIH0gPSBldmVudDtcbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzLmdldEV2ZW50SFRNTFRhcmdldChldmVudCk7XG4gICAgY29uc3QgeyB4ID0gMCwgeSA9IDAgfSA9IHRhcmdldCA/IHRoaXMuZG9tTWFuYWdlci5jYWxjdWxhdGVDYW52YXNQb3NpdGlvbih0YXJnZXQpIDoge307XG4gICAgaWYgKHRoaXMuZHJhZ1N0YXJ0RWxlbWVudCAhPSBudWxsICYmIGV2ZW50LnRhcmdldCAhPT0gdGhpcy5kcmFnU3RhcnRFbGVtZW50KSB7XG4gICAgICBjb25zdCBvZmZzZXREcmFnU3RhcnQgPSB0aGlzLmRvbU1hbmFnZXIuY2FsY3VsYXRlQ2FudmFzUG9zaXRpb24odGhpcy5kcmFnU3RhcnRFbGVtZW50KTtcbiAgICAgIG9mZnNldFggLT0gb2Zmc2V0RHJhZ1N0YXJ0LnggLSB4O1xuICAgICAgb2Zmc2V0WSAtPSBvZmZzZXREcmFnU3RhcnQueSAtIHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldFggKz0geDtcbiAgICAgIG9mZnNldFkgKz0geTtcbiAgICB9XG4gICAgcmV0dXJuIHsgY2xpZW50WCwgY2xpZW50WSwgcGFnZVgsIHBhZ2VZLCBvZmZzZXRYLCBvZmZzZXRZIH07XG4gIH1cbiAgaXNXaGVlbEV2ZW50KGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LnR5cGUgPT09IFwid2hlZWxcIjtcbiAgfVxuICBidWlsZFBvaW50ZXJFdmVudChvcHRzKSB7XG4gICAgY29uc3QgeyB0eXBlLCBldmVudCwgY2xpZW50WCwgY2xpZW50WSB9ID0gb3B0cztcbiAgICBsZXQgeyBvZmZzZXRYLCBvZmZzZXRZLCBwYWdlWCwgcGFnZVkgfSA9IG9wdHM7XG4gICAgaWYgKCFpc0Zpbml0ZU51bWJlcihvZmZzZXRYKSB8fCAhaXNGaW5pdGVOdW1iZXIob2Zmc2V0WSkpIHtcbiAgICAgIGNvbnN0IHJlY3QgPSB0aGlzLmRvbU1hbmFnZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBvZmZzZXRYID0gY2xpZW50WCAtIHJlY3QubGVmdDtcbiAgICAgIG9mZnNldFkgPSBjbGllbnRZIC0gcmVjdC50b3A7XG4gICAgfVxuICAgIGlmICghaXNGaW5pdGVOdW1iZXIocGFnZVgpIHx8ICFpc0Zpbml0ZU51bWJlcihwYWdlWSkpIHtcbiAgICAgIGNvbnN0IHBhZ2VSZWN0ID0gdGhpcy5yb290RWxlbWVudD8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBwYWdlWCA9IGNsaWVudFggLSAocGFnZVJlY3Q/LmxlZnQgPz8gMCk7XG4gICAgICBwYWdlWSA9IGNsaWVudFkgLSAocGFnZVJlY3Q/LnRvcCA/PyAwKTtcbiAgICB9XG4gICAgbGV0IFtkZWx0YVgsIGRlbHRhWV0gPSBbTmFOLCBOYU5dO1xuICAgIGlmICh0aGlzLmlzV2hlZWxFdmVudChldmVudCkpIHtcbiAgICAgIGNvbnN0IGZhY3RvciA9IGV2ZW50LmRlbHRhTW9kZSA9PT0gMCA/IDAuMDEgOiAxO1xuICAgICAgZGVsdGFYID0gZXZlbnQuZGVsdGFYICogZmFjdG9yO1xuICAgICAgZGVsdGFZID0gZXZlbnQuZGVsdGFZICogZmFjdG9yO1xuICAgIH1cbiAgICBsZXQgcG9pbnRlckhpc3RvcnkgPSBbXTtcbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiKSB7XG4gICAgICBwb2ludGVySGlzdG9yeSA9IHRoaXMuY2xpY2tIaXN0b3J5O1xuICAgIH0gZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gXCJkYmxjbGlja1wiKSB7XG4gICAgICBwb2ludGVySGlzdG9yeSA9IHRoaXMuZGJsY2xpY2tIaXN0b3J5O1xuICAgIH1cbiAgICBjb25zdCB7IHJlbGF0ZWRFbGVtZW50LCB0YXJnZXRFbGVtZW50IH0gPSB0aGlzLmV4dHJhY3RFbGVtZW50cyhldmVudCk7XG4gICAgY29uc3QgYnV0dG9uID0gXCJidXR0b25cIiBpbiBldmVudCA/IE51bWJlcihldmVudC5idXR0b24pIDogMDtcbiAgICBjb25zdCBidWlsdEV2ZW50ID0ge1xuICAgICAgdHlwZSxcbiAgICAgIG9mZnNldFgsXG4gICAgICBvZmZzZXRZLFxuICAgICAgcGFnZVgsXG4gICAgICBwYWdlWSxcbiAgICAgIGRlbHRhWCxcbiAgICAgIGRlbHRhWSxcbiAgICAgIGJ1dHRvbixcbiAgICAgIHBvaW50ZXJIaXN0b3J5LFxuICAgICAgc291cmNlRXZlbnQ6IGV2ZW50LFxuICAgICAgcmVsYXRlZEVsZW1lbnQsXG4gICAgICB0YXJnZXRFbGVtZW50XG4gICAgfTtcbiAgICB0aGlzLmRlYnVnKFwiSW50ZXJhY3Rpb25NYW5hZ2VyIC0gYnVpbHRFdmVudDogXCIsIGJ1aWx0RXZlbnQsIHRoaXMuZ2V0U3RhdGUoKSk7XG4gICAgcmV0dXJuIGJ1aWx0RXZlbnQ7XG4gIH1cbn07XG5fSW50ZXJhY3Rpb25NYW5hZ2VyLk5VTExfQ09PUkRTID0ge1xuICBjbGllbnRYOiAtSW5maW5pdHksXG4gIGNsaWVudFk6IC1JbmZpbml0eSxcbiAgcGFnZVg6IC1JbmZpbml0eSxcbiAgcGFnZVk6IC1JbmZpbml0eSxcbiAgb2Zmc2V0WDogLUluZmluaXR5LFxuICBvZmZzZXRZOiAtSW5maW5pdHlcbn07XG52YXIgSW50ZXJhY3Rpb25NYW5hZ2VyID0gX0ludGVyYWN0aW9uTWFuYWdlcjtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvaW50ZXJhY3Rpb24vYW5pbWF0aW9uTWFuYWdlci50c1xuZnVuY3Rpb24gdmFsaWRBbmltYXRpb25EdXJhdGlvbih0ZXN0ZWUpIHtcbiAgaWYgKHRlc3RlZSA9PSBudWxsKVxuICAgIHJldHVybiB0cnVlO1xuICByZXR1cm4gIWlzTmFOKHRlc3RlZSkgJiYgdGVzdGVlID49IDAgJiYgdGVzdGVlIDw9IDI7XG59XG52YXIgQW5pbWF0aW9uTWFuYWdlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoaW50ZXJhY3Rpb25NYW5hZ2VyLCBjaGFydFVwZGF0ZU11dGV4KSB7XG4gICAgdGhpcy5pbnRlcmFjdGlvbk1hbmFnZXIgPSBpbnRlcmFjdGlvbk1hbmFnZXI7XG4gICAgdGhpcy5jaGFydFVwZGF0ZU11dGV4ID0gY2hhcnRVcGRhdGVNdXRleDtcbiAgICB0aGlzLmRlZmF1bHREdXJhdGlvbiA9IDFlMztcbiAgICB0aGlzLmJhdGNoID0gbmV3IEFuaW1hdGlvbkJhdGNoKHRoaXMuZGVmYXVsdER1cmF0aW9uICogMS41KTtcbiAgICB0aGlzLmRlYnVnID0gRGVidWcuY3JlYXRlKHRydWUsIFwiYW5pbWF0aW9uXCIpO1xuICAgIHRoaXMuZXZlbnRzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIHRoaXMucmFmQXZhaWxhYmxlID0gdHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgICB0aGlzLmlzUGxheWluZyA9IHRydWU7XG4gICAgdGhpcy5yZXF1ZXN0SWQgPSBudWxsO1xuICAgIHRoaXMuc2tpcEFuaW1hdGlvbnMgPSB0cnVlO1xuICAgIHRoaXMuY3VycmVudEFub255bW91c0FuaW1hdGlvbklkID0gMDtcbiAgfVxuICBhZGRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZXZlbnRzLm9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gYW5pbWF0aW9uIHRvIHR3ZWVuIGEgdmFsdWUgYmV0d2VlbiB0aGUgYGZyb21gIGFuZCBgdG9gIHByb3BlcnRpZXMuIElmIGFuIGFuaW1hdGlvbiBhbHJlYWR5IGV4aXN0c1xuICAgKiB3aXRoIHRoZSBzYW1lIGBpZGAsIGltbWVkaWF0ZWx5IHN0b3AgaXQuXG4gICAqL1xuICBhbmltYXRlKG9wdHMpIHtcbiAgICBjb25zdCBiYXRjaCA9IHRoaXMuYmF0Y2g7XG4gICAgdHJ5IHtcbiAgICAgIGJhdGNoLmNoZWNrT3ZlcmxhcHBpbmdJZChvcHRzLmlkKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5mYWlsc2FmZU9uRXJyb3IoZXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgeyBpZCB9ID0gb3B0cztcbiAgICBpZiAoaWQgPT0gbnVsbCkge1xuICAgICAgaWQgPSBgX18ke3RoaXMuY3VycmVudEFub255bW91c0FuaW1hdGlvbklkfWA7XG4gICAgICB0aGlzLmN1cnJlbnRBbm9ueW1vdXNBbmltYXRpb25JZCArPSAxO1xuICAgIH1cbiAgICBjb25zdCBza2lwID0gdGhpcy5pc1NraXBwZWQoKSB8fCBvcHRzLnBoYXNlID09PSBcIm5vbmVcIjtcbiAgICBpZiAoc2tpcCkge1xuICAgICAgdGhpcy5kZWJ1ZyhcIkFuaW1hdGlvbk1hbmFnZXIgLSBza2lwcGluZyBhbmltYXRpb25cIik7XG4gICAgfVxuICAgIGNvbnN0IHsgZGVsYXksIGR1cmF0aW9uIH0gPSBvcHRzO1xuICAgIGlmICghdmFsaWRBbmltYXRpb25EdXJhdGlvbihkZWxheSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQW5pbWF0aW9uIGRlbGF5IG9mICR7ZGVsYXl9IGlzIHVuc3VwcG9ydGVkICgke2lkfSlgKTtcbiAgICB9XG4gICAgaWYgKCF2YWxpZEFuaW1hdGlvbkR1cmF0aW9uKGR1cmF0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbmltYXRpb24gZHVyYXRpb24gb2YgJHtkdXJhdGlvbn0gaXMgdW5zdXBwb3J0ZWQgKCR7aWR9KWApO1xuICAgIH1cbiAgICBjb25zdCBhbmltYXRpb24gPSBuZXcgQW5pbWF0aW9uKHtcbiAgICAgIC4uLm9wdHMsXG4gICAgICBpZCxcbiAgICAgIHNraXAsXG4gICAgICBhdXRvcGxheTogdGhpcy5pc1BsYXlpbmcgPyBvcHRzLmF1dG9wbGF5IDogZmFsc2UsXG4gICAgICBwaGFzZTogb3B0cy5waGFzZSxcbiAgICAgIGRlZmF1bHREdXJhdGlvbjogdGhpcy5kZWZhdWx0RHVyYXRpb25cbiAgICB9KTtcbiAgICBpZiAodGhpcy5mb3JjZVRpbWVKdW1wKGFuaW1hdGlvbiwgdGhpcy5kZWZhdWx0RHVyYXRpb24pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYmF0Y2guYWRkQW5pbWF0aW9uKGFuaW1hdGlvbik7XG4gICAgcmV0dXJuIGFuaW1hdGlvbjtcbiAgfVxuICBwbGF5KCkge1xuICAgIGlmICh0aGlzLmlzUGxheWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmlzUGxheWluZyA9IHRydWU7XG4gICAgdGhpcy5kZWJ1ZyhcIkFuaW1hdGlvbk1hbmFnZXIucGxheSgpXCIpO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmJhdGNoLnBsYXkoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5mYWlsc2FmZU9uRXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgICB0aGlzLnJlcXVlc3RBbmltYXRpb24oKTtcbiAgfVxuICBwYXVzZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNQbGF5aW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG4gICAgdGhpcy5jYW5jZWxBbmltYXRpb24oKTtcbiAgICB0aGlzLmRlYnVnKFwiQW5pbWF0aW9uTWFuYWdlci5wYXVzZSgpXCIpO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmJhdGNoLnBhdXNlKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMuZmFpbHNhZmVPbkVycm9yKGVycm9yKTtcbiAgICB9XG4gIH1cbiAgc3RvcCgpIHtcbiAgICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuICAgIHRoaXMuY2FuY2VsQW5pbWF0aW9uKCk7XG4gICAgdGhpcy5kZWJ1ZyhcIkFuaW1hdGlvbk1hbmFnZXIuc3RvcCgpXCIpO1xuICAgIHRoaXMuYmF0Y2guc3RvcCgpO1xuICB9XG4gIHN0b3BCeUFuaW1hdGlvbklkKGlkKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuYmF0Y2guc3RvcEJ5QW5pbWF0aW9uSWQoaWQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmZhaWxzYWZlT25FcnJvcihlcnJvcik7XG4gICAgfVxuICB9XG4gIHN0b3BCeUFuaW1hdGlvbkdyb3VwSWQoaWQpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5iYXRjaC5zdG9wQnlBbmltYXRpb25Hcm91cElkKGlkKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5mYWlsc2FmZU9uRXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfVxuICByZXNldCgpIHtcbiAgICBpZiAodGhpcy5pc1BsYXlpbmcpIHtcbiAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgdGhpcy5wbGF5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RvcCgpO1xuICAgIH1cbiAgfVxuICBza2lwKHNraXAgPSB0cnVlKSB7XG4gICAgdGhpcy5za2lwQW5pbWF0aW9ucyA9IHNraXA7XG4gIH1cbiAgaXNTa2lwcGVkKCkge1xuICAgIHJldHVybiAhdGhpcy5yYWZBdmFpbGFibGUgfHwgdGhpcy5za2lwQW5pbWF0aW9ucyB8fCB0aGlzLmJhdGNoLmlzU2tpcHBlZCgpO1xuICB9XG4gIGlzQWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLmlzUGxheWluZyAmJiB0aGlzLmJhdGNoLmlzQWN0aXZlKCk7XG4gIH1cbiAgc2tpcEN1cnJlbnRCYXRjaCgpIHtcbiAgICBpZiAodGhpcy5kZWJ1Zy5jaGVjaygpKSB7XG4gICAgICB0aGlzLmRlYnVnKGBBbmltYXRpb25NYW5hZ2VyIC0gc2tpcEN1cnJlbnRCYXRjaCgpYCwgeyBzdGFjazogbmV3IEVycm9yKCkuc3RhY2sgfSk7XG4gICAgfVxuICAgIHRoaXMuYmF0Y2guc2tpcCgpO1xuICB9XG4gIC8qKiBNb2NraW5nIHBvaW50IGZvciB0ZXN0cyB0byBndWFyYW50ZWUgdGhhdCBhbmltYXRpb24gdXBkYXRlcyBoYXBwZW4uICovXG4gIGlzU2tpcHBpbmdGcmFtZXMoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqIE1vY2tpbmcgcG9pbnQgZm9yIHRlc3RzIHRvIGNhcHR1cmUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGNhbGxiYWNrcy4gKi9cbiAgc2NoZWR1bGVBbmltYXRpb25GcmFtZShjYikge1xuICAgIHRoaXMucmVxdWVzdElkID0gZ2V0V2luZG93KCkucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNiKTtcbiAgfVxuICAvKiogTW9ja2luZyBwb2ludCBmb3IgdGVzdHMgdG8gc2tpcCBhbmltYXRpb25zIHRvIGEgc3BlY2lmaWMgcG9pbnQgaW4gdGltZS4gKi9cbiAgZm9yY2VUaW1lSnVtcChfYW5pbWF0aW9uLCBfZGVmYXVsdER1cmF0aW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJlcXVlc3RBbmltYXRpb24oKSB7XG4gICAgaWYgKCF0aGlzLnJhZkF2YWlsYWJsZSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAoIXRoaXMuYmF0Y2guaXNBY3RpdmUoKSB8fCB0aGlzLnJlcXVlc3RJZCAhPT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICBsZXQgcHJldlRpbWU7XG4gICAgY29uc3Qgb25BbmltYXRpb25GcmFtZSA9IGFzeW5jICh0aW1lMikgPT4ge1xuICAgICAgY29uc3QgZXhlY3V0ZUFuaW1hdGlvbkZyYW1lID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBkZWx0YVRpbWUgPSB0aW1lMiAtIChwcmV2VGltZSA/PyB0aW1lMik7XG4gICAgICAgIHByZXZUaW1lID0gdGltZTI7XG4gICAgICAgIHRoaXMuZGVidWcoXCJBbmltYXRpb25NYW5hZ2VyIC0gb25BbmltYXRpb25GcmFtZSgpXCIsIHtcbiAgICAgICAgICBjb250cm9sbGVyc0NvdW50OiB0aGlzLmJhdGNoLnNpemUsXG4gICAgICAgICAgZGVsdGFUaW1lXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmludGVyYWN0aW9uTWFuYWdlci5wdXNoU3RhdGUoMiAvKiBBbmltYXRpb24gKi8pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuYmF0Y2gucHJvZ3Jlc3MoZGVsdGFUaW1lKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB0aGlzLmZhaWxzYWZlT25FcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ldmVudHMuZW1pdChcImFuaW1hdGlvbi1mcmFtZVwiLCB7XG4gICAgICAgICAgdHlwZTogXCJhbmltYXRpb24tZnJhbWVcIixcbiAgICAgICAgICBkZWx0YU1zOiBkZWx0YVRpbWVcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuaXNTa2lwcGluZ0ZyYW1lcygpKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuY2hhcnRVcGRhdGVNdXRleC5hY3F1aXJlSW1tZWRpYXRlbHkoZXhlY3V0ZUFuaW1hdGlvbkZyYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF3YWl0IHRoaXMuY2hhcnRVcGRhdGVNdXRleC5hY3F1aXJlKGV4ZWN1dGVBbmltYXRpb25GcmFtZSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5iYXRjaC5pc0FjdGl2ZSgpKSB7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVBbmltYXRpb25GcmFtZShvbkFuaW1hdGlvbkZyYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYmF0Y2guc3RvcCgpO1xuICAgICAgICB0aGlzLmV2ZW50cy5lbWl0KFwiYW5pbWF0aW9uLXN0b3BcIiwge1xuICAgICAgICAgIHR5cGU6IFwiYW5pbWF0aW9uLXN0b3BcIixcbiAgICAgICAgICBkZWx0YU1zOiB0aGlzLmJhdGNoLmNvbnN1bWVkVGltZU1zXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5ldmVudHMuZW1pdChcImFuaW1hdGlvbi1zdGFydFwiLCB7XG4gICAgICB0eXBlOiBcImFuaW1hdGlvbi1zdGFydFwiLFxuICAgICAgZGVsdGFNczogMFxuICAgIH0pO1xuICAgIHRoaXMuc2NoZWR1bGVBbmltYXRpb25GcmFtZShvbkFuaW1hdGlvbkZyYW1lKTtcbiAgfVxuICBjYW5jZWxBbmltYXRpb24oKSB7XG4gICAgaWYgKHRoaXMucmVxdWVzdElkID09PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMucmVxdWVzdElkKTtcbiAgICB0aGlzLnJlcXVlc3RJZCA9IG51bGw7XG4gICAgdGhpcy5zdGFydEJhdGNoKCk7XG4gIH1cbiAgZmFpbHNhZmVPbkVycm9yKGVycm9yLCBjYW5jZWxBbmltYXRpb24gPSB0cnVlKSB7XG4gICAgTG9nZ2VyLmVycm9yKFwiRXJyb3IgZHVyaW5nIGFuaW1hdGlvbiwgc2tpcHBpbmcgYW5pbWF0aW9uc1wiLCBlcnJvcik7XG4gICAgaWYgKGNhbmNlbEFuaW1hdGlvbikge1xuICAgICAgdGhpcy5jYW5jZWxBbmltYXRpb24oKTtcbiAgICB9XG4gIH1cbiAgc3RhcnRCYXRjaChza2lwQW5pbWF0aW9ucykge1xuICAgIHRoaXMuZGVidWcoYEFuaW1hdGlvbk1hbmFnZXIgLSBzdGFydEJhdGNoKCkgd2l0aCBza2lwQW5pbWF0aW9ucz0ke3NraXBBbmltYXRpb25zfS5gKTtcbiAgICB0aGlzLnJlc2V0KCk7XG4gICAgdGhpcy5iYXRjaC5kZXN0cm95KCk7XG4gICAgdGhpcy5iYXRjaCA9IG5ldyBBbmltYXRpb25CYXRjaCh0aGlzLmRlZmF1bHREdXJhdGlvbiAqIDEuNSk7XG4gICAgaWYgKHNraXBBbmltYXRpb25zID09PSB0cnVlKSB7XG4gICAgICB0aGlzLmJhdGNoLnNraXAoKTtcbiAgICB9XG4gIH1cbiAgZW5kQmF0Y2goKSB7XG4gICAgaWYgKHRoaXMuYmF0Y2guaXNBY3RpdmUoKSkge1xuICAgICAgdGhpcy5iYXRjaC5yZWFkeSgpO1xuICAgICAgdGhpcy5yZXF1ZXN0QW5pbWF0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaW50ZXJhY3Rpb25NYW5hZ2VyLnBvcFN0YXRlKDIgLyogQW5pbWF0aW9uICovKTtcbiAgICAgIGlmICh0aGlzLmJhdGNoLmlzU2tpcHBlZCgpKSB7XG4gICAgICAgIHRoaXMuYmF0Y2guc2tpcChmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIG9uQmF0Y2hTdG9wKGNiKSB7XG4gICAgdGhpcy5iYXRjaC5zdG9wcGVkQ2JzLmFkZChjYik7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnN0b3AoKTtcbiAgICB0aGlzLmV2ZW50cy5jbGVhcigpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9pbnRlcmFjdGlvbi9jaGFydEV2ZW50TWFuYWdlci50c1xudmFyIENoYXJ0RXZlbnRNYW5hZ2VyID0gY2xhc3MgZXh0ZW5kcyBCYXNlTWFuYWdlciB7XG4gIGxlZ2VuZEl0ZW1DbGljayhzZXJpZXMsIGl0ZW1JZCwgZW5hYmxlZCwgbGVnZW5kSXRlbU5hbWUpIHtcbiAgICBjb25zdCBldmVudCA9IHtcbiAgICAgIHR5cGU6IFwibGVnZW5kLWl0ZW0tY2xpY2tcIixcbiAgICAgIHNlcmllcyxcbiAgICAgIGl0ZW1JZCxcbiAgICAgIGVuYWJsZWQsXG4gICAgICBsZWdlbmRJdGVtTmFtZVxuICAgIH07XG4gICAgdGhpcy5saXN0ZW5lcnMuZGlzcGF0Y2goXCJsZWdlbmQtaXRlbS1jbGlja1wiLCBldmVudCk7XG4gIH1cbiAgbGVnZW5kSXRlbURvdWJsZUNsaWNrKHNlcmllcywgaXRlbUlkLCBlbmFibGVkLCBudW1WaXNpYmxlSXRlbXMsIGxlZ2VuZEl0ZW1OYW1lKSB7XG4gICAgY29uc3QgZXZlbnQgPSB7XG4gICAgICB0eXBlOiBcImxlZ2VuZC1pdGVtLWRvdWJsZS1jbGlja1wiLFxuICAgICAgc2VyaWVzLFxuICAgICAgaXRlbUlkLFxuICAgICAgZW5hYmxlZCxcbiAgICAgIGxlZ2VuZEl0ZW1OYW1lLFxuICAgICAgbnVtVmlzaWJsZUl0ZW1zXG4gICAgfTtcbiAgICB0aGlzLmxpc3RlbmVycy5kaXNwYXRjaChcImxlZ2VuZC1pdGVtLWRvdWJsZS1jbGlja1wiLCBldmVudCk7XG4gIH1cbiAgYXhpc0hvdmVyKGF4aXNJZCwgZGlyZWN0aW9uKSB7XG4gICAgY29uc3QgZXZlbnQgPSB7XG4gICAgICB0eXBlOiBcImF4aXMtaG92ZXJcIixcbiAgICAgIGF4aXNJZCxcbiAgICAgIGRpcmVjdGlvblxuICAgIH07XG4gICAgdGhpcy5saXN0ZW5lcnMuZGlzcGF0Y2goXCJheGlzLWhvdmVyXCIsIGV2ZW50KTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvaW50ZXJhY3Rpb24vY29udGV4dE1lbnVSZWdpc3RyeS50c1xudmFyIENvbnRleHRNZW51UmVnaXN0cnkgPSBjbGFzcyBfQ29udGV4dE1lbnVSZWdpc3RyeSB7XG4gIGNvbnN0cnVjdG9yKHJlZ2lvbk1hbmFnZXIpIHtcbiAgICB0aGlzLmRlZmF1bHRBY3Rpb25zID0gW107XG4gICAgdGhpcy5kaXNhYmxlZEFjdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMuaGlkZGVuQWN0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy5saXN0ZW5lcnMgPSBuZXcgTGlzdGVuZXJzKCk7XG4gICAgY29uc3QgeyBEZWZhdWx0OiBEZWZhdWx0MiwgQ29udGV4dE1lbnUgfSA9IEludGVyYWN0aW9uU3RhdGU7XG4gICAgdGhpcy5kZXN0cm95Rm5zID0gW3JlZ2lvbk1hbmFnZXIubGlzdGVuQWxsKFwiY29udGV4dG1lbnVcIiwgKGUpID0+IHRoaXMub25Db250ZXh0TWVudShlKSwgRGVmYXVsdDIgfCBDb250ZXh0TWVudSldO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXN0cm95Rm5zLmZvckVhY2goKGQpID0+IGQoKSk7XG4gIH1cbiAgb25Db250ZXh0TWVudShldmVudCkge1xuICAgIGNvbnN0IHR5cGUgPSBfQ29udGV4dE1lbnVSZWdpc3RyeS50b0NvbnRleHRUeXBlKGV2ZW50LnJlZ2lvbik7XG4gICAgaWYgKHR5cGUgPT09IFwiYWxsXCIpIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hDb250ZXh0KFwiYWxsXCIsIGV2ZW50LCB7fSk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyB0b0NvbnRleHRUeXBlKHJlZ2lvbikge1xuICAgIGlmIChyZWdpb24gPT09IFwibGVnZW5kXCIgfHwgcmVnaW9uID09PSBcInNlcmllc1wiKSB7XG4gICAgICByZXR1cm4gcmVnaW9uO1xuICAgIH1cbiAgICByZXR1cm4gXCJhbGxcIjtcbiAgfVxuICBzdGF0aWMgY2hlY2sodHlwZSwgZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQudHlwZSA9PT0gdHlwZTtcbiAgfVxuICBzdGF0aWMgY2hlY2tDYWxsYmFjayhkZXNpcmVkVHlwZSwgdHlwZSwgX2NhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGRlc2lyZWRUeXBlID09PSB0eXBlO1xuICB9XG4gIGRpc3BhdGNoQ29udGV4dCh0eXBlLCBwb2ludGVyRXZlbnQsIGNvbnRleHQsIHBvc2l0aW9uKSB7XG4gICAgY29uc3QgeyBzb3VyY2VFdmVudCB9ID0gcG9pbnRlckV2ZW50O1xuICAgIGNvbnN0IHggPSBwb3NpdGlvbj8ueCA/PyBwb2ludGVyRXZlbnQub2Zmc2V0WDtcbiAgICBjb25zdCB5ID0gcG9zaXRpb24/LnkgPz8gcG9pbnRlckV2ZW50Lm9mZnNldFk7XG4gICAgc291cmNlRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgdGhpcy5saXN0ZW5lcnMuZGlzcGF0Y2goXCJcIiwgYnVpbGRQcmV2ZW50YWJsZSh7IHR5cGUsIHgsIHksIGNvbnRleHQsIHNvdXJjZUV2ZW50IH0pKTtcbiAgfVxuICBhZGRMaXN0ZW5lcihoYW5kbGVyKSB7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXJzLmFkZExpc3RlbmVyKFwiXCIsIGhhbmRsZXIpO1xuICB9XG4gIGZpbHRlckFjdGlvbnModHlwZSkge1xuICAgIHJldHVybiB0aGlzLmRlZmF1bHRBY3Rpb25zLmZpbHRlcigoYWN0aW9uKSA9PiB7XG4gICAgICByZXR1cm4gYWN0aW9uLmlkICYmICF0aGlzLmhpZGRlbkFjdGlvbnMuaGFzKGFjdGlvbi5pZCkgJiYgW1wiYWxsXCIsIHR5cGVdLmluY2x1ZGVzKGFjdGlvbi50eXBlKTtcbiAgICB9KTtcbiAgfVxuICByZWdpc3RlckRlZmF1bHRBY3Rpb24oYWN0aW9uKSB7XG4gICAgY29uc3QgZGlkQWRkID0gYWN0aW9uLmlkICE9IG51bGwgJiYgIXRoaXMuZGVmYXVsdEFjdGlvbnMuc29tZSgoeyBpZCB9KSA9PiBpZCA9PT0gYWN0aW9uLmlkKTtcbiAgICBpZiAoZGlkQWRkKSB7XG4gICAgICB0aGlzLmRlZmF1bHRBY3Rpb25zLnB1c2goYWN0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNvbnN0IGluZGV4ID0gZGlkQWRkID8gdGhpcy5kZWZhdWx0QWN0aW9ucy5maW5kSW5kZXgoKHsgaWQgfSkgPT4gaWQgPT09IGFjdGlvbi5pZCkgOiAtMTtcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy5kZWZhdWx0QWN0aW9ucy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZW5hYmxlQWN0aW9uKGFjdGlvbklkKSB7XG4gICAgdGhpcy5kaXNhYmxlZEFjdGlvbnMuZGVsZXRlKGFjdGlvbklkKTtcbiAgfVxuICBkaXNhYmxlQWN0aW9uKGFjdGlvbklkKSB7XG4gICAgdGhpcy5kaXNhYmxlZEFjdGlvbnMuYWRkKGFjdGlvbklkKTtcbiAgfVxuICBzaG93QWN0aW9uKGFjdGlvbklkKSB7XG4gICAgdGhpcy5oaWRkZW5BY3Rpb25zLmFkZChhY3Rpb25JZCk7XG4gIH1cbiAgaGlkZUFjdGlvbihhY3Rpb25JZCkge1xuICAgIHRoaXMuaGlkZGVuQWN0aW9ucy5kZWxldGUoYWN0aW9uSWQpO1xuICB9XG4gIGlzRGlzYWJsZWQoYWN0aW9uSWQpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNhYmxlZEFjdGlvbnMuaGFzKGFjdGlvbklkKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9zdGF0ZVRyYWNrZXIudHNcbnZhciBTdGF0ZVRyYWNrZXIgPSBjbGFzcyBleHRlbmRzIE1hcCB7XG4gIGNvbnN0cnVjdG9yKGRlZmF1bHRWYWx1ZSwgZGVmYXVsdFN0YXRlKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmRlZmF1bHRWYWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICB0aGlzLmRlZmF1bHRTdGF0ZSA9IGRlZmF1bHRTdGF0ZTtcbiAgfVxuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuZGVsZXRlKGtleSk7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgc3VwZXIuc2V0KGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzdGF0ZUlkKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMua2V5cygpKS5wb3AoKSA/PyB0aGlzLmRlZmF1bHRTdGF0ZTtcbiAgfVxuICBzdGF0ZVZhbHVlKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMudmFsdWVzKCkpLnBvcCgpID8/IHRoaXMuZGVmYXVsdFZhbHVlO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9pbnRlcmFjdGlvbi9jdXJzb3JNYW5hZ2VyLnRzXG52YXIgQ3Vyc29yID0gLyogQF9fUFVSRV9fICovICgoQ3Vyc29yMikgPT4ge1xuICBDdXJzb3IyW1wiQXV0b1wiXSA9IFwiYXV0b1wiO1xuICBDdXJzb3IyW1wiRGVmYXVsdFwiXSA9IFwiZGVmYXVsdFwiO1xuICBDdXJzb3IyW1wiR3JhYlwiXSA9IFwiZ3JhYlwiO1xuICBDdXJzb3IyW1wiR3JhYmJpbmdcIl0gPSBcImdyYWJiaW5nXCI7XG4gIEN1cnNvcjJbXCJNb3ZlXCJdID0gXCJtb3ZlXCI7XG4gIEN1cnNvcjJbXCJOb3RBbGxvd2VkXCJdID0gXCJub3QtYWxsb3dlZFwiO1xuICBDdXJzb3IyW1wiUG9pbnRlclwiXSA9IFwicG9pbnRlclwiO1xuICBDdXJzb3IyW1wiRVdSZXNpemVcIl0gPSBcImV3LXJlc2l6ZVwiO1xuICBDdXJzb3IyW1wiTlNSZXNpemVcIl0gPSBcIm5zLXJlc2l6ZVwiO1xuICBDdXJzb3IyW1wiWm9vbUluXCJdID0gXCJ6b29tLWluXCI7XG4gIEN1cnNvcjJbXCJab29tT3V0XCJdID0gXCJ6b29tLW91dFwiO1xuICByZXR1cm4gQ3Vyc29yMjtcbn0pKEN1cnNvciB8fCB7fSk7XG52YXIgQ3Vyc29yTWFuYWdlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZG9tTWFuYWdlcikge1xuICAgIHRoaXMuZG9tTWFuYWdlciA9IGRvbU1hbmFnZXI7XG4gICAgdGhpcy5zdGF0ZVRyYWNrZXIgPSBuZXcgU3RhdGVUcmFja2VyKFwiZGVmYXVsdFwiKTtcbiAgfVxuICB1cGRhdGVDdXJzb3IoY2FsbGVySWQsIHN0eWxlKSB7XG4gICAgdGhpcy5zdGF0ZVRyYWNrZXIuc2V0KGNhbGxlcklkLCBzdHlsZSk7XG4gICAgdGhpcy5kb21NYW5hZ2VyLnVwZGF0ZUN1cnNvcih0aGlzLnN0YXRlVHJhY2tlci5zdGF0ZVZhbHVlKCkpO1xuICB9XG4gIGdldEN1cnNvcigpIHtcbiAgICByZXR1cm4gdGhpcy5kb21NYW5hZ2VyLmdldEN1cnNvcigpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9pbnRlcmFjdGlvbi9nZXN0dXJlRGV0ZWN0b3IudHNcbmZ1bmN0aW9uIGRpc3RhbmNlU3F1YXJlZChmaW5nZXIxLCBmaW5nZXIyKSB7XG4gIGNvbnN0IGR4ID0gZmluZ2VyMS5zY3JlZW5YIC0gZmluZ2VyMi5zY3JlZW5YO1xuICBjb25zdCBkeSA9IGZpbmdlcjEuc2NyZWVuWSAtIGZpbmdlcjIuc2NyZWVuWTtcbiAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xufVxuZnVuY3Rpb24gZGlzdGFuY2UoZmluZ2VyMSwgZmluZ2VyMikge1xuICByZXR1cm4gTWF0aC5zcXJ0KGRpc3RhbmNlU3F1YXJlZChmaW5nZXIxLCBmaW5nZXIyKSk7XG59XG52YXIgTUlOX0RJU1RBTkNFX1RPX1NUQVJUX1BJTkNIID0gMTtcbnZhciBHZXN0dXJlRGV0ZWN0b3IgPSBjbGFzcyBleHRlbmRzIEJhc2VNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoZG9tTWFuYWdlcikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5kb21NYW5hZ2VyID0gZG9tTWFuYWdlcjtcbiAgICB0aGlzLnRvdWNoc3RhcnQgPSAoZXZlbnQpID0+IHRoaXMub25Ub3VjaFN0YXJ0KGV2ZW50KTtcbiAgICB0aGlzLnRvdWNobW92ZSA9IChldmVudCkgPT4gdGhpcy5vblRvdWNoTW92ZShldmVudCk7XG4gICAgdGhpcy50b3VjaGVuZCA9IChldmVudCkgPT4gdGhpcy5vblRvdWNoRW5kKGV2ZW50KTtcbiAgICB0aGlzLnRvdWNoY2FuY2VsID0gKGV2ZW50KSA9PiB0aGlzLm9uVG91Y2hDYW5jZWwoZXZlbnQpO1xuICAgIHRoaXMucGluY2ggPSB7XG4gICAgICBmaW5nZXIxOiB7IGlkZW50aWZpZXI6IE5hTiwgc2NyZWVuWDogTmFOLCBzY3JlZW5ZOiBOYU4gfSxcbiAgICAgIGZpbmdlcjI6IHsgaWRlbnRpZmllcjogTmFOLCBzY3JlZW5YOiBOYU4sIHNjcmVlblk6IE5hTiB9LFxuICAgICAgb3JpZ2luOiB7IHg6IE5hTiwgeTogTmFOIH0sXG4gICAgICBkaXN0YW5jZTogTmFOLFxuICAgICAgc3RhdHVzOiAwIC8qIE9mZiAqL1xuICAgIH07XG4gICAgdGhpcy5kb21NYW5hZ2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIHRoaXMudG91Y2hzdGFydCwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgIHRoaXMuZG9tTWFuYWdlci5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHRoaXMudG91Y2htb3ZlLCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICAgIHRoaXMuZG9tTWFuYWdlci5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy50b3VjaGVuZCk7XG4gICAgdGhpcy5kb21NYW5hZ2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGNhbmNlbFwiLCB0aGlzLnRvdWNoY2FuY2VsKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZG9tTWFuYWdlci5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCB0aGlzLnRvdWNoc3RhcnQpO1xuICAgIHRoaXMuZG9tTWFuYWdlci5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHRoaXMudG91Y2htb3ZlKTtcbiAgICB0aGlzLmRvbU1hbmFnZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMudG91Y2hlbmQpO1xuICAgIHRoaXMuZG9tTWFuYWdlci5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hjYW5jZWxcIiwgdGhpcy50b3VjaGNhbmNlbCk7XG4gIH1cbiAgZmluZFBpbmNoVG91Y2hlcyhtb3ZlRXZlbnQpIHtcbiAgICBjb25zdCB7IHRvdWNoZXMgfSA9IG1vdmVFdmVudDtcbiAgICBjb25zdCB7IGZpbmdlcjEsIGZpbmdlcjIgfSA9IHRoaXMucGluY2g7XG4gICAgaWYgKHRoaXMucGluY2guc3RhdHVzICE9PSAwIC8qIE9mZiAqLyAmJiB0b3VjaGVzLmxlbmd0aCA9PT0gMikge1xuICAgICAgaWYgKHRvdWNoZXNbMF0uaWRlbnRpZmllciA9PT0gZmluZ2VyMS5pZGVudGlmaWVyICYmIHRvdWNoZXNbMV0uaWRlbnRpZmllciA9PT0gZmluZ2VyMi5pZGVudGlmaWVyKSB7XG4gICAgICAgIHJldHVybiBbdG91Y2hlc1swXSwgdG91Y2hlc1sxXV07XG4gICAgICB9XG4gICAgICBpZiAodG91Y2hlc1swXS5pZGVudGlmaWVyID09PSBmaW5nZXIyLmlkZW50aWZpZXIgJiYgdG91Y2hlc1sxXS5pZGVudGlmaWVyID09PSBmaW5nZXIxLmlkZW50aWZpZXIpIHtcbiAgICAgICAgcmV0dXJuIFt0b3VjaGVzWzFdLCB0b3VjaGVzWzBdXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29weVRvdWNoRGF0YShldmVudCkge1xuICAgIGNvbnN0IGtleXMgPSBbXCJpZGVudGlmaWVyXCIsIFwic2NyZWVuWFwiLCBcInNjcmVlbllcIl07XG4gICAgcGFydGlhbEFzc2lnbihrZXlzLCB0aGlzLnBpbmNoLmZpbmdlcjEsIGV2ZW50LnRvdWNoZXNbMF0pO1xuICAgIHBhcnRpYWxBc3NpZ24oa2V5cywgdGhpcy5waW5jaC5maW5nZXIyLCBldmVudC50b3VjaGVzWzFdKTtcbiAgICB0aGlzLnBpbmNoLmRpc3RhbmNlID0gZGlzdGFuY2UodGhpcy5waW5jaC5maW5nZXIxLCB0aGlzLnBpbmNoLmZpbmdlcjIpO1xuICB9XG4gIGRpc3BhdGNoUGluY2hFdmVudCh0eXBlLCBkZWx0YURpc3RhbmNlLCBzb3VyY2VFdmVudCkge1xuICAgIGNvbnN0IHsgZmluZ2VyMSwgZmluZ2VyMiwgb3JpZ2luOiBvcmlnaW4zIH0gPSB0aGlzLnBpbmNoO1xuICAgIHRoaXMubGlzdGVuZXJzLmRpc3BhdGNoKHR5cGUsIGJ1aWxkUHJldmVudGFibGUoeyBzb3VyY2VFdmVudCwgdHlwZSwgZmluZ2VyMSwgZmluZ2VyMiwgZGVsdGFEaXN0YW5jZSwgb3JpZ2luOiBvcmlnaW4zIH0pKTtcbiAgfVxuICBvblRvdWNoU3RhcnQoZXZlbnQpIHtcbiAgICB0aGlzLnN0b3BQaW5jaFRyYWNraW5nKGV2ZW50KTtcbiAgICBjb25zdCB7IHBpbmNoIH0gPSB0aGlzO1xuICAgIGlmIChldmVudC50b3VjaGVzLmxlbmd0aCA9PT0gMikge1xuICAgICAgcGluY2guc3RhdHVzID0gMSAvKiBJbml0aWFsaXplZCAqLztcbiAgICAgIHRoaXMuY29weVRvdWNoRGF0YShldmVudCk7XG4gICAgICBwaW5jaC5vcmlnaW4ueCA9IChldmVudC50b3VjaGVzWzBdLmNsaWVudFggKyBldmVudC50b3VjaGVzWzFdLmNsaWVudFgpIC8gMjtcbiAgICAgIHBpbmNoLm9yaWdpbi55ID0gKGV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WSArIGV2ZW50LnRvdWNoZXNbMV0uY2xpZW50WSkgLyAyO1xuICAgIH1cbiAgfVxuICBvblRvdWNoTW92ZShldmVudCkge1xuICAgIGNvbnN0IHBpbmNoVG91Y2hlcyA9IHRoaXMuZmluZFBpbmNoVG91Y2hlcyhldmVudCk7XG4gICAgaWYgKHBpbmNoVG91Y2hlcyAhPT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBbdG91Y2gxLCB0b3VjaDJdID0gcGluY2hUb3VjaGVzO1xuICAgICAgY29uc3QgeyBwaW5jaCB9ID0gdGhpcztcbiAgICAgIGNvbnN0IG5ld0Rpc3RhbmNlID0gZGlzdGFuY2UodG91Y2gxLCB0b3VjaDIpO1xuICAgICAgY29uc3QgZGVsdGFEaXN0YW5jZSA9IG5ld0Rpc3RhbmNlIC0gcGluY2guZGlzdGFuY2U7XG4gICAgICBpZiAocGluY2guc3RhdHVzID09PSAxIC8qIEluaXRpYWxpemVkICovKSB7XG4gICAgICAgIGlmIChNYXRoLmFicyhkZWx0YURpc3RhbmNlKSA+IE1JTl9ESVNUQU5DRV9UT19TVEFSVF9QSU5DSCkge1xuICAgICAgICAgIHBpbmNoLnN0YXR1cyA9IDIgLyogUnVubmluZyAqLztcbiAgICAgICAgICB0aGlzLmNvcHlUb3VjaERhdGEoZXZlbnQpO1xuICAgICAgICAgIHRoaXMuZGlzcGF0Y2hQaW5jaEV2ZW50KFwicGluY2gtc3RhcnRcIiwgMCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBpbmNoLnN0YXR1cyA9PT0gMiAvKiBSdW5uaW5nICovKSB7XG4gICAgICAgIHBpbmNoLmRpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgIHRoaXMuY29weVRvdWNoRGF0YShldmVudCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hQaW5jaEV2ZW50KFwicGluY2gtbW92ZVwiLCBkZWx0YURpc3RhbmNlLCBldmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBMb2dnZXIuZXJyb3IoYHVuZXhwZWN0ZWQgcGluY2guc3RhdHVzOiAke3BpbmNoLnN0YXR1c31gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgb25Ub3VjaEVuZChldmVudCkge1xuICAgIHRoaXMuc3RvcFBpbmNoVHJhY2tpbmcoZXZlbnQpO1xuICB9XG4gIG9uVG91Y2hDYW5jZWwoZXZlbnQpIHtcbiAgICB0aGlzLnN0b3BQaW5jaFRyYWNraW5nKGV2ZW50KTtcbiAgfVxuICBzdG9wUGluY2hUcmFja2luZyhldmVudCkge1xuICAgIGNvbnN0IHsgcGluY2ggfSA9IHRoaXM7XG4gICAgaWYgKHBpbmNoLnN0YXR1cyA9PT0gMiAvKiBSdW5uaW5nICovKSB7XG4gICAgICB0aGlzLmRpc3BhdGNoUGluY2hFdmVudChcInBpbmNoLWVuZFwiLCAwLCBldmVudCk7XG4gICAgfVxuICAgIHRoaXMucGluY2guc3RhdHVzID0gMCAvKiBPZmYgKi87XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2ludGVyYWN0aW9uL2hpZ2hsaWdodE1hbmFnZXIudHNcbnZhciBIaWdobGlnaHRNYW5hZ2VyID0gY2xhc3MgZXh0ZW5kcyBCYXNlTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5oaWdobGlnaHRTdGF0ZXMgPSBuZXcgU3RhdGVUcmFja2VyKCk7XG4gIH1cbiAgdXBkYXRlSGlnaGxpZ2h0KGNhbGxlcklkLCBoaWdobGlnaHRlZERhdHVtKSB7XG4gICAgY29uc3QgeyBhY3RpdmVIaWdobGlnaHQ6IHByZXZpb3VzSGlnaGxpZ2h0IH0gPSB0aGlzO1xuICAgIHRoaXMuaGlnaGxpZ2h0U3RhdGVzLnNldChjYWxsZXJJZCwgaGlnaGxpZ2h0ZWREYXR1bSk7XG4gICAgdGhpcy5hY3RpdmVIaWdobGlnaHQgPSB0aGlzLmhpZ2hsaWdodFN0YXRlcy5zdGF0ZVZhbHVlKCk7XG4gICAgaWYgKCF0aGlzLmlzRXF1YWwodGhpcy5hY3RpdmVIaWdobGlnaHQsIHByZXZpb3VzSGlnaGxpZ2h0KSkge1xuICAgICAgdGhpcy5saXN0ZW5lcnMuZGlzcGF0Y2goXCJoaWdobGlnaHQtY2hhbmdlXCIsIHtcbiAgICAgICAgdHlwZTogXCJoaWdobGlnaHQtY2hhbmdlXCIsXG4gICAgICAgIGN1cnJlbnRIaWdobGlnaHQ6IHRoaXMuYWN0aXZlSGlnaGxpZ2h0LFxuICAgICAgICBwcmV2aW91c0hpZ2hsaWdodCxcbiAgICAgICAgY2FsbGVySWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBnZXRBY3RpdmVIaWdobGlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWN0aXZlSGlnaGxpZ2h0O1xuICB9XG4gIGlzRXF1YWwoYSwgYikge1xuICAgIHJldHVybiBhID09PSBiIHx8IGEgIT0gbnVsbCAmJiBiICE9IG51bGwgJiYgYT8uc2VyaWVzID09PSBiPy5zZXJpZXMgJiYgYT8uaXRlbUlkID09PSBiPy5pdGVtSWQgJiYgYT8uZGF0dW0gPT09IGI/LmRhdHVtO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9pbnRlcmFjdGlvbi9rZXlOYXZNYW5hZ2VyLnRzXG52YXIgS2V5TmF2TWFuYWdlciA9IGNsYXNzIGV4dGVuZHMgSW50ZXJhY3Rpb25TdGF0ZUxpc3RlbmVyIHtcbiAgY29uc3RydWN0b3IoZm9jdXNJbmRpY2F0b3IsIGludGVyYWN0aW9uTWFuYWdlciwgbW9kZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5mb2N1c0luZGljYXRvciA9IGZvY3VzSW5kaWNhdG9yO1xuICAgIHRoaXMuaW50ZXJhY3Rpb25NYW5hZ2VyID0gaW50ZXJhY3Rpb25NYW5hZ2VyO1xuICAgIC8vIFRoaXMgaXMgdGhlIFwic2Vjb25kIGxhc3RcIiBpbnB1dCBldmVudC4gSXQgY2FuIGJlIHVzZWZ1bCBmb3Iga2V5ZG93blxuICAgIC8vIGV2ZW50cyB0aGF0IGZvciB3aGljaCBkb24ndCB0byBzZXQgdGhlIGlzRm9jdXNWaXNpYmxlIHN0YXRlXG4gICAgLy8gKGUuZy4gQmFja3NwYWNlL0RlbGV0ZSBrZXkgb24gRkMgYW5ub3RhdGlvbnMsIHNlZSBBRy0xMzA0MSkuXG4gICAgLy9cbiAgICAvLyBVc2Ugd2l0aCBjYXV0aW9uISBUaGUgZm9jdXMgaW5kaWNhdG9yIG11c3QgQUxXQVlTIGJlIHZpc2libGUgZm9yXG4gICAgLy8ga2V5Ym9hcmQtb25seSB1c2Vycy5cbiAgICB0aGlzLnByZXZpb3VzSW5wdXREZXZpY2UgPSBcImtleWJvYXJkXCI7XG4gICAgY29uc3QgbW91c2VTdGF0ZXMgPSAzMiAvKiBEZWZhdWx0ICovIHwgOCAvKiBBbm5vdGF0aW9ucyAqLyB8IDEgLyogQW5ub3RhdGlvbnNTZWxlY3RlZCAqLztcbiAgICB0aGlzLmRlc3Ryb3lGbnMucHVzaChcbiAgICAgIGludGVyYWN0aW9uTWFuYWdlci5hZGRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHRoaXMub25DbGljaygpLCBtb3VzZVN0YXRlcyksXG4gICAgICBpbnRlcmFjdGlvbk1hbmFnZXIuYWRkTGlzdGVuZXIoXCJob3ZlclwiLCAoKSA9PiB0aGlzLm9uTW91c2UoKSwgbW91c2VTdGF0ZXMpLFxuICAgICAgaW50ZXJhY3Rpb25NYW5hZ2VyLmFkZExpc3RlbmVyKFwiZHJhZy1zdGFydFwiLCAoKSA9PiB0aGlzLm9uTW91c2UoKSwgbW91c2VTdGF0ZXMpLFxuICAgICAgaW50ZXJhY3Rpb25NYW5hZ2VyLmFkZExpc3RlbmVyKFwiYmx1clwiLCAoZSkgPT4gdGhpcy5vbkJsdXIoZSksIDYzIC8qIEFsbCAqLyksXG4gICAgICBpbnRlcmFjdGlvbk1hbmFnZXIuYWRkTGlzdGVuZXIoXCJmb2N1c1wiLCAoZSkgPT4gdGhpcy5vbkZvY3VzKGUpLCA2MyAvKiBBbGwgKi8pLFxuICAgICAgaW50ZXJhY3Rpb25NYW5hZ2VyLmFkZExpc3RlbmVyKFwia2V5ZG93blwiLCAoZSkgPT4gdGhpcy5vbktleURvd24oZSksIDYzIC8qIEFsbCAqLylcbiAgICApO1xuICAgIHRoaXMuZm9jdXNJbmRpY2F0b3Iub3ZlcnJpZGVGb2N1c1Zpc2libGUobW9kZSA9PT0gXCJpbnRlZ3JhdGVkXCIgPyBmYWxzZSA6IHZvaWQgMCk7XG4gIH1cbiAgZ2V0U3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW50ZXJhY3Rpb25NYW5hZ2VyLmdldFN0YXRlKCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gIH1cbiAgb25DbGljaygpIHtcbiAgICB0aGlzLmZvY3VzSW5kaWNhdG9yLm92ZXJyaWRlRm9jdXNWaXNpYmxlKGZhbHNlKTtcbiAgICB0aGlzLnByZXZpb3VzSW5wdXREZXZpY2UgPSBcIm1vdXNlXCI7XG4gIH1cbiAgb25Nb3VzZSgpIHtcbiAgICB0aGlzLnByZXZpb3VzSW5wdXREZXZpY2UgPSBcIm1vdXNlXCI7XG4gIH1cbiAgb25CbHVyKGV2ZW50KSB7XG4gICAgdGhpcy5mb2N1c0luZGljYXRvci5vdmVycmlkZUZvY3VzVmlzaWJsZSh2b2lkIDApO1xuICAgIHRoaXMuZGlzcGF0Y2goXCJibHVyXCIsIDAsIGV2ZW50KTtcbiAgfVxuICBvbkZvY3VzKGV2ZW50KSB7XG4gICAgdGhpcy5kaXNwYXRjaChcImZvY3VzXCIsIDAsIGV2ZW50KTtcbiAgfVxuICBvbktleURvd24oZXZlbnQpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCB7IGtleSwgY29kZSwgYWx0S2V5LCBzaGlmdEtleSwgbWV0YUtleSwgY3RybEtleSB9ID0gZXZlbnQuc291cmNlRXZlbnQ7XG4gICAgaWYgKGN0cmxLZXkgfHwgbWV0YUtleSkge1xuICAgICAgaWYgKGtleSA9PT0gXCJ5XCIgfHwga2V5ID09PSBcInpcIiAmJiBzaGlmdEtleSkge1xuICAgICAgICB0aGlzLmZvY3VzSW5kaWNhdG9yLm92ZXJyaWRlRm9jdXNWaXNpYmxlKHRoaXMucHJldmlvdXNJbnB1dERldmljZSA9PT0gXCJrZXlib2FyZFwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJyZWRvXCIsIDAsIGV2ZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcInpcIikge1xuICAgICAgICB0aGlzLmZvY3VzSW5kaWNhdG9yLm92ZXJyaWRlRm9jdXNWaXNpYmxlKHRoaXMucHJldmlvdXNJbnB1dERldmljZSA9PT0gXCJrZXlib2FyZFwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJ1bmRvXCIsIDAsIGV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0YXRlICYgKDggLyogQW5ub3RhdGlvbnMgKi8gfCAxIC8qIEFubm90YXRpb25zU2VsZWN0ZWQgKi8pKSB7XG4gICAgICB0aGlzLmZvY3VzSW5kaWNhdG9yLm92ZXJyaWRlRm9jdXNWaXNpYmxlKGZhbHNlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3dpdGNoIChrZXkpIHtcbiAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwibmF2LXpvb21cIiwgMSwgZXZlbnQpO1xuICAgICAgY2FzZSBcIi1cIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJuYXYtem9vbVwiLCAtMSwgZXZlbnQpO1xuICAgIH1cbiAgICBpZiAoYWx0S2V5IHx8IHNoaWZ0S2V5IHx8IG1ldGFLZXkgfHwgY3RybEtleSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmZvY3VzSW5kaWNhdG9yLm92ZXJyaWRlRm9jdXNWaXNpYmxlKHRydWUpO1xuICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgY2FzZSBcIkFycm93RG93blwiOlxuICAgICAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcIm5hdi12ZXJ0XCIsIDEsIGV2ZW50KTtcbiAgICAgIGNhc2UgXCJBcnJvd1VwXCI6XG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwibmF2LXZlcnRcIiwgLTEsIGV2ZW50KTtcbiAgICAgIGNhc2UgXCJBcnJvd0xlZnRcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJuYXYtaG9yaVwiLCAtMSwgZXZlbnQpO1xuICAgICAgY2FzZSBcIkFycm93UmlnaHRcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJuYXYtaG9yaVwiLCAxLCBldmVudCk7XG4gICAgICBjYXNlIFwiWm9vbUluXCI6XG4gICAgICBjYXNlIFwiQWRkXCI6XG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwibmF2LXpvb21cIiwgMSwgZXZlbnQpO1xuICAgICAgY2FzZSBcIlpvb21PdXRcIjpcbiAgICAgIGNhc2UgXCJTdWJzdHJhY3RcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJuYXYtem9vbVwiLCAtMSwgZXZlbnQpO1xuICAgICAgY2FzZSBcIlNwYWNlXCI6XG4gICAgICBjYXNlIFwiRW50ZXJcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJzdWJtaXRcIiwgMCwgZXZlbnQpO1xuICAgIH1cbiAgfVxuICBkaXNwYXRjaCh0eXBlLCBkZWx0YTQsIHNvdXJjZUV2ZW50KSB7XG4gICAgY29uc3QgeyBwcmV2aW91c0lucHV0RGV2aWNlIH0gPSB0aGlzO1xuICAgIGRpc3BhdGNoVHlwZWRFdmVudCh0aGlzLmxpc3RlbmVycywgeyB0eXBlLCBkZWx0YTogZGVsdGE0LCBzb3VyY2VFdmVudCwgcHJldmlvdXNJbnB1dERldmljZSB9KTtcbiAgICBjb25zdCBzaGFyZWRLYm1UeXBlcyA9IFtcInJlZG9cIiwgXCJ1bmRvXCIsIFwibmF2LXpvb21cIl07XG4gICAgaWYgKHNvdXJjZUV2ZW50LnR5cGUgPT09IFwia2V5ZG93blwiICYmICFzaGFyZWRLYm1UeXBlcy5pbmNsdWRlcyh0eXBlKSkge1xuICAgICAgdGhpcy5wcmV2aW91c0lucHV0RGV2aWNlID0gXCJrZXlib2FyZFwiO1xuICAgIH1cbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvaW50ZXJhY3Rpb24vcmVnaW9ucy50c1xudmFyIFJFR0lPTlMgPSAvKiBAX19QVVJFX18gKi8gKChSRUdJT05TMikgPT4ge1xuICBSRUdJT05TMltcIk5BVklHQVRPUlwiXSA9IFwibmF2aWdhdG9yXCI7XG4gIFJFR0lPTlMyW1wiUk9PVFwiXSA9IFwicm9vdFwiO1xuICBSRUdJT05TMltcIlNFUklFU1wiXSA9IFwic2VyaWVzXCI7XG4gIFJFR0lPTlMyW1wiSE9SSVpPTlRBTF9BWEVTXCJdID0gXCJob3Jpem9udGFsLWF4ZXNcIjtcbiAgUkVHSU9OUzJbXCJWRVJUSUNBTF9BWEVTXCJdID0gXCJ2ZXJ0aWNhbC1heGVzXCI7XG4gIHJldHVybiBSRUdJT05TMjtcbn0pKFJFR0lPTlMgfHwge30pO1xudmFyIE5vZGVSZWdpb25CQm94UHJvdmlkZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG5vZGUsIG92ZXJyaWRlSWQpIHtcbiAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgIHRoaXMub3ZlcnJpZGVJZCA9IG92ZXJyaWRlSWQ7XG4gIH1cbiAgZ2V0IGlkKCkge1xuICAgIHJldHVybiB0aGlzLm92ZXJyaWRlSWQgPz8gdGhpcy5ub2RlLmlkO1xuICB9XG4gIGdldCB2aXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGUudmlzaWJsZTtcbiAgfVxuICB0b0NhbnZhc0JCb3goKSB7XG4gICAgcmV0dXJuIFRyYW5zZm9ybWFibGUudG9DYW52YXModGhpcy5ub2RlKTtcbiAgfVxuICBmcm9tQ2FudmFzUG9pbnQoeCwgeSkge1xuICAgIHJldHVybiBUcmFuc2Zvcm1hYmxlLmZyb21DYW52YXNQb2ludCh0aGlzLm5vZGUsIHgsIHkpO1xuICB9XG59O1xudmFyIFNpbXBsZVJlZ2lvbkJCb3hQcm92aWRlciA9IGNsYXNzIGV4dGVuZHMgTm9kZVJlZ2lvbkJCb3hQcm92aWRlciB7XG4gIGNvbnN0cnVjdG9yKG5vZGUsIGJib3hGbiwgb3ZlcnJpZGVJZCkge1xuICAgIHN1cGVyKG5vZGUsIG92ZXJyaWRlSWQpO1xuICAgIHRoaXMuYmJveEZuID0gYmJveEZuO1xuICB9XG4gIHRvQ2FudmFzQkJveCgpIHtcbiAgICByZXR1cm4gdGhpcy5iYm94Rm4oKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvaW50ZXJhY3Rpb24vcmVnaW9uTWFuYWdlci50c1xudmFyIFJlZ2lvbkxpc3RlbmVycyA9IGNsYXNzIGV4dGVuZHMgTGlzdGVuZXJzIHtcbn07XG5mdW5jdGlvbiBhZGRIYW5kbGVyKGxpc3RlbmVycywgaW50ZXJhY3Rpb25NYW5hZ2VyLCB0eXBlLCBoYW5kbGVyLCB0cmlnZ2VyaW5nU3RhdGVzID0gMzIgLyogRGVmYXVsdCAqLykge1xuICByZXR1cm4gbGlzdGVuZXJzPy5hZGRMaXN0ZW5lcih0eXBlLCAoZSkgPT4ge1xuICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IGludGVyYWN0aW9uTWFuYWdlci5nZXRTdGF0ZSgpO1xuICAgIGlmIChjdXJyZW50U3RhdGUgJiB0cmlnZ2VyaW5nU3RhdGVzKSB7XG4gICAgICBoYW5kbGVyKGUpO1xuICAgIH1cbiAgfSkgPz8gKCgpID0+IHtcbiAgfSk7XG59XG5mdW5jdGlvbiBub2RlVG9CQm94UHJvdmlkZXIobm9kZSkge1xuICBpZiAobm9kZSBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICByZXR1cm4gbmV3IE5vZGVSZWdpb25CQm94UHJvdmlkZXIobm9kZSk7XG4gIH1cbiAgaWYgKG5vZGUgaW5zdGFuY2VvZiBOb2RlUmVnaW9uQkJveFByb3ZpZGVyKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgcmV0dXJuIG5ldyBOb2RlUmVnaW9uQkJveFByb3ZpZGVyKG5vZGUubm9kZSwgbm9kZS5pZCk7XG59XG5mdW5jdGlvbiBnZXRUb29sdGlwQ29udGFpbmVyKHRhcmdldCkge1xuICBpZiAodGFyZ2V0ID09IG51bGwgfHwgISh0YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpXG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgbGV0IGN1cnJlbnQgPSB0YXJnZXQ7XG4gIHdoaWxlIChjdXJyZW50ICE9IG51bGwgJiYgIWN1cnJlbnQ/LmNsYXNzTGlzdC5jb250YWlucyhcImFnLWNoYXJ0cy13cmFwcGVyXCIpKSB7XG4gICAgaWYgKGN1cnJlbnQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiYWctY2hhcnQtdG9vbHRpcFwiKSkge1xuICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudEVsZW1lbnQ7XG4gIH1cbiAgcmV0dXJuIHZvaWQgMDtcbn1cbmZ1bmN0aW9uIHNob3VsZElnbm9yZShldmVudCkge1xuICBjb25zdCB7IHR5cGUsIHNvdXJjZUV2ZW50IH0gPSBldmVudDtcbiAgY29uc3QgeyBpZCwgY2xhc3NOYW1lLCBjbGFzc0xpc3QsIGFyaWFIaWRkZW4gfSA9IHNvdXJjZUV2ZW50Py50YXJnZXQgPz8ge307XG4gIGlmICghKGNsYXNzTGlzdCBpbnN0YW5jZW9mIERPTVRva2VuTGlzdCkpXG4gICAgcmV0dXJuIFwibGVhdmVcIjtcbiAgY29uc3QgZHJhZ1R5cGVzID0gRFJBR19JTlRFUkFDVElPTl9UWVBFUztcbiAgaWYgKFxuICAgIC8vIEhhbmRsZSBkcmFnIGV2ZW50IG9uIHRoZSBheGlzICdhZGQgaG9yaXpvbnRhbCBsaW5lIGFubm90YXRpb24nIGJ1dHRvbiBhcyBjYW52YXMgZXZlbnRzLlxuICAgIGNsYXNzTGlzdC5jb250YWlucyhcImFnLWNoYXJ0cy1hbm5vdGF0aW9uc19fYXhpcy1idXR0b24taWNvblwiKSAmJiAhZHJhZ1R5cGVzLmluY2x1ZGVzKHR5cGUpIHx8IGNsYXNzTmFtZSA9PT0gXCJhZy1jaGFydHMtc2VyaWVzLWFyZWFcIiB8fCBjbGFzc05hbWUgPT09IFwiYWctY2hhcnRzLWNhbnZhcy1wcm94eVwiIHx8IGNsYXNzTmFtZSA9PT0gXCJhZy1jaGFydHMtcHJveHktZWxlbVwiICYmICFpZD8udG9TdHJpbmcoKS5zdGFydHNXaXRoKFwiYWctY2hhcnRzLWxlZ2VuZC1pdGVtLVwiKSB8fCAvLyBsZWdlbmQgPGJ1dHRvbnM+XG4gICAgc291cmNlRXZlbnQ/LnRhcmdldCBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50XG4gICkge1xuICAgIHJldHVybiBcIm5vbmVcIjtcbiAgfVxuICBpZiAoZ2V0VG9vbHRpcENvbnRhaW5lcihzb3VyY2VFdmVudC50YXJnZXQpICYmIGFyaWFIaWRkZW4gIT09IFwidHJ1ZVwiKSB7XG4gICAgcmV0dXJuIFwid2FpdFwiO1xuICB9XG4gIHJldHVybiBcImxlYXZlXCI7XG59XG52YXIgUmVnaW9uTWFuYWdlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoaW50ZXJhY3Rpb25NYW5hZ2VyKSB7XG4gICAgdGhpcy5pbnRlcmFjdGlvbk1hbmFnZXIgPSBpbnRlcmFjdGlvbk1hbmFnZXI7XG4gICAgdGhpcy5kZWJ1ZyA9IERlYnVnLmNyZWF0ZSh0cnVlLCBcInJlZ2lvblwiKTtcbiAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmxlZnRDYW52YXMgPSBmYWxzZTtcbiAgICB0aGlzLnJlZ2lvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuZGVzdHJveUZucyA9IFtdO1xuICAgIHRoaXMuYWxsUmVnaW9uc0xpc3RlbmVycyA9IG5ldyBSZWdpb25MaXN0ZW5lcnMoKTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMucHVzaChcbiAgICAgIC4uLlBPSU5URVJfSU5URVJBQ1RJT05fVFlQRVMubWFwKFxuICAgICAgICAoZXZlbnROYW1lKSA9PiBpbnRlcmFjdGlvbk1hbmFnZXIuYWRkTGlzdGVuZXIoZXZlbnROYW1lLCB0aGlzLnByb2Nlc3NQb2ludGVyRXZlbnQuYmluZCh0aGlzKSwgNjMgLyogQWxsICovKVxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRlc3Ryb3lGbnMuZm9yRWFjaCgoZm4pID0+IGZuKCkpO1xuICAgIHRoaXMuY3VycmVudCA9IHZvaWQgMDtcbiAgICBmb3IgKGNvbnN0IHJlZ2lvbiBvZiB0aGlzLnJlZ2lvbnMudmFsdWVzKCkpIHtcbiAgICAgIHJlZ2lvbi5saXN0ZW5lcnMuZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLnJlZ2lvbnMuY2xlYXIoKTtcbiAgfVxuICBhZGRSZWdpb24obmFtZSwgLi4ubm9kZXMpIHtcbiAgICBpZiAodGhpcy5yZWdpb25zLmhhcyhuYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBRyBDaGFydHMgLSBSZWdpb246ICR7bmFtZX0gYWxyZWFkeSBleGlzdHNgKTtcbiAgICB9XG4gICAgY29uc3QgcmVnaW9uID0ge1xuICAgICAgcHJvcGVydGllczogeyBuYW1lLCBiYm94cHJvdmlkZXJzOiBub2Rlcy5tYXAobm9kZVRvQkJveFByb3ZpZGVyKSB9LFxuICAgICAgbGlzdGVuZXJzOiBuZXcgUmVnaW9uTGlzdGVuZXJzKClcbiAgICB9O1xuICAgIHRoaXMucmVnaW9ucy5zZXQobmFtZSwgcmVnaW9uKTtcbiAgICByZXR1cm4gdGhpcy5tYWtlT2JzZXJ2ZXIocmVnaW9uKTtcbiAgfVxuICB1cGRhdGVSZWdpb24obmFtZSwgLi4ubm9kZXMpIHtcbiAgICBjb25zdCByZWdpb24gPSB0aGlzLnJlZ2lvbnMuZ2V0KG5hbWUpO1xuICAgIGlmIChyZWdpb24pIHtcbiAgICAgIHJlZ2lvbi5wcm9wZXJ0aWVzLmJib3hwcm92aWRlcnMgPSBub2Rlcy5tYXAobm9kZVRvQkJveFByb3ZpZGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQUcgQ2hhcnRzIC0gdW5rbm93biByZWdpb246IFwiICsgbmFtZSk7XG4gICAgfVxuICB9XG4gIGdldFJlZ2lvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubWFrZU9ic2VydmVyKHRoaXMucmVnaW9ucy5nZXQobmFtZSkpO1xuICB9XG4gIGxpc3RlbkFsbCh0eXBlLCBoYW5kbGVyLCB0cmlnZ2VyaW5nU3RhdGVzID0gMzIgLyogRGVmYXVsdCAqLykge1xuICAgIHJldHVybiBhZGRIYW5kbGVyKHRoaXMuYWxsUmVnaW9uc0xpc3RlbmVycywgdGhpcy5pbnRlcmFjdGlvbk1hbmFnZXIsIHR5cGUsIGhhbmRsZXIsIHRyaWdnZXJpbmdTdGF0ZXMpO1xuICB9XG4gIC8vIFRoaXMgbWV0aG9kIHJldHVybiBhIHdyYXBwZXIgb2JqZWN0IHRoYXQgbWF0Y2hlcyB0aGUgaW50ZXJmYWNlIG9mIEludGVyYWN0aW9uTWFuYWdlci5hZGRMaXN0ZW5lci5cbiAgLy8gVGhlIGludGVudCBpcyB0byBhbGxvdyB0aGUgSW50ZXJhY3Rpb25NYW5hZ2VyIGFuZCBSZWdpb25NYW5hZ2VyIHRvIGJlIHVzZWQgYWxtb3N0IGludGVyY2hhbmdlYWJseS5cbiAgbWFrZU9ic2VydmVyKHJlZ2lvbikge1xuICAgIGNvbnN0IHsgaW50ZXJhY3Rpb25NYW5hZ2VyIH0gPSB0aGlzO1xuICAgIGNsYXNzIE9ic2VydmFibGVSZWdpb25JbXBsZW1lbnRhdGlvbiB7XG4gICAgICBhZGRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCB0cmlnZ2VyaW5nU3RhdGVzID0gMzIgLyogRGVmYXVsdCAqLykge1xuICAgICAgICByZXR1cm4gYWRkSGFuZGxlcihyZWdpb24/Lmxpc3RlbmVycywgaW50ZXJhY3Rpb25NYW5hZ2VyLCB0eXBlLCBoYW5kbGVyLCB0cmlnZ2VyaW5nU3RhdGVzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlUmVnaW9uSW1wbGVtZW50YXRpb24oKTtcbiAgfVxuICBjaGVja1BvaW50ZXJIaXN0b3J5KHRhcmdldFJlZ2lvbiwgZXZlbnQpIHtcbiAgICBmb3IgKGNvbnN0IGhpc3RvcnlFdmVudCBvZiBldmVudC5wb2ludGVySGlzdG9yeSkge1xuICAgICAgY29uc3QgeyByZWdpb246IGhpc3RvcnlSZWdpb24gfSA9IHRoaXMucGlja1JlZ2lvbihoaXN0b3J5RXZlbnQub2Zmc2V0WCwgaGlzdG9yeUV2ZW50Lm9mZnNldFkpID8/IHt9O1xuICAgICAgaWYgKHRhcmdldFJlZ2lvbi5wcm9wZXJ0aWVzLm5hbWUgIT09IGhpc3RvcnlSZWdpb24/LnByb3BlcnRpZXMubmFtZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8vIENyZWF0ZSBhbmQgZGlzcGF0Y2ggYSBjb3B5IG9mIHRoZSBJbnRlcmFjdGlvbkV2ZW50LlxuICBkaXNwYXRjaChjdXJyZW50LCBwYXJ0aWFsRXZlbnQpIHtcbiAgICBpZiAoY3VycmVudCA9PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG1haW5CQm94UHJvdmlkZXIgPSBjdXJyZW50LnJlZ2lvbi5wcm9wZXJ0aWVzLmJib3hwcm92aWRlcnNbMF07XG4gICAgbGV0IHJlZ2lvbk9mZnNldFggPSAwO1xuICAgIGxldCByZWdpb25PZmZzZXRZID0gMDtcbiAgICBpZiAoXCJvZmZzZXRYXCIgaW4gcGFydGlhbEV2ZW50ICYmIFwib2Zmc2V0WVwiIGluIHBhcnRpYWxFdmVudCkge1xuICAgICAgKHsgeDogcmVnaW9uT2Zmc2V0WCwgeTogcmVnaW9uT2Zmc2V0WSB9ID0gbWFpbkJCb3hQcm92aWRlci5mcm9tQ2FudmFzUG9pbnQoXG4gICAgICAgIHBhcnRpYWxFdmVudC5vZmZzZXRYLFxuICAgICAgICBwYXJ0aWFsRXZlbnQub2Zmc2V0WVxuICAgICAgKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJlZ2lvbkJCb3ggPSBtYWluQkJveFByb3ZpZGVyLnRvQ2FudmFzQkJveCgpO1xuICAgICAgcmVnaW9uT2Zmc2V0WCA9IHJlZ2lvbkJCb3gud2lkdGggLyAyO1xuICAgICAgcmVnaW9uT2Zmc2V0WSA9IHJlZ2lvbkJCb3guaGVpZ2h0IC8gMjtcbiAgICB9XG4gICAgY29uc3QgZXZlbnQgPSBidWlsZFByZXZlbnRhYmxlKHtcbiAgICAgIC4uLnBhcnRpYWxFdmVudCxcbiAgICAgIHJlZ2lvbjogY3VycmVudC5yZWdpb24ucHJvcGVydGllcy5uYW1lLFxuICAgICAgYmJveFByb3ZpZGVySWQ6IGN1cnJlbnQuYmJveFByb3ZpZGVyPy5pZCxcbiAgICAgIHJlZ2lvbk9mZnNldFgsXG4gICAgICByZWdpb25PZmZzZXRZXG4gICAgfSk7XG4gICAgdGhpcy5kZWJ1ZyhcIkRpc3BhdGNoaW5nIHJlZ2lvbiBldmVudDogXCIsIGV2ZW50KTtcbiAgICB0aGlzLmFsbFJlZ2lvbnNMaXN0ZW5lcnMuZGlzcGF0Y2goZXZlbnQudHlwZSwgZXZlbnQpO1xuICAgIGN1cnJlbnQucmVnaW9uLmxpc3RlbmVycy5kaXNwYXRjaChldmVudC50eXBlLCBldmVudCk7XG4gIH1cbiAgLy8gUHJvY2VzcyBldmVudHMgZHVyaW5nIGEgZHJhZyBhY3Rpb24uIFJldHVybnMgZmFsc2UgaWYgdGhpcyBldmVudCBzaG91bGQgZm9sbG93IHRoZSBzdGFuZGFyZFxuICAvLyBSZWdpb25NYW5hZ2VyLnByb2Nlc3NFdmVudCBmbG93LCBvciB0cnVlIGlmIHRoaXMgZXZlbnQgYWxyZWFkeSBwcm9jZXNzZWQgYnkgdGhpcyBmdW5jdGlvbi5cbiAgaGFuZGxlRHJhZ2dpbmcoZXZlbnQpIHtcbiAgICBjb25zdCB7IGN1cnJlbnQgfSA9IHRoaXM7XG4gICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICBjYXNlIFwiZHJhZy1zdGFydFwiOlxuICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmxlZnRDYW52YXMgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibGVhdmVcIjpcbiAgICAgICAgdGhpcy5sZWZ0Q2FudmFzID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNEcmFnZ2luZztcbiAgICAgIGNhc2UgXCJlbnRlclwiOlxuICAgICAgICB0aGlzLmxlZnRDYW52YXMgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNEcmFnZ2luZztcbiAgICAgIGNhc2UgXCJkcmFnXCI6XG4gICAgICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcpIHtcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoKGN1cnJlbnQsIGV2ZW50KTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkcmFnLWVuZFwiOlxuICAgICAgICBpZiAodGhpcy5pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaChjdXJyZW50LCBldmVudCk7XG4gICAgICAgICAgaWYgKHRoaXMubGVmdENhbnZhcykge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaChjdXJyZW50LCB7IC4uLmV2ZW50LCB0eXBlOiBcImxlYXZlXCIgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcHJvY2Vzc1BvaW50ZXJFdmVudChldmVudCkge1xuICAgIGlmICh0aGlzLmhhbmRsZURyYWdnaW5nKGV2ZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGN1cnJlbnQgfSA9IHRoaXM7XG4gICAgY29uc3QgaWdub3JlID0gc2hvdWxkSWdub3JlKGV2ZW50KTtcbiAgICBsZXQgbmV3Q3VycmVudDtcbiAgICBzd2l0Y2ggKGlnbm9yZSkge1xuICAgICAgY2FzZSBcIndhaXRcIjpcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcIm5vbmVcIjpcbiAgICAgICAgbmV3Q3VycmVudCA9IHRoaXMucGlja1JlZ2lvbihldmVudC5vZmZzZXRYLCBldmVudC5vZmZzZXRZKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibGVhdmVcIjpcbiAgICAgICAgbmV3Q3VycmVudCA9IHZvaWQgMDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNvbnN0IG5ld1JlZ2lvbiA9IG5ld0N1cnJlbnQ/LnJlZ2lvbjtcbiAgICBpZiAoY3VycmVudCAhPT0gdm9pZCAwICYmIG5ld1JlZ2lvbj8ucHJvcGVydGllcy5uYW1lICE9PSBjdXJyZW50LnJlZ2lvbi5wcm9wZXJ0aWVzLm5hbWUpIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2goY3VycmVudCwgeyAuLi5ldmVudCwgdHlwZTogXCJsZWF2ZVwiIH0pO1xuICAgIH1cbiAgICBpZiAobmV3UmVnaW9uICE9PSB2b2lkIDAgJiYgbmV3UmVnaW9uLnByb3BlcnRpZXMubmFtZSAhPT0gY3VycmVudD8ucmVnaW9uLnByb3BlcnRpZXMubmFtZSkge1xuICAgICAgdGhpcy5kaXNwYXRjaChuZXdDdXJyZW50LCB7IC4uLmV2ZW50LCB0eXBlOiBcImVudGVyXCIgfSk7XG4gICAgfVxuICAgIGlmIChuZXdSZWdpb24gIT09IHZvaWQgMCAmJiB0aGlzLmNoZWNrUG9pbnRlckhpc3RvcnkobmV3UmVnaW9uLCBldmVudCkpIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2gobmV3Q3VycmVudCwgZXZlbnQpO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnQgPSBuZXdDdXJyZW50O1xuICB9XG4gIHBpY2tSZWdpb24oeCwgeSkge1xuICAgIGxldCBjdXJyZW50QXJlYSA9IEluZmluaXR5O1xuICAgIGxldCBjdXJyZW50UmVnaW9uO1xuICAgIGxldCBjdXJyZW50QkJveFByb3ZpZGVyO1xuICAgIGZvciAoY29uc3QgcmVnaW9uIG9mIHRoaXMucmVnaW9ucy52YWx1ZXMoKSkge1xuICAgICAgZm9yIChjb25zdCBwcm92aWRlciBvZiByZWdpb24ucHJvcGVydGllcy5iYm94cHJvdmlkZXJzKSB7XG4gICAgICAgIGlmIChwcm92aWRlci52aXNpYmxlID09PSBmYWxzZSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgYmJveCA9IHByb3ZpZGVyLnRvQ2FudmFzQkJveCgpO1xuICAgICAgICBjb25zdCBhcmVhMiA9IGJib3gud2lkdGggKiBiYm94LmhlaWdodDtcbiAgICAgICAgaWYgKGFyZWEyIDwgY3VycmVudEFyZWEgJiYgYmJveC5jb250YWluc1BvaW50KHgsIHkpKSB7XG4gICAgICAgICAgY3VycmVudEFyZWEgPSBhcmVhMjtcbiAgICAgICAgICBjdXJyZW50UmVnaW9uID0gcmVnaW9uO1xuICAgICAgICAgIGN1cnJlbnRCQm94UHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3VycmVudFJlZ2lvbiA/IHsgcmVnaW9uOiBjdXJyZW50UmVnaW9uLCBiYm94UHJvdmlkZXI6IGN1cnJlbnRCQm94UHJvdmlkZXIgfSA6IHZvaWQgMDtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvdG9vbGJhci90b29sYmFyVHlwZXMudHNcbnZhciBUT09MQkFSX0FMSUdOTUVOVFMgPSBbXCJzdGFydFwiLCBcImNlbnRlclwiLCBcImVuZFwiXTtcbnZhciBUT09MQkFSX0dST1VQUyA9IFtcInNlcmllc1R5cGVcIiwgXCJhbm5vdGF0aW9uc1wiLCBcImFubm90YXRpb25PcHRpb25zXCIsIFwicmFuZ2VzXCIsIFwiem9vbVwiXTtcbnZhciBUT09MQkFSX0dST1VQX09SREVSSU5HID0ge1xuICBzZXJpZXNUeXBlOiAwLFxuICBhbm5vdGF0aW9uczogMSxcbiAgYW5ub3RhdGlvbk9wdGlvbnM6IDIsXG4gIHJhbmdlczogMyxcbiAgem9vbTogNFxufTtcbnZhciBUb29sYmFyUG9zaXRpb24gPSAvKiBAX19QVVJFX18gKi8gKChUb29sYmFyUG9zaXRpb24yKSA9PiB7XG4gIFRvb2xiYXJQb3NpdGlvbjJbXCJUb3BcIl0gPSBcInRvcFwiO1xuICBUb29sYmFyUG9zaXRpb24yW1wiTGVmdFwiXSA9IFwibGVmdFwiO1xuICBUb29sYmFyUG9zaXRpb24yW1wiUmlnaHRcIl0gPSBcInJpZ2h0XCI7XG4gIFRvb2xiYXJQb3NpdGlvbjJbXCJCb3R0b21cIl0gPSBcImJvdHRvbVwiO1xuICBUb29sYmFyUG9zaXRpb24yW1wiRmxvYXRpbmdcIl0gPSBcImZsb2F0aW5nXCI7XG4gIFRvb2xiYXJQb3NpdGlvbjJbXCJGbG9hdGluZ1RvcFwiXSA9IFwiZmxvYXRpbmctdG9wXCI7XG4gIFRvb2xiYXJQb3NpdGlvbjJbXCJGbG9hdGluZ0JvdHRvbVwiXSA9IFwiZmxvYXRpbmctYm90dG9tXCI7XG4gIHJldHVybiBUb29sYmFyUG9zaXRpb24yO1xufSkoVG9vbGJhclBvc2l0aW9uIHx8IHt9KTtcbnZhciBUT09MQkFSX1BPU0lUSU9OUyA9IE9iamVjdC52YWx1ZXMoVG9vbGJhclBvc2l0aW9uKTtcbmZ1bmN0aW9uIGlzQW5pbWF0aW5nRmxvYXRpbmdQb3NpdGlvbihwb3NpdGlvbikge1xuICByZXR1cm4gW1wiZmxvYXRpbmctdG9wXCIgLyogRmxvYXRpbmdUb3AgKi8sIFwiZmxvYXRpbmctYm90dG9tXCIgLyogRmxvYXRpbmdCb3R0b20gKi9dLmluY2x1ZGVzKHBvc2l0aW9uKTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvaW50ZXJhY3Rpb24vdG9vbGJhck1hbmFnZXIudHNcbnZhciBUb29sYmFyTWFuYWdlciA9IGNsYXNzIGV4dGVuZHMgQmFzZU1hbmFnZXIge1xuICBzdGF0aWMgaXNHcm91cChncm91cCwgZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQuZ3JvdXAgPT09IGdyb3VwO1xuICB9XG4gIHN0YXRpYyBpc0NoaWxkRWxlbWVudChkb21NYW5hZ2VyLCBlbGVtZW50Mikge1xuICAgIGZvciAoY29uc3QgcG9zaXRpb24gb2YgVE9PTEJBUl9QT1NJVElPTlMpIHtcbiAgICAgIGlmIChkb21NYW5hZ2VyLmlzTWFuYWdlZENoaWxkRE9NRWxlbWVudChlbGVtZW50MiwgXCJjYW52YXMtb3ZlcmxheVwiLCBgdG9vbGJhci0ke3Bvc2l0aW9ufWApKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcHJlc3NCdXR0b24oZ3JvdXAsIGlkLCB2YWx1ZSwgcmVjdCwgc291cmNlRXZlbnQpIHtcbiAgICB0aGlzLmxpc3RlbmVycy5kaXNwYXRjaChcImJ1dHRvbi1wcmVzc2VkXCIsIHsgdHlwZTogXCJidXR0b24tcHJlc3NlZFwiLCBncm91cCwgaWQsIHZhbHVlLCByZWN0LCBzb3VyY2VFdmVudCB9KTtcbiAgfVxuICBjYW5jZWwoZ3JvdXApIHtcbiAgICB0aGlzLmxpc3RlbmVycy5kaXNwYXRjaChcImNhbmNlbGxlZFwiLCB7IHR5cGU6IFwiY2FuY2VsbGVkXCIsIGdyb3VwIH0pO1xuICB9XG4gIHRvZ2dsZUJ1dHRvbihncm91cCwgaWQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGFjdGl2ZSA9IGZhbHNlLCBlbmFibGVkID0gdHJ1ZSwgdmlzaWJsZSA9IHRydWUsIGNoZWNrZWQgPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgICB0aGlzLmxpc3RlbmVycy5kaXNwYXRjaChcImJ1dHRvbi10b2dnbGVkXCIsIHtcbiAgICAgIHR5cGU6IFwiYnV0dG9uLXRvZ2dsZWRcIixcbiAgICAgIGdyb3VwLFxuICAgICAgaWQsXG4gICAgICBhY3RpdmUsXG4gICAgICBlbmFibGVkLFxuICAgICAgdmlzaWJsZSxcbiAgICAgIGNoZWNrZWRcbiAgICB9KTtcbiAgfVxuICB1cGRhdGVCdXR0b24oZ3JvdXAsIGlkLCBvcHRpb25zKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMuZGlzcGF0Y2goXCJidXR0b24tdXBkYXRlZFwiLCB7IHR5cGU6IFwiYnV0dG9uLXVwZGF0ZWRcIiwgZ3JvdXAsIGlkLCAuLi5vcHRpb25zIH0pO1xuICB9XG4gIHRvZ2dsZUdyb3VwKGNhbGxlciwgZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGFjdGl2ZSwgdmlzaWJsZSB9ID0gb3B0aW9ucztcbiAgICB0aGlzLmxpc3RlbmVycy5kaXNwYXRjaChcImdyb3VwLXRvZ2dsZWRcIiwgeyB0eXBlOiBcImdyb3VwLXRvZ2dsZWRcIiwgY2FsbGVyLCBncm91cCwgYWN0aXZlLCB2aXNpYmxlIH0pO1xuICB9XG4gIHVwZGF0ZUdyb3VwKGdyb3VwKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMuZGlzcGF0Y2goXCJncm91cC11cGRhdGVkXCIsIHsgdHlwZTogXCJncm91cC11cGRhdGVkXCIsIGdyb3VwIH0pO1xuICB9XG4gIGdyb3VwTW92ZWQoZ3JvdXApIHtcbiAgICB0aGlzLmxpc3RlbmVycy5kaXNwYXRjaChcImdyb3VwLW1vdmVkXCIsIHsgdHlwZTogXCJncm91cC1tb3ZlZFwiLCBncm91cCB9KTtcbiAgfVxuICBjaGFuZ2VGbG9hdGluZ0FuY2hvcihncm91cCwgYW5jaG9yKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMuZGlzcGF0Y2goXCJmbG9hdGluZy1hbmNob3ItY2hhbmdlZFwiLCB7XG4gICAgICB0eXBlOiBcImZsb2F0aW5nLWFuY2hvci1jaGFuZ2VkXCIsXG4gICAgICBncm91cCxcbiAgICAgIGFuY2hvclxuICAgIH0pO1xuICB9XG4gIGJ1dHRvbk1vdmVkKGdyb3VwLCB2YWx1ZSwgcmVjdCwgZ3JvdXBSZWN0KSB7XG4gICAgdGhpcy5saXN0ZW5lcnMuZGlzcGF0Y2goXCJidXR0b24tbW92ZWRcIiwgeyB0eXBlOiBcImJ1dHRvbi1tb3ZlZFwiLCBncm91cCwgdmFsdWUsIHJlY3QsIGdyb3VwUmVjdCB9KTtcbiAgfVxuICBwcm94eUdyb3VwT3B0aW9ucyhjYWxsZXIsIGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMuZGlzcGF0Y2goXCJwcm94eS1ncm91cC1vcHRpb25zXCIsIHsgdHlwZTogXCJwcm94eS1ncm91cC1vcHRpb25zXCIsIGNhbGxlciwgZ3JvdXAsIG9wdGlvbnMgfSk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2ludGVyYWN0aW9uL3Rvb2x0aXBNYW5hZ2VyLnRzXG52YXIgVG9vbHRpcE1hbmFnZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGRvbU1hbmFnZXIsIHRvb2x0aXApIHtcbiAgICB0aGlzLmRvbU1hbmFnZXIgPSBkb21NYW5hZ2VyO1xuICAgIHRoaXMudG9vbHRpcCA9IHRvb2x0aXA7XG4gICAgdGhpcy5zdGF0ZVRyYWNrZXIgPSBuZXcgU3RhdGVUcmFja2VyKCk7XG4gICAgdGhpcy5zdXBwcmVzc1N0YXRlID0gbmV3IFN0YXRlVHJhY2tlcihmYWxzZSk7XG4gICAgdGhpcy5hcHBsaWVkU3RhdGUgPSBudWxsO1xuICAgIHRvb2x0aXAuc2V0dXAoZG9tTWFuYWdlcik7XG4gICAgZG9tTWFuYWdlci5hZGRMaXN0ZW5lcihcImhpZGRlblwiLCAoKSA9PiB0aGlzLnRvb2x0aXAudG9nZ2xlKGZhbHNlKSk7XG4gIH1cbiAgdXBkYXRlVG9vbHRpcChjYWxsZXJJZCwgbWV0YSwgY29udGVudCkge1xuICAgIGlmICghdGhpcy50b29sdGlwLmVuYWJsZWQpXG4gICAgICByZXR1cm47XG4gICAgY29udGVudCA/PyAoY29udGVudCA9IHRoaXMuc3RhdGVUcmFja2VyLmdldChjYWxsZXJJZCk/LmNvbnRlbnQpO1xuICAgIHRoaXMuc3RhdGVUcmFja2VyLnNldChjYWxsZXJJZCwgeyBjb250ZW50LCBtZXRhIH0pO1xuICAgIHRoaXMuYXBwbHlTdGF0ZXMoKTtcbiAgfVxuICByZW1vdmVUb29sdGlwKGNhbGxlcklkKSB7XG4gICAgaWYgKCF0aGlzLnRvb2x0aXAuZW5hYmxlZClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLnN0YXRlVHJhY2tlci5kZWxldGUoY2FsbGVySWQpO1xuICAgIHRoaXMuYXBwbHlTdGF0ZXMoKTtcbiAgfVxuICBzdXBwcmVzc1Rvb2x0aXAoY2FsbGVySWQpIHtcbiAgICB0aGlzLnN1cHByZXNzU3RhdGUuc2V0KGNhbGxlcklkLCB0cnVlKTtcbiAgfVxuICB1bnN1cHByZXNzVG9vbHRpcChjYWxsZXJJZCkge1xuICAgIHRoaXMuc3VwcHJlc3NTdGF0ZS5kZWxldGUoY2FsbGVySWQpO1xuICB9XG4gIGdldFRvb2x0aXBNZXRhKGNhbGxlcklkKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVUcmFja2VyLmdldChjYWxsZXJJZCk/Lm1ldGE7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRvbU1hbmFnZXIucmVtb3ZlU3R5bGVzKFwidG9vbHRpcFwiKTtcbiAgfVxuICBhcHBseVN0YXRlcygpIHtcbiAgICBjb25zdCBpZCA9IHRoaXMuc3RhdGVUcmFja2VyLnN0YXRlSWQoKTtcbiAgICBjb25zdCBzdGF0ZSA9IGlkID8gdGhpcy5zdGF0ZVRyYWNrZXIuZ2V0KGlkKSA6IG51bGw7XG4gICAgaWYgKHRoaXMuc3VwcHJlc3NTdGF0ZS5zdGF0ZVZhbHVlKCkgfHwgc3RhdGU/Lm1ldGEgPT0gbnVsbCB8fCBzdGF0ZT8uY29udGVudCA9PSBudWxsKSB7XG4gICAgICB0aGlzLmFwcGxpZWRTdGF0ZSA9IG51bGw7XG4gICAgICB0aGlzLnRvb2x0aXAudG9nZ2xlKGZhbHNlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2FudmFzUmVjdCA9IHRoaXMuZG9tTWFuYWdlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBib3VuZGluZ1JlY3QgPSB0aGlzLnRvb2x0aXAuYm91bmRzID09PSBcImV4dGVuZGVkXCIgPyB0aGlzLmRvbU1hbmFnZXIuZ2V0T3ZlcmxheUNsaWVudFJlY3QoKSA6IGNhbnZhc1JlY3Q7XG4gICAgaWYgKHRoaXMuYXBwbGllZFN0YXRlPy5jb250ZW50ID09PSBzdGF0ZT8uY29udGVudCkge1xuICAgICAgY29uc3QgcmVuZGVySW5zdGFudGx5ID0gdGhpcy50b29sdGlwLmlzVmlzaWJsZSgpO1xuICAgICAgdGhpcy50b29sdGlwLnNob3coYm91bmRpbmdSZWN0LCBjYW52YXNSZWN0LCBzdGF0ZT8ubWV0YSwgbnVsbCwgcmVuZGVySW5zdGFudGx5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50b29sdGlwLnNob3coYm91bmRpbmdSZWN0LCBjYW52YXNSZWN0LCBzdGF0ZT8ubWV0YSwgc3RhdGU/LmNvbnRlbnQpO1xuICAgIH1cbiAgICB0aGlzLmFwcGxpZWRTdGF0ZSA9IHN0YXRlO1xuICB9XG4gIHN0YXRpYyBtYWtlVG9vbHRpcE1ldGEoZXZlbnQsIGRhdHVtKSB7XG4gICAgY29uc3QgeyBvZmZzZXRYLCBvZmZzZXRZIH0gPSBldmVudDtcbiAgICBjb25zdCB0b29sdGlwID0gZGF0dW0uc2VyaWVzLnByb3BlcnRpZXMudG9vbHRpcDtcbiAgICBjb25zdCBtZXRhID0ge1xuICAgICAgb2Zmc2V0WCxcbiAgICAgIG9mZnNldFksXG4gICAgICBlbmFibGVJbnRlcmFjdGlvbjogdG9vbHRpcC5pbnRlcmFjdGlvbj8uZW5hYmxlZCA/PyBmYWxzZSxcbiAgICAgIGxhc3RQb2ludGVyRXZlbnQ6IHsgdHlwZTogZXZlbnQudHlwZSwgb2Zmc2V0WCwgb2Zmc2V0WSB9LFxuICAgICAgc2hvd0Fycm93OiB0b29sdGlwLnNob3dBcnJvdyxcbiAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgIHR5cGU6IHRvb2x0aXAucG9zaXRpb24udHlwZSxcbiAgICAgICAgeE9mZnNldDogdG9vbHRpcC5wb3NpdGlvbi54T2Zmc2V0LFxuICAgICAgICB5T2Zmc2V0OiB0b29sdGlwLnBvc2l0aW9uLnlPZmZzZXRcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlZlBvaW50ID0gZGF0dW0ueUJhcj8udXBwZXJQb2ludCA/PyBkYXR1bS5taWRQb2ludCA/PyBkYXR1bS5zZXJpZXMuZGF0dW1NaWRQb2ludD8uKGRhdHVtKTtcbiAgICBpZiAoKHRvb2x0aXAucG9zaXRpb24udHlwZSA9PT0gXCJub2RlXCIgfHwgdG9vbHRpcC5wb3NpdGlvbi50eXBlID09PSBcInNwYXJrbGluZVwiKSAmJiByZWZQb2ludCkge1xuICAgICAgY29uc3QgeyB4LCB5IH0gPSByZWZQb2ludDtcbiAgICAgIGNvbnN0IHBvaW50ID0gVHJhbnNmb3JtYWJsZS50b0NhbnZhc1BvaW50KGRhdHVtLnNlcmllcy5jb250ZW50R3JvdXAsIHgsIHkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubWV0YSxcbiAgICAgICAgb2Zmc2V0WDogTWF0aC5yb3VuZChwb2ludC54KSxcbiAgICAgICAgb2Zmc2V0WTogTWF0aC5yb3VuZChwb2ludC55KVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG1ldGE7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2ludGVyYWN0aW9uL3pvb21NYW5hZ2VyLnRzXG52YXIgWm9vbU1hbmFnZXIgPSBjbGFzcyBleHRlbmRzIEJhc2VNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLm1lbWVudG9PcmlnaW5hdG9yS2V5ID0gXCJ6b29tXCI7XG4gICAgdGhpcy5heGlzWm9vbU1hbmFnZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLnN0YXRlID0gbmV3IFN0YXRlVHJhY2tlcih2b2lkIDAsIFwiaW5pdGlhbFwiKTtcbiAgICB0aGlzLnJlamVjdENhbGxiYWNrcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgYWRkTGF5b3V0TGlzdGVuZXJzKGxheW91dE1hbmFnZXIpIHtcbiAgICB0aGlzLmRlc3Ryb3lGbnMucHVzaChcbiAgICAgIGxheW91dE1hbmFnZXIuYWRkTGlzdGVuZXIoXCJsYXlvdXQ6Y29tcGxldGVcIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgIHRoaXMuYXhlcyA9IGV2ZW50LmF4ZXM7XG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgY3JlYXRlTWVtZW50bygpIHtcbiAgICBjb25zdCB6b29tMiA9IHRoaXMuZ2V0RGVmaW5lZFpvb20oKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmFuZ2VYOiB0aGlzLmdldFJhbmdlRGlyZWN0aW9uKHpvb20yLCBcInhcIiAvKiBYICovKSxcbiAgICAgIHJhbmdlWTogdGhpcy5nZXRSYW5nZURpcmVjdGlvbih6b29tMiwgXCJ5XCIgLyogWSAqLyksXG4gICAgICByYXRpb1g6IHsgc3RhcnQ6IHpvb20yLngubWluLCBlbmQ6IHpvb20yLngubWF4IH0sXG4gICAgICByYXRpb1k6IHsgc3RhcnQ6IHpvb20yLnkubWluLCBlbmQ6IHpvb20yLnkubWF4IH1cbiAgICB9O1xuICB9XG4gIGd1YXJkTWVtZW50byhibG9iKSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGJsb2IpICYmIChibG9iLnJhdGlvWCAhPSBudWxsIHx8IGJsb2IucmF0aW9ZICE9IG51bGwgfHwgYmxvYi5yYW5nZVggIT0gbnVsbCB8fCBibG9iLnJhbmdlWSAhPSBudWxsKTtcbiAgfVxuICByZXN0b3JlTWVtZW50byhfdmVyc2lvbiwgX21lbWVudG9WZXJzaW9uLCBtZW1lbnRvKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMuZGlzcGF0Y2goXCJyZXN0b3JlLXpvb21cIiwgeyAuLi5tZW1lbnRvLCB0eXBlOiBcInJlc3RvcmUtem9vbVwiIH0pO1xuICB9XG4gIHVwZGF0ZUF4ZXMoYXhlcykge1xuICAgIGNvbnN0IHpvb21NYW5hZ2VycyA9IG5ldyBNYXAoYXhlcy5tYXAoKGF4aXMpID0+IFtheGlzLmlkLCB0aGlzLmF4aXNab29tTWFuYWdlcnMuZ2V0KGF4aXMuaWQpXSkpO1xuICAgIHRoaXMuYXhpc1pvb21NYW5hZ2Vycy5jbGVhcigpO1xuICAgIGZvciAoY29uc3QgYXhpcyBvZiBheGVzKSB7XG4gICAgICB0aGlzLmF4aXNab29tTWFuYWdlcnMuc2V0KGF4aXMuaWQsIHpvb21NYW5hZ2Vycy5nZXQoYXhpcy5pZCkgPz8gbmV3IEF4aXNab29tTWFuYWdlcihheGlzKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnN0YXRlLnNpemUgPiAwICYmIGF4ZXMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy51cGRhdGVab29tKHRoaXMuc3RhdGUuc3RhdGVJZCgpLCB0aGlzLnN0YXRlLnN0YXRlVmFsdWUoKSk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVpvb20oY2FsbGVySWQsIG5ld1pvb20sIGNhbkNoYW5nZUluaXRpYWwgPSB0cnVlLCByZWplY3RDYWxsYmFjaykge1xuICAgIGlmIChyZWplY3RDYWxsYmFjaykge1xuICAgICAgdGhpcy5yZWplY3RDYWxsYmFja3Muc2V0KGNhbGxlcklkLCByZWplY3RDYWxsYmFjayk7XG4gICAgfVxuICAgIGlmICh0aGlzLmF4aXNab29tTWFuYWdlcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgY29uc3Qgc3RhdGVJZCA9IHRoaXMuc3RhdGUuc3RhdGVJZCgpO1xuICAgICAgaWYgKHN0YXRlSWQgPT09IFwiaW5pdGlhbFwiIHx8IHN0YXRlSWQgPT09IGNhbGxlcklkIHx8IGNhbkNoYW5nZUluaXRpYWwpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5zZXQoY2FsbGVySWQsIG5ld1pvb20pO1xuICAgICAgICBpZiAoc3RhdGVJZCAhPT0gY2FsbGVySWQpIHtcbiAgICAgICAgICB0aGlzLnJlamVjdENhbGxiYWNrcy5nZXQoc3RhdGVJZCk/LihjYWxsZXJJZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlamVjdENhbGxiYWNrPy4oc3RhdGVJZCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc3RhdGUuc2V0KGNhbGxlcklkLCBuZXdab29tKTtcbiAgICB0aGlzLmF4aXNab29tTWFuYWdlcnMuZm9yRWFjaCgoYXhpcykgPT4ge1xuICAgICAgYXhpcy51cGRhdGVab29tKGNhbGxlcklkLCBuZXdab29tPy5bYXhpcy5nZXREaXJlY3Rpb24oKV0pO1xuICAgIH0pO1xuICAgIHRoaXMuYXBwbHlDaGFuZ2VzKGNhbGxlcklkKTtcbiAgfVxuICB1cGRhdGVBeGlzWm9vbShjYWxsZXJJZCwgYXhpc0lkLCBuZXdab29tKSB7XG4gICAgdGhpcy5heGlzWm9vbU1hbmFnZXJzLmdldChheGlzSWQpPy51cGRhdGVab29tKGNhbGxlcklkLCBuZXdab29tKTtcbiAgICB0aGlzLmFwcGx5Q2hhbmdlcyhjYWxsZXJJZCk7XG4gIH1cbiAgLy8gRmlyZSB0aGlzIGV2ZW50IHRvIHNpZ25hbCB0byBsaXN0ZW5lcnMgdGhhdCB0aGUgdmlldyBpcyBjaGFuZ2luZyB0aHJvdWdoIGEgem9vbSBhbmQvb3IgcGFuIGNoYW5nZS5cbiAgZmlyZVpvb21QYW5TdGFydEV2ZW50KGNhbGxlcklkKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMuZGlzcGF0Y2goXCJ6b29tLXBhbi1zdGFydFwiLCB7IHR5cGU6IFwiem9vbS1wYW4tc3RhcnRcIiwgY2FsbGVySWQgfSk7XG4gIH1cbiAgZ2V0Wm9vbSgpIHtcbiAgICBsZXQgeDtcbiAgICBsZXQgeTtcbiAgICB0aGlzLmF4aXNab29tTWFuYWdlcnMuZm9yRWFjaCgoYXhpcykgPT4ge1xuICAgICAgaWYgKGF4aXMuZ2V0RGlyZWN0aW9uKCkgPT09IFwieFwiIC8qIFggKi8pIHtcbiAgICAgICAgeCA/PyAoeCA9IGF4aXMuZ2V0Wm9vbSgpKTtcbiAgICAgIH0gZWxzZSBpZiAoYXhpcy5nZXREaXJlY3Rpb24oKSA9PT0gXCJ5XCIgLyogWSAqLykge1xuICAgICAgICB5ID8/ICh5ID0gYXhpcy5nZXRab29tKCkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICh4IHx8IHkpIHtcbiAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICB9XG4gIH1cbiAgZ2V0QXhpc1pvb20oYXhpc0lkKSB7XG4gICAgcmV0dXJuIHRoaXMuYXhpc1pvb21NYW5hZ2Vycy5nZXQoYXhpc0lkKT8uZ2V0Wm9vbSgpID8/IHsgbWluOiAwLCBtYXg6IDEgfTtcbiAgfVxuICBnZXRBeGlzWm9vbXMoKSB7XG4gICAgY29uc3QgYXhlcyA9IHt9O1xuICAgIGZvciAoY29uc3QgW2F4aXNJZCwgYXhpc10gb2YgdGhpcy5heGlzWm9vbU1hbmFnZXJzLmVudHJpZXMoKSkge1xuICAgICAgYXhlc1theGlzSWRdID0ge1xuICAgICAgICBkaXJlY3Rpb246IGF4aXMuZ2V0RGlyZWN0aW9uKCksXG4gICAgICAgIHpvb206IGF4aXMuZ2V0Wm9vbSgpXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gYXhlcztcbiAgfVxuICBhcHBseUNoYW5nZXMoY2FsbGVySWQpIHtcbiAgICBjb25zdCBjaGFuZ2VkID0gQXJyYXkuZnJvbSh0aGlzLmF4aXNab29tTWFuYWdlcnMudmFsdWVzKCksIChheGlzKSA9PiBheGlzLmFwcGx5Q2hhbmdlcygpKS5zb21lKEJvb2xlYW4pO1xuICAgIGlmICghY2hhbmdlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBheGVzID0ge307XG4gICAgZm9yIChjb25zdCBbYXhpc0lkLCBheGlzXSBvZiB0aGlzLmF4aXNab29tTWFuYWdlcnMuZW50cmllcygpKSB7XG4gICAgICBheGVzW2F4aXNJZF0gPSBheGlzLmdldFpvb20oKTtcbiAgICB9XG4gICAgdGhpcy5saXN0ZW5lcnMuZGlzcGF0Y2goXCJ6b29tLWNoYW5nZVwiLCB7IHR5cGU6IFwiem9vbS1jaGFuZ2VcIiwgLi4udGhpcy5nZXRab29tKCksIGF4ZXMsIGNhbGxlcklkIH0pO1xuICB9XG4gIGdldFJhbmdlRGlyZWN0aW9uKHpvb20yLCBkaXJlY3Rpb24pIHtcbiAgICBmb3IgKGNvbnN0IGF4aXMgb2YgdGhpcy5heGVzID8/IFtdKSB7XG4gICAgICBpZiAoYXhpcy5kaXJlY3Rpb24gIT09IGRpcmVjdGlvbilcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCBkb21haW4gPSBheGlzLnNjYWxlLmdldERvbWFpbj8uKCk7XG4gICAgICBjb25zdCBkMCA9IGF4aXMuc2NhbGUuY29udmVydD8uKGRvbWFpbj8uYXQoMCkpO1xuICAgICAgY29uc3QgZDEgPSBheGlzLnNjYWxlLmNvbnZlcnQ/Lihkb21haW4/LmF0KC0xKSk7XG4gICAgICBpZiAoIWlzRmluaXRlTnVtYmVyKGQwKSB8fCAhaXNGaW5pdGVOdW1iZXIoZDEpKVxuICAgICAgICByZXR1cm47XG4gICAgICBsZXQgc3RhcnQyO1xuICAgICAgbGV0IGVuZDI7XG4gICAgICBpZiAoZDAgPD0gZDEpIHtcbiAgICAgICAgY29uc3QgZGlmZjIgPSBkMSAtIGQwO1xuICAgICAgICBzdGFydDIgPSBheGlzLnNjYWxlLmludmVydD8uKDApO1xuICAgICAgICBlbmQyID0gYXhpcy5zY2FsZS5pbnZlcnQ/LihkMCArIGRpZmYyICogem9vbTJbZGlyZWN0aW9uXS5tYXgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZGlmZjIgPSBkMCAtIGQxO1xuICAgICAgICBzdGFydDIgPSBheGlzLnNjYWxlLmludmVydD8uKGQwIC0gZGlmZjIgKiB6b29tMltkaXJlY3Rpb25dLm1pbik7XG4gICAgICAgIGVuZDIgPSBheGlzLnNjYWxlLmludmVydD8uKDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0MiwgZW5kOiBlbmQyIH07XG4gICAgfVxuICB9XG4gIGdldERlZmluZWRab29tKCkge1xuICAgIGNvbnN0IHpvb20yID0gdGhpcy5nZXRab29tKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHsgbWluOiB6b29tMj8ueD8ubWluID8/IDAsIG1heDogem9vbTI/Lng/Lm1heCA/PyAxIH0sXG4gICAgICB5OiB7IG1pbjogem9vbTI/Lnk/Lm1pbiA/PyAwLCBtYXg6IHpvb20yPy55Py5tYXggPz8gMSB9XG4gICAgfTtcbiAgfVxufTtcbnZhciBBeGlzWm9vbU1hbmFnZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGF4aXMpIHtcbiAgICB0aGlzLmF4aXMgPSBheGlzO1xuICAgIGNvbnN0IFttaW4gPSAwLCBtYXggPSAxXSA9IGF4aXMudmlzaWJsZVJhbmdlO1xuICAgIHRoaXMuc3RhdGUgPSBuZXcgU3RhdGVUcmFja2VyKHsgbWluLCBtYXggfSk7XG4gICAgdGhpcy5jdXJyZW50Wm9vbSA9IHRoaXMuc3RhdGUuc3RhdGVWYWx1ZSgpO1xuICB9XG4gIGdldERpcmVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5heGlzLmRpcmVjdGlvbjtcbiAgfVxuICB1cGRhdGVab29tKGNhbGxlcklkLCBuZXdab29tKSB7XG4gICAgdGhpcy5zdGF0ZS5zZXQoY2FsbGVySWQsIG5ld1pvb20pO1xuICB9XG4gIGdldFpvb20oKSB7XG4gICAgcmV0dXJuIGRlZXBDbG9uZSh0aGlzLnN0YXRlLnN0YXRlVmFsdWUoKSk7XG4gIH1cbiAgYXBwbHlDaGFuZ2VzKCkge1xuICAgIGNvbnN0IHByZXZab29tID0gdGhpcy5jdXJyZW50Wm9vbTtcbiAgICB0aGlzLmN1cnJlbnRab29tID0gdGhpcy5zdGF0ZS5zdGF0ZVZhbHVlKCk7XG4gICAgcmV0dXJuIHByZXZab29tLm1pbiAhPT0gdGhpcy5jdXJyZW50Wm9vbS5taW4gfHwgcHJldlpvb20ubWF4ICE9PSB0aGlzLmN1cnJlbnRab29tLm1heDtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL3Nlcmllc1N0YXRlTWFuYWdlci50c1xudmFyIFNlcmllc1N0YXRlTWFuYWdlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgfVxuICByZWdpc3RlclNlcmllcyh7IGludGVybmFsSWQsIHNlcmllc0dyb3VwaW5nLCB2aXNpYmxlLCB0eXBlIH0pIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCFzZXJpZXNHcm91cGluZylcbiAgICAgIHJldHVybjtcbiAgICAoX2EgPSB0aGlzLmdyb3VwcylbdHlwZV0gPz8gKF9hW3R5cGVdID0ge30pO1xuICAgIHRoaXMuZ3JvdXBzW3R5cGVdW2ludGVybmFsSWRdID0geyBncm91cGluZzogc2VyaWVzR3JvdXBpbmcsIHZpc2libGUgfTtcbiAgfVxuICB1cGRhdGVTZXJpZXMoeyBpbnRlcm5hbElkLCBzZXJpZXNHcm91cGluZywgdmlzaWJsZSwgdHlwZSB9KSB7XG4gICAgaWYgKCFzZXJpZXNHcm91cGluZylcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlbnRyeSA9IHRoaXMuZ3JvdXBzW3R5cGVdPy5baW50ZXJuYWxJZF07XG4gICAgaWYgKGVudHJ5KSB7XG4gICAgICBlbnRyeS5ncm91cGluZyA9IHNlcmllc0dyb3VwaW5nO1xuICAgICAgZW50cnkudmlzaWJsZSA9IHZpc2libGU7XG4gICAgfVxuICB9XG4gIGRlcmVnaXN0ZXJTZXJpZXMoeyBpbnRlcm5hbElkLCB0eXBlIH0pIHtcbiAgICBpZiAodGhpcy5ncm91cHNbdHlwZV0pIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmdyb3Vwc1t0eXBlXVtpbnRlcm5hbElkXTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZ3JvdXBzW3R5cGVdICYmIE9iamVjdC5rZXlzKHRoaXMuZ3JvdXBzW3R5cGVdKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmdyb3Vwc1t0eXBlXTtcbiAgICB9XG4gIH1cbiAgZ2V0VmlzaWJsZVBlZXJHcm91cEluZGV4KHsgdHlwZSwgc2VyaWVzR3JvdXBpbmcsIHZpc2libGUgfSkge1xuICAgIGlmICghc2VyaWVzR3JvdXBpbmcpXG4gICAgICByZXR1cm4geyB2aXNpYmxlR3JvdXBDb3VudDogdmlzaWJsZSA/IDEgOiAwLCB2aXNpYmxlU2FtZVN0YWNrQ291bnQ6IHZpc2libGUgPyAxIDogMCwgaW5kZXg6IDAgfTtcbiAgICBjb25zdCB2aXNpYmxlR3JvdXBzU2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjb25zdCB2aXNpYmxlU2FtZVN0YWNrU2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIE9iamVjdC52YWx1ZXModGhpcy5ncm91cHNbdHlwZV0gPz8ge30pKSB7XG4gICAgICBpZiAoIWVudHJ5LnZpc2libGUpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgdmlzaWJsZUdyb3Vwc1NldC5hZGQoZW50cnkuZ3JvdXBpbmcuZ3JvdXBJbmRleCk7XG4gICAgICBpZiAoZW50cnkuZ3JvdXBpbmcuZ3JvdXBJbmRleCA9PT0gc2VyaWVzR3JvdXBpbmcuZ3JvdXBJbmRleCkge1xuICAgICAgICB2aXNpYmxlU2FtZVN0YWNrU2V0LmFkZChlbnRyeS5ncm91cGluZy5zdGFja0luZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdmlzaWJsZUdyb3VwcyA9IEFycmF5LmZyb20odmlzaWJsZUdyb3Vwc1NldCk7XG4gICAgdmlzaWJsZUdyb3Vwcy5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZpc2libGVHcm91cENvdW50OiB2aXNpYmxlR3JvdXBzLmxlbmd0aCxcbiAgICAgIHZpc2libGVTYW1lU3RhY2tDb3VudDogdmlzaWJsZVNhbWVTdGFja1NldC5zaXplLFxuICAgICAgaW5kZXg6IHZpc2libGVHcm91cHMuaW5kZXhPZihzZXJpZXNHcm91cGluZy5ncm91cEluZGV4KVxuICAgIH07XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2NoYXJ0VXBkYXRlVHlwZS50c1xudmFyIENoYXJ0VXBkYXRlVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKENoYXJ0VXBkYXRlVHlwZTIpID0+IHtcbiAgQ2hhcnRVcGRhdGVUeXBlMltDaGFydFVwZGF0ZVR5cGUyW1wiRlVMTFwiXSA9IDBdID0gXCJGVUxMXCI7XG4gIENoYXJ0VXBkYXRlVHlwZTJbQ2hhcnRVcGRhdGVUeXBlMltcIlVQREFURV9EQVRBXCJdID0gMV0gPSBcIlVQREFURV9EQVRBXCI7XG4gIENoYXJ0VXBkYXRlVHlwZTJbQ2hhcnRVcGRhdGVUeXBlMltcIlBST0NFU1NfREFUQVwiXSA9IDJdID0gXCJQUk9DRVNTX0RBVEFcIjtcbiAgQ2hhcnRVcGRhdGVUeXBlMltDaGFydFVwZGF0ZVR5cGUyW1wiUEVSRk9STV9MQVlPVVRcIl0gPSAzXSA9IFwiUEVSRk9STV9MQVlPVVRcIjtcbiAgQ2hhcnRVcGRhdGVUeXBlMltDaGFydFVwZGF0ZVR5cGUyW1wiU0VSSUVTX1VQREFURVwiXSA9IDRdID0gXCJTRVJJRVNfVVBEQVRFXCI7XG4gIENoYXJ0VXBkYXRlVHlwZTJbQ2hhcnRVcGRhdGVUeXBlMltcIlBSRV9TQ0VORV9SRU5ERVJcIl0gPSA1XSA9IFwiUFJFX1NDRU5FX1JFTkRFUlwiO1xuICBDaGFydFVwZGF0ZVR5cGUyW0NoYXJ0VXBkYXRlVHlwZTJbXCJTQ0VORV9SRU5ERVJcIl0gPSA2XSA9IFwiU0NFTkVfUkVOREVSXCI7XG4gIENoYXJ0VXBkYXRlVHlwZTJbQ2hhcnRVcGRhdGVUeXBlMltcIk5PTkVcIl0gPSA3XSA9IFwiTk9ORVwiO1xuICByZXR1cm4gQ2hhcnRVcGRhdGVUeXBlMjtcbn0pKENoYXJ0VXBkYXRlVHlwZSB8fCB7fSk7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3VwZGF0ZVNlcnZpY2UudHNcbnZhciBVcGRhdGVTZXJ2aWNlID0gY2xhc3MgZXh0ZW5kcyBMaXN0ZW5lcnMge1xuICBjb25zdHJ1Y3Rvcih1cGRhdGVDYWxsYmFjaykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy51cGRhdGVDYWxsYmFjayA9IHVwZGF0ZUNhbGxiYWNrO1xuICB9XG4gIHVwZGF0ZSh0eXBlID0gMCAvKiBGVUxMICovLCBvcHRpb25zKSB7XG4gICAgdGhpcy51cGRhdGVDYWxsYmFjayh0eXBlLCBvcHRpb25zKTtcbiAgfVxuICBkaXNwYXRjaFVwZGF0ZUNvbXBsZXRlKHJlY3RzKSB7XG4gICAgdGhpcy5kaXNwYXRjaChcInVwZGF0ZS1jb21wbGV0ZVwiLCB7XG4gICAgICB0eXBlOiBcInVwZGF0ZS1jb21wbGV0ZVwiLFxuICAgICAgbWluUmVjdDogcmVjdHM/Lm1pblJlY3QsXG4gICAgICBtaW5WaXNpYmxlUmVjdDogcmVjdHM/Lm1pblZpc2libGVSZWN0XG4gICAgfSk7XG4gIH1cbiAgZGlzcGF0Y2hQcmVEb21VcGRhdGUoKSB7XG4gICAgdGhpcy5kaXNwYXRjaChcInByZS1kb20tdXBkYXRlXCIsIHsgdHlwZTogXCJwcmUtZG9tLXVwZGF0ZVwiIH0pO1xuICB9XG4gIGRpc3BhdGNoUHJlU2NlbmVSZW5kZXIocmVjdHMpIHtcbiAgICB0aGlzLmRpc3BhdGNoKFwicHJlLXNjZW5lLXJlbmRlclwiLCB7IHR5cGU6IFwicHJlLXNjZW5lLXJlbmRlclwiLCAuLi5yZWN0cyB9KTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvY2hhcnRDb250ZXh0LnRzXG52YXIgQ2hhcnRDb250ZXh0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjaGFydCwgdmFycykge1xuICAgIHRoaXMuY2FsbGJhY2tDYWNoZSA9IG5ldyBDYWxsYmFja0NhY2hlKCk7XG4gICAgdGhpcy5jaGFydEV2ZW50TWFuYWdlciA9IG5ldyBDaGFydEV2ZW50TWFuYWdlcigpO1xuICAgIHRoaXMuaGlnaGxpZ2h0TWFuYWdlciA9IG5ldyBIaWdobGlnaHRNYW5hZ2VyKCk7XG4gICAgdGhpcy5sYXlvdXRNYW5hZ2VyID0gbmV3IExheW91dE1hbmFnZXIoKTtcbiAgICB0aGlzLmxvY2FsZU1hbmFnZXIgPSBuZXcgTG9jYWxlTWFuYWdlcigpO1xuICAgIHRoaXMuc2VyaWVzU3RhdGVNYW5hZ2VyID0gbmV3IFNlcmllc1N0YXRlTWFuYWdlcigpO1xuICAgIHRoaXMuc3RhdGVNYW5hZ2VyID0gbmV3IFN0YXRlTWFuYWdlcigpO1xuICAgIHRoaXMudG9vbGJhck1hbmFnZXIgPSBuZXcgVG9vbGJhck1hbmFnZXIoKTtcbiAgICB0aGlzLnpvb21NYW5hZ2VyID0gbmV3IFpvb21NYW5hZ2VyKCk7XG4gICAgY29uc3QgeyBzY2VuZSwgcm9vdCwgc3luY01hbmFnZXIsIGNvbnRhaW5lciwgdXBkYXRlQ2FsbGJhY2ssIHVwZGF0ZU11dGV4LCBwaXhlbFJhdGlvLCBzdHlsZUNvbnRhaW5lciB9ID0gdmFycztcbiAgICB0aGlzLmNoYXJ0U2VydmljZSA9IGNoYXJ0O1xuICAgIHRoaXMuc3luY01hbmFnZXIgPSBzeW5jTWFuYWdlcjtcbiAgICB0aGlzLmRvbU1hbmFnZXIgPSBuZXcgRE9NTWFuYWdlcihjb250YWluZXIsIHN0eWxlQ29udGFpbmVyKTtcbiAgICBjb25zdCBjYW52YXNFbGVtZW50ID0gdGhpcy5kb21NYW5hZ2VyLmFkZENoaWxkKFxuICAgICAgXCJjYW52YXNcIixcbiAgICAgIFwic2NlbmUtY2FudmFzXCIsXG4gICAgICBzY2VuZT8uY2FudmFzLmVsZW1lbnRcbiAgICApO1xuICAgIHRoaXMuc2NlbmUgPSBzY2VuZSA/PyBuZXcgU2NlbmUoeyBwaXhlbFJhdGlvLCBjYW52YXNFbGVtZW50IH0pO1xuICAgIHRoaXMuc2NlbmUuc2V0Um9vdChyb290KTtcbiAgICB0aGlzLmF4aXNNYW5hZ2VyID0gbmV3IEF4aXNNYW5hZ2VyKHJvb3QpO1xuICAgIHRoaXMuYW5ub3RhdGlvbk1hbmFnZXIgPSBuZXcgQW5ub3RhdGlvbk1hbmFnZXIoY2hhcnQuYW5ub3RhdGlvblJvb3QpO1xuICAgIHRoaXMuY3Vyc29yTWFuYWdlciA9IG5ldyBDdXJzb3JNYW5hZ2VyKHRoaXMuZG9tTWFuYWdlcik7XG4gICAgdGhpcy5pbnRlcmFjdGlvbk1hbmFnZXIgPSBuZXcgSW50ZXJhY3Rpb25NYW5hZ2VyKGNoYXJ0LmtleWJvYXJkLCB0aGlzLmRvbU1hbmFnZXIpO1xuICAgIHRoaXMuZm9jdXNJbmRpY2F0b3IgPSBuZXcgRm9jdXNJbmRpY2F0b3IodGhpcy5kb21NYW5hZ2VyKTtcbiAgICB0aGlzLmtleU5hdk1hbmFnZXIgPSBuZXcgS2V5TmF2TWFuYWdlcih0aGlzLmZvY3VzSW5kaWNhdG9yLCB0aGlzLmludGVyYWN0aW9uTWFuYWdlciwgY2hhcnQubW9kZSk7XG4gICAgdGhpcy5yZWdpb25NYW5hZ2VyID0gbmV3IFJlZ2lvbk1hbmFnZXIodGhpcy5pbnRlcmFjdGlvbk1hbmFnZXIpO1xuICAgIHRoaXMuY29udGV4dE1lbnVSZWdpc3RyeSA9IG5ldyBDb250ZXh0TWVudVJlZ2lzdHJ5KHRoaXMucmVnaW9uTWFuYWdlcik7XG4gICAgdGhpcy5nZXN0dXJlRGV0ZWN0b3IgPSBuZXcgR2VzdHVyZURldGVjdG9yKHRoaXMuZG9tTWFuYWdlcik7XG4gICAgdGhpcy51cGRhdGVTZXJ2aWNlID0gbmV3IFVwZGF0ZVNlcnZpY2UodXBkYXRlQ2FsbGJhY2spO1xuICAgIHRoaXMucHJveHlJbnRlcmFjdGlvblNlcnZpY2UgPSBuZXcgUHJveHlJbnRlcmFjdGlvblNlcnZpY2UodGhpcy5sb2NhbGVNYW5hZ2VyLCB0aGlzLmRvbU1hbmFnZXIpO1xuICAgIHRoaXMuaGlzdG9yeU1hbmFnZXIgPSBuZXcgSGlzdG9yeU1hbmFnZXIodGhpcy5rZXlOYXZNYW5hZ2VyKTtcbiAgICB0aGlzLmFuaW1hdGlvbk1hbmFnZXIgPSBuZXcgQW5pbWF0aW9uTWFuYWdlcih0aGlzLmludGVyYWN0aW9uTWFuYWdlciwgdXBkYXRlTXV0ZXgpO1xuICAgIHRoaXMuZGF0YVNlcnZpY2UgPSBuZXcgRGF0YVNlcnZpY2UodGhpcy5hbmltYXRpb25NYW5hZ2VyKTtcbiAgICB0aGlzLnRvb2x0aXBNYW5hZ2VyID0gbmV3IFRvb2x0aXBNYW5hZ2VyKHRoaXMuZG9tTWFuYWdlciwgY2hhcnQudG9vbHRpcCk7XG4gICAgdGhpcy56b29tTWFuYWdlci5hZGRMYXlvdXRMaXN0ZW5lcnModGhpcy5sYXlvdXRNYW5hZ2VyKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuYW5pbWF0aW9uTWFuYWdlci5kZXN0cm95KCk7XG4gICAgdGhpcy5oaWdobGlnaHRNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmF4aXNNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmNhbGxiYWNrQ2FjaGUuaW52YWxpZGF0ZUNhY2hlKCk7XG4gICAgdGhpcy5jaGFydEV2ZW50TWFuYWdlci5kZXN0cm95KCk7XG4gICAgdGhpcy5jb250ZXh0TWVudVJlZ2lzdHJ5LmRlc3Ryb3koKTtcbiAgICB0aGlzLmRvbU1hbmFnZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuaGlnaGxpZ2h0TWFuYWdlci5kZXN0cm95KCk7XG4gICAgdGhpcy5pbnRlcmFjdGlvbk1hbmFnZXIuZGVzdHJveSgpO1xuICAgIHRoaXMua2V5TmF2TWFuYWdlci5kZXN0cm95KCk7XG4gICAgdGhpcy5mb2N1c0luZGljYXRvci5kZXN0cm95KCk7XG4gICAgdGhpcy5wcm94eUludGVyYWN0aW9uU2VydmljZS5kZXN0cm95KCk7XG4gICAgdGhpcy5yZWdpb25NYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB0aGlzLnN5bmNNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB0aGlzLnRvb2x0aXBNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB0aGlzLnpvb21NYW5hZ2VyLmRlc3Ryb3koKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvY2hhcnRIaWdobGlnaHQudHNcbnZhciBDaGFydEhpZ2hsaWdodCA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMucmFuZ2UgPSBcInRvb2x0aXBcIjtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFVOSU9OKFtcInRvb2x0aXBcIiwgXCJub2RlXCJdLCBcImEgcmFuZ2VcIikpXG5dLCBDaGFydEhpZ2hsaWdodC5wcm90b3R5cGUsIFwicmFuZ2VcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2RhdGEvZGF0YURvbWFpbi50c1xudmFyIERpc2NyZXRlRG9tYWluID0gY2xhc3MgX0Rpc2NyZXRlRG9tYWluIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5kb21haW4gPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICB9XG4gIHN0YXRpYyBpcyh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIF9EaXNjcmV0ZURvbWFpbjtcbiAgfVxuICBleHRlbmQodmFsKSB7XG4gICAgdGhpcy5kb21haW4uYWRkKHZhbCk7XG4gIH1cbiAgZ2V0RG9tYWluKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuZG9tYWluKTtcbiAgfVxufTtcbnZhciBDb250aW51b3VzRG9tYWluID0gY2xhc3MgX0NvbnRpbnVvdXNEb21haW4ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmRvbWFpbiA9IFtJbmZpbml0eSwgLUluZmluaXR5XTtcbiAgfVxuICBzdGF0aWMgaXModmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBfQ29udGludW91c0RvbWFpbjtcbiAgfVxuICBzdGF0aWMgZXh0ZW5kRG9tYWluKHZhbHVlcywgZG9tYWluID0gW0luZmluaXR5LCAtSW5maW5pdHldKSB7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoZG9tYWluWzBdID4gdmFsdWUpIHtcbiAgICAgICAgZG9tYWluWzBdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoZG9tYWluWzFdIDwgdmFsdWUpIHtcbiAgICAgICAgZG9tYWluWzFdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkb21haW47XG4gIH1cbiAgZXh0ZW5kKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuZG9tYWluWzBdID4gdmFsdWUpIHtcbiAgICAgIHRoaXMuZG9tYWluWzBdID0gdmFsdWU7XG4gICAgfVxuICAgIGlmICh0aGlzLmRvbWFpblsxXSA8IHZhbHVlKSB7XG4gICAgICB0aGlzLmRvbWFpblsxXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICBnZXREb21haW4oKSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLmRvbWFpbl07XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2RhdGEvZGF0YU1vZGVsLnRzXG5mdW5jdGlvbiB0b0tleVN0cmluZyhrZXlzKSB7XG4gIHJldHVybiBrZXlzLm1hcCgoa2V5KSA9PiBpc09iamVjdChrZXkpID8gSlNPTi5zdHJpbmdpZnkoa2V5KSA6IGtleSkuam9pbihcIi1cIik7XG59XG5mdW5jdGlvbiByb3VuZDIodmFsKSB7XG4gIGNvbnN0IGFjY3VyYWN5ID0gMWU0O1xuICBpZiAoTnVtYmVyLmlzSW50ZWdlcih2YWwpKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfSBlbHNlIGlmIChNYXRoLmFicyh2YWwpID4gYWNjdXJhY3kpIHtcbiAgICByZXR1cm4gTWF0aC50cnVuYyh2YWwpO1xuICB9XG4gIHJldHVybiBNYXRoLnJvdW5kKHZhbCAqIGFjY3VyYWN5KSAvIGFjY3VyYWN5O1xufVxuZnVuY3Rpb24gZml4TnVtZXJpY0V4dGVudChleHRlbnQyKSB7XG4gIGlmIChleHRlbnQyID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgY29uc3QgW21pbiwgbWF4XSA9IGV4dGVudDIubWFwKE51bWJlcik7XG4gIGlmIChtaW4gPT09IDAgJiYgbWF4ID09PSAwKSB7XG4gICAgcmV0dXJuIFswLCAxXTtcbiAgfVxuICByZXR1cm4gaXNGaW5pdGVOdW1iZXIobWluKSAmJiBpc0Zpbml0ZU51bWJlcihtYXgpID8gW21pbiwgbWF4XSA6IFtdO1xufVxuZnVuY3Rpb24gZ2V0TWlzc0NvdW50KHNjb3BlUHJvdmlkZXIsIG1pc3NNYXApIHtcbiAgcmV0dXJuIG1pc3NNYXA/LmdldChzY29wZVByb3ZpZGVyLmlkKSA/PyAwO1xufVxudmFyIElOVkFMSURfVkFMVUUgPSBTeW1ib2woXCJpbnZhbGlkXCIpO1xuZnVuY3Rpb24gZ2V0UGF0aENvbXBvbmVudHMocGF0aCkge1xuICBjb25zdCBjb21wb25lbnRzID0gW107XG4gIGxldCBtYXRjaEluZGV4ID0gMDtcbiAgbGV0IG1hdGNoR3JvdXA7XG4gIGNvbnN0IHJlZ0V4cCA9IC8oKD86KD86XnxcXC4pXFxzKlxcdyt8XFxbXFxzKig/OicoPzpbXiddfFxcXFwnKSonfFwiKD86W15cIl18XFxcXFwiKSpcInwtP1xcZCspXFxzKlxcXSlcXHMqKS9nO1xuICB3aGlsZSAobWF0Y2hHcm91cCA9IHJlZ0V4cC5leGVjKHBhdGgpKSB7XG4gICAgaWYgKG1hdGNoR3JvdXAuaW5kZXggIT09IG1hdGNoSW5kZXgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbWF0Y2hJbmRleCA9IG1hdGNoR3JvdXAuaW5kZXggKyBtYXRjaEdyb3VwWzBdLmxlbmd0aDtcbiAgICBjb25zdCBtYXRjaCA9IG1hdGNoR3JvdXBbMV0udHJpbSgpO1xuICAgIGlmIChtYXRjaC5zdGFydHNXaXRoKFwiLlwiKSkge1xuICAgICAgY29tcG9uZW50cy5wdXNoKG1hdGNoLnNsaWNlKDEpLnRyaW0oKSk7XG4gICAgfSBlbHNlIGlmIChtYXRjaC5zdGFydHNXaXRoKFwiW1wiKSkge1xuICAgICAgY29uc3QgYWNjZXNzb3IgPSBtYXRjaC5zbGljZSgxLCAtMSkudHJpbSgpO1xuICAgICAgaWYgKGFjY2Vzc29yLnN0YXJ0c1dpdGgoYCdgKSkge1xuICAgICAgICBjb21wb25lbnRzLnB1c2goYWNjZXNzb3Iuc2xpY2UoMSwgLTEpLnJlcGxhY2UoL1xcXFwnL2csIGAnYCkpO1xuICAgICAgfSBlbHNlIGlmIChhY2Nlc3Nvci5zdGFydHNXaXRoKGBcImApKSB7XG4gICAgICAgIGNvbXBvbmVudHMucHVzaChhY2Nlc3Nvci5zbGljZSgxLCAtMSkucmVwbGFjZSgvXFxcXFwiL2csIGBcImApKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbXBvbmVudHMucHVzaChhY2Nlc3Nvcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBvbmVudHMucHVzaChtYXRjaCk7XG4gICAgfVxuICB9XG4gIGlmIChtYXRjaEluZGV4ICE9PSBwYXRoLmxlbmd0aClcbiAgICByZXR1cm47XG4gIHJldHVybiBjb21wb25lbnRzO1xufVxuZnVuY3Rpb24gY3JlYXRlUGF0aEFjY2Vzc29yKGNvbXBvbmVudHMpIHtcbiAgcmV0dXJuIChkYXR1bSkgPT4ge1xuICAgIGxldCBjdXJyZW50ID0gZGF0dW07XG4gICAgZm9yIChjb25zdCBjb21wb25lbnQgb2YgY29tcG9uZW50cykge1xuICAgICAgY3VycmVudCA9IGN1cnJlbnRbY29tcG9uZW50XTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG4gIH07XG59XG52YXIgRGF0YU1vZGVsID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRzLCBtb2RlID0gXCJzdGFuZGFsb25lXCIpIHtcbiAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgdGhpcy5kZWJ1ZyA9IERlYnVnLmNyZWF0ZSh0cnVlLCBcImRhdGEtbW9kZWxcIik7XG4gICAgdGhpcy5zY29wZUNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLmtleXMgPSBbXTtcbiAgICB0aGlzLnZhbHVlcyA9IFtdO1xuICAgIHRoaXMuYWdncmVnYXRlcyA9IFtdO1xuICAgIHRoaXMuZ3JvdXBQcm9jZXNzb3JzID0gW107XG4gICAgdGhpcy5wcm9wZXJ0eVByb2Nlc3NvcnMgPSBbXTtcbiAgICB0aGlzLnJlZHVjZXJzID0gW107XG4gICAgdGhpcy5wcm9jZXNzb3JzID0gW107XG4gICAgbGV0IGtleXMgPSB0cnVlO1xuICAgIGZvciAoY29uc3QgbmV4dCBvZiBvcHRzLnByb3BzKSB7XG4gICAgICBpZiAobmV4dC50eXBlID09PSBcImtleVwiICYmICFrZXlzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFHIENoYXJ0cyAtIGludGVybmFsIGNvbmZpZyBlcnJvcjoga2V5cyBtdXN0IGNvbWUgYmVmb3JlIHZhbHVlcy5cIik7XG4gICAgICB9XG4gICAgICBpZiAobmV4dC50eXBlID09PSBcInZhbHVlXCIgJiYga2V5cykge1xuICAgICAgICBrZXlzID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHZlcmlmeU1hdGNoR3JvdXBJZCA9ICh7IG1hdGNoR3JvdXBJZHMgPSBbXSB9KSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IG1hdGNoR3JvdXBJZCBvZiBtYXRjaEdyb3VwSWRzKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlcy5ldmVyeSgoZGVmKSA9PiBkZWYuZ3JvdXBJZCAhPT0gbWF0Y2hHcm91cElkKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBBRyBDaGFydHMgLSBpbnRlcm5hbCBjb25maWcgZXJyb3I6IG1hdGNoR3JvdXBJZHMgcHJvcGVydGllcyBtdXN0IG1hdGNoIGRlZmluZWQgZ3JvdXBzICgke21hdGNoR3JvdXBJZH0pLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IGRlZiBvZiBvcHRzLnByb3BzKSB7XG4gICAgICBzd2l0Y2ggKGRlZi50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJrZXlcIjpcbiAgICAgICAgICB0aGlzLmtleXMucHVzaCh7IC4uLmRlZiwgaW5kZXg6IHRoaXMua2V5cy5sZW5ndGgsIG1pc3Npbmc6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ2YWx1ZVwiOlxuICAgICAgICAgIGlmIChkZWYucHJvcGVydHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgQUcgQ2hhcnRzIC0gaW50ZXJuYWwgY29uZmlnIGVycm9yOiBubyBwcm9wZXJ0aWVzIHNwZWNpZmllZCBmb3IgdmFsdWUgZGVmaW5pdGlvbnM6ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgZGVmXG4gICAgICAgICAgICAgICl9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy52YWx1ZXMucHVzaCh7IC4uLmRlZiwgaW5kZXg6IHRoaXMudmFsdWVzLmxlbmd0aCwgbWlzc2luZzogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImFnZ3JlZ2F0ZVwiOlxuICAgICAgICAgIHZlcmlmeU1hdGNoR3JvdXBJZChkZWYpO1xuICAgICAgICAgIHRoaXMuYWdncmVnYXRlcy5wdXNoKHsgLi4uZGVmLCBpbmRleDogdGhpcy5hZ2dyZWdhdGVzLmxlbmd0aCB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImdyb3VwLXZhbHVlLXByb2Nlc3NvclwiOlxuICAgICAgICAgIHZlcmlmeU1hdGNoR3JvdXBJZChkZWYpO1xuICAgICAgICAgIHRoaXMuZ3JvdXBQcm9jZXNzb3JzLnB1c2goeyAuLi5kZWYsIGluZGV4OiB0aGlzLmdyb3VwUHJvY2Vzc29ycy5sZW5ndGggfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJwcm9wZXJ0eS12YWx1ZS1wcm9jZXNzb3JcIjpcbiAgICAgICAgICB0aGlzLnByb3BlcnR5UHJvY2Vzc29ycy5wdXNoKHsgLi4uZGVmLCBpbmRleDogdGhpcy5wcm9wZXJ0eVByb2Nlc3NvcnMubGVuZ3RoIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicmVkdWNlclwiOlxuICAgICAgICAgIHRoaXMucmVkdWNlcnMucHVzaCh7IC4uLmRlZiwgaW5kZXg6IHRoaXMucmVkdWNlcnMubGVuZ3RoIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicHJvY2Vzc29yXCI6XG4gICAgICAgICAgdGhpcy5wcm9jZXNzb3JzLnB1c2goeyAuLi5kZWYsIGluZGV4OiB0aGlzLnByb2Nlc3NvcnMubGVuZ3RoIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXNvbHZlUHJvY2Vzc2VkRGF0YURlZkJ5SWQoc2NvcGUsIHNlYXJjaElkKSB7XG4gICAgY29uc3QgZGVmID0gdGhpcy5zY29wZUNhY2hlLmdldChzY29wZS5pZCk/LmdldChzZWFyY2hJZCk7XG4gICAgaWYgKCFkZWYpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQUcgQ2hhcnRzIC0gZGlkbid0IGZpbmQgcHJvcGVydHkgZGVmaW5pdGlvbiBmb3IgWyR7c2VhcmNoSWR9LCAke3Njb3BlLmlkfV1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgaW5kZXg6IGRlZi5pbmRleCwgZGVmIH07XG4gIH1cbiAgcmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQoc2NvcGUsIHNlYXJjaElkKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x2ZVByb2Nlc3NlZERhdGFEZWZCeUlkKHNjb3BlLCBzZWFyY2hJZCkuaW5kZXg7XG4gIH1cbiAgcmVzb2x2ZVByb2Nlc3NlZERhdGFEZWZzQnlJZHMoc2NvcGUsIHNlYXJjaElkcykge1xuICAgIHJldHVybiBzZWFyY2hJZHMubWFwKChzZWFyY2hJZCkgPT4gW3NlYXJjaElkLCB0aGlzLnJlc29sdmVQcm9jZXNzZWREYXRhRGVmQnlJZChzY29wZSwgc2VhcmNoSWQpXSk7XG4gIH1cbiAgcmVzb2x2ZVByb2Nlc3NlZERhdGFEZWZzVmFsdWVzKGRlZnMsIHsga2V5cywgdmFsdWVzIH0pIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtzZWFyY2hJZCwgeyBpbmRleCwgZGVmIH1dIG9mIGRlZnMpIHtcbiAgICAgIGNvbnN0IHByb2Nlc3NlZERhdGEgPSBkZWYudHlwZSA9PT0gXCJrZXlcIiA/IGtleXMgOiB2YWx1ZXM7XG4gICAgICByZXN1bHRbc2VhcmNoSWRdID0gcHJvY2Vzc2VkRGF0YVtpbmRleF07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZ2V0RG9tYWluKHNjb3BlLCBzZWFyY2hJZCwgdHlwZSA9IFwidmFsdWVcIiwgcHJvY2Vzc2VkRGF0YSkge1xuICAgIGNvbnN0IGRvbWFpbnMgPSB0aGlzLmdldERvbWFpbnNCeVR5cGUodHlwZSwgcHJvY2Vzc2VkRGF0YSk7XG4gICAgcmV0dXJuIGRvbWFpbnM/Llt0aGlzLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHNjb3BlLCBzZWFyY2hJZCldID8/IFtdO1xuICB9XG4gIGdldERvbWFpbnNCeVR5cGUodHlwZSwgcHJvY2Vzc2VkRGF0YSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBcImtleVwiOlxuICAgICAgICByZXR1cm4gcHJvY2Vzc2VkRGF0YS5kb21haW4ua2V5cztcbiAgICAgIGNhc2UgXCJ2YWx1ZVwiOlxuICAgICAgICByZXR1cm4gcHJvY2Vzc2VkRGF0YS5kb21haW4udmFsdWVzO1xuICAgICAgY2FzZSBcImFnZ3JlZ2F0ZVwiOlxuICAgICAgICByZXR1cm4gcHJvY2Vzc2VkRGF0YS5kb21haW4uYWdnVmFsdWVzO1xuICAgICAgY2FzZSBcImdyb3VwLXZhbHVlLXByb2Nlc3NvclwiOlxuICAgICAgICByZXR1cm4gcHJvY2Vzc2VkRGF0YS5kb21haW4uZ3JvdXBzO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHByb2Nlc3NEYXRhKGRhdGEsIHNvdXJjZXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBvcHRzOiB7IGdyb3VwQnlLZXlzLCBncm91cEJ5Rm4gfSxcbiAgICAgIGFnZ3JlZ2F0ZXMsXG4gICAgICBncm91cFByb2Nlc3NvcnMsXG4gICAgICByZWR1Y2VycyxcbiAgICAgIHByb2Nlc3NvcnMsXG4gICAgICBwcm9wZXJ0eVByb2Nlc3NvcnNcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBzdGFydDIgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBpZiAoZ3JvdXBCeUtleXMgJiYgdGhpcy5rZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgcHJvY2Vzc2VkRGF0YSA9IHRoaXMuZXh0cmFjdERhdGEoZGF0YSwgc291cmNlcyk7XG4gICAgaWYgKGdyb3VwQnlLZXlzKSB7XG4gICAgICBwcm9jZXNzZWREYXRhID0gdGhpcy5ncm91cERhdGEocHJvY2Vzc2VkRGF0YSk7XG4gICAgfSBlbHNlIGlmIChncm91cEJ5Rm4pIHtcbiAgICAgIHByb2Nlc3NlZERhdGEgPSB0aGlzLmdyb3VwRGF0YShwcm9jZXNzZWREYXRhLCBncm91cEJ5Rm4ocHJvY2Vzc2VkRGF0YSkpO1xuICAgIH1cbiAgICBpZiAoZ3JvdXBQcm9jZXNzb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMucG9zdFByb2Nlc3NHcm91cHMocHJvY2Vzc2VkRGF0YSk7XG4gICAgfVxuICAgIGlmIChhZ2dyZWdhdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuYWdncmVnYXRlRGF0YShwcm9jZXNzZWREYXRhKTtcbiAgICB9XG4gICAgaWYgKHByb3BlcnR5UHJvY2Vzc29ycy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLnBvc3RQcm9jZXNzUHJvcGVydGllcyhwcm9jZXNzZWREYXRhKTtcbiAgICB9XG4gICAgaWYgKHJlZHVjZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMucmVkdWNlRGF0YShwcm9jZXNzZWREYXRhKTtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3NvcnMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5wb3N0UHJvY2Vzc0RhdGEocHJvY2Vzc2VkRGF0YSk7XG4gICAgfVxuICAgIGlmIChkYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAoY29uc3QgZGVmIG9mIGl0ZXJhdGUodGhpcy5rZXlzLCB0aGlzLnZhbHVlcykpIHtcbiAgICAgICAgZm9yIChjb25zdCBbc2NvcGUsIG1pc3NDb3VudF0gb2YgZGVmLm1pc3NpbmcpIHtcbiAgICAgICAgICBpZiAobWlzc0NvdW50ID49IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBzY29wZUhpbnQgPSBzY29wZSA9PSBudWxsID8gXCJcIiA6IGAgZm9yICR7c2NvcGV9YDtcbiAgICAgICAgICAgIExvZ2dlci53YXJuT25jZShgdGhlIGtleSAnJHtkZWYucHJvcGVydHl9JyB3YXMgbm90IGZvdW5kIGluIGFueSBkYXRhIGVsZW1lbnQke3Njb3BlSGludH0uYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGVuZDIgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBwcm9jZXNzZWREYXRhLnRpbWUgPSBlbmQyIC0gc3RhcnQyO1xuICAgIGlmICh0aGlzLmRlYnVnLmNoZWNrKCkpIHtcbiAgICAgIGxvZ1Byb2Nlc3NlZERhdGEocHJvY2Vzc2VkRGF0YSk7XG4gICAgfVxuICAgIHRoaXMuc2NvcGVDYWNoZS5jbGVhcigpO1xuICAgIGZvciAoY29uc3QgZGVmIG9mIGl0ZXJhdGUodGhpcy5rZXlzLCB0aGlzLnZhbHVlcywgdGhpcy5hZ2dyZWdhdGVzKSkge1xuICAgICAgaWYgKCFkZWYuaWRzTWFwKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGZvciAoY29uc3QgW3Njb3BlLCBpZHNdIG9mIGRlZi5pZHNNYXApIHtcbiAgICAgICAgZm9yIChjb25zdCBpZCBvZiBpZHMpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuc2NvcGVDYWNoZS5oYXMoc2NvcGUpKSB7XG4gICAgICAgICAgICB0aGlzLnNjb3BlQ2FjaGUuc2V0KHNjb3BlLCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbW2lkLCBkZWZdXSkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5zY29wZUNhY2hlLmdldChzY29wZSk/LmhhcyhpZCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImR1cGxpY2F0ZSBkZWZpbml0aW9uIGlkcyBvbiB0aGUgc2FtZSBzY29wZSBhcmUgbm90IGFsbG93ZWQuXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNjb3BlQ2FjaGUuZ2V0KHNjb3BlKS5zZXQoaWQsIGRlZik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcm9jZXNzZWREYXRhO1xuICB9XG4gIHZhbHVlR3JvdXBJZHhMb29rdXAoeyBtYXRjaEdyb3VwSWRzIH0pIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtpbmRleCwgZGVmXSBvZiB0aGlzLnZhbHVlcy5lbnRyaWVzKCkpIHtcbiAgICAgIGlmICghbWF0Y2hHcm91cElkcyB8fCBkZWYuZ3JvdXBJZCAmJiBtYXRjaEdyb3VwSWRzLmluY2x1ZGVzKGRlZi5ncm91cElkKSkge1xuICAgICAgICByZXN1bHQucHVzaChpbmRleCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgdmFsdWVJZHhMb29rdXAoc2NvcGVzLCBwcm9wKSB7XG4gICAgY29uc3Qgbm9TY29wZXNUb01hdGNoID0gc2NvcGVzID09IG51bGwgfHwgc2NvcGVzLmxlbmd0aCA9PT0gMDtcbiAgICBjb25zdCBwcm9wSWQgPSB0eXBlb2YgcHJvcCA9PT0gXCJzdHJpbmdcIiA/IHByb3AgOiBwcm9wLmlkO1xuICAgIGNvbnN0IGhhc01hdGNoaW5nU2NvcGVJZCA9IChkZWYpID0+IHtcbiAgICAgIGlmIChkZWYuaWRzTWFwKSB7XG4gICAgICAgIGZvciAoY29uc3QgW3Njb3BlLCBpZHNdIG9mIGRlZi5pZHNNYXApIHtcbiAgICAgICAgICBpZiAoc2NvcGVzPy5pbmNsdWRlcyhzY29wZSkgJiYgaWRzLmhhcyhwcm9wSWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMudmFsdWVzLmZpbmRJbmRleCgoZGVmKSA9PiB7XG4gICAgICBjb25zdCB2YWxpZERlZlNjb3BlcyA9IGRlZi5zY29wZXMgPT0gbnVsbCB8fCBub1Njb3Blc1RvTWF0Y2ggJiYgIWRlZi5zY29wZXMubGVuZ3RoIHx8IGRlZi5zY29wZXMuc29tZSgocykgPT4gc2NvcGVzPy5pbmNsdWRlcyhzKSk7XG4gICAgICByZXR1cm4gdmFsaWREZWZTY29wZXMgJiYgKGRlZi5wcm9wZXJ0eSA9PT0gcHJvcElkIHx8IGRlZi5pZCA9PT0gcHJvcElkIHx8IGhhc01hdGNoaW5nU2NvcGVJZChkZWYpKTtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0ID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQUcgQ2hhcnRzIC0gY29uZmlndXJhdGlvbiBlcnJvciwgdW5rbm93biBwcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KHByb3ApfSBpbiBzY29wZShzKSAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgIHNjb3Blc1xuICAgICAgICApfWBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZXh0cmFjdERhdGEoZGF0YSwgc291cmNlcykge1xuICAgIGNvbnN0IHsgZGF0YURvbWFpbiwgcHJvY2Vzc1ZhbHVlLCBzY29wZXMsIGFsbFNjb3Blc0hhdmVTYW1lRGVmcyB9ID0gdGhpcy5pbml0RGF0YURvbWFpblByb2Nlc3NvcigpO1xuICAgIGNvbnN0IHNvdXJjZXNCeUlkID0gbmV3IE1hcChzb3VyY2VzPy5tYXAoKHMpID0+IFtzLmlkLCBzXSkpO1xuICAgIGNvbnN0IHsga2V5czoga2V5RGVmcywgdmFsdWVzOiB2YWx1ZURlZnMgfSA9IHRoaXM7XG4gICAgY29uc3QgcmVzdWx0RGF0YSA9IG5ldyBBcnJheShkYXRhLmxlbmd0aCk7XG4gICAgbGV0IHJlc3VsdERhdGFJZHggPSAwO1xuICAgIGxldCBwYXJ0aWFsVmFsaWREYXRhQ291bnQgPSAwO1xuICAgIGZvciAoY29uc3QgW2RhdHVtSWR4LCBkYXR1bV0gb2YgZGF0YS5lbnRyaWVzKCkpIHtcbiAgICAgIGNvbnN0IHNvdXJjZURhdHVtcyA9IHt9O1xuICAgICAgY29uc3QgdmFsaWRTY29wZXMgPSBzY29wZXMuc2l6ZSA+IDAgPyBuZXcgU2V0KHNjb3BlcykgOiB2b2lkIDA7XG4gICAgICBjb25zdCBrZXlzID0gbmV3IEFycmF5KGtleURlZnMubGVuZ3RoKTtcbiAgICAgIGxldCBrZXlJZHggPSAwO1xuICAgICAgbGV0IGtleTtcbiAgICAgIGZvciAoY29uc3QgZGVmIG9mIGtleURlZnMpIHtcbiAgICAgICAga2V5ID0gcHJvY2Vzc1ZhbHVlKGRlZiwgZGF0dW0sIGtleSk7XG4gICAgICAgIGlmIChrZXkgPT09IElOVkFMSURfVkFMVUUpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChrZXlzKSB7XG4gICAgICAgICAga2V5c1trZXlJZHgrK10gPSBrZXk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChrZXkgPT09IElOVkFMSURfVkFMVUUpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3QgdmFsdWVzID0gdmFsdWVEZWZzLmxlbmd0aCA+IDAgPyBuZXcgQXJyYXkodmFsdWVEZWZzLmxlbmd0aCkgOiB2b2lkIDA7XG4gICAgICBsZXQgdmFsdWU7XG4gICAgICBmb3IgKGNvbnN0IFt2YWx1ZURlZklkeCwgZGVmXSBvZiB2YWx1ZURlZnMuZW50cmllcygpKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc2NvcGUgb2YgZGVmLnNjb3BlcyA/PyBzY29wZXMpIHtcbiAgICAgICAgICBjb25zdCBzb3VyY2UgPSBzb3VyY2VzQnlJZC5nZXQoc2NvcGUpO1xuICAgICAgICAgIGNvbnN0IHZhbHVlRGF0dW0gPSBzb3VyY2U/LmRhdGFbZGF0dW1JZHhdID8/IGRhdHVtO1xuICAgICAgICAgIHZhbHVlID0gcHJvY2Vzc1ZhbHVlKGRlZiwgdmFsdWVEYXR1bSwgdmFsdWUsIHNjb3BlKTtcbiAgICAgICAgICBpZiAodmFsdWUgPT09IElOVkFMSURfVkFMVUUgfHwgIXZhbHVlcylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGlmIChzb3VyY2UgIT0gbnVsbCAmJiBkZWYuaW5jbHVkZVByb3BlcnR5ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgY29uc3QgcHJvcGVydHkgPSBkZWYuaW5jbHVkZVByb3BlcnR5ICYmIGRlZi5pZCAhPSBudWxsID8gZGVmLmlkIDogZGVmLnByb3BlcnR5O1xuICAgICAgICAgICAgc291cmNlRGF0dW1zW3Njb3BlXSA/PyAoc291cmNlRGF0dW1zW3Njb3BlXSA9IHt9KTtcbiAgICAgICAgICAgIHNvdXJjZURhdHVtc1tzY29wZV1bcHJvcGVydHldID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhbHVlc1t2YWx1ZURlZklkeF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPT09IElOVkFMSURfVkFMVUUpIHtcbiAgICAgICAgICBpZiAoYWxsU2NvcGVzSGF2ZVNhbWVEZWZzKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZm9yIChjb25zdCBzY29wZSBvZiBkZWYuc2NvcGVzID8/IHNjb3Blcykge1xuICAgICAgICAgICAgdmFsaWRTY29wZXM/LmRlbGV0ZShzY29wZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWxpZFNjb3Blcz8uc2l6ZSA9PT0gMClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPT09IElOVkFMSURfVkFMVUUgJiYgYWxsU2NvcGVzSGF2ZVNhbWVEZWZzKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGlmICh2YWxpZFNjb3Blcz8uc2l6ZSA9PT0gMClcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCByZXN1bHQgPSB7IGRhdHVtOiB7IC4uLmRhdHVtLCAuLi5zb3VyY2VEYXR1bXMgfSwga2V5cywgdmFsdWVzIH07XG4gICAgICBpZiAoIWFsbFNjb3Blc0hhdmVTYW1lRGVmcyAmJiB2YWxpZFNjb3BlcyAmJiB2YWxpZFNjb3Blcy5zaXplIDwgc2NvcGVzLnNpemUpIHtcbiAgICAgICAgcGFydGlhbFZhbGlkRGF0YUNvdW50Kys7XG4gICAgICAgIHJlc3VsdC52YWxpZFNjb3BlcyA9IG5ldyBTZXQodmFsaWRTY29wZXMpO1xuICAgICAgfVxuICAgICAgcmVzdWx0RGF0YVtyZXN1bHREYXRhSWR4KytdID0gcmVzdWx0O1xuICAgIH1cbiAgICByZXN1bHREYXRhLmxlbmd0aCA9IHJlc3VsdERhdGFJZHg7XG4gICAgY29uc3QgcHJvcGVydHlEb21haW4gPSAoZGVmKSA9PiB7XG4gICAgICBjb25zdCBkZWZEb21haW4gPSBkYXRhRG9tYWluLmdldChkZWYpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gZGVmRG9tYWluLmdldERvbWFpbigpO1xuICAgICAgaWYgKENvbnRpbnVvdXNEb21haW4uaXMoZGVmRG9tYWluKSAmJiByZXN1bHRbMF0gPiByZXN1bHRbMV0pIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInVuZ3JvdXBlZFwiLFxuICAgICAgaW5wdXQ6IHsgY291bnQ6IGRhdGEubGVuZ3RoIH0sXG4gICAgICBkYXRhOiByZXN1bHREYXRhLFxuICAgICAgZG9tYWluOiB7XG4gICAgICAgIGtleXM6IGtleURlZnMubWFwKHByb3BlcnR5RG9tYWluKSxcbiAgICAgICAgdmFsdWVzOiB2YWx1ZURlZnMubWFwKHByb3BlcnR5RG9tYWluKVxuICAgICAgfSxcbiAgICAgIGRlZnM6IHtcbiAgICAgICAgYWxsU2NvcGVzSGF2ZVNhbWVEZWZzLFxuICAgICAgICBrZXlzOiBrZXlEZWZzLFxuICAgICAgICB2YWx1ZXM6IHZhbHVlRGVmc1xuICAgICAgfSxcbiAgICAgIHBhcnRpYWxWYWxpZERhdGFDb3VudCxcbiAgICAgIHRpbWU6IDBcbiAgICB9O1xuICB9XG4gIGdyb3VwRGF0YShkYXRhLCBncm91cGluZ0ZuKSB7XG4gICAgY29uc3QgcHJvY2Vzc2VkRGF0YSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBkYXRhRW50cnkgb2YgZGF0YS5kYXRhKSB7XG4gICAgICBjb25zdCB7IGtleXMsIHZhbHVlcywgZGF0dW0sIHZhbGlkU2NvcGVzIH0gPSBkYXRhRW50cnk7XG4gICAgICBjb25zdCBncm91cCA9IGdyb3VwaW5nRm4/LihkYXRhRW50cnkpID8/IGtleXM7XG4gICAgICBjb25zdCBncm91cFN0ciA9IHRvS2V5U3RyaW5nKGdyb3VwKTtcbiAgICAgIGlmIChwcm9jZXNzZWREYXRhLmhhcyhncm91cFN0cikpIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdEYXRhID0gcHJvY2Vzc2VkRGF0YS5nZXQoZ3JvdXBTdHIpO1xuICAgICAgICBleGlzdGluZ0RhdGEudmFsdWVzLnB1c2godmFsdWVzKTtcbiAgICAgICAgZXhpc3RpbmdEYXRhLmRhdHVtLnB1c2goZGF0dW0pO1xuICAgICAgICBpZiAodmFsaWRTY29wZXMgIT0gbnVsbCAmJiBleGlzdGluZ0RhdGEudmFsaWRTY29wZXMgIT0gbnVsbCkge1xuICAgICAgICAgIGZvciAoY29uc3Qgc2NvcGUgb2YgZXhpc3RpbmdEYXRhLnZhbGlkU2NvcGVzKSB7XG4gICAgICAgICAgICBpZiAoIXZhbGlkU2NvcGVzLmhhcyhzY29wZSkpIHtcbiAgICAgICAgICAgICAgZXhpc3RpbmdEYXRhLnZhbGlkU2NvcGVzLmRlbGV0ZShzY29wZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzZWREYXRhLnNldChncm91cFN0ciwge1xuICAgICAgICAgIGtleXM6IGdyb3VwLFxuICAgICAgICAgIHZhbHVlczogW3ZhbHVlc10sXG4gICAgICAgICAgZGF0dW06IFtkYXR1bV0sXG4gICAgICAgICAgdmFsaWRTY29wZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdERhdGEgPSBuZXcgQXJyYXkocHJvY2Vzc2VkRGF0YS5zaXplKTtcbiAgICBjb25zdCByZXN1bHRHcm91cHMgPSBuZXcgQXJyYXkocHJvY2Vzc2VkRGF0YS5zaXplKTtcbiAgICBsZXQgZGF0YUluZGV4ID0gMDtcbiAgICBmb3IgKGNvbnN0IHsga2V5cywgdmFsdWVzLCBkYXR1bSwgdmFsaWRTY29wZXMgfSBvZiBwcm9jZXNzZWREYXRhLnZhbHVlcygpKSB7XG4gICAgICBpZiAodmFsaWRTY29wZXM/LnNpemUgPT09IDApXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgcmVzdWx0R3JvdXBzW2RhdGFJbmRleF0gPSBrZXlzO1xuICAgICAgcmVzdWx0RGF0YVtkYXRhSW5kZXgrK10gPSB7XG4gICAgICAgIGtleXMsXG4gICAgICAgIHZhbHVlcyxcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIHZhbGlkU2NvcGVzXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgLi4uZGF0YSxcbiAgICAgIHR5cGU6IFwiZ3JvdXBlZFwiLFxuICAgICAgZGF0YTogcmVzdWx0RGF0YSxcbiAgICAgIGRvbWFpbjoge1xuICAgICAgICAuLi5kYXRhLmRvbWFpbixcbiAgICAgICAgZ3JvdXBzOiByZXN1bHRHcm91cHNcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGFnZ3JlZ2F0ZURhdGEocHJvY2Vzc2VkRGF0YSkge1xuICAgIGNvbnN0IGlzVW5ncm91cGVkID0gcHJvY2Vzc2VkRGF0YS50eXBlID09PSBcInVuZ3JvdXBlZFwiO1xuICAgIHByb2Nlc3NlZERhdGEuZG9tYWluLmFnZ1ZhbHVlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgW2luZGV4LCBkZWZdIG9mIHRoaXMuYWdncmVnYXRlcy5lbnRyaWVzKCkpIHtcbiAgICAgIGNvbnN0IGluZGljZXMgPSB0aGlzLnZhbHVlR3JvdXBJZHhMb29rdXAoZGVmKTtcbiAgICAgIGNvbnN0IGRvbWFpbiA9IFtJbmZpbml0eSwgLUluZmluaXR5XTtcbiAgICAgIGZvciAoY29uc3QgZGF0dW0gb2YgcHJvY2Vzc2VkRGF0YS5kYXRhKSB7XG4gICAgICAgIGRhdHVtLmFnZ1ZhbHVlcyA/PyAoZGF0dW0uYWdnVmFsdWVzID0gbmV3IEFycmF5KHRoaXMuYWdncmVnYXRlcy5sZW5ndGgpKTtcbiAgICAgICAgaWYgKGRhdHVtLnZhbGlkU2NvcGVzKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBpc1VuZ3JvdXBlZCA/IFtkYXR1bS52YWx1ZXNdIDogZGF0dW0udmFsdWVzO1xuICAgICAgICBsZXQgZ3JvdXBBZ2dWYWx1ZXMgPSBkZWYuZ3JvdXBBZ2dyZWdhdGVGdW5jdGlvbj8uKCkgPz8gW0luZmluaXR5LCAtSW5maW5pdHldO1xuICAgICAgICBmb3IgKGNvbnN0IGRpc3RpbmN0VmFsdWVzIG9mIHZhbHVlcykge1xuICAgICAgICAgIGNvbnN0IHZhbHVlc1RvQWdnID0gaW5kaWNlcy5tYXAoKHZhbHVlSWR4KSA9PiBkaXN0aW5jdFZhbHVlc1t2YWx1ZUlkeF0pO1xuICAgICAgICAgIGNvbnN0IHZhbHVlc0FnZyA9IGRlZi5hZ2dyZWdhdGVGdW5jdGlvbih2YWx1ZXNUb0FnZywgZGF0dW0ua2V5cyk7XG4gICAgICAgICAgaWYgKHZhbHVlc0FnZykge1xuICAgICAgICAgICAgZ3JvdXBBZ2dWYWx1ZXMgPSBkZWYuZ3JvdXBBZ2dyZWdhdGVGdW5jdGlvbj8uKHZhbHVlc0FnZywgZ3JvdXBBZ2dWYWx1ZXMpID8/IENvbnRpbnVvdXNEb21haW4uZXh0ZW5kRG9tYWluKHZhbHVlc0FnZywgZ3JvdXBBZ2dWYWx1ZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaW5hbFZhbHVlcyA9IChkZWYuZmluYWxGdW5jdGlvbj8uKGdyb3VwQWdnVmFsdWVzKSA/PyBncm91cEFnZ1ZhbHVlcykubWFwKCh2KSA9PiByb3VuZDIodikpO1xuICAgICAgICBkYXR1bS5hZ2dWYWx1ZXNbaW5kZXhdID0gZmluYWxWYWx1ZXM7XG4gICAgICAgIENvbnRpbnVvdXNEb21haW4uZXh0ZW5kRG9tYWluKGZpbmFsVmFsdWVzLCBkb21haW4pO1xuICAgICAgfVxuICAgICAgcHJvY2Vzc2VkRGF0YS5kb21haW4uYWdnVmFsdWVzLnB1c2goZG9tYWluKTtcbiAgICB9XG4gIH1cbiAgcG9zdFByb2Nlc3NHcm91cHMocHJvY2Vzc2VkRGF0YSkge1xuICAgIGNvbnN0IHsgZ3JvdXBQcm9jZXNzb3JzIH0gPSB0aGlzO1xuICAgIGNvbnN0IGFmZmVjdGVkSW5kaWNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3QgdXBkYXRlZERvbWFpbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGdyb3VwUHJvY2Vzc29ySW5kaWNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgY29uc3QgZ3JvdXBQcm9jZXNzb3JJbml0Rm5zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IHByb2Nlc3NvciBvZiBncm91cFByb2Nlc3NvcnMpIHtcbiAgICAgIGNvbnN0IGluZGljZXMgPSB0aGlzLnZhbHVlR3JvdXBJZHhMb29rdXAocHJvY2Vzc29yKTtcbiAgICAgIGdyb3VwUHJvY2Vzc29ySW5kaWNlcy5zZXQocHJvY2Vzc29yLCBpbmRpY2VzKTtcbiAgICAgIGdyb3VwUHJvY2Vzc29ySW5pdEZucy5zZXQocHJvY2Vzc29yLCBwcm9jZXNzb3IuYWRqdXN0KCkpO1xuICAgICAgZm9yIChjb25zdCBpZHggb2YgaW5kaWNlcykge1xuICAgICAgICBjb25zdCB2YWx1ZURlZiA9IHRoaXMudmFsdWVzW2lkeF07XG4gICAgICAgIGNvbnN0IGlzRGlzY3JldGUgPSB2YWx1ZURlZi52YWx1ZVR5cGUgPT09IFwiY2F0ZWdvcnlcIjtcbiAgICAgICAgYWZmZWN0ZWRJbmRpY2VzLmFkZChpZHgpO1xuICAgICAgICB1cGRhdGVkRG9tYWlucy5zZXQoaWR4LCBpc0Rpc2NyZXRlID8gbmV3IERpc2NyZXRlRG9tYWluKCkgOiBuZXcgQ29udGludW91c0RvbWFpbigpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdXBkYXRlRG9tYWlucyA9ICh2YWx1ZXMpID0+IHtcbiAgICAgIGZvciAoY29uc3QgdmFsdWVJbmRleCBvZiBhZmZlY3RlZEluZGljZXMpIHtcbiAgICAgICAgdXBkYXRlZERvbWFpbnMuZ2V0KHZhbHVlSW5kZXgpPy5leHRlbmQodmFsdWVzW3ZhbHVlSW5kZXhdKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgcHJvY2Vzc2VkRGF0YS5kYXRhKSB7XG4gICAgICBmb3IgKGNvbnN0IHByb2Nlc3NvciBvZiBncm91cFByb2Nlc3NvcnMpIHtcbiAgICAgICAgaWYgKGdyb3VwLnZhbGlkU2NvcGVzKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCB2YWx1ZUluZGV4ZXMgPSBncm91cFByb2Nlc3NvckluZGljZXMuZ2V0KHByb2Nlc3NvcikgPz8gW107XG4gICAgICAgIGNvbnN0IGFkanVzdEZuID0gZ3JvdXBQcm9jZXNzb3JJbml0Rm5zLmdldChwcm9jZXNzb3IpPy4oKTtcbiAgICAgICAgaWYgKCFhZGp1c3RGbilcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKHByb2Nlc3NlZERhdGEudHlwZSA9PT0gXCJncm91cGVkXCIpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHZhbHVlcyBvZiBncm91cC52YWx1ZXMpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgYWRqdXN0Rm4odmFsdWVzLCB2YWx1ZUluZGV4ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChncm91cC52YWx1ZXMpIHtcbiAgICAgICAgICBhZGp1c3RGbihncm91cC52YWx1ZXMsIHZhbHVlSW5kZXhlcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwcm9jZXNzZWREYXRhLnR5cGUgPT09IFwiZ3JvdXBlZFwiKSB7XG4gICAgICAgIGZvciAoY29uc3QgdmFsdWVzIG9mIGdyb3VwLnZhbHVlcykge1xuICAgICAgICAgIHVwZGF0ZURvbWFpbnModmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXBkYXRlRG9tYWlucyhncm91cC52YWx1ZXMpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtpZHgsIGRhdGFEb21haW5dIG9mIHVwZGF0ZWREb21haW5zKSB7XG4gICAgICBwcm9jZXNzZWREYXRhLmRvbWFpbi52YWx1ZXNbaWR4XSA9IGRhdGFEb21haW4uZ2V0RG9tYWluKCk7XG4gICAgfVxuICB9XG4gIHBvc3RQcm9jZXNzUHJvcGVydGllcyhwcm9jZXNzZWREYXRhKSB7XG4gICAgZm9yIChjb25zdCB7IGFkanVzdCwgcHJvcGVydHksIHNjb3BlcyB9IG9mIHRoaXMucHJvcGVydHlQcm9jZXNzb3JzKSB7XG4gICAgICBhZGp1c3QoKShwcm9jZXNzZWREYXRhLCB0aGlzLnZhbHVlSWR4TG9va3VwKHNjb3BlcywgcHJvcGVydHkpKTtcbiAgICB9XG4gIH1cbiAgcmVkdWNlRGF0YShwcm9jZXNzZWREYXRhKSB7XG4gICAgcHJvY2Vzc2VkRGF0YS5yZWR1Y2VkID8/IChwcm9jZXNzZWREYXRhLnJlZHVjZWQgPSB7fSk7XG4gICAgZm9yIChjb25zdCBkZWYgb2YgdGhpcy5yZWR1Y2Vycykge1xuICAgICAgY29uc3QgcmVkdWNlciA9IGRlZi5yZWR1Y2VyKCk7XG4gICAgICBsZXQgYWNjVmFsdWUgPSBkZWYuaW5pdGlhbFZhbHVlO1xuICAgICAgZm9yIChjb25zdCBkYXR1bSBvZiBwcm9jZXNzZWREYXRhLmRhdGEpIHtcbiAgICAgICAgaWYgKCFkYXR1bS52YWxpZFNjb3BlcyB8fCBkZWYuc2NvcGVzPy5zb21lKChzKSA9PiBkYXR1bS52YWxpZFNjb3Blcz8uaGFzKHMpKSkge1xuICAgICAgICAgIGFjY1ZhbHVlID0gcmVkdWNlcihhY2NWYWx1ZSwgZGF0dW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwcm9jZXNzZWREYXRhLnJlZHVjZWRbZGVmLnByb3BlcnR5XSA9IGFjY1ZhbHVlO1xuICAgIH1cbiAgfVxuICBwb3N0UHJvY2Vzc0RhdGEocHJvY2Vzc2VkRGF0YSkge1xuICAgIHByb2Nlc3NlZERhdGEucmVkdWNlZCA/PyAocHJvY2Vzc2VkRGF0YS5yZWR1Y2VkID0ge30pO1xuICAgIGZvciAoY29uc3QgZGVmIG9mIHRoaXMucHJvY2Vzc29ycykge1xuICAgICAgcHJvY2Vzc2VkRGF0YS5yZWR1Y2VkW2RlZi5wcm9wZXJ0eV0gPSBkZWYuY2FsY3VsYXRlKHByb2Nlc3NlZERhdGEpO1xuICAgIH1cbiAgfVxuICBpbml0RGF0YURvbWFpblByb2Nlc3NvcigpIHtcbiAgICBjb25zdCB7IGtleXM6IGtleURlZnMsIHZhbHVlczogdmFsdWVEZWZzIH0gPSB0aGlzO1xuICAgIGNvbnN0IHNjb3BlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCB2YWx1ZURlZiBvZiB2YWx1ZURlZnMpIHtcbiAgICAgIGlmICghdmFsdWVEZWYuc2NvcGVzKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGZvciAoY29uc3Qgc2NvcGUgb2YgdmFsdWVEZWYuc2NvcGVzKSB7XG4gICAgICAgIHNjb3Blcy5hZGQoc2NvcGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBkYXRhRG9tYWluID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBjb25zdCBwcm9jZXNzb3JGbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGxldCBhbGxTY29wZXNIYXZlU2FtZURlZnMgPSB0cnVlO1xuICAgIGNvbnN0IGluaXREYXRhRG9tYWluID0gKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBkZWYgb2YgaXRlcmF0ZShrZXlEZWZzLCB2YWx1ZURlZnMpKSB7XG4gICAgICAgIGlmIChkZWYudmFsdWVUeXBlID09PSBcImNhdGVnb3J5XCIpIHtcbiAgICAgICAgICBkYXRhRG9tYWluLnNldChkZWYsIG5ldyBEaXNjcmV0ZURvbWFpbigpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYXRhRG9tYWluLnNldChkZWYsIG5ldyBDb250aW51b3VzRG9tYWluKCkpO1xuICAgICAgICAgIGFsbFNjb3Blc0hhdmVTYW1lRGVmcyAmJiAoYWxsU2NvcGVzSGF2ZVNhbWVEZWZzID0gKGRlZi5zY29wZXMgPz8gW10pLmxlbmd0aCA9PT0gc2NvcGVzLnNpemUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBpbml0RGF0YURvbWFpbigpO1xuICAgIGNvbnN0IGFjY2Vzc29ycyA9IHRoaXMuYnVpbGRBY2Nlc3NvcnMoaXRlcmF0ZShrZXlEZWZzLCB2YWx1ZURlZnMpKTtcbiAgICBjb25zdCBwcm9jZXNzVmFsdWUgPSAoZGVmLCBkYXR1bSwgcHJldmlvdXNEYXR1bSwgc2NvcGUpID0+IHtcbiAgICAgIGxldCB2YWx1ZUluRGF0dW07XG4gICAgICBsZXQgdmFsdWU7XG4gICAgICBpZiAoYWNjZXNzb3JzLmhhcyhkZWYucHJvcGVydHkpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFsdWUgPSBhY2Nlc3NvcnMuZ2V0KGRlZi5wcm9wZXJ0eSkoZGF0dW0pO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlSW5EYXR1bSA9IHZhbHVlICE9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZUluRGF0dW0gPSBkZWYucHJvcGVydHkgaW4gZGF0dW07XG4gICAgICAgIHZhbHVlID0gdmFsdWVJbkRhdHVtID8gZGF0dW1bZGVmLnByb3BlcnR5XSA6IGRlZi5taXNzaW5nVmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoZGVmLmZvcmNlVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCB2YWx1ZU5lZ2F0aXZlID0gdmFsdWVJbkRhdHVtICYmIGlzTmVnYXRpdmUodmFsdWUpO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlTmVnYXRpdmUgPyAtMSAqIGRlZi5mb3JjZVZhbHVlIDogZGVmLmZvcmNlVmFsdWU7XG4gICAgICAgIHZhbHVlSW5EYXR1bSA9IHRydWU7XG4gICAgICB9XG4gICAgICBjb25zdCBtaXNzaW5nVmFsdWVEZWYgPSBcIm1pc3NpbmdWYWx1ZVwiIGluIGRlZjtcbiAgICAgIGlmICghdmFsdWVJbkRhdHVtICYmICFtaXNzaW5nVmFsdWVEZWYpIHtcbiAgICAgICAgY29uc3QgbWlzc0NvdW50ID0gZGVmLm1pc3NpbmcuZ2V0KHNjb3BlKSA/PyAwO1xuICAgICAgICBkZWYubWlzc2luZy5zZXQoc2NvcGUsIG1pc3NDb3VudCArIDEpO1xuICAgICAgfVxuICAgICAgaWYgKCFkYXRhRG9tYWluLmhhcyhkZWYpKSB7XG4gICAgICAgIGluaXREYXRhRG9tYWluKCk7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWVJbkRhdHVtICYmIGRlZi52YWxpZGF0aW9uPy4odmFsdWUsIGRhdHVtKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKFwiaW52YWxpZFZhbHVlXCIgaW4gZGVmKSB7XG4gICAgICAgICAgdmFsdWUgPSBkZWYuaW52YWxpZFZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLm1vZGUgIT09IFwiaW50ZWdyYXRlZFwiKSB7XG4gICAgICAgICAgICBMb2dnZXIud2Fybk9uY2UoXG4gICAgICAgICAgICAgIGBpbnZhbGlkIHZhbHVlIG9mIHR5cGUgWyR7dHlwZW9mIHZhbHVlfV0gZm9yIFske2RlZi5zY29wZXN9IC8gJHtkZWYuaWR9XSBpZ25vcmVkOmAsXG4gICAgICAgICAgICAgIGBbJHt2YWx1ZX1dYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIElOVkFMSURfVkFMVUU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkZWYucHJvY2Vzc29yKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc29yRm5zLmhhcyhkZWYpKSB7XG4gICAgICAgICAgcHJvY2Vzc29yRm5zLnNldChkZWYsIGRlZi5wcm9jZXNzb3IoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSBwcm9jZXNzb3JGbnMuZ2V0KGRlZik/Lih2YWx1ZSwgcHJldmlvdXNEYXR1bSA9PT0gSU5WQUxJRF9WQUxVRSA/IHZvaWQgMCA6IHByZXZpb3VzRGF0dW0pO1xuICAgICAgfVxuICAgICAgZGF0YURvbWFpbi5nZXQoZGVmKT8uZXh0ZW5kKHZhbHVlKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIHJldHVybiB7IGRhdGFEb21haW4sIHByb2Nlc3NWYWx1ZSwgaW5pdERhdGFEb21haW4sIHNjb3BlcywgYWxsU2NvcGVzSGF2ZVNhbWVEZWZzIH07XG4gIH1cbiAgYnVpbGRBY2Nlc3NvcnMoZGVmcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgaWYgKHRoaXMubW9kZSA9PT0gXCJpbnRlZ3JhdGVkXCIpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZGVmIG9mIGRlZnMpIHtcbiAgICAgIGNvbnN0IGlzUGF0aCA9IGRlZi5wcm9wZXJ0eS5pbmNsdWRlcyhcIi5cIikgfHwgZGVmLnByb3BlcnR5LmluY2x1ZGVzKFwiW1wiKTtcbiAgICAgIGlmICghaXNQYXRoKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSBnZXRQYXRoQ29tcG9uZW50cyhkZWYucHJvcGVydHkpO1xuICAgICAgaWYgKGNvbXBvbmVudHMgPT0gbnVsbCkge1xuICAgICAgICBMb2dnZXIud2Fybk9uY2UoXCJJbnZhbGlkIHByb3BlcnR5IHBhdGggWyVzXVwiLCBkZWYucHJvcGVydHkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFjY2Vzc29yID0gY3JlYXRlUGF0aEFjY2Vzc29yKGNvbXBvbmVudHMpO1xuICAgICAgcmVzdWx0LnNldChkZWYucHJvcGVydHksIGFjY2Vzc29yKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcbmZ1bmN0aW9uIGxvZ1Byb2Nlc3NlZERhdGEocHJvY2Vzc2VkRGF0YSkge1xuICBjb25zdCBsb2dWYWx1ZXMgPSAobmFtZSwgZGF0YSkgPT4ge1xuICAgIGlmIChkYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgIExvZ2dlci5sb2coYERhdGFNb2RlbC5wcm9jZXNzRGF0YSgpIC0gJHtuYW1lfWApO1xuICAgICAgTG9nZ2VyLnRhYmxlKGRhdGEpO1xuICAgIH1cbiAgfTtcbiAgTG9nZ2VyLmxvZyhcIkRhdGFNb2RlbC5wcm9jZXNzRGF0YSgpIC0gcHJvY2Vzc2VkRGF0YVwiLCBwcm9jZXNzZWREYXRhKTtcbiAgbG9nVmFsdWVzKFwiS2V5IERvbWFpbnNcIiwgcHJvY2Vzc2VkRGF0YS5kb21haW4ua2V5cyk7XG4gIGxvZ1ZhbHVlcyhcIkdyb3VwIERvbWFpbnNcIiwgcHJvY2Vzc2VkRGF0YS5kb21haW4uZ3JvdXBzID8/IFtdKTtcbiAgbG9nVmFsdWVzKFwiVmFsdWUgRG9tYWluc1wiLCBwcm9jZXNzZWREYXRhLmRvbWFpbi52YWx1ZXMpO1xuICBsb2dWYWx1ZXMoXCJBZ2dyZWdhdGUgRG9tYWluc1wiLCBwcm9jZXNzZWREYXRhLmRvbWFpbi5hZ2dWYWx1ZXMgPz8gW10pO1xuICBpZiAocHJvY2Vzc2VkRGF0YS50eXBlID09PSBcImdyb3VwZWRcIikge1xuICAgIGNvbnN0IGZsYXR0ZW5lZFZhbHVlcyA9IHByb2Nlc3NlZERhdGEuZGF0YS5yZWR1Y2UoKGFjYywgbmV4dCkgPT4ge1xuICAgICAgY29uc3Qga2V5cyA9IG5leHQua2V5cyA/PyBbXTtcbiAgICAgIGNvbnN0IGFnZ1ZhbHVlcyA9IG5leHQuYWdnVmFsdWVzID8/IFtdO1xuICAgICAgY29uc3Qgc2tpcEtleXMgPSBuZXh0LmtleXMubWFwKCgpID0+IHZvaWQgMCk7XG4gICAgICBjb25zdCBza2lwQWdnVmFsdWVzID0gYWdnVmFsdWVzPy5tYXAoKCkgPT4gdm9pZCAwKTtcbiAgICAgIGFjYy5wdXNoKFxuICAgICAgICAuLi5uZXh0LnZhbHVlcy5tYXAoKHYsIGkpID0+IFtcbiAgICAgICAgICAuLi5pID09PSAwID8ga2V5cyA6IHNraXBLZXlzLFxuICAgICAgICAgIC4uLnYgPz8gW10sXG4gICAgICAgICAgLi4uaSA9PSAwID8gYWdnVmFsdWVzIDogc2tpcEFnZ1ZhbHVlc1xuICAgICAgICBdKVxuICAgICAgKTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgW10pO1xuICAgIGxvZ1ZhbHVlcyhcIlZhbHVlc1wiLCBmbGF0dGVuZWRWYWx1ZXMpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGZsYXR0ZW5lZFZhbHVlcyA9IHByb2Nlc3NlZERhdGEuZGF0YS5yZWR1Y2UoKGFjYywgbmV4dCkgPT4ge1xuICAgICAgY29uc3QgYWdnVmFsdWVzID0gbmV4dC5hZ2dWYWx1ZXMgPz8gW107XG4gICAgICBhY2MucHVzaChbLi4ubmV4dC5rZXlzLCAuLi5uZXh0LnZhbHVlcywgLi4uYWdnVmFsdWVzXSk7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFtdKTtcbiAgICBsb2dWYWx1ZXMoXCJWYWx1ZXNcIiwgZmxhdHRlbmVkVmFsdWVzKTtcbiAgfVxufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9kYXRhL2RhdGFDb250cm9sbGVyLnRzXG52YXIgX0RhdGFDb250cm9sbGVyID0gY2xhc3MgX0RhdGFDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IobW9kZSkge1xuICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgdGhpcy5kZWJ1ZyA9IERlYnVnLmNyZWF0ZSh0cnVlLCBcImRhdGEtbW9kZWxcIik7XG4gICAgdGhpcy5yZXF1ZXN0ZWQgPSBbXTtcbiAgICB0aGlzLnN0YXR1cyA9IFwic2V0dXBcIjtcbiAgfVxuICBhc3luYyByZXF1ZXN0KGlkLCBkYXRhLCBvcHRzKSB7XG4gICAgaWYgKHRoaXMuc3RhdHVzICE9PSBcInNldHVwXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQUcgQ2hhcnRzIC0gZGF0YSByZXF1ZXN0IGFmdGVyIGRhdGEgc2V0dXAgcGhhc2UuYCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnJlcXVlc3RlZC5wdXNoKHsgaWQsIG9wdHMsIGRhdGEsIHJlc29sdmUsIHJlamVjdCB9KTtcbiAgICB9KTtcbiAgfVxuICBleGVjdXRlKCkge1xuICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gXCJzZXR1cFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFHIENoYXJ0cyAtIGRhdGEgcmVxdWVzdCBhZnRlciBkYXRhIHNldHVwIHBoYXNlLmApO1xuICAgIH1cbiAgICB0aGlzLnN0YXR1cyA9IFwiZXhlY3V0ZWRcIjtcbiAgICB0aGlzLmRlYnVnKFwiRGF0YUNvbnRyb2xsZXIuZXhlY3V0ZSgpIC0gcmVxdWVzdGVkXCIsIHRoaXMucmVxdWVzdGVkKTtcbiAgICBjb25zdCB2YWxpZCA9IHRoaXMudmFsaWRhdGVSZXF1ZXN0cyh0aGlzLnJlcXVlc3RlZCk7XG4gICAgdGhpcy5kZWJ1ZyhcIkRhdGFDb250cm9sbGVyLmV4ZWN1dGUoKSAtIHZhbGlkYXRlZFwiLCB2YWxpZCk7XG4gICAgY29uc3QgbWVyZ2VkID0gdGhpcy5tZXJnZVJlcXVlc3RlZCh2YWxpZCk7XG4gICAgdGhpcy5kZWJ1ZyhcIkRhdGFDb250cm9sbGVyLmV4ZWN1dGUoKSAtIG1lcmdlZFwiLCBtZXJnZWQpO1xuICAgIGlmICh0aGlzLmRlYnVnLmNoZWNrKCkpIHtcbiAgICAgIGdldFdpbmRvdygpLnByb2Nlc3NlZERhdGEgPSBbXTtcbiAgICB9XG4gICAgY29uc3Qgc2NvcGVzID0gdGhpcy5yZXF1ZXN0ZWQubWFwKCh7IGlkIH0pID0+IGlkKTtcbiAgICBjb25zdCBuZWVkc1ZhbHVlRXh0cmFjdGlvbiA9IHRoaXMuaGFzTXVsdGlwbGVEYXRhU291cmNlcyh2YWxpZCk7XG4gICAgZm9yIChjb25zdCB7IG9wdHMsIGRhdGEsIHJlc29sdmVzLCByZWplY3RzLCBpZHMgfSBvZiBtZXJnZWQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRhdGFNb2RlbCA9IG5ldyBEYXRhTW9kZWwob3B0cywgdGhpcy5tb2RlKTtcbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkRGF0YSA9IGRhdGFNb2RlbC5wcm9jZXNzRGF0YShkYXRhLCB2YWxpZCk7XG4gICAgICAgIGlmICh0aGlzLmRlYnVnLmNoZWNrKCkpIHtcbiAgICAgICAgICBnZXRXaW5kb3coXCJwcm9jZXNzZWREYXRhXCIpLnB1c2gocHJvY2Vzc2VkRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2Nlc3NlZERhdGE/LnBhcnRpYWxWYWxpZERhdGFDb3VudCA9PT0gMCkge1xuICAgICAgICAgIHJlc29sdmVzLmZvckVhY2goXG4gICAgICAgICAgICAocmVzb2x2ZSwgcmVxdWVzdElkeCkgPT4gcmVzb2x2ZSh7XG4gICAgICAgICAgICAgIGRhdGFNb2RlbCxcbiAgICAgICAgICAgICAgcHJvY2Vzc2VkRGF0YTogdGhpcy5wcm9jZXNzU2NvcGVkRGF0YShcbiAgICAgICAgICAgICAgICBpZHNbcmVxdWVzdElkeF0sXG4gICAgICAgICAgICAgICAgcHJvY2Vzc2VkRGF0YSxcbiAgICAgICAgICAgICAgICBzY29wZXMsXG4gICAgICAgICAgICAgICAgbmVlZHNWYWx1ZUV4dHJhY3Rpb25cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3NlZERhdGEpIHtcbiAgICAgICAgICB0aGlzLnNwbGl0UmVzdWx0KGRhdGFNb2RlbCwgcHJvY2Vzc2VkRGF0YSwgaWRzLCByZXNvbHZlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0cy5mb3JFYWNoKChjYikgPT4gY2IobmV3IEVycm9yKGBBRyBDaGFydHMgLSBubyBwcm9jZXNzZWQgZGF0YSBnZW5lcmF0ZWRgKSkpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZWplY3RzLmZvckVhY2goKGNiKSA9PiBjYihlcnJvcikpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBoYXNNdWx0aXBsZURhdGFTb3VyY2VzKHZhbGlkUmVxdWVzdHMpIHtcbiAgICBpZiAodmFsaWRSZXF1ZXN0cy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IFt7IGRhdGEgfSwgLi4ucmVzdFJlcXVlc3RzXSA9IHZhbGlkUmVxdWVzdHM7XG4gICAgICByZXR1cm4gcmVzdFJlcXVlc3RzLnNvbWUoKHYpID0+IGRhdGEgIT09IHYuZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBwcm9jZXNzU2NvcGVkRGF0YShpZCwgcHJvY2Vzc2VkRGF0YSwgaWRzLCBuZWVkc1ZhbHVlRXh0cmFjdGlvbikge1xuICAgIGNvbnN0IGV4dHJhY3REYXR1bSA9IChkYXR1bSkgPT4ge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0dW0pKSB7XG4gICAgICAgIHJldHVybiBkYXR1bS5tYXAoZXh0cmFjdERhdHVtKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGV4dHJhY3RlZCA9IG5lZWRzVmFsdWVFeHRyYWN0aW9uID8geyAuLi5kYXR1bSwgLi4uZGF0dW1baWRdIH0gOiBkYXR1bTtcbiAgICAgIGZvciAoY29uc3Qgb3RoZXJJZCBvZiBpZHMpIHtcbiAgICAgICAgZGVsZXRlIGV4dHJhY3RlZFtvdGhlcklkXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBleHRyYWN0ZWQ7XG4gICAgfTtcbiAgICBjb25zdCBleHRyYWN0VmFsdWVzID0gKHZhbHVlcykgPT4ge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICByZXR1cm4gdmFsdWVzLm1hcChleHRyYWN0VmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZXM/LltpZF0gPz8gdmFsdWVzO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnByb2Nlc3NlZERhdGEsXG4gICAgICBkYXRhOiBwcm9jZXNzZWREYXRhLmRhdGEubWFwKChkYXR1bSkgPT4gKHtcbiAgICAgICAgLi4uZGF0dW0sXG4gICAgICAgIGRhdHVtOiBleHRyYWN0RGF0dW0oZGF0dW0uZGF0dW0pLFxuICAgICAgICB2YWx1ZXM6IG5lZWRzVmFsdWVFeHRyYWN0aW9uID8gZGF0dW0udmFsdWVzPy5tYXAoZXh0cmFjdFZhbHVlcykgOiBkYXR1bS52YWx1ZXNcbiAgICAgIH0pKVxuICAgIH07XG4gIH1cbiAgdmFsaWRhdGVSZXF1ZXN0cyhyZXF1ZXN0ZWQpIHtcbiAgICBjb25zdCB2YWxpZCA9IFtdO1xuICAgIGZvciAoY29uc3QgW2luZGV4LCByZXF1ZXN0XSBvZiByZXF1ZXN0ZWQuZW50cmllcygpKSB7XG4gICAgICBpZiAoaW5kZXggPiAwICYmIHJlcXVlc3QuZGF0YS5sZW5ndGggIT09IHJlcXVlc3RlZFswXS5kYXRhLmxlbmd0aCAmJiByZXF1ZXN0Lm9wdHMuZ3JvdXBCeURhdGEgPT09IGZhbHNlKSB7XG4gICAgICAgIHJlcXVlc3QucmVqZWN0KFxuICAgICAgICAgIG5ldyBFcnJvcihcImFsbCBzZXJpZXNbXS5kYXRhIGFycmF5cyBtdXN0IGJlIG9mIHRoZSBzYW1lIGxlbmd0aCBhbmQgaGF2ZSBtYXRjaGluZyBrZXlzLlwiKVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsaWQucHVzaChyZXF1ZXN0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbGlkO1xuICB9XG4gIG1lcmdlUmVxdWVzdGVkKHJlcXVlc3RlZCkge1xuICAgIGNvbnN0IGdyb3VwZWQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHJlcXVlc3Qgb2YgcmVxdWVzdGVkKSB7XG4gICAgICBjb25zdCBtYXRjaCA9IGdyb3VwZWQuZmluZChfRGF0YUNvbnRyb2xsZXIuZ3JvdXBNYXRjaChyZXF1ZXN0KSk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgbWF0Y2gucHVzaChyZXF1ZXN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdyb3VwZWQucHVzaChbcmVxdWVzdF0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ3JvdXBlZC5tYXAoX0RhdGFDb250cm9sbGVyLm1lcmdlUmVxdWVzdHMpO1xuICB9XG4gIHNwbGl0UmVzdWx0KGRhdGFNb2RlbCwgcHJvY2Vzc2VkRGF0YSwgc2NvcGVzLCByZXNvbHZlcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2NvcGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzY29wZSA9IHNjb3Blc1tpXTtcbiAgICAgIGNvbnN0IHJlc29sdmUgPSByZXNvbHZlc1tpXTtcbiAgICAgIHJlc29sdmUoe1xuICAgICAgICBkYXRhTW9kZWwsXG4gICAgICAgIHByb2Nlc3NlZERhdGE6IHtcbiAgICAgICAgICAuLi5wcm9jZXNzZWREYXRhLFxuICAgICAgICAgIGRhdGE6IHByb2Nlc3NlZERhdGEuZGF0YS5maWx0ZXIoKHsgdmFsaWRTY29wZXMgfSkgPT4gdmFsaWRTY29wZXM/LmhhcyhzY29wZSkgPz8gdHJ1ZSlcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBncm91cE1hdGNoKHsgZGF0YSwgb3B0cyB9KSB7XG4gICAgZnVuY3Rpb24ga2V5cyhwcm9wcykge1xuICAgICAgcmV0dXJuIHByb3BzLmZpbHRlcigocCkgPT4gcC50eXBlID09PSBcImtleVwiKS5tYXAoKHApID0+IHAucHJvcGVydHkpLmpvaW4oXCI7XCIpO1xuICAgIH1cbiAgICByZXR1cm4gKFtncm91cF0pID0+IChvcHRzLmdyb3VwQnlEYXRhID09PSBmYWxzZSB8fCBncm91cC5kYXRhID09PSBkYXRhKSAmJiBncm91cC5vcHRzLmdyb3VwQnlLZXlzID09PSBvcHRzLmdyb3VwQnlLZXlzICYmIGdyb3VwLm9wdHMuZ3JvdXBCeUZuID09PSBvcHRzLmdyb3VwQnlGbiAmJiBrZXlzKGdyb3VwLm9wdHMucHJvcHMpID09PSBrZXlzKG9wdHMucHJvcHMpO1xuICB9XG4gIHN0YXRpYyBtZXJnZVJlcXVlc3RzKHJlcXVlc3RzKSB7XG4gICAgcmV0dXJuIHJlcXVlc3RzLnJlZHVjZShcbiAgICAgIChyZXN1bHQsIHsgaWQsIGRhdGEsIHJlc29sdmUsIHJlamVjdCwgb3B0czogeyBwcm9wcywgLi4ub3B0cyB9IH0pID0+IHtcbiAgICAgICAgcmVzdWx0Lmlkcy5wdXNoKGlkKTtcbiAgICAgICAgcmVzdWx0LnJlamVjdHMucHVzaChyZWplY3QpO1xuICAgICAgICByZXN1bHQucmVzb2x2ZXMucHVzaChyZXNvbHZlKTtcbiAgICAgICAgcmVzdWx0LmRhdGEgPz8gKHJlc3VsdC5kYXRhID0gZGF0YSk7XG4gICAgICAgIHJlc3VsdC5vcHRzID8/IChyZXN1bHQub3B0cyA9IHsgLi4ub3B0cywgcHJvcHM6IFtdIH0pO1xuICAgICAgICBmb3IgKGNvbnN0IHByb3Agb2YgcHJvcHMpIHtcbiAgICAgICAgICBjb25zdCBjbG9uZTIgPSB7IC4uLnByb3AsIHNjb3BlczogW2lkXSB9O1xuICAgICAgICAgIF9EYXRhQ29udHJvbGxlci5jcmVhdGVJZHNNYXAoaWQsIGNsb25lMik7XG4gICAgICAgICAgY29uc3QgbWF0Y2ggPSByZXN1bHQub3B0cy5wcm9wcy5maW5kKFxuICAgICAgICAgICAgKGV4aXN0aW5nKSA9PiBleGlzdGluZy50eXBlID09PSBjbG9uZTIudHlwZSAmJiBfRGF0YUNvbnRyb2xsZXIuZGVlcEVxdWFsKGV4aXN0aW5nLCBjbG9uZTIpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICByZXN1bHQub3B0cy5wcm9wcy5wdXNoKGNsb25lMik7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWF0Y2guc2NvcGVzID8/IChtYXRjaC5zY29wZXMgPSBbXSk7XG4gICAgICAgICAgbWF0Y2guc2NvcGVzLnB1c2goLi4uY2xvbmUyLnNjb3BlcyA/PyBbXSk7XG4gICAgICAgICAgaWYgKChtYXRjaC50eXBlID09PSBcImtleVwiIHx8IG1hdGNoLnR5cGUgPT09IFwidmFsdWVcIikgJiYgY2xvbmUyLmlkc01hcD8uc2l6ZSkge1xuICAgICAgICAgICAgX0RhdGFDb250cm9sbGVyLm1lcmdlSWRzTWFwKGNsb25lMi5pZHNNYXAsIG1hdGNoLmlkc01hcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LFxuICAgICAgeyBpZHM6IFtdLCByZWplY3RzOiBbXSwgcmVzb2x2ZXM6IFtdLCBkYXRhOiBudWxsLCBvcHRzOiBudWxsIH1cbiAgICApO1xuICB9XG4gIHN0YXRpYyBtZXJnZUlkc01hcChmcm9tTWFwLCB0b01hcCkge1xuICAgIGZvciAoY29uc3QgW3Njb3BlLCBpZHNdIG9mIGZyb21NYXApIHtcbiAgICAgIGNvbnN0IHRvTWFwVmFsdWUgPSB0b01hcC5nZXQoc2NvcGUpO1xuICAgICAgaWYgKHRvTWFwVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIGlkcykge1xuICAgICAgICAgIHRvTWFwVmFsdWUuYWRkKGlkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9NYXAuc2V0KHNjb3BlLCBuZXcgU2V0KGlkcykpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzdGF0aWMgY3JlYXRlSWRzTWFwKHNjb3BlLCBwcm9wKSB7XG4gICAgaWYgKHByb3AuaWQgPT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICBwcm9wLmlkc01hcCA/PyAocHJvcC5pZHNNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgICBpZiAocHJvcC5pZHNNYXAuaGFzKHNjb3BlKSkge1xuICAgICAgcHJvcC5pZHNNYXAuZ2V0KHNjb3BlKS5hZGQocHJvcC5pZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb3AuaWRzTWFwLnNldChzY29wZSwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW3Byb3AuaWRdKSk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBkZWVwRXF1YWwoYSwgYikge1xuICAgIGlmIChhID09PSBiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGEgJiYgYiAmJiB0eXBlb2YgYSA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBiID09IFwib2JqZWN0XCIpIHtcbiAgICAgIGlmIChhLmNvbnN0cnVjdG9yICE9PSBiLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGxldCBpLCBsZW5ndGgyO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgICAgbGVuZ3RoMiA9IGEubGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoMiAhPT0gYi5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gbGVuZ3RoMiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKCFfRGF0YUNvbnRyb2xsZXIuZGVlcEVxdWFsKGFbaV0sIGJbaV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgICAgbGVuZ3RoMiA9IGtleXMubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aDIgIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSBsZW5ndGgyIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgaWYgKCFfRGF0YUNvbnRyb2xsZXIuc2tpcEtleXMuaGFzKGtleSkgJiYgKCFPYmplY3QuaGFzT3duKGIsIGtleSkgfHwgIV9EYXRhQ29udHJvbGxlci5kZWVwRXF1YWwoYVtrZXldLCBiW2tleV0pKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcbi8vIG9wdGltaXplZCB2ZXJzaW9uIG9mIGRlZXAgZXF1YWxpdHkgZm9yIGBtZXJnZVJlcXVlc3RzYCB3aGljaCBjYW4gcG90ZW50aWFsbHkgbG9vcCBvdmVyIDFNIHRpbWVzXG5fRGF0YUNvbnRyb2xsZXIuc2tpcEtleXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJpZFwiLCBcImlkc01hcFwiLCBcInR5cGVcIiwgXCJzY29wZXNcIl0pO1xudmFyIERhdGFDb250cm9sbGVyID0gX0RhdGFDb250cm9sbGVyO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9mYWN0b3J5L2F4aXNSZWdpc3RyeS50c1xudmFyIEF4aXNSZWdpc3RyeSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5heGVzTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLmhpZGRlbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy50aGVtZVRlbXBsYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgcmVnaXN0ZXIoYXhpc1R5cGUsIG1vZHVsZSkge1xuICAgIHRoaXMuYXhlc01hcC5zZXQoYXhpc1R5cGUsIG1vZHVsZS5tb2R1bGVGYWN0b3J5KTtcbiAgICBpZiAobW9kdWxlLnRoZW1lVGVtcGxhdGUpIHtcbiAgICAgIHRoaXMuc2V0VGhlbWVUZW1wbGF0ZShheGlzVHlwZSwgbW9kdWxlLnRoZW1lVGVtcGxhdGUpO1xuICAgIH1cbiAgICBpZiAobW9kdWxlLmhpZGRlbikge1xuICAgICAgdGhpcy5oaWRkZW4uYWRkKGF4aXNUeXBlKTtcbiAgICB9XG4gIH1cbiAgY3JlYXRlKGF4aXNUeXBlLCBtb2R1bGVDb250ZXh0KSB7XG4gICAgY29uc3QgYXhpc0ZhY3RvcnkgPSB0aGlzLmF4ZXNNYXAuZ2V0KGF4aXNUeXBlKTtcbiAgICBpZiAoYXhpc0ZhY3RvcnkpIHtcbiAgICAgIHJldHVybiBheGlzRmFjdG9yeShtb2R1bGVDb250ZXh0KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBBRyBDaGFydHMgLSB1bmtub3duIGF4aXMgdHlwZTogJHtheGlzVHlwZX1gKTtcbiAgfVxuICBoYXMoYXhpc1R5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5heGVzTWFwLmhhcyhheGlzVHlwZSk7XG4gIH1cbiAga2V5cygpIHtcbiAgICByZXR1cm4gdGhpcy5heGVzTWFwLmtleXMoKTtcbiAgfVxuICBwdWJsaWNLZXlzKCkge1xuICAgIHJldHVybiBbLi4udGhpcy5rZXlzKCldLmZpbHRlcigoaykgPT4gIXRoaXMuaGlkZGVuLmhhcyhrKSk7XG4gIH1cbiAgc2V0VGhlbWVUZW1wbGF0ZShheGlzVHlwZSwgdGhlbWVUZW1wbGF0ZSkge1xuICAgIHRoaXMudGhlbWVUZW1wbGF0ZXMuc2V0KGF4aXNUeXBlLCB0aGVtZVRlbXBsYXRlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBnZXRUaGVtZVRlbXBsYXRlKGF4aXNUeXBlKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbWVUZW1wbGF0ZXMuZ2V0KGF4aXNUeXBlKTtcbiAgfVxufTtcbnZhciBheGlzUmVnaXN0cnkgPSBuZXcgQXhpc1JlZ2lzdHJ5KCk7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2ZhY3RvcnkvZXhwZWN0ZWRFbnRlcnByaXNlTW9kdWxlcy50c1xudmFyIEVYUEVDVEVEX0VOVEVSUFJJU0VfTU9EVUxFUyA9IFtcbiAge1xuICAgIHR5cGU6IFwicm9vdFwiLFxuICAgIG9wdGlvbnNLZXk6IFwiYW5pbWF0aW9uXCIsXG4gICAgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCIsIFwicG9sYXJcIiwgXCJoaWVyYXJjaHlcIiwgXCJ0b3BvbG9neVwiLCBcImZsb3ctcHJvcG9ydGlvblwiLCBcInN0YW5kYWxvbmVcIiwgXCJnYXVnZVwiXVxuICB9LFxuICB7IHR5cGU6IFwicm9vdFwiLCBvcHRpb25zS2V5OiBcImFubm90YXRpb25zXCIsIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiXSB9LFxuICB7XG4gICAgdHlwZTogXCJyb290XCIsXG4gICAgb3B0aW9uc0tleTogXCJiYWNrZ3JvdW5kXCIsXG4gICAgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCIsIFwicG9sYXJcIiwgXCJoaWVyYXJjaHlcIiwgXCJ0b3BvbG9neVwiLCBcImZsb3ctcHJvcG9ydGlvblwiLCBcInN0YW5kYWxvbmVcIiwgXCJnYXVnZVwiXSxcbiAgICBvcHRpb25zSW5uZXJLZXk6IFwiaW1hZ2VcIlxuICB9LFxuICB7XG4gICAgdHlwZTogXCJyb290XCIsXG4gICAgb3B0aW9uc0tleTogXCJmb3JlZ3JvdW5kXCIsXG4gICAgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCIsIFwicG9sYXJcIiwgXCJoaWVyYXJjaHlcIiwgXCJ0b3BvbG9neVwiLCBcImZsb3ctcHJvcG9ydGlvblwiLCBcInN0YW5kYWxvbmVcIiwgXCJnYXVnZVwiXSxcbiAgICBvcHRpb25zSW5uZXJLZXk6IFwiaW1hZ2VcIlxuICB9LFxuICB7XG4gICAgdHlwZTogXCJyb290XCIsXG4gICAgb3B0aW9uc0tleTogXCJjaGFydFRvb2xiYXJcIixcbiAgICBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIl1cbiAgfSxcbiAge1xuICAgIHR5cGU6IFwicm9vdFwiLFxuICAgIG9wdGlvbnNLZXk6IFwiY29udGV4dE1lbnVcIixcbiAgICBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIiwgXCJwb2xhclwiLCBcImhpZXJhcmNoeVwiLCBcInRvcG9sb2d5XCIsIFwiZmxvdy1wcm9wb3J0aW9uXCIsIFwic3RhbmRhbG9uZVwiLCBcImdhdWdlXCJdXG4gIH0sXG4gIHsgdHlwZTogXCJyb290XCIsIG9wdGlvbnNLZXk6IFwic3RhdHVzQmFyXCIsIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiXSwgaWRlbnRpZmllcjogXCJzdGF0dXMtYmFyXCIgfSxcbiAge1xuICAgIHR5cGU6IFwicm9vdFwiLFxuICAgIG9wdGlvbnNLZXk6IFwiZGF0YVNvdXJjZVwiLFxuICAgIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiLCBcInBvbGFyXCIsIFwiaGllcmFyY2h5XCIsIFwidG9wb2xvZ3lcIiwgXCJmbG93LXByb3BvcnRpb25cIiwgXCJzdGFuZGFsb25lXCIsIFwiZ2F1Z2VcIl1cbiAgfSxcbiAgeyB0eXBlOiBcInJvb3RcIiwgb3B0aW9uc0tleTogXCJzeW5jXCIsIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiXSB9LFxuICB7IHR5cGU6IFwicm9vdFwiLCBvcHRpb25zS2V5OiBcInpvb21cIiwgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCIsIFwidG9wb2xvZ3lcIl0gfSxcbiAge1xuICAgIHR5cGU6IFwibGVnZW5kXCIsXG4gICAgb3B0aW9uc0tleTogXCJncmFkaWVudExlZ2VuZFwiLFxuICAgIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiLCBcInBvbGFyXCIsIFwiaGllcmFyY2h5XCIsIFwidG9wb2xvZ3lcIiwgXCJmbG93LXByb3BvcnRpb25cIiwgXCJzdGFuZGFsb25lXCIsIFwiZ2F1Z2VcIl0sXG4gICAgaWRlbnRpZmllcjogXCJncmFkaWVudFwiXG4gIH0sXG4gIHsgdHlwZTogXCJyb290XCIsIG9wdGlvbnNLZXk6IFwibmF2aWdhdG9yXCIsIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiXSwgb3B0aW9uc0lubmVyS2V5OiBcIm1pbmlDaGFydFwiIH0sXG4gIHsgdHlwZTogXCJheGlzXCIsIG9wdGlvbnNLZXk6IFwiYXhlc1tdXCIsIGNoYXJ0VHlwZXM6IFtcInBvbGFyXCJdLCBpZGVudGlmaWVyOiBcImFuZ2xlLWNhdGVnb3J5XCIgfSxcbiAgeyB0eXBlOiBcImF4aXNcIiwgb3B0aW9uc0tleTogXCJheGVzW11cIiwgY2hhcnRUeXBlczogW1wicG9sYXJcIl0sIGlkZW50aWZpZXI6IFwiYW5nbGUtbnVtYmVyXCIgfSxcbiAgeyB0eXBlOiBcImF4aXNcIiwgb3B0aW9uc0tleTogXCJheGVzW11cIiwgY2hhcnRUeXBlczogW1wicG9sYXJcIl0sIGlkZW50aWZpZXI6IFwicmFkaXVzLWNhdGVnb3J5XCIgfSxcbiAgeyB0eXBlOiBcImF4aXNcIiwgb3B0aW9uc0tleTogXCJheGVzW11cIiwgY2hhcnRUeXBlczogW1wicG9sYXJcIl0sIGlkZW50aWZpZXI6IFwicmFkaXVzLW51bWJlclwiIH0sXG4gIHsgdHlwZTogXCJheGlzXCIsIG9wdGlvbnNLZXk6IFwiYXhlc1tdXCIsIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiXSwgaWRlbnRpZmllcjogXCJvcmRpbmFsLXRpbWVcIiB9LFxuICB7IHR5cGU6IFwiYXhpcy1vcHRpb25cIiwgb3B0aW9uc0tleTogXCJjcm9zc2hhaXJcIiwgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCJdIH0sXG4gIHsgdHlwZTogXCJzZXJpZXNcIiwgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIl0sIGlkZW50aWZpZXI6IFwiYm94LXBsb3RcIiB9LFxuICB7IHR5cGU6IFwic2VyaWVzXCIsIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIiwgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCJdLCBpZGVudGlmaWVyOiBcImNhbmRsZXN0aWNrXCIgfSxcbiAgeyB0eXBlOiBcInNlcmllc1wiLCBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiXSwgaWRlbnRpZmllcjogXCJjb25lLWZ1bm5lbFwiIH0sXG4gIHsgdHlwZTogXCJzZXJpZXNcIiwgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIl0sIGlkZW50aWZpZXI6IFwiZnVubmVsXCIgfSxcbiAgeyB0eXBlOiBcInNlcmllc1wiLCBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiXSwgaWRlbnRpZmllcjogXCJvaGxjXCIgfSxcbiAgeyB0eXBlOiBcInNlcmllc1wiLCBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiXSwgaWRlbnRpZmllcjogXCJidWxsZXRcIiB9LFxuICB7IHR5cGU6IFwic2VyaWVzXCIsIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIiwgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCJdLCBpZGVudGlmaWVyOiBcImhlYXRtYXBcIiB9LFxuICB7IHR5cGU6IFwic2VyaWVzXCIsIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIiwgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCJdLCBpZGVudGlmaWVyOiBcInJhbmdlLWFyZWFcIiB9LFxuICB7IHR5cGU6IFwic2VyaWVzXCIsIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIiwgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCJdLCBpZGVudGlmaWVyOiBcInJhbmdlLWJhclwiIH0sXG4gIHsgdHlwZTogXCJzZXJpZXNcIiwgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIl0sIGlkZW50aWZpZXI6IFwid2F0ZXJmYWxsXCIgfSxcbiAgeyB0eXBlOiBcInNlcmllc1wiLCBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsIGNoYXJ0VHlwZXM6IFtcInBvbGFyXCJdLCBpZGVudGlmaWVyOiBcIm5pZ2h0aW5nYWxlXCIgfSxcbiAgeyB0eXBlOiBcInNlcmllc1wiLCBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsIGNoYXJ0VHlwZXM6IFtcInBvbGFyXCJdLCBpZGVudGlmaWVyOiBcInJhZGFyLWFyZWFcIiB9LFxuICB7IHR5cGU6IFwic2VyaWVzXCIsIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIiwgY2hhcnRUeXBlczogW1wicG9sYXJcIl0sIGlkZW50aWZpZXI6IFwicmFkYXItbGluZVwiIH0sXG4gIHsgdHlwZTogXCJzZXJpZXNcIiwgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJwb2xhclwiXSwgaWRlbnRpZmllcjogXCJyYWRpYWwtYmFyXCIgfSxcbiAgeyB0eXBlOiBcInNlcmllc1wiLCBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsIGNoYXJ0VHlwZXM6IFtcInBvbGFyXCJdLCBpZGVudGlmaWVyOiBcInJhZGlhbC1jb2x1bW5cIiB9LFxuICB7IHR5cGU6IFwic2VyaWVzXCIsIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIiwgY2hhcnRUeXBlczogW1wiaGllcmFyY2h5XCJdLCBpZGVudGlmaWVyOiBcInN1bmJ1cnN0XCIgfSxcbiAgeyB0eXBlOiBcInNlcmllc1wiLCBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsIGNoYXJ0VHlwZXM6IFtcImhpZXJhcmNoeVwiXSwgaWRlbnRpZmllcjogXCJ0cmVlbWFwXCIgfSxcbiAgeyB0eXBlOiBcInNlcmllc1wiLCBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsIGNoYXJ0VHlwZXM6IFtcInRvcG9sb2d5XCJdLCBpZGVudGlmaWVyOiBcIm1hcC1zaGFwZVwiIH0sXG4gIHsgdHlwZTogXCJzZXJpZXNcIiwgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJ0b3BvbG9neVwiXSwgaWRlbnRpZmllcjogXCJtYXAtbGluZVwiIH0sXG4gIHsgdHlwZTogXCJzZXJpZXNcIiwgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJ0b3BvbG9neVwiXSwgaWRlbnRpZmllcjogXCJtYXAtbWFya2VyXCIgfSxcbiAgeyB0eXBlOiBcInNlcmllc1wiLCBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsIGNoYXJ0VHlwZXM6IFtcInRvcG9sb2d5XCJdLCBpZGVudGlmaWVyOiBcIm1hcC1zaGFwZS1iYWNrZ3JvdW5kXCIgfSxcbiAgeyB0eXBlOiBcInNlcmllc1wiLCBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsIGNoYXJ0VHlwZXM6IFtcInRvcG9sb2d5XCJdLCBpZGVudGlmaWVyOiBcIm1hcC1saW5lLWJhY2tncm91bmRcIiB9LFxuICB7IHR5cGU6IFwic2VyaWVzXCIsIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIiwgY2hhcnRUeXBlczogW1wiZmxvdy1wcm9wb3J0aW9uXCJdLCBpZGVudGlmaWVyOiBcImNob3JkXCIgfSxcbiAgeyB0eXBlOiBcInNlcmllc1wiLCBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsIGNoYXJ0VHlwZXM6IFtcImZsb3ctcHJvcG9ydGlvblwiXSwgaWRlbnRpZmllcjogXCJzYW5rZXlcIiB9LFxuICB7IHR5cGU6IFwic2VyaWVzXCIsIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIiwgY2hhcnRUeXBlczogW1wic3RhbmRhbG9uZVwiXSwgaWRlbnRpZmllcjogXCJweXJhbWlkXCIgfSxcbiAgeyB0eXBlOiBcInNlcmllc1wiLCBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsIGNoYXJ0VHlwZXM6IFtcImdhdWdlXCJdLCBpZGVudGlmaWVyOiBcImxpbmVhci1nYXVnZVwiIH0sXG4gIHsgdHlwZTogXCJzZXJpZXNcIiwgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJnYXVnZVwiXSwgaWRlbnRpZmllcjogXCJyYWRpYWwtZ2F1Z2VcIiB9LFxuICB7IHR5cGU6IFwic2VyaWVzLW9wdGlvblwiLCBvcHRpb25zS2V5OiBcImVycm9yQmFyXCIsIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiXSwgaWRlbnRpZmllcjogXCJlcnJvci1iYXJzXCIgfVxuXTtcbmZ1bmN0aW9uIGlzRW50ZXJwcmlzZVNlcmllc1R5cGUodHlwZSkge1xuICByZXR1cm4gRVhQRUNURURfRU5URVJQUklTRV9NT0RVTEVTLnNvbWUoKHMpID0+IHMudHlwZSA9PT0gXCJzZXJpZXNcIiAmJiBzLmlkZW50aWZpZXIgPT09IHR5cGUpO1xufVxuZnVuY3Rpb24gZ2V0RW50ZXJwcmlzZVNlcmllc0NoYXJ0VHlwZXModHlwZSkge1xuICByZXR1cm4gRVhQRUNURURfRU5URVJQUklTRV9NT0RVTEVTLmZpbmQoKHMpID0+IHMudHlwZSA9PT0gXCJzZXJpZXNcIiAmJiBzLmlkZW50aWZpZXIgPT09IHR5cGUpPy5jaGFydFR5cGVzO1xufVxuZnVuY3Rpb24gaXNFbnRlcnByaXNlQ2FydGVzaWFuKHNlcmllc1R5cGUyKSB7XG4gIGNvbnN0IHR5cGUgPSBnZXRFbnRlcnByaXNlU2VyaWVzQ2hhcnRUeXBlcyhzZXJpZXNUeXBlMik/LmZpbmQoKHYpID0+IHYgPT09IFwiY2FydGVzaWFuXCIpO1xuICByZXR1cm4gdHlwZSA9PT0gXCJjYXJ0ZXNpYW5cIjtcbn1cbmZ1bmN0aW9uIGlzRW50ZXJwcmlzZVBvbGFyKHNlcmllc1R5cGUyKSB7XG4gIGNvbnN0IHR5cGUgPSBnZXRFbnRlcnByaXNlU2VyaWVzQ2hhcnRUeXBlcyhzZXJpZXNUeXBlMik/LmZpbmQoKHYpID0+IHYgPT09IFwicG9sYXJcIik7XG4gIHJldHVybiB0eXBlID09PSBcInBvbGFyXCI7XG59XG5mdW5jdGlvbiBpc0VudGVycHJpc2VIaWVyYXJjaHkoc2VyaWVzVHlwZTIpIHtcbiAgY29uc3QgdHlwZSA9IGdldEVudGVycHJpc2VTZXJpZXNDaGFydFR5cGVzKHNlcmllc1R5cGUyKT8uZmluZCgodikgPT4gdiA9PT0gXCJoaWVyYXJjaHlcIik7XG4gIHJldHVybiB0eXBlID09PSBcImhpZXJhcmNoeVwiO1xufVxuZnVuY3Rpb24gaXNFbnRlcnByaXNlVG9wb2xvZ3koc2VyaWVzVHlwZTIpIHtcbiAgY29uc3QgdHlwZSA9IGdldEVudGVycHJpc2VTZXJpZXNDaGFydFR5cGVzKHNlcmllc1R5cGUyKT8uZmluZCgodikgPT4gdiA9PT0gXCJ0b3BvbG9neVwiKTtcbiAgcmV0dXJuIHR5cGUgPT09IFwidG9wb2xvZ3lcIjtcbn1cbmZ1bmN0aW9uIGlzRW50ZXJwcmlzZUZsb3dQcm9wb3J0aW9uKHNlcmllc1R5cGUyKSB7XG4gIGNvbnN0IHR5cGUgPSBnZXRFbnRlcnByaXNlU2VyaWVzQ2hhcnRUeXBlcyhzZXJpZXNUeXBlMik/LmZpbmQoKHYpID0+IHYgPT09IFwiZmxvdy1wcm9wb3J0aW9uXCIpO1xuICByZXR1cm4gdHlwZSA9PT0gXCJmbG93LXByb3BvcnRpb25cIjtcbn1cbmZ1bmN0aW9uIGlzRW50ZXJwcmlzZVN0YW5kYWxvbmUoc2VyaWVzVHlwZTIpIHtcbiAgY29uc3QgdHlwZSA9IGdldEVudGVycHJpc2VTZXJpZXNDaGFydFR5cGVzKHNlcmllc1R5cGUyKT8uZmluZCgodikgPT4gdiA9PT0gXCJzdGFuZGFsb25lXCIpO1xuICByZXR1cm4gdHlwZSA9PT0gXCJzdGFuZGFsb25lXCI7XG59XG5mdW5jdGlvbiBpc0VudGVycHJpc2VHYXVnZShzZXJpZXNUeXBlMikge1xuICBjb25zdCB0eXBlID0gZ2V0RW50ZXJwcmlzZVNlcmllc0NoYXJ0VHlwZXMoc2VyaWVzVHlwZTIpPy5maW5kKCh2KSA9PiB2ID09PSBcImdhdWdlXCIpO1xuICByZXR1cm4gdHlwZSA9PT0gXCJnYXVnZVwiO1xufVxuZnVuY3Rpb24gaXNFbnRlcnByaXNlTW9kdWxlKG1vZHVsZSkge1xuICByZXR1cm4gbW9kdWxlLnBhY2thZ2VUeXBlID09PSBcImVudGVycHJpc2VcIjtcbn1cbmZ1bmN0aW9uIHZlcmlmeUlmTW9kdWxlRXhwZWN0ZWQobW9kdWxlKSB7XG4gIGlmICghaXNFbnRlcnByaXNlTW9kdWxlKG1vZHVsZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBRyBDaGFydHMgLSBpbnRlcm5hbCBjb25maWd1cmF0aW9uIGVycm9yLCBvbmx5IGVudGVycHJpc2UgbW9kdWxlcyBuZWVkIHZlcmlmaWNhdGlvbi5cIik7XG4gIH1cbiAgY29uc3Qgc3R1YiA9IEVYUEVDVEVEX0VOVEVSUFJJU0VfTU9EVUxFUy5maW5kKChzKSA9PiB7XG4gICAgcmV0dXJuIHMudHlwZSA9PT0gbW9kdWxlLnR5cGUgJiYgcy5vcHRpb25zS2V5ID09PSBtb2R1bGUub3B0aW9uc0tleSAmJiBzLmlkZW50aWZpZXIgPT09IG1vZHVsZS5pZGVudGlmaWVyICYmIG1vZHVsZS5jaGFydFR5cGVzLmV2ZXJ5KCh0KSA9PiBzLmNoYXJ0VHlwZXMuaW5jbHVkZXModCkpO1xuICB9KTtcbiAgaWYgKHN0dWIpIHtcbiAgICBzdHViLnVzZUNvdW50ID8/IChzdHViLnVzZUNvdW50ID0gMCk7XG4gICAgc3R1Yi51c2VDb3VudCsrO1xuICB9XG4gIHJldHVybiBzdHViICE9IG51bGw7XG59XG5mdW5jdGlvbiBnZXRVbnVzZWRFeHBlY3RlZE1vZHVsZXMoKSB7XG4gIHJldHVybiBFWFBFQ1RFRF9FTlRFUlBSSVNFX01PRFVMRVMuZmlsdGVyKCh7IHVzZUNvdW50IH0pID0+IHVzZUNvdW50ID09IG51bGwgfHwgdXNlQ291bnQgPT09IDApO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9mYWN0b3J5L2xlZ2VuZFJlZ2lzdHJ5LnRzXG52YXIgTGVnZW5kUmVnaXN0cnkgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubGVnZW5kTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLnRoZW1lVGVtcGxhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICByZWdpc3RlcihsZWdlbmRUeXBlLCB7IG9wdGlvbnNLZXksIG1vZHVsZUZhY3RvcnksIHRoZW1lVGVtcGxhdGUgfSkge1xuICAgIHRoaXMubGVnZW5kTWFwLnNldChsZWdlbmRUeXBlLCB7IG9wdGlvbnNLZXksIG1vZHVsZUZhY3RvcnkgfSk7XG4gICAgdGhpcy50aGVtZVRlbXBsYXRlcy5zZXQob3B0aW9uc0tleSwgdGhlbWVUZW1wbGF0ZSk7XG4gIH1cbiAgY3JlYXRlKGxlZ2VuZFR5cGUsIG1vZHVsZUNvbnRleHQpIHtcbiAgICBjb25zdCBsZWdlbmRGYWN0b3J5ID0gdGhpcy5sZWdlbmRNYXAuZ2V0KGxlZ2VuZFR5cGUpPy5tb2R1bGVGYWN0b3J5O1xuICAgIGlmIChsZWdlbmRGYWN0b3J5KSB7XG4gICAgICByZXR1cm4gbGVnZW5kRmFjdG9yeShtb2R1bGVDb250ZXh0KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBBRyBDaGFydHMgLSB1bmtub3duIGxlZ2VuZCB0eXBlOiAke2xlZ2VuZFR5cGV9YCk7XG4gIH1cbiAgZ2V0VGhlbWVUZW1wbGF0ZXMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyh0aGlzLnRoZW1lVGVtcGxhdGVzKTtcbiAgfVxuICBnZXRLZXlzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMubGVnZW5kTWFwLmVudHJpZXMoKSkucmVkdWNlKFxuICAgICAgKHJlc3VsdCwgW2xlZ2VuZFR5cGUsIHJlY29yZF0pID0+IHtcbiAgICAgICAgcmVzdWx0W2xlZ2VuZFR5cGVdID0gcmVjb3JkLm9wdGlvbnNLZXk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LFxuICAgICAge31cbiAgICApO1xuICB9XG59O1xudmFyIGxlZ2VuZFJlZ2lzdHJ5ID0gbmV3IExlZ2VuZFJlZ2lzdHJ5KCk7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2ZhY3RvcnkvY2hhcnRUeXBlcy50c1xudmFyIENoYXJ0VHlwZXMgPSBjbGFzcyBleHRlbmRzIE1hcCB7XG4gIGdldChzZXJpZXNUeXBlMikge1xuICAgIHJldHVybiBzdXBlci5nZXQoc2VyaWVzVHlwZTIpID8/IFwidW5rbm93blwiO1xuICB9XG4gIGlzQ2FydGVzaWFuKHNlcmllc1R5cGUyKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KHNlcmllc1R5cGUyKSA9PT0gXCJjYXJ0ZXNpYW5cIjtcbiAgfVxuICBpc1BvbGFyKHNlcmllc1R5cGUyKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KHNlcmllc1R5cGUyKSA9PT0gXCJwb2xhclwiO1xuICB9XG4gIGlzSGllcmFyY2h5KHNlcmllc1R5cGUyKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KHNlcmllc1R5cGUyKSA9PT0gXCJoaWVyYXJjaHlcIjtcbiAgfVxuICBpc1RvcG9sb2d5KHNlcmllc1R5cGUyKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KHNlcmllc1R5cGUyKSA9PT0gXCJ0b3BvbG9neVwiO1xuICB9XG4gIGlzRmxvd1Byb3BvcnRpb24oc2VyaWVzVHlwZTIpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoc2VyaWVzVHlwZTIpID09PSBcImZsb3ctcHJvcG9ydGlvblwiO1xuICB9XG4gIGlzU3RhbmRhbG9uZShzZXJpZXNUeXBlMikge1xuICAgIHJldHVybiB0aGlzLmdldChzZXJpZXNUeXBlMikgPT09IFwic3RhbmRhbG9uZVwiO1xuICB9XG4gIGlzR2F1Z2Uoc2VyaWVzVHlwZTIpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoc2VyaWVzVHlwZTIpID09PSBcImdhdWdlXCI7XG4gIH1cbiAgZ2V0IHNlcmllc1R5cGVzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMua2V5cygpKTtcbiAgfVxuICBnZXQgY2FydGVzaWFuVHlwZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VyaWVzVHlwZXMuZmlsdGVyKCh0KSA9PiB0aGlzLmlzQ2FydGVzaWFuKHQpKTtcbiAgfVxuICBnZXQgcG9sYXJUeXBlcygpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJpZXNUeXBlcy5maWx0ZXIoKHQpID0+IHRoaXMuaXNQb2xhcih0KSk7XG4gIH1cbiAgZ2V0IGhpZXJhcmNoeVR5cGVzKCkge1xuICAgIHJldHVybiB0aGlzLnNlcmllc1R5cGVzLmZpbHRlcigodCkgPT4gdGhpcy5pc0hpZXJhcmNoeSh0KSk7XG4gIH1cbiAgZ2V0IHRvcG9sb2d5VHlwZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VyaWVzVHlwZXMuZmlsdGVyKCh0KSA9PiB0aGlzLmlzVG9wb2xvZ3kodCkpO1xuICB9XG4gIGdldCBmbG93UHJvcG9ydGlvblR5cGVzKCkge1xuICAgIHJldHVybiB0aGlzLnNlcmllc1R5cGVzLmZpbHRlcigodCkgPT4gdGhpcy5pc0Zsb3dQcm9wb3J0aW9uKHQpKTtcbiAgfVxuICBnZXQgc3RhbmRhbG9uZVR5cGVzKCkge1xuICAgIHJldHVybiB0aGlzLnNlcmllc1R5cGVzLmZpbHRlcigodCkgPT4gdGhpcy5pc1N0YW5kYWxvbmUodCkpO1xuICB9XG4gIGdldCBnYXVnZVR5cGVzKCkge1xuICAgIHJldHVybiB0aGlzLnNlcmllc1R5cGVzLmZpbHRlcigodCkgPT4gdGhpcy5pc0dhdWdlKHQpKTtcbiAgfVxufTtcbnZhciBDaGFydERlZmF1bHRzID0gY2xhc3MgZXh0ZW5kcyBNYXAge1xuICBzZXQoY2hhcnRUeXBlMiwgZGVmYXVsdHMpIHtcbiAgICByZXR1cm4gc3VwZXIuc2V0KGNoYXJ0VHlwZTIsIG1lcmdlRGVmYXVsdHMoZGVmYXVsdHMsIHRoaXMuZ2V0KGNoYXJ0VHlwZTIpKSk7XG4gIH1cbn07XG52YXIgY2hhcnRUeXBlcyA9IG5ldyBDaGFydFR5cGVzKCk7XG52YXIgcHVibGljQ2hhcnRUeXBlcyA9IG5ldyBDaGFydFR5cGVzKCk7XG52YXIgY2hhcnREZWZhdWx0cyA9IG5ldyBDaGFydERlZmF1bHRzKCk7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2ZhY3Rvcnkvc2VyaWVzUmVnaXN0cnkudHNcbnZhciBTZXJpZXNSZWdpc3RyeSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zZXJpZXNNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMudGhlbWVUZW1wbGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIHJlZ2lzdGVyKHNlcmllc1R5cGUyLCB7XG4gICAgY2hhcnRUeXBlczogW2NoYXJ0VHlwZTJdLFxuICAgIG1vZHVsZUZhY3RvcnksXG4gICAgdG9vbHRpcERlZmF1bHRzLFxuICAgIGRlZmF1bHRBeGVzLFxuICAgIHRoZW1lVGVtcGxhdGUsXG4gICAgcGFsZXR0ZUZhY3RvcnksXG4gICAgc29sbyxcbiAgICBzdGFja2FibGUsXG4gICAgZ3JvdXBhYmxlLFxuICAgIHN0YWNrZWRCeURlZmF1bHQsXG4gICAgaGlkZGVuXG4gIH0pIHtcbiAgICB0aGlzLnNldFRoZW1lVGVtcGxhdGUoc2VyaWVzVHlwZTIsIHRoZW1lVGVtcGxhdGUpO1xuICAgIHRoaXMuc2VyaWVzTWFwLnNldChzZXJpZXNUeXBlMiwge1xuICAgICAgbW9kdWxlRmFjdG9yeSxcbiAgICAgIHRvb2x0aXBEZWZhdWx0cyxcbiAgICAgIGRlZmF1bHRBeGVzLFxuICAgICAgcGFsZXR0ZUZhY3RvcnksXG4gICAgICBzb2xvLFxuICAgICAgc3RhY2thYmxlLFxuICAgICAgZ3JvdXBhYmxlLFxuICAgICAgc3RhY2tlZEJ5RGVmYXVsdFxuICAgIH0pO1xuICAgIGNoYXJ0VHlwZXMuc2V0KHNlcmllc1R5cGUyLCBjaGFydFR5cGUyKTtcbiAgICBpZiAoIWhpZGRlbikge1xuICAgICAgcHVibGljQ2hhcnRUeXBlcy5zZXQoc2VyaWVzVHlwZTIsIGNoYXJ0VHlwZTIpO1xuICAgIH1cbiAgfVxuICBjcmVhdGUoc2VyaWVzVHlwZTIsIG1vZHVsZUNvbnRleHQpIHtcbiAgICBjb25zdCBzZXJpZXNGYWN0b3J5ID0gdGhpcy5zZXJpZXNNYXAuZ2V0KHNlcmllc1R5cGUyKT8ubW9kdWxlRmFjdG9yeTtcbiAgICBpZiAoc2VyaWVzRmFjdG9yeSkge1xuICAgICAgcmV0dXJuIHNlcmllc0ZhY3RvcnkobW9kdWxlQ29udGV4dCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgQUcgQ2hhcnRzIC0gdW5rbm93biBzZXJpZXMgdHlwZTogJHtzZXJpZXNUeXBlMn1gKTtcbiAgfVxuICBjbG9uZURlZmF1bHRBeGVzKHNlcmllc1R5cGUyLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZGVmYXVsdEF4ZXMgPSB0aGlzLnNlcmllc01hcC5nZXQoc2VyaWVzVHlwZTIpPy5kZWZhdWx0QXhlcztcbiAgICBpZiAoZGVmYXVsdEF4ZXMgPT0gbnVsbClcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGF4ZXMgPSB0eXBlb2YgZGVmYXVsdEF4ZXMgPT09IFwiZnVuY3Rpb25cIiA/IGRlZmF1bHRBeGVzKG9wdGlvbnMpIDogZGVmYXVsdEF4ZXM7XG4gICAgcmV0dXJuIHsgYXhlczogZGVlcENsb25lKGF4ZXMpIH07XG4gIH1cbiAgc2V0VGhlbWVUZW1wbGF0ZShzZXJpZXNUeXBlMiwgdGhlbWVUZW1wbGF0ZSkge1xuICAgIGNvbnN0IGN1cnJlbnRUZW1wbGF0ZSA9IHRoaXMudGhlbWVUZW1wbGF0ZXMuZ2V0KHNlcmllc1R5cGUyKTtcbiAgICB0aGlzLnRoZW1lVGVtcGxhdGVzLnNldChzZXJpZXNUeXBlMiwgbWVyZ2VEZWZhdWx0cyh0aGVtZVRlbXBsYXRlLCBjdXJyZW50VGVtcGxhdGUpKTtcbiAgfVxuICBnZXRUaGVtZVRlbXBsYXRlKHNlcmllc1R5cGUyKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbWVUZW1wbGF0ZXMuZ2V0KHNlcmllc1R5cGUyKTtcbiAgfVxuICBnZXRQYWxldHRlRmFjdG9yeShzZXJpZXNUeXBlMikge1xuICAgIHJldHVybiB0aGlzLnNlcmllc01hcC5nZXQoc2VyaWVzVHlwZTIpPy5wYWxldHRlRmFjdG9yeTtcbiAgfVxuICBnZXRUb29sdGlwRGVmYXVscyhzZXJpZXNUeXBlMikge1xuICAgIHJldHVybiB0aGlzLnNlcmllc01hcC5nZXQoc2VyaWVzVHlwZTIpPy50b29sdGlwRGVmYXVsdHM7XG4gIH1cbiAgaXNTb2xvKHNlcmllc1R5cGUyKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VyaWVzTWFwLmdldChzZXJpZXNUeXBlMik/LnNvbG8gPz8gZmFsc2U7XG4gIH1cbiAgaXNHcm91cGFibGUoc2VyaWVzVHlwZTIpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJpZXNNYXAuZ2V0KHNlcmllc1R5cGUyKT8uZ3JvdXBhYmxlID8/IGZhbHNlO1xuICB9XG4gIGlzU3RhY2thYmxlKHNlcmllc1R5cGUyKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VyaWVzTWFwLmdldChzZXJpZXNUeXBlMik/LnN0YWNrYWJsZSA/PyBmYWxzZTtcbiAgfVxuICBpc1N0YWNrZWRCeURlZmF1bHQoc2VyaWVzVHlwZTIpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJpZXNNYXAuZ2V0KHNlcmllc1R5cGUyKT8uc3RhY2tlZEJ5RGVmYXVsdCA/PyBmYWxzZTtcbiAgfVxufTtcbnZhciBzZXJpZXNSZWdpc3RyeSA9IG5ldyBTZXJpZXNSZWdpc3RyeSgpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9pbnRlcmFjdGlvbi9zeW5jTWFuYWdlci50c1xudmFyIF9TeW5jTWFuYWdlciA9IGNsYXNzIF9TeW5jTWFuYWdlciBleHRlbmRzIEJhc2VNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoY2hhcnQpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY2hhcnQgPSBjaGFydDtcbiAgfVxuICBzdWJzY3JpYmUoZ3JvdXBJZCA9IF9TeW5jTWFuYWdlci5ERUZBVUxUX0dST1VQKSB7XG4gICAgbGV0IHN5bmNHcm91cCA9IHRoaXMuZ2V0KGdyb3VwSWQpO1xuICAgIGlmICghc3luY0dyb3VwKSB7XG4gICAgICBzeW5jR3JvdXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgX1N5bmNNYW5hZ2VyLmNoYXJ0c0dyb3Vwcy5zZXQoZ3JvdXBJZCwgc3luY0dyb3VwKTtcbiAgICB9XG4gICAgc3luY0dyb3VwLmFkZCh0aGlzLmNoYXJ0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB1bnN1YnNjcmliZShncm91cElkID0gX1N5bmNNYW5hZ2VyLkRFRkFVTFRfR1JPVVApIHtcbiAgICB0aGlzLmdldChncm91cElkKT8uZGVsZXRlKHRoaXMuY2hhcnQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGdldENoYXJ0KCkge1xuICAgIHJldHVybiB0aGlzLmNoYXJ0O1xuICB9XG4gIGdldEdyb3VwKGdyb3VwSWQgPSBfU3luY01hbmFnZXIuREVGQVVMVF9HUk9VUCkge1xuICAgIGNvbnN0IHN5bmNHcm91cCA9IHRoaXMuZ2V0KGdyb3VwSWQpO1xuICAgIHJldHVybiBzeW5jR3JvdXAgPyBBcnJheS5mcm9tKHN5bmNHcm91cCkgOiBbXTtcbiAgfVxuICBnZXRHcm91cFNpYmxpbmdzKGdyb3VwSWQgPSBfU3luY01hbmFnZXIuREVGQVVMVF9HUk9VUCkge1xuICAgIHJldHVybiB0aGlzLmdldEdyb3VwKGdyb3VwSWQpLmZpbHRlcigoY2hhcnQpID0+IGNoYXJ0ICE9PSB0aGlzLmNoYXJ0KTtcbiAgfVxuICBnZXQoZ3JvdXBJZCkge1xuICAgIHJldHVybiBfU3luY01hbmFnZXIuY2hhcnRzR3JvdXBzLmdldChncm91cElkKTtcbiAgfVxufTtcbl9TeW5jTWFuYWdlci5jaGFydHNHcm91cHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuX1N5bmNNYW5hZ2VyLkRFRkFVTFRfR1JPVVAgPSBTeW1ib2woXCJzeW5jLWdyb3VwLWRlZmF1bHRcIik7XG52YXIgU3luY01hbmFnZXIgPSBfU3luY01hbmFnZXI7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2tleWJvYXJkLnRzXG52YXIgS2V5Ym9hcmQgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBLZXlib2FyZC5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE5VTUJFUilcbl0sIEtleWJvYXJkLnByb3RvdHlwZSwgXCJ0YWJJbmRleFwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbWFwcGluZy9wcmVwYXJlQXhpcy50c1xudmFyIENhcnRlc2lhbkF4aXNQb3NpdGlvbnMgPSBbXCJ0b3BcIiwgXCJyaWdodFwiLCBcImJvdHRvbVwiLCBcImxlZnRcIl07XG5mdW5jdGlvbiBpc0F4aXNQb3NpdGlvbihwb3NpdGlvbikge1xuICByZXR1cm4gdHlwZW9mIHBvc2l0aW9uID09PSBcInN0cmluZ1wiICYmIENhcnRlc2lhbkF4aXNQb3NpdGlvbnMuaW5jbHVkZXMocG9zaXRpb24pO1xufVxuZnVuY3Rpb24gZ3Vlc3NJbnZhbGlkUG9zaXRpb25zKGF4ZXMpIHtcbiAgY29uc3QgaW52YWxpZEF4ZXMgPSBbXTtcbiAgY29uc3QgdXNlZFBvc2l0aW9ucyA9IFtdO1xuICBjb25zdCBndWVzc2VzID0gWy4uLkNhcnRlc2lhbkF4aXNQb3NpdGlvbnNdO1xuICBmb3IgKGNvbnN0IGF4aXMgb2YgYXhlcykge1xuICAgIGlmIChheGlzIGluc3RhbmNlb2YgQ2FydGVzaWFuQXhpcykge1xuICAgICAgaWYgKGlzQXhpc1Bvc2l0aW9uKGF4aXMucG9zaXRpb24pKSB7XG4gICAgICAgIHVzZWRQb3NpdGlvbnMucHVzaChheGlzLnBvc2l0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludmFsaWRBeGVzLnB1c2goYXhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3QgYXhpcyBvZiBpbnZhbGlkQXhlcykge1xuICAgIGxldCBuZXh0R3Vlc3M7XG4gICAgZG8ge1xuICAgICAgbmV4dEd1ZXNzID0gZ3Vlc3Nlcy5wb3AoKTtcbiAgICB9IHdoaWxlIChuZXh0R3Vlc3MgJiYgdXNlZFBvc2l0aW9ucy5pbmNsdWRlcyhuZXh0R3Vlc3MpKTtcbiAgICBpZiAobmV4dEd1ZXNzID09IG51bGwpXG4gICAgICBicmVhaztcbiAgICBheGlzLnBvc2l0aW9uID0gbmV4dEd1ZXNzO1xuICB9XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L21hcHBpbmcvcHJlcGFyZVNlcmllcy50c1xudmFyIE1BVENISU5HX0tFWVMgPSBbXCJkaXJlY3Rpb25cIiwgXCJ4S2V5XCIsIFwieUtleVwiLCBcInNpemVLZXlcIiwgXCJhbmdsZUtleVwiLCBcInJhZGl1c0tleVwiLCBcIm5vcm1hbGl6ZWRUb1wiXTtcbmZ1bmN0aW9uIG1hdGNoU2VyaWVzT3B0aW9ucyhzZXJpZXMsIG9wdFNlcmllcywgb2xkT3B0c1Nlcmllcykge1xuICBjb25zdCBnZW5lcmF0ZUtleSA9ICh0eXBlLCBpLCBvcHRzKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gW3R5cGVdO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE1BVENISU5HX0tFWVMpIHtcbiAgICAgIGlmIChrZXkgaW4gaSAmJiBpW2tleV0gIT0gbnVsbClcbiAgICAgICAgcmVzdWx0LnB1c2goYCR7a2V5fT0ke2lba2V5XX1gKTtcbiAgICB9XG4gICAgaWYgKG9wdHM/LnNlcmllc0dyb3VwaW5nKSB7XG4gICAgICByZXN1bHQucHVzaChgc2VyaWVzR3JvdXBpbmcuZ3JvdXBJZD0ke29wdHM/LnNlcmllc0dyb3VwaW5nLmdyb3VwSWR9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQuam9pbihcIjtcIik7XG4gIH07XG4gIGNvbnN0IHNlcmllc01hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGxldCBpZHggPSAwO1xuICBmb3IgKGNvbnN0IHMgb2Ygc2VyaWVzKSB7XG4gICAgY29uc3Qga2V5ID0gZ2VuZXJhdGVLZXkocy50eXBlLCBzLnByb3BlcnRpZXMsIG9sZE9wdHNTZXJpZXM/LltpZHhdKTtcbiAgICBpZiAoIXNlcmllc01hcC5oYXMoa2V5KSkge1xuICAgICAgc2VyaWVzTWFwLnNldChrZXksIFtdKTtcbiAgICB9XG4gICAgc2VyaWVzTWFwLmdldChrZXkpPy5wdXNoKFtzLCBpZHgrK10pO1xuICB9XG4gIGNvbnN0IG9wdHNNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBmb3IgKGNvbnN0IG8gb2Ygb3B0U2VyaWVzKSB7XG4gICAgY29uc3Qga2V5ID0gZ2VuZXJhdGVLZXkoby50eXBlLCBvLCBvKTtcbiAgICBpZiAoIW9wdHNNYXAuaGFzKGtleSkpIHtcbiAgICAgIG9wdHNNYXAuc2V0KGtleSwgW10pO1xuICAgIH1cbiAgICBvcHRzTWFwLmdldChrZXkpPy5wdXNoKG8pO1xuICB9XG4gIGNvbnN0IG92ZXJsYXAgPSBbLi4uc2VyaWVzTWFwLmtleXMoKV0uc29tZSgoaykgPT4gb3B0c01hcC5oYXMoaykpO1xuICBpZiAoIW92ZXJsYXApIHtcbiAgICByZXR1cm4geyBzdGF0dXM6IFwibm8tb3ZlcmxhcFwiLCBvbGRLZXlzOiBzZXJpZXNNYXAua2V5cygpLCBuZXdLZXlzOiBvcHRzTWFwLmtleXMoKSB9O1xuICB9XG4gIGNvbnN0IGNoYW5nZXMgPSBbXTtcbiAgbGV0IHRhcmdldElkeCA9IC0xO1xuICBmb3IgKGNvbnN0IFtrZXksIG9wdEFycmF5XSBvZiBvcHRzTWFwLmVudHJpZXMoKSkge1xuICAgIGZvciAoY29uc3Qgb3B0cyBvZiBvcHRBcnJheSkge1xuICAgICAgdGFyZ2V0SWR4Kys7XG4gICAgICBjb25zdCBzZXJpZXNBcnJheSA9IHNlcmllc01hcC5nZXQoa2V5KTtcbiAgICAgIGlmIChzZXJpZXNBcnJheSA9PSBudWxsIHx8IHNlcmllc0FycmF5Lmxlbmd0aCA8IDEpIHtcbiAgICAgICAgY2hhbmdlcy5wdXNoKHsgb3B0cywgaWR4OiB0YXJnZXRJZHgsIHN0YXR1czogXCJhZGRcIiB9KTtcbiAgICAgICAgc2VyaWVzTWFwLmRlbGV0ZShrZXkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IFtvdXRwdXRTZXJpZXMsIG91dHB1dElkeF0gPSBzZXJpZXNBcnJheS5zaGlmdCgpO1xuICAgICAgY29uc3QgcHJldmlvdXNPcHRzID0gb2xkT3B0c1Nlcmllcz8uW291dHB1dElkeF0gPz8ge307XG4gICAgICBjb25zdCBkaWZmMiA9IGpzb25EaWZmKHByZXZpb3VzT3B0cywgb3B0cyA/PyB7fSk7XG4gICAgICBjb25zdCB7IGdyb3VwSW5kZXgsIHN0YWNrSW5kZXggfSA9IGRpZmYyPy5zZXJpZXNHcm91cGluZyA/PyB7fTtcbiAgICAgIGlmIChncm91cEluZGV4ICE9IG51bGwgfHwgc3RhY2tJbmRleCAhPSBudWxsKSB7XG4gICAgICAgIGNoYW5nZXMucHVzaCh7IG9wdHMsIHNlcmllczogb3V0cHV0U2VyaWVzLCBkaWZmOiBkaWZmMiwgaWR4OiBvdXRwdXRJZHgsIHN0YXR1czogXCJzZXJpZXMtZ3JvdXBpbmdcIiB9KTtcbiAgICAgIH0gZWxzZSBpZiAoZGlmZjIpIHtcbiAgICAgICAgY2hhbmdlcy5wdXNoKHsgb3B0cywgc2VyaWVzOiBvdXRwdXRTZXJpZXMsIGRpZmY6IGRpZmYyLCBpZHg6IG91dHB1dElkeCwgc3RhdHVzOiBcInVwZGF0ZVwiIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hhbmdlcy5wdXNoKHsgb3B0cywgc2VyaWVzOiBvdXRwdXRTZXJpZXMsIGlkeDogb3V0cHV0SWR4LCBzdGF0dXM6IFwibm8tb3BcIiB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChzZXJpZXNBcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgc2VyaWVzTWFwLmRlbGV0ZShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IHNlcmllc0FycmF5IG9mIHNlcmllc01hcC52YWx1ZXMoKSkge1xuICAgIGZvciAoY29uc3QgW291dHB1dFNlcmllcywgb3V0cHV0SWR4XSBvZiBzZXJpZXNBcnJheSkge1xuICAgICAgY2hhbmdlcy5wdXNoKHsgc2VyaWVzOiBvdXRwdXRTZXJpZXMsIGlkeDogb3V0cHV0SWR4LCBzdGF0dXM6IFwicmVtb3ZlXCIgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7IHN0YXR1czogXCJvdmVybGFwXCIsIGNoYW5nZXMgfTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbWFwcGluZy90eXBlcy50c1xuZnVuY3Rpb24gb3B0aW9uc1R5cGUoaW5wdXQpIHtcbiAgY29uc3QgeyBzZXJpZXMgfSA9IGlucHV0O1xuICBpZiAoIXNlcmllcylcbiAgICByZXR1cm47XG4gIHJldHVybiBzZXJpZXNbMF0/LnR5cGUgPz8gXCJsaW5lXCI7XG59XG5mdW5jdGlvbiBpc0FnQ2FydGVzaWFuQ2hhcnRPcHRpb25zKGlucHV0KSB7XG4gIGNvbnN0IHNwZWNpZmllZFR5cGUgPSBvcHRpb25zVHlwZShpbnB1dCk7XG4gIGlmIChzcGVjaWZpZWRUeXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGNoYXJ0VHlwZXMuaXNDYXJ0ZXNpYW4oc3BlY2lmaWVkVHlwZSkgfHwgaXNFbnRlcnByaXNlQ2FydGVzaWFuKHNwZWNpZmllZFR5cGUpO1xufVxuZnVuY3Rpb24gaXNBZ1BvbGFyQ2hhcnRPcHRpb25zKGlucHV0KSB7XG4gIGNvbnN0IHNwZWNpZmllZFR5cGUgPSBvcHRpb25zVHlwZShpbnB1dCk7XG4gIGlmIChzcGVjaWZpZWRUeXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHNwZWNpZmllZFR5cGUgPT09IFwicG9sYXJcIikge1xuICAgIExvZ2dlci53YXJuT25jZShgdHlwZSAnJHtzcGVjaWZpZWRUeXBlfScgaXMgZGVwcmVjYXRlZCwgdXNlIGEgc2VyaWVzIHR5cGUgaW5zdGVhZGApO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBjaGFydFR5cGVzLmlzUG9sYXIoc3BlY2lmaWVkVHlwZSkgfHwgaXNFbnRlcnByaXNlUG9sYXIoc3BlY2lmaWVkVHlwZSk7XG59XG5mdW5jdGlvbiBpc0FnSGllcmFyY2h5Q2hhcnRPcHRpb25zKGlucHV0KSB7XG4gIGNvbnN0IHNwZWNpZmllZFR5cGUgPSBvcHRpb25zVHlwZShpbnB1dCk7XG4gIGlmIChzcGVjaWZpZWRUeXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHNwZWNpZmllZFR5cGUgPT09IFwiaGllcmFyY2h5XCIpIHtcbiAgICBMb2dnZXIud2Fybk9uY2UoYHR5cGUgJyR7c3BlY2lmaWVkVHlwZX0nIGlzIGRlcHJlY2F0ZWQsIHVzZSBhIHNlcmllcyB0eXBlIGluc3RlYWRgKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gY2hhcnRUeXBlcy5pc0hpZXJhcmNoeShzcGVjaWZpZWRUeXBlKSB8fCBpc0VudGVycHJpc2VIaWVyYXJjaHkoc3BlY2lmaWVkVHlwZSk7XG59XG5mdW5jdGlvbiBpc0FnVG9wb2xvZ3lDaGFydE9wdGlvbnMoaW5wdXQpIHtcbiAgY29uc3Qgc3BlY2lmaWVkVHlwZSA9IG9wdGlvbnNUeXBlKGlucHV0KTtcbiAgaWYgKHNwZWNpZmllZFR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoc3BlY2lmaWVkVHlwZSA9PT0gXCJ0b3BvbG9neVwiKSB7XG4gICAgTG9nZ2VyLndhcm5PbmNlKGB0eXBlICcke3NwZWNpZmllZFR5cGV9JyBpcyBkZXByZWNhdGVkLCB1c2UgYSBzZXJpZXMgdHlwZSBpbnN0ZWFkYCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGNoYXJ0VHlwZXMuaXNUb3BvbG9neShzcGVjaWZpZWRUeXBlKSB8fCBpc0VudGVycHJpc2VUb3BvbG9neShzcGVjaWZpZWRUeXBlKTtcbn1cbmZ1bmN0aW9uIGlzQWdGbG93UHJvcG9ydGlvbkNoYXJ0T3B0aW9ucyhpbnB1dCkge1xuICBjb25zdCBzcGVjaWZpZWRUeXBlID0gb3B0aW9uc1R5cGUoaW5wdXQpO1xuICBpZiAoc3BlY2lmaWVkVHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChzcGVjaWZpZWRUeXBlID09PSBcImZsb3ctcHJvcG9ydGlvblwiKSB7XG4gICAgTG9nZ2VyLndhcm5PbmNlKGB0eXBlICcke3NwZWNpZmllZFR5cGV9JyBpcyBkZXByZWNhdGVkLCB1c2UgYSBzZXJpZXMgdHlwZSBpbnN0ZWFkYCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGNoYXJ0VHlwZXMuaXNGbG93UHJvcG9ydGlvbihzcGVjaWZpZWRUeXBlKSB8fCBpc0VudGVycHJpc2VGbG93UHJvcG9ydGlvbihzcGVjaWZpZWRUeXBlKTtcbn1cbmZ1bmN0aW9uIGlzQWdTdGFuZGFsb25lQ2hhcnRPcHRpb25zKGlucHV0KSB7XG4gIGNvbnN0IHNwZWNpZmllZFR5cGUgPSBvcHRpb25zVHlwZShpbnB1dCk7XG4gIGlmIChzcGVjaWZpZWRUeXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHNwZWNpZmllZFR5cGUgPT09IFwic3RhbmRhbG9uZVwiKSB7XG4gICAgTG9nZ2VyLndhcm5PbmNlKGB0eXBlICcke3NwZWNpZmllZFR5cGV9JyBpcyBkZXByZWNhdGVkLCB1c2UgYSBzZXJpZXMgdHlwZSBpbnN0ZWFkYCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGNoYXJ0VHlwZXMuaXNTdGFuZGFsb25lKHNwZWNpZmllZFR5cGUpIHx8IGlzRW50ZXJwcmlzZVN0YW5kYWxvbmUoc3BlY2lmaWVkVHlwZSk7XG59XG5mdW5jdGlvbiBpc0FnR2F1Z2VDaGFydE9wdGlvbnMoaW5wdXQpIHtcbiAgY29uc3Qgc3BlY2lmaWVkVHlwZSA9IG9wdGlvbnNUeXBlKGlucHV0KTtcbiAgaWYgKHNwZWNpZmllZFR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoc3BlY2lmaWVkVHlwZSA9PT0gXCJnYXVnZVwiKSB7XG4gICAgTG9nZ2VyLndhcm5PbmNlKGB0eXBlICcke3NwZWNpZmllZFR5cGV9JyBpcyBkZXByZWNhdGVkLCB1c2UgYSBzZXJpZXMgdHlwZSBpbnN0ZWFkYCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGNoYXJ0VHlwZXMuaXNHYXVnZShzcGVjaWZpZWRUeXBlKSB8fCBpc0VudGVycHJpc2VHYXVnZShzcGVjaWZpZWRUeXBlKTtcbn1cbmZ1bmN0aW9uIGlzQWdQb2xhckNoYXJ0T3B0aW9uc1dpdGhTZXJpZXNCYXNlZExlZ2VuZChpbnB1dCkge1xuICBjb25zdCBzcGVjaWZpZWRUeXBlID0gb3B0aW9uc1R5cGUoaW5wdXQpO1xuICByZXR1cm4gaXNBZ1BvbGFyQ2hhcnRPcHRpb25zKGlucHV0KSAmJiBzcGVjaWZpZWRUeXBlICE9PSBcInBpZVwiICYmIHNwZWNpZmllZFR5cGUgIT09IFwiZG9udXRcIjtcbn1cbmZ1bmN0aW9uIGlzU2VyaWVzT3B0aW9uVHlwZShpbnB1dCkge1xuICBpZiAoaW5wdXQgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gY2hhcnRUeXBlcy5oYXMoaW5wdXQpO1xufVxuZnVuY3Rpb24gaXNBeGlzT3B0aW9uVHlwZShpbnB1dCkge1xuICBpZiAoaW5wdXQgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gYXhpc1JlZ2lzdHJ5LmhhcyhpbnB1dCk7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L21vZHVsZXNNYW5hZ2VyLnRzXG52YXIgTW9kdWxlc01hbmFnZXIgPSBjbGFzcyBleHRlbmRzIE1vZHVsZU1hcCB7XG4gIGFwcGx5T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgZm9yIChjb25zdCBtIG9mIHRoaXMubW9kdWxlTWFwLnZhbHVlcygpKSB7XG4gICAgICBpZiAobS5tb2R1bGUub3B0aW9uc0tleSBpbiBvcHRpb25zICYmIGlzUHJvcGVydGllcyhtLm1vZHVsZUluc3RhbmNlKSkge1xuICAgICAgICBtLm1vZHVsZUluc3RhbmNlLnNldChvcHRpb25zW20ubW9kdWxlLm9wdGlvbnNLZXldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgKmxlZ2VuZHMoKSB7XG4gICAgZm9yIChjb25zdCB7IG1vZHVsZSwgbW9kdWxlSW5zdGFuY2UgfSBvZiB0aGlzLm1vZHVsZU1hcC52YWx1ZXMoKSkge1xuICAgICAgaWYgKG1vZHVsZS50eXBlICE9PSBcImxlZ2VuZFwiKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHlpZWxkIHtcbiAgICAgICAgbGVnZW5kVHlwZTogbW9kdWxlLmlkZW50aWZpZXIsXG4gICAgICAgIGxlZ2VuZDogbW9kdWxlSW5zdGFuY2VcbiAgICAgIH07XG4gICAgfVxuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9vdmVybGF5L292ZXJsYXkudHNcbnZhciBERUZBVUxUX09WRVJMQVlfQ0xBU1MgPSBcImFnLWNoYXJ0LW92ZXJsYXlcIjtcbnZhciBERUZBVUxUX09WRVJMQVlfREFSS19DTEFTUyA9IFwiYWctY2hhcnQtZGFyay1vdmVybGF5XCI7XG52YXIgT3ZlcmxheSA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcihjbGFzc05hbWUsIGRlZmF1bHRNZXNzYWdlSWQpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgIHRoaXMuZGVmYXVsdE1lc3NhZ2VJZCA9IGRlZmF1bHRNZXNzYWdlSWQ7XG4gIH1cbiAgZ2V0VGV4dChsb2NhbGVNYW5hZ2VyKSB7XG4gICAgcmV0dXJuIGxvY2FsZU1hbmFnZXIudCh0aGlzLnRleHQgPz8gdGhpcy5kZWZhdWx0TWVzc2FnZUlkKTtcbiAgfVxuICBnZXRFbGVtZW50KGFuaW1hdGlvbk1hbmFnZXIsIGxvY2FsZU1hbmFnZXIsIHJlY3QpIHtcbiAgICB0aGlzLmNvbnRlbnQ/LnJlbW92ZSgpO1xuICAgIHRoaXMuZm9jdXNCb3ggPSByZWN0O1xuICAgIGlmICh0aGlzLnJlbmRlcmVyKSB7XG4gICAgICBjb25zdCBodG1sQ29udGVudCA9IHRoaXMucmVuZGVyZXIoKTtcbiAgICAgIGlmIChodG1sQ29udGVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgIHRoaXMuY29udGVudCA9IGh0bWxDb250ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdGVtcERpdiA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRlbXBEaXYuaW5uZXJIVE1MID0gaHRtbENvbnRlbnQ7XG4gICAgICAgIHRoaXMuY29udGVudCA9IHRlbXBEaXYuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgICAgIGFsaWduSXRlbXM6IFwiY2VudGVyXCIsXG4gICAgICAgIGp1c3RpZnlDb250ZW50OiBcImNlbnRlclwiLFxuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgICBtYXJnaW46IFwiOHB4XCIsXG4gICAgICAgIGZvbnQ6IFwiMTJweCBWZXJkYW5hLCBzYW5zLXNlcmlmXCJcbiAgICAgIH0pO1xuICAgICAgY29udGVudC5pbm5lclRleHQgPSB0aGlzLmdldFRleHQobG9jYWxlTWFuYWdlcik7XG4gICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgICAgYW5pbWF0aW9uTWFuYWdlcj8uYW5pbWF0ZSh7XG4gICAgICAgIGZyb206IDAsXG4gICAgICAgIHRvOiAxLFxuICAgICAgICBpZDogXCJvdmVybGF5XCIsXG4gICAgICAgIHBoYXNlOiBcImFkZFwiLFxuICAgICAgICBncm91cElkOiBcIm9wYWNpdHlcIixcbiAgICAgICAgb25VcGRhdGUodmFsdWUpIHtcbiAgICAgICAgICBjb250ZW50LnN0eWxlLm9wYWNpdHkgPSBTdHJpbmcodmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBvblN0b3AoKSB7XG4gICAgICAgICAgY29udGVudC5zdHlsZS5vcGFjaXR5ID0gXCIxXCI7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250ZW50O1xuICB9XG4gIHJlbW92ZUVsZW1lbnQoY2xlYW51cCA9ICgpID0+IHRoaXMuY29udGVudD8ucmVtb3ZlKCksIGFuaW1hdGlvbk1hbmFnZXIpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudClcbiAgICAgIHJldHVybjtcbiAgICBpZiAoYW5pbWF0aW9uTWFuYWdlcikge1xuICAgICAgY29uc3QgeyBjb250ZW50IH0gPSB0aGlzO1xuICAgICAgYW5pbWF0aW9uTWFuYWdlci5hbmltYXRlKHtcbiAgICAgICAgZnJvbTogMSxcbiAgICAgICAgdG86IDAsXG4gICAgICAgIHBoYXNlOiBcInJlbW92ZVwiLFxuICAgICAgICBpZDogXCJvdmVybGF5XCIsXG4gICAgICAgIGdyb3VwSWQ6IFwib3BhY2l0eVwiLFxuICAgICAgICBvblVwZGF0ZSh2YWx1ZSkge1xuICAgICAgICAgIGNvbnRlbnQuc3R5bGUub3BhY2l0eSA9IFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uU3RvcCgpIHtcbiAgICAgICAgICBjbGVhbnVwPy4oKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsZWFudXA/LigpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRlbnQgPSB2b2lkIDA7XG4gICAgdGhpcy5mb2N1c0JveCA9IHZvaWQgMDtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgT3ZlcmxheS5wcm90b3R5cGUsIFwidGV4dFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZVTkNUSU9OLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBPdmVybGF5LnByb3RvdHlwZSwgXCJyZW5kZXJlclwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvb3ZlcmxheS9jaGFydE92ZXJsYXlzLnRzXG52YXIgQ2hhcnRPdmVybGF5cyA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuZGFya1RoZW1lID0gZmFsc2U7XG4gICAgdGhpcy5sb2FkaW5nID0gbmV3IE92ZXJsYXkoXCJhZy1jaGFydC1sb2FkaW5nLW92ZXJsYXlcIiwgXCJvdmVybGF5TG9hZGluZ0RhdGFcIik7XG4gICAgdGhpcy5ub0RhdGEgPSBuZXcgT3ZlcmxheShcImFnLWNoYXJ0LW5vLWRhdGEtb3ZlcmxheVwiLCBcIm92ZXJsYXlOb0RhdGFcIik7XG4gICAgdGhpcy5ub1Zpc2libGVTZXJpZXMgPSBuZXcgT3ZlcmxheShcImFnLWNoYXJ0LW5vLXZpc2libGUtc2VyaWVzXCIsIFwib3ZlcmxheU5vVmlzaWJsZVNlcmllc1wiKTtcbiAgfVxuICBnZXRGb2N1c0luZm8obG9jYWxlTWFuYWdlcikge1xuICAgIGZvciAoY29uc3Qgb3ZlcmxheSBvZiBbdGhpcy5sb2FkaW5nLCB0aGlzLm5vRGF0YSwgdGhpcy5ub1Zpc2libGVTZXJpZXNdKSB7XG4gICAgICBpZiAob3ZlcmxheS5mb2N1c0JveCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiB7IHRleHQ6IG92ZXJsYXkuZ2V0VGV4dChsb2NhbGVNYW5hZ2VyKSwgcmVjdDogb3ZlcmxheS5mb2N1c0JveCB9O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5sb2FkaW5nLnJlbW92ZUVsZW1lbnQoKTtcbiAgICB0aGlzLm5vRGF0YS5yZW1vdmVFbGVtZW50KCk7XG4gICAgdGhpcy5ub1Zpc2libGVTZXJpZXMucmVtb3ZlRWxlbWVudCgpO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIENoYXJ0T3ZlcmxheXMucHJvdG90eXBlLCBcImRhcmtUaGVtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIENoYXJ0T3ZlcmxheXMucHJvdG90eXBlLCBcImxvYWRpbmdcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBDaGFydE92ZXJsYXlzLnByb3RvdHlwZSwgXCJub0RhdGFcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBDaGFydE92ZXJsYXlzLnByb3RvdHlwZSwgXCJub1Zpc2libGVTZXJpZXNcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L292ZXJsYXkvbG9hZGluZ1NwaW5uZXIudHNcbmZ1bmN0aW9uIGdldExvYWRpbmdTcGlubmVyKHRleHQsIGRlZmF1bHREdXJhdGlvbikge1xuICBjb25zdCB7IGFuaW1hdGlvbkR1cmF0aW9uIH0gPSBQSEFTRV9NRVRBREFUQVtcImFkZFwiXTtcbiAgY29uc3QgZHVyYXRpb24gPSBhbmltYXRpb25EdXJhdGlvbiAqIGRlZmF1bHREdXJhdGlvbjtcbiAgY29uc3QgY29udGFpbmVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBgJHtERUZBVUxUX09WRVJMQVlfQ0xBU1N9LS1sb2FkaW5nYCwge1xuICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgIGFsaWduSXRlbXM6IFwiY2VudGVyXCIsXG4gICAganVzdGlmeUNvbnRlbnQ6IFwiY2VudGVyXCIsXG4gICAgZmxleERpcmVjdGlvbjogXCJjb2x1bW5cIixcbiAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG4gICAgZm9udDogXCIxM3B4IFZlcmRhbmEsIHNhbnMtc2VyaWZcIixcbiAgICAvLyBGT05UX1NJWkUuTUVESVVNXG4gICAgdXNlclNlbGVjdDogXCJub25lXCIsXG4gICAgYW5pbWF0aW9uOiBgYWctY2hhcnRzLWxvYWRpbmcgJHtkdXJhdGlvbn1tcyBsaW5lYXIgNTBtcyBib3RoYFxuICB9KTtcbiAgY29uc3QgbWF0cml4ID0gY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgIHdpZHRoOiBcIjQ1cHhcIixcbiAgICBoZWlnaHQ6IFwiNDBweFwiLFxuICAgIGJhY2tncm91bmRJbWFnZTogW1xuICAgICAgXCJsaW5lYXItZ3JhZGllbnQoIzAwMDAgY2FsYygxICogMTAwJSAvIDYpLCAjY2NjIDAgY2FsYygzICogMTAwJSAvIDYpLCAjMDAwMCAwKSwgXCIsXG4gICAgICBcImxpbmVhci1ncmFkaWVudCgjMDAwMCBjYWxjKDIgKiAxMDAlIC8gNiksICNjY2MgMCBjYWxjKDQgKiAxMDAlIC8gNiksICMwMDAwIDApLCBcIixcbiAgICAgIFwibGluZWFyLWdyYWRpZW50KCMwMDAwIGNhbGMoMyAqIDEwMCUgLyA2KSwgI2NjYyAwIGNhbGMoNSAqIDEwMCUgLyA2KSwgIzAwMDAgMClcIlxuICAgIF0uam9pbihcIlwiKSxcbiAgICBiYWNrZ3JvdW5kU2l6ZTogXCIxMHB4IDQwMCVcIixcbiAgICBiYWNrZ3JvdW5kUmVwZWF0OiBcIm5vLXJlcGVhdFwiLFxuICAgIGFuaW1hdGlvbjogXCJhZy1jaGFydHMtbG9hZGluZy1tYXRyaXggMXMgaW5maW5pdGUgbGluZWFyXCJcbiAgfSk7XG4gIGNvbnN0IGxhYmVsID0gY3JlYXRlRWxlbWVudChcInBcIiwgeyBtYXJnaW5Ub3A6IFwiMWVtXCIgfSk7XG4gIGxhYmVsLmlubmVyVGV4dCA9IHRleHQ7XG4gIGNvbnN0IGJhY2tncm91bmQgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIGAke0RFRkFVTFRfT1ZFUkxBWV9DTEFTU31fX2xvYWRpbmctYmFja2dyb3VuZGAsIHtcbiAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgIGluc2V0OiBcIjBcIixcbiAgICBvcGFjaXR5OiBcIjAuNVwiLFxuICAgIHpJbmRleDogXCItMVwiXG4gIH0pO1xuICBjb25zdCBhbmltYXRpb25TdHlsZXMgPSBjcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gIGFuaW1hdGlvblN0eWxlcy5pbm5lclRleHQgPSBbXG4gICAgXCJAa2V5ZnJhbWVzIGFnLWNoYXJ0cy1sb2FkaW5nIHsgZnJvbSB7IG9wYWNpdHk6IDAgfSB0byB7IG9wYWNpdHk6IDEgfSB9XCIsXG4gICAgXCJAa2V5ZnJhbWVzIGFnLWNoYXJ0cy1sb2FkaW5nLW1hdHJpeCB7XCIsXG4gICAgXCIwJSB7IGJhY2tncm91bmQtcG9zaXRpb246IDAlIDAlLCA1MCUgMCUsIDEwMCUgMCU7IH1cIixcbiAgICBcIjEwMCUgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAwJSAxMDAlLCA1MCUgMTAwJSwgMTAwJSAxMDAlOyB9XCIsXG4gICAgXCJ9XCJcbiAgXS5qb2luKFwiIFwiKTtcbiAgY29udGFpbmVyLnJlcGxhY2VDaGlsZHJlbihhbmltYXRpb25TdHlsZXMsIG1hdHJpeCwgbGFiZWwsIGJhY2tncm91bmQpO1xuICByZXR1cm4gY29udGFpbmVyO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvc2VyaWVzLnRzXG52YXIgU2VyaWVzTm9kZVBpY2tNb2RlID0gLyogQF9fUFVSRV9fICovICgoU2VyaWVzTm9kZVBpY2tNb2RlMikgPT4ge1xuICBTZXJpZXNOb2RlUGlja01vZGUyW1Nlcmllc05vZGVQaWNrTW9kZTJbXCJFWEFDVF9TSEFQRV9NQVRDSFwiXSA9IDBdID0gXCJFWEFDVF9TSEFQRV9NQVRDSFwiO1xuICBTZXJpZXNOb2RlUGlja01vZGUyW1Nlcmllc05vZGVQaWNrTW9kZTJbXCJORUFSRVNUX05PREVcIl0gPSAxXSA9IFwiTkVBUkVTVF9OT0RFXCI7XG4gIFNlcmllc05vZGVQaWNrTW9kZTJbU2VyaWVzTm9kZVBpY2tNb2RlMltcIkFYSVNfQUxJR05FRFwiXSA9IDJdID0gXCJBWElTX0FMSUdORURcIjtcbiAgcmV0dXJuIFNlcmllc05vZGVQaWNrTW9kZTI7XG59KShTZXJpZXNOb2RlUGlja01vZGUgfHwge30pO1xudmFyIENST1NTX0ZJTFRFUl9NQVJLRVJfRklMTF9PUEFDSVRZX0ZBQ1RPUiA9IDAuMjU7XG52YXIgQ1JPU1NfRklMVEVSX01BUktFUl9TVFJPS0VfT1BBQ0lUWV9GQUNUT1IgPSAwLjEyNTtcbnZhciBTZXJpZXNOb2RlRXZlbnQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHR5cGUsIGV2ZW50LCB7IGRhdHVtIH0sIHNlcmllcykge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5ldmVudCA9IGV2ZW50O1xuICAgIHRoaXMuZGF0dW0gPSBkYXR1bTtcbiAgICB0aGlzLnNlcmllc0lkID0gc2VyaWVzLmlkO1xuICB9XG59O1xudmFyIFNlcmllc0dyb3VwaW5nQ2hhbmdlZEV2ZW50ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihzZXJpZXMsIHNlcmllc0dyb3VwaW5nLCBvbGRHcm91cGluZykge1xuICAgIHRoaXMuc2VyaWVzID0gc2VyaWVzO1xuICAgIHRoaXMuc2VyaWVzR3JvdXBpbmcgPSBzZXJpZXNHcm91cGluZztcbiAgICB0aGlzLm9sZEdyb3VwaW5nID0gb2xkR3JvdXBpbmc7XG4gICAgdGhpcy50eXBlID0gXCJncm91cGluZ0NoYW5nZWRcIjtcbiAgfVxufTtcbnZhciBTZXJpZXMgPSBjbGFzcyBleHRlbmRzIE9ic2VydmFibGUge1xuICBjb25zdHJ1Y3RvcihzZXJpZXNPcHRzKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMgPSBbXTtcbiAgICB0aGlzLnNlcmllc0dyb3VwaW5nID0gdm9pZCAwO1xuICAgIHRoaXMuTm9kZUV2ZW50ID0gU2VyaWVzTm9kZUV2ZW50O1xuICAgIHRoaXMuaW50ZXJuYWxJZCA9IGNyZWF0ZUlkKHRoaXMpO1xuICAgIC8vIFRoZSBncm91cCBub2RlIHRoYXQgY29udGFpbnMgYWxsIHRoZSBub2RlcyB1c2VkIHRvIHJlbmRlciB0aGlzIHNlcmllcy5cbiAgICB0aGlzLnJvb3RHcm91cCA9IG5ldyBHcm91cCh7IG5hbWU6IFwic2VyaWVzUm9vdFwiLCBpc1ZpcnR1YWw6IHRydWUgfSk7XG4gICAgdGhpcy5heGVzID0ge1xuICAgICAgW1wieFwiIC8qIFggKi9dOiB2b2lkIDAsXG4gICAgICBbXCJ5XCIgLyogWSAqL106IHZvaWQgMFxuICAgIH07XG4gICAgdGhpcy5kaXJlY3Rpb25zID0gW1wieFwiIC8qIFggKi8sIFwieVwiIC8qIFkgKi9dO1xuICAgIC8vIEZsYWcgdG8gZGV0ZXJtaW5lIGlmIHdlIHNob3VsZCByZWNhbGN1bGF0ZSBub2RlIGRhdGEuXG4gICAgdGhpcy5ub2RlRGF0YVJlZnJlc2ggPSB0cnVlO1xuICAgIHRoaXMubW9kdWxlTWFwID0gbmV3IE1vZHVsZU1hcCgpO1xuICAgIHRoaXMuX2RlY2xhcmF0aW9uT3JkZXIgPSAtMTtcbiAgICB0aGlzLnNlcmllc0xpc3RlbmVycyA9IG5ldyBMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLl9waWNrTm9kZUNhY2hlID0gbmV3IExSVUNhY2hlKCk7XG4gICAgY29uc3Qge1xuICAgICAgbW9kdWxlQ3R4LFxuICAgICAgcGlja01vZGVzLFxuICAgICAgZGlyZWN0aW9uS2V5cyA9IHt9LFxuICAgICAgZGlyZWN0aW9uTmFtZXMgPSB7fSxcbiAgICAgIGNvbnRlbnRHcm91cFZpcnR1YWwgPSB0cnVlLFxuICAgICAgY2FuSGF2ZUF4ZXMgPSBmYWxzZVxuICAgIH0gPSBzZXJpZXNPcHRzO1xuICAgIHRoaXMuY3R4ID0gbW9kdWxlQ3R4O1xuICAgIHRoaXMuZGlyZWN0aW9uS2V5cyA9IGRpcmVjdGlvbktleXM7XG4gICAgdGhpcy5kaXJlY3Rpb25OYW1lcyA9IGRpcmVjdGlvbk5hbWVzO1xuICAgIHRoaXMuY2FuSGF2ZUF4ZXMgPSBjYW5IYXZlQXhlcztcbiAgICB0aGlzLmNvbnRlbnRHcm91cCA9IHRoaXMucm9vdEdyb3VwLmFwcGVuZENoaWxkKFxuICAgICAgbmV3IFRyYW5zbGF0YWJsZUdyb3VwKHtcbiAgICAgICAgbmFtZTogYCR7dGhpcy5pbnRlcm5hbElkfS1jb250ZW50YCxcbiAgICAgICAgaXNWaXJ0dWFsOiBjb250ZW50R3JvdXBWaXJ0dWFsLFxuICAgICAgICB6SW5kZXg6IDQgLyogU0VSSUVTX0xBWUVSICovLFxuICAgICAgICB6SW5kZXhTdWJPcmRlcjogdGhpcy5nZXRHcm91cFpJbmRleFN1Yk9yZGVyKFwiZGF0YVwiKVxuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMuaGlnaGxpZ2h0R3JvdXAgPSBuZXcgVHJhbnNsYXRhYmxlR3JvdXAoe1xuICAgICAgbmFtZTogYCR7dGhpcy5pbnRlcm5hbElkfS1oaWdobGlnaHRgLFxuICAgICAgaXNWaXJ0dWFsOiBjb250ZW50R3JvdXBWaXJ0dWFsLFxuICAgICAgekluZGV4OiA0IC8qIFNFUklFU19MQVlFUiAqLyxcbiAgICAgIHpJbmRleFN1Yk9yZGVyOiB0aGlzLmdldEdyb3VwWkluZGV4U3ViT3JkZXIoXCJoaWdobGlnaHRcIilcbiAgICB9KTtcbiAgICB0aGlzLmhpZ2hsaWdodE5vZGUgPSB0aGlzLmhpZ2hsaWdodEdyb3VwLmFwcGVuZENoaWxkKG5ldyBHcm91cCh7IG5hbWU6IFwiaGlnaGxpZ2h0Tm9kZVwiLCB6SW5kZXg6IDAgfSkpO1xuICAgIHRoaXMuaGlnaGxpZ2h0TGFiZWwgPSB0aGlzLmhpZ2hsaWdodEdyb3VwLmFwcGVuZENoaWxkKG5ldyBHcm91cCh7IG5hbWU6IFwiaGlnaGxpZ2h0TGFiZWxcIiwgekluZGV4OiAxMCB9KSk7XG4gICAgdGhpcy5waWNrTW9kZXMgPSBwaWNrTW9kZXM7XG4gICAgdGhpcy5sYWJlbEdyb3VwID0gdGhpcy5yb290R3JvdXAuYXBwZW5kQ2hpbGQoXG4gICAgICBuZXcgVHJhbnNsYXRhYmxlR3JvdXAoe1xuICAgICAgICBuYW1lOiBgJHt0aGlzLmludGVybmFsSWR9LXNlcmllcy1sYWJlbHNgLFxuICAgICAgICB6SW5kZXg6IDE0IC8qIFNFUklFU19MQUJFTCAqL1xuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMuYW5ub3RhdGlvbkdyb3VwID0gbmV3IEdyb3VwKHtcbiAgICAgIG5hbWU6IGAke3RoaXMuaWR9LWFubm90YXRpb25gLFxuICAgICAgaXNWaXJ0dWFsOiBjb250ZW50R3JvdXBWaXJ0dWFsLFxuICAgICAgekluZGV4OiA0IC8qIFNFUklFU19MQVlFUiAqLyxcbiAgICAgIHpJbmRleFN1Yk9yZGVyOiB0aGlzLmdldEdyb3VwWkluZGV4U3ViT3JkZXIoXCJhbm5vdGF0aW9uXCIpXG4gICAgfSk7XG4gIH1cbiAgZ2V0IHBpY2tNb2RlQXhpcygpIHtcbiAgICByZXR1cm4gXCJtYWluXCI7XG4gIH1cbiAgZ2V0IGlkKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXM/LmlkID8/IHRoaXMuaW50ZXJuYWxJZDtcbiAgfVxuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50eXBlID8/IFwiXCI7XG4gIH1cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEgPz8gdGhpcy5fY2hhcnREYXRhO1xuICB9XG4gIHNldCB2aXNpYmxlKHZhbHVlKSB7XG4gICAgdGhpcy5wcm9wZXJ0aWVzLnZpc2libGUgPSB2YWx1ZTtcbiAgICB0aGlzLnZpc2libGVNYXliZUNoYW5nZWQoKTtcbiAgfVxuICBnZXQgdmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLnZpc2libGU7XG4gIH1cbiAgZ2V0IGhhc0RhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YSAhPSBudWxsICYmIHRoaXMuZGF0YS5sZW5ndGggPiAwO1xuICB9XG4gIGdldCB0b29sdGlwRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLnRvb2x0aXA/LmVuYWJsZWQgPz8gZmFsc2U7XG4gIH1cbiAgb25EYXRhQ2hhbmdlKCkge1xuICAgIHRoaXMubm9kZURhdGFSZWZyZXNoID0gdHJ1ZTtcbiAgICB0aGlzLl9waWNrTm9kZUNhY2hlLmNsZWFyKCk7XG4gIH1cbiAgc2V0T3B0aW9uc0RhdGEoaW5wdXQpIHtcbiAgICB0aGlzLl9kYXRhID0gaW5wdXQ7XG4gICAgdGhpcy5vbkRhdGFDaGFuZ2UoKTtcbiAgfVxuICBzZXRDaGFydERhdGEoaW5wdXQpIHtcbiAgICB0aGlzLl9jaGFydERhdGEgPSBpbnB1dDtcbiAgICBpZiAodGhpcy5kYXRhID09PSBpbnB1dCkge1xuICAgICAgdGhpcy5vbkRhdGFDaGFuZ2UoKTtcbiAgICB9XG4gIH1cbiAgb25TZXJpZXNHcm91cGluZ0NoYW5nZShwcmV2LCBuZXh0KSB7XG4gICAgY29uc3QgeyBpbnRlcm5hbElkLCB0eXBlLCB2aXNpYmxlIH0gPSB0aGlzO1xuICAgIGlmIChwcmV2KSB7XG4gICAgICB0aGlzLmN0eC5zZXJpZXNTdGF0ZU1hbmFnZXIuZGVyZWdpc3RlclNlcmllcyh0aGlzKTtcbiAgICB9XG4gICAgaWYgKG5leHQpIHtcbiAgICAgIHRoaXMuY3R4LnNlcmllc1N0YXRlTWFuYWdlci5yZWdpc3RlclNlcmllcyh7IGludGVybmFsSWQsIHR5cGUsIHZpc2libGUsIHNlcmllc0dyb3VwaW5nOiBuZXh0IH0pO1xuICAgIH1cbiAgICB0aGlzLmZpcmVFdmVudChuZXcgU2VyaWVzR3JvdXBpbmdDaGFuZ2VkRXZlbnQodGhpcywgbmV4dCwgcHJldikpO1xuICB9XG4gIGdldEJhbmRTY2FsZVBhZGRpbmcoKSB7XG4gICAgcmV0dXJuIHsgaW5uZXI6IDEsIG91dGVyOiAwIH07XG4gIH1cbiAgZ2V0R3JvdXBaSW5kZXhTdWJPcmRlcih0eXBlLCBzdWJJbmRleCA9IDApIHtcbiAgICBsZXQgbWFpbkFkanVzdCA9IDA7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFwiZGF0YVwiOlxuICAgICAgY2FzZSBcInBhdGhzXCI6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImxhYmVsc1wiOlxuICAgICAgICBtYWluQWRqdXN0ICs9IDJlNDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibWFya2VyXCI6XG4gICAgICAgIG1haW5BZGp1c3QgKz0gMWU0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJoaWdobGlnaHRcIjpcbiAgICAgICAgc3ViSW5kZXggKz0gMTVlMztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYW5ub3RhdGlvblwiOlxuICAgICAgICBtYWluQWRqdXN0ICs9IDE1ZTM7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBtYWluID0gKCkgPT4gdGhpcy5fZGVjbGFyYXRpb25PcmRlciArIG1haW5BZGp1c3Q7XG4gICAgcmV0dXJuIFttYWluLCBzdWJJbmRleF07XG4gIH1cbiAgYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJpZXNMaXN0ZW5lcnMuYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpO1xuICB9XG4gIGRpc3BhdGNoKHR5cGUsIGV2ZW50KSB7XG4gICAgdGhpcy5zZXJpZXNMaXN0ZW5lcnMuZGlzcGF0Y2godHlwZSwgZXZlbnQpO1xuICB9XG4gIGFkZENoYXJ0RXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXN0cm95Rm5zLmZvckVhY2goKGYpID0+IGYoKSk7XG4gICAgdGhpcy5kZXN0cm95Rm5zID0gW107XG4gICAgdGhpcy5jdHguc2VyaWVzU3RhdGVNYW5hZ2VyLmRlcmVnaXN0ZXJTZXJpZXModGhpcyk7XG4gIH1cbiAgZ2V0RGlyZWN0aW9uVmFsdWVzKGRpcmVjdGlvbiwgcHJvcGVydGllcykge1xuICAgIGNvbnN0IHJlc29sdmVkRGlyZWN0aW9uID0gdGhpcy5yZXNvbHZlS2V5RGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgY29uc3Qga2V5cyA9IHByb3BlcnRpZXM/LltyZXNvbHZlZERpcmVjdGlvbl07XG4gICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgaWYgKCFrZXlzKSB7XG4gICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cbiAgICBjb25zdCBhZGRWYWx1ZXMgPSAoLi4uaXRlbXMpID0+IHtcbiAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgaXRlbXMpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgYWRkVmFsdWVzKC4uLnZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICBhZGRWYWx1ZXMoLi4uT2JqZWN0LnZhbHVlcyh2YWx1ZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgYWRkVmFsdWVzKC4uLmtleXMubWFwKChrZXkpID0+IHRoaXMucHJvcGVydGllc1trZXldKSk7XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxuICBnZXRLZXlzKGRpcmVjdGlvbikge1xuICAgIHJldHVybiB0aGlzLmdldERpcmVjdGlvblZhbHVlcyhkaXJlY3Rpb24sIHRoaXMuZGlyZWN0aW9uS2V5cyk7XG4gIH1cbiAgZ2V0S2V5UHJvcGVydGllcyhkaXJlY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy5kaXJlY3Rpb25LZXlzW3RoaXMucmVzb2x2ZUtleURpcmVjdGlvbihkaXJlY3Rpb24pXSA/PyBbXTtcbiAgfVxuICBnZXROYW1lcyhkaXJlY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy5nZXREaXJlY3Rpb25WYWx1ZXMoZGlyZWN0aW9uLCB0aGlzLmRpcmVjdGlvbk5hbWVzKTtcbiAgfVxuICByZXNvbHZlS2V5RGlyZWN0aW9uKGRpcmVjdGlvbikge1xuICAgIHJldHVybiBkaXJlY3Rpb247XG4gIH1cbiAgLy8gVGhlIHVuaW9uIG9mIHRoZSBzZXJpZXMgZG9tYWluICgnY29tbXVuaXR5JykgYW5kIHNlcmllcy1vcHRpb24gZG9tYWlucyAoJ2VudGVycHJpc2UnKS5cbiAgZ2V0RG9tYWluKGRpcmVjdGlvbikge1xuICAgIGNvbnN0IHNlcmllc0RvbWFpbiA9IHRoaXMuZ2V0U2VyaWVzRG9tYWluKGRpcmVjdGlvbik7XG4gICAgY29uc3QgbW9kdWxlRG9tYWlucyA9IHRoaXMubW9kdWxlTWFwLm1hcE1vZHVsZXMoKG1vZHVsZSkgPT4gbW9kdWxlLmdldERvbWFpbihkaXJlY3Rpb24pKTtcbiAgICByZXR1cm4gc2VyaWVzRG9tYWluLmNvbmNhdChtb2R1bGVEb21haW5zLmZsYXQoKSk7XG4gIH1cbiAgLy8gSW5kaWNhdGUgdGhhdCBzb21ldGhpbmcgZXh0ZXJuYWwgY2hhbmdlZCBhbmQgd2Ugc2hvdWxkIHJlY2FsY3VsYXRlIG5vZGVEYXRhLlxuICBtYXJrTm9kZURhdGFEaXJ0eSgpIHtcbiAgICB0aGlzLm5vZGVEYXRhUmVmcmVzaCA9IHRydWU7XG4gICAgdGhpcy5fcGlja05vZGVDYWNoZS5jbGVhcigpO1xuICAgIHRoaXMudmlzaWJsZU1heWJlQ2hhbmdlZCgpO1xuICB9XG4gIHZpc2libGVNYXliZUNoYW5nZWQoKSB7XG4gICAgdGhpcy5jdHguc2VyaWVzU3RhdGVNYW5hZ2VyLnVwZGF0ZVNlcmllcyh0aGlzKTtcbiAgfVxuICBnZXRPcGFjaXR5KCkge1xuICAgIGNvbnN0IGRlZmF1bHRPcGFjaXR5ID0gMTtcbiAgICBjb25zdCB7IGRpbU9wYWNpdHkgPSAxLCBlbmFibGVkID0gdHJ1ZSB9ID0gdGhpcy5wcm9wZXJ0aWVzLmhpZ2hsaWdodFN0eWxlLnNlcmllcztcbiAgICBpZiAoIWVuYWJsZWQgfHwgZGltT3BhY2l0eSA9PT0gZGVmYXVsdE9wYWNpdHkpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0T3BhY2l0eTtcbiAgICB9XG4gICAgc3dpdGNoICh0aGlzLmlzSXRlbUlkSGlnaGxpZ2h0ZWQoKSkge1xuICAgICAgY2FzZSAwIC8qIE5vbmUgKi86XG4gICAgICBjYXNlIDEgLyogVGhpcyAqLzpcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRPcGFjaXR5O1xuICAgICAgY2FzZSAyIC8qIE90aGVyICovOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGRpbU9wYWNpdHk7XG4gICAgfVxuICB9XG4gIGdldFN0cm9rZVdpZHRoKGRlZmF1bHRTdHJva2VXaWR0aCkge1xuICAgIGNvbnN0IHsgc3Ryb2tlV2lkdGgsIGVuYWJsZWQgPSB0cnVlIH0gPSB0aGlzLnByb3BlcnRpZXMuaGlnaGxpZ2h0U3R5bGUuc2VyaWVzO1xuICAgIGlmICghZW5hYmxlZCB8fCBzdHJva2VXaWR0aCA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdFN0cm9rZVdpZHRoO1xuICAgIH1cbiAgICBzd2l0Y2ggKHRoaXMuaXNJdGVtSWRIaWdobGlnaHRlZCgpKSB7XG4gICAgICBjYXNlIDEgLyogVGhpcyAqLzpcbiAgICAgICAgcmV0dXJuIHN0cm9rZVdpZHRoO1xuICAgICAgY2FzZSAwIC8qIE5vbmUgKi86XG4gICAgICBjYXNlIDIgLyogT3RoZXIgKi86XG4gICAgICAgIHJldHVybiBkZWZhdWx0U3Ryb2tlV2lkdGg7XG4gICAgfVxuICB9XG4gIGlzSXRlbUlkSGlnaGxpZ2h0ZWQoKSB7XG4gICAgY29uc3Qgc2VyaWVzID0gdGhpcy5jdHguaGlnaGxpZ2h0TWFuYWdlcj8uZ2V0QWN0aXZlSGlnaGxpZ2h0KCk/LnNlcmllcztcbiAgICBpZiAoc2VyaWVzID09IG51bGwpIHtcbiAgICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG4gICAgfVxuICAgIGlmIChzZXJpZXMgIT09IHRoaXMpIHtcbiAgICAgIHJldHVybiAyIC8qIE90aGVyICovO1xuICAgIH1cbiAgICByZXR1cm4gMSAvKiBUaGlzICovO1xuICB9XG4gIGdldE1vZHVsZVRvb2x0aXBQYXJhbXMoKSB7XG4gICAgcmV0dXJuIHRoaXMubW9kdWxlTWFwLm1hcE1vZHVsZXMoKG1vZHVsZSkgPT4gbW9kdWxlLmdldFRvb2x0aXBQYXJhbXMoKSkucmVkdWNlKCh0b3RhbCwgY3VycmVudCkgPT4gT2JqZWN0LmFzc2lnbih0b3RhbCwgY3VycmVudCksIHt9KTtcbiAgfVxuICBwaWNrTm9kZShwb2ludCwgaW50ZW50LCBleGFjdE1hdGNoT25seSA9IGZhbHNlKSB7XG4gICAgY29uc3QgeyBwaWNrTW9kZXMsIHBpY2tNb2RlQXhpcywgdmlzaWJsZSwgcm9vdEdyb3VwIH0gPSB0aGlzO1xuICAgIGlmICghdmlzaWJsZSB8fCAhcm9vdEdyb3VwLnZpc2libGUpXG4gICAgICByZXR1cm47XG4gICAgaWYgKGludGVudCA9PT0gXCJoaWdobGlnaHRcIiAmJiAhdGhpcy5wcm9wZXJ0aWVzLmhpZ2hsaWdodC5lbmFibGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChpbnRlbnQgPT09IFwiaGlnaGxpZ2h0LXRvb2x0aXBcIiAmJiAhdGhpcy5wcm9wZXJ0aWVzLmhpZ2hsaWdodC5lbmFibGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGxldCBtYXhEaXN0YW5jZSA9IEluZmluaXR5O1xuICAgIGlmIChpbnRlbnQgPT09IFwidG9vbHRpcFwiIHx8IGludGVudCA9PT0gXCJoaWdobGlnaHQtdG9vbHRpcFwiKSB7XG4gICAgICBjb25zdCB7IHRvb2x0aXAgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICAgIG1heERpc3RhbmNlID0gdHlwZW9mIHRvb2x0aXAucmFuZ2UgPT09IFwibnVtYmVyXCIgPyB0b29sdGlwLnJhbmdlIDogSW5maW5pdHk7XG4gICAgICBleGFjdE1hdGNoT25seSB8fCAoZXhhY3RNYXRjaE9ubHkgPSB0b29sdGlwLnJhbmdlID09PSBcImV4YWN0XCIpO1xuICAgIH0gZWxzZSBpZiAoaW50ZW50ID09PSBcImV2ZW50XCIgfHwgaW50ZW50ID09PSBcImNvbnRleHQtbWVudVwiKSB7XG4gICAgICBjb25zdCB7IG5vZGVDbGlja1JhbmdlIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgICBtYXhEaXN0YW5jZSA9IHR5cGVvZiBub2RlQ2xpY2tSYW5nZSA9PT0gXCJudW1iZXJcIiA/IG5vZGVDbGlja1JhbmdlIDogSW5maW5pdHk7XG4gICAgICBleGFjdE1hdGNoT25seSB8fCAoZXhhY3RNYXRjaE9ubHkgPSBub2RlQ2xpY2tSYW5nZSA9PT0gXCJleGFjdFwiKTtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0ZWRQaWNrTW9kZXMgPSBwaWNrTW9kZXMuZmlsdGVyKFxuICAgICAgKG0pID0+ICFleGFjdE1hdGNoT25seSB8fCBtID09PSAwIC8qIEVYQUNUX1NIQVBFX01BVENIICovXG4gICAgKTtcbiAgICBjb25zdCB7IHgsIHkgfSA9IHBvaW50O1xuICAgIGNvbnN0IGtleSA9IEpTT04uc3RyaW5naWZ5KHsgeCwgeSwgbWF4RGlzdGFuY2UsIHNlbGVjdGVkUGlja01vZGVzIH0pO1xuICAgIGlmICh0aGlzLl9waWNrTm9kZUNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGlja05vZGVDYWNoZS5nZXQoa2V5KTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBwaWNrTW9kZSBvZiBzZWxlY3RlZFBpY2tNb2Rlcykge1xuICAgICAgbGV0IG1hdGNoO1xuICAgICAgc3dpdGNoIChwaWNrTW9kZSkge1xuICAgICAgICBjYXNlIDAgLyogRVhBQ1RfU0hBUEVfTUFUQ0ggKi86XG4gICAgICAgICAgbWF0Y2ggPSB0aGlzLnBpY2tOb2RlRXhhY3RTaGFwZShwb2ludCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMSAvKiBORUFSRVNUX05PREUgKi86XG4gICAgICAgICAgbWF0Y2ggPSB0aGlzLnBpY2tOb2RlQ2xvc2VzdERhdHVtKHBvaW50KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyIC8qIEFYSVNfQUxJR05FRCAqLzpcbiAgICAgICAgICBtYXRjaCA9IHBpY2tNb2RlICE9IG51bGwgPyB0aGlzLnBpY2tOb2RlTWFpbkF4aXNGaXJzdChwb2ludCwgcGlja01vZGVBeGlzID09PSBcIm1haW4tY2F0ZWdvcnlcIikgOiB2b2lkIDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAobWF0Y2ggJiYgbWF0Y2guZGlzdGFuY2UgPD0gbWF4RGlzdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BpY2tOb2RlQ2FjaGUuc2V0KGtleSwgeyBwaWNrTW9kZSwgbWF0Y2g6IG1hdGNoLmRhdHVtLCBkaXN0YW5jZTogbWF0Y2guZGlzdGFuY2UgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9waWNrTm9kZUNhY2hlLnNldChrZXksIHZvaWQgMCk7XG4gIH1cbiAgcGlja05vZGVFeGFjdFNoYXBlKHBvaW50KSB7XG4gICAgY29uc3QgbWF0Y2ggPSB0aGlzLmNvbnRlbnRHcm91cC5waWNrTm9kZShwb2ludC54LCBwb2ludC55KTtcbiAgICBpZiAobWF0Y2ggJiYgbWF0Y2guZGF0dW0ubWlzc2luZyAhPT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIHsgZGF0dW06IG1hdGNoLmRhdHVtLCBkaXN0YW5jZTogMCB9O1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHBpY2tOb2RlQ2xvc2VzdERhdHVtKF9wb2ludCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkFHIENoYXJ0cyAtIFNlcmllcy5waWNrTm9kZUNsb3Nlc3REYXR1bSgpIG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICBwaWNrTm9kZU5lYXJlc3REaXN0YW50T2JqZWN0KHBvaW50LCBpdGVtcykge1xuICAgIGNvbnN0IG1hdGNoID0gbmVhcmVzdFNxdWFyZWQocG9pbnQueCwgcG9pbnQueSwgaXRlbXMpO1xuICAgIGlmIChtYXRjaC5uZWFyZXN0ICE9PSB2b2lkIDAgJiYgbWF0Y2gubmVhcmVzdC5kYXR1bS5taXNzaW5nICE9PSB0cnVlKSB7XG4gICAgICByZXR1cm4geyBkYXR1bTogbWF0Y2gubmVhcmVzdC5kYXR1bSwgZGlzdGFuY2U6IE1hdGguc3FydChtYXRjaC5kaXN0YW5jZVNxdWFyZWQpIH07XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcGlja05vZGVNYWluQXhpc0ZpcnN0KF9wb2ludCwgX3JlcXVpcmVDYXRlZ29yeUF4aXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBRyBDaGFydHMgLSBTZXJpZXMucGlja05vZGVNYWluQXhpc0ZpcnN0KCkgbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIGZpcmVOb2RlQ2xpY2tFdmVudChldmVudCwgZGF0dW0pIHtcbiAgICB0aGlzLmZpcmVFdmVudChuZXcgdGhpcy5Ob2RlRXZlbnQoXCJub2RlQ2xpY2tcIiwgZXZlbnQsIGRhdHVtLCB0aGlzKSk7XG4gIH1cbiAgZmlyZU5vZGVEb3VibGVDbGlja0V2ZW50KGV2ZW50LCBkYXR1bSkge1xuICAgIHRoaXMuZmlyZUV2ZW50KG5ldyB0aGlzLk5vZGVFdmVudChcIm5vZGVEb3VibGVDbGlja1wiLCBldmVudCwgZGF0dW0sIHRoaXMpKTtcbiAgfVxuICBjcmVhdGVOb2RlQ29udGV4dE1lbnVBY3Rpb25FdmVudChldmVudCwgZGF0dW0pIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuTm9kZUV2ZW50KFwibm9kZUNvbnRleHRNZW51QWN0aW9uXCIsIGV2ZW50LCBkYXR1bSwgdGhpcyk7XG4gIH1cbiAgdG9nZ2xlU2VyaWVzSXRlbShpdGVtSWQsIGVuYWJsZWQpIHtcbiAgICB0aGlzLnZpc2libGUgPSBlbmFibGVkO1xuICAgIHRoaXMubm9kZURhdGFSZWZyZXNoID0gdHJ1ZTtcbiAgICB0aGlzLl9waWNrTm9kZUNhY2hlLmNsZWFyKCk7XG4gICAgdGhpcy5kaXNwYXRjaChcInZpc2liaWxpdHktY2hhbmdlZFwiLCB7IGl0ZW1JZCwgZW5hYmxlZCB9KTtcbiAgfVxuICBpc0VuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMudmlzaWJsZTtcbiAgfVxuICBnZXRNb2R1bGVNYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMubW9kdWxlTWFwO1xuICB9XG4gIGNyZWF0ZU1vZHVsZUNvbnRleHQoKSB7XG4gICAgcmV0dXJuIHsgLi4udGhpcy5jdHgsIHNlcmllczogdGhpcyB9O1xuICB9XG4gIGdldExhYmVsVGV4dChsYWJlbCwgcGFyYW1zLCBkZWZhdWx0Rm9ybWF0dGVyID0gU3RyaW5nKSB7XG4gICAgaWYgKGxhYmVsLmZvcm1hdHRlcikge1xuICAgICAgcmV0dXJuIHRoaXMuY3R4LmNhbGxiYWNrQ2FjaGUuY2FsbChsYWJlbC5mb3JtYXR0ZXIsIHsgc2VyaWVzSWQ6IHRoaXMuaWQsIC4uLnBhcmFtcyB9KSA/PyBkZWZhdWx0Rm9ybWF0dGVyKHBhcmFtcy52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0Rm9ybWF0dGVyKHBhcmFtcy52YWx1ZSk7XG4gIH1cbiAgZ2V0TWFya2VyU3R5bGUobWFya2VyLCBwYXJhbXMsIGRlZmF1bHRTdHlsZSA9IG1hcmtlci5nZXRTdHlsZSgpKSB7XG4gICAgY29uc3QgZGVmYXVsdFNpemUgPSB7IHNpemU6IHBhcmFtcy5kYXR1bS5wb2ludD8uc2l6ZSA/PyAwIH07XG4gICAgY29uc3QgbWFya2VyU3R5bGUgPSBtZXJnZURlZmF1bHRzKGRlZmF1bHRTaXplLCBkZWZhdWx0U3R5bGUpO1xuICAgIGlmIChtYXJrZXIuaXRlbVN0eWxlcikge1xuICAgICAgY29uc3Qgc3R5bGUgPSB0aGlzLmN0eC5jYWxsYmFja0NhY2hlLmNhbGwobWFya2VyLml0ZW1TdHlsZXIsIHtcbiAgICAgICAgc2VyaWVzSWQ6IHRoaXMuaWQsXG4gICAgICAgIC4uLm1hcmtlclN0eWxlLFxuICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgIGRhdHVtOiBwYXJhbXMuZGF0dW0uZGF0dW1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG1lcmdlRGVmYXVsdHMoc3R5bGUsIG1hcmtlclN0eWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcmtlclN0eWxlO1xuICB9XG4gIHVwZGF0ZU1hcmtlclN0eWxlKG1hcmtlck5vZGUsIG1hcmtlciwgcGFyYW1zLCBkZWZhdWx0U3R5bGUgPSBtYXJrZXIuZ2V0U3R5bGUoKSwgeyBhcHBseVRyYW5zbGF0aW9uID0gdHJ1ZSwgc2VsZWN0ZWQgPSB0cnVlIH0gPSB7fSkge1xuICAgIGNvbnN0IHsgcG9pbnQgfSA9IHBhcmFtcy5kYXR1bTtcbiAgICBjb25zdCBhY3RpdmVTdHlsZSA9IHRoaXMuZ2V0TWFya2VyU3R5bGUobWFya2VyLCBwYXJhbXMsIGRlZmF1bHRTdHlsZSk7XG4gICAgY29uc3QgdmlzaWJsZSA9IHRoaXMudmlzaWJsZSAmJiBhY3RpdmVTdHlsZS5zaXplID4gMCAmJiBwb2ludCAmJiAhaXNOYU4ocG9pbnQueCkgJiYgIWlzTmFOKHBvaW50LnkpO1xuICAgIGlmIChhcHBseVRyYW5zbGF0aW9uKSB7XG4gICAgICBtYXJrZXJOb2RlLnNldFByb3BlcnRpZXMoeyB2aXNpYmxlLCAuLi5hY3RpdmVTdHlsZSwgdHJhbnNsYXRpb25YOiBwb2ludD8ueCwgdHJhbnNsYXRpb25ZOiBwb2ludD8ueSB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWFya2VyTm9kZS5zZXRQcm9wZXJ0aWVzKHsgdmlzaWJsZSwgLi4uYWN0aXZlU3R5bGUgfSk7XG4gICAgfVxuICAgIGlmICghc2VsZWN0ZWQpIHtcbiAgICAgIG1hcmtlck5vZGUuZmlsbE9wYWNpdHkgKj0gQ1JPU1NfRklMVEVSX01BUktFUl9GSUxMX09QQUNJVFlfRkFDVE9SO1xuICAgICAgbWFya2VyTm9kZS5zdHJva2VPcGFjaXR5ICo9IENST1NTX0ZJTFRFUl9NQVJLRVJfU1RST0tFX09QQUNJVFlfRkFDVE9SO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG1hcmtlci5zaGFwZSA9PT0gXCJmdW5jdGlvblwiICYmICFtYXJrZXJOb2RlLmRpcnR5UGF0aCkge1xuICAgICAgbWFya2VyTm9kZS5wYXRoLmNsZWFyKHRydWUpO1xuICAgICAgbWFya2VyTm9kZS51cGRhdGVQYXRoKCk7XG4gICAgICBtYXJrZXJOb2RlLmNoZWNrUGF0aERpcnR5KCk7XG4gICAgICBjb25zdCBiYiA9IG1hcmtlck5vZGUuZ2V0QkJveCgpO1xuICAgICAgaWYgKHBvaW50ICE9PSB2b2lkIDAgJiYgYmIuaXNGaW5pdGUoKSkge1xuICAgICAgICBjb25zdCBjZW50ZXIyID0gYmIuY29tcHV0ZUNlbnRlcigpO1xuICAgICAgICBjb25zdCBbZHgsIGR5XSA9IFtcInhcIiwgXCJ5XCJdLm1hcChcbiAgICAgICAgICAoa2V5KSA9PiAoYWN0aXZlU3R5bGUuc3Ryb2tlV2lkdGggPz8gMCkgKyBNYXRoLmFicyhjZW50ZXIyW2tleV0gLSBwb2ludFtrZXldKVxuICAgICAgICApO1xuICAgICAgICBjb25zdCBjdXN0b21TaXplID0gTWF0aC5tYXgoYmIud2lkdGggKyBkeCwgYmIuaGVpZ2h0ICsgZHkpO1xuICAgICAgICBwb2ludC5mb2N1c1NpemUgPSBjdXN0b21TaXplO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXRNaW5SZWN0cyhfd2lkdGgsIF9oZWlnaHQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZ2V0IG5vZGVEYXRhRGVwZW5kZW5jaWVzKCkge1xuICAgIHJldHVybiB0aGlzLl9ub2RlRGF0YURlcGVuZGVuY2llcyA/PyB7IHNlcmllc1JlY3RXaWR0aDogTmFOLCBzZXJpZXNSZWN0SGVpZ2h0OiBOYU4gfTtcbiAgfVxuICBjaGVja1Jlc2l6ZShuZXdTZXJpZXNSZWN0KSB7XG4gICAgY29uc3QgeyB3aWR0aDogc2VyaWVzUmVjdFdpZHRoLCBoZWlnaHQ6IHNlcmllc1JlY3RIZWlnaHQgfSA9IG5ld1Nlcmllc1JlY3QgPz8geyB3aWR0aDogTmFOLCBoZWlnaHQ6IE5hTiB9O1xuICAgIGNvbnN0IG5ld05vZGVEYXRhRGVwZW5kZW5jaWVzID0gbmV3U2VyaWVzUmVjdCA/IHsgc2VyaWVzUmVjdFdpZHRoLCBzZXJpZXNSZWN0SGVpZ2h0IH0gOiB2b2lkIDA7XG4gICAgY29uc3QgcmVzaXplID0ganNvbkRpZmYodGhpcy5ub2RlRGF0YURlcGVuZGVuY2llcywgbmV3Tm9kZURhdGFEZXBlbmRlbmNpZXMpICE9IG51bGw7XG4gICAgaWYgKHJlc2l6ZSkge1xuICAgICAgdGhpcy5fbm9kZURhdGFEZXBlbmRlbmNpZXMgPSBuZXdOb2RlRGF0YURlcGVuZGVuY2llcztcbiAgICAgIHRoaXMubWFya05vZGVEYXRhRGlydHkoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc2l6ZTtcbiAgfVxuICBwaWNrRm9jdXMoX29wdHMpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG59O1xuU2VyaWVzLmhpZ2hsaWdodGVkWkluZGV4ID0gMWUxMjtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEFjdGlvbk9uU2V0KHtcbiAgICBjaGFuZ2VWYWx1ZTogZnVuY3Rpb24obmV3VmFsLCBvbGRWYWwpIHtcbiAgICAgIHRoaXMub25TZXJpZXNHcm91cGluZ0NoYW5nZShvbGRWYWwsIG5ld1ZhbCk7XG4gICAgfVxuICB9KVxuXSwgU2VyaWVzLnByb3RvdHlwZSwgXCJzZXJpZXNHcm91cGluZ1wiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQva2V5Ym9hcmRVdGlsLnRzXG5mdW5jdGlvbiBjb21wdXRlQ2VudGVyKGJib3hPclBhdGgpIHtcbiAgaWYgKGJib3hPclBhdGggPT0gbnVsbClcbiAgICByZXR1cm47XG4gIGlmIChiYm94T3JQYXRoIGluc3RhbmNlb2YgQkJveCkge1xuICAgIHJldHVybiBiYm94T3JQYXRoLmNvbXB1dGVDZW50ZXIoKTtcbiAgfVxuICByZXR1cm4gVHJhbnNmb3JtYWJsZS50b0NhbnZhcyhiYm94T3JQYXRoKS5jb21wdXRlQ2VudGVyKCk7XG59XG5mdW5jdGlvbiBkcmF3UGlja2VkRm9jdXMoZm9jdXNJbmRpY2F0b3IsIHBpY2spIHtcbiAgY29uc3QgeyBib3VuZHMsIHNob3dGb2N1c0JveCB9ID0gcGljaztcbiAgaWYgKHNob3dGb2N1c0JveCkge1xuICAgIGZvY3VzSW5kaWNhdG9yPy51cGRhdGVCb3VuZHMoYm91bmRzKTtcbiAgfVxufVxuZnVuY3Rpb24gbWFrZUtleWJvYXJkUG9pbnRlckV2ZW50KGZvY3VzSW5kaWNhdG9yLCBwaWNrKSB7XG4gIGRyYXdQaWNrZWRGb2N1cyhmb2N1c0luZGljYXRvciwgcGljayk7XG4gIGNvbnN0IHsgeDogb2Zmc2V0WCwgeTogb2Zmc2V0WSB9ID0gY29tcHV0ZUNlbnRlcihwaWNrLmJvdW5kcykgPz8ge307XG4gIGlmIChvZmZzZXRYICE9PSB2b2lkIDAgJiYgb2Zmc2V0WSAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJrZXlib2FyZFwiLCBvZmZzZXRYLCBvZmZzZXRZIH07XG4gIH1cbiAgcmV0dXJuIHZvaWQgMDtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL3V0aWwudHNcbmZ1bmN0aW9uIGNvbnZlcnRWYWx1ZXNUb1NjYWxlQnlEZWZzKHtcbiAgZGVmcyxcbiAgdmFsdWVzLFxuICB4QXhpcyxcbiAgeUF4aXNcbn0pIHtcbiAgaWYgKCEoeEF4aXMgJiYgeUF4aXMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQXhlcyBtdXN0IGJlIGRlZmluZWRcIik7XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGZvciAoY29uc3QgW3NlYXJjaElkLCB7IGRlZiB9XSBvZiBkZWZzKSB7XG4gICAgaWYgKE9iamVjdC5oYXNPd24odmFsdWVzLCBzZWFyY2hJZCkpIHtcbiAgICAgIGNvbnN0IHsgc2NhbGU6IHNjYWxlMiB9ID0gZGVmLnR5cGUgPT09IFwia2V5XCIgPyB4QXhpcyA6IHlBeGlzO1xuICAgICAgcmVzdWx0W3NlYXJjaElkXSA9IE1hdGgucm91bmQoc2NhbGUyLmNvbnZlcnQodmFsdWVzW3NlYXJjaElkXSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGlja05vZGUoaW5wdXRTZXJpZXMsIHBvaW50LCBpbnRlbnQsIGV4YWN0TWF0Y2hPbmx5KSB7XG4gIGNvbnN0IHJldmVyc2VTZXJpZXMgPSBbLi4uaW5wdXRTZXJpZXNdLnJldmVyc2UoKTtcbiAgbGV0IHJlc3VsdDtcbiAgZm9yIChjb25zdCBzZXJpZXMgb2YgcmV2ZXJzZVNlcmllcykge1xuICAgIGlmICghc2VyaWVzLnZpc2libGUgfHwgIXNlcmllcy5yb290R3JvdXAudmlzaWJsZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHsgbWF0Y2gsIGRpc3RhbmNlOiBkaXN0YW5jZTMgfSA9IHNlcmllcy5waWNrTm9kZShwb2ludCwgaW50ZW50LCBleGFjdE1hdGNoT25seSkgPz8ge307XG4gICAgaWYgKCFtYXRjaCB8fCBkaXN0YW5jZTMgPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICghcmVzdWx0IHx8IHJlc3VsdC5kaXN0YW5jZSA+IGRpc3RhbmNlMykge1xuICAgICAgcmVzdWx0ID0geyBzZXJpZXMsIGRpc3RhbmNlOiBkaXN0YW5jZTMsIGRhdHVtOiBtYXRjaCB9O1xuICAgIH1cbiAgICBpZiAoZGlzdGFuY2UzID09PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL3Nlcmllc0FyZWFNYW5hZ2VyLnRzXG52YXIgU2VyaWVzQXJlYUFyaWFMYWJlbCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZWxlbWVudDIsIGlkKSB7XG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDI7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIGVsZW1lbnQyLmlkID0gaWQ7XG4gICAgZWxlbWVudDIuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIHNldEF0dHJpYnV0ZShlbGVtZW50Mi5wYXJlbnRFbGVtZW50LCBcImFyaWEtbGFiZWxsZWRieVwiLCBpZCk7XG4gIH1cbiAgbGF5b3V0Q29tcGxldGUoZXZlbnQpIHtcbiAgICB0aGlzLmVsZW1lbnQucGFyZW50RWxlbWVudC5zdHlsZS53aWR0aCA9IGAke2V2ZW50LmNoYXJ0LndpZHRofXB4YDtcbiAgICB0aGlzLmVsZW1lbnQucGFyZW50RWxlbWVudC5zdHlsZS5oZWlnaHQgPSBgJHtldmVudC5jaGFydC5oZWlnaHR9cHhgO1xuICB9XG4gIHNldCB0ZXh0KHRleHQpIHtcbiAgICB0aGlzLmVsZW1lbnQudGV4dENvbnRlbnQgPSB0ZXh0O1xuICB9XG59O1xudmFyIFNlcmllc0FyZWFNYW5hZ2VyID0gY2xhc3MgZXh0ZW5kcyBCYXNlTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGNoYXJ0KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmNoYXJ0ID0gY2hhcnQ7XG4gICAgdGhpcy5pZCA9IGNyZWF0ZUlkKHRoaXMpO1xuICAgIHRoaXMuc2VyaWVzID0gW107XG4gICAgdGhpcy5oaWdobGlnaHQgPSB7XG4gICAgICAvKiogTGFzdCByZWNlaXZlZCBldmVudCB0aGF0IHN0aWxsIG5lZWRzIHRvIGJlIGFwcGxpZWQuICovXG4gICAgICBwZW5kaW5nSG92ZXJFdmVudDogdm9pZCAwLFxuICAgICAgLyoqIExhc3QgYXBwbGllZCBldmVudC4gKi9cbiAgICAgIGFwcGxpZWRIb3ZlckV2ZW50OiB2b2lkIDAsXG4gICAgICAvKiogTGFzdCBhcHBsaWVkIGV2ZW50LCB3aGljaCBoYXMgYmVlbiB0ZW1wb3JhcmlseSBzdGFzaGVkIGR1cmluZyB0aGUgbWFpbiBjaGFydCB1cGRhdGUgY3ljbGUuICovXG4gICAgICBzdGFzaGVkSG92ZXJFdmVudDogdm9pZCAwXG4gICAgfTtcbiAgICB0aGlzLnRvb2x0aXAgPSB7XG4gICAgICBsYXN0SG92ZXI6IHZvaWQgMFxuICAgIH07XG4gICAgLyoqXG4gICAgICogQTExeSBSZXF1aXJlbWVudHMgZm9yIFRvb2x0aXAvSGlnaGxpZ2h0IChzZWUgQUctMTMwNTEgZm9yIGRldGFpbHMpOlxuICAgICAqXG4gICAgICogICAtICAgV2hlbiB0aGUgc2VyaWVzLWFyZWEgaXMgYmx1cnJlZCwgYWx3YXlzIHRoZSBtb3VzZSB0byB1cGRhdGUgdGhlIHRvb2x0aXAvaGlnaGxpZ2h0LlxuICAgICAqXG4gICAgICogICAtICAgV2hlbiB0aGUgc2VyaWVzLWFyZWEgcmVjZWl2ZXMgYSBgZm9jdXNgIGV2ZW50LCB1c2UgYDpmb2N1cy12aXNpYmxlYCB0byBndWVzcyB0aGUgaW5wdXQgZGV2aWNlLlxuICAgICAqICAgICAgICh0aGlzIGlzIGRlY2lkZWQgYnkgdGhlIGJyb3dzZXIpLlxuICAgICAqXG4gICAgICogICAtICAgRm9yIGtleWJvYXJkIHVzZXJzLCBgZm9jdXNgIGFuZCBga2V5ZG93bmAgZXZlbnRzIGFsd2F5cyB1cGRhdGVzICYgc2hvd3MgdGhlIHRvb2x0aXAvaGlnaGxpZ2h0IG9uXG4gICAgICogICAgICAgdGhlIGN1cnJlbnRseSAob3IgbmV3bHkpIGZvY3VzZWQgZGF0dW0uXG4gICAgICpcbiAgICAgKiAgIC0gICBGb3Iga2V5Ym9hcmQgdXNlcnMsIGBtb3VzZW1vdmVgIGV2ZW50cyB1cGRhdGUgdGhlIHRvb2x0aXAvaGlnaGxpZ2h0IGlmZiBgcGlja05vZGVgIGZpbmRzIGEgbWF0Y2hcbiAgICAgKiAgICAgICBmb3IgdGhlIG1vdXNlIGV2ZW50IG9mZnNldHMuXG4gICAgICovXG4gICAgdGhpcy5ob3ZlckRldmljZSA9IFwibW91c2VcIjtcbiAgICB0aGlzLmZvY3VzID0ge1xuICAgICAgc29ydGVkU2VyaWVzOiBbXSxcbiAgICAgIHNlcmllczogdm9pZCAwLFxuICAgICAgc2VyaWVzSW5kZXg6IDAsXG4gICAgICBkYXR1bUluZGV4OiAwLFxuICAgICAgZGF0dW06IHZvaWQgMFxuICAgIH07XG4gICAgdGhpcy5ob3ZlclNjaGVkdWxlciA9IGRlYm91bmNlZEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIGlmICghdGhpcy50b29sdGlwLmxhc3RIb3ZlciAmJiAhdGhpcy5oaWdobGlnaHQucGVuZGluZ0hvdmVyRXZlbnQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmICh0aGlzLmNoYXJ0LmdldFVwZGF0ZVR5cGUoKSA8PSA0IC8qIFNFUklFU19VUERBVEUgKi8pIHtcbiAgICAgICAgdGhpcy5ob3ZlclNjaGVkdWxlci5zY2hlZHVsZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5oaWdobGlnaHQucGVuZGluZ0hvdmVyRXZlbnQpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVIb3ZlckhpZ2hsaWdodChmYWxzZSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50b29sdGlwLmxhc3RIb3Zlcikge1xuICAgICAgICB0aGlzLmhhbmRsZUhvdmVyVG9vbHRpcCh0aGlzLnRvb2x0aXAubGFzdEhvdmVyLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3Qgc2VyaWVzUmVnaW9uID0gY2hhcnQuY3R4LnJlZ2lvbk1hbmFnZXIuZ2V0UmVnaW9uKFwic2VyaWVzXCIgLyogU0VSSUVTICovKTtcbiAgICBjb25zdCBob3Jpem9udGFsQXhlc1JlZ2lvbiA9IGNoYXJ0LmN0eC5yZWdpb25NYW5hZ2VyLmdldFJlZ2lvbihcImhvcml6b250YWwtYXhlc1wiIC8qIEhPUklaT05UQUxfQVhFUyAqLyk7XG4gICAgY29uc3QgdmVydGljYWxBeGVzUmVnaW9uID0gY2hhcnQuY3R4LnJlZ2lvbk1hbmFnZXIuZ2V0UmVnaW9uKFwidmVydGljYWwtYXhlc1wiIC8qIFZFUlRJQ0FMX0FYRVMgKi8pO1xuICAgIGNvbnN0IG1vdXNlTW92ZVN0YXRlcyA9IDMyIC8qIERlZmF1bHQgKi8gfCA4IC8qIEFubm90YXRpb25zICovIHwgMSAvKiBBbm5vdGF0aW9uc1NlbGVjdGVkICovO1xuICAgIGNvbnN0IGtleVN0YXRlID0gMzIgLyogRGVmYXVsdCAqLyB8IDIgLyogQW5pbWF0aW9uICovO1xuICAgIGNvbnN0IGxhYmVsRWwgPSBjaGFydC5jdHguZG9tTWFuYWdlci5hZGRDaGlsZChcInNlcmllcy1hcmVhXCIsIFwic2VyaWVzLWFyZWEtYXJpYS1sYWJlbFwiKTtcbiAgICB0aGlzLmFyaWFMYWJlbCA9IG5ldyBTZXJpZXNBcmVhQXJpYUxhYmVsKGxhYmVsRWwsIGAke3RoaXMuaWR9LWFyaWEtbGFiZWxgKTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMucHVzaChcbiAgICAgICgpID0+IGNoYXJ0LmN0eC5kb21NYW5hZ2VyLnJlbW92ZUNoaWxkKFwic2VyaWVzLWFyZWFcIiwgXCJzZXJpZXMtYXJlYS1hcmlhLWxhYmVsXCIpLFxuICAgICAgc2VyaWVzUmVnaW9uLmFkZExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgKGV2ZW50KSA9PiB0aGlzLm9uQ29udGV4dE1lbnUoZXZlbnQpLCA2MyAvKiBBbGwgKi8pLFxuICAgICAgc2VyaWVzUmVnaW9uLmFkZExpc3RlbmVyKFwiZHJhZ1wiLCAoZXZlbnQpID0+IHRoaXMub25Ib3Zlckxpa2VFdmVudChldmVudCksIG1vdXNlTW92ZVN0YXRlcyksXG4gICAgICBzZXJpZXNSZWdpb24uYWRkTGlzdGVuZXIoXCJob3ZlclwiLCAoZXZlbnQpID0+IHRoaXMub25Ib3ZlcihldmVudCksIG1vdXNlTW92ZVN0YXRlcyksXG4gICAgICBzZXJpZXNSZWdpb24uYWRkTGlzdGVuZXIoXCJsZWF2ZVwiLCAoKSA9PiB0aGlzLm9uTGVhdmUoKSwgbW91c2VNb3ZlU3RhdGVzKSxcbiAgICAgIGhvcml6b250YWxBeGVzUmVnaW9uLmFkZExpc3RlbmVyKFwiaG92ZXJcIiwgKGV2ZW50KSA9PiB0aGlzLm9uSG92ZXIoZXZlbnQpLCBtb3VzZU1vdmVTdGF0ZXMpLFxuICAgICAgaG9yaXpvbnRhbEF4ZXNSZWdpb24uYWRkTGlzdGVuZXIoXCJsZWF2ZVwiLCAoKSA9PiB0aGlzLm9uTGVhdmUoKSksXG4gICAgICB2ZXJ0aWNhbEF4ZXNSZWdpb24uYWRkTGlzdGVuZXIoXCJob3ZlclwiLCAoZXZlbnQpID0+IHRoaXMub25Ib3ZlcihldmVudCksIG1vdXNlTW92ZVN0YXRlcyksXG4gICAgICB2ZXJ0aWNhbEF4ZXNSZWdpb24uYWRkTGlzdGVuZXIoXCJsZWF2ZVwiLCAoKSA9PiB0aGlzLm9uTGVhdmUoKSksXG4gICAgICBjaGFydC5jdHguYW5pbWF0aW9uTWFuYWdlci5hZGRMaXN0ZW5lcihcImFuaW1hdGlvbi1zdGFydFwiLCAoKSA9PiB0aGlzLmNsZWFyQWxsKCkpLFxuICAgICAgY2hhcnQuY3R4LmRvbU1hbmFnZXIuYWRkTGlzdGVuZXIoXCJyZXNpemVcIiwgKCkgPT4gdGhpcy5jbGVhckFsbCgpKSxcbiAgICAgIGNoYXJ0LmN0eC5oaWdobGlnaHRNYW5hZ2VyLmFkZExpc3RlbmVyKFwiaGlnaGxpZ2h0LWNoYW5nZVwiLCAoZXZlbnQpID0+IHRoaXMuY2hhbmdlSGlnaGxpZ2h0RGF0dW0oZXZlbnQpKSxcbiAgICAgIGNoYXJ0LmN0eC5rZXlOYXZNYW5hZ2VyLmFkZExpc3RlbmVyKFwiYmx1clwiLCAoKSA9PiB0aGlzLm9uQmx1cigpKSxcbiAgICAgIGNoYXJ0LmN0eC5rZXlOYXZNYW5hZ2VyLmFkZExpc3RlbmVyKFwiZm9jdXNcIiwgKGV2ZW50KSA9PiB0aGlzLm9uRm9jdXMoZXZlbnQpLCBrZXlTdGF0ZSksXG4gICAgICBjaGFydC5jdHgua2V5TmF2TWFuYWdlci5hZGRMaXN0ZW5lcihcIm5hdi1ob3JpXCIsIChldmVudCkgPT4gdGhpcy5vbk5hdkhvcmkoZXZlbnQpLCBrZXlTdGF0ZSksXG4gICAgICBjaGFydC5jdHgua2V5TmF2TWFuYWdlci5hZGRMaXN0ZW5lcihcIm5hdi12ZXJ0XCIsIChldmVudCkgPT4gdGhpcy5vbk5hdlZlcnQoZXZlbnQpLCBrZXlTdGF0ZSksXG4gICAgICBjaGFydC5jdHgua2V5TmF2TWFuYWdlci5hZGRMaXN0ZW5lcihcInN1Ym1pdFwiLCAoZXZlbnQpID0+IHRoaXMub25TdWJtaXQoZXZlbnQpLCBrZXlTdGF0ZSksXG4gICAgICBjaGFydC5jdHgubGF5b3V0TWFuYWdlci5hZGRMaXN0ZW5lcihcImxheW91dDpjb21wbGV0ZVwiLCAoZXZlbnQpID0+IHRoaXMubGF5b3V0Q29tcGxldGUoZXZlbnQpKSxcbiAgICAgIGNoYXJ0LmN0eC5yZWdpb25NYW5hZ2VyLmxpc3RlbkFsbChcImNsaWNrXCIsIChldmVudCkgPT4gdGhpcy5vbkNsaWNrKGV2ZW50KSksXG4gICAgICBjaGFydC5jdHgucmVnaW9uTWFuYWdlci5saXN0ZW5BbGwoXCJkYmxjbGlja1wiLCAoZXZlbnQpID0+IHRoaXMub25DbGljayhldmVudCkpLFxuICAgICAgY2hhcnQuY3R4LnVwZGF0ZVNlcnZpY2UuYWRkTGlzdGVuZXIoXCJwcmUtc2NlbmUtcmVuZGVyXCIsICgpID0+IHRoaXMucHJlU2NlbmVSZW5kZXIoKSksXG4gICAgICBjaGFydC5jdHguem9vbU1hbmFnZXIuYWRkTGlzdGVuZXIoXCJ6b29tLWNoYW5nZVwiLCAoKSA9PiB0aGlzLmNsZWFyQWxsKCkpLFxuICAgICAgY2hhcnQuY3R4Lnpvb21NYW5hZ2VyLmFkZExpc3RlbmVyKFwiem9vbS1wYW4tc3RhcnRcIiwgKCkgPT4gdGhpcy5jbGVhckFsbCgpKVxuICAgICk7XG4gIH1cbiAgZGF0YUNoYW5nZWQoKSB7XG4gICAgdmFyIF9hO1xuICAgIChfYSA9IHRoaXMuaGlnaGxpZ2h0KS5zdGFzaGVkSG92ZXJFdmVudCA/PyAoX2Euc3Rhc2hlZEhvdmVyRXZlbnQgPSB0aGlzLmhpZ2hsaWdodC5hcHBsaWVkSG92ZXJFdmVudCk7XG4gICAgdGhpcy5jaGFydC5jdHgudG9vbHRpcE1hbmFnZXIucmVtb3ZlVG9vbHRpcCh0aGlzLmlkKTtcbiAgICB0aGlzLmNoYXJ0LmN0eC5mb2N1c0luZGljYXRvci51cGRhdGVCb3VuZHModm9pZCAwKTtcbiAgICB0aGlzLmNsZWFySGlnaGxpZ2h0KCk7XG4gIH1cbiAgcHJlU2NlbmVSZW5kZXIoKSB7XG4gICAgdGhpcy5yZWZyZXNoRm9jdXMoKTtcbiAgICBpZiAodGhpcy5oaWdobGlnaHQuc3Rhc2hlZEhvdmVyRXZlbnQgIT0gbnVsbCkge1xuICAgICAgdGhpcy5oaWdobGlnaHQucGVuZGluZ0hvdmVyRXZlbnQgPSB0aGlzLmhpZ2hsaWdodC5zdGFzaGVkSG92ZXJFdmVudDtcbiAgICAgIHRoaXMuaGlnaGxpZ2h0LnN0YXNoZWRIb3ZlckV2ZW50ID0gdm9pZCAwO1xuICAgICAgdGhpcy5oYW5kbGVIb3ZlckhpZ2hsaWdodCh0cnVlKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudG9vbHRpcC5sYXN0SG92ZXIgIT0gbnVsbCkge1xuICAgICAgdGhpcy5oYW5kbGVIb3ZlclRvb2x0aXAodGhpcy50b29sdGlwLmxhc3RIb3ZlciwgdHJ1ZSk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZSh0eXBlLCBvcHRzKSB7XG4gICAgdGhpcy5jaGFydC5jdHgudXBkYXRlU2VydmljZS51cGRhdGUodHlwZSwgb3B0cyk7XG4gIH1cbiAgc2VyaWVzQ2hhbmdlZChzZXJpZXMpIHtcbiAgICB0aGlzLmZvY3VzLnNvcnRlZFNlcmllcyA9IFsuLi5zZXJpZXNdLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgIGxldCBmcEEgPSBhLnByb3BlcnRpZXMuZm9jdXNQcmlvcml0eSA/PyBJbmZpbml0eTtcbiAgICAgIGxldCBmcEIgPSBiLnByb3BlcnRpZXMuZm9jdXNQcmlvcml0eSA/PyBJbmZpbml0eTtcbiAgICAgIGlmIChmcEEgPT09IGZwQikge1xuICAgICAgICBbZnBBLCBmcEJdID0gW2EuX2RlY2xhcmF0aW9uT3JkZXIsIGIuX2RlY2xhcmF0aW9uT3JkZXJdO1xuICAgICAgfVxuICAgICAgaWYgKGZwQSA8IGZwQikge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9IGVsc2UgaWYgKGZwQSA+IGZwQikge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH0pO1xuICAgIHRoaXMuc2VyaWVzID0gc2VyaWVzO1xuICB9XG4gIGxheW91dENvbXBsZXRlKGV2ZW50KSB7XG4gICAgdGhpcy5zZXJpZXNSZWN0ID0gZXZlbnQuc2VyaWVzLnJlY3Q7XG4gICAgdGhpcy5ob3ZlclJlY3QgPSBldmVudC5zZXJpZXMucGFkZGVkUmVjdDtcbiAgICB0aGlzLmFyaWFMYWJlbC5sYXlvdXRDb21wbGV0ZShldmVudCk7XG4gIH1cbiAgb25Db250ZXh0TWVudShldmVudCkge1xuICAgIGNvbnN0IHsgRGVmYXVsdDogRGVmYXVsdDIsIENvbnRleHRNZW51IH0gPSBJbnRlcmFjdGlvblN0YXRlO1xuICAgIGxldCBwaWNrZWROb2RlO1xuICAgIGxldCBwb3NpdGlvbjtcbiAgICBpZiAodGhpcy5jaGFydC5jdHguZm9jdXNJbmRpY2F0b3IuaXNGb2N1c1Zpc2libGUoKSkge1xuICAgICAgcGlja2VkTm9kZSA9IHRoaXMuY2hhcnQuY3R4LmhpZ2hsaWdodE1hbmFnZXIuZ2V0QWN0aXZlSGlnaGxpZ2h0KCk7XG4gICAgICBpZiAocGlja2VkTm9kZSAmJiB0aGlzLnNlcmllc1JlY3QgJiYgcGlja2VkTm9kZS5taWRQb2ludCkge1xuICAgICAgICBwb3NpdGlvbiA9IFRyYW5zZm9ybWFibGUudG9DYW52YXNQb2ludChcbiAgICAgICAgICBwaWNrZWROb2RlLnNlcmllcy5jb250ZW50R3JvdXAsXG4gICAgICAgICAgcGlja2VkTm9kZS5taWRQb2ludC54LFxuICAgICAgICAgIHBpY2tlZE5vZGUubWlkUG9pbnQueVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5jaGFydC5jdHguaW50ZXJhY3Rpb25NYW5hZ2VyLmdldFN0YXRlKCkgJiAoRGVmYXVsdDIgfCBDb250ZXh0TWVudSkpIHtcbiAgICAgIGNvbnN0IG1hdGNoID0gcGlja05vZGUodGhpcy5zZXJpZXMsIHsgeDogZXZlbnQucmVnaW9uT2Zmc2V0WCwgeTogZXZlbnQucmVnaW9uT2Zmc2V0WSB9LCBcImNvbnRleHQtbWVudVwiKTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICB0aGlzLmNoYXJ0LmN0eC5oaWdobGlnaHRNYW5hZ2VyLnVwZGF0ZUhpZ2hsaWdodCh0aGlzLmlkKTtcbiAgICAgICAgcGlja2VkTm9kZSA9IG1hdGNoLmRhdHVtO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNsZWFyQWxsKCk7XG4gICAgdGhpcy5jaGFydC5jdHguY29udGV4dE1lbnVSZWdpc3RyeS5kaXNwYXRjaENvbnRleHQoXCJzZXJpZXNcIiwgZXZlbnQsIHsgcGlja2VkTm9kZSB9LCBwb3NpdGlvbik7XG4gIH1cbiAgb25MZWF2ZSgpIHtcbiAgICB0aGlzLmNoYXJ0LmN0eC5jdXJzb3JNYW5hZ2VyLnVwZGF0ZUN1cnNvcih0aGlzLmlkKTtcbiAgICBpZiAoIXRoaXMuY2hhcnQuY3R4LmZvY3VzSW5kaWNhdG9yLmlzRm9jdXNWaXNpYmxlKCkpXG4gICAgICB0aGlzLmNsZWFyQWxsKCk7XG4gIH1cbiAgb25Ib3ZlcihldmVudCkge1xuICAgIHRoaXMuaG92ZXJEZXZpY2UgPSBcIm1vdXNlXCI7XG4gICAgdGhpcy5vbkhvdmVyTGlrZUV2ZW50KGV2ZW50KTtcbiAgfVxuICBvbkhvdmVyTGlrZUV2ZW50KGV2ZW50KSB7XG4gICAgaWYgKGV4Y2x1ZGVzVHlwZShldmVudCwgXCJkcmFnXCIpKSB7XG4gICAgICB0aGlzLnRvb2x0aXAubGFzdEhvdmVyID0gZXZlbnQ7XG4gICAgfVxuICAgIHRoaXMuaGlnaGxpZ2h0LnBlbmRpbmdIb3ZlckV2ZW50ID0gZXZlbnQ7XG4gICAgdGhpcy5ob3ZlclNjaGVkdWxlci5zY2hlZHVsZSgpO1xuICAgIGlmICh0aGlzLmNoYXJ0LmN0eC5pbnRlcmFjdGlvbk1hbmFnZXIuZ2V0U3RhdGUoKSA9PT0gMzIgLyogRGVmYXVsdCAqLykge1xuICAgICAgY29uc3QgeyByZWdpb25PZmZzZXRYLCByZWdpb25PZmZzZXRZIH0gPSBldmVudDtcbiAgICAgIGNvbnN0IGZvdW5kID0gcGlja05vZGUodGhpcy5zZXJpZXMsIHsgeDogcmVnaW9uT2Zmc2V0WCwgeTogcmVnaW9uT2Zmc2V0WSB9LCBcImV2ZW50XCIpO1xuICAgICAgaWYgKGZvdW5kPy5zZXJpZXMuaGFzRXZlbnRMaXN0ZW5lcihcIm5vZGVDbGlja1wiKSB8fCBmb3VuZD8uc2VyaWVzLmhhc0V2ZW50TGlzdGVuZXIoXCJub2RlRG91YmxlQ2xpY2tcIikpIHtcbiAgICAgICAgdGhpcy5jaGFydC5jdHguY3Vyc29yTWFuYWdlci51cGRhdGVDdXJzb3IodGhpcy5pZCwgXCJwb2ludGVyXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jaGFydC5jdHguY3Vyc29yTWFuYWdlci51cGRhdGVDdXJzb3IodGhpcy5pZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIG9uQ2xpY2soZXZlbnQpIHtcbiAgICB0aGlzLmhvdmVyRGV2aWNlID0gXCJtb3VzZVwiO1xuICAgIHRoaXMub25Ib3Zlckxpa2VFdmVudChldmVudCk7XG4gICAgaWYgKHRoaXMuc2VyaWVzUmVjdD8uY29udGFpbnNQb2ludChldmVudC5vZmZzZXRYLCBldmVudC5vZmZzZXRZKSAmJiB0aGlzLmNoZWNrU2VyaWVzTm9kZUNsaWNrKGV2ZW50KSkge1xuICAgICAgdGhpcy51cGRhdGUoNCAvKiBTRVJJRVNfVVBEQVRFICovKTtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5ld0V2ZW50ID0geyB0eXBlOiBldmVudC50eXBlID09PSBcImNsaWNrXCIgPyBcImNsaWNrXCIgOiBcImRvdWJsZUNsaWNrXCIsIGV2ZW50OiBldmVudC5zb3VyY2VFdmVudCB9O1xuICAgIHRoaXMuY2hhcnQuZmlyZUV2ZW50KG5ld0V2ZW50KTtcbiAgfVxuICBvbkZvY3VzKGV2ZW50KSB7XG4gICAgdGhpcy5ob3ZlckRldmljZSA9IHRoaXMuY2hhcnQuY3R4LmZvY3VzSW5kaWNhdG9yLmlzRm9jdXNWaXNpYmxlKCkgPyBcImtleWJvYXJkXCIgOiBcIm1vdXNlXCI7XG4gICAgdGhpcy5oYW5kbGVGb2N1cygwLCAwKTtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG4gIG9uQmx1cigpIHtcbiAgICB0aGlzLmhvdmVyRGV2aWNlID0gXCJtb3VzZVwiO1xuICAgIHRoaXMuY2xlYXJBbGwoKTtcbiAgfVxuICBvbk5hdlZlcnQoZXZlbnQpIHtcbiAgICB0aGlzLmhvdmVyRGV2aWNlID0gXCJrZXlib2FyZFwiO1xuICAgIHRoaXMuZm9jdXMuc2VyaWVzSW5kZXggKz0gZXZlbnQuZGVsdGE7XG4gICAgdGhpcy5oYW5kbGVGb2N1cyhldmVudC5kZWx0YSwgMCk7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICBvbk5hdkhvcmkoZXZlbnQpIHtcbiAgICB0aGlzLmhvdmVyRGV2aWNlID0gXCJrZXlib2FyZFwiO1xuICAgIHRoaXMuZm9jdXMuZGF0dW1JbmRleCArPSBldmVudC5kZWx0YTtcbiAgICB0aGlzLmhhbmRsZUZvY3VzKDAsIGV2ZW50LmRlbHRhKTtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG4gIG9uU3VibWl0KGV2ZW50KSB7XG4gICAgY29uc3QgeyBzZXJpZXMsIGRhdHVtIH0gPSB0aGlzLmZvY3VzO1xuICAgIGNvbnN0IHNvdXJjZUV2ZW50ID0gZXZlbnQuc291cmNlRXZlbnQuc291cmNlRXZlbnQ7XG4gICAgaWYgKHNlcmllcyAhPT0gdm9pZCAwICYmIGRhdHVtICE9PSB2b2lkIDApIHtcbiAgICAgIHNlcmllcy5maXJlTm9kZUNsaWNrRXZlbnQoc291cmNlRXZlbnQsIGRhdHVtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jaGFydC5maXJlRXZlbnQoe1xuICAgICAgICB0eXBlOiBcImNsaWNrXCIsXG4gICAgICAgIGV2ZW50OiBzb3VyY2VFdmVudFxuICAgICAgfSk7XG4gICAgfVxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgY2hlY2tTZXJpZXNOb2RlQ2xpY2soZXZlbnQpIHtcbiAgICBsZXQgcG9pbnQgPSB7IHg6IGV2ZW50LnJlZ2lvbk9mZnNldFgsIHk6IGV2ZW50LnJlZ2lvbk9mZnNldFkgfTtcbiAgICBpZiAoZXZlbnQucmVnaW9uICE9PSBcInNlcmllc1wiKSB7XG4gICAgICBwb2ludCA9IFRyYW5zZm9ybWFibGUuZnJvbUNhbnZhc1BvaW50KHRoaXMuY2hhcnQuc2VyaWVzUm9vdCwgZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHBpY2tOb2RlKHRoaXMuc2VyaWVzLCBwb2ludCwgXCJldmVudFwiKTtcbiAgICBpZiAocmVzdWx0ID09IG51bGwpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIikge1xuICAgICAgcmVzdWx0LnNlcmllcy5maXJlTm9kZUNsaWNrRXZlbnQoZXZlbnQuc291cmNlRXZlbnQsIHJlc3VsdC5kYXR1bSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGV2ZW50LnR5cGUgPT09IFwiZGJsY2xpY2tcIikge1xuICAgICAgZXZlbnQucHJldmVudFpvb21EYmxDbGljayA9IHJlc3VsdC5kaXN0YW5jZSA9PT0gMDtcbiAgICAgIHJlc3VsdC5zZXJpZXMuZmlyZU5vZGVEb3VibGVDbGlja0V2ZW50KGV2ZW50LnNvdXJjZUV2ZW50LCByZXN1bHQuZGF0dW0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZWZyZXNoRm9jdXMoKSB7XG4gICAgaWYgKHRoaXMuY2hhcnQuY3R4LmZvY3VzSW5kaWNhdG9yLmlzRm9jdXNWaXNpYmxlKCkpIHtcbiAgICAgIHRoaXMuaGFuZGxlU2VyaWVzRm9jdXMoMCwgMCk7XG4gICAgfVxuICB9XG4gIGhhbmRsZUZvY3VzKHNlcmllc0luZGV4RGVsdGEsIGRhdHVtSW5kZXhEZWx0YSkge1xuICAgIGNvbnN0IG92ZXJsYXlGb2N1cyA9IHRoaXMuY2hhcnQub3ZlcmxheXMuZ2V0Rm9jdXNJbmZvKHRoaXMuY2hhcnQuY3R4LmxvY2FsZU1hbmFnZXIpO1xuICAgIGlmIChvdmVybGF5Rm9jdXMgPT0gbnVsbCkge1xuICAgICAgdGhpcy5oYW5kbGVTZXJpZXNGb2N1cyhzZXJpZXNJbmRleERlbHRhLCBkYXR1bUluZGV4RGVsdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNoYXJ0LmN0eC5mb2N1c0luZGljYXRvci51cGRhdGVCb3VuZHMob3ZlcmxheUZvY3VzLnJlY3QpO1xuICAgIH1cbiAgfVxuICBoYW5kbGVTZXJpZXNGb2N1cyhvdGhlckluZGV4RGVsdGEsIGRhdHVtSW5kZXhEZWx0YSkge1xuICAgIGlmICh0aGlzLmNoYXJ0LmNoYXJ0VHlwZSA9PT0gXCJoaWVyYXJjaHlcIikge1xuICAgICAgdGhpcy5oYW5kbGVIaWVyYXJjaHlTZXJpZXNGb2N1cyhvdGhlckluZGV4RGVsdGEsIGRhdHVtSW5kZXhEZWx0YSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgZm9jdXMsIHNlcmllc1JlY3QgfSA9IHRoaXM7XG4gICAgY29uc3QgdmlzaWJsZVNlcmllcyA9IGZvY3VzLnNvcnRlZFNlcmllcy5maWx0ZXIoKHMpID0+IHMudmlzaWJsZSk7XG4gICAgaWYgKHZpc2libGVTZXJpZXMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuO1xuICAgIGZvY3VzLnNlcmllc0luZGV4ID0gY2xhbXAoMCwgZm9jdXMuc2VyaWVzSW5kZXgsIHZpc2libGVTZXJpZXMubGVuZ3RoIC0gMSk7XG4gICAgZm9jdXMuc2VyaWVzID0gdmlzaWJsZVNlcmllc1tmb2N1cy5zZXJpZXNJbmRleF07XG4gICAgY29uc3QgeyBkYXR1bUluZGV4LCBzZXJpZXNJbmRleDogb3RoZXJJbmRleCB9ID0gZm9jdXM7XG4gICAgY29uc3QgcGljayA9IGZvY3VzLnNlcmllcy5waWNrRm9jdXMoeyBkYXR1bUluZGV4LCBkYXR1bUluZGV4RGVsdGEsIG90aGVySW5kZXgsIG90aGVySW5kZXhEZWx0YSwgc2VyaWVzUmVjdCB9KTtcbiAgICB0aGlzLnVwZGF0ZVBpY2tlZEZvY3VzKHBpY2spO1xuICB9XG4gIGhhbmRsZUhpZXJhcmNoeVNlcmllc0ZvY3VzKG90aGVySW5kZXhEZWx0YSwgZGF0dW1JbmRleERlbHRhKSB7XG4gICAgdGhpcy5mb2N1cy5zZXJpZXMgPSB0aGlzLmZvY3VzLnNvcnRlZFNlcmllc1swXTtcbiAgICBjb25zdCB7XG4gICAgICBmb2N1czogeyBzZXJpZXMsIHNlcmllc0luZGV4OiBvdGhlckluZGV4LCBkYXR1bUluZGV4IH0sXG4gICAgICBzZXJpZXNSZWN0XG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKHNlcmllcyA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHBpY2sgPSBzZXJpZXMucGlja0ZvY3VzKHsgZGF0dW1JbmRleCwgZGF0dW1JbmRleERlbHRhLCBvdGhlckluZGV4LCBvdGhlckluZGV4RGVsdGEsIHNlcmllc1JlY3QgfSk7XG4gICAgdGhpcy51cGRhdGVQaWNrZWRGb2N1cyhwaWNrKTtcbiAgfVxuICB1cGRhdGVQaWNrZWRGb2N1cyhwaWNrKSB7XG4gICAgY29uc3QgeyBmb2N1cyB9ID0gdGhpcztcbiAgICBpZiAocGljayA9PT0gdm9pZCAwIHx8IGZvY3VzLnNlcmllcyA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgZGF0dW0sIGRhdHVtSW5kZXggfSA9IHBpY2s7XG4gICAgZm9jdXMuZGF0dW1JbmRleCA9IGRhdHVtSW5kZXg7XG4gICAgZm9jdXMuZGF0dW0gPSBkYXR1bTtcbiAgICBpZiAodGhpcy5jaGFydC5jdHguZm9jdXNJbmRpY2F0b3IuaXNGb2N1c1Zpc2libGUoKSkge1xuICAgICAgdGhpcy5jaGFydC5jdHguYW5pbWF0aW9uTWFuYWdlci5yZXNldCgpO1xuICAgIH1cbiAgICBjb25zdCBrZXlib2FyZEV2ZW50ID0gbWFrZUtleWJvYXJkUG9pbnRlckV2ZW50KHRoaXMuY2hhcnQuY3R4LmZvY3VzSW5kaWNhdG9yLCBwaWNrKTtcbiAgICBpZiAoa2V5Ym9hcmRFdmVudCAhPT0gdm9pZCAwICYmIHRoaXMuaG92ZXJEZXZpY2UgPT09IFwia2V5Ym9hcmRcIikge1xuICAgICAgdGhpcy50b29sdGlwLmxhc3RIb3ZlciA9IHZvaWQgMDtcbiAgICAgIHRoaXMuaGlnaGxpZ2h0LmFwcGxpZWRIb3ZlckV2ZW50ID0gdm9pZCAwO1xuICAgICAgdGhpcy5oaWdobGlnaHQucGVuZGluZ0hvdmVyRXZlbnQgPSB2b2lkIDA7XG4gICAgICB0aGlzLmhpZ2hsaWdodC5zdGFzaGVkSG92ZXJFdmVudCA9IHZvaWQgMDtcbiAgICAgIGNvbnN0IGh0bWwgPSBmb2N1cy5zZXJpZXMuZ2V0VG9vbHRpcEh0bWwoZGF0dW0pO1xuICAgICAgY29uc3QgbWV0YSA9IFRvb2x0aXBNYW5hZ2VyLm1ha2VUb29sdGlwTWV0YShrZXlib2FyZEV2ZW50LCBkYXR1bSk7XG4gICAgICB0aGlzLmNoYXJ0LmN0eC5oaWdobGlnaHRNYW5hZ2VyLnVwZGF0ZUhpZ2hsaWdodCh0aGlzLmlkLCBkYXR1bSk7XG4gICAgICB0aGlzLmNoYXJ0LmN0eC50b29sdGlwTWFuYWdlci51cGRhdGVUb29sdGlwKHRoaXMuaWQsIG1ldGEsIGh0bWwpO1xuICAgICAgdGhpcy5hcmlhTGFiZWwudGV4dCA9IHRoaXMuZ2V0RGF0dW1BcmlhVGV4dChkYXR1bSwgaHRtbCk7XG4gICAgfVxuICB9XG4gIGdldERhdHVtQXJpYVRleHQoZGF0dW0sIGh0bWwpIHtcbiAgICBjb25zdCBkZXNjcmlwdGlvbiA9IGh0bWwuYXJpYUxhYmVsO1xuICAgIHJldHVybiB0aGlzLmNoYXJ0LmN0eC5sb2NhbGVNYW5hZ2VyLnQoXCJhcmlhQW5ub3VuY2VIb3ZlckRhdHVtXCIsIHtcbiAgICAgIGRhdHVtOiBkYXR1bS5zZXJpZXMuZ2V0RGF0dW1BcmlhVGV4dD8uKGRhdHVtLCBkZXNjcmlwdGlvbikgPz8gZGVzY3JpcHRpb25cbiAgICB9KTtcbiAgfVxuICBjbGVhckhpZ2hsaWdodCgpIHtcbiAgICB0aGlzLmhpZ2hsaWdodC5wZW5kaW5nSG92ZXJFdmVudCA9IHZvaWQgMDtcbiAgICB0aGlzLmhpZ2hsaWdodC5hcHBsaWVkSG92ZXJFdmVudCA9IHZvaWQgMDtcbiAgICB0aGlzLmNoYXJ0LmN0eC5oaWdobGlnaHRNYW5hZ2VyLnVwZGF0ZUhpZ2hsaWdodCh0aGlzLmlkKTtcbiAgfVxuICBjbGVhclRvb2x0aXAoKSB7XG4gICAgdGhpcy5jaGFydC5jdHgudG9vbHRpcE1hbmFnZXIucmVtb3ZlVG9vbHRpcCh0aGlzLmlkKTtcbiAgICB0aGlzLnRvb2x0aXAubGFzdEhvdmVyID0gdm9pZCAwO1xuICB9XG4gIGNsZWFyQWxsKCkge1xuICAgIHRoaXMuY2xlYXJIaWdobGlnaHQoKTtcbiAgICB0aGlzLmNsZWFyVG9vbHRpcCgpO1xuICAgIHRoaXMuY2hhcnQuY3R4LmZvY3VzSW5kaWNhdG9yLnVwZGF0ZUJvdW5kcyh2b2lkIDApO1xuICB9XG4gIGhhbmRsZUhvdmVySGlnaGxpZ2h0KHJlZGlzcGxheSkge1xuICAgIHRoaXMuaGlnaGxpZ2h0LmFwcGxpZWRIb3ZlckV2ZW50ID0gdGhpcy5oaWdobGlnaHQucGVuZGluZ0hvdmVyRXZlbnQ7XG4gICAgdGhpcy5oaWdobGlnaHQucGVuZGluZ0hvdmVyRXZlbnQgPSB2b2lkIDA7XG4gICAgY29uc3QgZXZlbnQgPSB0aGlzLmhpZ2hsaWdodC5hcHBsaWVkSG92ZXJFdmVudDtcbiAgICBpZiAoIWV2ZW50KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5jaGFydC5jdHguaW50ZXJhY3Rpb25NYW5hZ2VyLmdldFN0YXRlKCk7XG4gICAgaWYgKHN0YXRlICE9PSAzMiAvKiBEZWZhdWx0ICovICYmIHN0YXRlICE9PSA4IC8qIEFubm90YXRpb25zICovICYmIHN0YXRlICE9PSAxIC8qIEFubm90YXRpb25zU2VsZWN0ZWQgKi8pXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBvZmZzZXRYLCBvZmZzZXRZIH0gPSBldmVudDtcbiAgICBpZiAocmVkaXNwbGF5ID8gdGhpcy5jaGFydC5jdHguYW5pbWF0aW9uTWFuYWdlci5pc0FjdGl2ZSgpIDogIXRoaXMuaG92ZXJSZWN0Py5jb250YWluc1BvaW50KG9mZnNldFgsIG9mZnNldFkpKSB7XG4gICAgICB0aGlzLmNsZWFySGlnaGxpZ2h0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBwaWNrQ29vcmRzID0geyB4OiBldmVudC5yZWdpb25PZmZzZXRYLCB5OiBldmVudC5yZWdpb25PZmZzZXRZIH07XG4gICAgaWYgKGV2ZW50LnJlZ2lvbiAhPT0gXCJzZXJpZXNcIikge1xuICAgICAgcGlja0Nvb3JkcyA9IFRyYW5zZm9ybWFibGUuZnJvbUNhbnZhc1BvaW50KHRoaXMuY2hhcnQuc2VyaWVzUm9vdCwgb2Zmc2V0WCwgb2Zmc2V0WSk7XG4gICAgfVxuICAgIGNvbnN0IHsgcmFuZ2U6IHJhbmdlMyB9ID0gdGhpcy5jaGFydC5oaWdobGlnaHQ7XG4gICAgY29uc3QgaW50ZW50ID0gcmFuZ2UzID09PSBcInRvb2x0aXBcIiA/IFwiaGlnaGxpZ2h0LXRvb2x0aXBcIiA6IFwiaGlnaGxpZ2h0XCI7XG4gICAgY29uc3QgZm91bmQgPSBwaWNrTm9kZSh0aGlzLnNlcmllcywgcGlja0Nvb3JkcywgaW50ZW50KTtcbiAgICBpZiAoZm91bmQpIHtcbiAgICAgIHRoaXMuY2hhcnQuY3R4LmhpZ2hsaWdodE1hbmFnZXIudXBkYXRlSGlnaGxpZ2h0KHRoaXMuaWQsIGZvdW5kLmRhdHVtKTtcbiAgICAgIHRoaXMuaG92ZXJEZXZpY2UgPSBcIm1vdXNlXCI7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY2hhcnQuY3R4LmhpZ2hsaWdodE1hbmFnZXIudXBkYXRlSGlnaGxpZ2h0KHRoaXMuaWQpO1xuICB9XG4gIGhhbmRsZUhvdmVyVG9vbHRpcChldmVudCwgcmVkaXNwbGF5KSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLmNoYXJ0LmN0eC5pbnRlcmFjdGlvbk1hbmFnZXIuZ2V0U3RhdGUoKTtcbiAgICBpZiAoc3RhdGUgIT09IDMyIC8qIERlZmF1bHQgKi8gJiYgc3RhdGUgIT09IDggLyogQW5ub3RhdGlvbnMgKi8gJiYgc3RhdGUgIT09IDEgLyogQW5ub3RhdGlvbnNTZWxlY3RlZCAqLylcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IG9mZnNldFgsIG9mZnNldFksIHRhcmdldEVsZW1lbnQsIHJlZ2lvbk9mZnNldFgsIHJlZ2lvbk9mZnNldFkgfSA9IGV2ZW50O1xuICAgIGlmIChyZWRpc3BsYXkgPyB0aGlzLmNoYXJ0LmN0eC5hbmltYXRpb25NYW5hZ2VyLmlzQWN0aXZlKCkgOiAhdGhpcy5ob3ZlclJlY3Q/LmNvbnRhaW5zUG9pbnQob2Zmc2V0WCwgb2Zmc2V0WSkpIHtcbiAgICAgIGlmICh0aGlzLmhvdmVyRGV2aWNlID09IFwibW91c2VcIilcbiAgICAgICAgdGhpcy5jbGVhclRvb2x0aXAoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRhcmdldEVsZW1lbnQgJiYgdGhpcy5jaGFydC50b29sdGlwLmludGVyYWN0aXZlICYmIHRoaXMuY2hhcnQuY3R4LmRvbU1hbmFnZXIuaXNNYW5hZ2VkQ2hpbGRET01FbGVtZW50KHRhcmdldEVsZW1lbnQsIFwiY2FudmFzLW92ZXJsYXlcIiwgREVGQVVMVF9UT09MVElQX0NMQVNTKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgcGlja0Nvb3JkcyA9IHsgeDogcmVnaW9uT2Zmc2V0WCwgeTogcmVnaW9uT2Zmc2V0WSB9O1xuICAgIGlmIChldmVudC5yZWdpb24gIT09IFwic2VyaWVzXCIpIHtcbiAgICAgIHBpY2tDb29yZHMgPSBUcmFuc2Zvcm1hYmxlLmZyb21DYW52YXNQb2ludCh0aGlzLmNoYXJ0LnNlcmllc1Jvb3QsIG9mZnNldFgsIG9mZnNldFkpO1xuICAgIH1cbiAgICBjb25zdCBwaWNrID0gcGlja05vZGUodGhpcy5zZXJpZXMsIHBpY2tDb29yZHMsIFwidG9vbHRpcFwiKTtcbiAgICBpZiAoIXBpY2spIHtcbiAgICAgIGlmICh0aGlzLmhvdmVyRGV2aWNlID09IFwibW91c2VcIilcbiAgICAgICAgdGhpcy5jbGVhclRvb2x0aXAoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5ob3ZlckRldmljZSA9IFwibW91c2VcIjtcbiAgICBjb25zdCBodG1sID0gcGljay5zZXJpZXMuZ2V0VG9vbHRpcEh0bWwocGljay5kYXR1bSk7XG4gICAgY29uc3QgdG9vbHRpcEVuYWJsZWQgPSB0aGlzLmNoYXJ0LnRvb2x0aXAuZW5hYmxlZCAmJiBwaWNrLnNlcmllcy50b29sdGlwRW5hYmxlZDtcbiAgICBjb25zdCBzaG91bGRVcGRhdGVUb29sdGlwID0gdG9vbHRpcEVuYWJsZWQgJiYgaHRtbCAhPSBudWxsO1xuICAgIGlmIChzaG91bGRVcGRhdGVUb29sdGlwKSB7XG4gICAgICBjb25zdCBtZXRhID0gVG9vbHRpcE1hbmFnZXIubWFrZVRvb2x0aXBNZXRhKGV2ZW50LCBwaWNrLmRhdHVtKTtcbiAgICAgIHRoaXMuY2hhcnQuY3R4LnRvb2x0aXBNYW5hZ2VyLnVwZGF0ZVRvb2x0aXAodGhpcy5pZCwgbWV0YSwgaHRtbCk7XG4gICAgfVxuICB9XG4gIGNoYW5nZUhpZ2hsaWdodERhdHVtKGV2ZW50KSB7XG4gICAgY29uc3Qgc2VyaWVzVG9VcGRhdGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGNvbnN0IHsgc2VyaWVzOiBuZXdTZXJpZXMgPSB2b2lkIDAsIGRhdHVtOiBuZXdEYXR1bSB9ID0gZXZlbnQuY3VycmVudEhpZ2hsaWdodCA/PyB7fTtcbiAgICBjb25zdCB7IHNlcmllczogbGFzdFNlcmllcyA9IHZvaWQgMCwgZGF0dW06IGxhc3REYXR1bSB9ID0gZXZlbnQucHJldmlvdXNIaWdobGlnaHQgPz8ge307XG4gICAgaWYgKGxhc3RTZXJpZXMpIHtcbiAgICAgIHNlcmllc1RvVXBkYXRlLmFkZChsYXN0U2VyaWVzKTtcbiAgICB9XG4gICAgaWYgKG5ld1Nlcmllcykge1xuICAgICAgc2VyaWVzVG9VcGRhdGUuYWRkKG5ld1Nlcmllcyk7XG4gICAgfVxuICAgIGlmIChsYXN0U2VyaWVzPy5wcm9wZXJ0aWVzLmN1cnNvciAmJiBsYXN0RGF0dW0pIHtcbiAgICAgIHRoaXMuY2hhcnQuY3R4LmN1cnNvck1hbmFnZXIudXBkYXRlQ3Vyc29yKGxhc3RTZXJpZXMuaWQpO1xuICAgIH1cbiAgICBpZiAobmV3U2VyaWVzPy5wcm9wZXJ0aWVzLmN1cnNvciAmJiBuZXdTZXJpZXM/LnByb3BlcnRpZXMuY3Vyc29yICE9PSBcImRlZmF1bHRcIiAmJiBuZXdEYXR1bSkge1xuICAgICAgdGhpcy5jaGFydC5jdHguY3Vyc29yTWFuYWdlci51cGRhdGVDdXJzb3IobmV3U2VyaWVzLmlkLCBuZXdTZXJpZXMucHJvcGVydGllcy5jdXJzb3IpO1xuICAgIH1cbiAgICBjb25zdCB1cGRhdGVBbGwgPSBuZXdTZXJpZXMgPT0gbnVsbCB8fCBsYXN0U2VyaWVzID09IG51bGw7XG4gICAgaWYgKHVwZGF0ZUFsbCkge1xuICAgICAgdGhpcy51cGRhdGUoNCAvKiBTRVJJRVNfVVBEQVRFICovKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51cGRhdGUoNCAvKiBTRVJJRVNfVVBEQVRFICovLCB7IHNlcmllc1RvVXBkYXRlIH0pO1xuICAgIH1cbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL3Nlcmllc0xheWVyTWFuYWdlci50c1xudmFyIFNFUklFU19USFJFU0hPTERfRk9SX0FHR1JFU1NJVkVfTEFZRVJfUkVEVUNUSU9OID0gMzA7XG52YXIgU2VyaWVzTGF5ZXJNYW5hZ2VyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihzZXJpZXNSb290LCBoaWdobGlnaHRSb290LCBhbm5vdGF0aW9uUm9vdCkge1xuICAgIHRoaXMuc2VyaWVzUm9vdCA9IHNlcmllc1Jvb3Q7XG4gICAgdGhpcy5oaWdobGlnaHRSb290ID0gaGlnaGxpZ2h0Um9vdDtcbiAgICB0aGlzLmFubm90YXRpb25Sb290ID0gYW5ub3RhdGlvblJvb3Q7XG4gICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICB0aGlzLnNlcmllcyA9IHt9O1xuICAgIHRoaXMuZXhwZWN0ZWRTZXJpZXNDb3VudCA9IDE7XG4gICAgdGhpcy5tb2RlID0gXCJub3JtYWxcIjtcbiAgfVxuICBzZXRTZXJpZXNDb3VudChjb3VudCkge1xuICAgIHRoaXMuZXhwZWN0ZWRTZXJpZXNDb3VudCA9IGNvdW50O1xuICB9XG4gIHJlcXVlc3RHcm91cChzZXJpZXNDb25maWcpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IHtcbiAgICAgIGludGVybmFsSWQsXG4gICAgICB0eXBlLFxuICAgICAgcm9vdEdyb3VwOiBzZXJpZXNSb290R3JvdXAsXG4gICAgICBoaWdobGlnaHRHcm91cDogc2VyaWVzSGlnaGxpZ2h0R3JvdXAsXG4gICAgICBhbm5vdGF0aW9uR3JvdXA6IHNlcmllc0Fubm90YXRpb25Hcm91cCxcbiAgICAgIHNlcmllc0dyb3VwaW5nXG4gICAgfSA9IHNlcmllc0NvbmZpZztcbiAgICBjb25zdCB7IGdyb3VwSW5kZXggPSBpbnRlcm5hbElkIH0gPSBzZXJpZXNHcm91cGluZyA/PyB7fTtcbiAgICBpZiAodGhpcy5zZXJpZXNbaW50ZXJuYWxJZF0gIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBRyBDaGFydHMgLSBzZXJpZXMgYWxyZWFkeSBoYXMgYW4gYWxsb2NhdGVkIGxheWVyOiAke3RoaXMuc2VyaWVzW2ludGVybmFsSWRdfWApO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LmtleXModGhpcy5zZXJpZXMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5tb2RlID0gdGhpcy5leHBlY3RlZFNlcmllc0NvdW50ID49IFNFUklFU19USFJFU0hPTERfRk9SX0FHR1JFU1NJVkVfTEFZRVJfUkVEVUNUSU9OID8gXCJhZ2dyZXNzaXZlLWdyb3VwaW5nXCIgOiBcIm5vcm1hbFwiO1xuICAgIH1cbiAgICAoX2EgPSB0aGlzLmdyb3VwcylbdHlwZV0gPz8gKF9hW3R5cGVdID0ge30pO1xuICAgIGNvbnN0IGxvb2t1cEluZGV4ID0gdGhpcy5sb29rdXBJZHgoZ3JvdXBJbmRleCk7XG4gICAgY29uc3QgZ3JvdXBJbmZvID0gKF9iID0gdGhpcy5ncm91cHNbdHlwZV0pW2xvb2t1cEluZGV4XSA/PyAoX2JbbG9va3VwSW5kZXhdID0ge1xuICAgICAgdHlwZSxcbiAgICAgIGlkOiBsb29rdXBJbmRleCxcbiAgICAgIHNlcmllc0lkczogW10sXG4gICAgICBncm91cDogdGhpcy5zZXJpZXNSb290LmFwcGVuZENoaWxkKFxuICAgICAgICBuZXcgTGF5ZXIoe1xuICAgICAgICAgIG5hbWU6IGAke3R5cGV9LWNvbnRlbnRgLFxuICAgICAgICAgIHpJbmRleDogNCAvKiBTRVJJRVNfTEFZRVIgKi8sXG4gICAgICAgICAgekluZGV4U3ViT3JkZXI6IHNlcmllc0NvbmZpZy5nZXRHcm91cFpJbmRleFN1Yk9yZGVyKFwiZGF0YVwiKVxuICAgICAgICB9KVxuICAgICAgKSxcbiAgICAgIGhpZ2hsaWdodDogdGhpcy5oaWdobGlnaHRSb290LmFwcGVuZENoaWxkKFxuICAgICAgICBuZXcgR3JvdXAoe1xuICAgICAgICAgIG5hbWU6IGAke3R5cGV9LWhpZ2hsaWdodGAsXG4gICAgICAgICAgekluZGV4OiA0IC8qIFNFUklFU19MQVlFUiAqLyxcbiAgICAgICAgICB6SW5kZXhTdWJPcmRlcjogc2VyaWVzQ29uZmlnLmdldEdyb3VwWkluZGV4U3ViT3JkZXIoXCJoaWdobGlnaHRcIilcbiAgICAgICAgfSlcbiAgICAgICksXG4gICAgICBhbm5vdGF0aW9uOiB0aGlzLmFubm90YXRpb25Sb290LmFwcGVuZENoaWxkKFxuICAgICAgICBuZXcgR3JvdXAoe1xuICAgICAgICAgIG5hbWU6IGAke3R5cGV9LWFubm90YXRpb25gLFxuICAgICAgICAgIHpJbmRleDogNCAvKiBTRVJJRVNfTEFZRVIgKi8sXG4gICAgICAgICAgekluZGV4U3ViT3JkZXI6IHNlcmllc0NvbmZpZy5nZXRHcm91cFpJbmRleFN1Yk9yZGVyKFwiYW5ub3RhdGlvblwiKVxuICAgICAgICB9KVxuICAgICAgKVxuICAgIH0pO1xuICAgIHRoaXMuc2VyaWVzW2ludGVybmFsSWRdID0geyBsYXllclN0YXRlOiBncm91cEluZm8sIHNlcmllc0NvbmZpZyB9O1xuICAgIGdyb3VwSW5mby5zZXJpZXNJZHMucHVzaChpbnRlcm5hbElkKTtcbiAgICBncm91cEluZm8uZ3JvdXAuYXBwZW5kQ2hpbGQoc2VyaWVzUm9vdEdyb3VwKTtcbiAgICBncm91cEluZm8uaGlnaGxpZ2h0LmFwcGVuZENoaWxkKHNlcmllc0hpZ2hsaWdodEdyb3VwKTtcbiAgICBncm91cEluZm8uYW5ub3RhdGlvbi5hcHBlbmRDaGlsZChzZXJpZXNBbm5vdGF0aW9uR3JvdXApO1xuICAgIHJldHVybiBncm91cEluZm8uZ3JvdXA7XG4gIH1cbiAgY2hhbmdlR3JvdXAoc2VyaWVzQ29uZmlnKSB7XG4gICAgY29uc3QgeyBpbnRlcm5hbElkLCBzZXJpZXNHcm91cGluZywgdHlwZSwgcm9vdEdyb3VwLCBoaWdobGlnaHRHcm91cCwgYW5ub3RhdGlvbkdyb3VwLCBvbGRHcm91cGluZyB9ID0gc2VyaWVzQ29uZmlnO1xuICAgIGNvbnN0IHsgZ3JvdXBJbmRleCA9IGludGVybmFsSWQgfSA9IHNlcmllc0dyb3VwaW5nID8/IHt9O1xuICAgIGlmICh0aGlzLmdyb3Vwc1t0eXBlXT8uW2dyb3VwSW5kZXhdPy5zZXJpZXNJZHMuaW5jbHVkZXMoaW50ZXJuYWxJZCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuc2VyaWVzW2ludGVybmFsSWRdICE9IG51bGwpIHtcbiAgICAgIHRoaXMucmVsZWFzZUdyb3VwKHtcbiAgICAgICAgaW50ZXJuYWxJZCxcbiAgICAgICAgc2VyaWVzR3JvdXBpbmc6IG9sZEdyb3VwaW5nLFxuICAgICAgICB0eXBlLFxuICAgICAgICByb290R3JvdXAsXG4gICAgICAgIGhpZ2hsaWdodEdyb3VwLFxuICAgICAgICBhbm5vdGF0aW9uR3JvdXBcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLnJlcXVlc3RHcm91cChzZXJpZXNDb25maWcpO1xuICB9XG4gIHJlbGVhc2VHcm91cChzZXJpZXNDb25maWcpIHtcbiAgICBjb25zdCB7IGludGVybmFsSWQsIHJvb3RHcm91cCwgaGlnaGxpZ2h0R3JvdXAsIGFubm90YXRpb25Hcm91cCwgdHlwZSB9ID0gc2VyaWVzQ29uZmlnO1xuICAgIGlmICh0aGlzLnNlcmllc1tpbnRlcm5hbElkXSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFHIENoYXJ0cyAtIHNlcmllcyBkb2Vzbid0IGhhdmUgYW4gYWxsb2NhdGVkIGxheWVyOiAke2ludGVybmFsSWR9YCk7XG4gICAgfVxuICAgIGNvbnN0IGdyb3VwSW5mbyA9IHRoaXMuc2VyaWVzW2ludGVybmFsSWRdPy5sYXllclN0YXRlO1xuICAgIGlmIChncm91cEluZm8pIHtcbiAgICAgIGdyb3VwSW5mby5zZXJpZXNJZHMgPSBncm91cEluZm8uc2VyaWVzSWRzLmZpbHRlcigodikgPT4gdiAhPT0gaW50ZXJuYWxJZCk7XG4gICAgICBncm91cEluZm8uZ3JvdXAucmVtb3ZlQ2hpbGQocm9vdEdyb3VwKTtcbiAgICAgIGdyb3VwSW5mby5oaWdobGlnaHQucmVtb3ZlQ2hpbGQoaGlnaGxpZ2h0R3JvdXApO1xuICAgICAgZ3JvdXBJbmZvLmFubm90YXRpb24ucmVtb3ZlQ2hpbGQoYW5ub3RhdGlvbkdyb3VwKTtcbiAgICB9XG4gICAgaWYgKGdyb3VwSW5mbz8uc2VyaWVzSWRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5zZXJpZXNSb290LnJlbW92ZUNoaWxkKGdyb3VwSW5mby5ncm91cCk7XG4gICAgICB0aGlzLmhpZ2hsaWdodFJvb3QucmVtb3ZlQ2hpbGQoZ3JvdXBJbmZvLmhpZ2hsaWdodCk7XG4gICAgICB0aGlzLmFubm90YXRpb25Sb290LnJlbW92ZUNoaWxkKGdyb3VwSW5mby5hbm5vdGF0aW9uKTtcbiAgICAgIGRlbGV0ZSB0aGlzLmdyb3Vwc1tncm91cEluZm8udHlwZV1bZ3JvdXBJbmZvLmlkXTtcbiAgICAgIGRlbGV0ZSB0aGlzLmdyb3Vwc1t0eXBlXVtpbnRlcm5hbElkXTtcbiAgICB9IGVsc2UgaWYgKGdyb3VwSW5mbz8uc2VyaWVzSWRzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGxlYWRTZXJpZXNDb25maWcgPSB0aGlzLnNlcmllc1tncm91cEluZm8/LnNlcmllc0lkcz8uWzBdXT8uc2VyaWVzQ29uZmlnO1xuICAgICAgZ3JvdXBJbmZvLmdyb3VwLnpJbmRleFN1Yk9yZGVyID0gbGVhZFNlcmllc0NvbmZpZz8uZ2V0R3JvdXBaSW5kZXhTdWJPcmRlcihcImRhdGFcIik7XG4gICAgICBncm91cEluZm8uaGlnaGxpZ2h0LnpJbmRleFN1Yk9yZGVyID0gbGVhZFNlcmllc0NvbmZpZz8uZ2V0R3JvdXBaSW5kZXhTdWJPcmRlcihcImhpZ2hsaWdodFwiKTtcbiAgICAgIGdyb3VwSW5mby5hbm5vdGF0aW9uLnpJbmRleFN1Yk9yZGVyID0gbGVhZFNlcmllc0NvbmZpZz8uZ2V0R3JvdXBaSW5kZXhTdWJPcmRlcihcImFubm90YXRpb25cIik7XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLnNlcmllc1tpbnRlcm5hbElkXTtcbiAgfVxuICBsb29rdXBJZHgoZ3JvdXBJbmRleCkge1xuICAgIGlmICh0aGlzLm1vZGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgIHJldHVybiBncm91cEluZGV4O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGdyb3VwSW5kZXggPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGdyb3VwSW5kZXggPSBOdW1iZXIoZ3JvdXBJbmRleC5zcGxpdChcIi1cIikuYXQoLTEpKTtcbiAgICAgIGlmICghZ3JvdXBJbmRleCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoXG4gICAgICBjbGFtcCgwLCBncm91cEluZGV4IC8gdGhpcy5leHBlY3RlZFNlcmllc0NvdW50LCAxKSAqIFNFUklFU19USFJFU0hPTERfRk9SX0FHR1JFU1NJVkVfTEFZRVJfUkVEVUNUSU9OXG4gICAgKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGZvciAoY29uc3QgZ3JvdXBzIG9mIE9iamVjdC52YWx1ZXModGhpcy5ncm91cHMpKSB7XG4gICAgICBmb3IgKGNvbnN0IGdyb3VwSW5mbyBvZiBPYmplY3QudmFsdWVzKGdyb3VwcykpIHtcbiAgICAgICAgdGhpcy5zZXJpZXNSb290LnJlbW92ZUNoaWxkKGdyb3VwSW5mby5ncm91cCk7XG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0Um9vdC5yZW1vdmVDaGlsZChncm91cEluZm8uaGlnaGxpZ2h0KTtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uUm9vdC5yZW1vdmVDaGlsZChncm91cEluZm8uYW5ub3RhdGlvbik7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgdGhpcy5zZXJpZXMgPSB7fTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvdXBkYXRlL2RhdGFXaW5kb3dQcm9jZXNzb3IudHNcbnZhciBEYXRhV2luZG93UHJvY2Vzc29yID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjaGFydCwgZGF0YVNlcnZpY2UsIHVwZGF0ZVNlcnZpY2UsIHpvb21NYW5hZ2VyKSB7XG4gICAgdGhpcy5jaGFydCA9IGNoYXJ0O1xuICAgIHRoaXMuZGF0YVNlcnZpY2UgPSBkYXRhU2VydmljZTtcbiAgICB0aGlzLnVwZGF0ZVNlcnZpY2UgPSB1cGRhdGVTZXJ2aWNlO1xuICAgIHRoaXMuem9vbU1hbmFnZXIgPSB6b29tTWFuYWdlcjtcbiAgICB0aGlzLmRpcnR5Wm9vbSA9IGZhbHNlO1xuICAgIHRoaXMuZGlydHlEYXRhU291cmNlID0gZmFsc2U7XG4gICAgdGhpcy5sYXN0QXhpc1pvb21zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMgPSBbXTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMucHVzaChcbiAgICAgIHRoaXMuZGF0YVNlcnZpY2UuYWRkTGlzdGVuZXIoXCJkYXRhLXNvdXJjZS1jaGFuZ2VcIiwgKCkgPT4gdGhpcy5vbkRhdGFTb3VyY2VDaGFuZ2UoKSksXG4gICAgICB0aGlzLmRhdGFTZXJ2aWNlLmFkZExpc3RlbmVyKFwiZGF0YS1sb2FkXCIsICgpID0+IHRoaXMub25EYXRhTG9hZCgpKSxcbiAgICAgIHRoaXMuZGF0YVNlcnZpY2UuYWRkTGlzdGVuZXIoXCJkYXRhLWVycm9yXCIsICgpID0+IHRoaXMub25EYXRhRXJyb3IoKSksXG4gICAgICB0aGlzLnVwZGF0ZVNlcnZpY2UuYWRkTGlzdGVuZXIoXCJ1cGRhdGUtY29tcGxldGVcIiwgKCkgPT4gdGhpcy5vblVwZGF0ZUNvbXBsZXRlKCkpLFxuICAgICAgdGhpcy56b29tTWFuYWdlci5hZGRMaXN0ZW5lcihcInpvb20tY2hhbmdlXCIsICgpID0+IHRoaXMub25ab29tQ2hhbmdlKCkpXG4gICAgKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveUZucy5mb3JFYWNoKChjYikgPT4gY2IoKSk7XG4gIH1cbiAgb25EYXRhTG9hZCgpIHtcbiAgICB0aGlzLnVwZGF0ZVNlcnZpY2UudXBkYXRlKDEgLyogVVBEQVRFX0RBVEEgKi8pO1xuICB9XG4gIG9uRGF0YUVycm9yKCkge1xuICAgIHRoaXMudXBkYXRlU2VydmljZS51cGRhdGUoMyAvKiBQRVJGT1JNX0xBWU9VVCAqLyk7XG4gIH1cbiAgb25EYXRhU291cmNlQ2hhbmdlKCkge1xuICAgIHRoaXMuZGlydHlEYXRhU291cmNlID0gdHJ1ZTtcbiAgfVxuICBvblVwZGF0ZUNvbXBsZXRlKCkge1xuICAgIGlmICghdGhpcy5kaXJ0eVpvb20gJiYgIXRoaXMuZGlydHlEYXRhU291cmNlKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMudXBkYXRlV2luZG93KCkuY2F0Y2goKGUpID0+IExvZ2dlci5lcnJvck9uY2UoZSkpO1xuICB9XG4gIG9uWm9vbUNoYW5nZSgpIHtcbiAgICB0aGlzLmRpcnR5Wm9vbSA9IHRydWU7XG4gIH1cbiAgYXN5bmMgdXBkYXRlV2luZG93KCkge1xuICAgIGlmICghdGhpcy5kYXRhU2VydmljZS5pc0xhenkoKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBheGlzID0gdGhpcy5nZXRWYWxpZEF4aXMoKTtcbiAgICBsZXQgd2luZG93MjtcbiAgICBsZXQgc2hvdWxkUmVmcmVzaCA9IHRydWU7XG4gICAgaWYgKGF4aXMpIHtcbiAgICAgIGNvbnN0IHpvb20yID0gdGhpcy56b29tTWFuYWdlci5nZXRBeGlzWm9vbShheGlzLmlkKTtcbiAgICAgIHdpbmRvdzIgPSB0aGlzLmdldEF4aXNXaW5kb3coYXhpcywgem9vbTIpO1xuICAgICAgc2hvdWxkUmVmcmVzaCA9IHRoaXMuc2hvdWxkUmVmcmVzaChheGlzLCB6b29tMik7XG4gICAgfVxuICAgIHRoaXMuZGlydHlab29tID0gZmFsc2U7XG4gICAgdGhpcy5kaXJ0eURhdGFTb3VyY2UgPSBmYWxzZTtcbiAgICBpZiAoIXNob3VsZFJlZnJlc2gpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5kYXRhU2VydmljZS5sb2FkKHsgd2luZG93U3RhcnQ6IHdpbmRvdzI/Lm1pbiwgd2luZG93RW5kOiB3aW5kb3cyPy5tYXggfSk7XG4gIH1cbiAgZ2V0VmFsaWRBeGlzKCkge1xuICAgIHJldHVybiB0aGlzLmNoYXJ0LmF4ZXMuZmluZCgoYXhpcykgPT4gYXhpcy50eXBlID09PSBcInRpbWVcIik7XG4gIH1cbiAgc2hvdWxkUmVmcmVzaChheGlzLCB6b29tMikge1xuICAgIGlmICh0aGlzLmRpcnR5RGF0YVNvdXJjZSlcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmICghdGhpcy5kaXJ0eVpvb20pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgbGFzdFpvb20gPSB0aGlzLmxhc3RBeGlzWm9vbXMuZ2V0KGF4aXMuaWQpO1xuICAgIGlmIChsYXN0Wm9vbSAmJiB6b29tMi5taW4gPT09IGxhc3Rab29tLm1pbiAmJiB6b29tMi5tYXggPT09IGxhc3Rab29tLm1heCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLmxhc3RBeGlzWm9vbXMuc2V0KGF4aXMuaWQsIHpvb20yKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBnZXRBeGlzV2luZG93KGF4aXMsIHpvb20yKSB7XG4gICAgY29uc3QgZG9tYWluID0gYXhpcy5zY2FsZS5nZXREb21haW4/LigpO1xuICAgIGlmICghem9vbTIgfHwgIWRvbWFpbiB8fCBkb21haW4ubGVuZ3RoID09PSAwIHx8IGlzTmFOKE51bWJlcihkb21haW5bMF0pKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBkaWZmMiA9IE51bWJlcihkb21haW5bMV0pIC0gTnVtYmVyKGRvbWFpblswXSk7XG4gICAgY29uc3QgbWluID0gbmV3IERhdGUoTnVtYmVyKGRvbWFpblswXSkgKyBkaWZmMiAqIHpvb20yLm1pbik7XG4gICAgY29uc3QgbWF4ID0gbmV3IERhdGUoTnVtYmVyKGRvbWFpblswXSkgKyBkaWZmMiAqIHpvb20yLm1heCk7XG4gICAgcmV0dXJuIHsgbWluLCBtYXggfTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvdXBkYXRlL292ZXJsYXlzUHJvY2Vzc29yLnRzXG52YXIgT3ZlcmxheXNQcm9jZXNzb3IgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNoYXJ0TGlrZSwgb3ZlcmxheXMsIGRhdGFTZXJ2aWNlLCBsYXlvdXRNYW5hZ2VyLCBsb2NhbGVNYW5hZ2VyLCBhbmltYXRpb25NYW5hZ2VyLCBkb21NYW5hZ2VyKSB7XG4gICAgdGhpcy5jaGFydExpa2UgPSBjaGFydExpa2U7XG4gICAgdGhpcy5vdmVybGF5cyA9IG92ZXJsYXlzO1xuICAgIHRoaXMuZGF0YVNlcnZpY2UgPSBkYXRhU2VydmljZTtcbiAgICB0aGlzLmxheW91dE1hbmFnZXIgPSBsYXlvdXRNYW5hZ2VyO1xuICAgIHRoaXMubG9jYWxlTWFuYWdlciA9IGxvY2FsZU1hbmFnZXI7XG4gICAgdGhpcy5hbmltYXRpb25NYW5hZ2VyID0gYW5pbWF0aW9uTWFuYWdlcjtcbiAgICB0aGlzLmRvbU1hbmFnZXIgPSBkb21NYW5hZ2VyO1xuICAgIHRoaXMuZGVzdHJveUZucyA9IFtdO1xuICAgIHRoaXMub3ZlcmxheUVsZW0gPSB0aGlzLmRvbU1hbmFnZXIuYWRkQ2hpbGQoXCJjYW52YXMtb3ZlcmxheVwiLCBcIm92ZXJsYXlcIik7XG4gICAgdGhpcy5vdmVybGF5RWxlbS5yb2xlID0gXCJzdGF0dXNcIjtcbiAgICB0aGlzLm92ZXJsYXlFbGVtLmFyaWFBdG9taWMgPSBcImZhbHNlXCI7XG4gICAgdGhpcy5vdmVybGF5RWxlbS5hcmlhTGl2ZSA9IFwicG9saXRlXCI7XG4gICAgdGhpcy5vdmVybGF5RWxlbS5jbGFzc0xpc3QudG9nZ2xlKERFRkFVTFRfT1ZFUkxBWV9DTEFTUyk7XG4gICAgdGhpcy5kZXN0cm95Rm5zLnB1c2godGhpcy5sYXlvdXRNYW5hZ2VyLmFkZExpc3RlbmVyKFwibGF5b3V0OmNvbXBsZXRlXCIsIChlKSA9PiB0aGlzLm9uTGF5b3V0Q29tcGxldGUoZSkpKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveUZucy5mb3JFYWNoKChjYikgPT4gY2IoKSk7XG4gICAgdGhpcy5kb21NYW5hZ2VyLnJlbW92ZVN0eWxlcyhcIm92ZXJsYXlzXCIpO1xuICAgIHRoaXMuZG9tTWFuYWdlci5yZW1vdmVDaGlsZChcImNhbnZhcy1vdmVybGF5XCIsIFwib3ZlcmxheVwiKTtcbiAgfVxuICBvbkxheW91dENvbXBsZXRlKHsgc2VyaWVzOiB7IHJlY3QgfSB9KSB7XG4gICAgY29uc3QgaXNMb2FkaW5nID0gdGhpcy5kYXRhU2VydmljZS5pc0xvYWRpbmcoKTtcbiAgICBjb25zdCBoYXNEYXRhID0gdGhpcy5jaGFydExpa2Uuc2VyaWVzLnNvbWUoKHMpID0+IHMuaGFzRGF0YSk7XG4gICAgY29uc3QgYW55U2VyaWVzVmlzaWJsZSA9IHRoaXMuY2hhcnRMaWtlLnNlcmllcy5zb21lKChzKSA9PiBzLnZpc2libGUpO1xuICAgIGlmICh0aGlzLm92ZXJsYXlzLmRhcmtUaGVtZSkge1xuICAgICAgdGhpcy5vdmVybGF5RWxlbS5jbGFzc0xpc3QuYWRkKERFRkFVTFRfT1ZFUkxBWV9EQVJLX0NMQVNTKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vdmVybGF5RWxlbS5jbGFzc0xpc3QucmVtb3ZlKERFRkFVTFRfT1ZFUkxBWV9EQVJLX0NMQVNTKTtcbiAgICB9XG4gICAgdGhpcy5vdmVybGF5RWxlbS5zdHlsZS5sZWZ0ID0gYCR7cmVjdC54fXB4YDtcbiAgICB0aGlzLm92ZXJsYXlFbGVtLnN0eWxlLnRvcCA9IGAke3JlY3QueX1weGA7XG4gICAgdGhpcy5vdmVybGF5RWxlbS5zdHlsZS53aWR0aCA9IGAke3JlY3Qud2lkdGh9cHhgO1xuICAgIHRoaXMub3ZlcmxheUVsZW0uc3R5bGUuaGVpZ2h0ID0gYCR7cmVjdC5oZWlnaHR9cHhgO1xuICAgIGNvbnN0IGxvYWRpbmdTaG93biA9IGlzTG9hZGluZztcbiAgICBjb25zdCBub0RhdGFTaG93biA9ICFpc0xvYWRpbmcgJiYgIWhhc0RhdGE7XG4gICAgY29uc3Qgbm9WaXNpYmxlU2VyaWVzU2hvd24gPSBoYXNEYXRhICYmICFhbnlTZXJpZXNWaXNpYmxlO1xuICAgIGlmIChsb2FkaW5nU2hvd24pIHtcbiAgICAgIHRoaXMuc2hvd092ZXJsYXkodGhpcy5vdmVybGF5cy5sb2FkaW5nLCByZWN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oaWRlT3ZlcmxheSh0aGlzLm92ZXJsYXlzLmxvYWRpbmcpO1xuICAgIH1cbiAgICBpZiAobm9EYXRhU2hvd24pIHtcbiAgICAgIHRoaXMuc2hvd092ZXJsYXkodGhpcy5vdmVybGF5cy5ub0RhdGEsIHJlY3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhpZGVPdmVybGF5KHRoaXMub3ZlcmxheXMubm9EYXRhKTtcbiAgICB9XG4gICAgaWYgKG5vVmlzaWJsZVNlcmllc1Nob3duKSB7XG4gICAgICB0aGlzLnNob3dPdmVybGF5KHRoaXMub3ZlcmxheXMubm9WaXNpYmxlU2VyaWVzLCByZWN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oaWRlT3ZlcmxheSh0aGlzLm92ZXJsYXlzLm5vVmlzaWJsZVNlcmllcyk7XG4gICAgfVxuICAgIGNvbnN0IHNob3duID0gbG9hZGluZ1Nob3duIHx8IG5vRGF0YVNob3duIHx8IG5vVmlzaWJsZVNlcmllc1Nob3duO1xuICAgIHNldEF0dHJpYnV0ZSh0aGlzLm92ZXJsYXlFbGVtLCBcImFyaWEtaGlkZGVuXCIsICFzaG93bik7XG4gIH1cbiAgc2hvd092ZXJsYXkob3ZlcmxheSwgc2VyaWVzUmVjdCkge1xuICAgIGNvbnN0IGVsZW1lbnQyID0gb3ZlcmxheS5nZXRFbGVtZW50KHRoaXMuYW5pbWF0aW9uTWFuYWdlciwgdGhpcy5sb2NhbGVNYW5hZ2VyLCBzZXJpZXNSZWN0KTtcbiAgICB0aGlzLm92ZXJsYXlFbGVtLmFwcGVuZENoaWxkKGVsZW1lbnQyKTtcbiAgfVxuICBoaWRlT3ZlcmxheShvdmVybGF5KSB7XG4gICAgb3ZlcmxheS5yZW1vdmVFbGVtZW50KCgpID0+IHtcbiAgICAgIHRoaXMub3ZlcmxheUVsZW0uaW5uZXJUZXh0ID0gXCJcXHhBMFwiO1xuICAgIH0sIHRoaXMuYW5pbWF0aW9uTWFuYWdlcik7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2NoYXJ0LnRzXG52YXIgZGVidWcgPSBEZWJ1Zy5jcmVhdGUodHJ1ZSwgXCJvcHRzXCIpO1xudmFyIFNlcmllc0FyZWEgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnBhZGRpbmcgPSBuZXcgUGFkZGluZygwKTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFNlcmllc0FyZWEucHJvdG90eXBlLCBcImNsaXBcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBTZXJpZXNBcmVhLnByb3RvdHlwZSwgXCJwYWRkaW5nXCIsIDIpO1xudmFyIF9DaGFydCA9IGNsYXNzIF9DaGFydCBleHRlbmRzIE9ic2VydmFibGUge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCByZXNvdXJjZXMpIHtcbiAgICB2YXIgX2E7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmlkID0gY3JlYXRlSWQodGhpcyk7XG4gICAgdGhpcy5zZXJpZXNSb290ID0gbmV3IFRyYW5zbGF0YWJsZUdyb3VwKHsgbmFtZTogYCR7dGhpcy5pZH0tc2VyaWVzLXJvb3RgIH0pO1xuICAgIHRoaXMuaGlnaGxpZ2h0Um9vdCA9IG5ldyBUcmFuc2xhdGFibGVMYXllcih7XG4gICAgICBuYW1lOiBgJHt0aGlzLmlkfS1oaWdobGlnaHQtcm9vdGAsXG4gICAgICB6SW5kZXg6IDUgLyogU0VSSUVTX0hJR0hMSUdIVCAqLyxcbiAgICAgIGRlcml2ZVpJbmRleEZyb21DaGlsZHJlbjogdHJ1ZVxuICAgICAgLy8gVE9ETyByZW1vdmUgZmVhdHVyZVxuICAgIH0pO1xuICAgIHRoaXMuYW5ub3RhdGlvblJvb3QgPSBuZXcgVHJhbnNsYXRhYmxlTGF5ZXIoe1xuICAgICAgbmFtZTogYCR7dGhpcy5pZH0tYW5ub3RhdGlvbi1yb290YCxcbiAgICAgIHpJbmRleDogMTAgLyogU0VSSUVTX0FOTk9UQVRJT04gKi9cbiAgICB9KTtcbiAgICB0aGlzLmRlYnVnID0gRGVidWcuY3JlYXRlKCk7XG4gICAgdGhpcy5leHRyYURlYnVnU3RhdHMgPSB7fTtcbiAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICB0aGlzLl9maXJzdEF1dG9TaXplID0gdHJ1ZTtcbiAgICB0aGlzLnBhZGRpbmcgPSBuZXcgUGFkZGluZygyMCk7XG4gICAgdGhpcy5zZXJpZXNBcmVhID0gbmV3IFNlcmllc0FyZWEoKTtcbiAgICB0aGlzLmtleWJvYXJkID0gbmV3IEtleWJvYXJkKCk7XG4gICAgdGhpcy5tb2RlID0gXCJzdGFuZGFsb25lXCI7XG4gICAgdGhpcy5jaGFydENhcHRpb25zID0gbmV3IENoYXJ0Q2FwdGlvbnMoKTtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX2Rlc3Ryb3lGbnMgPSBbXTtcbiAgICAvLyBVc2VkIHRvIHByZXZlbnQgaW5maW5pdGUgdXBkYXRlIGxvb3BzIHdoZW4gc3luY2luZyBjaGFydHMuXG4gICAgdGhpcy5za2lwU3luYyA9IGZhbHNlO1xuICAgIHRoaXMuY2hhcnRBbmltYXRpb25QaGFzZSA9IFwiaW5pdGlhbFwiO1xuICAgIHRoaXMubW9kdWxlc01hbmFnZXIgPSBuZXcgTW9kdWxlc01hbmFnZXIoKTtcbiAgICB0aGlzLnByb2Nlc3NvcnMgPSBbXTtcbiAgICB0aGlzLnF1ZXVlZFVzZXJPcHRpb25zID0gW107XG4gICAgdGhpcy5fcGVuZGluZ0ZhY3RvcnlVcGRhdGVzQ291bnQgPSAwO1xuICAgIHRoaXMuX3BlcmZvcm1VcGRhdGVOb1JlbmRlckNvdW50ID0gMDtcbiAgICB0aGlzLl9wZXJmb3JtVXBkYXRlU2tpcEFuaW1hdGlvbnMgPSBmYWxzZTtcbiAgICB0aGlzLnBlcmZvcm1VcGRhdGVUeXBlID0gNyAvKiBOT05FICovO1xuICAgIHRoaXMudXBkYXRlU2hvcnRjdXRDb3VudCA9IDA7XG4gICAgdGhpcy5zZXJpZXNUb1VwZGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy51cGRhdGVNdXRleCA9IG5ldyBNdXRleCgpO1xuICAgIHRoaXMudXBkYXRlUmVxdWVzdG9ycyA9IHt9O1xuICAgIHRoaXMucGVyZm9ybVVwZGF0ZVRyaWdnZXIgPSBkZWJvdW5jZWRDYWxsYmFjayhhc3luYyAoeyBjb3VudCB9KSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMudXBkYXRlTXV0ZXguYWNxdWlyZShhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5wZXJmb3JtVXBkYXRlKGNvdW50KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBMb2dnZXIuZXJyb3IoXCJ1cGRhdGUgZXJyb3JcIiwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9KS5jYXRjaCgoZSkgPT4gTG9nZ2VyLmVycm9yT25jZShlKSk7XG4gICAgfSk7XG4gICAgdGhpcy5fcGVyZm9ybVVwZGF0ZVNwbGl0cyA9IHt9O1xuICAgIHRoaXMuYXhlcyA9IFtdO1xuICAgIHRoaXMuc2VyaWVzID0gW107XG4gICAgdGhpcy5vblNlcmllc05vZGVDbGljayA9IChldmVudCkgPT4ge1xuICAgICAgdGhpcy5maXJlRXZlbnQoeyAuLi5ldmVudCwgdHlwZTogXCJzZXJpZXNOb2RlQ2xpY2tcIiB9KTtcbiAgICB9O1xuICAgIHRoaXMub25TZXJpZXNOb2RlRG91YmxlQ2xpY2sgPSAoZXZlbnQpID0+IHtcbiAgICAgIHRoaXMuZmlyZUV2ZW50KHsgLi4uZXZlbnQsIHR5cGU6IFwic2VyaWVzTm9kZURvdWJsZUNsaWNrXCIgfSk7XG4gICAgfTtcbiAgICB0aGlzLnNlcmllc0dyb3VwaW5nQ2hhbmdlZCA9IChldmVudCkgPT4ge1xuICAgICAgaWYgKCEoZXZlbnQgaW5zdGFuY2VvZiBTZXJpZXNHcm91cGluZ0NoYW5nZWRFdmVudCkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHsgc2VyaWVzLCBzZXJpZXNHcm91cGluZywgb2xkR3JvdXBpbmcgfSA9IGV2ZW50O1xuICAgICAgaWYgKHNlcmllcy5yb290R3JvdXAuaXNSb290KCkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMuc2VyaWVzTGF5ZXJNYW5hZ2VyLmNoYW5nZUdyb3VwKHtcbiAgICAgICAgaW50ZXJuYWxJZDogc2VyaWVzLmludGVybmFsSWQsXG4gICAgICAgIHR5cGU6IHNlcmllcy50eXBlLFxuICAgICAgICByb290R3JvdXA6IHNlcmllcy5yb290R3JvdXAsXG4gICAgICAgIGhpZ2hsaWdodEdyb3VwOiBzZXJpZXMuaGlnaGxpZ2h0R3JvdXAsXG4gICAgICAgIGFubm90YXRpb25Hcm91cDogc2VyaWVzLmFubm90YXRpb25Hcm91cCxcbiAgICAgICAgZ2V0R3JvdXBaSW5kZXhTdWJPcmRlcjogKHR5cGUpID0+IHNlcmllcy5nZXRHcm91cFpJbmRleFN1Yk9yZGVyKHR5cGUpLFxuICAgICAgICBzZXJpZXNHcm91cGluZyxcbiAgICAgICAgb2xkR3JvdXBpbmdcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy5jaGFydE9wdGlvbnMgPSBvcHRpb25zO1xuICAgIGNvbnN0IHNjZW5lID0gcmVzb3VyY2VzPy5zY2VuZTtcbiAgICBjb25zdCBjb250YWluZXIgPSByZXNvdXJjZXM/LmNvbnRhaW5lciA/PyBvcHRpb25zLnByb2Nlc3NlZE9wdGlvbnMuY29udGFpbmVyID8/IHZvaWQgMDtcbiAgICBjb25zdCBzdHlsZUNvbnRhaW5lciA9IHJlc291cmNlcz8uc3R5bGVDb250YWluZXIgPz8gb3B0aW9ucy5zcGVjaWFsT3ZlcnJpZGVzLnN0eWxlQ29udGFpbmVyO1xuICAgIGNvbnN0IHJvb3QgPSBuZXcgR3JvdXAoeyBuYW1lOiBcInJvb3RcIiB9KTtcbiAgICBjb25zdCB0aXRsZUdyb3VwID0gbmV3IExheWVyKHsgbmFtZTogXCJ0aXRsZXNcIiwgekluZGV4OiAxNCAvKiBTRVJJRVNfTEFCRUwgKi8gfSk7XG4gICAgcm9vdC52aXNpYmxlID0gZmFsc2U7XG4gICAgcm9vdC5hcHBlbmQodGl0bGVHcm91cCk7XG4gICAgcm9vdC5hcHBlbmQodGhpcy5zZXJpZXNSb290KTtcbiAgICByb290LmFwcGVuZCh0aGlzLmhpZ2hsaWdodFJvb3QpO1xuICAgIHJvb3QuYXBwZW5kKHRoaXMuYW5ub3RhdGlvblJvb3QpO1xuICAgIHRpdGxlR3JvdXAuYXBwZW5kKHRoaXMudGl0bGUubm9kZSk7XG4gICAgdGl0bGVHcm91cC5hcHBlbmQodGhpcy5zdWJ0aXRsZS5ub2RlKTtcbiAgICB0aXRsZUdyb3VwLmFwcGVuZCh0aGlzLmZvb3Rub3RlLm5vZGUpO1xuICAgIHRoaXMudG9vbHRpcCA9IG5ldyBUb29sdGlwKCk7XG4gICAgdGhpcy5zZXJpZXNMYXllck1hbmFnZXIgPSBuZXcgU2VyaWVzTGF5ZXJNYW5hZ2VyKHRoaXMuc2VyaWVzUm9vdCwgdGhpcy5oaWdobGlnaHRSb290LCB0aGlzLmFubm90YXRpb25Sb290KTtcbiAgICB0aGlzLm1vZGUgPSBvcHRpb25zLnVzZXJPcHRpb25zLm1vZGUgPz8gdGhpcy5tb2RlO1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4ID0gbmV3IENoYXJ0Q29udGV4dCh0aGlzLCB7XG4gICAgICBzY2VuZSxcbiAgICAgIHJvb3QsXG4gICAgICBjb250YWluZXIsXG4gICAgICBzdHlsZUNvbnRhaW5lcixcbiAgICAgIHN5bmNNYW5hZ2VyOiBuZXcgU3luY01hbmFnZXIodGhpcyksXG4gICAgICBwaXhlbFJhdGlvOiBvcHRpb25zLnNwZWNpYWxPdmVycmlkZXMub3ZlcnJpZGVEZXZpY2VQaXhlbFJhdGlvLFxuICAgICAgdXBkYXRlQ2FsbGJhY2s6ICh0eXBlID0gMCAvKiBGVUxMICovLCBvcHRzKSA9PiB0aGlzLnVwZGF0ZSh0eXBlLCBvcHRzKSxcbiAgICAgIHVwZGF0ZU11dGV4OiB0aGlzLnVwZGF0ZU11dGV4XG4gICAgfSk7XG4gICAgdGhpcy5fZGVzdHJveUZucy5wdXNoKFxuICAgICAgY3R4LmRvbU1hbmFnZXIuYWRkTGlzdGVuZXIoXCJyZXNpemVcIiwgKCkgPT4gdGhpcy5wYXJlbnRSZXNpemUoY3R4LmRvbU1hbmFnZXIuY29udGFpbmVyU2l6ZSkpXG4gICAgKTtcbiAgICB0aGlzLm92ZXJsYXlzID0gbmV3IENoYXJ0T3ZlcmxheXMoKTtcbiAgICAoX2EgPSB0aGlzLm92ZXJsYXlzLmxvYWRpbmcpLnJlbmRlcmVyID8/IChfYS5yZW5kZXJlciA9ICgpID0+IGdldExvYWRpbmdTcGlubmVyKHRoaXMub3ZlcmxheXMubG9hZGluZy5nZXRUZXh0KGN0eC5sb2NhbGVNYW5hZ2VyKSwgY3R4LmFuaW1hdGlvbk1hbmFnZXIuZGVmYXVsdER1cmF0aW9uKSk7XG4gICAgdGhpcy5wcm9jZXNzb3JzID0gW1xuICAgICAgbmV3IERhdGFXaW5kb3dQcm9jZXNzb3IodGhpcywgY3R4LmRhdGFTZXJ2aWNlLCBjdHgudXBkYXRlU2VydmljZSwgY3R4Lnpvb21NYW5hZ2VyKSxcbiAgICAgIG5ldyBPdmVybGF5c1Byb2Nlc3NvcihcbiAgICAgICAgdGhpcyxcbiAgICAgICAgdGhpcy5vdmVybGF5cyxcbiAgICAgICAgY3R4LmRhdGFTZXJ2aWNlLFxuICAgICAgICBjdHgubGF5b3V0TWFuYWdlcixcbiAgICAgICAgY3R4LmxvY2FsZU1hbmFnZXIsXG4gICAgICAgIGN0eC5hbmltYXRpb25NYW5hZ2VyLFxuICAgICAgICBjdHguZG9tTWFuYWdlclxuICAgICAgKVxuICAgIF07XG4gICAgdGhpcy5oaWdobGlnaHQgPSBuZXcgQ2hhcnRIaWdobGlnaHQoKTtcbiAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICBjb25zdCBtb2R1bGVDb250ZXh0ID0gdGhpcy5nZXRNb2R1bGVDb250ZXh0KCk7XG4gICAgY3R4LnJlZ2lvbk1hbmFnZXIuYWRkUmVnaW9uKFxuICAgICAgXCJzZXJpZXNcIiAvKiBTRVJJRVMgKi8sXG4gICAgICB0aGlzLnNlcmllc1Jvb3QsXG4gICAgICBuZXcgU2ltcGxlUmVnaW9uQkJveFByb3ZpZGVyKHRoaXMuc2VyaWVzUm9vdCwgKCkgPT4gdGhpcy5zZXJpZXNSZWN0ID8/IEJCb3guemVybyksXG4gICAgICB0aGlzLmN0eC5heGlzTWFuYWdlci5heGlzR3JpZEdyb3VwXG4gICAgKTtcbiAgICBjdHgucmVnaW9uTWFuYWdlci5hZGRSZWdpb24oXCJob3Jpem9udGFsLWF4ZXNcIiAvKiBIT1JJWk9OVEFMX0FYRVMgKi8pO1xuICAgIGN0eC5yZWdpb25NYW5hZ2VyLmFkZFJlZ2lvbihcInZlcnRpY2FsLWF4ZXNcIiAvKiBWRVJUSUNBTF9BWEVTICovKTtcbiAgICBjdHgucmVnaW9uTWFuYWdlci5hZGRSZWdpb24oXCJyb290XCIsIHJvb3QpO1xuICAgIGN0eC5kb21NYW5hZ2VyLnNldERhdGFCb29sZWFuKFwiYW5pbWF0aW5nXCIsIGZhbHNlKTtcbiAgICB0aGlzLnNlcmllc0FyZWFNYW5hZ2VyID0gbmV3IFNlcmllc0FyZWFNYW5hZ2VyKHRoaXMuaW5pdFNlcmllc0FyZWFEZXBlbmRlbmNpZXMoKSk7XG4gICAgdGhpcy5fZGVzdHJveUZucy5wdXNoKFxuICAgICAgY3R4LmxheW91dE1hbmFnZXIucmVnaXN0ZXJFbGVtZW50KDAgLyogQ2FwdGlvbiAqLywgKGUpID0+IHtcbiAgICAgICAgZS5sYXlvdXRCb3guc2hyaW5rKHRoaXMucGFkZGluZy50b0pzb24oKSk7XG4gICAgICAgIHRoaXMuY2hhcnRDYXB0aW9ucy5wb3NpdGlvbkNhcHRpb25zKGUpO1xuICAgICAgfSksXG4gICAgICBjdHgubGF5b3V0TWFuYWdlci5hZGRMaXN0ZW5lcihcImxheW91dDpjb21wbGV0ZVwiLCAoZSkgPT4gdGhpcy5jaGFydENhcHRpb25zLnBvc2l0aW9uQWJzb2x1dGVDYXB0aW9ucyhlKSksXG4gICAgICBjdHguZGF0YVNlcnZpY2UuYWRkTGlzdGVuZXIoXCJkYXRhLWxvYWRcIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGV2ZW50LmRhdGE7XG4gICAgICB9KSxcbiAgICAgIHRoaXMudGl0bGUucmVnaXN0ZXJJbnRlcmFjdGlvbihtb2R1bGVDb250ZXh0LCBcImJlZm9yZWJlZ2luXCIpLFxuICAgICAgdGhpcy5zdWJ0aXRsZS5yZWdpc3RlckludGVyYWN0aW9uKG1vZHVsZUNvbnRleHQsIFwiYmVmb3JlYmVnaW5cIiksXG4gICAgICB0aGlzLmZvb3Rub3RlLnJlZ2lzdGVySW50ZXJhY3Rpb24obW9kdWxlQ29udGV4dCwgXCJhZnRlcmVuZFwiKSxcbiAgICAgIGN0eC5pbnRlcmFjdGlvbk1hbmFnZXIuYWRkTGlzdGVuZXIoXCJwYWdlLWxlZnRcIiwgKCkgPT4gdGhpcy5kZXN0cm95KCkpLFxuICAgICAgY3R4LmFuaW1hdGlvbk1hbmFnZXIuYWRkTGlzdGVuZXIoXCJhbmltYXRpb24tZnJhbWVcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLnVwZGF0ZSg2IC8qIFNDRU5FX1JFTkRFUiAqLyk7XG4gICAgICB9KSxcbiAgICAgIGN0eC5hbmltYXRpb25NYW5hZ2VyLmFkZExpc3RlbmVyKFwiYW5pbWF0aW9uLXN0YXJ0XCIsICgpID0+IGN0eC5kb21NYW5hZ2VyLnNldERhdGFCb29sZWFuKFwiYW5pbWF0aW5nXCIsIHRydWUpKSxcbiAgICAgIGN0eC5hbmltYXRpb25NYW5hZ2VyLmFkZExpc3RlbmVyKFwiYW5pbWF0aW9uLXN0b3BcIiwgKCkgPT4gY3R4LmRvbU1hbmFnZXIuc2V0RGF0YUJvb2xlYW4oXCJhbmltYXRpbmdcIiwgZmFsc2UpKSxcbiAgICAgIGN0eC56b29tTWFuYWdlci5hZGRMaXN0ZW5lcihcInpvb20tY2hhbmdlXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy5zZXJpZXMuZm9yRWFjaCgocykgPT4gcy5hbmltYXRpb25TdGF0ZT8udHJhbnNpdGlvbihcInVwZGF0ZURhdGFcIikpO1xuICAgICAgICBjb25zdCBza2lwQW5pbWF0aW9ucyA9IHRoaXMuY2hhcnRBbmltYXRpb25QaGFzZSAhPT0gXCJpbml0aWFsXCI7XG4gICAgICAgIHRoaXMudXBkYXRlKDMgLyogUEVSRk9STV9MQVlPVVQgKi8sIHsgZm9yY2VOb2RlRGF0YVJlZnJlc2g6IHRydWUsIHNraXBBbmltYXRpb25zIH0pO1xuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMucGFyZW50UmVzaXplKGN0eC5kb21NYW5hZ2VyLmNvbnRhaW5lclNpemUpO1xuICB9XG4gIHN0YXRpYyBnZXRJbnN0YW5jZShlbGVtZW50Mikge1xuICAgIHJldHVybiBfQ2hhcnQuY2hhcnRzSW5zdGFuY2VzLmdldChlbGVtZW50Mik7XG4gIH1cbiAgLyoqIE5PVEU6IFRoaXMgaXMgZXhwb3NlZCBmb3IgdXNlIGJ5IEludGVncmF0ZWQgY2hhcnRzIG9ubHkuICovXG4gIGdldCBjYW52YXNFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLmN0eC5zY2VuZS5jYW52YXMuZWxlbWVudDtcbiAgfVxuICBkb3dubG9hZChmaWxlTmFtZSwgZmlsZUZvcm1hdCkge1xuICAgIHRoaXMuY3R4LnNjZW5lLmRvd25sb2FkKGZpbGVOYW1lLCBmaWxlRm9ybWF0KTtcbiAgfVxuICBnZXRDYW52YXNEYXRhVVJMKGZpbGVGb3JtYXQpIHtcbiAgICByZXR1cm4gdGhpcy5jdHguc2NlbmUuZ2V0RGF0YVVSTChmaWxlRm9ybWF0KTtcbiAgfVxuICB0b1NWRygpIHtcbiAgICByZXR1cm4gdGhpcy5jdHguc2NlbmUudG9TVkcoKTtcbiAgfVxuICBnZXRPcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXVlZFVzZXJPcHRpb25zLmF0KC0xKSA/PyB0aGlzLmNoYXJ0T3B0aW9ucy51c2VyT3B0aW9ucztcbiAgfVxuICBpbml0U2VyaWVzQXJlYURlcGVuZGVuY2llcygpIHtcbiAgICBjb25zdCB7IGN0eCwgdG9vbHRpcCwgaGlnaGxpZ2h0LCBvdmVybGF5cywgc2VyaWVzUm9vdCB9ID0gdGhpcztcbiAgICBjb25zdCBjaGFydFR5cGUyID0gdGhpcy5nZXRDaGFydFR5cGUoKTtcbiAgICBjb25zdCBmaXJlRXZlbnQgPSB0aGlzLmZpcmVFdmVudC5iaW5kKHRoaXMpO1xuICAgIGNvbnN0IGdldFVwZGF0ZVR5cGUgPSAoKSA9PiB0aGlzLnBlcmZvcm1VcGRhdGVUeXBlO1xuICAgIHJldHVybiB7IGZpcmVFdmVudCwgZ2V0VXBkYXRlVHlwZSwgY2hhcnRUeXBlOiBjaGFydFR5cGUyLCBjdHgsIHRvb2x0aXAsIGhpZ2hsaWdodCwgb3ZlcmxheXMsIHNlcmllc1Jvb3QgfTtcbiAgfVxuICBnZXRNb2R1bGVDb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmN0eDtcbiAgfVxuICBnZXRDYXB0aW9uVGV4dCgpIHtcbiAgICByZXR1cm4gW3RoaXMudGl0bGUsIHRoaXMuc3VidGl0bGUsIHRoaXMuZm9vdG5vdGVdLmZpbHRlcigoY2FwdGlvbikgPT4gY2FwdGlvbi5lbmFibGVkICYmIGNhcHRpb24udGV4dCkubWFwKChjYXB0aW9uKSA9PiBjYXB0aW9uLnRleHQpLmpvaW4oXCIuIFwiKTtcbiAgfVxuICBnZXRBcmlhTGFiZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3R4LmxvY2FsZU1hbmFnZXIudChcImFyaWFBbm5vdW5jZUNoYXJ0XCIsIHsgc2VyaWVzQ291bnQ6IHRoaXMuc2VyaWVzLmxlbmd0aCB9KTtcbiAgfVxuICByZXNldEFuaW1hdGlvbnMoKSB7XG4gICAgdGhpcy5jaGFydEFuaW1hdGlvblBoYXNlID0gXCJpbml0aWFsXCI7XG4gICAgZm9yIChjb25zdCBzZXJpZXMgb2YgdGhpcy5zZXJpZXMpIHtcbiAgICAgIHNlcmllcy5yZXNldEFuaW1hdGlvbih0aGlzLmNoYXJ0QW5pbWF0aW9uUGhhc2UpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGF4aXMgb2YgdGhpcy5heGVzKSB7XG4gICAgICBheGlzLnJlc2V0QW5pbWF0aW9uKHRoaXMuY2hhcnRBbmltYXRpb25QaGFzZSk7XG4gICAgfVxuICAgIHRoaXMuYW5pbWF0aW9uUmVjdCA9IHZvaWQgMDtcbiAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLnJlc2V0KCk7XG4gIH1cbiAgc2tpcEFuaW1hdGlvbnMoKSB7XG4gICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5za2lwQ3VycmVudEJhdGNoKCk7XG4gICAgdGhpcy5fcGVyZm9ybVVwZGF0ZVNraXBBbmltYXRpb25zID0gdHJ1ZTtcbiAgfVxuICBkZXN0cm95KG9wdHMpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qga2VlcFRyYW5zZmVyYWJsZVJlc291cmNlcyA9IG9wdHM/LmtlZXBUcmFuc2ZlcmFibGVSZXNvdXJjZXM7XG4gICAgbGV0IHJlc3VsdDtcbiAgICB0aGlzLnBlcmZvcm1VcGRhdGVUeXBlID0gNyAvKiBOT05FICovO1xuICAgIHRoaXMuX2Rlc3Ryb3lGbnMuZm9yRWFjaCgoZm4pID0+IGZuKCkpO1xuICAgIHRoaXMucHJvY2Vzc29ycy5mb3JFYWNoKChwKSA9PiBwLmRlc3Ryb3koKSk7XG4gICAgdGhpcy50b29sdGlwLmRlc3Ryb3kodGhpcy5jdHguZG9tTWFuYWdlcik7XG4gICAgdGhpcy5vdmVybGF5cy5kZXN0cm95KCk7XG4gICAgdGhpcy5tb2R1bGVzTWFuYWdlci5kZXN0cm95KCk7XG4gICAgaWYgKGtlZXBUcmFuc2ZlcmFibGVSZXNvdXJjZXMpIHtcbiAgICAgIHRoaXMuY3R4LnNjZW5lLnN0cmlwKCk7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIGNvbnRhaW5lcjogdGhpcy5jb250YWluZXIsXG4gICAgICAgIHNjZW5lOiB0aGlzLmN0eC5zY2VuZVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jdHguc2NlbmUuZGVzdHJveSgpO1xuICAgICAgdGhpcy5jb250YWluZXIgPSB2b2lkIDA7XG4gICAgfVxuICAgIHRoaXMuZGVzdHJveVNlcmllcyh0aGlzLnNlcmllcyk7XG4gICAgdGhpcy5zZXJpZXNMYXllck1hbmFnZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuYXhlcy5mb3JFYWNoKChhKSA9PiBhLmRlc3Ryb3koKSk7XG4gICAgdGhpcy5heGVzID0gW107XG4gICAgdGhpcy5hbmltYXRpb25SZWN0ID0gdm9pZCAwO1xuICAgIHRoaXMuY3R4LmRlc3Ryb3koKTtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHJlcXVlc3RGYWN0b3J5VXBkYXRlKGNiKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX3BlbmRpbmdGYWN0b3J5VXBkYXRlc0NvdW50Kys7XG4gICAgdGhpcy51cGRhdGVNdXRleC5hY3F1aXJlKGFzeW5jICgpID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgYXdhaXQgY2IodGhpcyk7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMuX3BlbmRpbmdGYWN0b3J5VXBkYXRlc0NvdW50LS07XG4gICAgfSkuY2F0Y2goKGUpID0+IExvZ2dlci5lcnJvck9uY2UoZSkpO1xuICB9XG4gIHVwZGF0ZSh0eXBlID0gMCAvKiBGVUxMICovLCBvcHRzKSB7XG4gICAgY29uc3Qge1xuICAgICAgZm9yY2VOb2RlRGF0YVJlZnJlc2ggPSBmYWxzZSxcbiAgICAgIHNraXBBbmltYXRpb25zLFxuICAgICAgc2VyaWVzVG9VcGRhdGUgPSB0aGlzLnNlcmllcyxcbiAgICAgIG5ld0FuaW1hdGlvbkJhdGNoXG4gICAgfSA9IG9wdHMgPz8ge307XG4gICAgaWYgKGZvcmNlTm9kZURhdGFSZWZyZXNoKSB7XG4gICAgICB0aGlzLnNlcmllcy5mb3JFYWNoKChzZXJpZXMpID0+IHNlcmllcy5tYXJrTm9kZURhdGFEaXJ0eSgpKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBzZXJpZXMgb2Ygc2VyaWVzVG9VcGRhdGUpIHtcbiAgICAgIHRoaXMuc2VyaWVzVG9VcGRhdGUuYWRkKHNlcmllcyk7XG4gICAgfVxuICAgIGlmIChza2lwQW5pbWF0aW9ucykge1xuICAgICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5za2lwQ3VycmVudEJhdGNoKCk7XG4gICAgICB0aGlzLl9wZXJmb3JtVXBkYXRlU2tpcEFuaW1hdGlvbnMgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAobmV3QW5pbWF0aW9uQmF0Y2ggJiYgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5pc0FjdGl2ZSgpKSB7XG4gICAgICB0aGlzLl9wZXJmb3JtVXBkYXRlU2tpcEFuaW1hdGlvbnMgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLnNraXBTeW5jID0gb3B0cz8uc2tpcFN5bmMgPz8gZmFsc2U7XG4gICAgaWYgKHRoaXMuZGVidWcuY2hlY2soKSkge1xuICAgICAgbGV0IHN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2sgPz8gXCI8dW5rbm93bj5cIjtcbiAgICAgIHN0YWNrID0gc3RhY2sucmVwbGFjZSgvXFwoW14pXSovZywgXCJcIik7XG4gICAgICB0aGlzLnVwZGF0ZVJlcXVlc3RvcnNbc3RhY2tdID0gdHlwZTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPCB0aGlzLnBlcmZvcm1VcGRhdGVUeXBlKSB7XG4gICAgICB0aGlzLnBlcmZvcm1VcGRhdGVUeXBlID0gdHlwZTtcbiAgICAgIHRoaXMuY3R4LmRvbU1hbmFnZXIuc2V0RGF0YUJvb2xlYW4oXCJ1cGRhdGVQZW5kaW5nXCIsIHRydWUpO1xuICAgICAgdGhpcy5wZXJmb3JtVXBkYXRlVHJpZ2dlci5zY2hlZHVsZShvcHRzPy5iYWNrT2ZmTXMpO1xuICAgIH1cbiAgfVxuICBhc3luYyBwZXJmb3JtVXBkYXRlKGNvdW50KSB7XG4gICAgY29uc3QgeyBwZXJmb3JtVXBkYXRlVHlwZSwgZXh0cmFEZWJ1Z1N0YXRzLCBfcGVyZm9ybVVwZGF0ZVNwbGl0czogc3BsaXRzLCBjdHggfSA9IHRoaXM7XG4gICAgY29uc3Qgc2VyaWVzVG9VcGRhdGUgPSBbLi4udGhpcy5zZXJpZXNUb1VwZGF0ZV07XG4gICAgdGhpcy5wZXJmb3JtVXBkYXRlVHlwZSA9IDcgLyogTk9ORSAqLztcbiAgICB0aGlzLnNlcmllc1RvVXBkYXRlLmNsZWFyKCk7XG4gICAgaWYgKHRoaXMudXBkYXRlU2hvcnRjdXRDb3VudCA9PT0gMCAmJiBwZXJmb3JtVXBkYXRlVHlwZSA8IDYgLyogU0NFTkVfUkVOREVSICovKSB7XG4gICAgICBjdHguYW5pbWF0aW9uTWFuYWdlci5zdGFydEJhdGNoKHRoaXMuX3BlcmZvcm1VcGRhdGVTa2lwQW5pbWF0aW9ucyk7XG4gICAgICBjdHguYW5pbWF0aW9uTWFuYWdlci5vbkJhdGNoU3RvcCgoKSA9PiB0aGlzLmNoYXJ0QW5pbWF0aW9uUGhhc2UgPSBcInJlYWR5XCIpO1xuICAgIH1cbiAgICB0aGlzLmRlYnVnKFwiQ2hhcnQucGVyZm9ybVVwZGF0ZSgpIC0gc3RhcnRcIiwgQ2hhcnRVcGRhdGVUeXBlW3BlcmZvcm1VcGRhdGVUeXBlXSk7XG4gICAgbGV0IHByZXZpb3VzU3BsaXQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBzcGxpdHMuc3RhcnQgPz8gKHNwbGl0cy5zdGFydCA9IHByZXZpb3VzU3BsaXQpO1xuICAgIGNvbnN0IHVwZGF0ZVNwbGl0cyA9IChzcGxpdE5hbWUpID0+IHtcbiAgICAgIHNwbGl0c1tzcGxpdE5hbWVdID8/IChzcGxpdHNbc3BsaXROYW1lXSA9IDApO1xuICAgICAgc3BsaXRzW3NwbGl0TmFtZV0gKz0gcGVyZm9ybWFuY2Uubm93KCkgLSBwcmV2aW91c1NwbGl0O1xuICAgICAgcHJldmlvdXNTcGxpdCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIH07XG4gICAgbGV0IHVwZGF0ZURlZmVycmVkID0gZmFsc2U7XG4gICAgc3dpdGNoIChwZXJmb3JtVXBkYXRlVHlwZSkge1xuICAgICAgY2FzZSAwIC8qIEZVTEwgKi86XG4gICAgICAgIHRoaXMuY3R4LnVwZGF0ZVNlcnZpY2UuZGlzcGF0Y2hQcmVEb21VcGRhdGUoKTtcbiAgICAgICAgdGhpcy51cGRhdGVET00oKTtcbiAgICAgIGNhc2UgMSAvKiBVUERBVEVfREFUQSAqLzpcbiAgICAgICAgYXdhaXQgdGhpcy51cGRhdGVEYXRhKCk7XG4gICAgICAgIHVwZGF0ZVNwbGl0cyhcIlxcdTJCMDdcXHVGRTBGXCIpO1xuICAgICAgY2FzZSAyIC8qIFBST0NFU1NfREFUQSAqLzpcbiAgICAgICAgYXdhaXQgdGhpcy5wcm9jZXNzRGF0YSgpO1xuICAgICAgICB0aGlzLnNlcmllc0FyZWFNYW5hZ2VyLmRhdGFDaGFuZ2VkKCk7XG4gICAgICAgIHVwZGF0ZVNwbGl0cyhcIlxcdXsxRjNFRH1cIik7XG4gICAgICBjYXNlIDMgLyogUEVSRk9STV9MQVlPVVQgKi86XG4gICAgICAgIGlmICh0aGlzLmNoZWNrVXBkYXRlU2hvcnRjdXQoMyAvKiBQRVJGT1JNX0xBWU9VVCAqLykpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmICghdGhpcy5jaGVja0ZpcnN0QXV0b1NpemUoc2VyaWVzVG9VcGRhdGUpKSB7XG4gICAgICAgICAgdXBkYXRlRGVmZXJyZWQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMucHJvY2Vzc0xheW91dCgpO1xuICAgICAgICB1cGRhdGVTcGxpdHMoXCJcXHUyMzE2XCIpO1xuICAgICAgY2FzZSA0IC8qIFNFUklFU19VUERBVEUgKi86IHtcbiAgICAgICAgaWYgKHRoaXMuY2hlY2tVcGRhdGVTaG9ydGN1dCg0IC8qIFNFUklFU19VUERBVEUgKi8pKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjb25zdCB7IHNlcmllc1JlY3QgfSA9IHRoaXM7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHNlcmllc1RvVXBkYXRlLm1hcCgoc2VyaWVzKSA9PiBzZXJpZXMudXBkYXRlKHsgc2VyaWVzUmVjdCB9KSkpO1xuICAgICAgICB1cGRhdGVTcGxpdHMoXCJcXHV7MUY5MTR9XCIpO1xuICAgICAgICB0aGlzLnVwZGF0ZUFyaWFMYWJlbHMoKTtcbiAgICAgIH1cbiAgICAgIGNhc2UgNSAvKiBQUkVfU0NFTkVfUkVOREVSICovOlxuICAgICAgICBpZiAodGhpcy5jaGVja1VwZGF0ZVNob3J0Y3V0KDUgLyogUFJFX1NDRU5FX1JFTkRFUiAqLykpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGN0eC51cGRhdGVTZXJ2aWNlLmRpc3BhdGNoUHJlU2NlbmVSZW5kZXIodGhpcy5nZXRNaW5SZWN0cygpKTtcbiAgICAgICAgdXBkYXRlU3BsaXRzKFwiXFx1MjE5NlwiKTtcbiAgICAgIGNhc2UgNiAvKiBTQ0VORV9SRU5ERVIgKi86XG4gICAgICAgIGlmICh0aGlzLmNoZWNrVXBkYXRlU2hvcnRjdXQoNiAvKiBTQ0VORV9SRU5ERVIgKi8pKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjdHguYW5pbWF0aW9uTWFuYWdlci5lbmRCYXRjaCgpO1xuICAgICAgICBleHRyYURlYnVnU3RhdHNbXCJ1cGRhdGVTaG9ydGN1dENvdW50XCJdID0gdGhpcy51cGRhdGVTaG9ydGN1dENvdW50O1xuICAgICAgICBhd2FpdCBjdHguc2NlbmUucmVuZGVyKHsgZGVidWdTcGxpdFRpbWVzOiBzcGxpdHMsIGV4dHJhRGVidWdTdGF0cywgc2VyaWVzUmVjdDogdGhpcy5zZXJpZXNSZWN0IH0pO1xuICAgICAgICB0aGlzLmV4dHJhRGVidWdTdGF0cyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzcGxpdHMpIHtcbiAgICAgICAgICBkZWxldGUgc3BsaXRzW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdHguZG9tTWFuYWdlci5pbmNyZW1lbnREYXRhQ291bnRlcihcInNjZW5lUmVuZGVyc1wiKTtcbiAgICAgIGNhc2UgNyAvKiBOT05FICovOlxuICAgICAgICB0aGlzLnVwZGF0ZVNob3J0Y3V0Q291bnQgPSAwO1xuICAgICAgICB0aGlzLnVwZGF0ZVJlcXVlc3RvcnMgPSB7fTtcbiAgICAgICAgdGhpcy5fcGVyZm9ybVVwZGF0ZVNraXBBbmltYXRpb25zID0gZmFsc2U7XG4gICAgICAgIGN0eC5hbmltYXRpb25NYW5hZ2VyLmVuZEJhdGNoKCk7XG4gICAgfVxuICAgIGlmICghdXBkYXRlRGVmZXJyZWQpIHtcbiAgICAgIGN0eC51cGRhdGVTZXJ2aWNlLmRpc3BhdGNoVXBkYXRlQ29tcGxldGUodGhpcy5nZXRNaW5SZWN0cygpKTtcbiAgICAgIHRoaXMuY3R4LmRvbU1hbmFnZXIuc2V0RGF0YUJvb2xlYW4oXCJ1cGRhdGVQZW5kaW5nXCIsIGZhbHNlKTtcbiAgICB9XG4gICAgY29uc3QgZW5kMiA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHRoaXMuZGVidWcoXCJDaGFydC5wZXJmb3JtVXBkYXRlKCkgLSBlbmRcIiwge1xuICAgICAgY2hhcnQ6IHRoaXMsXG4gICAgICBkdXJhdGlvbk1zOiBNYXRoLnJvdW5kKChlbmQyIC0gc3BsaXRzW1wic3RhcnRcIl0pICogMTAwKSAvIDEwMCxcbiAgICAgIGNvdW50LFxuICAgICAgcGVyZm9ybVVwZGF0ZVR5cGU6IENoYXJ0VXBkYXRlVHlwZVtwZXJmb3JtVXBkYXRlVHlwZV1cbiAgICB9KTtcbiAgfVxuICB1cGRhdGVUaGVtZUNsYXNzTmFtZSgpIHtcbiAgICBjb25zdCB7IHRoZW1lIH0gPSB0aGlzLmNoYXJ0T3B0aW9ucy5wcm9jZXNzZWRPcHRpb25zO1xuICAgIGNvbnN0IHRoZW1lQ2xhc3NOYW1lUHJlZml4ID0gXCJhZy1jaGFydHMtdGhlbWUtXCI7XG4gICAgY29uc3QgdmFsaWRUaGVtZUNsYXNzTmFtZXMgPSBbYCR7dGhlbWVDbGFzc05hbWVQcmVmaXh9ZGVmYXVsdGAsIGAke3RoZW1lQ2xhc3NOYW1lUHJlZml4fWRlZmF1bHQtZGFya2BdO1xuICAgIGxldCB0aGVtZUNsYXNzTmFtZSA9IHZhbGlkVGhlbWVDbGFzc05hbWVzWzBdO1xuICAgIGxldCBpc0RhcmsgPSBmYWxzZTtcbiAgICBpZiAodHlwZW9mIHRoZW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aGVtZUNsYXNzTmFtZSA9IHRoZW1lLnJlcGxhY2UoXCJhZy1cIiwgdGhlbWVDbGFzc05hbWVQcmVmaXgpO1xuICAgICAgaXNEYXJrID0gdGhlbWUuaW5jbHVkZXMoXCItZGFya1wiKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGVtZT8uYmFzZVRoZW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aGVtZUNsYXNzTmFtZSA9IHRoZW1lLmJhc2VUaGVtZS5yZXBsYWNlKFwiYWctXCIsIHRoZW1lQ2xhc3NOYW1lUHJlZml4KTtcbiAgICAgIGlzRGFyayA9IHRoZW1lLmJhc2VUaGVtZS5pbmNsdWRlcyhcIi1kYXJrXCIpO1xuICAgIH1cbiAgICBpZiAoIXZhbGlkVGhlbWVDbGFzc05hbWVzLmluY2x1ZGVzKHRoZW1lQ2xhc3NOYW1lKSkge1xuICAgICAgdGhlbWVDbGFzc05hbWUgPSBpc0RhcmsgPyB2YWxpZFRoZW1lQ2xhc3NOYW1lc1sxXSA6IHZhbGlkVGhlbWVDbGFzc05hbWVzWzBdO1xuICAgIH1cbiAgICB0aGlzLmN0eC5kb21NYW5hZ2VyLnNldFRoZW1lQ2xhc3ModGhlbWVDbGFzc05hbWUpO1xuICB9XG4gIHVwZGF0ZURPTSgpIHtcbiAgICB0aGlzLnVwZGF0ZVRoZW1lQ2xhc3NOYW1lKCk7XG4gICAgY29uc3QgeyBlbmFibGVkLCB0YWJJbmRleCB9ID0gdGhpcy5rZXlib2FyZDtcbiAgICB0aGlzLmN0eC5kb21NYW5hZ2VyLnNldFRhYkluZGV4KGVuYWJsZWQgPyB0YWJJbmRleCA/PyAwIDogLTEpO1xuICB9XG4gIHVwZGF0ZUFyaWFMYWJlbHMoKSB7XG4gICAgdGhpcy5jdHguZG9tTWFuYWdlci51cGRhdGVDYW52YXNMYWJlbCh0aGlzLmdldEFyaWFMYWJlbCgpKTtcbiAgfVxuICBjaGVja1VwZGF0ZVNob3J0Y3V0KGNoZWNrVXBkYXRlVHlwZSkge1xuICAgIGNvbnN0IG1heFNob3J0Y3V0cyA9IDM7XG4gICAgaWYgKHRoaXMudXBkYXRlU2hvcnRjdXRDb3VudCA+IG1heFNob3J0Y3V0cykge1xuICAgICAgTG9nZ2VyLndhcm4oXG4gICAgICAgIGBleGNlZWRlZCB0aGUgbWF4aW11bSBudW1iZXIgb2Ygc2ltdWx0YW5lb3VzIHVwZGF0ZXMgKCR7bWF4U2hvcnRjdXRzICsgMX0pLCBkaXNjYXJkaW5nIGNoYW5nZXMgYW5kIHJlbmRlcmluZ2AsXG4gICAgICAgIHRoaXMudXBkYXRlUmVxdWVzdG9yc1xuICAgICAgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRoaXMucGVyZm9ybVVwZGF0ZVR5cGUgPD0gY2hlY2tVcGRhdGVUeXBlKSB7XG4gICAgICB0aGlzLnVwZGF0ZVNob3J0Y3V0Q291bnQrKztcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY2hlY2tGaXJzdEF1dG9TaXplKHNlcmllc1RvVXBkYXRlKSB7XG4gICAgaWYgKHRoaXMud2lkdGggIT0gbnVsbCAmJiB0aGlzLmhlaWdodCAhPSBudWxsKSB7XG4gICAgfSBlbHNlIGlmICghdGhpcy5fbGFzdEF1dG9TaXplKSB7XG4gICAgICBjb25zdCBjb3VudCA9IHRoaXMuX3BlcmZvcm1VcGRhdGVOb1JlbmRlckNvdW50Kys7XG4gICAgICBjb25zdCBiYWNrT2ZmTXMgPSAoY291bnQgKyAxKSAqKiAyICogNDA7XG4gICAgICBpZiAoY291bnQgPCA4KSB7XG4gICAgICAgIHRoaXMudXBkYXRlKDMgLyogUEVSRk9STV9MQVlPVVQgKi8sIHsgc2VyaWVzVG9VcGRhdGUsIGJhY2tPZmZNcyB9KTtcbiAgICAgICAgdGhpcy5kZWJ1ZyhcIkNoYXJ0LmNoZWNrRmlyc3RBdXRvU2l6ZSgpIC0gYmFja2luZyBvZmYgdW50aWwgZmlyc3Qgc2l6ZSB1cGRhdGVcIiwgYmFja09mZk1zKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhpcy5kZWJ1ZyhcIkNoYXJ0LmNoZWNrRmlyc3RBdXRvU2l6ZSgpIC0gdGltZW91dCBmb3IgZmlyc3Qgc2l6ZSB1cGRhdGUuXCIpO1xuICAgIH1cbiAgICB0aGlzLl9wZXJmb3JtVXBkYXRlTm9SZW5kZXJDb3VudCA9IDA7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgb25BeGlzQ2hhbmdlKG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xuICAgIGlmIChvbGRWYWx1ZSA9PSBudWxsICYmIG5ld1ZhbHVlLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmN0eC5heGlzTWFuYWdlci51cGRhdGVBeGVzKG9sZFZhbHVlID8/IFtdLCBuZXdWYWx1ZSk7XG4gIH1cbiAgb25TZXJpZXNDaGFuZ2UobmV3VmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgY29uc3Qgc2VyaWVzVG9EZXN0cm95ID0gb2xkVmFsdWU/LmZpbHRlcigoc2VyaWVzKSA9PiAhbmV3VmFsdWUuaW5jbHVkZXMoc2VyaWVzKSkgPz8gW107XG4gICAgdGhpcy5kZXN0cm95U2VyaWVzKHNlcmllc1RvRGVzdHJveSk7XG4gICAgdGhpcy5zZXJpZXNMYXllck1hbmFnZXI/LnNldFNlcmllc0NvdW50KG5ld1ZhbHVlLmxlbmd0aCk7XG4gICAgZm9yIChjb25zdCBzZXJpZXMgb2YgbmV3VmFsdWUpIHtcbiAgICAgIGlmIChvbGRWYWx1ZT8uaW5jbHVkZXMoc2VyaWVzKSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBpZiAoc2VyaWVzLnJvb3RHcm91cC5pc1Jvb3QoKSkge1xuICAgICAgICB0aGlzLnNlcmllc0xheWVyTWFuYWdlci5yZXF1ZXN0R3JvdXAoc2VyaWVzKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoYXJ0ID0gdGhpcztcbiAgICAgIHNlcmllcy5jaGFydCA9IHtcbiAgICAgICAgZ2V0IG1vZGUoKSB7XG4gICAgICAgICAgcmV0dXJuIGNoYXJ0Lm1vZGU7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBpc01pbmlDaGFydCgpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBzZXJpZXNSZWN0KCkge1xuICAgICAgICAgIHJldHVybiBjaGFydC5zZXJpZXNSZWN0O1xuICAgICAgICB9LFxuICAgICAgICBwbGFjZUxhYmVscyhwYWRkaW5nKSB7XG4gICAgICAgICAgcmV0dXJuIGNoYXJ0LnBsYWNlTGFiZWxzKHBhZGRpbmcpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgc2VyaWVzLnJlc2V0QW5pbWF0aW9uKHRoaXMuY2hhcnRBbmltYXRpb25QaGFzZSk7XG4gICAgICB0aGlzLmFkZFNlcmllc0xpc3RlbmVycyhzZXJpZXMpO1xuICAgICAgc2VyaWVzLmFkZENoYXJ0RXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG4gICAgdGhpcy5zZXJpZXNBcmVhTWFuYWdlcj8uc2VyaWVzQ2hhbmdlZChuZXdWYWx1ZSk7XG4gIH1cbiAgZGVzdHJveVNlcmllcyhhbGxTZXJpZXMpIHtcbiAgICBhbGxTZXJpZXM/LmZvckVhY2goKHNlcmllcykgPT4ge1xuICAgICAgc2VyaWVzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJub2RlQ2xpY2tcIiwgdGhpcy5vblNlcmllc05vZGVDbGljayk7XG4gICAgICBzZXJpZXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm5vZGVEb3VibGVDbGlja1wiLCB0aGlzLm9uU2VyaWVzTm9kZURvdWJsZUNsaWNrKTtcbiAgICAgIHNlcmllcy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZ3JvdXBpbmdDaGFuZ2VkXCIsIHRoaXMuc2VyaWVzR3JvdXBpbmdDaGFuZ2VkKTtcbiAgICAgIHNlcmllcy5kZXN0cm95KCk7XG4gICAgICB0aGlzLnNlcmllc0xheWVyTWFuYWdlci5yZWxlYXNlR3JvdXAoc2VyaWVzKTtcbiAgICAgIHNlcmllcy5jaGFydCA9IHZvaWQgMDtcbiAgICB9KTtcbiAgfVxuICBhZGRTZXJpZXNMaXN0ZW5lcnMoc2VyaWVzKSB7XG4gICAgaWYgKHRoaXMuaGFzRXZlbnRMaXN0ZW5lcihcInNlcmllc05vZGVDbGlja1wiKSkge1xuICAgICAgc2VyaWVzLmFkZEV2ZW50TGlzdGVuZXIoXCJub2RlQ2xpY2tcIiwgdGhpcy5vblNlcmllc05vZGVDbGljayk7XG4gICAgfVxuICAgIGlmICh0aGlzLmhhc0V2ZW50TGlzdGVuZXIoXCJzZXJpZXNOb2RlRG91YmxlQ2xpY2tcIikpIHtcbiAgICAgIHNlcmllcy5hZGRFdmVudExpc3RlbmVyKFwibm9kZURvdWJsZUNsaWNrXCIsIHRoaXMub25TZXJpZXNOb2RlRG91YmxlQ2xpY2spO1xuICAgIH1cbiAgICBzZXJpZXMuYWRkRXZlbnRMaXN0ZW5lcihcImdyb3VwaW5nQ2hhbmdlZFwiLCB0aGlzLnNlcmllc0dyb3VwaW5nQ2hhbmdlZCk7XG4gIH1cbiAgYXNzaWduU2VyaWVzVG9BeGVzKCkge1xuICAgIGZvciAoY29uc3QgYXhpcyBvZiB0aGlzLmF4ZXMpIHtcbiAgICAgIGF4aXMuYm91bmRTZXJpZXMgPSB0aGlzLnNlcmllcy5maWx0ZXIoKHMpID0+IHMuYXhlc1theGlzLmRpcmVjdGlvbl0gPT09IGF4aXMpO1xuICAgIH1cbiAgfVxuICBhc3NpZ25BeGVzVG9TZXJpZXMoKSB7XG4gICAgY29uc3QgZGlyZWN0aW9uVG9BeGVzTWFwID0gZ3JvdXBCeSh0aGlzLmF4ZXMsIChheGlzKSA9PiBheGlzLmRpcmVjdGlvbik7XG4gICAgdGhpcy5zZXJpZXMuZm9yRWFjaCgoc2VyaWVzKSA9PiB7XG4gICAgICBzZXJpZXMuZGlyZWN0aW9ucy5mb3JFYWNoKChkaXJlY3Rpb24pID0+IHtcbiAgICAgICAgY29uc3QgZGlyZWN0aW9uQXhlcyA9IGRpcmVjdGlvblRvQXhlc01hcFtkaXJlY3Rpb25dO1xuICAgICAgICBpZiAoIWRpcmVjdGlvbkF4ZXMpIHtcbiAgICAgICAgICBMb2dnZXIud2Fybk9uY2UoXG4gICAgICAgICAgICBgbm8gYXZhaWxhYmxlIGF4aXMgZm9yIGRpcmVjdGlvbiBbJHtkaXJlY3Rpb259XTsgY2hlY2sgc2VyaWVzIGFuZCBheGVzIGNvbmZpZ3VyYXRpb24uYFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlcmllc0tleXMgPSBzZXJpZXMuZ2V0S2V5cyhkaXJlY3Rpb24pO1xuICAgICAgICBjb25zdCBuZXdBeGlzID0gZGlyZWN0aW9uQXhlcy5maW5kKFxuICAgICAgICAgIChheGlzKSA9PiAhYXhpcy5rZXlzLmxlbmd0aCB8fCBzZXJpZXNLZXlzLnNvbWUoKGtleSkgPT4gYXhpcy5rZXlzLmluY2x1ZGVzKGtleSkpXG4gICAgICAgICk7XG4gICAgICAgIGlmICghbmV3QXhpcykge1xuICAgICAgICAgIExvZ2dlci53YXJuT25jZShcbiAgICAgICAgICAgIGBubyBtYXRjaGluZyBheGlzIGZvciBkaXJlY3Rpb24gWyR7ZGlyZWN0aW9ufV0gYW5kIGtleXMgWyR7c2VyaWVzS2V5c31dOyBjaGVjayBzZXJpZXMgYW5kIGF4ZXMgY29uZmlndXJhdGlvbi5gXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2VyaWVzLmF4ZXNbZGlyZWN0aW9uXSA9IG5ld0F4aXM7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBwYXJlbnRSZXNpemUoc2l6ZSkge1xuICAgIGlmIChzaXplID09IG51bGwgfHwgdGhpcy53aWR0aCAhPSBudWxsICYmIHRoaXMuaGVpZ2h0ICE9IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgbGV0IHsgd2lkdGg6IHdpZHRoMiwgaGVpZ2h0OiBoZWlnaHQyIH0gPSBzaXplO1xuICAgIHdpZHRoMiA9IE1hdGguZmxvb3Iod2lkdGgyKTtcbiAgICBoZWlnaHQyID0gTWF0aC5mbG9vcihoZWlnaHQyKTtcbiAgICBpZiAod2lkdGgyID09PSAwICYmIGhlaWdodDIgPT09IDApXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgW2F1dG9XaWR0aCA9IDAsIGF1dGhIZWlnaHQgPSAwXSA9IHRoaXMuX2xhc3RBdXRvU2l6ZSA/PyBbXTtcbiAgICBpZiAoYXV0b1dpZHRoID09PSB3aWR0aDIgJiYgYXV0aEhlaWdodCA9PT0gaGVpZ2h0MilcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9sYXN0QXV0b1NpemUgPSBbd2lkdGgyLCBoZWlnaHQyXTtcbiAgICB0aGlzLnJlc2l6ZShcIlNpemVNb25pdG9yXCIsIHt9KTtcbiAgfVxuICByZXNpemUoc291cmNlLCBvcHRzKSB7XG4gICAgY29uc3QgeyBzY2VuZSwgYW5pbWF0aW9uTWFuYWdlciB9ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgeyBpbldpZHRoLCBpbkhlaWdodCwgaW5NaW5XaWR0aCwgaW5NaW5IZWlnaHQgfSA9IG9wdHM7XG4gICAgdGhpcy5jdHguZG9tTWFuYWdlci5zZXRTaXplT3B0aW9ucyhcbiAgICAgIGluTWluV2lkdGggPz8gdGhpcy5taW5XaWR0aCxcbiAgICAgIGluTWluSGVpZ2h0ID8/IHRoaXMubWluSGVpZ2h0LFxuICAgICAgaW5XaWR0aCA/PyB0aGlzLndpZHRoLFxuICAgICAgaW5IZWlnaHQgPz8gdGhpcy5oZWlnaHRcbiAgICApO1xuICAgIGNvbnN0IHdpZHRoMiA9IGluV2lkdGggPz8gdGhpcy53aWR0aCA/PyB0aGlzLl9sYXN0QXV0b1NpemU/LlswXTtcbiAgICBjb25zdCBoZWlnaHQyID0gaW5IZWlnaHQgPz8gdGhpcy5oZWlnaHQgPz8gdGhpcy5fbGFzdEF1dG9TaXplPy5bMV07XG4gICAgdGhpcy5kZWJ1ZyhgQ2hhcnQucmVzaXplKCkgZnJvbSAke3NvdXJjZX1gLCB7IHdpZHRoOiB3aWR0aDIsIGhlaWdodDogaGVpZ2h0Miwgc3RhY2s6IG5ldyBFcnJvcigpLnN0YWNrIH0pO1xuICAgIGlmICh3aWR0aDIgPT0gbnVsbCB8fCBoZWlnaHQyID09IG51bGwgfHwgIWlzRmluaXRlTnVtYmVyKHdpZHRoMikgfHwgIWlzRmluaXRlTnVtYmVyKGhlaWdodDIpKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChzY2VuZS5yZXNpemUod2lkdGgyLCBoZWlnaHQyKSkge1xuICAgICAgYW5pbWF0aW9uTWFuYWdlci5yZXNldCgpO1xuICAgICAgbGV0IHNraXBBbmltYXRpb25zID0gdHJ1ZTtcbiAgICAgIGlmICgodGhpcy53aWR0aCA9PSBudWxsIHx8IHRoaXMuaGVpZ2h0ID09IG51bGwpICYmIHRoaXMuX2ZpcnN0QXV0b1NpemUpIHtcbiAgICAgICAgc2tpcEFuaW1hdGlvbnMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZmlyc3RBdXRvU2l6ZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGUoMyAvKiBQRVJGT1JNX0xBWU9VVCAqLywgeyBmb3JjZU5vZGVEYXRhUmVmcmVzaDogdHJ1ZSwgc2tpcEFuaW1hdGlvbnMgfSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIHVwZGF0ZURhdGEoKSB7XG4gICAgdGhpcy5zZXJpZXMuZm9yRWFjaCgocykgPT4gcy5zZXRDaGFydERhdGEodGhpcy5kYXRhKSk7XG4gICAgY29uc3QgbW9kdWxlUHJvbWlzZXMgPSB0aGlzLm1vZHVsZXNNYW5hZ2VyLm1hcE1vZHVsZXMoKG0pID0+IG0udXBkYXRlRGF0YT8uKHRoaXMuZGF0YSkpO1xuICAgIGF3YWl0IFByb21pc2UuYWxsKG1vZHVsZVByb21pc2VzKTtcbiAgfVxuICBhc3luYyBwcm9jZXNzRGF0YSgpIHtcbiAgICBpZiAodGhpcy5zZXJpZXMuc29tZSgocykgPT4gcy5jYW5IYXZlQXhlcykpIHtcbiAgICAgIHRoaXMuYXNzaWduQXhlc1RvU2VyaWVzKCk7XG4gICAgICB0aGlzLmFzc2lnblNlcmllc1RvQXhlcygpO1xuICAgIH1cbiAgICBjb25zdCBkYXRhQ29udHJvbGxlciA9IG5ldyBEYXRhQ29udHJvbGxlcih0aGlzLm1vZGUpO1xuICAgIGNvbnN0IHNlcmllc1Byb21pc2VzID0gdGhpcy5zZXJpZXMubWFwKChzKSA9PiBzLnByb2Nlc3NEYXRhKGRhdGFDb250cm9sbGVyKSk7XG4gICAgY29uc3QgbW9kdWxlUHJvbWlzZXMgPSB0aGlzLm1vZHVsZXNNYW5hZ2VyLm1hcE1vZHVsZXMoKG0pID0+IG0ucHJvY2Vzc0RhdGE/LihkYXRhQ29udHJvbGxlcikpO1xuICAgIGRhdGFDb250cm9sbGVyLmV4ZWN1dGUoKTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChbLi4uc2VyaWVzUHJvbWlzZXMsIC4uLm1vZHVsZVByb21pc2VzXSk7XG4gICAgZm9yIChjb25zdCB7IGxlZ2VuZFR5cGUsIGxlZ2VuZCB9IG9mIHRoaXMubW9kdWxlc01hbmFnZXIubGVnZW5kcygpKSB7XG4gICAgICBsZWdlbmQuZGF0YSA9IHRoaXMuZ2V0TGVnZW5kRGF0YShsZWdlbmRUeXBlLCB0aGlzLm1vZGUgIT09IFwiaW50ZWdyYXRlZFwiKTtcbiAgICB9XG4gIH1cbiAgcGxhY2VMYWJlbHMocGFkZGluZykge1xuICAgIGNvbnN0IHZpc2libGVTZXJpZXMgPSBbXTtcbiAgICBjb25zdCBkYXRhID0gW107XG4gICAgZm9yIChjb25zdCBzZXJpZXMgb2YgdGhpcy5zZXJpZXMpIHtcbiAgICAgIGlmICghc2VyaWVzLnZpc2libGUpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3QgbGFiZWxEYXRhID0gc2VyaWVzLmdldExhYmVsRGF0YSgpO1xuICAgICAgaWYgKGlzUG9pbnRMYWJlbERhdHVtKGxhYmVsRGF0YT8uWzBdKSkge1xuICAgICAgICBkYXRhLnB1c2gobGFiZWxEYXRhKTtcbiAgICAgICAgdmlzaWJsZVNlcmllcy5wdXNoKHNlcmllcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHsgc2VyaWVzUmVjdCB9ID0gdGhpcztcbiAgICBjb25zdCB7IHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCB9ID0gdGhpcy5zZXJpZXNBcmVhLnBhZGRpbmc7XG4gICAgY29uc3QgbGFiZWxzID0gc2VyaWVzUmVjdCAmJiBkYXRhLmxlbmd0aCA+IDAgPyBwbGFjZUxhYmVscyhcbiAgICAgIGRhdGEsXG4gICAgICB7XG4gICAgICAgIHg6IC1sZWZ0LFxuICAgICAgICB5OiAtdG9wLFxuICAgICAgICB3aWR0aDogc2VyaWVzUmVjdC53aWR0aCArIGxlZnQgKyByaWdodCxcbiAgICAgICAgaGVpZ2h0OiBzZXJpZXNSZWN0LmhlaWdodCArIHRvcCArIGJvdHRvbVxuICAgICAgfSxcbiAgICAgIHBhZGRpbmdcbiAgICApIDogW107XG4gICAgcmV0dXJuIG5ldyBNYXAobGFiZWxzLm1hcCgobCwgaSkgPT4gW3Zpc2libGVTZXJpZXNbaV0sIGxdKSk7XG4gIH1cbiAgZ2V0TGVnZW5kRGF0YShsZWdlbmRUeXBlLCB3YXJuQ29uZmxpY3RzKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGxlZ2VuZERhdGEgPSB0aGlzLnNlcmllcy5maWx0ZXIoKHMpID0+IHMucHJvcGVydGllcy5zaG93SW5MZWdlbmQpLmZsYXRNYXAoKHMpID0+IHMuZ2V0TGVnZW5kRGF0YShsZWdlbmRUeXBlKSk7XG4gICAgY29uc3QgaXNDYXRlZ29yeUxlZ2VuZERhdGEgPSAoZGF0YSkgPT4gZGF0YS5ldmVyeSgoZCkgPT4gZC5sZWdlbmRUeXBlID09PSBcImNhdGVnb3J5XCIpO1xuICAgIGlmICh3YXJuQ29uZmxpY3RzICYmIGlzQ2F0ZWdvcnlMZWdlbmREYXRhKGxlZ2VuZERhdGEpKSB7XG4gICAgICBjb25zdCBzZXJpZXNNYXJrZXJGaWxscyA9IHt9O1xuICAgICAgY29uc3Qgc2VyaWVzVHlwZU1hcCA9IG5ldyBNYXAodGhpcy5zZXJpZXMubWFwKChzKSA9PiBbcy5pZCwgcy50eXBlXSkpO1xuICAgICAgZm9yIChjb25zdCB7XG4gICAgICAgIHNlcmllc0lkLFxuICAgICAgICBzeW1ib2xzOiBbeyBtYXJrZXIgfV0sXG4gICAgICAgIGxhYmVsXG4gICAgICB9IG9mIGxlZ2VuZERhdGEpIHtcbiAgICAgICAgaWYgKG1hcmtlci5maWxsID09IG51bGwpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IHNlcmllc1R5cGUyID0gc2VyaWVzVHlwZU1hcC5nZXQoc2VyaWVzSWQpO1xuICAgICAgICBjb25zdCBtYXJrZXJGaWxsID0gc2VyaWVzTWFya2VyRmlsbHNbc2VyaWVzVHlwZTJdID8/IChzZXJpZXNNYXJrZXJGaWxsc1tzZXJpZXNUeXBlMl0gPSB7fSk7XG4gICAgICAgIG1hcmtlckZpbGxbX2EgPSBsYWJlbC50ZXh0XSA/PyAobWFya2VyRmlsbFtfYV0gPSBtYXJrZXIuZmlsbCk7XG4gICAgICAgIGlmIChtYXJrZXJGaWxsW2xhYmVsLnRleHRdICE9PSBtYXJrZXIuZmlsbCkge1xuICAgICAgICAgIExvZ2dlci53YXJuT25jZShcbiAgICAgICAgICAgIGBsZWdlbmQgaXRlbSAnJHtsYWJlbC50ZXh0fScgaGFzIG11bHRpcGxlIGZpbGwgY29sb3JzLCB0aGlzIG1heSBjYXVzZSB1bmV4cGVjdGVkIGJlaGF2aW91ci5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGVnZW5kRGF0YTtcbiAgfVxuICBhc3luYyBwcm9jZXNzTGF5b3V0KCkge1xuICAgIGNvbnN0IG9sZFJlY3QgPSB0aGlzLmFuaW1hdGlvblJlY3Q7XG4gICAgY29uc3QgeyB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIgfSA9IHRoaXMuY3R4LnNjZW5lO1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4LmxheW91dE1hbmFnZXIuY3JlYXRlQ29udGV4dCh3aWR0aDIsIGhlaWdodDIpO1xuICAgIGF3YWl0IHRoaXMucGVyZm9ybUxheW91dChjdHgpO1xuICAgIGlmIChvbGRSZWN0ICYmICF0aGlzLmFuaW1hdGlvblJlY3Q/LmVxdWFscyhvbGRSZWN0KSkge1xuICAgICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5za2lwQ3VycmVudEJhdGNoKCk7XG4gICAgfVxuICAgIHRoaXMuZGVidWcoXCJDaGFydC5wZXJmb3JtVXBkYXRlKCkgLSBzZXJpZXNSZWN0XCIsIHRoaXMuc2VyaWVzUmVjdCk7XG4gIH1cbiAgYXN5bmMgd2FpdEZvclVwZGF0ZSh0aW1lb3V0TXMgPSAxZTQsIGZhaWxPblRpbWVvdXQgPSBmYWxzZSkge1xuICAgIGNvbnN0IHN0YXJ0MiA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGlmICh0aGlzLl9wZW5kaW5nRmFjdG9yeVVwZGF0ZXNDb3VudCA+IDApIHtcbiAgICAgIGF3YWl0IHRoaXMudXBkYXRlTXV0ZXgud2FpdEZvckNsZWFyQWNxdWlyZVF1ZXVlKCk7XG4gICAgfVxuICAgIHdoaWxlICh0aGlzLnBlcmZvcm1VcGRhdGVUeXBlICE9PSA3IC8qIE5PTkUgKi8pIHtcbiAgICAgIGlmIChwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0MiA+IHRpbWVvdXRNcykge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gYENoYXJ0LndhaXRGb3JVcGRhdGUoKSB0aW1lb3V0IG9mICR7dGltZW91dE1zfSByZWFjaGVkIC0gZmlyc3QgY2hhcnQgdXBkYXRlIHRha2luZyB0b28gbG9uZy5gO1xuICAgICAgICBpZiAoZmFpbE9uVGltZW91dCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBMb2dnZXIud2Fybk9uY2UobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGF3YWl0IHNsZWVwKDUwKTtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy51cGRhdGVNdXRleC53YWl0Rm9yQ2xlYXJBY3F1aXJlUXVldWUoKTtcbiAgfVxuICBnZXRNaW5SZWN0cygpIHtcbiAgICBjb25zdCB7IHdpZHRoOiB3aWR0aDIsIGhlaWdodDogaGVpZ2h0MiB9ID0gdGhpcy5jdHguc2NlbmU7XG4gICAgY29uc3QgbWluUmVjdHMgPSB0aGlzLnNlcmllcy5tYXAoKHNlcmllcykgPT4gc2VyaWVzLmdldE1pblJlY3RzKHdpZHRoMiwgaGVpZ2h0MikpLmZpbHRlcihpc0RlZmluZWQpO1xuICAgIGlmIChtaW5SZWN0cy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm47XG4gICAgbGV0IG1heFdpZHRoID0gMDtcbiAgICBsZXQgbWF4SGVpZ2h0ID0gMDtcbiAgICBsZXQgbWF4VmlzaWJsZVdpZHRoID0gMDtcbiAgICBsZXQgbWF4VmlzaWJsZUhlaWdodCA9IDA7XG4gICAgZm9yIChjb25zdCB7IG1pblJlY3Q6IG1pblJlY3QyLCBtaW5WaXNpYmxlUmVjdDogbWluVmlzaWJsZVJlY3QyIH0gb2YgbWluUmVjdHMpIHtcbiAgICAgIG1heFdpZHRoID0gTWF0aC5tYXgobWF4V2lkdGgsIG1pblJlY3QyLndpZHRoKTtcbiAgICAgIG1heEhlaWdodCA9IE1hdGgubWF4KG1heEhlaWdodCwgbWluUmVjdDIuaGVpZ2h0KTtcbiAgICAgIG1heFZpc2libGVXaWR0aCA9IE1hdGgubWF4KG1heFZpc2libGVXaWR0aCwgbWluVmlzaWJsZVJlY3QyLndpZHRoKTtcbiAgICAgIG1heFZpc2libGVIZWlnaHQgPSBNYXRoLm1heChtYXhWaXNpYmxlSGVpZ2h0LCBtaW5WaXNpYmxlUmVjdDIuaGVpZ2h0KTtcbiAgICB9XG4gICAgY29uc3QgbWluUmVjdCA9IG5ldyBCQm94KDAsIDAsIG1heFdpZHRoLCBtYXhIZWlnaHQpO1xuICAgIGxldCBtaW5WaXNpYmxlUmVjdCA9IG1pblJlY3QuY2xvbmUoKTtcbiAgICBpZiAobWF4VmlzaWJsZVdpZHRoID4gMCAmJiBtYXhWaXNpYmxlSGVpZ2h0ID4gMCkge1xuICAgICAgbWluVmlzaWJsZVJlY3QgPSBuZXcgQkJveCgwLCAwLCBtYXhWaXNpYmxlV2lkdGgsIG1heFZpc2libGVIZWlnaHQpO1xuICAgIH1cbiAgICByZXR1cm4geyBtaW5SZWN0LCBtaW5WaXNpYmxlUmVjdCB9O1xuICB9XG4gIGZpbHRlck1pbmlDaGFydFNlcmllcyhzZXJpZXMpIHtcbiAgICByZXR1cm4gc2VyaWVzPy5maWx0ZXIoKHMpID0+IHMuc2hvd0luTWluaUNoYXJ0ICE9PSBmYWxzZSk7XG4gIH1cbiAgYXBwbHlPcHRpb25zKG5ld0NoYXJ0T3B0aW9ucykge1xuICAgIGNvbnN0IGlzRGlmZmVyZW50T3B0cyA9IG5ld0NoYXJ0T3B0aW9ucyAhPT0gdGhpcy5jaGFydE9wdGlvbnM7XG4gICAgY29uc3Qgb2xkT3B0cyA9IGlzRGlmZmVyZW50T3B0cyA/IHRoaXMuY2hhcnRPcHRpb25zLnByb2Nlc3NlZE9wdGlvbnMgOiB7fTtcbiAgICBjb25zdCBuZXdPcHRzID0gbmV3Q2hhcnRPcHRpb25zLnByb2Nlc3NlZE9wdGlvbnM7XG4gICAgY29uc3QgZGVsdGFPcHRpb25zID0gbmV3Q2hhcnRPcHRpb25zLmRpZmZPcHRpb25zKG9sZE9wdHMpO1xuICAgIGlmIChkZWx0YU9wdGlvbnMgPT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICBkZWJ1ZyhcIkNoYXJ0LmFwcGx5T3B0aW9ucygpIC0gYXBwbHlpbmcgZGVsdGFcIiwgZGVsdGFPcHRpb25zKTtcbiAgICBjb25zdCBtb2R1bGVzQ2hhbmdlZCA9IHRoaXMuYXBwbHlNb2R1bGVzKG5ld09wdHMpO1xuICAgIGNvbnN0IHNraXAgPSBbXG4gICAgICBcInR5cGVcIixcbiAgICAgIFwiZGF0YVwiLFxuICAgICAgXCJzZXJpZXNcIixcbiAgICAgIFwibGlzdGVuZXJzXCIsXG4gICAgICBcInByZXNldFwiLFxuICAgICAgXCJ0aGVtZVwiLFxuICAgICAgXCJsZWdlbmQubGlzdGVuZXJzXCIsXG4gICAgICBcIm5hdmlnYXRvci5taW5pQ2hhcnQuc2VyaWVzXCIsXG4gICAgICBcIm5hdmlnYXRvci5taW5pQ2hhcnQubGFiZWxcIixcbiAgICAgIFwibG9jYWxlLmxvY2FsZVRleHRcIixcbiAgICAgIFwiYXhlc1wiLFxuICAgICAgXCJ0b3BvbG9neVwiLFxuICAgICAgXCJub2Rlc1wiLFxuICAgICAgXCJpbml0aWFsU3RhdGVcIixcbiAgICAgIFwic3R5bGVDb250YWluZXJcIlxuICAgIF07XG4gICAgaWYgKGRlbHRhT3B0aW9ucy5saXN0ZW5lcnMpIHtcbiAgICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnModGhpcywgZGVsdGFPcHRpb25zLmxpc3RlbmVycyk7XG4gICAgfVxuICAgIGpzb25BcHBseSh0aGlzLCBkZWx0YU9wdGlvbnMsIHsgc2tpcCB9KTtcbiAgICBsZXQgZm9yY2VOb2RlRGF0YVJlZnJlc2ggPSBmYWxzZTtcbiAgICBsZXQgc2VyaWVzU3RhdHVzID0gXCJuby1vcFwiO1xuICAgIGlmIChkZWx0YU9wdGlvbnMuc2VyaWVzICE9IG51bGwpIHtcbiAgICAgIHNlcmllc1N0YXR1cyA9IHRoaXMuYXBwbHlTZXJpZXModGhpcywgZGVsdGFPcHRpb25zLnNlcmllcywgb2xkT3B0cz8uc2VyaWVzKTtcbiAgICAgIGZvcmNlTm9kZURhdGFSZWZyZXNoID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHNlcmllc1N0YXR1cyA9PT0gXCJyZXBsYWNlZFwiKSB7XG4gICAgICB0aGlzLnJlc2V0QW5pbWF0aW9ucygpO1xuICAgIH1cbiAgICBpZiAodGhpcy5hcHBseUF4ZXModGhpcywgbmV3T3B0cywgb2xkT3B0cywgc2VyaWVzU3RhdHVzLCBbXSwgdHJ1ZSkpIHtcbiAgICAgIGZvcmNlTm9kZURhdGFSZWZyZXNoID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGRlbHRhT3B0aW9ucy5kYXRhKSB7XG4gICAgICB0aGlzLmRhdGEgPSBkZWx0YU9wdGlvbnMuZGF0YTtcbiAgICB9XG4gICAgaWYgKGRlbHRhT3B0aW9ucy5sZWdlbmQ/Lmxpc3RlbmVycyAmJiB0aGlzLm1vZHVsZXNNYW5hZ2VyLmlzRW5hYmxlZChcImxlZ2VuZFwiKSkge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLmxlZ2VuZC5saXN0ZW5lcnMsIGRlbHRhT3B0aW9ucy5sZWdlbmQubGlzdGVuZXJzKTtcbiAgICB9XG4gICAgaWYgKGRlbHRhT3B0aW9ucy5sb2NhbGU/LmxvY2FsZVRleHQpIHtcbiAgICAgIHRoaXMubW9kdWxlc01hbmFnZXIuZ2V0TW9kdWxlKFwibG9jYWxlXCIpLmxvY2FsZVRleHQgPSBkZWx0YU9wdGlvbnMubG9jYWxlPy5sb2NhbGVUZXh0O1xuICAgIH1cbiAgICB0aGlzLmNoYXJ0T3B0aW9ucyA9IG5ld0NoYXJ0T3B0aW9ucztcbiAgICBjb25zdCBuYXZpZ2F0b3JNb2R1bGUgPSB0aGlzLm1vZHVsZXNNYW5hZ2VyLmdldE1vZHVsZShcIm5hdmlnYXRvclwiKTtcbiAgICBjb25zdCB6b29tTW9kdWxlID0gdGhpcy5tb2R1bGVzTWFuYWdlci5nZXRNb2R1bGUoXCJ6b29tXCIpO1xuICAgIGlmICghbmF2aWdhdG9yTW9kdWxlPy5lbmFibGVkICYmICF6b29tTW9kdWxlPy5lbmFibGVkKSB7XG4gICAgICB0aGlzLmN0eC56b29tTWFuYWdlci51cGRhdGVab29tKFwiY2hhcnRcIik7XG4gICAgfVxuICAgIGNvbnN0IG1pbmlDaGFydCA9IG5hdmlnYXRvck1vZHVsZT8ubWluaUNoYXJ0O1xuICAgIGNvbnN0IG1pbmlDaGFydFNlcmllcyA9IG5ld09wdHMubmF2aWdhdG9yPy5taW5pQ2hhcnQ/LnNlcmllcyA/PyBuZXdPcHRzLnNlcmllcztcbiAgICBpZiAobWluaUNoYXJ0Py5lbmFibGVkID09PSB0cnVlICYmIG1pbmlDaGFydFNlcmllcyAhPSBudWxsKSB7XG4gICAgICB0aGlzLmFwcGx5TWluaUNoYXJ0T3B0aW9ucyhtaW5pQ2hhcnQsIG1pbmlDaGFydFNlcmllcywgbmV3T3B0cywgb2xkT3B0cyk7XG4gICAgfSBlbHNlIGlmIChtaW5pQ2hhcnQ/LmVuYWJsZWQgPT09IGZhbHNlKSB7XG4gICAgICBtaW5pQ2hhcnQuc2VyaWVzID0gW107XG4gICAgICBtaW5pQ2hhcnQuYXhlcyA9IFtdO1xuICAgIH1cbiAgICB0aGlzLmN0eC5hbm5vdGF0aW9uTWFuYWdlci5zZXRBbm5vdGF0aW9uU3R5bGVzKG5ld0NoYXJ0T3B0aW9ucy5hbm5vdGF0aW9uVGhlbWVzKTtcbiAgICBmb3JjZU5vZGVEYXRhUmVmcmVzaCB8fCAoZm9yY2VOb2RlRGF0YVJlZnJlc2ggPSB0aGlzLnNob3VsZEZvcmNlTm9kZURhdGFSZWZyZXNoKGRlbHRhT3B0aW9ucywgc2VyaWVzU3RhdHVzKSk7XG4gICAgY29uc3QgbWFqb3JDaGFuZ2UgPSBmb3JjZU5vZGVEYXRhUmVmcmVzaCB8fCBtb2R1bGVzQ2hhbmdlZDtcbiAgICBjb25zdCB1cGRhdGVUeXBlID0gbWFqb3JDaGFuZ2UgPyAwIC8qIEZVTEwgKi8gOiAzIC8qIFBFUkZPUk1fTEFZT1VUICovO1xuICAgIHRoaXMubWF5YmVSZXNldEFuaW1hdGlvbnMoc2VyaWVzU3RhdHVzKTtcbiAgICBkZWJ1ZyhcIkNoYXJ0LmFwcGx5T3B0aW9ucygpIC0gdXBkYXRlIHR5cGVcIiwgQ2hhcnRVcGRhdGVUeXBlW3VwZGF0ZVR5cGVdLCB7XG4gICAgICBzZXJpZXNTdGF0dXMsXG4gICAgICBmb3JjZU5vZGVEYXRhUmVmcmVzaFxuICAgIH0pO1xuICAgIHRoaXMudXBkYXRlKHVwZGF0ZVR5cGUsIHsgZm9yY2VOb2RlRGF0YVJlZnJlc2gsIG5ld0FuaW1hdGlvbkJhdGNoOiB0cnVlIH0pO1xuICAgIGlmIChkZWx0YU9wdGlvbnMuaW5pdGlhbFN0YXRlIHx8IGRlbHRhT3B0aW9ucy50aGVtZSkge1xuICAgICAgdGhpcy5hcHBseUluaXRpYWxTdGF0ZShuZXdDaGFydE9wdGlvbnMudXNlck9wdGlvbnMuaW5pdGlhbFN0YXRlKTtcbiAgICB9XG4gIH1cbiAgYXBwbHlJbml0aWFsU3RhdGUoaW5pdGlhbFN0YXRlKSB7XG4gICAgY29uc3Qge1xuICAgICAgY3R4OiB7IGFubm90YXRpb25NYW5hZ2VyLCBoaXN0b3J5TWFuYWdlciwgc3RhdGVNYW5hZ2VyIH1cbiAgICB9ID0gdGhpcztcbiAgICBpZiAoaW5pdGlhbFN0YXRlPy5hbm5vdGF0aW9ucyAhPSBudWxsKSB7XG4gICAgICBjb25zdCBhbm5vdGF0aW9uczIgPSBpbml0aWFsU3RhdGUuYW5ub3RhdGlvbnMubWFwKChhbm5vdGF0aW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IGFubm90YXRpb25UaGVtZSA9IGFubm90YXRpb25NYW5hZ2VyLmdldEFubm90YXRpb25UeXBlU3R5bGVzKGFubm90YXRpb24udHlwZSk7XG4gICAgICAgIHJldHVybiBtZXJnZURlZmF1bHRzKGFubm90YXRpb24sIGFubm90YXRpb25UaGVtZSk7XG4gICAgICB9KTtcbiAgICAgIHN0YXRlTWFuYWdlci5zZXRTdGF0ZShhbm5vdGF0aW9uTWFuYWdlciwgYW5ub3RhdGlvbnMyKTtcbiAgICB9XG4gICAgaWYgKGluaXRpYWxTdGF0ZSAhPSBudWxsKSB7XG4gICAgICBoaXN0b3J5TWFuYWdlci5jbGVhcigpO1xuICAgIH1cbiAgfVxuICBtYXliZVJlc2V0QW5pbWF0aW9ucyhzZXJpZXNTdGF0dXMpIHtcbiAgICBpZiAodGhpcy5tb2RlICE9PSBcInN0YW5kYWxvbmVcIilcbiAgICAgIHJldHVybjtcbiAgICBzd2l0Y2ggKHNlcmllc1N0YXR1cykge1xuICAgICAgY2FzZSBcInNlcmllcy1ncm91cGluZy1jaGFuZ2VcIjpcbiAgICAgIGNhc2UgXCJyZXBsYWNlZFwiOlxuICAgICAgICB0aGlzLnJlc2V0QW5pbWF0aW9ucygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgfVxuICB9XG4gIHNob3VsZEZvcmNlTm9kZURhdGFSZWZyZXNoKGRlbHRhT3B0aW9ucywgc2VyaWVzU3RhdHVzKSB7XG4gICAgY29uc3Qgc2VyaWVzRGF0YVVwZGF0ZSA9ICEhZGVsdGFPcHRpb25zLmRhdGEgfHwgc2VyaWVzU3RhdHVzID09PSBcImRhdGEtY2hhbmdlXCIgfHwgc2VyaWVzU3RhdHVzID09PSBcInJlcGxhY2VkXCI7XG4gICAgY29uc3QgbGVnZW5kS2V5cyA9IGxlZ2VuZFJlZ2lzdHJ5LmdldEtleXMoKTtcbiAgICBjb25zdCBvcHRpb25zSGF2ZUxlZ2VuZCA9IE9iamVjdC52YWx1ZXMobGVnZW5kS2V5cykuc29tZShcbiAgICAgIChsZWdlbmRLZXkpID0+IGRlbHRhT3B0aW9uc1tsZWdlbmRLZXldICE9IG51bGxcbiAgICApO1xuICAgIGNvbnN0IG90aGVyUmVmcmVzaFVwZGF0ZSA9IGRlbHRhT3B0aW9ucy50aXRsZSAhPSBudWxsICYmIGRlbHRhT3B0aW9ucy5zdWJ0aXRsZSAhPSBudWxsO1xuICAgIHJldHVybiBzZXJpZXNEYXRhVXBkYXRlIHx8IG9wdGlvbnNIYXZlTGVnZW5kIHx8IG90aGVyUmVmcmVzaFVwZGF0ZTtcbiAgfVxuICBhcHBseU1pbmlDaGFydE9wdGlvbnMobWluaUNoYXJ0LCBtaW5pQ2hhcnRTZXJpZXMsIGNvbXBsZXRlT3B0aW9ucywgb2xkT3B0cykge1xuICAgIGNvbnN0IG9sZFNlcmllcyA9IG9sZE9wdHM/Lm5hdmlnYXRvcj8ubWluaUNoYXJ0Py5zZXJpZXMgPz8gb2xkT3B0cz8uc2VyaWVzO1xuICAgIGNvbnN0IG1pbmlDaGFydFNlcmllc1N0YXR1cyA9IHRoaXMuYXBwbHlTZXJpZXMoXG4gICAgICBtaW5pQ2hhcnQsXG4gICAgICB0aGlzLmZpbHRlck1pbmlDaGFydFNlcmllcyhtaW5pQ2hhcnRTZXJpZXMpLFxuICAgICAgdGhpcy5maWx0ZXJNaW5pQ2hhcnRTZXJpZXMob2xkU2VyaWVzKVxuICAgICk7XG4gICAgdGhpcy5hcHBseUF4ZXMobWluaUNoYXJ0LCBjb21wbGV0ZU9wdGlvbnMsIG9sZE9wdHMsIG1pbmlDaGFydFNlcmllc1N0YXR1cywgW1xuICAgICAgXCJheGVzW10udGlja1wiLFxuICAgICAgXCJheGVzW10udGhpY2tuZXNzXCIsXG4gICAgICBcImF4ZXNbXS50aXRsZVwiLFxuICAgICAgXCJheGVzW10uY3Jvc3NoYWlyXCIsXG4gICAgICBcImF4ZXNbXS5ncmlkTGluZVwiLFxuICAgICAgXCJheGVzW10ubGFiZWxcIlxuICAgIF0pO1xuICAgIGNvbnN0IHNlcmllcyA9IG1pbmlDaGFydC5zZXJpZXM7XG4gICAgZm9yIChjb25zdCBzIG9mIHNlcmllcykge1xuICAgICAgcy5wcm9wZXJ0aWVzLmlkID0gdm9pZCAwO1xuICAgIH1cbiAgICBjb25zdCBheGVzID0gbWluaUNoYXJ0LmF4ZXM7XG4gICAgY29uc3QgaG9yaXpvbnRhbEF4aXMgPSBheGVzLmZpbmQoKGF4aXMpID0+IGF4aXMuZGlyZWN0aW9uID09PSBcInhcIiAvKiBYICovKTtcbiAgICBmb3IgKGNvbnN0IGF4aXMgb2YgYXhlcykge1xuICAgICAgYXhpcy5ncmlkTGluZS5lbmFibGVkID0gZmFsc2U7XG4gICAgICBheGlzLmxhYmVsLmVuYWJsZWQgPSBheGlzID09PSBob3Jpem9udGFsQXhpcztcbiAgICAgIGF4aXMudGljay5lbmFibGVkID0gZmFsc2U7XG4gICAgICBheGlzLmludGVyYWN0aW9uRW5hYmxlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaG9yaXpvbnRhbEF4aXMgIT0gbnVsbCkge1xuICAgICAgY29uc3QgbWluaUNoYXJ0T3B0cyA9IGNvbXBsZXRlT3B0aW9ucy5uYXZpZ2F0b3I/Lm1pbmlDaGFydDtcbiAgICAgIGNvbnN0IGxhYmVsT3B0aW9ucyA9IG1pbmlDaGFydE9wdHM/LmxhYmVsO1xuICAgICAgY29uc3QgaW50ZXJ2YWxPcHRpb25zID0gbWluaUNoYXJ0T3B0cz8ubGFiZWw/LmludGVydmFsO1xuICAgICAgaG9yaXpvbnRhbEF4aXMubGluZS5lbmFibGVkID0gZmFsc2U7XG4gICAgICBob3Jpem9udGFsQXhpcy5sYWJlbC5zZXQoXG4gICAgICAgIHdpdGhvdXQobGFiZWxPcHRpb25zLCBbXCJpbnRlcnZhbFwiLCBcInJvdGF0aW9uXCIsIFwibWluU3BhY2luZ1wiLCBcImF1dG9Sb3RhdGVcIiwgXCJhdXRvUm90YXRlQW5nbGVcIl0pXG4gICAgICApO1xuICAgICAgaG9yaXpvbnRhbEF4aXMudGljay5zZXQoXG4gICAgICAgIHdpdGhvdXQoaW50ZXJ2YWxPcHRpb25zLCBbXCJlbmFibGVkXCIsIFwid2lkdGhcIiwgXCJzaXplXCIsIFwiY29sb3JcIiwgXCJpbnRlcnZhbFwiLCBcInN0ZXBcIl0pXG4gICAgICApO1xuICAgICAgY29uc3Qgc3RlcCA9IGludGVydmFsT3B0aW9ucz8uc3RlcDtcbiAgICAgIGlmIChzdGVwICE9IG51bGwpIHtcbiAgICAgICAgaG9yaXpvbnRhbEF4aXMuaW50ZXJ2YWwuc3RlcCA9IHN0ZXA7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFwcGx5TW9kdWxlcyhvcHRpb25zKSB7XG4gICAgY29uc3QgeyB0eXBlOiBjaGFydFR5cGUyIH0gPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgIGxldCBtb2R1bGVzQ2hhbmdlZCA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgbW9kdWxlIG9mIG1vZHVsZVJlZ2lzdHJ5LmJ5VHlwZShcInJvb3RcIiwgXCJsZWdlbmRcIikpIHtcbiAgICAgIGNvbnN0IGlzQ29uZmlndXJlZCA9IG9wdGlvbnNbbW9kdWxlLm9wdGlvbnNLZXldICE9IG51bGw7XG4gICAgICBjb25zdCBzaG91bGRCZUVuYWJsZWQgPSBpc0NvbmZpZ3VyZWQgJiYgbW9kdWxlLmNoYXJ0VHlwZXMuaW5jbHVkZXMoY2hhcnRUeXBlMik7XG4gICAgICBpZiAoc2hvdWxkQmVFbmFibGVkID09PSB0aGlzLm1vZHVsZXNNYW5hZ2VyLmlzRW5hYmxlZChtb2R1bGUpKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGlmIChzaG91bGRCZUVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5tb2R1bGVzTWFuYWdlci5hZGRNb2R1bGUobW9kdWxlLCAobSkgPT4gbS5tb2R1bGVGYWN0b3J5KHRoaXMuZ2V0TW9kdWxlQ29udGV4dCgpKSk7XG4gICAgICAgIGlmIChtb2R1bGUudHlwZSA9PT0gXCJsZWdlbmRcIikge1xuICAgICAgICAgIHRoaXMubW9kdWxlc01hbmFnZXIuZ2V0TW9kdWxlKG1vZHVsZSk/LmF0dGFjaExlZ2VuZCh0aGlzLmN0eC5zY2VuZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1ttb2R1bGUub3B0aW9uc0tleV0gPSB0aGlzLm1vZHVsZXNNYW5hZ2VyLmdldE1vZHVsZShtb2R1bGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tb2R1bGVzTWFuYWdlci5yZW1vdmVNb2R1bGUobW9kdWxlKTtcbiAgICAgICAgZGVsZXRlIHRoaXNbbW9kdWxlLm9wdGlvbnNLZXldO1xuICAgICAgfVxuICAgICAgbW9kdWxlc0NoYW5nZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gbW9kdWxlc0NoYW5nZWQ7XG4gIH1cbiAgaW5pdFNlcmllc0RlY2xhcmF0aW9uT3JkZXIoc2VyaWVzKSB7XG4gICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgc2VyaWVzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgIHNlcmllc1tpZHhdLl9kZWNsYXJhdGlvbk9yZGVyID0gaWR4O1xuICAgIH1cbiAgfVxuICBhcHBseVNlcmllcyhjaGFydCwgb3B0U2VyaWVzLCBvbGRPcHRTZXJpZXMpIHtcbiAgICBpZiAoIW9wdFNlcmllcykge1xuICAgICAgcmV0dXJuIFwibm8tY2hhbmdlXCI7XG4gICAgfVxuICAgIGNvbnN0IG1hdGNoUmVzdWx0ID0gbWF0Y2hTZXJpZXNPcHRpb25zKGNoYXJ0LnNlcmllcywgb3B0U2VyaWVzLCBvbGRPcHRTZXJpZXMpO1xuICAgIGlmIChtYXRjaFJlc3VsdC5zdGF0dXMgPT09IFwibm8tb3ZlcmxhcFwiKSB7XG4gICAgICBkZWJ1ZyhgQ2hhcnQuYXBwbHlTZXJpZXMoKSAtIGNyZWF0aW5nIG5ldyBzZXJpZXMgaW5zdGFuY2VzLCBzdGF0dXM6ICR7bWF0Y2hSZXN1bHQuc3RhdHVzfWAsIG1hdGNoUmVzdWx0KTtcbiAgICAgIGNoYXJ0LnNlcmllcyA9IG9wdFNlcmllcy5tYXAoKG9wdHMpID0+IHRoaXMuY3JlYXRlU2VyaWVzKG9wdHMpKTtcbiAgICAgIHRoaXMuaW5pdFNlcmllc0RlY2xhcmF0aW9uT3JkZXIoY2hhcnQuc2VyaWVzKTtcbiAgICAgIHJldHVybiBcInJlcGxhY2VkXCI7XG4gICAgfVxuICAgIGRlYnVnKGBDaGFydC5hcHBseVNlcmllcygpIC0gbWF0Y2hSZXN1bHRgLCBtYXRjaFJlc3VsdCk7XG4gICAgY29uc3Qgc2VyaWVzSW5zdGFuY2VzID0gW107XG4gICAgbGV0IGRhdGFDaGFuZ2VkID0gZmFsc2U7XG4gICAgbGV0IGdyb3VwaW5nQ2hhbmdlZCA9IGZhbHNlO1xuICAgIGxldCBpc1VwZGF0ZWQgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IGNoYW5nZSBvZiBtYXRjaFJlc3VsdC5jaGFuZ2VzKSB7XG4gICAgICBncm91cGluZ0NoYW5nZWQgfHwgKGdyb3VwaW5nQ2hhbmdlZCA9IGNoYW5nZS5zdGF0dXMgPT09IFwic2VyaWVzLWdyb3VwaW5nXCIpO1xuICAgICAgZGF0YUNoYW5nZWQgfHwgKGRhdGFDaGFuZ2VkID0gY2hhbmdlLmRpZmY/LmRhdGEgIT0gbnVsbCk7XG4gICAgICBpc1VwZGF0ZWQgfHwgKGlzVXBkYXRlZCA9IGNoYW5nZS5zdGF0dXMgIT09IFwibm8tb3BcIik7XG4gICAgICBzd2l0Y2ggKGNoYW5nZS5zdGF0dXMpIHtcbiAgICAgICAgY2FzZSBcImFkZFwiOiB7XG4gICAgICAgICAgY29uc3QgbmV3U2VyaWVzID0gdGhpcy5jcmVhdGVTZXJpZXMoY2hhbmdlLm9wdHMpO1xuICAgICAgICAgIHNlcmllc0luc3RhbmNlcy5wdXNoKG5ld1Nlcmllcyk7XG4gICAgICAgICAgZGVidWcoYENoYXJ0LmFwcGx5U2VyaWVzKCkgLSBjcmVhdGVkIG5ldyBzZXJpZXNgLCBuZXdTZXJpZXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJyZW1vdmVcIjpcbiAgICAgICAgICBkZWJ1ZyhgQ2hhcnQuYXBwbHlTZXJpZXMoKSAtIHJlbW92aW5nIHNlcmllcyBhdCBwcmV2aW91cyBpZHggJHtjaGFuZ2UuaWR4fWAsIGNoYW5nZS5zZXJpZXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibm8tb3BcIjpcbiAgICAgICAgICBzZXJpZXNJbnN0YW5jZXMucHVzaChjaGFuZ2Uuc2VyaWVzKTtcbiAgICAgICAgICBkZWJ1ZyhgQ2hhcnQuYXBwbHlTZXJpZXMoKSAtIG5vIGNoYW5nZSB0byBzZXJpZXMgYXQgcHJldmlvdXMgaWR4ICR7Y2hhbmdlLmlkeH1gLCBjaGFuZ2Uuc2VyaWVzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNlcmllcy1ncm91cGluZ1wiOlxuICAgICAgICBjYXNlIFwidXBkYXRlXCI6XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICBjb25zdCB7IHNlcmllcywgZGlmZjogZGlmZjIsIGlkeCB9ID0gY2hhbmdlO1xuICAgICAgICAgIGRlYnVnKGBDaGFydC5hcHBseVNlcmllcygpIC0gYXBwbHlpbmcgc2VyaWVzIGRpZmYgcHJldmlvdXMgaWR4ICR7aWR4fWAsIGRpZmYyLCBzZXJpZXMpO1xuICAgICAgICAgIHRoaXMuYXBwbHlTZXJpZXNWYWx1ZXMoc2VyaWVzLCBkaWZmMik7XG4gICAgICAgICAgc2VyaWVzLm1hcmtOb2RlRGF0YURpcnR5KCk7XG4gICAgICAgICAgc2VyaWVzSW5zdGFuY2VzLnB1c2goc2VyaWVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmluaXRTZXJpZXNEZWNsYXJhdGlvbk9yZGVyKHNlcmllc0luc3RhbmNlcyk7XG4gICAgZGVidWcoYENoYXJ0LmFwcGx5U2VyaWVzKCkgLSBmaW5hbCBzZXJpZXMgaW5zdGFuY2VzYCwgc2VyaWVzSW5zdGFuY2VzKTtcbiAgICBjaGFydC5zZXJpZXMgPSBzZXJpZXNJbnN0YW5jZXM7XG4gICAgaWYgKGdyb3VwaW5nQ2hhbmdlZCkge1xuICAgICAgcmV0dXJuIFwic2VyaWVzLWdyb3VwaW5nLWNoYW5nZVwiO1xuICAgIH1cbiAgICBpZiAoZGF0YUNoYW5nZWQpIHtcbiAgICAgIHJldHVybiBcImRhdGEtY2hhbmdlXCI7XG4gICAgfVxuICAgIHJldHVybiBpc1VwZGF0ZWQgPyBcInVwZGF0ZWRcIiA6IFwibm8tb3BcIjtcbiAgfVxuICBhcHBseUF4ZXMoY2hhcnQsIG9wdGlvbnMsIG9sZE9wdHMsIHNlcmllc1N0YXR1cywgc2tpcCA9IFtdLCByZWdpc3RlclJlZ2lvbnMgPSBmYWxzZSkge1xuICAgIGlmICghKFwiYXhlc1wiIGluIG9wdGlvbnMpIHx8ICFvcHRpb25zLmF4ZXMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc2tpcCA9IFtcImF4ZXNbXS50eXBlXCIsIC4uLnNraXBdO1xuICAgIGNvbnN0IHsgYXhlcyB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBmb3JjZVJlY3JlYXRlID0gc2VyaWVzU3RhdHVzID09PSBcInJlcGxhY2VkXCI7XG4gICAgY29uc3QgbWF0Y2hpbmdUeXBlcyA9ICFmb3JjZVJlY3JlYXRlICYmIGNoYXJ0LmF4ZXMubGVuZ3RoID09PSBheGVzLmxlbmd0aCAmJiBjaGFydC5heGVzLmV2ZXJ5KChhLCBpKSA9PiBhLnR5cGUgPT09IGF4ZXNbaV0udHlwZSk7XG4gICAgaWYgKG1hdGNoaW5nVHlwZXMgJiYgaXNBZ0NhcnRlc2lhbkNoYXJ0T3B0aW9ucyhvbGRPcHRzKSkge1xuICAgICAgY2hhcnQuYXhlcy5mb3JFYWNoKChheGlzLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBwcmV2aW91c09wdHMgPSBvbGRPcHRzLmF4ZXM/LltpbmRleF0gPz8ge307XG4gICAgICAgIGNvbnN0IGF4aXNEaWZmID0ganNvbkRpZmYocHJldmlvdXNPcHRzLCBheGVzW2luZGV4XSk7XG4gICAgICAgIGRlYnVnKGBDaGFydC5hcHBseUF4ZXMoKSAtIGFwcGx5aW5nIGF4aXMgZGlmZiBpZHggJHtpbmRleH1gLCBheGlzRGlmZik7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgYXhlc1ske2luZGV4fV1gO1xuICAgICAgICBqc29uQXBwbHkoYXhpcywgYXhpc0RpZmYsIHsgcGF0aCwgc2tpcCB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGRlYnVnKGBDaGFydC5hcHBseUF4ZXMoKSAtIGNyZWF0aW5nIG5ldyBheGVzIGluc3RhbmNlczsgc2VyaWVzU3RhdHVzOiAke3Nlcmllc1N0YXR1c31gKTtcbiAgICBjaGFydC5heGVzID0gdGhpcy5jcmVhdGVBeGlzKGF4ZXMsIHNraXApO1xuICAgIGNvbnN0IGF4aXNHcm91cHMgPSB7XG4gICAgICBbXCJ4XCIgLyogWCAqL106IFtdLFxuICAgICAgW1wieVwiIC8qIFkgKi9dOiBbXVxuICAgIH07XG4gICAgY2hhcnQuYXhlcy5mb3JFYWNoKChheGlzKSA9PiB7XG4gICAgICBjb25zdCB7IGlkIH0gPSBheGlzO1xuICAgICAgY29uc3Qgbm9kZSA9IGF4aXMuZ2V0UmVnaW9uTm9kZSgpO1xuICAgICAgaWYgKG5vZGUgIT0gbnVsbCkge1xuICAgICAgICBheGlzR3JvdXBzW2F4aXMuZGlyZWN0aW9uXS5wdXNoKHsgaWQsIG5vZGUgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHJlZ2lzdGVyUmVnaW9ucykge1xuICAgICAgdGhpcy5jdHgucmVnaW9uTWFuYWdlci51cGRhdGVSZWdpb24oXCJob3Jpem9udGFsLWF4ZXNcIiAvKiBIT1JJWk9OVEFMX0FYRVMgKi8sIC4uLmF4aXNHcm91cHNbXCJ4XCIgLyogWCAqL10pO1xuICAgICAgdGhpcy5jdHgucmVnaW9uTWFuYWdlci51cGRhdGVSZWdpb24oXCJ2ZXJ0aWNhbC1heGVzXCIgLyogVkVSVElDQUxfQVhFUyAqLywgLi4uYXhpc0dyb3Vwc1tcInlcIiAvKiBZICovXSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNyZWF0ZVNlcmllcyhzZXJpZXNPcHRpb25zKSB7XG4gICAgY29uc3Qgc2VyaWVzSW5zdGFuY2UgPSBzZXJpZXNSZWdpc3RyeS5jcmVhdGUoc2VyaWVzT3B0aW9ucy50eXBlLCB0aGlzLmdldE1vZHVsZUNvbnRleHQoKSk7XG4gICAgdGhpcy5hcHBseVNlcmllc09wdGlvbk1vZHVsZXMoc2VyaWVzSW5zdGFuY2UsIHNlcmllc09wdGlvbnMpO1xuICAgIHRoaXMuYXBwbHlTZXJpZXNWYWx1ZXMoc2VyaWVzSW5zdGFuY2UsIHNlcmllc09wdGlvbnMpO1xuICAgIHJldHVybiBzZXJpZXNJbnN0YW5jZTtcbiAgfVxuICBhcHBseVNlcmllc09wdGlvbk1vZHVsZXMoc2VyaWVzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbW9kdWxlQ29udGV4dCA9IHNlcmllcy5jcmVhdGVNb2R1bGVDb250ZXh0KCk7XG4gICAgY29uc3QgbW9kdWxlTWFwID0gc2VyaWVzLmdldE1vZHVsZU1hcCgpO1xuICAgIGZvciAoY29uc3QgbW9kdWxlIG9mIG1vZHVsZVJlZ2lzdHJ5LmJ5VHlwZShcInNlcmllcy1vcHRpb25cIikpIHtcbiAgICAgIGlmIChtb2R1bGUub3B0aW9uc0tleSBpbiBvcHRpb25zICYmIG1vZHVsZS5zZXJpZXNUeXBlcy5pbmNsdWRlcyhzZXJpZXMudHlwZSkpIHtcbiAgICAgICAgbW9kdWxlTWFwLmFkZE1vZHVsZShtb2R1bGUsIChtKSA9PiBtLm1vZHVsZUZhY3RvcnkobW9kdWxlQ29udGV4dCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhcHBseVNlcmllc1ZhbHVlcyh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBtb2R1bGVNYXAgPSB0YXJnZXQuZ2V0TW9kdWxlTWFwKCk7XG4gICAgY29uc3QgeyB0eXBlOiBfLCBkYXRhLCBsaXN0ZW5lcnMsIHNlcmllc0dyb3VwaW5nLCBzaG93SW5NaW5pQ2hhcnQ6IF9fLCAuLi5zZXJpZXNPcHRpb25zIH0gPSBvcHRpb25zO1xuICAgIGZvciAoY29uc3QgbW9kdWxlRGVmIG9mIEVYUEVDVEVEX0VOVEVSUFJJU0VfTU9EVUxFUykge1xuICAgICAgaWYgKG1vZHVsZURlZi50eXBlICE9PSBcInNlcmllcy1vcHRpb25cIilcbiAgICAgICAgY29udGludWU7XG4gICAgICBpZiAobW9kdWxlRGVmLm9wdGlvbnNLZXkgaW4gc2VyaWVzT3B0aW9ucykge1xuICAgICAgICBjb25zdCBtb2R1bGUgPSBtb2R1bGVNYXAuZ2V0TW9kdWxlKG1vZHVsZURlZi5vcHRpb25zS2V5KTtcbiAgICAgICAgaWYgKG1vZHVsZSkge1xuICAgICAgICAgIGNvbnN0IG1vZHVsZU9wdGlvbnMgPSBzZXJpZXNPcHRpb25zW21vZHVsZURlZi5vcHRpb25zS2V5XTtcbiAgICAgICAgICBkZWxldGUgc2VyaWVzT3B0aW9uc1ttb2R1bGVEZWYub3B0aW9uc0tleV07XG4gICAgICAgICAgbW9kdWxlLnByb3BlcnRpZXMuc2V0KG1vZHVsZU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRhcmdldC5wcm9wZXJ0aWVzLnNldChzZXJpZXNPcHRpb25zKTtcbiAgICBpZiAoXCJkYXRhXCIgaW4gb3B0aW9ucykge1xuICAgICAgdGFyZ2V0LnNldE9wdGlvbnNEYXRhKGRhdGEpO1xuICAgIH1cbiAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKHRhcmdldCwgbGlzdGVuZXJzKTtcbiAgICB9XG4gICAgaWYgKFwic2VyaWVzR3JvdXBpbmdcIiBpbiBvcHRpb25zKSB7XG4gICAgICBpZiAoc2VyaWVzR3JvdXBpbmcgPT0gbnVsbCkge1xuICAgICAgICB0YXJnZXQuc2VyaWVzR3JvdXBpbmcgPSB2b2lkIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXQuc2VyaWVzR3JvdXBpbmcgPSB7IC4uLnRhcmdldC5zZXJpZXNHcm91cGluZywgLi4uc2VyaWVzR3JvdXBpbmcgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY3JlYXRlQXhpcyhvcHRpb25zLCBza2lwKSB7XG4gICAgY29uc3QgbmV3QXhlcyA9IFtdO1xuICAgIGNvbnN0IG1vZHVsZUNvbnRleHQgPSB0aGlzLmdldE1vZHVsZUNvbnRleHQoKTtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgb3B0aW9ucy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGNvbnN0IGF4aXNPcHRpb25zID0gb3B0aW9uc1tpbmRleF07XG4gICAgICBjb25zdCBheGlzID0gYXhpc1JlZ2lzdHJ5LmNyZWF0ZShheGlzT3B0aW9ucy50eXBlLCBtb2R1bGVDb250ZXh0KTtcbiAgICAgIHRoaXMuYXBwbHlBeGlzTW9kdWxlcyhheGlzLCBheGlzT3B0aW9ucyk7XG4gICAgICBqc29uQXBwbHkoYXhpcywgYXhpc09wdGlvbnMsIHsgcGF0aDogYGF4ZXNbJHtpbmRleH1dYCwgc2tpcCB9KTtcbiAgICAgIG5ld0F4ZXMucHVzaChheGlzKTtcbiAgICB9XG4gICAgZ3Vlc3NJbnZhbGlkUG9zaXRpb25zKG5ld0F4ZXMpO1xuICAgIHJldHVybiBuZXdBeGVzO1xuICB9XG4gIGFwcGx5QXhpc01vZHVsZXMoYXhpcywgb3B0aW9ucykge1xuICAgIGNvbnN0IG1vZHVsZUNvbnRleHQgPSBheGlzLmNyZWF0ZU1vZHVsZUNvbnRleHQoKTtcbiAgICBjb25zdCBtb2R1bGVNYXAgPSBheGlzLmdldE1vZHVsZU1hcCgpO1xuICAgIGZvciAoY29uc3QgbW9kdWxlIG9mIG1vZHVsZVJlZ2lzdHJ5LmJ5VHlwZShcImF4aXMtb3B0aW9uXCIpKSB7XG4gICAgICBjb25zdCBzaG91bGRCZUVuYWJsZWQgPSBvcHRpb25zW21vZHVsZS5vcHRpb25zS2V5XSAhPSBudWxsO1xuICAgICAgaWYgKHNob3VsZEJlRW5hYmxlZCA9PT0gbW9kdWxlTWFwLmlzRW5hYmxlZChtb2R1bGUpKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGlmIChzaG91bGRCZUVuYWJsZWQpIHtcbiAgICAgICAgbW9kdWxlTWFwLmFkZE1vZHVsZShtb2R1bGUsIChtKSA9PiBtLm1vZHVsZUZhY3RvcnkobW9kdWxlQ29udGV4dCkpO1xuICAgICAgICBheGlzW21vZHVsZS5vcHRpb25zS2V5XSA9IG1vZHVsZU1hcC5nZXRNb2R1bGUobW9kdWxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1vZHVsZU1hcC5yZW1vdmVNb2R1bGUobW9kdWxlKTtcbiAgICAgICAgZGVsZXRlIGF4aXNbbW9kdWxlLm9wdGlvbnNLZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZWdpc3Rlckxpc3RlbmVycyhzb3VyY2UsIGxpc3RlbmVycykge1xuICAgIHNvdXJjZS5jbGVhckV2ZW50TGlzdGVuZXJzKCk7XG4gICAgZm9yIChjb25zdCBbcHJvcGVydHksIGxpc3RlbmVyXSBvZiBPYmplY3QuZW50cmllcyhsaXN0ZW5lcnMpKSB7XG4gICAgICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcikpIHtcbiAgICAgICAgc291cmNlLmFkZEV2ZW50TGlzdGVuZXIocHJvcGVydHksIGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5fQ2hhcnQuY2hhcnRzSW5zdGFuY2VzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBBY3Rpb25PblNldCh7XG4gICAgbmV3VmFsdWUodmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5jdHguZG9tTWFuYWdlci5zZXRDb250YWluZXIodmFsdWUpO1xuICAgICAgX0NoYXJ0LmNoYXJ0c0luc3RhbmNlcy5zZXQodmFsdWUsIHRoaXMpO1xuICAgIH0sXG4gICAgb2xkVmFsdWUodmFsdWUpIHtcbiAgICAgIF9DaGFydC5jaGFydHNJbnN0YW5jZXMuZGVsZXRlKHZhbHVlKTtcbiAgICB9XG4gIH0pXG5dLCBfQ2hhcnQucHJvdG90eXBlLCBcImNvbnRhaW5lclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEFjdGlvbk9uU2V0KHtcbiAgICBuZXdWYWx1ZSh2YWx1ZSkge1xuICAgICAgdGhpcy5yZXNpemUoXCJ3aWR0aCBvcHRpb25cIiwgeyBpbldpZHRoOiB2YWx1ZSB9KTtcbiAgICB9XG4gIH0pXG5dLCBfQ2hhcnQucHJvdG90eXBlLCBcIndpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgQWN0aW9uT25TZXQoe1xuICAgIG5ld1ZhbHVlKHZhbHVlKSB7XG4gICAgICB0aGlzLnJlc2l6ZShcImhlaWdodCBvcHRpb25cIiwgeyBpbkhlaWdodDogdmFsdWUgfSk7XG4gICAgfVxuICB9KVxuXSwgX0NoYXJ0LnByb3RvdHlwZSwgXCJoZWlnaHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBBY3Rpb25PblNldCh7XG4gICAgbmV3VmFsdWUodmFsdWUpIHtcbiAgICAgIHRoaXMucmVzaXplKFwibWluV2lkdGggb3B0aW9uXCIsIHsgaW5NaW5XaWR0aDogdmFsdWUgfSk7XG4gICAgfVxuICB9KVxuXSwgX0NoYXJ0LnByb3RvdHlwZSwgXCJtaW5XaWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEFjdGlvbk9uU2V0KHtcbiAgICBuZXdWYWx1ZSh2YWx1ZSkge1xuICAgICAgdGhpcy5yZXNpemUoXCJtaW5IZWlnaHQgb3B0aW9uXCIsIHsgaW5NaW5IZWlnaHQ6IHZhbHVlIH0pO1xuICAgIH1cbiAgfSlcbl0sIF9DaGFydC5wcm90b3R5cGUsIFwibWluSGVpZ2h0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgX0NoYXJ0LnByb3RvdHlwZSwgXCJwYWRkaW5nXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgX0NoYXJ0LnByb3RvdHlwZSwgXCJzZXJpZXNBcmVhXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgX0NoYXJ0LnByb3RvdHlwZSwgXCJrZXlib2FyZFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFVOSU9OKFtcInN0YW5kYWxvbmVcIiwgXCJpbnRlZ3JhdGVkXCJdLCBcImEgY2hhcnQgbW9kZVwiKSlcbl0sIF9DaGFydC5wcm90b3R5cGUsIFwibW9kZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHkoXCJjaGFydENhcHRpb25zLnRpdGxlXCIpXG5dLCBfQ2hhcnQucHJvdG90eXBlLCBcInRpdGxlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgUHJveHlQcm9wZXJ0eShcImNoYXJ0Q2FwdGlvbnMuc3VidGl0bGVcIilcbl0sIF9DaGFydC5wcm90b3R5cGUsIFwic3VidGl0bGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBQcm94eVByb3BlcnR5KFwiY2hhcnRDYXB0aW9ucy5mb290bm90ZVwiKVxuXSwgX0NoYXJ0LnByb3RvdHlwZSwgXCJmb290bm90ZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEFjdGlvbk9uU2V0KHtcbiAgICBjaGFuZ2VWYWx1ZShuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgIHRoaXMub25BeGlzQ2hhbmdlKG5ld1ZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgfVxuICB9KVxuXSwgX0NoYXJ0LnByb3RvdHlwZSwgXCJheGVzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgQWN0aW9uT25TZXQoe1xuICAgIGNoYW5nZVZhbHVlKG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgdGhpcy5vblNlcmllc0NoYW5nZShuZXdWYWx1ZSwgb2xkVmFsdWUpO1xuICAgIH1cbiAgfSlcbl0sIF9DaGFydC5wcm90b3R5cGUsIFwic2VyaWVzXCIsIDIpO1xudmFyIENoYXJ0ID0gX0NoYXJ0O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS91dGlsL3F1YWR0cmVlLnRzXG52YXIgUXVhZHRyZWVOZWFyZXN0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjYXBhY2l0eSwgbWF4ZGVwdGgsIGJvdW5kYXJ5KSB7XG4gICAgdGhpcy5yb290ID0gbmV3IFF1YWR0cmVlTm9kZU5lYXJlc3QoY2FwYWNpdHksIG1heGRlcHRoLCBib3VuZGFyeSk7XG4gIH1cbiAgY2xlYXIoYm91bmRhcnkpIHtcbiAgICB0aGlzLnJvb3QuY2xlYXIoYm91bmRhcnkpO1xuICB9XG4gIGFkZFZhbHVlKGhpdFRlc3RlciwgdmFsdWUpIHtcbiAgICBjb25zdCBlbGVtID0ge1xuICAgICAgaGl0VGVzdGVyLFxuICAgICAgdmFsdWUsXG4gICAgICBkaXN0YW5jZVNxdWFyZWQ6ICh4LCB5KSA9PiB7XG4gICAgICAgIHJldHVybiBoaXRUZXN0ZXIuZGlzdGFuY2VTcXVhcmVkKHgsIHkpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5yb290LmFkZEVsZW0oZWxlbSk7XG4gIH1cbiAgZmluZCh4LCB5KSB7XG4gICAgY29uc3QgYXJnID0geyBiZXN0OiB7IG5lYXJlc3Q6IHZvaWQgMCwgZGlzdGFuY2VTcXVhcmVkOiBJbmZpbml0eSB9IH07XG4gICAgdGhpcy5yb290LmZpbmQoeCwgeSwgYXJnKTtcbiAgICByZXR1cm4gYXJnLmJlc3Q7XG4gIH1cbn07XG52YXIgUXVhZHRyZWVTdWJkaXZpc2lvbnMgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG53LCBuZSwgc3csIHNlKSB7XG4gICAgdGhpcy5udyA9IG53O1xuICAgIHRoaXMubmUgPSBuZTtcbiAgICB0aGlzLnN3ID0gc3c7XG4gICAgdGhpcy5zZSA9IHNlO1xuICB9XG4gIGFkZEVsZW0oZWxlbSkge1xuICAgIHRoaXMubncuYWRkRWxlbShlbGVtKTtcbiAgICB0aGlzLm5lLmFkZEVsZW0oZWxlbSk7XG4gICAgdGhpcy5zdy5hZGRFbGVtKGVsZW0pO1xuICAgIHRoaXMuc2UuYWRkRWxlbShlbGVtKTtcbiAgfVxuICBmaW5kKHgsIHksIGFyZykge1xuICAgIHRoaXMubncuZmluZCh4LCB5LCBhcmcpO1xuICAgIHRoaXMubmUuZmluZCh4LCB5LCBhcmcpO1xuICAgIHRoaXMuc3cuZmluZCh4LCB5LCBhcmcpO1xuICAgIHRoaXMuc2UuZmluZCh4LCB5LCBhcmcpO1xuICB9XG59O1xudmFyIFF1YWR0cmVlTm9kZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2FwYWNpdHksIG1heGRlcHRoLCBib3VuZGFyeSkge1xuICAgIHRoaXMuY2FwYWNpdHkgPSBjYXBhY2l0eTtcbiAgICB0aGlzLm1heGRlcHRoID0gbWF4ZGVwdGg7XG4gICAgdGhpcy5ib3VuZGFyeSA9IGJvdW5kYXJ5ID8/IEJCb3guTmFOO1xuICAgIHRoaXMuZWxlbXMgPSBbXTtcbiAgICB0aGlzLnN1YmRpdmlzaW9ucyA9IHZvaWQgMDtcbiAgfVxuICBjbGVhcihib3VuZGFyeSkge1xuICAgIHRoaXMuZWxlbXMubGVuZ3RoID0gMDtcbiAgICB0aGlzLmJvdW5kYXJ5ID0gYm91bmRhcnk7XG4gICAgdGhpcy5zdWJkaXZpc2lvbnMgPSB2b2lkIDA7XG4gIH1cbiAgYWRkRWxlbShlKSB7XG4gICAgaWYgKHRoaXMuYWRkQ29uZGl0aW9uKGUpKSB7XG4gICAgICBpZiAodGhpcy5zdWJkaXZpc2lvbnMgPT09IHZvaWQgMCkge1xuICAgICAgICBpZiAodGhpcy5tYXhkZXB0aCA9PT0gMCB8fCB0aGlzLmVsZW1zLmxlbmd0aCA8IHRoaXMuY2FwYWNpdHkpIHtcbiAgICAgICAgICB0aGlzLmVsZW1zLnB1c2goZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdWJkaXZpZGUoZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3ViZGl2aXNpb25zLmFkZEVsZW0oZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZpbmQoeCwgeSwgYXJnKSB7XG4gICAgaWYgKHRoaXMuZmluZENvbmRpdGlvbih4LCB5LCBhcmcpKSB7XG4gICAgICBpZiAodGhpcy5zdWJkaXZpc2lvbnMgPT09IHZvaWQgMCkge1xuICAgICAgICB0aGlzLmZpbmRBY3Rpb24oeCwgeSwgYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3ViZGl2aXNpb25zLmZpbmQoeCwgeSwgYXJnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc3ViZGl2aWRlKG5ld0VsZW0pIHtcbiAgICB0aGlzLnN1YmRpdmlzaW9ucyA9IHRoaXMubWFrZVN1YmRpdmlzaW9ucygpO1xuICAgIGZvciAoY29uc3QgZSBvZiB0aGlzLmVsZW1zKSB7XG4gICAgICB0aGlzLnN1YmRpdmlzaW9ucy5hZGRFbGVtKGUpO1xuICAgIH1cbiAgICB0aGlzLnN1YmRpdmlzaW9ucy5hZGRFbGVtKG5ld0VsZW0pO1xuICAgIHRoaXMuZWxlbXMubGVuZ3RoID0gMDtcbiAgfVxuICBtYWtlU3ViZGl2aXNpb25zKCkge1xuICAgIGNvbnN0IHsgeCwgeSwgd2lkdGg6IHdpZHRoMiwgaGVpZ2h0OiBoZWlnaHQyIH0gPSB0aGlzLmJvdW5kYXJ5O1xuICAgIGNvbnN0IHsgY2FwYWNpdHkgfSA9IHRoaXM7XG4gICAgY29uc3QgZGVwdGggPSB0aGlzLm1heGRlcHRoIC0gMTtcbiAgICBjb25zdCBoYWxmV2lkdGggPSB3aWR0aDIgLyAyO1xuICAgIGNvbnN0IGhhbGZIZWlnaHQgPSBoZWlnaHQyIC8gMjtcbiAgICBjb25zdCBud0JvdW5kYXJ5ID0gbmV3IEJCb3goeCwgeSwgaGFsZldpZHRoLCBoYWxmSGVpZ2h0KTtcbiAgICBjb25zdCBuZUJvdW5kYXJ5ID0gbmV3IEJCb3goeCArIGhhbGZXaWR0aCwgeSwgaGFsZldpZHRoLCBoYWxmSGVpZ2h0KTtcbiAgICBjb25zdCBzd0JvdW5kYXJ5ID0gbmV3IEJCb3goeCwgeSArIGhhbGZIZWlnaHQsIGhhbGZXaWR0aCwgaGFsZkhlaWdodCk7XG4gICAgY29uc3Qgc2VCb3VuZGFyeSA9IG5ldyBCQm94KHggKyBoYWxmV2lkdGgsIHkgKyBoYWxmSGVpZ2h0LCBoYWxmV2lkdGgsIGhhbGZIZWlnaHQpO1xuICAgIHJldHVybiBuZXcgUXVhZHRyZWVTdWJkaXZpc2lvbnMoXG4gICAgICB0aGlzLmNoaWxkKGNhcGFjaXR5LCBkZXB0aCwgbndCb3VuZGFyeSksXG4gICAgICB0aGlzLmNoaWxkKGNhcGFjaXR5LCBkZXB0aCwgbmVCb3VuZGFyeSksXG4gICAgICB0aGlzLmNoaWxkKGNhcGFjaXR5LCBkZXB0aCwgc3dCb3VuZGFyeSksXG4gICAgICB0aGlzLmNoaWxkKGNhcGFjaXR5LCBkZXB0aCwgc2VCb3VuZGFyeSlcbiAgICApO1xuICB9XG59O1xudmFyIFF1YWR0cmVlTm9kZU5lYXJlc3QgPSBjbGFzcyBfUXVhZHRyZWVOb2RlTmVhcmVzdCBleHRlbmRzIFF1YWR0cmVlTm9kZSB7XG4gIGFkZENvbmRpdGlvbihlKSB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBlLmhpdFRlc3Rlci5taWRQb2ludDtcbiAgICByZXR1cm4gdGhpcy5ib3VuZGFyeS5jb250YWluc1BvaW50KHgsIHkpO1xuICB9XG4gIGZpbmRDb25kaXRpb24oeCwgeSwgYXJnKSB7XG4gICAgY29uc3QgeyBiZXN0IH0gPSBhcmc7XG4gICAgcmV0dXJuIGJlc3QuZGlzdGFuY2VTcXVhcmVkICE9PSAwICYmIHRoaXMuYm91bmRhcnkuZGlzdGFuY2VTcXVhcmVkKHgsIHkpIDwgYmVzdC5kaXN0YW5jZVNxdWFyZWQ7XG4gIH1cbiAgZmluZEFjdGlvbih4LCB5LCBhcmcpIHtcbiAgICBjb25zdCBvdGhlciA9IG5lYXJlc3RTcXVhcmVkKHgsIHksIHRoaXMuZWxlbXMsIGFyZy5iZXN0LmRpc3RhbmNlU3F1YXJlZCk7XG4gICAgaWYgKG90aGVyLm5lYXJlc3QgIT09IHZvaWQgMCAmJiBvdGhlci5kaXN0YW5jZVNxdWFyZWQgPCBhcmcuYmVzdC5kaXN0YW5jZVNxdWFyZWQpIHtcbiAgICAgIGFyZy5iZXN0ID0gb3RoZXI7XG4gICAgfVxuICB9XG4gIGNoaWxkKGNhcGFjaXR5LCBkZXB0aCwgYm91bmRhcnkpIHtcbiAgICByZXR1cm4gbmV3IF9RdWFkdHJlZU5vZGVOZWFyZXN0KGNhcGFjaXR5LCBkZXB0aCwgYm91bmRhcnkpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9tYXJrZXIvbWFya2VyLnRzXG52YXIgQlVJTFRJTl9NQVJLRVJTID0gW1xuICBcIkFycm93RG93blwiLFxuICBcIkFycm93VXBcIixcbiAgXCJDaXJjbGVcIixcbiAgXCJDcm9zc1wiLFxuICBcIkRpYW1vbmRcIixcbiAgXCJIZWFydFwiLFxuICBcIk1hcFBpblwiLFxuICBcIlBsdXNcIixcbiAgXCJTcXVhcmVcIixcbiAgXCJTdGFyXCIsXG4gIFwiVHJpYW5nbGVcIlxuXTtcbnZhciBERUZBVUxUX0NFTlRFUl9QT0lOVCA9IE9iamVjdC5mcmVlemUoeyB4OiAwLjUsIHk6IDAuNSB9KTtcbnZhciBJbnRlcm5hbE1hcmtlciA9IGNsYXNzIGV4dGVuZHMgUGF0aCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy54ID0gMDtcbiAgICB0aGlzLnkgPSAwO1xuICAgIHRoaXMuc2l6ZSA9IDEyO1xuICB9XG4gIGlzQnVpbHRJbigpIHtcbiAgICByZXR1cm4gQlVJTFRJTl9NQVJLRVJTLmluY2x1ZGVzKHRoaXMuY29uc3RydWN0b3IuY2xhc3NOYW1lID8/IFwiXCIpO1xuICB9XG4gIGNvbXB1dGVCQm94KCkge1xuICAgIGlmICghdGhpcy5pc0J1aWx0SW4oKSkge1xuICAgICAgcmV0dXJuIHRoaXMucGF0aC5jb21wdXRlQkJveCgpO1xuICAgIH1cbiAgICBjb25zdCB7IHgsIHksIHNpemUgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBjZW50ZXI6IGNlbnRlcjIgfSA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIG5ldyBCQm94KHggLSBzaXplICogY2VudGVyMi54LCB5IC0gc2l6ZSAqIGNlbnRlcjIueSwgc2l6ZSwgc2l6ZSk7XG4gIH1cbiAgYXBwbHlQYXRoKHMsIG1vdmVzKSB7XG4gICAgY29uc3QgeyBwYXRoIH0gPSB0aGlzO1xuICAgIGxldCB7IHgsIHkgfSA9IHRoaXM7XG4gICAgcGF0aC5jbGVhcigpO1xuICAgIGZvciAoY29uc3QgeyB4OiBteCwgeTogbXksIHQgfSBvZiBtb3Zlcykge1xuICAgICAgeCArPSBteCAqIHM7XG4gICAgICB5ICs9IG15ICogcztcbiAgICAgIGlmICh0ID09PSBcIm1vdmVcIikge1xuICAgICAgICBwYXRoLm1vdmVUbyh4LCB5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdGgubGluZVRvKHgsIHkpO1xuICAgICAgfVxuICAgIH1cbiAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICB9XG4gIGV4ZWN1dGVGaWxsKGN0eCwgcGF0aCkge1xuICAgIGlmICghcGF0aClcbiAgICAgIHJldHVybjtcbiAgICByZXR1cm4gc3VwZXIuZXhlY3V0ZUZpbGwoY3R4LCBwYXRoKTtcbiAgfVxuICBleGVjdXRlU3Ryb2tlKGN0eCwgcGF0aCkge1xuICAgIGlmICghcGF0aClcbiAgICAgIHJldHVybjtcbiAgICByZXR1cm4gc3VwZXIuZXhlY3V0ZVN0cm9rZShjdHgsIHBhdGgpO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIEludGVybmFsTWFya2VyLnByb3RvdHlwZSwgXCJ4XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIEludGVybmFsTWFya2VyLnByb3RvdHlwZSwgXCJ5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKHsgY29udmVydG9yOiBNYXRoLmFicyB9KVxuXSwgSW50ZXJuYWxNYXJrZXIucHJvdG90eXBlLCBcInNpemVcIiwgMik7XG52YXIgTWFya2VyID0gY2xhc3MgZXh0ZW5kcyBSb3RhdGFibGUoU2NhbGFibGUoVHJhbnNsYXRhYmxlKEludGVybmFsTWFya2VyKSkpIHtcbn07XG5NYXJrZXIuY2VudGVyID0gREVGQVVMVF9DRU5URVJfUE9JTlQ7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L21hcmtlci9jaXJjbGUudHNcbnZhciBDaXJjbGUgPSBjbGFzcyBleHRlbmRzIE1hcmtlciB7XG4gIHVwZGF0ZVBhdGgoKSB7XG4gICAgY29uc3QgeyB4LCB5LCBwYXRoLCBzaXplIH0gPSB0aGlzO1xuICAgIGNvbnN0IHIgPSBzaXplIC8gMjtcbiAgICBwYXRoLmNsZWFyKCk7XG4gICAgcGF0aC5hcmMoeCwgeSwgciwgMCwgTWF0aC5QSSAqIDIpO1xuICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gIH1cbn07XG5DaXJjbGUuY2xhc3NOYW1lID0gXCJDaXJjbGVcIjtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbWFya2VyL2Nyb3NzLnRzXG52YXIgX0Nyb3NzID0gY2xhc3MgX0Nyb3NzIGV4dGVuZHMgTWFya2VyIHtcbiAgdXBkYXRlUGF0aCgpIHtcbiAgICBjb25zdCBzID0gdGhpcy5zaXplIC8gNC4yO1xuICAgIHN1cGVyLmFwcGx5UGF0aChzLCBfQ3Jvc3MubW92ZXMpO1xuICB9XG59O1xuX0Nyb3NzLmNsYXNzTmFtZSA9IFwiQ3Jvc3NcIjtcbl9Dcm9zcy5tb3ZlcyA9IFtcbiAgeyB4OiAtMSwgeTogMCwgdDogXCJtb3ZlXCIgfSxcbiAgeyB4OiAtMSwgeTogLTEgfSxcbiAgeyB4OiAxLCB5OiAtMSB9LFxuICB7IHg6IDEsIHk6IDEgfSxcbiAgeyB4OiAxLCB5OiAtMSB9LFxuICB7IHg6IDEsIHk6IDEgfSxcbiAgeyB4OiAtMSwgeTogMSB9LFxuICB7IHg6IDEsIHk6IDEgfSxcbiAgeyB4OiAtMSwgeTogMSB9LFxuICB7IHg6IC0xLCB5OiAtMSB9LFxuICB7IHg6IC0xLCB5OiAxIH0sXG4gIHsgeDogLTEsIHk6IC0xIH1cbl07XG52YXIgQ3Jvc3MgPSBfQ3Jvc3M7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L21hcmtlci9kaWFtb25kLnRzXG52YXIgX0RpYW1vbmQgPSBjbGFzcyBfRGlhbW9uZCBleHRlbmRzIE1hcmtlciB7XG4gIHVwZGF0ZVBhdGgoKSB7XG4gICAgY29uc3QgcyA9IHRoaXMuc2l6ZSAvIDI7XG4gICAgc3VwZXIuYXBwbHlQYXRoKHMsIF9EaWFtb25kLm1vdmVzKTtcbiAgfVxufTtcbl9EaWFtb25kLmNsYXNzTmFtZSA9IFwiRGlhbW9uZFwiO1xuX0RpYW1vbmQubW92ZXMgPSBbXG4gIHsgeDogMCwgeTogLTEsIHQ6IFwibW92ZVwiIH0sXG4gIHsgeDogMSwgeTogMSB9LFxuICB7IHg6IC0xLCB5OiAxIH0sXG4gIHsgeDogLTEsIHk6IC0xIH0sXG4gIHsgeDogMSwgeTogLTEgfVxuXTtcbnZhciBEaWFtb25kID0gX0RpYW1vbmQ7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L21hcmtlci9oZWFydC50c1xudmFyIEhlYXJ0ID0gY2xhc3MgZXh0ZW5kcyBNYXJrZXIge1xuICByYWQoZGVncmVlMikge1xuICAgIHJldHVybiBkZWdyZWUyIC8gMTgwICogTWF0aC5QSTtcbiAgfVxuICB1cGRhdGVQYXRoKCkge1xuICAgIGNvbnN0IHsgeCwgcGF0aCwgc2l6ZSwgcmFkIH0gPSB0aGlzO1xuICAgIGNvbnN0IHIgPSBzaXplIC8gNDtcbiAgICBjb25zdCB5ID0gdGhpcy55ICsgciAvIDI7XG4gICAgcGF0aC5jbGVhcigpO1xuICAgIHBhdGguYXJjKHggLSByLCB5IC0gciwgciwgcmFkKDEzMCksIHJhZCgzMzApKTtcbiAgICBwYXRoLmFyYyh4ICsgciwgeSAtIHIsIHIsIHJhZCgyMjApLCByYWQoNTApKTtcbiAgICBwYXRoLmxpbmVUbyh4LCB5ICsgcik7XG4gICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgfVxufTtcbkhlYXJ0LmNsYXNzTmFtZSA9IFwiSGVhcnRcIjtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbWFya2VyL3Bpbi50c1xudmFyIFBpbiA9IGNsYXNzIGV4dGVuZHMgTWFya2VyIHtcbiAgdXBkYXRlUGF0aCgpIHtcbiAgICBjb25zdCB7IHBhdGgsIHgsIHkgfSA9IHRoaXM7XG4gICAgY29uc3QgcyA9IHRoaXMuc2l6ZTtcbiAgICBjb25zdCBjeCA9IDAuNTtcbiAgICBjb25zdCBjeSA9IDE7XG4gICAgcGF0aC5jbGVhcigpO1xuICAgIHBhdGgubW92ZVRvKHggKyAoMC4xNTYyNSAtIGN4KSAqIHMsIHkgKyAoMC4zNDM3NSAtIGN5KSAqIHMpO1xuICAgIHBhdGguY3ViaWNDdXJ2ZVRvKFxuICAgICAgeCArICgwLjE1NjI1IC0gY3gpICogcyxcbiAgICAgIHkgKyAoMC4xNTE0OTEgLSBjeSkgKiBzLFxuICAgICAgeCArICgwLjMwNzc0MSAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAgLSBjeSkgKiBzLFxuICAgICAgeCArICgwLjUgLSBjeCkgKiBzLFxuICAgICAgeSArICgwIC0gY3kpICogc1xuICAgICk7XG4gICAgcGF0aC5jdWJpY0N1cnZlVG8oXG4gICAgICB4ICsgKDAuNjkyMjU5IC0gY3gpICogcyxcbiAgICAgIHkgKyAoMCAtIGN5KSAqIHMsXG4gICAgICB4ICsgKDAuODQzNzUgLSBjeCkgKiBzLFxuICAgICAgeSArICgwLjE1MTQ5MSAtIGN5KSAqIHMsXG4gICAgICB4ICsgKDAuODQzNzUgLSBjeCkgKiBzLFxuICAgICAgeSArICgwLjM0Mzc1IC0gY3kpICogc1xuICAgICk7XG4gICAgcGF0aC5jdWJpY0N1cnZlVG8oXG4gICAgICB4ICsgKDAuODQzNzUgLSBjeCkgKiBzLFxuICAgICAgeSArICgwLjQ5MzgyNCAtIGN5KSAqIHMsXG4gICAgICB4ICsgKDAuNzg0NjI1IC0gY3gpICogcyxcbiAgICAgIHkgKyAoMC42MDAxODEgLSBjeSkgKiBzLFxuICAgICAgeCArICgwLjcxNjQ2MSAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAuNjk1MzkzIC0gY3kpICogc1xuICAgICk7XG4gICAgcGF0aC5jdWJpY0N1cnZlVG8oXG4gICAgICB4ICsgKDAuNjk5MDA5IC0gY3gpICogcyxcbiAgICAgIHkgKyAoMC43MTk3NjkgLSBjeSkgKiBzLFxuICAgICAgeCArICgwLjY4MTI3MSAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAuNzQzMTA0IC0gY3kpICogcyxcbiAgICAgIHggKyAoMC42NjM3ODUgLSBjeCkgKiBzLFxuICAgICAgeSArICgwLjc2NjEwNSAtIGN5KSAqIHNcbiAgICApO1xuICAgIHBhdGguY3ViaWNDdXJ2ZVRvKFxuICAgICAgeCArICgwLjYxMTg5MyAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAuODM0MzY3IC0gY3kpICogcyxcbiAgICAgIHggKyAoMC41NjIyMjggLSBjeCkgKiBzLFxuICAgICAgeSArICgwLjg5OTY5OSAtIGN5KSAqIHMsXG4gICAgICB4ICsgKDAuNTI4ODk2IC0gY3gpICogcyxcbiAgICAgIHkgKyAoMC45ODA2NDggLSBjeSkgKiBzXG4gICAgKTtcbiAgICBwYXRoLmN1YmljQ3VydmVUbyhcbiAgICAgIHggKyAoMC41MjQwNzUgLSBjeCkgKiBzLFxuICAgICAgeSArICgwLjk5MjM1OCAtIGN5KSAqIHMsXG4gICAgICB4ICsgKDAuNTEyNjYzIC0gY3gpICogcyxcbiAgICAgIHkgKyAoMSAtIGN5KSAqIHMsXG4gICAgICB4ICsgKDAuNSAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDEgLSBjeSkgKiBzXG4gICAgKTtcbiAgICBwYXRoLmN1YmljQ3VydmVUbyhcbiAgICAgIHggKyAoMC40ODczMzcgLSBjeCkgKiBzLFxuICAgICAgeSArICgxIC0gY3kpICogcyxcbiAgICAgIHggKyAoMC40NzU5MjUgLSBjeCkgKiBzLFxuICAgICAgeSArICgwLjk5MjM1OCAtIGN5KSAqIHMsXG4gICAgICB4ICsgKDAuNDcxMTA0IC0gY3gpICogcyxcbiAgICAgIHkgKyAoMC45ODA2NDggLSBjeSkgKiBzXG4gICAgKTtcbiAgICBwYXRoLmN1YmljQ3VydmVUbyhcbiAgICAgIHggKyAoMC40ODczMzcgLSBjeCkgKiBzLFxuICAgICAgeSArICgxIC0gY3kpICogcyxcbiAgICAgIHggKyAoMC40NzU5MjUgLSBjeCkgKiBzLFxuICAgICAgeSArICgwLjk5MjM1OCAtIGN5KSAqIHMsXG4gICAgICB4ICsgKDAuNDcxMTA0IC0gY3gpICogcyxcbiAgICAgIHkgKyAoMC45ODA2NDggLSBjeSkgKiBzXG4gICAgKTtcbiAgICBwYXRoLmN1YmljQ3VydmVUbyhcbiAgICAgIHggKyAoMC40Mzc3NzIgLSBjeCkgKiBzLFxuICAgICAgeSArICgwLjg5OTY5OSAtIGN5KSAqIHMsXG4gICAgICB4ICsgKDAuMzg4MTA3IC0gY3gpICogcyxcbiAgICAgIHkgKyAoMC44MzQzNjcgLSBjeSkgKiBzLFxuICAgICAgeCArICgwLjMzNjIxNSAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAuNzY2MTA1IC0gY3kpICogc1xuICAgICk7XG4gICAgcGF0aC5jdWJpY0N1cnZlVG8oXG4gICAgICB4ICsgKDAuMzE4NzI5IC0gY3gpICogcyxcbiAgICAgIHkgKyAoMC43NDMxMDQgLSBjeSkgKiBzLFxuICAgICAgeCArICgwLjMwMDk5MSAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAuNzE5NzY5IC0gY3kpICogcyxcbiAgICAgIHggKyAoMC4yODM1MzkgLSBjeCkgKiBzLFxuICAgICAgeSArICgwLjY5NTM5MyAtIGN5KSAqIHNcbiAgICApO1xuICAgIHBhdGguY3ViaWNDdXJ2ZVRvKFxuICAgICAgeCArICgwLjIxNTM3NSAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAuNjAwMTgxIC0gY3kpICogcyxcbiAgICAgIHggKyAoMC4xNTYyNSAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAuNDkzODI0IC0gY3kpICogcyxcbiAgICAgIHggKyAoMC4xNTYyNSAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAuMzQzNzUgLSBjeSkgKiBzXG4gICAgKTtcbiAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICB9XG59O1xuUGluLmNsYXNzTmFtZSA9IFwiTWFwUGluXCI7XG5QaW4uY2VudGVyID0geyB4OiAwLjUsIHk6IDEgfTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbWFya2VyL3BsdXMudHNcbnZhciBfUGx1cyA9IGNsYXNzIF9QbHVzIGV4dGVuZHMgTWFya2VyIHtcbiAgdXBkYXRlUGF0aCgpIHtcbiAgICBjb25zdCBzID0gdGhpcy5zaXplIC8gMztcbiAgICBzdXBlci5hcHBseVBhdGgocywgX1BsdXMubW92ZXMpO1xuICB9XG59O1xuX1BsdXMuY2xhc3NOYW1lID0gXCJQbHVzXCI7XG5fUGx1cy5tb3ZlcyA9IFtcbiAgeyB4OiAtMC41LCB5OiAtMC41LCB0OiBcIm1vdmVcIiB9LFxuICB7IHg6IDAsIHk6IC0xIH0sXG4gIHsgeDogMSwgeTogMCB9LFxuICB7IHg6IDAsIHk6IDEgfSxcbiAgeyB4OiAxLCB5OiAwIH0sXG4gIHsgeDogMCwgeTogMSB9LFxuICB7IHg6IC0xLCB5OiAwIH0sXG4gIHsgeDogMCwgeTogMSB9LFxuICB7IHg6IC0xLCB5OiAwIH0sXG4gIHsgeDogMCwgeTogLTEgfSxcbiAgeyB4OiAtMSwgeTogMCB9LFxuICB7IHg6IDAsIHk6IC0xIH1cbl07XG52YXIgUGx1cyA9IF9QbHVzO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9tYXJrZXIvc3F1YXJlLnRzXG52YXIgU3F1YXJlID0gY2xhc3MgZXh0ZW5kcyBNYXJrZXIge1xuICB1cGRhdGVQYXRoKCkge1xuICAgIGNvbnN0IHsgcGF0aCwgeCwgeSB9ID0gdGhpcztcbiAgICBjb25zdCBocyA9IHRoaXMuc2l6ZSAvIDI7XG4gICAgcGF0aC5jbGVhcigpO1xuICAgIHBhdGgubW92ZVRvKHRoaXMuYWxpZ24oeCAtIGhzKSwgdGhpcy5hbGlnbih5IC0gaHMpKTtcbiAgICBwYXRoLmxpbmVUbyh0aGlzLmFsaWduKHggKyBocyksIHRoaXMuYWxpZ24oeSAtIGhzKSk7XG4gICAgcGF0aC5saW5lVG8odGhpcy5hbGlnbih4ICsgaHMpLCB0aGlzLmFsaWduKHkgKyBocykpO1xuICAgIHBhdGgubGluZVRvKHRoaXMuYWxpZ24oeCAtIGhzKSwgdGhpcy5hbGlnbih5ICsgaHMpKTtcbiAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICB9XG59O1xuU3F1YXJlLmNsYXNzTmFtZSA9IFwiU3F1YXJlXCI7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L21hcmtlci9zdGFyLnRzXG52YXIgU3RhciA9IGNsYXNzIGV4dGVuZHMgTWFya2VyIHtcbiAgdXBkYXRlUGF0aCgpIHtcbiAgICBjb25zdCB7IHgsIHksIHBhdGgsIHNpemUgfSA9IHRoaXM7XG4gICAgY29uc3Qgc3Bpa2VzID0gNTtcbiAgICBjb25zdCBpbm5lclJhZGl1cyA9IHNpemUgLyAyO1xuICAgIGNvbnN0IHJvdGF0aW9uID0gTWF0aC5QSSAvIDI7XG4gICAgcGF0aC5jbGVhcigpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3Bpa2VzICogMjsgaSsrKSB7XG4gICAgICBjb25zdCByYWRpdXMgPSBpICUgMiA9PT0gMCA/IHNpemUgOiBpbm5lclJhZGl1cztcbiAgICAgIGNvbnN0IGFuZ2xlMiA9IGkgKiBNYXRoLlBJIC8gc3Bpa2VzIC0gcm90YXRpb247XG4gICAgICBjb25zdCB4Q29vcmRpbmF0ZSA9IHggKyBNYXRoLmNvcyhhbmdsZTIpICogcmFkaXVzO1xuICAgICAgY29uc3QgeUNvb3JkaW5hdGUgPSB5ICsgTWF0aC5zaW4oYW5nbGUyKSAqIHJhZGl1cztcbiAgICAgIHBhdGgubGluZVRvKHhDb29yZGluYXRlLCB5Q29vcmRpbmF0ZSk7XG4gICAgfVxuICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gIH1cbn07XG5TdGFyLmNsYXNzTmFtZSA9IFwiU3RhclwiO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9tYXJrZXIvdHJpYW5nbGUudHNcbnZhciBfVHJpYW5nbGUgPSBjbGFzcyBfVHJpYW5nbGUgZXh0ZW5kcyBNYXJrZXIge1xuICB1cGRhdGVQYXRoKCkge1xuICAgIGNvbnN0IHMgPSB0aGlzLnNpemUgKiAxLjE7XG4gICAgc3VwZXIuYXBwbHlQYXRoKHMsIF9UcmlhbmdsZS5tb3Zlcyk7XG4gIH1cbn07XG5fVHJpYW5nbGUuY2xhc3NOYW1lID0gXCJUcmlhbmdsZVwiO1xuX1RyaWFuZ2xlLm1vdmVzID0gW1xuICB7IHg6IDAsIHk6IC0wLjQ4LCB0OiBcIm1vdmVcIiB9LFxuICB7IHg6IDAuNSwgeTogMC44NyB9LFxuICB7IHg6IC0xLCB5OiAwIH1cbl07XG52YXIgVHJpYW5nbGUgPSBfVHJpYW5nbGU7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L21hcmtlci91dGlsLnRzXG52YXIgTUFSS0VSX1NIQVBFUyA9IHtcbiAgY2lyY2xlOiBDaXJjbGUsXG4gIGNyb3NzOiBDcm9zcyxcbiAgZGlhbW9uZDogRGlhbW9uZCxcbiAgaGVhcnQ6IEhlYXJ0LFxuICBwaW46IFBpbixcbiAgcGx1czogUGx1cyxcbiAgc3F1YXJlOiBTcXVhcmUsXG4gIHN0YXI6IFN0YXIsXG4gIHRyaWFuZ2xlOiBUcmlhbmdsZVxufTtcbnZhciBNQVJLRVJfU1VQUE9SVEVEX1NIQVBFUyA9IE9iamVjdC5rZXlzKE1BUktFUl9TSEFQRVMpO1xuZnVuY3Rpb24gaXNNYXJrZXJTaGFwZShzaGFwZSkge1xuICByZXR1cm4gdHlwZW9mIHNoYXBlID09PSBcInN0cmluZ1wiICYmIE1BUktFUl9TVVBQT1JURURfU0hBUEVTLmluY2x1ZGVzKHNoYXBlKTtcbn1cbmZ1bmN0aW9uIGdldE1hcmtlcihzaGFwZSA9IFNxdWFyZSkge1xuICBpZiAoaXNNYXJrZXJTaGFwZShzaGFwZSkpIHtcbiAgICByZXR1cm4gTUFSS0VSX1NIQVBFU1tzaGFwZV07XG4gIH1cbiAgaWYgKHR5cGVvZiBzaGFwZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIHNoYXBlO1xuICB9XG4gIHJldHVybiBTcXVhcmU7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9kYXRhTW9kZWxTZXJpZXMudHNcbnZhciBEYXRhTW9kZWxTZXJpZXMgPSBjbGFzcyBleHRlbmRzIFNlcmllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5zaG93Rm9jdXNCb3ggPSB0cnVlO1xuICB9XG4gIGdldFNjYWxlSW5mb3JtYXRpb24oe1xuICAgIHhTY2FsZSxcbiAgICB5U2NhbGVcbiAgfSkge1xuICAgIGNvbnN0IGlzQ29udGludW91c1ggPSBDb250aW51b3VzU2NhbGUuaXMoeFNjYWxlKTtcbiAgICBjb25zdCBpc0NvbnRpbnVvdXNZID0gQ29udGludW91c1NjYWxlLmlzKHlTY2FsZSk7XG4gICAgcmV0dXJuIHsgaXNDb250aW51b3VzWCwgaXNDb250aW51b3VzWSwgeFNjYWxlVHlwZTogeFNjYWxlPy50eXBlLCB5U2NhbGVUeXBlOiB5U2NhbGU/LnR5cGUgfTtcbiAgfVxuICBnZXRNb2R1bGVQcm9wZXJ0eURlZmluaXRpb25zKCkge1xuICAgIGNvbnN0IHhTY2FsZSA9IHRoaXMuYXhlc1tcInhcIiAvKiBYICovXT8uc2NhbGU7XG4gICAgY29uc3QgeVNjYWxlID0gdGhpcy5heGVzW1wieVwiIC8qIFkgKi9dPy5zY2FsZTtcbiAgICByZXR1cm4gdGhpcy5tb2R1bGVNYXAubWFwTW9kdWxlcygobW9kMikgPT4gbW9kMi5nZXRQcm9wZXJ0eURlZmluaXRpb25zKHRoaXMuZ2V0U2NhbGVJbmZvcm1hdGlvbih7IHhTY2FsZSwgeVNjYWxlIH0pKSkuZmxhdCgpO1xuICB9XG4gIC8vIFJlcXVlc3QgZGF0YSwgYnV0IHdpdGggbWVzc2FnZSBkaXNwYXRjaGluZyB0byBzZXJpZXMtb3B0aW9ucyAobW9kdWxlcykuXG4gIGFzeW5jIHJlcXVlc3REYXRhTW9kZWwoZGF0YUNvbnRyb2xsZXIsIGRhdGEsIG9wdHMpIHtcbiAgICBvcHRzLnByb3BzLnB1c2goLi4udGhpcy5nZXRNb2R1bGVQcm9wZXJ0eURlZmluaXRpb25zKCkpO1xuICAgIGNvbnN0IHsgZGF0YU1vZGVsLCBwcm9jZXNzZWREYXRhIH0gPSBhd2FpdCBkYXRhQ29udHJvbGxlci5yZXF1ZXN0KHRoaXMuaWQsIGRhdGEgPz8gW10sIG9wdHMpO1xuICAgIHRoaXMuZGF0YU1vZGVsID0gZGF0YU1vZGVsO1xuICAgIHRoaXMucHJvY2Vzc2VkRGF0YSA9IHByb2Nlc3NlZERhdGE7XG4gICAgdGhpcy5kaXNwYXRjaChcImRhdGEtcHJvY2Vzc2VkXCIsIHsgZGF0YU1vZGVsLCBwcm9jZXNzZWREYXRhIH0pO1xuICAgIHJldHVybiB7IGRhdGFNb2RlbCwgcHJvY2Vzc2VkRGF0YSB9O1xuICB9XG4gIGlzUHJvY2Vzc2VkRGF0YUFuaW1hdGFibGUoKSB7XG4gICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdHMgPSB0aGlzLnByb2Nlc3NlZERhdGE/LnJlZHVjZWQ/LmFuaW1hdGlvblZhbGlkYXRpb247XG4gICAgaWYgKCF2YWxpZGF0aW9uUmVzdWx0cykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IHsgb3JkZXJlZEtleXMsIHVuaXF1ZUtleXMgfSA9IHZhbGlkYXRpb25SZXN1bHRzO1xuICAgIHJldHVybiBvcmRlcmVkS2V5cyAmJiB1bmlxdWVLZXlzO1xuICB9XG4gIGNoZWNrUHJvY2Vzc2VkRGF0YUFuaW1hdGFibGUoKSB7XG4gICAgaWYgKCF0aGlzLmlzUHJvY2Vzc2VkRGF0YUFuaW1hdGFibGUoKSkge1xuICAgICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5za2lwQ3VycmVudEJhdGNoKCk7XG4gICAgfVxuICB9XG4gIHBpY2tGb2N1cyhvcHRzKSB7XG4gICAgY29uc3Qgbm9kZURhdGEgPSB0aGlzLmdldE5vZGVEYXRhKCk7XG4gICAgaWYgKG5vZGVEYXRhID09PSB2b2lkIDAgfHwgbm9kZURhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRhdHVtSW5kZXggPSB0aGlzLmNvbXB1dGVGb2N1c0RhdHVtSW5kZXgob3B0cywgbm9kZURhdGEpO1xuICAgIGlmIChkYXR1bUluZGV4ID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBzaG93Rm9jdXNCb3ggfSA9IHRoaXM7XG4gICAgY29uc3QgZGF0dW0gPSBub2RlRGF0YVtkYXR1bUluZGV4XTtcbiAgICBjb25zdCBkZXJpdmVkT3B0cyA9IHsgLi4ub3B0cywgZGF0dW1JbmRleCB9O1xuICAgIGNvbnN0IGJvdW5kcyA9IHRoaXMuY29tcHV0ZUZvY3VzQm91bmRzKGRlcml2ZWRPcHRzKTtcbiAgICBpZiAoYm91bmRzICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB7IGJvdW5kcywgc2hvd0ZvY3VzQm94LCBkYXR1bSwgZGF0dW1JbmRleCB9O1xuICAgIH1cbiAgfVxuICBjb21wdXRlRm9jdXNEYXR1bUluZGV4KG9wdHMsIG5vZGVEYXRhKSB7XG4gICAgY29uc3QgaXNEYXR1bUVuYWJsZWQgPSAoZGF0dW1JbmRleDIpID0+IHtcbiAgICAgIGNvbnN0IHsgbWlzc2luZyA9IGZhbHNlLCBlbmFibGVkID0gdHJ1ZSwgZm9jdXNhYmxlID0gdHJ1ZSB9ID0gbm9kZURhdGFbZGF0dW1JbmRleDJdO1xuICAgICAgcmV0dXJuICFtaXNzaW5nICYmIGVuYWJsZWQgJiYgZm9jdXNhYmxlO1xuICAgIH07XG4gICAgY29uc3Qgc2VhcmNoQmFja3dhcmQgPSAoZGF0dW1JbmRleDIpID0+IHtcbiAgICAgIHdoaWxlIChkYXR1bUluZGV4MiA+PSAwICYmICFpc0RhdHVtRW5hYmxlZChkYXR1bUluZGV4MikpIHtcbiAgICAgICAgZGF0dW1JbmRleDItLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXR1bUluZGV4MiA9PT0gLTEgPyB2b2lkIDAgOiBkYXR1bUluZGV4MjtcbiAgICB9O1xuICAgIGNvbnN0IHNlYXJjaEZvcndhcmQgPSAoZGF0dW1JbmRleDIpID0+IHtcbiAgICAgIHdoaWxlIChkYXR1bUluZGV4MiA8IG5vZGVEYXRhLmxlbmd0aCAmJiAhaXNEYXR1bUVuYWJsZWQoZGF0dW1JbmRleDIpKSB7XG4gICAgICAgIGRhdHVtSW5kZXgyKys7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0dW1JbmRleDIgPT09IG5vZGVEYXRhLmxlbmd0aCA/IHZvaWQgMCA6IGRhdHVtSW5kZXgyO1xuICAgIH07XG4gICAgbGV0IGRhdHVtSW5kZXg7XG4gICAgY29uc3QgY2xhbXBlZEluZGV4ID0gY2xhbXAoMCwgb3B0cy5kYXR1bUluZGV4LCBub2RlRGF0YS5sZW5ndGggLSAxKTtcbiAgICBpZiAob3B0cy5kYXR1bUluZGV4RGVsdGEgPCAwKSB7XG4gICAgICBkYXR1bUluZGV4ID0gc2VhcmNoQmFja3dhcmQoY2xhbXBlZEluZGV4KTtcbiAgICB9IGVsc2UgaWYgKG9wdHMuZGF0dW1JbmRleERlbHRhID4gMCkge1xuICAgICAgZGF0dW1JbmRleCA9IHNlYXJjaEZvcndhcmQoY2xhbXBlZEluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0dW1JbmRleCA9IHNlYXJjaEZvcndhcmQoY2xhbXBlZEluZGV4KSA/PyBzZWFyY2hCYWNrd2FyZChjbGFtcGVkSW5kZXgpO1xuICAgIH1cbiAgICBpZiAoZGF0dW1JbmRleCA9PT0gdm9pZCAwKSB7XG4gICAgICBpZiAob3B0cy5kYXR1bUluZGV4RGVsdGEgPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG9wdHMuZGF0dW1JbmRleCAtIG9wdHMuZGF0dW1JbmRleERlbHRhO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZGF0dW1JbmRleDtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9zZXJpZXNQcm9wZXJ0aWVzLnRzXG52YXIgU2VyaWVzSXRlbUhpZ2hsaWdodFN0eWxlID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5maWxsID0gXCJyZ2JhKDI1NSwyNTUsMjU1LCAwLjMzKVwiO1xuICAgIHRoaXMuc3Ryb2tlID0gYHJnYmEoMCwgMCwgMCwgMC40KWA7XG4gICAgdGhpcy5zdHJva2VXaWR0aCA9IDI7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFNlcmllc0l0ZW1IaWdobGlnaHRTdHlsZS5wcm90b3R5cGUsIFwiZmlsbFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBTZXJpZXNJdGVtSGlnaGxpZ2h0U3R5bGUucHJvdG90eXBlLCBcImZpbGxPcGFjaXR5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBTZXJpZXNJdGVtSGlnaGxpZ2h0U3R5bGUucHJvdG90eXBlLCBcInN0cm9rZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgU2VyaWVzSXRlbUhpZ2hsaWdodFN0eWxlLnByb3RvdHlwZSwgXCJzdHJva2VXaWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBTZXJpZXNJdGVtSGlnaGxpZ2h0U3R5bGUucHJvdG90eXBlLCBcInN0cm9rZU9wYWNpdHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShMSU5FX0RBU0gsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFNlcmllc0l0ZW1IaWdobGlnaHRTdHlsZS5wcm90b3R5cGUsIFwibGluZURhc2hcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFNlcmllc0l0ZW1IaWdobGlnaHRTdHlsZS5wcm90b3R5cGUsIFwibGluZURhc2hPZmZzZXRcIiwgMik7XG52YXIgU2VyaWVzSGlnaGxpZ2h0U3R5bGUgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFNlcmllc0hpZ2hsaWdodFN0eWxlLnByb3RvdHlwZSwgXCJzdHJva2VXaWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBTZXJpZXNIaWdobGlnaHRTdHlsZS5wcm90b3R5cGUsIFwiZGltT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFNlcmllc0hpZ2hsaWdodFN0eWxlLnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIDIpO1xudmFyIFRleHRIaWdobGlnaHRTdHlsZSA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuY29sb3IgPSBcImJsYWNrXCI7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFRleHRIaWdobGlnaHRTdHlsZS5wcm90b3R5cGUsIFwiY29sb3JcIiwgMik7XG52YXIgSGlnaGxpZ2h0UHJvcGVydGllcyA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBIaWdobGlnaHRQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIDIpO1xudmFyIEhpZ2hsaWdodFN0eWxlID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5pdGVtID0gbmV3IFNlcmllc0l0ZW1IaWdobGlnaHRTdHlsZSgpO1xuICAgIHRoaXMuc2VyaWVzID0gbmV3IFNlcmllc0hpZ2hsaWdodFN0eWxlKCk7XG4gICAgdGhpcy50ZXh0ID0gbmV3IFRleHRIaWdobGlnaHRTdHlsZSgpO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgSGlnaGxpZ2h0U3R5bGUucHJvdG90eXBlLCBcIml0ZW1cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBIaWdobGlnaHRTdHlsZS5wcm90b3R5cGUsIFwic2VyaWVzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgSGlnaGxpZ2h0U3R5bGUucHJvdG90eXBlLCBcInRleHRcIiwgMik7XG52YXIgU2VyaWVzUHJvcGVydGllcyA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG4gICAgdGhpcy5mb2N1c1ByaW9yaXR5ID0gSW5maW5pdHk7XG4gICAgdGhpcy5zaG93SW5MZWdlbmQgPSB0cnVlO1xuICAgIHRoaXMuY3Vyc29yID0gXCJkZWZhdWx0XCI7XG4gICAgdGhpcy5ub2RlQ2xpY2tSYW5nZSA9IFwiZXhhY3RcIjtcbiAgICB0aGlzLmhpZ2hsaWdodCA9IG5ldyBIaWdobGlnaHRQcm9wZXJ0aWVzKCk7XG4gICAgdGhpcy5oaWdobGlnaHRTdHlsZSA9IG5ldyBIaWdobGlnaHRTdHlsZSgpO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJpZFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ2aXNpYmxlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkVBTF9OVU1CRVIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImZvY3VzUHJpb3JpdHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic2hvd0luTGVnZW5kXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HKVxuXSwgU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiY3Vyc29yXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoSU5URVJBQ1RJT05fUkFOR0UpXG5dLCBTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJub2RlQ2xpY2tSYW5nZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImhpZ2hsaWdodFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImhpZ2hsaWdodFN0eWxlXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2NhcnRlc2lhblNlcmllcy50c1xudmFyIERFRkFVTFRfQ0FSVEVTSUFOX0RJUkVDVElPTl9LRVlTID0ge1xuICBbXCJ4XCIgLyogWCAqL106IFtcInhLZXlcIl0sXG4gIFtcInlcIiAvKiBZICovXTogW1wieUtleVwiXVxufTtcbnZhciBERUZBVUxUX0NBUlRFU0lBTl9ESVJFQ1RJT05fTkFNRVMgPSB7XG4gIFtcInhcIiAvKiBYICovXTogW1wieE5hbWVcIl0sXG4gIFtcInlcIiAvKiBZICovXTogW1wieU5hbWVcIl1cbn07XG52YXIgQ2FydGVzaWFuU2VyaWVzTm9kZUV2ZW50ID0gY2xhc3MgZXh0ZW5kcyBTZXJpZXNOb2RlRXZlbnQge1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBuYXRpdmVFdmVudCwgZGF0dW0sIHNlcmllcykge1xuICAgIHN1cGVyKHR5cGUsIG5hdGl2ZUV2ZW50LCBkYXR1bSwgc2VyaWVzKTtcbiAgICB0aGlzLnhLZXkgPSBzZXJpZXMucHJvcGVydGllcy54S2V5O1xuICAgIHRoaXMueUtleSA9IHNlcmllcy5wcm9wZXJ0aWVzLnlLZXk7XG4gIH1cbn07XG52YXIgQ2FydGVzaWFuU2VyaWVzUHJvcGVydGllcyA9IGNsYXNzIGV4dGVuZHMgU2VyaWVzUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5waWNrT3V0c2lkZVZpc2libGVNaW5vckF4aXMgPSBmYWxzZTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQ2FydGVzaWFuU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGVnZW5kSXRlbU5hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBDYXJ0ZXNpYW5TZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJwaWNrT3V0c2lkZVZpc2libGVNaW5vckF4aXNcIiwgMik7XG52YXIgQ2FydGVzaWFuU2VyaWVzID0gY2xhc3MgZXh0ZW5kcyBEYXRhTW9kZWxTZXJpZXMge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgcGF0aHNQZXJTZXJpZXMgPSBbXCJwYXRoXCJdLFxuICAgIGhhc01hcmtlcnMgPSBmYWxzZSxcbiAgICBoYXNIaWdobGlnaHRlZExhYmVscyA9IGZhbHNlLFxuICAgIHBhdGhzWkluZGV4U3ViT3JkZXJPZmZzZXQgPSBbXSxcbiAgICBkYXR1bVNlbGVjdGlvbkdhcmJhZ2VDb2xsZWN0aW9uID0gdHJ1ZSxcbiAgICBtYXJrZXJTZWxlY3Rpb25HYXJiYWdlQ29sbGVjdGlvbiA9IHRydWUsXG4gICAgYW5pbWF0aW9uQWx3YXlzVXBkYXRlU2VsZWN0aW9ucyA9IGZhbHNlLFxuICAgIGFuaW1hdGlvblJlc2V0Rm5zLFxuICAgIGRpcmVjdGlvbktleXMsXG4gICAgZGlyZWN0aW9uTmFtZXMsXG4gICAgLi4ub3RoZXJPcHRzXG4gIH0pIHtcbiAgICBzdXBlcih7XG4gICAgICBkaXJlY3Rpb25LZXlzLFxuICAgICAgZGlyZWN0aW9uTmFtZXMsXG4gICAgICBjYW5IYXZlQXhlczogdHJ1ZSxcbiAgICAgIC4uLm90aGVyT3B0c1xuICAgIH0pO1xuICAgIHRoaXMuTm9kZUV2ZW50ID0gQ2FydGVzaWFuU2VyaWVzTm9kZUV2ZW50O1xuICAgIHRoaXMuZGF0YU5vZGVHcm91cCA9IHRoaXMuY29udGVudEdyb3VwLmFwcGVuZENoaWxkKFxuICAgICAgbmV3IEdyb3VwKHtcbiAgICAgICAgbmFtZTogYCR7dGhpcy5pZH0tc2VyaWVzLWRhdGFOb2Rlc2AsXG4gICAgICAgIHpJbmRleDogNCAvKiBTRVJJRVNfTEFZRVIgKi8sXG4gICAgICAgIHpJbmRleFN1Yk9yZGVyOiB0aGlzLmdldEdyb3VwWkluZGV4U3ViT3JkZXIoXCJkYXRhXCIpXG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy5tYXJrZXJHcm91cCA9IHRoaXMuY29udGVudEdyb3VwLmFwcGVuZENoaWxkKFxuICAgICAgbmV3IEdyb3VwKHtcbiAgICAgICAgbmFtZTogYCR7dGhpcy5pZH0tc2VyaWVzLW1hcmtlcnNgLFxuICAgICAgICB6SW5kZXg6IDQgLyogU0VSSUVTX0xBWUVSICovLFxuICAgICAgICB6SW5kZXhTdWJPcmRlcjogdGhpcy5nZXRHcm91cFpJbmRleFN1Yk9yZGVyKFwibWFya2VyXCIpXG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy5sYWJlbEdyb3VwID0gdGhpcy5jb250ZW50R3JvdXAuYXBwZW5kQ2hpbGQoXG4gICAgICBuZXcgVHJhbnNsYXRhYmxlR3JvdXAoe1xuICAgICAgICBuYW1lOiBgJHt0aGlzLmlkfS1zZXJpZXMtbGFiZWxzYCxcbiAgICAgICAgekluZGV4OiAxNCAvKiBTRVJJRVNfTEFCRUwgKi8sXG4gICAgICAgIHpJbmRleFN1Yk9yZGVyOiB0aGlzLmdldEdyb3VwWkluZGV4U3ViT3JkZXIoXCJsYWJlbHNcIilcbiAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzLmxhYmVsU2VsZWN0aW9uID0gU2VsZWN0aW9uLnNlbGVjdCh0aGlzLmxhYmVsR3JvdXAsIFRleHQpO1xuICAgIHRoaXMuaGlnaGxpZ2h0U2VsZWN0aW9uID0gU2VsZWN0aW9uLnNlbGVjdChcbiAgICAgIHRoaXMuaGlnaGxpZ2h0Tm9kZSxcbiAgICAgICgpID0+IHRoaXMub3B0cy5oYXNNYXJrZXJzID8gdGhpcy5tYXJrZXJGYWN0b3J5KCkgOiB0aGlzLm5vZGVGYWN0b3J5KClcbiAgICApO1xuICAgIHRoaXMuaGlnaGxpZ2h0TGFiZWxTZWxlY3Rpb24gPSBTZWxlY3Rpb24uc2VsZWN0KHRoaXMuaGlnaGxpZ2h0TGFiZWwsIFRleHQpO1xuICAgIHRoaXMuYW5ub3RhdGlvblNlbGVjdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMubWluUmVjdHNDYWNoZSA9IHtcbiAgICAgIGRpcnR5Tm9kZURhdGE6IHRydWVcbiAgICB9O1xuICAgIHRoaXMuZGVidWcgPSBEZWJ1Zy5jcmVhdGUoKTtcbiAgICBpZiAoIWRpcmVjdGlvbktleXMgfHwgIWRpcmVjdGlvbk5hbWVzKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gaW5pdGlhbGlzZSBzZXJpZXMgdHlwZSAke3RoaXMudHlwZX1gKTtcbiAgICB0aGlzLm9wdHMgPSB7XG4gICAgICBwYXRoc1BlclNlcmllcyxcbiAgICAgIGhhc01hcmtlcnMsXG4gICAgICBoYXNIaWdobGlnaHRlZExhYmVscyxcbiAgICAgIHBhdGhzWkluZGV4U3ViT3JkZXJPZmZzZXQsXG4gICAgICBkaXJlY3Rpb25LZXlzLFxuICAgICAgZGlyZWN0aW9uTmFtZXMsXG4gICAgICBhbmltYXRpb25SZXNldEZucyxcbiAgICAgIGFuaW1hdGlvbkFsd2F5c1VwZGF0ZVNlbGVjdGlvbnMsXG4gICAgICBkYXR1bVNlbGVjdGlvbkdhcmJhZ2VDb2xsZWN0aW9uLFxuICAgICAgbWFya2VyU2VsZWN0aW9uR2FyYmFnZUNvbGxlY3Rpb25cbiAgICB9O1xuICAgIHRoaXMucGF0aHMgPSBbXTtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcGF0aHNQZXJTZXJpZXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB0aGlzLnBhdGhzW2luZGV4XSA9IG5ldyBQYXRoKHsgbmFtZTogYCR7dGhpcy5pZH0tJHtwYXRoc1BlclNlcmllc1tpbmRleF19YCB9KTtcbiAgICAgIHRoaXMucGF0aHNbaW5kZXhdLnpJbmRleCA9IDQgLyogU0VSSUVTX0xBWUVSICovO1xuICAgICAgdGhpcy5wYXRoc1tpbmRleF0uekluZGV4U3ViT3JkZXIgPSB0aGlzLmdldEdyb3VwWkluZGV4U3ViT3JkZXIoXCJwYXRoc1wiLCBpbmRleCk7XG4gICAgICB0aGlzLmNvbnRlbnRHcm91cC5hcHBlbmRDaGlsZCh0aGlzLnBhdGhzW2luZGV4XSk7XG4gICAgfVxuICAgIHRoaXMuZGF0dW1TZWxlY3Rpb24gPSBTZWxlY3Rpb24uc2VsZWN0KFxuICAgICAgdGhpcy5kYXRhTm9kZUdyb3VwLFxuICAgICAgKCkgPT4gdGhpcy5ub2RlRmFjdG9yeSgpLFxuICAgICAgZGF0dW1TZWxlY3Rpb25HYXJiYWdlQ29sbGVjdGlvblxuICAgICk7XG4gICAgdGhpcy5tYXJrZXJTZWxlY3Rpb24gPSBTZWxlY3Rpb24uc2VsZWN0KFxuICAgICAgdGhpcy5tYXJrZXJHcm91cCxcbiAgICAgICgpID0+IHRoaXMubWFya2VyRmFjdG9yeSgpLFxuICAgICAgbWFya2VyU2VsZWN0aW9uR2FyYmFnZUNvbGxlY3Rpb25cbiAgICApO1xuICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUgPSBuZXcgU3RhdGVNYWNoaW5lKFxuICAgICAgXCJlbXB0eVwiLFxuICAgICAge1xuICAgICAgICBlbXB0eToge1xuICAgICAgICAgIHVwZGF0ZToge1xuICAgICAgICAgICAgdGFyZ2V0OiBcInJlYWR5XCIsXG4gICAgICAgICAgICBhY3Rpb246IChkYXRhKSA9PiB0aGlzLmFuaW1hdGVFbXB0eVVwZGF0ZVJlYWR5KGRhdGEpXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXNldDogXCJlbXB0eVwiLFxuICAgICAgICAgIHNraXA6IFwicmVhZHlcIixcbiAgICAgICAgICBkaXNhYmxlOiBcImRpc2FibGVkXCJcbiAgICAgICAgfSxcbiAgICAgICAgcmVhZHk6IHtcbiAgICAgICAgICB1cGRhdGVEYXRhOiBcIndhaXRpbmdcIixcbiAgICAgICAgICBjbGVhcjogXCJjbGVhcmluZ1wiLFxuICAgICAgICAgIGhpZ2hsaWdodDogKGRhdGEpID0+IHRoaXMuYW5pbWF0ZVJlYWR5SGlnaGxpZ2h0KGRhdGEpLFxuICAgICAgICAgIGhpZ2hsaWdodE1hcmtlcnM6IChkYXRhKSA9PiB0aGlzLmFuaW1hdGVSZWFkeUhpZ2hsaWdodE1hcmtlcnMoZGF0YSksXG4gICAgICAgICAgcmVzaXplOiAoZGF0YSkgPT4gdGhpcy5hbmltYXRlUmVhZHlSZXNpemUoZGF0YSksXG4gICAgICAgICAgcmVzZXQ6IFwiZW1wdHlcIixcbiAgICAgICAgICBza2lwOiBcInJlYWR5XCIsXG4gICAgICAgICAgZGlzYWJsZTogXCJkaXNhYmxlZFwiXG4gICAgICAgIH0sXG4gICAgICAgIHdhaXRpbmc6IHtcbiAgICAgICAgICB1cGRhdGU6IHtcbiAgICAgICAgICAgIHRhcmdldDogXCJyZWFkeVwiLFxuICAgICAgICAgICAgYWN0aW9uOiAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICBpZiAodGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5pc1NraXBwZWQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXRBbGxBbmltYXRpb24oZGF0YSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbmltYXRlV2FpdGluZ1VwZGF0ZVJlYWR5KGRhdGEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXNldDogXCJlbXB0eVwiLFxuICAgICAgICAgIHNraXA6IFwicmVhZHlcIixcbiAgICAgICAgICBkaXNhYmxlOiBcImRpc2FibGVkXCJcbiAgICAgICAgfSxcbiAgICAgICAgZGlzYWJsZWQ6IHtcbiAgICAgICAgICB1cGRhdGU6IChkYXRhKSA9PiB0aGlzLnJlc2V0QWxsQW5pbWF0aW9uKGRhdGEpLFxuICAgICAgICAgIHJlc2V0OiBcImVtcHR5XCJcbiAgICAgICAgfSxcbiAgICAgICAgY2xlYXJpbmc6IHtcbiAgICAgICAgICB1cGRhdGU6IHtcbiAgICAgICAgICAgIHRhcmdldDogXCJlbXB0eVwiLFxuICAgICAgICAgICAgYWN0aW9uOiAoZGF0YSkgPT4gdGhpcy5hbmltYXRlQ2xlYXJpbmdVcGRhdGVFbXB0eShkYXRhKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVzZXQ6IFwiZW1wdHlcIixcbiAgICAgICAgICBza2lwOiBcInJlYWR5XCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgICgpID0+IHRoaXMuY2hlY2tQcm9jZXNzZWREYXRhQW5pbWF0YWJsZSgpXG4gICAgKTtcbiAgfVxuICBnZXQgY29udGV4dE5vZGVEYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl9jb250ZXh0Tm9kZURhdGE7XG4gIH1cbiAgZ2V0Tm9kZURhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dE5vZGVEYXRhPy5ub2RlRGF0YTtcbiAgfVxuICByZXNldEFuaW1hdGlvbihwaGFzZSkge1xuICAgIGlmIChwaGFzZSA9PT0gXCJpbml0aWFsXCIpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcInJlc2V0XCIpO1xuICAgIH0gZWxzZSBpZiAocGhhc2UgPT09IFwicmVhZHlcIikge1xuICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwic2tpcFwiKTtcbiAgICB9IGVsc2UgaWYgKHBoYXNlID09PSBcImRpc2FibGVkXCIpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcImRpc2FibGVcIik7XG4gICAgfVxuICB9XG4gIGFkZENoYXJ0RXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5kZXN0cm95Rm5zLnB1c2goXG4gICAgICB0aGlzLmN0eC5jaGFydEV2ZW50TWFuYWdlci5hZGRMaXN0ZW5lcihcImxlZ2VuZC1pdGVtLWNsaWNrXCIsIChldmVudCkgPT4gdGhpcy5vbkxlZ2VuZEl0ZW1DbGljayhldmVudCkpLFxuICAgICAgdGhpcy5jdHguY2hhcnRFdmVudE1hbmFnZXIuYWRkTGlzdGVuZXIoXG4gICAgICAgIFwibGVnZW5kLWl0ZW0tZG91YmxlLWNsaWNrXCIsXG4gICAgICAgIChldmVudCkgPT4gdGhpcy5vbkxlZ2VuZEl0ZW1Eb3VibGVDbGljayhldmVudClcbiAgICAgIClcbiAgICApO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuX2NvbnRleHROb2RlRGF0YSA9IHZvaWQgMDtcbiAgfVxuICBhc3luYyB1cGRhdGUoeyBzZXJpZXNSZWN0IH0pIHtcbiAgICBjb25zdCB7IHZpc2libGUsIF9jb250ZXh0Tm9kZURhdGE6IHByZXZpb3VzQ29udGV4dERhdGEgfSA9IHRoaXM7XG4gICAgY29uc3Qgc2VyaWVzID0gdGhpcy5jdHguaGlnaGxpZ2h0TWFuYWdlcj8uZ2V0QWN0aXZlSGlnaGxpZ2h0KCk/LnNlcmllcztcbiAgICBjb25zdCBzZXJpZXNIaWdobGlnaHRlZCA9IHNlcmllcyA9PT0gdGhpcztcbiAgICBjb25zdCByZXNpemUgPSB0aGlzLmNoZWNrUmVzaXplKHNlcmllc1JlY3QpO1xuICAgIGNvbnN0IGhpZ2hsaWdodEl0ZW1zID0gYXdhaXQgdGhpcy51cGRhdGVIaWdobGlnaHRTZWxlY3Rpb24oc2VyaWVzSGlnaGxpZ2h0ZWQpO1xuICAgIGF3YWl0IHRoaXMudXBkYXRlU2VsZWN0aW9ucyh2aXNpYmxlKTtcbiAgICBhd2FpdCB0aGlzLnVwZGF0ZU5vZGVzKGhpZ2hsaWdodEl0ZW1zLCBzZXJpZXNIaWdobGlnaHRlZCwgdmlzaWJsZSk7XG4gICAgY29uc3QgYW5pbWF0aW9uRGF0YSA9IHRoaXMuZ2V0QW5pbWF0aW9uRGF0YShzZXJpZXNSZWN0LCBwcmV2aW91c0NvbnRleHREYXRhKTtcbiAgICBpZiAoIWFuaW1hdGlvbkRhdGEpXG4gICAgICByZXR1cm47XG4gICAgaWYgKHJlc2l6ZSkge1xuICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwicmVzaXplXCIsIGFuaW1hdGlvbkRhdGEpO1xuICAgIH1cbiAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJ1cGRhdGVcIiwgYW5pbWF0aW9uRGF0YSk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlU2VsZWN0aW9ucyhhbnlTZXJpZXNJdGVtRW5hYmxlZCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBhbmltYXRpb25Ta2lwVXBkYXRlID0gIXRoaXMub3B0cy5hbmltYXRpb25BbHdheXNVcGRhdGVTZWxlY3Rpb25zICYmIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuaXNTa2lwcGVkKCk7XG4gICAgaWYgKCFhbnlTZXJpZXNJdGVtRW5hYmxlZCAmJiBhbmltYXRpb25Ta2lwVXBkYXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5ub2RlRGF0YVJlZnJlc2ggJiYgIXRoaXMuaXNQYXRoT3JTZWxlY3Rpb25EaXJ0eSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLm5vZGVEYXRhUmVmcmVzaCkge1xuICAgICAgdGhpcy5ub2RlRGF0YVJlZnJlc2ggPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVidWcoYENhcnRlc2lhblNlcmllcy51cGRhdGVTZWxlY3Rpb25zKCkgLSBjYWxsaW5nIGNyZWF0ZU5vZGVEYXRhKCkgZm9yYCwgdGhpcy5pZCk7XG4gICAgICB0aGlzLm1hcmtRdWFkdHJlZURpcnR5KCk7XG4gICAgICB0aGlzLl9jb250ZXh0Tm9kZURhdGEgPSBhd2FpdCB0aGlzLmNyZWF0ZU5vZGVEYXRhKCk7XG4gICAgICBjb25zdCBhbmltYXRpb25WYWxpZCA9IHRoaXMuaXNQcm9jZXNzZWREYXRhQW5pbWF0YWJsZSgpO1xuICAgICAgaWYgKHRoaXMuX2NvbnRleHROb2RlRGF0YSkge1xuICAgICAgICAoX2EgPSB0aGlzLl9jb250ZXh0Tm9kZURhdGEpLmFuaW1hdGlvblZhbGlkID8/IChfYS5hbmltYXRpb25WYWxpZCA9IGFuaW1hdGlvblZhbGlkKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubWluUmVjdHNDYWNoZS5kaXJ0eU5vZGVEYXRhID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHsgZGF0YU1vZGVsLCBwcm9jZXNzZWREYXRhIH0gPSB0aGlzO1xuICAgICAgaWYgKGRhdGFNb2RlbCAhPT0gdm9pZCAwICYmIHByb2Nlc3NlZERhdGEgIT09IHZvaWQgMCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoKFwiZGF0YS11cGRhdGVcIiwgeyBkYXRhTW9kZWwsIHByb2Nlc3NlZERhdGEgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGF3YWl0IHRoaXMudXBkYXRlU2VyaWVzU2VsZWN0aW9ucygpO1xuICB9XG4gIGFzeW5jIHVwZGF0ZVNlcmllc1NlbGVjdGlvbnMoc2VyaWVzSGlnaGxpZ2h0ZWQpIHtcbiAgICBjb25zdCB7IGRhdHVtU2VsZWN0aW9uLCBsYWJlbFNlbGVjdGlvbiwgbWFya2VyU2VsZWN0aW9uLCBwYXRocyB9ID0gdGhpcztcbiAgICBjb25zdCBjb250ZXh0RGF0YSA9IHRoaXMuX2NvbnRleHROb2RlRGF0YTtcbiAgICBpZiAoIWNvbnRleHREYXRhKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgbm9kZURhdGEsIGxhYmVsRGF0YSwgaXRlbUlkIH0gPSBjb250ZXh0RGF0YTtcbiAgICBhd2FpdCB0aGlzLnVwZGF0ZVBhdGhzKHsgc2VyaWVzSGlnaGxpZ2h0ZWQsIGl0ZW1JZCwgY29udGV4dERhdGEsIHBhdGhzIH0pO1xuICAgIHRoaXMuZGF0dW1TZWxlY3Rpb24gPSBhd2FpdCB0aGlzLnVwZGF0ZURhdHVtU2VsZWN0aW9uKHsgbm9kZURhdGEsIGRhdHVtU2VsZWN0aW9uIH0pO1xuICAgIHRoaXMubGFiZWxTZWxlY3Rpb24gPSBhd2FpdCB0aGlzLnVwZGF0ZUxhYmVsU2VsZWN0aW9uKHsgbGFiZWxEYXRhLCBsYWJlbFNlbGVjdGlvbiB9KTtcbiAgICBpZiAodGhpcy5vcHRzLmhhc01hcmtlcnMpIHtcbiAgICAgIHRoaXMubWFya2VyU2VsZWN0aW9uID0gYXdhaXQgdGhpcy51cGRhdGVNYXJrZXJTZWxlY3Rpb24oeyBub2RlRGF0YSwgbWFya2VyU2VsZWN0aW9uIH0pO1xuICAgIH1cbiAgfVxuICBtYXJrZXJGYWN0b3J5KCkge1xuICAgIGNvbnN0IE1hcmtlclNoYXBlID0gZ2V0TWFya2VyKCk7XG4gICAgcmV0dXJuIG5ldyBNYXJrZXJTaGFwZSgpO1xuICB9XG4gIGdldEdyb3VwWkluZGV4U3ViT3JkZXIodHlwZSwgc3ViSW5kZXggPSAwKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gc3VwZXIuZ2V0R3JvdXBaSW5kZXhTdWJPcmRlcih0eXBlLCBzdWJJbmRleCk7XG4gICAgaWYgKHR5cGUgPT09IFwicGF0aHNcIikge1xuICAgICAgY29uc3QgW3N1cGVyRm5dID0gcmVzdWx0O1xuICAgICAgY29uc3QgcGF0aE9mZnNldCA9IHRoaXMub3B0cy5wYXRoc1pJbmRleFN1Yk9yZGVyT2Zmc2V0W3N1YkluZGV4XSA/PyAwO1xuICAgICAgcmVzdWx0WzBdID0gaXNGdW5jdGlvbihzdXBlckZuKSA/ICgpID0+IE51bWJlcihzdXBlckZuKCkpICsgcGF0aE9mZnNldCA6IE51bWJlcihzdXBlckZuKSArIHBhdGhPZmZzZXQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgYXN5bmMgdXBkYXRlTm9kZXMoaGlnaGxpZ2h0ZWRJdGVtcywgc2VyaWVzSGlnaGxpZ2h0ZWQsIGFueVNlcmllc0l0ZW1FbmFibGVkKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGlnaGxpZ2h0U2VsZWN0aW9uLFxuICAgICAgaGlnaGxpZ2h0TGFiZWxTZWxlY3Rpb24sXG4gICAgICBvcHRzOiB7IGhhc01hcmtlcnMsIGhhc0hpZ2hsaWdodGVkTGFiZWxzIH1cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBhbmltYXRpb25FbmFibGVkID0gIXRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuaXNTa2lwcGVkKCk7XG4gICAgY29uc3QgdmlzaWJsZSA9IHRoaXMudmlzaWJsZSAmJiB0aGlzLl9jb250ZXh0Tm9kZURhdGEgIT0gbnVsbCAmJiBhbnlTZXJpZXNJdGVtRW5hYmxlZDtcbiAgICB0aGlzLnJvb3RHcm91cC52aXNpYmxlID0gYW5pbWF0aW9uRW5hYmxlZCB8fCB2aXNpYmxlO1xuICAgIHRoaXMuY29udGVudEdyb3VwLnZpc2libGUgPSBhbmltYXRpb25FbmFibGVkIHx8IHZpc2libGU7XG4gICAgdGhpcy5oaWdobGlnaHRHcm91cC52aXNpYmxlID0gKGFuaW1hdGlvbkVuYWJsZWQgfHwgdmlzaWJsZSkgJiYgc2VyaWVzSGlnaGxpZ2h0ZWQ7XG4gICAgY29uc3Qgb3BhY2l0eSA9IHRoaXMuZ2V0T3BhY2l0eSgpO1xuICAgIGlmIChoYXNNYXJrZXJzKSB7XG4gICAgICBhd2FpdCB0aGlzLnVwZGF0ZU1hcmtlck5vZGVzKHtcbiAgICAgICAgbWFya2VyU2VsZWN0aW9uOiBoaWdobGlnaHRTZWxlY3Rpb24sXG4gICAgICAgIGlzSGlnaGxpZ2h0OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcImhpZ2hsaWdodE1hcmtlcnNcIiwgaGlnaGxpZ2h0U2VsZWN0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXdhaXQgdGhpcy51cGRhdGVEYXR1bU5vZGVzKHtcbiAgICAgICAgZGF0dW1TZWxlY3Rpb246IGhpZ2hsaWdodFNlbGVjdGlvbixcbiAgICAgICAgaXNIaWdobGlnaHQ6IHRydWVcbiAgICAgIH0pO1xuICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwiaGlnaGxpZ2h0XCIsIGhpZ2hsaWdodFNlbGVjdGlvbik7XG4gICAgfVxuICAgIGlmIChoYXNIaWdobGlnaHRlZExhYmVscykge1xuICAgICAgYXdhaXQgdGhpcy51cGRhdGVMYWJlbE5vZGVzKHsgbGFiZWxTZWxlY3Rpb246IGhpZ2hsaWdodExhYmVsU2VsZWN0aW9uIH0pO1xuICAgIH1cbiAgICBjb25zdCB7IGRhdGFOb2RlR3JvdXAsIG1hcmtlckdyb3VwLCBkYXR1bVNlbGVjdGlvbiwgbGFiZWxTZWxlY3Rpb24sIG1hcmtlclNlbGVjdGlvbiwgcGF0aHMsIGxhYmVsR3JvdXAgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBpdGVtSWQgfSA9IHRoaXMuY29udGV4dE5vZGVEYXRhID8/IHt9O1xuICAgIGRhdGFOb2RlR3JvdXAub3BhY2l0eSA9IG9wYWNpdHk7XG4gICAgZGF0YU5vZGVHcm91cC52aXNpYmxlID0gYW5pbWF0aW9uRW5hYmxlZCB8fCB2aXNpYmxlO1xuICAgIGxhYmVsR3JvdXAudmlzaWJsZSA9IHZpc2libGU7XG4gICAgaWYgKGhhc01hcmtlcnMpIHtcbiAgICAgIG1hcmtlckdyb3VwLm9wYWNpdHkgPSBvcGFjaXR5O1xuICAgICAgbWFya2VyR3JvdXAuekluZGV4ID0gZGF0YU5vZGVHcm91cC56SW5kZXggPj0gNCAvKiBTRVJJRVNfTEFZRVIgKi8gPyBkYXRhTm9kZUdyb3VwLnpJbmRleCA6IGRhdGFOb2RlR3JvdXAuekluZGV4ICsgMTtcbiAgICAgIG1hcmtlckdyb3VwLnZpc2libGUgPSB2aXNpYmxlO1xuICAgIH1cbiAgICBpZiAobGFiZWxHcm91cCkge1xuICAgICAgbGFiZWxHcm91cC5vcGFjaXR5ID0gb3BhY2l0eTtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy51cGRhdGVQYXRoTm9kZXMoe1xuICAgICAgc2VyaWVzSGlnaGxpZ2h0ZWQsXG4gICAgICBpdGVtSWQsXG4gICAgICBwYXRocyxcbiAgICAgIG9wYWNpdHksXG4gICAgICB2aXNpYmxlLFxuICAgICAgYW5pbWF0aW9uRW5hYmxlZFxuICAgIH0pO1xuICAgIGlmICghZGF0YU5vZGVHcm91cC52aXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGF3YWl0IHRoaXMudXBkYXRlRGF0dW1Ob2Rlcyh7IGRhdHVtU2VsZWN0aW9uLCBoaWdobGlnaHRlZEl0ZW1zLCBpc0hpZ2hsaWdodDogZmFsc2UgfSk7XG4gICAgYXdhaXQgdGhpcy51cGRhdGVMYWJlbE5vZGVzKHsgbGFiZWxTZWxlY3Rpb24gfSk7XG4gICAgaWYgKGhhc01hcmtlcnMpIHtcbiAgICAgIGF3YWl0IHRoaXMudXBkYXRlTWFya2VyTm9kZXMoeyBtYXJrZXJTZWxlY3Rpb24sIGlzSGlnaGxpZ2h0OiBmYWxzZSB9KTtcbiAgICB9XG4gIH1cbiAgZ2V0SGlnaGxpZ2h0TGFiZWxEYXRhKGxhYmVsRGF0YSwgaGlnaGxpZ2h0ZWRJdGVtKSB7XG4gICAgY29uc3QgbGFiZWxJdGVtcyA9IGxhYmVsRGF0YS5maWx0ZXIoXG4gICAgICAobGQpID0+IGxkLmRhdHVtID09PSBoaWdobGlnaHRlZEl0ZW0uZGF0dW0gJiYgbGQuaXRlbUlkID09PSBoaWdobGlnaHRlZEl0ZW0uaXRlbUlkXG4gICAgKTtcbiAgICByZXR1cm4gbGFiZWxJdGVtcy5sZW5ndGggPT09IDAgPyB2b2lkIDAgOiBsYWJlbEl0ZW1zO1xuICB9XG4gIGdldEhpZ2hsaWdodERhdGEoX25vZGVEYXRhLCBoaWdobGlnaHRlZEl0ZW0pIHtcbiAgICByZXR1cm4gaGlnaGxpZ2h0ZWRJdGVtID8gW2hpZ2hsaWdodGVkSXRlbV0gOiB2b2lkIDA7XG4gIH1cbiAgYXN5bmMgdXBkYXRlSGlnaGxpZ2h0U2VsZWN0aW9uKHNlcmllc0hpZ2hsaWdodGVkKSB7XG4gICAgY29uc3QgeyBoaWdobGlnaHRTZWxlY3Rpb24sIGhpZ2hsaWdodExhYmVsU2VsZWN0aW9uLCBfY29udGV4dE5vZGVEYXRhOiBjb250ZXh0Tm9kZURhdGEgfSA9IHRoaXM7XG4gICAgaWYgKCFjb250ZXh0Tm9kZURhdGEpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgaGlnaGxpZ2h0ZWREYXR1bSA9IHRoaXMuY3R4LmhpZ2hsaWdodE1hbmFnZXI/LmdldEFjdGl2ZUhpZ2hsaWdodCgpO1xuICAgIGNvbnN0IGl0ZW0gPSBzZXJpZXNIaWdobGlnaHRlZCAmJiBoaWdobGlnaHRlZERhdHVtPy5kYXR1bSA/IGhpZ2hsaWdodGVkRGF0dW0gOiB2b2lkIDA7XG4gICAgbGV0IGxhYmVsSXRlbXM7XG4gICAgbGV0IGhpZ2hsaWdodEl0ZW1zO1xuICAgIGlmIChpdGVtICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IGxhYmVsc0VuYWJsZWQgPSB0aGlzLmlzTGFiZWxFbmFibGVkKCk7XG4gICAgICBjb25zdCB7IGxhYmVsRGF0YSwgbm9kZURhdGEgfSA9IGNvbnRleHROb2RlRGF0YTtcbiAgICAgIGhpZ2hsaWdodEl0ZW1zID0gdGhpcy5nZXRIaWdobGlnaHREYXRhKG5vZGVEYXRhLCBpdGVtKTtcbiAgICAgIGxhYmVsSXRlbXMgPSBsYWJlbHNFbmFibGVkID8gdGhpcy5nZXRIaWdobGlnaHRMYWJlbERhdGEobGFiZWxEYXRhLCBpdGVtKSA6IHZvaWQgMDtcbiAgICB9XG4gICAgdGhpcy5oaWdobGlnaHRTZWxlY3Rpb24gPSBhd2FpdCB0aGlzLnVwZGF0ZUhpZ2hsaWdodFNlbGVjdGlvbkl0ZW0oe1xuICAgICAgaXRlbXM6IGhpZ2hsaWdodEl0ZW1zLFxuICAgICAgaGlnaGxpZ2h0U2VsZWN0aW9uXG4gICAgfSk7XG4gICAgdGhpcy5oaWdobGlnaHRMYWJlbFNlbGVjdGlvbiA9IGF3YWl0IHRoaXMudXBkYXRlSGlnaGxpZ2h0U2VsZWN0aW9uTGFiZWwoe1xuICAgICAgaXRlbXM6IGxhYmVsSXRlbXMsXG4gICAgICBoaWdobGlnaHRMYWJlbFNlbGVjdGlvblxuICAgIH0pO1xuICAgIHJldHVybiBoaWdobGlnaHRJdGVtcztcbiAgfVxuICBtYXJrUXVhZHRyZWVEaXJ0eSgpIHtcbiAgICB0aGlzLnF1YWR0cmVlID0gdm9pZCAwO1xuICB9XG4gICpkYXR1bU5vZGVzSXRlcigpIHtcbiAgICBmb3IgKGNvbnN0IHsgbm9kZSB9IG9mIHRoaXMuZGF0dW1TZWxlY3Rpb24pIHtcbiAgICAgIGlmIChub2RlLmRhdHVtLm1pc3NpbmcgPT09IHRydWUpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgeWllbGQgbm9kZTtcbiAgICB9XG4gIH1cbiAgZ2V0UXVhZFRyZWUoKSB7XG4gICAgaWYgKHRoaXMucXVhZHRyZWUgPT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgeyB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIgfSA9IHRoaXMuY3R4LnNjZW5lLmNhbnZhcztcbiAgICAgIGNvbnN0IGNhbnZhc1JlY3QgPSBuZXcgQkJveCgwLCAwLCB3aWR0aDIsIGhlaWdodDIpO1xuICAgICAgdGhpcy5xdWFkdHJlZSA9IG5ldyBRdWFkdHJlZU5lYXJlc3QoMTAwLCAxMCwgY2FudmFzUmVjdCk7XG4gICAgICB0aGlzLmluaXRRdWFkVHJlZSh0aGlzLnF1YWR0cmVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucXVhZHRyZWU7XG4gIH1cbiAgaW5pdFF1YWRUcmVlKF9xdWFkdHJlZSkge1xuICB9XG4gIHBpY2tOb2RlRXhhY3RTaGFwZShwb2ludCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHN1cGVyLnBpY2tOb2RlRXhhY3RTaGFwZShwb2ludCk7XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgY29uc3QgeyB4LCB5IH0gPSBwb2ludDtcbiAgICBjb25zdCB7XG4gICAgICBvcHRzOiB7IGhhc01hcmtlcnMgfVxuICAgIH0gPSB0aGlzO1xuICAgIGxldCBtYXRjaDtcbiAgICBjb25zdCB7IGRhdGFOb2RlR3JvdXAsIG1hcmtlckdyb3VwIH0gPSB0aGlzO1xuICAgIG1hdGNoID0gZGF0YU5vZGVHcm91cC5waWNrTm9kZSh4LCB5KTtcbiAgICBpZiAoIW1hdGNoICYmIGhhc01hcmtlcnMpIHtcbiAgICAgIG1hdGNoID0gbWFya2VyR3JvdXA/LnBpY2tOb2RlKHgsIHkpO1xuICAgIH1cbiAgICBpZiAobWF0Y2ggJiYgbWF0Y2guZGF0dW0ubWlzc2luZyAhPT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIHsgZGF0dW06IG1hdGNoLmRhdHVtLCBkaXN0YW5jZTogMCB9O1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IG1vZDIgb2YgdGhpcy5tb2R1bGVNYXAubW9kdWxlcygpKSB7XG4gICAgICBjb25zdCB7IGRhdHVtIH0gPSBtb2QyLnBpY2tOb2RlRXhhY3QocG9pbnQpID8/IHt9O1xuICAgICAgaWYgKGRhdHVtID09IG51bGwpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgaWYgKGRhdHVtPy5taXNzaW5nID09PSB0cnVlKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHJldHVybiB7IGRhdHVtLCBkaXN0YW5jZTogMCB9O1xuICAgIH1cbiAgfVxuICBwaWNrTm9kZUNsb3Nlc3REYXR1bShwb2ludCkge1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gcG9pbnQ7XG4gICAgY29uc3QgeyBheGVzLCBfY29udGV4dE5vZGVEYXRhOiBjb250ZXh0Tm9kZURhdGEgfSA9IHRoaXM7XG4gICAgaWYgKCFjb250ZXh0Tm9kZURhdGEpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeEF4aXMgPSBheGVzW1wieFwiIC8qIFggKi9dO1xuICAgIGNvbnN0IHlBeGlzID0gYXhlc1tcInlcIiAvKiBZICovXTtcbiAgICBjb25zdCBoaXRQb2ludCA9IHsgeCwgeSB9O1xuICAgIGxldCBtaW5EaXN0YW5jZSA9IEluZmluaXR5O1xuICAgIGxldCBjbG9zZXN0RGF0dW07XG4gICAgZm9yIChjb25zdCBkYXR1bSBvZiBjb250ZXh0Tm9kZURhdGEubm9kZURhdGEpIHtcbiAgICAgIGNvbnN0IHsgcG9pbnQ6IHsgeDogZGF0dW1YID0gTmFOLCB5OiBkYXR1bVkgPSBOYU4gfSA9IHt9IH0gPSBkYXR1bTtcbiAgICAgIGlmIChpc05hTihkYXR1bVgpIHx8IGlzTmFOKGRhdHVtWSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBpc0luUmFuZ2UgPSB4QXhpcz8uaW5SYW5nZShkYXR1bVgpICYmIHlBeGlzPy5pblJhbmdlKGRhdHVtWSk7XG4gICAgICBpZiAoIWlzSW5SYW5nZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRpc3RhbmNlMyA9IE1hdGgubWF4KChoaXRQb2ludC54IC0gZGF0dW1YKSAqKiAyICsgKGhpdFBvaW50LnkgLSBkYXR1bVkpICoqIDIsIDApO1xuICAgICAgaWYgKGRpc3RhbmNlMyA8IG1pbkRpc3RhbmNlKSB7XG4gICAgICAgIG1pbkRpc3RhbmNlID0gZGlzdGFuY2UzO1xuICAgICAgICBjbG9zZXN0RGF0dW0gPSBkYXR1bTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBtb2QyIG9mIHRoaXMubW9kdWxlTWFwLm1vZHVsZXMoKSkge1xuICAgICAgY29uc3QgbW9kUGljayA9IG1vZDIucGlja05vZGVOZWFyZXN0KHBvaW50KTtcbiAgICAgIGlmIChtb2RQaWNrICE9PSB2b2lkIDAgJiYgbW9kUGljay5kaXN0YW5jZVNxdWFyZWQgPCBtaW5EaXN0YW5jZSkge1xuICAgICAgICBtaW5EaXN0YW5jZSA9IG1vZFBpY2suZGlzdGFuY2VTcXVhcmVkO1xuICAgICAgICBjbG9zZXN0RGF0dW0gPSBtb2RQaWNrLmRhdHVtO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNsb3Nlc3REYXR1bSkge1xuICAgICAgY29uc3QgZGlzdGFuY2UzID0gTWF0aC5tYXgoTWF0aC5zcXJ0KG1pbkRpc3RhbmNlKSAtIChjbG9zZXN0RGF0dW0ucG9pbnQ/LnNpemUgPz8gMCksIDApO1xuICAgICAgcmV0dXJuIHsgZGF0dW06IGNsb3Nlc3REYXR1bSwgZGlzdGFuY2U6IGRpc3RhbmNlMyB9O1xuICAgIH1cbiAgfVxuICBwaWNrTm9kZU1haW5BeGlzRmlyc3QocG9pbnQsIHJlcXVpcmVDYXRlZ29yeUF4aXMpIHtcbiAgICBjb25zdCB7IHgsIHkgfSA9IHBvaW50O1xuICAgIGNvbnN0IHsgYXhlcywgX2NvbnRleHROb2RlRGF0YTogY29udGV4dE5vZGVEYXRhIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgcGlja091dHNpZGVWaXNpYmxlTWlub3JBeGlzIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgaWYgKCFjb250ZXh0Tm9kZURhdGEpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeEF4aXMgPSBheGVzW1wieFwiIC8qIFggKi9dO1xuICAgIGNvbnN0IHlBeGlzID0gYXhlc1tcInlcIiAvKiBZICovXTtcbiAgICBjb25zdCBkaXJlY3Rpb25zMiA9IFt4QXhpcywgeUF4aXNdLmZpbHRlcihDYXRlZ29yeUF4aXMuaXMpLm1hcCgoYSkgPT4gYS5kaXJlY3Rpb24pO1xuICAgIGlmIChyZXF1aXJlQ2F0ZWdvcnlBeGlzICYmIGRpcmVjdGlvbnMyLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBbbWFqb3JEaXJlY3Rpb24gPSBcInhcIiAvKiBYICovXSA9IGRpcmVjdGlvbnMyO1xuICAgIGNvbnN0IGhpdFBvaW50Q29vcmRzID0gW3gsIHldO1xuICAgIGlmIChtYWpvckRpcmVjdGlvbiAhPT0gXCJ4XCIgLyogWCAqLylcbiAgICAgIGhpdFBvaW50Q29vcmRzLnJldmVyc2UoKTtcbiAgICBjb25zdCBtaW5EaXN0YW5jZSA9IFtJbmZpbml0eSwgSW5maW5pdHldO1xuICAgIGxldCBjbG9zZXN0RGF0dW07XG4gICAgZm9yIChjb25zdCBkYXR1bSBvZiBjb250ZXh0Tm9kZURhdGEubm9kZURhdGEpIHtcbiAgICAgIGNvbnN0IHsgeDogZGF0dW1YID0gTmFOLCB5OiBkYXR1bVkgPSBOYU4gfSA9IGRhdHVtLnBvaW50ID8/IGRhdHVtLm1pZFBvaW50ID8/IHt9O1xuICAgICAgaWYgKGlzTmFOKGRhdHVtWCkgfHwgaXNOYU4oZGF0dW1ZKSB8fCBkYXR1bS5taXNzaW5nID09PSB0cnVlKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IHZpc2libGUgPSBbeEF4aXM/LmluUmFuZ2UoZGF0dW1YKSwgeUF4aXM/LmluUmFuZ2UoZGF0dW1ZKV07XG4gICAgICBpZiAobWFqb3JEaXJlY3Rpb24gIT09IFwieFwiIC8qIFggKi8pIHtcbiAgICAgICAgdmlzaWJsZS5yZXZlcnNlKCk7XG4gICAgICB9XG4gICAgICBpZiAoIXZpc2libGVbMF0gfHwgIXBpY2tPdXRzaWRlVmlzaWJsZU1pbm9yQXhpcyAmJiAhdmlzaWJsZVsxXSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCBkYXR1bVBvaW50ID0gW2RhdHVtWCwgZGF0dW1ZXTtcbiAgICAgIGlmIChtYWpvckRpcmVjdGlvbiAhPT0gXCJ4XCIgLyogWCAqLykge1xuICAgICAgICBkYXR1bVBvaW50LnJldmVyc2UoKTtcbiAgICAgIH1cbiAgICAgIGxldCBuZXdNaW5EaXN0YW5jZSA9IHRydWU7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdHVtUG9pbnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZGlzdCA9IE1hdGguYWJzKGRhdHVtUG9pbnRbaV0gLSBoaXRQb2ludENvb3Jkc1tpXSk7XG4gICAgICAgIGlmIChkaXN0ID4gbWluRGlzdGFuY2VbaV0pIHtcbiAgICAgICAgICBuZXdNaW5EaXN0YW5jZSA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2UgaWYgKGRpc3QgPCBtaW5EaXN0YW5jZVtpXSkge1xuICAgICAgICAgIG1pbkRpc3RhbmNlW2ldID0gZGlzdDtcbiAgICAgICAgICBtaW5EaXN0YW5jZS5maWxsKEluZmluaXR5LCBpICsgMSwgbWluRGlzdGFuY2UubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5ld01pbkRpc3RhbmNlKSB7XG4gICAgICAgIGNsb3Nlc3REYXR1bSA9IGRhdHVtO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2xvc2VzdERhdHVtKSB7XG4gICAgICBsZXQgY2xvc2VzdERpc3RhbmNlU3F1YXJlZCA9IE1hdGgubWF4KFxuICAgICAgICBtaW5EaXN0YW5jZVswXSAqKiAyICsgbWluRGlzdGFuY2VbMV0gKiogMiAtIChjbG9zZXN0RGF0dW0ucG9pbnQ/LnNpemUgPz8gMCksXG4gICAgICAgIDBcbiAgICAgICk7XG4gICAgICBmb3IgKGNvbnN0IG1vZDIgb2YgdGhpcy5tb2R1bGVNYXAubW9kdWxlcygpKSB7XG4gICAgICAgIGNvbnN0IG1vZFBpY2sgPSBtb2QyLnBpY2tOb2RlTWFpbkF4aXNGaXJzdChwb2ludCk7XG4gICAgICAgIGlmIChtb2RQaWNrICE9PSB2b2lkIDAgJiYgbW9kUGljay5kaXN0YW5jZVNxdWFyZWQgPCBjbG9zZXN0RGlzdGFuY2VTcXVhcmVkKSB7XG4gICAgICAgICAgY2xvc2VzdERhdHVtID0gbW9kUGljay5kYXR1bTtcbiAgICAgICAgICBjbG9zZXN0RGlzdGFuY2VTcXVhcmVkID0gbW9kUGljay5kaXN0YW5jZVNxdWFyZWQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7IGRhdHVtOiBjbG9zZXN0RGF0dW0sIGRpc3RhbmNlOiBNYXRoLnNxcnQoY2xvc2VzdERpc3RhbmNlU3F1YXJlZCkgfTtcbiAgICB9XG4gIH1cbiAgb25MZWdlbmRJdGVtQ2xpY2soZXZlbnQpIHtcbiAgICBjb25zdCB7IGxlZ2VuZEl0ZW1OYW1lIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgeyBlbmFibGVkLCBpdGVtSWQsIHNlcmllcyB9ID0gZXZlbnQ7XG4gICAgY29uc3QgbWF0Y2hlZExlZ2VuZEl0ZW1OYW1lID0gbGVnZW5kSXRlbU5hbWUgIT0gbnVsbCAmJiBsZWdlbmRJdGVtTmFtZSA9PT0gZXZlbnQubGVnZW5kSXRlbU5hbWU7XG4gICAgaWYgKHNlcmllcy5pZCA9PT0gdGhpcy5pZCB8fCBtYXRjaGVkTGVnZW5kSXRlbU5hbWUpIHtcbiAgICAgIHRoaXMudG9nZ2xlU2VyaWVzSXRlbShpdGVtSWQsIGVuYWJsZWQpO1xuICAgIH1cbiAgfVxuICBvbkxlZ2VuZEl0ZW1Eb3VibGVDbGljayhldmVudCkge1xuICAgIGNvbnN0IHsgZW5hYmxlZCwgaXRlbUlkLCBzZXJpZXMsIG51bVZpc2libGVJdGVtcyB9ID0gZXZlbnQ7XG4gICAgY29uc3QgeyBsZWdlbmRJdGVtTmFtZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IG1hdGNoZWRMZWdlbmRJdGVtTmFtZSA9IGxlZ2VuZEl0ZW1OYW1lICE9IG51bGwgJiYgbGVnZW5kSXRlbU5hbWUgPT09IGV2ZW50LmxlZ2VuZEl0ZW1OYW1lO1xuICAgIGlmIChzZXJpZXMuaWQgPT09IHRoaXMuaWQgfHwgbWF0Y2hlZExlZ2VuZEl0ZW1OYW1lKSB7XG4gICAgICB0aGlzLnRvZ2dsZVNlcmllc0l0ZW0oaXRlbUlkLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKGVuYWJsZWQgJiYgbnVtVmlzaWJsZUl0ZW1zID09PSAxKSB7XG4gICAgICB0aGlzLnRvZ2dsZVNlcmllc0l0ZW0oaXRlbUlkLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50b2dnbGVTZXJpZXNJdGVtKGl0ZW1JZCwgZmFsc2UpO1xuICAgIH1cbiAgfVxuICBpc1BhdGhPclNlbGVjdGlvbkRpcnR5KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBnZXRMYWJlbERhdGEoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHNob3VsZEZsaXBYWSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgbWluaW11bSBib3VuZGluZyBib3ggdGhhdCBjb250YWlucyBhbnkgYWRqYWNlbnQgdHdvIG5vZGVzLiBUaGUgYXhlcyBhcmUgdHJlYXRlZCBpbmRlcGVuZGVudGx5LCBzbyB0aGlzXG4gICAqIG1heSBub3QgcmVwcmVzZW50IHRoZSBzYW1lIHR3byBwb2ludHMgZm9yIGJvdGggZGlyZWN0aW9ucy4gVGhlIGRpbWVuc2lvbnMgcmVwcmVzZW50IHRoZSBncmVhdGVzdCBkaXN0YW5jZVxuICAgKiBiZXR3ZWVuIGFueSB0d28gYWRqYWNlbnQgbm9kZXMuXG4gICAqL1xuICBnZXRNaW5SZWN0cyh3aWR0aDIsIGhlaWdodDIpIHtcbiAgICBjb25zdCB7IGRpcnR5Tm9kZURhdGEsIHNpemVDYWNoZSwgbWluUmVjdCwgbWluVmlzaWJsZVJlY3QgfSA9IHRoaXMubWluUmVjdHNDYWNoZTtcbiAgICBjb25zdCBuZXdTaXplQ2FjaGUgPSBKU09OLnN0cmluZ2lmeSh7IHdpZHRoOiB3aWR0aDIsIGhlaWdodDogaGVpZ2h0MiB9KTtcbiAgICBjb25zdCBkaXJ0eVNpemUgPSBuZXdTaXplQ2FjaGUgIT09IHNpemVDYWNoZTtcbiAgICBpZiAoIWRpcnR5U2l6ZSAmJiAhZGlydHlOb2RlRGF0YSAmJiBtaW5SZWN0ICYmIG1pblZpc2libGVSZWN0KSB7XG4gICAgICByZXR1cm4geyBtaW5SZWN0LCBtaW5WaXNpYmxlUmVjdCB9O1xuICAgIH1cbiAgICBjb25zdCByZWN0cyA9IHRoaXMuY29tcHV0ZU1pblJlY3RzKHdpZHRoMiwgaGVpZ2h0Mik7XG4gICAgdGhpcy5taW5SZWN0c0NhY2hlID0ge1xuICAgICAgZGlydHlOb2RlRGF0YTogZmFsc2UsXG4gICAgICBzaXplQ2FjaGU6IG5ld1NpemVDYWNoZSxcbiAgICAgIG1pblJlY3Q6IHJlY3RzPy5taW5SZWN0LFxuICAgICAgbWluVmlzaWJsZVJlY3Q6IHJlY3RzPy5taW5WaXNpYmxlUmVjdFxuICAgIH07XG4gICAgcmV0dXJuIHJlY3RzO1xuICB9XG4gIGNvbXB1dGVNaW5SZWN0cyh3aWR0aDIsIGhlaWdodDIpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5fY29udGV4dE5vZGVEYXRhO1xuICAgIGlmICghY29udGV4dD8ubm9kZURhdGEubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgbm9kZURhdGEgfSA9IGNvbnRleHQ7XG4gICAgY29uc3QgbWluUmVjdFhzID0gQXJyYXkobm9kZURhdGEubGVuZ3RoKTtcbiAgICBjb25zdCBtaW5SZWN0WXMgPSBBcnJheShub2RlRGF0YS5sZW5ndGgpO1xuICAgIGZvciAoY29uc3QgW2ksIHsgbWlkUG9pbnQgfV0gb2Ygbm9kZURhdGEuZW50cmllcygpKSB7XG4gICAgICBtaW5SZWN0WHNbaV0gPSBtaWRQb2ludD8ueCA/PyAwO1xuICAgICAgbWluUmVjdFlzW2ldID0gbWlkUG9pbnQ/LnkgPz8gMDtcbiAgICB9XG4gICAgbWluUmVjdFhzLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgICBtaW5SZWN0WXMuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgIGxldCB6ZXJvWCwgd2lkdGhYLCB6ZXJvWSwgaGVpZ2h0WTtcbiAgICBsZXQgbWF4V2lkdGggPSAwO1xuICAgIGxldCBtYXhIZWlnaHQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbm9kZURhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChtaW5SZWN0WHNbaV0gPj0gMClcbiAgICAgICAgemVyb1ggPz8gKHplcm9YID0gaSk7XG4gICAgICBpZiAobWluUmVjdFhzW2ldID4gd2lkdGgyKVxuICAgICAgICB3aWR0aFggPz8gKHdpZHRoWCA9IGkpO1xuICAgICAgaWYgKG1pblJlY3RZc1tpXSA+PSAwKVxuICAgICAgICB6ZXJvWSA/PyAoemVyb1kgPSBpKTtcbiAgICAgIGlmIChtaW5SZWN0WXNbaV0gPiBoZWlnaHQyKVxuICAgICAgICBoZWlnaHRZID8/IChoZWlnaHRZID0gaSk7XG4gICAgICBtYXhXaWR0aCA9IE1hdGgubWF4KG1heFdpZHRoLCBtaW5SZWN0WHNbaV0gLSBtaW5SZWN0WHNbaSAtIDFdKTtcbiAgICAgIG1heEhlaWdodCA9IE1hdGgubWF4KG1heEhlaWdodCwgbWluUmVjdFlzW2ldIC0gbWluUmVjdFlzW2kgLSAxXSk7XG4gICAgfVxuICAgIHdpZHRoWCA/PyAod2lkdGhYID0gbm9kZURhdGEubGVuZ3RoKTtcbiAgICBoZWlnaHRZID8/IChoZWlnaHRZID0gbm9kZURhdGEubGVuZ3RoKTtcbiAgICBjb25zdCBtaW5WaXNpYmxlUmVjdFhzID0gemVyb1ggIT0gbnVsbCAmJiB3aWR0aFggIT0gbnVsbCA/IG1pblJlY3RYcy5zbGljZSh6ZXJvWCwgd2lkdGhYKSA6IFtdO1xuICAgIGNvbnN0IG1pblZpc2libGVSZWN0WXMgPSB6ZXJvWSAhPSBudWxsICYmIGhlaWdodFkgIT0gbnVsbCA/IG1pblJlY3RZcy5zbGljZSh6ZXJvWSwgaGVpZ2h0WSkgOiBbXTtcbiAgICBsZXQgbWF4VmlzaWJsZVdpZHRoID0gMDtcbiAgICBsZXQgbWF4VmlzaWJsZUhlaWdodCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBNYXRoLm1heChtaW5WaXNpYmxlUmVjdFhzLmxlbmd0aCwgbWluVmlzaWJsZVJlY3RZcy5sZW5ndGgpOyBpKyspIHtcbiAgICAgIGNvbnN0IHgxID0gbWluVmlzaWJsZVJlY3RYc1tpXTtcbiAgICAgIGNvbnN0IHgyID0gbWluVmlzaWJsZVJlY3RYc1tpIC0gMV07XG4gICAgICBjb25zdCB5MSA9IG1pblZpc2libGVSZWN0WXNbaV07XG4gICAgICBjb25zdCB5MiA9IG1pblZpc2libGVSZWN0WXNbaSAtIDFdO1xuICAgICAgaWYgKHgxICE9IG51bGwgJiYgeDIgIT0gbnVsbCkge1xuICAgICAgICBtYXhWaXNpYmxlV2lkdGggPSBNYXRoLm1heChtYXhWaXNpYmxlV2lkdGgsIHgxIC0geDIpO1xuICAgICAgfVxuICAgICAgaWYgKHkxICE9IG51bGwgJiYgeTIgIT0gbnVsbCkge1xuICAgICAgICBtYXhWaXNpYmxlSGVpZ2h0ID0gTWF0aC5tYXgobWF4VmlzaWJsZUhlaWdodCwgeTEgLSB5Mik7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG1pblJlY3QgPSBuZXcgQkJveCgwLCAwLCBtYXhXaWR0aCwgbWF4SGVpZ2h0KTtcbiAgICBjb25zdCBtaW5WaXNpYmxlUmVjdCA9IG5ldyBCQm94KDAsIDAsIG1heFZpc2libGVXaWR0aCwgbWF4VmlzaWJsZUhlaWdodCk7XG4gICAgcmV0dXJuIHsgbWluUmVjdCwgbWluVmlzaWJsZVJlY3QgfTtcbiAgfVxuICB1cGRhdGVIaWdobGlnaHRTZWxlY3Rpb25JdGVtKG9wdHMpIHtcbiAgICBjb25zdCB7XG4gICAgICBvcHRzOiB7IGhhc01hcmtlcnMgfVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgaXRlbXMsIGhpZ2hsaWdodFNlbGVjdGlvbiB9ID0gb3B0cztcbiAgICBjb25zdCBub2RlRGF0YSA9IGl0ZW1zID8/IFtdO1xuICAgIGlmIChoYXNNYXJrZXJzKSB7XG4gICAgICBjb25zdCBtYXJrZXJTZWxlY3Rpb24gPSBoaWdobGlnaHRTZWxlY3Rpb247XG4gICAgICByZXR1cm4gdGhpcy51cGRhdGVNYXJrZXJTZWxlY3Rpb24oeyBub2RlRGF0YSwgbWFya2VyU2VsZWN0aW9uIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy51cGRhdGVEYXR1bVNlbGVjdGlvbih7XG4gICAgICAgIG5vZGVEYXRhLFxuICAgICAgICBkYXR1bVNlbGVjdGlvbjogaGlnaGxpZ2h0U2VsZWN0aW9uXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlSGlnaGxpZ2h0U2VsZWN0aW9uTGFiZWwob3B0cykge1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZUxhYmVsU2VsZWN0aW9uKHtcbiAgICAgIGxhYmVsRGF0YTogb3B0cy5pdGVtcyA/PyBbXSxcbiAgICAgIGxhYmVsU2VsZWN0aW9uOiBvcHRzLmhpZ2hsaWdodExhYmVsU2VsZWN0aW9uXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlRGF0dW1TZWxlY3Rpb24ob3B0cykge1xuICAgIHJldHVybiBvcHRzLmRhdHVtU2VsZWN0aW9uO1xuICB9XG4gIGFzeW5jIHVwZGF0ZURhdHVtTm9kZXMoX29wdHMpIHtcbiAgfVxuICBhc3luYyB1cGRhdGVNYXJrZXJTZWxlY3Rpb24ob3B0cykge1xuICAgIHJldHVybiBvcHRzLm1hcmtlclNlbGVjdGlvbjtcbiAgfVxuICBhc3luYyB1cGRhdGVNYXJrZXJOb2Rlcyhfb3B0cykge1xuICB9XG4gIGFzeW5jIHVwZGF0ZVBhdGhzKG9wdHMpIHtcbiAgICBvcHRzLnBhdGhzLmZvckVhY2goKHApID0+IHAudmlzaWJsZSA9IGZhbHNlKTtcbiAgfVxuICBhc3luYyB1cGRhdGVQYXRoTm9kZXMob3B0cykge1xuICAgIGNvbnN0IHsgcGF0aHMsIG9wYWNpdHksIHZpc2libGUgfSA9IG9wdHM7XG4gICAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzKSB7XG4gICAgICBwYXRoLm9wYWNpdHkgPSBvcGFjaXR5O1xuICAgICAgcGF0aC52aXNpYmxlID0gdmlzaWJsZTtcbiAgICB9XG4gIH1cbiAgcmVzZXRQYXRoQW5pbWF0aW9uKGRhdGEpIHtcbiAgICBjb25zdCB7IHBhdGggfSA9IHRoaXMub3B0cz8uYW5pbWF0aW9uUmVzZXRGbnMgPz8ge307XG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIGRhdGEucGF0aHMuZm9yRWFjaCgocGF0aHMpID0+IHtcbiAgICAgICAgcmVzZXRNb3Rpb24oW3BhdGhzXSwgcGF0aCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmVzZXREYXR1bUFuaW1hdGlvbihkYXRhKSB7XG4gICAgY29uc3QgeyBkYXR1bSB9ID0gdGhpcy5vcHRzPy5hbmltYXRpb25SZXNldEZucyA/PyB7fTtcbiAgICBpZiAoZGF0dW0pIHtcbiAgICAgIHJlc2V0TW90aW9uKFtkYXRhLmRhdHVtU2VsZWN0aW9uXSwgZGF0dW0pO1xuICAgIH1cbiAgfVxuICByZXNldExhYmVsQW5pbWF0aW9uKGRhdGEpIHtcbiAgICBjb25zdCB7IGxhYmVsIH0gPSB0aGlzLm9wdHM/LmFuaW1hdGlvblJlc2V0Rm5zID8/IHt9O1xuICAgIGlmIChsYWJlbCkge1xuICAgICAgcmVzZXRNb3Rpb24oW2RhdGEubGFiZWxTZWxlY3Rpb25dLCBsYWJlbCk7XG4gICAgfVxuICB9XG4gIHJlc2V0TWFya2VyQW5pbWF0aW9uKGRhdGEpIHtcbiAgICBjb25zdCB7IG1hcmtlciB9ID0gdGhpcy5vcHRzPy5hbmltYXRpb25SZXNldEZucyA/PyB7fTtcbiAgICBpZiAobWFya2VyICYmIHRoaXMub3B0cy5oYXNNYXJrZXJzKSB7XG4gICAgICByZXNldE1vdGlvbihbZGF0YS5tYXJrZXJTZWxlY3Rpb25dLCBtYXJrZXIpO1xuICAgIH1cbiAgfVxuICByZXNldEFsbEFuaW1hdGlvbihkYXRhKSB7XG4gICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5zdG9wQnlBbmltYXRpb25Hcm91cElkKHRoaXMuaWQpO1xuICAgIHRoaXMucmVzZXRQYXRoQW5pbWF0aW9uKGRhdGEpO1xuICAgIHRoaXMucmVzZXREYXR1bUFuaW1hdGlvbihkYXRhKTtcbiAgICB0aGlzLnJlc2V0TGFiZWxBbmltYXRpb24oZGF0YSk7XG4gICAgdGhpcy5yZXNldE1hcmtlckFuaW1hdGlvbihkYXRhKTtcbiAgICBpZiAoZGF0YS5jb250ZXh0RGF0YT8uYW5pbWF0aW9uVmFsaWQgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLnNraXBDdXJyZW50QmF0Y2goKTtcbiAgICB9XG4gIH1cbiAgYW5pbWF0ZUVtcHR5VXBkYXRlUmVhZHkoZGF0YSkge1xuICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuc2tpcEN1cnJlbnRCYXRjaCgpO1xuICAgIHRoaXMucmVzZXRBbGxBbmltYXRpb24oZGF0YSk7XG4gIH1cbiAgYW5pbWF0ZVdhaXRpbmdVcGRhdGVSZWFkeShkYXRhKSB7XG4gICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5za2lwQ3VycmVudEJhdGNoKCk7XG4gICAgdGhpcy5yZXNldEFsbEFuaW1hdGlvbihkYXRhKTtcbiAgfVxuICBhbmltYXRlUmVhZHlIaWdobGlnaHQoZGF0YSkge1xuICAgIGNvbnN0IHsgZGF0dW0gfSA9IHRoaXMub3B0cz8uYW5pbWF0aW9uUmVzZXRGbnMgPz8ge307XG4gICAgaWYgKGRhdHVtKSB7XG4gICAgICByZXNldE1vdGlvbihbZGF0YV0sIGRhdHVtKTtcbiAgICB9XG4gIH1cbiAgYW5pbWF0ZVJlYWR5SGlnaGxpZ2h0TWFya2VycyhkYXRhKSB7XG4gICAgY29uc3QgeyBtYXJrZXIgfSA9IHRoaXMub3B0cz8uYW5pbWF0aW9uUmVzZXRGbnMgPz8ge307XG4gICAgaWYgKG1hcmtlcikge1xuICAgICAgcmVzZXRNb3Rpb24oW2RhdGFdLCBtYXJrZXIpO1xuICAgIH1cbiAgfVxuICBhbmltYXRlUmVhZHlSZXNpemUoZGF0YSkge1xuICAgIHRoaXMucmVzZXRBbGxBbmltYXRpb24oZGF0YSk7XG4gIH1cbiAgYW5pbWF0ZUNsZWFyaW5nVXBkYXRlRW1wdHkoZGF0YSkge1xuICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuc2tpcEN1cnJlbnRCYXRjaCgpO1xuICAgIHRoaXMucmVzZXRBbGxBbmltYXRpb24oZGF0YSk7XG4gIH1cbiAgYW5pbWF0aW9uVHJhbnNpdGlvbkNsZWFyKCkge1xuICAgIGNvbnN0IGFuaW1hdGlvbkRhdGEgPSB0aGlzLmdldEFuaW1hdGlvbkRhdGEoKTtcbiAgICBpZiAoIWFuaW1hdGlvbkRhdGEpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwiY2xlYXJcIiwgYW5pbWF0aW9uRGF0YSk7XG4gIH1cbiAgZ2V0QW5pbWF0aW9uRGF0YShzZXJpZXNSZWN0LCBwcmV2aW91c0NvbnRleHREYXRhKSB7XG4gICAgY29uc3QgeyBfY29udGV4dE5vZGVEYXRhOiBjb250ZXh0RGF0YSB9ID0gdGhpcztcbiAgICBpZiAoIWNvbnRleHREYXRhKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGFuaW1hdGlvbkRhdGEgPSB7XG4gICAgICBkYXR1bVNlbGVjdGlvbjogdGhpcy5kYXR1bVNlbGVjdGlvbixcbiAgICAgIG1hcmtlclNlbGVjdGlvbjogdGhpcy5tYXJrZXJTZWxlY3Rpb24sXG4gICAgICBsYWJlbFNlbGVjdGlvbjogdGhpcy5sYWJlbFNlbGVjdGlvbixcbiAgICAgIGFubm90YXRpb25TZWxlY3Rpb25zOiBbLi4udGhpcy5hbm5vdGF0aW9uU2VsZWN0aW9uc10sXG4gICAgICBjb250ZXh0RGF0YSxcbiAgICAgIHByZXZpb3VzQ29udGV4dERhdGEsXG4gICAgICBwYXRoczogdGhpcy5wYXRocyxcbiAgICAgIHNlcmllc1JlY3RcbiAgICB9O1xuICAgIHJldHVybiBhbmltYXRpb25EYXRhO1xuICB9XG4gIGNhbGN1bGF0ZVNjYWxpbmcoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBkaXJlY3Rpb24gb2YgT2JqZWN0LnZhbHVlcyhDaGFydEF4aXNEaXJlY3Rpb24pKSB7XG4gICAgICBjb25zdCBheGlzID0gdGhpcy5heGVzW2RpcmVjdGlvbl07XG4gICAgICBpZiAoIWF4aXMpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgaWYgKGF4aXMuc2NhbGUgaW5zdGFuY2VvZiBMb2dTY2FsZSkge1xuICAgICAgICBjb25zdCB7IHJhbmdlOiByYW5nZTMsIGRvbWFpbiB9ID0gYXhpcy5zY2FsZTtcbiAgICAgICAgcmVzdWx0W2RpcmVjdGlvbl0gPSB7XG4gICAgICAgICAgdHlwZTogXCJsb2dcIixcbiAgICAgICAgICBjb252ZXJ0OiAoZCkgPT4gYXhpcy5zY2FsZS5jb252ZXJ0KGQpLFxuICAgICAgICAgIGRvbWFpbjogW2RvbWFpblswXSwgZG9tYWluWzFdXSxcbiAgICAgICAgICByYW5nZTogW3JhbmdlM1swXSwgcmFuZ2UzWzFdXVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChheGlzLnNjYWxlIGluc3RhbmNlb2YgQ29udGludW91c1NjYWxlKSB7XG4gICAgICAgIGNvbnN0IHsgcmFuZ2U6IHJhbmdlMyB9ID0gYXhpcy5zY2FsZTtcbiAgICAgICAgY29uc3QgZG9tYWluID0gYXhpcy5zY2FsZS5nZXREb21haW4oKTtcbiAgICAgICAgcmVzdWx0W2RpcmVjdGlvbl0gPSB7XG4gICAgICAgICAgdHlwZTogXCJjb250aW51b3VzXCIsXG4gICAgICAgICAgZG9tYWluOiBbZG9tYWluWzBdLCBkb21haW5bMV1dLFxuICAgICAgICAgIHJhbmdlOiBbcmFuZ2UzWzBdLCByYW5nZTNbMV1dXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKGF4aXMuc2NhbGUpIHtcbiAgICAgICAgY29uc3QgeyBkb21haW4gfSA9IGF4aXMuc2NhbGU7XG4gICAgICAgIHJlc3VsdFtkaXJlY3Rpb25dID0ge1xuICAgICAgICAgIHR5cGU6IFwiY2F0ZWdvcnlcIixcbiAgICAgICAgICBkb21haW4sXG4gICAgICAgICAgcmFuZ2U6IGRvbWFpbi5tYXAoKGQpID0+IGF4aXMuc2NhbGUuY29udmVydChkKSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvY2FydGVzaWFuQ2hhcnQudHNcbnZhciBkaXJlY3Rpb25zID0gW1widG9wXCIsIFwicmlnaHRcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCJdO1xudmFyIENhcnRlc2lhbkNoYXJ0ID0gY2xhc3MgZXh0ZW5kcyBDaGFydCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIHJlc291cmNlcykge1xuICAgIHN1cGVyKG9wdGlvbnMsIHJlc291cmNlcyk7XG4gICAgLyoqIEludGVncmF0ZWQgQ2hhcnRzIGZlYXR1cmUgc3RhdGUgLSBub3QgdXNlZCBpbiBTdGFuZGFsb25lIENoYXJ0cy4gKi9cbiAgICB0aGlzLnBhaXJlZCA9IHRydWU7XG4gICAgdGhpcy5maXJzdFNlcmllc1RyYW5zbGF0aW9uID0gdHJ1ZTtcbiAgICB0aGlzLmxhc3RVcGRhdGVDbGlwUmVjdCA9IHZvaWQgMDtcbiAgICB0aGlzLl9sYXN0Q3Jvc3NMaW5lSWRzID0gdm9pZCAwO1xuICAgIHRoaXMuX2xhc3RBeGlzQXJlYVdpZHRocyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5fbGFzdENsaXBTZXJpZXMgPSBmYWxzZTtcbiAgICB0aGlzLl9sYXN0VmlzaWJpbGl0eSA9IHtcbiAgICAgIGNyb3NzTGluZXM6IHRydWUsXG4gICAgICBzZXJpZXM6IHRydWVcbiAgICB9O1xuICB9XG4gIG9uQXhpc0NoYW5nZShuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcbiAgICBzdXBlci5vbkF4aXNDaGFuZ2UobmV3VmFsdWUsIG9sZFZhbHVlKTtcbiAgICB0aGlzLmN0eD8uem9vbU1hbmFnZXIudXBkYXRlQXhlcyhuZXdWYWx1ZSk7XG4gIH1cbiAgZGVzdHJveVNlcmllcyhzZXJpZXMpIHtcbiAgICBzdXBlci5kZXN0cm95U2VyaWVzKHNlcmllcyk7XG4gICAgdGhpcy5maXJzdFNlcmllc1RyYW5zbGF0aW9uID0gdHJ1ZTtcbiAgfVxuICBnZXRDaGFydFR5cGUoKSB7XG4gICAgcmV0dXJuIFwiY2FydGVzaWFuXCI7XG4gIH1cbiAgc2V0Um9vdENsaXBSZWN0cyhjbGlwUmVjdCkge1xuICAgIGNvbnN0IHsgc2VyaWVzUm9vdCwgYW5ub3RhdGlvblJvb3QsIGhpZ2hsaWdodFJvb3QgfSA9IHRoaXM7XG4gICAgc2VyaWVzUm9vdC5zZXRDbGlwUmVjdChjbGlwUmVjdCk7XG4gICAgaGlnaGxpZ2h0Um9vdC5zZXRDbGlwUmVjdChjbGlwUmVjdCk7XG4gICAgYW5ub3RhdGlvblJvb3Quc2V0Q2xpcFJlY3QoY2xpcFJlY3QpO1xuICB9XG4gIHBlcmZvcm1MYXlvdXQoY3R4KSB7XG4gICAgY29uc3QgeyBmaXJzdFNlcmllc1RyYW5zbGF0aW9uLCBzZXJpZXNSb290LCBhbm5vdGF0aW9uUm9vdCwgaGlnaGxpZ2h0Um9vdCB9ID0gdGhpcztcbiAgICBjb25zdCB7IHNlcmllc1JlY3QsIHZpc2liaWxpdHksIGNsaXBTZXJpZXMgfSA9IHRoaXMudXBkYXRlQXhlcyhjdHgubGF5b3V0Qm94KTtcbiAgICB0aGlzLnNlcmllc1Jvb3QudmlzaWJsZSA9IHZpc2liaWxpdHkuc2VyaWVzO1xuICAgIHRoaXMuc2VyaWVzUmVjdCA9IHNlcmllc1JlY3Q7XG4gICAgdGhpcy5hbmltYXRpb25SZWN0ID0gY3R4LmxheW91dEJveDtcbiAgICBjb25zdCB7IHgsIHkgfSA9IHNlcmllc1JlY3Q7XG4gICAgaWYgKGZpcnN0U2VyaWVzVHJhbnNsYXRpb24pIHtcbiAgICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgW3Nlcmllc1Jvb3QsIGFubm90YXRpb25Sb290LCBoaWdobGlnaHRSb290XSkge1xuICAgICAgICBncm91cC50cmFuc2xhdGlvblggPSBNYXRoLmZsb29yKHgpO1xuICAgICAgICBncm91cC50cmFuc2xhdGlvblkgPSBNYXRoLmZsb29yKHkpO1xuICAgICAgfVxuICAgICAgdGhpcy5maXJzdFNlcmllc1RyYW5zbGF0aW9uID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHsgdHJhbnNsYXRpb25YLCB0cmFuc2xhdGlvblkgfSA9IHNlcmllc1Jvb3Q7XG4gICAgICBzdGF0aWNGcm9tVG9Nb3Rpb24oXG4gICAgICAgIHRoaXMuaWQsXG4gICAgICAgIFwic2VyaWVzUmVjdFwiLFxuICAgICAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLFxuICAgICAgICBbc2VyaWVzUm9vdCwgaGlnaGxpZ2h0Um9vdCwgYW5ub3RhdGlvblJvb3RdLFxuICAgICAgICB7IHRyYW5zbGF0aW9uWCwgdHJhbnNsYXRpb25ZIH0sXG4gICAgICAgIHsgdHJhbnNsYXRpb25YOiBNYXRoLmZsb29yKHgpLCB0cmFuc2xhdGlvblk6IE1hdGguZmxvb3IoeSkgfSxcbiAgICAgICAgeyBwaGFzZTogXCJ1cGRhdGVcIiB9XG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBzZXJpZXNQYWRkZWRSZWN0ID0gc2VyaWVzUmVjdC5jbG9uZSgpLmdyb3codGhpcy5zZXJpZXNBcmVhLnBhZGRpbmcpO1xuICAgIGNvbnN0IGNsaXBSZWN0ID0gdGhpcy5zZXJpZXNBcmVhLmNsaXAgfHwgY2xpcFNlcmllcyA/IHNlcmllc1BhZGRlZFJlY3QgOiB2b2lkIDA7XG4gICAgY29uc3QgeyBsYXN0VXBkYXRlQ2xpcFJlY3QgfSA9IHRoaXM7XG4gICAgdGhpcy5sYXN0VXBkYXRlQ2xpcFJlY3QgPSBjbGlwUmVjdDtcbiAgICBpZiAodGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5pc0FjdGl2ZSgpICYmIGxhc3RVcGRhdGVDbGlwUmVjdCAhPSBudWxsKSB7XG4gICAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLmFuaW1hdGUoe1xuICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgZ3JvdXBJZDogXCJjbGlwLXJlY3RcIixcbiAgICAgICAgcGhhc2U6IFwidXBkYXRlXCIsXG4gICAgICAgIGZyb206IGxhc3RVcGRhdGVDbGlwUmVjdCxcbiAgICAgICAgdG86IHNlcmllc1BhZGRlZFJlY3QsXG4gICAgICAgIG9uVXBkYXRlOiAoaW50ZXJwb2xhdGVkQ2xpcFJlY3QpID0+IHRoaXMuc2V0Um9vdENsaXBSZWN0cyhpbnRlcnBvbGF0ZWRDbGlwUmVjdCksXG4gICAgICAgIG9uQ29tcGxldGU6ICgpID0+IHRoaXMuc2V0Um9vdENsaXBSZWN0cyhjbGlwUmVjdClcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldFJvb3RDbGlwUmVjdHMoY2xpcFJlY3QpO1xuICAgIH1cbiAgICB0aGlzLmN0eC5sYXlvdXRNYW5hZ2VyLmVtaXRMYXlvdXRDb21wbGV0ZShjdHgsIHtcbiAgICAgIGF4ZXM6IHRoaXMuYXhlcy5tYXAoKGF4aXMpID0+IGF4aXMuZ2V0TGF5b3V0U3RhdGUoKSksXG4gICAgICBzZXJpZXM6IHtcbiAgICAgICAgcmVjdDogc2VyaWVzUmVjdCxcbiAgICAgICAgcGFkZGVkUmVjdDogc2VyaWVzUGFkZGVkUmVjdCxcbiAgICAgICAgdmlzaWJsZTogdmlzaWJpbGl0eS5zZXJpZXMsXG4gICAgICAgIHNob3VsZEZsaXBYWTogdGhpcy5zaG91bGRGbGlwWFkoKVxuICAgICAgfSxcbiAgICAgIGNsaXBTZXJpZXNcbiAgICB9KTtcbiAgfVxuICB1cGRhdGVBeGVzKGxheW91dEJveCkge1xuICAgIGNvbnN0IGNyb3NzTGluZUlkcyA9IHRoaXMuYXhlcy5mbGF0TWFwKChheGlzKSA9PiBheGlzLmNyb3NzTGluZXMgPz8gW10pLm1hcCgoY3Jvc3NMaW5lKSA9PiBjcm9zc0xpbmUuaWQpO1xuICAgIGNvbnN0IGF4ZXNWYWxpZCA9IHRoaXMuX2xhc3RDcm9zc0xpbmVJZHMgIT0gbnVsbCAmJiB0aGlzLl9sYXN0Q3Jvc3NMaW5lSWRzLmxlbmd0aCA9PT0gY3Jvc3NMaW5lSWRzLmxlbmd0aCAmJiB0aGlzLl9sYXN0Q3Jvc3NMaW5lSWRzLmV2ZXJ5KChpZCwgaW5kZXgpID0+IGNyb3NzTGluZUlkc1tpbmRleF0gPT09IGlkKTtcbiAgICBsZXQgYXhpc0FyZWFXaWR0aHM7XG4gICAgbGV0IGNsaXBTZXJpZXM7XG4gICAgbGV0IHZpc2liaWxpdHk7XG4gICAgaWYgKGF4ZXNWYWxpZCkge1xuICAgICAgYXhpc0FyZWFXaWR0aHMgPSBuZXcgTWFwKHRoaXMuX2xhc3RBeGlzQXJlYVdpZHRocy5lbnRyaWVzKCkpO1xuICAgICAgY2xpcFNlcmllcyA9IHRoaXMuX2xhc3RDbGlwU2VyaWVzO1xuICAgICAgdmlzaWJpbGl0eSA9IHsgLi4udGhpcy5fbGFzdFZpc2liaWxpdHkgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXhpc0FyZWFXaWR0aHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgY2xpcFNlcmllcyA9IGZhbHNlO1xuICAgICAgdmlzaWJpbGl0eSA9IHsgY3Jvc3NMaW5lczogdHJ1ZSwgc2VyaWVzOiB0cnVlIH07XG4gICAgICB0aGlzLl9sYXN0Q3Jvc3NMaW5lSWRzID0gY3Jvc3NMaW5lSWRzO1xuICAgIH1cbiAgICBjb25zdCBsaXZlQXhpc1dpZHRocyA9IG5ldyBTZXQodGhpcy5heGVzLm1hcCgoYSkgPT4gYS5wb3NpdGlvbikpO1xuICAgIGZvciAoY29uc3QgcG9zaXRpb24gb2YgYXhpc0FyZWFXaWR0aHMua2V5cygpKSB7XG4gICAgICBpZiAoIWxpdmVBeGlzV2lkdGhzLmhhcyhwb3NpdGlvbikpIHtcbiAgICAgICAgYXhpc0FyZWFXaWR0aHMuZGVsZXRlKHBvc2l0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgc3RhYmxlT3V0cHV0cyA9IChvdGhlckF4aXNXaWR0aHMsIG90aGVyQ2xpcFNlcmllcywgb3RoZXJWaXNpYmlsaXR5KSA9PiB7XG4gICAgICBpZiAoWy4uLm90aGVyQXhpc1dpZHRocy5rZXlzKCldLnNvbWUoKGspID0+ICFheGlzQXJlYVdpZHRocy5oYXMoaykpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICh2aXNpYmlsaXR5LmNyb3NzTGluZXMgIT09IG90aGVyVmlzaWJpbGl0eS5jcm9zc0xpbmVzIHx8IHZpc2liaWxpdHkuc2VyaWVzICE9PSBvdGhlclZpc2liaWxpdHkuc2VyaWVzIHx8IGNsaXBTZXJpZXMgIT09IG90aGVyQ2xpcFNlcmllcykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IFtwLCB3XSBvZiBheGlzQXJlYVdpZHRocy5lbnRyaWVzKCkpIHtcbiAgICAgICAgY29uc3Qgb3RoZXJXID0gb3RoZXJBeGlzV2lkdGhzLmdldChwKTtcbiAgICAgICAgaWYgKCh3ICE9IG51bGwgfHwgb3RoZXJXICE9IG51bGwpICYmIHcgIT09IG90aGVyVykge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBjb25zdCBjZWlsVmFsdWVzID0gKG1hcCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgbWFwLmVudHJpZXMoKSkge1xuICAgICAgICBpZiAodmFsdWUgJiYgTWF0aC5hYnModmFsdWUpID09PSBJbmZpbml0eSkge1xuICAgICAgICAgIG1hcC5zZXQoa2V5LCAwKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBtYXAuc2V0KGtleSwgdmFsdWUgIT0gbnVsbCA/IE1hdGguY2VpbCh2YWx1ZSkgOiB2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFwO1xuICAgIH07XG4gICAgbGV0IGxhc3RQYXNzQXhpc0FyZWFXaWR0aHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGxldCBsYXN0UGFzc1Zpc2liaWxpdHkgPSB7fTtcbiAgICBsZXQgbGFzdFBhc3NDbGlwU2VyaWVzID0gZmFsc2U7XG4gICAgbGV0IHNlcmllc1JlY3QgPSB0aGlzLnNlcmllc1JlY3Q/LmNsb25lKCk7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBkbyB7XG4gICAgICBheGlzQXJlYVdpZHRocyA9IG5ldyBNYXAobGFzdFBhc3NBeGlzQXJlYVdpZHRocy5lbnRyaWVzKCkpO1xuICAgICAgY2xpcFNlcmllcyA9IGxhc3RQYXNzQ2xpcFNlcmllcztcbiAgICAgIE9iamVjdC5hc3NpZ24odmlzaWJpbGl0eSwgbGFzdFBhc3NWaXNpYmlsaXR5KTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMudXBkYXRlQXhlc1Bhc3MoYXhpc0FyZWFXaWR0aHMsIGxheW91dEJveC5jbG9uZSgpLCBzZXJpZXNSZWN0KTtcbiAgICAgIGxhc3RQYXNzQXhpc0FyZWFXaWR0aHMgPSBjZWlsVmFsdWVzKHJlc3VsdC5heGlzQXJlYVdpZHRocyk7XG4gICAgICBsYXN0UGFzc1Zpc2liaWxpdHkgPSByZXN1bHQudmlzaWJpbGl0eTtcbiAgICAgIGxhc3RQYXNzQ2xpcFNlcmllcyA9IHJlc3VsdC5jbGlwU2VyaWVzO1xuICAgICAgKHsgc2VyaWVzUmVjdCB9ID0gcmVzdWx0KTtcbiAgICAgIGlmIChjb3VudCsrID4gMTApIHtcbiAgICAgICAgTG9nZ2VyLndhcm4oXCJ1bmFibGUgdG8gZmluZCBzdGFibGUgYXhpcyBsYXlvdXQuXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IHdoaWxlICghc3RhYmxlT3V0cHV0cyhsYXN0UGFzc0F4aXNBcmVhV2lkdGhzLCBsYXN0UGFzc0NsaXBTZXJpZXMsIGxhc3RQYXNzVmlzaWJpbGl0eSkpO1xuICAgIHRoaXMuYXhlcy5mb3JFYWNoKChheGlzKSA9PiB7XG4gICAgICBheGlzLnVwZGF0ZSgpO1xuICAgIH0pO1xuICAgIGNvbnN0IGNsaXBSZWN0UGFkZGluZyA9IDU7XG4gICAgdGhpcy5heGVzLmZvckVhY2goKGF4aXMpID0+IHtcbiAgICAgIGF4aXMuc2V0Q3Jvc3NMaW5lc1Zpc2libGUodmlzaWJpbGl0eS5jcm9zc0xpbmVzKTtcbiAgICAgIGlmICghc2VyaWVzUmVjdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBheGlzLmNsaXBHcmlkKFxuICAgICAgICBzZXJpZXNSZWN0LngsXG4gICAgICAgIHNlcmllc1JlY3QueSxcbiAgICAgICAgc2VyaWVzUmVjdC53aWR0aCArIGNsaXBSZWN0UGFkZGluZyxcbiAgICAgICAgc2VyaWVzUmVjdC5oZWlnaHQgKyBjbGlwUmVjdFBhZGRpbmdcbiAgICAgICk7XG4gICAgICBzd2l0Y2ggKGF4aXMucG9zaXRpb24pIHtcbiAgICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICAgICAgYXhpcy5jbGlwVGlja0xpbmVzKFxuICAgICAgICAgICAgbGF5b3V0Qm94LngsXG4gICAgICAgICAgICBzZXJpZXNSZWN0LnksXG4gICAgICAgICAgICBsYXlvdXRCb3gud2lkdGggKyBjbGlwUmVjdFBhZGRpbmcsXG4gICAgICAgICAgICBzZXJpZXNSZWN0LmhlaWdodCArIGNsaXBSZWN0UGFkZGluZ1xuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ0b3BcIjpcbiAgICAgICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgICAgIGF4aXMuY2xpcFRpY2tMaW5lcyhcbiAgICAgICAgICAgIHNlcmllc1JlY3QueCxcbiAgICAgICAgICAgIGxheW91dEJveC55LFxuICAgICAgICAgICAgc2VyaWVzUmVjdC53aWR0aCArIGNsaXBSZWN0UGFkZGluZyxcbiAgICAgICAgICAgIGxheW91dEJveC5oZWlnaHQgKyBjbGlwUmVjdFBhZGRpbmdcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuX2xhc3RBeGlzQXJlYVdpZHRocyA9IGF4aXNBcmVhV2lkdGhzO1xuICAgIHRoaXMuX2xhc3RWaXNpYmlsaXR5ID0gdmlzaWJpbGl0eTtcbiAgICB0aGlzLl9sYXN0Q2xpcFNlcmllcyA9IGNsaXBTZXJpZXM7XG4gICAgcmV0dXJuIHsgc2VyaWVzUmVjdCwgdmlzaWJpbGl0eSwgY2xpcFNlcmllcyB9O1xuICB9XG4gIHVwZGF0ZUF4ZXNQYXNzKGF4aXNBcmVhV2lkdGhzLCBib3VuZHMsIGxhc3RQYXNzU2VyaWVzUmVjdCkge1xuICAgIGNvbnN0IGF4aXNXaWR0aHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGF4aXNHcm91cHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHZpc2liaWxpdHkgPSB7XG4gICAgICBzZXJpZXM6IHRydWUsXG4gICAgICBjcm9zc0xpbmVzOiB0cnVlXG4gICAgfTtcbiAgICBsZXQgY2xpcFNlcmllcyA9IGZhbHNlO1xuICAgIGNvbnN0IHByaW1hcnlUaWNrQ291bnRzID0ge307XG4gICAgY29uc3QgcGFkZGVkQm91bmRzID0gdGhpcy5hcHBseVNlcmllc1BhZGRpbmcoYm91bmRzKTtcbiAgICBjb25zdCBjcm9zc0xpbmVQYWRkaW5nID0gbGFzdFBhc3NTZXJpZXNSZWN0ID8gdGhpcy5idWlsZENyb3NzTGluZVBhZGRpbmcoYXhpc0FyZWFXaWR0aHMpIDoge307XG4gICAgY29uc3QgYXhpc0FyZWFCb3VuZCA9IHRoaXMuYnVpbGRBeGlzQm91bmQocGFkZGVkQm91bmRzLCBheGlzQXJlYVdpZHRocywgY3Jvc3NMaW5lUGFkZGluZywgdmlzaWJpbGl0eSk7XG4gICAgY29uc3Qgc2VyaWVzUmVjdCA9IHRoaXMuYnVpbGRTZXJpZXNSZWN0KGF4aXNBcmVhQm91bmQsIGF4aXNBcmVhV2lkdGhzKTtcbiAgICBmb3IgKGNvbnN0IGF4aXMgb2YgdGhpcy5heGVzKSB7XG4gICAgICBjb25zdCB7IHBvc2l0aW9uID0gXCJsZWZ0XCIgfSA9IGF4aXM7XG4gICAgICBjb25zdCB7IGNsaXBTZXJpZXM6IG5ld0NsaXBTZXJpZXMsIGF4aXNUaGlja25lc3MgfSA9IHRoaXMuY2FsY3VsYXRlQXhpc0RpbWVuc2lvbnMoe1xuICAgICAgICBheGlzLFxuICAgICAgICBzZXJpZXNSZWN0LFxuICAgICAgICBwcmltYXJ5VGlja0NvdW50cyxcbiAgICAgICAgY2xpcFNlcmllc1xuICAgICAgfSk7XG4gICAgICBheGlzV2lkdGhzLnNldChheGlzLmlkLCBheGlzVGhpY2tuZXNzKTtcbiAgICAgIGlmICghYXhpc0dyb3Vwcy5oYXMocG9zaXRpb24pKVxuICAgICAgICBheGlzR3JvdXBzLnNldChwb3NpdGlvbiwgW10pO1xuICAgICAgYXhpc0dyb3Vwcy5nZXQocG9zaXRpb24pPy5wdXNoKGF4aXMpO1xuICAgICAgY2xpcFNlcmllcyA9IGNsaXBTZXJpZXMgfHwgbmV3Q2xpcFNlcmllcztcbiAgICB9XG4gICAgY29uc3QgbmV3QXhpc0FyZWFXaWR0aHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGF4aXNPZmZzZXRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IFtwb3NpdGlvbiwgYXhlc10gb2YgYXhpc0dyb3Vwcy5lbnRyaWVzKCkpIHtcbiAgICAgIGNvbnN0IGlzVmVydGljYWwgPSBwb3NpdGlvbiA9PT0gXCJsZWZ0XCIgfHwgcG9zaXRpb24gPT09IFwicmlnaHRcIjtcbiAgICAgIG5ld0F4aXNBcmVhV2lkdGhzLnNldChwb3NpdGlvbiwgdGhpcy5jYWxjdWxhdGVBeGlzQXJlYShheGVzLCBheGlzV2lkdGhzLCBheGlzT2Zmc2V0cywgaXNWZXJ0aWNhbCkpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtwb3NpdGlvbiwgYXhlc10gb2YgYXhpc0dyb3Vwcy5lbnRyaWVzKCkpIHtcbiAgICAgIHRoaXMucG9zaXRpb25BeGVzKHtcbiAgICAgICAgYXhlcyxcbiAgICAgICAgcG9zaXRpb24sXG4gICAgICAgIGF4aXNXaWR0aHMsXG4gICAgICAgIGF4aXNPZmZzZXRzLFxuICAgICAgICBheGlzQXJlYVdpZHRoczogbmV3QXhpc0FyZWFXaWR0aHMsXG4gICAgICAgIGF4aXNCb3VuZDogYXhpc0FyZWFCb3VuZCxcbiAgICAgICAgc2VyaWVzUmVjdFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7IGNsaXBTZXJpZXMsIHNlcmllc1JlY3QsIGF4aXNBcmVhV2lkdGhzOiBuZXdBeGlzQXJlYVdpZHRocywgdmlzaWJpbGl0eSB9O1xuICB9XG4gIGJ1aWxkQ3Jvc3NMaW5lUGFkZGluZyhheGlzQXJlYVNpemUpIHtcbiAgICBjb25zdCBjcm9zc0xpbmVQYWRkaW5nID0ge307XG4gICAgdGhpcy5heGVzLmZvckVhY2goKGF4aXMpID0+IHtcbiAgICAgIGF4aXMuY3Jvc3NMaW5lcz8uZm9yRWFjaCgoY3Jvc3NMaW5lKSA9PiB7XG4gICAgICAgIGNyb3NzTGluZS5jYWxjdWxhdGVQYWRkaW5nPy4oY3Jvc3NMaW5lUGFkZGluZyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IFtzaWRlLCBwYWRkaW5nID0gMF0gb2YgT2JqZWN0LmVudHJpZXMoY3Jvc3NMaW5lUGFkZGluZykpIHtcbiAgICAgIGNyb3NzTGluZVBhZGRpbmdbc2lkZV0gPSBNYXRoLm1heChwYWRkaW5nIC0gKGF4aXNBcmVhU2l6ZS5nZXQoc2lkZSkgPz8gMCksIDApO1xuICAgIH1cbiAgICByZXR1cm4gY3Jvc3NMaW5lUGFkZGluZztcbiAgfVxuICBhcHBseVNlcmllc1BhZGRpbmcoYm91bmRzKSB7XG4gICAgY29uc3QgcGFkZGVkUmVjdCA9IGJvdW5kcy5jbG9uZSgpO1xuICAgIGRpcmVjdGlvbnMuZm9yRWFjaCgoZGlyKSA9PiB7XG4gICAgICBjb25zdCBwYWRkaW5nID0gdGhpcy5zZXJpZXNBcmVhLnBhZGRpbmdbZGlyXTtcbiAgICAgIGNvbnN0IGF4aXMgPSB0aGlzLmF4ZXMuZmluZExhc3QoKGEpID0+IGEucG9zaXRpb24gPT09IGRpcik7XG4gICAgICBpZiAoYXhpcykge1xuICAgICAgICBheGlzLnNlcmllc0FyZWFQYWRkaW5nID0gcGFkZGluZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhZGRlZFJlY3Quc2hyaW5rKHBhZGRpbmcsIGRpcik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHBhZGRlZFJlY3Q7XG4gIH1cbiAgYnVpbGRBeGlzQm91bmQoYm91bmRzLCBheGlzQXJlYVdpZHRocywgY3Jvc3NMaW5lUGFkZGluZywgdmlzaWJpbGl0eSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGJvdW5kcy5jbG9uZSgpO1xuICAgIGNvbnN0IHsgdG9wID0gMCwgcmlnaHQgPSAwLCBib3R0b20gPSAwLCBsZWZ0ID0gMCB9ID0gY3Jvc3NMaW5lUGFkZGluZztcbiAgICBjb25zdCBob3Jpem9udGFsUGFkZGluZyA9IGxlZnQgKyByaWdodDtcbiAgICBjb25zdCB2ZXJ0aWNhbFBhZGRpbmcgPSB0b3AgKyBib3R0b207XG4gICAgY29uc3QgdG90YWxXaWR0aCA9IChheGlzQXJlYVdpZHRocy5nZXQoXCJsZWZ0XCIpID8/IDApICsgKGF4aXNBcmVhV2lkdGhzLmdldChcInJpZ2h0XCIpID8/IDApICsgaG9yaXpvbnRhbFBhZGRpbmc7XG4gICAgY29uc3QgdG90YWxIZWlnaHQgPSAoYXhpc0FyZWFXaWR0aHMuZ2V0KFwidG9wXCIpID8/IDApICsgKGF4aXNBcmVhV2lkdGhzLmdldChcImJvdHRvbVwiKSA/PyAwKSArIHZlcnRpY2FsUGFkZGluZztcbiAgICBpZiAocmVzdWx0LndpZHRoIDw9IHRvdGFsV2lkdGggfHwgcmVzdWx0LmhlaWdodCA8PSB0b3RhbEhlaWdodCkge1xuICAgICAgdmlzaWJpbGl0eS5jcm9zc0xpbmVzID0gZmFsc2U7XG4gICAgICB2aXNpYmlsaXR5LnNlcmllcyA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmVzdWx0LnggKz0gbGVmdDtcbiAgICByZXN1bHQueSArPSB0b3A7XG4gICAgcmVzdWx0LndpZHRoIC09IGhvcml6b250YWxQYWRkaW5nO1xuICAgIHJlc3VsdC5oZWlnaHQgLT0gdmVydGljYWxQYWRkaW5nO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgYnVpbGRTZXJpZXNSZWN0KGF4aXNCb3VuZCwgYXhpc0FyZWFXaWR0aHMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBheGlzQm91bmQuY2xvbmUoKTtcbiAgICByZXN1bHQueCArPSBheGlzQXJlYVdpZHRocy5nZXQoXCJsZWZ0XCIpID8/IDA7XG4gICAgcmVzdWx0LnkgKz0gYXhpc0FyZWFXaWR0aHMuZ2V0KFwidG9wXCIpID8/IDA7XG4gICAgcmVzdWx0LndpZHRoIC09IChheGlzQXJlYVdpZHRocy5nZXQoXCJsZWZ0XCIpID8/IDApICsgKGF4aXNBcmVhV2lkdGhzLmdldChcInJpZ2h0XCIpID8/IDApO1xuICAgIHJlc3VsdC5oZWlnaHQgLT0gKGF4aXNBcmVhV2lkdGhzLmdldChcInRvcFwiKSA/PyAwKSArIChheGlzQXJlYVdpZHRocy5nZXQoXCJib3R0b21cIikgPz8gMCk7XG4gICAgcmVzdWx0LndpZHRoID0gTWF0aC5tYXgoMCwgcmVzdWx0LndpZHRoKTtcbiAgICByZXN1bHQuaGVpZ2h0ID0gTWF0aC5tYXgoMCwgcmVzdWx0LmhlaWdodCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBjbGFtcFRvT3V0c2lkZVNlcmllc1JlY3Qoc2VyaWVzUmVjdCwgdmFsdWUsIGRpbWVuc2lvbiwgZGlyZWN0aW9uKSB7XG4gICAgY29uc3QgeyB4LCB5LCB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIgfSA9IHNlcmllc1JlY3Q7XG4gICAgY29uc3QgY2xhbXBCb3VuZHMgPSBbeCwgeSwgeCArIHdpZHRoMiwgeSArIGhlaWdodDJdO1xuICAgIGNvbnN0IGNvbXBhcmVUbyA9IGNsYW1wQm91bmRzWyhkaW1lbnNpb24gPT09IFwieFwiID8gMCA6IDEpICsgKGRpcmVjdGlvbiA9PT0gMSA/IDAgOiAyKV07XG4gICAgY29uc3QgY2xhbXBGbiA9IGRpcmVjdGlvbiA9PT0gMSA/IE1hdGgubWluIDogTWF0aC5tYXg7XG4gICAgcmV0dXJuIGNsYW1wRm4odmFsdWUsIGNvbXBhcmVUbyk7XG4gIH1cbiAgY2FsY3VsYXRlQXhpc0RpbWVuc2lvbnMob3B0cykge1xuICAgIGNvbnN0IHsgYXhpcywgc2VyaWVzUmVjdCwgcHJpbWFyeVRpY2tDb3VudHMgfSA9IG9wdHM7XG4gICAgbGV0IHsgY2xpcFNlcmllcyB9ID0gb3B0cztcbiAgICBjb25zdCB7IHBvc2l0aW9uID0gXCJsZWZ0XCIsIGRpcmVjdGlvbiB9ID0gYXhpcztcbiAgICB0aGlzLnNpemVBeGlzKGF4aXMsIHNlcmllc1JlY3QsIHBvc2l0aW9uKTtcbiAgICBjb25zdCBzeW5jZWREb21haW4gPSB0aGlzLmdldFN5bmNlZERvbWFpbihheGlzKTtcbiAgICBjb25zdCBsYXlvdXQgPSBheGlzLmNhbGN1bGF0ZUxheW91dChzeW5jZWREb21haW4sIGF4aXMubmljZSA/IHByaW1hcnlUaWNrQ291bnRzW2RpcmVjdGlvbl0gOiB2b2lkIDApO1xuICAgIGNvbnN0IGlzVmVydGljYWwgPSBkaXJlY3Rpb24gPT09IFwieVwiIC8qIFkgKi87XG4gICAgcHJpbWFyeVRpY2tDb3VudHNbZGlyZWN0aW9uXSA/PyAocHJpbWFyeVRpY2tDb3VudHNbZGlyZWN0aW9uXSA9IGxheW91dC5wcmltYXJ5VGlja0NvdW50KTtcbiAgICBjbGlwU2VyaWVzIHx8IChjbGlwU2VyaWVzID0gYXhpcy5kYXRhRG9tYWluLmNsaXBwZWQgfHwgYXhpcy52aXNpYmxlUmFuZ2VbMF0gPiAwIHx8IGF4aXMudmlzaWJsZVJhbmdlWzFdIDwgMSk7XG4gICAgbGV0IGF4aXNUaGlja25lc3M7XG4gICAgaWYgKGF4aXMudGhpY2tuZXNzICE9IG51bGwgJiYgYXhpcy50aGlja25lc3MgPiAwKSB7XG4gICAgICBheGlzVGhpY2tuZXNzID0gYXhpcy50aGlja25lc3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF4aXNUaGlja25lc3MgPSBpc1ZlcnRpY2FsID8gbGF5b3V0LmJib3gud2lkdGggOiBsYXlvdXQuYmJveC5oZWlnaHQ7XG4gICAgfVxuICAgIGF4aXNUaGlja25lc3MgPSBNYXRoLmNlaWwoYXhpc1RoaWNrbmVzcyk7XG4gICAgcmV0dXJuIHsgY2xpcFNlcmllcywgYXhpc1RoaWNrbmVzcyB9O1xuICB9XG4gIGdldFN5bmNlZERvbWFpbihheGlzKSB7XG4gICAgY29uc3Qgc3luY01vZHVsZSA9IHRoaXMubW9kdWxlc01hbmFnZXIuZ2V0TW9kdWxlKFwic3luY1wiKTtcbiAgICBpZiAoIXN5bmNNb2R1bGU/LmVuYWJsZWQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3Qgc3luY2VkRG9tYWluID0gc3luY01vZHVsZS5nZXRTeW5jZWREb21haW4oYXhpcyk7XG4gICAgaWYgKHN5bmNlZERvbWFpbiAmJiBheGlzLmRhdGFEb21haW4uZG9tYWluLmxlbmd0aCkge1xuICAgICAgbGV0IHNob3VsZFVwZGF0ZTtcbiAgICAgIGNvbnN0IHsgZG9tYWluIH0gPSBheGlzLnNjYWxlO1xuICAgICAgaWYgKENvbnRpbnVvdXNTY2FsZS5pcyhheGlzLnNjYWxlKSkge1xuICAgICAgICBjb25zdCBbbWluLCBtYXhdID0gZmluZE1pbk1heChzeW5jZWREb21haW4pO1xuICAgICAgICBzaG91bGRVcGRhdGUgPSBtaW4gIT09IGRvbWFpblswXSB8fCBtYXggIT09IGRvbWFpblsxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNob3VsZFVwZGF0ZSA9ICFhcnJheXNFcXVhbChzeW5jZWREb21haW4sIGRvbWFpbik7XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlICYmICF0aGlzLnNraXBTeW5jKSB7XG4gICAgICAgIHN5bmNNb2R1bGUudXBkYXRlU2libGluZ3MoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN5bmNlZERvbWFpbjtcbiAgfVxuICBzaXplQXhpcyhheGlzLCBzZXJpZXNSZWN0LCBwb3NpdGlvbikge1xuICAgIGNvbnN0IGlzQ2F0ZWdvcnkgPSBheGlzIGluc3RhbmNlb2YgQ2F0ZWdvcnlBeGlzIHx8IGF4aXMgaW5zdGFuY2VvZiBHcm91cGVkQ2F0ZWdvcnlBeGlzO1xuICAgIGNvbnN0IGlzTGVmdFJpZ2h0ID0gcG9zaXRpb24gPT09IFwibGVmdFwiIHx8IHBvc2l0aW9uID09PSBcInJpZ2h0XCI7XG4gICAgbGV0IHsgbWluLCBtYXggfSA9IHRoaXMuY3R4Lnpvb21NYW5hZ2VyLmdldEF4aXNab29tKGF4aXMuaWQpO1xuICAgIGNvbnN0IHsgd2lkdGg6IHdpZHRoMiwgaGVpZ2h0OiBoZWlnaHQyIH0gPSBzZXJpZXNSZWN0O1xuICAgIGNvbnN0IG1pblN0YXJ0ID0gMDtcbiAgICBjb25zdCBtYXhFbmQgPSBpc0xlZnRSaWdodCA/IGhlaWdodDIgOiB3aWR0aDI7XG4gICAgbGV0IHN0YXJ0MiA9IG1pblN0YXJ0O1xuICAgIGxldCBlbmQyID0gbWF4RW5kO1xuICAgIGNvbnN0IHsgd2lkdGg6IGF4aXNXaWR0aCwgdW5pdCwgYWxpZ24gfSA9IGF4aXMubGF5b3V0Q29uc3RyYWludHM7XG4gICAgaWYgKHVuaXQgPT09IFwicHhcIikge1xuICAgICAgZW5kMiA9IHN0YXJ0MiArIGF4aXNXaWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgZW5kMiA9IGVuZDIgKiBheGlzV2lkdGggLyAxMDA7XG4gICAgfVxuICAgIGlmIChhbGlnbiA9PT0gXCJlbmRcIikge1xuICAgICAgc3RhcnQyID0gbWF4RW5kIC0gKGVuZDIgLSBzdGFydDIpO1xuICAgICAgZW5kMiA9IG1heEVuZDtcbiAgICB9XG4gICAgaWYgKGlzQ2F0ZWdvcnkgJiYgaXNMZWZ0UmlnaHQpIHtcbiAgICAgIFttaW4sIG1heF0gPSBbMSAtIG1heCwgMSAtIG1pbl07XG4gICAgfSBlbHNlIGlmIChpc0xlZnRSaWdodCkge1xuICAgICAgW3N0YXJ0MiwgZW5kMl0gPSBbZW5kMiwgc3RhcnQyXTtcbiAgICB9XG4gICAgYXhpcy5yYW5nZSA9IFtzdGFydDIsIGVuZDJdO1xuICAgIGF4aXMudmlzaWJsZVJhbmdlID0gW21pbiwgbWF4XTtcbiAgICBheGlzLmdyaWRMZW5ndGggPSBpc0xlZnRSaWdodCA/IHdpZHRoMiA6IGhlaWdodDI7XG4gIH1cbiAgY2FsY3VsYXRlQXhpc0FyZWEoYXhlcywgYXhpc1dpZHRocywgYXhpc09mZnNldHMsIGlzVmVydGljYWwpIHtcbiAgICBjb25zdCB7IHdpZHRoOiB3aWR0aDIsIGhlaWdodDogaGVpZ2h0MiwgY2FudmFzIH0gPSB0aGlzLmN0eC5zY2VuZTtcbiAgICBsZXQgY3VycmVudE9mZnNldCA9IGlzVmVydGljYWwgPyBoZWlnaHQyICUgY2FudmFzLnBpeGVsUmF0aW8gOiB3aWR0aDIgJSBjYW52YXMucGl4ZWxSYXRpbztcbiAgICBsZXQgdG90YWxBeGlzV2lkdGggPSAwO1xuICAgIGZvciAoY29uc3QgYXhpcyBvZiBheGVzKSB7XG4gICAgICBheGlzT2Zmc2V0cy5zZXQoYXhpcy5pZCwgY3VycmVudE9mZnNldCk7XG4gICAgICBjb25zdCBheGlzVGhpY2tuZXNzID0gYXhpc1dpZHRocy5nZXQoYXhpcy5pZCkgPz8gMDtcbiAgICAgIHRvdGFsQXhpc1dpZHRoID0gTWF0aC5tYXgodG90YWxBeGlzV2lkdGgsIGN1cnJlbnRPZmZzZXQgKyBheGlzVGhpY2tuZXNzKTtcbiAgICAgIGlmIChheGlzLmxheW91dENvbnN0cmFpbnRzLnN0YWNrZWQpIHtcbiAgICAgICAgY3VycmVudE9mZnNldCArPSBheGlzVGhpY2tuZXNzICsgMTU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0b3RhbEF4aXNXaWR0aDtcbiAgfVxuICBwb3NpdGlvbkF4ZXMob3B0cykge1xuICAgIGNvbnN0IHsgYXhlcywgYXhpc0JvdW5kLCBheGlzV2lkdGhzLCBheGlzT2Zmc2V0cywgYXhpc0FyZWFXaWR0aHMsIHNlcmllc1JlY3QsIHBvc2l0aW9uIH0gPSBvcHRzO1xuICAgIGNvbnN0IGF4aXNBcmVhV2lkdGggPSBheGlzQXJlYVdpZHRocy5nZXQocG9zaXRpb24pID8/IDA7XG4gICAgbGV0IG1haW5EaW1lbnNpb24gPSBcInhcIjtcbiAgICBsZXQgbWlub3JEaW1lbnNpb24gPSBcInlcIjtcbiAgICBsZXQgZGlyZWN0aW9uID0gMTtcbiAgICBsZXQgYXhpc0JvdW5kTWFpbk9mZnNldCA9IDA7XG4gICAgaWYgKHBvc2l0aW9uID09PSBcInRvcFwiIHx8IHBvc2l0aW9uID09PSBcImJvdHRvbVwiKSB7XG4gICAgICBtYWluRGltZW5zaW9uID0gXCJ5XCI7XG4gICAgICBtaW5vckRpbWVuc2lvbiA9IFwieFwiO1xuICAgICAgYXhpc0JvdW5kTWFpbk9mZnNldCArPSAxO1xuICAgIH1cbiAgICBheGlzQm91bmRNYWluT2Zmc2V0ICs9IGF4aXNCb3VuZFttYWluRGltZW5zaW9uXTtcbiAgICBpZiAocG9zaXRpb24gPT09IFwicmlnaHRcIiB8fCBwb3NpdGlvbiA9PT0gXCJib3R0b21cIikge1xuICAgICAgZGlyZWN0aW9uID0gLTE7XG4gICAgICBheGlzQm91bmRNYWluT2Zmc2V0ICs9IG1haW5EaW1lbnNpb24gPT09IFwieFwiID8gYXhpc0JvdW5kLndpZHRoIDogYXhpc0JvdW5kLmhlaWdodDtcbiAgICB9XG4gICAgZm9yIChjb25zdCBheGlzIG9mIGF4ZXMpIHtcbiAgICAgIGNvbnN0IG1pbm9yT2Zmc2V0ID0gYXhpc0FyZWFXaWR0aHMuZ2V0KG1pbm9yRGltZW5zaW9uID09PSBcInhcIiA/IFwibGVmdFwiIDogXCJ0b3BcIikgPz8gMDtcbiAgICAgIGF4aXMudHJhbnNsYXRpb25bbWlub3JEaW1lbnNpb25dID0gYXhpc0JvdW5kW21pbm9yRGltZW5zaW9uXSArIG1pbm9yT2Zmc2V0O1xuICAgICAgY29uc3QgYXhpc1RoaWNrbmVzcyA9IGF4aXNXaWR0aHMuZ2V0KGF4aXMuaWQpID8/IDA7XG4gICAgICBjb25zdCBheGlzT2Zmc2V0ID0gYXhpc09mZnNldHMuZ2V0KGF4aXMuaWQpID8/IDA7XG4gICAgICBheGlzLnRyYW5zbGF0aW9uW21haW5EaW1lbnNpb25dID0gdGhpcy5jbGFtcFRvT3V0c2lkZVNlcmllc1JlY3QoXG4gICAgICAgIHNlcmllc1JlY3QsXG4gICAgICAgIGF4aXNCb3VuZE1haW5PZmZzZXQgKyBkaXJlY3Rpb24gKiAoYXhpc09mZnNldCArIGF4aXNUaGlja25lc3MpLFxuICAgICAgICBtYWluRGltZW5zaW9uLFxuICAgICAgICBkaXJlY3Rpb25cbiAgICAgICk7XG4gICAgICBheGlzLmdyaWRQYWRkaW5nID0gYXhpc0FyZWFXaWR0aCAtIGF4aXNPZmZzZXQgLSBheGlzVGhpY2tuZXNzO1xuICAgICAgYXhpcy51cGRhdGVQb3NpdGlvbigpO1xuICAgIH1cbiAgfVxuICBzaG91bGRGbGlwWFkoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VyaWVzLmV2ZXJ5KChzZXJpZXMpID0+IHNlcmllcyBpbnN0YW5jZW9mIENhcnRlc2lhblNlcmllcyAmJiBzZXJpZXMuc2hvdWxkRmxpcFhZKCkpO1xuICB9XG59O1xuQ2FydGVzaWFuQ2hhcnQuY2xhc3NOYW1lID0gXCJDYXJ0ZXNpYW5DaGFydFwiO1xuQ2FydGVzaWFuQ2hhcnQudHlwZSA9IFwiY2FydGVzaWFuXCI7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2NoYXJ0UHJveHkudHNcbnZhciBfQWdDaGFydEluc3RhbmNlUHJveHkgPSBjbGFzcyBfQWdDaGFydEluc3RhbmNlUHJveHkge1xuICBjb25zdHJ1Y3RvcihjaGFydCwgZmFjdG9yeUFwaSwgbGljZW5zZU1hbmFnZXIpIHtcbiAgICB0aGlzLmZhY3RvcnlBcGkgPSBmYWN0b3J5QXBpO1xuICAgIHRoaXMubGljZW5zZU1hbmFnZXIgPSBsaWNlbnNlTWFuYWdlcjtcbiAgICB0aGlzLmNoYXJ0ID0gY2hhcnQ7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoeCkge1xuICAgIGlmICh4IGluc3RhbmNlb2YgX0FnQ2hhcnRJbnN0YW5jZVByb3h5KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHguY29uc3RydWN0b3I/Lm5hbWUgPT09IFwiQWdDaGFydEluc3RhbmNlUHJveHlcIiAmJiB4LmNoYXJ0ICE9IG51bGwpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4geC5jaGFydCAhPSBudWxsICYmIHRoaXMudmFsaWRhdGVJbXBsZW1lbnRhdGlvbih4KTtcbiAgfVxuICBzdGF0aWMgdmFsaWRhdGVJbXBsZW1lbnRhdGlvbih4KSB7XG4gICAgY29uc3QgY2hhcnRQcm9wcyA9IFtcImdldE9wdGlvbnNcIiwgXCJkZXN0cm95XCJdO1xuICAgIGNvbnN0IHNpZ25hdHVyZVByb3BzID0gT2JqZWN0LmtleXMoT2JqZWN0LmdldFByb3RvdHlwZU9mKHgpID8/IHt9KTtcbiAgICByZXR1cm4gY2hhcnRQcm9wcy5ldmVyeSgocHJvcCkgPT4gc2lnbmF0dXJlUHJvcHMuaW5jbHVkZXMocHJvcCkpO1xuICB9XG4gIGFzeW5jIHVwZGF0ZShvcHRpb25zKSB7XG4gICAgdGhpcy5mYWN0b3J5QXBpLnVwZGF0ZShvcHRpb25zLCB0aGlzKTtcbiAgICBhd2FpdCB0aGlzLmNoYXJ0LndhaXRGb3JVcGRhdGUoKTtcbiAgfVxuICBhc3luYyB1cGRhdGVEZWx0YShkZWx0YU9wdGlvbnMpIHtcbiAgICB0aGlzLmZhY3RvcnlBcGkudXBkYXRlVXNlckRlbHRhKHRoaXMsIGRlbHRhT3B0aW9ucyk7XG4gICAgYXdhaXQgdGhpcy5jaGFydC53YWl0Rm9yVXBkYXRlKCk7XG4gIH1cbiAgZ2V0T3B0aW9ucygpIHtcbiAgICBjb25zdCBvcHRpb25zID0gZGVlcENsb25lKHRoaXMuY2hhcnQuZ2V0T3B0aW9ucygpKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvcHRpb25zKSB7XG4gICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoXCJfXCIpKSB7XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zW2tleV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xuICB9XG4gIHdhaXRGb3JVcGRhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcnQud2FpdEZvclVwZGF0ZSgpO1xuICB9XG4gIGFzeW5jIGRvd25sb2FkKG9wdHMpIHtcbiAgICBjb25zdCBjbG9uZTIgPSBhd2FpdCB0aGlzLnByZXBhcmVSZXNpemVkQ2hhcnQodGhpcywgb3B0cyk7XG4gICAgdHJ5IHtcbiAgICAgIGNsb25lMi5jaGFydC5kb3dubG9hZChvcHRzPy5maWxlTmFtZSwgb3B0cz8uZmlsZUZvcm1hdCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGNsb25lMi5kZXN0cm95KCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIF9fdG9TVkcob3B0cykge1xuICAgIGNvbnN0IGNsb25lMiA9IGF3YWl0IHRoaXMucHJlcGFyZVJlc2l6ZWRDaGFydCh0aGlzLCB7IHdpZHRoOiA2MDAsIGhlaWdodDogMzAwLCAuLi5vcHRzIH0pO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY2xvbmUyLmNoYXJ0LnRvU1ZHKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGNsb25lMi5kZXN0cm95KCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGdldEltYWdlRGF0YVVSTChvcHRzKSB7XG4gICAgY29uc3QgY2xvbmUyID0gYXdhaXQgdGhpcy5wcmVwYXJlUmVzaXplZENoYXJ0KHRoaXMsIG9wdHMpO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY2xvbmUyLmNoYXJ0LmdldENhbnZhc0RhdGFVUkwob3B0cz8uZmlsZUZvcm1hdCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGNsb25lMi5kZXN0cm95KCk7XG4gICAgfVxuICB9XG4gIGdldFN0YXRlKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGZhY3RvcnlBcGk6IHsgY2FyZXRha2VyIH0sXG4gICAgICBjaGFydDoge1xuICAgICAgICBjdHg6IHsgYW5ub3RhdGlvbk1hbmFnZXIgfVxuICAgICAgfVxuICAgIH0gPSB0aGlzO1xuICAgIHJldHVybiBjYXJldGFrZXIuc2F2ZShhbm5vdGF0aW9uTWFuYWdlcik7XG4gIH1cbiAgYXN5bmMgc2V0U3RhdGUoc3RhdGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBmYWN0b3J5QXBpOiB7IGNhcmV0YWtlciB9LFxuICAgICAgY2hhcnQ6IHtcbiAgICAgICAgY3R4OiB7IGFubm90YXRpb25NYW5hZ2VyIH1cbiAgICAgIH1cbiAgICB9ID0gdGhpcztcbiAgICBjYXJldGFrZXIucmVzdG9yZShzdGF0ZSwgYW5ub3RhdGlvbk1hbmFnZXIpO1xuICAgIGF3YWl0IHRoaXMuY2hhcnQud2FpdEZvclVwZGF0ZSgpO1xuICB9XG4gIHJlc2V0QW5pbWF0aW9ucygpIHtcbiAgICB0aGlzLmNoYXJ0LnJlc2V0QW5pbWF0aW9ucygpO1xuICB9XG4gIHNraXBBbmltYXRpb25zKCkge1xuICAgIHRoaXMuY2hhcnQuc2tpcEFuaW1hdGlvbnMoKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuY2hhcnQucHVibGljQXBpID0gdm9pZCAwO1xuICAgIHRoaXMuY2hhcnQuZGVzdHJveSgpO1xuICB9XG4gIGFzeW5jIHByZXBhcmVSZXNpemVkQ2hhcnQocHJveHksIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IHsgY2hhcnQgfSA9IHByb3h5O1xuICAgIGNvbnN0IHdpZHRoMiA9IG9wdHMud2lkdGggPz8gY2hhcnQud2lkdGggPz8gY2hhcnQuY3R4LnNjZW5lLmNhbnZhcy53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQyID0gb3B0cy5oZWlnaHQgPz8gY2hhcnQuaGVpZ2h0ID8/IGNoYXJ0LmN0eC5zY2VuZS5jYW52YXMuaGVpZ2h0O1xuICAgIGNvbnN0IHN0YXRlID0gcHJveHkuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBpc0VudGVycHJpc2UgPSBtb2R1bGVSZWdpc3RyeS5oYXNFbnRlcnByaXNlTW9kdWxlcygpO1xuICAgIGNvbnN0IHByb2Nlc3NlZE92ZXJyaWRlcyA9IHtcbiAgICAgIC4uLmNoYXJ0LmNoYXJ0T3B0aW9ucy5wcm9jZXNzZWRPdmVycmlkZXMsXG4gICAgICBjb250YWluZXI6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG4gICAgICB3aWR0aDogd2lkdGgyLFxuICAgICAgaGVpZ2h0OiBoZWlnaHQyXG4gICAgfTtcbiAgICBjb25zdCB1c2VyT3B0aW9ucyA9IGNoYXJ0LmdldE9wdGlvbnMoKTtcbiAgICBpZiAoaXNFbnRlcnByaXNlKSB7XG4gICAgICBwcm9jZXNzZWRPdmVycmlkZXMuYW5pbWF0aW9uID0geyBlbmFibGVkOiBmYWxzZSB9O1xuICAgICAgaWYgKGlzQWdDYXJ0ZXNpYW5DaGFydE9wdGlvbnModXNlck9wdGlvbnMpKSB7XG4gICAgICAgIHByb2Nlc3NlZE92ZXJyaWRlcy50b29sYmFyID0geyBlbmFibGVkOiBmYWxzZSB9O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubGljZW5zZU1hbmFnZXI/LmlzRGlzcGxheVdhdGVybWFyaygpKSB7XG4gICAgICAgIHByb2Nlc3NlZE92ZXJyaWRlcy5mb3JlZ3JvdW5kID0ge1xuICAgICAgICAgIHRleHQ6IHRoaXMubGljZW5zZU1hbmFnZXIuZ2V0V2F0ZXJtYXJrTWVzc2FnZSgpLFxuICAgICAgICAgIGltYWdlOiB7XG4gICAgICAgICAgICB1cmw6IGBkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNalU0SWlCb1pXbG5hSFE5SWpRd0lpQjJhV1YzUW05NFBTSXdJREFnTWpVNElEUXdJaUJtYVd4c1BTSnViMjVsSWlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpUGdvOGNHRjBhQ0JrUFNKTk1qVXVOemM1SURJNExqWTFOMGd4TXk0ek5UbE1NVEV1TVRjeklETTBMakF4TWtnMUxqWTNNamszVERFM0xqRTRNaUEzTGpBMU9UazVTREl4TGprMU0wd3pNeTQwTmpJZ016UXVNREV5U0RJM0xqazJNa3d5TlM0M056WWdNamd1TmpVM1NESTFMamMzT1ZwTk1qUXVNRFk0SURJMExqTTVOMHd4T1M0MU9EZ2dNVE11TkRNMFRERTFMakV3TnlBeU5DNHpPVGRJTWpRdU1EWTRXazAyTWk0d09USWdNVGd1T0RJelNEUTVMamd4TjFZeU15NHdPRFpJTlRZdU56YzFRelUyTGpVMU5TQXlOUzR5TWpJZ05UVXVOelUxSURJMkxqa3lOeUExTkM0ek56SWdNamd1TWpBeVF6VXlMams0T1NBeU9TNDBOellnTlRFdU1UWTJJRE13TGpFeE5TQTBPQzQ1TURrZ016QXVNVEUxUXpRM0xqWXlNaUF6TUM0eE1UVWdORFl1TkRVZ01qa3VPRGcxSURRMUxqTTVNeUF5T1M0ME1qTkRORFF1TXpVNE15QXlPQzQ1TnpneElEUXpMalF6TWpZZ01qZ3VNekV6T0NBME1pNDJPQ0F5Tnk0ME56WkROREV1T1RJM0lESTJMall6T1NBME1TNHpORFFnTWpVdU5qTXhJRFF3TGprek1TQXlOQzQwTlRORE5EQXVOVEU1SURJekxqSTNOU0EwTUM0ek1URWdNakV1T1RjZ05EQXVNekV4SURJd0xqVXpOME0wTUM0ek1URWdNVGt1TVRBMUlEUXdMalV4TmlBeE55NDRJRFF3TGprek1TQXhOaTQyTWpGRE5ERXVNelEwSURFMUxqUTBNeUEwTVM0NU1qY2dNVFF1TkRNMklEUXlMalk0SURFekxqVTVPRU0wTXk0ME16YzJJREV5TGpjMU56Y2dORFF1TXpZNU5pQXhNaTR3T1RNeUlEUTFMalF4TVNBeE1TNDJOVEZETkRZdU5EYzRJREV4TGpFNE9TQTBOeTQyTlRZZ01UQXVPVFlnTkRndU9UUTJJREV3TGprMlF6VXhMall4TWlBeE1DNDVOaUExTXk0Mk16Y2dNVEV1TmpBeUlEVTFMakF5SURFeUxqZzROVXcxT0M0eklEa3VOakEwT1RsRE5UVXVPREUzSURjdU5qWTVPVGtnTlRJdU5qYzJJRFl1TmprNU9Ua2dORGd1T0RjeUlEWXVOams1T1RsRE5EWXVOellnTmk0Mk9UazVPU0EwTkM0NE5UTWdOeTR3TXpRNU9TQTBNeTR4TlRRZ055NDNNREE1T1VNME1TNDBOVFVnT0M0ek5qYzVPU0F6T1M0NU9UZ2dPUzR6TURNNU9TQXpPQzQzT0RNZ01UQXVOVEEwUXpNM0xqVTJOeUF4TVM0M01EY2dNell1TmpNMElERXpMakUxT0NBek5TNDVOemNnTVRRdU9EVTNRek0xTGpNeE9TQXhOaTQxTlRZZ016UXVPVGswSURFNExqUTFNU0F6TkM0NU9UUWdNakF1TlRSRE16UXVPVGswSURJeUxqWXpJRE0xTGpNeU9TQXlOQzQwT1RRZ016VXVPVGsxSURJMkxqSXdOVU16Tmk0Mk5qSWdNamN1T1RFMklETTNMall3TlNBeU9TNHpOelFnTXpndU9ERTNJRE13TGpVM04wTTBNQzR3TXpJZ016RXVOemdnTkRFdU5EZzJJRE15TGpjeE15QTBNeTR4T0RnZ016TXVNemd6UXpRMExqZzRPQ0F6TkM0d05Ea2dORFl1TnpneUlETTBMak00TkNBME9DNDROeklnTXpRdU16ZzBRelV3TGprMk1TQXpOQzR6T0RRZ05USXVOelVnTXpRdU1EUTVJRFUwTGpNNUlETXpMak00TTBNMU5pNHdNekVnTXpJdU56RTJJRFUzTGpReU5pQXpNUzQzT0NBMU9DNDFOemtnTXpBdU5UYzNRelU1TGpjek15QXlPUzR6TnpRZ05qQXVOakU1SURJM0xqa3hOaUEyTVM0eU16a2dNall1TWpBMVF6WXhMamcySURJMExqUTVOQ0EyTWk0eE55QXlNaTQyTURVZ05qSXVNVGNnTWpBdU5UUkROakl1TVRZNU5pQXhPUzQ1TmpnNElEWXlMakUwTkRVZ01Ua3VNems0SURZeUxqQTVOU0F4T0M0NE1qbE1Oakl1TURreUlERTRMamd5TTFwTk1UVXhMamd4SURFMkxqazRNVU14TlRNdU5ERWdNVFF1TmpBNUlERTFOeTQwTVRrZ01UUXVNelU0SURFMU9TNHdNaklnTVRRdU16VTRWakU0TGpreFF6RTFOaTQ1TlRjZ01UZ3VPVEVnTVRVMExqazROU0F4T0M0NU9UWWdNVFV6TGpjMU55QXhPUzQ0T1RKRE1UVXlMalV5T1NBeU1DNDNPVElnTVRVeExqa3hPU0F5TVM0NU9ESWdNVFV4TGpreE9TQXlNeTQwTmpSV016TXVPVGxJTVRRMkxqazJORll4TkM0ek5UaElNVFV4TGpjek5rd3hOVEV1T0RFZ01UWXVPVGd4V2sweE5ETXVNREV4SURFMExqTTJNVll6TkM0d016RklNVE00TGpJMFRERXpPQzR4TXpFZ016RXVNRFExUXpFek55NDBOallnTXpJdU1EYzJJREV6Tmk0MU5URWdNekl1T1RJeE9TQXhNelV1TkRjeElETXpMalV3TkVNeE16UXVNemMySURNMExqQTVPU0F4TXpNdU1EWTRJRE0wTGpNNU5pQXhNekV1TlRNMklETTBMak01TmtNeE16QXVNaUF6TkM0ek9UWWdNVEk0TGprMk15QXpOQzR4TlRJZ01USTNMamd5TWlBek15NDJOamhETVRJMkxqY2dNek11TVRrMk5DQXhNalV1TmpnNUlETXlMalE1TlNBeE1qUXVPRFUxSURNeExqWXdPVU14TWpRdU1ERTRJRE13TGpjeU1pQXhNak11TXpVMElESTVMalkyTWlBeE1qSXVPRGN4SURJNExqUXlNa014TWpJdU16ZzBJREkzTGpFNE5TQXhNakl1TVRReUlESTFMamd4TVNBeE1qSXVNVFF5SURJMExqTXdORU14TWpJdU1UUXlJREl5TGpjNU9DQXhNakl1TXpnMElESXhMak0zT0NBeE1qSXVPRGN4SURJd0xqRXhOa014TWpNdU16VTNJREU0TGpnMU5DQXhNalF1TURFNElERTNMamMzTWlBeE1qUXVPRFUxSURFMkxqZzNNME14TWpVdU5qZzRJREUxTGprM05qUWdNVEkyTGpZNU9DQXhOUzR5TmpNMklERXlOeTQ0TWpJZ01UUXVOemhETVRJNExqazJNeUF4TkM0eU9ERWdNVE13TGpJd015QXhOQzR3TXpNZ01UTXhMalV6TmlBeE5DNHdNek5ETVRNekxqQTBNeUF4TkM0d016TWdNVE0wTGpNeklERTBMak14T0NBeE16VXVNemszSURFMExqZzRPRU14TXpZdU5EWXlJREUxTGpRMU9Ea2dNVE0zTGpNM05TQXhOaTR5TnpnZ01UTTRMakExTnlBeE55NHlOelpXTVRRdU16WXhTREUwTXk0d01URmFUVEV6TWk0Mk16RWdNekF1TVRNelF6RXpOQzR5TlRZZ016QXVNVE16SURFek5TNDFOamNnTWprdU5UazBJREV6Tmk0MU5qVWdNamd1TlRFeVF6RXpOeTQxTmpFZ01qY3VORE1nTVRNNExqQTJJREkxTGprNU1TQXhNemd1TURZZ01qUXVNVGsyUXpFek9DNHdOaUF5TWk0ME1ERWdNVE0zTGpVMk1TQXlNQzQ1T1NBeE16WXVOVFkxSURFNUxqZzVPVU14TXpVdU5UY2dNVGd1T0RBM0lERXpOQzR5TlRrZ01UZ3VNalU0SURFek1pNDJNekVnTVRndU1qVTRRekV6TVM0d01ETWdNVGd1TWpVNElERXlPUzQzTWprZ01UZ3VPREEwSURFeU9DNDNNelFnTVRrdU9EazVRekV5Tnk0M016Z2dNakF1T1RreklERXlOeTR5TXprZ01qSXVORE00SURFeU55NHlNemtnTWpRdU1qTXpRekV5Tnk0eU16a2dNall1TURJNElERXlOeTQzTXpVZ01qY3VORE16SURFeU9DNDNNelFnTWpndU5URTFRekV5T1M0M01qa2dNamt1TlRrMElERXpNUzR3TWpnZ016QXVNVE0ySURFek1pNDJNekVnTXpBdU1UTTJWak13TGpFek0xcE5PVE11TmprNElESTNMamczTmtNNU15NDFOemsxSURJNExqQXdNalVnT1RNdU5EVTJOQ0F5T0M0eE1qUTJJRGt6TGpNeU9TQXlPQzR5TkRKRE9URXVPVFEzSURJNUxqVXhOaUE1TUM0eE1qTWdNekF1TVRVMUlEZzNMamcyTmlBek1DNHhOVFZET0RZdU5UZ2dNekF1TVRVMUlEZzFMalF3T0NBeU9TNDVNallnT0RRdU16VWdNamt1TkRZMFF6Z3pMak14TlRVZ01qa3VNREU0T1NBNE1pNHpPRGs0SURJNExqTTFORFlnT0RFdU5qTTNJREkzTGpVeE4wTTRNQzQ0T0RRZ01qWXVOamM1SURnd0xqTXdNU0F5TlM0Mk56SWdOemt1T0RnNUlESTBMalE1TkVNM09TNDBOellnTWpNdU16RTFJRGM1TGpJMk9TQXlNaTR3TVNBM09TNHlOamtnTWpBdU5UYzRRemM1TGpJMk9TQXhPUzR4TkRVZ056a3VORGN6SURFM0xqZzBJRGM1TGpnNE9TQXhOaTQyTmpKRE9EQXVNekF4SURFMUxqUTROQ0E0TUM0NE9EUWdNVFF1TkRjMklEZ3hMall6TnlBeE15NDJNemxET0RJdU16azBPU0F4TWk0M09UZzNJRGd6TGpNeU56TWdNVEl1TVRNME1pQTROQzR6TmprZ01URXVOamt5UXpnMUxqUXpOaUF4TVM0eU15QTROaTQyTVRRZ01URWdPRGN1T1RBeklERXhRemt3TGpVM0lERXhJRGt5TGpVNU5TQXhNUzQyTkRJZ09UTXVPVGMzSURFeUxqa3lOa3c1Tnk0eU5UZ2dPUzQyTkRRNU9VTTVOQzQzTnpRZ055NDNNVEE1T1NBNU1TNDJNek1nTmk0M016azVPU0E0Tnk0NE1qa2dOaTQzTXprNU9VTTROUzQzTVRnZ05pNDNNems1T1NBNE15NDRNVEVnTnk0d056UTVPU0E0TWk0eE1USWdOeTQzTkRFNU9VTTRNQzQwTVRNZ09DNDBNRGM1T1NBM09DNDVOVFlnT1M0ek5EUTVPU0EzTnk0M05DQXhNQzQxTkRWRE56WXVOVEkxSURFeExqYzBOeUEzTlM0MU9USWdNVE11TVRrNUlEYzBMamt6TkNBeE5DNDRPVGhETnpRdU1qYzNJREUyTGpVNU55QTNNeTQ1TlRFZ01UZ3VORGt4SURjekxqazFNU0F5TUM0MU9ERkROek11T1RVeElESXlMalkzSURjMExqSTROaUF5TkM0MU16UWdOelF1T1RVeklESTJMakkwTlVNM05TNDJNVGtnTWpjdU9UVTNJRGMyTGpVMk1pQXlPUzQwTVRRZ056Y3VOemMwSURNd0xqWXhOME0zT0M0NU9TQXpNUzQ0TWlBNE1DNDBORFFnTXpJdU56VXpJRGd5TGpFME5pQXpNeTQwTWpORE9ETXVPRFExSURNMExqQTVJRGcxTGpjek9TQXpOQzQwTWpRZ09EY3VPREk1SURNMExqUXlORU00T1M0NU1Ua2dNelF1TkRJMElEa3hMamN3T0NBek5DNHdPU0E1TXk0ek5EZ2dNek11TkRJelF6azBMamN4T0NBek1pNDROalVnT1RVdU9URTRJRE15TGpFeU1TQTVOaTQ1TkRnZ016RXVNVGt4UXprM0xqRTBPU0F6TVM0d01EZ2dPVGN1TXpRNElETXdMamd4TlNBNU55NDFNemNnTXpBdU5qSk1PVE11TnpBeElESTNMamc0TlV3NU15NDJPVGdnTWpjdU9EYzJXazB4TVRBdU9EQXlJREUwTGpBeE5VTXhNRGt1TVRrNUlERTBMakF4TlNBeE1EWXVPRE0ySURFMExqUTNNU0F4TURVdU5qRXhJREUyTGpFMU9Fd3hNRFV1TlRNM0lEWXVNREUxT1RsSU1UQXdMamMyTlZZek15NDVNemxJTVRBMUxqY3lWakl5TGpZME1VTXhNRFV1TnpjeElESXhMalEyTURjZ01UQTJMakk0T0NBeU1DNHpORGc0SURFd055NHhOVGNnTVRrdU5UUTRPVU14TURndU1ESTNJREU0TGpjME9URWdNVEE1TGpFM09DQXhPQzR6TWpZMklERXhNQzR6TlRnZ01UZ3VNemMwUXpFeE15NHpPVGNnTVRndU16YzBJREV4TkM0eU5qZ2dNakV1TVRVNUlERXhOQzR5TmpnZ01qSXVOalF4VmpNekxqa3pPVWd4TVRrdU1qSXpWakl4TGpBMU9VTXhNVGt1TWpJeklESXhMakExT1NBeE1Ua3VNVFF5SURFMExqQXhOU0F4TVRBdU9EQXlJREUwTGpBeE5WcE5NVGN6TGpjMk15QXhOQzR6TlRoSU1UWTVMams1T1ZZNExqY3hORGs1U0RFMk5TNHdORGhXTVRRdU16VTRTREUyTVM0eU9EUldNVGd1T1RFMlNERTJOUzR3TkRoV016UXVNREF6U0RFMk9TNDVPVGxXTVRndU9URTJTREUzTXk0M05qTldNVFF1TXpVNFdrMHhPVEF1TnpnM0lESTFMakkyTWtNeE9UQXVNVEk1SURJMExqVXdNVFFnTVRnNUxqTXdOeUF5TXk0NE9UazBJREU0T0M0ek9EUWdNak11TlRBeFF6RTROeTQwT0RnZ01qTXVNVEUzSURFNE5pNHpNekVnTWpJdU56TXlJREU0TkM0NU5EZ2dNakl1TXpZMFF6RTROQzR4TmpVZ01qSXVNVFF6T1NBeE9ETXVNemtnTWpFdU9EazNPQ0F4T0RJdU5qSXpJREl4TGpZeU5rTXhPREl1TVRZeklESXhMalEyTWpFZ01UZ3hMamMwTVNBeU1TNHlNRFkySURFNE1TNHpPRE1nTWpBdU9EYzFRekU0TVM0eU16VWdNakF1TnpReU1TQXhPREV1TVRFNElESXdMalUzT0RrZ01UZ3hMakF6T1NBeU1DNHpPVFkwUXpFNE1DNDVOakVnTWpBdU1qRTBJREU0TUM0NU1qSWdNakF1TURFMk5pQXhPREF1T1RJM0lERTVMamd4T0VNeE9EQXVPVEkzSURFNUxqSTNNaUF4T0RFdU1UVTJJREU0TGpnME5DQXhPREV1TmpJMUlERTRMalV4UXpFNE1pNHhNakVnTVRndU1UVTJJREU0TWk0NE5qSWdNVGN1T1RjMklERTRNeTQ0TWpZZ01UY3VPVGMyUXpFNE5DNDNPU0F4Tnk0NU56WWdNVGcxTGpVNE55QXhPQzR5TURrZ01UZzJMakUwT0NBeE9DNDJOamhETVRnMkxqY3dOaUF4T1M0eE1qUWdNVGczTGpBd055QXhPUzQzTWpVZ01UZzNMakEzTWlBeU1DNDFUREU0Tnk0d09UUWdNakF1TnpneVNERTVNUzQyTXpOTU1Ua3hMall4TnlBeU1DNDBOa014T1RFdU5USXhJREU0TGpRNE5TQXhPVEF1TnpjeElERTJMamtnTVRnNUxqTTROU0F4TlM0M05VTXhPRGd1TURFeUlERTBMall4TWlBeE9EWXVNVGcxSURFMExqQXpNeUF4T0RNdU9UWXlJREUwTGpBek0wTXhPREl1TkRjM0lERTBMakF6TXlBeE9ERXVNVFF4SURFMExqSTROeUF4TnprdU9UazBJREUwTGpjNE5rTXhOemd1T0RNeElERTFMakk1TVNBeE56Y3VPVEkySURFMUxqazVOU0F4TnpjdU1qazJJREUyTGpnNE1rTXhOell1TmpjeklERTNMamMwTlRVZ01UYzJMak16T0NBeE9DNDNPRFFnTVRjMkxqTTBNU0F4T1M0NE5EbERNVGMyTGpNME1TQXlNUzR4TmpjZ01UYzJMalk1T0NBeU1pNHlORGtnTVRjM0xqTTVPU0F5TXk0d05qUkRNVGM0TGpBMklESXpMamcwTXpJZ01UYzRMamc1T0NBeU5DNDBOVE0wSURFM09TNDRORElnTWpRdU9EUTBRekU0TUM0M05EUWdNalV1TWpFMklERTRNUzQ1TWpnZ01qVXVOakEzSURFNE15NHpOakVnTWpaRE1UZzBMamd3TmlBeU5pNDBNU0F4T0RVdU9EY3lJREkyTGpjNE5TQXhPRFl1TlRNZ01qY3VNVEl6UXpFNE55NHhJREkzTGpReE5DQXhPRGN1TXpjNUlESTNMamcwTlNBeE9EY3VNemM1SURJNExqUTBORU14T0RjdU16YzVJREk1TGpBME1pQXhPRGN1TVRJeUlESTVMalEyTnlBeE9EWXVOVGsxSURJNUxqZ3pPVU14T0RZdU1EUXpJRE13TGpJeU5pQXhPRFV1TWpNM0lETXdMalF5TlNBeE9EUXVNakF4SURNd0xqUXlOVU14T0RNdU1UWTJJRE13TGpReU5TQXhPREl1TXprMElETXdMakUzTkNBeE9ERXVOelE1SURJNUxqWTNORU14T0RFdU1URXpJREk1TGpFNE1TQXhPREF1TnpjeUlESTRMalU0T1NBeE9EQXVOekVnTWpjdU9EWTBUREU0TUM0Mk9EVWdNamN1TlRneVNERTNOaTR3TVROTU1UYzJMakF5TlNBeU55NDVNREZETVRjMkxqQTJOeUF5T1M0d09UVTFJREUzTmk0ME56SWdNekF1TWpRNE55QXhOemN1TVRnNElETXhMakl3TmtNeE56Y3VPVEEzSURNeUxqRTRJREUzT0M0NE9UTWdNekl1T1RVNElERTRNQzR4TVRnZ016TXVOVEU1UXpFNE1TNHpNellnTXpRdU1EYzNJREU0TWk0M016SWdNelF1TXpZeUlERTROQzR5TmpZZ016UXVNell5UXpFNE5TNDRNREVnTXpRdU16WXlJREU0Tnk0eE1Ea2dNelF1TVRBNElERTRPQzR5TXpnZ016TXVOakE1UXpFNE9TNHpOellnTXpNdU1UQTBJREU1TUM0eU56SWdNekl1TXprMElERTVNQzQ1TURFZ016RXVORGswUXpFNU1TNDFNelFnTXpBdU5Ua3lJREU1TVM0NE5UTWdNamt1TlRVMElERTVNUzQ0TlRNZ01qZ3VOREF6UXpFNU1TNDRNamdnTWpjdU1URWdNVGt4TGpRMk5pQXlOaTR3TlRNZ01Ua3dMamMzTnlBeU5TNHlOakpJTVRrd0xqYzROMW9pSUdacGJHdzlJaU01UWpsQ09VSWlMejRLUEhCaGRHZ2daRDBpVFRJME1TNDVPRElnTWpVdU5qVTRNbFl4Tnk0M01URTNTREl5T0M0ME5ERk1Nakl3TGpRNU5DQXlOUzQyTlRneVNESTBNUzQ1T0RKYUlpQm1hV3hzUFNJak9VSTVRamxDSWk4K0NqeHdZWFJvSUdROUlrMHlOVGN1TWpNNUlEVXVPVFV3T0RGSU1qUXdMakkyTlV3eU16SXVNalUxSURFekxqZzVOek5JTWpVM0xqSXpPVlkxTGprMU1EZ3hXaUlnWm1sc2JEMGlJemxDT1VJNVFpSXZQZ284Y0dGMGFDQmtQU0pOTWpFeUxqWXhNU0F6TXk0Mk1EUTRUREl4Tmk0Mk9DQXlPUzQxTXpZeFNESXpNQzQwTVRKV016Y3VORGd5TjBneU1USXVOakV4VmpNekxqWXdORGhhSWlCbWFXeHNQU0lqT1VJNVFqbENJaTgrQ2p4d1lYUm9JR1E5SWsweU1UVXVOVGs1SURJeExqYzRNRE5JTWpJMExqTTNNa3d5TXpJdU16Z3lJREV6TGpnek16ZElNakUxTGpVNU9WWXlNUzQzT0RBeldpSWdabWxzYkQwaUl6bENPVUk1UWlJdlBnbzhjR0YwYUNCa1BTSk5NakEySURNekxqWXdORGRJTWpFeUxqWXhNVXd5TWpBdU5EazBJREkxTGpZMU9ESklNakEyVmpNekxqWXdORGRhSWlCbWFXeHNQU0lqT1VJNVFqbENJaTgrQ2p4d1lYUm9JR1E5SWsweU5EQXVNalkxSURVdU9UVXdPREZNTWpNMkxqRTVOeUF4TUM0d01UazBTREl4TUM0eU5UbFdNaTR3TnpJNE9FZ3lOREF1TWpZMVZqVXVPVFV3T0RGYUlpQm1hV3hzUFNJak9VSTVRamxDSWk4K0Nqd3ZjM1puUGdvPWAsXG4gICAgICAgICAgICB3aWR0aDogMTcwLFxuICAgICAgICAgICAgaGVpZ2h0OiAyNSxcbiAgICAgICAgICAgIHJpZ2h0OiAyNSxcbiAgICAgICAgICAgIGJvdHRvbTogNTAsXG4gICAgICAgICAgICBvcGFjaXR5OiAwLjdcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHNwZWNpYWxPdmVycmlkZXMgPSB7IC4uLmNoYXJ0LmNoYXJ0T3B0aW9ucy5zcGVjaWFsT3ZlcnJpZGVzIH07XG4gICAgY29uc3Qgb3B0aW9uc01ldGFkYXRhID0geyAuLi5jaGFydC5jaGFydE9wdGlvbnMub3B0aW9uTWV0YWRhdGEgfTtcbiAgICBpZiAob3B0cy53aWR0aCAhPSBudWxsICYmIG9wdHMuaGVpZ2h0ICE9IG51bGwpIHtcbiAgICAgIHNwZWNpYWxPdmVycmlkZXMub3ZlcnJpZGVEZXZpY2VQaXhlbFJhdGlvID0gMTtcbiAgICB9XG4gICAgY29uc3QgY2xvbmVQcm94eSA9IGF3YWl0IHRoaXMuZmFjdG9yeUFwaS5jcmVhdGUoXG4gICAgICB1c2VyT3B0aW9ucyxcbiAgICAgIHByb2Nlc3NlZE92ZXJyaWRlcyxcbiAgICAgIHNwZWNpYWxPdmVycmlkZXMsXG4gICAgICBvcHRpb25zTWV0YWRhdGFcbiAgICApO1xuICAgIGF3YWl0IGNsb25lUHJveHkuc2V0U3RhdGUoc3RhdGUpO1xuICAgIGNsb25lUHJveHkuY2hhcnQuY3R4Lnpvb21NYW5hZ2VyLnVwZGF0ZVpvb20oXCJjaGFydFByb3h5XCIsIGNoYXJ0LmN0eC56b29tTWFuYWdlci5nZXRab29tKCkpO1xuICAgIGNoYXJ0LnNlcmllcy5mb3JFYWNoKChzZXJpZXMsIGluZGV4KSA9PiB7XG4gICAgICBpZiAoIXNlcmllcy52aXNpYmxlKSB7XG4gICAgICAgIGNsb25lUHJveHkuY2hhcnQuc2VyaWVzW2luZGV4XS52aXNpYmxlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY2xvbmVQcm94eS5jaGFydC51cGRhdGUoMCAvKiBGVUxMICovLCB7IGZvcmNlTm9kZURhdGFSZWZyZXNoOiB0cnVlIH0pO1xuICAgIGF3YWl0IGNsb25lUHJveHkud2FpdEZvclVwZGF0ZSgpO1xuICAgIHJldHVybiBjbG9uZVByb3h5O1xuICB9XG59O1xuX0FnQ2hhcnRJbnN0YW5jZVByb3h5LmNoYXJ0SW5zdGFuY2VzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBBY3Rpb25PblNldCh7XG4gICAgb2xkVmFsdWUoY2hhcnQpIHtcbiAgICAgIGlmICghY2hhcnQuZGVzdHJveWVkKSB7XG4gICAgICAgIGNoYXJ0LnB1YmxpY0FwaSA9IHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIF9BZ0NoYXJ0SW5zdGFuY2VQcm94eS5jaGFydEluc3RhbmNlcy5kZWxldGUoY2hhcnQpO1xuICAgIH0sXG4gICAgbmV3VmFsdWUoY2hhcnQpIHtcbiAgICAgIGNoYXJ0LnB1YmxpY0FwaSA9IHRoaXM7XG4gICAgICBfQWdDaGFydEluc3RhbmNlUHJveHkuY2hhcnRJbnN0YW5jZXMuc2V0KGNoYXJ0LCB0aGlzKTtcbiAgICB9XG4gIH0pXG5dLCBfQWdDaGFydEluc3RhbmNlUHJveHkucHJvdG90eXBlLCBcImNoYXJ0XCIsIDIpO1xudmFyIEFnQ2hhcnRJbnN0YW5jZVByb3h5ID0gX0FnQ2hhcnRJbnN0YW5jZVByb3h5O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9sb2NhbGUvbG9jYWxlLnRzXG52YXIgTG9jYWxlID0gY2xhc3MgZXh0ZW5kcyBCYXNlTW9kdWxlSW5zdGFuY2Uge1xuICBjb25zdHJ1Y3RvcihjdHgpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMubG9jYWxlVGV4dCA9IHZvaWQgMDtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIE9ic2VydmVDaGFuZ2VzKCh0YXJnZXQpID0+IHtcbiAgICB0YXJnZXQuY3R4LmxvY2FsZU1hbmFnZXIuc2V0TG9jYWxlVGV4dCh0YXJnZXQubG9jYWxlVGV4dCk7XG4gIH0pLFxuICBWYWxpZGF0ZShQTEFJTl9PQkpFQ1QsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIExvY2FsZS5wcm90b3R5cGUsIFwibG9jYWxlVGV4dFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIE9ic2VydmVDaGFuZ2VzKCh0YXJnZXQpID0+IHtcbiAgICB0YXJnZXQuY3R4LmxvY2FsZU1hbmFnZXIuc2V0TG9jYWxlVGV4dEZvcm1hdHRlcih0YXJnZXQuZ2V0TG9jYWxlVGV4dCk7XG4gIH0pLFxuICBWYWxpZGF0ZShGVU5DVElPTiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTG9jYWxlLnByb3RvdHlwZSwgXCJnZXRMb2NhbGVUZXh0XCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9sb2NhbGUvbG9jYWxlTW9kdWxlLnRzXG52YXIgTG9jYWxlTW9kdWxlID0ge1xuICB0eXBlOiBcInJvb3RcIixcbiAgb3B0aW9uc0tleTogXCJsb2NhbGVcIixcbiAgcGFja2FnZVR5cGU6IFwiY29tbXVuaXR5XCIsXG4gIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiLCBcInBvbGFyXCIsIFwiaGllcmFyY2h5XCIsIFwidG9wb2xvZ3lcIiwgXCJmbG93LXByb3BvcnRpb25cIiwgXCJzdGFuZGFsb25lXCIsIFwiZ2F1Z2VcIl0sXG4gIG1vZHVsZUZhY3Rvcnk6IChjdHgpID0+IG5ldyBMb2NhbGUoY3R4KVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NhbGUvbGluZWFyU2NhbGUudHNcbnZhciBMaW5lYXJTY2FsZSA9IGNsYXNzIGV4dGVuZHMgQ29udGludW91c1NjYWxlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoWzAsIDFdLCBbMCwgMV0pO1xuICAgIHRoaXMudHlwZSA9IFwibnVtYmVyXCI7XG4gIH1cbiAgdG9Eb21haW4oZCkge1xuICAgIHJldHVybiBkO1xuICB9XG4gIHRpY2tzKCkge1xuICAgIGNvbnN0IGNvdW50ID0gdGhpcy50aWNrQ291bnQgPz8gQ29udGludW91c1NjYWxlLmRlZmF1bHRUaWNrQ291bnQ7XG4gICAgaWYgKCF0aGlzLmRvbWFpbiB8fCB0aGlzLmRvbWFpbi5sZW5ndGggPCAyIHx8IGNvdW50IDwgMSB8fCAhdGhpcy5kb21haW4uZXZlcnkoaXNGaW5pdGUpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIGNvbnN0IFtkMCwgZDFdID0gdGhpcy5nZXREb21haW4oKTtcbiAgICBpZiAodGhpcy5pbnRlcnZhbCkge1xuICAgICAgY29uc3Qgc3RlcCA9IE1hdGguYWJzKHRoaXMuaW50ZXJ2YWwpO1xuICAgICAgaWYgKCFpc0RlbnNlSW50ZXJ2YWwoKGQxIC0gZDApIC8gc3RlcCwgdGhpcy5nZXRQaXhlbFJhbmdlKCkpKSB7XG4gICAgICAgIHJldHVybiByYW5nZShkMCwgZDEsIHN0ZXApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlVGlja3MoZDAsIGQxLCBjb3VudCwgdGhpcy5taW5UaWNrQ291bnQsIHRoaXMubWF4VGlja0NvdW50KTtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgaWYgKCF0aGlzLmRvbWFpbiB8fCB0aGlzLmRvbWFpbi5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLm5pY2UpIHtcbiAgICAgIHRoaXMudXBkYXRlTmljZURvbWFpbigpO1xuICAgIH1cbiAgfVxuICBnZXRUaWNrU3RlcChzdGFydDIsIHN0b3ApIHtcbiAgICByZXR1cm4gdGhpcy5pbnRlcnZhbCA/PyB0aWNrU3RlcChzdGFydDIsIHN0b3AsIHRoaXMudGlja0NvdW50LCB0aGlzLm1pblRpY2tDb3VudCwgdGhpcy5tYXhUaWNrQ291bnQpO1xuICB9XG4gIC8qKlxuICAgKiBFeHRlbmRzIHRoZSBkb21haW4gc28gdGhhdCBpdCBzdGFydHMgYW5kIGVuZHMgb24gbmljZSByb3VuZCB2YWx1ZXMuXG4gICAqL1xuICB1cGRhdGVOaWNlRG9tYWluKCkge1xuICAgIGNvbnN0IGNvdW50ID0gdGhpcy50aWNrQ291bnQ7XG4gICAgaWYgKGNvdW50IDwgMSkge1xuICAgICAgdGhpcy5uaWNlRG9tYWluID0gWy4uLnRoaXMuZG9tYWluXTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IFtzdGFydDIsIHN0b3BdID0gdGhpcy5kb21haW47XG4gICAgaWYgKGNvdW50ID09PSAxKSB7XG4gICAgICBbc3RhcnQyLCBzdG9wXSA9IG5pY2VUaWNrc0RvbWFpbihzdGFydDIsIHN0b3ApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByb3VuZFN0YXJ0ID0gc3RhcnQyID4gc3RvcCA/IE1hdGguY2VpbCA6IE1hdGguZmxvb3I7XG4gICAgICBjb25zdCByb3VuZFN0b3AgPSBzdG9wIDwgc3RhcnQyID8gTWF0aC5mbG9vciA6IE1hdGguY2VpbDtcbiAgICAgIGNvbnN0IG1heEF0dGVtcHRzID0gNDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4QXR0ZW1wdHM7IGkrKykge1xuICAgICAgICBjb25zdCBwcmV2MCA9IHN0YXJ0MjtcbiAgICAgICAgY29uc3QgcHJldjEgPSBzdG9wO1xuICAgICAgICBjb25zdCBzdGVwID0gdGhpcy5nZXRUaWNrU3RlcChzdGFydDIsIHN0b3ApO1xuICAgICAgICBjb25zdCBbZDAsIGQxXSA9IHRoaXMuZG9tYWluO1xuICAgICAgICBpZiAoc3RlcCA+PSAxKSB7XG4gICAgICAgICAgc3RhcnQyID0gcm91bmRTdGFydChkMCAvIHN0ZXApICogc3RlcDtcbiAgICAgICAgICBzdG9wID0gcm91bmRTdG9wKGQxIC8gc3RlcCkgKiBzdGVwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHMgPSAxIC8gc3RlcDtcbiAgICAgICAgICBzdGFydDIgPSByb3VuZFN0YXJ0KGQwICogcykgLyBzO1xuICAgICAgICAgIHN0b3AgPSByb3VuZFN0b3AoZDEgKiBzKSAvIHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0MiA9PT0gcHJldjAgJiYgc3RvcCA9PT0gcHJldjEpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm5pY2VEb21haW4gPSBbc3RhcnQyLCBzdG9wXTtcbiAgfVxuICB0aWNrRm9ybWF0KHsgdGlja3M6IHNwZWNpZmllZFRpY2tzLCBzcGVjaWZpZXIgfSkge1xuICAgIHJldHVybiB0aWNrRm9ybWF0KHNwZWNpZmllZFRpY2tzID8/IHRoaXMudGlja3MoKSwgc3BlY2lmaWVyKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9zZWNvbmRhcnlBeGlzVGlja3MudHNcbmZ1bmN0aW9uIGNhbGN1bGF0ZU5pY2VTZWNvbmRhcnlBeGlzKGRvbWFpbiwgcHJpbWFyeVRpY2tDb3VudCwgcmV2ZXJzZSkge1xuICBsZXQgW3N0YXJ0Miwgc3RvcF0gPSBmaW5kTWluTWF4KGRvbWFpbik7XG4gIHN0YXJ0MiA9IGNhbGN1bGF0ZU5pY2VTdGFydChNYXRoLmZsb29yKHN0YXJ0MiksIHN0b3AsIHByaW1hcnlUaWNrQ291bnQpO1xuICBjb25zdCBzdGVwID0gZ2V0VGlja1N0ZXAoc3RhcnQyLCBzdG9wLCBwcmltYXJ5VGlja0NvdW50KTtcbiAgY29uc3Qgc2VnbWVudHMgPSBwcmltYXJ5VGlja0NvdW50IC0gMTtcbiAgc3RvcCA9IHN0YXJ0MiArIHNlZ21lbnRzICogc3RlcDtcbiAgY29uc3QgZCA9IHJldmVyc2UgPyBbc3RvcCwgc3RhcnQyXSA6IFtzdGFydDIsIHN0b3BdO1xuICBjb25zdCB0aWNrcyA9IGdldFRpY2tzKHN0YXJ0Miwgc3RlcCwgcHJpbWFyeVRpY2tDb3VudCk7XG4gIHJldHVybiB7IGRvbWFpbjogZCwgdGlja3MgfTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZU5pY2VTdGFydChhLCBiLCBjb3VudCkge1xuICBjb25zdCByYXdTdGVwID0gTWF0aC5hYnMoYiAtIGEpIC8gKGNvdW50IC0gMSk7XG4gIGNvbnN0IG9yZGVyID0gTWF0aC5mbG9vcihNYXRoLmxvZzEwKHJhd1N0ZXApKTtcbiAgY29uc3QgbWFnbml0dWRlID0gTWF0aC5wb3coMTAsIG9yZGVyKTtcbiAgcmV0dXJuIE1hdGguZmxvb3IoYSAvIG1hZ25pdHVkZSkgKiBtYWduaXR1ZGU7XG59XG5mdW5jdGlvbiBnZXRUaWNrcyhzdGFydDIsIHN0ZXAsIGNvdW50KSB7XG4gIGNvbnN0IHN0ZXBQb3dlciA9IE1hdGguZmxvb3IoTWF0aC5sb2cxMChzdGVwKSk7XG4gIGNvbnN0IGZyYWN0aW9uRGlnaXRzID0gc3RlcCA+IDAgJiYgc3RlcCA8IDEgPyBNYXRoLmFicyhzdGVwUG93ZXIpIDogMDtcbiAgY29uc3QgZiA9IE1hdGgucG93KDEwLCBmcmFjdGlvbkRpZ2l0cyk7XG4gIGNvbnN0IHRpY2tzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgIGNvbnN0IHRpY2sgPSBzdGFydDIgKyBzdGVwICogaTtcbiAgICB0aWNrc1tpXSA9IE1hdGgucm91bmQodGljayAqIGYpIC8gZjtcbiAgfVxuICByZXR1cm4gdGlja3M7XG59XG5mdW5jdGlvbiBnZXRUaWNrU3RlcChzdGFydDIsIHN0b3AsIGNvdW50KSB7XG4gIGNvbnN0IHNlZ21lbnRzID0gY291bnQgLSAxO1xuICBjb25zdCByYXdTdGVwID0gKHN0b3AgLSBzdGFydDIpIC8gc2VnbWVudHM7XG4gIHJldHVybiBjYWxjdWxhdGVOZXh0TmljZVN0ZXAocmF3U3RlcCk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVOZXh0TmljZVN0ZXAocmF3U3RlcCkge1xuICBjb25zdCBvcmRlciA9IE1hdGguZmxvb3IoTWF0aC5sb2cxMChyYXdTdGVwKSk7XG4gIGNvbnN0IG1hZ25pdHVkZSA9IE1hdGgucG93KDEwLCBvcmRlcik7XG4gIGNvbnN0IHN0ZXAgPSByYXdTdGVwIC8gbWFnbml0dWRlICogMTA7XG4gIGlmIChzdGVwID4gMCAmJiBzdGVwIDw9IDEpIHtcbiAgICByZXR1cm4gbWFnbml0dWRlIC8gMTA7XG4gIH1cbiAgaWYgKHN0ZXAgPiAxICYmIHN0ZXAgPD0gMikge1xuICAgIHJldHVybiAyICogbWFnbml0dWRlIC8gMTA7XG4gIH1cbiAgaWYgKHN0ZXAgPiAxICYmIHN0ZXAgPD0gNSkge1xuICAgIHJldHVybiA1ICogbWFnbml0dWRlIC8gMTA7XG4gIH1cbiAgaWYgKHN0ZXAgPiA1ICYmIHN0ZXAgPD0gMTApIHtcbiAgICByZXR1cm4gMTAgKiBtYWduaXR1ZGUgLyAxMDtcbiAgfVxuICBpZiAoc3RlcCA+IDEwICYmIHN0ZXAgPD0gMjApIHtcbiAgICByZXR1cm4gMjAgKiBtYWduaXR1ZGUgLyAxMDtcbiAgfVxuICBpZiAoc3RlcCA+IDIwICYmIHN0ZXAgPD0gNDApIHtcbiAgICByZXR1cm4gNDAgKiBtYWduaXR1ZGUgLyAxMDtcbiAgfVxuICBpZiAoc3RlcCA+IDQwICYmIHN0ZXAgPD0gNTApIHtcbiAgICByZXR1cm4gNTAgKiBtYWduaXR1ZGUgLyAxMDtcbiAgfVxuICBpZiAoc3RlcCA+IDUwICYmIHN0ZXAgPD0gMTAwKSB7XG4gICAgcmV0dXJuIDEwMCAqIG1hZ25pdHVkZSAvIDEwO1xuICB9XG4gIHJldHVybiBzdGVwO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9heGlzL251bWJlckF4aXMudHNcbnZhciBOdW1iZXJBeGlzID0gY2xhc3MgZXh0ZW5kcyBDYXJ0ZXNpYW5BeGlzIHtcbiAgY29uc3RydWN0b3IobW9kdWxlQ3R4LCBzY2FsZTIgPSBuZXcgTGluZWFyU2NhbGUoKSkge1xuICAgIHN1cGVyKG1vZHVsZUN0eCwgc2NhbGUyKTtcbiAgICB0aGlzLm1pbiA9IE5hTjtcbiAgICB0aGlzLm1heCA9IE5hTjtcbiAgfVxuICBub3JtYWxpc2VEYXRhRG9tYWluKGQpIHtcbiAgICBjb25zdCB7IG1pbiwgbWF4IH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgZXh0ZW50OiBleHRlbnQyLCBjbGlwcGVkIH0gPSBub3JtYWxpc2VkRXh0ZW50V2l0aE1ldGFkYXRhKGQsIG1pbiwgbWF4KTtcbiAgICByZXR1cm4geyBkb21haW46IGV4dGVudDIsIGNsaXBwZWQgfTtcbiAgfVxuICB1cGRhdGVTZWNvbmRhcnlBeGlzVGlja3MocHJpbWFyeVRpY2tDb3VudCkge1xuICAgIGlmICh0aGlzLmRhdGFEb21haW4gPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQUcgQ2hhcnRzIC0gZGF0YURvbWFpbiBub3QgY2FsY3VsYXRlZCwgY2Fubm90IHBlcmZvcm0gdGljayBjYWxjdWxhdGlvbi5cIik7XG4gICAgfVxuICAgIGlmICh0aGlzLmRhdGFEb21haW4uZG9tYWluLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCB7IGRvbWFpbiwgdGlja3MgfSA9IGNhbGN1bGF0ZU5pY2VTZWNvbmRhcnlBeGlzKFxuICAgICAgdGhpcy5kYXRhRG9tYWluLmRvbWFpbixcbiAgICAgIHByaW1hcnlUaWNrQ291bnQgPz8gMCxcbiAgICAgIHRoaXMucmV2ZXJzZVxuICAgICk7XG4gICAgdGhpcy5zY2FsZS5uaWNlID0gZmFsc2U7XG4gICAgdGhpcy5zY2FsZS5kb21haW4gPSBkb21haW47XG4gICAgdGhpcy5zY2FsZS51cGRhdGUoKTtcbiAgICByZXR1cm4gdGlja3M7XG4gIH1cbn07XG5OdW1iZXJBeGlzLmNsYXNzTmFtZSA9IFwiTnVtYmVyQXhpc1wiO1xuTnVtYmVyQXhpcy50eXBlID0gXCJudW1iZXJcIjtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEFORChOVU1CRVJfT1JfTkFOLCBMRVNTX1RIQU4oXCJtYXhcIikpKSxcbiAgRGVmYXVsdChOYU4pXG5dLCBOdW1iZXJBeGlzLnByb3RvdHlwZSwgXCJtaW5cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShBTkQoTlVNQkVSX09SX05BTiwgR1JFQVRFUl9USEFOKFwibWluXCIpKSksXG4gIERlZmF1bHQoTmFOKVxuXSwgTnVtYmVyQXhpcy5wcm90b3R5cGUsIFwibWF4XCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9heGlzL2xvZ0F4aXMudHNcbnZhciBOT05fWkVST19OVU1CRVIgPSBwcmVkaWNhdGVXaXRoTWVzc2FnZSgodmFsdWUpID0+IGlzTnVtYmVyKHZhbHVlKSAmJiB2YWx1ZSAhPT0gMCwgXCJhIG5vbi16ZXJvIG51bWJlclwiKTtcbnZhciBMb2dBeGlzID0gY2xhc3MgZXh0ZW5kcyBOdW1iZXJBeGlzIHtcbiAgY29uc3RydWN0b3IobW9kdWxlQ3R4KSB7XG4gICAgc3VwZXIobW9kdWxlQ3R4LCBuZXcgTG9nU2NhbGUoKSk7XG4gICAgdGhpcy5taW4gPSBOYU47XG4gICAgdGhpcy5tYXggPSBOYU47XG4gIH1cbiAgbm9ybWFsaXNlRGF0YURvbWFpbihkKSB7XG4gICAgY29uc3QgeyBtaW4sIG1heCB9ID0gdGhpcztcbiAgICBjb25zdCB7IGV4dGVudDogZXh0ZW50MiwgY2xpcHBlZCB9ID0gbm9ybWFsaXNlZEV4dGVudFdpdGhNZXRhZGF0YShkLCBtaW4sIG1heCk7XG4gICAgY29uc3QgaXNJbnZlcnRlZCA9IGV4dGVudDJbMF0gPiBleHRlbnQyWzFdO1xuICAgIGNvbnN0IGNyb3NzZXNaZXJvID0gZXh0ZW50MlswXSA8IDAgJiYgZXh0ZW50MlsxXSA+IDA7XG4gICAgY29uc3QgaGFzWmVyb0V4dGVudCA9IGV4dGVudDJbMF0gPT09IDAgJiYgZXh0ZW50MlsxXSA9PT0gMDtcbiAgICBjb25zdCBpbnZhbGlkRG9tYWluID0gaXNJbnZlcnRlZCB8fCBjcm9zc2VzWmVybyB8fCBoYXNaZXJvRXh0ZW50O1xuICAgIGlmIChpbnZhbGlkRG9tYWluKSB7XG4gICAgICBpZiAoY3Jvc3Nlc1plcm8pIHtcbiAgICAgICAgTG9nZ2VyLndhcm4oXG4gICAgICAgICAgYHRoZSBkYXRhIGRvbWFpbiBjcm9zc2VzIHplcm8sIHRoZSBjaGFydCBkYXRhIGNhbm5vdCBiZSByZW5kZXJlZC4gU2VlIGxvZyBheGlzIGRvY3VtZW50YXRpb24gZm9yIG1vcmUgaW5mb3JtYXRpb24uYFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmIChoYXNaZXJvRXh0ZW50KSB7XG4gICAgICAgIExvZ2dlci53YXJuKGB0aGUgZGF0YSBkb21haW4gaGFzIDAgZXh0ZW50LCBubyBkYXRhIGlzIHJlbmRlcmVkLmApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZXh0ZW50MlswXSA9PT0gMCkge1xuICAgICAgZXh0ZW50MlswXSA9IDE7XG4gICAgfVxuICAgIGlmIChleHRlbnQyWzFdID09PSAwKSB7XG4gICAgICBleHRlbnQyWzFdID0gLTE7XG4gICAgfVxuICAgIHJldHVybiB7IGRvbWFpbjogZXh0ZW50MiwgY2xpcHBlZCB9O1xuICB9XG4gIHNldCBiYXNlKHZhbHVlKSB7XG4gICAgdGhpcy5zY2FsZS5iYXNlID0gdmFsdWU7XG4gIH1cbiAgZ2V0IGJhc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NhbGUuYmFzZTtcbiAgfVxufTtcbkxvZ0F4aXMuY2xhc3NOYW1lID0gXCJMb2dBeGlzXCI7XG5Mb2dBeGlzLnR5cGUgPSBcImxvZ1wiO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQU5EKE5VTUJFUl9PUl9OQU4sIE5PTl9aRVJPX05VTUJFUiwgTEVTU19USEFOKFwibWF4XCIpKSksXG4gIERlZmF1bHQoTmFOKVxuXSwgTG9nQXhpcy5wcm90b3R5cGUsIFwibWluXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQU5EKE5VTUJFUl9PUl9OQU4sIE5PTl9aRVJPX05VTUJFUiwgR1JFQVRFUl9USEFOKFwibWluXCIpKSksXG4gIERlZmF1bHQoTmFOKVxuXSwgTG9nQXhpcy5wcm90b3R5cGUsIFwibWF4XCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9heGlzL3RpbWVBeGlzLnRzXG52YXIgVGltZUF4aXMgPSBjbGFzcyBleHRlbmRzIENhcnRlc2lhbkF4aXMge1xuICBjb25zdHJ1Y3Rvcihtb2R1bGVDdHgpIHtcbiAgICBzdXBlcihtb2R1bGVDdHgsIG5ldyBUaW1lU2NhbGUoKSk7XG4gICAgdGhpcy5taW4gPSB2b2lkIDA7XG4gICAgdGhpcy5tYXggPSB2b2lkIDA7XG4gIH1cbiAgbm9ybWFsaXNlRGF0YURvbWFpbihkKSB7XG4gICAgbGV0IHsgbWluLCBtYXggfSA9IHRoaXM7XG4gICAgbGV0IGNsaXBwZWQgPSBmYWxzZTtcbiAgICBpZiAodHlwZW9mIG1pbiA9PT0gXCJudW1iZXJcIikge1xuICAgICAgbWluID0gbmV3IERhdGUobWluKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBtYXggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIG1heCA9IG5ldyBEYXRlKG1heCk7XG4gICAgfVxuICAgIGlmIChkLmxlbmd0aCA+IDIpIHtcbiAgICAgIGQgPSBleHRlbnQoZCk/Lm1hcCgoeCkgPT4gbmV3IERhdGUoeCkpID8/IFtdO1xuICAgIH1cbiAgICBpZiAobWluIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgY2xpcHBlZCB8fCAoY2xpcHBlZCA9IG1pbiA+IGRbMF0pO1xuICAgICAgZCA9IFttaW4sIGRbMV1dO1xuICAgIH1cbiAgICBpZiAobWF4IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgY2xpcHBlZCB8fCAoY2xpcHBlZCA9IG1heCA8IGRbMV0pO1xuICAgICAgZCA9IFtkWzBdLCBtYXhdO1xuICAgIH1cbiAgICBpZiAoZFswXSA+IGRbMV0pIHtcbiAgICAgIGQgPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZG9tYWluOiBkLCBjbGlwcGVkIH07XG4gIH1cbiAgb25Gb3JtYXRDaGFuZ2UodGlja3MsIGZyYWN0aW9uRGlnaXRzLCBkb21haW4sIGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQpIHtcbiAgICAgIHN1cGVyLm9uRm9ybWF0Q2hhbmdlKHRpY2tzLCBmcmFjdGlvbkRpZ2l0cywgZG9tYWluLCBmb3JtYXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxhYmVsRm9ybWF0dGVyID0gdGhpcy5zY2FsZS50aWNrRm9ybWF0KHsgdGlja3MsIGRvbWFpbiB9KTtcbiAgICAgIHRoaXMuZGF0dW1Gb3JtYXR0ZXIgPSB0aGlzLnNjYWxlLnRpY2tGb3JtYXQoeyB0aWNrcywgZG9tYWluLCBmb3JtYXRPZmZzZXQ6IDEgfSk7XG4gICAgfVxuICB9XG59O1xuVGltZUF4aXMuY2xhc3NOYW1lID0gXCJUaW1lQXhpc1wiO1xuVGltZUF4aXMudHlwZSA9IFwidGltZVwiO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQU5EKERBVEVfT1JfREFURVRJTUVfTVMsIExFU1NfVEhBTihcIm1heFwiKSksIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFRpbWVBeGlzLnByb3RvdHlwZSwgXCJtaW5cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShBTkQoREFURV9PUl9EQVRFVElNRV9NUywgR1JFQVRFUl9USEFOKFwibWluXCIpKSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgVGltZUF4aXMucHJvdG90eXBlLCBcIm1heFwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvdXRpbC9jb3JuZXIudHNcbnZhciBkcmF3Q29ybmVyID0gKHBhdGgsIHsgeDAsIHkwLCB4MSwgeTEsIGN4LCBjeSB9LCBjb3JuZXJSYWRpdXMsIG1vdmUpID0+IHtcbiAgaWYgKG1vdmUpIHtcbiAgICBwYXRoLm1vdmVUbyh4MCwgeTApO1xuICB9XG4gIGlmICh4MCAhPT0geDEgfHwgeTAgIT09IHkxKSB7XG4gICAgY29uc3QgcjAgPSBNYXRoLmF0YW4yKHkwIC0gY3ksIHgwIC0gY3gpO1xuICAgIGNvbnN0IHIxID0gTWF0aC5hdGFuMih5MSAtIGN5LCB4MSAtIGN4KTtcbiAgICBwYXRoLmFyYyhjeCwgY3ksIGNvcm5lclJhZGl1cywgcjAsIHIxKTtcbiAgfSBlbHNlIHtcbiAgICBwYXRoLmxpbmVUbyh4MCwgeTApO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9zaGFwZS9yZWN0LnRzXG52YXIgZXBzaWxvbiA9IDFlLTY7XG52YXIgY29ybmVyRWRnZXMgPSAobGVhZGluZ0VkZ2UsIHRyYWlsaW5nRWRnZSwgbGVhZGluZ0luc2V0LCB0cmFpbGluZ0luc2V0LCBjb3JuZXJSYWRpdXMpID0+IHtcbiAgbGV0IGxlYWRpbmdDbGlwcGVkID0gZmFsc2U7XG4gIGxldCB0cmFpbGluZ0NsaXBwZWQgPSBmYWxzZTtcbiAgbGV0IGxlYWRpbmcwID0gdHJhaWxpbmdJbnNldCAtIE1hdGguc3FydChNYXRoLm1heChjb3JuZXJSYWRpdXMgKiogMiAtIGxlYWRpbmdJbnNldCAqKiAyLCAwKSk7XG4gIGxldCBsZWFkaW5nMSA9IDA7XG4gIGxldCB0cmFpbGluZzAgPSAwO1xuICBsZXQgdHJhaWxpbmcxID0gbGVhZGluZ0luc2V0IC0gTWF0aC5zcXJ0KE1hdGgubWF4KGNvcm5lclJhZGl1cyAqKiAyIC0gdHJhaWxpbmdJbnNldCAqKiAyLCAwKSk7XG4gIGlmIChsZWFkaW5nMCA+IGxlYWRpbmdFZGdlKSB7XG4gICAgbGVhZGluZ0NsaXBwZWQgPSB0cnVlO1xuICAgIGxlYWRpbmcwID0gbGVhZGluZ0VkZ2U7XG4gICAgbGVhZGluZzEgPSBsZWFkaW5nSW5zZXQgLSBNYXRoLnNxcnQoTWF0aC5tYXgoY29ybmVyUmFkaXVzICoqIDIgLSAodHJhaWxpbmdJbnNldCAtIGxlYWRpbmdFZGdlKSAqKiAyKSk7XG4gIH0gZWxzZSBpZiAobGVhZGluZzAgPCBlcHNpbG9uKSB7XG4gICAgbGVhZGluZzAgPSAwO1xuICB9XG4gIGlmICh0cmFpbGluZzEgPiB0cmFpbGluZ0VkZ2UpIHtcbiAgICB0cmFpbGluZ0NsaXBwZWQgPSB0cnVlO1xuICAgIHRyYWlsaW5nMCA9IHRyYWlsaW5nSW5zZXQgLSBNYXRoLnNxcnQoTWF0aC5tYXgoY29ybmVyUmFkaXVzICoqIDIgLSAobGVhZGluZ0luc2V0IC0gdHJhaWxpbmdFZGdlKSAqKiAyKSk7XG4gICAgdHJhaWxpbmcxID0gdHJhaWxpbmdFZGdlO1xuICB9IGVsc2UgaWYgKHRyYWlsaW5nMSA8IGVwc2lsb24pIHtcbiAgICB0cmFpbGluZzEgPSAwO1xuICB9XG4gIHJldHVybiB7IGxlYWRpbmcwLCBsZWFkaW5nMSwgdHJhaWxpbmcwLCB0cmFpbGluZzEsIGxlYWRpbmdDbGlwcGVkLCB0cmFpbGluZ0NsaXBwZWQgfTtcbn07XG52YXIgaW5zZXRDb3JuZXJSYWRpdXNSZWN0ID0gKHBhdGgsIHgsIHksIHdpZHRoMiwgaGVpZ2h0MiwgY29ybmVyUmFkaWksIGNsaXBCQm94KSA9PiB7XG4gIGxldCB7XG4gICAgdG9wTGVmdDogdG9wTGVmdENvcm5lclJhZGl1cyxcbiAgICB0b3BSaWdodDogdG9wUmlnaHRDb3JuZXJSYWRpdXMsXG4gICAgYm90dG9tUmlnaHQ6IGJvdHRvbVJpZ2h0Q29ybmVyUmFkaXVzLFxuICAgIGJvdHRvbUxlZnQ6IGJvdHRvbUxlZnRDb3JuZXJSYWRpdXNcbiAgfSA9IGNvcm5lclJhZGlpO1xuICBjb25zdCBtYXhWZXJ0aWNhbENvcm5lclJhZGl1cyA9IE1hdGgubWF4KFxuICAgIHRvcExlZnRDb3JuZXJSYWRpdXMgKyBib3R0b21MZWZ0Q29ybmVyUmFkaXVzLFxuICAgIHRvcFJpZ2h0Q29ybmVyUmFkaXVzICsgYm90dG9tUmlnaHRDb3JuZXJSYWRpdXNcbiAgKTtcbiAgY29uc3QgbWF4SG9yaXpvbnRhbENvcm5lclJhZGl1cyA9IE1hdGgubWF4KFxuICAgIHRvcExlZnRDb3JuZXJSYWRpdXMgKyB0b3BSaWdodENvcm5lclJhZGl1cyxcbiAgICBib3R0b21MZWZ0Q29ybmVyUmFkaXVzICsgYm90dG9tUmlnaHRDb3JuZXJSYWRpdXNcbiAgKTtcbiAgaWYgKG1heFZlcnRpY2FsQ29ybmVyUmFkaXVzIDw9IDAgJiYgbWF4SG9yaXpvbnRhbENvcm5lclJhZGl1cyA8PSAwKSB7XG4gICAgaWYgKGNsaXBCQm94ID09IG51bGwpIHtcbiAgICAgIHBhdGgucmVjdCh4LCB5LCB3aWR0aDIsIGhlaWdodDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRoLnJlY3QoY2xpcEJCb3gueCwgY2xpcEJCb3gueSwgY2xpcEJCb3gud2lkdGgsIGNsaXBCQm94LmhlaWdodCk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmIChjbGlwQkJveCA9PSBudWxsICYmIHRvcExlZnRDb3JuZXJSYWRpdXMgPT09IHRvcFJpZ2h0Q29ybmVyUmFkaXVzICYmIHRvcExlZnRDb3JuZXJSYWRpdXMgPT09IGJvdHRvbVJpZ2h0Q29ybmVyUmFkaXVzICYmIHRvcExlZnRDb3JuZXJSYWRpdXMgPT09IGJvdHRvbUxlZnRDb3JuZXJSYWRpdXMpIHtcbiAgICBwYXRoLnJvdW5kUmVjdCh4LCB5LCB3aWR0aDIsIGhlaWdodDIsIHRvcExlZnRDb3JuZXJSYWRpdXMpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAod2lkdGgyIDwgMCkge1xuICAgIHggKz0gd2lkdGgyO1xuICAgIHdpZHRoMiA9IE1hdGguYWJzKHdpZHRoMik7XG4gIH1cbiAgaWYgKGhlaWdodDIgPCAwKSB7XG4gICAgeSArPSBoZWlnaHQyO1xuICAgIGhlaWdodDIgPSBNYXRoLmFicyhoZWlnaHQyKTtcbiAgfVxuICBpZiAod2lkdGgyIDw9IDAgfHwgaGVpZ2h0MiA8PSAwKVxuICAgIHJldHVybjtcbiAgaWYgKGNsaXBCQm94ID09IG51bGwpIHtcbiAgICBjbGlwQkJveCA9IG5ldyBCQm94KHgsIHksIHdpZHRoMiwgaGVpZ2h0Mik7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgeDAgPSBNYXRoLm1heCh4LCBjbGlwQkJveC54KTtcbiAgICBjb25zdCB4MSA9IE1hdGgubWluKHggKyB3aWR0aDIsIGNsaXBCQm94LnggKyBjbGlwQkJveC53aWR0aCk7XG4gICAgY29uc3QgeTAgPSBNYXRoLm1heCh5LCBjbGlwQkJveC55KTtcbiAgICBjb25zdCB5MSA9IE1hdGgubWluKHkgKyBoZWlnaHQyLCBjbGlwQkJveC55ICsgY2xpcEJCb3guaGVpZ2h0KTtcbiAgICBjbGlwQkJveCA9IG5ldyBCQm94KHgwLCB5MCwgeDEgLSB4MCwgeTEgLSB5MCk7XG4gIH1cbiAgY29uc3QgYm9yZGVyU2NhbGUgPSBNYXRoLm1heChtYXhWZXJ0aWNhbENvcm5lclJhZGl1cyAvIGhlaWdodDIsIG1heEhvcml6b250YWxDb3JuZXJSYWRpdXMgLyB3aWR0aDIsIDEpO1xuICBpZiAoYm9yZGVyU2NhbGUgPiAxKSB7XG4gICAgdG9wTGVmdENvcm5lclJhZGl1cyAvPSBib3JkZXJTY2FsZTtcbiAgICB0b3BSaWdodENvcm5lclJhZGl1cyAvPSBib3JkZXJTY2FsZTtcbiAgICBib3R0b21SaWdodENvcm5lclJhZGl1cyAvPSBib3JkZXJTY2FsZTtcbiAgICBib3R0b21MZWZ0Q29ybmVyUmFkaXVzIC89IGJvcmRlclNjYWxlO1xuICB9XG4gIGxldCBkcmF3VG9wTGVmdENvcm5lciA9IHRydWU7XG4gIGxldCBkcmF3VG9wUmlnaHRDb3JuZXIgPSB0cnVlO1xuICBsZXQgZHJhd0JvdHRvbVJpZ2h0Q29ybmVyID0gdHJ1ZTtcbiAgbGV0IGRyYXdCb3R0b21MZWZ0Q29ybmVyID0gdHJ1ZTtcbiAgbGV0IHRvcExlZnRDb3JuZXI7XG4gIGxldCB0b3BSaWdodENvcm5lcjtcbiAgbGV0IGJvdHRvbVJpZ2h0Q29ybmVyO1xuICBsZXQgYm90dG9tTGVmdENvcm5lcjtcbiAgaWYgKGRyYXdUb3BMZWZ0Q29ybmVyKSB7XG4gICAgY29uc3Qgbm9kZXMgPSBjb3JuZXJFZGdlcyhcbiAgICAgIGNsaXBCQm94LmhlaWdodCxcbiAgICAgIGNsaXBCQm94LndpZHRoLFxuICAgICAgTWF0aC5tYXgoeCArIHRvcExlZnRDb3JuZXJSYWRpdXMgLSBjbGlwQkJveC54LCAwKSxcbiAgICAgIE1hdGgubWF4KHkgKyB0b3BMZWZ0Q29ybmVyUmFkaXVzIC0gY2xpcEJCb3gueSwgMCksXG4gICAgICB0b3BMZWZ0Q29ybmVyUmFkaXVzXG4gICAgKTtcbiAgICBpZiAobm9kZXMubGVhZGluZ0NsaXBwZWQpXG4gICAgICBkcmF3Qm90dG9tTGVmdENvcm5lciA9IGZhbHNlO1xuICAgIGlmIChub2Rlcy50cmFpbGluZ0NsaXBwZWQpXG4gICAgICBkcmF3VG9wUmlnaHRDb3JuZXIgPSBmYWxzZTtcbiAgICBjb25zdCB4MCA9IE1hdGgubWF4KGNsaXBCQm94LnggKyBub2Rlcy5sZWFkaW5nMSwgY2xpcEJCb3gueCk7XG4gICAgY29uc3QgeTAgPSBNYXRoLm1heChjbGlwQkJveC55ICsgbm9kZXMubGVhZGluZzAsIGNsaXBCQm94LnkpO1xuICAgIGNvbnN0IHgxID0gTWF0aC5tYXgoY2xpcEJCb3gueCArIG5vZGVzLnRyYWlsaW5nMSwgY2xpcEJCb3gueCk7XG4gICAgY29uc3QgeTEgPSBNYXRoLm1heChjbGlwQkJveC55ICsgbm9kZXMudHJhaWxpbmcwLCBjbGlwQkJveC55KTtcbiAgICBjb25zdCBjeCA9IHggKyB0b3BMZWZ0Q29ybmVyUmFkaXVzO1xuICAgIGNvbnN0IGN5ID0geSArIHRvcExlZnRDb3JuZXJSYWRpdXM7XG4gICAgdG9wTGVmdENvcm5lciA9IHsgeDAsIHkwLCB4MSwgeTEsIGN4LCBjeSB9O1xuICB9XG4gIGlmIChkcmF3VG9wUmlnaHRDb3JuZXIpIHtcbiAgICBjb25zdCBub2RlcyA9IGNvcm5lckVkZ2VzKFxuICAgICAgY2xpcEJCb3gud2lkdGgsXG4gICAgICBjbGlwQkJveC5oZWlnaHQsXG4gICAgICBNYXRoLm1heCh5ICsgdG9wUmlnaHRDb3JuZXJSYWRpdXMgLSBjbGlwQkJveC55LCAwKSxcbiAgICAgIE1hdGgubWF4KGNsaXBCQm94LnggKyBjbGlwQkJveC53aWR0aCAtICh4ICsgd2lkdGgyIC0gdG9wUmlnaHRDb3JuZXJSYWRpdXMpLCAwKSxcbiAgICAgIHRvcFJpZ2h0Q29ybmVyUmFkaXVzXG4gICAgKTtcbiAgICBpZiAobm9kZXMubGVhZGluZ0NsaXBwZWQpXG4gICAgICBkcmF3VG9wTGVmdENvcm5lciA9IGZhbHNlO1xuICAgIGlmIChub2Rlcy50cmFpbGluZ0NsaXBwZWQpXG4gICAgICBkcmF3Qm90dG9tUmlnaHRDb3JuZXIgPSBmYWxzZTtcbiAgICBjb25zdCB4MCA9IE1hdGgubWluKGNsaXBCQm94LnggKyBjbGlwQkJveC53aWR0aCAtIG5vZGVzLmxlYWRpbmcwLCBjbGlwQkJveC54ICsgY2xpcEJCb3gud2lkdGgpO1xuICAgIGNvbnN0IHkwID0gTWF0aC5tYXgoY2xpcEJCb3gueSArIG5vZGVzLmxlYWRpbmcxLCBjbGlwQkJveC55KTtcbiAgICBjb25zdCB4MSA9IE1hdGgubWluKGNsaXBCQm94LnggKyBjbGlwQkJveC53aWR0aCAtIG5vZGVzLnRyYWlsaW5nMCwgY2xpcEJCb3gueCArIGNsaXBCQm94LndpZHRoKTtcbiAgICBjb25zdCB5MSA9IE1hdGgubWF4KGNsaXBCQm94LnkgKyBub2Rlcy50cmFpbGluZzEsIGNsaXBCQm94LnkpO1xuICAgIGNvbnN0IGN4ID0geCArIHdpZHRoMiAtIHRvcFJpZ2h0Q29ybmVyUmFkaXVzO1xuICAgIGNvbnN0IGN5ID0geSArIHRvcFJpZ2h0Q29ybmVyUmFkaXVzO1xuICAgIHRvcFJpZ2h0Q29ybmVyID0geyB4MCwgeTAsIHgxLCB5MSwgY3gsIGN5IH07XG4gIH1cbiAgaWYgKGRyYXdCb3R0b21SaWdodENvcm5lcikge1xuICAgIGNvbnN0IG5vZGVzID0gY29ybmVyRWRnZXMoXG4gICAgICBjbGlwQkJveC5oZWlnaHQsXG4gICAgICBjbGlwQkJveC53aWR0aCxcbiAgICAgIE1hdGgubWF4KGNsaXBCQm94LnggKyBjbGlwQkJveC53aWR0aCAtICh4ICsgd2lkdGgyIC0gYm90dG9tUmlnaHRDb3JuZXJSYWRpdXMpLCAwKSxcbiAgICAgIE1hdGgubWF4KGNsaXBCQm94LnkgKyBjbGlwQkJveC5oZWlnaHQgLSAoeSArIGhlaWdodDIgLSBib3R0b21SaWdodENvcm5lclJhZGl1cyksIDApLFxuICAgICAgYm90dG9tUmlnaHRDb3JuZXJSYWRpdXNcbiAgICApO1xuICAgIGlmIChub2Rlcy5sZWFkaW5nQ2xpcHBlZClcbiAgICAgIGRyYXdUb3BSaWdodENvcm5lciA9IGZhbHNlO1xuICAgIGlmIChub2Rlcy50cmFpbGluZ0NsaXBwZWQpXG4gICAgICBkcmF3Qm90dG9tTGVmdENvcm5lciA9IGZhbHNlO1xuICAgIGNvbnN0IHgwID0gTWF0aC5taW4oY2xpcEJCb3gueCArIGNsaXBCQm94LndpZHRoIC0gbm9kZXMubGVhZGluZzEsIGNsaXBCQm94LnggKyBjbGlwQkJveC53aWR0aCk7XG4gICAgY29uc3QgeTAgPSBNYXRoLm1pbihjbGlwQkJveC55ICsgY2xpcEJCb3guaGVpZ2h0IC0gbm9kZXMubGVhZGluZzAsIGNsaXBCQm94LnkgKyBjbGlwQkJveC5oZWlnaHQpO1xuICAgIGNvbnN0IHgxID0gTWF0aC5taW4oY2xpcEJCb3gueCArIGNsaXBCQm94LndpZHRoIC0gbm9kZXMudHJhaWxpbmcxLCBjbGlwQkJveC54ICsgY2xpcEJCb3gud2lkdGgpO1xuICAgIGNvbnN0IHkxID0gTWF0aC5taW4oY2xpcEJCb3gueSArIGNsaXBCQm94LmhlaWdodCAtIG5vZGVzLnRyYWlsaW5nMCwgY2xpcEJCb3gueSArIGNsaXBCQm94LmhlaWdodCk7XG4gICAgY29uc3QgY3ggPSB4ICsgd2lkdGgyIC0gYm90dG9tUmlnaHRDb3JuZXJSYWRpdXM7XG4gICAgY29uc3QgY3kgPSB5ICsgaGVpZ2h0MiAtIGJvdHRvbVJpZ2h0Q29ybmVyUmFkaXVzO1xuICAgIGJvdHRvbVJpZ2h0Q29ybmVyID0geyB4MCwgeTAsIHgxLCB5MSwgY3gsIGN5IH07XG4gIH1cbiAgaWYgKGRyYXdCb3R0b21MZWZ0Q29ybmVyKSB7XG4gICAgY29uc3Qgbm9kZXMgPSBjb3JuZXJFZGdlcyhcbiAgICAgIGNsaXBCQm94LndpZHRoLFxuICAgICAgY2xpcEJCb3guaGVpZ2h0LFxuICAgICAgTWF0aC5tYXgoY2xpcEJCb3gueSArIGNsaXBCQm94LmhlaWdodCAtICh5ICsgaGVpZ2h0MiAtIGJvdHRvbUxlZnRDb3JuZXJSYWRpdXMpLCAwKSxcbiAgICAgIE1hdGgubWF4KHggKyBib3R0b21MZWZ0Q29ybmVyUmFkaXVzIC0gY2xpcEJCb3gueCwgMCksXG4gICAgICBib3R0b21MZWZ0Q29ybmVyUmFkaXVzXG4gICAgKTtcbiAgICBpZiAobm9kZXMubGVhZGluZ0NsaXBwZWQpXG4gICAgICBkcmF3Qm90dG9tUmlnaHRDb3JuZXIgPSBmYWxzZTtcbiAgICBpZiAobm9kZXMudHJhaWxpbmdDbGlwcGVkKVxuICAgICAgZHJhd1RvcExlZnRDb3JuZXIgPSBmYWxzZTtcbiAgICBjb25zdCB4MCA9IE1hdGgubWF4KGNsaXBCQm94LnggKyBub2Rlcy5sZWFkaW5nMCwgY2xpcEJCb3gueCk7XG4gICAgY29uc3QgeTAgPSBNYXRoLm1pbihjbGlwQkJveC55ICsgY2xpcEJCb3guaGVpZ2h0IC0gbm9kZXMubGVhZGluZzEsIGNsaXBCQm94LnkgKyBjbGlwQkJveC5oZWlnaHQpO1xuICAgIGNvbnN0IHgxID0gTWF0aC5tYXgoY2xpcEJCb3gueCArIG5vZGVzLnRyYWlsaW5nMCwgY2xpcEJCb3gueCk7XG4gICAgY29uc3QgeTEgPSBNYXRoLm1pbihjbGlwQkJveC55ICsgY2xpcEJCb3guaGVpZ2h0IC0gbm9kZXMudHJhaWxpbmcxLCBjbGlwQkJveC55ICsgY2xpcEJCb3guaGVpZ2h0KTtcbiAgICBjb25zdCBjeCA9IHggKyBib3R0b21MZWZ0Q29ybmVyUmFkaXVzO1xuICAgIGNvbnN0IGN5ID0geSArIGhlaWdodDIgLSBib3R0b21MZWZ0Q29ybmVyUmFkaXVzO1xuICAgIGJvdHRvbUxlZnRDb3JuZXIgPSB7IHgwLCB5MCwgeDEsIHkxLCBjeCwgY3kgfTtcbiAgfVxuICBsZXQgZGlkTW92ZSA9IGZhbHNlO1xuICBpZiAoZHJhd1RvcExlZnRDb3JuZXIgJiYgdG9wTGVmdENvcm5lciAhPSBudWxsKSB7XG4gICAgZHJhd0Nvcm5lcihwYXRoLCB0b3BMZWZ0Q29ybmVyLCB0b3BMZWZ0Q29ybmVyUmFkaXVzLCAhZGlkTW92ZSk7XG4gICAgZGlkTW92ZSB8fCAoZGlkTW92ZSA9IHRydWUpO1xuICB9XG4gIGlmIChkcmF3VG9wUmlnaHRDb3JuZXIgJiYgdG9wUmlnaHRDb3JuZXIgIT0gbnVsbCkge1xuICAgIGRyYXdDb3JuZXIocGF0aCwgdG9wUmlnaHRDb3JuZXIsIHRvcFJpZ2h0Q29ybmVyUmFkaXVzLCAhZGlkTW92ZSk7XG4gICAgZGlkTW92ZSB8fCAoZGlkTW92ZSA9IHRydWUpO1xuICB9XG4gIGlmIChkcmF3Qm90dG9tUmlnaHRDb3JuZXIgJiYgYm90dG9tUmlnaHRDb3JuZXIgIT0gbnVsbCkge1xuICAgIGRyYXdDb3JuZXIocGF0aCwgYm90dG9tUmlnaHRDb3JuZXIsIGJvdHRvbVJpZ2h0Q29ybmVyUmFkaXVzLCAhZGlkTW92ZSk7XG4gICAgZGlkTW92ZSB8fCAoZGlkTW92ZSA9IHRydWUpO1xuICB9XG4gIGlmIChkcmF3Qm90dG9tTGVmdENvcm5lciAmJiBib3R0b21MZWZ0Q29ybmVyICE9IG51bGwpIHtcbiAgICBkcmF3Q29ybmVyKHBhdGgsIGJvdHRvbUxlZnRDb3JuZXIsIGJvdHRvbUxlZnRDb3JuZXJSYWRpdXMsICFkaWRNb3ZlKTtcbiAgICBkaWRNb3ZlIHx8IChkaWRNb3ZlID0gdHJ1ZSk7XG4gIH1cbiAgcGF0aC5jbG9zZVBhdGgoKTtcbn07XG52YXIgUmVjdCA9IGNsYXNzIGV4dGVuZHMgUGF0aCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5ib3JkZXJQYXRoID0gbmV3IEV4dGVuZGVkUGF0aDJEKCk7XG4gICAgdGhpcy54ID0gMDtcbiAgICB0aGlzLnkgPSAwO1xuICAgIHRoaXMud2lkdGggPSAxMDtcbiAgICB0aGlzLmhlaWdodCA9IDEwO1xuICAgIHRoaXMudG9wTGVmdENvcm5lclJhZGl1cyA9IDA7XG4gICAgdGhpcy50b3BSaWdodENvcm5lclJhZGl1cyA9IDA7XG4gICAgdGhpcy5ib3R0b21SaWdodENvcm5lclJhZGl1cyA9IDA7XG4gICAgdGhpcy5ib3R0b21MZWZ0Q29ybmVyUmFkaXVzID0gMDtcbiAgICB0aGlzLmNsaXBCQm94ID0gdm9pZCAwO1xuICAgIHRoaXMuY3Jpc3AgPSBmYWxzZTtcbiAgICB0aGlzLmxhc3RVcGRhdGVQYXRoU3Ryb2tlV2lkdGggPSBTaGFwZS5kZWZhdWx0U3R5bGVzLnN0cm9rZVdpZHRoO1xuICAgIHRoaXMuZWZmZWN0aXZlU3Ryb2tlV2lkdGggPSBTaGFwZS5kZWZhdWx0U3R5bGVzLnN0cm9rZVdpZHRoO1xuICAgIHRoaXMuaGl0dGVzdGVyID0gc3VwZXIuaXNQb2ludEluUGF0aDtcbiAgICB0aGlzLmRpc3RhbmNlQ2FsY3VsYXRvciA9IHN1cGVyLmRpc3RhbmNlU3F1YXJlZFRyYW5zZm9ybWVkUG9pbnQ7XG4gICAgLyoqXG4gICAgICogV2hlbiB0aGUgcmVjdGFuZ2xlJ3Mgd2lkdGggb3IgaGVpZ2h0IGlzIGxlc3MgdGhhbiBhIHBpeGVsXG4gICAgICogYW5kIGNyaXNwIG1vZGUgaXMgb24sIHRoZSByZWN0YW5nbGUgd2lsbCBzdGlsbCBmaXQgaW50byB0aGUgcGl4ZWwsXG4gICAgICogYnV0IHdpbGwgYmUgbGVzcyBvcGFxdWUgdG8gbWFrZSBhbiBlZmZlY3Qgb2YgaG9sZGluZyBsZXNzIHNwYWNlLlxuICAgICAqL1xuICAgIHRoaXMubWljcm9QaXhlbEVmZmVjdE9wYWNpdHkgPSAxO1xuICB9XG4gIHNldCBjb3JuZXJSYWRpdXMoY29ybmVyUmFkaXVzKSB7XG4gICAgdGhpcy50b3BMZWZ0Q29ybmVyUmFkaXVzID0gY29ybmVyUmFkaXVzO1xuICAgIHRoaXMudG9wUmlnaHRDb3JuZXJSYWRpdXMgPSBjb3JuZXJSYWRpdXM7XG4gICAgdGhpcy5ib3R0b21SaWdodENvcm5lclJhZGl1cyA9IGNvcm5lclJhZGl1cztcbiAgICB0aGlzLmJvdHRvbUxlZnRDb3JuZXJSYWRpdXMgPSBjb3JuZXJSYWRpdXM7XG4gIH1cbiAgaXNEaXJ0eVBhdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMubGFzdFVwZGF0ZVBhdGhTdHJva2VXaWR0aCAhPT0gdGhpcy5zdHJva2VXaWR0aCB8fCBCb29sZWFuKHRoaXMucGF0aC5pc0RpcnR5KCkgfHwgdGhpcy5ib3JkZXJQYXRoLmlzRGlydHkoKSk7XG4gIH1cbiAgdXBkYXRlUGF0aCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBwYXRoLFxuICAgICAgYm9yZGVyUGF0aCxcbiAgICAgIGNyaXNwLFxuICAgICAgdG9wTGVmdENvcm5lclJhZGl1czogdG9wTGVmdCxcbiAgICAgIHRvcFJpZ2h0Q29ybmVyUmFkaXVzOiB0b3BSaWdodCxcbiAgICAgIGJvdHRvbVJpZ2h0Q29ybmVyUmFkaXVzOiBib3R0b21SaWdodCxcbiAgICAgIGJvdHRvbUxlZnRDb3JuZXJSYWRpdXM6IGJvdHRvbUxlZnRcbiAgICB9ID0gdGhpcztcbiAgICBsZXQgeyB4LCB5LCB3aWR0aDogdywgaGVpZ2h0OiBoLCBzdHJva2VXaWR0aCwgY2xpcEJCb3ggfSA9IHRoaXM7XG4gICAgY29uc3QgcGl4ZWxSYXRpbyA9IHRoaXMubGF5ZXJNYW5hZ2VyPy5jYW52YXMucGl4ZWxSYXRpbyA/PyAxO1xuICAgIGNvbnN0IHBpeGVsU2l6ZSA9IDEgLyBwaXhlbFJhdGlvO1xuICAgIGxldCBtaWNyb1BpeGVsRWZmZWN0T3BhY2l0eSA9IDE7XG4gICAgcGF0aC5jbGVhcih0cnVlKTtcbiAgICBib3JkZXJQYXRoLmNsZWFyKHRydWUpO1xuICAgIGlmIChjcmlzcCkge1xuICAgICAgaWYgKHcgPD0gcGl4ZWxTaXplKSB7XG4gICAgICAgIG1pY3JvUGl4ZWxFZmZlY3RPcGFjaXR5ICo9IHcgLyBwaXhlbFNpemU7XG4gICAgICB9XG4gICAgICBpZiAoaCA8PSBwaXhlbFNpemUpIHtcbiAgICAgICAgbWljcm9QaXhlbEVmZmVjdE9wYWNpdHkgKj0gaCAvIHBpeGVsU2l6ZTtcbiAgICAgIH1cbiAgICAgIHcgPSB0aGlzLmFsaWduKHgsIHcpO1xuICAgICAgaCA9IHRoaXMuYWxpZ24oeSwgaCk7XG4gICAgICB4ID0gdGhpcy5hbGlnbih4KTtcbiAgICAgIHkgPSB0aGlzLmFsaWduKHkpO1xuICAgICAgY2xpcEJCb3ggPSBjbGlwQkJveCAhPSBudWxsID8gbmV3IEJCb3goXG4gICAgICAgIHRoaXMuYWxpZ24oY2xpcEJCb3gueCksXG4gICAgICAgIHRoaXMuYWxpZ24oY2xpcEJCb3gueSksXG4gICAgICAgIHRoaXMuYWxpZ24oY2xpcEJCb3gueCwgY2xpcEJCb3gud2lkdGgpLFxuICAgICAgICB0aGlzLmFsaWduKGNsaXBCQm94LnksIGNsaXBCQm94LmhlaWdodClcbiAgICAgICkgOiB2b2lkIDA7XG4gICAgfVxuICAgIGlmIChzdHJva2VXaWR0aCkge1xuICAgICAgaWYgKHcgPCBwaXhlbFNpemUpIHtcbiAgICAgICAgY29uc3QgbHggPSB4ICsgcGl4ZWxTaXplIC8gMjtcbiAgICAgICAgYm9yZGVyUGF0aC5tb3ZlVG8obHgsIHkpO1xuICAgICAgICBib3JkZXJQYXRoLmxpbmVUbyhseCwgeSArIGgpO1xuICAgICAgICBzdHJva2VXaWR0aCA9IHBpeGVsU2l6ZTtcbiAgICAgICAgdGhpcy5ib3JkZXJDbGlwUGF0aCA9IHZvaWQgMDtcbiAgICAgIH0gZWxzZSBpZiAoaCA8IHBpeGVsU2l6ZSkge1xuICAgICAgICBjb25zdCBseSA9IHkgKyBwaXhlbFNpemUgLyAyO1xuICAgICAgICBib3JkZXJQYXRoLm1vdmVUbyh4LCBseSk7XG4gICAgICAgIGJvcmRlclBhdGgubGluZVRvKHggKyB3LCBseSk7XG4gICAgICAgIHN0cm9rZVdpZHRoID0gcGl4ZWxTaXplO1xuICAgICAgICB0aGlzLmJvcmRlckNsaXBQYXRoID0gdm9pZCAwO1xuICAgICAgfSBlbHNlIGlmIChzdHJva2VXaWR0aCA8IHcgJiYgc3Ryb2tlV2lkdGggPCBoKSB7XG4gICAgICAgIGNvbnN0IGhhbGZTdHJva2VXaWR0aCA9IHN0cm9rZVdpZHRoIC8gMjtcbiAgICAgICAgeCArPSBoYWxmU3Ryb2tlV2lkdGg7XG4gICAgICAgIHkgKz0gaGFsZlN0cm9rZVdpZHRoO1xuICAgICAgICB3IC09IHN0cm9rZVdpZHRoO1xuICAgICAgICBoIC09IHN0cm9rZVdpZHRoO1xuICAgICAgICBjb25zdCBhZGp1c3RlZENsaXBCQm94ID0gY2xpcEJCb3g/LmNsb25lKCkuc2hyaW5rKGhhbGZTdHJva2VXaWR0aCk7XG4gICAgICAgIGNvbnN0IGNvcm5lclJhZGlpID0ge1xuICAgICAgICAgIHRvcExlZnQ6IHRvcExlZnQgPiAwID8gdG9wTGVmdCAtIHN0cm9rZVdpZHRoIDogMCxcbiAgICAgICAgICB0b3BSaWdodDogdG9wUmlnaHQgPiAwID8gdG9wUmlnaHQgLSBzdHJva2VXaWR0aCA6IDAsXG4gICAgICAgICAgYm90dG9tUmlnaHQ6IGJvdHRvbVJpZ2h0ID4gMCA/IGJvdHRvbVJpZ2h0IC0gc3Ryb2tlV2lkdGggOiAwLFxuICAgICAgICAgIGJvdHRvbUxlZnQ6IGJvdHRvbUxlZnQgPiAwID8gYm90dG9tTGVmdCAtIHN0cm9rZVdpZHRoIDogMFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmJvcmRlckNsaXBQYXRoID0gdm9pZCAwO1xuICAgICAgICBpZiAodyA+IDAgJiYgaCA+IDAgJiYgKGFkanVzdGVkQ2xpcEJCb3ggPT0gbnVsbCB8fCBhZGp1c3RlZENsaXBCQm94Py53aWR0aCA+IDAgJiYgYWRqdXN0ZWRDbGlwQkJveD8uaGVpZ2h0ID4gMCkpIHtcbiAgICAgICAgICBpbnNldENvcm5lclJhZGl1c1JlY3QocGF0aCwgeCwgeSwgdywgaCwgY29ybmVyUmFkaWksIGFkanVzdGVkQ2xpcEJCb3gpO1xuICAgICAgICAgIGluc2V0Q29ybmVyUmFkaXVzUmVjdChib3JkZXJQYXRoLCB4LCB5LCB3LCBoLCBjb3JuZXJSYWRpaSwgYWRqdXN0ZWRDbGlwQkJveCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYm9yZGVyQ2xpcFBhdGggPSB0aGlzLmJvcmRlckNsaXBQYXRoID8/IG5ldyBFeHRlbmRlZFBhdGgyRCgpO1xuICAgICAgICB0aGlzLmJvcmRlckNsaXBQYXRoLmNsZWFyKHRydWUpO1xuICAgICAgICB0aGlzLmJvcmRlckNsaXBQYXRoLnJlY3QoeCwgeSwgdywgaCk7XG4gICAgICAgIGJvcmRlclBhdGgucmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY29ybmVyUmFkaWkgPSB7IHRvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21SaWdodCwgYm90dG9tTGVmdCB9O1xuICAgICAgdGhpcy5ib3JkZXJDbGlwUGF0aCA9IHZvaWQgMDtcbiAgICAgIGluc2V0Q29ybmVyUmFkaXVzUmVjdChwYXRoLCB4LCB5LCB3LCBoLCBjb3JuZXJSYWRpaSwgY2xpcEJCb3gpO1xuICAgIH1cbiAgICBpZiAoW3RvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21SaWdodCwgYm90dG9tTGVmdF0uZXZlcnkoKHIpID0+IHIgPT09IDApKSB7XG4gICAgICBjb25zdCBiYm94ID0gdGhpcy5nZXRCQm94KCk7XG4gICAgICB0aGlzLmhpdHRlc3RlciA9IGJib3guY29udGFpbnNQb2ludC5iaW5kKGJib3gpO1xuICAgICAgdGhpcy5kaXN0YW5jZVNxdWFyZWQgPSAoaGl0WCwgaGl0WSkgPT4gdGhpcy5nZXRCQm94KCkuZGlzdGFuY2VTcXVhcmVkKGhpdFgsIGhpdFkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhpdHRlc3RlciA9IHN1cGVyLmlzUG9pbnRJblBhdGg7XG4gICAgICB0aGlzLmRpc3RhbmNlQ2FsY3VsYXRvciA9IHN1cGVyLmRpc3RhbmNlU3F1YXJlZFRyYW5zZm9ybWVkUG9pbnQ7XG4gICAgfVxuICAgIHRoaXMuZWZmZWN0aXZlU3Ryb2tlV2lkdGggPSBzdHJva2VXaWR0aDtcbiAgICB0aGlzLmxhc3RVcGRhdGVQYXRoU3Ryb2tlV2lkdGggPSBzdHJva2VXaWR0aDtcbiAgICB0aGlzLm1pY3JvUGl4ZWxFZmZlY3RPcGFjaXR5ID0gbWljcm9QaXhlbEVmZmVjdE9wYWNpdHk7XG4gIH1cbiAgY29tcHV0ZUJCb3goKSB7XG4gICAgY29uc3QgeyB4LCB5LCB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIsIGNsaXBCQm94IH0gPSB0aGlzO1xuICAgIHJldHVybiBjbGlwQkJveD8uY2xvbmUoKSA/PyBuZXcgQkJveCh4LCB5LCB3aWR0aDIsIGhlaWdodDIpO1xuICB9XG4gIGlzUG9pbnRJblBhdGgoeCwgeSkge1xuICAgIHJldHVybiB0aGlzLmhpdHRlc3Rlcih4LCB5KTtcbiAgfVxuICBnZXQgbWlkUG9pbnQoKSB7XG4gICAgcmV0dXJuIHsgeDogdGhpcy54ICsgdGhpcy53aWR0aCAvIDIsIHk6IHRoaXMueSArIHRoaXMuaGVpZ2h0IC8gMiB9O1xuICB9XG4gIGRpc3RhbmNlU3F1YXJlZCh4LCB5KSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzdGFuY2VDYWxjdWxhdG9yKHgsIHkpO1xuICB9XG4gIGFwcGx5RmlsbEFscGhhKGN0eCkge1xuICAgIGNvbnN0IHsgZmlsbE9wYWNpdHksIG1pY3JvUGl4ZWxFZmZlY3RPcGFjaXR5LCBvcGFjaXR5IH0gPSB0aGlzO1xuICAgIGN0eC5nbG9iYWxBbHBoYSAqPSBvcGFjaXR5ICogZmlsbE9wYWNpdHkgKiBtaWNyb1BpeGVsRWZmZWN0T3BhY2l0eTtcbiAgfVxuICByZW5kZXJTdHJva2UoY3R4KSB7XG4gICAgY29uc3QgeyBzdHJva2UsIGVmZmVjdGl2ZVN0cm9rZVdpZHRoIH0gPSB0aGlzO1xuICAgIGlmIChzdHJva2UgJiYgZWZmZWN0aXZlU3Ryb2tlV2lkdGgpIHtcbiAgICAgIGNvbnN0IHsgZ2xvYmFsQWxwaGEgfSA9IGN0eDtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3Ryb2tlT3BhY2l0eSxcbiAgICAgICAgbGluZURhc2gsXG4gICAgICAgIGxpbmVEYXNoT2Zmc2V0LFxuICAgICAgICBsaW5lQ2FwLFxuICAgICAgICBsaW5lSm9pbixcbiAgICAgICAgYm9yZGVyUGF0aCxcbiAgICAgICAgYm9yZGVyQ2xpcFBhdGgsXG4gICAgICAgIG9wYWNpdHksXG4gICAgICAgIG1pY3JvUGl4ZWxFZmZlY3RPcGFjaXR5XG4gICAgICB9ID0gdGhpcztcbiAgICAgIGlmIChib3JkZXJDbGlwUGF0aCkge1xuICAgICAgICBjdHguY2xpcChib3JkZXJDbGlwUGF0aC5nZXRQYXRoMkQoKSk7XG4gICAgICB9XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2U7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgKj0gb3BhY2l0eSAqIHN0cm9rZU9wYWNpdHkgKiBtaWNyb1BpeGVsRWZmZWN0T3BhY2l0eTtcbiAgICAgIGN0eC5saW5lV2lkdGggPSBlZmZlY3RpdmVTdHJva2VXaWR0aDtcbiAgICAgIGlmIChsaW5lRGFzaCkge1xuICAgICAgICBjdHguc2V0TGluZURhc2gobGluZURhc2gpO1xuICAgICAgfVxuICAgICAgaWYgKGxpbmVEYXNoT2Zmc2V0KSB7XG4gICAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IGxpbmVEYXNoT2Zmc2V0O1xuICAgICAgfVxuICAgICAgaWYgKGxpbmVDYXApIHtcbiAgICAgICAgY3R4LmxpbmVDYXAgPSBsaW5lQ2FwO1xuICAgICAgfVxuICAgICAgaWYgKGxpbmVKb2luKSB7XG4gICAgICAgIGN0eC5saW5lSm9pbiA9IGxpbmVKb2luO1xuICAgICAgfVxuICAgICAgY3R4LnN0cm9rZShib3JkZXJQYXRoLmdldFBhdGgyRCgpKTtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGdsb2JhbEFscGhhO1xuICAgIH1cbiAgfVxufTtcblJlY3QuY2xhc3NOYW1lID0gXCJSZWN0XCI7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgUmVjdC5wcm90b3R5cGUsIFwieFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBSZWN0LnByb3RvdHlwZSwgXCJ5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFJlY3QucHJvdG90eXBlLCBcIndpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFJlY3QucHJvdG90eXBlLCBcImhlaWdodFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBSZWN0LnByb3RvdHlwZSwgXCJ0b3BMZWZ0Q29ybmVyUmFkaXVzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFJlY3QucHJvdG90eXBlLCBcInRvcFJpZ2h0Q29ybmVyUmFkaXVzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFJlY3QucHJvdG90eXBlLCBcImJvdHRvbVJpZ2h0Q29ybmVyUmFkaXVzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFJlY3QucHJvdG90eXBlLCBcImJvdHRvbUxlZnRDb3JuZXJSYWRpdXNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgUmVjdC5wcm90b3R5cGUsIFwiY2xpcEJCb3hcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgUmVjdC5wcm90b3R5cGUsIFwiY3Jpc3BcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2JhY2tncm91bmQvYmFja2dyb3VuZC50c1xudmFyIEJhY2tncm91bmQgPSBjbGFzcyBleHRlbmRzIEJhc2VNb2R1bGVJbnN0YW5jZSB7XG4gIGNvbnN0cnVjdG9yKGN0eCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy5yZWN0Tm9kZSA9IG5ldyBSZWN0KCk7XG4gICAgdGhpcy50ZXh0Tm9kZSA9IG5ldyBUZXh0KCk7XG4gICAgdGhpcy5maWxsID0gXCJ3aGl0ZVwiO1xuICAgIHRoaXMubm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xuICAgIHRoaXMubm9kZS5hcHBlbmQoW3RoaXMucmVjdE5vZGUsIHRoaXMudGV4dE5vZGVdKTtcbiAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuICAgIHRoaXMuZGVzdHJveUZucy5wdXNoKFxuICAgICAgY3R4LnNjZW5lLmF0dGFjaE5vZGUodGhpcy5ub2RlKSxcbiAgICAgIGN0eC5sYXlvdXRNYW5hZ2VyLmFkZExpc3RlbmVyKFwibGF5b3V0OmNvbXBsZXRlXCIsIChlKSA9PiB0aGlzLm9uTGF5b3V0Q29tcGxldGUoZSkpXG4gICAgKTtcbiAgfVxuICBjcmVhdGVOb2RlKCkge1xuICAgIHJldHVybiBuZXcgR3JvdXAoeyBuYW1lOiBcImJhY2tncm91bmRcIiwgekluZGV4OiAwIC8qIFNFUklFU19CQUNLR1JPVU5EICovIH0pO1xuICB9XG4gIG9uTGF5b3V0Q29tcGxldGUoZSkge1xuICAgIGNvbnN0IHsgd2lkdGg6IHdpZHRoMiwgaGVpZ2h0OiBoZWlnaHQyIH0gPSBlLmNoYXJ0O1xuICAgIHRoaXMucmVjdE5vZGUud2lkdGggPSB3aWR0aDI7XG4gICAgdGhpcy5yZWN0Tm9kZS5oZWlnaHQgPSBoZWlnaHQyO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTiksXG4gIFByb3h5UHJvcGVydHlPbldyaXRlKFwibm9kZVwiLCBcInZpc2libGVcIilcbl0sIEJhY2tncm91bmQucHJvdG90eXBlLCBcInZpc2libGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSksXG4gIFByb3h5UHJvcGVydHlPbldyaXRlKFwicmVjdE5vZGVcIiwgXCJmaWxsXCIpXG5dLCBCYWNrZ3JvdW5kLnByb3RvdHlwZSwgXCJmaWxsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNULCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBCYWNrZ3JvdW5kLnByb3RvdHlwZSwgXCJpbWFnZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KSxcbiAgUHJveHlQcm9wZXJ0eU9uV3JpdGUoXCJ0ZXh0Tm9kZVwiKVxuXSwgQmFja2dyb3VuZC5wcm90b3R5cGUsIFwidGV4dFwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvYmFja2dyb3VuZC9iYWNrZ3JvdW5kTW9kdWxlLnRzXG52YXIgQmFja2dyb3VuZE1vZHVsZSA9IHtcbiAgdHlwZTogXCJyb290XCIsXG4gIG9wdGlvbnNLZXk6IFwiYmFja2dyb3VuZFwiLFxuICBwYWNrYWdlVHlwZTogXCJjb21tdW5pdHlcIixcbiAgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCIsIFwicG9sYXJcIiwgXCJoaWVyYXJjaHlcIiwgXCJ0b3BvbG9neVwiLCBcImZsb3ctcHJvcG9ydGlvblwiLCBcInN0YW5kYWxvbmVcIiwgXCJnYXVnZVwiXSxcbiAgbW9kdWxlRmFjdG9yeTogKGN0eCkgPT4gbmV3IEJhY2tncm91bmQoY3R4KVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvZ3JpZExheW91dC50c1xuZnVuY3Rpb24gZ3JpZExheW91dCh7XG4gIG9yaWVudGF0aW9uLFxuICBiYm94ZXMsXG4gIG1heEhlaWdodCxcbiAgbWF4V2lkdGgsXG4gIGl0ZW1QYWRkaW5nWSA9IDAsXG4gIGl0ZW1QYWRkaW5nWCA9IDAsXG4gIGZvcmNlUmVzdWx0ID0gZmFsc2Vcbn0pIHtcbiAgY29uc3QgaG9yaXpvbnRhbCA9IG9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIjtcbiAgY29uc3QgcHJpbWFyeSA9IHtcbiAgICBtYXg6IGhvcml6b250YWwgPyBtYXhXaWR0aCA6IG1heEhlaWdodCxcbiAgICBmbjogaG9yaXpvbnRhbCA/IChiKSA9PiBiLndpZHRoIDogKGIpID0+IGIuaGVpZ2h0LFxuICAgIHBhZGRpbmc6IGhvcml6b250YWwgPyBpdGVtUGFkZGluZ1ggOiBpdGVtUGFkZGluZ1lcbiAgfTtcbiAgY29uc3Qgc2Vjb25kYXJ5ID0ge1xuICAgIG1heDogaG9yaXpvbnRhbCA/IG1heEhlaWdodCA6IG1heFdpZHRoLFxuICAgIGZuOiBob3Jpem9udGFsID8gKGIpID0+IGIuaGVpZ2h0IDogKGIpID0+IGIud2lkdGgsXG4gICAgcGFkZGluZzogaG9yaXpvbnRhbCA/IGl0ZW1QYWRkaW5nWSA6IGl0ZW1QYWRkaW5nWFxuICB9O1xuICBsZXQgcHJvY2Vzc2VkQkJveENvdW50ID0gMDtcbiAgY29uc3QgcmF3UGFnZXMgPSBbXTtcbiAgd2hpbGUgKHByb2Nlc3NlZEJCb3hDb3VudCA8IGJib3hlcy5sZW5ndGgpIHtcbiAgICBjb25zdCB1bnByb2Nlc3NlZEJCb3hlcyA9IGJib3hlcy5zbGljZShwcm9jZXNzZWRCQm94Q291bnQpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHByb2Nlc3NCQm94ZXModW5wcm9jZXNzZWRCQm94ZXMsIHByb2Nlc3NlZEJCb3hDb3VudCwgcHJpbWFyeSwgc2Vjb25kYXJ5LCBmb3JjZVJlc3VsdCk7XG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcHJvY2Vzc2VkQkJveENvdW50ICs9IHJlc3VsdC5wcm9jZXNzZWRCQm94Q291bnQ7XG4gICAgcmF3UGFnZXMucHVzaChyZXN1bHQucGFnZUluZGljZXMpO1xuICB9XG4gIHJldHVybiBidWlsZFBhZ2VzKHJhd1BhZ2VzLCBvcmllbnRhdGlvbiwgYmJveGVzLCBpdGVtUGFkZGluZ1ksIGl0ZW1QYWRkaW5nWCk7XG59XG5mdW5jdGlvbiBwcm9jZXNzQkJveGVzKGJib3hlcywgaW5kZXhPZmZzZXQsIHByaW1hcnksIHNlY29uZGFyeSwgZm9yY2VSZXN1bHQpIHtcbiAgY29uc3QgbWluR3Vlc3MgPSAxO1xuICBsZXQgc3RhcnRpbmdHdWVzcyA9IGVzdGltYXRlU3RhcnRpbmdHdWVzcyhiYm94ZXMsIHByaW1hcnkpO1xuICBpZiAoc3RhcnRpbmdHdWVzcyA8IG1pbkd1ZXNzKSB7XG4gICAgaWYgKCFmb3JjZVJlc3VsdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdGFydGluZ0d1ZXNzID0gbWluR3Vlc3M7XG4gIH1cbiAgbGV0IGd1ZXNzID0gc3RhcnRpbmdHdWVzcztcbiAgd2hpbGUgKGd1ZXNzID49IG1pbkd1ZXNzKSB7XG4gICAgY29uc3QgcGFnZUluZGljZXMgPSBjYWxjdWxhdGVQYWdlKGJib3hlcywgaW5kZXhPZmZzZXQsIGd1ZXNzLCBwcmltYXJ5LCBzZWNvbmRhcnksIGZvcmNlUmVzdWx0KTtcbiAgICBpZiAocGFnZUluZGljZXMgPT0gbnVsbCAmJiBndWVzcyA8PSBtaW5HdWVzcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocGFnZUluZGljZXMgPT0gbnVsbCkge1xuICAgICAgZ3Vlc3MtLTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHBhZ2VJbmRpY2VzID09PSBcIm51bWJlclwiKSB7XG4gICAgICBpZiAocGFnZUluZGljZXMgPD0gbWluR3Vlc3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZ3Vlc3MgPSBwYWdlSW5kaWNlcyA8IGd1ZXNzICYmIHBhZ2VJbmRpY2VzID4gbWluR3Vlc3MgPyBwYWdlSW5kaWNlcyA6IGd1ZXNzO1xuICAgICAgZ3Vlc3MtLTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBwcm9jZXNzZWRCQm94Q291bnQgPSBwYWdlSW5kaWNlcy5sZW5ndGggKiBwYWdlSW5kaWNlc1swXS5sZW5ndGg7XG4gICAgcmV0dXJuIHsgcHJvY2Vzc2VkQkJveENvdW50LCBwYWdlSW5kaWNlcyB9O1xuICB9XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVQYWdlKGJib3hlcywgaW5kZXhPZmZzZXQsIHByaW1hcnlDb3VudCwgcHJpbWFyeSwgc2Vjb25kYXJ5LCBmb3JjZVJlc3VsdCkge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IHN1bVNlY29uZGFyeSA9IDA7XG4gIGxldCBjdXJyZW50TWF4U2Vjb25kYXJ5ID0gMDtcbiAgbGV0IGN1cnJlbnRQcmltYXJ5SW5kaWNlcyA9IFtdO1xuICBjb25zdCBtYXhQcmltYXJ5VmFsdWVzID0gW107XG4gIGZvciAobGV0IGJib3hJbmRleCA9IDA7IGJib3hJbmRleCA8IGJib3hlcy5sZW5ndGg7IGJib3hJbmRleCsrKSB7XG4gICAgY29uc3QgcHJpbWFyeVZhbHVlSWR4ID0gKGJib3hJbmRleCArIHByaW1hcnlDb3VudCkgJSBwcmltYXJ5Q291bnQ7XG4gICAgaWYgKHByaW1hcnlWYWx1ZUlkeCA9PT0gMCkge1xuICAgICAgc3VtU2Vjb25kYXJ5ICs9IGN1cnJlbnRNYXhTZWNvbmRhcnk7XG4gICAgICBjdXJyZW50TWF4U2Vjb25kYXJ5ID0gMDtcbiAgICAgIGlmIChjdXJyZW50UHJpbWFyeUluZGljZXMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXN1bHQucHVzaChjdXJyZW50UHJpbWFyeUluZGljZXMpO1xuICAgICAgfVxuICAgICAgY3VycmVudFByaW1hcnlJbmRpY2VzID0gW107XG4gICAgfVxuICAgIGNvbnN0IHByaW1hcnlWYWx1ZSA9IHByaW1hcnkuZm4oYmJveGVzW2Jib3hJbmRleF0pICsgcHJpbWFyeS5wYWRkaW5nO1xuICAgIG1heFByaW1hcnlWYWx1ZXNbcHJpbWFyeVZhbHVlSWR4XSA9IE1hdGgubWF4KG1heFByaW1hcnlWYWx1ZXNbcHJpbWFyeVZhbHVlSWR4XSA/PyAwLCBwcmltYXJ5VmFsdWUpO1xuICAgIGN1cnJlbnRNYXhTZWNvbmRhcnkgPSBNYXRoLm1heChjdXJyZW50TWF4U2Vjb25kYXJ5LCBzZWNvbmRhcnkuZm4oYmJveGVzW2Jib3hJbmRleF0pICsgc2Vjb25kYXJ5LnBhZGRpbmcpO1xuICAgIGNvbnN0IGN1cnJlbnRTZWNvbmRhcnlEaW1lbnNpb24gPSBzdW1TZWNvbmRhcnkgKyBjdXJyZW50TWF4U2Vjb25kYXJ5O1xuICAgIGNvbnN0IHJldHVyblJlc3VsdCA9ICFmb3JjZVJlc3VsdCB8fCByZXN1bHQubGVuZ3RoID4gMDtcbiAgICBpZiAoY3VycmVudFNlY29uZGFyeURpbWVuc2lvbiA+IHNlY29uZGFyeS5tYXggJiYgcmV0dXJuUmVzdWx0KSB7XG4gICAgICBjdXJyZW50UHJpbWFyeUluZGljZXMgPSBbXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBzdW1QcmltYXJ5ID0gbWF4UHJpbWFyeVZhbHVlcy5yZWR1Y2UoKHN1bTIsIG5leHQpID0+IHN1bTIgKyBuZXh0LCAwKTtcbiAgICBpZiAoc3VtUHJpbWFyeSA+IHByaW1hcnkubWF4ICYmICFmb3JjZVJlc3VsdCkge1xuICAgICAgaWYgKG1heFByaW1hcnlWYWx1ZXMubGVuZ3RoIDwgcHJpbWFyeUNvdW50KSB7XG4gICAgICAgIHJldHVybiBtYXhQcmltYXJ5VmFsdWVzLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY3VycmVudFByaW1hcnlJbmRpY2VzLnB1c2goYmJveEluZGV4ICsgaW5kZXhPZmZzZXQpO1xuICB9XG4gIGlmIChjdXJyZW50UHJpbWFyeUluZGljZXMubGVuZ3RoID4gMCkge1xuICAgIHJlc3VsdC5wdXNoKGN1cnJlbnRQcmltYXJ5SW5kaWNlcyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC5sZW5ndGggPiAwID8gcmVzdWx0IDogdm9pZCAwO1xufVxuZnVuY3Rpb24gYnVpbGRQYWdlcyhyYXdQYWdlcywgb3JpZW50YXRpb24sIGJib3hlcywgaXRlbVBhZGRpbmdZLCBpdGVtUGFkZGluZ1gpIHtcbiAgbGV0IG1heFBhZ2VXaWR0aCA9IDA7XG4gIGxldCBtYXhQYWdlSGVpZ2h0ID0gMDtcbiAgY29uc3QgcGFnZXMgPSByYXdQYWdlcy5tYXAoKGluZGljZXMpID0+IHtcbiAgICBpZiAob3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiKSB7XG4gICAgICBpbmRpY2VzID0gdHJhbnNwb3NlKGluZGljZXMpO1xuICAgIH1cbiAgICBsZXQgZW5kSW5kZXggPSAwO1xuICAgIGNvbnN0IGNvbHVtbnMgPSBpbmRpY2VzLm1hcCgoY29sSW5kaWNlcykgPT4ge1xuICAgICAgY29uc3QgY29sQkJveGVzID0gY29sSW5kaWNlcy5tYXAoKGJib3hJbmRleCkgPT4ge1xuICAgICAgICBlbmRJbmRleCA9IE1hdGgubWF4KGJib3hJbmRleCwgZW5kSW5kZXgpO1xuICAgICAgICByZXR1cm4gYmJveGVzW2Jib3hJbmRleF07XG4gICAgICB9KTtcbiAgICAgIGxldCBjb2x1bW5IZWlnaHQgPSAwO1xuICAgICAgbGV0IGNvbHVtbldpZHRoID0gMDtcbiAgICAgIGNvbEJCb3hlcy5mb3JFYWNoKChiYm94KSA9PiB7XG4gICAgICAgIGNvbHVtbkhlaWdodCArPSBiYm94LmhlaWdodCArIGl0ZW1QYWRkaW5nWTtcbiAgICAgICAgY29sdW1uV2lkdGggPSBNYXRoLm1heChjb2x1bW5XaWR0aCwgYmJveC53aWR0aCArIGl0ZW1QYWRkaW5nWCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluZGljZXM6IGNvbEluZGljZXMsXG4gICAgICAgIGJib3hlczogY29sQkJveGVzLFxuICAgICAgICBjb2x1bW5IZWlnaHQ6IE1hdGguY2VpbChjb2x1bW5IZWlnaHQpLFxuICAgICAgICBjb2x1bW5XaWR0aDogTWF0aC5jZWlsKGNvbHVtbldpZHRoKVxuICAgICAgfTtcbiAgICB9KTtcbiAgICBsZXQgcGFnZVdpZHRoID0gMDtcbiAgICBsZXQgcGFnZUhlaWdodCA9IDA7XG4gICAgY29sdW1ucy5mb3JFYWNoKChjb2x1bW4pID0+IHtcbiAgICAgIHBhZ2VXaWR0aCArPSBjb2x1bW4uY29sdW1uV2lkdGg7XG4gICAgICBwYWdlSGVpZ2h0ID0gTWF0aC5tYXgocGFnZUhlaWdodCwgY29sdW1uLmNvbHVtbkhlaWdodCk7XG4gICAgfSk7XG4gICAgbWF4UGFnZVdpZHRoID0gTWF0aC5tYXgocGFnZVdpZHRoLCBtYXhQYWdlV2lkdGgpO1xuICAgIG1heFBhZ2VIZWlnaHQgPSBNYXRoLm1heChwYWdlSGVpZ2h0LCBtYXhQYWdlSGVpZ2h0KTtcbiAgICByZXR1cm4ge1xuICAgICAgY29sdW1ucyxcbiAgICAgIHN0YXJ0SW5kZXg6IGluZGljZXNbMF1bMF0sXG4gICAgICBlbmRJbmRleCxcbiAgICAgIHBhZ2VXaWR0aCxcbiAgICAgIHBhZ2VIZWlnaHRcbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIHsgcGFnZXMsIG1heFBhZ2VXaWR0aCwgbWF4UGFnZUhlaWdodCB9O1xufVxuZnVuY3Rpb24gdHJhbnNwb3NlKGRhdGEpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGZvciAoY29uc3QgXyBvZiBkYXRhWzBdKSB7XG4gICAgcmVzdWx0LnB1c2goW10pO1xuICB9XG4gIGRhdGEuZm9yRWFjaCgoaW5uZXJEYXRhLCBkYXRhSWR4KSA9PiB7XG4gICAgaW5uZXJEYXRhLmZvckVhY2goKGl0ZW0sIGl0ZW1JZHgpID0+IHtcbiAgICAgIHJlc3VsdFtpdGVtSWR4XVtkYXRhSWR4XSA9IGl0ZW07XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZXN0aW1hdGVTdGFydGluZ0d1ZXNzKGJib3hlcywgcHJpbWFyeSkge1xuICBjb25zdCBuID0gYmJveGVzLmxlbmd0aDtcbiAgbGV0IHByaW1hcnlTdW0gPSAwO1xuICBmb3IgKGxldCBiYm94SW5kZXggPSAwOyBiYm94SW5kZXggPCBuOyBiYm94SW5kZXgrKykge1xuICAgIHByaW1hcnlTdW0gKz0gcHJpbWFyeS5mbihiYm94ZXNbYmJveEluZGV4XSkgKyBwcmltYXJ5LnBhZGRpbmc7XG4gICAgaWYgKHByaW1hcnlTdW0gPiBwcmltYXJ5Lm1heCkge1xuICAgICAgY29uc3QgcmF0aW8yID0gbiAvIGJib3hJbmRleDtcbiAgICAgIGlmIChyYXRpbzIgPCAyKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwobiAvIDIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJib3hJbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG47XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL2ltYWdlLnRzXG52YXIgSW1hZ2UgPSBjbGFzcyBleHRlbmRzIE5vZGUge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2VJbWFnZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zb3VyY2VJbWFnZSA9IHNvdXJjZUltYWdlO1xuICAgIHRoaXMueCA9IDA7XG4gICAgdGhpcy55ID0gMDtcbiAgICB0aGlzLndpZHRoID0gMDtcbiAgICB0aGlzLmhlaWdodCA9IDA7XG4gICAgdGhpcy5vcGFjaXR5ID0gMTtcbiAgfVxuICB1cGRhdGVCaXRtYXAobmV3Qml0bWFwLCBiaXRtYXBQaXhlbFJhdGlvLCB4LCB5KSB7XG4gICAgdGhpcy5zb3VyY2VJbWFnZSA9IG5ld0JpdG1hcDtcbiAgICB0aGlzLndpZHRoID0gbmV3Qml0bWFwLndpZHRoIC8gYml0bWFwUGl4ZWxSYXRpbztcbiAgICB0aGlzLmhlaWdodCA9IG5ld0JpdG1hcC5oZWlnaHQgLyBiaXRtYXBQaXhlbFJhdGlvO1xuICAgIHRoaXMueCA9IHggLyBiaXRtYXBQaXhlbFJhdGlvO1xuICAgIHRoaXMueSA9IHkgLyBiaXRtYXBQaXhlbFJhdGlvO1xuICAgIHRoaXMubWFya0RpcnR5KDMgLyogTUFKT1IgKi8pO1xuICB9XG4gIHJlbmRlcihyZW5kZXJDdHgpIHtcbiAgICBjb25zdCB7IGN0eCwgZm9yY2VSZW5kZXIsIHN0YXRzIH0gPSByZW5kZXJDdHg7XG4gICAgaWYgKHRoaXMuZGlydHkgPT09IDAgLyogTk9ORSAqLyAmJiAhZm9yY2VSZW5kZXIpIHtcbiAgICAgIGlmIChzdGF0cylcbiAgICAgICAgc3RhdHMubm9kZXNTa2lwcGVkKys7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGltYWdlID0gdGhpcy5zb3VyY2VJbWFnZTtcbiAgICBpZiAoIWltYWdlKVxuICAgICAgcmV0dXJuO1xuICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMub3BhY2l0eTtcbiAgICBjdHguZHJhd0ltYWdlKGltYWdlLCAwLCAwLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LCB0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIHN1cGVyLnJlbmRlcihyZW5kZXJDdHgpO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8gfSlcbl0sIEltYWdlLnByb3RvdHlwZSwgXCJ4XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8gfSlcbl0sIEltYWdlLnByb3RvdHlwZSwgXCJ5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8gfSlcbl0sIEltYWdlLnByb3RvdHlwZSwgXCJ3aWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBJbWFnZS5wcm90b3R5cGUsIFwiaGVpZ2h0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8gfSlcbl0sIEltYWdlLnByb3RvdHlwZSwgXCJvcGFjaXR5XCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9sZWdlbmRNYXJrZXJMYWJlbC50c1xudmFyIExlZ2VuZE1hcmtlckxhYmVsID0gY2xhc3MgZXh0ZW5kcyBUcmFuc2xhdGFibGUoR3JvdXApIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoeyBuYW1lOiBcIm1hcmtlckxhYmVsR3JvdXBcIiB9KTtcbiAgICB0aGlzLmxhYmVsID0gbmV3IFRleHQoKTtcbiAgICB0aGlzLnN5bWJvbHNHcm91cCA9IG5ldyBHcm91cCh7XG4gICAgICBuYW1lOiBcImxlZ2VuZC1tYXJrZXJMYWJlbC1zeW1ib2xzXCJcbiAgICB9KTtcbiAgICB0aGlzLmJpdG1hcCA9IG5ldyBJbWFnZSgpO1xuICAgIHRoaXMuYml0bWFwRGlydHkgPSB0cnVlO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5wYWdlSW5kZXggPSBOYU47XG4gICAgdGhpcy5fbWFya2VycyA9IFtdO1xuICAgIHRoaXMuX2xpbmVzID0gW107XG4gICAgY29uc3QgeyBtYXJrZXJzLCBsYWJlbCwgbGluZXMgfSA9IHRoaXM7XG4gICAgbGFiZWwudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIjtcbiAgICBsYWJlbC5mb250U2l6ZSA9IDEyO1xuICAgIGxhYmVsLmZvbnRGYW1pbHkgPSBcIlZlcmRhbmEsIHNhbnMtc2VyaWZcIjtcbiAgICBsYWJlbC5maWxsID0gXCJibGFja1wiO1xuICAgIGxhYmVsLnkgPSAxO1xuICAgIHRoaXMudXBkYXRlU3ltYm9scyhtYXJrZXJzLCBsaW5lcyk7XG4gICAgdGhpcy5hcHBlbmQoW3RoaXMuc3ltYm9sc0dyb3VwLCBsYWJlbF0pO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuZGVzdHJveVByb3h5QnV0dG9uKCk7XG4gIH1cbiAgZGVzdHJveVByb3h5QnV0dG9uKCkge1xuICAgIHRoaXMucHJveHlCdXR0b24/LmJ1dHRvbi5yZW1vdmUoKTtcbiAgICB0aGlzLnByb3h5QnV0dG9uPy5saXN0aXRlbS5yZW1vdmUoKTtcbiAgICB0aGlzLnByb3h5QnV0dG9uID0gdm9pZCAwO1xuICB9XG4gIGdldCBtYXJrZXJzKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXJrZXJzO1xuICB9XG4gIGdldCBsaW5lcygpIHtcbiAgICByZXR1cm4gdGhpcy5fbGluZXM7XG4gIH1cbiAgdXBkYXRlU3ltYm9scyhtYXJrZXJzLCBsaW5lcykge1xuICAgIGlmIChhcnJheXNFcXVhbCh0aGlzLl9tYXJrZXJzLCBtYXJrZXJzKSAmJiBhcnJheXNFcXVhbCh0aGlzLl9saW5lcywgbGluZXMpKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuYml0bWFwRGlydHkgPSB0cnVlO1xuICAgIHRoaXMuX21hcmtlcnMgPSBtYXJrZXJzO1xuICAgIHRoaXMuX2xpbmVzID0gbGluZXM7XG4gICAgdGhpcy5zeW1ib2xzR3JvdXAuY2xlYXIoKTtcbiAgICB0aGlzLnN5bWJvbHNHcm91cC5hcHBlbmQoW3RoaXMuYml0bWFwLCAuLi5saW5lcywgLi4ubWFya2Vyc10pO1xuICB9XG4gIHNldEVuYWJsZWQoZW5hYmxlZCkge1xuICAgIHRoaXMuZW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgdGhpcy5yZWZyZXNoVmlzaWJpbGl0aWVzKCk7XG4gIH1cbiAgcmVmcmVzaFZpc2liaWxpdGllcygpIHtcbiAgICBjb25zdCBvcGFjaXR5ID0gdGhpcy5lbmFibGVkID8gMSA6IDAuNTtcbiAgICB0aGlzLmxhYmVsLm9wYWNpdHkgPSBvcGFjaXR5O1xuICAgIHRoaXMub3BhY2l0eSA9IG9wYWNpdHk7XG4gICAgdGhpcy5iaXRtYXAub3BhY2l0eSA9IG9wYWNpdHk7XG4gICAgdGhpcy5zZXRCaXRtYXBWaXNpYmlsaXR5KCF0aGlzLmVuYWJsZWQpO1xuICB9XG4gIHNldEJpdG1hcFZpc2liaWxpdHkodmlzaWJsZSkge1xuICAgIGNvbnN0IHsgbGluZXMsIG1hcmtlcnMgfSA9IHRoaXM7XG4gICAgW2xpbmVzLCBtYXJrZXJzXS5mb3JFYWNoKChzaGFwZXMpID0+IHNoYXBlcy5mb3JFYWNoKChzaGFwZSkgPT4gc2hhcGUudmlzaWJsZSA9ICF2aXNpYmxlKSk7XG4gICAgdGhpcy5iaXRtYXAudmlzaWJsZSA9IHZpc2libGU7XG4gIH1cbiAgLy8gVGhlIEJCb3ggb2YgdGhpcy5iaXRtYXAgaXMgYHNwcml0ZVBhZGRpbmdgIHBpeGVscyBiaWdnZXIgaW4gZWFjaCBkaXJlY3Rpb24gdGhhbiBCQm94IG9mIHRoZSBtYXJrZXJzIGFuZCBsaW5lcy5cbiAgLy8gVGhpcyBwYWRkaW5nIGFsbG93cyB0aGUgU3ByaXRlUmVuZGVyZXIgdG8gZHJhdyBhbnRpYWxpYXNpbmcgcGl4ZWxzIHRoYXQgY2FuIGV4dGVuZCBiZXlvbmQgdGhlIHNoYXBlcycgYm91bmRzLlxuICB1cGRhdGUoc3ByaXRlUmVuZGVyZXIsIHsgc3ByaXRlQUFQYWRkaW5nLCBzcHJpdGVQaXhlbFJhdGlvOiBzY2FsZTIgfSwgZGltZW5zaW9uUHJvcHMpIHtcbiAgICBjb25zdCB7IG1hcmtlcnMsIGxpbmVzIH0gPSB0aGlzO1xuICAgIGxldCBzcHJpdGVYID0gMDtcbiAgICBsZXQgc3ByaXRlWSA9IDA7XG4gICAgbGV0IHNoaWZ0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1hdGgubWF4KG1hcmtlcnMubGVuZ3RoLCBsaW5lcy5sZW5ndGgpOyBpKyspIHtcbiAgICAgIGNvbnN0IHsgbGVuZ3RoOiBsZW5ndGgyLCBzcGFjaW5nLCBpc0N1c3RvbU1hcmtlciB9ID0gZGltZW5zaW9uUHJvcHNbaV0gPz8gMDtcbiAgICAgIGNvbnN0IG1hcmtlciA9IG1hcmtlcnNbaV07XG4gICAgICBjb25zdCBsaW5lID0gbGluZXNbaV07XG4gICAgICBjb25zdCBzaXplID0gbWFya2VyPy5zaXplID8/IDA7XG4gICAgICBsZXQgbGluZVRvcCA9IEluZmluaXR5O1xuICAgICAgbGV0IGxpbmVYMSA9IEluZmluaXR5O1xuICAgICAgbGV0IGxpbmVYMiA9IEluZmluaXR5O1xuICAgICAgbGV0IG1hcmtlclRvcCA9IEluZmluaXR5O1xuICAgICAgbGV0IG1hcmtlckxlZnQgPSBJbmZpbml0eTtcbiAgICAgIGlmIChtYXJrZXIpIHtcbiAgICAgICAgY29uc3QgY2VudGVyMiA9IG1hcmtlci5jb25zdHJ1Y3Rvci5jZW50ZXI7XG4gICAgICAgIGNvbnN0IHJhZGl1cyA9IChzaXplICsgbWFya2VyLnN0cm9rZVdpZHRoKSAvIDI7XG4gICAgICAgIGlmIChpc0N1c3RvbU1hcmtlcikge1xuICAgICAgICAgIG1hcmtlci54ID0gMDtcbiAgICAgICAgICBtYXJrZXIueSA9IDA7XG4gICAgICAgICAgbWFya2VyLnRyYW5zbGF0aW9uWCA9IChjZW50ZXIyLnggLSAwLjUpICogc2l6ZSArIGxlbmd0aDIgLyAyICsgc2hpZnQ7XG4gICAgICAgICAgbWFya2VyLnRyYW5zbGF0aW9uWSA9IChjZW50ZXIyLnkgLSAwLjUpICogc2l6ZTtcbiAgICAgICAgICBtYXJrZXJUb3AgPSBtYXJrZXIudHJhbnNsYXRpb25ZIC0gcmFkaXVzO1xuICAgICAgICAgIG1hcmtlckxlZnQgPSBtYXJrZXIudHJhbnNsYXRpb25YIC0gcmFkaXVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hcmtlci54ID0gKGNlbnRlcjIueCAtIDAuNSkgKiBzaXplICsgbGVuZ3RoMiAvIDIgKyBzaGlmdDtcbiAgICAgICAgICBtYXJrZXIueSA9IChjZW50ZXIyLnkgLSAwLjUpICogc2l6ZTtcbiAgICAgICAgICBtYXJrZXJUb3AgPSBtYXJrZXIueSAtIHJhZGl1cztcbiAgICAgICAgICBtYXJrZXJMZWZ0ID0gbWFya2VyLnggLSByYWRpdXM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsaW5lKSB7XG4gICAgICAgIGxpbmUueDEgPSBzaGlmdDtcbiAgICAgICAgbGluZS54MiA9IHNoaWZ0ICsgbGVuZ3RoMjtcbiAgICAgICAgbGluZS55MSA9IDA7XG4gICAgICAgIGxpbmUueTIgPSAwO1xuICAgICAgICBsaW5lLm1hcmtEaXJ0eSgzIC8qIE1BSk9SICovKTtcbiAgICAgICAgbGluZVRvcCA9IC1saW5lLnN0cm9rZVdpZHRoIC8gMjtcbiAgICAgICAgbGluZVgxID0gbGluZS54MTtcbiAgICAgICAgbGluZVgyID0gbGluZS54MjtcbiAgICAgIH1cbiAgICAgIHNoaWZ0ICs9IHNwYWNpbmcgKyBNYXRoLm1heChsZW5ndGgyLCBzaXplKTtcbiAgICAgIHNwcml0ZVggPSBNYXRoLm1pbihzcHJpdGVYLCBsaW5lWDEsIGxpbmVYMiwgbWFya2VyTGVmdCk7XG4gICAgICBzcHJpdGVZID0gTWF0aC5taW4oc3ByaXRlWSwgbGluZVRvcCwgbWFya2VyVG9wKTtcbiAgICB9XG4gICAgY29uc3QgbGFzdFN5bWJvbFByb3BzID0gZGltZW5zaW9uUHJvcHMuYXQoLTEpO1xuICAgIGNvbnN0IGxhc3RMaW5lID0gdGhpcy5saW5lcy5hdCgtMSk7XG4gICAgY29uc3QgbGFzdE1hcmtlciA9IHRoaXMubWFya2Vycy5hdCgtMSk7XG4gICAgY29uc3QgbGluZUVuZCA9IGxhc3RMaW5lID8gbGFzdExpbmUueDIgOiAtSW5maW5pdHk7XG4gICAgY29uc3QgbWFya2VyRW5kID0gKGxhc3RNYXJrZXI/LnggPz8gMCkgKyAobGFzdE1hcmtlcj8uc2l6ZSA/PyAwKSAvIDI7XG4gICAgdGhpcy5sYWJlbC54ID0gTWF0aC5tYXgobGluZUVuZCwgbWFya2VyRW5kKSArIChsYXN0U3ltYm9sUHJvcHM/LnNwYWNpbmcgPz8gMCk7XG4gICAgaWYgKHRoaXMuYml0bWFwRGlydHkpIHtcbiAgICAgIHRoaXMuc2V0Qml0bWFwVmlzaWJpbGl0eShmYWxzZSk7XG4gICAgICBjb25zdCB0cmFuc2xhdGVYID0gKHNwcml0ZUFBUGFkZGluZyArIHNwcml0ZVgpICogc2NhbGUyO1xuICAgICAgY29uc3QgdHJhbnNsYXRlWSA9IChzcHJpdGVBQVBhZGRpbmcgLSBzcHJpdGVZKSAqIHNjYWxlMjtcbiAgICAgIGNvbnN0IHNwcml0ZSA9IHNwcml0ZVJlbmRlcmVyLnJlbmRlclNwcml0ZSh0aGlzLnN5bWJvbHNHcm91cCwge1xuICAgICAgICBzY2FsZTogc2NhbGUyLFxuICAgICAgICB0cmFuc2xhdGVYOiBNYXRoLmZsb29yKHRyYW5zbGF0ZVgpLFxuICAgICAgICB0cmFuc2xhdGVZOiBNYXRoLmZsb29yKHRyYW5zbGF0ZVkpXG4gICAgICB9KTtcbiAgICAgIHRoaXMuYml0bWFwLnVwZGF0ZUJpdG1hcChzcHJpdGUsIHNjYWxlMiwgTWF0aC5jZWlsKC10cmFuc2xhdGVYKSwgTWF0aC5jZWlsKC10cmFuc2xhdGVZKSk7XG4gICAgICB0aGlzLmJpdG1hcERpcnR5ID0gZmFsc2U7XG4gICAgICB0aGlzLnJlZnJlc2hWaXNpYmlsaXRpZXMoKTtcbiAgICB9XG4gICAgaWYgKGRpbWVuc2lvblByb3BzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYmJveCA9IHRoaXMuc3ltYm9sc0dyb3VwLmdldEJCb3goKTtcbiAgICBjb25zdCBjbGlwcGVkV2lkdGggPSBNYXRoLm1heChsYXN0TWFya2VyPy5zaXplID8/IDAsIGxhc3RTeW1ib2xQcm9wcz8ubGVuZ3RoID8/IDApO1xuICAgIGNvbnN0IGNsaXBSZWN0ID0gbmV3IEJCb3goYmJveC54ICsgY2xpcHBlZFdpZHRoIC8gMiwgYmJveC55LCBjbGlwcGVkV2lkdGgsIGJib3guaGVpZ2h0KTtcbiAgICB0aGlzLnN5bWJvbHNHcm91cC5zZXRDbGlwUmVjdChjbGlwUmVjdCk7XG4gIH1cbiAgY29tcHV0ZUJCb3goKSB7XG4gICAgY29uc3QgeyBsYWJlbCwgbGluZXMsIG1hcmtlcnMgfSA9IHRoaXM7XG4gICAgcmV0dXJuIHRoaXMudG9QYXJlbnQoR3JvdXAuY29tcHV0ZUNoaWxkcmVuQkJveChpdGVyYXRlKFtsYWJlbF0sIGxpbmVzLCBtYXJrZXJzKSwgZmFsc2UpKTtcbiAgfVxufTtcbkxlZ2VuZE1hcmtlckxhYmVsLmNsYXNzTmFtZSA9IFwiTWFya2VyTGFiZWxcIjtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHlPbldyaXRlKFwibGFiZWxcIilcbl0sIExlZ2VuZE1hcmtlckxhYmVsLnByb3RvdHlwZSwgXCJ0ZXh0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgUHJveHlQcm9wZXJ0eU9uV3JpdGUoXCJsYWJlbFwiKVxuXSwgTGVnZW5kTWFya2VyTGFiZWwucHJvdG90eXBlLCBcImZvbnRTdHlsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHlPbldyaXRlKFwibGFiZWxcIilcbl0sIExlZ2VuZE1hcmtlckxhYmVsLnByb3RvdHlwZSwgXCJmb250V2VpZ2h0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgUHJveHlQcm9wZXJ0eU9uV3JpdGUoXCJsYWJlbFwiKVxuXSwgTGVnZW5kTWFya2VyTGFiZWwucHJvdG90eXBlLCBcImZvbnRTaXplXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgUHJveHlQcm9wZXJ0eU9uV3JpdGUoXCJsYWJlbFwiKVxuXSwgTGVnZW5kTWFya2VyTGFiZWwucHJvdG90eXBlLCBcImZvbnRGYW1pbHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBQcm94eVByb3BlcnR5T25Xcml0ZShcImxhYmVsXCIsIFwiZmlsbFwiKVxuXSwgTGVnZW5kTWFya2VyTGFiZWwucHJvdG90eXBlLCBcImNvbG9yXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9wYWdpbmF0aW9uL3BhZ2luYXRpb24udHNcbnZhciBQYWdpbmF0aW9uTGFiZWwgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmNvbG9yID0gXCJibGFja1wiO1xuICAgIHRoaXMuZm9udFN0eWxlID0gdm9pZCAwO1xuICAgIHRoaXMuZm9udFdlaWdodCA9IHZvaWQgMDtcbiAgICB0aGlzLmZvbnRTaXplID0gMTI7XG4gICAgdGhpcy5mb250RmFtaWx5ID0gXCJWZXJkYW5hLCBzYW5zLXNlcmlmXCI7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcpXG5dLCBQYWdpbmF0aW9uTGFiZWwucHJvdG90eXBlLCBcImNvbG9yXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoRk9OVF9TVFlMRSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgUGFnaW5hdGlvbkxhYmVsLnByb3RvdHlwZSwgXCJmb250U3R5bGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGT05UX1dFSUdIVCwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgUGFnaW5hdGlvbkxhYmVsLnByb3RvdHlwZSwgXCJmb250V2VpZ2h0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgUGFnaW5hdGlvbkxhYmVsLnByb3RvdHlwZSwgXCJmb250U2l6ZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORylcbl0sIFBhZ2luYXRpb25MYWJlbC5wcm90b3R5cGUsIFwiZm9udEZhbWlseVwiLCAyKTtcbnZhciBQYWdpbmF0aW9uTWFya2VyU3R5bGUgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnNpemUgPSAxNTtcbiAgICB0aGlzLmZpbGwgPSB2b2lkIDA7XG4gICAgdGhpcy5maWxsT3BhY2l0eSA9IHZvaWQgMDtcbiAgICB0aGlzLnN0cm9rZSA9IHZvaWQgMDtcbiAgICB0aGlzLnN0cm9rZVdpZHRoID0gMTtcbiAgICB0aGlzLnN0cm9rZU9wYWNpdHkgPSAxO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgUGFnaW5hdGlvbk1hcmtlclN0eWxlLnByb3RvdHlwZSwgXCJzaXplXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBQYWdpbmF0aW9uTWFya2VyU3R5bGUucHJvdG90eXBlLCBcImZpbGxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgUGFnaW5hdGlvbk1hcmtlclN0eWxlLnByb3RvdHlwZSwgXCJmaWxsT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgUGFnaW5hdGlvbk1hcmtlclN0eWxlLnByb3RvdHlwZSwgXCJzdHJva2VcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBQYWdpbmF0aW9uTWFya2VyU3R5bGUucHJvdG90eXBlLCBcInN0cm9rZVdpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8pXG5dLCBQYWdpbmF0aW9uTWFya2VyU3R5bGUucHJvdG90eXBlLCBcInN0cm9rZU9wYWNpdHlcIiwgMik7XG52YXIgUGFnaW5hdGlvbk1hcmtlciA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMuc2hhcGUgPSBUcmlhbmdsZTtcbiAgICB0aGlzLnNpemUgPSAxNTtcbiAgICB0aGlzLnBhZGRpbmcgPSA4O1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgQWN0aW9uT25TZXQoe1xuICAgIGNoYW5nZVZhbHVlKCkge1xuICAgICAgaWYgKHRoaXMucGFyZW50Lm1hcmtlciA9PT0gdGhpcykge1xuICAgICAgICB0aGlzLnBhcmVudC5vbk1hcmtlclNoYXBlQ2hhbmdlKCk7XG4gICAgICB9XG4gICAgfVxuICB9KVxuXSwgUGFnaW5hdGlvbk1hcmtlci5wcm90b3R5cGUsIFwic2hhcGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBQYWdpbmF0aW9uTWFya2VyLnByb3RvdHlwZSwgXCJzaXplXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgUGFnaW5hdGlvbk1hcmtlci5wcm90b3R5cGUsIFwicGFkZGluZ1wiLCAyKTtcbnZhciBQYWdpbmF0aW9uID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKGNoYXJ0VXBkYXRlQ2FsbGJhY2ssIHBhZ2VVcGRhdGVDYWxsYmFjaykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jaGFydFVwZGF0ZUNhbGxiYWNrID0gY2hhcnRVcGRhdGVDYWxsYmFjaztcbiAgICB0aGlzLnBhZ2VVcGRhdGVDYWxsYmFjayA9IHBhZ2VVcGRhdGVDYWxsYmFjaztcbiAgICB0aGlzLmlkID0gY3JlYXRlSWQodGhpcyk7XG4gICAgdGhpcy5tYXJrZXIgPSBuZXcgUGFnaW5hdGlvbk1hcmtlcih0aGlzKTtcbiAgICB0aGlzLmFjdGl2ZVN0eWxlID0gbmV3IFBhZ2luYXRpb25NYXJrZXJTdHlsZSgpO1xuICAgIHRoaXMuaW5hY3RpdmVTdHlsZSA9IG5ldyBQYWdpbmF0aW9uTWFya2VyU3R5bGUoKTtcbiAgICB0aGlzLmhpZ2hsaWdodFN0eWxlID0gbmV3IFBhZ2luYXRpb25NYXJrZXJTdHlsZSgpO1xuICAgIHRoaXMubGFiZWwgPSBuZXcgUGFnaW5hdGlvbkxhYmVsKCk7XG4gICAgdGhpcy5ncm91cCA9IG5ldyBUcmFuc2xhdGFibGVHcm91cCh7IG5hbWU6IFwicGFnaW5hdGlvblwiIH0pO1xuICAgIHRoaXMubGFiZWxOb2RlID0gbmV3IFRleHQoKTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMgPSBbXTtcbiAgICB0aGlzLnRvdGFsUGFnZXMgPSAwO1xuICAgIHRoaXMuY3VycmVudFBhZ2UgPSAwO1xuICAgIHRoaXMudHJhbnNsYXRpb25YID0gMDtcbiAgICB0aGlzLnRyYW5zbGF0aW9uWSA9IDA7XG4gICAgdGhpcy5uZXh0QnV0dG9uRGlzYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLnByZXZpb3VzQnV0dG9uRGlzYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLl92aXNpYmxlID0gdHJ1ZTtcbiAgICB0aGlzLl9lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLl9vcmllbnRhdGlvbiA9IFwidmVydGljYWxcIjtcbiAgICB0aGlzLl9uZXh0QnV0dG9uID0gbmV3IFRyaWFuZ2xlKCk7XG4gICAgdGhpcy5fcHJldmlvdXNCdXR0b24gPSBuZXcgVHJpYW5nbGUoKTtcbiAgICB0aGlzLmxhYmVsTm9kZS5zZXRQcm9wZXJ0aWVzKHtcbiAgICAgIHRleHRCYXNlbGluZTogXCJtaWRkbGVcIixcbiAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgIGZvbnRGYW1pbHk6IFwiVmVyZGFuYSwgc2Fucy1zZXJpZlwiLFxuICAgICAgZmlsbDogXCJibGFja1wiLFxuICAgICAgeTogMVxuICAgIH0pO1xuICAgIHRoaXMuZ3JvdXAuYXBwZW5kKFt0aGlzLm5leHRCdXR0b24sIHRoaXMucHJldmlvdXNCdXR0b24sIHRoaXMubGFiZWxOb2RlXSk7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgICB0aGlzLnVwZGF0ZU1hcmtlcnMoKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveUZucy5mb3JFYWNoKChmKSA9PiBmKCkpO1xuICB9XG4gIHNldCB2aXNpYmxlKHZhbHVlKSB7XG4gICAgdGhpcy5fdmlzaWJsZSA9IHZhbHVlO1xuICAgIHRoaXMudXBkYXRlR3JvdXBWaXNpYmlsaXR5KCk7XG4gIH1cbiAgZ2V0IHZpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Zpc2libGU7XG4gIH1cbiAgc2V0IGVuYWJsZWQodmFsdWUpIHtcbiAgICB0aGlzLl9lbmFibGVkID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGVHcm91cFZpc2liaWxpdHkoKTtcbiAgfVxuICBnZXQgZW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZW5hYmxlZDtcbiAgfVxuICB1cGRhdGVHcm91cFZpc2liaWxpdHkoKSB7XG4gICAgdGhpcy5ncm91cC52aXNpYmxlID0gdGhpcy5lbmFibGVkICYmIHRoaXMudmlzaWJsZTtcbiAgfVxuICBzZXQgb3JpZW50YXRpb24odmFsdWUpIHtcbiAgICB0aGlzLl9vcmllbnRhdGlvbiA9IHZhbHVlO1xuICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgIGNhc2UgXCJob3Jpem9udGFsXCI6IHtcbiAgICAgICAgdGhpcy5wcmV2aW91c0J1dHRvbi5yb3RhdGlvbiA9IC1NYXRoLlBJIC8gMjtcbiAgICAgICAgdGhpcy5uZXh0QnV0dG9uLnJvdGF0aW9uID0gTWF0aC5QSSAvIDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcInZlcnRpY2FsXCI6XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIHRoaXMucHJldmlvdXNCdXR0b24ucm90YXRpb24gPSAwO1xuICAgICAgICB0aGlzLm5leHRCdXR0b24ucm90YXRpb24gPSBNYXRoLlBJO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQgb3JpZW50YXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX29yaWVudGF0aW9uO1xuICB9XG4gIHNldCBuZXh0QnV0dG9uKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX25leHRCdXR0b24gIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLmdyb3VwLnJlbW92ZUNoaWxkKHRoaXMuX25leHRCdXR0b24pO1xuICAgICAgdGhpcy5fbmV4dEJ1dHRvbiA9IHZhbHVlO1xuICAgICAgdGhpcy5ncm91cC5hcHBlbmRDaGlsZCh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIGdldCBuZXh0QnV0dG9uKCkge1xuICAgIHJldHVybiB0aGlzLl9uZXh0QnV0dG9uO1xuICB9XG4gIHNldCBwcmV2aW91c0J1dHRvbih2YWx1ZSkge1xuICAgIGlmICh0aGlzLl9wcmV2aW91c0J1dHRvbiAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuZ3JvdXAucmVtb3ZlQ2hpbGQodGhpcy5fcHJldmlvdXNCdXR0b24pO1xuICAgICAgdGhpcy5fcHJldmlvdXNCdXR0b24gPSB2YWx1ZTtcbiAgICAgIHRoaXMuZ3JvdXAuYXBwZW5kQ2hpbGQodmFsdWUpO1xuICAgIH1cbiAgfVxuICBnZXQgcHJldmlvdXNCdXR0b24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByZXZpb3VzQnV0dG9uO1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICB0aGlzLnVwZGF0ZUxhYmVsKCk7XG4gICAgdGhpcy51cGRhdGVQb3NpdGlvbnMoKTtcbiAgICB0aGlzLmVuYWJsZU9yRGlzYWJsZUJ1dHRvbnMoKTtcbiAgfVxuICB1cGRhdGVQb3NpdGlvbnMoKSB7XG4gICAgdGhpcy5ncm91cC50cmFuc2xhdGlvblggPSB0aGlzLnRyYW5zbGF0aW9uWDtcbiAgICB0aGlzLmdyb3VwLnRyYW5zbGF0aW9uWSA9IHRoaXMudHJhbnNsYXRpb25ZO1xuICAgIHRoaXMudXBkYXRlTGFiZWxQb3NpdGlvbigpO1xuICAgIHRoaXMudXBkYXRlTmV4dEJ1dHRvblBvc2l0aW9uKCk7XG4gIH1cbiAgdXBkYXRlTGFiZWxQb3NpdGlvbigpIHtcbiAgICBjb25zdCB7IHNpemU6IG1hcmtlclNpemUsIHBhZGRpbmc6IG1hcmtlclBhZGRpbmcgfSA9IHRoaXMubWFya2VyO1xuICAgIHRoaXMubmV4dEJ1dHRvbi5zaXplID0gbWFya2VyU2l6ZTtcbiAgICB0aGlzLnByZXZpb3VzQnV0dG9uLnNpemUgPSBtYXJrZXJTaXplO1xuICAgIHRoaXMubGFiZWxOb2RlLnggPSBtYXJrZXJTaXplIC8gMiArIG1hcmtlclBhZGRpbmc7XG4gIH1cbiAgdXBkYXRlTmV4dEJ1dHRvblBvc2l0aW9uKCkge1xuICAgIGNvbnN0IGxhYmVsQkJveCA9IHRoaXMubGFiZWxOb2RlLmdldEJCb3goKTtcbiAgICB0aGlzLm5leHRCdXR0b24udHJhbnNsYXRpb25YID0gbGFiZWxCQm94LndpZHRoICsgKHRoaXMubWFya2VyLnNpemUgLyAyICsgdGhpcy5tYXJrZXIucGFkZGluZykgKiAyO1xuICB9XG4gIHVwZGF0ZUxhYmVsKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGN1cnJlbnRQYWdlLFxuICAgICAgdG90YWxQYWdlczogcGFnZXMsXG4gICAgICBsYWJlbE5vZGUsXG4gICAgICBsYWJlbDogeyBjb2xvciwgZm9udFN0eWxlLCBmb250V2VpZ2h0LCBmb250U2l6ZSwgZm9udEZhbWlseSB9XG4gICAgfSA9IHRoaXM7XG4gICAgbGFiZWxOb2RlLnRleHQgPSBgJHtjdXJyZW50UGFnZSArIDF9IC8gJHtwYWdlc31gO1xuICAgIGxhYmVsTm9kZS5maWxsID0gY29sb3I7XG4gICAgbGFiZWxOb2RlLmZvbnRTdHlsZSA9IGZvbnRTdHlsZTtcbiAgICBsYWJlbE5vZGUuZm9udFdlaWdodCA9IGZvbnRXZWlnaHQ7XG4gICAgbGFiZWxOb2RlLmZvbnRTaXplID0gZm9udFNpemU7XG4gICAgbGFiZWxOb2RlLmZvbnRGYW1pbHkgPSBmb250RmFtaWx5O1xuICB9XG4gIHVwZGF0ZU1hcmtlcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgbmV4dEJ1dHRvbixcbiAgICAgIHByZXZpb3VzQnV0dG9uLFxuICAgICAgbmV4dEJ1dHRvbkRpc2FibGVkLFxuICAgICAgcHJldmlvdXNCdXR0b25EaXNhYmxlZCxcbiAgICAgIGFjdGl2ZVN0eWxlLFxuICAgICAgaW5hY3RpdmVTdHlsZSxcbiAgICAgIGhpZ2hsaWdodFN0eWxlLFxuICAgICAgaGlnaGxpZ2h0QWN0aXZlXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgYnV0dG9uU3R5bGUgPSAoYnV0dG9uLCBkaXNhYmxlZCkgPT4ge1xuICAgICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICAgIHJldHVybiBpbmFjdGl2ZVN0eWxlO1xuICAgICAgfSBlbHNlIGlmIChidXR0b24gPT09IGhpZ2hsaWdodEFjdGl2ZSkge1xuICAgICAgICByZXR1cm4gaGlnaGxpZ2h0U3R5bGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0aXZlU3R5bGU7XG4gICAgfTtcbiAgICB0aGlzLnVwZGF0ZU1hcmtlcihuZXh0QnV0dG9uLCBidXR0b25TdHlsZShcIm5leHRcIiwgbmV4dEJ1dHRvbkRpc2FibGVkKSk7XG4gICAgdGhpcy51cGRhdGVNYXJrZXIocHJldmlvdXNCdXR0b24sIGJ1dHRvblN0eWxlKFwicHJldmlvdXNcIiwgcHJldmlvdXNCdXR0b25EaXNhYmxlZCkpO1xuICB9XG4gIHVwZGF0ZU1hcmtlcihtYXJrZXIsIHN0eWxlKSB7XG4gICAgY29uc3QgeyBzaXplIH0gPSB0aGlzLm1hcmtlcjtcbiAgICBtYXJrZXIuc2l6ZSA9IHNpemU7XG4gICAgbWFya2VyLmZpbGwgPSBzdHlsZS5maWxsO1xuICAgIG1hcmtlci5maWxsT3BhY2l0eSA9IHN0eWxlLmZpbGxPcGFjaXR5ID8/IDE7XG4gICAgbWFya2VyLnN0cm9rZSA9IHN0eWxlLnN0cm9rZTtcbiAgICBtYXJrZXIuc3Ryb2tlV2lkdGggPSBzdHlsZS5zdHJva2VXaWR0aDtcbiAgICBtYXJrZXIuc3Ryb2tlT3BhY2l0eSA9IHN0eWxlLnN0cm9rZU9wYWNpdHk7XG4gIH1cbiAgZW5hYmxlT3JEaXNhYmxlQnV0dG9ucygpIHtcbiAgICBjb25zdCB7IGN1cnJlbnRQYWdlLCB0b3RhbFBhZ2VzIH0gPSB0aGlzO1xuICAgIGNvbnN0IHplcm9QYWdlc1RvRGlzcGxheSA9IHRvdGFsUGFnZXMgPT09IDA7XG4gICAgY29uc3Qgb25MYXN0UGFnZSA9IGN1cnJlbnRQYWdlID09PSB0b3RhbFBhZ2VzIC0gMTtcbiAgICBjb25zdCBvbkZpcnN0UGFnZSA9IGN1cnJlbnRQYWdlID09PSAwO1xuICAgIHRoaXMubmV4dEJ1dHRvbkRpc2FibGVkID0gb25MYXN0UGFnZSB8fCB6ZXJvUGFnZXNUb0Rpc3BsYXk7XG4gICAgdGhpcy5wcmV2aW91c0J1dHRvbkRpc2FibGVkID0gb25GaXJzdFBhZ2UgfHwgemVyb1BhZ2VzVG9EaXNwbGF5O1xuICB9XG4gIHNldFBhZ2UocGFnZU51bWJlcikge1xuICAgIHBhZ2VOdW1iZXIgPSBjbGFtcCgwLCBwYWdlTnVtYmVyLCB0aGlzLnRvdGFsUGFnZXMgLSAxKTtcbiAgICBpZiAodGhpcy5jdXJyZW50UGFnZSAhPT0gcGFnZU51bWJlcikge1xuICAgICAgdGhpcy5jdXJyZW50UGFnZSA9IHBhZ2VOdW1iZXI7XG4gICAgICB0aGlzLm9uUGFnaW5hdGlvbkNoYW5nZWQoKTtcbiAgICB9XG4gIH1cbiAgZ2V0Q3Vyc29yKG5vZGUpIHtcbiAgICByZXR1cm4geyBwcmV2aW91czogdGhpcy5wcmV2aW91c0J1dHRvbkRpc2FibGVkLCBuZXh0OiB0aGlzLm5leHRCdXR0b25EaXNhYmxlZCB9W25vZGVdID8gdm9pZCAwIDogXCJwb2ludGVyXCI7XG4gIH1cbiAgb25DbGljayhldmVudCwgbm9kZSkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKG5vZGUgPT09IFwibmV4dFwiICYmICF0aGlzLm5leHRCdXR0b25EaXNhYmxlZCkge1xuICAgICAgdGhpcy5pbmNyZW1lbnRQYWdlKCk7XG4gICAgICB0aGlzLm9uUGFnaW5hdGlvbkNoYW5nZWQoKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUgPT09IFwicHJldmlvdXNcIiAmJiAhdGhpcy5wcmV2aW91c0J1dHRvbkRpc2FibGVkKSB7XG4gICAgICB0aGlzLmRlY3JlbWVudFBhZ2UoKTtcbiAgICAgIHRoaXMub25QYWdpbmF0aW9uQ2hhbmdlZCgpO1xuICAgIH1cbiAgfVxuICBvbk1vdXNlSG92ZXIobm9kZSkge1xuICAgIHRoaXMuaGlnaGxpZ2h0QWN0aXZlID0gbm9kZTtcbiAgICB0aGlzLnVwZGF0ZU1hcmtlcnMoKTtcbiAgICB0aGlzLmNoYXJ0VXBkYXRlQ2FsbGJhY2soNiAvKiBTQ0VORV9SRU5ERVIgKi8pO1xuICB9XG4gIG9uUGFnaW5hdGlvbkNoYW5nZWQoKSB7XG4gICAgdGhpcy5wYWdlVXBkYXRlQ2FsbGJhY2sodGhpcy5jdXJyZW50UGFnZSk7XG4gIH1cbiAgaW5jcmVtZW50UGFnZSgpIHtcbiAgICB0aGlzLmN1cnJlbnRQYWdlID0gTWF0aC5taW4odGhpcy5jdXJyZW50UGFnZSArIDEsIHRoaXMudG90YWxQYWdlcyAtIDEpO1xuICB9XG4gIGRlY3JlbWVudFBhZ2UoKSB7XG4gICAgdGhpcy5jdXJyZW50UGFnZSA9IE1hdGgubWF4KHRoaXMuY3VycmVudFBhZ2UgLSAxLCAwKTtcbiAgfVxuICBvbk1hcmtlclNoYXBlQ2hhbmdlKCkge1xuICAgIGNvbnN0IE1hcmtlcjIgPSBSb3RhdGFibGUoZ2V0TWFya2VyKHRoaXMubWFya2VyLnNoYXBlIHx8IFRyaWFuZ2xlKSk7XG4gICAgdGhpcy5wcmV2aW91c0J1dHRvbiA9IG5ldyBNYXJrZXIyKCk7XG4gICAgdGhpcy5uZXh0QnV0dG9uID0gbmV3IE1hcmtlcjIoKTtcbiAgICB0aGlzLnVwZGF0ZVBvc2l0aW9ucygpO1xuICAgIHRoaXMudXBkYXRlTWFya2VycygpO1xuICAgIHRoaXMuY2hhcnRVcGRhdGVDYWxsYmFjayg2IC8qIFNDRU5FX1JFTkRFUiAqLyk7XG4gIH1cbiAgYXR0YWNoUGFnaW5hdGlvbihub2RlKSB7XG4gICAgbm9kZS5hcHBlbmQodGhpcy5ncm91cCk7XG4gIH1cbiAgZ2V0QkJveCgpIHtcbiAgICByZXR1cm4gdGhpcy5ncm91cC5nZXRCQm94KCk7XG4gIH1cbiAgY29tcHV0ZUNTU0JvdW5kcygpIHtcbiAgICBjb25zdCBwcmV2ID0gVHJhbnNmb3JtYWJsZS50b0NhbnZhcyh0aGlzLnByZXZpb3VzQnV0dG9uKTtcbiAgICBjb25zdCBuZXh0ID0gVHJhbnNmb3JtYWJsZS50b0NhbnZhcyh0aGlzLm5leHRCdXR0b24pO1xuICAgIHJldHVybiB7IHByZXYsIG5leHQgfTtcbiAgfVxufTtcblBhZ2luYXRpb24uY2xhc3NOYW1lID0gXCJQYWdpbmF0aW9uXCI7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBQYWdpbmF0aW9uLnByb3RvdHlwZSwgXCJtYXJrZXJcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBQYWdpbmF0aW9uLnByb3RvdHlwZSwgXCJhY3RpdmVTdHlsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIFBhZ2luYXRpb24ucHJvdG90eXBlLCBcImluYWN0aXZlU3R5bGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBQYWdpbmF0aW9uLnByb3RvdHlwZSwgXCJoaWdobGlnaHRTdHlsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIFBhZ2luYXRpb24ucHJvdG90eXBlLCBcImxhYmVsXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9sZWdlbmQudHNcbnZhciBMZWdlbmRMYWJlbCA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMubWF4TGVuZ3RoID0gdm9pZCAwO1xuICAgIHRoaXMuY29sb3IgPSBcImJsYWNrXCI7XG4gICAgdGhpcy5mb250U3R5bGUgPSB2b2lkIDA7XG4gICAgdGhpcy5mb250V2VpZ2h0ID0gdm9pZCAwO1xuICAgIHRoaXMuZm9udFNpemUgPSAxMjtcbiAgICB0aGlzLmZvbnRGYW1pbHkgPSBcIlZlcmRhbmEsIHNhbnMtc2VyaWZcIjtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGVnZW5kTGFiZWwucHJvdG90eXBlLCBcIm1heExlbmd0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORylcbl0sIExlZ2VuZExhYmVsLnByb3RvdHlwZSwgXCJjb2xvclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZPTlRfU1RZTEUsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIExlZ2VuZExhYmVsLnByb3RvdHlwZSwgXCJmb250U3R5bGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGT05UX1dFSUdIVCwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGVnZW5kTGFiZWwucHJvdG90eXBlLCBcImZvbnRXZWlnaHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBMZWdlbmRMYWJlbC5wcm90b3R5cGUsIFwiZm9udFNpemVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcpXG5dLCBMZWdlbmRMYWJlbC5wcm90b3R5cGUsIFwiZm9udEZhbWlseVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZVTkNUSU9OLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBMZWdlbmRMYWJlbC5wcm90b3R5cGUsIFwiZm9ybWF0dGVyXCIsIDIpO1xudmFyIExlZ2VuZE1hcmtlciA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuc2l6ZSA9IDE1O1xuICAgIHRoaXMucGFkZGluZyA9IDg7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBPYnNlcnZlQ2hhbmdlcygodGFyZ2V0KSA9PiB0YXJnZXQucGFyZW50Py5vbk1hcmtlclNoYXBlQ2hhbmdlKCkpXG5dLCBMZWdlbmRNYXJrZXIucHJvdG90eXBlLCBcInNoYXBlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgTGVnZW5kTWFya2VyLnByb3RvdHlwZSwgXCJzaXplXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgTGVnZW5kTWFya2VyLnByb3RvdHlwZSwgXCJwYWRkaW5nXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBMZWdlbmRNYXJrZXIucHJvdG90eXBlLCBcInN0cm9rZVdpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIExlZ2VuZE1hcmtlci5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCAyKTtcbnZhciBMZWdlbmRMaW5lID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBMZWdlbmRMaW5lLnByb3RvdHlwZSwgXCJzdHJva2VXaWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGVnZW5kTGluZS5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIDIpO1xudmFyIExlZ2VuZEl0ZW0gPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnBhZGRpbmdYID0gMTY7XG4gICAgdGhpcy5wYWRkaW5nWSA9IDg7XG4gICAgdGhpcy5zaG93U2VyaWVzU3Ryb2tlID0gZmFsc2U7XG4gICAgdGhpcy5tYXJrZXIgPSBuZXcgTGVnZW5kTWFya2VyKCk7XG4gICAgdGhpcy5sYWJlbCA9IG5ldyBMZWdlbmRMYWJlbCgpO1xuICAgIHRoaXMubGluZSA9IG5ldyBMZWdlbmRMaW5lKCk7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIExlZ2VuZEl0ZW0ucHJvdG90eXBlLCBcIm1heFdpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgTGVnZW5kSXRlbS5wcm90b3R5cGUsIFwicGFkZGluZ1hcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBMZWdlbmRJdGVtLnByb3RvdHlwZSwgXCJwYWRkaW5nWVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBMZWdlbmRJdGVtLnByb3RvdHlwZSwgXCJzaG93U2VyaWVzU3Ryb2tlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgTGVnZW5kSXRlbS5wcm90b3R5cGUsIFwibWFya2VyXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgTGVnZW5kSXRlbS5wcm90b3R5cGUsIFwibGFiZWxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBMZWdlbmRJdGVtLnByb3RvdHlwZSwgXCJsaW5lXCIsIDIpO1xudmFyIExlZ2VuZExpc3RlbmVycyA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZVTkNUSU9OLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBMZWdlbmRMaXN0ZW5lcnMucHJvdG90eXBlLCBcImxlZ2VuZEl0ZW1DbGlja1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZVTkNUSU9OLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBMZWdlbmRMaXN0ZW5lcnMucHJvdG90eXBlLCBcImxlZ2VuZEl0ZW1Eb3VibGVDbGlja1wiLCAyKTtcbnZhciBJRF9MRUdFTkRfVklTSUJJTElUWSA9IFwibGVnZW5kLXZpc2liaWxpdHlcIjtcbnZhciBJRF9MRUdFTkRfT1RIRVJfU0VSSUVTID0gXCJsZWdlbmQtb3RoZXItc2VyaWVzXCI7XG52YXIgTGVnZW5kSXRlbUV2ZW50ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBlbmFibGVkLCBpdGVtSWQsIHNlcmllc0lkLCBldmVudCkge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5lbmFibGVkID0gZW5hYmxlZDtcbiAgICB0aGlzLml0ZW1JZCA9IGl0ZW1JZDtcbiAgICB0aGlzLnNlcmllc0lkID0gc2VyaWVzSWQ7XG4gICAgdGhpcy5ldmVudCA9IGV2ZW50O1xuICAgIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IGZhbHNlO1xuICB9XG4gIHByZXZlbnREZWZhdWx0KCkge1xuICAgIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gIH1cbn07XG52YXIgTGVnZW5kID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKGN0eCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy5pZCA9IGNyZWF0ZUlkKHRoaXMpO1xuICAgIHRoaXMuZ3JvdXAgPSBuZXcgVHJhbnNsYXRhYmxlTGF5ZXIoeyBuYW1lOiBcImxlZ2VuZFwiLCB6SW5kZXg6IDE1IC8qIExFR0VORCAqLyB9KTtcbiAgICB0aGlzLml0ZW1TZWxlY3Rpb24gPSBTZWxlY3Rpb24uc2VsZWN0KFxuICAgICAgdGhpcy5ncm91cCxcbiAgICAgIExlZ2VuZE1hcmtlckxhYmVsXG4gICAgKTtcbiAgICB0aGlzLnNwcml0ZVJlbmRlcmVyID0gdm9pZCAwO1xuICAgIHRoaXMub2xkU2l6ZSA9IFswLCAwXTtcbiAgICB0aGlzLnBhZ2VzID0gW107XG4gICAgdGhpcy5tYXhQYWdlU2l6ZSA9IFswLCAwXTtcbiAgICAvKiogSXRlbSBpbmRleCB0byB0cmFjayBvbiByZS1wYWdpbmF0aW9uLCBzbyBjdXJyZW50IHBhZ2UgdXBkYXRlcyBhcHByb3ByaWF0ZWx5LiAqL1xuICAgIHRoaXMucGFnaW5hdGlvblRyYWNraW5nSW5kZXggPSAwO1xuICAgIHRoaXMudHJ1bmNhdGVkSXRlbXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMuX2RhdGEgPSBbXTtcbiAgICB0aGlzLl9zeW1ib2xzRGlydHkgPSB0cnVlO1xuICAgIHRoaXMudG9nZ2xlU2VyaWVzID0gdHJ1ZTtcbiAgICB0aGlzLml0ZW0gPSBuZXcgTGVnZW5kSXRlbSgpO1xuICAgIHRoaXMubGlzdGVuZXJzID0gbmV3IExlZ2VuZExpc3RlbmVycygpO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5wb3NpdGlvbiA9IFwiYm90dG9tXCI7XG4gICAgdGhpcy5zcGFjaW5nID0gMjA7XG4gICAgdGhpcy5kZXN0cm95Rm5zID0gW107XG4gICAgdGhpcy5wcm94eUxlZ2VuZERpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzLnByb3h5TGVnZW5kVG9vbGJhckRlc3Ryb3lGbnMgPSBuZXcgRGVzdHJveUZucygpO1xuICAgIHRoaXMuc2l6ZSA9IFswLCAwXTtcbiAgICB0aGlzLl92aXNpYmxlID0gdHJ1ZTtcbiAgICB0aGlzLml0ZW0ubWFya2VyLnBhcmVudCA9IHRoaXM7XG4gICAgdGhpcy5wYWdpbmF0aW9uID0gbmV3IFBhZ2luYXRpb24oXG4gICAgICAodHlwZSkgPT4gY3R4LnVwZGF0ZVNlcnZpY2UudXBkYXRlKHR5cGUpLFxuICAgICAgKHBhZ2UpID0+IHRoaXMudXBkYXRlUGFnZU51bWJlcihwYWdlKVxuICAgICk7XG4gICAgdGhpcy5wYWdpbmF0aW9uLmF0dGFjaFBhZ2luYXRpb24odGhpcy5ncm91cCk7XG4gICAgdGhpcy5kZXN0cm95Rm5zLnB1c2goXG4gICAgICBjdHguY29udGV4dE1lbnVSZWdpc3RyeS5yZWdpc3RlckRlZmF1bHRBY3Rpb24oe1xuICAgICAgICBpZDogSURfTEVHRU5EX1ZJU0lCSUxJVFksXG4gICAgICAgIHR5cGU6IFwibGVnZW5kXCIsXG4gICAgICAgIGxhYmVsOiBcImNvbnRleHRNZW51VG9nZ2xlU2VyaWVzVmlzaWJpbGl0eVwiLFxuICAgICAgICBhY3Rpb246IChwYXJhbXMpID0+IHRoaXMuY29udGV4dFRvZ2dsZVZpc2liaWxpdHkocGFyYW1zKVxuICAgICAgfSksXG4gICAgICBjdHguY29udGV4dE1lbnVSZWdpc3RyeS5yZWdpc3RlckRlZmF1bHRBY3Rpb24oe1xuICAgICAgICBpZDogSURfTEVHRU5EX09USEVSX1NFUklFUyxcbiAgICAgICAgdHlwZTogXCJsZWdlbmRcIixcbiAgICAgICAgbGFiZWw6IFwiY29udGV4dE1lbnVUb2dnbGVPdGhlclNlcmllc1wiLFxuICAgICAgICBhY3Rpb246IChwYXJhbXMpID0+IHRoaXMuY29udGV4dFRvZ2dsZU90aGVyU2VyaWVzKHBhcmFtcylcbiAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMucHVzaChcbiAgICAgIGN0eC5sYXlvdXRNYW5hZ2VyLnJlZ2lzdGVyRWxlbWVudCgxIC8qIExlZ2VuZCAqLywgKGUpID0+IHRoaXMucG9zaXRpb25MZWdlbmQoZSkpLFxuICAgICAgY3R4LmxvY2FsZU1hbmFnZXIuYWRkTGlzdGVuZXIoXCJsb2NhbGUtY2hhbmdlZFwiLCAoKSA9PiB0aGlzLm9uTG9jYWxlQ2hhbmdlZCgpKSxcbiAgICAgICgpID0+IHRoaXMuZ3JvdXAucmVtb3ZlKClcbiAgICApO1xuICAgIHRoaXMucHJveHlMZWdlbmRUb29sYmFyID0gdGhpcy5jdHgucHJveHlJbnRlcmFjdGlvblNlcnZpY2UuY3JlYXRlUHJveHlDb250YWluZXIoe1xuICAgICAgdHlwZTogXCJsaXN0XCIsXG4gICAgICBpZDogYCR7dGhpcy5pZH0tdG9vbGJhcmAsXG4gICAgICBjbGFzc0xpc3Q6IFtcImFnLWNoYXJ0cy1wcm94eS1sZWdlbmQtdG9vbGJhclwiXSxcbiAgICAgIGFyaWFMYWJlbDogeyBpZDogXCJhcmlhTGFiZWxMZWdlbmRcIiB9LFxuICAgICAgYXJpYUhpZGRlbjogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMucHJveHlMZWdlbmRQYWdpbmF0aW9uID0gdGhpcy5jdHgucHJveHlJbnRlcmFjdGlvblNlcnZpY2UuY3JlYXRlUHJveHlDb250YWluZXIoe1xuICAgICAgdHlwZTogXCJncm91cFwiLFxuICAgICAgaWQ6IGAke3RoaXMuaWR9LXBhZ2luYXRpb25gLFxuICAgICAgY2xhc3NMaXN0OiBbXCJhZy1jaGFydHMtcHJveHktbGVnZW5kLXBhZ2luYXRpb25cIl0sXG4gICAgICBhcmlhTGFiZWw6IHsgaWQ6IFwiYXJpYUxhYmVsTGVnZW5kUGFnaW5hdGlvblwiIH0sXG4gICAgICBhcmlhT3JpZW50YXRpb246IFwiaG9yaXpvbnRhbFwiLFxuICAgICAgYXJpYUhpZGRlbjogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMucHJveHlMZWdlbmRJdGVtRGVzY3JpcHRpb24gPSBjcmVhdGVFbGVtZW50KFwicFwiKTtcbiAgICB0aGlzLnByb3h5TGVnZW5kSXRlbURlc2NyaXB0aW9uLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICB0aGlzLnByb3h5TGVnZW5kSXRlbURlc2NyaXB0aW9uLmlkID0gYCR7dGhpcy5pZH0tYXJpYURlc2NyaXB0aW9uYDtcbiAgICB0aGlzLnByb3h5TGVnZW5kSXRlbURlc2NyaXB0aW9uLnRleHRDb250ZW50ID0gdGhpcy5nZXRJdGVtQXJpYURlc2NyaXB0aW9uKCk7XG4gICAgdGhpcy5wcm94eUxlZ2VuZFRvb2xiYXIuYXBwZW5kKHRoaXMucHJveHlMZWdlbmRJdGVtRGVzY3JpcHRpb24pO1xuICB9XG4gIHNldCBkYXRhKHZhbHVlKSB7XG4gICAgdGhpcy5vbkRhdGFVcGRhdGUodGhpcy5fZGF0YSwgdmFsdWUpO1xuICAgIHRoaXMuX2RhdGEgPSB2YWx1ZTtcbiAgICB0aGlzLl9zeW1ib2xzRGlydHkgPSB0cnVlO1xuICAgIHRoaXMudXBkYXRlR3JvdXBWaXNpYmlsaXR5KCk7XG4gIH1cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmN0eC5kb21NYW5hZ2VyLnJlbW92ZUNoaWxkKFwiY2FudmFzLW92ZXJsYXlcIiwgYCR7dGhpcy5pZH0tdG9vbGJhcmApO1xuICAgIHRoaXMuY3R4LmRvbU1hbmFnZXIucmVtb3ZlQ2hpbGQoXCJjYW52YXMtb3ZlcmxheVwiLCBgJHt0aGlzLmlkfS1wYWdpbmF0aW9uYCk7XG4gICAgdGhpcy5kZXN0cm95Rm5zLmZvckVhY2goKGYpID0+IGYoKSk7XG4gICAgdGhpcy5wYWdpbmF0aW9uLmRlc3Ryb3koKTtcbiAgICB0aGlzLml0ZW1TZWxlY3Rpb24uY2xlYXIoKTtcbiAgICB0aGlzLnByb3h5TGVnZW5kVG9vbGJhckRlc3Ryb3lGbnMuZGVzdHJveSgpO1xuICB9XG4gIGluaXRMZWdlbmRJdGVtVG9vbGJhcigpIHtcbiAgICBpZiAoIXRoaXMucHJveHlMZWdlbmREaXJ0eSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLml0ZW1TZWxlY3Rpb24uZWFjaCgobWFya2VyTGFiZWwsIF8sIGkpID0+IHtcbiAgICAgIG1hcmtlckxhYmVsLmRlc3Ryb3lQcm94eUJ1dHRvbigpO1xuICAgICAgbWFya2VyTGFiZWwucHJveHlCdXR0b24gPz8gKG1hcmtlckxhYmVsLnByb3h5QnV0dG9uID0gdGhpcy5jdHgucHJveHlJbnRlcmFjdGlvblNlcnZpY2UuY3JlYXRlUHJveHlFbGVtZW50KHtcbiAgICAgICAgdHlwZTogXCJsaXN0c3dpdGNoXCIsXG4gICAgICAgIGlkOiBgYWctY2hhcnRzLWxlZ2VuZC1pdGVtLSR7aX1gLFxuICAgICAgICB0ZXh0Q29udGVudDogdGhpcy5nZXRJdGVtQXJpYVRleHQoaSksXG4gICAgICAgIGFyaWFDaGVja2VkOiAhIW1hcmtlckxhYmVsLmRhdHVtLmVuYWJsZWQsXG4gICAgICAgIGFyaWFEZXNjcmliZWRCeTogdGhpcy5wcm94eUxlZ2VuZEl0ZW1EZXNjcmlwdGlvbi5pZCxcbiAgICAgICAgcGFyZW50OiB0aGlzLnByb3h5TGVnZW5kVG9vbGJhcixcbiAgICAgICAgLy8gUmV0cmlldmUgdGhlIGRhdHVtIGZyb20gdGhlIG5vZGUgcmF0aGVyIHRoYW4gZnJvbSB0aGUgbWV0aG9kIHBhcmFtZXRlci5cbiAgICAgICAgLy8gVGhlIG1ldGhvZCBwYXJhbWV0ZXIgYGRhdHVtYCBnZXRzIGRlc3Ryb3llZCB3aGVuIHRoZSBkYXRhIGlzIHJlZnJlc2hlZFxuICAgICAgICAvLyB1c2luZyBTZXJpZXMuZ2V0TGVnZW5kRGF0YSgpLiBCdXQgdGhlIHNjZW5lIG5vZGUgd2lsbCBzdGF5IHRoZSBzYW1lLlxuICAgICAgICBvbmNsaWNrOiAoZXYpID0+IHRoaXMub25DbGljayhldiwgbWFya2VyTGFiZWwuZGF0dW0sIG1hcmtlckxhYmVsLnByb3h5QnV0dG9uLmJ1dHRvbiksXG4gICAgICAgIG9uZGJsY2xpY2s6IChldikgPT4gdGhpcy5vbkRvdWJsZUNsaWNrKGV2LCBtYXJrZXJMYWJlbC5kYXR1bSksXG4gICAgICAgIG9ubW91c2VlbnRlcjogKGV2KSA9PiB0aGlzLm9uSG92ZXIoZXYsIG1hcmtlckxhYmVsKSxcbiAgICAgICAgb25tb3VzZWxlYXZlOiAoKSA9PiB0aGlzLm9uTGVhdmUoKSxcbiAgICAgICAgb25jb250ZXh0bWVudTogKGV2KSA9PiB0aGlzLm9uQ29udGV4dENsaWNrKGV2LCBtYXJrZXJMYWJlbCksXG4gICAgICAgIG9uYmx1cjogKCkgPT4gdGhpcy5vbkxlYXZlKCksXG4gICAgICAgIG9uZm9jdXM6IChldikgPT4gdGhpcy5vbkhvdmVyKGV2LCBtYXJrZXJMYWJlbClcbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgICBjb25zdCBidXR0b25zID0gdGhpcy5pdGVtU2VsZWN0aW9uLm5vZGVzKCkubWFwKChtYXJrZXJMYWJlbCkgPT4gbWFya2VyTGFiZWwucHJveHlCdXR0b24/LmJ1dHRvbikuZmlsdGVyKGlzRGVmaW5lZCk7XG4gICAgdGhpcy5wcm94eUxlZ2VuZFRvb2xiYXJEZXN0cm95Rm5zLnNldEZucyhbXG4gICAgICAuLi5pbml0Um92aW5nVGFiSW5kZXgoeyBvcmllbnRhdGlvbjogXCJob3Jpem9udGFsXCIsIGJ1dHRvbnMgfSksXG4gICAgICAuLi5pbml0Um92aW5nVGFiSW5kZXgoeyBvcmllbnRhdGlvbjogXCJ2ZXJ0aWNhbFwiLCBidXR0b25zIH0pXG4gICAgXSk7XG4gICAgdGhpcy5wcm94eUxlZ2VuZFRvb2xiYXIuYXJpYUhpZGRlbiA9IChidXR0b25zLmxlbmd0aCA9PT0gMCkudG9TdHJpbmcoKTtcbiAgICB0aGlzLnByb3h5TGVnZW5kRGlydHkgPSBmYWxzZTtcbiAgfVxuICBvbkRhdGFVcGRhdGUob2xkRGF0YSwgbmV3RGF0YSkge1xuICAgIHRoaXMucHJveHlMZWdlbmREaXJ0eSA9IG9sZERhdGEubGVuZ3RoICE9PSBuZXdEYXRhLmxlbmd0aCB8fCBvbGREYXRhLnNvbWUoKF92LCBpbmRleCwgX2EpID0+IHtcbiAgICAgIGNvbnN0IFtuZXdWYWx1ZSwgb2xkVmFsdWVdID0gW25ld0RhdGFbaW5kZXhdLCBvbGREYXRhW2luZGV4XV07XG4gICAgICByZXR1cm4gbmV3VmFsdWUuaWQgIT09IG9sZFZhbHVlLmlkO1xuICAgIH0pO1xuICB9XG4gIG9uTWFya2VyU2hhcGVDaGFuZ2UoKSB7XG4gICAgdGhpcy5pdGVtU2VsZWN0aW9uLmNsZWFyKCk7XG4gICAgdGhpcy5ncm91cC5tYXJrRGlydHkoMiAvKiBNSU5PUiAqLyk7XG4gIH1cbiAgZ2V0T3JpZW50YXRpb24oKSB7XG4gICAgaWYgKHRoaXMub3JpZW50YXRpb24gIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRoaXMub3JpZW50YXRpb247XG4gICAgfVxuICAgIHN3aXRjaCAodGhpcy5wb3NpdGlvbikge1xuICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgICByZXR1cm4gXCJ2ZXJ0aWNhbFwiO1xuICAgICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgY2FzZSBcInRvcFwiOlxuICAgICAgICByZXR1cm4gXCJob3Jpem9udGFsXCI7XG4gICAgfVxuICB9XG4gIHNldCB2aXNpYmxlKHZhbHVlKSB7XG4gICAgdGhpcy5fdmlzaWJsZSA9IHZhbHVlO1xuICAgIHRoaXMudXBkYXRlR3JvdXBWaXNpYmlsaXR5KCk7XG4gIH1cbiAgZ2V0IHZpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Zpc2libGU7XG4gIH1cbiAgdXBkYXRlR3JvdXBWaXNpYmlsaXR5KCkge1xuICAgIHRoaXMuZ3JvdXAudmlzaWJsZSA9IHRoaXMuZW5hYmxlZCAmJiB0aGlzLnZpc2libGUgJiYgdGhpcy5kYXRhLmxlbmd0aCA+IDA7XG4gIH1cbiAgYXR0YWNoTGVnZW5kKHNjZW5lKSB7XG4gICAgc2NlbmUuYXBwZW5kQ2hpbGQodGhpcy5ncm91cCk7XG4gIH1cbiAgZ2V0SXRlbUxhYmVsKGRhdHVtKSB7XG4gICAgY29uc3Qge1xuICAgICAgY3R4OiB7IGNhbGxiYWNrQ2FjaGUgfVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgZm9ybWF0dGVyIH0gPSB0aGlzLml0ZW0ubGFiZWw7XG4gICAgaWYgKGZvcm1hdHRlcikge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrQ2FjaGUuY2FsbChmb3JtYXR0ZXIsIHtcbiAgICAgICAgaXRlbUlkOiBkYXR1bS5pdGVtSWQsXG4gICAgICAgIHZhbHVlOiBkYXR1bS5sYWJlbC50ZXh0LFxuICAgICAgICBzZXJpZXNJZDogZGF0dW0uc2VyaWVzSWRcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZGF0dW0ubGFiZWwudGV4dDtcbiAgfVxuICAvKipcbiAgICogVGhlIG1ldGhvZCBpcyBnaXZlbiB0aGUgZGVzaXJlZCBzaXplIG9mIHRoZSBsZWdlbmQsIHdoaWNoIG9ubHkgc2VydmVzIGFzIGEgaGludC5cbiAgICogVGhlIHZlcnRpY2FsbHkgb3JpZW50ZWQgbGVnZW5kIHdpbGwgdGFrZSBhcyBtdWNoIGhvcml6b250YWwgc3BhY2UgYXMgbmVlZGVkLCBidXQgd2lsbFxuICAgKiByZXNwZWN0IHRoZSBoZWlnaHQgY29uc3RyYWludHMsIGFuZCB0aGUgaG9yaXpvbnRhbCBsZWdlbmQgd2lsbCB0YWtlIGFzIG11Y2ggdmVydGljYWxcbiAgICogc3BhY2UgYXMgbmVlZGVkIGluIGFuIGF0dGVtcHQgbm90IHRvIGV4Y2VlZCB0aGUgZ2l2ZW4gd2lkdGguXG4gICAqIEFmdGVyIHRoZSBsYXlvdXQgaXMgZG9uZSwgdGhlIHtAbGluayBzaXplfSB3aWxsIGNvbnRhaW4gdGhlIGFjdHVhbCBzaXplIG9mIHRoZSBsZWdlbmQuXG4gICAqIElmIHRoZSBhY3R1YWwgc2l6ZSBpcyBub3QgdGhlIHNhbWUgYXMgdGhlIHByZXZpb3VzIGFjdHVhbCBzaXplLCB0aGUgbGVnZW5kIHdpbGwgZmlyZVxuICAgKiB0aGUgJ2xheW91dENoYW5nZScgZXZlbnQgdG8gY29tbXVuaWNhdGUgdGhhdCBhbm90aGVyIGxheW91dCBpcyBuZWVkZWQsIGFuZCB0aGUgYWJvdmVcbiAgICogcHJvY2VzcyBzaG91bGQgYmUgcmVwZWF0ZWQuXG4gICAqIEBwYXJhbSB3aWR0aFxuICAgKiBAcGFyYW0gaGVpZ2h0XG4gICAqL1xuICBjYWxjTGF5b3V0KHdpZHRoMiwgaGVpZ2h0Mikge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhZGRpbmdYLFxuICAgICAgcGFkZGluZ1ksXG4gICAgICBsYWJlbCxcbiAgICAgIG1heFdpZHRoLFxuICAgICAgbGFiZWw6IHsgbWF4TGVuZ3RoID0gSW5maW5pdHksIGZvbnRTdHlsZSwgZm9udFdlaWdodCwgZm9udFNpemUsIGZvbnRGYW1pbHkgfVxuICAgIH0gPSB0aGlzLml0ZW07XG4gICAgY29uc3QgZGF0YSA9IFsuLi50aGlzLmRhdGFdO1xuICAgIGlmICh0aGlzLnJldmVyc2VPcmRlcikge1xuICAgICAgZGF0YS5yZXZlcnNlKCk7XG4gICAgfVxuICAgIHRoaXMuaXRlbVNlbGVjdGlvbi51cGRhdGUoZGF0YSk7XG4gICAgdGhpcy5pbml0TGVnZW5kSXRlbVRvb2xiYXIoKTtcbiAgICBjb25zdCBiYm94ZXMgPSBbXTtcbiAgICBjb25zdCBmb250ID0gVGV4dFV0aWxzLnRvRm9udFN0cmluZyhsYWJlbCk7XG4gICAgY29uc3QgaXRlbU1heFdpZHRoUGVyY2VudGFnZSA9IDAuODtcbiAgICBjb25zdCBtYXhJdGVtV2lkdGggPSBtYXhXaWR0aCA/PyB3aWR0aDIgKiBpdGVtTWF4V2lkdGhQZXJjZW50YWdlO1xuICAgIGNvbnN0IHNwcml0ZURpbXMgPSB0aGlzLmNhbGN1bGF0ZVNwcml0ZURpbWVuc2lvbnMoKTtcbiAgICB0aGlzLnNwcml0ZVJlbmRlcmVyID8/ICh0aGlzLnNwcml0ZVJlbmRlcmVyID0gbmV3IFNwcml0ZVJlbmRlcmVyKCkpO1xuICAgIHRoaXMuc3ByaXRlUmVuZGVyZXIucmVzaXplKHNwcml0ZURpbXMpO1xuICAgIHRoaXMuaXRlbVNlbGVjdGlvbi5lYWNoKChtYXJrZXJMYWJlbCwgZGF0dW0pID0+IHtcbiAgICAgIG1hcmtlckxhYmVsLmZvbnRTdHlsZSA9IGZvbnRTdHlsZTtcbiAgICAgIG1hcmtlckxhYmVsLmZvbnRXZWlnaHQgPSBmb250V2VpZ2h0O1xuICAgICAgbWFya2VyTGFiZWwuZm9udFNpemUgPSBmb250U2l6ZTtcbiAgICAgIG1hcmtlckxhYmVsLmZvbnRGYW1pbHkgPSBmb250RmFtaWx5O1xuICAgICAgY29uc3QgcGFkZGVkU3ltYm9sV2lkdGggPSB0aGlzLnVwZGF0ZU1hcmtlckxhYmVsKHRoaXMuc3ByaXRlUmVuZGVyZXIsIG1hcmtlckxhYmVsLCBkYXR1bSwgc3ByaXRlRGltcyk7XG4gICAgICBjb25zdCBpZCA9IGRhdHVtLml0ZW1JZCA/PyBkYXR1bS5pZDtcbiAgICAgIGNvbnN0IGxhYmVsVGV4dCA9IHRoaXMuZ2V0SXRlbUxhYmVsKGRhdHVtKTtcbiAgICAgIGNvbnN0IHRleHQgPSAobGFiZWxUZXh0ID8/IFwiPHVua25vd24+XCIpLnJlcGxhY2UoL1xccj9cXG4vZywgXCIgXCIpO1xuICAgICAgbWFya2VyTGFiZWwudGV4dCA9IHRoaXMudHJ1bmNhdGUodGV4dCwgbWF4TGVuZ3RoLCBtYXhJdGVtV2lkdGgsIHBhZGRlZFN5bWJvbFdpZHRoLCBmb250LCBpZCk7XG4gICAgICBiYm94ZXMucHVzaChtYXJrZXJMYWJlbC5nZXRCQm94KCkpO1xuICAgIH0pO1xuICAgIHRoaXMuX3N5bWJvbHNEaXJ0eSA9IGZhbHNlO1xuICAgIHdpZHRoMiA9IE1hdGgubWF4KDEsIHdpZHRoMik7XG4gICAgaGVpZ2h0MiA9IE1hdGgubWF4KDEsIGhlaWdodDIpO1xuICAgIGlmICghaXNGaW5pdGUod2lkdGgyKSkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBjb25zdCBzaXplID0gdGhpcy5zaXplO1xuICAgIGNvbnN0IG9sZFNpemUgPSB0aGlzLm9sZFNpemU7XG4gICAgc2l6ZVswXSA9IHdpZHRoMjtcbiAgICBzaXplWzFdID0gaGVpZ2h0MjtcbiAgICBpZiAoc2l6ZVswXSAhPT0gb2xkU2l6ZVswXSB8fCBzaXplWzFdICE9PSBvbGRTaXplWzFdKSB7XG4gICAgICBvbGRTaXplWzBdID0gc2l6ZVswXTtcbiAgICAgIG9sZFNpemVbMV0gPSBzaXplWzFdO1xuICAgIH1cbiAgICBjb25zdCB7IHBhZ2VzLCBtYXhQYWdlSGVpZ2h0LCBtYXhQYWdlV2lkdGggfSA9IHRoaXMudXBkYXRlUGFnaW5hdGlvbihiYm94ZXMsIHdpZHRoMiwgaGVpZ2h0Mik7XG4gICAgY29uc3Qgb2xkUGFnZXMgPSB0aGlzLnBhZ2VzO1xuICAgIHRoaXMucGFnZXMgPSBwYWdlcztcbiAgICB0aGlzLm1heFBhZ2VTaXplID0gW21heFBhZ2VXaWR0aCAtIHBhZGRpbmdYLCBtYXhQYWdlSGVpZ2h0IC0gcGFkZGluZ1ldO1xuICAgIGNvbnN0IHBhZ2VOdW1iZXIgPSB0aGlzLnBhZ2luYXRpb24uY3VycmVudFBhZ2U7XG4gICAgY29uc3QgcGFnZSA9IHRoaXMucGFnZXNbcGFnZU51bWJlcl07XG4gICAgaWYgKHRoaXMucGFnZXMubGVuZ3RoIDwgMSB8fCAhcGFnZSkge1xuICAgICAgdGhpcy52aXNpYmxlID0gZmFsc2U7XG4gICAgICByZXR1cm4geyBvbGRQYWdlcyB9O1xuICAgIH1cbiAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuICAgIHRoaXMudXBkYXRlUG9zaXRpb25zKHBhZ2VOdW1iZXIpO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gICAgcmV0dXJuIHsgb2xkUGFnZXMgfTtcbiAgfVxuICBpc0N1c3RvbU1hcmtlcihtYXJrZXJFbmFibGVkLCBzaGFwZSkge1xuICAgIHJldHVybiBtYXJrZXJFbmFibGVkICYmIHNoYXBlICE9PSB2b2lkIDAgJiYgdHlwZW9mIHNoYXBlICE9PSBcInN0cmluZ1wiO1xuICB9XG4gIGNhbGNTeW1ib2xzRW5hYmxlZChzeW1ib2wpIHtcbiAgICBjb25zdCB7IHNob3dTZXJpZXNTdHJva2UsIG1hcmtlciB9ID0gdGhpcy5pdGVtO1xuICAgIGNvbnN0IG1hcmtlckVuYWJsZWQgPSAhIW1hcmtlci5lbmFibGVkIHx8ICFzaG93U2VyaWVzU3Ryb2tlIHx8IChzeW1ib2wubWFya2VyLmVuYWJsZWQgPz8gdHJ1ZSk7XG4gICAgY29uc3QgbGluZUVuYWJsZWQgPSAhIShzeW1ib2wubGluZSAmJiBzaG93U2VyaWVzU3Ryb2tlKTtcbiAgICBjb25zdCBpc0N1c3RvbU1hcmtlciA9IHRoaXMuaXNDdXN0b21NYXJrZXIobWFya2VyRW5hYmxlZCwgc3ltYm9sLm1hcmtlci5zaGFwZSk7XG4gICAgcmV0dXJuIHsgbWFya2VyRW5hYmxlZCwgbGluZUVuYWJsZWQsIGlzQ3VzdG9tTWFya2VyIH07XG4gIH1cbiAgY2FsY1N5bWJvbHNMZW5ndGhzKHN5bWJvbCkge1xuICAgIGNvbnN0IHsgbWFya2VyLCBsaW5lIH0gPSB0aGlzLml0ZW07XG4gICAgY29uc3QgeyBtYXJrZXJFbmFibGVkLCBsaW5lRW5hYmxlZCB9ID0gdGhpcy5jYWxjU3ltYm9sc0VuYWJsZWQoc3ltYm9sKTtcbiAgICBjb25zdCB7IHN0cm9rZVdpZHRoOiBtYXJrZXJTdHJva2VXaWR0aCB9ID0gdGhpcy5nZXRNYXJrZXJTdHlsZXMoc3ltYm9sKTtcbiAgICBjb25zdCB7IHN0cm9rZVdpZHRoOiBsaW5lU3Ryb2tlV2lkdGggfSA9IGxpbmVFbmFibGVkID8gdGhpcy5nZXRMaW5lU3R5bGVzKHN5bWJvbCkgOiB7IHN0cm9rZVdpZHRoOiAwIH07XG4gICAgbGV0IGN1c3RvbU1hcmtlclNpemU7XG4gICAgY29uc3QgeyBzaGFwZSB9ID0gc3ltYm9sLm1hcmtlcjtcbiAgICBpZiAodGhpcy5pc0N1c3RvbU1hcmtlcihtYXJrZXJFbmFibGVkLCBzaGFwZSkpIHtcbiAgICAgIGNvbnN0IHRtcFNoYXBlID0gbmV3IHNoYXBlKCk7XG4gICAgICB0bXBTaGFwZS51cGRhdGVQYXRoKCk7XG4gICAgICBjb25zdCBiYm94ID0gdG1wU2hhcGUuZ2V0QkJveCgpO1xuICAgICAgY3VzdG9tTWFya2VyU2l6ZSA9IE1hdGgubWF4KGJib3gud2lkdGgsIGJib3guaGVpZ2h0KTtcbiAgICB9XG4gICAgY29uc3QgbWFya2VyTGVuZ3RoID0gbWFya2VyRW5hYmxlZCA/IG1hcmtlci5zaXplIDogMDtcbiAgICBjb25zdCBsaW5lTGVuZ3RoID0gbGluZUVuYWJsZWQgPyBsaW5lLmxlbmd0aCA/PyAyNSA6IDA7XG4gICAgcmV0dXJuIHsgbWFya2VyTGVuZ3RoLCBtYXJrZXJTdHJva2VXaWR0aCwgbGluZUxlbmd0aCwgbGluZVN0cm9rZVdpZHRoLCBjdXN0b21NYXJrZXJTaXplIH07XG4gIH1cbiAgY2FsY3VsYXRlU3ByaXRlRGltZW5zaW9ucygpIHtcbiAgICBsZXQgc3ByaXRlQUFQYWRkaW5nID0gMDtcbiAgICBsZXQgc3ByaXRlV2lkdGggPSAwO1xuICAgIGxldCBzcHJpdGVIZWlnaHQgPSAwO1xuICAgIGxldCBtYXJrZXJXaWR0aCA9IDA7XG4gICAgdGhpcy5pdGVtU2VsZWN0aW9uLmVhY2goKF8sIGRhdHVtKSA9PiB7XG4gICAgICBkYXR1bS5zeW1ib2xzLmZvckVhY2goKHN5bWJvbCkgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgbWFya2VyTGVuZ3RoLFxuICAgICAgICAgIG1hcmtlclN0cm9rZVdpZHRoLFxuICAgICAgICAgIGxpbmVMZW5ndGgsXG4gICAgICAgICAgbGluZVN0cm9rZVdpZHRoLFxuICAgICAgICAgIGN1c3RvbU1hcmtlclNpemUgPSAtSW5maW5pdHlcbiAgICAgICAgfSA9IHRoaXMuY2FsY1N5bWJvbHNMZW5ndGhzKHN5bWJvbCk7XG4gICAgICAgIGNvbnN0IG1hcmtlclRvdGFsTGVuZ3RoID0gbWFya2VyTGVuZ3RoICsgbWFya2VyU3Ryb2tlV2lkdGg7XG4gICAgICAgIG1hcmtlcldpZHRoID0gTWF0aC5tYXgobWFya2VyV2lkdGgsIGxpbmVMZW5ndGgsIGN1c3RvbU1hcmtlclNpemUsIG1hcmtlckxlbmd0aCk7XG4gICAgICAgIHNwcml0ZVdpZHRoID0gTWF0aC5tYXgoc3ByaXRlV2lkdGgsIGxpbmVMZW5ndGgsIGN1c3RvbU1hcmtlclNpemUsIG1hcmtlclRvdGFsTGVuZ3RoKTtcbiAgICAgICAgc3ByaXRlSGVpZ2h0ID0gTWF0aC5tYXgoc3ByaXRlSGVpZ2h0LCBsaW5lU3Ryb2tlV2lkdGgsIG1hcmtlclRvdGFsTGVuZ3RoKTtcbiAgICAgICAgc3ByaXRlQUFQYWRkaW5nID0gTWF0aC5tYXgoc3ByaXRlQUFQYWRkaW5nLCBtYXJrZXJTdHJva2VXaWR0aCArIDAuNSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBzcHJpdGVXaWR0aCArPSBzcHJpdGVBQVBhZGRpbmcgKiAyO1xuICAgIHNwcml0ZUhlaWdodCArPSBzcHJpdGVBQVBhZGRpbmcgKiAyO1xuICAgIGNvbnN0IHNwcml0ZVBpeGVsUmF0aW8gPSBnZXRXaW5kb3coKS5kZXZpY2VQaXhlbFJhdGlvO1xuICAgIHJldHVybiB7IHNwcml0ZVBpeGVsUmF0aW8sIHNwcml0ZUFBUGFkZGluZywgc3ByaXRlV2lkdGgsIHNwcml0ZUhlaWdodCwgbWFya2VyV2lkdGggfTtcbiAgfVxuICB1cGRhdGVNYXJrZXJMYWJlbChzcHJpdGVSZW5kZXJlciwgbWFya2VyTGFiZWwsIGRhdHVtLCBzcHJpdGVEaW1zKSB7XG4gICAgY29uc3QgeyBtYXJrZXI6IGl0ZW1NYXJrZXIsIHBhZGRpbmdYIH0gPSB0aGlzLml0ZW07XG4gICAgY29uc3QgeyBtYXJrZXJXaWR0aCB9ID0gc3ByaXRlRGltcztcbiAgICBjb25zdCBkaW1lbnNpb25Qcm9wcyA9IFtdO1xuICAgIGxldCBwYWRkZWRTeW1ib2xXaWR0aCA9IHBhZGRpbmdYO1xuICAgIGlmICh0aGlzLl9zeW1ib2xzRGlydHkpIHtcbiAgICAgIGNvbnN0IG1hcmtlcnMgPSBbXTtcbiAgICAgIGNvbnN0IGxpbmVzID0gW107XG4gICAgICBkYXR1bS5zeW1ib2xzLmZvckVhY2goKHN5bWJvbCkgPT4ge1xuICAgICAgICBjb25zdCB7IHNoYXBlOiBtYXJrZXJTaGFwZSA9IHN5bWJvbC5tYXJrZXIuc2hhcGUgfSA9IGl0ZW1NYXJrZXI7XG4gICAgICAgIGNvbnN0IE1hcmtlckN0ciA9IGdldE1hcmtlcihtYXJrZXJTaGFwZSk7XG4gICAgICAgIGxpbmVzLnB1c2gobmV3IExpbmUoeyB6SW5kZXg6IDAgfSkpO1xuICAgICAgICBtYXJrZXJzLnB1c2gobmV3IE1hcmtlckN0cih7IHpJbmRleDogMSB9KSk7XG4gICAgICB9KTtcbiAgICAgIG1hcmtlckxhYmVsLnVwZGF0ZVN5bWJvbHMobWFya2VycywgbGluZXMpO1xuICAgIH1cbiAgICBkYXR1bS5zeW1ib2xzLmZvckVhY2goKHN5bWJvbCwgaSkgPT4ge1xuICAgICAgY29uc3Qgc3BhY2luZyA9IHN5bWJvbC5tYXJrZXIucGFkZGluZyA/PyBpdGVtTWFya2VyLnBhZGRpbmc7XG4gICAgICBjb25zdCB7IG1hcmtlckVuYWJsZWQsIGxpbmVFbmFibGVkLCBpc0N1c3RvbU1hcmtlciB9ID0gdGhpcy5jYWxjU3ltYm9sc0VuYWJsZWQoc3ltYm9sKTtcbiAgICAgIG1hcmtlckxhYmVsLm1hcmtlcnNbaV0uc2l6ZSA9IG1hcmtlckVuYWJsZWQgfHwgIWxpbmVFbmFibGVkID8gaXRlbU1hcmtlci5zaXplIDogMDtcbiAgICAgIGRpbWVuc2lvblByb3BzLnB1c2goeyBsZW5ndGg6IG1hcmtlcldpZHRoLCBzcGFjaW5nLCBpc0N1c3RvbU1hcmtlciB9KTtcbiAgICAgIGlmIChtYXJrZXJFbmFibGVkIHx8IGxpbmVFbmFibGVkKSB7XG4gICAgICAgIHBhZGRlZFN5bWJvbFdpZHRoICs9IHNwYWNpbmcgKyBtYXJrZXJXaWR0aDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1hcmtlciA9IG1hcmtlckxhYmVsLm1hcmtlcnNbaV07XG4gICAgICBjb25zdCBsaW5lID0gbWFya2VyTGFiZWwubGluZXNbaV07XG4gICAgICBpZiAobWFya2VyKSB7XG4gICAgICAgIGNvbnN0IHsgc3Ryb2tlV2lkdGgsIGZpbGwsIHN0cm9rZSwgZmlsbE9wYWNpdHksIHN0cm9rZU9wYWNpdHkgfSA9IHRoaXMuZ2V0TWFya2VyU3R5bGVzKHN5bWJvbCk7XG4gICAgICAgIG1hcmtlci5maWxsID0gZmlsbDtcbiAgICAgICAgbWFya2VyLnN0cm9rZSA9IHN0cm9rZTtcbiAgICAgICAgbWFya2VyLnN0cm9rZVdpZHRoID0gc3Ryb2tlV2lkdGg7XG4gICAgICAgIG1hcmtlci5maWxsT3BhY2l0eSA9IGZpbGxPcGFjaXR5O1xuICAgICAgICBtYXJrZXIuc3Ryb2tlT3BhY2l0eSA9IHN0cm9rZU9wYWNpdHk7XG4gICAgICB9XG4gICAgICBpZiAobGluZSkge1xuICAgICAgICBjb25zdCBsaW5lU3R5bGVzID0gdGhpcy5nZXRMaW5lU3R5bGVzKHN5bWJvbCk7XG4gICAgICAgIGxpbmUuc3Ryb2tlID0gbGluZVN0eWxlcy5zdHJva2U7XG4gICAgICAgIGxpbmUuc3Ryb2tlT3BhY2l0eSA9IGxpbmVTdHlsZXMuc3Ryb2tlT3BhY2l0eTtcbiAgICAgICAgbGluZS5zdHJva2VXaWR0aCA9IGxpbmVTdHlsZXMuc3Ryb2tlV2lkdGg7XG4gICAgICAgIGxpbmUubGluZURhc2ggPSBsaW5lU3R5bGVzLmxpbmVEYXNoO1xuICAgICAgfVxuICAgIH0pO1xuICAgIG1hcmtlckxhYmVsLnVwZGF0ZShzcHJpdGVSZW5kZXJlciwgc3ByaXRlRGltcywgZGltZW5zaW9uUHJvcHMpO1xuICAgIHJldHVybiBwYWRkZWRTeW1ib2xXaWR0aDtcbiAgfVxuICB0cnVuY2F0ZSh0ZXh0LCBtYXhDaGFyTGVuZ3RoLCBtYXhJdGVtV2lkdGgsIHBhZGRlZE1hcmtlcldpZHRoLCBmb250LCBpZCkge1xuICAgIGxldCBhZGRFbGxpcHNpcyA9IGZhbHNlO1xuICAgIGlmICh0ZXh0Lmxlbmd0aCA+IG1heENoYXJMZW5ndGgpIHtcbiAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBtYXhDaGFyTGVuZ3RoKTtcbiAgICAgIGFkZEVsbGlwc2lzID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgbWVhc3VyZXIgPSBDYWNoZWRUZXh0TWVhc3VyZXJQb29sLmdldE1lYXN1cmVyKHsgZm9udCB9KTtcbiAgICBjb25zdCByZXN1bHQgPSBUZXh0V3JhcHBlci50cnVuY2F0ZUxpbmUodGV4dCwgbWVhc3VyZXIsIG1heEl0ZW1XaWR0aCAtIHBhZGRlZE1hcmtlcldpZHRoLCBhZGRFbGxpcHNpcyk7XG4gICAgaWYgKHJlc3VsdC5lbmRzV2l0aChUZXh0VXRpbHMuRWxsaXBzaXNDaGFyKSkge1xuICAgICAgdGhpcy50cnVuY2F0ZWRJdGVtcy5hZGQoaWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRydW5jYXRlZEl0ZW1zLmRlbGV0ZShpZCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgdXBkYXRlUGFnaW5hdGlvbihiYm94ZXMsIHdpZHRoMiwgaGVpZ2h0Mikge1xuICAgIGNvbnN0IG9yaWVudGF0aW9uID0gdGhpcy5nZXRPcmllbnRhdGlvbigpO1xuICAgIGNvbnN0IHRyYWNraW5nSW5kZXggPSBNYXRoLm1pbih0aGlzLnBhZ2luYXRpb25UcmFja2luZ0luZGV4LCBiYm94ZXMubGVuZ3RoKTtcbiAgICB0aGlzLnBhZ2luYXRpb24ub3JpZW50YXRpb24gPSBvcmllbnRhdGlvbjtcbiAgICB0aGlzLnBhZ2luYXRpb24udHJhbnNsYXRpb25YID0gMDtcbiAgICB0aGlzLnBhZ2luYXRpb24udHJhbnNsYXRpb25ZID0gMDtcbiAgICBjb25zdCB7IHBhZ2VzLCBtYXhQYWdlSGVpZ2h0LCBtYXhQYWdlV2lkdGgsIHBhZ2luYXRpb25CQm94LCBwYWdpbmF0aW9uVmVydGljYWwgfSA9IHRoaXMuY2FsY3VsYXRlUGFnaW5hdGlvbihcbiAgICAgIGJib3hlcyxcbiAgICAgIHdpZHRoMixcbiAgICAgIGhlaWdodDJcbiAgICApO1xuICAgIGNvbnN0IG5ld0N1cnJlbnRQYWdlID0gcGFnZXMuZmluZEluZGV4KChwKSA9PiBwLmVuZEluZGV4ID49IHRyYWNraW5nSW5kZXgpO1xuICAgIHRoaXMucGFnaW5hdGlvbi5jdXJyZW50UGFnZSA9IGNsYW1wKDAsIG5ld0N1cnJlbnRQYWdlLCBwYWdlcy5sZW5ndGggLSAxKTtcbiAgICBjb25zdCB7IHBhZGRpbmdYOiBpdGVtUGFkZGluZ1gsIHBhZGRpbmdZOiBpdGVtUGFkZGluZ1kgfSA9IHRoaXMuaXRlbTtcbiAgICBjb25zdCBwYWdpbmF0aW9uQ29tcG9uZW50UGFkZGluZyA9IDg7XG4gICAgY29uc3QgbGVnZW5kSXRlbXNXaWR0aCA9IG1heFBhZ2VXaWR0aCAtIGl0ZW1QYWRkaW5nWDtcbiAgICBjb25zdCBsZWdlbmRJdGVtc0hlaWdodCA9IG1heFBhZ2VIZWlnaHQgLSBpdGVtUGFkZGluZ1k7XG4gICAgbGV0IHBhZ2luYXRpb25YID0gMDtcbiAgICBsZXQgcGFnaW5hdGlvblkgPSAtcGFnaW5hdGlvbkJCb3gueSAtIHRoaXMuaXRlbS5tYXJrZXIuc2l6ZSAvIDI7XG4gICAgaWYgKHBhZ2luYXRpb25WZXJ0aWNhbCkge1xuICAgICAgcGFnaW5hdGlvblkgKz0gbGVnZW5kSXRlbXNIZWlnaHQgKyBwYWdpbmF0aW9uQ29tcG9uZW50UGFkZGluZztcbiAgICB9IGVsc2Uge1xuICAgICAgcGFnaW5hdGlvblggKz0gLXBhZ2luYXRpb25CQm94LnggKyBsZWdlbmRJdGVtc1dpZHRoICsgcGFnaW5hdGlvbkNvbXBvbmVudFBhZGRpbmc7XG4gICAgICBwYWdpbmF0aW9uWSArPSAobGVnZW5kSXRlbXNIZWlnaHQgLSBwYWdpbmF0aW9uQkJveC5oZWlnaHQpIC8gMjtcbiAgICB9XG4gICAgdGhpcy5wYWdpbmF0aW9uLnRyYW5zbGF0aW9uWCA9IHBhZ2luYXRpb25YO1xuICAgIHRoaXMucGFnaW5hdGlvbi50cmFuc2xhdGlvblkgPSBwYWdpbmF0aW9uWTtcbiAgICB0aGlzLnBhZ2luYXRpb24udXBkYXRlKCk7XG4gICAgdGhpcy5wYWdpbmF0aW9uLnVwZGF0ZU1hcmtlcnMoKTtcbiAgICBsZXQgcGFnZUluZGV4ID0gMDtcbiAgICB0aGlzLml0ZW1TZWxlY3Rpb24uZWFjaCgobWFya2VyTGFiZWwsIF8sIG5vZGVJbmRleCkgPT4ge1xuICAgICAgaWYgKG5vZGVJbmRleCA+IChwYWdlc1twYWdlSW5kZXhdPy5lbmRJbmRleCA/PyBJbmZpbml0eSkpIHtcbiAgICAgICAgcGFnZUluZGV4Kys7XG4gICAgICB9XG4gICAgICBtYXJrZXJMYWJlbC5wYWdlSW5kZXggPSBwYWdlSW5kZXg7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1heFBhZ2VIZWlnaHQsXG4gICAgICBtYXhQYWdlV2lkdGgsXG4gICAgICBwYWdlc1xuICAgIH07XG4gIH1cbiAgdXBkYXRlSXRlbVByb3h5QnV0dG9ucygpIHtcbiAgICBjb25zdCBwb2ludGVyID0gdGhpcy50b2dnbGVTZXJpZXMgPyBcInBvaW50ZXJcIiA6IHZvaWQgMDtcbiAgICBjb25zdCBtYXhIZWlnaHQgPSBNYXRoLm1heCguLi50aGlzLml0ZW1TZWxlY3Rpb24ubm9kZXMoKS5tYXAoKGwpID0+IGwuZ2V0QkJveCgpLmhlaWdodCkpO1xuICAgIHRoaXMuaXRlbVNlbGVjdGlvbi5lYWNoKChsKSA9PiB7XG4gICAgICBpZiAobC5wcm94eUJ1dHRvbikge1xuICAgICAgICBjb25zdCB7IGxpc3RpdGVtLCBidXR0b24gfSA9IGwucHJveHlCdXR0b247XG4gICAgICAgIGNvbnN0IHZpc2libGUgPSBsLnBhZ2VJbmRleCA9PT0gdGhpcy5wYWdpbmF0aW9uLmN1cnJlbnRQYWdlO1xuICAgICAgICBsZXQgYmJveCA9IFRyYW5zZm9ybWFibGUudG9DYW52YXMobCk7XG4gICAgICAgIGlmIChiYm94LmhlaWdodCAhPT0gbWF4SGVpZ2h0KSB7XG4gICAgICAgICAgY29uc3QgbWFyZ2luID0gKG1heEhlaWdodCAtIGJib3guaGVpZ2h0KSAvIDI7XG4gICAgICAgICAgYmJveCA9IHsgeDogYmJveC54LCB5OiBiYm94LnkgLSBtYXJnaW4sIGhlaWdodDogbWF4SGVpZ2h0LCB3aWR0aDogYmJveC53aWR0aCB9O1xuICAgICAgICB9XG4gICAgICAgIHNldEVsZW1lbnRTdHlsZShidXR0b24sIFwicG9pbnRlci1ldmVudHNcIiwgdmlzaWJsZSA/IFwiYXV0b1wiIDogXCJub25lXCIpO1xuICAgICAgICBzZXRFbGVtZW50U3R5bGUoYnV0dG9uLCBcImN1cnNvclwiLCBwb2ludGVyKTtcbiAgICAgICAgc2V0RWxlbWVudEJCb3gobGlzdGl0ZW0sIGJib3gpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHVwZGF0ZVBhZ2luYXRpb25Qcm94eUJ1dHRvbnMob2xkUGFnZXMpIHtcbiAgICB0aGlzLnByb3h5TGVnZW5kUGFnaW5hdGlvbi5zdHlsZS5kaXNwbGF5ID0gdGhpcy5wYWdpbmF0aW9uLnZpc2libGUgPyBcImFic29sdXRlXCIgOiBcIm5vbmVcIjtcbiAgICBjb25zdCBvbGROZWVkc0J1dHRvbnMgPSAob2xkUGFnZXM/Lmxlbmd0aCA/PyB0aGlzLnBhZ2VzLmxlbmd0aCkgPiAxO1xuICAgIGNvbnN0IG5ld05lZWRzQnV0dG9ucyA9IHRoaXMucGFnZXMubGVuZ3RoID4gMTtcbiAgICBpZiAob2xkTmVlZHNCdXR0b25zICE9PSBuZXdOZWVkc0J1dHRvbnMpIHtcbiAgICAgIGlmIChuZXdOZWVkc0J1dHRvbnMpIHtcbiAgICAgICAgdGhpcy5wcm94eVByZXZCdXR0b24gPSB0aGlzLmN0eC5wcm94eUludGVyYWN0aW9uU2VydmljZS5jcmVhdGVQcm94eUVsZW1lbnQoe1xuICAgICAgICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgICAgICAgaWQ6IGAke3RoaXMuaWR9LXByZXYtcGFnZWAsXG4gICAgICAgICAgdGV4dENvbnRlbnQ6IHsgaWQ6IFwiYXJpYUxhYmVsTGVnZW5kUGFnZVByZXZpb3VzXCIgfSxcbiAgICAgICAgICB0YWJJbmRleDogMCxcbiAgICAgICAgICBwYXJlbnQ6IHRoaXMucHJveHlMZWdlbmRQYWdpbmF0aW9uLFxuICAgICAgICAgIG9uY2xpY2s6IChldikgPT4gdGhpcy5wYWdpbmF0aW9uLm9uQ2xpY2soZXYsIFwicHJldmlvdXNcIiksXG4gICAgICAgICAgb25tb3VzZWVudGVyOiAoKSA9PiB0aGlzLnBhZ2luYXRpb24ub25Nb3VzZUhvdmVyKFwicHJldmlvdXNcIiksXG4gICAgICAgICAgb25tb3VzZWxlYXZlOiAoKSA9PiB0aGlzLnBhZ2luYXRpb24ub25Nb3VzZUhvdmVyKHZvaWQgMClcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucHJveHlOZXh0QnV0dG9uID8/ICh0aGlzLnByb3h5TmV4dEJ1dHRvbiA9IHRoaXMuY3R4LnByb3h5SW50ZXJhY3Rpb25TZXJ2aWNlLmNyZWF0ZVByb3h5RWxlbWVudCh7XG4gICAgICAgICAgdHlwZTogXCJidXR0b25cIixcbiAgICAgICAgICBpZDogYCR7dGhpcy5pZH0tbmV4dC1wYWdlYCxcbiAgICAgICAgICB0ZXh0Q29udGVudDogeyBpZDogXCJhcmlhTGFiZWxMZWdlbmRQYWdlTmV4dFwiIH0sXG4gICAgICAgICAgdGFiSW5kZXg6IDAsXG4gICAgICAgICAgcGFyZW50OiB0aGlzLnByb3h5TGVnZW5kUGFnaW5hdGlvbixcbiAgICAgICAgICBvbmNsaWNrOiAoZXYpID0+IHRoaXMucGFnaW5hdGlvbi5vbkNsaWNrKGV2LCBcIm5leHRcIiksXG4gICAgICAgICAgb25tb3VzZWVudGVyOiAoKSA9PiB0aGlzLnBhZ2luYXRpb24ub25Nb3VzZUhvdmVyKFwibmV4dFwiKSxcbiAgICAgICAgICBvbm1vdXNlbGVhdmU6ICgpID0+IHRoaXMucGFnaW5hdGlvbi5vbk1vdXNlSG92ZXIodm9pZCAwKVxuICAgICAgICB9KSk7XG4gICAgICAgIHRoaXMucHJveHlMZWdlbmRQYWdpbmF0aW9uLmFyaWFIaWRkZW4gPSBcImZhbHNlXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByb3h5TmV4dEJ1dHRvbj8ucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMucHJveHlQcmV2QnV0dG9uPy5yZW1vdmUoKTtcbiAgICAgICAgW3RoaXMucHJveHlOZXh0QnV0dG9uLCB0aGlzLnByb3h5UHJldkJ1dHRvbl0gPSBbdm9pZCAwLCB2b2lkIDBdO1xuICAgICAgICB0aGlzLnByb3h5TGVnZW5kUGFnaW5hdGlvbi5hcmlhSGlkZGVuID0gXCJ0cnVlXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHsgcHJldiwgbmV4dCB9ID0gdGhpcy5wYWdpbmF0aW9uLmNvbXB1dGVDU1NCb3VuZHMoKTtcbiAgICBzZXRFbGVtZW50QkJveCh0aGlzLnByb3h5UHJldkJ1dHRvbiwgcHJldik7XG4gICAgc2V0RWxlbWVudEJCb3godGhpcy5wcm94eU5leHRCdXR0b24sIG5leHQpO1xuICAgIHNldEVsZW1lbnRTdHlsZSh0aGlzLnByb3h5TmV4dEJ1dHRvbiwgXCJjdXJzb3JcIiwgdGhpcy5wYWdpbmF0aW9uLmdldEN1cnNvcihcIm5leHRcIikpO1xuICAgIHNldEVsZW1lbnRTdHlsZSh0aGlzLnByb3h5UHJldkJ1dHRvbiwgXCJjdXJzb3JcIiwgdGhpcy5wYWdpbmF0aW9uLmdldEN1cnNvcihcInByZXZpb3VzXCIpKTtcbiAgfVxuICBjYWxjdWxhdGVQYWdpbmF0aW9uKGJib3hlcywgd2lkdGgyLCBoZWlnaHQyKSB7XG4gICAgY29uc3QgeyBwYWRkaW5nWDogaXRlbVBhZGRpbmdYLCBwYWRkaW5nWTogaXRlbVBhZGRpbmdZIH0gPSB0aGlzLml0ZW07XG4gICAgY29uc3Qgb3JpZW50YXRpb24gPSB0aGlzLmdldE9yaWVudGF0aW9uKCk7XG4gICAgY29uc3QgcGFnaW5hdGlvblZlcnRpY2FsID0gW1wibGVmdFwiLCBcInJpZ2h0XCJdLmluY2x1ZGVzKHRoaXMucG9zaXRpb24pO1xuICAgIGxldCBwYWdpbmF0aW9uQkJveCA9IHRoaXMucGFnaW5hdGlvbi5nZXRCQm94KCk7XG4gICAgbGV0IGxhc3RQYXNzUGFnaW5hdGlvbkJCb3ggPSBuZXcgQkJveCgwLCAwLCAwLCAwKTtcbiAgICBsZXQgcGFnZXMgPSBbXTtcbiAgICBsZXQgbWF4UGFnZVdpZHRoID0gMDtcbiAgICBsZXQgbWF4UGFnZUhlaWdodCA9IDA7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBjb25zdCBzdGFibGVPdXRwdXQgPSAoYmJveCkgPT4ge1xuICAgICAgcmV0dXJuIGJib3gud2lkdGggPT09IHBhZ2luYXRpb25CQm94LndpZHRoICYmIGJib3guaGVpZ2h0ID09PSBwYWdpbmF0aW9uQkJveC5oZWlnaHQ7XG4gICAgfTtcbiAgICBjb25zdCBmb3JjZVJlc3VsdCA9IHRoaXMubWF4V2lkdGggIT09IHZvaWQgMCAmJiB0aGlzLm1heEhlaWdodCAhPT0gdm9pZCAwO1xuICAgIGRvIHtcbiAgICAgIGlmIChjb3VudCsrID4gMTApIHtcbiAgICAgICAgTG9nZ2VyLndhcm4oXCJ1bmFibGUgdG8gZmluZCBzdGFibGUgbGVnZW5kIGxheW91dC5cIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcGFnaW5hdGlvbkJCb3ggPSBsYXN0UGFzc1BhZ2luYXRpb25CQm94O1xuICAgICAgY29uc3QgbWF4V2lkdGggPSB3aWR0aDIgLSAocGFnaW5hdGlvblZlcnRpY2FsID8gMCA6IHBhZ2luYXRpb25CQm94LndpZHRoKTtcbiAgICAgIGNvbnN0IG1heEhlaWdodCA9IGhlaWdodDIgLSAocGFnaW5hdGlvblZlcnRpY2FsID8gcGFnaW5hdGlvbkJCb3guaGVpZ2h0IDogMCk7XG4gICAgICBjb25zdCBsYXlvdXQgPSBncmlkTGF5b3V0KHtcbiAgICAgICAgb3JpZW50YXRpb24sXG4gICAgICAgIGJib3hlcyxcbiAgICAgICAgbWF4SGVpZ2h0LFxuICAgICAgICBtYXhXaWR0aCxcbiAgICAgICAgaXRlbVBhZGRpbmdZLFxuICAgICAgICBpdGVtUGFkZGluZ1gsXG4gICAgICAgIGZvcmNlUmVzdWx0XG4gICAgICB9KTtcbiAgICAgIHBhZ2VzID0gbGF5b3V0Py5wYWdlcyA/PyBbXTtcbiAgICAgIG1heFBhZ2VXaWR0aCA9IGxheW91dD8ubWF4UGFnZVdpZHRoID8/IDA7XG4gICAgICBtYXhQYWdlSGVpZ2h0ID0gbGF5b3V0Py5tYXhQYWdlSGVpZ2h0ID8/IDA7XG4gICAgICBjb25zdCB0b3RhbFBhZ2VzID0gcGFnZXMubGVuZ3RoO1xuICAgICAgdGhpcy5wYWdpbmF0aW9uLnZpc2libGUgPSB0b3RhbFBhZ2VzID4gMTtcbiAgICAgIHRoaXMucGFnaW5hdGlvbi50b3RhbFBhZ2VzID0gdG90YWxQYWdlcztcbiAgICAgIHRoaXMucGFnaW5hdGlvbi51cGRhdGUoKTtcbiAgICAgIHRoaXMucGFnaW5hdGlvbi51cGRhdGVNYXJrZXJzKCk7XG4gICAgICBsYXN0UGFzc1BhZ2luYXRpb25CQm94ID0gdGhpcy5wYWdpbmF0aW9uLmdldEJCb3goKTtcbiAgICAgIGlmICghdGhpcy5wYWdpbmF0aW9uLnZpc2libGUpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSB3aGlsZSAoIXN0YWJsZU91dHB1dChsYXN0UGFzc1BhZ2luYXRpb25CQm94KSk7XG4gICAgcmV0dXJuIHsgbWF4UGFnZVdpZHRoLCBtYXhQYWdlSGVpZ2h0LCBwYWdlcywgcGFnaW5hdGlvbkJCb3g6IGxhc3RQYXNzUGFnaW5hdGlvbkJCb3gsIHBhZ2luYXRpb25WZXJ0aWNhbCB9O1xuICB9XG4gIHVwZGF0ZVBvc2l0aW9ucyhwYWdlTnVtYmVyID0gMCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGl0ZW06IHsgcGFkZGluZ1kgfSxcbiAgICAgIGl0ZW1TZWxlY3Rpb24sXG4gICAgICBwYWdlc1xuICAgIH0gPSB0aGlzO1xuICAgIGlmIChwYWdlcy5sZW5ndGggPCAxIHx8ICFwYWdlc1twYWdlTnVtYmVyXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGNvbHVtbnMsIHN0YXJ0SW5kZXg6IHZpc2libGVTdGFydCwgZW5kSW5kZXg6IHZpc2libGVFbmQgfSA9IHBhZ2VzW3BhZ2VOdW1iZXJdO1xuICAgIGxldCB4ID0gMDtcbiAgICBsZXQgeSA9IDA7XG4gICAgY29uc3QgY29sdW1uQ291bnQgPSBjb2x1bW5zLmxlbmd0aDtcbiAgICBjb25zdCByb3dDb3VudCA9IGNvbHVtbnNbMF0uaW5kaWNlcy5sZW5ndGg7XG4gICAgY29uc3QgaG9yaXpvbnRhbCA9IHRoaXMuZ2V0T3JpZW50YXRpb24oKSA9PT0gXCJob3Jpem9udGFsXCI7XG4gICAgY29uc3QgaXRlbUhlaWdodCA9IGNvbHVtbnNbMF0uYmJveGVzWzBdLmhlaWdodCArIHBhZGRpbmdZO1xuICAgIGNvbnN0IHJvd1N1bUNvbHVtbldpZHRocyA9IFtdO1xuICAgIGl0ZW1TZWxlY3Rpb24uZWFjaCgobWFya2VyTGFiZWwsIF8sIGkpID0+IHtcbiAgICAgIGlmIChpIDwgdmlzaWJsZVN0YXJ0IHx8IGkgPiB2aXNpYmxlRW5kKSB7XG4gICAgICAgIG1hcmtlckxhYmVsLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFnZUluZGV4ID0gaSAtIHZpc2libGVTdGFydDtcbiAgICAgIGxldCBjb2x1bW5JbmRleDtcbiAgICAgIGxldCByb3dJbmRleDtcbiAgICAgIGlmIChob3Jpem9udGFsKSB7XG4gICAgICAgIGNvbHVtbkluZGV4ID0gcGFnZUluZGV4ICUgY29sdW1uQ291bnQ7XG4gICAgICAgIHJvd0luZGV4ID0gTWF0aC5mbG9vcihwYWdlSW5kZXggLyBjb2x1bW5Db3VudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2x1bW5JbmRleCA9IE1hdGguZmxvb3IocGFnZUluZGV4IC8gcm93Q291bnQpO1xuICAgICAgICByb3dJbmRleCA9IHBhZ2VJbmRleCAlIHJvd0NvdW50O1xuICAgICAgfVxuICAgICAgbWFya2VyTGFiZWwudmlzaWJsZSA9IHRydWU7XG4gICAgICBjb25zdCBjb2x1bW4gPSBjb2x1bW5zW2NvbHVtbkluZGV4XTtcbiAgICAgIGlmICghY29sdW1uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHkgPSBNYXRoLmZsb29yKGl0ZW1IZWlnaHQgKiByb3dJbmRleCk7XG4gICAgICB4ID0gTWF0aC5mbG9vcihyb3dTdW1Db2x1bW5XaWR0aHNbcm93SW5kZXhdID8/IDApO1xuICAgICAgcm93U3VtQ29sdW1uV2lkdGhzW3Jvd0luZGV4XSA9IChyb3dTdW1Db2x1bW5XaWR0aHNbcm93SW5kZXhdID8/IDApICsgY29sdW1uLmNvbHVtbldpZHRoO1xuICAgICAgbWFya2VyTGFiZWwudHJhbnNsYXRpb25YID0geDtcbiAgICAgIG1hcmtlckxhYmVsLnRyYW5zbGF0aW9uWSA9IHk7XG4gICAgfSk7XG4gICAgdGhpcy51cGRhdGVJdGVtUHJveHlCdXR0b25zKCk7XG4gIH1cbiAgdXBkYXRlUGFnZU51bWJlcihwYWdlTnVtYmVyKSB7XG4gICAgY29uc3QgeyBwYWdlcyB9ID0gdGhpcztcbiAgICBjb25zdCB7IHN0YXJ0SW5kZXgsIGVuZEluZGV4IH0gPSBwYWdlc1twYWdlTnVtYmVyXTtcbiAgICBpZiAoc3RhcnRJbmRleCA9PT0gMCkge1xuICAgICAgdGhpcy5wYWdpbmF0aW9uVHJhY2tpbmdJbmRleCA9IDA7XG4gICAgfSBlbHNlIGlmIChwYWdlTnVtYmVyID09PSBwYWdlcy5sZW5ndGggLSAxKSB7XG4gICAgICB0aGlzLnBhZ2luYXRpb25UcmFja2luZ0luZGV4ID0gZW5kSW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGFnaW5hdGlvblRyYWNraW5nSW5kZXggPSBNYXRoLmZsb29yKChzdGFydEluZGV4ICsgZW5kSW5kZXgpIC8gMik7XG4gICAgfVxuICAgIHRoaXMucGFnaW5hdGlvbi51cGRhdGUoKTtcbiAgICB0aGlzLnBhZ2luYXRpb24udXBkYXRlTWFya2VycygpO1xuICAgIHRoaXMudXBkYXRlUG9zaXRpb25zKHBhZ2VOdW1iZXIpO1xuICAgIHNldEVsZW1lbnRTdHlsZSh0aGlzLnByb3h5TmV4dEJ1dHRvbiwgXCJjdXJzb3JcIiwgdGhpcy5wYWdpbmF0aW9uLmdldEN1cnNvcihcIm5leHRcIikpO1xuICAgIHNldEVsZW1lbnRTdHlsZSh0aGlzLnByb3h5UHJldkJ1dHRvbiwgXCJjdXJzb3JcIiwgdGhpcy5wYWdpbmF0aW9uLmdldEN1cnNvcihcInByZXZpb3VzXCIpKTtcbiAgICB0aGlzLmN0eC51cGRhdGVTZXJ2aWNlLnVwZGF0ZSg2IC8qIFNDRU5FX1JFTkRFUiAqLyk7XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGxhYmVsOiB7IGNvbG9yIH1cbiAgICB9ID0gdGhpcy5pdGVtO1xuICAgIHRoaXMuaXRlbVNlbGVjdGlvbi5lYWNoKChtYXJrZXJMYWJlbCwgZGF0dW0pID0+IHtcbiAgICAgIG1hcmtlckxhYmVsLnNldEVuYWJsZWQoZGF0dW0uZW5hYmxlZCk7XG4gICAgICBtYXJrZXJMYWJlbC5jb2xvciA9IGNvbG9yO1xuICAgIH0pO1xuICAgIHRoaXMudXBkYXRlQ29udGV4dE1lbnUoKTtcbiAgfVxuICB1cGRhdGVDb250ZXh0TWVudSgpIHtcbiAgICBjb25zdCB7XG4gICAgICB0b2dnbGVTZXJpZXMsXG4gICAgICBjdHg6IHsgY29udGV4dE1lbnVSZWdpc3RyeSB9XG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKHRvZ2dsZVNlcmllcykge1xuICAgICAgY29udGV4dE1lbnVSZWdpc3RyeS5oaWRlQWN0aW9uKElEX0xFR0VORF9WSVNJQklMSVRZKTtcbiAgICAgIGNvbnRleHRNZW51UmVnaXN0cnkuaGlkZUFjdGlvbihJRF9MRUdFTkRfT1RIRVJfU0VSSUVTKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dE1lbnVSZWdpc3RyeS5zaG93QWN0aW9uKElEX0xFR0VORF9WSVNJQklMSVRZKTtcbiAgICAgIGNvbnRleHRNZW51UmVnaXN0cnkuc2hvd0FjdGlvbihJRF9MRUdFTkRfT1RIRVJfU0VSSUVTKTtcbiAgICB9XG4gIH1cbiAgZ2V0TGluZVN0eWxlcyhkYXR1bSkge1xuICAgIGNvbnN0IHsgc3Ryb2tlLCBzdHJva2VPcGFjaXR5ID0gMSwgc3Ryb2tlV2lkdGgsIGxpbmVEYXNoIH0gPSBkYXR1bS5saW5lID8/IHt9O1xuICAgIGNvbnN0IGRlZmF1bHRMaW5lU3Ryb2tlV2lkdGggPSBNYXRoLm1pbigyLCBzdHJva2VXaWR0aCA/PyAxKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3Ryb2tlLFxuICAgICAgc3Ryb2tlT3BhY2l0eSxcbiAgICAgIHN0cm9rZVdpZHRoOiB0aGlzLml0ZW0ubGluZS5zdHJva2VXaWR0aCA/PyBkZWZhdWx0TGluZVN0cm9rZVdpZHRoLFxuICAgICAgbGluZURhc2hcbiAgICB9O1xuICB9XG4gIGdldE1hcmtlclN0eWxlcyhkYXR1bSkge1xuICAgIGNvbnN0IHsgZmlsbCwgc3Ryb2tlLCBzdHJva2VPcGFjaXR5ID0gMSwgZmlsbE9wYWNpdHkgPSAxLCBzdHJva2VXaWR0aCB9ID0gZGF0dW0ubWFya2VyO1xuICAgIGNvbnN0IGRlZmF1bHRMaW5lU3Ryb2tlV2lkdGggPSBNYXRoLm1pbigyLCBzdHJva2VXaWR0aCA/PyAxKTtcbiAgICByZXR1cm4ge1xuICAgICAgZmlsbCxcbiAgICAgIHN0cm9rZSxcbiAgICAgIHN0cm9rZU9wYWNpdHksXG4gICAgICBmaWxsT3BhY2l0eSxcbiAgICAgIHN0cm9rZVdpZHRoOiB0aGlzLml0ZW0ubWFya2VyLnN0cm9rZVdpZHRoID8/IGRlZmF1bHRMaW5lU3Ryb2tlV2lkdGhcbiAgICB9O1xuICB9XG4gIGNvbXB1dGVQYWdlZEJCb3goKSB7XG4gICAgY29uc3QgYWN0dWFsQkJveCA9IEdyb3VwLmNvbXB1dGVDaGlsZHJlbkJCb3godGhpcy5ncm91cC5jaGlsZHJlbigpKTtcbiAgICBpZiAodGhpcy5wYWdlcy5sZW5ndGggPiAxKSB7XG4gICAgICBjb25zdCBbbWF4UGFnZVdpZHRoLCBtYXhQYWdlSGVpZ2h0XSA9IHRoaXMubWF4UGFnZVNpemU7XG4gICAgICBhY3R1YWxCQm94LmhlaWdodCA9IE1hdGgubWF4KG1heFBhZ2VIZWlnaHQsIGFjdHVhbEJCb3guaGVpZ2h0KTtcbiAgICAgIGFjdHVhbEJCb3gud2lkdGggPSBNYXRoLm1heChtYXhQYWdlV2lkdGgsIGFjdHVhbEJCb3gud2lkdGgpO1xuICAgIH1cbiAgICByZXR1cm4gYWN0dWFsQkJveDtcbiAgfVxuICBmaW5kTm9kZShwYXJhbXMpIHtcbiAgICBjb25zdCB7IGRhdHVtLCBwcm94eUJ1dHRvbiB9ID0gdGhpcy5pdGVtU2VsZWN0aW9uLnNlbGVjdCgobWwpID0+IG1sLmRhdHVtPy5pdGVtSWQgPT09IHBhcmFtcy5pdGVtSWQpWzBdID8/IHt9O1xuICAgIGlmIChkYXR1bSA9PT0gdm9pZCAwIHx8IHByb3h5QnV0dG9uID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQUcgQ2hhcnRzIC0gTWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0aWVzIHsgZGF0dW06ICR7ZGF0dW19LCBwcm94eUJ1dHRvbjogJHtwcm94eUJ1dHRvbn0gfWApO1xuICAgIH1cbiAgICByZXR1cm4geyBkYXR1bSwgcHJveHlCdXR0b24gfTtcbiAgfVxuICBjb250ZXh0VG9nZ2xlVmlzaWJpbGl0eShwYXJhbXMpIHtcbiAgICBjb25zdCB7IGRhdHVtLCBwcm94eUJ1dHRvbiB9ID0gdGhpcy5maW5kTm9kZShwYXJhbXMpO1xuICAgIHRoaXMuZG9DbGljayhwYXJhbXMuZXZlbnQsIGRhdHVtLCBwcm94eUJ1dHRvbi5idXR0b24pO1xuICB9XG4gIGNvbnRleHRUb2dnbGVPdGhlclNlcmllcyhwYXJhbXMpIHtcbiAgICB0aGlzLmRvRG91YmxlQ2xpY2socGFyYW1zLmV2ZW50LCB0aGlzLmZpbmROb2RlKHBhcmFtcykuZGF0dW0pO1xuICB9XG4gIG9uQ29udGV4dENsaWNrKHNvdXJjZUV2ZW50LCBub2RlKSB7XG4gICAgY29uc3QgbGVnZW5kSXRlbSA9IG5vZGUuZGF0dW07XG4gICAgaWYgKHRoaXMucHJldmVudEhpZGluZ0FsbCAmJiB0aGlzLmNvbnRleHRNZW51RGF0dW0/LmVuYWJsZWQgJiYgdGhpcy5nZXRWaXNpYmxlSXRlbUNvdW50KCkgPD0gMSkge1xuICAgICAgdGhpcy5jdHguY29udGV4dE1lbnVSZWdpc3RyeS5kaXNhYmxlQWN0aW9uKElEX0xFR0VORF9WSVNJQklMSVRZKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jdHguY29udGV4dE1lbnVSZWdpc3RyeS5lbmFibGVBY3Rpb24oSURfTEVHRU5EX1ZJU0lCSUxJVFkpO1xuICAgIH1cbiAgICBjb25zdCB7IGJ1dHRvbiwgb2Zmc2V0WCwgb2Zmc2V0WSB9ID0gc291cmNlRXZlbnQ7XG4gICAgY29uc3QgeyB4OiBjYW52YXNPZmZzZXRYLCB5OiBjYW52YXNPZmZzZXRZIH0gPSBUcmFuc2Zvcm1hYmxlLnRvQ2FudmFzUG9pbnQobm9kZSwgb2Zmc2V0WCwgb2Zmc2V0WSk7XG4gICAgY29uc3QgZXZlbnQgPSB7XG4gICAgICB0eXBlOiBcImNvbnRleHRtZW51XCIsXG4gICAgICBzb3VyY2VFdmVudCxcbiAgICAgIGJ1dHRvbixcbiAgICAgIG9mZnNldFg6IGNhbnZhc09mZnNldFgsXG4gICAgICBvZmZzZXRZOiBjYW52YXNPZmZzZXRZLFxuICAgICAgZGVsdGFYOiAwLFxuICAgICAgZGVsdGFZOiAwLFxuICAgICAgcGFnZVg6IE5hTixcbiAgICAgIHBhZ2VZOiBOYU4sXG4gICAgICBwcmV2ZW50RGVmYXVsdDogKCkgPT4gc291cmNlRXZlbnQucHJldmVudERlZmF1bHQoKSxcbiAgICAgIHBvaW50ZXJIaXN0b3J5OiBbXVxuICAgIH07XG4gICAgdGhpcy5jdHguY29udGV4dE1lbnVSZWdpc3RyeS5kaXNwYXRjaENvbnRleHQoXCJsZWdlbmRcIiwgZXZlbnQsIHsgbGVnZW5kSXRlbSB9KTtcbiAgfVxuICBvbkNsaWNrKGV2ZW50LCBkYXR1bSwgcHJveHlCdXR0b24pIHtcbiAgICBpZiAodGhpcy5kb0NsaWNrKGV2ZW50LCBkYXR1bSwgcHJveHlCdXR0b24pKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxuICBnZXRWaXNpYmxlSXRlbUNvdW50KCkge1xuICAgIHJldHVybiB0aGlzLmN0eC5jaGFydFNlcnZpY2Uuc2VyaWVzLmZsYXRNYXAoKHMpID0+IHMuZ2V0TGVnZW5kRGF0YShcImNhdGVnb3J5XCIpKS5maWx0ZXIoKGQpID0+IGQuZW5hYmxlZCkubGVuZ3RoO1xuICB9XG4gIGRvQ2xpY2soZXZlbnQsIGRhdHVtLCBwcm94eUJ1dHRvbikge1xuICAgIGNvbnN0IHtcbiAgICAgIGxpc3RlbmVyczogeyBsZWdlbmRJdGVtQ2xpY2sgfSxcbiAgICAgIGN0eDogeyBjaGFydFNlcnZpY2UsIGhpZ2hsaWdodE1hbmFnZXIgfSxcbiAgICAgIHByZXZlbnRIaWRpbmdBbGwsXG4gICAgICB0b2dnbGVTZXJpZXNcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIWRhdHVtKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHsgaWQsIGl0ZW1JZCwgZW5hYmxlZCB9ID0gZGF0dW07XG4gICAgY29uc3Qgc2VyaWVzID0gY2hhcnRTZXJ2aWNlLnNlcmllcy5maW5kKChzKSA9PiBzLmlkID09PSBpZCk7XG4gICAgaWYgKCFzZXJpZXMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IG5ld0VuYWJsZWQgPSBlbmFibGVkO1xuICAgIGNvbnN0IGNsaWNrRXZlbnQgPSBuZXcgTGVnZW5kSXRlbUV2ZW50KFwiY2xpY2tcIiwgbmV3RW5hYmxlZCwgaXRlbUlkLCBzZXJpZXMuaWQsIGV2ZW50KTtcbiAgICBsZWdlbmRJdGVtQ2xpY2s/LihjbGlja0V2ZW50KTtcbiAgICBpZiAoY2xpY2tFdmVudC5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKHRvZ2dsZVNlcmllcykge1xuICAgICAgbmV3RW5hYmxlZCA9ICFlbmFibGVkO1xuICAgICAgaWYgKHByZXZlbnRIaWRpbmdBbGwgJiYgIW5ld0VuYWJsZWQpIHtcbiAgICAgICAgY29uc3QgbnVtVmlzaWJsZUl0ZW1zID0gdGhpcy5nZXRWaXNpYmxlSXRlbUNvdW50KCk7XG4gICAgICAgIGlmIChudW1WaXNpYmxlSXRlbXMgPCAyKSB7XG4gICAgICAgICAgbmV3RW5hYmxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHByb3h5QnV0dG9uLmFyaWFDaGVja2VkID0gbmV3RW5hYmxlZC50b1N0cmluZygpO1xuICAgICAgdGhpcy5jdHguY2hhcnRFdmVudE1hbmFnZXIubGVnZW5kSXRlbUNsaWNrKHNlcmllcywgaXRlbUlkLCBuZXdFbmFibGVkLCBkYXR1bS5sZWdlbmRJdGVtTmFtZSk7XG4gICAgfVxuICAgIGlmIChuZXdFbmFibGVkKSB7XG4gICAgICBoaWdobGlnaHRNYW5hZ2VyLnVwZGF0ZUhpZ2hsaWdodCh0aGlzLmlkLCB7XG4gICAgICAgIHNlcmllcyxcbiAgICAgICAgaXRlbUlkLFxuICAgICAgICBkYXR1bTogdm9pZCAwXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGlnaGxpZ2h0TWFuYWdlci51cGRhdGVIaWdobGlnaHQodGhpcy5pZCk7XG4gICAgfVxuICAgIHRoaXMuY3R4LnVwZGF0ZVNlcnZpY2UudXBkYXRlKDIgLyogUFJPQ0VTU19EQVRBICovLCB7IGZvcmNlTm9kZURhdGFSZWZyZXNoOiB0cnVlIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIG9uRG91YmxlQ2xpY2soZXZlbnQsIGRhdHVtKSB7XG4gICAgaWYgKHRoaXMuZG9Eb3VibGVDbGljayhldmVudCwgZGF0dW0pKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxuICBkb0RvdWJsZUNsaWNrKGV2ZW50LCBkYXR1bSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGxpc3RlbmVyczogeyBsZWdlbmRJdGVtRG91YmxlQ2xpY2sgfSxcbiAgICAgIGN0eDogeyBjaGFydFNlcnZpY2UgfSxcbiAgICAgIHRvZ2dsZVNlcmllc1xuICAgIH0gPSB0aGlzO1xuICAgIGlmIChjaGFydFNlcnZpY2UubW9kZSA9PT0gXCJpbnRlZ3JhdGVkXCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFkYXR1bSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB7IGlkLCBpdGVtSWQsIHNlcmllc0lkIH0gPSBkYXR1bTtcbiAgICBjb25zdCBzZXJpZXMgPSBjaGFydFNlcnZpY2Uuc2VyaWVzLmZpbmQoKHMpID0+IHMuaWQgPT09IGlkKTtcbiAgICBpZiAoIXNlcmllcykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBkb3VibGVDbGlja0V2ZW50ID0gbmV3IExlZ2VuZEl0ZW1FdmVudChcImRibGNsaWNrXCIsIHRydWUsIGl0ZW1JZCwgc2VyaWVzLmlkLCBldmVudCk7XG4gICAgbGVnZW5kSXRlbURvdWJsZUNsaWNrPy4oZG91YmxlQ2xpY2tFdmVudCk7XG4gICAgaWYgKGRvdWJsZUNsaWNrRXZlbnQuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmICh0b2dnbGVTZXJpZXMpIHtcbiAgICAgIGNvbnN0IGxlZ2VuZERhdGEgPSBjaGFydFNlcnZpY2Uuc2VyaWVzLmZsYXRNYXAoKHMpID0+IHMuZ2V0TGVnZW5kRGF0YShcImNhdGVnb3J5XCIpKTtcbiAgICAgIGNvbnN0IG51bVZpc2libGVJdGVtcyA9IGxlZ2VuZERhdGEuZmlsdGVyKChkKSA9PiBkLmVuYWJsZWQpLmxlbmd0aDtcbiAgICAgIGNvbnN0IGNsaWNrZWRJdGVtID0gbGVnZW5kRGF0YS5maW5kKChkKSA9PiBkLml0ZW1JZCA9PT0gaXRlbUlkICYmIGQuc2VyaWVzSWQgPT09IHNlcmllc0lkKTtcbiAgICAgIHRoaXMuY3R4LmNoYXJ0RXZlbnRNYW5hZ2VyLmxlZ2VuZEl0ZW1Eb3VibGVDbGljayhcbiAgICAgICAgc2VyaWVzLFxuICAgICAgICBpdGVtSWQsXG4gICAgICAgIGNsaWNrZWRJdGVtPy5lbmFibGVkID8/IGZhbHNlLFxuICAgICAgICBudW1WaXNpYmxlSXRlbXMsXG4gICAgICAgIGNsaWNrZWRJdGVtPy5sZWdlbmRJdGVtTmFtZVxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5jdHgudXBkYXRlU2VydmljZS51cGRhdGUoMiAvKiBQUk9DRVNTX0RBVEEgKi8sIHsgZm9yY2VOb2RlRGF0YVJlZnJlc2g6IHRydWUgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdG9Ub29sdGlwTWV0YShldmVudCwgbm9kZSkge1xuICAgIGxldCBsYXN0UG9pbnRlckV2ZW50O1xuICAgIGlmIChldmVudCBpbnN0YW5jZW9mIEZvY3VzRXZlbnQpIHtcbiAgICAgIGNvbnN0IHsgeCwgeSB9ID0gVHJhbnNmb3JtYWJsZS50b0NhbnZhcyhub2RlKS5jb21wdXRlQ2VudGVyKCk7XG4gICAgICBsYXN0UG9pbnRlckV2ZW50ID0geyB0eXBlOiBcImtleWJvYXJkXCIsIG9mZnNldFg6IHgsIG9mZnNldFk6IHkgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGNvbnN0IHsgeCwgeSB9ID0gVHJhbnNmb3JtYWJsZS50b0NhbnZhc1BvaW50KG5vZGUsIGV2ZW50Lm9mZnNldFgsIGV2ZW50Lm9mZnNldFkpO1xuICAgICAgbGFzdFBvaW50ZXJFdmVudCA9IHsgdHlwZTogXCJob3ZlclwiLCBvZmZzZXRYOiB4LCBvZmZzZXRZOiB5IH07XG4gICAgfVxuICAgIGNvbnN0IHsgb2Zmc2V0WCwgb2Zmc2V0WSB9ID0gbGFzdFBvaW50ZXJFdmVudDtcbiAgICByZXR1cm4geyBvZmZzZXRYLCBvZmZzZXRZLCBsYXN0UG9pbnRlckV2ZW50LCBzaG93QXJyb3c6IGZhbHNlIH07XG4gIH1cbiAgb25Ib3ZlcihldmVudCwgbm9kZSkge1xuICAgIGlmICghdGhpcy5lbmFibGVkKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQUcgQ2hhcnRzIC0gb25Ib3ZlciBoYW5kbGVyIGNhbGxlZCBvbiBkaXNhYmxlZCBsZWdlbmRcIik7XG4gICAgdGhpcy5wYWdpbmF0aW9uLnNldFBhZ2Uobm9kZS5wYWdlSW5kZXgpO1xuICAgIGNvbnN0IGRhdHVtID0gbm9kZS5kYXR1bTtcbiAgICBjb25zdCBzZXJpZXMgPSBkYXR1bSA/IHRoaXMuY3R4LmNoYXJ0U2VydmljZS5zZXJpZXMuZmluZCgocykgPT4gcy5pZCA9PT0gZGF0dW0/LmlkKSA6IHZvaWQgMDtcbiAgICBpZiAoZGF0dW0gJiYgdGhpcy50cnVuY2F0ZWRJdGVtcy5oYXMoZGF0dW0uaXRlbUlkID8/IGRhdHVtLmlkKSkge1xuICAgICAgY29uc3QgbWV0YSA9IHRoaXMudG9Ub29sdGlwTWV0YShldmVudCwgbm9kZSk7XG4gICAgICB0aGlzLmN0eC50b29sdGlwTWFuYWdlci51cGRhdGVUb29sdGlwKHRoaXMuaWQsIG1ldGEsIHRvVG9vbHRpcEh0bWwoeyBjb250ZW50OiB0aGlzLmdldEl0ZW1MYWJlbChkYXR1bSkgfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmN0eC50b29sdGlwTWFuYWdlci5yZW1vdmVUb29sdGlwKHRoaXMuaWQpO1xuICAgIH1cbiAgICBpZiAoZGF0dW0/LmVuYWJsZWQgJiYgc2VyaWVzKSB7XG4gICAgICB0aGlzLnVwZGF0ZUhpZ2hsaWdodCh7IHNlcmllcywgaXRlbUlkOiBkYXR1bT8uaXRlbUlkLCBkYXR1bTogdm9pZCAwIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVwZGF0ZUhpZ2hsaWdodCgpO1xuICAgIH1cbiAgfVxuICBvbkxlYXZlKCkge1xuICAgIHRoaXMuY3R4LnRvb2x0aXBNYW5hZ2VyLnJlbW92ZVRvb2x0aXAodGhpcy5pZCk7XG4gICAgdGhpcy51cGRhdGVIaWdobGlnaHQoKTtcbiAgfVxuICB1cGRhdGVIaWdobGlnaHQoZGF0dW0pIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuY3R4LmludGVyYWN0aW9uTWFuYWdlci5nZXRTdGF0ZSgpO1xuICAgIGlmIChzdGF0ZSA9PT0gMzIgLyogRGVmYXVsdCAqLykge1xuICAgICAgdGhpcy5jdHguaGlnaGxpZ2h0TWFuYWdlci51cGRhdGVIaWdobGlnaHQodGhpcy5pZCwgZGF0dW0pO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IDIgLyogQW5pbWF0aW9uICovKSB7XG4gICAgICB0aGlzLnBlbmRpbmdIaWdobGlnaHREYXR1bSA9IGRhdHVtO1xuICAgICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5vbkJhdGNoU3RvcCgoKSA9PiB7XG4gICAgICAgIHRoaXMuY3R4LmhpZ2hsaWdodE1hbmFnZXIudXBkYXRlSGlnaGxpZ2h0KHRoaXMuaWQsIHRoaXMucGVuZGluZ0hpZ2hsaWdodERhdHVtKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBvbkxvY2FsZUNoYW5nZWQoKSB7XG4gICAgdGhpcy5pdGVtU2VsZWN0aW9uLmVhY2goKHsgcHJveHlCdXR0b24gfSwgXywgaSkgPT4ge1xuICAgICAgaWYgKHByb3h5QnV0dG9uPy5idXR0b24gIT0gbnVsbCkge1xuICAgICAgICBwcm94eUJ1dHRvbi5idXR0b24udGV4dENvbnRlbnQgPSB0aGlzLmdldEl0ZW1BcmlhVGV4dChpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnByb3h5TGVnZW5kSXRlbURlc2NyaXB0aW9uLnRleHRDb250ZW50ID0gdGhpcy5nZXRJdGVtQXJpYURlc2NyaXB0aW9uKCk7XG4gIH1cbiAgZ2V0SXRlbUFyaWFUZXh0KG5vZGVJbmRleCkge1xuICAgIGNvbnN0IGRhdHVtID0gdGhpcy5kYXRhW25vZGVJbmRleF07XG4gICAgY29uc3QgbGFiZWwgPSBkYXR1bSAmJiB0aGlzLmdldEl0ZW1MYWJlbChkYXR1bSk7XG4gICAgY29uc3QgbG0gPSB0aGlzLmN0eC5sb2NhbGVNYW5hZ2VyO1xuICAgIGlmIChub2RlSW5kZXggPj0gMCAmJiBsYWJlbCkge1xuICAgICAgY29uc3QgaW5kZXggPSBub2RlSW5kZXggKyAxO1xuICAgICAgY29uc3QgY291bnQgPSB0aGlzLmRhdGEubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxtLnQoXCJhcmlhTGFiZWxMZWdlbmRJdGVtXCIsIHsgbGFiZWwsIGluZGV4LCBjb3VudCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGxtLnQoXCJhcmlhTGFiZWxMZWdlbmRJdGVtVW5rbm93blwiKTtcbiAgfVxuICBnZXRJdGVtQXJpYURlc2NyaXB0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmN0eC5sb2NhbGVNYW5hZ2VyLnQoXCJhcmlhRGVzY3JpcHRpb25MZWdlbmRJdGVtXCIpO1xuICB9XG4gIHBvc2l0aW9uTGVnZW5kKGN0eCkge1xuICAgIHNldEVsZW1lbnRTdHlsZSh0aGlzLnByb3h5TGVnZW5kVG9vbGJhciwgXCJkaXNwbGF5XCIsIHRoaXMudmlzaWJsZSAmJiB0aGlzLmVuYWJsZWQgPyB2b2lkIDAgOiBcIm5vbmVcIik7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQgfHwgIXRoaXMuZGF0YS5sZW5ndGgpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBsYXlvdXRCb3ggfSA9IGN0eDtcbiAgICBjb25zdCB7IHgsIHksIHdpZHRoOiB3aWR0aDIsIGhlaWdodDogaGVpZ2h0MiB9ID0gbGF5b3V0Qm94O1xuICAgIGNvbnN0IFtsZWdlbmRXaWR0aCwgbGVnZW5kSGVpZ2h0XSA9IHRoaXMuY2FsY3VsYXRlTGVnZW5kRGltZW5zaW9ucyhsYXlvdXRCb3gpO1xuICAgIGNvbnN0IHsgb2xkUGFnZXMgfSA9IHRoaXMuY2FsY0xheW91dChsZWdlbmRXaWR0aCwgbGVnZW5kSGVpZ2h0KTtcbiAgICBjb25zdCBsZWdlbmRCQm94ID0gdGhpcy5jb21wdXRlUGFnZWRCQm94KCk7XG4gICAgY29uc3QgY2FsY3VsYXRlVHJhbnNsYXRpb25QZXJwZW5kaWN1bGFyRGltZW5zaW9uID0gKCkgPT4ge1xuICAgICAgc3dpdGNoICh0aGlzLnBvc2l0aW9uKSB7XG4gICAgICAgIGNhc2UgXCJ0b3BcIjpcbiAgICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgICAgIHJldHVybiBoZWlnaHQyIC0gbGVnZW5kQkJveC5oZWlnaHQ7XG4gICAgICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB3aWR0aDIgLSBsZWdlbmRCQm94LndpZHRoO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKHRoaXMudmlzaWJsZSkge1xuICAgICAgY29uc3QgbGVnZW5kUGFkZGluZyA9IHRoaXMuc3BhY2luZztcbiAgICAgIGxldCB0cmFuc2xhdGlvblg7XG4gICAgICBsZXQgdHJhbnNsYXRpb25ZO1xuICAgICAgc3dpdGNoICh0aGlzLnBvc2l0aW9uKSB7XG4gICAgICAgIGNhc2UgXCJ0b3BcIjpcbiAgICAgICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgICAgIHRyYW5zbGF0aW9uWCA9ICh3aWR0aDIgLSBsZWdlbmRCQm94LndpZHRoKSAvIDI7XG4gICAgICAgICAgdHJhbnNsYXRpb25ZID0gY2FsY3VsYXRlVHJhbnNsYXRpb25QZXJwZW5kaWN1bGFyRGltZW5zaW9uKCk7XG4gICAgICAgICAgbGF5b3V0Qm94LnNocmluayhsZWdlbmRCQm94LmhlaWdodCArIGxlZ2VuZFBhZGRpbmcsIHRoaXMucG9zaXRpb24pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0cmFuc2xhdGlvblggPSBjYWxjdWxhdGVUcmFuc2xhdGlvblBlcnBlbmRpY3VsYXJEaW1lbnNpb24oKTtcbiAgICAgICAgICB0cmFuc2xhdGlvblkgPSAoaGVpZ2h0MiAtIGxlZ2VuZEJCb3guaGVpZ2h0KSAvIDI7XG4gICAgICAgICAgbGF5b3V0Qm94LnNocmluayhsZWdlbmRCQm94LndpZHRoICsgbGVnZW5kUGFkZGluZywgdGhpcy5wb3NpdGlvbik7XG4gICAgICB9XG4gICAgICB0aGlzLmdyb3VwLnRyYW5zbGF0aW9uWCA9IE1hdGguZmxvb3IoeCArIHRyYW5zbGF0aW9uWCAtIGxlZ2VuZEJCb3gueCk7XG4gICAgICB0aGlzLmdyb3VwLnRyYW5zbGF0aW9uWSA9IE1hdGguZmxvb3IoeSArIHRyYW5zbGF0aW9uWSAtIGxlZ2VuZEJCb3gueSk7XG4gICAgICB0aGlzLnByb3h5TGVnZW5kVG9vbGJhci5hcmlhT3JpZW50YXRpb24gPSB0aGlzLmdldE9yaWVudGF0aW9uKCk7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlSXRlbVByb3h5QnV0dG9ucygpO1xuICAgIHRoaXMudXBkYXRlUGFnaW5hdGlvblByb3h5QnV0dG9ucyhvbGRQYWdlcyk7XG4gIH1cbiAgY2FsY3VsYXRlTGVnZW5kRGltZW5zaW9ucyhzaHJpbmtSZWN0KSB7XG4gICAgY29uc3QgeyB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIgfSA9IHNocmlua1JlY3Q7XG4gICAgY29uc3QgYXNwZWN0UmF0aW8gPSB3aWR0aDIgLyBoZWlnaHQyO1xuICAgIGNvbnN0IG1heENvZWZmaWNpZW50ID0gMC41O1xuICAgIGNvbnN0IG1pbkhlaWdodENvZWZmaWNpZW50ID0gMC4yO1xuICAgIGNvbnN0IG1pbldpZHRoQ29lZmZpY2llbnQgPSAwLjI1O1xuICAgIGxldCBsZWdlbmRXaWR0aCwgbGVnZW5kSGVpZ2h0O1xuICAgIHN3aXRjaCAodGhpcy5wb3NpdGlvbikge1xuICAgICAgY2FzZSBcInRvcFwiOlxuICAgICAgY2FzZSBcImJvdHRvbVwiOiB7XG4gICAgICAgIGNvbnN0IGhlaWdodENvZWZmaWNpZW50ID0gYXNwZWN0UmF0aW8gPCAxID8gTWF0aC5taW4obWF4Q29lZmZpY2llbnQsIG1pbkhlaWdodENvZWZmaWNpZW50ICogKDEgLyBhc3BlY3RSYXRpbykpIDogbWluSGVpZ2h0Q29lZmZpY2llbnQ7XG4gICAgICAgIGxlZ2VuZFdpZHRoID0gdGhpcy5tYXhXaWR0aCA/IE1hdGgubWluKHRoaXMubWF4V2lkdGgsIHdpZHRoMikgOiB3aWR0aDI7XG4gICAgICAgIGxlZ2VuZEhlaWdodCA9IHRoaXMubWF4SGVpZ2h0ID8gTWF0aC5taW4odGhpcy5tYXhIZWlnaHQsIGhlaWdodDIpIDogTWF0aC5yb3VuZChoZWlnaHQyICogaGVpZ2h0Q29lZmZpY2llbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgY29uc3Qgd2lkdGhDb2VmZmljaWVudCA9IGFzcGVjdFJhdGlvID4gMSA/IE1hdGgubWluKG1heENvZWZmaWNpZW50LCBtaW5XaWR0aENvZWZmaWNpZW50ICogYXNwZWN0UmF0aW8pIDogbWluV2lkdGhDb2VmZmljaWVudDtcbiAgICAgICAgbGVnZW5kV2lkdGggPSB0aGlzLm1heFdpZHRoID8gTWF0aC5taW4odGhpcy5tYXhXaWR0aCwgd2lkdGgyKSA6IE1hdGgucm91bmQod2lkdGgyICogd2lkdGhDb2VmZmljaWVudCk7XG4gICAgICAgIGxlZ2VuZEhlaWdodCA9IHRoaXMubWF4SGVpZ2h0ID8gTWF0aC5taW4odGhpcy5tYXhIZWlnaHQsIGhlaWdodDIpIDogaGVpZ2h0MjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtsZWdlbmRXaWR0aCwgbGVnZW5kSGVpZ2h0XTtcbiAgfVxufTtcbkxlZ2VuZC5jbGFzc05hbWUgPSBcIkxlZ2VuZFwiO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIExlZ2VuZC5wcm90b3R5cGUsIFwidG9nZ2xlU2VyaWVzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgTGVnZW5kLnByb3RvdHlwZSwgXCJwYWdpbmF0aW9uXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgTGVnZW5kLnByb3RvdHlwZSwgXCJpdGVtXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgTGVnZW5kLnByb3RvdHlwZSwgXCJsaXN0ZW5lcnNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBPYnNlcnZlQ2hhbmdlcygodGFyZ2V0KSA9PiB0YXJnZXQudXBkYXRlR3JvdXBWaXNpYmlsaXR5KCkpLFxuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgTGVnZW5kLnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgT2JzZXJ2ZUNoYW5nZXMoKHRhcmdldCkgPT4gdGFyZ2V0LnByb3h5TGVnZW5kRGlydHkgPSB0cnVlKSxcbiAgVmFsaWRhdGUoUE9TSVRJT04pXG5dLCBMZWdlbmQucHJvdG90eXBlLCBcInBvc2l0aW9uXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBMZWdlbmQucHJvdG90eXBlLCBcIm1heFdpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBMZWdlbmQucHJvdG90eXBlLCBcIm1heEhlaWdodFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIExlZ2VuZC5wcm90b3R5cGUsIFwicmV2ZXJzZU9yZGVyXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoVU5JT04oW1wiaG9yaXpvbnRhbFwiLCBcInZlcnRpY2FsXCJdLCBcImFuIG9yaWVudGF0aW9uXCIpLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBMZWdlbmQucHJvdG90eXBlLCBcIm9yaWVudGF0aW9uXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGVnZW5kLnByb3RvdHlwZSwgXCJwcmV2ZW50SGlkaW5nQWxsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgTGVnZW5kLnByb3RvdHlwZSwgXCJzcGFjaW5nXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9sZWdlbmRNb2R1bGUudHNcbnZhciBDb21tdW5pdHlMZWdlbmRNb2R1bGUgPSB7XG4gIHR5cGU6IFwibGVnZW5kXCIsXG4gIG9wdGlvbnNLZXk6IFwibGVnZW5kXCIsXG4gIGlkZW50aWZpZXI6IFwiY2F0ZWdvcnlcIixcbiAgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCIsIFwicG9sYXJcIiwgXCJoaWVyYXJjaHlcIiwgXCJ0b3BvbG9neVwiLCBcImZsb3ctcHJvcG9ydGlvblwiLCBcInN0YW5kYWxvbmVcIiwgXCJnYXVnZVwiXSxcbiAgbW9kdWxlRmFjdG9yeTogKGN0eCkgPT4gbmV3IExlZ2VuZChjdHgpLFxuICBwYWNrYWdlVHlwZTogXCJjb21tdW5pdHlcIlxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbmF2aWdhdG9yL3NoYXBlcy9yYW5nZUhhbmRsZS50c1xudmFyIFJhbmdlSGFuZGxlID0gY2xhc3MgZXh0ZW5kcyBQYXRoIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnpJbmRleCA9IDM7XG4gICAgdGhpcy5jZW50ZXJYID0gMDtcbiAgICB0aGlzLmNlbnRlclkgPSAwO1xuICAgIHRoaXMud2lkdGggPSA4O1xuICAgIHRoaXMuaGVpZ2h0ID0gMTY7XG4gICAgdGhpcy5ncmlwTGluZUdhcCA9IDI7XG4gICAgdGhpcy5ncmlwTGluZUxlbmd0aCA9IDg7XG4gIH1cbiAgc2V0Q2VudGVyKHgsIHkpIHtcbiAgICB0aGlzLmRpcnR5UGF0aCA9IHRydWU7XG4gICAgaWYgKHRoaXMuY2VudGVyWCAhPT0geCB8fCB0aGlzLmNlbnRlclkgIT09IHkpIHtcbiAgICAgIHRoaXMuY2VudGVyWCA9IHg7XG4gICAgICB0aGlzLmNlbnRlclkgPSB5O1xuICAgICAgdGhpcy5tYXJrRGlydHkoMyAvKiBNQUpPUiAqLyk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBhbGlnbihtaW5IYW5kbGUsIG1heEhhbmRsZSwgeCwgeSwgd2lkdGgyLCBoZWlnaHQyLCBtaW4sIG1heCkge1xuICAgIGNvbnN0IGhhbmRsZVBpeGVsQWxpZ24gPSBtaW5IYW5kbGUuc3Ryb2tlV2lkdGggLyAyO1xuICAgIGNvbnN0IG1pbkhhbmRsZVggPSBtaW5IYW5kbGUuYWxpZ24oeCArIHdpZHRoMiAqIG1pbikgKyBoYW5kbGVQaXhlbEFsaWduO1xuICAgIGNvbnN0IG1heEhhbmRsZVggPSBtaW5IYW5kbGVYICsgbWluSGFuZGxlLmFsaWduKHggKyB3aWR0aDIgKiBtaW4sIHdpZHRoMiAqIChtYXggLSBtaW4pKSAtIDIgKiBoYW5kbGVQaXhlbEFsaWduO1xuICAgIGNvbnN0IGhhbmRsZVkgPSBtaW5IYW5kbGUuYWxpZ24oeSArIGhlaWdodDIgLyAyKSArIGhhbmRsZVBpeGVsQWxpZ247XG4gICAgbWluSGFuZGxlLnNldENlbnRlcihtaW5IYW5kbGVYLCBoYW5kbGVZKTtcbiAgICBtYXhIYW5kbGUuc2V0Q2VudGVyKG1heEhhbmRsZVgsIGhhbmRsZVkpO1xuICB9XG4gIGNvbXB1dGVCQm94KCkge1xuICAgIGNvbnN0IHsgY2VudGVyWCwgY2VudGVyWSwgd2lkdGg6IHdpZHRoMiwgaGVpZ2h0OiBoZWlnaHQyIH0gPSB0aGlzO1xuICAgIGNvbnN0IHggPSBjZW50ZXJYIC0gd2lkdGgyIC8gMjtcbiAgICBjb25zdCB5ID0gY2VudGVyWSAtIGhlaWdodDIgLyAyO1xuICAgIHJldHVybiBuZXcgQkJveCh4LCB5LCB3aWR0aDIsIGhlaWdodDIpO1xuICB9XG4gIGlzUG9pbnRJblBhdGgoeCwgeSkge1xuICAgIGNvbnN0IGJib3ggPSB0aGlzLmdldEJCb3goKTtcbiAgICByZXR1cm4gYmJveC5jb250YWluc1BvaW50KHgsIHkpO1xuICB9XG4gIHVwZGF0ZVBhdGgoKSB7XG4gICAgY29uc3QgeyBjZW50ZXJYLCBjZW50ZXJZLCBwYXRoLCBzdHJva2VXaWR0aCwgZ3JpcExpbmVHYXAsIGdyaXBMaW5lTGVuZ3RoIH0gPSB0aGlzO1xuICAgIGNvbnN0IHBpeGVsUmF0aW8gPSB0aGlzLmxheWVyTWFuYWdlcj8uY2FudmFzPy5waXhlbFJhdGlvID8/IDE7XG4gICAgcGF0aC5jbGVhcigpO1xuICAgIGNvbnN0IGhhbGZXaWR0aCA9IE1hdGguZmxvb3IodGhpcy53aWR0aCAvIDIgKiBwaXhlbFJhdGlvKSAvIHBpeGVsUmF0aW87XG4gICAgY29uc3QgaGFsZkhlaWdodCA9IE1hdGguZmxvb3IodGhpcy5oZWlnaHQgLyAyICogcGl4ZWxSYXRpbykgLyBwaXhlbFJhdGlvO1xuICAgIHBhdGgubW92ZVRvKGNlbnRlclggLSBoYWxmV2lkdGgsIGNlbnRlclkgLSBoYWxmSGVpZ2h0KTtcbiAgICBwYXRoLmxpbmVUbyhjZW50ZXJYICsgaGFsZldpZHRoLCBjZW50ZXJZIC0gaGFsZkhlaWdodCk7XG4gICAgcGF0aC5saW5lVG8oY2VudGVyWCArIGhhbGZXaWR0aCwgY2VudGVyWSArIGhhbGZIZWlnaHQpO1xuICAgIHBhdGgubGluZVRvKGNlbnRlclggLSBoYWxmV2lkdGgsIGNlbnRlclkgKyBoYWxmSGVpZ2h0KTtcbiAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICAgIGNvbnN0IGR4ID0gTWF0aC5mbG9vcigoZ3JpcExpbmVHYXAgKyBzdHJva2VXaWR0aCkgLyAyICogcGl4ZWxSYXRpbykgLyBwaXhlbFJhdGlvO1xuICAgIGNvbnN0IGR5ID0gTWF0aC5mbG9vcihncmlwTGluZUxlbmd0aCAvIDIgKiBwaXhlbFJhdGlvKSAvIHBpeGVsUmF0aW87XG4gICAgcGF0aC5tb3ZlVG8oY2VudGVyWCAtIGR4LCBjZW50ZXJZIC0gZHkpO1xuICAgIHBhdGgubGluZVRvKGNlbnRlclggLSBkeCwgY2VudGVyWSArIGR5KTtcbiAgICBwYXRoLm1vdmVUbyhjZW50ZXJYICsgZHgsIGNlbnRlclkgLSBkeSk7XG4gICAgcGF0aC5saW5lVG8oY2VudGVyWCArIGR4LCBjZW50ZXJZICsgZHkpO1xuICB9XG59O1xuUmFuZ2VIYW5kbGUuY2xhc3NOYW1lID0gXCJSYW5nZUhhbmRsZVwiO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKSxcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8sIHR5cGU6IFwicGF0aFwiIH0pXG5dLCBSYW5nZUhhbmRsZS5wcm90b3R5cGUsIFwid2lkdGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpLFxuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLywgdHlwZTogXCJwYXRoXCIgfSlcbl0sIFJhbmdlSGFuZGxlLnByb3RvdHlwZSwgXCJoZWlnaHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpLFxuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLywgdHlwZTogXCJwYXRoXCIgfSlcbl0sIFJhbmdlSGFuZGxlLnByb3RvdHlwZSwgXCJncmlwTGluZUdhcFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiksXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovLCB0eXBlOiBcInBhdGhcIiB9KVxuXSwgUmFuZ2VIYW5kbGUucHJvdG90eXBlLCBcImdyaXBMaW5lTGVuZ3RoXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9uYXZpZ2F0b3Ivc2hhcGVzL3JhbmdlTWFzay50c1xudmFyIFJhbmdlTWFzayA9IGNsYXNzIGV4dGVuZHMgUGF0aCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy56SW5kZXggPSAyO1xuICAgIHRoaXMueCA9IDA7XG4gICAgdGhpcy55ID0gMDtcbiAgICB0aGlzLndpZHRoID0gMjAwO1xuICAgIHRoaXMuaGVpZ2h0ID0gMzA7XG4gICAgdGhpcy5taW4gPSAwO1xuICAgIHRoaXMubWF4ID0gMTtcbiAgfVxuICBsYXlvdXQoeCwgeSwgd2lkdGgyLCBoZWlnaHQyKSB7XG4gICAgaWYgKHggIT09IHRoaXMueCB8fCB5ICE9PSB0aGlzLnkgfHwgd2lkdGgyICE9PSB0aGlzLndpZHRoIHx8IHRoaXMuaGVpZ2h0ICE9PSBoZWlnaHQyKSB7XG4gICAgICB0aGlzLnggPSB4O1xuICAgICAgdGhpcy55ID0geTtcbiAgICAgIHRoaXMud2lkdGggPSB3aWR0aDI7XG4gICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDI7XG4gICAgICB0aGlzLmRpcnR5UGF0aCA9IHRydWU7XG4gICAgICB0aGlzLm1hcmtEaXJ0eSgzIC8qIE1BSk9SICovKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlKG1pbiwgbWF4KSB7XG4gICAgbWluID0gaXNOYU4obWluKSA/IHRoaXMubWluIDogbWluO1xuICAgIG1heCA9IGlzTmFOKG1heCkgPyB0aGlzLm1heCA6IG1heDtcbiAgICBpZiAobWluICE9PSB0aGlzLm1pbiB8fCBtYXggIT09IHRoaXMubWF4KSB7XG4gICAgICB0aGlzLm1pbiA9IG1pbjtcbiAgICAgIHRoaXMubWF4ID0gbWF4O1xuICAgICAgdGhpcy5kaXJ0eVBhdGggPSB0cnVlO1xuICAgICAgdGhpcy5tYXJrRGlydHkoMyAvKiBNQUpPUiAqLyk7XG4gICAgfVxuICB9XG4gIGNvbXB1dGVCQm94KCkge1xuICAgIGNvbnN0IHsgeCwgeSwgd2lkdGg6IHdpZHRoMiwgaGVpZ2h0OiBoZWlnaHQyIH0gPSB0aGlzO1xuICAgIHJldHVybiBuZXcgQkJveCh4LCB5LCB3aWR0aDIsIGhlaWdodDIpO1xuICB9XG4gIGNvbXB1dGVWaXNpYmxlUmFuZ2VCQm94KCkge1xuICAgIGNvbnN0IHsgeCwgeSwgd2lkdGg6IHdpZHRoMiwgaGVpZ2h0OiBoZWlnaHQyLCBtaW4sIG1heCB9ID0gdGhpcztcbiAgICBjb25zdCBtaW5YID0geCArIHdpZHRoMiAqIG1pbjtcbiAgICBjb25zdCBtYXhYID0geCArIHdpZHRoMiAqIG1heDtcbiAgICByZXR1cm4gbmV3IEJCb3gobWluWCwgeSwgbWF4WCAtIG1pblgsIGhlaWdodDIpO1xuICB9XG4gIHVwZGF0ZVBhdGgoKSB7XG4gICAgY29uc3QgeyBwYXRoLCB4LCB5LCB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIsIG1pbiwgbWF4LCBzdHJva2VXaWR0aCB9ID0gdGhpcztcbiAgICBjb25zdCBwaXhlbEFsaWduID0gc3Ryb2tlV2lkdGggLyAyO1xuICAgIHBhdGguY2xlYXIoKTtcbiAgICBjb25zdCBheCA9IHRoaXMuYWxpZ24oeCkgKyBwaXhlbEFsaWduO1xuICAgIGNvbnN0IGF5ID0gdGhpcy5hbGlnbih5KSArIHBpeGVsQWxpZ247XG4gICAgY29uc3QgYXh3ID0gYXggKyB0aGlzLmFsaWduKHgsIHdpZHRoMikgLSAyICogcGl4ZWxBbGlnbjtcbiAgICBjb25zdCBheWggPSBheSArIHRoaXMuYWxpZ24oeSwgaGVpZ2h0MikgLSAyICogcGl4ZWxBbGlnbjtcbiAgICBwYXRoLm1vdmVUbyhheCwgYXkpO1xuICAgIHBhdGgubGluZVRvKGF4dywgYXkpO1xuICAgIHBhdGgubGluZVRvKGF4dywgYXloKTtcbiAgICBwYXRoLmxpbmVUbyhheCwgYXloKTtcbiAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICAgIGNvbnN0IG1pblggPSB0aGlzLmFsaWduKHggKyB3aWR0aDIgKiBtaW4pICsgcGl4ZWxBbGlnbjtcbiAgICBjb25zdCBtYXhYID0gbWluWCArIHRoaXMuYWxpZ24oeCArIHdpZHRoMiAqIG1pbiwgd2lkdGgyICogKG1heCAtIG1pbikpIC0gMiAqIHBpeGVsQWxpZ247XG4gICAgcGF0aC5tb3ZlVG8obWluWCwgYXkpO1xuICAgIHBhdGgubGluZVRvKG1pblgsIGF5aCk7XG4gICAgcGF0aC5saW5lVG8obWF4WCwgYXloKTtcbiAgICBwYXRoLmxpbmVUbyhtYXhYLCBheSk7XG4gICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgfVxufTtcblJhbmdlTWFzay5jbGFzc05hbWUgPSBcIlJhbmdlTWFza1wiO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9uYXZpZ2F0b3Ivc2hhcGVzL3JhbmdlU2VsZWN0b3IudHNcbnZhciBSYW5nZVNlbGVjdG9yID0gY2xhc3MgZXh0ZW5kcyBMYXllciB7XG4gIGNvbnN0cnVjdG9yKGNoaWxkcmVuKSB7XG4gICAgc3VwZXIoeyBuYW1lOiBcInJhbmdlU2VsZWN0b3JHcm91cFwiLCB6SW5kZXg6IDE2IC8qIE5BVklHQVRPUiAqLyB9KTtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gICAgdGhpcy53aWR0aCA9IDIwMDtcbiAgICB0aGlzLmhlaWdodCA9IDMwO1xuICAgIHRoaXMubE9mZnNldCA9IDA7XG4gICAgdGhpcy5yT2Zmc2V0ID0gMDtcbiAgICB0aGlzLmJhY2tncm91bmQgPSB0aGlzLmFwcGVuZENoaWxkKG5ldyBUcmFuc2xhdGFibGVHcm91cCh7IG5hbWU6IFwibmF2aWdhdG9yLWJhY2tncm91bmRcIiwgekluZGV4OiAxIH0pKTtcbiAgICB0aGlzLmFwcGVuZChjaGlsZHJlbik7XG4gIH1cbiAgbGF5b3V0KHgsIHksIHdpZHRoMiwgaGVpZ2h0MiwgbE9mZnNldCwgck9mZnNldCkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLndpZHRoID0gd2lkdGgyO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0MjtcbiAgICB0aGlzLmxPZmZzZXQgPSBsT2Zmc2V0O1xuICAgIHRoaXMuck9mZnNldCA9IHJPZmZzZXQ7XG4gICAgdGhpcy5iYWNrZ3JvdW5kLnRyYW5zbGF0aW9uWCA9IHg7XG4gICAgdGhpcy5iYWNrZ3JvdW5kLnRyYW5zbGF0aW9uWSA9IHk7XG4gICAgdGhpcy5tYXJrRGlydHkoMyAvKiBNQUpPUiAqLyk7XG4gIH1cbiAgdXBkYXRlQmFja2dyb3VuZChvbGRHcm91cCwgbmV3R3JvdXApIHtcbiAgICBpZiAob2xkR3JvdXAgIT0gbnVsbCkge1xuICAgICAgdGhpcy5iYWNrZ3JvdW5kLnJlbW92ZUNoaWxkKG9sZEdyb3VwKTtcbiAgICB9XG4gICAgaWYgKG5ld0dyb3VwICE9IG51bGwpIHtcbiAgICAgIHRoaXMuYmFja2dyb3VuZC5hcHBlbmRDaGlsZChuZXdHcm91cCk7XG4gICAgfVxuICAgIHRoaXMubWFya0RpcnR5KDMgLyogTUFKT1IgKi8pO1xuICB9XG4gIGNvbXB1dGVCQm94KCkge1xuICAgIGNvbnN0IHsgeCwgeSwgd2lkdGg6IHdpZHRoMiwgaGVpZ2h0OiBoZWlnaHQyLCBsT2Zmc2V0LCByT2Zmc2V0IH0gPSB0aGlzO1xuICAgIHJldHVybiBuZXcgQkJveCh4IC0gbE9mZnNldCwgeSwgd2lkdGgyICsgKGxPZmZzZXQgKyByT2Zmc2V0KSwgaGVpZ2h0Mik7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L25hdmlnYXRvci9uYXZpZ2F0b3IudHNcbnZhciBOYXZpZ2F0b3IgPSBjbGFzcyBleHRlbmRzIEJhc2VNb2R1bGVJbnN0YW5jZSB7XG4gIGNvbnN0cnVjdG9yKGN0eCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy5taW5pQ2hhcnQgPSB2b2lkIDA7XG4gICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XG4gICAgdGhpcy5tYXNrID0gbmV3IFJhbmdlTWFzaygpO1xuICAgIHRoaXMubWluSGFuZGxlID0gbmV3IFJhbmdlSGFuZGxlKCk7XG4gICAgdGhpcy5tYXhIYW5kbGUgPSBuZXcgUmFuZ2VIYW5kbGUoKTtcbiAgICB0aGlzLm1hc2tWaXNpYmxlUmFuZ2UgPSB7XG4gICAgICBpZDogXCJuYXZpZ2F0b3ItbWFzay12aXNpYmxlLXJhbmdlXCIsXG4gICAgICBnZXRCQm94OiAoKSA9PiB0aGlzLm1hc2suY29tcHV0ZVZpc2libGVSYW5nZUJCb3goKSxcbiAgICAgIHRvQ2FudmFzQkJveDogKCkgPT4gdGhpcy5tYXNrLmNvbXB1dGVWaXNpYmxlUmFuZ2VCQm94KCksXG4gICAgICBmcm9tQ2FudmFzUG9pbnQ6ICh4LCB5KSA9PiAoeyB4LCB5IH0pXG4gICAgfTtcbiAgICB0aGlzLmhlaWdodCA9IDMwO1xuICAgIHRoaXMuc3BhY2luZyA9IDEwO1xuICAgIHRoaXMueCA9IDA7XG4gICAgdGhpcy55ID0gMDtcbiAgICB0aGlzLndpZHRoID0gMDtcbiAgICB0aGlzLnJhbmdlU2VsZWN0b3IgPSBuZXcgUmFuZ2VTZWxlY3RvcihbdGhpcy5tYXNrLCB0aGlzLm1pbkhhbmRsZSwgdGhpcy5tYXhIYW5kbGVdKTtcbiAgICB0aGlzLl9taW4gPSAwO1xuICAgIHRoaXMuX21heCA9IDE7XG4gICAgdGhpcy5taW5SYW5nZSA9IDFlLTM7XG4gICAgY29uc3QgcmVnaW9uID0gY3R4LnJlZ2lvbk1hbmFnZXIuYWRkUmVnaW9uKFwibmF2aWdhdG9yXCIsIHRoaXMucmFuZ2VTZWxlY3Rvcik7XG4gICAgY29uc3QgZHJhZ1N0YXRlcyA9IDMyIC8qIERlZmF1bHQgKi8gfCAyIC8qIEFuaW1hdGlvbiAqLyB8IDE2IC8qIFpvb21EcmFnICovO1xuICAgIHRoaXMuZGVzdHJveUZucy5wdXNoKFxuICAgICAgY3R4LnNjZW5lLmF0dGFjaE5vZGUodGhpcy5yYW5nZVNlbGVjdG9yKSxcbiAgICAgIHJlZ2lvbi5hZGRMaXN0ZW5lcihcImhvdmVyXCIsIChldmVudCkgPT4gdGhpcy5vbkhvdmVyKGV2ZW50KSwgZHJhZ1N0YXRlcyksXG4gICAgICByZWdpb24uYWRkTGlzdGVuZXIoXCJkcmFnLXN0YXJ0XCIsIChldmVudCkgPT4gdGhpcy5vbkRyYWdTdGFydChldmVudCksIGRyYWdTdGF0ZXMpLFxuICAgICAgcmVnaW9uLmFkZExpc3RlbmVyKFwiZHJhZ1wiLCAoZXZlbnQpID0+IHRoaXMub25EcmFnKGV2ZW50KSwgZHJhZ1N0YXRlcyksXG4gICAgICByZWdpb24uYWRkTGlzdGVuZXIoXCJkcmFnLWVuZFwiLCAoZXZlbnQpID0+IHRoaXMub25EcmFnRW5kKGV2ZW50KSwgZHJhZ1N0YXRlcyksXG4gICAgICByZWdpb24uYWRkTGlzdGVuZXIoXCJsZWF2ZVwiLCAoZXZlbnQpID0+IHRoaXMub25MZWF2ZShldmVudCksIGRyYWdTdGF0ZXMpLFxuICAgICAgdGhpcy5jdHgubG9jYWxlTWFuYWdlci5hZGRMaXN0ZW5lcihcImxvY2FsZS1jaGFuZ2VkXCIsICgpID0+IHRoaXMudXBkYXRlWm9vbSgpKSxcbiAgICAgIHRoaXMuY3R4LmxheW91dE1hbmFnZXIucmVnaXN0ZXJFbGVtZW50KDMgLyogTmF2aWdhdG9yICovLCAoZSkgPT4gdGhpcy5vbkxheW91dFN0YXJ0KGUpKSxcbiAgICAgIHRoaXMuY3R4LmxheW91dE1hbmFnZXIuYWRkTGlzdGVuZXIoXCJsYXlvdXQ6Y29tcGxldGVcIiwgKGUpID0+IHRoaXMub25MYXlvdXRDb21wbGV0ZShlKSksXG4gICAgICBjdHguem9vbU1hbmFnZXIuYWRkTGlzdGVuZXIoXCJ6b29tLWNoYW5nZVwiLCAoZXZlbnQpID0+IHRoaXMub25ab29tQ2hhbmdlKGV2ZW50KSlcbiAgICApO1xuICAgIHRoaXMucHJveHlOYXZpZ2F0b3JUb29sYmFyID0gdGhpcy5jdHgucHJveHlJbnRlcmFjdGlvblNlcnZpY2UuY3JlYXRlUHJveHlDb250YWluZXIoe1xuICAgICAgdHlwZTogXCJ0b29sYmFyXCIsXG4gICAgICBpZDogYG5hdmlnYXRvci10b29sYmFyYCxcbiAgICAgIGNsYXNzTGlzdDogW1wiYWctY2hhcnRzLXByb3h5LW5hdmlnYXRvci10b29sYmFyXCJdLFxuICAgICAgYXJpYU9yaWVudGF0aW9uOiBcInZlcnRpY2FsXCIsXG4gICAgICBhcmlhTGFiZWw6IHsgaWQ6IFwiYXJpYUxhYmVsTmF2aWdhdG9yXCIgfVxuICAgIH0pO1xuICAgIHRoaXMudXBkYXRlR3JvdXBWaXNpYmlsaXR5KCk7XG4gICAgdGhpcy5wcm94eU5hdmlnYXRvckVsZW1lbnRzID0gW1xuICAgICAgdGhpcy5jdHgucHJveHlJbnRlcmFjdGlvblNlcnZpY2UuY3JlYXRlUHJveHlFbGVtZW50KHtcbiAgICAgICAgdHlwZTogXCJzbGlkZXJcIixcbiAgICAgICAgaWQ6IFwiYWctY2hhcnRzLW5hdmlnYXRvci1taW5cIixcbiAgICAgICAgYXJpYUxhYmVsOiB7IGlkOiBcImFyaWFMYWJlbE5hdmlnYXRvck1pbmltdW1cIiB9LFxuICAgICAgICBhcmlhT3JpZW50YXRpb246IFwiaG9yaXpvbnRhbFwiLFxuICAgICAgICBwYXJlbnQ6IHRoaXMucHJveHlOYXZpZ2F0b3JUb29sYmFyLFxuICAgICAgICBvbmNoYW5nZTogKGV2KSA9PiB0aGlzLm9uTWluU2xpZGVyQ2hhbmdlKGV2KVxuICAgICAgfSksXG4gICAgICB0aGlzLmN0eC5wcm94eUludGVyYWN0aW9uU2VydmljZS5jcmVhdGVQcm94eUVsZW1lbnQoe1xuICAgICAgICB0eXBlOiBcInNsaWRlclwiLFxuICAgICAgICBpZDogXCJhZy1jaGFydHMtbmF2aWdhdG9yLXBhblwiLFxuICAgICAgICBhcmlhTGFiZWw6IHsgaWQ6IFwiYXJpYUxhYmVsTmF2aWdhdG9yUmFuZ2VcIiB9LFxuICAgICAgICBhcmlhT3JpZW50YXRpb246IFwiaG9yaXpvbnRhbFwiLFxuICAgICAgICBwYXJlbnQ6IHRoaXMucHJveHlOYXZpZ2F0b3JUb29sYmFyLFxuICAgICAgICBvbmNoYW5nZTogKGV2KSA9PiB0aGlzLm9uUGFuU2xpZGVyQ2hhbmdlKGV2KVxuICAgICAgfSksXG4gICAgICB0aGlzLmN0eC5wcm94eUludGVyYWN0aW9uU2VydmljZS5jcmVhdGVQcm94eUVsZW1lbnQoe1xuICAgICAgICB0eXBlOiBcInNsaWRlclwiLFxuICAgICAgICBpZDogXCJhZy1jaGFydHMtbmF2aWdhdG9yLW1heFwiLFxuICAgICAgICBhcmlhTGFiZWw6IHsgaWQ6IFwiYXJpYUxhYmVsTmF2aWdhdG9yTWF4aW11bVwiIH0sXG4gICAgICAgIGFyaWFPcmllbnRhdGlvbjogXCJob3Jpem9udGFsXCIsXG4gICAgICAgIHBhcmVudDogdGhpcy5wcm94eU5hdmlnYXRvclRvb2xiYXIsXG4gICAgICAgIG9uY2hhbmdlOiAoZXYpID0+IHRoaXMub25NYXhTbGlkZXJDaGFuZ2UoZXYpXG4gICAgICB9KVxuICAgIF07XG4gICAgdGhpcy5wcm94eU5hdmlnYXRvckVsZW1lbnRzLmZvckVhY2goKHNsaWRlcikgPT4gc2V0QXR0cmlidXRlKHNsaWRlciwgXCJkYXRhLXByZXZlbnRkZWZhdWx0XCIsIGZhbHNlKSk7XG4gICAgdGhpcy5zZXRTbGlkZXJSYXRpbyh0aGlzLnByb3h5TmF2aWdhdG9yRWxlbWVudHNbMF0sIHRoaXMuX21pbik7XG4gICAgdGhpcy5zZXRTbGlkZXJSYXRpbyh0aGlzLnByb3h5TmF2aWdhdG9yRWxlbWVudHNbMl0sIHRoaXMuX21heCk7XG4gICAgdGhpcy5zZXRQYW5TbGlkZXJWYWx1ZSh0aGlzLl9taW4sIHRoaXMuX21heCk7XG4gICAgaW5pdFRvb2xiYXJLZXlOYXYoe1xuICAgICAgb3JpZW50YXRpb246IFwidmVydGljYWxcIixcbiAgICAgIHRvb2xiYXI6IHRoaXMucHJveHlOYXZpZ2F0b3JUb29sYmFyLFxuICAgICAgYnV0dG9uczogdGhpcy5wcm94eU5hdmlnYXRvckVsZW1lbnRzXG4gICAgfSk7XG4gICAgdGhpcy5kZXN0cm95Rm5zLnB1c2goKCkgPT4ge1xuICAgICAgdGhpcy5wcm94eU5hdmlnYXRvckVsZW1lbnRzLmZvckVhY2goKGUpID0+IGUucmVtb3ZlKCkpO1xuICAgICAgdGhpcy5wcm94eU5hdmlnYXRvclRvb2xiYXIucmVtb3ZlKCk7XG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlQmFja2dyb3VuZChvbGRHcm91cCwgbmV3R3JvdXApIHtcbiAgICB0aGlzLnJhbmdlU2VsZWN0b3I/LnVwZGF0ZUJhY2tncm91bmQob2xkR3JvdXAsIG5ld0dyb3VwKTtcbiAgfVxuICB1cGRhdGVHcm91cFZpc2liaWxpdHkoKSB7XG4gICAgY29uc3QgeyBlbmFibGVkIH0gPSB0aGlzO1xuICAgIGlmICh0aGlzLnJhbmdlU2VsZWN0b3IgPT0gbnVsbCB8fCBlbmFibGVkID09PSB0aGlzLnJhbmdlU2VsZWN0b3IudmlzaWJsZSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLnJhbmdlU2VsZWN0b3IudmlzaWJsZSA9IGVuYWJsZWQ7XG4gICAgdGhpcy5wcm94eU5hdmlnYXRvclRvb2xiYXIuYXJpYUhpZGRlbiA9ICghZW5hYmxlZCkudG9TdHJpbmcoKTtcbiAgICBpZiAoZW5hYmxlZCkge1xuICAgICAgdGhpcy51cGRhdGVab29tKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3R4Lnpvb21NYW5hZ2VyLnVwZGF0ZVpvb20oXCJuYXZpZ2F0b3JcIik7XG4gICAgfVxuICB9XG4gIG9uTGF5b3V0U3RhcnQoY3R4KSB7XG4gICAgaWYgKHRoaXMuZW5hYmxlZCkge1xuICAgICAgY29uc3QgeyBsYXlvdXRCb3ggfSA9IGN0eDtcbiAgICAgIGNvbnN0IG5hdmlnYXRvclRvdGFsSGVpZ2h0ID0gdGhpcy5oZWlnaHQgKyB0aGlzLnNwYWNpbmc7XG4gICAgICBsYXlvdXRCb3guc2hyaW5rKG5hdmlnYXRvclRvdGFsSGVpZ2h0LCBcImJvdHRvbVwiKTtcbiAgICAgIHRoaXMueSA9IGxheW91dEJveC55ICsgbGF5b3V0Qm94LmhlaWdodCArIHRoaXMuc3BhY2luZztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy55ID0gMDtcbiAgICB9XG4gIH1cbiAgb25MYXlvdXRDb21wbGV0ZShvcHRzKSB7XG4gICAgY29uc3QgeyB4LCB3aWR0aDogd2lkdGgyIH0gPSBvcHRzLnNlcmllcy5yZWN0O1xuICAgIGlmICh0aGlzLmVuYWJsZWQpIHtcbiAgICAgIGNvbnN0IHsgeSwgaGVpZ2h0OiBoZWlnaHQyIH0gPSB0aGlzO1xuICAgICAgdGhpcy5sYXlvdXROb2Rlcyh4LCB5LCB3aWR0aDIsIGhlaWdodDIpO1xuICAgICAgc2V0RWxlbWVudEJCb3godGhpcy5wcm94eU5hdmlnYXRvclRvb2xiYXIsIHsgeCwgeSwgd2lkdGg6IHdpZHRoMiwgaGVpZ2h0OiBoZWlnaHQyIH0pO1xuICAgICAgdGhpcy5wcm94eU5hdmlnYXRvclRvb2xiYXIuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJkaXNwbGF5XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnByb3h5TmF2aWdhdG9yVG9vbGJhci5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgfVxuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoMjtcbiAgfVxuICBvbkhvdmVyKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy51cGRhdGVDdXJzb3IoZXZlbnQpO1xuICB9XG4gIHVwZGF0ZUN1cnNvcihldmVudCkge1xuICAgIGlmICghdGhpcy5lbmFibGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgbWFzaywgbWluSGFuZGxlLCBtYXhIYW5kbGUgfSA9IHRoaXM7XG4gICAgY29uc3QgeyByZWdpb25PZmZzZXRYLCByZWdpb25PZmZzZXRZIH0gPSBldmVudDtcbiAgICBpZiAobWluSGFuZGxlLmNvbnRhaW5zUG9pbnQocmVnaW9uT2Zmc2V0WCwgcmVnaW9uT2Zmc2V0WSkgfHwgbWF4SGFuZGxlLmNvbnRhaW5zUG9pbnQocmVnaW9uT2Zmc2V0WCwgcmVnaW9uT2Zmc2V0WSkpIHtcbiAgICAgIHRoaXMuY3R4LmN1cnNvck1hbmFnZXIudXBkYXRlQ3Vyc29yKFwibmF2aWdhdG9yXCIsIFwiZXctcmVzaXplXCIpO1xuICAgIH0gZWxzZSBpZiAobWFzay5jb21wdXRlVmlzaWJsZVJhbmdlQkJveCgpLmNvbnRhaW5zUG9pbnQocmVnaW9uT2Zmc2V0WCwgcmVnaW9uT2Zmc2V0WSkpIHtcbiAgICAgIHRoaXMuY3R4LmN1cnNvck1hbmFnZXIudXBkYXRlQ3Vyc29yKFwibmF2aWdhdG9yXCIsIFwiZ3JhYlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jdHguY3Vyc29yTWFuYWdlci51cGRhdGVDdXJzb3IoXCJuYXZpZ2F0b3JcIik7XG4gICAgfVxuICB9XG4gIG9uRHJhZ1N0YXJ0KGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy51cGRhdGVDdXJzb3IoZXZlbnQpO1xuICAgIGNvbnN0IHsgbWFzaywgbWluSGFuZGxlLCBtYXhIYW5kbGUsIHgsIHdpZHRoOiB3aWR0aDIsIF9taW46IG1pbiB9ID0gdGhpcztcbiAgICBjb25zdCB7IHJlZ2lvbk9mZnNldFgsIHJlZ2lvbk9mZnNldFkgfSA9IGV2ZW50O1xuICAgIGlmIChtaW5IYW5kbGUuekluZGV4IDwgbWF4SGFuZGxlLnpJbmRleCkge1xuICAgICAgaWYgKG1heEhhbmRsZS5jb250YWluc1BvaW50KHJlZ2lvbk9mZnNldFgsIHJlZ2lvbk9mZnNldFkpKSB7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBcIm1heFwiO1xuICAgICAgfSBlbHNlIGlmIChtaW5IYW5kbGUuY29udGFpbnNQb2ludChyZWdpb25PZmZzZXRYLCByZWdpb25PZmZzZXRZKSkge1xuICAgICAgICB0aGlzLmRyYWdnaW5nID0gXCJtaW5cIjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1pbkhhbmRsZS5jb250YWluc1BvaW50KHJlZ2lvbk9mZnNldFgsIHJlZ2lvbk9mZnNldFkpKSB7XG4gICAgICB0aGlzLmRyYWdnaW5nID0gXCJtaW5cIjtcbiAgICB9IGVsc2UgaWYgKG1heEhhbmRsZS5jb250YWluc1BvaW50KHJlZ2lvbk9mZnNldFgsIHJlZ2lvbk9mZnNldFkpKSB7XG4gICAgICB0aGlzLmRyYWdnaW5nID0gXCJtYXhcIjtcbiAgICB9XG4gICAgaWYgKHRoaXMuZHJhZ2dpbmcgPT0gbnVsbCAmJiBtYXNrLmNvbXB1dGVWaXNpYmxlUmFuZ2VCQm94KCkuY29udGFpbnNQb2ludChyZWdpb25PZmZzZXRYLCByZWdpb25PZmZzZXRZKSkge1xuICAgICAgdGhpcy5kcmFnZ2luZyA9IFwicGFuXCI7XG4gICAgICB0aGlzLnBhblN0YXJ0ID0gKHJlZ2lvbk9mZnNldFggLSB4KSAvIHdpZHRoMiAtIG1pbjtcbiAgICB9XG4gICAgaWYgKHRoaXMuZHJhZ2dpbmcgIT0gbnVsbCkge1xuICAgICAgdGhpcy5jdHguem9vbU1hbmFnZXIuZmlyZVpvb21QYW5TdGFydEV2ZW50KFwibmF2aWdhdG9yXCIpO1xuICAgIH1cbiAgfVxuICBvbkRyYWcoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlZCB8fCB0aGlzLmRyYWdnaW5nID09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBkcmFnZ2luZywgbWluUmFuZ2UsIHBhblN0YXJ0LCB4LCB3aWR0aDogd2lkdGgyIH0gPSB0aGlzO1xuICAgIGxldCB7IF9taW46IG1pbiwgX21heDogbWF4IH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgcmVnaW9uT2Zmc2V0WCB9ID0gZXZlbnQ7XG4gICAgY29uc3QgcmF0aW8yID0gKHJlZ2lvbk9mZnNldFggLSB4KSAvIHdpZHRoMjtcbiAgICBpZiAoZHJhZ2dpbmcgPT09IFwibWluXCIpIHtcbiAgICAgIG1pbiA9IGNsYW1wKDAsIHJhdGlvMiwgbWF4IC0gbWluUmFuZ2UpO1xuICAgIH0gZWxzZSBpZiAoZHJhZ2dpbmcgPT09IFwibWF4XCIpIHtcbiAgICAgIG1heCA9IGNsYW1wKG1pbiArIG1pblJhbmdlLCByYXRpbzIsIDEpO1xuICAgIH0gZWxzZSBpZiAoZHJhZ2dpbmcgPT09IFwicGFuXCIgJiYgcGFuU3RhcnQgIT0gbnVsbCkge1xuICAgICAgY29uc3Qgc3BhbiA9IG1heCAtIG1pbjtcbiAgICAgIG1pbiA9IGNsYW1wKDAsIHJhdGlvMiAtIHBhblN0YXJ0LCAxIC0gc3Bhbik7XG4gICAgICBtYXggPSBtaW4gKyBzcGFuO1xuICAgIH1cbiAgICB0aGlzLl9taW4gPSBtaW47XG4gICAgdGhpcy5fbWF4ID0gbWF4O1xuICAgIHRoaXMudXBkYXRlWm9vbSgpO1xuICB9XG4gIG9uRHJhZ0VuZChldmVudCkge1xuICAgIHRoaXMuZHJhZ2dpbmcgPSB2b2lkIDA7XG4gICAgdGhpcy51cGRhdGVDdXJzb3IoZXZlbnQpO1xuICB9XG4gIG9uTGVhdmUoX2V2ZW50KSB7XG4gICAgdGhpcy5jdHguY3Vyc29yTWFuYWdlci51cGRhdGVDdXJzb3IoXCJuYXZpZ2F0b3JcIik7XG4gIH1cbiAgb25ab29tQ2hhbmdlKGV2ZW50KSB7XG4gICAgY29uc3QgeyB4IH0gPSBldmVudDtcbiAgICBpZiAoIXgpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fbWluID0geC5taW47XG4gICAgdGhpcy5fbWF4ID0geC5tYXg7XG4gICAgdGhpcy51cGRhdGVOb2Rlcyh4Lm1pbiwgeC5tYXgpO1xuICAgIHRoaXMuc2V0UGFuU2xpZGVyVmFsdWUoeC5taW4sIHgubWF4KTtcbiAgICB0aGlzLnNldFNsaWRlclJhdGlvKHRoaXMucHJveHlOYXZpZ2F0b3JFbGVtZW50c1swXSwgeC5taW4pO1xuICAgIHRoaXMuc2V0U2xpZGVyUmF0aW8odGhpcy5wcm94eU5hdmlnYXRvckVsZW1lbnRzWzJdLCB4Lm1heCk7XG4gIH1cbiAgb25QYW5TbGlkZXJDaGFuZ2UoX2V2ZW50KSB7XG4gICAgY29uc3QgcmF0aW8yID0gdGhpcy5nZXRTbGlkZXJSYXRpbyh0aGlzLnByb3h5TmF2aWdhdG9yRWxlbWVudHNbMV0pO1xuICAgIGNvbnN0IHNwYW4gPSB0aGlzLl9tYXggLSB0aGlzLl9taW47XG4gICAgdGhpcy5fbWluID0gY2xhbXAoMCwgcmF0aW8yLCAxIC0gc3Bhbik7XG4gICAgdGhpcy5fbWF4ID0gdGhpcy5fbWluICsgc3BhbjtcbiAgICB0aGlzLnVwZGF0ZVpvb20oKTtcbiAgfVxuICBvbk1pblNsaWRlckNoYW5nZShfZXZlbnQpIHtcbiAgICBjb25zdCBzbGlkZXIgPSB0aGlzLnByb3h5TmF2aWdhdG9yRWxlbWVudHNbMF07XG4gICAgdGhpcy5fbWluID0gdGhpcy5zZXRTbGlkZXJSYXRpb0NsYW1wZWQoc2xpZGVyLCAwLCB0aGlzLl9tYXggLSB0aGlzLm1pblJhbmdlKTtcbiAgICB0aGlzLnVwZGF0ZVpvb20oKTtcbiAgfVxuICBvbk1heFNsaWRlckNoYW5nZShfZXZlbnQpIHtcbiAgICBjb25zdCBzbGlkZXIgPSB0aGlzLnByb3h5TmF2aWdhdG9yRWxlbWVudHNbMl07XG4gICAgdGhpcy5fbWF4ID0gdGhpcy5zZXRTbGlkZXJSYXRpb0NsYW1wZWQoc2xpZGVyLCB0aGlzLl9taW4gKyB0aGlzLm1pblJhbmdlLCAxKTtcbiAgICB0aGlzLnVwZGF0ZVpvb20oKTtcbiAgfVxuICBzZXRQYW5TbGlkZXJWYWx1ZShtaW4sIG1heCkge1xuICAgIHRoaXMucHJveHlOYXZpZ2F0b3JFbGVtZW50c1sxXS52YWx1ZSA9IGAke01hdGgucm91bmQobWluICogMTAwKX1gO1xuICAgIHRoaXMucHJveHlOYXZpZ2F0b3JFbGVtZW50c1sxXS5hcmlhVmFsdWVUZXh0ID0gdGhpcy5jdHgubG9jYWxlTWFuYWdlci50KFwiYXJpYVZhbHVlUGFuUmFuZ2VcIiwgeyBtaW4sIG1heCB9KTtcbiAgfVxuICBzZXRTbGlkZXJSYXRpb0NsYW1wZWQoc2xpZGVyLCBjbGFtcE1pbiwgY2xhbXBNYXgpIHtcbiAgICBjb25zdCByYXRpbzIgPSB0aGlzLmdldFNsaWRlclJhdGlvKHNsaWRlcik7XG4gICAgY29uc3QgY2xhbXBlZFJhdGlvID0gY2xhbXAoY2xhbXBNaW4sIHJhdGlvMiwgY2xhbXBNYXgpO1xuICAgIGlmIChjbGFtcGVkUmF0aW8gIT09IHJhdGlvMikge1xuICAgICAgdGhpcy5zZXRTbGlkZXJSYXRpbyhzbGlkZXIsIGNsYW1wZWRSYXRpbyk7XG4gICAgfVxuICAgIHJldHVybiBjbGFtcGVkUmF0aW87XG4gIH1cbiAgc2V0U2xpZGVyUmF0aW8oc2xpZGVyLCByYXRpbzIpIHtcbiAgICBjb25zdCB2YWx1ZSA9IE1hdGgucm91bmQocmF0aW8yICogMTAwKTtcbiAgICBzbGlkZXIudmFsdWUgPSBgJHt2YWx1ZX1gO1xuICAgIHNsaWRlci5hcmlhVmFsdWVUZXh0ID0gZm9ybWF0UGVyY2VudGFnZSh2YWx1ZSk7XG4gIH1cbiAgZ2V0U2xpZGVyUmF0aW8oc2xpZGVyKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQoc2xpZGVyLnZhbHVlKSAvIDEwMDtcbiAgfVxuICBsYXlvdXROb2Rlcyh4LCB5LCB3aWR0aDIsIGhlaWdodDIpIHtcbiAgICBjb25zdCB7IHJhbmdlU2VsZWN0b3IsIG1hc2ssIG1pbkhhbmRsZSwgbWF4SGFuZGxlLCBfbWluOiBtaW4sIF9tYXg6IG1heCB9ID0gdGhpcztcbiAgICByYW5nZVNlbGVjdG9yLmxheW91dCh4LCB5LCB3aWR0aDIsIGhlaWdodDIsIG1pbkhhbmRsZS53aWR0aCAvIDIsIG1heEhhbmRsZS53aWR0aCAvIDIpO1xuICAgIG1hc2subGF5b3V0KHgsIHksIHdpZHRoMiwgaGVpZ2h0Mik7XG4gICAgUmFuZ2VIYW5kbGUuYWxpZ24obWluSGFuZGxlLCBtYXhIYW5kbGUsIHgsIHksIHdpZHRoMiwgaGVpZ2h0MiwgbWluLCBtYXgpO1xuICAgIGlmIChtaW4gKyAobWF4IC0gbWluKSAvIDIgPCAwLjUpIHtcbiAgICAgIG1pbkhhbmRsZS56SW5kZXggPSAzO1xuICAgICAgbWF4SGFuZGxlLnpJbmRleCA9IDQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1pbkhhbmRsZS56SW5kZXggPSA0O1xuICAgICAgbWF4SGFuZGxlLnpJbmRleCA9IDM7XG4gICAgfVxuICAgIFttaW5IYW5kbGUsIHRoaXMubWFza1Zpc2libGVSYW5nZSwgbWF4SGFuZGxlXS5mb3JFYWNoKChub2RlLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgYmJveCA9IG5vZGUuZ2V0QkJveCgpO1xuICAgICAgY29uc3QgdGJveCA9IHsgeDogYmJveC54IC0geCwgeTogYmJveC55IC0geSwgaGVpZ2h0OiBiYm94LmhlaWdodCwgd2lkdGg6IGJib3gud2lkdGggfTtcbiAgICAgIHNldEVsZW1lbnRCQm94KHRoaXMucHJveHlOYXZpZ2F0b3JFbGVtZW50c1tpbmRleF0sIHRib3gpO1xuICAgIH0pO1xuICB9XG4gIHVwZGF0ZU5vZGVzKG1pbiwgbWF4KSB7XG4gICAgdGhpcy5tYXNrLnVwZGF0ZShtaW4sIG1heCk7XG4gIH1cbiAgdXBkYXRlWm9vbSgpIHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlZClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IF9taW46IG1pbiwgX21heDogbWF4IH0gPSB0aGlzO1xuICAgIGlmIChtaW4gPT0gbnVsbCB8fCBtYXggPT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB3YXJuT25Db25mbGljdCA9IChzdGF0ZUlkKSA9PiB7XG4gICAgICBpZiAodGhpcy5taW4gPT0gbnVsbCAmJiB0aGlzLm1heCA9PSBudWxsKVxuICAgICAgICByZXR1cm47XG4gICAgICBMb2dnZXIud2Fybk9uY2UoXG4gICAgICAgIGBDb3VsZCBub3QgYXBwbHkgW25hdmlnYXRvci5taW5dIG9yIFtuYXZpZ2F0b3IubWF4XSBhcyBbJHtzdGF0ZUlkfV0gaGFzIG1vZGlmaWVkIHRoZSBpbml0aWFsIHpvb20gc3RhdGUuYFxuICAgICAgKTtcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLmN0eC56b29tTWFuYWdlci51cGRhdGVab29tKFwibmF2aWdhdG9yXCIsIHsgeDogeyBtaW4sIG1heCB9IH0sIGZhbHNlLCB3YXJuT25Db25mbGljdCk7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIE5hdmlnYXRvci5wcm90b3R5cGUsIFwibWluaUNoYXJ0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTiksXG4gIE9ic2VydmVDaGFuZ2VzKCh0YXJnZXQpID0+IHRhcmdldC51cGRhdGVHcm91cFZpc2liaWxpdHkoKSlcbl0sIE5hdmlnYXRvci5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIE5hdmlnYXRvci5wcm90b3R5cGUsIFwiaGVpZ2h0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgTmF2aWdhdG9yLnByb3RvdHlwZSwgXCJzcGFjaW5nXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgQWN0aW9uT25TZXQoe1xuICAgIG5ld1ZhbHVlKG1pbikge1xuICAgICAgdGhpcy5fbWluID0gbWluO1xuICAgICAgdGhpcy51cGRhdGVab29tKCk7XG4gICAgfVxuICB9KSxcbiAgVmFsaWRhdGUoQU5EKFJBVElPLCBMRVNTX1RIQU4oXCJtYXhcIikpLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBOYXZpZ2F0b3IucHJvdG90eXBlLCBcIm1pblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEFjdGlvbk9uU2V0KHtcbiAgICBuZXdWYWx1ZShtYXgpIHtcbiAgICAgIHRoaXMuX21heCA9IG1heDtcbiAgICAgIHRoaXMudXBkYXRlWm9vbSgpO1xuICAgIH1cbiAgfSksXG4gIFZhbGlkYXRlKEFORChSQVRJTywgR1JFQVRFUl9USEFOKFwibWluXCIpKSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTmF2aWdhdG9yLnByb3RvdHlwZSwgXCJtYXhcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L25hdmlnYXRvci9uYXZpZ2F0b3JNb2R1bGUudHNcbnZhciBOYXZpZ2F0b3JNb2R1bGUgPSB7XG4gIHR5cGU6IFwicm9vdFwiLFxuICBvcHRpb25zS2V5OiBcIm5hdmlnYXRvclwiLFxuICBwYWNrYWdlVHlwZTogXCJjb21tdW5pdHlcIixcbiAgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCJdLFxuICBtb2R1bGVGYWN0b3J5OiAoY3R4KSA9PiBuZXcgTmF2aWdhdG9yKGN0eCksXG4gIHRoZW1lVGVtcGxhdGU6IHtcbiAgICBuYXZpZ2F0b3I6IHtcbiAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgaGVpZ2h0OiAzMCxcbiAgICAgIG1hc2s6IHtcbiAgICAgICAgZmlsbDogXCIjOTk5OTk5XCIsXG4gICAgICAgIHN0cm9rZTogXCIjOTk5OTk5XCIsXG4gICAgICAgIHN0cm9rZVdpZHRoOiAxLFxuICAgICAgICBmaWxsT3BhY2l0eTogMC4yXG4gICAgICB9LFxuICAgICAgbWluSGFuZGxlOiB7XG4gICAgICAgIGZpbGw6IFwiI2YyZjJmMlwiLFxuICAgICAgICBzdHJva2U6IFwiIzk5OTk5OVwiLFxuICAgICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgICAgd2lkdGg6IDksXG4gICAgICAgIGhlaWdodDogMTYsXG4gICAgICAgIGdyaXBMaW5lR2FwOiAxLFxuICAgICAgICBncmlwTGluZUxlbmd0aDogOFxuICAgICAgfSxcbiAgICAgIG1heEhhbmRsZToge1xuICAgICAgICBmaWxsOiBcIiNmMmYyZjJcIixcbiAgICAgICAgc3Ryb2tlOiBcIiM5OTk5OTlcIixcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDEsXG4gICAgICAgIHdpZHRoOiA5LFxuICAgICAgICBoZWlnaHQ6IDE2LFxuICAgICAgICBncmlwTGluZUdhcDogMSxcbiAgICAgICAgZ3JpcExpbmVMZW5ndGg6IDhcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL21vZHVsZS90aGVtZS50c1xuZnVuY3Rpb24gc2luZ2xlU2VyaWVzUGFsZXR0ZUZhY3RvcnkoeyB0YWtlQ29sb3JzIH0pIHtcbiAgY29uc3Qge1xuICAgIGZpbGxzOiBbZmlsbF0sXG4gICAgc3Ryb2tlczogW3N0cm9rZV1cbiAgfSA9IHRha2VDb2xvcnMoMSk7XG4gIHJldHVybiB7IGZpbGwsIHN0cm9rZSB9O1xufVxuZnVuY3Rpb24gbWFya2VyUGFsZXR0ZUZhY3RvcnkocGFyYW1zKSB7XG4gIHJldHVybiB7IG1hcmtlcjogc2luZ2xlU2VyaWVzUGFsZXR0ZUZhY3RvcnkocGFyYW1zKSB9O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC90aGVtZXMvY29uc3RhbnRzLnRzXG52YXIgRk9OVF9TSVpFID0gLyogQF9fUFVSRV9fICovICgoRk9OVF9TSVpFMikgPT4ge1xuICBGT05UX1NJWkUyW0ZPTlRfU0laRTJbXCJTTUFMTFwiXSA9IDEyXSA9IFwiU01BTExcIjtcbiAgRk9OVF9TSVpFMltGT05UX1NJWkUyW1wiTUVESVVNXCJdID0gMTNdID0gXCJNRURJVU1cIjtcbiAgRk9OVF9TSVpFMltGT05UX1NJWkUyW1wiTEFSR0VcIl0gPSAxN10gPSBcIkxBUkdFXCI7XG4gIHJldHVybiBGT05UX1NJWkUyO1xufSkoRk9OVF9TSVpFIHx8IHt9KTtcbnZhciBGT05UX1dFSUdIVDIgPSAvKiBAX19QVVJFX18gKi8gKChGT05UX1dFSUdIVDMpID0+IHtcbiAgRk9OVF9XRUlHSFQzW1wiTk9STUFMXCJdID0gXCJub3JtYWxcIjtcbiAgRk9OVF9XRUlHSFQzW1wiQk9MRFwiXSA9IFwiYm9sZFwiO1xuICBGT05UX1dFSUdIVDNbXCJCT0xERVJcIl0gPSBcImJvbGRlclwiO1xuICBGT05UX1dFSUdIVDNbXCJMSUdIVEVSXCJdID0gXCJsaWdodGVyXCI7XG4gIHJldHVybiBGT05UX1dFSUdIVDM7XG59KShGT05UX1dFSUdIVDIgfHwge30pO1xudmFyIENBUlRFU0lBTl9QT1NJVElPTiA9IC8qIEBfX1BVUkVfXyAqLyAoKENBUlRFU0lBTl9QT1NJVElPTjIpID0+IHtcbiAgQ0FSVEVTSUFOX1BPU0lUSU9OMltcIlRPUFwiXSA9IFwidG9wXCI7XG4gIENBUlRFU0lBTl9QT1NJVElPTjJbXCJSSUdIVFwiXSA9IFwicmlnaHRcIjtcbiAgQ0FSVEVTSUFOX1BPU0lUSU9OMltcIkJPVFRPTVwiXSA9IFwiYm90dG9tXCI7XG4gIENBUlRFU0lBTl9QT1NJVElPTjJbXCJMRUZUXCJdID0gXCJsZWZ0XCI7XG4gIHJldHVybiBDQVJURVNJQU5fUE9TSVRJT04yO1xufSkoQ0FSVEVTSUFOX1BPU0lUSU9OIHx8IHt9KTtcbnZhciBDQVJURVNJQU5fQVhJU19UWVBFID0gLyogQF9fUFVSRV9fICovICgoQ0FSVEVTSUFOX0FYSVNfVFlQRTIpID0+IHtcbiAgQ0FSVEVTSUFOX0FYSVNfVFlQRTJbXCJDQVRFR09SWVwiXSA9IFwiY2F0ZWdvcnlcIjtcbiAgQ0FSVEVTSUFOX0FYSVNfVFlQRTJbXCJPUkRJTkFMX1RJTUVcIl0gPSBcIm9yZGluYWwtdGltZVwiO1xuICBDQVJURVNJQU5fQVhJU19UWVBFMltcIk5VTUJFUlwiXSA9IFwibnVtYmVyXCI7XG4gIENBUlRFU0lBTl9BWElTX1RZUEUyW1wiVElNRVwiXSA9IFwidGltZVwiO1xuICBDQVJURVNJQU5fQVhJU19UWVBFMltcIkxPR1wiXSA9IFwibG9nXCI7XG4gIHJldHVybiBDQVJURVNJQU5fQVhJU19UWVBFMjtcbn0pKENBUlRFU0lBTl9BWElTX1RZUEUgfHwge30pO1xudmFyIFBPTEFSX0FYSVNfVFlQRSA9IC8qIEBfX1BVUkVfXyAqLyAoKFBPTEFSX0FYSVNfVFlQRTIpID0+IHtcbiAgUE9MQVJfQVhJU19UWVBFMltcIkFOR0xFX0NBVEVHT1JZXCJdID0gXCJhbmdsZS1jYXRlZ29yeVwiO1xuICBQT0xBUl9BWElTX1RZUEUyW1wiQU5HTEVfTlVNQkVSXCJdID0gXCJhbmdsZS1udW1iZXJcIjtcbiAgUE9MQVJfQVhJU19UWVBFMltcIlJBRElVU19DQVRFR09SWVwiXSA9IFwicmFkaXVzLWNhdGVnb3J5XCI7XG4gIFBPTEFSX0FYSVNfVFlQRTJbXCJSQURJVVNfTlVNQkVSXCJdID0gXCJyYWRpdXMtbnVtYmVyXCI7XG4gIHJldHVybiBQT0xBUl9BWElTX1RZUEUyO1xufSkoUE9MQVJfQVhJU19UWVBFIHx8IHt9KTtcbnZhciBQT0xBUl9BWElTX1NIQVBFID0gLyogQF9fUFVSRV9fICovICgoUE9MQVJfQVhJU19TSEFQRTIpID0+IHtcbiAgUE9MQVJfQVhJU19TSEFQRTJbXCJDSVJDTEVcIl0gPSBcImNpcmNsZVwiO1xuICBQT0xBUl9BWElTX1NIQVBFMltcIlBPTFlHT05cIl0gPSBcInBvbHlnb25cIjtcbiAgcmV0dXJuIFBPTEFSX0FYSVNfU0hBUEUyO1xufSkoUE9MQVJfQVhJU19TSEFQRSB8fCB7fSk7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3RoZW1lcy9zeW1ib2xzLnRzXG52YXIgSVNfREFSS19USEVNRSA9IFN5bWJvbChcImlzLWRhcmstdGhlbWVcIik7XG52YXIgSVNfQ09NTVVOSVRZID0gU3ltYm9sKFwiaXMtY29tbXVuaXR5XCIpO1xudmFyIElTX0VOVEVSUFJJU0UgPSBTeW1ib2woXCJpcy1lbnRlcnByaXNlXCIpO1xudmFyIERFRkFVTFRfRk9OVF9GQU1JTFkgPSBTeW1ib2woXCJkZWZhdWx0LWZvbnRcIik7XG52YXIgREVGQVVMVF9MQUJFTF9DT0xPVVIgPSBTeW1ib2woXCJkZWZhdWx0LWxhYmVsLWNvbG91clwiKTtcbnZhciBERUZBVUxUX0lOVkVSVEVEX0xBQkVMX0NPTE9VUiA9IFN5bWJvbChcImRlZmF1bHQtaW52ZXJ0ZWQtbGFiZWwtY29sb3VyXCIpO1xudmFyIERFRkFVTFRfSU5TSURFX1NFUklFU19MQUJFTF9DT0xPVVIgPSBTeW1ib2woXCJkZWZhdWx0LWluc2lkZS1zZXJpZXMtbGFiZWwtY29sb3VyXCIpO1xudmFyIERFRkFVTFRfTVVURURfTEFCRUxfQ09MT1VSID0gU3ltYm9sKFwiZGVmYXVsdC1tdXRlZC1sYWJlbC1jb2xvdXJcIik7XG52YXIgREVGQVVMVF9BWElTX0dSSURfQ09MT1VSID0gU3ltYm9sKFwiZGVmYXVsdC1heGlzLWdyaWQtY29sb3VyXCIpO1xudmFyIERFRkFVTFRfQVhJU19MSU5FX0NPTE9VUiA9IFN5bWJvbChcImRlZmF1bHQtYXhpcy1saW5lLWNvbG91clwiKTtcbnZhciBERUZBVUxUX0NST1NTX0xJTkVTX0NPTE9VUiA9IFN5bWJvbChcImRlZmF1bHQtY3Jvc3MtbGluZXMtY29sb3VyXCIpO1xudmFyIERFRkFVTFRfQkFDS0dST1VORF9DT0xPVVIgPSBTeW1ib2woXCJkZWZhdWx0LWJhY2tncm91bmQtY29sb3VyXCIpO1xudmFyIERFRkFVTFRfU0hBRE9XX0NPTE9VUiA9IFN5bWJvbChcImRlZmF1bHQtc2hhZG93LWNvbG91clwiKTtcbnZhciBERUZBVUxUX0NPTE9VUlMgPSBTeW1ib2woXCJkZWZhdWx0LWNvbG91cnNcIik7XG52YXIgREVGQVVMVF9QQURESU5HID0gU3ltYm9sKFwiZGVmYXVsdC1wYWRkaW5nXCIpO1xudmFyIERFRkFVTFRfQ0FQVElPTl9MQVlPVVRfU1RZTEUgPSBTeW1ib2woXCJkZWZhdWx0LWNhcHRpb24tbGF5b3V0LXN0eWxlXCIpO1xudmFyIERFRkFVTFRfQ0FQVElPTl9BTElHTk1FTlQgPSBTeW1ib2woXCJkZWZhdWx0LWNhcHRpb24tYWxpZ25tZW50XCIpO1xudmFyIFBBTEVUVEVfVVBfU1RST0tFID0gU3ltYm9sKFwicGFsZXR0ZS11cC1zdHJva2VcIik7XG52YXIgUEFMRVRURV9ET1dOX1NUUk9LRSA9IFN5bWJvbChcInBhbGV0dGUtZG93bi1zdHJva2VcIik7XG52YXIgUEFMRVRURV9VUF9GSUxMID0gU3ltYm9sKFwicGFsZXR0ZS11cC1maWxsXCIpO1xudmFyIFBBTEVUVEVfRE9XTl9GSUxMID0gU3ltYm9sKFwicGFsZXR0ZS1kb3duLWZpbGxcIik7XG52YXIgUEFMRVRURV9ORVVUUkFMX1NUUk9LRSA9IFN5bWJvbChcInBhbGV0dGUtbmV1dHJhbC1zdHJva2VcIik7XG52YXIgUEFMRVRURV9ORVVUUkFMX0ZJTEwgPSBTeW1ib2woXCJwYWxldHRlLW5ldXRyYWwtZmlsbFwiKTtcbnZhciBQQUxFVFRFX0FMVF9VUF9TVFJPS0UgPSBTeW1ib2woXCJwYWxldHRlLWFsdC11cC1zdHJva2VcIik7XG52YXIgUEFMRVRURV9BTFRfRE9XTl9TVFJPS0UgPSBTeW1ib2woXCJwYWxldHRlLWFsdC1kb3duLXN0cm9rZVwiKTtcbnZhciBQQUxFVFRFX0FMVF9VUF9GSUxMID0gU3ltYm9sKFwicGFsZXR0ZS1hbHQtdXAtZmlsbFwiKTtcbnZhciBQQUxFVFRFX0FMVF9ET1dOX0ZJTEwgPSBTeW1ib2woXCJwYWxldHRlLWFsdC1kb3duLWZpbGxcIik7XG52YXIgUEFMRVRURV9BTFRfTkVVVFJBTF9GSUxMID0gU3ltYm9sKFwicGFsZXR0ZS1ncmF5LWZpbGxcIik7XG52YXIgUEFMRVRURV9BTFRfTkVVVFJBTF9TVFJPS0UgPSBTeW1ib2woXCJwYWxldHRlLWdyYXktc3Ryb2tlXCIpO1xudmFyIERFRkFVTFRfUE9MQVJfU0VSSUVTX1NUUk9LRSA9IFN5bWJvbChcImRlZmF1bHQtcG9sYXItc2VyaWVzLXN0cm9rZVwiKTtcbnZhciBERUZBVUxUX0RJVkVSR0lOR19TRVJJRVNfQ09MT1JfUkFOR0UgPSBTeW1ib2woXG4gIFwiZGVmYXVsdC1kaXZlcmdpbmctc2VyaWVzLWNvbG91ci1yYW5nZVwiXG4pO1xudmFyIERFRkFVTFRfR0FVR0VfU0VSSUVTX0NPTE9SX1JBTkdFID0gU3ltYm9sKFwiZGVmYXVsdC1nYXVnZS1zZXJpZXMtY29sb3VyLXJhbmdlXCIpO1xudmFyIERFRkFVTFRfRlVOTkVMX1NFUklFU19DT0xPUl9SQU5HRSA9IFN5bWJvbChcImRlZmF1bHQtZnVubmVsLXNlcmllcy1jb2xvdXItcmFuZ2VcIik7XG52YXIgREVGQVVMVF9ISUVSQVJDSFlfRklMTFMgPSBTeW1ib2woXCJkZWZhdWx0LWhpZXJhcmNoeS1maWxsc1wiKTtcbnZhciBERUZBVUxUX0hJRVJBUkNIWV9TVFJPS0VTID0gU3ltYm9sKFwiZGVmYXVsdC1oaWVyYXJjaHktc3Ryb2tlc1wiKTtcbnZhciBERUZBVUxUX0FOTk9UQVRJT05fQ09MT1IgPSBTeW1ib2woXCJkZWZhdWx0LWFubm90YXRpb24tc3Ryb2tlXCIpO1xudmFyIERFRkFVTFRfVEVYVF9BTk5PVEFUSU9OX0NPTE9SID0gU3ltYm9sKFwiZGVmYXVsdC10ZXh0LWFubm90YXRpb24tY29sb3JcIik7XG52YXIgREVGQVVMVF9BTk5PVEFUSU9OX0JBQ0tHUk9VTkRfRklMTCA9IFN5bWJvbChcImRlZmF1bHQtYW5ub3RhdGlvbi1iYWNrZ3JvdW5kLWZpbGxcIik7XG52YXIgREVGQVVMVF9BTk5PVEFUSU9OX0hBTkRMRV9GSUxMID0gU3ltYm9sKFwiZGVmYXVsdC1hbm5vdGF0aW9uLWhhbmRsZS1maWxsXCIpO1xudmFyIERFRkFVTFRfQU5OT1RBVElPTl9TVEFUSVNUSUNTX0ZJTEwgPSBTeW1ib2woXCJkZWZhdWx0LWFubm90YXRpb24tc3RhdGlzdGljcy1maWxsXCIpO1xudmFyIERFRkFVTFRfQU5OT1RBVElPTl9TVEFUSVNUSUNTX1NUUk9LRSA9IFN5bWJvbChcImRlZmF1bHQtYW5ub3RhdGlvbi1zdGF0aXN0aWNzLXN0cm9rZVwiKTtcbnZhciBERUZBVUxUX0FOTk9UQVRJT05fU1RBVElTVElDU19DT0xPUiA9IFN5bWJvbChcImRlZmF1bHQtYW5ub3RhdGlvbi1zdGF0aXN0aWNzLWNvbG9yXCIpO1xudmFyIERFRkFVTFRfQU5OT1RBVElPTl9TVEFUSVNUSUNTX0RJVklERVJfU1RST0tFID0gU3ltYm9sKFxuICBcImRlZmF1bHQtYW5ub3RhdGlvbi1zdGF0aXN0aWNzLWRpdmlkZXItc3Ryb2tlXCJcbik7XG52YXIgREVGQVVMVF9BTk5PVEFUSU9OX1NUQVRJU1RJQ1NfRE9XTl9GSUxMID0gU3ltYm9sKFxuICBcImRlZmF1bHQtYW5ub3RhdGlvbi1zdGF0aXN0aWNzLWZpbGxcIlxuKTtcbnZhciBERUZBVUxUX0FOTk9UQVRJT05fU1RBVElTVElDU19ET1dOX1NUUk9LRSA9IFN5bWJvbChcbiAgXCJkZWZhdWx0LWFubm90YXRpb24tc3RhdGlzdGljcy1zdHJva2VcIlxuKTtcbnZhciBERUZBVUxUX1RFWFRCT1hfRklMTCA9IFN5bWJvbChcImRlZmF1bHQtdGV4dGJveC1maWxsXCIpO1xudmFyIERFRkFVTFRfVEVYVEJPWF9TVFJPS0UgPSBTeW1ib2woXCJkZWZhdWx0LXRleHRib3gtc3Ryb2tlXCIpO1xudmFyIERFRkFVTFRfVEVYVEJPWF9DT0xPUiA9IFN5bWJvbChcImRlZmF1bHQtdGV4dGJveC1jb2xvclwiKTtcbnZhciBERUZBVUxUX1RPT0xCQVJfUE9TSVRJT04gPSBTeW1ib2woXCJkZWZhdWx0LXRvb2xiYXItcG9zaXRpb25cIik7XG52YXIgREVGQVVMVF9HUklETElORV9FTkFCTEVEID0gU3ltYm9sKFwiZGVmYXVsdC1ncmlkbGluZS1lbmFibGVkXCIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9tb3Rpb24vcGF0aE1vdGlvbi50c1xuZnVuY3Rpb24gcGF0aE1vdGlvbihncm91cElkLCBzdWJJZCwgYW5pbWF0aW9uTWFuYWdlciwgcGF0aHMsIGZucykge1xuICBjb25zdCB7IGFkZFBoYXNlRm4sIHVwZGF0ZVBoYXNlRm4sIHJlbW92ZVBoYXNlRm4gfSA9IGZucztcbiAgY29uc3QgYW5pbWF0ZSA9IChwaGFzZSwgcGF0aCwgdXBkYXRlRm4pID0+IHtcbiAgICBhbmltYXRpb25NYW5hZ2VyLmFuaW1hdGUoe1xuICAgICAgaWQ6IGAke2dyb3VwSWR9XyR7c3ViSWR9XyR7cGF0aC5pZH1fJHtwaGFzZX1gLFxuICAgICAgZ3JvdXBJZCxcbiAgICAgIGZyb206IDAsXG4gICAgICB0bzogMSxcbiAgICAgIGVhc2U6IGVhc2VPdXQsXG4gICAgICBjb2xsYXBzYWJsZTogZmFsc2UsXG4gICAgICBvblVwZGF0ZShyYXRpbzIsIHByZUluaXQpIHtcbiAgICAgICAgaWYgKHByZUluaXQgJiYgcGhhc2UgIT09IFwicmVtb3ZlZFwiKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcGF0aC5wYXRoLmNsZWFyKHRydWUpO1xuICAgICAgICB1cGRhdGVGbihyYXRpbzIsIHBhdGgpO1xuICAgICAgICBwYXRoLmNoZWNrUGF0aERpcnR5KCk7XG4gICAgICB9LFxuICAgICAgb25TdG9wKCkge1xuICAgICAgICBpZiAocGhhc2UgIT09IFwiYWRkZWRcIilcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHBhdGgucGF0aC5jbGVhcih0cnVlKTtcbiAgICAgICAgdXBkYXRlRm4oMSwgcGF0aCk7XG4gICAgICAgIHBhdGguY2hlY2tQYXRoRGlydHkoKTtcbiAgICAgIH0sXG4gICAgICBwaGFzZTogTk9ERV9VUERBVEVfU1RBVEVfVE9fUEhBU0VfTUFQUElOR1twaGFzZV1cbiAgICB9KTtcbiAgfTtcbiAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzKSB7XG4gICAgaWYgKCFhbmltYXRpb25NYW5hZ2VyLmlzU2tpcHBlZCgpKSB7XG4gICAgICBhbmltYXRlKFwicmVtb3ZlZFwiLCBwYXRoLCByZW1vdmVQaGFzZUZuKTtcbiAgICAgIGFuaW1hdGUoXCJ1cGRhdGVkXCIsIHBhdGgsIHVwZGF0ZVBoYXNlRm4pO1xuICAgIH1cbiAgICBhbmltYXRlKFwiYWRkZWRcIiwgcGF0aCwgYWRkUGhhc2VGbik7XG4gIH1cbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9mb3JtYXQudXRpbC50c1xuZnVuY3Rpb24gZm9ybWF0VmFsdWUodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiB2YWx1ZS50b0ZpeGVkKDIpO1xuICB9XG4gIHJldHVybiBTdHJpbmcodmFsdWUgPz8gXCJcIik7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvc2FuaXRpemUudHNcbnZhciBlbGVtZW50ID0gbnVsbDtcbmZ1bmN0aW9uIHNhbml0aXplSHRtbCh0ZXh0KSB7XG4gIGlmICh0ZXh0ID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAodGV4dCA9PT0gXCJcIikge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIGVsZW1lbnQgPz8gKGVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcbiAgZWxlbWVudC50ZXh0Q29udGVudCA9IFN0cmluZyh0ZXh0KTtcbiAgcmV0dXJuIGVsZW1lbnQuaW5uZXJIVE1MO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL21lbW8udHNcbnZhciBtZW1vcml6ZWRGbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIG1lbW8ocGFyYW1zLCBmbkdlbmVyYXRvcikge1xuICBjb25zdCBzZXJpYWxpc2VkUGFyYW1zID0gSlNPTi5zdHJpbmdpZnkocGFyYW1zLCBudWxsLCAwKTtcbiAgaWYgKCFtZW1vcml6ZWRGbnMuaGFzKGZuR2VuZXJhdG9yKSkge1xuICAgIG1lbW9yaXplZEZucy5zZXQoZm5HZW5lcmF0b3IsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICB9XG4gIGlmICghbWVtb3JpemVkRm5zLmdldChmbkdlbmVyYXRvcik/LmhhcyhzZXJpYWxpc2VkUGFyYW1zKSkge1xuICAgIG1lbW9yaXplZEZucy5nZXQoZm5HZW5lcmF0b3IpPy5zZXQoc2VyaWFsaXNlZFBhcmFtcywgZm5HZW5lcmF0b3IocGFyYW1zKSk7XG4gIH1cbiAgcmV0dXJuIG1lbW9yaXplZEZucy5nZXQoZm5HZW5lcmF0b3IpPy5nZXQoc2VyaWFsaXNlZFBhcmFtcyk7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2RhdGEvYWdncmVnYXRlRnVuY3Rpb25zLnRzXG5mdW5jdGlvbiBzdW1WYWx1ZXModmFsdWVzLCBhY2N1bXVsYXRvciA9IFswLCAwXSkge1xuICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPCAwKSB7XG4gICAgICBhY2N1bXVsYXRvclswXSArPSB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID4gMCkge1xuICAgICAgYWNjdW11bGF0b3JbMV0gKz0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBhY2N1bXVsYXRvcjtcbn1cbmZ1bmN0aW9uIHN1bShpZCwgbWF0Y2hHcm91cElkKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBpZCxcbiAgICBtYXRjaEdyb3VwSWRzOiBbbWF0Y2hHcm91cElkXSxcbiAgICB0eXBlOiBcImFnZ3JlZ2F0ZVwiLFxuICAgIGFnZ3JlZ2F0ZUZ1bmN0aW9uOiAodmFsdWVzKSA9PiBzdW1WYWx1ZXModmFsdWVzKVxuICB9O1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ3JvdXBTdW0oaWQsIG1hdGNoR3JvdXBJZCkge1xuICByZXR1cm4ge1xuICAgIGlkLFxuICAgIHR5cGU6IFwiYWdncmVnYXRlXCIsXG4gICAgbWF0Y2hHcm91cElkczogbWF0Y2hHcm91cElkID8gW21hdGNoR3JvdXBJZF0gOiB2b2lkIDAsXG4gICAgYWdncmVnYXRlRnVuY3Rpb246ICh2YWx1ZXMpID0+IHN1bVZhbHVlcyh2YWx1ZXMpLFxuICAgIGdyb3VwQWdncmVnYXRlRnVuY3Rpb246IChuZXh0LCBhY2MgPSBbMCwgMF0pID0+IHtcbiAgICAgIGFjY1swXSArPSBuZXh0Py5bMF0gPz8gMDtcbiAgICAgIGFjY1sxXSArPSBuZXh0Py5bMV0gPz8gMDtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gcmFuZ2UyKGlkLCBtYXRjaEdyb3VwSWQpIHtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIGlkLFxuICAgIG1hdGNoR3JvdXBJZHM6IFttYXRjaEdyb3VwSWRdLFxuICAgIHR5cGU6IFwiYWdncmVnYXRlXCIsXG4gICAgYWdncmVnYXRlRnVuY3Rpb246ICh2YWx1ZXMpID0+IENvbnRpbnVvdXNEb21haW4uZXh0ZW5kRG9tYWluKHZhbHVlcylcbiAgfTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdyb3VwQ291bnQoaWQpIHtcbiAgcmV0dXJuIHtcbiAgICBpZCxcbiAgICB0eXBlOiBcImFnZ3JlZ2F0ZVwiLFxuICAgIGFnZ3JlZ2F0ZUZ1bmN0aW9uOiAoKSA9PiBbMCwgMV0sXG4gICAgZ3JvdXBBZ2dyZWdhdGVGdW5jdGlvbjogKG5leHQsIGFjYyA9IFswLCAwXSkgPT4ge1xuICAgICAgYWNjWzBdICs9IG5leHQ/LlswXSA/PyAwO1xuICAgICAgYWNjWzFdICs9IG5leHQ/LlsxXSA/PyAwO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBncm91cEF2ZXJhZ2UoaWQsIG1hdGNoR3JvdXBJZCkge1xuICBjb25zdCBkZWYgPSB7XG4gICAgaWQsXG4gICAgbWF0Y2hHcm91cElkczogbWF0Y2hHcm91cElkID8gW21hdGNoR3JvdXBJZF0gOiB2b2lkIDAsXG4gICAgdHlwZTogXCJhZ2dyZWdhdGVcIixcbiAgICBhZ2dyZWdhdGVGdW5jdGlvbjogKHZhbHVlcykgPT4gc3VtVmFsdWVzKHZhbHVlcyksXG4gICAgZ3JvdXBBZ2dyZWdhdGVGdW5jdGlvbjogKG5leHQsIGFjYyA9IFswLCAwLCAtMV0pID0+IHtcbiAgICAgIGFjY1swXSArPSBuZXh0Py5bMF0gPz8gMDtcbiAgICAgIGFjY1sxXSArPSBuZXh0Py5bMV0gPz8gMDtcbiAgICAgIGFjY1syXSsrO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LFxuICAgIGZpbmFsRnVuY3Rpb246IChhY2MgPSBbMCwgMCwgMF0pID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGFjY1swXSArIGFjY1sxXTtcbiAgICAgIGlmIChyZXN1bHQgPj0gMCkge1xuICAgICAgICByZXR1cm4gWzAsIHJlc3VsdCAvIGFjY1syXV07XG4gICAgICB9XG4gICAgICByZXR1cm4gW3Jlc3VsdCAvIGFjY1syXSwgMF07XG4gICAgfVxuICB9O1xuICByZXR1cm4gZGVmO1xufVxuZnVuY3Rpb24gYXJlYShpZCwgYWdnRm4sIG1hdGNoR3JvdXBJZCkge1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgaWQsXG4gICAgbWF0Y2hHcm91cElkczogbWF0Y2hHcm91cElkID8gW21hdGNoR3JvdXBJZF0gOiB2b2lkIDAsXG4gICAgdHlwZTogXCJhZ2dyZWdhdGVcIixcbiAgICBhZ2dyZWdhdGVGdW5jdGlvbjogKHZhbHVlcywga2V5UmFuZ2UgPSBbXSkgPT4ge1xuICAgICAgY29uc3Qga2V5V2lkdGggPSBrZXlSYW5nZVsxXSAtIGtleVJhbmdlWzBdO1xuICAgICAgcmV0dXJuIGFnZ0ZuLmFnZ3JlZ2F0ZUZ1bmN0aW9uKHZhbHVlcykubWFwKCh2KSA9PiB2IC8ga2V5V2lkdGgpO1xuICAgIH1cbiAgfTtcbiAgaWYgKGFnZ0ZuLmdyb3VwQWdncmVnYXRlRnVuY3Rpb24pIHtcbiAgICByZXN1bHQuZ3JvdXBBZ2dyZWdhdGVGdW5jdGlvbiA9IGFnZ0ZuLmdyb3VwQWdncmVnYXRlRnVuY3Rpb247XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGFjY3VtdWxhdGVkVmFsdWUob25seVBvc2l0aXZlKSB7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgbGV0IHZhbHVlID0gMDtcbiAgICByZXR1cm4gKGRhdHVtKSA9PiB7XG4gICAgICBpZiAoIWlzRmluaXRlTnVtYmVyKGRhdHVtKSkge1xuICAgICAgICByZXR1cm4gZGF0dW07XG4gICAgICB9XG4gICAgICB2YWx1ZSArPSBvbmx5UG9zaXRpdmUgPyBNYXRoLm1heCgwLCBkYXR1bSkgOiBkYXR1bTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICB9O1xufVxuZnVuY3Rpb24gdHJhaWxpbmdBY2N1bXVsYXRlZFZhbHVlKCkge1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGxldCB2YWx1ZSA9IDA7XG4gICAgcmV0dXJuIChkYXR1bSkgPT4ge1xuICAgICAgaWYgKCFpc0Zpbml0ZU51bWJlcihkYXR1bSkpIHtcbiAgICAgICAgcmV0dXJuIGRhdHVtO1xuICAgICAgfVxuICAgICAgY29uc3QgdHJhaWxpbmdWYWx1ZSA9IHZhbHVlO1xuICAgICAgdmFsdWUgKz0gZGF0dW07XG4gICAgICByZXR1cm4gdHJhaWxpbmdWYWx1ZTtcbiAgICB9O1xuICB9O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9kYXRhL3Byb2Nlc3NvcnMudHNcbmZ1bmN0aW9uIGJhc2ljQ29udGludW91c0NoZWNrRGF0dW1WYWxpZGF0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzQ29udGludW91cyh2YWx1ZSk7XG59XG5mdW5jdGlvbiBiYXNpY0Rpc2NyZXRlQ2hlY2tEYXR1bVZhbGlkYXRpb24odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGw7XG59XG5mdW5jdGlvbiBnZXRWYWxpZGF0aW9uRm4oc2NhbGVUeXBlKSB7XG4gIHN3aXRjaCAoc2NhbGVUeXBlKSB7XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgIGNhc2UgXCJsb2dcIjpcbiAgICBjYXNlIFwib3JkaW5hbC10aW1lXCI6XG4gICAgY2FzZSBcInRpbWVcIjpcbiAgICBjYXNlIFwiY29sb3JcIjpcbiAgICAgIHJldHVybiBiYXNpY0NvbnRpbnVvdXNDaGVja0RhdHVtVmFsaWRhdGlvbjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGJhc2ljRGlzY3JldGVDaGVja0RhdHVtVmFsaWRhdGlvbjtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0VmFsdWVUeXBlKHNjYWxlVHlwZSkge1xuICBzd2l0Y2ggKHNjYWxlVHlwZSkge1xuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICBjYXNlIFwibG9nXCI6XG4gICAgY2FzZSBcInRpbWVcIjpcbiAgICBjYXNlIFwiY29sb3JcIjpcbiAgICAgIHJldHVybiBcInJhbmdlXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBcImNhdGVnb3J5XCI7XG4gIH1cbn1cbmZ1bmN0aW9uIGtleVByb3BlcnR5KHByb3BOYW1lLCBzY2FsZVR5cGUsIG9wdHMgPSB7fSkge1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgcHJvcGVydHk6IHByb3BOYW1lLFxuICAgIHR5cGU6IFwia2V5XCIsXG4gICAgdmFsdWVUeXBlOiBnZXRWYWx1ZVR5cGUoc2NhbGVUeXBlKSxcbiAgICB2YWxpZGF0aW9uOiBnZXRWYWxpZGF0aW9uRm4oc2NhbGVUeXBlKSxcbiAgICAuLi5vcHRzXG4gIH07XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB2YWx1ZVByb3BlcnR5KHByb3BOYW1lLCBzY2FsZVR5cGUsIG9wdHMgPSB7fSkge1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgcHJvcGVydHk6IHByb3BOYW1lLFxuICAgIHR5cGU6IFwidmFsdWVcIixcbiAgICB2YWx1ZVR5cGU6IGdldFZhbHVlVHlwZShzY2FsZVR5cGUpLFxuICAgIHZhbGlkYXRpb246IGdldFZhbGlkYXRpb25GbihzY2FsZVR5cGUpLFxuICAgIC4uLm9wdHNcbiAgfTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHJhbmdlZFZhbHVlUHJvcGVydHkocHJvcE5hbWUsIG9wdHMgPSB7fSkge1xuICBjb25zdCB7IG1pbiA9IC1JbmZpbml0eSwgbWF4ID0gSW5maW5pdHksIC4uLmRlZk9wdHMgfSA9IG9wdHM7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJ2YWx1ZVwiLFxuICAgIHByb3BlcnR5OiBwcm9wTmFtZSxcbiAgICB2YWx1ZVR5cGU6IFwicmFuZ2VcIixcbiAgICB2YWxpZGF0aW9uOiBiYXNpY0NvbnRpbnVvdXNDaGVja0RhdHVtVmFsaWRhdGlvbixcbiAgICBwcm9jZXNzb3I6ICgpID0+IChkYXR1bSkgPT4gaXNGaW5pdGVOdW1iZXIoZGF0dW0pID8gY2xhbXAobWluLCBkYXR1bSwgbWF4KSA6IGRhdHVtLFxuICAgIC4uLmRlZk9wdHNcbiAgfTtcbn1cbmZ1bmN0aW9uIGFjY3VtdWxhdGl2ZVZhbHVlUHJvcGVydHkocHJvcE5hbWUsIHNjYWxlVHlwZSwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IHsgb25seVBvc2l0aXZlLCAuLi5kZWZPcHRzIH0gPSBvcHRzO1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgLi4udmFsdWVQcm9wZXJ0eShwcm9wTmFtZSwgc2NhbGVUeXBlLCBkZWZPcHRzKSxcbiAgICBwcm9jZXNzb3I6IGFjY3VtdWxhdGVkVmFsdWUob25seVBvc2l0aXZlKVxuICB9O1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdHJhaWxpbmdBY2N1bXVsYXRlZFZhbHVlUHJvcGVydHkocHJvcE5hbWUsIHNjYWxlVHlwZSwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAuLi52YWx1ZVByb3BlcnR5KHByb3BOYW1lLCBzY2FsZVR5cGUsIG9wdHMpLFxuICAgIHByb2Nlc3NvcjogdHJhaWxpbmdBY2N1bXVsYXRlZFZhbHVlKClcbiAgfTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdyb3VwQWNjdW11bGF0aXZlVmFsdWVQcm9wZXJ0eShwcm9wTmFtZSwgbW9kZSwgc3VtMiA9IFwiY3VycmVudFwiLCBvcHRzLCBzY2FsZVR5cGUpIHtcbiAgcmV0dXJuIFtcbiAgICB2YWx1ZVByb3BlcnR5KHByb3BOYW1lLCBzY2FsZVR5cGUsIG9wdHMpLFxuICAgIGFjY3VtdWxhdGVHcm91cChvcHRzLmdyb3VwSWQsIG1vZGUsIHN1bTIsIG9wdHMuc2VwYXJhdGVOZWdhdGl2ZSksXG4gICAgLi4ub3B0cy5yYW5nZUlkICE9IG51bGwgPyBbcmFuZ2UyKG9wdHMucmFuZ2VJZCwgb3B0cy5ncm91cElkKV0gOiBbXVxuICBdO1xufVxuZnVuY3Rpb24gZ3JvdXBTdGFja1ZhbHVlUHJvcGVydHkocHJvcE5hbWUsIHNjYWxlVHlwZSwgb3B0cykge1xuICByZXR1cm4gW3ZhbHVlUHJvcGVydHkocHJvcE5hbWUsIHNjYWxlVHlwZSwgb3B0cyksIGFjY3VtdWxhdGVTdGFjayhvcHRzLmdyb3VwSWQpXTtcbn1cbnZhciBTTUFMTEVTVF9LRVlfSU5URVJWQUwgPSB7XG4gIHR5cGU6IFwicmVkdWNlclwiLFxuICBwcm9wZXJ0eTogXCJzbWFsbGVzdEtleUludGVydmFsXCIsXG4gIGluaXRpYWxWYWx1ZTogSW5maW5pdHksXG4gIHJlZHVjZXI6ICgpID0+IHtcbiAgICBsZXQgcHJldlggPSBOYU47XG4gICAgcmV0dXJuIChzbWFsbGVzdFNvRmFyID0gSW5maW5pdHksIG5leHQpID0+IHtcbiAgICAgIGNvbnN0IG5leHRYID0gbmV4dC5rZXlzWzBdO1xuICAgICAgY29uc3QgaW50ZXJ2YWwgPSBNYXRoLmFicyhuZXh0WCAtIHByZXZYKTtcbiAgICAgIHByZXZYID0gbmV4dFg7XG4gICAgICBpZiAoIWlzTmFOKGludGVydmFsKSAmJiBpbnRlcnZhbCA+IDAgJiYgaW50ZXJ2YWwgPCBzbWFsbGVzdFNvRmFyKSB7XG4gICAgICAgIHJldHVybiBpbnRlcnZhbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzbWFsbGVzdFNvRmFyO1xuICAgIH07XG4gIH1cbn07XG52YXIgTEFSR0VTVF9LRVlfSU5URVJWQUwgPSB7XG4gIHR5cGU6IFwicmVkdWNlclwiLFxuICBwcm9wZXJ0eTogXCJsYXJnZXN0S2V5SW50ZXJ2YWxcIixcbiAgaW5pdGlhbFZhbHVlOiAtSW5maW5pdHksXG4gIHJlZHVjZXI6ICgpID0+IHtcbiAgICBsZXQgcHJldlggPSBOYU47XG4gICAgcmV0dXJuIChsYXJnZXN0U29GYXIgPSAtSW5maW5pdHksIG5leHQpID0+IHtcbiAgICAgIGNvbnN0IG5leHRYID0gbmV4dC5rZXlzWzBdO1xuICAgICAgY29uc3QgaW50ZXJ2YWwgPSBNYXRoLmFicyhuZXh0WCAtIHByZXZYKTtcbiAgICAgIHByZXZYID0gbmV4dFg7XG4gICAgICBpZiAoIWlzTmFOKGludGVydmFsKSAmJiBpbnRlcnZhbCA+IDAgJiYgaW50ZXJ2YWwgPiBsYXJnZXN0U29GYXIpIHtcbiAgICAgICAgcmV0dXJuIGludGVydmFsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxhcmdlc3RTb0ZhcjtcbiAgICB9O1xuICB9XG59O1xudmFyIFNPUlRfRE9NQUlOX0dST1VQUyA9IHtcbiAgdHlwZTogXCJwcm9jZXNzb3JcIixcbiAgcHJvcGVydHk6IFwic29ydGVkR3JvdXBEb21haW5cIixcbiAgY2FsY3VsYXRlOiAoeyBkb21haW46IHsgZ3JvdXBzIH0gfSkgPT4gZ3JvdXBzPy5zbGljZSgpLnNvcnQoKGEsIGIpID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGFbaV0gLSBiW2ldO1xuICAgICAgaWYgKHJlc3VsdCAhPT0gMCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfSlcbn07XG5mdW5jdGlvbiBub3JtYWxpc2VGbkJ1aWxkZXIoeyBub3JtYWxpc2VUbywgbW9kZSB9KSB7XG4gIGNvbnN0IG5vcm1hbGlzZSA9ICh2YWwsIGV4dGVudDIpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSB2YWwgKiBub3JtYWxpc2VUbyAvIGV4dGVudDI7XG4gICAgaWYgKHJlc3VsdCA+PSAwKSB7XG4gICAgICByZXR1cm4gTWF0aC5taW4obm9ybWFsaXNlVG8sIHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLm1heCgtbm9ybWFsaXNlVG8sIHJlc3VsdCk7XG4gIH07XG4gIHJldHVybiAoKSA9PiAoKSA9PiAodmFsdWVzLCB2YWx1ZUluZGV4ZXMpID0+IHtcbiAgICBjb25zdCB2YWx1ZXNFeHRlbnQgPSBbMCwgMF07XG4gICAgZm9yIChjb25zdCB2YWx1ZUlkeCBvZiB2YWx1ZUluZGV4ZXMpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW3ZhbHVlSWR4XTtcbiAgICAgIGNvbnN0IHZhbHVlRXh0ZW50ID0gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiID8gdmFsdWUgOiBNYXRoLm1heCguLi52YWx1ZSk7XG4gICAgICBjb25zdCB2YWxJZHggPSB2YWx1ZUV4dGVudCA8IDAgPyAwIDogMTtcbiAgICAgIGlmIChtb2RlID09PSBcInN1bVwiKSB7XG4gICAgICAgIHZhbHVlc0V4dGVudFt2YWxJZHhdICs9IHZhbHVlRXh0ZW50O1xuICAgICAgfSBlbHNlIGlmICh2YWxJZHggPT09IDApIHtcbiAgICAgICAgdmFsdWVzRXh0ZW50W3ZhbElkeF0gPSBNYXRoLm1pbih2YWx1ZXNFeHRlbnRbdmFsSWR4XSwgdmFsdWVFeHRlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVzRXh0ZW50W3ZhbElkeF0gPSBNYXRoLm1heCh2YWx1ZXNFeHRlbnRbdmFsSWR4XSwgdmFsdWVFeHRlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBleHRlbnQyID0gTWF0aC5tYXgoTWF0aC5hYnModmFsdWVzRXh0ZW50WzBdKSwgdmFsdWVzRXh0ZW50WzFdKTtcbiAgICBmb3IgKGNvbnN0IHZhbHVlSWR4IG9mIHZhbHVlSW5kZXhlcykge1xuICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbdmFsdWVJZHhdO1xuICAgICAgdmFsdWVzW3ZhbHVlSWR4XSA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiA/IG5vcm1hbGlzZSh2YWx1ZSwgZXh0ZW50MikgOiB2YWx1ZS5tYXAoKHYpID0+IG5vcm1hbGlzZSh2LCBleHRlbnQyKSk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gbm9ybWFsaXNlR3JvdXBUbyhtYXRjaEdyb3VwSWRzLCBub3JtYWxpc2VUbywgbW9kZSA9IFwic3VtXCIpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImdyb3VwLXZhbHVlLXByb2Nlc3NvclwiLFxuICAgIG1hdGNoR3JvdXBJZHMsXG4gICAgYWRqdXN0OiBtZW1vKHsgbm9ybWFsaXNlVG8sIG1vZGUgfSwgbm9ybWFsaXNlRm5CdWlsZGVyKVxuICB9O1xufVxuZnVuY3Rpb24gbm9ybWFsaXNlUHJvcGVydHlGbkJ1aWxkZXIoe1xuICBub3JtYWxpc2VUbyxcbiAgemVyb0RvbWFpbixcbiAgcmFuZ2VNaW4sXG4gIHJhbmdlTWF4XG59KSB7XG4gIGNvbnN0IG5vcm1hbGlzZVNwYW4gPSBub3JtYWxpc2VUb1sxXSAtIG5vcm1hbGlzZVRvWzBdO1xuICBjb25zdCBub3JtYWxpc2UgPSAodmFsLCBzdGFydDIsIHNwYW4pID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBub3JtYWxpc2VUb1swXSArICh2YWwgLSBzdGFydDIpIC8gc3BhbiAqIG5vcm1hbGlzZVNwYW47XG4gICAgaWYgKHNwYW4gPT09IDApIHtcbiAgICAgIHJldHVybiB6ZXJvRG9tYWluO1xuICAgIH0gZWxzZSBpZiAocmVzdWx0ID49IG5vcm1hbGlzZVRvWzFdKSB7XG4gICAgICByZXR1cm4gbm9ybWFsaXNlVG9bMV07XG4gICAgfSBlbHNlIGlmIChyZXN1bHQgPCBub3JtYWxpc2VUb1swXSkge1xuICAgICAgcmV0dXJuIG5vcm1hbGlzZVRvWzBdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICByZXR1cm4gKCkgPT4gKHBEYXRhLCBwSWR4KSA9PiB7XG4gICAgbGV0IFtzdGFydDIsIGVuZDJdID0gcERhdGEuZG9tYWluLnZhbHVlc1twSWR4XTtcbiAgICBpZiAocmFuZ2VNaW4gIT0gbnVsbClcbiAgICAgIHN0YXJ0MiA9IHJhbmdlTWluO1xuICAgIGlmIChyYW5nZU1heCAhPSBudWxsKVxuICAgICAgZW5kMiA9IHJhbmdlTWF4O1xuICAgIGNvbnN0IHNwYW4gPSBlbmQyIC0gc3RhcnQyO1xuICAgIHBEYXRhLmRvbWFpbi52YWx1ZXNbcElkeF0gPSBbbm9ybWFsaXNlVG9bMF0sIG5vcm1hbGlzZVRvWzFdXTtcbiAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIHBEYXRhLmRhdGEpIHtcbiAgICAgIGxldCBncm91cFZhbHVlcyA9IGdyb3VwLnZhbHVlcztcbiAgICAgIGlmIChwRGF0YS50eXBlID09PSBcInVuZ3JvdXBlZFwiKSB7XG4gICAgICAgIGdyb3VwVmFsdWVzID0gW2dyb3VwVmFsdWVzXTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgdmFsdWVzIG9mIGdyb3VwVmFsdWVzKSB7XG4gICAgICAgIHZhbHVlc1twSWR4XSA9IG5vcm1hbGlzZSh2YWx1ZXNbcElkeF0sIHN0YXJ0Miwgc3Bhbik7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gbm9ybWFsaXNlUHJvcGVydHlUbyhwcm9wZXJ0eSwgbm9ybWFsaXNlVG8sIHplcm9Eb21haW4sIHJhbmdlTWluLCByYW5nZU1heCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwicHJvcGVydHktdmFsdWUtcHJvY2Vzc29yXCIsXG4gICAgcHJvcGVydHksXG4gICAgYWRqdXN0OiBtZW1vKHsgbm9ybWFsaXNlVG8sIHJhbmdlTWluLCByYW5nZU1heCwgemVyb0RvbWFpbiB9LCBub3JtYWxpc2VQcm9wZXJ0eUZuQnVpbGRlcilcbiAgfTtcbn1cbmZ1bmN0aW9uIGFuaW1hdGlvblZhbGlkYXRpb24odmFsdWVLZXlJZHMpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInByb2Nlc3NvclwiLFxuICAgIHByb3BlcnR5OiBcImFuaW1hdGlvblZhbGlkYXRpb25cIixcbiAgICBjYWxjdWxhdGUocmVzdWx0KSB7XG4gICAgICBjb25zdCB7IGtleXMsIHZhbHVlcyB9ID0gcmVzdWx0LmRlZnM7XG4gICAgICBjb25zdCB7IGlucHV0LCBkYXRhIH0gPSByZXN1bHQ7XG4gICAgICBsZXQgdW5pcXVlS2V5cyA9IHRydWU7XG4gICAgICBsZXQgb3JkZXJlZEtleXMgPSB0cnVlO1xuICAgICAgY29uc3QgdmFsdWVLZXlzID0gW107XG4gICAgICBmb3IgKGxldCBrID0gMDsgayA8IHZhbHVlcy5sZW5ndGg7IGsrKykge1xuICAgICAgICBpZiAoIXZhbHVlS2V5SWRzPy5pbmNsdWRlcyh2YWx1ZXNba10uaWQpKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB2YWx1ZUtleXMucHVzaChbaywgdmFsdWVzW2tdXSk7XG4gICAgICB9XG4gICAgICBjb25zdCBwcm9jZXNzS2V5ID0gKGlkeCwgZGVmLCB0eXBlKSA9PiB7XG4gICAgICAgIGlmIChkZWYudmFsdWVUeXBlID09PSBcImNhdGVnb3J5XCIpIHtcbiAgICAgICAgICBjb25zdCBrZXlWYWx1ZXMgPSByZXN1bHQuZG9tYWluW3R5cGVdW2lkeF07XG4gICAgICAgICAgdW5pcXVlS2V5cyAmJiAodW5pcXVlS2V5cyA9IGtleVZhbHVlcy5sZW5ndGggPT09IGlucHV0LmNvdW50KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxhc3RWYWx1ZSA9IGRhdGFbMF0/Llt0eXBlXVtpZHhdO1xuICAgICAgICBmb3IgKGxldCBkID0gMTsgKHVuaXF1ZUtleXMgfHwgb3JkZXJlZEtleXMpICYmIGQgPCBkYXRhLmxlbmd0aDsgZCsrKSB7XG4gICAgICAgICAgY29uc3Qga2V5VmFsdWUgPSBkYXRhW2RdW3R5cGVdW2lkeF07XG4gICAgICAgICAgb3JkZXJlZEtleXMgJiYgKG9yZGVyZWRLZXlzID0gbGFzdFZhbHVlIDw9IGtleVZhbHVlKTtcbiAgICAgICAgICB1bmlxdWVLZXlzICYmICh1bmlxdWVLZXlzID0gbGFzdFZhbHVlICE9PSBrZXlWYWx1ZSk7XG4gICAgICAgICAgbGFzdFZhbHVlID0ga2V5VmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBmb3IgKGxldCBrID0gMDsgKHVuaXF1ZUtleXMgfHwgb3JkZXJlZEtleXMpICYmIGsgPCBrZXlzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHByb2Nlc3NLZXkoaywga2V5c1trXSwgXCJrZXlzXCIpO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgayA9IDA7ICh1bmlxdWVLZXlzIHx8IG9yZGVyZWRLZXlzKSAmJiBrIDwgdmFsdWVLZXlzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIGNvbnN0IFtpZHgsIGtleV0gPSB2YWx1ZUtleXNba107XG4gICAgICAgIHByb2Nlc3NLZXkoaWR4LCBrZXksIFwidmFsdWVzXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgdW5pcXVlS2V5cywgb3JkZXJlZEtleXMgfTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBidWlsZEdyb3VwQWNjRm4oeyBtb2RlLCBzZXBhcmF0ZU5lZ2F0aXZlIH0pIHtcbiAgcmV0dXJuICgpID0+ICgpID0+ICh2YWx1ZXMsIHZhbHVlSW5kZXhlcykgPT4ge1xuICAgIGNvbnN0IGFjYyA9IFswLCAwXTtcbiAgICBmb3IgKGNvbnN0IHZhbHVlSWR4IG9mIHZhbHVlSW5kZXhlcykge1xuICAgICAgY29uc3QgY3VycmVudFZhbCA9IHZhbHVlc1t2YWx1ZUlkeF07XG4gICAgICBjb25zdCBhY2NJbmRleCA9IGlzTmVnYXRpdmUoY3VycmVudFZhbCkgJiYgc2VwYXJhdGVOZWdhdGl2ZSA/IDAgOiAxO1xuICAgICAgaWYgKCFpc0Zpbml0ZU51bWJlcihjdXJyZW50VmFsKSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBpZiAobW9kZSA9PT0gXCJub3JtYWxcIilcbiAgICAgICAgYWNjW2FjY0luZGV4XSArPSBjdXJyZW50VmFsO1xuICAgICAgdmFsdWVzW3ZhbHVlSWR4XSA9IGFjY1thY2NJbmRleF07XG4gICAgICBpZiAobW9kZSA9PT0gXCJ0cmFpbGluZ1wiKVxuICAgICAgICBhY2NbYWNjSW5kZXhdICs9IGN1cnJlbnRWYWw7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gYnVpbGRHcm91cFdpbmRvd0FjY0ZuKHsgbW9kZSwgc3VtOiBzdW0yIH0pIHtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBjb25zdCBsYXN0VmFsdWVzID0gW107XG4gICAgbGV0IGZpcnN0Um93ID0gdHJ1ZTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcmV0dXJuICh2YWx1ZXMsIHZhbHVlSW5kZXhlcykgPT4ge1xuICAgICAgICBsZXQgYWNjID0gMDtcbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZUlkeCBvZiB2YWx1ZUluZGV4ZXMpIHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50VmFsID0gdmFsdWVzW3ZhbHVlSWR4XTtcbiAgICAgICAgICBjb25zdCBsYXN0VmFsdWUgPSBmaXJzdFJvdyAmJiBzdW0yID09PSBcImN1cnJlbnRcIiA/IDAgOiBsYXN0VmFsdWVzW3ZhbHVlSWR4XTtcbiAgICAgICAgICBsYXN0VmFsdWVzW3ZhbHVlSWR4XSA9IGN1cnJlbnRWYWw7XG4gICAgICAgICAgY29uc3Qgc3VtVmFsdWUgPSBzdW0yID09PSBcImN1cnJlbnRcIiA/IGN1cnJlbnRWYWwgOiBsYXN0VmFsdWU7XG4gICAgICAgICAgaWYgKCFpc0Zpbml0ZU51bWJlcihjdXJyZW50VmFsKSB8fCAhaXNGaW5pdGVOdW1iZXIobGFzdFZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlSWR4XSA9IGFjYztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobW9kZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgICAgYWNjICs9IHN1bVZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YWx1ZXNbdmFsdWVJZHhdID0gYWNjO1xuICAgICAgICAgIGlmIChtb2RlID09PSBcInRyYWlsaW5nXCIpIHtcbiAgICAgICAgICAgIGFjYyArPSBzdW1WYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmlyc3RSb3cgPSBmYWxzZTtcbiAgICAgIH07XG4gICAgfTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGFjY3VtdWxhdGVHcm91cChtYXRjaEdyb3VwSWQsIG1vZGUsIHN1bTIsIHNlcGFyYXRlTmVnYXRpdmUgPSBmYWxzZSkge1xuICBsZXQgYWRqdXN0O1xuICBpZiAobW9kZS5zdGFydHNXaXRoKFwid2luZG93XCIpKSB7XG4gICAgY29uc3QgbW9kZVBhcmFtID0gbW9kZS5lbmRzV2l0aChcIi10cmFpbGluZ1wiKSA/IFwidHJhaWxpbmdcIiA6IFwibm9ybWFsXCI7XG4gICAgYWRqdXN0ID0gbWVtbyh7IG1vZGU6IG1vZGVQYXJhbSwgc3VtOiBzdW0yIH0sIGJ1aWxkR3JvdXBXaW5kb3dBY2NGbik7XG4gIH0gZWxzZSB7XG4gICAgYWRqdXN0ID0gbWVtbyh7IG1vZGUsIHNlcGFyYXRlTmVnYXRpdmUgfSwgYnVpbGRHcm91cEFjY0ZuKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiZ3JvdXAtdmFsdWUtcHJvY2Vzc29yXCIsXG4gICAgbWF0Y2hHcm91cElkczogW21hdGNoR3JvdXBJZF0sXG4gICAgYWRqdXN0XG4gIH07XG59XG5mdW5jdGlvbiBncm91cFN0YWNrQWNjRm4oKSB7XG4gIHJldHVybiAoKSA9PiAodmFsdWVzLCB2YWx1ZUluZGV4ZXMpID0+IHtcbiAgICBjb25zdCBhY2MgPSBuZXcgRmxvYXQ2NEFycmF5KDMyKTtcbiAgICBsZXQgc3RhY2tDb3VudCA9IDA7XG4gICAgZm9yIChjb25zdCB2YWx1ZUlkeCBvZiB2YWx1ZUluZGV4ZXMpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHZhbHVlc1t2YWx1ZUlkeF07XG4gICAgICBhY2Nbc3RhY2tDb3VudF0gPSBOdW1iZXIuaXNGaW5pdGUoY3VycmVudFZhbHVlKSA/IGN1cnJlbnRWYWx1ZSA6IE5hTjtcbiAgICAgIHN0YWNrQ291bnQgKz0gMTtcbiAgICAgIHZhbHVlc1t2YWx1ZUlkeF0gPSBhY2Muc3ViYXJyYXkoMCwgc3RhY2tDb3VudCk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gYWNjdW11bGF0ZVN0YWNrKG1hdGNoR3JvdXBJZCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiZ3JvdXAtdmFsdWUtcHJvY2Vzc29yXCIsXG4gICAgbWF0Y2hHcm91cElkczogW21hdGNoR3JvdXBJZF0sXG4gICAgYWRqdXN0OiBncm91cFN0YWNrQWNjRm5cbiAgfTtcbn1cbmZ1bmN0aW9uIGRpZmYocHJldmlvdXNEYXRhLCB1cGRhdGVNb3ZlZERhdGEgPSB0cnVlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJwcm9jZXNzb3JcIixcbiAgICBwcm9wZXJ0eTogXCJkaWZmXCIsXG4gICAgY2FsY3VsYXRlOiAocHJvY2Vzc2VkRGF0YSkgPT4ge1xuICAgICAgY29uc3QgbW92ZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgY29uc3QgYWRkZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgY29uc3QgdXBkYXRlZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBjb25zdCByZW1vdmVkID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIGNvbnN0IGxlbmd0aDIgPSBNYXRoLm1heChwcmV2aW91c0RhdGEuZGF0YS5sZW5ndGgsIHByb2Nlc3NlZERhdGEuZGF0YS5sZW5ndGgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgICAgY29uc3QgcHJldiA9IHByZXZpb3VzRGF0YS5kYXRhW2ldO1xuICAgICAgICBjb25zdCBkYXR1bSA9IHByb2Nlc3NlZERhdGEuZGF0YVtpXTtcbiAgICAgICAgY29uc3QgcHJldklkID0gcHJldiA/IGNyZWF0ZURhdHVtSWQocHJldi5rZXlzKSA6IFwiXCI7XG4gICAgICAgIGNvbnN0IGRhdHVtSWQgPSBkYXR1bSA/IGNyZWF0ZURhdHVtSWQoZGF0dW0ua2V5cykgOiBcIlwiO1xuICAgICAgICBpZiAoZGF0dW0gJiYgcHJldiAmJiBwcmV2SWQgPT09IGRhdHVtSWQpIHtcbiAgICAgICAgICBpZiAoIWFycmF5c0VxdWFsKHByZXYudmFsdWVzLCBkYXR1bS52YWx1ZXMpKSB7XG4gICAgICAgICAgICB1cGRhdGVkLnNldChkYXR1bUlkLCBkYXR1bSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZW1vdmVkLmhhcyhkYXR1bUlkKSkge1xuICAgICAgICAgIGlmICh1cGRhdGVNb3ZlZERhdGEgfHwgIWFycmF5c0VxdWFsKHJlbW92ZWQuZ2V0KGRhdHVtSWQpLnZhbHVlcywgZGF0dW0udmFsdWVzKSkge1xuICAgICAgICAgICAgdXBkYXRlZC5zZXQoZGF0dW1JZCwgZGF0dW0pO1xuICAgICAgICAgICAgbW92ZWQuc2V0KGRhdHVtSWQsIGRhdHVtKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVtb3ZlZC5kZWxldGUoZGF0dW1JZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0dW0pIHtcbiAgICAgICAgICBhZGRlZC5zZXQoZGF0dW1JZCwgZGF0dW0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhZGRlZC5oYXMocHJldklkKSkge1xuICAgICAgICAgIGlmICh1cGRhdGVNb3ZlZERhdGEgfHwgIWFycmF5c0VxdWFsKGFkZGVkLmdldChwcmV2SWQpLnZhbHVlcywgcHJldi52YWx1ZXMpKSB7XG4gICAgICAgICAgICB1cGRhdGVkLnNldChwcmV2SWQsIHByZXYpO1xuICAgICAgICAgICAgbW92ZWQuc2V0KHByZXZJZCwgcHJldik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFkZGVkLmRlbGV0ZShwcmV2SWQpO1xuICAgICAgICB9IGVsc2UgaWYgKHByZXYpIHtcbiAgICAgICAgICB1cGRhdGVkLmRlbGV0ZShwcmV2SWQpO1xuICAgICAgICAgIHJlbW92ZWQuc2V0KHByZXZJZCwgcHJldik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoYW5nZWQgPSBhZGRlZC5zaXplID4gMCB8fCB1cGRhdGVkLnNpemUgPiAwIHx8IHJlbW92ZWQuc2l6ZSA+IDA7XG4gICAgICByZXR1cm4geyBjaGFuZ2VkLCBhZGRlZCwgdXBkYXRlZCwgcmVtb3ZlZCwgbW92ZWQgfTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVEYXR1bUlkKGtleXMsIC4uLmV4dHJhS2V5cykge1xuICBsZXQgcmVzdWx0O1xuICBpZiAoaXNBcnJheShrZXlzKSkge1xuICAgIHJlc3VsdCA9IGtleXMubWFwKChrZXkpID0+IHRyYW5zZm9ybUludGVncmF0ZWRDYXRlZ29yeVZhbHVlKGtleSkpLmpvaW4oXCJfX19cIik7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gdHJhbnNmb3JtSW50ZWdyYXRlZENhdGVnb3J5VmFsdWUoa2V5cyk7XG4gIH1cbiAgY29uc3QgcHJpbWl0aXZlVHlwZSA9IHR5cGVvZiByZXN1bHQgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHJlc3VsdCA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgcmVzdWx0ID09PSBcImJvb2xlYW5cIiB8fCByZXN1bHQgaW5zdGFuY2VvZiBEYXRlO1xuICBpZiAocHJpbWl0aXZlVHlwZSAmJiBleHRyYUtleXMubGVuZ3RoID4gMCkge1xuICAgIHJlc3VsdCArPSBgX19fJHtleHRyYUtleXMuam9pbihcIl9fX1wiKX1gO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9zZXJpZXNMYWJlbFV0aWwudHNcbmZ1bmN0aW9uIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHsgaWQgfSwgc3ViSWQsIGFuaW1hdGlvbk1hbmFnZXIsIC4uLmxhYmVsU2VsZWN0aW9ucykge1xuICBzdGF0aWNGcm9tVG9Nb3Rpb24oXG4gICAgaWQsXG4gICAgc3ViSWQsXG4gICAgYW5pbWF0aW9uTWFuYWdlcixcbiAgICBsYWJlbFNlbGVjdGlvbnMsXG4gICAgeyBvcGFjaXR5OiAwIH0sXG4gICAgeyBvcGFjaXR5OiAxIH0sXG4gICAgeyBwaGFzZTogXCJ0cmFpbGluZ1wiIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIHNlcmllc0xhYmVsRmFkZU91dEFuaW1hdGlvbih7IGlkIH0sIHN1YklkLCBhbmltYXRpb25NYW5hZ2VyLCAuLi5sYWJlbFNlbGVjdGlvbnMpIHtcbiAgc3RhdGljRnJvbVRvTW90aW9uKFxuICAgIGlkLFxuICAgIHN1YklkLFxuICAgIGFuaW1hdGlvbk1hbmFnZXIsXG4gICAgbGFiZWxTZWxlY3Rpb25zLFxuICAgIHsgb3BhY2l0eTogMSB9LFxuICAgIHsgb3BhY2l0eTogMCB9LFxuICAgIHsgcGhhc2U6IFwicmVtb3ZlXCIgfVxuICApO1xufVxuZnVuY3Rpb24gcmVzZXRMYWJlbEZuKF9ub2RlKSB7XG4gIHJldHVybiB7IG9wYWNpdHk6IDEgfTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvdXRpbC9jaGFuZ2VEZXRlY3RhYmxlUHJvcGVydGllcy50c1xudmFyIENoYW5nZURldGVjdGFibGVQcm9wZXJ0aWVzID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5fZGlydHkgPSAzIC8qIE1BSk9SICovO1xuICB9XG4gIG1hcmtEaXJ0eSh0eXBlID0gMSAvKiBUUklWSUFMICovKSB7XG4gICAgaWYgKHRoaXMuX2RpcnR5IDwgdHlwZSkge1xuICAgICAgdGhpcy5fZGlydHkgPSB0eXBlO1xuICAgIH1cbiAgfVxuICBtYXJrQ2xlYW4oX29wdHMpIHtcbiAgICB0aGlzLl9kaXJ0eSA9IDAgLyogTk9ORSAqLztcbiAgfVxuICBpc0RpcnR5KCkge1xuICAgIHJldHVybiB0aGlzLl9kaXJ0eSA+IDAgLyogTk9ORSAqLztcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvZHJvcFNoYWRvdy50c1xudmFyIERyb3BTaGFkb3cgPSBjbGFzcyBleHRlbmRzIENoYW5nZURldGVjdGFibGVQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMuY29sb3IgPSBcInJnYmEoMCwgMCwgMCwgMC41KVwiO1xuICAgIHRoaXMueE9mZnNldCA9IDA7XG4gICAgdGhpcy55T2Zmc2V0ID0gMDtcbiAgICB0aGlzLmJsdXIgPSA1O1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTiksXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBEcm9wU2hhZG93LnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HKSxcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8gfSlcbl0sIERyb3BTaGFkb3cucHJvdG90eXBlLCBcImNvbG9yXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTlVNQkVSKSxcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8gfSlcbl0sIERyb3BTaGFkb3cucHJvdG90eXBlLCBcInhPZmZzZXRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShOVU1CRVIpLFxuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLyB9KVxuXSwgRHJvcFNoYWRvdy5wcm90b3R5cGUsIFwieU9mZnNldFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiksXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBEcm9wU2hhZG93LnByb3RvdHlwZSwgXCJibHVyXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvc2VyaWVzTWFya2VyLnRzXG52YXIgTUFSS0VSX1NIQVBFID0gcHJlZGljYXRlV2l0aE1lc3NhZ2UoXG4gICh2YWx1ZSkgPT4gaXNNYXJrZXJTaGFwZSh2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgJiYgT2JqZWN0LmNyZWF0ZSh2YWx1ZS5wcm90b3R5cGUpIGluc3RhbmNlb2YgTWFya2VyLFxuICBgYSBtYXJrZXIgc2hhcGUga2V5d29yZCBzdWNoIGFzICdjaXJjbGUnLCAnZGlhbW9uZCcgb3IgJ3NxdWFyZScgb3IgYW4gb2JqZWN0IGV4dGVuZGluZyB0aGUgTWFya2VyIGNsYXNzYFxuKTtcbnZhciBTZXJpZXNNYXJrZXIgPSBjbGFzcyBleHRlbmRzIENoYW5nZURldGVjdGFibGVQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMuc2hhcGUgPSBDaXJjbGU7XG4gICAgdGhpcy5zaXplID0gNjtcbiAgICB0aGlzLmZpbGxPcGFjaXR5ID0gMTtcbiAgICB0aGlzLnN0cm9rZVdpZHRoID0gMTtcbiAgICB0aGlzLnN0cm9rZU9wYWNpdHkgPSAxO1xuICB9XG4gIGdldFN0eWxlKCkge1xuICAgIGNvbnN0IHsgc2l6ZSwgc2hhcGUsIGZpbGwsIGZpbGxPcGFjaXR5LCBzdHJva2UsIHN0cm9rZVdpZHRoLCBzdHJva2VPcGFjaXR5IH0gPSB0aGlzO1xuICAgIHJldHVybiB7IHNpemUsIHNoYXBlLCBmaWxsLCBmaWxsT3BhY2l0eSwgc3Ryb2tlLCBzdHJva2VXaWR0aCwgc3Ryb2tlT3BhY2l0eSB9O1xuICB9XG4gIGdldERpYW1ldGVyKCkge1xuICAgIHJldHVybiB0aGlzLnNpemUgKyB0aGlzLnN0cm9rZVdpZHRoO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTiksXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBTZXJpZXNNYXJrZXIucHJvdG90eXBlLCBcImVuYWJsZWRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShNQVJLRVJfU0hBUEUpLFxuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLyB9KVxuXSwgU2VyaWVzTWFya2VyLnByb3RvdHlwZSwgXCJzaGFwZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiksXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBTZXJpZXNNYXJrZXIucHJvdG90eXBlLCBcInNpemVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSksXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBTZXJpZXNNYXJrZXIucHJvdG90eXBlLCBcImZpbGxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTyksXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBTZXJpZXNNYXJrZXIucHJvdG90eXBlLCBcImZpbGxPcGFjaXR5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pLFxuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLyB9KVxuXSwgU2VyaWVzTWFya2VyLnByb3RvdHlwZSwgXCJzdHJva2VcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpLFxuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLyB9KVxuXSwgU2VyaWVzTWFya2VyLnByb3RvdHlwZSwgXCJzdHJva2VXaWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPKSxcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8gfSlcbl0sIFNlcmllc01hcmtlci5wcm90b3R5cGUsIFwic3Ryb2tlT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZVTkNUSU9OLCB7IG9wdGlvbmFsOiB0cnVlIH0pLFxuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLyB9KVxuXSwgU2VyaWVzTWFya2VyLnByb3RvdHlwZSwgXCJpdGVtU3R5bGVyXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvc2VyaWVzVG9vbHRpcC50c1xudmFyIFNlcmllc1Rvb2x0aXBJbnRlcmFjdGlvbiA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIFNlcmllc1Rvb2x0aXBJbnRlcmFjdGlvbi5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCAyKTtcbnZhciBTZXJpZXNUb29sdGlwID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLmludGVyYWN0aW9uID0gbmV3IFNlcmllc1Rvb2x0aXBJbnRlcmFjdGlvbigpO1xuICAgIHRoaXMucG9zaXRpb24gPSBuZXcgVG9vbHRpcFBvc2l0aW9uKCk7XG4gICAgdGhpcy5yYW5nZSA9IHZvaWQgMDtcbiAgfVxuICB0b1Rvb2x0aXBIdG1sKGRlZmF1bHRzLCBwYXJhbXMpIHtcbiAgICBpZiAodGhpcy5yZW5kZXJlcikge1xuICAgICAgcmV0dXJuIHRvVG9vbHRpcEh0bWwodGhpcy5yZW5kZXJlcihwYXJhbXMpLCBkZWZhdWx0cyk7XG4gICAgfVxuICAgIHJldHVybiB0b1Rvb2x0aXBIdG1sKGRlZmF1bHRzKTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBTZXJpZXNUb29sdGlwLnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgU2VyaWVzVG9vbHRpcC5wcm90b3R5cGUsIFwic2hvd0Fycm93XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoRlVOQ1RJT04sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFNlcmllc1Rvb2x0aXAucHJvdG90eXBlLCBcInJlbmRlcmVyXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgU2VyaWVzVG9vbHRpcC5wcm90b3R5cGUsIFwiaW50ZXJhY3Rpb25cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBTZXJpZXNUb29sdGlwLnByb3RvdHlwZSwgXCJwb3NpdGlvblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKElOVEVSQUNUSU9OX1JBTkdFLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBTZXJpZXNUb29sdGlwLnByb3RvdHlwZSwgXCJyYW5nZVwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9pbnRlcnBvbGF0aW9uUHJvcGVydGllcy50c1xudmFyIElOVEVSUE9MQVRJT05fVFlQRSA9IFVOSU9OKFtcImxpbmVhclwiLCBcInNtb290aFwiLCBcInN0ZXBcIl0sIFwiYSBsaW5lIHN0eWxlXCIpO1xudmFyIElOVEVSUE9MQVRJT05fU1RFUF9QT1NJVElPTiA9IFVOSU9OKFtcInN0YXJ0XCIsIFwibWlkZGxlXCIsIFwiZW5kXCJdKTtcbnZhciBJbnRlcnBvbGF0aW9uUHJvcGVydGllcyA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9IFwibGluZWFyXCI7XG4gICAgdGhpcy50ZW5zaW9uID0gMTtcbiAgICB0aGlzLnBvc2l0aW9uID0gXCJlbmRcIjtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKElOVEVSUE9MQVRJT05fVFlQRSlcbl0sIEludGVycG9sYXRpb25Qcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ0eXBlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8pXG5dLCBJbnRlcnBvbGF0aW9uUHJvcGVydGllcy5wcm90b3R5cGUsIFwidGVuc2lvblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKElOVEVSUE9MQVRJT05fU1RFUF9QT1NJVElPTilcbl0sIEludGVycG9sYXRpb25Qcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJwb3NpdGlvblwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9hcmVhU2VyaWVzUHJvcGVydGllcy50c1xudmFyIEFyZWFTZXJpZXNQcm9wZXJ0aWVzID0gY2xhc3MgZXh0ZW5kcyBDYXJ0ZXNpYW5TZXJpZXNQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnhOYW1lID0gdm9pZCAwO1xuICAgIHRoaXMuZmlsbCA9IFwiI2MxNjA2OFwiO1xuICAgIHRoaXMuZmlsbE9wYWNpdHkgPSAxO1xuICAgIHRoaXMuc3Ryb2tlID0gXCIjODc0MzQ5XCI7XG4gICAgdGhpcy5zdHJva2VXaWR0aCA9IDI7XG4gICAgdGhpcy5zdHJva2VPcGFjaXR5ID0gMTtcbiAgICB0aGlzLmxpbmVEYXNoID0gWzBdO1xuICAgIHRoaXMubGluZURhc2hPZmZzZXQgPSAwO1xuICAgIHRoaXMuaW50ZXJwb2xhdGlvbiA9IG5ldyBJbnRlcnBvbGF0aW9uUHJvcGVydGllcygpO1xuICAgIHRoaXMuc2hhZG93ID0gbmV3IERyb3BTaGFkb3coKTtcbiAgICB0aGlzLm1hcmtlciA9IG5ldyBTZXJpZXNNYXJrZXIoKTtcbiAgICB0aGlzLmxhYmVsID0gbmV3IExhYmVsKCk7XG4gICAgdGhpcy50b29sdGlwID0gbmV3IFNlcmllc1Rvb2x0aXAoKTtcbiAgICB0aGlzLmNvbm5lY3RNaXNzaW5nRGF0YSA9IGZhbHNlO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HKVxuXSwgQXJlYVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInhLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEFyZWFTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ4TmFtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORylcbl0sIEFyZWFTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ5S2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBBcmVhU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwieU5hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEFyZWFTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ5RmlsdGVyS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBBcmVhU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibm9ybWFsaXplZFRvXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HKVxuXSwgQXJlYVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImZpbGxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTylcbl0sIEFyZWFTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJmaWxsT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORylcbl0sIEFyZWFTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdHJva2VcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBBcmVhU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic3Ryb2tlV2lkdGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTylcbl0sIEFyZWFTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdHJva2VPcGFjaXR5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTElORV9EQVNIKVxuXSwgQXJlYVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImxpbmVEYXNoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgQXJlYVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImxpbmVEYXNoT2Zmc2V0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgQXJlYVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImludGVycG9sYXRpb25cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBBcmVhU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic2hhZG93XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgQXJlYVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcIm1hcmtlclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIEFyZWFTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJsYWJlbFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIEFyZWFTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ0b29sdGlwXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIEFyZWFTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjb25uZWN0TWlzc2luZ0RhdGFcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vbGluZUludGVycG9sYXRpb24udHNcbmZ1bmN0aW9uIHNwYW5SYW5nZShzcGFuKSB7XG4gIHN3aXRjaCAoc3Bhbi50eXBlKSB7XG4gICAgY2FzZSBcImxpbmVhclwiOlxuICAgIGNhc2UgXCJzdGVwXCI6XG4gICAgICByZXR1cm4gW1xuICAgICAgICB7IHg6IHNwYW4ueDAsIHk6IHNwYW4ueTAgfSxcbiAgICAgICAgeyB4OiBzcGFuLngxLCB5OiBzcGFuLnkxIH1cbiAgICAgIF07XG4gICAgY2FzZSBcImN1YmljXCI6XG4gICAgICByZXR1cm4gW1xuICAgICAgICB7IHg6IHNwYW4uY3AweCwgeTogc3Bhbi5jcDB5IH0sXG4gICAgICAgIHsgeDogc3Bhbi5jcDN4LCB5OiBzcGFuLmNwM3kgfVxuICAgICAgXTtcbiAgfVxufVxuZnVuY3Rpb24gc3BhblJhbmdlTm9ybWFsaXplZChzcGFuKSB7XG4gIGNvbnN0IHJhbmdlMyA9IHNwYW5SYW5nZShzcGFuKTtcbiAgaWYgKHJhbmdlM1swXS54ID4gcmFuZ2UzWzFdLngpIHtcbiAgICByYW5nZTMucmV2ZXJzZSgpO1xuICB9XG4gIHJldHVybiByYW5nZTM7XG59XG5mdW5jdGlvbiByZXNjYWxlU3BhbihzcGFuLCBuZXh0U3RhcnQsIG5leHRFbmQpIHtcbiAgY29uc3QgW3ByZXZTdGFydCwgcHJldkVuZF0gPSBzcGFuUmFuZ2Uoc3Bhbik7XG4gIGNvbnN0IHdpZHRoU2NhbGUgPSBwcmV2RW5kLnggIT09IHByZXZTdGFydC54ID8gKG5leHRFbmQueCAtIG5leHRTdGFydC54KSAvIChwcmV2RW5kLnggLSBwcmV2U3RhcnQueCkgOiAwO1xuICBjb25zdCBoZWlnaHRTY2FsZSA9IHByZXZFbmQueSAhPT0gcHJldlN0YXJ0LnkgPyAobmV4dEVuZC55IC0gbmV4dFN0YXJ0LnkpIC8gKHByZXZFbmQueSAtIHByZXZTdGFydC55KSA6IDA7XG4gIHN3aXRjaCAoc3Bhbi50eXBlKSB7XG4gICAgY2FzZSBcImxpbmVhclwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJsaW5lYXJcIixcbiAgICAgICAgbW92ZVRvOiBzcGFuLm1vdmVUbyxcbiAgICAgICAgeDA6IG5leHRTdGFydC54LFxuICAgICAgICB5MDogbmV4dFN0YXJ0LnksXG4gICAgICAgIHgxOiBuZXh0RW5kLngsXG4gICAgICAgIHkxOiBuZXh0RW5kLnlcbiAgICAgIH07XG4gICAgY2FzZSBcImN1YmljXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImN1YmljXCIsXG4gICAgICAgIG1vdmVUbzogc3Bhbi5tb3ZlVG8sXG4gICAgICAgIGNwMHg6IG5leHRTdGFydC54LFxuICAgICAgICBjcDB5OiBuZXh0U3RhcnQueSxcbiAgICAgICAgY3AxeDogbmV4dEVuZC54IC0gKHNwYW4uY3AyeCAtIHByZXZTdGFydC54KSAqIHdpZHRoU2NhbGUsXG4gICAgICAgIGNwMXk6IG5leHRFbmQueSAtIChzcGFuLmNwMnkgLSBwcmV2U3RhcnQueSkgKiBoZWlnaHRTY2FsZSxcbiAgICAgICAgY3AyeDogbmV4dEVuZC54IC0gKHNwYW4uY3AxeCAtIHByZXZTdGFydC54KSAqIHdpZHRoU2NhbGUsXG4gICAgICAgIGNwMnk6IG5leHRFbmQueSAtIChzcGFuLmNwMXkgLSBwcmV2U3RhcnQueSkgKiBoZWlnaHRTY2FsZSxcbiAgICAgICAgY3AzeDogbmV4dEVuZC54LFxuICAgICAgICBjcDN5OiBuZXh0RW5kLnlcbiAgICAgIH07XG4gICAgY2FzZSBcInN0ZXBcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwic3RlcFwiLFxuICAgICAgICBtb3ZlVG86IHNwYW4ubW92ZVRvLFxuICAgICAgICB4MDogbmV4dFN0YXJ0LngsXG4gICAgICAgIHkwOiBuZXh0U3RhcnQueSxcbiAgICAgICAgeDE6IG5leHRFbmQueCxcbiAgICAgICAgeTE6IG5leHRFbmQueSxcbiAgICAgICAgc3RlcFg6IG5leHRFbmQueCAtIChzcGFuLnN0ZXBYIC0gcHJldlN0YXJ0LngpICogd2lkdGhTY2FsZVxuICAgICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gY2xpcFNwYW5YKHNwYW4sIHgwLCB4MSkge1xuICBjb25zdCB7IG1vdmVUbyB9ID0gc3BhbjtcbiAgY29uc3QgW3N0YXJ0MiwgZW5kMl0gPSBzcGFuUmFuZ2VOb3JtYWxpemVkKHNwYW4pO1xuICBjb25zdCB7IHg6IHNwYW5YMCwgeTogc3BhblkwIH0gPSBzdGFydDI7XG4gIGNvbnN0IHsgeDogc3BhblgxLCB5OiBzcGFuWTEgfSA9IGVuZDI7XG4gIGlmICh4MSA8IHNwYW5YMCkge1xuICAgIHJldHVybiByZXNjYWxlU3BhbihzcGFuLCBzdGFydDIsIHN0YXJ0Mik7XG4gIH0gZWxzZSBpZiAoeDAgPiBzcGFuWDEpIHtcbiAgICByZXR1cm4gcmVzY2FsZVNwYW4oc3BhbiwgZW5kMiwgZW5kMik7XG4gIH1cbiAgc3dpdGNoIChzcGFuLnR5cGUpIHtcbiAgICBjYXNlIFwibGluZWFyXCI6IHtcbiAgICAgIGNvbnN0IG0gPSBzcGFuWTAgPT09IHNwYW5ZMSA/IHZvaWQgMCA6IChzcGFuWTEgLSBzcGFuWTApIC8gKHNwYW5YMSAtIHNwYW5YMCk7XG4gICAgICBjb25zdCB5MCA9IG0gPT0gbnVsbCA/IHNwYW5ZMCA6IG0gKiAoeDAgLSBzcGFuWDApICsgc3BhblkwO1xuICAgICAgY29uc3QgeTEgPSBtID09IG51bGwgPyBzcGFuWTAgOiBtICogKHgxIC0gc3BhblgwKSArIHNwYW5ZMDtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibGluZWFyXCIsIG1vdmVUbywgeDAsIHkwLCB4MSwgeTEgfTtcbiAgICB9XG4gICAgY2FzZSBcInN0ZXBcIjpcbiAgICAgIGlmICh4MSA8PSBzcGFuLnN0ZXBYKSB7XG4gICAgICAgIGNvbnN0IHkgPSBzcGFuLnkwO1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcInN0ZXBcIiwgbW92ZVRvLCB4MCwgeTA6IHksIHgxLCB5MTogeSwgc3RlcFg6IHgxIH07XG4gICAgICB9IGVsc2UgaWYgKHgwID49IHNwYW4uc3RlcFgpIHtcbiAgICAgICAgY29uc3QgeSA9IHNwYW4ueTE7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwic3RlcFwiLCBtb3ZlVG8sIHgwLCB5MDogeSwgeDEsIHkxOiB5LCBzdGVwWDogeDAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHsgeTAsIHkxLCBzdGVwWCB9ID0gc3BhbjtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJzdGVwXCIsIG1vdmVUbywgeDAsIHkwLCB4MSwgeTEsIHN0ZXBYIH07XG4gICAgICB9XG4gICAgY2FzZSBcImN1YmljXCI6IHtcbiAgICAgIGNvbnN0IHQwID0gc29sdmVCZXppZXIoc3Bhbi5jcDB4LCBzcGFuLmNwMXgsIHNwYW4uY3AyeCwgc3Bhbi5jcDN4LCB4MCk7XG4gICAgICBsZXQgW191bnVzZWQsIGJlemllcl0gPSBzcGxpdEJlemllcihcbiAgICAgICAgc3Bhbi5jcDB4LFxuICAgICAgICBzcGFuLmNwMHksXG4gICAgICAgIHNwYW4uY3AxeCxcbiAgICAgICAgc3Bhbi5jcDF5LFxuICAgICAgICBzcGFuLmNwMngsXG4gICAgICAgIHNwYW4uY3AyeSxcbiAgICAgICAgc3Bhbi5jcDN4LFxuICAgICAgICBzcGFuLmNwM3ksXG4gICAgICAgIHQwXG4gICAgICApO1xuICAgICAgY29uc3QgdDEgPSBzb2x2ZUJlemllcihiZXppZXJbMF0ueCwgYmV6aWVyWzFdLngsIGJlemllclsyXS54LCBiZXppZXJbM10ueCwgeDEpO1xuICAgICAgW2JlemllciwgX3VudXNlZF0gPSBzcGxpdEJlemllcihcbiAgICAgICAgYmV6aWVyWzBdLngsXG4gICAgICAgIGJlemllclswXS55LFxuICAgICAgICBiZXppZXJbMV0ueCxcbiAgICAgICAgYmV6aWVyWzFdLnksXG4gICAgICAgIGJlemllclsyXS54LFxuICAgICAgICBiZXppZXJbMl0ueSxcbiAgICAgICAgYmV6aWVyWzNdLngsXG4gICAgICAgIGJlemllclszXS55LFxuICAgICAgICB0MVxuICAgICAgKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiY3ViaWNcIixcbiAgICAgICAgbW92ZVRvLFxuICAgICAgICBjcDB4OiBiZXppZXJbMF0ueCxcbiAgICAgICAgY3AweTogYmV6aWVyWzBdLnksXG4gICAgICAgIGNwMXg6IGJlemllclsxXS54LFxuICAgICAgICBjcDF5OiBiZXppZXJbMV0ueSxcbiAgICAgICAgY3AyeDogYmV6aWVyWzJdLngsXG4gICAgICAgIGNwMnk6IGJlemllclsyXS55LFxuICAgICAgICBjcDN4OiBiZXppZXJbM10ueCxcbiAgICAgICAgY3AzeTogYmV6aWVyWzNdLnlcbiAgICAgIH07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBsaW5lYXJQb2ludHMocG9pbnRzKSB7XG4gIGNvbnN0IHNwYW5zID0gW107XG4gIGxldCBpID0gMDtcbiAgbGV0IHgwID0gTmFOO1xuICBsZXQgeTAgPSBOYU47XG4gIGZvciAoY29uc3QgeyB4OiB4MSwgeTogeTEgfSBvZiBwb2ludHMpIHtcbiAgICBpZiAoaSA+IDApIHtcbiAgICAgIGNvbnN0IG1vdmVUbyA9IGkgPT09IDE7XG4gICAgICBzcGFucy5wdXNoKHsgdHlwZTogXCJsaW5lYXJcIiwgbW92ZVRvLCB4MCwgeTAsIHgxLCB5MSB9KTtcbiAgICB9XG4gICAgaSArPSAxO1xuICAgIHgwID0geDE7XG4gICAgeTAgPSB5MTtcbiAgfVxuICByZXR1cm4gc3BhbnM7XG59XG52YXIgbGluZVN0ZXBzID0ge1xuICBzdGFydDogMCxcbiAgbWlkZGxlOiAwLjUsXG4gIGVuZDogMVxufTtcbmZ1bmN0aW9uIHN0ZXBQb2ludHMocG9pbnRzLCBwb3NpdGlvbikge1xuICBjb25zdCBzcGFucyA9IFtdO1xuICBsZXQgaSA9IDA7XG4gIGxldCB4MCA9IE5hTjtcbiAgbGV0IHkwID0gTmFOO1xuICBjb25zdCBwMCA9IHR5cGVvZiBwb3NpdGlvbiA9PT0gXCJudW1iZXJcIiA/IHBvc2l0aW9uIDogbGluZVN0ZXBzW3Bvc2l0aW9uXTtcbiAgZm9yIChjb25zdCB7IHg6IHgxLCB5OiB5MSB9IG9mIHBvaW50cykge1xuICAgIGlmIChpID4gMCkge1xuICAgICAgY29uc3QgbW92ZVRvID0gaSA9PT0gMTtcbiAgICAgIGNvbnN0IHN0ZXBYID0geDAgKyAoeDEgLSB4MCkgKiBwMDtcbiAgICAgIHNwYW5zLnB1c2goeyB0eXBlOiBcInN0ZXBcIiwgbW92ZVRvLCB4MCwgeTAsIHgxLCB5MSwgc3RlcFggfSk7XG4gICAgfVxuICAgIGkgKz0gMTtcbiAgICB4MCA9IHgxO1xuICAgIHkwID0geTE7XG4gIH1cbiAgcmV0dXJuIHNwYW5zO1xufVxudmFyIGZsYXRuZXNzUmF0aW8gPSAwLjA1O1xuZnVuY3Rpb24gc21vb3RoUG9pbnRzKGlQb2ludHMsIHRlbnNpb24pIHtcbiAgY29uc3QgcG9pbnRzID0gQXJyYXkuaXNBcnJheShpUG9pbnRzKSA/IGlQb2ludHMgOiBBcnJheS5mcm9tKGlQb2ludHMpO1xuICBpZiAocG9pbnRzLmxlbmd0aCA8PSAxKVxuICAgIHJldHVybiBbXTtcbiAgY29uc3QgZ3JhZGllbnRzID0gcG9pbnRzLm1hcCgoYywgaSkgPT4ge1xuICAgIGNvbnN0IHAgPSBpID09PSAwID8gYyA6IHBvaW50c1tpIC0gMV07XG4gICAgY29uc3QgbiA9IGkgPT09IHBvaW50cy5sZW5ndGggLSAxID8gYyA6IHBvaW50c1tpICsgMV07XG4gICAgY29uc3QgaXNUZXJtaW5hbFBvaW50ID0gaSA9PT0gMCB8fCBpID09PSBwb2ludHMubGVuZ3RoIC0gMTtcbiAgICBpZiAoTWF0aC5zaWduKHAueSAtIGMueSkgPT09IE1hdGguc2lnbihuLnkgLSBjLnkpKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgaWYgKCFpc1Rlcm1pbmFsUG9pbnQpIHtcbiAgICAgIGNvbnN0IHJhbmdlMyA9IE1hdGguYWJzKHAueSAtIG4ueSk7XG4gICAgICBjb25zdCBwcmV2UmF0aW8gPSBNYXRoLmFicyhjLnkgLSBwLnkpIC8gcmFuZ2UzO1xuICAgICAgY29uc3QgbmV4dFJhdGlvID0gTWF0aC5hYnMoYy55IC0gbi55KSAvIHJhbmdlMztcbiAgICAgIGlmIChwcmV2UmF0aW8gPD0gZmxhdG5lc3NSYXRpbyB8fCAxIC0gcHJldlJhdGlvIDw9IGZsYXRuZXNzUmF0aW8gfHwgbmV4dFJhdGlvIDw9IGZsYXRuZXNzUmF0aW8gfHwgMSAtIG5leHRSYXRpbyA8PSBmbGF0bmVzc1JhdGlvKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKG4ueSAtIHAueSkgLyAobi54IC0gcC54KTtcbiAgfSk7XG4gIGlmIChncmFkaWVudHNbMV0gPT09IDApIHtcbiAgICBncmFkaWVudHNbMF0gKj0gMjtcbiAgfVxuICBpZiAoZ3JhZGllbnRzW2dyYWRpZW50cy5sZW5ndGggLSAyXSA9PT0gMCkge1xuICAgIGdyYWRpZW50c1tncmFkaWVudHMubGVuZ3RoIC0gMV0gKj0gMjtcbiAgfVxuICBjb25zdCBzcGFucyA9IFtdO1xuICBmb3IgKGxldCBpID0gMTsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IHByZXYgPSBwb2ludHNbaSAtIDFdO1xuICAgIGNvbnN0IHByZXZNID0gZ3JhZGllbnRzW2kgLSAxXTtcbiAgICBjb25zdCBjdXIgPSBwb2ludHNbaV07XG4gICAgY29uc3QgY3VyTSA9IGdyYWRpZW50c1tpXTtcbiAgICBjb25zdCBkeCA9IGN1ci54IC0gcHJldi54O1xuICAgIGNvbnN0IGR5ID0gY3VyLnkgLSBwcmV2Lnk7XG4gICAgbGV0IGRjcDF4ID0gZHggKiB0ZW5zaW9uIC8gMztcbiAgICBsZXQgZGNwMXkgPSBkeCAqIHByZXZNICogdGVuc2lvbiAvIDM7XG4gICAgbGV0IGRjcDJ4ID0gZHggKiB0ZW5zaW9uIC8gMztcbiAgICBsZXQgZGNwMnkgPSBkeCAqIGN1ck0gKiB0ZW5zaW9uIC8gMztcbiAgICBpZiAoY3VyTSA9PT0gMCAmJiBNYXRoLmFicyhkY3AxeSkgPiBNYXRoLmFicyhkeSkpIHtcbiAgICAgIGRjcDF4ICo9IE1hdGguYWJzKGR5IC8gZGNwMXkpO1xuICAgICAgZGNwMXkgPSBNYXRoLnNpZ24oZGNwMXkpICogTWF0aC5hYnMoZHkpO1xuICAgIH1cbiAgICBpZiAocHJldk0gPT09IDAgJiYgTWF0aC5hYnMoZGNwMnkpID4gTWF0aC5hYnMoZHkpKSB7XG4gICAgICBkY3AyeCAqPSBNYXRoLmFicyhkeSAvIGRjcDJ5KTtcbiAgICAgIGRjcDJ5ID0gTWF0aC5zaWduKGRjcDJ5KSAqIE1hdGguYWJzKGR5KTtcbiAgICB9XG4gICAgc3BhbnMucHVzaCh7XG4gICAgICB0eXBlOiBcImN1YmljXCIsXG4gICAgICBtb3ZlVG86IGkgPT09IDEsXG4gICAgICBjcDB4OiBwcmV2LngsXG4gICAgICBjcDB5OiBwcmV2LnksXG4gICAgICBjcDF4OiBwcmV2LnggKyBkY3AxeCxcbiAgICAgIGNwMXk6IHByZXYueSArIGRjcDF5LFxuICAgICAgY3AyeDogY3VyLnggLSBkY3AyeCxcbiAgICAgIGNwMnk6IGN1ci55IC0gZGNwMnksXG4gICAgICBjcDN4OiBjdXIueCxcbiAgICAgIGNwM3k6IGN1ci55XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHNwYW5zO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2xpbmVJbnRlcnBvbGF0aW9uUGxvdHRpbmcudHNcbmZ1bmN0aW9uIGxlcnAyKGEsIGIsIHJhdGlvMikge1xuICByZXR1cm4gKGIgLSBhKSAqIHJhdGlvMiArIGE7XG59XG5mdW5jdGlvbiBsaW5lYXJTdXBlcnR5cGUoc3Bhbiwgc3RlcFgpIHtcbiAgY29uc3QgeyB4MCwgeTAsIHgxLCB5MSB9ID0gc3BhbjtcbiAgY29uc3QgbSA9ICh5MSAtIHkwKSAvICh4MSAtIHgwKTtcbiAgY29uc3Qgc3RlcFkgPSBtICogKHN0ZXBYIC0geDApICsgeTA7XG4gIHJldHVybiB7XG4gICAgbGVmdENwMXg6IHgwLFxuICAgIGxlZnRDcDF5OiB5MCxcbiAgICBsZWZ0Q3AyeDogc3RlcFgsXG4gICAgbGVmdENwMnk6IHN0ZXBZLFxuICAgIHN0ZXBYLFxuICAgIHN0ZXBZMDogc3RlcFksXG4gICAgc3RlcFkxOiBzdGVwWSxcbiAgICByaWdodENwMXg6IHN0ZXBYLFxuICAgIHJpZ2h0Q3AxeTogc3RlcFksXG4gICAgcmlnaHRDcDJ4OiB4MSxcbiAgICByaWdodENwMnk6IHkxXG4gIH07XG59XG5mdW5jdGlvbiBiZXppZXJTdXBlcnR5cGUoc3Bhbiwgc3RlcFgpIHtcbiAgY29uc3QgeyBjcDB4LCBjcDB5LCBjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCBjcDN4LCBjcDN5IH0gPSBzcGFuO1xuICBjb25zdCB0ID0gc29sdmVCZXppZXIoY3AweCwgY3AxeCwgY3AyeCwgY3AzeCwgc3RlcFgpO1xuICBjb25zdCBbbGVmdCwgcmlnaHRdID0gc3BsaXRCZXppZXIoY3AweCwgY3AweSwgY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgY3AzeCwgY3AzeSwgdCk7XG4gIGNvbnN0IHN0ZXBZID0gbGVmdFszXS55O1xuICByZXR1cm4ge1xuICAgIGxlZnRDcDF4OiBsZWZ0WzFdLngsXG4gICAgbGVmdENwMXk6IGxlZnRbMV0ueSxcbiAgICBsZWZ0Q3AyeDogbGVmdFsyXS54LFxuICAgIGxlZnRDcDJ5OiBsZWZ0WzJdLnksXG4gICAgc3RlcFgsXG4gICAgc3RlcFkwOiBzdGVwWSxcbiAgICBzdGVwWTE6IHN0ZXBZLFxuICAgIHJpZ2h0Q3AxeDogcmlnaHRbMV0ueCxcbiAgICByaWdodENwMXk6IHJpZ2h0WzFdLnksXG4gICAgcmlnaHRDcDJ4OiByaWdodFsyXS54LFxuICAgIHJpZ2h0Q3AyeTogcmlnaHRbMl0ueVxuICB9O1xufVxuZnVuY3Rpb24gc3RlcFN1cGVydHlwZShzcGFuKSB7XG4gIGNvbnN0IHsgeDAsIHkwLCB4MSwgeTEsIHN0ZXBYIH0gPSBzcGFuO1xuICByZXR1cm4ge1xuICAgIGxlZnRDcDF4OiAoeDAgKyBzdGVwWCkgLyAyLFxuICAgIGxlZnRDcDF5OiB5MCxcbiAgICBsZWZ0Q3AyeDogKHgwICsgc3RlcFgpIC8gMixcbiAgICBsZWZ0Q3AyeTogeTAsXG4gICAgc3RlcFgsXG4gICAgc3RlcFkwOiB5MCxcbiAgICBzdGVwWTE6IHkxLFxuICAgIHJpZ2h0Q3AxeDogKHN0ZXBYICsgeDEpIC8gMixcbiAgICByaWdodENwMXk6IHkxLFxuICAgIHJpZ2h0Q3AyeDogKHN0ZXBYICsgeDEpIC8gMixcbiAgICByaWdodENwMnk6IHkxXG4gIH07XG59XG5mdW5jdGlvbiBzcGFuU3VwZXJ0eXBlKHNwYW4sIHN0ZXBYKSB7XG4gIGlmIChzcGFuLnR5cGUgPT09IFwibGluZWFyXCIpIHtcbiAgICByZXR1cm4gbGluZWFyU3VwZXJ0eXBlKHNwYW4sIHN0ZXBYKTtcbiAgfSBlbHNlIGlmIChzcGFuLnR5cGUgPT09IFwiY3ViaWNcIikge1xuICAgIHJldHVybiBiZXppZXJTdXBlcnR5cGUoc3Bhbiwgc3RlcFgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdGVwU3VwZXJ0eXBlKHNwYW4pO1xuICB9XG59XG5mdW5jdGlvbiBwbG90U3RhcnQocGF0aCwgbW92ZVRvLCB4MCwgeTAsIHgxLCB5MSwgcmV2ZXJzZWQpIHtcbiAgc3dpdGNoIChtb3ZlVG8pIHtcbiAgICBjYXNlIDEgLyogTW92ZVRvICovOlxuICAgICAgaWYgKHJldmVyc2VkKSB7XG4gICAgICAgIHBhdGgubW92ZVRvKHgxLCB5MSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXRoLm1vdmVUbyh4MCwgeTApO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyIC8qIExpbmVUbyAqLzpcbiAgICAgIGlmIChyZXZlcnNlZCkge1xuICAgICAgICBwYXRoLmxpbmVUbyh4MSwgeTEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGF0aC5saW5lVG8oeDAsIHkwKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG59XG5mdW5jdGlvbiBwbG90TGluZWFyKHBhdGgsIHgwLCB5MCwgeDEsIHkxLCByZXZlcnNlZCkge1xuICBpZiAocmV2ZXJzZWQpIHtcbiAgICBwYXRoLmxpbmVUbyh4MCwgeTApO1xuICB9IGVsc2Uge1xuICAgIHBhdGgubGluZVRvKHgxLCB5MSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBsb3RDdWJpYyhwYXRoLCBjcDB4LCBjcDB5LCBjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCBjcDN4LCBjcDN5LCByZXZlcnNlZCkge1xuICBpZiAocmV2ZXJzZWQpIHtcbiAgICBwYXRoLmN1YmljQ3VydmVUbyhjcDJ4LCBjcDJ5LCBjcDF4LCBjcDF5LCBjcDB4LCBjcDB5KTtcbiAgfSBlbHNlIHtcbiAgICBwYXRoLmN1YmljQ3VydmVUbyhjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCBjcDN4LCBjcDN5KTtcbiAgfVxufVxuZnVuY3Rpb24gcGxvdFN0ZXAocGF0aCwgeDAsIHkwLCB4MSwgeTEsIHN0ZXBYLCByZXZlcnNlZCkge1xuICBpZiAocmV2ZXJzZWQpIHtcbiAgICBwYXRoLmxpbmVUbyhzdGVwWCwgeTEpO1xuICAgIHBhdGgubGluZVRvKHN0ZXBYLCB5MCk7XG4gICAgcGF0aC5saW5lVG8oeDAsIHkwKTtcbiAgfSBlbHNlIHtcbiAgICBwYXRoLmxpbmVUbyhzdGVwWCwgeTApO1xuICAgIHBhdGgubGluZVRvKHN0ZXBYLCB5MSk7XG4gICAgcGF0aC5saW5lVG8oeDEsIHkxKTtcbiAgfVxufVxuZnVuY3Rpb24gcGxvdFNwYW4ocGF0aCwgc3BhbiwgbW92ZVRvLCByZXZlcnNlZCkge1xuICBjb25zdCBbc3RhcnQyLCBlbmQyXSA9IHNwYW5SYW5nZShzcGFuKTtcbiAgcGxvdFN0YXJ0KHBhdGgsIG1vdmVUbywgc3RhcnQyLngsIHN0YXJ0Mi55LCBlbmQyLngsIGVuZDIueSwgcmV2ZXJzZWQpO1xuICBzd2l0Y2ggKHNwYW4udHlwZSkge1xuICAgIGNhc2UgXCJsaW5lYXJcIjpcbiAgICAgIHBsb3RMaW5lYXIocGF0aCwgc3Bhbi54MCwgc3Bhbi55MCwgc3Bhbi54MSwgc3Bhbi55MSwgcmV2ZXJzZWQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImN1YmljXCI6XG4gICAgICBwbG90Q3ViaWMoXG4gICAgICAgIHBhdGgsXG4gICAgICAgIHNwYW4uY3AweCxcbiAgICAgICAgc3Bhbi5jcDB5LFxuICAgICAgICBzcGFuLmNwMXgsXG4gICAgICAgIHNwYW4uY3AxeSxcbiAgICAgICAgc3Bhbi5jcDJ4LFxuICAgICAgICBzcGFuLmNwMnksXG4gICAgICAgIHNwYW4uY3AzeCxcbiAgICAgICAgc3Bhbi5jcDN5LFxuICAgICAgICByZXZlcnNlZFxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJzdGVwXCI6XG4gICAgICBwbG90U3RlcChwYXRoLCBzcGFuLngwLCBzcGFuLnkwLCBzcGFuLngxLCBzcGFuLnkxLCBzcGFuLnN0ZXBYLCByZXZlcnNlZCk7XG4gICAgICBicmVhaztcbiAgfVxufVxuZnVuY3Rpb24gcGxvdEludGVycG9sYXRlZFNwYW5zKHBhdGgsIGEsIGIsIHJhdGlvMiwgbW92ZVRvLCByZXZlcnNlZCkge1xuICBjb25zdCBbYVN0YXJ0LCBhRW5kXSA9IHNwYW5SYW5nZShhKTtcbiAgY29uc3QgW2JTdGFydCwgYkVuZF0gPSBzcGFuUmFuZ2UoYik7XG4gIGNvbnN0IHgwID0gbGVycDIoYVN0YXJ0LngsIGJTdGFydC54LCByYXRpbzIpO1xuICBjb25zdCB5MCA9IGxlcnAyKGFTdGFydC55LCBiU3RhcnQueSwgcmF0aW8yKTtcbiAgY29uc3QgeDEgPSBsZXJwMihhRW5kLngsIGJFbmQueCwgcmF0aW8yKTtcbiAgY29uc3QgeTEgPSBsZXJwMihhRW5kLnksIGJFbmQueSwgcmF0aW8yKTtcbiAgcGxvdFN0YXJ0KHBhdGgsIG1vdmVUbywgeDAsIHkwLCB4MSwgeTEsIHJldmVyc2VkKTtcbiAgaWYgKGEudHlwZSA9PT0gXCJjdWJpY1wiICYmIGIudHlwZSA9PT0gXCJjdWJpY1wiKSB7XG4gICAgY29uc3QgY3AxeCA9IGxlcnAyKGEuY3AxeCwgYi5jcDF4LCByYXRpbzIpO1xuICAgIGNvbnN0IGNwMXkgPSBsZXJwMihhLmNwMXksIGIuY3AxeSwgcmF0aW8yKTtcbiAgICBjb25zdCBjcDJ4ID0gbGVycDIoYS5jcDJ4LCBiLmNwMngsIHJhdGlvMik7XG4gICAgY29uc3QgY3AyeSA9IGxlcnAyKGEuY3AyeSwgYi5jcDJ5LCByYXRpbzIpO1xuICAgIHBsb3RDdWJpYyhwYXRoLCB4MCwgeTAsIGNwMXgsIGNwMXksIGNwMngsIGNwMnksIHgxLCB5MSwgcmV2ZXJzZWQpO1xuICB9IGVsc2UgaWYgKGEudHlwZSA9PT0gXCJzdGVwXCIgJiYgYi50eXBlID09PSBcInN0ZXBcIikge1xuICAgIGNvbnN0IHN0ZXBYID0gbGVycDIoYS5zdGVwWCwgYi5zdGVwWCwgcmF0aW8yKTtcbiAgICBwbG90U3RlcChwYXRoLCB4MCwgeTAsIHgxLCB5MSwgc3RlcFgsIHJldmVyc2VkKTtcbiAgfSBlbHNlIGlmIChhLnR5cGUgPT09IFwibGluZWFyXCIgJiYgYi50eXBlID09PSBcImxpbmVhclwiKSB7XG4gICAgcGxvdExpbmVhcihwYXRoLCB4MCwgeTAsIHgxLCB5MSwgcmV2ZXJzZWQpO1xuICB9IGVsc2Uge1xuICAgIGxldCBkZWZhdWx0U3RlcFg7XG4gICAgaWYgKGEudHlwZSA9PT0gXCJzdGVwXCIpIHtcbiAgICAgIGRlZmF1bHRTdGVwWCA9IGEuc3RlcFg7XG4gICAgfSBlbHNlIGlmIChiLnR5cGUgPT09IFwic3RlcFwiKSB7XG4gICAgICBkZWZhdWx0U3RlcFggPSBiLnN0ZXBYO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWZhdWx0U3RlcFggPSAoeDAgKyB4MSkgLyAyO1xuICAgIH1cbiAgICBjb25zdCBhcyA9IHNwYW5TdXBlcnR5cGUoYSwgZGVmYXVsdFN0ZXBYKTtcbiAgICBjb25zdCBicyA9IHNwYW5TdXBlcnR5cGUoYiwgZGVmYXVsdFN0ZXBYKTtcbiAgICBjb25zdCBsZWZ0Q3AxeCA9IGxlcnAyKGFzLmxlZnRDcDF4LCBicy5sZWZ0Q3AxeCwgcmF0aW8yKTtcbiAgICBjb25zdCBsZWZ0Q3AxeSA9IGxlcnAyKGFzLmxlZnRDcDF5LCBicy5sZWZ0Q3AxeSwgcmF0aW8yKTtcbiAgICBjb25zdCBsZWZ0Q3AyeCA9IGxlcnAyKGFzLmxlZnRDcDJ4LCBicy5sZWZ0Q3AyeCwgcmF0aW8yKTtcbiAgICBjb25zdCBsZWZ0Q3AyeSA9IGxlcnAyKGFzLmxlZnRDcDJ5LCBicy5sZWZ0Q3AyeSwgcmF0aW8yKTtcbiAgICBjb25zdCBzdGVwWCA9IGxlcnAyKGFzLnN0ZXBYLCBicy5zdGVwWCwgcmF0aW8yKTtcbiAgICBjb25zdCBzdGVwWTAgPSBsZXJwMihhcy5zdGVwWTAsIGJzLnN0ZXBZMCwgcmF0aW8yKTtcbiAgICBjb25zdCBzdGVwWTEgPSBsZXJwMihhcy5zdGVwWTEsIGJzLnN0ZXBZMSwgcmF0aW8yKTtcbiAgICBjb25zdCByaWdodENwMXggPSBsZXJwMihhcy5yaWdodENwMXgsIGJzLnJpZ2h0Q3AxeCwgcmF0aW8yKTtcbiAgICBjb25zdCByaWdodENwMXkgPSBsZXJwMihhcy5yaWdodENwMXksIGJzLnJpZ2h0Q3AxeSwgcmF0aW8yKTtcbiAgICBjb25zdCByaWdodENwMnggPSBsZXJwMihhcy5yaWdodENwMngsIGJzLnJpZ2h0Q3AyeCwgcmF0aW8yKTtcbiAgICBjb25zdCByaWdodENwMnkgPSBsZXJwMihhcy5yaWdodENwMnksIGJzLnJpZ2h0Q3AyeSwgcmF0aW8yKTtcbiAgICBpZiAocmV2ZXJzZWQpIHtcbiAgICAgIHBhdGguY3ViaWNDdXJ2ZVRvKHJpZ2h0Q3AyeCwgcmlnaHRDcDJ5LCByaWdodENwMXgsIHJpZ2h0Q3AxeSwgc3RlcFgsIHN0ZXBZMSk7XG4gICAgICBwYXRoLmxpbmVUbyhzdGVwWCwgc3RlcFkwKTtcbiAgICAgIHBhdGguY3ViaWNDdXJ2ZVRvKGxlZnRDcDJ4LCBsZWZ0Q3AyeSwgbGVmdENwMXgsIGxlZnRDcDF5LCB4MCwgeTApO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRoLmN1YmljQ3VydmVUbyhsZWZ0Q3AxeCwgbGVmdENwMXksIGxlZnRDcDJ4LCBsZWZ0Q3AyeSwgc3RlcFgsIHN0ZXBZMCk7XG4gICAgICBwYXRoLmxpbmVUbyhzdGVwWCwgc3RlcFkxKTtcbiAgICAgIHBhdGguY3ViaWNDdXJ2ZVRvKHJpZ2h0Q3AxeCwgcmlnaHRDcDF5LCByaWdodENwMngsIHJpZ2h0Q3AyeSwgeDEsIHkxKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9tYXJrZXJVdGlsLnRzXG5mdW5jdGlvbiBtYXJrZXJGYWRlSW5BbmltYXRpb24oeyBpZCB9LCBhbmltYXRpb25NYW5hZ2VyLCBzdGF0dXMsIC4uLm1hcmtlclNlbGVjdGlvbnMpIHtcbiAgY29uc3QgcGFyYW1zID0geyBwaGFzZTogc3RhdHVzID8gTk9ERV9VUERBVEVfU1RBVEVfVE9fUEhBU0VfTUFQUElOR1tzdGF0dXNdIDogXCJ0cmFpbGluZ1wiIH07XG4gIHN0YXRpY0Zyb21Ub01vdGlvbihpZCwgXCJtYXJrZXJzXCIsIGFuaW1hdGlvbk1hbmFnZXIsIG1hcmtlclNlbGVjdGlvbnMsIHsgb3BhY2l0eTogMCB9LCB7IG9wYWNpdHk6IDEgfSwgcGFyYW1zKTtcbiAgbWFya2VyU2VsZWN0aW9ucy5mb3JFYWNoKChzKSA9PiBzLmNsZWFudXAoKSk7XG59XG5mdW5jdGlvbiBtYXJrZXJTY2FsZUluQW5pbWF0aW9uKHsgaWQgfSwgYW5pbWF0aW9uTWFuYWdlciwgLi4ubWFya2VyU2VsZWN0aW9ucykge1xuICBzdGF0aWNGcm9tVG9Nb3Rpb24oXG4gICAgaWQsXG4gICAgXCJtYXJrZXJzXCIsXG4gICAgYW5pbWF0aW9uTWFuYWdlcixcbiAgICBtYXJrZXJTZWxlY3Rpb25zLFxuICAgIHsgc2NhbGluZ1g6IDAsIHNjYWxpbmdZOiAwIH0sXG4gICAgeyBzY2FsaW5nWDogMSwgc2NhbGluZ1k6IDEgfSxcbiAgICB7IHBoYXNlOiBcImluaXRpYWxcIiB9XG4gICk7XG4gIG1hcmtlclNlbGVjdGlvbnMuZm9yRWFjaCgocykgPT4gcy5jbGVhbnVwKCkpO1xufVxuZnVuY3Rpb24gbWFya2VyU3dpcGVTY2FsZUluQW5pbWF0aW9uKHsgaWQsIG5vZGVEYXRhRGVwZW5kZW5jaWVzIH0sIGFuaW1hdGlvbk1hbmFnZXIsIC4uLm1hcmtlclNlbGVjdGlvbnMpIHtcbiAgY29uc3Qgc2VyaWVzV2lkdGggPSBub2RlRGF0YURlcGVuZGVuY2llcy5zZXJpZXNSZWN0V2lkdGg7XG4gIGNvbnN0IGZyb21GbiA9IChfLCBkYXR1bSkgPT4ge1xuICAgIGNvbnN0IHggPSBkYXR1bS5taWRQb2ludD8ueCA/PyBzZXJpZXNXaWR0aDtcbiAgICBsZXQgZGVsYXkgPSBjbGFtcCgwLCBpbnZlcnNlRWFzZU91dCh4IC8gc2VyaWVzV2lkdGgpLCAxKTtcbiAgICBpZiAoaXNOYU4oZGVsYXkpKSB7XG4gICAgICBkZWxheSA9IDA7XG4gICAgfVxuICAgIHJldHVybiB7IHNjYWxpbmdYOiAwLCBzY2FsaW5nWTogMCwgZGVsYXksIGR1cmF0aW9uOiBRVUlDS19UUkFOU0lUSU9OLCBwaGFzZTogXCJpbml0aWFsXCIgfTtcbiAgfTtcbiAgY29uc3QgdG9GbiA9ICgpID0+IHtcbiAgICByZXR1cm4geyBzY2FsaW5nWDogMSwgc2NhbGluZ1k6IDEgfTtcbiAgfTtcbiAgZnJvbVRvTW90aW9uKGlkLCBcIm1hcmtlcnNcIiwgYW5pbWF0aW9uTWFuYWdlciwgbWFya2VyU2VsZWN0aW9ucywgeyBmcm9tRm4sIHRvRm4gfSk7XG59XG5mdW5jdGlvbiByZXNldE1hcmtlckZuKF9ub2RlKSB7XG4gIHJldHVybiB7IG9wYWNpdHk6IDEsIHNjYWxpbmdYOiAxLCBzY2FsaW5nWTogMSB9O1xufVxuZnVuY3Rpb24gcmVzZXRNYXJrZXJQb3NpdGlvbkZuKF9ub2RlLCBkYXR1bSkge1xuICByZXR1cm4ge1xuICAgIHRyYW5zbGF0aW9uWDogZGF0dW0ucG9pbnQ/LnggPz8gTmFOLFxuICAgIHRyYW5zbGF0aW9uWTogZGF0dW0ucG9pbnQ/LnkgPz8gTmFOXG4gIH07XG59XG5mdW5jdGlvbiBwcmVwYXJlTWFya2VyQW5pbWF0aW9uKHBhaXJNYXAsIHBhcmVudFN0YXR1cykge1xuICBjb25zdCByZWFkRmlyc3RQYWlyID0gKHhWYWx1ZSwgdHlwZSkgPT4ge1xuICAgIGNvbnN0IHZhbCA9IHBhaXJNYXBbdHlwZV1beFZhbHVlXTtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWwpID8gdmFsWzBdIDogdmFsO1xuICB9O1xuICBjb25zdCBtYXJrZXJTdGF0dXMgPSAoZGF0dW0pID0+IHtcbiAgICBjb25zdCB7IHhWYWx1ZSB9ID0gZGF0dW07XG4gICAgaWYgKHBhaXJNYXAubW92ZWRbeFZhbHVlXSkge1xuICAgICAgcmV0dXJuIHsgcG9pbnQ6IHJlYWRGaXJzdFBhaXIoeFZhbHVlLCBcIm1vdmVkXCIpLCBzdGF0dXM6IFwidXBkYXRlZFwiIH07XG4gICAgfSBlbHNlIGlmIChwYWlyTWFwLnJlbW92ZWRbeFZhbHVlXSkge1xuICAgICAgcmV0dXJuIHsgcG9pbnQ6IHJlYWRGaXJzdFBhaXIoeFZhbHVlLCBcInJlbW92ZWRcIiksIHN0YXR1czogXCJyZW1vdmVkXCIgfTtcbiAgICB9IGVsc2UgaWYgKHBhaXJNYXAuYWRkZWRbeFZhbHVlXSkge1xuICAgICAgcmV0dXJuIHsgcG9pbnQ6IHJlYWRGaXJzdFBhaXIoeFZhbHVlLCBcImFkZGVkXCIpLCBzdGF0dXM6IFwiYWRkZWRcIiB9O1xuICAgIH1cbiAgICByZXR1cm4geyBzdGF0dXM6IFwidW5rbm93blwiIH07XG4gIH07XG4gIGNvbnN0IGZyb21GbiA9IChtYXJrZXIsIGRhdHVtKSA9PiB7XG4gICAgY29uc3QgeyBzdGF0dXMsIHBvaW50IH0gPSBtYXJrZXJTdGF0dXMoZGF0dW0pO1xuICAgIGlmIChzdGF0dXMgPT09IFwidW5rbm93blwiKVxuICAgICAgcmV0dXJuIHsgb3BhY2l0eTogMCB9O1xuICAgIGNvbnN0IGRlZmF1bHRzID0ge1xuICAgICAgdHJhbnNsYXRpb25YOiBwb2ludD8uZnJvbT8ueCA/PyBtYXJrZXIudHJhbnNsYXRpb25YLFxuICAgICAgdHJhbnNsYXRpb25ZOiBwb2ludD8uZnJvbT8ueSA/PyBtYXJrZXIudHJhbnNsYXRpb25ZLFxuICAgICAgb3BhY2l0eTogbWFya2VyLm9wYWNpdHksXG4gICAgICBwaGFzZTogTk9ERV9VUERBVEVfU1RBVEVfVE9fUEhBU0VfTUFQUElOR1tzdGF0dXNdXG4gICAgfTtcbiAgICBpZiAocGFyZW50U3RhdHVzID09PSBcImFkZGVkXCIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmRlZmF1bHRzLFxuICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICB0cmFuc2xhdGlvblg6IHBvaW50Py50bz8ueCxcbiAgICAgICAgdHJhbnNsYXRpb25ZOiBwb2ludD8udG8/LnksXG4gICAgICAgIHBoYXNlOiBOT0RFX1VQREFURV9TVEFURV9UT19QSEFTRV9NQVBQSU5HW1wiYWRkZWRcIl1cbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChzdGF0dXMgPT09IFwiYWRkZWRcIikge1xuICAgICAgZGVmYXVsdHMub3BhY2l0eSA9IDA7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0cztcbiAgfTtcbiAgY29uc3QgdG9GbiA9IChfbWFya2VyLCBkYXR1bSkgPT4ge1xuICAgIGNvbnN0IHsgc3RhdHVzLCBwb2ludCB9ID0gbWFya2VyU3RhdHVzKGRhdHVtKTtcbiAgICBpZiAoc3RhdHVzID09PSBcInVua25vd25cIilcbiAgICAgIHJldHVybiB7IG9wYWNpdHk6IDAgfTtcbiAgICBjb25zdCBkZWZhdWx0cyA9IHtcbiAgICAgIHRyYW5zbGF0aW9uWDogZGF0dW0ucG9pbnQueCxcbiAgICAgIHRyYW5zbGF0aW9uWTogZGF0dW0ucG9pbnQueSxcbiAgICAgIG9wYWNpdHk6IDEsXG4gICAgICBwaGFzZTogTk9ERV9VUERBVEVfU1RBVEVfVE9fUEhBU0VfTUFQUElOR1tzdGF0dXNdXG4gICAgfTtcbiAgICBpZiAoc3RhdHVzID09PSBcInJlbW92ZWRcIiB8fCBwYXJlbnRTdGF0dXMgPT09IFwicmVtb3ZlZFwiKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5kZWZhdWx0cyxcbiAgICAgICAgdHJhbnNsYXRpb25YOiBwb2ludD8udG8/LngsXG4gICAgICAgIHRyYW5zbGF0aW9uWTogcG9pbnQ/LnRvPy55LFxuICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICBwaGFzZTogTk9ERV9VUERBVEVfU1RBVEVfVE9fUEhBU0VfTUFQUElOR1tcInJlbW92ZWRcIl1cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0cztcbiAgfTtcbiAgcmV0dXJuIHsgZnJvbUZuLCB0b0ZuIH07XG59XG5mdW5jdGlvbiBjb21wdXRlTWFya2VyRm9jdXNCb3VuZHMoc2VyaWVzLCB7IGRhdHVtSW5kZXggfSkge1xuICBjb25zdCBub2RlRGF0YSA9IHNlcmllcy5nZXROb2RlRGF0YSgpO1xuICBpZiAobm9kZURhdGEgPT09IHZvaWQgMClcbiAgICByZXR1cm4gdm9pZCAwO1xuICBjb25zdCBkYXR1bSA9IG5vZGVEYXRhW2RhdHVtSW5kZXhdO1xuICBjb25zdCB7IHBvaW50IH0gPSBkYXR1bTtcbiAgaWYgKGRhdHVtID09IG51bGwgfHwgcG9pbnQgPT0gbnVsbClcbiAgICByZXR1cm4gdm9pZCAwO1xuICBjb25zdCBzaXplID0gcG9pbnQuZm9jdXNTaXplID8/IHNlcmllcy5nZXRGb3JtYXR0ZWRNYXJrZXJTdHlsZShkYXR1bSkuc2l6ZTtcbiAgY29uc3QgcmFkaXVzID0gc2l6ZSAvIDI7XG4gIGNvbnN0IHggPSBkYXR1bS5wb2ludC54IC0gcmFkaXVzO1xuICBjb25zdCB5ID0gZGF0dW0ucG9pbnQueSAtIHJhZGl1cztcbiAgcmV0dXJuIFRyYW5zZm9ybWFibGUudG9DYW52YXMoc2VyaWVzLmNvbnRlbnRHcm91cCwgbmV3IEJCb3goeCwgeSwgc2l6ZSwgc2l6ZSkpO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2xpbmVQbG90dGVyLnRzXG5mdW5jdGlvbiBwbG90TGluZWFyUG9pbnRzKHBhdGgsIHBvaW50cywgY29udGludWVQYXRoKSB7XG4gIGxldCBkaWRNb3ZlID0gY29udGludWVQYXRoO1xuICBmb3IgKGNvbnN0IHsgeCwgeSB9IG9mIHBvaW50cykge1xuICAgIGlmIChkaWRNb3ZlKSB7XG4gICAgICBwYXRoLmxpbmVUbyh4LCB5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aC5tb3ZlVG8oeCwgeSk7XG4gICAgICBkaWRNb3ZlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cbnZhciBmbGF0bmVzc1JhdGlvMiA9IDAuMDU7XG5mdW5jdGlvbiBwbG90U21vb3RoUG9pbnRzKHBhdGgsIGlQb2ludHMsIHRlbnNpb24sIGNvbnRpbnVlUGF0aCkge1xuICBjb25zdCBwb2ludHMgPSBBcnJheS5pc0FycmF5KGlQb2ludHMpID8gaVBvaW50cyA6IEFycmF5LmZyb20oaVBvaW50cyk7XG4gIGlmIChwb2ludHMubGVuZ3RoID09PSAwKVxuICAgIHJldHVybjtcbiAgaWYgKGNvbnRpbnVlUGF0aCkge1xuICAgIHBhdGgubGluZVRvKHBvaW50c1swXS54LCBwb2ludHNbMF0ueSk7XG4gIH0gZWxzZSB7XG4gICAgcGF0aC5tb3ZlVG8ocG9pbnRzWzBdLngsIHBvaW50c1swXS55KTtcbiAgfVxuICBpZiAocG9pbnRzLmxlbmd0aCA8PSAxKVxuICAgIHJldHVybjtcbiAgY29uc3QgZ3JhZGllbnRzID0gcG9pbnRzLm1hcCgoYywgaSkgPT4ge1xuICAgIGNvbnN0IHAgPSBpID09PSAwID8gYyA6IHBvaW50c1tpIC0gMV07XG4gICAgY29uc3QgbiA9IGkgPT09IHBvaW50cy5sZW5ndGggLSAxID8gYyA6IHBvaW50c1tpICsgMV07XG4gICAgY29uc3QgaXNUZXJtaW5hbFBvaW50ID0gaSA9PT0gMCB8fCBpID09PSBwb2ludHMubGVuZ3RoIC0gMTtcbiAgICBpZiAoTWF0aC5zaWduKHAueSAtIGMueSkgPT09IE1hdGguc2lnbihuLnkgLSBjLnkpKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgaWYgKCFpc1Rlcm1pbmFsUG9pbnQpIHtcbiAgICAgIGNvbnN0IHJhbmdlMyA9IE1hdGguYWJzKHAueSAtIG4ueSk7XG4gICAgICBjb25zdCBwcmV2UmF0aW8gPSBNYXRoLmFicyhjLnkgLSBwLnkpIC8gcmFuZ2UzO1xuICAgICAgY29uc3QgbmV4dFJhdGlvID0gTWF0aC5hYnMoYy55IC0gbi55KSAvIHJhbmdlMztcbiAgICAgIGlmIChwcmV2UmF0aW8gPD0gZmxhdG5lc3NSYXRpbzIgfHwgMSAtIHByZXZSYXRpbyA8PSBmbGF0bmVzc1JhdGlvMiB8fCBuZXh0UmF0aW8gPD0gZmxhdG5lc3NSYXRpbzIgfHwgMSAtIG5leHRSYXRpbyA8PSBmbGF0bmVzc1JhdGlvMikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIChuLnkgLSBwLnkpIC8gKG4ueCAtIHAueCk7XG4gIH0pO1xuICBpZiAoZ3JhZGllbnRzWzFdID09PSAwKSB7XG4gICAgZ3JhZGllbnRzWzBdICo9IDI7XG4gIH1cbiAgaWYgKGdyYWRpZW50c1tncmFkaWVudHMubGVuZ3RoIC0gMl0gPT09IDApIHtcbiAgICBncmFkaWVudHNbZ3JhZGllbnRzLmxlbmd0aCAtIDFdICo9IDI7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBwb2ludHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBjb25zdCBwcmV2ID0gcG9pbnRzW2kgLSAxXTtcbiAgICBjb25zdCBwcmV2TSA9IGdyYWRpZW50c1tpIC0gMV07XG4gICAgY29uc3QgY3VyID0gcG9pbnRzW2ldO1xuICAgIGNvbnN0IGN1ck0gPSBncmFkaWVudHNbaV07XG4gICAgY29uc3QgZHggPSBjdXIueCAtIHByZXYueDtcbiAgICBjb25zdCBkeSA9IGN1ci55IC0gcHJldi55O1xuICAgIGxldCBkY3AxeCA9IGR4ICogdGVuc2lvbiAvIDM7XG4gICAgbGV0IGRjcDF5ID0gZHggKiBwcmV2TSAqIHRlbnNpb24gLyAzO1xuICAgIGxldCBkY3AyeCA9IGR4ICogdGVuc2lvbiAvIDM7XG4gICAgbGV0IGRjcDJ5ID0gZHggKiBjdXJNICogdGVuc2lvbiAvIDM7XG4gICAgaWYgKGN1ck0gPT09IDAgJiYgTWF0aC5hYnMoZGNwMXkpID4gTWF0aC5hYnMoZHkpKSB7XG4gICAgICBkY3AxeCAqPSBNYXRoLmFicyhkeSAvIGRjcDF5KTtcbiAgICAgIGRjcDF5ID0gTWF0aC5zaWduKGRjcDF5KSAqIE1hdGguYWJzKGR5KTtcbiAgICB9XG4gICAgaWYgKHByZXZNID09PSAwICYmIE1hdGguYWJzKGRjcDJ5KSA+IE1hdGguYWJzKGR5KSkge1xuICAgICAgZGNwMnggKj0gTWF0aC5hYnMoZHkgLyBkY3AyeSk7XG4gICAgICBkY3AyeSA9IE1hdGguc2lnbihkY3AyeSkgKiBNYXRoLmFicyhkeSk7XG4gICAgfVxuICAgIHBhdGguY3ViaWNDdXJ2ZVRvKHByZXYueCArIGRjcDF4LCBwcmV2LnkgKyBkY3AxeSwgY3VyLnggLSBkY3AyeCwgY3VyLnkgLSBkY3AyeSwgY3VyLngsIGN1ci55KTtcbiAgfVxufVxuZnVuY3Rpb24gcGxvdFN0ZXBQb2ludHMocGF0aCwgcG9pbnRzLCBhbGlnbiwgY29udGludWVQYXRoKSB7XG4gIGxldCBsYXN0UG9pbnQ7XG4gIGZvciAoY29uc3QgcG9pbnQgb2YgcG9pbnRzKSB7XG4gICAgaWYgKGxhc3RQb2ludCAhPSBudWxsKSB7XG4gICAgICBjb25zdCBkaXJlY3Rpb25hbEFsaWduID0gbGFzdFBvaW50LnggPCBwb2ludC54ID8gYWxpZ24gOiAxIC0gYWxpZ247XG4gICAgICBjb25zdCB4ID0gKHBvaW50LnggLSBsYXN0UG9pbnQueCkgKiBkaXJlY3Rpb25hbEFsaWduICsgbGFzdFBvaW50Lng7XG4gICAgICBwYXRoLmxpbmVUbyh4LCBsYXN0UG9pbnQ/LnkgPz8gcG9pbnQueSk7XG4gICAgICBwYXRoLmxpbmVUbyh4LCBwb2ludC55KTtcbiAgICAgIHBhdGgubGluZVRvKHBvaW50LngsIHBvaW50LnkpO1xuICAgIH0gZWxzZSBpZiAoY29udGludWVQYXRoKSB7XG4gICAgICBwYXRoLmxpbmVUbyhwb2ludC54LCBwb2ludC55KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aC5tb3ZlVG8ocG9pbnQueCwgcG9pbnQueSk7XG4gICAgfVxuICAgIGxhc3RQb2ludCA9IHBvaW50O1xuICB9XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vcGF0aFV0aWwudHNcbmZ1bmN0aW9uIG1pbk1heChub2RlRGF0YSkge1xuICByZXR1cm4gbm9kZURhdGEucmVkdWNlKFxuICAgICh7IG1pbiwgbWF4IH0sIG5vZGUpID0+IHtcbiAgICAgIGlmIChtaW4gPT0gbnVsbCB8fCBtaW4ucG9pbnQueCA+IG5vZGUucG9pbnQueCkge1xuICAgICAgICBtaW4gPSBub2RlO1xuICAgICAgfVxuICAgICAgaWYgKG1heCA9PSBudWxsIHx8IG1heC5wb2ludC54IDwgbm9kZS5wb2ludC54KSB7XG4gICAgICAgIG1heCA9IG5vZGU7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBtaW4sIG1heCB9O1xuICAgIH0sXG4gICAge31cbiAgKTtcbn1cbmZ1bmN0aW9uIGludGVyc2VjdGlvbk9uTGluZShhLCBiLCB0YXJnZXRYKSB7XG4gIGNvbnN0IG0gPSAoYi55IC0gYS55KSAvIChiLnggLSBhLngpO1xuICBjb25zdCB5ID0gKHRhcmdldFggLSBhLngpICogbSArIGEueTtcbiAgcmV0dXJuIHsgeDogdGFyZ2V0WCwgeSB9O1xufVxuZnVuY3Rpb24gYmFja2ZpbGxQYXRoUG9pbnQocmVzdWx0cywgcHJvY2Vzcywgc2tpcCwgcHJvY2Vzc0ZuKSB7XG4gIGxldCBwcmV2TWFya2VySWR4ID0gLTEsIG5leHRNYXJrZXJJZHggPSAwO1xuICBjb25zdCB0b1Byb2Nlc3MgPSBbXTtcbiAgd2hpbGUgKG5leHRNYXJrZXJJZHggPCByZXN1bHRzLmxlbmd0aCkge1xuICAgIGlmIChyZXN1bHRzW25leHRNYXJrZXJJZHhdLmNoYW5nZSA9PT0gcHJvY2Vzcykge1xuICAgICAgdG9Qcm9jZXNzLnB1c2gocmVzdWx0c1tuZXh0TWFya2VySWR4XSk7XG4gICAgICBuZXh0TWFya2VySWR4Kys7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdHNbbmV4dE1hcmtlcklkeF0uY2hhbmdlID09PSBza2lwKSB7XG4gICAgICBuZXh0TWFya2VySWR4Kys7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHRvUHJvY2Vzcy5sZW5ndGggPiAwKSB7XG4gICAgICBwcm9jZXNzRm4odG9Qcm9jZXNzLCBwcmV2TWFya2VySWR4LCBuZXh0TWFya2VySWR4KTtcbiAgICAgIHRvUHJvY2Vzcy5sZW5ndGggPSAwO1xuICAgIH1cbiAgICBwcmV2TWFya2VySWR4ID0gbmV4dE1hcmtlcklkeDtcbiAgICBuZXh0TWFya2VySWR4Kys7XG4gIH1cbiAgaWYgKHRvUHJvY2Vzcy5sZW5ndGggPiAwKSB7XG4gICAgcHJvY2Vzc0ZuKHRvUHJvY2VzcywgcHJldk1hcmtlcklkeCwgbmV4dE1hcmtlcklkeCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGJhY2tmaWxsUGF0aFBvaW50RGF0YShyZXN1bHQsIHNwbGl0TW9kZSkge1xuICBiYWNrZmlsbFBhdGhQb2ludChyZXN1bHQsIFwib3V0XCIsIFwiaW5cIiwgKHRvUHJvY2Vzcywgc0lkeCwgZUlkeCkgPT4ge1xuICAgIGlmIChzSWR4ID09PSAtMSAmJiByZXN1bHRbZUlkeF0pIHtcbiAgICAgIHRvUHJvY2Vzcy5mb3JFYWNoKChkKSA9PiBkLnRvID0gcmVzdWx0W2VJZHhdLmZyb20pO1xuICAgIH0gZWxzZSBpZiAoZUlkeCA9PT0gcmVzdWx0Lmxlbmd0aCAmJiByZXN1bHRbc0lkeF0pIHtcbiAgICAgIHRvUHJvY2Vzcy5mb3JFYWNoKChkKSA9PiBkLnRvID0gcmVzdWx0W3NJZHhdLmZyb20pO1xuICAgIH0gZWxzZSBpZiAoc3BsaXRNb2RlID09PSBcImludGVyc2VjdFwiICYmIHJlc3VsdFtzSWR4XT8uZnJvbSAmJiByZXN1bHRbZUlkeF0/LmZyb20pIHtcbiAgICAgIHRvUHJvY2Vzcy5mb3JFYWNoKChkKSA9PiBkLnRvID0gaW50ZXJzZWN0aW9uT25MaW5lKHJlc3VsdFtzSWR4XS5mcm9tLCByZXN1bHRbZUlkeF0uZnJvbSwgZC5mcm9tLngpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9Qcm9jZXNzLmZvckVhY2goKGQpID0+IGQudG8gPSBkLmZyb20pO1xuICAgIH1cbiAgfSk7XG4gIGJhY2tmaWxsUGF0aFBvaW50KHJlc3VsdCwgXCJpblwiLCBcIm91dFwiLCAodG9Qcm9jZXNzLCBzSWR4LCBlSWR4KSA9PiB7XG4gICAgaWYgKHNJZHggPT09IC0xICYmIHJlc3VsdFtlSWR4XSkge1xuICAgICAgdG9Qcm9jZXNzLmZvckVhY2goKGQpID0+IGQuZnJvbSA9IHJlc3VsdFtlSWR4XS50byk7XG4gICAgfSBlbHNlIGlmIChlSWR4ID09PSByZXN1bHQubGVuZ3RoICYmIHJlc3VsdFtzSWR4XSkge1xuICAgICAgdG9Qcm9jZXNzLmZvckVhY2goKGQpID0+IGQuZnJvbSA9IHJlc3VsdFtzSWR4XS50byk7XG4gICAgfSBlbHNlIGlmIChzcGxpdE1vZGUgPT09IFwiaW50ZXJzZWN0XCIgJiYgcmVzdWx0W3NJZHhdPy50byAmJiByZXN1bHRbZUlkeF0/LnRvKSB7XG4gICAgICB0b1Byb2Nlc3MuZm9yRWFjaCgoZCkgPT4gZC5mcm9tID0gaW50ZXJzZWN0aW9uT25MaW5lKHJlc3VsdFtzSWR4XS50bywgcmVzdWx0W2VJZHhdLnRvLCBkLnRvLngpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9Qcm9jZXNzLmZvckVhY2goKGQpID0+IGQuZnJvbSA9IGQudG8pO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVQb2ludChmcm9tMywgdG8sIHJhdGlvMikge1xuICBjb25zdCB4MSA9IGlzTmFOKGZyb20zLngpID8gdG8ueCA6IGZyb20zLng7XG4gIGNvbnN0IHkxID0gaXNOYU4oZnJvbTMueSkgPyB0by55IDogZnJvbTMueTtcbiAgY29uc3QgeGQgPSB0by54IC0gZnJvbTMueDtcbiAgY29uc3QgeWQgPSB0by55IC0gZnJvbTMueTtcbiAgY29uc3QgeHIgPSBpc05hTih4ZCkgPyAwIDogeGQgKiByYXRpbzI7XG4gIGNvbnN0IHlyID0gaXNOYU4oeWQpID8gMCA6IHlkICogcmF0aW8yO1xuICByZXR1cm4ge1xuICAgIHg6IHgxICsgeHIsXG4gICAgeTogeTEgKyB5clxuICB9O1xufVxudmFyIGxpbmVTdGVwczIgPSB7XG4gIHN0YXJ0OiAwLFxuICBtaWRkbGU6IDAuNSxcbiAgZW5kOiAxXG59O1xuZnVuY3Rpb24gcGxvdFBhdGgocG9pbnRzLCBwYXRoLCBpbnRlcnBvbGF0aW9uLCBjb250aW51ZVBhdGggPSBmYWxzZSkge1xuICBjb25zdCB7IHBhdGg6IGxpbmVQYXRoIH0gPSBwYXRoO1xuICBpZiAoaW50ZXJwb2xhdGlvbj8udHlwZSA9PT0gXCJzbW9vdGhcIikge1xuICAgIHBsb3RTbW9vdGhQb2ludHMobGluZVBhdGgsIHBvaW50cywgaW50ZXJwb2xhdGlvbi50ZW5zaW9uID8/IDEsIGNvbnRpbnVlUGF0aCk7XG4gIH0gZWxzZSBpZiAoaW50ZXJwb2xhdGlvbj8udHlwZSA9PT0gXCJzdGVwXCIpIHtcbiAgICBwbG90U3RlcFBvaW50cyhsaW5lUGF0aCwgcG9pbnRzLCBsaW5lU3RlcHMyW2ludGVycG9sYXRpb24ucG9zaXRpb24gPz8gXCJlbmRcIl0sIGNvbnRpbnVlUGF0aCk7XG4gIH0gZWxzZSB7XG4gICAgcGxvdExpbmVhclBvaW50cyhsaW5lUGF0aCwgcG9pbnRzLCBjb250aW51ZVBhdGgpO1xuICB9XG59XG5mdW5jdGlvbiBzcGxpdFBhaXJEYXRhKHBhaXJEYXRhLCByYXRpb3MpIHtcbiAgbGV0IHByZXZpb3VzVG87XG4gIGxldCBwb2ludHMgPSB2b2lkIDA7XG4gIGNvbnN0IG91dCA9IFtdO1xuICBjb25zdCBmbHVzaEN1cnJlbnQgPSAoKSA9PiB7XG4gICAgaWYgKHBvaW50cyAhPSBudWxsKSB7XG4gICAgICBvdXQucHVzaChwb2ludHMpO1xuICAgICAgcG9pbnRzID0gdm9pZCAwO1xuICAgIH1cbiAgfTtcbiAgZm9yIChjb25zdCBkYXRhIG9mIHBhaXJEYXRhKSB7XG4gICAgY29uc3QgeyBmcm9tOiBmcm9tMywgdG8gfSA9IGRhdGE7XG4gICAgY29uc3QgcmF0aW8yID0gcmF0aW9zW2RhdGEuY2hhbmdlXTtcbiAgICBpZiAocmF0aW8yID09IG51bGwgfHwgZnJvbTMgPT0gbnVsbCB8fCB0byA9PSBudWxsKVxuICAgICAgY29udGludWU7XG4gICAgY29uc3QgcG9pbnQgPSBjYWxjdWxhdGVQb2ludChmcm9tMywgdG8sIHJhdGlvMik7XG4gICAgaWYgKGRhdGEubW92ZVRvID09PSBmYWxzZSkge1xuICAgICAgcG9pbnRzID8/IChwb2ludHMgPSBbXSk7XG4gICAgICBwb2ludHMucHVzaChwb2ludCk7XG4gICAgfSBlbHNlIGlmIChkYXRhLm1vdmVUbyA9PT0gdHJ1ZSB8fCAhcHJldmlvdXNUbykge1xuICAgICAgZmx1c2hDdXJyZW50KCk7XG4gICAgICBwb2ludHMgPSBbcG9pbnRdO1xuICAgIH0gZWxzZSBpZiAocHJldmlvdXNUbykge1xuICAgICAgY29uc3QgbW92ZVRvUmF0aW8gPSBkYXRhLm1vdmVUbyA9PT0gXCJpblwiID8gcmF0aW8yIDogMSAtIHJhdGlvMjtcbiAgICAgIGNvbnN0IHsgeDogbWlkUG9pbnRYLCB5OiBtaWRQb2ludFkgfSA9IGNhbGN1bGF0ZVBvaW50KHByZXZpb3VzVG8sIHBvaW50LCBtb3ZlVG9SYXRpbyk7XG4gICAgICBwb2ludHMgPz8gKHBvaW50cyA9IFtdKTtcbiAgICAgIHBvaW50cy5wdXNoKHsgeDogbWlkUG9pbnRYLCB5OiBtaWRQb2ludFkgfSk7XG4gICAgICBmbHVzaEN1cnJlbnQoKTtcbiAgICAgIHBvaW50cyA9IFtwb2ludF07XG4gICAgfVxuICAgIHByZXZpb3VzVG8gPSBwb2ludDtcbiAgfVxuICBmbHVzaEN1cnJlbnQoKTtcbiAgcmV0dXJuIG91dDtcbn1cbmZ1bmN0aW9uIHJlbmRlclBhcnRpYWxQYXRoKHBhaXJEYXRhLCByYXRpb3MsIHBhdGgsIGludGVycG9sYXRpb24pIHtcbiAgc3BsaXRQYWlyRGF0YShwYWlyRGF0YSwgcmF0aW9zKS5mb3JFYWNoKChwb2ludHMpID0+IHtcbiAgICBwbG90UGF0aChwb2ludHMsIHBhdGgsIGludGVycG9sYXRpb24pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHBhdGhTd2lwZUluQW5pbWF0aW9uKHsgaWQsIHZpc2libGUsIG5vZGVEYXRhRGVwZW5kZW5jaWVzIH0sIGFuaW1hdGlvbk1hbmFnZXIsIC4uLnBhdGhzKSB7XG4gIGNvbnN0IHsgc2VyaWVzUmVjdFdpZHRoOiB3aWR0aDIsIHNlcmllc1JlY3RIZWlnaHQ6IGhlaWdodDIgfSA9IG5vZGVEYXRhRGVwZW5kZW5jaWVzO1xuICBzdGF0aWNGcm9tVG9Nb3Rpb24oXG4gICAgaWQsXG4gICAgXCJwYXRoX3Byb3BlcnRpZXNcIixcbiAgICBhbmltYXRpb25NYW5hZ2VyLFxuICAgIHBhdGhzLFxuICAgIHsgY2xpcFg6IDAgfSxcbiAgICB7IGNsaXBYOiB3aWR0aDIgfSxcbiAgICB7XG4gICAgICBwaGFzZTogXCJpbml0aWFsXCIsXG4gICAgICBzdGFydDogeyBjbGlwOiB0cnVlLCBjbGlwWTogaGVpZ2h0MiwgdmlzaWJsZSB9LFxuICAgICAgZmluaXNoOiB7IGNsaXA6IGZhbHNlLCB2aXNpYmxlIH1cbiAgICB9XG4gICk7XG59XG5mdW5jdGlvbiBwYXRoRmFkZUluQW5pbWF0aW9uKHsgaWQgfSwgc3ViSWQsIGFuaW1hdGlvbk1hbmFnZXIsIHBoYXNlID0gXCJhZGRcIiwgLi4uc2VsZWN0aW9uKSB7XG4gIHN0YXRpY0Zyb21Ub01vdGlvbihpZCwgc3ViSWQsIGFuaW1hdGlvbk1hbmFnZXIsIHNlbGVjdGlvbiwgeyBvcGFjaXR5OiAwIH0sIHsgb3BhY2l0eTogMSB9LCB7IHBoYXNlIH0pO1xufVxuZnVuY3Rpb24gcGF0aEZhZGVPdXRBbmltYXRpb24oeyBpZCB9LCBzdWJJZCwgYW5pbWF0aW9uTWFuYWdlciwgLi4uc2VsZWN0aW9uKSB7XG4gIHN0YXRpY0Zyb21Ub01vdGlvbihpZCwgc3ViSWQsIGFuaW1hdGlvbk1hbmFnZXIsIHNlbGVjdGlvbiwgeyBvcGFjaXR5OiAxIH0sIHsgb3BhY2l0eTogMCB9LCB7IHBoYXNlOiBcInJlbW92ZVwiIH0pO1xufVxuZnVuY3Rpb24gYnVpbGRSZXNldFBhdGhGbihvcHRzKSB7XG4gIHJldHVybiAoX25vZGUpID0+ICh7XG4gICAgdmlzaWJsZTogb3B0cy5nZXRWaXNpYmxlKCksXG4gICAgb3BhY2l0eTogb3B0cy5nZXRPcGFjaXR5KCksXG4gICAgY2xpcFNjYWxpbmdYOiAxLFxuICAgIGNsaXA6IGZhbHNlXG4gIH0pO1xufVxuZnVuY3Rpb24gdXBkYXRlQ2xpcFBhdGgoeyBub2RlRGF0YURlcGVuZGVuY2llcyB9LCBwYXRoKSB7XG4gIGNvbnN0IHRvRmluaXRlID0gKHZhbHVlKSA9PiBpc0Zpbml0ZSh2YWx1ZSkgPyB2YWx1ZSA6IDA7XG4gIHBhdGguY2xpcFggPSB0b0Zpbml0ZShub2RlRGF0YURlcGVuZGVuY2llcy5zZXJpZXNSZWN0V2lkdGgpO1xuICBwYXRoLmNsaXBZID0gdG9GaW5pdGUobm9kZURhdGFEZXBlbmRlbmNpZXMuc2VyaWVzUmVjdEhlaWdodCk7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vc2NhbGluZy50c1xuZnVuY3Rpb24gaXNDb250aW51b3VzU2NhbGluZyhzY2FsaW5nKSB7XG4gIHJldHVybiBzY2FsaW5nLnR5cGUgPT09IFwiY29udGludW91c1wiIHx8IHNjYWxpbmcudHlwZSA9PT0gXCJsb2dcIjtcbn1cbmZ1bmN0aW9uIGlzQ2F0ZWdvcnlTY2FsaW5nKHNjYWxpbmcpIHtcbiAgcmV0dXJuIHNjYWxpbmcudHlwZSA9PT0gXCJjYXRlZ29yeVwiO1xufVxuZnVuY3Rpb24gYXJlRXF1YWwoYSwgYikge1xuICByZXR1cm4gYS5kb21haW4ubGVuZ3RoID09PSBiLmRvbWFpbi5sZW5ndGggJiYgYS5yYW5nZS5sZW5ndGggPT09IGIucmFuZ2UubGVuZ3RoICYmIGEuZG9tYWluLmV2ZXJ5KCh2YWwsIGluZGV4KSA9PiB2YWwgPT09IGIuZG9tYWluW2luZGV4XSkgJiYgYS5yYW5nZS5ldmVyeSgodmFsLCBpbmRleCkgPT4gdmFsID09PSBiLnJhbmdlW2luZGV4XSk7XG59XG5mdW5jdGlvbiBhcmVTY2FsaW5nRXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gdm9pZCAwIHx8IGIgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiBhICE9PSB2b2lkIDAgfHwgYiAhPT0gdm9pZCAwO1xuICB9XG4gIGlmIChpc0NvbnRpbnVvdXNTY2FsaW5nKGEpICYmIGlzQ29udGludW91c1NjYWxpbmcoYikpIHtcbiAgICByZXR1cm4gYS50eXBlID09PSBiLnR5cGUgJiYgYXJlRXF1YWwoYSwgYik7XG4gIH1cbiAgaWYgKGlzQ2F0ZWdvcnlTY2FsaW5nKGEpICYmIGlzQ2F0ZWdvcnlTY2FsaW5nKGIpKSB7XG4gICAgcmV0dXJuIGFyZUVxdWFsKGEsIGIpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzU2NhbGVWYWxpZChzY2FsZTIpIHtcbiAgaWYgKHNjYWxlMiA9PSBudWxsKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKCFzY2FsZTIucmFuZ2UuZXZlcnkoKHYpID0+IE51bWJlci5pc0Zpbml0ZSh2KSkpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoc2NhbGUyLnR5cGUgPT09IFwiY2F0ZWdvcnlcIikge1xuICAgIHJldHVybiBzY2FsZTIuZG9tYWluLmV2ZXJ5KCh2KSA9PiB2ICE9IG51bGwpO1xuICB9XG4gIHJldHVybiBzY2FsZTIuZG9tYWluLmV2ZXJ5KCh2KSA9PiBOdW1iZXIuaXNGaW5pdGUodikgfHwgdiBpbnN0YW5jZW9mIERhdGUpO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2xpbmVVdGlsLnRzXG5mdW5jdGlvbiogcGF0aFJhbmdlcyhwb2ludHMpIHtcbiAgbGV0IHN0YXJ0MiA9IC0xO1xuICBsZXQgZW5kMiA9IDA7XG4gIGZvciAoY29uc3QgeyBwb2ludCB9IG9mIHBvaW50cykge1xuICAgIGlmIChwb2ludC5tb3ZlVG8pIHtcbiAgICAgIGNvbnN0IHJhbmdlMyA9IHN0YXJ0MiA+PSAwID8geyBzdGFydDogc3RhcnQyLCBlbmQ6IGVuZDIgfSA6IHZvaWQgMDtcbiAgICAgIHN0YXJ0MiA9IGVuZDI7XG4gICAgICBlbmQyID0gc3RhcnQyO1xuICAgICAgaWYgKHJhbmdlMyAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHlpZWxkIHJhbmdlMztcbiAgICAgIH1cbiAgICB9XG4gICAgZW5kMiArPSAxO1xuICB9XG4gIGlmIChzdGFydDIgIT09IC0xKSB7XG4gICAgeWllbGQgeyBzdGFydDogc3RhcnQyLCBlbmQ6IGVuZDIgfTtcbiAgfVxufVxuZnVuY3Rpb24qIHBhdGhSYW5nZVBvaW50cyhwb2ludHMsIHsgc3RhcnQ6IHN0YXJ0MiwgZW5kOiBlbmQyIH0pIHtcbiAgZm9yIChsZXQgaSA9IHN0YXJ0MjsgaSA8IGVuZDI7IGkgKz0gMSkge1xuICAgIHlpZWxkIHBvaW50c1tpXS5wb2ludDtcbiAgfVxufVxuZnVuY3Rpb24qIHBhdGhSYW5nZVBvaW50c1JldmVyc2UocG9pbnRzLCB7IHN0YXJ0OiBzdGFydDIsIGVuZDogZW5kMiB9KSB7XG4gIGZvciAobGV0IGkgPSBlbmQyIC0gMTsgaSA+PSBzdGFydDI7IGkgLT0gMSkge1xuICAgIHlpZWxkIHBvaW50c1tpXS5wb2ludDtcbiAgfVxufVxuZnVuY3Rpb24gaW50ZWdyYXRlZENhdGVnb3J5TWF0Y2goYSwgYikge1xuICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbClcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgYSAhPT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgYiAhPT0gXCJvYmplY3RcIilcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChcImlkXCIgaW4gYSAmJiBcImlkXCIgaW4gYikge1xuICAgIHJldHVybiBhLmlkID09PSBiLmlkO1xuICB9XG4gIHJldHVybiBhLnRvU3RyaW5nKCkgPT09IGIudG9TdHJpbmcoKTtcbn1cbmZ1bmN0aW9uIHNjYWxlKHZhbCwgc2NhbGluZykge1xuICBpZiAoIXNjYWxpbmcpXG4gICAgcmV0dXJuIE5hTjtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICB2YWwgPSB2YWwuZ2V0VGltZSgpO1xuICB9XG4gIGlmIChzY2FsaW5nLnR5cGUgPT09IFwiY29udGludW91c1wiICYmIHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIpIHtcbiAgICBjb25zdCBkb21haW5SYXRpbyA9ICh2YWwgLSBzY2FsaW5nLmRvbWFpblswXSkgLyAoc2NhbGluZy5kb21haW5bMV0gLSBzY2FsaW5nLmRvbWFpblswXSk7XG4gICAgcmV0dXJuIGRvbWFpblJhdGlvICogKHNjYWxpbmcucmFuZ2VbMV0gLSBzY2FsaW5nLnJhbmdlWzBdKSArIHNjYWxpbmcucmFuZ2VbMF07XG4gIH1cbiAgaWYgKHNjYWxpbmcudHlwZSA9PT0gXCJsb2dcIiAmJiB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIHNjYWxpbmcuY29udmVydCh2YWwpO1xuICB9XG4gIGNvbnN0IG1hdGNoaW5nSW5kZXggPSBzY2FsaW5nLmRvbWFpbi5maW5kSW5kZXgoKGQpID0+IGQgPT09IHZhbCk7XG4gIGlmIChtYXRjaGluZ0luZGV4ID49IDApIHtcbiAgICByZXR1cm4gc2NhbGluZy5yYW5nZVttYXRjaGluZ0luZGV4XTtcbiAgfVxuICBjb25zdCBtYXRjaGluZ0ludGVncmF0ZWRJbmRleCA9IHNjYWxpbmcuZG9tYWluLmZpbmRJbmRleCgoZCkgPT4gaW50ZWdyYXRlZENhdGVnb3J5TWF0Y2godmFsLCBkKSk7XG4gIGlmIChtYXRjaGluZ0ludGVncmF0ZWRJbmRleCA+PSAwKSB7XG4gICAgcmV0dXJuIHNjYWxpbmcucmFuZ2VbbWF0Y2hpbmdJbnRlZ3JhdGVkSW5kZXhdO1xuICB9XG4gIHJldHVybiBOYU47XG59XG5mdW5jdGlvbiBzY2FsZXNDaGFuZ2VkKG5ld0RhdGEsIG9sZERhdGEpIHtcbiAgcmV0dXJuICFhcmVTY2FsaW5nRXF1YWwobmV3RGF0YS5zY2FsZXMueCwgb2xkRGF0YS5zY2FsZXMueCkgfHwgIWFyZVNjYWxpbmdFcXVhbChuZXdEYXRhLnNjYWxlcy55LCBvbGREYXRhLnNjYWxlcy55KTtcbn1cbmZ1bmN0aW9uIGNsb3NlTWF0Y2goYSwgYikge1xuICBjb25zdCBhbiA9IE51bWJlcihhKTtcbiAgY29uc3QgYm4gPSBOdW1iZXIoYik7XG4gIGlmICghaXNOYU4oYW4pICYmICFpc05hTihibikpIHtcbiAgICByZXR1cm4gTWF0aC5hYnMoYm4gLSBhbikgPCAwLjI1O1xuICB9XG4gIHJldHVybiBhID09PSBiO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlTW92ZVRvKGZyb20zID0gZmFsc2UsIHRvID0gZmFsc2UpIHtcbiAgaWYgKGZyb20zID09PSB0bykge1xuICAgIHJldHVybiBCb29sZWFuKGZyb20zKTtcbiAgfVxuICByZXR1cm4gZnJvbTMgPyBcImluXCIgOiBcIm91dFwiO1xufVxuZnVuY3Rpb24gcGFpckNvbnRpbnVvdXNEYXRhKG5ld0RhdGEsIG9sZERhdGEsIG9wdHMgPSB7fSkge1xuICBjb25zdCB7IGJhY2tmaWxsU3BsaXRNb2RlID0gXCJpbnRlcnNlY3RcIiB9ID0gb3B0cztcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGNvbnN0IHJlc3VsdE1hcCA9IHtcbiAgICBhZGRlZDoge30sXG4gICAgbW92ZWQ6IHt9LFxuICAgIHJlbW92ZWQ6IHt9XG4gIH07XG4gIGNvbnN0IHBhaXJVcCA9IChmcm9tMywgdG8sIHhWYWx1ZSwgY2hhbmdlID0gXCJtb3ZlXCIpID0+IHtcbiAgICBpZiAoZnJvbTMgJiYgKGlzTmFOKGZyb20zLnBvaW50LngpIHx8IGlzTmFOKGZyb20zLnBvaW50LnkpKSkge1xuICAgICAgZnJvbTMgPSB0bztcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0UG9pbnQgPSB7XG4gICAgICBmcm9tOiBmcm9tMz8ucG9pbnQsXG4gICAgICB0bzogdG8/LnBvaW50LFxuICAgICAgbW92ZVRvOiBjYWxjdWxhdGVNb3ZlVG8oZnJvbTM/LnBvaW50Lm1vdmVUbywgdG8/LnBvaW50Lm1vdmVUbyksXG4gICAgICBjaGFuZ2VcbiAgICB9O1xuICAgIGlmIChjaGFuZ2UgPT09IFwibW92ZVwiKSB7XG4gICAgICByZXN1bHRNYXAubW92ZWRbeFZhbHVlXSA9IHJlc3VsdFBvaW50O1xuICAgICAgb2xkSWR4Kys7XG4gICAgICBuZXdJZHgrKztcbiAgICB9IGVsc2UgaWYgKGNoYW5nZSA9PT0gXCJpblwiKSB7XG4gICAgICByZXN1bHRNYXAuYWRkZWRbeFZhbHVlXSA9IHJlc3VsdFBvaW50O1xuICAgICAgbmV3SWR4Kys7XG4gICAgfSBlbHNlIGlmIChjaGFuZ2UgPT09IFwib3V0XCIpIHtcbiAgICAgIHJlc3VsdE1hcC5yZW1vdmVkW3hWYWx1ZV0gPSByZXN1bHRQb2ludDtcbiAgICAgIG9sZElkeCsrO1xuICAgIH1cbiAgICByZXN1bHQucHVzaChyZXN1bHRQb2ludCk7XG4gIH07XG4gIGNvbnN0IHsgbWluOiBtaW5Gcm9tTm9kZSwgbWF4OiBtYXhGcm9tTm9kZSB9ID0gbWluTWF4KG9sZERhdGEubm9kZURhdGEpO1xuICBjb25zdCB7IG1pbjogbWluVG9Ob2RlLCBtYXg6IG1heFRvTm9kZSB9ID0gbWluTWF4KG5ld0RhdGEubm9kZURhdGEpO1xuICBsZXQgb2xkSWR4ID0gMDtcbiAgbGV0IG5ld0lkeCA9IDA7XG4gIHdoaWxlIChvbGRJZHggPCBvbGREYXRhLm5vZGVEYXRhLmxlbmd0aCB8fCBuZXdJZHggPCBuZXdEYXRhLm5vZGVEYXRhLmxlbmd0aCkge1xuICAgIGNvbnN0IGZyb20zID0gb2xkRGF0YS5ub2RlRGF0YVtvbGRJZHhdO1xuICAgIGNvbnN0IHRvID0gbmV3RGF0YS5ub2RlRGF0YVtuZXdJZHhdO1xuICAgIGNvbnN0IGZyb21TaGlmdGVkID0gZnJvbTMgPyBzY2FsZShmcm9tMy54VmFsdWUgPz8gTmFOLCBuZXdEYXRhLnNjYWxlcy54KSA6IHZvaWQgMDtcbiAgICBjb25zdCB0b1Vuc2hpZnRlZCA9IHRvID8gc2NhbGUodG8ueFZhbHVlID8/IE5hTiwgb2xkRGF0YS5zY2FsZXMueCkgOiB2b2lkIDA7XG4gICAgY29uc3QgTkEgPSB2b2lkIDA7XG4gICAgaWYgKGZyb21TaGlmdGVkICE9IG51bGwgJiYgY2xvc2VNYXRjaChmcm9tU2hpZnRlZCwgdG8/LnBvaW50LngpKSB7XG4gICAgICBwYWlyVXAoZnJvbTMsIHRvLCB0by54VmFsdWUsIFwibW92ZVwiKTtcbiAgICB9IGVsc2UgaWYgKGZyb21TaGlmdGVkICE9IG51bGwgJiYgZnJvbVNoaWZ0ZWQgPCAobWluVG9Ob2RlPy5wb2ludC54ID8/IC1JbmZpbml0eSkpIHtcbiAgICAgIHBhaXJVcChmcm9tMywgTkEsIGZyb20zLnhWYWx1ZSwgXCJvdXRcIik7XG4gICAgfSBlbHNlIGlmIChmcm9tU2hpZnRlZCAhPSBudWxsICYmIGZyb21TaGlmdGVkID4gKG1heFRvTm9kZT8ucG9pbnQueCA/PyBJbmZpbml0eSkpIHtcbiAgICAgIHBhaXJVcChmcm9tMywgTkEsIGZyb20zLnhWYWx1ZSwgXCJvdXRcIik7XG4gICAgfSBlbHNlIGlmICh0b1Vuc2hpZnRlZCAhPSBudWxsICYmIHRvVW5zaGlmdGVkIDwgKG1pbkZyb21Ob2RlPy5wb2ludC54ID8/IC1JbmZpbml0eSkpIHtcbiAgICAgIHBhaXJVcChOQSwgdG8sIHRvLnhWYWx1ZSwgXCJpblwiKTtcbiAgICB9IGVsc2UgaWYgKHRvVW5zaGlmdGVkICE9IG51bGwgJiYgdG9VbnNoaWZ0ZWQgPiAobWF4RnJvbU5vZGU/LnBvaW50LnggPz8gSW5maW5pdHkpKSB7XG4gICAgICBwYWlyVXAoTkEsIHRvLCB0by54VmFsdWUsIFwiaW5cIik7XG4gICAgfSBlbHNlIGlmIChmcm9tU2hpZnRlZCAhPSBudWxsICYmIGZyb21TaGlmdGVkIDwgdG8/LnBvaW50LngpIHtcbiAgICAgIHBhaXJVcChmcm9tMywgTkEsIGZyb20zLnhWYWx1ZSwgXCJvdXRcIik7XG4gICAgfSBlbHNlIGlmICh0b1Vuc2hpZnRlZCAhPSBudWxsICYmIHRvVW5zaGlmdGVkIDwgZnJvbTM/LnBvaW50LngpIHtcbiAgICAgIHBhaXJVcChOQSwgdG8sIHRvLnhWYWx1ZSwgXCJpblwiKTtcbiAgICB9IGVsc2UgaWYgKGZyb20zKSB7XG4gICAgICBwYWlyVXAoZnJvbTMsIE5BLCBmcm9tMy54VmFsdWUsIFwib3V0XCIpO1xuICAgIH0gZWxzZSBpZiAodG8pIHtcbiAgICAgIHBhaXJVcChOQSwgdG8sIHRvLnhWYWx1ZSwgXCJpblwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHByb2Nlc3MgcG9pbnRzXCIpO1xuICAgIH1cbiAgfVxuICBiYWNrZmlsbFBhdGhQb2ludERhdGEocmVzdWx0LCBiYWNrZmlsbFNwbGl0TW9kZSk7XG4gIHJldHVybiB7IHJlc3VsdCwgcmVzdWx0TWFwIH07XG59XG5mdW5jdGlvbiBwYWlyQ2F0ZWdvcnlEYXRhKG5ld0RhdGEsIG9sZERhdGEsIGRpZmYyLCBvcHRzID0ge30pIHtcbiAgY29uc3QgeyBiYWNrZmlsbFNwbGl0TW9kZSA9IFwiaW50ZXJzZWN0XCIsIG11bHRpRGF0dW0gPSBmYWxzZSB9ID0gb3B0cztcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGNvbnN0IHJlc3VsdE1hcFNpbmdsZSA9IHtcbiAgICBhZGRlZDoge30sXG4gICAgbW92ZWQ6IHt9LFxuICAgIHJlbW92ZWQ6IHt9XG4gIH07XG4gIGNvbnN0IHJlc3VsdE1hcE11bHRpID0ge1xuICAgIGFkZGVkOiB7fSxcbiAgICBtb3ZlZDoge30sXG4gICAgcmVtb3ZlZDoge31cbiAgfTtcbiAgY29uc3QgcG9pbnRSZXN1bHRNYXBwaW5nID0ge1xuICAgIGluOiBcImFkZGVkXCIsXG4gICAgbW92ZTogXCJtb3ZlZFwiLFxuICAgIG91dDogXCJyZW1vdmVkXCJcbiAgfTtcbiAgbGV0IHByZXZpb3VzUmVzdWx0UG9pbnQgPSB2b2lkIDA7XG4gIGxldCBwcmV2aW91c1hWYWx1ZSA9IHZvaWQgMDtcbiAgY29uc3QgYWRkVG9SZXN1bHRNYXAgPSAoeFZhbHVlLCBuZXdQb2ludCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB0eXBlID0gcG9pbnRSZXN1bHRNYXBwaW5nW25ld1BvaW50LmNoYW5nZV07XG4gICAgaWYgKG11bHRpRGF0dW0pIHtcbiAgICAgIChfYSA9IHJlc3VsdE1hcE11bHRpW3R5cGVdKVt4VmFsdWVdID8/IChfYVt4VmFsdWVdID0gW10pO1xuICAgICAgcmVzdWx0TWFwTXVsdGlbdHlwZV1beFZhbHVlXS5wdXNoKG5ld1BvaW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0TWFwU2luZ2xlW3R5cGVdW3hWYWx1ZV0gPSBuZXdQb2ludDtcbiAgICB9XG4gICAgcHJldmlvdXNSZXN1bHRQb2ludCA9IG5ld1BvaW50O1xuICAgIHByZXZpb3VzWFZhbHVlID0gdHJhbnNmb3JtSW50ZWdyYXRlZENhdGVnb3J5VmFsdWUoeFZhbHVlKTtcbiAgfTtcbiAgbGV0IG9sZEluZGV4ID0gMDtcbiAgbGV0IG5ld0luZGV4ID0gMDtcbiAgbGV0IGlzWFVub3JkZXJlZCA9IGZhbHNlO1xuICB3aGlsZSAob2xkSW5kZXggPCBvbGREYXRhLm5vZGVEYXRhLmxlbmd0aCB8fCBuZXdJbmRleCA8IG5ld0RhdGEubm9kZURhdGEubGVuZ3RoKSB7XG4gICAgY29uc3QgYmVmb3JlID0gb2xkRGF0YS5ub2RlRGF0YVtvbGRJbmRleF07XG4gICAgY29uc3QgYWZ0ZXIgPSBuZXdEYXRhLm5vZGVEYXRhW25ld0luZGV4XTtcbiAgICBjb25zdCBiWFZhbHVlID0gdHJhbnNmb3JtSW50ZWdyYXRlZENhdGVnb3J5VmFsdWUoYmVmb3JlPy54VmFsdWUpO1xuICAgIGNvbnN0IGFYVmFsdWUgPSB0cmFuc2Zvcm1JbnRlZ3JhdGVkQ2F0ZWdvcnlWYWx1ZShhZnRlcj8ueFZhbHVlKTtcbiAgICBsZXQgcmVzdWx0UG9pbnQ7XG4gICAgaWYgKGJYVmFsdWUgPT09IGFYVmFsdWUpIHtcbiAgICAgIHJlc3VsdFBvaW50ID0ge1xuICAgICAgICBjaGFuZ2U6IFwibW92ZVwiLFxuICAgICAgICBtb3ZlVG86IGNhbGN1bGF0ZU1vdmVUbyhiZWZvcmUucG9pbnQubW92ZVRvID8/IGZhbHNlLCBhZnRlci5wb2ludC5tb3ZlVG8pLFxuICAgICAgICBmcm9tOiBiZWZvcmUucG9pbnQsXG4gICAgICAgIHRvOiBhZnRlci5wb2ludFxuICAgICAgfTtcbiAgICAgIGFkZFRvUmVzdWx0TWFwKGJlZm9yZT8ueFZhbHVlLCByZXN1bHRQb2ludCk7XG4gICAgICBvbGRJbmRleCsrO1xuICAgICAgbmV3SW5kZXgrKztcbiAgICB9IGVsc2UgaWYgKGRpZmYyPy5yZW1vdmVkLmhhcyhTdHJpbmcoYlhWYWx1ZSkpKSB7XG4gICAgICByZXN1bHRQb2ludCA9IHtcbiAgICAgICAgY2hhbmdlOiBcIm91dFwiLFxuICAgICAgICBtb3ZlVG86IGJlZm9yZS5wb2ludC5tb3ZlVG8gPz8gZmFsc2UsXG4gICAgICAgIGZyb206IGJlZm9yZS5wb2ludFxuICAgICAgfTtcbiAgICAgIGFkZFRvUmVzdWx0TWFwKGJlZm9yZT8ueFZhbHVlLCByZXN1bHRQb2ludCk7XG4gICAgICBvbGRJbmRleCsrO1xuICAgIH0gZWxzZSBpZiAoZGlmZjI/LmFkZGVkLmhhcyhTdHJpbmcoYVhWYWx1ZSkpKSB7XG4gICAgICByZXN1bHRQb2ludCA9IHtcbiAgICAgICAgY2hhbmdlOiBcImluXCIsXG4gICAgICAgIG1vdmVUbzogYWZ0ZXIucG9pbnQubW92ZVRvID8/IGZhbHNlLFxuICAgICAgICB0bzogYWZ0ZXIucG9pbnRcbiAgICAgIH07XG4gICAgICBhZGRUb1Jlc3VsdE1hcChhZnRlcj8ueFZhbHVlLCByZXN1bHRQb2ludCk7XG4gICAgICBuZXdJbmRleCsrO1xuICAgIH0gZWxzZSBpZiAobXVsdGlEYXR1bSAmJiBwcmV2aW91c1Jlc3VsdFBvaW50ICYmIHByZXZpb3VzWFZhbHVlID09PSBiWFZhbHVlKSB7XG4gICAgICByZXN1bHRQb2ludCA9IHtcbiAgICAgICAgLi4ucHJldmlvdXNSZXN1bHRQb2ludFxuICAgICAgfTtcbiAgICAgIGFkZFRvUmVzdWx0TWFwKGJlZm9yZT8ueFZhbHVlLCByZXN1bHRQb2ludCk7XG4gICAgICBvbGRJbmRleCsrO1xuICAgIH0gZWxzZSBpZiAobXVsdGlEYXR1bSAmJiBwcmV2aW91c1Jlc3VsdFBvaW50ICYmIHByZXZpb3VzWFZhbHVlID09PSBhWFZhbHVlKSB7XG4gICAgICByZXN1bHRQb2ludCA9IHtcbiAgICAgICAgLi4ucHJldmlvdXNSZXN1bHRQb2ludFxuICAgICAgfTtcbiAgICAgIGFkZFRvUmVzdWx0TWFwKGFmdGVyPy54VmFsdWUsIHJlc3VsdFBvaW50KTtcbiAgICAgIG5ld0luZGV4Kys7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlzWFVub3JkZXJlZCA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcmVzdWx0LnB1c2gocmVzdWx0UG9pbnQpO1xuICB9XG4gIGxldCBwcmV2aW91c1ggPSAtSW5maW5pdHk7XG4gIGlzWFVub3JkZXJlZCB8fCAoaXNYVW5vcmRlcmVkID0gcmVzdWx0LnNvbWUoKHBhdGhQb2ludCkgPT4ge1xuICAgIGNvbnN0IHsgY2hhbmdlOiBtYXJrZXIsIHRvOiB7IHggPSAtSW5maW5pdHkgfSA9IHt9IH0gPSBwYXRoUG9pbnQ7XG4gICAgaWYgKG1hcmtlciA9PT0gXCJvdXRcIilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB1bm9yZGVyZWQgPSB4IDwgcHJldmlvdXNYO1xuICAgIHByZXZpb3VzWCA9IHg7XG4gICAgcmV0dXJuIHVub3JkZXJlZDtcbiAgfSkpO1xuICBpZiAoaXNYVW5vcmRlcmVkKSB7XG4gICAgcmV0dXJuIHsgcmVzdWx0OiB2b2lkIDAsIHJlc3VsdE1hcDogdm9pZCAwIH07XG4gIH1cbiAgYmFja2ZpbGxQYXRoUG9pbnREYXRhKHJlc3VsdCwgYmFja2ZpbGxTcGxpdE1vZGUpO1xuICByZXR1cm4geyByZXN1bHQsIHJlc3VsdE1hcDogbXVsdGlEYXR1bSA/IHJlc3VsdE1hcE11bHRpIDogcmVzdWx0TWFwU2luZ2xlIH07XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVQYXRoU3RhdHVzKG5ld0RhdGEsIG9sZERhdGEsIHBhaXJEYXRhKSB7XG4gIGxldCBzdGF0dXMgPSBcInVwZGF0ZWRcIjtcbiAgY29uc3QgdmlzaWJsZSA9IChkYXRhKSA9PiB7XG4gICAgcmV0dXJuIGRhdGEudmlzaWJsZTtcbiAgfTtcbiAgaWYgKCF2aXNpYmxlKG9sZERhdGEpICYmIHZpc2libGUobmV3RGF0YSkpIHtcbiAgICBzdGF0dXMgPSBcImFkZGVkXCI7XG4gIH0gZWxzZSBpZiAodmlzaWJsZShvbGREYXRhKSAmJiAhdmlzaWJsZShuZXdEYXRhKSkge1xuICAgIHN0YXR1cyA9IFwicmVtb3ZlZFwiO1xuICB9IGVsc2Uge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFpckRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChwYWlyRGF0YVtpXS5jaGFuZ2UgIT09IFwibW92ZVwiKVxuICAgICAgICBicmVhaztcbiAgICAgIGlmIChwYWlyRGF0YVtpXS5mcm9tPy54ICE9PSBwYWlyRGF0YVtpXS50bz8ueClcbiAgICAgICAgYnJlYWs7XG4gICAgICBpZiAocGFpckRhdGFbaV0uZnJvbT8ueSAhPT0gcGFpckRhdGFbaV0udG8/LnkpXG4gICAgICAgIGJyZWFrO1xuICAgICAgaWYgKGkgPT09IHBhaXJEYXRhLmxlbmd0aCAtIDEpXG4gICAgICAgIHJldHVybiBcIm5vLW9wXCI7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdGF0dXM7XG59XG5mdW5jdGlvbiBwcmVwYXJlTGluZVBhdGhQcm9wZXJ0eUFuaW1hdGlvbihzdGF0dXMsIHZpc2libGVUb2dnbGVNb2RlKSB7XG4gIGNvbnN0IHBoYXNlID0gdmlzaWJsZVRvZ2dsZU1vZGUgPT09IFwibm9uZVwiID8gXCJ1cGRhdGVkXCIgOiBzdGF0dXM7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBmcm9tRm46IChfcGF0aCkgPT4ge1xuICAgICAgbGV0IG1peGluO1xuICAgICAgaWYgKHN0YXR1cyA9PT0gXCJyZW1vdmVkXCIpIHtcbiAgICAgICAgbWl4aW4gPSB7IGZpbmlzaDogeyB2aXNpYmxlOiBmYWxzZSB9IH07XG4gICAgICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gXCJhZGRlZFwiKSB7XG4gICAgICAgIG1peGluID0geyBzdGFydDogeyB2aXNpYmxlOiB0cnVlIH0gfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1peGluID0ge307XG4gICAgICB9XG4gICAgICByZXR1cm4geyBwaGFzZTogTk9ERV9VUERBVEVfU1RBVEVfVE9fUEhBU0VfTUFQUElOR1twaGFzZV0sIC4uLm1peGluIH07XG4gICAgfSxcbiAgICB0b0ZuOiAoX3BhdGgpID0+IHtcbiAgICAgIHJldHVybiB7IHBoYXNlOiBOT0RFX1VQREFURV9TVEFURV9UT19QSEFTRV9NQVBQSU5HW3BoYXNlXSB9O1xuICAgIH1cbiAgfTtcbiAgaWYgKHZpc2libGVUb2dnbGVNb2RlID09PSBcImZhZGVcIikge1xuICAgIHJldHVybiB7XG4gICAgICBmcm9tRm46IChwYXRoKSA9PiB7XG4gICAgICAgIGNvbnN0IG9wYWNpdHkgPSBzdGF0dXMgPT09IFwiYWRkZWRcIiA/IDAgOiBwYXRoLm9wYWNpdHk7XG4gICAgICAgIHJldHVybiB7IG9wYWNpdHksIC4uLnJlc3VsdC5mcm9tRm4ocGF0aCkgfTtcbiAgICAgIH0sXG4gICAgICB0b0ZuOiAocGF0aCkgPT4ge1xuICAgICAgICBjb25zdCBvcGFjaXR5ID0gc3RhdHVzID09PSBcInJlbW92ZWRcIiA/IDAgOiAxO1xuICAgICAgICByZXR1cm4geyBvcGFjaXR5LCAuLi5yZXN1bHQudG9GbihwYXRoKSB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHByZXBhcmVMaW5lUGF0aEFuaW1hdGlvbkZucyhuZXdEYXRhLCBvbGREYXRhLCBwYWlyRGF0YSwgdmlzaWJsZVRvZ2dsZU1vZGUsIGludGVycG9sYXRpb24sIHJlbmRlcikge1xuICBjb25zdCBzdGF0dXMgPSBkZXRlcm1pbmVQYXRoU3RhdHVzKG5ld0RhdGEsIG9sZERhdGEsIHBhaXJEYXRhKTtcbiAgY29uc3QgcmVtb3ZlUGhhc2VGbiA9IChyYXRpbzIsIHBhdGgpID0+IHtcbiAgICByZW5kZXIocGFpckRhdGEsIHsgbW92ZTogMCwgb3V0OiByYXRpbzIgfSwgcGF0aCwgaW50ZXJwb2xhdGlvbik7XG4gIH07XG4gIGNvbnN0IHVwZGF0ZVBoYXNlRm4gPSAocmF0aW8yLCBwYXRoKSA9PiB7XG4gICAgcmVuZGVyKHBhaXJEYXRhLCB7IG1vdmU6IHJhdGlvMiB9LCBwYXRoLCBpbnRlcnBvbGF0aW9uKTtcbiAgfTtcbiAgY29uc3QgYWRkUGhhc2VGbiA9IChyYXRpbzIsIHBhdGgpID0+IHtcbiAgICByZW5kZXIocGFpckRhdGEsIHsgbW92ZTogMSwgaW46IHJhdGlvMiB9LCBwYXRoLCBpbnRlcnBvbGF0aW9uKTtcbiAgfTtcbiAgY29uc3QgcGF0aFByb3BlcnRpZXMgPSBwcmVwYXJlTGluZVBhdGhQcm9wZXJ0eUFuaW1hdGlvbihzdGF0dXMsIHZpc2libGVUb2dnbGVNb2RlKTtcbiAgcmV0dXJuIHsgc3RhdHVzLCBwYXRoOiB7IGFkZFBoYXNlRm4sIHVwZGF0ZVBoYXNlRm4sIHJlbW92ZVBoYXNlRm4gfSwgcGF0aFByb3BlcnRpZXMgfTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVMaW5lUGF0aEFuaW1hdGlvbihuZXdEYXRhLCBvbGREYXRhLCBkaWZmMiwgaW50ZXJwb2xhdGlvbikge1xuICBjb25zdCBpc0NhdGVnb3J5QmFzZWQgPSBuZXdEYXRhLnNjYWxlcy54Py50eXBlID09PSBcImNhdGVnb3J5XCI7XG4gIGNvbnN0IHdhc0NhdGVnb3J5QmFzZWQgPSBvbGREYXRhLnNjYWxlcy54Py50eXBlID09PSBcImNhdGVnb3J5XCI7XG4gIGlmIChpc0NhdGVnb3J5QmFzZWQgIT09IHdhc0NhdGVnb3J5QmFzZWQgfHwgIWlzU2NhbGVWYWxpZChuZXdEYXRhLnNjYWxlcy54KSB8fCAhaXNTY2FsZVZhbGlkKG9sZERhdGEuc2NhbGVzLngpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHsgcmVzdWx0OiBwYWlyRGF0YSwgcmVzdWx0TWFwOiBwYWlyTWFwIH0gPSBpc0NhdGVnb3J5QmFzZWQgPyBwYWlyQ2F0ZWdvcnlEYXRhKG5ld0RhdGEsIG9sZERhdGEsIGRpZmYyKSA6IHBhaXJDb250aW51b3VzRGF0YShuZXdEYXRhLCBvbGREYXRhKTtcbiAgbGV0IHN0YXR1cyA9IFwidXBkYXRlZFwiO1xuICBpZiAob2xkRGF0YS52aXNpYmxlICYmICFuZXdEYXRhLnZpc2libGUpIHtcbiAgICBzdGF0dXMgPSBcInJlbW92ZWRcIjtcbiAgfSBlbHNlIGlmICghb2xkRGF0YS52aXNpYmxlICYmIG5ld0RhdGEudmlzaWJsZSkge1xuICAgIHN0YXR1cyA9IFwiYWRkZWRcIjtcbiAgfVxuICBpZiAocGFpckRhdGEgPT09IHZvaWQgMCB8fCBwYWlyTWFwID09PSB2b2lkIDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgaGFzTW90aW9uID0gKGRpZmYyPy5jaGFuZ2VkID8/IHRydWUpIHx8IHNjYWxlc0NoYW5nZWQobmV3RGF0YSwgb2xkRGF0YSkgfHwgc3RhdHVzICE9PSBcInVwZGF0ZWRcIjtcbiAgY29uc3QgcGF0aEZucyA9IHByZXBhcmVMaW5lUGF0aEFuaW1hdGlvbkZucyhuZXdEYXRhLCBvbGREYXRhLCBwYWlyRGF0YSwgXCJmYWRlXCIsIGludGVycG9sYXRpb24sIHJlbmRlclBhcnRpYWxQYXRoKTtcbiAgY29uc3QgbWFya2VyID0gcHJlcGFyZU1hcmtlckFuaW1hdGlvbihwYWlyTWFwLCBzdGF0dXMpO1xuICByZXR1cm4geyAuLi5wYXRoRm5zLCBtYXJrZXIsIGhhc01vdGlvbiB9O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2xpbmVJbnRlcnBvbGF0aW9uVXRpbC50c1xuZnVuY3Rpb24gdG9BeGlzVmFsdWUodmFsdWUpIHtcbiAgcmV0dXJuIHRyYW5zZm9ybUludGVncmF0ZWRDYXRlZ29yeVZhbHVlKHZhbHVlKS52YWx1ZU9mKCk7XG59XG5mdW5jdGlvbiBnZXRBeGlzSW5kaWNlcyh7IGRhdGEgfSwgYXhpc1ZhbHVlcykge1xuICByZXR1cm4gZGF0YS5tYXAoKGRhdHVtLCBkYXR1bUluZGV4KSA9PiAoe1xuICAgIHhWYWx1ZTBJbmRleDogYXhpc1ZhbHVlcy5pbmRleE9mKHRvQXhpc1ZhbHVlKGRhdHVtLnhWYWx1ZTApKSxcbiAgICB4VmFsdWUxSW5kZXg6IGF4aXNWYWx1ZXMuaW5kZXhPZih0b0F4aXNWYWx1ZShkYXR1bS54VmFsdWUxKSksXG4gICAgZGF0dW1JbmRleFxuICB9KSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUF4aXNWYWx1ZXNPcmRlcihheGlzVmFsdWVzLCBkYXRhKSB7XG4gIGxldCB4MCA9IC1JbmZpbml0eTtcbiAgZm9yIChjb25zdCBheGlzVmFsdWUgb2YgYXhpc1ZhbHVlcykge1xuICAgIGNvbnN0IHggPSBzY2FsZShheGlzVmFsdWUsIGRhdGEuc2NhbGVzLngpO1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHgpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKHggPCB4MCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB4MCA9IHg7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZ2V0QXhpc1ZhbHVlcyhuZXdEYXRhLCBvbGREYXRhKSB7XG4gIGNvbnN0IGFsbEF4aXNWYWx1ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBmb3IgKGNvbnN0IHsgeFZhbHVlMCwgeFZhbHVlMSB9IG9mIG5ld0RhdGEuZGF0YSkge1xuICAgIGNvbnN0IHhWYWx1ZTBWYWx1ZSA9IHRvQXhpc1ZhbHVlKHhWYWx1ZTApO1xuICAgIGNvbnN0IHhWYWx1ZTFWYWx1ZSA9IHRvQXhpc1ZhbHVlKHhWYWx1ZTEpO1xuICAgIGFsbEF4aXNWYWx1ZXMuYWRkKHhWYWx1ZTBWYWx1ZSkuYWRkKHhWYWx1ZTFWYWx1ZSk7XG4gIH1cbiAgY29uc3QgbmV3QXhpc1ZhbHVlcyA9IEFycmF5LmZyb20oYWxsQXhpc1ZhbHVlcykuc29ydCgoYSwgYikgPT4ge1xuICAgIHJldHVybiBzY2FsZShhLCBuZXdEYXRhLnNjYWxlcy54KSAtIHNjYWxlKGIsIG5ld0RhdGEuc2NhbGVzLngpO1xuICB9KTtcbiAgY29uc3QgZXhjbHVzaXZlbHlPbGRBeGlzVmFsdWVzID0gW107XG4gIGZvciAoY29uc3QgeyB4VmFsdWUwLCB4VmFsdWUxIH0gb2Ygb2xkRGF0YS5kYXRhKSB7XG4gICAgY29uc3QgeFZhbHVlMFZhbHVlID0gdG9BeGlzVmFsdWUoeFZhbHVlMCk7XG4gICAgY29uc3QgeFZhbHVlMVZhbHVlID0gdG9BeGlzVmFsdWUoeFZhbHVlMSk7XG4gICAgaWYgKCFhbGxBeGlzVmFsdWVzLmhhcyh4VmFsdWUwVmFsdWUpKSB7XG4gICAgICBhbGxBeGlzVmFsdWVzLmFkZCh4VmFsdWUwVmFsdWUpO1xuICAgICAgZXhjbHVzaXZlbHlPbGRBeGlzVmFsdWVzLnB1c2goeFZhbHVlMFZhbHVlKTtcbiAgICB9XG4gICAgaWYgKCFhbGxBeGlzVmFsdWVzLmhhcyh4VmFsdWUxVmFsdWUpKSB7XG4gICAgICBhbGxBeGlzVmFsdWVzLmFkZCh4VmFsdWUxVmFsdWUpO1xuICAgICAgZXhjbHVzaXZlbHlPbGRBeGlzVmFsdWVzLnB1c2goeFZhbHVlMVZhbHVlKTtcbiAgICB9XG4gIH1cbiAgZXhjbHVzaXZlbHlPbGRBeGlzVmFsdWVzLnNvcnQoKGEsIGIpID0+IHtcbiAgICByZXR1cm4gc2NhbGUoYSwgb2xkRGF0YS5zY2FsZXMueCkgLSBzY2FsZShiLCBvbGREYXRhLnNjYWxlcy54KTtcbiAgfSk7XG4gIGNvbnN0IGF4aXNWYWx1ZXMgPSBuZXdBeGlzVmFsdWVzO1xuICBsZXQgaW5zZXJ0aW9uSW5kZXggPSAwO1xuICBmb3IgKGNvbnN0IG9sZFZhbHVlIG9mIGV4Y2x1c2l2ZWx5T2xkQXhpc1ZhbHVlcykge1xuICAgIGlubmVyOlxuICAgICAgZm9yIChsZXQgaSA9IGF4aXNWYWx1ZXMubGVuZ3RoOyBpID4gaW5zZXJ0aW9uSW5kZXg7IGkgLT0gMSkge1xuICAgICAgICBjb25zdCBvbGRWYWx1ZVggPSBzY2FsZShvbGRWYWx1ZSwgb2xkRGF0YS5zY2FsZXMueCk7XG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlWCA9IHNjYWxlKGF4aXNWYWx1ZXNbaV0sIG9sZERhdGEuc2NhbGVzLngpO1xuICAgICAgICBpZiAob2xkVmFsdWVYID4gbmV3VmFsdWVYKSB7XG4gICAgICAgICAgaW5zZXJ0aW9uSW5kZXggPSBpICsgMTtcbiAgICAgICAgICBicmVhayBpbm5lcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGF4aXNWYWx1ZXMuc3BsaWNlKGluc2VydGlvbkluZGV4LCAwLCBvbGRWYWx1ZSk7XG4gICAgaW5zZXJ0aW9uSW5kZXggKz0gMTtcbiAgfVxuICBpZiAoIXZhbGlkYXRlQXhpc1ZhbHVlc09yZGVyKGF4aXNWYWx1ZXMsIG9sZERhdGEpKVxuICAgIHJldHVybjtcbiAgY29uc3Qgb2xkRGF0YUF4aXNJbmRpY2VzID0gZ2V0QXhpc0luZGljZXMob2xkRGF0YSwgYXhpc1ZhbHVlcyk7XG4gIGNvbnN0IG5ld0RhdGFBeGlzSW5kaWNlcyA9IGdldEF4aXNJbmRpY2VzKG5ld0RhdGEsIGF4aXNWYWx1ZXMpO1xuICByZXR1cm4geyBheGlzVmFsdWVzLCBvbGREYXRhQXhpc0luZGljZXMsIG5ld0RhdGFBeGlzSW5kaWNlcyB9O1xufVxuZnVuY3Rpb24gY2xpcFNwYW4oc3BhbiwgeFZhbHVlMEluZGV4LCB4SW5kaWNlcykge1xuICBpZiAoeEluZGljZXMueFZhbHVlMUluZGV4ID09PSB4SW5kaWNlcy54VmFsdWUwSW5kZXggKyAxKVxuICAgIHJldHVybiBzcGFuO1xuICBjb25zdCByYW5nZTMgPSBzcGFuUmFuZ2Uoc3Bhbik7XG4gIGNvbnN0IHN0ZXAgPSAocmFuZ2UzWzFdLnggLSByYW5nZTNbMF0ueCkgLyAoeEluZGljZXMueFZhbHVlMUluZGV4IC0geEluZGljZXMueFZhbHVlMEluZGV4KTtcbiAgY29uc3Qgc3RhcnQyID0gcmFuZ2UzWzBdLnggKyAoeFZhbHVlMEluZGV4IC0geEluZGljZXMueFZhbHVlMEluZGV4KSAqIHN0ZXA7XG4gIGNvbnN0IGVuZDIgPSBzdGFydDIgKyBzdGVwO1xuICByZXR1cm4gY2xpcFNwYW5YKHNwYW4sIHN0YXJ0MiwgZW5kMik7XG59XG5mdW5jdGlvbiBheGlzWmVyb1NwYW4oc3BhbiwgZGF0YSkge1xuICBjb25zdCBbcjAsIHIxXSA9IHNwYW5SYW5nZShzcGFuKTtcbiAgY29uc3QgeTAgPSBzY2FsZSgwLCBkYXRhLnNjYWxlcy55KTtcbiAgcmV0dXJuIHJlc2NhbGVTcGFuKHNwYW4sIHsgeDogcjAueCwgeTogeTAgfSwgeyB4OiByMS54LCB5OiB5MCB9KTtcbn1cbmZ1bmN0aW9uIGNvbGxhcHNlU3BhbihzcGFuLCBkYXRhLCBheGlzSW5kaWNlcywgaW5kaWNlcywgcmFuZ2UzKSB7XG4gIGxldCB4VmFsdWU7XG4gIGxldCB5VmFsdWU7XG4gIGlmIChpbmRpY2VzLnhWYWx1ZTBJbmRleCA+PSByYW5nZTMueFZhbHVlMUluZGV4KSB7XG4gICAgY29uc3QgZGF0dW1JbmRleCA9IGF4aXNJbmRpY2VzLmZpbmRMYXN0KChpKSA9PiBpLnhWYWx1ZTFJbmRleCA8PSByYW5nZTMueFZhbHVlMUluZGV4KT8uZGF0dW1JbmRleDtcbiAgICBjb25zdCBkYXR1bSA9IGRhdHVtSW5kZXggIT0gbnVsbCA/IGRhdGEuZGF0YVtkYXR1bUluZGV4XSA6IHZvaWQgMDtcbiAgICB4VmFsdWUgPSBkYXR1bT8ueFZhbHVlMTtcbiAgICB5VmFsdWUgPSBkYXR1bT8ueVZhbHVlMTtcbiAgfSBlbHNlIGlmIChpbmRpY2VzLnhWYWx1ZTBJbmRleCA8PSByYW5nZTMueFZhbHVlMEluZGV4KSB7XG4gICAgY29uc3QgZGF0dW1JbmRleCA9IGF4aXNJbmRpY2VzLmZpbmQoKGkpID0+IGkueFZhbHVlMEluZGV4ID49IHJhbmdlMy54VmFsdWUwSW5kZXgpPy5kYXR1bUluZGV4O1xuICAgIGNvbnN0IGRhdHVtID0gZGF0dW1JbmRleCAhPSBudWxsID8gZGF0YS5kYXRhW2RhdHVtSW5kZXhdIDogdm9pZCAwO1xuICAgIHhWYWx1ZSA9IGRhdHVtPy54VmFsdWUwO1xuICAgIHlWYWx1ZSA9IGRhdHVtPy55VmFsdWUwO1xuICB9XG4gIGlmICh4VmFsdWUgPT0gbnVsbCB8fCB5VmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBheGlzWmVyb1NwYW4oc3BhbiwgZGF0YSk7XG4gIH1cbiAgY29uc3QgeCA9IHNjYWxlKHhWYWx1ZSwgZGF0YS5zY2FsZXMueCk7XG4gIGNvbnN0IHkgPSBzY2FsZSh5VmFsdWUsIGRhdGEuc2NhbGVzLnkpO1xuICBjb25zdCBwb2ludCA9IHsgeCwgeSB9O1xuICByZXR1cm4gcmVzY2FsZVNwYW4oc3BhbiwgcG9pbnQsIHBvaW50KTtcbn1cbmZ1bmN0aW9uIHplcm9EYXRhU3BhbihzcGFuRGF0dW0sIHplcm9EYXRhKSB7XG4gIGNvbnN0IG5ld1NwYW5YVmFsdWUwID0gdG9BeGlzVmFsdWUoc3BhbkRhdHVtLnhWYWx1ZTApO1xuICBjb25zdCBuZXdTcGFuWFZhbHVlMSA9IHRvQXhpc1ZhbHVlKHNwYW5EYXR1bS54VmFsdWUxKTtcbiAgcmV0dXJuIHplcm9EYXRhPy5maW5kKFxuICAgIChzcGFuKSA9PiB0b0F4aXNWYWx1ZShzcGFuLnhWYWx1ZTApID09PSBuZXdTcGFuWFZhbHVlMCAmJiB0b0F4aXNWYWx1ZShzcGFuLnhWYWx1ZTEpID09PSBuZXdTcGFuWFZhbHVlMVxuICApPy5zcGFuO1xufVxuZnVuY3Rpb24gYWRkU3BhbihuZXdEYXRhLCBuZXdBeGlzSW5kaWNlcywgbmV3SW5kaWNlcywgb2xkWmVyb0RhdGEsIHJhbmdlMywgb3V0KSB7XG4gIGNvbnN0IG5ld1NwYW5EYXR1bSA9IG5ld0RhdGEuZGF0YVtuZXdJbmRpY2VzLmRhdHVtSW5kZXhdO1xuICBjb25zdCBuZXdTcGFuID0gbmV3U3BhbkRhdHVtLnNwYW47XG4gIGNvbnN0IHplcm9TcGFuID0gemVyb0RhdGFTcGFuKG5ld1NwYW5EYXR1bSwgb2xkWmVyb0RhdGEpO1xuICBpZiAoemVyb1NwYW4gIT0gbnVsbCkge1xuICAgIG91dC5yZW1vdmVkLnB1c2goeyBmcm9tOiB6ZXJvU3BhbiwgdG86IHplcm9TcGFuIH0pO1xuICAgIG91dC5tb3ZlZC5wdXNoKHsgZnJvbTogemVyb1NwYW4sIHRvOiBuZXdTcGFuIH0pO1xuICAgIG91dC5hZGRlZC5wdXNoKHsgZnJvbTogbmV3U3BhbiwgdG86IG5ld1NwYW4gfSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgb2xkU3BhbiA9IGNvbGxhcHNlU3BhbihuZXdTcGFuLCBuZXdEYXRhLCBuZXdBeGlzSW5kaWNlcywgbmV3SW5kaWNlcywgcmFuZ2UzKTtcbiAgICBvdXQuYWRkZWQucHVzaCh7IGZyb206IG9sZFNwYW4sIHRvOiBuZXdTcGFuIH0pO1xuICB9XG59XG5mdW5jdGlvbiByZW1vdmVTcGFuKG9sZERhdGEsIG9sZEF4aXNJbmRpY2VzLCBvbGRJbmRpY2VzLCBuZXdaZXJvRGF0YSwgcmFuZ2UzLCBvdXQpIHtcbiAgY29uc3Qgb2xkU3BhbkRhdHVtID0gb2xkRGF0YS5kYXRhW29sZEluZGljZXMuZGF0dW1JbmRleF07XG4gIGNvbnN0IG9sZFNwYW4gPSBvbGRTcGFuRGF0dW0uc3BhbjtcbiAgY29uc3QgemVyb1NwYW4gPSB6ZXJvRGF0YVNwYW4ob2xkU3BhbkRhdHVtLCBuZXdaZXJvRGF0YSk7XG4gIGlmICh6ZXJvU3BhbiAhPSBudWxsKSB7XG4gICAgb3V0LnJlbW92ZWQucHVzaCh7IGZyb206IG9sZFNwYW4sIHRvOiBvbGRTcGFuIH0pO1xuICAgIG91dC5tb3ZlZC5wdXNoKHsgZnJvbTogb2xkU3BhbiwgdG86IHplcm9TcGFuIH0pO1xuICAgIG91dC5hZGRlZC5wdXNoKHsgZnJvbTogemVyb1NwYW4sIHRvOiB6ZXJvU3BhbiB9KTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBuZXdTcGFuID0gY29sbGFwc2VTcGFuKG9sZFNwYW4sIG9sZERhdGEsIG9sZEF4aXNJbmRpY2VzLCBvbGRJbmRpY2VzLCByYW5nZTMpO1xuICAgIG91dC5yZW1vdmVkLnB1c2goeyBmcm9tOiBvbGRTcGFuLCB0bzogbmV3U3BhbiB9KTtcbiAgfVxufVxuZnVuY3Rpb24gYWxpZ25TcGFuVG9Db250YWluaW5nU3BhbihzcGFuLCBheGlzVmFsdWVzLCBwcmVEYXRhLCBwb3N0RGF0YSwgcG9zdFNwYW5JbmRpY2VzKSB7XG4gIGNvbnN0IHN0YXJ0WFZhbHVlMCA9IGF4aXNWYWx1ZXNbcG9zdFNwYW5JbmRpY2VzLnhWYWx1ZTBJbmRleF07XG4gIGNvbnN0IHN0YXJ0RGF0dW0gPSBwcmVEYXRhLmRhdGEuZmluZCgoc3BhbkRhdHVtKSA9PiB0b0F4aXNWYWx1ZShzcGFuRGF0dW0ueFZhbHVlMCkgPT09IHN0YXJ0WFZhbHVlMCk7XG4gIGNvbnN0IGVuZFhWYWx1ZTEgPSBheGlzVmFsdWVzW3Bvc3RTcGFuSW5kaWNlcy54VmFsdWUxSW5kZXhdO1xuICBjb25zdCBlbmREYXR1bSA9IHByZURhdGEuZGF0YS5maW5kKChzcGFuRGF0dW0pID0+IHRvQXhpc1ZhbHVlKHNwYW5EYXR1bS54VmFsdWUxKSA9PT0gZW5kWFZhbHVlMSk7XG4gIGlmIChzdGFydERhdHVtID09IG51bGwgfHwgZW5kRGF0dW0gPT0gbnVsbClcbiAgICByZXR1cm47XG4gIGNvbnN0IFt7IHg6IHgwIH0sIHsgeDogeDEgfV0gPSBzcGFuUmFuZ2Uoc3Bhbik7XG4gIGNvbnN0IHN0YXJ0WCA9IHNjYWxlKHN0YXJ0RGF0dW0ueFZhbHVlMCwgcHJlRGF0YS5zY2FsZXMueCk7XG4gIGNvbnN0IHN0YXJ0WSA9IHNjYWxlKHN0YXJ0RGF0dW0ueVZhbHVlMCwgcHJlRGF0YS5zY2FsZXMueSk7XG4gIGNvbnN0IGVuZFggPSBzY2FsZShlbmREYXR1bS54VmFsdWUxLCBwcmVEYXRhLnNjYWxlcy54KTtcbiAgY29uc3QgZW5kWSA9IHNjYWxlKGVuZERhdHVtLnlWYWx1ZTEsIHByZURhdGEuc2NhbGVzLnkpO1xuICBsZXQgYWx0U3BhbiA9IHBvc3REYXRhLmRhdGFbcG9zdFNwYW5JbmRpY2VzLmRhdHVtSW5kZXhdLnNwYW47XG4gIGFsdFNwYW4gPSByZXNjYWxlU3BhbihhbHRTcGFuLCB7IHg6IHN0YXJ0WCwgeTogc3RhcnRZIH0sIHsgeDogZW5kWCwgeTogZW5kWSB9KTtcbiAgYWx0U3BhbiA9IGNsaXBTcGFuWChhbHRTcGFuLCB4MCwgeDEpO1xuICByZXR1cm4gYWx0U3Bhbjtcbn1cbmZ1bmN0aW9uIGFwcGVuZFNwYW5QaGFzZXMobmV3RGF0YSwgb2xkRGF0YSwgYXhpc1ZhbHVlcywgeFZhbHVlMEluZGV4LCBuZXdBeGlzSW5kaWNlcywgb2xkQXhpc0luZGljZXMsIHJhbmdlMywgb3V0KSB7XG4gIGNvbnN0IHhWYWx1ZTFJbmRleCA9IHhWYWx1ZTBJbmRleCArIDE7XG4gIGNvbnN0IG9sZEluZGljZXMgPSBvbGRBeGlzSW5kaWNlcy5maW5kKChpKSA9PiBpLnhWYWx1ZTBJbmRleCA8PSB4VmFsdWUwSW5kZXggJiYgaS54VmFsdWUxSW5kZXggPj0geFZhbHVlMUluZGV4KTtcbiAgY29uc3QgbmV3SW5kaWNlcyA9IG5ld0F4aXNJbmRpY2VzLmZpbmQoKGkpID0+IGkueFZhbHVlMEluZGV4IDw9IHhWYWx1ZTBJbmRleCAmJiBpLnhWYWx1ZTFJbmRleCA+PSB4VmFsdWUxSW5kZXgpO1xuICBjb25zdCBvbGRaZXJvRGF0YSA9IG9sZERhdGEuemVyb0RhdGE7XG4gIGNvbnN0IG5ld1plcm9EYXRhID0gbmV3RGF0YS56ZXJvRGF0YTtcbiAgaWYgKG9sZEluZGljZXMgPT0gbnVsbCAmJiBuZXdJbmRpY2VzICE9IG51bGwpIHtcbiAgICBhZGRTcGFuKG5ld0RhdGEsIG5ld0F4aXNJbmRpY2VzLCBuZXdJbmRpY2VzLCBvbGRaZXJvRGF0YSwgcmFuZ2UzLCBvdXQpO1xuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmIChvbGRJbmRpY2VzICE9IG51bGwgJiYgbmV3SW5kaWNlcyA9PSBudWxsKSB7XG4gICAgcmVtb3ZlU3BhbihvbGREYXRhLCBvbGRBeGlzSW5kaWNlcywgb2xkSW5kaWNlcywgbmV3WmVyb0RhdGEsIHJhbmdlMywgb3V0KTtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAob2xkSW5kaWNlcyA9PSBudWxsIHx8IG5ld0luZGljZXMgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgb3JkZXJpbmc7XG4gIGlmIChvbGRJbmRpY2VzLnhWYWx1ZTBJbmRleCA9PT0gbmV3SW5kaWNlcy54VmFsdWUwSW5kZXggJiYgb2xkSW5kaWNlcy54VmFsdWUxSW5kZXggPT09IG5ld0luZGljZXMueFZhbHVlMUluZGV4KSB7XG4gICAgb3JkZXJpbmcgPSAwO1xuICB9IGVsc2UgaWYgKG9sZEluZGljZXMueFZhbHVlMEluZGV4IDw9IG5ld0luZGljZXMueFZhbHVlMEluZGV4ICYmIG9sZEluZGljZXMueFZhbHVlMUluZGV4ID49IG5ld0luZGljZXMueFZhbHVlMUluZGV4KSB7XG4gICAgb3JkZXJpbmcgPSAtMTtcbiAgfSBlbHNlIGlmIChvbGRJbmRpY2VzLnhWYWx1ZTBJbmRleCA+PSBuZXdJbmRpY2VzLnhWYWx1ZTBJbmRleCAmJiBvbGRJbmRpY2VzLnhWYWx1ZTFJbmRleCA8PSBuZXdJbmRpY2VzLnhWYWx1ZTFJbmRleCkge1xuICAgIG9yZGVyaW5nID0gMTtcbiAgfSBlbHNlIHtcbiAgICBvcmRlcmluZyA9IDA7XG4gIH1cbiAgY29uc3Qgb2xkU3BhbkRhdHVtID0gb2xkRGF0YS5kYXRhW29sZEluZGljZXMuZGF0dW1JbmRleF07XG4gIGNvbnN0IGNsaXBwZWRPbGRTcGFuT2xkU2NhbGUgPSBjbGlwU3BhbihvbGRTcGFuRGF0dW0uc3BhbiwgeFZhbHVlMEluZGV4LCBvbGRJbmRpY2VzKTtcbiAgY29uc3QgbmV3U3BhbkRhdHVtID0gbmV3RGF0YS5kYXRhW25ld0luZGljZXMuZGF0dW1JbmRleF07XG4gIGNvbnN0IGNsaXBwZWROZXdTcGFuTmV3U2NhbGUgPSBjbGlwU3BhbihuZXdTcGFuRGF0dW0uc3BhbiwgeFZhbHVlMEluZGV4LCBuZXdJbmRpY2VzKTtcbiAgaWYgKG9yZGVyaW5nID09PSAxKSB7XG4gICAgY29uc3QgY2xpcHBlZFBvc3RSZW1vdmVPbGRTcGFuT2xkU2NhbGUgPSBhbGlnblNwYW5Ub0NvbnRhaW5pbmdTcGFuKFxuICAgICAgY2xpcHBlZE9sZFNwYW5PbGRTY2FsZSxcbiAgICAgIGF4aXNWYWx1ZXMsXG4gICAgICBvbGREYXRhLFxuICAgICAgbmV3RGF0YSxcbiAgICAgIG5ld0luZGljZXNcbiAgICApO1xuICAgIGlmIChjbGlwcGVkUG9zdFJlbW92ZU9sZFNwYW5PbGRTY2FsZSAhPSBudWxsKSB7XG4gICAgICBvdXQucmVtb3ZlZC5wdXNoKHsgZnJvbTogY2xpcHBlZE9sZFNwYW5PbGRTY2FsZSwgdG86IGNsaXBwZWRQb3N0UmVtb3ZlT2xkU3Bhbk9sZFNjYWxlIH0pO1xuICAgICAgb3V0Lm1vdmVkLnB1c2goeyBmcm9tOiBjbGlwcGVkUG9zdFJlbW92ZU9sZFNwYW5PbGRTY2FsZSwgdG86IGNsaXBwZWROZXdTcGFuTmV3U2NhbGUgfSk7XG4gICAgICBvdXQuYWRkZWQucHVzaCh7IGZyb206IGNsaXBwZWROZXdTcGFuTmV3U2NhbGUsIHRvOiBjbGlwcGVkTmV3U3Bhbk5ld1NjYWxlIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmVTcGFuKG9sZERhdGEsIG9sZEF4aXNJbmRpY2VzLCBvbGRJbmRpY2VzLCBuZXdaZXJvRGF0YSwgcmFuZ2UzLCBvdXQpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChvcmRlcmluZyA9PT0gLTEpIHtcbiAgICBjb25zdCBjbGlwcGVkUHJlQWRkZWROZXdTcGFuTmV3U2NhbGUgPSBhbGlnblNwYW5Ub0NvbnRhaW5pbmdTcGFuKFxuICAgICAgY2xpcHBlZE5ld1NwYW5OZXdTY2FsZSxcbiAgICAgIGF4aXNWYWx1ZXMsXG4gICAgICBuZXdEYXRhLFxuICAgICAgb2xkRGF0YSxcbiAgICAgIG9sZEluZGljZXNcbiAgICApO1xuICAgIGlmIChjbGlwcGVkUHJlQWRkZWROZXdTcGFuTmV3U2NhbGUgIT0gbnVsbCkge1xuICAgICAgb3V0LnJlbW92ZWQucHVzaCh7IGZyb206IGNsaXBwZWRPbGRTcGFuT2xkU2NhbGUsIHRvOiBjbGlwcGVkT2xkU3Bhbk9sZFNjYWxlIH0pO1xuICAgICAgb3V0Lm1vdmVkLnB1c2goeyBmcm9tOiBjbGlwcGVkT2xkU3Bhbk9sZFNjYWxlLCB0bzogY2xpcHBlZFByZUFkZGVkTmV3U3Bhbk5ld1NjYWxlIH0pO1xuICAgICAgb3V0LmFkZGVkLnB1c2goeyBmcm9tOiBjbGlwcGVkUHJlQWRkZWROZXdTcGFuTmV3U2NhbGUsIHRvOiBjbGlwcGVkTmV3U3Bhbk5ld1NjYWxlIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZGRTcGFuKG5ld0RhdGEsIG5ld0F4aXNJbmRpY2VzLCBuZXdJbmRpY2VzLCBvbGRaZXJvRGF0YSwgcmFuZ2UzLCBvdXQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBvdXQucmVtb3ZlZC5wdXNoKHsgZnJvbTogY2xpcHBlZE9sZFNwYW5PbGRTY2FsZSwgdG86IGNsaXBwZWRPbGRTcGFuT2xkU2NhbGUgfSk7XG4gICAgb3V0Lm1vdmVkLnB1c2goeyBmcm9tOiBjbGlwcGVkT2xkU3Bhbk9sZFNjYWxlLCB0bzogY2xpcHBlZE5ld1NwYW5OZXdTY2FsZSB9KTtcbiAgICBvdXQuYWRkZWQucHVzaCh7IGZyb206IGNsaXBwZWROZXdTcGFuTmV3U2NhbGUsIHRvOiBjbGlwcGVkTmV3U3Bhbk5ld1NjYWxlIH0pO1xuICB9XG59XG5mdW5jdGlvbiBwaGFzZUFuaW1hdGlvbihheGlzQ29udGV4dCwgbmV3RGF0YSwgb2xkRGF0YSwgb3V0KSB7XG4gIGNvbnN0IHsgYXhpc1ZhbHVlcywgb2xkRGF0YUF4aXNJbmRpY2VzLCBuZXdEYXRhQXhpc0luZGljZXMgfSA9IGF4aXNDb250ZXh0O1xuICBjb25zdCByYW5nZTMgPSB7XG4gICAgeFZhbHVlMEluZGV4OiBNYXRoLm1heChcbiAgICAgIG9sZERhdGFBeGlzSW5kaWNlcy5hdCgwKT8ueFZhbHVlMEluZGV4ID8/IC1JbmZpbml0eSxcbiAgICAgIG5ld0RhdGFBeGlzSW5kaWNlcy5hdCgwKT8ueFZhbHVlMEluZGV4ID8/IC1JbmZpbml0eVxuICAgICksXG4gICAgeFZhbHVlMUluZGV4OiBNYXRoLm1pbihcbiAgICAgIG9sZERhdGFBeGlzSW5kaWNlcy5hdCgtMSk/LnhWYWx1ZTFJbmRleCA/PyBJbmZpbml0eSxcbiAgICAgIG5ld0RhdGFBeGlzSW5kaWNlcy5hdCgtMSk/LnhWYWx1ZTFJbmRleCA/PyBJbmZpbml0eVxuICAgIClcbiAgfTtcbiAgZm9yIChsZXQgeFZhbHVlMEluZGV4ID0gMDsgeFZhbHVlMEluZGV4IDwgYXhpc1ZhbHVlcy5sZW5ndGggLSAxOyB4VmFsdWUwSW5kZXggKz0gMSkge1xuICAgIGFwcGVuZFNwYW5QaGFzZXMoXG4gICAgICBuZXdEYXRhLFxuICAgICAgb2xkRGF0YSxcbiAgICAgIGF4aXNWYWx1ZXMsXG4gICAgICB4VmFsdWUwSW5kZXgsXG4gICAgICBuZXdEYXRhQXhpc0luZGljZXMsXG4gICAgICBvbGREYXRhQXhpc0luZGljZXMsXG4gICAgICByYW5nZTMsXG4gICAgICBvdXRcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiByZXNldEFuaW1hdGlvbihuZXdEYXRhLCBvbGREYXRhLCBvdXQpIHtcbiAgZm9yIChjb25zdCBvbGRTcGFuRGF0dW0gb2Ygb2xkRGF0YS5kYXRhKSB7XG4gICAgY29uc3Qgb2xkU3BhbiA9IG9sZFNwYW5EYXR1bS5zcGFuO1xuICAgIGNvbnN0IHplcm9TcGFuID0gemVyb0RhdGFTcGFuKG9sZFNwYW5EYXR1bSwgb2xkRGF0YS56ZXJvRGF0YSkgPz8gYXhpc1plcm9TcGFuKG9sZFNwYW4sIG9sZERhdGEpO1xuICAgIG91dC5yZW1vdmVkLnB1c2goeyBmcm9tOiBvbGRTcGFuLCB0bzogemVyb1NwYW4gfSk7XG4gIH1cbiAgZm9yIChjb25zdCBuZXdTcGFuRGF0dW0gb2YgbmV3RGF0YS5kYXRhKSB7XG4gICAgY29uc3QgbmV3U3BhbiA9IG5ld1NwYW5EYXR1bS5zcGFuO1xuICAgIGNvbnN0IHplcm9TcGFuID0gemVyb0RhdGFTcGFuKG5ld1NwYW5EYXR1bSwgbmV3RGF0YS56ZXJvRGF0YSkgPz8gYXhpc1plcm9TcGFuKG5ld1NwYW4sIG5ld0RhdGEpO1xuICAgIG91dC5hZGRlZC5wdXNoKHsgZnJvbTogemVyb1NwYW4sIHRvOiBuZXdTcGFuIH0pO1xuICB9XG59XG5mdW5jdGlvbiBwYWlyVXBTcGFucyhuZXdEYXRhLCBvbGREYXRhKSB7XG4gIGNvbnN0IG91dCA9IHtcbiAgICByZW1vdmVkOiBbXSxcbiAgICBtb3ZlZDogW10sXG4gICAgYWRkZWQ6IFtdXG4gIH07XG4gIGNvbnN0IGF4aXNDb250ZXh0ID0gZ2V0QXhpc1ZhbHVlcyhuZXdEYXRhLCBvbGREYXRhKTtcbiAgaWYgKGF4aXNDb250ZXh0ID09IG51bGwpIHtcbiAgICByZXNldEFuaW1hdGlvbihuZXdEYXRhLCBvbGREYXRhLCBvdXQpO1xuICB9IGVsc2Uge1xuICAgIHBoYXNlQW5pbWF0aW9uKGF4aXNDb250ZXh0LCBuZXdEYXRhLCBvbGREYXRhLCBvdXQpO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vYXJlYVV0aWwudHNcbmZ1bmN0aW9uIHBsb3RGaWxsU3BhbnMocmF0aW8yLCBwYXRoLCBzcGFucywgZmlsbFBoYW50b21TcGFucykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgY29uc3Qgc3BhbiA9IHNwYW5zW2ldO1xuICAgIGNvbnN0IHJldmVyc2VkUGhhbnRvbVNwYW4gPSBmaWxsUGhhbnRvbVNwYW5zW2ldO1xuICAgIHBsb3RJbnRlcnBvbGF0ZWRTcGFucyhwYXRoLnBhdGgsIHNwYW4uZnJvbSwgc3Bhbi50bywgcmF0aW8yLCAxIC8qIE1vdmVUbyAqLywgZmFsc2UpO1xuICAgIHBsb3RJbnRlcnBvbGF0ZWRTcGFucyhcbiAgICAgIHBhdGgucGF0aCxcbiAgICAgIHJldmVyc2VkUGhhbnRvbVNwYW4uZnJvbSxcbiAgICAgIHJldmVyc2VkUGhhbnRvbVNwYW4udG8sXG4gICAgICByYXRpbzIsXG4gICAgICAyIC8qIExpbmVUbyAqLyxcbiAgICAgIHRydWVcbiAgICApO1xuICAgIHBhdGgucGF0aC5jbG9zZVBhdGgoKTtcbiAgfVxufVxuZnVuY3Rpb24gcHJlcGFyZUFyZWFGaWxsQW5pbWF0aW9uRm5zKHN0YXR1cywgc3BhbnMsIGZpbGxQaGFudG9tU3BhbnMsIHZpc2libGVUb2dnbGVNb2RlKSB7XG4gIGNvbnN0IHJlbW92ZVBoYXNlRm4gPSAocmF0aW8yLCBwYXRoKSA9PiBwbG90RmlsbFNwYW5zKHJhdGlvMiwgcGF0aCwgc3BhbnMucmVtb3ZlZCwgZmlsbFBoYW50b21TcGFucy5yZW1vdmVkKTtcbiAgY29uc3QgdXBkYXRlUGhhc2VGbiA9IChyYXRpbzIsIHBhdGgpID0+IHBsb3RGaWxsU3BhbnMocmF0aW8yLCBwYXRoLCBzcGFucy5tb3ZlZCwgZmlsbFBoYW50b21TcGFucy5tb3ZlZCk7XG4gIGNvbnN0IGFkZFBoYXNlRm4gPSAocmF0aW8yLCBwYXRoKSA9PiBwbG90RmlsbFNwYW5zKHJhdGlvMiwgcGF0aCwgc3BhbnMuYWRkZWQsIGZpbGxQaGFudG9tU3BhbnMuYWRkZWQpO1xuICBjb25zdCBwYXRoUHJvcGVydGllcyA9IHByZXBhcmVMaW5lUGF0aFByb3BlcnR5QW5pbWF0aW9uKHN0YXR1cywgdmlzaWJsZVRvZ2dsZU1vZGUpO1xuICByZXR1cm4geyBzdGF0dXMsIHBhdGg6IHsgYWRkUGhhc2VGbiwgdXBkYXRlUGhhc2VGbiwgcmVtb3ZlUGhhc2VGbiB9LCBwYXRoUHJvcGVydGllcyB9O1xufVxuZnVuY3Rpb24gcGxvdFN0cm9rZVNwYW5zKHJhdGlvMiwgcGF0aCwgc3BhbnMpIHtcbiAgZm9yIChjb25zdCBzcGFuIG9mIHNwYW5zKSB7XG4gICAgcGxvdEludGVycG9sYXRlZFNwYW5zKHBhdGgucGF0aCwgc3Bhbi5mcm9tLCBzcGFuLnRvLCByYXRpbzIsIDEgLyogTW92ZVRvICovLCBmYWxzZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHByZXBhcmVBcmVhU3Ryb2tlQW5pbWF0aW9uRm5zKHN0YXR1cywgc3BhbnMsIHZpc2libGVUb2dnbGVNb2RlKSB7XG4gIGNvbnN0IHJlbW92ZVBoYXNlRm4gPSAocmF0aW8yLCBwYXRoKSA9PiBwbG90U3Ryb2tlU3BhbnMocmF0aW8yLCBwYXRoLCBzcGFucy5yZW1vdmVkKTtcbiAgY29uc3QgdXBkYXRlUGhhc2VGbiA9IChyYXRpbzIsIHBhdGgpID0+IHBsb3RTdHJva2VTcGFucyhyYXRpbzIsIHBhdGgsIHNwYW5zLm1vdmVkKTtcbiAgY29uc3QgYWRkUGhhc2VGbiA9IChyYXRpbzIsIHBhdGgpID0+IHBsb3RTdHJva2VTcGFucyhyYXRpbzIsIHBhdGgsIHNwYW5zLmFkZGVkKTtcbiAgY29uc3QgcGF0aFByb3BlcnRpZXMgPSBwcmVwYXJlTGluZVBhdGhQcm9wZXJ0eUFuaW1hdGlvbihzdGF0dXMsIHZpc2libGVUb2dnbGVNb2RlKTtcbiAgcmV0dXJuIHsgc3RhdHVzLCBwYXRoOiB7IGFkZFBoYXNlRm4sIHVwZGF0ZVBoYXNlRm4sIHJlbW92ZVBoYXNlRm4gfSwgcGF0aFByb3BlcnRpZXMgfTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVBcmVhUGF0aEFuaW1hdGlvbihuZXdEYXRhLCBvbGREYXRhKSB7XG4gIGNvbnN0IGlzQ2F0ZWdvcnlCYXNlZCA9IG5ld0RhdGEuc2NhbGVzLng/LnR5cGUgPT09IFwiY2F0ZWdvcnlcIjtcbiAgY29uc3Qgd2FzQ2F0ZWdvcnlCYXNlZCA9IG9sZERhdGEuc2NhbGVzLng/LnR5cGUgPT09IFwiY2F0ZWdvcnlcIjtcbiAgaWYgKGlzQ2F0ZWdvcnlCYXNlZCAhPT0gd2FzQ2F0ZWdvcnlCYXNlZCB8fCAhaXNTY2FsZVZhbGlkKG5ld0RhdGEuc2NhbGVzLngpIHx8ICFpc1NjYWxlVmFsaWQob2xkRGF0YS5zY2FsZXMueCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IHN0YXR1cyA9IFwidXBkYXRlZFwiO1xuICBpZiAob2xkRGF0YS52aXNpYmxlICYmICFuZXdEYXRhLnZpc2libGUpIHtcbiAgICBzdGF0dXMgPSBcInJlbW92ZWRcIjtcbiAgfSBlbHNlIGlmICghb2xkRGF0YS52aXNpYmxlICYmIG5ld0RhdGEudmlzaWJsZSkge1xuICAgIHN0YXR1cyA9IFwiYWRkZWRcIjtcbiAgfVxuICBjb25zdCBmaWxsU3BhbnMgPSBwYWlyVXBTcGFucyhcbiAgICB7IHNjYWxlczogbmV3RGF0YS5zY2FsZXMsIGRhdGE6IG5ld0RhdGEuZmlsbERhdGEuc3BhbnMsIHZpc2libGU6IG5ld0RhdGEudmlzaWJsZSB9LFxuICAgIHsgc2NhbGVzOiBvbGREYXRhLnNjYWxlcywgZGF0YTogb2xkRGF0YS5maWxsRGF0YS5zcGFucywgdmlzaWJsZTogb2xkRGF0YS52aXNpYmxlIH1cbiAgKTtcbiAgY29uc3QgZmlsbFBoYW50b21TcGFucyA9IHBhaXJVcFNwYW5zKFxuICAgIHsgc2NhbGVzOiBuZXdEYXRhLnNjYWxlcywgZGF0YTogbmV3RGF0YS5maWxsRGF0YS5waGFudG9tU3BhbnMsIHZpc2libGU6IG5ld0RhdGEudmlzaWJsZSB9LFxuICAgIHsgc2NhbGVzOiBvbGREYXRhLnNjYWxlcywgZGF0YTogb2xkRGF0YS5maWxsRGF0YS5waGFudG9tU3BhbnMsIHZpc2libGU6IG9sZERhdGEudmlzaWJsZSB9XG4gICk7XG4gIGNvbnN0IHN0cm9rZVNwYW5zID0gcGFpclVwU3BhbnMoXG4gICAge1xuICAgICAgc2NhbGVzOiBuZXdEYXRhLnNjYWxlcyxcbiAgICAgIGRhdGE6IG5ld0RhdGEuc3Ryb2tlRGF0YS5zcGFucyxcbiAgICAgIHZpc2libGU6IG5ld0RhdGEudmlzaWJsZSxcbiAgICAgIHplcm9EYXRhOiBuZXdEYXRhLmZpbGxEYXRhLnBoYW50b21TcGFuc1xuICAgIH0sXG4gICAge1xuICAgICAgc2NhbGVzOiBvbGREYXRhLnNjYWxlcyxcbiAgICAgIGRhdGE6IG9sZERhdGEuc3Ryb2tlRGF0YS5zcGFucyxcbiAgICAgIHZpc2libGU6IG9sZERhdGEudmlzaWJsZSxcbiAgICAgIHplcm9EYXRhOiBvbGREYXRhLmZpbGxEYXRhLnBoYW50b21TcGFuc1xuICAgIH1cbiAgKTtcbiAgY29uc3QgZmFkZU1vZGUgPSBcIm5vbmVcIjtcbiAgY29uc3QgZmlsbCA9IHByZXBhcmVBcmVhRmlsbEFuaW1hdGlvbkZucyhzdGF0dXMsIGZpbGxTcGFucywgZmlsbFBoYW50b21TcGFucywgZmFkZU1vZGUpO1xuICBjb25zdCBzdHJva2UgPSBwcmVwYXJlQXJlYVN0cm9rZUFuaW1hdGlvbkZucyhzdGF0dXMsIHN0cm9rZVNwYW5zLCBmYWRlTW9kZSk7XG4gIHJldHVybiB7IHN0YXR1cywgZmlsbCwgc3Ryb2tlIH07XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vYXJlYVNlcmllcy50c1xudmFyIENST1NTX0ZJTFRFUl9BUkVBX0ZJTExfT1BBQ0lUWV9GQUNUT1IgPSAwLjEyNTtcbnZhciBDUk9TU19GSUxURVJfQVJFQV9TVFJPS0VfT1BBQ0lUWV9GQUNUT1IgPSAwLjI1O1xudmFyIEFyZWFTZXJpZXMgPSBjbGFzcyBleHRlbmRzIENhcnRlc2lhblNlcmllcyB7XG4gIGNvbnN0cnVjdG9yKG1vZHVsZUN0eCkge1xuICAgIHN1cGVyKHtcbiAgICAgIG1vZHVsZUN0eCxcbiAgICAgIGRpcmVjdGlvbktleXM6IERFRkFVTFRfQ0FSVEVTSUFOX0RJUkVDVElPTl9LRVlTLFxuICAgICAgZGlyZWN0aW9uTmFtZXM6IERFRkFVTFRfQ0FSVEVTSUFOX0RJUkVDVElPTl9OQU1FUyxcbiAgICAgIHBhdGhzUGVyU2VyaWVzOiBbXCJmaWxsXCIsIFwic3Ryb2tlXCJdLFxuICAgICAgcGF0aHNaSW5kZXhTdWJPcmRlck9mZnNldDogWzAsIDFlM10sXG4gICAgICBoYXNNYXJrZXJzOiB0cnVlLFxuICAgICAgbWFya2VyU2VsZWN0aW9uR2FyYmFnZUNvbGxlY3Rpb246IGZhbHNlLFxuICAgICAgcGlja01vZGVzOiBbMiAvKiBBWElTX0FMSUdORUQgKi8sIDAgLyogRVhBQ1RfU0hBUEVfTUFUQ0ggKi9dLFxuICAgICAgYW5pbWF0aW9uUmVzZXRGbnM6IHtcbiAgICAgICAgcGF0aDogYnVpbGRSZXNldFBhdGhGbih7IGdldFZpc2libGU6ICgpID0+IHRoaXMudmlzaWJsZSwgZ2V0T3BhY2l0eTogKCkgPT4gdGhpcy5nZXRPcGFjaXR5KCkgfSksXG4gICAgICAgIGxhYmVsOiByZXNldExhYmVsRm4sXG4gICAgICAgIG1hcmtlcjogKG5vZGUsIGRhdHVtKSA9PiAoeyAuLi5yZXNldE1hcmtlckZuKG5vZGUpLCAuLi5yZXNldE1hcmtlclBvc2l0aW9uRm4obm9kZSwgZGF0dW0pIH0pXG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5wcm9wZXJ0aWVzID0gbmV3IEFyZWFTZXJpZXNQcm9wZXJ0aWVzKCk7XG4gIH1cbiAgYXN5bmMgcHJvY2Vzc0RhdGEoZGF0YUNvbnRyb2xsZXIpIHtcbiAgICBpZiAodGhpcy5kYXRhID09IG51bGwgfHwgIXRoaXMucHJvcGVydGllcy5pc1ZhbGlkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBkYXRhLCB2aXNpYmxlLCBzZXJpZXNHcm91cGluZzogeyBncm91cEluZGV4ID0gdGhpcy5pZCwgc3RhY2tDb3VudCA9IDEgfSA9IHt9IH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgeEtleSwgeUtleSwgeUZpbHRlcktleSwgY29ubmVjdE1pc3NpbmdEYXRhLCBub3JtYWxpemVkVG8gfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCBhbmltYXRpb25FbmFibGVkID0gIXRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuaXNTa2lwcGVkKCk7XG4gICAgY29uc3QgeFNjYWxlID0gdGhpcy5heGVzW1wieFwiIC8qIFggKi9dPy5zY2FsZTtcbiAgICBjb25zdCB5U2NhbGUgPSB0aGlzLmF4ZXNbXCJ5XCIgLyogWSAqL10/LnNjYWxlO1xuICAgIGNvbnN0IHsgeFNjYWxlVHlwZSwgeVNjYWxlVHlwZSB9ID0gdGhpcy5nZXRTY2FsZUluZm9ybWF0aW9uKHsgeFNjYWxlLCB5U2NhbGUgfSk7XG4gICAgY29uc3QgaWRNYXAgPSB7XG4gICAgICB2YWx1ZTogYGFyZWEtc3RhY2stJHtncm91cEluZGV4fS15VmFsdWVgLFxuICAgICAgdmFsdWVzOiBgYXJlYS1zdGFjay0ke2dyb3VwSW5kZXh9LXlWYWx1ZXNgLFxuICAgICAgc3RhY2s6IGBhcmVhLXN0YWNrLSR7Z3JvdXBJbmRleH0teVZhbHVlLXN0YWNrYCxcbiAgICAgIG1hcmtlcjogYGFyZWEtc3RhY2stJHtncm91cEluZGV4fS15VmFsdWVzLW1hcmtlcmBcbiAgICB9O1xuICAgIGNvbnN0IGV4dHJhUHJvcHMgPSBbXTtcbiAgICBpZiAoaXNEZWZpbmVkKG5vcm1hbGl6ZWRUbykpIHtcbiAgICAgIGV4dHJhUHJvcHMucHVzaChub3JtYWxpc2VHcm91cFRvKE9iamVjdC52YWx1ZXMoaWRNYXApLCBub3JtYWxpemVkVG8sIFwicmFuZ2VcIikpO1xuICAgIH1cbiAgICBpZiAoYW5pbWF0aW9uRW5hYmxlZCkge1xuICAgICAgZXh0cmFQcm9wcy5wdXNoKGFuaW1hdGlvblZhbGlkYXRpb24oKSk7XG4gICAgfVxuICAgIGNvbnN0IGNvbW1vbiA9IHsgaW52YWxpZFZhbHVlOiBudWxsIH07XG4gICAgaWYgKGNvbm5lY3RNaXNzaW5nRGF0YSAmJiBzdGFja0NvdW50ID4gMSkge1xuICAgICAgY29tbW9uLmludmFsaWRWYWx1ZSA9IDA7XG4gICAgfVxuICAgIGlmICghdmlzaWJsZSkge1xuICAgICAgY29tbW9uLmZvcmNlVmFsdWUgPSAwO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLnJlcXVlc3REYXRhTW9kZWwoZGF0YUNvbnRyb2xsZXIsIGRhdGEsIHtcbiAgICAgIHByb3BzOiBbXG4gICAgICAgIGtleVByb3BlcnR5KHhLZXksIHhTY2FsZVR5cGUsIHsgaWQ6IFwieFZhbHVlXCIgfSksXG4gICAgICAgIHZhbHVlUHJvcGVydHkoeUtleSwgeVNjYWxlVHlwZSwgeyBpZDogYHlWYWx1ZVJhd2AsIC4uLmNvbW1vbiB9KSxcbiAgICAgICAgLi4ueUZpbHRlcktleSAhPSBudWxsID8gW3ZhbHVlUHJvcGVydHkoeUZpbHRlcktleSwgeVNjYWxlVHlwZSwgeyBpZDogXCJ5RmlsdGVyUmF3XCIgfSldIDogW10sXG4gICAgICAgIC4uLmdyb3VwU3RhY2tWYWx1ZVByb3BlcnR5KHlLZXksIHlTY2FsZVR5cGUsIHsgaWQ6IGB5VmFsdWVTdGFja2AsIC4uLmNvbW1vbiwgZ3JvdXBJZDogaWRNYXAuc3RhY2sgfSksXG4gICAgICAgIHZhbHVlUHJvcGVydHkoeUtleSwgeVNjYWxlVHlwZSwgeyBpZDogYHlWYWx1ZWAsIC4uLmNvbW1vbiwgZ3JvdXBJZDogaWRNYXAudmFsdWUgfSksXG4gICAgICAgIC4uLmdyb3VwQWNjdW11bGF0aXZlVmFsdWVQcm9wZXJ0eShcbiAgICAgICAgICB5S2V5LFxuICAgICAgICAgIFwid2luZG93XCIsXG4gICAgICAgICAgXCJjdXJyZW50XCIsXG4gICAgICAgICAgeyBpZDogYHlWYWx1ZUVuZGAsIC4uLmNvbW1vbiwgZ3JvdXBJZDogaWRNYXAudmFsdWVzIH0sXG4gICAgICAgICAgeVNjYWxlVHlwZVxuICAgICAgICApLFxuICAgICAgICAuLi5ncm91cEFjY3VtdWxhdGl2ZVZhbHVlUHJvcGVydHkoXG4gICAgICAgICAgeUtleSxcbiAgICAgICAgICBcIm5vcm1hbFwiLFxuICAgICAgICAgIFwiY3VycmVudFwiLFxuICAgICAgICAgIHsgaWQ6IGB5VmFsdWVDdW11bGF0aXZlYCwgLi4uY29tbW9uLCBncm91cElkOiBpZE1hcC5tYXJrZXIgfSxcbiAgICAgICAgICB5U2NhbGVUeXBlXG4gICAgICAgICksXG4gICAgICAgIC4uLmV4dHJhUHJvcHNcbiAgICAgIF0sXG4gICAgICBncm91cEJ5S2V5czogdHJ1ZSxcbiAgICAgIGdyb3VwQnlEYXRhOiBmYWxzZVxuICAgIH0pO1xuICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcInVwZGF0ZURhdGFcIik7XG4gIH1cbiAgZ2V0U2VyaWVzRG9tYWluKGRpcmVjdGlvbikge1xuICAgIGNvbnN0IHsgcHJvY2Vzc2VkRGF0YSwgZGF0YU1vZGVsLCBheGVzIH0gPSB0aGlzO1xuICAgIGlmICghcHJvY2Vzc2VkRGF0YSB8fCAhZGF0YU1vZGVsIHx8IHByb2Nlc3NlZERhdGEuZGF0YS5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gW107XG4gICAgY29uc3QgeUF4aXMgPSBheGVzW1wieVwiIC8qIFkgKi9dO1xuICAgIGNvbnN0IGtleURlZiA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YURlZkJ5SWQodGhpcywgYHhWYWx1ZWApO1xuICAgIGNvbnN0IGtleXMgPSBkYXRhTW9kZWwuZ2V0RG9tYWluKHRoaXMsIGB4VmFsdWVgLCBcImtleVwiLCBwcm9jZXNzZWREYXRhKTtcbiAgICBjb25zdCB5RXh0ZW50ID0gZGF0YU1vZGVsLmdldERvbWFpbih0aGlzLCBgeVZhbHVlRW5kYCwgXCJ2YWx1ZVwiLCBwcm9jZXNzZWREYXRhKTtcbiAgICBpZiAoZGlyZWN0aW9uID09PSBcInhcIiAvKiBYICovKSB7XG4gICAgICBpZiAoa2V5RGVmPy5kZWYudHlwZSA9PT0gXCJrZXlcIiAmJiBrZXlEZWYuZGVmLnZhbHVlVHlwZSA9PT0gXCJjYXRlZ29yeVwiKSB7XG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZpeE51bWVyaWNFeHRlbnQoZXh0ZW50KGtleXMpKTtcbiAgICB9IGVsc2UgaWYgKHlBeGlzIGluc3RhbmNlb2YgTG9nQXhpcyB8fCB5QXhpcyBpbnN0YW5jZW9mIFRpbWVBeGlzKSB7XG4gICAgICByZXR1cm4gZml4TnVtZXJpY0V4dGVudCh5RXh0ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZml4ZWRZRXh0ZW50ID0gW3lFeHRlbnRbMF0gPiAwID8gMCA6IHlFeHRlbnRbMF0sIHlFeHRlbnRbMV0gPCAwID8gMCA6IHlFeHRlbnRbMV1dO1xuICAgICAgcmV0dXJuIGZpeE51bWVyaWNFeHRlbnQoZml4ZWRZRXh0ZW50KTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgY3JlYXRlTm9kZURhdGEoKSB7XG4gICAgY29uc3QgeyBheGVzLCBkYXRhLCBwcm9jZXNzZWREYXRhOiB7IGRhdGE6IGdyb3VwZWREYXRhIH0gPSB7fSwgZGF0YU1vZGVsIH0gPSB0aGlzO1xuICAgIGNvbnN0IHhBeGlzID0gYXhlc1tcInhcIiAvKiBYICovXTtcbiAgICBjb25zdCB5QXhpcyA9IGF4ZXNbXCJ5XCIgLyogWSAqL107XG4gICAgaWYgKCF4QXhpcyB8fCAheUF4aXMgfHwgIWRhdGEgfHwgIWRhdGFNb2RlbCB8fCAhdGhpcy5wcm9wZXJ0aWVzLmlzVmFsaWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICB5S2V5LFxuICAgICAgeEtleSxcbiAgICAgIHlGaWx0ZXJLZXksXG4gICAgICBtYXJrZXIsXG4gICAgICBsYWJlbCxcbiAgICAgIGZpbGw6IHNlcmllc0ZpbGwsXG4gICAgICBzdHJva2U6IHNlcmllc1N0cm9rZSxcbiAgICAgIGNvbm5lY3RNaXNzaW5nRGF0YVxuICAgIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgeyBzY2FsZTogeFNjYWxlIH0gPSB4QXhpcztcbiAgICBjb25zdCB7IHNjYWxlOiB5U2NhbGUgfSA9IHlBeGlzO1xuICAgIGNvbnN0IHsgaXNDb250aW51b3VzWSB9ID0gdGhpcy5nZXRTY2FsZUluZm9ybWF0aW9uKHsgeFNjYWxlLCB5U2NhbGUgfSk7XG4gICAgY29uc3QgeE9mZnNldCA9ICh4U2NhbGUuYmFuZHdpZHRoID8/IDApIC8gMjtcbiAgICBjb25zdCBkZWZzID0gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhRGVmc0J5SWRzKHRoaXMsIFtgeVZhbHVlRW5kYCwgYHlWYWx1ZVJhd2AsIGB5VmFsdWVDdW11bGF0aXZlYF0pO1xuICAgIGNvbnN0IHlGaWx0ZXJJbmRleCA9IHlGaWx0ZXJLZXkgIT0gbnVsbCA/IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBcInlGaWx0ZXJSYXdcIikgOiB2b2lkIDA7XG4gICAgY29uc3QgeVZhbHVlU3RhY2tJbmRleCA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBcInlWYWx1ZVN0YWNrXCIpO1xuICAgIGNvbnN0IGNyZWF0ZU1hcmtlckNvb3JkaW5hdGUgPSAoeERhdHVtLCB5RW5kLCByYXdZRGF0dW0pID0+IHtcbiAgICAgIGxldCBjdXJyWTtcbiAgICAgIGlmIChpc0RlZmluZWQodGhpcy5wcm9wZXJ0aWVzLm5vcm1hbGl6ZWRUbykgPyBpc0NvbnRpbnVvdXNZICYmIGlzQ29udGludW91cyhyYXdZRGF0dW0pIDogIWlzTmFOKHJhd1lEYXR1bSkpIHtcbiAgICAgICAgY3VyclkgPSB5RW5kO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogeFNjYWxlLmNvbnZlcnQoeERhdHVtKSArIHhPZmZzZXQsXG4gICAgICAgIHk6IHlTY2FsZS5jb252ZXJ0KGN1cnJZKSxcbiAgICAgICAgc2l6ZTogbWFya2VyLnNpemVcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBpdGVtSWQgPSB5S2V5O1xuICAgIGNvbnN0IGxhYmVsRGF0YSA9IFtdO1xuICAgIGNvbnN0IG1hcmtlckRhdGEgPSBbXTtcbiAgICBjb25zdCB7IHZpc2libGVTYW1lU3RhY2tDb3VudCB9ID0gdGhpcy5jdHguc2VyaWVzU3RhdGVNYW5hZ2VyLmdldFZpc2libGVQZWVyR3JvdXBJbmRleCh0aGlzKTtcbiAgICBsZXQgZGF0dW1JZHggPSAtMTtcbiAgICBsZXQgY3Jvc3NGaWx0ZXJpbmcgPSBmYWxzZTtcbiAgICBncm91cGVkRGF0YT8uZm9yRWFjaCgoZGF0dW1Hcm91cCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBrZXlzLFxuICAgICAgICBrZXlzOiBbeERhdHVtXSxcbiAgICAgICAgZGF0dW06IGRhdHVtQXJyYXksXG4gICAgICAgIHZhbHVlczogdmFsdWVzQXJyYXlcbiAgICAgIH0gPSBkYXR1bUdyb3VwO1xuICAgICAgdmFsdWVzQXJyYXkuZm9yRWFjaCgodmFsdWVzLCB2YWx1ZUlkeCkgPT4ge1xuICAgICAgICBkYXR1bUlkeCsrO1xuICAgICAgICBjb25zdCBzZXJpZXNEYXR1bSA9IGRhdHVtQXJyYXlbdmFsdWVJZHhdO1xuICAgICAgICBjb25zdCBkYXRhVmFsdWVzMiA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YURlZnNWYWx1ZXMoZGVmcywgeyBrZXlzLCB2YWx1ZXMgfSk7XG4gICAgICAgIGNvbnN0IHsgeVZhbHVlUmF3OiB5RGF0dW0sIHlWYWx1ZUN1bXVsYXRpdmUsIHlWYWx1ZUVuZCB9ID0gZGF0YVZhbHVlczI7XG4gICAgICAgIGNvbnN0IHZhbGlkUG9pbnQgPSBOdW1iZXIuaXNGaW5pdGUoeURhdHVtKTtcbiAgICAgICAgY29uc3QgcG9pbnQgPSBjcmVhdGVNYXJrZXJDb29yZGluYXRlKHhEYXR1bSwgK3lWYWx1ZUN1bXVsYXRpdmUsIHlEYXR1bSk7XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkID0geUZpbHRlckluZGV4ICE9IG51bGwgPyB2YWx1ZXNbeUZpbHRlckluZGV4XSA9PT0geURhdHVtIDogdm9pZCAwO1xuICAgICAgICBpZiAoc2VsZWN0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgY3Jvc3NGaWx0ZXJpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWxpZFBvaW50ICYmIG1hcmtlcikge1xuICAgICAgICAgIG1hcmtlckRhdGEucHVzaCh7XG4gICAgICAgICAgICBpbmRleDogZGF0dW1JZHgsXG4gICAgICAgICAgICBzZXJpZXM6IHRoaXMsXG4gICAgICAgICAgICBpdGVtSWQsXG4gICAgICAgICAgICBkYXR1bTogc2VyaWVzRGF0dW0sXG4gICAgICAgICAgICBtaWRQb2ludDogeyB4OiBwb2ludC54LCB5OiBwb2ludC55IH0sXG4gICAgICAgICAgICBjdW11bGF0aXZlVmFsdWU6IHlWYWx1ZUVuZCxcbiAgICAgICAgICAgIHlWYWx1ZTogeURhdHVtLFxuICAgICAgICAgICAgeFZhbHVlOiB4RGF0dW0sXG4gICAgICAgICAgICB5S2V5LFxuICAgICAgICAgICAgeEtleSxcbiAgICAgICAgICAgIHBvaW50LFxuICAgICAgICAgICAgZmlsbDogbWFya2VyLmZpbGwgPz8gc2VyaWVzRmlsbCxcbiAgICAgICAgICAgIHN0cm9rZTogbWFya2VyLnN0cm9rZSA/PyBzZXJpZXNTdHJva2UsXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogbWFya2VyLnN0cm9rZVdpZHRoID8/IHRoaXMuZ2V0U3Ryb2tlV2lkdGgodGhpcy5wcm9wZXJ0aWVzLnN0cm9rZVdpZHRoKSxcbiAgICAgICAgICAgIHNlbGVjdGVkXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbGlkUG9pbnQgJiYgbGFiZWwpIHtcbiAgICAgICAgICBjb25zdCBsYWJlbFRleHQgPSB0aGlzLmdldExhYmVsVGV4dChcbiAgICAgICAgICAgIGxhYmVsLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YWx1ZTogeURhdHVtLFxuICAgICAgICAgICAgICBkYXR1bTogc2VyaWVzRGF0dW0sXG4gICAgICAgICAgICAgIHhLZXksXG4gICAgICAgICAgICAgIHlLZXksXG4gICAgICAgICAgICAgIHhOYW1lOiB0aGlzLnByb3BlcnRpZXMueE5hbWUsXG4gICAgICAgICAgICAgIHlOYW1lOiB0aGlzLnByb3BlcnRpZXMueU5hbWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb3JtYXRWYWx1ZVxuICAgICAgICAgICk7XG4gICAgICAgICAgbGFiZWxEYXRhLnB1c2goe1xuICAgICAgICAgICAgaW5kZXg6IGRhdHVtSWR4LFxuICAgICAgICAgICAgc2VyaWVzOiB0aGlzLFxuICAgICAgICAgICAgaXRlbUlkOiB5S2V5LFxuICAgICAgICAgICAgZGF0dW06IHNlcmllc0RhdHVtLFxuICAgICAgICAgICAgeDogcG9pbnQueCxcbiAgICAgICAgICAgIHk6IHBvaW50LnksXG4gICAgICAgICAgICBsYWJlbFRleHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgY29uc3QgeyBpbnRlcnBvbGF0aW9uIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgaW50ZXJwb2xhdGVQb2ludHMgPSAocG9pbnRzKSA9PiB7XG4gICAgICBsZXQgc3BhbnM7XG4gICAgICBjb25zdCBwb2ludHNJdGVyID0gcG9pbnRzLm1hcCgocG9pbnQpID0+IHBvaW50LnBvaW50KTtcbiAgICAgIHN3aXRjaCAoaW50ZXJwb2xhdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJsaW5lYXJcIjpcbiAgICAgICAgICBzcGFucyA9IGxpbmVhclBvaW50cyhwb2ludHNJdGVyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNtb290aFwiOlxuICAgICAgICAgIHNwYW5zID0gc21vb3RoUG9pbnRzKHBvaW50c0l0ZXIsIGludGVycG9sYXRpb24udGVuc2lvbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzdGVwXCI6XG4gICAgICAgICAgc3BhbnMgPSBzdGVwUG9pbnRzKHBvaW50c0l0ZXIsIGludGVycG9sYXRpb24ucG9zaXRpb24pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNwYW5zLm1hcCgoc3BhbiwgaSkgPT4gKHtcbiAgICAgICAgc3BhbixcbiAgICAgICAgeFZhbHVlMDogcG9pbnRzW2ldLnhEYXR1bSxcbiAgICAgICAgeVZhbHVlMDogcG9pbnRzW2ldLnlEYXR1bSxcbiAgICAgICAgeFZhbHVlMTogcG9pbnRzW2kgKyAxXS54RGF0dW0sXG4gICAgICAgIHlWYWx1ZTE6IHBvaW50c1tpICsgMV0ueURhdHVtXG4gICAgICB9KSk7XG4gICAgfTtcbiAgICBjb25zdCBzcGFuc0ZvclBvaW50cyA9IChwb2ludHMpID0+IHtcbiAgICAgIHJldHVybiBwb2ludHMuZmxhdE1hcCgocCkgPT4ge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShwKSA/IGludGVycG9sYXRlUG9pbnRzKHApIDogbmV3IEFycmF5KHAuc2tpcCkuZmlsbChudWxsKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgZGF0YVZhbHVlcyA9IGdyb3VwZWREYXRhPy5mbGF0TWFwKChkYXR1bUdyb3VwKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGtleXM6IFt4RGF0dW1dLFxuICAgICAgICB2YWx1ZXM6IHZhbHVlc0FycmF5XG4gICAgICB9ID0gZGF0dW1Hcm91cDtcbiAgICAgIHJldHVybiB2YWx1ZXNBcnJheS5tYXAoKHZhbHVlcykgPT4gKHsgeERhdHVtLCB2YWx1ZXMgfSkpO1xuICAgIH0pO1xuICAgIGNvbnN0IGNyZWF0ZVBvaW50ID0gKHhEYXR1bSwgeURhdHVtKSA9PiAoe1xuICAgICAgcG9pbnQ6IHtcbiAgICAgICAgeDogeFNjYWxlLmNvbnZlcnQoeERhdHVtKSArIHhPZmZzZXQsXG4gICAgICAgIHk6IHlTY2FsZS5jb252ZXJ0KHlEYXR1bSlcbiAgICAgIH0sXG4gICAgICB4RGF0dW0sXG4gICAgICB5RGF0dW1cbiAgICB9KTtcbiAgICBjb25zdCBnZXRTZXJpZXNTcGFucyA9IChpbmRleCkgPT4ge1xuICAgICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgICBpZiAoZGF0YVZhbHVlcyA9PSBudWxsKVxuICAgICAgICByZXR1cm4gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFWYWx1ZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgeyB4RGF0dW0sIHZhbHVlcyB9ID0gZGF0YVZhbHVlc1tpXTtcbiAgICAgICAgY29uc3QgeVZhbHVlU3RhY2sgPSB2YWx1ZXNbeVZhbHVlU3RhY2tJbmRleF07XG4gICAgICAgIGNvbnN0IHlEYXR1bSA9IHlWYWx1ZVN0YWNrW2luZGV4XTtcbiAgICAgICAgY29uc3QgeURhdHVtSXNGaW5pdGUgPSBOdW1iZXIuaXNGaW5pdGUoeURhdHVtKTtcbiAgICAgICAgaWYgKGNvbm5lY3RNaXNzaW5nRGF0YSAmJiAheURhdHVtSXNGaW5pdGUpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IGxhc3RZVmFsdWVTdGFjayA9IGRhdGFWYWx1ZXNbaSAtIDFdPy52YWx1ZXNbeVZhbHVlU3RhY2tJbmRleF07XG4gICAgICAgIGNvbnN0IG5leHRZVmFsdWVTdGFjayA9IGRhdGFWYWx1ZXNbaSArIDFdPy52YWx1ZXNbeVZhbHVlU3RhY2tJbmRleF07XG4gICAgICAgIGxldCB5VmFsdWVFbmRCYWNrd2FyZHMgPSAwO1xuICAgICAgICBsZXQgeVZhbHVlRW5kRm9yd2FyZHMgPSAwO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8PSBpbmRleDsgaiArPSAxKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSB5VmFsdWVTdGFja1tqXTtcbiAgICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHZhbHVlKSkge1xuICAgICAgICAgICAgY29uc3QgbGFzdFdhc0Zpbml0ZSA9IGxhc3RZVmFsdWVTdGFjayA9PSBudWxsIHx8IE51bWJlci5pc0Zpbml0ZShsYXN0WVZhbHVlU3RhY2tbal0pO1xuICAgICAgICAgICAgY29uc3QgbmV4dFdhc0Zpbml0ZSA9IG5leHRZVmFsdWVTdGFjayA9PSBudWxsIHx8IE51bWJlci5pc0Zpbml0ZShuZXh0WVZhbHVlU3RhY2tbal0pO1xuICAgICAgICAgICAgaWYgKGxhc3RXYXNGaW5pdGUpIHtcbiAgICAgICAgICAgICAgeVZhbHVlRW5kQmFja3dhcmRzICs9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHRXYXNGaW5pdGUpIHtcbiAgICAgICAgICAgICAgeVZhbHVlRW5kRm9yd2FyZHMgKz0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRQb2ludHMgPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoIWNvbm5lY3RNaXNzaW5nRGF0YSAmJiAoeVZhbHVlRW5kQmFja3dhcmRzICE9PSB5VmFsdWVFbmRGb3J3YXJkcyB8fCAheURhdHVtSXNGaW5pdGUpKSB7XG4gICAgICAgICAgaWYgKCF5RGF0dW1Jc0Zpbml0ZSAmJiBBcnJheS5pc0FycmF5KGN1cnJlbnRQb2ludHMpICYmIGN1cnJlbnRQb2ludHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdID0geyBza2lwOiAxIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50QmFja3dhcmRzID0gY3JlYXRlUG9pbnQoeERhdHVtLCB5VmFsdWVFbmRCYWNrd2FyZHMpO1xuICAgICAgICAgICAgY29uc3QgcG9pbnRGb3J3YXJkcyA9IGNyZWF0ZVBvaW50KHhEYXR1bSwgeVZhbHVlRW5kRm9yd2FyZHMpO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudFBvaW50cykpIHtcbiAgICAgICAgICAgICAgY3VycmVudFBvaW50cy5wdXNoKHBvaW50QmFja3dhcmRzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFBvaW50cyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRQb2ludHMuc2tpcCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9pbnRzLnB1c2goeURhdHVtSXNGaW5pdGUgPyBbcG9pbnRGb3J3YXJkc10gOiB7IHNraXA6IDAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHlWYWx1ZUVuZCA9IE1hdGgubWF4KHlWYWx1ZUVuZEJhY2t3YXJkcywgeVZhbHVlRW5kRm9yd2FyZHMpO1xuICAgICAgICAgIGNvbnN0IHBvaW50ID0gY3JlYXRlUG9pbnQoeERhdHVtLCB5VmFsdWVFbmQpO1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnRQb2ludHMpKSB7XG4gICAgICAgICAgICBjdXJyZW50UG9pbnRzLnB1c2gocG9pbnQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFBvaW50cyAhPSBudWxsKSB7XG4gICAgICAgICAgICBjdXJyZW50UG9pbnRzLnNraXAgKz0gMTtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKFtwb2ludF0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb2ludHMucHVzaChbcG9pbnRdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzcGFuc0ZvclBvaW50cyhwb2ludHMpO1xuICAgIH07XG4gICAgY29uc3Qgc3RhY2tJbmRleCA9IHRoaXMuc2VyaWVzR3JvdXBpbmc/LnN0YWNrSW5kZXggPz8gMDtcbiAgICBjb25zdCBnZXRBeGlzU3BhbnMgPSAoKSA9PiB7XG4gICAgICBpZiAoZGF0YVZhbHVlcyA9PSBudWxsKVxuICAgICAgICByZXR1cm4gW107XG4gICAgICBjb25zdCB5VmFsdWVaZXJvUG9pbnRzID0gZGF0YVZhbHVlcy5tYXAoKHsgeERhdHVtLCB2YWx1ZXMgfSkgPT4ge1xuICAgICAgICBjb25zdCB5VmFsdWVTdGFjayA9IHZhbHVlc1t5VmFsdWVTdGFja0luZGV4XTtcbiAgICAgICAgY29uc3QgeURhdHVtID0geVZhbHVlU3RhY2tbc3RhY2tJbmRleF07XG4gICAgICAgIGlmIChjb25uZWN0TWlzc2luZ0RhdGEgJiYgIU51bWJlci5pc0Zpbml0ZSh5RGF0dW0pKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVBvaW50KHhEYXR1bSwgMCk7XG4gICAgICB9KS5maWx0ZXIoKHgpID0+IHggIT0gbnVsbCk7XG4gICAgICByZXR1cm4gaW50ZXJwb2xhdGVQb2ludHMoeVZhbHVlWmVyb1BvaW50cyk7XG4gICAgfTtcbiAgICBjb25zdCBjdXJyZW50U2VyaWVzU3BhbnMgPSBnZXRTZXJpZXNTcGFucyhzdGFja0luZGV4KTtcbiAgICBjb25zdCBwaGFudG9tU3BhbnMgPSBjdXJyZW50U2VyaWVzU3BhbnMubWFwKCgpID0+IG51bGwpO1xuICAgIGZvciAobGV0IGogPSBzdGFja0luZGV4IC0gMTsgaiA+PSAtMTsgaiAtPSAxKSB7XG4gICAgICBsZXQgc3BhbnM7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBoYW50b21TcGFucy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAocGhhbnRvbVNwYW5zW2ldICE9IG51bGwpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIHNwYW5zID8/IChzcGFucyA9IGogIT09IC0xID8gZ2V0U2VyaWVzU3BhbnMoaikgOiBnZXRBeGlzU3BhbnMoKSk7XG4gICAgICAgIHBoYW50b21TcGFuc1tpXSA9IHNwYW5zW2ldO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmaWxsU3BhbnMgPSBjdXJyZW50U2VyaWVzU3BhbnMubWFwKChzcGFuLCBpbmRleCkgPT4gc3BhbiA/PyBwaGFudG9tU3BhbnNbaW5kZXhdKTtcbiAgICBjb25zdCBzdHJva2VTcGFucyA9IGN1cnJlbnRTZXJpZXNTcGFucy5maWx0ZXIoKHNwYW4pID0+IHNwYW4gIT0gbnVsbCk7XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIGl0ZW1JZCxcbiAgICAgIGZpbGxEYXRhOiB7IGl0ZW1JZCwgc3BhbnM6IGZpbGxTcGFucywgcGhhbnRvbVNwYW5zIH0sXG4gICAgICBzdHJva2VEYXRhOiB7IGl0ZW1JZCwgc3BhbnM6IHN0cm9rZVNwYW5zIH0sXG4gICAgICBsYWJlbERhdGEsXG4gICAgICBub2RlRGF0YTogbWFya2VyRGF0YSxcbiAgICAgIHNjYWxlczogdGhpcy5jYWxjdWxhdGVTY2FsaW5nKCksXG4gICAgICB2aXNpYmxlOiB0aGlzLnZpc2libGUsXG4gICAgICBzdGFja1Zpc2libGU6IHZpc2libGVTYW1lU3RhY2tDb3VudCA+IDAsXG4gICAgICBjcm9zc0ZpbHRlcmluZ1xuICAgIH07XG4gICAgcmV0dXJuIGNvbnRleHQ7XG4gIH1cbiAgaXNQYXRoT3JTZWxlY3Rpb25EaXJ0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLm1hcmtlci5pc0RpcnR5KCk7XG4gIH1cbiAgbWFya2VyRmFjdG9yeSgpIHtcbiAgICBjb25zdCB7IHNoYXBlIH0gPSB0aGlzLnByb3BlcnRpZXMubWFya2VyO1xuICAgIGNvbnN0IE1hcmtlclNoYXBlID0gZ2V0TWFya2VyKHNoYXBlKTtcbiAgICByZXR1cm4gbmV3IE1hcmtlclNoYXBlKCk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlUGF0aE5vZGVzKG9wdHMpIHtcbiAgICBjb25zdCB7IG9wYWNpdHksIHZpc2libGUsIGFuaW1hdGlvbkVuYWJsZWQgfSA9IG9wdHM7XG4gICAgY29uc3QgW2ZpbGwsIHN0cm9rZV0gPSBvcHRzLnBhdGhzO1xuICAgIGNvbnN0IGNyb3NzRmlsdGVyaW5nID0gdGhpcy5jb250ZXh0Tm9kZURhdGE/LmNyb3NzRmlsdGVyaW5nID09PSB0cnVlO1xuICAgIGNvbnN0IHN0cm9rZVdpZHRoID0gdGhpcy5nZXRTdHJva2VXaWR0aCh0aGlzLnByb3BlcnRpZXMuc3Ryb2tlV2lkdGgpO1xuICAgIHN0cm9rZS5zZXRQcm9wZXJ0aWVzKHtcbiAgICAgIGZpbGw6IHZvaWQgMCxcbiAgICAgIGxpbmVKb2luOiBzdHJva2UubGluZUNhcCA9IFwicm91bmRcIixcbiAgICAgIHBvaW50ZXJFdmVudHM6IDEgLyogTm9uZSAqLyxcbiAgICAgIHN0cm9rZTogdGhpcy5wcm9wZXJ0aWVzLnN0cm9rZSxcbiAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgc3Ryb2tlT3BhY2l0eTogdGhpcy5wcm9wZXJ0aWVzLnN0cm9rZU9wYWNpdHkgKiAoY3Jvc3NGaWx0ZXJpbmcgPyBDUk9TU19GSUxURVJfQVJFQV9TVFJPS0VfT1BBQ0lUWV9GQUNUT1IgOiAxKSxcbiAgICAgIGxpbmVEYXNoOiB0aGlzLnByb3BlcnRpZXMubGluZURhc2gsXG4gICAgICBsaW5lRGFzaE9mZnNldDogdGhpcy5wcm9wZXJ0aWVzLmxpbmVEYXNoT2Zmc2V0LFxuICAgICAgb3BhY2l0eSxcbiAgICAgIHZpc2libGU6IHZpc2libGUgfHwgYW5pbWF0aW9uRW5hYmxlZFxuICAgIH0pO1xuICAgIGZpbGwuc2V0UHJvcGVydGllcyh7XG4gICAgICBzdHJva2U6IHZvaWQgMCxcbiAgICAgIGxpbmVKb2luOiBcInJvdW5kXCIsXG4gICAgICBwb2ludGVyRXZlbnRzOiAxIC8qIE5vbmUgKi8sXG4gICAgICBmaWxsOiB0aGlzLnByb3BlcnRpZXMuZmlsbCxcbiAgICAgIGZpbGxPcGFjaXR5OiB0aGlzLnByb3BlcnRpZXMuZmlsbE9wYWNpdHkgKiAoY3Jvc3NGaWx0ZXJpbmcgPyBDUk9TU19GSUxURVJfQVJFQV9GSUxMX09QQUNJVFlfRkFDVE9SIDogMSksXG4gICAgICBmaWxsU2hhZG93OiB0aGlzLnByb3BlcnRpZXMuc2hhZG93LFxuICAgICAgb3BhY2l0eSxcbiAgICAgIHZpc2libGU6IHZpc2libGUgfHwgYW5pbWF0aW9uRW5hYmxlZFxuICAgIH0pO1xuICAgIHVwZGF0ZUNsaXBQYXRoKHRoaXMsIHN0cm9rZSk7XG4gICAgdXBkYXRlQ2xpcFBhdGgodGhpcywgZmlsbCk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlUGF0aHMob3B0cykge1xuICAgIHRoaXMudXBkYXRlQXJlYVBhdGhzKG9wdHMucGF0aHMsIG9wdHMuY29udGV4dERhdGEpO1xuICB9XG4gIHVwZGF0ZUFyZWFQYXRocyhwYXRocywgY29udGV4dERhdGEpIHtcbiAgICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aHMpIHtcbiAgICAgIHBhdGgudmlzaWJsZSA9IGNvbnRleHREYXRhLnZpc2libGU7XG4gICAgfVxuICAgIGlmIChjb250ZXh0RGF0YS52aXNpYmxlKSB7XG4gICAgICB0aGlzLnVwZGF0ZUZpbGxQYXRoKHBhdGhzLCBjb250ZXh0RGF0YSk7XG4gICAgICB0aGlzLnVwZGF0ZVN0cm9rZVBhdGgocGF0aHMsIGNvbnRleHREYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzKSB7XG4gICAgICAgIHBhdGgucGF0aC5jbGVhcigpO1xuICAgICAgICBwYXRoLmNoZWNrUGF0aERpcnR5KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHVwZGF0ZUZpbGxQYXRoKHBhdGhzLCBjb250ZXh0RGF0YSkge1xuICAgIGNvbnN0IHsgc3BhbnMsIHBoYW50b21TcGFucyB9ID0gY29udGV4dERhdGEuZmlsbERhdGE7XG4gICAgY29uc3QgW2ZpbGxdID0gcGF0aHM7XG4gICAgY29uc3QgeyBwYXRoIH0gPSBmaWxsO1xuICAgIHBhdGguY2xlYXIodHJ1ZSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGFucy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgY29uc3QgeyBzcGFuIH0gPSBzcGFuc1tpXTtcbiAgICAgIGNvbnN0IHBoYW50b21TcGFuID0gcGhhbnRvbVNwYW5zW2ldLnNwYW47XG4gICAgICBwbG90U3BhbihwYXRoLCBzcGFuLCAxIC8qIE1vdmVUbyAqLywgZmFsc2UpO1xuICAgICAgcGxvdFNwYW4ocGF0aCwgcGhhbnRvbVNwYW4sIDIgLyogTGluZVRvICovLCB0cnVlKTtcbiAgICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gICAgfVxuICAgIGZpbGwuY2hlY2tQYXRoRGlydHkoKTtcbiAgfVxuICB1cGRhdGVTdHJva2VQYXRoKHBhdGhzLCBjb250ZXh0RGF0YSkge1xuICAgIGNvbnN0IHsgc3BhbnMgfSA9IGNvbnRleHREYXRhLnN0cm9rZURhdGE7XG4gICAgY29uc3QgWywgc3Ryb2tlXSA9IHBhdGhzO1xuICAgIGNvbnN0IHsgcGF0aCB9ID0gc3Ryb2tlO1xuICAgIHBhdGguY2xlYXIodHJ1ZSk7XG4gICAgZm9yIChjb25zdCB7IHNwYW4gfSBvZiBzcGFucykge1xuICAgICAgcGxvdFNwYW4ocGF0aCwgc3BhbiwgMSAvKiBNb3ZlVG8gKi8sIGZhbHNlKTtcbiAgICB9XG4gICAgc3Ryb2tlLmNoZWNrUGF0aERpcnR5KCk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlTWFya2VyU2VsZWN0aW9uKG9wdHMpIHtcbiAgICBjb25zdCB7IG5vZGVEYXRhLCBtYXJrZXJTZWxlY3Rpb24gfSA9IG9wdHM7XG4gICAgY29uc3QgbWFya2Vyc0VuYWJsZWQgPSB0aGlzLnByb3BlcnRpZXMubWFya2VyLmVuYWJsZWQgfHwgdGhpcy5jb250ZXh0Tm9kZURhdGE/LmNyb3NzRmlsdGVyaW5nID09PSB0cnVlO1xuICAgIGlmICh0aGlzLnByb3BlcnRpZXMubWFya2VyLmlzRGlydHkoKSkge1xuICAgICAgbWFya2VyU2VsZWN0aW9uLmNsZWFyKCk7XG4gICAgICBtYXJrZXJTZWxlY3Rpb24uY2xlYW51cCgpO1xuICAgIH1cbiAgICByZXR1cm4gbWFya2VyU2VsZWN0aW9uLnVwZGF0ZShtYXJrZXJzRW5hYmxlZCA/IG5vZGVEYXRhIDogW10pO1xuICB9XG4gIGFzeW5jIHVwZGF0ZU1hcmtlck5vZGVzKG9wdHMpIHtcbiAgICBjb25zdCB7IG1hcmtlclNlbGVjdGlvbiwgaXNIaWdobGlnaHQ6IGhpZ2hsaWdodGVkIH0gPSBvcHRzO1xuICAgIGNvbnN0IHsgeEtleSwgeUtleSwgbWFya2VyLCBmaWxsLCBzdHJva2UsIHN0cm9rZVdpZHRoLCBmaWxsT3BhY2l0eSwgc3Ryb2tlT3BhY2l0eSwgaGlnaGxpZ2h0U3R5bGUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCBiYXNlU3R5bGUgPSBtZXJnZURlZmF1bHRzKGhpZ2hsaWdodGVkICYmIGhpZ2hsaWdodFN0eWxlLml0ZW0sIG1hcmtlci5nZXRTdHlsZSgpLCB7XG4gICAgICBmaWxsLFxuICAgICAgc3Ryb2tlLFxuICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICBmaWxsT3BhY2l0eSxcbiAgICAgIHN0cm9rZU9wYWNpdHlcbiAgICB9KTtcbiAgICBtYXJrZXJTZWxlY3Rpb24uZWFjaCgobm9kZSwgZGF0dW0pID0+IHtcbiAgICAgIHRoaXMudXBkYXRlTWFya2VyU3R5bGUobm9kZSwgbWFya2VyLCB7IGRhdHVtLCBoaWdobGlnaHRlZCwgeEtleSwgeUtleSB9LCBiYXNlU3R5bGUsIHtcbiAgICAgICAgc2VsZWN0ZWQ6IGRhdHVtLnNlbGVjdGVkXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAoIWhpZ2hsaWdodGVkKSB7XG4gICAgICB0aGlzLnByb3BlcnRpZXMubWFya2VyLm1hcmtDbGVhbigpO1xuICAgIH1cbiAgfVxuICBhc3luYyB1cGRhdGVMYWJlbFNlbGVjdGlvbihvcHRzKSB7XG4gICAgY29uc3QgeyBsYWJlbERhdGEsIGxhYmVsU2VsZWN0aW9uIH0gPSBvcHRzO1xuICAgIHJldHVybiBsYWJlbFNlbGVjdGlvbi51cGRhdGUobGFiZWxEYXRhKTtcbiAgfVxuICBhc3luYyB1cGRhdGVMYWJlbE5vZGVzKG9wdHMpIHtcbiAgICBjb25zdCB7IGxhYmVsU2VsZWN0aW9uIH0gPSBvcHRzO1xuICAgIGNvbnN0IHsgZW5hYmxlZDogbGFiZWxFbmFibGVkLCBmb250U3R5bGUsIGZvbnRXZWlnaHQsIGZvbnRTaXplLCBmb250RmFtaWx5LCBjb2xvciB9ID0gdGhpcy5wcm9wZXJ0aWVzLmxhYmVsO1xuICAgIGxhYmVsU2VsZWN0aW9uLmVhY2goKHRleHQsIGRhdHVtKSA9PiB7XG4gICAgICBjb25zdCB7IHgsIHksIGxhYmVsVGV4dCB9ID0gZGF0dW07XG4gICAgICBpZiAobGFiZWxUZXh0ICYmIGxhYmVsRW5hYmxlZCAmJiB0aGlzLnZpc2libGUpIHtcbiAgICAgICAgdGV4dC5mb250U3R5bGUgPSBmb250U3R5bGU7XG4gICAgICAgIHRleHQuZm9udFdlaWdodCA9IGZvbnRXZWlnaHQ7XG4gICAgICAgIHRleHQuZm9udFNpemUgPSBmb250U2l6ZTtcbiAgICAgICAgdGV4dC5mb250RmFtaWx5ID0gZm9udEZhbWlseTtcbiAgICAgICAgdGV4dC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgICB0ZXh0LnRleHRCYXNlbGluZSA9IFwiYm90dG9tXCI7XG4gICAgICAgIHRleHQudGV4dCA9IGxhYmVsVGV4dDtcbiAgICAgICAgdGV4dC54ID0geDtcbiAgICAgICAgdGV4dC55ID0geSAtIDEwO1xuICAgICAgICB0ZXh0LmZpbGwgPSBjb2xvcjtcbiAgICAgICAgdGV4dC52aXNpYmxlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHQudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGdldFRvb2x0aXBIdG1sKG5vZGVEYXR1bSkge1xuICAgIGNvbnN0IHsgaWQ6IHNlcmllc0lkLCBheGVzLCBkYXRhTW9kZWwgfSA9IHRoaXM7XG4gICAgY29uc3QgeyB4S2V5LCB4TmFtZSwgeU5hbWUsIHRvb2x0aXAsIG1hcmtlciB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHsgeUtleSwgeFZhbHVlLCB5VmFsdWUsIGRhdHVtLCBpdGVtSWQgfSA9IG5vZGVEYXR1bTtcbiAgICBjb25zdCB4QXhpcyA9IGF4ZXNbXCJ4XCIgLyogWCAqL107XG4gICAgY29uc3QgeUF4aXMgPSBheGVzW1wieVwiIC8qIFkgKi9dO1xuICAgIGlmICghdGhpcy5wcm9wZXJ0aWVzLmlzVmFsaWQoKSB8fCAhKHhBeGlzICYmIHlBeGlzICYmIGlzRmluaXRlTnVtYmVyKHlWYWx1ZSkpIHx8ICFkYXRhTW9kZWwpIHtcbiAgICAgIHJldHVybiBFTVBUWV9UT09MVElQX0NPTlRFTlQ7XG4gICAgfVxuICAgIGNvbnN0IHhTdHJpbmcgPSB4QXhpcy5mb3JtYXREYXR1bSh4VmFsdWUpO1xuICAgIGNvbnN0IHlTdHJpbmcgPSB5QXhpcy5mb3JtYXREYXR1bSh5VmFsdWUpO1xuICAgIGNvbnN0IHRpdGxlID0gc2FuaXRpemVIdG1sKHlOYW1lKTtcbiAgICBjb25zdCBjb250ZW50ID0gc2FuaXRpemVIdG1sKHhTdHJpbmcgKyBcIjogXCIgKyB5U3RyaW5nKTtcbiAgICBjb25zdCBiYXNlU3R5bGUgPSBtZXJnZURlZmF1bHRzKHsgZmlsbDogdGhpcy5wcm9wZXJ0aWVzLmZpbGwgfSwgbWFya2VyLmdldFN0eWxlKCksIHtcbiAgICAgIHN0cm9rZTogdGhpcy5wcm9wZXJ0aWVzLnN0cm9rZSxcbiAgICAgIHN0cm9rZVdpZHRoOiB0aGlzLnByb3BlcnRpZXMuc3Ryb2tlV2lkdGhcbiAgICB9KTtcbiAgICBjb25zdCB7IGZpbGw6IGNvbG9yIH0gPSB0aGlzLmdldE1hcmtlclN0eWxlKFxuICAgICAgbWFya2VyLFxuICAgICAgeyBkYXR1bTogbm9kZURhdHVtLCB4S2V5LCB5S2V5LCBoaWdobGlnaHRlZDogZmFsc2UgfSxcbiAgICAgIGJhc2VTdHlsZVxuICAgICk7XG4gICAgcmV0dXJuIHRvb2x0aXAudG9Ub29sdGlwSHRtbChcbiAgICAgIHsgdGl0bGUsIGNvbnRlbnQsIGJhY2tncm91bmRDb2xvcjogY29sb3IgfSxcbiAgICAgIHtcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIGl0ZW1JZCxcbiAgICAgICAgeEtleSxcbiAgICAgICAgeE5hbWUsXG4gICAgICAgIHlLZXksXG4gICAgICAgIHlOYW1lLFxuICAgICAgICBjb2xvcixcbiAgICAgICAgdGl0bGUsXG4gICAgICAgIHNlcmllc0lkXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBnZXRMZWdlbmREYXRhKGxlZ2VuZFR5cGUpIHtcbiAgICBpZiAoIXRoaXMuZGF0YT8ubGVuZ3RoIHx8ICF0aGlzLnByb3BlcnRpZXMuaXNWYWxpZCgpIHx8ICF0aGlzLnByb3BlcnRpZXMuc2hvd0luTGVnZW5kIHx8IGxlZ2VuZFR5cGUgIT09IFwiY2F0ZWdvcnlcIikge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICB5S2V5LFxuICAgICAgeU5hbWUsXG4gICAgICBmaWxsLFxuICAgICAgc3Ryb2tlLFxuICAgICAgZmlsbE9wYWNpdHksXG4gICAgICBzdHJva2VPcGFjaXR5LFxuICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICBsaW5lRGFzaCxcbiAgICAgIG1hcmtlcixcbiAgICAgIHZpc2libGUsXG4gICAgICBsZWdlbmRJdGVtTmFtZVxuICAgIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgdXNlQXJlYUZpbGwgPSAhbWFya2VyLmVuYWJsZWQgfHwgbWFya2VyLmZpbGwgPT09IHZvaWQgMDtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICBsZWdlbmRUeXBlLFxuICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgaXRlbUlkOiB5S2V5LFxuICAgICAgICBzZXJpZXNJZDogdGhpcy5pZCxcbiAgICAgICAgZW5hYmxlZDogdmlzaWJsZSxcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICB0ZXh0OiBsZWdlbmRJdGVtTmFtZSA/PyB5TmFtZSA/PyB5S2V5XG4gICAgICAgIH0sXG4gICAgICAgIHN5bWJvbHM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBtYXJrZXI6IHtcbiAgICAgICAgICAgICAgc2hhcGU6IG1hcmtlci5zaGFwZSxcbiAgICAgICAgICAgICAgZmlsbDogdXNlQXJlYUZpbGwgPyBmaWxsIDogbWFya2VyLmZpbGwsXG4gICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiB1c2VBcmVhRmlsbCA/IGZpbGxPcGFjaXR5IDogbWFya2VyLmZpbGxPcGFjaXR5LFxuICAgICAgICAgICAgICBzdHJva2U6IG1hcmtlci5zdHJva2UgPz8gc3Ryb2tlLFxuICAgICAgICAgICAgICBzdHJva2VPcGFjaXR5OiBtYXJrZXIuc3Ryb2tlT3BhY2l0eSA/PyBzdHJva2VPcGFjaXR5LFxuICAgICAgICAgICAgICBzdHJva2VXaWR0aDogbWFya2VyLnN0cm9rZVdpZHRoID8/IDAsXG4gICAgICAgICAgICAgIGVuYWJsZWQ6IG1hcmtlci5lbmFibGVkIHx8IHN0cm9rZVdpZHRoIDw9IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsaW5lOiB7XG4gICAgICAgICAgICAgIHN0cm9rZSxcbiAgICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eSxcbiAgICAgICAgICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgICAgIGxpbmVEYXNoXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBsZWdlbmRJdGVtTmFtZVxuICAgICAgfVxuICAgIF07XG4gIH1cbiAgYW5pbWF0ZUVtcHR5VXBkYXRlUmVhZHkoYW5pbWF0aW9uRGF0YSkge1xuICAgIGNvbnN0IHsgbWFya2VyU2VsZWN0aW9uLCBsYWJlbFNlbGVjdGlvbiwgY29udGV4dERhdGEsIHBhdGhzIH0gPSBhbmltYXRpb25EYXRhO1xuICAgIGNvbnN0IHsgYW5pbWF0aW9uTWFuYWdlciB9ID0gdGhpcy5jdHg7XG4gICAgdGhpcy51cGRhdGVBcmVhUGF0aHMocGF0aHMsIGNvbnRleHREYXRhKTtcbiAgICBwYXRoU3dpcGVJbkFuaW1hdGlvbih0aGlzLCBhbmltYXRpb25NYW5hZ2VyLCAuLi5wYXRocyk7XG4gICAgcmVzZXRNb3Rpb24oW21hcmtlclNlbGVjdGlvbl0sIHJlc2V0TWFya2VyUG9zaXRpb25Gbik7XG4gICAgbWFya2VyU3dpcGVTY2FsZUluQW5pbWF0aW9uKHRoaXMsIGFuaW1hdGlvbk1hbmFnZXIsIG1hcmtlclNlbGVjdGlvbik7XG4gICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJsYWJlbHNcIiwgYW5pbWF0aW9uTWFuYWdlciwgbGFiZWxTZWxlY3Rpb24pO1xuICB9XG4gIGFuaW1hdGVSZWFkeVJlc2l6ZShhbmltYXRpb25EYXRhKSB7XG4gICAgY29uc3QgeyBjb250ZXh0RGF0YSwgcGF0aHMgfSA9IGFuaW1hdGlvbkRhdGE7XG4gICAgdGhpcy51cGRhdGVBcmVhUGF0aHMocGF0aHMsIGNvbnRleHREYXRhKTtcbiAgICBzdXBlci5hbmltYXRlUmVhZHlSZXNpemUoYW5pbWF0aW9uRGF0YSk7XG4gIH1cbiAgYW5pbWF0ZVdhaXRpbmdVcGRhdGVSZWFkeShhbmltYXRpb25EYXRhKSB7XG4gICAgY29uc3QgeyBhbmltYXRpb25NYW5hZ2VyIH0gPSB0aGlzLmN0eDtcbiAgICBjb25zdCB7IG1hcmtlclNlbGVjdGlvbiwgbGFiZWxTZWxlY3Rpb24sIGNvbnRleHREYXRhLCBwYXRocywgcHJldmlvdXNDb250ZXh0RGF0YSB9ID0gYW5pbWF0aW9uRGF0YTtcbiAgICBjb25zdCBbZmlsbCwgc3Ryb2tlXSA9IHBhdGhzO1xuICAgIGlmIChmaWxsID09IG51bGwgJiYgc3Ryb2tlID09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5yZXNldE1hcmtlckFuaW1hdGlvbihhbmltYXRpb25EYXRhKTtcbiAgICB0aGlzLnJlc2V0TGFiZWxBbmltYXRpb24oYW5pbWF0aW9uRGF0YSk7XG4gICAgY29uc3QgdXBkYXRlID0gKCkgPT4ge1xuICAgICAgdGhpcy5yZXNldFBhdGhBbmltYXRpb24oYW5pbWF0aW9uRGF0YSk7XG4gICAgICB0aGlzLnVwZGF0ZUFyZWFQYXRocyhwYXRocywgY29udGV4dERhdGEpO1xuICAgIH07XG4gICAgY29uc3Qgc2tpcCA9ICgpID0+IHtcbiAgICAgIGFuaW1hdGlvbk1hbmFnZXIuc2tpcEN1cnJlbnRCYXRjaCgpO1xuICAgICAgdXBkYXRlKCk7XG4gICAgfTtcbiAgICBpZiAoY29udGV4dERhdGEgPT0gbnVsbCB8fCBwcmV2aW91c0NvbnRleHREYXRhID09IG51bGwpIHtcbiAgICAgIHVwZGF0ZSgpO1xuICAgICAgbWFya2VyRmFkZUluQW5pbWF0aW9uKHRoaXMsIGFuaW1hdGlvbk1hbmFnZXIsIFwiYWRkZWRcIiwgbWFya2VyU2VsZWN0aW9uKTtcbiAgICAgIHBhdGhGYWRlSW5BbmltYXRpb24odGhpcywgXCJmaWxsX3BhdGhfcHJvcGVydGllc1wiLCBhbmltYXRpb25NYW5hZ2VyLCBcImFkZFwiLCBmaWxsKTtcbiAgICAgIHBhdGhGYWRlSW5BbmltYXRpb24odGhpcywgXCJzdHJva2VfcGF0aF9wcm9wZXJ0aWVzXCIsIGFuaW1hdGlvbk1hbmFnZXIsIFwiYWRkXCIsIHN0cm9rZSk7XG4gICAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImxhYmVsc1wiLCBhbmltYXRpb25NYW5hZ2VyLCBsYWJlbFNlbGVjdGlvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjb250ZXh0RGF0YS5jcm9zc0ZpbHRlcmluZyAhPT0gcHJldmlvdXNDb250ZXh0RGF0YS5jcm9zc0ZpbHRlcmluZykge1xuICAgICAgc2tpcCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBmbnMgPSBwcmVwYXJlQXJlYVBhdGhBbmltYXRpb24oY29udGV4dERhdGEsIHByZXZpb3VzQ29udGV4dERhdGEpO1xuICAgIGlmIChmbnMgPT09IHZvaWQgMCkge1xuICAgICAgc2tpcCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoZm5zLnN0YXR1cyA9PT0gXCJuby1vcFwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG1hcmtlckZhZGVJbkFuaW1hdGlvbih0aGlzLCBhbmltYXRpb25NYW5hZ2VyLCB2b2lkIDAsIG1hcmtlclNlbGVjdGlvbik7XG4gICAgZnJvbVRvTW90aW9uKHRoaXMuaWQsIFwiZmlsbF9wYXRoX3Byb3BlcnRpZXNcIiwgYW5pbWF0aW9uTWFuYWdlciwgW2ZpbGxdLCBmbnMuZmlsbC5wYXRoUHJvcGVydGllcyk7XG4gICAgcGF0aE1vdGlvbih0aGlzLmlkLCBcImZpbGxfcGF0aF91cGRhdGVcIiwgYW5pbWF0aW9uTWFuYWdlciwgW2ZpbGxdLCBmbnMuZmlsbC5wYXRoKTtcbiAgICBmcm9tVG9Nb3Rpb24odGhpcy5pZCwgXCJzdHJva2VfcGF0aF9wcm9wZXJ0aWVzXCIsIGFuaW1hdGlvbk1hbmFnZXIsIFtzdHJva2VdLCBmbnMuc3Ryb2tlLnBhdGhQcm9wZXJ0aWVzKTtcbiAgICBwYXRoTW90aW9uKHRoaXMuaWQsIFwic3Ryb2tlX3BhdGhfdXBkYXRlXCIsIGFuaW1hdGlvbk1hbmFnZXIsIFtzdHJva2VdLCBmbnMuc3Ryb2tlLnBhdGgpO1xuICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwibGFiZWxzXCIsIGFuaW1hdGlvbk1hbmFnZXIsIGxhYmVsU2VsZWN0aW9uKTtcbiAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLmFuaW1hdGUoe1xuICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICBncm91cElkOiBcInJlc2V0X2FmdGVyX2FuaW1hdGlvblwiLFxuICAgICAgcGhhc2U6IFwidHJhaWxpbmdcIixcbiAgICAgIGZyb206IHt9LFxuICAgICAgdG86IHt9LFxuICAgICAgb25Db21wbGV0ZTogKCkgPT4gdGhpcy51cGRhdGVBcmVhUGF0aHMocGF0aHMsIGNvbnRleHREYXRhKVxuICAgIH0pO1xuICB9XG4gIGlzTGFiZWxFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXMubGFiZWwuZW5hYmxlZDtcbiAgfVxuICBub2RlRmFjdG9yeSgpIHtcbiAgICByZXR1cm4gbmV3IEdyb3VwKCk7XG4gIH1cbiAgZ2V0Rm9ybWF0dGVkTWFya2VyU3R5bGUoZGF0dW0pIHtcbiAgICBjb25zdCB7IHhLZXksIHlLZXkgfSA9IGRhdHVtO1xuICAgIHJldHVybiB0aGlzLmdldE1hcmtlclN0eWxlKHRoaXMucHJvcGVydGllcy5tYXJrZXIsIHsgZGF0dW0sIHhLZXksIHlLZXksIGhpZ2hsaWdodGVkOiB0cnVlIH0pO1xuICB9XG4gIGNvbXB1dGVGb2N1c0JvdW5kcyhvcHRzKSB7XG4gICAgcmV0dXJuIGNvbXB1dGVNYXJrZXJGb2N1c0JvdW5kcyh0aGlzLCBvcHRzKTtcbiAgfVxufTtcbkFyZWFTZXJpZXMuY2xhc3NOYW1lID0gXCJBcmVhU2VyaWVzXCI7XG5BcmVhU2VyaWVzLnR5cGUgPSBcImFyZWFcIjtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9hcmVhU2VyaWVzTW9kdWxlLnRzXG52YXIgQXJlYVNlcmllc01vZHVsZSA9IHtcbiAgdHlwZTogXCJzZXJpZXNcIixcbiAgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLFxuICBwYWNrYWdlVHlwZTogXCJjb21tdW5pdHlcIixcbiAgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCJdLFxuICBpZGVudGlmaWVyOiBcImFyZWFcIixcbiAgbW9kdWxlRmFjdG9yeTogKGN0eCkgPT4gbmV3IEFyZWFTZXJpZXMoY3R4KSxcbiAgc3RhY2thYmxlOiB0cnVlLFxuICB0b29sdGlwRGVmYXVsdHM6IHsgcmFuZ2U6IFwibmVhcmVzdFwiIH0sXG4gIGRlZmF1bHRBeGVzOiBbXG4gICAge1xuICAgICAgdHlwZTogXCJudW1iZXJcIiAvKiBOVU1CRVIgKi8sXG4gICAgICBwb3NpdGlvbjogXCJsZWZ0XCIgLyogTEVGVCAqL1xuICAgIH0sXG4gICAge1xuICAgICAgdHlwZTogXCJjYXRlZ29yeVwiIC8qIENBVEVHT1JZICovLFxuICAgICAgcG9zaXRpb246IFwiYm90dG9tXCIgLyogQk9UVE9NICovXG4gICAgfVxuICBdLFxuICB0aGVtZVRlbXBsYXRlOiB7XG4gICAgc2VyaWVzOiB7XG4gICAgICBub2RlQ2xpY2tSYW5nZTogXCJuZWFyZXN0XCIsXG4gICAgICB0b29sdGlwOiB7IHBvc2l0aW9uOiB7IHR5cGU6IFwibm9kZVwiIH0gfSxcbiAgICAgIGZpbGxPcGFjaXR5OiAwLjgsXG4gICAgICBzdHJva2VPcGFjaXR5OiAxLFxuICAgICAgc3Ryb2tlV2lkdGg6IDAsXG4gICAgICBsaW5lRGFzaDogWzBdLFxuICAgICAgbGluZURhc2hPZmZzZXQ6IDAsXG4gICAgICBzaGFkb3c6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIGNvbG9yOiBERUZBVUxUX1NIQURPV19DT0xPVVIsXG4gICAgICAgIHhPZmZzZXQ6IDMsXG4gICAgICAgIHlPZmZzZXQ6IDMsXG4gICAgICAgIGJsdXI6IDVcbiAgICAgIH0sXG4gICAgICBpbnRlcnBvbGF0aW9uOiB7XG4gICAgICAgIHR5cGU6IFwibGluZWFyXCIsXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSB1c2VycyBzaG91bGRuJ3Qgc3BlY2lmeSBhbGwgb3B0aW9ucywgYnV0IHdlIGhhdmUgdG8gZm9yIHRoZW1pbmcgdG8gd29ya1xuICAgICAgICB0ZW5zaW9uOiAxLFxuICAgICAgICBwb3NpdGlvbjogXCJlbmRcIlxuICAgICAgfSxcbiAgICAgIG1hcmtlcjoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgc2hhcGU6IFwiY2lyY2xlXCIsXG4gICAgICAgIHNpemU6IDcsXG4gICAgICAgIHN0cm9rZVdpZHRoOiAwXG4gICAgICB9LFxuICAgICAgbGFiZWw6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgICAgZm9udEZhbWlseTogREVGQVVMVF9GT05UX0ZBTUlMWSxcbiAgICAgICAgY29sb3I6IERFRkFVTFRfTEFCRUxfQ09MT1VSXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwYWxldHRlRmFjdG9yeTogKHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IHsgbWFya2VyIH0gPSBtYXJrZXJQYWxldHRlRmFjdG9yeShwYXJhbXMpO1xuICAgIHJldHVybiB7IGZpbGw6IG1hcmtlci5maWxsLCBzdHJva2U6IG1hcmtlci5zdHJva2UsIG1hcmtlciB9O1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC90aGVtZXMvdXRpbC50c1xuZnVuY3Rpb24gc3dhcEF4aXNDb25kaXRpb24oYXhlcywgc3dhcCkge1xuICByZXR1cm4gKHNlcmllcykgPT4ge1xuICAgIGlmICghc3dhcChzZXJpZXMpKVxuICAgICAgcmV0dXJuIGF4ZXM7XG4gICAgcmV0dXJuIFtcbiAgICAgIHsgLi4uYXhlc1swXSwgcG9zaXRpb246IGF4ZXNbMV0ucG9zaXRpb24gfSxcbiAgICAgIHsgLi4uYXhlc1sxXSwgcG9zaXRpb246IGF4ZXNbMF0ucG9zaXRpb24gfVxuICAgIF07XG4gIH07XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vcXVhZHRyZWVVdGlsLnRzXG5mdW5jdGlvbiBhZGRIaXRUZXN0ZXJzVG9RdWFkdHJlZShxdWFkdHJlZSwgaGl0VGVzdGVycykge1xuICBmb3IgKGNvbnN0IG5vZGUgb2YgaGl0VGVzdGVycykge1xuICAgIGNvbnN0IGRhdHVtID0gbm9kZS5kYXR1bTtcbiAgICBpZiAoZGF0dW0gPT09IHZvaWQgMCkge1xuICAgICAgTG9nZ2VyLmVycm9yKFwidW5kZWZpbmVkIGRhdHVtXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBxdWFkdHJlZS5hZGRWYWx1ZShub2RlLCBkYXR1bSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBmaW5kUXVhZHRyZWVNYXRjaChzZXJpZXMsIHBvaW50KSB7XG4gIGNvbnN0IHsgeCwgeSB9ID0gcG9pbnQ7XG4gIGNvbnN0IHsgbmVhcmVzdCwgZGlzdGFuY2VTcXVhcmVkOiBkaXN0YW5jZVNxdWFyZWQzIH0gPSBzZXJpZXMuZ2V0UXVhZFRyZWUoKS5maW5kKHgsIHkpO1xuICBpZiAobmVhcmVzdCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHsgZGF0dW06IG5lYXJlc3QudmFsdWUsIGRpc3RhbmNlOiBNYXRoLnNxcnQoZGlzdGFuY2VTcXVhcmVkMykgfTtcbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2Fic3RyYWN0QmFyU2VyaWVzLnRzXG52YXIgQWJzdHJhY3RCYXJTZXJpZXNQcm9wZXJ0aWVzID0gY2xhc3MgZXh0ZW5kcyBDYXJ0ZXNpYW5TZXJpZXNQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmRpcmVjdGlvbiA9IFwidmVydGljYWxcIjtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKERJUkVDVElPTilcbl0sIEFic3RyYWN0QmFyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiZGlyZWN0aW9uXCIsIDIpO1xudmFyIEFic3RyYWN0QmFyU2VyaWVzID0gY2xhc3MgZXh0ZW5kcyBDYXJ0ZXNpYW5TZXJpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gZ2V0IHRoZSBwb3NpdGlvbiBvZiBiYXJzIHdpdGhpbiBlYWNoIGdyb3VwLlxuICAgICAqL1xuICAgIHRoaXMuZ3JvdXBTY2FsZSA9IG5ldyBCYW5kU2NhbGUoKTtcbiAgICB0aGlzLnNtYWxsZXN0RGF0YUludGVydmFsID0gdm9pZCAwO1xuICAgIHRoaXMubGFyZ2VzdERhdGFJbnRlcnZhbCA9IHZvaWQgMDtcbiAgfVxuICBwYWRCYW5kRXh0ZW50KGtleXMsIGFsaWduU3RhcnQpIHtcbiAgICBjb25zdCByYXRpbzIgPSB0eXBlb2YgYWxpZ25TdGFydCA9PT0gXCJib29sZWFuXCIgPyAxIDogMC41O1xuICAgIGNvbnN0IHNjYWxlUGFkZGluZyA9IGlzRmluaXRlTnVtYmVyKHRoaXMuc21hbGxlc3REYXRhSW50ZXJ2YWwpID8gdGhpcy5zbWFsbGVzdERhdGFJbnRlcnZhbCAqIHJhdGlvMiA6IDA7XG4gICAgY29uc3Qga2V5c0V4dGVudCA9IGV4dGVudChrZXlzKSA/PyBbTmFOLCBOYU5dO1xuICAgIGlmICh0eXBlb2YgYWxpZ25TdGFydCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIGtleXNFeHRlbnRbYWxpZ25TdGFydCA/IDAgOiAxXSAtPSAoYWxpZ25TdGFydCA/IDEgOiAtMSkgKiBzY2FsZVBhZGRpbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleXNFeHRlbnRbMF0gLT0gc2NhbGVQYWRkaW5nO1xuICAgICAga2V5c0V4dGVudFsxXSArPSBzY2FsZVBhZGRpbmc7XG4gICAgfVxuICAgIHJldHVybiBmaXhOdW1lcmljRXh0ZW50KGtleXNFeHRlbnQpO1xuICB9XG4gIGdldEJhbmRTY2FsZVBhZGRpbmcoKSB7XG4gICAgcmV0dXJuIHsgaW5uZXI6IDAuMywgb3V0ZXI6IDAuMTUgfTtcbiAgfVxuICBzaG91bGRGbGlwWFkoKSB7XG4gICAgcmV0dXJuICF0aGlzLmlzVmVydGljYWwoKTtcbiAgfVxuICBpc1ZlcnRpY2FsKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXMuZGlyZWN0aW9uID09PSBcInZlcnRpY2FsXCI7XG4gIH1cbiAgZ2V0QmFyRGlyZWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnNob3VsZEZsaXBYWSgpID8gXCJ4XCIgLyogWCAqLyA6IFwieVwiIC8qIFkgKi87XG4gIH1cbiAgZ2V0Q2F0ZWdvcnlEaXJlY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2hvdWxkRmxpcFhZKCkgPyBcInlcIiAvKiBZICovIDogXCJ4XCIgLyogWCAqLztcbiAgfVxuICBnZXRWYWx1ZUF4aXMoKSB7XG4gICAgY29uc3QgZGlyZWN0aW9uID0gdGhpcy5nZXRCYXJEaXJlY3Rpb24oKTtcbiAgICByZXR1cm4gdGhpcy5heGVzW2RpcmVjdGlvbl07XG4gIH1cbiAgZ2V0Q2F0ZWdvcnlBeGlzKCkge1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IHRoaXMuZ2V0Q2F0ZWdvcnlEaXJlY3Rpb24oKTtcbiAgICByZXR1cm4gdGhpcy5heGVzW2RpcmVjdGlvbl07XG4gIH1cbiAgZ2V0QmFuZHdpZHRoKHhBeGlzKSB7XG4gICAgcmV0dXJuIENvbnRpbnVvdXNTY2FsZS5pcyh4QXhpcy5zY2FsZSkgPyB4QXhpcy5zY2FsZS5jYWxjQmFuZHdpZHRoKHRoaXMuc21hbGxlc3REYXRhSW50ZXJ2YWwpIDogeEF4aXMuc2NhbGUuYmFuZHdpZHRoO1xuICB9XG4gIHVwZGF0ZUdyb3VwU2NhbGUoeEF4aXMpIHtcbiAgICBjb25zdCBkb21haW4gPSBbXTtcbiAgICBjb25zdCB7IGdyb3VwU2NhbGUgfSA9IHRoaXM7XG4gICAgY29uc3QgeEJhbmRXaWR0aCA9IHRoaXMuZ2V0QmFuZHdpZHRoKHhBeGlzKTtcbiAgICBjb25zdCB7IGluZGV4OiBncm91cEluZGV4LCB2aXNpYmxlR3JvdXBDb3VudCB9ID0gdGhpcy5jdHguc2VyaWVzU3RhdGVNYW5hZ2VyLmdldFZpc2libGVQZWVyR3JvdXBJbmRleCh0aGlzKTtcbiAgICBmb3IgKGxldCBncm91cElkeCA9IDA7IGdyb3VwSWR4IDwgdmlzaWJsZUdyb3VwQ291bnQ7IGdyb3VwSWR4KyspIHtcbiAgICAgIGRvbWFpbi5wdXNoKFN0cmluZyhncm91cElkeCkpO1xuICAgIH1cbiAgICBncm91cFNjYWxlLmRvbWFpbiA9IGRvbWFpbjtcbiAgICBncm91cFNjYWxlLnJhbmdlID0gWzAsIHhCYW5kV2lkdGggPz8gMF07XG4gICAgaWYgKHhBeGlzIGluc3RhbmNlb2YgQ2F0ZWdvcnlBeGlzKSB7XG4gICAgICBncm91cFNjYWxlLnBhZGRpbmdJbm5lciA9IHhBeGlzLmdyb3VwUGFkZGluZ0lubmVyO1xuICAgIH0gZWxzZSBpZiAoeEF4aXMgaW5zdGFuY2VvZiBHcm91cGVkQ2F0ZWdvcnlBeGlzKSB7XG4gICAgICBncm91cFNjYWxlLnBhZGRpbmcgPSAwLjE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdyb3VwU2NhbGUucGFkZGluZyA9IDA7XG4gICAgfVxuICAgIGdyb3VwU2NhbGUucm91bmQgPSBncm91cFNjYWxlLnBhZGRpbmcgIT09IDA7XG4gICAgY29uc3QgYmFyV2lkdGggPSBncm91cFNjYWxlLmJhbmR3aWR0aCA+PSAxID8gKFxuICAgICAgLy8gUGl4ZWwtcm91bmRlZCB2YWx1ZSBmb3IgbG93LXZvbHVtZSBiYXIgY2hhcnRzLlxuICAgICAgZ3JvdXBTY2FsZS5iYW5kd2lkdGhcbiAgICApIDogKFxuICAgICAgLy8gSGFuZGxlIGhpZ2gtdm9sdW1lIGJhciBjaGFydHMgZ3JhY2VmdWxseS5cbiAgICAgIGdyb3VwU2NhbGUucmF3QmFuZHdpZHRoXG4gICAgKTtcbiAgICByZXR1cm4geyBiYXJXaWR0aCwgZ3JvdXBJbmRleCB9O1xuICB9XG4gIHJlc29sdmVLZXlEaXJlY3Rpb24oZGlyZWN0aW9uKSB7XG4gICAgaWYgKHRoaXMuZ2V0QmFyRGlyZWN0aW9uKCkgPT09IFwieFwiIC8qIFggKi8pIHtcbiAgICAgIGlmIChkaXJlY3Rpb24gPT09IFwieFwiIC8qIFggKi8pIHtcbiAgICAgICAgcmV0dXJuIFwieVwiIC8qIFkgKi87XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJ4XCIgLyogWCAqLztcbiAgICB9XG4gICAgcmV0dXJuIGRpcmVjdGlvbjtcbiAgfVxuICBpbml0UXVhZFRyZWUocXVhZHRyZWUpIHtcbiAgICBhZGRIaXRUZXN0ZXJzVG9RdWFkdHJlZShxdWFkdHJlZSwgdGhpcy5kYXR1bU5vZGVzSXRlcigpKTtcbiAgfVxuICBwaWNrTm9kZUNsb3Nlc3REYXR1bShwb2ludCkge1xuICAgIHJldHVybiBmaW5kUXVhZHRyZWVNYXRjaCh0aGlzLCBwb2ludCk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vYmFyU2VyaWVzUHJvcGVydGllcy50c1xudmFyIEJhclNlcmllc0xhYmVsID0gY2xhc3MgZXh0ZW5kcyBMYWJlbCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5wbGFjZW1lbnQgPSBcImluc2lkZS1jZW50ZXJcIjtcbiAgICB0aGlzLnBhZGRpbmcgPSAwO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoXG4gICAgVU5JT04oXG4gICAgICBbXG4gICAgICAgIFwiaW5zaWRlLWNlbnRlclwiLFxuICAgICAgICBcImluc2lkZS1zdGFydFwiLFxuICAgICAgICBcImluc2lkZS1lbmRcIixcbiAgICAgICAgXCJvdXRzaWRlLXN0YXJ0XCIsXG4gICAgICAgIFwib3V0c2lkZS1lbmRcIixcbiAgICAgICAgLy8gQHRvZG8oQUctNTk1MCkgRGVwcmVjYXRlXG4gICAgICAgIHsgdmFsdWU6IFwiaW5zaWRlXCIsIGRlcHJlY2F0ZWRUbzogXCJpbnNpZGUtY2VudGVyXCIgfSxcbiAgICAgICAgeyB2YWx1ZTogXCJvdXRzaWRlXCIsIGRlcHJlY2F0ZWRUbzogXCJvdXRzaWRlLWVuZFwiIH1cbiAgICAgIF0sXG4gICAgICBcImEgcGxhY2VtZW50XCJcbiAgICApXG4gIClcbl0sIEJhclNlcmllc0xhYmVsLnByb3RvdHlwZSwgXCJwbGFjZW1lbnRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShOVU1CRVIpXG5dLCBCYXJTZXJpZXNMYWJlbC5wcm90b3R5cGUsIFwicGFkZGluZ1wiLCAyKTtcbnZhciBCYXJTZXJpZXNQcm9wZXJ0aWVzID0gY2xhc3MgZXh0ZW5kcyBBYnN0cmFjdEJhclNlcmllc1Byb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuZmlsbCA9IFwiI2MxNjA2OFwiO1xuICAgIHRoaXMuZmlsbE9wYWNpdHkgPSAxO1xuICAgIHRoaXMuc3Ryb2tlID0gXCIjODc0MzQ5XCI7XG4gICAgdGhpcy5zdHJva2VXaWR0aCA9IDE7XG4gICAgdGhpcy5zdHJva2VPcGFjaXR5ID0gMTtcbiAgICB0aGlzLmxpbmVEYXNoID0gWzBdO1xuICAgIHRoaXMubGluZURhc2hPZmZzZXQgPSAwO1xuICAgIHRoaXMuY29ybmVyUmFkaXVzID0gMDtcbiAgICB0aGlzLmNyaXNwID0gdm9pZCAwO1xuICAgIHRoaXMuc2hhZG93ID0gbmV3IERyb3BTaGFkb3coKTtcbiAgICB0aGlzLmxhYmVsID0gbmV3IEJhclNlcmllc0xhYmVsKCk7XG4gICAgdGhpcy50b29sdGlwID0gbmV3IFNlcmllc1Rvb2x0aXAoKTtcbiAgICB0aGlzLnNwYXJrbGluZU1vZGUgPSBmYWxzZTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORylcbl0sIEJhclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInhLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEJhclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInhOYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HKVxuXSwgQmFyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwieUtleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQmFyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwieU5hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEJhclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInlGaWx0ZXJLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEJhclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0YWNrR3JvdXBcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShOVU1CRVIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEJhclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcIm5vcm1hbGl6ZWRUb1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORylcbl0sIEJhclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImZpbGxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTylcbl0sIEJhclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImZpbGxPcGFjaXR5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HKVxuXSwgQmFyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic3Ryb2tlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgQmFyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic3Ryb2tlV2lkdGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTylcbl0sIEJhclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0cm9rZU9wYWNpdHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShMSU5FX0RBU0gpXG5dLCBCYXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJsaW5lRGFzaFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIEJhclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImxpbmVEYXNoT2Zmc2V0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgQmFyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiY29ybmVyUmFkaXVzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQmFyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiY3Jpc3BcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGVU5DVElPTiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQmFyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiaXRlbVN0eWxlclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVCwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQmFyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic2hhZG93XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgQmFyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGFiZWxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBCYXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ0b29sdGlwXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIEJhclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInNwYXJrbGluZU1vZGVcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vYmFyVXRpbC50c1xuZnVuY3Rpb24gdXBkYXRlUmVjdChyZWN0LCBjb25maWcpIHtcbiAgcmVjdC5jcmlzcCA9IGNvbmZpZy5jcmlzcCA/PyB0cnVlO1xuICByZWN0LmZpbGwgPSBjb25maWcuZmlsbDtcbiAgcmVjdC5zdHJva2UgPSBjb25maWcuc3Ryb2tlO1xuICByZWN0LnN0cm9rZVdpZHRoID0gY29uZmlnLnN0cm9rZVdpZHRoO1xuICByZWN0LmZpbGxPcGFjaXR5ID0gY29uZmlnLmZpbGxPcGFjaXR5O1xuICByZWN0LnN0cm9rZU9wYWNpdHkgPSBjb25maWcuc3Ryb2tlT3BhY2l0eTtcbiAgcmVjdC5saW5lRGFzaCA9IGNvbmZpZy5saW5lRGFzaDtcbiAgcmVjdC5saW5lRGFzaE9mZnNldCA9IGNvbmZpZy5saW5lRGFzaE9mZnNldDtcbiAgcmVjdC5maWxsU2hhZG93ID0gY29uZmlnLmZpbGxTaGFkb3c7XG4gIHJlY3QudG9wTGVmdENvcm5lclJhZGl1cyA9IGNvbmZpZy50b3BMZWZ0Q29ybmVyUmFkaXVzICE9PSBmYWxzZSA/IGNvbmZpZy5jb3JuZXJSYWRpdXMgPz8gMCA6IDA7XG4gIHJlY3QudG9wUmlnaHRDb3JuZXJSYWRpdXMgPSBjb25maWcudG9wUmlnaHRDb3JuZXJSYWRpdXMgIT09IGZhbHNlID8gY29uZmlnLmNvcm5lclJhZGl1cyA/PyAwIDogMDtcbiAgcmVjdC5ib3R0b21SaWdodENvcm5lclJhZGl1cyA9IGNvbmZpZy5ib3R0b21SaWdodENvcm5lclJhZGl1cyAhPT0gZmFsc2UgPyBjb25maWcuY29ybmVyUmFkaXVzID8/IDAgOiAwO1xuICByZWN0LmJvdHRvbUxlZnRDb3JuZXJSYWRpdXMgPSBjb25maWcuYm90dG9tTGVmdENvcm5lclJhZGl1cyAhPT0gZmFsc2UgPyBjb25maWcuY29ybmVyUmFkaXVzID8/IDAgOiAwO1xuICByZWN0LnZpc2libGUgPSBjb25maWcudmlzaWJsZSA/PyB0cnVlO1xufVxuZnVuY3Rpb24gZ2V0UmVjdENvbmZpZyh7XG4gIGRhdHVtLFxuICBpc0hpZ2hsaWdodGVkLFxuICBzdHlsZSxcbiAgaGlnaGxpZ2h0U3R5bGUsXG4gIGl0ZW1TdHlsZXIsXG4gIHNlcmllc0lkLFxuICBjdHg6IHsgY2FsbGJhY2tDYWNoZSB9LFxuICAuLi5vcHRzXG59KSB7XG4gIGNvbnN0IHtcbiAgICBmaWxsLFxuICAgIGZpbGxPcGFjaXR5LFxuICAgIHN0cm9rZSxcbiAgICBzdHJva2VXaWR0aCxcbiAgICBzdHJva2VPcGFjaXR5LFxuICAgIGxpbmVEYXNoLFxuICAgIGxpbmVEYXNoT2Zmc2V0LFxuICAgIGNvcm5lclJhZGl1cyA9IDBcbiAgfSA9IG1lcmdlRGVmYXVsdHMoaXNIaWdobGlnaHRlZCAmJiBoaWdobGlnaHRTdHlsZSwgc3R5bGUpO1xuICBsZXQgZm9ybWF0O1xuICBpZiAoaXRlbVN0eWxlcikge1xuICAgIGZvcm1hdCA9IGNhbGxiYWNrQ2FjaGUuY2FsbChpdGVtU3R5bGVyLCB7XG4gICAgICBkYXR1bTogZGF0dW0uZGF0dW0sXG4gICAgICB4S2V5OiBkYXR1bS54S2V5LFxuICAgICAgZmlsbCxcbiAgICAgIGZpbGxPcGFjaXR5LFxuICAgICAgc3Ryb2tlLFxuICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICBzdHJva2VPcGFjaXR5LFxuICAgICAgbGluZURhc2gsXG4gICAgICBsaW5lRGFzaE9mZnNldCxcbiAgICAgIGNvcm5lclJhZGl1cyxcbiAgICAgIGhpZ2hsaWdodGVkOiBpc0hpZ2hsaWdodGVkLFxuICAgICAgc2VyaWVzSWQsXG4gICAgICAuLi5vcHRzXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBmaWxsOiBmb3JtYXQ/LmZpbGwgPz8gZmlsbCxcbiAgICBmaWxsT3BhY2l0eTogZm9ybWF0Py5maWxsT3BhY2l0eSA/PyBmaWxsT3BhY2l0eSxcbiAgICBzdHJva2U6IGZvcm1hdD8uc3Ryb2tlID8/IHN0cm9rZSxcbiAgICBzdHJva2VXaWR0aDogZm9ybWF0Py5zdHJva2VXaWR0aCA/PyBzdHJva2VXaWR0aCxcbiAgICBzdHJva2VPcGFjaXR5OiBmb3JtYXQ/LnN0cm9rZU9wYWNpdHkgPz8gc3Ryb2tlT3BhY2l0eSxcbiAgICBsaW5lRGFzaDogZm9ybWF0Py5saW5lRGFzaCA/PyBsaW5lRGFzaCxcbiAgICBsaW5lRGFzaE9mZnNldDogZm9ybWF0Py5saW5lRGFzaE9mZnNldCA/PyBsaW5lRGFzaE9mZnNldCxcbiAgICBjb3JuZXJSYWRpdXM6IGZvcm1hdD8uY29ybmVyUmFkaXVzID8/IGNvcm5lclJhZGl1cyxcbiAgICB0b3BMZWZ0Q29ybmVyUmFkaXVzOiBzdHlsZS50b3BMZWZ0Q29ybmVyUmFkaXVzLFxuICAgIHRvcFJpZ2h0Q29ybmVyUmFkaXVzOiBzdHlsZS50b3BSaWdodENvcm5lclJhZGl1cyxcbiAgICBib3R0b21SaWdodENvcm5lclJhZGl1czogc3R5bGUuYm90dG9tUmlnaHRDb3JuZXJSYWRpdXMsXG4gICAgYm90dG9tTGVmdENvcm5lclJhZGl1czogc3R5bGUuYm90dG9tTGVmdENvcm5lclJhZGl1cyxcbiAgICBmaWxsU2hhZG93OiBzdHlsZS5maWxsU2hhZG93XG4gIH07XG59XG5mdW5jdGlvbiBjaGVja0NyaXNwKHNjYWxlMiwgdmlzaWJsZVJhbmdlLCBzbWFsbGVzdERhdGFJbnRlcnZhbCwgbGFyZ2VzdERhdGFJbnRlcnZhbCkge1xuICBpZiAodmlzaWJsZVJhbmdlICE9IG51bGwpIHtcbiAgICBjb25zdCBbdmlzaWJsZU1pbiwgdmlzaWJsZU1heF0gPSB2aXNpYmxlUmFuZ2U7XG4gICAgY29uc3QgaXNab29tZWQgPSB2aXNpYmxlTWluICE9PSAwIHx8IHZpc2libGVNYXggIT09IDE7XG4gICAgaWYgKGlzWm9vbWVkKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChDb250aW51b3VzU2NhbGUuaXMoc2NhbGUyKSkge1xuICAgIGNvbnN0IHNwYWNpbmcgPSBzY2FsZTIuY2FsY0JhbmR3aWR0aChsYXJnZXN0RGF0YUludGVydmFsKSAtIHNjYWxlMi5jYWxjQmFuZHdpZHRoKHNtYWxsZXN0RGF0YUludGVydmFsKTtcbiAgICBpZiAoc3BhY2luZyA+IDAgJiYgc3BhY2luZyA8IDEpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG52YXIgaXNEYXR1bU5lZ2F0aXZlID0gKGRhdHVtKSA9PiB7XG4gIHJldHVybiBpc05lZ2F0aXZlKGRhdHVtLnlWYWx1ZSA/PyAwKTtcbn07XG5mdW5jdGlvbiBjb2xsYXBzZWRTdGFydGluZ0JhclBvc2l0aW9uKGlzVmVydGljYWwsIGF4ZXMsIG1vZGUpIHtcbiAgY29uc3QgeyBzdGFydGluZ1gsIHN0YXJ0aW5nWSB9ID0gZ2V0U3RhcnRpbmdWYWx1ZXMoaXNWZXJ0aWNhbCwgYXhlcyk7XG4gIGNvbnN0IGNhbGN1bGF0ZSA9IChkYXR1bSwgcHJldkRhdHVtKSA9PiB7XG4gICAgbGV0IHggPSBpc1ZlcnRpY2FsID8gZGF0dW0ueCA6IHN0YXJ0aW5nWDtcbiAgICBsZXQgeSA9IGlzVmVydGljYWwgPyBzdGFydGluZ1kgOiBkYXR1bS55O1xuICAgIGxldCB3aWR0aDIgPSBpc1ZlcnRpY2FsID8gZGF0dW0ud2lkdGggOiAwO1xuICAgIGxldCBoZWlnaHQyID0gaXNWZXJ0aWNhbCA/IDAgOiBkYXR1bS5oZWlnaHQ7XG4gICAgY29uc3QgeyBvcGFjaXR5IH0gPSBkYXR1bTtcbiAgICBpZiAocHJldkRhdHVtICYmIChpc05hTih4KSB8fCBpc05hTih5KSkpIHtcbiAgICAgICh7IHgsIHkgfSA9IHByZXZEYXR1bSk7XG4gICAgICB3aWR0aDIgPSBpc1ZlcnRpY2FsID8gcHJldkRhdHVtLndpZHRoIDogMDtcbiAgICAgIGhlaWdodDIgPSBpc1ZlcnRpY2FsID8gMCA6IHByZXZEYXR1bS5oZWlnaHQ7XG4gICAgICBpZiAoaXNWZXJ0aWNhbCAmJiAhaXNEYXR1bU5lZ2F0aXZlKHByZXZEYXR1bSkpIHtcbiAgICAgICAgeSArPSBwcmV2RGF0dW0uaGVpZ2h0O1xuICAgICAgfSBlbHNlIGlmICghaXNWZXJ0aWNhbCAmJiBpc0RhdHVtTmVnYXRpdmUocHJldkRhdHVtKSkge1xuICAgICAgICB4ICs9IHByZXZEYXR1bS53aWR0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGNsaXBCQm94O1xuICAgIGlmIChkYXR1bS5jbGlwQkJveCA9PSBudWxsKSB7XG4gICAgICBjbGlwQkJveCA9IHZvaWQgMDtcbiAgICB9IGVsc2UgaWYgKGlzRGF0dW1OZWdhdGl2ZShkYXR1bSkpIHtcbiAgICAgIGNsaXBCQm94ID0gaXNWZXJ0aWNhbCA/IG5ldyBCQm94KHgsIHkgLSBoZWlnaHQyLCB3aWR0aDIsIGhlaWdodDIpIDogbmV3IEJCb3goeCAtIHdpZHRoMiwgeSwgd2lkdGgyLCBoZWlnaHQyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xpcEJCb3ggPSBuZXcgQkJveCh4LCB5LCB3aWR0aDIsIGhlaWdodDIpO1xuICAgIH1cbiAgICByZXR1cm4geyB4LCB5LCB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIsIGNsaXBCQm94LCBvcGFjaXR5IH07XG4gIH07XG4gIHJldHVybiB7IGlzVmVydGljYWwsIGNhbGN1bGF0ZSwgbW9kZSB9O1xufVxuZnVuY3Rpb24gbWlkcG9pbnRTdGFydGluZ0JhclBvc2l0aW9uKGlzVmVydGljYWwsIG1vZGUpIHtcbiAgcmV0dXJuIHtcbiAgICBpc1ZlcnRpY2FsLFxuICAgIGNhbGN1bGF0ZTogKGRhdHVtKSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBpc1ZlcnRpY2FsID8gZGF0dW0ueCA6IGRhdHVtLnggKyBkYXR1bS53aWR0aCAvIDIsXG4gICAgICAgIHk6IGlzVmVydGljYWwgPyBkYXR1bS55ICsgZGF0dW0uaGVpZ2h0IC8gMiA6IGRhdHVtLnksXG4gICAgICAgIHdpZHRoOiBpc1ZlcnRpY2FsID8gZGF0dW0ud2lkdGggOiAwLFxuICAgICAgICBoZWlnaHQ6IGlzVmVydGljYWwgPyAwIDogZGF0dW0uaGVpZ2h0LFxuICAgICAgICBjbGlwQkJveDogZGF0dW0uY2xpcEJCb3gsXG4gICAgICAgIG9wYWNpdHk6IGRhdHVtLm9wYWNpdHlcbiAgICAgIH07XG4gICAgfSxcbiAgICBtb2RlXG4gIH07XG59XG5mdW5jdGlvbiBwcmVwYXJlQmFyQW5pbWF0aW9uRnVuY3Rpb25zKGluaXRQb3MpIHtcbiAgY29uc3QgaXNSZW1vdmVkID0gKGRhdHVtKSA9PiBkYXR1bSA9PSBudWxsIHx8IGlzTmFOKGRhdHVtLngpIHx8IGlzTmFOKGRhdHVtLnkpO1xuICBjb25zdCBmcm9tRm4gPSAocmVjdCwgZGF0dW0sIHN0YXR1cykgPT4ge1xuICAgIGlmIChzdGF0dXMgPT09IFwidXBkYXRlZFwiICYmIGlzUmVtb3ZlZChkYXR1bSkpIHtcbiAgICAgIHN0YXR1cyA9IFwicmVtb3ZlZFwiO1xuICAgIH0gZWxzZSBpZiAoc3RhdHVzID09PSBcInVwZGF0ZWRcIiAmJiBpc1JlbW92ZWQocmVjdC5wcmV2aW91c0RhdHVtKSkge1xuICAgICAgc3RhdHVzID0gXCJhZGRlZFwiO1xuICAgIH1cbiAgICBsZXQgc291cmNlO1xuICAgIGlmIChzdGF0dXMgPT09IFwiYWRkZWRcIiAmJiByZWN0LnByZXZpb3VzRGF0dW0gPT0gbnVsbCAmJiBpbml0UG9zLm1vZGUgPT09IFwiZmFkZVwiKSB7XG4gICAgICBzb3VyY2UgPSB7IC4uLnJlc2V0QmFyU2VsZWN0aW9uc0ZuKHJlY3QsIGRhdHVtKSwgb3BhY2l0eTogMCB9O1xuICAgIH0gZWxzZSBpZiAoc3RhdHVzID09PSBcInVua25vd25cIiB8fCBzdGF0dXMgPT09IFwiYWRkZWRcIikge1xuICAgICAgc291cmNlID0gaW5pdFBvcy5jYWxjdWxhdGUoZGF0dW0sIHJlY3QucHJldmlvdXNEYXR1bSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNvdXJjZSA9IHtcbiAgICAgICAgeDogcmVjdC54LFxuICAgICAgICB5OiByZWN0LnksXG4gICAgICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0LFxuICAgICAgICBjbGlwQkJveDogcmVjdC5jbGlwQkJveCxcbiAgICAgICAgb3BhY2l0eTogcmVjdC5vcGFjaXR5XG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBwaGFzZSA9IE5PREVfVVBEQVRFX1NUQVRFX1RPX1BIQVNFX01BUFBJTkdbc3RhdHVzXTtcbiAgICByZXR1cm4geyAuLi5zb3VyY2UsIHBoYXNlIH07XG4gIH07XG4gIGNvbnN0IHRvRm4gPSAocmVjdCwgZGF0dW0sIHN0YXR1cykgPT4ge1xuICAgIGxldCBzb3VyY2U7XG4gICAgaWYgKHN0YXR1cyA9PT0gXCJyZW1vdmVkXCIgJiYgcmVjdC5kYXR1bSA9PSBudWxsICYmIGluaXRQb3MubW9kZSA9PT0gXCJmYWRlXCIpIHtcbiAgICAgIHNvdXJjZSA9IHsgLi4ucmVzZXRCYXJTZWxlY3Rpb25zRm4ocmVjdCwgZGF0dW0pLCBvcGFjaXR5OiAwIH07XG4gICAgfSBlbHNlIGlmIChzdGF0dXMgPT09IFwicmVtb3ZlZFwiIHx8IGlzUmVtb3ZlZChkYXR1bSkpIHtcbiAgICAgIHNvdXJjZSA9IGluaXRQb3MuY2FsY3VsYXRlKGRhdHVtLCByZWN0LnByZXZpb3VzRGF0dW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzb3VyY2UgPSB7XG4gICAgICAgIHg6IGRhdHVtLngsXG4gICAgICAgIHk6IGRhdHVtLnksXG4gICAgICAgIHdpZHRoOiBkYXR1bS53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBkYXR1bS5oZWlnaHQsXG4gICAgICAgIGNsaXBCQm94OiBkYXR1bS5jbGlwQkJveCxcbiAgICAgICAgb3BhY2l0eTogZGF0dW0ub3BhY2l0eVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfTtcbiAgcmV0dXJuIHsgdG9GbiwgZnJvbUZuIH07XG59XG5mdW5jdGlvbiBnZXRTdGFydGluZ1ZhbHVlcyhpc1ZlcnRpY2FsLCBheGVzKSB7XG4gIGNvbnN0IGF4aXMgPSBheGVzW2lzVmVydGljYWwgPyBcInlcIiAvKiBZICovIDogXCJ4XCIgLyogWCAqL107XG4gIGxldCBzdGFydGluZ1ggPSBJbmZpbml0eTtcbiAgbGV0IHN0YXJ0aW5nWSA9IDA7XG4gIGlmICghYXhpcykge1xuICAgIHJldHVybiB7IHN0YXJ0aW5nWCwgc3RhcnRpbmdZIH07XG4gIH1cbiAgaWYgKGlzVmVydGljYWwpIHtcbiAgICBzdGFydGluZ1kgPSBheGlzLnNjYWxlLmNvbnZlcnQoQ29udGludW91c1NjYWxlLmlzKGF4aXMuc2NhbGUpID8gMCA6IE1hdGgubWF4KC4uLmF4aXMucmFuZ2UpKTtcbiAgfSBlbHNlIHtcbiAgICBzdGFydGluZ1ggPSBheGlzLnNjYWxlLmNvbnZlcnQoQ29udGludW91c1NjYWxlLmlzKGF4aXMuc2NhbGUpID8gMCA6IE1hdGgubWluKC4uLmF4aXMucmFuZ2UpKTtcbiAgfVxuICByZXR1cm4geyBzdGFydGluZ1gsIHN0YXJ0aW5nWSB9O1xufVxuZnVuY3Rpb24gcmVzZXRCYXJTZWxlY3Rpb25zRm4oX25vZGUsIHsgeCwgeSwgd2lkdGg6IHdpZHRoMiwgaGVpZ2h0OiBoZWlnaHQyLCBjbGlwQkJveCwgb3BhY2l0eSB9KSB7XG4gIHJldHVybiB7IHgsIHksIHdpZHRoOiB3aWR0aDIsIGhlaWdodDogaGVpZ2h0MiwgY2xpcEJCb3gsIG9wYWNpdHkgfTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVCYXJGb2N1c0JvdW5kcyhkYXR1bSwgYmFyR3JvdXAsIHNlcmllc1JlY3QpIHtcbiAgaWYgKGRhdHVtID09PSB2b2lkIDApXG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgY29uc3QgeyB4LCB5LCB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIgfSA9IGRhdHVtO1xuICByZXR1cm4gVHJhbnNmb3JtYWJsZS50b0NhbnZhcyhiYXJHcm91cCwgbmV3IEJCb3goeCwgeSwgd2lkdGgyLCBoZWlnaHQyKSkuY2xpcChzZXJpZXNSZWN0KTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9sYWJlbFV0aWwudHNcbmZ1bmN0aW9uIHVwZGF0ZUxhYmVsTm9kZSh0ZXh0Tm9kZSwgbGFiZWwsIGxhYmVsRGF0dW0pIHtcbiAgaWYgKGxhYmVsLmVuYWJsZWQgJiYgbGFiZWxEYXR1bSkge1xuICAgIGNvbnN0IHsgeCwgeSwgdGV4dCwgdGV4dEFsaWduLCB0ZXh0QmFzZWxpbmUgfSA9IGxhYmVsRGF0dW07XG4gICAgY29uc3QgeyBjb2xvcjogZmlsbCwgZm9udFN0eWxlLCBmb250V2VpZ2h0LCBmb250U2l6ZSwgZm9udEZhbWlseSB9ID0gbGFiZWw7XG4gICAgdGV4dE5vZGUuc2V0UHJvcGVydGllcyh7XG4gICAgICB2aXNpYmxlOiB0cnVlLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB0ZXh0LFxuICAgICAgZmlsbCxcbiAgICAgIGZvbnRTdHlsZSxcbiAgICAgIGZvbnRXZWlnaHQsXG4gICAgICBmb250U2l6ZSxcbiAgICAgIGZvbnRGYW1pbHksXG4gICAgICB0ZXh0QWxpZ24sXG4gICAgICB0ZXh0QmFzZWxpbmVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0ZXh0Tm9kZS52aXNpYmxlID0gZmFsc2U7XG4gIH1cbn1cbnZhciBwbGFjZW1lbnRzID0ge1xuICBcImluc2lkZS1zdGFydFwiOiB7IGluc2lkZTogdHJ1ZSwgZGlyZWN0aW9uOiAtMSwgdGV4dEFsaWdubWVudDogMSB9LFxuICBcImluc2lkZS1lbmRcIjogeyBpbnNpZGU6IHRydWUsIGRpcmVjdGlvbjogMSwgdGV4dEFsaWdubWVudDogLTEgfSxcbiAgXCJvdXRzaWRlLXN0YXJ0XCI6IHsgaW5zaWRlOiBmYWxzZSwgZGlyZWN0aW9uOiAtMSwgdGV4dEFsaWdubWVudDogLTEgfSxcbiAgXCJvdXRzaWRlLWVuZFwiOiB7IGluc2lkZTogZmFsc2UsIGRpcmVjdGlvbjogMSwgdGV4dEFsaWdubWVudDogMSB9XG59O1xuZnVuY3Rpb24gYWRqdXN0TGFiZWxQbGFjZW1lbnQoe1xuICBpc1Vwd2FyZCxcbiAgaXNWZXJ0aWNhbCxcbiAgcGxhY2VtZW50LFxuICBwYWRkaW5nID0gMCxcbiAgcmVjdFxufSkge1xuICBsZXQgeCA9IHJlY3QueCArIHJlY3Qud2lkdGggLyAyO1xuICBsZXQgeSA9IHJlY3QueSArIHJlY3QuaGVpZ2h0IC8gMjtcbiAgbGV0IHRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gIGxldCB0ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xuICBpZiAocGxhY2VtZW50ICE9PSBcImluc2lkZS1jZW50ZXJcIikge1xuICAgIGNvbnN0IGJhckRpcmVjdGlvbiA9IChpc1Vwd2FyZCA/IDEgOiAtMSkgKiAoaXNWZXJ0aWNhbCA/IC0xIDogMSk7XG4gICAgY29uc3QgeyBkaXJlY3Rpb24sIHRleHRBbGlnbm1lbnQgfSA9IHBsYWNlbWVudHNbcGxhY2VtZW50XTtcbiAgICBjb25zdCBkaXNwbGFjZW1lbnRSYXRpbyA9IChkaXJlY3Rpb24gKyAxKSAqIDAuNTtcbiAgICBpZiAoaXNWZXJ0aWNhbCkge1xuICAgICAgY29uc3QgeTAgPSBpc1Vwd2FyZCA/IHJlY3QueSArIHJlY3QuaGVpZ2h0IDogcmVjdC55O1xuICAgICAgY29uc3QgaGVpZ2h0MiA9IHJlY3QuaGVpZ2h0ICogYmFyRGlyZWN0aW9uO1xuICAgICAgeSA9IHkwICsgaGVpZ2h0MiAqIGRpc3BsYWNlbWVudFJhdGlvICsgcGFkZGluZyAqIHRleHRBbGlnbm1lbnQgKiBiYXJEaXJlY3Rpb247XG4gICAgICB0ZXh0QmFzZWxpbmUgPSB0ZXh0QWxpZ25tZW50ID09PSBiYXJEaXJlY3Rpb24gPyBcInRvcFwiIDogXCJib3R0b21cIjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgeDAgPSBpc1Vwd2FyZCA/IHJlY3QueCA6IHJlY3QueCArIHJlY3Qud2lkdGg7XG4gICAgICBjb25zdCB3aWR0aDIgPSByZWN0LndpZHRoICogYmFyRGlyZWN0aW9uO1xuICAgICAgeCA9IHgwICsgd2lkdGgyICogZGlzcGxhY2VtZW50UmF0aW8gKyBwYWRkaW5nICogdGV4dEFsaWdubWVudCAqIGJhckRpcmVjdGlvbjtcbiAgICAgIHRleHRBbGlnbiA9IHRleHRBbGlnbm1lbnQgPT09IGJhckRpcmVjdGlvbiA/IFwibGVmdFwiIDogXCJyaWdodFwiO1xuICAgIH1cbiAgfVxuICByZXR1cm4geyB4LCB5LCB0ZXh0QWxpZ24sIHRleHRCYXNlbGluZSB9O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2JhclNlcmllcy50c1xudmFyIGxhYmVsUGxhY2VtZW50czIgPSB7XG4gIFwiaW5zaWRlLWNlbnRlclwiOiBcImluc2lkZS1jZW50ZXJcIixcbiAgXCJpbnNpZGUtc3RhcnRcIjogXCJpbnNpZGUtc3RhcnRcIixcbiAgXCJpbnNpZGUtZW5kXCI6IFwiaW5zaWRlLWVuZFwiLFxuICBcIm91dHNpZGUtc3RhcnRcIjogXCJvdXRzaWRlLXN0YXJ0XCIsXG4gIFwib3V0c2lkZS1lbmRcIjogXCJvdXRzaWRlLWVuZFwiLFxuICBpbnNpZGU6IFwiaW5zaWRlLWNlbnRlclwiLFxuICBvdXRzaWRlOiBcIm91dHNpZGUtZW5kXCJcbn07XG52YXIgQmFyU2VyaWVzID0gY2xhc3MgZXh0ZW5kcyBBYnN0cmFjdEJhclNlcmllcyB7XG4gIGNvbnN0cnVjdG9yKG1vZHVsZUN0eCkge1xuICAgIHN1cGVyKHtcbiAgICAgIG1vZHVsZUN0eCxcbiAgICAgIGRpcmVjdGlvbktleXM6IERFRkFVTFRfQ0FSVEVTSUFOX0RJUkVDVElPTl9LRVlTLFxuICAgICAgZGlyZWN0aW9uTmFtZXM6IERFRkFVTFRfQ0FSVEVTSUFOX0RJUkVDVElPTl9OQU1FUyxcbiAgICAgIHBpY2tNb2RlczogW1xuICAgICAgICAyIC8qIEFYSVNfQUxJR05FRCAqLyxcbiAgICAgICAgLy8gT25seSB1c2VkIGluIHNwYXJrbGluZU1vZGVcbiAgICAgICAgMSAvKiBORUFSRVNUX05PREUgKi8sXG4gICAgICAgIDAgLyogRVhBQ1RfU0hBUEVfTUFUQ0ggKi9cbiAgICAgIF0sXG4gICAgICBwYXRoc1BlclNlcmllczogW10sXG4gICAgICBoYXNIaWdobGlnaHRlZExhYmVsczogdHJ1ZSxcbiAgICAgIGRhdHVtU2VsZWN0aW9uR2FyYmFnZUNvbGxlY3Rpb246IGZhbHNlLFxuICAgICAgYW5pbWF0aW9uQWx3YXlzVXBkYXRlU2VsZWN0aW9uczogdHJ1ZSxcbiAgICAgIGFuaW1hdGlvblJlc2V0Rm5zOiB7XG4gICAgICAgIGRhdHVtOiByZXNldEJhclNlbGVjdGlvbnNGbixcbiAgICAgICAgbGFiZWw6IHJlc2V0TGFiZWxGblxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMucHJvcGVydGllcyA9IG5ldyBCYXJTZXJpZXNQcm9wZXJ0aWVzKCk7XG4gIH1cbiAgZ2V0IHBpY2tNb2RlQXhpcygpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLnNwYXJrbGluZU1vZGUgPyBcIm1haW5cIiA6IHZvaWQgMDtcbiAgfVxuICBjcm9zc0ZpbHRlcmluZ0VuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcGVydGllcy55RmlsdGVyS2V5ICE9IG51bGwgJiYgKHRoaXMuc2VyaWVzR3JvdXBpbmcgPT0gbnVsbCB8fCB0aGlzLnNlcmllc0dyb3VwaW5nLnN0YWNrSW5kZXggPT09IDApO1xuICB9XG4gIGFzeW5jIHByb2Nlc3NEYXRhKGRhdGFDb250cm9sbGVyKSB7XG4gICAgaWYgKCF0aGlzLnByb3BlcnRpZXMuaXNWYWxpZCgpIHx8ICF0aGlzLmRhdGEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBzZXJpZXNHcm91cGluZzogeyBncm91cEluZGV4ID0gdGhpcy5pZCB9ID0ge30sIGRhdGEgPSBbXSB9ID0gdGhpcztcbiAgICBjb25zdCB7IHhLZXksIHlLZXksIHlGaWx0ZXJLZXksIG5vcm1hbGl6ZWRUbyB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGFuaW1hdGlvbkVuYWJsZWQgPSAhdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5pc1NraXBwZWQoKTtcbiAgICBjb25zdCB4U2NhbGUgPSB0aGlzLmdldENhdGVnb3J5QXhpcygpPy5zY2FsZTtcbiAgICBjb25zdCB5U2NhbGUgPSB0aGlzLmdldFZhbHVlQXhpcygpPy5zY2FsZTtcbiAgICBjb25zdCB7IGlzQ29udGludW91c1gsIHhTY2FsZVR5cGUsIHlTY2FsZVR5cGUgfSA9IHRoaXMuZ2V0U2NhbGVJbmZvcm1hdGlvbih7IHhTY2FsZSwgeVNjYWxlIH0pO1xuICAgIGNvbnN0IHN0YWNrR3JvdXBOYW1lID0gYGJhci1zdGFjay0ke2dyb3VwSW5kZXh9LXlWYWx1ZXNgO1xuICAgIGNvbnN0IHN0YWNrR3JvdXBUcmFpbGluZ05hbWUgPSBgJHtzdGFja0dyb3VwTmFtZX0tdHJhaWxpbmdgO1xuICAgIGNvbnN0IGV4dHJhUHJvcHMgPSBbXTtcbiAgICBpZiAoaXNGaW5pdGVOdW1iZXIobm9ybWFsaXplZFRvKSkge1xuICAgICAgZXh0cmFQcm9wcy5wdXNoKFxuICAgICAgICBub3JtYWxpc2VHcm91cFRvKFtzdGFja0dyb3VwTmFtZSwgc3RhY2tHcm91cFRyYWlsaW5nTmFtZV0sIE1hdGguYWJzKG5vcm1hbGl6ZWRUbyksIFwicmFuZ2VcIilcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChhbmltYXRpb25FbmFibGVkICYmIHRoaXMucHJvY2Vzc2VkRGF0YSkge1xuICAgICAgZXh0cmFQcm9wcy5wdXNoKGRpZmYodGhpcy5wcm9jZXNzZWREYXRhKSk7XG4gICAgfVxuICAgIGlmIChhbmltYXRpb25FbmFibGVkKSB7XG4gICAgICBleHRyYVByb3BzLnB1c2goYW5pbWF0aW9uVmFsaWRhdGlvbigpKTtcbiAgICB9XG4gICAgY29uc3QgdmlzaWJsZVByb3BzID0gdGhpcy52aXNpYmxlID8ge30gOiB7IGZvcmNlVmFsdWU6IDAgfTtcbiAgICBjb25zdCB7IHByb2Nlc3NlZERhdGEgfSA9IGF3YWl0IHRoaXMucmVxdWVzdERhdGFNb2RlbChkYXRhQ29udHJvbGxlciwgZGF0YSwge1xuICAgICAgcHJvcHM6IFtcbiAgICAgICAga2V5UHJvcGVydHkoeEtleSwgeFNjYWxlVHlwZSwgeyBpZDogXCJ4VmFsdWVcIiB9KSxcbiAgICAgICAgdmFsdWVQcm9wZXJ0eSh5S2V5LCB5U2NhbGVUeXBlLCB7IGlkOiBgeVZhbHVlLXJhd2AsIGludmFsaWRWYWx1ZTogbnVsbCwgLi4udmlzaWJsZVByb3BzIH0pLFxuICAgICAgICAuLi50aGlzLmNyb3NzRmlsdGVyaW5nRW5hYmxlZCgpID8gW1xuICAgICAgICAgIHZhbHVlUHJvcGVydHkoeUZpbHRlcktleSwgeVNjYWxlVHlwZSwge1xuICAgICAgICAgICAgaWQ6IGB5RmlsdGVyVmFsdWVgLFxuICAgICAgICAgICAgaW52YWxpZFZhbHVlOiBudWxsLFxuICAgICAgICAgICAgLi4udmlzaWJsZVByb3BzXG4gICAgICAgICAgfSlcbiAgICAgICAgXSA6IFtdLFxuICAgICAgICAuLi5ncm91cEFjY3VtdWxhdGl2ZVZhbHVlUHJvcGVydHkoXG4gICAgICAgICAgeUtleSxcbiAgICAgICAgICBcIm5vcm1hbFwiLFxuICAgICAgICAgIFwiY3VycmVudFwiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkOiBgeVZhbHVlLWVuZGAsXG4gICAgICAgICAgICByYW5nZUlkOiBgeVZhbHVlLXJhbmdlYCxcbiAgICAgICAgICAgIGludmFsaWRWYWx1ZTogbnVsbCxcbiAgICAgICAgICAgIG1pc3NpbmdWYWx1ZTogMCxcbiAgICAgICAgICAgIGdyb3VwSWQ6IHN0YWNrR3JvdXBOYW1lLFxuICAgICAgICAgICAgc2VwYXJhdGVOZWdhdGl2ZTogdHJ1ZSxcbiAgICAgICAgICAgIC4uLnZpc2libGVQcm9wc1xuICAgICAgICAgIH0sXG4gICAgICAgICAgeVNjYWxlVHlwZVxuICAgICAgICApLFxuICAgICAgICAuLi5ncm91cEFjY3VtdWxhdGl2ZVZhbHVlUHJvcGVydHkoXG4gICAgICAgICAgeUtleSxcbiAgICAgICAgICBcInRyYWlsaW5nXCIsXG4gICAgICAgICAgXCJjdXJyZW50XCIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWQ6IGB5VmFsdWUtc3RhcnRgLFxuICAgICAgICAgICAgaW52YWxpZFZhbHVlOiBudWxsLFxuICAgICAgICAgICAgbWlzc2luZ1ZhbHVlOiAwLFxuICAgICAgICAgICAgZ3JvdXBJZDogc3RhY2tHcm91cFRyYWlsaW5nTmFtZSxcbiAgICAgICAgICAgIHNlcGFyYXRlTmVnYXRpdmU6IHRydWUsXG4gICAgICAgICAgICAuLi52aXNpYmxlUHJvcHNcbiAgICAgICAgICB9LFxuICAgICAgICAgIHlTY2FsZVR5cGVcbiAgICAgICAgKSxcbiAgICAgICAgLi4uaXNDb250aW51b3VzWCA/IFtTTUFMTEVTVF9LRVlfSU5URVJWQUwsIExBUkdFU1RfS0VZX0lOVEVSVkFMXSA6IFtdLFxuICAgICAgICAuLi5leHRyYVByb3BzXG4gICAgICBdLFxuICAgICAgZ3JvdXBCeUtleXM6IHRydWUsXG4gICAgICBncm91cEJ5RGF0YTogZmFsc2VcbiAgICB9KTtcbiAgICB0aGlzLnNtYWxsZXN0RGF0YUludGVydmFsID0gcHJvY2Vzc2VkRGF0YS5yZWR1Y2VkPy5zbWFsbGVzdEtleUludGVydmFsO1xuICAgIHRoaXMubGFyZ2VzdERhdGFJbnRlcnZhbCA9IHByb2Nlc3NlZERhdGEucmVkdWNlZD8ubGFyZ2VzdEtleUludGVydmFsO1xuICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcInVwZGF0ZURhdGFcIik7XG4gIH1cbiAgZ2V0U2VyaWVzRG9tYWluKGRpcmVjdGlvbikge1xuICAgIGNvbnN0IHsgcHJvY2Vzc2VkRGF0YSwgZGF0YU1vZGVsIH0gPSB0aGlzO1xuICAgIGlmICghZGF0YU1vZGVsIHx8ICFwcm9jZXNzZWREYXRhPy5kYXRhLmxlbmd0aClcbiAgICAgIHJldHVybiBbXTtcbiAgICBjb25zdCBrZXlEZWYgPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFEZWZCeUlkKHRoaXMsIGB4VmFsdWVgKTtcbiAgICBjb25zdCBrZXlzID0gZGF0YU1vZGVsLmdldERvbWFpbih0aGlzLCBgeFZhbHVlYCwgXCJrZXlcIiwgcHJvY2Vzc2VkRGF0YSk7XG4gICAgbGV0IHlFeHRlbnQgPSBkYXRhTW9kZWwuZ2V0RG9tYWluKHRoaXMsIGB5VmFsdWUtZW5kYCwgXCJ2YWx1ZVwiLCBwcm9jZXNzZWREYXRhKTtcbiAgICBjb25zdCB5RmlsdGVyRXh0ZW50ID0gdGhpcy5jcm9zc0ZpbHRlcmluZ0VuYWJsZWQoKSA/IGRhdGFNb2RlbC5nZXREb21haW4odGhpcywgYHlGaWx0ZXJWYWx1ZWAsIFwidmFsdWVcIiwgcHJvY2Vzc2VkRGF0YSkgOiB2b2lkIDA7XG4gICAgaWYgKHlGaWx0ZXJFeHRlbnQgIT0gbnVsbCkge1xuICAgICAgeUV4dGVudCA9IFtNYXRoLm1pbih5RXh0ZW50WzBdLCB5RmlsdGVyRXh0ZW50WzBdKSwgTWF0aC5tYXgoeUV4dGVudFsxXSwgeUZpbHRlckV4dGVudFsxXSldO1xuICAgIH1cbiAgICBpZiAoZGlyZWN0aW9uID09PSB0aGlzLmdldENhdGVnb3J5RGlyZWN0aW9uKCkpIHtcbiAgICAgIGlmIChrZXlEZWY/LmRlZi50eXBlID09PSBcImtleVwiICYmIGtleURlZi5kZWYudmFsdWVUeXBlID09PSBcImNhdGVnb3J5XCIpIHtcbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5wYWRCYW5kRXh0ZW50KGtleXMpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5nZXRWYWx1ZUF4aXMoKSBpbnN0YW5jZW9mIExvZ0F4aXMpIHtcbiAgICAgIHJldHVybiBmaXhOdW1lcmljRXh0ZW50KHlFeHRlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBmaXhlZFlFeHRlbnQgPSBbTWF0aC5taW4oMCwgeUV4dGVudFswXSksIE1hdGgubWF4KDAsIHlFeHRlbnRbMV0pXTtcbiAgICAgIHJldHVybiBmaXhOdW1lcmljRXh0ZW50KGZpeGVkWUV4dGVudCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGNyZWF0ZU5vZGVEYXRhKCkge1xuICAgIGNvbnN0IHsgZGF0YU1vZGVsIH0gPSB0aGlzO1xuICAgIGNvbnN0IHhBeGlzID0gdGhpcy5nZXRDYXRlZ29yeUF4aXMoKTtcbiAgICBjb25zdCB5QXhpcyA9IHRoaXMuZ2V0VmFsdWVBeGlzKCk7XG4gICAgaWYgKCFkYXRhTW9kZWwgfHwgIXhBeGlzIHx8ICF5QXhpcyB8fCAhdGhpcy5wcm9wZXJ0aWVzLmlzVmFsaWQoKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB4U2NhbGUgPSB4QXhpcy5zY2FsZTtcbiAgICBjb25zdCB5U2NhbGUgPSB5QXhpcy5zY2FsZTtcbiAgICBjb25zdCB7IHhLZXksIHlLZXksIHhOYW1lLCB5TmFtZSwgZmlsbCwgc3Ryb2tlLCBzdHJva2VXaWR0aCwgY29ybmVyUmFkaXVzLCBsZWdlbmRJdGVtTmFtZSwgbGFiZWwgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCB5UmV2ZXJzZWQgPSB5QXhpcy5pc1JldmVyc2VkKCk7XG4gICAgY29uc3QgeyBiYXJXaWR0aCwgZ3JvdXBJbmRleCB9ID0gdGhpcy51cGRhdGVHcm91cFNjYWxlKHhBeGlzKTtcbiAgICBjb25zdCBiYXJPZmZzZXQgPSBDb250aW51b3VzU2NhbGUuaXMoeFNjYWxlKSA/IGJhcldpZHRoICogLTAuNSA6IDA7XG4gICAgY29uc3QgeEluZGV4ID0gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGB4VmFsdWVgKTtcbiAgICBjb25zdCB5UmF3SW5kZXggPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYHlWYWx1ZS1yYXdgKTtcbiAgICBjb25zdCB5RmlsdGVySW5kZXggPSB0aGlzLmNyb3NzRmlsdGVyaW5nRW5hYmxlZCgpID8gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGB5RmlsdGVyVmFsdWVgKSA6IHZvaWQgMDtcbiAgICBjb25zdCB5U3RhcnRJbmRleCA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgeVZhbHVlLXN0YXJ0YCk7XG4gICAgY29uc3QgeUVuZEluZGV4ID0gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGB5VmFsdWUtZW5kYCk7XG4gICAgY29uc3QgeVJhbmdlSW5kZXggPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYHlWYWx1ZS1yYW5nZWApO1xuICAgIGNvbnN0IGFuaW1hdGlvbkVuYWJsZWQgPSAhdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5pc1NraXBwZWQoKTtcbiAgICBjb25zdCBub2RlRGF0dW0gPSAoe1xuICAgICAgZGF0dW0sXG4gICAgICB2YWx1ZUluZGV4LFxuICAgICAgeFZhbHVlLFxuICAgICAgeVZhbHVlLFxuICAgICAgY3VtdWxhdGl2ZVZhbHVlLFxuICAgICAgcGhhbnRvbSxcbiAgICAgIGN1cnJZLFxuICAgICAgcHJldlksXG4gICAgICBpc1Bvc2l0aXZlLFxuICAgICAgeVJhbmdlLFxuICAgICAgbGFiZWxUZXh0LFxuICAgICAgY3Jvc3NTY2FsZSA9IDFcbiAgICB9KSA9PiB7XG4gICAgICBjb25zdCB4ID0geFNjYWxlLmNvbnZlcnQoeFZhbHVlKTtcbiAgICAgIGNvbnN0IGlzVXB3YXJkID0gaXNQb3NpdGl2ZSAhPT0geVJldmVyc2VkO1xuICAgICAgY29uc3QgYmFyWCA9IHggKyBncm91cFNjYWxlLmNvbnZlcnQoU3RyaW5nKGdyb3VwSW5kZXgpKSArIGJhck9mZnNldDtcbiAgICAgIGNvbnN0IHkgPSB5U2NhbGUuY29udmVydChjdXJyWSk7XG4gICAgICBjb25zdCBib3R0b21ZID0geVNjYWxlLmNvbnZlcnQocHJldlkpO1xuICAgICAgY29uc3QgYmFyQWxvbmdYID0gdGhpcy5nZXRCYXJEaXJlY3Rpb24oKSA9PT0gXCJ4XCIgLyogWCAqLztcbiAgICAgIGNvbnN0IGJib3hIZWlnaHQgPSB5U2NhbGUuY29udmVydCh5UmFuZ2UpO1xuICAgICAgY29uc3QgYmJveEJvdHRvbSA9IHlTY2FsZS5jb252ZXJ0KDApO1xuICAgICAgY29uc3QgeE9mZnNldCA9IGJhcldpZHRoICogMC41ICogKDEgLSBjcm9zc1NjYWxlKTtcbiAgICAgIGNvbnN0IHJlY3QgPSB7XG4gICAgICAgIHg6IGJhckFsb25nWCA/IE1hdGgubWluKHksIGJvdHRvbVkpIDogYmFyWCArIHhPZmZzZXQsXG4gICAgICAgIHk6IGJhckFsb25nWCA/IGJhclggKyB4T2Zmc2V0IDogTWF0aC5taW4oeSwgYm90dG9tWSksXG4gICAgICAgIHdpZHRoOiBiYXJBbG9uZ1ggPyBNYXRoLmFicyhib3R0b21ZIC0geSkgOiBiYXJXaWR0aCAqIGNyb3NzU2NhbGUsXG4gICAgICAgIGhlaWdodDogYmFyQWxvbmdYID8gYmFyV2lkdGggKiBjcm9zc1NjYWxlIDogTWF0aC5hYnMoYm90dG9tWSAtIHkpXG4gICAgICB9O1xuICAgICAgY29uc3QgY2xpcEJCb3ggPSBuZXcgQkJveChyZWN0LngsIHJlY3QueSwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xuICAgICAgY29uc3QgYmFyUmVjdCA9IHtcbiAgICAgICAgeDogYmFyQWxvbmdYID8gTWF0aC5taW4oYmJveEJvdHRvbSwgYmJveEhlaWdodCkgOiBiYXJYICsgeE9mZnNldCxcbiAgICAgICAgeTogYmFyQWxvbmdYID8gYmFyWCArIHhPZmZzZXQgOiBNYXRoLm1pbihiYm94Qm90dG9tLCBiYm94SGVpZ2h0KSxcbiAgICAgICAgd2lkdGg6IGJhckFsb25nWCA/IE1hdGguYWJzKGJib3hCb3R0b20gLSBiYm94SGVpZ2h0KSA6IGJhcldpZHRoICogY3Jvc3NTY2FsZSxcbiAgICAgICAgaGVpZ2h0OiBiYXJBbG9uZ1ggPyBiYXJXaWR0aCAqIGNyb3NzU2NhbGUgOiBNYXRoLmFicyhiYm94Qm90dG9tIC0gYmJveEhlaWdodClcbiAgICAgIH07XG4gICAgICBjb25zdCBsZW5ndGhSYXRpb011bHRpcGxpZXIgPSB0aGlzLnNob3VsZEZsaXBYWSgpID8gcmVjdC5oZWlnaHQgOiByZWN0LndpZHRoO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2VyaWVzOiB0aGlzLFxuICAgICAgICBpdGVtSWQ6IHBoYW50b20gPyBjcmVhdGVEYXR1bUlkKHlLZXksIHBoYW50b20pIDogeUtleSxcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIHZhbHVlSW5kZXgsXG4gICAgICAgIGN1bXVsYXRpdmVWYWx1ZSxcbiAgICAgICAgcGhhbnRvbSxcbiAgICAgICAgeFZhbHVlLFxuICAgICAgICB5VmFsdWUsXG4gICAgICAgIHlLZXksXG4gICAgICAgIHhLZXksXG4gICAgICAgIGNhcERlZmF1bHRzOiB7XG4gICAgICAgICAgbGVuZ3RoUmF0aW9NdWx0aXBsaWVyLFxuICAgICAgICAgIGxlbmd0aE1heDogbGVuZ3RoUmF0aW9NdWx0aXBsaWVyXG4gICAgICAgIH0sXG4gICAgICAgIHg6IGJhclJlY3QueCxcbiAgICAgICAgeTogYmFyUmVjdC55LFxuICAgICAgICB3aWR0aDogYmFyUmVjdC53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBiYXJSZWN0LmhlaWdodCxcbiAgICAgICAgbWlkUG9pbnQ6IHsgeDogcmVjdC54ICsgcmVjdC53aWR0aCAvIDIsIHk6IHJlY3QueSArIHJlY3QuaGVpZ2h0IC8gMiB9LFxuICAgICAgICBmaWxsLFxuICAgICAgICBzdHJva2UsXG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgICBjb3JuZXJSYWRpdXMsXG4gICAgICAgIHRvcExlZnRDb3JuZXJSYWRpdXM6IGJhckFsb25nWCAhPT0gaXNVcHdhcmQsXG4gICAgICAgIHRvcFJpZ2h0Q29ybmVyUmFkaXVzOiBpc1Vwd2FyZCxcbiAgICAgICAgYm90dG9tUmlnaHRDb3JuZXJSYWRpdXM6IGJhckFsb25nWCA9PT0gaXNVcHdhcmQsXG4gICAgICAgIGJvdHRvbUxlZnRDb3JuZXJSYWRpdXM6ICFpc1Vwd2FyZCxcbiAgICAgICAgY2xpcEJCb3gsXG4gICAgICAgIGxhYmVsOiBsYWJlbFRleHQgIT0gbnVsbCA/IHtcbiAgICAgICAgICB0ZXh0OiBsYWJlbFRleHQsXG4gICAgICAgICAgLi4uYWRqdXN0TGFiZWxQbGFjZW1lbnQoe1xuICAgICAgICAgICAgaXNVcHdhcmQsXG4gICAgICAgICAgICBpc1ZlcnRpY2FsOiAhYmFyQWxvbmdYLFxuICAgICAgICAgICAgcGxhY2VtZW50OiBsYWJlbFBsYWNlbWVudHMyW2xhYmVsLnBsYWNlbWVudF0sXG4gICAgICAgICAgICBwYWRkaW5nOiBsYWJlbC5wYWRkaW5nLFxuICAgICAgICAgICAgcmVjdFxuICAgICAgICAgIH0pXG4gICAgICAgIH0gOiB2b2lkIDAsXG4gICAgICAgIG1pc3Npbmc6IHlWYWx1ZSA9PSBudWxsLFxuICAgICAgICBmb2N1c2FibGU6ICFwaGFudG9tXG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgeyBncm91cFNjYWxlLCBwcm9jZXNzZWREYXRhIH0gPSB0aGlzO1xuICAgIGNvbnN0IHBoYW50b21Ob2RlcyA9IFtdO1xuICAgIGNvbnN0IG5vZGVzID0gW107XG4gICAgY29uc3QgbGFiZWxzID0gW107XG4gICAgcHJvY2Vzc2VkRGF0YT8uZGF0YS5mb3JFYWNoKCh7IGtleXMsIGRhdHVtOiBzZXJpZXNEYXR1bSwgdmFsdWVzLCBhZ2dWYWx1ZXMgfSkgPT4ge1xuICAgICAgdmFsdWVzLmZvckVhY2goKHZhbHVlLCB2YWx1ZUluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IHhWYWx1ZSA9IGtleXNbeEluZGV4XTtcbiAgICAgICAgY29uc3QgeVJhd1ZhbHVlID0gdmFsdWVbeVJhd0luZGV4XTtcbiAgICAgICAgY29uc3QgeVN0YXJ0ID0gTnVtYmVyKHZhbHVlW3lTdGFydEluZGV4XSk7XG4gICAgICAgIGNvbnN0IHlGaWx0ZXJWYWx1ZSA9IHlGaWx0ZXJJbmRleCAhPSBudWxsID8gTnVtYmVyKHZhbHVlW3lGaWx0ZXJJbmRleF0pIDogdm9pZCAwO1xuICAgICAgICBjb25zdCB5RW5kID0gTnVtYmVyKHZhbHVlW3lFbmRJbmRleF0pO1xuICAgICAgICBjb25zdCBpc1Bvc2l0aXZlID0geVJhd1ZhbHVlID49IDAgJiYgIU9iamVjdC5pcyh5UmF3VmFsdWUsIC0wKTtcbiAgICAgICAgY29uc3QgeVJhbmdlID0gYWdnVmFsdWVzPy5beVJhbmdlSW5kZXhdW2lzUG9zaXRpdmUgPyAxIDogMF0gPz8gMDtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoeUVuZCkpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoeUZpbHRlclZhbHVlICE9IG51bGwgJiYgIU51bWJlci5pc0Zpbml0ZSh5RmlsdGVyVmFsdWUpKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgbGFiZWxUZXh0ID0geVJhd1ZhbHVlICE9IG51bGwgPyB0aGlzLmdldExhYmVsVGV4dChcbiAgICAgICAgICB0aGlzLnByb3BlcnRpZXMubGFiZWwsXG4gICAgICAgICAge1xuICAgICAgICAgICAgZGF0dW06IHNlcmllc0RhdHVtW3ZhbHVlSW5kZXhdLFxuICAgICAgICAgICAgdmFsdWU6IHlGaWx0ZXJWYWx1ZSA/PyB5UmF3VmFsdWUsXG4gICAgICAgICAgICB4S2V5LFxuICAgICAgICAgICAgeUtleSxcbiAgICAgICAgICAgIHhOYW1lLFxuICAgICAgICAgICAgeU5hbWUsXG4gICAgICAgICAgICBsZWdlbmRJdGVtTmFtZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZm9ybWF0VmFsdWVcbiAgICAgICAgKSA6IHZvaWQgMDtcbiAgICAgICAgY29uc3QgaW5zZXQgPSB5RmlsdGVyVmFsdWUgIT0gbnVsbCAmJiB5RmlsdGVyVmFsdWUgPiB5UmF3VmFsdWU7XG4gICAgICAgIGNvbnN0IG5vZGVEYXRhID0gbm9kZURhdHVtKHtcbiAgICAgICAgICBkYXR1bTogc2VyaWVzRGF0dW1bdmFsdWVJbmRleF0sXG4gICAgICAgICAgdmFsdWVJbmRleCxcbiAgICAgICAgICB4VmFsdWUsXG4gICAgICAgICAgeVZhbHVlOiB5RmlsdGVyVmFsdWUgPz8geVJhd1ZhbHVlLFxuICAgICAgICAgIGN1bXVsYXRpdmVWYWx1ZTogeUZpbHRlclZhbHVlID8/IHlFbmQsXG4gICAgICAgICAgcGhhbnRvbTogZmFsc2UsXG4gICAgICAgICAgY3Vyclk6IHlGaWx0ZXJWYWx1ZSAhPSBudWxsID8geVN0YXJ0ICsgeUZpbHRlclZhbHVlIDogeUVuZCxcbiAgICAgICAgICBwcmV2WTogeVN0YXJ0LFxuICAgICAgICAgIGlzUG9zaXRpdmUsXG4gICAgICAgICAgeVJhbmdlOiBNYXRoLm1heCh5U3RhcnQgKyAoeUZpbHRlclZhbHVlID8/IC1JbmZpbml0eSksIHlSYW5nZSksXG4gICAgICAgICAgbGFiZWxUZXh0LFxuICAgICAgICAgIGNyb3NzU2NhbGU6IGluc2V0ID8gMC42IDogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBub2Rlcy5wdXNoKG5vZGVEYXRhKTtcbiAgICAgICAgbGFiZWxzLnB1c2gobm9kZURhdGEpO1xuICAgICAgICBpZiAoeUZpbHRlclZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBwaGFudG9tTm9kZURhdGEgPSBub2RlRGF0dW0oe1xuICAgICAgICAgICAgZGF0dW06IHNlcmllc0RhdHVtW3ZhbHVlSW5kZXhdLFxuICAgICAgICAgICAgdmFsdWVJbmRleCxcbiAgICAgICAgICAgIHhWYWx1ZSxcbiAgICAgICAgICAgIHlWYWx1ZTogeUZpbHRlclZhbHVlLFxuICAgICAgICAgICAgY3VtdWxhdGl2ZVZhbHVlOiB5RmlsdGVyVmFsdWUsXG4gICAgICAgICAgICBwaGFudG9tOiB0cnVlLFxuICAgICAgICAgICAgY3Vyclk6IHlFbmQsXG4gICAgICAgICAgICBwcmV2WTogeVN0YXJ0LFxuICAgICAgICAgICAgaXNQb3NpdGl2ZSxcbiAgICAgICAgICAgIHlSYW5nZSxcbiAgICAgICAgICAgIGxhYmVsVGV4dDogdm9pZCAwLFxuICAgICAgICAgICAgY3Jvc3NTY2FsZTogdm9pZCAwXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcGhhbnRvbU5vZGVzLnB1c2gocGhhbnRvbU5vZGVEYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGl0ZW1JZDogeUtleSxcbiAgICAgIG5vZGVEYXRhOiBwaGFudG9tTm9kZXMubGVuZ3RoID4gMCA/IFsuLi5waGFudG9tTm9kZXMsIC4uLm5vZGVzXSA6IG5vZGVzLFxuICAgICAgbGFiZWxEYXRhOiBsYWJlbHMsXG4gICAgICBzY2FsZXM6IHRoaXMuY2FsY3VsYXRlU2NhbGluZygpLFxuICAgICAgdmlzaWJsZTogdGhpcy52aXNpYmxlIHx8IGFuaW1hdGlvbkVuYWJsZWRcbiAgICB9O1xuICB9XG4gIG5vZGVGYWN0b3J5KCkge1xuICAgIHJldHVybiBuZXcgUmVjdCgpO1xuICB9XG4gIGdldEhpZ2hsaWdodERhdGEobm9kZURhdGEsIGhpZ2hsaWdodGVkSXRlbSkge1xuICAgIGNvbnN0IGhpZ2hsaWdodEl0ZW0gPSBub2RlRGF0YS5maW5kKFxuICAgICAgKG5vZGVEYXR1bSkgPT4gbm9kZURhdHVtLmRhdHVtID09PSBoaWdobGlnaHRlZEl0ZW0uZGF0dW0gJiYgIW5vZGVEYXR1bS5waGFudG9tXG4gICAgKTtcbiAgICByZXR1cm4gaGlnaGxpZ2h0SXRlbSAhPSBudWxsID8gW2hpZ2hsaWdodEl0ZW1dIDogdm9pZCAwO1xuICB9XG4gIGFzeW5jIHVwZGF0ZURhdHVtU2VsZWN0aW9uKG9wdHMpIHtcbiAgICByZXR1cm4gb3B0cy5kYXR1bVNlbGVjdGlvbi51cGRhdGUoXG4gICAgICBvcHRzLm5vZGVEYXRhLFxuICAgICAgdm9pZCAwLFxuICAgICAgKGRhdHVtKSA9PiBjcmVhdGVEYXR1bUlkKGRhdHVtLnhWYWx1ZSwgZGF0dW0udmFsdWVJbmRleCwgZGF0dW0ucGhhbnRvbSlcbiAgICApO1xuICB9XG4gIGFzeW5jIHVwZGF0ZURhdHVtTm9kZXMob3B0cykge1xuICAgIGlmICghdGhpcy5wcm9wZXJ0aWVzLmlzVmFsaWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICB5S2V5LFxuICAgICAgc3RhY2tHcm91cCxcbiAgICAgIGZpbGwsXG4gICAgICBmaWxsT3BhY2l0eSxcbiAgICAgIHN0cm9rZSxcbiAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgc3Ryb2tlT3BhY2l0eSxcbiAgICAgIGxpbmVEYXNoLFxuICAgICAgbGluZURhc2hPZmZzZXQsXG4gICAgICBpdGVtU3R5bGVyLFxuICAgICAgc2hhZG93LFxuICAgICAgaGlnaGxpZ2h0U3R5bGU6IHsgaXRlbTogaXRlbUhpZ2hsaWdodFN0eWxlIH1cbiAgICB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHhBeGlzID0gdGhpcy5heGVzW1wieFwiIC8qIFggKi9dO1xuICAgIGNvbnN0IGNyaXNwID0gdGhpcy5wcm9wZXJ0aWVzLmNyaXNwID8/IGNoZWNrQ3Jpc3AoeEF4aXM/LnNjYWxlLCB4QXhpcz8udmlzaWJsZVJhbmdlLCB0aGlzLnNtYWxsZXN0RGF0YUludGVydmFsLCB0aGlzLmxhcmdlc3REYXRhSW50ZXJ2YWwpO1xuICAgIGNvbnN0IGNhdGVnb3J5QWxvbmdYID0gdGhpcy5nZXRDYXRlZ29yeURpcmVjdGlvbigpID09PSBcInhcIiAvKiBYICovO1xuICAgIGNvbnN0IHN0eWxlID0ge1xuICAgICAgZmlsbCxcbiAgICAgIHN0cm9rZSxcbiAgICAgIGxpbmVEYXNoLFxuICAgICAgbGluZURhc2hPZmZzZXQsXG4gICAgICBmaWxsU2hhZG93OiBzaGFkb3csXG4gICAgICBzdHJva2VXaWR0aDogdGhpcy5nZXRTdHJva2VXaWR0aChzdHJva2VXaWR0aCksXG4gICAgICBmaWxsT3BhY2l0eTogMCxcbiAgICAgIHN0cm9rZU9wYWNpdHk6IDBcbiAgICB9O1xuICAgIGNvbnN0IHJlY3RQYXJhbXMgPSB7XG4gICAgICBkYXR1bTogdm9pZCAwLFxuICAgICAgY3R4OiB0aGlzLmN0eCxcbiAgICAgIHNlcmllc0lkOiB0aGlzLmlkLFxuICAgICAgaXNIaWdobGlnaHRlZDogb3B0cy5pc0hpZ2hsaWdodCxcbiAgICAgIGhpZ2hsaWdodFN0eWxlOiBpdGVtSGlnaGxpZ2h0U3R5bGUsXG4gICAgICB5S2V5LFxuICAgICAgc3R5bGUsXG4gICAgICBpdGVtU3R5bGVyLFxuICAgICAgc3RhY2tHcm91cFxuICAgIH07XG4gICAgb3B0cy5kYXR1bVNlbGVjdGlvbi5lYWNoKChyZWN0LCBkYXR1bSkgPT4ge1xuICAgICAgc3R5bGUuZmlsbE9wYWNpdHkgPSBmaWxsT3BhY2l0eSAqIChkYXR1bS5waGFudG9tID8gMC4yIDogMSk7XG4gICAgICBzdHlsZS5zdHJva2VPcGFjaXR5ID0gc3Ryb2tlT3BhY2l0eSAqIChkYXR1bS5waGFudG9tID8gMC4yIDogMSk7XG4gICAgICBzdHlsZS5jb3JuZXJSYWRpdXMgPSBkYXR1bS5jb3JuZXJSYWRpdXM7XG4gICAgICBzdHlsZS50b3BMZWZ0Q29ybmVyUmFkaXVzID0gZGF0dW0udG9wTGVmdENvcm5lclJhZGl1cztcbiAgICAgIHN0eWxlLnRvcFJpZ2h0Q29ybmVyUmFkaXVzID0gZGF0dW0udG9wUmlnaHRDb3JuZXJSYWRpdXM7XG4gICAgICBzdHlsZS5ib3R0b21SaWdodENvcm5lclJhZGl1cyA9IGRhdHVtLmJvdHRvbVJpZ2h0Q29ybmVyUmFkaXVzO1xuICAgICAgc3R5bGUuYm90dG9tTGVmdENvcm5lclJhZGl1cyA9IGRhdHVtLmJvdHRvbUxlZnRDb3JuZXJSYWRpdXM7XG4gICAgICBjb25zdCB2aXNpYmxlID0gY2F0ZWdvcnlBbG9uZ1ggPyAoZGF0dW0uY2xpcEJCb3g/LndpZHRoID8/IGRhdHVtLndpZHRoKSA+IDAgOiAoZGF0dW0uY2xpcEJCb3g/LmhlaWdodCA/PyBkYXR1bS5oZWlnaHQpID4gMDtcbiAgICAgIHJlY3RQYXJhbXMuZGF0dW0gPSBkYXR1bTtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IGdldFJlY3RDb25maWcocmVjdFBhcmFtcyk7XG4gICAgICBjb25maWcuY3Jpc3AgPSBjcmlzcDtcbiAgICAgIGNvbmZpZy52aXNpYmxlID0gdmlzaWJsZTtcbiAgICAgIHVwZGF0ZVJlY3QocmVjdCwgY29uZmlnKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyB1cGRhdGVMYWJlbFNlbGVjdGlvbihvcHRzKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuaXNMYWJlbEVuYWJsZWQoKSA/IG9wdHMubGFiZWxEYXRhIDogW107XG4gICAgcmV0dXJuIG9wdHMubGFiZWxTZWxlY3Rpb24udXBkYXRlKGRhdGEsICh0ZXh0KSA9PiB7XG4gICAgICB0ZXh0LnBvaW50ZXJFdmVudHMgPSAxIC8qIE5vbmUgKi87XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlTGFiZWxOb2RlcyhvcHRzKSB7XG4gICAgb3B0cy5sYWJlbFNlbGVjdGlvbi5lYWNoKCh0ZXh0Tm9kZSwgZGF0dW0pID0+IHtcbiAgICAgIHVwZGF0ZUxhYmVsTm9kZSh0ZXh0Tm9kZSwgdGhpcy5wcm9wZXJ0aWVzLmxhYmVsLCBkYXR1bS5sYWJlbCk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0VG9vbHRpcEh0bWwobm9kZURhdHVtKSB7XG4gICAgY29uc3Qge1xuICAgICAgaWQ6IHNlcmllc0lkLFxuICAgICAgcHJvY2Vzc2VkRGF0YSxcbiAgICAgIGN0eDogeyBjYWxsYmFja0NhY2hlIH1cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB4QXhpcyA9IHRoaXMuZ2V0Q2F0ZWdvcnlBeGlzKCk7XG4gICAgY29uc3QgeUF4aXMgPSB0aGlzLmdldFZhbHVlQXhpcygpO1xuICAgIGlmICghcHJvY2Vzc2VkRGF0YSB8fCAhdGhpcy5wcm9wZXJ0aWVzLmlzVmFsaWQoKSB8fCAheEF4aXMgfHwgIXlBeGlzKSB7XG4gICAgICByZXR1cm4gRU1QVFlfVE9PTFRJUF9DT05URU5UO1xuICAgIH1cbiAgICBjb25zdCB7IHhLZXksIHlLZXksIHhOYW1lLCB5TmFtZSwgZmlsbCwgc3Ryb2tlLCBzdHJva2VXaWR0aCwgdG9vbHRpcCwgaXRlbVN0eWxlciwgc3RhY2tHcm91cCwgbGVnZW5kSXRlbU5hbWUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCB7IHhWYWx1ZSwgeVZhbHVlLCBkYXR1bSwgaXRlbUlkIH0gPSBub2RlRGF0dW07XG4gICAgY29uc3QgeFN0cmluZyA9IHhBeGlzLmZvcm1hdERhdHVtKHhWYWx1ZSk7XG4gICAgY29uc3QgeVN0cmluZyA9IHlBeGlzLmZvcm1hdERhdHVtKHlWYWx1ZSk7XG4gICAgY29uc3QgdGl0bGUgPSBzYW5pdGl6ZUh0bWwoeU5hbWUpO1xuICAgIGNvbnN0IGNvbnRlbnQgPSBzYW5pdGl6ZUh0bWwoeFN0cmluZyArIFwiOiBcIiArIHlTdHJpbmcpO1xuICAgIGxldCBmb3JtYXQ7XG4gICAgaWYgKGl0ZW1TdHlsZXIpIHtcbiAgICAgIGZvcm1hdCA9IGNhbGxiYWNrQ2FjaGUuY2FsbChpdGVtU3R5bGVyLCB7XG4gICAgICAgIHNlcmllc0lkLFxuICAgICAgICBkYXR1bSxcbiAgICAgICAgeEtleSxcbiAgICAgICAgeUtleSxcbiAgICAgICAgc3RhY2tHcm91cCxcbiAgICAgICAgZmlsbCxcbiAgICAgICAgc3Ryb2tlLFxuICAgICAgICBzdHJva2VXaWR0aDogdGhpcy5nZXRTdHJva2VXaWR0aChzdHJva2VXaWR0aCksXG4gICAgICAgIGhpZ2hsaWdodGVkOiBmYWxzZSxcbiAgICAgICAgY29ybmVyUmFkaXVzOiB0aGlzLnByb3BlcnRpZXMuY29ybmVyUmFkaXVzLFxuICAgICAgICBmaWxsT3BhY2l0eTogdGhpcy5wcm9wZXJ0aWVzLmZpbGxPcGFjaXR5LFxuICAgICAgICBzdHJva2VPcGFjaXR5OiB0aGlzLnByb3BlcnRpZXMuc3Ryb2tlT3BhY2l0eSxcbiAgICAgICAgbGluZURhc2g6IHRoaXMucHJvcGVydGllcy5saW5lRGFzaCA/PyBbXSxcbiAgICAgICAgbGluZURhc2hPZmZzZXQ6IHRoaXMucHJvcGVydGllcy5saW5lRGFzaE9mZnNldFxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGNvbG9yID0gZm9ybWF0Py5maWxsID8/IGZpbGw7XG4gICAgcmV0dXJuIHRvb2x0aXAudG9Ub29sdGlwSHRtbChcbiAgICAgIHsgdGl0bGUsIGNvbnRlbnQsIGJhY2tncm91bmRDb2xvcjogY29sb3IgfSxcbiAgICAgIHtcbiAgICAgICAgc2VyaWVzSWQsXG4gICAgICAgIGl0ZW1JZCxcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIHhLZXksXG4gICAgICAgIHlLZXksXG4gICAgICAgIHhOYW1lLFxuICAgICAgICB5TmFtZSxcbiAgICAgICAgc3RhY2tHcm91cCxcbiAgICAgICAgdGl0bGUsXG4gICAgICAgIGNvbG9yLFxuICAgICAgICBsZWdlbmRJdGVtTmFtZSxcbiAgICAgICAgLi4udGhpcy5nZXRNb2R1bGVUb29sdGlwUGFyYW1zKClcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGdldExlZ2VuZERhdGEobGVnZW5kVHlwZSkge1xuICAgIGNvbnN0IHsgc2hvd0luTGVnZW5kIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgaWYgKGxlZ2VuZFR5cGUgIT09IFwiY2F0ZWdvcnlcIiB8fCAhdGhpcy5kYXRhPy5sZW5ndGggfHwgIXRoaXMucHJvcGVydGllcy5pc1ZhbGlkKCkgfHwgIXNob3dJbkxlZ2VuZCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCB7IHlLZXksIHlOYW1lLCBmaWxsLCBzdHJva2UsIHN0cm9rZVdpZHRoLCBmaWxsT3BhY2l0eSwgc3Ryb2tlT3BhY2l0eSwgbGVnZW5kSXRlbU5hbWUsIHZpc2libGUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICBsZWdlbmRUeXBlOiBcImNhdGVnb3J5XCIsXG4gICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICBpdGVtSWQ6IHlLZXksXG4gICAgICAgIHNlcmllc0lkOiB0aGlzLmlkLFxuICAgICAgICBlbmFibGVkOiB2aXNpYmxlLFxuICAgICAgICBsYWJlbDogeyB0ZXh0OiBsZWdlbmRJdGVtTmFtZSA/PyB5TmFtZSA/PyB5S2V5IH0sXG4gICAgICAgIHN5bWJvbHM6IFt7IG1hcmtlcjogeyBmaWxsLCBmaWxsT3BhY2l0eSwgc3Ryb2tlLCBzdHJva2VXaWR0aCwgc3Ryb2tlT3BhY2l0eSB9IH1dLFxuICAgICAgICBsZWdlbmRJdGVtTmFtZVxuICAgICAgfVxuICAgIF07XG4gIH1cbiAgYW5pbWF0ZUVtcHR5VXBkYXRlUmVhZHkoeyBkYXR1bVNlbGVjdGlvbiwgbGFiZWxTZWxlY3Rpb24sIGFubm90YXRpb25TZWxlY3Rpb25zIH0pIHtcbiAgICBjb25zdCBmbnMgPSBwcmVwYXJlQmFyQW5pbWF0aW9uRnVuY3Rpb25zKGNvbGxhcHNlZFN0YXJ0aW5nQmFyUG9zaXRpb24odGhpcy5pc1ZlcnRpY2FsKCksIHRoaXMuYXhlcywgXCJub3JtYWxcIikpO1xuICAgIGZyb21Ub01vdGlvbih0aGlzLmlkLCBcIm5vZGVzXCIsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIFtkYXR1bVNlbGVjdGlvbl0sIGZucyk7XG4gICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJsYWJlbHNcIiwgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgbGFiZWxTZWxlY3Rpb24pO1xuICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwiYW5ub3RhdGlvbnNcIiwgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgLi4uYW5ub3RhdGlvblNlbGVjdGlvbnMpO1xuICB9XG4gIGFuaW1hdGVXYWl0aW5nVXBkYXRlUmVhZHkoZGF0YSkge1xuICAgIGNvbnN0IHsgZGF0dW1TZWxlY3Rpb24sIGxhYmVsU2VsZWN0aW9uLCBhbm5vdGF0aW9uU2VsZWN0aW9ucywgcHJldmlvdXNDb250ZXh0RGF0YSB9ID0gZGF0YTtcbiAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLnN0b3BCeUFuaW1hdGlvbkdyb3VwSWQodGhpcy5pZCk7XG4gICAgY29uc3QgZGF0YURpZmYgPSB0aGlzLnByb2Nlc3NlZERhdGE/LnJlZHVjZWQ/LmRpZmY7XG4gICAgY29uc3QgbW9kZSA9IHByZXZpb3VzQ29udGV4dERhdGEgPT0gbnVsbCA/IFwiZmFkZVwiIDogXCJub3JtYWxcIjtcbiAgICBjb25zdCBmbnMgPSBwcmVwYXJlQmFyQW5pbWF0aW9uRnVuY3Rpb25zKGNvbGxhcHNlZFN0YXJ0aW5nQmFyUG9zaXRpb24odGhpcy5pc1ZlcnRpY2FsKCksIHRoaXMuYXhlcywgbW9kZSkpO1xuICAgIGZyb21Ub01vdGlvbihcbiAgICAgIHRoaXMuaWQsXG4gICAgICBcIm5vZGVzXCIsXG4gICAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLFxuICAgICAgW2RhdHVtU2VsZWN0aW9uXSxcbiAgICAgIGZucyxcbiAgICAgIChfLCBkYXR1bSkgPT4gY3JlYXRlRGF0dW1JZChkYXR1bS54VmFsdWUsIGRhdHVtLnZhbHVlSW5kZXgsIGRhdHVtLnBoYW50b20pLFxuICAgICAgZGF0YURpZmZcbiAgICApO1xuICAgIGNvbnN0IGhhc01vdGlvbiA9IGRhdGFEaWZmPy5jaGFuZ2VkID8/IHRydWU7XG4gICAgaWYgKGhhc01vdGlvbikge1xuICAgICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJsYWJlbHNcIiwgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgbGFiZWxTZWxlY3Rpb24pO1xuICAgICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJhbm5vdGF0aW9uc1wiLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCAuLi5hbm5vdGF0aW9uU2VsZWN0aW9ucyk7XG4gICAgfVxuICB9XG4gIGlzTGFiZWxFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXMubGFiZWwuZW5hYmxlZDtcbiAgfVxuICBjb21wdXRlRm9jdXNCb3VuZHMoeyBkYXR1bUluZGV4LCBzZXJpZXNSZWN0IH0pIHtcbiAgICBjb25zdCBkYXR1bUJveCA9IHRoaXMuY29udGV4dE5vZGVEYXRhPy5ub2RlRGF0YVtkYXR1bUluZGV4XS5jbGlwQkJveDtcbiAgICByZXR1cm4gY29tcHV0ZUJhckZvY3VzQm91bmRzKGRhdHVtQm94LCB0aGlzLmNvbnRlbnRHcm91cCwgc2VyaWVzUmVjdCk7XG4gIH1cbn07XG5CYXJTZXJpZXMuY2xhc3NOYW1lID0gXCJCYXJTZXJpZXNcIjtcbkJhclNlcmllcy50eXBlID0gXCJiYXJcIjtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9iYXJTZXJpZXNNb2R1bGUudHNcbnZhciBCYXJTZXJpZXNNb2R1bGUgPSB7XG4gIHR5cGU6IFwic2VyaWVzXCIsXG4gIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIixcbiAgcGFja2FnZVR5cGU6IFwiY29tbXVuaXR5XCIsXG4gIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiXSxcbiAgaWRlbnRpZmllcjogXCJiYXJcIixcbiAgbW9kdWxlRmFjdG9yeTogKGN0eCkgPT4gbmV3IEJhclNlcmllcyhjdHgpLFxuICBzdGFja2FibGU6IHRydWUsXG4gIGdyb3VwYWJsZTogdHJ1ZSxcbiAgdG9vbHRpcERlZmF1bHRzOiB7IHJhbmdlOiBcImV4YWN0XCIgfSxcbiAgZGVmYXVsdEF4ZXM6IHN3YXBBeGlzQ29uZGl0aW9uKFxuICAgIFtcbiAgICAgIHsgdHlwZTogXCJudW1iZXJcIiAvKiBOVU1CRVIgKi8sIHBvc2l0aW9uOiBcImxlZnRcIiAvKiBMRUZUICovIH0sXG4gICAgICB7IHR5cGU6IFwiY2F0ZWdvcnlcIiAvKiBDQVRFR09SWSAqLywgcG9zaXRpb246IFwiYm90dG9tXCIgLyogQk9UVE9NICovIH1cbiAgICBdLFxuICAgIChzZXJpZXMpID0+IHNlcmllcz8uZGlyZWN0aW9uID09PSBcImhvcml6b250YWxcIlxuICApLFxuICB0aGVtZVRlbXBsYXRlOiB7XG4gICAgc2VyaWVzOiB7XG4gICAgICBkaXJlY3Rpb246IFwidmVydGljYWxcIixcbiAgICAgIGZpbGxPcGFjaXR5OiAxLFxuICAgICAgc3Ryb2tlV2lkdGg6IDAsXG4gICAgICBsaW5lRGFzaDogWzBdLFxuICAgICAgbGluZURhc2hPZmZzZXQ6IDAsXG4gICAgICBsYWJlbDoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgZm9udFdlaWdodDogXCJub3JtYWxcIiAvKiBOT1JNQUwgKi8sXG4gICAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgICAgZm9udEZhbWlseTogREVGQVVMVF9GT05UX0ZBTUlMWSxcbiAgICAgICAgY29sb3I6IERFRkFVTFRfSU5TSURFX1NFUklFU19MQUJFTF9DT0xPVVIsXG4gICAgICAgIHBsYWNlbWVudDogXCJpbnNpZGUtY2VudGVyXCJcbiAgICAgIH0sXG4gICAgICBzaGFkb3c6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIGNvbG9yOiBERUZBVUxUX1NIQURPV19DT0xPVVIsXG4gICAgICAgIHhPZmZzZXQ6IDMsXG4gICAgICAgIHlPZmZzZXQ6IDMsXG4gICAgICAgIGJsdXI6IDVcbiAgICAgIH0sXG4gICAgICBlcnJvckJhcjoge1xuICAgICAgICBjYXA6IHtcbiAgICAgICAgICBsZW5ndGhSYXRpbzogMC4zXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHBhbGV0dGVGYWN0b3J5OiBzaW5nbGVTZXJpZXNQYWxldHRlRmFjdG9yeVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9idWJibGVTZXJpZXNQcm9wZXJ0aWVzLnRzXG52YXIgQnViYmxlU2VyaWVzTWFya2VyID0gY2xhc3MgZXh0ZW5kcyBTZXJpZXNNYXJrZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMubWF4U2l6ZSA9IDMwO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKSxcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8gfSlcbl0sIEJ1YmJsZVNlcmllc01hcmtlci5wcm90b3R5cGUsIFwibWF4U2l6ZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE5VTUJFUl9BUlJBWSwgeyBvcHRpb25hbDogdHJ1ZSB9KSxcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8gfSlcbl0sIEJ1YmJsZVNlcmllc01hcmtlci5wcm90b3R5cGUsIFwiZG9tYWluXCIsIDIpO1xudmFyIEJ1YmJsZVNlcmllc0xhYmVsID0gY2xhc3MgZXh0ZW5kcyBMYWJlbCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5wbGFjZW1lbnQgPSBcInRvcFwiO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTEFCRUxfUExBQ0VNRU5UKVxuXSwgQnViYmxlU2VyaWVzTGFiZWwucHJvdG90eXBlLCBcInBsYWNlbWVudFwiLCAyKTtcbnZhciBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzID0gY2xhc3MgZXh0ZW5kcyBDYXJ0ZXNpYW5TZXJpZXNQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmNvbG9yUmFuZ2UgPSBbXCIjZmZmZjAwXCIsIFwiIzAwZmYwMFwiLCBcIiMwMDAwZmZcIl07XG4gICAgdGhpcy5sYWJlbCA9IG5ldyBCdWJibGVTZXJpZXNMYWJlbCgpO1xuICAgIHRoaXMudG9vbHRpcCA9IG5ldyBTZXJpZXNUb29sdGlwKCk7XG4gICAgLy8gTm8gdmFsaWRhdGlvbi4gTm90IGEgcGFydCBvZiB0aGUgb3B0aW9ucyBjb250cmFjdC5cbiAgICB0aGlzLm1hcmtlciA9IG5ldyBCdWJibGVTZXJpZXNNYXJrZXIoKTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORylcbl0sIEJ1YmJsZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInhLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcpXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ5S2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HKVxuXSwgQnViYmxlU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic2l6ZUtleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQnViYmxlU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGFiZWxLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEJ1YmJsZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNvbG9yS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ4RmlsdGVyS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ5RmlsdGVyS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzaXplRmlsdGVyS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ4TmFtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQnViYmxlU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwieU5hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEJ1YmJsZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInNpemVOYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJsYWJlbE5hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEJ1YmJsZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNvbG9yTmFtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE5VTUJFUl9BUlJBWSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQnViYmxlU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiY29sb3JEb21haW5cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkdfQVJSQVkpXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjb2xvclJhbmdlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ0aXRsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHkoXCJtYXJrZXIuc2hhcGVcIilcbl0sIEJ1YmJsZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInNoYXBlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgUHJveHlQcm9wZXJ0eShcIm1hcmtlci5zaXplXCIpXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzaXplXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgUHJveHlQcm9wZXJ0eShcIm1hcmtlci5tYXhTaXplXCIpXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJtYXhTaXplXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgUHJveHlQcm9wZXJ0eShcIm1hcmtlci5kb21haW5cIiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQnViYmxlU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiZG9tYWluXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgUHJveHlQcm9wZXJ0eShcIm1hcmtlci5maWxsXCIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEJ1YmJsZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImZpbGxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBQcm94eVByb3BlcnR5KFwibWFya2VyLmZpbGxPcGFjaXR5XCIpXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJmaWxsT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHkoXCJtYXJrZXIuc3Ryb2tlXCIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEJ1YmJsZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0cm9rZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHkoXCJtYXJrZXIuc3Ryb2tlV2lkdGhcIilcbl0sIEJ1YmJsZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0cm9rZVdpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgUHJveHlQcm9wZXJ0eShcIm1hcmtlci5zdHJva2VPcGFjaXR5XCIpXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdHJva2VPcGFjaXR5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgUHJveHlQcm9wZXJ0eShcIm1hcmtlci5pdGVtU3R5bGVyXCIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEJ1YmJsZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcIml0ZW1TdHlsZXJcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJsYWJlbFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIEJ1YmJsZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInRvb2x0aXBcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vYnViYmxlU2VyaWVzLnRzXG52YXIgQnViYmxlU2VyaWVzTm9kZUV2ZW50ID0gY2xhc3MgZXh0ZW5kcyBDYXJ0ZXNpYW5TZXJpZXNOb2RlRXZlbnQge1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBuYXRpdmVFdmVudCwgZGF0dW0sIHNlcmllcykge1xuICAgIHN1cGVyKHR5cGUsIG5hdGl2ZUV2ZW50LCBkYXR1bSwgc2VyaWVzKTtcbiAgICB0aGlzLnNpemVLZXkgPSBzZXJpZXMucHJvcGVydGllcy5zaXplS2V5O1xuICB9XG59O1xudmFyIEJ1YmJsZVNlcmllcyA9IGNsYXNzIGV4dGVuZHMgQ2FydGVzaWFuU2VyaWVzIHtcbiAgY29uc3RydWN0b3IobW9kdWxlQ3R4KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbW9kdWxlQ3R4LFxuICAgICAgZGlyZWN0aW9uS2V5czogREVGQVVMVF9DQVJURVNJQU5fRElSRUNUSU9OX0tFWVMsXG4gICAgICBkaXJlY3Rpb25OYW1lczogREVGQVVMVF9DQVJURVNJQU5fRElSRUNUSU9OX05BTUVTLFxuICAgICAgcGlja01vZGVzOiBbXG4gICAgICAgIDIgLyogQVhJU19BTElHTkVEICovLFxuICAgICAgICAxIC8qIE5FQVJFU1RfTk9ERSAqLyxcbiAgICAgICAgMCAvKiBFWEFDVF9TSEFQRV9NQVRDSCAqL1xuICAgICAgXSxcbiAgICAgIHBhdGhzUGVyU2VyaWVzOiBbXSxcbiAgICAgIGhhc01hcmtlcnM6IHRydWUsXG4gICAgICBtYXJrZXJTZWxlY3Rpb25HYXJiYWdlQ29sbGVjdGlvbjogZmFsc2UsXG4gICAgICBhbmltYXRpb25SZXNldEZuczoge1xuICAgICAgICBsYWJlbDogcmVzZXRMYWJlbEZuLFxuICAgICAgICBtYXJrZXI6IHJlc2V0TWFya2VyRm5cbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLk5vZGVFdmVudCA9IEJ1YmJsZVNlcmllc05vZGVFdmVudDtcbiAgICB0aGlzLnByb3BlcnRpZXMgPSBuZXcgQnViYmxlU2VyaWVzUHJvcGVydGllcygpO1xuICAgIHRoaXMuc2l6ZVNjYWxlID0gbmV3IExpbmVhclNjYWxlKCk7XG4gICAgdGhpcy5jb2xvclNjYWxlID0gbmV3IENvbG9yU2NhbGUoKTtcbiAgfVxuICBnZXQgcGlja01vZGVBeGlzKCkge1xuICAgIHJldHVybiBcIm1haW4tY2F0ZWdvcnlcIjtcbiAgfVxuICBhc3luYyBwcm9jZXNzRGF0YShkYXRhQ29udHJvbGxlcikge1xuICAgIGlmICghdGhpcy5wcm9wZXJ0aWVzLmlzVmFsaWQoKSB8fCB0aGlzLmRhdGEgPT0gbnVsbCB8fCAhdGhpcy52aXNpYmxlKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHhTY2FsZSA9IHRoaXMuYXhlc1tcInhcIiAvKiBYICovXT8uc2NhbGU7XG4gICAgY29uc3QgeVNjYWxlID0gdGhpcy5heGVzW1wieVwiIC8qIFkgKi9dPy5zY2FsZTtcbiAgICBjb25zdCB7IHhTY2FsZVR5cGUsIHlTY2FsZVR5cGUgfSA9IHRoaXMuZ2V0U2NhbGVJbmZvcm1hdGlvbih7IHhTY2FsZSwgeVNjYWxlIH0pO1xuICAgIGNvbnN0IGNvbG9yU2NhbGVUeXBlID0gdGhpcy5jb2xvclNjYWxlLnR5cGU7XG4gICAgY29uc3Qgc2l6ZVNjYWxlVHlwZSA9IHRoaXMuc2l6ZVNjYWxlLnR5cGU7XG4gICAgY29uc3Qge1xuICAgICAgeEtleSxcbiAgICAgIHlLZXksXG4gICAgICBzaXplS2V5LFxuICAgICAgeEZpbHRlcktleSxcbiAgICAgIHlGaWx0ZXJLZXksXG4gICAgICBzaXplRmlsdGVyS2V5LFxuICAgICAgbGFiZWxLZXksXG4gICAgICBjb2xvckRvbWFpbixcbiAgICAgIGNvbG9yUmFuZ2UsXG4gICAgICBjb2xvcktleSxcbiAgICAgIG1hcmtlclxuICAgIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgeyBkYXRhTW9kZWwsIHByb2Nlc3NlZERhdGEgfSA9IGF3YWl0IHRoaXMucmVxdWVzdERhdGFNb2RlbChkYXRhQ29udHJvbGxlciwgdGhpcy5kYXRhLCB7XG4gICAgICBwcm9wczogW1xuICAgICAgICB2YWx1ZVByb3BlcnR5KHhLZXksIHhTY2FsZVR5cGUsIHsgaWQ6IGB4VmFsdWVgIH0pLFxuICAgICAgICB2YWx1ZVByb3BlcnR5KHlLZXksIHlTY2FsZVR5cGUsIHsgaWQ6IGB5VmFsdWVgIH0pLFxuICAgICAgICAuLi54RmlsdGVyS2V5ICE9IG51bGwgPyBbdmFsdWVQcm9wZXJ0eSh4RmlsdGVyS2V5LCB4U2NhbGVUeXBlLCB7IGlkOiBgeEZpbHRlclZhbHVlYCB9KV0gOiBbXSxcbiAgICAgICAgLi4ueUZpbHRlcktleSAhPSBudWxsID8gW3ZhbHVlUHJvcGVydHkoeUZpbHRlcktleSwgeVNjYWxlVHlwZSwgeyBpZDogYHlGaWx0ZXJWYWx1ZWAgfSldIDogW10sXG4gICAgICAgIC4uLnNpemVGaWx0ZXJLZXkgIT0gbnVsbCA/IFt2YWx1ZVByb3BlcnR5KHNpemVGaWx0ZXJLZXksIHNpemVTY2FsZVR5cGUsIHsgaWQ6IGBzaXplRmlsdGVyVmFsdWVgIH0pXSA6IFtdLFxuICAgICAgICB2YWx1ZVByb3BlcnR5KHNpemVLZXksIHNpemVTY2FsZVR5cGUsIHsgaWQ6IGBzaXplVmFsdWVgIH0pLFxuICAgICAgICAuLi5jb2xvcktleSA/IFt2YWx1ZVByb3BlcnR5KGNvbG9yS2V5LCBjb2xvclNjYWxlVHlwZSwgeyBpZDogYGNvbG9yVmFsdWVgIH0pXSA6IFtdLFxuICAgICAgICAuLi5sYWJlbEtleSA/IFt2YWx1ZVByb3BlcnR5KGxhYmVsS2V5LCBcImJhbmRcIiwgeyBpZDogYGxhYmVsVmFsdWVgIH0pXSA6IFtdXG4gICAgICBdXG4gICAgfSk7XG4gICAgY29uc3Qgc2l6ZUtleUlkeCA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgc2l6ZVZhbHVlYCk7XG4gICAgY29uc3QgcHJvY2Vzc2VkU2l6ZSA9IHByb2Nlc3NlZERhdGEuZG9tYWluLnZhbHVlc1tzaXplS2V5SWR4XSA/PyBbXTtcbiAgICB0aGlzLnNpemVTY2FsZS5kb21haW4gPSBtYXJrZXIuZG9tYWluID8gbWFya2VyLmRvbWFpbiA6IHByb2Nlc3NlZFNpemU7XG4gICAgaWYgKGNvbG9yS2V5KSB7XG4gICAgICBjb25zdCBjb2xvcktleUlkeCA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgY29sb3JWYWx1ZWApO1xuICAgICAgdGhpcy5jb2xvclNjYWxlLmRvbWFpbiA9IGNvbG9yRG9tYWluID8/IHByb2Nlc3NlZERhdGEuZG9tYWluLnZhbHVlc1tjb2xvcktleUlkeF0gPz8gW107XG4gICAgICB0aGlzLmNvbG9yU2NhbGUucmFuZ2UgPSBjb2xvclJhbmdlO1xuICAgICAgdGhpcy5jb2xvclNjYWxlLnVwZGF0ZSgpO1xuICAgIH1cbiAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJ1cGRhdGVEYXRhXCIpO1xuICB9XG4gIGdldFNlcmllc0RvbWFpbihkaXJlY3Rpb24pIHtcbiAgICBjb25zdCB7IGRhdGFNb2RlbCwgcHJvY2Vzc2VkRGF0YSB9ID0gdGhpcztcbiAgICBpZiAoIXByb2Nlc3NlZERhdGEgfHwgIWRhdGFNb2RlbClcbiAgICAgIHJldHVybiBbXTtcbiAgICBjb25zdCBpZCA9IGRpcmVjdGlvbiA9PT0gXCJ4XCIgLyogWCAqLyA/IGB4VmFsdWVgIDogYHlWYWx1ZWA7XG4gICAgY29uc3QgZGF0YURlZiA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YURlZkJ5SWQodGhpcywgaWQpO1xuICAgIGNvbnN0IGRvbWFpbiA9IGRhdGFNb2RlbC5nZXREb21haW4odGhpcywgaWQsIFwidmFsdWVcIiwgcHJvY2Vzc2VkRGF0YSk7XG4gICAgaWYgKGRhdGFEZWY/LmRlZi50eXBlID09PSBcInZhbHVlXCIgJiYgZGF0YURlZj8uZGVmLnZhbHVlVHlwZSA9PT0gXCJjYXRlZ29yeVwiKSB7XG4gICAgICByZXR1cm4gZG9tYWluO1xuICAgIH1cbiAgICByZXR1cm4gZml4TnVtZXJpY0V4dGVudChleHRlbnQoZG9tYWluKSk7XG4gIH1cbiAgYXN5bmMgY3JlYXRlTm9kZURhdGEoKSB7XG4gICAgY29uc3QgeyBheGVzLCBkYXRhTW9kZWwsIHByb2Nlc3NlZERhdGEsIGNvbG9yU2NhbGUsIHNpemVTY2FsZSB9ID0gdGhpcztcbiAgICBjb25zdCB7XG4gICAgICB4S2V5LFxuICAgICAgeUtleSxcbiAgICAgIHNpemVLZXksXG4gICAgICB4RmlsdGVyS2V5LFxuICAgICAgeUZpbHRlcktleSxcbiAgICAgIHNpemVGaWx0ZXJLZXksXG4gICAgICBsYWJlbEtleSxcbiAgICAgIHhOYW1lLFxuICAgICAgeU5hbWUsXG4gICAgICBzaXplTmFtZSxcbiAgICAgIGxhYmVsTmFtZSxcbiAgICAgIGxhYmVsLFxuICAgICAgY29sb3JLZXksXG4gICAgICBtYXJrZXIsXG4gICAgICB2aXNpYmxlXG4gICAgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCBtYXJrZXJTaGFwZSA9IGdldE1hcmtlcihtYXJrZXIuc2hhcGUpO1xuICAgIGNvbnN0IHsgcGxhY2VtZW50IH0gPSBsYWJlbDtcbiAgICBjb25zdCB4QXhpcyA9IGF4ZXNbXCJ4XCIgLyogWCAqL107XG4gICAgY29uc3QgeUF4aXMgPSBheGVzW1wieVwiIC8qIFkgKi9dO1xuICAgIGlmICghKGRhdGFNb2RlbCAmJiBwcm9jZXNzZWREYXRhICYmIHZpc2libGUgJiYgeEF4aXMgJiYgeUF4aXMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHhEYXRhSWR4ID0gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGB4VmFsdWVgKTtcbiAgICBjb25zdCB5RGF0YUlkeCA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgeVZhbHVlYCk7XG4gICAgY29uc3Qgc2l6ZURhdGFJZHggPSBzaXplS2V5ICE9IG51bGwgPyBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYHNpemVWYWx1ZWApIDogdm9pZCAwO1xuICAgIGNvbnN0IGNvbG9yRGF0YUlkeCA9IGNvbG9yS2V5ICE9IG51bGwgPyBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYGNvbG9yVmFsdWVgKSA6IC0xO1xuICAgIGNvbnN0IGxhYmVsRGF0YUlkeCA9IGxhYmVsS2V5ICE9IG51bGwgPyBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYGxhYmVsVmFsdWVgKSA6IC0xO1xuICAgIGNvbnN0IHhGaWx0ZXJEYXRhSWR4ID0geEZpbHRlcktleSAhPSBudWxsID8gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGB4RmlsdGVyVmFsdWVgKSA6IHZvaWQgMDtcbiAgICBjb25zdCB5RmlsdGVyRGF0YUlkeCA9IHlGaWx0ZXJLZXkgIT0gbnVsbCA/IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgeUZpbHRlclZhbHVlYCkgOiB2b2lkIDA7XG4gICAgY29uc3Qgc2l6ZUZpbHRlckRhdGFJZHggPSBzaXplRmlsdGVyS2V5ICE9IG51bGwgPyBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYHNpemVGaWx0ZXJWYWx1ZWApIDogdm9pZCAwO1xuICAgIGNvbnN0IHhTY2FsZSA9IHhBeGlzLnNjYWxlO1xuICAgIGNvbnN0IHlTY2FsZSA9IHlBeGlzLnNjYWxlO1xuICAgIGNvbnN0IHhPZmZzZXQgPSAoeFNjYWxlLmJhbmR3aWR0aCA/PyAwKSAvIDI7XG4gICAgY29uc3QgeU9mZnNldCA9ICh5U2NhbGUuYmFuZHdpZHRoID8/IDApIC8gMjtcbiAgICBjb25zdCBub2RlRGF0YSA9IFtdO1xuICAgIHNpemVTY2FsZS5yYW5nZSA9IFttYXJrZXIuc2l6ZSwgbWFya2VyLm1heFNpemVdO1xuICAgIGNvbnN0IGZvbnQgPSBsYWJlbC5nZXRGb250KCk7XG4gICAgY29uc3QgdGV4dE1lYXN1cmVyID0gQ2FjaGVkVGV4dE1lYXN1cmVyUG9vbC5nZXRNZWFzdXJlcih7IGZvbnQgfSk7XG4gICAgZm9yIChjb25zdCB7IHZhbHVlcywgZGF0dW0gfSBvZiBwcm9jZXNzZWREYXRhLmRhdGEgPz8gW10pIHtcbiAgICAgIGNvbnN0IHhEYXR1bSA9IHZhbHVlc1t4RGF0YUlkeF07XG4gICAgICBjb25zdCB5RGF0dW0gPSB2YWx1ZXNbeURhdGFJZHhdO1xuICAgICAgY29uc3Qgc2l6ZVZhbHVlID0gc2l6ZURhdGFJZHggIT0gbnVsbCA/IHZhbHVlc1tzaXplRGF0YUlkeF0gOiB2b2lkIDA7XG4gICAgICBjb25zdCB4ID0geFNjYWxlLmNvbnZlcnQoeERhdHVtKSArIHhPZmZzZXQ7XG4gICAgICBjb25zdCB5ID0geVNjYWxlLmNvbnZlcnQoeURhdHVtKSArIHlPZmZzZXQ7XG4gICAgICBsZXQgc2VsZWN0ZWQ7XG4gICAgICBpZiAoeEZpbHRlckRhdGFJZHggIT0gbnVsbCAmJiB5RmlsdGVyRGF0YUlkeCAhPSBudWxsKSB7XG4gICAgICAgIHNlbGVjdGVkID0gdmFsdWVzW3hGaWx0ZXJEYXRhSWR4XSA9PT0geERhdHVtICYmIHZhbHVlc1t5RmlsdGVyRGF0YUlkeF0gPT09IHlEYXR1bTtcbiAgICAgICAgaWYgKHNpemVGaWx0ZXJEYXRhSWR4ICE9IG51bGwpIHtcbiAgICAgICAgICBzZWxlY3RlZCAmJiAoc2VsZWN0ZWQgPSB2YWx1ZXNbc2l6ZUZpbHRlckRhdGFJZHhdID09PSBzaXplVmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBsYWJlbFRleHQgPSB0aGlzLmdldExhYmVsVGV4dChsYWJlbCwge1xuICAgICAgICB2YWx1ZTogbGFiZWxLZXkgPyB2YWx1ZXNbbGFiZWxEYXRhSWR4XSA6IHlEYXR1bSxcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIHhLZXksXG4gICAgICAgIHlLZXksXG4gICAgICAgIHNpemVLZXksXG4gICAgICAgIGxhYmVsS2V5LFxuICAgICAgICB4TmFtZSxcbiAgICAgICAgeU5hbWUsXG4gICAgICAgIHNpemVOYW1lLFxuICAgICAgICBsYWJlbE5hbWVcbiAgICAgIH0pO1xuICAgICAgY29uc3Qgc2l6ZSA9IHRleHRNZWFzdXJlci5tZWFzdXJlVGV4dChTdHJpbmcobGFiZWxUZXh0KSk7XG4gICAgICBjb25zdCBtYXJrZXJTaXplID0gc2l6ZVZhbHVlID8gc2l6ZVNjYWxlLmNvbnZlcnQoc2l6ZVZhbHVlKSA6IG1hcmtlci5zaXplO1xuICAgICAgY29uc3QgZmlsbCA9IGNvbG9yS2V5ID8gY29sb3JTY2FsZS5jb252ZXJ0KHZhbHVlc1tjb2xvckRhdGFJZHhdKSA6IHZvaWQgMDtcbiAgICAgIG5vZGVEYXRhLnB1c2goe1xuICAgICAgICBzZXJpZXM6IHRoaXMsXG4gICAgICAgIGl0ZW1JZDogeUtleSxcbiAgICAgICAgeUtleSxcbiAgICAgICAgeEtleSxcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIHhWYWx1ZTogeERhdHVtLFxuICAgICAgICB5VmFsdWU6IHlEYXR1bSxcbiAgICAgICAgc2l6ZVZhbHVlLFxuICAgICAgICBwb2ludDogeyB4LCB5LCBzaXplOiBtYXJrZXJTaXplIH0sXG4gICAgICAgIG1pZFBvaW50OiB7IHgsIHkgfSxcbiAgICAgICAgZmlsbCxcbiAgICAgICAgbGFiZWw6IHsgdGV4dDogbGFiZWxUZXh0LCAuLi5zaXplIH0sXG4gICAgICAgIG1hcmtlcjogbWFya2VyU2hhcGUsXG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgc2VsZWN0ZWRcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgaXRlbUlkOiB5S2V5LFxuICAgICAgbm9kZURhdGEsXG4gICAgICBsYWJlbERhdGE6IG5vZGVEYXRhLFxuICAgICAgc2NhbGVzOiB0aGlzLmNhbGN1bGF0ZVNjYWxpbmcoKSxcbiAgICAgIHZpc2libGU6IHRoaXMudmlzaWJsZVxuICAgIH07XG4gIH1cbiAgaXNQYXRoT3JTZWxlY3Rpb25EaXJ0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLm1hcmtlci5pc0RpcnR5KCk7XG4gIH1cbiAgZ2V0TGFiZWxEYXRhKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHROb2RlRGF0YT8ubGFiZWxEYXRhID8/IFtdO1xuICB9XG4gIG1hcmtlckZhY3RvcnkoKSB7XG4gICAgY29uc3QgeyBzaGFwZSB9ID0gdGhpcy5wcm9wZXJ0aWVzLm1hcmtlcjtcbiAgICBjb25zdCBNYXJrZXJTaGFwZSA9IGdldE1hcmtlcihzaGFwZSk7XG4gICAgcmV0dXJuIG5ldyBNYXJrZXJTaGFwZSgpO1xuICB9XG4gIGFzeW5jIHVwZGF0ZU1hcmtlclNlbGVjdGlvbihvcHRzKSB7XG4gICAgY29uc3QgeyBub2RlRGF0YSwgbWFya2VyU2VsZWN0aW9uIH0gPSBvcHRzO1xuICAgIGlmICh0aGlzLnByb3BlcnRpZXMubWFya2VyLmlzRGlydHkoKSkge1xuICAgICAgbWFya2VyU2VsZWN0aW9uLmNsZWFyKCk7XG4gICAgICBtYXJrZXJTZWxlY3Rpb24uY2xlYW51cCgpO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gdGhpcy5wcm9wZXJ0aWVzLm1hcmtlci5lbmFibGVkID8gbm9kZURhdGEgOiBbXTtcbiAgICByZXR1cm4gbWFya2VyU2VsZWN0aW9uLnVwZGF0ZShcbiAgICAgIGRhdGEsXG4gICAgICB2b2lkIDAsXG4gICAgICAoZGF0dW0pID0+IGNyZWF0ZURhdHVtSWQoW2RhdHVtLnhWYWx1ZSwgZGF0dW0ueVZhbHVlLCBkYXR1bS5sYWJlbC50ZXh0XSlcbiAgICApO1xuICB9XG4gIGFzeW5jIHVwZGF0ZU1hcmtlck5vZGVzKG9wdHMpIHtcbiAgICBjb25zdCB7IG1hcmtlclNlbGVjdGlvbiwgaXNIaWdobGlnaHQ6IGhpZ2hsaWdodGVkIH0gPSBvcHRzO1xuICAgIGNvbnN0IHsgeEtleSwgeUtleSwgc2l6ZUtleSwgbGFiZWxLZXksIG1hcmtlciB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHsgc2l6ZSwgc2hhcGUsIGZpbGwsIGZpbGxPcGFjaXR5LCBzdHJva2UsIHN0cm9rZVdpZHRoLCBzdHJva2VPcGFjaXR5IH0gPSBtZXJnZURlZmF1bHRzKFxuICAgICAgaGlnaGxpZ2h0ZWQgJiYgdGhpcy5wcm9wZXJ0aWVzLmhpZ2hsaWdodFN0eWxlLml0ZW0sXG4gICAgICBtYXJrZXIuZ2V0U3R5bGUoKVxuICAgICk7XG4gICAgY29uc3QgYmFzZVN0eWxlID0geyBzaXplLCBzaGFwZSwgZmlsbCwgZmlsbE9wYWNpdHksIHN0cm9rZSwgc3Ryb2tlV2lkdGgsIHN0cm9rZU9wYWNpdHkgfTtcbiAgICB0aGlzLnNpemVTY2FsZS5yYW5nZSA9IFttYXJrZXIuc2l6ZSwgbWFya2VyLm1heFNpemVdO1xuICAgIG1hcmtlclNlbGVjdGlvbi5lYWNoKChub2RlLCBkYXR1bSkgPT4ge1xuICAgICAgdGhpcy51cGRhdGVNYXJrZXJTdHlsZShub2RlLCBtYXJrZXIsIHsgZGF0dW0sIGhpZ2hsaWdodGVkLCB4S2V5LCB5S2V5LCBzaXplS2V5LCBsYWJlbEtleSB9LCBiYXNlU3R5bGUsIHtcbiAgICAgICAgc2VsZWN0ZWQ6IGRhdHVtLnNlbGVjdGVkXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAoIWhpZ2hsaWdodGVkKSB7XG4gICAgICB0aGlzLnByb3BlcnRpZXMubWFya2VyLm1hcmtDbGVhbigpO1xuICAgIH1cbiAgfVxuICBhc3luYyB1cGRhdGVMYWJlbFNlbGVjdGlvbihvcHRzKSB7XG4gICAgY29uc3QgcGxhY2VkTGFiZWxzID0gdGhpcy5wcm9wZXJ0aWVzLmxhYmVsLmVuYWJsZWQgPyB0aGlzLmNoYXJ0Py5wbGFjZUxhYmVscygpLmdldCh0aGlzKSA/PyBbXSA6IFtdO1xuICAgIHJldHVybiBvcHRzLmxhYmVsU2VsZWN0aW9uLnVwZGF0ZShcbiAgICAgIHBsYWNlZExhYmVscy5tYXAoKHYpID0+ICh7XG4gICAgICAgIC4uLnYuZGF0dW0sXG4gICAgICAgIHBvaW50OiB7XG4gICAgICAgICAgeDogdi54LFxuICAgICAgICAgIHk6IHYueSxcbiAgICAgICAgICBzaXplOiB2LmRhdHVtLnBvaW50LnNpemVcbiAgICAgICAgfVxuICAgICAgfSkpXG4gICAgKTtcbiAgfVxuICBhc3luYyB1cGRhdGVMYWJlbE5vZGVzKG9wdHMpIHtcbiAgICBjb25zdCB7IGxhYmVsIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgb3B0cy5sYWJlbFNlbGVjdGlvbi5lYWNoKCh0ZXh0LCBkYXR1bSkgPT4ge1xuICAgICAgdGV4dC50ZXh0ID0gZGF0dW0ubGFiZWwudGV4dDtcbiAgICAgIHRleHQuZmlsbCA9IGxhYmVsLmNvbG9yO1xuICAgICAgdGV4dC54ID0gZGF0dW0ucG9pbnQ/LnggPz8gMDtcbiAgICAgIHRleHQueSA9IGRhdHVtLnBvaW50Py55ID8/IDA7XG4gICAgICB0ZXh0LmZvbnRTdHlsZSA9IGxhYmVsLmZvbnRTdHlsZTtcbiAgICAgIHRleHQuZm9udFdlaWdodCA9IGxhYmVsLmZvbnRXZWlnaHQ7XG4gICAgICB0ZXh0LmZvbnRTaXplID0gbGFiZWwuZm9udFNpemU7XG4gICAgICB0ZXh0LmZvbnRGYW1pbHkgPSBsYWJlbC5mb250RmFtaWx5O1xuICAgICAgdGV4dC50ZXh0QWxpZ24gPSBcImxlZnRcIjtcbiAgICAgIHRleHQudGV4dEJhc2VsaW5lID0gXCJ0b3BcIjtcbiAgICB9KTtcbiAgfVxuICBnZXRUb29sdGlwSHRtbChub2RlRGF0dW0pIHtcbiAgICBjb25zdCB4QXhpcyA9IHRoaXMuYXhlc1tcInhcIiAvKiBYICovXTtcbiAgICBjb25zdCB5QXhpcyA9IHRoaXMuYXhlc1tcInlcIiAvKiBZICovXTtcbiAgICBpZiAoIXRoaXMucHJvcGVydGllcy5pc1ZhbGlkKCkgfHwgIXhBeGlzIHx8ICF5QXhpcykge1xuICAgICAgcmV0dXJuIEVNUFRZX1RPT0xUSVBfQ09OVEVOVDtcbiAgICB9XG4gICAgY29uc3QgeyB4S2V5LCB5S2V5LCBzaXplS2V5LCBsYWJlbEtleSwgeE5hbWUsIHlOYW1lLCBzaXplTmFtZSwgbGFiZWxOYW1lLCBtYXJrZXIsIHRvb2x0aXAgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCB0aXRsZSA9IHRoaXMucHJvcGVydGllcy50aXRsZSA/PyB5TmFtZTtcbiAgICBjb25zdCBiYXNlU3R5bGUgPSBtZXJnZURlZmF1bHRzKFxuICAgICAgeyBmaWxsOiBub2RlRGF0dW0uZmlsbCwgc3Ryb2tlV2lkdGg6IHRoaXMuZ2V0U3Ryb2tlV2lkdGgobWFya2VyLnN0cm9rZVdpZHRoKSB9LFxuICAgICAgbWFya2VyLmdldFN0eWxlKClcbiAgICApO1xuICAgIGNvbnN0IHsgZmlsbDogY29sb3IgPSBcImdyYXlcIiB9ID0gdGhpcy5nZXRNYXJrZXJTdHlsZShcbiAgICAgIG1hcmtlcixcbiAgICAgIHsgZGF0dW06IG5vZGVEYXR1bSwgaGlnaGxpZ2h0ZWQ6IGZhbHNlLCB4S2V5LCB5S2V5LCBzaXplS2V5LCBsYWJlbEtleSB9LFxuICAgICAgYmFzZVN0eWxlXG4gICAgKTtcbiAgICBjb25zdCB7XG4gICAgICBkYXR1bSxcbiAgICAgIHhWYWx1ZSxcbiAgICAgIHlWYWx1ZSxcbiAgICAgIHNpemVWYWx1ZSxcbiAgICAgIGxhYmVsOiB7IHRleHQ6IGxhYmVsVGV4dCB9LFxuICAgICAgaXRlbUlkXG4gICAgfSA9IG5vZGVEYXR1bTtcbiAgICBjb25zdCB4U3RyaW5nID0gc2FuaXRpemVIdG1sKHhBeGlzLmZvcm1hdERhdHVtKHhWYWx1ZSkpO1xuICAgIGNvbnN0IHlTdHJpbmcgPSBzYW5pdGl6ZUh0bWwoeUF4aXMuZm9ybWF0RGF0dW0oeVZhbHVlKSk7XG4gICAgbGV0IGNvbnRlbnQgPSBgPGI+JHtzYW5pdGl6ZUh0bWwoeE5hbWUgPz8geEtleSl9PC9iPjogJHt4U3RyaW5nfTxicj48Yj4ke3Nhbml0aXplSHRtbCh5TmFtZSA/PyB5S2V5KX08L2I+OiAke3lTdHJpbmd9YDtcbiAgICBpZiAoc2l6ZUtleSkge1xuICAgICAgY29udGVudCArPSBgPGJyPjxiPiR7c2FuaXRpemVIdG1sKHNpemVOYW1lID8/IHNpemVLZXkpfTwvYj46ICR7c2FuaXRpemVIdG1sKFN0cmluZyhzaXplVmFsdWUpKX1gO1xuICAgIH1cbiAgICBpZiAobGFiZWxLZXkpIHtcbiAgICAgIGNvbnRlbnQgPSBgPGI+JHtzYW5pdGl6ZUh0bWwobGFiZWxOYW1lID8/IGxhYmVsS2V5KX08L2I+OiAke3Nhbml0aXplSHRtbChsYWJlbFRleHQpfTxicj5gICsgY29udGVudDtcbiAgICB9XG4gICAgcmV0dXJuIHRvb2x0aXAudG9Ub29sdGlwSHRtbChcbiAgICAgIHsgdGl0bGUsIGNvbnRlbnQsIGJhY2tncm91bmRDb2xvcjogY29sb3IgfSxcbiAgICAgIHtcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIGl0ZW1JZCxcbiAgICAgICAgeEtleSxcbiAgICAgICAgeE5hbWUsXG4gICAgICAgIHlLZXksXG4gICAgICAgIHlOYW1lLFxuICAgICAgICBzaXplS2V5LFxuICAgICAgICBzaXplTmFtZSxcbiAgICAgICAgbGFiZWxLZXksXG4gICAgICAgIGxhYmVsTmFtZSxcbiAgICAgICAgdGl0bGUsXG4gICAgICAgIGNvbG9yLFxuICAgICAgICBzZXJpZXNJZDogdGhpcy5pZFxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgZ2V0TGVnZW5kRGF0YSgpIHtcbiAgICBpZiAoIXRoaXMuZGF0YT8ubGVuZ3RoIHx8ICF0aGlzLnByb3BlcnRpZXMuaXNWYWxpZCgpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IHsgeUtleSwgeU5hbWUsIHRpdGxlLCBtYXJrZXIsIHZpc2libGUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCB7IHNoYXBlLCBmaWxsLCBzdHJva2UsIGZpbGxPcGFjaXR5LCBzdHJva2VPcGFjaXR5LCBzdHJva2VXaWR0aCB9ID0gbWFya2VyO1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIGxlZ2VuZFR5cGU6IFwiY2F0ZWdvcnlcIixcbiAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgIGl0ZW1JZDogeUtleSxcbiAgICAgICAgc2VyaWVzSWQ6IHRoaXMuaWQsXG4gICAgICAgIGVuYWJsZWQ6IHZpc2libGUsXG4gICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgdGV4dDogdGl0bGUgPz8geU5hbWUgPz8geUtleVxuICAgICAgICB9LFxuICAgICAgICBzeW1ib2xzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgbWFya2VyOiB7XG4gICAgICAgICAgICAgIHNoYXBlLFxuICAgICAgICAgICAgICBmaWxsOiBmaWxsID8/IFwicmdiYSgwLCAwLCAwLCAwKVwiLFxuICAgICAgICAgICAgICBzdHJva2U6IHN0cm9rZSA/PyBcInJnYmEoMCwgMCwgMCwgMClcIixcbiAgICAgICAgICAgICAgZmlsbE9wYWNpdHk6IGZpbGxPcGFjaXR5ID8/IDEsXG4gICAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IHN0cm9rZU9wYWNpdHkgPz8gMSxcbiAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoID8/IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH1cbiAgICBdO1xuICB9XG4gIGFuaW1hdGVFbXB0eVVwZGF0ZVJlYWR5KHsgbWFya2VyU2VsZWN0aW9uLCBsYWJlbFNlbGVjdGlvbiB9KSB7XG4gICAgbWFya2VyU2NhbGVJbkFuaW1hdGlvbih0aGlzLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCBtYXJrZXJTZWxlY3Rpb24pO1xuICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwibGFiZWxzXCIsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIGxhYmVsU2VsZWN0aW9uKTtcbiAgfVxuICBpc0xhYmVsRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLmxhYmVsLmVuYWJsZWQ7XG4gIH1cbiAgbm9kZUZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIG5ldyBHcm91cCgpO1xuICB9XG4gIGdldEZvcm1hdHRlZE1hcmtlclN0eWxlKGRhdHVtKSB7XG4gICAgY29uc3QgeyB4S2V5LCB5S2V5LCBzaXplS2V5LCBsYWJlbEtleSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIHJldHVybiB0aGlzLmdldE1hcmtlclN0eWxlKHRoaXMucHJvcGVydGllcy5tYXJrZXIsIHtcbiAgICAgIGRhdHVtLFxuICAgICAgeEtleSxcbiAgICAgIHlLZXksXG4gICAgICBzaXplS2V5LFxuICAgICAgbGFiZWxLZXksXG4gICAgICBoaWdobGlnaHRlZDogZmFsc2VcbiAgICB9KTtcbiAgfVxuICBjb21wdXRlRm9jdXNCb3VuZHMob3B0cykge1xuICAgIHJldHVybiBjb21wdXRlTWFya2VyRm9jdXNCb3VuZHModGhpcywgb3B0cyk7XG4gIH1cbn07XG5CdWJibGVTZXJpZXMuY2xhc3NOYW1lID0gXCJCdWJibGVTZXJpZXNcIjtcbkJ1YmJsZVNlcmllcy50eXBlID0gXCJidWJibGVcIjtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9idWJibGVTZXJpZXNNb2R1bGUudHNcbnZhciBCdWJibGVTZXJpZXNNb2R1bGUgPSB7XG4gIHR5cGU6IFwic2VyaWVzXCIsXG4gIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIixcbiAgcGFja2FnZVR5cGU6IFwiY29tbXVuaXR5XCIsXG4gIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiXSxcbiAgaWRlbnRpZmllcjogXCJidWJibGVcIixcbiAgbW9kdWxlRmFjdG9yeTogKGN0eCkgPT4gbmV3IEJ1YmJsZVNlcmllcyhjdHgpLFxuICB0b29sdGlwRGVmYXVsdHM6IHsgcmFuZ2U6IFwibmVhcmVzdFwiIH0sXG4gIGRlZmF1bHRBeGVzOiBbXG4gICAge1xuICAgICAgdHlwZTogXCJudW1iZXJcIiAvKiBOVU1CRVIgKi8sXG4gICAgICBwb3NpdGlvbjogXCJib3R0b21cIiAvKiBCT1RUT00gKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIHR5cGU6IFwibnVtYmVyXCIgLyogTlVNQkVSICovLFxuICAgICAgcG9zaXRpb246IFwibGVmdFwiIC8qIExFRlQgKi9cbiAgICB9XG4gIF0sXG4gIHRoZW1lVGVtcGxhdGU6IHtcbiAgICBzZXJpZXM6IHtcbiAgICAgIHNoYXBlOiBcImNpcmNsZVwiLFxuICAgICAgc2l6ZTogNyxcbiAgICAgIG1heFNpemU6IDMwLFxuICAgICAgZmlsbE9wYWNpdHk6IDAuOCxcbiAgICAgIHRvb2x0aXA6IHsgcG9zaXRpb246IHsgdHlwZTogXCJub2RlXCIgfSB9LFxuICAgICAgbGFiZWw6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgICAgZm9udEZhbWlseTogREVGQVVMVF9GT05UX0ZBTUlMWSxcbiAgICAgICAgY29sb3I6IERFRkFVTFRfTEFCRUxfQ09MT1VSXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwYWxldHRlRmFjdG9yeTogc2luZ2xlU2VyaWVzUGFsZXR0ZUZhY3Rvcnlcbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vaGlzdG9ncmFtU2VyaWVzUHJvcGVydGllcy50c1xudmFyIEhpc3RvZ3JhbVNlcmllc1Byb3BlcnRpZXMgPSBjbGFzcyBleHRlbmRzIENhcnRlc2lhblNlcmllc1Byb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuZmlsbE9wYWNpdHkgPSAxO1xuICAgIHRoaXMuc3Ryb2tlV2lkdGggPSAxO1xuICAgIHRoaXMuc3Ryb2tlT3BhY2l0eSA9IDE7XG4gICAgdGhpcy5saW5lRGFzaCA9IFswXTtcbiAgICB0aGlzLmxpbmVEYXNoT2Zmc2V0ID0gMDtcbiAgICB0aGlzLmNvcm5lclJhZGl1cyA9IDA7XG4gICAgdGhpcy5hcmVhUGxvdCA9IGZhbHNlO1xuICAgIHRoaXMuYWdncmVnYXRpb24gPSBcInN1bVwiO1xuICAgIHRoaXMuc2hhZG93ID0gbmV3IERyb3BTaGFkb3coKTtcbiAgICB0aGlzLmxhYmVsID0gbmV3IExhYmVsKCk7XG4gICAgdGhpcy50b29sdGlwID0gbmV3IFNlcmllc1Rvb2x0aXAoKTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORylcbl0sIEhpc3RvZ3JhbVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInhLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEhpc3RvZ3JhbVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInlLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEhpc3RvZ3JhbVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInhOYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBIaXN0b2dyYW1TZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ5TmFtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgSGlzdG9ncmFtU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiZmlsbFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPKVxuXSwgSGlzdG9ncmFtU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiZmlsbE9wYWNpdHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEhpc3RvZ3JhbVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0cm9rZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIEhpc3RvZ3JhbVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0cm9rZVdpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8pXG5dLCBIaXN0b2dyYW1TZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdHJva2VPcGFjaXR5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTElORV9EQVNIKVxuXSwgSGlzdG9ncmFtU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGluZURhc2hcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBIaXN0b2dyYW1TZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJsaW5lRGFzaE9mZnNldFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIEhpc3RvZ3JhbVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNvcm5lclJhZGl1c1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBIaXN0b2dyYW1TZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJhcmVhUGxvdFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEFSUkFZLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBIaXN0b2dyYW1TZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJiaW5zXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoVU5JT04oW1wiY291bnRcIiwgXCJzdW1cIiwgXCJtZWFuXCJdLCBcImEgaGlzdG9ncmFtIGFnZ3JlZ2F0aW9uXCIpKVxuXSwgSGlzdG9ncmFtU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiYWdncmVnYXRpb25cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEhpc3RvZ3JhbVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImJpbkNvdW50XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgSGlzdG9ncmFtU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic2hhZG93XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgSGlzdG9ncmFtU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGFiZWxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBIaXN0b2dyYW1TZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ0b29sdGlwXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2hpc3RvZ3JhbVNlcmllcy50c1xudmFyIGRlZmF1bHRCaW5Db3VudCA9IDEwO1xudmFyIEhpc3RvZ3JhbVNlcmllcyA9IGNsYXNzIGV4dGVuZHMgQ2FydGVzaWFuU2VyaWVzIHtcbiAgY29uc3RydWN0b3IobW9kdWxlQ3R4KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbW9kdWxlQ3R4LFxuICAgICAgZGlyZWN0aW9uS2V5czogREVGQVVMVF9DQVJURVNJQU5fRElSRUNUSU9OX0tFWVMsXG4gICAgICBkaXJlY3Rpb25OYW1lczogREVGQVVMVF9DQVJURVNJQU5fRElSRUNUSU9OX05BTUVTLFxuICAgICAgcGlja01vZGVzOiBbMSAvKiBORUFSRVNUX05PREUgKi8sIDAgLyogRVhBQ1RfU0hBUEVfTUFUQ0ggKi9dLFxuICAgICAgZGF0dW1TZWxlY3Rpb25HYXJiYWdlQ29sbGVjdGlvbjogZmFsc2UsXG4gICAgICBhbmltYXRpb25SZXNldEZuczoge1xuICAgICAgICBkYXR1bTogcmVzZXRCYXJTZWxlY3Rpb25zRm4sXG4gICAgICAgIGxhYmVsOiByZXNldExhYmVsRm5cbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnByb3BlcnRpZXMgPSBuZXcgSGlzdG9ncmFtU2VyaWVzUHJvcGVydGllcygpO1xuICAgIHRoaXMuY2FsY3VsYXRlZEJpbnMgPSBbXTtcbiAgfVxuICAvLyBEdXJpbmcgcHJvY2Vzc0RhdGEgcGhhc2UsIHVzZWQgdG8gdW5pZnkgZGlmZmVyZW50IHdheXMgb2YgdGhlIHVzZXIgc3BlY2lmeWluZ1xuICAvLyB0aGUgYmlucy4gUmV0dXJucyBiaW5zIGluIGZvcm1hdFtbbWluMSwgbWF4MV0sIFttaW4yLCBtYXgyXSwgLi4uIF0uXG4gIGRlcml2ZUJpbnMoeERvbWFpbikge1xuICAgIGNvbnN0IGJpblN0YXJ0cyA9IGNyZWF0ZVRpY2tzKHhEb21haW5bMF0sIHhEb21haW5bMV0sIGRlZmF1bHRCaW5Db3VudCk7XG4gICAgY29uc3QgYmluU2l6ZSA9IHRpY2tTdGVwKHhEb21haW5bMF0sIHhEb21haW5bMV0sIGRlZmF1bHRCaW5Db3VudCk7XG4gICAgY29uc3QgW2ZpcnN0QmluRW5kXSA9IGJpblN0YXJ0cztcbiAgICBjb25zdCBleHBhbmRTdGFydFRvQmluID0gKG4pID0+IFtuLCBuICsgYmluU2l6ZV07XG4gICAgcmV0dXJuIFtbZmlyc3RCaW5FbmQgLSBiaW5TaXplLCBmaXJzdEJpbkVuZF0sIC4uLmJpblN0YXJ0cy5tYXAoZXhwYW5kU3RhcnRUb0JpbildO1xuICB9XG4gIGNhbGN1bGF0ZU5pY2VCaW5zKGRvbWFpbiwgYmluQ291bnQpIHtcbiAgICBjb25zdCBzdGFydEd1ZXNzID0gTWF0aC5mbG9vcihkb21haW5bMF0pO1xuICAgIGNvbnN0IHN0b3AgPSBkb21haW5bMV07XG4gICAgY29uc3Qgc2VnbWVudHMgPSBiaW5Db3VudCB8fCAxO1xuICAgIGNvbnN0IHsgc3RhcnQ6IHN0YXJ0MiwgYmluU2l6ZSB9ID0gdGhpcy5jYWxjdWxhdGVOaWNlU3RhcnQoc3RhcnRHdWVzcywgc3RvcCwgc2VnbWVudHMpO1xuICAgIHJldHVybiB0aGlzLmdldEJpbnMoc3RhcnQyLCBzdG9wLCBiaW5TaXplLCBzZWdtZW50cyk7XG4gIH1cbiAgZ2V0QmlucyhzdGFydDIsIHN0b3AsIHN0ZXAsIGNvdW50KSB7XG4gICAgY29uc3QgYmlucyA9IFtdO1xuICAgIGNvbnN0IHByZWNpc2lvbiA9IHRoaXMuY2FsY3VsYXRlUHJlY2lzaW9uKHN0ZXApO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgYSA9IE1hdGgucm91bmQoKHN0YXJ0MiArIGkgKiBzdGVwKSAqIHByZWNpc2lvbikgLyBwcmVjaXNpb247XG4gICAgICBsZXQgYiA9IE1hdGgucm91bmQoKHN0YXJ0MiArIChpICsgMSkgKiBzdGVwKSAqIHByZWNpc2lvbikgLyBwcmVjaXNpb247XG4gICAgICBpZiAoaSA9PT0gY291bnQgLSAxKSB7XG4gICAgICAgIGIgPSBNYXRoLm1heChiLCBzdG9wKTtcbiAgICAgIH1cbiAgICAgIGJpbnNbaV0gPSBbYSwgYl07XG4gICAgfVxuICAgIHJldHVybiBiaW5zO1xuICB9XG4gIGNhbGN1bGF0ZVByZWNpc2lvbihzdGVwKSB7XG4gICAgbGV0IHByZWNpc2lvbiA9IDEwO1xuICAgIGlmIChpc0Zpbml0ZShzdGVwKSAmJiBzdGVwID4gMCkge1xuICAgICAgd2hpbGUgKHN0ZXAgPCAxKSB7XG4gICAgICAgIHByZWNpc2lvbiAqPSAxMDtcbiAgICAgICAgc3RlcCAqPSAxMDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByZWNpc2lvbjtcbiAgfVxuICBjYWxjdWxhdGVOaWNlU3RhcnQoYSwgYiwgc2VnbWVudHMpIHtcbiAgICBjb25zdCBiaW5TaXplID0gTWF0aC5hYnMoYiAtIGEpIC8gc2VnbWVudHM7XG4gICAgY29uc3Qgb3JkZXIgPSBNYXRoLmZsb29yKE1hdGgubG9nMTAoYmluU2l6ZSkpO1xuICAgIGNvbnN0IG1hZ25pdHVkZSA9IE1hdGgucG93KDEwLCBvcmRlcik7XG4gICAgY29uc3Qgc3RhcnQyID0gTWF0aC5mbG9vcihhIC8gbWFnbml0dWRlKSAqIG1hZ25pdHVkZTtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IHN0YXJ0MixcbiAgICAgIGJpblNpemVcbiAgICB9O1xuICB9XG4gIGFzeW5jIHByb2Nlc3NEYXRhKGRhdGFDb250cm9sbGVyKSB7XG4gICAgaWYgKCF0aGlzLnZpc2libGUpIHtcbiAgICAgIHRoaXMucHJvY2Vzc2VkRGF0YSA9IHZvaWQgMDtcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcInVwZGF0ZURhdGFcIik7XG4gICAgfVxuICAgIGNvbnN0IHsgeEtleSwgeUtleSwgYXJlYVBsb3QsIGFnZ3JlZ2F0aW9uIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgeFNjYWxlID0gdGhpcy5heGVzW1wieFwiIC8qIFggKi9dPy5zY2FsZTtcbiAgICBjb25zdCB5U2NhbGUgPSB0aGlzLmF4ZXNbXCJ5XCIgLyogWSAqL10/LnNjYWxlO1xuICAgIGNvbnN0IHsgeFNjYWxlVHlwZSwgeVNjYWxlVHlwZSB9ID0gdGhpcy5nZXRTY2FsZUluZm9ybWF0aW9uKHsgeVNjYWxlLCB4U2NhbGUgfSk7XG4gICAgY29uc3QgcHJvcHMgPSBba2V5UHJvcGVydHkoeEtleSwgeFNjYWxlVHlwZSksIFNPUlRfRE9NQUlOX0dST1VQU107XG4gICAgaWYgKHlLZXkpIHtcbiAgICAgIGxldCBhZ2dQcm9wID0gZ3JvdXBDb3VudChcImdyb3VwQWdnXCIpO1xuICAgICAgaWYgKGFnZ3JlZ2F0aW9uID09PSBcImNvdW50XCIpIHtcbiAgICAgIH0gZWxzZSBpZiAoYWdncmVnYXRpb24gPT09IFwic3VtXCIpIHtcbiAgICAgICAgYWdnUHJvcCA9IGdyb3VwU3VtKFwiZ3JvdXBBZ2dcIik7XG4gICAgICB9IGVsc2UgaWYgKGFnZ3JlZ2F0aW9uID09PSBcIm1lYW5cIikge1xuICAgICAgICBhZ2dQcm9wID0gZ3JvdXBBdmVyYWdlKFwiZ3JvdXBBZ2dcIik7XG4gICAgICB9XG4gICAgICBpZiAoYXJlYVBsb3QpIHtcbiAgICAgICAgYWdnUHJvcCA9IGFyZWEoXCJncm91cEFnZ1wiLCBhZ2dQcm9wKTtcbiAgICAgIH1cbiAgICAgIHByb3BzLnB1c2godmFsdWVQcm9wZXJ0eSh5S2V5LCB5U2NhbGVUeXBlLCB7IGludmFsaWRWYWx1ZTogdm9pZCAwIH0pLCBhZ2dQcm9wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGFnZ1Byb3AgPSBncm91cENvdW50KFwiZ3JvdXBBZ2dcIik7XG4gICAgICBpZiAoYXJlYVBsb3QpIHtcbiAgICAgICAgYWdnUHJvcCA9IGFyZWEoXCJncm91cEFnZ1wiLCBhZ2dQcm9wKTtcbiAgICAgIH1cbiAgICAgIHByb3BzLnB1c2goYWdnUHJvcCk7XG4gICAgfVxuICAgIGNvbnN0IGdyb3VwQnlGbiA9IChkYXRhU2V0KSA9PiB7XG4gICAgICBjb25zdCB4RXh0ZW50ID0gZml4TnVtZXJpY0V4dGVudChkYXRhU2V0LmRvbWFpbi5rZXlzWzBdKTtcbiAgICAgIGlmICh4RXh0ZW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBkYXRhU2V0LmRvbWFpbi5ncm91cHMgPSBbXTtcbiAgICAgICAgcmV0dXJuICgpID0+IFtdO1xuICAgICAgfVxuICAgICAgY29uc3QgYmlucyA9IGlzTnVtYmVyKHRoaXMucHJvcGVydGllcy5iaW5Db3VudCkgPyB0aGlzLmNhbGN1bGF0ZU5pY2VCaW5zKHhFeHRlbnQsIHRoaXMucHJvcGVydGllcy5iaW5Db3VudCkgOiB0aGlzLnByb3BlcnRpZXMuYmlucyA/PyB0aGlzLmRlcml2ZUJpbnMoeEV4dGVudCk7XG4gICAgICBjb25zdCBiaW5Db3VudCA9IGJpbnMubGVuZ3RoO1xuICAgICAgdGhpcy5jYWxjdWxhdGVkQmlucyA9IFsuLi5iaW5zXTtcbiAgICAgIHJldHVybiAoaXRlbSkgPT4ge1xuICAgICAgICBjb25zdCB4VmFsdWUgPSBpdGVtLmtleXNbMF07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmluQ291bnQ7IGkrKykge1xuICAgICAgICAgIGNvbnN0IG5leHRCaW4gPSBiaW5zW2ldO1xuICAgICAgICAgIGlmICh4VmFsdWUgPj0gbmV4dEJpblswXSAmJiB4VmFsdWUgPCBuZXh0QmluWzFdKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dEJpbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGkgPT09IGJpbkNvdW50IC0gMSAmJiB4VmFsdWUgPD0gbmV4dEJpblsxXSkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHRCaW47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH07XG4gICAgfTtcbiAgICBpZiAoIXRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuaXNTa2lwcGVkKCkgJiYgdGhpcy5wcm9jZXNzZWREYXRhKSB7XG4gICAgICBwcm9wcy5wdXNoKGRpZmYodGhpcy5wcm9jZXNzZWREYXRhLCBmYWxzZSkpO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLnJlcXVlc3REYXRhTW9kZWwoZGF0YUNvbnRyb2xsZXIsIHRoaXMuZGF0YSwgeyBwcm9wcywgZ3JvdXBCeUZuIH0pO1xuICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcInVwZGF0ZURhdGFcIik7XG4gIH1cbiAgZ2V0U2VyaWVzRG9tYWluKGRpcmVjdGlvbikge1xuICAgIGNvbnN0IHsgcHJvY2Vzc2VkRGF0YSwgZGF0YU1vZGVsIH0gPSB0aGlzO1xuICAgIGlmICghcHJvY2Vzc2VkRGF0YSB8fCAhZGF0YU1vZGVsIHx8ICF0aGlzLmNhbGN1bGF0ZWRCaW5zLmxlbmd0aClcbiAgICAgIHJldHVybiBbXTtcbiAgICBjb25zdCB5RG9tYWluID0gZGF0YU1vZGVsLmdldERvbWFpbih0aGlzLCBgZ3JvdXBBZ2dgLCBcImFnZ3JlZ2F0ZVwiLCBwcm9jZXNzZWREYXRhKTtcbiAgICBjb25zdCB4RG9tYWluTWluID0gdGhpcy5jYWxjdWxhdGVkQmlucz8uWzBdWzBdO1xuICAgIGNvbnN0IHhEb21haW5NYXggPSB0aGlzLmNhbGN1bGF0ZWRCaW5zPy5bKHRoaXMuY2FsY3VsYXRlZEJpbnM/Lmxlbmd0aCA/PyAwKSAtIDFdWzFdO1xuICAgIGlmIChkaXJlY3Rpb24gPT09IFwieFwiIC8qIFggKi8pIHtcbiAgICAgIHJldHVybiBmaXhOdW1lcmljRXh0ZW50KFt4RG9tYWluTWluLCB4RG9tYWluTWF4XSk7XG4gICAgfVxuICAgIHJldHVybiBmaXhOdW1lcmljRXh0ZW50KHlEb21haW4pO1xuICB9XG4gIGFzeW5jIGNyZWF0ZU5vZGVEYXRhKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlkOiBzZXJpZXNJZCxcbiAgICAgIGF4ZXMsXG4gICAgICBwcm9jZXNzZWREYXRhLFxuICAgICAgY3R4OiB7IGNhbGxiYWNrQ2FjaGUgfVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHhBeGlzID0gYXhlc1tcInhcIiAvKiBYICovXTtcbiAgICBjb25zdCB5QXhpcyA9IGF4ZXNbXCJ5XCIgLyogWSAqL107XG4gICAgaWYgKCF4QXhpcyB8fCAheUF4aXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBzY2FsZTogeFNjYWxlIH0gPSB4QXhpcztcbiAgICBjb25zdCB7IHNjYWxlOiB5U2NhbGUgfSA9IHlBeGlzO1xuICAgIGNvbnN0IHsgeEtleSwgeUtleSwgeE5hbWUsIHlOYW1lLCBmaWxsLCBzdHJva2UsIHN0cm9rZVdpZHRoLCBjb3JuZXJSYWRpdXMgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCBsYWJlbEZvcm1hdHRlciA9IHRoaXMucHJvcGVydGllcy5sYWJlbC5mb3JtYXR0ZXIgPz8gKChwYXJhbXMpID0+IFN0cmluZyhwYXJhbXMudmFsdWUpKTtcbiAgICBjb25zdCBub2RlRGF0YSA9IFtdO1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBpdGVtSWQ6IHRoaXMucHJvcGVydGllcy55S2V5ID8/IHRoaXMuaWQsXG4gICAgICBub2RlRGF0YSxcbiAgICAgIGxhYmVsRGF0YTogbm9kZURhdGEsXG4gICAgICBzY2FsZXM6IHRoaXMuY2FsY3VsYXRlU2NhbGluZygpLFxuICAgICAgYW5pbWF0aW9uVmFsaWQ6IHRydWUsXG4gICAgICB2aXNpYmxlOiB0aGlzLnZpc2libGVcbiAgICB9O1xuICAgIGlmICghdGhpcy52aXNpYmxlIHx8ICFwcm9jZXNzZWREYXRhIHx8IHByb2Nlc3NlZERhdGEudHlwZSAhPT0gXCJncm91cGVkXCIpXG4gICAgICByZXR1cm4gY29udGV4dDtcbiAgICBwcm9jZXNzZWREYXRhLmRhdGEuZm9yRWFjaCgoZ3JvdXApID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYWdnVmFsdWVzOiBbW25lZ2F0aXZlQWdnLCBwb3NpdGl2ZUFnZ11dID0gW1swLCAwXV0sXG4gICAgICAgIGRhdHVtLFxuICAgICAgICBkYXR1bTogeyBsZW5ndGg6IGZyZXF1ZW5jeSB9LFxuICAgICAgICBrZXlzOiBkb21haW4sXG4gICAgICAgIGtleXM6IFt4RG9tYWluTWluLCB4RG9tYWluTWF4XVxuICAgICAgfSA9IGdyb3VwO1xuICAgICAgY29uc3QgeE1pblB4ID0geFNjYWxlLmNvbnZlcnQoeERvbWFpbk1pbik7XG4gICAgICBjb25zdCB4TWF4UHggPSB4U2NhbGUuY29udmVydCh4RG9tYWluTWF4KTtcbiAgICAgIGNvbnN0IHRvdGFsID0gbmVnYXRpdmVBZ2cgKyBwb3NpdGl2ZUFnZztcbiAgICAgIGNvbnN0IHlaZXJvUHggPSB5U2NhbGUuY29udmVydCgwKTtcbiAgICAgIGNvbnN0IHlNYXhQeCA9IHlTY2FsZS5jb252ZXJ0KHRvdGFsKTtcbiAgICAgIGNvbnN0IHcgPSBNYXRoLmFicyh4TWF4UHggLSB4TWluUHgpO1xuICAgICAgY29uc3QgaCA9IE1hdGguYWJzKHlNYXhQeCAtIHlaZXJvUHgpO1xuICAgICAgY29uc3QgeCA9IE1hdGgubWluKHhNaW5QeCwgeE1heFB4KTtcbiAgICAgIGNvbnN0IHkgPSBNYXRoLm1pbih5WmVyb1B4LCB5TWF4UHgpO1xuICAgICAgbGV0IHNlbGVjdGlvbkRhdHVtTGFiZWwgPSB2b2lkIDA7XG4gICAgICBpZiAodG90YWwgIT09IDApIHtcbiAgICAgICAgc2VsZWN0aW9uRGF0dW1MYWJlbCA9IHtcbiAgICAgICAgICB4OiB4ICsgdyAvIDIsXG4gICAgICAgICAgeTogeSArIGggLyAyLFxuICAgICAgICAgIHRleHQ6IGNhbGxiYWNrQ2FjaGUuY2FsbChsYWJlbEZvcm1hdHRlciwge1xuICAgICAgICAgICAgdmFsdWU6IHRvdGFsLFxuICAgICAgICAgICAgZGF0dW0sXG4gICAgICAgICAgICBzZXJpZXNJZCxcbiAgICAgICAgICAgIHhLZXksXG4gICAgICAgICAgICB5S2V5LFxuICAgICAgICAgICAgeE5hbWUsXG4gICAgICAgICAgICB5TmFtZVxuICAgICAgICAgIH0pID8/IFN0cmluZyh0b3RhbClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5vZGVNaWRQb2ludCA9IHtcbiAgICAgICAgeDogeCArIHcgLyAyLFxuICAgICAgICB5OiB5ICsgaCAvIDJcbiAgICAgIH07XG4gICAgICBjb25zdCB5QXhpc1JldmVyc2VkID0geUF4aXMuaXNSZXZlcnNlZCgpO1xuICAgICAgbm9kZURhdGEucHVzaCh7XG4gICAgICAgIHNlcmllczogdGhpcyxcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIC8vIHJlcXVpcmVkIGJ5IFNlcmllc05vZGVEYXR1bSwgYnV0IG1pZ2h0IG5vdCBtYWtlIHNlbnNlIGhlcmVcbiAgICAgICAgLy8gc2luY2UgZWFjaCBzZWxlY3Rpb24gaXMgYW4gYWdncmVnYXRpb24gb2YgbXVsdGlwbGUgZGF0YS5cbiAgICAgICAgYWdncmVnYXRlZFZhbHVlOiB0b3RhbCxcbiAgICAgICAgZnJlcXVlbmN5LFxuICAgICAgICBkb21haW4sXG4gICAgICAgIHlLZXksXG4gICAgICAgIHhLZXksXG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHhWYWx1ZTogeE1pblB4LFxuICAgICAgICB5VmFsdWU6IHlNYXhQeCxcbiAgICAgICAgd2lkdGg6IHcsXG4gICAgICAgIGhlaWdodDogaCxcbiAgICAgICAgbWlkUG9pbnQ6IG5vZGVNaWRQb2ludCxcbiAgICAgICAgZmlsbCxcbiAgICAgICAgc3Ryb2tlLFxuICAgICAgICBjb3JuZXJSYWRpdXMsXG4gICAgICAgIHRvcExlZnRDb3JuZXJSYWRpdXM6ICF5QXhpc1JldmVyc2VkLFxuICAgICAgICB0b3BSaWdodENvcm5lclJhZGl1czogIXlBeGlzUmV2ZXJzZWQsXG4gICAgICAgIGJvdHRvbVJpZ2h0Q29ybmVyUmFkaXVzOiB5QXhpc1JldmVyc2VkLFxuICAgICAgICBib3R0b21MZWZ0Q29ybmVyUmFkaXVzOiB5QXhpc1JldmVyc2VkLFxuICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICBzdHJva2VXaWR0aCxcbiAgICAgICAgbGFiZWw6IHNlbGVjdGlvbkRhdHVtTGFiZWxcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIG5vZGVEYXRhLnNvcnQoKGEsIGIpID0+IGEueCAtIGIueCk7XG4gICAgcmV0dXJuIGNvbnRleHQ7XG4gIH1cbiAgbm9kZUZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIG5ldyBSZWN0KCk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlRGF0dW1TZWxlY3Rpb24ob3B0cykge1xuICAgIGNvbnN0IHsgbm9kZURhdGEsIGRhdHVtU2VsZWN0aW9uIH0gPSBvcHRzO1xuICAgIHJldHVybiBkYXR1bVNlbGVjdGlvbi51cGRhdGUoXG4gICAgICBub2RlRGF0YSxcbiAgICAgIChyZWN0KSA9PiB7XG4gICAgICAgIHJlY3QuY3Jpc3AgPSB0cnVlO1xuICAgICAgfSxcbiAgICAgIChkYXR1bSkgPT4gZGF0dW0uZG9tYWluLmpvaW4oXCJfXCIpXG4gICAgKTtcbiAgfVxuICBhc3luYyB1cGRhdGVEYXR1bU5vZGVzKG9wdHMpIHtcbiAgICBjb25zdCB7IGlzSGlnaGxpZ2h0OiBpc0RhdHVtSGlnaGxpZ2h0ZWQgfSA9IG9wdHM7XG4gICAgY29uc3Qge1xuICAgICAgZmlsbE9wYWNpdHk6IHNlcmllc0ZpbGxPcGFjaXR5LFxuICAgICAgc3Ryb2tlT3BhY2l0eSxcbiAgICAgIGxpbmVEYXNoLFxuICAgICAgbGluZURhc2hPZmZzZXQsXG4gICAgICBzaGFkb3csXG4gICAgICBoaWdobGlnaHRTdHlsZToge1xuICAgICAgICBpdGVtOiB7XG4gICAgICAgICAgZmlsbDogaGlnaGxpZ2h0ZWRGaWxsLFxuICAgICAgICAgIGZpbGxPcGFjaXR5OiBoaWdobGlnaHRGaWxsT3BhY2l0eSA9IHNlcmllc0ZpbGxPcGFjaXR5LFxuICAgICAgICAgIHN0cm9rZTogaGlnaGxpZ2h0ZWRTdHJva2UsXG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IGhpZ2hsaWdodGVkRGF0dW1TdHJva2VXaWR0aFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBvcHRzLmRhdHVtU2VsZWN0aW9uLmVhY2goKHJlY3QsIGRhdHVtLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjb3JuZXJSYWRpdXMsXG4gICAgICAgIHRvcExlZnRDb3JuZXJSYWRpdXMsXG4gICAgICAgIHRvcFJpZ2h0Q29ybmVyUmFkaXVzLFxuICAgICAgICBib3R0b21SaWdodENvcm5lclJhZGl1cyxcbiAgICAgICAgYm90dG9tTGVmdENvcm5lclJhZGl1c1xuICAgICAgfSA9IGRhdHVtO1xuICAgICAgY29uc3Qgc3Ryb2tlV2lkdGggPSBpc0RhdHVtSGlnaGxpZ2h0ZWQgJiYgaGlnaGxpZ2h0ZWREYXR1bVN0cm9rZVdpZHRoICE9PSB2b2lkIDAgPyBoaWdobGlnaHRlZERhdHVtU3Ryb2tlV2lkdGggOiBkYXR1bS5zdHJva2VXaWR0aDtcbiAgICAgIGNvbnN0IGZpbGxPcGFjaXR5ID0gaXNEYXR1bUhpZ2hsaWdodGVkID8gaGlnaGxpZ2h0RmlsbE9wYWNpdHkgOiBzZXJpZXNGaWxsT3BhY2l0eTtcbiAgICAgIHJlY3QuZmlsbCA9IChpc0RhdHVtSGlnaGxpZ2h0ZWQgPyBoaWdobGlnaHRlZEZpbGwgOiB2b2lkIDApID8/IGRhdHVtLmZpbGw7XG4gICAgICByZWN0LnN0cm9rZSA9IChpc0RhdHVtSGlnaGxpZ2h0ZWQgPyBoaWdobGlnaHRlZFN0cm9rZSA6IHZvaWQgMCkgPz8gZGF0dW0uc3Ryb2tlO1xuICAgICAgcmVjdC5maWxsT3BhY2l0eSA9IGZpbGxPcGFjaXR5O1xuICAgICAgcmVjdC5zdHJva2VPcGFjaXR5ID0gc3Ryb2tlT3BhY2l0eTtcbiAgICAgIHJlY3Quc3Ryb2tlV2lkdGggPSBzdHJva2VXaWR0aDtcbiAgICAgIHJlY3QubGluZURhc2ggPSBsaW5lRGFzaDtcbiAgICAgIHJlY3QubGluZURhc2hPZmZzZXQgPSBsaW5lRGFzaE9mZnNldDtcbiAgICAgIHJlY3QudG9wTGVmdENvcm5lclJhZGl1cyA9IHRvcExlZnRDb3JuZXJSYWRpdXMgPyBjb3JuZXJSYWRpdXMgOiAwO1xuICAgICAgcmVjdC50b3BSaWdodENvcm5lclJhZGl1cyA9IHRvcFJpZ2h0Q29ybmVyUmFkaXVzID8gY29ybmVyUmFkaXVzIDogMDtcbiAgICAgIHJlY3QuYm90dG9tUmlnaHRDb3JuZXJSYWRpdXMgPSBib3R0b21SaWdodENvcm5lclJhZGl1cyA/IGNvcm5lclJhZGl1cyA6IDA7XG4gICAgICByZWN0LmJvdHRvbUxlZnRDb3JuZXJSYWRpdXMgPSBib3R0b21MZWZ0Q29ybmVyUmFkaXVzID8gY29ybmVyUmFkaXVzIDogMDtcbiAgICAgIHJlY3QuZmlsbFNoYWRvdyA9IHNoYWRvdztcbiAgICAgIHJlY3QuekluZGV4ID0gaXNEYXR1bUhpZ2hsaWdodGVkID8gU2VyaWVzLmhpZ2hsaWdodGVkWkluZGV4IDogaW5kZXg7XG4gICAgICByZWN0LnZpc2libGUgPSBkYXR1bS5oZWlnaHQgPiAwO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIHVwZGF0ZUxhYmVsU2VsZWN0aW9uKG9wdHMpIHtcbiAgICBjb25zdCB7IGxhYmVsRGF0YSwgbGFiZWxTZWxlY3Rpb24gfSA9IG9wdHM7XG4gICAgcmV0dXJuIGxhYmVsU2VsZWN0aW9uLnVwZGF0ZShsYWJlbERhdGEsICh0ZXh0KSA9PiB7XG4gICAgICB0ZXh0LnBvaW50ZXJFdmVudHMgPSAxIC8qIE5vbmUgKi87XG4gICAgICB0ZXh0LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgICB0ZXh0LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlTGFiZWxOb2RlcyhvcHRzKSB7XG4gICAgY29uc3QgeyBmb250U3R5bGUsIGZvbnRXZWlnaHQsIGZvbnRGYW1pbHksIGZvbnRTaXplLCBjb2xvciB9ID0gdGhpcy5wcm9wZXJ0aWVzLmxhYmVsO1xuICAgIGNvbnN0IGxhYmVsRW5hYmxlZCA9IHRoaXMuaXNMYWJlbEVuYWJsZWQoKTtcbiAgICBvcHRzLmxhYmVsU2VsZWN0aW9uLmVhY2goKHRleHQsIGRhdHVtKSA9PiB7XG4gICAgICBpZiAobGFiZWxFbmFibGVkICYmIGRhdHVtPy5sYWJlbCkge1xuICAgICAgICB0ZXh0LnRleHQgPSBkYXR1bS5sYWJlbC50ZXh0O1xuICAgICAgICB0ZXh0LnggPSBkYXR1bS5sYWJlbC54O1xuICAgICAgICB0ZXh0LnkgPSBkYXR1bS5sYWJlbC55O1xuICAgICAgICB0ZXh0LmZvbnRTdHlsZSA9IGZvbnRTdHlsZTtcbiAgICAgICAgdGV4dC5mb250V2VpZ2h0ID0gZm9udFdlaWdodDtcbiAgICAgICAgdGV4dC5mb250RmFtaWx5ID0gZm9udEZhbWlseTtcbiAgICAgICAgdGV4dC5mb250U2l6ZSA9IGZvbnRTaXplO1xuICAgICAgICB0ZXh0LmZpbGwgPSBjb2xvcjtcbiAgICAgICAgdGV4dC52aXNpYmxlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHQudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGluaXRRdWFkVHJlZShxdWFkdHJlZSkge1xuICAgIGNvbnN0IHsgdmFsdWU6IGNoaWxkTm9kZSB9ID0gdGhpcy5jb250ZW50R3JvdXAuY2hpbGRyZW4oKS5uZXh0KCk7XG4gICAgaWYgKGNoaWxkTm9kZSkge1xuICAgICAgYWRkSGl0VGVzdGVyc1RvUXVhZHRyZWUocXVhZHRyZWUsIGNoaWxkTm9kZS5jaGlsZHJlbigpKTtcbiAgICB9XG4gIH1cbiAgcGlja05vZGVDbG9zZXN0RGF0dW0ocG9pbnQpIHtcbiAgICByZXR1cm4gZmluZFF1YWR0cmVlTWF0Y2godGhpcywgcG9pbnQpO1xuICB9XG4gIGdldFRvb2x0aXBIdG1sKG5vZGVEYXR1bSkge1xuICAgIGNvbnN0IHhBeGlzID0gdGhpcy5heGVzW1wieFwiIC8qIFggKi9dO1xuICAgIGNvbnN0IHlBeGlzID0gdGhpcy5heGVzW1wieVwiIC8qIFkgKi9dO1xuICAgIGlmICghdGhpcy5wcm9wZXJ0aWVzLmlzVmFsaWQoKSB8fCAheEF4aXMgfHwgIXlBeGlzKSB7XG4gICAgICByZXR1cm4gRU1QVFlfVE9PTFRJUF9DT05URU5UO1xuICAgIH1cbiAgICBjb25zdCB7IHhLZXksIHlLZXksIHhOYW1lLCB5TmFtZSwgZmlsbDogY29sb3IsIGFnZ3JlZ2F0aW9uLCB0b29sdGlwIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3Qge1xuICAgICAgYWdncmVnYXRlZFZhbHVlLFxuICAgICAgZnJlcXVlbmN5LFxuICAgICAgZG9tYWluOiBbcmFuZ2VNaW4sIHJhbmdlTWF4XSxcbiAgICAgIGl0ZW1JZFxuICAgIH0gPSBub2RlRGF0dW07XG4gICAgY29uc3QgdGl0bGUgPSBgJHtzYW5pdGl6ZUh0bWwoeE5hbWUgPz8geEtleSl9OiAke3hBeGlzLmZvcm1hdERhdHVtKHJhbmdlTWluKX0gLSAke3hBeGlzLmZvcm1hdERhdHVtKHJhbmdlTWF4KX1gO1xuICAgIGxldCBjb250ZW50ID0geUtleSA/IGA8Yj4ke3Nhbml0aXplSHRtbCh5TmFtZSA/PyB5S2V5KX0gKCR7YWdncmVnYXRpb259KTwvYj46ICR7eUF4aXMuZm9ybWF0RGF0dW0oYWdncmVnYXRlZFZhbHVlKX08YnI+YCA6IFwiXCI7XG4gICAgY29udGVudCArPSBgPGI+RnJlcXVlbmN5PC9iPjogJHtmcmVxdWVuY3l9YDtcbiAgICBjb25zdCBkZWZhdWx0cyA9IHtcbiAgICAgIHRpdGxlLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiBjb2xvcixcbiAgICAgIGNvbnRlbnRcbiAgICB9O1xuICAgIHJldHVybiB0b29sdGlwLnRvVG9vbHRpcEh0bWwoZGVmYXVsdHMsIHtcbiAgICAgIGRhdHVtOiB7XG4gICAgICAgIGRhdGE6IG5vZGVEYXR1bS5kYXR1bSxcbiAgICAgICAgYWdncmVnYXRlZFZhbHVlOiBub2RlRGF0dW0uYWdncmVnYXRlZFZhbHVlLFxuICAgICAgICBkb21haW46IG5vZGVEYXR1bS5kb21haW4sXG4gICAgICAgIGZyZXF1ZW5jeTogbm9kZURhdHVtLmZyZXF1ZW5jeVxuICAgICAgfSxcbiAgICAgIGl0ZW1JZCxcbiAgICAgIHhLZXksXG4gICAgICB4TmFtZSxcbiAgICAgIHlLZXksXG4gICAgICB5TmFtZSxcbiAgICAgIGNvbG9yLFxuICAgICAgdGl0bGUsXG4gICAgICBzZXJpZXNJZDogdGhpcy5pZFxuICAgIH0pO1xuICB9XG4gIGdldExlZ2VuZERhdGEobGVnZW5kVHlwZSkge1xuICAgIGlmICghdGhpcy5kYXRhPy5sZW5ndGggfHwgbGVnZW5kVHlwZSAhPT0gXCJjYXRlZ29yeVwiKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IHsgeEtleSwgeU5hbWUsIGZpbGwsIGZpbGxPcGFjaXR5LCBzdHJva2UsIHN0cm9rZVdpZHRoLCBzdHJva2VPcGFjaXR5LCB2aXNpYmxlIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgbGVnZW5kVHlwZTogXCJjYXRlZ29yeVwiLFxuICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgaXRlbUlkOiB4S2V5LFxuICAgICAgICBzZXJpZXNJZDogdGhpcy5pZCxcbiAgICAgICAgZW5hYmxlZDogdmlzaWJsZSxcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICB0ZXh0OiB5TmFtZSA/PyB4S2V5ID8/IFwiRnJlcXVlbmN5XCJcbiAgICAgICAgfSxcbiAgICAgICAgc3ltYm9sczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1hcmtlcjoge1xuICAgICAgICAgICAgICBmaWxsOiBmaWxsID8/IFwicmdiYSgwLCAwLCAwLCAwKVwiLFxuICAgICAgICAgICAgICBzdHJva2U6IHN0cm9rZSA/PyBcInJnYmEoMCwgMCwgMCwgMClcIixcbiAgICAgICAgICAgICAgZmlsbE9wYWNpdHksXG4gICAgICAgICAgICAgIHN0cm9rZU9wYWNpdHksXG4gICAgICAgICAgICAgIHN0cm9rZVdpZHRoXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9XG4gICAgXTtcbiAgfVxuICBhbmltYXRlRW1wdHlVcGRhdGVSZWFkeSh7IGRhdHVtU2VsZWN0aW9uLCBsYWJlbFNlbGVjdGlvbiB9KSB7XG4gICAgY29uc3QgZm5zID0gcHJlcGFyZUJhckFuaW1hdGlvbkZ1bmN0aW9ucyhjb2xsYXBzZWRTdGFydGluZ0JhclBvc2l0aW9uKHRydWUsIHRoaXMuYXhlcywgXCJub3JtYWxcIikpO1xuICAgIGZyb21Ub01vdGlvbih0aGlzLmlkLCBcImRhdHVtc1wiLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCBbZGF0dW1TZWxlY3Rpb25dLCBmbnMpO1xuICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwibGFiZWxzXCIsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIGxhYmVsU2VsZWN0aW9uKTtcbiAgfVxuICBhbmltYXRlV2FpdGluZ1VwZGF0ZVJlYWR5KGRhdGEpIHtcbiAgICBjb25zdCBkYXRhRGlmZiA9IHRoaXMucHJvY2Vzc2VkRGF0YT8ucmVkdWNlZD8uZGlmZjtcbiAgICBjb25zdCBmbnMgPSBwcmVwYXJlQmFyQW5pbWF0aW9uRnVuY3Rpb25zKGNvbGxhcHNlZFN0YXJ0aW5nQmFyUG9zaXRpb24odHJ1ZSwgdGhpcy5heGVzLCBcIm5vcm1hbFwiKSk7XG4gICAgZnJvbVRvTW90aW9uKFxuICAgICAgdGhpcy5pZCxcbiAgICAgIFwiZGF0dW1zXCIsXG4gICAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLFxuICAgICAgW2RhdGEuZGF0dW1TZWxlY3Rpb25dLFxuICAgICAgZm5zLFxuICAgICAgKF8sIGRhdHVtKSA9PiBjcmVhdGVEYXR1bUlkKGRhdHVtLmRvbWFpbiksXG4gICAgICBkYXRhRGlmZlxuICAgICk7XG4gICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJsYWJlbHNcIiwgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgZGF0YS5sYWJlbFNlbGVjdGlvbik7XG4gIH1cbiAgaXNMYWJlbEVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcGVydGllcy5sYWJlbC5lbmFibGVkO1xuICB9XG4gIGNvbXB1dGVGb2N1c0JvdW5kcyh7IGRhdHVtSW5kZXgsIHNlcmllc1JlY3QgfSkge1xuICAgIHJldHVybiBjb21wdXRlQmFyRm9jdXNCb3VuZHModGhpcy5jb250ZXh0Tm9kZURhdGE/Lm5vZGVEYXRhW2RhdHVtSW5kZXhdLCB0aGlzLmNvbnRlbnRHcm91cCwgc2VyaWVzUmVjdCk7XG4gIH1cbn07XG5IaXN0b2dyYW1TZXJpZXMuY2xhc3NOYW1lID0gXCJIaXN0b2dyYW1TZXJpZXNcIjtcbkhpc3RvZ3JhbVNlcmllcy50eXBlID0gXCJoaXN0b2dyYW1cIjtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9oaXN0b2dyYW1TZXJpZXNNb2R1bGUudHNcbnZhciBIaXN0b2dyYW1TZXJpZXNNb2R1bGUgPSB7XG4gIHR5cGU6IFwic2VyaWVzXCIsXG4gIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIixcbiAgcGFja2FnZVR5cGU6IFwiY29tbXVuaXR5XCIsXG4gIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiXSxcbiAgaWRlbnRpZmllcjogXCJoaXN0b2dyYW1cIixcbiAgbW9kdWxlRmFjdG9yeTogKGN0eCkgPT4gbmV3IEhpc3RvZ3JhbVNlcmllcyhjdHgpLFxuICB0b29sdGlwRGVmYXVsdHM6IHsgcmFuZ2U6IFwiZXhhY3RcIiB9LFxuICBkZWZhdWx0QXhlczogW1xuICAgIHtcbiAgICAgIHR5cGU6IFwibnVtYmVyXCIgLyogTlVNQkVSICovLFxuICAgICAgcG9zaXRpb246IFwiYm90dG9tXCIgLyogQk9UVE9NICovXG4gICAgfSxcbiAgICB7XG4gICAgICB0eXBlOiBcIm51bWJlclwiIC8qIE5VTUJFUiAqLyxcbiAgICAgIHBvc2l0aW9uOiBcImxlZnRcIiAvKiBMRUZUICovXG4gICAgfVxuICBdLFxuICB0aGVtZVRlbXBsYXRlOiB7XG4gICAgc2VyaWVzOiB7XG4gICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgIGZpbGxPcGFjaXR5OiAxLFxuICAgICAgc3Ryb2tlT3BhY2l0eTogMSxcbiAgICAgIGxpbmVEYXNoOiBbMF0sXG4gICAgICBsaW5lRGFzaE9mZnNldDogMCxcbiAgICAgIGxhYmVsOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBmb250U2l6ZTogMTIsXG4gICAgICAgIGZvbnRGYW1pbHk6IERFRkFVTFRfRk9OVF9GQU1JTFksXG4gICAgICAgIGNvbG9yOiBERUZBVUxUX0lOU0lERV9TRVJJRVNfTEFCRUxfQ09MT1VSXG4gICAgICB9LFxuICAgICAgc2hhZG93OiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBjb2xvcjogREVGQVVMVF9TSEFET1dfQ09MT1VSLFxuICAgICAgICB4T2Zmc2V0OiAzLFxuICAgICAgICB5T2Zmc2V0OiAzLFxuICAgICAgICBibHVyOiA1XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwYWxldHRlRmFjdG9yeTogKHsgdGFrZUNvbG9ycyB9KSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgZmlsbHM6IFtmaWxsXSxcbiAgICAgIHN0cm9rZXM6IFtzdHJva2VdXG4gICAgfSA9IHRha2VDb2xvcnMoMSk7XG4gICAgcmV0dXJuIHsgZmlsbCwgc3Ryb2tlIH07XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vbGluZVNlcmllc1Byb3BlcnRpZXMudHNcbnZhciBMaW5lU2VyaWVzUHJvcGVydGllcyA9IGNsYXNzIGV4dGVuZHMgQ2FydGVzaWFuU2VyaWVzUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5zdHJva2UgPSBcIiM4NzQzNDlcIjtcbiAgICB0aGlzLnN0cm9rZVdpZHRoID0gMjtcbiAgICB0aGlzLnN0cm9rZU9wYWNpdHkgPSAxO1xuICAgIHRoaXMubGluZURhc2ggPSBbMF07XG4gICAgdGhpcy5saW5lRGFzaE9mZnNldCA9IDA7XG4gICAgdGhpcy5pbnRlcnBvbGF0aW9uID0gbmV3IEludGVycG9sYXRpb25Qcm9wZXJ0aWVzKCk7XG4gICAgdGhpcy5tYXJrZXIgPSBuZXcgU2VyaWVzTWFya2VyKCk7XG4gICAgdGhpcy5sYWJlbCA9IG5ldyBMYWJlbCgpO1xuICAgIHRoaXMudG9vbHRpcCA9IG5ldyBTZXJpZXNUb29sdGlwKCk7XG4gICAgdGhpcy5jb25uZWN0TWlzc2luZ0RhdGEgPSBmYWxzZTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORylcbl0sIExpbmVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ4S2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HKVxuXSwgTGluZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInlLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIExpbmVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ4TmFtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGluZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInlOYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBMaW5lU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwieUZpbHRlcktleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGluZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0YWNrR3JvdXBcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIExpbmVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJub3JtYWxpemVkVG9cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIExpbmVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ0aXRsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORylcbl0sIExpbmVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdHJva2VcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBMaW5lU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic3Ryb2tlV2lkdGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTylcbl0sIExpbmVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdHJva2VPcGFjaXR5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTElORV9EQVNIKVxuXSwgTGluZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImxpbmVEYXNoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgTGluZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImxpbmVEYXNoT2Zmc2V0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgTGluZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImludGVycG9sYXRpb25cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBMaW5lU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibWFya2VyXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgTGluZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImxhYmVsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgTGluZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInRvb2x0aXBcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgTGluZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNvbm5lY3RNaXNzaW5nRGF0YVwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9saW5lU2VyaWVzLnRzXG52YXIgQ1JPU1NfRklMVEVSX0xJTkVfU1RST0tFX09QQUNJVFlfRkFDVE9SID0gMC4yNTtcbnZhciBMaW5lU2VyaWVzID0gY2xhc3MgZXh0ZW5kcyBDYXJ0ZXNpYW5TZXJpZXMge1xuICBjb25zdHJ1Y3Rvcihtb2R1bGVDdHgpIHtcbiAgICBzdXBlcih7XG4gICAgICBtb2R1bGVDdHgsXG4gICAgICBkaXJlY3Rpb25LZXlzOiBERUZBVUxUX0NBUlRFU0lBTl9ESVJFQ1RJT05fS0VZUyxcbiAgICAgIGRpcmVjdGlvbk5hbWVzOiBERUZBVUxUX0NBUlRFU0lBTl9ESVJFQ1RJT05fTkFNRVMsXG4gICAgICBoYXNNYXJrZXJzOiB0cnVlLFxuICAgICAgcGlja01vZGVzOiBbXG4gICAgICAgIDIgLyogQVhJU19BTElHTkVEICovLFxuICAgICAgICAxIC8qIE5FQVJFU1RfTk9ERSAqLyxcbiAgICAgICAgMCAvKiBFWEFDVF9TSEFQRV9NQVRDSCAqL1xuICAgICAgXSxcbiAgICAgIG1hcmtlclNlbGVjdGlvbkdhcmJhZ2VDb2xsZWN0aW9uOiBmYWxzZSxcbiAgICAgIGFuaW1hdGlvblJlc2V0Rm5zOiB7XG4gICAgICAgIHBhdGg6IGJ1aWxkUmVzZXRQYXRoRm4oeyBnZXRWaXNpYmxlOiAoKSA9PiB0aGlzLnZpc2libGUsIGdldE9wYWNpdHk6ICgpID0+IHRoaXMuZ2V0T3BhY2l0eSgpIH0pLFxuICAgICAgICBsYWJlbDogcmVzZXRMYWJlbEZuLFxuICAgICAgICBtYXJrZXI6IChub2RlLCBkYXR1bSkgPT4gKHsgLi4ucmVzZXRNYXJrZXJGbihub2RlKSwgLi4ucmVzZXRNYXJrZXJQb3NpdGlvbkZuKG5vZGUsIGRhdHVtKSB9KVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMucHJvcGVydGllcyA9IG5ldyBMaW5lU2VyaWVzUHJvcGVydGllcygpO1xuICB9XG4gIGdldCBwaWNrTW9kZUF4aXMoKSB7XG4gICAgcmV0dXJuIFwibWFpbi1jYXRlZ29yeVwiO1xuICB9XG4gIGFzeW5jIHByb2Nlc3NEYXRhKGRhdGFDb250cm9sbGVyKSB7XG4gICAgaWYgKHRoaXMuZGF0YSA9PSBudWxsIHx8ICF0aGlzLnByb3BlcnRpZXMuaXNWYWxpZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgZGF0YSwgdmlzaWJsZSwgc2VyaWVzR3JvdXBpbmc6IHsgZ3JvdXBJbmRleCA9IHRoaXMuaWQsIHN0YWNrQ291bnQgPSAxIH0gPSB7fSB9ID0gdGhpcztcbiAgICBjb25zdCB7IHhLZXksIHlLZXksIHlGaWx0ZXJLZXksIGNvbm5lY3RNaXNzaW5nRGF0YSwgbm9ybWFsaXplZFRvIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgYW5pbWF0aW9uRW5hYmxlZCA9ICF0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLmlzU2tpcHBlZCgpO1xuICAgIGNvbnN0IHhTY2FsZSA9IHRoaXMuYXhlc1tcInhcIiAvKiBYICovXT8uc2NhbGU7XG4gICAgY29uc3QgeVNjYWxlID0gdGhpcy5heGVzW1wieVwiIC8qIFkgKi9dPy5zY2FsZTtcbiAgICBjb25zdCB7IGlzQ29udGludW91c1gsIHhTY2FsZVR5cGUsIHlTY2FsZVR5cGUgfSA9IHRoaXMuZ2V0U2NhbGVJbmZvcm1hdGlvbih7IHhTY2FsZSwgeVNjYWxlIH0pO1xuICAgIGNvbnN0IGNvbW1vbiA9IHsgaW52YWxpZFZhbHVlOiBudWxsIH07XG4gICAgaWYgKGNvbm5lY3RNaXNzaW5nRGF0YSAmJiBzdGFja0NvdW50ID4gMSkge1xuICAgICAgY29tbW9uLmludmFsaWRWYWx1ZSA9IDA7XG4gICAgfVxuICAgIGlmICghdmlzaWJsZSkge1xuICAgICAgY29tbW9uLmZvcmNlVmFsdWUgPSAwO1xuICAgIH1cbiAgICBjb25zdCBwcm9wcyA9IFtdO1xuICAgIGlmICghaXNDb250aW51b3VzWCkge1xuICAgICAgcHJvcHMucHVzaChrZXlQcm9wZXJ0eSh4S2V5LCB4U2NhbGVUeXBlLCB7IGlkOiBcInhLZXlcIiB9KSk7XG4gICAgfVxuICAgIHByb3BzLnB1c2goXG4gICAgICB2YWx1ZVByb3BlcnR5KHhLZXksIHhTY2FsZVR5cGUsIHsgaWQ6IFwieFZhbHVlXCIgfSksXG4gICAgICB2YWx1ZVByb3BlcnR5KHlLZXksIHlTY2FsZVR5cGUsIHtcbiAgICAgICAgaWQ6IGB5VmFsdWVSYXdgLFxuICAgICAgICAuLi5jb21tb24sXG4gICAgICAgIGludmFsaWRWYWx1ZTogdm9pZCAwXG4gICAgICB9KVxuICAgICk7XG4gICAgaWYgKHlGaWx0ZXJLZXkgIT0gbnVsbCkge1xuICAgICAgcHJvcHMucHVzaCh2YWx1ZVByb3BlcnR5KHlGaWx0ZXJLZXksIHlTY2FsZVR5cGUsIHsgaWQ6IFwieUZpbHRlclJhd1wiIH0pKTtcbiAgICB9XG4gICAgaWYgKHN0YWNrQ291bnQgPiAxKSB7XG4gICAgICBjb25zdCBpZHMgPSBbXG4gICAgICAgIGBsaW5lLXN0YWNrLSR7Z3JvdXBJbmRleH0teVZhbHVlc2AsXG4gICAgICAgIGBsaW5lLXN0YWNrLSR7Z3JvdXBJbmRleH0teVZhbHVlcy10cmFpbGluZ2AsXG4gICAgICAgIGBsaW5lLXN0YWNrLSR7Z3JvdXBJbmRleH0teVZhbHVlcy1tYXJrZXJgXG4gICAgICBdO1xuICAgICAgcHJvcHMucHVzaChcbiAgICAgICAgLi4uZ3JvdXBBY2N1bXVsYXRpdmVWYWx1ZVByb3BlcnR5KFxuICAgICAgICAgIHlLZXksXG4gICAgICAgICAgXCJ3aW5kb3dcIixcbiAgICAgICAgICBcImN1cnJlbnRcIixcbiAgICAgICAgICB7IGlkOiBgeVZhbHVlRW5kYCwgLi4uY29tbW9uLCBncm91cElkOiBpZHNbMF0gfSxcbiAgICAgICAgICB5U2NhbGVUeXBlXG4gICAgICAgICksXG4gICAgICAgIC4uLmdyb3VwQWNjdW11bGF0aXZlVmFsdWVQcm9wZXJ0eShcbiAgICAgICAgICB5S2V5LFxuICAgICAgICAgIFwid2luZG93LXRyYWlsaW5nXCIsXG4gICAgICAgICAgXCJjdXJyZW50XCIsXG4gICAgICAgICAgeyBpZDogYHlWYWx1ZVN0YXJ0YCwgLi4uY29tbW9uLCBncm91cElkOiBpZHNbMV0gfSxcbiAgICAgICAgICB5U2NhbGVUeXBlXG4gICAgICAgICksXG4gICAgICAgIC4uLmdyb3VwQWNjdW11bGF0aXZlVmFsdWVQcm9wZXJ0eShcbiAgICAgICAgICB5S2V5LFxuICAgICAgICAgIFwibm9ybWFsXCIsXG4gICAgICAgICAgXCJjdXJyZW50XCIsXG4gICAgICAgICAgeyBpZDogYHlWYWx1ZUN1bXVsYXRpdmVgLCAuLi5jb21tb24sIGdyb3VwSWQ6IGlkc1syXSB9LFxuICAgICAgICAgIHlTY2FsZVR5cGVcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIGlmIChpc0RlZmluZWQobm9ybWFsaXplZFRvKSkge1xuICAgICAgICBwcm9wcy5wdXNoKG5vcm1hbGlzZUdyb3VwVG8oW2lkc1swXSwgaWRzWzFdLCBpZHNbMl1dLCBub3JtYWxpemVkVG8sIFwicmFuZ2VcIikpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYW5pbWF0aW9uRW5hYmxlZCkge1xuICAgICAgcHJvcHMucHVzaChhbmltYXRpb25WYWxpZGF0aW9uKGlzQ29udGludW91c1ggPyBbXCJ4VmFsdWVcIl0gOiB2b2lkIDApKTtcbiAgICAgIGlmICh0aGlzLnByb2Nlc3NlZERhdGEpIHtcbiAgICAgICAgcHJvcHMucHVzaChkaWZmKHRoaXMucHJvY2Vzc2VkRGF0YSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBhd2FpdCB0aGlzLnJlcXVlc3REYXRhTW9kZWwoZGF0YUNvbnRyb2xsZXIsIGRhdGEsIHsgcHJvcHMgfSk7XG4gICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwidXBkYXRlRGF0YVwiKTtcbiAgfVxuICBnZXRTZXJpZXNEb21haW4oZGlyZWN0aW9uKSB7XG4gICAgY29uc3QgeyBkYXRhTW9kZWwsIHByb2Nlc3NlZERhdGEgfSA9IHRoaXM7XG4gICAgaWYgKCFkYXRhTW9kZWwgfHwgIXByb2Nlc3NlZERhdGE/LmRhdGEubGVuZ3RoKVxuICAgICAgcmV0dXJuIFtdO1xuICAgIGNvbnN0IHhEZWYgPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFEZWZCeUlkKHRoaXMsIGB4VmFsdWVgKTtcbiAgICBpZiAoZGlyZWN0aW9uID09PSBcInhcIiAvKiBYICovKSB7XG4gICAgICBjb25zdCBkb21haW4gPSBkYXRhTW9kZWwuZ2V0RG9tYWluKHRoaXMsIGB4VmFsdWVgLCBcInZhbHVlXCIsIHByb2Nlc3NlZERhdGEpO1xuICAgICAgaWYgKHhEZWY/LmRlZi50eXBlID09PSBcInZhbHVlXCIgJiYgeERlZi5kZWYudmFsdWVUeXBlID09PSBcImNhdGVnb3J5XCIpIHtcbiAgICAgICAgcmV0dXJuIGRvbWFpbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmaXhOdW1lcmljRXh0ZW50KGV4dGVudChkb21haW4pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc3RhY2tDb3VudCA9IHRoaXMuc2VyaWVzR3JvdXBpbmc/LnN0YWNrQ291bnQgPz8gMTtcbiAgICAgIGNvbnN0IGRvbWFpbiA9IHN0YWNrQ291bnQgPiAxID8gZGF0YU1vZGVsLmdldERvbWFpbih0aGlzLCBgeVZhbHVlRW5kYCwgXCJ2YWx1ZVwiLCBwcm9jZXNzZWREYXRhKSA6IGRhdGFNb2RlbC5nZXREb21haW4odGhpcywgYHlWYWx1ZVJhd2AsIFwidmFsdWVcIiwgcHJvY2Vzc2VkRGF0YSk7XG4gICAgICByZXR1cm4gZml4TnVtZXJpY0V4dGVudChkb21haW4pO1xuICAgIH1cbiAgfVxuICBhc3luYyBjcmVhdGVOb2RlRGF0YSgpIHtcbiAgICBjb25zdCB7IHByb2Nlc3NlZERhdGEsIGRhdGFNb2RlbCwgYXhlcyB9ID0gdGhpcztcbiAgICBjb25zdCB4QXhpcyA9IGF4ZXNbXCJ4XCIgLyogWCAqL107XG4gICAgY29uc3QgeUF4aXMgPSBheGVzW1wieVwiIC8qIFkgKi9dO1xuICAgIGlmICghcHJvY2Vzc2VkRGF0YSB8fCAhZGF0YU1vZGVsIHx8ICF4QXhpcyB8fCAheUF4aXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyB4S2V5LCB5S2V5LCB5RmlsdGVyS2V5LCB4TmFtZSwgeU5hbWUsIG1hcmtlciwgbGFiZWwsIGNvbm5lY3RNaXNzaW5nRGF0YSwgbGVnZW5kSXRlbU5hbWUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCBzdGFja2VkID0gKHRoaXMuc2VyaWVzR3JvdXBpbmc/LnN0YWNrQ291bnQgPz8gMSkgPiAxO1xuICAgIGNvbnN0IHhTY2FsZSA9IHhBeGlzLnNjYWxlO1xuICAgIGNvbnN0IHlTY2FsZSA9IHlBeGlzLnNjYWxlO1xuICAgIGNvbnN0IHhPZmZzZXQgPSAoeFNjYWxlLmJhbmR3aWR0aCA/PyAwKSAvIDI7XG4gICAgY29uc3QgeU9mZnNldCA9ICh5U2NhbGUuYmFuZHdpZHRoID8/IDApIC8gMjtcbiAgICBjb25zdCBub2RlRGF0YSA9IFtdO1xuICAgIGNvbnN0IHNpemUgPSBtYXJrZXIuZW5hYmxlZCA/IG1hcmtlci5zaXplIDogMDtcbiAgICBjb25zdCB4SWR4ID0gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGB4VmFsdWVgKTtcbiAgICBjb25zdCB5SWR4ID0gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGB5VmFsdWVSYXdgKTtcbiAgICBjb25zdCB5U2VsZWN0aW9uSWR4ID0geUZpbHRlcktleSAhPSBudWxsID8gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGB5RmlsdGVyUmF3YCkgOiB2b2lkIDA7XG4gICAgY29uc3QgeUN1bXVsYXRpdmVJZHggPSBzdGFja2VkID8gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGB5VmFsdWVDdW11bGF0aXZlYCkgOiB5SWR4O1xuICAgIGNvbnN0IHlFbmRJZHggPSBzdGFja2VkID8gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGB5VmFsdWVFbmRgKSA6IHZvaWQgMDtcbiAgICBsZXQgbW92ZVRvID0gdHJ1ZTtcbiAgICBsZXQgY3Jvc3NGaWx0ZXJpbmcgPSBmYWxzZTtcbiAgICBwcm9jZXNzZWREYXRhLmRhdGE/LmZvckVhY2goKHsgZGF0dW0sIHZhbHVlcyB9KSA9PiB7XG4gICAgICBjb25zdCB4RGF0dW0gPSB2YWx1ZXNbeElkeF07XG4gICAgICBjb25zdCB5RGF0dW0gPSB2YWx1ZXNbeUlkeF07XG4gICAgICBjb25zdCB5Q3VtdWxhdGl2ZURhdHVtID0gdmFsdWVzW3lDdW11bGF0aXZlSWR4XTtcbiAgICAgIGNvbnN0IHlFbmREYXR1bSA9IHlFbmRJZHggIT0gbnVsbCA/IHZhbHVlc1t5RW5kSWR4XSA6IHZvaWQgMDtcbiAgICAgIGlmICh5RGF0dW0gPT0gbnVsbCkge1xuICAgICAgICBtb3ZlVG8gfHwgKG1vdmVUbyA9ICFjb25uZWN0TWlzc2luZ0RhdGEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB4ID0geFNjYWxlLmNvbnZlcnQoeERhdHVtKSArIHhPZmZzZXQ7XG4gICAgICBpZiAoaXNOYU4oeCkpIHtcbiAgICAgICAgbW92ZVRvIHx8IChtb3ZlVG8gPSAhY29ubmVjdE1pc3NpbmdEYXRhKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgeSA9IHlTY2FsZS5jb252ZXJ0KHlDdW11bGF0aXZlRGF0dW0pICsgeU9mZnNldDtcbiAgICAgIGNvbnN0IHNlbGVjdGVkID0geVNlbGVjdGlvbklkeCAhPSBudWxsID8gdmFsdWVzW3lTZWxlY3Rpb25JZHhdID09PSB5RGF0dW0gOiB2b2lkIDA7XG4gICAgICBpZiAoc2VsZWN0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIGNyb3NzRmlsdGVyaW5nID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxhYmVsVGV4dCA9IHRoaXMuZ2V0TGFiZWxUZXh0KFxuICAgICAgICBsYWJlbCxcbiAgICAgICAgeyB2YWx1ZTogeURhdHVtLCBkYXR1bSwgeEtleSwgeUtleSwgeE5hbWUsIHlOYW1lLCBsZWdlbmRJdGVtTmFtZSB9LFxuICAgICAgICBmb3JtYXRWYWx1ZVxuICAgICAgKTtcbiAgICAgIG5vZGVEYXRhLnB1c2goe1xuICAgICAgICBzZXJpZXM6IHRoaXMsXG4gICAgICAgIGRhdHVtLFxuICAgICAgICB5S2V5LFxuICAgICAgICB4S2V5LFxuICAgICAgICBwb2ludDogeyB4LCB5LCBtb3ZlVG8sIHNpemUgfSxcbiAgICAgICAgbWlkUG9pbnQ6IHsgeCwgeSB9LFxuICAgICAgICBjdW11bGF0aXZlVmFsdWU6IHlFbmREYXR1bSxcbiAgICAgICAgeVZhbHVlOiB5RGF0dW0sXG4gICAgICAgIHhWYWx1ZTogeERhdHVtLFxuICAgICAgICBjYXBEZWZhdWx0czoge1xuICAgICAgICAgIGxlbmd0aFJhdGlvTXVsdGlwbGllcjogdGhpcy5wcm9wZXJ0aWVzLm1hcmtlci5nZXREaWFtZXRlcigpLFxuICAgICAgICAgIGxlbmd0aE1heDogSW5maW5pdHlcbiAgICAgICAgfSxcbiAgICAgICAgbGFiZWxUZXh0LFxuICAgICAgICBzZWxlY3RlZFxuICAgICAgfSk7XG4gICAgICBtb3ZlVG8gPSBmYWxzZTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgaXRlbUlkOiB5S2V5LFxuICAgICAgbm9kZURhdGEsXG4gICAgICBsYWJlbERhdGE6IG5vZGVEYXRhLFxuICAgICAgc2NhbGVzOiB0aGlzLmNhbGN1bGF0ZVNjYWxpbmcoKSxcbiAgICAgIHZpc2libGU6IHRoaXMudmlzaWJsZSxcbiAgICAgIGNyb3NzRmlsdGVyaW5nXG4gICAgfTtcbiAgfVxuICBpc1BhdGhPclNlbGVjdGlvbkRpcnR5KCkge1xuICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXMubWFya2VyLmlzRGlydHkoKTtcbiAgfVxuICBtYXJrZXJGYWN0b3J5KCkge1xuICAgIGNvbnN0IHsgc2hhcGUgfSA9IHRoaXMucHJvcGVydGllcy5tYXJrZXI7XG4gICAgY29uc3QgTWFya2VyU2hhcGUgPSBnZXRNYXJrZXIoc2hhcGUpO1xuICAgIHJldHVybiBuZXcgTWFya2VyU2hhcGUoKTtcbiAgfVxuICBhc3luYyB1cGRhdGVQYXRoTm9kZXMob3B0cykge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhdGhzOiBbbGluZU5vZGVdLFxuICAgICAgb3BhY2l0eSxcbiAgICAgIHZpc2libGUsXG4gICAgICBhbmltYXRpb25FbmFibGVkXG4gICAgfSA9IG9wdHM7XG4gICAgY29uc3QgY3Jvc3NGaWx0ZXJpbmcgPSB0aGlzLmNvbnRleHROb2RlRGF0YT8uY3Jvc3NGaWx0ZXJpbmcgPT09IHRydWU7XG4gICAgbGluZU5vZGUuc2V0UHJvcGVydGllcyh7XG4gICAgICBmaWxsOiB2b2lkIDAsXG4gICAgICBsaW5lSm9pbjogXCJyb3VuZFwiLFxuICAgICAgcG9pbnRlckV2ZW50czogMSAvKiBOb25lICovLFxuICAgICAgb3BhY2l0eSxcbiAgICAgIHN0cm9rZTogdGhpcy5wcm9wZXJ0aWVzLnN0cm9rZSxcbiAgICAgIHN0cm9rZVdpZHRoOiB0aGlzLmdldFN0cm9rZVdpZHRoKHRoaXMucHJvcGVydGllcy5zdHJva2VXaWR0aCksXG4gICAgICBzdHJva2VPcGFjaXR5OiB0aGlzLnByb3BlcnRpZXMuc3Ryb2tlT3BhY2l0eSAqIChjcm9zc0ZpbHRlcmluZyA/IENST1NTX0ZJTFRFUl9MSU5FX1NUUk9LRV9PUEFDSVRZX0ZBQ1RPUiA6IDEpLFxuICAgICAgbGluZURhc2g6IHRoaXMucHJvcGVydGllcy5saW5lRGFzaCxcbiAgICAgIGxpbmVEYXNoT2Zmc2V0OiB0aGlzLnByb3BlcnRpZXMubGluZURhc2hPZmZzZXRcbiAgICB9KTtcbiAgICBpZiAoIWFuaW1hdGlvbkVuYWJsZWQpIHtcbiAgICAgIGxpbmVOb2RlLnZpc2libGUgPSB2aXNpYmxlO1xuICAgIH1cbiAgICB1cGRhdGVDbGlwUGF0aCh0aGlzLCBsaW5lTm9kZSk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlTWFya2VyU2VsZWN0aW9uKG9wdHMpIHtcbiAgICBsZXQgeyBub2RlRGF0YSB9ID0gb3B0cztcbiAgICBjb25zdCB7IG1hcmtlclNlbGVjdGlvbiB9ID0gb3B0cztcbiAgICBjb25zdCBtYXJrZXJzRW5hYmxlZCA9IHRoaXMucHJvcGVydGllcy5tYXJrZXIuZW5hYmxlZCB8fCB0aGlzLmNvbnRleHROb2RlRGF0YT8uY3Jvc3NGaWx0ZXJpbmcgPT09IHRydWU7XG4gICAgbm9kZURhdGEgPSBtYXJrZXJzRW5hYmxlZCA/IG5vZGVEYXRhIDogW107XG4gICAgaWYgKHRoaXMucHJvcGVydGllcy5tYXJrZXIuaXNEaXJ0eSgpKSB7XG4gICAgICBtYXJrZXJTZWxlY3Rpb24uY2xlYXIoKTtcbiAgICAgIG1hcmtlclNlbGVjdGlvbi5jbGVhbnVwKCk7XG4gICAgfVxuICAgIHJldHVybiBtYXJrZXJTZWxlY3Rpb24udXBkYXRlKG5vZGVEYXRhLCB2b2lkIDAsIChkYXR1bSkgPT4gY3JlYXRlRGF0dW1JZChkYXR1bS54VmFsdWUpKTtcbiAgfVxuICBhc3luYyB1cGRhdGVNYXJrZXJOb2RlcyhvcHRzKSB7XG4gICAgY29uc3QgeyBtYXJrZXJTZWxlY3Rpb24sIGlzSGlnaGxpZ2h0OiBoaWdobGlnaHRlZCB9ID0gb3B0cztcbiAgICBjb25zdCB7IHhLZXksIHlLZXksIHN0cm9rZSwgc3Ryb2tlV2lkdGgsIHN0cm9rZU9wYWNpdHksIG1hcmtlciwgaGlnaGxpZ2h0U3R5bGUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCBiYXNlU3R5bGUgPSBtZXJnZURlZmF1bHRzKGhpZ2hsaWdodGVkICYmIGhpZ2hsaWdodFN0eWxlLml0ZW0sIG1hcmtlci5nZXRTdHlsZSgpLCB7XG4gICAgICBzdHJva2UsXG4gICAgICBzdHJva2VXaWR0aCxcbiAgICAgIHN0cm9rZU9wYWNpdHlcbiAgICB9KTtcbiAgICBjb25zdCBhcHBseVRyYW5zbGF0aW9uID0gdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5pc1NraXBwZWQoKTtcbiAgICBtYXJrZXJTZWxlY3Rpb24uZWFjaCgobm9kZSwgZGF0dW0pID0+IHtcbiAgICAgIHRoaXMudXBkYXRlTWFya2VyU3R5bGUobm9kZSwgbWFya2VyLCB7IGRhdHVtLCBoaWdobGlnaHRlZCwgeEtleSwgeUtleSB9LCBiYXNlU3R5bGUsIHtcbiAgICAgICAgYXBwbHlUcmFuc2xhdGlvbixcbiAgICAgICAgc2VsZWN0ZWQ6IGRhdHVtLnNlbGVjdGVkXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAoIWhpZ2hsaWdodGVkKSB7XG4gICAgICBtYXJrZXIubWFya0NsZWFuKCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIHVwZGF0ZUxhYmVsU2VsZWN0aW9uKG9wdHMpIHtcbiAgICByZXR1cm4gb3B0cy5sYWJlbFNlbGVjdGlvbi51cGRhdGUodGhpcy5pc0xhYmVsRW5hYmxlZCgpID8gb3B0cy5sYWJlbERhdGEgOiBbXSk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlTGFiZWxOb2RlcyhvcHRzKSB7XG4gICAgY29uc3QgeyBlbmFibGVkLCBmb250U3R5bGUsIGZvbnRXZWlnaHQsIGZvbnRTaXplLCBmb250RmFtaWx5LCBjb2xvciB9ID0gdGhpcy5wcm9wZXJ0aWVzLmxhYmVsO1xuICAgIG9wdHMubGFiZWxTZWxlY3Rpb24uZWFjaCgodGV4dCwgZGF0dW0pID0+IHtcbiAgICAgIGlmIChlbmFibGVkICYmIGRhdHVtPy5sYWJlbFRleHQpIHtcbiAgICAgICAgdGV4dC5mb250U3R5bGUgPSBmb250U3R5bGU7XG4gICAgICAgIHRleHQuZm9udFdlaWdodCA9IGZvbnRXZWlnaHQ7XG4gICAgICAgIHRleHQuZm9udFNpemUgPSBmb250U2l6ZTtcbiAgICAgICAgdGV4dC5mb250RmFtaWx5ID0gZm9udEZhbWlseTtcbiAgICAgICAgdGV4dC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgICB0ZXh0LnRleHRCYXNlbGluZSA9IFwiYm90dG9tXCI7XG4gICAgICAgIHRleHQudGV4dCA9IGRhdHVtLmxhYmVsVGV4dDtcbiAgICAgICAgdGV4dC54ID0gZGF0dW0ucG9pbnQueDtcbiAgICAgICAgdGV4dC55ID0gZGF0dW0ucG9pbnQueSAtIDEwO1xuICAgICAgICB0ZXh0LmZpbGwgPSBjb2xvcjtcbiAgICAgICAgdGV4dC52aXNpYmxlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHQudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGdldFRvb2x0aXBIdG1sKG5vZGVEYXR1bSkge1xuICAgIGNvbnN0IHhBeGlzID0gdGhpcy5heGVzW1wieFwiIC8qIFggKi9dO1xuICAgIGNvbnN0IHlBeGlzID0gdGhpcy5heGVzW1wieVwiIC8qIFkgKi9dO1xuICAgIGlmICghdGhpcy5wcm9wZXJ0aWVzLmlzVmFsaWQoKSB8fCAheEF4aXMgfHwgIXlBeGlzKSB7XG4gICAgICByZXR1cm4gRU1QVFlfVE9PTFRJUF9DT05URU5UO1xuICAgIH1cbiAgICBjb25zdCB7IHhLZXksIHlLZXksIHhOYW1lLCB5TmFtZSwgc3Ryb2tlV2lkdGgsIG1hcmtlciwgdG9vbHRpcCB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHsgZGF0dW0sIHhWYWx1ZSwgeVZhbHVlLCBpdGVtSWQgfSA9IG5vZGVEYXR1bTtcbiAgICBjb25zdCB4U3RyaW5nID0geEF4aXMuZm9ybWF0RGF0dW0oeFZhbHVlKTtcbiAgICBjb25zdCB5U3RyaW5nID0geUF4aXMuZm9ybWF0RGF0dW0oeVZhbHVlKTtcbiAgICBjb25zdCB0aXRsZSA9IHNhbml0aXplSHRtbCh0aGlzLnByb3BlcnRpZXMudGl0bGUgPz8geU5hbWUpO1xuICAgIGNvbnN0IGNvbnRlbnQgPSBzYW5pdGl6ZUh0bWwoeFN0cmluZyArIFwiOiBcIiArIHlTdHJpbmcpO1xuICAgIGNvbnN0IGJhc2VTdHlsZSA9IG1lcmdlRGVmYXVsdHMoeyBmaWxsOiBtYXJrZXIuc3Ryb2tlIH0sIG1hcmtlci5nZXRTdHlsZSgpLCB7IHN0cm9rZVdpZHRoIH0pO1xuICAgIGNvbnN0IHsgZmlsbDogY29sb3IgfSA9IHRoaXMuZ2V0TWFya2VyU3R5bGUoXG4gICAgICBtYXJrZXIsXG4gICAgICB7IGRhdHVtOiBub2RlRGF0dW0sIHhLZXksIHlLZXksIGhpZ2hsaWdodGVkOiBmYWxzZSB9LFxuICAgICAgYmFzZVN0eWxlXG4gICAgKTtcbiAgICByZXR1cm4gdG9vbHRpcC50b1Rvb2x0aXBIdG1sKFxuICAgICAgeyB0aXRsZSwgY29udGVudCwgYmFja2dyb3VuZENvbG9yOiBjb2xvciB9LFxuICAgICAge1xuICAgICAgICBkYXR1bSxcbiAgICAgICAgaXRlbUlkLFxuICAgICAgICB4S2V5LFxuICAgICAgICB4TmFtZSxcbiAgICAgICAgeUtleSxcbiAgICAgICAgeU5hbWUsXG4gICAgICAgIHRpdGxlLFxuICAgICAgICBjb2xvcixcbiAgICAgICAgc2VyaWVzSWQ6IHRoaXMuaWQsXG4gICAgICAgIC4uLnRoaXMuZ2V0TW9kdWxlVG9vbHRpcFBhcmFtcygpXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBnZXRMZWdlbmREYXRhKGxlZ2VuZFR5cGUpIHtcbiAgICBpZiAoISh0aGlzLmRhdGE/Lmxlbmd0aCAmJiB0aGlzLnByb3BlcnRpZXMuaXNWYWxpZCgpICYmIGxlZ2VuZFR5cGUgPT09IFwiY2F0ZWdvcnlcIikpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgeyB5S2V5LCB5TmFtZSwgc3Ryb2tlLCBzdHJva2VPcGFjaXR5LCBzdHJva2VXaWR0aCwgbGluZURhc2gsIHRpdGxlLCBtYXJrZXIsIHZpc2libGUsIGxlZ2VuZEl0ZW1OYW1lIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgY29sb3IwID0gXCJyZ2JhKDAsIDAsIDAsIDApXCI7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgbGVnZW5kVHlwZTogXCJjYXRlZ29yeVwiLFxuICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgaXRlbUlkOiB5S2V5LFxuICAgICAgICBsZWdlbmRJdGVtTmFtZSxcbiAgICAgICAgc2VyaWVzSWQ6IHRoaXMuaWQsXG4gICAgICAgIGVuYWJsZWQ6IHZpc2libGUsXG4gICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgdGV4dDogbGVnZW5kSXRlbU5hbWUgPz8gdGl0bGUgPz8geU5hbWUgPz8geUtleVxuICAgICAgICB9LFxuICAgICAgICBzeW1ib2xzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgbWFya2VyOiB7XG4gICAgICAgICAgICAgIHNoYXBlOiBtYXJrZXIuc2hhcGUsXG4gICAgICAgICAgICAgIGZpbGw6IG1hcmtlci5maWxsID8/IGNvbG9yMCxcbiAgICAgICAgICAgICAgc3Ryb2tlOiBtYXJrZXIuc3Ryb2tlID8/IHN0cm9rZSA/PyBjb2xvcjAsXG4gICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiBtYXJrZXIuZmlsbE9wYWNpdHkgPz8gMSxcbiAgICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogbWFya2VyLnN0cm9rZU9wYWNpdHkgPz8gc3Ryb2tlT3BhY2l0eSA/PyAxLFxuICAgICAgICAgICAgICBzdHJva2VXaWR0aDogbWFya2VyLnN0cm9rZVdpZHRoID8/IDAsXG4gICAgICAgICAgICAgIGVuYWJsZWQ6IG1hcmtlci5lbmFibGVkXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGluZToge1xuICAgICAgICAgICAgICBzdHJva2U6IHN0cm9rZSA/PyBjb2xvcjAsXG4gICAgICAgICAgICAgIHN0cm9rZU9wYWNpdHksXG4gICAgICAgICAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgICAgICAgICBsaW5lRGFzaFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfVxuICAgIF07XG4gIH1cbiAgYXN5bmMgdXBkYXRlUGF0aHMob3B0cykge1xuICAgIHRoaXMudXBkYXRlTGluZVBhdGhzKG9wdHMucGF0aHMsIG9wdHMuY29udGV4dERhdGEpO1xuICB9XG4gIHVwZGF0ZUxpbmVQYXRocyhwYXRocywgY29udGV4dERhdGEpIHtcbiAgICBjb25zdCB7IGludGVycG9sYXRpb24gfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCB7IG5vZGVEYXRhIH0gPSBjb250ZXh0RGF0YTtcbiAgICBjb25zdCBbbGluZU5vZGVdID0gcGF0aHM7XG4gICAgbGluZU5vZGUucGF0aC5jbGVhcih0cnVlKTtcbiAgICBmb3IgKGNvbnN0IHJhbmdlMyBvZiBwYXRoUmFuZ2VzKG5vZGVEYXRhKSkge1xuICAgICAgcGxvdFBhdGgocGF0aFJhbmdlUG9pbnRzKG5vZGVEYXRhLCByYW5nZTMpLCBsaW5lTm9kZSwgaW50ZXJwb2xhdGlvbik7XG4gICAgfVxuICAgIGxpbmVOb2RlLmNoZWNrUGF0aERpcnR5KCk7XG4gIH1cbiAgYW5pbWF0ZUVtcHR5VXBkYXRlUmVhZHkoYW5pbWF0aW9uRGF0YSkge1xuICAgIGNvbnN0IHsgbWFya2VyU2VsZWN0aW9uLCBsYWJlbFNlbGVjdGlvbiwgYW5ub3RhdGlvblNlbGVjdGlvbnMsIGNvbnRleHREYXRhLCBwYXRocyB9ID0gYW5pbWF0aW9uRGF0YTtcbiAgICBjb25zdCB7IGFuaW1hdGlvbk1hbmFnZXIgfSA9IHRoaXMuY3R4O1xuICAgIHRoaXMudXBkYXRlTGluZVBhdGhzKHBhdGhzLCBjb250ZXh0RGF0YSk7XG4gICAgcGF0aFN3aXBlSW5BbmltYXRpb24odGhpcywgYW5pbWF0aW9uTWFuYWdlciwgLi4ucGF0aHMpO1xuICAgIHJlc2V0TW90aW9uKFttYXJrZXJTZWxlY3Rpb25dLCByZXNldE1hcmtlclBvc2l0aW9uRm4pO1xuICAgIG1hcmtlclN3aXBlU2NhbGVJbkFuaW1hdGlvbih0aGlzLCBhbmltYXRpb25NYW5hZ2VyLCBtYXJrZXJTZWxlY3Rpb24pO1xuICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwibGFiZWxzXCIsIGFuaW1hdGlvbk1hbmFnZXIsIGxhYmVsU2VsZWN0aW9uKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImFubm90YXRpb25zXCIsIGFuaW1hdGlvbk1hbmFnZXIsIC4uLmFubm90YXRpb25TZWxlY3Rpb25zKTtcbiAgfVxuICBhbmltYXRlUmVhZHlSZXNpemUoYW5pbWF0aW9uRGF0YSkge1xuICAgIGNvbnN0IHsgY29udGV4dERhdGEsIHBhdGhzIH0gPSBhbmltYXRpb25EYXRhO1xuICAgIHRoaXMudXBkYXRlTGluZVBhdGhzKHBhdGhzLCBjb250ZXh0RGF0YSk7XG4gICAgc3VwZXIuYW5pbWF0ZVJlYWR5UmVzaXplKGFuaW1hdGlvbkRhdGEpO1xuICB9XG4gIGFuaW1hdGVXYWl0aW5nVXBkYXRlUmVhZHkoYW5pbWF0aW9uRGF0YSkge1xuICAgIGNvbnN0IHsgYW5pbWF0aW9uTWFuYWdlciB9ID0gdGhpcy5jdHg7XG4gICAgY29uc3Qge1xuICAgICAgbWFya2VyU2VsZWN0aW9uOiBtYXJrZXJTZWxlY3Rpb25zLFxuICAgICAgbGFiZWxTZWxlY3Rpb246IGxhYmVsU2VsZWN0aW9ucyxcbiAgICAgIGFubm90YXRpb25TZWxlY3Rpb25zLFxuICAgICAgY29udGV4dERhdGEsXG4gICAgICBwYXRocyxcbiAgICAgIHByZXZpb3VzQ29udGV4dERhdGFcbiAgICB9ID0gYW5pbWF0aW9uRGF0YTtcbiAgICBjb25zdCBbcGF0aF0gPSBwYXRocztcbiAgICB0aGlzLnJlc2V0TWFya2VyQW5pbWF0aW9uKGFuaW1hdGlvbkRhdGEpO1xuICAgIHRoaXMucmVzZXRMYWJlbEFuaW1hdGlvbihhbmltYXRpb25EYXRhKTtcbiAgICBjb25zdCB1cGRhdGUgPSAoKSA9PiB7XG4gICAgICB0aGlzLnJlc2V0UGF0aEFuaW1hdGlvbihhbmltYXRpb25EYXRhKTtcbiAgICAgIHRoaXMudXBkYXRlTGluZVBhdGhzKHBhdGhzLCBjb250ZXh0RGF0YSk7XG4gICAgfTtcbiAgICBjb25zdCBza2lwID0gKCkgPT4ge1xuICAgICAgYW5pbWF0aW9uTWFuYWdlci5za2lwQ3VycmVudEJhdGNoKCk7XG4gICAgICB1cGRhdGUoKTtcbiAgICB9O1xuICAgIGlmIChjb250ZXh0RGF0YSA9PSBudWxsIHx8IHByZXZpb3VzQ29udGV4dERhdGEgPT0gbnVsbCkge1xuICAgICAgdXBkYXRlKCk7XG4gICAgICBtYXJrZXJGYWRlSW5BbmltYXRpb24odGhpcywgYW5pbWF0aW9uTWFuYWdlciwgXCJhZGRlZFwiLCBtYXJrZXJTZWxlY3Rpb25zKTtcbiAgICAgIHBhdGhGYWRlSW5BbmltYXRpb24odGhpcywgXCJwYXRoX3Byb3BlcnRpZXNcIiwgYW5pbWF0aW9uTWFuYWdlciwgXCJhZGRcIiwgcGF0aCk7XG4gICAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImxhYmVsc1wiLCBhbmltYXRpb25NYW5hZ2VyLCBsYWJlbFNlbGVjdGlvbnMpO1xuICAgICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJhbm5vdGF0aW9uc1wiLCBhbmltYXRpb25NYW5hZ2VyLCAuLi5hbm5vdGF0aW9uU2VsZWN0aW9ucyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjb250ZXh0RGF0YS5jcm9zc0ZpbHRlcmluZyAhPT0gcHJldmlvdXNDb250ZXh0RGF0YS5jcm9zc0ZpbHRlcmluZykge1xuICAgICAgc2tpcCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgZm5zO1xuICAgIHRyeSB7XG4gICAgICBmbnMgPSBwcmVwYXJlTGluZVBhdGhBbmltYXRpb24oXG4gICAgICAgIGNvbnRleHREYXRhLFxuICAgICAgICBwcmV2aW91c0NvbnRleHREYXRhLFxuICAgICAgICB0aGlzLnByb2Nlc3NlZERhdGE/LnJlZHVjZWQ/LmRpZmYsXG4gICAgICAgIHRoaXMucHJvcGVydGllcy5pbnRlcnBvbGF0aW9uXG4gICAgICApO1xuICAgIH0gY2F0Y2gge1xuICAgICAgZm5zID0gdm9pZCAwO1xuICAgIH1cbiAgICBpZiAoZm5zID09PSB2b2lkIDApIHtcbiAgICAgIHNraXAoKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKGZucy5zdGF0dXMgPT09IFwibm8tb3BcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBtYXJrZXJGYWRlSW5BbmltYXRpb24odGhpcywgYW5pbWF0aW9uTWFuYWdlciwgdm9pZCAwLCBtYXJrZXJTZWxlY3Rpb25zKTtcbiAgICBmcm9tVG9Nb3Rpb24odGhpcy5pZCwgXCJwYXRoX3Byb3BlcnRpZXNcIiwgYW5pbWF0aW9uTWFuYWdlciwgW3BhdGhdLCBmbnMucGF0aFByb3BlcnRpZXMpO1xuICAgIGlmIChmbnMuc3RhdHVzID09PSBcImFkZGVkXCIpIHtcbiAgICAgIHRoaXMudXBkYXRlTGluZVBhdGhzKHBhdGhzLCBjb250ZXh0RGF0YSk7XG4gICAgfSBlbHNlIGlmIChmbnMuc3RhdHVzID09PSBcInJlbW92ZWRcIikge1xuICAgICAgdGhpcy51cGRhdGVMaW5lUGF0aHMocGF0aHMsIHByZXZpb3VzQ29udGV4dERhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRoTW90aW9uKHRoaXMuaWQsIFwicGF0aF91cGRhdGVcIiwgYW5pbWF0aW9uTWFuYWdlciwgW3BhdGhdLCBmbnMucGF0aCk7XG4gICAgfVxuICAgIGlmIChmbnMuaGFzTW90aW9uKSB7XG4gICAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImxhYmVsc1wiLCBhbmltYXRpb25NYW5hZ2VyLCBsYWJlbFNlbGVjdGlvbnMpO1xuICAgICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJhbm5vdGF0aW9uc1wiLCBhbmltYXRpb25NYW5hZ2VyLCAuLi5hbm5vdGF0aW9uU2VsZWN0aW9ucyk7XG4gICAgfVxuICB9XG4gIGlzTGFiZWxFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXMubGFiZWwuZW5hYmxlZDtcbiAgfVxuICBnZXRCYW5kU2NhbGVQYWRkaW5nKCkge1xuICAgIHJldHVybiB7IGlubmVyOiAxLCBvdXRlcjogMC4xIH07XG4gIH1cbiAgbm9kZUZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIG5ldyBHcm91cCgpO1xuICB9XG4gIGdldEZvcm1hdHRlZE1hcmtlclN0eWxlKGRhdHVtKSB7XG4gICAgY29uc3QgeyB4S2V5LCB5S2V5IH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TWFya2VyU3R5bGUodGhpcy5wcm9wZXJ0aWVzLm1hcmtlciwgeyBkYXR1bSwgeEtleSwgeUtleSwgaGlnaGxpZ2h0ZWQ6IHRydWUgfSk7XG4gIH1cbiAgY29tcHV0ZUZvY3VzQm91bmRzKG9wdHMpIHtcbiAgICByZXR1cm4gY29tcHV0ZU1hcmtlckZvY3VzQm91bmRzKHRoaXMsIG9wdHMpO1xuICB9XG59O1xuTGluZVNlcmllcy5jbGFzc05hbWUgPSBcIkxpbmVTZXJpZXNcIjtcbkxpbmVTZXJpZXMudHlwZSA9IFwibGluZVwiO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2xpbmVTZXJpZXNNb2R1bGUudHNcbnZhciBMaW5lU2VyaWVzTW9kdWxlID0ge1xuICB0eXBlOiBcInNlcmllc1wiLFxuICBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsXG4gIHBhY2thZ2VUeXBlOiBcImNvbW11bml0eVwiLFxuICBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIl0sXG4gIGlkZW50aWZpZXI6IFwibGluZVwiLFxuICBtb2R1bGVGYWN0b3J5OiAoY3R4KSA9PiBuZXcgTGluZVNlcmllcyhjdHgpLFxuICBzdGFja2FibGU6IHRydWUsXG4gIHRvb2x0aXBEZWZhdWx0czogeyByYW5nZTogXCJuZWFyZXN0XCIgfSxcbiAgZGVmYXVsdEF4ZXM6IFtcbiAgICB7XG4gICAgICB0eXBlOiBcIm51bWJlclwiIC8qIE5VTUJFUiAqLyxcbiAgICAgIHBvc2l0aW9uOiBcImxlZnRcIiAvKiBMRUZUICovXG4gICAgfSxcbiAgICB7XG4gICAgICB0eXBlOiBcImNhdGVnb3J5XCIgLyogQ0FURUdPUlkgKi8sXG4gICAgICBwb3NpdGlvbjogXCJib3R0b21cIiAvKiBCT1RUT00gKi9cbiAgICB9XG4gIF0sXG4gIHRoZW1lVGVtcGxhdGU6IHtcbiAgICBzZXJpZXM6IHtcbiAgICAgIHRvb2x0aXA6IHsgcG9zaXRpb246IHsgdHlwZTogXCJub2RlXCIgfSB9LFxuICAgICAgc3Ryb2tlV2lkdGg6IDIsXG4gICAgICBzdHJva2VPcGFjaXR5OiAxLFxuICAgICAgbGluZURhc2g6IFswXSxcbiAgICAgIGxpbmVEYXNoT2Zmc2V0OiAwLFxuICAgICAgaW50ZXJwb2xhdGlvbjoge1xuICAgICAgICB0eXBlOiBcImxpbmVhclwiLFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gdXNlcnMgc2hvdWxkbid0IHNwZWNpZnkgYWxsIG9wdGlvbnMsIGJ1dCB3ZSBoYXZlIHRvIGZvciB0aGVtaW5nIHRvIHdvcmtcbiAgICAgICAgdGVuc2lvbjogMSxcbiAgICAgICAgcG9zaXRpb246IFwiZW5kXCJcbiAgICAgIH0sXG4gICAgICBtYXJrZXI6IHtcbiAgICAgICAgc2hhcGU6IFwiY2lyY2xlXCIsXG4gICAgICAgIHNpemU6IDcsXG4gICAgICAgIHN0cm9rZVdpZHRoOiAwXG4gICAgICB9LFxuICAgICAgbGFiZWw6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgICAgZm9udEZhbWlseTogREVGQVVMVF9GT05UX0ZBTUlMWSxcbiAgICAgICAgY29sb3I6IERFRkFVTFRfTEFCRUxfQ09MT1VSXG4gICAgICB9LFxuICAgICAgZXJyb3JCYXI6IHtcbiAgICAgICAgY2FwOiB7XG4gICAgICAgICAgbGVuZ3RoUmF0aW86IDFcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcGFsZXR0ZUZhY3Rvcnk6IChwYXJhbXMpID0+IHtcbiAgICBjb25zdCB7IG1hcmtlciB9ID0gbWFya2VyUGFsZXR0ZUZhY3RvcnkocGFyYW1zKTtcbiAgICByZXR1cm4geyBzdHJva2U6IG1hcmtlci5maWxsLCBtYXJrZXIgfTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9zY2F0dGVyU2VyaWVzUHJvcGVydGllcy50c1xudmFyIFNjYXR0ZXJTZXJpZXNMYWJlbCA9IGNsYXNzIGV4dGVuZHMgTGFiZWwge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMucGxhY2VtZW50ID0gXCJ0b3BcIjtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKExBQkVMX1BMQUNFTUVOVClcbl0sIFNjYXR0ZXJTZXJpZXNMYWJlbC5wcm90b3R5cGUsIFwicGxhY2VtZW50XCIsIDIpO1xudmFyIFNjYXR0ZXJTZXJpZXNQcm9wZXJ0aWVzID0gY2xhc3MgZXh0ZW5kcyBDYXJ0ZXNpYW5TZXJpZXNQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmNvbG9yUmFuZ2UgPSBbXCIjZmZmZjAwXCIsIFwiIzAwZmYwMFwiLCBcIiMwMDAwZmZcIl07XG4gICAgdGhpcy5sYWJlbCA9IG5ldyBTY2F0dGVyU2VyaWVzTGFiZWwoKTtcbiAgICB0aGlzLnRvb2x0aXAgPSBuZXcgU2VyaWVzVG9vbHRpcCgpO1xuICAgIC8vIE5vIHZhbGlkYXRpb24uIE5vdCBhIHBhcnQgb2YgdGhlIG9wdGlvbnMgY29udHJhY3QuXG4gICAgdGhpcy5tYXJrZXIgPSBuZXcgU2VyaWVzTWFya2VyKCk7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcpXG5dLCBTY2F0dGVyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwieEtleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORylcbl0sIFNjYXR0ZXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ5S2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBTY2F0dGVyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGFiZWxLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFNjYXR0ZXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjb2xvcktleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgU2NhdHRlclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInhGaWx0ZXJLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFNjYXR0ZXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ5RmlsdGVyS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBTY2F0dGVyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwieE5hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFNjYXR0ZXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ5TmFtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgU2NhdHRlclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImxhYmVsTmFtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgU2NhdHRlclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNvbG9yTmFtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE5VTUJFUl9BUlJBWSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgU2NhdHRlclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNvbG9yRG9tYWluXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HX0FSUkFZKVxuXSwgU2NhdHRlclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNvbG9yUmFuZ2VcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFNjYXR0ZXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ0aXRsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHkoXCJtYXJrZXIuc2hhcGVcIilcbl0sIFNjYXR0ZXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzaGFwZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHkoXCJtYXJrZXIuc2l6ZVwiKVxuXSwgU2NhdHRlclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInNpemVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBQcm94eVByb3BlcnR5KFwibWFya2VyLmZpbGxcIilcbl0sIFNjYXR0ZXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJmaWxsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgUHJveHlQcm9wZXJ0eShcIm1hcmtlci5maWxsT3BhY2l0eVwiKVxuXSwgU2NhdHRlclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImZpbGxPcGFjaXR5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgUHJveHlQcm9wZXJ0eShcIm1hcmtlci5zdHJva2VcIilcbl0sIFNjYXR0ZXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdHJva2VcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBQcm94eVByb3BlcnR5KFwibWFya2VyLnN0cm9rZVdpZHRoXCIpXG5dLCBTY2F0dGVyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic3Ryb2tlV2lkdGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBQcm94eVByb3BlcnR5KFwibWFya2VyLnN0cm9rZU9wYWNpdHlcIilcbl0sIFNjYXR0ZXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdHJva2VPcGFjaXR5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgUHJveHlQcm9wZXJ0eShcIm1hcmtlci5pdGVtU3R5bGVyXCIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFNjYXR0ZXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJpdGVtU3R5bGVyXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgU2NhdHRlclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImxhYmVsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgU2NhdHRlclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInRvb2x0aXBcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vc2NhdHRlclNlcmllcy50c1xudmFyIFNjYXR0ZXJTZXJpZXMgPSBjbGFzcyBleHRlbmRzIENhcnRlc2lhblNlcmllcyB7XG4gIGNvbnN0cnVjdG9yKG1vZHVsZUN0eCkge1xuICAgIHN1cGVyKHtcbiAgICAgIG1vZHVsZUN0eCxcbiAgICAgIGRpcmVjdGlvbktleXM6IERFRkFVTFRfQ0FSVEVTSUFOX0RJUkVDVElPTl9LRVlTLFxuICAgICAgZGlyZWN0aW9uTmFtZXM6IERFRkFVTFRfQ0FSVEVTSUFOX0RJUkVDVElPTl9OQU1FUyxcbiAgICAgIHBpY2tNb2RlczogW1xuICAgICAgICAyIC8qIEFYSVNfQUxJR05FRCAqLyxcbiAgICAgICAgMSAvKiBORUFSRVNUX05PREUgKi8sXG4gICAgICAgIDAgLyogRVhBQ1RfU0hBUEVfTUFUQ0ggKi9cbiAgICAgIF0sXG4gICAgICBwYXRoc1BlclNlcmllczogW10sXG4gICAgICBoYXNNYXJrZXJzOiB0cnVlLFxuICAgICAgbWFya2VyU2VsZWN0aW9uR2FyYmFnZUNvbGxlY3Rpb246IGZhbHNlLFxuICAgICAgYW5pbWF0aW9uUmVzZXRGbnM6IHtcbiAgICAgICAgbWFya2VyOiByZXNldE1hcmtlckZuLFxuICAgICAgICBsYWJlbDogcmVzZXRMYWJlbEZuXG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5wcm9wZXJ0aWVzID0gbmV3IFNjYXR0ZXJTZXJpZXNQcm9wZXJ0aWVzKCk7XG4gICAgdGhpcy5jb2xvclNjYWxlID0gbmV3IENvbG9yU2NhbGUoKTtcbiAgfVxuICBnZXQgcGlja01vZGVBeGlzKCkge1xuICAgIHJldHVybiBcIm1haW4tY2F0ZWdvcnlcIjtcbiAgfVxuICBhc3luYyBwcm9jZXNzRGF0YShkYXRhQ29udHJvbGxlcikge1xuICAgIGlmICghdGhpcy5wcm9wZXJ0aWVzLmlzVmFsaWQoKSB8fCB0aGlzLmRhdGEgPT0gbnVsbCB8fCAhdGhpcy52aXNpYmxlKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHhTY2FsZSA9IHRoaXMuYXhlc1tcInhcIiAvKiBYICovXT8uc2NhbGU7XG4gICAgY29uc3QgeVNjYWxlID0gdGhpcy5heGVzW1wieVwiIC8qIFkgKi9dPy5zY2FsZTtcbiAgICBjb25zdCB7IHhTY2FsZVR5cGUsIHlTY2FsZVR5cGUgfSA9IHRoaXMuZ2V0U2NhbGVJbmZvcm1hdGlvbih7IHhTY2FsZSwgeVNjYWxlIH0pO1xuICAgIGNvbnN0IGNvbG9yU2NhbGVUeXBlID0gdGhpcy5jb2xvclNjYWxlLnR5cGU7XG4gICAgY29uc3QgeyB4S2V5LCB5S2V5LCB4RmlsdGVyS2V5LCB5RmlsdGVyS2V5LCBsYWJlbEtleSwgY29sb3JLZXksIGNvbG9yRG9tYWluLCBjb2xvclJhbmdlIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgeyBkYXRhTW9kZWwsIHByb2Nlc3NlZERhdGEgfSA9IGF3YWl0IHRoaXMucmVxdWVzdERhdGFNb2RlbChkYXRhQ29udHJvbGxlciwgdGhpcy5kYXRhLCB7XG4gICAgICBwcm9wczogW1xuICAgICAgICB2YWx1ZVByb3BlcnR5KHhLZXksIHhTY2FsZVR5cGUsIHsgaWQ6IGB4VmFsdWVgIH0pLFxuICAgICAgICB2YWx1ZVByb3BlcnR5KHlLZXksIHlTY2FsZVR5cGUsIHsgaWQ6IGB5VmFsdWVgIH0pLFxuICAgICAgICAuLi54RmlsdGVyS2V5ICE9IG51bGwgPyBbdmFsdWVQcm9wZXJ0eSh4RmlsdGVyS2V5LCB4U2NhbGVUeXBlLCB7IGlkOiBcInhGaWx0ZXJWYWx1ZVwiIH0pXSA6IFtdLFxuICAgICAgICAuLi55RmlsdGVyS2V5ICE9IG51bGwgPyBbdmFsdWVQcm9wZXJ0eSh5RmlsdGVyS2V5LCB5U2NhbGVUeXBlLCB7IGlkOiBcInlGaWx0ZXJWYWx1ZVwiIH0pXSA6IFtdLFxuICAgICAgICAuLi5jb2xvcktleSA/IFt2YWx1ZVByb3BlcnR5KGNvbG9yS2V5LCBjb2xvclNjYWxlVHlwZSwgeyBpZDogYGNvbG9yVmFsdWVgIH0pXSA6IFtdLFxuICAgICAgICAuLi5sYWJlbEtleSA/IFt2YWx1ZVByb3BlcnR5KGxhYmVsS2V5LCBcImJhbmRcIiwgeyBpZDogYGxhYmVsVmFsdWVgIH0pXSA6IFtdXG4gICAgICBdXG4gICAgfSk7XG4gICAgaWYgKGNvbG9yS2V5KSB7XG4gICAgICBjb25zdCBjb2xvcktleUlkeCA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgY29sb3JWYWx1ZWApO1xuICAgICAgdGhpcy5jb2xvclNjYWxlLmRvbWFpbiA9IGNvbG9yRG9tYWluID8/IHByb2Nlc3NlZERhdGEuZG9tYWluLnZhbHVlc1tjb2xvcktleUlkeF0gPz8gW107XG4gICAgICB0aGlzLmNvbG9yU2NhbGUucmFuZ2UgPSBjb2xvclJhbmdlO1xuICAgICAgdGhpcy5jb2xvclNjYWxlLnVwZGF0ZSgpO1xuICAgIH1cbiAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJ1cGRhdGVEYXRhXCIpO1xuICB9XG4gIGdldFNlcmllc0RvbWFpbihkaXJlY3Rpb24pIHtcbiAgICBjb25zdCB7IGRhdGFNb2RlbCwgcHJvY2Vzc2VkRGF0YSB9ID0gdGhpcztcbiAgICBpZiAoIXByb2Nlc3NlZERhdGEgfHwgIWRhdGFNb2RlbClcbiAgICAgIHJldHVybiBbXTtcbiAgICBjb25zdCBpZCA9IGRpcmVjdGlvbiA9PT0gXCJ4XCIgLyogWCAqLyA/IGB4VmFsdWVgIDogYHlWYWx1ZWA7XG4gICAgY29uc3QgZGF0YURlZiA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YURlZkJ5SWQodGhpcywgaWQpO1xuICAgIGNvbnN0IGRvbWFpbiA9IGRhdGFNb2RlbC5nZXREb21haW4odGhpcywgaWQsIFwidmFsdWVcIiwgcHJvY2Vzc2VkRGF0YSk7XG4gICAgaWYgKGRhdGFEZWY/LmRlZi50eXBlID09PSBcInZhbHVlXCIgJiYgZGF0YURlZj8uZGVmLnZhbHVlVHlwZSA9PT0gXCJjYXRlZ29yeVwiKSB7XG4gICAgICByZXR1cm4gZG9tYWluO1xuICAgIH1cbiAgICByZXR1cm4gZml4TnVtZXJpY0V4dGVudChleHRlbnQoZG9tYWluKSk7XG4gIH1cbiAgYXN5bmMgY3JlYXRlTm9kZURhdGEoKSB7XG4gICAgY29uc3QgeyBheGVzLCBkYXRhTW9kZWwsIHByb2Nlc3NlZERhdGEsIGNvbG9yU2NhbGUgfSA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgeEtleSxcbiAgICAgIHlLZXksXG4gICAgICB4RmlsdGVyS2V5LFxuICAgICAgeUZpbHRlcktleSxcbiAgICAgIGxhYmVsS2V5LFxuICAgICAgY29sb3JLZXksXG4gICAgICB4TmFtZSxcbiAgICAgIHlOYW1lLFxuICAgICAgbGFiZWxOYW1lLFxuICAgICAgbWFya2VyLFxuICAgICAgbGFiZWwsXG4gICAgICB2aXNpYmxlXG4gICAgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCB7IHBsYWNlbWVudCB9ID0gbGFiZWw7XG4gICAgY29uc3QgbWFya2VyU2hhcGUgPSBnZXRNYXJrZXIobWFya2VyLnNoYXBlKTtcbiAgICBjb25zdCB4QXhpcyA9IGF4ZXNbXCJ4XCIgLyogWCAqL107XG4gICAgY29uc3QgeUF4aXMgPSBheGVzW1wieVwiIC8qIFkgKi9dO1xuICAgIGlmICghKGRhdGFNb2RlbCAmJiBwcm9jZXNzZWREYXRhICYmIHZpc2libGUgJiYgeEF4aXMgJiYgeUF4aXMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHhEYXRhSWR4ID0gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGB4VmFsdWVgKTtcbiAgICBjb25zdCB5RGF0YUlkeCA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgeVZhbHVlYCk7XG4gICAgY29uc3QgY29sb3JEYXRhSWR4ID0gY29sb3JLZXkgIT0gbnVsbCA/IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgY29sb3JWYWx1ZWApIDogLTE7XG4gICAgY29uc3QgbGFiZWxEYXRhSWR4ID0gbGFiZWxLZXkgIT0gbnVsbCA/IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgbGFiZWxWYWx1ZWApIDogLTE7XG4gICAgY29uc3QgeEZpbHRlckRhdGFJZHggPSB4RmlsdGVyS2V5ICE9IG51bGwgPyBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYHhGaWx0ZXJWYWx1ZWApIDogdm9pZCAwO1xuICAgIGNvbnN0IHlGaWx0ZXJEYXRhSWR4ID0geUZpbHRlcktleSAhPSBudWxsID8gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGB5RmlsdGVyVmFsdWVgKSA6IHZvaWQgMDtcbiAgICBjb25zdCB4U2NhbGUgPSB4QXhpcy5zY2FsZTtcbiAgICBjb25zdCB5U2NhbGUgPSB5QXhpcy5zY2FsZTtcbiAgICBjb25zdCB4T2Zmc2V0ID0gKHhTY2FsZS5iYW5kd2lkdGggPz8gMCkgLyAyO1xuICAgIGNvbnN0IHlPZmZzZXQgPSAoeVNjYWxlLmJhbmR3aWR0aCA/PyAwKSAvIDI7XG4gICAgY29uc3Qgbm9kZURhdGEgPSBbXTtcbiAgICBjb25zdCBmb250ID0gbGFiZWwuZ2V0Rm9udCgpO1xuICAgIGNvbnN0IHRleHRNZWFzdXJlciA9IENhY2hlZFRleHRNZWFzdXJlclBvb2wuZ2V0TWVhc3VyZXIoeyBmb250IH0pO1xuICAgIGZvciAoY29uc3QgeyB2YWx1ZXMsIGRhdHVtIH0gb2YgcHJvY2Vzc2VkRGF0YS5kYXRhID8/IFtdKSB7XG4gICAgICBjb25zdCB4RGF0dW0gPSB2YWx1ZXNbeERhdGFJZHhdO1xuICAgICAgY29uc3QgeURhdHVtID0gdmFsdWVzW3lEYXRhSWR4XTtcbiAgICAgIGNvbnN0IHggPSB4U2NhbGUuY29udmVydCh4RGF0dW0pICsgeE9mZnNldDtcbiAgICAgIGNvbnN0IHkgPSB5U2NhbGUuY29udmVydCh5RGF0dW0pICsgeU9mZnNldDtcbiAgICAgIGNvbnN0IHNlbGVjdGVkID0geEZpbHRlckRhdGFJZHggIT0gbnVsbCAmJiB5RmlsdGVyRGF0YUlkeCAhPSBudWxsID8gdmFsdWVzW3hGaWx0ZXJEYXRhSWR4XSA9PT0geERhdHVtICYmIHZhbHVlc1t5RmlsdGVyRGF0YUlkeF0gPT09IHlEYXR1bSA6IHZvaWQgMDtcbiAgICAgIGNvbnN0IGxhYmVsVGV4dCA9IHRoaXMuZ2V0TGFiZWxUZXh0KGxhYmVsLCB7XG4gICAgICAgIHZhbHVlOiBsYWJlbEtleSA/IHZhbHVlc1tsYWJlbERhdGFJZHhdIDogeURhdHVtLFxuICAgICAgICBkYXR1bSxcbiAgICAgICAgeEtleSxcbiAgICAgICAgeUtleSxcbiAgICAgICAgbGFiZWxLZXksXG4gICAgICAgIHhOYW1lLFxuICAgICAgICB5TmFtZSxcbiAgICAgICAgbGFiZWxOYW1lXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHNpemUgPSB0ZXh0TWVhc3VyZXIubWVhc3VyZVRleHQobGFiZWxUZXh0KTtcbiAgICAgIGNvbnN0IGZpbGwgPSBjb2xvcktleSA/IGNvbG9yU2NhbGUuY29udmVydCh2YWx1ZXNbY29sb3JEYXRhSWR4XSkgOiB2b2lkIDA7XG4gICAgICBub2RlRGF0YS5wdXNoKHtcbiAgICAgICAgc2VyaWVzOiB0aGlzLFxuICAgICAgICBpdGVtSWQ6IHlLZXksXG4gICAgICAgIHlLZXksXG4gICAgICAgIHhLZXksXG4gICAgICAgIGRhdHVtLFxuICAgICAgICB4VmFsdWU6IHhEYXR1bSxcbiAgICAgICAgeVZhbHVlOiB5RGF0dW0sXG4gICAgICAgIGNhcERlZmF1bHRzOiB7IGxlbmd0aFJhdGlvTXVsdGlwbGllcjogbWFya2VyLmdldERpYW1ldGVyKCksIGxlbmd0aE1heDogSW5maW5pdHkgfSxcbiAgICAgICAgcG9pbnQ6IHsgeCwgeSwgc2l6ZTogbWFya2VyLnNpemUgfSxcbiAgICAgICAgbWlkUG9pbnQ6IHsgeCwgeSB9LFxuICAgICAgICBmaWxsLFxuICAgICAgICBsYWJlbDogeyB0ZXh0OiBsYWJlbFRleHQsIC4uLnNpemUgfSxcbiAgICAgICAgbWFya2VyOiBtYXJrZXJTaGFwZSxcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICBzZWxlY3RlZFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBpdGVtSWQ6IHlLZXksXG4gICAgICBub2RlRGF0YSxcbiAgICAgIGxhYmVsRGF0YTogbm9kZURhdGEsXG4gICAgICBzY2FsZXM6IHRoaXMuY2FsY3VsYXRlU2NhbGluZygpLFxuICAgICAgdmlzaWJsZTogdGhpcy52aXNpYmxlXG4gICAgfTtcbiAgfVxuICBpc1BhdGhPclNlbGVjdGlvbkRpcnR5KCkge1xuICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXMubWFya2VyLmlzRGlydHkoKTtcbiAgfVxuICBnZXRMYWJlbERhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dE5vZGVEYXRhPy5sYWJlbERhdGEgPz8gW107XG4gIH1cbiAgbWFya2VyRmFjdG9yeSgpIHtcbiAgICBjb25zdCB7IHNoYXBlIH0gPSB0aGlzLnByb3BlcnRpZXMubWFya2VyO1xuICAgIGNvbnN0IE1hcmtlclNoYXBlID0gZ2V0TWFya2VyKHNoYXBlKTtcbiAgICByZXR1cm4gbmV3IE1hcmtlclNoYXBlKCk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlTWFya2VyU2VsZWN0aW9uKG9wdHMpIHtcbiAgICBjb25zdCB7IG5vZGVEYXRhLCBtYXJrZXJTZWxlY3Rpb24gfSA9IG9wdHM7XG4gICAgaWYgKHRoaXMucHJvcGVydGllcy5tYXJrZXIuaXNEaXJ0eSgpKSB7XG4gICAgICBtYXJrZXJTZWxlY3Rpb24uY2xlYXIoKTtcbiAgICAgIG1hcmtlclNlbGVjdGlvbi5jbGVhbnVwKCk7XG4gICAgfVxuICAgIHJldHVybiBtYXJrZXJTZWxlY3Rpb24udXBkYXRlKHRoaXMucHJvcGVydGllcy5tYXJrZXIuZW5hYmxlZCA/IG5vZGVEYXRhIDogW10pO1xuICB9XG4gIGFzeW5jIHVwZGF0ZU1hcmtlck5vZGVzKG9wdHMpIHtcbiAgICBjb25zdCB7IG1hcmtlclNlbGVjdGlvbiwgaXNIaWdobGlnaHQ6IGhpZ2hsaWdodGVkIH0gPSBvcHRzO1xuICAgIGNvbnN0IHsgeEtleSwgeUtleSwgbGFiZWxLZXksIG1hcmtlciwgaGlnaGxpZ2h0U3R5bGUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCBiYXNlU3R5bGUgPSBtZXJnZURlZmF1bHRzKGhpZ2hsaWdodGVkICYmIGhpZ2hsaWdodFN0eWxlLml0ZW0sIG1hcmtlci5nZXRTdHlsZSgpKTtcbiAgICBtYXJrZXJTZWxlY3Rpb24uZWFjaCgobm9kZSwgZGF0dW0pID0+IHtcbiAgICAgIHRoaXMudXBkYXRlTWFya2VyU3R5bGUobm9kZSwgbWFya2VyLCB7IGRhdHVtLCBoaWdobGlnaHRlZCwgeEtleSwgeUtleSwgbGFiZWxLZXkgfSwgYmFzZVN0eWxlLCB7XG4gICAgICAgIHNlbGVjdGVkOiBkYXR1bS5zZWxlY3RlZFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKCFoaWdobGlnaHRlZCkge1xuICAgICAgbWFya2VyLm1hcmtDbGVhbigpO1xuICAgIH1cbiAgfVxuICBhc3luYyB1cGRhdGVMYWJlbFNlbGVjdGlvbihvcHRzKSB7XG4gICAgY29uc3QgcGxhY2VkTGFiZWxzID0gdGhpcy5pc0xhYmVsRW5hYmxlZCgpID8gdGhpcy5jaGFydD8ucGxhY2VMYWJlbHMoKS5nZXQodGhpcykgPz8gW10gOiBbXTtcbiAgICByZXR1cm4gb3B0cy5sYWJlbFNlbGVjdGlvbi51cGRhdGUoXG4gICAgICBwbGFjZWRMYWJlbHMubWFwKCh7IGRhdHVtLCB4LCB5IH0pID0+ICh7XG4gICAgICAgIC4uLmRhdHVtLFxuICAgICAgICBwb2ludDogeyB4LCB5LCBzaXplOiBkYXR1bS5wb2ludC5zaXplIH0sXG4gICAgICAgIHBsYWNlbWVudDogXCJ0b3BcIlxuICAgICAgfSkpLFxuICAgICAgKHRleHQpID0+IHtcbiAgICAgICAgdGV4dC5wb2ludGVyRXZlbnRzID0gMSAvKiBOb25lICovO1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlTGFiZWxOb2RlcyhvcHRzKSB7XG4gICAgY29uc3QgeyBsYWJlbCB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIG9wdHMubGFiZWxTZWxlY3Rpb24uZWFjaCgodGV4dCwgZGF0dW0pID0+IHtcbiAgICAgIHRleHQudGV4dCA9IGRhdHVtLmxhYmVsLnRleHQ7XG4gICAgICB0ZXh0LmZpbGwgPSBsYWJlbC5jb2xvcjtcbiAgICAgIHRleHQueCA9IGRhdHVtLnBvaW50Py54ID8/IDA7XG4gICAgICB0ZXh0LnkgPSBkYXR1bS5wb2ludD8ueSA/PyAwO1xuICAgICAgdGV4dC5mb250U3R5bGUgPSBsYWJlbC5mb250U3R5bGU7XG4gICAgICB0ZXh0LmZvbnRXZWlnaHQgPSBsYWJlbC5mb250V2VpZ2h0O1xuICAgICAgdGV4dC5mb250U2l6ZSA9IGxhYmVsLmZvbnRTaXplO1xuICAgICAgdGV4dC5mb250RmFtaWx5ID0gbGFiZWwuZm9udEZhbWlseTtcbiAgICAgIHRleHQudGV4dEFsaWduID0gXCJsZWZ0XCI7XG4gICAgICB0ZXh0LnRleHRCYXNlbGluZSA9IFwidG9wXCI7XG4gICAgfSk7XG4gIH1cbiAgZ2V0VG9vbHRpcEh0bWwobm9kZURhdHVtKSB7XG4gICAgY29uc3QgeEF4aXMgPSB0aGlzLmF4ZXNbXCJ4XCIgLyogWCAqL107XG4gICAgY29uc3QgeUF4aXMgPSB0aGlzLmF4ZXNbXCJ5XCIgLyogWSAqL107XG4gICAgaWYgKCF0aGlzLnByb3BlcnRpZXMuaXNWYWxpZCgpIHx8ICF4QXhpcyB8fCAheUF4aXMpIHtcbiAgICAgIHJldHVybiBFTVBUWV9UT09MVElQX0NPTlRFTlQ7XG4gICAgfVxuICAgIGNvbnN0IHsgeEtleSwgeUtleSwgbGFiZWxLZXksIHhOYW1lLCB5TmFtZSwgbGFiZWxOYW1lLCB0aXRsZSA9IHlOYW1lLCBtYXJrZXIsIHRvb2x0aXAgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCB7IGRhdHVtLCB4VmFsdWUsIHlWYWx1ZSwgbGFiZWwsIGl0ZW1JZCB9ID0gbm9kZURhdHVtO1xuICAgIGNvbnN0IGJhc2VTdHlsZSA9IG1lcmdlRGVmYXVsdHMoXG4gICAgICB7IGZpbGw6IG5vZGVEYXR1bS5maWxsLCBzdHJva2VXaWR0aDogdGhpcy5nZXRTdHJva2VXaWR0aChtYXJrZXIuc3Ryb2tlV2lkdGgpIH0sXG4gICAgICBtYXJrZXIuZ2V0U3R5bGUoKVxuICAgICk7XG4gICAgY29uc3QgeyBmaWxsOiBjb2xvciA9IFwiZ3JheVwiIH0gPSB0aGlzLmdldE1hcmtlclN0eWxlKFxuICAgICAgbWFya2VyLFxuICAgICAgeyBkYXR1bTogbm9kZURhdHVtLCBoaWdobGlnaHRlZDogZmFsc2UsIHhLZXksIHlLZXksIGxhYmVsS2V5IH0sXG4gICAgICBiYXNlU3R5bGVcbiAgICApO1xuICAgIGNvbnN0IHhTdHJpbmcgPSBzYW5pdGl6ZUh0bWwoeEF4aXMuZm9ybWF0RGF0dW0oeFZhbHVlKSk7XG4gICAgY29uc3QgeVN0cmluZyA9IHNhbml0aXplSHRtbCh5QXhpcy5mb3JtYXREYXR1bSh5VmFsdWUpKTtcbiAgICBsZXQgY29udGVudCA9IGA8Yj4ke3Nhbml0aXplSHRtbCh4TmFtZSA/PyB4S2V5KX08L2I+OiAke3hTdHJpbmd9PGJyPjxiPiR7c2FuaXRpemVIdG1sKHlOYW1lID8/IHlLZXkpfTwvYj46ICR7eVN0cmluZ31gO1xuICAgIGlmIChsYWJlbEtleSkge1xuICAgICAgY29udGVudCA9IGA8Yj4ke3Nhbml0aXplSHRtbChsYWJlbE5hbWUgPz8gbGFiZWxLZXkpfTwvYj46ICR7c2FuaXRpemVIdG1sKGxhYmVsLnRleHQpfTxicj5gICsgY29udGVudDtcbiAgICB9XG4gICAgcmV0dXJuIHRvb2x0aXAudG9Ub29sdGlwSHRtbChcbiAgICAgIHsgdGl0bGUsIGNvbnRlbnQsIGJhY2tncm91bmRDb2xvcjogY29sb3IgfSxcbiAgICAgIHtcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIGl0ZW1JZCxcbiAgICAgICAgeEtleSxcbiAgICAgICAgeE5hbWUsXG4gICAgICAgIHlLZXksXG4gICAgICAgIHlOYW1lLFxuICAgICAgICBsYWJlbEtleSxcbiAgICAgICAgbGFiZWxOYW1lLFxuICAgICAgICB0aXRsZSxcbiAgICAgICAgY29sb3IsXG4gICAgICAgIHNlcmllc0lkOiB0aGlzLmlkLFxuICAgICAgICAuLi50aGlzLmdldE1vZHVsZVRvb2x0aXBQYXJhbXMoKVxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgZ2V0TGVnZW5kRGF0YShsZWdlbmRUeXBlKSB7XG4gICAgY29uc3QgeyB5S2V5LCB5TmFtZSwgdGl0bGUsIG1hcmtlciwgdmlzaWJsZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHsgZmlsbCwgc3Ryb2tlLCBmaWxsT3BhY2l0eSwgc3Ryb2tlT3BhY2l0eSwgc3Ryb2tlV2lkdGggfSA9IG1hcmtlcjtcbiAgICBpZiAoIXRoaXMuZGF0YT8ubGVuZ3RoIHx8ICF0aGlzLnByb3BlcnRpZXMuaXNWYWxpZCgpIHx8IGxlZ2VuZFR5cGUgIT09IFwiY2F0ZWdvcnlcIikge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICBsZWdlbmRUeXBlOiBcImNhdGVnb3J5XCIsXG4gICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICBpdGVtSWQ6IHlLZXksXG4gICAgICAgIHNlcmllc0lkOiB0aGlzLmlkLFxuICAgICAgICBlbmFibGVkOiB2aXNpYmxlLFxuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgIHRleHQ6IHRpdGxlID8/IHlOYW1lID8/IHlLZXlcbiAgICAgICAgfSxcbiAgICAgICAgc3ltYm9sczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1hcmtlcjoge1xuICAgICAgICAgICAgICBzaGFwZTogbWFya2VyLnNoYXBlLFxuICAgICAgICAgICAgICBmaWxsOiBtYXJrZXIuZmlsbCA/PyBmaWxsID8/IFwicmdiYSgwLCAwLCAwLCAwKVwiLFxuICAgICAgICAgICAgICBzdHJva2U6IG1hcmtlci5zdHJva2UgPz8gc3Ryb2tlID8/IFwicmdiYSgwLCAwLCAwLCAwKVwiLFxuICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogZmlsbE9wYWNpdHkgPz8gMSxcbiAgICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogc3Ryb2tlT3BhY2l0eSA/PyAxLFxuICAgICAgICAgICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGggPz8gMFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfVxuICAgIF07XG4gIH1cbiAgYW5pbWF0ZUVtcHR5VXBkYXRlUmVhZHkoZGF0YSkge1xuICAgIGNvbnN0IHsgbWFya2VyU2VsZWN0aW9uLCBsYWJlbFNlbGVjdGlvbiwgYW5ub3RhdGlvblNlbGVjdGlvbnMgfSA9IGRhdGE7XG4gICAgbWFya2VyU2NhbGVJbkFuaW1hdGlvbih0aGlzLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCBtYXJrZXJTZWxlY3Rpb24pO1xuICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwibGFiZWxzXCIsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIGxhYmVsU2VsZWN0aW9uKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImFubm90YXRpb25zXCIsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIC4uLmFubm90YXRpb25TZWxlY3Rpb25zKTtcbiAgfVxuICBpc0xhYmVsRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLmxhYmVsLmVuYWJsZWQ7XG4gIH1cbiAgbm9kZUZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIG5ldyBHcm91cCgpO1xuICB9XG4gIGdldEZvcm1hdHRlZE1hcmtlclN0eWxlKGRhdHVtKSB7XG4gICAgY29uc3QgeyB4S2V5LCB5S2V5LCBsYWJlbEtleSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIHJldHVybiB0aGlzLmdldE1hcmtlclN0eWxlKHRoaXMucHJvcGVydGllcy5tYXJrZXIsIHsgZGF0dW0sIHhLZXksIHlLZXksIGxhYmVsS2V5LCBoaWdobGlnaHRlZDogdHJ1ZSB9KTtcbiAgfVxuICBjb21wdXRlRm9jdXNCb3VuZHMob3B0cykge1xuICAgIHJldHVybiBjb21wdXRlTWFya2VyRm9jdXNCb3VuZHModGhpcywgb3B0cyk7XG4gIH1cbn07XG5TY2F0dGVyU2VyaWVzLmNsYXNzTmFtZSA9IFwiU2NhdHRlclNlcmllc1wiO1xuU2NhdHRlclNlcmllcy50eXBlID0gXCJzY2F0dGVyXCI7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vc2NhdHRlclNlcmllc01vZHVsZS50c1xudmFyIFNjYXR0ZXJTZXJpZXNNb2R1bGUgPSB7XG4gIHR5cGU6IFwic2VyaWVzXCIsXG4gIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIixcbiAgcGFja2FnZVR5cGU6IFwiY29tbXVuaXR5XCIsXG4gIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiXSxcbiAgaWRlbnRpZmllcjogXCJzY2F0dGVyXCIsXG4gIG1vZHVsZUZhY3Rvcnk6IChjdHgpID0+IG5ldyBTY2F0dGVyU2VyaWVzKGN0eCksXG4gIHRvb2x0aXBEZWZhdWx0czogeyByYW5nZTogXCJuZWFyZXN0XCIgfSxcbiAgZGVmYXVsdEF4ZXM6IFtcbiAgICB7XG4gICAgICB0eXBlOiBcIm51bWJlclwiIC8qIE5VTUJFUiAqLyxcbiAgICAgIHBvc2l0aW9uOiBcImJvdHRvbVwiIC8qIEJPVFRPTSAqL1xuICAgIH0sXG4gICAge1xuICAgICAgdHlwZTogXCJudW1iZXJcIiAvKiBOVU1CRVIgKi8sXG4gICAgICBwb3NpdGlvbjogXCJsZWZ0XCIgLyogTEVGVCAqL1xuICAgIH1cbiAgXSxcbiAgdGhlbWVUZW1wbGF0ZToge1xuICAgIHNlcmllczoge1xuICAgICAgc2hhcGU6IFwiY2lyY2xlXCIsXG4gICAgICBzaXplOiA3LFxuICAgICAgZmlsbE9wYWNpdHk6IDAuOCxcbiAgICAgIHRvb2x0aXA6IHsgcG9zaXRpb246IHsgdHlwZTogXCJub2RlXCIgfSB9LFxuICAgICAgbGFiZWw6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgICAgZm9udEZhbWlseTogREVGQVVMVF9GT05UX0ZBTUlMWSxcbiAgICAgICAgY29sb3I6IERFRkFVTFRfTEFCRUxfQ09MT1VSXG4gICAgICB9LFxuICAgICAgZXJyb3JCYXI6IHtcbiAgICAgICAgY2FwOiB7XG4gICAgICAgICAgbGVuZ3RoUmF0aW86IDFcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcGFsZXR0ZUZhY3Rvcnk6IHNpbmdsZVNlcmllc1BhbGV0dGVGYWN0b3J5XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9zZWN0b3JCb3gudHNcbnZhciBTZWN0b3JCb3ggPSBjbGFzcyBfU2VjdG9yQm94IHtcbiAgY29uc3RydWN0b3Ioc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cykge1xuICAgIHRoaXMuc3RhcnRBbmdsZSA9IHN0YXJ0QW5nbGU7XG4gICAgdGhpcy5lbmRBbmdsZSA9IGVuZEFuZ2xlO1xuICAgIHRoaXMuaW5uZXJSYWRpdXMgPSBpbm5lclJhZGl1cztcbiAgICB0aGlzLm91dGVyUmFkaXVzID0gb3V0ZXJSYWRpdXM7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgeyBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzIH0gPSB0aGlzO1xuICAgIHJldHVybiBuZXcgX1NlY3RvckJveChzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzKTtcbiAgfVxuICBlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFydEFuZ2xlID09PSBvdGhlci5zdGFydEFuZ2xlICYmIHRoaXMuZW5kQW5nbGUgPT09IG90aGVyLmVuZEFuZ2xlICYmIHRoaXMuaW5uZXJSYWRpdXMgPT09IG90aGVyLmlubmVyUmFkaXVzICYmIHRoaXMub3V0ZXJSYWRpdXMgPT09IG90aGVyLm91dGVyUmFkaXVzO1xuICB9XG4gIFtpbnRlcnBvbGF0ZV0ob3RoZXIsIGQpIHtcbiAgICByZXR1cm4gbmV3IF9TZWN0b3JCb3goXG4gICAgICB0aGlzLnN0YXJ0QW5nbGUgKiAoMSAtIGQpICsgb3RoZXIuc3RhcnRBbmdsZSAqIGQsXG4gICAgICB0aGlzLmVuZEFuZ2xlICogKDEgLSBkKSArIG90aGVyLmVuZEFuZ2xlICogZCxcbiAgICAgIHRoaXMuaW5uZXJSYWRpdXMgKiAoMSAtIGQpICsgb3RoZXIuaW5uZXJSYWRpdXMgKiBkLFxuICAgICAgdGhpcy5vdXRlclJhZGl1cyAqICgxIC0gZCkgKyBvdGhlci5vdXRlclJhZGl1cyAqIGRcbiAgICApO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS91dGlsL3NlY3Rvci50c1xuZnVuY3Rpb24gc2VjdG9yQm94KHsgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cyB9KSB7XG4gIGxldCB4MCA9IEluZmluaXR5O1xuICBsZXQgeTAgPSBJbmZpbml0eTtcbiAgbGV0IHgxID0gLUluZmluaXR5O1xuICBsZXQgeTEgPSAtSW5maW5pdHk7XG4gIGNvbnN0IGFkZFBvaW50ID0gKHgsIHkpID0+IHtcbiAgICB4MCA9IE1hdGgubWluKHgsIHgwKTtcbiAgICB5MCA9IE1hdGgubWluKHksIHkwKTtcbiAgICB4MSA9IE1hdGgubWF4KHgsIHgxKTtcbiAgICB5MSA9IE1hdGgubWF4KHksIHkxKTtcbiAgfTtcbiAgYWRkUG9pbnQoaW5uZXJSYWRpdXMgKiBNYXRoLmNvcyhzdGFydEFuZ2xlKSwgaW5uZXJSYWRpdXMgKiBNYXRoLnNpbihzdGFydEFuZ2xlKSk7XG4gIGFkZFBvaW50KGlubmVyUmFkaXVzICogTWF0aC5jb3MoZW5kQW5nbGUpLCBpbm5lclJhZGl1cyAqIE1hdGguc2luKGVuZEFuZ2xlKSk7XG4gIGFkZFBvaW50KG91dGVyUmFkaXVzICogTWF0aC5jb3Moc3RhcnRBbmdsZSksIG91dGVyUmFkaXVzICogTWF0aC5zaW4oc3RhcnRBbmdsZSkpO1xuICBhZGRQb2ludChvdXRlclJhZGl1cyAqIE1hdGguY29zKGVuZEFuZ2xlKSwgb3V0ZXJSYWRpdXMgKiBNYXRoLnNpbihlbmRBbmdsZSkpO1xuICBpZiAoaXNCZXR3ZWVuQW5nbGVzKDAsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKSkge1xuICAgIGFkZFBvaW50KG91dGVyUmFkaXVzLCAwKTtcbiAgfVxuICBpZiAoaXNCZXR3ZWVuQW5nbGVzKE1hdGguUEkgKiAwLjUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKSkge1xuICAgIGFkZFBvaW50KDAsIG91dGVyUmFkaXVzKTtcbiAgfVxuICBpZiAoaXNCZXR3ZWVuQW5nbGVzKE1hdGguUEksIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKSkge1xuICAgIGFkZFBvaW50KC1vdXRlclJhZGl1cywgMCk7XG4gIH1cbiAgaWYgKGlzQmV0d2VlbkFuZ2xlcyhNYXRoLlBJICogMS41LCBzdGFydEFuZ2xlLCBlbmRBbmdsZSkpIHtcbiAgICBhZGRQb2ludCgwLCAtb3V0ZXJSYWRpdXMpO1xuICB9XG4gIHJldHVybiBuZXcgQkJveCh4MCwgeTAsIHgxIC0geDAsIHkxIC0geTApO1xufVxuZnVuY3Rpb24gaXNQb2ludEluU2VjdG9yKHgsIHksIHNlY3Rvcikge1xuICBjb25zdCByYWRpdXMgPSBNYXRoLnNxcnQoTWF0aC5wb3coeCwgMikgKyBNYXRoLnBvdyh5LCAyKSk7XG4gIGNvbnN0IHsgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzIH0gPSBzZWN0b3I7XG4gIGlmIChzZWN0b3Iuc3RhcnRBbmdsZSA9PT0gc2VjdG9yLmVuZEFuZ2xlIHx8IHJhZGl1cyA8IE1hdGgubWluKGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cykgfHwgcmFkaXVzID4gTWF0aC5tYXgoaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBzdGFydEFuZ2xlID0gbm9ybWFsaXplQW5nbGUxODAoc2VjdG9yLnN0YXJ0QW5nbGUpO1xuICBjb25zdCBlbmRBbmdsZSA9IG5vcm1hbGl6ZUFuZ2xlMTgwKHNlY3Rvci5lbmRBbmdsZSk7XG4gIGNvbnN0IGFuZ2xlMiA9IE1hdGguYXRhbjIoeSwgeCk7XG4gIHJldHVybiBzdGFydEFuZ2xlIDwgZW5kQW5nbGUgPyBhbmdsZTIgPD0gZW5kQW5nbGUgJiYgYW5nbGUyID49IHN0YXJ0QW5nbGUgOiBhbmdsZTIgPD0gZW5kQW5nbGUgJiYgYW5nbGUyID49IC1NYXRoLlBJIHx8IGFuZ2xlMiA+PSBzdGFydEFuZ2xlICYmIGFuZ2xlMiA8PSBNYXRoLlBJO1xufVxuZnVuY3Rpb24gbGluZUNvbGxpZGVzU2VjdG9yKGxpbmUsIHNlY3Rvcikge1xuICBjb25zdCB7IHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMgfSA9IHNlY3RvcjtcbiAgY29uc3Qgb3V0ZXJTdGFydCA9IHsgeDogb3V0ZXJSYWRpdXMgKiBNYXRoLmNvcyhzdGFydEFuZ2xlKSwgeTogb3V0ZXJSYWRpdXMgKiBNYXRoLnNpbihzdGFydEFuZ2xlKSB9O1xuICBjb25zdCBvdXRlckVuZCA9IHsgeDogb3V0ZXJSYWRpdXMgKiBNYXRoLmNvcyhlbmRBbmdsZSksIHk6IG91dGVyUmFkaXVzICogTWF0aC5zaW4oZW5kQW5nbGUpIH07XG4gIGNvbnN0IGlubmVyU3RhcnQgPSBpbm5lclJhZGl1cyA9PT0gMCA/IHsgeDogMCwgeTogMCB9IDogeyB4OiBpbm5lclJhZGl1cyAqIE1hdGguY29zKHN0YXJ0QW5nbGUpLCB5OiBpbm5lclJhZGl1cyAqIE1hdGguc2luKHN0YXJ0QW5nbGUpIH07XG4gIGNvbnN0IGlubmVyRW5kID0gaW5uZXJSYWRpdXMgPT09IDAgPyB7IHg6IDAsIHk6IDAgfSA6IHsgeDogaW5uZXJSYWRpdXMgKiBNYXRoLmNvcyhlbmRBbmdsZSksIHk6IGlubmVyUmFkaXVzICogTWF0aC5zaW4oZW5kQW5nbGUpIH07XG4gIHJldHVybiBzZWdtZW50SW50ZXJzZWN0aW9uKFxuICAgIGxpbmUuc3RhcnQueCxcbiAgICBsaW5lLnN0YXJ0LnksXG4gICAgbGluZS5lbmQueCxcbiAgICBsaW5lLmVuZC55LFxuICAgIG91dGVyU3RhcnQueCxcbiAgICBvdXRlclN0YXJ0LnksXG4gICAgaW5uZXJTdGFydC54LFxuICAgIGlubmVyU3RhcnQueVxuICApIHx8IHNlZ21lbnRJbnRlcnNlY3Rpb24oXG4gICAgbGluZS5zdGFydC54LFxuICAgIGxpbmUuc3RhcnQueSxcbiAgICBsaW5lLmVuZC54LFxuICAgIGxpbmUuZW5kLnksXG4gICAgb3V0ZXJFbmQueCxcbiAgICBvdXRlckVuZC55LFxuICAgIGlubmVyRW5kLngsXG4gICAgaW5uZXJFbmQueVxuICApIHx8IGFyY0ludGVyc2VjdGlvbnMoXG4gICAgMCxcbiAgICAwLFxuICAgIG91dGVyUmFkaXVzLFxuICAgIHN0YXJ0QW5nbGUsXG4gICAgZW5kQW5nbGUsXG4gICAgdHJ1ZSxcbiAgICBsaW5lLnN0YXJ0LngsXG4gICAgbGluZS5zdGFydC55LFxuICAgIGxpbmUuZW5kLngsXG4gICAgbGluZS5lbmQueVxuICApO1xufVxuZnVuY3Rpb24gYm94Q29sbGlkZXNTZWN0b3IoYm94LCBzZWN0b3IpIHtcbiAgY29uc3QgdG9wTGVmdCA9IHsgeDogYm94LngsIHk6IGJveC55IH07XG4gIGNvbnN0IHRvcFJpZ2h0ID0geyB4OiBib3gueCArIGJveC53aWR0aCwgeTogYm94LnkgfTtcbiAgY29uc3QgYm90dG9tTGVmdCA9IHsgeDogYm94LngsIHk6IGJveC55ICsgYm94LmhlaWdodCB9O1xuICBjb25zdCBib3R0b21SaWdodCA9IHsgeDogYm94LnggKyBib3gud2lkdGgsIHk6IGJveC55ICsgYm94LmhlaWdodCB9O1xuICByZXR1cm4gbGluZUNvbGxpZGVzU2VjdG9yKHsgc3RhcnQ6IHRvcExlZnQsIGVuZDogdG9wUmlnaHQgfSwgc2VjdG9yKSB8fCBsaW5lQ29sbGlkZXNTZWN0b3IoeyBzdGFydDogYm90dG9tTGVmdCwgZW5kOiBib3R0b21SaWdodCB9LCBzZWN0b3IpO1xufVxuZnVuY3Rpb24gcmFkaWlTY2FsaW5nRmFjdG9yKHIsIHN3ZWVwLCBhLCBiKSB7XG4gIGlmIChhID09PSAwICYmIGIgPT09IDApXG4gICAgcmV0dXJuIDA7XG4gIGNvbnN0IGZzMSA9IE1hdGguYXNpbihNYXRoLmFicygxICogYSkgLyAociArIDEgKiBhKSkgKyBNYXRoLmFzaW4oTWF0aC5hYnMoMSAqIGIpIC8gKHIgKyAxICogYikpIC0gc3dlZXA7XG4gIGlmIChmczEgPCAwKVxuICAgIHJldHVybiAxO1xuICBsZXQgc3RhcnQyID0gMDtcbiAgbGV0IGVuZDIgPSAxO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkgKz0gMSkge1xuICAgIGNvbnN0IHMgPSAoc3RhcnQyICsgZW5kMikgLyAyO1xuICAgIGNvbnN0IGZzID0gTWF0aC5hc2luKE1hdGguYWJzKHMgKiBhKSAvIChyICsgcyAqIGEpKSArIE1hdGguYXNpbihNYXRoLmFicyhzICogYikgLyAociArIHMgKiBiKSkgLSBzd2VlcDtcbiAgICBpZiAoZnMgPCAwKSB7XG4gICAgICBzdGFydDIgPSBzO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmQyID0gcztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0YXJ0Mjtcbn1cbnZhciBkZWx0YTMgPSAxZS02O1xuZnVuY3Rpb24gY2xvY2t3aXNlQW5nbGUyKGFuZ2xlMiwgcmVsYXRpdmVUb1N0YXJ0QW5nbGUpIHtcbiAgaWYgKGFuZ2xlQmV0d2VlbihhbmdsZTIsIHJlbGF0aXZlVG9TdGFydEFuZ2xlKSA8IGRlbHRhMykge1xuICAgIHJldHVybiByZWxhdGl2ZVRvU3RhcnRBbmdsZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbm9ybWFsaXplQW5nbGUzNjAoYW5nbGUyIC0gcmVsYXRpdmVUb1N0YXJ0QW5nbGUpICsgcmVsYXRpdmVUb1N0YXJ0QW5nbGU7XG4gIH1cbn1cbmZ1bmN0aW9uIGNsb2Nrd2lzZUFuZ2xlczIoc3RhcnRBbmdsZSwgZW5kQW5nbGUsIHJlbGF0aXZlVG9TdGFydEFuZ2xlID0gMCkge1xuICBjb25zdCBmdWxsUGllID0gTWF0aC5hYnMoZW5kQW5nbGUgLSBzdGFydEFuZ2xlKSA+PSAyICogTWF0aC5QSTtcbiAgY29uc3Qgc3dlZXBBbmdsZSA9IGZ1bGxQaWUgPyAyICogTWF0aC5QSSA6IG5vcm1hbGl6ZUFuZ2xlMzYwKGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSk7XG4gIHN0YXJ0QW5nbGUgPSBjbG9ja3dpc2VBbmdsZTIoc3RhcnRBbmdsZSwgcmVsYXRpdmVUb1N0YXJ0QW5nbGUpO1xuICBlbmRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBzd2VlcEFuZ2xlO1xuICByZXR1cm4geyBzdGFydEFuZ2xlLCBlbmRBbmdsZSB9O1xufVxuZnVuY3Rpb24gYXJjUmFkaWFsTGluZUludGVyc2VjdGlvbkFuZ2xlKGN4LCBjeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGNsaXBBbmdsZSkge1xuICBjb25zdCBzaW5BID0gTWF0aC5zaW4oY2xpcEFuZ2xlKTtcbiAgY29uc3QgY29zQSA9IE1hdGguY29zKGNsaXBBbmdsZSk7XG4gIGNvbnN0IGMgPSBjeCAqKiAyICsgY3kgKiogMiAtIHIgKiogMjtcbiAgbGV0IHAweCA9IE5hTjtcbiAgbGV0IHAweSA9IE5hTjtcbiAgbGV0IHAxeCA9IE5hTjtcbiAgbGV0IHAxeSA9IE5hTjtcbiAgaWYgKGNvc0EgPiAwLjUpIHtcbiAgICBjb25zdCB0YW5BID0gc2luQSAvIGNvc0E7XG4gICAgY29uc3QgYSA9IDEgKyB0YW5BICoqIDI7XG4gICAgY29uc3QgYiA9IC0yICogKGN4ICsgY3kgKiB0YW5BKTtcbiAgICBjb25zdCBkID0gYiAqKiAyIC0gNCAqIGEgKiBjO1xuICAgIGlmIChkIDwgMClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB4MCA9ICgtYiArIE1hdGguc3FydChkKSkgLyAoMiAqIGEpO1xuICAgIGNvbnN0IHgxID0gKC1iIC0gTWF0aC5zcXJ0KGQpKSAvICgyICogYSk7XG4gICAgcDB4ID0geDA7XG4gICAgcDB5ID0geDAgKiB0YW5BO1xuICAgIHAxeCA9IHgxO1xuICAgIHAxeSA9IHgxICogdGFuQTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjb3RBID0gY29zQSAvIHNpbkE7XG4gICAgY29uc3QgYSA9IDEgKyBjb3RBICoqIDI7XG4gICAgY29uc3QgYiA9IC0yICogKGN5ICsgY3ggKiBjb3RBKTtcbiAgICBjb25zdCBkID0gYiAqKiAyIC0gNCAqIGEgKiBjO1xuICAgIGlmIChkIDwgMClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB5MCA9ICgtYiArIE1hdGguc3FydChkKSkgLyAoMiAqIGEpO1xuICAgIGNvbnN0IHkxID0gKC1iIC0gTWF0aC5zcXJ0KGQpKSAvICgyICogYSk7XG4gICAgcDB4ID0geTAgKiBjb3RBO1xuICAgIHAweSA9IHkwO1xuICAgIHAxeCA9IHkxICogY290QTtcbiAgICBwMXkgPSB5MTtcbiAgfVxuICBjb25zdCBub3JtYWxpc2VkWCA9IGNvc0E7XG4gIGNvbnN0IG5vcm1hbGlzZWRZID0gc2luQTtcbiAgY29uc3QgcDBEb3ROb3JtYWxpemVkID0gcDB4ICogbm9ybWFsaXNlZFggKyBwMHkgKiBub3JtYWxpc2VkWTtcbiAgY29uc3QgcDFEb3ROb3JtYWxpemVkID0gcDF4ICogbm9ybWFsaXNlZFggKyBwMXkgKiBub3JtYWxpc2VkWTtcbiAgY29uc3QgYTAgPSBwMERvdE5vcm1hbGl6ZWQgPiAwID8gY2xvY2t3aXNlQW5nbGUyKE1hdGguYXRhbjIocDB5IC0gY3ksIHAweCAtIGN4KSwgc3RhcnRBbmdsZSkgOiBOYU47XG4gIGNvbnN0IGExID0gcDFEb3ROb3JtYWxpemVkID4gMCA/IGNsb2Nrd2lzZUFuZ2xlMihNYXRoLmF0YW4yKHAxeSAtIGN5LCBwMXggLSBjeCksIHN0YXJ0QW5nbGUpIDogTmFOO1xuICBpZiAoYTAgPj0gc3RhcnRBbmdsZSAmJiBhMCA8PSBlbmRBbmdsZSkge1xuICAgIHJldHVybiBhMDtcbiAgfSBlbHNlIGlmIChhMSA+PSBzdGFydEFuZ2xlICYmIGExIDw9IGVuZEFuZ2xlKSB7XG4gICAgcmV0dXJuIGExO1xuICB9XG59XG5mdW5jdGlvbiBhcmNDaXJjbGVJbnRlcnNlY3Rpb25BbmdsZShjeCwgY3ksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBjaXJjbGVSKSB7XG4gIGNvbnN0IGQgPSBNYXRoLmh5cG90KGN4LCBjeSk7XG4gIGNvbnN0IGQxID0gKGQgKiogMiAtIHIgKiogMiArIGNpcmNsZVIgKiogMikgLyAoMiAqIGQpO1xuICBjb25zdCBkMiA9IGQgLSBkMTtcbiAgY29uc3QgdGhldGEgPSBNYXRoLmF0YW4yKGN5LCBjeCk7XG4gIGNvbnN0IGRlbHRhVGhldGEgPSBNYXRoLmFjb3MoLWQyIC8gcik7XG4gIGNvbnN0IGEwID0gY2xvY2t3aXNlQW5nbGUyKHRoZXRhICsgZGVsdGFUaGV0YSwgc3RhcnRBbmdsZSk7XG4gIGNvbnN0IGExID0gY2xvY2t3aXNlQW5nbGUyKHRoZXRhIC0gZGVsdGFUaGV0YSwgc3RhcnRBbmdsZSk7XG4gIGlmIChhMCA+PSBzdGFydEFuZ2xlICYmIGEwIDw9IGVuZEFuZ2xlKSB7XG4gICAgcmV0dXJuIGEwO1xuICB9IGVsc2UgaWYgKGExID49IHN0YXJ0QW5nbGUgJiYgYTEgPD0gZW5kQW5nbGUpIHtcbiAgICByZXR1cm4gYTE7XG4gIH1cbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvc2hhcGUvc2VjdG9yLnRzXG52YXIgQXJjID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjeCwgY3ksIHIsIGEwLCBhMSkge1xuICAgIHRoaXMuY3ggPSBjeDtcbiAgICB0aGlzLmN5ID0gY3k7XG4gICAgdGhpcy5yID0gcjtcbiAgICB0aGlzLmEwID0gYTA7XG4gICAgdGhpcy5hMSA9IGExO1xuICAgIGlmICh0aGlzLmEwID49IHRoaXMuYTEpIHtcbiAgICAgIHRoaXMuYTAgPSBOYU47XG4gICAgICB0aGlzLmExID0gTmFOO1xuICAgIH1cbiAgfVxuICBpc1ZhbGlkKCkge1xuICAgIHJldHVybiBOdW1iZXIuaXNGaW5pdGUodGhpcy5hMCkgJiYgTnVtYmVyLmlzRmluaXRlKHRoaXMuYTEpO1xuICB9XG4gIHBvaW50QXQoYSkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiB0aGlzLmN4ICsgdGhpcy5yICogTWF0aC5jb3MoYSksXG4gICAgICB5OiB0aGlzLmN5ICsgdGhpcy5yICogTWF0aC5zaW4oYSlcbiAgICB9O1xuICB9XG4gIGNsaXBTdGFydChhKSB7XG4gICAgaWYgKGEgPT0gbnVsbCB8fCAhdGhpcy5pc1ZhbGlkKCkgfHwgYSA8IHRoaXMuYTApXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5hMCA9IGE7XG4gICAgaWYgKE51bWJlci5pc05hTihhKSB8fCB0aGlzLmEwID49IHRoaXMuYTEpIHtcbiAgICAgIHRoaXMuYTAgPSBOYU47XG4gICAgICB0aGlzLmExID0gTmFOO1xuICAgIH1cbiAgfVxuICBjbGlwRW5kKGEpIHtcbiAgICBpZiAoYSA9PSBudWxsIHx8ICF0aGlzLmlzVmFsaWQoKSB8fCBhID4gdGhpcy5hMSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmExID0gYTtcbiAgICBpZiAoTnVtYmVyLmlzTmFOKGEpIHx8IHRoaXMuYTAgPj0gdGhpcy5hMSkge1xuICAgICAgdGhpcy5hMCA9IE5hTjtcbiAgICAgIHRoaXMuYTEgPSBOYU47XG4gICAgfVxuICB9XG59O1xudmFyIFNlY3RvciA9IGNsYXNzIGV4dGVuZHMgUGF0aCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5jZW50ZXJYID0gMDtcbiAgICB0aGlzLmNlbnRlclkgPSAwO1xuICAgIHRoaXMuaW5uZXJSYWRpdXMgPSAxMDtcbiAgICB0aGlzLm91dGVyUmFkaXVzID0gMjA7XG4gICAgdGhpcy5zdGFydEFuZ2xlID0gMDtcbiAgICB0aGlzLmVuZEFuZ2xlID0gTWF0aC5QSSAqIDI7XG4gICAgdGhpcy5jbGlwU2VjdG9yID0gdm9pZCAwO1xuICAgIHRoaXMuY29uY2VudHJpY0VkZ2VJbnNldCA9IDA7XG4gICAgdGhpcy5yYWRpYWxFZGdlSW5zZXQgPSAwO1xuICAgIHRoaXMuc3RhcnRPdXRlckNvcm5lclJhZGl1cyA9IDA7XG4gICAgdGhpcy5lbmRPdXRlckNvcm5lclJhZGl1cyA9IDA7XG4gICAgdGhpcy5zdGFydElubmVyQ29ybmVyUmFkaXVzID0gMDtcbiAgICB0aGlzLmVuZElubmVyQ29ybmVyUmFkaXVzID0gMDtcbiAgfVxuICBzZXQgaW5zZXQodmFsdWUpIHtcbiAgICB0aGlzLmNvbmNlbnRyaWNFZGdlSW5zZXQgPSB2YWx1ZTtcbiAgICB0aGlzLnJhZGlhbEVkZ2VJbnNldCA9IHZhbHVlO1xuICB9XG4gIHNldCBjb3JuZXJSYWRpdXModmFsdWUpIHtcbiAgICB0aGlzLnN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXMgPSB2YWx1ZTtcbiAgICB0aGlzLmVuZE91dGVyQ29ybmVyUmFkaXVzID0gdmFsdWU7XG4gICAgdGhpcy5zdGFydElubmVyQ29ybmVyUmFkaXVzID0gdmFsdWU7XG4gICAgdGhpcy5lbmRJbm5lckNvcm5lclJhZGl1cyA9IHZhbHVlO1xuICB9XG4gIGNvbXB1dGVCQm94KCkge1xuICAgIHJldHVybiBzZWN0b3JCb3godGhpcykudHJhbnNsYXRlKHRoaXMuY2VudGVyWCwgdGhpcy5jZW50ZXJZKTtcbiAgfVxuICBub3JtYWxpemVkUmFkaWkoKSB7XG4gICAgY29uc3QgeyBjb25jZW50cmljRWRnZUluc2V0IH0gPSB0aGlzO1xuICAgIGxldCB7IGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cyB9ID0gdGhpcztcbiAgICBpbm5lclJhZGl1cyA9IGlubmVyUmFkaXVzID4gMCA/IGlubmVyUmFkaXVzICsgY29uY2VudHJpY0VkZ2VJbnNldCA6IDA7XG4gICAgb3V0ZXJSYWRpdXMgPSBNYXRoLm1heChvdXRlclJhZGl1cyAtIGNvbmNlbnRyaWNFZGdlSW5zZXQsIDApO1xuICAgIHJldHVybiB7IGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cyB9O1xuICB9XG4gIG5vcm1hbGl6ZWRDbGlwU2VjdG9yKCkge1xuICAgIGNvbnN0IHsgY2xpcFNlY3RvciB9ID0gdGhpcztcbiAgICBpZiAoY2xpcFNlY3RvciA9PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgc3RhcnRBbmdsZSwgZW5kQW5nbGUgfSA9IGNsb2Nrd2lzZUFuZ2xlczIodGhpcy5zdGFydEFuZ2xlLCB0aGlzLmVuZEFuZ2xlKTtcbiAgICBjb25zdCB7IGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cyB9ID0gdGhpcy5ub3JtYWxpemVkUmFkaWkoKTtcbiAgICBjb25zdCBjbGlwQW5nbGVzID0gY2xvY2t3aXNlQW5nbGVzMihjbGlwU2VjdG9yLnN0YXJ0QW5nbGUsIGNsaXBTZWN0b3IuZW5kQW5nbGUsIHN0YXJ0QW5nbGUpO1xuICAgIHJldHVybiBuZXcgU2VjdG9yQm94KFxuICAgICAgTWF0aC5tYXgoc3RhcnRBbmdsZSwgY2xpcEFuZ2xlcy5zdGFydEFuZ2xlKSxcbiAgICAgIE1hdGgubWluKGVuZEFuZ2xlLCBjbGlwQW5nbGVzLmVuZEFuZ2xlKSxcbiAgICAgIE1hdGgubWF4KGlubmVyUmFkaXVzLCBjbGlwU2VjdG9yLmlubmVyUmFkaXVzKSxcbiAgICAgIE1hdGgubWluKG91dGVyUmFkaXVzLCBjbGlwU2VjdG9yLm91dGVyUmFkaXVzKVxuICAgICk7XG4gIH1cbiAgZ2V0QW5nbGVPZmZzZXQocmFkaXVzKSB7XG4gICAgcmV0dXJuIHJhZGl1cyA+IDAgPyB0aGlzLnJhZGlhbEVkZ2VJbnNldCAvIHJhZGl1cyA6IDA7XG4gIH1cbiAgYXJjKHIsIGFuZ2xlU3dlZXAsIGEwLCBhMSwgb3V0ZXJBcmMsIGlubmVyQXJjLCBzdGFydDIsIGlubmVyKSB7XG4gICAgaWYgKHIgPD0gMClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IHN0YXJ0QW5nbGUsIGVuZEFuZ2xlIH0gPSBjbG9ja3dpc2VBbmdsZXMyKHRoaXMuc3RhcnRBbmdsZSwgdGhpcy5lbmRBbmdsZSk7XG4gICAgY29uc3QgeyBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMgfSA9IHRoaXMubm9ybWFsaXplZFJhZGlpKCk7XG4gICAgY29uc3QgY2xpcFNlY3RvciA9IHRoaXMubm9ybWFsaXplZENsaXBTZWN0b3IoKTtcbiAgICBpZiAoaW5uZXIgJiYgaW5uZXJSYWRpdXMgPD0gMClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBhbmdsZU9mZnNldCA9IGlubmVyID8gdGhpcy5nZXRBbmdsZU9mZnNldChpbm5lclJhZGl1cyArIHIpIDogdGhpcy5nZXRBbmdsZU9mZnNldChvdXRlclJhZGl1cyAtIHIpO1xuICAgIGNvbnN0IGFuZ2xlMiA9IHN0YXJ0MiA/IHN0YXJ0QW5nbGUgKyBhbmdsZU9mZnNldCArIGFuZ2xlU3dlZXAgOiBlbmRBbmdsZSAtIGFuZ2xlT2Zmc2V0IC0gYW5nbGVTd2VlcDtcbiAgICBjb25zdCByYWRpdXMgPSBpbm5lciA/IGlubmVyUmFkaXVzICsgciA6IG91dGVyUmFkaXVzIC0gcjtcbiAgICBjb25zdCBjeCA9IHJhZGl1cyAqIE1hdGguY29zKGFuZ2xlMik7XG4gICAgY29uc3QgY3kgPSByYWRpdXMgKiBNYXRoLnNpbihhbmdsZTIpO1xuICAgIGlmIChjbGlwU2VjdG9yICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IGRlbHRhNCA9IDFlLTY7XG4gICAgICBpZiAoIXN0YXJ0MiAmJiAhKGFuZ2xlMiA+PSBzdGFydEFuZ2xlIC0gZGVsdGE0ICYmIGFuZ2xlMiA8PSBjbGlwU2VjdG9yLmVuZEFuZ2xlIC0gZGVsdGE0KSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKHN0YXJ0MiAmJiAhKGFuZ2xlMiA+PSBjbGlwU2VjdG9yLnN0YXJ0QW5nbGUgKyBkZWx0YTQgJiYgYW5nbGUyIDw9IGVuZEFuZ2xlIC0gZGVsdGE0KSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKGlubmVyICYmIHJhZGl1cyA8IGNsaXBTZWN0b3IuaW5uZXJSYWRpdXMgLSBkZWx0YTQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmICghaW5uZXIgJiYgcmFkaXVzID4gY2xpcFNlY3Rvci5vdXRlclJhZGl1cyArIGRlbHRhNClcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhcmMgPSBuZXcgQXJjKGN4LCBjeSwgciwgYTAsIGExKTtcbiAgICBpZiAoY2xpcFNlY3RvciAhPSBudWxsKSB7XG4gICAgICBpZiAoaW5uZXIpIHtcbiAgICAgICAgYXJjLmNsaXBTdGFydChhcmNSYWRpYWxMaW5lSW50ZXJzZWN0aW9uQW5nbGUoY3gsIGN5LCByLCBhMCwgYTEsIGNsaXBTZWN0b3IuZW5kQW5nbGUpKTtcbiAgICAgICAgYXJjLmNsaXBFbmQoYXJjUmFkaWFsTGluZUludGVyc2VjdGlvbkFuZ2xlKGN4LCBjeSwgciwgYTAsIGExLCBjbGlwU2VjdG9yLnN0YXJ0QW5nbGUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFyYy5jbGlwU3RhcnQoYXJjUmFkaWFsTGluZUludGVyc2VjdGlvbkFuZ2xlKGN4LCBjeSwgciwgYTAsIGExLCBjbGlwU2VjdG9yLnN0YXJ0QW5nbGUpKTtcbiAgICAgICAgYXJjLmNsaXBFbmQoYXJjUmFkaWFsTGluZUludGVyc2VjdGlvbkFuZ2xlKGN4LCBjeSwgciwgYTAsIGExLCBjbGlwU2VjdG9yLmVuZEFuZ2xlKSk7XG4gICAgICB9XG4gICAgICBsZXQgY2lyY2xlQ2xpcFN0YXJ0O1xuICAgICAgbGV0IGNpcmNsZUNsaXBFbmQ7XG4gICAgICBpZiAoc3RhcnQyKSB7XG4gICAgICAgIGNpcmNsZUNsaXBTdGFydCA9IGFyY0NpcmNsZUludGVyc2VjdGlvbkFuZ2xlKGN4LCBjeSwgciwgYTAsIGExLCBjbGlwU2VjdG9yLmlubmVyUmFkaXVzKTtcbiAgICAgICAgY2lyY2xlQ2xpcEVuZCA9IGFyY0NpcmNsZUludGVyc2VjdGlvbkFuZ2xlKGN4LCBjeSwgciwgYTAsIGExLCBjbGlwU2VjdG9yLm91dGVyUmFkaXVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNpcmNsZUNsaXBTdGFydCA9IGFyY0NpcmNsZUludGVyc2VjdGlvbkFuZ2xlKGN4LCBjeSwgciwgYTAsIGExLCBjbGlwU2VjdG9yLm91dGVyUmFkaXVzKTtcbiAgICAgICAgY2lyY2xlQ2xpcEVuZCA9IGFyY0NpcmNsZUludGVyc2VjdGlvbkFuZ2xlKGN4LCBjeSwgciwgYTAsIGExLCBjbGlwU2VjdG9yLmlubmVyUmFkaXVzKTtcbiAgICAgIH1cbiAgICAgIGFyYy5jbGlwU3RhcnQoY2lyY2xlQ2xpcFN0YXJ0KTtcbiAgICAgIGFyYy5jbGlwRW5kKGNpcmNsZUNsaXBFbmQpO1xuICAgICAgaWYgKGNpcmNsZUNsaXBTdGFydCAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHsgeDogeDIsIHk6IHkyIH0gPSBhcmMucG9pbnRBdChjaXJjbGVDbGlwU3RhcnQpO1xuICAgICAgICBjb25zdCB0aGV0YTIgPSBjbG9ja3dpc2VBbmdsZTIoTWF0aC5hdGFuMih5MiwgeDIpLCBzdGFydEFuZ2xlKTtcbiAgICAgICAgaWYgKHN0YXJ0Mikge1xuICAgICAgICAgIGlubmVyQXJjPy5jbGlwU3RhcnQodGhldGEyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXRlckFyYy5jbGlwRW5kKHRoZXRhMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjaXJjbGVDbGlwRW5kICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgeyB4OiB4MiwgeTogeTIgfSA9IGFyYy5wb2ludEF0KGNpcmNsZUNsaXBFbmQpO1xuICAgICAgICBjb25zdCB0aGV0YTIgPSBjbG9ja3dpc2VBbmdsZTIoTWF0aC5hdGFuMih5MiwgeDIpLCBzdGFydEFuZ2xlKTtcbiAgICAgICAgaWYgKHN0YXJ0Mikge1xuICAgICAgICAgIG91dGVyQXJjLmNsaXBTdGFydCh0aGV0YTIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlubmVyQXJjPy5jbGlwRW5kKHRoZXRhMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNsaXBTZWN0b3IgIT0gbnVsbCkge1xuICAgICAgY29uc3QgeyB4OiB4MiwgeTogeTIgfSA9IGFyYy5wb2ludEF0KChhcmMuYTAgKyBhcmMuYTEpIC8gMik7XG4gICAgICBpZiAoIWlzUG9pbnRJblNlY3Rvcih4MiwgeTIsIGNsaXBTZWN0b3IpKVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgeCwgeSB9ID0gYXJjLnBvaW50QXQoc3RhcnQyID09PSBpbm5lciA/IGFyYy5hMCA6IGFyYy5hMSk7XG4gICAgY29uc3QgdGhldGEgPSBjbG9ja3dpc2VBbmdsZTIoTWF0aC5hdGFuMih5LCB4KSwgc3RhcnRBbmdsZSk7XG4gICAgY29uc3QgcmFkaWFsQXJjID0gaW5uZXIgPyBpbm5lckFyYyA6IG91dGVyQXJjO1xuICAgIGlmIChzdGFydDIpIHtcbiAgICAgIHJhZGlhbEFyYz8uY2xpcFN0YXJ0KHRoZXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmFkaWFsQXJjPy5jbGlwRW5kKHRoZXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGFyYztcbiAgfVxuICB1cGRhdGVQYXRoKCkge1xuICAgIGNvbnN0IGRlbHRhNCA9IDFlLTY7XG4gICAgY29uc3QgeyBwYXRoLCBjZW50ZXJYLCBjZW50ZXJZLCBjb25jZW50cmljRWRnZUluc2V0LCByYWRpYWxFZGdlSW5zZXQgfSA9IHRoaXM7XG4gICAgbGV0IHsgc3RhcnRPdXRlckNvcm5lclJhZGl1cywgZW5kT3V0ZXJDb3JuZXJSYWRpdXMsIHN0YXJ0SW5uZXJDb3JuZXJSYWRpdXMsIGVuZElubmVyQ29ybmVyUmFkaXVzIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgc3RhcnRBbmdsZSwgZW5kQW5nbGUgfSA9IGNsb2Nrd2lzZUFuZ2xlczIodGhpcy5zdGFydEFuZ2xlLCB0aGlzLmVuZEFuZ2xlKTtcbiAgICBjb25zdCB7IGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cyB9ID0gdGhpcy5ub3JtYWxpemVkUmFkaWkoKTtcbiAgICBjb25zdCBjbGlwU2VjdG9yID0gdGhpcy5ub3JtYWxpemVkQ2xpcFNlY3RvcigpO1xuICAgIGNvbnN0IHN3ZWVwQW5nbGUgPSBlbmRBbmdsZSAtIHN0YXJ0QW5nbGU7XG4gICAgY29uc3QgZnVsbFBpZSA9IHN3ZWVwQW5nbGUgPj0gMiAqIE1hdGguUEkgLSBkZWx0YTQ7XG4gICAgcGF0aC5jbGVhcigpO1xuICAgIGlmIChpbm5lclJhZGl1cyA9PT0gMCAmJiBvdXRlclJhZGl1cyA9PT0gMCB8fCBpbm5lclJhZGl1cyA+IG91dGVyUmFkaXVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmICgoY2xpcFNlY3Rvcj8uc3RhcnRBbmdsZSA/PyBzdGFydEFuZ2xlKSA9PT0gKGNsaXBTZWN0b3I/LmVuZEFuZ2xlID8/IGVuZEFuZ2xlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoZnVsbFBpZSAmJiB0aGlzLmNsaXBTZWN0b3IgPT0gbnVsbCAmJiBzdGFydE91dGVyQ29ybmVyUmFkaXVzID09PSAwICYmIGVuZE91dGVyQ29ybmVyUmFkaXVzID09PSAwICYmIHN0YXJ0SW5uZXJDb3JuZXJSYWRpdXMgPT09IDAgJiYgZW5kSW5uZXJDb3JuZXJSYWRpdXMgPT09IDApIHtcbiAgICAgIHBhdGgubW92ZVRvKGNlbnRlclggKyBvdXRlclJhZGl1cyAqIE1hdGguY29zKHN0YXJ0QW5nbGUpLCBjZW50ZXJZICsgb3V0ZXJSYWRpdXMgKiBNYXRoLnNpbihzdGFydEFuZ2xlKSk7XG4gICAgICBwYXRoLmFyYyhjZW50ZXJYLCBjZW50ZXJZLCBvdXRlclJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUpO1xuICAgICAgaWYgKGlubmVyUmFkaXVzID4gY29uY2VudHJpY0VkZ2VJbnNldCkge1xuICAgICAgICBwYXRoLm1vdmVUbyhjZW50ZXJYICsgaW5uZXJSYWRpdXMgKiBNYXRoLmNvcyhlbmRBbmdsZSksIGNlbnRlclkgKyBpbm5lclJhZGl1cyAqIE1hdGguc2luKGVuZEFuZ2xlKSk7XG4gICAgICAgIHBhdGguYXJjKGNlbnRlclgsIGNlbnRlclksIGlubmVyUmFkaXVzLCBlbmRBbmdsZSwgc3RhcnRBbmdsZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAodGhpcy5jbGlwU2VjdG9yID09IG51bGwgJiYgTWF0aC5hYnMoaW5uZXJSYWRpdXMgLSBvdXRlclJhZGl1cykgPCAxZS02KSB7XG4gICAgICBwYXRoLmFyYyhjZW50ZXJYLCBjZW50ZXJZLCBvdXRlclJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGZhbHNlKTtcbiAgICAgIHBhdGguYXJjKGNlbnRlclgsIGNlbnRlclksIG91dGVyUmFkaXVzLCBlbmRBbmdsZSwgc3RhcnRBbmdsZSwgdHJ1ZSk7XG4gICAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbm5lckFuZ2xlT2Zmc2V0ID0gdGhpcy5nZXRBbmdsZU9mZnNldChpbm5lclJhZGl1cyk7XG4gICAgY29uc3Qgb3V0ZXJBbmdsZU9mZnNldCA9IHRoaXMuZ2V0QW5nbGVPZmZzZXQob3V0ZXJSYWRpdXMpO1xuICAgIGNvbnN0IG91dGVyQW5nbGVFeGNlZWRlZCA9IHN3ZWVwQW5nbGUgPCAyICogb3V0ZXJBbmdsZU9mZnNldDtcbiAgICBpZiAob3V0ZXJBbmdsZUV4Y2VlZGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGhhc0lubmVyU3dlZXAgPSAoY2xpcFNlY3Rvcj8uaW5uZXJSYWRpdXMgPz8gaW5uZXJSYWRpdXMpID4gY29uY2VudHJpY0VkZ2VJbnNldDtcbiAgICBjb25zdCBpbm5lckFuZ2xlRXhjZWVkZWQgPSBpbm5lclJhZGl1cyA8IGNvbmNlbnRyaWNFZGdlSW5zZXQgfHwgc3dlZXBBbmdsZSA8IDIgKiBpbm5lckFuZ2xlT2Zmc2V0O1xuICAgIGNvbnN0IHJhZGlhbExlbmd0aCA9IG91dGVyUmFkaXVzIC0gaW5uZXJSYWRpdXM7XG4gICAgY29uc3QgbWF4UmFkaWFsTGVuZ3RoID0gTWF0aC5tYXgoXG4gICAgICBzdGFydE91dGVyQ29ybmVyUmFkaXVzLFxuICAgICAgc3RhcnRJbm5lckNvcm5lclJhZGl1cyxcbiAgICAgIGVuZE91dGVyQ29ybmVyUmFkaXVzLFxuICAgICAgZW5kSW5uZXJDb3JuZXJSYWRpdXNcbiAgICApO1xuICAgIGNvbnN0IGluaXRpYWxTY2FsaW5nRmFjdG9yID0gbWF4UmFkaWFsTGVuZ3RoID4gMCA/IE1hdGgubWluKHJhZGlhbExlbmd0aCAvIG1heFJhZGlhbExlbmd0aCwgMSkgOiAxO1xuICAgIHN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXMgKj0gaW5pdGlhbFNjYWxpbmdGYWN0b3I7XG4gICAgZW5kT3V0ZXJDb3JuZXJSYWRpdXMgKj0gaW5pdGlhbFNjYWxpbmdGYWN0b3I7XG4gICAgc3RhcnRJbm5lckNvcm5lclJhZGl1cyAqPSBpbml0aWFsU2NhbGluZ0ZhY3RvcjtcbiAgICBlbmRJbm5lckNvcm5lclJhZGl1cyAqPSBpbml0aWFsU2NhbGluZ0ZhY3RvcjtcbiAgICBjb25zdCBvdXRlclNjYWxpbmdGYWN0b3IgPSByYWRpaVNjYWxpbmdGYWN0b3IoXG4gICAgICBvdXRlclJhZGl1cyxcbiAgICAgIHN3ZWVwQW5nbGUgLSAyICogb3V0ZXJBbmdsZU9mZnNldCxcbiAgICAgIC1zdGFydE91dGVyQ29ybmVyUmFkaXVzLFxuICAgICAgLWVuZE91dGVyQ29ybmVyUmFkaXVzXG4gICAgKTtcbiAgICBzdGFydE91dGVyQ29ybmVyUmFkaXVzICo9IG91dGVyU2NhbGluZ0ZhY3RvcjtcbiAgICBlbmRPdXRlckNvcm5lclJhZGl1cyAqPSBvdXRlclNjYWxpbmdGYWN0b3I7XG4gICAgaWYgKCFpbm5lckFuZ2xlRXhjZWVkZWQgJiYgaGFzSW5uZXJTd2VlcCkge1xuICAgICAgY29uc3QgaW5uZXJTY2FsaW5nRmFjdG9yID0gcmFkaWlTY2FsaW5nRmFjdG9yKFxuICAgICAgICBpbm5lclJhZGl1cyxcbiAgICAgICAgc3dlZXBBbmdsZSAtIDIgKiBpbm5lckFuZ2xlT2Zmc2V0LFxuICAgICAgICBzdGFydElubmVyQ29ybmVyUmFkaXVzLFxuICAgICAgICBlbmRJbm5lckNvcm5lclJhZGl1c1xuICAgICAgKTtcbiAgICAgIHN0YXJ0SW5uZXJDb3JuZXJSYWRpdXMgKj0gaW5uZXJTY2FsaW5nRmFjdG9yO1xuICAgICAgZW5kSW5uZXJDb3JuZXJSYWRpdXMgKj0gaW5uZXJTY2FsaW5nRmFjdG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydElubmVyQ29ybmVyUmFkaXVzID0gMDtcbiAgICAgIGVuZElubmVyQ29ybmVyUmFkaXVzID0gMDtcbiAgICB9XG4gICAgY29uc3QgbWF4Q29tYmluZWRSYWRpYWxMZW5ndGggPSBNYXRoLm1heChcbiAgICAgIHN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXMgKyBzdGFydElubmVyQ29ybmVyUmFkaXVzLFxuICAgICAgZW5kT3V0ZXJDb3JuZXJSYWRpdXMgKyBlbmRJbm5lckNvcm5lclJhZGl1c1xuICAgICk7XG4gICAgY29uc3QgZWRnZXNTY2FsaW5nRmFjdG9yID0gbWF4Q29tYmluZWRSYWRpYWxMZW5ndGggPiAwID8gTWF0aC5taW4ocmFkaWFsTGVuZ3RoIC8gbWF4Q29tYmluZWRSYWRpYWxMZW5ndGgsIDEpIDogMTtcbiAgICBzdGFydE91dGVyQ29ybmVyUmFkaXVzICo9IGVkZ2VzU2NhbGluZ0ZhY3RvcjtcbiAgICBlbmRPdXRlckNvcm5lclJhZGl1cyAqPSBlZGdlc1NjYWxpbmdGYWN0b3I7XG4gICAgc3RhcnRJbm5lckNvcm5lclJhZGl1cyAqPSBlZGdlc1NjYWxpbmdGYWN0b3I7XG4gICAgZW5kSW5uZXJDb3JuZXJSYWRpdXMgKj0gZWRnZXNTY2FsaW5nRmFjdG9yO1xuICAgIGxldCBzdGFydE91dGVyQ29ybmVyUmFkaXVzQW5nbGVTd2VlcCA9IDA7XG4gICAgbGV0IGVuZE91dGVyQ29ybmVyUmFkaXVzQW5nbGVTd2VlcCA9IDA7XG4gICAgY29uc3Qgc3RhcnRPdXRlckNvcm5lclJhZGl1c1N3ZWVwID0gc3RhcnRPdXRlckNvcm5lclJhZGl1cyAvIChvdXRlclJhZGl1cyAtIHN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXMpO1xuICAgIGNvbnN0IGVuZE91dGVyQ29ybmVyUmFkaXVzU3dlZXAgPSBlbmRPdXRlckNvcm5lclJhZGl1cyAvIChvdXRlclJhZGl1cyAtIGVuZE91dGVyQ29ybmVyUmFkaXVzKTtcbiAgICBpZiAoc3RhcnRPdXRlckNvcm5lclJhZGl1c1N3ZWVwID49IDAgJiYgc3RhcnRPdXRlckNvcm5lclJhZGl1c1N3ZWVwIDwgMSAtIGRlbHRhNCkge1xuICAgICAgc3RhcnRPdXRlckNvcm5lclJhZGl1c0FuZ2xlU3dlZXAgPSBNYXRoLmFzaW4oc3RhcnRPdXRlckNvcm5lclJhZGl1c1N3ZWVwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRPdXRlckNvcm5lclJhZGl1c0FuZ2xlU3dlZXAgPSBzd2VlcEFuZ2xlIC8gMjtcbiAgICAgIGNvbnN0IG1heFN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXMgPSBvdXRlclJhZGl1cyAvICgxIC8gTWF0aC5zaW4oc3RhcnRPdXRlckNvcm5lclJhZGl1c0FuZ2xlU3dlZXApICsgMSk7XG4gICAgICBzdGFydE91dGVyQ29ybmVyUmFkaXVzID0gTWF0aC5taW4obWF4U3RhcnRPdXRlckNvcm5lclJhZGl1cywgc3RhcnRPdXRlckNvcm5lclJhZGl1cyk7XG4gICAgfVxuICAgIGlmIChlbmRPdXRlckNvcm5lclJhZGl1c1N3ZWVwID49IDAgJiYgZW5kT3V0ZXJDb3JuZXJSYWRpdXNTd2VlcCA8IDEgLSBkZWx0YTQpIHtcbiAgICAgIGVuZE91dGVyQ29ybmVyUmFkaXVzQW5nbGVTd2VlcCA9IE1hdGguYXNpbihlbmRPdXRlckNvcm5lclJhZGl1c1N3ZWVwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW5kT3V0ZXJDb3JuZXJSYWRpdXNBbmdsZVN3ZWVwID0gc3dlZXBBbmdsZSAvIDI7XG4gICAgICBjb25zdCBtYXhFbmRPdXRlckNvcm5lclJhZGl1cyA9IG91dGVyUmFkaXVzIC8gKDEgLyBNYXRoLnNpbihlbmRPdXRlckNvcm5lclJhZGl1c0FuZ2xlU3dlZXApICsgMSk7XG4gICAgICBlbmRPdXRlckNvcm5lclJhZGl1cyA9IE1hdGgubWluKG1heEVuZE91dGVyQ29ybmVyUmFkaXVzLCBlbmRPdXRlckNvcm5lclJhZGl1cyk7XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0SW5uZXJDb3JuZXJSYWRpdXNBbmdsZVN3ZWVwID0gTWF0aC5hc2luKFxuICAgICAgc3RhcnRJbm5lckNvcm5lclJhZGl1cyAvIChpbm5lclJhZGl1cyArIHN0YXJ0SW5uZXJDb3JuZXJSYWRpdXMpXG4gICAgKTtcbiAgICBjb25zdCBlbmRJbm5lckNvcm5lclJhZGl1c0FuZ2xlU3dlZXAgPSBNYXRoLmFzaW4oZW5kSW5uZXJDb3JuZXJSYWRpdXMgLyAoaW5uZXJSYWRpdXMgKyBlbmRJbm5lckNvcm5lclJhZGl1cykpO1xuICAgIGNvbnN0IG91dGVyQXJjUmFkaXVzID0gY2xpcFNlY3Rvcj8ub3V0ZXJSYWRpdXMgPz8gb3V0ZXJSYWRpdXM7XG4gICAgY29uc3Qgb3V0ZXJBcmNSYWRpdXNPZmZzZXQgPSB0aGlzLmdldEFuZ2xlT2Zmc2V0KG91dGVyQXJjUmFkaXVzKTtcbiAgICBjb25zdCBvdXRlckFyYyA9IG5ldyBBcmMoXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIG91dGVyQXJjUmFkaXVzLFxuICAgICAgc3RhcnRBbmdsZSArIG91dGVyQXJjUmFkaXVzT2Zmc2V0LFxuICAgICAgZW5kQW5nbGUgLSBvdXRlckFyY1JhZGl1c09mZnNldFxuICAgICk7XG4gICAgY29uc3QgaW5uZXJBcmNSYWRpdXMgPSBjbGlwU2VjdG9yPy5pbm5lclJhZGl1cyA/PyBpbm5lclJhZGl1cztcbiAgICBjb25zdCBpbm5lckFyY1JhZGl1c09mZnNldCA9IHRoaXMuZ2V0QW5nbGVPZmZzZXQoaW5uZXJBcmNSYWRpdXMpO1xuICAgIGNvbnN0IGlubmVyQXJjID0gaGFzSW5uZXJTd2VlcCA/IG5ldyBBcmMoMCwgMCwgaW5uZXJBcmNSYWRpdXMsIHN0YXJ0QW5nbGUgKyBpbm5lckFyY1JhZGl1c09mZnNldCwgZW5kQW5nbGUgLSBpbm5lckFyY1JhZGl1c09mZnNldCkgOiB2b2lkIDA7XG4gICAgaWYgKGNsaXBTZWN0b3IgIT0gbnVsbCkge1xuICAgICAgb3V0ZXJBcmMuY2xpcFN0YXJ0KGNsaXBTZWN0b3Iuc3RhcnRBbmdsZSk7XG4gICAgICBvdXRlckFyYy5jbGlwRW5kKGNsaXBTZWN0b3IuZW5kQW5nbGUpO1xuICAgICAgaW5uZXJBcmM/LmNsaXBTdGFydChjbGlwU2VjdG9yLnN0YXJ0QW5nbGUpO1xuICAgICAgaW5uZXJBcmM/LmNsaXBFbmQoY2xpcFNlY3Rvci5lbmRBbmdsZSk7XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0T3V0ZXJBcmMgPSB0aGlzLmFyYyhcbiAgICAgIHN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXMsXG4gICAgICBzdGFydE91dGVyQ29ybmVyUmFkaXVzQW5nbGVTd2VlcCxcbiAgICAgIHN0YXJ0QW5nbGUgLSBNYXRoLlBJICogMC41LFxuICAgICAgc3RhcnRBbmdsZSArIHN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXNBbmdsZVN3ZWVwLFxuICAgICAgb3V0ZXJBcmMsXG4gICAgICBpbm5lckFyYyxcbiAgICAgIHRydWUsXG4gICAgICBmYWxzZVxuICAgICk7XG4gICAgY29uc3QgZW5kT3V0ZXJBcmMgPSB0aGlzLmFyYyhcbiAgICAgIGVuZE91dGVyQ29ybmVyUmFkaXVzLFxuICAgICAgZW5kT3V0ZXJDb3JuZXJSYWRpdXNBbmdsZVN3ZWVwLFxuICAgICAgZW5kQW5nbGUgLSBlbmRPdXRlckNvcm5lclJhZGl1c0FuZ2xlU3dlZXAsXG4gICAgICBlbmRBbmdsZSArIE1hdGguUEkgKiAwLjUsXG4gICAgICBvdXRlckFyYyxcbiAgICAgIGlubmVyQXJjLFxuICAgICAgZmFsc2UsXG4gICAgICBmYWxzZVxuICAgICk7XG4gICAgY29uc3QgZW5kSW5uZXJBcmMgPSB0aGlzLmFyYyhcbiAgICAgIGVuZElubmVyQ29ybmVyUmFkaXVzLFxuICAgICAgZW5kSW5uZXJDb3JuZXJSYWRpdXNBbmdsZVN3ZWVwLFxuICAgICAgZW5kQW5nbGUgKyBNYXRoLlBJICogMC41LFxuICAgICAgZW5kQW5nbGUgKyBNYXRoLlBJIC0gZW5kSW5uZXJDb3JuZXJSYWRpdXNBbmdsZVN3ZWVwLFxuICAgICAgb3V0ZXJBcmMsXG4gICAgICBpbm5lckFyYyxcbiAgICAgIGZhbHNlLFxuICAgICAgdHJ1ZVxuICAgICk7XG4gICAgY29uc3Qgc3RhcnRJbm5lckFyYyA9IHRoaXMuYXJjKFxuICAgICAgc3RhcnRJbm5lckNvcm5lclJhZGl1cyxcbiAgICAgIHN0YXJ0SW5uZXJDb3JuZXJSYWRpdXNBbmdsZVN3ZWVwLFxuICAgICAgc3RhcnRBbmdsZSArIE1hdGguUEkgKyBzdGFydElubmVyQ29ybmVyUmFkaXVzQW5nbGVTd2VlcCxcbiAgICAgIHN0YXJ0QW5nbGUgKyBNYXRoLlBJICogMS41LFxuICAgICAgb3V0ZXJBcmMsXG4gICAgICBpbm5lckFyYyxcbiAgICAgIHRydWUsXG4gICAgICB0cnVlXG4gICAgKTtcbiAgICBpZiAoaW5uZXJBbmdsZUV4Y2VlZGVkKSB7XG4gICAgICBjb25zdCB4ID0gc3dlZXBBbmdsZSA8IE1hdGguUEkgKiAwLjUgPyByYWRpYWxFZGdlSW5zZXQgKiAoMSArIE1hdGguY29zKHN3ZWVwQW5nbGUpKSAvIE1hdGguc2luKHN3ZWVwQW5nbGUpIDogTmFOO1xuICAgICAgbGV0IHI7XG4gICAgICBpZiAoeCA+IDAgJiYgeCA8IG91dGVyUmFkaXVzKSB7XG4gICAgICAgIHIgPSBNYXRoLm1heChNYXRoLmh5cG90KHJhZGlhbEVkZ2VJbnNldCwgeCksIGlubmVyUmFkaXVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHIgPSByYWRpYWxFZGdlSW5zZXQ7XG4gICAgICB9XG4gICAgICByID0gTWF0aC5tYXgociwgaW5uZXJSYWRpdXMpO1xuICAgICAgY29uc3QgbWlkQW5nbGUgPSBzdGFydEFuZ2xlICsgc3dlZXBBbmdsZSAqIDAuNTtcbiAgICAgIHBhdGgubW92ZVRvKGNlbnRlclggKyByICogTWF0aC5jb3MobWlkQW5nbGUpLCBjZW50ZXJZICsgciAqIE1hdGguc2luKG1pZEFuZ2xlKSk7XG4gICAgfSBlbHNlIGlmIChzdGFydElubmVyQXJjPy5pc1ZhbGlkKCkgPT09IHRydWUgfHwgaW5uZXJBcmM/LmlzVmFsaWQoKSA9PT0gdHJ1ZSkge1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtaWRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBzd2VlcEFuZ2xlIC8gMjtcbiAgICAgIGNvbnN0IGN4ID0gaW5uZXJSYWRpdXMgKiBNYXRoLmNvcyhtaWRBbmdsZSk7XG4gICAgICBjb25zdCBjeSA9IGlubmVyUmFkaXVzICogTWF0aC5zaW4obWlkQW5nbGUpO1xuICAgICAgcGF0aC5tb3ZlVG8oY2VudGVyWCArIGN4LCBjZW50ZXJZICsgY3kpO1xuICAgIH1cbiAgICBpZiAoc3RhcnRPdXRlckFyYz8uaXNWYWxpZCgpID09PSB0cnVlKSB7XG4gICAgICBjb25zdCB7IGN4LCBjeSwgciwgYTAsIGExIH0gPSBzdGFydE91dGVyQXJjO1xuICAgICAgcGF0aC5hcmMoY2VudGVyWCArIGN4LCBjZW50ZXJZICsgY3ksIHIsIGEwLCBhMSk7XG4gICAgfVxuICAgIGlmIChvdXRlckFyYy5pc1ZhbGlkKCkpIHtcbiAgICAgIGNvbnN0IHsgciwgYTAsIGExIH0gPSBvdXRlckFyYztcbiAgICAgIHBhdGguYXJjKGNlbnRlclgsIGNlbnRlclksIHIsIGEwLCBhMSk7XG4gICAgfVxuICAgIGlmIChlbmRPdXRlckFyYz8uaXNWYWxpZCgpID09PSB0cnVlKSB7XG4gICAgICBjb25zdCB7IGN4LCBjeSwgciwgYTAsIGExIH0gPSBlbmRPdXRlckFyYztcbiAgICAgIHBhdGguYXJjKGNlbnRlclggKyBjeCwgY2VudGVyWSArIGN5LCByLCBhMCwgYTEpO1xuICAgIH1cbiAgICBpZiAoIWlubmVyQW5nbGVFeGNlZWRlZCkge1xuICAgICAgaWYgKGVuZElubmVyQXJjPy5pc1ZhbGlkKCkgPT09IHRydWUpIHtcbiAgICAgICAgY29uc3QgeyBjeCwgY3ksIHIsIGEwLCBhMSB9ID0gZW5kSW5uZXJBcmM7XG4gICAgICAgIHBhdGguYXJjKGNlbnRlclggKyBjeCwgY2VudGVyWSArIGN5LCByLCBhMCwgYTEpO1xuICAgICAgfVxuICAgICAgaWYgKGlubmVyQXJjPy5pc1ZhbGlkKCkgPT09IHRydWUpIHtcbiAgICAgICAgY29uc3QgeyByLCBhMCwgYTEgfSA9IGlubmVyQXJjO1xuICAgICAgICBwYXRoLmFyYyhjZW50ZXJYLCBjZW50ZXJZLCByLCBhMSwgYTAsIHRydWUpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0SW5uZXJBcmM/LmlzVmFsaWQoKSA9PT0gdHJ1ZSkge1xuICAgICAgICBjb25zdCB7IGN4LCBjeSwgciwgYTAsIGExIH0gPSBzdGFydElubmVyQXJjO1xuICAgICAgICBwYXRoLmFyYyhjZW50ZXJYICsgY3gsIGNlbnRlclkgKyBjeSwgciwgYTAsIGExKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgfVxuICBpc1BvaW50SW5QYXRoKHgsIHkpIHtcbiAgICBjb25zdCB7IHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMgfSA9IHRoaXMuY2xpcFNlY3RvciA/PyB0aGlzO1xuICAgIHJldHVybiBpc1BvaW50SW5TZWN0b3IoeCAtIHRoaXMuY2VudGVyWCwgeSAtIHRoaXMuY2VudGVyWSwge1xuICAgICAgc3RhcnRBbmdsZSxcbiAgICAgIGVuZEFuZ2xlLFxuICAgICAgaW5uZXJSYWRpdXM6IE1hdGgubWluKGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cyksXG4gICAgICBvdXRlclJhZGl1czogTWF0aC5tYXgoaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzKVxuICAgIH0pO1xuICB9XG59O1xuU2VjdG9yLmNsYXNzTmFtZSA9IFwiU2VjdG9yXCI7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgU2VjdG9yLnByb3RvdHlwZSwgXCJjZW50ZXJYXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFNlY3Rvci5wcm90b3R5cGUsIFwiY2VudGVyWVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBTZWN0b3IucHJvdG90eXBlLCBcImlubmVyUmFkaXVzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFNlY3Rvci5wcm90b3R5cGUsIFwib3V0ZXJSYWRpdXNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgU2VjdG9yLnByb3RvdHlwZSwgXCJzdGFydEFuZ2xlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFNlY3Rvci5wcm90b3R5cGUsIFwiZW5kQW5nbGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgU2VjdG9yLnByb3RvdHlwZSwgXCJjbGlwU2VjdG9yXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFNlY3Rvci5wcm90b3R5cGUsIFwiY29uY2VudHJpY0VkZ2VJbnNldFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBTZWN0b3IucHJvdG90eXBlLCBcInJhZGlhbEVkZ2VJbnNldFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBTZWN0b3IucHJvdG90eXBlLCBcInN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgU2VjdG9yLnByb3RvdHlwZSwgXCJlbmRPdXRlckNvcm5lclJhZGl1c1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBTZWN0b3IucHJvdG90eXBlLCBcInN0YXJ0SW5uZXJDb3JuZXJSYWRpdXNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgU2VjdG9yLnByb3RvdHlwZSwgXCJlbmRJbm5lckNvcm5lclJhZGl1c1wiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvdGhlbWVzL2RlZmF1bHRDb2xvcnMudHNcbnZhciBERUZBVUxUX0ZJTExTID0ge1xuICBCTFVFOiBcIiM1MDkwZGNcIixcbiAgT1JBTkdFOiBcIiNmZmEwM2FcIixcbiAgR1JFRU46IFwiIzQ1OWQ1NVwiLFxuICBDWUFOOiBcIiMzNGJmZTFcIixcbiAgWUVMTE9XOiBcIiNlMWNjMDBcIixcbiAgVklPTEVUOiBcIiM5NjY5Y2JcIixcbiAgR1JBWTogXCIjYjViNWI1XCIsXG4gIE1BR0VOVEE6IFwiI2JkNWFhN1wiLFxuICBCUk9XTjogXCIjOGE2MjI0XCIsXG4gIFJFRDogXCIjZWY1NDUyXCJcbn07XG52YXIgREVGQVVMVF9TVFJPS0VTID0ge1xuICBCTFVFOiBcIiMyYjVjOTVcIixcbiAgT1JBTkdFOiBcIiNjYzZmMTBcIixcbiAgR1JFRU46IFwiIzFlNjUyZVwiLFxuICBDWUFOOiBcIiMxODg1OWVcIixcbiAgWUVMTE9XOiBcIiNhNjk0MDBcIixcbiAgVklPTEVUOiBcIiM2MDNjODhcIixcbiAgR1JBWTogXCIjNTc1NzU3XCIsXG4gIE1BR0VOVEE6IFwiIzdkMmY2ZFwiLFxuICBCUk9XTjogXCIjNGYzNTA4XCIsXG4gIFJFRDogXCIjYTgyNTI5XCJcbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9wb2xhci9kb251dFNlcmllc1Byb3BlcnRpZXMudHNcbnZhciBEb251dFRpdGxlID0gY2xhc3MgZXh0ZW5kcyBDYXB0aW9uIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnNob3dJbkxlZ2VuZCA9IGZhbHNlO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIERvbnV0VGl0bGUucHJvdG90eXBlLCBcInNob3dJbkxlZ2VuZFwiLCAyKTtcbnZhciBEb251dElubmVyTGFiZWwgPSBjbGFzcyBleHRlbmRzIExhYmVsIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnNwYWNpbmcgPSAyO1xuICB9XG4gIHNldChwcm9wZXJ0aWVzLCBfcmVzZXQpIHtcbiAgICByZXR1cm4gc3VwZXIuc2V0KHByb3BlcnRpZXMpO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HKVxuXSwgRG9udXRJbm5lckxhYmVsLnByb3RvdHlwZSwgXCJ0ZXh0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTlVNQkVSKVxuXSwgRG9udXRJbm5lckxhYmVsLnByb3RvdHlwZSwgXCJzcGFjaW5nXCIsIDIpO1xudmFyIERvbnV0SW5uZXJDaXJjbGUgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmZpbGwgPSBcInRyYW5zcGFyZW50XCI7XG4gICAgdGhpcy5maWxsT3BhY2l0eSA9IDE7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcpXG5dLCBEb251dElubmVyQ2lyY2xlLnByb3RvdHlwZSwgXCJmaWxsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8pXG5dLCBEb251dElubmVyQ2lyY2xlLnByb3RvdHlwZSwgXCJmaWxsT3BhY2l0eVwiLCAyKTtcbnZhciBEb251dFNlcmllc0NhbGxvdXRMYWJlbCA9IGNsYXNzIGV4dGVuZHMgTGFiZWwge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMub2Zmc2V0ID0gMztcbiAgICB0aGlzLm1pbkFuZ2xlID0gMDtcbiAgICB0aGlzLm1pblNwYWNpbmcgPSA0O1xuICAgIHRoaXMubWF4Q29sbGlzaW9uT2Zmc2V0ID0gNTA7XG4gICAgdGhpcy5hdm9pZENvbGxpc2lvbnMgPSB0cnVlO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgRG9udXRTZXJpZXNDYWxsb3V0TGFiZWwucHJvdG90eXBlLCBcIm9mZnNldFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKERFR1JFRSlcbl0sIERvbnV0U2VyaWVzQ2FsbG91dExhYmVsLnByb3RvdHlwZSwgXCJtaW5BbmdsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIERvbnV0U2VyaWVzQ2FsbG91dExhYmVsLnByb3RvdHlwZSwgXCJtaW5TcGFjaW5nXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgRG9udXRTZXJpZXNDYWxsb3V0TGFiZWwucHJvdG90eXBlLCBcIm1heENvbGxpc2lvbk9mZnNldFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBEb251dFNlcmllc0NhbGxvdXRMYWJlbC5wcm90b3R5cGUsIFwiYXZvaWRDb2xsaXNpb25zXCIsIDIpO1xudmFyIERvbnV0U2VyaWVzU2VjdG9yTGFiZWwgPSBjbGFzcyBleHRlbmRzIExhYmVsIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnBvc2l0aW9uT2Zmc2V0ID0gMDtcbiAgICB0aGlzLnBvc2l0aW9uUmF0aW8gPSAwLjU7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShOVU1CRVIpXG5dLCBEb251dFNlcmllc1NlY3RvckxhYmVsLnByb3RvdHlwZSwgXCJwb3NpdGlvbk9mZnNldFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPKVxuXSwgRG9udXRTZXJpZXNTZWN0b3JMYWJlbC5wcm90b3R5cGUsIFwicG9zaXRpb25SYXRpb1wiLCAyKTtcbnZhciBEb251dFNlcmllc0NhbGxvdXRMaW5lID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5sZW5ndGggPSAxMDtcbiAgICB0aGlzLnN0cm9rZVdpZHRoID0gMTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklOR19BUlJBWSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgRG9udXRTZXJpZXNDYWxsb3V0TGluZS5wcm90b3R5cGUsIFwiY29sb3JzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgRG9udXRTZXJpZXNDYWxsb3V0TGluZS5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgRG9udXRTZXJpZXNDYWxsb3V0TGluZS5wcm90b3R5cGUsIFwic3Ryb2tlV2lkdGhcIiwgMik7XG52YXIgRG9udXRTZXJpZXNQcm9wZXJ0aWVzID0gY2xhc3MgZXh0ZW5kcyBTZXJpZXNQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmZpbGxzID0gT2JqZWN0LnZhbHVlcyhERUZBVUxUX0ZJTExTKTtcbiAgICB0aGlzLnN0cm9rZXMgPSBPYmplY3QudmFsdWVzKERFRkFVTFRfU1RST0tFUyk7XG4gICAgdGhpcy5maWxsT3BhY2l0eSA9IDE7XG4gICAgdGhpcy5zdHJva2VPcGFjaXR5ID0gMTtcbiAgICB0aGlzLmxpbmVEYXNoID0gWzBdO1xuICAgIHRoaXMubGluZURhc2hPZmZzZXQgPSAwO1xuICAgIHRoaXMuY29ybmVyUmFkaXVzID0gMDtcbiAgICB0aGlzLnJvdGF0aW9uID0gMDtcbiAgICB0aGlzLm91dGVyUmFkaXVzT2Zmc2V0ID0gMDtcbiAgICB0aGlzLm91dGVyUmFkaXVzUmF0aW8gPSAxO1xuICAgIHRoaXMuc3Ryb2tlV2lkdGggPSAxO1xuICAgIHRoaXMuc2VjdG9yU3BhY2luZyA9IDA7XG4gICAgdGhpcy5pbm5lckxhYmVscyA9IG5ldyBQcm9wZXJ0aWVzQXJyYXkoRG9udXRJbm5lckxhYmVsKTtcbiAgICB0aGlzLnRpdGxlID0gbmV3IERvbnV0VGl0bGUoKTtcbiAgICB0aGlzLmlubmVyQ2lyY2xlID0gbmV3IERvbnV0SW5uZXJDaXJjbGUoKTtcbiAgICB0aGlzLnNoYWRvdyA9IG5ldyBEcm9wU2hhZG93KCk7XG4gICAgdGhpcy5jYWxsb3V0TGFiZWwgPSBuZXcgRG9udXRTZXJpZXNDYWxsb3V0TGFiZWwoKTtcbiAgICB0aGlzLnNlY3RvckxhYmVsID0gbmV3IERvbnV0U2VyaWVzU2VjdG9yTGFiZWwoKTtcbiAgICB0aGlzLmNhbGxvdXRMaW5lID0gbmV3IERvbnV0U2VyaWVzQ2FsbG91dExpbmUoKTtcbiAgICB0aGlzLnRvb2x0aXAgPSBuZXcgU2VyaWVzVG9vbHRpcCgpO1xuICB9XG4gIGlzVmFsaWQoKSB7XG4gICAgY29uc3Qgc3VwZXJJc1ZhbGlkID0gc3VwZXIuaXNWYWxpZCgpO1xuICAgIGlmICh0aGlzLmlubmVyUmFkaXVzUmF0aW8gPT0gbnVsbCAmJiB0aGlzLmlubmVyUmFkaXVzT2Zmc2V0ID09IG51bGwpIHtcbiAgICAgIExvZ2dlci53YXJuT25jZShcbiAgICAgICAgXCJFaXRoZXIgYW4gW2lubmVyUmFkaXVzUmF0aW9dIG9yIGFuIFtpbm5lclJhZGl1c09mZnNldF0gbXVzdCBiZSBzZXQgdG8gcmVuZGVyIGEgZG9udXQgc2VyaWVzLlwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXJJc1ZhbGlkO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HKVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJhbmdsZUtleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJhbmdsZU5hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiYW5nbGVGaWx0ZXJLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwicmFkaXVzS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInJhZGl1c05hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwicmFkaXVzTWluXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInJhZGl1c01heFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjYWxsb3V0TGFiZWxLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiY2FsbG91dExhYmVsTmFtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzZWN0b3JMYWJlbEtleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzZWN0b3JMYWJlbE5hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGVnZW5kSXRlbUtleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklOR19BUlJBWSlcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiZmlsbHNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkdfQVJSQVkpXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0cm9rZXNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTylcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiZmlsbE9wYWNpdHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTylcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic3Ryb2tlT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKExJTkVfREFTSClcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGluZURhc2hcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImxpbmVEYXNoT2Zmc2V0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjb3JuZXJSYWRpdXNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGVU5DVElPTiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJpdGVtU3R5bGVyXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoREVHUkVFKVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJyb3RhdGlvblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE5VTUJFUilcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwib3V0ZXJSYWRpdXNPZmZzZXRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTylcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwib3V0ZXJSYWRpdXNSYXRpb1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE5VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJpbm5lclJhZGl1c09mZnNldFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImlubmVyUmFkaXVzUmF0aW9cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0cm9rZVdpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTlVNQkVSKVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzZWN0b3JTcGFjaW5nXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUX0FSUkFZKVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJpbm5lckxhYmVsc1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwidGl0bGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImlubmVyQ2lyY2xlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzaGFkb3dcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNhbGxvdXRMYWJlbFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic2VjdG9yTGFiZWxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNhbGxvdXRMaW5lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ0b29sdGlwXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvcG9sYXIvcGllVXRpbC50c1xuZnVuY3Rpb24gcHJlcGFyZVBpZVNlcmllc0FuaW1hdGlvbkZ1bmN0aW9ucyhpbml0aWFsTG9hZCwgcm90YXRpb25EZWdyZWVzLCBzY2FsZUZuLCBvbGRTY2FsZUZuKSB7XG4gIGNvbnN0IHNjYWxlMiA9IFtzY2FsZUZuLmNvbnZlcnQoMCksIHNjYWxlRm4uY29udmVydCgxKV07XG4gIGNvbnN0IG9sZFNjYWxlID0gW29sZFNjYWxlRm4uY29udmVydCgwKSwgb2xkU2NhbGVGbi5jb252ZXJ0KDEpXTtcbiAgY29uc3Qgcm90YXRpb24gPSBNYXRoLlBJIC8gLTIgKyB0b1JhZGlhbnMocm90YXRpb25EZWdyZWVzKTtcbiAgY29uc3QgcGhhc2UgPSBpbml0aWFsTG9hZCA/IFwiaW5pdGlhbFwiIDogXCJ1cGRhdGVcIjtcbiAgY29uc3Qgc2NhbGVUb05ld1JhZGl1cyA9ICh7IHJhZGl1cyB9KSA9PiB7XG4gICAgcmV0dXJuIHsgaW5uZXJSYWRpdXM6IHNjYWxlMlswXSwgb3V0ZXJSYWRpdXM6IHNjYWxlMlswXSArIChzY2FsZTJbMV0gLSBzY2FsZTJbMF0pICogcmFkaXVzIH07XG4gIH07XG4gIGNvbnN0IHNjYWxlVG9PbGRSYWRpdXMgPSAoeyByYWRpdXMgfSkgPT4ge1xuICAgIHJldHVybiB7IGlubmVyUmFkaXVzOiBvbGRTY2FsZVswXSwgb3V0ZXJSYWRpdXM6IG9sZFNjYWxlWzBdICsgKG9sZFNjYWxlWzFdIC0gb2xkU2NhbGVbMF0pICogcmFkaXVzIH07XG4gIH07XG4gIGNvbnN0IGZyb21GbiA9IChzZWN0LCBkYXR1bSwgc3RhdHVzLCB7IHByZXZGcm9tUHJvcHMgfSkgPT4ge1xuICAgIGxldCB7IHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMgfSA9IHNlY3Q7XG4gICAgbGV0IHsgZmlsbCwgc3Ryb2tlIH0gPSBkYXR1bS5zZWN0b3JGb3JtYXQ7XG4gICAgaWYgKHN0YXR1cyA9PT0gXCJ1bmtub3duXCIgfHwgc3RhdHVzID09PSBcImFkZGVkXCIgJiYgIXByZXZGcm9tUHJvcHMpIHtcbiAgICAgIHN0YXJ0QW5nbGUgPSByb3RhdGlvbjtcbiAgICAgIGVuZEFuZ2xlID0gcm90YXRpb247XG4gICAgICBpbm5lclJhZGl1cyA9IGRhdHVtLmlubmVyUmFkaXVzO1xuICAgICAgb3V0ZXJSYWRpdXMgPSBkYXR1bS5vdXRlclJhZGl1cztcbiAgICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gXCJhZGRlZFwiICYmIHByZXZGcm9tUHJvcHMpIHtcbiAgICAgIHN0YXJ0QW5nbGUgPSBwcmV2RnJvbVByb3BzLmVuZEFuZ2xlID8/IHJvdGF0aW9uO1xuICAgICAgZW5kQW5nbGUgPSBwcmV2RnJvbVByb3BzLmVuZEFuZ2xlID8/IHJvdGF0aW9uO1xuICAgICAgaW5uZXJSYWRpdXMgPSBwcmV2RnJvbVByb3BzLmlubmVyUmFkaXVzID8/IGRhdHVtLmlubmVyUmFkaXVzO1xuICAgICAgb3V0ZXJSYWRpdXMgPSBwcmV2RnJvbVByb3BzLm91dGVyUmFkaXVzID8/IGRhdHVtLm91dGVyUmFkaXVzO1xuICAgIH1cbiAgICBpZiAoc3RhdHVzID09PSBcImFkZGVkXCIgJiYgIWluaXRpYWxMb2FkKSB7XG4gICAgICBjb25zdCByYWRpaSA9IHNjYWxlVG9PbGRSYWRpdXMoZGF0dW0pO1xuICAgICAgaW5uZXJSYWRpdXMgPSByYWRpaS5pbm5lclJhZGl1cztcbiAgICAgIG91dGVyUmFkaXVzID0gcmFkaWkub3V0ZXJSYWRpdXM7XG4gICAgfVxuICAgIGlmIChzdGF0dXMgPT09IFwidXBkYXRlZFwiKSB7XG4gICAgICBmaWxsID0gc2VjdC5maWxsID8/IGZpbGw7XG4gICAgICBzdHJva2UgPSBzZWN0LnN0cm9rZSA/PyBzdHJva2U7XG4gICAgfVxuICAgIHJldHVybiB7IHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMsIGZpbGwsIHN0cm9rZSwgcGhhc2UgfTtcbiAgfTtcbiAgY29uc3QgdG9GbiA9IChfc2VjdCwgZGF0dW0sIHN0YXR1cywgeyBwcmV2TGl2ZSB9KSA9PiB7XG4gICAgbGV0IHsgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cyB9ID0gZGF0dW07XG4gICAgY29uc3QgeyBzdHJva2UsIGZpbGwgfSA9IGRhdHVtLnNlY3RvckZvcm1hdDtcbiAgICBpZiAoc3RhdHVzID09PSBcInJlbW92ZWRcIiAmJiBwcmV2TGl2ZSkge1xuICAgICAgc3RhcnRBbmdsZSA9IHByZXZMaXZlLmRhdHVtPy5lbmRBbmdsZTtcbiAgICAgIGVuZEFuZ2xlID0gcHJldkxpdmUuZGF0dW0/LmVuZEFuZ2xlO1xuICAgIH0gZWxzZSBpZiAoc3RhdHVzID09PSBcInJlbW92ZWRcIiAmJiAhcHJldkxpdmUpIHtcbiAgICAgIHN0YXJ0QW5nbGUgPSByb3RhdGlvbjtcbiAgICAgIGVuZEFuZ2xlID0gcm90YXRpb247XG4gICAgfVxuICAgIGlmIChzdGF0dXMgPT09IFwicmVtb3ZlZFwiKSB7XG4gICAgICBjb25zdCByYWRpaSA9IHNjYWxlVG9OZXdSYWRpdXMoZGF0dW0pO1xuICAgICAgaW5uZXJSYWRpdXMgPSByYWRpaS5pbm5lclJhZGl1cztcbiAgICAgIG91dGVyUmFkaXVzID0gcmFkaWkub3V0ZXJSYWRpdXM7XG4gICAgfVxuICAgIHJldHVybiB7IHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBvdXRlclJhZGl1cywgaW5uZXJSYWRpdXMsIHN0cm9rZSwgZmlsbCB9O1xuICB9O1xuICBjb25zdCBpbm5lckNpcmNsZUZyb21GbiA9IChub2RlLCBfKSA9PiB7XG4gICAgcmV0dXJuIHsgc2l6ZTogbm9kZS5wcmV2aW91c0RhdHVtPy5yYWRpdXMgPz8gbm9kZS5zaXplID8/IDAsIHBoYXNlIH07XG4gIH07XG4gIGNvbnN0IGlubmVyQ2lyY2xlVG9GbiA9IChfLCBkYXR1bSkgPT4ge1xuICAgIHJldHVybiB7IHNpemU6IGRhdHVtLnJhZGl1cyA/PyAwIH07XG4gIH07XG4gIHJldHVybiB7IG5vZGVzOiB7IHRvRm4sIGZyb21GbiB9LCBpbm5lckNpcmNsZTogeyBmcm9tRm46IGlubmVyQ2lyY2xlRnJvbUZuLCB0b0ZuOiBpbm5lckNpcmNsZVRvRm4gfSB9O1xufVxuZnVuY3Rpb24gcmVzZXRQaWVTZWxlY3Rpb25zRm4oX25vZGUsIGRhdHVtKSB7XG4gIHJldHVybiB7XG4gICAgc3RhcnRBbmdsZTogZGF0dW0uc3RhcnRBbmdsZSxcbiAgICBlbmRBbmdsZTogZGF0dW0uZW5kQW5nbGUsXG4gICAgaW5uZXJSYWRpdXM6IGRhdHVtLmlubmVyUmFkaXVzLFxuICAgIG91dGVyUmFkaXVzOiBkYXR1bS5vdXRlclJhZGl1cyxcbiAgICBmaWxsOiBkYXR1bS5zZWN0b3JGb3JtYXQuZmlsbCxcbiAgICBzdHJva2U6IGRhdHVtLnNlY3RvckZvcm1hdC5zdHJva2VcbiAgfTtcbn1cbmZ1bmN0aW9uIHBpY2tCeU1hdGNoaW5nQW5nbGUoc2VyaWVzLCBwb2ludCkge1xuICBjb25zdCBkeSA9IHBvaW50LnkgLSBzZXJpZXMuY2VudGVyWTtcbiAgY29uc3QgZHggPSBwb2ludC54IC0gc2VyaWVzLmNlbnRlclg7XG4gIGNvbnN0IGFuZ2xlMiA9IE1hdGguYXRhbjIoZHksIGR4KTtcbiAgY29uc3Qgc2VjdG9ycyA9IHNlcmllcy5nZXRJdGVtTm9kZXMoKTtcbiAgZm9yIChjb25zdCBzZWN0b3Igb2Ygc2VjdG9ycykge1xuICAgIGlmIChzZWN0b3IuZGF0dW0ubWlzc2luZyA9PT0gdHJ1ZSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIGlmIChpc0JldHdlZW5BbmdsZXMoYW5nbGUyLCBzZWN0b3Iuc3RhcnRBbmdsZSwgc2VjdG9yLmVuZEFuZ2xlKSkge1xuICAgICAgY29uc3QgcmFkaXVzID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgIGxldCBkaXN0YW5jZTMgPSAwO1xuICAgICAgaWYgKHJhZGl1cyA8IHNlY3Rvci5pbm5lclJhZGl1cykge1xuICAgICAgICBkaXN0YW5jZTMgPSBzZWN0b3IuaW5uZXJSYWRpdXMgLSByYWRpdXM7XG4gICAgICB9IGVsc2UgaWYgKHJhZGl1cyA+IHNlY3Rvci5vdXRlclJhZGl1cykge1xuICAgICAgICBkaXN0YW5jZTMgPSByYWRpdXMgLSBzZWN0b3Iub3V0ZXJSYWRpdXM7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBkYXR1bTogc2VjdG9yLmRhdHVtLCBkaXN0YW5jZTogZGlzdGFuY2UzIH07XG4gICAgfVxuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9wb2xhci9wb2xhclNlcmllcy50c1xudmFyIFBvbGFyU2VyaWVzID0gY2xhc3MgZXh0ZW5kcyBEYXRhTW9kZWxTZXJpZXMge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgdXNlTGFiZWxMYXllciA9IGZhbHNlLFxuICAgIHBpY2tNb2RlcyA9IFsxIC8qIE5FQVJFU1RfTk9ERSAqLywgMCAvKiBFWEFDVF9TSEFQRV9NQVRDSCAqL10sXG4gICAgY2FuSGF2ZUF4ZXMgPSBmYWxzZSxcbiAgICBhbmltYXRpb25SZXNldEZucyxcbiAgICAuLi5vcHRzXG4gIH0pIHtcbiAgICBzdXBlcih7XG4gICAgICAuLi5vcHRzLFxuICAgICAgdXNlTGFiZWxMYXllcixcbiAgICAgIHBpY2tNb2RlcyxcbiAgICAgIGNvbnRlbnRHcm91cFZpcnR1YWw6IGZhbHNlLFxuICAgICAgZGlyZWN0aW9uS2V5czoge1xuICAgICAgICBbXCJ4XCIgLyogWCAqL106IFtcImFuZ2xlS2V5XCJdLFxuICAgICAgICBbXCJ5XCIgLyogWSAqL106IFtcInJhZGl1c0tleVwiXVxuICAgICAgfSxcbiAgICAgIGRpcmVjdGlvbk5hbWVzOiB7XG4gICAgICAgIFtcInhcIiAvKiBYICovXTogW1wiYW5nbGVOYW1lXCJdLFxuICAgICAgICBbXCJ5XCIgLyogWSAqL106IFtcInJhZGl1c05hbWVcIl1cbiAgICAgIH0sXG4gICAgICBjYW5IYXZlQXhlc1xuICAgIH0pO1xuICAgIHRoaXMuaXRlbUdyb3VwID0gdGhpcy5jb250ZW50R3JvdXAuYXBwZW5kQ2hpbGQobmV3IEdyb3VwKCkpO1xuICAgIHRoaXMubm9kZURhdGEgPSBbXTtcbiAgICB0aGlzLml0ZW1TZWxlY3Rpb24gPSBTZWxlY3Rpb24uc2VsZWN0KFxuICAgICAgdGhpcy5pdGVtR3JvdXAsXG4gICAgICAoKSA9PiB0aGlzLm5vZGVGYWN0b3J5KCksXG4gICAgICBmYWxzZVxuICAgICk7XG4gICAgdGhpcy5sYWJlbFNlbGVjdGlvbiA9IFNlbGVjdGlvbi5zZWxlY3QoXG4gICAgICB0aGlzLmxhYmVsR3JvdXAsXG4gICAgICAoKSA9PiB0aGlzLmxhYmVsRmFjdG9yeSgpLFxuICAgICAgZmFsc2VcbiAgICApO1xuICAgIHRoaXMuaGlnaGxpZ2h0U2VsZWN0aW9uID0gU2VsZWN0aW9uLnNlbGVjdChcbiAgICAgIHRoaXMuaGlnaGxpZ2h0R3JvdXAsXG4gICAgICAoKSA9PiB0aGlzLm5vZGVGYWN0b3J5KClcbiAgICApO1xuICAgIHRoaXMuaGlnaGxpZ2h0TGFiZWxTZWxlY3Rpb24gPSBTZWxlY3Rpb24uc2VsZWN0KFxuICAgICAgdGhpcy5oaWdobGlnaHRMYWJlbCxcbiAgICAgICgpID0+IHRoaXMubGFiZWxGYWN0b3J5KClcbiAgICApO1xuICAgIC8qKlxuICAgICAqIFRoZSBjZW50ZXIgb2YgdGhlIHBvbGFyIHNlcmllcyAoZm9yIGV4YW1wbGUsIHRoZSBjZW50ZXIgb2YgYSBwaWUpLlxuICAgICAqIElmIHRoZSBwb2xhciBjaGFydCBoYXMgbXVsdGlwbGUgc2VyaWVzLCBhbGwgb2YgdGhlbSB3aWxsIGhhdmUgdGhlaXJcbiAgICAgKiBjZW50ZXIgc2V0IHRvIHRoZSBzYW1lIHZhbHVlIGFzIGEgcmVzdWx0IG9mIHRoZSBwb2xhciBjaGFydCBsYXlvdXQuXG4gICAgICogVGhlIGNlbnRlciBjb29yZGluYXRlcyBhcmUgbm90IHN1cHBvc2VkIHRvIGJlIHNldCBieSB0aGUgdXNlci5cbiAgICAgKi9cbiAgICB0aGlzLmNlbnRlclggPSAwO1xuICAgIHRoaXMuY2VudGVyWSA9IDA7XG4gICAgLyoqXG4gICAgICogVGhlIG1heGltdW0gcmFkaXVzIHRoZSBzZXJpZXMgY2FuIHVzZS5cbiAgICAgKiBUaGlzIHZhbHVlIGlzIHNldCBhdXRvbWF0aWNhbGx5IGFzIGEgcmVzdWx0IG9mIHRoZSBwb2xhciBjaGFydCBsYXlvdXRcbiAgICAgKiBhbmQgaXMgbm90IHN1cHBvc2VkIHRvIGJlIHNldCBieSB0aGUgdXNlci5cbiAgICAgKi9cbiAgICB0aGlzLnJhZGl1cyA9IDA7XG4gICAgdGhpcy5pdGVtR3JvdXAuekluZGV4U3ViT3JkZXIgPSBbKCkgPT4gdGhpcy5fZGVjbGFyYXRpb25PcmRlciwgMV07XG4gICAgdGhpcy5hbmltYXRpb25SZXNldEZucyA9IGFuaW1hdGlvblJlc2V0Rm5zO1xuICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUgPSBuZXcgU3RhdGVNYWNoaW5lKFxuICAgICAgXCJlbXB0eVwiLFxuICAgICAge1xuICAgICAgICBlbXB0eToge1xuICAgICAgICAgIHVwZGF0ZToge1xuICAgICAgICAgICAgdGFyZ2V0OiBcInJlYWR5XCIsXG4gICAgICAgICAgICBhY3Rpb246IChkYXRhKSA9PiB0aGlzLmFuaW1hdGVFbXB0eVVwZGF0ZVJlYWR5KGRhdGEpXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXNldDogXCJlbXB0eVwiLFxuICAgICAgICAgIHNraXA6IFwicmVhZHlcIlxuICAgICAgICB9LFxuICAgICAgICByZWFkeToge1xuICAgICAgICAgIHVwZGF0ZURhdGE6IFwid2FpdGluZ1wiLFxuICAgICAgICAgIGNsZWFyOiBcImNsZWFyaW5nXCIsXG4gICAgICAgICAgaGlnaGxpZ2h0OiAoZGF0YSkgPT4gdGhpcy5hbmltYXRlUmVhZHlIaWdobGlnaHQoZGF0YSksXG4gICAgICAgICAgaGlnaGxpZ2h0TWFya2VyczogKGRhdGEpID0+IHRoaXMuYW5pbWF0ZVJlYWR5SGlnaGxpZ2h0TWFya2VycyhkYXRhKSxcbiAgICAgICAgICByZXNpemU6IChkYXRhKSA9PiB0aGlzLmFuaW1hdGVSZWFkeVJlc2l6ZShkYXRhKSxcbiAgICAgICAgICByZXNldDogXCJlbXB0eVwiLFxuICAgICAgICAgIHNraXA6IFwicmVhZHlcIlxuICAgICAgICB9LFxuICAgICAgICB3YWl0aW5nOiB7XG4gICAgICAgICAgdXBkYXRlOiB7XG4gICAgICAgICAgICB0YXJnZXQ6IFwicmVhZHlcIixcbiAgICAgICAgICAgIGFjdGlvbjogKGRhdGEpID0+IHRoaXMuYW5pbWF0ZVdhaXRpbmdVcGRhdGVSZWFkeShkYXRhKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVzZXQ6IFwiZW1wdHlcIixcbiAgICAgICAgICBza2lwOiBcInJlYWR5XCJcbiAgICAgICAgfSxcbiAgICAgICAgY2xlYXJpbmc6IHtcbiAgICAgICAgICB1cGRhdGU6IHtcbiAgICAgICAgICAgIHRhcmdldDogXCJlbXB0eVwiLFxuICAgICAgICAgICAgYWN0aW9uOiAoZGF0YSkgPT4gdGhpcy5hbmltYXRlQ2xlYXJpbmdVcGRhdGVFbXB0eShkYXRhKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVzZXQ6IFwiZW1wdHlcIixcbiAgICAgICAgICBza2lwOiBcInJlYWR5XCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgICgpID0+IHRoaXMuY2hlY2tQcm9jZXNzZWREYXRhQW5pbWF0YWJsZSgpXG4gICAgKTtcbiAgfVxuICBnZXRJdGVtTm9kZXMoKSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLml0ZW1Hcm91cC5jaGlsZHJlbigpXTtcbiAgfVxuICBnZXROb2RlRGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlRGF0YTtcbiAgfVxuICByZXNldEFuaW1hdGlvbihwaGFzZSkge1xuICAgIGlmIChwaGFzZSA9PT0gXCJpbml0aWFsXCIpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcInJlc2V0XCIpO1xuICAgIH0gZWxzZSBpZiAocGhhc2UgPT09IFwicmVhZHlcIikge1xuICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwic2tpcFwiKTtcbiAgICB9XG4gIH1cbiAgbGFiZWxGYWN0b3J5KCkge1xuICAgIGNvbnN0IHRleHQgPSBuZXcgVGV4dCgpO1xuICAgIHRleHQucG9pbnRlckV2ZW50cyA9IDEgLyogTm9uZSAqLztcbiAgICByZXR1cm4gdGV4dDtcbiAgfVxuICBnZXRJbm5lclJhZGl1cygpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBnZXRMYWJlbERhdGEoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGNvbXB1dGVMYWJlbHNCQm94KF9vcHRpb25zLCBfc2VyaWVzUmVjdCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJlc2V0QWxsQW5pbWF0aW9uKCkge1xuICAgIGNvbnN0IHsgaXRlbSwgbGFiZWwgfSA9IHRoaXMuYW5pbWF0aW9uUmVzZXRGbnMgPz8ge307XG4gICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5zdG9wQnlBbmltYXRpb25Hcm91cElkKHRoaXMuaWQpO1xuICAgIGlmIChpdGVtKSB7XG4gICAgICByZXNldE1vdGlvbihbdGhpcy5pdGVtU2VsZWN0aW9uLCB0aGlzLmhpZ2hsaWdodFNlbGVjdGlvbl0sIGl0ZW0pO1xuICAgIH1cbiAgICBpZiAobGFiZWwpIHtcbiAgICAgIHJlc2V0TW90aW9uKFt0aGlzLmxhYmVsU2VsZWN0aW9uLCB0aGlzLmhpZ2hsaWdodExhYmVsU2VsZWN0aW9uXSwgbGFiZWwpO1xuICAgIH1cbiAgICB0aGlzLml0ZW1TZWxlY3Rpb24uY2xlYW51cCgpO1xuICAgIHRoaXMubGFiZWxTZWxlY3Rpb24uY2xlYW51cCgpO1xuICAgIHRoaXMuaGlnaGxpZ2h0U2VsZWN0aW9uLmNsZWFudXAoKTtcbiAgICB0aGlzLmhpZ2hsaWdodExhYmVsU2VsZWN0aW9uLmNsZWFudXAoKTtcbiAgfVxuICBhbmltYXRlRW1wdHlVcGRhdGVSZWFkeShfZGF0YSkge1xuICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuc2tpcEN1cnJlbnRCYXRjaCgpO1xuICAgIHRoaXMucmVzZXRBbGxBbmltYXRpb24oKTtcbiAgfVxuICBhbmltYXRlV2FpdGluZ1VwZGF0ZVJlYWR5KF9kYXRhKSB7XG4gICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5za2lwQ3VycmVudEJhdGNoKCk7XG4gICAgdGhpcy5yZXNldEFsbEFuaW1hdGlvbigpO1xuICB9XG4gIGFuaW1hdGVSZWFkeUhpZ2hsaWdodChfZGF0YSkge1xuICAgIGNvbnN0IHsgaXRlbSwgbGFiZWwgfSA9IHRoaXMuYW5pbWF0aW9uUmVzZXRGbnMgPz8ge307XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIHJlc2V0TW90aW9uKFt0aGlzLmhpZ2hsaWdodFNlbGVjdGlvbl0sIGl0ZW0pO1xuICAgIH1cbiAgICBpZiAobGFiZWwpIHtcbiAgICAgIHJlc2V0TW90aW9uKFt0aGlzLmhpZ2hsaWdodExhYmVsU2VsZWN0aW9uXSwgbGFiZWwpO1xuICAgIH1cbiAgfVxuICBhbmltYXRlUmVhZHlIaWdobGlnaHRNYXJrZXJzKF9kYXRhKSB7XG4gIH1cbiAgYW5pbWF0ZVJlYWR5UmVzaXplKF9kYXRhKSB7XG4gICAgdGhpcy5yZXNldEFsbEFuaW1hdGlvbigpO1xuICB9XG4gIGFuaW1hdGVDbGVhcmluZ1VwZGF0ZUVtcHR5KF9kYXRhKSB7XG4gICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5za2lwQ3VycmVudEJhdGNoKCk7XG4gICAgdGhpcy5yZXNldEFsbEFuaW1hdGlvbigpO1xuICB9XG4gIGFuaW1hdGlvblRyYW5zaXRpb25DbGVhcigpIHtcbiAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJjbGVhclwiLCB0aGlzLmdldEFuaW1hdGlvbkRhdGEoKSk7XG4gIH1cbiAgZ2V0QW5pbWF0aW9uRGF0YShzZXJpZXNSZWN0KSB7XG4gICAgcmV0dXJuIHsgc2VyaWVzUmVjdCB9O1xuICB9XG4gIGNvbXB1dGVGb2N1c0JvdW5kcyhvcHRzKSB7XG4gICAgY29uc3QgZGF0dW0gPSB0aGlzLmdldE5vZGVEYXRhKCk/LltvcHRzLmRhdHVtSW5kZXhdO1xuICAgIGlmIChkYXR1bSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5pdGVtU2VsZWN0aW9uLnNlbGVjdCgobm9kZSkgPT4gbm9kZSBpbnN0YW5jZW9mIFBhdGggJiYgbm9kZS5kYXR1bSA9PT0gZGF0dW0pWzBdO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvcG9sYXIvZG9udXRTZXJpZXMudHNcbnZhciBEb251dFNlcmllc05vZGVFdmVudCA9IGNsYXNzIGV4dGVuZHMgU2VyaWVzTm9kZUV2ZW50IHtcbiAgY29uc3RydWN0b3IodHlwZSwgbmF0aXZlRXZlbnQsIGRhdHVtLCBzZXJpZXMpIHtcbiAgICBzdXBlcih0eXBlLCBuYXRpdmVFdmVudCwgZGF0dW0sIHNlcmllcyk7XG4gICAgdGhpcy5hbmdsZUtleSA9IHNlcmllcy5wcm9wZXJ0aWVzLmFuZ2xlS2V5O1xuICAgIHRoaXMucmFkaXVzS2V5ID0gc2VyaWVzLnByb3BlcnRpZXMucmFkaXVzS2V5O1xuICAgIHRoaXMuY2FsbG91dExhYmVsS2V5ID0gc2VyaWVzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsS2V5O1xuICAgIHRoaXMuc2VjdG9yTGFiZWxLZXkgPSBzZXJpZXMucHJvcGVydGllcy5zZWN0b3JMYWJlbEtleTtcbiAgfVxufTtcbnZhciBEb251dFNlcmllcyA9IGNsYXNzIGV4dGVuZHMgUG9sYXJTZXJpZXMge1xuICBjb25zdHJ1Y3Rvcihtb2R1bGVDdHgpIHtcbiAgICBzdXBlcih7XG4gICAgICBtb2R1bGVDdHgsXG4gICAgICBwaWNrTW9kZXM6IFsxIC8qIE5FQVJFU1RfTk9ERSAqLywgMCAvKiBFWEFDVF9TSEFQRV9NQVRDSCAqL10sXG4gICAgICB1c2VMYWJlbExheWVyOiB0cnVlLFxuICAgICAgYW5pbWF0aW9uUmVzZXRGbnM6IHsgaXRlbTogcmVzZXRQaWVTZWxlY3Rpb25zRm4sIGxhYmVsOiByZXNldExhYmVsRm4gfVxuICAgIH0pO1xuICAgIHRoaXMucHJvcGVydGllcyA9IG5ldyBEb251dFNlcmllc1Byb3BlcnRpZXMoKTtcbiAgICB0aGlzLnBoYW50b21Ob2RlRGF0YSA9IHZvaWQgMDtcbiAgICB0aGlzLnByZXZpb3VzUmFkaXVzU2NhbGUgPSBuZXcgTGluZWFyU2NhbGUoKTtcbiAgICB0aGlzLnJhZGl1c1NjYWxlID0gbmV3IExpbmVhclNjYWxlKCk7XG4gICAgdGhpcy5waGFudG9tR3JvdXAgPSB0aGlzLmNvbnRlbnRHcm91cC5hcHBlbmRDaGlsZChuZXcgR3JvdXAoKSk7XG4gICAgdGhpcy5waGFudG9tU2VsZWN0aW9uID0gU2VsZWN0aW9uLnNlbGVjdChcbiAgICAgIHRoaXMucGhhbnRvbUdyb3VwLFxuICAgICAgKCkgPT4gdGhpcy5ub2RlRmFjdG9yeSgpLFxuICAgICAgZmFsc2VcbiAgICApO1xuICAgIHRoaXMuY2FsbG91dExhYmVsR3JvdXAgPSB0aGlzLmNvbnRlbnRHcm91cC5hcHBlbmRDaGlsZChuZXcgR3JvdXAoeyBuYW1lOiBcInBpZUNhbGxvdXRMYWJlbHNcIiB9KSk7XG4gICAgdGhpcy5jYWxsb3V0TGFiZWxTZWxlY3Rpb24gPSBuZXcgU2VsZWN0aW9uKFxuICAgICAgdGhpcy5jYWxsb3V0TGFiZWxHcm91cCxcbiAgICAgIEdyb3VwXG4gICAgKTtcbiAgICAvLyBUaGUgZ3JvdXAgbm9kZSB0aGF0IGNvbnRhaW5zIHRoZSBiYWNrZ3JvdW5kIGdyYXBoaWNzLlxuICAgIHRoaXMuYmFja2dyb3VuZEdyb3VwID0gdGhpcy5yb290R3JvdXAuYXBwZW5kQ2hpbGQoXG4gICAgICBuZXcgVHJhbnNsYXRhYmxlTGF5ZXIoe1xuICAgICAgICBuYW1lOiBgJHt0aGlzLmlkfS1iYWNrZ3JvdW5kYCxcbiAgICAgICAgekluZGV4OiAwIC8qIFNFUklFU19CQUNLR1JPVU5EICovXG4gICAgICB9KVxuICAgICk7XG4gICAgLy8gQUctNjE5MyBJZiB0aGUgc3VtIG9mIGFsbCBkYXR1bXMgaXMgMCwgdGhlbiB3ZSdsbCBkcmF3IDEgb3IgMiByaW5ncyB0byByZXByZXNlbnQgdGhlIGVtcHR5IHNlcmllcy5cbiAgICB0aGlzLnplcm9zdW1SaW5nc0dyb3VwID0gdGhpcy5iYWNrZ3JvdW5kR3JvdXAuYXBwZW5kQ2hpbGQobmV3IEdyb3VwKHsgbmFtZTogYCR7dGhpcy5pZH0temVyb3N1bVJpbmdzYCB9KSk7XG4gICAgdGhpcy56ZXJvc3VtT3V0ZXJSaW5nID0gdGhpcy56ZXJvc3VtUmluZ3NHcm91cC5hcHBlbmRDaGlsZChuZXcgQ2lyY2xlKCkpO1xuICAgIHRoaXMuemVyb3N1bUlubmVyUmluZyA9IHRoaXMuemVyb3N1bVJpbmdzR3JvdXAuYXBwZW5kQ2hpbGQobmV3IENpcmNsZSgpKTtcbiAgICB0aGlzLmlubmVyTGFiZWxzR3JvdXAgPSB0aGlzLmNvbnRlbnRHcm91cC5hcHBlbmRDaGlsZChuZXcgR3JvdXAoeyBuYW1lOiBcImlubmVyTGFiZWxzXCIgfSkpO1xuICAgIHRoaXMuaW5uZXJDaXJjbGVHcm91cCA9IHRoaXMuYmFja2dyb3VuZEdyb3VwLmFwcGVuZENoaWxkKG5ldyBHcm91cCh7IG5hbWU6IGAke3RoaXMuaWR9LWlubmVyQ2lyY2xlYCB9KSk7XG4gICAgdGhpcy5pbm5lckxhYmVsc1NlbGVjdGlvbiA9IFNlbGVjdGlvbi5zZWxlY3QodGhpcy5pbm5lckxhYmVsc0dyb3VwLCBUZXh0KTtcbiAgICB0aGlzLmlubmVyQ2lyY2xlU2VsZWN0aW9uID0gU2VsZWN0aW9uLnNlbGVjdChcbiAgICAgIHRoaXMuaW5uZXJDaXJjbGVHcm91cCxcbiAgICAgIENpcmNsZVxuICAgICk7XG4gICAgLy8gV2hlbiBhIHVzZXIgdG9nZ2xlcyBhIHNlcmllcyBpdGVtIChlLmcuIGZyb20gdGhlIGxlZ2VuZCksIGl0cyBib29sZWFuIHN0YXRlIGlzIHJlY29yZGVkIGhlcmUuXG4gICAgdGhpcy5zZXJpZXNJdGVtRW5hYmxlZCA9IFtdO1xuICAgIHRoaXMubGVnZW5kSXRlbUVuYWJsZWQgPSBbXTtcbiAgICB0aGlzLnN1cnJvdW5kaW5nUmFkaXVzID0gdm9pZCAwO1xuICAgIHRoaXMuTm9kZUV2ZW50ID0gRG9udXRTZXJpZXNOb2RlRXZlbnQ7XG4gICAgdGhpcy5hbmdsZVNjYWxlID0gbmV3IExpbmVhclNjYWxlKCk7XG4gICAgdGhpcy5hbmdsZVNjYWxlLmRvbWFpbiA9IFswLCAxXTtcbiAgICB0aGlzLmFuZ2xlU2NhbGUucmFuZ2UgPSBbLU1hdGguUEksIE1hdGguUEldLm1hcCgoYW5nbGUyKSA9PiBhbmdsZTIgKyBNYXRoLlBJIC8gMik7XG4gICAgdGhpcy5waGFudG9tR3JvdXAub3BhY2l0eSA9IDAuMjtcbiAgICB0aGlzLnBoYW50b21Hcm91cC56SW5kZXhTdWJPcmRlciA9IFsoKSA9PiB0aGlzLl9kZWNsYXJhdGlvbk9yZGVyLCAwXTtcbiAgfVxuICBnZXQgY2FsbG91dE5vZGVEYXRhKCkge1xuICAgIHJldHVybiB0aGlzLnBoYW50b21Ob2RlRGF0YSA/PyB0aGlzLm5vZGVEYXRhO1xuICB9XG4gIGFkZENoYXJ0RXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5kZXN0cm95Rm5zLnB1c2goXG4gICAgICB0aGlzLmN0eC5jaGFydEV2ZW50TWFuYWdlcj8uYWRkTGlzdGVuZXIoXCJsZWdlbmQtaXRlbS1jbGlja1wiLCAoZXZlbnQpID0+IHRoaXMub25MZWdlbmRJdGVtQ2xpY2soZXZlbnQpKVxuICAgICk7XG4gIH1cbiAgZ2V0IHZpc2libGUoKSB7XG4gICAgcmV0dXJuIHN1cGVyLnZpc2libGUgJiYgKHRoaXMuc2VyaWVzSXRlbUVuYWJsZWQubGVuZ3RoID09PSAwIHx8IHRoaXMuc2VyaWVzSXRlbUVuYWJsZWQuaW5jbHVkZXModHJ1ZSkpO1xuICB9XG4gIG5vZGVGYWN0b3J5KCkge1xuICAgIHJldHVybiBuZXcgU2VjdG9yKCk7XG4gIH1cbiAgZ2V0U2VyaWVzRG9tYWluKGRpcmVjdGlvbikge1xuICAgIGlmIChkaXJlY3Rpb24gPT09IFwieFwiIC8qIFggKi8pIHtcbiAgICAgIHJldHVybiB0aGlzLmFuZ2xlU2NhbGUuZG9tYWluO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5yYWRpdXNTY2FsZS5kb21haW47XG4gICAgfVxuICB9XG4gIGFzeW5jIHByb2Nlc3NEYXRhKGRhdGFDb250cm9sbGVyKSB7XG4gICAgaWYgKHRoaXMuZGF0YSA9PSBudWxsIHx8ICF0aGlzLnByb3BlcnRpZXMuaXNWYWxpZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCB7IGRhdGEgfSA9IHRoaXM7XG4gICAgY29uc3QgeyB2aXNpYmxlLCBzZXJpZXNJdGVtRW5hYmxlZCB9ID0gdGhpcztcbiAgICBjb25zdCB7IGFuZ2xlS2V5LCBhbmdsZUZpbHRlcktleSwgcmFkaXVzS2V5LCBjYWxsb3V0TGFiZWxLZXksIHNlY3RvckxhYmVsS2V5LCBsZWdlbmRJdGVtS2V5IH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgYW5pbWF0aW9uRW5hYmxlZCA9ICF0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLmlzU2tpcHBlZCgpO1xuICAgIGNvbnN0IGV4dHJhS2V5UHJvcHMgPSBbXTtcbiAgICBjb25zdCBleHRyYVByb3BzID0gW107XG4gICAgaWYgKGxlZ2VuZEl0ZW1LZXkpIHtcbiAgICAgIGV4dHJhS2V5UHJvcHMucHVzaChrZXlQcm9wZXJ0eShsZWdlbmRJdGVtS2V5LCBcImJhbmRcIiwgeyBpZDogYGxlZ2VuZEl0ZW1LZXlgIH0pKTtcbiAgICB9IGVsc2UgaWYgKGNhbGxvdXRMYWJlbEtleSkge1xuICAgICAgZXh0cmFLZXlQcm9wcy5wdXNoKGtleVByb3BlcnR5KGNhbGxvdXRMYWJlbEtleSwgXCJiYW5kXCIsIHsgaWQ6IGBjYWxsb3V0TGFiZWxLZXlgIH0pKTtcbiAgICB9IGVsc2UgaWYgKHNlY3RvckxhYmVsS2V5KSB7XG4gICAgICBleHRyYUtleVByb3BzLnB1c2goa2V5UHJvcGVydHkoc2VjdG9yTGFiZWxLZXksIFwiYmFuZFwiLCB7IGlkOiBgc2VjdG9yTGFiZWxLZXlgIH0pKTtcbiAgICB9XG4gICAgY29uc3QgcmFkaXVzU2NhbGVUeXBlID0gdGhpcy5yYWRpdXNTY2FsZS50eXBlO1xuICAgIGNvbnN0IGFuZ2xlU2NhbGVUeXBlID0gdGhpcy5yYWRpdXNTY2FsZS50eXBlO1xuICAgIGlmIChyYWRpdXNLZXkpIHtcbiAgICAgIGV4dHJhUHJvcHMucHVzaChcbiAgICAgICAgcmFuZ2VkVmFsdWVQcm9wZXJ0eShyYWRpdXNLZXksIHtcbiAgICAgICAgICBpZDogXCJyYWRpdXNWYWx1ZVwiLFxuICAgICAgICAgIG1pbjogdGhpcy5wcm9wZXJ0aWVzLnJhZGl1c01pbiA/PyAwLFxuICAgICAgICAgIG1heDogdGhpcy5wcm9wZXJ0aWVzLnJhZGl1c01heFxuICAgICAgICB9KSxcbiAgICAgICAgdmFsdWVQcm9wZXJ0eShyYWRpdXNLZXksIHJhZGl1c1NjYWxlVHlwZSwgeyBpZDogYHJhZGl1c1Jhd2AgfSksXG4gICAgICAgIC8vIFJhdyB2YWx1ZSBwYXNzLXRocm91Z2guXG4gICAgICAgIG5vcm1hbGlzZVByb3BlcnR5VG8oXCJyYWRpdXNWYWx1ZVwiLCBbMCwgMV0sIDEsIHRoaXMucHJvcGVydGllcy5yYWRpdXNNaW4gPz8gMCwgdGhpcy5wcm9wZXJ0aWVzLnJhZGl1c01heClcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChjYWxsb3V0TGFiZWxLZXkpIHtcbiAgICAgIGV4dHJhUHJvcHMucHVzaCh2YWx1ZVByb3BlcnR5KGNhbGxvdXRMYWJlbEtleSwgXCJiYW5kXCIsIHsgaWQ6IGBjYWxsb3V0TGFiZWxWYWx1ZWAgfSkpO1xuICAgIH1cbiAgICBpZiAoc2VjdG9yTGFiZWxLZXkpIHtcbiAgICAgIGV4dHJhUHJvcHMucHVzaCh2YWx1ZVByb3BlcnR5KHNlY3RvckxhYmVsS2V5LCBcImJhbmRcIiwgeyBpZDogYHNlY3RvckxhYmVsVmFsdWVgIH0pKTtcbiAgICB9XG4gICAgaWYgKGxlZ2VuZEl0ZW1LZXkpIHtcbiAgICAgIGV4dHJhUHJvcHMucHVzaCh2YWx1ZVByb3BlcnR5KGxlZ2VuZEl0ZW1LZXksIFwiYmFuZFwiLCB7IGlkOiBgbGVnZW5kSXRlbVZhbHVlYCB9KSk7XG4gICAgfVxuICAgIGlmIChhbmdsZUZpbHRlcktleSkge1xuICAgICAgZXh0cmFQcm9wcy5wdXNoKFxuICAgICAgICBhY2N1bXVsYXRpdmVWYWx1ZVByb3BlcnR5KGFuZ2xlRmlsdGVyS2V5LCBhbmdsZVNjYWxlVHlwZSwge1xuICAgICAgICAgIGlkOiBgYW5nbGVGaWx0ZXJWYWx1ZWAsXG4gICAgICAgICAgb25seVBvc2l0aXZlOiB0cnVlXG4gICAgICAgIH0pLFxuICAgICAgICB2YWx1ZVByb3BlcnR5KGFuZ2xlRmlsdGVyS2V5LCBhbmdsZVNjYWxlVHlwZSwgeyBpZDogYGFuZ2xlRmlsdGVyUmF3YCB9KSxcbiAgICAgICAgbm9ybWFsaXNlUHJvcGVydHlUbyhcImFuZ2xlRmlsdGVyVmFsdWVcIiwgWzAsIDFdLCAwLCAwKVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGFuaW1hdGlvbkVuYWJsZWQgJiYgdGhpcy5wcm9jZXNzZWREYXRhICYmIGV4dHJhS2V5UHJvcHMubGVuZ3RoID4gMCkge1xuICAgICAgZXh0cmFQcm9wcy5wdXNoKGRpZmYodGhpcy5wcm9jZXNzZWREYXRhKSk7XG4gICAgfVxuICAgIGV4dHJhUHJvcHMucHVzaChhbmltYXRpb25WYWxpZGF0aW9uKCkpO1xuICAgIGRhdGEgPSBkYXRhLm1hcCgoZCwgaWR4KSA9PiB2aXNpYmxlICYmIHNlcmllc0l0ZW1FbmFibGVkW2lkeF0gPyBkIDogeyAuLi5kLCBbYW5nbGVLZXldOiAwIH0pO1xuICAgIGF3YWl0IHRoaXMucmVxdWVzdERhdGFNb2RlbChkYXRhQ29udHJvbGxlciwgZGF0YSwge1xuICAgICAgcHJvcHM6IFtcbiAgICAgICAgLi4uZXh0cmFLZXlQcm9wcyxcbiAgICAgICAgYWNjdW11bGF0aXZlVmFsdWVQcm9wZXJ0eShhbmdsZUtleSwgYW5nbGVTY2FsZVR5cGUsIHsgaWQ6IGBhbmdsZVZhbHVlYCwgb25seVBvc2l0aXZlOiB0cnVlIH0pLFxuICAgICAgICB2YWx1ZVByb3BlcnR5KGFuZ2xlS2V5LCBhbmdsZVNjYWxlVHlwZSwgeyBpZDogYGFuZ2xlUmF3YCB9KSxcbiAgICAgICAgLy8gUmF3IHZhbHVlIHBhc3MtdGhyb3VnaC5cbiAgICAgICAgbm9ybWFsaXNlUHJvcGVydHlUbyhcImFuZ2xlVmFsdWVcIiwgWzAsIDFdLCAwLCAwKSxcbiAgICAgICAgLi4uZXh0cmFQcm9wc1xuICAgICAgXVxuICAgIH0pO1xuICAgIGZvciAoY29uc3QgdmFsdWVEZWYgb2YgdGhpcy5wcm9jZXNzZWREYXRhPy5kZWZzPy52YWx1ZXMgPz8gW10pIHtcbiAgICAgIGNvbnN0IHsgaWQsIG1pc3NpbmcsIHByb3BlcnR5IH0gPSB2YWx1ZURlZjtcbiAgICAgIGNvbnN0IG1pc3NDb3VudCA9IGdldE1pc3NDb3VudCh0aGlzLCBtaXNzaW5nKTtcbiAgICAgIGlmIChpZCAhPT0gXCJhbmdsZVJhd1wiICYmIG1pc3NDb3VudCA+IDApIHtcbiAgICAgICAgTG9nZ2VyLndhcm5PbmNlKFxuICAgICAgICAgIGBubyB2YWx1ZSB3YXMgZm91bmQgZm9yIHRoZSBrZXkgJyR7U3RyaW5nKHByb3BlcnR5KX0nIG9uICR7bWlzc0NvdW50fSBkYXRhIGVsZW1lbnQke21pc3NDb3VudCA+IDEgPyBcInNcIiA6IFwiXCJ9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJ1cGRhdGVEYXRhXCIpO1xuICB9XG4gIGFzeW5jIG1heWJlUmVmcmVzaE5vZGVEYXRhKCkge1xuICAgIGlmICghdGhpcy5ub2RlRGF0YVJlZnJlc2gpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBub2RlRGF0YSA9IFtdLCBwaGFudG9tTm9kZURhdGEgfSA9IGF3YWl0IHRoaXMuY3JlYXRlTm9kZURhdGEoKSA/PyB7fTtcbiAgICB0aGlzLm5vZGVEYXRhID0gbm9kZURhdGE7XG4gICAgdGhpcy5waGFudG9tTm9kZURhdGEgPSBwaGFudG9tTm9kZURhdGE7XG4gICAgdGhpcy5ub2RlRGF0YVJlZnJlc2ggPSBmYWxzZTtcbiAgfVxuICBnZXRQcm9jZXNzZWREYXRhSW5kZXhlcyhkYXRhTW9kZWwpIHtcbiAgICBjb25zdCBhbmdsZUlkeCA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgYW5nbGVWYWx1ZWApO1xuICAgIGNvbnN0IGFuZ2xlUmF3SWR4ID0gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGBhbmdsZVJhd2ApO1xuICAgIGNvbnN0IGFuZ2xlRmlsdGVySWR4ID0gdGhpcy5wcm9wZXJ0aWVzLmFuZ2xlRmlsdGVyS2V5ICE9IG51bGwgPyBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYGFuZ2xlRmlsdGVyVmFsdWVgKSA6IHZvaWQgMDtcbiAgICBjb25zdCBhbmdsZUZpbHRlclJhd0lkeCA9IHRoaXMucHJvcGVydGllcy5hbmdsZUZpbHRlcktleSAhPSBudWxsID8gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGBhbmdsZUZpbHRlclJhd2ApIDogdm9pZCAwO1xuICAgIGNvbnN0IHJhZGl1c0lkeCA9IHRoaXMucHJvcGVydGllcy5yYWRpdXNLZXkgPyBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYHJhZGl1c1ZhbHVlYCkgOiB2b2lkIDA7XG4gICAgY29uc3QgcmFkaXVzUmF3SWR4ID0gdGhpcy5wcm9wZXJ0aWVzLnJhZGl1c0tleSA/IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgcmFkaXVzUmF3YCkgOiB2b2lkIDA7XG4gICAgY29uc3QgY2FsbG91dExhYmVsSWR4ID0gdGhpcy5wcm9wZXJ0aWVzLmNhbGxvdXRMYWJlbEtleSA/IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgY2FsbG91dExhYmVsVmFsdWVgKSA6IHZvaWQgMDtcbiAgICBjb25zdCBzZWN0b3JMYWJlbElkeCA9IHRoaXMucHJvcGVydGllcy5zZWN0b3JMYWJlbEtleSA/IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgc2VjdG9yTGFiZWxWYWx1ZWApIDogdm9pZCAwO1xuICAgIGNvbnN0IGxlZ2VuZEl0ZW1JZHggPSB0aGlzLnByb3BlcnRpZXMubGVnZW5kSXRlbUtleSA/IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgbGVnZW5kSXRlbVZhbHVlYCkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFuZ2xlSWR4LFxuICAgICAgYW5nbGVSYXdJZHgsXG4gICAgICBhbmdsZUZpbHRlcklkeCxcbiAgICAgIGFuZ2xlRmlsdGVyUmF3SWR4LFxuICAgICAgcmFkaXVzSWR4LFxuICAgICAgcmFkaXVzUmF3SWR4LFxuICAgICAgY2FsbG91dExhYmVsSWR4LFxuICAgICAgc2VjdG9yTGFiZWxJZHgsXG4gICAgICBsZWdlbmRJdGVtSWR4XG4gICAgfTtcbiAgfVxuICBhc3luYyBjcmVhdGVOb2RlRGF0YSgpIHtcbiAgICBjb25zdCB7IGlkOiBzZXJpZXNJZCwgcHJvY2Vzc2VkRGF0YSwgZGF0YU1vZGVsLCBhbmdsZVNjYWxlIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgcm90YXRpb24sIGlubmVyUmFkaXVzUmF0aW8gfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBpZiAoIXRoaXMucHJvcGVydGllcy5pc1ZhbGlkKCkpIHtcbiAgICAgIHRoaXMuemVyb3N1bU91dGVyUmluZy52aXNpYmxlID0gdHJ1ZTtcbiAgICAgIHRoaXMuemVyb3N1bUlubmVyUmluZy52aXNpYmxlID0gdHJ1ZTtcbiAgICAgIHJldHVybiB7IGl0ZW1JZDogc2VyaWVzSWQsIG5vZGVEYXRhOiBbXSwgbGFiZWxEYXRhOiBbXSB9O1xuICAgIH1cbiAgICBpZiAoIXByb2Nlc3NlZERhdGEgfHwgIWRhdGFNb2RlbCB8fCBwcm9jZXNzZWREYXRhLnR5cGUgIT09IFwidW5ncm91cGVkXCIpXG4gICAgICByZXR1cm47XG4gICAgY29uc3Qge1xuICAgICAgYW5nbGVJZHgsXG4gICAgICBhbmdsZVJhd0lkeCxcbiAgICAgIGFuZ2xlRmlsdGVySWR4LFxuICAgICAgYW5nbGVGaWx0ZXJSYXdJZHgsXG4gICAgICByYWRpdXNJZHgsXG4gICAgICByYWRpdXNSYXdJZHgsXG4gICAgICBjYWxsb3V0TGFiZWxJZHgsXG4gICAgICBzZWN0b3JMYWJlbElkeCxcbiAgICAgIGxlZ2VuZEl0ZW1JZHhcbiAgICB9ID0gdGhpcy5nZXRQcm9jZXNzZWREYXRhSW5kZXhlcyhkYXRhTW9kZWwpO1xuICAgIGNvbnN0IHVzZUZpbHRlckFuZ2xlcyA9IGFuZ2xlRmlsdGVyUmF3SWR4ICE9IG51bGwgJiYgcHJvY2Vzc2VkRGF0YS5kYXRhLnNvbWUoKHsgdmFsdWVzIH0pID0+IHtcbiAgICAgIHJldHVybiB2YWx1ZXNbYW5nbGVGaWx0ZXJSYXdJZHhdID4gdmFsdWVzW2FuZ2xlUmF3SWR4XTtcbiAgICB9KTtcbiAgICBsZXQgY3VycmVudFN0YXJ0ID0gMDtcbiAgICBsZXQgc3VtMiA9IDA7XG4gICAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgICBjb25zdCBwaGFudG9tTm9kZXMgPSBhbmdsZUZpbHRlclJhd0lkeCAhPSBudWxsID8gW10gOiB2b2lkIDA7XG4gICAgcHJvY2Vzc2VkRGF0YS5kYXRhLmZvckVhY2goKGdyb3VwLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgeyBkYXR1bSwgdmFsdWVzIH0gPSBncm91cDtcbiAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHVzZUZpbHRlckFuZ2xlcyA/IHZhbHVlc1thbmdsZUZpbHRlcklkeF0gOiB2YWx1ZXNbYW5nbGVJZHhdO1xuICAgICAgY29uc3QgY3Jvc3NGaWx0ZXJTY2FsZSA9IGFuZ2xlRmlsdGVyUmF3SWR4ICE9IG51bGwgJiYgIXVzZUZpbHRlckFuZ2xlcyA/IE1hdGguc3FydCh2YWx1ZXNbYW5nbGVGaWx0ZXJSYXdJZHhdIC8gdmFsdWVzW2FuZ2xlUmF3SWR4XSkgOiAxO1xuICAgICAgY29uc3Qgc3RhcnRBbmdsZSA9IGFuZ2xlU2NhbGUuY29udmVydChjdXJyZW50U3RhcnQpICsgdG9SYWRpYW5zKHJvdGF0aW9uKTtcbiAgICAgIGN1cnJlbnRTdGFydCA9IGN1cnJlbnRWYWx1ZTtcbiAgICAgIHN1bTIgKz0gY3VycmVudFZhbHVlO1xuICAgICAgY29uc3QgZW5kQW5nbGUgPSBhbmdsZVNjYWxlLmNvbnZlcnQoY3VycmVudFN0YXJ0KSArIHRvUmFkaWFucyhyb3RhdGlvbik7XG4gICAgICBjb25zdCBzcGFuID0gTWF0aC5hYnMoZW5kQW5nbGUgLSBzdGFydEFuZ2xlKTtcbiAgICAgIGNvbnN0IG1pZEFuZ2xlID0gc3RhcnRBbmdsZSArIHNwYW4gLyAyO1xuICAgICAgY29uc3QgYW5nbGVWYWx1ZSA9IHZhbHVlc1thbmdsZVJhd0lkeF07XG4gICAgICBjb25zdCByYWRpdXNSYXcgPSByYWRpdXNJZHggIT0gbnVsbCA/IHZhbHVlc1tyYWRpdXNJZHhdID8/IDEgOiAxO1xuICAgICAgY29uc3QgcmFkaXVzID0gcmFkaXVzUmF3ICogY3Jvc3NGaWx0ZXJTY2FsZTtcbiAgICAgIGNvbnN0IHJhZGl1c1ZhbHVlID0gcmFkaXVzUmF3SWR4ICE9IG51bGwgPyB2YWx1ZXNbcmFkaXVzUmF3SWR4XSA6IHZvaWQgMDtcbiAgICAgIGNvbnN0IGxlZ2VuZEl0ZW1WYWx1ZSA9IGxlZ2VuZEl0ZW1JZHggIT0gbnVsbCA/IHZhbHVlc1tsZWdlbmRJdGVtSWR4XSA6IHZvaWQgMDtcbiAgICAgIGNvbnN0IG5vZGVMYWJlbHMgPSB0aGlzLmdldExhYmVscyhcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIG1pZEFuZ2xlLFxuICAgICAgICBzcGFuLFxuICAgICAgICB0cnVlLFxuICAgICAgICBjYWxsb3V0TGFiZWxJZHggIT0gbnVsbCA/IHZhbHVlc1tjYWxsb3V0TGFiZWxJZHhdIDogdm9pZCAwLFxuICAgICAgICBzZWN0b3JMYWJlbElkeCAhPSBudWxsID8gdmFsdWVzW3NlY3RvckxhYmVsSWR4XSA6IHZvaWQgMCxcbiAgICAgICAgbGVnZW5kSXRlbVZhbHVlXG4gICAgICApO1xuICAgICAgY29uc3Qgc2VjdG9yRm9ybWF0ID0gdGhpcy5nZXRTZWN0b3JGb3JtYXQoZGF0dW0sIGluZGV4LCBmYWxzZSk7XG4gICAgICBjb25zdCBub2RlID0ge1xuICAgICAgICBpdGVtSWQ6IGluZGV4LFxuICAgICAgICBzZXJpZXM6IHRoaXMsXG4gICAgICAgIGRhdHVtLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgYW5nbGVWYWx1ZSxcbiAgICAgICAgbWlkQW5nbGUsXG4gICAgICAgIG1pZENvczogTWF0aC5jb3MobWlkQW5nbGUpLFxuICAgICAgICBtaWRTaW46IE1hdGguc2luKG1pZEFuZ2xlKSxcbiAgICAgICAgc3RhcnRBbmdsZSxcbiAgICAgICAgZW5kQW5nbGUsXG4gICAgICAgIHJhZGl1cyxcbiAgICAgICAgaW5uZXJSYWRpdXM6IE1hdGgubWF4KHRoaXMucmFkaXVzU2NhbGUuY29udmVydCgwKSwgMCksXG4gICAgICAgIG91dGVyUmFkaXVzOiBNYXRoLm1heCh0aGlzLnJhZGl1c1NjYWxlLmNvbnZlcnQocmFkaXVzKSwgMCksXG4gICAgICAgIHNlY3RvckZvcm1hdCxcbiAgICAgICAgcmFkaXVzVmFsdWUsXG4gICAgICAgIGxlZ2VuZEl0ZW1WYWx1ZSxcbiAgICAgICAgZW5hYmxlZDogdGhpcy5zZXJpZXNJdGVtRW5hYmxlZFtpbmRleF0sXG4gICAgICAgIGZvY3VzYWJsZTogdHJ1ZSxcbiAgICAgICAgLi4ubm9kZUxhYmVsc1xuICAgICAgfTtcbiAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgICBpZiAocGhhbnRvbU5vZGVzICE9IG51bGwpIHtcbiAgICAgICAgcGhhbnRvbU5vZGVzLnB1c2goe1xuICAgICAgICAgIC4uLm5vZGUsXG4gICAgICAgICAgcmFkaXVzOiAxLFxuICAgICAgICAgIGlubmVyUmFkaXVzOiBNYXRoLm1heCh0aGlzLnJhZGl1c1NjYWxlLmNvbnZlcnQoMCksIDApLFxuICAgICAgICAgIG91dGVyUmFkaXVzOiBNYXRoLm1heCh0aGlzLnJhZGl1c1NjYWxlLmNvbnZlcnQoMSksIDApLFxuICAgICAgICAgIGZvY3VzYWJsZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy56ZXJvc3VtT3V0ZXJSaW5nLnZpc2libGUgPSBzdW0yID09PSAwO1xuICAgIHRoaXMuemVyb3N1bUlubmVyUmluZy52aXNpYmxlID0gc3VtMiA9PT0gMCAmJiBpbm5lclJhZGl1c1JhdGlvICE9IG51bGwgJiYgaW5uZXJSYWRpdXNSYXRpbyAhPT0gMSAmJiBpbm5lclJhZGl1c1JhdGlvID4gMDtcbiAgICByZXR1cm4ge1xuICAgICAgaXRlbUlkOiBzZXJpZXNJZCxcbiAgICAgIG5vZGVEYXRhOiBub2RlcyxcbiAgICAgIGxhYmVsRGF0YTogbm9kZXMsXG4gICAgICBwaGFudG9tTm9kZURhdGE6IHBoYW50b21Ob2Rlc1xuICAgIH07XG4gIH1cbiAgZ2V0TGFiZWxzKGRhdHVtLCBtaWRBbmdsZSwgc3Bhbiwgc2tpcERpc2FibGVkLCBjYWxsb3V0TGFiZWxWYWx1ZSwgc2VjdG9yTGFiZWxWYWx1ZSwgbGVnZW5kSXRlbVZhbHVlKSB7XG4gICAgY29uc3QgeyBjYWxsb3V0TGFiZWwsIHNlY3RvckxhYmVsLCBsZWdlbmRJdGVtS2V5IH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgY2FsbG91dExhYmVsS2V5ID0gIXNraXBEaXNhYmxlZCB8fCBjYWxsb3V0TGFiZWwuZW5hYmxlZCA/IHRoaXMucHJvcGVydGllcy5jYWxsb3V0TGFiZWxLZXkgOiB2b2lkIDA7XG4gICAgY29uc3Qgc2VjdG9yTGFiZWxLZXkgPSAhc2tpcERpc2FibGVkIHx8IHNlY3RvckxhYmVsLmVuYWJsZWQgPyB0aGlzLnByb3BlcnRpZXMuc2VjdG9yTGFiZWxLZXkgOiB2b2lkIDA7XG4gICAgaWYgKCFjYWxsb3V0TGFiZWxLZXkgJiYgIXNlY3RvckxhYmVsS2V5ICYmICFsZWdlbmRJdGVtS2V5KSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IGxhYmVsRm9ybWF0dGVyUGFyYW1zID0ge1xuICAgICAgZGF0dW0sXG4gICAgICBhbmdsZUtleTogdGhpcy5wcm9wZXJ0aWVzLmFuZ2xlS2V5LFxuICAgICAgYW5nbGVOYW1lOiB0aGlzLnByb3BlcnRpZXMuYW5nbGVOYW1lLFxuICAgICAgcmFkaXVzS2V5OiB0aGlzLnByb3BlcnRpZXMucmFkaXVzS2V5LFxuICAgICAgcmFkaXVzTmFtZTogdGhpcy5wcm9wZXJ0aWVzLnJhZGl1c05hbWUsXG4gICAgICBjYWxsb3V0TGFiZWxLZXk6IHRoaXMucHJvcGVydGllcy5jYWxsb3V0TGFiZWxLZXksXG4gICAgICBjYWxsb3V0TGFiZWxOYW1lOiB0aGlzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsTmFtZSxcbiAgICAgIHNlY3RvckxhYmVsS2V5OiB0aGlzLnByb3BlcnRpZXMuc2VjdG9yTGFiZWxLZXksXG4gICAgICBzZWN0b3JMYWJlbE5hbWU6IHRoaXMucHJvcGVydGllcy5zZWN0b3JMYWJlbE5hbWUsXG4gICAgICBsZWdlbmRJdGVtS2V5OiB0aGlzLnByb3BlcnRpZXMubGVnZW5kSXRlbUtleVxuICAgIH07XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgaWYgKGNhbGxvdXRMYWJlbEtleSAmJiBzcGFuID4gdG9SYWRpYW5zKGNhbGxvdXRMYWJlbC5taW5BbmdsZSkpIHtcbiAgICAgIHJlc3VsdC5jYWxsb3V0TGFiZWwgPSB7XG4gICAgICAgIC4uLnRoaXMuZ2V0VGV4dEFsaWdubWVudChtaWRBbmdsZSksXG4gICAgICAgIHRleHQ6IHRoaXMuZ2V0TGFiZWxUZXh0KGNhbGxvdXRMYWJlbCwge1xuICAgICAgICAgIC4uLmxhYmVsRm9ybWF0dGVyUGFyYW1zLFxuICAgICAgICAgIHZhbHVlOiBjYWxsb3V0TGFiZWxWYWx1ZVxuICAgICAgICB9KSxcbiAgICAgICAgaGlkZGVuOiBmYWxzZSxcbiAgICAgICAgY29sbGlzaW9uVGV4dEFsaWduOiB2b2lkIDAsXG4gICAgICAgIGNvbGxpc2lvbk9mZnNldFk6IDAsXG4gICAgICAgIGJveDogdm9pZCAwXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoc2VjdG9yTGFiZWxLZXkpIHtcbiAgICAgIHJlc3VsdC5zZWN0b3JMYWJlbCA9IHtcbiAgICAgICAgdGV4dDogdGhpcy5nZXRMYWJlbFRleHQoc2VjdG9yTGFiZWwsIHtcbiAgICAgICAgICAuLi5sYWJlbEZvcm1hdHRlclBhcmFtcyxcbiAgICAgICAgICB2YWx1ZTogc2VjdG9yTGFiZWxWYWx1ZVxuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGxlZ2VuZEl0ZW1LZXkgIT0gbnVsbCAmJiBsZWdlbmRJdGVtVmFsdWUgIT0gbnVsbCkge1xuICAgICAgcmVzdWx0LmxlZ2VuZEl0ZW0gPSB7IGtleTogbGVnZW5kSXRlbUtleSwgdGV4dDogbGVnZW5kSXRlbVZhbHVlIH07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZ2V0VGV4dEFsaWdubWVudChtaWRBbmdsZSkge1xuICAgIGNvbnN0IHF1YWRyYW50VGV4dE9wdHMgPSBbXG4gICAgICB7IHRleHRBbGlnbjogXCJjZW50ZXJcIiwgdGV4dEJhc2VsaW5lOiBcImJvdHRvbVwiIH0sXG4gICAgICB7IHRleHRBbGlnbjogXCJsZWZ0XCIsIHRleHRCYXNlbGluZTogXCJtaWRkbGVcIiB9LFxuICAgICAgeyB0ZXh0QWxpZ246IFwiY2VudGVyXCIsIHRleHRCYXNlbGluZTogXCJoYW5naW5nXCIgfSxcbiAgICAgIHsgdGV4dEFsaWduOiBcInJpZ2h0XCIsIHRleHRCYXNlbGluZTogXCJtaWRkbGVcIiB9XG4gICAgXTtcbiAgICBjb25zdCBtaWRBbmdsZTE4MCA9IG5vcm1hbGl6ZUFuZ2xlMTgwKG1pZEFuZ2xlKTtcbiAgICBjb25zdCBxdWFkcmFudFN0YXJ0ID0gLTAuNzUgKiBNYXRoLlBJO1xuICAgIGNvbnN0IHF1YWRyYW50T2Zmc2V0ID0gbWlkQW5nbGUxODAgLSBxdWFkcmFudFN0YXJ0O1xuICAgIGNvbnN0IHF1YWRyYW50ID0gTWF0aC5mbG9vcihxdWFkcmFudE9mZnNldCAvIChNYXRoLlBJIC8gMikpO1xuICAgIGNvbnN0IHF1YWRyYW50SW5kZXggPSBtb2QocXVhZHJhbnQsIHF1YWRyYW50VGV4dE9wdHMubGVuZ3RoKTtcbiAgICByZXR1cm4gcXVhZHJhbnRUZXh0T3B0c1txdWFkcmFudEluZGV4XTtcbiAgfVxuICBnZXRTZWN0b3JGb3JtYXQoZGF0dW0sIGZvcm1hdEluZGV4LCBoaWdobGlnaHRlZCkge1xuICAgIGNvbnN0IHsgY2FsbGJhY2tDYWNoZSB9ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgeyBhbmdsZUtleSwgcmFkaXVzS2V5LCBjYWxsb3V0TGFiZWxLZXksIHNlY3RvckxhYmVsS2V5LCBsZWdlbmRJdGVtS2V5LCBmaWxscywgc3Ryb2tlcywgaXRlbVN0eWxlciB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGRlZmF1bHRTdHJva2UgPSBzdHJva2VzW2Zvcm1hdEluZGV4ICUgc3Ryb2tlcy5sZW5ndGhdO1xuICAgIGNvbnN0IHsgZmlsbCwgZmlsbE9wYWNpdHksIHN0cm9rZSwgc3Ryb2tlV2lkdGgsIHN0cm9rZU9wYWNpdHksIGxpbmVEYXNoLCBsaW5lRGFzaE9mZnNldCwgY29ybmVyUmFkaXVzIH0gPSBtZXJnZURlZmF1bHRzKFxuICAgICAgaGlnaGxpZ2h0ZWQgJiYgdGhpcy5wcm9wZXJ0aWVzLmhpZ2hsaWdodFN0eWxlLml0ZW0sXG4gICAgICB7XG4gICAgICAgIGZpbGw6IGZpbGxzLmxlbmd0aCA+IDAgPyBmaWxsc1tmb3JtYXRJbmRleCAlIGZpbGxzLmxlbmd0aF0gOiB2b2lkIDAsXG4gICAgICAgIHN0cm9rZTogZGVmYXVsdFN0cm9rZSxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IHRoaXMuZ2V0U3Ryb2tlV2lkdGgodGhpcy5wcm9wZXJ0aWVzLnN0cm9rZVdpZHRoKSxcbiAgICAgICAgc3Ryb2tlT3BhY2l0eTogdGhpcy5nZXRPcGFjaXR5KClcbiAgICAgIH0sXG4gICAgICB0aGlzLnByb3BlcnRpZXNcbiAgICApO1xuICAgIGxldCBmb3JtYXQ7XG4gICAgaWYgKGl0ZW1TdHlsZXIpIHtcbiAgICAgIGZvcm1hdCA9IGNhbGxiYWNrQ2FjaGUuY2FsbChpdGVtU3R5bGVyLCB7XG4gICAgICAgIGRhdHVtLFxuICAgICAgICBhbmdsZUtleSxcbiAgICAgICAgcmFkaXVzS2V5LFxuICAgICAgICBjYWxsb3V0TGFiZWxLZXksXG4gICAgICAgIHNlY3RvckxhYmVsS2V5LFxuICAgICAgICBsZWdlbmRJdGVtS2V5LFxuICAgICAgICBmaWxsLFxuICAgICAgICBmaWxsT3BhY2l0eSxcbiAgICAgICAgc3Ryb2tlLFxuICAgICAgICBzdHJva2VXaWR0aCxcbiAgICAgICAgc3Ryb2tlT3BhY2l0eSxcbiAgICAgICAgbGluZURhc2gsXG4gICAgICAgIGxpbmVEYXNoT2Zmc2V0LFxuICAgICAgICBjb3JuZXJSYWRpdXMsXG4gICAgICAgIGhpZ2hsaWdodGVkLFxuICAgICAgICBzZXJpZXNJZDogdGhpcy5pZFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBmaWxsOiBmb3JtYXQ/LmZpbGwgPz8gZmlsbCxcbiAgICAgIGZpbGxPcGFjaXR5OiBmb3JtYXQ/LmZpbGxPcGFjaXR5ID8/IGZpbGxPcGFjaXR5LFxuICAgICAgc3Ryb2tlOiBmb3JtYXQ/LnN0cm9rZSA/PyBzdHJva2UsXG4gICAgICBzdHJva2VXaWR0aDogZm9ybWF0Py5zdHJva2VXaWR0aCA/PyBzdHJva2VXaWR0aCxcbiAgICAgIHN0cm9rZU9wYWNpdHk6IGZvcm1hdD8uc3Ryb2tlT3BhY2l0eSA/PyBzdHJva2VPcGFjaXR5LFxuICAgICAgbGluZURhc2g6IGZvcm1hdD8ubGluZURhc2ggPz8gbGluZURhc2gsXG4gICAgICBsaW5lRGFzaE9mZnNldDogZm9ybWF0Py5saW5lRGFzaE9mZnNldCA/PyBsaW5lRGFzaE9mZnNldCxcbiAgICAgIGNvcm5lclJhZGl1czogZm9ybWF0Py5jb3JuZXJSYWRpdXMgPz8gY29ybmVyUmFkaXVzXG4gICAgfTtcbiAgfVxuICBnZXRJbm5lclJhZGl1cygpIHtcbiAgICBjb25zdCB7IHJhZGl1cyB9ID0gdGhpcztcbiAgICBjb25zdCB7IGlubmVyUmFkaXVzUmF0aW8gPSAxLCBpbm5lclJhZGl1c09mZnNldCA9IDAgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCBpbm5lclJhZGl1cyA9IHJhZGl1cyAqIGlubmVyUmFkaXVzUmF0aW8gKyBpbm5lclJhZGl1c09mZnNldDtcbiAgICBpZiAoaW5uZXJSYWRpdXMgPT09IHJhZGl1cyB8fCBpbm5lclJhZGl1cyA8IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gaW5uZXJSYWRpdXM7XG4gIH1cbiAgZ2V0T3V0ZXJSYWRpdXMoKSB7XG4gICAgY29uc3QgeyBvdXRlclJhZGl1c1JhdGlvLCBvdXRlclJhZGl1c09mZnNldCB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIHJldHVybiBNYXRoLm1heCh0aGlzLnJhZGl1cyAqIG91dGVyUmFkaXVzUmF0aW8gKyBvdXRlclJhZGl1c09mZnNldCwgMCk7XG4gIH1cbiAgdXBkYXRlUmFkaXVzU2NhbGUocmVzaXplKSB7XG4gICAgY29uc3QgbmV3UmFuZ2UgPSBbdGhpcy5nZXRJbm5lclJhZGl1cygpLCB0aGlzLmdldE91dGVyUmFkaXVzKCldO1xuICAgIHRoaXMucmFkaXVzU2NhbGUucmFuZ2UgPSBuZXdSYW5nZTtcbiAgICBpZiAocmVzaXplKSB7XG4gICAgICB0aGlzLnByZXZpb3VzUmFkaXVzU2NhbGUucmFuZ2UgPSBuZXdSYW5nZTtcbiAgICB9XG4gICAgY29uc3Qgc2V0UmFkaWkgPSAoZCkgPT4gKHtcbiAgICAgIC4uLmQsXG4gICAgICBpbm5lclJhZGl1czogTWF0aC5tYXgodGhpcy5yYWRpdXNTY2FsZS5jb252ZXJ0KDApLCAwKSxcbiAgICAgIG91dGVyUmFkaXVzOiBNYXRoLm1heCh0aGlzLnJhZGl1c1NjYWxlLmNvbnZlcnQoZC5yYWRpdXMpLCAwKVxuICAgIH0pO1xuICAgIHRoaXMubm9kZURhdGEgPSB0aGlzLm5vZGVEYXRhLm1hcChzZXRSYWRpaSk7XG4gICAgdGhpcy5waGFudG9tTm9kZURhdGEgPSB0aGlzLnBoYW50b21Ob2RlRGF0YT8ubWFwKHNldFJhZGlpKTtcbiAgfVxuICBnZXRUaXRsZVRyYW5zbGF0aW9uWSgpIHtcbiAgICBjb25zdCBvdXRlclJhZGl1cyA9IE1hdGgubWF4KDAsIHRoaXMucmFkaXVzU2NhbGUucmFuZ2VbMV0pO1xuICAgIGlmIChvdXRlclJhZGl1cyA9PT0gMCkge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgY29uc3Qgc3BhY2luZyA9IHRoaXMucHJvcGVydGllcy50aXRsZT8uc3BhY2luZyA/PyAwO1xuICAgIGNvbnN0IHRpdGxlT2Zmc2V0ID0gMiArIHNwYWNpbmc7XG4gICAgY29uc3QgZHkgPSBNYXRoLm1heCgwLCAtb3V0ZXJSYWRpdXMpO1xuICAgIHJldHVybiAtb3V0ZXJSYWRpdXMgLSB0aXRsZU9mZnNldCAtIGR5O1xuICB9XG4gIGFzeW5jIHVwZGF0ZSh7IHNlcmllc1JlY3QgfSkge1xuICAgIGNvbnN0IHsgdGl0bGUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCBuZXdOb2RlRGF0YURlcGVuZGVuY2llcyA9IHtcbiAgICAgIHNlcmllc1JlY3RXaWR0aDogc2VyaWVzUmVjdD8ud2lkdGgsXG4gICAgICBzZXJpZXNSZWN0SGVpZ2h0OiBzZXJpZXNSZWN0Py5oZWlnaHRcbiAgICB9O1xuICAgIGNvbnN0IHJlc2l6ZSA9IGpzb25EaWZmKHRoaXMubm9kZURhdGFEZXBlbmRlbmNpZXMsIG5ld05vZGVEYXRhRGVwZW5kZW5jaWVzKSAhPSBudWxsO1xuICAgIGlmIChyZXNpemUpIHtcbiAgICAgIHRoaXMuX25vZGVEYXRhRGVwZW5kZW5jaWVzID0gbmV3Tm9kZURhdGFEZXBlbmRlbmNpZXM7XG4gICAgfVxuICAgIGF3YWl0IHRoaXMubWF5YmVSZWZyZXNoTm9kZURhdGEoKTtcbiAgICB0aGlzLnVwZGF0ZVRpdGxlTm9kZXMoKTtcbiAgICB0aGlzLnVwZGF0ZVJhZGl1c1NjYWxlKHJlc2l6ZSk7XG4gICAgdGhpcy5jb250ZW50R3JvdXAudHJhbnNsYXRpb25YID0gdGhpcy5jZW50ZXJYO1xuICAgIHRoaXMuY29udGVudEdyb3VwLnRyYW5zbGF0aW9uWSA9IHRoaXMuY2VudGVyWTtcbiAgICB0aGlzLmhpZ2hsaWdodEdyb3VwLnRyYW5zbGF0aW9uWCA9IHRoaXMuY2VudGVyWDtcbiAgICB0aGlzLmhpZ2hsaWdodEdyb3VwLnRyYW5zbGF0aW9uWSA9IHRoaXMuY2VudGVyWTtcbiAgICB0aGlzLmJhY2tncm91bmRHcm91cC50cmFuc2xhdGlvblggPSB0aGlzLmNlbnRlclg7XG4gICAgdGhpcy5iYWNrZ3JvdW5kR3JvdXAudHJhbnNsYXRpb25ZID0gdGhpcy5jZW50ZXJZO1xuICAgIGlmICh0aGlzLmxhYmVsR3JvdXApIHtcbiAgICAgIHRoaXMubGFiZWxHcm91cC50cmFuc2xhdGlvblggPSB0aGlzLmNlbnRlclg7XG4gICAgICB0aGlzLmxhYmVsR3JvdXAudHJhbnNsYXRpb25ZID0gdGhpcy5jZW50ZXJZO1xuICAgIH1cbiAgICBpZiAodGl0bGUpIHtcbiAgICAgIGNvbnN0IGR5ID0gdGhpcy5nZXRUaXRsZVRyYW5zbGF0aW9uWSgpO1xuICAgICAgdGl0bGUubm9kZS55ID0gaXNGaW5pdGUoZHkpID8gZHkgOiAwO1xuICAgICAgY29uc3QgdGl0bGVCb3ggPSB0aXRsZS5ub2RlLmdldEJCb3goKTtcbiAgICAgIHRpdGxlLm5vZGUudmlzaWJsZSA9IHRpdGxlLmVuYWJsZWQgJiYgaXNGaW5pdGUoZHkpICYmICF0aGlzLmJib3hJbnRlcnNlY3RzU3Vycm91bmRpbmdTZXJpZXModGl0bGVCb3gpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGNpcmNsZSBvZiBbdGhpcy56ZXJvc3VtSW5uZXJSaW5nLCB0aGlzLnplcm9zdW1PdXRlclJpbmddKSB7XG4gICAgICBjaXJjbGUuZmlsbE9wYWNpdHkgPSAwO1xuICAgICAgY2lyY2xlLnN0cm9rZSA9IHRoaXMucHJvcGVydGllcy5jYWxsb3V0TGFiZWwuY29sb3I7XG4gICAgICBjaXJjbGUuc3Ryb2tlV2lkdGggPSAxO1xuICAgICAgY2lyY2xlLnN0cm9rZU9wYWNpdHkgPSAxO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZU5vZGVNaWRQb2ludCgpO1xuICAgIGF3YWl0IHRoaXMudXBkYXRlU2VsZWN0aW9ucygpO1xuICAgIGF3YWl0IHRoaXMudXBkYXRlTm9kZXMoc2VyaWVzUmVjdCk7XG4gIH1cbiAgdXBkYXRlVGl0bGVOb2RlcygpIHtcbiAgICBjb25zdCB7IG9sZFRpdGxlIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgdGl0bGUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBpZiAob2xkVGl0bGUgIT09IHRpdGxlKSB7XG4gICAgICBpZiAob2xkVGl0bGUpIHtcbiAgICAgICAgdGhpcy5sYWJlbEdyb3VwPy5yZW1vdmVDaGlsZChvbGRUaXRsZS5ub2RlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aXRsZSkge1xuICAgICAgICB0aXRsZS5ub2RlLnRleHRCYXNlbGluZSA9IFwiYm90dG9tXCI7XG4gICAgICAgIHRoaXMubGFiZWxHcm91cD8uYXBwZW5kQ2hpbGQodGl0bGUubm9kZSk7XG4gICAgICB9XG4gICAgICB0aGlzLm9sZFRpdGxlID0gdGl0bGU7XG4gICAgfVxuICB9XG4gIHVwZGF0ZU5vZGVNaWRQb2ludCgpIHtcbiAgICBjb25zdCBzZXRNaWRQb2ludCA9IChkKSA9PiB7XG4gICAgICBjb25zdCByYWRpdXMgPSBkLmlubmVyUmFkaXVzICsgKGQub3V0ZXJSYWRpdXMgLSBkLmlubmVyUmFkaXVzKSAvIDI7XG4gICAgICBkLm1pZFBvaW50ID0ge1xuICAgICAgICB4OiBkLm1pZENvcyAqIE1hdGgubWF4KDAsIHJhZGl1cyksXG4gICAgICAgIHk6IGQubWlkU2luICogTWF0aC5tYXgoMCwgcmFkaXVzKVxuICAgICAgfTtcbiAgICB9O1xuICAgIHRoaXMubm9kZURhdGEuZm9yRWFjaChzZXRNaWRQb2ludCk7XG4gICAgdGhpcy5waGFudG9tTm9kZURhdGE/LmZvckVhY2goc2V0TWlkUG9pbnQpO1xuICB9XG4gIGFzeW5jIHVwZGF0ZVNlbGVjdGlvbnMoKSB7XG4gICAgYXdhaXQgdGhpcy51cGRhdGVHcm91cFNlbGVjdGlvbigpO1xuICAgIHRoaXMudXBkYXRlSW5uZXJDaXJjbGVTZWxlY3Rpb24oKTtcbiAgfVxuICBhc3luYyB1cGRhdGVHcm91cFNlbGVjdGlvbigpIHtcbiAgICBjb25zdCB7XG4gICAgICBpdGVtU2VsZWN0aW9uLFxuICAgICAgaGlnaGxpZ2h0U2VsZWN0aW9uLFxuICAgICAgcGhhbnRvbVNlbGVjdGlvbixcbiAgICAgIGhpZ2hsaWdodExhYmVsU2VsZWN0aW9uLFxuICAgICAgY2FsbG91dExhYmVsU2VsZWN0aW9uLFxuICAgICAgbGFiZWxTZWxlY3Rpb24sXG4gICAgICBpbm5lckxhYmVsc1NlbGVjdGlvblxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGhpZ2hsaWdodGVkTm9kZURhdGEgPSB0aGlzLm5vZGVEYXRhLm1hcCgoZGF0dW0pID0+ICh7XG4gICAgICAuLi5kYXR1bSxcbiAgICAgIC8vIEFsbG93IG11dGFibGUgc2VjdG9yRm9ybWF0LCBzbyBmb3JtYXR0ZWQgc2VjdG9yIHN0eWxlcyBjYW4gYmUgdXBkYXRlZCBhbmQgdmFyaWVkXG4gICAgICAvLyBiZXR3ZWVuIG5vcm1hbCBhbmQgaGlnaGxpZ2h0ZWQgY2FzZXMuXG4gICAgICBzZWN0b3JGb3JtYXQ6IHsgLi4uZGF0dW0uc2VjdG9yRm9ybWF0IH1cbiAgICB9KSk7XG4gICAgY29uc3QgdXBkYXRlID0gKHNlbGVjdGlvbiwgbm9kZURhdGEpID0+IHtcbiAgICAgIHNlbGVjdGlvbi51cGRhdGUobm9kZURhdGEsIHZvaWQgMCwgKGRhdHVtKSA9PiB0aGlzLmdldERhdHVtSWQoZGF0dW0pKTtcbiAgICAgIGlmICh0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLmlzU2tpcHBlZCgpKSB7XG4gICAgICAgIHNlbGVjdGlvbi5jbGVhbnVwKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB1cGRhdGUoaXRlbVNlbGVjdGlvbiwgdGhpcy5ub2RlRGF0YSk7XG4gICAgdXBkYXRlKGhpZ2hsaWdodFNlbGVjdGlvbiwgaGlnaGxpZ2h0ZWROb2RlRGF0YSk7XG4gICAgdXBkYXRlKHBoYW50b21TZWxlY3Rpb24sIHRoaXMucGhhbnRvbU5vZGVEYXRhID8/IFtdKTtcbiAgICBjYWxsb3V0TGFiZWxTZWxlY3Rpb24udXBkYXRlKHRoaXMuY2FsbG91dE5vZGVEYXRhLCAoZ3JvdXApID0+IHtcbiAgICAgIGNvbnN0IGxpbmUgPSBuZXcgTGluZSgpO1xuICAgICAgbGluZS50YWcgPSAwIC8qIENhbGxvdXQgKi87XG4gICAgICBsaW5lLnBvaW50ZXJFdmVudHMgPSAxIC8qIE5vbmUgKi87XG4gICAgICBncm91cC5hcHBlbmRDaGlsZChsaW5lKTtcbiAgICAgIGNvbnN0IHRleHQgPSBuZXcgVGV4dCgpO1xuICAgICAgdGV4dC50YWcgPSAxIC8qIExhYmVsICovO1xuICAgICAgdGV4dC5wb2ludGVyRXZlbnRzID0gMSAvKiBOb25lICovO1xuICAgICAgZ3JvdXAuYXBwZW5kQ2hpbGQodGV4dCk7XG4gICAgfSk7XG4gICAgbGFiZWxTZWxlY3Rpb24udXBkYXRlKHRoaXMubm9kZURhdGEpO1xuICAgIGhpZ2hsaWdodExhYmVsU2VsZWN0aW9uLnVwZGF0ZShoaWdobGlnaHRlZE5vZGVEYXRhKTtcbiAgICBpbm5lckxhYmVsc1NlbGVjdGlvbi51cGRhdGUodGhpcy5wcm9wZXJ0aWVzLmlubmVyTGFiZWxzLCAobm9kZSkgPT4ge1xuICAgICAgbm9kZS5wb2ludGVyRXZlbnRzID0gMSAvKiBOb25lICovO1xuICAgIH0pO1xuICB9XG4gIHVwZGF0ZUlubmVyQ2lyY2xlU2VsZWN0aW9uKCkge1xuICAgIGNvbnN0IHsgaW5uZXJDaXJjbGUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBsZXQgcmFkaXVzID0gMDtcbiAgICBjb25zdCBpbm5lclJhZGl1cyA9IHRoaXMuZ2V0SW5uZXJSYWRpdXMoKTtcbiAgICBpZiAoaW5uZXJSYWRpdXMgPiAwKSB7XG4gICAgICBjb25zdCBjaXJjbGVSYWRpdXMgPSBNYXRoLm1pbihpbm5lclJhZGl1cywgdGhpcy5nZXRPdXRlclJhZGl1cygpKTtcbiAgICAgIGNvbnN0IGFudGlBbGlhc2luZ1BhZGRpbmcgPSAxO1xuICAgICAgcmFkaXVzID0gTWF0aC5jZWlsKGNpcmNsZVJhZGl1cyAqIDIgKyBhbnRpQWxpYXNpbmdQYWRkaW5nKTtcbiAgICB9XG4gICAgY29uc3QgZGF0dW1zID0gaW5uZXJDaXJjbGUgPyBbeyByYWRpdXMgfV0gOiBbXTtcbiAgICB0aGlzLmlubmVyQ2lyY2xlU2VsZWN0aW9uLnVwZGF0ZShkYXR1bXMpO1xuICB9XG4gIGFzeW5jIHVwZGF0ZU5vZGVzKHNlcmllc1JlY3QpIHtcbiAgICBjb25zdCBoaWdobGlnaHRlZERhdHVtID0gdGhpcy5jdHguaGlnaGxpZ2h0TWFuYWdlci5nZXRBY3RpdmVIaWdobGlnaHQoKTtcbiAgICBjb25zdCBpc1Zpc2libGUgPSB0aGlzLnZpc2libGUgJiYgdGhpcy5zZXJpZXNJdGVtRW5hYmxlZC5pbmNsdWRlcyh0cnVlKTtcbiAgICB0aGlzLnJvb3RHcm91cC52aXNpYmxlID0gaXNWaXNpYmxlO1xuICAgIHRoaXMuYmFja2dyb3VuZEdyb3VwLnZpc2libGUgPSBpc1Zpc2libGU7XG4gICAgdGhpcy5jb250ZW50R3JvdXAudmlzaWJsZSA9IGlzVmlzaWJsZTtcbiAgICB0aGlzLmhpZ2hsaWdodEdyb3VwLnZpc2libGUgPSBpc1Zpc2libGUgJiYgaGlnaGxpZ2h0ZWREYXR1bT8uc2VyaWVzID09PSB0aGlzO1xuICAgIHRoaXMuaGlnaGxpZ2h0TGFiZWwudmlzaWJsZSA9IGlzVmlzaWJsZSAmJiBoaWdobGlnaHRlZERhdHVtPy5zZXJpZXMgPT09IHRoaXM7XG4gICAgdGhpcy5sYWJlbEdyb3VwLnZpc2libGUgPSBpc1Zpc2libGU7XG4gICAgdGhpcy5jb250ZW50R3JvdXAub3BhY2l0eSA9IHRoaXMuZ2V0T3BhY2l0eSgpO1xuICAgIHRoaXMuaW5uZXJDaXJjbGVTZWxlY3Rpb24uZWFjaCgobm9kZSwgeyByYWRpdXMgfSkgPT4ge1xuICAgICAgbm9kZS5zZXRQcm9wZXJ0aWVzKHtcbiAgICAgICAgZmlsbDogdGhpcy5wcm9wZXJ0aWVzLmlubmVyQ2lyY2xlPy5maWxsLFxuICAgICAgICBvcGFjaXR5OiB0aGlzLnByb3BlcnRpZXMuaW5uZXJDaXJjbGU/LmZpbGxPcGFjaXR5LFxuICAgICAgICBzaXplOiByYWRpdXNcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGNvbnN0IGFuaW1hdGlvbkRpc2FibGVkID0gdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5pc1NraXBwZWQoKTtcbiAgICBjb25zdCB1cGRhdGVTZWN0b3JGbiA9IChzZWN0b3IsIGRhdHVtLCBfaW5kZXgsIGlzRGF0dW1IaWdobGlnaHRlZCkgPT4ge1xuICAgICAgY29uc3QgZm9ybWF0ID0gdGhpcy5nZXRTZWN0b3JGb3JtYXQoZGF0dW0uZGF0dW0sIGRhdHVtLml0ZW1JZCwgaXNEYXR1bUhpZ2hsaWdodGVkKTtcbiAgICAgIGRhdHVtLnNlY3RvckZvcm1hdC5maWxsID0gZm9ybWF0LmZpbGw7XG4gICAgICBkYXR1bS5zZWN0b3JGb3JtYXQuc3Ryb2tlID0gZm9ybWF0LnN0cm9rZTtcbiAgICAgIGlmIChhbmltYXRpb25EaXNhYmxlZCkge1xuICAgICAgICBzZWN0b3Iuc3RhcnRBbmdsZSA9IGRhdHVtLnN0YXJ0QW5nbGU7XG4gICAgICAgIHNlY3Rvci5lbmRBbmdsZSA9IGRhdHVtLmVuZEFuZ2xlO1xuICAgICAgICBzZWN0b3IuaW5uZXJSYWRpdXMgPSBkYXR1bS5pbm5lclJhZGl1cztcbiAgICAgICAgc2VjdG9yLm91dGVyUmFkaXVzID0gZGF0dW0ub3V0ZXJSYWRpdXM7XG4gICAgICB9XG4gICAgICBpZiAoaXNEYXR1bUhpZ2hsaWdodGVkIHx8IGFuaW1hdGlvbkRpc2FibGVkKSB7XG4gICAgICAgIHNlY3Rvci5maWxsID0gZm9ybWF0LmZpbGw7XG4gICAgICAgIHNlY3Rvci5zdHJva2UgPSBmb3JtYXQuc3Ryb2tlO1xuICAgICAgfVxuICAgICAgc2VjdG9yLnN0cm9rZVdpZHRoID0gZm9ybWF0LnN0cm9rZVdpZHRoO1xuICAgICAgc2VjdG9yLmZpbGxPcGFjaXR5ID0gZm9ybWF0LmZpbGxPcGFjaXR5O1xuICAgICAgc2VjdG9yLnN0cm9rZU9wYWNpdHkgPSBmb3JtYXQuc3Ryb2tlT3BhY2l0eTtcbiAgICAgIHNlY3Rvci5saW5lRGFzaCA9IGZvcm1hdC5saW5lRGFzaDtcbiAgICAgIHNlY3Rvci5saW5lRGFzaE9mZnNldCA9IGZvcm1hdC5saW5lRGFzaE9mZnNldDtcbiAgICAgIHNlY3Rvci5jb3JuZXJSYWRpdXMgPSBmb3JtYXQuY29ybmVyUmFkaXVzO1xuICAgICAgc2VjdG9yLmZpbGxTaGFkb3cgPSB0aGlzLnByb3BlcnRpZXMuc2hhZG93O1xuICAgICAgY29uc3QgaW5zZXQgPSBNYXRoLm1heChcbiAgICAgICAgKHRoaXMucHJvcGVydGllcy5zZWN0b3JTcGFjaW5nICsgKGZvcm1hdC5zdHJva2UgIT0gbnVsbCA/IGZvcm1hdC5zdHJva2VXaWR0aCA6IDApKSAvIDIsXG4gICAgICAgIDBcbiAgICAgICk7XG4gICAgICBzZWN0b3IuaW5zZXQgPSBpbnNldDtcbiAgICAgIHNlY3Rvci5saW5lSm9pbiA9IHRoaXMucHJvcGVydGllcy5zZWN0b3JTcGFjaW5nID49IDAgfHwgaW5zZXQgPiAwID8gXCJtaXRlclwiIDogXCJyb3VuZFwiO1xuICAgIH07XG4gICAgdGhpcy5pdGVtU2VsZWN0aW9uLmVhY2goKG5vZGUsIGRhdHVtLCBpbmRleCkgPT4gdXBkYXRlU2VjdG9yRm4obm9kZSwgZGF0dW0sIGluZGV4LCBmYWxzZSkpO1xuICAgIHRoaXMuaGlnaGxpZ2h0U2VsZWN0aW9uLmVhY2goKG5vZGUsIGRhdHVtLCBpbmRleCkgPT4ge1xuICAgICAgdXBkYXRlU2VjdG9yRm4obm9kZSwgZGF0dW0sIGluZGV4LCB0cnVlKTtcbiAgICAgIG5vZGUudmlzaWJsZSA9IGRhdHVtLml0ZW1JZCA9PT0gaGlnaGxpZ2h0ZWREYXR1bT8uaXRlbUlkO1xuICAgIH0pO1xuICAgIHRoaXMucGhhbnRvbVNlbGVjdGlvbi5lYWNoKChub2RlLCBkYXR1bSwgaW5kZXgpID0+IHVwZGF0ZVNlY3RvckZuKG5vZGUsIGRhdHVtLCBpbmRleCwgZmFsc2UpKTtcbiAgICB0aGlzLnVwZGF0ZUNhbGxvdXRMaW5lTm9kZXMoKTtcbiAgICB0aGlzLnVwZGF0ZUNhbGxvdXRMYWJlbE5vZGVzKHNlcmllc1JlY3QpO1xuICAgIHRoaXMudXBkYXRlU2VjdG9yTGFiZWxOb2RlcygpO1xuICAgIHRoaXMudXBkYXRlSW5uZXJMYWJlbE5vZGVzKCk7XG4gICAgdGhpcy51cGRhdGVaZXJvc3VtUmluZ3MoKTtcbiAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJ1cGRhdGVcIik7XG4gIH1cbiAgdXBkYXRlQ2FsbG91dExpbmVOb2RlcygpIHtcbiAgICBjb25zdCB7IGNhbGxvdXRMaW5lIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgY2FsbG91dExlbmd0aCA9IGNhbGxvdXRMaW5lLmxlbmd0aDtcbiAgICBjb25zdCBjYWxsb3V0U3Ryb2tlV2lkdGggPSBjYWxsb3V0TGluZS5zdHJva2VXaWR0aDtcbiAgICBjb25zdCBjYWxsb3V0Q29sb3JzID0gY2FsbG91dExpbmUuY29sb3JzID8/IHRoaXMucHJvcGVydGllcy5zdHJva2VzO1xuICAgIGNvbnN0IHsgb2Zmc2V0OiBvZmZzZXQ0IH0gPSB0aGlzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsO1xuICAgIHRoaXMuY2FsbG91dExhYmVsU2VsZWN0aW9uLnNlbGVjdEJ5VGFnKDAgLyogQ2FsbG91dCAqLykuZm9yRWFjaCgobGluZSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGRhdHVtID0gbGluZS5kYXR1bTtcbiAgICAgIGNvbnN0IHsgY2FsbG91dExhYmVsOiBsYWJlbCwgb3V0ZXJSYWRpdXMgfSA9IGRhdHVtO1xuICAgICAgaWYgKGxhYmVsPy50ZXh0ICYmICFsYWJlbC5oaWRkZW4gJiYgb3V0ZXJSYWRpdXMgIT09IDApIHtcbiAgICAgICAgbGluZS52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgbGluZS5zdHJva2VXaWR0aCA9IGNhbGxvdXRTdHJva2VXaWR0aDtcbiAgICAgICAgbGluZS5zdHJva2UgPSBjYWxsb3V0Q29sb3JzW2luZGV4ICUgY2FsbG91dENvbG9ycy5sZW5ndGhdO1xuICAgICAgICBsaW5lLmZpbGwgPSB2b2lkIDA7XG4gICAgICAgIGNvbnN0IHgxID0gZGF0dW0ubWlkQ29zICogb3V0ZXJSYWRpdXM7XG4gICAgICAgIGNvbnN0IHkxID0gZGF0dW0ubWlkU2luICogb3V0ZXJSYWRpdXM7XG4gICAgICAgIGxldCB4MiA9IGRhdHVtLm1pZENvcyAqIChvdXRlclJhZGl1cyArIGNhbGxvdXRMZW5ndGgpO1xuICAgICAgICBsZXQgeTIgPSBkYXR1bS5taWRTaW4gKiAob3V0ZXJSYWRpdXMgKyBjYWxsb3V0TGVuZ3RoKTtcbiAgICAgICAgY29uc3QgaXNNb3ZlZCA9IGxhYmVsLmNvbGxpc2lvblRleHRBbGlnbiA/PyBsYWJlbC5jb2xsaXNpb25PZmZzZXRZICE9PSAwO1xuICAgICAgICBpZiAoaXNNb3ZlZCAmJiBsYWJlbC5ib3ggIT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IGJveCA9IGxhYmVsLmJveDtcbiAgICAgICAgICBsZXQgY3ggPSB4MjtcbiAgICAgICAgICBsZXQgY3kgPSB5MjtcbiAgICAgICAgICBpZiAoeDIgPCBib3gueCkge1xuICAgICAgICAgICAgY3ggPSBib3gueDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHgyID4gYm94LnggKyBib3gud2lkdGgpIHtcbiAgICAgICAgICAgIGN4ID0gYm94LnggKyBib3gud2lkdGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh5MiA8IGJveC55KSB7XG4gICAgICAgICAgICBjeSA9IGJveC55O1xuICAgICAgICAgIH0gZWxzZSBpZiAoeTIgPiBib3gueSArIGJveC5oZWlnaHQpIHtcbiAgICAgICAgICAgIGN5ID0gYm94LnkgKyBib3guaGVpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBkeCA9IGN4IC0geDI7XG4gICAgICAgICAgY29uc3QgZHkgPSBjeSAtIHkyO1xuICAgICAgICAgIGNvbnN0IGxlbmd0aDIgPSBNYXRoLnNxcnQoTWF0aC5wb3coZHgsIDIpICsgTWF0aC5wb3coZHksIDIpKTtcbiAgICAgICAgICBjb25zdCBwYWRkZWRMZW5ndGggPSBsZW5ndGgyIC0gb2Zmc2V0NDtcbiAgICAgICAgICBpZiAocGFkZGVkTGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgeDIgPSB4MiArIGR4ICogcGFkZGVkTGVuZ3RoIC8gbGVuZ3RoMjtcbiAgICAgICAgICAgIHkyID0geTIgKyBkeSAqIHBhZGRlZExlbmd0aCAvIGxlbmd0aDI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxpbmUueDEgPSB4MTtcbiAgICAgICAgbGluZS55MSA9IHkxO1xuICAgICAgICBsaW5lLngyID0geDI7XG4gICAgICAgIGxpbmUueTIgPSB5MjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpbmUudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGdldExhYmVsT3ZlcmZsb3codGV4dCwgYm94LCBzZXJpZXNSZWN0KSB7XG4gICAgY29uc3Qgc2VyaWVzTGVmdCA9IHNlcmllc1JlY3QueCAtIHRoaXMuY2VudGVyWDtcbiAgICBjb25zdCBzZXJpZXNSaWdodCA9IHNlcmllc1JlY3QueCArIHNlcmllc1JlY3Qud2lkdGggLSB0aGlzLmNlbnRlclg7XG4gICAgY29uc3Qgc2VyaWVzVG9wID0gc2VyaWVzUmVjdC55IC0gdGhpcy5jZW50ZXJZO1xuICAgIGNvbnN0IHNlcmllc0JvdHRvbSA9IHNlcmllc1JlY3QueSArIHNlcmllc1JlY3QuaGVpZ2h0IC0gdGhpcy5jZW50ZXJZO1xuICAgIGNvbnN0IGVyclB4ID0gMTtcbiAgICBsZXQgdmlzaWJsZVRleHRQYXJ0ID0gMTtcbiAgICBpZiAoYm94LnggKyBlcnJQeCA8IHNlcmllc0xlZnQpIHtcbiAgICAgIHZpc2libGVUZXh0UGFydCA9IChib3gueCArIGJveC53aWR0aCAtIHNlcmllc0xlZnQpIC8gYm94LndpZHRoO1xuICAgIH0gZWxzZSBpZiAoYm94LnggKyBib3gud2lkdGggLSBlcnJQeCA+IHNlcmllc1JpZ2h0KSB7XG4gICAgICB2aXNpYmxlVGV4dFBhcnQgPSAoc2VyaWVzUmlnaHQgLSBib3gueCkgLyBib3gud2lkdGg7XG4gICAgfVxuICAgIGNvbnN0IGhhc1ZlcnRpY2FsT3ZlcmZsb3cgPSBib3gueSArIGVyclB4IDwgc2VyaWVzVG9wIHx8IGJveC55ICsgYm94LmhlaWdodCAtIGVyclB4ID4gc2VyaWVzQm90dG9tO1xuICAgIGNvbnN0IHRleHRMZW5ndGggPSB2aXNpYmxlVGV4dFBhcnQgPT09IDEgPyB0ZXh0Lmxlbmd0aCA6IE1hdGguZmxvb3IodGV4dC5sZW5ndGggKiB2aXNpYmxlVGV4dFBhcnQpIC0gMTtcbiAgICBjb25zdCBoYXNTdXJyb3VuZGluZ1Nlcmllc092ZXJmbG93ID0gdGhpcy5iYm94SW50ZXJzZWN0c1N1cnJvdW5kaW5nU2VyaWVzKGJveCk7XG4gICAgcmV0dXJuIHsgdGV4dExlbmd0aCwgaGFzVmVydGljYWxPdmVyZmxvdywgaGFzU3Vycm91bmRpbmdTZXJpZXNPdmVyZmxvdyB9O1xuICB9XG4gIGJib3hJbnRlcnNlY3RzU3Vycm91bmRpbmdTZXJpZXMoYm94KSB7XG4gICAgY29uc3QgeyBzdXJyb3VuZGluZ1JhZGl1cyB9ID0gdGhpcztcbiAgICBpZiAoc3Vycm91bmRpbmdSYWRpdXMgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBjb3JuZXJzID0gW1xuICAgICAgeyB4OiBib3gueCwgeTogYm94LnkgfSxcbiAgICAgIHsgeDogYm94LnggKyBib3gud2lkdGgsIHk6IGJveC55IH0sXG4gICAgICB7IHg6IGJveC54ICsgYm94LndpZHRoLCB5OiBib3gueSArIGJveC5oZWlnaHQgfSxcbiAgICAgIHsgeDogYm94LngsIHk6IGJveC55ICsgYm94LmhlaWdodCB9XG4gICAgXTtcbiAgICBjb25zdCBzdXIyID0gc3Vycm91bmRpbmdSYWRpdXMgKiogMjtcbiAgICByZXR1cm4gY29ybmVycy5zb21lKChjb3JuZXIpID0+IGNvcm5lci54ICoqIDIgKyBjb3JuZXIueSAqKiAyID4gc3VyMik7XG4gIH1cbiAgY29tcHV0ZUNhbGxvdXRMYWJlbENvbGxpc2lvbk9mZnNldHMoKSB7XG4gICAgY29uc3QgeyByYWRpdXNTY2FsZSB9ID0gdGhpcztcbiAgICBjb25zdCB7IGNhbGxvdXRMYWJlbCwgY2FsbG91dExpbmUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCB7IG9mZnNldDogb2Zmc2V0NCwgbWluU3BhY2luZyB9ID0gY2FsbG91dExhYmVsO1xuICAgIGNvbnN0IGlubmVyUmFkaXVzID0gcmFkaXVzU2NhbGUuY29udmVydCgwKTtcbiAgICBjb25zdCBzaG91bGRTa2lwID0gKGRhdHVtKSA9PiB7XG4gICAgICBjb25zdCBsYWJlbCA9IGRhdHVtLmNhbGxvdXRMYWJlbDtcbiAgICAgIHJldHVybiAhbGFiZWwgfHwgZGF0dW0ub3V0ZXJSYWRpdXMgPT09IDA7XG4gICAgfTtcbiAgICBjb25zdCBmdWxsRGF0YSA9IHRoaXMuY2FsbG91dE5vZGVEYXRhO1xuICAgIGNvbnN0IGRhdGEgPSBmdWxsRGF0YS5maWx0ZXIoKHQpID0+ICFzaG91bGRTa2lwKHQpKTtcbiAgICBkYXRhLmZvckVhY2goKGRhdHVtKSA9PiB7XG4gICAgICBjb25zdCBsYWJlbCA9IGRhdHVtLmNhbGxvdXRMYWJlbDtcbiAgICAgIGlmIChsYWJlbCA9PSBudWxsKVxuICAgICAgICByZXR1cm47XG4gICAgICBsYWJlbC5oaWRkZW4gPSBmYWxzZTtcbiAgICAgIGxhYmVsLmNvbGxpc2lvblRleHRBbGlnbiA9IHZvaWQgMDtcbiAgICAgIGxhYmVsLmNvbGxpc2lvbk9mZnNldFkgPSAwO1xuICAgIH0pO1xuICAgIGlmIChkYXRhLmxlbmd0aCA8PSAxKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxlZnRMYWJlbHMgPSBkYXRhLmZpbHRlcigoZCkgPT4gZC5taWRDb3MgPCAwKS5zb3J0KChhLCBiKSA9PiBhLm1pZFNpbiAtIGIubWlkU2luKTtcbiAgICBjb25zdCByaWdodExhYmVscyA9IGRhdGEuZmlsdGVyKChkKSA9PiBkLm1pZENvcyA+PSAwKS5zb3J0KChhLCBiKSA9PiBhLm1pZFNpbiAtIGIubWlkU2luKTtcbiAgICBjb25zdCB0b3BMYWJlbHMgPSBkYXRhLmZpbHRlcigoZCkgPT4gZC5taWRTaW4gPCAwICYmIGQuY2FsbG91dExhYmVsPy50ZXh0QWxpZ24gPT09IFwiY2VudGVyXCIpLnNvcnQoKGEsIGIpID0+IGEubWlkQ29zIC0gYi5taWRDb3MpO1xuICAgIGNvbnN0IGJvdHRvbUxhYmVscyA9IGRhdGEuZmlsdGVyKChkKSA9PiBkLm1pZFNpbiA+PSAwICYmIGQuY2FsbG91dExhYmVsPy50ZXh0QWxpZ24gPT09IFwiY2VudGVyXCIpLnNvcnQoKGEsIGIpID0+IGEubWlkQ29zIC0gYi5taWRDb3MpO1xuICAgIGNvbnN0IGdldFRleHRCQm94ID0gKGRhdHVtKSA9PiB7XG4gICAgICBjb25zdCBsYWJlbCA9IGRhdHVtLmNhbGxvdXRMYWJlbDtcbiAgICAgIGlmIChsYWJlbCA9PSBudWxsKVxuICAgICAgICByZXR1cm4gQkJveC56ZXJvLmNsb25lKCk7XG4gICAgICBjb25zdCBsYWJlbFJhZGl1cyA9IGRhdHVtLm91dGVyUmFkaXVzICsgY2FsbG91dExpbmUubGVuZ3RoICsgb2Zmc2V0NDtcbiAgICAgIGNvbnN0IHggPSBkYXR1bS5taWRDb3MgKiBsYWJlbFJhZGl1cztcbiAgICAgIGNvbnN0IHkgPSBkYXR1bS5taWRTaW4gKiBsYWJlbFJhZGl1cyArIGxhYmVsLmNvbGxpc2lvbk9mZnNldFk7XG4gICAgICBjb25zdCB0ZXh0QWxpZ24gPSBsYWJlbC5jb2xsaXNpb25UZXh0QWxpZ24gPz8gbGFiZWwudGV4dEFsaWduO1xuICAgICAgY29uc3QgdGV4dEJhc2VsaW5lID0gbGFiZWwudGV4dEJhc2VsaW5lO1xuICAgICAgcmV0dXJuIFRleHQuY29tcHV0ZUJCb3gobGFiZWwudGV4dCwgeCwgeSwge1xuICAgICAgICBmb250OiB0aGlzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsLFxuICAgICAgICB0ZXh0QWxpZ24sXG4gICAgICAgIHRleHRCYXNlbGluZVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBhdm9pZE5laWdoYm91cllDb2xsaXNpb24gPSAobGFiZWwsIG5leHQsIGRpcmVjdGlvbikgPT4ge1xuICAgICAgY29uc3QgYm94ID0gZ2V0VGV4dEJCb3gobGFiZWwpLmdyb3cobWluU3BhY2luZyAvIDIpO1xuICAgICAgY29uc3Qgb3RoZXIgPSBnZXRUZXh0QkJveChuZXh0KS5ncm93KG1pblNwYWNpbmcgLyAyKTtcbiAgICAgIGNvbnN0IGNvbGxpZGVzT3JCZWhpbmQgPSBib3gueCA8IG90aGVyLnggKyBvdGhlci53aWR0aCAmJiBib3gueCArIGJveC53aWR0aCA+IG90aGVyLnggJiYgKGRpcmVjdGlvbiA9PT0gXCJ0by10b3BcIiA/IGJveC55IDwgb3RoZXIueSArIG90aGVyLmhlaWdodCA6IGJveC55ICsgYm94LmhlaWdodCA+IG90aGVyLnkpO1xuICAgICAgaWYgKGNvbGxpZGVzT3JCZWhpbmQpIHtcbiAgICAgICAgY29uc3QgZHkgPSBkaXJlY3Rpb24gPT09IFwidG8tdG9wXCIgPyBib3gueSAtIG90aGVyLnkgLSBvdGhlci5oZWlnaHQgOiBib3gueSArIGJveC5oZWlnaHQgLSBvdGhlci55O1xuICAgICAgICBuZXh0LmNhbGxvdXRMYWJlbC5jb2xsaXNpb25PZmZzZXRZID0gZHk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBhdm9pZFlDb2xsaXNpb25zID0gKGxhYmVscykgPT4ge1xuICAgICAgY29uc3QgbWlkTGFiZWwgPSBsYWJlbHMuc2xpY2UoKS5zb3J0KChhLCBiKSA9PiBNYXRoLmFicyhhLm1pZFNpbikgLSBNYXRoLmFicyhiLm1pZFNpbikpWzBdO1xuICAgICAgY29uc3QgbWlkSW5kZXggPSBsYWJlbHMuaW5kZXhPZihtaWRMYWJlbCk7XG4gICAgICBmb3IgKGxldCBpID0gbWlkSW5kZXggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBwcmV2ID0gbGFiZWxzW2kgKyAxXTtcbiAgICAgICAgY29uc3QgbmV4dCA9IGxhYmVsc1tpXTtcbiAgICAgICAgYXZvaWROZWlnaGJvdXJZQ29sbGlzaW9uKHByZXYsIG5leHQsIFwidG8tdG9wXCIpO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IG1pZEluZGV4ICsgMTsgaSA8IGxhYmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwcmV2ID0gbGFiZWxzW2kgLSAxXTtcbiAgICAgICAgY29uc3QgbmV4dCA9IGxhYmVsc1tpXTtcbiAgICAgICAgYXZvaWROZWlnaGJvdXJZQ29sbGlzaW9uKHByZXYsIG5leHQsIFwidG8tYm90dG9tXCIpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgYXZvaWRYQ29sbGlzaW9ucyA9IChsYWJlbHMpID0+IHtcbiAgICAgIGNvbnN0IGxhYmVsc0NvbGxpZGVMYWJlbHNCeVkgPSBkYXRhLnNvbWUoKGRhdHVtKSA9PiBkYXR1bS5jYWxsb3V0TGFiZWwuY29sbGlzaW9uT2Zmc2V0WSAhPT0gMCk7XG4gICAgICBjb25zdCBib3hlcyA9IGxhYmVscy5tYXAoKGxhYmVsKSA9PiBnZXRUZXh0QkJveChsYWJlbCkpO1xuICAgICAgY29uc3QgcGFkZGVkQm94ZXMgPSBib3hlcy5tYXAoKGJveCkgPT4gYm94LmNsb25lKCkuZ3JvdyhtaW5TcGFjaW5nIC8gMikpO1xuICAgICAgbGV0IGxhYmVsc0NvbGxpZGVMYWJlbHNCeVggPSBmYWxzZTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkZGVkQm94ZXMubGVuZ3RoICYmICFsYWJlbHNDb2xsaWRlTGFiZWxzQnlYOyBpKyspIHtcbiAgICAgICAgY29uc3QgYm94ID0gcGFkZGVkQm94ZXNbaV07XG4gICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IGxhYmVscy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNvbnN0IG90aGVyID0gcGFkZGVkQm94ZXNbal07XG4gICAgICAgICAgaWYgKGJveC5jb2xsaWRlc0JCb3gob3RoZXIpKSB7XG4gICAgICAgICAgICBsYWJlbHNDb2xsaWRlTGFiZWxzQnlYID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qgc2VjdG9ycyA9IGZ1bGxEYXRhLm1hcCgoZGF0dW0pID0+IHtcbiAgICAgICAgY29uc3QgeyBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgb3V0ZXJSYWRpdXMgfSA9IGRhdHVtO1xuICAgICAgICByZXR1cm4geyBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzIH07XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGxhYmVsc0NvbGxpZGVTZWN0b3JzID0gYm94ZXMuc29tZSgoYm94KSA9PiB7XG4gICAgICAgIHJldHVybiBzZWN0b3JzLnNvbWUoKHNlY3RvcikgPT4gYm94Q29sbGlkZXNTZWN0b3IoYm94LCBzZWN0b3IpKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKCFsYWJlbHNDb2xsaWRlTGFiZWxzQnlYICYmICFsYWJlbHNDb2xsaWRlTGFiZWxzQnlZICYmICFsYWJlbHNDb2xsaWRlU2VjdG9ycykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsYWJlbHMuZmlsdGVyKChkKSA9PiBkLmNhbGxvdXRMYWJlbC50ZXh0QWxpZ24gPT09IFwiY2VudGVyXCIpLmZvckVhY2goKGQpID0+IHtcbiAgICAgICAgY29uc3QgbGFiZWwgPSBkLmNhbGxvdXRMYWJlbDtcbiAgICAgICAgaWYgKGQubWlkQ29zIDwgMCkge1xuICAgICAgICAgIGxhYmVsLmNvbGxpc2lvblRleHRBbGlnbiA9IFwicmlnaHRcIjtcbiAgICAgICAgfSBlbHNlIGlmIChkLm1pZENvcyA+IDApIHtcbiAgICAgICAgICBsYWJlbC5jb2xsaXNpb25UZXh0QWxpZ24gPSBcImxlZnRcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYWJlbC5jb2xsaXNpb25UZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGF2b2lkWUNvbGxpc2lvbnMobGVmdExhYmVscyk7XG4gICAgYXZvaWRZQ29sbGlzaW9ucyhyaWdodExhYmVscyk7XG4gICAgYXZvaWRYQ29sbGlzaW9ucyh0b3BMYWJlbHMpO1xuICAgIGF2b2lkWENvbGxpc2lvbnMoYm90dG9tTGFiZWxzKTtcbiAgfVxuICB1cGRhdGVDYWxsb3V0TGFiZWxOb2RlcyhzZXJpZXNSZWN0KSB7XG4gICAgY29uc3QgeyByYWRpdXNTY2FsZSB9ID0gdGhpcztcbiAgICBjb25zdCB7IGNhbGxvdXRMYWJlbCwgY2FsbG91dExpbmUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCBjYWxsb3V0TGVuZ3RoID0gY2FsbG91dExpbmUubGVuZ3RoO1xuICAgIGNvbnN0IHsgb2Zmc2V0OiBvZmZzZXQ0LCBjb2xvciB9ID0gY2FsbG91dExhYmVsO1xuICAgIGNvbnN0IHRlbXBUZXh0Tm9kZSA9IG5ldyBUZXh0KCk7XG4gICAgdGhpcy5jYWxsb3V0TGFiZWxTZWxlY3Rpb24uc2VsZWN0QnlUYWcoMSAvKiBMYWJlbCAqLykuZm9yRWFjaCgodGV4dCkgPT4ge1xuICAgICAgY29uc3QgeyBkYXR1bSB9ID0gdGV4dDtcbiAgICAgIGNvbnN0IGxhYmVsID0gZGF0dW0uY2FsbG91dExhYmVsO1xuICAgICAgY29uc3QgcmFkaXVzID0gcmFkaXVzU2NhbGUuY29udmVydChkYXR1bS5yYWRpdXMpO1xuICAgICAgY29uc3Qgb3V0ZXJSYWRpdXMgPSBNYXRoLm1heCgwLCByYWRpdXMpO1xuICAgICAgaWYgKCFsYWJlbD8udGV4dCB8fCBvdXRlclJhZGl1cyA9PT0gMCB8fCBsYWJlbC5oaWRkZW4pIHtcbiAgICAgICAgdGV4dC52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxhYmVsUmFkaXVzID0gb3V0ZXJSYWRpdXMgKyBjYWxsb3V0TGVuZ3RoICsgb2Zmc2V0NDtcbiAgICAgIGNvbnN0IHggPSBkYXR1bS5taWRDb3MgKiBsYWJlbFJhZGl1cztcbiAgICAgIGNvbnN0IHkgPSBkYXR1bS5taWRTaW4gKiBsYWJlbFJhZGl1cyArIGxhYmVsLmNvbGxpc2lvbk9mZnNldFk7XG4gICAgICBjb25zdCBhbGlnbiA9IHtcbiAgICAgICAgdGV4dEFsaWduOiBsYWJlbC5jb2xsaXNpb25UZXh0QWxpZ24gPz8gbGFiZWwudGV4dEFsaWduLFxuICAgICAgICB0ZXh0QmFzZWxpbmU6IGxhYmVsLnRleHRCYXNlbGluZVxuICAgICAgfTtcbiAgICAgIHRlbXBUZXh0Tm9kZS50ZXh0ID0gbGFiZWwudGV4dDtcbiAgICAgIHRlbXBUZXh0Tm9kZS54ID0geDtcbiAgICAgIHRlbXBUZXh0Tm9kZS55ID0geTtcbiAgICAgIHRlbXBUZXh0Tm9kZS5zZXRGb250KHRoaXMucHJvcGVydGllcy5jYWxsb3V0TGFiZWwpO1xuICAgICAgdGVtcFRleHROb2RlLnNldEFsaWduKGFsaWduKTtcbiAgICAgIGNvbnN0IGJveCA9IHRlbXBUZXh0Tm9kZS5nZXRCQm94KCk7XG4gICAgICBsZXQgZGlzcGxheVRleHQgPSBsYWJlbC50ZXh0O1xuICAgICAgbGV0IHZpc2libGUgPSB0cnVlO1xuICAgICAgaWYgKGNhbGxvdXRMYWJlbC5hdm9pZENvbGxpc2lvbnMpIHtcbiAgICAgICAgY29uc3QgeyB0ZXh0TGVuZ3RoLCBoYXNWZXJ0aWNhbE92ZXJmbG93IH0gPSB0aGlzLmdldExhYmVsT3ZlcmZsb3cobGFiZWwudGV4dCwgYm94LCBzZXJpZXNSZWN0KTtcbiAgICAgICAgZGlzcGxheVRleHQgPSBsYWJlbC50ZXh0Lmxlbmd0aCA9PT0gdGV4dExlbmd0aCA/IGxhYmVsLnRleHQgOiBgJHtsYWJlbC50ZXh0LnN1YnN0cmluZygwLCB0ZXh0TGVuZ3RoKX1cXHUyMDI2YDtcbiAgICAgICAgdmlzaWJsZSA9ICFoYXNWZXJ0aWNhbE92ZXJmbG93O1xuICAgICAgfVxuICAgICAgdGV4dC50ZXh0ID0gZGlzcGxheVRleHQ7XG4gICAgICB0ZXh0LnggPSB4O1xuICAgICAgdGV4dC55ID0geTtcbiAgICAgIHRleHQuc2V0Rm9udCh0aGlzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsKTtcbiAgICAgIHRleHQuc2V0QWxpZ24oYWxpZ24pO1xuICAgICAgdGV4dC5maWxsID0gY29sb3I7XG4gICAgICB0ZXh0LnZpc2libGUgPSB2aXNpYmxlO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGNvbXB1dGVMYWJlbHNCQm94KG9wdGlvbnMsIHNlcmllc1JlY3QpIHtcbiAgICBjb25zdCB7IGNhbGxvdXRMYWJlbCwgY2FsbG91dExpbmUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCBjYWxsb3V0TGVuZ3RoID0gY2FsbG91dExpbmUubGVuZ3RoO1xuICAgIGNvbnN0IHsgb2Zmc2V0OiBvZmZzZXQ0LCBtYXhDb2xsaXNpb25PZmZzZXQsIG1pblNwYWNpbmcgfSA9IGNhbGxvdXRMYWJlbDtcbiAgICBpZiAoIWNhbGxvdXRMYWJlbC5hdm9pZENvbGxpc2lvbnMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLm1heWJlUmVmcmVzaE5vZGVEYXRhKCk7XG4gICAgdGhpcy51cGRhdGVSYWRpdXNTY2FsZShmYWxzZSk7XG4gICAgdGhpcy5jb21wdXRlQ2FsbG91dExhYmVsQ29sbGlzaW9uT2Zmc2V0cygpO1xuICAgIGNvbnN0IHRleHRCb3hlcyA9IFtdO1xuICAgIGNvbnN0IHRleHQgPSBuZXcgVGV4dCgpO1xuICAgIGxldCB0aXRsZUJveDtcbiAgICBjb25zdCB7IHRpdGxlIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgaWYgKHRpdGxlPy50ZXh0ICYmIHRpdGxlLmVuYWJsZWQpIHtcbiAgICAgIGNvbnN0IGR5ID0gdGhpcy5nZXRUaXRsZVRyYW5zbGF0aW9uWSgpO1xuICAgICAgaWYgKGlzRmluaXRlKGR5KSkge1xuICAgICAgICB0ZXh0LnRleHQgPSB0aXRsZS50ZXh0O1xuICAgICAgICB0ZXh0LnggPSAwO1xuICAgICAgICB0ZXh0LnkgPSBkeTtcbiAgICAgICAgdGV4dC5zZXRGb250KHRpdGxlKTtcbiAgICAgICAgdGV4dC5zZXRBbGlnbih7XG4gICAgICAgICAgdGV4dEJhc2VsaW5lOiBcImJvdHRvbVwiLFxuICAgICAgICAgIHRleHRBbGlnbjogXCJjZW50ZXJcIlxuICAgICAgICB9KTtcbiAgICAgICAgdGl0bGVCb3ggPSB0ZXh0LmdldEJCb3goKTtcbiAgICAgICAgdGV4dEJveGVzLnB1c2godGl0bGVCb3gpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNhbGxvdXROb2RlRGF0YS5mb3JFYWNoKChkYXR1bSkgPT4ge1xuICAgICAgY29uc3QgbGFiZWwgPSBkYXR1bS5jYWxsb3V0TGFiZWw7XG4gICAgICBpZiAoIWxhYmVsIHx8IGRhdHVtLm91dGVyUmFkaXVzID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgbGFiZWxSYWRpdXMgPSBkYXR1bS5vdXRlclJhZGl1cyArIGNhbGxvdXRMZW5ndGggKyBvZmZzZXQ0O1xuICAgICAgY29uc3QgeCA9IGRhdHVtLm1pZENvcyAqIGxhYmVsUmFkaXVzO1xuICAgICAgY29uc3QgeSA9IGRhdHVtLm1pZFNpbiAqIGxhYmVsUmFkaXVzICsgbGFiZWwuY29sbGlzaW9uT2Zmc2V0WTtcbiAgICAgIHRleHQudGV4dCA9IGxhYmVsLnRleHQ7XG4gICAgICB0ZXh0LnggPSB4O1xuICAgICAgdGV4dC55ID0geTtcbiAgICAgIHRleHQuc2V0Rm9udCh0aGlzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsKTtcbiAgICAgIHRleHQuc2V0QWxpZ24oe1xuICAgICAgICB0ZXh0QWxpZ246IGxhYmVsLmNvbGxpc2lvblRleHRBbGlnbiA/PyBsYWJlbC50ZXh0QWxpZ24sXG4gICAgICAgIHRleHRCYXNlbGluZTogbGFiZWwudGV4dEJhc2VsaW5lXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGJveCA9IHRleHQuZ2V0QkJveCgpO1xuICAgICAgbGFiZWwuYm94ID0gYm94O1xuICAgICAgaWYgKE1hdGguYWJzKGxhYmVsLmNvbGxpc2lvbk9mZnNldFkpID4gbWF4Q29sbGlzaW9uT2Zmc2V0KSB7XG4gICAgICAgIGxhYmVsLmhpZGRlbiA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aXRsZUJveCkge1xuICAgICAgICBjb25zdCBzZXJpZXNUb3AgPSBzZXJpZXNSZWN0LnkgLSB0aGlzLmNlbnRlclk7XG4gICAgICAgIGNvbnN0IHRpdGxlQ2xlYW5BcmVhID0gbmV3IEJCb3goXG4gICAgICAgICAgdGl0bGVCb3gueCAtIG1pblNwYWNpbmcsXG4gICAgICAgICAgc2VyaWVzVG9wLFxuICAgICAgICAgIHRpdGxlQm94LndpZHRoICsgMiAqIG1pblNwYWNpbmcsXG4gICAgICAgICAgdGl0bGVCb3gueSArIHRpdGxlQm94LmhlaWdodCArIG1pblNwYWNpbmcgLSBzZXJpZXNUb3BcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGJveC5jb2xsaWRlc0JCb3godGl0bGVDbGVhbkFyZWEpKSB7XG4gICAgICAgICAgbGFiZWwuaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmhpZGVXaGVuTmVjZXNzYXJ5KSB7XG4gICAgICAgIGNvbnN0IHsgdGV4dExlbmd0aCwgaGFzVmVydGljYWxPdmVyZmxvdywgaGFzU3Vycm91bmRpbmdTZXJpZXNPdmVyZmxvdyB9ID0gdGhpcy5nZXRMYWJlbE92ZXJmbG93KFxuICAgICAgICAgIGxhYmVsLnRleHQsXG4gICAgICAgICAgYm94LFxuICAgICAgICAgIHNlcmllc1JlY3RcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgaXNUb29TaG9ydCA9IGxhYmVsLnRleHQubGVuZ3RoID4gMiAmJiB0ZXh0TGVuZ3RoIDwgMjtcbiAgICAgICAgaWYgKGhhc1ZlcnRpY2FsT3ZlcmZsb3cgfHwgaXNUb29TaG9ydCB8fCBoYXNTdXJyb3VuZGluZ1Nlcmllc092ZXJmbG93KSB7XG4gICAgICAgICAgbGFiZWwuaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxhYmVsLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgdGV4dEJveGVzLnB1c2goYm94KTtcbiAgICB9KTtcbiAgICBpZiAodGV4dEJveGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBCQm94Lm1lcmdlKHRleHRCb3hlcyk7XG4gIH1cbiAgdXBkYXRlU2VjdG9yTGFiZWxOb2RlcygpIHtcbiAgICBjb25zdCB7IHJhZGl1c1NjYWxlIH0gPSB0aGlzO1xuICAgIGNvbnN0IGlubmVyUmFkaXVzID0gcmFkaXVzU2NhbGUuY29udmVydCgwKTtcbiAgICBjb25zdCB7IGZvbnRTaXplLCBmb250U3R5bGUsIGZvbnRXZWlnaHQsIGZvbnRGYW1pbHksIHBvc2l0aW9uT2Zmc2V0LCBwb3NpdGlvblJhdGlvLCBjb2xvciB9ID0gdGhpcy5wcm9wZXJ0aWVzLnNlY3RvckxhYmVsO1xuICAgIGNvbnN0IHVwZGF0ZVNlY3RvckxhYmVsID0gKHRleHQsIGRhdHVtKSA9PiB7XG4gICAgICBjb25zdCB7IHNlY3RvckxhYmVsLCBvdXRlclJhZGl1cyB9ID0gZGF0dW07XG4gICAgICBsZXQgaXNUZXh0VmlzaWJsZSA9IGZhbHNlO1xuICAgICAgaWYgKHNlY3RvckxhYmVsICYmIG91dGVyUmFkaXVzICE9PSAwKSB7XG4gICAgICAgIGNvbnN0IGxhYmVsUmFkaXVzID0gaW5uZXJSYWRpdXMgKiAoMSAtIHBvc2l0aW9uUmF0aW8pICsgb3V0ZXJSYWRpdXMgKiBwb3NpdGlvblJhdGlvICsgcG9zaXRpb25PZmZzZXQ7XG4gICAgICAgIHRleHQuZmlsbCA9IGNvbG9yO1xuICAgICAgICB0ZXh0LmZvbnRTdHlsZSA9IGZvbnRTdHlsZTtcbiAgICAgICAgdGV4dC5mb250V2VpZ2h0ID0gZm9udFdlaWdodDtcbiAgICAgICAgdGV4dC5mb250U2l6ZSA9IGZvbnRTaXplO1xuICAgICAgICB0ZXh0LmZvbnRGYW1pbHkgPSBmb250RmFtaWx5O1xuICAgICAgICB0ZXh0LnRleHQgPSBzZWN0b3JMYWJlbC50ZXh0O1xuICAgICAgICB0ZXh0LnggPSBkYXR1bS5taWRDb3MgKiBsYWJlbFJhZGl1cztcbiAgICAgICAgdGV4dC55ID0gZGF0dW0ubWlkU2luICogbGFiZWxSYWRpdXM7XG4gICAgICAgIHRleHQudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICAgICAgdGV4dC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xuICAgICAgICBjb25zdCBiYm94ID0gdGV4dC5nZXRCQm94KCk7XG4gICAgICAgIGNvbnN0IGNvcm5lcnMgPSBbXG4gICAgICAgICAgW2Jib3gueCwgYmJveC55XSxcbiAgICAgICAgICBbYmJveC54ICsgYmJveC53aWR0aCwgYmJveC55XSxcbiAgICAgICAgICBbYmJveC54ICsgYmJveC53aWR0aCwgYmJveC55ICsgYmJveC5oZWlnaHRdLFxuICAgICAgICAgIFtiYm94LngsIGJib3gueSArIGJib3guaGVpZ2h0XVxuICAgICAgICBdO1xuICAgICAgICBjb25zdCB7IHN0YXJ0QW5nbGUsIGVuZEFuZ2xlIH0gPSBkYXR1bTtcbiAgICAgICAgY29uc3Qgc2VjdG9yQm91bmRzID0geyBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzIH07XG4gICAgICAgIGlmIChjb3JuZXJzLmV2ZXJ5KChbeCwgeV0pID0+IGlzUG9pbnRJblNlY3Rvcih4LCB5LCBzZWN0b3JCb3VuZHMpKSkge1xuICAgICAgICAgIGlzVGV4dFZpc2libGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0ZXh0LnZpc2libGUgPSBpc1RleHRWaXNpYmxlO1xuICAgIH07XG4gICAgdGhpcy5sYWJlbFNlbGVjdGlvbi5lYWNoKHVwZGF0ZVNlY3RvckxhYmVsKTtcbiAgICB0aGlzLmhpZ2hsaWdodExhYmVsU2VsZWN0aW9uLmVhY2godXBkYXRlU2VjdG9yTGFiZWwpO1xuICB9XG4gIHVwZGF0ZUlubmVyTGFiZWxOb2RlcygpIHtcbiAgICBjb25zdCB0ZXh0QkJveGVzID0gW107XG4gICAgY29uc3QgbWFyZ2lucyA9IFtdO1xuICAgIHRoaXMuaW5uZXJMYWJlbHNTZWxlY3Rpb24uZWFjaCgodGV4dCwgZGF0dW0pID0+IHtcbiAgICAgIGNvbnN0IHsgZm9udFN0eWxlLCBmb250V2VpZ2h0LCBmb250U2l6ZSwgZm9udEZhbWlseSwgY29sb3IgfSA9IGRhdHVtO1xuICAgICAgdGV4dC5mb250U3R5bGUgPSBmb250U3R5bGU7XG4gICAgICB0ZXh0LmZvbnRXZWlnaHQgPSBmb250V2VpZ2h0O1xuICAgICAgdGV4dC5mb250U2l6ZSA9IGZvbnRTaXplO1xuICAgICAgdGV4dC5mb250RmFtaWx5ID0gZm9udEZhbWlseTtcbiAgICAgIHRleHQudGV4dCA9IGRhdHVtLnRleHQ7XG4gICAgICB0ZXh0LnggPSAwO1xuICAgICAgdGV4dC55ID0gMDtcbiAgICAgIHRleHQuZmlsbCA9IGNvbG9yO1xuICAgICAgdGV4dC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgdGV4dC50ZXh0QmFzZWxpbmUgPSBcImFscGhhYmV0aWNcIjtcbiAgICAgIHRleHRCQm94ZXMucHVzaCh0ZXh0LmdldEJCb3goKSk7XG4gICAgICBtYXJnaW5zLnB1c2goZGF0dW0uc3BhY2luZyk7XG4gICAgfSk7XG4gICAgY29uc3QgZ2V0TWFyZ2luVG9wID0gKGluZGV4KSA9PiBpbmRleCA9PT0gMCA/IDAgOiBtYXJnaW5zW2luZGV4XTtcbiAgICBjb25zdCBnZXRNYXJnaW5Cb3R0b20gPSAoaW5kZXgpID0+IGluZGV4ID09PSBtYXJnaW5zLmxlbmd0aCAtIDEgPyAwIDogbWFyZ2luc1tpbmRleF07XG4gICAgY29uc3QgdG90YWxIZWlnaHQgPSB0ZXh0QkJveGVzLnJlZHVjZSgoc3VtMiwgYmJveCwgaSkgPT4ge1xuICAgICAgcmV0dXJuIHN1bTIgKyBiYm94LmhlaWdodCArIGdldE1hcmdpblRvcChpKSArIGdldE1hcmdpbkJvdHRvbShpKTtcbiAgICB9LCAwKTtcbiAgICBjb25zdCB0b3RhbFdpZHRoID0gTWF0aC5tYXgoLi4udGV4dEJCb3hlcy5tYXAoKGJib3gpID0+IGJib3gud2lkdGgpKTtcbiAgICBjb25zdCBpbm5lclJhZGl1cyA9IHRoaXMuZ2V0SW5uZXJSYWRpdXMoKTtcbiAgICBjb25zdCBsYWJlbFJhZGl1cyA9IE1hdGguc3FydChNYXRoLnBvdyh0b3RhbFdpZHRoIC8gMiwgMikgKyBNYXRoLnBvdyh0b3RhbEhlaWdodCAvIDIsIDIpKTtcbiAgICBjb25zdCBsYWJlbHNWaXNpYmxlID0gbGFiZWxSYWRpdXMgPD0gKGlubmVyUmFkaXVzID4gMCA/IGlubmVyUmFkaXVzIDogdGhpcy5nZXRPdXRlclJhZGl1cygpKTtcbiAgICBjb25zdCB0ZXh0Qm90dG9tcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBwcmV2ID0gLXRvdGFsSGVpZ2h0IC8gMjsgaSA8IHRleHRCQm94ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGJib3ggPSB0ZXh0QkJveGVzW2ldO1xuICAgICAgY29uc3QgYm90dG9tID0gYmJveC5oZWlnaHQgKyBwcmV2ICsgZ2V0TWFyZ2luVG9wKGkpO1xuICAgICAgdGV4dEJvdHRvbXMucHVzaChib3R0b20pO1xuICAgICAgcHJldiA9IGJvdHRvbSArIGdldE1hcmdpbkJvdHRvbShpKTtcbiAgICB9XG4gICAgdGhpcy5pbm5lckxhYmVsc1NlbGVjdGlvbi5lYWNoKCh0ZXh0LCBfZGF0dW0sIGluZGV4KSA9PiB7XG4gICAgICB0ZXh0LnkgPSB0ZXh0Qm90dG9tc1tpbmRleF07XG4gICAgICB0ZXh0LnZpc2libGUgPSBsYWJlbHNWaXNpYmxlO1xuICAgIH0pO1xuICB9XG4gIHVwZGF0ZVplcm9zdW1SaW5ncygpIHtcbiAgICB0aGlzLnplcm9zdW1PdXRlclJpbmcuc2l6ZSA9IHRoaXMuZ2V0T3V0ZXJSYWRpdXMoKSAqIDI7XG4gICAgdGhpcy56ZXJvc3VtSW5uZXJSaW5nLnNpemUgPSB0aGlzLmdldElubmVyUmFkaXVzKCkgKiAyO1xuICB9XG4gIGdldERhdHVtTGVnZW5kTmFtZShub2RlRGF0dW0pIHtcbiAgICBjb25zdCB7IGFuZ2xlS2V5LCBjYWxsb3V0TGFiZWxLZXksIHNlY3RvckxhYmVsS2V5LCBsZWdlbmRJdGVtS2V5IH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgeyBzZWN0b3JMYWJlbCwgY2FsbG91dExhYmVsLCBsZWdlbmRJdGVtIH0gPSBub2RlRGF0dW07XG4gICAgaWYgKGxlZ2VuZEl0ZW1LZXkgJiYgbGVnZW5kSXRlbSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbGVnZW5kSXRlbS50ZXh0O1xuICAgIH0gZWxzZSBpZiAoY2FsbG91dExhYmVsS2V5ICYmIGNhbGxvdXRMYWJlbEtleSAhPT0gYW5nbGVLZXkgJiYgY2FsbG91dExhYmVsPy50ZXh0ICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBjYWxsb3V0TGFiZWwudGV4dDtcbiAgICB9IGVsc2UgaWYgKHNlY3RvckxhYmVsS2V5ICYmIHNlY3RvckxhYmVsS2V5ICE9PSBhbmdsZUtleSAmJiBzZWN0b3JMYWJlbD8udGV4dCAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gc2VjdG9yTGFiZWwudGV4dDtcbiAgICB9XG4gIH1cbiAgcGlja05vZGVDbG9zZXN0RGF0dW0ocG9pbnQpIHtcbiAgICByZXR1cm4gcGlja0J5TWF0Y2hpbmdBbmdsZSh0aGlzLCBwb2ludCk7XG4gIH1cbiAgZ2V0VG9vbHRpcEh0bWwobm9kZURhdHVtKSB7XG4gICAgaWYgKCF0aGlzLnByb3BlcnRpZXMuaXNWYWxpZCgpKSB7XG4gICAgICByZXR1cm4gRU1QVFlfVE9PTFRJUF9DT05URU5UO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBkYXR1bSxcbiAgICAgIGFuZ2xlVmFsdWUsXG4gICAgICBzZWN0b3JGb3JtYXQ6IHsgZmlsbDogY29sb3IgfSxcbiAgICAgIGl0ZW1JZFxuICAgIH0gPSBub2RlRGF0dW07XG4gICAgY29uc3QgdGl0bGUgPSBzYW5pdGl6ZUh0bWwodGhpcy5wcm9wZXJ0aWVzLnRpdGxlPy50ZXh0KTtcbiAgICBjb25zdCBjb250ZW50ID0gaXNGaW5pdGVOdW1iZXIoYW5nbGVWYWx1ZSkgPyB0b0ZpeGVkKGFuZ2xlVmFsdWUpIDogU3RyaW5nKGFuZ2xlVmFsdWUpO1xuICAgIGNvbnN0IGxhYmVsVGV4dCA9IHRoaXMuZ2V0RGF0dW1MZWdlbmROYW1lKG5vZGVEYXR1bSk7XG4gICAgcmV0dXJuIHRoaXMucHJvcGVydGllcy50b29sdGlwLnRvVG9vbHRpcEh0bWwoXG4gICAgICB7XG4gICAgICAgIHRpdGxlOiB0aXRsZSA/PyBsYWJlbFRleHQsXG4gICAgICAgIGNvbnRlbnQ6IHRpdGxlICYmIGxhYmVsVGV4dCA/IGAke2xhYmVsVGV4dH06ICR7Y29udGVudH1gIDogY29udGVudCxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjb2xvclxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIGl0ZW1JZCxcbiAgICAgICAgdGl0bGUsXG4gICAgICAgIGNvbG9yLFxuICAgICAgICBzZXJpZXNJZDogdGhpcy5pZCxcbiAgICAgICAgYW5nbGVLZXk6IHRoaXMucHJvcGVydGllcy5hbmdsZUtleSxcbiAgICAgICAgYW5nbGVOYW1lOiB0aGlzLnByb3BlcnRpZXMuYW5nbGVOYW1lLFxuICAgICAgICByYWRpdXNLZXk6IHRoaXMucHJvcGVydGllcy5yYWRpdXNLZXksXG4gICAgICAgIHJhZGl1c05hbWU6IHRoaXMucHJvcGVydGllcy5yYWRpdXNOYW1lLFxuICAgICAgICBjYWxsb3V0TGFiZWxLZXk6IHRoaXMucHJvcGVydGllcy5jYWxsb3V0TGFiZWxLZXksXG4gICAgICAgIGNhbGxvdXRMYWJlbE5hbWU6IHRoaXMucHJvcGVydGllcy5jYWxsb3V0TGFiZWxOYW1lLFxuICAgICAgICBzZWN0b3JMYWJlbEtleTogdGhpcy5wcm9wZXJ0aWVzLnNlY3RvckxhYmVsS2V5LFxuICAgICAgICBzZWN0b3JMYWJlbE5hbWU6IHRoaXMucHJvcGVydGllcy5zZWN0b3JMYWJlbE5hbWUsXG4gICAgICAgIGxlZ2VuZEl0ZW1LZXk6IHRoaXMucHJvcGVydGllcy5sZWdlbmRJdGVtS2V5XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBnZXRMZWdlbmREYXRhKGxlZ2VuZFR5cGUpIHtcbiAgICBjb25zdCB7IHZpc2libGUsIHByb2Nlc3NlZERhdGEsIGRhdGFNb2RlbCB9ID0gdGhpcztcbiAgICBpZiAoIWRhdGFNb2RlbCB8fCAhcHJvY2Vzc2VkRGF0YT8uZGF0YS5sZW5ndGggfHwgIXRoaXMucHJvcGVydGllcy5pc1ZhbGlkKCkgfHwgbGVnZW5kVHlwZSAhPT0gXCJjYXRlZ29yeVwiKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IHsgYW5nbGVLZXksIGNhbGxvdXRMYWJlbEtleSwgc2VjdG9yTGFiZWxLZXksIGxlZ2VuZEl0ZW1LZXkgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBpZiAoIWxlZ2VuZEl0ZW1LZXkgJiYgKCFjYWxsb3V0TGFiZWxLZXkgfHwgY2FsbG91dExhYmVsS2V5ID09PSBhbmdsZUtleSkgJiYgKCFzZWN0b3JMYWJlbEtleSB8fCBzZWN0b3JMYWJlbEtleSA9PT0gYW5nbGVLZXkpKVxuICAgICAgcmV0dXJuIFtdO1xuICAgIGNvbnN0IHsgY2FsbG91dExhYmVsSWR4LCBzZWN0b3JMYWJlbElkeCwgbGVnZW5kSXRlbUlkeCB9ID0gdGhpcy5nZXRQcm9jZXNzZWREYXRhSW5kZXhlcyhkYXRhTW9kZWwpO1xuICAgIGNvbnN0IHRpdGxlVGV4dCA9IHRoaXMucHJvcGVydGllcy50aXRsZT8uc2hvd0luTGVnZW5kICYmIHRoaXMucHJvcGVydGllcy50aXRsZS50ZXh0O1xuICAgIGNvbnN0IGxlZ2VuZERhdGEgPSBbXTtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcHJvY2Vzc2VkRGF0YS5kYXRhLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgY29uc3QgeyBkYXR1bSwgdmFsdWVzIH0gPSBwcm9jZXNzZWREYXRhLmRhdGFbaW5kZXhdO1xuICAgICAgY29uc3QgbGFiZWxQYXJ0cyA9IFtdO1xuICAgICAgaWYgKHRpdGxlVGV4dCkge1xuICAgICAgICBsYWJlbFBhcnRzLnB1c2godGl0bGVUZXh0KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKFxuICAgICAgICBkYXR1bSxcbiAgICAgICAgMiAqIE1hdGguUEksXG4gICAgICAgIDIgKiBNYXRoLlBJLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgY2FsbG91dExhYmVsSWR4ICE9IG51bGwgPyB2YWx1ZXNbY2FsbG91dExhYmVsSWR4XSA6IHZvaWQgMCxcbiAgICAgICAgc2VjdG9yTGFiZWxJZHggIT0gbnVsbCA/IHZhbHVlc1tzZWN0b3JMYWJlbElkeF0gOiB2b2lkIDAsXG4gICAgICAgIGxlZ2VuZEl0ZW1JZHggIT0gbnVsbCA/IHZhbHVlc1tsZWdlbmRJdGVtSWR4XSA6IHZvaWQgMFxuICAgICAgKTtcbiAgICAgIGlmIChsZWdlbmRJdGVtS2V5ICYmIGxhYmVscy5sZWdlbmRJdGVtICE9PSB2b2lkIDApIHtcbiAgICAgICAgbGFiZWxQYXJ0cy5wdXNoKGxhYmVscy5sZWdlbmRJdGVtLnRleHQpO1xuICAgICAgfSBlbHNlIGlmIChjYWxsb3V0TGFiZWxLZXkgJiYgY2FsbG91dExhYmVsS2V5ICE9PSBhbmdsZUtleSAmJiBsYWJlbHMuY2FsbG91dExhYmVsPy50ZXh0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgbGFiZWxQYXJ0cy5wdXNoKGxhYmVscy5jYWxsb3V0TGFiZWw/LnRleHQpO1xuICAgICAgfSBlbHNlIGlmIChzZWN0b3JMYWJlbEtleSAmJiBzZWN0b3JMYWJlbEtleSAhPT0gYW5nbGVLZXkgJiYgbGFiZWxzLnNlY3RvckxhYmVsPy50ZXh0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgbGFiZWxQYXJ0cy5wdXNoKGxhYmVscy5zZWN0b3JMYWJlbD8udGV4dCk7XG4gICAgICB9XG4gICAgICBpZiAobGFiZWxQYXJ0cy5sZW5ndGggPT09IDApXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3Qgc2VjdG9yRm9ybWF0ID0gdGhpcy5nZXRTZWN0b3JGb3JtYXQoZGF0dW0sIGluZGV4LCBmYWxzZSk7XG4gICAgICBsZWdlbmREYXRhLnB1c2goe1xuICAgICAgICBsZWdlbmRUeXBlOiBcImNhdGVnb3J5XCIsXG4gICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICBpdGVtSWQ6IGluZGV4LFxuICAgICAgICBzZXJpZXNJZDogdGhpcy5pZCxcbiAgICAgICAgZW5hYmxlZDogdmlzaWJsZSAmJiB0aGlzLmxlZ2VuZEl0ZW1FbmFibGVkW2luZGV4XSxcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICB0ZXh0OiBsYWJlbFBhcnRzLmpvaW4oXCIgLSBcIilcbiAgICAgICAgfSxcbiAgICAgICAgc3ltYm9sczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1hcmtlcjoge1xuICAgICAgICAgICAgICBmaWxsOiBzZWN0b3JGb3JtYXQuZmlsbCxcbiAgICAgICAgICAgICAgc3Ryb2tlOiBzZWN0b3JGb3JtYXQuc3Ryb2tlLFxuICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogdGhpcy5wcm9wZXJ0aWVzLmZpbGxPcGFjaXR5LFxuICAgICAgICAgICAgICBzdHJva2VPcGFjaXR5OiB0aGlzLnByb3BlcnRpZXMuc3Ryb2tlT3BhY2l0eSxcbiAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IHRoaXMucHJvcGVydGllcy5zdHJva2VXaWR0aFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgbGVnZW5kSXRlbU5hbWU6IGxlZ2VuZEl0ZW1LZXkgIT0gbnVsbCA/IGRhdHVtW2xlZ2VuZEl0ZW1LZXldIDogdm9pZCAwXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGxlZ2VuZERhdGE7XG4gIH1cbiAgb25MZWdlbmRJdGVtQ2xpY2soZXZlbnQpIHtcbiAgICBjb25zdCB7IGVuYWJsZWQsIGl0ZW1JZCwgc2VyaWVzLCBsZWdlbmRJdGVtTmFtZSB9ID0gZXZlbnQ7XG4gICAgaWYgKHNlcmllcy5pZCA9PT0gdGhpcy5pZCkge1xuICAgICAgdGhpcy50b2dnbGVTZXJpZXNJdGVtKGl0ZW1JZCwgZW5hYmxlZCk7XG4gICAgfSBlbHNlIGlmIChsZWdlbmRJdGVtTmFtZSAhPSBudWxsKSB7XG4gICAgICB0aGlzLnRvZ2dsZU90aGVyU2VyaWVzSXRlbXMobGVnZW5kSXRlbU5hbWUsIGVuYWJsZWQpO1xuICAgIH1cbiAgfVxuICB0b2dnbGVTZXJpZXNJdGVtKGl0ZW1JZCwgZW5hYmxlZCkge1xuICAgIHRoaXMuc2VyaWVzSXRlbUVuYWJsZWRbaXRlbUlkXSA9IGVuYWJsZWQ7XG4gICAgdGhpcy5sZWdlbmRJdGVtRW5hYmxlZFtpdGVtSWRdID0gZW5hYmxlZDtcbiAgICBpZiAodGhpcy5ub2RlRGF0YVtpdGVtSWRdKSB7XG4gICAgICB0aGlzLm5vZGVEYXRhW2l0ZW1JZF0uZW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgfVxuICAgIHRoaXMubm9kZURhdGFSZWZyZXNoID0gdHJ1ZTtcbiAgfVxuICAvLyBVc2VkIGZvciBncmlkXG4gIHNldExlZ2VuZFN0YXRlKGVuYWJsZWRJdGVtcykge1xuICAgIHRoaXMubGVnZW5kSXRlbUVuYWJsZWQgPSBlbmFibGVkSXRlbXM7XG4gICAgdGhpcy5jdHgudXBkYXRlU2VydmljZS51cGRhdGUoNCAvKiBTRVJJRVNfVVBEQVRFICovKTtcbiAgfVxuICB0b2dnbGVPdGhlclNlcmllc0l0ZW1zKGxlZ2VuZEl0ZW1OYW1lLCBlbmFibGVkKSB7XG4gICAgaWYgKCF0aGlzLnByb3BlcnRpZXMubGVnZW5kSXRlbUtleSB8fCAhdGhpcy5kYXRhTW9kZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGVnZW5kSXRlbUlkeCA9IHRoaXMuZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGBsZWdlbmRJdGVtVmFsdWVgKTtcbiAgICB0aGlzLnByb2Nlc3NlZERhdGE/LmRhdGEuZm9yRWFjaCgoeyB2YWx1ZXMgfSwgZGF0dW1JdGVtSWQpID0+IHtcbiAgICAgIGlmICh2YWx1ZXNbbGVnZW5kSXRlbUlkeF0gPT09IGxlZ2VuZEl0ZW1OYW1lKSB7XG4gICAgICAgIHRoaXMudG9nZ2xlU2VyaWVzSXRlbShkYXR1bUl0ZW1JZCwgZW5hYmxlZCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYW5pbWF0ZUVtcHR5VXBkYXRlUmVhZHkoX2RhdGEpIHtcbiAgICBjb25zdCB7IGFuaW1hdGlvbk1hbmFnZXIgfSA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGZucyA9IHByZXBhcmVQaWVTZXJpZXNBbmltYXRpb25GdW5jdGlvbnMoXG4gICAgICB0cnVlLFxuICAgICAgdGhpcy5wcm9wZXJ0aWVzLnJvdGF0aW9uLFxuICAgICAgdGhpcy5yYWRpdXNTY2FsZSxcbiAgICAgIHRoaXMucHJldmlvdXNSYWRpdXNTY2FsZVxuICAgICk7XG4gICAgZnJvbVRvTW90aW9uKFxuICAgICAgdGhpcy5pZCxcbiAgICAgIFwibm9kZXNcIixcbiAgICAgIGFuaW1hdGlvbk1hbmFnZXIsXG4gICAgICBbdGhpcy5pdGVtU2VsZWN0aW9uLCB0aGlzLmhpZ2hsaWdodFNlbGVjdGlvbiwgdGhpcy5waGFudG9tU2VsZWN0aW9uXSxcbiAgICAgIGZucy5ub2RlcyxcbiAgICAgIChfLCBkYXR1bSkgPT4gdGhpcy5nZXREYXR1bUlkKGRhdHVtKVxuICAgICk7XG4gICAgZnJvbVRvTW90aW9uKHRoaXMuaWQsIGBpbm5lckNpcmNsZWAsIGFuaW1hdGlvbk1hbmFnZXIsIFt0aGlzLmlubmVyQ2lyY2xlU2VsZWN0aW9uXSwgZm5zLmlubmVyQ2lyY2xlKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImNhbGxvdXRcIiwgYW5pbWF0aW9uTWFuYWdlciwgdGhpcy5jYWxsb3V0TGFiZWxTZWxlY3Rpb24pO1xuICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwic2VjdG9yXCIsIGFuaW1hdGlvbk1hbmFnZXIsIHRoaXMubGFiZWxTZWxlY3Rpb24pO1xuICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwiaGlnaGxpZ2h0XCIsIGFuaW1hdGlvbk1hbmFnZXIsIHRoaXMuaGlnaGxpZ2h0TGFiZWxTZWxlY3Rpb24pO1xuICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwiaW5uZXJcIiwgYW5pbWF0aW9uTWFuYWdlciwgdGhpcy5pbm5lckxhYmVsc1NlbGVjdGlvbik7XG4gICAgdGhpcy5wcmV2aW91c1JhZGl1c1NjYWxlLnJhbmdlID0gdGhpcy5yYWRpdXNTY2FsZS5yYW5nZTtcbiAgfVxuICBhbmltYXRlV2FpdGluZ1VwZGF0ZVJlYWR5KCkge1xuICAgIGNvbnN0IHsgaXRlbVNlbGVjdGlvbiwgaGlnaGxpZ2h0U2VsZWN0aW9uLCBwaGFudG9tU2VsZWN0aW9uLCBwcm9jZXNzZWREYXRhLCByYWRpdXNTY2FsZSwgcHJldmlvdXNSYWRpdXNTY2FsZSB9ID0gdGhpcztcbiAgICBjb25zdCB7IGFuaW1hdGlvbk1hbmFnZXIgfSA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGRhdGFEaWZmID0gcHJvY2Vzc2VkRGF0YT8ucmVkdWNlZD8uZGlmZjtcbiAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLnN0b3BCeUFuaW1hdGlvbkdyb3VwSWQodGhpcy5pZCk7XG4gICAgY29uc3Qgc3VwcG9ydGVkRGlmZiA9IChkYXRhRGlmZj8ubW92ZWQuc2l6ZSA/PyAwKSA9PT0gMDtcbiAgICBjb25zdCBoYXNLZXlzID0gKHByb2Nlc3NlZERhdGE/LmRlZnMua2V5cy5sZW5ndGggPz8gMCkgPiAwO1xuICAgIGNvbnN0IGhhc1VuaXF1ZUtleXMgPSBwcm9jZXNzZWREYXRhPy5yZWR1Y2VkPy5hbmltYXRpb25WYWxpZGF0aW9uPy51bmlxdWVLZXlzID8/IHRydWU7XG4gICAgaWYgKCFzdXBwb3J0ZWREaWZmIHx8ICFoYXNLZXlzIHx8ICFoYXNVbmlxdWVLZXlzKSB7XG4gICAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLnNraXBDdXJyZW50QmF0Y2goKTtcbiAgICB9XG4gICAgY29uc3QgZm5zID0gcHJlcGFyZVBpZVNlcmllc0FuaW1hdGlvbkZ1bmN0aW9ucyhcbiAgICAgIGZhbHNlLFxuICAgICAgdGhpcy5wcm9wZXJ0aWVzLnJvdGF0aW9uLFxuICAgICAgcmFkaXVzU2NhbGUsXG4gICAgICBwcmV2aW91c1JhZGl1c1NjYWxlXG4gICAgKTtcbiAgICBmcm9tVG9Nb3Rpb24oXG4gICAgICB0aGlzLmlkLFxuICAgICAgXCJub2Rlc1wiLFxuICAgICAgYW5pbWF0aW9uTWFuYWdlcixcbiAgICAgIFtpdGVtU2VsZWN0aW9uLCBoaWdobGlnaHRTZWxlY3Rpb24sIHBoYW50b21TZWxlY3Rpb25dLFxuICAgICAgZm5zLm5vZGVzLFxuICAgICAgKF8sIGRhdHVtKSA9PiB0aGlzLmdldERhdHVtSWQoZGF0dW0pLFxuICAgICAgZGF0YURpZmZcbiAgICApO1xuICAgIGZyb21Ub01vdGlvbih0aGlzLmlkLCBgaW5uZXJDaXJjbGVgLCBhbmltYXRpb25NYW5hZ2VyLCBbdGhpcy5pbm5lckNpcmNsZVNlbGVjdGlvbl0sIGZucy5pbm5lckNpcmNsZSk7XG4gICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJjYWxsb3V0XCIsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIHRoaXMuY2FsbG91dExhYmVsU2VsZWN0aW9uKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcInNlY3RvclwiLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCB0aGlzLmxhYmVsU2VsZWN0aW9uKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImhpZ2hsaWdodFwiLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCB0aGlzLmhpZ2hsaWdodExhYmVsU2VsZWN0aW9uKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImlubmVyXCIsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIHRoaXMuaW5uZXJMYWJlbHNTZWxlY3Rpb24pO1xuICAgIHRoaXMucHJldmlvdXNSYWRpdXNTY2FsZS5yYW5nZSA9IHRoaXMucmFkaXVzU2NhbGUucmFuZ2U7XG4gIH1cbiAgYW5pbWF0ZUNsZWFyaW5nVXBkYXRlRW1wdHkoKSB7XG4gICAgY29uc3QgeyBpdGVtU2VsZWN0aW9uLCBoaWdobGlnaHRTZWxlY3Rpb24sIHBoYW50b21TZWxlY3Rpb24sIHJhZGl1c1NjYWxlLCBwcmV2aW91c1JhZGl1c1NjYWxlIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgYW5pbWF0aW9uTWFuYWdlciB9ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgZm5zID0gcHJlcGFyZVBpZVNlcmllc0FuaW1hdGlvbkZ1bmN0aW9ucyhcbiAgICAgIGZhbHNlLFxuICAgICAgdGhpcy5wcm9wZXJ0aWVzLnJvdGF0aW9uLFxuICAgICAgcmFkaXVzU2NhbGUsXG4gICAgICBwcmV2aW91c1JhZGl1c1NjYWxlXG4gICAgKTtcbiAgICBmcm9tVG9Nb3Rpb24oXG4gICAgICB0aGlzLmlkLFxuICAgICAgXCJub2Rlc1wiLFxuICAgICAgYW5pbWF0aW9uTWFuYWdlcixcbiAgICAgIFtpdGVtU2VsZWN0aW9uLCBoaWdobGlnaHRTZWxlY3Rpb24sIHBoYW50b21TZWxlY3Rpb25dLFxuICAgICAgZm5zLm5vZGVzLFxuICAgICAgKF8sIGRhdHVtKSA9PiB0aGlzLmdldERhdHVtSWQoZGF0dW0pXG4gICAgKTtcbiAgICBmcm9tVG9Nb3Rpb24odGhpcy5pZCwgYGlubmVyQ2lyY2xlYCwgYW5pbWF0aW9uTWFuYWdlciwgW3RoaXMuaW5uZXJDaXJjbGVTZWxlY3Rpb25dLCBmbnMuaW5uZXJDaXJjbGUpO1xuICAgIHNlcmllc0xhYmVsRmFkZU91dEFuaW1hdGlvbih0aGlzLCBcImNhbGxvdXRcIiwgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgdGhpcy5jYWxsb3V0TGFiZWxTZWxlY3Rpb24pO1xuICAgIHNlcmllc0xhYmVsRmFkZU91dEFuaW1hdGlvbih0aGlzLCBcInNlY3RvclwiLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCB0aGlzLmxhYmVsU2VsZWN0aW9uKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVPdXRBbmltYXRpb24odGhpcywgXCJoaWdobGlnaHRcIiwgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgdGhpcy5oaWdobGlnaHRMYWJlbFNlbGVjdGlvbik7XG4gICAgc2VyaWVzTGFiZWxGYWRlT3V0QW5pbWF0aW9uKHRoaXMsIFwiaW5uZXJcIiwgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgdGhpcy5pbm5lckxhYmVsc1NlbGVjdGlvbik7XG4gICAgdGhpcy5wcmV2aW91c1JhZGl1c1NjYWxlLnJhbmdlID0gdGhpcy5yYWRpdXNTY2FsZS5yYW5nZTtcbiAgfVxuICBnZXREYXR1bUlkRnJvbURhdGEoZGF0dW0pIHtcbiAgICBjb25zdCB7IGNhbGxvdXRMYWJlbEtleSwgc2VjdG9yTGFiZWxLZXksIGxlZ2VuZEl0ZW1LZXkgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBpZiAoIXRoaXMucHJvY2Vzc2VkRGF0YT8ucmVkdWNlZD8uYW5pbWF0aW9uVmFsaWRhdGlvbj8udW5pcXVlS2V5cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobGVnZW5kSXRlbUtleSkge1xuICAgICAgcmV0dXJuIGRhdHVtW2xlZ2VuZEl0ZW1LZXldO1xuICAgIH0gZWxzZSBpZiAoY2FsbG91dExhYmVsS2V5KSB7XG4gICAgICByZXR1cm4gZGF0dW1bY2FsbG91dExhYmVsS2V5XTtcbiAgICB9IGVsc2UgaWYgKHNlY3RvckxhYmVsS2V5KSB7XG4gICAgICByZXR1cm4gZGF0dW1bc2VjdG9yTGFiZWxLZXldO1xuICAgIH1cbiAgfVxuICBnZXREYXR1bUlkKGRhdHVtKSB7XG4gICAgY29uc3QgeyBpbmRleCB9ID0gZGF0dW07XG4gICAgY29uc3QgZGF0dW1JZCA9IHRoaXMuZ2V0RGF0dW1JZEZyb21EYXRhKGRhdHVtLmRhdHVtKTtcbiAgICByZXR1cm4gZGF0dW1JZCAhPSBudWxsID8gU3RyaW5nKGRhdHVtSWQpIDogYCR7aW5kZXh9YDtcbiAgfVxuICBvbkRhdGFDaGFuZ2UoKSB7XG4gICAgY29uc3QgeyBkYXRhLCBzZXJpZXNJdGVtRW5hYmxlZCwgbGVnZW5kSXRlbUVuYWJsZWQgfSA9IHRoaXM7XG4gICAgdGhpcy5zZXJpZXNJdGVtRW5hYmxlZCA9IGRhdGE/Lm1hcCgoXywgaW5kZXgpID0+IHNlcmllc0l0ZW1FbmFibGVkW2luZGV4XSA/PyB0cnVlKSA/PyBbXTtcbiAgICB0aGlzLmxlZ2VuZEl0ZW1FbmFibGVkID0gZGF0YT8ubWFwKChfLCBpbmRleCkgPT4gbGVnZW5kSXRlbUVuYWJsZWRbaW5kZXhdID8/IHRydWUpID8/IFtdO1xuICB9XG59O1xuRG9udXRTZXJpZXMuY2xhc3NOYW1lID0gXCJEb251dFNlcmllc1wiO1xuRG9udXRTZXJpZXMudHlwZSA9IFwiZG9udXRcIjtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL3BvbGFyL2RvbnV0VGhlbWUudHNcbnZhciBkb251dFRoZW1lID0ge1xuICBzZXJpZXM6IHtcbiAgICB0aXRsZToge1xuICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgIGZvbnRXZWlnaHQ6IFwibm9ybWFsXCIgLyogTk9STUFMICovLFxuICAgICAgZm9udFNpemU6IDE0LFxuICAgICAgZm9udEZhbWlseTogREVGQVVMVF9GT05UX0ZBTUlMWSxcbiAgICAgIGNvbG9yOiBERUZBVUxUX01VVEVEX0xBQkVMX0NPTE9VUixcbiAgICAgIHNwYWNpbmc6IDVcbiAgICB9LFxuICAgIGNhbGxvdXRMYWJlbDoge1xuICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgIGZvbnRTaXplOiAxMiAvKiBTTUFMTCAqLyxcbiAgICAgIGZvbnRGYW1pbHk6IERFRkFVTFRfRk9OVF9GQU1JTFksXG4gICAgICBjb2xvcjogREVGQVVMVF9MQUJFTF9DT0xPVVIsXG4gICAgICBvZmZzZXQ6IDMsXG4gICAgICBtaW5BbmdsZTogMFxuICAgIH0sXG4gICAgc2VjdG9yTGFiZWw6IHtcbiAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICBmb250V2VpZ2h0OiBcIm5vcm1hbFwiIC8qIE5PUk1BTCAqLyxcbiAgICAgIGZvbnRTaXplOiAxMiAvKiBTTUFMTCAqLyxcbiAgICAgIGZvbnRGYW1pbHk6IERFRkFVTFRfRk9OVF9GQU1JTFksXG4gICAgICBjb2xvcjogREVGQVVMVF9JTlNJREVfU0VSSUVTX0xBQkVMX0NPTE9VUixcbiAgICAgIHBvc2l0aW9uT2Zmc2V0OiAwLFxuICAgICAgcG9zaXRpb25SYXRpbzogMC41XG4gICAgfSxcbiAgICBjYWxsb3V0TGluZToge1xuICAgICAgbGVuZ3RoOiAxMCxcbiAgICAgIHN0cm9rZVdpZHRoOiAyXG4gICAgfSxcbiAgICBmaWxsT3BhY2l0eTogMSxcbiAgICBzdHJva2VPcGFjaXR5OiAxLFxuICAgIHN0cm9rZVdpZHRoOiAwLFxuICAgIGxpbmVEYXNoOiBbMF0sXG4gICAgbGluZURhc2hPZmZzZXQ6IDAsXG4gICAgcm90YXRpb246IDAsXG4gICAgc2VjdG9yU3BhY2luZzogMSxcbiAgICBzaGFkb3c6IHtcbiAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgY29sb3I6IERFRkFVTFRfU0hBRE9XX0NPTE9VUixcbiAgICAgIHhPZmZzZXQ6IDMsXG4gICAgICB5T2Zmc2V0OiAzLFxuICAgICAgYmx1cjogNVxuICAgIH0sXG4gICAgaW5uZXJMYWJlbHM6IHtcbiAgICAgIGZvbnRTaXplOiAxMiAvKiBTTUFMTCAqLyxcbiAgICAgIGZvbnRGYW1pbHk6IERFRkFVTFRfRk9OVF9GQU1JTFksXG4gICAgICBjb2xvcjogREVGQVVMVF9MQUJFTF9DT0xPVVIsXG4gICAgICBzcGFjaW5nOiAyXG4gICAgfVxuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvcG9sYXIvcGllVGhlbWUudHNcbnZhciBwaWVUaGVtZSA9IHtcbiAgc2VyaWVzOiB7XG4gICAgdGl0bGU6IHtcbiAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICBmb250V2VpZ2h0OiBcIm5vcm1hbFwiIC8qIE5PUk1BTCAqLyxcbiAgICAgIGZvbnRTaXplOiAxNCxcbiAgICAgIGZvbnRGYW1pbHk6IERFRkFVTFRfRk9OVF9GQU1JTFksXG4gICAgICBjb2xvcjogREVGQVVMVF9NVVRFRF9MQUJFTF9DT0xPVVIsXG4gICAgICBzcGFjaW5nOiA1XG4gICAgfSxcbiAgICBjYWxsb3V0TGFiZWw6IHtcbiAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICBmb250U2l6ZTogMTIgLyogU01BTEwgKi8sXG4gICAgICBmb250RmFtaWx5OiBERUZBVUxUX0ZPTlRfRkFNSUxZLFxuICAgICAgY29sb3I6IERFRkFVTFRfTEFCRUxfQ09MT1VSLFxuICAgICAgb2Zmc2V0OiAzLFxuICAgICAgbWluQW5nbGU6IDBcbiAgICB9LFxuICAgIHNlY3RvckxhYmVsOiB7XG4gICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgZm9udFdlaWdodDogXCJub3JtYWxcIiAvKiBOT1JNQUwgKi8sXG4gICAgICBmb250U2l6ZTogMTIgLyogU01BTEwgKi8sXG4gICAgICBmb250RmFtaWx5OiBERUZBVUxUX0ZPTlRfRkFNSUxZLFxuICAgICAgY29sb3I6IERFRkFVTFRfSU5TSURFX1NFUklFU19MQUJFTF9DT0xPVVIsXG4gICAgICBwb3NpdGlvbk9mZnNldDogMCxcbiAgICAgIHBvc2l0aW9uUmF0aW86IDAuNVxuICAgIH0sXG4gICAgY2FsbG91dExpbmU6IHtcbiAgICAgIGxlbmd0aDogMTAsXG4gICAgICBzdHJva2VXaWR0aDogMlxuICAgIH0sXG4gICAgZmlsbE9wYWNpdHk6IDEsXG4gICAgc3Ryb2tlT3BhY2l0eTogMSxcbiAgICBzdHJva2VXaWR0aDogMCxcbiAgICBsaW5lRGFzaDogWzBdLFxuICAgIGxpbmVEYXNoT2Zmc2V0OiAwLFxuICAgIHJvdGF0aW9uOiAwLFxuICAgIHNlY3RvclNwYWNpbmc6IDEsXG4gICAgc2hhZG93OiB7XG4gICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgIGNvbG9yOiBERUZBVUxUX1NIQURPV19DT0xPVVIsXG4gICAgICB4T2Zmc2V0OiAzLFxuICAgICAgeU9mZnNldDogMyxcbiAgICAgIGJsdXI6IDVcbiAgICB9XG4gIH1cbn07XG52YXIgcGllUGFsZXR0ZUZhY3RvcnkgPSAoeyB0YWtlQ29sb3JzLCBjb2xvcnNDb3VudCB9KSA9PiB7XG4gIGNvbnN0IHsgZmlsbHMsIHN0cm9rZXMgfSA9IHRha2VDb2xvcnMoY29sb3JzQ291bnQpO1xuICByZXR1cm4geyBmaWxscywgc3Ryb2tlcywgY2FsbG91dExpbmU6IHsgY29sb3JzOiBzdHJva2VzIH0gfTtcbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9wb2xhci9kb251dFNlcmllc01vZHVsZS50c1xudmFyIERvbnV0U2VyaWVzTW9kdWxlID0ge1xuICB0eXBlOiBcInNlcmllc1wiLFxuICBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsXG4gIHBhY2thZ2VUeXBlOiBcImNvbW11bml0eVwiLFxuICBjaGFydFR5cGVzOiBbXCJwb2xhclwiXSxcbiAgaWRlbnRpZmllcjogXCJkb251dFwiLFxuICBtb2R1bGVGYWN0b3J5OiAoY3R4KSA9PiBuZXcgRG9udXRTZXJpZXMoY3R4KSxcbiAgdG9vbHRpcERlZmF1bHRzOiB7IHJhbmdlOiBcImV4YWN0XCIgfSxcbiAgdGhlbWVUZW1wbGF0ZTogZG9udXRUaGVtZSxcbiAgcGFsZXR0ZUZhY3Rvcnk6IHBpZVBhbGV0dGVGYWN0b3J5XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvcG9sYXIvcGllU2VyaWVzUHJvcGVydGllcy50c1xudmFyIFBpZVRpdGxlID0gY2xhc3MgZXh0ZW5kcyBDYXB0aW9uIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnNob3dJbkxlZ2VuZCA9IGZhbHNlO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIFBpZVRpdGxlLnByb3RvdHlwZSwgXCJzaG93SW5MZWdlbmRcIiwgMik7XG52YXIgUGllU2VyaWVzQ2FsbG91dExhYmVsID0gY2xhc3MgZXh0ZW5kcyBMYWJlbCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5vZmZzZXQgPSAzO1xuICAgIHRoaXMubWluQW5nbGUgPSAwO1xuICAgIHRoaXMubWluU3BhY2luZyA9IDQ7XG4gICAgdGhpcy5tYXhDb2xsaXNpb25PZmZzZXQgPSA1MDtcbiAgICB0aGlzLmF2b2lkQ29sbGlzaW9ucyA9IHRydWU7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBQaWVTZXJpZXNDYWxsb3V0TGFiZWwucHJvdG90eXBlLCBcIm9mZnNldFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKERFR1JFRSlcbl0sIFBpZVNlcmllc0NhbGxvdXRMYWJlbC5wcm90b3R5cGUsIFwibWluQW5nbGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBQaWVTZXJpZXNDYWxsb3V0TGFiZWwucHJvdG90eXBlLCBcIm1pblNwYWNpbmdcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBQaWVTZXJpZXNDYWxsb3V0TGFiZWwucHJvdG90eXBlLCBcIm1heENvbGxpc2lvbk9mZnNldFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBQaWVTZXJpZXNDYWxsb3V0TGFiZWwucHJvdG90eXBlLCBcImF2b2lkQ29sbGlzaW9uc1wiLCAyKTtcbnZhciBQaWVTZXJpZXNTZWN0b3JMYWJlbCA9IGNsYXNzIGV4dGVuZHMgTGFiZWwge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMucG9zaXRpb25PZmZzZXQgPSAwO1xuICAgIHRoaXMucG9zaXRpb25SYXRpbyA9IDAuNTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE5VTUJFUilcbl0sIFBpZVNlcmllc1NlY3RvckxhYmVsLnByb3RvdHlwZSwgXCJwb3NpdGlvbk9mZnNldFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPKVxuXSwgUGllU2VyaWVzU2VjdG9yTGFiZWwucHJvdG90eXBlLCBcInBvc2l0aW9uUmF0aW9cIiwgMik7XG52YXIgUGllU2VyaWVzQ2FsbG91dExpbmUgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmxlbmd0aCA9IDEwO1xuICAgIHRoaXMuc3Ryb2tlV2lkdGggPSAxO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HX0FSUkFZLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBQaWVTZXJpZXNDYWxsb3V0TGluZS5wcm90b3R5cGUsIFwiY29sb3JzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgUGllU2VyaWVzQ2FsbG91dExpbmUucHJvdG90eXBlLCBcImxlbmd0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIFBpZVNlcmllc0NhbGxvdXRMaW5lLnByb3RvdHlwZSwgXCJzdHJva2VXaWR0aFwiLCAyKTtcbnZhciBQaWVTZXJpZXNQcm9wZXJ0aWVzID0gY2xhc3MgZXh0ZW5kcyBTZXJpZXNQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmZpbGxzID0gT2JqZWN0LnZhbHVlcyhERUZBVUxUX0ZJTExTKTtcbiAgICB0aGlzLnN0cm9rZXMgPSBPYmplY3QudmFsdWVzKERFRkFVTFRfU1RST0tFUyk7XG4gICAgdGhpcy5maWxsT3BhY2l0eSA9IDE7XG4gICAgdGhpcy5zdHJva2VPcGFjaXR5ID0gMTtcbiAgICB0aGlzLmxpbmVEYXNoID0gWzBdO1xuICAgIHRoaXMubGluZURhc2hPZmZzZXQgPSAwO1xuICAgIHRoaXMuY29ybmVyUmFkaXVzID0gMDtcbiAgICB0aGlzLnJvdGF0aW9uID0gMDtcbiAgICB0aGlzLm91dGVyUmFkaXVzT2Zmc2V0ID0gMDtcbiAgICB0aGlzLm91dGVyUmFkaXVzUmF0aW8gPSAxO1xuICAgIHRoaXMuc3Ryb2tlV2lkdGggPSAxO1xuICAgIHRoaXMuc2VjdG9yU3BhY2luZyA9IDA7XG4gICAgdGhpcy50aXRsZSA9IG5ldyBQaWVUaXRsZSgpO1xuICAgIHRoaXMuc2hhZG93ID0gbmV3IERyb3BTaGFkb3coKTtcbiAgICB0aGlzLmNhbGxvdXRMYWJlbCA9IG5ldyBQaWVTZXJpZXNDYWxsb3V0TGFiZWwoKTtcbiAgICB0aGlzLnNlY3RvckxhYmVsID0gbmV3IFBpZVNlcmllc1NlY3RvckxhYmVsKCk7XG4gICAgdGhpcy5jYWxsb3V0TGluZSA9IG5ldyBQaWVTZXJpZXNDYWxsb3V0TGluZSgpO1xuICAgIHRoaXMudG9vbHRpcCA9IG5ldyBTZXJpZXNUb29sdGlwKCk7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcpXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJhbmdsZUtleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiYW5nbGVOYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJhbmdsZUZpbHRlcktleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwicmFkaXVzS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJyYWRpdXNOYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJyYWRpdXNNaW5cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInJhZGl1c01heFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiY2FsbG91dExhYmVsS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjYWxsb3V0TGFiZWxOYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzZWN0b3JMYWJlbEtleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic2VjdG9yTGFiZWxOYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJsZWdlbmRJdGVtS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HX0FSUkFZKVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiZmlsbHNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkdfQVJSQVkpXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdHJva2VzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8pXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJmaWxsT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPKVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic3Ryb2tlT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKExJTkVfREFTSClcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImxpbmVEYXNoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGluZURhc2hPZmZzZXRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjb3JuZXJSYWRpdXNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGVU5DVElPTiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiaXRlbVN0eWxlclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKERFR1JFRSlcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInJvdGF0aW9uXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTlVNQkVSKVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwib3V0ZXJSYWRpdXNPZmZzZXRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTylcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcIm91dGVyUmFkaXVzUmF0aW9cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdHJva2VXaWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE5VTUJFUilcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInNlY3RvclNwYWNpbmdcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ0aXRsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInNoYWRvd1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNhbGxvdXRMYWJlbFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInNlY3RvckxhYmVsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiY2FsbG91dExpbmVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ0b29sdGlwXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvcG9sYXIvcGllU2VyaWVzLnRzXG52YXIgUGllU2VyaWVzTm9kZUV2ZW50ID0gY2xhc3MgZXh0ZW5kcyBTZXJpZXNOb2RlRXZlbnQge1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBuYXRpdmVFdmVudCwgZGF0dW0sIHNlcmllcykge1xuICAgIHN1cGVyKHR5cGUsIG5hdGl2ZUV2ZW50LCBkYXR1bSwgc2VyaWVzKTtcbiAgICB0aGlzLmFuZ2xlS2V5ID0gc2VyaWVzLnByb3BlcnRpZXMuYW5nbGVLZXk7XG4gICAgdGhpcy5yYWRpdXNLZXkgPSBzZXJpZXMucHJvcGVydGllcy5yYWRpdXNLZXk7XG4gICAgdGhpcy5jYWxsb3V0TGFiZWxLZXkgPSBzZXJpZXMucHJvcGVydGllcy5jYWxsb3V0TGFiZWxLZXk7XG4gICAgdGhpcy5zZWN0b3JMYWJlbEtleSA9IHNlcmllcy5wcm9wZXJ0aWVzLnNlY3RvckxhYmVsS2V5O1xuICB9XG59O1xudmFyIFBpZVNlcmllcyA9IGNsYXNzIGV4dGVuZHMgUG9sYXJTZXJpZXMge1xuICBjb25zdHJ1Y3Rvcihtb2R1bGVDdHgpIHtcbiAgICBzdXBlcih7XG4gICAgICBtb2R1bGVDdHgsXG4gICAgICBwaWNrTW9kZXM6IFsxIC8qIE5FQVJFU1RfTk9ERSAqLywgMCAvKiBFWEFDVF9TSEFQRV9NQVRDSCAqL10sXG4gICAgICB1c2VMYWJlbExheWVyOiB0cnVlLFxuICAgICAgYW5pbWF0aW9uUmVzZXRGbnM6IHsgaXRlbTogcmVzZXRQaWVTZWxlY3Rpb25zRm4sIGxhYmVsOiByZXNldExhYmVsRm4gfVxuICAgIH0pO1xuICAgIHRoaXMucHJvcGVydGllcyA9IG5ldyBQaWVTZXJpZXNQcm9wZXJ0aWVzKCk7XG4gICAgdGhpcy5waGFudG9tTm9kZURhdGEgPSB2b2lkIDA7XG4gICAgdGhpcy5wcmV2aW91c1JhZGl1c1NjYWxlID0gbmV3IExpbmVhclNjYWxlKCk7XG4gICAgdGhpcy5yYWRpdXNTY2FsZSA9IG5ldyBMaW5lYXJTY2FsZSgpO1xuICAgIHRoaXMucGhhbnRvbUdyb3VwID0gdGhpcy5jb250ZW50R3JvdXAuYXBwZW5kQ2hpbGQobmV3IEdyb3VwKCkpO1xuICAgIHRoaXMucGhhbnRvbVNlbGVjdGlvbiA9IFNlbGVjdGlvbi5zZWxlY3QoXG4gICAgICB0aGlzLnBoYW50b21Hcm91cCxcbiAgICAgICgpID0+IHRoaXMubm9kZUZhY3RvcnkoKSxcbiAgICAgIGZhbHNlXG4gICAgKTtcbiAgICB0aGlzLmNhbGxvdXRMYWJlbEdyb3VwID0gdGhpcy5jb250ZW50R3JvdXAuYXBwZW5kQ2hpbGQobmV3IEdyb3VwKHsgbmFtZTogXCJwaWVDYWxsb3V0TGFiZWxzXCIgfSkpO1xuICAgIHRoaXMuY2FsbG91dExhYmVsU2VsZWN0aW9uID0gbmV3IFNlbGVjdGlvbihcbiAgICAgIHRoaXMuY2FsbG91dExhYmVsR3JvdXAsXG4gICAgICBHcm91cFxuICAgICk7XG4gICAgLy8gVGhlIGdyb3VwIG5vZGUgdGhhdCBjb250YWlucyB0aGUgYmFja2dyb3VuZCBncmFwaGljcy5cbiAgICB0aGlzLmJhY2tncm91bmRHcm91cCA9IHRoaXMucm9vdEdyb3VwLmFwcGVuZENoaWxkKFxuICAgICAgbmV3IFRyYW5zbGF0YWJsZUxheWVyKHtcbiAgICAgICAgbmFtZTogYCR7dGhpcy5pZH0tYmFja2dyb3VuZGAsXG4gICAgICAgIHpJbmRleDogMCAvKiBTRVJJRVNfQkFDS0dST1VORCAqL1xuICAgICAgfSlcbiAgICApO1xuICAgIC8vIEFHLTYxOTMgSWYgdGhlIHN1bSBvZiBhbGwgZGF0dW1zIGlzIDAsIHRoZW4gd2UnbGwgZHJhdyAxIG9yIDIgcmluZ3MgdG8gcmVwcmVzZW50IHRoZSBlbXB0eSBzZXJpZXMuXG4gICAgdGhpcy56ZXJvc3VtUmluZ3NHcm91cCA9IHRoaXMuYmFja2dyb3VuZEdyb3VwLmFwcGVuZENoaWxkKG5ldyBHcm91cCh7IG5hbWU6IGAke3RoaXMuaWR9LXplcm9zdW1SaW5nc2AgfSkpO1xuICAgIHRoaXMuemVyb3N1bU91dGVyUmluZyA9IHRoaXMuemVyb3N1bVJpbmdzR3JvdXAuYXBwZW5kQ2hpbGQobmV3IENpcmNsZSgpKTtcbiAgICAvLyBXaGVuIGEgdXNlciB0b2dnbGVzIGEgc2VyaWVzIGl0ZW0gKGUuZy4gZnJvbSB0aGUgbGVnZW5kKSwgaXRzIGJvb2xlYW4gc3RhdGUgaXMgcmVjb3JkZWQgaGVyZS5cbiAgICB0aGlzLnNlcmllc0l0ZW1FbmFibGVkID0gW107XG4gICAgdGhpcy5sZWdlbmRJdGVtRW5hYmxlZCA9IFtdO1xuICAgIHRoaXMuc3Vycm91bmRpbmdSYWRpdXMgPSB2b2lkIDA7XG4gICAgdGhpcy5Ob2RlRXZlbnQgPSBQaWVTZXJpZXNOb2RlRXZlbnQ7XG4gICAgdGhpcy5hbmdsZVNjYWxlID0gbmV3IExpbmVhclNjYWxlKCk7XG4gICAgdGhpcy5hbmdsZVNjYWxlLmRvbWFpbiA9IFswLCAxXTtcbiAgICB0aGlzLmFuZ2xlU2NhbGUucmFuZ2UgPSBbLU1hdGguUEksIE1hdGguUEldLm1hcCgoYW5nbGUyKSA9PiBhbmdsZTIgKyBNYXRoLlBJIC8gMik7XG4gICAgdGhpcy5waGFudG9tR3JvdXAub3BhY2l0eSA9IDAuMjtcbiAgICB0aGlzLnBoYW50b21Hcm91cC56SW5kZXhTdWJPcmRlciA9IFsoKSA9PiB0aGlzLl9kZWNsYXJhdGlvbk9yZGVyLCAwXTtcbiAgfVxuICBnZXQgY2FsbG91dE5vZGVEYXRhKCkge1xuICAgIHJldHVybiB0aGlzLnBoYW50b21Ob2RlRGF0YSA/PyB0aGlzLm5vZGVEYXRhO1xuICB9XG4gIGFkZENoYXJ0RXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5kZXN0cm95Rm5zLnB1c2goXG4gICAgICB0aGlzLmN0eC5jaGFydEV2ZW50TWFuYWdlcj8uYWRkTGlzdGVuZXIoXCJsZWdlbmQtaXRlbS1jbGlja1wiLCAoZXZlbnQpID0+IHRoaXMub25MZWdlbmRJdGVtQ2xpY2soZXZlbnQpKVxuICAgICk7XG4gIH1cbiAgZ2V0IHZpc2libGUoKSB7XG4gICAgcmV0dXJuIHN1cGVyLnZpc2libGUgJiYgKHRoaXMuc2VyaWVzSXRlbUVuYWJsZWQubGVuZ3RoID09PSAwIHx8IHRoaXMuc2VyaWVzSXRlbUVuYWJsZWQuaW5jbHVkZXModHJ1ZSkpO1xuICB9XG4gIG5vZGVGYWN0b3J5KCkge1xuICAgIGNvbnN0IHNlY3RvciA9IG5ldyBTZWN0b3IoKTtcbiAgICBzZWN0b3IubWl0ZXJMaW1pdCA9IDFlOTtcbiAgICByZXR1cm4gc2VjdG9yO1xuICB9XG4gIGdldFNlcmllc0RvbWFpbihkaXJlY3Rpb24pIHtcbiAgICBpZiAoZGlyZWN0aW9uID09PSBcInhcIiAvKiBYICovKSB7XG4gICAgICByZXR1cm4gdGhpcy5hbmdsZVNjYWxlLmRvbWFpbjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMucmFkaXVzU2NhbGUuZG9tYWluO1xuICAgIH1cbiAgfVxuICBhc3luYyBwcm9jZXNzRGF0YShkYXRhQ29udHJvbGxlcikge1xuICAgIGlmICh0aGlzLmRhdGEgPT0gbnVsbCB8fCAhdGhpcy5wcm9wZXJ0aWVzLmlzVmFsaWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgeyBkYXRhIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgdmlzaWJsZSwgc2VyaWVzSXRlbUVuYWJsZWQgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBhbmdsZUtleSwgYW5nbGVGaWx0ZXJLZXksIHJhZGl1c0tleSwgY2FsbG91dExhYmVsS2V5LCBzZWN0b3JMYWJlbEtleSwgbGVnZW5kSXRlbUtleSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGFuaW1hdGlvbkVuYWJsZWQgPSAhdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5pc1NraXBwZWQoKTtcbiAgICBjb25zdCBleHRyYUtleVByb3BzID0gW107XG4gICAgY29uc3QgZXh0cmFQcm9wcyA9IFtdO1xuICAgIGlmIChsZWdlbmRJdGVtS2V5KSB7XG4gICAgICBleHRyYUtleVByb3BzLnB1c2goa2V5UHJvcGVydHkobGVnZW5kSXRlbUtleSwgXCJiYW5kXCIsIHsgaWQ6IGBsZWdlbmRJdGVtS2V5YCB9KSk7XG4gICAgfSBlbHNlIGlmIChjYWxsb3V0TGFiZWxLZXkpIHtcbiAgICAgIGV4dHJhS2V5UHJvcHMucHVzaChrZXlQcm9wZXJ0eShjYWxsb3V0TGFiZWxLZXksIFwiYmFuZFwiLCB7IGlkOiBgY2FsbG91dExhYmVsS2V5YCB9KSk7XG4gICAgfSBlbHNlIGlmIChzZWN0b3JMYWJlbEtleSkge1xuICAgICAgZXh0cmFLZXlQcm9wcy5wdXNoKGtleVByb3BlcnR5KHNlY3RvckxhYmVsS2V5LCBcImJhbmRcIiwgeyBpZDogYHNlY3RvckxhYmVsS2V5YCB9KSk7XG4gICAgfVxuICAgIGNvbnN0IHJhZGl1c1NjYWxlVHlwZSA9IHRoaXMucmFkaXVzU2NhbGUudHlwZTtcbiAgICBjb25zdCBhbmdsZVNjYWxlVHlwZSA9IHRoaXMucmFkaXVzU2NhbGUudHlwZTtcbiAgICBpZiAocmFkaXVzS2V5KSB7XG4gICAgICBleHRyYVByb3BzLnB1c2goXG4gICAgICAgIHJhbmdlZFZhbHVlUHJvcGVydHkocmFkaXVzS2V5LCB7XG4gICAgICAgICAgaWQ6IFwicmFkaXVzVmFsdWVcIixcbiAgICAgICAgICBtaW46IHRoaXMucHJvcGVydGllcy5yYWRpdXNNaW4gPz8gMCxcbiAgICAgICAgICBtYXg6IHRoaXMucHJvcGVydGllcy5yYWRpdXNNYXhcbiAgICAgICAgfSksXG4gICAgICAgIHZhbHVlUHJvcGVydHkocmFkaXVzS2V5LCByYWRpdXNTY2FsZVR5cGUsIHsgaWQ6IGByYWRpdXNSYXdgIH0pLFxuICAgICAgICAvLyBSYXcgdmFsdWUgcGFzcy10aHJvdWdoLlxuICAgICAgICBub3JtYWxpc2VQcm9wZXJ0eVRvKFwicmFkaXVzVmFsdWVcIiwgWzAsIDFdLCAxLCB0aGlzLnByb3BlcnRpZXMucmFkaXVzTWluID8/IDAsIHRoaXMucHJvcGVydGllcy5yYWRpdXNNYXgpXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoY2FsbG91dExhYmVsS2V5KSB7XG4gICAgICBleHRyYVByb3BzLnB1c2godmFsdWVQcm9wZXJ0eShjYWxsb3V0TGFiZWxLZXksIFwiYmFuZFwiLCB7IGlkOiBgY2FsbG91dExhYmVsVmFsdWVgIH0pKTtcbiAgICB9XG4gICAgaWYgKHNlY3RvckxhYmVsS2V5KSB7XG4gICAgICBleHRyYVByb3BzLnB1c2godmFsdWVQcm9wZXJ0eShzZWN0b3JMYWJlbEtleSwgXCJiYW5kXCIsIHsgaWQ6IGBzZWN0b3JMYWJlbFZhbHVlYCB9KSk7XG4gICAgfVxuICAgIGlmIChsZWdlbmRJdGVtS2V5KSB7XG4gICAgICBleHRyYVByb3BzLnB1c2godmFsdWVQcm9wZXJ0eShsZWdlbmRJdGVtS2V5LCBcImJhbmRcIiwgeyBpZDogYGxlZ2VuZEl0ZW1WYWx1ZWAgfSkpO1xuICAgIH1cbiAgICBpZiAoYW5nbGVGaWx0ZXJLZXkpIHtcbiAgICAgIGV4dHJhUHJvcHMucHVzaChcbiAgICAgICAgYWNjdW11bGF0aXZlVmFsdWVQcm9wZXJ0eShhbmdsZUZpbHRlcktleSwgYW5nbGVTY2FsZVR5cGUsIHtcbiAgICAgICAgICBpZDogYGFuZ2xlRmlsdGVyVmFsdWVgLFxuICAgICAgICAgIG9ubHlQb3NpdGl2ZTogdHJ1ZVxuICAgICAgICB9KSxcbiAgICAgICAgdmFsdWVQcm9wZXJ0eShhbmdsZUZpbHRlcktleSwgYW5nbGVTY2FsZVR5cGUsIHsgaWQ6IGBhbmdsZUZpbHRlclJhd2AgfSksXG4gICAgICAgIG5vcm1hbGlzZVByb3BlcnR5VG8oXCJhbmdsZUZpbHRlclZhbHVlXCIsIFswLCAxXSwgMCwgMClcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChhbmltYXRpb25FbmFibGVkICYmIHRoaXMucHJvY2Vzc2VkRGF0YT8ucmVkdWNlZD8uYW5pbWF0aW9uVmFsaWRhdGlvbj8udW5pcXVlS2V5cyAmJiBleHRyYUtleVByb3BzLmxlbmd0aCA+IDApIHtcbiAgICAgIGV4dHJhUHJvcHMucHVzaChkaWZmKHRoaXMucHJvY2Vzc2VkRGF0YSkpO1xuICAgIH1cbiAgICBleHRyYVByb3BzLnB1c2goYW5pbWF0aW9uVmFsaWRhdGlvbigpKTtcbiAgICBkYXRhID0gZGF0YS5tYXAoKGQsIGlkeCkgPT4gdmlzaWJsZSAmJiBzZXJpZXNJdGVtRW5hYmxlZFtpZHhdID8gZCA6IHsgLi4uZCwgW2FuZ2xlS2V5XTogMCB9KTtcbiAgICBhd2FpdCB0aGlzLnJlcXVlc3REYXRhTW9kZWwoZGF0YUNvbnRyb2xsZXIsIGRhdGEsIHtcbiAgICAgIHByb3BzOiBbXG4gICAgICAgIC4uLmV4dHJhS2V5UHJvcHMsXG4gICAgICAgIGFjY3VtdWxhdGl2ZVZhbHVlUHJvcGVydHkoYW5nbGVLZXksIGFuZ2xlU2NhbGVUeXBlLCB7IGlkOiBgYW5nbGVWYWx1ZWAsIG9ubHlQb3NpdGl2ZTogdHJ1ZSB9KSxcbiAgICAgICAgdmFsdWVQcm9wZXJ0eShhbmdsZUtleSwgYW5nbGVTY2FsZVR5cGUsIHsgaWQ6IGBhbmdsZVJhd2AgfSksXG4gICAgICAgIC8vIFJhdyB2YWx1ZSBwYXNzLXRocm91Z2guXG4gICAgICAgIG5vcm1hbGlzZVByb3BlcnR5VG8oXCJhbmdsZVZhbHVlXCIsIFswLCAxXSwgMCwgMCksXG4gICAgICAgIC4uLmV4dHJhUHJvcHNcbiAgICAgIF1cbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IHZhbHVlRGVmIG9mIHRoaXMucHJvY2Vzc2VkRGF0YT8uZGVmcz8udmFsdWVzID8/IFtdKSB7XG4gICAgICBjb25zdCB7IGlkLCBtaXNzaW5nLCBwcm9wZXJ0eSB9ID0gdmFsdWVEZWY7XG4gICAgICBjb25zdCBtaXNzQ291bnQgPSBnZXRNaXNzQ291bnQodGhpcywgbWlzc2luZyk7XG4gICAgICBpZiAoaWQgIT09IFwiYW5nbGVSYXdcIiAmJiBtaXNzQ291bnQgPiAwKSB7XG4gICAgICAgIExvZ2dlci53YXJuT25jZShcbiAgICAgICAgICBgbm8gdmFsdWUgd2FzIGZvdW5kIGZvciB0aGUga2V5ICcke1N0cmluZyhwcm9wZXJ0eSl9JyBvbiAke21pc3NDb3VudH0gZGF0YSBlbGVtZW50JHttaXNzQ291bnQgPiAxID8gXCJzXCIgOiBcIlwifWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwidXBkYXRlRGF0YVwiKTtcbiAgfVxuICBhc3luYyBtYXliZVJlZnJlc2hOb2RlRGF0YSgpIHtcbiAgICBpZiAoIXRoaXMubm9kZURhdGFSZWZyZXNoKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgbm9kZURhdGEgPSBbXSwgcGhhbnRvbU5vZGVEYXRhIH0gPSBhd2FpdCB0aGlzLmNyZWF0ZU5vZGVEYXRhKCkgPz8ge307XG4gICAgdGhpcy5ub2RlRGF0YSA9IG5vZGVEYXRhO1xuICAgIHRoaXMucGhhbnRvbU5vZGVEYXRhID0gcGhhbnRvbU5vZGVEYXRhO1xuICAgIHRoaXMubm9kZURhdGFSZWZyZXNoID0gZmFsc2U7XG4gIH1cbiAgZ2V0UHJvY2Vzc2VkRGF0YUluZGV4ZXMoZGF0YU1vZGVsKSB7XG4gICAgY29uc3QgYW5nbGVJZHggPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYGFuZ2xlVmFsdWVgKTtcbiAgICBjb25zdCBhbmdsZVJhd0lkeCA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgYW5nbGVSYXdgKTtcbiAgICBjb25zdCBhbmdsZUZpbHRlcklkeCA9IHRoaXMucHJvcGVydGllcy5hbmdsZUZpbHRlcktleSAhPSBudWxsID8gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGBhbmdsZUZpbHRlclZhbHVlYCkgOiB2b2lkIDA7XG4gICAgY29uc3QgYW5nbGVGaWx0ZXJSYXdJZHggPSB0aGlzLnByb3BlcnRpZXMuYW5nbGVGaWx0ZXJLZXkgIT0gbnVsbCA/IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgYW5nbGVGaWx0ZXJSYXdgKSA6IHZvaWQgMDtcbiAgICBjb25zdCByYWRpdXNJZHggPSB0aGlzLnByb3BlcnRpZXMucmFkaXVzS2V5ID8gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGByYWRpdXNWYWx1ZWApIDogdm9pZCAwO1xuICAgIGNvbnN0IHJhZGl1c1Jhd0lkeCA9IHRoaXMucHJvcGVydGllcy5yYWRpdXNLZXkgPyBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYHJhZGl1c1Jhd2ApIDogdm9pZCAwO1xuICAgIGNvbnN0IGNhbGxvdXRMYWJlbElkeCA9IHRoaXMucHJvcGVydGllcy5jYWxsb3V0TGFiZWxLZXkgPyBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYGNhbGxvdXRMYWJlbFZhbHVlYCkgOiB2b2lkIDA7XG4gICAgY29uc3Qgc2VjdG9yTGFiZWxJZHggPSB0aGlzLnByb3BlcnRpZXMuc2VjdG9yTGFiZWxLZXkgPyBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYHNlY3RvckxhYmVsVmFsdWVgKSA6IHZvaWQgMDtcbiAgICBjb25zdCBsZWdlbmRJdGVtSWR4ID0gdGhpcy5wcm9wZXJ0aWVzLmxlZ2VuZEl0ZW1LZXkgPyBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYGxlZ2VuZEl0ZW1WYWx1ZWApIDogdm9pZCAwO1xuICAgIHJldHVybiB7XG4gICAgICBhbmdsZUlkeCxcbiAgICAgIGFuZ2xlUmF3SWR4LFxuICAgICAgYW5nbGVGaWx0ZXJJZHgsXG4gICAgICBhbmdsZUZpbHRlclJhd0lkeCxcbiAgICAgIHJhZGl1c0lkeCxcbiAgICAgIHJhZGl1c1Jhd0lkeCxcbiAgICAgIGNhbGxvdXRMYWJlbElkeCxcbiAgICAgIHNlY3RvckxhYmVsSWR4LFxuICAgICAgbGVnZW5kSXRlbUlkeFxuICAgIH07XG4gIH1cbiAgYXN5bmMgY3JlYXRlTm9kZURhdGEoKSB7XG4gICAgY29uc3QgeyBpZDogc2VyaWVzSWQsIHByb2Nlc3NlZERhdGEsIGRhdGFNb2RlbCwgYW5nbGVTY2FsZSB9ID0gdGhpcztcbiAgICBjb25zdCB7IHJvdGF0aW9uIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgaWYgKCFwcm9jZXNzZWREYXRhIHx8ICFkYXRhTW9kZWwgfHwgcHJvY2Vzc2VkRGF0YS50eXBlICE9PSBcInVuZ3JvdXBlZFwiKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHtcbiAgICAgIGFuZ2xlSWR4LFxuICAgICAgYW5nbGVSYXdJZHgsXG4gICAgICBhbmdsZUZpbHRlcklkeCxcbiAgICAgIGFuZ2xlRmlsdGVyUmF3SWR4LFxuICAgICAgcmFkaXVzSWR4LFxuICAgICAgcmFkaXVzUmF3SWR4LFxuICAgICAgY2FsbG91dExhYmVsSWR4LFxuICAgICAgc2VjdG9yTGFiZWxJZHgsXG4gICAgICBsZWdlbmRJdGVtSWR4XG4gICAgfSA9IHRoaXMuZ2V0UHJvY2Vzc2VkRGF0YUluZGV4ZXMoZGF0YU1vZGVsKTtcbiAgICBjb25zdCB1c2VGaWx0ZXJBbmdsZXMgPSBhbmdsZUZpbHRlclJhd0lkeCAhPSBudWxsICYmIHByb2Nlc3NlZERhdGEuZGF0YS5zb21lKCh7IHZhbHVlcyB9KSA9PiB7XG4gICAgICByZXR1cm4gdmFsdWVzW2FuZ2xlRmlsdGVyUmF3SWR4XSA+IHZhbHVlc1thbmdsZVJhd0lkeF07XG4gICAgfSk7XG4gICAgbGV0IGN1cnJlbnRTdGFydCA9IDA7XG4gICAgbGV0IHN1bTIgPSAwO1xuICAgIGNvbnN0IG5vZGVzID0gW107XG4gICAgY29uc3QgcGhhbnRvbU5vZGVzID0gYW5nbGVGaWx0ZXJSYXdJZHggIT0gbnVsbCA/IFtdIDogdm9pZCAwO1xuICAgIHByb2Nlc3NlZERhdGEuZGF0YS5mb3JFYWNoKChncm91cCwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHsgZGF0dW0sIHZhbHVlcyB9ID0gZ3JvdXA7XG4gICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB1c2VGaWx0ZXJBbmdsZXMgPyB2YWx1ZXNbYW5nbGVGaWx0ZXJJZHhdIDogdmFsdWVzW2FuZ2xlSWR4XTtcbiAgICAgIGNvbnN0IGNyb3NzRmlsdGVyU2NhbGUgPSBhbmdsZUZpbHRlclJhd0lkeCAhPSBudWxsICYmICF1c2VGaWx0ZXJBbmdsZXMgPyBNYXRoLnNxcnQodmFsdWVzW2FuZ2xlRmlsdGVyUmF3SWR4XSAvIHZhbHVlc1thbmdsZVJhd0lkeF0pIDogMTtcbiAgICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSBhbmdsZVNjYWxlLmNvbnZlcnQoY3VycmVudFN0YXJ0KSArIHRvUmFkaWFucyhyb3RhdGlvbik7XG4gICAgICBjdXJyZW50U3RhcnQgPSBjdXJyZW50VmFsdWU7XG4gICAgICBzdW0yICs9IGN1cnJlbnRWYWx1ZTtcbiAgICAgIGNvbnN0IGVuZEFuZ2xlID0gYW5nbGVTY2FsZS5jb252ZXJ0KGN1cnJlbnRTdGFydCkgKyB0b1JhZGlhbnMocm90YXRpb24pO1xuICAgICAgY29uc3Qgc3BhbiA9IE1hdGguYWJzKGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSk7XG4gICAgICBjb25zdCBtaWRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBzcGFuIC8gMjtcbiAgICAgIGNvbnN0IGFuZ2xlVmFsdWUgPSB2YWx1ZXNbYW5nbGVSYXdJZHhdO1xuICAgICAgY29uc3QgcmFkaXVzUmF3ID0gcmFkaXVzSWR4ICE9IG51bGwgPyB2YWx1ZXNbcmFkaXVzSWR4XSA/PyAxIDogMTtcbiAgICAgIGNvbnN0IHJhZGl1cyA9IHJhZGl1c1JhdyAqIGNyb3NzRmlsdGVyU2NhbGU7XG4gICAgICBjb25zdCByYWRpdXNWYWx1ZSA9IHJhZGl1c1Jhd0lkeCAhPSBudWxsID8gdmFsdWVzW3JhZGl1c1Jhd0lkeF0gOiB2b2lkIDA7XG4gICAgICBjb25zdCBsZWdlbmRJdGVtVmFsdWUgPSBsZWdlbmRJdGVtSWR4ICE9IG51bGwgPyB2YWx1ZXNbbGVnZW5kSXRlbUlkeF0gOiB2b2lkIDA7XG4gICAgICBjb25zdCBub2RlTGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoXG4gICAgICAgIGRhdHVtLFxuICAgICAgICBtaWRBbmdsZSxcbiAgICAgICAgc3BhbixcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgY2FsbG91dExhYmVsSWR4ICE9IG51bGwgPyB2YWx1ZXNbY2FsbG91dExhYmVsSWR4XSA6IHZvaWQgMCxcbiAgICAgICAgc2VjdG9yTGFiZWxJZHggIT0gbnVsbCA/IHZhbHVlc1tzZWN0b3JMYWJlbElkeF0gOiB2b2lkIDAsXG4gICAgICAgIGxlZ2VuZEl0ZW1WYWx1ZVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHNlY3RvckZvcm1hdCA9IHRoaXMuZ2V0U2VjdG9yRm9ybWF0KGRhdHVtLCBpbmRleCwgZmFsc2UpO1xuICAgICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgICAgaXRlbUlkOiBpbmRleCxcbiAgICAgICAgc2VyaWVzOiB0aGlzLFxuICAgICAgICBkYXR1bSxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIGFuZ2xlVmFsdWUsXG4gICAgICAgIG1pZEFuZ2xlLFxuICAgICAgICBtaWRDb3M6IE1hdGguY29zKG1pZEFuZ2xlKSxcbiAgICAgICAgbWlkU2luOiBNYXRoLnNpbihtaWRBbmdsZSksXG4gICAgICAgIHN0YXJ0QW5nbGUsXG4gICAgICAgIGVuZEFuZ2xlLFxuICAgICAgICByYWRpdXMsXG4gICAgICAgIGlubmVyUmFkaXVzOiBNYXRoLm1heCh0aGlzLnJhZGl1c1NjYWxlLmNvbnZlcnQoMCksIDApLFxuICAgICAgICBvdXRlclJhZGl1czogTWF0aC5tYXgodGhpcy5yYWRpdXNTY2FsZS5jb252ZXJ0KHJhZGl1cyksIDApLFxuICAgICAgICBzZWN0b3JGb3JtYXQsXG4gICAgICAgIHJhZGl1c1ZhbHVlLFxuICAgICAgICBsZWdlbmRJdGVtVmFsdWUsXG4gICAgICAgIGVuYWJsZWQ6IHRoaXMuc2VyaWVzSXRlbUVuYWJsZWRbaW5kZXhdLFxuICAgICAgICAuLi5ub2RlTGFiZWxzXG4gICAgICB9O1xuICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICAgIGlmIChwaGFudG9tTm9kZXMgIT0gbnVsbCkge1xuICAgICAgICBwaGFudG9tTm9kZXMucHVzaCh7XG4gICAgICAgICAgLi4ubm9kZSxcbiAgICAgICAgICByYWRpdXM6IDEsXG4gICAgICAgICAgaW5uZXJSYWRpdXM6IE1hdGgubWF4KHRoaXMucmFkaXVzU2NhbGUuY29udmVydCgwKSwgMCksXG4gICAgICAgICAgb3V0ZXJSYWRpdXM6IE1hdGgubWF4KHRoaXMucmFkaXVzU2NhbGUuY29udmVydCgxKSwgMClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy56ZXJvc3VtT3V0ZXJSaW5nLnZpc2libGUgPSBzdW0yID09PSAwO1xuICAgIHJldHVybiB7XG4gICAgICBpdGVtSWQ6IHNlcmllc0lkLFxuICAgICAgbm9kZURhdGE6IG5vZGVzLFxuICAgICAgbGFiZWxEYXRhOiBub2RlcyxcbiAgICAgIHBoYW50b21Ob2RlRGF0YTogcGhhbnRvbU5vZGVzXG4gICAgfTtcbiAgfVxuICBnZXRMYWJlbHMoZGF0dW0sIG1pZEFuZ2xlLCBzcGFuLCBza2lwRGlzYWJsZWQsIGNhbGxvdXRMYWJlbFZhbHVlLCBzZWN0b3JMYWJlbFZhbHVlLCBsZWdlbmRJdGVtVmFsdWUpIHtcbiAgICBjb25zdCB7IGNhbGxvdXRMYWJlbCwgc2VjdG9yTGFiZWwsIGxlZ2VuZEl0ZW1LZXkgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCBjYWxsb3V0TGFiZWxLZXkgPSAhc2tpcERpc2FibGVkIHx8IGNhbGxvdXRMYWJlbC5lbmFibGVkID8gdGhpcy5wcm9wZXJ0aWVzLmNhbGxvdXRMYWJlbEtleSA6IHZvaWQgMDtcbiAgICBjb25zdCBzZWN0b3JMYWJlbEtleSA9ICFza2lwRGlzYWJsZWQgfHwgc2VjdG9yTGFiZWwuZW5hYmxlZCA/IHRoaXMucHJvcGVydGllcy5zZWN0b3JMYWJlbEtleSA6IHZvaWQgMDtcbiAgICBpZiAoIWNhbGxvdXRMYWJlbEtleSAmJiAhc2VjdG9yTGFiZWxLZXkgJiYgIWxlZ2VuZEl0ZW1LZXkpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgY29uc3QgbGFiZWxGb3JtYXR0ZXJQYXJhbXMgPSB7XG4gICAgICBkYXR1bSxcbiAgICAgIGFuZ2xlS2V5OiB0aGlzLnByb3BlcnRpZXMuYW5nbGVLZXksXG4gICAgICBhbmdsZU5hbWU6IHRoaXMucHJvcGVydGllcy5hbmdsZU5hbWUsXG4gICAgICByYWRpdXNLZXk6IHRoaXMucHJvcGVydGllcy5yYWRpdXNLZXksXG4gICAgICByYWRpdXNOYW1lOiB0aGlzLnByb3BlcnRpZXMucmFkaXVzTmFtZSxcbiAgICAgIGNhbGxvdXRMYWJlbEtleTogdGhpcy5wcm9wZXJ0aWVzLmNhbGxvdXRMYWJlbEtleSxcbiAgICAgIGNhbGxvdXRMYWJlbE5hbWU6IHRoaXMucHJvcGVydGllcy5jYWxsb3V0TGFiZWxOYW1lLFxuICAgICAgc2VjdG9yTGFiZWxLZXk6IHRoaXMucHJvcGVydGllcy5zZWN0b3JMYWJlbEtleSxcbiAgICAgIHNlY3RvckxhYmVsTmFtZTogdGhpcy5wcm9wZXJ0aWVzLnNlY3RvckxhYmVsTmFtZSxcbiAgICAgIGxlZ2VuZEl0ZW1LZXk6IHRoaXMucHJvcGVydGllcy5sZWdlbmRJdGVtS2V5XG4gICAgfTtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBpZiAoY2FsbG91dExhYmVsS2V5ICYmIHNwYW4gPiB0b1JhZGlhbnMoY2FsbG91dExhYmVsLm1pbkFuZ2xlKSkge1xuICAgICAgcmVzdWx0LmNhbGxvdXRMYWJlbCA9IHtcbiAgICAgICAgLi4udGhpcy5nZXRUZXh0QWxpZ25tZW50KG1pZEFuZ2xlKSxcbiAgICAgICAgdGV4dDogdGhpcy5nZXRMYWJlbFRleHQoY2FsbG91dExhYmVsLCB7XG4gICAgICAgICAgLi4ubGFiZWxGb3JtYXR0ZXJQYXJhbXMsXG4gICAgICAgICAgdmFsdWU6IGNhbGxvdXRMYWJlbFZhbHVlXG4gICAgICAgIH0pLFxuICAgICAgICBoaWRkZW46IGZhbHNlLFxuICAgICAgICBjb2xsaXNpb25UZXh0QWxpZ246IHZvaWQgMCxcbiAgICAgICAgY29sbGlzaW9uT2Zmc2V0WTogMCxcbiAgICAgICAgYm94OiB2b2lkIDBcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChzZWN0b3JMYWJlbEtleSkge1xuICAgICAgcmVzdWx0LnNlY3RvckxhYmVsID0ge1xuICAgICAgICB0ZXh0OiB0aGlzLmdldExhYmVsVGV4dChzZWN0b3JMYWJlbCwge1xuICAgICAgICAgIC4uLmxhYmVsRm9ybWF0dGVyUGFyYW1zLFxuICAgICAgICAgIHZhbHVlOiBzZWN0b3JMYWJlbFZhbHVlXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAobGVnZW5kSXRlbUtleSAhPSBudWxsICYmIGxlZ2VuZEl0ZW1WYWx1ZSAhPSBudWxsKSB7XG4gICAgICByZXN1bHQubGVnZW5kSXRlbSA9IHsga2V5OiBsZWdlbmRJdGVtS2V5LCB0ZXh0OiBsZWdlbmRJdGVtVmFsdWUgfTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBnZXRUZXh0QWxpZ25tZW50KG1pZEFuZ2xlKSB7XG4gICAgY29uc3QgcXVhZHJhbnRUZXh0T3B0cyA9IFtcbiAgICAgIHsgdGV4dEFsaWduOiBcImNlbnRlclwiLCB0ZXh0QmFzZWxpbmU6IFwiYm90dG9tXCIgfSxcbiAgICAgIHsgdGV4dEFsaWduOiBcImxlZnRcIiwgdGV4dEJhc2VsaW5lOiBcIm1pZGRsZVwiIH0sXG4gICAgICB7IHRleHRBbGlnbjogXCJjZW50ZXJcIiwgdGV4dEJhc2VsaW5lOiBcImhhbmdpbmdcIiB9LFxuICAgICAgeyB0ZXh0QWxpZ246IFwicmlnaHRcIiwgdGV4dEJhc2VsaW5lOiBcIm1pZGRsZVwiIH1cbiAgICBdO1xuICAgIGNvbnN0IG1pZEFuZ2xlMTgwID0gbm9ybWFsaXplQW5nbGUxODAobWlkQW5nbGUpO1xuICAgIGNvbnN0IHF1YWRyYW50U3RhcnQgPSAtMC43NSAqIE1hdGguUEk7XG4gICAgY29uc3QgcXVhZHJhbnRPZmZzZXQgPSBtaWRBbmdsZTE4MCAtIHF1YWRyYW50U3RhcnQ7XG4gICAgY29uc3QgcXVhZHJhbnQgPSBNYXRoLmZsb29yKHF1YWRyYW50T2Zmc2V0IC8gKE1hdGguUEkgLyAyKSk7XG4gICAgY29uc3QgcXVhZHJhbnRJbmRleCA9IG1vZChxdWFkcmFudCwgcXVhZHJhbnRUZXh0T3B0cy5sZW5ndGgpO1xuICAgIHJldHVybiBxdWFkcmFudFRleHRPcHRzW3F1YWRyYW50SW5kZXhdO1xuICB9XG4gIGdldFNlY3RvckZvcm1hdChkYXR1bSwgZm9ybWF0SW5kZXgsIGhpZ2hsaWdodGVkKSB7XG4gICAgY29uc3QgeyBjYWxsYmFja0NhY2hlIH0gPSB0aGlzLmN0eDtcbiAgICBjb25zdCB7IGFuZ2xlS2V5LCByYWRpdXNLZXksIGNhbGxvdXRMYWJlbEtleSwgc2VjdG9yTGFiZWxLZXksIGxlZ2VuZEl0ZW1LZXksIGZpbGxzLCBzdHJva2VzLCBpdGVtU3R5bGVyIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgZGVmYXVsdFN0cm9rZSA9IHN0cm9rZXNbZm9ybWF0SW5kZXggJSBzdHJva2VzLmxlbmd0aF07XG4gICAgY29uc3QgeyBmaWxsLCBmaWxsT3BhY2l0eSwgc3Ryb2tlLCBzdHJva2VXaWR0aCwgc3Ryb2tlT3BhY2l0eSwgbGluZURhc2gsIGxpbmVEYXNoT2Zmc2V0LCBjb3JuZXJSYWRpdXMgfSA9IG1lcmdlRGVmYXVsdHMoXG4gICAgICBoaWdobGlnaHRlZCAmJiB0aGlzLnByb3BlcnRpZXMuaGlnaGxpZ2h0U3R5bGUuaXRlbSxcbiAgICAgIHtcbiAgICAgICAgZmlsbDogZmlsbHMubGVuZ3RoID4gMCA/IGZpbGxzW2Zvcm1hdEluZGV4ICUgZmlsbHMubGVuZ3RoXSA6IHZvaWQgMCxcbiAgICAgICAgc3Ryb2tlOiBkZWZhdWx0U3Ryb2tlLFxuICAgICAgICBzdHJva2VXaWR0aDogdGhpcy5nZXRTdHJva2VXaWR0aCh0aGlzLnByb3BlcnRpZXMuc3Ryb2tlV2lkdGgpLFxuICAgICAgICBzdHJva2VPcGFjaXR5OiB0aGlzLmdldE9wYWNpdHkoKVxuICAgICAgfSxcbiAgICAgIHRoaXMucHJvcGVydGllc1xuICAgICk7XG4gICAgbGV0IGZvcm1hdDtcbiAgICBpZiAoaXRlbVN0eWxlcikge1xuICAgICAgZm9ybWF0ID0gY2FsbGJhY2tDYWNoZS5jYWxsKGl0ZW1TdHlsZXIsIHtcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIGFuZ2xlS2V5LFxuICAgICAgICByYWRpdXNLZXksXG4gICAgICAgIGNhbGxvdXRMYWJlbEtleSxcbiAgICAgICAgc2VjdG9yTGFiZWxLZXksXG4gICAgICAgIGxlZ2VuZEl0ZW1LZXksXG4gICAgICAgIGZpbGwsXG4gICAgICAgIHN0cm9rZU9wYWNpdHksXG4gICAgICAgIHN0cm9rZSxcbiAgICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICAgIGZpbGxPcGFjaXR5LFxuICAgICAgICBsaW5lRGFzaCxcbiAgICAgICAgbGluZURhc2hPZmZzZXQsXG4gICAgICAgIGNvcm5lclJhZGl1cyxcbiAgICAgICAgaGlnaGxpZ2h0ZWQsXG4gICAgICAgIHNlcmllc0lkOiB0aGlzLmlkXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpbGw6IGZvcm1hdD8uZmlsbCA/PyBmaWxsLFxuICAgICAgZmlsbE9wYWNpdHk6IGZvcm1hdD8uZmlsbE9wYWNpdHkgPz8gZmlsbE9wYWNpdHksXG4gICAgICBzdHJva2U6IGZvcm1hdD8uc3Ryb2tlID8/IHN0cm9rZSxcbiAgICAgIHN0cm9rZVdpZHRoOiBmb3JtYXQ/LnN0cm9rZVdpZHRoID8/IHN0cm9rZVdpZHRoLFxuICAgICAgc3Ryb2tlT3BhY2l0eTogZm9ybWF0Py5zdHJva2VPcGFjaXR5ID8/IHN0cm9rZU9wYWNpdHksXG4gICAgICBsaW5lRGFzaDogZm9ybWF0Py5saW5lRGFzaCA/PyBsaW5lRGFzaCxcbiAgICAgIGxpbmVEYXNoT2Zmc2V0OiBmb3JtYXQ/LmxpbmVEYXNoT2Zmc2V0ID8/IGxpbmVEYXNoT2Zmc2V0LFxuICAgICAgY29ybmVyUmFkaXVzOiBmb3JtYXQ/LmNvcm5lclJhZGl1cyA/PyBjb3JuZXJSYWRpdXNcbiAgICB9O1xuICB9XG4gIGdldE91dGVyUmFkaXVzKCkge1xuICAgIHJldHVybiBNYXRoLm1heCh0aGlzLnJhZGl1cyAqIHRoaXMucHJvcGVydGllcy5vdXRlclJhZGl1c1JhdGlvICsgdGhpcy5wcm9wZXJ0aWVzLm91dGVyUmFkaXVzT2Zmc2V0LCAwKTtcbiAgfVxuICB1cGRhdGVSYWRpdXNTY2FsZShyZXNpemUpIHtcbiAgICBjb25zdCBuZXdSYW5nZSA9IFswLCB0aGlzLmdldE91dGVyUmFkaXVzKCldO1xuICAgIHRoaXMucmFkaXVzU2NhbGUucmFuZ2UgPSBuZXdSYW5nZTtcbiAgICBpZiAocmVzaXplKSB7XG4gICAgICB0aGlzLnByZXZpb3VzUmFkaXVzU2NhbGUucmFuZ2UgPSBuZXdSYW5nZTtcbiAgICB9XG4gICAgY29uc3Qgc2V0UmFkaWkgPSAoZCkgPT4gKHtcbiAgICAgIC4uLmQsXG4gICAgICBpbm5lclJhZGl1czogTWF0aC5tYXgodGhpcy5yYWRpdXNTY2FsZS5jb252ZXJ0KDApLCAwKSxcbiAgICAgIG91dGVyUmFkaXVzOiBNYXRoLm1heCh0aGlzLnJhZGl1c1NjYWxlLmNvbnZlcnQoZC5yYWRpdXMpLCAwKVxuICAgIH0pO1xuICAgIHRoaXMubm9kZURhdGEgPSB0aGlzLm5vZGVEYXRhLm1hcChzZXRSYWRpaSk7XG4gICAgdGhpcy5waGFudG9tTm9kZURhdGEgPSB0aGlzLnBoYW50b21Ob2RlRGF0YT8ubWFwKHNldFJhZGlpKTtcbiAgfVxuICBnZXRUaXRsZVRyYW5zbGF0aW9uWSgpIHtcbiAgICBjb25zdCBvdXRlclJhZGl1cyA9IE1hdGgubWF4KDAsIHRoaXMucmFkaXVzU2NhbGUucmFuZ2VbMV0pO1xuICAgIGlmIChvdXRlclJhZGl1cyA9PT0gMCkge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgY29uc3Qgc3BhY2luZyA9IHRoaXMucHJvcGVydGllcy50aXRsZT8uc3BhY2luZyA/PyAwO1xuICAgIGNvbnN0IHRpdGxlT2Zmc2V0ID0gMiArIHNwYWNpbmc7XG4gICAgY29uc3QgZHkgPSBNYXRoLm1heCgwLCAtb3V0ZXJSYWRpdXMpO1xuICAgIHJldHVybiAtb3V0ZXJSYWRpdXMgLSB0aXRsZU9mZnNldCAtIGR5O1xuICB9XG4gIGFzeW5jIHVwZGF0ZSh7IHNlcmllc1JlY3QgfSkge1xuICAgIGNvbnN0IHsgdGl0bGUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCBuZXdOb2RlRGF0YURlcGVuZGVuY2llcyA9IHtcbiAgICAgIHNlcmllc1JlY3RXaWR0aDogc2VyaWVzUmVjdD8ud2lkdGgsXG4gICAgICBzZXJpZXNSZWN0SGVpZ2h0OiBzZXJpZXNSZWN0Py5oZWlnaHRcbiAgICB9O1xuICAgIGNvbnN0IHJlc2l6ZSA9IGpzb25EaWZmKHRoaXMubm9kZURhdGFEZXBlbmRlbmNpZXMsIG5ld05vZGVEYXRhRGVwZW5kZW5jaWVzKSAhPSBudWxsO1xuICAgIGlmIChyZXNpemUpIHtcbiAgICAgIHRoaXMuX25vZGVEYXRhRGVwZW5kZW5jaWVzID0gbmV3Tm9kZURhdGFEZXBlbmRlbmNpZXM7XG4gICAgfVxuICAgIGF3YWl0IHRoaXMubWF5YmVSZWZyZXNoTm9kZURhdGEoKTtcbiAgICB0aGlzLnVwZGF0ZVRpdGxlTm9kZXMoKTtcbiAgICB0aGlzLnVwZGF0ZVJhZGl1c1NjYWxlKHJlc2l6ZSk7XG4gICAgdGhpcy5jb250ZW50R3JvdXAudHJhbnNsYXRpb25YID0gdGhpcy5jZW50ZXJYO1xuICAgIHRoaXMuY29udGVudEdyb3VwLnRyYW5zbGF0aW9uWSA9IHRoaXMuY2VudGVyWTtcbiAgICB0aGlzLmhpZ2hsaWdodEdyb3VwLnRyYW5zbGF0aW9uWCA9IHRoaXMuY2VudGVyWDtcbiAgICB0aGlzLmhpZ2hsaWdodEdyb3VwLnRyYW5zbGF0aW9uWSA9IHRoaXMuY2VudGVyWTtcbiAgICB0aGlzLmJhY2tncm91bmRHcm91cC50cmFuc2xhdGlvblggPSB0aGlzLmNlbnRlclg7XG4gICAgdGhpcy5iYWNrZ3JvdW5kR3JvdXAudHJhbnNsYXRpb25ZID0gdGhpcy5jZW50ZXJZO1xuICAgIGlmICh0aGlzLmxhYmVsR3JvdXApIHtcbiAgICAgIHRoaXMubGFiZWxHcm91cC50cmFuc2xhdGlvblggPSB0aGlzLmNlbnRlclg7XG4gICAgICB0aGlzLmxhYmVsR3JvdXAudHJhbnNsYXRpb25ZID0gdGhpcy5jZW50ZXJZO1xuICAgIH1cbiAgICBpZiAodGl0bGUpIHtcbiAgICAgIGNvbnN0IGR5ID0gdGhpcy5nZXRUaXRsZVRyYW5zbGF0aW9uWSgpO1xuICAgICAgdGl0bGUubm9kZS55ID0gaXNGaW5pdGUoZHkpID8gZHkgOiAwO1xuICAgICAgY29uc3QgdGl0bGVCb3ggPSB0aXRsZS5ub2RlLmdldEJCb3goKTtcbiAgICAgIHRpdGxlLm5vZGUudmlzaWJsZSA9IHRpdGxlLmVuYWJsZWQgJiYgaXNGaW5pdGUoZHkpICYmICF0aGlzLmJib3hJbnRlcnNlY3RzU3Vycm91bmRpbmdTZXJpZXModGl0bGVCb3gpO1xuICAgIH1cbiAgICB0aGlzLnplcm9zdW1PdXRlclJpbmcuZmlsbE9wYWNpdHkgPSAwO1xuICAgIHRoaXMuemVyb3N1bU91dGVyUmluZy5zdHJva2UgPSB0aGlzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsLmNvbG9yO1xuICAgIHRoaXMuemVyb3N1bU91dGVyUmluZy5zdHJva2VXaWR0aCA9IDE7XG4gICAgdGhpcy56ZXJvc3VtT3V0ZXJSaW5nLnN0cm9rZU9wYWNpdHkgPSAxO1xuICAgIHRoaXMudXBkYXRlTm9kZU1pZFBvaW50KCk7XG4gICAgYXdhaXQgdGhpcy51cGRhdGVTZWxlY3Rpb25zKCk7XG4gICAgYXdhaXQgdGhpcy51cGRhdGVOb2RlcyhzZXJpZXNSZWN0KTtcbiAgfVxuICB1cGRhdGVUaXRsZU5vZGVzKCkge1xuICAgIGNvbnN0IHsgb2xkVGl0bGUgfSA9IHRoaXM7XG4gICAgY29uc3QgeyB0aXRsZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGlmIChvbGRUaXRsZSAhPT0gdGl0bGUpIHtcbiAgICAgIGlmIChvbGRUaXRsZSkge1xuICAgICAgICB0aGlzLmxhYmVsR3JvdXA/LnJlbW92ZUNoaWxkKG9sZFRpdGxlLm5vZGUpO1xuICAgICAgfVxuICAgICAgaWYgKHRpdGxlKSB7XG4gICAgICAgIHRpdGxlLm5vZGUudGV4dEJhc2VsaW5lID0gXCJib3R0b21cIjtcbiAgICAgICAgdGhpcy5sYWJlbEdyb3VwPy5hcHBlbmRDaGlsZCh0aXRsZS5ub2RlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub2xkVGl0bGUgPSB0aXRsZTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlTm9kZU1pZFBvaW50KCkge1xuICAgIGNvbnN0IHNldE1pZFBvaW50ID0gKGQpID0+IHtcbiAgICAgIGNvbnN0IHJhZGl1cyA9IGQuaW5uZXJSYWRpdXMgKyAoZC5vdXRlclJhZGl1cyAtIGQuaW5uZXJSYWRpdXMpIC8gMjtcbiAgICAgIGQubWlkUG9pbnQgPSB7XG4gICAgICAgIHg6IGQubWlkQ29zICogTWF0aC5tYXgoMCwgcmFkaXVzKSxcbiAgICAgICAgeTogZC5taWRTaW4gKiBNYXRoLm1heCgwLCByYWRpdXMpXG4gICAgICB9O1xuICAgIH07XG4gICAgdGhpcy5ub2RlRGF0YS5mb3JFYWNoKHNldE1pZFBvaW50KTtcbiAgICB0aGlzLnBoYW50b21Ob2RlRGF0YT8uZm9yRWFjaChzZXRNaWRQb2ludCk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlU2VsZWN0aW9ucygpIHtcbiAgICBhd2FpdCB0aGlzLnVwZGF0ZUdyb3VwU2VsZWN0aW9uKCk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlR3JvdXBTZWxlY3Rpb24oKSB7XG4gICAgY29uc3Qge1xuICAgICAgaXRlbVNlbGVjdGlvbixcbiAgICAgIGhpZ2hsaWdodFNlbGVjdGlvbixcbiAgICAgIHBoYW50b21TZWxlY3Rpb24sXG4gICAgICBoaWdobGlnaHRMYWJlbFNlbGVjdGlvbixcbiAgICAgIGNhbGxvdXRMYWJlbFNlbGVjdGlvbixcbiAgICAgIGxhYmVsU2VsZWN0aW9uXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgaGlnaGxpZ2h0ZWROb2RlRGF0YSA9IHRoaXMubm9kZURhdGEubWFwKChkYXR1bSkgPT4gKHtcbiAgICAgIC4uLmRhdHVtLFxuICAgICAgLy8gQWxsb3cgbXV0YWJsZSBzZWN0b3JGb3JtYXQsIHNvIGZvcm1hdHRlZCBzZWN0b3Igc3R5bGVzIGNhbiBiZSB1cGRhdGVkIGFuZCB2YXJpZWRcbiAgICAgIC8vIGJldHdlZW4gbm9ybWFsIGFuZCBoaWdobGlnaHRlZCBjYXNlcy5cbiAgICAgIHNlY3RvckZvcm1hdDogeyAuLi5kYXR1bS5zZWN0b3JGb3JtYXQgfVxuICAgIH0pKTtcbiAgICBjb25zdCB1cGRhdGUgPSAoc2VsZWN0aW9uLCBub2RlRGF0YSkgPT4ge1xuICAgICAgc2VsZWN0aW9uLnVwZGF0ZShub2RlRGF0YSwgdm9pZCAwLCAoZGF0dW0pID0+IHRoaXMuZ2V0RGF0dW1JZChkYXR1bSkpO1xuICAgICAgaWYgKHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuaXNTa2lwcGVkKCkpIHtcbiAgICAgICAgc2VsZWN0aW9uLmNsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHVwZGF0ZShpdGVtU2VsZWN0aW9uLCB0aGlzLm5vZGVEYXRhKTtcbiAgICB1cGRhdGUoaGlnaGxpZ2h0U2VsZWN0aW9uLCBoaWdobGlnaHRlZE5vZGVEYXRhKTtcbiAgICB1cGRhdGUocGhhbnRvbVNlbGVjdGlvbiwgdGhpcy5waGFudG9tTm9kZURhdGEgPz8gW10pO1xuICAgIGNhbGxvdXRMYWJlbFNlbGVjdGlvbi51cGRhdGUodGhpcy5jYWxsb3V0Tm9kZURhdGEsIChncm91cCkgPT4ge1xuICAgICAgY29uc3QgbGluZSA9IG5ldyBMaW5lKCk7XG4gICAgICBsaW5lLnRhZyA9IDAgLyogQ2FsbG91dCAqLztcbiAgICAgIGxpbmUucG9pbnRlckV2ZW50cyA9IDEgLyogTm9uZSAqLztcbiAgICAgIGdyb3VwLmFwcGVuZENoaWxkKGxpbmUpO1xuICAgICAgY29uc3QgdGV4dCA9IG5ldyBUZXh0KCk7XG4gICAgICB0ZXh0LnRhZyA9IDEgLyogTGFiZWwgKi87XG4gICAgICB0ZXh0LnBvaW50ZXJFdmVudHMgPSAxIC8qIE5vbmUgKi87XG4gICAgICBncm91cC5hcHBlbmRDaGlsZCh0ZXh0KTtcbiAgICB9KTtcbiAgICBsYWJlbFNlbGVjdGlvbi51cGRhdGUodGhpcy5ub2RlRGF0YSk7XG4gICAgaGlnaGxpZ2h0TGFiZWxTZWxlY3Rpb24udXBkYXRlKGhpZ2hsaWdodGVkTm9kZURhdGEpO1xuICB9XG4gIGFzeW5jIHVwZGF0ZU5vZGVzKHNlcmllc1JlY3QpIHtcbiAgICBjb25zdCBoaWdobGlnaHRlZERhdHVtID0gdGhpcy5jdHguaGlnaGxpZ2h0TWFuYWdlci5nZXRBY3RpdmVIaWdobGlnaHQoKTtcbiAgICBjb25zdCBpc1Zpc2libGUgPSB0aGlzLnZpc2libGUgJiYgdGhpcy5zZXJpZXNJdGVtRW5hYmxlZC5pbmNsdWRlcyh0cnVlKTtcbiAgICB0aGlzLnJvb3RHcm91cC52aXNpYmxlID0gaXNWaXNpYmxlO1xuICAgIHRoaXMuYmFja2dyb3VuZEdyb3VwLnZpc2libGUgPSBpc1Zpc2libGU7XG4gICAgdGhpcy5jb250ZW50R3JvdXAudmlzaWJsZSA9IGlzVmlzaWJsZTtcbiAgICB0aGlzLmhpZ2hsaWdodEdyb3VwLnZpc2libGUgPSBpc1Zpc2libGUgJiYgaGlnaGxpZ2h0ZWREYXR1bT8uc2VyaWVzID09PSB0aGlzO1xuICAgIHRoaXMuaGlnaGxpZ2h0TGFiZWwudmlzaWJsZSA9IGlzVmlzaWJsZSAmJiBoaWdobGlnaHRlZERhdHVtPy5zZXJpZXMgPT09IHRoaXM7XG4gICAgaWYgKHRoaXMubGFiZWxHcm91cCkge1xuICAgICAgdGhpcy5sYWJlbEdyb3VwLnZpc2libGUgPSBpc1Zpc2libGU7XG4gICAgfVxuICAgIHRoaXMuY29udGVudEdyb3VwLm9wYWNpdHkgPSB0aGlzLmdldE9wYWNpdHkoKTtcbiAgICBjb25zdCBhbmltYXRpb25EaXNhYmxlZCA9IHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuaXNTa2lwcGVkKCk7XG4gICAgY29uc3QgdXBkYXRlU2VjdG9yRm4gPSAoc2VjdG9yLCBkYXR1bSwgX2luZGV4LCBpc0RhdHVtSGlnaGxpZ2h0ZWQpID0+IHtcbiAgICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMuZ2V0U2VjdG9yRm9ybWF0KGRhdHVtLmRhdHVtLCBkYXR1bS5pdGVtSWQsIGlzRGF0dW1IaWdobGlnaHRlZCk7XG4gICAgICBkYXR1bS5zZWN0b3JGb3JtYXQuZmlsbCA9IGZvcm1hdC5maWxsO1xuICAgICAgZGF0dW0uc2VjdG9yRm9ybWF0LnN0cm9rZSA9IGZvcm1hdC5zdHJva2U7XG4gICAgICBpZiAoYW5pbWF0aW9uRGlzYWJsZWQpIHtcbiAgICAgICAgc2VjdG9yLnN0YXJ0QW5nbGUgPSBkYXR1bS5zdGFydEFuZ2xlO1xuICAgICAgICBzZWN0b3IuZW5kQW5nbGUgPSBkYXR1bS5lbmRBbmdsZTtcbiAgICAgICAgc2VjdG9yLmlubmVyUmFkaXVzID0gZGF0dW0uaW5uZXJSYWRpdXM7XG4gICAgICAgIHNlY3Rvci5vdXRlclJhZGl1cyA9IGRhdHVtLm91dGVyUmFkaXVzO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGF0dW1IaWdobGlnaHRlZCB8fCBhbmltYXRpb25EaXNhYmxlZCkge1xuICAgICAgICBzZWN0b3IuZmlsbCA9IGZvcm1hdC5maWxsO1xuICAgICAgICBzZWN0b3Iuc3Ryb2tlID0gZm9ybWF0LnN0cm9rZTtcbiAgICAgIH1cbiAgICAgIHNlY3Rvci5zdHJva2VXaWR0aCA9IGZvcm1hdC5zdHJva2VXaWR0aDtcbiAgICAgIHNlY3Rvci5maWxsT3BhY2l0eSA9IGZvcm1hdC5maWxsT3BhY2l0eTtcbiAgICAgIHNlY3Rvci5zdHJva2VPcGFjaXR5ID0gZm9ybWF0LnN0cm9rZU9wYWNpdHk7XG4gICAgICBzZWN0b3IubGluZURhc2ggPSBmb3JtYXQubGluZURhc2g7XG4gICAgICBzZWN0b3IubGluZURhc2hPZmZzZXQgPSBmb3JtYXQubGluZURhc2hPZmZzZXQ7XG4gICAgICBzZWN0b3IuY29ybmVyUmFkaXVzID0gZm9ybWF0LmNvcm5lclJhZGl1cztcbiAgICAgIHNlY3Rvci5maWxsU2hhZG93ID0gdGhpcy5wcm9wZXJ0aWVzLnNoYWRvdztcbiAgICAgIGNvbnN0IGluc2V0ID0gTWF0aC5tYXgoXG4gICAgICAgICh0aGlzLnByb3BlcnRpZXMuc2VjdG9yU3BhY2luZyArIChmb3JtYXQuc3Ryb2tlICE9IG51bGwgPyBmb3JtYXQuc3Ryb2tlV2lkdGggOiAwKSkgLyAyLFxuICAgICAgICAwXG4gICAgICApO1xuICAgICAgc2VjdG9yLmluc2V0ID0gaW5zZXQ7XG4gICAgICBzZWN0b3IubGluZUpvaW4gPSB0aGlzLnByb3BlcnRpZXMuc2VjdG9yU3BhY2luZyA+PSAwIHx8IGluc2V0ID4gMCA/IFwibWl0ZXJcIiA6IFwicm91bmRcIjtcbiAgICB9O1xuICAgIHRoaXMuaXRlbVNlbGVjdGlvbi5lYWNoKChub2RlLCBkYXR1bSwgaW5kZXgpID0+IHVwZGF0ZVNlY3RvckZuKG5vZGUsIGRhdHVtLCBpbmRleCwgZmFsc2UpKTtcbiAgICB0aGlzLmhpZ2hsaWdodFNlbGVjdGlvbi5lYWNoKChub2RlLCBkYXR1bSwgaW5kZXgpID0+IHtcbiAgICAgIHVwZGF0ZVNlY3RvckZuKG5vZGUsIGRhdHVtLCBpbmRleCwgdHJ1ZSk7XG4gICAgICBub2RlLnZpc2libGUgPSBkYXR1bS5pdGVtSWQgPT09IGhpZ2hsaWdodGVkRGF0dW0/Lml0ZW1JZDtcbiAgICB9KTtcbiAgICB0aGlzLnBoYW50b21TZWxlY3Rpb24uZWFjaCgobm9kZSwgZGF0dW0sIGluZGV4KSA9PiB1cGRhdGVTZWN0b3JGbihub2RlLCBkYXR1bSwgaW5kZXgsIGZhbHNlKSk7XG4gICAgdGhpcy51cGRhdGVDYWxsb3V0TGluZU5vZGVzKCk7XG4gICAgdGhpcy51cGRhdGVDYWxsb3V0TGFiZWxOb2RlcyhzZXJpZXNSZWN0KTtcbiAgICB0aGlzLnVwZGF0ZVNlY3RvckxhYmVsTm9kZXMoKTtcbiAgICB0aGlzLnVwZGF0ZVplcm9zdW1SaW5ncygpO1xuICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcInVwZGF0ZVwiKTtcbiAgfVxuICB1cGRhdGVDYWxsb3V0TGluZU5vZGVzKCkge1xuICAgIGNvbnN0IHsgY2FsbG91dExpbmUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCBjYWxsb3V0TGVuZ3RoID0gY2FsbG91dExpbmUubGVuZ3RoO1xuICAgIGNvbnN0IGNhbGxvdXRTdHJva2VXaWR0aCA9IGNhbGxvdXRMaW5lLnN0cm9rZVdpZHRoO1xuICAgIGNvbnN0IGNhbGxvdXRDb2xvcnMgPSBjYWxsb3V0TGluZS5jb2xvcnMgPz8gdGhpcy5wcm9wZXJ0aWVzLnN0cm9rZXM7XG4gICAgY29uc3QgeyBvZmZzZXQ6IG9mZnNldDQgfSA9IHRoaXMucHJvcGVydGllcy5jYWxsb3V0TGFiZWw7XG4gICAgdGhpcy5jYWxsb3V0TGFiZWxTZWxlY3Rpb24uc2VsZWN0QnlUYWcoMCAvKiBDYWxsb3V0ICovKS5mb3JFYWNoKChsaW5lLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgZGF0dW0gPSBsaW5lLmRhdHVtO1xuICAgICAgY29uc3QgeyBjYWxsb3V0TGFiZWw6IGxhYmVsLCBvdXRlclJhZGl1cyB9ID0gZGF0dW07XG4gICAgICBpZiAobGFiZWw/LnRleHQgJiYgIWxhYmVsLmhpZGRlbiAmJiBvdXRlclJhZGl1cyAhPT0gMCkge1xuICAgICAgICBsaW5lLnZpc2libGUgPSB0cnVlO1xuICAgICAgICBsaW5lLnN0cm9rZVdpZHRoID0gY2FsbG91dFN0cm9rZVdpZHRoO1xuICAgICAgICBsaW5lLnN0cm9rZSA9IGNhbGxvdXRDb2xvcnNbaW5kZXggJSBjYWxsb3V0Q29sb3JzLmxlbmd0aF07XG4gICAgICAgIGxpbmUuZmlsbCA9IHZvaWQgMDtcbiAgICAgICAgY29uc3QgeDEgPSBkYXR1bS5taWRDb3MgKiBvdXRlclJhZGl1cztcbiAgICAgICAgY29uc3QgeTEgPSBkYXR1bS5taWRTaW4gKiBvdXRlclJhZGl1cztcbiAgICAgICAgbGV0IHgyID0gZGF0dW0ubWlkQ29zICogKG91dGVyUmFkaXVzICsgY2FsbG91dExlbmd0aCk7XG4gICAgICAgIGxldCB5MiA9IGRhdHVtLm1pZFNpbiAqIChvdXRlclJhZGl1cyArIGNhbGxvdXRMZW5ndGgpO1xuICAgICAgICBjb25zdCBpc01vdmVkID0gbGFiZWwuY29sbGlzaW9uVGV4dEFsaWduID8/IGxhYmVsLmNvbGxpc2lvbk9mZnNldFkgIT09IDA7XG4gICAgICAgIGlmIChpc01vdmVkICYmIGxhYmVsLmJveCAhPSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgYm94ID0gbGFiZWwuYm94O1xuICAgICAgICAgIGxldCBjeCA9IHgyO1xuICAgICAgICAgIGxldCBjeSA9IHkyO1xuICAgICAgICAgIGlmICh4MiA8IGJveC54KSB7XG4gICAgICAgICAgICBjeCA9IGJveC54O1xuICAgICAgICAgIH0gZWxzZSBpZiAoeDIgPiBib3gueCArIGJveC53aWR0aCkge1xuICAgICAgICAgICAgY3ggPSBib3gueCArIGJveC53aWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHkyIDwgYm94LnkpIHtcbiAgICAgICAgICAgIGN5ID0gYm94Lnk7XG4gICAgICAgICAgfSBlbHNlIGlmICh5MiA+IGJveC55ICsgYm94LmhlaWdodCkge1xuICAgICAgICAgICAgY3kgPSBib3gueSArIGJveC5oZWlnaHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGR4ID0gY3ggLSB4MjtcbiAgICAgICAgICBjb25zdCBkeSA9IGN5IC0geTI7XG4gICAgICAgICAgY29uc3QgbGVuZ3RoMiA9IE1hdGguc3FydChNYXRoLnBvdyhkeCwgMikgKyBNYXRoLnBvdyhkeSwgMikpO1xuICAgICAgICAgIGNvbnN0IHBhZGRlZExlbmd0aCA9IGxlbmd0aDIgLSBvZmZzZXQ0O1xuICAgICAgICAgIGlmIChwYWRkZWRMZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB4MiA9IHgyICsgZHggKiBwYWRkZWRMZW5ndGggLyBsZW5ndGgyO1xuICAgICAgICAgICAgeTIgPSB5MiArIGR5ICogcGFkZGVkTGVuZ3RoIC8gbGVuZ3RoMjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGluZS54MSA9IHgxO1xuICAgICAgICBsaW5lLnkxID0geTE7XG4gICAgICAgIGxpbmUueDIgPSB4MjtcbiAgICAgICAgbGluZS55MiA9IHkyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGluZS52aXNpYmxlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZ2V0TGFiZWxPdmVyZmxvdyh0ZXh0LCBib3gsIHNlcmllc1JlY3QpIHtcbiAgICBjb25zdCBzZXJpZXNMZWZ0ID0gc2VyaWVzUmVjdC54IC0gdGhpcy5jZW50ZXJYO1xuICAgIGNvbnN0IHNlcmllc1JpZ2h0ID0gc2VyaWVzUmVjdC54ICsgc2VyaWVzUmVjdC53aWR0aCAtIHRoaXMuY2VudGVyWDtcbiAgICBjb25zdCBzZXJpZXNUb3AgPSBzZXJpZXNSZWN0LnkgLSB0aGlzLmNlbnRlclk7XG4gICAgY29uc3Qgc2VyaWVzQm90dG9tID0gc2VyaWVzUmVjdC55ICsgc2VyaWVzUmVjdC5oZWlnaHQgLSB0aGlzLmNlbnRlclk7XG4gICAgY29uc3QgZXJyUHggPSAxO1xuICAgIGxldCB2aXNpYmxlVGV4dFBhcnQgPSAxO1xuICAgIGlmIChib3gueCArIGVyclB4IDwgc2VyaWVzTGVmdCkge1xuICAgICAgdmlzaWJsZVRleHRQYXJ0ID0gKGJveC54ICsgYm94LndpZHRoIC0gc2VyaWVzTGVmdCkgLyBib3gud2lkdGg7XG4gICAgfSBlbHNlIGlmIChib3gueCArIGJveC53aWR0aCAtIGVyclB4ID4gc2VyaWVzUmlnaHQpIHtcbiAgICAgIHZpc2libGVUZXh0UGFydCA9IChzZXJpZXNSaWdodCAtIGJveC54KSAvIGJveC53aWR0aDtcbiAgICB9XG4gICAgY29uc3QgaGFzVmVydGljYWxPdmVyZmxvdyA9IGJveC55ICsgZXJyUHggPCBzZXJpZXNUb3AgfHwgYm94LnkgKyBib3guaGVpZ2h0IC0gZXJyUHggPiBzZXJpZXNCb3R0b207XG4gICAgY29uc3QgdGV4dExlbmd0aCA9IHZpc2libGVUZXh0UGFydCA9PT0gMSA/IHRleHQubGVuZ3RoIDogTWF0aC5mbG9vcih0ZXh0Lmxlbmd0aCAqIHZpc2libGVUZXh0UGFydCkgLSAxO1xuICAgIGNvbnN0IGhhc1N1cnJvdW5kaW5nU2VyaWVzT3ZlcmZsb3cgPSB0aGlzLmJib3hJbnRlcnNlY3RzU3Vycm91bmRpbmdTZXJpZXMoYm94KTtcbiAgICByZXR1cm4geyB0ZXh0TGVuZ3RoLCBoYXNWZXJ0aWNhbE92ZXJmbG93LCBoYXNTdXJyb3VuZGluZ1Nlcmllc092ZXJmbG93IH07XG4gIH1cbiAgYmJveEludGVyc2VjdHNTdXJyb3VuZGluZ1Nlcmllcyhib3gpIHtcbiAgICBjb25zdCB7IHN1cnJvdW5kaW5nUmFkaXVzIH0gPSB0aGlzO1xuICAgIGlmIChzdXJyb3VuZGluZ1JhZGl1cyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGNvcm5lcnMgPSBbXG4gICAgICB7IHg6IGJveC54LCB5OiBib3gueSB9LFxuICAgICAgeyB4OiBib3gueCArIGJveC53aWR0aCwgeTogYm94LnkgfSxcbiAgICAgIHsgeDogYm94LnggKyBib3gud2lkdGgsIHk6IGJveC55ICsgYm94LmhlaWdodCB9LFxuICAgICAgeyB4OiBib3gueCwgeTogYm94LnkgKyBib3guaGVpZ2h0IH1cbiAgICBdO1xuICAgIGNvbnN0IHN1cjIgPSBzdXJyb3VuZGluZ1JhZGl1cyAqKiAyO1xuICAgIHJldHVybiBjb3JuZXJzLnNvbWUoKGNvcm5lcikgPT4gY29ybmVyLnggKiogMiArIGNvcm5lci55ICoqIDIgPiBzdXIyKTtcbiAgfVxuICBjb21wdXRlQ2FsbG91dExhYmVsQ29sbGlzaW9uT2Zmc2V0cygpIHtcbiAgICBjb25zdCB7IHJhZGl1c1NjYWxlIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgY2FsbG91dExhYmVsLCBjYWxsb3V0TGluZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHsgb2Zmc2V0OiBvZmZzZXQ0LCBtaW5TcGFjaW5nIH0gPSBjYWxsb3V0TGFiZWw7XG4gICAgY29uc3QgaW5uZXJSYWRpdXMgPSByYWRpdXNTY2FsZS5jb252ZXJ0KDApO1xuICAgIGNvbnN0IHNob3VsZFNraXAgPSAoZGF0dW0pID0+IHtcbiAgICAgIGNvbnN0IGxhYmVsID0gZGF0dW0uY2FsbG91dExhYmVsO1xuICAgICAgcmV0dXJuICFsYWJlbCB8fCBkYXR1bS5vdXRlclJhZGl1cyA9PT0gMDtcbiAgICB9O1xuICAgIGNvbnN0IGZ1bGxEYXRhID0gdGhpcy5jYWxsb3V0Tm9kZURhdGE7XG4gICAgY29uc3QgZGF0YSA9IGZ1bGxEYXRhLmZpbHRlcigodCkgPT4gIXNob3VsZFNraXAodCkpO1xuICAgIGRhdGEuZm9yRWFjaCgoZGF0dW0pID0+IHtcbiAgICAgIGNvbnN0IGxhYmVsID0gZGF0dW0uY2FsbG91dExhYmVsO1xuICAgICAgaWYgKGxhYmVsID09IG51bGwpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGxhYmVsLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgbGFiZWwuY29sbGlzaW9uVGV4dEFsaWduID0gdm9pZCAwO1xuICAgICAgbGFiZWwuY29sbGlzaW9uT2Zmc2V0WSA9IDA7XG4gICAgfSk7XG4gICAgaWYgKGRhdGEubGVuZ3RoIDw9IDEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGVmdExhYmVscyA9IGRhdGEuZmlsdGVyKChkKSA9PiBkLm1pZENvcyA8IDApLnNvcnQoKGEsIGIpID0+IGEubWlkU2luIC0gYi5taWRTaW4pO1xuICAgIGNvbnN0IHJpZ2h0TGFiZWxzID0gZGF0YS5maWx0ZXIoKGQpID0+IGQubWlkQ29zID49IDApLnNvcnQoKGEsIGIpID0+IGEubWlkU2luIC0gYi5taWRTaW4pO1xuICAgIGNvbnN0IHRvcExhYmVscyA9IGRhdGEuZmlsdGVyKChkKSA9PiBkLm1pZFNpbiA8IDAgJiYgZC5jYWxsb3V0TGFiZWw/LnRleHRBbGlnbiA9PT0gXCJjZW50ZXJcIikuc29ydCgoYSwgYikgPT4gYS5taWRDb3MgLSBiLm1pZENvcyk7XG4gICAgY29uc3QgYm90dG9tTGFiZWxzID0gZGF0YS5maWx0ZXIoKGQpID0+IGQubWlkU2luID49IDAgJiYgZC5jYWxsb3V0TGFiZWw/LnRleHRBbGlnbiA9PT0gXCJjZW50ZXJcIikuc29ydCgoYSwgYikgPT4gYS5taWRDb3MgLSBiLm1pZENvcyk7XG4gICAgY29uc3QgZ2V0VGV4dEJCb3ggPSAoZGF0dW0pID0+IHtcbiAgICAgIGNvbnN0IGxhYmVsID0gZGF0dW0uY2FsbG91dExhYmVsO1xuICAgICAgaWYgKGxhYmVsID09IG51bGwpXG4gICAgICAgIHJldHVybiBCQm94Lnplcm8uY2xvbmUoKTtcbiAgICAgIGNvbnN0IGxhYmVsUmFkaXVzID0gZGF0dW0ub3V0ZXJSYWRpdXMgKyBjYWxsb3V0TGluZS5sZW5ndGggKyBvZmZzZXQ0O1xuICAgICAgY29uc3QgeCA9IGRhdHVtLm1pZENvcyAqIGxhYmVsUmFkaXVzO1xuICAgICAgY29uc3QgeSA9IGRhdHVtLm1pZFNpbiAqIGxhYmVsUmFkaXVzICsgbGFiZWwuY29sbGlzaW9uT2Zmc2V0WTtcbiAgICAgIGNvbnN0IHRleHRBbGlnbiA9IGxhYmVsLmNvbGxpc2lvblRleHRBbGlnbiA/PyBsYWJlbC50ZXh0QWxpZ247XG4gICAgICBjb25zdCB0ZXh0QmFzZWxpbmUgPSBsYWJlbC50ZXh0QmFzZWxpbmU7XG4gICAgICByZXR1cm4gVGV4dC5jb21wdXRlQkJveChsYWJlbC50ZXh0LCB4LCB5LCB7XG4gICAgICAgIGZvbnQ6IHRoaXMucHJvcGVydGllcy5jYWxsb3V0TGFiZWwsXG4gICAgICAgIHRleHRBbGlnbixcbiAgICAgICAgdGV4dEJhc2VsaW5lXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGF2b2lkTmVpZ2hib3VyWUNvbGxpc2lvbiA9IChsYWJlbCwgbmV4dCwgZGlyZWN0aW9uKSA9PiB7XG4gICAgICBjb25zdCBib3ggPSBnZXRUZXh0QkJveChsYWJlbCkuZ3JvdyhtaW5TcGFjaW5nIC8gMik7XG4gICAgICBjb25zdCBvdGhlciA9IGdldFRleHRCQm94KG5leHQpLmdyb3cobWluU3BhY2luZyAvIDIpO1xuICAgICAgY29uc3QgY29sbGlkZXNPckJlaGluZCA9IGJveC54IDwgb3RoZXIueCArIG90aGVyLndpZHRoICYmIGJveC54ICsgYm94LndpZHRoID4gb3RoZXIueCAmJiAoZGlyZWN0aW9uID09PSBcInRvLXRvcFwiID8gYm94LnkgPCBvdGhlci55ICsgb3RoZXIuaGVpZ2h0IDogYm94LnkgKyBib3guaGVpZ2h0ID4gb3RoZXIueSk7XG4gICAgICBpZiAoY29sbGlkZXNPckJlaGluZCkge1xuICAgICAgICBjb25zdCBkeSA9IGRpcmVjdGlvbiA9PT0gXCJ0by10b3BcIiA/IGJveC55IC0gb3RoZXIueSAtIG90aGVyLmhlaWdodCA6IGJveC55ICsgYm94LmhlaWdodCAtIG90aGVyLnk7XG4gICAgICAgIG5leHQuY2FsbG91dExhYmVsLmNvbGxpc2lvbk9mZnNldFkgPSBkeTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGF2b2lkWUNvbGxpc2lvbnMgPSAobGFiZWxzKSA9PiB7XG4gICAgICBjb25zdCBtaWRMYWJlbCA9IGxhYmVscy5zbGljZSgpLnNvcnQoKGEsIGIpID0+IE1hdGguYWJzKGEubWlkU2luKSAtIE1hdGguYWJzKGIubWlkU2luKSlbMF07XG4gICAgICBjb25zdCBtaWRJbmRleCA9IGxhYmVscy5pbmRleE9mKG1pZExhYmVsKTtcbiAgICAgIGZvciAobGV0IGkgPSBtaWRJbmRleCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IHByZXYgPSBsYWJlbHNbaSArIDFdO1xuICAgICAgICBjb25zdCBuZXh0ID0gbGFiZWxzW2ldO1xuICAgICAgICBhdm9pZE5laWdoYm91cllDb2xsaXNpb24ocHJldiwgbmV4dCwgXCJ0by10b3BcIik7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gbWlkSW5kZXggKyAxOyBpIDwgbGFiZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHByZXYgPSBsYWJlbHNbaSAtIDFdO1xuICAgICAgICBjb25zdCBuZXh0ID0gbGFiZWxzW2ldO1xuICAgICAgICBhdm9pZE5laWdoYm91cllDb2xsaXNpb24ocHJldiwgbmV4dCwgXCJ0by1ib3R0b21cIik7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBhdm9pZFhDb2xsaXNpb25zID0gKGxhYmVscykgPT4ge1xuICAgICAgY29uc3QgbGFiZWxzQ29sbGlkZUxhYmVsc0J5WSA9IGRhdGEuc29tZSgoZGF0dW0pID0+IGRhdHVtLmNhbGxvdXRMYWJlbC5jb2xsaXNpb25PZmZzZXRZICE9PSAwKTtcbiAgICAgIGNvbnN0IGJveGVzID0gbGFiZWxzLm1hcCgobGFiZWwpID0+IGdldFRleHRCQm94KGxhYmVsKSk7XG4gICAgICBjb25zdCBwYWRkZWRCb3hlcyA9IGJveGVzLm1hcCgoYm94KSA9PiBib3guY2xvbmUoKS5ncm93KG1pblNwYWNpbmcgLyAyKSk7XG4gICAgICBsZXQgbGFiZWxzQ29sbGlkZUxhYmVsc0J5WCA9IGZhbHNlO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWRkZWRCb3hlcy5sZW5ndGggJiYgIWxhYmVsc0NvbGxpZGVMYWJlbHNCeVg7IGkrKykge1xuICAgICAgICBjb25zdCBib3ggPSBwYWRkZWRCb3hlc1tpXTtcbiAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgbGFiZWxzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgY29uc3Qgb3RoZXIgPSBwYWRkZWRCb3hlc1tqXTtcbiAgICAgICAgICBpZiAoYm94LmNvbGxpZGVzQkJveChvdGhlcikpIHtcbiAgICAgICAgICAgIGxhYmVsc0NvbGxpZGVMYWJlbHNCeVggPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBzZWN0b3JzID0gZnVsbERhdGEubWFwKChkYXR1bSkgPT4ge1xuICAgICAgICBjb25zdCB7IHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBvdXRlclJhZGl1cyB9ID0gZGF0dW07XG4gICAgICAgIHJldHVybiB7IHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMgfTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbGFiZWxzQ29sbGlkZVNlY3RvcnMgPSBib3hlcy5zb21lKChib3gpID0+IHtcbiAgICAgICAgcmV0dXJuIHNlY3RvcnMuc29tZSgoc2VjdG9yKSA9PiBib3hDb2xsaWRlc1NlY3Rvcihib3gsIHNlY3RvcikpO1xuICAgICAgfSk7XG4gICAgICBpZiAoIWxhYmVsc0NvbGxpZGVMYWJlbHNCeVggJiYgIWxhYmVsc0NvbGxpZGVMYWJlbHNCeVkgJiYgIWxhYmVsc0NvbGxpZGVTZWN0b3JzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxhYmVscy5maWx0ZXIoKGQpID0+IGQuY2FsbG91dExhYmVsLnRleHRBbGlnbiA9PT0gXCJjZW50ZXJcIikuZm9yRWFjaCgoZCkgPT4ge1xuICAgICAgICBjb25zdCBsYWJlbCA9IGQuY2FsbG91dExhYmVsO1xuICAgICAgICBpZiAoZC5taWRDb3MgPCAwKSB7XG4gICAgICAgICAgbGFiZWwuY29sbGlzaW9uVGV4dEFsaWduID0gXCJyaWdodFwiO1xuICAgICAgICB9IGVsc2UgaWYgKGQubWlkQ29zID4gMCkge1xuICAgICAgICAgIGxhYmVsLmNvbGxpc2lvblRleHRBbGlnbiA9IFwibGVmdFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhYmVsLmNvbGxpc2lvblRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgYXZvaWRZQ29sbGlzaW9ucyhsZWZ0TGFiZWxzKTtcbiAgICBhdm9pZFlDb2xsaXNpb25zKHJpZ2h0TGFiZWxzKTtcbiAgICBhdm9pZFhDb2xsaXNpb25zKHRvcExhYmVscyk7XG4gICAgYXZvaWRYQ29sbGlzaW9ucyhib3R0b21MYWJlbHMpO1xuICB9XG4gIHVwZGF0ZUNhbGxvdXRMYWJlbE5vZGVzKHNlcmllc1JlY3QpIHtcbiAgICBjb25zdCB7IHJhZGl1c1NjYWxlIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgY2FsbG91dExhYmVsLCBjYWxsb3V0TGluZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGNhbGxvdXRMZW5ndGggPSBjYWxsb3V0TGluZS5sZW5ndGg7XG4gICAgY29uc3QgeyBvZmZzZXQ6IG9mZnNldDQsIGNvbG9yIH0gPSBjYWxsb3V0TGFiZWw7XG4gICAgY29uc3QgdGVtcFRleHROb2RlID0gbmV3IFRleHQoKTtcbiAgICB0aGlzLmNhbGxvdXRMYWJlbFNlbGVjdGlvbi5zZWxlY3RCeVRhZygxIC8qIExhYmVsICovKS5mb3JFYWNoKCh0ZXh0KSA9PiB7XG4gICAgICBjb25zdCB7IGRhdHVtIH0gPSB0ZXh0O1xuICAgICAgY29uc3QgbGFiZWwgPSBkYXR1bS5jYWxsb3V0TGFiZWw7XG4gICAgICBjb25zdCByYWRpdXMgPSByYWRpdXNTY2FsZS5jb252ZXJ0KGRhdHVtLnJhZGl1cyk7XG4gICAgICBjb25zdCBvdXRlclJhZGl1cyA9IE1hdGgubWF4KDAsIHJhZGl1cyk7XG4gICAgICBpZiAoIWxhYmVsPy50ZXh0IHx8IG91dGVyUmFkaXVzID09PSAwIHx8IGxhYmVsLmhpZGRlbikge1xuICAgICAgICB0ZXh0LnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbGFiZWxSYWRpdXMgPSBvdXRlclJhZGl1cyArIGNhbGxvdXRMZW5ndGggKyBvZmZzZXQ0O1xuICAgICAgY29uc3QgeCA9IGRhdHVtLm1pZENvcyAqIGxhYmVsUmFkaXVzO1xuICAgICAgY29uc3QgeSA9IGRhdHVtLm1pZFNpbiAqIGxhYmVsUmFkaXVzICsgbGFiZWwuY29sbGlzaW9uT2Zmc2V0WTtcbiAgICAgIGNvbnN0IGFsaWduID0ge1xuICAgICAgICB0ZXh0QWxpZ246IGxhYmVsLmNvbGxpc2lvblRleHRBbGlnbiA/PyBsYWJlbC50ZXh0QWxpZ24sXG4gICAgICAgIHRleHRCYXNlbGluZTogbGFiZWwudGV4dEJhc2VsaW5lXG4gICAgICB9O1xuICAgICAgdGVtcFRleHROb2RlLnRleHQgPSBsYWJlbC50ZXh0O1xuICAgICAgdGVtcFRleHROb2RlLnggPSB4O1xuICAgICAgdGVtcFRleHROb2RlLnkgPSB5O1xuICAgICAgdGVtcFRleHROb2RlLnNldEZvbnQodGhpcy5wcm9wZXJ0aWVzLmNhbGxvdXRMYWJlbCk7XG4gICAgICB0ZW1wVGV4dE5vZGUuc2V0QWxpZ24oYWxpZ24pO1xuICAgICAgY29uc3QgYm94ID0gdGVtcFRleHROb2RlLmdldEJCb3goKTtcbiAgICAgIGxldCBkaXNwbGF5VGV4dCA9IGxhYmVsLnRleHQ7XG4gICAgICBsZXQgdmlzaWJsZSA9IHRydWU7XG4gICAgICBpZiAoY2FsbG91dExhYmVsLmF2b2lkQ29sbGlzaW9ucykge1xuICAgICAgICBjb25zdCB7IHRleHRMZW5ndGgsIGhhc1ZlcnRpY2FsT3ZlcmZsb3cgfSA9IHRoaXMuZ2V0TGFiZWxPdmVyZmxvdyhsYWJlbC50ZXh0LCBib3gsIHNlcmllc1JlY3QpO1xuICAgICAgICBkaXNwbGF5VGV4dCA9IGxhYmVsLnRleHQubGVuZ3RoID09PSB0ZXh0TGVuZ3RoID8gbGFiZWwudGV4dCA6IGAke2xhYmVsLnRleHQuc3Vic3RyaW5nKDAsIHRleHRMZW5ndGgpfVxcdTIwMjZgO1xuICAgICAgICB2aXNpYmxlID0gIWhhc1ZlcnRpY2FsT3ZlcmZsb3c7XG4gICAgICB9XG4gICAgICB0ZXh0LnRleHQgPSBkaXNwbGF5VGV4dDtcbiAgICAgIHRleHQueCA9IHg7XG4gICAgICB0ZXh0LnkgPSB5O1xuICAgICAgdGV4dC5zZXRGb250KHRoaXMucHJvcGVydGllcy5jYWxsb3V0TGFiZWwpO1xuICAgICAgdGV4dC5zZXRBbGlnbihhbGlnbik7XG4gICAgICB0ZXh0LmZpbGwgPSBjb2xvcjtcbiAgICAgIHRleHQudmlzaWJsZSA9IHZpc2libGU7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgY29tcHV0ZUxhYmVsc0JCb3gob3B0aW9ucywgc2VyaWVzUmVjdCkge1xuICAgIGNvbnN0IHsgY2FsbG91dExhYmVsLCBjYWxsb3V0TGluZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGNhbGxvdXRMZW5ndGggPSBjYWxsb3V0TGluZS5sZW5ndGg7XG4gICAgY29uc3QgeyBvZmZzZXQ6IG9mZnNldDQsIG1heENvbGxpc2lvbk9mZnNldCwgbWluU3BhY2luZyB9ID0gY2FsbG91dExhYmVsO1xuICAgIGlmICghY2FsbG91dExhYmVsLmF2b2lkQ29sbGlzaW9ucykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGF3YWl0IHRoaXMubWF5YmVSZWZyZXNoTm9kZURhdGEoKTtcbiAgICB0aGlzLnVwZGF0ZVJhZGl1c1NjYWxlKGZhbHNlKTtcbiAgICB0aGlzLmNvbXB1dGVDYWxsb3V0TGFiZWxDb2xsaXNpb25PZmZzZXRzKCk7XG4gICAgY29uc3QgdGV4dEJveGVzID0gW107XG4gICAgY29uc3QgdGV4dCA9IG5ldyBUZXh0KCk7XG4gICAgbGV0IHRpdGxlQm94O1xuICAgIGNvbnN0IHsgdGl0bGUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBpZiAodGl0bGU/LnRleHQgJiYgdGl0bGUuZW5hYmxlZCkge1xuICAgICAgY29uc3QgZHkgPSB0aGlzLmdldFRpdGxlVHJhbnNsYXRpb25ZKCk7XG4gICAgICBpZiAoaXNGaW5pdGUoZHkpKSB7XG4gICAgICAgIHRleHQudGV4dCA9IHRpdGxlLnRleHQ7XG4gICAgICAgIHRleHQueCA9IDA7XG4gICAgICAgIHRleHQueSA9IGR5O1xuICAgICAgICB0ZXh0LnNldEZvbnQodGl0bGUpO1xuICAgICAgICB0ZXh0LnNldEFsaWduKHtcbiAgICAgICAgICB0ZXh0QmFzZWxpbmU6IFwiYm90dG9tXCIsXG4gICAgICAgICAgdGV4dEFsaWduOiBcImNlbnRlclwiXG4gICAgICAgIH0pO1xuICAgICAgICB0aXRsZUJveCA9IHRleHQuZ2V0QkJveCgpO1xuICAgICAgICB0ZXh0Qm94ZXMucHVzaCh0aXRsZUJveCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY2FsbG91dE5vZGVEYXRhLmZvckVhY2goKGRhdHVtKSA9PiB7XG4gICAgICBjb25zdCBsYWJlbCA9IGRhdHVtLmNhbGxvdXRMYWJlbDtcbiAgICAgIGlmICghbGFiZWwgfHwgZGF0dW0ub3V0ZXJSYWRpdXMgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCBsYWJlbFJhZGl1cyA9IGRhdHVtLm91dGVyUmFkaXVzICsgY2FsbG91dExlbmd0aCArIG9mZnNldDQ7XG4gICAgICBjb25zdCB4ID0gZGF0dW0ubWlkQ29zICogbGFiZWxSYWRpdXM7XG4gICAgICBjb25zdCB5ID0gZGF0dW0ubWlkU2luICogbGFiZWxSYWRpdXMgKyBsYWJlbC5jb2xsaXNpb25PZmZzZXRZO1xuICAgICAgdGV4dC50ZXh0ID0gbGFiZWwudGV4dDtcbiAgICAgIHRleHQueCA9IHg7XG4gICAgICB0ZXh0LnkgPSB5O1xuICAgICAgdGV4dC5zZXRGb250KHRoaXMucHJvcGVydGllcy5jYWxsb3V0TGFiZWwpO1xuICAgICAgdGV4dC5zZXRBbGlnbih7XG4gICAgICAgIHRleHRBbGlnbjogbGFiZWwuY29sbGlzaW9uVGV4dEFsaWduID8/IGxhYmVsLnRleHRBbGlnbixcbiAgICAgICAgdGV4dEJhc2VsaW5lOiBsYWJlbC50ZXh0QmFzZWxpbmVcbiAgICAgIH0pO1xuICAgICAgY29uc3QgYm94ID0gdGV4dC5nZXRCQm94KCk7XG4gICAgICBsYWJlbC5ib3ggPSBib3g7XG4gICAgICBpZiAoTWF0aC5hYnMobGFiZWwuY29sbGlzaW9uT2Zmc2V0WSkgPiBtYXhDb2xsaXNpb25PZmZzZXQpIHtcbiAgICAgICAgbGFiZWwuaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRpdGxlQm94KSB7XG4gICAgICAgIGNvbnN0IHNlcmllc1RvcCA9IHNlcmllc1JlY3QueSAtIHRoaXMuY2VudGVyWTtcbiAgICAgICAgY29uc3QgdGl0bGVDbGVhbkFyZWEgPSBuZXcgQkJveChcbiAgICAgICAgICB0aXRsZUJveC54IC0gbWluU3BhY2luZyxcbiAgICAgICAgICBzZXJpZXNUb3AsXG4gICAgICAgICAgdGl0bGVCb3gud2lkdGggKyAyICogbWluU3BhY2luZyxcbiAgICAgICAgICB0aXRsZUJveC55ICsgdGl0bGVCb3guaGVpZ2h0ICsgbWluU3BhY2luZyAtIHNlcmllc1RvcFxuICAgICAgICApO1xuICAgICAgICBpZiAoYm94LmNvbGxpZGVzQkJveCh0aXRsZUNsZWFuQXJlYSkpIHtcbiAgICAgICAgICBsYWJlbC5oaWRkZW4gPSB0cnVlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuaGlkZVdoZW5OZWNlc3NhcnkpIHtcbiAgICAgICAgY29uc3QgeyB0ZXh0TGVuZ3RoLCBoYXNWZXJ0aWNhbE92ZXJmbG93LCBoYXNTdXJyb3VuZGluZ1Nlcmllc092ZXJmbG93IH0gPSB0aGlzLmdldExhYmVsT3ZlcmZsb3coXG4gICAgICAgICAgbGFiZWwudGV4dCxcbiAgICAgICAgICBib3gsXG4gICAgICAgICAgc2VyaWVzUmVjdFxuICAgICAgICApO1xuICAgICAgICBjb25zdCBpc1Rvb1Nob3J0ID0gbGFiZWwudGV4dC5sZW5ndGggPiAyICYmIHRleHRMZW5ndGggPCAyO1xuICAgICAgICBpZiAoaGFzVmVydGljYWxPdmVyZmxvdyB8fCBpc1Rvb1Nob3J0IHx8IGhhc1N1cnJvdW5kaW5nU2VyaWVzT3ZlcmZsb3cpIHtcbiAgICAgICAgICBsYWJlbC5oaWRkZW4gPSB0cnVlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGFiZWwuaGlkZGVuID0gZmFsc2U7XG4gICAgICB0ZXh0Qm94ZXMucHVzaChib3gpO1xuICAgIH0pO1xuICAgIGlmICh0ZXh0Qm94ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIEJCb3gubWVyZ2UodGV4dEJveGVzKTtcbiAgfVxuICB1cGRhdGVTZWN0b3JMYWJlbE5vZGVzKCkge1xuICAgIGNvbnN0IHsgcmFkaXVzU2NhbGUgfSA9IHRoaXM7XG4gICAgY29uc3QgaW5uZXJSYWRpdXMgPSByYWRpdXNTY2FsZS5jb252ZXJ0KDApO1xuICAgIGNvbnN0IHsgZm9udFNpemUsIGZvbnRTdHlsZSwgZm9udFdlaWdodCwgZm9udEZhbWlseSwgcG9zaXRpb25PZmZzZXQsIHBvc2l0aW9uUmF0aW8sIGNvbG9yIH0gPSB0aGlzLnByb3BlcnRpZXMuc2VjdG9yTGFiZWw7XG4gICAgY29uc3QgaXNEb251dCA9IGlubmVyUmFkaXVzID4gMDtcbiAgICBjb25zdCBzaW5nbGVWaXNpYmxlU2VjdG9yID0gdGhpcy5zZXJpZXNJdGVtRW5hYmxlZC5maWx0ZXIoQm9vbGVhbikubGVuZ3RoID09PSAxO1xuICAgIGNvbnN0IHVwZGF0ZVNlY3RvckxhYmVsID0gKHRleHQsIGRhdHVtKSA9PiB7XG4gICAgICBjb25zdCB7IHNlY3RvckxhYmVsLCBvdXRlclJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUgfSA9IGRhdHVtO1xuICAgICAgbGV0IGlzVGV4dFZpc2libGUgPSBmYWxzZTtcbiAgICAgIGlmIChzZWN0b3JMYWJlbCAmJiBvdXRlclJhZGl1cyAhPT0gMCkge1xuICAgICAgICBjb25zdCBsYWJlbFJhZGl1cyA9IGlubmVyUmFkaXVzICogKDEgLSBwb3NpdGlvblJhdGlvKSArIG91dGVyUmFkaXVzICogcG9zaXRpb25SYXRpbyArIHBvc2l0aW9uT2Zmc2V0O1xuICAgICAgICB0ZXh0LmZpbGwgPSBjb2xvcjtcbiAgICAgICAgdGV4dC5mb250U3R5bGUgPSBmb250U3R5bGU7XG4gICAgICAgIHRleHQuZm9udFdlaWdodCA9IGZvbnRXZWlnaHQ7XG4gICAgICAgIHRleHQuZm9udFNpemUgPSBmb250U2l6ZTtcbiAgICAgICAgdGV4dC5mb250RmFtaWx5ID0gZm9udEZhbWlseTtcbiAgICAgICAgdGV4dC50ZXh0ID0gc2VjdG9yTGFiZWwudGV4dDtcbiAgICAgICAgY29uc3Qgc2hvdWxkUHV0VGV4dEluQ2VudGVyID0gIWlzRG9udXQgJiYgc2luZ2xlVmlzaWJsZVNlY3RvcjtcbiAgICAgICAgaWYgKHNob3VsZFB1dFRleHRJbkNlbnRlcikge1xuICAgICAgICAgIHRleHQueCA9IDA7XG4gICAgICAgICAgdGV4dC55ID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0LnggPSBkYXR1bS5taWRDb3MgKiBsYWJlbFJhZGl1cztcbiAgICAgICAgICB0ZXh0LnkgPSBkYXR1bS5taWRTaW4gKiBsYWJlbFJhZGl1cztcbiAgICAgICAgfVxuICAgICAgICB0ZXh0LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgICAgIHRleHQudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIjtcbiAgICAgICAgY29uc3QgYmJveCA9IHRleHQuZ2V0QkJveCgpO1xuICAgICAgICBjb25zdCBjb3JuZXJzID0gW1xuICAgICAgICAgIFtiYm94LngsIGJib3gueV0sXG4gICAgICAgICAgW2Jib3gueCArIGJib3gud2lkdGgsIGJib3gueV0sXG4gICAgICAgICAgW2Jib3gueCArIGJib3gud2lkdGgsIGJib3gueSArIGJib3guaGVpZ2h0XSxcbiAgICAgICAgICBbYmJveC54LCBiYm94LnkgKyBiYm94LmhlaWdodF1cbiAgICAgICAgXTtcbiAgICAgICAgY29uc3Qgc2VjdG9yQm91bmRzID0geyBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzIH07XG4gICAgICAgIGlmIChjb3JuZXJzLmV2ZXJ5KChbeCwgeV0pID0+IGlzUG9pbnRJblNlY3Rvcih4LCB5LCBzZWN0b3JCb3VuZHMpKSkge1xuICAgICAgICAgIGlzVGV4dFZpc2libGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0ZXh0LnZpc2libGUgPSBpc1RleHRWaXNpYmxlO1xuICAgIH07XG4gICAgdGhpcy5sYWJlbFNlbGVjdGlvbi5lYWNoKHVwZGF0ZVNlY3RvckxhYmVsKTtcbiAgICB0aGlzLmhpZ2hsaWdodExhYmVsU2VsZWN0aW9uLmVhY2godXBkYXRlU2VjdG9yTGFiZWwpO1xuICB9XG4gIHVwZGF0ZVplcm9zdW1SaW5ncygpIHtcbiAgICB0aGlzLnplcm9zdW1PdXRlclJpbmcuc2l6ZSA9IHRoaXMuZ2V0T3V0ZXJSYWRpdXMoKSAqIDI7XG4gIH1cbiAgZ2V0RGF0dW1MZWdlbmROYW1lKG5vZGVEYXR1bSkge1xuICAgIGNvbnN0IHsgYW5nbGVLZXksIGNhbGxvdXRMYWJlbEtleSwgc2VjdG9yTGFiZWxLZXksIGxlZ2VuZEl0ZW1LZXkgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCB7IHNlY3RvckxhYmVsLCBjYWxsb3V0TGFiZWwsIGxlZ2VuZEl0ZW0gfSA9IG5vZGVEYXR1bTtcbiAgICBpZiAobGVnZW5kSXRlbUtleSAmJiBsZWdlbmRJdGVtICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBsZWdlbmRJdGVtLnRleHQ7XG4gICAgfSBlbHNlIGlmIChjYWxsb3V0TGFiZWxLZXkgJiYgY2FsbG91dExhYmVsS2V5ICE9PSBhbmdsZUtleSAmJiBjYWxsb3V0TGFiZWw/LnRleHQgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIGNhbGxvdXRMYWJlbC50ZXh0O1xuICAgIH0gZWxzZSBpZiAoc2VjdG9yTGFiZWxLZXkgJiYgc2VjdG9yTGFiZWxLZXkgIT09IGFuZ2xlS2V5ICYmIHNlY3RvckxhYmVsPy50ZXh0ICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBzZWN0b3JMYWJlbC50ZXh0O1xuICAgIH1cbiAgfVxuICBwaWNrTm9kZUNsb3Nlc3REYXR1bShwb2ludCkge1xuICAgIHJldHVybiBwaWNrQnlNYXRjaGluZ0FuZ2xlKHRoaXMsIHBvaW50KTtcbiAgfVxuICBnZXRUb29sdGlwSHRtbChub2RlRGF0dW0pIHtcbiAgICBpZiAoIXRoaXMucHJvcGVydGllcy5pc1ZhbGlkKCkpIHtcbiAgICAgIHJldHVybiBFTVBUWV9UT09MVElQX0NPTlRFTlQ7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGRhdHVtLFxuICAgICAgYW5nbGVWYWx1ZSxcbiAgICAgIHNlY3RvckZvcm1hdDogeyBmaWxsOiBjb2xvciB9LFxuICAgICAgaXRlbUlkXG4gICAgfSA9IG5vZGVEYXR1bTtcbiAgICBjb25zdCB0aXRsZSA9IHNhbml0aXplSHRtbCh0aGlzLnByb3BlcnRpZXMudGl0bGU/LnRleHQpO1xuICAgIGNvbnN0IGNvbnRlbnQgPSBpc0Zpbml0ZU51bWJlcihhbmdsZVZhbHVlKSA/IHRvRml4ZWQoYW5nbGVWYWx1ZSkgOiBTdHJpbmcoYW5nbGVWYWx1ZSk7XG4gICAgY29uc3QgbGFiZWxUZXh0ID0gdGhpcy5nZXREYXR1bUxlZ2VuZE5hbWUobm9kZURhdHVtKTtcbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLnRvb2x0aXAudG9Ub29sdGlwSHRtbChcbiAgICAgIHtcbiAgICAgICAgdGl0bGU6IHRpdGxlID8/IGxhYmVsVGV4dCxcbiAgICAgICAgY29udGVudDogdGl0bGUgJiYgbGFiZWxUZXh0ID8gYCR7bGFiZWxUZXh0fTogJHtjb250ZW50fWAgOiBjb250ZW50LFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGNvbG9yXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBkYXR1bSxcbiAgICAgICAgaXRlbUlkLFxuICAgICAgICB0aXRsZSxcbiAgICAgICAgY29sb3IsXG4gICAgICAgIHNlcmllc0lkOiB0aGlzLmlkLFxuICAgICAgICBhbmdsZUtleTogdGhpcy5wcm9wZXJ0aWVzLmFuZ2xlS2V5LFxuICAgICAgICBhbmdsZU5hbWU6IHRoaXMucHJvcGVydGllcy5hbmdsZU5hbWUsXG4gICAgICAgIHJhZGl1c0tleTogdGhpcy5wcm9wZXJ0aWVzLnJhZGl1c0tleSxcbiAgICAgICAgcmFkaXVzTmFtZTogdGhpcy5wcm9wZXJ0aWVzLnJhZGl1c05hbWUsXG4gICAgICAgIGNhbGxvdXRMYWJlbEtleTogdGhpcy5wcm9wZXJ0aWVzLmNhbGxvdXRMYWJlbEtleSxcbiAgICAgICAgY2FsbG91dExhYmVsTmFtZTogdGhpcy5wcm9wZXJ0aWVzLmNhbGxvdXRMYWJlbE5hbWUsXG4gICAgICAgIHNlY3RvckxhYmVsS2V5OiB0aGlzLnByb3BlcnRpZXMuc2VjdG9yTGFiZWxLZXksXG4gICAgICAgIHNlY3RvckxhYmVsTmFtZTogdGhpcy5wcm9wZXJ0aWVzLnNlY3RvckxhYmVsTmFtZSxcbiAgICAgICAgbGVnZW5kSXRlbUtleTogdGhpcy5wcm9wZXJ0aWVzLmxlZ2VuZEl0ZW1LZXlcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGdldExlZ2VuZERhdGEobGVnZW5kVHlwZSkge1xuICAgIGNvbnN0IHsgdmlzaWJsZSwgcHJvY2Vzc2VkRGF0YSwgZGF0YU1vZGVsIH0gPSB0aGlzO1xuICAgIGlmICghZGF0YU1vZGVsIHx8ICFwcm9jZXNzZWREYXRhPy5kYXRhLmxlbmd0aCB8fCBsZWdlbmRUeXBlICE9PSBcImNhdGVnb3J5XCIpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgeyBhbmdsZUtleSwgY2FsbG91dExhYmVsS2V5LCBzZWN0b3JMYWJlbEtleSwgbGVnZW5kSXRlbUtleSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGlmICghbGVnZW5kSXRlbUtleSAmJiAoIWNhbGxvdXRMYWJlbEtleSB8fCBjYWxsb3V0TGFiZWxLZXkgPT09IGFuZ2xlS2V5KSAmJiAoIXNlY3RvckxhYmVsS2V5IHx8IHNlY3RvckxhYmVsS2V5ID09PSBhbmdsZUtleSkpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgeyBjYWxsb3V0TGFiZWxJZHgsIHNlY3RvckxhYmVsSWR4LCBsZWdlbmRJdGVtSWR4IH0gPSB0aGlzLmdldFByb2Nlc3NlZERhdGFJbmRleGVzKGRhdGFNb2RlbCk7XG4gICAgY29uc3QgdGl0bGVUZXh0ID0gdGhpcy5wcm9wZXJ0aWVzLnRpdGxlPy5zaG93SW5MZWdlbmQgJiYgdGhpcy5wcm9wZXJ0aWVzLnRpdGxlLnRleHQ7XG4gICAgY29uc3QgbGVnZW5kRGF0YSA9IFtdO1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBwcm9jZXNzZWREYXRhLmRhdGEubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBjb25zdCB7IGRhdHVtLCB2YWx1ZXMgfSA9IHByb2Nlc3NlZERhdGEuZGF0YVtpbmRleF07XG4gICAgICBjb25zdCBsYWJlbFBhcnRzID0gW107XG4gICAgICBpZiAodGl0bGVUZXh0KSB7XG4gICAgICAgIGxhYmVsUGFydHMucHVzaCh0aXRsZVRleHQpO1xuICAgICAgfVxuICAgICAgY29uc3QgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoXG4gICAgICAgIGRhdHVtLFxuICAgICAgICAyICogTWF0aC5QSSxcbiAgICAgICAgMiAqIE1hdGguUEksXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBjYWxsb3V0TGFiZWxJZHggIT0gbnVsbCA/IHZhbHVlc1tjYWxsb3V0TGFiZWxJZHhdIDogdm9pZCAwLFxuICAgICAgICBzZWN0b3JMYWJlbElkeCAhPSBudWxsID8gdmFsdWVzW3NlY3RvckxhYmVsSWR4XSA6IHZvaWQgMCxcbiAgICAgICAgbGVnZW5kSXRlbUlkeCAhPSBudWxsID8gdmFsdWVzW2xlZ2VuZEl0ZW1JZHhdIDogdm9pZCAwXG4gICAgICApO1xuICAgICAgaWYgKGxlZ2VuZEl0ZW1LZXkgJiYgbGFiZWxzLmxlZ2VuZEl0ZW0gIT09IHZvaWQgMCkge1xuICAgICAgICBsYWJlbFBhcnRzLnB1c2gobGFiZWxzLmxlZ2VuZEl0ZW0udGV4dCk7XG4gICAgICB9IGVsc2UgaWYgKGNhbGxvdXRMYWJlbEtleSAmJiBjYWxsb3V0TGFiZWxLZXkgIT09IGFuZ2xlS2V5ICYmIGxhYmVscy5jYWxsb3V0TGFiZWw/LnRleHQgIT09IHZvaWQgMCkge1xuICAgICAgICBsYWJlbFBhcnRzLnB1c2gobGFiZWxzLmNhbGxvdXRMYWJlbD8udGV4dCk7XG4gICAgICB9IGVsc2UgaWYgKHNlY3RvckxhYmVsS2V5ICYmIHNlY3RvckxhYmVsS2V5ICE9PSBhbmdsZUtleSAmJiBsYWJlbHMuc2VjdG9yTGFiZWw/LnRleHQgIT09IHZvaWQgMCkge1xuICAgICAgICBsYWJlbFBhcnRzLnB1c2gobGFiZWxzLnNlY3RvckxhYmVsPy50ZXh0KTtcbiAgICAgIH1cbiAgICAgIGlmIChsYWJlbFBhcnRzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCBzZWN0b3JGb3JtYXQgPSB0aGlzLmdldFNlY3RvckZvcm1hdChkYXR1bSwgaW5kZXgsIGZhbHNlKTtcbiAgICAgIGxlZ2VuZERhdGEucHVzaCh7XG4gICAgICAgIGxlZ2VuZFR5cGU6IFwiY2F0ZWdvcnlcIixcbiAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgIGl0ZW1JZDogaW5kZXgsXG4gICAgICAgIHNlcmllc0lkOiB0aGlzLmlkLFxuICAgICAgICBlbmFibGVkOiB2aXNpYmxlICYmIHRoaXMubGVnZW5kSXRlbUVuYWJsZWRbaW5kZXhdLFxuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgIHRleHQ6IGxhYmVsUGFydHMuam9pbihcIiAtIFwiKVxuICAgICAgICB9LFxuICAgICAgICBzeW1ib2xzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgbWFya2VyOiB7XG4gICAgICAgICAgICAgIGZpbGw6IHNlY3RvckZvcm1hdC5maWxsLFxuICAgICAgICAgICAgICBzdHJva2U6IHNlY3RvckZvcm1hdC5zdHJva2UsXG4gICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiB0aGlzLnByb3BlcnRpZXMuZmlsbE9wYWNpdHksXG4gICAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IHRoaXMucHJvcGVydGllcy5zdHJva2VPcGFjaXR5LFxuICAgICAgICAgICAgICBzdHJva2VXaWR0aDogdGhpcy5wcm9wZXJ0aWVzLnN0cm9rZVdpZHRoXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBsZWdlbmRJdGVtTmFtZTogbGVnZW5kSXRlbUtleSAhPSBudWxsID8gZGF0dW1bbGVnZW5kSXRlbUtleV0gOiB2b2lkIDBcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbGVnZW5kRGF0YTtcbiAgfVxuICBvbkxlZ2VuZEl0ZW1DbGljayhldmVudCkge1xuICAgIGNvbnN0IHsgZW5hYmxlZCwgaXRlbUlkLCBzZXJpZXMsIGxlZ2VuZEl0ZW1OYW1lIH0gPSBldmVudDtcbiAgICBpZiAoc2VyaWVzLmlkID09PSB0aGlzLmlkKSB7XG4gICAgICB0aGlzLnRvZ2dsZVNlcmllc0l0ZW0oaXRlbUlkLCBlbmFibGVkKTtcbiAgICB9IGVsc2UgaWYgKGxlZ2VuZEl0ZW1OYW1lICE9IG51bGwpIHtcbiAgICAgIHRoaXMudG9nZ2xlT3RoZXJTZXJpZXNJdGVtcyhsZWdlbmRJdGVtTmFtZSwgZW5hYmxlZCk7XG4gICAgfVxuICB9XG4gIHRvZ2dsZVNlcmllc0l0ZW0oaXRlbUlkLCBlbmFibGVkKSB7XG4gICAgdGhpcy5zZXJpZXNJdGVtRW5hYmxlZFtpdGVtSWRdID0gZW5hYmxlZDtcbiAgICB0aGlzLmxlZ2VuZEl0ZW1FbmFibGVkW2l0ZW1JZF0gPSBlbmFibGVkO1xuICAgIGlmICh0aGlzLm5vZGVEYXRhW2l0ZW1JZF0pIHtcbiAgICAgIHRoaXMubm9kZURhdGFbaXRlbUlkXS5lbmFibGVkID0gZW5hYmxlZDtcbiAgICB9XG4gICAgdGhpcy5ub2RlRGF0YVJlZnJlc2ggPSB0cnVlO1xuICB9XG4gIC8vIFVzZWQgZm9yIGdyaWRcbiAgc2V0TGVnZW5kU3RhdGUoZW5hYmxlZEl0ZW1zKSB7XG4gICAgdGhpcy5sZWdlbmRJdGVtRW5hYmxlZCA9IGVuYWJsZWRJdGVtcztcbiAgICB0aGlzLmN0eC51cGRhdGVTZXJ2aWNlLnVwZGF0ZSg0IC8qIFNFUklFU19VUERBVEUgKi8pO1xuICB9XG4gIHRvZ2dsZU90aGVyU2VyaWVzSXRlbXMobGVnZW5kSXRlbU5hbWUsIGVuYWJsZWQpIHtcbiAgICBpZiAoIXRoaXMucHJvcGVydGllcy5sZWdlbmRJdGVtS2V5IHx8ICF0aGlzLmRhdGFNb2RlbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsZWdlbmRJdGVtSWR4ID0gdGhpcy5kYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYGxlZ2VuZEl0ZW1WYWx1ZWApO1xuICAgIHRoaXMucHJvY2Vzc2VkRGF0YT8uZGF0YS5mb3JFYWNoKCh7IHZhbHVlcyB9LCBkYXR1bUl0ZW1JZCkgPT4ge1xuICAgICAgaWYgKHZhbHVlc1tsZWdlbmRJdGVtSWR4XSA9PT0gbGVnZW5kSXRlbU5hbWUpIHtcbiAgICAgICAgdGhpcy50b2dnbGVTZXJpZXNJdGVtKGRhdHVtSXRlbUlkLCBlbmFibGVkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhbmltYXRlRW1wdHlVcGRhdGVSZWFkeShfZGF0YSkge1xuICAgIGNvbnN0IHsgYW5pbWF0aW9uTWFuYWdlciB9ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgZm5zID0gcHJlcGFyZVBpZVNlcmllc0FuaW1hdGlvbkZ1bmN0aW9ucyhcbiAgICAgIHRydWUsXG4gICAgICB0aGlzLnByb3BlcnRpZXMucm90YXRpb24sXG4gICAgICB0aGlzLnJhZGl1c1NjYWxlLFxuICAgICAgdGhpcy5wcmV2aW91c1JhZGl1c1NjYWxlXG4gICAgKTtcbiAgICBmcm9tVG9Nb3Rpb24oXG4gICAgICB0aGlzLmlkLFxuICAgICAgXCJub2Rlc1wiLFxuICAgICAgYW5pbWF0aW9uTWFuYWdlcixcbiAgICAgIFt0aGlzLml0ZW1TZWxlY3Rpb24sIHRoaXMuaGlnaGxpZ2h0U2VsZWN0aW9uLCB0aGlzLnBoYW50b21TZWxlY3Rpb25dLFxuICAgICAgZm5zLm5vZGVzLFxuICAgICAgKF8sIGRhdHVtKSA9PiB0aGlzLmdldERhdHVtSWQoZGF0dW0pXG4gICAgKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImNhbGxvdXRcIiwgYW5pbWF0aW9uTWFuYWdlciwgdGhpcy5jYWxsb3V0TGFiZWxTZWxlY3Rpb24pO1xuICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwic2VjdG9yXCIsIGFuaW1hdGlvbk1hbmFnZXIsIHRoaXMubGFiZWxTZWxlY3Rpb24pO1xuICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwiaGlnaGxpZ2h0XCIsIGFuaW1hdGlvbk1hbmFnZXIsIHRoaXMuaGlnaGxpZ2h0TGFiZWxTZWxlY3Rpb24pO1xuICAgIHRoaXMucHJldmlvdXNSYWRpdXNTY2FsZS5yYW5nZSA9IHRoaXMucmFkaXVzU2NhbGUucmFuZ2U7XG4gIH1cbiAgYW5pbWF0ZVdhaXRpbmdVcGRhdGVSZWFkeSgpIHtcbiAgICBjb25zdCB7IGl0ZW1TZWxlY3Rpb24sIGhpZ2hsaWdodFNlbGVjdGlvbiwgcGhhbnRvbVNlbGVjdGlvbiwgcHJvY2Vzc2VkRGF0YSwgcmFkaXVzU2NhbGUsIHByZXZpb3VzUmFkaXVzU2NhbGUgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBhbmltYXRpb25NYW5hZ2VyIH0gPSB0aGlzLmN0eDtcbiAgICBjb25zdCBkYXRhRGlmZiA9IHByb2Nlc3NlZERhdGE/LnJlZHVjZWQ/LmRpZmY7XG4gICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5zdG9wQnlBbmltYXRpb25Hcm91cElkKHRoaXMuaWQpO1xuICAgIGNvbnN0IHN1cHBvcnRlZERpZmYgPSAoZGF0YURpZmY/Lm1vdmVkLnNpemUgPz8gMCkgPT09IDA7XG4gICAgY29uc3QgaGFzS2V5cyA9IChwcm9jZXNzZWREYXRhPy5kZWZzLmtleXMubGVuZ3RoID8/IDApID4gMDtcbiAgICBjb25zdCBoYXNVbmlxdWVLZXlzID0gcHJvY2Vzc2VkRGF0YT8ucmVkdWNlZD8uYW5pbWF0aW9uVmFsaWRhdGlvbj8udW5pcXVlS2V5cyA/PyB0cnVlO1xuICAgIGlmICghc3VwcG9ydGVkRGlmZiB8fCAhaGFzS2V5cyB8fCAhaGFzVW5pcXVlS2V5cykge1xuICAgICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5za2lwQ3VycmVudEJhdGNoKCk7XG4gICAgfVxuICAgIGNvbnN0IGZucyA9IHByZXBhcmVQaWVTZXJpZXNBbmltYXRpb25GdW5jdGlvbnMoXG4gICAgICBmYWxzZSxcbiAgICAgIHRoaXMucHJvcGVydGllcy5yb3RhdGlvbixcbiAgICAgIHJhZGl1c1NjYWxlLFxuICAgICAgcHJldmlvdXNSYWRpdXNTY2FsZVxuICAgICk7XG4gICAgZnJvbVRvTW90aW9uKFxuICAgICAgdGhpcy5pZCxcbiAgICAgIFwibm9kZXNcIixcbiAgICAgIGFuaW1hdGlvbk1hbmFnZXIsXG4gICAgICBbaXRlbVNlbGVjdGlvbiwgaGlnaGxpZ2h0U2VsZWN0aW9uLCBwaGFudG9tU2VsZWN0aW9uXSxcbiAgICAgIGZucy5ub2RlcyxcbiAgICAgIChfLCBkYXR1bSkgPT4gdGhpcy5nZXREYXR1bUlkKGRhdHVtKSxcbiAgICAgIGRhdGFEaWZmXG4gICAgKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImNhbGxvdXRcIiwgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgdGhpcy5jYWxsb3V0TGFiZWxTZWxlY3Rpb24pO1xuICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwic2VjdG9yXCIsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIHRoaXMubGFiZWxTZWxlY3Rpb24pO1xuICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwiaGlnaGxpZ2h0XCIsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIHRoaXMuaGlnaGxpZ2h0TGFiZWxTZWxlY3Rpb24pO1xuICAgIHRoaXMucHJldmlvdXNSYWRpdXNTY2FsZS5yYW5nZSA9IHRoaXMucmFkaXVzU2NhbGUucmFuZ2U7XG4gIH1cbiAgYW5pbWF0ZUNsZWFyaW5nVXBkYXRlRW1wdHkoKSB7XG4gICAgY29uc3QgeyBpdGVtU2VsZWN0aW9uLCBoaWdobGlnaHRTZWxlY3Rpb24sIHBoYW50b21TZWxlY3Rpb24sIHJhZGl1c1NjYWxlLCBwcmV2aW91c1JhZGl1c1NjYWxlIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgYW5pbWF0aW9uTWFuYWdlciB9ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgZm5zID0gcHJlcGFyZVBpZVNlcmllc0FuaW1hdGlvbkZ1bmN0aW9ucyhcbiAgICAgIGZhbHNlLFxuICAgICAgdGhpcy5wcm9wZXJ0aWVzLnJvdGF0aW9uLFxuICAgICAgcmFkaXVzU2NhbGUsXG4gICAgICBwcmV2aW91c1JhZGl1c1NjYWxlXG4gICAgKTtcbiAgICBmcm9tVG9Nb3Rpb24oXG4gICAgICB0aGlzLmlkLFxuICAgICAgXCJub2Rlc1wiLFxuICAgICAgYW5pbWF0aW9uTWFuYWdlcixcbiAgICAgIFtpdGVtU2VsZWN0aW9uLCBoaWdobGlnaHRTZWxlY3Rpb24sIHBoYW50b21TZWxlY3Rpb25dLFxuICAgICAgZm5zLm5vZGVzLFxuICAgICAgKF8sIGRhdHVtKSA9PiB0aGlzLmdldERhdHVtSWQoZGF0dW0pXG4gICAgKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVPdXRBbmltYXRpb24odGhpcywgXCJjYWxsb3V0XCIsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIHRoaXMuY2FsbG91dExhYmVsU2VsZWN0aW9uKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVPdXRBbmltYXRpb24odGhpcywgXCJzZWN0b3JcIiwgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgdGhpcy5sYWJlbFNlbGVjdGlvbik7XG4gICAgc2VyaWVzTGFiZWxGYWRlT3V0QW5pbWF0aW9uKHRoaXMsIFwiaGlnaGxpZ2h0XCIsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIHRoaXMuaGlnaGxpZ2h0TGFiZWxTZWxlY3Rpb24pO1xuICAgIHRoaXMucHJldmlvdXNSYWRpdXNTY2FsZS5yYW5nZSA9IHRoaXMucmFkaXVzU2NhbGUucmFuZ2U7XG4gIH1cbiAgZ2V0RGF0dW1JZEZyb21EYXRhKGRhdHVtKSB7XG4gICAgY29uc3QgeyBjYWxsb3V0TGFiZWxLZXksIHNlY3RvckxhYmVsS2V5LCBsZWdlbmRJdGVtS2V5IH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgaWYgKCF0aGlzLnByb2Nlc3NlZERhdGE/LnJlZHVjZWQ/LmFuaW1hdGlvblZhbGlkYXRpb24/LnVuaXF1ZUtleXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGxlZ2VuZEl0ZW1LZXkpIHtcbiAgICAgIHJldHVybiBkYXR1bVtsZWdlbmRJdGVtS2V5XTtcbiAgICB9IGVsc2UgaWYgKGNhbGxvdXRMYWJlbEtleSkge1xuICAgICAgcmV0dXJuIGRhdHVtW2NhbGxvdXRMYWJlbEtleV07XG4gICAgfSBlbHNlIGlmIChzZWN0b3JMYWJlbEtleSkge1xuICAgICAgcmV0dXJuIGRhdHVtW3NlY3RvckxhYmVsS2V5XTtcbiAgICB9XG4gIH1cbiAgZ2V0RGF0dW1JZChkYXR1bSkge1xuICAgIGNvbnN0IHsgaW5kZXggfSA9IGRhdHVtO1xuICAgIGNvbnN0IGRhdHVtSWQgPSB0aGlzLmdldERhdHVtSWRGcm9tRGF0YShkYXR1bS5kYXR1bSk7XG4gICAgcmV0dXJuIGRhdHVtSWQgIT0gbnVsbCA/IFN0cmluZyhkYXR1bUlkKSA6IGAke2luZGV4fWA7XG4gIH1cbiAgb25EYXRhQ2hhbmdlKCkge1xuICAgIGNvbnN0IHsgZGF0YSwgc2VyaWVzSXRlbUVuYWJsZWQsIGxlZ2VuZEl0ZW1FbmFibGVkIH0gPSB0aGlzO1xuICAgIHRoaXMuc2VyaWVzSXRlbUVuYWJsZWQgPSBkYXRhPy5tYXAoKF8sIGluZGV4KSA9PiBzZXJpZXNJdGVtRW5hYmxlZFtpbmRleF0gPz8gdHJ1ZSkgPz8gW107XG4gICAgdGhpcy5sZWdlbmRJdGVtRW5hYmxlZCA9IGRhdGE/Lm1hcCgoXywgaW5kZXgpID0+IGxlZ2VuZEl0ZW1FbmFibGVkW2luZGV4XSA/PyB0cnVlKSA/PyBbXTtcbiAgfVxufTtcblBpZVNlcmllcy5jbGFzc05hbWUgPSBcIlBpZVNlcmllc1wiO1xuUGllU2VyaWVzLnR5cGUgPSBcInBpZVwiO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvcG9sYXIvcGllU2VyaWVzTW9kdWxlLnRzXG52YXIgUGllU2VyaWVzTW9kdWxlID0ge1xuICB0eXBlOiBcInNlcmllc1wiLFxuICBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsXG4gIHBhY2thZ2VUeXBlOiBcImNvbW11bml0eVwiLFxuICBjaGFydFR5cGVzOiBbXCJwb2xhclwiXSxcbiAgaWRlbnRpZmllcjogXCJwaWVcIixcbiAgbW9kdWxlRmFjdG9yeTogKGN0eCkgPT4gbmV3IFBpZVNlcmllcyhjdHgpLFxuICB0b29sdGlwRGVmYXVsdHM6IHsgcmFuZ2U6IFwiZXhhY3RcIiB9LFxuICB0aGVtZVRlbXBsYXRlOiBwaWVUaGVtZSxcbiAgcGFsZXR0ZUZhY3Rvcnk6IHBpZVBhbGV0dGVGYWN0b3J5XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3ZlY3Rvci50c1xudmFyIFZlYzIgPSB7XG4gIGFkZCxcbiAgYW5nbGUsXG4gIGFwcGx5LFxuICBlcXVhbCxcbiAgZGlzdGFuY2U6IGRpc3RhbmNlMixcbiAgZGlzdGFuY2VTcXVhcmVkOiBkaXN0YW5jZVNxdWFyZWQyLFxuICBmcm9tLFxuICBncmFkaWVudCxcbiAgaW50ZXJjZXB0LFxuICBpbnRlcnNlY3RBdFgsXG4gIGludGVyc2VjdEF0WSxcbiAgbGVuZ3RoLFxuICBsZW5ndGhTcXVhcmVkLFxuICBtdWx0aXBseSxcbiAgbm9ybWFsaXplZCxcbiAgb3JpZ2luLFxuICByZXF1aXJlZCxcbiAgcm90YXRlLFxuICByb3VuZDogcm91bmQzLFxuICBzdWJcbn07XG5mdW5jdGlvbiBhZGQoYSwgYikge1xuICBpZiAodHlwZW9mIGIgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4geyB4OiBhLnggKyBiLCB5OiBhLnkgKyBiIH07XG4gIH1cbiAgcmV0dXJuIHsgeDogYS54ICsgYi54LCB5OiBhLnkgKyBiLnkgfTtcbn1cbmZ1bmN0aW9uIHN1YihhLCBiKSB7XG4gIGlmICh0eXBlb2YgYiA9PT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiB7IHg6IGEueCAtIGIsIHk6IGEueSAtIGIgfTtcbiAgfVxuICByZXR1cm4geyB4OiBhLnggLSBiLngsIHk6IGEueSAtIGIueSB9O1xufVxuZnVuY3Rpb24gbXVsdGlwbHkoYSwgYikge1xuICBpZiAodHlwZW9mIGIgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4geyB4OiBhLnggKiBiLCB5OiBhLnkgKiBiIH07XG4gIH1cbiAgcmV0dXJuIHsgeDogYS54ICogYi54LCB5OiBhLnkgKiBiLnkgfTtcbn1cbmZ1bmN0aW9uIGxlbmd0aChhKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoYS54ICogYS54ICsgYS55ICogYS55KTtcbn1cbmZ1bmN0aW9uIGxlbmd0aFNxdWFyZWQoYSkge1xuICByZXR1cm4gYS54ICogYS54ICsgYS55ICogYS55O1xufVxuZnVuY3Rpb24gZGlzdGFuY2UyKGEsIGIpIHtcbiAgY29uc3QgZCA9IHN1YihhLCBiKTtcbiAgcmV0dXJuIE1hdGguc3FydChkLnggKiBkLnggKyBkLnkgKiBkLnkpO1xufVxuZnVuY3Rpb24gZGlzdGFuY2VTcXVhcmVkMihhLCBiKSB7XG4gIGNvbnN0IGQgPSBzdWIoYSwgYik7XG4gIHJldHVybiBkLnggKiBkLnggKyBkLnkgKiBkLnk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVkKGEpIHtcbiAgY29uc3QgbCA9IGxlbmd0aChhKTtcbiAgcmV0dXJuIHsgeDogYS54IC8gbCwgeTogYS55IC8gbCB9O1xufVxuZnVuY3Rpb24gYW5nbGUoYSwgYiA9IG9yaWdpbigpKSB7XG4gIHJldHVybiBNYXRoLmF0YW4yKGEueSwgYS54KSAtIE1hdGguYXRhbjIoYi55LCBiLngpO1xufVxuZnVuY3Rpb24gcm90YXRlKGEsIHRoZXRhLCBiID0gb3JpZ2luKCkpIHtcbiAgY29uc3QgbCA9IGxlbmd0aChhKTtcbiAgcmV0dXJuIHsgeDogYi54ICsgbCAqIE1hdGguY29zKHRoZXRhKSwgeTogYi55ICsgbCAqIE1hdGguc2luKHRoZXRhKSB9O1xufVxuZnVuY3Rpb24gZ3JhZGllbnQoYSwgYiwgcmVmbGVjdGlvbikge1xuICBjb25zdCBkeCA9IGIueCAtIGEueDtcbiAgY29uc3QgZHkgPSByZWZsZWN0aW9uID09IG51bGwgPyBiLnkgLSBhLnkgOiByZWZsZWN0aW9uIC0gYi55IC0gKHJlZmxlY3Rpb24gLSBhLnkpO1xuICByZXR1cm4gZHkgLyBkeDtcbn1cbmZ1bmN0aW9uIGludGVyY2VwdChhLCBncmFkaWVudDIsIHJlZmxlY3Rpb24pIHtcbiAgY29uc3QgeSA9IHJlZmxlY3Rpb24gPT0gbnVsbCA/IGEueSA6IHJlZmxlY3Rpb24gLSBhLnk7XG4gIHJldHVybiB5IC0gZ3JhZGllbnQyICogYS54O1xufVxuZnVuY3Rpb24gaW50ZXJzZWN0QXRZKGdyYWRpZW50MiwgY29lZmZpY2llbnQsIHkgPSAwLCByZWZsZWN0aW9uKSB7XG4gIHJldHVybiB7XG4gICAgeDogZ3JhZGllbnQyID09PSBJbmZpbml0eSA/IEluZmluaXR5IDogKHkgLSBjb2VmZmljaWVudCkgLyBncmFkaWVudDIsXG4gICAgeTogcmVmbGVjdGlvbiA9PSBudWxsID8geSA6IHJlZmxlY3Rpb24gLSB5XG4gIH07XG59XG5mdW5jdGlvbiBpbnRlcnNlY3RBdFgoZ3JhZGllbnQyLCBjb2VmZmljaWVudCwgeCA9IDAsIHJlZmxlY3Rpb24pIHtcbiAgY29uc3QgeSA9IGdyYWRpZW50MiA9PT0gSW5maW5pdHkgPyBJbmZpbml0eSA6IGdyYWRpZW50MiAqIHggKyBjb2VmZmljaWVudDtcbiAgcmV0dXJuIHsgeCwgeTogcmVmbGVjdGlvbiA9PSBudWxsID8geSA6IHJlZmxlY3Rpb24gLSB5IH07XG59XG5mdW5jdGlvbiByb3VuZDMoYSkge1xuICByZXR1cm4geyB4OiBNYXRoLnJvdW5kKGEueCksIHk6IE1hdGgucm91bmQoYS55KSB9O1xufVxuZnVuY3Rpb24gZXF1YWwoYSwgYikge1xuICByZXR1cm4gYS54ID09PSBiLnggJiYgYS55ID09PSBiLnk7XG59XG5mdW5jdGlvbiBmcm9tKGEsIGIpIHtcbiAgaWYgKHR5cGVvZiBhID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIHsgeDogYSwgeTogYiB9O1xuICB9XG4gIGlmIChcInJlZ2lvbk9mZnNldFhcIiBpbiBhKSB7XG4gICAgcmV0dXJuIHsgeDogYS5yZWdpb25PZmZzZXRYLCB5OiBhLnJlZ2lvbk9mZnNldFkgfTtcbiAgfVxuICBpZiAoXCJvZmZzZXRXaWR0aFwiIGluIGEpIHtcbiAgICByZXR1cm4geyB4OiBhLm9mZnNldFdpZHRoLCB5OiBhLm9mZnNldEhlaWdodCB9O1xuICB9XG4gIGlmIChcIndpZHRoXCIgaW4gYSkge1xuICAgIHJldHVybiBbXG4gICAgICB7IHg6IGEueCwgeTogYS55IH0sXG4gICAgICB7IHg6IGEueCArIGEud2lkdGgsIHk6IGEueSArIGEuaGVpZ2h0IH1cbiAgICBdO1xuICB9XG4gIGlmIChcIngxXCIgaW4gYSkge1xuICAgIHJldHVybiBbXG4gICAgICB7IHg6IGEueDEsIHk6IGEueTEgfSxcbiAgICAgIHsgeDogYS54MiwgeTogYS55MiB9XG4gICAgXTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYFZhbHVlcyBjYW4gbm90IGJlIGNvbnZlcnRlZCBpbnRvIGEgdmVjdG9yOiBbJHthfV0gWyR7Yn1dYCk7XG59XG5mdW5jdGlvbiBhcHBseShhLCBiKSB7XG4gIGEueCA9IGIueDtcbiAgYS55ID0gYi55O1xuICByZXR1cm4gYTtcbn1cbmZ1bmN0aW9uIHJlcXVpcmVkKGEpIHtcbiAgcmV0dXJuIHsgeDogYT8ueCA/PyAwLCB5OiBhPy55ID8/IDAgfTtcbn1cbmZ1bmN0aW9uIG9yaWdpbigpIHtcbiAgcmV0dXJuIHsgeDogMCwgeTogMCB9O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC90b29sYmFyL3Rvb2xiYXJQcm9wZXJ0aWVzLnRzXG52YXIgVG9vbGJhckdyb3VwUHJvcGVydGllcyA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcihvbkNoYW5nZSwgb25CdXR0b25zQ2hhbmdlKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm9uQ2hhbmdlID0gb25DaGFuZ2U7XG4gICAgdGhpcy5vbkJ1dHRvbnNDaGFuZ2UgPSBvbkJ1dHRvbnNDaGFuZ2U7XG4gICAgdGhpcy5hbGlnbiA9IFwic3RhcnRcIjtcbiAgICB0aGlzLnBvc2l0aW9uID0gXCJ0b3BcIiAvKiBUb3AgKi87XG4gICAgdGhpcy5zaXplID0gXCJub3JtYWxcIjtcbiAgICB0aGlzLmJ1dHRvbk92ZXJyaWRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgYnV0dG9uQ29uZmlndXJhdGlvbnMoKSB7XG4gICAgY29uc3QgYnV0dG9ucyA9IFsuLi50aGlzLmJ1dHRvbnMgPz8gW11dO1xuICAgIGlmICh0aGlzLmRyYWdnYWJsZSkge1xuICAgICAgYnV0dG9ucy51bnNoaWZ0KHtcbiAgICAgICAgaWNvbjogXCJkcmFnLWhhbmRsZVwiLFxuICAgICAgICB0b29sdGlwOiBcInRvb2xiYXJBbm5vdGF0aW9uc0RyYWdIYW5kbGVcIixcbiAgICAgICAgdmFsdWU6IFwiZHJhZ1wiLFxuICAgICAgICBpZDogXCJkcmFnXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYnV0dG9ucz8ubWFwKChidXR0b24pID0+IHtcbiAgICAgIGNvbnN0IGlkID0gYnV0dG9uLmlkID8/IGJ1dHRvbi52YWx1ZTtcbiAgICAgIGNvbnN0IG92ZXJyaWRlcyA9IHRoaXMuYnV0dG9uT3ZlcnJpZGVzLmdldChpZCk7XG4gICAgICByZXR1cm4gb3ZlcnJpZGVzICE9IG51bGwgPyB7IC4uLmJ1dHRvbiwgLi4ub3ZlcnJpZGVzIH0gOiBidXR0b247XG4gICAgfSkgPz8gW107XG4gIH1cbiAgYnV0dG9uc0NoYW5nZWQoY29uZmlndXJhdGlvbk9ubHkpIHtcbiAgICB0aGlzLm9uQnV0dG9uc0NoYW5nZSh0aGlzLmJ1dHRvbkNvbmZpZ3VyYXRpb25zKCksIGNvbmZpZ3VyYXRpb25Pbmx5KTtcbiAgfVxuICBvdmVycmlkZUJ1dHRvbkNvbmZpZ3VyYXRpb24oaWQsIG9wdGlvbnMpIHtcbiAgICBsZXQgb3ZlcnJpZGVzID0gdGhpcy5idXR0b25PdmVycmlkZXMuZ2V0KGlkKTtcbiAgICBpZiAob3ZlcnJpZGVzID09IG51bGwpIHtcbiAgICAgIG92ZXJyaWRlcyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgdGhpcy5idXR0b25PdmVycmlkZXMuc2V0KGlkLCBvdmVycmlkZXMpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvcHRpb25zKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IG9wdGlvbnNba2V5XTtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGRlbGV0ZSBvdmVycmlkZXNba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG92ZXJyaWRlc1trZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYnV0dG9uc0NoYW5nZWQodHJ1ZSk7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBPYnNlcnZlQ2hhbmdlcygodGFyZ2V0KSA9PiB7XG4gICAgdGFyZ2V0Lm9uQ2hhbmdlKHRhcmdldC5lbmFibGVkKTtcbiAgfSksXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBUb29sYmFyR3JvdXBQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgT2JzZXJ2ZUNoYW5nZXMoKHRhcmdldCkgPT4ge1xuICAgIHRhcmdldC5vbkNoYW5nZSh0YXJnZXQuZW5hYmxlZCk7XG4gIH0pLFxuICBWYWxpZGF0ZShVTklPTihbLi4uVE9PTEJBUl9BTElHTk1FTlRTXSksIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFRvb2xiYXJHcm91cFByb3BlcnRpZXMucHJvdG90eXBlLCBcImFsaWduXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgT2JzZXJ2ZUNoYW5nZXMoKHRhcmdldCkgPT4ge1xuICAgIHRhcmdldC5vbkNoYW5nZSh0YXJnZXQuZW5hYmxlZCk7XG4gIH0pLFxuICBWYWxpZGF0ZShVTklPTihUT09MQkFSX1BPU0lUSU9OUyksIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFRvb2xiYXJHcm91cFByb3BlcnRpZXMucHJvdG90eXBlLCBcInBvc2l0aW9uXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIFRvb2xiYXJHcm91cFByb3BlcnRpZXMucHJvdG90eXBlLCBcImRyYWdnYWJsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIE9ic2VydmVDaGFuZ2VzKCh0YXJnZXQpID0+IHtcbiAgICB0YXJnZXQub25DaGFuZ2UodGFyZ2V0LmVuYWJsZWQpO1xuICB9KSxcbiAgVmFsaWRhdGUoVU5JT04oW1wic21hbGxcIiwgXCJub3JtYWxcIl0pLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBUb29sYmFyR3JvdXBQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzaXplXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgT2JzZXJ2ZUNoYW5nZXMoKHRhcmdldCkgPT4ge1xuICAgIGZvciAoY29uc3QgYnV0dG9uIG9mIHRhcmdldC5idXR0b25zID8/IFtdKSB7XG4gICAgICBpZiAoYnV0dG9uLmljb24gIT0gbnVsbCAmJiBJQ09OU19MRUdBQ1kuaW5jbHVkZXMoYnV0dG9uLmljb24pKSB7XG4gICAgICAgIExvZ2dlci53YXJuT25jZShgSWNvbiAnJHtidXR0b24uaWNvbn0nIGlzIGRlcHJlY2F0ZWQsIHVzZSBhbm90aGVyIGljb24gaW5zdGVhZC5gKTtcbiAgICAgIH1cbiAgICAgIGlmIChidXR0b24uYXJpYUxhYmVsID09PSBcInRvb2xiYXJBbm5vdGF0aW9uc0NvbG9yXCIpIHtcbiAgICAgICAgTG9nZ2VyLndhcm5PbmNlKFxuICAgICAgICAgIGBBcmlhIGxhYmVsICcke2J1dHRvbi5hcmlhTGFiZWx9JyBpcyBkZXByZWNhdGVkLCB1c2UgJ3Rvb2xiYXJBbm5vdGF0aW9uc0xpbmVDb2xvcicgaW5zdGVhZC5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHRhcmdldC5idXR0b25zQ2hhbmdlZChmYWxzZSk7XG4gIH0pLFxuICBWYWxpZGF0ZShBUlJBWSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgVG9vbGJhckdyb3VwUHJvcGVydGllcy5wcm90b3R5cGUsIFwiYnV0dG9uc1wiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvdG9vbGJhci90b29sYmFyU3R5bGVzLnRzXG52YXIgYmxvY2sgPSBcImFnLWNoYXJ0cy10b29sYmFyXCI7XG52YXIgZWxlbWVudHMgPSB7XG4gIGFsaWduOiBcImFnLWNoYXJ0cy10b29sYmFyX19hbGlnblwiLFxuICBzZWN0aW9uOiBcImFnLWNoYXJ0cy10b29sYmFyX19zZWN0aW9uXCIsXG4gIGJ1dHRvbjogXCJhZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uXCIsXG4gIGljb246IFwiYWctY2hhcnRzLXRvb2xiYXJfX2ljb25cIixcbiAgbGFiZWw6IFwiYWctY2hhcnRzLXRvb2xiYXJfX2xhYmVsXCJcbn07XG52YXIgbW9kaWZpZXJzID0ge1xuICBbXCJ0b3BcIiAvKiBUb3AgKi9dOiBcImFnLWNoYXJ0cy10b29sYmFyLS10b3BcIixcbiAgW1wicmlnaHRcIiAvKiBSaWdodCAqL106IFwiYWctY2hhcnRzLXRvb2xiYXItLXJpZ2h0XCIsXG4gIFtcImJvdHRvbVwiIC8qIEJvdHRvbSAqL106IFwiYWctY2hhcnRzLXRvb2xiYXItLWJvdHRvbVwiLFxuICBbXCJsZWZ0XCIgLyogTGVmdCAqL106IFwiYWctY2hhcnRzLXRvb2xiYXItLWxlZnRcIixcbiAgW1wiZmxvYXRpbmdcIiAvKiBGbG9hdGluZyAqL106IFwiYWctY2hhcnRzLXRvb2xiYXItLWZsb2F0aW5nXCIsXG4gIFtcImZsb2F0aW5nLXRvcFwiIC8qIEZsb2F0aW5nVG9wICovXTogXCJhZy1jaGFydHMtdG9vbGJhci0tZmxvYXRpbmctdG9wXCIsXG4gIFtcImZsb2F0aW5nLWJvdHRvbVwiIC8qIEZsb2F0aW5nQm90dG9tICovXTogXCJhZy1jaGFydHMtdG9vbGJhci0tZmxvYXRpbmctYm90dG9tXCIsXG4gIHNtYWxsOiBcImFnLWNoYXJ0cy10b29sYmFyLS1zbWFsbFwiLFxuICBub3JtYWw6IFwiYWctY2hhcnRzLXRvb2xiYXItLW5vcm1hbFwiLFxuICBoaWRkZW46IFwiYWctY2hhcnRzLXRvb2xiYXItLWhpZGRlblwiLFxuICBwcmV2ZW50Rmxhc2g6IFwiYWctY2hhcnRzLXRvb2xiYXItLXByZXZlbnQtZmxhc2hcIixcbiAgZmxvYXRpbmdIaWRkZW46IFwiYWctY2hhcnRzLXRvb2xiYXItLWZsb2F0aW5nLWhpZGRlblwiLFxuICBhbGlnbjoge1xuICAgIHN0YXJ0OiBcImFnLWNoYXJ0cy10b29sYmFyX19hbGlnbi0tc3RhcnRcIixcbiAgICBjZW50ZXI6IFwiYWctY2hhcnRzLXRvb2xiYXJfX2FsaWduLS1jZW50ZXJcIixcbiAgICBlbmQ6IFwiYWctY2hhcnRzLXRvb2xiYXJfX2FsaWduLS1lbmRcIlxuICB9LFxuICBidXR0b246IHtcbiAgICBmaXJzdDogXCJhZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uLS1maXJzdFwiLFxuICAgIGxhc3Q6IFwiYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvbi0tbGFzdFwiLFxuICAgIGFjdGl2ZTogXCJhZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uLS1hY3RpdmVcIixcbiAgICBoaWRkZW5WYWx1ZTogXCJhZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uLS1oaWRkZW4tdmFsdWVcIixcbiAgICBoaWRkZW5Ub2dnbGVkOiBcImFnLWNoYXJ0cy10b29sYmFyX19idXR0b24tLWhpZGRlbi10b2dnbGVkXCIsXG4gICAgZmlsbFZpc2libGU6IFwiYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvbi0tZmlsbC12aXNpYmxlXCIsXG4gICAgc3Ryb2tlV2lkdGhWaXNpYmxlOiBcImFnLWNoYXJ0cy10b29sYmFyX19idXR0b24tLXN0cm9rZS13aWR0aC12aXNpYmxlXCIsXG4gICAgd2l0aFRyYW5zaXRpb246IFwiYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvbi0td2l0aC10cmFuc2l0aW9uXCIsXG4gICAgZHJhZ0hhbmRsZTogXCJhZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uLS1kcmFnLWhhbmRsZVwiLFxuICAgIGRyYWdnaW5nOiBcImFnLWNoYXJ0cy10b29sYmFyX19idXR0b24tLWRyYWdnaW5nXCJcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvdG9vbGJhci90b29sYmFyLnRzXG52YXIgVG9vbGJhciA9IGNsYXNzIGV4dGVuZHMgQmFzZU1vZHVsZUluc3RhbmNlIHtcbiAgY29uc3RydWN0b3IoY3R4KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMuc2VyaWVzVHlwZSA9IG5ldyBUb29sYmFyR3JvdXBQcm9wZXJ0aWVzKFxuICAgICAgdGhpcy5vbkdyb3VwQ2hhbmdlZC5iaW5kKHRoaXMsIFwic2VyaWVzVHlwZVwiKSxcbiAgICAgIHRoaXMub25Hcm91cEJ1dHRvbnNDaGFuZ2VkLmJpbmQodGhpcywgXCJzZXJpZXNUeXBlXCIpXG4gICAgKTtcbiAgICB0aGlzLmFubm90YXRpb25zID0gbmV3IFRvb2xiYXJHcm91cFByb3BlcnRpZXMoXG4gICAgICB0aGlzLm9uR3JvdXBDaGFuZ2VkLmJpbmQodGhpcywgXCJhbm5vdGF0aW9uc1wiKSxcbiAgICAgIHRoaXMub25Hcm91cEJ1dHRvbnNDaGFuZ2VkLmJpbmQodGhpcywgXCJhbm5vdGF0aW9uc1wiKVxuICAgICk7XG4gICAgdGhpcy5hbm5vdGF0aW9uT3B0aW9ucyA9IG5ldyBUb29sYmFyR3JvdXBQcm9wZXJ0aWVzKFxuICAgICAgdGhpcy5vbkdyb3VwQ2hhbmdlZC5iaW5kKHRoaXMsIFwiYW5ub3RhdGlvbk9wdGlvbnNcIiksXG4gICAgICB0aGlzLm9uR3JvdXBCdXR0b25zQ2hhbmdlZC5iaW5kKHRoaXMsIFwiYW5ub3RhdGlvbk9wdGlvbnNcIilcbiAgICApO1xuICAgIHRoaXMucmFuZ2VzID0gbmV3IFRvb2xiYXJHcm91cFByb3BlcnRpZXMoXG4gICAgICB0aGlzLm9uR3JvdXBDaGFuZ2VkLmJpbmQodGhpcywgXCJyYW5nZXNcIiksXG4gICAgICB0aGlzLm9uR3JvdXBCdXR0b25zQ2hhbmdlZC5iaW5kKHRoaXMsIFwicmFuZ2VzXCIpXG4gICAgKTtcbiAgICB0aGlzLnpvb20gPSBuZXcgVG9vbGJhckdyb3VwUHJvcGVydGllcyhcbiAgICAgIHRoaXMub25Hcm91cENoYW5nZWQuYmluZCh0aGlzLCBcInpvb21cIiksXG4gICAgICB0aGlzLm9uR3JvdXBCdXR0b25zQ2hhbmdlZC5iaW5kKHRoaXMsIFwiem9vbVwiKVxuICAgICk7XG4gICAgdGhpcy5kcmFnU3RhdGUgPSB7XG4gICAgICBjbGllbnQ6IHsgeDogMCwgeTogMCB9LFxuICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfSxcbiAgICAgIGRldGFjaGVkOiBmYWxzZVxuICAgIH07XG4gICAgdGhpcy5ob3Jpem9udGFsU3BhY2luZyA9IDEwO1xuICAgIHRoaXMudmVydGljYWxTcGFjaW5nID0gMTA7XG4gICAgdGhpcy5mbG9hdGluZ0RldGVjdGlvblJhbmdlID0gMzg7XG4gICAgdGhpcy5wb3NpdGlvbnMgPSB7XG4gICAgICBbXCJ0b3BcIiAvKiBUb3AgKi9dOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxuICAgICAgW1wibGVmdFwiIC8qIExlZnQgKi9dOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxuICAgICAgW1wicmlnaHRcIiAvKiBSaWdodCAqL106IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksXG4gICAgICBbXCJib3R0b21cIiAvKiBCb3R0b20gKi9dOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxuICAgICAgW1wiZmxvYXRpbmdcIiAvKiBGbG9hdGluZyAqL106IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksXG4gICAgICBbXCJmbG9hdGluZy10b3BcIiAvKiBGbG9hdGluZ1RvcCAqL106IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksXG4gICAgICBbXCJmbG9hdGluZy1ib3R0b21cIiAvKiBGbG9hdGluZ0JvdHRvbSAqL106IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KClcbiAgICB9O1xuICAgIHRoaXMucG9zaXRpb25BbGlnbm1lbnRzID0ge1xuICAgICAgW1widG9wXCIgLyogVG9wICovXToge30sXG4gICAgICBbXCJsZWZ0XCIgLyogTGVmdCAqL106IHt9LFxuICAgICAgW1wicmlnaHRcIiAvKiBSaWdodCAqL106IHt9LFxuICAgICAgW1wiYm90dG9tXCIgLyogQm90dG9tICovXToge30sXG4gICAgICBbXCJmbG9hdGluZ1wiIC8qIEZsb2F0aW5nICovXToge30sXG4gICAgICBbXCJmbG9hdGluZy10b3BcIiAvKiBGbG9hdGluZ1RvcCAqL106IHt9LFxuICAgICAgW1wiZmxvYXRpbmctYm90dG9tXCIgLyogRmxvYXRpbmdCb3R0b20gKi9dOiB7fVxuICAgIH07XG4gICAgdGhpcy5ncm91cENhbGxlcnMgPSB7XG4gICAgICBzZXJpZXNUeXBlOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxuICAgICAgYW5ub3RhdGlvbnM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksXG4gICAgICBhbm5vdGF0aW9uT3B0aW9uczogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSxcbiAgICAgIHJhbmdlczogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSxcbiAgICAgIHpvb206IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KClcbiAgICB9O1xuICAgIHRoaXMuZ3JvdXBCdXR0b25zID0ge1xuICAgICAgc2VyaWVzVHlwZTogW10sXG4gICAgICBhbm5vdGF0aW9uczogW10sXG4gICAgICBhbm5vdGF0aW9uT3B0aW9uczogW10sXG4gICAgICByYW5nZXM6IFtdLFxuICAgICAgem9vbTogW11cbiAgICB9O1xuICAgIHRoaXMuYXJpYVRvb2xiYXJzID0gW1xuICAgICAgeyBncm91cHM6IFtcInNlcmllc1R5cGVcIiwgXCJhbm5vdGF0aW9uc1wiXSwgZGVzdHJveUZuczogW10sIHJlc2V0TGlzdGVuZXJzOiAoKSA9PiB7XG4gICAgICB9IH0sXG4gICAgICB7IGdyb3VwczogW1wiYW5ub3RhdGlvbk9wdGlvbnNcIl0sIGRlc3Ryb3lGbnM6IFtdLCByZXNldExpc3RlbmVyczogKCkgPT4ge1xuICAgICAgfSB9LFxuICAgICAgeyBncm91cHM6IFtcInJhbmdlc1wiXSwgZGVzdHJveUZuczogW10sIHJlc2V0TGlzdGVuZXJzOiAoKSA9PiB7XG4gICAgICB9IH0sXG4gICAgICB7IGdyb3VwczogW1wiem9vbVwiXSwgZGVzdHJveUZuczogW10sIHJlc2V0TGlzdGVuZXJzOiAoKSA9PiB7XG4gICAgICB9IH1cbiAgICBdO1xuICAgIHRoaXMucGVuZGluZ0J1dHRvblRvZ2dsZWRFdmVudHMgPSBbXTtcbiAgICB0aGlzLmdyb3VwUHJveGllZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5oYXNOZXdMb2NhbGUgPSB0cnVlO1xuICAgIHRoaXMuZWxlbWVudHMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHBvc2l0aW9uIG9mIFRPT0xCQVJfUE9TSVRJT05TKSB7XG4gICAgICB0aGlzLmVsZW1lbnRzW3Bvc2l0aW9uXSA9IGN0eC5kb21NYW5hZ2VyLmFkZENoaWxkKFwiY2FudmFzLW92ZXJsYXlcIiwgYHRvb2xiYXItJHtwb3NpdGlvbn1gKTtcbiAgICAgIHRoaXMuZWxlbWVudHNbcG9zaXRpb25dLnJvbGUgPSBcInByZXNlbnRhdGlvblwiO1xuICAgICAgdGhpcy5yZW5kZXJUb29sYmFyKHBvc2l0aW9uKTtcbiAgICB9XG4gICAgdGhpcy50b2dnbGVWaXNpYmlsaXRpZXMoKTtcbiAgICBjb25zdCBkcmFnU3RhdGVzID0gMzIgLyogRGVmYXVsdCAqLyB8IDggLyogQW5ub3RhdGlvbnMgKi87XG4gICAgY29uc3Qgc2VyaWVzUmVnaW9uID0gY3R4LnJlZ2lvbk1hbmFnZXIuZ2V0UmVnaW9uKFwic2VyaWVzXCIpO1xuICAgIHRoaXMuZGVzdHJveUZucy5wdXNoKFxuICAgICAgY3R4LmludGVyYWN0aW9uTWFuYWdlci5hZGRMaXN0ZW5lcihcImhvdmVyXCIsIHRoaXMub25Ib3Zlci5iaW5kKHRoaXMpLCA2MyAvKiBBbGwgKi8pLFxuICAgICAgY3R4LmludGVyYWN0aW9uTWFuYWdlci5hZGRMaXN0ZW5lcihcImxlYXZlXCIsIHRoaXMub25MZWF2ZS5iaW5kKHRoaXMpLCA2MyAvKiBBbGwgKi8pLFxuICAgICAgc2VyaWVzUmVnaW9uLmFkZExpc3RlbmVyKFwiZHJhZy1zdGFydFwiLCB0aGlzLnRvZ2dsZU5vUG9pbnRlckV2ZW50cy5iaW5kKHRoaXMsIHRydWUpLCBkcmFnU3RhdGVzKSxcbiAgICAgIHNlcmllc1JlZ2lvbi5hZGRMaXN0ZW5lcihcImRyYWctZW5kXCIsIHRoaXMudG9nZ2xlTm9Qb2ludGVyRXZlbnRzLmJpbmQodGhpcywgZmFsc2UpLCA2MyAvKiBBbGwgKi8pLFxuICAgICAgY3R4LnRvb2xiYXJNYW5hZ2VyLmFkZExpc3RlbmVyKFwiYnV0dG9uLXRvZ2dsZWRcIiwgdGhpcy5vbkJ1dHRvblRvZ2dsZWQuYmluZCh0aGlzKSksXG4gICAgICBjdHgudG9vbGJhck1hbmFnZXIuYWRkTGlzdGVuZXIoXCJidXR0b24tdXBkYXRlZFwiLCB0aGlzLm9uQnV0dG9uVXBkYXRlZC5iaW5kKHRoaXMpKSxcbiAgICAgIGN0eC50b29sYmFyTWFuYWdlci5hZGRMaXN0ZW5lcihcImdyb3VwLXRvZ2dsZWRcIiwgdGhpcy5vbkdyb3VwVG9nZ2xlZC5iaW5kKHRoaXMpKSxcbiAgICAgIGN0eC50b29sYmFyTWFuYWdlci5hZGRMaXN0ZW5lcihcImdyb3VwLXVwZGF0ZWRcIiwgdGhpcy5vbkdyb3VwVXBkYXRlZC5iaW5kKHRoaXMpKSxcbiAgICAgIGN0eC50b29sYmFyTWFuYWdlci5hZGRMaXN0ZW5lcihcImZsb2F0aW5nLWFuY2hvci1jaGFuZ2VkXCIsIHRoaXMub25GbG9hdGluZ0FuY2hvckNoYW5nZWQuYmluZCh0aGlzKSksXG4gICAgICBjdHgudG9vbGJhck1hbmFnZXIuYWRkTGlzdGVuZXIoXCJwcm94eS1ncm91cC1vcHRpb25zXCIsIHRoaXMub25Qcm94eUdyb3VwT3B0aW9ucy5iaW5kKHRoaXMpKSxcbiAgICAgIGN0eC5sYXlvdXRNYW5hZ2VyLnJlZ2lzdGVyRWxlbWVudCgyIC8qIFRvb2xiYXIgKi8sIHRoaXMub25MYXlvdXRTdGFydC5iaW5kKHRoaXMpKSxcbiAgICAgIGN0eC5sYXlvdXRNYW5hZ2VyLmFkZExpc3RlbmVyKFwibGF5b3V0OmNvbXBsZXRlXCIsIHRoaXMub25MYXlvdXRDb21wbGV0ZS5iaW5kKHRoaXMpKSxcbiAgICAgIGN0eC51cGRhdGVTZXJ2aWNlLmFkZExpc3RlbmVyKFwicHJlLWRvbS11cGRhdGVcIiwgdGhpcy5vblByZURvbVVwZGF0ZS5iaW5kKHRoaXMpKSxcbiAgICAgIGN0eC51cGRhdGVTZXJ2aWNlLmFkZExpc3RlbmVyKFwidXBkYXRlLWNvbXBsZXRlXCIsIHRoaXMub25VcGRhdGVDb21wbGV0ZS5iaW5kKHRoaXMpKSxcbiAgICAgIGN0eC5sb2NhbGVNYW5hZ2VyLmFkZExpc3RlbmVyKFwibG9jYWxlLWNoYW5nZWRcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLmhhc05ld0xvY2FsZSA9IHRydWU7XG4gICAgICB9KSxcbiAgICAgICgpID0+IHRoaXMuZGVzdHJveUVsZW1lbnRzKClcbiAgICApO1xuICB9XG4gIGRlc3Ryb3lFbGVtZW50cygpIHtcbiAgICB0aGlzLmN0eC5kb21NYW5hZ2VyLnJlbW92ZVN0eWxlcyhibG9jayk7XG4gICAgZm9yIChjb25zdCBlbGVtZW50MiBvZiBPYmplY3Qua2V5cyh0aGlzLmVsZW1lbnRzKSkge1xuICAgICAgdGhpcy5jdHguZG9tTWFuYWdlci5yZW1vdmVDaGlsZChcImNhbnZhcy1vdmVybGF5XCIsIGB0b29sYmFyLSR7ZWxlbWVudDJ9YCk7XG4gICAgfVxuICB9XG4gIG9uSG92ZXIoZXZlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBlbmFibGVkLFxuICAgICAgZWxlbWVudHM6IGVsZW1lbnRzMixcbiAgICAgIGZsb2F0aW5nRGV0ZWN0aW9uUmFuZ2UsXG4gICAgICBjdHg6IHsgc2NlbmUgfVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIG9mZnNldFksXG4gICAgICBzb3VyY2VFdmVudDogeyB0YXJnZXQgfVxuICAgIH0gPSBldmVudDtcbiAgICBjb25zdCB7IEZsb2F0aW5nQm90dG9tLCBGbG9hdGluZ1RvcCB9ID0gVG9vbGJhclBvc2l0aW9uO1xuICAgIGlmICghZW5hYmxlZClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBib3R0b20gPSBlbGVtZW50czJbRmxvYXRpbmdCb3R0b21dO1xuICAgIGNvbnN0IHRvcCA9IGVsZW1lbnRzMltGbG9hdGluZ1RvcF07XG4gICAgY29uc3QgYm90dG9tRGV0ZWN0aW9uWSA9IGJvdHRvbS5vZmZzZXRUb3AgLSBmbG9hdGluZ0RldGVjdGlvblJhbmdlO1xuICAgIGNvbnN0IGJvdHRvbVZpc2libGUgPSBvZmZzZXRZID4gYm90dG9tRGV0ZWN0aW9uWSAmJiBvZmZzZXRZIDwgc2NlbmUuY2FudmFzLmVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IHRhcmdldCA9PT0gYm90dG9tO1xuICAgIGNvbnN0IHRvcERldGVjdGlvblkgPSB0b3Aub2Zmc2V0VG9wICsgdG9wLm9mZnNldEhlaWdodCArIGZsb2F0aW5nRGV0ZWN0aW9uUmFuZ2U7XG4gICAgY29uc3QgdG9wVmlzaWJsZSA9IG9mZnNldFkgPiAwICYmIG9mZnNldFkgPCB0b3BEZXRlY3Rpb25ZIHx8IHRhcmdldCA9PT0gdG9wO1xuICAgIHRoaXMudHJhbnNsYXRlRmxvYXRpbmdFbGVtZW50cyhGbG9hdGluZ0JvdHRvbSwgYm90dG9tVmlzaWJsZSk7XG4gICAgdGhpcy50cmFuc2xhdGVGbG9hdGluZ0VsZW1lbnRzKEZsb2F0aW5nVG9wLCB0b3BWaXNpYmxlKTtcbiAgfVxuICBvbkxlYXZlKGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgZW5hYmxlZCxcbiAgICAgIGN0eDogeyBzY2VuZSB9XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgeyByZWxhdGVkRWxlbWVudCwgdGFyZ2V0RWxlbWVudCB9ID0gZXZlbnQ7XG4gICAgY29uc3QgeyBGbG9hdGluZ0JvdHRvbSwgRmxvYXRpbmdUb3AgfSA9IFRvb2xiYXJQb3NpdGlvbjtcbiAgICBpZiAoIWVuYWJsZWQgfHwgdGFyZ2V0RWxlbWVudCAhPT0gc2NlbmUuY2FudmFzLmVsZW1lbnQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgaXNUYXJnZXRCdXR0b24gPSBUT09MQkFSX0dST1VQUy5zb21lKFxuICAgICAgKGdyb3VwKSA9PiB0aGlzLmdyb3VwQnV0dG9uc1tncm91cF0uc29tZSgoYnV0dG9uKSA9PiBidXR0b24gPT09IHJlbGF0ZWRFbGVtZW50KVxuICAgICk7XG4gICAgaWYgKGlzVGFyZ2V0QnV0dG9uKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMudHJhbnNsYXRlRmxvYXRpbmdFbGVtZW50cyhGbG9hdGluZ0JvdHRvbSwgZmFsc2UpO1xuICAgIHRoaXMudHJhbnNsYXRlRmxvYXRpbmdFbGVtZW50cyhGbG9hdGluZ1RvcCwgZmFsc2UpO1xuICB9XG4gIC8vIEFHLTEyNjk1IFRlbXBvcmFyaWx5IHNldCBgcG9pbnRlci1ldmVudHM6IG5vbmVgIG9uIHRoZSBhbm5vdGF0aW9uT3B0aW9ucyB3aGVuIGRyYWdnaW5nLCBiZWNhdXNlIHRoZVxuICAvLyBidXR0b25zIGJsb2NrIHRvIG1vdXNlIGZyb20gaG92ZXJpbmcgb3ZlciB0aGUgY2FudmFzLlxuICB0b2dnbGVOb1BvaW50ZXJFdmVudHMob24pIHtcbiAgICBjb25zdCBjbGFzc05hbWUgPSBcImFnLWNoYXJ0cy10b29sYmFyX19uby1wb2ludGVyLWV2ZW50c1wiO1xuICAgIHRoaXMuZ3JvdXBCdXR0b25zW1wiYW5ub3RhdGlvbk9wdGlvbnNcIl0uZm9yRWFjaCgoYikgPT4gYi5jbGFzc0xpc3QudG9nZ2xlKGNsYXNzTmFtZSwgb24pKTtcbiAgfVxuICBvbkdyb3VwQ2hhbmdlZChncm91cCkge1xuICAgIGlmICh0aGlzW2dyb3VwXSA9PSBudWxsIHx8IHRoaXMuZ3JvdXBQcm94aWVkLmhhcyhncm91cCkpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5jcmVhdGVHcm91cChncm91cCk7XG4gICAgdGhpcy50b2dnbGVWaXNpYmlsaXRpZXMoKTtcbiAgfVxuICBvbkdyb3VwQnV0dG9uc0NoYW5nZWQoZ3JvdXAsIGJ1dHRvbnMsIGNvbmZpZ3VyYXRpb25Pbmx5KSB7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQgfHwgdGhpcy5ncm91cFByb3hpZWQuaGFzKGdyb3VwKSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAoY29uZmlndXJhdGlvbk9ubHkpIHtcbiAgICAgIGZvciAoY29uc3QgYnV0dG9uT3B0aW9ucyBvZiB0aGlzW2dyb3VwXS5idXR0b25Db25maWd1cmF0aW9ucygpKSB7XG4gICAgICAgIHRoaXMucmVmcmVzaEJ1dHRvbkNvbnRlbnQoZ3JvdXAsIGJ1dHRvbk9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNyZWF0ZUdyb3VwQnV0dG9ucyhncm91cCwgYnV0dG9ucyk7XG4gICAgfVxuICAgIHRoaXMudG9nZ2xlVmlzaWJpbGl0aWVzKCk7XG4gIH1cbiAgb25MYXlvdXRDb21wbGV0ZShvcHRzKSB7XG4gICAgZm9yIChjb25zdCBwb3NpdGlvbiBvZiBUT09MQkFSX1BPU0lUSU9OUykge1xuICAgICAgdGhpcy5lbGVtZW50c1twb3NpdGlvbl0uY2xhc3NMaXN0LnJlbW92ZShtb2RpZmllcnMucHJldmVudEZsYXNoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZW5hYmxlZCkge1xuICAgICAgdGhpcy5yZWZyZXNoSW5uZXJMYXlvdXQob3B0cy5zZXJpZXMucmVjdCk7XG4gICAgfVxuICB9XG4gIHRvZ2dsZUJ1dHRvbnNUcmFuc2l0aW9uKGVuYWJsZWQpIHtcbiAgICBjb25zdCBjbGFzc05hbWUgPSBtb2RpZmllcnMuYnV0dG9uLndpdGhUcmFuc2l0aW9uO1xuICAgIGZvciAoY29uc3QgYnV0dG9uIG9mIE9iamVjdC52YWx1ZXModGhpcy5ncm91cEJ1dHRvbnMpLmZsYXQoKSkge1xuICAgICAgaWYgKGVuYWJsZWQgJiYgIWJ1dHRvbi5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKSkge1xuICAgICAgICBidXR0b24uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB9XG4gICAgICBidXR0b24uY2xhc3NMaXN0LnRvZ2dsZShjbGFzc05hbWUsIGVuYWJsZWQpO1xuICAgIH1cbiAgfVxuICBvblByZURvbVVwZGF0ZSgpIHtcbiAgICB0aGlzLnRvZ2dsZUJ1dHRvbnNUcmFuc2l0aW9uKGZhbHNlKTtcbiAgfVxuICBvblVwZGF0ZUNvbXBsZXRlKCkge1xuICAgIHRoaXMudG9nZ2xlQnV0dG9uc1RyYW5zaXRpb24odHJ1ZSk7XG4gIH1cbiAgb25CdXR0b25VcGRhdGVkKGV2ZW50KSB7XG4gICAgY29uc3QgeyB0eXBlOiBfdHlwZSwgZ3JvdXAsIGlkLCAuLi5wYXJhbXMgfSA9IGV2ZW50O1xuICAgIHRoaXNbZ3JvdXBdLm92ZXJyaWRlQnV0dG9uQ29uZmlndXJhdGlvbihpZCwgcGFyYW1zKTtcbiAgfVxuICBzZXRCdXR0b25BY3RpdmUoYnV0dG9uLCBhY3RpdmUpIHtcbiAgICBidXR0b24uY2xhc3NMaXN0LnRvZ2dsZShtb2RpZmllcnMuYnV0dG9uLmFjdGl2ZSwgYWN0aXZlKTtcbiAgfVxuICBzZXRCdXR0b25DaGVja2VkKGJ1dHRvbiwgY2hlY2tlZCkge1xuICAgIGlmIChidXR0b24ucm9sZSA9PT0gXCJzd2l0Y2hcIikge1xuICAgICAgYnV0dG9uLmFyaWFDaGVja2VkID0gY2hlY2tlZC50b1N0cmluZygpO1xuICAgIH1cbiAgfVxuICBzZXRCdXR0b25Hcm91cEZpcnN0TGFzdChncm91cCkge1xuICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBBcnJheS5mcm9tKGdyb3VwLmNoaWxkTm9kZXMgPz8gW10pO1xuICAgIGNvbnN0IHNldEZpcnN0Q2xhc3MgPSAoZmlyc3QyLCBidXR0b24sIG1vZGlmaWVyKSA9PiB7XG4gICAgICBjb25zdCBidXR0b25WaXNpYmxlID0gIWJ1dHRvbi5jbGFzc0xpc3QuY29udGFpbnMobW9kaWZpZXJzLmJ1dHRvbi5oaWRkZW5Ub2dnbGVkKTtcbiAgICAgIGJ1dHRvbi5jbGFzc0xpc3QudG9nZ2xlKG1vZGlmaWVyLCBidXR0b25WaXNpYmxlICYmIGZpcnN0Mik7XG4gICAgICByZXR1cm4gYnV0dG9uVmlzaWJsZSA/IGZhbHNlIDogZmlyc3QyO1xuICAgIH07XG4gICAgbGV0IGZpcnN0ID0gdHJ1ZTtcbiAgICBjaGlsZE5vZGVzLmZvckVhY2goKGJ1dHRvbikgPT4gZmlyc3QgPSBzZXRGaXJzdENsYXNzKGZpcnN0LCBidXR0b24sIG1vZGlmaWVycy5idXR0b24uZmlyc3QpKTtcbiAgICBsZXQgbGFzdCA9IHRydWU7XG4gICAgY2hpbGROb2Rlcy50b1JldmVyc2VkKCkuZm9yRWFjaCgoYnV0dG9uKSA9PiBsYXN0ID0gc2V0Rmlyc3RDbGFzcyhsYXN0LCBidXR0b24sIG1vZGlmaWVycy5idXR0b24ubGFzdCkpO1xuICB9XG4gIG9uQnV0dG9uVG9nZ2xlZChldmVudCkge1xuICAgIGNvbnN0IHsgZ3JvdXAsIGlkLCBhY3RpdmUsIGVuYWJsZWQsIHZpc2libGUsIGNoZWNrZWQgfSA9IGV2ZW50O1xuICAgIGlmICh0aGlzLmdyb3VwQnV0dG9uc1tncm91cF0ubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLnBlbmRpbmdCdXR0b25Ub2dnbGVkRXZlbnRzLnB1c2goZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBidXR0b24gPSB0aGlzLmdyb3VwQnV0dG9uc1tncm91cF0uZmluZCgoYikgPT4gYi5kYXRhc2V0LnRvb2xiYXJJZCA9PT0gYCR7aWR9YCk7XG4gICAgaWYgKGJ1dHRvbiA9PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGJ1dHRvbi5hcmlhRGlzYWJsZWQgPSBgJHshZW5hYmxlZH1gO1xuICAgIGJ1dHRvbi5jbGFzc0xpc3QudG9nZ2xlKG1vZGlmaWVycy5idXR0b24uaGlkZGVuVG9nZ2xlZCwgIXZpc2libGUpO1xuICAgIHRoaXMuc2V0QnV0dG9uQWN0aXZlKGJ1dHRvbiwgYWN0aXZlKTtcbiAgICB0aGlzLnNldEJ1dHRvbkNoZWNrZWQoYnV0dG9uLCBjaGVja2VkKTtcbiAgICB0aGlzLnNldEJ1dHRvbkdyb3VwRmlyc3RMYXN0KGJ1dHRvbi5wYXJlbnROb2RlKTtcbiAgfVxuICBvbkdyb3VwVG9nZ2xlZChldmVudCkge1xuICAgIGNvbnN0IHsgY2FsbGVyLCBncm91cCwgYWN0aXZlLCB2aXNpYmxlIH0gPSBldmVudDtcbiAgICB0aGlzLnRvZ2dsZUdyb3VwKGNhbGxlciwgZ3JvdXAsIGFjdGl2ZSwgdmlzaWJsZSk7XG4gICAgdGhpcy50b2dnbGVWaXNpYmlsaXRpZXMoKTtcbiAgfVxuICBvbkdyb3VwVXBkYXRlZChldmVudCkge1xuICAgIGNvbnN0IHsgZ3JvdXAgfSA9IGV2ZW50O1xuICAgIGZvciAoY29uc3QgYXJpYVRvb2xiYXIgb2YgdGhpcy5hcmlhVG9vbGJhcnMpIHtcbiAgICAgIGlmIChhcmlhVG9vbGJhci5ncm91cHMuaW5jbHVkZXMoZ3JvdXApKSB7XG4gICAgICAgIGFyaWFUb29sYmFyLnJlc2V0TGlzdGVuZXJzKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgb25GbG9hdGluZ0FuY2hvckNoYW5nZWQoZXZlbnQpIHtcbiAgICBjb25zdCB7IGVsZW1lbnRzOiBlbGVtZW50czIsIHBvc2l0aW9ucywgaG9yaXpvbnRhbFNwYWNpbmcsIHZlcnRpY2FsU3BhY2luZyB9ID0gdGhpcztcbiAgICBjb25zdCB7IGdyb3VwLCBhbmNob3IgfSA9IGV2ZW50O1xuICAgIGNvbnN0IGVsZW1lbnQyID0gZWxlbWVudHMyW1wiZmxvYXRpbmdcIiAvKiBGbG9hdGluZyAqL107XG4gICAgaWYgKHRoaXMuZHJhZ1N0YXRlLmRldGFjaGVkIHx8IGVsZW1lbnQyLmNsYXNzTGlzdC5jb250YWlucyhtb2RpZmllcnMuaGlkZGVuKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmRyYWdTdGF0ZS5kZXRhY2hlZCA9IGZhbHNlO1xuICAgIGlmICghcG9zaXRpb25zW1wiZmxvYXRpbmdcIiAvKiBGbG9hdGluZyAqL10uaGFzKGdyb3VwKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBwb3NpdGlvbiA9IGFuY2hvci5wb3NpdGlvbiA/PyBcImFib3ZlXCI7XG4gICAgY29uc3QgeyBvZmZzZXRXaWR0aDogd2lkdGgyLCBvZmZzZXRIZWlnaHQ6IGhlaWdodDIgfSA9IGVsZW1lbnQyO1xuICAgIGxldCB0b3AgPSBhbmNob3IueSAtIGhlaWdodDIgLSB2ZXJ0aWNhbFNwYWNpbmc7XG4gICAgbGV0IGxlZnQgPSBhbmNob3IueCAtIHdpZHRoMiAvIDI7XG4gICAgaWYgKHBvc2l0aW9uID09PSBcImJlbG93XCIpIHtcbiAgICAgIHRvcCA9IGFuY2hvci55ICsgdmVydGljYWxTcGFjaW5nO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09IFwicmlnaHRcIikge1xuICAgICAgdG9wID0gYW5jaG9yLnkgLSBoZWlnaHQyIC8gMjtcbiAgICAgIGxlZnQgPSBhbmNob3IueCArIGhvcml6b250YWxTcGFjaW5nO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09IFwiYWJvdmUtbGVmdFwiKSB7XG4gICAgICBsZWZ0ID0gYW5jaG9yLng7XG4gICAgfVxuICAgIGNvbnN0IGdyb3VwQkJveCA9IG5ldyBCQm94KGxlZnQsIHRvcCwgd2lkdGgyLCBoZWlnaHQyKTtcbiAgICB0aGlzLnBvc2l0aW9uR3JvdXAoZWxlbWVudDIsIGdyb3VwLCBncm91cEJCb3gpO1xuICB9XG4gIHBvc2l0aW9uR3JvdXAoZWxlbWVudDIsIGdyb3VwLCBiYm94KSB7XG4gICAgY29uc3Qge1xuICAgICAgY3R4OiB7IGRvbU1hbmFnZXIgfVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGNhbnZhc1JlY3QgPSBkb21NYW5hZ2VyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGJib3gueCA9IGNsYW1wKDAsIGJib3gueCwgY2FudmFzUmVjdC53aWR0aCAtIGJib3gud2lkdGgpO1xuICAgIGJib3gueSA9IGNsYW1wKDAsIGJib3gueSwgY2FudmFzUmVjdC5oZWlnaHQgLSBiYm94LmhlaWdodCk7XG4gICAgY29uc3QgbGVmdCA9IGAke01hdGguZmxvb3IoYmJveC54KX1weGA7XG4gICAgY29uc3QgdG9wID0gYCR7TWF0aC5mbG9vcihiYm94LnkpfXB4YDtcbiAgICBjb25zdCBkaXJ0eSA9IGVsZW1lbnQyLnN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCJsZWZ0XCIpICE9PSBsZWZ0IHx8IGVsZW1lbnQyLnN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCJ0b3BcIikgIT09IHRvcDtcbiAgICBpZiAoIWRpcnR5KVxuICAgICAgcmV0dXJuO1xuICAgIGVsZW1lbnQyLnN0eWxlLnNldFByb3BlcnR5KFwibGVmdFwiLCBsZWZ0KTtcbiAgICBlbGVtZW50Mi5zdHlsZS5zZXRQcm9wZXJ0eShcInRvcFwiLCB0b3ApO1xuICAgIHRoaXMub25Hcm91cE1vdmVkKGdyb3VwLCBiYm94KTtcbiAgfVxuICBvbkdyb3VwTW92ZWQoZ3JvdXAsIGJib3gpIHtcbiAgICBjb25zdCB7XG4gICAgICBncm91cEJ1dHRvbnMsXG4gICAgICBjdHg6IHsgdG9vbGJhck1hbmFnZXIgfVxuICAgIH0gPSB0aGlzO1xuICAgIGZvciAoY29uc3QgYnV0dG9uIG9mIGdyb3VwQnV0dG9uc1tncm91cF0pIHtcbiAgICAgIGlmIChidXR0b24uY2xhc3NMaXN0LmNvbnRhaW5zKG1vZGlmaWVycy5idXR0b24uaGlkZGVuVG9nZ2xlZCkpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3QgcGFyZW50ID0gYnV0dG9uLm9mZnNldFBhcmVudDtcbiAgICAgIHRvb2xiYXJNYW5hZ2VyLmJ1dHRvbk1vdmVkKFxuICAgICAgICBncm91cCxcbiAgICAgICAgYnV0dG9uLmRhdGFzZXQudG9vbGJhcklkLFxuICAgICAgICBuZXcgQkJveChcbiAgICAgICAgICBidXR0b24ub2Zmc2V0TGVmdCArIChwYXJlbnQ/Lm9mZnNldExlZnQgPz8gMCksXG4gICAgICAgICAgYnV0dG9uLm9mZnNldFRvcCArIChwYXJlbnQ/Lm9mZnNldFRvcCA/PyAwKSxcbiAgICAgICAgICBidXR0b24ub2Zmc2V0V2lkdGgsXG4gICAgICAgICAgYnV0dG9uLm9mZnNldEhlaWdodFxuICAgICAgICApLFxuICAgICAgICBiYm94XG4gICAgICApO1xuICAgIH1cbiAgfVxuICBidXR0b25SZWN0KGJ1dHRvbiwgY2FudmFzUmVjdCA9IHRoaXMuY3R4LmRvbU1hbmFnZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpIHtcbiAgICBjb25zdCBidXR0b25SZWN0ID0gYnV0dG9uLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiBuZXcgQkJveChcbiAgICAgIGJ1dHRvblJlY3QubGVmdCAtIGNhbnZhc1JlY3QubGVmdCxcbiAgICAgIGJ1dHRvblJlY3QudG9wIC0gY2FudmFzUmVjdC50b3AsXG4gICAgICBidXR0b25SZWN0LndpZHRoLFxuICAgICAgYnV0dG9uUmVjdC5oZWlnaHRcbiAgICApO1xuICB9XG4gIG9uUHJveHlHcm91cE9wdGlvbnMoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlZClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IGNhbGxlciwgZ3JvdXAsIG9wdGlvbnMgfSA9IGV2ZW50O1xuICAgIHRoaXMuZ3JvdXBQcm94aWVkLnNldChncm91cCwgb3B0aW9ucyk7XG4gICAgdGhpc1tncm91cF0uc2V0KG9wdGlvbnMpO1xuICAgIHRoaXMudG9nZ2xlR3JvdXAoY2FsbGVyLCBncm91cCwgdm9pZCAwLCBvcHRpb25zLmVuYWJsZWQpO1xuICAgIHRoaXMuY3JlYXRlR3JvdXAoZ3JvdXAsIG9wdGlvbnMuZW5hYmxlZCwgb3B0aW9ucy5wb3NpdGlvbik7XG4gICAgaWYgKG9wdGlvbnMuZW5hYmxlZCkge1xuICAgICAgdGhpcy5jcmVhdGVHcm91cEJ1dHRvbnMoZ3JvdXAsIG9wdGlvbnMuYnV0dG9ucyk7XG4gICAgfVxuICB9XG4gIGNyZWF0ZUdyb3VwKGdyb3VwLCBlbmFibGVkLCBwb3NpdGlvbikge1xuICAgIGVuYWJsZWQgPz8gKGVuYWJsZWQgPSB0aGlzW2dyb3VwXS5lbmFibGVkKTtcbiAgICBwb3NpdGlvbiA/PyAocG9zaXRpb24gPSB0aGlzW2dyb3VwXS5wb3NpdGlvbik7XG4gICAgZm9yIChjb25zdCBwb3Mgb2YgVE9PTEJBUl9QT1NJVElPTlMpIHtcbiAgICAgIGlmIChlbmFibGVkICYmIHBvc2l0aW9uID09PSBwb3MpIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbnNbcG9zXS5hZGQoZ3JvdXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbnNbcG9zXS5kZWxldGUoZ3JvdXApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjcmVhdGVHcm91cEJ1dHRvbnMoZ3JvdXAsIGJ1dHRvbnMgPSBbXSkge1xuICAgIGZvciAoY29uc3QgYnV0dG9uIG9mIHRoaXMuZ3JvdXBCdXR0b25zW2dyb3VwXSkge1xuICAgICAgYnV0dG9uLnJlbW92ZSgpO1xuICAgIH1cbiAgICB0aGlzLmdyb3VwQnV0dG9uc1tncm91cF0gPSBbXTtcbiAgICBpZiAoYnV0dG9ucy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBhbGlnbiwgcG9zaXRpb24gfSA9IHRoaXNbZ3JvdXBdO1xuICAgIGNvbnN0IGFsaWduRWxlbWVudCA9IHRoaXMucG9zaXRpb25BbGlnbm1lbnRzW3Bvc2l0aW9uXVthbGlnbl07XG4gICAgaWYgKCFhbGlnbkVsZW1lbnQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbmV4dFNlY3Rpb24gPSAoc2VjdGlvbjIpID0+IHtcbiAgICAgIGNvbnN0IGFsaWduRWxlbWVudENoaWxkcmVuID0gQXJyYXkuZnJvbShhbGlnbkVsZW1lbnQuY2hpbGRyZW4pO1xuICAgICAgY29uc3QgZGF0YUdyb3VwID0gXCJkYXRhLWdyb3VwXCI7XG4gICAgICBjb25zdCBkYXRhU2VjdGlvbiA9IFwiZGF0YS1zZWN0aW9uXCI7XG4gICAgICBsZXQgc2VjdGlvbkVsZW1lbnQgPSBhbGlnbkVsZW1lbnRDaGlsZHJlbi5maW5kKChwcmV2U2VjdGlvbjIpID0+IHtcbiAgICAgICAgcmV0dXJuIHByZXZTZWN0aW9uMi5nZXRBdHRyaWJ1dGUoZGF0YUdyb3VwKSA9PT0gZ3JvdXAgJiYgcHJldlNlY3Rpb24yLmdldEF0dHJpYnV0ZShkYXRhU2VjdGlvbikgPT09IChzZWN0aW9uMiA/PyBcIlwiKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKCFzZWN0aW9uRWxlbWVudCkge1xuICAgICAgICBzZWN0aW9uRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHNlY3Rpb25FbGVtZW50LnJvbGUgPSBcInByZXNlbnRhdGlvblwiO1xuICAgICAgICBzZWN0aW9uRWxlbWVudC5zZXRBdHRyaWJ1dGUoZGF0YUdyb3VwLCBncm91cCk7XG4gICAgICAgIHNlY3Rpb25FbGVtZW50LnNldEF0dHJpYnV0ZShkYXRhU2VjdGlvbiwgc2VjdGlvbjIgPz8gXCJcIik7XG4gICAgICAgIGNvbnN0IGdyb3VwSW5kZXggPSBUT09MQkFSX0dST1VQX09SREVSSU5HW2dyb3VwXTtcbiAgICAgICAgY29uc3QgaW5zZXJ0QmVmb3JlRWxlbWVudCA9IGFsaWduRWxlbWVudENoaWxkcmVuLmZpbmQoKHByZXZTZWN0aW9uMikgPT4ge1xuICAgICAgICAgIGNvbnN0IHByZXZHcm91cCA9IHByZXZTZWN0aW9uMi5nZXRBdHRyaWJ1dGUoZGF0YUdyb3VwKTtcbiAgICAgICAgICBjb25zdCBwcmV2R3JvdXBJbmRleCA9IFRPT0xCQVJfR1JPVVBfT1JERVJJTkdbcHJldkdyb3VwXTtcbiAgICAgICAgICByZXR1cm4gcHJldkdyb3VwSW5kZXggPiBncm91cEluZGV4O1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGluc2VydEJlZm9yZUVsZW1lbnQgIT0gbnVsbCkge1xuICAgICAgICAgIGFsaWduRWxlbWVudC5pbnNlcnRCZWZvcmUoc2VjdGlvbkVsZW1lbnQsIGluc2VydEJlZm9yZUVsZW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFsaWduRWxlbWVudC5hcHBlbmRDaGlsZChzZWN0aW9uRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXN0cm95Rm5zLnB1c2goKCkgPT4gc2VjdGlvbkVsZW1lbnQucmVtb3ZlKCkpO1xuICAgICAgfVxuICAgICAgc2VjdGlvbkVsZW1lbnQuY2xhc3NMaXN0LmFkZChlbGVtZW50cy5zZWN0aW9uLCBtb2RpZmllcnNbdGhpc1tncm91cF0uc2l6ZV0pO1xuICAgICAgcmV0dXJuIHNlY3Rpb25FbGVtZW50O1xuICAgIH07XG4gICAgbGV0IHByZXZTZWN0aW9uID0gYnV0dG9ucy5hdCgwKT8uc2VjdGlvbjtcbiAgICBsZXQgc2VjdGlvbiA9IG5leHRTZWN0aW9uKHByZXZTZWN0aW9uKTtcbiAgICBmb3IgKGNvbnN0IG9wdGlvbnMgb2YgYnV0dG9ucykge1xuICAgICAgaWYgKHByZXZTZWN0aW9uICE9PSBvcHRpb25zLnNlY3Rpb24pIHtcbiAgICAgICAgdGhpcy5zZXRCdXR0b25Hcm91cEZpcnN0TGFzdChzZWN0aW9uKTtcbiAgICAgICAgc2VjdGlvbiA9IG5leHRTZWN0aW9uKG9wdGlvbnMuc2VjdGlvbik7XG4gICAgICB9XG4gICAgICBwcmV2U2VjdGlvbiA9IG9wdGlvbnMuc2VjdGlvbjtcbiAgICAgIGNvbnN0IGJ1dHRvbiA9IHRoaXMuY3JlYXRlQnV0dG9uRWxlbWVudChncm91cCwgb3B0aW9ucyk7XG4gICAgICBzZWN0aW9uLmFwcGVuZENoaWxkKGJ1dHRvbik7XG4gICAgICB0aGlzLmdyb3VwQnV0dG9uc1tncm91cF0ucHVzaChidXR0b24pO1xuICAgIH1cbiAgICB0aGlzLnNldEJ1dHRvbkdyb3VwRmlyc3RMYXN0KHNlY3Rpb24pO1xuICAgIGNvbnN0IG9uRXNjYXBlID0gKCkgPT4ge1xuICAgICAgdGhpcy5jdHgudG9vbGJhck1hbmFnZXIuY2FuY2VsKGdyb3VwKTtcbiAgICB9O1xuICAgIGxldCBvbkZvY3VzO1xuICAgIGxldCBvbkJsdXI7XG4gICAgaWYgKGlzQW5pbWF0aW5nRmxvYXRpbmdQb3NpdGlvbihwb3NpdGlvbikpIHtcbiAgICAgIG9uRm9jdXMgPSAoKSA9PiB0aGlzLnRyYW5zbGF0ZUZsb2F0aW5nRWxlbWVudHMocG9zaXRpb24sIHRydWUpO1xuICAgICAgb25CbHVyID0gKCkgPT4gdGhpcy50cmFuc2xhdGVGbG9hdGluZ0VsZW1lbnRzKHBvc2l0aW9uLCBmYWxzZSk7XG4gICAgfVxuICAgIHRoaXMuY3JlYXRlQXJpYVRvb2xiYXIoZ3JvdXAsIGFsaWduRWxlbWVudCwgb25Gb2N1cywgb25CbHVyLCBvbkVzY2FwZSk7XG4gIH1cbiAgY3JlYXRlQXJpYVRvb2xiYXIoZ3JvdXAsIHRvb2xiYXIsIG9uRm9jdXMsIG9uQmx1ciwgb25Fc2NhcGUpIHtcbiAgICBjb25zdCBvcmllbnRhdGlvbiA9IHRoaXMuY29tcHV0ZUFyaWFPcmllbnRhdGlvbih0aGlzW2dyb3VwXS5wb3NpdGlvbik7XG4gICAgY29uc3QgYXJpYVRvb2xiYXIgPSB0aGlzLmdldEFyaWFUb29sYmFyKGdyb3VwKTtcbiAgICBhcmlhVG9vbGJhci5yZXNldExpc3RlbmVycyA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGJ1dHRvbnMgPSBhcmlhVG9vbGJhci5ncm91cHMubWFwKChnKSA9PiB0aGlzLmdyb3VwQnV0dG9uc1tnXSkuZmxhdCgpLmZpbHRlcihcbiAgICAgICAgKGIpID0+ICFiLmNsYXNzTGlzdC5jb250YWlucyhtb2RpZmllcnMuYnV0dG9uLmhpZGRlblRvZ2dsZWQpICYmICFiLmNsYXNzTGlzdC5jb250YWlucyhtb2RpZmllcnMuYnV0dG9uLmRyYWdIYW5kbGUpXG4gICAgICApO1xuICAgICAgYXJpYVRvb2xiYXIuZGVzdHJveUZucy5mb3JFYWNoKChkKSA9PiBkKCkpO1xuICAgICAgYXJpYVRvb2xiYXIuZGVzdHJveUZucyA9IGluaXRUb29sYmFyS2V5TmF2KHsgb3JpZW50YXRpb24sIHRvb2xiYXIsIGJ1dHRvbnMsIG9uRXNjYXBlLCBvbkZvY3VzLCBvbkJsdXIgfSk7XG4gICAgfTtcbiAgICBhcmlhVG9vbGJhci5yZXNldExpc3RlbmVycygpO1xuICAgIHRoaXMudXBkYXRlVG9vbGJhckFyaWFMYWJlbChncm91cCwgdG9vbGJhcik7XG4gIH1cbiAgY29tcHV0ZUFyaWFPcmllbnRhdGlvbihwb3NpdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICB0b3A6IFwiaG9yaXpvbnRhbFwiLFxuICAgICAgcmlnaHQ6IFwidmVydGljYWxcIixcbiAgICAgIGJvdHRvbTogXCJob3Jpem9udGFsXCIsXG4gICAgICBsZWZ0OiBcInZlcnRpY2FsXCIsXG4gICAgICBmbG9hdGluZzogXCJob3Jpem9udGFsXCIsXG4gICAgICBcImZsb2F0aW5nLXRvcFwiOiBcImhvcml6b250YWxcIixcbiAgICAgIFwiZmxvYXRpbmctYm90dG9tXCI6IFwiaG9yaXpvbnRhbFwiXG4gICAgfVtwb3NpdGlvbl07XG4gIH1cbiAgdG9nZ2xlR3JvdXAoY2FsbGVyLCBncm91cCwgYWN0aXZlLCBlbmFibGVkKSB7XG4gICAgaWYgKGVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgIHRoaXMuZ3JvdXBDYWxsZXJzW2dyb3VwXS5hZGQoY2FsbGVyKTtcbiAgICB9IGVsc2UgaWYgKGVuYWJsZWQgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmdyb3VwQ2FsbGVyc1tncm91cF0uZGVsZXRlKGNhbGxlcik7XG4gICAgfVxuICAgIGlmIChhY3RpdmUgIT0gbnVsbCkge1xuICAgICAgZm9yIChjb25zdCBidXR0b24gb2YgdGhpcy5ncm91cEJ1dHRvbnNbZ3JvdXBdKSB7XG4gICAgICAgIHRoaXMuc2V0QnV0dG9uQWN0aXZlKGJ1dHRvbiwgYWN0aXZlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcHJvY2Vzc1BlbmRpbmdFdmVudHMoKSB7XG4gICAgY29uc3QgcGVuZGluZ0J1dHRvblRvZ2dsZWRFdmVudHMgPSAodGhpcy5wZW5kaW5nQnV0dG9uVG9nZ2xlZEV2ZW50cyA/PyBbXSkuc2xpY2UoKTtcbiAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIHBlbmRpbmdCdXR0b25Ub2dnbGVkRXZlbnRzKSB7XG4gICAgICB0aGlzLm9uQnV0dG9uVG9nZ2xlZChldmVudCk7XG4gICAgfVxuICAgIHRoaXMucGVuZGluZ0J1dHRvblRvZ2dsZWRFdmVudHMgPSBbXTtcbiAgfVxuICBvbkxheW91dFN0YXJ0KGN0eCkge1xuICAgIGlmICh0aGlzLmVuYWJsZWQpIHtcbiAgICAgIHRoaXMucmVmcmVzaE91dGVyTGF5b3V0KGN0eC5sYXlvdXRCb3gpO1xuICAgICAgdGhpcy5yZWZyZXNoTG9jYWxlKCk7XG4gICAgfVxuICB9XG4gIHJlZnJlc2hPdXRlckxheW91dChzaHJpbmtSZWN0KSB7XG4gICAgY29uc3QgeyBlbGVtZW50czogZWxlbWVudHMyLCBob3Jpem9udGFsU3BhY2luZywgdmVydGljYWxTcGFjaW5nIH0gPSB0aGlzO1xuICAgIGlmICghZWxlbWVudHMyLnRvcC5jbGFzc0xpc3QuY29udGFpbnMobW9kaWZpZXJzLmhpZGRlbikpIHtcbiAgICAgIHNocmlua1JlY3Quc2hyaW5rKGVsZW1lbnRzMi50b3Aub2Zmc2V0SGVpZ2h0ICsgdmVydGljYWxTcGFjaW5nLCBcInRvcFwiKTtcbiAgICB9XG4gICAgaWYgKCFlbGVtZW50czIucmlnaHQuY2xhc3NMaXN0LmNvbnRhaW5zKG1vZGlmaWVycy5oaWRkZW4pKSB7XG4gICAgICBzaHJpbmtSZWN0LnNocmluayhlbGVtZW50czIucmlnaHQub2Zmc2V0V2lkdGggKyBob3Jpem9udGFsU3BhY2luZywgXCJyaWdodFwiKTtcbiAgICB9XG4gICAgaWYgKCFlbGVtZW50czIuYm90dG9tLmNsYXNzTGlzdC5jb250YWlucyhtb2RpZmllcnMuaGlkZGVuKSkge1xuICAgICAgc2hyaW5rUmVjdC5zaHJpbmsoZWxlbWVudHMyLmJvdHRvbS5vZmZzZXRIZWlnaHQgKyB2ZXJ0aWNhbFNwYWNpbmcsIFwiYm90dG9tXCIpO1xuICAgICAgZWxlbWVudHMyLmJvdHRvbS5zdHlsZS50b3AgPSBgJHtzaHJpbmtSZWN0LnkgKyBzaHJpbmtSZWN0LmhlaWdodCArIHZlcnRpY2FsU3BhY2luZ31weGA7XG4gICAgfVxuICAgIGlmICghZWxlbWVudHMyLmxlZnQuY2xhc3NMaXN0LmNvbnRhaW5zKG1vZGlmaWVycy5oaWRkZW4pKSB7XG4gICAgICBzaHJpbmtSZWN0LnNocmluayhlbGVtZW50czIubGVmdC5vZmZzZXRXaWR0aCArIGhvcml6b250YWxTcGFjaW5nLCBcImxlZnRcIik7XG4gICAgfVxuICB9XG4gIHJlZnJlc2hMb2NhbGUoKSB7XG4gICAgY29uc3QgeyBoYXNOZXdMb2NhbGUgfSA9IHRoaXM7XG4gICAgaWYgKCFoYXNOZXdMb2NhbGUpXG4gICAgICByZXR1cm47XG4gICAgZm9yIChjb25zdCBncm91cCBvZiBUT09MQkFSX0dST1VQUykge1xuICAgICAgY29uc3QgYnV0dG9ucyA9IHRoaXNbZ3JvdXBdLmJ1dHRvbkNvbmZpZ3VyYXRpb25zKCk7XG4gICAgICBmb3IgKGNvbnN0IGJ1dHRvbk9wdGlvbnMgb2YgYnV0dG9ucykge1xuICAgICAgICB0aGlzLnJlZnJlc2hCdXR0b25Db250ZW50KGdyb3VwLCBidXR0b25PcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlVG9vbGJhckFyaWFMYWJlbChncm91cCk7XG4gICAgfVxuICAgIHRoaXMuaGFzTmV3TG9jYWxlID0gZmFsc2U7XG4gIH1cbiAgcmVmcmVzaElubmVyTGF5b3V0KHJlY3QpIHtcbiAgICBjb25zdCB7IGVsZW1lbnRzOiBlbGVtZW50czIsIHZlcnRpY2FsU3BhY2luZyB9ID0gdGhpcztcbiAgICBjb25zdCB7IEZsb2F0aW5nQm90dG9tLCBGbG9hdGluZ1RvcCB9ID0gVG9vbGJhclBvc2l0aW9uO1xuICAgIGVsZW1lbnRzMi50b3Auc3R5bGUudG9wID0gYCR7cmVjdC55IC0gZWxlbWVudHMyLnRvcC5vZmZzZXRIZWlnaHQgLSB2ZXJ0aWNhbFNwYWNpbmd9cHhgO1xuICAgIGVsZW1lbnRzMi50b3Auc3R5bGUubGVmdCA9IGAke3JlY3QueH1weGA7XG4gICAgZWxlbWVudHMyLnRvcC5zdHlsZS53aWR0aCA9IGAke3JlY3Qud2lkdGh9cHhgO1xuICAgIGVsZW1lbnRzMi5ib3R0b20uc3R5bGUubGVmdCA9IGAke3JlY3QueH1weGA7XG4gICAgZWxlbWVudHMyLmJvdHRvbS5zdHlsZS53aWR0aCA9IGAke3JlY3Qud2lkdGh9cHhgO1xuICAgIGVsZW1lbnRzMi5yaWdodC5zdHlsZS50b3AgPSBgJHtyZWN0Lnl9cHhgO1xuICAgIGVsZW1lbnRzMi5yaWdodC5zdHlsZS5yaWdodCA9IGAwcHhgO1xuICAgIGVsZW1lbnRzMi5yaWdodC5zdHlsZS5oZWlnaHQgPSBgJHtyZWN0LmhlaWdodH1weGA7XG4gICAgZWxlbWVudHMyLmxlZnQuc3R5bGUudG9wID0gYCR7cmVjdC55fXB4YDtcbiAgICBlbGVtZW50czIubGVmdC5zdHlsZS5sZWZ0ID0gYDBweGA7XG4gICAgZWxlbWVudHMyLmxlZnQuc3R5bGUuaGVpZ2h0ID0gYCR7cmVjdC5oZWlnaHR9cHhgO1xuICAgIGVsZW1lbnRzMltGbG9hdGluZ1RvcF0uc3R5bGUudG9wID0gYCR7cmVjdC55fXB4YDtcbiAgICBlbGVtZW50czJbRmxvYXRpbmdCb3R0b21dLnN0eWxlLnRvcCA9IGAke3JlY3QueSArIHJlY3QuaGVpZ2h0IC0gZWxlbWVudHMyW0Zsb2F0aW5nQm90dG9tXS5vZmZzZXRIZWlnaHR9cHhgO1xuICB9XG4gIHJlZnJlc2hCdXR0b25Db250ZW50KGdyb3VwLCBidXR0b25PcHRpb25zKSB7XG4gICAgY29uc3QgaWQgPSB0aGlzLmJ1dHRvbklkKGJ1dHRvbk9wdGlvbnMpO1xuICAgIGNvbnN0IGJ1dHRvbiA9IHRoaXMuZ3JvdXBQcm94aWVkLmdldChncm91cCk/LmJ1dHRvbnM/LmZpbmQoKGIpID0+IHRoaXMuYnV0dG9uSWQoYikgPT09IGlkKSA/PyBidXR0b25PcHRpb25zO1xuICAgIGNvbnN0IGVsZW1lbnQyID0gdGhpcy5ncm91cEJ1dHRvbnNbZ3JvdXBdLmZpbmQoKGIpID0+IGIuZ2V0QXR0cmlidXRlKFwiZGF0YS10b29sYmFyLWlkXCIpID09PSBpZCk7XG4gICAgaWYgKGVsZW1lbnQyID09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy51cGRhdGVCdXR0b24oZWxlbWVudDIsIGJ1dHRvbik7XG4gIH1cbiAgdG9nZ2xlVmlzaWJpbGl0aWVzKCkge1xuICAgIGlmICh0aGlzLmVsZW1lbnRzID09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgaXNHcm91cFZpc2libGUgPSAoZ3JvdXApID0+IHRoaXNbZ3JvdXBdLmVuYWJsZWQgJiYgdGhpcy5ncm91cENhbGxlcnNbZ3JvdXBdLnNpemUgPiAwO1xuICAgIGNvbnN0IGlzQnV0dG9uVmlzaWJsZSA9IChlbGVtZW50MikgPT4gKGJ1dHRvbikgPT4ge1xuICAgICAgY29uc3QgaWQgPSB0aGlzLmJ1dHRvbklkKGJ1dHRvbik7XG4gICAgICByZXR1cm4gaWQgPT0gbnVsbCB8fCBpZCA9PT0gZWxlbWVudDIuZGF0YXNldC50b29sYmFySWQ7XG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IHBvc2l0aW9uIG9mIFRPT0xCQVJfUE9TSVRJT05TKSB7XG4gICAgICBjb25zdCB2aXNpYmxlID0gdGhpcy5lbmFibGVkICYmIEFycmF5LmZyb20odGhpcy5wb3NpdGlvbnNbcG9zaXRpb25dLnZhbHVlcygpKS5zb21lKGlzR3JvdXBWaXNpYmxlKTtcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gXCJmbG9hdGluZ1wiIC8qIEZsb2F0aW5nICovICYmICF2aXNpYmxlKSB7XG4gICAgICAgIHRoaXMuZHJhZ1N0YXRlLmRldGFjaGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzLmVsZW1lbnRzW3Bvc2l0aW9uXS5jbGFzc0xpc3QudG9nZ2xlKG1vZGlmaWVycy5oaWRkZW4sICF2aXNpYmxlKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBncm91cCBvZiBUT09MQkFSX0dST1VQUykge1xuICAgICAgaWYgKHRoaXNbZ3JvdXBdID09IG51bGwpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3QgZ3JvdXBWaXNpYmxlID0gaXNHcm91cFZpc2libGUoZ3JvdXApO1xuICAgICAgZm9yIChjb25zdCBidXR0b24gb2YgdGhpcy5ncm91cEJ1dHRvbnNbZ3JvdXBdKSB7XG4gICAgICAgIGNvbnN0IGJ1dHRvblZpc2libGUgPSBncm91cFZpc2libGUgJiYgdGhpc1tncm91cF0uYnV0dG9uQ29uZmlndXJhdGlvbnMoKS5zb21lKGlzQnV0dG9uVmlzaWJsZShidXR0b24pKTtcbiAgICAgICAgYnV0dG9uLmNsYXNzTGlzdC50b2dnbGUobW9kaWZpZXJzLmJ1dHRvbi5oaWRkZW5WYWx1ZSwgIWJ1dHRvblZpc2libGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB0cmFuc2xhdGVGbG9hdGluZ0VsZW1lbnRzKHBvc2l0aW9uLCB2aXNpYmxlKSB7XG4gICAgY29uc3QgeyBlbGVtZW50czogZWxlbWVudHMyLCB2ZXJ0aWNhbFNwYWNpbmc6IHZlcnRpY2FsTWFyZ2luLCBwb3NpdGlvbkFsaWdubWVudHMgfSA9IHRoaXM7XG4gICAgY29uc3QgZWxlbWVudDIgPSBlbGVtZW50czJbcG9zaXRpb25dO1xuICAgIGNvbnN0IGFsaWdubWVudHMgPSBPYmplY3QudmFsdWVzKHBvc2l0aW9uQWxpZ25tZW50c1twb3NpdGlvbl0pO1xuICAgIGVsZW1lbnQyLmNsYXNzTGlzdC50b2dnbGUobW9kaWZpZXJzLmZsb2F0aW5nSGlkZGVuLCAhdmlzaWJsZSk7XG4gICAgY29uc3QgZGlyID0gcG9zaXRpb24gPT09IFwiZmxvYXRpbmctYm90dG9tXCIgLyogRmxvYXRpbmdCb3R0b20gKi8gPyAxIDogLTE7XG4gICAgZm9yIChjb25zdCBhbGlnbiBvZiBhbGlnbm1lbnRzKSB7XG4gICAgICBhbGlnbi5zdHlsZS50cmFuc2Zvcm0gPSB2aXNpYmxlICYmIGFsaWduLnN0eWxlLnRyYW5zZm9ybSAhPT0gXCJcIiA/IFwidHJhbnNsYXRlWSgwKVwiIDogYHRyYW5zbGF0ZVkoJHsoZWxlbWVudDIub2Zmc2V0SGVpZ2h0ICsgdmVydGljYWxNYXJnaW4pICogZGlyfXB4KWA7XG4gICAgfVxuICB9XG4gIHJlbmRlclRvb2xiYXIocG9zaXRpb24gPSBcInRvcFwiIC8qIFRvcCAqLykge1xuICAgIGNvbnN0IGVsZW1lbnQyID0gdGhpcy5lbGVtZW50c1twb3NpdGlvbl07XG4gICAgZWxlbWVudDIuY2xhc3NMaXN0LmFkZChibG9jaywgbW9kaWZpZXJzW3Bvc2l0aW9uXSwgbW9kaWZpZXJzLnByZXZlbnRGbGFzaCk7XG4gICAgaWYgKGlzQW5pbWF0aW5nRmxvYXRpbmdQb3NpdGlvbihwb3NpdGlvbikpIHtcbiAgICAgIGVsZW1lbnQyLmNsYXNzTGlzdC5hZGQobW9kaWZpZXJzLmZsb2F0aW5nSGlkZGVuKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBhbGlnbiBvZiBUT09MQkFSX0FMSUdOTUVOVFMpIHtcbiAgICAgIGNvbnN0IGFsaWdubWVudEVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgYWxpZ25tZW50RWxlbWVudC5yb2xlID0gXCJwcmVzZW50YXRpb25cIjtcbiAgICAgIGFsaWdubWVudEVsZW1lbnQuY2xhc3NMaXN0LmFkZChlbGVtZW50cy5hbGlnbiwgbW9kaWZpZXJzLmFsaWduW2FsaWduXSk7XG4gICAgICBlbGVtZW50Mi5hcHBlbmRDaGlsZChhbGlnbm1lbnRFbGVtZW50KTtcbiAgICAgIHRoaXMucG9zaXRpb25BbGlnbm1lbnRzW3Bvc2l0aW9uXVthbGlnbl0gPSBhbGlnbm1lbnRFbGVtZW50O1xuICAgIH1cbiAgfVxuICBjcmVhdGVCdXR0b25FbGVtZW50KGdyb3VwLCBvcHRpb25zKSB7XG4gICAgY29uc3QgYnV0dG9uID0gY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICBidXR0b24uY2xhc3NMaXN0LmFkZChlbGVtZW50cy5idXR0b24pO1xuICAgIGJ1dHRvbi5kYXRhc2V0LnRvb2xiYXJHcm91cCA9IGdyb3VwO1xuICAgIHNldEF0dHJpYnV0ZShidXR0b24sIFwidGFiaW5kZXhcIiwgLTEpO1xuICAgIGlmIChvcHRpb25zLmhhc3BvcHVwKSB7XG4gICAgICBzZXRBdHRyaWJ1dGVzKGJ1dHRvbiwgeyBcImFyaWEtaGFzcG9wdXBcIjogdHJ1ZSwgXCJhcmlhLWV4cGFuZGVkXCI6IGZhbHNlIH0pO1xuICAgIH1cbiAgICBidXR0b24uZGF0YXNldC50b29sYmFySWQgPSB0aGlzLmJ1dHRvbklkKG9wdGlvbnMpO1xuICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgXCJjbGlja1wiLFxuICAgICAgbWFrZUFjY2Vzc2libGVDbGlja0xpc3RlbmVyKFxuICAgICAgICBidXR0b24sXG4gICAgICAgIChldmVudCkgPT4gdGhpcy5vbkJ1dHRvblByZXNzKGV2ZW50LCBidXR0b24sIGdyb3VwLCBvcHRpb25zLmlkLCBvcHRpb25zLnZhbHVlKVxuICAgICAgKVxuICAgICk7XG4gICAgaWYgKG9wdGlvbnMudmFsdWUgPT09IFwiZHJhZ1wiKSB7XG4gICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJtb3VzZWRvd25cIixcbiAgICAgICAgbWFrZUFjY2Vzc2libGVDbGlja0xpc3RlbmVyKGJ1dHRvbiwgKGV2ZW50KSA9PiB0aGlzLm9uRHJhZ1N0YXJ0KGV2ZW50LCBidXR0b24sIGdyb3VwKSlcbiAgICAgICk7XG4gICAgICBidXR0b24uY2xhc3NMaXN0LmFkZChtb2RpZmllcnMuYnV0dG9uLmRyYWdIYW5kbGUpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5yb2xlID09PSBcInN3aXRjaFwiKSB7XG4gICAgICBzZXRBdHRyaWJ1dGVzKGJ1dHRvbiwgeyByb2xlOiBvcHRpb25zLnJvbGUsIFwiYXJpYS1jaGVja2VkXCI6IGZhbHNlIH0pO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUJ1dHRvbihidXR0b24sIG9wdGlvbnMpO1xuICAgIHRoaXMuZGVzdHJveUZucy5wdXNoKCgpID0+IGJ1dHRvbi5yZW1vdmUoKSk7XG4gICAgcmV0dXJuIGJ1dHRvbjtcbiAgfVxuICBnZXRBcmlhVG9vbGJhcihncm91cCkge1xuICAgIGZvciAoY29uc3QgYXJpYVRvb2xiYXIgb2YgdGhpcy5hcmlhVG9vbGJhcnMpIHtcbiAgICAgIGlmIChhcmlhVG9vbGJhci5ncm91cHMuaW5jbHVkZXMoZ3JvdXApKSB7XG4gICAgICAgIHJldHVybiBhcmlhVG9vbGJhcjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBBRyBDaGFydHMgLSBjYW5ub3QgZmluZCBhcmlhLXRvb2xiYXIgb2YgJyR7Z3JvdXB9J2ApO1xuICB9XG4gIHVwZGF0ZVRvb2xiYXJBcmlhTGFiZWwoZ3JvdXAsIGFsaWduRWxlbWVudCkge1xuICAgIGlmICghYWxpZ25FbGVtZW50KSB7XG4gICAgICBjb25zdCB7IGFsaWduLCBwb3NpdGlvbiB9ID0gdGhpc1tncm91cF07XG4gICAgICBhbGlnbkVsZW1lbnQgPSB0aGlzLnBvc2l0aW9uQWxpZ25tZW50c1twb3NpdGlvbl1bYWxpZ25dO1xuICAgICAgaWYgKCFhbGlnbkVsZW1lbnQpXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbWFwID0ge1xuICAgICAgc2VyaWVzVHlwZTogXCJhcmlhTGFiZWxGaW5hbmNpYWxDaGFydHNcIixcbiAgICAgIGFubm90YXRpb25zOiBcImFyaWFMYWJlbEZpbmFuY2lhbENoYXJ0c1wiLFxuICAgICAgYW5ub3RhdGlvbk9wdGlvbnM6IFwiYXJpYUxhYmVsQW5ub3RhdGlvbk9wdGlvbnNUb29sYmFyXCIsXG4gICAgICByYW5nZXM6IFwiYXJpYUxhYmVsUmFuZ2VzVG9vbGJhclwiLFxuICAgICAgem9vbTogXCJhcmlhTGFiZWxab29tVG9vbGJhclwiXG4gICAgfTtcbiAgICBhbGlnbkVsZW1lbnQuYXJpYUxhYmVsID0gdGhpcy5jdHgubG9jYWxlTWFuYWdlci50KG1hcFtncm91cF0pO1xuICB9XG4gIGV4cGFuZEJ1dHRvbkNvbmZpZyhidXR0b24sIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5yb2xlICE9PSBcInN3aXRjaFwiIHx8IGJ1dHRvbi5hcmlhQ2hlY2tlZCAhPT0gXCJ0cnVlXCIgfHwgb3B0aW9ucy5jaGVja2VkT3ZlcnJpZGVzID09PSB2b2lkIDApXG4gICAgICByZXR1cm4gb3B0aW9ucztcbiAgICByZXR1cm4ge1xuICAgICAgaWNvbjogb3B0aW9ucy5jaGVja2VkT3ZlcnJpZGVzLmljb24gPz8gb3B0aW9ucy5pY29uLFxuICAgICAgbGFiZWw6IG9wdGlvbnMuY2hlY2tlZE92ZXJyaWRlcy5sYWJlbCA/PyBvcHRpb25zLmxhYmVsLFxuICAgICAgYXJpYUxhYmVsOiBvcHRpb25zLmNoZWNrZWRPdmVycmlkZXMuYXJpYUxhYmVsID8/IG9wdGlvbnMuYXJpYUxhYmVsLFxuICAgICAgdG9vbHRpcDogb3B0aW9ucy5jaGVja2VkT3ZlcnJpZGVzLnRvb2x0aXAgPz8gb3B0aW9ucy50b29sdGlwXG4gICAgfTtcbiAgfVxuICB1cGRhdGVCdXR0b24oYnV0dG9uLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBkb21NYW5hZ2VyLCBsb2NhbGVNYW5hZ2VyIH0gPSB0aGlzLmN0eDtcbiAgICBjb25zdCB7IGljb24sIGxhYmVsLCBhcmlhTGFiZWwsIHRvb2x0aXAgfSA9IHRoaXMuZXhwYW5kQnV0dG9uQ29uZmlnKGJ1dHRvbiwgb3B0aW9ucyk7XG4gICAgaWYgKHRvb2x0aXApIHtcbiAgICAgIGJ1dHRvbi50aXRsZSA9IGxvY2FsZU1hbmFnZXIudCh0b29sdGlwKTtcbiAgICB9XG4gICAgbGV0IGlubmVyID0gXCJcIjtcbiAgICBpZiAoaWNvbiAhPSBudWxsKSB7XG4gICAgICBpbm5lciA9IGA8c3BhbiBjbGFzcz1cIiR7ZG9tTWFuYWdlci5nZXRJY29uQ2xhc3NOYW1lcyhpY29uKX0gJHtlbGVtZW50cy5pY29ufVwiPjwvc3Bhbj5gO1xuICAgIH1cbiAgICBpZiAobGFiZWwgIT0gbnVsbCkge1xuICAgICAgY29uc3QgdGxhYmVsID0gbG9jYWxlTWFuYWdlci50KGxhYmVsKTtcbiAgICAgIGlubmVyID0gYCR7aW5uZXJ9PHNwYW4gY2xhc3M9XCIke2VsZW1lbnRzLmxhYmVsfVwiPiR7dGxhYmVsfTwvc3Bhbj5gO1xuICAgIH1cbiAgICBidXR0b24uaW5uZXJIVE1MID0gaW5uZXI7XG4gICAgYnV0dG9uLmNsYXNzTGlzdC50b2dnbGUobW9kaWZpZXJzLmJ1dHRvbi5maWxsVmlzaWJsZSwgb3B0aW9ucy5maWxsICE9IG51bGwpO1xuICAgIGJ1dHRvbi5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tZmlsbFwiLCBvcHRpb25zLmZpbGwgPz8gbnVsbCk7XG4gICAgY29uc3Qgc3Ryb2tlV2lkdGhWaXNpYmxlID0gb3B0aW9ucy5zdHJva2VXaWR0aCAhPSBudWxsO1xuICAgIGJ1dHRvbi5jbGFzc0xpc3QudG9nZ2xlKG1vZGlmaWVycy5idXR0b24uc3Ryb2tlV2lkdGhWaXNpYmxlLCBzdHJva2VXaWR0aFZpc2libGUpO1xuICAgIGJ1dHRvbi5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tc3Ryb2tlV2lkdGhcIiwgc3Ryb2tlV2lkdGhWaXNpYmxlID8gYCR7b3B0aW9ucy5zdHJva2VXaWR0aH1weGAgOiBudWxsKTtcbiAgICBjb25zdCB0QXJpYUxhYmVsID0gYXJpYUxhYmVsID8gdGhpcy5jdHgubG9jYWxlTWFuYWdlci50KGFyaWFMYWJlbCkgOiB2b2lkIDA7XG4gICAgc2V0QXR0cmlidXRlKGJ1dHRvbiwgXCJhcmlhLWxhYmVsXCIsIHRBcmlhTGFiZWwpO1xuICB9XG4gIG9uQnV0dG9uUHJlc3MoZXZlbnQsIGJ1dHRvbiwgZ3JvdXAsIGlkLCB2YWx1ZSkge1xuICAgIHRoaXMuY3R4LnRvb2xiYXJNYW5hZ2VyLnByZXNzQnV0dG9uKGdyb3VwLCB0aGlzLmJ1dHRvbklkKHsgaWQsIHZhbHVlIH0pLCB2YWx1ZSwgdGhpcy5idXR0b25SZWN0KGJ1dHRvbiksIGV2ZW50KTtcbiAgfVxuICBvbkRyYWdTdGFydChldmVudCwgYnV0dG9uLCBncm91cCkge1xuICAgIGNvbnN0IGVsZW1lbnQyID0gdGhpcy5lbGVtZW50c1tcImZsb2F0aW5nXCIgLyogRmxvYXRpbmcgKi9dO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgdGhpcy5kcmFnU3RhdGUgPSB7XG4gICAgICBjbGllbnQ6IFZlYzIuZnJvbShldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKSxcbiAgICAgIHBvc2l0aW9uOiBWZWMyLmZyb20oXG4gICAgICAgIE51bWJlcihlbGVtZW50Mi5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwibGVmdFwiKS5yZXBsYWNlKFwicHhcIiwgXCJcIikpLFxuICAgICAgICBOdW1iZXIoZWxlbWVudDIuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcInRvcFwiKS5yZXBsYWNlKFwicHhcIiwgXCJcIikpXG4gICAgICApLFxuICAgICAgZGV0YWNoZWQ6IHRydWVcbiAgICB9O1xuICAgIGJ1dHRvbi5jbGFzc0xpc3QudG9nZ2xlKG1vZGlmaWVycy5idXR0b24uZHJhZ2dpbmcsIHRydWUpO1xuICAgIGNvbnN0IG9uRHJhZyA9IChlKSA9PiB0aGlzLm9uRHJhZyhlLCBncm91cCk7XG4gICAgY29uc3Qgb25EcmFnRW5kID0gKCkgPT4ge1xuICAgICAgYnV0dG9uLmNsYXNzTGlzdC50b2dnbGUobW9kaWZpZXJzLmJ1dHRvbi5kcmFnZ2luZywgZmFsc2UpO1xuICAgICAgd2luZG93Mi5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG9uRHJhZyk7XG4gICAgfTtcbiAgICBjb25zdCB3aW5kb3cyID0gZ2V0V2luZG93KCk7XG4gICAgd2luZG93Mi5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG9uRHJhZyk7XG4gICAgd2luZG93Mi5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBvbkRyYWdFbmQsIHtcbiAgICAgIG9uY2U6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLmN0eC50b29sYmFyTWFuYWdlci5ncm91cE1vdmVkKGdyb3VwKTtcbiAgfVxuICBvbkRyYWcoZXZlbnQsIGdyb3VwKSB7XG4gICAgY29uc3QgeyBlbGVtZW50czogZWxlbWVudHMyLCBkcmFnU3RhdGUgfSA9IHRoaXM7XG4gICAgY29uc3QgZWxlbWVudDIgPSBlbGVtZW50czJbXCJmbG9hdGluZ1wiIC8qIEZsb2F0aW5nICovXTtcbiAgICBjb25zdCB7IG9mZnNldFdpZHRoOiB3aWR0aDIsIG9mZnNldEhlaWdodDogaGVpZ2h0MiB9ID0gZWxlbWVudDI7XG4gICAgY29uc3Qgb2Zmc2V0NCA9IFZlYzIuc3ViKFZlYzIuZnJvbShldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKSwgZHJhZ1N0YXRlLmNsaWVudCk7XG4gICAgY29uc3QgcG9zaXRpb24gPSBWZWMyLmFkZChkcmFnU3RhdGUucG9zaXRpb24sIG9mZnNldDQpO1xuICAgIGNvbnN0IGdyb3VwQkJveCA9IG5ldyBCQm94KHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHdpZHRoMiwgaGVpZ2h0Mik7XG4gICAgdGhpcy5wb3NpdGlvbkdyb3VwKGVsZW1lbnQyLCBncm91cCwgZ3JvdXBCQm94KTtcbiAgfVxuICBidXR0b25JZChidXR0b24pIHtcbiAgICBjb25zdCB7IGlkLCB2YWx1ZSwgbGFiZWwgfSA9IGJ1dHRvbjtcbiAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGlkO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gbGFiZWwgPz8gXCJcIjtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIE9ic2VydmVDaGFuZ2VzKCh0YXJnZXQpID0+IHtcbiAgICB0YXJnZXQucHJvY2Vzc1BlbmRpbmdFdmVudHMoKTtcbiAgICB0YXJnZXQudG9nZ2xlVmlzaWJpbGl0aWVzKCk7XG4gIH0pLFxuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgVG9vbGJhci5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvdG9vbGJhci90b29sYmFyTW9kdWxlLnRzXG52YXIgREFZID0gMWUzICogNjAgKiA2MCAqIDI0O1xudmFyIE1PTlRIID0gREFZICogMzA7XG52YXIgWUVBUiA9IERBWSAqIDM2NTtcbnZhciBzZXJpZXNUeXBlID0ge1xuICBlbmFibGVkOiBmYWxzZSxcbiAgcG9zaXRpb246IFwibGVmdFwiLFxuICBhbGlnbjogXCJzdGFydFwiLFxuICBidXR0b25zOiBbXG4gICAge1xuICAgICAgdG9vbHRpcDogXCJ0b29sYmFyU2VyaWVzVHlwZURyb3Bkb3duXCIsXG4gICAgICB2YWx1ZTogXCJ0eXBlXCIsXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICBoYXNwb3B1cDogdHJ1ZVxuICAgIH1cbiAgXVxufTtcbnZhciBhbm5vdGF0aW9ucyA9IHtcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcG9zaXRpb246IFwibGVmdFwiLFxuICBhbGlnbjogXCJzdGFydFwiLFxuICBidXR0b25zOiBbXG4gICAge1xuICAgICAgaWNvbjogXCJ0cmVuZC1saW5lLWRyYXdpbmdcIixcbiAgICAgIHRvb2x0aXA6IFwidG9vbGJhckFubm90YXRpb25zTGluZUFubm90YXRpb25zXCIsXG4gICAgICB2YWx1ZTogXCJsaW5lLW1lbnVcIixcbiAgICAgIHNlY3Rpb246IFwibGluZS1hbm5vdGF0aW9uc1wiLFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgaGFzcG9wdXA6IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgIGljb246IFwidGV4dC1hbm5vdGF0aW9uXCIsXG4gICAgICB0b29sdGlwOiBcInRvb2xiYXJBbm5vdGF0aW9uc1RleHRBbm5vdGF0aW9uc1wiLFxuICAgICAgdmFsdWU6IFwidGV4dC1tZW51XCIsXG4gICAgICBzZWN0aW9uOiBcInRleHQtYW5ub3RhdGlvbnNcIixcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgIGhhc3BvcHVwOiB0cnVlXG4gICAgfSxcbiAgICB7XG4gICAgICBpY29uOiBcImFycm93LWRyYXdpbmdcIixcbiAgICAgIHRvb2x0aXA6IFwidG9vbGJhckFubm90YXRpb25zU2hhcGVBbm5vdGF0aW9uc1wiLFxuICAgICAgdmFsdWU6IFwic2hhcGUtbWVudVwiLFxuICAgICAgc2VjdGlvbjogXCJzaGFwZS1hbm5vdGF0aW9uc1wiLFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgaGFzcG9wdXA6IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgIGljb246IFwibWVhc3VyZXItZHJhd2luZ1wiLFxuICAgICAgdG9vbHRpcDogXCJ0b29sYmFyQW5ub3RhdGlvbnNNZWFzdXJlckFubm90YXRpb25zXCIsXG4gICAgICB2YWx1ZTogXCJtZWFzdXJlci1tZW51XCIsXG4gICAgICBzZWN0aW9uOiBcIm1lYXN1cmUtYW5ub3RhdGlvbnNcIixcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgIGhhc3BvcHVwOiB0cnVlXG4gICAgfSxcbiAgICB7XG4gICAgICBpY29uOiBcImRlbGV0ZVwiLFxuICAgICAgdG9vbHRpcDogXCJ0b29sYmFyQW5ub3RhdGlvbnNDbGVhckFsbFwiLFxuICAgICAgdmFsdWU6IFwiY2xlYXJcIixcbiAgICAgIHNlY3Rpb246IFwidG9vbHNcIlxuICAgIH1cbiAgXVxufTtcbnZhciBhbm5vdGF0aW9uT3B0aW9ucyA9IHtcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcG9zaXRpb246IFwiZmxvYXRpbmdcIixcbiAgYWxpZ246IFwic3RhcnRcIixcbiAgZHJhZ2dhYmxlOiB0cnVlLFxuICBidXR0b25zOiBbXG4gICAge1xuICAgICAgaWNvbjogXCJ0ZXh0LWFubm90YXRpb25cIixcbiAgICAgIHRvb2x0aXA6IFwidG9vbGJhckFubm90YXRpb25zVGV4dENvbG9yXCIsXG4gICAgICB2YWx1ZTogXCJ0ZXh0LWNvbG9yXCIsXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICBoYXNwb3B1cDogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgaWNvbjogXCJsaW5lLWNvbG9yXCIsXG4gICAgICB0b29sdGlwOiBcInRvb2xiYXJBbm5vdGF0aW9uc0xpbmVDb2xvclwiLFxuICAgICAgdmFsdWU6IFwibGluZS1jb2xvclwiLFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgaGFzcG9wdXA6IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgIGljb246IFwiZmlsbC1jb2xvclwiLFxuICAgICAgdG9vbHRpcDogXCJ0b29sYmFyQW5ub3RhdGlvbnNGaWxsQ29sb3JcIixcbiAgICAgIHZhbHVlOiBcImZpbGwtY29sb3JcIixcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgIGhhc3BvcHVwOiB0cnVlXG4gICAgfSxcbiAgICB7XG4gICAgICB0b29sdGlwOiBcInRvb2xiYXJBbm5vdGF0aW9uc1RleHRTaXplXCIsXG4gICAgICB2YWx1ZTogXCJ0ZXh0LXNpemVcIixcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgIGhhc3BvcHVwOiB0cnVlXG4gICAgfSxcbiAgICB7XG4gICAgICB0b29sdGlwOiBcInRvb2xiYXJBbm5vdGF0aW9uc0xpbmVTdHJva2VXaWR0aFwiLFxuICAgICAgdmFsdWU6IFwibGluZS1zdHJva2Utd2lkdGhcIixcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgIGhhc3BvcHVwOiB0cnVlXG4gICAgfSxcbiAgICB7XG4gICAgICBpY29uOiBcImxpbmUtc3R5bGUtc29saWRcIixcbiAgICAgIHRvb2x0aXA6IFwidG9vbGJhckFubm90YXRpb25zTGluZVN0eWxlXCIsXG4gICAgICB2YWx1ZTogXCJsaW5lLXN0eWxlLXR5cGVcIixcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgIGhhc3BvcHVwOiB0cnVlXG4gICAgfSxcbiAgICB7XG4gICAgICBpY29uOiBcInNldHRpbmdzXCIsXG4gICAgICB0b29sdGlwOiBcInRvb2xiYXJBbm5vdGF0aW9uc1NldHRpbmdzXCIsXG4gICAgICB2YWx1ZTogXCJzZXR0aW5nc1wiLFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgaGFzcG9wdXA6IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgIHJvbGU6IFwic3dpdGNoXCIsXG4gICAgICBpY29uOiBcInVubG9ja2VkXCIsXG4gICAgICB0b29sdGlwOiBcInRvb2xiYXJBbm5vdGF0aW9uc0xvY2tcIixcbiAgICAgIGFyaWFMYWJlbDogXCJ0b29sYmFyQW5ub3RhdGlvbnNMb2NrXCIsXG4gICAgICBjaGVja2VkT3ZlcnJpZGVzOiB7XG4gICAgICAgIGljb246IFwibG9ja2VkXCIsXG4gICAgICAgIHRvb2x0aXA6IFwidG9vbGJhckFubm90YXRpb25zVW5sb2NrXCJcbiAgICAgIH0sXG4gICAgICB2YWx1ZTogXCJsb2NrXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIGljb246IFwiZGVsZXRlXCIsXG4gICAgICB0b29sdGlwOiBcInRvb2xiYXJBbm5vdGF0aW9uc0RlbGV0ZVwiLFxuICAgICAgdmFsdWU6IFwiZGVsZXRlXCJcbiAgICB9XG4gIF1cbn07XG52YXIgcmFuZ2VzID0ge1xuICBlbmFibGVkOiBmYWxzZSxcbiAgcG9zaXRpb246IERFRkFVTFRfVE9PTEJBUl9QT1NJVElPTixcbiAgYWxpZ246IFwic3RhcnRcIixcbiAgYnV0dG9uczogW1xuICAgIHtcbiAgICAgIGxhYmVsOiBcInRvb2xiYXJSYW5nZTFNb250aFwiLFxuICAgICAgYXJpYUxhYmVsOiBcInRvb2xiYXJSYW5nZTFNb250aEFyaWFcIixcbiAgICAgIHZhbHVlOiBNT05USFxuICAgIH0sXG4gICAge1xuICAgICAgbGFiZWw6IFwidG9vbGJhclJhbmdlM01vbnRoc1wiLFxuICAgICAgYXJpYUxhYmVsOiBcInRvb2xiYXJSYW5nZTNNb250aHNBcmlhXCIsXG4gICAgICB2YWx1ZTogMyAqIE1PTlRIXG4gICAgfSxcbiAgICB7XG4gICAgICBsYWJlbDogXCJ0b29sYmFyUmFuZ2U2TW9udGhzXCIsXG4gICAgICBhcmlhTGFiZWw6IFwidG9vbGJhclJhbmdlNk1vbnRoc0FyaWFcIixcbiAgICAgIHZhbHVlOiA2ICogTU9OVEhcbiAgICB9LFxuICAgIHtcbiAgICAgIGxhYmVsOiBcInRvb2xiYXJSYW5nZVllYXJUb0RhdGVcIixcbiAgICAgIGFyaWFMYWJlbDogXCJ0b29sYmFyUmFuZ2VZZWFyVG9EYXRlQXJpYVwiLFxuICAgICAgdmFsdWU6IChfc3RhcnQsIGVuZDIpID0+IFsoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKGAke25ldyBEYXRlKGVuZDIpLmdldEZ1bGxZZWFyKCl9LTAxLTAxYCkpLmdldFRpbWUoKSwgZW5kMl0sXG4gICAgICBpZDogXCJ5ZWFyLXRvLWRhdGVcIlxuICAgIH0sXG4gICAge1xuICAgICAgbGFiZWw6IFwidG9vbGJhclJhbmdlMVllYXJcIixcbiAgICAgIGFyaWFMYWJlbDogXCJ0b29sYmFyUmFuZ2UxWWVhckFyaWFcIixcbiAgICAgIHZhbHVlOiBZRUFSXG4gICAgfSxcbiAgICB7XG4gICAgICBsYWJlbDogXCJ0b29sYmFyUmFuZ2VBbGxcIixcbiAgICAgIGFyaWFMYWJlbDogXCJ0b29sYmFyUmFuZ2VBbGxBcmlhXCIsXG4gICAgICB2YWx1ZTogKHN0YXJ0MiwgZW5kMikgPT4gW3N0YXJ0MiwgZW5kMl0sXG4gICAgICBpZDogXCJhbGxcIlxuICAgIH1cbiAgXVxufTtcbnZhciB6b29tID0ge1xuICBlbmFibGVkOiB0cnVlLFxuICBwb3NpdGlvbjogXCJ0b3BcIixcbiAgYWxpZ246IFwiZW5kXCIsXG4gIGJ1dHRvbnM6IFtcbiAgICB7XG4gICAgICBpY29uOiBcInpvb20tb3V0XCIsXG4gICAgICB0b29sdGlwOiBcInRvb2xiYXJab29tWm9vbU91dFwiLFxuICAgICAgdmFsdWU6IFwiem9vbS1vdXRcIlxuICAgIH0sXG4gICAge1xuICAgICAgaWNvbjogXCJ6b29tLWluXCIsXG4gICAgICB0b29sdGlwOiBcInRvb2xiYXJab29tWm9vbUluXCIsXG4gICAgICB2YWx1ZTogXCJ6b29tLWluXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIGljb246IFwicGFuLWxlZnRcIixcbiAgICAgIHRvb2x0aXA6IFwidG9vbGJhclpvb21QYW5MZWZ0XCIsXG4gICAgICB2YWx1ZTogXCJwYW4tbGVmdFwiXG4gICAgfSxcbiAgICB7XG4gICAgICBpY29uOiBcInBhbi1yaWdodFwiLFxuICAgICAgdG9vbHRpcDogXCJ0b29sYmFyWm9vbVBhblJpZ2h0XCIsXG4gICAgICB2YWx1ZTogXCJwYW4tcmlnaHRcIlxuICAgIH0sXG4gICAge1xuICAgICAgaWNvbjogXCJwYW4tc3RhcnRcIixcbiAgICAgIHRvb2x0aXA6IFwidG9vbGJhclpvb21QYW5TdGFydFwiLFxuICAgICAgdmFsdWU6IFwicGFuLXN0YXJ0XCJcbiAgICB9LFxuICAgIHtcbiAgICAgIGljb246IFwicGFuLWVuZFwiLFxuICAgICAgdG9vbHRpcDogXCJ0b29sYmFyWm9vbVBhbkVuZFwiLFxuICAgICAgdmFsdWU6IFwicGFuLWVuZFwiXG4gICAgfSxcbiAgICB7XG4gICAgICBpY29uOiBcInJlc2V0XCIsXG4gICAgICB0b29sdGlwOiBcInRvb2xiYXJab29tUmVzZXRcIixcbiAgICAgIHZhbHVlOiBcInJlc2V0XCJcbiAgICB9XG4gIF1cbn07XG52YXIgVG9vbGJhck1vZHVsZSA9IHtcbiAgdHlwZTogXCJyb290XCIsXG4gIG9wdGlvbnNLZXk6IFwidG9vbGJhclwiLFxuICBwYWNrYWdlVHlwZTogXCJjb21tdW5pdHlcIixcbiAgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCJdLFxuICBtb2R1bGVGYWN0b3J5OiAoY3R4KSA9PiBuZXcgVG9vbGJhcihjdHgpLFxuICB0aGVtZVRlbXBsYXRlOiB7XG4gICAgdG9vbGJhcjoge1xuICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgIHNlcmllc1R5cGUsXG4gICAgICBhbm5vdGF0aW9ucyxcbiAgICAgIGFubm90YXRpb25PcHRpb25zLFxuICAgICAgcmFuZ2VzLFxuICAgICAgem9vbVxuICAgIH1cbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvZmFjdG9yeS9yZWdpc3RlckluYnVpbHRNb2R1bGVzLnRzXG5mdW5jdGlvbiByZWdpc3RlckluYnVpbHRNb2R1bGVzKCkge1xuICBtb2R1bGVSZWdpc3RyeS5yZWdpc3RlcihcbiAgICBCYWNrZ3JvdW5kTW9kdWxlLFxuICAgIENvbW11bml0eUxlZ2VuZE1vZHVsZSxcbiAgICBMb2NhbGVNb2R1bGUsXG4gICAgTmF2aWdhdG9yTW9kdWxlLFxuICAgIFRvb2xiYXJNb2R1bGUsXG4gICAgQXJlYVNlcmllc01vZHVsZSxcbiAgICBCYXJTZXJpZXNNb2R1bGUsXG4gICAgQnViYmxlU2VyaWVzTW9kdWxlLFxuICAgIExpbmVTZXJpZXNNb2R1bGUsXG4gICAgU2NhdHRlclNlcmllc01vZHVsZSxcbiAgICBEb251dFNlcmllc01vZHVsZSxcbiAgICBQaWVTZXJpZXNNb2R1bGUsXG4gICAgSGlzdG9ncmFtU2VyaWVzTW9kdWxlXG4gICk7XG4gIGZvciAoY29uc3QgQXhpc0NvbnN0cnVjdG9yIG9mIFtOdW1iZXJBeGlzLCBDYXRlZ29yeUF4aXMsIFRpbWVBeGlzLCBHcm91cGVkQ2F0ZWdvcnlBeGlzLCBMb2dBeGlzXSkge1xuICAgIGF4aXNSZWdpc3RyeS5yZWdpc3RlcihBeGlzQ29uc3RydWN0b3IudHlwZSwge1xuICAgICAgbW9kdWxlRmFjdG9yeTogKGN0eCkgPT4gbmV3IEF4aXNDb25zdHJ1Y3RvcihjdHgpLFxuICAgICAgaGlkZGVuOiBBeGlzQ29uc3RydWN0b3IgPT09IEdyb3VwZWRDYXRlZ29yeUF4aXNcbiAgICB9KTtcbiAgfVxufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9mYWN0b3J5L3NldHVwTW9kdWxlcy50c1xuZnVuY3Rpb24gc2V0dXBNb2R1bGVzKCkge1xuICBmb3IgKGNvbnN0IG0gb2YgbW9kdWxlUmVnaXN0cnkubW9kdWxlcykge1xuICAgIGlmIChtLnBhY2thZ2VUeXBlID09PSBcImVudGVycHJpc2VcIiAmJiAhdmVyaWZ5SWZNb2R1bGVFeHBlY3RlZChtKSkge1xuICAgICAgTG9nZ2VyLmVycm9yT25jZShcIlVuZXhwZWN0ZWQgZW50ZXJwcmlzZSBtb2R1bGUgcmVnaXN0ZXJlZDogXCIgKyBtLmlkZW50aWZpZXIpO1xuICAgIH1cbiAgICBpZiAobS50eXBlID09PSBcInJvb3RcIiAmJiBtLnRoZW1lVGVtcGxhdGUpIHtcbiAgICAgIGZvciAoY29uc3QgY2hhcnRUeXBlMiBvZiBtLmNoYXJ0VHlwZXMpIHtcbiAgICAgICAgY2hhcnREZWZhdWx0cy5zZXQoY2hhcnRUeXBlMiwgbS50aGVtZVRlbXBsYXRlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG0udHlwZSA9PT0gXCJzZXJpZXNcIikge1xuICAgICAgaWYgKG0uY2hhcnRUeXBlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQUcgQ2hhcnRzIC0gTW9kdWxlIGRlZmluaXRpb24gZXJyb3I6ICR7bS5pZGVudGlmaWVyfWApO1xuICAgICAgfVxuICAgICAgc2VyaWVzUmVnaXN0cnkucmVnaXN0ZXIobS5pZGVudGlmaWVyLCBtKTtcbiAgICB9XG4gICAgaWYgKG0udHlwZSA9PT0gXCJzZXJpZXMtb3B0aW9uXCIgJiYgbS50aGVtZVRlbXBsYXRlKSB7XG4gICAgICBmb3IgKGNvbnN0IHNlcmllc1R5cGUyIG9mIG0uc2VyaWVzVHlwZXMpIHtcbiAgICAgICAgc2VyaWVzUmVnaXN0cnkuc2V0VGhlbWVUZW1wbGF0ZShzZXJpZXNUeXBlMiwgbS50aGVtZVRlbXBsYXRlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG0udHlwZSA9PT0gXCJheGlzLW9wdGlvblwiICYmIG0udGhlbWVUZW1wbGF0ZSkge1xuICAgICAgZm9yIChjb25zdCBheGlzVHlwZSBvZiBtLmF4aXNUeXBlcykge1xuICAgICAgICBjb25zdCBheGlzVHlwZVRoZW1lID0gYXhpc1JlZ2lzdHJ5LmdldFRoZW1lVGVtcGxhdGUoYXhpc1R5cGUpO1xuICAgICAgICBjb25zdCB0aGVtZSA9IG1lcmdlRGVmYXVsdHMobS50aGVtZVRlbXBsYXRlLCBheGlzVHlwZVRoZW1lKTtcbiAgICAgICAgYXhpc1JlZ2lzdHJ5LnNldFRoZW1lVGVtcGxhdGUoYXhpc1R5cGUsIHRoZW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG0udHlwZSA9PT0gXCJheGlzXCIpIHtcbiAgICAgIGF4aXNSZWdpc3RyeS5yZWdpc3RlcihtLmlkZW50aWZpZXIsIG0pO1xuICAgIH1cbiAgICBpZiAobS50eXBlID09PSBcImxlZ2VuZFwiKSB7XG4gICAgICBsZWdlbmRSZWdpc3RyeS5yZWdpc3RlcihtLmlkZW50aWZpZXIsIG0pO1xuICAgIH1cbiAgfVxuICBpZiAobW9kdWxlUmVnaXN0cnkuaGFzRW50ZXJwcmlzZU1vZHVsZXMoKSkge1xuICAgIGNvbnN0IGV4cGVjdGVkQnV0VW51c2VkID0gZ2V0VW51c2VkRXhwZWN0ZWRNb2R1bGVzKCk7XG4gICAgaWYgKGV4cGVjdGVkQnV0VW51c2VkLmxlbmd0aCA+IDApIHtcbiAgICAgIExvZ2dlci5lcnJvck9uY2UoXCJFbnRlcnByaXNlIG1vZHVsZXMgZXhwZWN0ZWQgYnV0IG5vdCByZWdpc3RlcmVkOiBcIiwgZXhwZWN0ZWRCdXRVbnVzZWQpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9mbG93UHJvcG9ydGlvbkNoYXJ0LnRzXG5mdW5jdGlvbiBpc0Zsb3dQcm9wb3J0aW9uKHNlcmllcykge1xuICByZXR1cm4gc2VyaWVzLnR5cGUgPT09IFwic2Fua2V5XCIgfHwgc2VyaWVzLnR5cGUgPT09IFwiY2hvcmRcIjtcbn1cbnZhciBGbG93UHJvcG9ydGlvbkNoYXJ0ID0gY2xhc3MgZXh0ZW5kcyBDaGFydCB7XG4gIGdldENoYXJ0VHlwZSgpIHtcbiAgICByZXR1cm4gXCJmbG93LXByb3BvcnRpb25cIjtcbiAgfVxuICBhc3luYyB1cGRhdGVEYXRhKCkge1xuICAgIGF3YWl0IHN1cGVyLnVwZGF0ZURhdGEoKTtcbiAgICBjb25zdCB7IG5vZGVzIH0gPSB0aGlzLmdldE9wdGlvbnMoKTtcbiAgICB0aGlzLnNlcmllcy5mb3JFYWNoKChzZXJpZXMpID0+IHtcbiAgICAgIGlmIChpc0Zsb3dQcm9wb3J0aW9uKHNlcmllcykpIHtcbiAgICAgICAgc2VyaWVzLnNldENoYXJ0Tm9kZXMobm9kZXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHBlcmZvcm1MYXlvdXQoY3R4KSB7XG4gICAgY29uc3QgeyBzZXJpZXNSb290LCBhbm5vdGF0aW9uUm9vdCwgaGlnaGxpZ2h0Um9vdCB9ID0gdGhpcztcbiAgICBjb25zdCB7IGxheW91dEJveCB9ID0gY3R4O1xuICAgIGNvbnN0IHNlcmllc1JlY3QgPSBsYXlvdXRCb3guY2xvbmUoKTtcbiAgICBsYXlvdXRCb3guc2hyaW5rKHRoaXMuc2VyaWVzQXJlYS5wYWRkaW5nLnRvSnNvbigpKTtcbiAgICB0aGlzLnNlcmllc1JlY3QgPSBsYXlvdXRCb3g7XG4gICAgdGhpcy5hbmltYXRpb25SZWN0ID0gbGF5b3V0Qm94O1xuICAgIHNlcmllc1Jvb3QudmlzaWJsZSA9IHRoaXMuc2VyaWVzLnNvbWUoKHMpID0+IHMudmlzaWJsZSk7XG4gICAgZm9yIChjb25zdCBncm91cCBvZiBbc2VyaWVzUm9vdCwgYW5ub3RhdGlvblJvb3QsIGhpZ2hsaWdodFJvb3RdKSB7XG4gICAgICBncm91cC50cmFuc2xhdGlvblggPSBNYXRoLmZsb29yKGxheW91dEJveC54KTtcbiAgICAgIGdyb3VwLnRyYW5zbGF0aW9uWSA9IE1hdGguZmxvb3IobGF5b3V0Qm94LnkpO1xuICAgICAgZ3JvdXAuc2V0Q2xpcFJlY3Qoc2VyaWVzUmVjdC5jbG9uZSgpKTtcbiAgICB9XG4gICAgdGhpcy5jdHgubGF5b3V0TWFuYWdlci5lbWl0TGF5b3V0Q29tcGxldGUoY3R4LCB7XG4gICAgICBzZXJpZXM6IHsgdmlzaWJsZTogc2VyaWVzUm9vdC52aXNpYmxlLCByZWN0OiBzZXJpZXNSZWN0LCBwYWRkZWRSZWN0OiBsYXlvdXRCb3ggfVxuICAgIH0pO1xuICB9XG59O1xuRmxvd1Byb3BvcnRpb25DaGFydC5jbGFzc05hbWUgPSBcIkZsb3dQcm9wb3J0aW9uQ2hhcnRcIjtcbkZsb3dQcm9wb3J0aW9uQ2hhcnQudHlwZSA9IFwiZmxvdy1wcm9wb3J0aW9uXCI7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2F4aXMvcG9sYXJBeGlzLnRzXG52YXIgUG9sYXJBeGlzID0gY2xhc3MgZXh0ZW5kcyBBeGlzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnNoYXBlID0gXCJwb2x5Z29uXCI7XG4gICAgdGhpcy5pbm5lclJhZGl1c1JhdGlvID0gMDtcbiAgICB0aGlzLmRlZmF1bHRUaWNrTWluU3BhY2luZyA9IDIwO1xuICB9XG4gIGNvbXB1dGVMYWJlbHNCQm94KF9vcHRpb25zLCBfc2VyaWVzUmVjdCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbXB1dGVSYW5nZSgpIHtcbiAgfVxuICBnZXRBeGlzTGluZVBvaW50cygpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoVU5JT04oW1wicG9seWdvblwiLCBcImNpcmNsZVwiXSwgXCJhIHBvbGFyIGF4aXMgc2hhcGVcIikpXG5dLCBQb2xhckF4aXMucHJvdG90eXBlLCBcInNoYXBlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8pXG5dLCBQb2xhckF4aXMucHJvdG90eXBlLCBcImlubmVyUmFkaXVzUmF0aW9cIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2dhdWdlQ2hhcnQudHNcbmZ1bmN0aW9uIGlzUmFkaWFsR2F1Z2VTZXJpZXMoc2VyaWVzKSB7XG4gIHJldHVybiBzZXJpZXMudHlwZSA9PT0gXCJyYWRpYWwtZ2F1Z2VcIjtcbn1cbmZ1bmN0aW9uIGlzTGluZWFyR2F1Z2VTZXJpZXMoc2VyaWVzKSB7XG4gIHJldHVybiBzZXJpZXMudHlwZSA9PT0gXCJsaW5lYXItZ2F1Z2VcIjtcbn1cbnZhciBHYXVnZUNoYXJ0ID0gY2xhc3MgZXh0ZW5kcyBDaGFydCB7XG4gIGdldENoYXJ0VHlwZSgpIHtcbiAgICByZXR1cm4gXCJnYXVnZVwiO1xuICB9XG4gIHVwZGF0ZVJhZGlhbEdhdWdlKHNlcmllc1JlY3QsIHNlcmllcykge1xuICAgIGNvbnN0IGFuZ2xlQXhpcyA9IHRoaXMuYXhlcy5maW5kKChheGlzKSA9PiBheGlzLmRpcmVjdGlvbiA9PT0gXCJ4XCIgLyogWCAqLyk7XG4gICAgaWYgKCEoYW5nbGVBeGlzIGluc3RhbmNlb2YgUG9sYXJBeGlzKSlcbiAgICAgIHJldHVybjtcbiAgICBhbmdsZUF4aXMuY29tcHV0ZVJhbmdlKCk7XG4gICAgY29uc3Qgc2VyaWVzUmVjdFgwID0gc2VyaWVzUmVjdC54O1xuICAgIGNvbnN0IHNlcmllc1JlY3RYMSA9IHNlcmllc1JlY3RYMCArIHNlcmllc1JlY3Qud2lkdGg7XG4gICAgY29uc3Qgc2VyaWVzUmVjdFkwID0gc2VyaWVzUmVjdC55O1xuICAgIGNvbnN0IHNlcmllc1JlY3RZMSA9IHNlcmllc1JlY3RZMCArIHNlcmllc1JlY3QuaGVpZ2h0O1xuICAgIGNvbnN0IFtzdGFydEFuZ2xlLCBlbmRBbmdsZV0gPSBhbmdsZUF4aXMucmFuZ2U7XG4gICAgY29uc3Qgc3dlZXBBbmdsZSA9IG5vcm1hbGl6ZUFuZ2xlMzYwSW5jbHVzaXZlKGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSk7XG4gICAgY29uc3QgbGFyZ2VyVGhhbkhhbGYgPSBzd2VlcEFuZ2xlID4gTWF0aC5QSTtcbiAgICBjb25zdCBjb250YWluc1RvcCA9IGxhcmdlclRoYW5IYWxmIHx8IGlzQmV0d2VlbkFuZ2xlcygxLjUgKiBNYXRoLlBJLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSk7XG4gICAgY29uc3QgY29udGFpbnNSaWdodCA9IGxhcmdlclRoYW5IYWxmIHx8IGlzQmV0d2VlbkFuZ2xlcygwICogTWF0aC5QSSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpO1xuICAgIGNvbnN0IGNvbnRhaW5zQm90dG9tID0gbGFyZ2VyVGhhbkhhbGYgfHwgaXNCZXR3ZWVuQW5nbGVzKDAuNSAqIE1hdGguUEksIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKTtcbiAgICBjb25zdCBjb250YWluc0xlZnQgPSBsYXJnZXJUaGFuSGFsZiB8fCBpc0JldHdlZW5BbmdsZXMoMSAqIE1hdGguUEksIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKTtcbiAgICBsZXQgdGV4dEFsaWduO1xuICAgIGlmIChjb250YWluc0xlZnQgJiYgIWNvbnRhaW5zUmlnaHQpIHtcbiAgICAgIHRleHRBbGlnbiA9IFwicmlnaHRcIjtcbiAgICB9IGVsc2UgaWYgKCFjb250YWluc0xlZnQgJiYgY29udGFpbnNSaWdodCkge1xuICAgICAgdGV4dEFsaWduID0gXCJsZWZ0XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgfVxuICAgIGxldCB2ZXJ0aWNhbEFsaWduO1xuICAgIGlmIChjb250YWluc1RvcCAmJiAhY29udGFpbnNCb3R0b20pIHtcbiAgICAgIHZlcnRpY2FsQWxpZ24gPSBcImJvdHRvbVwiO1xuICAgIH0gZWxzZSBpZiAoIWNvbnRhaW5zVG9wICYmIGNvbnRhaW5zQm90dG9tKSB7XG4gICAgICB2ZXJ0aWNhbEFsaWduID0gXCJ0b3BcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgdmVydGljYWxBbGlnbiA9IFwibWlkZGxlXCI7XG4gICAgfVxuICAgIGNvbnN0IHVuaXRCb3ggPSBzZWN0b3JCb3goe1xuICAgICAgc3RhcnRBbmdsZSxcbiAgICAgIGVuZEFuZ2xlLFxuICAgICAgaW5uZXJSYWRpdXM6IDAsXG4gICAgICBvdXRlclJhZGl1czogMC41XG4gICAgfSk7XG4gICAgY29uc3QgY2VudGVyWE9mZnNldCA9IC0odW5pdEJveC54ICsgdW5pdEJveC53aWR0aCAvIDIpICogMjtcbiAgICBjb25zdCBjZW50ZXJZT2Zmc2V0ID0gLSh1bml0Qm94LnkgKyB1bml0Qm94LmhlaWdodCAvIDIpICogMjtcbiAgICBjb25zdCB7IG1pbmltdW1SYWRpdXMgPSAwLCBtYXhpbXVtUmFkaXVzIH0gPSBzZXJpZXM7XG4gICAgY29uc3QgcmFkaXVzQm91bmRzID0gTWF0aC5tYXgoXG4gICAgICAwLjUgKiBNYXRoLm1pbihzZXJpZXNSZWN0LndpZHRoIC8gdW5pdEJveC53aWR0aCwgc2VyaWVzUmVjdC5oZWlnaHQgLyB1bml0Qm94LmhlaWdodCksXG4gICAgICAvLyBzZXJpZXNSZWN0IG1heSBoYXZlIG5lZ2F0aXZlIHNpemVcbiAgICAgIDBcbiAgICApO1xuICAgIGxldCByYWRpdXMgPSBNYXRoLm1pbihtYXhpbXVtUmFkaXVzID8/IEluZmluaXR5LCBNYXRoLm1heChyYWRpdXNCb3VuZHMsIG1pbmltdW1SYWRpdXMgPz8gMCkpO1xuICAgIGNvbnN0IE1BWF9JVEVSQVRJT05TID0gODtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1BWF9JVEVSQVRJT05TOyBpICs9IDEpIHtcbiAgICAgIGNvbnN0IGlzRmluYWxJdGVyYXRpb24gPSByYWRpdXMgPD0gbWluaW11bVJhZGl1cyB8fCBpID09PSBNQVhfSVRFUkFUSU9OUyAtIDE7XG4gICAgICBjb25zdCBjZW50ZXJYID0gc2VyaWVzUmVjdC54ICsgc2VyaWVzUmVjdC53aWR0aCAvIDIgKyBjZW50ZXJYT2Zmc2V0ICogcmFkaXVzO1xuICAgICAgY29uc3QgY2VudGVyWSA9IHNlcmllc1JlY3QueSArIHNlcmllc1JlY3QuaGVpZ2h0IC8gMiArIGNlbnRlcllPZmZzZXQgKiByYWRpdXM7XG4gICAgICBhbmdsZUF4aXMudHJhbnNsYXRpb24ueCA9IGNlbnRlclg7XG4gICAgICBhbmdsZUF4aXMudHJhbnNsYXRpb24ueSA9IGNlbnRlclk7XG4gICAgICBhbmdsZUF4aXMuZ3JpZExlbmd0aCA9IHJhZGl1cztcbiAgICAgIGFuZ2xlQXhpcy5jYWxjdWxhdGVMYXlvdXQoKTtcbiAgICAgIGNvbnN0IGJib3ggPSBhbmdsZUF4aXMuY29tcHV0ZUxhYmVsc0JCb3goeyBoaWRlV2hlbk5lY2Vzc2FyeTogaXNGaW5hbEl0ZXJhdGlvbiB9LCBzZXJpZXNSZWN0KTtcbiAgICAgIGlmIChpc0ZpbmFsSXRlcmF0aW9uKVxuICAgICAgICBicmVhaztcbiAgICAgIGxldCBzaHJpbmtEZWx0YSA9IDA7XG4gICAgICBpZiAoYmJveCAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGJib3hYMCA9IGJib3gueCArIGNlbnRlclg7XG4gICAgICAgIGNvbnN0IGJib3hYMSA9IGJib3hYMCArIGJib3gud2lkdGg7XG4gICAgICAgIGNvbnN0IGJib3hZMCA9IGJib3gueSArIGNlbnRlclk7XG4gICAgICAgIGNvbnN0IGJib3hZMSA9IGJib3hZMCArIGJib3guaGVpZ2h0O1xuICAgICAgICBzaHJpbmtEZWx0YSA9IE1hdGgubWF4KFxuICAgICAgICAgIHNlcmllc1JlY3RZMCAtIGJib3hZMCxcbiAgICAgICAgICBzZXJpZXNSZWN0WDAgLSBiYm94WDAsXG4gICAgICAgICAgYmJveFkxIC0gc2VyaWVzUmVjdFkxLFxuICAgICAgICAgIGJib3hYMSAtIHNlcmllc1JlY3RYMSxcbiAgICAgICAgICAwXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoc2hyaW5rRGVsdGEgPiAwKSB7XG4gICAgICAgIHJhZGl1cyA9IE1hdGgubWF4KHJhZGl1cyAtIHNocmlua0RlbHRhLCBtaW5pbXVtUmFkaXVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBhbmdsZUF4aXMudHJhbnNsYXRpb24ueCA9IHNlcmllc1JlY3QueCArIHNlcmllc1JlY3Qud2lkdGggLyAyICsgY2VudGVyWE9mZnNldCAqIHJhZGl1cztcbiAgICBhbmdsZUF4aXMudHJhbnNsYXRpb24ueSA9IHNlcmllc1JlY3QueSArIHNlcmllc1JlY3QuaGVpZ2h0IC8gMiArIGNlbnRlcllPZmZzZXQgKiByYWRpdXM7XG4gICAgc2VyaWVzLmNlbnRlclggPSBzZXJpZXNSZWN0LndpZHRoIC8gMiArIGNlbnRlclhPZmZzZXQgKiByYWRpdXM7XG4gICAgc2VyaWVzLmNlbnRlclkgPSBzZXJpZXNSZWN0LmhlaWdodCAvIDIgKyBjZW50ZXJZT2Zmc2V0ICogcmFkaXVzO1xuICAgIHNlcmllcy5yYWRpdXMgPSByYWRpdXM7XG4gICAgc2VyaWVzLnRleHRBbGlnbiA9IHRleHRBbGlnbjtcbiAgICBzZXJpZXMudmVydGljYWxBbGlnbiA9IHZlcnRpY2FsQWxpZ247XG4gICAgaWYgKHJhZGl1cyA9PT0gMCB8fCByYWRpdXMgPiByYWRpdXNCb3VuZHMpIHtcbiAgICAgIExvZ2dlci53YXJuT25jZShcIlRoZXJlIHdhcyBpbnN1ZmZpY2llbnQgc3BhY2UgdG8gZGlzcGxheSB0aGUgUmFkaWFsIEdhdWdlLlwiKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlTGluZWFyR2F1Z2Uoc2VyaWVzUmVjdCwgc2VyaWVzKSB7XG4gICAgY29uc3QgeEF4aXMgPSB0aGlzLmF4ZXMuZmluZCgoYXhpcykgPT4gYXhpcy5kaXJlY3Rpb24gPT09IFwieFwiIC8qIFggKi8pO1xuICAgIGNvbnN0IHlBeGlzID0gdGhpcy5heGVzLmZpbmQoKGF4aXMpID0+IGF4aXMuZGlyZWN0aW9uID09PSBcInlcIiAvKiBZICovKTtcbiAgICBpZiAoISh4QXhpcyBpbnN0YW5jZW9mIENhcnRlc2lhbkF4aXMpKVxuICAgICAgcmV0dXJuIHNlcmllc1JlY3Q7XG4gICAgaWYgKCEoeUF4aXMgaW5zdGFuY2VvZiBDYXJ0ZXNpYW5BeGlzKSlcbiAgICAgIHJldHVybiBzZXJpZXNSZWN0O1xuICAgIGNvbnN0IHsgaG9yaXpvbnRhbCwgdGhpY2tuZXNzIH0gPSBzZXJpZXM7XG4gICAgbGV0IGhvcml6b250YWxJbnNldCA9IDA7XG4gICAgbGV0IHZlcnRpY2FsSW5zZXQgPSAwO1xuICAgIGNvbnN0IHNjYWxlMiA9IG5ldyBMaW5lYXJTY2FsZSgpO1xuICAgIHNjYWxlMi5kb21haW4gPSBbMCwgMTAwXTtcbiAgICBzY2FsZTIucmFuZ2UgPSBob3Jpem9udGFsID8geEF4aXMucmFuZ2UgOiB5QXhpcy5yYW5nZTtcbiAgICBjb25zdCB0aWNrcyA9IHNjYWxlMi50aWNrcygpO1xuICAgIGlmIChob3Jpem9udGFsKSB7XG4gICAgICBob3Jpem9udGFsSW5zZXQgPSBzZXJpZXMuY29tcHV0ZUluc2V0KFwieFwiIC8qIFggKi8sIHRpY2tzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmVydGljYWxJbnNldCA9IHNlcmllcy5jb21wdXRlSW5zZXQoXCJ5XCIgLyogWSAqLywgdGlja3MpO1xuICAgIH1cbiAgICBjb25zdCBzZXJpZXNXaWR0aCA9IHNlcmllc1JlY3Qud2lkdGggLSBNYXRoLmFicyhob3Jpem9udGFsSW5zZXQpO1xuICAgIGNvbnN0IHNlcmllc0hlaWdodCA9IHNlcmllc1JlY3QuaGVpZ2h0IC0gTWF0aC5hYnModmVydGljYWxJbnNldCk7XG4gICAgY29uc3Qgd2lkdGgyID0gTWF0aC5tYXgoaG9yaXpvbnRhbCA/IHNlcmllc1dpZHRoIDogdGhpY2tuZXNzLCAwKTtcbiAgICBjb25zdCBoZWlnaHQyID0gTWF0aC5tYXgoaG9yaXpvbnRhbCA/IHRoaWNrbmVzcyA6IHNlcmllc0hlaWdodCwgMCk7XG4gICAgY29uc3QgeDAgPSBzZXJpZXNSZWN0LnggKyAoc2VyaWVzV2lkdGggLSB3aWR0aDIpIC8gMiArIE1hdGgubWF4KGhvcml6b250YWxJbnNldCwgMCk7XG4gICAgY29uc3QgeTAgPSBzZXJpZXNSZWN0LnkgKyAoc2VyaWVzSGVpZ2h0IC0gaGVpZ2h0MikgLyAyIC0gTWF0aC5taW4odmVydGljYWxJbnNldCwgMCk7XG4gICAgeEF4aXMucmFuZ2UgPSBbMCwgd2lkdGgyXTtcbiAgICB4QXhpcy5ncmlkTGVuZ3RoID0gd2lkdGgyO1xuICAgIHhBeGlzLmNhbGN1bGF0ZUxheW91dCgpO1xuICAgIHhBeGlzLnRyYW5zbGF0aW9uLnggPSB4MDtcbiAgICB4QXhpcy50cmFuc2xhdGlvbi55ID0geTAgKyAoeEF4aXMucG9zaXRpb24gPT09IFwiYm90dG9tXCIgPyB0aGlja25lc3MgOiAwKTtcbiAgICB5QXhpcy5yYW5nZSA9IFswLCBoZWlnaHQyXTtcbiAgICB5QXhpcy5ncmlkTGVuZ3RoID0gaGVpZ2h0MjtcbiAgICB5QXhpcy5jYWxjdWxhdGVMYXlvdXQoKTtcbiAgICB5QXhpcy50cmFuc2xhdGlvbi54ID0geDAgKyAoeUF4aXMucG9zaXRpb24gPT09IFwicmlnaHRcIiA/IHRoaWNrbmVzcyA6IDApO1xuICAgIHlBeGlzLnRyYW5zbGF0aW9uLnkgPSB5MDtcbiAgICBzZXJpZXMub3JpZ2luWCA9IHgwIC0gc2VyaWVzUmVjdC54O1xuICAgIHNlcmllcy5vcmlnaW5ZID0geTAgLSBzZXJpZXNSZWN0Lnk7XG4gICAgaWYgKHdpZHRoMiA9PT0gMCB8fCBoZWlnaHQyID09PSAwKSB7XG4gICAgICBMb2dnZXIud2Fybk9uY2UoXCJUaGVyZSB3YXMgaW5zdWZmaWNpZW50IHNwYWNlIHRvIGRpc3BsYXkgdGhlIExpbmVhciBHYXVnZS5cIik7XG4gICAgfVxuICB9XG4gIHBlcmZvcm1MYXlvdXQoY3R4KSB7XG4gICAgY29uc3QgeyBzZXJpZXNSb290LCBhbm5vdGF0aW9uUm9vdCwgaGlnaGxpZ2h0Um9vdCwgc2VyaWVzLCBzZXJpZXNBcmVhIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgbGF5b3V0Qm94IH0gPSBjdHg7XG4gICAgY29uc3Qgc2VyaWVzUmVjdCA9IGxheW91dEJveC5jbG9uZSgpO1xuICAgIGxheW91dEJveC5zaHJpbmsoc2VyaWVzQXJlYS5wYWRkaW5nLnRvSnNvbigpKTtcbiAgICBjb25zdCBmaXJzdFNlcmllcyA9IHRoaXMuc2VyaWVzWzBdO1xuICAgIGlmIChpc1JhZGlhbEdhdWdlU2VyaWVzKGZpcnN0U2VyaWVzKSkge1xuICAgICAgdGhpcy51cGRhdGVSYWRpYWxHYXVnZShsYXlvdXRCb3gsIGZpcnN0U2VyaWVzKTtcbiAgICB9IGVsc2UgaWYgKGlzTGluZWFyR2F1Z2VTZXJpZXMoZmlyc3RTZXJpZXMpKSB7XG4gICAgICB0aGlzLnVwZGF0ZUxpbmVhckdhdWdlKGxheW91dEJveCwgZmlyc3RTZXJpZXMpO1xuICAgIH1cbiAgICB0aGlzLmF4ZXMuZm9yRWFjaCgoYXhpcykgPT4gYXhpcy51cGRhdGUoKSk7XG4gICAgdGhpcy5zZXJpZXNSZWN0ID0gc2VyaWVzUmVjdC5jbG9uZSgpLnRyYW5zbGF0ZShzZXJpZXNSZWN0LnggLSBsYXlvdXRCb3gueCwgc2VyaWVzUmVjdC55IC0gbGF5b3V0Qm94LnkpO1xuICAgIHRoaXMuYW5pbWF0aW9uUmVjdCA9IGxheW91dEJveDtcbiAgICBzZXJpZXNSb290LnZpc2libGUgPSBzZXJpZXMuc29tZSgocykgPT4gcy52aXNpYmxlKTtcbiAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIFtzZXJpZXNSb290LCBhbm5vdGF0aW9uUm9vdCwgaGlnaGxpZ2h0Um9vdF0pIHtcbiAgICAgIGdyb3VwLnRyYW5zbGF0aW9uWCA9IE1hdGguZmxvb3IobGF5b3V0Qm94LngpO1xuICAgICAgZ3JvdXAudHJhbnNsYXRpb25ZID0gTWF0aC5mbG9vcihsYXlvdXRCb3gueSk7XG4gICAgfVxuICAgIHRoaXMuY3R4LmxheW91dE1hbmFnZXIuZW1pdExheW91dENvbXBsZXRlKGN0eCwge1xuICAgICAgc2VyaWVzOiB7IHZpc2libGU6IHNlcmllc1Jvb3QudmlzaWJsZSwgcmVjdDogc2VyaWVzUmVjdCwgcGFkZGVkUmVjdDogbGF5b3V0Qm94IH1cbiAgICB9KTtcbiAgfVxuICBnZXRBcmlhTGFiZWwoKSB7XG4gICAgY29uc3QgY2FwdGlvbnMgPSBbXTtcbiAgICBjb25zdCBjaGFydENhcHRpb24gPSB0aGlzLmdldENhcHRpb25UZXh0KCk7XG4gICAgaWYgKGNoYXJ0Q2FwdGlvbi5sZW5ndGggIT09IDApIHtcbiAgICAgIGNhcHRpb25zLnB1c2goY2hhcnRDYXB0aW9uKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBzZXJpZXMgb2YgdGhpcy5zZXJpZXMpIHtcbiAgICAgIGNhcHRpb25zLnB1c2goc2VyaWVzLmdldENhcHRpb25UZXh0KCkpO1xuICAgIH1cbiAgICBjb25zdCBjYXB0aW9uID0gY2FwdGlvbnMuam9pbihcIi4gXCIpO1xuICAgIHJldHVybiB0aGlzLmN0eC5sb2NhbGVNYW5hZ2VyLnQoXCJhcmlhQW5ub3VuY2VHYXVnZUNoYXJ0XCIsIHsgY2FwdGlvbiB9KTtcbiAgfVxufTtcbkdhdWdlQ2hhcnQuY2xhc3NOYW1lID0gXCJHYXVnZUNoYXJ0XCI7XG5HYXVnZUNoYXJ0LnR5cGUgPSBcImdhdWdlXCI7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2hpZXJhcmNoeUNoYXJ0LnRzXG52YXIgSGllcmFyY2h5Q2hhcnQgPSBjbGFzcyBleHRlbmRzIENoYXJ0IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucywgcmVzb3VyY2VzKSB7XG4gICAgc3VwZXIob3B0aW9ucywgcmVzb3VyY2VzKTtcbiAgfVxuICBnZXRDaGFydFR5cGUoKSB7XG4gICAgcmV0dXJuIFwiaGllcmFyY2h5XCI7XG4gIH1cbiAgcGVyZm9ybUxheW91dChjdHgpIHtcbiAgICBjb25zdCB7IHNlcmllc1Jvb3QsIGFubm90YXRpb25Sb290LCBoaWdobGlnaHRSb290IH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgbGF5b3V0Qm94IH0gPSBjdHg7XG4gICAgY29uc3Qgc2VyaWVzUmVjdCA9IGxheW91dEJveC5jbG9uZSgpO1xuICAgIGxheW91dEJveC5zaHJpbmsodGhpcy5zZXJpZXNBcmVhLnBhZGRpbmcudG9Kc29uKCkpO1xuICAgIHRoaXMuc2VyaWVzUmVjdCA9IGxheW91dEJveDtcbiAgICB0aGlzLmFuaW1hdGlvblJlY3QgPSBsYXlvdXRCb3g7XG4gICAgZm9yIChjb25zdCBncm91cCBvZiBbc2VyaWVzUm9vdCwgYW5ub3RhdGlvblJvb3QsIGhpZ2hsaWdodFJvb3RdKSB7XG4gICAgICBncm91cC50cmFuc2xhdGlvblggPSBNYXRoLmZsb29yKGxheW91dEJveC54KTtcbiAgICAgIGdyb3VwLnRyYW5zbGF0aW9uWSA9IE1hdGguZmxvb3IobGF5b3V0Qm94LnkpO1xuICAgIH1cbiAgICBzZXJpZXNSb290LnZpc2libGUgPSB0aGlzLnNlcmllc1swXS52aXNpYmxlO1xuICAgIHNlcmllc1Jvb3Quc2V0Q2xpcFJlY3QobGF5b3V0Qm94LmNsb25lKCkpO1xuICAgIHRoaXMuY3R4LmxheW91dE1hbmFnZXIuZW1pdExheW91dENvbXBsZXRlKGN0eCwge1xuICAgICAgc2VyaWVzOiB7IHZpc2libGU6IHRydWUsIHJlY3Q6IHNlcmllc1JlY3QsIHBhZGRlZFJlY3Q6IGxheW91dEJveCB9XG4gICAgfSk7XG4gIH1cbiAgZ2V0QXJpYUxhYmVsKCkge1xuICAgIGNvbnN0IGNhcHRpb24gPSB0aGlzLmdldENhcHRpb25UZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMuY3R4LmxvY2FsZU1hbmFnZXIudChcImFyaWFBbm5vdW5jZUhpZXJhcmNoeUNoYXJ0XCIsIHsgY2FwdGlvbiB9KTtcbiAgfVxufTtcbkhpZXJhcmNoeUNoYXJ0LmNsYXNzTmFtZSA9IFwiSGllcmFyY2h5Q2hhcnRcIjtcbkhpZXJhcmNoeUNoYXJ0LnR5cGUgPSBcImhpZXJhcmNoeVwiO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9wb2xhckNoYXJ0LnRzXG52YXIgUG9sYXJDaGFydCA9IGNsYXNzIGV4dGVuZHMgQ2hhcnQge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCByZXNvdXJjZXMpIHtcbiAgICBzdXBlcihvcHRpb25zLCByZXNvdXJjZXMpO1xuICAgIHRoaXMucGFkZGluZyA9IG5ldyBQYWRkaW5nKDQwKTtcbiAgICB0aGlzLmN0eC5heGlzTWFuYWdlci5heGlzR3JvdXAuekluZGV4ID0gNiAvKiBBWElTX0ZPUkVHUk9VTkQgKi87XG4gIH1cbiAgZ2V0Q2hhcnRUeXBlKCkge1xuICAgIHJldHVybiBcInBvbGFyXCI7XG4gIH1cbiAgYXN5bmMgcGVyZm9ybUxheW91dChjdHgpIHtcbiAgICBjb25zdCB7IGxheW91dEJveCB9ID0gY3R4O1xuICAgIGNvbnN0IHNlcmllc1JlY3QgPSBsYXlvdXRCb3guY2xvbmUoKTtcbiAgICBsYXlvdXRCb3guc2hyaW5rKHRoaXMuc2VyaWVzQXJlYS5wYWRkaW5nLnRvSnNvbigpKTtcbiAgICB0aGlzLnNlcmllc1JlY3QgPSBsYXlvdXRCb3g7XG4gICAgdGhpcy5hbmltYXRpb25SZWN0ID0gbGF5b3V0Qm94O1xuICAgIGF3YWl0IHRoaXMuY29tcHV0ZUNpcmNsZShsYXlvdXRCb3gpO1xuICAgIHRoaXMuYXhlcy5mb3JFYWNoKChheGlzKSA9PiBheGlzLnVwZGF0ZSgpKTtcbiAgICB0aGlzLmN0eC5sYXlvdXRNYW5hZ2VyLmVtaXRMYXlvdXRDb21wbGV0ZShjdHgsIHtcbiAgICAgIHNlcmllczogeyB2aXNpYmxlOiB0cnVlLCByZWN0OiBzZXJpZXNSZWN0LCBwYWRkZWRSZWN0OiBsYXlvdXRCb3ggfVxuICAgIH0pO1xuICB9XG4gIHVwZGF0ZUF4ZXMoY3gsIGN5LCByYWRpdXMpIHtcbiAgICBjb25zdCBhbmdsZUF4aXMgPSB0aGlzLmF4ZXMuZmluZCgoYXhpcykgPT4gYXhpcy5kaXJlY3Rpb24gPT09IFwieFwiIC8qIFggKi8pO1xuICAgIGNvbnN0IHJhZGl1c0F4aXMgPSB0aGlzLmF4ZXMuZmluZCgoYXhpcykgPT4gYXhpcy5kaXJlY3Rpb24gPT09IFwieVwiIC8qIFkgKi8pO1xuICAgIGlmICghKGFuZ2xlQXhpcyBpbnN0YW5jZW9mIFBvbGFyQXhpcykgfHwgIShyYWRpdXNBeGlzIGluc3RhbmNlb2YgUG9sYXJBeGlzKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBhbmdsZVNjYWxlID0gYW5nbGVBeGlzLnNjYWxlO1xuICAgIGNvbnN0IGlubmVyUmFkaXVzUmF0aW8gPSByYWRpdXNBeGlzLmlubmVyUmFkaXVzUmF0aW87XG4gICAgYW5nbGVBeGlzLmlubmVyUmFkaXVzUmF0aW8gPSBpbm5lclJhZGl1c1JhdGlvO1xuICAgIGFuZ2xlQXhpcy5jb21wdXRlUmFuZ2UoKTtcbiAgICBhbmdsZUF4aXMuZ3JpZExlbmd0aCA9IHJhZGl1cztcbiAgICByYWRpdXNBeGlzLmdyaWRBbmdsZXMgPSBhbmdsZVNjYWxlLnRpY2tzPy4oKS5tYXAoKHZhbHVlKSA9PiBhbmdsZVNjYWxlLmNvbnZlcnQodmFsdWUpKTtcbiAgICByYWRpdXNBeGlzLmdyaWRSYW5nZSA9IGFuZ2xlQXhpcy5yYW5nZTtcbiAgICByYWRpdXNBeGlzLnJhbmdlID0gW3JhZGl1cywgcmFkaXVzICogaW5uZXJSYWRpdXNSYXRpb107XG4gICAgW2FuZ2xlQXhpcywgcmFkaXVzQXhpc10uZm9yRWFjaCgoYXhpcykgPT4ge1xuICAgICAgYXhpcy50cmFuc2xhdGlvbi54ID0gY3g7XG4gICAgICBheGlzLnRyYW5zbGF0aW9uLnkgPSBjeTtcbiAgICAgIGF4aXMuY2FsY3VsYXRlTGF5b3V0KCk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgY29tcHV0ZUNpcmNsZShzZXJpZXNCb3gpIHtcbiAgICBjb25zdCBwb2xhclNlcmllcyA9IHRoaXMuc2VyaWVzLmZpbHRlcihpc1BvbGFyU2VyaWVzKTtcbiAgICBjb25zdCBwb2xhckF4ZXMgPSB0aGlzLmF4ZXMuZmlsdGVyKGlzUG9sYXJBeGlzKTtcbiAgICBjb25zdCBzZXRTZXJpZXNDaXJjbGUgPSAoY3gsIGN5LCByKSA9PiB7XG4gICAgICB0aGlzLnVwZGF0ZUF4ZXMoY3gsIGN5LCByKTtcbiAgICAgIHBvbGFyU2VyaWVzLmZvckVhY2goKHNlcmllcykgPT4ge1xuICAgICAgICBzZXJpZXMuY2VudGVyWCA9IGN4O1xuICAgICAgICBzZXJpZXMuY2VudGVyWSA9IGN5O1xuICAgICAgICBzZXJpZXMucmFkaXVzID0gcjtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcGllU2VyaWVzID0gcG9sYXJTZXJpZXMuZmlsdGVyKChzKSA9PiBzLnR5cGUgPT09IFwiZG9udXRcIiB8fCBzLnR5cGUgPT09IFwicGllXCIpO1xuICAgICAgaWYgKHBpZVNlcmllcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGNvbnN0IGlubmVyUmFkaWkgPSBwaWVTZXJpZXMubWFwKChzZXJpZXMpID0+IHtcbiAgICAgICAgICBjb25zdCBpbm5lclJhZGl1cyA9IHNlcmllcy5nZXRJbm5lclJhZGl1cygpO1xuICAgICAgICAgIHJldHVybiB7IHNlcmllcywgaW5uZXJSYWRpdXMgfTtcbiAgICAgICAgfSkuc29ydCgoYSwgYikgPT4gYS5pbm5lclJhZGl1cyAtIGIuaW5uZXJSYWRpdXMpO1xuICAgICAgICBpbm5lclJhZGlpLmF0KC0xKS5zZXJpZXMuc3Vycm91bmRpbmdSYWRpdXMgPSB2b2lkIDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5uZXJSYWRpaS5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICBpbm5lclJhZGlpW2ldLnNlcmllcy5zdXJyb3VuZGluZ1JhZGl1cyA9IGlubmVyUmFkaWlbaSArIDFdLmlubmVyUmFkaXVzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBjZW50ZXJYID0gc2VyaWVzQm94LnggKyBzZXJpZXNCb3gud2lkdGggLyAyO1xuICAgIGNvbnN0IGNlbnRlclkgPSBzZXJpZXNCb3gueSArIHNlcmllc0JveC5oZWlnaHQgLyAyO1xuICAgIGNvbnN0IGluaXRpYWxSYWRpdXMgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihzZXJpZXNCb3gud2lkdGgsIHNlcmllc0JveC5oZWlnaHQpIC8gMik7XG4gICAgbGV0IHJhZGl1cyA9IGluaXRpYWxSYWRpdXM7XG4gICAgc2V0U2VyaWVzQ2lyY2xlKGNlbnRlclgsIGNlbnRlclksIHJhZGl1cyk7XG4gICAgY29uc3Qgc2hha2UgPSBhc3luYyAoeyBoaWRlV2hlbk5lY2Vzc2FyeSA9IGZhbHNlIH0gPSB7fSkgPT4ge1xuICAgICAgY29uc3QgbGFiZWxCb3hlcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBzZXJpZXMgb2YgaXRlcmF0ZShwb2xhckF4ZXMsIHBvbGFyU2VyaWVzKSkge1xuICAgICAgICBjb25zdCBib3ggPSBhd2FpdCBzZXJpZXMuY29tcHV0ZUxhYmVsc0JCb3goeyBoaWRlV2hlbk5lY2Vzc2FyeSB9LCBzZXJpZXNCb3gpO1xuICAgICAgICBpZiAoYm94KSB7XG4gICAgICAgICAgbGFiZWxCb3hlcy5wdXNoKGJveCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsYWJlbEJveGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzZXRTZXJpZXNDaXJjbGUoY2VudGVyWCwgY2VudGVyWSwgaW5pdGlhbFJhZGl1cyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxhYmVsQm94ID0gQkJveC5tZXJnZShsYWJlbEJveGVzKTtcbiAgICAgIGNvbnN0IHJlZmluZWQgPSB0aGlzLnJlZmluZUNpcmNsZShsYWJlbEJveCwgcmFkaXVzLCBzZXJpZXNCb3gpO1xuICAgICAgc2V0U2VyaWVzQ2lyY2xlKHJlZmluZWQuY2VudGVyWCwgcmVmaW5lZC5jZW50ZXJZLCByZWZpbmVkLnJhZGl1cyk7XG4gICAgICByYWRpdXMgPSByZWZpbmVkLnJhZGl1cztcbiAgICB9O1xuICAgIGF3YWl0IHNoYWtlKCk7XG4gICAgYXdhaXQgc2hha2UoKTtcbiAgICBhd2FpdCBzaGFrZSgpO1xuICAgIGF3YWl0IHNoYWtlKHsgaGlkZVdoZW5OZWNlc3Nhcnk6IHRydWUgfSk7XG4gICAgYXdhaXQgc2hha2UoeyBoaWRlV2hlbk5lY2Vzc2FyeTogdHJ1ZSB9KTtcbiAgICBmb3IgKGNvbnN0IHNlcmllcyBvZiBpdGVyYXRlKHBvbGFyQXhlcywgcG9sYXJTZXJpZXMpKSB7XG4gICAgICBhd2FpdCBzZXJpZXMuY29tcHV0ZUxhYmVsc0JCb3goeyBoaWRlV2hlbk5lY2Vzc2FyeTogdHJ1ZSB9LCBzZXJpZXNCb3gpO1xuICAgIH1cbiAgICByZXR1cm4geyByYWRpdXMsIGNlbnRlclgsIGNlbnRlclkgfTtcbiAgfVxuICByZWZpbmVDaXJjbGUobGFiZWxzQm94LCByYWRpdXMsIHNlcmllc0JveCkge1xuICAgIGNvbnN0IG1pbkNpcmNsZVJhdGlvID0gMC41O1xuICAgIGNvbnN0IGNpcmNsZUxlZnQgPSAtcmFkaXVzO1xuICAgIGNvbnN0IGNpcmNsZVRvcCA9IC1yYWRpdXM7XG4gICAgY29uc3QgY2lyY2xlUmlnaHQgPSByYWRpdXM7XG4gICAgY29uc3QgY2lyY2xlQm90dG9tID0gcmFkaXVzO1xuICAgIGxldCBwYWRMZWZ0ID0gTWF0aC5tYXgoMCwgY2lyY2xlTGVmdCAtIGxhYmVsc0JveC54KTtcbiAgICBsZXQgcGFkVG9wID0gTWF0aC5tYXgoMCwgY2lyY2xlVG9wIC0gbGFiZWxzQm94LnkpO1xuICAgIGxldCBwYWRSaWdodCA9IE1hdGgubWF4KDAsIGxhYmVsc0JveC54ICsgbGFiZWxzQm94LndpZHRoIC0gY2lyY2xlUmlnaHQpO1xuICAgIGxldCBwYWRCb3R0b20gPSBNYXRoLm1heCgwLCBsYWJlbHNCb3gueSArIGxhYmVsc0JveC5oZWlnaHQgLSBjaXJjbGVCb3R0b20pO1xuICAgIHBhZExlZnQgPSBwYWRSaWdodCA9IE1hdGgubWF4KHBhZExlZnQsIHBhZFJpZ2h0KTtcbiAgICBwYWRUb3AgPSBwYWRCb3R0b20gPSBNYXRoLm1heChwYWRUb3AsIHBhZEJvdHRvbSk7XG4gICAgY29uc3QgYXZhaWxDaXJjbGVXaWR0aCA9IHNlcmllc0JveC53aWR0aCAtIHBhZExlZnQgLSBwYWRSaWdodDtcbiAgICBjb25zdCBhdmFpbENpcmNsZUhlaWdodCA9IHNlcmllc0JveC5oZWlnaHQgLSBwYWRUb3AgLSBwYWRCb3R0b207XG4gICAgbGV0IG5ld1JhZGl1cyA9IE1hdGgubWluKGF2YWlsQ2lyY2xlV2lkdGgsIGF2YWlsQ2lyY2xlSGVpZ2h0KSAvIDI7XG4gICAgY29uc3QgbWluSG9yaXpvbnRhbFJhZGl1cyA9IG1pbkNpcmNsZVJhdGlvICogc2VyaWVzQm94LndpZHRoIC8gMjtcbiAgICBjb25zdCBtaW5WZXJ0aWNhbFJhZGl1cyA9IG1pbkNpcmNsZVJhdGlvICogc2VyaWVzQm94LmhlaWdodCAvIDI7XG4gICAgY29uc3QgbWluUmFkaXVzID0gTWF0aC5taW4obWluSG9yaXpvbnRhbFJhZGl1cywgbWluVmVydGljYWxSYWRpdXMpO1xuICAgIGlmIChuZXdSYWRpdXMgPCBtaW5SYWRpdXMpIHtcbiAgICAgIG5ld1JhZGl1cyA9IG1pblJhZGl1cztcbiAgICAgIGNvbnN0IGhvcml6b250YWxQYWRkaW5nID0gcGFkTGVmdCArIHBhZFJpZ2h0O1xuICAgICAgY29uc3QgdmVydGljYWxQYWRkaW5nID0gcGFkVG9wICsgcGFkQm90dG9tO1xuICAgICAgaWYgKDIgKiBuZXdSYWRpdXMgKyB2ZXJ0aWNhbFBhZGRpbmcgPiBzZXJpZXNCb3guaGVpZ2h0KSB7XG4gICAgICAgIGNvbnN0IHBhZEhlaWdodCA9IHNlcmllc0JveC5oZWlnaHQgLSAyICogbmV3UmFkaXVzO1xuICAgICAgICBpZiAoTWF0aC5taW4ocGFkVG9wLCBwYWRCb3R0b20pICogMiA+IHBhZEhlaWdodCkge1xuICAgICAgICAgIHBhZFRvcCA9IHBhZEhlaWdodCAvIDI7XG4gICAgICAgICAgcGFkQm90dG9tID0gcGFkSGVpZ2h0IC8gMjtcbiAgICAgICAgfSBlbHNlIGlmIChwYWRUb3AgPiBwYWRCb3R0b20pIHtcbiAgICAgICAgICBwYWRUb3AgPSBwYWRIZWlnaHQgLSBwYWRCb3R0b207XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFkQm90dG9tID0gcGFkSGVpZ2h0IC0gcGFkVG9wO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoMiAqIG5ld1JhZGl1cyArIGhvcml6b250YWxQYWRkaW5nID4gc2VyaWVzQm94LndpZHRoKSB7XG4gICAgICAgIGNvbnN0IHBhZFdpZHRoID0gc2VyaWVzQm94LndpZHRoIC0gMiAqIG5ld1JhZGl1cztcbiAgICAgICAgaWYgKE1hdGgubWluKHBhZExlZnQsIHBhZFJpZ2h0KSAqIDIgPiBwYWRXaWR0aCkge1xuICAgICAgICAgIHBhZExlZnQgPSBwYWRXaWR0aCAvIDI7XG4gICAgICAgICAgcGFkUmlnaHQgPSBwYWRXaWR0aCAvIDI7XG4gICAgICAgIH0gZWxzZSBpZiAocGFkTGVmdCA+IHBhZFJpZ2h0KSB7XG4gICAgICAgICAgcGFkTGVmdCA9IHBhZFdpZHRoIC0gcGFkUmlnaHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFkUmlnaHQgPSBwYWRXaWR0aCAtIHBhZExlZnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbmV3V2lkdGggPSBwYWRMZWZ0ICsgMiAqIG5ld1JhZGl1cyArIHBhZFJpZ2h0O1xuICAgIGNvbnN0IG5ld0hlaWdodCA9IHBhZFRvcCArIDIgKiBuZXdSYWRpdXMgKyBwYWRCb3R0b207XG4gICAgcmV0dXJuIHtcbiAgICAgIGNlbnRlclg6IHNlcmllc0JveC54ICsgKHNlcmllc0JveC53aWR0aCAtIG5ld1dpZHRoKSAvIDIgKyBwYWRMZWZ0ICsgbmV3UmFkaXVzLFxuICAgICAgY2VudGVyWTogc2VyaWVzQm94LnkgKyAoc2VyaWVzQm94LmhlaWdodCAtIG5ld0hlaWdodCkgLyAyICsgcGFkVG9wICsgbmV3UmFkaXVzLFxuICAgICAgcmFkaXVzOiBuZXdSYWRpdXNcbiAgICB9O1xuICB9XG59O1xuUG9sYXJDaGFydC5jbGFzc05hbWUgPSBcIlBvbGFyQ2hhcnRcIjtcblBvbGFyQ2hhcnQudHlwZSA9IFwicG9sYXJcIjtcbmZ1bmN0aW9uIGlzUG9sYXJTZXJpZXMoc2VyaWVzKSB7XG4gIHJldHVybiBzZXJpZXMgaW5zdGFuY2VvZiBQb2xhclNlcmllcztcbn1cbmZ1bmN0aW9uIGlzUG9sYXJBeGlzKGF4aXMpIHtcbiAgcmV0dXJuIGF4aXMgaW5zdGFuY2VvZiBQb2xhckF4aXM7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3N0YW5kYWxvbmVDaGFydC50c1xudmFyIFN0YW5kYWxvbmVDaGFydCA9IGNsYXNzIGV4dGVuZHMgQ2hhcnQge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCByZXNvdXJjZXMpIHtcbiAgICBzdXBlcihvcHRpb25zLCByZXNvdXJjZXMpO1xuICB9XG4gIGdldENoYXJ0VHlwZSgpIHtcbiAgICByZXR1cm4gXCJzdGFuZGFsb25lXCI7XG4gIH1cbiAgcGVyZm9ybUxheW91dChjdHgpIHtcbiAgICBjb25zdCB7IHNlcmllc1Jvb3QsIGFubm90YXRpb25Sb290LCBoaWdobGlnaHRSb290IH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgbGF5b3V0Qm94IH0gPSBjdHg7XG4gICAgY29uc3Qgc2VyaWVzUmVjdCA9IGxheW91dEJveC5jbG9uZSgpO1xuICAgIGxheW91dEJveC5zaHJpbmsodGhpcy5zZXJpZXNBcmVhLnBhZGRpbmcudG9Kc29uKCkpO1xuICAgIHRoaXMuc2VyaWVzUmVjdCA9IGxheW91dEJveDtcbiAgICB0aGlzLmFuaW1hdGlvblJlY3QgPSBsYXlvdXRCb3g7XG4gICAgZm9yIChjb25zdCBncm91cCBvZiBbc2VyaWVzUm9vdCwgYW5ub3RhdGlvblJvb3QsIGhpZ2hsaWdodFJvb3RdKSB7XG4gICAgICBncm91cC50cmFuc2xhdGlvblggPSBNYXRoLmZsb29yKGxheW91dEJveC54KTtcbiAgICAgIGdyb3VwLnRyYW5zbGF0aW9uWSA9IE1hdGguZmxvb3IobGF5b3V0Qm94LnkpO1xuICAgIH1cbiAgICBzZXJpZXNSb290LnZpc2libGUgPSB0aGlzLnNlcmllc1swXS52aXNpYmxlO1xuICAgIHRoaXMuY3R4LmxheW91dE1hbmFnZXIuZW1pdExheW91dENvbXBsZXRlKGN0eCwge1xuICAgICAgc2VyaWVzOiB7IHZpc2libGU6IHRydWUsIHJlY3Q6IHNlcmllc1JlY3QsIHBhZGRlZFJlY3Q6IGxheW91dEJveCB9XG4gICAgfSk7XG4gIH1cbiAgZ2V0QXJpYUxhYmVsKCkge1xuICAgIGNvbnN0IGNhcHRpb24gPSB0aGlzLmdldENhcHRpb25UZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMuY3R4LmxvY2FsZU1hbmFnZXIudChcImFyaWFBbm5vdW5jZUhpZXJhcmNoeUNoYXJ0XCIsIHsgY2FwdGlvbiB9KTtcbiAgfVxufTtcblN0YW5kYWxvbmVDaGFydC5jbGFzc05hbWUgPSBcIlN0YW5kYWxvbmVDaGFydFwiO1xuU3RhbmRhbG9uZUNoYXJ0LnR5cGUgPSBcInN0YW5kYWxvbmVcIjtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL3RvcG9sb2d5L21lcmNhdG9yU2NhbGUudHNcbnZhciByYWRzSW5EZWcgPSBNYXRoLlBJIC8gMTgwO1xudmFyIGxvblggPSAobG9uKSA9PiBsb24gKiByYWRzSW5EZWc7XG52YXIgbGF0WSA9IChsYXQpID0+IC1NYXRoLmxvZyhNYXRoLnRhbihNYXRoLlBJICogMC4yNSArIGxhdCAqIHJhZHNJbkRlZyAqIDAuNSkpO1xudmFyIHhMb24gPSAoeCkgPT4geCAvIHJhZHNJbkRlZztcbnZhciB5TGF0ID0gKHkpID0+IChNYXRoLmF0YW4oTWF0aC5leHAoLXkpKSAtIE1hdGguUEkgKiAwLjI1KSAvIChyYWRzSW5EZWcgKiAwLjUpO1xudmFyIE1lcmNhdG9yU2NhbGUgPSBjbGFzcyBfTWVyY2F0b3JTY2FsZSB7XG4gIGNvbnN0cnVjdG9yKGRvbWFpbiwgcmFuZ2UzKSB7XG4gICAgdGhpcy5kb21haW4gPSBkb21haW47XG4gICAgdGhpcy5yYW5nZSA9IHJhbmdlMztcbiAgICB0aGlzLnR5cGUgPSBcIm1lcmNhdG9yXCI7XG4gICAgdGhpcy5ib3VuZHMgPSBfTWVyY2F0b3JTY2FsZS5ib3VuZHMoZG9tYWluKTtcbiAgfVxuICBzdGF0aWMgYm91bmRzKGRvbWFpbikge1xuICAgIGNvbnN0IFtbbG9uMCwgbGF0MF0sIFtsb24xLCBsYXQxXV0gPSBkb21haW47XG4gICAgY29uc3QgeDAgPSBsb25YKGxvbjApO1xuICAgIGNvbnN0IHkwID0gbGF0WShsYXQwKTtcbiAgICBjb25zdCB4MSA9IGxvblgobG9uMSk7XG4gICAgY29uc3QgeTEgPSBsYXRZKGxhdDEpO1xuICAgIHJldHVybiBuZXcgQkJveChNYXRoLm1pbih4MCwgeDEpLCBNYXRoLm1pbih5MCwgeTEpLCBNYXRoLmFicyh4MSAtIHgwKSwgTWF0aC5hYnMoeTEgLSB5MCkpO1xuICB9XG4gIHN0YXRpYyBmaXhlZFNjYWxlKCkge1xuICAgIHJldHVybiBuZXcgX01lcmNhdG9yU2NhbGUoXG4gICAgICBbXG4gICAgICAgIFt4TG9uKDApLCB5TGF0KDApXSxcbiAgICAgICAgW3hMb24oMSksIHlMYXQoMSldXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICBbMCwgMF0sXG4gICAgICAgIFsxLCAxXVxuICAgICAgXVxuICAgICk7XG4gIH1cbiAgY29udmVydChbbG9uLCBsYXRdKSB7XG4gICAgY29uc3QgW1t4MCwgeTBdLCBbeDEsIHkxXV0gPSB0aGlzLnJhbmdlO1xuICAgIGNvbnN0IHhTY2FsZSA9ICh4MSAtIHgwKSAvIHRoaXMuYm91bmRzLndpZHRoO1xuICAgIGNvbnN0IHlTY2FsZSA9ICh5MSAtIHkwKSAvIHRoaXMuYm91bmRzLmhlaWdodDtcbiAgICByZXR1cm4gWyhsb25YKGxvbikgLSB0aGlzLmJvdW5kcy54KSAqIHhTY2FsZSArIHgwLCAobGF0WShsYXQpIC0gdGhpcy5ib3VuZHMueSkgKiB5U2NhbGUgKyB5MF07XG4gIH1cbiAgaW52ZXJ0KFt4LCB5XSkge1xuICAgIGNvbnN0IFtbeDAsIHkwXSwgW3gxLCB5MV1dID0gdGhpcy5yYW5nZTtcbiAgICBjb25zdCB4U2NhbGUgPSAoeDEgLSB4MCkgLyB0aGlzLmJvdW5kcy53aWR0aDtcbiAgICBjb25zdCB5U2NhbGUgPSAoeTEgLSB5MCkgLyB0aGlzLmJvdW5kcy5oZWlnaHQ7XG4gICAgcmV0dXJuIFt4TG9uKCh4IC0geDApIC8geFNjYWxlICsgdGhpcy5ib3VuZHMueCksIHlMYXQoKHkgLSB5MCkgLyB5U2NhbGUgKyB0aGlzLmJvdW5kcy55KV07XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3RvcG9sb2d5Q2hhcnQudHNcbmZ1bmN0aW9uIGlzVG9wb2xvZ3lTZXJpZXMoc2VyaWVzKSB7XG4gIHJldHVybiBzZXJpZXMudHlwZSA9PT0gXCJtYXAtc2hhcGVcIiB8fCBzZXJpZXMudHlwZSA9PT0gXCJtYXAtbGluZVwiIHx8IHNlcmllcy50eXBlID09PSBcIm1hcC1tYXJrZXJcIiB8fCBzZXJpZXMudHlwZSA9PT0gXCJtYXAtc2hhcGUtYmFja2dyb3VuZFwiIHx8IHNlcmllcy50eXBlID09PSBcIm1hcC1saW5lLWJhY2tncm91bmRcIjtcbn1cbnZhciBUb3BvbG9neUNoYXJ0ID0gY2xhc3MgZXh0ZW5kcyBDaGFydCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIHJlc291cmNlcykge1xuICAgIHN1cGVyKG9wdGlvbnMsIHJlc291cmNlcyk7XG4gICAgdGhpcy54QXhpcyA9IG5ldyBOdW1iZXJBeGlzKHRoaXMuZ2V0TW9kdWxlQ29udGV4dCgpKTtcbiAgICB0aGlzLnhBeGlzLnBvc2l0aW9uID0gXCJib3R0b21cIjtcbiAgICB0aGlzLnlBeGlzID0gbmV3IE51bWJlckF4aXModGhpcy5nZXRNb2R1bGVDb250ZXh0KCkpO1xuICAgIHRoaXMueUF4aXMucG9zaXRpb24gPSBcImxlZnRcIjtcbiAgICB0aGlzLmN0eC56b29tTWFuYWdlci51cGRhdGVBeGVzKFt0aGlzLnhBeGlzLCB0aGlzLnlBeGlzXSk7XG4gIH1cbiAgZ2V0Q2hhcnRUeXBlKCkge1xuICAgIHJldHVybiBcInRvcG9sb2d5XCI7XG4gIH1cbiAgYXN5bmMgdXBkYXRlRGF0YSgpIHtcbiAgICBhd2FpdCBzdXBlci51cGRhdGVEYXRhKCk7XG4gICAgY29uc3QgeyB0b3BvbG9neSB9ID0gdGhpcy5nZXRPcHRpb25zKCk7XG4gICAgdGhpcy5zZXJpZXMuZm9yRWFjaCgoc2VyaWVzKSA9PiB7XG4gICAgICBpZiAoaXNUb3BvbG9neVNlcmllcyhzZXJpZXMpKSB7XG4gICAgICAgIHNlcmllcy5zZXRDaGFydFRvcG9sb2d5KHRvcG9sb2d5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBwZXJmb3JtTGF5b3V0KGN0eCkge1xuICAgIGNvbnN0IHsgc2VyaWVzUm9vdCwgYW5ub3RhdGlvblJvb3QsIGhpZ2hsaWdodFJvb3QgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBsYXlvdXRCb3ggfSA9IGN0eDtcbiAgICBjb25zdCBzZXJpZXNSZWN0ID0gbGF5b3V0Qm94LmNsb25lKCk7XG4gICAgbGF5b3V0Qm94LnNocmluayh0aGlzLnNlcmllc0FyZWEucGFkZGluZy50b0pzb24oKSk7XG4gICAgdGhpcy5zZXJpZXNSZWN0ID0gbGF5b3V0Qm94O1xuICAgIHRoaXMuYW5pbWF0aW9uUmVjdCA9IGxheW91dEJveDtcbiAgICBjb25zdCBtYXBTZXJpZXMgPSB0aGlzLnNlcmllcy5maWx0ZXIoaXNUb3BvbG9neVNlcmllcyk7XG4gICAgY29uc3QgY29tYmluZWRCYm94ID0gbWFwU2VyaWVzLnJlZHVjZSgoY29tYmluZWQsIHNlcmllcykgPT4ge1xuICAgICAgaWYgKCFzZXJpZXMudmlzaWJsZSlcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVkO1xuICAgICAgY29uc3QgYmJveCA9IHNlcmllcy50b3BvbG9neUJvdW5kcztcbiAgICAgIGlmIChiYm94ID09IG51bGwpXG4gICAgICAgIHJldHVybiBjb21iaW5lZDtcbiAgICAgIGlmIChjb21iaW5lZCA9PSBudWxsKVxuICAgICAgICByZXR1cm4gYmJveDtcbiAgICAgIGNvbWJpbmVkLm1lcmdlKGJib3gpO1xuICAgICAgcmV0dXJuIGNvbWJpbmVkO1xuICAgIH0sIHZvaWQgMCk7XG4gICAgbGV0IHNjYWxlMjtcbiAgICBpZiAoY29tYmluZWRCYm94ICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHsgbG9uMCwgbGF0MCwgbG9uMSwgbGF0MSB9ID0gY29tYmluZWRCYm94O1xuICAgICAgY29uc3QgZG9tYWluID0gW1xuICAgICAgICBbbG9uMCwgbGF0MF0sXG4gICAgICAgIFtsb24xLCBsYXQxXVxuICAgICAgXTtcbiAgICAgIGNvbnN0IGJvdW5kcyA9IE1lcmNhdG9yU2NhbGUuYm91bmRzKGRvbWFpbik7XG4gICAgICBjb25zdCB7IHdpZHRoOiB3aWR0aDIsIGhlaWdodDogaGVpZ2h0MiB9ID0gbGF5b3V0Qm94O1xuICAgICAgY29uc3Qgdmlld0JveFNjYWxlID0gTWF0aC5taW4od2lkdGgyIC8gYm91bmRzLndpZHRoLCBoZWlnaHQyIC8gYm91bmRzLmhlaWdodCk7XG4gICAgICBjb25zdCB2aWV3Qm94V2lkdGggPSBib3VuZHMud2lkdGggKiB2aWV3Qm94U2NhbGU7XG4gICAgICBjb25zdCB2aWV3Qm94SGVpZ2h0ID0gYm91bmRzLmhlaWdodCAqIHZpZXdCb3hTY2FsZTtcbiAgICAgIGNvbnN0IHZpZXdCb3hPcmlnaW5YID0gKHdpZHRoMiAtIHZpZXdCb3hXaWR0aCkgLyAyO1xuICAgICAgY29uc3Qgdmlld0JveE9yaWdpblkgPSAoaGVpZ2h0MiAtIHZpZXdCb3hIZWlnaHQpIC8gMjtcbiAgICAgIGNvbnN0IHgwID0gdmlld0JveE9yaWdpblg7XG4gICAgICBjb25zdCB5MCA9IHZpZXdCb3hPcmlnaW5ZO1xuICAgICAgY29uc3QgeDEgPSB2aWV3Qm94T3JpZ2luWCArIHZpZXdCb3hXaWR0aDtcbiAgICAgIGNvbnN0IHkxID0gdmlld0JveE9yaWdpblkgKyB2aWV3Qm94SGVpZ2h0O1xuICAgICAgY29uc3QgeFpvb20gPSB0aGlzLmN0eC56b29tTWFuYWdlci5nZXRBeGlzWm9vbSh0aGlzLnhBeGlzLmlkKTtcbiAgICAgIGNvbnN0IHlab29tID0gdGhpcy5jdHguem9vbU1hbmFnZXIuZ2V0QXhpc1pvb20odGhpcy55QXhpcy5pZCk7XG4gICAgICBjb25zdCB4U3BhbiA9ICh4MSAtIHgwKSAvICh4Wm9vbS5tYXggLSB4Wm9vbS5taW4pO1xuICAgICAgY29uc3QgeFN0YXJ0ID0geDAgLSB4U3BhbiAqIHhab29tLm1pbjtcbiAgICAgIGNvbnN0IHlTcGFuID0gKHkxIC0geTApIC8gKDEgLSB5Wm9vbS5taW4gLSAoMSAtIHlab29tLm1heCkpO1xuICAgICAgY29uc3QgeVN0YXJ0ID0geTAgLSB5U3BhbiAqICgxIC0geVpvb20ubWF4KTtcbiAgICAgIHNjYWxlMiA9IG5ldyBNZXJjYXRvclNjYWxlKGRvbWFpbiwgW1xuICAgICAgICBbeFN0YXJ0LCB5U3RhcnRdLFxuICAgICAgICBbeFN0YXJ0ICsgeFNwYW4sIHlTdGFydCArIHlTcGFuXVxuICAgICAgXSk7XG4gICAgfVxuICAgIG1hcFNlcmllcy5mb3JFYWNoKChzZXJpZXMpID0+IHtcbiAgICAgIHNlcmllcy5zY2FsZSA9IHNjYWxlMjtcbiAgICB9KTtcbiAgICBjb25zdCBzZXJpZXNWaXNpYmxlID0gdGhpcy5zZXJpZXMuc29tZSgocykgPT4gcy52aXNpYmxlKTtcbiAgICBzZXJpZXNSb290LnZpc2libGUgPSBzZXJpZXNWaXNpYmxlO1xuICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgW3Nlcmllc1Jvb3QsIGFubm90YXRpb25Sb290LCBoaWdobGlnaHRSb290XSkge1xuICAgICAgZ3JvdXAudHJhbnNsYXRpb25YID0gTWF0aC5mbG9vcihsYXlvdXRCb3gueCk7XG4gICAgICBncm91cC50cmFuc2xhdGlvblkgPSBNYXRoLmZsb29yKGxheW91dEJveC55KTtcbiAgICAgIGdyb3VwLnNldENsaXBSZWN0KGxheW91dEJveC5jbG9uZSgpKTtcbiAgICB9XG4gICAgdGhpcy5jdHgubGF5b3V0TWFuYWdlci5lbWl0TGF5b3V0Q29tcGxldGUoY3R4LCB7XG4gICAgICBzZXJpZXM6IHsgdmlzaWJsZTogc2VyaWVzVmlzaWJsZSwgcmVjdDogc2VyaWVzUmVjdCwgcGFkZGVkUmVjdDogbGF5b3V0Qm94IH1cbiAgICB9KTtcbiAgfVxufTtcblRvcG9sb2d5Q2hhcnQuY2xhc3NOYW1lID0gXCJUb3BvbG9neUNoYXJ0XCI7XG5Ub3BvbG9neUNoYXJ0LnR5cGUgPSBcInRvcG9sb2d5XCI7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2FwaS9wcmVzZXQvcHJlc2V0VXRpbHMudHNcbmZ1bmN0aW9uIGFzc2VydEVtcHR5KF90KSB7XG59XG52YXIgSUdOT1JFRF9QUk9QID0gU3ltYm9sKFwiSUdOT1JFRF9QUk9QXCIpO1xuZnVuY3Rpb24gcGlja1Byb3BzKG9wdHMsIHZhbHVlcykge1xuICBjb25zdCBvdXQgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWVzKSB7XG4gICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNba2V5XTtcbiAgICBpZiAodmFsdWUgIT09IElHTk9SRURfUFJPUCAmJiBPYmplY3QuaGFzT3duKG9wdHMsIGtleSkpIHtcbiAgICAgIG91dFtrZXldID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2FwaS9wcmVzZXQvZ2F1Z2UudHNcbmZ1bmN0aW9uIGlzUmFkaWFsR2F1Z2Uob3B0cykge1xuICByZXR1cm4gb3B0cy50eXBlID09PSBcInJhZGlhbC1nYXVnZVwiO1xufVxuZnVuY3Rpb24gaXNMaW5lYXJHYXVnZShvcHRzKSB7XG4gIHJldHVybiBvcHRzLnR5cGUgPT09IFwibGluZWFyLWdhdWdlXCI7XG59XG5mdW5jdGlvbiByYWRpYWxHYXVnZU9wdGlvbnMob3B0cykge1xuICBjb25zdCB7XG4gICAgYW5pbWF0aW9uLFxuICAgIGJhY2tncm91bmQsXG4gICAgY29udGFpbmVyLFxuICAgIGNvbnRleHRNZW51LFxuICAgIGZvb3Rub3RlLFxuICAgIGhlaWdodDogaGVpZ2h0MixcbiAgICBsaXN0ZW5lcnMsXG4gICAgbG9jYWxlLFxuICAgIG1pbkhlaWdodCxcbiAgICBtaW5XaWR0aCxcbiAgICBwYWRkaW5nLFxuICAgIHN1YnRpdGxlLFxuICAgIHRoZW1lLFxuICAgIHRpdGxlLFxuICAgIHdpZHRoOiB3aWR0aDIsXG4gICAgdHlwZSxcbiAgICBjdXJzb3IsXG4gICAgbm9kZUNsaWNrUmFuZ2UsXG4gICAgdG9vbHRpcCxcbiAgICB2YWx1ZSxcbiAgICBzY2FsZTogc2NhbGUyID0ge30sXG4gICAgc3RhcnRBbmdsZSxcbiAgICBlbmRBbmdsZSxcbiAgICBoaWdobGlnaHRTdHlsZSxcbiAgICBzZWdtZW50YXRpb24sXG4gICAgYmFyLFxuICAgIG5lZWRsZSxcbiAgICB0YXJnZXRzLFxuICAgIG91dGVyUmFkaXVzLFxuICAgIGlubmVyUmFkaXVzLFxuICAgIG91dGVyUmFkaXVzUmF0aW8sXG4gICAgaW5uZXJSYWRpdXNSYXRpbyxcbiAgICBjb3JuZXJSYWRpdXMsXG4gICAgY29ybmVyTW9kZSxcbiAgICBsYWJlbCxcbiAgICBzZWNvbmRhcnlMYWJlbCxcbiAgICBzcGFjaW5nLFxuICAgIC4uLnJlc3RcbiAgfSA9IG9wdHM7XG4gIGFzc2VydEVtcHR5KHJlc3QpO1xuICBjb25zdCB7XG4gICAgZmlsbHM6IHNjYWxlRmlsbHMsXG4gICAgZmlsbE1vZGU6IHNjYWxlRmlsbE1vZGUsXG4gICAgZmlsbDogc2NhbGVGaWxsLFxuICAgIGZpbGxPcGFjaXR5OiBzY2FsZUZpbGxPcGFjaXR5LFxuICAgIHN0cm9rZTogc2NhbGVTdHJva2UsXG4gICAgc3Ryb2tlV2lkdGg6IHNjYWxlU3Ryb2tlV2lkdGgsXG4gICAgc3Ryb2tlT3BhY2l0eTogc2NhbGVTdHJva2VPcGFjaXR5LFxuICAgIGxpbmVEYXNoOiBzY2FsZUxpbmVEYXNoLFxuICAgIGxpbmVEYXNoT2Zmc2V0OiBzY2FsZUxpbmVEYXNoT2Zmc2V0LFxuICAgIG1pbjogc2NhbGVNaW4gPSAwLFxuICAgIG1heDogc2NhbGVNYXggPSAxLFxuICAgIGludGVydmFsOiBzY2FsZUludGVydmFsID0ge30sXG4gICAgbGFiZWw6IHNjYWxlTGFiZWwgPSB7fSxcbiAgICAuLi5zY2FsZVJlc3RcbiAgfSA9IHNjYWxlMjtcbiAgYXNzZXJ0RW1wdHkoc2NhbGVSZXN0KTtcbiAgY29uc3QgY2hhcnRPcHRzID0gcGlja1Byb3BzKG9wdHMsIHtcbiAgICBhbmltYXRpb24sXG4gICAgYmFja2dyb3VuZCxcbiAgICBjb250YWluZXIsXG4gICAgY29udGV4dE1lbnUsXG4gICAgZm9vdG5vdGUsXG4gICAgaGVpZ2h0OiBoZWlnaHQyLFxuICAgIGxpc3RlbmVycyxcbiAgICBsb2NhbGUsXG4gICAgbWluSGVpZ2h0LFxuICAgIG1pbldpZHRoLFxuICAgIHBhZGRpbmcsXG4gICAgc3VidGl0bGUsXG4gICAgdGhlbWUsXG4gICAgdGl0bGUsXG4gICAgd2lkdGg6IHdpZHRoMlxuICB9KTtcbiAgY29uc3Qgc2NhbGVPcHRzID0gcGlja1Byb3BzKHNjYWxlMiwge1xuICAgIGZpbGxzOiBzY2FsZUZpbGxzLFxuICAgIGZpbGxNb2RlOiBzY2FsZUZpbGxNb2RlLFxuICAgIGZpbGw6IHNjYWxlRmlsbCxcbiAgICBmaWxsT3BhY2l0eTogc2NhbGVGaWxsT3BhY2l0eSxcbiAgICBzdHJva2U6IHNjYWxlU3Ryb2tlLFxuICAgIHN0cm9rZVdpZHRoOiBzY2FsZVN0cm9rZVdpZHRoLFxuICAgIHN0cm9rZU9wYWNpdHk6IHNjYWxlU3Ryb2tlT3BhY2l0eSxcbiAgICBsaW5lRGFzaDogc2NhbGVMaW5lRGFzaCxcbiAgICBsaW5lRGFzaE9mZnNldDogc2NhbGVMaW5lRGFzaE9mZnNldFxuICB9KTtcbiAgY29uc3Qgc2VyaWVzT3B0cyA9IHBpY2tQcm9wcyhvcHRzLCB7XG4gICAgc3RhcnRBbmdsZTogSUdOT1JFRF9QUk9QLFxuICAgIGVuZEFuZ2xlOiBJR05PUkVEX1BST1AsXG4gICAgbmVlZGxlOiBuZWVkbGUgIT0gbnVsbCA/IHsgZW5hYmxlZDogdHJ1ZSwgLi4ubmVlZGxlIH0gOiBJR05PUkVEX1BST1AsXG4gICAgc2NhbGU6IHNjYWxlT3B0cyxcbiAgICB0eXBlLFxuICAgIGN1cnNvcixcbiAgICBub2RlQ2xpY2tSYW5nZSxcbiAgICBsaXN0ZW5lcnMsXG4gICAgdG9vbHRpcCxcbiAgICB2YWx1ZSxcbiAgICBoaWdobGlnaHRTdHlsZSxcbiAgICBzZWdtZW50YXRpb24sXG4gICAgYmFyLFxuICAgIHRhcmdldHMsXG4gICAgb3V0ZXJSYWRpdXMsXG4gICAgaW5uZXJSYWRpdXMsXG4gICAgb3V0ZXJSYWRpdXNSYXRpbyxcbiAgICBpbm5lclJhZGl1c1JhdGlvLFxuICAgIGNvcm5lclJhZGl1cyxcbiAgICBjb3JuZXJNb2RlLFxuICAgIGxhYmVsLFxuICAgIHNlY29uZGFyeUxhYmVsLFxuICAgIHNwYWNpbmcsXG4gICAgLi4ucmVzdFxuICB9KTtcbiAgY29uc3QgYXhlc09wdHMgPSBbXG4gICAge1xuICAgICAgdHlwZTogXCJhbmdsZS1udW1iZXJcIixcbiAgICAgIG1pbjogc2NhbGVNaW4sXG4gICAgICBtYXg6IHNjYWxlTWF4LFxuICAgICAgc3RhcnRBbmdsZSxcbiAgICAgIGVuZEFuZ2xlLFxuICAgICAgaW50ZXJ2YWw6IHNjYWxlSW50ZXJ2YWwgPz8ge30sXG4gICAgICBsYWJlbDogc2NhbGVMYWJlbCA/PyB7fVxuICAgIH0sXG4gICAgeyB0eXBlOiBcInJhZGl1cy1udW1iZXJcIiB9XG4gIF07XG4gIHJldHVybiB7XG4gICAgLi4uY2hhcnRPcHRzLFxuICAgIHNlcmllczogW3Nlcmllc09wdHNdLFxuICAgIGF4ZXM6IGF4ZXNPcHRzXG4gIH07XG59XG5mdW5jdGlvbiBsaW5lYXJHYXVnZU9wdGlvbnMob3B0cykge1xuICBjb25zdCB7XG4gICAgYW5pbWF0aW9uLFxuICAgIGJhY2tncm91bmQsXG4gICAgY29udGFpbmVyLFxuICAgIGNvbnRleHRNZW51LFxuICAgIGZvb3Rub3RlLFxuICAgIGhlaWdodDogaGVpZ2h0MixcbiAgICBsaXN0ZW5lcnMsXG4gICAgbG9jYWxlLFxuICAgIG1pbkhlaWdodCxcbiAgICBtaW5XaWR0aCxcbiAgICBwYWRkaW5nLFxuICAgIHN1YnRpdGxlLFxuICAgIHRoZW1lLFxuICAgIHRpdGxlLFxuICAgIHdpZHRoOiB3aWR0aDIsXG4gICAgdHlwZSxcbiAgICBjdXJzb3IsXG4gICAgbm9kZUNsaWNrUmFuZ2UsXG4gICAgdG9vbHRpcCxcbiAgICB2YWx1ZSxcbiAgICBzY2FsZTogc2NhbGUyID0ge30sXG4gICAgZGlyZWN0aW9uID0gXCJ2ZXJ0aWNhbFwiLFxuICAgIHRoaWNrbmVzcyxcbiAgICBoaWdobGlnaHRTdHlsZSxcbiAgICBzZWdtZW50YXRpb24sXG4gICAgYmFyLFxuICAgIHRhcmdldHMsXG4gICAgY29ybmVyUmFkaXVzLFxuICAgIGNvcm5lck1vZGUsXG4gICAgbGFiZWwsXG4gICAgLi4ucmVzdFxuICB9ID0gb3B0cztcbiAgYXNzZXJ0RW1wdHkocmVzdCk7XG4gIGNvbnN0IHtcbiAgICBmaWxsczogc2NhbGVGaWxscyxcbiAgICBmaWxsTW9kZTogc2NhbGVGaWxsTW9kZSxcbiAgICBmaWxsOiBzY2FsZUZpbGwsXG4gICAgZmlsbE9wYWNpdHk6IHNjYWxlRmlsbE9wYWNpdHksXG4gICAgc3Ryb2tlOiBzY2FsZVN0cm9rZSxcbiAgICBzdHJva2VXaWR0aDogc2NhbGVTdHJva2VXaWR0aCxcbiAgICBzdHJva2VPcGFjaXR5OiBzY2FsZVN0cm9rZU9wYWNpdHksXG4gICAgbGluZURhc2g6IHNjYWxlTGluZURhc2gsXG4gICAgbGluZURhc2hPZmZzZXQ6IHNjYWxlTGluZURhc2hPZmZzZXQsXG4gICAgbWluOiBzY2FsZU1pbiA9IDAsXG4gICAgbWF4OiBzY2FsZU1heCA9IDEsXG4gICAgaW50ZXJ2YWw6IHNjYWxlSW50ZXJ2YWwgPSB7fSxcbiAgICBsYWJlbDogc2NhbGVMYWJlbCA9IHt9LFxuICAgIC4uLnNjYWxlUmVzdFxuICB9ID0gc2NhbGUyO1xuICBhc3NlcnRFbXB0eShzY2FsZVJlc3QpO1xuICBjb25zdCBjaGFydE9wdHMgPSBwaWNrUHJvcHMob3B0cywge1xuICAgIGFuaW1hdGlvbixcbiAgICBiYWNrZ3JvdW5kLFxuICAgIGNvbnRhaW5lcixcbiAgICBjb250ZXh0TWVudSxcbiAgICBmb290bm90ZSxcbiAgICBoZWlnaHQ6IGhlaWdodDIsXG4gICAgbGlzdGVuZXJzLFxuICAgIGxvY2FsZSxcbiAgICBtaW5IZWlnaHQsXG4gICAgbWluV2lkdGgsXG4gICAgcGFkZGluZyxcbiAgICBzdWJ0aXRsZSxcbiAgICB0aGVtZSxcbiAgICB0aXRsZSxcbiAgICB3aWR0aDogd2lkdGgyXG4gIH0pO1xuICBjb25zdCBzY2FsZU9wdHMgPSBwaWNrUHJvcHMoc2NhbGUyLCB7XG4gICAgZmlsbHM6IHNjYWxlRmlsbHMsXG4gICAgZmlsbE1vZGU6IHNjYWxlRmlsbE1vZGUsXG4gICAgZmlsbDogc2NhbGVGaWxsLFxuICAgIGZpbGxPcGFjaXR5OiBzY2FsZUZpbGxPcGFjaXR5LFxuICAgIHN0cm9rZTogc2NhbGVTdHJva2UsXG4gICAgc3Ryb2tlV2lkdGg6IHNjYWxlU3Ryb2tlV2lkdGgsXG4gICAgc3Ryb2tlT3BhY2l0eTogc2NhbGVTdHJva2VPcGFjaXR5LFxuICAgIGxpbmVEYXNoOiBzY2FsZUxpbmVEYXNoLFxuICAgIGxpbmVEYXNoT2Zmc2V0OiBzY2FsZUxpbmVEYXNoT2Zmc2V0XG4gIH0pO1xuICBjb25zdCBzZXJpZXNPcHRzID0gcGlja1Byb3BzKG9wdHMsIHtcbiAgICBzY2FsZTogc2NhbGVPcHRzLFxuICAgIHR5cGUsXG4gICAgY3Vyc29yLFxuICAgIG5vZGVDbGlja1JhbmdlLFxuICAgIGxpc3RlbmVycyxcbiAgICB0b29sdGlwLFxuICAgIHZhbHVlLFxuICAgIGRpcmVjdGlvbixcbiAgICB0aGlja25lc3MsXG4gICAgaGlnaGxpZ2h0U3R5bGUsXG4gICAgc2VnbWVudGF0aW9uLFxuICAgIGJhcixcbiAgICB0YXJnZXRzLFxuICAgIGNvcm5lclJhZGl1cyxcbiAgICBjb3JuZXJNb2RlLFxuICAgIGxhYmVsLFxuICAgIC4uLnJlc3RcbiAgfSk7XG4gIGNvbnN0IHsgcGxhY2VtZW50OiBsYWJlbFBsYWNlbWVudCwgLi4uYXhpc0xhYmVsIH0gPSBzY2FsZUxhYmVsO1xuICBsZXQgbWFpbkF4aXNQb3NpdGlvbjtcbiAgbGV0IGNyb3NzQXhpc1Bvc2l0aW9uO1xuICBjb25zdCBob3Jpem9udGFsID0gZGlyZWN0aW9uID09PSBcImhvcml6b250YWxcIjtcbiAgaWYgKGhvcml6b250YWwpIHtcbiAgICBtYWluQXhpc1Bvc2l0aW9uID0gbGFiZWxQbGFjZW1lbnQgPT09IFwiYmVmb3JlXCIgPyBcInRvcFwiIDogXCJib3R0b21cIjtcbiAgICBjcm9zc0F4aXNQb3NpdGlvbiA9IFwibGVmdFwiO1xuICB9IGVsc2Uge1xuICAgIG1haW5BeGlzUG9zaXRpb24gPSBsYWJlbFBsYWNlbWVudCA9PT0gXCJhZnRlclwiID8gXCJyaWdodFwiIDogXCJsZWZ0XCI7XG4gICAgY3Jvc3NBeGlzUG9zaXRpb24gPSBcImJvdHRvbVwiO1xuICB9XG4gIGNvbnN0IG1haW5BeGlzID0ge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgcG9zaXRpb246IG1haW5BeGlzUG9zaXRpb24sXG4gICAgbWluOiBzY2FsZU1pbixcbiAgICBtYXg6IHNjYWxlTWF4LFxuICAgIHJldmVyc2U6ICFob3Jpem9udGFsLFxuICAgIGludGVydmFsOiBzY2FsZUludGVydmFsLFxuICAgIGxhYmVsOiBheGlzTGFiZWwsXG4gICAgbmljZTogZmFsc2VcbiAgfTtcbiAgY29uc3QgY3Jvc3NBeGlzID0ge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgcG9zaXRpb246IGNyb3NzQXhpc1Bvc2l0aW9uLFxuICAgIG1pbjogMCxcbiAgICBtYXg6IDEsXG4gICAgbGFiZWw6IHtcbiAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgfVxuICB9O1xuICBjb25zdCBheGVzT3B0cyA9IGhvcml6b250YWwgPyBbbWFpbkF4aXMsIGNyb3NzQXhpc10gOiBbY3Jvc3NBeGlzLCBtYWluQXhpc107XG4gIHJldHVybiB7XG4gICAgLi4uY2hhcnRPcHRzLFxuICAgIHNlcmllczogW3Nlcmllc09wdHNdLFxuICAgIGF4ZXM6IGF4ZXNPcHRzXG4gIH07XG59XG5mdW5jdGlvbiBhcHBseVRoZW1lRGVmYXVsdHMob3B0cywgcHJlc2V0VGhlbWUpIHtcbiAgaWYgKHByZXNldFRoZW1lID09IG51bGwpXG4gICAgcmV0dXJuIG9wdHM7XG4gIGNvbnN0IHsgdGFyZ2V0czogdGFyZ2V0c1RoZW1lLCAuLi5nYXVnZVRoZW1lIH0gPSBwcmVzZXRUaGVtZTtcbiAgb3B0cyA9IG1lcmdlRGVmYXVsdHMob3B0cywgZ2F1Z2VUaGVtZSk7XG4gIGlmIChvcHRzLnRhcmdldHMgIT0gbnVsbCAmJiB0YXJnZXRzVGhlbWUgIT0gbnVsbCkge1xuICAgIG9wdHMudGFyZ2V0cyA9IG1lcmdlQXJyYXlEZWZhdWx0cyhvcHRzLnRhcmdldHMsIHRhcmdldHNUaGVtZSk7XG4gIH1cbiAgcmV0dXJuIG9wdHM7XG59XG5mdW5jdGlvbiBnYXVnZShvcHRzLCBwcmVzZXRUaGVtZSkge1xuICBpZiAoaXNSYWRpYWxHYXVnZShvcHRzKSkge1xuICAgIGNvbnN0IHJhZGlhbEdhdWdlT3B0cyA9IGFwcGx5VGhlbWVEZWZhdWx0cyhvcHRzLCBwcmVzZXRUaGVtZSk7XG4gICAgcmV0dXJuIHJhZGlhbEdhdWdlT3B0aW9ucyhyYWRpYWxHYXVnZU9wdHMpO1xuICB9IGVsc2UgaWYgKGlzTGluZWFyR2F1Z2Uob3B0cykpIHtcbiAgICBjb25zdCBsaW5lYXJHYXVnZU9wdHMgPSBhcHBseVRoZW1lRGVmYXVsdHMob3B0cywgcHJlc2V0VGhlbWUpO1xuICAgIHJldHVybiBsaW5lYXJHYXVnZU9wdGlvbnMobGluZWFyR2F1Z2VPcHRzKTtcbiAgfVxuICBjb25zdCB7XG4gICAgYW5pbWF0aW9uLFxuICAgIGJhY2tncm91bmQsXG4gICAgY29udGFpbmVyLFxuICAgIGNvbnRleHRNZW51LFxuICAgIGZvb3Rub3RlLFxuICAgIGhlaWdodDogaGVpZ2h0MixcbiAgICBsaXN0ZW5lcnMsXG4gICAgbG9jYWxlLFxuICAgIG1pbkhlaWdodCxcbiAgICBtaW5XaWR0aCxcbiAgICBwYWRkaW5nLFxuICAgIHN1YnRpdGxlLFxuICAgIHRoZW1lLFxuICAgIHRpdGxlLFxuICAgIHdpZHRoOiB3aWR0aDJcbiAgfSA9IG9wdHM7XG4gIHJldHVybiBwaWNrUHJvcHMob3B0cywge1xuICAgIGFuaW1hdGlvbixcbiAgICBiYWNrZ3JvdW5kLFxuICAgIGNvbnRhaW5lcixcbiAgICBjb250ZXh0TWVudSxcbiAgICBmb290bm90ZSxcbiAgICBoZWlnaHQ6IGhlaWdodDIsXG4gICAgbGlzdGVuZXJzLFxuICAgIGxvY2FsZSxcbiAgICBtaW5IZWlnaHQsXG4gICAgbWluV2lkdGgsXG4gICAgcGFkZGluZyxcbiAgICBzdWJ0aXRsZSxcbiAgICB0aGVtZSxcbiAgICB0aXRsZSxcbiAgICB3aWR0aDogd2lkdGgyXG4gIH0pO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9hcGkvcHJlc2V0L3ByaWNlVm9sdW1lUHJlc2V0LnRzXG5mdW5jdGlvbiBmcm9tVGhlbWUodGhlbWUsIGNiKSB7XG4gIGlmIChpc09iamVjdCh0aGVtZSkpIHtcbiAgICByZXR1cm4gY2IodGhlbWUpO1xuICB9XG59XG52YXIgY2hhcnRUeXBlczIgPSBbXCJvaGxjXCIsIFwibGluZVwiLCBcInN0ZXAtbGluZVwiLCBcImhsY1wiLCBcImhpZ2gtbG93XCIsIFwiY2FuZGxlc3RpY2tcIiwgXCJob2xsb3ctY2FuZGxlc3RpY2tcIl07XG5mdW5jdGlvbiBwcmljZVZvbHVtZShvcHRzLCBfcHJlc2V0VGhlbWUsIGdldFRoZW1lKSB7XG4gIGNvbnN0IHtcbiAgICB4S2V5LFxuICAgIGRhdGVLZXkgPSB4S2V5ID8/IFwiZGF0ZVwiLFxuICAgIGhpZ2hLZXkgPSBcImhpZ2hcIixcbiAgICBvcGVuS2V5ID0gXCJvcGVuXCIsXG4gICAgbG93S2V5ID0gXCJsb3dcIixcbiAgICBjbG9zZUtleSA9IFwiY2xvc2VcIixcbiAgICB2b2x1bWVLZXkgPSBcInZvbHVtZVwiLFxuICAgIGNoYXJ0VHlwZTogY2hhcnRUeXBlMiA9IFwiY2FuZGxlc3RpY2tcIixcbiAgICBuYXZpZ2F0b3I6IG5hdmlnYXRvcjIgPSBmYWxzZSxcbiAgICB2b2x1bWUgPSB0cnVlLFxuICAgIHJhbmdlVG9vbGJhcixcbiAgICByYW5nZUJ1dHRvbnMgPSByYW5nZVRvb2xiYXIgPz8gdHJ1ZSxcbiAgICBzdGF0dXNCYXIgPSB0cnVlLFxuICAgIGFubm90YXRpb25zOiBhbm5vdGF0aW9uczIsXG4gICAgdG9vbGJhciA9IGFubm90YXRpb25zMiA/PyB0cnVlLFxuICAgIHpvb206IHpvb20yID0gdHJ1ZSxcbiAgICB0aGVtZSxcbiAgICBkYXRhLFxuICAgIC4uLnVudXNlZE9wdHNcbiAgfSA9IG9wdHM7XG4gIGlmICh4S2V5ICE9IG51bGwpIHtcbiAgICBMb2dnZXIud2Fybk9uY2UoXCJQcm9wZXJ0eSBbeEtleV0gaXMgZGVwcmVjYXRlZCwgdXNlIFtkYXRlS2V5XSBpbnN0ZWFkLlwiKTtcbiAgfVxuICBpZiAocmFuZ2VUb29sYmFyICE9IG51bGwpIHtcbiAgICBMb2dnZXIud2Fybk9uY2UoXCJQcm9wZXJ0eSBbcmFuZ2VUb29sYmFyXSBpcyBkZXByZWNhdGVkLCB1c2UgW3JhbmdlQnV0dG9uc10gaW5zdGVhZC5cIik7XG4gIH1cbiAgaWYgKGFubm90YXRpb25zMiAhPSBudWxsKSB7XG4gICAgTG9nZ2VyLndhcm5PbmNlKFwiUHJvcGVydHkgW2Fubm90YXRpb25zXSBpcyBkZXByZWNhdGVkLCB1c2UgW3Rvb2xiYXJdIGluc3RlYWQuXCIpO1xuICB9XG4gIGNvbnN0IHByaWNlU2VyaWVzID0gY3JlYXRlUHJpY2VTZXJpZXModGhlbWUsIGNoYXJ0VHlwZTIsIGRhdGVLZXksIGhpZ2hLZXksIGxvd0tleSwgb3BlbktleSwgY2xvc2VLZXkpO1xuICBjb25zdCB2b2x1bWVTZXJpZXMgPSBjcmVhdGVWb2x1bWVTZXJpZXModGhlbWUsIGdldFRoZW1lLCBvcGVuS2V5LCBjbG9zZUtleSwgdm9sdW1lLCB2b2x1bWVLZXkpO1xuICBjb25zdCBtaW5pQ2hhcnQgPSB2b2x1bWUgPyB7XG4gICAgbWluaUNoYXJ0OiB7XG4gICAgICBlbmFibGVkOiBuYXZpZ2F0b3IyLFxuICAgICAgc2VyaWVzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcImxpbmVcIixcbiAgICAgICAgICB4S2V5OiBkYXRlS2V5LFxuICAgICAgICAgIHlLZXk6IHZvbHVtZUtleSxcbiAgICAgICAgICBtYXJrZXI6IHsgZW5hYmxlZDogZmFsc2UgfVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfVxuICB9IDogbnVsbDtcbiAgY29uc3QgbmF2aWdhdG9yT3B0cyA9IHtcbiAgICBuYXZpZ2F0b3I6IHtcbiAgICAgIGVuYWJsZWQ6IG5hdmlnYXRvcjIsXG4gICAgICAuLi5taW5pQ2hhcnRcbiAgICB9XG4gIH07XG4gIGNvbnN0IGFubm90YXRpb25PcHRzID0ge1xuICAgIGFubm90YXRpb25zOiB7XG4gICAgICBlbmFibGVkOiB0b29sYmFyLFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgZGF0YSxcbiAgICAgIHhLZXk6IGRhdGVLZXksXG4gICAgICB2b2x1bWVLZXk6IHZvbHVtZSA/IHZvbHVtZUtleSA6IHZvaWQgMFxuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3RhdHVzQmFyT3B0cyA9IHN0YXR1c0JhciA/IHtcbiAgICBzdGF0dXNCYXI6IHtcbiAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICBkYXRhLFxuICAgICAgaGlnaEtleSxcbiAgICAgIG9wZW5LZXksXG4gICAgICBsb3dLZXksXG4gICAgICBjbG9zZUtleSxcbiAgICAgIHZvbHVtZUtleTogdm9sdW1lID8gdm9sdW1lS2V5IDogdm9pZCAwXG4gICAgfVxuICB9IDogbnVsbDtcbiAgY29uc3Qgem9vbU9wdHMgPSB7XG4gICAgem9vbToge1xuICAgICAgZW5hYmxlZDogem9vbTIsXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICBlbmFibGVJbmRlcGVuZGVudEF4ZXM6IHRydWVcbiAgICB9XG4gIH07XG4gIGNvbnN0IHRvb2xiYXJPcHRzID0ge1xuICAgIGNoYXJ0VG9vbGJhcjogeyBlbmFibGVkOiB0cnVlIH0sXG4gICAgdG9vbGJhcjoge1xuICAgICAgc2VyaWVzVHlwZToge1xuICAgICAgICBlbmFibGVkOiB0b29sYmFyXG4gICAgICB9LFxuICAgICAgYW5ub3RhdGlvbk9wdGlvbnM6IHtcbiAgICAgICAgZW5hYmxlZDogdG9vbGJhclxuICAgICAgfSxcbiAgICAgIGFubm90YXRpb25zOiB7XG4gICAgICAgIGVuYWJsZWQ6IHRvb2xiYXJcbiAgICAgIH0sXG4gICAgICByYW5nZXM6IHtcbiAgICAgICAgZW5hYmxlZDogcmFuZ2VCdXR0b25zXG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCB2b2x1bWVBeGlzID0gdm9sdW1lID8gW1xuICAgIHtcbiAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICBwb3NpdGlvbjogXCJsZWZ0XCIsXG4gICAgICBrZXlzOiBbdm9sdW1lS2V5XSxcbiAgICAgIGxhYmVsOiB7IGVuYWJsZWQ6IGZhbHNlIH0sXG4gICAgICBjcm9zc2hhaXI6IHsgZW5hYmxlZDogZmFsc2UgfSxcbiAgICAgIGdyaWRMaW5lOiB7IGVuYWJsZWQ6IGZhbHNlIH0sXG4gICAgICBuaWNlOiBmYWxzZSxcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgIGxheW91dENvbnN0cmFpbnRzOiB7XG4gICAgICAgIHN0YWNrZWQ6IGZhbHNlLFxuICAgICAgICB3aWR0aDogMjAsXG4gICAgICAgIHVuaXQ6IFwicGVyY2VudGFnZVwiLFxuICAgICAgICBhbGlnbjogXCJlbmRcIlxuICAgICAgfVxuICAgIH1cbiAgXSA6IFtdO1xuICByZXR1cm4ge1xuICAgIHRoZW1lOiB7XG4gICAgICBiYXNlVGhlbWU6IHR5cGVvZiB0aGVtZSA9PT0gXCJzdHJpbmdcIiA/IHRoZW1lIDogXCJhZy1maW5hbmNpYWxcIixcbiAgICAgIC4uLm1lcmdlRGVmYXVsdHModHlwZW9mIHRoZW1lID09PSBcIm9iamVjdFwiID8gdGhlbWUgOiBudWxsLCB7XG4gICAgICAgIG92ZXJyaWRlczoge1xuICAgICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgdGl0bGU6IHsgcGFkZGluZzogNCB9LFxuICAgICAgICAgICAgcGFkZGluZzoge1xuICAgICAgICAgICAgICB0b3A6IDYsXG4gICAgICAgICAgICAgIHJpZ2h0OiA4LFxuICAgICAgICAgICAgICBib3R0b206IDVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSxcbiAgICBhbmltYXRpb246IHsgZW5hYmxlZDogZmFsc2UgfSxcbiAgICBsZWdlbmQ6IHsgZW5hYmxlZDogZmFsc2UgfSxcbiAgICBzZXJpZXM6IFsuLi52b2x1bWVTZXJpZXMsIC4uLnByaWNlU2VyaWVzXSxcbiAgICBheGVzOiBbXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgIHBvc2l0aW9uOiBcInJpZ2h0XCIsXG4gICAgICAgIGtleXM6IFtvcGVuS2V5LCBjbG9zZUtleSwgaGlnaEtleSwgbG93S2V5XSxcbiAgICAgICAgaW50ZXJ2YWw6IHtcbiAgICAgICAgICBtYXhTcGFjaW5nOiBmcm9tVGhlbWUodGhlbWUsICh0KSA9PiB0Lm92ZXJyaWRlcz8uY29tbW9uPy5heGVzPy5udW1iZXI/LmludGVydmFsPy5tYXhTcGFjaW5nKSA/PyA0NVxuICAgICAgICB9LFxuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgIGZvcm1hdDogZnJvbVRoZW1lKHRoZW1lLCAodCkgPT4gdC5vdmVycmlkZXM/LmNvbW1vbj8uYXhlcz8ubnVtYmVyPy5sYWJlbD8uZm9ybWF0KSA/PyBcIi4yZlwiXG4gICAgICAgIH0sXG4gICAgICAgIGNyb3NzaGFpcjoge1xuICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgc25hcDogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBsYXlvdXRDb25zdHJhaW50czoge1xuICAgICAgICAgIHN0YWNrZWQ6IGZhbHNlLFxuICAgICAgICAgIHdpZHRoOiAxMDAsXG4gICAgICAgICAgdW5pdDogXCJwZXJjZW50YWdlXCIsXG4gICAgICAgICAgYWxpZ246IFwic3RhcnRcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLi4udm9sdW1lQXhpcyxcbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJvcmRpbmFsLXRpbWVcIixcbiAgICAgICAgcG9zaXRpb246IFwiYm90dG9tXCIsXG4gICAgICAgIGxpbmU6IHtcbiAgICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgIGVuYWJsZWQ6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgY3Jvc3NoYWlyOiB7XG4gICAgICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgXSxcbiAgICB0b29sdGlwOiB7IGVuYWJsZWQ6IGZhbHNlIH0sXG4gICAgZGF0YSxcbiAgICAuLi5hbm5vdGF0aW9uT3B0cyxcbiAgICAuLi5uYXZpZ2F0b3JPcHRzLFxuICAgIC4uLnN0YXR1c0Jhck9wdHMsXG4gICAgLi4uem9vbU9wdHMsXG4gICAgLi4udG9vbGJhck9wdHMsXG4gICAgLi4udW51c2VkT3B0c1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlVm9sdW1lU2VyaWVzKHRoZW1lLCBnZXRUaGVtZSwgb3BlbktleSwgY2xvc2VLZXksIHZvbHVtZSwgdm9sdW1lS2V5KSB7XG4gIGlmICghdm9sdW1lKVxuICAgIHJldHVybiBbXTtcbiAgY29uc3QgYmFyU2VyaWVzRmlsbCA9IGZyb21UaGVtZSh0aGVtZSwgKHQpID0+IHQub3ZlcnJpZGVzPy5iYXI/LnNlcmllcz8uZmlsbCk7XG4gIGNvbnN0IGl0ZW1TdHlsZXIgPSBiYXJTZXJpZXNGaWxsID8geyBmaWxsOiBiYXJTZXJpZXNGaWxsIH0gOiB7XG4gICAgaXRlbVN0eWxlcih7IGRhdHVtIH0pIHtcbiAgICAgIGNvbnN0IHsgdXAsIGRvd24gfSA9IGdldFRoZW1lKCkucGFsZXR0ZTtcbiAgICAgIHJldHVybiB7IGZpbGw6IGRhdHVtW29wZW5LZXldIDwgZGF0dW1bY2xvc2VLZXldID8gdXA/LmZpbGwgOiBkb3duPy5maWxsIH07XG4gICAgfVxuICB9O1xuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIHR5cGU6IFwiYmFyXCIsXG4gICAgICB4S2V5OiBcImRhdGVcIixcbiAgICAgIHlLZXk6IHZvbHVtZUtleSxcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgIGZvY3VzUHJpb3JpdHk6IDEsXG4gICAgICB0b29sdGlwOiB7IGVuYWJsZWQ6IGZhbHNlIH0sXG4gICAgICBoaWdobGlnaHQ6IHsgZW5hYmxlZDogZmFsc2UgfSxcbiAgICAgIGZpbGxPcGFjaXR5OiBmcm9tVGhlbWUodGhlbWUsICh0KSA9PiB0Lm92ZXJyaWRlcz8uYmFyPy5zZXJpZXM/LmZpbGxPcGFjaXR5KSA/PyAwLjUsXG4gICAgICAuLi5pdGVtU3R5bGVyXG4gICAgfVxuICBdO1xufVxudmFyIFJBTkdFX0FSRUFfVFlQRSA9IFwicmFuZ2UtYXJlYVwiO1xuZnVuY3Rpb24gY3JlYXRlUHJpY2VTZXJpZXModGhlbWUsIGNoYXJ0VHlwZTIsIHhLZXksIGhpZ2hLZXksIGxvd0tleSwgb3BlbktleSwgY2xvc2VLZXkpIHtcbiAgaWYgKGNoYXJ0VHlwZTIgPT09IFJBTkdFX0FSRUFfVFlQRSkge1xuICAgIExvZ2dlci53YXJuT25jZShgdHlwZSAnJHtjaGFydFR5cGUyfScgaXMgZGVwcmVjYXRlZCwgdXNlICdobGMnIGNoYXJ0IHR5cGUgaW5zdGVhZGApO1xuICAgIGNoYXJ0VHlwZTIgPSBcImhsY1wiO1xuICB9XG4gIGNvbnN0IGtleXMgPSB7XG4gICAgeEtleSxcbiAgICBvcGVuS2V5LFxuICAgIGNsb3NlS2V5LFxuICAgIGhpZ2hLZXksXG4gICAgbG93S2V5XG4gIH07XG4gIGNvbnN0IHNpbmdsZUtleXMgPSB7XG4gICAgeEtleSxcbiAgICB5S2V5OiBjbG9zZUtleVxuICB9O1xuICBjb25zdCBjb21tb24gPSB7XG4gICAgcGlja091dHNpZGVWaXNpYmxlTWlub3JBeGlzOiB0cnVlXG4gIH07XG4gIHN3aXRjaCAoY2hhcnRUeXBlMiA/PyBcImNhbmRsZXN0aWNrXCIpIHtcbiAgICBjYXNlIFwib2hsY1wiOlxuICAgICAgcmV0dXJuIFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwib2hsY1wiLFxuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICBmb2N1c1ByaW9yaXR5OiAwLFxuICAgICAgICAgIC4uLmNvbW1vbixcbiAgICAgICAgICAuLi5rZXlzXG4gICAgICAgIH1cbiAgICAgIF07XG4gICAgY2FzZSBcImxpbmVcIjpcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcImxpbmVcIixcbiAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgZm9jdXNQcmlvcml0eTogMCxcbiAgICAgICAgICAuLi5jb21tb24sXG4gICAgICAgICAgLi4uc2luZ2xlS2V5cyxcbiAgICAgICAgICBzdHJva2U6IGZyb21UaGVtZSh0aGVtZSwgKHQpID0+IHQub3ZlcnJpZGVzPy5saW5lPy5zZXJpZXM/LnN0cm9rZSkgPz8gUEFMRVRURV9ORVVUUkFMX1NUUk9LRSxcbiAgICAgICAgICBtYXJrZXI6IGZyb21UaGVtZSh0aGVtZSwgKHQpID0+IHQub3ZlcnJpZGVzPy5saW5lPy5zZXJpZXM/Lm1hcmtlcikgPz8geyBlbmFibGVkOiBmYWxzZSB9XG4gICAgICAgIH1cbiAgICAgIF07XG4gICAgY2FzZSBcInN0ZXAtbGluZVwiOlxuICAgICAgcmV0dXJuIFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwibGluZVwiLFxuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICBmb2N1c1ByaW9yaXR5OiAwLFxuICAgICAgICAgIC4uLmNvbW1vbixcbiAgICAgICAgICAuLi5zaW5nbGVLZXlzLFxuICAgICAgICAgIHN0cm9rZTogZnJvbVRoZW1lKHRoZW1lLCAodCkgPT4gdC5vdmVycmlkZXM/LmxpbmU/LnNlcmllcz8uc3Ryb2tlKSA/PyBQQUxFVFRFX05FVVRSQUxfU1RST0tFLFxuICAgICAgICAgIGludGVycG9sYXRpb246IGZyb21UaGVtZSh0aGVtZSwgKHQpID0+IHQub3ZlcnJpZGVzPy5saW5lPy5zZXJpZXM/LmludGVycG9sYXRpb24pID8/IHtcbiAgICAgICAgICAgIHR5cGU6IFwic3RlcFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBtYXJrZXI6IGZyb21UaGVtZSh0aGVtZSwgKHQpID0+IHQub3ZlcnJpZGVzPy5saW5lPy5zZXJpZXM/Lm1hcmtlcikgPz8geyBlbmFibGVkOiBmYWxzZSB9XG4gICAgICAgIH1cbiAgICAgIF07XG4gICAgY2FzZSBcImhsY1wiOiB7XG4gICAgICBjb25zdCByYW5nZUFyZWFDb2xvcnMgPSBnZXRUaGVtZUNvbG9ycyhSQU5HRV9BUkVBX1RZUEUsIHRoZW1lKTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBSQU5HRV9BUkVBX1RZUEUsXG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgIGZvY3VzUHJpb3JpdHk6IDAsXG4gICAgICAgICAgLi4uY29tbW9uLFxuICAgICAgICAgIHhLZXksXG4gICAgICAgICAgeUhpZ2hLZXk6IGhpZ2hLZXksXG4gICAgICAgICAgeUxvd0tleTogY2xvc2VLZXksXG4gICAgICAgICAgZmlsbDogcmFuZ2VBcmVhQ29sb3JzLmZpbGwgPz8gUEFMRVRURV9VUF9GSUxMLFxuICAgICAgICAgIHN0cm9rZTogcmFuZ2VBcmVhQ29sb3JzLnN0cm9rZSA/PyBQQUxFVFRFX1VQX1NUUk9LRSxcbiAgICAgICAgICBmaWxsT3BhY2l0eTogZnJvbVRoZW1lKHRoZW1lLCAodCkgPT4gdC5vdmVycmlkZXM/LltcInJhbmdlLWFyZWFcIl0/LnNlcmllcz8uZmlsbE9wYWNpdHkpID8/IDAuMyxcbiAgICAgICAgICBzdHJva2VXaWR0aDogZnJvbVRoZW1lKHRoZW1lLCAodCkgPT4gdC5vdmVycmlkZXM/LltcInJhbmdlLWFyZWFcIl0/LnNlcmllcz8uc3Ryb2tlV2lkdGgpID8/IDJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFJBTkdFX0FSRUFfVFlQRSxcbiAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgZm9jdXNQcmlvcml0eTogMCxcbiAgICAgICAgICAuLi5jb21tb24sXG4gICAgICAgICAgeEtleSxcbiAgICAgICAgICB5SGlnaEtleTogY2xvc2VLZXksXG4gICAgICAgICAgeUxvd0tleTogbG93S2V5LFxuICAgICAgICAgIGZpbGw6IHJhbmdlQXJlYUNvbG9ycy5maWxsID8/IFBBTEVUVEVfRE9XTl9GSUxMLFxuICAgICAgICAgIHN0cm9rZTogcmFuZ2VBcmVhQ29sb3JzLnN0cm9rZSA/PyBQQUxFVFRFX0RPV05fU1RST0tFLFxuICAgICAgICAgIGZpbGxPcGFjaXR5OiBmcm9tVGhlbWUodGhlbWUsICh0KSA9PiB0Lm92ZXJyaWRlcz8uW1wicmFuZ2UtYXJlYVwiXT8uc2VyaWVzPy5maWxsT3BhY2l0eSkgPz8gMC4zLFxuICAgICAgICAgIHN0cm9rZVdpZHRoOiBmcm9tVGhlbWUodGhlbWUsICh0KSA9PiB0Lm92ZXJyaWRlcz8uW1wicmFuZ2UtYXJlYVwiXT8uc2VyaWVzPy5zdHJva2VXaWR0aCkgPz8gMlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogXCJsaW5lXCIsXG4gICAgICAgICAgLi4uY29tbW9uLFxuICAgICAgICAgIC4uLnNpbmdsZUtleXMsXG4gICAgICAgICAgc3Ryb2tlOiBmcm9tVGhlbWUodGhlbWUsICh0KSA9PiB0Lm92ZXJyaWRlcz8ubGluZT8uc2VyaWVzPy5zdHJva2UpID8/IFBBTEVUVEVfQUxUX05FVVRSQUxfU1RST0tFLFxuICAgICAgICAgIHN0cm9rZVdpZHRoOiBmcm9tVGhlbWUodGhlbWUsICh0KSA9PiB0Lm92ZXJyaWRlcz8ubGluZT8uc2VyaWVzPy5zdHJva2VXaWR0aCkgPz8gMixcbiAgICAgICAgICBtYXJrZXI6IGZyb21UaGVtZSh0aGVtZSwgKHQpID0+IHQub3ZlcnJpZGVzPy5saW5lPy5zZXJpZXM/Lm1hcmtlcikgPz8geyBlbmFibGVkOiBmYWxzZSB9XG4gICAgICAgIH1cbiAgICAgIF07XG4gICAgfVxuICAgIGNhc2UgXCJoaWdoLWxvd1wiOiB7XG4gICAgICBjb25zdCByYW5nZUJhckNvbG9ycyA9IGdldFRoZW1lQ29sb3JzKFwicmFuZ2UtYmFyXCIsIHRoZW1lKTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcInJhbmdlLWJhclwiLFxuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICBmb2N1c1ByaW9yaXR5OiAwLFxuICAgICAgICAgIC4uLmNvbW1vbixcbiAgICAgICAgICB4S2V5LFxuICAgICAgICAgIHlIaWdoS2V5OiBoaWdoS2V5LFxuICAgICAgICAgIHlMb3dLZXk6IGxvd0tleSxcbiAgICAgICAgICBmaWxsOiByYW5nZUJhckNvbG9ycy5maWxsID8/IFBBTEVUVEVfTkVVVFJBTF9GSUxMLFxuICAgICAgICAgIHN0cm9rZTogcmFuZ2VCYXJDb2xvcnMuc3Ryb2tlID8/IFBBTEVUVEVfTkVVVFJBTF9TVFJPS0UsXG4gICAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgICAgcmFuZ2U6IFwibmVhcmVzdFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBdO1xuICAgIH1cbiAgICBjYXNlIFwiY2FuZGxlc3RpY2tcIjpcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcImNhbmRsZXN0aWNrXCIsXG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgIGZvY3VzUHJpb3JpdHk6IDAsXG4gICAgICAgICAgLi4uY29tbW9uLFxuICAgICAgICAgIC4uLmtleXNcbiAgICAgICAgfVxuICAgICAgXTtcbiAgICBjYXNlIFwiaG9sbG93LWNhbmRsZXN0aWNrXCI6IHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBmcm9tVGhlbWUodGhlbWUsICh0KSA9PiB0Lm92ZXJyaWRlcz8uY2FuZGxlc3RpY2s/LnNlcmllcz8uaXRlbSk7XG4gICAgICByZXR1cm4gW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogXCJjYW5kbGVzdGlja1wiLFxuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICBmb2N1c1ByaW9yaXR5OiAwLFxuICAgICAgICAgIC4uLmNvbW1vbixcbiAgICAgICAgICAuLi5rZXlzLFxuICAgICAgICAgIGl0ZW06IHtcbiAgICAgICAgICAgIHVwOiB7XG4gICAgICAgICAgICAgIGZpbGw6IGl0ZW0/LnVwPy5maWxsID8/IFwidHJhbnNwYXJlbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgXTtcbiAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIExvZ2dlci53YXJuT25jZShgdW5rbm93biBjaGFydCB0eXBlOiAke2NoYXJ0VHlwZTJ9OyBleHBlY3RlZCBvbmUgb2Y6ICR7Y2hhcnRUeXBlczIuam9pbihcIiwgXCIpfWApO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwiY2FuZGxlc3RpY2tcIixcbiAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgZm9jdXNQcmlvcml0eTogMCxcbiAgICAgICAgICAuLi5jb21tb24sXG4gICAgICAgICAgLi4ua2V5c1xuICAgICAgICB9XG4gICAgICBdO1xuICB9XG59XG5mdW5jdGlvbiBnZXRUaGVtZUNvbG9ycyhzZXJpZXNUeXBlMiwgdGhlbWUpIHtcbiAgY29uc3QgZmlsbCA9IGZyb21UaGVtZSh0aGVtZSwgKHQpID0+IHQub3ZlcnJpZGVzPy5bc2VyaWVzVHlwZTJdPy5zZXJpZXM/LmZpbGwpO1xuICBjb25zdCBzdHJva2UgPSBmcm9tVGhlbWUodGhlbWUsICh0KSA9PiB0Lm92ZXJyaWRlcz8uW3Nlcmllc1R5cGUyXT8uc2VyaWVzPy5zdHJva2UpO1xuICByZXR1cm4geyBmaWxsLCBzdHJva2UgfTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvYXBpL3ByZXNldC9zcGFya2xpbmUudHNcbnZhciBjb21tb25BeGlzUHJvcGVydGllcyA9IHtcbiAgbGluZToge1xuICAgIGVuYWJsZWQ6IGZhbHNlXG4gIH0sXG4gIHRpdGxlOiB7XG4gICAgZW5hYmxlZDogZmFsc2VcbiAgfSxcbiAgbGFiZWw6IHtcbiAgICBlbmFibGVkOiBmYWxzZVxuICB9LFxuICBjcm9zc2hhaXI6IHtcbiAgICBlbmFibGVkOiBmYWxzZSxcbiAgICBzdHJva2VPcGFjaXR5OiAwLjI1LFxuICAgIGxpbmVEYXNoOiBbMF0sXG4gICAgbGFiZWw6IHtcbiAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgfVxuICB9XG59O1xudmFyIG51bWVyaWNBeGlzUHJvcGVydGllcyA9IHtcbiAgLi4uY29tbW9uQXhpc1Byb3BlcnRpZXMsXG4gIG5pY2U6IGZhbHNlXG59O1xudmFyIGJvdHRvbUNyb3NzSGFpckF4aXNQcm9wZXJ0aWVzID0ge1xuICBib3R0b206IHtcbiAgICBjcm9zc2hhaXI6IHtcbiAgICAgIGVuYWJsZWQ6IElTX0VOVEVSUFJJU0VcbiAgICB9XG4gIH1cbn07XG52YXIgY3Jvc3NIYWlyQXhlcyA9IHtcbiAgY2F0ZWdvcnk6IGJvdHRvbUNyb3NzSGFpckF4aXNQcm9wZXJ0aWVzLFxuICBudW1iZXI6IGJvdHRvbUNyb3NzSGFpckF4aXNQcm9wZXJ0aWVzLFxuICBsb2c6IGJvdHRvbUNyb3NzSGFpckF4aXNQcm9wZXJ0aWVzLFxuICB0aW1lOiBib3R0b21Dcm9zc0hhaXJBeGlzUHJvcGVydGllc1xufTtcbnZhciBjcm9zc0hhaXJUb29sdGlwID0ge1xuICBwb3NpdGlvbjoge1xuICAgIHR5cGU6IFwic3BhcmtsaW5lXCJcbiAgfVxufTtcbnZhciBTUEFSS0xJTkVfVEhFTUUgPSB7XG4gIG92ZXJyaWRlczoge1xuICAgIGNvbW1vbjoge1xuICAgICAgYW5pbWF0aW9uOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgcGFkZGluZzoge1xuICAgICAgICB0b3A6IDAsXG4gICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICBib3R0b206IDAsXG4gICAgICAgIGxlZnQ6IDBcbiAgICAgIH0sXG4gICAgICBheGVzOiB7XG4gICAgICAgIG51bWJlcjoge1xuICAgICAgICAgIC4uLm51bWVyaWNBeGlzUHJvcGVydGllcyxcbiAgICAgICAgICBpbnRlcnZhbDoge1xuICAgICAgICAgICAgdmFsdWVzOiBbMF1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGxvZzoge1xuICAgICAgICAgIC4uLm51bWVyaWNBeGlzUHJvcGVydGllc1xuICAgICAgICB9LFxuICAgICAgICB0aW1lOiB7XG4gICAgICAgICAgLi4ubnVtZXJpY0F4aXNQcm9wZXJ0aWVzXG4gICAgICAgIH0sXG4gICAgICAgIGNhdGVnb3J5OiB7XG4gICAgICAgICAgLi4uY29tbW9uQXhpc1Byb3BlcnRpZXMsXG4gICAgICAgICAgZ3JpZExpbmU6IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBiYXI6IHtcbiAgICAgIHNlcmllczoge1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIHNwYXJrbGluZU1vZGU6IHRydWVcbiAgICAgIH0sXG4gICAgICB0b29sdGlwOiB7XG4gICAgICAgIHJhbmdlOiBcIm5lYXJlc3RcIlxuICAgICAgfVxuICAgIH0sXG4gICAgbGluZToge1xuICAgICAgc2VyaWVzQXJlYToge1xuICAgICAgICBwYWRkaW5nOiB7XG4gICAgICAgICAgdG9wOiAyLFxuICAgICAgICAgIHJpZ2h0OiAyLFxuICAgICAgICAgIGJvdHRvbTogMixcbiAgICAgICAgICBsZWZ0OiAyXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBheGVzOiBjcm9zc0hhaXJBeGVzLFxuICAgICAgc2VyaWVzOiB7XG4gICAgICAgIHN0cm9rZVdpZHRoOiAxLFxuICAgICAgICBtYXJrZXI6IHtcbiAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICBzaXplOiAzXG4gICAgICAgIH0sXG4gICAgICAgIHRvb2x0aXA6IGNyb3NzSGFpclRvb2x0aXBcbiAgICAgIH1cbiAgICB9LFxuICAgIGFyZWE6IHtcbiAgICAgIHNlcmllc0FyZWE6IHtcbiAgICAgICAgcGFkZGluZzoge1xuICAgICAgICAgIHRvcDogMSxcbiAgICAgICAgICByaWdodDogMCxcbiAgICAgICAgICBib3R0b206IDEsXG4gICAgICAgICAgbGVmdDogMFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYXhlczogY3Jvc3NIYWlyQXhlcyxcbiAgICAgIHNlcmllczoge1xuICAgICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgICAgZmlsbE9wYWNpdHk6IDAuNCxcbiAgICAgICAgdG9vbHRpcDogY3Jvc3NIYWlyVG9vbHRpcFxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbmZ1bmN0aW9uIHNldEluaXRpYWxCYXNlVGhlbWUoYmFzZVRoZW1lLCBpbml0aWFsQmFzZVRoZW1lKSB7XG4gIGlmICh0eXBlb2YgYmFzZVRoZW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmluaXRpYWxCYXNlVGhlbWUsXG4gICAgICBiYXNlVGhlbWVcbiAgICB9O1xuICB9XG4gIGlmIChiYXNlVGhlbWUgIT0gbnVsbCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5iYXNlVGhlbWUsXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGludGVybmFsIGltcGxlbWVudGF0aW9uXG4gICAgICBiYXNlVGhlbWU6IHNldEluaXRpYWxCYXNlVGhlbWUoYmFzZVRoZW1lLmJhc2VUaGVtZSwgaW5pdGlhbEJhc2VUaGVtZSlcbiAgICB9O1xuICB9XG4gIHJldHVybiBpbml0aWFsQmFzZVRoZW1lO1xufVxuZnVuY3Rpb24gc3BhcmtsaW5lKG9wdHMpIHtcbiAgY29uc3Qge1xuICAgIGJhY2tncm91bmQsXG4gICAgY29udGFpbmVyLFxuICAgIGhlaWdodDogaGVpZ2h0MixcbiAgICBsaXN0ZW5lcnMsXG4gICAgbG9jYWxlLFxuICAgIG1pbkhlaWdodCxcbiAgICBtaW5XaWR0aCxcbiAgICBwYWRkaW5nLFxuICAgIHdpZHRoOiB3aWR0aDIsXG4gICAgdGhlbWU6IGJhc2VUaGVtZSxcbiAgICBkYXRhLFxuICAgIHhBeGlzLFxuICAgIHlBeGlzLFxuICAgIC4uLm9wdHNSZXN0XG4gIH0gPSBvcHRzO1xuICBhc3NlcnRFbXB0eShvcHRzUmVzdCk7XG4gIGNvbnN0IHNlcmllc09wdGlvbnMgPSBvcHRzUmVzdDtcbiAgY29uc3Qgc3dhcEF4ZXMgPSBzZXJpZXNPcHRpb25zLnR5cGUgIT09IFwiYmFyXCIgfHwgc2VyaWVzT3B0aW9ucy5kaXJlY3Rpb24gIT09IFwiaG9yaXpvbnRhbFwiO1xuICBjb25zdCBjaGFydE9wdHMgPSBwaWNrUHJvcHMob3B0cywge1xuICAgIGJhY2tncm91bmQsXG4gICAgY29udGFpbmVyLFxuICAgIGhlaWdodDogaGVpZ2h0MixcbiAgICBsaXN0ZW5lcnMsXG4gICAgbG9jYWxlLFxuICAgIG1pbkhlaWdodCxcbiAgICBtaW5XaWR0aCxcbiAgICBwYWRkaW5nLFxuICAgIHdpZHRoOiB3aWR0aDIsXG4gICAgZGF0YSxcbiAgICB4QXhpczogSUdOT1JFRF9QUk9QLFxuICAgIHlBeGlzOiBJR05PUkVEX1BST1AsXG4gICAgdGhlbWU6IElHTk9SRURfUFJPUFxuICB9KTtcbiAgY2hhcnRPcHRzLnRoZW1lID0gc2V0SW5pdGlhbEJhc2VUaGVtZShiYXNlVGhlbWUsIFNQQVJLTElORV9USEVNRSk7XG4gIGNoYXJ0T3B0cy5zZXJpZXMgPSBbc2VyaWVzT3B0aW9uc107XG4gIGNoYXJ0T3B0cy5heGVzID0gc3dhcEF4ZXMgPyBbXG4gICAgeyB0eXBlOiBcIm51bWJlclwiLCAuLi55QXhpcywgcG9zaXRpb246IFwibGVmdFwiIH0sXG4gICAgeyB0eXBlOiBcImNhdGVnb3J5XCIsIC4uLnhBeGlzLCBwb3NpdGlvbjogXCJib3R0b21cIiB9XG4gIF0gOiBbXG4gICAgeyB0eXBlOiBcImNhdGVnb3J5XCIsIC4uLnhBeGlzLCBwb3NpdGlvbjogXCJsZWZ0XCIgfSxcbiAgICB7IHR5cGU6IFwibnVtYmVyXCIsIC4uLnlBeGlzLCBwb3NpdGlvbjogXCJib3R0b21cIiB9XG4gIF07XG4gIHJldHVybiBjaGFydE9wdHM7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2FwaS9wcmVzZXQvcHJlc2V0cy50c1xudmFyIFBSRVNFVFMgPSB7XG4gIFwicHJpY2Utdm9sdW1lXCI6IHByaWNlVm9sdW1lLFxuICBnYXVnZSxcbiAgc3BhcmtsaW5lXG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9mYWN0b3J5L3Byb2Nlc3NFbnRlcnByaXNlT3B0aW9ucy50c1xuZnVuY3Rpb24gcmVtb3ZlVXNlZEVudGVycHJpc2VPcHRpb25zKG9wdGlvbnMsIHNpbGVudCkge1xuICBsZXQgdXNlZE9wdGlvbnMgPSBbXTtcbiAgY29uc3QgaXNHYXVnZUNoYXJ0ID0gaXNBZ0dhdWdlQ2hhcnRPcHRpb25zKG9wdGlvbnMpO1xuICBjb25zdCB0eXBlID0gb3B0aW9uc1R5cGUob3B0aW9ucyk7XG4gIGNvbnN0IG9wdGlvbnNDaGFydFR5cGUgPSB0eXBlID8gY2hhcnRUeXBlcy5nZXQodHlwZSkgOiBcInVua25vd25cIjtcbiAgZm9yIChjb25zdCB7XG4gICAgdHlwZTogdHlwZTIsXG4gICAgY2hhcnRUeXBlczogbW9kdWxlQ2hhcnRUeXBlcyxcbiAgICBvcHRpb25zS2V5LFxuICAgIG9wdGlvbnNJbm5lcktleSxcbiAgICBpZGVudGlmaWVyXG4gIH0gb2YgRVhQRUNURURfRU5URVJQUklTRV9NT0RVTEVTKSB7XG4gICAgaWYgKG9wdGlvbnNDaGFydFR5cGUgIT09IFwidW5rbm93blwiICYmICFtb2R1bGVDaGFydFR5cGVzLmluY2x1ZGVzKG9wdGlvbnNDaGFydFR5cGUpKVxuICAgICAgY29udGludWU7XG4gICAgaWYgKHR5cGUyID09PSBcInJvb3RcIiB8fCB0eXBlMiA9PT0gXCJsZWdlbmRcIikge1xuICAgICAgY29uc3Qgb3B0aW9uVmFsdWUgPSBvcHRpb25zW29wdGlvbnNLZXldO1xuICAgICAgaWYgKG9wdGlvblZhbHVlID09IG51bGwpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgaWYgKCFvcHRpb25zSW5uZXJLZXkpIHtcbiAgICAgICAgdXNlZE9wdGlvbnMucHVzaChvcHRpb25zS2V5KTtcbiAgICAgICAgZGVsZXRlIG9wdGlvbnNbb3B0aW9uc0tleV07XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvblZhbHVlW29wdGlvbnNJbm5lcktleV0pIHtcbiAgICAgICAgdXNlZE9wdGlvbnMucHVzaChgJHtvcHRpb25zS2V5fS4ke29wdGlvbnNJbm5lcktleX1gKTtcbiAgICAgICAgZGVsZXRlIG9wdGlvblZhbHVlW29wdGlvbnNJbm5lcktleV07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlMiA9PT0gXCJheGlzXCIpIHtcbiAgICAgIGlmICghKFwiYXhlc1wiIGluIG9wdGlvbnMpIHx8ICFvcHRpb25zLmF4ZXM/LnNvbWUoKGF4aXMpID0+IGF4aXMudHlwZSA9PT0gaWRlbnRpZmllcikpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgdXNlZE9wdGlvbnMucHVzaChgYXhpc1t0eXBlPSR7aWRlbnRpZmllcn1dYCk7XG4gICAgICBvcHRpb25zLmF4ZXMgPSBvcHRpb25zLmF4ZXMuZmlsdGVyKChheGlzKSA9PiBheGlzLnR5cGUgIT09IGlkZW50aWZpZXIpO1xuICAgIH0gZWxzZSBpZiAodHlwZTIgPT09IFwiYXhpcy1vcHRpb25cIikge1xuICAgICAgaWYgKCEoXCJheGVzXCIgaW4gb3B0aW9ucykgfHwgIW9wdGlvbnMuYXhlcz8uc29tZSgoYXhpcykgPT4gYXhpc1tvcHRpb25zS2V5XSkpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgdXNlZE9wdGlvbnMucHVzaChgYXhpcy4ke29wdGlvbnNLZXl9YCk7XG4gICAgICBvcHRpb25zLmF4ZXMuZm9yRWFjaCgoYXhpcykgPT4ge1xuICAgICAgICBpZiAoYXhpc1tvcHRpb25zS2V5XSkge1xuICAgICAgICAgIGRlbGV0ZSBheGlzW29wdGlvbnNLZXldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUyID09PSBcInNlcmllc1wiKSB7XG4gICAgICBpZiAoIW9wdGlvbnMuc2VyaWVzPy5zb21lKChzZXJpZXMpID0+IHNlcmllcy50eXBlID09PSBpZGVudGlmaWVyKSlcbiAgICAgICAgY29udGludWU7XG4gICAgICB1c2VkT3B0aW9ucy5wdXNoKGBzZXJpZXNbdHlwZT0ke2lkZW50aWZpZXJ9XWApO1xuICAgICAgb3B0aW9ucy5zZXJpZXMgPSBvcHRpb25zLnNlcmllcy5maWx0ZXIoKHNlcmllcykgPT4gc2VyaWVzLnR5cGUgIT09IGlkZW50aWZpZXIpO1xuICAgIH0gZWxzZSBpZiAodHlwZTIgPT09IFwic2VyaWVzLW9wdGlvblwiKSB7XG4gICAgICBpZiAoIW9wdGlvbnMuc2VyaWVzPy5zb21lKChzZXJpZXMpID0+IHNlcmllc1tvcHRpb25zS2V5XSkpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgdXNlZE9wdGlvbnMucHVzaChgc2VyaWVzLiR7b3B0aW9uc0tleX1gKTtcbiAgICAgIG9wdGlvbnMuc2VyaWVzLmZvckVhY2goKHNlcmllcykgPT4ge1xuICAgICAgICBpZiAoc2VyaWVzW29wdGlvbnNLZXldKSB7XG4gICAgICAgICAgZGVsZXRlIHNlcmllc1tvcHRpb25zS2V5XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmICh1c2VkT3B0aW9ucy5sZW5ndGggJiYgIXNpbGVudCkge1xuICAgIGlmIChpc0dhdWdlQ2hhcnQpIHtcbiAgICAgIHVzZWRPcHRpb25zID0gW1wiQWdDaGFydHMuY3JlYXRlR2F1Z2VcIl07XG4gICAgfVxuICAgIGxldCBlbnRlcnByaXNlUGFja2FnZU5hbWUgPSBcImFnLWNoYXJ0cy1lbnRlcnByaXNlXCI7XG4gICAgbGV0IGVudGVycHJpc2VSZWZlcmVuY2VVcmwgPSBcImh0dHBzOi8vYWctZ3JpZC5jb20vY2hhcnRzL2phdmFzY3JpcHQvaW5zdGFsbGF0aW9uL1wiO1xuICAgIGlmIChvcHRpb25zLm1vZGUgPT09IFwiaW50ZWdyYXRlZFwiKSB7XG4gICAgICBlbnRlcnByaXNlUGFja2FnZU5hbWUgPSBcImFnLWdyaWQtY2hhcnRzLWVudGVycHJpc2UnIG9yICdhZy1ncmlkLWVudGVycHJpc2UvY2hhcnRzLWVudGVycHJpc2VcIjtcbiAgICAgIGVudGVycHJpc2VSZWZlcmVuY2VVcmwgPSBcImh0dHBzOi8vd3d3LmFnLWdyaWQuY29tL2phdmFzY3JpcHQtZGF0YS1ncmlkL2ludGVncmF0ZWQtY2hhcnRzLWluc3RhbGxhdGlvbi9cIjtcbiAgICB9XG4gICAgTG9nZ2VyLndhcm5PbmNlKFxuICAgICAgW1xuICAgICAgICBgdW5hYmxlIHRvIHVzZSB0aGVzZSBlbnRlcnByaXNlIGZlYXR1cmVzIGFzICcke2VudGVycHJpc2VQYWNrYWdlTmFtZX0nIGhhcyBub3QgYmVlbiBsb2FkZWQ6YCxcbiAgICAgICAgXCJcIixcbiAgICAgICAgLi4udXNlZE9wdGlvbnMsXG4gICAgICAgIFwiXCIsXG4gICAgICAgIGBTZWU6ICR7ZW50ZXJwcmlzZVJlZmVyZW5jZVVybH1gXG4gICAgICBdLmpvaW4oXCJcXG5cIilcbiAgICApO1xuICB9XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvc3RyaW5nLnV0aWwudHNcbmZ1bmN0aW9uIHN0cmluZ2lmeVZhbHVlKHZhbHVlLCBtYXhMZW5ndGggPSBJbmZpbml0eSkge1xuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgIHJldHVybiBcInVuZGVmaW5lZFwiO1xuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIFwiTmFOXCI7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgICAgICByZXR1cm4gXCJJbmZpbml0eVwiO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgIHJldHVybiBcIi1JbmZpbml0eVwiO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB2YWx1ZSA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiBtYXhMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGAke3ZhbHVlLnNsaWNlKDAsIG1heExlbmd0aCl9Li4uICgrJHt2YWx1ZS5sZW5ndGggLSBtYXhMZW5ndGh9IGNoYXJhY3RlcnMpYDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3ZhbGlkYXRlLnRzXG52YXIgZGVzY3JpcHRpb25TeW1ib2wgPSBTeW1ib2woXCJkZXNjcmlwdGlvblwiKTtcbnZhciByZXF1aXJlZFN5bWJvbCA9IFN5bWJvbChcInJlcXVpcmVkXCIpO1xuZnVuY3Rpb24gaXNWYWxpZChvcHRpb25zLCBvcHRpb25zRGVmcywgcGF0aCkge1xuICBjb25zdCB7IGVycm9ycyB9ID0gdmFsaWRhdGUob3B0aW9ucywgb3B0aW9uc0RlZnMsIHBhdGgpO1xuICBmb3IgKGNvbnN0IHsgbWVzc2FnZSB9IG9mIGVycm9ycykge1xuICAgIExvZ2dlci53YXJuKG1lc3NhZ2UpO1xuICB9XG4gIHJldHVybiBlcnJvcnMubGVuZ3RoID09PSAwO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVNZXNzYWdlKHBhdGgsIHZhbHVlLCB2YWxpZGF0b3JPckRlZnMpIHtcbiAgY29uc3QgZGVzY3JpcHRpb24gPSBpc1N0cmluZyh2YWxpZGF0b3JPckRlZnMpID8gdmFsaWRhdG9yT3JEZWZzIDogdmFsaWRhdG9yT3JEZWZzW2Rlc2NyaXB0aW9uU3ltYm9sXTtcbiAgY29uc3QgZXhwZWN0aW5nID0gZGVzY3JpcHRpb24gPyBgOyBleHBlY3RpbmcgJHtkZXNjcmlwdGlvbn1gIDogXCJcIjtcbiAgY29uc3QgcHJlZml4ID0gcGF0aCA/IGBPcHRpb24gXFxgJHtwYXRofVxcYGAgOiBcIlZhbHVlXCI7XG4gIHJldHVybiBgJHtwcmVmaXh9IGNhbm5vdCBiZSBzZXQgdG8gXFxgJHtzdHJpbmdpZnlWYWx1ZSh2YWx1ZSl9XFxgJHtleHBlY3Rpbmd9LCBpZ25vcmluZy5gO1xufVxuZnVuY3Rpb24gdmFsaWRhdGUob3B0aW9ucywgb3B0aW9uc0RlZnMsIHBhdGggPSBcIlwiKSB7XG4gIGlmICghaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsaWQ6IG51bGwsXG4gICAgICBlcnJvcnM6IFt7IHBhdGgsIHZhbHVlOiBvcHRpb25zLCBtZXNzYWdlOiB2YWxpZGF0ZU1lc3NhZ2UocGF0aCwgb3B0aW9ucywgXCJhbiBvYmplY3RcIikgfV1cbiAgICB9O1xuICB9XG4gIGNvbnN0IG9wdGlvbnNLZXlzID0gbmV3IFNldChPYmplY3Qua2V5cyhvcHRpb25zKSk7XG4gIGNvbnN0IGVycm9ycyA9IFtdO1xuICBjb25zdCB2YWxpZCA9IHt9O1xuICBmdW5jdGlvbiBleHRlbmRQYXRoKGtleSkge1xuICAgIGlmIChpc0FycmF5KG9wdGlvbnNEZWZzKSkge1xuICAgICAgcmV0dXJuIGAke3BhdGh9WyR7a2V5fV1gO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aCA/IGAke3BhdGh9LiR7a2V5fWAgOiBrZXk7XG4gIH1cbiAgZm9yIChjb25zdCBba2V5LCB2YWxpZGF0b3JPckRlZnNdIG9mIE9iamVjdC5lbnRyaWVzKG9wdGlvbnNEZWZzKSkge1xuICAgIG9wdGlvbnNLZXlzLmRlbGV0ZShrZXkpO1xuICAgIGNvbnN0IHZhbHVlID0gb3B0aW9uc1trZXldO1xuICAgIGlmICghdmFsaWRhdG9yT3JEZWZzW3JlcXVpcmVkU3ltYm9sXSAmJiB0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICBjb250aW51ZTtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWxpZGF0b3JPckRlZnMpKSB7XG4gICAgICBpZiAodmFsaWRhdG9yT3JEZWZzKHZhbHVlKSkge1xuICAgICAgICB2YWxpZFtrZXldID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcnMucHVzaCh7IGtleSwgcGF0aCwgdmFsdWUsIG1lc3NhZ2U6IHZhbGlkYXRlTWVzc2FnZShleHRlbmRQYXRoKGtleSksIHZhbHVlLCB2YWxpZGF0b3JPckRlZnMpIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBuZXN0ZWRSZXN1bHQgPSB2YWxpZGF0ZSh2YWx1ZSwgdmFsaWRhdG9yT3JEZWZzLCBleHRlbmRQYXRoKGtleSkpO1xuICAgICAgdmFsaWRba2V5XSA9IG5lc3RlZFJlc3VsdC52YWxpZDtcbiAgICAgIGVycm9ycy5wdXNoKC4uLm5lc3RlZFJlc3VsdC5lcnJvcnMpO1xuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IGtleSBvZiBvcHRpb25zS2V5cykge1xuICAgIGVycm9ycy5wdXNoKHtcbiAgICAgIGtleSxcbiAgICAgIHBhdGgsXG4gICAgICB1bmtub3duOiB0cnVlLFxuICAgICAgbWVzc2FnZTogYFVua25vd24gb3B0aW9uIFxcYCR7ZXh0ZW5kUGF0aChrZXkpfVxcYCwgaWdub3JpbmcuYFxuICAgIH0pO1xuICB9XG4gIHJldHVybiB7IHZhbGlkLCBlcnJvcnMgfTtcbn1cbmZ1bmN0aW9uIGF0dGFjaERlc2NyaXB0aW9uKHZhbGlkYXRvciwgZGVzY3JpcHRpb24pIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oKHZhbHVlKSA9PiB2YWxpZGF0b3IodmFsdWUpLCB7IFtkZXNjcmlwdGlvblN5bWJvbF06IGRlc2NyaXB0aW9uIH0pO1xufVxudmFyIG9yID0gKC4uLnZhbGlkYXRvcnMpID0+IGF0dGFjaERlc2NyaXB0aW9uKFxuICAodmFsdWUpID0+IHZhbGlkYXRvcnMuc29tZSgodmFsaWRhdG9yKSA9PiB2YWxpZGF0b3IodmFsdWUpKSxcbiAgdmFsaWRhdG9ycy5tYXAoKHYpID0+IHZbZGVzY3JpcHRpb25TeW1ib2xdKS5maWx0ZXIoQm9vbGVhbikuam9pbihcIiBvciBcIilcbik7XG52YXIgYXJyYXkgPSBhdHRhY2hEZXNjcmlwdGlvbihpc0FycmF5LCBcImFuIGFycmF5XCIpO1xudmFyIGJvb2xlYW4gPSBhdHRhY2hEZXNjcmlwdGlvbihpc0Jvb2xlYW4sIFwiYSBib29sZWFuXCIpO1xudmFyIGNhbGxiYWNrID0gYXR0YWNoRGVzY3JpcHRpb24oaXNGdW5jdGlvbiwgXCJhIGZ1bmN0aW9uXCIpO1xudmFyIG51bWJlciA9IGF0dGFjaERlc2NyaXB0aW9uKGlzRmluaXRlTnVtYmVyLCBcImEgbnVtYmVyXCIpO1xudmFyIG9iamVjdCA9IGF0dGFjaERlc2NyaXB0aW9uKGlzT2JqZWN0LCBcImFuIG9iamVjdFwiKTtcbnZhciBzdHJpbmcgPSBhdHRhY2hEZXNjcmlwdGlvbihpc1N0cmluZywgXCJhIHN0cmluZ1wiKTtcbnZhciBudW1iZXJNaW4gPSAobWluLCBpbmNsdXNpdmUgPSB0cnVlKSA9PiBhdHRhY2hEZXNjcmlwdGlvbihcbiAgKHZhbHVlKSA9PiBpc0Zpbml0ZU51bWJlcih2YWx1ZSkgJiYgKHZhbHVlID4gbWluIHx8IGluY2x1c2l2ZSAmJiB2YWx1ZSA9PT0gbWluKSxcbiAgYGEgbnVtYmVyIGdyZWF0ZXIgdGhhbiAke2luY2x1c2l2ZSA/IFwib3IgZXF1YWwgdG8gXCIgOiBcIlwifSR7bWlufWBcbik7XG52YXIgbnVtYmVyUmFuZ2UgPSAobWluLCBtYXgpID0+IGF0dGFjaERlc2NyaXB0aW9uKFxuICAodmFsdWUpID0+IGlzRmluaXRlTnVtYmVyKHZhbHVlKSAmJiB2YWx1ZSA+PSBtaW4gJiYgdmFsdWUgPD0gbWF4LFxuICBgYSBudW1iZXIgYmV0d2VlbiAke21pbn0gYW5kICR7bWF4fSBpbmNsdXNpdmVgXG4pO1xudmFyIHBvc2l0aXZlTnVtYmVyID0gbnVtYmVyTWluKDApO1xudmFyIG1pbk9uZU51bWJlciA9IG51bWJlck1pbigxKTtcbnZhciByYXRpbyA9IG51bWJlclJhbmdlKDAsIDEpO1xudmFyIGRlZ3JlZSA9IG51bWJlclJhbmdlKDAsIDM2MCk7XG52YXIgYXJyYXlPZiA9ICh2YWxpZGF0b3IsIGRlc2NyaXB0aW9uKSA9PiBhdHRhY2hEZXNjcmlwdGlvbihcbiAgKHZhbHVlKSA9PiBpc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5ldmVyeSh2YWxpZGF0b3IpLFxuICBkZXNjcmlwdGlvbiA/PyBgJHt2YWxpZGF0b3JbZGVzY3JpcHRpb25TeW1ib2xdfSBhcnJheWBcbik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL21vZHVsZS9jb3JlTW9kdWxlc1R5cGVzLnRzXG5mdW5jdGlvbiBwYWxldHRlVHlwZShwYXJ0aWFsKSB7XG4gIGlmIChwYXJ0aWFsPy51cCB8fCBwYXJ0aWFsPy5kb3duIHx8IHBhcnRpYWw/Lm5ldXRyYWwpIHtcbiAgICByZXR1cm4gXCJ1c2VyLWZ1bGxcIjtcbiAgfSBlbHNlIGlmIChwYXJ0aWFsPy5maWxscyB8fCBwYXJ0aWFsPy5zdHJva2VzKSB7XG4gICAgcmV0dXJuIFwidXNlci1pbmRleGVkXCI7XG4gIH1cbiAgcmV0dXJuIFwiaW5idWlsdFwiO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC90aGVtZXMvY2hhcnRUaGVtZS50c1xudmFyIERFRkFVTFRfQkFDS0dST1VORF9GSUxMID0gXCJ3aGl0ZVwiO1xudmFyIENIQVJUX1RZUEVfQ09ORklHID0ge1xuICBnZXQgY2FydGVzaWFuKCkge1xuICAgIHJldHVybiB7IHNlcmllc1R5cGVzOiBjaGFydFR5cGVzLmNhcnRlc2lhblR5cGVzLCBjb21tb25PcHRpb25zOiBbXCJ6b29tXCIsIFwibmF2aWdhdG9yXCJdIH07XG4gIH0sXG4gIGdldCBwb2xhcigpIHtcbiAgICByZXR1cm4geyBzZXJpZXNUeXBlczogY2hhcnRUeXBlcy5wb2xhclR5cGVzLCBjb21tb25PcHRpb25zOiBbXSB9O1xuICB9LFxuICBnZXQgaGllcmFyY2h5KCkge1xuICAgIHJldHVybiB7IHNlcmllc1R5cGVzOiBjaGFydFR5cGVzLmhpZXJhcmNoeVR5cGVzLCBjb21tb25PcHRpb25zOiBbXSB9O1xuICB9LFxuICBnZXQgdG9wb2xvZ3koKSB7XG4gICAgcmV0dXJuIHsgc2VyaWVzVHlwZXM6IGNoYXJ0VHlwZXMudG9wb2xvZ3lUeXBlcywgY29tbW9uT3B0aW9uczogW10gfTtcbiAgfSxcbiAgZ2V0IFwiZmxvdy1wcm9wb3J0aW9uXCIoKSB7XG4gICAgcmV0dXJuIHsgc2VyaWVzVHlwZXM6IGNoYXJ0VHlwZXMuZmxvd1Byb3BvcnRpb25UeXBlcywgY29tbW9uT3B0aW9uczogW10gfTtcbiAgfSxcbiAgZ2V0IHN0YW5kYWxvbmUoKSB7XG4gICAgcmV0dXJuIHsgc2VyaWVzVHlwZXM6IGNoYXJ0VHlwZXMuc3RhbmRhbG9uZVR5cGVzLCBjb21tb25PcHRpb25zOiBbXSB9O1xuICB9LFxuICBnZXQgZ2F1Z2UoKSB7XG4gICAgcmV0dXJuIHsgc2VyaWVzVHlwZXM6IGNoYXJ0VHlwZXMuZ2F1Z2VUeXBlcywgY29tbW9uT3B0aW9uczogW10gfTtcbiAgfVxufTtcbnZhciBQUkVTRVRfT1ZFUlJJREVTX1RZUEVTID0ge1xuICBcInJhZGlhbC1nYXVnZVwiOiB0cnVlLFxuICBcImxpbmVhci1nYXVnZVwiOiB0cnVlXG59O1xuZnVuY3Rpb24gaXNQcmVzZXRPdmVycmlkZXNUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIFBSRVNFVF9PVkVSUklERVNfVFlQRVNbdHlwZV0gPT09IHRydWU7XG59XG52YXIgQ0hBUlRfVFlQRV9TUEVDSUZJQ19DT01NT05fT1BUSU9OUyA9IE9iamVjdC52YWx1ZXMoQ0hBUlRfVFlQRV9DT05GSUcpLnJlZHVjZSgociwgeyBjb21tb25PcHRpb25zIH0pID0+IHIuY29uY2F0KGNvbW1vbk9wdGlvbnMpLCBbXSk7XG52YXIgX0NoYXJ0VGhlbWUgPSBjbGFzcyBfQ2hhcnRUaGVtZSB7XG4gIHN0YXRpYyBnZXRBeGlzRGVmYXVsdHMob3ZlcnJpZGVEZWZhdWx0cykge1xuICAgIHJldHVybiBtZXJnZURlZmF1bHRzKG92ZXJyaWRlRGVmYXVsdHMsIHtcbiAgICAgIHRpdGxlOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICB0ZXh0OiBcIkF4aXMgVGl0bGVcIixcbiAgICAgICAgc3BhY2luZzogMjUsXG4gICAgICAgIGZvbnRXZWlnaHQ6IFwibm9ybWFsXCIgLyogTk9STUFMICovLFxuICAgICAgICBmb250U2l6ZTogMTMgLyogTUVESVVNICovLFxuICAgICAgICBmb250RmFtaWx5OiBERUZBVUxUX0ZPTlRfRkFNSUxZLFxuICAgICAgICBjb2xvcjogREVGQVVMVF9MQUJFTF9DT0xPVVJcbiAgICAgIH0sXG4gICAgICBsYWJlbDoge1xuICAgICAgICBmb250U2l6ZTogMTIgLyogU01BTEwgKi8sXG4gICAgICAgIGZvbnRGYW1pbHk6IERFRkFVTFRfRk9OVF9GQU1JTFksXG4gICAgICAgIHBhZGRpbmc6IDUsXG4gICAgICAgIGNvbG9yOiBERUZBVUxUX0xBQkVMX0NPTE9VUixcbiAgICAgICAgYXZvaWRDb2xsaXNpb25zOiB0cnVlXG4gICAgICB9LFxuICAgICAgbGluZToge1xuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgc3Ryb2tlOiBERUZBVUxUX0FYSVNfTElORV9DT0xPVVJcbiAgICAgIH0sXG4gICAgICB0aWNrOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgc3Ryb2tlOiBERUZBVUxUX0FYSVNfTElORV9DT0xPVVJcbiAgICAgIH0sXG4gICAgICBncmlkTGluZToge1xuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBzdHlsZTogW3sgc3Ryb2tlOiBERUZBVUxUX0FYSVNfR1JJRF9DT0xPVVIsIGxpbmVEYXNoOiBbXSB9XVxuICAgICAgfSxcbiAgICAgIGNyb3NzTGluZXM6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIGZpbGw6IERFRkFVTFRfQ1JPU1NfTElORVNfQ09MT1VSLFxuICAgICAgICBzdHJva2U6IERFRkFVTFRfQ1JPU1NfTElORVNfQ09MT1VSLFxuICAgICAgICBmaWxsT3BhY2l0eTogMC4xLFxuICAgICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICBmb250U2l6ZTogMTIgLyogU01BTEwgKi8sXG4gICAgICAgICAgZm9udEZhbWlseTogREVGQVVMVF9GT05UX0ZBTUlMWSxcbiAgICAgICAgICBwYWRkaW5nOiA1LFxuICAgICAgICAgIGNvbG9yOiBERUZBVUxUX0xBQkVMX0NPTE9VUlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY3Jvc3NoYWlyOiB7XG4gICAgICAgIGVuYWJsZWQ6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXRDaGFydERlZmF1bHRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBtaW5IZWlnaHQ6IDMwMCxcbiAgICAgIG1pbldpZHRoOiAzMDAsXG4gICAgICBiYWNrZ3JvdW5kOiB7IHZpc2libGU6IHRydWUsIGZpbGw6IERFRkFVTFRfQkFDS0dST1VORF9DT0xPVVIgfSxcbiAgICAgIHBhZGRpbmc6IHsgdG9wOiBERUZBVUxUX1BBRERJTkcsIHJpZ2h0OiBERUZBVUxUX1BBRERJTkcsIGJvdHRvbTogREVGQVVMVF9QQURESU5HLCBsZWZ0OiBERUZBVUxUX1BBRERJTkcgfSxcbiAgICAgIGtleWJvYXJkOiB7IGVuYWJsZWQ6IHRydWUgfSxcbiAgICAgIHRpdGxlOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICB0ZXh0OiBcIlRpdGxlXCIsXG4gICAgICAgIGZvbnRXZWlnaHQ6IFwibm9ybWFsXCIgLyogTk9STUFMICovLFxuICAgICAgICBmb250U2l6ZTogMTcgLyogTEFSR0UgKi8sXG4gICAgICAgIGZvbnRGYW1pbHk6IERFRkFVTFRfRk9OVF9GQU1JTFksXG4gICAgICAgIGNvbG9yOiBERUZBVUxUX0xBQkVMX0NPTE9VUixcbiAgICAgICAgd3JhcHBpbmc6IFwiaHlwaGVuYXRlXCIsXG4gICAgICAgIGxheW91dFN0eWxlOiBERUZBVUxUX0NBUFRJT05fTEFZT1VUX1NUWUxFLFxuICAgICAgICB0ZXh0QWxpZ246IERFRkFVTFRfQ0FQVElPTl9BTElHTk1FTlRcbiAgICAgIH0sXG4gICAgICBzdWJ0aXRsZToge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgdGV4dDogXCJTdWJ0aXRsZVwiLFxuICAgICAgICBzcGFjaW5nOiAyMCxcbiAgICAgICAgZm9udFNpemU6IDEzIC8qIE1FRElVTSAqLyxcbiAgICAgICAgZm9udEZhbWlseTogREVGQVVMVF9GT05UX0ZBTUlMWSxcbiAgICAgICAgY29sb3I6IERFRkFVTFRfTVVURURfTEFCRUxfQ09MT1VSLFxuICAgICAgICB3cmFwcGluZzogXCJoeXBoZW5hdGVcIixcbiAgICAgICAgbGF5b3V0U3R5bGU6IERFRkFVTFRfQ0FQVElPTl9MQVlPVVRfU1RZTEUsXG4gICAgICAgIHRleHRBbGlnbjogREVGQVVMVF9DQVBUSU9OX0FMSUdOTUVOVFxuICAgICAgfSxcbiAgICAgIGZvb3Rub3RlOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICB0ZXh0OiBcIkZvb3Rub3RlXCIsXG4gICAgICAgIHNwYWNpbmc6IDIwLFxuICAgICAgICBmb250U2l6ZTogMTMgLyogTUVESVVNICovLFxuICAgICAgICBmb250RmFtaWx5OiBERUZBVUxUX0ZPTlRfRkFNSUxZLFxuICAgICAgICBjb2xvcjogXCJyZ2IoMTQwLCAxNDAsIDE0MClcIixcbiAgICAgICAgd3JhcHBpbmc6IFwiaHlwaGVuYXRlXCIsXG4gICAgICAgIGxheW91dFN0eWxlOiBERUZBVUxUX0NBUFRJT05fTEFZT1VUX1NUWUxFLFxuICAgICAgICB0ZXh0QWxpZ246IERFRkFVTFRfQ0FQVElPTl9BTElHTk1FTlRcbiAgICAgIH0sXG4gICAgICBsZWdlbmQ6IHtcbiAgICAgICAgcG9zaXRpb246IFwiYm90dG9tXCIgLyogQk9UVE9NICovLFxuICAgICAgICBzcGFjaW5nOiAzMCxcbiAgICAgICAgbGlzdGVuZXJzOiB7fSxcbiAgICAgICAgdG9nZ2xlU2VyaWVzOiB0cnVlLFxuICAgICAgICBpdGVtOiB7XG4gICAgICAgICAgcGFkZGluZ1g6IDE2LFxuICAgICAgICAgIHBhZGRpbmdZOiA4LFxuICAgICAgICAgIG1hcmtlcjogeyBzaXplOiAxNSwgcGFkZGluZzogOCB9LFxuICAgICAgICAgIHNob3dTZXJpZXNTdHJva2U6IHRydWUsXG4gICAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICAgIGNvbG9yOiBERUZBVUxUX0xBQkVMX0NPTE9VUixcbiAgICAgICAgICAgIGZvbnRTaXplOiAxMiAvKiBTTUFMTCAqLyxcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6IERFRkFVTFRfRk9OVF9GQU1JTFlcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJldmVyc2VPcmRlcjogZmFsc2UsXG4gICAgICAgIHBhZ2luYXRpb246IHtcbiAgICAgICAgICBtYXJrZXI6IHsgc2l6ZTogMTIgfSxcbiAgICAgICAgICBhY3RpdmVTdHlsZTogeyBmaWxsOiBERUZBVUxUX0xBQkVMX0NPTE9VUiB9LFxuICAgICAgICAgIGluYWN0aXZlU3R5bGU6IHsgZmlsbDogREVGQVVMVF9NVVRFRF9MQUJFTF9DT0xPVVIgfSxcbiAgICAgICAgICBoaWdobGlnaHRTdHlsZTogeyBmaWxsOiBERUZBVUxUX0xBQkVMX0NPTE9VUiB9LFxuICAgICAgICAgIGxhYmVsOiB7IGNvbG9yOiBERUZBVUxUX0xBQkVMX0NPTE9VUiB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0b29sdGlwOiB7XG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIGRhcmtUaGVtZTogSVNfREFSS19USEVNRSxcbiAgICAgICAgZGVsYXk6IDBcbiAgICAgIH0sXG4gICAgICBvdmVybGF5czogeyBkYXJrVGhlbWU6IElTX0RBUktfVEhFTUUgfSxcbiAgICAgIGxpc3RlbmVyczoge31cbiAgICB9O1xuICB9XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgb3ZlcnJpZGVzLCBwYWxldHRlIH0gPSBkZWVwQ2xvbmUob3B0aW9ucyk7XG4gICAgY29uc3QgZGVmYXVsdHMgPSB0aGlzLmNyZWF0ZUNoYXJ0Q29uZmlnUGVyQ2hhcnRUeXBlKHRoaXMuZ2V0RGVmYXVsdHMoKSk7XG4gICAgY29uc3QgcHJlc2V0cyA9IHt9O1xuICAgIGlmIChvdmVycmlkZXMpIHtcbiAgICAgIHRoaXMubWVyZ2VPdmVycmlkZXMoZGVmYXVsdHMsIHByZXNldHMsIG92ZXJyaWRlcyk7XG4gICAgfVxuICAgIGNvbnN0IHsgZmlsbHMsIHN0cm9rZXMsIC4uLm90aGVyQ29sb3JzIH0gPSB0aGlzLmdldERlZmF1bHRDb2xvcnMoKTtcbiAgICB0aGlzLnBhbGV0dGUgPSBtZXJnZURlZmF1bHRzKHBhbGV0dGUsIHtcbiAgICAgIGZpbGxzOiBPYmplY3QudmFsdWVzKGZpbGxzKSxcbiAgICAgIHN0cm9rZXM6IE9iamVjdC52YWx1ZXMoc3Ryb2tlcyksXG4gICAgICAuLi5vdGhlckNvbG9yc1xuICAgIH0pO1xuICAgIHRoaXMucGFsZXR0ZVR5cGUgPSBwYWxldHRlVHlwZShwYWxldHRlKTtcbiAgICB0aGlzLmNvbmZpZyA9IE9iamVjdC5mcmVlemUodGhpcy50ZW1wbGF0ZVRoZW1lKGRlZmF1bHRzKSk7XG4gICAgdGhpcy5wcmVzZXRzID0gcHJlc2V0cztcbiAgfVxuICBtZXJnZU92ZXJyaWRlcyhkZWZhdWx0cywgcHJlc2V0cywgb3ZlcnJpZGVzKSB7XG4gICAgZm9yIChjb25zdCB7IHNlcmllc1R5cGVzLCBjb21tb25PcHRpb25zIH0gb2YgT2JqZWN0LnZhbHVlcyhDSEFSVF9UWVBFX0NPTkZJRykpIHtcbiAgICAgIGNvbnN0IGNsZWFuZWRDb21tb24gPSB7IC4uLm92ZXJyaWRlcy5jb21tb24gfTtcbiAgICAgIGZvciAoY29uc3QgY29tbW9uS2V5IG9mIENIQVJUX1RZUEVfU1BFQ0lGSUNfQ09NTU9OX09QVElPTlMpIHtcbiAgICAgICAgaWYgKCFjb21tb25PcHRpb25zLmluY2x1ZGVzKGNvbW1vbktleSkpIHtcbiAgICAgICAgICBkZWxldGUgY2xlYW5lZENvbW1vbltjb21tb25LZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWNsZWFuZWRDb21tb24pXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgZm9yIChjb25zdCBzIG9mIHNlcmllc1R5cGVzKSB7XG4gICAgICAgIGNvbnN0IHNlcmllc1R5cGUyID0gcztcbiAgICAgICAgaWYgKCFpc1ByZXNldE92ZXJyaWRlc1R5cGUoc2VyaWVzVHlwZTIpKSB7XG4gICAgICAgICAgZGVmYXVsdHNbc2VyaWVzVHlwZTJdID0gbWVyZ2VEZWZhdWx0cyhjbGVhbmVkQ29tbW9uLCBkZWZhdWx0c1tzZXJpZXNUeXBlMl0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNoYXJ0VHlwZXMuc2VyaWVzVHlwZXMuZm9yRWFjaCgocykgPT4ge1xuICAgICAgY29uc3Qgc2VyaWVzVHlwZTIgPSBzO1xuICAgICAgY29uc3Qgc2VyaWVzT3ZlcnJpZGVzID0gb3ZlcnJpZGVzW3Nlcmllc1R5cGUyXTtcbiAgICAgIGlmIChpc1ByZXNldE92ZXJyaWRlc1R5cGUoc2VyaWVzVHlwZTIpKSB7XG4gICAgICAgIHByZXNldHNbc2VyaWVzVHlwZTJdID0gc2VyaWVzT3ZlcnJpZGVzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVmYXVsdHNbc2VyaWVzVHlwZTJdID0gbWVyZ2VEZWZhdWx0cyhzZXJpZXNPdmVycmlkZXMsIGRlZmF1bHRzW3Nlcmllc1R5cGUyXSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY3JlYXRlQ2hhcnRDb25maWdQZXJDaGFydFR5cGUoY29uZmlnKSB7XG4gICAgZm9yIChjb25zdCBbbmV4dFR5cGUsIHsgc2VyaWVzVHlwZXMgfV0gb2YgT2JqZWN0LmVudHJpZXMoQ0hBUlRfVFlQRV9DT05GSUcpKSB7XG4gICAgICBjb25zdCB0eXBlRGVmYXVsdHMgPSBjaGFydERlZmF1bHRzLmdldChuZXh0VHlwZSk7XG4gICAgICBmb3IgKGNvbnN0IHNlcmllc1R5cGUyIG9mIHNlcmllc1R5cGVzKSB7XG4gICAgICAgIGNvbmZpZ1tzZXJpZXNUeXBlMl0gfHwgKGNvbmZpZ1tzZXJpZXNUeXBlMl0gPSBkZWVwQ2xvbmUodHlwZURlZmF1bHRzKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb25maWc7XG4gIH1cbiAgZ2V0RGVmYXVsdHMoKSB7XG4gICAgY29uc3QgZ2V0T3ZlcnJpZGVzQnlUeXBlID0gKGNoYXJ0VHlwZTIsIHNlcmllc1R5cGVzKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgIGNvbnN0IGNoYXJ0VHlwZURlZmF1bHRzID0ge1xuICAgICAgICBheGVzOiB7fSxcbiAgICAgICAgLi4ubGVnZW5kUmVnaXN0cnkuZ2V0VGhlbWVUZW1wbGF0ZXMoKSxcbiAgICAgICAgLi4udGhpcy5nZXRDaGFydERlZmF1bHRzKCksXG4gICAgICAgIC4uLmNoYXJ0RGVmYXVsdHMuZ2V0KGNoYXJ0VHlwZTIpXG4gICAgICB9O1xuICAgICAgZm9yIChjb25zdCBzZXJpZXNUeXBlMiBvZiBzZXJpZXNUeXBlcykge1xuICAgICAgICByZXN1bHRbc2VyaWVzVHlwZTJdID0gbWVyZ2VEZWZhdWx0cyhcbiAgICAgICAgICBzZXJpZXNSZWdpc3RyeS5nZXRUaGVtZVRlbXBsYXRlKHNlcmllc1R5cGUyKSxcbiAgICAgICAgICByZXN1bHRbc2VyaWVzVHlwZTJdID8/IGRlZXBDbG9uZShjaGFydFR5cGVEZWZhdWx0cylcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgeyBheGVzIH0gPSByZXN1bHRbc2VyaWVzVHlwZTJdO1xuICAgICAgICBmb3IgKGNvbnN0IGF4aXNUeXBlIG9mIGF4aXNSZWdpc3RyeS5rZXlzKCkpIHtcbiAgICAgICAgICBheGVzW2F4aXNUeXBlXSA9IG1lcmdlRGVmYXVsdHMoXG4gICAgICAgICAgICBheGVzW2F4aXNUeXBlXSxcbiAgICAgICAgICAgIGF4aXNSZWdpc3RyeS5nZXRUaGVtZVRlbXBsYXRlKGF4aXNUeXBlKSxcbiAgICAgICAgICAgIF9DaGFydFRoZW1lLmNhcnRlc2lhbkF4aXNEZWZhdWx0W2F4aXNUeXBlXVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICByZXR1cm4gbWVyZ2VEZWZhdWx0cyhcbiAgICAgIGdldE92ZXJyaWRlc0J5VHlwZShcImNhcnRlc2lhblwiLCBjaGFydFR5cGVzLmNhcnRlc2lhblR5cGVzKSxcbiAgICAgIGdldE92ZXJyaWRlc0J5VHlwZShcInBvbGFyXCIsIGNoYXJ0VHlwZXMucG9sYXJUeXBlcyksXG4gICAgICBnZXRPdmVycmlkZXNCeVR5cGUoXCJoaWVyYXJjaHlcIiwgY2hhcnRUeXBlcy5oaWVyYXJjaHlUeXBlcyksXG4gICAgICBnZXRPdmVycmlkZXNCeVR5cGUoXCJ0b3BvbG9neVwiLCBjaGFydFR5cGVzLnRvcG9sb2d5VHlwZXMpLFxuICAgICAgZ2V0T3ZlcnJpZGVzQnlUeXBlKFwiZmxvdy1wcm9wb3J0aW9uXCIsIGNoYXJ0VHlwZXMuZmxvd1Byb3BvcnRpb25UeXBlcyksXG4gICAgICBnZXRPdmVycmlkZXNCeVR5cGUoXCJzdGFuZGFsb25lXCIsIGNoYXJ0VHlwZXMuc3RhbmRhbG9uZVR5cGVzKSxcbiAgICAgIGdldE92ZXJyaWRlc0J5VHlwZShcImdhdWdlXCIsIGNoYXJ0VHlwZXMuZ2F1Z2VUeXBlcylcbiAgICApO1xuICB9XG4gIHRlbXBsYXRlVGhlbWUodGhlbWVUZW1wbGF0ZSkge1xuICAgIGNvbnN0IHRoZW1lSW5zdGFuY2UgPSBkZWVwQ2xvbmUodGhlbWVUZW1wbGF0ZSk7XG4gICAgY29uc3QgcGFyYW1zID0gdGhpcy5nZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKTtcbiAgICBqc29uV2Fsayh0aGVtZUluc3RhbmNlLCAobm9kZSkgPT4ge1xuICAgICAgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qgc3ltYm9sID0gbm9kZVtpXTtcbiAgICAgICAgICBpZiAocGFyYW1zLmhhcyhzeW1ib2wpKSB7XG4gICAgICAgICAgICBub2RlW2ldID0gcGFyYW1zLmdldChzeW1ib2wpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG5vZGUpKSB7XG4gICAgICAgICAgaWYgKHBhcmFtcy5oYXModmFsdWUpKSB7XG4gICAgICAgICAgICBub2RlW25hbWVdID0gcGFyYW1zLmdldCh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlZXBDbG9uZSh0aGVtZUluc3RhbmNlKTtcbiAgfVxuICBnZXREZWZhdWx0Q29sb3JzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBmaWxsczogREVGQVVMVF9GSUxMUyxcbiAgICAgIHN0cm9rZXM6IERFRkFVTFRfU1RST0tFUyxcbiAgICAgIHVwOiB7IGZpbGw6IERFRkFVTFRfRklMTFMuR1JFRU4sIHN0cm9rZTogREVGQVVMVF9TVFJPS0VTLkdSRUVOIH0sXG4gICAgICBkb3duOiB7IGZpbGw6IERFRkFVTFRfRklMTFMuUkVELCBzdHJva2U6IERFRkFVTFRfU1RST0tFUy5SRUQgfSxcbiAgICAgIG5ldXRyYWw6IHsgZmlsbDogREVGQVVMVF9GSUxMUy5HUkFZLCBzdHJva2U6IERFRkFVTFRfU1RST0tFUy5HUkFZIH0sXG4gICAgICBhbHRVcDogeyBmaWxsOiBERUZBVUxUX0ZJTExTLkJMVUUsIHN0cm9rZTogREVGQVVMVF9TVFJPS0VTLkJMVUUgfSxcbiAgICAgIGFsdERvd246IHsgZmlsbDogREVGQVVMVF9GSUxMUy5PUkFOR0UsIHN0cm9rZTogREVGQVVMVF9TVFJPS0VTLk9SQU5HRSB9LFxuICAgICAgYWx0TmV1dHJhbDogeyBmaWxsOiBERUZBVUxUX0ZJTExTLkdSQVksIHN0cm9rZTogREVGQVVMVF9TVFJPS0VTLkdSQVkgfVxuICAgIH07XG4gIH1cbiAgZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKCkge1xuICAgIGNvbnN0IHsgaXNFbnRlcnByaXNlIH0gPSBlbnRlcnByaXNlTW9kdWxlO1xuICAgIGNvbnN0IHBhcmFtcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgcGFyYW1zLnNldChJU19EQVJLX1RIRU1FLCBmYWxzZSk7XG4gICAgcGFyYW1zLnNldChJU19FTlRFUlBSSVNFLCBpc0VudGVycHJpc2UpO1xuICAgIHBhcmFtcy5zZXQoSVNfQ09NTVVOSVRZLCAhaXNFbnRlcnByaXNlKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfRk9OVF9GQU1JTFksIFwiVmVyZGFuYSwgc2Fucy1zZXJpZlwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfTEFCRUxfQ09MT1VSLCBcInJnYig3MCwgNzAsIDcwKVwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfSU5WRVJURURfTEFCRUxfQ09MT1VSLCBcIndoaXRlXCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9NVVRFRF9MQUJFTF9DT0xPVVIsIFwicmdiKDE0MCwgMTQwLCAxNDApXCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BWElTX0dSSURfQ09MT1VSLCBcInJnYigyMjQsMjM0LDI0MSlcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FYSVNfTElORV9DT0xPVVIsIFwicmdiKDE5NSwgMTk1LCAxOTUpXCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9DUk9TU19MSU5FU19DT0xPVVIsIFwicmdiKDcwLCA3MCwgNzApXCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9JTlNJREVfU0VSSUVTX0xBQkVMX0NPTE9VUiwgREVGQVVMVF9CQUNLR1JPVU5EX0ZJTEwpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9CQUNLR1JPVU5EX0NPTE9VUiwgREVGQVVMVF9CQUNLR1JPVU5EX0ZJTEwpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9TSEFET1dfQ09MT1VSLCBcInJnYmEoMCwgMCwgMCwgMC41KVwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfRElWRVJHSU5HX1NFUklFU19DT0xPUl9SQU5HRSwgW1xuICAgICAgREVGQVVMVF9GSUxMUy5PUkFOR0UsXG4gICAgICBERUZBVUxUX0ZJTExTLllFTExPVyxcbiAgICAgIERFRkFVTFRfRklMTFMuR1JFRU5cbiAgICBdKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfR0FVR0VfU0VSSUVTX0NPTE9SX1JBTkdFLCBbREVGQVVMVF9GSUxMUy5HUkVFTiwgREVGQVVMVF9GSUxMUy5ZRUxMT1csIERFRkFVTFRfRklMTFMuUkVEXSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0ZVTk5FTF9TRVJJRVNfQ09MT1JfUkFOR0UsIFtcbiAgICAgIFwiIzUwOTBkY1wiLFxuICAgICAgXCIjNjI5YmUwXCIsXG4gICAgICBcIiM3M2E2ZTNcIixcbiAgICAgIFwiIzg1YjFlN1wiLFxuICAgICAgXCIjOTZiY2VhXCIsXG4gICAgICBcIiNhOGM4ZWVcIixcbiAgICAgIFwiI2I5ZDNmMVwiLFxuICAgICAgXCIjY2JkZWY1XCJcbiAgICBdKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfUEFERElORywgMjApO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9DQVBUSU9OX0xBWU9VVF9TVFlMRSwgXCJibG9ja1wiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQ0FQVElPTl9BTElHTk1FTlQsIFwiY2VudGVyXCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9ISUVSQVJDSFlfRklMTFMsIFtcIiNmZmZmZmZcIiwgXCIjZTBlNWVhXCIsIFwiI2MxY2NkNVwiLCBcIiNhM2I0YzFcIiwgXCIjODU5Y2FkXCJdKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfSElFUkFSQ0hZX1NUUk9LRVMsIFtcIiNmZmZmZmZcIiwgXCIjYzVjYmQxXCIsIFwiI2E0YjFiZFwiLCBcIiM4NDk4YTlcIiwgXCIjNjQ4MDk2XCJdKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfUE9MQVJfU0VSSUVTX1NUUk9LRSwgREVGQVVMVF9CQUNLR1JPVU5EX0ZJTEwpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX0NPTE9SLCBERUZBVUxUX0ZJTExTLkJMVUUpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9URVhUX0FOTk9UQVRJT05fQ09MT1IsIERFRkFVTFRfRklMTFMuQkxVRSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fQkFDS0dST1VORF9GSUxMLCBERUZBVUxUX0ZJTExTLkJMVUUpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX0hBTkRMRV9GSUxMLCBERUZBVUxUX0JBQ0tHUk9VTkRfRklMTCk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fU1RBVElTVElDU19GSUxMLCBcIiNmYWZhZmFcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fU1RBVElTVElDU19TVFJPS0UsIFwiI2RkZGRkZFwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQU5OT1RBVElPTl9TVEFUSVNUSUNTX0NPTE9SLCBcIiMwMDAwMDBcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fU1RBVElTVElDU19ESVZJREVSX1NUUk9LRSwgXCIjMTgxZDFmXCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX1NUQVRJU1RJQ1NfRE9XTl9GSUxMLCBcIiNlMzVjNWNcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fU1RBVElTVElDU19ET1dOX1NUUk9LRSwgXCIjZTM1YzVjXCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9URVhUQk9YX0ZJTEwsIFwiI2ZhZmFmYVwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfVEVYVEJPWF9TVFJPS0UsIFwiI2RkZGRkZFwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfVEVYVEJPWF9DT0xPUiwgXCIjMDAwMDAwXCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9UT09MQkFSX1BPU0lUSU9OLCBcInRvcFwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfR1JJRExJTkVfRU5BQkxFRCwgZmFsc2UpO1xuICAgIGNvbnN0IGRlZmF1bHRDb2xvcnMgPSB0aGlzLmdldERlZmF1bHRDb2xvcnMoKTtcbiAgICBwYXJhbXMuc2V0KFBBTEVUVEVfVVBfU1RST0tFLCB0aGlzLnBhbGV0dGUudXA/LnN0cm9rZSA/PyBkZWZhdWx0Q29sb3JzLnVwLnN0cm9rZSk7XG4gICAgcGFyYW1zLnNldChQQUxFVFRFX1VQX0ZJTEwsIHRoaXMucGFsZXR0ZS51cD8uZmlsbCA/PyBkZWZhdWx0Q29sb3JzLnVwLmZpbGwpO1xuICAgIHBhcmFtcy5zZXQoUEFMRVRURV9ET1dOX1NUUk9LRSwgdGhpcy5wYWxldHRlLmRvd24/LnN0cm9rZSA/PyBkZWZhdWx0Q29sb3JzLmRvd24uc3Ryb2tlKTtcbiAgICBwYXJhbXMuc2V0KFBBTEVUVEVfRE9XTl9GSUxMLCB0aGlzLnBhbGV0dGUuZG93bj8uZmlsbCA/PyBkZWZhdWx0Q29sb3JzLmRvd24uZmlsbCk7XG4gICAgcGFyYW1zLnNldChQQUxFVFRFX05FVVRSQUxfU1RST0tFLCB0aGlzLnBhbGV0dGUubmV1dHJhbD8uc3Ryb2tlID8/IGRlZmF1bHRDb2xvcnMubmV1dHJhbC5zdHJva2UpO1xuICAgIHBhcmFtcy5zZXQoUEFMRVRURV9ORVVUUkFMX0ZJTEwsIHRoaXMucGFsZXR0ZS5uZXV0cmFsPy5maWxsID8/IGRlZmF1bHRDb2xvcnMubmV1dHJhbC5maWxsKTtcbiAgICBwYXJhbXMuc2V0KFBBTEVUVEVfQUxUX1VQX1NUUk9LRSwgdGhpcy5wYWxldHRlLmFsdFVwPy5zdHJva2UgPz8gZGVmYXVsdENvbG9ycy51cC5zdHJva2UpO1xuICAgIHBhcmFtcy5zZXQoUEFMRVRURV9BTFRfVVBfRklMTCwgdGhpcy5wYWxldHRlLmFsdFVwPy5maWxsID8/IGRlZmF1bHRDb2xvcnMudXAuZmlsbCk7XG4gICAgcGFyYW1zLnNldChQQUxFVFRFX0FMVF9ET1dOX1NUUk9LRSwgdGhpcy5wYWxldHRlLmFsdERvd24/LnN0cm9rZSA/PyBkZWZhdWx0Q29sb3JzLmRvd24uc3Ryb2tlKTtcbiAgICBwYXJhbXMuc2V0KFBBTEVUVEVfQUxUX0RPV05fRklMTCwgdGhpcy5wYWxldHRlLmFsdERvd24/LmZpbGwgPz8gZGVmYXVsdENvbG9ycy5kb3duLmZpbGwpO1xuICAgIHBhcmFtcy5zZXQoUEFMRVRURV9BTFRfTkVVVFJBTF9GSUxMLCB0aGlzLnBhbGV0dGUuYWx0TmV1dHJhbD8uZmlsbCA/PyBkZWZhdWx0Q29sb3JzLmFsdE5ldXRyYWwuZmlsbCk7XG4gICAgcGFyYW1zLnNldChQQUxFVFRFX0FMVF9ORVVUUkFMX1NUUk9LRSwgdGhpcy5wYWxldHRlLmFsdE5ldXRyYWw/LnN0cm9rZSA/PyBkZWZhdWx0Q29sb3JzLmFsdE5ldXRyYWwuc3Ryb2tlKTtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG59O1xuX0NoYXJ0VGhlbWUuY2FydGVzaWFuQXhpc0RlZmF1bHQgPSB7XG4gIFtcIm51bWJlclwiIC8qIE5VTUJFUiAqL106IF9DaGFydFRoZW1lLmdldEF4aXNEZWZhdWx0cyh7XG4gICAgbGluZTogeyBlbmFibGVkOiBmYWxzZSB9XG4gIH0pLFxuICBbXCJsb2dcIiAvKiBMT0cgKi9dOiBfQ2hhcnRUaGVtZS5nZXRBeGlzRGVmYXVsdHMoe1xuICAgIGJhc2U6IDEwLFxuICAgIGxpbmU6IHsgZW5hYmxlZDogZmFsc2UgfSxcbiAgICBpbnRlcnZhbDogeyBtaW5TcGFjaW5nOiBOYU4gfVxuICB9KSxcbiAgW1wiY2F0ZWdvcnlcIiAvKiBDQVRFR09SWSAqL106IF9DaGFydFRoZW1lLmdldEF4aXNEZWZhdWx0cyh7XG4gICAgZ3JvdXBQYWRkaW5nSW5uZXI6IDAuMSxcbiAgICBsYWJlbDogeyBhdXRvUm90YXRlOiB0cnVlIH0sXG4gICAgZ3JpZExpbmU6IHsgZW5hYmxlZDogREVGQVVMVF9HUklETElORV9FTkFCTEVEIH0sXG4gICAgY3Jvc3NoYWlyOiB7IGVuYWJsZWQ6IGZhbHNlIH1cbiAgfSksXG4gIFtcInRpbWVcIiAvKiBUSU1FICovXTogX0NoYXJ0VGhlbWUuZ2V0QXhpc0RlZmF1bHRzKHsgZ3JpZExpbmU6IHsgZW5hYmxlZDogREVGQVVMVF9HUklETElORV9FTkFCTEVEIH0gfSksXG4gIFtcIm9yZGluYWwtdGltZVwiIC8qIE9SRElOQUxfVElNRSAqL106IF9DaGFydFRoZW1lLmdldEF4aXNEZWZhdWx0cyh7XG4gICAgZ3JvdXBQYWRkaW5nSW5uZXI6IDAsXG4gICAgbGFiZWw6IHsgYXV0b1JvdGF0ZTogZmFsc2UgfSxcbiAgICBncmlkTGluZTogeyBlbmFibGVkOiBERUZBVUxUX0dSSURMSU5FX0VOQUJMRUQgfVxuICB9KSxcbiAgW1wiYW5nbGUtY2F0ZWdvcnlcIiAvKiBBTkdMRV9DQVRFR09SWSAqL106IF9DaGFydFRoZW1lLmdldEF4aXNEZWZhdWx0cyh7XG4gICAgZ3JpZExpbmU6IHsgZW5hYmxlZDogREVGQVVMVF9HUklETElORV9FTkFCTEVEIH1cbiAgfSksXG4gIFtcImFuZ2xlLW51bWJlclwiIC8qIEFOR0xFX05VTUJFUiAqL106IF9DaGFydFRoZW1lLmdldEF4aXNEZWZhdWx0cyh7IGdyaWRMaW5lOiB7IGVuYWJsZWQ6IERFRkFVTFRfR1JJRExJTkVfRU5BQkxFRCB9IH0pLFxuICBbXCJyYWRpdXMtY2F0ZWdvcnlcIiAvKiBSQURJVVNfQ0FURUdPUlkgKi9dOiBfQ2hhcnRUaGVtZS5nZXRBeGlzRGVmYXVsdHMoe1xuICAgIGxpbmU6IHsgZW5hYmxlZDogZmFsc2UgfVxuICB9KSxcbiAgW1wicmFkaXVzLW51bWJlclwiIC8qIFJBRElVU19OVU1CRVIgKi9dOiBfQ2hhcnRUaGVtZS5nZXRBeGlzRGVmYXVsdHMoe1xuICAgIGxpbmU6IHsgZW5hYmxlZDogZmFsc2UgfVxuICB9KSxcbiAgXCJncm91cGVkLWNhdGVnb3J5XCI6IF9DaGFydFRoZW1lLmdldEF4aXNEZWZhdWx0cyh7XG4gICAgdGljazogeyBlbmFibGVkOiB0cnVlIH1cbiAgfSlcbn07XG52YXIgQ2hhcnRUaGVtZSA9IF9DaGFydFRoZW1lO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC90aGVtZXMvZGFya1RoZW1lLnRzXG52YXIgREVGQVVMVF9EQVJLX0JBQ0tHUk9VTkRfRklMTCA9IFwiIzE5MjIzMlwiO1xudmFyIERFRkFVTFRfREFSS19GSUxMUyA9IHtcbiAgQkxVRTogXCIjNTA5MGRjXCIsXG4gIE9SQU5HRTogXCIjZmZhMDNhXCIsXG4gIEdSRUVOOiBcIiM0NTlkNTVcIixcbiAgQ1lBTjogXCIjMzRiZmUxXCIsXG4gIFlFTExPVzogXCIjZTFjYzAwXCIsXG4gIFZJT0xFVDogXCIjOTY2OWNiXCIsXG4gIEdSQVk6IFwiI2I1YjViNVwiLFxuICBNQUdFTlRBOiBcIiNiZDVhYTdcIixcbiAgQlJPV046IFwiIzhhNjIyNFwiLFxuICBSRUQ6IFwiI2VmNTQ1MlwiXG59O1xudmFyIERFRkFVTFRfREFSS19TVFJPS0VTID0ge1xuICBCTFVFOiBcIiM3NGE4ZTZcIixcbiAgT1JBTkdFOiBcIiNmZmJlNzBcIixcbiAgR1JFRU46IFwiIzZjYjE3NlwiLFxuICBDWUFOOiBcIiM3NWQ0ZWZcIixcbiAgWUVMTE9XOiBcIiNmNmU1NTlcIixcbiAgVklPTEVUOiBcIiNhYTg2ZDhcIixcbiAgR1JBWTogXCIjYTFhMWExXCIsXG4gIE1BR0VOVEE6IFwiI2NlN2FiOVwiLFxuICBCUk9XTjogXCIjOTk3YjUyXCIsXG4gIFJFRDogXCIjZmY3ODcyXCJcbn07XG52YXIgRGFya1RoZW1lID0gY2xhc3MgZXh0ZW5kcyBDaGFydFRoZW1lIHtcbiAgZ2V0RGVmYXVsdENvbG9ycygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZmlsbHM6IERFRkFVTFRfREFSS19GSUxMUyxcbiAgICAgIHN0cm9rZXM6IERFRkFVTFRfREFSS19TVFJPS0VTLFxuICAgICAgdXA6IHsgZmlsbDogREVGQVVMVF9EQVJLX0ZJTExTLkdSRUVOLCBzdHJva2U6IERFRkFVTFRfREFSS19TVFJPS0VTLkdSRUVOIH0sXG4gICAgICBkb3duOiB7IGZpbGw6IERFRkFVTFRfREFSS19GSUxMUy5SRUQsIHN0cm9rZTogREVGQVVMVF9EQVJLX1NUUk9LRVMuUkVEIH0sXG4gICAgICBuZXV0cmFsOiB7IGZpbGw6IERFRkFVTFRfREFSS19GSUxMUy5HUkFZLCBzdHJva2U6IERFRkFVTFRfREFSS19TVFJPS0VTLkdSQVkgfSxcbiAgICAgIGFsdFVwOiB7IGZpbGw6IERFRkFVTFRfREFSS19GSUxMUy5CTFVFLCBzdHJva2U6IERFRkFVTFRfREFSS19TVFJPS0VTLkJMVUUgfSxcbiAgICAgIGFsdERvd246IHsgZmlsbDogREVGQVVMVF9EQVJLX0ZJTExTLk9SQU5HRSwgc3Ryb2tlOiBERUZBVUxUX0RBUktfU1RST0tFUy5PUkFOR0UgfSxcbiAgICAgIGFsdE5ldXRyYWw6IHsgZmlsbDogREVGQVVMVF9EQVJLX0ZJTExTLkdSQVksIHN0cm9rZTogREVGQVVMVF9EQVJLX1NUUk9LRVMuR1JBWSB9XG4gICAgfTtcbiAgfVxuICBnZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKSB7XG4gICAgY29uc3QgcGFyYW1zID0gc3VwZXIuZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKCk7XG4gICAgcGFyYW1zLnNldChJU19EQVJLX1RIRU1FLCB0cnVlKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfUE9MQVJfU0VSSUVTX1NUUk9LRSwgREVGQVVMVF9EQVJLX0JBQ0tHUk9VTkRfRklMTCk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0xBQkVMX0NPTE9VUiwgXCJ3aGl0ZVwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfTVVURURfTEFCRUxfQ09MT1VSLCBcIiM3RDkxQTBcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FYSVNfR1JJRF9DT0xPVVIsIFwiIzU0NUE2RVwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQ1JPU1NfTElORVNfQ09MT1VSLCBcIndoaXRlXCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9ESVZFUkdJTkdfU0VSSUVTX0NPTE9SX1JBTkdFLCBbXG4gICAgICBERUZBVUxUX0RBUktfRklMTFMuT1JBTkdFLFxuICAgICAgREVGQVVMVF9EQVJLX0ZJTExTLllFTExPVyxcbiAgICAgIERFRkFVTFRfREFSS19GSUxMUy5HUkVFTlxuICAgIF0pO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9HQVVHRV9TRVJJRVNfQ09MT1JfUkFOR0UsIFtcbiAgICAgIERFRkFVTFRfREFSS19GSUxMUy5HUkVFTixcbiAgICAgIERFRkFVTFRfREFSS19GSUxMUy5ZRUxMT1csXG4gICAgICBERUZBVUxUX0RBUktfRklMTFMuUkVEXG4gICAgXSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0ZVTk5FTF9TRVJJRVNfQ09MT1JfUkFOR0UsIFtcbiAgICAgIFwiIzUwOTBkY1wiLFxuICAgICAgXCIjNDg4MmM2XCIsXG4gICAgICBcIiM0MDczYjBcIixcbiAgICAgIFwiIzM4NjU5YVwiLFxuICAgICAgXCIjMzA1Njg0XCIsXG4gICAgICBcIiMyODQ4NmVcIixcbiAgICAgIFwiIzIwM2E1OFwiLFxuICAgICAgXCIjMTgyYjQyXCJcbiAgICBdKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfSElFUkFSQ0hZX0ZJTExTLCBbXCIjMTkyODM0XCIsIFwiIzI1Mzc0NlwiLCBcIiMzMjQ4NTlcIiwgXCIjM2Y1OTZjXCIsIFwiIzRkNmE4MFwiXSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0hJRVJBUkNIWV9TVFJPS0VTLCBbXCIjMTkyODM0XCIsIFwiIzNiNTE2NFwiLCBcIiM0OTYyNzVcIiwgXCIjNTc3Mjg3XCIsIFwiIzY2ODM5OVwiXSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0JBQ0tHUk9VTkRfQ09MT1VSLCBERUZBVUxUX0RBUktfQkFDS0dST1VORF9GSUxMKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfSU5TSURFX1NFUklFU19MQUJFTF9DT0xPVVIsIERFRkFVTFRfREFSS19CQUNLR1JPVU5EX0ZJTEwpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX0NPTE9SLCBERUZBVUxUX0RBUktfRklMTFMuQkxVRSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX1RFWFRfQU5OT1RBVElPTl9DT0xPUiwgXCJ3aGl0ZVwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQU5OT1RBVElPTl9CQUNLR1JPVU5EX0ZJTEwsIERFRkFVTFRfREFSS19GSUxMUy5CTFVFKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQU5OT1RBVElPTl9IQU5ETEVfRklMTCwgREVGQVVMVF9EQVJLX0JBQ0tHUk9VTkRfRklMTCk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fU1RBVElTVElDU19GSUxMLCBcIiMyODMxM2VcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fU1RBVElTVElDU19TVFJPS0UsIFwiIzRiNTI1ZFwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQU5OT1RBVElPTl9TVEFUSVNUSUNTX0NPTE9SLCBcIiNmZmZmZmZcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fU1RBVElTVElDU19ESVZJREVSX1NUUk9LRSwgXCIjZmZmZmZmXCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9URVhUQk9YX0ZJTEwsIFwiIzI4MzEzZVwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfVEVYVEJPWF9TVFJPS0UsIFwiIzRiNTI1ZFwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfVEVYVEJPWF9DT0xPUiwgXCIjZmZmZmZmXCIpO1xuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC90aGVtZXMvZmluYW5jaWFsRGFyay50c1xudmFyIEZJTkFOQ0lBTF9EQVJLX0ZJTExTID0ge1xuICBHUkVFTjogXCIjMDg5OTgxXCIsXG4gIFJFRDogXCIjRjIzNjQ1XCIsXG4gIEJMVUU6IFwiIzUwOTBkY1wiLFxuICBHUkFZOiBcIiNBOUE5QTlcIlxufTtcbnZhciBGSU5BTkNJQUxfREFSS19TVFJPS0VTID0ge1xuICBHUkVFTjogXCIjMDg5OTgxXCIsXG4gIFJFRDogXCIjRjIzNjQ1XCIsXG4gIEJMVUU6IFwiIzUwOTBkY1wiLFxuICBHUkFZOiBcIiM5MDkwOTBcIlxufTtcbnZhciBGaW5hbmNpYWxEYXJrID0gY2xhc3MgZXh0ZW5kcyBEYXJrVGhlbWUge1xuICBnZXREZWZhdWx0Q29sb3JzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBmaWxsczogeyAuLi5GSU5BTkNJQUxfREFSS19GSUxMUyB9LFxuICAgICAgc3Ryb2tlczogeyAuLi5GSU5BTkNJQUxfREFSS19TVFJPS0VTIH0sXG4gICAgICB1cDogeyBmaWxsOiBGSU5BTkNJQUxfREFSS19GSUxMUy5HUkVFTiwgc3Ryb2tlOiBGSU5BTkNJQUxfREFSS19TVFJPS0VTLkdSRUVOIH0sXG4gICAgICBkb3duOiB7IGZpbGw6IEZJTkFOQ0lBTF9EQVJLX0ZJTExTLlJFRCwgc3Ryb2tlOiBGSU5BTkNJQUxfREFSS19TVFJPS0VTLlJFRCB9LFxuICAgICAgbmV1dHJhbDogeyBmaWxsOiBGSU5BTkNJQUxfREFSS19GSUxMUy5CTFVFLCBzdHJva2U6IEZJTkFOQ0lBTF9EQVJLX1NUUk9LRVMuQkxVRSB9LFxuICAgICAgYWx0VXA6IHsgZmlsbDogRklOQU5DSUFMX0RBUktfRklMTFMuR1JFRU4sIHN0cm9rZTogRklOQU5DSUFMX0RBUktfU1RST0tFUy5HUkVFTiB9LFxuICAgICAgYWx0RG93bjogeyBmaWxsOiBGSU5BTkNJQUxfREFSS19GSUxMUy5SRUQsIHN0cm9rZTogRklOQU5DSUFMX0RBUktfU1RST0tFUy5SRUQgfSxcbiAgICAgIGFsdE5ldXRyYWw6IHsgZmlsbDogRklOQU5DSUFMX0RBUktfRklMTFMuR1JBWSwgc3Ryb2tlOiBGSU5BTkNJQUxfREFSS19TVFJPS0VTLkdSQVkgfVxuICAgIH07XG4gIH1cbiAgZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHN1cGVyLmdldFRlbXBsYXRlUGFyYW1ldGVycygpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9ESVZFUkdJTkdfU0VSSUVTX0NPTE9SX1JBTkdFLCBbXG4gICAgICBGSU5BTkNJQUxfREFSS19GSUxMUy5HUkVFTixcbiAgICAgIEZJTkFOQ0lBTF9EQVJLX0ZJTExTLkJMVUUsXG4gICAgICBGSU5BTkNJQUxfREFSS19GSUxMUy5SRURcbiAgICBdKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQU5OT1RBVElPTl9DT0xPUiwgRklOQU5DSUFMX0RBUktfRklMTFMuQkxVRSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fQkFDS0dST1VORF9GSUxMLCBGSU5BTkNJQUxfREFSS19GSUxMUy5CTFVFKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQVhJU19HUklEX0NPTE9VUiwgXCIjMzQzQTRFXCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9QQURESU5HLCAwKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQ0FQVElPTl9MQVlPVVRfU1RZTEUsIFwib3ZlcmxheVwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQ0FQVElPTl9BTElHTk1FTlQsIFwibGVmdFwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfVE9PTEJBUl9QT1NJVElPTiwgXCJib3R0b21cIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0dSSURMSU5FX0VOQUJMRUQsIHRydWUpO1xuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3RoZW1lcy9maW5hbmNpYWxMaWdodC50c1xudmFyIEZJTkFOQ0lBTF9MSUdIVF9GSUxMUyA9IHtcbiAgR1JFRU46IFwiIzA4OTk4MVwiLFxuICBSRUQ6IFwiI0YyMzY0NVwiLFxuICBCTFVFOiBcIiM1MDkwZGNcIixcbiAgR1JBWTogXCIjQTlBOUE5XCJcbn07XG52YXIgRklOQU5DSUFMX0xJR0hUX1NUUk9LRVMgPSB7XG4gIEdSRUVOOiBcIiMwODk5ODFcIixcbiAgUkVEOiBcIiNGMjM2NDVcIixcbiAgQkxVRTogXCIjNTA5MGRjXCIsXG4gIEdSQVk6IFwiIzkwOTA5MFwiXG59O1xudmFyIEZpbmFuY2lhbExpZ2h0ID0gY2xhc3MgZXh0ZW5kcyBDaGFydFRoZW1lIHtcbiAgZ2V0RGVmYXVsdENvbG9ycygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZmlsbHM6IHsgLi4uRklOQU5DSUFMX0xJR0hUX0ZJTExTIH0sXG4gICAgICBzdHJva2VzOiB7IC4uLkZJTkFOQ0lBTF9MSUdIVF9TVFJPS0VTIH0sXG4gICAgICB1cDogeyBmaWxsOiBGSU5BTkNJQUxfTElHSFRfRklMTFMuR1JFRU4sIHN0cm9rZTogRklOQU5DSUFMX0xJR0hUX1NUUk9LRVMuR1JFRU4gfSxcbiAgICAgIGRvd246IHsgZmlsbDogRklOQU5DSUFMX0xJR0hUX0ZJTExTLlJFRCwgc3Ryb2tlOiBGSU5BTkNJQUxfTElHSFRfU1RST0tFUy5SRUQgfSxcbiAgICAgIG5ldXRyYWw6IHsgZmlsbDogRklOQU5DSUFMX0xJR0hUX0ZJTExTLkJMVUUsIHN0cm9rZTogRklOQU5DSUFMX0xJR0hUX1NUUk9LRVMuQkxVRSB9LFxuICAgICAgYWx0VXA6IHsgZmlsbDogRklOQU5DSUFMX0xJR0hUX0ZJTExTLkdSRUVOLCBzdHJva2U6IEZJTkFOQ0lBTF9MSUdIVF9TVFJPS0VTLkdSRUVOIH0sXG4gICAgICBhbHREb3duOiB7IGZpbGw6IEZJTkFOQ0lBTF9MSUdIVF9GSUxMUy5SRUQsIHN0cm9rZTogRklOQU5DSUFMX0xJR0hUX1NUUk9LRVMuUkVEIH0sXG4gICAgICBhbHROZXV0cmFsOiB7IGZpbGw6IEZJTkFOQ0lBTF9MSUdIVF9GSUxMUy5HUkFZLCBzdHJva2U6IEZJTkFOQ0lBTF9MSUdIVF9TVFJPS0VTLkdSQVkgfVxuICAgIH07XG4gIH1cbiAgZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHN1cGVyLmdldFRlbXBsYXRlUGFyYW1ldGVycygpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9ESVZFUkdJTkdfU0VSSUVTX0NPTE9SX1JBTkdFLCBbXG4gICAgICBGSU5BTkNJQUxfTElHSFRfRklMTFMuR1JFRU4sXG4gICAgICBGSU5BTkNJQUxfTElHSFRfRklMTFMuQkxVRSxcbiAgICAgIEZJTkFOQ0lBTF9MSUdIVF9GSUxMUy5SRURcbiAgICBdKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQU5OT1RBVElPTl9DT0xPUiwgRklOQU5DSUFMX0xJR0hUX0ZJTExTLkJMVUUpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX0JBQ0tHUk9VTkRfRklMTCwgRklOQU5DSUFMX0xJR0hUX0ZJTExTLkJMVUUpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BWElTX0dSSURfQ09MT1VSLCBcIiNGMkYzRjNcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX1BBRERJTkcsIDApO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9DQVBUSU9OX0xBWU9VVF9TVFlMRSwgXCJvdmVybGF5XCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9DQVBUSU9OX0FMSUdOTUVOVCwgXCJsZWZ0XCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9UT09MQkFSX1BPU0lUSU9OLCBcImJvdHRvbVwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfR1JJRExJTkVfRU5BQkxFRCwgdHJ1ZSk7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvdGhlbWVzL21hdGVyaWFsRGFyay50c1xudmFyIE1BVEVSSUFMX0RBUktfRklMTFMgPSB7XG4gIEJMVUU6IFwiIzIxOTZGM1wiLFxuICBPUkFOR0U6IFwiI0ZGOTgwMFwiLFxuICBHUkVFTjogXCIjNENBRjUwXCIsXG4gIENZQU46IFwiIzAwQkNENFwiLFxuICBZRUxMT1c6IFwiI0ZGRUIzQlwiLFxuICBWSU9MRVQ6IFwiIzdFNTdDMlwiLFxuICBHUkFZOiBcIiM5RTlFOUVcIixcbiAgTUFHRU5UQTogXCIjRjA2MjkyXCIsXG4gIEJST1dOOiBcIiM3OTU1NDhcIixcbiAgUkVEOiBcIiNGNDQzMzZcIlxufTtcbnZhciBNQVRFUklBTF9EQVJLX1NUUk9LRVMgPSB7XG4gIEJMVUU6IFwiIzkwQ0FGOVwiLFxuICBPUkFOR0U6IFwiI0ZGQ0M4MFwiLFxuICBHUkVFTjogXCIjQTVENkE3XCIsXG4gIENZQU46IFwiIzgwREVFQVwiLFxuICBZRUxMT1c6IFwiI0ZGRjlDNFwiLFxuICBWSU9MRVQ6IFwiI0IzOUREQlwiLFxuICBHUkFZOiBcIiNFMEUwRTBcIixcbiAgTUFHRU5UQTogXCIjRjQ4RkIxXCIsXG4gIEJST1dOOiBcIiNBMTg4N0ZcIixcbiAgUkVEOiBcIiNFRjlBOUFcIlxufTtcbnZhciBNYXRlcmlhbERhcmsgPSBjbGFzcyBleHRlbmRzIERhcmtUaGVtZSB7XG4gIGdldERlZmF1bHRDb2xvcnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpbGxzOiBNQVRFUklBTF9EQVJLX0ZJTExTLFxuICAgICAgc3Ryb2tlczogTUFURVJJQUxfREFSS19TVFJPS0VTLFxuICAgICAgdXA6IHsgZmlsbDogTUFURVJJQUxfREFSS19GSUxMUy5HUkVFTiwgc3Ryb2tlOiBNQVRFUklBTF9EQVJLX1NUUk9LRVMuR1JFRU4gfSxcbiAgICAgIGRvd246IHsgZmlsbDogTUFURVJJQUxfREFSS19GSUxMUy5SRUQsIHN0cm9rZTogTUFURVJJQUxfREFSS19TVFJPS0VTLlJFRCB9LFxuICAgICAgbmV1dHJhbDogeyBmaWxsOiBNQVRFUklBTF9EQVJLX0ZJTExTLkdSQVksIHN0cm9rZTogTUFURVJJQUxfREFSS19TVFJPS0VTLkdSQVkgfSxcbiAgICAgIGFsdFVwOiB7IGZpbGw6IE1BVEVSSUFMX0RBUktfRklMTFMuQkxVRSwgc3Ryb2tlOiBNQVRFUklBTF9EQVJLX1NUUk9LRVMuQkxVRSB9LFxuICAgICAgYWx0RG93bjogeyBmaWxsOiBNQVRFUklBTF9EQVJLX0ZJTExTLlJFRCwgc3Ryb2tlOiBNQVRFUklBTF9EQVJLX1NUUk9LRVMuUkVEIH0sXG4gICAgICBhbHROZXV0cmFsOiB7IGZpbGw6IE1BVEVSSUFMX0RBUktfRklMTFMuR1JBWSwgc3Ryb2tlOiBNQVRFUklBTF9EQVJLX1NUUk9LRVMuR1JBWSB9XG4gICAgfTtcbiAgfVxuICBnZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKSB7XG4gICAgY29uc3QgcGFyYW1zID0gc3VwZXIuZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKCk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0RJVkVSR0lOR19TRVJJRVNfQ09MT1JfUkFOR0UsIFtcbiAgICAgIE1BVEVSSUFMX0RBUktfRklMTFMuT1JBTkdFLFxuICAgICAgTUFURVJJQUxfREFSS19GSUxMUy5ZRUxMT1csXG4gICAgICBNQVRFUklBTF9EQVJLX0ZJTExTLkdSRUVOXG4gICAgXSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0ZVTk5FTF9TRVJJRVNfQ09MT1JfUkFOR0UsIFtcbiAgICAgIFwiIzIxOTZmM1wiLFxuICAgICAgLy8gNTAwXG4gICAgICBcIiMyMDhGRUNcIixcbiAgICAgIC8vIChpbnRlcnBvbGF0ZWQpXG4gICAgICBcIiMxRTg4RTVcIixcbiAgICAgIC8vIDYwMFxuICAgICAgXCIjMUM3RkRDXCIsXG4gICAgICAvLyAoaW50ZXJwb2xhdGVkKVxuICAgICAgXCIjMTk3NmQyXCIsXG4gICAgICAvLyA3MDBcbiAgICAgIFwiIzE3NkVDOVwiLFxuICAgICAgLy8gKGludGVycG9sYXRlZClcbiAgICAgIFwiIzE1NjVjMFwiXG4gICAgICAvLyA4MDBcbiAgICBdKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfR0FVR0VfU0VSSUVTX0NPTE9SX1JBTkdFLCBbXG4gICAgICBNQVRFUklBTF9EQVJLX0ZJTExTLkdSRUVOLFxuICAgICAgTUFURVJJQUxfREFSS19GSUxMUy5ZRUxMT1csXG4gICAgICBNQVRFUklBTF9EQVJLX0ZJTExTLlJFRFxuICAgIF0pO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX0NPTE9SLCBNQVRFUklBTF9EQVJLX0ZJTExTLkJMVUUpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX0JBQ0tHUk9VTkRfRklMTCwgTUFURVJJQUxfREFSS19GSUxMUy5CTFVFKTtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC90aGVtZXMvbWF0ZXJpYWxMaWdodC50c1xudmFyIE1BVEVSSUFMX0xJR0hUX0ZJTExTID0ge1xuICBCTFVFOiBcIiMyMTk2RjNcIixcbiAgT1JBTkdFOiBcIiNGRjk4MDBcIixcbiAgR1JFRU46IFwiIzRDQUY1MFwiLFxuICBDWUFOOiBcIiMwMEJDRDRcIixcbiAgWUVMTE9XOiBcIiNGRkVCM0JcIixcbiAgVklPTEVUOiBcIiM3RTU3QzJcIixcbiAgR1JBWTogXCIjOUU5RTlFXCIsXG4gIE1BR0VOVEE6IFwiI0YwNjI5MlwiLFxuICBCUk9XTjogXCIjNzk1NTQ4XCIsXG4gIFJFRDogXCIjRjQ0MzM2XCJcbn07XG52YXIgTUFURVJJQUxfTElHSFRfU1RST0tFUyA9IHtcbiAgQkxVRTogXCIjMTU2NUMwXCIsXG4gIE9SQU5HRTogXCIjRTY1MTAwXCIsXG4gIEdSRUVOOiBcIiMyRTdEMzJcIixcbiAgQ1lBTjogXCIjMDA4MzhGXCIsXG4gIFlFTExPVzogXCIjRjlBODI1XCIsXG4gIFZJT0xFVDogXCIjNDUyN0EwXCIsXG4gIEdSQVk6IFwiIzYxNjE2MVwiLFxuICBNQUdFTlRBOiBcIiNDMjE4NUJcIixcbiAgQlJPV046IFwiIzRFMzQyRVwiLFxuICBSRUQ6IFwiI0I3MUMxQ1wiXG59O1xudmFyIE1hdGVyaWFsTGlnaHQgPSBjbGFzcyBleHRlbmRzIENoYXJ0VGhlbWUge1xuICBnZXREZWZhdWx0Q29sb3JzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBmaWxsczogTUFURVJJQUxfTElHSFRfRklMTFMsXG4gICAgICBzdHJva2VzOiBNQVRFUklBTF9MSUdIVF9TVFJPS0VTLFxuICAgICAgdXA6IHsgZmlsbDogTUFURVJJQUxfTElHSFRfRklMTFMuR1JFRU4sIHN0cm9rZTogTUFURVJJQUxfTElHSFRfU1RST0tFUy5HUkVFTiB9LFxuICAgICAgZG93bjogeyBmaWxsOiBNQVRFUklBTF9MSUdIVF9GSUxMUy5SRUQsIHN0cm9rZTogTUFURVJJQUxfTElHSFRfU1RST0tFUy5SRUQgfSxcbiAgICAgIG5ldXRyYWw6IHsgZmlsbDogTUFURVJJQUxfTElHSFRfRklMTFMuR1JBWSwgc3Ryb2tlOiBNQVRFUklBTF9MSUdIVF9TVFJPS0VTLkdSQVkgfSxcbiAgICAgIGFsdFVwOiB7IGZpbGw6IE1BVEVSSUFMX0xJR0hUX0ZJTExTLkJMVUUsIHN0cm9rZTogTUFURVJJQUxfTElHSFRfU1RST0tFUy5CTFVFIH0sXG4gICAgICBhbHREb3duOiB7IGZpbGw6IE1BVEVSSUFMX0xJR0hUX0ZJTExTLlJFRCwgc3Ryb2tlOiBNQVRFUklBTF9MSUdIVF9TVFJPS0VTLlJFRCB9LFxuICAgICAgYWx0TmV1dHJhbDogeyBmaWxsOiBNQVRFUklBTF9MSUdIVF9GSUxMUy5HUkFZLCBzdHJva2U6IE1BVEVSSUFMX0xJR0hUX1NUUk9LRVMuR1JBWSB9XG4gICAgfTtcbiAgfVxuICBnZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKSB7XG4gICAgY29uc3QgcGFyYW1zID0gc3VwZXIuZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKCk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0RJVkVSR0lOR19TRVJJRVNfQ09MT1JfUkFOR0UsIFtcbiAgICAgIE1BVEVSSUFMX0xJR0hUX0ZJTExTLk9SQU5HRSxcbiAgICAgIE1BVEVSSUFMX0xJR0hUX0ZJTExTLllFTExPVyxcbiAgICAgIE1BVEVSSUFMX0xJR0hUX0ZJTExTLkdSRUVOXG4gICAgXSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0ZVTk5FTF9TRVJJRVNfQ09MT1JfUkFOR0UsIFtcbiAgICAgIFwiIzIxOTZmM1wiLFxuICAgICAgLy8gNTAwXG4gICAgICBcIiMzMjlFRjRcIixcbiAgICAgIC8vIChpbnRlcnBvbGF0ZWQpXG4gICAgICBcIiM0MmE1ZjVcIixcbiAgICAgIC8vIDQwMFxuICAgICAgXCIjNTNBREY2XCIsXG4gICAgICAvLyAoaW50ZXJwb2xhdGVkKVxuICAgICAgXCIjNjRiNWY2XCIsXG4gICAgICAvLyAzMDBcbiAgICAgIFwiIzdBQzBGOFwiLFxuICAgICAgLy8gKGludGVycG9sYXRlZClcbiAgICAgIFwiIzkwY2FmOVwiXG4gICAgICAvLyAyMDBcbiAgICBdKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfR0FVR0VfU0VSSUVTX0NPTE9SX1JBTkdFLCBbXG4gICAgICBNQVRFUklBTF9MSUdIVF9GSUxMUy5HUkVFTixcbiAgICAgIE1BVEVSSUFMX0xJR0hUX0ZJTExTLllFTExPVyxcbiAgICAgIE1BVEVSSUFMX0xJR0hUX0ZJTExTLlJFRFxuICAgIF0pO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX0NPTE9SLCBNQVRFUklBTF9MSUdIVF9GSUxMUy5CTFVFKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQU5OT1RBVElPTl9CQUNLR1JPVU5EX0ZJTEwsIE1BVEVSSUFMX0xJR0hUX0ZJTExTLkJMVUUpO1xuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3RoZW1lcy9wb2x5Y2hyb21hRGFyay50c1xudmFyIFBPTFlDSFJPTUFfREFSS19GSUxMUyA9IHtcbiAgQkxVRTogXCIjNDM2ZmY0XCIsXG4gIFBVUlBMRTogXCIjOWE3YmZmXCIsXG4gIE1BR0VOVEE6IFwiI2QxNjVkMlwiLFxuICBQSU5LOiBcIiNmMDU5OGJcIixcbiAgUkVEOiBcIiNmNDczNDhcIixcbiAgT1JBTkdFOiBcIiNmMmE2MDJcIixcbiAgWUVMTE9XOiBcIiNlOWUyMDFcIixcbiAgR1JFRU46IFwiIzIxYjQ0OFwiLFxuICBDWUFOOiBcIiMwMGI5YTJcIixcbiAgTU9ERVJBVEVfQkxVRTogXCIjMDBhZWU0XCIsXG4gIEdSQVk6IFwiI2JiYmJiYlwiXG59O1xudmFyIFBPTFlDSFJPTUFfREFSS19TVFJPS0VTID0ge1xuICBCTFVFOiBcIiM2Njk4ZmZcIixcbiAgUFVSUExFOiBcIiNjMGEzZmZcIixcbiAgTUFHRU5UQTogXCIjZmM4ZGZjXCIsXG4gIFBJTks6IFwiI2ZmODJiMVwiLFxuICBSRUQ6IFwiI2ZmOWI3MFwiLFxuICBPUkFOR0U6IFwiI2ZmY2Y0ZVwiLFxuICBZRUxMT1c6IFwiI2ZmZmY1OFwiLFxuICBHUkVFTjogXCIjNThkZDcwXCIsXG4gIENZQU46IFwiIzUxZTJjOVwiLFxuICBNT0RFUkFURV9CTFVFOiBcIiM0ZmQ3ZmZcIixcbiAgR1JBWTogXCIjZWVlZWVlXCJcbn07XG52YXIgUG9seWNocm9tYURhcmsgPSBjbGFzcyBleHRlbmRzIERhcmtUaGVtZSB7XG4gIGdldERlZmF1bHRDb2xvcnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpbGxzOiBQT0xZQ0hST01BX0RBUktfRklMTFMsXG4gICAgICBzdHJva2VzOiBQT0xZQ0hST01BX0RBUktfU1RST0tFUyxcbiAgICAgIHVwOiB7IGZpbGw6IFBPTFlDSFJPTUFfREFSS19GSUxMUy5HUkVFTiwgc3Ryb2tlOiBQT0xZQ0hST01BX0RBUktfU1RST0tFUy5HUkVFTiB9LFxuICAgICAgZG93bjogeyBmaWxsOiBQT0xZQ0hST01BX0RBUktfRklMTFMuUkVELCBzdHJva2U6IFBPTFlDSFJPTUFfREFSS19TVFJPS0VTLlJFRCB9LFxuICAgICAgbmV1dHJhbDogeyBmaWxsOiBQT0xZQ0hST01BX0RBUktfRklMTFMuR1JBWSwgc3Ryb2tlOiBQT0xZQ0hST01BX0RBUktfU1RST0tFUy5HUkFZIH0sXG4gICAgICBhbHRVcDogeyBmaWxsOiBQT0xZQ0hST01BX0RBUktfRklMTFMuQkxVRSwgc3Ryb2tlOiBQT0xZQ0hST01BX0RBUktfU1RST0tFUy5CTFVFIH0sXG4gICAgICBhbHREb3duOiB7IGZpbGw6IFBPTFlDSFJPTUFfREFSS19GSUxMUy5SRUQsIHN0cm9rZTogUE9MWUNIUk9NQV9EQVJLX1NUUk9LRVMuUkVEIH0sXG4gICAgICBhbHROZXV0cmFsOiB7IGZpbGw6IFBPTFlDSFJPTUFfREFSS19GSUxMUy5HUkFZLCBzdHJva2U6IFBPTFlDSFJPTUFfREFSS19TVFJPS0VTLkdSQVkgfVxuICAgIH07XG4gIH1cbiAgZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHN1cGVyLmdldFRlbXBsYXRlUGFyYW1ldGVycygpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9ESVZFUkdJTkdfU0VSSUVTX0NPTE9SX1JBTkdFLCBbUE9MWUNIUk9NQV9EQVJLX0ZJTExTLkJMVUUsIFBPTFlDSFJPTUFfREFSS19GSUxMUy5SRURdKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfRlVOTkVMX1NFUklFU19DT0xPUl9SQU5HRSwgW1xuICAgICAgUE9MWUNIUk9NQV9EQVJLX0ZJTExTLkJMVUUsXG4gICAgICBQT0xZQ0hST01BX0RBUktfRklMTFMuUFVSUExFLFxuICAgICAgUE9MWUNIUk9NQV9EQVJLX0ZJTExTLk1BR0VOVEEsXG4gICAgICBQT0xZQ0hST01BX0RBUktfRklMTFMuUElOSyxcbiAgICAgIFBPTFlDSFJPTUFfREFSS19GSUxMUy5SRUQsXG4gICAgICBQT0xZQ0hST01BX0RBUktfRklMTFMuT1JBTkdFLFxuICAgICAgUE9MWUNIUk9NQV9EQVJLX0ZJTExTLllFTExPVyxcbiAgICAgIFBPTFlDSFJPTUFfREFSS19GSUxMUy5HUkVFTlxuICAgIF0pO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9HQVVHRV9TRVJJRVNfQ09MT1JfUkFOR0UsIFtQT0xZQ0hST01BX0RBUktfRklMTFMuQkxVRSwgUE9MWUNIUk9NQV9EQVJLX0ZJTExTLlJFRF0pO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX0NPTE9SLCBQT0xZQ0hST01BX0RBUktfRklMTFMuQkxVRSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fQkFDS0dST1VORF9GSUxMLCBQT0xZQ0hST01BX0RBUktfRklMTFMuQkxVRSk7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvdGhlbWVzL3BvbHljaHJvbWFMaWdodC50c1xudmFyIFBPTFlDSFJPTUFfTElHSFRfRklMTFMgPSB7XG4gIEJMVUU6IFwiIzQzNmZmNFwiLFxuICBQVVJQTEU6IFwiIzlhN2JmZlwiLFxuICBNQUdFTlRBOiBcIiNkMTY1ZDJcIixcbiAgUElOSzogXCIjZjA1OThiXCIsXG4gIFJFRDogXCIjZjQ3MzQ4XCIsXG4gIE9SQU5HRTogXCIjZjJhNjAyXCIsXG4gIFlFTExPVzogXCIjZTllMjAxXCIsXG4gIEdSRUVOOiBcIiMyMWI0NDhcIixcbiAgQ1lBTjogXCIjMDBiOWEyXCIsXG4gIE1PREVSQVRFX0JMVUU6IFwiIzAwYWVlNFwiLFxuICBHUkFZOiBcIiNiYmJiYmJcIlxufTtcbnZhciBQT0xZQ0hST01BX0xJR0hUX1NUUk9LRVMgPSB7XG4gIEJMVUU6IFwiIzIzNDZjOVwiLFxuICBQVVJQTEU6IFwiIzc2NTNkNFwiLFxuICBNQUdFTlRBOiBcIiNhNzNkYTlcIixcbiAgUElOSzogXCIjYzMyZDY2XCIsXG4gIFJFRDogXCIjYzg0YjFjXCIsXG4gIE9SQU5HRTogXCIjYzg3ZjAwXCIsXG4gIFlFTExPVzogXCIjYzFiOTAwXCIsXG4gIEdSRUVOOiBcIiMwMDhjMWNcIixcbiAgQ1lBTjogXCIjMDA5MjdjXCIsXG4gIE1PREVSQVRFX0JMVUU6IFwiIzAwODdiYlwiLFxuICBHUkFZOiBcIiM4ODg4ODhcIlxufTtcbnZhciBQb2x5Y2hyb21hTGlnaHQgPSBjbGFzcyBleHRlbmRzIENoYXJ0VGhlbWUge1xuICBnZXREZWZhdWx0Q29sb3JzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBmaWxsczogUE9MWUNIUk9NQV9MSUdIVF9GSUxMUyxcbiAgICAgIHN0cm9rZXM6IFBPTFlDSFJPTUFfTElHSFRfU1RST0tFUyxcbiAgICAgIHVwOiB7IGZpbGw6IFBPTFlDSFJPTUFfTElHSFRfRklMTFMuR1JFRU4sIHN0cm9rZTogUE9MWUNIUk9NQV9MSUdIVF9TVFJPS0VTLkdSRUVOIH0sXG4gICAgICBkb3duOiB7IGZpbGw6IFBPTFlDSFJPTUFfTElHSFRfRklMTFMuUkVELCBzdHJva2U6IFBPTFlDSFJPTUFfTElHSFRfU1RST0tFUy5SRUQgfSxcbiAgICAgIG5ldXRyYWw6IHsgZmlsbDogUE9MWUNIUk9NQV9MSUdIVF9GSUxMUy5HUkFZLCBzdHJva2U6IFBPTFlDSFJPTUFfTElHSFRfU1RST0tFUy5HUkFZIH0sXG4gICAgICBhbHRVcDogeyBmaWxsOiBQT0xZQ0hST01BX0xJR0hUX0ZJTExTLkJMVUUsIHN0cm9rZTogUE9MWUNIUk9NQV9MSUdIVF9TVFJPS0VTLkJMVUUgfSxcbiAgICAgIGFsdERvd246IHsgZmlsbDogUE9MWUNIUk9NQV9MSUdIVF9GSUxMUy5SRUQsIHN0cm9rZTogUE9MWUNIUk9NQV9MSUdIVF9TVFJPS0VTLlJFRCB9LFxuICAgICAgYWx0TmV1dHJhbDogeyBmaWxsOiBQT0xZQ0hST01BX0xJR0hUX0ZJTExTLkdSQVksIHN0cm9rZTogUE9MWUNIUk9NQV9MSUdIVF9TVFJPS0VTLkdSQVkgfVxuICAgIH07XG4gIH1cbiAgZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHN1cGVyLmdldFRlbXBsYXRlUGFyYW1ldGVycygpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9ESVZFUkdJTkdfU0VSSUVTX0NPTE9SX1JBTkdFLCBbUE9MWUNIUk9NQV9MSUdIVF9GSUxMUy5CTFVFLCBQT0xZQ0hST01BX0xJR0hUX0ZJTExTLlJFRF0pO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9GVU5ORUxfU0VSSUVTX0NPTE9SX1JBTkdFLCBbXG4gICAgICBQT0xZQ0hST01BX0xJR0hUX0ZJTExTLkJMVUUsXG4gICAgICBQT0xZQ0hST01BX0xJR0hUX0ZJTExTLlBVUlBMRSxcbiAgICAgIFBPTFlDSFJPTUFfTElHSFRfRklMTFMuTUFHRU5UQSxcbiAgICAgIFBPTFlDSFJPTUFfTElHSFRfRklMTFMuUElOSyxcbiAgICAgIFBPTFlDSFJPTUFfTElHSFRfRklMTFMuUkVELFxuICAgICAgUE9MWUNIUk9NQV9MSUdIVF9GSUxMUy5PUkFOR0UsXG4gICAgICBQT0xZQ0hST01BX0xJR0hUX0ZJTExTLllFTExPVyxcbiAgICAgIFBPTFlDSFJPTUFfTElHSFRfRklMTFMuR1JFRU5cbiAgICBdKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfR0FVR0VfU0VSSUVTX0NPTE9SX1JBTkdFLCBbUE9MWUNIUk9NQV9MSUdIVF9GSUxMUy5CTFVFLCBQT0xZQ0hST01BX0xJR0hUX0ZJTExTLlJFRF0pO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX0NPTE9SLCBQT0xZQ0hST01BX0xJR0hUX0ZJTExTLkJMVUUpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX0JBQ0tHUk9VTkRfRklMTCwgUE9MWUNIUk9NQV9MSUdIVF9GSUxMUy5CTFVFKTtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC90aGVtZXMvc2hlZXRzRGFyay50c1xudmFyIFNIRUVUU19EQVJLX0ZJTExTID0ge1xuICBCTFVFOiBcIiM0NDcyQzRcIixcbiAgT1JBTkdFOiBcIiNFRDdEMzFcIixcbiAgR1JBWTogXCIjQTVBNUE1XCIsXG4gIFlFTExPVzogXCIjRkZDMDAwXCIsXG4gIE1PREVSQVRFX0JMVUU6IFwiIzVCOUJENVwiLFxuICBHUkVFTjogXCIjNzBBRDQ3XCIsXG4gIERBUktfR1JBWTogXCIjN0I3QjdCXCIsXG4gIERBUktfQkxVRTogXCIjMjY0NDc4XCIsXG4gIFZFUllfREFSS19HUkFZOiBcIiM2MzYzNjNcIixcbiAgREFSS19ZRUxMT1c6IFwiIzk5NzMwMFwiXG59O1xudmFyIFNIRUVUU19EQVJLX1NUUk9LRVMgPSB7XG4gIEJMVUU6IFwiIzY4OTllZVwiLFxuICBPUkFOR0U6IFwiI2ZmYTU1ZFwiLFxuICBHUkFZOiBcIiNjZGNkY2RcIixcbiAgWUVMTE9XOiBcIiNmZmVhNTNcIixcbiAgTU9ERVJBVEVfQkxVRTogXCIjODJjM2ZmXCIsXG4gIEdSRUVOOiBcIiM5NmQ1NmZcIixcbiAgREFSS19HUkFZOiBcIiNhMWExYTFcIixcbiAgREFSS19CTFVFOiBcIiM0NzY4OWZcIixcbiAgVkVSWV9EQVJLX0dSQVk6IFwiIzg3ODc4N1wiLFxuICBEQVJLX1lFTExPVzogXCIjYzA5OTNkXCJcbn07XG52YXIgU2hlZXRzRGFyayA9IGNsYXNzIGV4dGVuZHMgRGFya1RoZW1lIHtcbiAgZ2V0RGVmYXVsdENvbG9ycygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZmlsbHM6IHsgLi4uU0hFRVRTX0RBUktfRklMTFMsIFJFRDogU0hFRVRTX0RBUktfRklMTFMuT1JBTkdFIH0sXG4gICAgICBzdHJva2VzOiB7IC4uLlNIRUVUU19EQVJLX1NUUk9LRVMsIFJFRDogU0hFRVRTX0RBUktfU1RST0tFUy5PUkFOR0UgfSxcbiAgICAgIHVwOiB7IGZpbGw6IFNIRUVUU19EQVJLX0ZJTExTLkdSRUVOLCBzdHJva2U6IFNIRUVUU19EQVJLX1NUUk9LRVMuR1JFRU4gfSxcbiAgICAgIGRvd246IHsgZmlsbDogU0hFRVRTX0RBUktfRklMTFMuT1JBTkdFLCBzdHJva2U6IFNIRUVUU19EQVJLX1NUUk9LRVMuT1JBTkdFIH0sXG4gICAgICBuZXV0cmFsOiB7IGZpbGw6IFNIRUVUU19EQVJLX0ZJTExTLkdSQVksIHN0cm9rZTogU0hFRVRTX0RBUktfU1RST0tFUy5HUkFZIH0sXG4gICAgICBhbHRVcDogeyBmaWxsOiBTSEVFVFNfREFSS19GSUxMUy5CTFVFLCBzdHJva2U6IFNIRUVUU19EQVJLX1NUUk9LRVMuQkxVRSB9LFxuICAgICAgYWx0RG93bjogeyBmaWxsOiBTSEVFVFNfREFSS19GSUxMUy5PUkFOR0UsIHN0cm9rZTogU0hFRVRTX0RBUktfU1RST0tFUy5PUkFOR0UgfSxcbiAgICAgIGFsdE5ldXRyYWw6IHsgZmlsbDogU0hFRVRTX0RBUktfRklMTFMuR1JBWSwgc3Ryb2tlOiBTSEVFVFNfREFSS19TVFJPS0VTLkdSQVkgfVxuICAgIH07XG4gIH1cbiAgZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHN1cGVyLmdldFRlbXBsYXRlUGFyYW1ldGVycygpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9ESVZFUkdJTkdfU0VSSUVTX0NPTE9SX1JBTkdFLCBbXG4gICAgICBTSEVFVFNfREFSS19GSUxMUy5PUkFOR0UsXG4gICAgICBTSEVFVFNfREFSS19GSUxMUy5ZRUxMT1csXG4gICAgICBTSEVFVFNfREFSS19GSUxMUy5HUkVFTlxuICAgIF0pO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9HQVVHRV9TRVJJRVNfQ09MT1JfUkFOR0UsIFtcbiAgICAgIFNIRUVUU19EQVJLX0ZJTExTLkdSRUVOLFxuICAgICAgU0hFRVRTX0RBUktfRklMTFMuWUVMTE9XLFxuICAgICAgU0hFRVRTX0RBUktfRklMTFMuT1JBTkdFXG4gICAgXSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fQ09MT1IsIFNIRUVUU19EQVJLX0ZJTExTLkJMVUUpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX0JBQ0tHUk9VTkRfRklMTCwgU0hFRVRTX0RBUktfRklMTFMuQkxVRSk7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvdGhlbWVzL3NoZWV0c0xpZ2h0LnRzXG52YXIgU0hFRVRTX0xJR0hUX0ZJTExTID0ge1xuICBCTFVFOiBcIiM1MjgxZDVcIixcbiAgT1JBTkdFOiBcIiNmZjhkNDRcIixcbiAgR1JBWTogXCIjYjViNWI1XCIsXG4gIFlFTExPVzogXCIjZmZkMDJmXCIsXG4gIE1PREVSQVRFX0JMVUU6IFwiIzZhYWJlNlwiLFxuICBHUkVFTjogXCIjN2ZiZDU3XCIsXG4gIERBUktfR1JBWTogXCIjOGE4YThhXCIsXG4gIERBUktfQkxVRTogXCIjMzM1Mjg3XCIsXG4gIFZFUllfREFSS19HUkFZOiBcIiM3MTcxNzFcIixcbiAgREFSS19ZRUxMT1c6IFwiI2E5ODIyMFwiXG59O1xudmFyIFNIRUVUU19MSUdIVF9TVFJPS0VTID0ge1xuICBCTFVFOiBcIiMyMTRkOWJcIixcbiAgT1JBTkdFOiBcIiNjMjU2MDBcIixcbiAgR1JBWTogXCIjN2Y3ZjdmXCIsXG4gIFlFTExPVzogXCIjZDU5ODAwXCIsXG4gIE1PREVSQVRFX0JMVUU6IFwiIzM1NzVhY1wiLFxuICBHUkVFTjogXCIjNGI4NjFhXCIsXG4gIERBUktfR1JBWTogXCIjNTc1NzU3XCIsXG4gIERBUktfQkxVRTogXCIjMDYyMjUzXCIsXG4gIFZFUllfREFSS19HUkFZOiBcIiM0MTQxNDFcIixcbiAgREFSS19ZRUxMT1c6IFwiIzczNGYwMFwiXG59O1xudmFyIFNoZWV0c0xpZ2h0ID0gY2xhc3MgZXh0ZW5kcyBDaGFydFRoZW1lIHtcbiAgZ2V0RGVmYXVsdENvbG9ycygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZmlsbHM6IHsgLi4uU0hFRVRTX0xJR0hUX0ZJTExTLCBSRUQ6IFNIRUVUU19MSUdIVF9GSUxMUy5PUkFOR0UgfSxcbiAgICAgIHN0cm9rZXM6IHsgLi4uU0hFRVRTX0xJR0hUX1NUUk9LRVMsIFJFRDogU0hFRVRTX0xJR0hUX1NUUk9LRVMuT1JBTkdFIH0sXG4gICAgICB1cDogeyBmaWxsOiBTSEVFVFNfTElHSFRfRklMTFMuR1JFRU4sIHN0cm9rZTogU0hFRVRTX0xJR0hUX1NUUk9LRVMuR1JFRU4gfSxcbiAgICAgIGRvd246IHsgZmlsbDogU0hFRVRTX0xJR0hUX0ZJTExTLk9SQU5HRSwgc3Ryb2tlOiBTSEVFVFNfTElHSFRfU1RST0tFUy5PUkFOR0UgfSxcbiAgICAgIG5ldXRyYWw6IHsgZmlsbDogU0hFRVRTX0xJR0hUX1NUUk9LRVMuR1JBWSwgc3Ryb2tlOiBTSEVFVFNfTElHSFRfU1RST0tFUy5HUkFZIH0sXG4gICAgICBhbHRVcDogeyBmaWxsOiBTSEVFVFNfTElHSFRfRklMTFMuQkxVRSwgc3Ryb2tlOiBTSEVFVFNfTElHSFRfU1RST0tFUy5CTFVFIH0sXG4gICAgICBhbHREb3duOiB7IGZpbGw6IFNIRUVUU19MSUdIVF9GSUxMUy5PUkFOR0UsIHN0cm9rZTogU0hFRVRTX0xJR0hUX1NUUk9LRVMuT1JBTkdFIH0sXG4gICAgICBhbHROZXV0cmFsOiB7IGZpbGw6IFNIRUVUU19MSUdIVF9GSUxMUy5HUkFZLCBzdHJva2U6IFNIRUVUU19MSUdIVF9TVFJPS0VTLkdSQVkgfVxuICAgIH07XG4gIH1cbiAgZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHN1cGVyLmdldFRlbXBsYXRlUGFyYW1ldGVycygpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9ESVZFUkdJTkdfU0VSSUVTX0NPTE9SX1JBTkdFLCBbXG4gICAgICBTSEVFVFNfTElHSFRfRklMTFMuT1JBTkdFLFxuICAgICAgU0hFRVRTX0xJR0hUX0ZJTExTLllFTExPVyxcbiAgICAgIFNIRUVUU19MSUdIVF9GSUxMUy5HUkVFTlxuICAgIF0pO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9HQVVHRV9TRVJJRVNfQ09MT1JfUkFOR0UsIFtcbiAgICAgIFNIRUVUU19MSUdIVF9GSUxMUy5HUkVFTixcbiAgICAgIFNIRUVUU19MSUdIVF9GSUxMUy5ZRUxMT1csXG4gICAgICBTSEVFVFNfTElHSFRfRklMTFMuT1JBTkdFXG4gICAgXSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fQ09MT1IsIFNIRUVUU19MSUdIVF9GSUxMUy5CTFVFKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQU5OT1RBVElPTl9CQUNLR1JPVU5EX0ZJTEwsIFNIRUVUU19MSUdIVF9GSUxMUy5CTFVFKTtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC90aGVtZXMvdml2aWREYXJrLnRzXG52YXIgVklWSURfREFSS19GSUxMUyA9IHtcbiAgQkxVRTogXCIjMDA4M2ZmXCIsXG4gIE9SQU5HRTogXCIjZmY2NjAwXCIsXG4gIEdSRUVOOiBcIiMwMGFmMDBcIixcbiAgQ1lBTjogXCIjMDBjY2ZmXCIsXG4gIFlFTExPVzogXCIjZjdjNzAwXCIsXG4gIFZJT0xFVDogXCIjYWMyNmZmXCIsXG4gIEdSQVk6IFwiI2E3YTdiN1wiLFxuICBNQUdFTlRBOiBcIiNlODAwYzVcIixcbiAgQlJPV046IFwiI2I1NDMwMFwiLFxuICBSRUQ6IFwiI2ZmMDAwMFwiXG59O1xudmFyIFZJVklEX0RBUktfU1RST0tFUyA9IHtcbiAgQkxVRTogXCIjNjdiN2ZmXCIsXG4gIE9SQU5HRTogXCIjZmZjMjRkXCIsXG4gIEdSRUVOOiBcIiM1Y2M4NmZcIixcbiAgQ1lBTjogXCIjNTRlYmZmXCIsXG4gIFZJT0xFVDogXCIjZmZmNjUzXCIsXG4gIFlFTExPVzogXCIjYzE4YWZmXCIsXG4gIEdSQVk6IFwiI2FlYWVhZVwiLFxuICBNQUdFTlRBOiBcIiNmMDc4ZDRcIixcbiAgQlJPV046IFwiI2JhODQzOFwiLFxuICBSRUQ6IFwiI2ZmNzI2ZVwiXG59O1xudmFyIFZpdmlkRGFyayA9IGNsYXNzIGV4dGVuZHMgRGFya1RoZW1lIHtcbiAgZ2V0RGVmYXVsdENvbG9ycygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZmlsbHM6IFZJVklEX0RBUktfRklMTFMsXG4gICAgICBzdHJva2VzOiBWSVZJRF9EQVJLX1NUUk9LRVMsXG4gICAgICB1cDogeyBmaWxsOiBWSVZJRF9EQVJLX0ZJTExTLkdSRUVOLCBzdHJva2U6IFZJVklEX0RBUktfU1RST0tFUy5HUkVFTiB9LFxuICAgICAgZG93bjogeyBmaWxsOiBWSVZJRF9EQVJLX0ZJTExTLlJFRCwgc3Ryb2tlOiBWSVZJRF9EQVJLX1NUUk9LRVMuUkVEIH0sXG4gICAgICBuZXV0cmFsOiB7IGZpbGw6IFZJVklEX0RBUktfRklMTFMuR1JBWSwgc3Ryb2tlOiBWSVZJRF9EQVJLX1NUUk9LRVMuR1JBWSB9LFxuICAgICAgYWx0VXA6IHsgZmlsbDogVklWSURfREFSS19GSUxMUy5CTFVFLCBzdHJva2U6IFZJVklEX0RBUktfU1RST0tFUy5CTFVFIH0sXG4gICAgICBhbHREb3duOiB7IGZpbGw6IFZJVklEX0RBUktfRklMTFMuT1JBTkdFLCBzdHJva2U6IFZJVklEX0RBUktfU1RST0tFUy5PUkFOR0UgfSxcbiAgICAgIGFsdE5ldXRyYWw6IHsgZmlsbDogVklWSURfREFSS19GSUxMUy5HUkFZLCBzdHJva2U6IFZJVklEX0RBUktfU1RST0tFUy5HUkFZIH1cbiAgICB9O1xuICB9XG4gIGdldFRlbXBsYXRlUGFyYW1ldGVycygpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBzdXBlci5nZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfRElWRVJHSU5HX1NFUklFU19DT0xPUl9SQU5HRSwgW1xuICAgICAgVklWSURfREFSS19GSUxMUy5PUkFOR0UsXG4gICAgICBWSVZJRF9EQVJLX0ZJTExTLllFTExPVyxcbiAgICAgIFZJVklEX0RBUktfRklMTFMuR1JFRU5cbiAgICBdKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfRlVOTkVMX1NFUklFU19DT0xPUl9SQU5HRSwgW1xuICAgICAgXCIjMDA4M2ZmXCIsXG4gICAgICBcIiMwMDc2ZTZcIixcbiAgICAgIFwiIzAwNjljY1wiLFxuICAgICAgXCIjMDA1Y2IzXCIsXG4gICAgICBcIiMwMDRmOTlcIixcbiAgICAgIFwiIzAwNDI4MFwiLFxuICAgICAgXCIjMDAzNDY2XCIsXG4gICAgICBcIiMwMDI3NGNcIlxuICAgIF0pO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9HQVVHRV9TRVJJRVNfQ09MT1JfUkFOR0UsIFtcbiAgICAgIFZJVklEX0RBUktfRklMTFMuR1JFRU4sXG4gICAgICBWSVZJRF9EQVJLX0ZJTExTLllFTExPVyxcbiAgICAgIFZJVklEX0RBUktfRklMTFMuUkVEXG4gICAgXSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fQ09MT1IsIFZJVklEX0RBUktfRklMTFMuQkxVRSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fQkFDS0dST1VORF9GSUxMLCBWSVZJRF9EQVJLX0ZJTExTLkJMVUUpO1xuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3RoZW1lcy92aXZpZExpZ2h0LnRzXG52YXIgVklWSURfRklMTFMgPSB7XG4gIEJMVUU6IFwiIzAwODNmZlwiLFxuICBPUkFOR0U6IFwiI2ZmNjYwMFwiLFxuICBHUkVFTjogXCIjMDBhZjAwXCIsXG4gIENZQU46IFwiIzAwY2NmZlwiLFxuICBZRUxMT1c6IFwiI2Y3YzcwMFwiLFxuICBWSU9MRVQ6IFwiI2FjMjZmZlwiLFxuICBHUkFZOiBcIiNhN2E3YjdcIixcbiAgTUFHRU5UQTogXCIjZTgwMGM1XCIsXG4gIEJST1dOOiBcIiNiNTQzMDBcIixcbiAgUkVEOiBcIiNmZjAwMDBcIlxufTtcbnZhciBWSVZJRF9TVFJPS0VTID0ge1xuICBCTFVFOiBcIiMwZjY4YzBcIixcbiAgT1JBTkdFOiBcIiNkNDcxMDBcIixcbiAgR1JFRU46IFwiIzAwNzkyMlwiLFxuICBDWUFOOiBcIiMwMDlhYzJcIixcbiAgVklPTEVUOiBcIiNiY2E0MDBcIixcbiAgWUVMTE9XOiBcIiM3NTNjYWNcIixcbiAgR1JBWTogXCIjNjQ2NDY0XCIsXG4gIE1BR0VOVEE6IFwiIzliMjY4NVwiLFxuICBCUk9XTjogXCIjNmMzYjAwXCIsXG4gIFJFRDogXCIjY2IwMDIxXCJcbn07XG52YXIgVml2aWRMaWdodCA9IGNsYXNzIGV4dGVuZHMgQ2hhcnRUaGVtZSB7XG4gIGdldERlZmF1bHRDb2xvcnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpbGxzOiBWSVZJRF9GSUxMUyxcbiAgICAgIHN0cm9rZXM6IFZJVklEX1NUUk9LRVMsXG4gICAgICB1cDogeyBmaWxsOiBWSVZJRF9GSUxMUy5HUkVFTiwgc3Ryb2tlOiBWSVZJRF9TVFJPS0VTLkdSRUVOIH0sXG4gICAgICBkb3duOiB7IGZpbGw6IFZJVklEX0ZJTExTLlJFRCwgc3Ryb2tlOiBWSVZJRF9TVFJPS0VTLlJFRCB9LFxuICAgICAgbmV1dHJhbDogeyBmaWxsOiBWSVZJRF9GSUxMUy5HUkFZLCBzdHJva2U6IFZJVklEX1NUUk9LRVMuR1JBWSB9LFxuICAgICAgYWx0VXA6IHsgZmlsbDogVklWSURfRklMTFMuQkxVRSwgc3Ryb2tlOiBWSVZJRF9TVFJPS0VTLkJMVUUgfSxcbiAgICAgIGFsdERvd246IHsgZmlsbDogVklWSURfRklMTFMuT1JBTkdFLCBzdHJva2U6IFZJVklEX1NUUk9LRVMuT1JBTkdFIH0sXG4gICAgICBhbHROZXV0cmFsOiB7IGZpbGw6IFZJVklEX0ZJTExTLkdSQVksIHN0cm9rZTogVklWSURfU1RST0tFUy5HUkFZIH1cbiAgICB9O1xuICB9XG4gIGdldFRlbXBsYXRlUGFyYW1ldGVycygpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBzdXBlci5nZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfRElWRVJHSU5HX1NFUklFU19DT0xPUl9SQU5HRSwgW1ZJVklEX0ZJTExTLk9SQU5HRSwgVklWSURfRklMTFMuWUVMTE9XLCBWSVZJRF9GSUxMUy5HUkVFTl0pO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9GVU5ORUxfU0VSSUVTX0NPTE9SX1JBTkdFLCBbXG4gICAgICBcIiMwMDgzZmZcIixcbiAgICAgIFwiIzFhOGZmZlwiLFxuICAgICAgXCIjMzM5Y2ZmXCIsXG4gICAgICBcIiM0ZGE4ZmZcIixcbiAgICAgIFwiIzY2YjVmZlwiLFxuICAgICAgXCIjODBjMWZmXCIsXG4gICAgICBcIiM5OWNkZmZcIixcbiAgICAgIFwiI2IzZGFmZlwiXG4gICAgXSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0dBVUdFX1NFUklFU19DT0xPUl9SQU5HRSwgW1ZJVklEX0ZJTExTLkdSRUVOLCBWSVZJRF9GSUxMUy5ZRUxMT1csIFZJVklEX0ZJTExTLlJFRF0pO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX0NPTE9SLCBWSVZJRF9GSUxMUy5CTFVFKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQU5OT1RBVElPTl9CQUNLR1JPVU5EX0ZJTEwsIFZJVklEX0ZJTExTLkJMVUUpO1xuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L21hcHBpbmcvdGhlbWVzLnRzXG52YXIgbGlnaHRUaGVtZSA9ICgpID0+IG5ldyBDaGFydFRoZW1lKCk7XG52YXIgZGFya1RoZW1lID0gKCkgPT4gbmV3IERhcmtUaGVtZSgpO1xudmFyIHRoZW1lcyA9IHtcbiAgLy8gZGFya1RoZW1lcyxcbiAgXCJhZy1kZWZhdWx0LWRhcmtcIjogZGFya1RoZW1lLFxuICBcImFnLXNoZWV0cy1kYXJrXCI6ICgpID0+IG5ldyBTaGVldHNEYXJrKCksXG4gIFwiYWctcG9seWNocm9tYS1kYXJrXCI6ICgpID0+IG5ldyBQb2x5Y2hyb21hRGFyaygpLFxuICBcImFnLXZpdmlkLWRhcmtcIjogKCkgPT4gbmV3IFZpdmlkRGFyaygpLFxuICBcImFnLW1hdGVyaWFsLWRhcmtcIjogKCkgPT4gbmV3IE1hdGVyaWFsRGFyaygpLFxuICBcImFnLWZpbmFuY2lhbC1kYXJrXCI6ICgpID0+IG5ldyBGaW5hbmNpYWxEYXJrKCksXG4gIC8vIGxpZ2h0VGhlbWVzLFxuICBudWxsOiBsaWdodFRoZW1lLFxuICB1bmRlZmluZWQ6IGxpZ2h0VGhlbWUsXG4gIFwiYWctZGVmYXVsdFwiOiBsaWdodFRoZW1lLFxuICBcImFnLXNoZWV0c1wiOiAoKSA9PiBuZXcgU2hlZXRzTGlnaHQoKSxcbiAgXCJhZy1wb2x5Y2hyb21hXCI6ICgpID0+IG5ldyBQb2x5Y2hyb21hTGlnaHQoKSxcbiAgXCJhZy12aXZpZFwiOiAoKSA9PiBuZXcgVml2aWRMaWdodCgpLFxuICBcImFnLW1hdGVyaWFsXCI6ICgpID0+IG5ldyBNYXRlcmlhbExpZ2h0KCksXG4gIFwiYWctZmluYW5jaWFsXCI6ICgpID0+IG5ldyBGaW5hbmNpYWxMaWdodCgpXG59O1xuZnVuY3Rpb24gZ2V0Q2hhcnRUaGVtZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBDaGFydFRoZW1lKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnN0IHN0b2NrVGhlbWUgPSB0aGVtZXNbdmFsdWVdO1xuICAgIGlmIChzdG9ja1RoZW1lKSB7XG4gICAgICByZXR1cm4gc3RvY2tUaGVtZSgpO1xuICAgIH1cbiAgICBMb2dnZXIud2Fybk9uY2UoYHRoZSB0aGVtZSBbJHt2YWx1ZX1dIGlzIGludmFsaWQsIHVzaW5nIFthZy1kZWZhdWx0XSBpbnN0ZWFkLmApO1xuICAgIHJldHVybiBsaWdodFRoZW1lKCk7XG4gIH1cbiAgaWYgKGlzVmFsaWQodmFsdWUsIHRoZW1lT3B0aW9uc0RlZiwgXCJ0aGVtZVwiKSkge1xuICAgIGNvbnN0IGZsYXR0ZW5lZFRoZW1lID0gcmVkdWNlVGhlbWVPcHRpb25zKHZhbHVlKTtcbiAgICBjb25zdCBiYXNlVGhlbWUgPSBmbGF0dGVuZWRUaGVtZS5iYXNlVGhlbWUgPyBnZXRDaGFydFRoZW1lKGZsYXR0ZW5lZFRoZW1lLmJhc2VUaGVtZSkgOiBsaWdodFRoZW1lKCk7XG4gICAgcmV0dXJuIG5ldyBiYXNlVGhlbWUuY29uc3RydWN0b3IoZmxhdHRlbmVkVGhlbWUpO1xuICB9XG4gIHJldHVybiBsaWdodFRoZW1lKCk7XG59XG5mdW5jdGlvbiByZWR1Y2VUaGVtZU9wdGlvbnMob3B0aW9ucykge1xuICBsZXQgbWF5YmVOZXN0ZWQgPSBvcHRpb25zO1xuICBsZXQgcGFsZXR0ZTtcbiAgY29uc3Qgb3ZlcnJpZGVzID0gW107XG4gIHdoaWxlICh0eXBlb2YgbWF5YmVOZXN0ZWQgPT09IFwib2JqZWN0XCIpIHtcbiAgICBwYWxldHRlID8/IChwYWxldHRlID0gbWF5YmVOZXN0ZWQucGFsZXR0ZSk7XG4gICAgaWYgKG1heWJlTmVzdGVkLm92ZXJyaWRlcykge1xuICAgICAgb3ZlcnJpZGVzLnB1c2gobWF5YmVOZXN0ZWQub3ZlcnJpZGVzKTtcbiAgICB9XG4gICAgbWF5YmVOZXN0ZWQgPSBtYXliZU5lc3RlZC5iYXNlVGhlbWU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBiYXNlVGhlbWU6IG1heWJlTmVzdGVkLFxuICAgIG92ZXJyaWRlczogbWVyZ2VEZWZhdWx0cyguLi5vdmVycmlkZXMpLFxuICAgIHBhbGV0dGVcbiAgfTtcbn1cbnZhciB0aGVtZU9wdGlvbnNEZWYgPSB7XG4gIGJhc2VUaGVtZTogb3Ioc3RyaW5nLCBvYmplY3QpLFxuICBvdmVycmlkZXM6IG9iamVjdCxcbiAgcGFsZXR0ZToge1xuICAgIGZpbGxzOiBhcnJheU9mKHN0cmluZyksXG4gICAgc3Ryb2tlczogYXJyYXlPZihzdHJpbmcpLFxuICAgIHVwOiB7IGZpbGw6IHN0cmluZywgc3Ryb2tlOiBzdHJpbmcgfSxcbiAgICBkb3duOiB7IGZpbGw6IHN0cmluZywgc3Ryb2tlOiBzdHJpbmcgfSxcbiAgICBuZXV0cmFsOiB7IGZpbGw6IHN0cmluZywgc3Ryb2tlOiBzdHJpbmcgfVxuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9tb2R1bGUvb3B0aW9uc01vZHVsZS50c1xudmFyIHVudGhlbWVkU2VyaWVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wibWFwLXNoYXBlLWJhY2tncm91bmRcIiwgXCJtYXAtbGluZS1iYWNrZ3JvdW5kXCJdKTtcbnZhciBDaGFydE9wdGlvbnMgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHVzZXJPcHRpb25zLCBwcm9jZXNzZWRPdmVycmlkZXMsIHNwZWNpYWxPdmVycmlkZXMsIG1ldGFkYXRhKSB7XG4gICAgdGhpcy5kZWJ1ZyA9IERlYnVnLmNyZWF0ZSh0cnVlLCBcIm9wdHNcIik7XG4gICAgdmFyIF9hO1xuICAgIHRoaXMub3B0aW9uTWV0YWRhdGEgPSBtZXRhZGF0YSA/PyB7fTtcbiAgICB0aGlzLnByb2Nlc3NlZE92ZXJyaWRlcyA9IHByb2Nlc3NlZE92ZXJyaWRlcyA/PyB7fTtcbiAgICBjb25zdCBjbG9uZU9wdGlvbnMgPSB7IHNoYWxsb3c6IFtcImRhdGFcIl0gfTtcbiAgICB0aGlzLnVzZXJPcHRpb25zID0gZGVlcENsb25lKHVzZXJPcHRpb25zLCBjbG9uZU9wdGlvbnMpO1xuICAgIGxldCBvcHRpb25zID0gZGVlcENsb25lKHVzZXJPcHRpb25zLCBjbG9uZU9wdGlvbnMpO1xuICAgIGNvbnN0IHsgcHJlc2V0VHlwZSB9ID0gdGhpcy5vcHRpb25NZXRhZGF0YTtcbiAgICBpZiAocHJlc2V0VHlwZSAhPSBudWxsKSB7XG4gICAgICBjb25zdCBwcmVzZXRDb25zdHJ1Y3RvciA9IFBSRVNFVFNbcHJlc2V0VHlwZV07XG4gICAgICBjb25zdCBwcmVzZXRQYXJhbXMgPSBvcHRpb25zO1xuICAgICAgY29uc3QgcHJlc2V0U3ViVHlwZSA9IG9wdGlvbnMudHlwZTtcbiAgICAgIGNvbnN0IHByZXNldFRoZW1lID0gcHJlc2V0U3ViVHlwZSAhPSBudWxsID8gZ2V0Q2hhcnRUaGVtZShvcHRpb25zLnRoZW1lKS5wcmVzZXRzW3ByZXNldFN1YlR5cGVdIDogdm9pZCAwO1xuICAgICAgdGhpcy5kZWJ1ZyhcIj4+PiBBZ0NoYXJ0cy5jcmVhdGVPclVwZGF0ZSgpIC0gYXBwbHlpbmcgcHJlc2V0XCIsIHByZXNldFBhcmFtcyk7XG4gICAgICBvcHRpb25zID0gcHJlc2V0Q29uc3RydWN0b3I/LihwcmVzZXRQYXJhbXMsIHByZXNldFRoZW1lLCAoKSA9PiB0aGlzLmFjdGl2ZVRoZW1lKSA/PyBvcHRpb25zO1xuICAgIH1cbiAgICBpZiAoIWVudGVycHJpc2VNb2R1bGUuaXNFbnRlcnByaXNlKSB7XG4gICAgICByZW1vdmVVc2VkRW50ZXJwcmlzZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgfVxuICAgIHRoaXMuYWN0aXZlVGhlbWUgPSBnZXRDaGFydFRoZW1lKG9wdGlvbnMudGhlbWUpO1xuICAgIGlmIChwcmVzZXRUeXBlKSB7XG4gICAgICBvcHRpb25zID0gdGhpcy5hY3RpdmVUaGVtZS50ZW1wbGF0ZVRoZW1lKG9wdGlvbnMpO1xuICAgIH1cbiAgICB0aGlzLnNhbml0eUNoZWNrQW5kQ2xlYW51cChvcHRpb25zKTtcbiAgICB0aGlzLmRlZmF1bHRBeGVzID0gdGhpcy5nZXREZWZhdWx0QXhlcyhvcHRpb25zKTtcbiAgICB0aGlzLnNwZWNpYWxPdmVycmlkZXMgPSB0aGlzLnNwZWNpYWxPdmVycmlkZXNEZWZhdWx0cyh7IC4uLnNwZWNpYWxPdmVycmlkZXMgfSk7XG4gICAgY29uc3QgY2hhcnRUeXBlMiA9IHRoaXMub3B0aW9uc1R5cGUob3B0aW9ucyk7XG4gICAgY29uc3Qge1xuICAgICAgYXhlczogYXhlc1RoZW1lcyA9IHt9LFxuICAgICAgYW5ub3RhdGlvbnM6IHsgYXhlc0J1dHRvbnMgPSBudWxsLCAuLi5hbm5vdGF0aW9uc1RoZW1lcyB9ID0ge30sXG4gICAgICBzZXJpZXM6IF8sXG4gICAgICAuLi50aGVtZURlZmF1bHRzXG4gICAgfSA9IHRoaXMuZ2V0U2VyaWVzVGhlbWVDb25maWcoY2hhcnRUeXBlMik7XG4gICAgdGhpcy5wcm9jZXNzZWRPcHRpb25zID0gZGVlcENsb25lKFxuICAgICAgbWVyZ2VEZWZhdWx0cyhcbiAgICAgICAgcHJvY2Vzc2VkT3ZlcnJpZGVzLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICBheGVzQnV0dG9ucyAhPSBudWxsID8geyBhbm5vdGF0aW9uczogeyBheGVzQnV0dG9ucyB9IH0gOiB7fSxcbiAgICAgICAgdGhlbWVEZWZhdWx0cyxcbiAgICAgICAgdGhpcy5kZWZhdWx0QXhlc1xuICAgICAgKSxcbiAgICAgIGNsb25lT3B0aW9uc1xuICAgICk7XG4gICAgdGhpcy5wcm9jZXNzQXhlc09wdGlvbnModGhpcy5wcm9jZXNzZWRPcHRpb25zLCBheGVzVGhlbWVzKTtcbiAgICB0aGlzLnByb2Nlc3NTZXJpZXNPcHRpb25zKHRoaXMucHJvY2Vzc2VkT3B0aW9ucyk7XG4gICAgdGhpcy5wcm9jZXNzTWluaUNoYXJ0U2VyaWVzT3B0aW9ucyh0aGlzLnByb2Nlc3NlZE9wdGlvbnMpO1xuICAgIHRoaXMuYW5ub3RhdGlvblRoZW1lcyA9IGFubm90YXRpb25zVGhlbWVzO1xuICAgIGlmICgoaXNBZ0NhcnRlc2lhbkNoYXJ0T3B0aW9ucyh0aGlzLnByb2Nlc3NlZE9wdGlvbnMpIHx8IGlzQWdQb2xhckNoYXJ0T3B0aW9uc1dpdGhTZXJpZXNCYXNlZExlZ2VuZCh0aGlzLnByb2Nlc3NlZE9wdGlvbnMpKSAmJiB0aGlzLnByb2Nlc3NlZE9wdGlvbnMubGVnZW5kPy5lbmFibGVkID09IG51bGwpIHtcbiAgICAgIChfYSA9IHRoaXMucHJvY2Vzc2VkT3B0aW9ucykubGVnZW5kID8/IChfYS5sZWdlbmQgPSB7fSk7XG4gICAgICB0aGlzLnByb2Nlc3NlZE9wdGlvbnMubGVnZW5kLmVuYWJsZWQgPSB0aGlzLnByb2Nlc3NlZE9wdGlvbnMuc2VyaWVzLmxlbmd0aCA+IDE7XG4gICAgfVxuICAgIHRoaXMuZW5hYmxlQ29uZmlndXJlZE9wdGlvbnModGhpcy5wcm9jZXNzZWRPcHRpb25zLCBvcHRpb25zKTtcbiAgICBpZiAoIWVudGVycHJpc2VNb2R1bGUuaXNFbnRlcnByaXNlKSB7XG4gICAgICByZW1vdmVVc2VkRW50ZXJwcmlzZU9wdGlvbnModGhpcy5wcm9jZXNzZWRPcHRpb25zLCB0cnVlKTtcbiAgICB9XG4gIH1cbiAgZ2V0T3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9jZXNzZWRPcHRpb25zID8/IHt9O1xuICB9XG4gIGRpZmZPcHRpb25zKG9wdGlvbnMpIHtcbiAgICByZXR1cm4ganNvbkRpZmYob3B0aW9ucywgdGhpcy5wcm9jZXNzZWRPcHRpb25zKTtcbiAgfVxuICBnZXRTZXJpZXNUaGVtZUNvbmZpZyhzZXJpZXNUeXBlMikge1xuICAgIGNvbnN0IHRoZW1lQ29uZmlnID0gZGVlcENsb25lKHRoaXMuYWN0aXZlVGhlbWU/LmNvbmZpZ1tzZXJpZXNUeXBlMl0gPz8ge30pO1xuICAgIHRoaXMucmVtb3ZlTGVmdG92ZXJTeW1ib2xzKHRoZW1lQ29uZmlnKTtcbiAgICByZXR1cm4gdGhlbWVDb25maWc7XG4gIH1cbiAgZ2V0RGVmYXVsdEF4ZXMob3B0aW9ucykge1xuICAgIGNvbnN0IG9wdGlvbnNUeXBlMiA9IHRoaXMub3B0aW9uc1R5cGUob3B0aW9ucyk7XG4gICAgY29uc3QgZmlyc3RTZXJpZXNPcHRpb25zID0gb3B0aW9ucy5zZXJpZXM/LmZpbmQoKHNlcmllcykgPT4gKHNlcmllcy50eXBlID8/IFwibGluZVwiKSA9PT0gb3B0aW9uc1R5cGUyKSA/PyB7fTtcbiAgICByZXR1cm4gc2VyaWVzUmVnaXN0cnkuY2xvbmVEZWZhdWx0QXhlcyhvcHRpb25zVHlwZTIsIGZpcnN0U2VyaWVzT3B0aW9ucyk7XG4gIH1cbiAgb3B0aW9uc1R5cGUob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLnNlcmllcz8uWzBdPy50eXBlID8/IFwibGluZVwiO1xuICB9XG4gIHNhbml0eUNoZWNrQW5kQ2xlYW51cChvcHRpb25zKSB7XG4gICAgdGhpcy5kZXByZWNhdGlvbldhcm5pbmdzKG9wdGlvbnMpO1xuICAgIHRoaXMuYXhlc1R5cGVJbnRlZ3JpdHkob3B0aW9ucyk7XG4gICAgdGhpcy5zZXJpZXNUeXBlSW50ZWdyaXR5KG9wdGlvbnMpO1xuICAgIHRoaXMuc29sb1Nlcmllc0ludGVncml0eShvcHRpb25zKTtcbiAgICB0aGlzLnJlbW92ZURpc2FibGVkT3B0aW9ucyhvcHRpb25zKTtcbiAgICB0aGlzLnJlbW92ZUxlZnRvdmVyU3ltYm9scyhvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5zZXJpZXM/LnNvbWUoKHMpID0+IHMudHlwZSA9PT0gXCJidWxsZXRcIikgJiYgb3B0aW9ucy5zeW5jICE9IG51bGwgJiYgb3B0aW9ucy5zeW5jLmVuYWJsZWQgIT09IGZhbHNlKSB7XG4gICAgICBMb2dnZXIud2Fybk9uY2UoXCJidWxsZXQgc2VyaWVzIGNhbm5vdCBiZSBzeW5jZWQsIGRpc2FibGluZyBzeW5jaHJvbml6YXRpb24uXCIpO1xuICAgICAgZGVsZXRlIG9wdGlvbnMuc3luYztcbiAgICB9XG4gIH1cbiAgcHJvY2Vzc0F4ZXNPcHRpb25zKG9wdGlvbnMsIGF4ZXNUaGVtZXMpIHtcbiAgICBpZiAoIShcImF4ZXNcIiBpbiBvcHRpb25zKSlcbiAgICAgIHJldHVybjtcbiAgICBvcHRpb25zLmF4ZXMgPSBvcHRpb25zLmF4ZXMubWFwKChheGlzKSA9PiB7XG4gICAgICBjb25zdCB7IGNyb3NzTGluZXM6IGNyb3NzTGluZXNUaGVtZSwgLi4uYXhpc1RoZW1lIH0gPSBtZXJnZURlZmF1bHRzKFxuICAgICAgICBheGVzVGhlbWVzW2F4aXMudHlwZV0/LltheGlzLnBvc2l0aW9uXSxcbiAgICAgICAgYXhlc1RoZW1lc1theGlzLnR5cGVdXG4gICAgICApO1xuICAgICAgaWYgKGF4aXMuY3Jvc3NMaW5lcykge1xuICAgICAgICBheGlzLmNyb3NzTGluZXMgPSBtZXJnZUFycmF5RGVmYXVsdHMoYXhpcy5jcm9zc0xpbmVzLCBjcm9zc0xpbmVzVGhlbWUpO1xuICAgICAgfVxuICAgICAgY29uc3QgZ3JpZExpbmVTdHlsZSA9IGF4aXNUaGVtZS5ncmlkTGluZT8uc3R5bGU7XG4gICAgICBpZiAoYXhpcy5ncmlkTGluZT8uc3R5bGUgJiYgZ3JpZExpbmVTdHlsZT8ubGVuZ3RoKSB7XG4gICAgICAgIGF4aXMuZ3JpZExpbmUuc3R5bGUgPSBheGlzLmdyaWRMaW5lLnN0eWxlLm1hcChcbiAgICAgICAgICAoc3R5bGUsIGluZGV4KSA9PiBzdHlsZS5zdHJva2UgIT0gbnVsbCB8fCBzdHlsZS5saW5lRGFzaCAhPSBudWxsID8gbWVyZ2VEZWZhdWx0cyhzdHlsZSwgZ3JpZExpbmVTdHlsZS5hdChpbmRleCAlIGdyaWRMaW5lU3R5bGUubGVuZ3RoKSkgOiBzdHlsZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgeyB0b3A6IF8xLCByaWdodDogXzIsIGJvdHRvbTogXzMsIGxlZnQ6IF80LCAuLi5heGlzT3B0aW9ucyB9ID0gbWVyZ2VEZWZhdWx0cyhheGlzLCBheGlzVGhlbWUpO1xuICAgICAgcmV0dXJuIGF4aXNPcHRpb25zO1xuICAgIH0pO1xuICB9XG4gIHByb2Nlc3NTZXJpZXNPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBjb25zdCBkZWZhdWx0VG9vbHRpcFBvc2l0aW9uID0gdGhpcy5nZXRUb29sdGlwUG9zaXRpb25EZWZhdWx0cyhvcHRpb25zKTtcbiAgICBjb25zdCB1c2VyUGFsZXR0ZSA9IGlzT2JqZWN0KG9wdGlvbnMudGhlbWUpID8gcGFsZXR0ZVR5cGUob3B0aW9ucy50aGVtZT8ucGFsZXR0ZSkgOiBcImluYnVpbHRcIjtcbiAgICBjb25zdCBwYWxldHRlT3B0aW9ucyA9IHtcbiAgICAgIGNvbG91ckluZGV4OiAwLFxuICAgICAgdXNlclBhbGV0dGVcbiAgICB9O1xuICAgIGNvbnN0IHByb2Nlc3NlZFNlcmllcyA9IG9wdGlvbnMuc2VyaWVzPy5tYXAoKHNlcmllcykgPT4ge1xuICAgICAgc2VyaWVzLnR5cGUgPz8gKHNlcmllcy50eXBlID0gdGhpcy5nZXREZWZhdWx0U2VyaWVzVHlwZShvcHRpb25zKSk7XG4gICAgICBjb25zdCB7IGlubmVyTGFiZWxzOiBpbm5lckxhYmVsc1RoZW1lLCAuLi5zZXJpZXNUaGVtZSB9ID0gdGhpcy5nZXRTZXJpZXNUaGVtZUNvbmZpZyhzZXJpZXMudHlwZSkuc2VyaWVzID8/IHt9O1xuICAgICAgY29uc3Qgc2VyaWVzUGFsZXR0ZU9wdGlvbnMgPSB1bnRoZW1lZFNlcmllcy5oYXMoc2VyaWVzLnR5cGUpID8geyBjb2xvdXJJbmRleDogMCwgdXNlclBhbGV0dGUgfSA6IHBhbGV0dGVPcHRpb25zO1xuICAgICAgY29uc3QgcGFsZXR0ZSA9IHRoaXMuZ2V0U2VyaWVzUGFsZXR0ZShzZXJpZXMudHlwZSwgc2VyaWVzUGFsZXR0ZU9wdGlvbnMpO1xuICAgICAgY29uc3QgZGVmYXVsdFRvb2x0aXBSYW5nZSA9IHRoaXMuZ2V0VG9vbHRpcFJhbmdlRGVmYXVsdHMob3B0aW9ucywgc2VyaWVzLnR5cGUpO1xuICAgICAgY29uc3Qgc2VyaWVzT3B0aW9ucyA9IG1lcmdlRGVmYXVsdHMoXG4gICAgICAgIHRoaXMuZ2V0U2VyaWVzR3JvdXBpbmdPcHRpb25zKHNlcmllcyksXG4gICAgICAgIHNlcmllcyxcbiAgICAgICAgZGVmYXVsdFRvb2x0aXBQb3NpdGlvbixcbiAgICAgICAgZGVmYXVsdFRvb2x0aXBSYW5nZSxcbiAgICAgICAgc2VyaWVzVGhlbWUsXG4gICAgICAgIHBhbGV0dGUsXG4gICAgICAgIHsgdmlzaWJsZTogdHJ1ZSB9XG4gICAgICApO1xuICAgICAgaWYgKHNlcmllc09wdGlvbnMuaW5uZXJMYWJlbHMpIHtcbiAgICAgICAgc2VyaWVzT3B0aW9ucy5pbm5lckxhYmVscyA9IG1lcmdlQXJyYXlEZWZhdWx0cyhzZXJpZXNPcHRpb25zLmlubmVyTGFiZWxzLCBpbm5lckxhYmVsc1RoZW1lKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmFjdGl2ZVRoZW1lLnRlbXBsYXRlVGhlbWUoc2VyaWVzT3B0aW9ucyk7XG4gICAgfSk7XG4gICAgb3B0aW9ucy5zZXJpZXMgPSB0aGlzLnNldFNlcmllc0dyb3VwaW5nT3B0aW9ucyhwcm9jZXNzZWRTZXJpZXMgPz8gW10pO1xuICB9XG4gIHByb2Nlc3NNaW5pQ2hhcnRTZXJpZXNPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBsZXQgbWluaUNoYXJ0U2VyaWVzID0gb3B0aW9ucy5uYXZpZ2F0b3I/Lm1pbmlDaGFydD8uc2VyaWVzO1xuICAgIGlmIChtaW5pQ2hhcnRTZXJpZXMgPT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBwYWxldHRlT3B0aW9ucyA9IHtcbiAgICAgIGNvbG91ckluZGV4OiAwLFxuICAgICAgdXNlclBhbGV0dGU6IGlzT2JqZWN0KG9wdGlvbnMudGhlbWUpID8gcGFsZXR0ZVR5cGUob3B0aW9ucy50aGVtZS5wYWxldHRlKSA6IFwiaW5idWlsdFwiXG4gICAgfTtcbiAgICBtaW5pQ2hhcnRTZXJpZXMgPSBtaW5pQ2hhcnRTZXJpZXMubWFwKChzZXJpZXMpID0+IHtcbiAgICAgIHNlcmllcy50eXBlID8/IChzZXJpZXMudHlwZSA9IFwibGluZVwiKTtcbiAgICAgIGNvbnN0IHsgaW5uZXJMYWJlbHM6IF8sIC4uLnNlcmllc1RoZW1lIH0gPSB0aGlzLmdldFNlcmllc1RoZW1lQ29uZmlnKHNlcmllcy50eXBlKS5zZXJpZXMgPz8ge307XG4gICAgICBjb25zdCBzZXJpZXNPcHRpb25zID0gbWVyZ2VEZWZhdWx0cyhcbiAgICAgICAgdGhpcy5nZXRTZXJpZXNHcm91cGluZ09wdGlvbnMoc2VyaWVzKSxcbiAgICAgICAgc2VyaWVzLFxuICAgICAgICBzZXJpZXNUaGVtZSxcbiAgICAgICAgdGhpcy5nZXRTZXJpZXNQYWxldHRlKHNlcmllcy50eXBlLCBwYWxldHRlT3B0aW9ucylcbiAgICAgICk7XG4gICAgICByZXR1cm4gdGhpcy5hY3RpdmVUaGVtZS50ZW1wbGF0ZVRoZW1lKHNlcmllc09wdGlvbnMpO1xuICAgIH0pO1xuICAgIG9wdGlvbnMubmF2aWdhdG9yLm1pbmlDaGFydC5zZXJpZXMgPSB0aGlzLnNldFNlcmllc0dyb3VwaW5nT3B0aW9ucyhtaW5pQ2hhcnRTZXJpZXMpO1xuICB9XG4gIGdldFNlcmllc1BhbGV0dGUoc2VyaWVzVHlwZTIsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBwYWxldHRlRmFjdG9yeSA9IHNlcmllc1JlZ2lzdHJ5LmdldFBhbGV0dGVGYWN0b3J5KHNlcmllc1R5cGUyKTtcbiAgICBjb25zdCB7IGNvbG91ckluZGV4OiBjb2xvdXJPZmZzZXQsIHVzZXJQYWxldHRlIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHsgZmlsbHMgPSBbXSwgc3Ryb2tlcyA9IFtdIH0gPSB0aGlzLmFjdGl2ZVRoZW1lLnBhbGV0dGU7XG4gICAgcmV0dXJuIHBhbGV0dGVGYWN0b3J5Py4oe1xuICAgICAgdXNlclBhbGV0dGUsXG4gICAgICBjb2xvcnNDb3VudDogTWF0aC5tYXgoZmlsbHMubGVuZ3RoLCBzdHJva2VzLmxlbmd0aCksXG4gICAgICB0aGVtZVRlbXBsYXRlUGFyYW1ldGVyczogdGhpcy5hY3RpdmVUaGVtZS5nZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKSxcbiAgICAgIHBhbGV0dGU6IHRoaXMuYWN0aXZlVGhlbWUucGFsZXR0ZSxcbiAgICAgIHRha2VDb2xvcnMoY291bnQpIHtcbiAgICAgICAgb3B0aW9ucy5jb2xvdXJJbmRleCArPSBjb3VudDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBmaWxsczogY2lyY3VsYXJTbGljZUFycmF5KGZpbGxzLCBjb3VudCwgY29sb3VyT2Zmc2V0KSxcbiAgICAgICAgICBzdHJva2VzOiBjaXJjdWxhclNsaWNlQXJyYXkoc3Ryb2tlcywgY291bnQsIGNvbG91ck9mZnNldClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXRTZXJpZXNHcm91cGluZ09wdGlvbnMoc2VyaWVzKSB7XG4gICAgY29uc3QgZ3JvdXBhYmxlID0gc2VyaWVzUmVnaXN0cnkuaXNHcm91cGFibGUoc2VyaWVzLnR5cGUpO1xuICAgIGNvbnN0IHN0YWNrYWJsZSA9IHNlcmllc1JlZ2lzdHJ5LmlzU3RhY2thYmxlKHNlcmllcy50eXBlKTtcbiAgICBjb25zdCBzdGFja2VkQnlEZWZhdWx0ID0gc2VyaWVzUmVnaXN0cnkuaXNTdGFja2VkQnlEZWZhdWx0KHNlcmllcy50eXBlKTtcbiAgICBpZiAoc2VyaWVzLmdyb3VwZWQgJiYgIWdyb3VwYWJsZSkge1xuICAgICAgTG9nZ2VyLndhcm5PbmNlKGB1bnN1cHBvcnRlZCBncm91cGluZyBvZiBzZXJpZXMgdHlwZSBcIiR7c2VyaWVzLnR5cGV9XCIuYCk7XG4gICAgfVxuICAgIGlmICgoc2VyaWVzLnN0YWNrZWQgfHwgc2VyaWVzLnN0YWNrR3JvdXApICYmICFzdGFja2FibGUpIHtcbiAgICAgIExvZ2dlci53YXJuT25jZShgdW5zdXBwb3J0ZWQgc3RhY2tpbmcgb2Ygc2VyaWVzIHR5cGUgXCIke3Nlcmllcy50eXBlfVwiLmApO1xuICAgIH1cbiAgICBsZXQgeyBncm91cGVkLCBzdGFja2VkIH0gPSBzZXJpZXM7XG4gICAgc3RhY2tlZCA/PyAoc3RhY2tlZCA9IChzdGFja2VkQnlEZWZhdWx0IHx8IHNlcmllcy5zdGFja0dyb3VwICE9IG51bGwpICYmICEoZ3JvdXBhYmxlICYmIGdyb3VwZWQpKTtcbiAgICBncm91cGVkID8/IChncm91cGVkID0gdHJ1ZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YWNrZWQ6IHN0YWNrYWJsZSAmJiBzdGFja2VkLFxuICAgICAgZ3JvdXBlZDogZ3JvdXBhYmxlICYmIGdyb3VwZWQgJiYgIShzdGFja2FibGUgJiYgc3RhY2tlZClcbiAgICB9O1xuICB9XG4gIHNldFNlcmllc0dyb3VwaW5nT3B0aW9ucyhhbGxTZXJpZXMpIHtcbiAgICBjb25zdCBzZXJpZXNHcm91cHMgPSB0aGlzLmdldFNlcmllc0dyb3VwaW5nKGFsbFNlcmllcyk7XG4gICAgdGhpcy5kZWJ1ZyhcInNldFNlcmllc0dyb3VwaW5nT3B0aW9ucygpIC0gc2VyaWVzIGdyb3VwaW5nOiBcIiwgc2VyaWVzR3JvdXBzKTtcbiAgICBjb25zdCBncm91cElkeCA9IHt9O1xuICAgIGNvbnN0IGdyb3VwQ291bnQyID0gc2VyaWVzR3JvdXBzLnJlZHVjZSgoY291bnRNYXAsIHNlcmllc0dyb3VwKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAoc2VyaWVzR3JvdXAuZ3JvdXBUeXBlID09PSBcImRlZmF1bHRcIiAvKiBERUZBVUxUICovKSB7XG4gICAgICAgIHJldHVybiBjb3VudE1hcDtcbiAgICAgIH1cbiAgICAgIGNvdW50TWFwW19hID0gc2VyaWVzR3JvdXAuc2VyaWVzVHlwZV0gPz8gKGNvdW50TWFwW19hXSA9IDApO1xuICAgICAgY291bnRNYXBbc2VyaWVzR3JvdXAuc2VyaWVzVHlwZV0gKz0gc2VyaWVzR3JvdXAuZ3JvdXBUeXBlID09PSBcInN0YWNrXCIgLyogU1RBQ0sgKi8gPyAxIDogc2VyaWVzR3JvdXAuc2VyaWVzLmxlbmd0aDtcbiAgICAgIHJldHVybiBjb3VudE1hcDtcbiAgICB9LCB7fSk7XG4gICAgcmV0dXJuIHNlcmllc0dyb3Vwcy5mbGF0TWFwKChzZXJpZXNHcm91cCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgZ3JvdXBJZHhbX2EgPSBzZXJpZXNHcm91cC5zZXJpZXNUeXBlXSA/PyAoZ3JvdXBJZHhbX2FdID0gMCk7XG4gICAgICBzd2l0Y2ggKHNlcmllc0dyb3VwLmdyb3VwVHlwZSkge1xuICAgICAgICBjYXNlIFwic3RhY2tcIiAvKiBTVEFDSyAqLzoge1xuICAgICAgICAgIGNvbnN0IGdyb3VwSW5kZXggPSBncm91cElkeFtzZXJpZXNHcm91cC5zZXJpZXNUeXBlXSsrO1xuICAgICAgICAgIHJldHVybiBzZXJpZXNHcm91cC5zZXJpZXMubWFwKFxuICAgICAgICAgICAgKHNlcmllcywgc3RhY2tJbmRleCkgPT4gT2JqZWN0LmFzc2lnbihzZXJpZXMsIHtcbiAgICAgICAgICAgICAgc2VyaWVzR3JvdXBpbmc6IHtcbiAgICAgICAgICAgICAgICBncm91cElkOiBzZXJpZXNHcm91cC5ncm91cElkLFxuICAgICAgICAgICAgICAgIGdyb3VwSW5kZXgsXG4gICAgICAgICAgICAgICAgZ3JvdXBDb3VudDogZ3JvdXBDb3VudDJbc2VyaWVzR3JvdXAuc2VyaWVzVHlwZV0sXG4gICAgICAgICAgICAgICAgc3RhY2tJbmRleCxcbiAgICAgICAgICAgICAgICBzdGFja0NvdW50OiBzZXJpZXNHcm91cC5zZXJpZXMubGVuZ3RoXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZ3JvdXBcIiAvKiBHUk9VUCAqLzpcbiAgICAgICAgICByZXR1cm4gc2VyaWVzR3JvdXAuc2VyaWVzLm1hcChcbiAgICAgICAgICAgIChzZXJpZXMpID0+IE9iamVjdC5hc3NpZ24oc2VyaWVzLCB7XG4gICAgICAgICAgICAgIHNlcmllc0dyb3VwaW5nOiB7XG4gICAgICAgICAgICAgICAgZ3JvdXBJZDogc2VyaWVzR3JvdXAuZ3JvdXBJZCxcbiAgICAgICAgICAgICAgICBncm91cEluZGV4OiBncm91cElkeFtzZXJpZXNHcm91cC5zZXJpZXNUeXBlXSsrLFxuICAgICAgICAgICAgICAgIGdyb3VwQ291bnQ6IGdyb3VwQ291bnQyW3Nlcmllc0dyb3VwLnNlcmllc1R5cGVdLFxuICAgICAgICAgICAgICAgIHN0YWNrSW5kZXg6IDAsXG4gICAgICAgICAgICAgICAgc3RhY2tDb3VudDogMFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VyaWVzR3JvdXAuc2VyaWVzO1xuICAgIH0pLm1hcCgoeyBzdGFja2VkOiBfLCBncm91cGVkOiBfXywgLi4uc2VyaWVzT3B0aW9ucyB9KSA9PiBzZXJpZXNPcHRpb25zKTtcbiAgfVxuICBnZXRTZXJpZXNHcm91cElkKHNlcmllcykge1xuICAgIHJldHVybiBbc2VyaWVzLnR5cGUsIHNlcmllcy54S2V5LCBzZXJpZXMuc3RhY2tlZCA/IHNlcmllcy5zdGFja0dyb3VwID8/IFwic3RhY2tlZFwiIDogXCJncm91cGVkXCJdLmZpbHRlcihCb29sZWFuKS5qb2luKFwiLVwiKTtcbiAgfVxuICBnZXRTZXJpZXNHcm91cGluZyhhbGxTZXJpZXMpIHtcbiAgICBjb25zdCBncm91cE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgcmV0dXJuIGFsbFNlcmllcy5yZWR1Y2UoKHJlc3VsdCwgc2VyaWVzKSA9PiB7XG4gICAgICBjb25zdCBzZXJpZXNUeXBlMiA9IHNlcmllcy50eXBlO1xuICAgICAgaWYgKCFzZXJpZXMuc3RhY2tlZCAmJiAhc2VyaWVzLmdyb3VwZWQpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goeyBncm91cFR5cGU6IFwiZGVmYXVsdFwiIC8qIERFRkFVTFQgKi8sIHNlcmllc1R5cGU6IHNlcmllc1R5cGUyLCBzZXJpZXM6IFtzZXJpZXNdLCBncm91cElkOiBcIl9fZGVmYXVsdF9fXCIgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBncm91cElkID0gdGhpcy5nZXRTZXJpZXNHcm91cElkKHNlcmllcyk7XG4gICAgICAgIGlmICghZ3JvdXBNYXAuaGFzKGdyb3VwSWQpKSB7XG4gICAgICAgICAgY29uc3QgZ3JvdXBUeXBlID0gc2VyaWVzLnN0YWNrZWQgPyBcInN0YWNrXCIgLyogU1RBQ0sgKi8gOiBcImdyb3VwXCIgLyogR1JPVVAgKi87XG4gICAgICAgICAgY29uc3QgcmVjb3JkID0geyBncm91cFR5cGUsIHNlcmllc1R5cGU6IHNlcmllc1R5cGUyLCBzZXJpZXM6IFtdLCBncm91cElkIH07XG4gICAgICAgICAgZ3JvdXBNYXAuc2V0KGdyb3VwSWQsIHJlY29yZCk7XG4gICAgICAgICAgcmVzdWx0LnB1c2gocmVjb3JkKTtcbiAgICAgICAgfVxuICAgICAgICBncm91cE1hcC5nZXQoZ3JvdXBJZCkuc2VyaWVzLnB1c2goc2VyaWVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwgW10pO1xuICB9XG4gIGdldERlZmF1bHRTZXJpZXNUeXBlKG9wdGlvbnMpIHtcbiAgICBpZiAoaXNBZ0NhcnRlc2lhbkNoYXJ0T3B0aW9ucyhvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIFwibGluZVwiO1xuICAgIH0gZWxzZSBpZiAoaXNBZ1BvbGFyQ2hhcnRPcHRpb25zKG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gXCJwaWVcIjtcbiAgICB9IGVsc2UgaWYgKGlzQWdIaWVyYXJjaHlDaGFydE9wdGlvbnMob3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBcInRyZWVtYXBcIjtcbiAgICB9IGVsc2UgaWYgKGlzQWdUb3BvbG9neUNoYXJ0T3B0aW9ucyhvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIFwibWFwLXNoYXBlXCI7XG4gICAgfSBlbHNlIGlmIChpc0FnRmxvd1Byb3BvcnRpb25DaGFydE9wdGlvbnMob3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBcInNhbmtleVwiO1xuICAgIH0gZWxzZSBpZiAoaXNBZ1N0YW5kYWxvbmVDaGFydE9wdGlvbnMob3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBcInB5cmFtaWRcIjtcbiAgICB9IGVsc2UgaWYgKGlzQWdHYXVnZUNoYXJ0T3B0aW9ucyhvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIFwicmFkaWFsLWdhdWdlXCI7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY2hhcnQgb3B0aW9ucyB0eXBlIGRldGVjdGVkLlwiKTtcbiAgfVxuICBnZXRUb29sdGlwUG9zaXRpb25EZWZhdWx0cyhvcHRpb25zKSB7XG4gICAgY29uc3QgcG9zaXRpb24gPSBvcHRpb25zLnRvb2x0aXA/LnBvc2l0aW9uO1xuICAgIGlmICghaXNQbGFpbk9iamVjdChwb3NpdGlvbikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyB0eXBlLCB4T2Zmc2V0LCB5T2Zmc2V0IH0gPSBwb3NpdGlvbjtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBpZiAoaXNTdHJpbmcodHlwZSkgJiYgaXNFbnVtVmFsdWUoQWdUb29sdGlwUG9zaXRpb25UeXBlLCB0eXBlKSkge1xuICAgICAgcmVzdWx0LnR5cGUgPSB0eXBlO1xuICAgIH1cbiAgICBpZiAoaXNGaW5pdGVOdW1iZXIoeE9mZnNldCkpIHtcbiAgICAgIHJlc3VsdC54T2Zmc2V0ID0geE9mZnNldDtcbiAgICB9XG4gICAgaWYgKGlzRmluaXRlTnVtYmVyKHlPZmZzZXQpKSB7XG4gICAgICByZXN1bHQueU9mZnNldCA9IHlPZmZzZXQ7XG4gICAgfVxuICAgIHJldHVybiB7IHRvb2x0aXA6IHsgcG9zaXRpb246IHJlc3VsdCB9IH07XG4gIH1cbiAgLy8gQUctMTE1OTEgU3VwcG9ydCBmb3IgbmV3IHNlcmllcy1zcGVjaWZpYyAmIGxlZ2FjeSBjaGFydC1nbG9iYWwgJ3Rvb2x0aXAucmFuZ2UnIG9wdGlvbnNcbiAgLy9cbiAgLy8gVGhlIGBjaGFydC5zZXJpZXNbXS50b29sdGlwLnJhbmdlYCBvcHRpb24gaXMgYSBiaXQgZGlmZmVyZW50IGZvciBsZWdhY3kgcmVhc29uLiBUaGlzIHVzZSB0byBiZVxuICAvLyBnbG9iYWwgb3B0aW9uIChgY2hhcnQudG9vbHRpcC5yYW5nZWApIHRoYXQgY291bGQgb3ZlcnJpZGUgdGhlIHRoZW1lLiBCdXQgbm93LCB0aGUgdG9vbHRpcCByYW5nZVxuICAvLyBvcHRpb24gaXMgc2VyaWVzLXNwZWNpZmljLlxuICAvL1xuICAvLyBUbyBwcmVzZXJ2ZSBiYWNrd2FyZCBjb21wYXRpYmxpdHksIHRoZSBgY2hhcnQudG9vbHRpcC5yYW5nZWAgdGhlbWUgZGVmYXVsdCBoYXMgYmVlbiBjaGFuZ2VkIGZyb21cbiAgLy8gJ25lYXJlc3QnIHRvIHVuZGVmaW5lZC5cbiAgZ2V0VG9vbHRpcFJhbmdlRGVmYXVsdHMob3B0aW9ucywgc2VyaWVzVHlwZTIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9vbHRpcDoge1xuICAgICAgICByYW5nZTogb3B0aW9ucy50b29sdGlwPy5yYW5nZSA/PyBzZXJpZXNSZWdpc3RyeS5nZXRUb29sdGlwRGVmYXVscyhzZXJpZXNUeXBlMik/LnJhbmdlXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBkZXByZWNhdGlvbldhcm5pbmdzKG9wdGlvbnMpIHtcbiAgICBjb25zdCBkZXByZWNhdGVkQXJyYXlQcm9wcyA9IHsgeUtleXM6IFwieUtleVwiLCB5TmFtZXM6IFwieU5hbWVcIiB9O1xuICAgIE9iamVjdC5lbnRyaWVzKGRlcHJlY2F0ZWRBcnJheVByb3BzKS5mb3JFYWNoKChbb2xkUHJvcCwgbmV3UHJvcF0pID0+IHtcbiAgICAgIGlmIChvcHRpb25zLnNlcmllcz8uc29tZSgocykgPT4gc1tvbGRQcm9wXSAhPSBudWxsKSkge1xuICAgICAgICBMb2dnZXIud2Fybk9uY2UoXG4gICAgICAgICAgYFByb3BlcnR5IFtzZXJpZXMuJHtvbGRQcm9wfV0gaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBbc2VyaWVzLiR7bmV3UHJvcH1dIGFuZCBtdWx0aXBsZSBzZXJpZXMgaW5zdGVhZC5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYXhlc1R5cGVJbnRlZ3JpdHkob3B0aW9ucykge1xuICAgIGlmIChcImF4ZXNcIiBpbiBvcHRpb25zKSB7XG4gICAgICBjb25zdCBheGVzID0gb3B0aW9ucy5heGVzID8/IFtdO1xuICAgICAgZm9yIChjb25zdCB7IHR5cGUgfSBvZiBheGVzKSB7XG4gICAgICAgIGlmICghaXNBeGlzT3B0aW9uVHlwZSh0eXBlKSkge1xuICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmF4ZXM7XG4gICAgICAgICAgY29uc3QgZXhwZWN0ZWRUeXBlcyA9IGF4aXNSZWdpc3RyeS5wdWJsaWNLZXlzKCkuam9pbihcIiwgXCIpO1xuICAgICAgICAgIExvZ2dlci53YXJuT25jZShgdW5rbm93biBheGlzIHR5cGU6ICR7dHlwZX07IGV4cGVjdGVkIG9uZSBvZjogJHtleHBlY3RlZFR5cGVzfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHNlcmllc1R5cGVJbnRlZ3JpdHkob3B0aW9ucykge1xuICAgIG9wdGlvbnMuc2VyaWVzID0gb3B0aW9ucy5zZXJpZXM/LmZpbHRlcigoeyB0eXBlIH0pID0+IHtcbiAgICAgIGlmICh0eXBlID09IG51bGwgfHwgaXNTZXJpZXNPcHRpb25UeXBlKHR5cGUpIHx8IGlzRW50ZXJwcmlzZVNlcmllc1R5cGUodHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBMb2dnZXIud2Fybk9uY2UoXG4gICAgICAgIGB1bmtub3duIHNlcmllcyB0eXBlOiAke3R5cGV9OyBleHBlY3RlZCBvbmUgb2Y6ICR7cHVibGljQ2hhcnRUeXBlcy5zZXJpZXNUeXBlcy5qb2luKFwiLCBcIil9YFxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuICBzb2xvU2VyaWVzSW50ZWdyaXR5KG9wdGlvbnMpIHtcbiAgICBjb25zdCBhbGxTZXJpZXMgPSBvcHRpb25zLnNlcmllcztcbiAgICBpZiAoYWxsU2VyaWVzICYmIGFsbFNlcmllcy5sZW5ndGggPiAxICYmIGFsbFNlcmllcy5zb21lKChzZXJpZXMpID0+IHNlcmllc1JlZ2lzdHJ5LmlzU29sbyhzZXJpZXMudHlwZSkpKSB7XG4gICAgICBjb25zdCBtYWluU2VyaWVzVHlwZSA9IHRoaXMub3B0aW9uc1R5cGUob3B0aW9ucyk7XG4gICAgICBpZiAoc2VyaWVzUmVnaXN0cnkuaXNTb2xvKG1haW5TZXJpZXNUeXBlKSkge1xuICAgICAgICBMb2dnZXIud2FybihcbiAgICAgICAgICBgc2VyaWVzWzBdIG9mIHR5cGUgJyR7bWFpblNlcmllc1R5cGV9JyBpcyBpbmNvbXBhdGlibGUgd2l0aCBvdGhlciBzZXJpZXMgdHlwZXMuIE9ubHkgcHJvY2Vzc2luZyBzZXJpZXNbMF1gXG4gICAgICAgICk7XG4gICAgICAgIG9wdGlvbnMuc2VyaWVzID0gYWxsU2VyaWVzLnNsaWNlKDAsIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgeyBzb2xvLCBub25Tb2xvIH0gPSBncm91cEJ5KFxuICAgICAgICAgIGFsbFNlcmllcyxcbiAgICAgICAgICAocykgPT4gc2VyaWVzUmVnaXN0cnkuaXNTb2xvKHMudHlwZSkgPyBcInNvbG9cIiA6IFwibm9uU29sb1wiXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHJlamVjdHMgPSB1bmlxdWUoc29sby5tYXAoKHMpID0+IHMudHlwZSkpLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgTG9nZ2VyLndhcm4oYFVuYWJsZSB0byBtaXggdGhlc2Ugc2VyaWVzIHR5cGVzIHdpdGggdGhlIGxlYWQgc2VyaWVzIHR5cGU6ICR7cmVqZWN0c31gKTtcbiAgICAgICAgb3B0aW9ucy5zZXJpZXMgPSBub25Tb2xvO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBlbmFibGVDb25maWd1cmVkT3B0aW9ucyhvcHRpb25zLCB1c2VyT3B0aW9ucykge1xuICAgIGpzb25XYWxrKFxuICAgICAgdXNlck9wdGlvbnMsXG4gICAgICAodmlzaXRpbmdVc2VyT3B0cywgdmlzaXRpbmdNZXJnZWRPcHRzKSA9PiB7XG4gICAgICAgIGlmICh2aXNpdGluZ01lcmdlZE9wdHMgJiYgXCJlbmFibGVkXCIgaW4gdmlzaXRpbmdNZXJnZWRPcHRzICYmICF2aXNpdGluZ01lcmdlZE9wdHMuX2VuYWJsZWRGcm9tVGhlbWUgJiYgdmlzaXRpbmdVc2VyT3B0cy5lbmFibGVkID09IG51bGwpIHtcbiAgICAgICAgICB2aXNpdGluZ01lcmdlZE9wdHMuZW5hYmxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7IHNraXA6IFtcImRhdGFcIiwgXCJ0aGVtZVwiXSB9LFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAganNvbldhbGsoXG4gICAgICBvcHRpb25zLFxuICAgICAgKHZpc2l0aW5nTWVyZ2VkT3B0cykgPT4ge1xuICAgICAgICBpZiAodmlzaXRpbmdNZXJnZWRPcHRzLl9lbmFibGVkRnJvbVRoZW1lICE9IG51bGwpIHtcbiAgICAgICAgICBkZWxldGUgdmlzaXRpbmdNZXJnZWRPcHRzLl9lbmFibGVkRnJvbVRoZW1lO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgeyBza2lwOiBbXCJkYXRhXCIsIFwidGhlbWVcIl0gfVxuICAgICk7XG4gIH1cbiAgcmVtb3ZlRGlzYWJsZWRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBqc29uV2FsayhcbiAgICAgIG9wdGlvbnMsXG4gICAgICAob3B0aW9uc05vZGUpID0+IHtcbiAgICAgICAgaWYgKFwiZW5hYmxlZFwiIGluIG9wdGlvbnNOb2RlICYmIG9wdGlvbnNOb2RlLmVuYWJsZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgT2JqZWN0LmtleXMob3B0aW9uc05vZGUpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJlbmFibGVkXCIpXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zTm9kZVtrZXldO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgeyBza2lwOiBbXCJkYXRhXCIsIFwidGhlbWVcIl0gfVxuICAgICk7XG4gIH1cbiAgcmVtb3ZlTGVmdG92ZXJTeW1ib2xzKG9wdGlvbnMpIHtcbiAgICBqc29uV2FsayhcbiAgICAgIG9wdGlvbnMsXG4gICAgICAob3B0aW9uc05vZGUpID0+IHtcbiAgICAgICAgaWYgKCFvcHRpb25zTm9kZSB8fCAhaXNPYmplY3Qob3B0aW9uc05vZGUpKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMob3B0aW9uc05vZGUpKSB7XG4gICAgICAgICAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnNOb2RlW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgeyBza2lwOiBbXCJkYXRhXCJdIH1cbiAgICApO1xuICB9XG4gIHNwZWNpYWxPdmVycmlkZXNEZWZhdWx0cyhvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMud2luZG93ICE9IG51bGwpIHtcbiAgICAgIHNldFdpbmRvdyhvcHRpb25zLndpbmRvdyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBvcHRpb25zLndpbmRvdyA9IHdpbmRvdztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIG9wdGlvbnMud2luZG93ID0gZ2xvYmFsLndpbmRvdztcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZG9jdW1lbnQgIT0gbnVsbCkge1xuICAgICAgc2V0RG9jdW1lbnQob3B0aW9ucy5kb2N1bWVudCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIG9wdGlvbnMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIG9wdGlvbnMuZG9jdW1lbnQgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLndpbmRvdyA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBRyBDaGFydHMgLSB1bmFibGUgdG8gcmVzb2x2ZSBnbG9iYWwgd2luZG93XCIpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5kb2N1bWVudCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBRyBDaGFydHMgLSB1bmFibGUgdG8gcmVzb2x2ZSBnbG9iYWwgZG9jdW1lbnRcIik7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9hcGkvYWdDaGFydHMudHNcbnZhciBkZWJ1ZzIgPSBEZWJ1Zy5jcmVhdGUodHJ1ZSwgXCJvcHRzXCIpO1xuZnVuY3Rpb24gY2hhcnRUeXBlKG9wdGlvbnMpIHtcbiAgaWYgKGlzQWdDYXJ0ZXNpYW5DaGFydE9wdGlvbnMob3B0aW9ucykpIHtcbiAgICByZXR1cm4gXCJjYXJ0ZXNpYW5cIjtcbiAgfSBlbHNlIGlmIChpc0FnUG9sYXJDaGFydE9wdGlvbnMob3B0aW9ucykpIHtcbiAgICByZXR1cm4gXCJwb2xhclwiO1xuICB9IGVsc2UgaWYgKGlzQWdIaWVyYXJjaHlDaGFydE9wdGlvbnMob3B0aW9ucykpIHtcbiAgICByZXR1cm4gXCJoaWVyYXJjaHlcIjtcbiAgfSBlbHNlIGlmIChpc0FnVG9wb2xvZ3lDaGFydE9wdGlvbnMob3B0aW9ucykpIHtcbiAgICByZXR1cm4gXCJ0b3BvbG9neVwiO1xuICB9IGVsc2UgaWYgKGlzQWdGbG93UHJvcG9ydGlvbkNoYXJ0T3B0aW9ucyhvcHRpb25zKSkge1xuICAgIHJldHVybiBcImZsb3ctcHJvcG9ydGlvblwiO1xuICB9IGVsc2UgaWYgKGlzQWdTdGFuZGFsb25lQ2hhcnRPcHRpb25zKG9wdGlvbnMpKSB7XG4gICAgcmV0dXJuIFwic3RhbmRhbG9uZVwiO1xuICB9IGVsc2UgaWYgKGlzQWdHYXVnZUNoYXJ0T3B0aW9ucyhvcHRpb25zKSkge1xuICAgIHJldHVybiBcImdhdWdlXCI7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBBRyBDaGFydCAtIHVua25vd24gdHlwZSBvZiBjaGFydCBmb3Igb3B0aW9ucyB3aXRoIHR5cGU6ICR7b3B0aW9ucy50eXBlfWApO1xufVxudmFyIEFnQ2hhcnRzID0gY2xhc3Mge1xuICBzdGF0aWMgbGljZW5zZUNoZWNrKG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcy5saWNlbnNlQ2hlY2tlZClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmxpY2Vuc2VNYW5hZ2VyID0gZW50ZXJwcmlzZU1vZHVsZS5saWNlbnNlTWFuYWdlcj8uKG9wdGlvbnMpO1xuICAgIHRoaXMubGljZW5zZU1hbmFnZXI/LnNldExpY2Vuc2VLZXkodGhpcy5saWNlbnNlS2V5LCB0aGlzLmdyaWRDb250ZXh0KTtcbiAgICB0aGlzLmxpY2Vuc2VNYW5hZ2VyPy52YWxpZGF0ZUxpY2Vuc2UoKTtcbiAgICB0aGlzLmxpY2Vuc2VDaGVja2VkID0gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgc2V0TGljZW5zZUtleShsaWNlbnNlS2V5KSB7XG4gICAgdGhpcy5saWNlbnNlS2V5ID0gbGljZW5zZUtleTtcbiAgfVxuICBzdGF0aWMgc2V0R3JpZENvbnRleHQoZ3JpZENvbnRleHQpIHtcbiAgICB0aGlzLmdyaWRDb250ZXh0ID0gZ3JpZENvbnRleHQ7XG4gIH1cbiAgc3RhdGljIGdldExpY2Vuc2VEZXRhaWxzKGxpY2Vuc2VLZXkpIHtcbiAgICByZXR1cm4gZW50ZXJwcmlzZU1vZHVsZS5saWNlbnNlTWFuYWdlcj8uKHt9KS5nZXRMaWNlbnNlRGV0YWlscyhsaWNlbnNlS2V5KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYEFnQ2hhcnRJbnN0YW5jZWAgZm9yIGEgRE9NIG5vZGUsIGlmIHRoZXJlIGlzIG9uZS5cbiAgICovXG4gIHN0YXRpYyBnZXRJbnN0YW5jZShlbGVtZW50Mikge1xuICAgIHJldHVybiBBZ0NoYXJ0c0ludGVybmFsLmdldEluc3RhbmNlKGVsZW1lbnQyKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBBZ0NoYXJ0SW5zdGFuY2VgIGJhc2VkIHVwb24gdGhlIGdpdmVuIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgICovXG4gIHN0YXRpYyBjcmVhdGUodXNlck9wdGlvbnMsIG9wdGlvbnNNZXRhZGF0YSkge1xuICAgIHRoaXMubGljZW5zZUNoZWNrKHVzZXJPcHRpb25zKTtcbiAgICBjb25zdCBjaGFydCA9IEFnQ2hhcnRzSW50ZXJuYWwuY3JlYXRlT3JVcGRhdGUoe1xuICAgICAgdXNlck9wdGlvbnMsXG4gICAgICBsaWNlbnNlTWFuYWdlcjogdGhpcy5saWNlbnNlTWFuYWdlcixcbiAgICAgIHN0eWxlczogZW50ZXJwcmlzZU1vZHVsZS5zdHlsZXMgIT0gbnVsbCA/IFtbXCJhZy1jaGFydHMtZW50ZXJwcmlzZVwiLCBlbnRlcnByaXNlTW9kdWxlLnN0eWxlc11dIDogW10sXG4gICAgICBvcHRpb25zTWV0YWRhdGFcbiAgICB9KTtcbiAgICBpZiAodGhpcy5saWNlbnNlTWFuYWdlcj8uaXNEaXNwbGF5V2F0ZXJtYXJrKCkgJiYgdGhpcy5saWNlbnNlTWFuYWdlcikge1xuICAgICAgZW50ZXJwcmlzZU1vZHVsZS5pbmplY3RXYXRlcm1hcms/LihjaGFydC5jaGFydC5jdHguZG9tTWFuYWdlciwgdGhpcy5saWNlbnNlTWFuYWdlci5nZXRXYXRlcm1hcmtNZXNzYWdlKCkpO1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnQ7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZUZpbmFuY2lhbENoYXJ0KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGUob3B0aW9ucywgeyBwcmVzZXRUeXBlOiBcInByaWNlLXZvbHVtZVwiIH0pO1xuICB9XG4gIHN0YXRpYyBjcmVhdGVHYXVnZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlKG9wdGlvbnMsIHsgcHJlc2V0VHlwZTogXCJnYXVnZVwiIH0pO1xuICB9XG4gIHN0YXRpYyBfX2NyZWF0ZVNwYXJrbGluZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlKG9wdGlvbnMsIHsgcHJlc2V0VHlwZTogXCJzcGFya2xpbmVcIiB9KTtcbiAgfVxufTtcbkFnQ2hhcnRzLmxpY2Vuc2VDaGVja2VkID0gZmFsc2U7XG5BZ0NoYXJ0cy5ncmlkQ29udGV4dCA9IGZhbHNlO1xudmFyIF9BZ0NoYXJ0c0ludGVybmFsID0gY2xhc3MgX0FnQ2hhcnRzSW50ZXJuYWwge1xuICBzdGF0aWMgZ2V0SW5zdGFuY2UoZWxlbWVudDIpIHtcbiAgICBjb25zdCBjaGFydCA9IENoYXJ0LmdldEluc3RhbmNlKGVsZW1lbnQyKTtcbiAgICByZXR1cm4gY2hhcnQgPyBBZ0NoYXJ0SW5zdGFuY2VQcm94eS5jaGFydEluc3RhbmNlcy5nZXQoY2hhcnQpIDogdm9pZCAwO1xuICB9XG4gIHN0YXRpYyBpbml0aWFsaXNlTW9kdWxlcygpIHtcbiAgICBpZiAoX0FnQ2hhcnRzSW50ZXJuYWwuaW5pdGlhbGlzZWQpXG4gICAgICByZXR1cm47XG4gICAgcmVnaXN0ZXJJbmJ1aWx0TW9kdWxlcygpO1xuICAgIHNldHVwTW9kdWxlcygpO1xuICAgIF9BZ0NoYXJ0c0ludGVybmFsLmluaXRpYWxpc2VkID0gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgY3JlYXRlT3JVcGRhdGUob3B0cykge1xuICAgIGxldCB7IHByb3h5IH0gPSBvcHRzO1xuICAgIGNvbnN0IHtcbiAgICAgIHVzZXJPcHRpb25zLFxuICAgICAgbGljZW5zZU1hbmFnZXIsXG4gICAgICBzdHlsZXMsXG4gICAgICBwcm9jZXNzZWRPdmVycmlkZXMgPSBwcm94eT8uY2hhcnQuY2hhcnRPcHRpb25zLnByb2Nlc3NlZE92ZXJyaWRlcyA/PyB7fSxcbiAgICAgIHNwZWNpYWxPdmVycmlkZXMgPSBwcm94eT8uY2hhcnQuY2hhcnRPcHRpb25zLnNwZWNpYWxPdmVycmlkZXMgPz8ge30sXG4gICAgICBvcHRpb25zTWV0YWRhdGEgPSBwcm94eT8uY2hhcnQuY2hhcnRPcHRpb25zLm9wdGlvbk1ldGFkYXRhID8/IHt9XG4gICAgfSA9IG9wdHM7XG4gICAgY29uc3QgeyBwcmVzZXRUeXBlIH0gPSBvcHRpb25zTWV0YWRhdGE7XG4gICAgX0FnQ2hhcnRzSW50ZXJuYWwuaW5pdGlhbGlzZU1vZHVsZXMoKTtcbiAgICBkZWJ1ZzIoXCI+Pj4gQWdDaGFydHMuY3JlYXRlT3JVcGRhdGUoKSB1c2VyIG9wdGlvbnNcIiwgdXNlck9wdGlvbnMpO1xuICAgIGxldCBtdXRhYmxlT3B0aW9ucyA9IHVzZXJPcHRpb25zO1xuICAgIGlmIChBZ0NoYXJ0cy5vcHRpb25zTXV0YXRpb25Gbikge1xuICAgICAgbXV0YWJsZU9wdGlvbnMgPSBBZ0NoYXJ0cy5vcHRpb25zTXV0YXRpb25GbihtdXRhYmxlT3B0aW9ucywgcHJlc2V0VHlwZSk7XG4gICAgICBkZWJ1ZzIoXCI+Pj4gQWdDaGFydHMuY3JlYXRlT3JVcGRhdGUoKSBNVVRBVEVEIHVzZXIgb3B0aW9uc1wiLCBtdXRhYmxlT3B0aW9ucyk7XG4gICAgfVxuICAgIGNvbnN0IHsgb3ZlcnJpZGVEZXZpY2VQaXhlbFJhdGlvLCBkb2N1bWVudDogZG9jdW1lbnQyLCB3aW5kb3c6IHVzZXJXaW5kb3csIHN0eWxlQ29udGFpbmVyLCAuLi5vcHRpb25zIH0gPSBtdXRhYmxlT3B0aW9ucztcbiAgICBjb25zdCBjaGFydE9wdGlvbnMgPSBuZXcgQ2hhcnRPcHRpb25zKFxuICAgICAgb3B0aW9ucyxcbiAgICAgIHByb2Nlc3NlZE92ZXJyaWRlcyxcbiAgICAgIHtcbiAgICAgICAgLi4uc3BlY2lhbE92ZXJyaWRlcyxcbiAgICAgICAgZG9jdW1lbnQ6IGRvY3VtZW50MixcbiAgICAgICAgd2luZG93OiB1c2VyV2luZG93LFxuICAgICAgICBvdmVycmlkZURldmljZVBpeGVsUmF0aW8sXG4gICAgICAgIHN0eWxlQ29udGFpbmVyXG4gICAgICB9LFxuICAgICAgb3B0aW9uc01ldGFkYXRhXG4gICAgKTtcbiAgICBsZXQgY2hhcnQgPSBwcm94eT8uY2hhcnQ7XG4gICAgaWYgKGNoYXJ0ID09IG51bGwgfHwgY2hhcnRUeXBlKGNoYXJ0T3B0aW9ucy5wcm9jZXNzZWRPcHRpb25zKSAhPT0gY2hhcnRUeXBlKGNoYXJ0Py5jaGFydE9wdGlvbnMucHJvY2Vzc2VkT3B0aW9ucykpIHtcbiAgICAgIGNoYXJ0ID0gX0FnQ2hhcnRzSW50ZXJuYWwuY3JlYXRlQ2hhcnRJbnN0YW5jZShjaGFydE9wdGlvbnMsIGNoYXJ0KTtcbiAgICAgIHN0eWxlcz8uZm9yRWFjaCgoW2lkLCBjc3NdKSA9PiB7XG4gICAgICAgIGNoYXJ0Py5jdHguZG9tTWFuYWdlci5hZGRTdHlsZXMoaWQsIGNzcyk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHByb3h5ID09IG51bGwpIHtcbiAgICAgIHByb3h5ID0gbmV3IEFnQ2hhcnRJbnN0YW5jZVByb3h5KGNoYXJ0LCBfQWdDaGFydHNJbnRlcm5hbC5jYWxsYmFja0FwaSwgbGljZW5zZU1hbmFnZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm94eS5jaGFydCA9IGNoYXJ0O1xuICAgIH1cbiAgICBpZiAoZGVidWcyLmNoZWNrKCkgJiYgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgd2luZG93LmFnQ2hhcnRJbnN0YW5jZXMgPz8gKHdpbmRvdy5hZ0NoYXJ0SW5zdGFuY2VzID0ge30pO1xuICAgICAgd2luZG93LmFnQ2hhcnRJbnN0YW5jZXNbY2hhcnQuaWRdID0gY2hhcnQ7XG4gICAgfVxuICAgIGNoYXJ0LnF1ZXVlZFVzZXJPcHRpb25zLnB1c2godXNlck9wdGlvbnMpO1xuICAgIGNoYXJ0LnJlcXVlc3RGYWN0b3J5VXBkYXRlKChjaGFydFJlZikgPT4ge1xuICAgICAgY2hhcnRSZWYuYXBwbHlPcHRpb25zKGNoYXJ0T3B0aW9ucyk7XG4gICAgICBjb25zdCBxdWV1ZUlkeCA9IGNoYXJ0UmVmLnF1ZXVlZFVzZXJPcHRpb25zLmluZGV4T2YodXNlck9wdGlvbnMpICsgMTtcbiAgICAgIGNoYXJ0UmVmLnF1ZXVlZFVzZXJPcHRpb25zLnNwbGljZSgwLCBxdWV1ZUlkeCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb3h5O1xuICB9XG4gIHN0YXRpYyB1cGRhdGVVc2VyRGVsdGEocHJveHksIGRlbHRhT3B0aW9ucykge1xuICAgIGRlbHRhT3B0aW9ucyA9IGRlZXBDbG9uZShkZWx0YU9wdGlvbnMsIHsgc2hhbGxvdzogW1wiZGF0YVwiXSB9KTtcbiAgICBqc29uV2FsayhcbiAgICAgIGRlbHRhT3B0aW9ucyxcbiAgICAgIChub2RlKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2Ygbm9kZSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG5vZGUpKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihub2RlLCB7IFtrZXldOiBTeW1ib2woXCJVTlNFVFwiKSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7IHNraXA6IFtcImRhdGFcIl0gfVxuICAgICk7XG4gICAgY29uc3QgeyBjaGFydCB9ID0gcHJveHk7XG4gICAgY29uc3QgbGFzdFVwZGF0ZU9wdGlvbnMgPSBjaGFydC5nZXRPcHRpb25zKCk7XG4gICAgY29uc3QgdXNlck9wdGlvbnMgPSBtZXJnZURlZmF1bHRzKGRlbHRhT3B0aW9ucywgbGFzdFVwZGF0ZU9wdGlvbnMpO1xuICAgIGRlYnVnMihcIj4+PiBBZ0NoYXJ0cy51cGRhdGVVc2VyRGVsdGEoKSB1c2VyIGRlbHRhXCIsIGRlbHRhT3B0aW9ucyk7XG4gICAgZGVidWcyKFwiQWdDaGFydHMudXBkYXRlVXNlckRlbHRhKCkgLSBiYXNlIG9wdGlvbnNcIiwgbGFzdFVwZGF0ZU9wdGlvbnMpO1xuICAgIF9BZ0NoYXJ0c0ludGVybmFsLmNyZWF0ZU9yVXBkYXRlKHsgdXNlck9wdGlvbnMsIHByb3h5IH0pO1xuICB9XG4gIHN0YXRpYyBjcmVhdGVDaGFydEluc3RhbmNlKG9wdGlvbnMsIG9sZENoYXJ0KSB7XG4gICAgY29uc3QgdHJhbnNmZXJhYmxlUmVzb3VyY2UgPSBvbGRDaGFydD8uZGVzdHJveSh7IGtlZXBUcmFuc2ZlcmFibGVSZXNvdXJjZXM6IHRydWUgfSk7XG4gICAgY29uc3QgQ2hhcnRDb25zdHJ1Y3RvciA9IF9BZ0NoYXJ0c0ludGVybmFsLmdldENoYXJ0QnlPcHRpb25zKG9wdGlvbnMucHJvY2Vzc2VkT3B0aW9ucyk7XG4gICAgcmV0dXJuIG5ldyBDaGFydENvbnN0cnVjdG9yKG9wdGlvbnMsIHRyYW5zZmVyYWJsZVJlc291cmNlKTtcbiAgfVxuICBzdGF0aWMgZ2V0Q2hhcnRCeU9wdGlvbnMob3B0aW9ucykge1xuICAgIGlmIChpc0FnQ2FydGVzaWFuQ2hhcnRPcHRpb25zKG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gQ2FydGVzaWFuQ2hhcnQ7XG4gICAgfSBlbHNlIGlmIChpc0FnSGllcmFyY2h5Q2hhcnRPcHRpb25zKG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gSGllcmFyY2h5Q2hhcnQ7XG4gICAgfSBlbHNlIGlmIChpc0FnUG9sYXJDaGFydE9wdGlvbnMob3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBQb2xhckNoYXJ0O1xuICAgIH0gZWxzZSBpZiAoaXNBZ1RvcG9sb2d5Q2hhcnRPcHRpb25zKG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gVG9wb2xvZ3lDaGFydDtcbiAgICB9IGVsc2UgaWYgKGlzQWdGbG93UHJvcG9ydGlvbkNoYXJ0T3B0aW9ucyhvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIEZsb3dQcm9wb3J0aW9uQ2hhcnQ7XG4gICAgfSBlbHNlIGlmIChpc0FnU3RhbmRhbG9uZUNoYXJ0T3B0aW9ucyhvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIFN0YW5kYWxvbmVDaGFydDtcbiAgICB9IGVsc2UgaWYgKGlzQWdHYXVnZUNoYXJ0T3B0aW9ucyhvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIEdhdWdlQ2hhcnQ7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBBRyBDaGFydHMgLSBjb3VsZG4ndCBhcHBseSBjb25maWd1cmF0aW9uLCBjaGVjayBvcHRpb25zIGFyZSBjb3JyZWN0bHkgc3RydWN0dXJlZCBhbmQgc2VyaWVzIHR5cGVzIGFyZSBzcGVjaWZpZWRgXG4gICAgKTtcbiAgfVxufTtcbl9BZ0NoYXJ0c0ludGVybmFsLmNhcmV0YWtlciA9IG5ldyBNZW1lbnRvQ2FyZXRha2VyKFZFUlNJT04pO1xuX0FnQ2hhcnRzSW50ZXJuYWwuaW5pdGlhbGlzZWQgPSBmYWxzZTtcbl9BZ0NoYXJ0c0ludGVybmFsLmNhbGxiYWNrQXBpID0ge1xuICBjYXJldGFrZXI6IF9BZ0NoYXJ0c0ludGVybmFsLmNhcmV0YWtlcixcbiAgY3JlYXRlKHVzZXJPcHRpb25zLCBwcm9jZXNzZWRPdmVycmlkZXMsIHNwZWNpYWxPdmVycmlkZXMsIG9wdGlvbnNNZXRhZGF0YSkge1xuICAgIHJldHVybiBfQWdDaGFydHNJbnRlcm5hbC5jcmVhdGVPclVwZGF0ZSh7XG4gICAgICB1c2VyT3B0aW9ucyxcbiAgICAgIHByb2Nlc3NlZE92ZXJyaWRlcyxcbiAgICAgIHNwZWNpYWxPdmVycmlkZXMsXG4gICAgICBvcHRpb25zTWV0YWRhdGFcbiAgICB9KTtcbiAgfSxcbiAgdXBkYXRlKG9wdHMsIGNoYXJ0KSB7XG4gICAgcmV0dXJuIF9BZ0NoYXJ0c0ludGVybmFsLmNyZWF0ZU9yVXBkYXRlKHsgdXNlck9wdGlvbnM6IG9wdHMsIHByb3h5OiBjaGFydCB9KTtcbiAgfSxcbiAgdXBkYXRlVXNlckRlbHRhKGNoYXJ0LCBkZWx0YU9wdGlvbnMpIHtcbiAgICByZXR1cm4gX0FnQ2hhcnRzSW50ZXJuYWwudXBkYXRlVXNlckRlbHRhKGNoYXJ0LCBkZWx0YU9wdGlvbnMpO1xuICB9XG59O1xudmFyIEFnQ2hhcnRzSW50ZXJuYWwgPSBfQWdDaGFydHNJbnRlcm5hbDtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvbWFpbi1tb2R1bGVzLnRzXG5mdW5jdGlvbiBzZXR1cENvbW11bml0eU1vZHVsZXMoKSB7XG4gIHJlZ2lzdGVySW5idWlsdE1vZHVsZXMoKTtcbiAgcmV0dXJuIHsgQWdDaGFydHMsIHZlcnNpb246IFZFUlNJT04gfTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvaW50ZWdyYXRlZC1jaGFydHMtc2NlbmUudHNcbnZhciBpbnRlZ3JhdGVkX2NoYXJ0c19zY2VuZV9leHBvcnRzID0ge307XG5fX2V4cG9ydChpbnRlZ3JhdGVkX2NoYXJ0c19zY2VuZV9leHBvcnRzLCB7XG4gIEFyYzogKCkgPT4gQXJjMixcbiAgQXJyb3dEb3duOiAoKSA9PiBBcnJvd0Rvd24sXG4gIEFycm93VXA6ICgpID0+IEFycm93VXAsXG4gIEJCb3g6ICgpID0+IEJCb3gsXG4gIEJhbmRTY2FsZTogKCkgPT4gQmFuZFNjYWxlLFxuICBDYXB0aW9uOiAoKSA9PiBDYXB0aW9uLFxuICBDaGFuZ2VEZXRlY3RhYmxlUHJvcGVydGllczogKCkgPT4gQ2hhbmdlRGV0ZWN0YWJsZVByb3BlcnRpZXMsXG4gIENpcmNsZTogKCkgPT4gQ2lyY2xlLFxuICBDb25pY0dyYWRpZW50OiAoKSA9PiBDb25pY0dyYWRpZW50LFxuICBDb250aW51b3VzU2NhbGU6ICgpID0+IENvbnRpbnVvdXNTY2FsZSxcbiAgRGlhbW9uZDogKCkgPT4gRGlhbW9uZCxcbiAgRHJvcFNoYWRvdzogKCkgPT4gRHJvcFNoYWRvdyxcbiAgRXh0ZW5kZWRQYXRoMkQ6ICgpID0+IEV4dGVuZGVkUGF0aDJELFxuICBHcmFkaWVudDogKCkgPT4gR3JhZGllbnQsXG4gIEdyb3VwOiAoKSA9PiBHcm91cCxcbiAgSGRwaUNhbnZhczogKCkgPT4gSGRwaUNhbnZhcyxcbiAgSW1hZ2U6ICgpID0+IEltYWdlLFxuICBMYWJlbDogKCkgPT4gTGFiZWwsXG4gIExheWVyOiAoKSA9PiBMYXllcixcbiAgTGluZTogKCkgPT4gTGluZSxcbiAgTGluZWFyR3JhZGllbnQ6ICgpID0+IExpbmVhckdyYWRpZW50LFxuICBMaW5lYXJTY2FsZTogKCkgPT4gTGluZWFyU2NhbGUsXG4gIE1hcmtlcjogKCkgPT4gTWFya2VyLFxuICBOb2RlOiAoKSA9PiBOb2RlLFxuICBPcmRpbmFsVGltZVNjYWxlOiAoKSA9PiBPcmRpbmFsVGltZVNjYWxlLFxuICBQYXRoOiAoKSA9PiBQYXRoLFxuICBQb2ludGVyRXZlbnRzOiAoKSA9PiBQb2ludGVyRXZlbnRzLFxuICBSYWRpYWxDb2x1bW5TaGFwZTogKCkgPT4gUmFkaWFsQ29sdW1uU2hhcGUsXG4gIFJlY3Q6ICgpID0+IFJlY3QsXG4gIFJlZHJhd1R5cGU6ICgpID0+IFJlZHJhd1R5cGUsXG4gIFJvdGF0YWJsZTogKCkgPT4gUm90YXRhYmxlLFxuICBSb3RhdGFibGVHcm91cDogKCkgPT4gUm90YXRhYmxlR3JvdXAsXG4gIFJvdGF0YWJsZVRleHQ6ICgpID0+IFJvdGF0YWJsZVRleHQsXG4gIFNjYWxhYmxlOiAoKSA9PiBTY2FsYWJsZSxcbiAgU2NhbGFibGVHcm91cDogKCkgPT4gU2NhbGFibGVHcm91cCxcbiAgU2NlbmU6ICgpID0+IFNjZW5lLFxuICBTY2VuZUNoYW5nZURldGVjdGlvbjogKCkgPT4gU2NlbmVDaGFuZ2VEZXRlY3Rpb24sXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbjogKCkgPT4gU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uLFxuICBTZWN0b3I6ICgpID0+IFNlY3RvcixcbiAgU2VjdG9yQm94OiAoKSA9PiBTZWN0b3JCb3gsXG4gIFNlbGVjdGlvbjogKCkgPT4gU2VsZWN0aW9uLFxuICBTaGFwZTogKCkgPT4gU2hhcGUsXG4gIFNxdWFyZTogKCkgPT4gU3F1YXJlLFxuICBTdmdQYXRoOiAoKSA9PiBTdmdQYXRoLFxuICBUZXh0OiAoKSA9PiBUZXh0LFxuICBUb29sdGlwOiAoKSA9PiBUb29sdGlwLFxuICBUcmFuc2Zvcm1hYmxlOiAoKSA9PiBUcmFuc2Zvcm1hYmxlLFxuICBUcmFuc2Zvcm1hYmxlVGV4dDogKCkgPT4gVHJhbnNmb3JtYWJsZVRleHQsXG4gIFRyYW5zbGF0YWJsZTogKCkgPT4gVHJhbnNsYXRhYmxlLFxuICBUcmFuc2xhdGFibGVHcm91cDogKCkgPT4gVHJhbnNsYXRhYmxlR3JvdXAsXG4gIFRyYW5zbGF0YWJsZUxheWVyOiAoKSA9PiBUcmFuc2xhdGFibGVMYXllcixcbiAgVHJpYW5nbGU6ICgpID0+IFRyaWFuZ2xlLFxuICBjYWxjdWxhdGVEZXJpdmF0aXZlRXh0cmVtYTogKCkgPT4gY2FsY3VsYXRlRGVyaXZhdGl2ZUV4dHJlbWEsXG4gIGNhbGN1bGF0ZURlcml2YXRpdmVFeHRyZW1hWFk6ICgpID0+IGNhbGN1bGF0ZURlcml2YXRpdmVFeHRyZW1hWFksXG4gIGRyYXdDb3JuZXI6ICgpID0+IGRyYXdDb3JuZXIsXG4gIGVhc2luZzogKCkgPT4gZWFzaW5nX2V4cG9ydHMsXG4gIGV2YWx1YXRlQmV6aWVyOiAoKSA9PiBldmFsdWF0ZUJlemllcixcbiAgZ2V0Rm9udDogKCkgPT4gZ2V0Rm9udCxcbiAgZ2V0TWFya2VyOiAoKSA9PiBnZXRNYXJrZXIsXG4gIGdldFJhZGlhbENvbHVtbldpZHRoOiAoKSA9PiBnZXRSYWRpYWxDb2x1bW5XaWR0aCxcbiAgbW90aW9uOiAoKSA9PiBtb3Rpb24sXG4gIHNlY3RvckJveDogKCkgPT4gc2VjdG9yQm94LFxuICBzb2x2ZUJlemllcjogKCkgPT4gc29sdmVCZXppZXIsXG4gIHNwbGl0QmV6aWVyOiAoKSA9PiBzcGxpdEJlemllcixcbiAgdG9SYWRpYW5zOiAoKSA9PiB0b1JhZGlhbnMsXG4gIHRvVG9vbHRpcEh0bWw6ICgpID0+IHRvVG9vbHRpcEh0bWxcbn0pO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9zaGFwZS9hcmMudHNcbnZhciBBcmMyID0gY2xhc3MgZXh0ZW5kcyBQYXRoIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmNlbnRlclggPSAwO1xuICAgIHRoaXMuY2VudGVyWSA9IDA7XG4gICAgdGhpcy5yYWRpdXMgPSAxMDtcbiAgICB0aGlzLnN0YXJ0QW5nbGUgPSAwO1xuICAgIHRoaXMuZW5kQW5nbGUgPSBNYXRoLlBJICogMjtcbiAgICB0aGlzLmNvdW50ZXJDbG9ja3dpc2UgPSBmYWxzZTtcbiAgICB0aGlzLnR5cGUgPSAwIC8qIE9wZW4gKi87XG4gICAgdGhpcy5yZXN0b3JlT3duU3R5bGVzKCk7XG4gIH1cbiAgZ2V0IGZ1bGxQaWUoKSB7XG4gICAgcmV0dXJuIGlzRXF1YWwobm9ybWFsaXplQW5nbGUzNjAodGhpcy5zdGFydEFuZ2xlKSwgbm9ybWFsaXplQW5nbGUzNjAodGhpcy5lbmRBbmdsZSkpO1xuICB9XG4gIHVwZGF0ZVBhdGgoKSB7XG4gICAgY29uc3QgcGF0aCA9IHRoaXMucGF0aDtcbiAgICBwYXRoLmNsZWFyKCk7XG4gICAgcGF0aC5hcmModGhpcy5jZW50ZXJYLCB0aGlzLmNlbnRlclksIHRoaXMucmFkaXVzLCB0aGlzLnN0YXJ0QW5nbGUsIHRoaXMuZW5kQW5nbGUsIHRoaXMuY291bnRlckNsb2Nrd2lzZSk7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gMSAvKiBDaG9yZCAqLykge1xuICAgICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gMiAvKiBSb3VuZCAqLyAmJiAhdGhpcy5mdWxsUGllKSB7XG4gICAgICBwYXRoLmxpbmVUbyh0aGlzLmNlbnRlclgsIHRoaXMuY2VudGVyWSk7XG4gICAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgfVxuICBjb21wdXRlQkJveCgpIHtcbiAgICByZXR1cm4gbmV3IEJCb3godGhpcy5jZW50ZXJYIC0gdGhpcy5yYWRpdXMsIHRoaXMuY2VudGVyWSAtIHRoaXMucmFkaXVzLCB0aGlzLnJhZGl1cyAqIDIsIHRoaXMucmFkaXVzICogMik7XG4gIH1cbiAgaXNQb2ludEluUGF0aCh4LCB5KSB7XG4gICAgY29uc3QgYmJveCA9IHRoaXMuZ2V0QkJveCgpO1xuICAgIHJldHVybiB0aGlzLnR5cGUgIT09IDAgLyogT3BlbiAqLyAmJiBiYm94LmNvbnRhaW5zUG9pbnQoeCwgeSkgJiYgdGhpcy5wYXRoLmlzUG9pbnRJblBhdGgoeCwgeSk7XG4gIH1cbn07XG5BcmMyLmNsYXNzTmFtZSA9IFwiQXJjXCI7XG5BcmMyLmRlZmF1bHRTdHlsZXMgPSB7IC4uLlNoYXBlLmRlZmF1bHRTdHlsZXMsIGxpbmVXaWR0aDogMSwgZmlsbFN0eWxlOiBudWxsIH07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgQXJjMi5wcm90b3R5cGUsIFwiY2VudGVyWFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBBcmMyLnByb3RvdHlwZSwgXCJjZW50ZXJZXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIEFyYzIucHJvdG90eXBlLCBcInJhZGl1c1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBBcmMyLnByb3RvdHlwZSwgXCJzdGFydEFuZ2xlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIEFyYzIucHJvdG90eXBlLCBcImVuZEFuZ2xlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIEFyYzIucHJvdG90eXBlLCBcImNvdW50ZXJDbG9ja3dpc2VcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgQXJjMi5wcm90b3R5cGUsIFwidHlwZVwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvZ3JhZGllbnQvY29uaWNHcmFkaWVudC50c1xudmFyIENvbmljR3JhZGllbnQgPSBjbGFzcyBleHRlbmRzIEdyYWRpZW50IHtcbiAgY29uc3RydWN0b3IoY29sb3JTcGFjZSwgc3RvcHMsIGFuZ2xlMiA9IDAsIGJib3gpIHtcbiAgICBzdXBlcihjb2xvclNwYWNlLCBzdG9wcywgYmJveCk7XG4gICAgdGhpcy5hbmdsZSA9IGFuZ2xlMjtcbiAgfVxuICBjcmVhdGVDYW52YXNHcmFkaWVudChjdHgsIGJib3gpIHtcbiAgICBjb25zdCBhbmdsZU9mZnNldCA9IDkwO1xuICAgIGNvbnN0IHsgY29sb3JTcGFjZSwgc3RvcHMsIGFuZ2xlOiBhbmdsZTIgfSA9IHRoaXM7XG4gICAgY29uc3QgcmFkaWFucyA9IG5vcm1hbGl6ZUFuZ2xlMzYwKHRvUmFkaWFucyhhbmdsZTIgKyBhbmdsZU9mZnNldCkpO1xuICAgIGlmICghKFwiY3JlYXRlQ29uaWNHcmFkaWVudFwiIGluIGN0eCkpIHtcbiAgICAgIGNvbnN0IGxpbmVhckdyYWRpZW50ID0gbmV3IExpbmVhckdyYWRpZW50KGNvbG9yU3BhY2UsIHN0b3BzLCBhbmdsZTIpO1xuICAgICAgcmV0dXJuIGxpbmVhckdyYWRpZW50LmNyZWF0ZUNhbnZhc0dyYWRpZW50KGN0eCwgYmJveCk7XG4gICAgfVxuICAgIGNvbnN0IGN4ID0gYmJveC54ICsgYmJveC53aWR0aCAqIDAuNTtcbiAgICBjb25zdCBjeSA9IGJib3gueSArIGJib3guaGVpZ2h0ICogMC41O1xuICAgIHJldHVybiBjdHguY3JlYXRlQ29uaWNHcmFkaWVudChyYWRpYW5zLCBjeCwgY3kpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9zaGFwZS9yYWRpYWxDb2x1bW5TaGFwZS50c1xuZnVuY3Rpb24gcm90YXRlUG9pbnQoeCwgeSwgcm90YXRpb24pIHtcbiAgY29uc3QgcmFkaXVzID0gTWF0aC5zcXJ0KHggKiogMiArIHkgKiogMik7XG4gIGNvbnN0IGFuZ2xlMiA9IE1hdGguYXRhbjIoeSwgeCk7XG4gIGNvbnN0IHJvdGF0ZWQgPSBhbmdsZTIgKyByb3RhdGlvbjtcbiAgcmV0dXJuIHtcbiAgICB4OiBNYXRoLmNvcyhyb3RhdGVkKSAqIHJhZGl1cyxcbiAgICB5OiBNYXRoLnNpbihyb3RhdGVkKSAqIHJhZGl1c1xuICB9O1xufVxudmFyIFJhZGlhbENvbHVtblNoYXBlID0gY2xhc3MgZXh0ZW5kcyBQYXRoIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmlzQmV2ZWxlZCA9IHRydWU7XG4gICAgdGhpcy5jb2x1bW5XaWR0aCA9IDA7XG4gICAgdGhpcy5zdGFydEFuZ2xlID0gMDtcbiAgICB0aGlzLmVuZEFuZ2xlID0gMDtcbiAgICB0aGlzLm91dGVyUmFkaXVzID0gMDtcbiAgICB0aGlzLmlubmVyUmFkaXVzID0gMDtcbiAgICB0aGlzLmF4aXNJbm5lclJhZGl1cyA9IDA7XG4gICAgdGhpcy5heGlzT3V0ZXJSYWRpdXMgPSAwO1xuICAgIHRoaXMuaXNSYWRpdXNBeGlzUmV2ZXJzZWQgPSBmYWxzZTtcbiAgfVxuICBzZXQgY29ybmVyUmFkaXVzKF92YWx1ZSkge1xuICB9XG4gIGNvbXB1dGVCQm94KCkge1xuICAgIGNvbnN0IHsgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCBjb2x1bW5XaWR0aCB9ID0gdGhpcztcbiAgICBjb25zdCByb3RhdGlvbiA9IHRoaXMuZ2V0Um90YXRpb24oKTtcbiAgICBjb25zdCBsZWZ0ID0gLWNvbHVtbldpZHRoIC8gMjtcbiAgICBjb25zdCByaWdodCA9IGNvbHVtbldpZHRoIC8gMjtcbiAgICBjb25zdCB0b3AgPSAtb3V0ZXJSYWRpdXM7XG4gICAgY29uc3QgYm90dG9tID0gLWlubmVyUmFkaXVzO1xuICAgIGxldCB4MCA9IEluZmluaXR5O1xuICAgIGxldCB5MCA9IEluZmluaXR5O1xuICAgIGxldCB4MSA9IC1JbmZpbml0eTtcbiAgICBsZXQgeTEgPSAtSW5maW5pdHk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpICs9IDEpIHtcbiAgICAgIGNvbnN0IHsgeCwgeSB9ID0gcm90YXRlUG9pbnQoaSAlIDIgPT09IDAgPyBsZWZ0IDogcmlnaHQsIGkgPCAyID8gdG9wIDogYm90dG9tLCByb3RhdGlvbik7XG4gICAgICB4MCA9IE1hdGgubWluKHgsIHgwKTtcbiAgICAgIHkwID0gTWF0aC5taW4oeSwgeTApO1xuICAgICAgeDEgPSBNYXRoLm1heCh4LCB4MSk7XG4gICAgICB5MSA9IE1hdGgubWF4KHksIHkxKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCQm94KHgwLCB5MCwgeDEgLSB4MCwgeTEgLSB5MCk7XG4gIH1cbiAgZ2V0Um90YXRpb24oKSB7XG4gICAgY29uc3QgeyBzdGFydEFuZ2xlLCBlbmRBbmdsZSB9ID0gdGhpcztcbiAgICBjb25zdCBtaWRBbmdsZSA9IGFuZ2xlQmV0d2VlbihzdGFydEFuZ2xlLCBlbmRBbmdsZSk7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZUFuZ2xlMzYwKHN0YXJ0QW5nbGUgKyBtaWRBbmdsZSAvIDIgKyBNYXRoLlBJIC8gMik7XG4gIH1cbiAgdXBkYXRlUGF0aCgpIHtcbiAgICBjb25zdCB7IGlzQmV2ZWxlZCB9ID0gdGhpcztcbiAgICBpZiAoaXNCZXZlbGVkKSB7XG4gICAgICB0aGlzLnVwZGF0ZUJldmVsZWRQYXRoKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudXBkYXRlUmVjdGFuZ3VsYXJQYXRoKCk7XG4gICAgfVxuICAgIHRoaXMuY2hlY2tQYXRoRGlydHkoKTtcbiAgfVxuICB1cGRhdGVSZWN0YW5ndWxhclBhdGgoKSB7XG4gICAgY29uc3QgeyBjb2x1bW5XaWR0aCwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCBwYXRoIH0gPSB0aGlzO1xuICAgIGNvbnN0IGxlZnQgPSAtY29sdW1uV2lkdGggLyAyO1xuICAgIGNvbnN0IHJpZ2h0ID0gY29sdW1uV2lkdGggLyAyO1xuICAgIGNvbnN0IHRvcCA9IC1vdXRlclJhZGl1cztcbiAgICBjb25zdCBib3R0b20gPSAtaW5uZXJSYWRpdXM7XG4gICAgY29uc3Qgcm90YXRpb24gPSB0aGlzLmdldFJvdGF0aW9uKCk7XG4gICAgY29uc3QgcG9pbnRzID0gW1xuICAgICAgW2xlZnQsIGJvdHRvbV0sXG4gICAgICBbbGVmdCwgdG9wXSxcbiAgICAgIFtyaWdodCwgdG9wXSxcbiAgICAgIFtyaWdodCwgYm90dG9tXVxuICAgIF0ubWFwKChbeCwgeV0pID0+IHJvdGF0ZVBvaW50KHgsIHksIHJvdGF0aW9uKSk7XG4gICAgcGF0aC5jbGVhcih0cnVlKTtcbiAgICBwYXRoLm1vdmVUbyhwb2ludHNbMF0ueCwgcG9pbnRzWzBdLnkpO1xuICAgIHBhdGgubGluZVRvKHBvaW50c1sxXS54LCBwb2ludHNbMV0ueSk7XG4gICAgcGF0aC5saW5lVG8ocG9pbnRzWzJdLngsIHBvaW50c1syXS55KTtcbiAgICBwYXRoLmxpbmVUbyhwb2ludHNbM10ueCwgcG9pbnRzWzNdLnkpO1xuICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gIH1cbiAgdXBkYXRlQmV2ZWxlZFBhdGgoKSB7XG4gICAgY29uc3QgeyBjb2x1bW5XaWR0aCwgcGF0aCwgb3V0ZXJSYWRpdXMsIGlubmVyUmFkaXVzLCBheGlzSW5uZXJSYWRpdXMsIGF4aXNPdXRlclJhZGl1cywgaXNSYWRpdXNBeGlzUmV2ZXJzZWQgfSA9IHRoaXM7XG4gICAgY29uc3QgaXNTdGFja0JvdHRvbSA9IGlzRXF1YWwoaW5uZXJSYWRpdXMsIGF4aXNJbm5lclJhZGl1cyk7XG4gICAgY29uc3Qgc2lkZVJvdGF0aW9uID0gTWF0aC5hc2luKGNvbHVtbldpZHRoIC8gMiAvIGlubmVyUmFkaXVzKTtcbiAgICBjb25zdCBwb2ludFJvdGF0aW9uID0gdGhpcy5nZXRSb3RhdGlvbigpO1xuICAgIGNvbnN0IHJvdGF0ZTIgPSAoeCwgeSkgPT4gcm90YXRlUG9pbnQoeCwgeSwgcG9pbnRSb3RhdGlvbik7XG4gICAgY29uc3QgZ2V0VHJpYW5nbGVIeXBvdGVudXNlID0gKGxlZywgb3RoZXJMZWcpID0+IE1hdGguc3FydChsZWcgKiogMiArIG90aGVyTGVnICoqIDIpO1xuICAgIGNvbnN0IGdldFRyaWFuZ2xlTGVnID0gKGh5cG90ZW51c2UsIG90aGVyTGVnKSA9PiB7XG4gICAgICBpZiAob3RoZXJMZWcgPiBoeXBvdGVudXNlKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE1hdGguc3FydChoeXBvdGVudXNlICoqIDIgLSBvdGhlckxlZyAqKiAyKTtcbiAgICB9O1xuICAgIGNvbnN0IGNvbXBhcmUgPSAodmFsdWUsIG90aGVyVmFsdWUsIGxlc3NUaGFuKSA9PiBsZXNzVGhhbiA/IHZhbHVlIDwgb3RoZXJWYWx1ZSA6IHZhbHVlID4gb3RoZXJWYWx1ZTtcbiAgICBjb25zdCBzaG91bGRDb25uZWN0Qm90dG9tQ2lyY2xlID0gaXNTdGFja0JvdHRvbSAmJiAhaXNOYU4oc2lkZVJvdGF0aW9uKSAmJiBzaWRlUm90YXRpb24gPCBNYXRoLlBJIC8gNjtcbiAgICBsZXQgbGVmdCA9IC1jb2x1bW5XaWR0aCAvIDI7XG4gICAgbGV0IHJpZ2h0ID0gY29sdW1uV2lkdGggLyAyO1xuICAgIGNvbnN0IHRvcCA9IC1vdXRlclJhZGl1cztcbiAgICBjb25zdCBib3R0b20gPSAtaW5uZXJSYWRpdXMgKiAoc2hvdWxkQ29ubmVjdEJvdHRvbUNpcmNsZSA/IE1hdGguY29zKHNpZGVSb3RhdGlvbikgOiAxKTtcbiAgICBjb25zdCBoYXNCb3R0b21JbnRlcnNlY3Rpb24gPSBjb21wYXJlKFxuICAgICAgYXhpc091dGVyUmFkaXVzLFxuICAgICAgZ2V0VHJpYW5nbGVIeXBvdGVudXNlKGlubmVyUmFkaXVzLCBjb2x1bW5XaWR0aCAvIDIpLFxuICAgICAgIWlzUmFkaXVzQXhpc1JldmVyc2VkXG4gICAgKTtcbiAgICBpZiAoaGFzQm90dG9tSW50ZXJzZWN0aW9uKSB7XG4gICAgICBjb25zdCBib3R0b21JbnRlcnNlY3Rpb25YID0gZ2V0VHJpYW5nbGVMZWcoYXhpc091dGVyUmFkaXVzLCBpbm5lclJhZGl1cyk7XG4gICAgICBsZWZ0ID0gLWJvdHRvbUludGVyc2VjdGlvblg7XG4gICAgICByaWdodCA9IGJvdHRvbUludGVyc2VjdGlvblg7XG4gICAgfVxuICAgIHBhdGguY2xlYXIodHJ1ZSk7XG4gICAgY29uc3QgYm90dG9tTGVmdFB0ID0gcm90YXRlMihsZWZ0LCBib3R0b20pO1xuICAgIHBhdGgubW92ZVRvKGJvdHRvbUxlZnRQdC54LCBib3R0b21MZWZ0UHQueSk7XG4gICAgY29uc3QgaXNFbXB0eSA9IGlzRXF1YWwoaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzKTtcbiAgICBjb25zdCBoYXNTaWRlSW50ZXJzZWN0aW9uID0gY29tcGFyZShcbiAgICAgIGF4aXNPdXRlclJhZGl1cyxcbiAgICAgIGdldFRyaWFuZ2xlSHlwb3RlbnVzZShvdXRlclJhZGl1cywgY29sdW1uV2lkdGggLyAyKSxcbiAgICAgICFpc1JhZGl1c0F4aXNSZXZlcnNlZFxuICAgICk7XG4gICAgaWYgKGlzRW1wdHkgJiYgc2hvdWxkQ29ubmVjdEJvdHRvbUNpcmNsZSkge1xuICAgICAgcGF0aC5hcmMoXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIGlubmVyUmFkaXVzLFxuICAgICAgICBub3JtYWxpemVBbmdsZTM2MCgtc2lkZVJvdGF0aW9uIC0gTWF0aC5QSSAvIDIpICsgcG9pbnRSb3RhdGlvbixcbiAgICAgICAgbm9ybWFsaXplQW5nbGUzNjAoc2lkZVJvdGF0aW9uIC0gTWF0aC5QSSAvIDIpICsgcG9pbnRSb3RhdGlvbixcbiAgICAgICAgZmFsc2VcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChoYXNTaWRlSW50ZXJzZWN0aW9uKSB7XG4gICAgICBjb25zdCBzaWRlSW50ZXJzZWN0aW9uWSA9IC1nZXRUcmlhbmdsZUxlZyhheGlzT3V0ZXJSYWRpdXMsIGNvbHVtbldpZHRoIC8gMik7XG4gICAgICBjb25zdCB0b3BJbnRlcnNlY3Rpb25YID0gZ2V0VHJpYW5nbGVMZWcoYXhpc091dGVyUmFkaXVzLCBvdXRlclJhZGl1cyk7XG4gICAgICBpZiAoIWhhc0JvdHRvbUludGVyc2VjdGlvbikge1xuICAgICAgICBjb25zdCB0b3BMZWZ0UHQgPSByb3RhdGUyKGxlZnQsIHNpZGVJbnRlcnNlY3Rpb25ZKTtcbiAgICAgICAgcGF0aC5saW5lVG8odG9wTGVmdFB0LngsIHRvcExlZnRQdC55KTtcbiAgICAgIH1cbiAgICAgIHBhdGguYXJjKFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICBheGlzT3V0ZXJSYWRpdXMsXG4gICAgICAgIE1hdGguYXRhbjIoc2lkZUludGVyc2VjdGlvblksIGxlZnQpICsgcG9pbnRSb3RhdGlvbixcbiAgICAgICAgTWF0aC5hdGFuMih0b3AsIC10b3BJbnRlcnNlY3Rpb25YKSArIHBvaW50Um90YXRpb24sXG4gICAgICAgIGZhbHNlXG4gICAgICApO1xuICAgICAgaWYgKCFpc0VxdWFsKHRvcEludGVyc2VjdGlvblgsIDApKSB7XG4gICAgICAgIGNvbnN0IHRvcFJpZ2h0QmV2ZWxQdCA9IHJvdGF0ZTIodG9wSW50ZXJzZWN0aW9uWCwgdG9wKTtcbiAgICAgICAgcGF0aC5saW5lVG8odG9wUmlnaHRCZXZlbFB0LngsIHRvcFJpZ2h0QmV2ZWxQdC55KTtcbiAgICAgIH1cbiAgICAgIHBhdGguYXJjKFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICBheGlzT3V0ZXJSYWRpdXMsXG4gICAgICAgIE1hdGguYXRhbjIodG9wLCB0b3BJbnRlcnNlY3Rpb25YKSArIHBvaW50Um90YXRpb24sXG4gICAgICAgIE1hdGguYXRhbjIoc2lkZUludGVyc2VjdGlvblksIHJpZ2h0KSArIHBvaW50Um90YXRpb24sXG4gICAgICAgIGZhbHNlXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0b3BMZWZ0UHQgPSByb3RhdGUyKGxlZnQsIHRvcCk7XG4gICAgICBjb25zdCB0b3BSaWdodFB0ID0gcm90YXRlMihyaWdodCwgdG9wKTtcbiAgICAgIHBhdGgubGluZVRvKHRvcExlZnRQdC54LCB0b3BMZWZ0UHQueSk7XG4gICAgICBwYXRoLmxpbmVUbyh0b3BSaWdodFB0LngsIHRvcFJpZ2h0UHQueSk7XG4gICAgfVxuICAgIGNvbnN0IGJvdHRvbVJpZ2h0UHQgPSByb3RhdGUyKHJpZ2h0LCBib3R0b20pO1xuICAgIHBhdGgubGluZVRvKGJvdHRvbVJpZ2h0UHQueCwgYm90dG9tUmlnaHRQdC55KTtcbiAgICBpZiAoc2hvdWxkQ29ubmVjdEJvdHRvbUNpcmNsZSkge1xuICAgICAgcGF0aC5hcmMoXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIGlubmVyUmFkaXVzLFxuICAgICAgICBub3JtYWxpemVBbmdsZTM2MChzaWRlUm90YXRpb24gLSBNYXRoLlBJIC8gMikgKyBwb2ludFJvdGF0aW9uLFxuICAgICAgICBub3JtYWxpemVBbmdsZTM2MCgtc2lkZVJvdGF0aW9uIC0gTWF0aC5QSSAvIDIpICsgcG9pbnRSb3RhdGlvbixcbiAgICAgICAgdHJ1ZVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgcm90YXRlZEJvdHRvbUxlZnRQdCA9IHJvdGF0ZTIobGVmdCwgYm90dG9tKTtcbiAgICAgIHBhdGgubGluZVRvKHJvdGF0ZWRCb3R0b21MZWZ0UHQueCwgcm90YXRlZEJvdHRvbUxlZnRQdC55KTtcbiAgICB9XG4gICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgfVxufTtcblJhZGlhbENvbHVtblNoYXBlLmNsYXNzTmFtZSA9IFwiUmFkaWFsQ29sdW1uU2hhcGVcIjtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBSYWRpYWxDb2x1bW5TaGFwZS5wcm90b3R5cGUsIFwiaXNCZXZlbGVkXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFJhZGlhbENvbHVtblNoYXBlLnByb3RvdHlwZSwgXCJjb2x1bW5XaWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBSYWRpYWxDb2x1bW5TaGFwZS5wcm90b3R5cGUsIFwic3RhcnRBbmdsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBSYWRpYWxDb2x1bW5TaGFwZS5wcm90b3R5cGUsIFwiZW5kQW5nbGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgUmFkaWFsQ29sdW1uU2hhcGUucHJvdG90eXBlLCBcIm91dGVyUmFkaXVzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFJhZGlhbENvbHVtblNoYXBlLnByb3RvdHlwZSwgXCJpbm5lclJhZGl1c1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBSYWRpYWxDb2x1bW5TaGFwZS5wcm90b3R5cGUsIFwiYXhpc0lubmVyUmFkaXVzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFJhZGlhbENvbHVtblNoYXBlLnByb3RvdHlwZSwgXCJheGlzT3V0ZXJSYWRpdXNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgUmFkaWFsQ29sdW1uU2hhcGUucHJvdG90eXBlLCBcImlzUmFkaXVzQXhpc1JldmVyc2VkXCIsIDIpO1xuZnVuY3Rpb24gZ2V0UmFkaWFsQ29sdW1uV2lkdGgoc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGF4aXNPdXRlclJhZGl1cywgY29sdW1uV2lkdGhSYXRpbywgbWF4Q29sdW1uV2lkdGhSYXRpbykge1xuICBjb25zdCByb3RhdGlvbiA9IGFuZ2xlQmV0d2VlbihzdGFydEFuZ2xlLCBlbmRBbmdsZSk7XG4gIGNvbnN0IHBhZDIgPSByb3RhdGlvbiAqICgxIC0gY29sdW1uV2lkdGhSYXRpbykgLyAyO1xuICBzdGFydEFuZ2xlICs9IHBhZDI7XG4gIGVuZEFuZ2xlIC09IHBhZDI7XG4gIGlmIChyb3RhdGlvbiA8IDFlLTMpIHtcbiAgICByZXR1cm4gMiAqIGF4aXNPdXRlclJhZGl1cyAqIG1heENvbHVtbldpZHRoUmF0aW87XG4gIH1cbiAgaWYgKHJvdGF0aW9uID49IDIgKiBNYXRoLlBJKSB7XG4gICAgY29uc3QgbWlkQW5nbGUgPSBzdGFydEFuZ2xlICsgcm90YXRpb24gLyAyO1xuICAgIHN0YXJ0QW5nbGUgPSBtaWRBbmdsZSAtIE1hdGguUEk7XG4gICAgZW5kQW5nbGUgPSBtaWRBbmdsZSArIE1hdGguUEk7XG4gIH1cbiAgY29uc3Qgc3RhcnRYID0gYXhpc091dGVyUmFkaXVzICogTWF0aC5jb3Moc3RhcnRBbmdsZSk7XG4gIGNvbnN0IHN0YXJ0WSA9IGF4aXNPdXRlclJhZGl1cyAqIE1hdGguc2luKHN0YXJ0QW5nbGUpO1xuICBjb25zdCBlbmRYID0gYXhpc091dGVyUmFkaXVzICogTWF0aC5jb3MoZW5kQW5nbGUpO1xuICBjb25zdCBlbmRZID0gYXhpc091dGVyUmFkaXVzICogTWF0aC5zaW4oZW5kQW5nbGUpO1xuICBjb25zdCBjb2xXaWR0aCA9IE1hdGguZmxvb3IoTWF0aC5zcXJ0KChzdGFydFggLSBlbmRYKSAqKiAyICsgKHN0YXJ0WSAtIGVuZFkpICoqIDIpKTtcbiAgY29uc3QgbWF4V2lkdGggPSAyICogYXhpc091dGVyUmFkaXVzICogbWF4Q29sdW1uV2lkdGhSYXRpbztcbiAgcmV0dXJuIE1hdGgubWF4KDEsIE1hdGgubWluKG1heFdpZHRoLCBjb2xXaWR0aCkpO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9zaGFwZS9zdmdQYXRoLnRzXG52YXIgU3ZnUGF0aCA9IGNsYXNzIGV4dGVuZHMgUGF0aCB7XG4gIGNvbnN0cnVjdG9yKGQgPSBcIlwiKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gICAgdGhpcy5jb21tYW5kcyA9IFtdO1xuICAgIHRoaXMuX2QgPSBcIlwiO1xuICAgIHRoaXMuZCA9IGQ7XG4gIH1cbiAgZ2V0IGQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Q7XG4gIH1cbiAgc2V0IGQoZCkge1xuICAgIGlmIChkID09PSB0aGlzLl9kKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2QgPSBkO1xuICAgIHRoaXMuY29tbWFuZHMubGVuZ3RoID0gMDtcbiAgICBmb3IgKGNvbnN0IFtfLCBjb21tYW5kLCBwYXJhbXNTdHJpbmddIG9mIGQubWF0Y2hBbGwoLyhbQS1aXSkoWzAtOS4gXSopL2cpKSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSBwYXJhbXNTdHJpbmcuc3BsaXQoL1xccysvZykubWFwKE51bWJlcik7XG4gICAgICB0aGlzLmNvbW1hbmRzLnB1c2goW2NvbW1hbmQsIHBhcmFtc10pO1xuICAgIH1cbiAgICB0aGlzLmNoZWNrUGF0aERpcnR5KCk7XG4gIH1cbiAgdXBkYXRlUGF0aCgpIHtcbiAgICBjb25zdCB7IHBhdGgsIHgsIHkgfSA9IHRoaXM7XG4gICAgcGF0aC5jbGVhcigpO1xuICAgIGxldCBsYXN0WCA9IHg7XG4gICAgbGV0IGxhc3RZID0geTtcbiAgICBmb3IgKGNvbnN0IFtjb21tYW5kLCBwYXJhbXNdIG9mIHRoaXMuY29tbWFuZHMpIHtcbiAgICAgIHN3aXRjaCAoY29tbWFuZCkge1xuICAgICAgICBjYXNlIFwiTVwiOlxuICAgICAgICAgIHBhdGgubW92ZVRvKHggKyBwYXJhbXNbMF0sIHkgKyBwYXJhbXNbMV0pO1xuICAgICAgICAgIGxhc3RYID0geCArIHBhcmFtc1swXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkNcIjpcbiAgICAgICAgICBwYXRoLmN1YmljQ3VydmVUbyhcbiAgICAgICAgICAgIHggKyBwYXJhbXNbMF0sXG4gICAgICAgICAgICB5ICsgcGFyYW1zWzFdLFxuICAgICAgICAgICAgeCArIHBhcmFtc1syXSxcbiAgICAgICAgICAgIHkgKyBwYXJhbXNbM10sXG4gICAgICAgICAgICB4ICsgcGFyYW1zWzRdLFxuICAgICAgICAgICAgeSArIHBhcmFtc1s1XVxuICAgICAgICAgICk7XG4gICAgICAgICAgbGFzdFggPSB4ICsgcGFyYW1zWzRdO1xuICAgICAgICAgIGxhc3RZID0geSArIHBhcmFtc1s1XTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkhcIjpcbiAgICAgICAgICBwYXRoLmxpbmVUbyh4ICsgcGFyYW1zWzBdLCBsYXN0WSk7XG4gICAgICAgICAgbGFzdFggPSB5ICsgcGFyYW1zWzBdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTFwiOlxuICAgICAgICAgIHBhdGgubGluZVRvKHggKyBwYXJhbXNbMF0sIHkgKyBwYXJhbXNbMV0pO1xuICAgICAgICAgIGxhc3RYID0geCArIHBhcmFtc1swXTtcbiAgICAgICAgICBsYXN0WSA9IHkgKyBwYXJhbXNbMV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJWXCI6XG4gICAgICAgICAgcGF0aC5saW5lVG8obGFzdFgsIHkgKyBwYXJhbXNbMF0pO1xuICAgICAgICAgIGxhc3RZID0geSArIHBhcmFtc1swXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlpcIjpcbiAgICAgICAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IHRyYW5zbGF0ZSBjb21tYW5kICcke2NvbW1hbmR9JyB3aXRoICcke3BhcmFtcy5qb2luKFwiIFwiKX0nYCk7XG4gICAgICB9XG4gICAgfVxuICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgU3ZnUGF0aC5wcm90b3R5cGUsIFwieFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBTdmdQYXRoLnByb3RvdHlwZSwgXCJ5XCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9tYXJrZXIvYXJyb3dVcC50c1xudmFyIF9BcnJvd1VwID0gY2xhc3MgX0Fycm93VXAgZXh0ZW5kcyBNYXJrZXIge1xuICB1cGRhdGVQYXRoKCkge1xuICAgIGNvbnN0IHMgPSB0aGlzLnNpemUgLyAyO1xuICAgIHN1cGVyLmFwcGx5UGF0aChzLCBfQXJyb3dVcC5tb3Zlcyk7XG4gIH1cbn07XG5fQXJyb3dVcC5jbGFzc05hbWUgPSBcIkFycm93VXBcIjtcbl9BcnJvd1VwLm1vdmVzID0gW1xuICB7IHg6IDAsIHk6IDAsIHQ6IFwibW92ZVwiIH0sXG4gIHsgeDogMSwgeTogMS4yIH0sXG4gIHsgeDogLTAuNSwgeTogMCB9LFxuICB7IHg6IDAsIHk6IDAuOCB9LFxuICB7IHg6IC0xLCB5OiAwIH0sXG4gIHsgeDogMCwgeTogLTAuOCB9LFxuICB7IHg6IC0wLjUsIHk6IDAgfVxuXTtcbnZhciBBcnJvd1VwID0gX0Fycm93VXA7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L21hcmtlci9hcnJvd0Rvd24udHNcbnZhciBBcnJvd0Rvd24gPSBjbGFzcyBleHRlbmRzIE1hcmtlciB7XG4gIHVwZGF0ZVBhdGgoKSB7XG4gICAgY29uc3QgcyA9IHRoaXMuc2l6ZSAvIDI7XG4gICAgc3VwZXIuYXBwbHlQYXRoKFxuICAgICAgcyxcbiAgICAgIEFycm93VXAubW92ZXMubWFwKChtKSA9PiAoeyB4OiBtLnggKiAtMSwgeTogbS55ICogLTEgfSkpXG4gICAgKTtcbiAgfVxufTtcbkFycm93RG93bi5jbGFzc05hbWUgPSBcIkFycm93RG93blwiO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9pbnRlZ3JhdGVkLWNoYXJ0cy1zY2VuZS50c1xudmFyIG1vdGlvbiA9IHsgLi4uZnJvbVRvTW90aW9uX2V4cG9ydHMsIC4uLnJlc2V0TW90aW9uX2V4cG9ydHMgfTtcbnZhciBnZXRGb250ID0gVGV4dFV0aWxzLnRvRm9udFN0cmluZztcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvaW50ZWdyYXRlZC1jaGFydHMtdGhlbWUudHNcbnZhciBpbnRlZ3JhdGVkX2NoYXJ0c190aGVtZV9leHBvcnRzID0ge307XG5fX2V4cG9ydChpbnRlZ3JhdGVkX2NoYXJ0c190aGVtZV9leHBvcnRzLCB7XG4gIENBUlRFU0lBTl9BWElTX1RZUEU6ICgpID0+IENBUlRFU0lBTl9BWElTX1RZUEUsXG4gIENBUlRFU0lBTl9QT1NJVElPTjogKCkgPT4gQ0FSVEVTSUFOX1BPU0lUSU9OLFxuICBDaGFydFRoZW1lOiAoKSA9PiBDaGFydFRoZW1lLFxuICBERUZBVUxUX0FOTk9UQVRJT05fQkFDS0dST1VORF9GSUxMOiAoKSA9PiBERUZBVUxUX0FOTk9UQVRJT05fQkFDS0dST1VORF9GSUxMLFxuICBERUZBVUxUX0FOTk9UQVRJT05fQ09MT1I6ICgpID0+IERFRkFVTFRfQU5OT1RBVElPTl9DT0xPUixcbiAgREVGQVVMVF9BTk5PVEFUSU9OX0hBTkRMRV9GSUxMOiAoKSA9PiBERUZBVUxUX0FOTk9UQVRJT05fSEFORExFX0ZJTEwsXG4gIERFRkFVTFRfQU5OT1RBVElPTl9TVEFUSVNUSUNTX0NPTE9SOiAoKSA9PiBERUZBVUxUX0FOTk9UQVRJT05fU1RBVElTVElDU19DT0xPUixcbiAgREVGQVVMVF9BTk5PVEFUSU9OX1NUQVRJU1RJQ1NfRElWSURFUl9TVFJPS0U6ICgpID0+IERFRkFVTFRfQU5OT1RBVElPTl9TVEFUSVNUSUNTX0RJVklERVJfU1RST0tFLFxuICBERUZBVUxUX0FOTk9UQVRJT05fU1RBVElTVElDU19ET1dOX0ZJTEw6ICgpID0+IERFRkFVTFRfQU5OT1RBVElPTl9TVEFUSVNUSUNTX0RPV05fRklMTCxcbiAgREVGQVVMVF9BTk5PVEFUSU9OX1NUQVRJU1RJQ1NfRE9XTl9TVFJPS0U6ICgpID0+IERFRkFVTFRfQU5OT1RBVElPTl9TVEFUSVNUSUNTX0RPV05fU1RST0tFLFxuICBERUZBVUxUX0FOTk9UQVRJT05fU1RBVElTVElDU19GSUxMOiAoKSA9PiBERUZBVUxUX0FOTk9UQVRJT05fU1RBVElTVElDU19GSUxMLFxuICBERUZBVUxUX0FOTk9UQVRJT05fU1RBVElTVElDU19TVFJPS0U6ICgpID0+IERFRkFVTFRfQU5OT1RBVElPTl9TVEFUSVNUSUNTX1NUUk9LRSxcbiAgREVGQVVMVF9BWElTX0dSSURfQ09MT1VSOiAoKSA9PiBERUZBVUxUX0FYSVNfR1JJRF9DT0xPVVIsXG4gIERFRkFVTFRfQVhJU19MSU5FX0NPTE9VUjogKCkgPT4gREVGQVVMVF9BWElTX0xJTkVfQ09MT1VSLFxuICBERUZBVUxUX0JBQ0tHUk9VTkRfQ09MT1VSOiAoKSA9PiBERUZBVUxUX0JBQ0tHUk9VTkRfQ09MT1VSLFxuICBERUZBVUxUX0NBUFRJT05fQUxJR05NRU5UOiAoKSA9PiBERUZBVUxUX0NBUFRJT05fQUxJR05NRU5ULFxuICBERUZBVUxUX0NBUFRJT05fTEFZT1VUX1NUWUxFOiAoKSA9PiBERUZBVUxUX0NBUFRJT05fTEFZT1VUX1NUWUxFLFxuICBERUZBVUxUX0NPTE9VUlM6ICgpID0+IERFRkFVTFRfQ09MT1VSUyxcbiAgREVGQVVMVF9DUk9TU19MSU5FU19DT0xPVVI6ICgpID0+IERFRkFVTFRfQ1JPU1NfTElORVNfQ09MT1VSLFxuICBERUZBVUxUX0RJVkVSR0lOR19TRVJJRVNfQ09MT1JfUkFOR0U6ICgpID0+IERFRkFVTFRfRElWRVJHSU5HX1NFUklFU19DT0xPUl9SQU5HRSxcbiAgREVGQVVMVF9GT05UX0ZBTUlMWTogKCkgPT4gREVGQVVMVF9GT05UX0ZBTUlMWSxcbiAgREVGQVVMVF9GVU5ORUxfU0VSSUVTX0NPTE9SX1JBTkdFOiAoKSA9PiBERUZBVUxUX0ZVTk5FTF9TRVJJRVNfQ09MT1JfUkFOR0UsXG4gIERFRkFVTFRfR0FVR0VfU0VSSUVTX0NPTE9SX1JBTkdFOiAoKSA9PiBERUZBVUxUX0dBVUdFX1NFUklFU19DT0xPUl9SQU5HRSxcbiAgREVGQVVMVF9HUklETElORV9FTkFCTEVEOiAoKSA9PiBERUZBVUxUX0dSSURMSU5FX0VOQUJMRUQsXG4gIERFRkFVTFRfSElFUkFSQ0hZX0ZJTExTOiAoKSA9PiBERUZBVUxUX0hJRVJBUkNIWV9GSUxMUyxcbiAgREVGQVVMVF9ISUVSQVJDSFlfU1RST0tFUzogKCkgPT4gREVGQVVMVF9ISUVSQVJDSFlfU1RST0tFUyxcbiAgREVGQVVMVF9JTlNJREVfU0VSSUVTX0xBQkVMX0NPTE9VUjogKCkgPT4gREVGQVVMVF9JTlNJREVfU0VSSUVTX0xBQkVMX0NPTE9VUixcbiAgREVGQVVMVF9JTlZFUlRFRF9MQUJFTF9DT0xPVVI6ICgpID0+IERFRkFVTFRfSU5WRVJURURfTEFCRUxfQ09MT1VSLFxuICBERUZBVUxUX0xBQkVMX0NPTE9VUjogKCkgPT4gREVGQVVMVF9MQUJFTF9DT0xPVVIsXG4gIERFRkFVTFRfTVVURURfTEFCRUxfQ09MT1VSOiAoKSA9PiBERUZBVUxUX01VVEVEX0xBQkVMX0NPTE9VUixcbiAgREVGQVVMVF9QQURESU5HOiAoKSA9PiBERUZBVUxUX1BBRERJTkcsXG4gIERFRkFVTFRfUE9MQVJfU0VSSUVTX1NUUk9LRTogKCkgPT4gREVGQVVMVF9QT0xBUl9TRVJJRVNfU1RST0tFLFxuICBERUZBVUxUX1NIQURPV19DT0xPVVI6ICgpID0+IERFRkFVTFRfU0hBRE9XX0NPTE9VUixcbiAgREVGQVVMVF9URVhUQk9YX0NPTE9SOiAoKSA9PiBERUZBVUxUX1RFWFRCT1hfQ09MT1IsXG4gIERFRkFVTFRfVEVYVEJPWF9GSUxMOiAoKSA9PiBERUZBVUxUX1RFWFRCT1hfRklMTCxcbiAgREVGQVVMVF9URVhUQk9YX1NUUk9LRTogKCkgPT4gREVGQVVMVF9URVhUQk9YX1NUUk9LRSxcbiAgREVGQVVMVF9URVhUX0FOTk9UQVRJT05fQ09MT1I6ICgpID0+IERFRkFVTFRfVEVYVF9BTk5PVEFUSU9OX0NPTE9SLFxuICBERUZBVUxUX1RPT0xCQVJfUE9TSVRJT046ICgpID0+IERFRkFVTFRfVE9PTEJBUl9QT1NJVElPTixcbiAgRk9OVF9TSVpFOiAoKSA9PiBGT05UX1NJWkUsXG4gIEZPTlRfV0VJR0hUOiAoKSA9PiBGT05UX1dFSUdIVDIsXG4gIElTX0NPTU1VTklUWTogKCkgPT4gSVNfQ09NTVVOSVRZLFxuICBJU19EQVJLX1RIRU1FOiAoKSA9PiBJU19EQVJLX1RIRU1FLFxuICBJU19FTlRFUlBSSVNFOiAoKSA9PiBJU19FTlRFUlBSSVNFLFxuICBQQUxFVFRFX0FMVF9ET1dOX0ZJTEw6ICgpID0+IFBBTEVUVEVfQUxUX0RPV05fRklMTCxcbiAgUEFMRVRURV9BTFRfRE9XTl9TVFJPS0U6ICgpID0+IFBBTEVUVEVfQUxUX0RPV05fU1RST0tFLFxuICBQQUxFVFRFX0FMVF9ORVVUUkFMX0ZJTEw6ICgpID0+IFBBTEVUVEVfQUxUX05FVVRSQUxfRklMTCxcbiAgUEFMRVRURV9BTFRfTkVVVFJBTF9TVFJPS0U6ICgpID0+IFBBTEVUVEVfQUxUX05FVVRSQUxfU1RST0tFLFxuICBQQUxFVFRFX0FMVF9VUF9GSUxMOiAoKSA9PiBQQUxFVFRFX0FMVF9VUF9GSUxMLFxuICBQQUxFVFRFX0FMVF9VUF9TVFJPS0U6ICgpID0+IFBBTEVUVEVfQUxUX1VQX1NUUk9LRSxcbiAgUEFMRVRURV9ET1dOX0ZJTEw6ICgpID0+IFBBTEVUVEVfRE9XTl9GSUxMLFxuICBQQUxFVFRFX0RPV05fU1RST0tFOiAoKSA9PiBQQUxFVFRFX0RPV05fU1RST0tFLFxuICBQQUxFVFRFX05FVVRSQUxfRklMTDogKCkgPT4gUEFMRVRURV9ORVVUUkFMX0ZJTEwsXG4gIFBBTEVUVEVfTkVVVFJBTF9TVFJPS0U6ICgpID0+IFBBTEVUVEVfTkVVVFJBTF9TVFJPS0UsXG4gIFBBTEVUVEVfVVBfRklMTDogKCkgPT4gUEFMRVRURV9VUF9GSUxMLFxuICBQQUxFVFRFX1VQX1NUUk9LRTogKCkgPT4gUEFMRVRURV9VUF9TVFJPS0UsXG4gIFBPTEFSX0FYSVNfU0hBUEU6ICgpID0+IFBPTEFSX0FYSVNfU0hBUEUsXG4gIFBPTEFSX0FYSVNfVFlQRTogKCkgPT4gUE9MQVJfQVhJU19UWVBFLFxuICBnZXRDaGFydFRoZW1lOiAoKSA9PiBnZXRDaGFydFRoZW1lLFxuICBtYXJrZXJQYWxldHRlRmFjdG9yeTogKCkgPT4gbWFya2VyUGFsZXR0ZUZhY3RvcnksXG4gIHNpbmdsZVNlcmllc1BhbGV0dGVGYWN0b3J5OiAoKSA9PiBzaW5nbGVTZXJpZXNQYWxldHRlRmFjdG9yeSxcbiAgc3dhcEF4aXNDb25kaXRpb246ICgpID0+IHN3YXBBeGlzQ29uZGl0aW9uLFxuICB0aGVtZXM6ICgpID0+IHRoZW1lczJcbn0pO1xudmFyIHRoZW1lczIgPSBtYXBWYWx1ZXMoXG4gIHRoZW1lcyxcbiAgKHRoZW1lRmFjdG9yeSkgPT4gdGhlbWVGYWN0b3J5Py4oKVxuKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc3BhcmtsaW5lcy1zY2FsZS50c1xudmFyIHNwYXJrbGluZXNfc2NhbGVfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoc3BhcmtsaW5lc19zY2FsZV9leHBvcnRzLCB7XG4gIEJhbmRTY2FsZTogKCkgPT4gQmFuZFNjYWxlLFxuICBDb2xvclNjYWxlOiAoKSA9PiBDb2xvclNjYWxlLFxuICBDb250aW51b3VzU2NhbGU6ICgpID0+IENvbnRpbnVvdXNTY2FsZSxcbiAgSW52YWxpZGF0aW5nOiAoKSA9PiBJbnZhbGlkYXRpbmcsXG4gIExpbmVhclNjYWxlOiAoKSA9PiBMaW5lYXJTY2FsZSxcbiAgT3JkaW5hbFRpbWVTY2FsZTogKCkgPT4gT3JkaW5hbFRpbWVTY2FsZSxcbiAgVGltZVNjYWxlOiAoKSA9PiBUaW1lU2NhbGVcbn0pO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zcGFya2xpbmVzLXV0aWwudHNcbnZhciBzcGFya2xpbmVzX3V0aWxfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoc3BhcmtsaW5lc191dGlsX2V4cG9ydHMsIHtcbiAgQ29sb3I6ICgpID0+IENvbG9yLFxuICBEZWJ1ZzogKCkgPT4gRGVidWcsXG4gIExvZ2dlcjogKCkgPT4gTG9nZ2VyLFxuICBQYWRkaW5nOiAoKSA9PiBQYWRkaW5nLFxuICBUaW1lSW50ZXJ2YWw6ICgpID0+IFRpbWVJbnRlcnZhbCxcbiAgYW5nbGVCZXR3ZWVuOiAoKSA9PiBhbmdsZUJldHdlZW4sXG4gIGFuZ2xlRGlmZjogKCkgPT4gYW5nbGVEaWZmLFxuICBhcmNEaXN0YW5jZVNxdWFyZWQ6ICgpID0+IGFyY0Rpc3RhbmNlU3F1YXJlZCxcbiAgYXJlQXJyYXlOdW1iZXJzRXF1YWw6ICgpID0+IGFyZUFycmF5TnVtYmVyc0VxdWFsLFxuICBjaGVja0RhdHVtOiAoKSA9PiBjaGVja0RhdHVtLFxuICBjbGFtcDogKCkgPT4gY2xhbXAsXG4gIGNsYW1wQXJyYXk6ICgpID0+IGNsYW1wQXJyYXksXG4gIGNsb2Nrd2lzZUFuZ2xlOiAoKSA9PiBjbG9ja3dpc2VBbmdsZSxcbiAgY2xvY2t3aXNlQW5nbGVzOiAoKSA9PiBjbG9ja3dpc2VBbmdsZXMsXG4gIGNvdW50RnJhY3Rpb25EaWdpdHM6ICgpID0+IGNvdW50RnJhY3Rpb25EaWdpdHMsXG4gIGNyZWF0ZUlkOiAoKSA9PiBjcmVhdGVJZCxcbiAgZGF5OiAoKSA9PiBkYXksXG4gIGRlZXBDbG9uZTogKCkgPT4gZGVlcENsb25lLFxuICBkaXNwbGFjZVBvaW50RnJvbVZlY3RvcjogKCkgPT4gZGlzcGxhY2VQb2ludEZyb21WZWN0b3IsXG4gIGV4dGVudDogKCkgPT4gZXh0ZW50LFxuICBmaW5kTWluTWF4OiAoKSA9PiBmaW5kTWluTWF4LFxuICBmaW5kUmFuZ2VFeHRlbnQ6ICgpID0+IGZpbmRSYW5nZUV4dGVudCxcbiAgZm9ybWF0Tm9ybWFsaXplZFBlcmNlbnRhZ2U6ICgpID0+IGZvcm1hdE5vcm1hbGl6ZWRQZXJjZW50YWdlLFxuICBmb3JtYXRQZXJjZW50YWdlOiAoKSA9PiBmb3JtYXRQZXJjZW50YWdlLFxuICBmcmlkYXk6ICgpID0+IGZyaWRheSxcbiAgZ2VuZXJhdGVVVUlEOiAoKSA9PiBnZW5lcmF0ZVVVSUQsXG4gIGdldEF0dHJpYnV0ZTogKCkgPT4gZ2V0QXR0cmlidXRlLFxuICBob3VyOiAoKSA9PiBob3VyLFxuICBpbnRlcnBvbGF0ZUNvbG9yOiAoKSA9PiBpbnRlcnBvbGF0ZUNvbG9yLFxuICBpbnRlcnBvbGF0ZU51bWJlcjogKCkgPT4gaW50ZXJwb2xhdGVOdW1iZXIsXG4gIGlzQmV0d2VlbkFuZ2xlczogKCkgPT4gaXNCZXR3ZWVuQW5nbGVzLFxuICBpc0NvbnRpbnVvdXM6ICgpID0+IGlzQ29udGludW91cyxcbiAgaXNEYXRlOiAoKSA9PiBpc1ZhbGlkRGF0ZSxcbiAgaXNEZW5zZUludGVydmFsOiAoKSA9PiBpc0RlbnNlSW50ZXJ2YWwsXG4gIGlzRXF1YWw6ICgpID0+IGlzRXF1YWwsXG4gIGlzTmVnYXRpdmU6ICgpID0+IGlzTmVnYXRpdmUsXG4gIGlzTnVtYmVyOiAoKSA9PiBpc0Zpbml0ZU51bWJlcixcbiAgaXNOdW1iZXJFcXVhbDogKCkgPT4gaXNFcXVhbCxcbiAgaXNOdW1iZXJPYmplY3Q6ICgpID0+IGlzTnVtYmVyT2JqZWN0LFxuICBpc1N0cmluZzogKCkgPT4gaXNTdHJpbmcsXG4gIGlzU3RyaW5nT2JqZWN0OiAoKSA9PiBpc1N0cmluZ09iamVjdCxcbiAganNvbkFwcGx5OiAoKSA9PiBqc29uQXBwbHksXG4gIGpzb25EaWZmOiAoKSA9PiBqc29uRGlmZixcbiAganNvbldhbGs6ICgpID0+IGpzb25XYWxrLFxuICBsaW5lRGlzdGFuY2VTcXVhcmVkOiAoKSA9PiBsaW5lRGlzdGFuY2VTcXVhcmVkLFxuICBtaWxsaXNlY29uZDogKCkgPT4gbWlsbGlzZWNvbmQsXG4gIG1pbnV0ZTogKCkgPT4gbWludXRlLFxuICBtb2Q6ICgpID0+IG1vZCxcbiAgbW9uZGF5OiAoKSA9PiBtb25kYXksXG4gIG1vbnRoOiAoKSA9PiBtb250aCxcbiAgbm9ybWFsaXNlZEV4dGVudFdpdGhNZXRhZGF0YTogKCkgPT4gbm9ybWFsaXNlZEV4dGVudFdpdGhNZXRhZGF0YSxcbiAgbm9ybWFsaXplQW5nbGUxODA6ICgpID0+IG5vcm1hbGl6ZUFuZ2xlMTgwLFxuICBub3JtYWxpemVBbmdsZTM2MDogKCkgPT4gbm9ybWFsaXplQW5nbGUzNjAsXG4gIG5vcm1hbGl6ZUFuZ2xlMzYwSW5jbHVzaXZlOiAoKSA9PiBub3JtYWxpemVBbmdsZTM2MEluY2x1c2l2ZSxcbiAgcmFuZ2U6ICgpID0+IHJhbmdlLFxuICByZXNldElkczogKCkgPT4gcmVzZXRJZHMsXG4gIHJvdW5kOiAoKSA9PiByb3VuZCxcbiAgc2FuaXRpemVIdG1sOiAoKSA9PiBzYW5pdGl6ZUh0bWwsXG4gIHNhdHVyZGF5OiAoKSA9PiBzYXR1cmRheSxcbiAgc2Vjb25kOiAoKSA9PiBzZWNvbmQsXG4gIHNldEF0dHJpYnV0ZTogKCkgPT4gc2V0QXR0cmlidXRlLFxuICBzZXRBdHRyaWJ1dGVzOiAoKSA9PiBzZXRBdHRyaWJ1dGVzLFxuICBzZXRFbGVtZW50U3R5bGU6ICgpID0+IHNldEVsZW1lbnRTdHlsZSxcbiAgc2hhbGxvd0Nsb25lOiAoKSA9PiBzaGFsbG93Q2xvbmUsXG4gIHN1bmRheTogKCkgPT4gc3VuZGF5LFxuICB0aHVyc2RheTogKCkgPT4gdGh1cnNkYXksXG4gIHRpY2tGb3JtYXQ6ICgpID0+IHRpY2tGb3JtYXQsXG4gIHRpY2tTdGVwOiAoKSA9PiB0aWNrU3RlcCxcbiAgdGlja3M6ICgpID0+IGNyZWF0ZVRpY2tzLFxuICB0b0RlZ3JlZXM6ICgpID0+IHRvRGVncmVlcyxcbiAgdG9GaXhlZDogKCkgPT4gdG9GaXhlZCxcbiAgdG9SYWRpYW5zOiAoKSA9PiB0b1JhZGlhbnMsXG4gIHRyYW5zZm9ybUludGVncmF0ZWRDYXRlZ29yeVZhbHVlOiAoKSA9PiB0cmFuc2Zvcm1JbnRlZ3JhdGVkQ2F0ZWdvcnlWYWx1ZSxcbiAgdHVlc2RheTogKCkgPT4gdHVlc2RheSxcbiAgdXRjRGF5OiAoKSA9PiB1dGNEYXksXG4gIHV0Y0hvdXI6ICgpID0+IHV0Y0hvdXIsXG4gIHV0Y01pbnV0ZTogKCkgPT4gdXRjTWludXRlLFxuICB1dGNNb250aDogKCkgPT4gdXRjTW9udGgsXG4gIHV0Y1llYXI6ICgpID0+IHV0Y1llYXIsXG4gIHdlZG5lc2RheTogKCkgPT4gd2VkbmVzZGF5LFxuICB5ZWFyOiAoKSA9PiB5ZWFyXG59KTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvbW9kdWxlLXN1cHBvcnQudHNcbnZhciBtb2R1bGVfc3VwcG9ydF9leHBvcnRzID0ge307XG5fX2V4cG9ydChtb2R1bGVfc3VwcG9ydF9leHBvcnRzLCB7XG4gIEFORDogKCkgPT4gQU5ELFxuICBBUlJBWTogKCkgPT4gQVJSQVksXG4gIEFSUkFZX09GOiAoKSA9PiBBUlJBWV9PRixcbiAgQWJzdHJhY3RCYXJTZXJpZXM6ICgpID0+IEFic3RyYWN0QmFyU2VyaWVzLFxuICBBYnN0cmFjdEJhclNlcmllc1Byb3BlcnRpZXM6ICgpID0+IEFic3RyYWN0QmFyU2VyaWVzUHJvcGVydGllcyxcbiAgQWN0aW9uT25TZXQ6ICgpID0+IEFjdGlvbk9uU2V0LFxuICBBbmltYXRpb246ICgpID0+IEFuaW1hdGlvbixcbiAgQW5pbWF0aW9uTWFuYWdlcjogKCkgPT4gQW5pbWF0aW9uTWFuYWdlcixcbiAgQXhpczogKCkgPT4gQXhpcyxcbiAgQXhpc0ludGVydmFsOiAoKSA9PiBBeGlzSW50ZXJ2YWwsXG4gIEF4aXNMYWJlbDogKCkgPT4gQXhpc0xhYmVsLFxuICBBeGlzVGljazogKCkgPT4gQXhpc1RpY2ssXG4gIEF4aXNUaWNrczogKCkgPT4gQXhpc1RpY2tzLFxuICBCT09MRUFOOiAoKSA9PiBCT09MRUFOLFxuICBCT09MRUFOX0FSUkFZOiAoKSA9PiBCT09MRUFOX0FSUkFZLFxuICBCYWNrZ3JvdW5kOiAoKSA9PiBCYWNrZ3JvdW5kLFxuICBCYWNrZ3JvdW5kTW9kdWxlOiAoKSA9PiBCYWNrZ3JvdW5kTW9kdWxlLFxuICBCYXNlTW9kdWxlSW5zdGFuY2U6ICgpID0+IEJhc2VNb2R1bGVJbnN0YW5jZSxcbiAgQmFzZVByb3BlcnRpZXM6ICgpID0+IEJhc2VQcm9wZXJ0aWVzLFxuICBDT0xPUl9TVFJJTkc6ICgpID0+IENPTE9SX1NUUklORyxcbiAgQ09MT1JfU1RSSU5HX0FSUkFZOiAoKSA9PiBDT0xPUl9TVFJJTkdfQVJSQVksXG4gIENhY2hlZFRleHRNZWFzdXJlcjogKCkgPT4gQ2FjaGVkVGV4dE1lYXN1cmVyLFxuICBDYWNoZWRUZXh0TWVhc3VyZXJQb29sOiAoKSA9PiBDYWNoZWRUZXh0TWVhc3VyZXJQb29sLFxuICBDYXJ0ZXNpYW5BeGlzOiAoKSA9PiBDYXJ0ZXNpYW5BeGlzLFxuICBDYXJ0ZXNpYW5TZXJpZXM6ICgpID0+IENhcnRlc2lhblNlcmllcyxcbiAgQ2FydGVzaWFuU2VyaWVzTm9kZUV2ZW50OiAoKSA9PiBDYXJ0ZXNpYW5TZXJpZXNOb2RlRXZlbnQsXG4gIENhcnRlc2lhblNlcmllc1Byb3BlcnRpZXM6ICgpID0+IENhcnRlc2lhblNlcmllc1Byb3BlcnRpZXMsXG4gIENhdGVnb3J5QXhpczogKCkgPT4gQ2F0ZWdvcnlBeGlzLFxuICBDaGFydEF4aXNEaXJlY3Rpb246ICgpID0+IENoYXJ0QXhpc0RpcmVjdGlvbixcbiAgQ2hhcnRFdmVudE1hbmFnZXI6ICgpID0+IENoYXJ0RXZlbnRNYW5hZ2VyLFxuICBDaGFydE9wdGlvbnM6ICgpID0+IENoYXJ0T3B0aW9ucyxcbiAgQ2hhcnRVcGRhdGVUeXBlOiAoKSA9PiBDaGFydFVwZGF0ZVR5cGUsXG4gIENvbnRleHRNZW51UmVnaXN0cnk6ICgpID0+IENvbnRleHRNZW51UmVnaXN0cnksXG4gIEN1cnNvcjogKCkgPT4gQ3Vyc29yLFxuICBDdXJzb3JNYW5hZ2VyOiAoKSA9PiBDdXJzb3JNYW5hZ2VyLFxuICBEQVRFOiAoKSA9PiBEQVRFLFxuICBEQVRFX0FSUkFZOiAoKSA9PiBEQVRFX0FSUkFZLFxuICBEQVRFX09SX0RBVEVUSU1FX01TOiAoKSA9PiBEQVRFX09SX0RBVEVUSU1FX01TLFxuICBERUZBVUxUX0NBUlRFU0lBTl9ESVJFQ1RJT05fS0VZUzogKCkgPT4gREVGQVVMVF9DQVJURVNJQU5fRElSRUNUSU9OX0tFWVMsXG4gIERFRkFVTFRfQ0FSVEVTSUFOX0RJUkVDVElPTl9OQU1FUzogKCkgPT4gREVGQVVMVF9DQVJURVNJQU5fRElSRUNUSU9OX05BTUVTLFxuICBERUZBVUxUX1RPT0xUSVBfQ0xBU1M6ICgpID0+IERFRkFVTFRfVE9PTFRJUF9DTEFTUyxcbiAgREVGQVVMVF9UT09MVElQX0RBUktfQ0xBU1M6ICgpID0+IERFRkFVTFRfVE9PTFRJUF9EQVJLX0NMQVNTLFxuICBERUdSRUU6ICgpID0+IERFR1JFRSxcbiAgRElSRUNUSU9OOiAoKSA9PiBESVJFQ1RJT04sXG4gIERPTU1hbmFnZXI6ICgpID0+IERPTU1hbmFnZXIsXG4gIERSQUdfSU5URVJBQ1RJT05fVFlQRVM6ICgpID0+IERSQUdfSU5URVJBQ1RJT05fVFlQRVMsXG4gIERhdGFDb250cm9sbGVyOiAoKSA9PiBEYXRhQ29udHJvbGxlcixcbiAgRGF0YU1vZGVsOiAoKSA9PiBEYXRhTW9kZWwsXG4gIERhdGFNb2RlbFNlcmllczogKCkgPT4gRGF0YU1vZGVsU2VyaWVzLFxuICBEYXRhU2VydmljZTogKCkgPT4gRGF0YVNlcnZpY2UsXG4gIERlZmF1bHQ6ICgpID0+IERlZmF1bHQsXG4gIERlcHJlY2F0ZWQ6ICgpID0+IERlcHJlY2F0ZWQsXG4gIERlcHJlY2F0ZWRBbmRSZW5hbWVkVG86ICgpID0+IERlcHJlY2F0ZWRBbmRSZW5hbWVkVG8sXG4gIEVNUFRZX1RPT0xUSVBfQ09OVEVOVDogKCkgPT4gRU1QVFlfVE9PTFRJUF9DT05URU5ULFxuICBGT05UX1NUWUxFOiAoKSA9PiBGT05UX1NUWUxFLFxuICBGT05UX1dFSUdIVDogKCkgPT4gRk9OVF9XRUlHSFQsXG4gIEZVTkNUSU9OOiAoKSA9PiBGVU5DVElPTixcbiAgR1JFQVRFUl9USEFOOiAoKSA9PiBHUkVBVEVSX1RIQU4sXG4gIEdlc3R1cmVEZXRlY3RvcjogKCkgPT4gR2VzdHVyZURldGVjdG9yLFxuICBHcm91cGVkQ2F0ZWdvcnlBeGlzOiAoKSA9PiBHcm91cGVkQ2F0ZWdvcnlBeGlzLFxuICBIaWVyYXJjaHlOb2RlOiAoKSA9PiBIaWVyYXJjaHlOb2RlLFxuICBIaWVyYXJjaHlTZXJpZXM6ICgpID0+IEhpZXJhcmNoeVNlcmllcyxcbiAgSGllcmFyY2h5U2VyaWVzUHJvcGVydGllczogKCkgPT4gSGllcmFyY2h5U2VyaWVzUHJvcGVydGllcyxcbiAgSGlnaGxpZ2h0TWFuYWdlcjogKCkgPT4gSGlnaGxpZ2h0TWFuYWdlcixcbiAgSGlnaGxpZ2h0UHJvcGVydGllczogKCkgPT4gSGlnaGxpZ2h0UHJvcGVydGllcyxcbiAgSGlnaGxpZ2h0U3R5bGU6ICgpID0+IEhpZ2hsaWdodFN0eWxlLFxuICBJTlRFUkFDVElPTl9SQU5HRTogKCkgPT4gSU5URVJBQ1RJT05fUkFOR0UsXG4gIElOVEVSUE9MQVRJT05fU1RFUF9QT1NJVElPTjogKCkgPT4gSU5URVJQT0xBVElPTl9TVEVQX1BPU0lUSU9OLFxuICBJTlRFUlBPTEFUSU9OX1RZUEU6ICgpID0+IElOVEVSUE9MQVRJT05fVFlQRSxcbiAgSW50ZXJhY3Rpb25NYW5hZ2VyOiAoKSA9PiBJbnRlcmFjdGlvbk1hbmFnZXIsXG4gIEludGVyYWN0aW9uU3RhdGU6ICgpID0+IEludGVyYWN0aW9uU3RhdGUsXG4gIEludGVycG9sYXRpb25Qcm9wZXJ0aWVzOiAoKSA9PiBJbnRlcnBvbGF0aW9uUHJvcGVydGllcyxcbiAgS2V5TmF2TWFuYWdlcjogKCkgPT4gS2V5TmF2TWFuYWdlcixcbiAgTEFCRUxfUExBQ0VNRU5UOiAoKSA9PiBMQUJFTF9QTEFDRU1FTlQsXG4gIExBUkdFU1RfS0VZX0lOVEVSVkFMOiAoKSA9PiBMQVJHRVNUX0tFWV9JTlRFUlZBTCxcbiAgTEVTU19USEFOOiAoKSA9PiBMRVNTX1RIQU4sXG4gIExJTkVfQ0FQOiAoKSA9PiBMSU5FX0NBUCxcbiAgTElORV9EQVNIOiAoKSA9PiBMSU5FX0RBU0gsXG4gIExJTkVfSk9JTjogKCkgPT4gTElORV9KT0lOLFxuICBMSU5FX1NUWUxFOiAoKSA9PiBMSU5FX1NUWUxFLFxuICBMYXlvdXRFbGVtZW50OiAoKSA9PiBMYXlvdXRFbGVtZW50LFxuICBMYXlvdXRNYW5hZ2VyOiAoKSA9PiBMYXlvdXRNYW5hZ2VyLFxuICBMb25MYXRCQm94OiAoKSA9PiBMb25MYXRCQm94LFxuICBNQVJLRVJfU0hBUEU6ICgpID0+IE1BUktFUl9TSEFQRSxcbiAgTUFUQ0hJTkdfQ1JPU1NMSU5FX1RZUEU6ICgpID0+IE1BVENISU5HX0NST1NTTElORV9UWVBFLFxuICBNQVhfU1BBQ0lORzogKCkgPT4gTUFYX1NQQUNJTkcsXG4gIE1JTl9TUEFDSU5HOiAoKSA9PiBNSU5fU1BBQ0lORyxcbiAgTWVyY2F0b3JTY2FsZTogKCkgPT4gTWVyY2F0b3JTY2FsZSxcbiAgTW9kdWxlUmVnaXN0cnk6ICgpID0+IE1vZHVsZVJlZ2lzdHJ5LFxuICBNb3Rpb246ICgpID0+IGVhc2luZ19leHBvcnRzLFxuICBOQU46ICgpID0+IE5BTixcbiAgTk9ERV9VUERBVEVfU1RBVEVfVE9fUEhBU0VfTUFQUElORzogKCkgPT4gTk9ERV9VUERBVEVfU1RBVEVfVE9fUEhBU0VfTUFQUElORyxcbiAgTlVNQkVSOiAoKSA9PiBOVU1CRVIsXG4gIE5VTUJFUl9BUlJBWTogKCkgPT4gTlVNQkVSX0FSUkFZLFxuICBOVU1CRVJfT1JfTkFOOiAoKSA9PiBOVU1CRVJfT1JfTkFOLFxuICBOYXZpZ2F0b3I6ICgpID0+IE5hdmlnYXRvcixcbiAgTmF2aWdhdG9yTW9kdWxlOiAoKSA9PiBOYXZpZ2F0b3JNb2R1bGUsXG4gIE5vZGVSZWdpb25CQm94UHJvdmlkZXI6ICgpID0+IE5vZGVSZWdpb25CQm94UHJvdmlkZXIsXG4gIE9CSkVDVDogKCkgPT4gT0JKRUNULFxuICBPQkpFQ1RfQVJSQVk6ICgpID0+IE9CSkVDVF9BUlJBWSxcbiAgT1I6ICgpID0+IE9SLFxuICBPVkVSRkxPV19TVFJBVEVHWTogKCkgPT4gT1ZFUkZMT1dfU1RSQVRFR1ksXG4gIE9ic2VydmVDaGFuZ2VzOiAoKSA9PiBPYnNlcnZlQ2hhbmdlcyxcbiAgUEhBU0VfTUVUQURBVEE6ICgpID0+IFBIQVNFX01FVEFEQVRBLFxuICBQSEFTRV9PUkRFUjogKCkgPT4gUEhBU0VfT1JERVIsXG4gIFBMQUNFTUVOVDogKCkgPT4gUExBQ0VNRU5ULFxuICBQTEFJTl9PQkpFQ1Q6ICgpID0+IFBMQUlOX09CSkVDVCxcbiAgUE9JTlRFUl9JTlRFUkFDVElPTl9UWVBFUzogKCkgPT4gUE9JTlRFUl9JTlRFUkFDVElPTl9UWVBFUyxcbiAgUE9TSVRJT046ICgpID0+IFBPU0lUSU9OLFxuICBQT1NJVElPTl9UT1BfQ09PUkRJTkFURVM6ICgpID0+IFBPU0lUSU9OX1RPUF9DT09SRElOQVRFUyxcbiAgUE9TSVRJVkVfTlVNQkVSOiAoKSA9PiBQT1NJVElWRV9OVU1CRVIsXG4gIFBvbGFyQXhpczogKCkgPT4gUG9sYXJBeGlzLFxuICBQb2xhclNlcmllczogKCkgPT4gUG9sYXJTZXJpZXMsXG4gIFByb3BlcnRpZXNBcnJheTogKCkgPT4gUHJvcGVydGllc0FycmF5LFxuICBQcm94eU9uV3JpdGU6ICgpID0+IFByb3h5T25Xcml0ZSxcbiAgUHJveHlQcm9wZXJ0eTogKCkgPT4gUHJveHlQcm9wZXJ0eSxcbiAgUHJveHlQcm9wZXJ0eU9uV3JpdGU6ICgpID0+IFByb3h5UHJvcGVydHlPbldyaXRlLFxuICBRVUlDS19UUkFOU0lUSU9OOiAoKSA9PiBRVUlDS19UUkFOU0lUSU9OLFxuICBSQVRJTzogKCkgPT4gUkFUSU8sXG4gIFJFQUxfTlVNQkVSOiAoKSA9PiBSRUFMX05VTUJFUixcbiAgUkVHSU9OUzogKCkgPT4gUkVHSU9OUyxcbiAgUmVnaW9uTWFuYWdlcjogKCkgPT4gUmVnaW9uTWFuYWdlcixcbiAgUmVwZWF0VHlwZTogKCkgPT4gUmVwZWF0VHlwZSxcbiAgU0tJUF9KU19CVUlMVElOUzogKCkgPT4gU0tJUF9KU19CVUlMVElOUyxcbiAgU01BTExFU1RfS0VZX0lOVEVSVkFMOiAoKSA9PiBTTUFMTEVTVF9LRVlfSU5URVJWQUwsXG4gIFNPUlRfRE9NQUlOX0dST1VQUzogKCkgPT4gU09SVF9ET01BSU5fR1JPVVBTLFxuICBTVFJJTkc6ICgpID0+IFNUUklORyxcbiAgU1RSSU5HX0FSUkFZOiAoKSA9PiBTVFJJTkdfQVJSQVksXG4gIFNlcmllczogKCkgPT4gU2VyaWVzLFxuICBTZXJpZXNHcm91cGluZ0NoYW5nZWRFdmVudDogKCkgPT4gU2VyaWVzR3JvdXBpbmdDaGFuZ2VkRXZlbnQsXG4gIFNlcmllc0l0ZW1IaWdobGlnaHRTdHlsZTogKCkgPT4gU2VyaWVzSXRlbUhpZ2hsaWdodFN0eWxlLFxuICBTZXJpZXNNYXJrZXI6ICgpID0+IFNlcmllc01hcmtlcixcbiAgU2VyaWVzTm9kZUV2ZW50OiAoKSA9PiBTZXJpZXNOb2RlRXZlbnQsXG4gIFNlcmllc05vZGVQaWNrTW9kZTogKCkgPT4gU2VyaWVzTm9kZVBpY2tNb2RlLFxuICBTZXJpZXNQcm9wZXJ0aWVzOiAoKSA9PiBTZXJpZXNQcm9wZXJ0aWVzLFxuICBTZXJpZXNUb29sdGlwOiAoKSA9PiBTZXJpZXNUb29sdGlwLFxuICBTaW1wbGVSZWdpb25CQm94UHJvdmlkZXI6ICgpID0+IFNpbXBsZVJlZ2lvbkJCb3hQcm92aWRlcixcbiAgU2ltcGxlVGV4dE1lYXN1cmVyOiAoKSA9PiBTaW1wbGVUZXh0TWVhc3VyZXIsXG4gIFN0YXRlTWFjaGluZTogKCkgPT4gU3RhdGVNYWNoaW5lLFxuICBURVhUX0FMSUdOOiAoKSA9PiBURVhUX0FMSUdOLFxuICBURVhUX1dSQVA6ICgpID0+IFRFWFRfV1JBUCxcbiAgVElDS19JTlRFUlZBTDogKCkgPT4gVElDS19JTlRFUlZBTCxcbiAgVE9PTEJBUl9BTElHTk1FTlRTOiAoKSA9PiBUT09MQkFSX0FMSUdOTUVOVFMsXG4gIFRPT0xCQVJfR1JPVVBTOiAoKSA9PiBUT09MQkFSX0dST1VQUyxcbiAgVE9PTEJBUl9HUk9VUF9PUkRFUklORzogKCkgPT4gVE9PTEJBUl9HUk9VUF9PUkRFUklORyxcbiAgVE9PTEJBUl9QT1NJVElPTlM6ICgpID0+IFRPT0xCQVJfUE9TSVRJT05TLFxuICBUZXh0VXRpbHM6ICgpID0+IFRleHRVdGlscyxcbiAgVGV4dFdyYXBwZXI6ICgpID0+IFRleHRXcmFwcGVyLFxuICBUb29sYmFyTWFuYWdlcjogKCkgPT4gVG9vbGJhck1hbmFnZXIsXG4gIFRvb2xiYXJQb3NpdGlvbjogKCkgPT4gVG9vbGJhclBvc2l0aW9uLFxuICBUb29sdGlwOiAoKSA9PiBUb29sdGlwLFxuICBUb29sdGlwTWFuYWdlcjogKCkgPT4gVG9vbHRpcE1hbmFnZXIsXG4gIFRvb2x0aXBQb3NpdGlvbjogKCkgPT4gVG9vbHRpcFBvc2l0aW9uLFxuICBVTklPTjogKCkgPT4gVU5JT04sXG4gIFVwZGF0ZVNlcnZpY2U6ICgpID0+IFVwZGF0ZVNlcnZpY2UsXG4gIFZFUlRJQ0FMX0FMSUdOOiAoKSA9PiBWRVJUSUNBTF9BTElHTixcbiAgVmFsaWRhdGU6ICgpID0+IFZhbGlkYXRlLFxuICBWZWMyOiAoKSA9PiBWZWMyLFxuICBWZWM0OiAoKSA9PiBWZWM0LFxuICBaSW5kZXhNYXA6ICgpID0+IFpJbmRleE1hcCxcbiAgWm9vbU1hbmFnZXI6ICgpID0+IFpvb21NYW5hZ2VyLFxuICBfX0ZPUkNFX01PRFVMRV9ERVRFQ1RJT046ICgpID0+IF9fRk9SQ0VfTU9EVUxFX0RFVEVDVElPTixcbiAgYWNjdW11bGF0ZUdyb3VwOiAoKSA9PiBhY2N1bXVsYXRlR3JvdXAsXG4gIGFjY3VtdWxhdGVTdGFjazogKCkgPT4gYWNjdW11bGF0ZVN0YWNrLFxuICBhY2N1bXVsYXRlZFZhbHVlOiAoKSA9PiBhY2N1bXVsYXRlZFZhbHVlLFxuICBhY2N1bXVsYXRpdmVWYWx1ZVByb3BlcnR5OiAoKSA9PiBhY2N1bXVsYXRpdmVWYWx1ZVByb3BlcnR5LFxuICBhZGRIaXRUZXN0ZXJzVG9RdWFkdHJlZTogKCkgPT4gYWRkSGl0VGVzdGVyc1RvUXVhZHRyZWUsXG4gIGFkanVzdExhYmVsUGxhY2VtZW50OiAoKSA9PiBhZGp1c3RMYWJlbFBsYWNlbWVudCxcbiAgYW5pbWF0aW9uVmFsaWRhdGlvbjogKCkgPT4gYW5pbWF0aW9uVmFsaWRhdGlvbixcbiAgYXJlYTogKCkgPT4gYXJlYSxcbiAgYXJyYXlzRXF1YWw6ICgpID0+IGFycmF5c0VxdWFsLFxuICBiYWNrZmlsbFBhdGhQb2ludERhdGE6ICgpID0+IGJhY2tmaWxsUGF0aFBvaW50RGF0YSxcbiAgYnVpbGRGb3JtYXR0ZXI6ICgpID0+IGJ1aWxkRm9ybWF0dGVyLFxuICBidWlsZFJlc2V0UGF0aEZuOiAoKSA9PiBidWlsZFJlc2V0UGF0aEZuLFxuICBjYWxjdWxhdGVEZWZhdWx0VGltZVRpY2tGb3JtYXQ6ICgpID0+IGNhbGN1bGF0ZURlZmF1bHRUaW1lVGlja0Zvcm1hdCxcbiAgY2FsY3VsYXRlTGFiZWxDaGFydFBhZGRpbmc6ICgpID0+IGNhbGN1bGF0ZUxhYmVsQ2hhcnRQYWRkaW5nLFxuICBjYWxjdWxhdGVMYWJlbFRyYW5zbGF0aW9uOiAoKSA9PiBjYWxjdWxhdGVMYWJlbFRyYW5zbGF0aW9uLFxuICBjYWxjdWxhdGVQbGFjZW1lbnQ6ICgpID0+IGNhbGN1bGF0ZVBsYWNlbWVudCxcbiAgY2hlY2tDcmlzcDogKCkgPT4gY2hlY2tDcmlzcCxcbiAgY2lyY3VsYXJTbGljZUFycmF5OiAoKSA9PiBjaXJjdWxhclNsaWNlQXJyYXksXG4gIGNsYW1wOiAoKSA9PiBjbGFtcCxcbiAgY2xhbXBBcnJheTogKCkgPT4gY2xhbXBBcnJheSxcbiAgY29sbGFwc2VkU3RhcnRpbmdCYXJQb3NpdGlvbjogKCkgPT4gY29sbGFwc2VkU3RhcnRpbmdCYXJQb3NpdGlvbixcbiAgY29tcHV0ZUJhckZvY3VzQm91bmRzOiAoKSA9PiBjb21wdXRlQmFyRm9jdXNCb3VuZHMsXG4gIGNvbXB1dGVNYXJrZXJGb2N1c0JvdW5kczogKCkgPT4gY29tcHV0ZU1hcmtlckZvY3VzQm91bmRzLFxuICBjb252ZXJ0VmFsdWVzVG9TY2FsZUJ5RGVmczogKCkgPT4gY29udmVydFZhbHVlc1RvU2NhbGVCeURlZnMsXG4gIGNvdW50RnJhY3Rpb25EaWdpdHM6ICgpID0+IGNvdW50RnJhY3Rpb25EaWdpdHMsXG4gIGNyZWF0ZUJ1dHRvbjogKCkgPT4gY3JlYXRlQnV0dG9uLFxuICBjcmVhdGVDaGVja2JveDogKCkgPT4gY3JlYXRlQ2hlY2tib3gsXG4gIGNyZWF0ZURhdHVtSWQ6ICgpID0+IGNyZWF0ZURhdHVtSWQsXG4gIGNyZWF0ZURlcHJlY2F0aW9uV2FybmluZzogKCkgPT4gY3JlYXRlRGVwcmVjYXRpb25XYXJuaW5nLFxuICBjcmVhdGVFbGVtZW50OiAoKSA9PiBjcmVhdGVFbGVtZW50LFxuICBjcmVhdGVFbGVtZW50SWQ6ICgpID0+IGNyZWF0ZUVsZW1lbnRJZCxcbiAgY3JlYXRlRWxlbWVudE5TOiAoKSA9PiBjcmVhdGVFbGVtZW50TlMsXG4gIGNyZWF0ZUljb246ICgpID0+IGNyZWF0ZUljb24sXG4gIGNyZWF0ZVNlbGVjdDogKCkgPT4gY3JlYXRlU2VsZWN0LFxuICBjcmVhdGVUZXh0QXJlYTogKCkgPT4gY3JlYXRlVGV4dEFyZWEsXG4gIGRhdGVUb051bWJlcjogKCkgPT4gZGF0ZVRvTnVtYmVyLFxuICBkZWNvbnN0cnVjdFNlbGVjdGlvbnNPck5vZGVzOiAoKSA9PiBkZWNvbnN0cnVjdFNlbGVjdGlvbnNPck5vZGVzLFxuICBkZWVwQ2xvbmU6ICgpID0+IGRlZXBDbG9uZSxcbiAgZGVlcE1lcmdlOiAoKSA9PiBkZWVwTWVyZ2UsXG4gIGRlZmF1bHRUaW1lVGlja0Zvcm1hdDogKCkgPT4gZGVmYXVsdFRpbWVUaWNrRm9ybWF0LFxuICBkZXRlcm1pbmVQYXRoU3RhdHVzOiAoKSA9PiBkZXRlcm1pbmVQYXRoU3RhdHVzLFxuICBkaWZmOiAoKSA9PiBkaWZmLFxuICBkb3dubG9hZFVybDogKCkgPT4gZG93bmxvYWRVcmwsXG4gIGVudGVycHJpc2VNb2R1bGU6ICgpID0+IGVudGVycHJpc2VNb2R1bGUsXG4gIGV4Y2x1ZGVzVHlwZTogKCkgPT4gZXhjbHVkZXNUeXBlLFxuICBleHRlbnQ6ICgpID0+IGV4dGVudCxcbiAgZXh0cmFjdERlY29yYXRlZFByb3BlcnRpZXM6ICgpID0+IGV4dHJhY3REZWNvcmF0ZWRQcm9wZXJ0aWVzLFxuICBmaW5kTWF4VmFsdWU6ICgpID0+IGZpbmRNYXhWYWx1ZSxcbiAgZmluZE1pbk1heDogKCkgPT4gZmluZE1pbk1heCxcbiAgZmluZFF1YWR0cmVlTWF0Y2g6ICgpID0+IGZpbmRRdWFkdHJlZU1hdGNoLFxuICBmaW5kUmFuZ2VFeHRlbnQ6ICgpID0+IGZpbmRSYW5nZUV4dGVudCxcbiAgZml4TnVtZXJpY0V4dGVudDogKCkgPT4gZml4TnVtZXJpY0V4dGVudCxcbiAgZm9jdXNDdXJzb3JBdEVuZDogKCkgPT4gZm9jdXNDdXJzb3JBdEVuZCxcbiAgZm9ybWF0Tm9ybWFsaXplZFBlcmNlbnRhZ2U6ICgpID0+IGZvcm1hdE5vcm1hbGl6ZWRQZXJjZW50YWdlLFxuICBmb3JtYXRQZXJjZW50YWdlOiAoKSA9PiBmb3JtYXRQZXJjZW50YWdlLFxuICBmb3JtYXRWYWx1ZTogKCkgPT4gZm9ybWF0VmFsdWUsXG4gIGZyb21Ub01vdGlvbjogKCkgPT4gZnJvbVRvTW90aW9uLFxuICBnZXREb2N1bWVudDogKCkgPT4gZ2V0RG9jdW1lbnQsXG4gIGdldExhc3RGb2N1czogKCkgPT4gZ2V0TGFzdEZvY3VzLFxuICBnZXRNaXNzQ291bnQ6ICgpID0+IGdldE1pc3NDb3VudCxcbiAgZ2V0UGF0aDogKCkgPT4gZ2V0UGF0aCxcbiAgZ2V0UGF0aENvbXBvbmVudHM6ICgpID0+IGdldFBhdGhDb21wb25lbnRzLFxuICBnZXRSZWN0Q29uZmlnOiAoKSA9PiBnZXRSZWN0Q29uZmlnLFxuICBnZXRXaW5kb3c6ICgpID0+IGdldFdpbmRvdyxcbiAgZ3JvdXBBY2N1bXVsYXRpdmVWYWx1ZVByb3BlcnR5OiAoKSA9PiBncm91cEFjY3VtdWxhdGl2ZVZhbHVlUHJvcGVydHksXG4gIGdyb3VwQXZlcmFnZTogKCkgPT4gZ3JvdXBBdmVyYWdlLFxuICBncm91cEJ5OiAoKSA9PiBncm91cEJ5LFxuICBncm91cENvdW50OiAoKSA9PiBncm91cENvdW50LFxuICBncm91cFN0YWNrVmFsdWVQcm9wZXJ0eTogKCkgPT4gZ3JvdXBTdGFja1ZhbHVlUHJvcGVydHksXG4gIGdyb3VwU3VtOiAoKSA9PiBncm91cFN1bSxcbiAgaW5pdE1lbnVLZXlOYXY6ICgpID0+IGluaXRNZW51S2V5TmF2LFxuICBpbml0Um92aW5nVGFiSW5kZXg6ICgpID0+IGluaXRSb3ZpbmdUYWJJbmRleCxcbiAgaW5pdFRvb2xiYXJLZXlOYXY6ICgpID0+IGluaXRUb29sYmFyS2V5TmF2LFxuICBpc0FuaW1hdGluZ0Zsb2F0aW5nUG9zaXRpb246ICgpID0+IGlzQW5pbWF0aW5nRmxvYXRpbmdQb3NpdGlvbixcbiAgaXNBcnJheTogKCkgPT4gaXNBcnJheSxcbiAgaXNCb29sZWFuOiAoKSA9PiBpc0Jvb2xlYW4sXG4gIGlzQnV0dG9uQ2xpY2tFdmVudDogKCkgPT4gaXNCdXR0b25DbGlja0V2ZW50LFxuICBpc0RhdGU6ICgpID0+IGlzRGF0ZSxcbiAgaXNEZWNvcmF0ZWRPYmplY3Q6ICgpID0+IGlzRGVjb3JhdGVkT2JqZWN0LFxuICBpc0RlZmluZWQ6ICgpID0+IGlzRGVmaW5lZCxcbiAgaXNFbnVtS2V5OiAoKSA9PiBpc0VudW1LZXksXG4gIGlzRW51bVZhbHVlOiAoKSA9PiBpc0VudW1WYWx1ZSxcbiAgaXNFcXVhbDogKCkgPT4gaXNFcXVhbCxcbiAgaXNGaW5pdGVOdW1iZXI6ICgpID0+IGlzRmluaXRlTnVtYmVyLFxuICBpc0Z1bmN0aW9uOiAoKSA9PiBpc0Z1bmN0aW9uLFxuICBpc0h0bWxFbGVtZW50OiAoKSA9PiBpc0h0bWxFbGVtZW50LFxuICBpc05lZ2F0aXZlOiAoKSA9PiBpc05lZ2F0aXZlLFxuICBpc051bWJlcjogKCkgPT4gaXNOdW1iZXIsXG4gIGlzT2JqZWN0OiAoKSA9PiBpc09iamVjdCxcbiAgaXNPYmplY3RMaWtlOiAoKSA9PiBpc09iamVjdExpa2UsXG4gIGlzUGxhaW5PYmplY3Q6ICgpID0+IGlzUGxhaW5PYmplY3QsXG4gIGlzUHJvcGVydGllczogKCkgPT4gaXNQcm9wZXJ0aWVzLFxuICBpc1JlZ0V4cDogKCkgPT4gaXNSZWdFeHAsXG4gIGlzU3RyaW5nOiAoKSA9PiBpc1N0cmluZyxcbiAgaXNTeW1ib2w6ICgpID0+IGlzU3ltYm9sLFxuICBpc1ZhbGlkRGF0ZTogKCkgPT4gaXNWYWxpZERhdGUsXG4gIGpzb25BcHBseTogKCkgPT4ganNvbkFwcGx5LFxuICBqc29uRGlmZjogKCkgPT4ganNvbkRpZmYsXG4gIGpzb25XYWxrOiAoKSA9PiBqc29uV2FsayxcbiAga2V5UHJvcGVydHk6ICgpID0+IGtleVByb3BlcnR5LFxuICBsYWJlbERpcmVjdGlvbkhhbmRsaW5nOiAoKSA9PiBsYWJlbERpcmVjdGlvbkhhbmRsaW5nLFxuICBsaXN0RGVjb3JhdGVkUHJvcGVydGllczogKCkgPT4gbGlzdERlY29yYXRlZFByb3BlcnRpZXMsXG4gIG1ha2VBY2Nlc3NpYmxlQ2xpY2tMaXN0ZW5lcjogKCkgPT4gbWFrZUFjY2Vzc2libGVDbGlja0xpc3RlbmVyLFxuICBtYXBWYWx1ZXM6ICgpID0+IG1hcFZhbHVlcyxcbiAgbWFya2VyRmFkZUluQW5pbWF0aW9uOiAoKSA9PiBtYXJrZXJGYWRlSW5BbmltYXRpb24sXG4gIG1hcmtlclBhbGV0dGVGYWN0b3J5OiAoKSA9PiBtYXJrZXJQYWxldHRlRmFjdG9yeSxcbiAgbWFya2VyU2NhbGVJbkFuaW1hdGlvbjogKCkgPT4gbWFya2VyU2NhbGVJbkFuaW1hdGlvbixcbiAgbWFya2VyU3dpcGVTY2FsZUluQW5pbWF0aW9uOiAoKSA9PiBtYXJrZXJTd2lwZVNjYWxlSW5BbmltYXRpb24sXG4gIG1lcmdlQXJyYXlEZWZhdWx0czogKCkgPT4gbWVyZ2VBcnJheURlZmF1bHRzLFxuICBtZXJnZURlZmF1bHRzOiAoKSA9PiBtZXJnZURlZmF1bHRzLFxuICBtaWRwb2ludFN0YXJ0aW5nQmFyUG9zaXRpb246ICgpID0+IG1pZHBvaW50U3RhcnRpbmdCYXJQb3NpdGlvbixcbiAgbWluTWF4OiAoKSA9PiBtaW5NYXgsXG4gIG1vZDogKCkgPT4gbW9kLFxuICBtb2R1bGVSZWdpc3RyeTogKCkgPT4gbW9kdWxlUmVnaXN0cnksXG4gIG5lYXJlc3RTcXVhcmVkOiAoKSA9PiBuZWFyZXN0U3F1YXJlZCxcbiAgbmVhcmVzdFNxdWFyZWRJbkNvbnRhaW5lcjogKCkgPT4gbmVhcmVzdFNxdWFyZWRJbkNvbnRhaW5lcixcbiAgbm9ybWFsaXNlR3JvdXBUbzogKCkgPT4gbm9ybWFsaXNlR3JvdXBUbyxcbiAgbm9ybWFsaXNlUHJvcGVydHlUbzogKCkgPT4gbm9ybWFsaXNlUHJvcGVydHlUbyxcbiAgbm9ybWFsaXNlZEV4dGVudFdpdGhNZXRhZGF0YTogKCkgPT4gbm9ybWFsaXNlZEV4dGVudFdpdGhNZXRhZGF0YSxcbiAgb2JqZWN0RXF1YWxXaXRoOiAoKSA9PiBvYmplY3RFcXVhbFdpdGgsXG4gIHBhaXJDYXRlZ29yeURhdGE6ICgpID0+IHBhaXJDYXRlZ29yeURhdGEsXG4gIHBhaXJDb250aW51b3VzRGF0YTogKCkgPT4gcGFpckNvbnRpbnVvdXNEYXRhLFxuICBwYXJ0aWFsQXNzaWduOiAoKSA9PiBwYXJ0aWFsQXNzaWduLFxuICBwYXRoRmFkZUluQW5pbWF0aW9uOiAoKSA9PiBwYXRoRmFkZUluQW5pbWF0aW9uLFxuICBwYXRoRmFkZU91dEFuaW1hdGlvbjogKCkgPT4gcGF0aEZhZGVPdXRBbmltYXRpb24sXG4gIHBhdGhSYW5nZVBvaW50czogKCkgPT4gcGF0aFJhbmdlUG9pbnRzLFxuICBwYXRoUmFuZ2VQb2ludHNSZXZlcnNlOiAoKSA9PiBwYXRoUmFuZ2VQb2ludHNSZXZlcnNlLFxuICBwYXRoUmFuZ2VzOiAoKSA9PiBwYXRoUmFuZ2VzLFxuICBwYXRoU3dpcGVJbkFuaW1hdGlvbjogKCkgPT4gcGF0aFN3aXBlSW5BbmltYXRpb24sXG4gIHBpY2tCeU1hdGNoaW5nQW5nbGU6ICgpID0+IHBpY2tCeU1hdGNoaW5nQW5nbGUsXG4gIHBpY2tOb2RlOiAoKSA9PiBwaWNrTm9kZSxcbiAgcGxvdFBhdGg6ICgpID0+IHBsb3RQYXRoLFxuICBwcmVkaWNhdGVXaXRoTWVzc2FnZTogKCkgPT4gcHJlZGljYXRlV2l0aE1lc3NhZ2UsXG4gIHByZXBhcmVBcmVhUGF0aEFuaW1hdGlvbjogKCkgPT4gcHJlcGFyZUFyZWFQYXRoQW5pbWF0aW9uLFxuICBwcmVwYXJlQXhpc0FuaW1hdGlvbkNvbnRleHQ6ICgpID0+IHByZXBhcmVBeGlzQW5pbWF0aW9uQ29udGV4dCxcbiAgcHJlcGFyZUF4aXNBbmltYXRpb25GdW5jdGlvbnM6ICgpID0+IHByZXBhcmVBeGlzQW5pbWF0aW9uRnVuY3Rpb25zLFxuICBwcmVwYXJlQmFyQW5pbWF0aW9uRnVuY3Rpb25zOiAoKSA9PiBwcmVwYXJlQmFyQW5pbWF0aW9uRnVuY3Rpb25zLFxuICBwcmVwYXJlTGluZVBhdGhBbmltYXRpb246ICgpID0+IHByZXBhcmVMaW5lUGF0aEFuaW1hdGlvbixcbiAgcHJlcGFyZUxpbmVQYXRoQW5pbWF0aW9uRm5zOiAoKSA9PiBwcmVwYXJlTGluZVBhdGhBbmltYXRpb25GbnMsXG4gIHByZXBhcmVMaW5lUGF0aFByb3BlcnR5QW5pbWF0aW9uOiAoKSA9PiBwcmVwYXJlTGluZVBhdGhQcm9wZXJ0eUFuaW1hdGlvbixcbiAgcHJlcGFyZU1hcmtlckFuaW1hdGlvbjogKCkgPT4gcHJlcGFyZU1hcmtlckFuaW1hdGlvbixcbiAgcHJlcGFyZVBpZVNlcmllc0FuaW1hdGlvbkZ1bmN0aW9uczogKCkgPT4gcHJlcGFyZVBpZVNlcmllc0FuaW1hdGlvbkZ1bmN0aW9ucyxcbiAgcmFuZ2U6ICgpID0+IHJhbmdlMixcbiAgcmFuZ2VkVmFsdWVQcm9wZXJ0eTogKCkgPT4gcmFuZ2VkVmFsdWVQcm9wZXJ0eSxcbiAgcmVuZGVyUGFydGlhbFBhdGg6ICgpID0+IHJlbmRlclBhcnRpYWxQYXRoLFxuICByZXNldEF4aXNHcm91cEZuOiAoKSA9PiByZXNldEF4aXNHcm91cEZuLFxuICByZXNldEF4aXNMYWJlbFNlbGVjdGlvbkZuOiAoKSA9PiByZXNldEF4aXNMYWJlbFNlbGVjdGlvbkZuLFxuICByZXNldEF4aXNMaW5lU2VsZWN0aW9uRm46ICgpID0+IHJlc2V0QXhpc0xpbmVTZWxlY3Rpb25GbixcbiAgcmVzZXRBeGlzU2VsZWN0aW9uRm46ICgpID0+IHJlc2V0QXhpc1NlbGVjdGlvbkZuLFxuICByZXNldEJhclNlbGVjdGlvbnNGbjogKCkgPT4gcmVzZXRCYXJTZWxlY3Rpb25zRm4sXG4gIHJlc2V0SWRzOiAoKSA9PiByZXNldElkcyxcbiAgcmVzZXRMYWJlbEZuOiAoKSA9PiByZXNldExhYmVsRm4sXG4gIHJlc2V0TWFya2VyRm46ICgpID0+IHJlc2V0TWFya2VyRm4sXG4gIHJlc2V0TWFya2VyUG9zaXRpb25GbjogKCkgPT4gcmVzZXRNYXJrZXJQb3NpdGlvbkZuLFxuICByZXNldE1vdGlvbjogKCkgPT4gcmVzZXRNb3Rpb24sXG4gIHJlc2V0UGllU2VsZWN0aW9uc0ZuOiAoKSA9PiByZXNldFBpZVNlbGVjdGlvbnNGbixcbiAgcm91bmQ6ICgpID0+IHJvdW5kLFxuICBzY2FsZTogKCkgPT4gc2NhbGUsXG4gIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uOiAoKSA9PiBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbixcbiAgc2VyaWVzTGFiZWxGYWRlT3V0QW5pbWF0aW9uOiAoKSA9PiBzZXJpZXNMYWJlbEZhZGVPdXRBbmltYXRpb24sXG4gIHNldERvY3VtZW50OiAoKSA9PiBzZXREb2N1bWVudCxcbiAgc2V0RWxlbWVudEJCb3g6ICgpID0+IHNldEVsZW1lbnRCQm94LFxuICBzZXRQYXRoOiAoKSA9PiBzZXRQYXRoLFxuICBzZXRXaW5kb3c6ICgpID0+IHNldFdpbmRvdyxcbiAgc2hhbGxvd0Nsb25lOiAoKSA9PiBzaGFsbG93Q2xvbmUsXG4gIHNpbmdsZVNlcmllc1BhbGV0dGVGYWN0b3J5OiAoKSA9PiBzaW5nbGVTZXJpZXNQYWxldHRlRmFjdG9yeSxcbiAgc29ydEJhc2VkT25BcnJheTogKCkgPT4gc29ydEJhc2VkT25BcnJheSxcbiAgc3BsaXRQYWlyRGF0YTogKCkgPT4gc3BsaXRQYWlyRGF0YSxcbiAgc3RhdGljRnJvbVRvTW90aW9uOiAoKSA9PiBzdGF0aWNGcm9tVG9Nb3Rpb24sXG4gIHN0b3BQYWdlU2Nyb2xsaW5nOiAoKSA9PiBzdG9wUGFnZVNjcm9sbGluZyxcbiAgc3RyaW5naWZ5OiAoKSA9PiBzdHJpbmdpZnksXG4gIHN1bTogKCkgPT4gc3VtLFxuICBzdW1WYWx1ZXM6ICgpID0+IHN1bVZhbHVlcyxcbiAgdG9BcnJheTogKCkgPT4gdG9BcnJheSxcbiAgdG9GaXhlZDogKCkgPT4gdG9GaXhlZCxcbiAgdG9Ub29sdGlwSHRtbDogKCkgPT4gdG9Ub29sdGlwSHRtbCxcbiAgdHJhaWxpbmdBY2N1bXVsYXRlZFZhbHVlOiAoKSA9PiB0cmFpbGluZ0FjY3VtdWxhdGVkVmFsdWUsXG4gIHRyYWlsaW5nQWNjdW11bGF0ZWRWYWx1ZVByb3BlcnR5OiAoKSA9PiB0cmFpbGluZ0FjY3VtdWxhdGVkVmFsdWVQcm9wZXJ0eSxcbiAgdW5pcXVlOiAoKSA9PiB1bmlxdWUsXG4gIHVwZGF0ZUNsaXBQYXRoOiAoKSA9PiB1cGRhdGVDbGlwUGF0aCxcbiAgdXBkYXRlTGFiZWxOb2RlOiAoKSA9PiB1cGRhdGVMYWJlbE5vZGUsXG4gIHVwZGF0ZVJlY3Q6ICgpID0+IHVwZGF0ZVJlY3QsXG4gIHZhbGlkYXRlQ3Jvc3NMaW5lVmFsdWVzOiAoKSA9PiB2YWxpZGF0ZUNyb3NzTGluZVZhbHVlcyxcbiAgdmFsdWVQcm9wZXJ0eTogKCkgPT4gdmFsdWVQcm9wZXJ0eSxcbiAgd2l0aG91dDogKCkgPT4gd2l0aG91dFxufSk7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvZGVwcmVjYXRpb24udHNcbmZ1bmN0aW9uIGNyZWF0ZURlcHJlY2F0aW9uV2FybmluZygpIHtcbiAgcmV0dXJuIChrZXksIG1lc3NhZ2UpID0+IHtcbiAgICBjb25zdCBtc2cgPSBbYFByb3BlcnR5IFske2tleX1dIGlzIGRlcHJlY2F0ZWQuYCwgbWVzc2FnZV0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCIgXCIpO1xuICAgIExvZ2dlci53YXJuT25jZShtc2cpO1xuICB9O1xufVxuZnVuY3Rpb24gRGVwcmVjYXRlZChtZXNzYWdlLCBvcHRzKSB7XG4gIGNvbnN0IHdhcm5EZXByZWNhdGVkID0gY3JlYXRlRGVwcmVjYXRpb25XYXJuaW5nKCk7XG4gIGNvbnN0IGRlZiA9IG9wdHM/LmRlZmF1bHQ7XG4gIHJldHVybiBhZGRUcmFuc2Zvcm1Ub0luc3RhbmNlUHJvcGVydHkoKF8sIGtleSwgdmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgIT09IGRlZikge1xuICAgICAgd2FybkRlcHJlY2F0ZWQoa2V5LnRvU3RyaW5nKCksIG1lc3NhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH0pO1xufVxuZnVuY3Rpb24gRGVwcmVjYXRlZEFuZFJlbmFtZWRUbyhuZXdQcm9wTmFtZSwgbWFwVmFsdWUpIHtcbiAgY29uc3Qgd2FybkRlcHJlY2F0ZWQgPSBjcmVhdGVEZXByZWNhdGlvbldhcm5pbmcoKTtcbiAgcmV0dXJuIGFkZFRyYW5zZm9ybVRvSW5zdGFuY2VQcm9wZXJ0eShcbiAgICAodGFyZ2V0LCBrZXksIHZhbHVlKSA9PiB7XG4gICAgICBpZiAodmFsdWUgIT09IHRhcmdldFtuZXdQcm9wTmFtZV0pIHtcbiAgICAgICAgd2FybkRlcHJlY2F0ZWQoa2V5LnRvU3RyaW5nKCksIGBVc2UgWyR7bmV3UHJvcE5hbWV9XSBpbnN0ZWFkLmApO1xuICAgICAgICBzZXRQYXRoKHRhcmdldCwgbmV3UHJvcE5hbWUsIG1hcFZhbHVlID8gbWFwVmFsdWUodmFsdWUpIDogdmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEJSRUFLX1RSQU5TRk9STV9DSEFJTjtcbiAgICB9LFxuICAgICh0YXJnZXQsIGtleSkgPT4ge1xuICAgICAgd2FybkRlcHJlY2F0ZWQoa2V5LnRvU3RyaW5nKCksIGBVc2UgWyR7bmV3UHJvcE5hbWV9XSBpbnN0ZWFkLmApO1xuICAgICAgcmV0dXJuIGdldFBhdGgodGFyZ2V0LCBuZXdQcm9wTmFtZSk7XG4gICAgfVxuICApO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3NlYXJjaC51dGlsLnRzXG5mdW5jdGlvbiBmaW5kTWF4VmFsdWUobWluLCBtYXgsIGl0ZXJhdGVlKSB7XG4gIGlmIChtaW4gPiBtYXgpXG4gICAgcmV0dXJuO1xuICBsZXQgZm91bmQ7XG4gIHdoaWxlIChtYXggPj0gbWluKSB7XG4gICAgY29uc3QgaW5kZXggPSBNYXRoLmZsb29yKChtYXggKyBtaW4pIC8gMik7XG4gICAgY29uc3QgdmFsdWUgPSBpdGVyYXRlZShpbmRleCk7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIG1heCA9IGluZGV4IC0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm91bmQgPSB2YWx1ZTtcbiAgICAgIG1pbiA9IGluZGV4ICsgMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZvdW5kO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3ZlY3RvcjQudHNcbnZhciBWZWM0ID0ge1xuICBib3R0b21DZW50ZXIsXG4gIGNlbnRlcixcbiAgY2xvbmUsXG4gIGVuZCxcbiAgZnJvbTogZnJvbTIsXG4gIGhlaWdodCxcbiAgcm91bmQ6IHJvdW5kNCxcbiAgc3RhcnQsXG4gIHRvcENlbnRlcixcbiAgb3JpZ2luOiBvcmlnaW4yLFxuICB3aWR0aFxufTtcbmZ1bmN0aW9uIHN0YXJ0KGEpIHtcbiAgcmV0dXJuIHsgeDogYS54MSwgeTogYS55MSB9O1xufVxuZnVuY3Rpb24gZW5kKGEpIHtcbiAgcmV0dXJuIHsgeDogYS54MiwgeTogYS55MiB9O1xufVxuZnVuY3Rpb24gdG9wQ2VudGVyKGEpIHtcbiAgcmV0dXJuIHsgeDogKGEueDEgKyBhLngyKSAvIDIsIHk6IE1hdGgubWluKGEueTEsIGEueTIpIH07XG59XG5mdW5jdGlvbiBjZW50ZXIoYSkge1xuICByZXR1cm4geyB4OiAoYS54MSArIGEueDIpIC8gMiwgeTogKGEueTEgKyBhLnkyKSAvIDIgfTtcbn1cbmZ1bmN0aW9uIGJvdHRvbUNlbnRlcihhKSB7XG4gIHJldHVybiB7IHg6IChhLngxICsgYS54MikgLyAyLCB5OiBNYXRoLm1heChhLnkxLCBhLnkyKSB9O1xufVxuZnVuY3Rpb24gd2lkdGgoYSkge1xuICByZXR1cm4gTWF0aC5hYnMoYS54MiAtIGEueDEpO1xufVxuZnVuY3Rpb24gaGVpZ2h0KGEpIHtcbiAgcmV0dXJuIE1hdGguYWJzKGEueTIgLSBhLnkxKTtcbn1cbmZ1bmN0aW9uIHJvdW5kNChhKSB7XG4gIHJldHVybiB7IHgxOiBNYXRoLnJvdW5kKGEueDEpLCB5MTogTWF0aC5yb3VuZChhLnkxKSwgeDI6IE1hdGgucm91bmQoYS54MiksIHkyOiBNYXRoLnJvdW5kKGEueTIpIH07XG59XG5mdW5jdGlvbiBjbG9uZShhKSB7XG4gIHJldHVybiB7IHgxOiBhLngxLCB5MTogYS55MSwgeDI6IGEueDIsIHkyOiBhLnkyIH07XG59XG5mdW5jdGlvbiBmcm9tMihhLCBiLCBjLCBkKSB7XG4gIGlmICh0eXBlb2YgYSA9PT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiB7IHgxOiBhLCB5MTogYiwgeDI6IGMsIHkyOiBkIH07XG4gIH1cbiAgaWYgKFwid2lkdGhcIiBpbiBhKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHgxOiBhLngsXG4gICAgICB5MTogYS55LFxuICAgICAgeDI6IGEueCArIGEud2lkdGgsXG4gICAgICB5MjogYS55ICsgYS5oZWlnaHRcbiAgICB9O1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihgVmFsdWVzIGNhbiBub3QgYmUgY29udmVydGVkIGludG8gYSB2ZWN0b3I0OiBbJHthfV0gWyR7Yn1dIFske2N9XSBbJHtkfV1gKTtcbn1cbmZ1bmN0aW9uIG9yaWdpbjIoKSB7XG4gIHJldHVybiB7IHgxOiAwLCB5MTogMCwgeDI6IDAsIHkyOiAwIH07XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9oaWVyYXJjaHkvaGllcmFyY2h5U2VyaWVzLnRzXG52YXIgX0hpZXJhcmNoeU5vZGUgPSBjbGFzcyBfSGllcmFyY2h5Tm9kZSB7XG4gIGNvbnN0cnVjdG9yKHNlcmllcywgaW5kZXgsIGRhdHVtLCBzaXplLCBjb2xvclZhbHVlLCBmaWxsLCBzdHJva2UsIHN1bVNpemUsIGRlcHRoLCBwYXJlbnQsIGNoaWxkcmVuKSB7XG4gICAgdGhpcy5zZXJpZXMgPSBzZXJpZXM7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIHRoaXMuZGF0dW0gPSBkYXR1bTtcbiAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgIHRoaXMuY29sb3JWYWx1ZSA9IGNvbG9yVmFsdWU7XG4gICAgdGhpcy5maWxsID0gZmlsbDtcbiAgICB0aGlzLnN0cm9rZSA9IHN0cm9rZTtcbiAgICB0aGlzLnN1bVNpemUgPSBzdW1TaXplO1xuICAgIHRoaXMuZGVwdGggPSBkZXB0aDtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgdGhpcy5taWRQb2ludCA9IHsgeDogMCwgeTogMCB9O1xuICB9XG4gIGNvbnRhaW5zKG90aGVyKSB7XG4gICAgbGV0IGN1cnJlbnQgPSBvdGhlcjtcbiAgICB3aGlsZSAoY3VycmVudCAhPSBudWxsICYmIGN1cnJlbnQuaW5kZXggPj0gdGhpcy5pbmRleCkge1xuICAgICAgaWYgKGN1cnJlbnQgPT09IHRoaXMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB3YWxrKGNhbGxiYWNrMiwgb3JkZXIgPSBfSGllcmFyY2h5Tm9kZS5XYWxrLlByZU9yZGVyKSB7XG4gICAgaWYgKG9yZGVyID09PSBfSGllcmFyY2h5Tm9kZS5XYWxrLlByZU9yZGVyKSB7XG4gICAgICBjYWxsYmFjazIodGhpcyk7XG4gICAgfVxuICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgIGNoaWxkLndhbGsoY2FsbGJhY2syLCBvcmRlcik7XG4gICAgfSk7XG4gICAgaWYgKG9yZGVyID09PSBfSGllcmFyY2h5Tm9kZS5XYWxrLlBvc3RPcmRlcikge1xuICAgICAgY2FsbGJhY2syKHRoaXMpO1xuICAgIH1cbiAgfVxuICAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgeWllbGQgdGhpcztcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgIHlpZWxkKiBjaGlsZDtcbiAgICB9XG4gIH1cbn07XG5fSGllcmFyY2h5Tm9kZS5XYWxrID0ge1xuICBQcmVPcmRlcjogMCxcbiAgUG9zdE9yZGVyOiAxXG59O1xudmFyIEhpZXJhcmNoeU5vZGUgPSBfSGllcmFyY2h5Tm9kZTtcbnZhciBIaWVyYXJjaHlTZXJpZXMgPSBjbGFzcyBleHRlbmRzIFNlcmllcyB7XG4gIGNvbnN0cnVjdG9yKG1vZHVsZUN0eCkge1xuICAgIHN1cGVyKHtcbiAgICAgIG1vZHVsZUN0eCxcbiAgICAgIHBpY2tNb2RlczogWzEgLyogTkVBUkVTVF9OT0RFICovLCAwIC8qIEVYQUNUX1NIQVBFX01BVENIICovXSxcbiAgICAgIGNvbnRlbnRHcm91cFZpcnR1YWw6IGZhbHNlXG4gICAgfSk7XG4gICAgdGhpcy5yb290Tm9kZSA9IG5ldyBIaWVyYXJjaHlOb2RlKFxuICAgICAgdGhpcyxcbiAgICAgIDAsXG4gICAgICB2b2lkIDAsXG4gICAgICAwLFxuICAgICAgdm9pZCAwLFxuICAgICAgdm9pZCAwLFxuICAgICAgdm9pZCAwLFxuICAgICAgMCxcbiAgICAgIHZvaWQgMCxcbiAgICAgIHZvaWQgMCxcbiAgICAgIFtdXG4gICAgKTtcbiAgICB0aGlzLmNvbG9yRG9tYWluID0gWzAsIDBdO1xuICAgIHRoaXMubWF4RGVwdGggPSAwO1xuICAgIHRoaXMuZm9jdXNQYXRoID0gW107XG4gICAgdGhpcy5hbmltYXRpb25TdGF0ZSA9IG5ldyBTdGF0ZU1hY2hpbmUoXG4gICAgICBcImVtcHR5XCIsXG4gICAgICB7XG4gICAgICAgIGVtcHR5OiB7XG4gICAgICAgICAgdXBkYXRlOiB7XG4gICAgICAgICAgICB0YXJnZXQ6IFwicmVhZHlcIixcbiAgICAgICAgICAgIGFjdGlvbjogKGRhdGEpID0+IHRoaXMuYW5pbWF0ZUVtcHR5VXBkYXRlUmVhZHkoZGF0YSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc2V0OiBcImVtcHR5XCIsXG4gICAgICAgICAgc2tpcDogXCJyZWFkeVwiXG4gICAgICAgIH0sXG4gICAgICAgIHJlYWR5OiB7XG4gICAgICAgICAgdXBkYXRlRGF0YTogXCJ3YWl0aW5nXCIsXG4gICAgICAgICAgY2xlYXI6IFwiY2xlYXJpbmdcIixcbiAgICAgICAgICBoaWdobGlnaHQ6IChkYXRhKSA9PiB0aGlzLmFuaW1hdGVSZWFkeUhpZ2hsaWdodChkYXRhKSxcbiAgICAgICAgICByZXNpemU6IChkYXRhKSA9PiB0aGlzLmFuaW1hdGVSZWFkeVJlc2l6ZShkYXRhKSxcbiAgICAgICAgICByZXNldDogXCJlbXB0eVwiLFxuICAgICAgICAgIHNraXA6IFwicmVhZHlcIlxuICAgICAgICB9LFxuICAgICAgICB3YWl0aW5nOiB7XG4gICAgICAgICAgdXBkYXRlOiB7XG4gICAgICAgICAgICB0YXJnZXQ6IFwicmVhZHlcIixcbiAgICAgICAgICAgIGFjdGlvbjogKGRhdGEpID0+IHRoaXMuYW5pbWF0ZVdhaXRpbmdVcGRhdGVSZWFkeShkYXRhKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVzZXQ6IFwiZW1wdHlcIixcbiAgICAgICAgICBza2lwOiBcInJlYWR5XCJcbiAgICAgICAgfSxcbiAgICAgICAgY2xlYXJpbmc6IHtcbiAgICAgICAgICB1cGRhdGU6IHtcbiAgICAgICAgICAgIHRhcmdldDogXCJlbXB0eVwiLFxuICAgICAgICAgICAgYWN0aW9uOiAoZGF0YSkgPT4gdGhpcy5hbmltYXRlQ2xlYXJpbmdVcGRhdGVFbXB0eShkYXRhKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVzZXQ6IFwiZW1wdHlcIixcbiAgICAgICAgICBza2lwOiBcInJlYWR5XCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgICgpID0+IHRoaXMuY2hlY2tQcm9jZXNzZWREYXRhQW5pbWF0YWJsZSgpXG4gICAgKTtcbiAgfVxuICByZXNldEFuaW1hdGlvbihwaGFzZSkge1xuICAgIGlmIChwaGFzZSA9PT0gXCJpbml0aWFsXCIpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcInJlc2V0XCIpO1xuICAgIH0gZWxzZSBpZiAocGhhc2UgPT09IFwicmVhZHlcIikge1xuICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwic2tpcFwiKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgcHJvY2Vzc0RhdGEoKSB7XG4gICAgY29uc3QgeyBjaGlsZHJlbktleSwgc2l6ZUtleSwgY29sb3JLZXksIGZpbGxzLCBzdHJva2VzLCBjb2xvclJhbmdlIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBjb25zdCBnZXRJbmRleCA9ICgpID0+IHtcbiAgICAgIGluZGV4ICs9IDE7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfTtcbiAgICBsZXQgbWF4RGVwdGggPSAwO1xuICAgIGxldCBtaW5Db2xvciA9IEluZmluaXR5O1xuICAgIGxldCBtYXhDb2xvciA9IC1JbmZpbml0eTtcbiAgICBjb25zdCBjb2xvcnMgPSBuZXcgQXJyYXkoKHRoaXMuZGF0YT8ubGVuZ3RoID8/IDApICsgMSkuZmlsbCh2b2lkIDApO1xuICAgIGNvbnN0IGNyZWF0ZU5vZGUgPSAoZGF0dW0sIHBhcmVudCkgPT4ge1xuICAgICAgY29uc3Qgbm9kZUluZGV4ID0gZ2V0SW5kZXgoKTtcbiAgICAgIGNvbnN0IGRlcHRoID0gcGFyZW50LmRlcHRoICE9IG51bGwgPyBwYXJlbnQuZGVwdGggKyAxIDogMDtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gY2hpbGRyZW5LZXkgIT0gbnVsbCA/IGRhdHVtW2NoaWxkcmVuS2V5XSA6IHZvaWQgMDtcbiAgICAgIGNvbnN0IGlzTGVhZiA9IGNoaWxkcmVuID09IG51bGwgfHwgY2hpbGRyZW4ubGVuZ3RoID09PSAwO1xuICAgICAgbGV0IHNpemUgPSBzaXplS2V5ICE9IG51bGwgPyBkYXR1bVtzaXplS2V5XSA6IHZvaWQgMDtcbiAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoc2l6ZSkpIHtcbiAgICAgICAgc2l6ZSA9IE1hdGgubWF4KHNpemUsIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2l6ZSA9IGlzTGVhZiA/IDEgOiAwO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3VtU2l6ZSA9IHNpemU7XG4gICAgICBtYXhEZXB0aCA9IE1hdGgubWF4KG1heERlcHRoLCBkZXB0aCk7XG4gICAgICBjb25zdCBjb2xvciA9IGNvbG9yS2V5ICE9IG51bGwgPyBkYXR1bVtjb2xvcktleV0gOiB2b2lkIDA7XG4gICAgICBpZiAodHlwZW9mIGNvbG9yID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGNvbG9yc1tub2RlSW5kZXhdID0gY29sb3I7XG4gICAgICAgIG1pbkNvbG9yID0gTWF0aC5taW4obWluQ29sb3IsIGNvbG9yKTtcbiAgICAgICAgbWF4Q29sb3IgPSBNYXRoLm1heChtYXhDb2xvciwgY29sb3IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFwcGVuZENoaWxkcmVuKFxuICAgICAgICBuZXcgSGllcmFyY2h5Tm9kZShcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIG5vZGVJbmRleCxcbiAgICAgICAgICBkYXR1bSxcbiAgICAgICAgICBzaXplLFxuICAgICAgICAgIGNvbG9yLFxuICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgc3VtU2l6ZSxcbiAgICAgICAgICBkZXB0aCxcbiAgICAgICAgICBwYXJlbnQsXG4gICAgICAgICAgW11cbiAgICAgICAgKSxcbiAgICAgICAgY2hpbGRyZW5cbiAgICAgICk7XG4gICAgfTtcbiAgICBjb25zdCBhcHBlbmRDaGlsZHJlbiA9IChub2RlLCBkYXRhKSA9PiB7XG4gICAgICBkYXRhPy5mb3JFYWNoKChkYXR1bSkgPT4ge1xuICAgICAgICBjb25zdCBjaGlsZCA9IGNyZWF0ZU5vZGUoZGF0dW0sIG5vZGUpO1xuICAgICAgICBub2RlLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICBub2RlLnN1bVNpemUgKz0gY2hpbGQuc3VtU2l6ZTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcbiAgICBjb25zdCByb290Tm9kZSA9IGFwcGVuZENoaWxkcmVuKFxuICAgICAgbmV3IEhpZXJhcmNoeU5vZGUoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIDAsXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgMCxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgMCxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIFtdXG4gICAgICApLFxuICAgICAgdGhpcy5kYXRhXG4gICAgKTtcbiAgICBjb25zdCBjb2xvckRvbWFpbiA9IFttaW5Db2xvciwgbWF4Q29sb3JdO1xuICAgIGxldCBjb2xvclNjYWxlO1xuICAgIGlmIChjb2xvclJhbmdlICE9IG51bGwgJiYgTnVtYmVyLmlzRmluaXRlKG1pbkNvbG9yKSAmJiBOdW1iZXIuaXNGaW5pdGUobWF4Q29sb3IpKSB7XG4gICAgICBjb2xvclNjYWxlID0gbmV3IENvbG9yU2NhbGUoKTtcbiAgICAgIGNvbG9yU2NhbGUuZG9tYWluID0gY29sb3JEb21haW47XG4gICAgICBjb2xvclNjYWxlLnJhbmdlID0gY29sb3JSYW5nZTtcbiAgICAgIGNvbG9yU2NhbGUudXBkYXRlKCk7XG4gICAgfVxuICAgIHJvb3ROb2RlLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkLCBjaGlsZEluZGV4KSA9PiB7XG4gICAgICBjaGlsZC53YWxrKChub2RlKSA9PiB7XG4gICAgICAgIGxldCBmaWxsO1xuICAgICAgICBjb25zdCBjb2xvciA9IGNvbG9yc1tub2RlLmluZGV4XTtcbiAgICAgICAgaWYgKGNvbG9yICE9IG51bGwpIHtcbiAgICAgICAgICBmaWxsID0gY29sb3JTY2FsZT8uY29udmVydChjb2xvcik7XG4gICAgICAgIH1cbiAgICAgICAgZmlsbCA/PyAoZmlsbCA9IGZpbGxzPy5bY2hpbGRJbmRleCAlIGZpbGxzLmxlbmd0aF0pO1xuICAgICAgICBub2RlLmZpbGwgPSBmaWxsO1xuICAgICAgICBub2RlLnN0cm9rZSA9IGNvbG9yU2NhbGUgPT0gbnVsbCA/IHN0cm9rZXM/LltjaGlsZEluZGV4ICUgc3Ryb2tlcy5sZW5ndGhdIDogXCJyZ2JhKDAsIDAsIDAsIDAuMilcIjtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMucm9vdE5vZGUgPSByb290Tm9kZTtcbiAgICB0aGlzLm1heERlcHRoID0gbWF4RGVwdGg7XG4gICAgdGhpcy5jb2xvckRvbWFpbiA9IGNvbG9yRG9tYWluO1xuICAgIHRoaXMuZm9jdXNQYXRoID0gW3sgbm9kZURhdHVtOiB0aGlzLnJvb3ROb2RlLCBjaGlsZEluZGV4OiAwIH1dO1xuICB9XG4gIGFzeW5jIHVwZGF0ZSh7IHNlcmllc1JlY3QgfSkge1xuICAgIGF3YWl0IHRoaXMudXBkYXRlU2VsZWN0aW9ucygpO1xuICAgIGF3YWl0IHRoaXMudXBkYXRlTm9kZXMoKTtcbiAgICBjb25zdCBhbmltYXRpb25EYXRhID0gdGhpcy5nZXRBbmltYXRpb25EYXRhKCk7XG4gICAgY29uc3QgcmVzaXplID0gdGhpcy5jaGVja1Jlc2l6ZShzZXJpZXNSZWN0KTtcbiAgICBpZiAocmVzaXplKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJyZXNpemVcIiwgYW5pbWF0aW9uRGF0YSk7XG4gICAgfVxuICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcInVwZGF0ZVwiLCBhbmltYXRpb25EYXRhKTtcbiAgfVxuICByZXNldEFsbEFuaW1hdGlvbihkYXRhKSB7XG4gICAgY29uc3QgZGF0dW0gPSB0aGlzLmFuaW1hdGlvblJlc2V0Rm5zPy5kYXR1bTtcbiAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLnN0b3BCeUFuaW1hdGlvbkdyb3VwSWQodGhpcy5pZCk7XG4gICAgaWYgKGRhdHVtICE9IG51bGwpIHtcbiAgICAgIHJlc2V0TW90aW9uKGRhdGEuZGF0dW1TZWxlY3Rpb25zLCBkYXR1bSk7XG4gICAgfVxuICB9XG4gIGFuaW1hdGVFbXB0eVVwZGF0ZVJlYWR5KGRhdGEpIHtcbiAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLnNraXBDdXJyZW50QmF0Y2goKTtcbiAgICB0aGlzLnJlc2V0QWxsQW5pbWF0aW9uKGRhdGEpO1xuICB9XG4gIGFuaW1hdGVXYWl0aW5nVXBkYXRlUmVhZHkoZGF0YSkge1xuICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuc2tpcEN1cnJlbnRCYXRjaCgpO1xuICAgIHRoaXMucmVzZXRBbGxBbmltYXRpb24oZGF0YSk7XG4gIH1cbiAgYW5pbWF0ZVJlYWR5SGlnaGxpZ2h0KGRhdGEpIHtcbiAgICBjb25zdCBkYXR1bSA9IHRoaXMuYW5pbWF0aW9uUmVzZXRGbnM/LmRhdHVtO1xuICAgIGlmIChkYXR1bSAhPSBudWxsKSB7XG4gICAgICByZXNldE1vdGlvbihbZGF0YV0sIGRhdHVtKTtcbiAgICB9XG4gIH1cbiAgYW5pbWF0ZVJlYWR5UmVzaXplKGRhdGEpIHtcbiAgICB0aGlzLnJlc2V0QWxsQW5pbWF0aW9uKGRhdGEpO1xuICB9XG4gIGFuaW1hdGVDbGVhcmluZ1VwZGF0ZUVtcHR5KGRhdGEpIHtcbiAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLnNraXBDdXJyZW50QmF0Y2goKTtcbiAgICB0aGlzLnJlc2V0QWxsQW5pbWF0aW9uKGRhdGEpO1xuICB9XG4gIGFuaW1hdGlvblRyYW5zaXRpb25DbGVhcigpIHtcbiAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJjbGVhclwiLCB0aGlzLmdldEFuaW1hdGlvbkRhdGEoKSk7XG4gIH1cbiAgZ2V0QW5pbWF0aW9uRGF0YSgpIHtcbiAgICBjb25zdCBhbmltYXRpb25EYXRhID0ge1xuICAgICAgZGF0dW1TZWxlY3Rpb25zOiBbdGhpcy5ncm91cFNlbGVjdGlvbl1cbiAgICB9O1xuICAgIHJldHVybiBhbmltYXRpb25EYXRhO1xuICB9XG4gIGlzUHJvY2Vzc2VkRGF0YUFuaW1hdGFibGUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY2hlY2tQcm9jZXNzZWREYXRhQW5pbWF0YWJsZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNQcm9jZXNzZWREYXRhQW5pbWF0YWJsZSgpKSB7XG4gICAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLnNraXBDdXJyZW50QmF0Y2goKTtcbiAgICB9XG4gIH1cbiAgZ2V0TGFiZWxEYXRhKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBnZXRTZXJpZXNEb21haW4oKSB7XG4gICAgcmV0dXJuIFtOYU4sIE5hTl07XG4gIH1cbiAgZ2V0TGVnZW5kRGF0YShsZWdlbmRUeXBlKSB7XG4gICAgY29uc3QgeyBjb2xvcktleSwgY29sb3JOYW1lLCBjb2xvclJhbmdlLCB2aXNpYmxlIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgcmV0dXJuIGxlZ2VuZFR5cGUgPT09IFwiZ3JhZGllbnRcIiAmJiBjb2xvcktleSAhPSBudWxsICYmIGNvbG9yUmFuZ2UgIT0gbnVsbCA/IFtcbiAgICAgIHtcbiAgICAgICAgbGVnZW5kVHlwZTogXCJncmFkaWVudFwiLFxuICAgICAgICBlbmFibGVkOiB2aXNpYmxlLFxuICAgICAgICBzZXJpZXNJZDogdGhpcy5pZCxcbiAgICAgICAgY29sb3JOYW1lLFxuICAgICAgICBjb2xvclJhbmdlLFxuICAgICAgICBjb2xvckRvbWFpbjogdGhpcy5jb2xvckRvbWFpblxuICAgICAgfVxuICAgIF0gOiBbXTtcbiAgfVxuICBnZXREYXR1bUlkRnJvbURhdGEobm9kZSkge1xuICAgIHJldHVybiBgJHtub2RlLmluZGV4fWA7XG4gIH1cbiAgZ2V0RGF0dW1JZChub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RGF0dW1JZEZyb21EYXRhKG5vZGUpO1xuICB9XG4gIHBpY2tGb2N1cyhvcHRzKSB7XG4gICAgaWYgKHRoaXMucm9vdE5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICBpZiAodGhpcy5mb2N1c1BhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICBMb2dnZXIuZXJyb3IoXCJ0aGlzLmZvY3VzUGF0aCBzaG91bGQgbm90IGJlIGVtcHR5XCIpO1xuICAgIH1cbiAgICBjb25zdCB7IGRhdHVtSW5kZXhEZWx0YTogY2hpbGREZWx0YSwgb3RoZXJJbmRleERlbHRhOiBkZXB0aERlbHRhIH0gPSBvcHRzO1xuICAgIGNvbnN0IHsgZm9jdXNQYXRoOiBwYXRoIH0gPSB0aGlzO1xuICAgIGNvbnN0IGRlcHRoID0gcGF0aC5sZW5ndGggLSAyO1xuICAgIGlmIChkZXB0aERlbHRhICE9PSAwIHx8IHBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCB0YXJnZXREZXB0aCA9IE1hdGgubWF4KDAsIGRlcHRoICsgZGVwdGhEZWx0YSk7XG4gICAgICBpZiAocGF0aFt0YXJnZXREZXB0aCArIDFdICE9PSB2b2lkIDApIHtcbiAgICAgICAgcGF0aC5sZW5ndGggPSB0YXJnZXREZXB0aCArIDI7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVGb2N1c091dHB1dHMocGF0aFt0YXJnZXREZXB0aCArIDFdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBkZWVwZXN0ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICB3aGlsZSAoZGVlcGVzdC5ub2RlRGF0dW0uY2hpbGRyZW4ubGVuZ3RoID4gMCAmJiAoZGVlcGVzdC5ub2RlRGF0dW0uZGVwdGggPz8gLTEpIDwgdGFyZ2V0RGVwdGgpIHtcbiAgICAgICAgICBjb25zdCBuZXh0RGVlcGVzdCA9IHsgbm9kZURhdHVtOiBkZWVwZXN0Lm5vZGVEYXR1bS5jaGlsZHJlblswXSwgY2hpbGRJbmRleDogMCB9O1xuICAgICAgICAgIHBhdGgucHVzaChuZXh0RGVlcGVzdCk7XG4gICAgICAgICAgZGVlcGVzdCA9IG5leHREZWVwZXN0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVGb2N1c091dHB1dHMoZGVlcGVzdCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjaGlsZERlbHRhICE9PSAwKSB7XG4gICAgICBjb25zdCB0YXJnZXRDaGlsZCA9IHBhdGhbZGVwdGggKyAxXS5jaGlsZEluZGV4ICsgY2hpbGREZWx0YTtcbiAgICAgIGNvbnN0IGN1cnJlbnRQYXJlbnQgPSBwYXRoW2RlcHRoXS5ub2RlRGF0dW07XG4gICAgICBjb25zdCBjaGlsZENvdW50ID0gY3VycmVudFBhcmVudD8uY2hpbGRyZW4/Lmxlbmd0aDtcbiAgICAgIGlmIChjaGlsZENvdW50ICE9PSB2b2lkIDApIHtcbiAgICAgICAgY29uc3QgbmV3Q2hpbGQgPSBjbGFtcCgwLCB0YXJnZXRDaGlsZCwgY2hpbGRDb3VudCAtIDEpO1xuICAgICAgICBjb25zdCBuZXdGb2N1cyA9IHsgbm9kZURhdHVtOiBjdXJyZW50UGFyZW50LmNoaWxkcmVuW25ld0NoaWxkXSwgY2hpbGRJbmRleDogbmV3Q2hpbGQgfTtcbiAgICAgICAgcGF0aFtkZXB0aCArIDFdID0gbmV3Rm9jdXM7XG4gICAgICAgIHBhdGgubGVuZ3RoID0gZGVwdGggKyAyO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlRm9jdXNPdXRwdXRzKG5ld0ZvY3VzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZUZvY3VzT3V0cHV0cyhwYXRoW3BhdGgubGVuZ3RoIC0gMV0pO1xuICAgIH1cbiAgfVxuICBnZXREYXR1bUFyaWFUZXh0KGRhdHVtLCBkZXNjcmlwdGlvbikge1xuICAgIGlmICghKGRhdHVtIGluc3RhbmNlb2YgSGllcmFyY2h5Tm9kZSkpIHtcbiAgICAgIExvZ2dlci5lcnJvcihgZGF0dW0gaXMgbm90IEhpZXJhcmNoeU5vZGU6ICR7ZGF0dW19YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmN0eC5sb2NhbGVNYW5hZ2VyLnQoXCJhcmlhQW5ub3VuY2VIaWVyYXJjaHlEYXR1bVwiLCB7XG4gICAgICBsZXZlbDogKGRhdHVtLmRlcHRoID8/IC0xKSArIDEsXG4gICAgICBjb3VudDogZGF0dW0uY2hpbGRyZW4ubGVuZ3RoLFxuICAgICAgZGVzY3JpcHRpb25cbiAgICB9KTtcbiAgfVxuICBjb21wdXRlRm9jdXNPdXRwdXRzKHsgbm9kZURhdHVtLCBjaGlsZEluZGV4IH0pIHtcbiAgICBjb25zdCBib3VuZHMgPSB0aGlzLmNvbXB1dGVGb2N1c0JvdW5kcyhub2RlRGF0dW0pO1xuICAgIGlmIChib3VuZHMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdHVtOiBub2RlRGF0dW0sXG4gICAgICAgIGRhdHVtSW5kZXg6IGNoaWxkSW5kZXgsXG4gICAgICAgIG90aGVySW5kZXg6IG5vZGVEYXR1bS5kZXB0aCxcbiAgICAgICAgYm91bmRzLFxuICAgICAgICBzaG93Rm9jdXNCb3g6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9oaWVyYXJjaHkvaGllcmFyY2h5U2VyaWVzUHJvcGVydGllcy50c1xudmFyIEhpZXJhcmNoeVNlcmllc1Byb3BlcnRpZXMgPSBjbGFzcyBleHRlbmRzIFNlcmllc1Byb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuY2hpbGRyZW5LZXkgPSBcImNoaWxkcmVuXCI7XG4gICAgdGhpcy5maWxscyA9IE9iamVjdC52YWx1ZXMoREVGQVVMVF9GSUxMUyk7XG4gICAgdGhpcy5zdHJva2VzID0gT2JqZWN0LnZhbHVlcyhERUZBVUxUX1NUUk9LRVMpO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HKVxuXSwgSGllcmFyY2h5U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiY2hpbGRyZW5LZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEhpZXJhcmNoeVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInNpemVLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEhpZXJhcmNoeVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNvbG9yS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBIaWVyYXJjaHlTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjb2xvck5hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkdfQVJSQVkpXG5dLCBIaWVyYXJjaHlTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJmaWxsc1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklOR19BUlJBWSlcbl0sIEhpZXJhcmNoeVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0cm9rZXNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkdfQVJSQVksIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEhpZXJhcmNoeVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNvbG9yUmFuZ2VcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy90b3BvbG9neS9sb25MYXRCYm94LnRzXG52YXIgTG9uTGF0QkJveCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IobG9uMCwgbGF0MCwgbG9uMSwgbGF0MSkge1xuICAgIHRoaXMubG9uMCA9IGxvbjA7XG4gICAgdGhpcy5sYXQwID0gbGF0MDtcbiAgICB0aGlzLmxvbjEgPSBsb24xO1xuICAgIHRoaXMubGF0MSA9IGxhdDE7XG4gIH1cbiAgbWVyZ2Uob3RoZXIpIHtcbiAgICB0aGlzLmxvbjAgPSBNYXRoLm1pbih0aGlzLmxvbjAsIG90aGVyLmxvbjApO1xuICAgIHRoaXMubGF0MCA9IE1hdGgubWluKHRoaXMubGF0MCwgb3RoZXIubGF0MCk7XG4gICAgdGhpcy5sb24xID0gTWF0aC5tYXgodGhpcy5sb24xLCBvdGhlci5sb24xKTtcbiAgICB0aGlzLmxhdDEgPSBNYXRoLm1heCh0aGlzLmxhdDEsIG90aGVyLmxhdDEpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3RlbXBVdGlscy50c1xuZnVuY3Rpb24gY3JlYXRlSWRzR2VuZXJhdG9yKCkge1xuICBjb25zdCBpZHNDb3VudGVyID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgcmV0dXJuIChuYW1lKSA9PiB7XG4gICAgY29uc3QgY291bnRlciA9IGlkc0NvdW50ZXIuZ2V0KG5hbWUpO1xuICAgIGlmIChjb3VudGVyKSB7XG4gICAgICBpZHNDb3VudGVyLnNldChuYW1lLCBjb3VudGVyICsgMSk7XG4gICAgICByZXR1cm4gYCR7bmFtZX0ke2NvdW50ZXJ9YDtcbiAgICB9XG4gICAgaWRzQ291bnRlci5zZXQobmFtZSwgMSk7XG4gICAgcmV0dXJuIG5hbWU7XG4gIH07XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2F4aXMvYXhpc1RpY2tzLnRzXG52YXIgX0F4aXNUaWNrcyA9IGNsYXNzIF9BeGlzVGlja3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmlkID0gY3JlYXRlSWQodGhpcyk7XG4gICAgdGhpcy5heGlzR3JvdXAgPSBuZXcgVHJhbnNsYXRhYmxlR3JvdXAoeyBuYW1lOiBgJHt0aGlzLmlkfS1BeGlzVGlja3NgLCB6SW5kZXg6IDIgLyogQVhJUyAqLyB9KTtcbiAgICB0aGlzLmxhYmVsU2VsZWN0aW9uID0gU2VsZWN0aW9uLnNlbGVjdCh0aGlzLmF4aXNHcm91cCwgVGV4dCk7XG4gICAgdGhpcy5pbnRlcnZhbCA9IG5ldyBBeGlzSW50ZXJ2YWwoKTtcbiAgICB0aGlzLmxhYmVsID0gbmV3IEF4aXNMYWJlbCgpO1xuICAgIHRoaXMuc2NhbGUgPSBuZXcgTGluZWFyU2NhbGUoKTtcbiAgICB0aGlzLnBvc2l0aW9uID0gXCJib3R0b21cIjtcbiAgICB0aGlzLnRyYW5zbGF0aW9uWCA9IDA7XG4gICAgdGhpcy50cmFuc2xhdGlvblkgPSAwO1xuICAgIHRoaXMucGFkZGluZyA9IDA7XG4gIH1cbiAgYXR0YWNoQXhpcyhheGlzTm9kZSkge1xuICAgIGF4aXNOb2RlLmFwcGVuZENoaWxkKHRoaXMuYXhpc0dyb3VwKTtcbiAgfVxuICBjYWxjdWxhdGVMYXlvdXQoKSB7XG4gICAgdGhpcy5zY2FsZS5pbnRlcnZhbCA9IHRoaXMuaW50ZXJ2YWwuc3RlcDtcbiAgICBjb25zdCBib3hlcyA9IFtdO1xuICAgIGNvbnN0IHRpY2tEYXRhID0gdGhpcy5nZW5lcmF0ZVRpY2tzKCk7XG4gICAgY29uc3QgeyB0cmFuc2xhdGlvblgsIHRyYW5zbGF0aW9uWSB9ID0gdGhpcztcbiAgICB0aGlzLmxhYmVsU2VsZWN0aW9uLnVwZGF0ZShcbiAgICAgIHRpY2tEYXRhLnRpY2tzLm1hcCgoZCkgPT4gdGhpcy5jcmVhdGVMYWJlbERhdHVtKGQpKSxcbiAgICAgIHZvaWQgMCxcbiAgICAgIChkYXR1bSkgPT4gZGF0dW0udGlja0lkXG4gICAgKTtcbiAgICB0aGlzLmxhYmVsU2VsZWN0aW9uLmVhY2goKG5vZGUsIGRhdHVtKSA9PiB7XG4gICAgICBub2RlLnNldFByb3BlcnRpZXMoZGF0dW0pO1xuICAgICAgaWYgKGRhdHVtLnZpc2libGUpIHtcbiAgICAgICAgYm94ZXMucHVzaChub2RlLmdldEJCb3goKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5heGlzR3JvdXAuc2V0UHJvcGVydGllcyh7IHRyYW5zbGF0aW9uWCwgdHJhbnNsYXRpb25ZIH0pO1xuICAgIHJldHVybiBCQm94Lm1lcmdlKGJveGVzKTtcbiAgfVxuICBnZXRMYWJlbFBhcmFtcyhkYXR1bSkge1xuICAgIGNvbnN0IHsgcGFkZGluZyB9ID0gdGhpcztcbiAgICBjb25zdCB7IHRyYW5zbGF0ZSB9ID0gZGF0dW07XG4gICAgc3dpdGNoICh0aGlzLnBvc2l0aW9uKSB7XG4gICAgICBjYXNlIFwidG9wXCI6XG4gICAgICBjYXNlIFwiYm90dG9tXCI6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogdHJhbnNsYXRlLFxuICAgICAgICAgIHk6IHBhZGRpbmcsXG4gICAgICAgICAgdGV4dEFsaWduOiBcImNlbnRlclwiLFxuICAgICAgICAgIHRleHRCYXNlbGluZTogXCJ0b3BcIlxuICAgICAgICB9O1xuICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IHBhZGRpbmcsXG4gICAgICAgICAgeTogdHJhbnNsYXRlLFxuICAgICAgICAgIHRleHRBbGlnbjogXCJzdGFydFwiLFxuICAgICAgICAgIHRleHRCYXNlbGluZTogXCJtaWRkbGVcIlxuICAgICAgICB9O1xuICAgIH1cbiAgfVxuICBpblJhbmdlKHgsIHRvbGVyYW5jZSA9IDFlLTMpIHtcbiAgICBjb25zdCBbbWluLCBtYXhdID0gZmluZE1pbk1heCh0aGlzLnNjYWxlLnJhbmdlKTtcbiAgICByZXR1cm4geCA+PSBtaW4gLSB0b2xlcmFuY2UgJiYgeCA8PSBtYXggKyB0b2xlcmFuY2U7XG4gIH1cbiAgY3JlYXRlTGFiZWxEYXR1bShkYXR1bSkge1xuICAgIGNvbnN0IHsgeCwgeSwgdGV4dEJhc2VsaW5lLCB0ZXh0QWxpZ24gfSA9IHRoaXMuZ2V0TGFiZWxQYXJhbXMoZGF0dW0pO1xuICAgIHJldHVybiB7XG4gICAgICB2aXNpYmxlOiBCb29sZWFuKGRhdHVtLnRpY2tMYWJlbCksXG4gICAgICB0aWNrSWQ6IGRhdHVtLnRpY2tJZCxcbiAgICAgIGZpbGw6IHRoaXMubGFiZWwuY29sb3IsXG4gICAgICBmb250RmFtaWx5OiB0aGlzLmxhYmVsLmZvbnRGYW1pbHksXG4gICAgICBmb250U2l6ZTogdGhpcy5sYWJlbC5mb250U2l6ZSxcbiAgICAgIGZvbnRTdHlsZTogdGhpcy5sYWJlbC5mb250U3R5bGUsXG4gICAgICBmb250V2VpZ2h0OiB0aGlzLmxhYmVsLmZvbnRXZWlnaHQsXG4gICAgICByb3RhdGlvbjogMCxcbiAgICAgIHJvdGF0aW9uQ2VudGVyWDogMCxcbiAgICAgIHRleHQ6IGRhdHVtLnRpY2tMYWJlbCxcbiAgICAgIHRleHRBbGlnbixcbiAgICAgIHRleHRCYXNlbGluZSxcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfTtcbiAgfVxuICBnZW5lcmF0ZVRpY2tzKCkge1xuICAgIGNvbnN0IHsgbWluU3BhY2luZywgbWF4U3BhY2luZyB9ID0gdGhpcy5pbnRlcnZhbDtcbiAgICBjb25zdCBleHRlbnRXaXRoQmxlZWQgPSByb3VuZChmaW5kUmFuZ2VFeHRlbnQodGhpcy5zY2FsZS5yYW5nZSksIDIpO1xuICAgIGNvbnN0IHsgbWF4VGlja0NvdW50LCBtaW5UaWNrQ291bnQsIHRpY2tDb3VudCB9ID0gZXN0aW1hdGVUaWNrQ291bnQoXG4gICAgICBleHRlbnRXaXRoQmxlZWQsXG4gICAgICBtaW5TcGFjaW5nLFxuICAgICAgbWF4U3BhY2luZyxcbiAgICAgIF9BeGlzVGlja3MuRGVmYXVsdFRpY2tDb3VudCxcbiAgICAgIF9BeGlzVGlja3MuRGVmYXVsdE1pblNwYWNpbmdcbiAgICApO1xuICAgIGlmICh0aWNrQ291bnQpIHtcbiAgICAgIHRoaXMuc2NhbGUudGlja0NvdW50ID0gdGlja0NvdW50O1xuICAgICAgdGhpcy5zY2FsZS5taW5UaWNrQ291bnQgPSBtaW5UaWNrQ291bnQ7XG4gICAgICB0aGlzLnNjYWxlLm1heFRpY2tDb3VudCA9IG1heFRpY2tDb3VudDtcbiAgICB9XG4gICAgY29uc3QgdGlja0RhdGEgPSB0aGlzLmdldFRpY2tzRGF0YSgpO1xuICAgIGlmICh0aGlzLnBvc2l0aW9uID09PSBcImJvdHRvbVwiIHx8IHRoaXMucG9zaXRpb24gPT09IFwidG9wXCIpIHtcbiAgICAgIGNvbnN0IG1lYXN1cmVyID0gQ2FjaGVkVGV4dE1lYXN1cmVyUG9vbC5nZXRNZWFzdXJlcih7IGZvbnQ6IHRoaXMubGFiZWwgfSk7XG4gICAgICBjb25zdCBkb21haW4gPSB0aGlzLnNjYWxlLmdldERvbWFpbigpO1xuICAgICAgY29uc3QgcmV2ZXJzZWQgPSBkb21haW5bMF0gPiBkb21haW5bMV07XG4gICAgICBjb25zdCBkaXJlY3Rpb24gPSByZXZlcnNlZCA/IC0xIDogMTtcbiAgICAgIGxldCBsYXN0VGlja1Bvc2l0aW9uID0gLUluZmluaXR5ICogZGlyZWN0aW9uO1xuICAgICAgdGlja0RhdGEudGlja3MgPSB0aWNrRGF0YS50aWNrcy5maWx0ZXIoKGRhdGEpID0+IHtcbiAgICAgICAgaWYgKE1hdGguc2lnbihkYXRhLnRyYW5zbGF0ZSAtIGxhc3RUaWNrUG9zaXRpb24pICE9PSBkaXJlY3Rpb24pXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsYXN0VGlja1Bvc2l0aW9uID0gZGF0YS50cmFuc2xhdGUgKyBtZWFzdXJlci50ZXh0V2lkdGgoZGF0YS50aWNrTGFiZWwsIHRydWUpICogZGlyZWN0aW9uO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGlja0RhdGE7XG4gIH1cbiAgZ2V0VGlja3NEYXRhKCkge1xuICAgIGNvbnN0IHRpY2tzID0gW107XG4gICAgY29uc3QgcmF3VGlja3MgPSB0aGlzLnNjYWxlLnRpY2tzKCk7XG4gICAgY29uc3QgZnJhY3Rpb25EaWdpdHMgPSByYXdUaWNrcy5yZWR1Y2UoXG4gICAgICAobWF4LCB0aWNrKSA9PiBNYXRoLm1heChtYXgsIHR5cGVvZiB0aWNrID09PSBcIm51bWJlclwiID8gY291bnRGcmFjdGlvbkRpZ2l0cyh0aWNrKSA6IDApLFxuICAgICAgMFxuICAgICk7XG4gICAgY29uc3QgaWRHZW5lcmF0b3IgPSBjcmVhdGVJZHNHZW5lcmF0b3IoKTtcbiAgICBjb25zdCBsYWJlbEZvcm1hdHRlciA9IHRoaXMubGFiZWwuZm9ybWF0ID8gdGhpcy5zY2FsZS50aWNrRm9ybWF0KHsgdGlja3M6IHJhd1RpY2tzLCBzcGVjaWZpZXI6IHRoaXMubGFiZWwuZm9ybWF0IH0pIDogKHgpID0+IGlzTnVtYmVyKHgpID8geC50b0ZpeGVkKGZyYWN0aW9uRGlnaXRzKSA6IFN0cmluZyh4KTtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcmF3VGlja3MubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBjb25zdCB0aWNrID0gcmF3VGlja3NbaW5kZXhdO1xuICAgICAgY29uc3QgdHJhbnNsYXRlID0gdGhpcy5zY2FsZS5jb252ZXJ0KHRpY2spO1xuICAgICAgaWYgKCF0aGlzLmluUmFuZ2UodHJhbnNsYXRlKSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCB0aWNrTGFiZWwgPSB0aGlzLmxhYmVsLmZvcm1hdHRlcj8uKHsgdmFsdWU6IHRpY2ssIGluZGV4LCBmcmFjdGlvbkRpZ2l0cyB9KSA/PyBsYWJlbEZvcm1hdHRlcih0aWNrKTtcbiAgICAgIGNvbnN0IHRpY2tJZCA9IGlkR2VuZXJhdG9yKHRpY2tMYWJlbCk7XG4gICAgICB0aWNrcy5wdXNoKHsgdGljaywgdGlja0lkLCB0aWNrTGFiZWwsIHRyYW5zbGF0ZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHsgcmF3VGlja3MsIGZyYWN0aW9uRGlnaXRzLCB0aWNrcyB9O1xuICB9XG59O1xuX0F4aXNUaWNrcy5EZWZhdWx0VGlja0NvdW50ID0gNTtcbl9BeGlzVGlja3MuRGVmYXVsdE1pblNwYWNpbmcgPSA1MDtcbnZhciBBeGlzVGlja3MgPSBfQXhpc1RpY2tzO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9sZWdlbmREYXR1bS50c1xudmFyIF9fRk9SQ0VfTU9EVUxFX0RFVEVDVElPTiA9IDA7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2RvbS9lbGVtZW50cy50c1xuZnVuY3Rpb24gY3JlYXRlQnV0dG9uKG9wdGlvbnMsIGF0dHJzKSB7XG4gIGNvbnN0IGJ1dHRvbiA9IGNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgZ2V0Q2xhc3NOYW1lKFwiYWctY2hhcnRzLWlucHV0IGFnLWNoYXJ0cy1idXR0b25cIiwgYXR0cnMpKTtcbiAgaWYgKG9wdGlvbnMubGFiZWwgIT09IHZvaWQgMCkge1xuICAgIGJ1dHRvbi5hcHBlbmQob3B0aW9ucy5sYWJlbCk7XG4gIH0gZWxzZSB7XG4gICAgYnV0dG9uLmFwcGVuZChjcmVhdGVJY29uKG9wdGlvbnMuaWNvbikpO1xuICAgIGJ1dHRvbi5hcmlhTGFiZWwgPSBvcHRpb25zLmFsdFRleHQ7XG4gIH1cbiAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBvcHRpb25zLm9uUHJlc3MpO1xuICBzZXRBdHRyaWJ1dGVzKGJ1dHRvbiwgYXR0cnMpO1xuICByZXR1cm4gYnV0dG9uO1xufVxuZnVuY3Rpb24gY3JlYXRlQ2hlY2tib3gob3B0aW9ucywgYXR0cnMpIHtcbiAgY29uc3QgY2hlY2tib3ggPSBjcmVhdGVFbGVtZW50KFwiaW5wdXRcIiwgZ2V0Q2xhc3NOYW1lKFwiYWctY2hhcnRzLWlucHV0IGFnLWNoYXJ0cy1jaGVja2JveFwiLCBhdHRycykpO1xuICBjaGVja2JveC50eXBlID0gXCJjaGVja2JveFwiO1xuICBjaGVja2JveC5jaGVja2VkID0gb3B0aW9ucy5jaGVja2VkO1xuICBjaGVja2JveC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIChldmVudCkgPT4gb3B0aW9ucy5vbkNoYW5nZShjaGVja2JveC5jaGVja2VkLCBldmVudCkpO1xuICBjaGVja2JveC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCAoZXZlbnQpID0+IHtcbiAgICBpZiAoaXNCdXR0b25DbGlja0V2ZW50KGV2ZW50KSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGNoZWNrYm94LmNsaWNrKCk7XG4gICAgfVxuICB9KTtcbiAgc2V0QXR0cmlidXRlcyhjaGVja2JveCwgYXR0cnMpO1xuICByZXR1cm4gY2hlY2tib3g7XG59XG5mdW5jdGlvbiBjcmVhdGVTZWxlY3Qob3B0aW9ucywgYXR0cnMpIHtcbiAgY29uc3Qgc2VsZWN0ID0gY3JlYXRlRWxlbWVudChcInNlbGVjdFwiLCBnZXRDbGFzc05hbWUoXCJhZy1jaGFydHMtaW5wdXQgYWctY2hhcnRzLXNlbGVjdFwiLCBhdHRycykpO1xuICBzZWxlY3QuYXBwZW5kKFxuICAgIC4uLm9wdGlvbnMub3B0aW9ucy5tYXAoKG9wdGlvbikgPT4ge1xuICAgICAgY29uc3Qgb3B0aW9uRWwgPSBjcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgICAgb3B0aW9uRWwudmFsdWUgPSBvcHRpb24udmFsdWU7XG4gICAgICBvcHRpb25FbC50ZXh0Q29udGVudCA9IG9wdGlvbi5sYWJlbDtcbiAgICAgIHJldHVybiBvcHRpb25FbDtcbiAgICB9KVxuICApO1xuICBzZXRBdHRyaWJ1dGUoc2VsZWN0LCBcImRhdGEtcHJldmVudGRlZmF1bHRcIiwgZmFsc2UpO1xuICBzZWxlY3QudmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICBzZWxlY3QuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoZXZlbnQpID0+IG9wdGlvbnMub25DaGFuZ2Uoc2VsZWN0LnZhbHVlLCBldmVudCkpO1xuICBzZXRBdHRyaWJ1dGVzKHNlbGVjdCwgYXR0cnMpO1xuICByZXR1cm4gc2VsZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlVGV4dEFyZWEob3B0aW9ucywgYXR0cnMpIHtcbiAgY29uc3QgdGV4dEFyZWEgPSBjcmVhdGVFbGVtZW50KFwidGV4dGFyZWFcIiwgZ2V0Q2xhc3NOYW1lKFwiYWctY2hhcnRzLWlucHV0IGFnLWNoYXJ0cy10ZXh0YXJlYVwiLCBhdHRycykpO1xuICB0ZXh0QXJlYS52YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG4gIHRleHRBcmVhLmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCAoZXZlbnQpID0+IG9wdGlvbnMub25DaGFuZ2UodGV4dEFyZWEudmFsdWUsIGV2ZW50KSk7XG4gIHNldEF0dHJpYnV0ZXModGV4dEFyZWEsIGF0dHJzKTtcbiAgcmV0dXJuIHRleHRBcmVhO1xufVxuZnVuY3Rpb24gY3JlYXRlSWNvbihpY29uKSB7XG4gIGNvbnN0IGVsID0gY3JlYXRlRWxlbWVudChcInNwYW5cIiwgYGFnLWNoYXJ0cy1pY29uIGFnLWNoYXJ0cy1pY29uLSR7aWNvbn1gKTtcbiAgc2V0QXR0cmlidXRlKGVsLCBcImFyaWEtaGlkZGVuXCIsIHRydWUpO1xuICByZXR1cm4gZWw7XG59XG5mdW5jdGlvbiBnZXRDbGFzc05hbWUoYmFzZUNsYXNzLCBhdHRycykge1xuICBpZiAoYXR0cnMgPT0gbnVsbClcbiAgICByZXR1cm4gYmFzZUNsYXNzO1xuICByZXR1cm4gYCR7YmFzZUNsYXNzfSAke2F0dHJzLmNsYXNzfWA7XG59XG5leHBvcnQge1xuICBBR19DSEFSVFNfTE9DQUxFX0VOX1VTLFxuICBBZ0NoYXJ0cyxcbiAgQWdFcnJvckJhclN1cHBvcnRlZFNlcmllc1R5cGVzLFxuICBBZ1Rvb2x0aXBQb3NpdGlvblR5cGUsXG4gIElDT05TX0xFR0FDWSxcbiAgTWFya2VyLFxuICBWRVJTSU9OLFxuICBtb2R1bGVfc3VwcG9ydF9leHBvcnRzIGFzIF9Nb2R1bGVTdXBwb3J0LFxuICBzcGFya2xpbmVzX3NjYWxlX2V4cG9ydHMgYXMgX1NjYWxlLFxuICBpbnRlZ3JhdGVkX2NoYXJ0c19zY2VuZV9leHBvcnRzIGFzIF9TY2VuZSxcbiAgaW50ZWdyYXRlZF9jaGFydHNfdGhlbWVfZXhwb3J0cyBhcyBfVGhlbWUsXG4gIHNwYXJrbGluZXNfdXRpbF9leHBvcnRzIGFzIF9VdGlsLFxuICBzZXR1cENvbW11bml0eU1vZHVsZXMsXG4gIHRpbWVfZXhwb3J0cyBhcyB0aW1lXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ag-charts-community/dist/package/main.esm.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ag-charts-react/dist/package/index.esm.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/ag-charts-react/dist/package/index.esm.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AgCharts: () => (/* binding */ AgCharts),\n/* harmony export */   AgFinancialCharts: () => (/* binding */ AgFinancialCharts),\n/* harmony export */   AgGauge: () => (/* binding */ AgGauge)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var ag_charts_community__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ag-charts-community */ \"(app-pages-browser)/./node_modules/ag-charts-community/dist/package/main.esm.mjs\");\n// packages/ag-charts-react/src/index.ts\n\n\nfunction getOptions(options, containerRef) {\n  return {\n    ...options,\n    container: containerRef.current\n  };\n}\nfunction ChartWithConstructor(ctor, displayName) {\n  const Component = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function AgChartsReact(props, ref) {\n    const { options, style, className } = props;\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const chartRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n      const chart = ctor(getOptions(options, containerRef));\n      chartRef.current = chart;\n      return () => {\n        chart.destroy();\n      };\n    }, []);\n    const unsafeIsInitialMount = chartRef.current === void 0;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n      if (!unsafeIsInitialMount) {\n        void chartRef.current?.update(getOptions(options, containerRef));\n      }\n    }, [options]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => chartRef.current, []);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n      return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n        ref: containerRef,\n        style,\n        className\n      });\n    }, [style, className]);\n  });\n  Component.displayName = displayName;\n  return Component;\n}\nvar AgCharts = /* @__PURE__ */ ChartWithConstructor(\n  (options) => ag_charts_community__WEBPACK_IMPORTED_MODULE_1__.AgCharts.create(options),\n  \"AgCharts\"\n);\nvar AgFinancialCharts = /* @__PURE__ */ ChartWithConstructor(\n  (options) => ag_charts_community__WEBPACK_IMPORTED_MODULE_1__.AgCharts.createFinancialChart(options),\n  \"AgFinancialCharts\"\n);\nvar AgGauge = /* @__PURE__ */ ChartWithConstructor(\n  (options) => ag_charts_community__WEBPACK_IMPORTED_MODULE_1__.AgCharts.createGauge(options),\n  \"AgGauge\"\n);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9hZy1jaGFydHMtcmVhY3QvZGlzdC9wYWNrYWdlL2luZGV4LmVzbS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQVNlO0FBR2M7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaURBQVU7QUFDOUIsWUFBWSw0QkFBNEI7QUFDeEMseUJBQXlCLDZDQUFNO0FBQy9CLHFCQUFxQiw2Q0FBTTtBQUMzQixJQUFJLHNEQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksMERBQW1CO0FBQ3ZCLFdBQVcsOENBQU87QUFDbEIsYUFBYSxvREFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseURBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsZUFBZSx5REFBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxlQUFlLHlEQUFXO0FBQzFCO0FBQ0E7QUFLRSIsInNvdXJjZXMiOlsiL1VzZXJzL3Bhd2VsbmllZHp3aWVkei9EZXNrdG9wL3ZvdXktYnVzaW5lc3Mvbm9kZV9tb2R1bGVzL2FnLWNoYXJ0cy1yZWFjdC9kaXN0L3BhY2thZ2UvaW5kZXguZXNtLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBwYWNrYWdlcy9hZy1jaGFydHMtcmVhY3Qvc3JjL2luZGV4LnRzXG5pbXBvcnQge1xuICBjcmVhdGVFbGVtZW50LFxuICBmb3J3YXJkUmVmLFxuICB1c2VFZmZlY3QsXG4gIHVzZUltcGVyYXRpdmVIYW5kbGUsXG4gIHVzZUxheW91dEVmZmVjdCxcbiAgdXNlTWVtbyxcbiAgdXNlUmVmXG59IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHtcbiAgQWdDaGFydHMgYXMgQWdDaGFydHNBUElcbn0gZnJvbSBcImFnLWNoYXJ0cy1jb21tdW5pdHlcIjtcbmZ1bmN0aW9uIGdldE9wdGlvbnMob3B0aW9ucywgY29udGFpbmVyUmVmKSB7XG4gIHJldHVybiB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICBjb250YWluZXI6IGNvbnRhaW5lclJlZi5jdXJyZW50XG4gIH07XG59XG5mdW5jdGlvbiBDaGFydFdpdGhDb25zdHJ1Y3RvcihjdG9yLCBkaXNwbGF5TmFtZSkge1xuICBjb25zdCBDb21wb25lbnQgPSBmb3J3YXJkUmVmKGZ1bmN0aW9uIEFnQ2hhcnRzUmVhY3QocHJvcHMsIHJlZikge1xuICAgIGNvbnN0IHsgb3B0aW9ucywgc3R5bGUsIGNsYXNzTmFtZSB9ID0gcHJvcHM7XG4gICAgY29uc3QgY29udGFpbmVyUmVmID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IGNoYXJ0UmVmID0gdXNlUmVmKCk7XG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgIGNvbnN0IGNoYXJ0ID0gY3RvcihnZXRPcHRpb25zKG9wdGlvbnMsIGNvbnRhaW5lclJlZikpO1xuICAgICAgY2hhcnRSZWYuY3VycmVudCA9IGNoYXJ0O1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY2hhcnQuZGVzdHJveSgpO1xuICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3QgdW5zYWZlSXNJbml0aWFsTW91bnQgPSBjaGFydFJlZi5jdXJyZW50ID09PSB2b2lkIDA7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIGlmICghdW5zYWZlSXNJbml0aWFsTW91bnQpIHtcbiAgICAgICAgdm9pZCBjaGFydFJlZi5jdXJyZW50Py51cGRhdGUoZ2V0T3B0aW9ucyhvcHRpb25zLCBjb250YWluZXJSZWYpKTtcbiAgICAgIH1cbiAgICB9LCBbb3B0aW9uc10pO1xuICAgIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCAoKSA9PiBjaGFydFJlZi5jdXJyZW50LCBbXSk7XG4gICAgcmV0dXJuIHVzZU1lbW8oKCkgPT4ge1xuICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICByZWY6IGNvbnRhaW5lclJlZixcbiAgICAgICAgc3R5bGUsXG4gICAgICAgIGNsYXNzTmFtZVxuICAgICAgfSk7XG4gICAgfSwgW3N0eWxlLCBjbGFzc05hbWVdKTtcbiAgfSk7XG4gIENvbXBvbmVudC5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xuICByZXR1cm4gQ29tcG9uZW50O1xufVxudmFyIEFnQ2hhcnRzID0gLyogQF9fUFVSRV9fICovIENoYXJ0V2l0aENvbnN0cnVjdG9yKFxuICAob3B0aW9ucykgPT4gQWdDaGFydHNBUEkuY3JlYXRlKG9wdGlvbnMpLFxuICBcIkFnQ2hhcnRzXCJcbik7XG52YXIgQWdGaW5hbmNpYWxDaGFydHMgPSAvKiBAX19QVVJFX18gKi8gQ2hhcnRXaXRoQ29uc3RydWN0b3IoXG4gIChvcHRpb25zKSA9PiBBZ0NoYXJ0c0FQSS5jcmVhdGVGaW5hbmNpYWxDaGFydChvcHRpb25zKSxcbiAgXCJBZ0ZpbmFuY2lhbENoYXJ0c1wiXG4pO1xudmFyIEFnR2F1Z2UgPSAvKiBAX19QVVJFX18gKi8gQ2hhcnRXaXRoQ29uc3RydWN0b3IoXG4gIChvcHRpb25zKSA9PiBBZ0NoYXJ0c0FQSS5jcmVhdGVHYXVnZShvcHRpb25zKSxcbiAgXCJBZ0dhdWdlXCJcbik7XG5leHBvcnQge1xuICBBZ0NoYXJ0cyxcbiAgQWdGaW5hbmNpYWxDaGFydHMsXG4gIEFnR2F1Z2Vcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ag-charts-react/dist/package/index.esm.mjs\n"));

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["main-app"], () => (__webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fpawelniedzwiedz%2FDesktop%2Fvouy-business%2Fsrc%2Fapp%2Fauth%2Fdashboard%2FRevenue%2FRevenue.tsx%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=false!")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);