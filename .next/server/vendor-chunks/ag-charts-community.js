"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ag-charts-community";
exports.ids = ["vendor-chunks/ag-charts-community"];
exports.modules = {

/***/ "(ssr)/./node_modules/ag-charts-community/dist/package/main.esm.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/ag-charts-community/dist/package/main.esm.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AG_CHARTS_LOCALE_EN_US: () => (/* binding */ AG_CHARTS_LOCALE_EN_US),\n/* harmony export */   AgCharts: () => (/* binding */ AgCharts),\n/* harmony export */   AgErrorBarSupportedSeriesTypes: () => (/* binding */ AgErrorBarSupportedSeriesTypes),\n/* harmony export */   AgTooltipPositionType: () => (/* binding */ AgTooltipPositionType),\n/* harmony export */   ICONS_LEGACY: () => (/* binding */ ICONS_LEGACY),\n/* harmony export */   Marker: () => (/* binding */ Marker),\n/* harmony export */   VERSION: () => (/* binding */ VERSION),\n/* harmony export */   _ModuleSupport: () => (/* binding */ module_support_exports),\n/* harmony export */   _Scale: () => (/* binding */ sparklines_scale_exports),\n/* harmony export */   _Scene: () => (/* binding */ integrated_charts_scene_exports),\n/* harmony export */   _Theme: () => (/* binding */ integrated_charts_theme_exports),\n/* harmony export */   _Util: () => (/* binding */ sparklines_util_exports),\n/* harmony export */   setupCommunityModules: () => (/* binding */ setupCommunityModules),\n/* harmony export */   time: () => (/* binding */ time_exports)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __decorateClass = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result)\n    __defProp(target, key, result);\n  return result;\n};\n\n// packages/ag-charts-locale/src/en-US.ts\nvar AG_CHARTS_LOCALE_EN_US = {\n  // Screen reader announcement when focusing an item in the chart\n  ariaAnnounceHoverDatum: \"${datum}\",\n  // Screen reader announcement when focusing a chart\n  ariaAnnounceChart: \"chart, ${seriesCount}[number] series\",\n  // Screen reader announcement when focusing a hierarchy chart\n  ariaAnnounceHierarchyChart: \"hierarchy chart, ${caption}\",\n  // Screen reader announcement when focusing a gauge chart\n  ariaAnnounceGaugeChart: \"gauge chart, ${caption}\",\n  // Screen reader announcement when focusing an item in a treemap or sunburst chart\n  ariaAnnounceHierarchyDatum: \"level ${level}[number], ${count}[number] children, ${description}\",\n  // Screen reader announcement when focusing a link in a Sankey or chord chart\n  ariaAnnounceFlowProportionLink: \"link ${index} of ${count}, from ${from} to ${to}, ${sizeName} ${size}\",\n  // Screen reader announcement when focusing a node in a Sankey or chord chart\n  ariaAnnounceFlowProportionNode: \"node ${index} of ${count}, ${description}\",\n  // Screen reader description for legend items\n  ariaDescriptionLegendItem: \"Press Space or Enter to toggle visibility\",\n  // Screen reader text for annotation-options toolbar\n  ariaLabelAnnotationOptionsToolbar: \"Annotation Options\",\n  // Screen reader text for annotation-settings dialog\n  ariaLabelAnnotationSettingsDialog: \"Annotation Settings\",\n  // Screen reader text for the color picker dialog\n  ariaLabelColorPicker: \"Color picker\",\n  // Screen reader text for the financial charts toolbar\n  ariaLabelFinancialCharts: \"Financial Charts\",\n  // Screen reader text for the legend toolbar\n  ariaLabelLegend: \"Legend\",\n  // Screen reader text for the legend pagination button\n  ariaLabelLegendPagination: \"Legend Pagination\",\n  // Screen reader text for the previous legend page button\n  ariaLabelLegendPagePrevious: \"Previous Legend Page\",\n  // Screen reader text for the next legend page button\n  ariaLabelLegendPageNext: \"Next Legend Page\",\n  // Screen reader text for the an item in the legend\n  ariaLabelLegendItem: \"${label}, Legend item ${index}[number] of ${count}[number]\",\n  // Screen reader text for the an unknown item in the legend\n  ariaLabelLegendItemUnknown: \"Unknown legend item\",\n  // Screen reader text for the navigator element\n  ariaLabelNavigator: \"Navigator\",\n  // Screen reader text for an accessibility control that changes the position of the navigator's range\n  ariaLabelNavigatorRange: \"Range\",\n  // Screen reader text for an accessibility control that changes the start of the navigator's range\n  ariaLabelNavigatorMinimum: \"Minimum\",\n  // Screen reader text for an accessibility control that changes the end of the navigator's range\n  ariaLabelNavigatorMaximum: \"Maximum\",\n  // Screen reader text for ranges toolbar\n  ariaLabelRangesToolbar: \"Ranges\",\n  // Screen reader text for the settings dialog tab-bar\n  ariaLabelSettingsTabBar: \"Settings\",\n  // Screen reader text for zoom toolbar\n  ariaLabelZoomToolbar: \"Zoom\",\n  // Screen reader text for the value of the navigator's range\n  ariaValuePanRange: \"${min}[percent] to ${max}[percent]\",\n  // Alt-text for the solid line dash style menu item icon\n  iconAltTextLineStyleSolid: \"Solid\",\n  // Alt-text for the long-dashed line dash style menu item icon\n  iconAltTextLineStyleDashed: \"Long-dashed\",\n  // Alt-text for the short-dashed line dash style menu item icon\n  iconAltTextLineStyleDotted: \"Short-dashed\",\n  // Alt-text for the 'position-top' icon\n  iconAltTextPositionTop: \"Top\",\n  // Alt-text for the 'position-center' icon\n  iconAltTextPositionCenter: \"Center\",\n  // Alt-text for the 'position-bottom' icon\n  iconAltTextPositionBottom: \"Bottom\",\n  // Alt-text for the 'position-left' icon\n  iconAltTextAlignLeft: \"Left\",\n  // Alt-text for the 'align-center' icon\n  iconAltTextAlignCenter: \"Center\",\n  // Alt-text for the 'position-right' icon\n  iconAltTextAlignRight: \"Right\",\n  // Alt-text for the 'close' icon\n  iconAltTextClose: \"Close\",\n  // Default text for the 'loading data' overlay\n  overlayLoadingData: \"Loading data...\",\n  // Default text for the 'no data' overlay\n  overlayNoData: \"No data to display\",\n  // Default text for the 'no visible series' overlay\n  overlayNoVisibleSeries: \"No visible series\",\n  // Text for the series type toolbar's chart type button\n  toolbarSeriesTypeDropdown: \"Chart Type\",\n  // Text for the series type toolbar's OHLC chart type button\n  toolbarSeriesTypeOHLC: \"OHLC\",\n  // Text for the series type toolbar's HLC chart type button\n  toolbarSeriesTypeHLC: \"HLC\",\n  // Text for the series type toolbar's high low chart type button\n  toolbarSeriesTypeHighLow: \"High Low\",\n  // Text for the series type toolbar's candles chart type button\n  toolbarSeriesTypeCandles: \"Candles\",\n  // Text for the series type toolbar's hollow candles chart type button\n  toolbarSeriesTypeHollowCandles: \"Hollow Candles\",\n  // Text for the series type toolbar's line chart type button\n  toolbarSeriesTypeLine: \"Line\",\n  // Text for the series type toolbar's line with markers chart type button\n  toolbarSeriesTypeLineWithMarkers: \"Line with Markers\",\n  // Text for the series type toolbar's line with step line chart type button\n  toolbarSeriesTypeStepLine: \"Step Line\",\n  // Text for the annotation toolbar's trend line button\n  toolbarAnnotationsTrendLine: \"Trend Line\",\n  // Text for the annotation toolbar's horizontal line button\n  toolbarAnnotationsHorizontalLine: \"Horizontal Line\",\n  // Text for the annotation toolbar's vertical line button\n  toolbarAnnotationsVerticalLine: \"Vertical Line\",\n  // Text for the annotation toolbar's parallel channel button\n  toolbarAnnotationsParallelChannel: \"Parallel Channel\",\n  // Text for the annotation toolbar's disjoint channel button\n  toolbarAnnotationsDisjointChannel: \"Disjoint Channel\",\n  // Text for the annotation toolbar's clear all button\n  toolbarAnnotationsClearAll: \"Clear All\",\n  /**\n   * Text for the annotation toolbar's color picker annotation button\n   * @deprecated v10.1.0 use `toolbarAnnotationsLineColor` instead.\n   */\n  toolbarAnnotationsColor: \"Color\",\n  // Text for the annotation toolbar's fill color picker annotation button\n  toolbarAnnotationsFillColor: \"Fill Color\",\n  // Text for the annotation toolbar's line color picker annotation button\n  toolbarAnnotationsLineColor: \"Line Color\",\n  // Text for the annotation toolbar's line style type button\n  toolbarAnnotationsLineStyle: \"Line Style\",\n  // Text for the annotation toolbar's line stroke width button\n  toolbarAnnotationsLineStrokeWidth: \"Line Stroke Width\",\n  // Text for the annotation toolbar's settings annotation button\n  toolbarAnnotationsSettings: \"Settings\",\n  // Text for the annotation toolbar's text color picker annotation button\n  toolbarAnnotationsTextColor: \"Text Color\",\n  // Text for the annotation toolbar's text size picker annotation button\n  toolbarAnnotationsTextSize: \"Text Size\",\n  // Text for the annotation toolbar's lock annotation button\n  toolbarAnnotationsLock: \"Lock\",\n  // Text for the annotation toolbar's unlock annotation button\n  toolbarAnnotationsUnlock: \"Unlock\",\n  // Text for the annotation toolbar's delete annotation button\n  toolbarAnnotationsDelete: \"Delete\",\n  // Text for the annotation toolbar's drag handle\n  toolbarAnnotationsDragHandle: \"Drag Toolbar\",\n  // Text for the annotation toolbar's line drawings menu button\n  toolbarAnnotationsLineAnnotations: \"Trend Lines\",\n  // Text for the annotation toolbar's text annotations menu button\n  toolbarAnnotationsTextAnnotations: \"Text Annotations\",\n  // Text for the annotation toolbar's shapes menu button\n  toolbarAnnotationsShapeAnnotations: \"Arrows\",\n  // Text for the annotation toolbar's measurers menu button\n  toolbarAnnotationsMeasurerAnnotations: \"Measurers\",\n  // Text for the annotation toolbar's callout button\n  toolbarAnnotationsCallout: \"Callout\",\n  // Text for the annotation toolbar's comment button\n  toolbarAnnotationsComment: \"Comment\",\n  // Text for the annotation toolbar's note button\n  toolbarAnnotationsNote: \"Note\",\n  // Text for the annotation toolbar's text button\n  toolbarAnnotationsText: \"Text\",\n  // Text for the annotation toolbar's arrow button\n  toolbarAnnotationsArrow: \"Arrow\",\n  // Text for the annotation toolbar's arrow up button\n  toolbarAnnotationsArrowUp: \"Arrow Up\",\n  // Text for the annotation toolbar's arrow down button\n  toolbarAnnotationsArrowDown: \"Arrow Down\",\n  // Text for the annotation toolbar's date range button\n  toolbarAnnotationsDateRange: \"Date Range\",\n  // Text for the annotation toolbar's price range button\n  toolbarAnnotationsPriceRange: \"Price Range\",\n  // Text for the annotation toolbar's date and price range button\n  toolbarAnnotationsDatePriceRange: \"Date and Price\",\n  // Text for the annotation toolbar's quick date and price range button\n  toolbarAnnotationsQuickDatePriceRange: \"Measure\",\n  // Text for the range toolbar's 1 month button\n  toolbarRange1Month: \"1M\",\n  // Aria label for the range toolbar's 1 month button\n  toolbarRange1MonthAria: \"1 month\",\n  // Text for the range toolbar's 3 month button\n  toolbarRange3Months: \"3M\",\n  // Aria label for the range toolbar's 3 month button\n  toolbarRange3MonthsAria: \"3 months\",\n  // Text for the range toolbar's 6 month button\n  toolbarRange6Months: \"6M\",\n  // Aria label for the range toolbar's 6 month button\n  toolbarRange6MonthsAria: \"6 months\",\n  // Text for the range toolbar's year to date button\n  toolbarRangeYearToDate: \"YTD\",\n  // Aria label for the range toolbar's year to date month button\n  toolbarRangeYearToDateAria: \"Year to date\",\n  // Text for the range toolbar's 1 year button\n  toolbarRange1Year: \"1Y\",\n  // Aria label for the range toolbar's 1 year button\n  toolbarRange1YearAria: \"1 year\",\n  // Text for the range toolbar's full range button\n  toolbarRangeAll: \"All\",\n  // Aria label for the range toolbar's full range button\n  toolbarRangeAllAria: \"All\",\n  // Text for the zoom toolbar's zoom out button\n  toolbarZoomZoomOut: \"Zoom out\",\n  // Text for the zoom toolbar's zoom in button\n  toolbarZoomZoomIn: \"Zoom in\",\n  // Text for the zoom toolbar's pan left button\n  toolbarZoomPanLeft: \"Pan left\",\n  // Text for the zoom toolbar's pan right button\n  toolbarZoomPanRight: \"Pan right\",\n  // Text for the zoom toolbar's pan to the start button\n  toolbarZoomPanStart: \"Pan to the start\",\n  // Text for the zoom toolbar's pan to the end button\n  toolbarZoomPanEnd: \"Pan to the end\",\n  // Text for the zoom toolbar's pan reset button\n  toolbarZoomReset: \"Reset the zoom\",\n  // Text for the context menu's download button\n  contextMenuDownload: \"Download\",\n  // Text for the context menu's toggle series visibility button\n  contextMenuToggleSeriesVisibility: \"Toggle Visibility\",\n  // Text for the context menu's toggle other series visibility button\n  contextMenuToggleOtherSeries: \"Toggle Other Series\",\n  // Text for the context menu's zoom to point button\n  contextMenuZoomToCursor: \"Zoom to here\",\n  // Text for the context menu's pan to point button\n  contextMenuPanToCursor: \"Pan to here\",\n  // Text for the annotation dialog's header channel tab label\n  dialogHeaderChannel: \"Channel\",\n  // Text for the annotation dialog's header line tab label\n  dialogHeaderLine: \"Line\",\n  // Text for the annotation dialog's header date range tab label\n  dialogHeaderDateRange: \"Date Range\",\n  // Text for the annotation dialog's header price range tab label\n  dialogHeaderPriceRange: \"Price Range\",\n  // Text for the annotation dialog's header date and price range tab label\n  dialogHeaderDatePriceRange: \"Date and Price\",\n  // Text for the annotation dialog's header text tab label\n  dialogHeaderText: \"Text\",\n  // Text for the annotation dialog's text alignment radio label\n  dialogInputAlign: \"Align\",\n  // Text for the annotation dialog's color picker label\n  dialogInputColorPicker: \"Color\",\n  // Text for the annotation dialog's color picker alt text\n  dialogInputColorPickerAltText: \"Text Color\",\n  // Text for the annotation dialog's fill color picker label\n  dialogInputFillColorPicker: \"Fill\",\n  // Text for the annotation dialog's fill color picker alt text\n  dialogInputFillColorPickerAltText: \"Fill Color\",\n  // Text for the annotation dialog's extend channel start checkbox\n  dialogInputExtendChannelStart: \"Extend channel start\",\n  // Text for the annotation dialog's extend channel end checkbox\n  dialogInputExtendChannelEnd: \"Extend channel end\",\n  // Text for the annotation dialog's extend line start checkbox\n  dialogInputExtendLineStart: \"Extend line start\",\n  // Text for the annotation dialog's extend line end checkbox\n  dialogInputExtendLineEnd: \"Extend line end\",\n  // Text for the annotation dialog's extend above checkbox\n  dialogInputExtendAbove: \"Extend above\",\n  // Text for the annotation dialog's extend below checkbox\n  dialogInputExtendBelow: \"Extend below\",\n  // Text for the annotation dialog's extend left checkbox\n  dialogInputExtendLeft: \"Extend left\",\n  // Text for the annotation dialog's extend right checkbox\n  dialogInputExtendRight: \"Extend right\",\n  // Text for the annotation dialog's font size select box label\n  dialogInputFontSize: \"Size\",\n  // Text for the annotation dialog's font size select box alt text\n  dialogInputFontSizeAltText: \"Font Size\",\n  // Text for the annotation dialog's line style radio label\n  dialogInputLineStyle: \"Dash\",\n  // Text for the annotation dialog's text position radio label\n  dialogInputPosition: \"Position\",\n  // Text for the annotation dialog's stroke width label\n  dialogInputStrokeWidth: \"Weight\",\n  // Text for the annotation dialog's stroke width label\n  dialogInputStrokeWidthAltText: \"Line Weight\",\n  // Text for text area input placeholders\n  inputTextareaPlaceholder: \"Add Text\",\n  // Text for the measurer statistics date range bars value\n  measurerDateRangeBars: \"${value}[number] bars\",\n  // Text for the measurer statistics price range value\n  measurerPriceRangeValue: \"${value}[number]\",\n  // Text for the measurer statistics price range percentage\n  measurerPriceRangePercent: \"${value}[percent]\",\n  // Text for the measurer statistics volume value\n  measurerVolume: \"Vol ${value}\"\n};\n\n// packages/ag-charts-types/src/chart/errorBarOptions.ts\nvar AgErrorBarSupportedSeriesTypes = [\"bar\", \"line\", \"scatter\"];\n\n// packages/ag-charts-types/src/chart/icons.ts\nvar ICONS_LEGACY = [\n  \"delete-legacy\",\n  \"disjoint-channel\",\n  \"disjoint-channel-legacy\",\n  \"horizontal-line-legacy\",\n  \"line-color-legacy\",\n  \"lock\",\n  \"lock-legacy\",\n  \"pan-end-legacy\",\n  \"pan-left-legacy\",\n  \"pan-right-legacy\",\n  \"pan-start-legacy\",\n  \"parallel-channel\",\n  \"parallel-channel-legacy\",\n  \"reset-legacy\",\n  \"trend-line\",\n  \"trend-line-legacy\",\n  \"unlock\",\n  \"unlock-legacy\",\n  \"vertical-line\",\n  \"vertical-line-legacy\",\n  \"zoom-in-legacy\",\n  \"zoom-in-alt\",\n  \"zoom-in-alt-legacy\",\n  \"zoom-out-legacy\",\n  \"zoom-out-alt\",\n  \"zoom-out-alt-legacy\"\n];\n\n// packages/ag-charts-types/src/chart/navigatorOptions.ts\nvar __MINI_CHART_SERIES_OPTIONS = void 0;\nvar __VERIFY_MINI_CHART_SERIES_OPTIONS = void 0;\n__VERIFY_MINI_CHART_SERIES_OPTIONS = __MINI_CHART_SERIES_OPTIONS;\n\n// packages/ag-charts-types/src/chart/themeOptions.ts\nvar __THEME_OVERRIDES = void 0;\nvar __VERIFY_THEME_OVERRIDES = void 0;\n__VERIFY_THEME_OVERRIDES = __THEME_OVERRIDES;\n\n// packages/ag-charts-types/src/chart/tooltipOptions.ts\nvar AgTooltipPositionType = /* @__PURE__ */ ((AgTooltipPositionType2) => {\n  AgTooltipPositionType2[\"POINTER\"] = \"pointer\";\n  AgTooltipPositionType2[\"NODE\"] = \"node\";\n  AgTooltipPositionType2[\"TOP\"] = \"top\";\n  AgTooltipPositionType2[\"RIGHT\"] = \"right\";\n  AgTooltipPositionType2[\"BOTTOM\"] = \"bottom\";\n  AgTooltipPositionType2[\"LEFT\"] = \"left\";\n  AgTooltipPositionType2[\"TOP_LEFT\"] = \"top-left\";\n  AgTooltipPositionType2[\"TOP_RIGHT\"] = \"top-right\";\n  AgTooltipPositionType2[\"BOTTOM_RIGHT\"] = \"bottom-right\";\n  AgTooltipPositionType2[\"BOTTOM_LEFT\"] = \"bottom-left\";\n  return AgTooltipPositionType2;\n})(AgTooltipPositionType || {});\n\n// packages/ag-charts-types/src/presets/gauge/commonOptions.ts\nvar __THEMEABLE_OPTIONS = void 0;\nvar __VERIFY_THEMEABLE_OPTIONS = void 0;\n__VERIFY_THEMEABLE_OPTIONS = __THEMEABLE_OPTIONS;\nvar __AXIS_LABEL_OPTIONS = void 0;\nvar __VERIFY_AXIS_LABEL_OPTIONS = void 0;\n__VERIFY_AXIS_LABEL_OPTIONS = __AXIS_LABEL_OPTIONS;\n\n// packages/ag-charts-community/src/util/time/index.ts\nvar time_exports = {};\n__export(time_exports, {\n  TimeInterval: () => TimeInterval,\n  day: () => day,\n  friday: () => friday,\n  hour: () => hour,\n  millisecond: () => millisecond,\n  minute: () => minute,\n  monday: () => monday,\n  month: () => month,\n  saturday: () => saturday,\n  second: () => second,\n  sunday: () => sunday,\n  thursday: () => thursday,\n  tuesday: () => tuesday,\n  utcDay: () => utcDay,\n  utcHour: () => utcHour,\n  utcMinute: () => utcMinute,\n  utcMonth: () => utcMonth,\n  utcYear: () => utcYear,\n  wednesday: () => wednesday,\n  year: () => year\n});\n\n// packages/ag-charts-community/src/util/function.ts\nvar doOnceState = /* @__PURE__ */ new Map();\nfunction doOnce(func, key) {\n  if (doOnceState.has(key))\n    return;\n  doOnceState.set(key, true);\n  func();\n}\ndoOnce.clear = () => doOnceState.clear();\nfunction identity(x) {\n  return x;\n}\nfunction throttle(callback2, waitMs = 0, options) {\n  const { leading = true, trailing = true } = options ?? {};\n  let timerId;\n  let lastArgs;\n  let shouldWait = false;\n  function timeoutHandler() {\n    if (trailing && lastArgs) {\n      timerId = setTimeout(timeoutHandler, waitMs);\n      callback2(...lastArgs);\n    } else {\n      shouldWait = false;\n    }\n    lastArgs = null;\n  }\n  function throttleCallback(...args) {\n    if (shouldWait) {\n      lastArgs = args;\n    } else {\n      shouldWait = true;\n      timerId = setTimeout(timeoutHandler, waitMs);\n      if (leading) {\n        callback2(...args);\n      } else {\n        lastArgs = args;\n      }\n    }\n  }\n  return Object.assign(throttleCallback, {\n    cancel() {\n      clearTimeout(timerId);\n      shouldWait = false;\n      lastArgs = null;\n    }\n  });\n}\nfunction joinFunctions(...fns) {\n  return () => {\n    for (const fn of fns) {\n      fn();\n    }\n  };\n}\n\n// packages/ag-charts-community/src/util/logger.ts\nvar Logger = {\n  log(...logContent) {\n    console.log(...logContent);\n  },\n  warn(message, ...logContent) {\n    console.warn(`AG Charts - ${message}`, ...logContent);\n  },\n  error(message, ...logContent) {\n    if (typeof message === \"object\") {\n      console.error(`AG Charts error`, message, ...logContent);\n    } else {\n      console.error(`AG Charts - ${message}`, ...logContent);\n    }\n  },\n  table(...logContent) {\n    console.table(...logContent);\n  },\n  warnOnce(message, ...logContent) {\n    doOnce(() => Logger.warn(message, ...logContent), `Logger.warn: ${message}`);\n  },\n  errorOnce(message, ...logContent) {\n    doOnce(() => Logger.error(message, ...logContent), `Logger.error: ${message}`);\n  }\n};\n\n// packages/ag-charts-community/src/util/time/interval.ts\nvar TimeInterval = class {\n  constructor(_encode, _decode, _rangeCallback) {\n    this._encode = _encode;\n    this._decode = _decode;\n    this._rangeCallback = _rangeCallback;\n  }\n  /**\n   * Returns a new date representing the latest interval boundary date before or equal to date.\n   * For example, `day.floor(date)` typically returns 12:00 AM local time on the given date.\n   * @param date\n   */\n  floor(date) {\n    const d = new Date(date);\n    const e = this._encode(d);\n    return this._decode(e);\n  }\n  /**\n   * Returns a new date representing the earliest interval boundary date after or equal to date.\n   * @param date\n   */\n  ceil(date) {\n    const d = new Date(Number(date) - 1);\n    const e = this._encode(d);\n    return this._decode(e + 1);\n  }\n  /**\n   * Returns an array of dates representing every interval boundary after or equal to start (inclusive) and before stop (exclusive).\n   * @param start Range start.\n   * @param stop Range end.\n   * @param extend If specified, the requested range will be extended to the closest \"nice\" values.\n   */\n  range(start2, stop, extend) {\n    const rangeCallback = this._rangeCallback?.(start2, stop);\n    const e0 = this._encode(extend ? this.floor(start2) : this.ceil(start2));\n    const e1 = this._encode(extend ? this.ceil(stop) : this.floor(stop));\n    if (e1 < e0) {\n      return [];\n    }\n    const range3 = [];\n    for (let e = e0; e <= e1; e++) {\n      const d = this._decode(e);\n      range3.push(d);\n    }\n    rangeCallback?.();\n    return range3;\n  }\n};\nvar CountableTimeInterval = class extends TimeInterval {\n  getOffset(snapTo, step) {\n    const s = typeof snapTo === \"number\" || snapTo instanceof Date ? this._encode(new Date(snapTo)) : 0;\n    return Math.floor(s) % step;\n  }\n  /**\n   * Returns a filtered view of this interval representing every step'th date.\n   * It can be a number of minutes, hours, days etc.\n   * Must be a positive integer.\n   * @param step\n   */\n  every(step, options) {\n    let offset4 = 0;\n    let rangeCallback;\n    const unsafeStep = step;\n    step = Math.max(1, Math.round(step));\n    if (unsafeStep !== step) {\n      Logger.warnOnce(`interval step of [${unsafeStep}] rounded to [${step}].`);\n    }\n    const { snapTo = \"start\" } = options ?? {};\n    if (typeof snapTo === \"string\") {\n      const initialOffset = offset4;\n      rangeCallback = (start2, stop) => {\n        const s = snapTo === \"start\" ? start2 : stop;\n        offset4 = this.getOffset(s, step);\n        return () => offset4 = initialOffset;\n      };\n    } else if (typeof snapTo === \"number\") {\n      offset4 = this.getOffset(new Date(snapTo), step);\n    } else if (snapTo instanceof Date) {\n      offset4 = this.getOffset(snapTo, step);\n    }\n    const encode13 = (date) => {\n      const e = this._encode(date);\n      return Math.floor((e - offset4) / step);\n    };\n    const decode13 = (encoded) => {\n      return this._decode(encoded * step + offset4);\n    };\n    return new TimeInterval(encode13, decode13, rangeCallback);\n  }\n};\n\n// packages/ag-charts-community/src/util/time/millisecond.ts\nfunction encode(date) {\n  return date.getTime();\n}\nfunction decode(encoded) {\n  return new Date(encoded);\n}\nvar millisecond = new CountableTimeInterval(encode, decode);\nvar millisecond_default = millisecond;\n\n// packages/ag-charts-community/src/util/time/duration.ts\nvar epochYear = (/* @__PURE__ */ new Date(0)).getFullYear();\nvar durationSecond = 1e3;\nvar durationMinute = durationSecond * 60;\nvar durationHour = durationMinute * 60;\nvar durationDay = durationHour * 24;\nvar durationWeek = durationDay * 7;\nvar durationMonth = durationDay * 30;\nvar durationYear = durationDay * 365;\n\n// packages/ag-charts-community/src/util/time/second.ts\nvar offset = (/* @__PURE__ */ new Date()).getTimezoneOffset() * durationMinute;\nfunction encode2(date) {\n  return Math.floor((date.getTime() - offset) / durationSecond);\n}\nfunction decode2(encoded) {\n  return new Date(offset + encoded * durationSecond);\n}\nvar second = new CountableTimeInterval(encode2, decode2);\nvar second_default = second;\n\n// packages/ag-charts-community/src/util/time/minute.ts\nvar offset2 = (/* @__PURE__ */ new Date()).getTimezoneOffset() * durationMinute;\nfunction encode3(date) {\n  return Math.floor((date.getTime() - offset2) / durationMinute);\n}\nfunction decode3(encoded) {\n  return new Date(offset2 + encoded * durationMinute);\n}\nvar minute = new CountableTimeInterval(encode3, decode3);\nvar minute_default = minute;\n\n// packages/ag-charts-community/src/util/time/hour.ts\nvar offset3 = (/* @__PURE__ */ new Date()).getTimezoneOffset() * durationMinute;\nfunction encode4(date) {\n  return Math.floor((date.getTime() - offset3) / durationHour);\n}\nfunction decode4(encoded) {\n  return new Date(offset3 + encoded * durationHour);\n}\nvar hour = new CountableTimeInterval(encode4, decode4);\nvar hour_default = hour;\n\n// packages/ag-charts-community/src/util/time/day.ts\nfunction encode5(date) {\n  const tzOffsetMs = date.getTimezoneOffset() * durationMinute;\n  return Math.floor((date.getTime() - tzOffsetMs) / durationDay);\n}\nfunction decode5(encoded) {\n  const d = new Date(1970, 0, 1);\n  d.setDate(d.getDate() + encoded);\n  return d;\n}\nvar day = new CountableTimeInterval(encode5, decode5);\nvar day_default = day;\n\n// packages/ag-charts-community/src/util/time/week.ts\nfunction weekday(weekStart) {\n  const thursday2 = 4;\n  const dayShift = (7 + weekStart - thursday2) % 7;\n  function encode13(date) {\n    const tzOffsetMs = date.getTimezoneOffset() * durationMinute;\n    return Math.floor((date.getTime() - tzOffsetMs) / durationWeek - dayShift / 7);\n  }\n  function decode13(encoded) {\n    const d = new Date(1970, 0, 1);\n    d.setDate(d.getDate() + encoded * 7 + dayShift);\n    return d;\n  }\n  return new CountableTimeInterval(encode13, decode13);\n}\nvar sunday = weekday(0);\nvar monday = weekday(1);\nvar tuesday = weekday(2);\nvar wednesday = weekday(3);\nvar thursday = weekday(4);\nvar friday = weekday(5);\nvar saturday = weekday(6);\nvar week_default = sunday;\n\n// packages/ag-charts-community/src/util/time/month.ts\nfunction encode6(date) {\n  return date.getFullYear() * 12 + date.getMonth();\n}\nfunction decode6(encoded) {\n  const year2 = Math.floor(encoded / 12);\n  const month2 = encoded - year2 * 12;\n  return new Date(year2, month2, 1);\n}\nvar month = new CountableTimeInterval(encode6, decode6);\nvar month_default = month;\n\n// packages/ag-charts-community/src/util/time/year.ts\nfunction encode7(date) {\n  return date.getFullYear();\n}\nfunction decode7(encoded) {\n  const d = /* @__PURE__ */ new Date();\n  d.setFullYear(encoded);\n  d.setMonth(0, 1);\n  d.setHours(0, 0, 0, 0);\n  return d;\n}\nvar year = new CountableTimeInterval(encode7, decode7);\nvar year_default = year;\n\n// packages/ag-charts-community/src/util/time/utcMinute.ts\nfunction encode8(date) {\n  return Math.floor(date.getTime() / durationMinute);\n}\nfunction decode8(encoded) {\n  return new Date(encoded * durationMinute);\n}\nvar utcMinute = new CountableTimeInterval(encode8, decode8);\n\n// packages/ag-charts-community/src/util/time/utcHour.ts\nfunction encode9(date) {\n  return Math.floor(date.getTime() / durationHour);\n}\nfunction decode9(encoded) {\n  return new Date(encoded * durationHour);\n}\nvar utcHour = new CountableTimeInterval(encode9, decode9);\n\n// packages/ag-charts-community/src/util/time/utcDay.ts\nfunction encode10(date) {\n  return Math.floor(date.getTime() / durationDay);\n}\nfunction decode10(encoded) {\n  const d = /* @__PURE__ */ new Date(0);\n  d.setUTCDate(d.getUTCDate() + encoded);\n  d.setUTCHours(0, 0, 0, 0);\n  return d;\n}\nvar utcDay = new CountableTimeInterval(encode10, decode10);\n\n// packages/ag-charts-community/src/util/time/utcMonth.ts\nfunction encode11(date) {\n  return date.getUTCFullYear() * 12 + date.getUTCMonth();\n}\nfunction decode11(encoded) {\n  const year2 = Math.floor(encoded / 12);\n  const month2 = encoded - year2 * 12;\n  return new Date(Date.UTC(year2, month2, 1));\n}\nvar utcMonth = new CountableTimeInterval(encode11, decode11);\n\n// packages/ag-charts-community/src/util/time/utcYear.ts\nfunction encode12(date) {\n  return date.getUTCFullYear();\n}\nfunction decode12(encoded) {\n  const d = /* @__PURE__ */ new Date();\n  d.setUTCFullYear(encoded);\n  d.setUTCMonth(0, 1);\n  d.setUTCHours(0, 0, 0, 0);\n  return d;\n}\nvar utcYear = new CountableTimeInterval(encode12, decode12);\n\n// packages/ag-charts-community/src/motion/fromToMotion.ts\nvar fromToMotion_exports = {};\n__export(fromToMotion_exports, {\n  NODE_UPDATE_STATE_TO_PHASE_MAPPING: () => NODE_UPDATE_STATE_TO_PHASE_MAPPING,\n  fromToMotion: () => fromToMotion,\n  staticFromToMotion: () => staticFromToMotion\n});\n\n// packages/ag-charts-community/src/util/id.ts\nvar ID_MAP = /* @__PURE__ */ new Map();\nfunction resetIds() {\n  ID_MAP.clear();\n}\nfunction createId(instance) {\n  const constructor = instance.constructor;\n  const className = Object.hasOwn(constructor, \"className\") ? constructor.className : constructor.name;\n  if (!className) {\n    throw new Error(`The ${constructor} is missing the 'className' property.`);\n  }\n  const nextId = (ID_MAP.get(className) ?? 0) + 1;\n  ID_MAP.set(className, nextId);\n  return `${className}-${nextId}`;\n}\nfunction generateUUID() {\n  return crypto.randomUUID?.() ?? generateUUIDv4();\n}\nfunction generateUUIDv4() {\n  const uuidArray = new Uint8Array(16);\n  crypto.getRandomValues(uuidArray);\n  uuidArray[6] = uuidArray[6] & 15 | 64;\n  uuidArray[8] = uuidArray[8] & 63 | 128;\n  let uuid = \"\";\n  for (let i = 0; i < uuidArray.length; i++) {\n    if (i === 4 || i === 6 || i === 8 || i === 10) {\n      uuid += \"-\";\n    }\n    uuid += uuidArray[i].toString(16).padStart(2, \"0\");\n  }\n  return uuid;\n}\n\n// packages/ag-charts-community/src/util/iterator.ts\nfunction* iterate(...iterators) {\n  for (const iterator of iterators) {\n    yield* iterator;\n  }\n}\nfunction toIterable(value) {\n  return value != null && typeof value === \"object\" && Symbol.iterator in value ? value : [value];\n}\n\n// packages/ag-charts-community/src/util/interpolating.ts\nvar interpolate = Symbol(\"interpolate\");\nvar isInterpolating = (x) => x[interpolate] != null;\n\n// packages/ag-charts-community/src/util/nearest.ts\nfunction nearestSquared(x, y, objects, maxDistanceSquared = Infinity) {\n  const result = { nearest: void 0, distanceSquared: maxDistanceSquared };\n  for (const obj of objects) {\n    const thisDistance = obj.distanceSquared(x, y);\n    if (thisDistance === 0) {\n      return { nearest: obj, distanceSquared: 0 };\n    } else if (thisDistance < result.distanceSquared) {\n      result.nearest = obj;\n      result.distanceSquared = thisDistance;\n    }\n  }\n  return result;\n}\nfunction nearestSquaredInContainer(x, y, container, maxDistanceSquared = Infinity) {\n  const { x: tx = x, y: ty = y } = container.transformPoint?.(x, y) ?? {};\n  const result = { nearest: void 0, distanceSquared: maxDistanceSquared };\n  for (const child of container.children) {\n    const { nearest, distanceSquared: distanceSquared3 } = child.nearestSquared(tx, ty, result.distanceSquared);\n    if (distanceSquared3 === 0) {\n      return { nearest, distanceSquared: distanceSquared3 };\n    } else if (distanceSquared3 < result.distanceSquared) {\n      result.nearest = nearest;\n      result.distanceSquared = distanceSquared3;\n    }\n  }\n  return result;\n}\n\n// packages/ag-charts-community/src/util/dom.ts\nvar verifiedGlobals = {};\nif (typeof window !== \"undefined\") {\n  verifiedGlobals.window = window;\n} else if (typeof global !== \"undefined\") {\n  verifiedGlobals.window = global.window;\n}\nif (typeof document !== \"undefined\") {\n  verifiedGlobals.document = document;\n} else if (typeof global !== \"undefined\") {\n  verifiedGlobals.document = global.document;\n}\nfunction getDocument(propertyName) {\n  return propertyName ? verifiedGlobals.document?.[propertyName] : verifiedGlobals.document;\n}\nfunction getWindow(propertyName) {\n  return propertyName ? verifiedGlobals.window?.[propertyName] : verifiedGlobals.window;\n}\nfunction createElement(tagName, className, style) {\n  const element2 = getDocument().createElement(tagName);\n  if (typeof className === \"object\") {\n    style = className;\n    className = void 0;\n  }\n  if (className) {\n    for (const name of className.split(\" \")) {\n      element2.classList.add(name);\n    }\n  }\n  if (style) {\n    Object.assign(element2.style, style);\n  }\n  return element2;\n}\nfunction createElementNS(namespaceURI, qualifiedName) {\n  return getDocument().createElementNS(namespaceURI, qualifiedName);\n}\nfunction downloadUrl(dataUrl, fileName) {\n  const { body } = getDocument();\n  const element2 = createElement(\"a\", { display: \"none\" });\n  element2.href = dataUrl;\n  element2.download = fileName;\n  body.appendChild(element2);\n  element2.click();\n  setTimeout(() => body.removeChild(element2));\n}\nfunction setDocument(document2) {\n  verifiedGlobals.document = document2;\n}\nfunction setWindow(window2) {\n  verifiedGlobals.window = window2;\n}\nfunction setElementBBox(element2, bbox) {\n  if (element2) {\n    element2.style.width = `${bbox.width}px`;\n    element2.style.height = `${bbox.height}px`;\n    element2.style.left = `${bbox.x}px`;\n    element2.style.top = `${bbox.y}px`;\n  }\n}\nfunction focusCursorAtEnd(element2) {\n  element2.focus({ preventScroll: true });\n  if (element2.lastChild?.textContent == null)\n    return;\n  const range3 = getDocument().createRange();\n  range3.setStart(element2.lastChild, element2.lastChild.textContent.length);\n  range3.setEnd(element2.lastChild, element2.lastChild.textContent.length);\n  const selection = getWindow().getSelection();\n  selection?.removeAllRanges();\n  selection?.addRange(range3);\n}\nvar _id = 0;\nfunction createElementId(label) {\n  return `${label ?? \"ag-charts-element\"}-${_id++}`;\n}\n\n// packages/ag-charts-community/src/util/number.ts\nfunction clamp(min, value, max) {\n  return Math.min(max, Math.max(min, value));\n}\nfunction clampArray(value, array2) {\n  const [min, max] = findMinMax(array2);\n  return clamp(min, value, max);\n}\nfunction findMinMax(array2) {\n  if (array2.length === 0)\n    return [];\n  const result = [Infinity, -Infinity];\n  for (const val of array2) {\n    if (val < result[0])\n      result[0] = val;\n    if (val > result[1])\n      result[1] = val;\n  }\n  return result;\n}\nfunction findRangeExtent(array2) {\n  const [min, max] = findMinMax(array2);\n  return max - min;\n}\nfunction isEqual(a, b, epsilon2 = 1e-10) {\n  return Math.abs(a - b) < epsilon2;\n}\nfunction isNegative(value) {\n  return Math.sign(value) === -1 || Object.is(value, -0);\n}\nfunction round(value, decimals = 2) {\n  const base = 10 ** decimals;\n  return Math.round(value * base) / base;\n}\nfunction toFixed(value, fractionOrSignificantDigits = 2) {\n  const power = Math.floor(Math.log(Math.abs(value)) / Math.LN10);\n  if (power >= 0 || !isFinite(power)) {\n    return value.toFixed(fractionOrSignificantDigits);\n  }\n  return value.toFixed(Math.abs(power) - 1 + fractionOrSignificantDigits);\n}\nfunction mod(n, m) {\n  return Math.floor(n % m + (n < 0 ? m : 0));\n}\nfunction countFractionDigits(value) {\n  if (Math.floor(value) === value)\n    return 0;\n  let valueString = String(value);\n  let exponent = 0;\n  if (value < 1e-6 || value >= 1e21) {\n    let exponentString;\n    [valueString, exponentString] = valueString.split(\"e\");\n    if (exponentString != null) {\n      exponent = Number(exponentString);\n    }\n  }\n  const decimalPlaces2 = valueString.split(\".\")[1]?.length ?? 0;\n  return Math.max(decimalPlaces2 - exponent, 0);\n}\nfunction formatNormalizedPercentage(ratio2, locale) {\n  locale = locale ?? getWindow(\"navigator\").language;\n  return new Intl.NumberFormat(locale, {\n    style: \"percent\",\n    minimumFractionDigits: 2,\n    maximumFractionDigits: 2\n  }).format(ratio2);\n}\nfunction formatPercentage(percent, locale) {\n  return formatNormalizedPercentage(percent / 100, locale);\n}\n\n// packages/ag-charts-community/src/scene/bbox.ts\nvar _BBox = class _BBox {\n  constructor(x, y, width2, height2) {\n    this.x = x;\n    this.y = y;\n    this.width = width2;\n    this.height = height2;\n  }\n  static fromDOMRect({ x, y, width: width2, height: height2 }) {\n    return new _BBox(x, y, width2, height2);\n  }\n  toDOMRect() {\n    return {\n      x: this.x,\n      y: this.y,\n      width: this.width,\n      height: this.height,\n      top: this.y,\n      left: this.x,\n      right: this.x + this.width,\n      bottom: this.y + this.height,\n      toJSON() {\n        return {};\n      }\n    };\n  }\n  clone() {\n    const { x, y, width: width2, height: height2 } = this;\n    return new _BBox(x, y, width2, height2);\n  }\n  equals(other) {\n    return this.x === other.x && this.y === other.y && this.width === other.width && this.height === other.height;\n  }\n  containsPoint(x, y) {\n    return x >= this.x && x <= this.x + this.width && y >= this.y && y <= this.y + this.height;\n  }\n  intersection(other) {\n    if (!this.collidesBBox(other))\n      return;\n    const newX1 = clamp(other.x, this.x, other.x + other.width);\n    const newY1 = clamp(other.y, this.y, other.y + other.height);\n    const newX2 = clamp(other.x, this.x + this.width, other.x + other.width);\n    const newY2 = clamp(other.y, this.y + this.height, other.y + other.height);\n    return new _BBox(newX1, newY1, newX2 - newX1, newY2 - newY1);\n  }\n  collidesBBox(other) {\n    return this.x < other.x + other.width && this.x + this.width > other.x && this.y < other.y + other.height && this.y + this.height > other.y;\n  }\n  computeCenter() {\n    return { x: this.x + this.width / 2, y: this.y + this.height / 2 };\n  }\n  isFinite() {\n    return Number.isFinite(this.x) && Number.isFinite(this.y) && Number.isFinite(this.width) && Number.isFinite(this.height);\n  }\n  distanceSquared(x, y) {\n    if (this.containsPoint(x, y)) {\n      return 0;\n    }\n    const dx = x - clamp(this.x, x, this.x + this.width);\n    const dy = y - clamp(this.y, y, this.y + this.height);\n    return dx * dx + dy * dy;\n  }\n  static nearestBox(x, y, boxes) {\n    return nearestSquared(x, y, boxes);\n  }\n  clip(clipRect) {\n    if (clipRect === void 0)\n      return this;\n    const x1 = Math.max(this.x, clipRect.x);\n    const y1 = Math.max(this.y, clipRect.y);\n    const x2 = Math.min(this.x + this.width, clipRect.x + clipRect.width);\n    const y2 = Math.min(this.y + this.height, clipRect.y + clipRect.height);\n    this.x = x1;\n    this.y = y1;\n    this.width = Math.max(0, x2 - x1);\n    this.height = Math.max(0, y2 - y1);\n    return this;\n  }\n  shrink(amount, position) {\n    const apply2 = (pos, amt) => {\n      switch (pos) {\n        case \"top\":\n          this.y += amt;\n        case \"bottom\":\n          this.height -= amt;\n          break;\n        case \"left\":\n          this.x += amt;\n        case \"right\":\n          this.width -= amt;\n          break;\n        case \"vertical\":\n          this.y += amt;\n          this.height -= amt * 2;\n          break;\n        case \"horizontal\":\n          this.x += amt;\n          this.width -= amt * 2;\n          break;\n        case void 0:\n          this.x += amt;\n          this.width -= amt * 2;\n          this.y += amt;\n          this.height -= amt * 2;\n          break;\n        default:\n      }\n    };\n    if (typeof amount === \"number\") {\n      apply2(position, amount);\n    } else if (typeof amount === \"object\") {\n      Object.entries(amount).forEach(([pos, amt]) => apply2(pos, amt));\n    }\n    return this;\n  }\n  grow(amount, position) {\n    if (typeof amount === \"number\") {\n      this.shrink(-amount, position);\n    } else {\n      const paddingCopy = { ...amount };\n      for (const key in paddingCopy) {\n        paddingCopy[key] *= -1;\n      }\n      this.shrink(paddingCopy);\n    }\n    return this;\n  }\n  translate(x, y) {\n    this.x += x;\n    this.y += y;\n    return this;\n  }\n  combine(other) {\n    const { x, y, width: width2, height: height2 } = this;\n    this.x = Math.min(x, other.x);\n    this.y = Math.min(y, other.y);\n    this.width = Math.max(x + width2, other.x + other.width) - this.x;\n    this.height = Math.max(y + height2, other.y + other.height) - this.y;\n  }\n  static merge(boxes) {\n    let left = Infinity;\n    let top = Infinity;\n    let right = -Infinity;\n    let bottom = -Infinity;\n    for (const box of boxes) {\n      if (box.x < left) {\n        left = box.x;\n      }\n      if (box.y < top) {\n        top = box.y;\n      }\n      if (box.x + box.width > right) {\n        right = box.x + box.width;\n      }\n      if (box.y + box.height > bottom) {\n        bottom = box.y + box.height;\n      }\n    }\n    return new _BBox(left, top, right - left, bottom - top);\n  }\n  [interpolate](other, d) {\n    return new _BBox(\n      this.x * (1 - d) + other.x * d,\n      this.y * (1 - d) + other.y * d,\n      this.width * (1 - d) + other.width * d,\n      this.height * (1 - d) + other.height * d\n    );\n  }\n};\n_BBox.zero = Object.freeze(new _BBox(0, 0, 0, 0));\n_BBox.NaN = Object.freeze(new _BBox(NaN, NaN, NaN, NaN));\nvar BBox = _BBox;\n\n// packages/ag-charts-community/src/scene/changeDetectable.ts\nvar RedrawType = /* @__PURE__ */ ((RedrawType2) => {\n  RedrawType2[RedrawType2[\"NONE\"] = 0] = \"NONE\";\n  RedrawType2[RedrawType2[\"TRIVIAL\"] = 1] = \"TRIVIAL\";\n  RedrawType2[RedrawType2[\"MINOR\"] = 2] = \"MINOR\";\n  RedrawType2[RedrawType2[\"MAJOR\"] = 3] = \"MAJOR\";\n  return RedrawType2;\n})(RedrawType || {});\nfunction SceneChangeDetection(opts) {\n  return function(target, key) {\n    const privateKey = `__${key}`;\n    if (target[key]) {\n      return;\n    }\n    prepareGetSet(target, key, privateKey, opts);\n  };\n}\nfunction prepareGetSet(target, key, privateKey, opts) {\n  const {\n    redraw = 1 /* TRIVIAL */,\n    type = \"normal\",\n    changeCb,\n    convertor,\n    checkDirtyOnAssignment = false\n  } = opts ?? {};\n  const requiredOpts = { redraw, type, changeCb, checkDirtyOnAssignment, convertor };\n  let setter;\n  switch (type) {\n    case \"normal\":\n      setter = buildNormalSetter(privateKey, requiredOpts);\n      break;\n    case \"transform\":\n      setter = buildTransformSetter(privateKey, requiredOpts);\n      break;\n    case \"path\":\n      setter = buildPathSetter(privateKey, requiredOpts);\n      break;\n  }\n  setter = buildCheckDirtyChain(\n    buildChangeCallbackChain(buildConvertorChain(setter, requiredOpts), requiredOpts),\n    requiredOpts\n  );\n  const getter = function() {\n    return this[privateKey];\n  };\n  Object.defineProperty(target, key, {\n    set: setter,\n    get: getter,\n    enumerable: true,\n    configurable: true\n  });\n}\nfunction buildConvertorChain(setterFn, opts) {\n  const { convertor } = opts;\n  if (convertor) {\n    return function(value) {\n      setterFn.call(this, convertor(value));\n    };\n  }\n  return setterFn;\n}\nvar NO_CHANGE = Symbol(\"no-change\");\nfunction buildChangeCallbackChain(setterFn, opts) {\n  const { changeCb } = opts;\n  if (changeCb) {\n    return function(value) {\n      const change = setterFn.call(this, value);\n      if (change !== NO_CHANGE) {\n        changeCb.call(this, this);\n      }\n      return change;\n    };\n  }\n  return setterFn;\n}\nfunction buildCheckDirtyChain(setterFn, opts) {\n  const { checkDirtyOnAssignment } = opts;\n  if (checkDirtyOnAssignment) {\n    return function(value) {\n      const change = setterFn.call(this, value);\n      if (change !== NO_CHANGE && value != null && value._dirty > 0 /* NONE */) {\n        this.markDirty(value._dirty);\n      }\n      return change;\n    };\n  }\n  return setterFn;\n}\nfunction buildNormalSetter(privateKey, opts) {\n  const { redraw = 1 /* TRIVIAL */, changeCb } = opts;\n  return function(value) {\n    const oldValue = this[privateKey];\n    if (value !== oldValue) {\n      this[privateKey] = value;\n      this.markDirty(redraw);\n      changeCb?.(this);\n      return value;\n    }\n    return NO_CHANGE;\n  };\n}\nfunction buildTransformSetter(privateKey, opts) {\n  const { redraw = 1 /* TRIVIAL */ } = opts;\n  return function(value) {\n    const oldValue = this[privateKey];\n    if (value !== oldValue) {\n      this[privateKey] = value;\n      this.markDirtyTransform(redraw);\n      return value;\n    }\n    return NO_CHANGE;\n  };\n}\nfunction buildPathSetter(privateKey, opts) {\n  const { redraw = 1 /* TRIVIAL */ } = opts;\n  return function(value) {\n    const oldValue = this[privateKey];\n    if (value !== oldValue) {\n      this[privateKey] = value;\n      if (!this._dirtyPath) {\n        this._dirtyPath = true;\n        this.markDirty(redraw);\n      }\n      return value;\n    }\n    return NO_CHANGE;\n  };\n}\n\n// packages/ag-charts-community/src/scene/node.ts\nvar PointerEvents = /* @__PURE__ */ ((PointerEvents2) => {\n  PointerEvents2[PointerEvents2[\"All\"] = 0] = \"All\";\n  PointerEvents2[PointerEvents2[\"None\"] = 1] = \"None\";\n  return PointerEvents2;\n})(PointerEvents || {});\nvar _Node = class _Node {\n  // Discriminators for render order within a zIndex\n  constructor(options) {\n    /** Unique number to allow creation order to be easily determined. */\n    this.serialNumber = _Node._nextSerialNumber++;\n    this.childNodeCounts = { groups: 0, nonGroups: 0 };\n    /** Unique node ID in the form `ClassName-NaturalNumber`. */\n    this.id = createId(this);\n    this.pointerEvents = 0 /* All */;\n    this._dirty = 3 /* MAJOR */;\n    this.dirtyZIndex = false;\n    this.virtualChildrenCount = 0;\n    /**\n     * To simplify the type system (especially in Selections) we don't have the `Parent` node\n     * (one that has children). Instead, we mimic HTML DOM, where any node can have children.\n     * But we still need to distinguish regular leaf nodes from container leafs somehow.\n     */\n    this.isContainerNode = false;\n    this.visible = true;\n    this.zIndex = 0;\n    this.zIndexSubOrder = void 0;\n    this.name = options?.name;\n    this.isVirtual = options?.isVirtual ?? false;\n    this.tag = options?.tag ?? NaN;\n    this.zIndex = options?.zIndex ?? 0;\n  }\n  static *extractBBoxes(nodes, skipInvisible) {\n    for (const n of nodes) {\n      if (!skipInvisible || n.visible && !n.transitionOut) {\n        const bbox = n.getBBox();\n        if (bbox)\n          yield bbox;\n      }\n    }\n  }\n  /**\n   * Some arbitrary data bound to the node.\n   */\n  get datum() {\n    return this._datum ?? this.parentNode?.datum;\n  }\n  set datum(datum) {\n    if (this._datum !== datum) {\n      this._previousDatum = this._datum;\n      this._datum = datum;\n    }\n  }\n  get previousDatum() {\n    return this._previousDatum;\n  }\n  get layerManager() {\n    return this._layerManager;\n  }\n  get dirty() {\n    return this._dirty;\n  }\n  /** Perform any pre-rendering initialization. */\n  preRender() {\n    this.childNodeCounts.groups = 0;\n    this.childNodeCounts.nonGroups = 1;\n    for (const child of this.children()) {\n      const childCounts = child.preRender();\n      this.childNodeCounts.groups += childCounts.groups;\n      this.childNodeCounts.nonGroups += childCounts.nonGroups;\n    }\n    return this.childNodeCounts;\n  }\n  render(renderCtx) {\n    const { stats } = renderCtx;\n    this._dirty = 0 /* NONE */;\n    if (renderCtx.debugNodeSearch) {\n      const idOrName = this.name ?? this.id;\n      if (renderCtx.debugNodeSearch.some((v) => typeof v === \"string\" ? v === idOrName : v.test(idOrName))) {\n        renderCtx.debugNodes[this.name ?? this.id] = this;\n      }\n    }\n    if (stats) {\n      stats.nodesRendered++;\n    }\n  }\n  _setLayerManager(value) {\n    this._layerManager = value;\n    this._debug = value?.debug;\n    for (const child of this.children(false)) {\n      child._setLayerManager(value);\n    }\n  }\n  sortChildren(compareFn) {\n    this.dirtyZIndex = false;\n    if (!this.childNodes)\n      return;\n    if (this.hasVirtualChildren())\n      return;\n    const sortedChildren = [...this.childNodes].sort(compareFn);\n    this.childNodes.clear();\n    for (const child of sortedChildren) {\n      this.childNodes.add(child);\n    }\n  }\n  *traverseUp(includeSelf) {\n    let node = this;\n    if (includeSelf) {\n      yield node;\n    }\n    while (node = node.parentNode) {\n      yield node;\n    }\n  }\n  *children(flattenVirtual = true) {\n    if (!this.childNodes)\n      return;\n    const virtualChildren = [];\n    for (const child of this.childNodes) {\n      if (flattenVirtual && child.isVirtual) {\n        virtualChildren.push(child.children());\n      } else {\n        yield child;\n      }\n    }\n    for (const vChildren of virtualChildren) {\n      yield* vChildren;\n    }\n  }\n  *virtualChildren() {\n    if (!this.childNodes || !this.virtualChildrenCount)\n      return;\n    for (const child of this.childNodes) {\n      if (child.isVirtual) {\n        yield child;\n      }\n    }\n  }\n  hasVirtualChildren() {\n    return this.virtualChildrenCount > 0;\n  }\n  /**\n   * Checks if the node is a leaf (has no children).\n   */\n  isLeaf() {\n    return !this.childNodes?.size;\n  }\n  /**\n   * Checks if the node is the root (has no parent).\n   */\n  isRoot() {\n    return !this.parentNode;\n  }\n  /**\n   * Appends one or more new node instances to this parent.\n   * If one needs to:\n   * - move a child to the end of the list of children\n   * - move a child from one parent to another (including parents in other scenes)\n   * one should use the {@link insertBefore} method instead.\n   * @param nodes A node or nodes to append.\n   */\n  append(nodes) {\n    this.childNodes ?? (this.childNodes = /* @__PURE__ */ new Set());\n    for (const node of toIterable(nodes)) {\n      node.parentNode?.removeChild(node);\n      this.childNodes.add(node);\n      node.parentNode = this;\n      node._setLayerManager(this.layerManager);\n      if (node.isVirtual) {\n        this.virtualChildrenCount++;\n      }\n    }\n    this.invalidateCachedBBox();\n    this.dirtyZIndex = true;\n    this.markDirty(3 /* MAJOR */);\n  }\n  appendChild(node) {\n    this.append(node);\n    return node;\n  }\n  removeChild(node) {\n    if (!this.childNodes?.delete(node)) {\n      return false;\n    }\n    delete node.parentNode;\n    node._setLayerManager();\n    if (node.isVirtual) {\n      this.virtualChildrenCount--;\n    }\n    this.invalidateCachedBBox();\n    this.dirtyZIndex = true;\n    this.markDirty(3 /* MAJOR */);\n    return true;\n  }\n  remove() {\n    return this.parentNode?.removeChild(this) ?? false;\n  }\n  clear() {\n    for (const child of this.children(false)) {\n      delete child.parentNode;\n      child._setLayerManager();\n    }\n    this.childNodes?.clear();\n    this.invalidateCachedBBox();\n    this.virtualChildrenCount = 0;\n  }\n  destroy() {\n    this.parentNode?.removeChild(this);\n  }\n  setProperties(styles, pickKeys) {\n    if (pickKeys) {\n      for (const key of pickKeys) {\n        this[key] = styles[key];\n      }\n    } else {\n      Object.assign(this, styles);\n    }\n    return this;\n  }\n  containsPoint(_x, _y) {\n    return false;\n  }\n  /**\n   * Hit testing method.\n   * Recursively checks if the given point is inside this node or any of its children.\n   * Returns the first matching node or `undefined`.\n   * Nodes that render later (show on top) are hit tested first.\n   */\n  pickNode(x, y, _localCoords = false) {\n    if (!this.visible || this.pointerEvents === 1 /* None */ || !this.containsPoint(x, y)) {\n      return;\n    }\n    const children = [...this.children()];\n    if (children.length > 1e3) {\n      for (let i = children.length - 1; i >= 0; i--) {\n        const child = children[i];\n        const containsPoint2 = child.containsPoint(x, y);\n        const hit = containsPoint2 ? child.pickNode(x, y) : void 0;\n        if (hit) {\n          return hit;\n        }\n      }\n    } else if (children.length) {\n      for (let i = children.length - 1; i >= 0; i--) {\n        const hit = children[i].pickNode(x, y);\n        if (hit) {\n          return hit;\n        }\n      }\n    } else if (!this.isContainerNode) {\n      return this;\n    }\n  }\n  invalidateCachedBBox() {\n    this.cachedBBox = void 0;\n    this.parentNode?.invalidateCachedBBox();\n  }\n  getBBox() {\n    if (this.cachedBBox == null) {\n      this.cachedBBox = Object.freeze(this.computeBBox());\n    }\n    return this.cachedBBox;\n  }\n  computeBBox() {\n    return;\n  }\n  markDirty(type = 1 /* TRIVIAL */, parentType = type) {\n    const { _dirty } = this;\n    const dirtyTypeBelowHighWatermark = _dirty > type || _dirty === type && type === parentType;\n    const noParentCachedBBox = this.cachedBBox == null;\n    if (noParentCachedBBox && dirtyTypeBelowHighWatermark)\n      return;\n    this.invalidateCachedBBox();\n    this._dirty = Math.max(_dirty, type);\n    if (this.parentNode) {\n      this.parentNode.markDirty(parentType);\n    } else if (this.layerManager) {\n      this.layerManager.markDirty();\n    }\n  }\n  markClean(opts) {\n    const { force = false, recursive = true } = opts ?? {};\n    if (this._dirty === 0 /* NONE */ && !force)\n      return;\n    this._dirty = 0 /* NONE */;\n    for (const child of this.children(false)) {\n      if (child.isVirtual ? recursive !== false : recursive === true) {\n        child.markClean({ force });\n      }\n    }\n  }\n  onVisibleChange() {\n  }\n  onZIndexChange() {\n    if (this.parentNode) {\n      this.parentNode.dirtyZIndex = true;\n    }\n  }\n  toSVG() {\n    return;\n  }\n};\n_Node._nextSerialNumber = 0;\n__decorateClass([\n  SceneChangeDetection({\n    redraw: 3 /* MAJOR */,\n    changeCb: (target) => target.onVisibleChange()\n  })\n], _Node.prototype, \"visible\", 2);\n__decorateClass([\n  SceneChangeDetection({\n    redraw: 1 /* TRIVIAL */,\n    changeCb: (target) => target.onZIndexChange()\n  })\n], _Node.prototype, \"zIndex\", 2);\n__decorateClass([\n  SceneChangeDetection({\n    redraw: 1 /* TRIVIAL */,\n    changeCb: (target) => target.onZIndexChange()\n  })\n], _Node.prototype, \"zIndexSubOrder\", 2);\nvar Node = _Node;\n\n// packages/ag-charts-community/src/util/color.ts\nvar lerp = (x, y, t) => x * (1 - t) + y * t;\nvar srgbToLinear = (value) => {\n  const sign = value < 0 ? -1 : 1;\n  const abs = Math.abs(value);\n  if (abs <= 0.04045)\n    return value / 12.92;\n  return sign * ((abs + 0.055) / 1.055) ** 2.4;\n};\nvar srgbFromLinear = (value) => {\n  const sign = value < 0 ? -1 : 1;\n  const abs = Math.abs(value);\n  if (abs > 31308e-7) {\n    return sign * (1.055 * abs ** (1 / 2.4) - 0.055);\n  }\n  return 12.92 * value;\n};\nvar _Color = class _Color {\n  /**\n   * Every color component should be in the [0, 1] range.\n   * Some easing functions (such as elastic easing) can overshoot the target value by some amount.\n   * So, when animating colors, if the source or target color components are already near\n   * or at the edge of the allowed [0, 1] range, it is possible for the intermediate color\n   * component value to end up outside of that range mid-animation. For this reason the constructor\n   * performs range checking/constraining.\n   * @param r Red component.\n   * @param g Green component.\n   * @param b Blue component.\n   * @param a Alpha (opacity) component.\n   */\n  constructor(r, g, b, a = 1) {\n    this.r = clamp(0, r || 0, 1);\n    this.g = clamp(0, g || 0, 1);\n    this.b = clamp(0, b || 0, 1);\n    this.a = clamp(0, a || 0, 1);\n  }\n  /**\n   * A color string can be in one of the following formats to be valid:\n   * - #rgb\n   * - #rrggbb\n   * - rgb(r, g, b)\n   * - rgba(r, g, b, a)\n   * - CSS color name such as 'white', 'orange', 'cyan', etc.\n   */\n  static validColorString(str) {\n    if (str.indexOf(\"#\") >= 0) {\n      return !!_Color.parseHex(str);\n    }\n    if (str.indexOf(\"rgb\") >= 0) {\n      return !!_Color.stringToRgba(str);\n    }\n    return !!_Color.nameToHex[str.toLowerCase()];\n  }\n  /**\n   * The given string can be in one of the following formats:\n   * - #rgb\n   * - #rrggbb\n   * - rgb(r, g, b)\n   * - rgba(r, g, b, a)\n   * - CSS color name such as 'white', 'orange', 'cyan', etc.\n   * @param str\n   */\n  static fromString(str) {\n    if (str.indexOf(\"#\") >= 0) {\n      return _Color.fromHexString(str);\n    }\n    const hex = _Color.nameToHex[str.toLowerCase()];\n    if (hex) {\n      return _Color.fromHexString(hex);\n    }\n    if (str.indexOf(\"rgb\") >= 0) {\n      return _Color.fromRgbaString(str);\n    }\n    throw new Error(`Invalid color string: '${str}'`);\n  }\n  // See https://drafts.csswg.org/css-color/#hex-notation\n  static parseHex(input) {\n    input = input.replace(/ /g, \"\").slice(1);\n    let parts;\n    switch (input.length) {\n      case 6:\n      case 8:\n        parts = [];\n        for (let i = 0; i < input.length; i += 2) {\n          parts.push(parseInt(`${input[i]}${input[i + 1]}`, 16));\n        }\n        break;\n      case 3:\n      case 4:\n        parts = input.split(\"\").map((p) => parseInt(p, 16)).map((p) => p + p * 16);\n        break;\n    }\n    if (parts?.length >= 3 && parts.every((p) => p >= 0)) {\n      if (parts.length === 3) {\n        parts.push(255);\n      }\n      return parts;\n    }\n  }\n  static fromHexString(str) {\n    const values = _Color.parseHex(str);\n    if (values) {\n      const [r, g, b, a] = values;\n      return new _Color(r / 255, g / 255, b / 255, a / 255);\n    }\n    throw new Error(`Malformed hexadecimal color string: '${str}'`);\n  }\n  static stringToRgba(str) {\n    let po = -1;\n    let pc = -1;\n    for (let i = 0; i < str.length; i++) {\n      const c = str[i];\n      if (po === -1 && c === \"(\") {\n        po = i;\n      } else if (c === \")\") {\n        pc = i;\n        break;\n      }\n    }\n    if (po === -1 || pc === -1)\n      return;\n    const contents = str.substring(po + 1, pc);\n    const parts = contents.split(\",\");\n    const rgba = [];\n    for (let i = 0; i < parts.length; i++) {\n      const part = parts[i];\n      let value = parseFloat(part);\n      if (!Number.isFinite(value)) {\n        return;\n      }\n      if (part.indexOf(\"%\") >= 0) {\n        value = clamp(0, value, 100);\n        value /= 100;\n      } else if (i === 3) {\n        value = clamp(0, value, 1);\n      } else {\n        value = clamp(0, value, 255);\n        value /= 255;\n      }\n      rgba.push(value);\n    }\n    return rgba;\n  }\n  static fromRgbaString(str) {\n    const rgba = _Color.stringToRgba(str);\n    if (rgba) {\n      if (rgba.length === 3) {\n        return new _Color(rgba[0], rgba[1], rgba[2]);\n      } else if (rgba.length === 4) {\n        return new _Color(rgba[0], rgba[1], rgba[2], rgba[3]);\n      }\n    }\n    throw new Error(`Malformed rgb/rgba color string: '${str}'`);\n  }\n  static fromArray(arr) {\n    if (arr.length === 4) {\n      return new _Color(arr[0], arr[1], arr[2], arr[3]);\n    }\n    if (arr.length === 3) {\n      return new _Color(arr[0], arr[1], arr[2]);\n    }\n    throw new Error(\"The given array should contain 3 or 4 color components (numbers).\");\n  }\n  static fromHSB(h, s, b, alpha = 1) {\n    const rgb = _Color.HSBtoRGB(h, s, b);\n    return new _Color(rgb[0], rgb[1], rgb[2], alpha);\n  }\n  static fromHSL(h, s, l, alpha = 1) {\n    const rgb = _Color.HSLtoRGB(h, s, l);\n    return new _Color(rgb[0], rgb[1], rgb[2], alpha);\n  }\n  static fromOKLCH(l, c, h, alpha = 1) {\n    const rgb = _Color.OKLCHtoRGB(l, c, h);\n    return new _Color(rgb[0], rgb[1], rgb[2], alpha);\n  }\n  static padHex(str) {\n    return str.length === 1 ? \"0\" + str : str;\n  }\n  toHexString() {\n    let hex = \"#\" + _Color.padHex(Math.round(this.r * 255).toString(16)) + _Color.padHex(Math.round(this.g * 255).toString(16)) + _Color.padHex(Math.round(this.b * 255).toString(16));\n    if (this.a < 1) {\n      hex += _Color.padHex(Math.round(this.a * 255).toString(16));\n    }\n    return hex;\n  }\n  toRgbaString(fractionDigits = 3) {\n    const components = [Math.round(this.r * 255), Math.round(this.g * 255), Math.round(this.b * 255)];\n    const k = Math.pow(10, fractionDigits);\n    if (this.a !== 1) {\n      components.push(Math.round(this.a * k) / k);\n      return `rgba(${components.join(\", \")})`;\n    }\n    return `rgb(${components.join(\", \")})`;\n  }\n  toString() {\n    if (this.a === 1) {\n      return this.toHexString();\n    }\n    return this.toRgbaString();\n  }\n  toHSB() {\n    return _Color.RGBtoHSB(this.r, this.g, this.b);\n  }\n  static RGBtoOKLCH(r, g, b) {\n    const LSRGB0 = srgbToLinear(r);\n    const LSRGB1 = srgbToLinear(g);\n    const LSRGB2 = srgbToLinear(b);\n    const LMS0 = Math.cbrt(0.4122214708 * LSRGB0 + 0.5363325363 * LSRGB1 + 0.0514459929 * LSRGB2);\n    const LMS1 = Math.cbrt(0.2119034982 * LSRGB0 + 0.6806995451 * LSRGB1 + 0.1073969566 * LSRGB2);\n    const LMS2 = Math.cbrt(0.0883024619 * LSRGB0 + 0.2817188376 * LSRGB1 + 0.6299787005 * LSRGB2);\n    const OKLAB0 = 0.2104542553 * LMS0 + 0.793617785 * LMS1 - 0.0040720468 * LMS2;\n    const OKLAB1 = 1.9779984951 * LMS0 - 2.428592205 * LMS1 + 0.4505937099 * LMS2;\n    const OKLAB2 = 0.0259040371 * LMS0 + 0.7827717662 * LMS1 - 0.808675766 * LMS2;\n    const hue = Math.atan2(OKLAB2, OKLAB1) * 180 / Math.PI;\n    const OKLCH0 = OKLAB0;\n    const OKLCH1 = Math.hypot(OKLAB1, OKLAB2);\n    const OKLCH2 = hue >= 0 ? hue : hue + 360;\n    return [OKLCH0, OKLCH1, OKLCH2];\n  }\n  static OKLCHtoRGB(l, c, h) {\n    const OKLAB0 = l;\n    const OKLAB1 = c * Math.cos(h * Math.PI / 180);\n    const OKLAB2 = c * Math.sin(h * Math.PI / 180);\n    const LMS0 = (OKLAB0 + 0.3963377774 * OKLAB1 + 0.2158037573 * OKLAB2) ** 3;\n    const LMS1 = (OKLAB0 - 0.1055613458 * OKLAB1 - 0.0638541728 * OKLAB2) ** 3;\n    const LMS2 = (OKLAB0 - 0.0894841775 * OKLAB1 - 1.291485548 * OKLAB2) ** 3;\n    const LSRGB0 = 4.0767416621 * LMS0 - 3.3077115913 * LMS1 + 0.2309699292 * LMS2;\n    const LSRGB1 = -1.2684380046 * LMS0 + 2.6097574011 * LMS1 - 0.3413193965 * LMS2;\n    const LSRGB2 = -0.0041960863 * LMS0 - 0.7034186147 * LMS1 + 1.707614701 * LMS2;\n    const SRGB0 = srgbFromLinear(LSRGB0);\n    const SRGB1 = srgbFromLinear(LSRGB1);\n    const SRGB2 = srgbFromLinear(LSRGB2);\n    return [SRGB0, SRGB1, SRGB2];\n  }\n  static RGBtoHSL(r, g, b) {\n    const min = Math.min(r, g, b);\n    const max = Math.max(r, g, b);\n    const l = (max + min) / 2;\n    let h;\n    let s;\n    if (max === min) {\n      h = 0;\n      s = 0;\n    } else {\n      const delta4 = max - min;\n      s = l > 0.5 ? delta4 / (2 - max - min) : delta4 / (max + min);\n      if (max === r) {\n        h = (g - b) / delta4 + (g < b ? 6 : 0);\n      } else if (max === g) {\n        h = (b - r) / delta4 + 2;\n      } else {\n        h = (r - g) / delta4 + 4;\n      }\n      h *= 360 / 6;\n    }\n    return [h, s, l];\n  }\n  static HSLtoRGB(h, s, l) {\n    h = (h % 360 + 360) % 360;\n    if (s === 0) {\n      return [l, l, l];\n    }\n    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n    const p = 2 * l - q;\n    function hueToRgb(t) {\n      if (t < 0)\n        t += 1;\n      if (t > 1)\n        t -= 1;\n      if (t < 1 / 6)\n        return p + (q - p) * 6 * t;\n      if (t < 1 / 2)\n        return q;\n      if (t < 2 / 3)\n        return p + (q - p) * (2 / 3 - t) * 6;\n      return p;\n    }\n    const r = hueToRgb(h / 360 + 1 / 3);\n    const g = hueToRgb(h / 360);\n    const b = hueToRgb(h / 360 - 1 / 3);\n    return [r, g, b];\n  }\n  /**\n   * Converts the given RGB triple to an array of HSB (HSV) components.\n   */\n  static RGBtoHSB(r, g, b) {\n    const min = Math.min(r, g, b);\n    const max = Math.max(r, g, b);\n    const S = max === 0 ? 0 : (max - min) / max;\n    let H = 0;\n    if (min !== max) {\n      const delta4 = max - min;\n      const rc = (max - r) / delta4;\n      const gc = (max - g) / delta4;\n      const bc = (max - b) / delta4;\n      if (r === max) {\n        H = bc - gc;\n      } else if (g === max) {\n        H = 2 + rc - bc;\n      } else {\n        H = 4 + gc - rc;\n      }\n      H /= 6;\n      if (H < 0) {\n        H = H + 1;\n      }\n    }\n    return [H * 360, S, max];\n  }\n  /**\n   * Converts the given HSB (HSV) triple to an array of RGB components.\n   */\n  static HSBtoRGB(H, S, B) {\n    H = (H % 360 + 360) % 360 / 360;\n    let r = 0;\n    let g = 0;\n    let b = 0;\n    if (S === 0) {\n      r = g = b = B;\n    } else {\n      const h = (H - Math.floor(H)) * 6;\n      const f = h - Math.floor(h);\n      const p = B * (1 - S);\n      const q = B * (1 - S * f);\n      const t = B * (1 - S * (1 - f));\n      switch (h >> 0) {\n        case 0:\n          r = B;\n          g = t;\n          b = p;\n          break;\n        case 1:\n          r = q;\n          g = B;\n          b = p;\n          break;\n        case 2:\n          r = p;\n          g = B;\n          b = t;\n          break;\n        case 3:\n          r = p;\n          g = q;\n          b = B;\n          break;\n        case 4:\n          r = t;\n          g = p;\n          b = B;\n          break;\n        case 5:\n          r = B;\n          g = p;\n          b = q;\n          break;\n      }\n    }\n    return [r, g, b];\n  }\n  static mix(c0, c1, t) {\n    return new _Color(lerp(c0.r, c1.r, t), lerp(c0.g, c1.g, t), lerp(c0.b, c1.b, t), lerp(c0.a, c1.a, t));\n  }\n};\n/**\n * CSS Color Module Level 4:\n * https://drafts.csswg.org/css-color/#named-colors\n */\n_Color.nameToHex = {\n  // @ts-expect-error\n  __proto__: null,\n  aliceblue: \"#F0F8FF\",\n  antiquewhite: \"#FAEBD7\",\n  aqua: \"#00FFFF\",\n  aquamarine: \"#7FFFD4\",\n  azure: \"#F0FFFF\",\n  beige: \"#F5F5DC\",\n  bisque: \"#FFE4C4\",\n  black: \"#000000\",\n  blanchedalmond: \"#FFEBCD\",\n  blue: \"#0000FF\",\n  blueviolet: \"#8A2BE2\",\n  brown: \"#A52A2A\",\n  burlywood: \"#DEB887\",\n  cadetblue: \"#5F9EA0\",\n  chartreuse: \"#7FFF00\",\n  chocolate: \"#D2691E\",\n  coral: \"#FF7F50\",\n  cornflowerblue: \"#6495ED\",\n  cornsilk: \"#FFF8DC\",\n  crimson: \"#DC143C\",\n  cyan: \"#00FFFF\",\n  darkblue: \"#00008B\",\n  darkcyan: \"#008B8B\",\n  darkgoldenrod: \"#B8860B\",\n  darkgray: \"#A9A9A9\",\n  darkgreen: \"#006400\",\n  darkgrey: \"#A9A9A9\",\n  darkkhaki: \"#BDB76B\",\n  darkmagenta: \"#8B008B\",\n  darkolivegreen: \"#556B2F\",\n  darkorange: \"#FF8C00\",\n  darkorchid: \"#9932CC\",\n  darkred: \"#8B0000\",\n  darksalmon: \"#E9967A\",\n  darkseagreen: \"#8FBC8F\",\n  darkslateblue: \"#483D8B\",\n  darkslategray: \"#2F4F4F\",\n  darkslategrey: \"#2F4F4F\",\n  darkturquoise: \"#00CED1\",\n  darkviolet: \"#9400D3\",\n  deeppink: \"#FF1493\",\n  deepskyblue: \"#00BFFF\",\n  dimgray: \"#696969\",\n  dimgrey: \"#696969\",\n  dodgerblue: \"#1E90FF\",\n  firebrick: \"#B22222\",\n  floralwhite: \"#FFFAF0\",\n  forestgreen: \"#228B22\",\n  fuchsia: \"#FF00FF\",\n  gainsboro: \"#DCDCDC\",\n  ghostwhite: \"#F8F8FF\",\n  gold: \"#FFD700\",\n  goldenrod: \"#DAA520\",\n  gray: \"#808080\",\n  green: \"#008000\",\n  greenyellow: \"#ADFF2F\",\n  grey: \"#808080\",\n  honeydew: \"#F0FFF0\",\n  hotpink: \"#FF69B4\",\n  indianred: \"#CD5C5C\",\n  indigo: \"#4B0082\",\n  ivory: \"#FFFFF0\",\n  khaki: \"#F0E68C\",\n  lavender: \"#E6E6FA\",\n  lavenderblush: \"#FFF0F5\",\n  lawngreen: \"#7CFC00\",\n  lemonchiffon: \"#FFFACD\",\n  lightblue: \"#ADD8E6\",\n  lightcoral: \"#F08080\",\n  lightcyan: \"#E0FFFF\",\n  lightgoldenrodyellow: \"#FAFAD2\",\n  lightgray: \"#D3D3D3\",\n  lightgreen: \"#90EE90\",\n  lightgrey: \"#D3D3D3\",\n  lightpink: \"#FFB6C1\",\n  lightsalmon: \"#FFA07A\",\n  lightseagreen: \"#20B2AA\",\n  lightskyblue: \"#87CEFA\",\n  lightslategray: \"#778899\",\n  lightslategrey: \"#778899\",\n  lightsteelblue: \"#B0C4DE\",\n  lightyellow: \"#FFFFE0\",\n  lime: \"#00FF00\",\n  limegreen: \"#32CD32\",\n  linen: \"#FAF0E6\",\n  magenta: \"#FF00FF\",\n  maroon: \"#800000\",\n  mediumaquamarine: \"#66CDAA\",\n  mediumblue: \"#0000CD\",\n  mediumorchid: \"#BA55D3\",\n  mediumpurple: \"#9370DB\",\n  mediumseagreen: \"#3CB371\",\n  mediumslateblue: \"#7B68EE\",\n  mediumspringgreen: \"#00FA9A\",\n  mediumturquoise: \"#48D1CC\",\n  mediumvioletred: \"#C71585\",\n  midnightblue: \"#191970\",\n  mintcream: \"#F5FFFA\",\n  mistyrose: \"#FFE4E1\",\n  moccasin: \"#FFE4B5\",\n  navajowhite: \"#FFDEAD\",\n  navy: \"#000080\",\n  oldlace: \"#FDF5E6\",\n  olive: \"#808000\",\n  olivedrab: \"#6B8E23\",\n  orange: \"#FFA500\",\n  orangered: \"#FF4500\",\n  orchid: \"#DA70D6\",\n  palegoldenrod: \"#EEE8AA\",\n  palegreen: \"#98FB98\",\n  paleturquoise: \"#AFEEEE\",\n  palevioletred: \"#DB7093\",\n  papayawhip: \"#FFEFD5\",\n  peachpuff: \"#FFDAB9\",\n  peru: \"#CD853F\",\n  pink: \"#FFC0CB\",\n  plum: \"#DDA0DD\",\n  powderblue: \"#B0E0E6\",\n  purple: \"#800080\",\n  rebeccapurple: \"#663399\",\n  red: \"#FF0000\",\n  rosybrown: \"#BC8F8F\",\n  royalblue: \"#4169E1\",\n  saddlebrown: \"#8B4513\",\n  salmon: \"#FA8072\",\n  sandybrown: \"#F4A460\",\n  seagreen: \"#2E8B57\",\n  seashell: \"#FFF5EE\",\n  sienna: \"#A0522D\",\n  silver: \"#C0C0C0\",\n  skyblue: \"#87CEEB\",\n  slateblue: \"#6A5ACD\",\n  slategray: \"#708090\",\n  slategrey: \"#708090\",\n  snow: \"#FFFAFA\",\n  springgreen: \"#00FF7F\",\n  steelblue: \"#4682B4\",\n  tan: \"#D2B48C\",\n  teal: \"#008080\",\n  thistle: \"#D8BFD8\",\n  tomato: \"#FF6347\",\n  transparent: \"#00000000\",\n  turquoise: \"#40E0D0\",\n  violet: \"#EE82EE\",\n  wheat: \"#F5DEB3\",\n  white: \"#FFFFFF\",\n  whitesmoke: \"#F5F5F5\",\n  yellow: \"#FFFF00\",\n  yellowgreen: \"#9ACD32\"\n};\nvar Color = _Color;\n\n// packages/ag-charts-community/src/util/interpolate.ts\nfunction interpolateNumber(a, b) {\n  return (d) => Number(a) * (1 - d) + Number(b) * d;\n}\nfunction interpolateColor(a, b) {\n  if (typeof a === \"string\") {\n    try {\n      a = Color.fromString(a);\n    } catch (e) {\n      a = Color.fromArray([0, 0, 0]);\n    }\n  }\n  if (typeof b === \"string\") {\n    try {\n      b = Color.fromString(b);\n    } catch (e) {\n      b = Color.fromArray([0, 0, 0]);\n    }\n  }\n  return (d) => Color.mix(a, b, d).toRgbaString();\n}\n\n// packages/ag-charts-community/src/util/decorator.ts\nvar BREAK_TRANSFORM_CHAIN = Symbol(\"BREAK\");\nvar CONFIG_KEY = \"__decorator_config\";\nfunction initialiseConfig(target, propertyKeyOrSymbol) {\n  if (Object.getOwnPropertyDescriptor(target, CONFIG_KEY) == null) {\n    Object.defineProperty(target, CONFIG_KEY, { value: {} });\n  }\n  const config = target[CONFIG_KEY];\n  const propertyKey = propertyKeyOrSymbol.toString();\n  if (typeof config[propertyKey] !== \"undefined\") {\n    return config[propertyKey];\n  }\n  const valuesMap = /* @__PURE__ */ new WeakMap();\n  config[propertyKey] = { setters: [], getters: [], observers: [], valuesMap };\n  const descriptor = Object.getOwnPropertyDescriptor(target, propertyKeyOrSymbol);\n  const prevSet = descriptor?.set;\n  const prevGet = descriptor?.get;\n  const getter = function() {\n    let value = prevGet ? prevGet.call(this) : valuesMap.get(this);\n    for (const transformFn of config[propertyKey].getters) {\n      value = transformFn(this, propertyKeyOrSymbol, value);\n      if (value === BREAK_TRANSFORM_CHAIN) {\n        return;\n      }\n    }\n    return value;\n  };\n  const setter = function(value) {\n    const { setters, observers } = config[propertyKey];\n    let oldValue;\n    if (setters.some((f) => f.length > 2)) {\n      oldValue = prevGet ? prevGet.call(this) : valuesMap.get(this);\n    }\n    for (const transformFn of setters) {\n      value = transformFn(this, propertyKeyOrSymbol, value, oldValue);\n      if (value === BREAK_TRANSFORM_CHAIN) {\n        return;\n      }\n    }\n    if (prevSet) {\n      prevSet.call(this, value);\n    } else {\n      valuesMap.set(this, value);\n    }\n    for (const observerFn of observers) {\n      observerFn(this, value, oldValue);\n    }\n  };\n  Object.defineProperty(target, propertyKeyOrSymbol, {\n    set: setter,\n    get: getter,\n    enumerable: true,\n    configurable: false\n  });\n  return config[propertyKey];\n}\nfunction addTransformToInstanceProperty(setTransform, getTransform, configMetadata) {\n  return (target, propertyKeyOrSymbol) => {\n    const config = initialiseConfig(target, propertyKeyOrSymbol);\n    config.setters.push(setTransform);\n    if (getTransform) {\n      config.getters.unshift(getTransform);\n    }\n    if (configMetadata) {\n      Object.assign(config, configMetadata);\n    }\n  };\n}\nfunction addObserverToInstanceProperty(setObserver) {\n  return (target, propertyKeyOrSymbol) => {\n    initialiseConfig(target, propertyKeyOrSymbol).observers.push(setObserver);\n  };\n}\nfunction isDecoratedObject(target) {\n  return typeof target !== \"undefined\" && CONFIG_KEY in target;\n}\nfunction listDecoratedProperties(target) {\n  const targets = /* @__PURE__ */ new Set();\n  while (isDecoratedObject(target)) {\n    targets.add(target?.[CONFIG_KEY]);\n    target = Object.getPrototypeOf(target);\n  }\n  return Array.from(targets).flatMap((configMap) => Object.keys(configMap));\n}\nfunction extractDecoratedProperties(target) {\n  return listDecoratedProperties(target).reduce((result, key) => {\n    result[key] = target[key] ?? null;\n    return result;\n  }, {});\n}\nfunction extractDecoratedPropertyMetadata(target, propertyKeyOrSymbol) {\n  const propertyKey = propertyKeyOrSymbol.toString();\n  while (isDecoratedObject(target)) {\n    const config = target[CONFIG_KEY];\n    if (Object.hasOwn(config, propertyKey)) {\n      return config[propertyKey];\n    }\n    target = Object.getPrototypeOf(target);\n  }\n}\n\n// packages/ag-charts-community/src/util/type-guards.ts\nfunction isDefined(val) {\n  return val != null;\n}\nfunction isArray(value) {\n  return Array.isArray(value);\n}\nfunction isBoolean(value) {\n  return typeof value === \"boolean\";\n}\nfunction isDate(value) {\n  return value instanceof Date;\n}\nfunction isValidDate(value) {\n  return isDate(value) && !isNaN(Number(value));\n}\nfunction isRegExp(value) {\n  return value instanceof RegExp;\n}\nfunction isFunction(value) {\n  return typeof value === \"function\";\n}\nfunction isObject(value) {\n  return typeof value === \"object\" && value !== null && !isArray(value);\n}\nfunction isObjectLike(value) {\n  return isArray(value) || isPlainObject(value);\n}\nfunction isPlainObject(value) {\n  return typeof value === \"object\" && value !== null && Object.getPrototypeOf(value) === Object.prototype;\n}\nfunction isString(value) {\n  return typeof value === \"string\";\n}\nfunction isNumber(value) {\n  return typeof value === \"number\";\n}\nfunction isFiniteNumber(value) {\n  return Number.isFinite(value);\n}\nfunction isHtmlElement(value) {\n  return typeof window !== \"undefined\" && value instanceof HTMLElement;\n}\nfunction isEnumKey(enumObject, enumKey) {\n  return isString(enumKey) && Object.keys(enumObject).includes(enumKey);\n}\nfunction isEnumValue(enumObject, enumValue) {\n  return Object.values(enumObject).includes(enumValue);\n}\nfunction isSymbol(value) {\n  return typeof value === \"symbol\";\n}\nfunction excludesType(obj, excluded) {\n  return obj.type !== excluded;\n}\n\n// packages/ag-charts-community/src/util/object.ts\nfunction objectEqualWith(a, b, cmp) {\n  for (const key in b) {\n    if (!(key in a))\n      return false;\n  }\n  for (const key in a) {\n    if (!(key in b))\n      return false;\n    if (!cmp(a[key], b[key]))\n      return false;\n  }\n  return true;\n}\nfunction deepMerge(...sources) {\n  return mergeDefaults(...sources.reverse());\n}\nfunction mergeDefaults(...sources) {\n  const target = {};\n  for (const source of sources) {\n    if (!isObject(source))\n      continue;\n    const keys = isDecoratedObject(source) ? listDecoratedProperties(source) : Object.keys(source);\n    for (const key of keys) {\n      if (isPlainObject(target[key]) && isPlainObject(source[key])) {\n        target[key] = mergeDefaults(target[key], source[key]);\n      } else {\n        target[key] ?? (target[key] = source[key]);\n      }\n    }\n  }\n  return target;\n}\nfunction mergeArrayDefaults(dataArray, ...itemDefaults) {\n  if (itemDefaults && isArray(dataArray)) {\n    return dataArray.map((item) => mergeDefaults(item, ...itemDefaults));\n  }\n  return dataArray;\n}\nfunction mapValues(object2, mapper) {\n  return Object.entries(object2).reduce(\n    (result, [key, value]) => {\n      result[key] = mapper(value, key, object2);\n      return result;\n    },\n    {}\n  );\n}\nfunction without(object2, keys) {\n  const clone2 = { ...object2 };\n  for (const key of keys) {\n    delete clone2[key];\n  }\n  return clone2;\n}\nfunction getPath(object2, path) {\n  const pathArray = isArray(path) ? path : path.split(\".\");\n  return pathArray.reduce((value, pathKey) => value[pathKey], object2);\n}\nvar SKIP_JS_BUILTINS = /* @__PURE__ */ new Set([\"__proto__\", \"constructor\", \"prototype\"]);\nfunction setPath(object2, path, newValue) {\n  const pathArray = isArray(path) ? path.slice() : path.split(\".\");\n  const lastKey = pathArray.pop();\n  if (pathArray.some((p) => SKIP_JS_BUILTINS.has(p)))\n    return;\n  const lastObject = pathArray.reduce((value, pathKey) => value[pathKey], object2);\n  lastObject[lastKey] = newValue;\n  return lastObject[lastKey];\n}\nfunction partialAssign(keysToCopy, target, source) {\n  if (source === void 0) {\n    return target;\n  }\n  for (const key of keysToCopy) {\n    const value = source[key];\n    if (value !== void 0) {\n      target[key] = value;\n    }\n  }\n  return target;\n}\n\n// packages/ag-charts-community/src/motion/easing.ts\nvar easing_exports = {};\n__export(easing_exports, {\n  easeIn: () => easeIn,\n  easeInOut: () => easeInOut,\n  easeInOutQuad: () => easeInOutQuad,\n  easeInQuad: () => easeInQuad,\n  easeOut: () => easeOut,\n  easeOutQuad: () => easeOutQuad,\n  inverseEaseOut: () => inverseEaseOut,\n  linear: () => linear\n});\nvar linear = (n) => n;\nvar easeIn = (n) => 1 - Math.cos(n * Math.PI / 2);\nvar easeOut = (n) => Math.sin(n * Math.PI / 2);\nvar easeInOut = (n) => -(Math.cos(n * Math.PI) - 1) / 2;\nvar easeInQuad = (n) => n * n;\nvar easeOutQuad = (n) => 1 - (1 - n) ** 2;\nvar easeInOutQuad = (n) => n < 0.5 ? 2 * n * n : 1 - (-2 * n + 2) ** 2 / 2;\nvar inverseEaseOut = (x) => 2 * Math.asin(x) / Math.PI;\n\n// packages/ag-charts-community/src/motion/animation.ts\nvar QUICK_TRANSITION = 0.2;\nvar PHASE_ORDER = [\"initial\", \"remove\", \"update\", \"add\", \"trailing\", \"end\", \"none\"];\nvar PHASE_METADATA = {\n  initial: {\n    animationDuration: 1,\n    animationDelay: 0\n  },\n  add: {\n    animationDuration: 0.25,\n    animationDelay: 0.75\n  },\n  remove: {\n    animationDuration: 0.25,\n    animationDelay: 0\n  },\n  update: {\n    animationDuration: 0.5,\n    animationDelay: 0.25\n  },\n  trailing: {\n    animationDuration: QUICK_TRANSITION,\n    animationDelay: 1,\n    skipIfNoEarlierAnimations: true\n  },\n  end: {\n    animationDelay: 1 + QUICK_TRANSITION,\n    animationDuration: 0,\n    skipIfNoEarlierAnimations: true\n  },\n  none: {\n    animationDuration: 0,\n    animationDelay: 0\n  }\n};\nvar RepeatType = /* @__PURE__ */ ((RepeatType2) => {\n  RepeatType2[\"Loop\"] = \"loop\";\n  RepeatType2[\"Reverse\"] = \"reverse\";\n  return RepeatType2;\n})(RepeatType || {});\nfunction isNodeArray(array2) {\n  return array2.every((n) => n instanceof Node);\n}\nfunction deconstructSelectionsOrNodes(selectionsOrNodes) {\n  return isNodeArray(selectionsOrNodes) ? { nodes: selectionsOrNodes, selections: [] } : { nodes: [], selections: selectionsOrNodes };\n}\nfunction animationValuesEqual(a, b) {\n  if (a === b) {\n    return true;\n  } else if (Array.isArray(a) && Array.isArray(b)) {\n    return a.length === b.length && a.every((v, i) => animationValuesEqual(v, b[i]));\n  } else if (isInterpolating(a) && isInterpolating(b)) {\n    return a.equals(b);\n  } else if (isPlainObject(a) && isPlainObject(b)) {\n    return objectEqualWith(a, b, animationValuesEqual);\n  }\n  return false;\n}\nvar Animation = class {\n  constructor(opts) {\n    this.isComplete = false;\n    this.elapsed = 0;\n    this.iteration = 0;\n    this.isPlaying = false;\n    this.isReverse = false;\n    this.id = opts.id;\n    this.groupId = opts.groupId;\n    this.autoplay = opts.autoplay ?? true;\n    this.ease = opts.ease ?? linear;\n    this.phase = opts.phase;\n    const durationProportion = opts.duration ?? PHASE_METADATA[this.phase].animationDuration;\n    this.duration = durationProportion * opts.defaultDuration;\n    this.delay = (opts.delay ?? 0) * opts.defaultDuration;\n    this.onComplete = opts.onComplete;\n    this.onPlay = opts.onPlay;\n    this.onStop = opts.onStop;\n    this.onUpdate = opts.onUpdate;\n    this.interpolate = this.createInterpolator(opts.from, opts.to);\n    this.from = opts.from;\n    if (opts.skip === true) {\n      this.onUpdate?.(opts.to, false, this);\n      this.onStop?.(this);\n      this.onComplete?.(this);\n      this.isComplete = true;\n    }\n    if (opts.collapsable !== false) {\n      this.duration = this.checkCollapse(opts, this.duration);\n    }\n  }\n  checkCollapse(opts, calculatedDuration) {\n    return animationValuesEqual(opts.from, opts.to) ? 0 : calculatedDuration;\n  }\n  play(initialUpdate = false) {\n    if (this.isPlaying || this.isComplete)\n      return;\n    this.isPlaying = true;\n    this.onPlay?.(this);\n    if (!this.autoplay)\n      return;\n    this.autoplay = false;\n    if (!initialUpdate)\n      return;\n    this.onUpdate?.(this.from, true, this);\n  }\n  pause() {\n    this.isPlaying = false;\n  }\n  stop() {\n    this.isPlaying = false;\n    if (!this.isComplete) {\n      this.isComplete = true;\n      this.onStop?.(this);\n    }\n  }\n  update(time2) {\n    if (this.isComplete)\n      return time2;\n    if (!this.isPlaying && this.autoplay) {\n      this.play(true);\n    }\n    const previousElapsed = this.elapsed;\n    this.elapsed += time2;\n    if (this.delay > this.elapsed)\n      return 0;\n    const value = this.interpolate(this.isReverse ? 1 - this.delta : this.delta);\n    this.onUpdate?.(value, false, this);\n    const totalDuration = this.delay + this.duration;\n    if (this.elapsed >= totalDuration) {\n      this.stop();\n      this.isComplete = true;\n      this.onComplete?.(this);\n      return time2 - (totalDuration - previousElapsed);\n    }\n    return 0;\n  }\n  get delta() {\n    return this.ease(clamp(0, (this.elapsed - this.delay) / this.duration, 1));\n  }\n  createInterpolator(from3, to) {\n    if (typeof to !== \"object\" || isInterpolating(to)) {\n      return this.interpolateValue(from3, to);\n    }\n    const interpolatorEntries = [];\n    for (const key in to) {\n      const interpolator = this.interpolateValue(from3[key], to[key]);\n      if (interpolator != null) {\n        interpolatorEntries.push([key, interpolator]);\n      }\n    }\n    return (d) => {\n      const result = {};\n      for (const [key, interpolator] of interpolatorEntries) {\n        result[key] = interpolator(d);\n      }\n      return result;\n    };\n  }\n  interpolateValue(a, b) {\n    if (a == null || b == null) {\n      return;\n    } else if (isInterpolating(a)) {\n      return (d) => a[interpolate](b, d);\n    }\n    try {\n      switch (typeof a) {\n        case \"number\":\n          return interpolateNumber(a, b);\n        case \"string\":\n          return interpolateColor(a, b);\n        case \"boolean\":\n          if (a === b) {\n            return () => a;\n          }\n          break;\n      }\n    } catch (e) {\n    }\n    throw new Error(`Unable to interpolate values: ${a}, ${b}`);\n  }\n};\n\n// packages/ag-charts-community/src/motion/fromToMotion.ts\nvar NODE_UPDATE_STATE_TO_PHASE_MAPPING = {\n  added: \"add\",\n  updated: \"update\",\n  removed: \"remove\",\n  unknown: \"initial\",\n  \"no-op\": \"none\"\n};\nfunction fromToMotion(groupId, subId, animationManager, selectionsOrNodes, fns, getDatumId, diff2) {\n  const { fromFn, toFn, applyFn = (node, props) => node.setProperties(props) } = fns;\n  const { nodes, selections } = deconstructSelectionsOrNodes(selectionsOrNodes);\n  const processNodes = (liveNodes, subNodes) => {\n    let prevFromProps;\n    let liveNodeIndex = 0;\n    let nodeIndex = 0;\n    for (const node of subNodes) {\n      const isLive = liveNodes[liveNodeIndex] === node;\n      const ctx = {\n        last: nodeIndex >= subNodes.length - 1,\n        lastLive: liveNodeIndex >= liveNodes.length - 1,\n        prev: subNodes[nodeIndex - 1],\n        prevFromProps,\n        prevLive: liveNodes[liveNodeIndex - 1],\n        next: subNodes[nodeIndex + 1],\n        nextLive: liveNodes[liveNodeIndex + (isLive ? 1 : 0)]\n      };\n      const animationId = `${groupId}_${subId}_${node.id}`;\n      animationManager.stopByAnimationId(animationId);\n      let status = \"unknown\";\n      if (!isLive) {\n        status = \"removed\";\n      } else if (getDatumId && diff2) {\n        status = calculateStatus(node, node.datum, getDatumId, diff2);\n      }\n      node.transitionOut = status === \"removed\";\n      const { phase, start: start2, finish, delay, duration, ...from3 } = fromFn(node, node.datum, status, ctx);\n      const {\n        phase: toPhase,\n        start: toStart,\n        finish: toFinish,\n        delay: toDelay,\n        duration: toDuration,\n        ...to\n      } = toFn(node, node.datum, status, ctx);\n      const collapsable = finish == null;\n      animationManager.animate({\n        id: animationId,\n        groupId,\n        phase: phase ?? toPhase ?? \"update\",\n        duration: duration ?? toDuration,\n        delay: delay ?? toDelay,\n        from: from3,\n        to,\n        ease: easeOut,\n        collapsable,\n        onPlay: () => {\n          applyFn(node, { ...start2, ...toStart, ...from3 });\n        },\n        onUpdate(props) {\n          applyFn(node, props);\n        },\n        onStop: () => {\n          applyFn(node, {\n            ...start2,\n            ...toStart,\n            ...from3,\n            ...to,\n            ...finish,\n            ...toFinish\n          });\n        }\n      });\n      if (isLive) {\n        liveNodeIndex++;\n      }\n      nodeIndex++;\n      prevFromProps = from3;\n    }\n  };\n  let selectionIndex = 0;\n  for (const selection of selections) {\n    const selectionNodes = selection.nodes();\n    const liveNodes = selectionNodes.filter((n) => !selection.isGarbage(n));\n    processNodes(liveNodes, selectionNodes);\n    animationManager.animate({\n      id: `${groupId}_${subId}_selection_${selectionIndex}`,\n      groupId,\n      phase: \"end\",\n      from: 0,\n      to: 1,\n      ease: easeOut,\n      onStop() {\n        selection.cleanup();\n      }\n    });\n    selectionIndex++;\n  }\n  processNodes(nodes, nodes);\n}\nfunction staticFromToMotion(groupId, subId, animationManager, selectionsOrNodes, from3, to, extraOpts) {\n  const { nodes, selections } = deconstructSelectionsOrNodes(selectionsOrNodes);\n  const { start: start2, finish, phase } = extraOpts;\n  animationManager.animate({\n    id: `${groupId}_${subId}`,\n    groupId,\n    phase: phase ?? \"update\",\n    from: from3,\n    to,\n    ease: easeOut,\n    onPlay: () => {\n      if (!start2)\n        return;\n      for (const node of nodes) {\n        node.setProperties(start2);\n      }\n      for (const selection of selections) {\n        for (const node of selection.nodes()) {\n          node.setProperties(start2);\n        }\n      }\n    },\n    onUpdate(props) {\n      for (const node of nodes) {\n        node.setProperties(props);\n      }\n      for (const selection of selections) {\n        for (const node of selection.nodes()) {\n          node.setProperties(props);\n        }\n      }\n    },\n    onStop: () => {\n      for (const node of nodes) {\n        node.setProperties({ ...to, ...finish });\n      }\n      for (const selection of selections) {\n        for (const node of selection.nodes()) {\n          node.setProperties({ ...to, ...finish });\n        }\n        selection.cleanup();\n      }\n    }\n  });\n}\nfunction calculateStatus(node, datum, getDatumId, diff2) {\n  const id = getDatumId(node, datum);\n  if (diff2.added.has(id)) {\n    return \"added\";\n  }\n  if (diff2.removed.has(id)) {\n    return \"removed\";\n  }\n  return \"updated\";\n}\n\n// packages/ag-charts-community/src/scale/invalidating.ts\nvar Invalidating = (target, propertyKey) => {\n  const mappedProperty = Symbol(String(propertyKey));\n  target[mappedProperty] = void 0;\n  Object.defineProperty(target, propertyKey, {\n    get() {\n      return this[mappedProperty];\n    },\n    set(newValue) {\n      const oldValue = this[mappedProperty];\n      if (oldValue !== newValue) {\n        this[mappedProperty] = newValue;\n        this.invalid = true;\n      }\n    },\n    enumerable: true,\n    configurable: false\n  });\n};\n\n// packages/ag-charts-community/src/scale/continuousScale.ts\nvar _ContinuousScale = class _ContinuousScale {\n  constructor(domain, range3) {\n    this.invalid = true;\n    this.nice = false;\n    this.interval = void 0;\n    this.tickCount = _ContinuousScale.defaultTickCount;\n    this.minTickCount = 0;\n    this.maxTickCount = Infinity;\n    // TODO(olegat) should be of type D[]\n    this.niceDomain = [];\n    this.defaultClampMode = \"raw\";\n    this.domain = domain;\n    this.range = range3;\n  }\n  static is(value) {\n    return value instanceof _ContinuousScale;\n  }\n  transform(x) {\n    return x;\n  }\n  transformInvert(x) {\n    return x;\n  }\n  calcBandwidth(smallestInterval = 1) {\n    const domain = this.getDomain();\n    const rangeDistance = this.getPixelRange();\n    const intervals = Math.abs(domain[1] - domain[0]) / smallestInterval + 1;\n    const maxBands = Math.floor(rangeDistance);\n    const bands = Math.min(intervals, maxBands);\n    return rangeDistance / Math.max(1, bands);\n  }\n  getDomain() {\n    if (this.nice) {\n      this.refresh();\n      if (this.niceDomain.length) {\n        return this.niceDomain;\n      }\n    }\n    return this.domain;\n  }\n  convert(x, opts) {\n    const clampMode = opts?.clampMode ?? this.defaultClampMode;\n    if (!this.domain || this.domain.length < 2) {\n      return NaN;\n    }\n    this.refresh();\n    const domain = this.getDomain().map((d) => this.transform(d));\n    const [d0, d1] = domain;\n    const { range: range3 } = this;\n    const [r0, r1] = range3;\n    x = this.transform(x);\n    if (clampMode === \"clamped\") {\n      const [start2, stop] = findMinMax(domain.map(Number));\n      if (Number(x) < start2) {\n        return r0;\n      } else if (Number(x) > stop) {\n        return r1;\n      }\n    }\n    if (d0 === d1) {\n      return (r0 + r1) / 2;\n    } else if (x === d0) {\n      return r0;\n    } else if (x === d1) {\n      return r1;\n    }\n    return r0 + (Number(x) - Number(d0)) / (Number(d1) - Number(d0)) * (r1 - r0);\n  }\n  invert(x) {\n    this.refresh();\n    const domain = this.getDomain().map((d2) => this.transform(d2));\n    const [d0, d1] = domain;\n    const { range: range3 } = this;\n    const [r0, r1] = range3;\n    const isReversed = r0 > r1;\n    const rMin = isReversed ? r1 : r0;\n    const rMax = isReversed ? r0 : r1;\n    let d;\n    if (x < rMin) {\n      return isReversed ? d1 : d0;\n    } else if (x > rMax) {\n      return isReversed ? d0 : d1;\n    } else if (r0 === r1) {\n      d = this.toDomain((Number(d0) + Number(d1)) / 2);\n    } else {\n      d = this.toDomain(Number(d0) + (x - r0) / (r1 - r0) * (Number(d1) - Number(d0)));\n    }\n    return this.transformInvert(d);\n  }\n  refresh() {\n    if (!this.invalid)\n      return;\n    this.invalid = false;\n    this.update();\n    if (this.invalid) {\n      Logger.warnOnce(\"Expected update to not invalidate scale\");\n    }\n  }\n  getPixelRange() {\n    const [a, b] = this.range;\n    return Math.abs(b - a);\n  }\n};\n_ContinuousScale.defaultTickCount = 5;\n_ContinuousScale.defaultMaxTickCount = 6;\n__decorateClass([\n  Invalidating\n], _ContinuousScale.prototype, \"domain\", 2);\n__decorateClass([\n  Invalidating\n], _ContinuousScale.prototype, \"range\", 2);\n__decorateClass([\n  Invalidating\n], _ContinuousScale.prototype, \"nice\", 2);\n__decorateClass([\n  Invalidating\n], _ContinuousScale.prototype, \"interval\", 2);\n__decorateClass([\n  Invalidating\n], _ContinuousScale.prototype, \"tickCount\", 2);\n__decorateClass([\n  Invalidating\n], _ContinuousScale.prototype, \"minTickCount\", 2);\n__decorateClass([\n  Invalidating\n], _ContinuousScale.prototype, \"maxTickCount\", 2);\nvar ContinuousScale = _ContinuousScale;\n\n// packages/ag-charts-community/src/util/array.ts\nfunction extent(values) {\n  if (values.length === 0) {\n    return null;\n  }\n  let min = Infinity;\n  let max = -Infinity;\n  for (let n of values) {\n    if (n instanceof Date) {\n      n = n.getTime();\n    }\n    if (typeof n !== \"number\") {\n      continue;\n    }\n    if (n < min) {\n      min = n;\n    }\n    if (n > max) {\n      max = n;\n    }\n  }\n  const result = [min, max];\n  return result.every(isFinite) ? result : null;\n}\nfunction normalisedExtentWithMetadata(d, min, max) {\n  let clipped = false;\n  if (d.length > 2) {\n    d = extent(d) ?? [NaN, NaN];\n  }\n  if (!isNaN(min)) {\n    clipped || (clipped = min > d[0]);\n    d = [min, d[1]];\n  }\n  if (!isNaN(max)) {\n    clipped || (clipped = max < d[1]);\n    d = [d[0], max];\n  }\n  if (d[0] > d[1]) {\n    d = [];\n  }\n  return { extent: d, clipped };\n}\nfunction arraysEqual(a, b) {\n  if (a == null || b == null || a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i++) {\n    if (Array.isArray(a[i]) && Array.isArray(b[i])) {\n      if (!arraysEqual(a[i], b[i])) {\n        return false;\n      }\n    } else if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction toArray(value) {\n  if (typeof value === \"undefined\") {\n    return [];\n  }\n  return Array.isArray(value) ? value : [value];\n}\nfunction unique(array2) {\n  return Array.from(new Set(array2));\n}\nfunction groupBy(array2, iteratee) {\n  return array2.reduce((result, item) => {\n    const groupKey = iteratee(item);\n    result[groupKey] ?? (result[groupKey] = []);\n    result[groupKey].push(item);\n    return result;\n  }, {});\n}\nfunction circularSliceArray(data, size, offset4 = 0) {\n  if (data.length === 0) {\n    return [];\n  }\n  const result = [];\n  for (let i = 0; i < size; i++) {\n    result.push(data.at((i + offset4) % data.length));\n  }\n  return result;\n}\nfunction sortBasedOnArray(baseArray, orderArray) {\n  const orderMap = /* @__PURE__ */ new Map();\n  orderArray.forEach((item, index) => {\n    orderMap.set(item, index);\n  });\n  return baseArray.sort((a, b) => {\n    const indexA = orderMap.get(a) ?? Infinity;\n    const indexB = orderMap.get(b) ?? Infinity;\n    return indexA - indexB;\n  });\n}\n\n// packages/ag-charts-community/src/util/timeFormat.ts\nvar CONSTANTS = {\n  periods: [\"AM\", \"PM\"],\n  days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n  shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n  months: [\n    \"January\",\n    \"February\",\n    \"March\",\n    \"April\",\n    \"May\",\n    \"June\",\n    \"July\",\n    \"August\",\n    \"September\",\n    \"October\",\n    \"November\",\n    \"December\"\n  ],\n  shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n};\nfunction dayOfYear(date, startOfYear = new Date(date.getFullYear(), 0, 1)) {\n  const startOffset = date.getTimezoneOffset() - startOfYear.getTimezoneOffset();\n  const timeDiff = date.getTime() - startOfYear.getTime() + startOffset * 6e4;\n  const timeOneDay = 36e5 * 24;\n  return Math.floor(timeDiff / timeOneDay);\n}\nfunction weekOfYear(date, startDay) {\n  const startOfYear = new Date(date.getFullYear(), 0, 1);\n  const startOfYearDay = startOfYear.getDay();\n  const firstWeekStartOffset = (startDay - startOfYearDay + 7) % 7;\n  const startOffset = new Date(date.getFullYear(), 0, firstWeekStartOffset + 1);\n  if (startOffset <= date) {\n    return Math.floor(dayOfYear(date, startOffset) / 7) + 1;\n  }\n  return 0;\n}\nvar SUNDAY = 0;\nvar MONDAY = 1;\nvar THURSDAY = 4;\nfunction isoWeekOfYear(date, year2 = date.getFullYear()) {\n  const firstOfYear = new Date(year2, 0, 1);\n  const firstOfYearDay = firstOfYear.getDay();\n  const firstThursdayOffset = (THURSDAY - firstOfYearDay + 7) % 7;\n  const startOffset = new Date(year2, 0, firstThursdayOffset - (THURSDAY - MONDAY) + 1);\n  if (startOffset <= date) {\n    return Math.floor(dayOfYear(date, startOffset) / 7) + 1;\n  }\n  return isoWeekOfYear(date, year2 - 1);\n}\nfunction timezone(date) {\n  const offset4 = date.getTimezoneOffset();\n  const unsignedOffset = Math.abs(offset4);\n  const sign = offset4 > 0 ? \"-\" : \"+\";\n  return `${sign}${pad(Math.floor(unsignedOffset / 60), 2, \"0\")}${pad(Math.floor(unsignedOffset % 60), 2, \"0\")}`;\n}\nvar FORMATTERS = {\n  a: (d) => CONSTANTS.shortDays[d.getDay()],\n  A: (d) => CONSTANTS.days[d.getDay()],\n  b: (d) => CONSTANTS.shortMonths[d.getMonth()],\n  B: (d) => CONSTANTS.months[d.getMonth()],\n  c: \"%x, %X\",\n  d: (d, p) => pad(d.getDate(), 2, p ?? \"0\"),\n  e: \"%_d\",\n  f: (d, p) => pad(d.getMilliseconds() * 1e3, 6, p ?? \"0\"),\n  H: (d, p) => pad(d.getHours(), 2, p ?? \"0\"),\n  I: (d, p) => {\n    const hours = d.getHours() % 12;\n    return hours === 0 ? \"12\" : pad(hours, 2, p ?? \"0\");\n  },\n  j: (d, p) => pad(dayOfYear(d) + 1, 3, p ?? \"0\"),\n  m: (d, p) => pad(d.getMonth() + 1, 2, p ?? \"0\"),\n  M: (d, p) => pad(d.getMinutes(), 2, p ?? \"0\"),\n  L: (d, p) => pad(d.getMilliseconds(), 3, p ?? \"0\"),\n  p: (d) => d.getHours() < 12 ? \"AM\" : \"PM\",\n  Q: (d) => String(d.getTime()),\n  s: (d) => String(Math.floor(d.getTime() / 1e3)),\n  S: (d, p) => pad(d.getSeconds(), 2, p ?? \"0\"),\n  u: (d) => {\n    let day2 = d.getDay();\n    if (day2 < 1)\n      day2 += 7;\n    return String(day2 % 7);\n  },\n  U: (d, p) => pad(weekOfYear(d, SUNDAY), 2, p ?? \"0\"),\n  V: (d, p) => pad(isoWeekOfYear(d), 2, p ?? \"0\"),\n  w: (d, p) => pad(d.getDay(), 2, p ?? \"0\"),\n  W: (d, p) => pad(weekOfYear(d, MONDAY), 2, p ?? \"0\"),\n  x: \"%-m/%-d/%Y\",\n  X: \"%-I:%M:%S %p\",\n  y: (d, p) => pad(d.getFullYear() % 100, 2, p ?? \"0\"),\n  Y: (d, p) => pad(d.getFullYear(), 4, p ?? \"0\"),\n  Z: (d) => timezone(d),\n  \"%\": () => \"%\"\n};\nvar PADS = {\n  _: \" \",\n  \"0\": \"0\",\n  \"-\": \"\"\n};\nfunction pad(value, size, padChar) {\n  const output = String(Math.floor(value));\n  if (output.length >= size) {\n    return output;\n  }\n  return `${padChar.repeat(size - output.length)}${output}`;\n}\nfunction buildFormatter(formatString) {\n  const formatParts = [];\n  while (formatString.length > 0) {\n    let nextEscapeIdx = formatString.indexOf(\"%\");\n    if (nextEscapeIdx !== 0) {\n      const literalPart = nextEscapeIdx > 0 ? formatString.substring(0, nextEscapeIdx) : formatString;\n      formatParts.push(literalPart);\n    }\n    if (nextEscapeIdx < 0)\n      break;\n    const maybePadSpecifier = formatString[nextEscapeIdx + 1];\n    const maybePad = PADS[maybePadSpecifier];\n    if (maybePad != null) {\n      nextEscapeIdx++;\n    }\n    const maybeFormatterSpecifier = formatString[nextEscapeIdx + 1];\n    const maybeFormatter = FORMATTERS[maybeFormatterSpecifier];\n    if (typeof maybeFormatter === \"function\") {\n      formatParts.push([maybeFormatter, maybePad]);\n    } else if (typeof maybeFormatter === \"string\") {\n      const formatter = buildFormatter(maybeFormatter);\n      formatParts.push([formatter, maybePad]);\n    } else {\n      formatParts.push(`${maybePad ?? \"\"}${maybeFormatterSpecifier}`);\n    }\n    formatString = formatString.substring(nextEscapeIdx + 2);\n  }\n  return (dateTime) => {\n    const dateTimeAsDate = typeof dateTime === \"number\" ? new Date(dateTime) : dateTime;\n    return formatParts.map((c) => typeof c === \"string\" ? c : c[0](dateTimeAsDate, c[1])).join(\"\");\n  };\n}\n\n// packages/ag-charts-community/src/util/timeFormatDefaults.ts\nfunction dateToNumber(value) {\n  return value instanceof Date ? value.getTime() : value;\n}\nfunction defaultTimeTickFormat(ticks, domain, formatOffset) {\n  const formatString = calculateDefaultTimeTickFormat(ticks, domain, formatOffset);\n  const formatter = buildFormatter(formatString);\n  return (date) => formatter(date);\n}\nfunction calculateDefaultTimeTickFormat(ticks = [], domain = ticks, formatOffset = 0) {\n  let minInterval = Infinity;\n  for (let i = 1; i < ticks.length; i++) {\n    minInterval = Math.min(minInterval, Math.abs(ticks[i] - ticks[i - 1]));\n  }\n  const startYear = new Date(domain[0]).getFullYear();\n  const stopYear = new Date(domain.at(-1)).getFullYear();\n  const yearChange = stopYear - startYear > 0;\n  const timeFormat = isFinite(minInterval) ? getIntervalLowestGranularityFormat(minInterval, ticks) : getLowestGranularityFormat(ticks[0]);\n  return formatStringBuilder(Math.max(timeFormat - formatOffset, 0), yearChange, ticks);\n}\nfunction getIntervalLowestGranularityFormat(value, ticks) {\n  if (value < durationSecond) {\n    return 0 /* MILLISECOND */;\n  } else if (value < durationMinute) {\n    return 1 /* SECOND */;\n  } else if (value < durationHour) {\n    return 2 /* MINUTE */;\n  } else if (value < durationDay) {\n    return 3 /* HOUR */;\n  } else if (value < durationWeek) {\n    return 4 /* WEEK_DAY */;\n  } else if (value < durationDay * 28 || value < durationDay * 31 && hasDuplicateMonth(ticks)) {\n    return 5 /* SHORT_MONTH */;\n  } else if (value < durationYear) {\n    return 6 /* MONTH */;\n  }\n  return 7 /* YEAR */;\n}\nfunction getLowestGranularityFormat(value) {\n  if (second_default.floor(value) < value) {\n    return 0 /* MILLISECOND */;\n  } else if (minute_default.floor(value) < value) {\n    return 1 /* SECOND */;\n  } else if (hour_default.floor(value) < value) {\n    return 2 /* MINUTE */;\n  } else if (day_default.floor(value) < value) {\n    return 3 /* HOUR */;\n  } else if (month_default.floor(value) < value) {\n    if (week_default.floor(value) < value) {\n      return 4 /* WEEK_DAY */;\n    }\n    return 5 /* SHORT_MONTH */;\n  } else if (year_default.floor(value) < value) {\n    return 6 /* MONTH */;\n  }\n  return 7 /* YEAR */;\n}\nfunction hasDuplicateMonth(ticks) {\n  let prevMonth = new Date(ticks[0]).getMonth();\n  for (let i = 1; i < ticks.length; i++) {\n    const tickMonth = new Date(ticks[i]).getMonth();\n    if (prevMonth === tickMonth) {\n      return true;\n    }\n    prevMonth = tickMonth;\n  }\n  return false;\n}\nfunction formatStringBuilder(defaultTimeFormat, yearChange, ticks) {\n  const firstTick = dateToNumber(ticks[0]);\n  const lastTick = dateToNumber(ticks.at(-1));\n  const extent2 = Math.abs(lastTick - firstTick);\n  const activeYear = yearChange || defaultTimeFormat === 7 /* YEAR */;\n  const activeDate = extent2 === 0;\n  const parts = [\n    [\"hour\", 6 * durationHour, 14 * durationDay, 3 /* HOUR */, \"%I %p\"],\n    [\"hour\", durationMinute, 6 * durationHour, 3 /* HOUR */, \"%I:%M\"],\n    [\"second\", 1e3, 6 * durationHour, 1 /* SECOND */, \":%S\"],\n    [\"ms\", 0, 6 * durationHour, 0 /* MILLISECOND */, \".%L\"],\n    [\"am/pm\", durationMinute, 6 * durationHour, 3 /* HOUR */, \"%p\"],\n    \" \",\n    [\"day\", durationDay, durationWeek, 4 /* WEEK_DAY */, \"%a\"],\n    [\"month\", activeDate ? 0 : durationWeek, 52 * durationWeek, 5 /* SHORT_MONTH */, \"%b %d\"],\n    [\"month\", 5 * durationWeek, 10 * durationYear, 6 /* MONTH */, \"%B\"],\n    \" \",\n    [\"year\", activeYear ? 0 : durationYear, Infinity, 7 /* YEAR */, \"%Y\"]\n  ];\n  const formatParts = parts.filter((v) => {\n    if (typeof v === \"string\") {\n      return true;\n    }\n    const [_, min, max, format] = v;\n    return format >= defaultTimeFormat && min <= extent2 && extent2 < max;\n  }).reduce(\n    (r, next) => {\n      if (typeof next === \"string\") {\n        r.result.push(next);\n      } else if (!r.used.has(next[0])) {\n        r.result.push(next);\n        r.used.add(next[0]);\n      }\n      return r;\n    },\n    { result: [], used: /* @__PURE__ */ new Set() }\n  ).result;\n  const firstFormat = formatParts.findIndex((v) => typeof v !== \"string\");\n  const lastFormat = formatParts.findLastIndex((v) => typeof v !== \"string\");\n  return formatParts.slice(firstFormat, lastFormat + 1).map((v) => typeof v === \"string\" ? v : v[4]).join(\"\").replaceAll(/\\s+/g, \" \").trim();\n}\n\n// packages/ag-charts-community/src/scale/bandScale.ts\nvar _BandScale = class _BandScale {\n  constructor() {\n    this.type = \"band\";\n    this.invalid = true;\n    this.range = [0, 1];\n    this.round = false;\n    this.interval = void 0;\n    /**\n     * Maps datum to its index in the {@link domain} array.\n     * Used to check for duplicate data (not allowed).\n     */\n    this.index = /* @__PURE__ */ new Map();\n    /**\n     * The output range values for datum at each index.\n     */\n    this.ordinalRange = [];\n    /**\n     * Contains unique data only.\n     */\n    this._domain = [];\n    this._bandwidth = 1;\n    this._step = 1;\n    this._inset = 1;\n    this._rawBandwidth = 1;\n    /**\n     * The ratio of the range that is reserved for space between bands.\n     */\n    this._paddingInner = 0;\n    /**\n     * The ratio of the range that is reserved for space before the first\n     * and after the last band.\n     */\n    this._paddingOuter = 0;\n  }\n  static is(value) {\n    return value instanceof _BandScale;\n  }\n  refresh() {\n    if (!this.invalid)\n      return;\n    this.invalid = false;\n    this.update();\n    if (this.invalid) {\n      Logger.warnOnce(\"Expected update to not invalidate scale\");\n    }\n  }\n  set domain(values) {\n    this.index = /* @__PURE__ */ new Map();\n    this.invalid = true;\n    this._domain = [];\n    for (const value of values) {\n      const key = dateToNumber(value);\n      if (this.getIndex(key) === void 0) {\n        this.index.set(key, this._domain.push(value) - 1);\n      }\n    }\n  }\n  get domain() {\n    return this._domain;\n  }\n  getDomain() {\n    return this._domain;\n  }\n  ticks() {\n    this.refresh();\n    return this._domain;\n  }\n  convert(d) {\n    this.refresh();\n    const i = this.getIndex(d);\n    if (i == null) {\n      return NaN;\n    }\n    return this.ordinalRange[i] ?? NaN;\n  }\n  invert(position) {\n    this.refresh();\n    const index = this.ordinalRange.findIndex((p) => p === position);\n    return this.domain[index];\n  }\n  invertNearest(position) {\n    this.refresh();\n    let nearest = -1;\n    let minDistance = Infinity;\n    const index = this.ordinalRange.findIndex((p, i) => {\n      if (p === position)\n        return true;\n      const distance3 = Math.abs(position - p);\n      if (distance3 < minDistance) {\n        minDistance = distance3;\n        nearest = i;\n      }\n      return false;\n    });\n    return this.domain[index] ?? this.domain[nearest];\n  }\n  get bandwidth() {\n    this.refresh();\n    return this._bandwidth;\n  }\n  get step() {\n    this.refresh();\n    return this._step;\n  }\n  get inset() {\n    this.refresh();\n    return this._inset;\n  }\n  get rawBandwidth() {\n    this.refresh();\n    return this._rawBandwidth;\n  }\n  set padding(value) {\n    value = clamp(0, value, 1);\n    this._paddingInner = value;\n    this._paddingOuter = value;\n  }\n  get padding() {\n    return this._paddingInner;\n  }\n  set paddingInner(value) {\n    this._paddingInner = clamp(0, value, 1);\n  }\n  get paddingInner() {\n    return this._paddingInner;\n  }\n  set paddingOuter(value) {\n    this._paddingOuter = clamp(0, value, 1);\n  }\n  get paddingOuter() {\n    return this._paddingOuter;\n  }\n  update() {\n    const count = this._domain.length;\n    if (count === 0)\n      return;\n    const [r0, r1] = this.range;\n    let { _paddingInner: paddingInner } = this;\n    const { _paddingOuter: paddingOuter, round: round5 } = this;\n    const rangeDistance = r1 - r0;\n    let rawStep;\n    if (count === 1) {\n      paddingInner = 0;\n      rawStep = rangeDistance * (1 - paddingOuter * 2);\n    } else {\n      rawStep = rangeDistance / Math.max(1, count - paddingInner + paddingOuter * 2);\n    }\n    const step = round5 ? Math.floor(rawStep) : rawStep;\n    let inset = r0 + (rangeDistance - step * (count - paddingInner)) / 2;\n    let bandwidth = step * (1 - paddingInner);\n    if (round5) {\n      inset = Math.round(inset);\n      bandwidth = Math.round(bandwidth);\n    }\n    this._step = step;\n    this._inset = inset;\n    this._bandwidth = bandwidth;\n    this._rawBandwidth = rawStep * (1 - paddingInner);\n    this.ordinalRange = this._domain.map((_, i) => inset + step * i);\n  }\n  getIndex(value) {\n    return this.index.get(value instanceof Date ? value.getTime() : value);\n  }\n};\n__decorateClass([\n  Invalidating\n], _BandScale.prototype, \"range\", 2);\n__decorateClass([\n  Invalidating\n], _BandScale.prototype, \"round\", 2);\n__decorateClass([\n  Invalidating\n], _BandScale.prototype, \"interval\", 2);\nvar BandScale = _BandScale;\n\n// packages/ag-charts-community/src/util/properties.ts\nvar BaseProperties = class {\n  set(properties) {\n    const { className = this.constructor.name } = this.constructor;\n    if (typeof properties !== \"object\") {\n      Logger.warn(`unable to set ${className} - expecting a properties object`);\n      return this;\n    }\n    const keys = new Set(Object.keys(properties));\n    for (const propertyKey of listDecoratedProperties(this)) {\n      if (keys.has(propertyKey)) {\n        const value = properties[propertyKey];\n        const self = this;\n        if (isProperties(self[propertyKey])) {\n          if (self[propertyKey] instanceof PropertiesArray) {\n            const array2 = self[propertyKey].reset(value);\n            if (array2 != null) {\n              self[propertyKey] = array2;\n            } else {\n              Logger.warn(`unable to set [${propertyKey}] - expecting a properties array`);\n            }\n          } else {\n            self[propertyKey].set(value);\n          }\n        } else {\n          self[propertyKey] = value;\n        }\n        keys.delete(propertyKey);\n      }\n    }\n    for (const unknownKey of keys) {\n      Logger.warn(`unable to set [${unknownKey}] in ${className} - property is unknown`);\n    }\n    return this;\n  }\n  isValid(warningPrefix) {\n    return listDecoratedProperties(this).every((propertyKey) => {\n      const { optional } = extractDecoratedPropertyMetadata(this, propertyKey);\n      const valid = optional === true || typeof this[propertyKey] !== \"undefined\";\n      if (!valid) {\n        Logger.warnOnce(`${warningPrefix ?? \"\"}[${propertyKey}] is required.`);\n      }\n      return valid;\n    });\n  }\n  toJson() {\n    return listDecoratedProperties(this).reduce((object2, propertyKey) => {\n      const propertyValue = this[propertyKey];\n      object2[propertyKey] = isProperties(propertyValue) ? propertyValue.toJson() : propertyValue;\n      return object2;\n    }, {});\n  }\n};\nvar PropertiesArray = class _PropertiesArray extends Array {\n  constructor(itemFactory, ...properties) {\n    super(properties.length);\n    const isConstructor = (value2) => Boolean(value2?.prototype?.constructor?.name);\n    const value = isConstructor(itemFactory) ? (params) => new itemFactory().set(params) : itemFactory;\n    Object.defineProperty(this, \"itemFactory\", { value, enumerable: false, configurable: false });\n    this.set(properties);\n  }\n  set(properties) {\n    if (isArray(properties)) {\n      this.length = properties.length;\n      for (let i = 0; i < properties.length; i++) {\n        this[i] = this.itemFactory(properties[i]);\n      }\n    }\n    return this;\n  }\n  reset(properties) {\n    if (Array.isArray(properties)) {\n      return new _PropertiesArray(this.itemFactory, ...properties);\n    }\n  }\n  toJson() {\n    return this.map((value) => value?.toJson?.() ?? value);\n  }\n};\nfunction isProperties(value) {\n  return value instanceof BaseProperties || value instanceof PropertiesArray;\n}\n\n// packages/ag-charts-community/src/util/validation.ts\nfunction Validate(predicate, options = {}) {\n  const { optional = false, property: overrideProperty } = options;\n  return addTransformToInstanceProperty(\n    (target, property, value) => {\n      const context = { ...options, target, property };\n      if (optional && typeof value === \"undefined\" || predicate(value, context)) {\n        if (isProperties(target[property]) && !isProperties(value)) {\n          target[property].set(value);\n          return target[property];\n        }\n        return value;\n      }\n      const cleanKey = overrideProperty ?? String(property).replace(/^_*/, \"\");\n      const targetName = target.constructor.className ?? target.constructor.name.replace(/Properties$/, \"\");\n      let valueString = stringify(value);\n      const maxLength = 50;\n      if (valueString != null && valueString.length > maxLength) {\n        const excessCharacters = valueString.length - maxLength;\n        valueString = valueString.slice(0, maxLength) + `... (+${excessCharacters} characters)`;\n      }\n      Logger.warn(\n        `Property [${cleanKey}] of [${targetName}] cannot be set to [${valueString}]${predicate.message ? `; expecting ${getPredicateMessage(predicate, context)}` : \"\"}, ignoring.`\n      );\n      return BREAK_TRANSFORM_CHAIN;\n    },\n    void 0,\n    { optional }\n  );\n}\nvar AND = (...predicates) => {\n  const messages = [];\n  return predicateWithMessage(\n    (value, ctx) => {\n      messages.length = 0;\n      return predicates.every((predicate) => {\n        const isValid2 = predicate(value, ctx);\n        if (!isValid2) {\n          messages.push(getPredicateMessage(predicate, ctx));\n        }\n        return isValid2;\n      });\n    },\n    () => messages.filter(Boolean).join(\" AND \")\n  );\n};\nvar OR = (...predicates) => predicateWithMessage(\n  (value, ctx) => predicates.some((predicate) => predicate(value, ctx)),\n  (ctx) => predicates.map(getPredicateMessageMapper(ctx)).filter(Boolean).join(\" OR \")\n);\nvar OBJECT = attachObjectRestrictions(\n  predicateWithMessage(\n    (value, ctx) => isProperties(value) || isObject(value) && isProperties(ctx.target[ctx.property]),\n    \"a properties object\"\n  )\n);\nvar PLAIN_OBJECT = attachObjectRestrictions(predicateWithMessage((value) => isObject(value), \"an object\"));\nvar BOOLEAN = predicateWithMessage(isBoolean, \"a boolean\");\nvar FUNCTION = predicateWithMessage(isFunction, \"a function\");\nvar STRING = predicateWithMessage(isString, \"a string\");\nvar NUMBER = attachNumberRestrictions(predicateWithMessage(isFiniteNumber, \"a number\"));\nvar REAL_NUMBER = predicateWithMessage((value) => isNumber(value) && !isNaN(value), \"a real number\");\nvar NAN = predicateWithMessage((value) => isNumber(value) && isNaN(value), \"NaN\");\nvar POSITIVE_NUMBER = NUMBER.restrict({ min: 0 });\nvar RATIO = NUMBER.restrict({ min: 0, max: 1 });\nvar DEGREE = NUMBER.restrict({ min: -360, max: 360 });\nvar NUMBER_OR_NAN = OR(NUMBER, NAN);\nvar ARRAY = attachArrayRestrictions(predicateWithMessage(isArray, \"an array\"));\nvar ARRAY_OF = (predicate, message) => predicateWithMessage(\n  (value, ctx) => isArray(value) && value.every((item) => predicate(item, ctx)),\n  (ctx) => {\n    const arrayMessage = getPredicateMessage(ARRAY, ctx) ?? \"\";\n    return message ? `${arrayMessage} of ${message}` : arrayMessage;\n  }\n);\nvar isComparable = (value) => isFiniteNumber(value) || isValidDate(value);\nvar LESS_THAN = (otherField) => predicateWithMessage(\n  (v, ctx) => !isComparable(v) || !isComparable(ctx.target[otherField]) || v < ctx.target[otherField],\n  `to be less than ${otherField}`\n);\nvar GREATER_THAN = (otherField) => predicateWithMessage(\n  (v, ctx) => !isComparable(v) || !isComparable(ctx.target[otherField]) || v > ctx.target[otherField],\n  `to be greater than ${otherField}`\n);\nvar DATE = predicateWithMessage(isValidDate, \"Date object\");\nvar DATE_OR_DATETIME_MS = OR(DATE, POSITIVE_NUMBER);\nvar colorMessage = `A color string can be in one of the following formats to be valid: #rgb, #rrggbb, rgb(r, g, b), rgba(r, g, b, a) or a CSS color name such as 'white', 'orange', 'cyan', etc`;\nvar COLOR_STRING = predicateWithMessage(\n  (v) => isString(v) && Color.validColorString(v),\n  `color String. ${colorMessage}`\n);\nvar COLOR_STRING_ARRAY = predicateWithMessage(ARRAY_OF(COLOR_STRING), `color strings. ${colorMessage}`);\nvar BOOLEAN_ARRAY = ARRAY_OF(BOOLEAN, \"boolean values\");\nvar NUMBER_ARRAY = ARRAY_OF(NUMBER, \"numbers\");\nvar STRING_ARRAY = ARRAY_OF(STRING, \"strings\");\nvar DATE_ARRAY = predicateWithMessage(ARRAY_OF(DATE), \"Date objects\");\nvar OBJECT_ARRAY = predicateWithMessage(ARRAY_OF(OBJECT), \"objects\");\nvar LINE_CAP = UNION([\"butt\", \"round\", \"square\"], \"a line cap\");\nvar LINE_JOIN = UNION([\"round\", \"bevel\", \"miter\"], \"a line join\");\nvar LINE_STYLE = UNION([\"solid\", \"dashed\", \"dotted\"], \"a line style\");\nvar LINE_DASH = predicateWithMessage(\n  ARRAY_OF(POSITIVE_NUMBER),\n  \"numbers specifying the length in pixels of alternating dashes and gaps, for example, [6, 3] means dashes with a length of 6 pixels with gaps between of 3 pixels.\"\n);\nvar POSITION = UNION([\"top\", \"right\", \"bottom\", \"left\"], \"a position\");\nvar FONT_STYLE = UNION([\"normal\", \"italic\", \"oblique\"], \"a font style\");\nvar FONT_WEIGHT = OR(\n  UNION([\"normal\", \"bold\", \"bolder\", \"lighter\"], \"a font weight\"),\n  NUMBER.restrict({ min: 1, max: 1e3 })\n);\nvar TEXT_WRAP = UNION([\"never\", \"always\", \"hyphenate\", \"on-space\"], \"a text wrap strategy\");\nvar TEXT_ALIGN = UNION([\"left\", \"center\", \"right\"], \"a text align\");\nvar VERTICAL_ALIGN = UNION([\"top\", \"middle\", \"bottom\"], \"a vertical align\");\nvar OVERFLOW_STRATEGY = UNION([\"ellipsis\", \"hide\"], \"an overflow strategy\");\nvar DIRECTION = UNION([\"horizontal\", \"vertical\"], \"a direction\");\nvar PLACEMENT = UNION([\"inside\", \"outside\"], \"a placement\");\nvar INTERACTION_RANGE = OR(UNION([\"exact\", \"nearest\"], \"interaction range\"), NUMBER);\nvar LABEL_PLACEMENT = UNION([\"top\", \"bottom\", \"left\", \"right\"]);\nfunction UNION(options, message = \"a\") {\n  return predicateWithMessage(\n    (v, ctx) => {\n      const option = options.find((o) => {\n        const value = typeof o === \"string\" ? o : o.value;\n        return v === value;\n      });\n      if (option == null)\n        return false;\n      if (typeof option !== \"string\" && (option.deprecated === true || option.deprecatedTo != null)) {\n        const messages = [`Property [%s] with value '${option.value}' is deprecated.`];\n        if (option.deprecatedTo) {\n          messages.push(`Use ${option.deprecatedTo} instead.`);\n        }\n        Logger.warnOnce(messages.join(\" \"), ctx.property);\n      }\n      return true;\n    },\n    `${message} keyword such as ${joinUnionOptions(options)}`\n  );\n}\nvar MIN_SPACING = OR(AND(NUMBER.restrict({ min: 1 }), LESS_THAN(\"maxSpacing\")), NAN);\nvar MAX_SPACING = OR(AND(NUMBER.restrict({ min: 1 }), GREATER_THAN(\"minSpacing\")), NAN);\nfunction predicateWithMessage(predicate, message) {\n  predicate.message = message;\n  return predicate;\n}\nfunction joinUnionOptions(options) {\n  const values = options.filter((option) => typeof option === \"string\" || option.undocumented !== true).map((option) => `'${typeof option === \"string\" ? option : option.value}'`);\n  if (values.length === 1) {\n    return values[0];\n  }\n  const lastValue = values.pop();\n  return `${values.join(\", \")} or ${lastValue}`;\n}\nfunction getPredicateMessage(predicate, ctx) {\n  return isFunction(predicate.message) ? predicate.message(ctx) : predicate.message;\n}\nfunction getPredicateMessageMapper(ctx) {\n  return (predicate) => getPredicateMessage(predicate, ctx);\n}\nfunction attachArrayRestrictions(predicate) {\n  return Object.assign(predicate, {\n    restrict({ length: length2, minLength } = {}) {\n      let message = \"an array\";\n      if (isNumber(minLength) && minLength > 0) {\n        message = \"a non-empty array\";\n      } else if (isNumber(length2)) {\n        message = `an array of length ${length2}`;\n      }\n      return predicateWithMessage(\n        (value) => isArray(value) && (isNumber(length2) ? value.length === length2 : true) && (isNumber(minLength) ? value.length >= minLength : true),\n        message\n      );\n    }\n  });\n}\nfunction attachNumberRestrictions(predicate) {\n  return Object.assign(predicate, {\n    restrict({ min, max } = {}) {\n      const message = [\"a number\"];\n      const hasMin = isNumber(min);\n      const hasMax = isNumber(max);\n      if (hasMin && hasMax) {\n        message.push(`between ${min} and ${max} inclusive`);\n      } else if (hasMin) {\n        message.push(`greater than or equal to ${min}`);\n      } else if (hasMax) {\n        message.push(`less than or equal to ${max}`);\n      }\n      return predicateWithMessage(\n        (value) => isFiniteNumber(value) && (hasMin ? value >= min : true) && (hasMax ? value <= max : true),\n        message.join(\" \")\n      );\n    }\n  });\n}\nfunction attachObjectRestrictions(predicate) {\n  return Object.assign(predicate, {\n    restrict(objectType) {\n      return predicateWithMessage(\n        (value) => value instanceof objectType,\n        (ctx) => getPredicateMessage(predicate, ctx) ?? `an instance of ${objectType.name}`\n      );\n    }\n  });\n}\nfunction stringify(value) {\n  if (typeof value === \"number\") {\n    if (isNaN(value))\n      return \"NaN\";\n    if (value === Infinity)\n      return \"Infinity\";\n    if (value === -Infinity)\n      return \"-Infinity\";\n  }\n  return JSON.stringify(value);\n}\n\n// packages/ag-charts-community/src/chart/chartAxisDirection.ts\nvar ChartAxisDirection = /* @__PURE__ */ ((ChartAxisDirection2) => {\n  ChartAxisDirection2[\"X\"] = \"x\";\n  ChartAxisDirection2[\"Y\"] = \"y\";\n  return ChartAxisDirection2;\n})(ChartAxisDirection || {});\n\n// packages/ag-charts-community/src/module/moduleMap.ts\nvar ModuleMap = class {\n  constructor() {\n    this.moduleMap = /* @__PURE__ */ new Map();\n  }\n  *modules() {\n    for (const m of this.moduleMap.values()) {\n      yield m.moduleInstance;\n    }\n  }\n  addModule(module, moduleFactory) {\n    if (this.moduleMap.has(module.optionsKey)) {\n      throw new Error(`AG Charts - module already initialised: ${module.optionsKey}`);\n    }\n    this.moduleMap.set(module.optionsKey, { module, moduleInstance: moduleFactory(module) });\n  }\n  removeModule(module) {\n    const moduleKey = isString(module) ? module : module.optionsKey;\n    this.moduleMap.get(moduleKey)?.moduleInstance.destroy();\n    this.moduleMap.delete(moduleKey);\n  }\n  getModule(module) {\n    return this.moduleMap.get(isString(module) ? module : module.optionsKey)?.moduleInstance;\n  }\n  isEnabled(module) {\n    return this.moduleMap.has(isString(module) ? module : module.optionsKey);\n  }\n  mapModules(callback2) {\n    return Array.from(this.moduleMap.values(), (m, i) => callback2(m.moduleInstance, i));\n  }\n  destroy() {\n    for (const moduleKey of this.moduleMap.keys()) {\n      this.moduleMap.get(moduleKey)?.moduleInstance.destroy();\n    }\n    this.moduleMap.clear();\n  }\n};\n\n// packages/ag-charts-community/src/motion/resetMotion.ts\nvar resetMotion_exports = {};\n__export(resetMotion_exports, {\n  resetMotion: () => resetMotion\n});\nfunction resetMotion(selectionsOrNodes, propsFn) {\n  const { nodes, selections } = deconstructSelectionsOrNodes(selectionsOrNodes);\n  for (const selection of selections) {\n    for (const node of selection.nodes()) {\n      const from3 = propsFn(node, node.datum);\n      node.setProperties(from3);\n    }\n    selection.cleanup();\n  }\n  for (const node of nodes) {\n    const from3 = propsFn(node, node.datum);\n    node.setProperties(from3);\n  }\n}\n\n// packages/ag-charts-community/src/util/numberFormat.ts\nfunction parseFormat(format) {\n  let prefix;\n  let suffix;\n  const surrounded = surroundedRegEx.exec(format);\n  if (surrounded) {\n    [, prefix, format, suffix] = surrounded;\n  }\n  const match = formatRegEx.exec(format);\n  if (!match) {\n    throw new Error(`The number formatter is invalid: ${format}`);\n  }\n  const [, fill, align, sign, symbol, zero, width2, comma, precision, trim, type] = match;\n  return {\n    fill,\n    align,\n    sign,\n    symbol,\n    zero,\n    width: parseInt(width2),\n    comma,\n    precision: parseInt(precision),\n    trim: Boolean(trim),\n    type,\n    prefix,\n    suffix\n  };\n}\nfunction numberFormat(format) {\n  const options = typeof format === \"string\" ? parseFormat(format) : format;\n  const { fill, align, sign = \"-\", symbol, zero, width: width2, comma, type, prefix = \"\", suffix = \"\", precision } = options;\n  let { trim } = options;\n  const precisionIsNaN = precision == null || isNaN(precision);\n  let formatBody;\n  if (!type) {\n    formatBody = decimalTypes[\"g\"];\n    trim = true;\n  } else if (type in decimalTypes && type in integerTypes) {\n    formatBody = precisionIsNaN ? integerTypes[type] : decimalTypes[type];\n  } else if (type in decimalTypes) {\n    formatBody = decimalTypes[type];\n  } else if (type in integerTypes) {\n    formatBody = integerTypes[type];\n  } else {\n    throw new Error(`The number formatter type is invalid: ${type}`);\n  }\n  let formatterPrecision;\n  if (precision == null || precisionIsNaN) {\n    formatterPrecision = type ? 6 : 12;\n  } else {\n    formatterPrecision = precision;\n  }\n  return (n) => {\n    let result = formatBody(n, formatterPrecision);\n    if (trim) {\n      result = removeTrailingZeros(result);\n    }\n    if (comma) {\n      result = insertSeparator(result, comma);\n    }\n    result = addSign(n, result, sign);\n    if (symbol && symbol !== \"#\") {\n      result = `${symbol}${result}`;\n    }\n    if (symbol === \"#\" && type === \"x\") {\n      result = `0x${result}`;\n    }\n    if (type === \"s\") {\n      result = `${result}${getSIPrefix(n)}`;\n    }\n    if (type === \"%\" || type === \"p\") {\n      result = `${result}%`;\n    }\n    if (width2 != null && !isNaN(width2)) {\n      result = addPadding(result, width2, fill ?? zero, align);\n    }\n    result = `${prefix}${result}${suffix}`;\n    return result;\n  };\n}\nvar formatRegEx = /^(?:(.)?([<>=^]))?([+\\-( ])?([$€£¥₣₹#])?(0)?(\\d+)?(,)?(?:\\.(\\d+))?(~)?([%a-z])?$/i;\nvar surroundedRegEx = /^((?:[^#]|#[^{])*)#{([^}]+)}(.*)$/;\nvar integerTypes = {\n  b: (n) => absFloor(n).toString(2),\n  c: (n) => String.fromCharCode(n),\n  d: (n) => Math.round(Math.abs(n)).toFixed(0),\n  o: (n) => absFloor(n).toString(8),\n  x: (n) => absFloor(n).toString(16),\n  X: (n) => integerTypes.x(n).toUpperCase(),\n  n: (n) => integerTypes.d(n),\n  \"%\": (n) => `${absFloor(n * 100).toFixed(0)}`\n};\nvar decimalTypes = {\n  e: (n, f) => Math.abs(n).toExponential(f),\n  E: (n, f) => decimalTypes.e(n, f).toUpperCase(),\n  f: (n, f) => Math.abs(n).toFixed(f),\n  F: (n, f) => decimalTypes.f(n, f).toUpperCase(),\n  g: (n, f) => {\n    if (n === 0) {\n      return \"0\";\n    }\n    const a = Math.abs(n);\n    const p = Math.floor(Math.log10(a));\n    if (p >= -4 && p < f) {\n      return a.toFixed(f - 1 - p);\n    }\n    return a.toExponential(f - 1);\n  },\n  G: (n, f) => decimalTypes.g(n, f).toUpperCase(),\n  n: (n, f) => decimalTypes.g(n, f),\n  p: (n, f) => decimalTypes.r(n * 100, f),\n  r: (n, f) => {\n    if (n === 0) {\n      return \"0\";\n    }\n    const a = Math.abs(n);\n    const p = Math.floor(Math.log10(a));\n    const q = p - (f - 1);\n    if (q <= 0) {\n      return a.toFixed(-q);\n    }\n    const x = 10 ** q;\n    return (Math.round(a / x) * x).toFixed();\n  },\n  s: (n, f) => {\n    const p = getSIPrefixPower(n);\n    return decimalTypes.r(n / 10 ** p, f);\n  },\n  \"%\": (n, f) => decimalTypes.f(n * 100, f)\n};\nvar minSIPrefix = -24;\nvar maxSIPrefix = 24;\nvar siPrefixes = {\n  [minSIPrefix]: \"y\",\n  [-21]: \"z\",\n  [-18]: \"a\",\n  [-15]: \"f\",\n  [-12]: \"p\",\n  [-9]: \"n\",\n  [-6]: \"\\xB5\",\n  [-3]: \"m\",\n  [0]: \"\",\n  [3]: \"k\",\n  [6]: \"M\",\n  [9]: \"G\",\n  [12]: \"T\",\n  [15]: \"P\",\n  [18]: \"E\",\n  [21]: \"Z\",\n  [maxSIPrefix]: \"Y\"\n};\nvar minusSign = \"\\u2212\";\nfunction absFloor(n) {\n  return Math.floor(Math.abs(n));\n}\nfunction removeTrailingZeros(numString) {\n  return numString.replace(/\\.0+$/, \"\").replace(/(\\.[1-9])0+$/, \"$1\");\n}\nfunction insertSeparator(numString, separator) {\n  let dotIndex = numString.indexOf(\".\");\n  if (dotIndex < 0) {\n    dotIndex = numString.length;\n  }\n  const integerChars = numString.substring(0, dotIndex).split(\"\");\n  const fractionalPart = numString.substring(dotIndex);\n  for (let i = integerChars.length - 3; i > 0; i -= 3) {\n    integerChars.splice(i, 0, separator);\n  }\n  return `${integerChars.join(\"\")}${fractionalPart}`;\n}\nfunction getSIPrefix(n) {\n  return siPrefixes[getSIPrefixPower(n)];\n}\nfunction getSIPrefixPower(n) {\n  return clamp(minSIPrefix, n ? Math.floor(Math.log10(Math.abs(n)) / 3) * 3 : 0, maxSIPrefix);\n}\nfunction addSign(num, numString, signType = \"\") {\n  if (signType === \"(\") {\n    return num >= 0 ? numString : `(${numString})`;\n  }\n  const plusSign = signType === \"+\" ? \"+\" : \"\";\n  return `${num >= 0 ? plusSign : minusSign}${numString}`;\n}\nfunction addPadding(numString, width2, fill = \" \", align = \">\") {\n  let result = numString;\n  if (align === \">\" || !align) {\n    result = result.padStart(width2, fill);\n  } else if (align === \"<\") {\n    result = result.padEnd(width2, fill);\n  } else if (align === \"^\") {\n    const padWidth = Math.max(0, width2 - result.length);\n    const padLeft = Math.ceil(padWidth / 2);\n    const padRight = Math.floor(padWidth / 2);\n    result = result.padStart(padLeft + result.length, fill);\n    result = result.padEnd(padRight + result.length, fill);\n  }\n  return result;\n}\n\n// packages/ag-charts-community/src/util/ticks.ts\nvar tInterval = (timeInterval, baseDuration, step) => ({\n  duration: baseDuration * step,\n  timeInterval,\n  step\n});\nvar TickIntervals = [\n  tInterval(second_default, durationSecond, 1),\n  tInterval(second_default, durationSecond, 5),\n  tInterval(second_default, durationSecond, 15),\n  tInterval(second_default, durationSecond, 30),\n  tInterval(minute_default, durationMinute, 1),\n  tInterval(minute_default, durationMinute, 5),\n  tInterval(minute_default, durationMinute, 15),\n  tInterval(minute_default, durationMinute, 30),\n  tInterval(hour_default, durationHour, 1),\n  tInterval(hour_default, durationHour, 3),\n  tInterval(hour_default, durationHour, 6),\n  tInterval(hour_default, durationHour, 12),\n  tInterval(day_default, durationDay, 1),\n  tInterval(day_default, durationDay, 2),\n  tInterval(week_default, durationWeek, 1),\n  tInterval(week_default, durationWeek, 2),\n  tInterval(week_default, durationWeek, 3),\n  tInterval(month_default, durationMonth, 1),\n  tInterval(month_default, durationMonth, 2),\n  tInterval(month_default, durationMonth, 3),\n  tInterval(month_default, durationMonth, 4),\n  tInterval(month_default, durationMonth, 6),\n  tInterval(year_default, durationYear, 1)\n];\nvar TickMultipliers = [1, 2, 5, 10];\nfunction isCloseToInteger(n, delta4) {\n  return Math.abs(Math.round(n) - n) < delta4;\n}\nfunction createTicks(start2, stop, count, minCount, maxCount) {\n  if (count < 2) {\n    return [start2, stop];\n  }\n  const step = tickStep(start2, stop, count, minCount, maxCount);\n  if (!Number.isFinite(step)) {\n    return [];\n  }\n  if (!isCloseToInteger(start2 / step, 1e-12)) {\n    start2 = Math.ceil(start2 / step) * step;\n  }\n  if (!isCloseToInteger(stop / step, 1e-12)) {\n    stop = Math.floor(stop / step) * step;\n  }\n  return range(start2, stop, step);\n}\nfunction getTickInterval(start2, stop, count, minCount, maxCount, targetInterval) {\n  const target = targetInterval ?? Math.abs(stop - start2) / Math.max(count, 1);\n  let i = 0;\n  for (const tickInterval of TickIntervals) {\n    if (target <= tickInterval.duration)\n      break;\n    i++;\n  }\n  if (i === 0) {\n    const step2 = Math.max(tickStep(start2, stop, count, minCount, maxCount), 1);\n    return millisecond_default.every(step2);\n  } else if (i === TickIntervals.length) {\n    const step2 = targetInterval == null ? tickStep(start2 / durationYear, stop / durationYear, count, minCount, maxCount) : 1;\n    return year_default.every(step2);\n  }\n  const i0 = TickIntervals[i - 1];\n  const i1 = TickIntervals[i];\n  const { timeInterval, step } = target - i0.duration < i1.duration - target ? i0 : i1;\n  return timeInterval.every(step);\n}\nfunction tickStep(start2, end2, count, minCount = 0, maxCount = Infinity) {\n  if (start2 === end2) {\n    return clamp(1, minCount, maxCount);\n  } else if (count < 1) {\n    return NaN;\n  }\n  const extent2 = Math.abs(end2 - start2);\n  const step = 10 ** Math.floor(Math.log10(extent2 / count));\n  let m = NaN, minDiff = Infinity, isInBounds = false;\n  for (const multiplier of TickMultipliers) {\n    const c = Math.ceil(extent2 / (multiplier * step));\n    const validBounds = c >= minCount && c <= maxCount;\n    if (isInBounds && !validBounds)\n      continue;\n    const diffCount = Math.abs(c - count);\n    if (minDiff > diffCount || isInBounds !== validBounds) {\n      isInBounds || (isInBounds = validBounds);\n      minDiff = diffCount;\n      m = multiplier;\n    }\n  }\n  return m * step;\n}\nfunction decimalPlaces(decimal) {\n  for (let i = decimal.length - 1; i >= 0; i -= 1) {\n    if (decimal[i] !== \"0\") {\n      return i + 1;\n    }\n  }\n  return 0;\n}\nfunction tickFormat(ticks, format) {\n  const options = parseFormat(format ?? \",f\");\n  if (options.precision == null || isNaN(options.precision)) {\n    if (!options.type || \"eEFgGnprs\".includes(options.type)) {\n      options.precision = Math.max(\n        ...ticks.map((x) => {\n          if (!Number.isFinite(x))\n            return 0;\n          const [integer, decimal] = x.toExponential((options.type ? 6 : 12) - 1).split(/\\.|e/g);\n          return (integer !== \"1\" && integer !== \"-1\" ? 1 : 0) + decimalPlaces(decimal) + 1;\n        })\n      );\n    } else if (\"f%\".includes(options.type)) {\n      options.precision = Math.max(\n        ...ticks.map((x) => {\n          if (!Number.isFinite(x) || x === 0)\n            return 0;\n          const l = Math.floor(Math.log10(Math.abs(x)));\n          const digits = options.type ? 6 : 12;\n          const decimal = x.toExponential(digits - 1).split(/\\.|e/g)[1];\n          const decimalLength = decimalPlaces(decimal);\n          return Math.max(0, decimalLength - l);\n        })\n      );\n    }\n  }\n  const formatter = numberFormat(options);\n  return (n) => formatter(Number(n));\n}\nfunction range(start2, end2, step) {\n  if (!Number.isFinite(step) || step <= 0)\n    return [];\n  const f = 10 ** countFractionDigits(step);\n  const d0 = Math.min(start2, end2);\n  const d1 = Math.max(start2, end2);\n  const out = [];\n  for (let i = 0; ; i += 1) {\n    const p = Math.round((d0 + step * i) * f) / f;\n    if (p <= d1) {\n      out.push(p);\n    } else {\n      break;\n    }\n  }\n  return out;\n}\nfunction isDenseInterval(count, availableRange) {\n  if (count >= availableRange) {\n    Logger.warnOnce(\n      `the configured interval results in more than 1 item per pixel, ignoring. Supply a larger interval or omit this configuration`\n    );\n    return true;\n  }\n  return false;\n}\nfunction niceTicksDomain(start2, end2) {\n  const extent2 = Math.abs(end2 - start2);\n  const step = 10 ** Math.floor(Math.log10(extent2));\n  let minError = Infinity, ticks = [start2, end2];\n  for (const multiplier of TickMultipliers) {\n    const m = multiplier * step;\n    const d0 = Math.floor(start2 / m) * m;\n    const d1 = Math.ceil(end2 / m) * m;\n    const error = 1 - extent2 / Math.abs(d1 - d0);\n    if (minError > error) {\n      minError = error;\n      ticks = [d0, d1];\n    }\n  }\n  return ticks;\n}\nfunction estimateTickCount(rangeExtent, minSpacing, maxSpacing, defaultTickCount, defaultMinSpacing) {\n  defaultMinSpacing = Math.max(defaultMinSpacing, rangeExtent / (defaultTickCount + 1));\n  if (isNaN(minSpacing)) {\n    minSpacing = defaultMinSpacing;\n  }\n  if (isNaN(maxSpacing)) {\n    maxSpacing = rangeExtent;\n  }\n  if (minSpacing > maxSpacing) {\n    if (minSpacing === defaultMinSpacing) {\n      minSpacing = maxSpacing;\n    } else {\n      maxSpacing = minSpacing;\n    }\n  }\n  const maxTickCount = clamp(1, Math.floor(rangeExtent / minSpacing), Math.min(Math.floor(rangeExtent), 100));\n  const minTickCount = Math.min(maxTickCount, Math.ceil(rangeExtent / maxSpacing));\n  const tickCount = clamp(minTickCount, defaultTickCount, maxTickCount);\n  return { minTickCount, maxTickCount, tickCount };\n}\n\n// packages/ag-charts-community/src/scale/logScale.ts\nvar _LogScale = class _LogScale extends ContinuousScale {\n  constructor() {\n    super([1, 10], [0, 1]);\n    this.type = \"log\";\n    this.base = 10;\n    this.baseLog = identity;\n    this.basePow = identity;\n    this.log = (x) => {\n      const start2 = Math.min(...this.domain);\n      return start2 >= 0 ? this.baseLog(x) : -this.baseLog(-x);\n    };\n    this.pow = (x) => {\n      const start2 = Math.min(...this.domain);\n      return start2 >= 0 ? this.basePow(x) : -this.basePow(-x);\n    };\n    this.defaultClampMode = \"clamped\";\n  }\n  toDomain(d) {\n    return d;\n  }\n  transform(x) {\n    const start2 = Math.min(...this.domain);\n    return start2 >= 0 ? Math.log(x) : -Math.log(-x);\n  }\n  transformInvert(x) {\n    const start2 = Math.min(...this.domain);\n    return start2 >= 0 ? Math.exp(x) : -Math.exp(-x);\n  }\n  refresh() {\n    if (this.base <= 0) {\n      this.base = 0;\n      Logger.warnOnce(\"expecting a finite Number greater than to 0\");\n    }\n    super.refresh();\n  }\n  update() {\n    if (!this.domain || this.domain.length < 2) {\n      return;\n    }\n    this.baseLog = _LogScale.getBaseLogMethod(this.base);\n    this.basePow = _LogScale.getBasePowerMethod(this.base);\n    if (this.nice) {\n      this.updateNiceDomain();\n    }\n  }\n  updateNiceDomain() {\n    const [d0, d1] = this.domain;\n    const roundStart = d0 > d1 ? Math.ceil : Math.floor;\n    const roundStop = d0 > d1 ? Math.floor : Math.ceil;\n    const n0 = this.pow(roundStart(this.log(d0)));\n    const n1 = this.pow(roundStop(this.log(d1)));\n    this.niceDomain = [n0, n1];\n  }\n  ticks() {\n    const count = this.tickCount ?? 10;\n    if (!this.domain || this.domain.length < 2 || count < 1) {\n      return [];\n    }\n    this.refresh();\n    const base = this.base;\n    const [d0, d1] = this.getDomain();\n    const start2 = Math.min(d0, d1);\n    const stop = Math.max(d0, d1);\n    let p0 = this.log(start2);\n    let p1 = this.log(stop);\n    if (this.interval) {\n      const inBounds = (tick) => tick >= start2 && tick <= stop;\n      const step = Math.min(Math.abs(this.interval), Math.abs(p1 - p0));\n      const ticks2 = range(p0, p1, step).map(this.pow).filter(inBounds);\n      if (!isDenseInterval(ticks2.length, this.getPixelRange())) {\n        return ticks2;\n      }\n    }\n    const isBaseInteger = base % 1 === 0;\n    const isDiffLarge = p1 - p0 >= count;\n    if (!isBaseInteger || isDiffLarge) {\n      return createTicks(p0, p1, Math.min(p1 - p0, count)).map(this.pow);\n    }\n    const ticks = [];\n    const isPositive = start2 > 0;\n    p0 = Math.floor(p0) - 1;\n    p1 = Math.round(p1) + 1;\n    const availableSpacing = findRangeExtent(this.range) / count;\n    let lastTickPosition = Infinity;\n    for (let p = p0; p <= p1; p++) {\n      const nextMagnitudeTickPosition = this.convert(this.pow(p + 1));\n      for (let k = 1; k < base; k++) {\n        const q = isPositive ? k : base - k + 1;\n        const t = this.pow(p) * q;\n        const tickPosition = this.convert(t);\n        const prevSpacing = Math.abs(lastTickPosition - tickPosition);\n        const nextSpacing = Math.abs(tickPosition - nextMagnitudeTickPosition);\n        const fits = prevSpacing >= availableSpacing && nextSpacing >= availableSpacing;\n        if (t >= start2 && t <= stop && (k === 1 || fits || ticks.length === 0)) {\n          ticks.push(t);\n          lastTickPosition = tickPosition;\n        }\n      }\n    }\n    return ticks;\n  }\n  tickFormat({\n    count,\n    ticks,\n    specifier\n  }) {\n    if (count !== Infinity && ticks == null) {\n      this.ticks();\n    }\n    specifier ?? (specifier = this.base === 10 ? \".0e\" : \",\");\n    return isString(specifier) ? numberFormat(specifier) : specifier;\n  }\n  static getBaseLogMethod(base) {\n    switch (base) {\n      case 10:\n        return Math.log10;\n      case Math.E:\n        return Math.log;\n      case 2:\n        return Math.log2;\n      default:\n        return (x) => Math.log(x) / Math.log(base);\n    }\n  }\n  static getBasePowerMethod(base) {\n    switch (base) {\n      case 10:\n        return (x) => x >= 0 ? 10 ** x : 1 / 10 ** -x;\n      case Math.E:\n        return Math.exp;\n      default:\n        return (x) => base ** x;\n    }\n  }\n};\n__decorateClass([\n  Invalidating\n], _LogScale.prototype, \"base\", 2);\nvar LogScale = _LogScale;\n\n// packages/ag-charts-community/src/scale/timeScale.ts\nvar TimeScale = class _TimeScale extends ContinuousScale {\n  constructor() {\n    super([], [0, 1]);\n    this.type = \"time\";\n  }\n  toDomain(d) {\n    return new Date(d);\n  }\n  convert(x, opts) {\n    return super.convert(new Date(x), opts);\n  }\n  invert(y) {\n    return new Date(super.invert(y));\n  }\n  /**\n   * Returns uniformly-spaced dates that represent the scale's domain.\n   */\n  ticks() {\n    if (!this.domain || this.domain.length < 2) {\n      return [];\n    }\n    this.refresh();\n    const { interval, nice, tickCount, minTickCount, maxTickCount } = this;\n    const [start2, stop] = findMinMax(this.getDomain().map(dateToNumber));\n    if (interval != null) {\n      return _TimeScale.getTicksForInterval({ start: start2, stop, interval, availableRange: this.getPixelRange() }) ?? _TimeScale.getDefaultTicks({ start: start2, stop, tickCount, minTickCount, maxTickCount });\n    } else if (nice && tickCount === 2) {\n      return this.niceDomain;\n    } else if (nice && tickCount === 1) {\n      return this.niceDomain.slice(0, 1);\n    }\n    return _TimeScale.getDefaultTicks({ start: start2, stop, tickCount, minTickCount, maxTickCount });\n  }\n  static getDefaultTicks({\n    start: start2,\n    stop,\n    tickCount,\n    minTickCount,\n    maxTickCount\n  }) {\n    const t = getTickInterval(start2, stop, tickCount, minTickCount, maxTickCount);\n    return t ? t.range(new Date(start2), new Date(stop)) : [];\n  }\n  static getTicksForInterval({\n    start: start2,\n    stop,\n    interval,\n    availableRange\n  }) {\n    if (!interval) {\n      return [];\n    }\n    if (interval instanceof TimeInterval) {\n      const ticks2 = interval.range(new Date(start2), new Date(stop));\n      if (isDenseInterval(ticks2.length, availableRange)) {\n        return;\n      }\n      return ticks2;\n    }\n    const absInterval = Math.abs(interval);\n    if (isDenseInterval((stop - start2) / absInterval, availableRange))\n      return;\n    const timeInterval = TickIntervals.findLast((tickInterval) => absInterval % tickInterval.duration === 0);\n    if (timeInterval) {\n      const i = timeInterval.timeInterval.every(absInterval / (timeInterval.duration / timeInterval.step));\n      return i.range(new Date(start2), new Date(stop));\n    }\n    let date = new Date(start2);\n    const stopDate = new Date(stop);\n    const ticks = [];\n    while (date <= stopDate) {\n      ticks.push(date);\n      date = new Date(date);\n      date.setMilliseconds(date.getMilliseconds() + absInterval);\n    }\n    return ticks;\n  }\n  /**\n   * Returns a time format function suitable for displaying tick values.\n   *\n   * @param ticks Optional array of tick values for custom formatting.\n   * @param domain Optional array representing the [min, max] values of the time axis.\n   * @param specifier Optional format specifier string for custom date formatting (e.g., `%Y`, `%m`, `%d`).\n   * @param formatOffset Optional number for applying an offset to the format (e.g., timezone shifts).\n   * @returns A function that formats a `Date` object into a string based on the provided specifier or default format.\n   */\n  tickFormat({\n    ticks,\n    domain,\n    specifier,\n    formatOffset\n  }) {\n    return specifier == null ? defaultTimeTickFormat(ticks, domain, formatOffset) : buildFormatter(specifier);\n  }\n  update() {\n    if (!this.domain || this.domain.length < 2) {\n      return;\n    }\n    if (this.nice) {\n      this.updateNiceDomain();\n    }\n  }\n  /**\n   * Extends the domain so that it starts and ends on nice round values.\n   * This method typically modifies the scale’s domain, and may only extend the bounds to the nearest round value.\n   */\n  updateNiceDomain() {\n    const maxAttempts = 4;\n    let [d0, d1] = this.domain;\n    for (let i = 0; i < maxAttempts; i++) {\n      this.updateNiceDomainIteration(d0, d1);\n      const [n0, n1] = this.niceDomain;\n      if (dateToNumber(d0) === dateToNumber(n0) && dateToNumber(d1) === dateToNumber(n1)) {\n        break;\n      }\n      d0 = n0;\n      d1 = n1;\n    }\n  }\n  updateNiceDomainIteration(d0, d1) {\n    const start2 = Math.min(dateToNumber(d0), dateToNumber(d1));\n    const stop = Math.max(dateToNumber(d0), dateToNumber(d1));\n    const isReversed = d0 > d1;\n    const { interval } = this;\n    let i;\n    if (interval instanceof TimeInterval) {\n      i = interval;\n    } else {\n      const tickCount = typeof interval === \"number\" ? (stop - start2) / Math.max(interval, 1) : this.tickCount;\n      i = getTickInterval(start2, stop, tickCount, this.minTickCount, this.maxTickCount);\n    }\n    if (i) {\n      const intervalRange = i.range(new Date(start2), new Date(stop), true);\n      const domain = isReversed ? [...intervalRange].reverse() : intervalRange;\n      const n0 = domain[0];\n      const n1 = domain.at(-1);\n      this.niceDomain = [n0, n1];\n    }\n  }\n};\n\n// packages/ag-charts-community/src/scale/ordinalTimeScale.ts\nfunction compareNumbers(a, b) {\n  return a - b;\n}\nvar _OrdinalTimeScale = class _OrdinalTimeScale extends BandScale {\n  constructor() {\n    super(...arguments);\n    this.type = \"ordinal-time\";\n    this.tickCount = ContinuousScale.defaultTickCount;\n    this.minTickCount = 0;\n    this.maxTickCount = Infinity;\n    this.interval = void 0;\n    this._domain = [];\n    this.timestamps = [];\n    this.sortedTimestamps = [];\n    this.visibleRange = [0, 1];\n  }\n  static is(value) {\n    return value instanceof _OrdinalTimeScale;\n  }\n  setVisibleRange(visibleRange) {\n    this.visibleRange = visibleRange;\n  }\n  set domain(values) {\n    this.invalid = true;\n    if (values.length === 0) {\n      this._domain = [];\n      return;\n    }\n    this._domain = values;\n    this.timestamps = unique(values.map(dateToNumber));\n    this.sortedTimestamps = this.timestamps.slice().sort(compareNumbers);\n  }\n  get domain() {\n    return this._domain;\n  }\n  ticks() {\n    this.refresh();\n    const [t0, t1] = [this.timestamps[0], this.timestamps.at(-1)];\n    const start2 = Math.min(t0, t1);\n    const stop = Math.max(t0, t1);\n    const isReversed = t0 > t1;\n    let ticks;\n    if (this.interval == null) {\n      ticks = this.getDefaultTicks(this.maxTickCount, isReversed);\n    } else {\n      const [r0, r1] = this.range;\n      const availableRange = Math.abs(r1 - r0);\n      ticks = TimeScale.getTicksForInterval({ start: start2, stop, interval: this.interval, availableRange }) ?? [];\n    }\n    const tickPositions = /* @__PURE__ */ new Set();\n    return ticks.filter((tick) => {\n      const position = this.convert(tick);\n      if (isNaN(position) || tickPositions.has(position)) {\n        return false;\n      }\n      tickPositions.add(position);\n      return true;\n    });\n  }\n  getDefaultTicks(maxTickCount, isReversed) {\n    const ticks = [];\n    const count = this.timestamps.length;\n    const tickEvery = Math.ceil(count * (this.visibleRange[1] - this.visibleRange[0]) / maxTickCount);\n    const tickOffset = Math.floor(tickEvery / 2);\n    for (const [index, value] of this.timestamps.entries()) {\n      if (tickEvery > 0 && (index + tickOffset) % tickEvery)\n        continue;\n      if (isReversed) {\n        ticks.push(new Date(this.timestamps[count - index - 1]));\n      } else {\n        ticks.push(new Date(value));\n      }\n    }\n    return ticks;\n  }\n  convert(d) {\n    this.refresh();\n    const n = Number(d);\n    if (n < this.sortedTimestamps[0]) {\n      return NaN;\n    }\n    let i = this.findInterval(n);\n    if (this.timestamps[0] !== this.sortedTimestamps[0]) {\n      i = this.timestamps.length - i - 1;\n    }\n    return this.ordinalRange[i] ?? NaN;\n  }\n  findInterval(target) {\n    const { sortedTimestamps } = this;\n    let low = 0;\n    let high = sortedTimestamps.length - 1;\n    while (low <= high) {\n      const mid = Math.floor((low + high) / 2);\n      if (sortedTimestamps[mid] === target) {\n        return mid;\n      } else if (sortedTimestamps[mid] < target) {\n        low = mid + 1;\n      } else {\n        high = mid - 1;\n      }\n    }\n    return low;\n  }\n  /**\n   * Returns a time format function suitable for displaying tick values.\n   * @param specifier If the specifier string is provided, this method is equivalent to\n   * the {@link TimeLocaleObject.format} method.\n   * If no specifier is provided, this method returns the default time format function.\n   */\n  tickFormat({\n    ticks,\n    domain,\n    specifier\n  }) {\n    return specifier == null ? defaultTimeTickFormat(ticks, domain) : buildFormatter(specifier);\n  }\n  invert(position) {\n    this.refresh();\n    const index = this.ordinalRange.findIndex((p) => position <= p);\n    return this.domain[index];\n  }\n  invertNearest(y) {\n    return new Date(super.invertNearest(y));\n  }\n};\n__decorateClass([\n  Invalidating\n], _OrdinalTimeScale.prototype, \"tickCount\", 2);\n__decorateClass([\n  Invalidating\n], _OrdinalTimeScale.prototype, \"minTickCount\", 2);\n__decorateClass([\n  Invalidating\n], _OrdinalTimeScale.prototype, \"maxTickCount\", 2);\n__decorateClass([\n  Invalidating\n], _OrdinalTimeScale.prototype, \"interval\", 2);\nvar OrdinalTimeScale = _OrdinalTimeScale;\n\n// packages/ag-charts-community/src/util/compare.ts\nfunction ascendingStringNumberUndefined(a, b) {\n  if (typeof a === \"number\" && typeof b === \"number\") {\n    return a - b;\n  } else if (typeof a === \"string\" && typeof b === \"string\") {\n    return a.localeCompare(b);\n  } else if (a == null && b == null) {\n    return 0;\n  } else if (a == null) {\n    return -1;\n  } else if (b == null) {\n    return 1;\n  }\n  return String(a).localeCompare(String(b));\n}\nfunction toLiteral(v) {\n  return typeof v === \"function\" ? v() : v;\n}\nfunction compoundAscending(a, b, comparator) {\n  for (const idx in a) {\n    const diff2 = comparator(toLiteral(a[idx]), toLiteral(b[idx]));\n    if (diff2 !== 0) {\n      return diff2;\n    }\n  }\n  return 0;\n}\n\n// packages/ag-charts-community/src/scene/debug.util.ts\nfunction nodeCount(node) {\n  let count = 1;\n  let visibleCount = node.visible ? 1 : 0;\n  let dirtyCount = node.dirty > 0 /* NONE */ ? 1 : 0;\n  for (const child of node.children(false)) {\n    const c = nodeCount(child);\n    count += c.count;\n    dirtyCount += c.dirtyCount;\n    visibleCount += c.visibleCount;\n  }\n  return { count, visibleCount, dirtyCount };\n}\n\n// packages/ag-charts-community/src/scene/matrix.ts\nvar IDENTITY_MATRIX_ELEMENTS = Object.freeze([1, 0, 0, 1, 0, 0]);\nfunction closeValue(val, ref, errorMargin = 1e-8) {\n  return val === ref || Math.abs(ref - val) < errorMargin;\n}\nvar _Matrix = class _Matrix {\n  get e() {\n    return [...this.elements];\n  }\n  constructor(elements2 = [...IDENTITY_MATRIX_ELEMENTS]) {\n    this.elements = elements2;\n  }\n  setElements(elements2) {\n    const e = this.elements;\n    e[0] = elements2[0];\n    e[1] = elements2[1];\n    e[2] = elements2[2];\n    e[3] = elements2[3];\n    e[4] = elements2[4];\n    e[5] = elements2[5];\n    return this;\n  }\n  get identity() {\n    const e = this.elements;\n    return closeValue(e[0], 1) && closeValue(e[1], 0) && closeValue(e[2], 0) && closeValue(e[3], 1) && closeValue(e[4], 0) && closeValue(e[5], 0);\n  }\n  /**\n   * Performs the AxB matrix multiplication and saves the result\n   * to `C`, if given, or to `A` otherwise.\n   */\n  AxB(A, B, C) {\n    const a = A[0] * B[0] + A[2] * B[1], b = A[1] * B[0] + A[3] * B[1], c = A[0] * B[2] + A[2] * B[3], d = A[1] * B[2] + A[3] * B[3], e = A[0] * B[4] + A[2] * B[5] + A[4], f = A[1] * B[4] + A[3] * B[5] + A[5];\n    C = C ?? A;\n    C[0] = a;\n    C[1] = b;\n    C[2] = c;\n    C[3] = d;\n    C[4] = e;\n    C[5] = f;\n  }\n  /**\n   * The `other` matrix gets post-multiplied to the current matrix.\n   * Returns the current matrix.\n   * @param other\n   */\n  multiplySelf(other) {\n    this.AxB(this.elements, other.elements);\n    return this;\n  }\n  /**\n   * The `other` matrix gets post-multiplied to the current matrix.\n   * Returns a new matrix.\n   * @param other\n   */\n  multiply(other) {\n    const elements2 = new Array(6);\n    if (other instanceof _Matrix) {\n      this.AxB(this.elements, other.elements, elements2);\n    } else {\n      this.AxB(this.elements, [other.a, other.b, other.c, other.d, other.e, other.f], elements2);\n    }\n    return new _Matrix(elements2);\n  }\n  preMultiplySelf(other) {\n    this.AxB(other.elements, this.elements, this.elements);\n    return this;\n  }\n  /**\n   * Returns the inverse of this matrix as a new matrix.\n   */\n  inverse() {\n    const el = this.elements;\n    let a = el[0], b = el[1], c = el[2], d = el[3];\n    const e = el[4], f = el[5];\n    const rD = 1 / (a * d - b * c);\n    a *= rD;\n    b *= rD;\n    c *= rD;\n    d *= rD;\n    return new _Matrix([d, -b, -c, a, c * f - d * e, b * e - a * f]);\n  }\n  /**\n   * Save the inverse of this matrix to the given matrix.\n   */\n  inverseTo(other) {\n    const el = this.elements;\n    let a = el[0], b = el[1], c = el[2], d = el[3];\n    const e = el[4], f = el[5];\n    const rD = 1 / (a * d - b * c);\n    a *= rD;\n    b *= rD;\n    c *= rD;\n    d *= rD;\n    other.setElements([d, -b, -c, a, c * f - d * e, b * e - a * f]);\n    return this;\n  }\n  invertSelf() {\n    const el = this.elements;\n    let a = el[0], b = el[1], c = el[2], d = el[3];\n    const e = el[4], f = el[5];\n    const rD = 1 / (a * d - b * c);\n    a *= rD;\n    b *= rD;\n    c *= rD;\n    d *= rD;\n    el[0] = d;\n    el[1] = -b;\n    el[2] = -c;\n    el[3] = a;\n    el[4] = c * f - d * e;\n    el[5] = b * e - a * f;\n    return this;\n  }\n  transformPoint(x, y) {\n    const e = this.elements;\n    return {\n      x: x * e[0] + y * e[2] + e[4],\n      y: x * e[1] + y * e[3] + e[5]\n    };\n  }\n  transformBBox(bbox, target) {\n    const el = this.elements;\n    const xx = el[0];\n    const xy = el[1];\n    const yx = el[2];\n    const yy = el[3];\n    const h_w = bbox.width * 0.5;\n    const h_h = bbox.height * 0.5;\n    const cx = bbox.x + h_w;\n    const cy = bbox.y + h_h;\n    const w = Math.abs(h_w * xx) + Math.abs(h_h * yx);\n    const h = Math.abs(h_w * xy) + Math.abs(h_h * yy);\n    target ?? (target = new BBox(0, 0, 0, 0));\n    target.x = cx * xx + cy * yx + el[4] - w;\n    target.y = cx * xy + cy * yy + el[5] - h;\n    target.width = w + w;\n    target.height = h + h;\n    return target;\n  }\n  toContext(ctx) {\n    if (this.identity) {\n      return;\n    }\n    const e = this.elements;\n    ctx.transform(e[0], e[1], e[2], e[3], e[4], e[5]);\n  }\n  static flyweight(sourceMatrix) {\n    return _Matrix.instance.setElements(sourceMatrix.elements);\n  }\n  static updateTransformMatrix(matrix, scalingX, scalingY, rotation, translationX, translationY, opts) {\n    const sx = scalingX;\n    const sy = scalingY;\n    let scx;\n    let scy;\n    if (sx === 1 && sy === 1) {\n      scx = 0;\n      scy = 0;\n    } else {\n      scx = opts?.scalingCenterX ?? 0;\n      scy = opts?.scalingCenterY ?? 0;\n    }\n    const r = rotation;\n    const cos = Math.cos(r);\n    const sin = Math.sin(r);\n    let rcx;\n    let rcy;\n    if (r === 0) {\n      rcx = 0;\n      rcy = 0;\n    } else {\n      rcx = opts?.rotationCenterX ?? 0;\n      rcy = opts?.rotationCenterY ?? 0;\n    }\n    const tx = translationX;\n    const ty = translationY;\n    const tx4 = scx * (1 - sx) - rcx;\n    const ty4 = scy * (1 - sy) - rcy;\n    matrix.setElements([\n      cos * sx,\n      sin * sx,\n      -sin * sy,\n      cos * sy,\n      cos * tx4 - sin * ty4 + rcx + tx,\n      sin * tx4 + cos * ty4 + rcy + ty\n    ]);\n    return matrix;\n  }\n  static fromContext(ctx) {\n    const domMatrix = ctx.getTransform();\n    return new _Matrix([domMatrix.a, domMatrix.b, domMatrix.c, domMatrix.d, domMatrix.e, domMatrix.f]);\n  }\n};\n_Matrix.instance = new _Matrix();\nvar Matrix = _Matrix;\n\n// packages/ag-charts-community/src/scene/transformable.ts\nfunction isMatrixTransform(node) {\n  return isMatrixTransformType(node.constructor);\n}\nvar MATRIX_TRANSFORM_TYPE = Symbol(\"isMatrixTransform\");\nfunction isMatrixTransformType(cstr) {\n  return cstr[MATRIX_TRANSFORM_TYPE] === true;\n}\nfunction MatrixTransform(Parent) {\n  var _a, _b;\n  const ParentNode = Parent;\n  if (isMatrixTransformType(Parent)) {\n    return Parent;\n  }\n  const TRANSFORM_MATRIX = Symbol(\"matrix_combined_transform\");\n  class MatrixTransformInternal extends ParentNode {\n    constructor() {\n      super(...arguments);\n      this[_b] = new Matrix();\n      this._dirtyTransform = true;\n    }\n    markDirtyTransform() {\n      this._dirtyTransform = true;\n      super.markDirty(3 /* MAJOR */);\n    }\n    updateMatrix(_matrix) {\n    }\n    computeTransformMatrix() {\n      if (!this._dirtyTransform)\n        return;\n      this[TRANSFORM_MATRIX].setElements(IDENTITY_MATRIX_ELEMENTS);\n      this.updateMatrix(this[TRANSFORM_MATRIX]);\n      this._dirtyTransform = false;\n    }\n    toParent(bbox) {\n      this.computeTransformMatrix();\n      if (this[TRANSFORM_MATRIX].identity)\n        return bbox.clone();\n      return this[TRANSFORM_MATRIX].transformBBox(bbox);\n    }\n    toParentPoint(x, y) {\n      this.computeTransformMatrix();\n      if (this[TRANSFORM_MATRIX].identity)\n        return { x, y };\n      return this[TRANSFORM_MATRIX].transformPoint(x, y);\n    }\n    fromParent(bbox) {\n      this.computeTransformMatrix();\n      if (this[TRANSFORM_MATRIX].identity)\n        return bbox.clone();\n      return this[TRANSFORM_MATRIX].inverse().transformBBox(bbox);\n    }\n    fromParentPoint(x, y) {\n      this.computeTransformMatrix();\n      if (this[TRANSFORM_MATRIX].identity)\n        return { x, y };\n      return this[TRANSFORM_MATRIX].inverse().transformPoint(x, y);\n    }\n    computeBBox() {\n      const bbox = super.computeBBox();\n      if (!bbox)\n        return bbox;\n      return this.toParent(bbox);\n    }\n    computeBBoxWithoutTransforms() {\n      return super.computeBBox();\n    }\n    pickNode(x, y, localCoords = false) {\n      if (!localCoords) {\n        ({ x, y } = this.fromParentPoint(x, y));\n      }\n      return super.pickNode(x, y);\n    }\n    render(renderCtx) {\n      if (this._dirtyTransform) {\n        this.computeTransformMatrix();\n        if (!renderCtx.forceRender) {\n          renderCtx = { ...renderCtx, forceRender: \"dirtyTransform\" };\n        }\n      }\n      const matrix = this[TRANSFORM_MATRIX];\n      let performRestore = false;\n      if (!matrix.identity) {\n        renderCtx.ctx.save();\n        performRestore = true;\n        matrix.toContext(renderCtx.ctx);\n      }\n      super.render(renderCtx);\n      if (performRestore) {\n        renderCtx.ctx.restore();\n      }\n    }\n    toSVG() {\n      const svg = super.toSVG();\n      const matrix = this[TRANSFORM_MATRIX];\n      if (matrix.identity || svg == null)\n        return svg;\n      const g = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n      g.append(...svg.elements);\n      const [a, b, c, d, e, f] = matrix.e;\n      g.setAttribute(\"transform\", `matrix(${a} ${b} ${c} ${d} ${e} ${f})`);\n      return {\n        elements: [g],\n        defs: svg.defs\n      };\n    }\n  }\n  _a = MATRIX_TRANSFORM_TYPE, _b = TRANSFORM_MATRIX;\n  MatrixTransformInternal[_a] = true;\n  return MatrixTransformInternal;\n}\nfunction Rotatable(Parent) {\n  var _a;\n  const ParentNode = Parent;\n  const ROTATABLE_MATRIX = Symbol(\"matrix_rotation\");\n  class RotatableInternal extends MatrixTransform(ParentNode) {\n    constructor() {\n      super(...arguments);\n      this[_a] = new Matrix();\n      this.rotationCenterX = null;\n      this.rotationCenterY = null;\n      this.rotation = 0;\n    }\n    updateMatrix(matrix) {\n      super.updateMatrix(matrix);\n      const { rotation, rotationCenterX, rotationCenterY } = this;\n      if (rotation === 0)\n        return;\n      Matrix.updateTransformMatrix(this[ROTATABLE_MATRIX], 1, 1, rotation, 0, 0, {\n        rotationCenterX,\n        rotationCenterY\n      });\n      matrix.multiplySelf(this[ROTATABLE_MATRIX]);\n    }\n  }\n  _a = ROTATABLE_MATRIX;\n  __decorateClass([\n    SceneChangeDetection({ type: \"transform\" })\n  ], RotatableInternal.prototype, \"rotationCenterX\", 2);\n  __decorateClass([\n    SceneChangeDetection({ type: \"transform\" })\n  ], RotatableInternal.prototype, \"rotationCenterY\", 2);\n  __decorateClass([\n    SceneChangeDetection({ type: \"transform\" })\n  ], RotatableInternal.prototype, \"rotation\", 2);\n  return RotatableInternal;\n}\nfunction Scalable(Parent) {\n  var _a;\n  const ParentNode = Parent;\n  const SCALABLE_MATRIX = Symbol(\"matrix_scale\");\n  class ScalableInternal extends MatrixTransform(ParentNode) {\n    constructor() {\n      super(...arguments);\n      this[_a] = new Matrix();\n      this.scalingX = 1;\n      this.scalingY = 1;\n      this.scalingCenterX = null;\n      this.scalingCenterY = null;\n    }\n    updateMatrix(matrix) {\n      super.updateMatrix(matrix);\n      const { scalingX, scalingY, scalingCenterX, scalingCenterY } = this;\n      if (scalingX === 1 && scalingY === 1)\n        return;\n      Matrix.updateTransformMatrix(this[SCALABLE_MATRIX], scalingX, scalingY, 0, 0, 0, {\n        scalingCenterX,\n        scalingCenterY\n      });\n      matrix.multiplySelf(this[SCALABLE_MATRIX]);\n    }\n  }\n  _a = SCALABLE_MATRIX;\n  __decorateClass([\n    SceneChangeDetection({ type: \"transform\" })\n  ], ScalableInternal.prototype, \"scalingX\", 2);\n  __decorateClass([\n    SceneChangeDetection({ type: \"transform\" })\n  ], ScalableInternal.prototype, \"scalingY\", 2);\n  __decorateClass([\n    SceneChangeDetection({ type: \"transform\" })\n  ], ScalableInternal.prototype, \"scalingCenterX\", 2);\n  __decorateClass([\n    SceneChangeDetection({ type: \"transform\" })\n  ], ScalableInternal.prototype, \"scalingCenterY\", 2);\n  return ScalableInternal;\n}\nfunction Translatable(Parent) {\n  var _a;\n  const ParentNode = Parent;\n  const TRANSLATABLE_MATRIX = Symbol(\"matrix_translation\");\n  class TranslatableInternal extends MatrixTransform(ParentNode) {\n    constructor() {\n      super(...arguments);\n      this[_a] = new Matrix();\n      this.translationX = 0;\n      this.translationY = 0;\n    }\n    updateMatrix(matrix) {\n      super.updateMatrix(matrix);\n      const { translationX, translationY } = this;\n      if (translationX === 0 && translationY === 0)\n        return;\n      Matrix.updateTransformMatrix(this[TRANSLATABLE_MATRIX], 1, 1, 0, translationX, translationY);\n      matrix.multiplySelf(this[TRANSLATABLE_MATRIX]);\n    }\n  }\n  _a = TRANSLATABLE_MATRIX;\n  __decorateClass([\n    SceneChangeDetection({ type: \"transform\" })\n  ], TranslatableInternal.prototype, \"translationX\", 2);\n  __decorateClass([\n    SceneChangeDetection({ type: \"transform\" })\n  ], TranslatableInternal.prototype, \"translationY\", 2);\n  return TranslatableInternal;\n}\nvar Transformable = class {\n  /**\n   * Converts a BBox from canvas coordinate space into the coordinate space of the given Node.\n   */\n  static fromCanvas(node, bbox) {\n    const parents = [];\n    for (const parent of node.traverseUp()) {\n      if (isMatrixTransform(parent)) {\n        parents.unshift(parent);\n      }\n    }\n    for (const parent of parents) {\n      bbox = parent.fromParent(bbox);\n    }\n    if (isMatrixTransform(node)) {\n      bbox = node.fromParent(bbox);\n    }\n    return bbox;\n  }\n  /**\n   * Converts a Nodes BBox (or an arbitrary BBox if supplied) from local Node coordinate space\n   * into the Canvas coordinate space.\n   */\n  static toCanvas(node, bbox) {\n    if (bbox == null) {\n      bbox = node.getBBox();\n    } else if (isMatrixTransform(node)) {\n      bbox = node.toParent(bbox);\n    }\n    for (const parent of node.traverseUp()) {\n      if (isMatrixTransform(parent)) {\n        bbox = parent.toParent(bbox);\n      }\n    }\n    return bbox;\n  }\n  /**\n   * Converts a point from canvas coordinate space into the coordinate space of the given Node.\n   */\n  static fromCanvasPoint(node, x, y) {\n    const parents = [];\n    for (const parent of node.traverseUp()) {\n      if (isMatrixTransform(parent)) {\n        parents.unshift(parent);\n      }\n    }\n    for (const parent of parents) {\n      ({ x, y } = parent.fromParentPoint(x, y));\n    }\n    if (isMatrixTransform(node)) {\n      ({ x, y } = node.fromParentPoint(x, y));\n    }\n    return { x, y };\n  }\n  /**\n   * Converts a point from a Nodes local coordinate space into the Canvas coordinate space.\n   */\n  static toCanvasPoint(node, x, y) {\n    if (isMatrixTransform(node)) {\n      ({ x, y } = node.toParentPoint(x, y));\n    }\n    for (const parent of node.traverseUp()) {\n      if (isMatrixTransform(parent)) {\n        ({ x, y } = parent.toParentPoint(x, y));\n      }\n    }\n    return { x, y };\n  }\n};\n\n// packages/ag-charts-community/src/scene/group.ts\nvar _Group = class _Group extends Node {\n  constructor(opts) {\n    super(opts);\n    this.opts = opts;\n    this.opacity = 1;\n    this.isContainerNode = true;\n    this.zIndexSubOrder = opts?.zIndexSubOrder;\n  }\n  static is(value) {\n    return value instanceof _Group;\n  }\n  static computeChildrenBBox(nodes, skipInvisible = true) {\n    return BBox.merge(Node.extractBBoxes(nodes, skipInvisible));\n  }\n  static compareChildren(a, b) {\n    return compoundAscending(\n      [a.zIndex, ...a.zIndexSubOrder ?? [void 0, void 0], a.serialNumber],\n      [b.zIndex, ...b.zIndexSubOrder ?? [void 0, void 0], b.serialNumber],\n      ascendingStringNumberUndefined\n    );\n  }\n  // We consider a group to be boundless, thus any point belongs to it.\n  containsPoint(_x, _y) {\n    return true;\n  }\n  computeBBox() {\n    return _Group.computeChildrenBBox(this.children());\n  }\n  preRender() {\n    const counts = super.preRender();\n    counts.groups += 1;\n    counts.nonGroups -= 1;\n    return counts;\n  }\n  isDirty(renderCtx) {\n    const { resized } = renderCtx;\n    const { dirty, dirtyZIndex } = this;\n    const isDirty = dirty >= 2 /* MINOR */ || dirtyZIndex || resized;\n    let isChildDirty = isDirty;\n    let isChildLayerDirty = false;\n    for (const child of this.children()) {\n      isChildDirty || (isChildDirty = child.layerManager == null && child.dirty >= 1 /* TRIVIAL */);\n      isChildLayerDirty || (isChildLayerDirty = child.layerManager != null && child.dirty >= 1 /* TRIVIAL */);\n      if (isChildDirty)\n        break;\n    }\n    if (this.opts?.name) {\n      this._debug?.({ name: this.opts.name, group: this, isDirty, isChildDirty, renderCtx });\n    }\n    return { isDirty, isChildDirty, isChildLayerDirty };\n  }\n  debugSkip(renderCtx) {\n    if (renderCtx.stats && this.opts?.name) {\n      this._debug?.({\n        name: this.opts.name,\n        group: this,\n        result: \"skipping\",\n        counts: nodeCount(this),\n        renderCtx\n      });\n    }\n  }\n  render(renderCtx, skip) {\n    if (skip) {\n      return super.render(renderCtx);\n    }\n    const { opts: { name } = {}, _debug: debug3 } = this;\n    const { isDirty, isChildDirty, isChildLayerDirty } = this.isDirty(renderCtx);\n    const { ctx, stats } = renderCtx;\n    let { forceRender } = renderCtx;\n    if (!isDirty && !isChildDirty && !isChildLayerDirty && !forceRender) {\n      this.debugSkip(renderCtx);\n      this.markClean({ recursive: false });\n      return;\n    }\n    if (forceRender !== \"dirtyTransform\") {\n      forceRender || (forceRender = this.dirtyZIndex);\n    }\n    ctx.globalAlpha *= this.opacity;\n    if (this.dirtyZIndex) {\n      this.sortChildren(_Group.compareChildren);\n    }\n    const children = this.sortedChildren();\n    const clipBBox = this.renderClip(renderCtx) ?? renderCtx.clipBBox;\n    const renderCtxChanged = forceRender !== renderCtx.forceRender || clipBBox !== renderCtx.clipBBox;\n    this.renderChildren(children, renderCtxChanged ? { ...renderCtx, forceRender, clipBBox } : renderCtx);\n    super.render(renderCtx);\n    if (this.clipRect) {\n      ctx.restore();\n    }\n    for (const child of this.virtualChildren()) {\n      child.markClean({ recursive: \"virtual\" });\n    }\n    if (name && stats) {\n      debug3?.({\n        name,\n        renderCtx,\n        result: \"rendered\",\n        skipped: stats.nodesSkipped,\n        counts: nodeCount(this),\n        group: this\n      });\n    }\n  }\n  sortedChildren() {\n    let children = this.children();\n    if (this.hasVirtualChildren()) {\n      children = [...children].sort(_Group.compareChildren);\n    }\n    return children;\n  }\n  renderClip(renderCtx) {\n    if (!this.clipRect)\n      return;\n    const { x, y, width: width2, height: height2 } = this.clipRect;\n    const { ctx } = renderCtx;\n    ctx.save();\n    ctx.beginPath();\n    ctx.rect(x, y, width2, height2);\n    ctx.clip();\n    this._debug?.(() => ({\n      name: this.opts?.name,\n      clipRect: this.clipRect,\n      ctxTransform: ctx.getTransform(),\n      renderCtx,\n      group: this\n    }));\n    return Transformable.toCanvas(this, this.clipRect);\n  }\n  renderChildren(children, renderCtx) {\n    const { ctx, forceRender, stats } = renderCtx;\n    for (const child of children) {\n      if (!child.visible || !this.visible) {\n        child.markClean();\n        if (stats) {\n          stats.nodesSkipped += nodeCount(child).count;\n        }\n        continue;\n      }\n      if (!forceRender && child.dirty === 0 /* NONE */) {\n        if (stats) {\n          stats.nodesSkipped += nodeCount(child).count;\n        }\n        continue;\n      }\n      ctx.save();\n      child.render(renderCtx);\n      ctx.restore();\n    }\n  }\n  /**\n   * Transforms bbox given in the canvas coordinate space to bbox in this group's coordinate space and\n   * sets this group's clipRect to the transformed bbox.\n   * @param bbox clipRect bbox in the canvas coordinate space.\n   */\n  setClipRect(bbox) {\n    this.clipRect = bbox ? Transformable.fromCanvas(this, bbox) : void 0;\n  }\n  /**\n   * Set the clip rect within the canvas coordinate space.\n   * @param bbox clipRect bbox in the canvas coordinate space.\n   */\n  setClipRectCanvasSpace(bbox) {\n    this.clipRect = bbox;\n  }\n  toSVG() {\n    if (!this.visible)\n      return;\n    const defs = [];\n    const elements2 = [];\n    for (const child of this.sortedChildren()) {\n      const svg = child.toSVG();\n      if (svg != null) {\n        elements2.push(...svg.elements);\n        if (svg.defs != null) {\n          defs.push(...svg.defs);\n        }\n      }\n    }\n    return { elements: elements2, defs };\n  }\n};\n_Group.className = \"Group\";\n__decorateClass([\n  SceneChangeDetection({\n    redraw: 3 /* MAJOR */,\n    convertor: (v) => clamp(0, v, 1)\n  })\n], _Group.prototype, \"opacity\", 2);\nvar Group = _Group;\nvar ScalableGroup = class extends Scalable(Group) {\n};\nvar RotatableGroup = class extends Rotatable(Group) {\n};\nvar TranslatableGroup = class extends Translatable(Group) {\n};\nvar TransformableGroup = class extends Rotatable(Translatable(Group)) {\n};\n\n// packages/ag-charts-community/src/util/debug.ts\nvar LONG_TIME_PERIOD_THRESHOLD = 2e3;\nvar timeOfLastLog = Date.now();\nvar logTimeGap = () => {\n  const timeSinceLastLog = Date.now() - timeOfLastLog;\n  if (timeSinceLastLog > LONG_TIME_PERIOD_THRESHOLD) {\n    const prettyDuration = (Math.floor(timeSinceLastLog / 100) / 10).toFixed(1);\n    Logger.log(`**** ${prettyDuration}s since last log message ****`);\n  }\n  timeOfLastLog = Date.now();\n};\nvar Debug = {\n  create(...debugSelectors) {\n    const resultFn = (...logContent) => {\n      if (Debug.check(...debugSelectors)) {\n        if (typeof logContent[0] === \"function\") {\n          logContent = toArray(logContent[0]());\n        }\n        logTimeGap();\n        Logger.log(...logContent);\n      }\n    };\n    return Object.assign(resultFn, { check: () => Debug.check(...debugSelectors) });\n  },\n  check(...debugSelectors) {\n    if (debugSelectors.length === 0) {\n      debugSelectors.push(true);\n    }\n    const chartDebug = toArray(getWindow(\"agChartsDebug\"));\n    return chartDebug.some((selector) => debugSelectors.includes(selector));\n  }\n};\n\n// packages/ag-charts-community/src/scene/selection.ts\nvar Selection = class _Selection {\n  constructor(parentNode, classOrFactory, autoCleanup = true) {\n    this.parentNode = parentNode;\n    this.autoCleanup = autoCleanup;\n    this.garbageBin = /* @__PURE__ */ new Set();\n    this._nodesMap = /* @__PURE__ */ new Map();\n    this._nodes = [];\n    this.data = [];\n    this.debug = Debug.create(true, \"scene\", \"scene:selections\");\n    this.nodeFactory = Object.prototype.isPrototypeOf.call(Node, classOrFactory) ? () => new classOrFactory() : classOrFactory;\n  }\n  static select(parent, classOrFactory, garbageCollection = true) {\n    return new _Selection(parent, classOrFactory, garbageCollection);\n  }\n  static selectAll(parent, predicate) {\n    const results = [];\n    const traverse = (node) => {\n      if (predicate(node)) {\n        results.push(node);\n      }\n      for (const child of node.children()) {\n        traverse(child);\n      }\n    };\n    traverse(parent);\n    return results;\n  }\n  static selectByClass(node, ...Classes) {\n    return _Selection.selectAll(node, (n) => Classes.some((C) => n instanceof C));\n  }\n  static selectByTag(node, tag) {\n    return _Selection.selectAll(node, (n) => n.tag === tag);\n  }\n  createNode(datum, initializer, idx) {\n    const node = this.nodeFactory(datum);\n    node.datum = datum;\n    initializer?.(node);\n    if (idx == null) {\n      this._nodes.push(node);\n    } else {\n      this._nodes.splice(idx, 0, node);\n    }\n    this.parentNode.appendChild(node);\n    return node;\n  }\n  /**\n   * Update the data in a selection. If an `getDatumId()` function is provided, maintain a list of ids related to\n   * the nodes. Otherwise, take the more efficient route of simply creating and destroying nodes at the end\n   * of the array.\n   */\n  update(data, initializer, getDatumId) {\n    if (this.garbageBin.size > 0) {\n      this.debug(`Selection - update() called with pending garbage: ${data}`);\n    }\n    if (getDatumId) {\n      const dataMap = new Map(\n        data.map((datum, idx) => [getDatumId(datum), [datum, idx]])\n      );\n      for (const [node, datumId] of this._nodesMap.entries()) {\n        if (dataMap.has(datumId)) {\n          const [newDatum] = dataMap.get(datumId);\n          node.datum = newDatum;\n          this.garbageBin.delete(node);\n          dataMap.delete(datumId);\n        } else {\n          this.garbageBin.add(node);\n        }\n      }\n      for (const [datumId, [datum, idx]] of dataMap.entries()) {\n        this._nodesMap.set(this.createNode(datum, initializer, idx), datumId);\n      }\n    } else {\n      const maxLength = Math.max(data.length, this.data.length);\n      for (let i = 0; i < maxLength; i++) {\n        if (i >= data.length) {\n          this.garbageBin.add(this._nodes[i]);\n        } else if (i >= this._nodes.length) {\n          this.createNode(data[i], initializer);\n        } else {\n          this._nodes[i].datum = data[i];\n          this.garbageBin.delete(this._nodes[i]);\n        }\n      }\n    }\n    this.data = data.slice();\n    if (this.autoCleanup) {\n      this.cleanup();\n    }\n    return this;\n  }\n  cleanup() {\n    if (this.garbageBin.size === 0) {\n      return this;\n    }\n    this._nodes = this._nodes.filter((node) => {\n      if (this.garbageBin.has(node)) {\n        this._nodesMap.delete(node);\n        this.garbageBin.delete(node);\n        node.destroy();\n        return false;\n      }\n      return true;\n    });\n    return this;\n  }\n  clear() {\n    this.update([]);\n    return this;\n  }\n  isGarbage(node) {\n    return this.garbageBin.has(node);\n  }\n  hasGarbage() {\n    return this.garbageBin.size > 0;\n  }\n  each(iterate2) {\n    for (const entry of this._nodes.entries()) {\n      iterate2(entry[1], entry[1].datum, entry[0]);\n    }\n    return this;\n  }\n  *[Symbol.iterator]() {\n    for (let index = 0; index < this._nodes.length; index++) {\n      const node = this._nodes[index];\n      yield { node, datum: node.datum, index };\n    }\n  }\n  select(predicate) {\n    return _Selection.selectAll(this.parentNode, predicate);\n  }\n  selectByClass(Class) {\n    return _Selection.selectByClass(this.parentNode, Class);\n  }\n  selectByTag(tag) {\n    return _Selection.selectByTag(this.parentNode, tag);\n  }\n  nodes() {\n    return this._nodes;\n  }\n  at(index) {\n    return this._nodes.at(index);\n  }\n};\n\n// packages/ag-charts-community/src/util/angle.ts\nvar twoPi = Math.PI * 2;\nfunction normalizeAngle360(radians) {\n  radians %= twoPi;\n  radians += twoPi;\n  radians %= twoPi;\n  return radians;\n}\nfunction normalizeAngle360Inclusive(radians) {\n  radians %= twoPi;\n  radians += twoPi;\n  if (radians !== twoPi) {\n    radians %= twoPi;\n  }\n  return radians;\n}\nfunction normalizeAngle180(radians) {\n  radians %= twoPi;\n  if (radians < -Math.PI) {\n    radians += twoPi;\n  } else if (radians >= Math.PI) {\n    radians -= twoPi;\n  }\n  return radians;\n}\nfunction isBetweenAngles(targetAngle, startAngle, endAngle) {\n  const t = normalizeAngle360(targetAngle);\n  const a0 = normalizeAngle360(startAngle);\n  const a1 = normalizeAngle360(endAngle);\n  if (a0 < a1) {\n    return a0 <= t && t <= a1;\n  } else if (a0 > a1) {\n    return a0 <= t || t <= a1;\n  } else {\n    return true;\n  }\n}\nfunction toRadians(degrees) {\n  return degrees / 180 * Math.PI;\n}\nfunction toDegrees(radians) {\n  return radians / Math.PI * 180;\n}\nfunction angleDiff(angle0, angle1, counterClockwise) {\n  if (counterClockwise) {\n    [angle0, angle1] = [angle1, angle0];\n  }\n  const a0 = normalizeAngle360(angle0);\n  const a1 = normalizeAngle360(angle1) + twoPi;\n  return (a1 - a0) % twoPi;\n}\nfunction angleBetween(angle0, angle1) {\n  angle0 = normalizeAngle360(angle0);\n  angle1 = normalizeAngle360(angle1);\n  return angle1 - angle0 + (angle0 > angle1 ? 2 * Math.PI : 0);\n}\nfunction displacePointFromVector(centerX, centerY, radius, angle2) {\n  const x = centerX + radius * Math.cos(angle2);\n  const y = centerY + radius * Math.sin(angle2);\n  return { x, y };\n}\nvar delta = 1e-6;\nfunction clockwiseAngle(angle2, relativeToStartAngle) {\n  if (angleBetween(angle2, relativeToStartAngle) < delta) {\n    return relativeToStartAngle;\n  } else {\n    return normalizeAngle360(angle2 - relativeToStartAngle) + relativeToStartAngle;\n  }\n}\nfunction clockwiseAngles(startAngle, endAngle, relativeToStartAngle = 0) {\n  const fullPie = Math.abs(endAngle - startAngle) >= 2 * Math.PI;\n  const sweepAngle = fullPie ? 2 * Math.PI : normalizeAngle360(endAngle - startAngle);\n  startAngle = clockwiseAngle(startAngle, relativeToStartAngle);\n  endAngle = startAngle + sweepAngle;\n  return { startAngle, endAngle };\n}\n\n// packages/ag-charts-community/src/util/distance.ts\nfunction pointsDistanceSquared(x1, y1, x2, y2) {\n  const dx = x1 - x2;\n  const dy = y1 - y2;\n  return dx * dx + dy * dy;\n}\nfunction lineDistanceSquared(x, y, x1, y1, x2, y2, best) {\n  if (x1 === x2 && y1 === y2) {\n    return Math.min(best, pointsDistanceSquared(x, y, x1, y1));\n  }\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  const t = Math.max(0, Math.min(1, ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy)));\n  const ix = x1 + t * dx;\n  const iy = y1 + t * dy;\n  return Math.min(best, pointsDistanceSquared(x, y, ix, iy));\n}\nfunction arcDistanceSquared(x, y, cx, cy, radius, startAngle, endAngle, counterClockwise, best) {\n  if (counterClockwise) {\n    [endAngle, startAngle] = [startAngle, endAngle];\n  }\n  const angle2 = Math.atan2(y - cy, x - cx);\n  if (!isBetweenAngles(angle2, startAngle, endAngle)) {\n    const startX = cx + Math.cos(startAngle) * radius;\n    const startY = cy + Math.sin(startAngle) * radius;\n    const endX = cx + Math.cos(startAngle) * radius;\n    const endY = cy + Math.sin(startAngle) * radius;\n    return Math.min(best, pointsDistanceSquared(x, y, startX, startY), pointsDistanceSquared(x, y, endX, endY));\n  }\n  const distToArc = radius - Math.sqrt(pointsDistanceSquared(x, y, cx, cy));\n  return Math.min(best, distToArc * distToArc);\n}\n\n// packages/ag-charts-community/src/scale/colorScale.ts\nvar convertColorStringToOklcha = (v) => {\n  const color = Color.fromString(v);\n  const [l, c, h] = Color.RGBtoOKLCH(color.r, color.g, color.b);\n  return { l, c, h, a: color.a };\n};\nvar delta2 = 1e-6;\nvar isAchromatic = (x) => x.c < delta2 || x.l < delta2 || x.l > 1 - delta2;\nvar interpolateOklch = (x, y, d) => {\n  d = clamp(0, d, 1);\n  let h;\n  if (isAchromatic(x)) {\n    h = y.h;\n  } else if (isAchromatic(y)) {\n    h = x.h;\n  } else {\n    const xH = x.h;\n    let yH = y.h;\n    const deltaH = y.h - x.h;\n    if (deltaH > 180) {\n      yH -= 360;\n    } else if (deltaH < -180) {\n      yH += 360;\n    }\n    h = xH * (1 - d) + yH * d;\n  }\n  const c = x.c * (1 - d) + y.c * d;\n  const l = x.l * (1 - d) + y.l * d;\n  const a = x.a * (1 - d) + y.a * d;\n  return Color.fromOKLCH(l, c, h, a);\n};\nvar ColorScale = class {\n  constructor() {\n    this.type = \"color\";\n    this.invalid = true;\n    this.domain = [0, 1];\n    this.range = [\"red\", \"blue\"];\n    this.parsedRange = this.range.map(convertColorStringToOklcha);\n  }\n  update() {\n    const { domain, range: range3 } = this;\n    if (domain.length < 2) {\n      Logger.warnOnce(\"`colorDomain` should have at least 2 values.\");\n      if (domain.length === 0) {\n        domain.push(0, 1);\n      } else if (domain.length === 1) {\n        domain.push(domain[0] + 1);\n      }\n    }\n    for (let i = 1; i < domain.length; i++) {\n      const a = domain[i - 1];\n      const b = domain[i];\n      if (a >= b) {\n        Logger.warnOnce(\"`colorDomain` values should be supplied in ascending order.\");\n        domain.sort((a2, b2) => a2 - b2);\n        break;\n      }\n    }\n    if (range3.length < domain.length) {\n      for (let i = range3.length; i < domain.length; i++) {\n        range3.push(range3.length > 0 ? range3[0] : \"black\");\n      }\n    }\n    this.parsedRange = this.range.map(convertColorStringToOklcha);\n  }\n  convert(x) {\n    this.refresh();\n    const { domain, range: range3, parsedRange } = this;\n    const d0 = domain[0];\n    const d1 = domain.at(-1);\n    const r0 = range3[0];\n    const r1 = range3[range3.length - 1];\n    if (x <= d0) {\n      return r0;\n    }\n    if (x >= d1) {\n      return r1;\n    }\n    let index;\n    let q;\n    if (domain.length === 2) {\n      const t = (x - d0) / (d1 - d0);\n      const step = 1 / (range3.length - 1);\n      index = range3.length <= 2 ? 0 : Math.min(Math.floor(t * (range3.length - 1)), range3.length - 2);\n      q = (t - index * step) / step;\n    } else {\n      for (index = 0; index < domain.length - 2; index++) {\n        if (x < domain[index + 1]) {\n          break;\n        }\n      }\n      const a = domain[index];\n      const b = domain[index + 1];\n      q = (x - a) / (b - a);\n    }\n    const c0 = parsedRange[index];\n    const c1 = parsedRange[index + 1];\n    return interpolateOklch(c0, c1, q).toRgbaString();\n  }\n  refresh() {\n    if (!this.invalid)\n      return;\n    this.invalid = false;\n    this.update();\n    if (this.invalid) {\n      Logger.warnOnce(\"Expected update to not invalidate scale\");\n    }\n  }\n};\n__decorateClass([\n  Invalidating\n], ColorScale.prototype, \"domain\", 2);\n__decorateClass([\n  Invalidating\n], ColorScale.prototype, \"range\", 2);\n\n// packages/ag-charts-community/src/scene/gradient/gradient.ts\nvar Gradient = class {\n  constructor(colorSpace, stops = [], bbox) {\n    this.colorSpace = colorSpace;\n    this.stops = stops;\n    this.bbox = bbox;\n    this._cache = void 0;\n  }\n  createGradient(ctx, shapeBbox) {\n    const bbox = this.bbox ?? shapeBbox;\n    if (this._cache != null && this._cache.ctx === ctx && this._cache.bbox.equals(bbox)) {\n      return this._cache.gradient;\n    }\n    const { stops, colorSpace } = this;\n    if (stops.length === 0)\n      return;\n    if (stops.length === 1)\n      return stops[0].color;\n    let gradient2 = this.createCanvasGradient(ctx, bbox);\n    if (gradient2 == null)\n      return;\n    const isOkLch = colorSpace === \"oklch\";\n    const step = 0.05;\n    let c0 = stops[0];\n    gradient2.addColorStop(c0.offset, c0.color);\n    for (let i = 1; i < stops.length; i += 1) {\n      const c1 = stops[i];\n      if (isOkLch) {\n        const scale2 = new ColorScale();\n        scale2.domain = [c0.offset, c1.offset];\n        scale2.range = [c0.color, c1.color];\n        for (let offset4 = c0.offset + step; offset4 < c1.offset; offset4 += step) {\n          gradient2.addColorStop(offset4, scale2.convert(offset4));\n        }\n      }\n      gradient2.addColorStop(c1.offset, c1.color);\n      c0 = c1;\n    }\n    if (\"createPattern\" in gradient2) {\n      gradient2 = gradient2.createPattern();\n    }\n    this._cache = { ctx, bbox, gradient: gradient2 };\n    return gradient2;\n  }\n};\n\n// packages/ag-charts-community/src/scene/gradient/linearGradient.ts\nvar LinearGradient = class extends Gradient {\n  constructor(colorSpace, stops, angle2 = 0, bbox) {\n    super(colorSpace, stops, bbox);\n    this.angle = angle2;\n  }\n  createCanvasGradient(ctx, bbox) {\n    const angleOffset = 90;\n    const { angle: angle2 } = this;\n    const radians = normalizeAngle360(toRadians(angle2 + angleOffset));\n    const cos = Math.cos(radians);\n    const sin = Math.sin(radians);\n    const w = bbox.width;\n    const h = bbox.height;\n    const cx = bbox.x + w * 0.5;\n    const cy = bbox.y + h * 0.5;\n    const diagonal = Math.sqrt(h * h + w * w) / 2;\n    const diagonalAngle = Math.atan2(h, w);\n    let quarteredAngle;\n    if (radians < Math.PI / 2) {\n      quarteredAngle = radians;\n    } else if (radians < Math.PI) {\n      quarteredAngle = Math.PI - radians;\n    } else if (radians < 1.5 * Math.PI) {\n      quarteredAngle = radians - Math.PI;\n    } else {\n      quarteredAngle = 2 * Math.PI - radians;\n    }\n    const l = diagonal * Math.abs(Math.cos(quarteredAngle - diagonalAngle));\n    return ctx.createLinearGradient(cx + cos * l, cy + sin * l, cx - cos * l, cy - sin * l);\n  }\n};\n\n// packages/ag-charts-community/src/scene/shape/shape.ts\nvar LINEAR_GRADIENT_REGEXP = /^linear-gradient\\((-?[\\d.]+)deg,(.*?)\\)$/i;\nvar _Shape = class _Shape extends Node {\n  constructor() {\n    super(...arguments);\n    this.fillOpacity = 1;\n    this.strokeOpacity = 1;\n    this.fill = _Shape.defaultStyles.fill;\n    this.stroke = _Shape.defaultStyles.stroke;\n    this.strokeWidth = _Shape.defaultStyles.strokeWidth;\n    this.lineDash = _Shape.defaultStyles.lineDash;\n    this.lineDashOffset = _Shape.defaultStyles.lineDashOffset;\n    this.lineCap = _Shape.defaultStyles.lineCap;\n    this.lineJoin = _Shape.defaultStyles.lineJoin;\n    this.miterLimit = void 0;\n    this.opacity = _Shape.defaultStyles.opacity;\n    this.fillShadow = _Shape.defaultStyles.fillShadow;\n  }\n  /**\n   * Restores the default styles introduced by this subclass.\n   */\n  restoreOwnStyles() {\n    const { defaultStyles } = this.constructor;\n    Object.assign(this, defaultStyles);\n  }\n  onFillChange() {\n    const { fill } = this;\n    let linearGradientMatch;\n    if (fill instanceof Gradient) {\n      this.gradient = fill;\n    } else if (fill?.startsWith(\"linear-gradient\") && (linearGradientMatch = LINEAR_GRADIENT_REGEXP.exec(fill))) {\n      const angle2 = parseFloat(linearGradientMatch[1]);\n      const colors = [];\n      const colorsPart = linearGradientMatch[2];\n      const colorRegex = /(#[0-9a-f]+)|(rgba?\\(.+?\\))|([a-z]+)/gi;\n      let c;\n      while (c = colorRegex.exec(colorsPart)) {\n        colors.push(c[0]);\n      }\n      this.gradient = new LinearGradient(\n        \"rgb\",\n        colors.map((color, index) => ({ color, offset: index / (colors.length - 1) })),\n        angle2\n      );\n    } else {\n      this.gradient = void 0;\n    }\n  }\n  /**\n   * Returns a device-pixel aligned coordinate (or length if length is supplied).\n   *\n   * NOTE: Not suitable for strokes, since the stroke needs to be offset to the middle\n   * of a device pixel.\n   */\n  align(start2, length2) {\n    const pixelRatio = this.layerManager?.canvas?.pixelRatio ?? 1;\n    const alignedStart = Math.round(start2 * pixelRatio) / pixelRatio;\n    if (length2 == null) {\n      return alignedStart;\n    } else if (length2 === 0) {\n      return 0;\n    } else if (length2 < 1) {\n      return Math.ceil(length2 * pixelRatio) / pixelRatio;\n    }\n    return Math.round((length2 + start2) * pixelRatio) / pixelRatio - alignedStart;\n  }\n  fillStroke(ctx, path) {\n    this.renderFill(ctx, path);\n    this.renderStroke(ctx, path);\n  }\n  renderFill(ctx, path) {\n    if (this.fill) {\n      const { globalAlpha } = ctx;\n      this.applyFill(ctx);\n      this.applyFillAlpha(ctx);\n      this.applyShadow(ctx);\n      this.executeFill(ctx, path);\n      ctx.globalAlpha = globalAlpha;\n    }\n    ctx.shadowColor = \"rgba(0, 0, 0, 0)\";\n  }\n  executeFill(ctx, path) {\n    path ? ctx.fill(path) : ctx.fill();\n  }\n  applyFill(ctx) {\n    ctx.fillStyle = this.gradient?.createGradient(ctx, this.getBBox()) ?? (typeof this.fill === \"string\" ? this.fill : void 0) ?? \"black\";\n  }\n  applyFillAlpha(ctx) {\n    ctx.globalAlpha *= this.opacity * this.fillOpacity;\n  }\n  applyShadow(ctx) {\n    const pixelRatio = this.layerManager?.canvas.pixelRatio ?? 1;\n    const fillShadow = this.fillShadow;\n    if (fillShadow?.enabled) {\n      ctx.shadowColor = fillShadow.color;\n      ctx.shadowOffsetX = fillShadow.xOffset * pixelRatio;\n      ctx.shadowOffsetY = fillShadow.yOffset * pixelRatio;\n      ctx.shadowBlur = fillShadow.blur * pixelRatio;\n    }\n  }\n  renderStroke(ctx, path) {\n    if (this.stroke && this.strokeWidth) {\n      const { globalAlpha } = ctx;\n      ctx.strokeStyle = this.stroke;\n      ctx.globalAlpha *= this.opacity * this.strokeOpacity;\n      ctx.lineWidth = this.strokeWidth;\n      if (this.lineDash) {\n        ctx.setLineDash(this.lineDash);\n      }\n      if (this.lineDashOffset) {\n        ctx.lineDashOffset = this.lineDashOffset;\n      }\n      if (this.lineCap) {\n        ctx.lineCap = this.lineCap;\n      }\n      if (this.lineJoin) {\n        ctx.lineJoin = this.lineJoin;\n      }\n      if (this.miterLimit != null) {\n        ctx.miterLimit = this.miterLimit;\n      }\n      this.executeStroke(ctx, path);\n      ctx.globalAlpha = globalAlpha;\n    }\n  }\n  executeStroke(ctx, path) {\n    path ? ctx.stroke(path) : ctx.stroke();\n  }\n  containsPoint(x, y) {\n    return this.isPointInPath(x, y);\n  }\n};\n/**\n * Defaults for style properties. Note that properties that affect the position\n * and shape of the node are not considered style properties, for example:\n * `x`, `y`, `width`, `height`, `radius`, `rotation`, etc.\n * Can be used to reset to the original styling after some custom styling\n * has been applied (using the `restoreOwnStyles` method).\n * These static defaults are meant to be inherited by subclasses.\n */\n_Shape.defaultStyles = {\n  fill: \"black\",\n  stroke: void 0,\n  strokeWidth: 0,\n  lineDash: void 0,\n  lineDashOffset: 0,\n  lineCap: void 0,\n  lineJoin: void 0,\n  opacity: 1,\n  fillShadow: void 0\n};\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */, changeCb: (s) => s.onFillChange() })\n], _Shape.prototype, \"fill\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"stroke\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"lineDash\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"lineCap\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"lineJoin\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"miterLimit\", 2);\n__decorateClass([\n  SceneChangeDetection({\n    redraw: 2 /* MINOR */,\n    convertor: (v) => clamp(0, v, 1)\n  })\n], _Shape.prototype, \"opacity\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */, checkDirtyOnAssignment: true })\n], _Shape.prototype, \"fillShadow\", 2);\nvar Shape = _Shape;\n\n// packages/ag-charts-community/src/scene/shape/line.ts\nvar Line = class extends Shape {\n  constructor(opts = {}) {\n    super(opts);\n    this.x1 = 0;\n    this.y1 = 0;\n    this.x2 = 0;\n    this.y2 = 0;\n    this.restoreOwnStyles();\n  }\n  set x(value) {\n    this.x1 = value;\n    this.x2 = value;\n  }\n  set y(value) {\n    this.y1 = value;\n    this.y2 = value;\n  }\n  get midPoint() {\n    return { x: (this.x1 + this.x2) / 2, y: (this.y1 + this.y2) / 2 };\n  }\n  computeBBox() {\n    return new BBox(\n      Math.min(this.x1, this.x2),\n      Math.min(this.y1, this.y2),\n      Math.abs(this.x2 - this.x1),\n      Math.abs(this.y2 - this.y1)\n    );\n  }\n  isPointInPath(x, y) {\n    if (this.x1 === this.x2 || this.y1 === this.y2) {\n      return this.getBBox().clone().grow(this.strokeWidth / 2).containsPoint(x, y);\n    }\n    return false;\n  }\n  distanceSquared(px, py) {\n    const { x1, y1, x2, y2 } = this;\n    return lineDistanceSquared(px, py, x1, y1, x2, y2, Infinity);\n  }\n  render(renderCtx) {\n    const { ctx, forceRender, stats, devicePixelRatio } = renderCtx;\n    if (this.dirty === 0 /* NONE */ && !forceRender) {\n      if (stats)\n        stats.nodesSkipped += nodeCount(this).count;\n      return;\n    }\n    let { x1, y1, x2, y2 } = this;\n    if (x1 === x2) {\n      const { strokeWidth } = this;\n      const x = Math.round(x1 * devicePixelRatio) / devicePixelRatio + Math.trunc(strokeWidth * devicePixelRatio) % 2 / (devicePixelRatio * 2);\n      x1 = x;\n      x2 = x;\n    } else if (y1 === y2) {\n      const { strokeWidth } = this;\n      const y = Math.round(y1 * devicePixelRatio) / devicePixelRatio + Math.trunc(strokeWidth * devicePixelRatio) % 2 / (devicePixelRatio * 2);\n      y1 = y;\n      y2 = y;\n    }\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n    this.fillStroke(ctx);\n    this.fillShadow?.markClean();\n    super.render(renderCtx);\n  }\n  toSVG() {\n    if (!this.visible)\n      return;\n    const element2 = document.createElementNS(\"http://www.w3.org/2000/svg\", \"line\");\n    element2.setAttribute(\"x1\", String(this.x1));\n    element2.setAttribute(\"y1\", String(this.y1));\n    element2.setAttribute(\"x2\", String(this.x2));\n    element2.setAttribute(\"y2\", String(this.y2));\n    element2.setAttribute(\"stroke\", this.stroke ?? \"none\");\n    element2.setAttribute(\"stroke-opacity\", String(this.strokeOpacity));\n    element2.setAttribute(\"stroke-width\", String(this.strokeWidth));\n    return {\n      elements: [element2]\n    };\n  }\n};\nLine.className = \"Line\";\nLine.defaultStyles = { ...Shape.defaultStyles, fill: void 0, strokeWidth: 1 };\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Line.prototype, \"x1\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Line.prototype, \"y1\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Line.prototype, \"x2\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Line.prototype, \"y2\", 2);\n\n// packages/ag-charts-community/src/util/canvas.util.ts\nfunction createCanvasContext(width2 = 0, height2 = 0) {\n  const canvas = createElement(\"canvas\");\n  canvas.style.display = \"block\";\n  canvas.style.width = width2 + \"px\";\n  canvas.style.height = height2 + \"px\";\n  return canvas.getContext(\"2d\");\n}\n\n// packages/ag-charts-community/src/util/lruCache.ts\nvar LRUCache = class {\n  constructor(maxCacheSize = 5) {\n    this.maxCacheSize = maxCacheSize;\n    this.store = /* @__PURE__ */ new Map();\n  }\n  get(key) {\n    if (!this.store.has(key))\n      return void 0;\n    const hit = this.store.get(key);\n    this.store.delete(key);\n    this.store.set(key, hit);\n    return hit;\n  }\n  has(key) {\n    return this.store.has(key);\n  }\n  set(key, value) {\n    this.store.set(key, value);\n    if (this.store.size > this.maxCacheSize) {\n      const iterator = this.store.keys();\n      let evictCount = this.store.size - this.maxCacheSize;\n      while (evictCount > 0) {\n        const evictKeyIterator = iterator.next();\n        if (!evictKeyIterator.done) {\n          this.store.delete(evictKeyIterator.value);\n        }\n        evictCount--;\n      }\n    }\n    return value;\n  }\n  clear() {\n    this.store.clear();\n  }\n};\n\n// packages/ag-charts-community/src/util/textMeasurer.ts\nvar CachedTextMeasurerPool = class {\n  // Measures the dimensions of the provided text, handling multiline if needed.\n  static measureText(text, options) {\n    const textMeasurer = this.getMeasurer(options);\n    return textMeasurer.measureText(text);\n  }\n  static measureLines(text, options) {\n    const textMeasurer = this.getMeasurer(options);\n    return textMeasurer.measureLines(text);\n  }\n  // Gets a TextMeasurer instance, configuring text alignment and baseline if provided.\n  static getMeasurer(options) {\n    const font = typeof options.font === \"string\" ? options.font : TextUtils.toFontString(options.font);\n    const key = `${font}-${options.textAlign ?? \"start\"}-${options.textBaseline ?? \"alphabetic\"}`;\n    return this.instanceMap.get(key) ?? this.createFontMeasurer(font, options, key);\n  }\n  // Creates or retrieves a TextMeasurer instance for a specific font.\n  static createFontMeasurer(font, options, key) {\n    const ctx = createCanvasContext();\n    ctx.font = font;\n    ctx.textAlign = options.textAlign ?? \"start\";\n    ctx.textBaseline = options.textBaseline ?? \"alphabetic\";\n    const measurer = new CachedTextMeasurer(ctx, options);\n    this.instanceMap.set(key, measurer);\n    return measurer;\n  }\n};\nCachedTextMeasurerPool.instanceMap = new LRUCache(10);\nvar CachedTextMeasurer = class {\n  constructor(ctx, options) {\n    this.ctx = ctx;\n    // cached text measurements\n    this.measureMap = new LRUCache(100);\n    if (options.textAlign) {\n      ctx.textAlign = options.textAlign;\n    }\n    if (options.textBaseline) {\n      ctx.textBaseline = options.textBaseline;\n    }\n    ctx.font = typeof options.font === \"string\" ? options.font : TextUtils.toFontString(options.font);\n    this.textMeasurer = new SimpleTextMeasurer(\n      (t) => this.cachedCtxMeasureText(t),\n      options.textBaseline ?? \"alphabetic\"\n    );\n  }\n  textWidth(text, estimate) {\n    return this.textMeasurer.textWidth(text, estimate);\n  }\n  measureText(text) {\n    return this.textMeasurer.measureText(text);\n  }\n  measureLines(text) {\n    return this.textMeasurer.measureLines(text);\n  }\n  cachedCtxMeasureText(text) {\n    if (!this.measureMap.has(text)) {\n      const rawResult = this.ctx.measureText(text);\n      this.measureMap.set(text, {\n        actualBoundingBoxAscent: rawResult.actualBoundingBoxAscent,\n        emHeightAscent: rawResult.emHeightAscent,\n        emHeightDescent: rawResult.emHeightDescent,\n        actualBoundingBoxDescent: rawResult.actualBoundingBoxDescent,\n        actualBoundingBoxLeft: rawResult.actualBoundingBoxLeft,\n        actualBoundingBoxRight: rawResult.actualBoundingBoxRight,\n        alphabeticBaseline: rawResult.alphabeticBaseline,\n        fontBoundingBoxAscent: rawResult.fontBoundingBoxAscent,\n        fontBoundingBoxDescent: rawResult.fontBoundingBoxDescent,\n        hangingBaseline: rawResult.hangingBaseline,\n        ideographicBaseline: rawResult.ideographicBaseline,\n        width: rawResult.width\n      });\n    }\n    return this.measureMap.get(text);\n  }\n};\nvar TextUtils = class {\n  static toFontString({ fontSize = 10, fontStyle, fontWeight, fontFamily, lineHeight }) {\n    let fontString = \"\";\n    if (fontStyle) {\n      fontString += `${fontStyle} `;\n    }\n    if (fontWeight) {\n      fontString += `${fontWeight} `;\n    }\n    fontString += `${fontSize}px`;\n    if (lineHeight) {\n      fontString += `/${lineHeight}px`;\n    }\n    fontString += ` ${fontFamily}`;\n    return fontString.trim();\n  }\n  static getLineHeight(fontSize) {\n    return Math.ceil(fontSize * this.defaultLineHeight);\n  }\n  // Determines vertical offset modifier based on text baseline.\n  static getVerticalModifier(textBaseline) {\n    switch (textBaseline) {\n      case \"hanging\":\n      case \"top\":\n        return 0;\n      case \"middle\":\n        return 0.5;\n      case \"alphabetic\":\n      case \"bottom\":\n      case \"ideographic\":\n      default:\n        return 1;\n    }\n  }\n};\nTextUtils.EllipsisChar = \"\\u2026\";\n// Representation for text clipping.\nTextUtils.defaultLineHeight = 1.15;\n// Normally between 1.1 and 1.2\nTextUtils.lineSplitter = /\\r?\\n/g;\nvar SimpleTextMeasurer = class {\n  constructor(measureTextFn, textBaseline = \"alphabetic\") {\n    this.measureTextFn = measureTextFn;\n    this.textBaseline = textBaseline;\n    // local chars width cache per TextMeasurer\n    this.charMap = /* @__PURE__ */ new Map();\n  }\n  // Measures metrics for a single line of text.\n  getMetrics(text) {\n    const m = this.measureTextFn(text);\n    m.fontBoundingBoxAscent ?? (m.fontBoundingBoxAscent = m.emHeightAscent);\n    m.fontBoundingBoxDescent ?? (m.fontBoundingBoxDescent = m.emHeightDescent);\n    return {\n      width: m.width,\n      height: m.actualBoundingBoxAscent + m.actualBoundingBoxDescent,\n      lineHeight: m.fontBoundingBoxAscent + m.fontBoundingBoxDescent,\n      offsetTop: m.actualBoundingBoxAscent,\n      offsetLeft: m.actualBoundingBoxLeft\n    };\n  }\n  // Calculates aggregated metrics for multiline text.\n  getMultilineMetrics(lines) {\n    let width2 = 0;\n    let height2 = 0;\n    let offsetTop = 0;\n    let offsetLeft = 0;\n    let baselineDistance = 0;\n    const verticalModifier = TextUtils.getVerticalModifier(this.textBaseline);\n    const lineMetrics = [];\n    let index = 0;\n    const length2 = lines.length;\n    for (const line of lines) {\n      const m = this.measureTextFn(line);\n      m.fontBoundingBoxAscent ?? (m.fontBoundingBoxAscent = m.emHeightAscent);\n      m.fontBoundingBoxDescent ?? (m.fontBoundingBoxDescent = m.emHeightDescent);\n      if (width2 < m.width) {\n        width2 = m.width;\n      }\n      if (offsetLeft < m.actualBoundingBoxLeft) {\n        offsetLeft = m.actualBoundingBoxLeft;\n      }\n      if (index === 0) {\n        height2 += m.actualBoundingBoxAscent;\n        offsetTop += m.actualBoundingBoxAscent;\n      } else {\n        baselineDistance += m.fontBoundingBoxAscent;\n      }\n      if (index === length2 - 1) {\n        height2 += m.actualBoundingBoxDescent;\n      } else {\n        baselineDistance += m.fontBoundingBoxDescent;\n      }\n      lineMetrics.push({\n        text: line,\n        width: m.width,\n        height: m.actualBoundingBoxAscent + m.actualBoundingBoxDescent,\n        lineHeight: m.fontBoundingBoxAscent + m.fontBoundingBoxDescent,\n        offsetTop: m.actualBoundingBoxAscent,\n        offsetLeft: m.actualBoundingBoxLeft\n      });\n      index++;\n    }\n    height2 += baselineDistance;\n    offsetTop += baselineDistance * verticalModifier;\n    return { width: width2, height: height2, offsetTop, offsetLeft, lineMetrics };\n  }\n  textWidth(text, estimate) {\n    if (estimate) {\n      let estimatedWidth = 0;\n      for (let i = 0; i < text.length; i++) {\n        estimatedWidth += this.textWidth(text.charAt(i));\n      }\n      return estimatedWidth;\n    }\n    if (text.length > 1) {\n      return this.measureTextFn(text).width;\n    }\n    return this.charMap.get(text) ?? this.charWidth(text);\n  }\n  measureText(text) {\n    return this.getMetrics(text);\n  }\n  // Measures the dimensions of the provided text, handling multiline if needed.\n  measureLines(text) {\n    const lines = typeof text === \"string\" ? text.split(TextUtils.lineSplitter) : text;\n    return this.getMultilineMetrics(lines);\n  }\n  charWidth(char) {\n    const { width: width2 } = this.measureTextFn(char);\n    this.charMap.set(char, width2);\n    return width2;\n  }\n};\n\n// packages/ag-charts-community/src/scene/shape/text.ts\nvar _Text = class _Text extends Shape {\n  constructor() {\n    super(...arguments);\n    this.x = 0;\n    this.y = 0;\n    this.lines = [];\n    this.text = void 0;\n    this.fontSize = 10;\n    this.fontFamily = \"sans-serif\";\n    this.textAlign = _Text.defaultStyles.textAlign;\n    this.textBaseline = _Text.defaultStyles.textBaseline;\n  }\n  onTextChange() {\n    this.lines = this.text?.split(\"\\n\").map((s) => s.trim()) ?? [];\n  }\n  static computeBBox(lines, x, y, opts) {\n    const { offsetTop, offsetLeft, width: width2, height: height2 } = CachedTextMeasurerPool.measureLines(lines, opts);\n    return new BBox(x - offsetLeft, y - offsetTop, width2, height2);\n  }\n  computeBBox() {\n    const { x, y, lines, textBaseline, textAlign } = this;\n    return _Text.computeBBox(lines, x, y, { font: this, textBaseline, textAlign });\n  }\n  isPointInPath(x, y) {\n    const bbox = this.getBBox();\n    return bbox ? bbox.containsPoint(x, y) : false;\n  }\n  render(renderCtx) {\n    const { ctx, forceRender, stats } = renderCtx;\n    if (this.dirty === 0 /* NONE */ && !forceRender) {\n      if (stats)\n        stats.nodesSkipped += nodeCount(this).count;\n      return;\n    }\n    if (!this.lines.length || !this.layerManager) {\n      if (stats)\n        stats.nodesSkipped += nodeCount(this).count;\n      return;\n    }\n    const { fill, stroke, strokeWidth } = this;\n    const { pixelRatio } = this.layerManager.canvas;\n    ctx.font = TextUtils.toFontString(this);\n    ctx.textAlign = this.textAlign;\n    ctx.textBaseline = this.textBaseline;\n    if (fill) {\n      this.applyFill(ctx);\n      ctx.globalAlpha *= this.opacity * this.fillOpacity;\n      const { fillShadow } = this;\n      if (fillShadow?.enabled) {\n        ctx.shadowColor = fillShadow.color;\n        ctx.shadowOffsetX = fillShadow.xOffset * pixelRatio;\n        ctx.shadowOffsetY = fillShadow.yOffset * pixelRatio;\n        ctx.shadowBlur = fillShadow.blur * pixelRatio;\n      }\n      this.renderLines((line, x, y) => ctx.fillText(line, x, y));\n    }\n    if (stroke && strokeWidth) {\n      ctx.strokeStyle = stroke;\n      ctx.lineWidth = strokeWidth;\n      ctx.globalAlpha *= this.opacity * this.strokeOpacity;\n      const { lineDash, lineDashOffset, lineCap, lineJoin } = this;\n      if (lineDash) {\n        ctx.setLineDash(lineDash);\n      }\n      if (lineDashOffset) {\n        ctx.lineDashOffset = lineDashOffset;\n      }\n      if (lineCap) {\n        ctx.lineCap = lineCap;\n      }\n      if (lineJoin) {\n        ctx.lineJoin = lineJoin;\n      }\n      this.renderLines((line, x, y) => ctx.strokeText(line, x, y));\n    }\n    super.render(renderCtx);\n  }\n  renderLines(renderCallback) {\n    const { lines, x, y } = this;\n    const lineHeight = this.lineHeight ?? TextUtils.getLineHeight(this.fontSize);\n    let offsetY = (lineHeight - lineHeight * lines.length) * TextUtils.getVerticalModifier(this.textBaseline);\n    for (const line of lines) {\n      renderCallback(line, x, y + offsetY);\n      offsetY += lineHeight;\n    }\n  }\n  setFont(props) {\n    this.fontFamily = props.fontFamily;\n    this.fontSize = props.fontSize;\n    this.fontStyle = props.fontStyle;\n    this.fontWeight = props.fontWeight;\n  }\n  setAlign(props) {\n    this.textAlign = props.textAlign;\n    this.textBaseline = props.textBaseline;\n  }\n  toSVG() {\n    if (!this.visible || !this.text)\n      return;\n    const element2 = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n    element2.setAttribute(\"font-family\", this.fontFamily?.split(\",\")[0] ?? \"\");\n    element2.setAttribute(\"font-size\", String(this.fontSize));\n    element2.setAttribute(\"font-style\", this.fontStyle ?? \"\");\n    element2.setAttribute(\"font-weight\", String(this.fontWeight ?? \"\"));\n    element2.setAttribute(\n      \"text-anchor\",\n      {\n        center: \"middle\",\n        left: \"start\",\n        right: \"end\",\n        start: \"start\",\n        end: \"end\"\n      }[this.textAlign ?? \"start\"]\n    );\n    element2.setAttribute(\n      \"alignment-baseline\",\n      {\n        alphabetic: \"alphabetic\",\n        top: \"top\",\n        bottom: \"bottom\",\n        hanging: \"hanging\",\n        middle: \"middle\",\n        ideographic: \"ideographic\"\n      }[this.textBaseline ?? \"alphabetic\"]\n    );\n    element2.setAttribute(\"x\", String(this.x));\n    element2.setAttribute(\"y\", String(this.y));\n    element2.textContent = this.text ?? \"\";\n    return { elements: [element2] };\n  }\n};\n_Text.className = \"Text\";\n_Text.defaultStyles = {\n  ...Shape.defaultStyles,\n  textAlign: \"start\",\n  fontStyle: void 0,\n  fontWeight: void 0,\n  fontSize: 10,\n  fontFamily: \"sans-serif\",\n  textBaseline: \"alphabetic\"\n};\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], _Text.prototype, \"x\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], _Text.prototype, \"y\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */, changeCb: (o) => o.onTextChange() })\n], _Text.prototype, \"text\", 2);\n__decorateClass([\n  SceneChangeDetection()\n], _Text.prototype, \"fontStyle\", 2);\n__decorateClass([\n  SceneChangeDetection()\n], _Text.prototype, \"fontWeight\", 2);\n__decorateClass([\n  SceneChangeDetection()\n], _Text.prototype, \"fontSize\", 2);\n__decorateClass([\n  SceneChangeDetection()\n], _Text.prototype, \"fontFamily\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], _Text.prototype, \"textAlign\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], _Text.prototype, \"textBaseline\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], _Text.prototype, \"lineHeight\", 2);\nvar Text = _Text;\nvar RotatableText = class extends Rotatable(Text) {\n};\nvar TransformableText = class extends Rotatable(Translatable(Text)) {\n};\n\n// packages/ag-charts-community/src/scene/util/labelPlacement.ts\nfunction circleRectOverlap(c, unitCenter, x, y, w, h) {\n  if (c.size === 0) {\n    return false;\n  }\n  let cx = c.x;\n  let cy = c.y;\n  if (unitCenter != null) {\n    cx -= (unitCenter.x - 0.5) * c.size;\n    cy -= (unitCenter.y - 0.5) * c.size;\n  }\n  let edgeX = cx;\n  if (cx < x) {\n    edgeX = x;\n  } else if (cx > x + w) {\n    edgeX = x + w;\n  }\n  let edgeY = cy;\n  if (cy < y) {\n    edgeY = y;\n  } else if (cy > y + h) {\n    edgeY = y + h;\n  }\n  const dx = cx - edgeX;\n  const dy = cy - edgeY;\n  const d = Math.sqrt(dx * dx + dy * dy);\n  return d <= c.size * 0.5;\n}\nfunction rectRectOverlap(r1, x2, y2, w2, h2) {\n  const xOverlap = r1.x + r1.width > x2 && r1.x < x2 + w2;\n  const yOverlap = r1.y + r1.height > y2 && r1.y < y2 + h2;\n  return xOverlap && yOverlap;\n}\nfunction rectContainsRect(r1, r2x, r2y, r2w, r2h) {\n  return r2x + r2w < r1.x + r1.width && r2x > r1.x && r2y > r1.y && r2y + r2h < r1.y + r1.height;\n}\nfunction isPointLabelDatum(x) {\n  return x != null && typeof x.point === \"object\" && typeof x.label === \"object\";\n}\nvar labelPlacements = {\n  top: { x: 0, y: -1 },\n  bottom: { x: 0, y: 1 },\n  left: { x: -1, y: 0 },\n  right: { x: 1, y: 0 },\n  \"top-left\": { x: -1, y: -1 },\n  \"top-right\": { x: 1, y: -1 },\n  \"bottom-left\": { x: -1, y: 1 },\n  \"bottom-right\": { x: 1, y: 1 }\n};\nfunction placeLabels(data, bounds, padding = 5) {\n  const result = [];\n  data = data.map((d) => d.slice().sort((a, b) => b.point.size - a.point.size));\n  for (let j = 0; j < data.length; j++) {\n    const labels = result[j] = [];\n    const datum = data[j];\n    if (!(datum?.length && datum[0].label)) {\n      continue;\n    }\n    for (let index = 0, ln = datum.length; index < ln; index++) {\n      const d = datum[index];\n      const { point, label, marker } = d;\n      const { text, width: width2, height: height2 } = label;\n      const r = point.size * 0.5;\n      let dx = 0;\n      let dy = 0;\n      if (r > 0 && d.placement != null) {\n        const placement = labelPlacements[d.placement];\n        dx = (width2 * 0.5 + r + padding) * placement.x;\n        dy = (height2 * 0.5 + r + padding) * placement.y;\n      }\n      const x = point.x - width2 * 0.5 + dx - ((marker?.center.x ?? 0.5) - 0.5) * point.size;\n      const y = point.y - height2 * 0.5 + dy - ((marker?.center.y ?? 0.5) - 0.5) * point.size;\n      const withinBounds = !bounds || rectContainsRect(bounds, x, y, width2, height2);\n      if (!withinBounds) {\n        continue;\n      }\n      const overlapPoints = data.some(\n        (dataDatums) => dataDatums.some(\n          (dataDatum) => circleRectOverlap(dataDatum.point, dataDatum.marker?.center, x, y, width2, height2)\n        )\n      );\n      if (overlapPoints) {\n        continue;\n      }\n      const overlapLabels = result.some((l2) => l2.some((l3) => rectRectOverlap(l3, x, y, width2, height2)));\n      if (overlapLabels) {\n        continue;\n      }\n      labels.push({ index, text, x, y, width: width2, height: height2, datum: d });\n    }\n  }\n  return result;\n}\nfunction axisLabelsOverlap(data, padding = 0) {\n  const result = [];\n  for (let index = 0; index < data.length; index++) {\n    const datum = data[index];\n    const {\n      point: { x, y },\n      label: { text }\n    } = datum;\n    let { width: width2, height: height2 } = datum.label;\n    width2 += padding;\n    height2 += padding;\n    if (result.some((l) => rectRectOverlap(l, x, y, width2, height2))) {\n      return true;\n    }\n    result.push({ index, text, x, y, width: width2, height: height2, datum });\n  }\n  return false;\n}\n\n// packages/ag-charts-community/src/util/equal.ts\nfunction areArrayNumbersEqual(arrA, arrB) {\n  return arrA.length === arrB.length && arrA.every((item, i) => Number(item) === Number(arrB[i]));\n}\n\n// packages/ag-charts-community/src/util/json.ts\nvar CLASS_INSTANCE_TYPE = \"class-instance\";\nfunction jsonDiff(source, target, skip) {\n  if (isArray(target)) {\n    if (!isArray(source) || source.length !== target.length || target.some((v, i) => jsonDiff(source[i], v) != null)) {\n      return target;\n    }\n  } else if (isPlainObject(target)) {\n    if (!isPlainObject(source)) {\n      return target;\n    }\n    const result = {};\n    const allKeys = /* @__PURE__ */ new Set([\n      ...Object.keys(source),\n      ...Object.keys(target)\n    ]);\n    for (const key of allKeys) {\n      if (source[key] === target[key] || skip?.includes(key)) {\n        continue;\n      }\n      if (typeof source[key] === typeof target[key]) {\n        const diff2 = jsonDiff(source[key], target[key]);\n        if (diff2 !== null) {\n          result[key] = diff2;\n        }\n      } else {\n        result[key] = target[key];\n      }\n    }\n    return Object.keys(result).length ? result : null;\n  } else if (source !== target) {\n    return target;\n  }\n  return null;\n}\nfunction deepClone(source, options) {\n  if (isArray(source)) {\n    return source.map((item) => deepClone(item, options));\n  }\n  if (isPlainObject(source)) {\n    return mapValues(\n      source,\n      (value, key) => options?.shallow?.includes(key) ? shallowClone(value) : deepClone(value, options)\n    );\n  }\n  if (source instanceof Map) {\n    return new Map(deepClone(Array.from(source)));\n  }\n  return shallowClone(source);\n}\nfunction shallowClone(source) {\n  if (isArray(source)) {\n    return [...source];\n  }\n  if (isPlainObject(source)) {\n    return { ...source };\n  }\n  if (isDate(source)) {\n    return new Date(source);\n  }\n  if (isRegExp(source)) {\n    return new RegExp(source.source, source.flags);\n  }\n  return source;\n}\nfunction jsonWalk(json, visit, opts, ...jsons) {\n  if (isArray(json)) {\n    visit(json, ...jsons);\n    json.forEach((node, index) => {\n      jsonWalk(node, visit, opts, ...keyMapper(jsons, index));\n    });\n  } else if (isPlainObject(json)) {\n    visit(json, ...jsons);\n    for (const key of Object.keys(json)) {\n      if (opts?.skip?.includes(key)) {\n        continue;\n      }\n      const value = json[key];\n      if (isArray(value) || isPlainObject(value)) {\n        jsonWalk(value, visit, opts, ...keyMapper(jsons, key));\n      }\n    }\n  }\n}\nfunction jsonApply(target, source, params = {}) {\n  const { path, matcherPath = path?.replace(/(\\[[0-9+]+])/i, \"[]\"), skip = [] } = params;\n  if (target == null) {\n    throw new Error(`AG Charts - target is uninitialised: ${path ?? \"<root>\"}`);\n  }\n  if (source == null) {\n    return target;\n  }\n  if (isProperties(target)) {\n    return target.set(source);\n  }\n  const targetAny = target;\n  const targetType = classify(target);\n  for (const property in source) {\n    if (SKIP_JS_BUILTINS.has(property))\n      continue;\n    const propertyMatcherPath = `${matcherPath ? matcherPath + \".\" : \"\"}${property}`;\n    if (skip.includes(propertyMatcherPath))\n      continue;\n    const newValue = source[property];\n    const propertyPath = `${path ? path + \".\" : \"\"}${property}`;\n    const targetClass = targetAny.constructor;\n    const currentValue = targetAny[property];\n    try {\n      const currentValueType = classify(currentValue);\n      const newValueType = classify(newValue);\n      if (targetType === CLASS_INSTANCE_TYPE && !(property in target)) {\n        Logger.warn(`unable to set [${propertyPath}] in ${targetClass?.name} - property is unknown`);\n        continue;\n      }\n      if (currentValueType != null && newValueType != null && newValueType !== currentValueType && (currentValueType !== CLASS_INSTANCE_TYPE || newValueType !== \"object\")) {\n        Logger.warn(\n          `unable to set [${propertyPath}] in ${targetClass?.name} - can't apply type of [${newValueType}], allowed types are: [${currentValueType}]`\n        );\n        continue;\n      }\n      if (isProperties(currentValue)) {\n        targetAny[property].set(newValue);\n      } else if (newValueType === \"object\") {\n        if (currentValue == null) {\n          targetAny[property] = {};\n        }\n        jsonApply(currentValue ?? targetAny[property], newValue, {\n          ...params,\n          path: propertyPath,\n          matcherPath: propertyMatcherPath\n        });\n      } else {\n        targetAny[property] = newValue;\n      }\n    } catch (error) {\n      Logger.warn(`unable to set [${propertyPath}] in [${targetClass?.name}]; nested error is: ${error.message}`);\n    }\n  }\n  return target;\n}\nfunction keyMapper(data, key) {\n  return data.map((dataObject) => dataObject?.[key]);\n}\nfunction classify(value) {\n  if (value == null) {\n    return null;\n  }\n  if (isHtmlElement(value) || isDate(value)) {\n    return \"primitive\";\n  }\n  if (isArray(value)) {\n    return \"array\";\n  }\n  if (isObject(value)) {\n    return isPlainObject(value) ? \"object\" : CLASS_INSTANCE_TYPE;\n  }\n  if (isFunction(value)) {\n    return \"function\";\n  }\n  return \"primitive\";\n}\n\n// packages/ag-charts-community/src/util/proxy.ts\nfunction ProxyProperty(proxyPath, configMetadata) {\n  const pathArray = isArray(proxyPath) ? proxyPath : proxyPath.split(\".\");\n  if (pathArray.length === 1) {\n    const [property] = pathArray;\n    return addTransformToInstanceProperty(\n      (target, _, value) => target[property] = value,\n      (target) => target[property],\n      configMetadata\n    );\n  }\n  return addTransformToInstanceProperty(\n    (target, _, value) => setPath(target, pathArray, value),\n    (target) => getPath(target, pathArray),\n    configMetadata\n  );\n}\nfunction ProxyOnWrite(proxyProperty) {\n  return addTransformToInstanceProperty((target, _, value) => target[proxyProperty] = value);\n}\nfunction ProxyPropertyOnWrite(childName, childProperty) {\n  return addTransformToInstanceProperty((target, key, value) => target[childName][childProperty ?? key] = value);\n}\nfunction ActionOnSet(opts) {\n  const { newValue: newValueFn, oldValue: oldValueFn, changeValue: changeValueFn } = opts;\n  return addTransformToInstanceProperty((target, _, newValue, oldValue) => {\n    if (newValue !== oldValue) {\n      if (oldValue !== void 0) {\n        oldValueFn?.call(target, oldValue);\n      }\n      if (newValue !== void 0) {\n        newValueFn?.call(target, newValue);\n      }\n      changeValueFn?.call(target, newValue, oldValue);\n    }\n    return newValue;\n  });\n}\nfunction ObserveChanges(observerFn) {\n  return addObserverToInstanceProperty(observerFn);\n}\n\n// packages/ag-charts-community/src/util/stateMachine.ts\nvar debugColor = \"color: green\";\nvar debugQuietColor = \"color: grey\";\nvar _StateMachine = class _StateMachine {\n  constructor(defaultState, states, enterEach) {\n    this.defaultState = defaultState;\n    this.states = states;\n    this.enterEach = enterEach;\n    this.debug = Debug.create(true, \"animation\");\n    this.state = defaultState;\n    this.debug(`%c${this.constructor.name} | init -> ${defaultState}`, debugColor);\n  }\n  transition(event, data) {\n    const shouldTransitionSelf = this.transitionChild(event, data);\n    if (!shouldTransitionSelf || this.state === _StateMachine.child || this.state === _StateMachine.parent) {\n      return;\n    }\n    const currentState = this.state;\n    const currentStateConfig = this.states[this.state];\n    let destination = currentStateConfig[event];\n    const debugPrefix = `%c${this.constructor.name} | ${this.state} -> ${event} ->`;\n    if (Array.isArray(destination)) {\n      destination = destination.find((transition) => {\n        if (!transition.guard)\n          return true;\n        const valid = transition.guard(data);\n        if (!valid) {\n          this.debug(`${debugPrefix} ${transition.target} (guarded)`, debugQuietColor);\n        }\n        return valid;\n      });\n    } else if (typeof destination === \"object\" && !(destination instanceof _StateMachine) && destination.guard && !destination.guard(data)) {\n      this.debug(`${debugPrefix} ${destination.target} (guarded)`, debugQuietColor);\n      return;\n    }\n    if (!destination) {\n      this.debug(`${debugPrefix} ${this.state}`, debugQuietColor);\n      return;\n    }\n    const destinationState = this.getDestinationState(destination);\n    const exitFn = destinationState === this.state ? void 0 : currentStateConfig.onExit;\n    this.debug(`${debugPrefix} ${destinationState}`, debugColor);\n    this.state = destinationState;\n    if (typeof destination === \"function\") {\n      destination(data);\n    } else if (typeof destination === \"object\" && !(destination instanceof _StateMachine)) {\n      destination.action?.(data);\n    }\n    exitFn?.();\n    this.enterEach?.(currentState, destinationState);\n    if (destinationState !== currentState && destinationState !== _StateMachine.child && destinationState !== _StateMachine.parent) {\n      this.states[destinationState].onEnter?.(currentState, data);\n    }\n  }\n  transitionAsync(event, data) {\n    setTimeout(() => {\n      this.transition(event, data);\n    }, 0);\n  }\n  is(value) {\n    if (this.state === _StateMachine.child && this.childState) {\n      return this.childState.is(value);\n    }\n    return this.state === value;\n  }\n  resetHierarchy() {\n    this.debug(\n      `%c${this.constructor.name} | ${this.state} -> [resetHierarchy] -> ${this.defaultState}`,\n      \"color: green\"\n    );\n    this.state = this.defaultState;\n  }\n  transitionChild(event, data) {\n    if (this.state !== _StateMachine.child || !this.childState)\n      return true;\n    this.childState.transition(event, data);\n    if (!this.childState.is(_StateMachine.parent))\n      return true;\n    this.debug(`%c${this.constructor.name} | ${this.state} -> ${event} -> ${this.defaultState}`, debugColor);\n    this.state = this.defaultState;\n    this.states[this.state].onEnter?.();\n    this.childState.resetHierarchy();\n    return false;\n  }\n  getDestinationState(destination) {\n    let state = this.state;\n    if (typeof destination === \"string\") {\n      state = destination;\n    } else if (destination instanceof _StateMachine) {\n      this.childState = destination;\n      state = _StateMachine.child;\n    } else if (typeof destination === \"object\") {\n      if (destination.target instanceof _StateMachine) {\n        this.childState = destination.target;\n        state = _StateMachine.child;\n      } else if (destination.target != null) {\n        state = destination.target;\n      }\n    }\n    return state;\n  }\n};\n_StateMachine.child = \"__child\";\n_StateMachine.parent = \"__parent\";\nvar StateMachine = _StateMachine;\n\n// packages/ag-charts-community/src/util/textWrapper.ts\nvar TextWrapper = class {\n  static wrapText(text, options) {\n    return this.wrapLines(text, options).join(\"\\n\");\n  }\n  static wrapLines(text, options) {\n    const clippedResult = this.textWrap(text, options);\n    if (options.overflow === \"hide\" && clippedResult.some((l) => l.endsWith(TextUtils.EllipsisChar))) {\n      return [];\n    }\n    return clippedResult;\n  }\n  static appendEllipsis(text) {\n    return text.replace(/[.,]{1,5}$/, \"\") + TextUtils.EllipsisChar;\n  }\n  static truncateLine(text, measurer, maxWidth, ellipsisForce) {\n    const ellipsisWidth = measurer.textWidth(TextUtils.EllipsisChar);\n    let estimatedWidth = 0;\n    let i = 0;\n    for (; i < text.length; i++) {\n      const charWidth = measurer.textWidth(text.charAt(i));\n      if (estimatedWidth + charWidth > maxWidth)\n        break;\n      estimatedWidth += charWidth;\n    }\n    if (text.length === i && (!ellipsisForce || estimatedWidth + ellipsisWidth <= maxWidth)) {\n      return ellipsisForce ? text + TextUtils.EllipsisChar : text;\n    }\n    text = text.slice(0, i).trimEnd();\n    while (text.length && measurer.textWidth(text) + ellipsisWidth > maxWidth) {\n      text = text.slice(0, -1).trimEnd();\n    }\n    return text + TextUtils.EllipsisChar;\n  }\n  static textWrap(text, options) {\n    const lines = text.split(TextUtils.lineSplitter);\n    const measurer = CachedTextMeasurerPool.getMeasurer(options);\n    if (options.textWrap === \"never\") {\n      return lines.map((line) => this.truncateLine(line.trimEnd(), measurer, options.maxWidth));\n    }\n    const result = [];\n    const wrapHyphenate = options.textWrap === \"hyphenate\";\n    const wrapOnSpace = options.textWrap == null || options.textWrap === \"on-space\";\n    for (let line of lines) {\n      line = line.trimEnd();\n      if (line === \"\") {\n        result.push(line);\n        continue;\n      }\n      for (let i = 0, estimatedWidth = 0, lastSpaceIndex = 0; i < line.length; i++) {\n        const char = line.charAt(i);\n        estimatedWidth += measurer.textWidth(char);\n        if (char === \" \") {\n          lastSpaceIndex = i;\n        }\n        if (estimatedWidth > options.maxWidth) {\n          if (i === 0)\n            break;\n          const actualWidth = measurer.textWidth(line.slice(0, i + 1));\n          if (actualWidth <= options.maxWidth) {\n            estimatedWidth = actualWidth;\n            continue;\n          }\n          if (lastSpaceIndex) {\n            const nextWord = this.getWordAt(line, lastSpaceIndex + 1);\n            const textWidth = measurer.textWidth(nextWord);\n            if (textWidth <= options.maxWidth) {\n              result.push(line.slice(0, lastSpaceIndex).trimEnd());\n              line = line.slice(lastSpaceIndex).trimStart();\n              i = -1;\n              estimatedWidth = 0;\n              lastSpaceIndex = 0;\n              continue;\n            } else if (wrapOnSpace && textWidth > options.maxWidth) {\n              result.push(\n                line.slice(0, lastSpaceIndex).trimEnd(),\n                this.truncateLine(\n                  line.slice(lastSpaceIndex).trimStart(),\n                  measurer,\n                  options.maxWidth,\n                  true\n                )\n              );\n            }\n          } else if (wrapOnSpace) {\n            result.push(this.truncateLine(line, measurer, options.maxWidth, true));\n          }\n          if (wrapOnSpace) {\n            line = \"\";\n            break;\n          }\n          const postfix = wrapHyphenate ? \"-\" : \"\";\n          let newLine = line.slice(0, i).trim();\n          while (newLine.length && measurer.textWidth(newLine + postfix) > options.maxWidth) {\n            newLine = newLine.slice(0, -1).trimEnd();\n          }\n          result.push(newLine + postfix);\n          if (!newLine.length) {\n            line = \"\";\n            break;\n          }\n          line = line.slice(newLine.length).trimStart();\n          i = -1;\n          estimatedWidth = 0;\n          lastSpaceIndex = 0;\n        }\n      }\n      if (line) {\n        result.push(line);\n      }\n    }\n    this.avoidOrphans(result, measurer, options);\n    return this.clipLines(result, measurer, options);\n  }\n  static getWordAt(text, position) {\n    const nextSpaceIndex = text.indexOf(\" \", position);\n    return nextSpaceIndex === -1 ? text.slice(position) : text.slice(position, nextSpaceIndex);\n  }\n  static clipLines(lines, measurer, options) {\n    if (!options.maxHeight) {\n      return lines;\n    }\n    const { height: height2, lineMetrics } = measurer.measureLines(lines);\n    if (height2 <= options.maxHeight) {\n      return lines;\n    }\n    for (let i = 0, cumulativeHeight = 0; i < lineMetrics.length; i++) {\n      const { lineHeight } = lineMetrics[i];\n      cumulativeHeight += lineHeight;\n      if (cumulativeHeight > options.maxHeight) {\n        if (options.overflow === \"hide\") {\n          return [];\n        }\n        const clippedResults = lines.slice(0, i || 1);\n        const lastLine = clippedResults.pop();\n        return clippedResults.concat(this.truncateLine(lastLine, measurer, options.maxWidth, true));\n      }\n    }\n    return lines;\n  }\n  static avoidOrphans(lines, measurer, options) {\n    if (options.avoidOrphans === false || lines.length < 2)\n      return;\n    const { length: length2 } = lines;\n    const lastLine = lines[length2 - 1];\n    const beforeLast = lines[length2 - 2];\n    if (beforeLast.length < lastLine.length)\n      return;\n    const lastSpaceIndex = beforeLast.lastIndexOf(\" \");\n    if (lastSpaceIndex === -1 || lastSpaceIndex === beforeLast.indexOf(\" \") || lastLine.includes(\" \"))\n      return;\n    const lastWord = beforeLast.slice(lastSpaceIndex + 1);\n    if (measurer.textWidth(lastLine + lastWord) <= options.maxWidth) {\n      lines[length2 - 2] = beforeLast.slice(0, lastSpaceIndex);\n      lines[length2 - 1] = lastWord + \" \" + lastLine;\n    }\n  }\n};\n\n// packages/ag-charts-community/src/module/enterpriseModule.ts\nvar enterpriseModule = {\n  isEnterprise: false\n};\n\n// packages/ag-charts-community/src/util/attributeUtil.ts\nfunction setAttribute(e, qualifiedName, value) {\n  if (value === void 0 || value === \"\") {\n    e?.removeAttribute(qualifiedName);\n  } else {\n    e?.setAttribute(qualifiedName, value.toString());\n  }\n}\nfunction setAttributes(e, attrs) {\n  if (attrs == null)\n    return;\n  let key;\n  for (key in attrs) {\n    if (key === \"class\")\n      continue;\n    setAttribute(e, key, attrs[key]);\n  }\n}\nfunction getAttribute(e, qualifiedName, defaultValue) {\n  if (!(e instanceof HTMLElement))\n    return void 0;\n  const value = e.getAttribute(qualifiedName);\n  if (value === null)\n    return defaultValue;\n  const type = typeof {}[qualifiedName];\n  if (type === \"boolean\")\n    return value === \"true\";\n  if (type === \"number\")\n    return Number(value);\n  if (type === \"string\")\n    return value;\n  return void 0;\n}\nfunction setElementStyle(e, property, value) {\n  if (e == null)\n    return;\n  if (value == null) {\n    e.style.removeProperty(property);\n  } else {\n    e.style.setProperty(property, value);\n  }\n}\n\n// packages/ag-charts-community/src/util/placement.ts\nfunction calculatePlacement(naturalWidth, naturalHeight, container, bounds) {\n  let { top, right, bottom, left, width: width2, height: height2 } = bounds;\n  if (left != null) {\n    if (width2 != null) {\n      right = container.width - left + width2;\n    } else if (right != null) {\n      width2 = container.width - left - right;\n    }\n  } else if (right != null && width2 != null) {\n    left = container.width - right - width2;\n  }\n  if (top != null) {\n    if (height2 != null) {\n      bottom = container.height - top - height2;\n    } else if (bottom != null) {\n      height2 = container.height - bottom - top;\n    }\n  } else if (bottom != null && height2 != null) {\n    top = container.height - bottom - height2;\n  }\n  if (width2 == null) {\n    if (height2 == null) {\n      width2 = naturalWidth;\n      height2 = naturalHeight;\n    } else {\n      width2 = Math.ceil(naturalWidth * height2 / naturalHeight);\n    }\n  } else if (height2 == null) {\n    height2 = Math.ceil(naturalHeight * width2 / naturalWidth);\n  }\n  if (left == null) {\n    if (right == null) {\n      left = Math.floor((container.width - width2) / 2);\n    } else {\n      left = container.width - right - width2;\n    }\n  }\n  if (top == null) {\n    if (bottom == null) {\n      top = Math.floor((container.height - height2) / 2);\n    } else {\n      top = container.height - height2 - bottom;\n    }\n  }\n  return { x: left, y: top, width: width2, height: height2 };\n}\n\n// packages/ag-charts-community/src/chart/tooltip/tooltip.ts\nvar DEFAULT_TOOLTIP_CLASS = \"ag-chart-tooltip\";\nvar DEFAULT_TOOLTIP_DARK_CLASS = \"ag-chart-dark-tooltip\";\nvar EMPTY_TOOLTIP_CONTENT = { html: \"\", ariaLabel: \"\" };\nfunction toAccessibleText(inputHtml) {\n  const lineConverter = (_match, offset4, str) => {\n    if (offset4 === 0 || str[offset4 - 1] !== \".\") {\n      return \". \";\n    }\n    return \" \";\n  };\n  return inputHtml.replace(/<br\\s*\\/?>/g, lineConverter).replace(/<\\/p\\s+>/g, lineConverter).replace(/<\\/li\\s*>/g, lineConverter).replace(/<[^<>]+>/g, \"\").replace(/\\n+/g, \" \").replace(/\\s+/g, \" \");\n}\nfunction toTooltipHtml(input, defaults) {\n  if (typeof input === \"string\") {\n    return { html: input, ariaLabel: input };\n  }\n  const {\n    content = defaults?.content ?? \"\",\n    title = defaults?.title,\n    color = defaults?.color ?? \"white\",\n    backgroundColor = defaults?.backgroundColor ?? \"#888\"\n  } = input;\n  const titleHtml = title ? `<div class=\"${DEFAULT_TOOLTIP_CLASS}-title\"\n        style=\"color: ${color}; background-color: ${backgroundColor}\">${title}</div>` : \"\";\n  const titleAria = title ? `${title}: ` : \"\";\n  const contentHtml = content ? `<div class=\"${DEFAULT_TOOLTIP_CLASS}-content\">${content}</div>` : \"\";\n  return {\n    html: `${titleHtml}${contentHtml}`,\n    ariaLabel: toAccessibleText(`${titleAria}${content}`)\n  };\n}\nvar TooltipPosition = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    /** The type of positioning for the tooltip. By default, the tooltip follows the pointer. */\n    this.type = \"pointer\";\n    /** The horizontal offset in pixels for the position of the tooltip. */\n    this.xOffset = 0;\n    /** The vertical offset in pixels for the position of the tooltip. */\n    this.yOffset = 0;\n  }\n};\n__decorateClass([\n  Validate(\n    UNION(\n      [\n        \"pointer\",\n        \"node\",\n        \"top\",\n        \"right\",\n        \"bottom\",\n        \"left\",\n        \"top-left\",\n        \"top-right\",\n        \"bottom-right\",\n        \"bottom-left\",\n        { value: \"sparkline\", undocumented: true }\n      ],\n      \"a position type\"\n    )\n  )\n], TooltipPosition.prototype, \"type\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], TooltipPosition.prototype, \"xOffset\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], TooltipPosition.prototype, \"yOffset\", 2);\nvar Tooltip = class extends BaseProperties {\n  constructor() {\n    super();\n    this.enabled = true;\n    this.delay = 0;\n    this.range = void 0;\n    this.wrapping = \"hyphenate\";\n    this.position = new TooltipPosition();\n    this.darkTheme = false;\n    this.bounds = \"extended\";\n    this.enableInteraction = false;\n    this.lastVisibilityChange = Date.now();\n    this.wrapTypes = [\"always\", \"hyphenate\", \"on-space\", \"never\"];\n    this.showTimeout = 0;\n    this._showArrow = true;\n  }\n  get interactive() {\n    return this.enableInteraction;\n  }\n  setup(domManager) {\n    this.element = domManager.addChild(\"canvas-overlay\", DEFAULT_TOOLTIP_CLASS);\n    this.element.classList.add(DEFAULT_TOOLTIP_CLASS);\n  }\n  destroy(domManager) {\n    domManager.removeChild(\"canvas-overlay\", DEFAULT_TOOLTIP_CLASS);\n  }\n  isVisible() {\n    return !this.element?.classList.contains(DEFAULT_TOOLTIP_CLASS + \"-hidden\");\n  }\n  /**\n   * Shows tooltip at the given event's coordinates.\n   * If the `html` parameter is missing, moves the existing tooltip to the new position.\n   */\n  show(boundingRect, canvasRect, meta, content, instantly = false) {\n    const { element: element2 } = this;\n    const existingPosition = element2?.getBoundingClientRect();\n    if (content != null && element2 != null) {\n      element2.innerHTML = content.html;\n    } else if (!element2?.innerHTML) {\n      this.toggle(false);\n      return;\n    }\n    const positionType = meta.position?.type ?? this.position.type;\n    const xOffset = meta.position?.xOffset ?? 0;\n    const yOffset = meta.position?.yOffset ?? 0;\n    const tooltipBounds = this.getTooltipBounds({ positionType, meta, yOffset, xOffset, canvasRect });\n    const relativeRect = {\n      x: boundingRect.x - canvasRect.x,\n      y: boundingRect.y - canvasRect.y,\n      width: boundingRect.width,\n      height: boundingRect.height\n    };\n    const position = calculatePlacement(element2.clientWidth, element2.clientHeight, relativeRect, tooltipBounds);\n    const minX = relativeRect.x;\n    const minY = relativeRect.y;\n    const maxX = relativeRect.width - element2.clientWidth - 1 + minX;\n    const maxY = relativeRect.height - element2.clientHeight + minY;\n    const left = clamp(minX, position.x, maxX);\n    const top = clamp(minY, position.y, maxY);\n    let willExistOutsideBoundingRectDuringTransition = false;\n    if (existingPosition != null) {\n      const maxXWithPreviousPosition = relativeRect.width - existingPosition.width - 1 + minX;\n      const maxYWithPreviousPosition = relativeRect.height - existingPosition.height + minY;\n      willExistOutsideBoundingRectDuringTransition = maxXWithPreviousPosition > maxX || maxYWithPreviousPosition > maxY;\n    }\n    const constrained = left !== position.x || top !== position.y;\n    const defaultShowArrow = (positionType === \"node\" || positionType === \"pointer\" || positionType === \"sparkline\") && !constrained && !xOffset && !yOffset;\n    const showArrow = meta.showArrow ?? this.showArrow ?? defaultShowArrow;\n    this.updateShowArrow(showArrow);\n    if (willExistOutsideBoundingRectDuringTransition) {\n      element2.style.transition = \"none\";\n    }\n    element2.style.transform = `translate(${Math.round(left)}px, ${Math.round(top)}px)`;\n    if (willExistOutsideBoundingRectDuringTransition) {\n      element2.style.transition = \"\";\n    }\n    if (meta.enableInteraction) {\n      this.enableInteraction = true;\n      element2.style.pointerEvents = \"auto\";\n      setAttribute(element2, \"aria-hidden\", void 0);\n    } else {\n      this.enableInteraction = false;\n      element2.style.pointerEvents = \"none\";\n      setAttribute(element2, \"aria-hidden\", true);\n    }\n    if (this.delay > 0 && !instantly) {\n      this.toggle(false);\n      this.showTimeout = setTimeout(() => {\n        this.toggle(true);\n      }, this.delay);\n    } else {\n      this.toggle(true);\n    }\n  }\n  toggle(visible) {\n    if (!this.element)\n      return;\n    const { classList } = this.element;\n    const toggleClass = (name, include) => classList.toggle(`${DEFAULT_TOOLTIP_CLASS}-${name}`, include);\n    const wasVisible = this.isVisible();\n    let timeSinceLastVisibilityChangeMs = Infinity;\n    if (!visible) {\n      clearTimeout(this.showTimeout);\n    }\n    if (wasVisible !== visible) {\n      const now = Date.now();\n      timeSinceLastVisibilityChangeMs = now - this.lastVisibilityChange;\n      this.lastVisibilityChange = now;\n    }\n    const animatedMoveThresholdMs = 100;\n    const thrashingThresholdMs = 5;\n    const noAnimation = !wasVisible && visible && timeSinceLastVisibilityChangeMs > animatedMoveThresholdMs;\n    if (timeSinceLastVisibilityChangeMs > thrashingThresholdMs) {\n      toggleClass(\"no-animation\", noAnimation);\n    }\n    toggleClass(\"no-interaction\", !this.enableInteraction);\n    toggleClass(\"hidden\", !visible);\n    toggleClass(\"arrow\", this._showArrow);\n    classList.toggle(DEFAULT_TOOLTIP_DARK_CLASS, this.darkTheme);\n    for (const wrapType of this.wrapTypes) {\n      classList.toggle(`${DEFAULT_TOOLTIP_CLASS}-wrap-${wrapType}`, wrapType === this.wrapping);\n    }\n  }\n  updateShowArrow(show) {\n    this._showArrow = show;\n  }\n  getTooltipBounds(opts) {\n    if (!this.element)\n      return {};\n    const { positionType, meta, yOffset, xOffset, canvasRect } = opts;\n    const { clientWidth: tooltipWidth, clientHeight: tooltipHeight } = this.element;\n    const bounds = { width: tooltipWidth, height: tooltipHeight };\n    switch (positionType) {\n      case \"node\":\n      case \"pointer\": {\n        bounds.top = meta.offsetY + yOffset - tooltipHeight - 8;\n        bounds.left = meta.offsetX + xOffset - tooltipWidth / 2;\n        return bounds;\n      }\n      case \"top\": {\n        bounds.top = yOffset;\n        bounds.left = canvasRect.width / 2 - tooltipWidth / 2 + xOffset;\n        return bounds;\n      }\n      case \"right\": {\n        bounds.top = canvasRect.height / 2 - tooltipHeight / 2 + yOffset;\n        bounds.left = canvasRect.width - tooltipWidth / 2 + xOffset;\n        return bounds;\n      }\n      case \"left\": {\n        bounds.top = canvasRect.height / 2 - tooltipHeight / 2 + yOffset;\n        bounds.left = xOffset;\n        return bounds;\n      }\n      case \"bottom\": {\n        bounds.top = canvasRect.height - tooltipHeight + yOffset;\n        bounds.left = canvasRect.width / 2 - tooltipWidth / 2 + xOffset;\n        return bounds;\n      }\n      case \"top-left\": {\n        bounds.top = yOffset;\n        bounds.left = xOffset;\n        return bounds;\n      }\n      case \"top-right\": {\n        bounds.top = yOffset;\n        bounds.left = canvasRect.width - tooltipWidth + xOffset;\n        return bounds;\n      }\n      case \"bottom-right\": {\n        bounds.top = canvasRect.height - tooltipHeight + yOffset;\n        bounds.left = canvasRect.width - tooltipWidth + xOffset;\n        return bounds;\n      }\n      case \"bottom-left\": {\n        bounds.top = canvasRect.height - tooltipHeight + yOffset;\n        bounds.left = xOffset;\n        return bounds;\n      }\n      case \"sparkline\": {\n        if (enterpriseModule.isEnterprise) {\n          bounds.top = yOffset - tooltipHeight - 8;\n        } else {\n          bounds.top = meta.offsetY + yOffset - tooltipHeight - 8;\n        }\n        bounds.left = meta.offsetX + xOffset - tooltipWidth / 2;\n        return bounds;\n      }\n    }\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], Tooltip.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], Tooltip.prototype, \"showArrow\", 2);\n__decorateClass([\n  ObserveChanges((target, newValue, oldValue) => {\n    if (newValue) {\n      target.element?.classList.add(newValue);\n    }\n    if (oldValue) {\n      target.element?.classList.remove(oldValue);\n    }\n  }),\n  Validate(STRING, { optional: true })\n], Tooltip.prototype, \"class\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Tooltip.prototype, \"delay\", 2);\n__decorateClass([\n  Validate(INTERACTION_RANGE, { optional: true })\n], Tooltip.prototype, \"range\", 2);\n__decorateClass([\n  Validate(TEXT_WRAP)\n], Tooltip.prototype, \"wrapping\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Tooltip.prototype, \"position\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], Tooltip.prototype, \"darkTheme\", 2);\n__decorateClass([\n  Validate(UNION([\"extended\", \"canvas\"]))\n], Tooltip.prototype, \"bounds\", 2);\n\n// packages/ag-charts-community/src/chart/caption.ts\nvar Caption = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.id = createId(this);\n    this.node = new RotatableText({ zIndex: 1 }).setProperties({\n      textAlign: \"center\",\n      pointerEvents: 1 /* None */\n    });\n    this.enabled = false;\n    this.textAlign = \"center\";\n    this.fontSize = 10;\n    this.fontFamily = \"sans-serif\";\n    this.wrapping = \"always\";\n    this.padding = 0;\n    this.layoutStyle = \"block\";\n    this.truncated = false;\n  }\n  registerInteraction(moduleCtx, where) {\n    const { regionManager, proxyInteractionService, layoutManager } = moduleCtx;\n    const region = regionManager.getRegion(\"root\");\n    const destroyFns = [\n      layoutManager.addListener(\"layout:complete\", () => this.updateA11yText(proxyInteractionService, where)),\n      region.addListener(\"hover\", (event) => this.handleMouseMove(moduleCtx, event)),\n      region.addListener(\"leave\", (event) => this.handleMouseLeave(moduleCtx, event))\n    ];\n    return joinFunctions(...destroyFns);\n  }\n  computeTextWrap(containerWidth, containerHeight) {\n    const { text, padding, wrapping } = this;\n    const maxWidth = Math.min(this.maxWidth ?? Infinity, containerWidth) - padding * 2;\n    const maxHeight = this.maxHeight ?? containerHeight - padding * 2;\n    if (!isFinite(maxWidth) && !isFinite(maxHeight)) {\n      this.node.text = text;\n      return;\n    }\n    const wrappedText = TextWrapper.wrapText(text ?? \"\", { maxWidth, maxHeight, font: this, textWrap: wrapping });\n    this.node.text = wrappedText;\n    this.truncated = wrappedText.includes(TextUtils.EllipsisChar);\n  }\n  updateA11yText(proxyService, where) {\n    if (this.enabled && this.text) {\n      const bbox = Transformable.toCanvas(this.node);\n      if (bbox) {\n        const { id } = this;\n        this.proxyText ?? (this.proxyText = proxyService.createProxyElement({ type: \"text\", id, parent: where }));\n        this.proxyText.textContent = this.text;\n        this.proxyText.updateBounds(bbox);\n      }\n    } else {\n      this.proxyText?.remove();\n      this.proxyText = void 0;\n    }\n  }\n  handleMouseMove(moduleCtx, event) {\n    if (event !== void 0 && this.enabled && this.node.visible && this.truncated) {\n      const { offsetX, offsetY } = event;\n      moduleCtx.tooltipManager.updateTooltip(\n        this.id,\n        { offsetX, offsetY, lastPointerEvent: event, showArrow: false },\n        toTooltipHtml({ content: this.text })\n      );\n    }\n  }\n  handleMouseLeave(moduleCtx, _event) {\n    moduleCtx.tooltipManager.removeTooltip(this.id);\n  }\n};\nCaption.SMALL_PADDING = 10;\nCaption.LARGE_PADDING = 20;\n__decorateClass([\n  Validate(BOOLEAN),\n  ProxyPropertyOnWrite(\"node\", \"visible\")\n], Caption.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true }),\n  ProxyPropertyOnWrite(\"node\")\n], Caption.prototype, \"text\", 2);\n__decorateClass([\n  Validate(TEXT_ALIGN, { optional: true }),\n  ProxyPropertyOnWrite(\"node\")\n], Caption.prototype, \"textAlign\", 2);\n__decorateClass([\n  Validate(FONT_STYLE, { optional: true }),\n  ProxyPropertyOnWrite(\"node\")\n], Caption.prototype, \"fontStyle\", 2);\n__decorateClass([\n  Validate(FONT_WEIGHT, { optional: true }),\n  ProxyPropertyOnWrite(\"node\")\n], Caption.prototype, \"fontWeight\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  ProxyPropertyOnWrite(\"node\")\n], Caption.prototype, \"fontSize\", 2);\n__decorateClass([\n  Validate(STRING),\n  ProxyPropertyOnWrite(\"node\")\n], Caption.prototype, \"fontFamily\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true }),\n  ProxyPropertyOnWrite(\"node\", \"fill\")\n], Caption.prototype, \"color\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], Caption.prototype, \"spacing\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], Caption.prototype, \"maxWidth\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], Caption.prototype, \"maxHeight\", 2);\n__decorateClass([\n  Validate(TEXT_WRAP)\n], Caption.prototype, \"wrapping\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Caption.prototype, \"padding\", 2);\n__decorateClass([\n  Validate(STRING)\n], Caption.prototype, \"layoutStyle\", 2);\n\n// packages/ag-charts-community/src/scene/layer.ts\nvar _Layer = class _Layer extends Group {\n  constructor(opts) {\n    super(opts);\n    this.opts = opts;\n    this.lastBBox = void 0;\n  }\n  static is(value) {\n    return value instanceof _Layer;\n  }\n  markDirty(type = 1 /* TRIVIAL */) {\n    super.markDirty(type, 1 /* TRIVIAL */);\n  }\n  preRender() {\n    const counts = super.preRender();\n    if (counts.nonGroups > 0) {\n      this.layer ?? (this.layer = this._layerManager?.addLayer({\n        name: this.name,\n        zIndex: this.zIndex,\n        zIndexSubOrder: this.zIndexSubOrder,\n        getComputedOpacity: () => this.getComputedOpacity(),\n        getVisibility: () => this.getVisibility()\n      }));\n      if (this.opts?.deriveZIndexFromChildren) {\n        this.deriveZIndexFromChildren();\n      }\n    }\n    return counts;\n  }\n  debugSkip(renderCtx) {\n    super.debugSkip(renderCtx);\n    const { stats } = renderCtx;\n    if (stats) {\n      stats.layersSkipped++;\n      stats.nodesSkipped += nodeCount(this).count;\n    }\n  }\n  render(renderCtx) {\n    if (!this.layer) {\n      return super.render(renderCtx);\n    }\n    const { opts: { name } = {}, _debug: debug3, clipRect } = this;\n    const { isDirty, isChildDirty, isChildLayerDirty } = this.isDirty(renderCtx);\n    const { stats } = renderCtx;\n    let { forceRender, clipBBox } = renderCtx;\n    const currentBBox = this.getBBox();\n    if (!this.lastBBox?.equals(currentBBox)) {\n      forceRender = \"dirtyTransform\";\n      this.lastBBox = currentBBox;\n    }\n    if (!isDirty && !isChildDirty && !isChildLayerDirty && !forceRender) {\n      this.debugSkip(renderCtx);\n      this.markClean({ recursive: false });\n      return;\n    }\n    if (forceRender !== \"dirtyTransform\") {\n      forceRender = isChildDirty || this.dirtyZIndex;\n    }\n    if (forceRender) {\n      this.layer.clear();\n    }\n    if (this.dirtyZIndex) {\n      this.sortChildren(Group.compareChildren);\n    }\n    const children = this.sortedChildren();\n    const renderCtxTransform = renderCtx.ctx.getTransform();\n    const { context: ctx } = this.layer;\n    ctx.save();\n    if (clipBBox) {\n      const { width: width2, height: height2, x, y } = clipBBox;\n      ctx.beginPath();\n      ctx.rect(x, y, width2, height2);\n      ctx.clip();\n      debug3?.(() => ({ name, clipBBox, renderCtx, group: this, ctxTransform: ctx.getTransform() }));\n    }\n    ctx.setTransform(renderCtxTransform);\n    if (this.clipRect) {\n      clipBBox = this.renderClip({ ...renderCtx, ctx });\n    }\n    this.renderChildren(children, { ...renderCtx, ctx, forceRender, clipBBox });\n    super.render(renderCtx, true);\n    if (clipRect) {\n      ctx.restore();\n    }\n    for (const child of this.virtualChildren()) {\n      child.markClean({ recursive: \"virtual\" });\n    }\n    if (stats)\n      stats.layersRendered++;\n    ctx.restore();\n    ctx.verifyDepthZero?.();\n    if (name && stats) {\n      debug3?.({\n        name,\n        renderCtx,\n        result: \"rendered\",\n        skipped: stats.nodesSkipped,\n        counts: nodeCount(this),\n        group: this\n      });\n    }\n  }\n  deriveZIndexFromChildren() {\n    let lastChild;\n    for (const child of this.children()) {\n      if (!child.childNodeCounts.nonGroups)\n        continue;\n      if (!lastChild || Group.compareChildren(lastChild, child) < 0) {\n        lastChild = child;\n      }\n    }\n    this.zIndex = lastChild?.zIndex ?? -Infinity;\n    this.zIndexSubOrder = lastChild?.zIndexSubOrder;\n  }\n  _setLayerManager(layersManager) {\n    if (this.layer) {\n      this._layerManager?.removeLayer(this.layer);\n      this.layer = void 0;\n    }\n    super._setLayerManager(layersManager);\n  }\n  getComputedOpacity() {\n    let opacity = 1;\n    for (const node of this.traverseUp(true)) {\n      if (node instanceof Group) {\n        opacity *= node.opacity;\n      }\n    }\n    return opacity;\n  }\n  getVisibility() {\n    for (const node of this.traverseUp(true)) {\n      if (!node.visible) {\n        return false;\n      }\n    }\n    return true;\n  }\n  onVisibleChange() {\n    if (this.layer) {\n      this.layer.enabled = this.visible;\n    }\n  }\n  onZIndexChange() {\n    super.onZIndexChange();\n    if (this.layer) {\n      this._layerManager?.moveLayer(this.layer, this.zIndex, this.zIndexSubOrder);\n    }\n  }\n};\n_Layer.className = \"Layer\";\nvar Layer = _Layer;\nvar TranslatableLayer = class extends Translatable(Layer) {\n};\n\n// packages/ag-charts-community/src/scene/shape/range.ts\nvar Range = class extends Shape {\n  constructor(opts = {}) {\n    super(opts);\n    this.x1 = 0;\n    this.y1 = 0;\n    this.x2 = 0;\n    this.y2 = 0;\n    this.startLine = false;\n    this.endLine = false;\n    this.isRange = false;\n    this.restoreOwnStyles();\n  }\n  computeBBox() {\n    return new BBox(this.x1, this.y1, this.x2 - this.x1, this.y2 - this.y1);\n  }\n  isPointInPath(_x, _y) {\n    return false;\n  }\n  render(renderCtx) {\n    const { ctx, forceRender, stats } = renderCtx;\n    if (this.dirty === 0 /* NONE */ && !forceRender) {\n      if (stats)\n        stats.nodesSkipped += nodeCount(this).count;\n      return;\n    }\n    let { x1, y1, x2, y2 } = this;\n    x1 = this.align(x1);\n    y1 = this.align(y1);\n    x2 = this.align(x2);\n    y2 = this.align(y2);\n    const { fill, opacity, isRange } = this;\n    const fillActive = !!(isRange && fill);\n    if (fillActive) {\n      const { fillOpacity } = this;\n      this.applyFill(ctx);\n      ctx.globalAlpha = opacity * fillOpacity;\n      ctx.beginPath();\n      ctx.moveTo(x1, y1);\n      ctx.lineTo(x2, y1);\n      ctx.lineTo(x2, y2);\n      ctx.lineTo(x1, y2);\n      ctx.closePath();\n      ctx.fill();\n    }\n    const { stroke, strokeWidth, startLine, endLine } = this;\n    const strokeActive = !!((startLine || endLine) && stroke && strokeWidth);\n    if (strokeActive) {\n      const { strokeOpacity, lineDash, lineDashOffset, lineCap, lineJoin } = this;\n      ctx.strokeStyle = stroke;\n      ctx.globalAlpha = opacity * strokeOpacity;\n      ctx.lineWidth = strokeWidth;\n      if (lineDash) {\n        ctx.setLineDash(lineDash);\n      }\n      if (lineDashOffset) {\n        ctx.lineDashOffset = lineDashOffset;\n      }\n      if (lineCap) {\n        ctx.lineCap = lineCap;\n      }\n      if (lineJoin) {\n        ctx.lineJoin = lineJoin;\n      }\n      ctx.beginPath();\n      if (startLine) {\n        ctx.moveTo(x1, y1);\n        ctx.lineTo(x2, y1);\n      }\n      if (endLine) {\n        ctx.moveTo(x2, y2);\n        ctx.lineTo(x1, y2);\n      }\n      ctx.stroke();\n    }\n    this.fillShadow?.markClean();\n    super.render(renderCtx);\n  }\n};\nRange.className = \"Range\";\nRange.defaultStyles = {\n  ...Shape.defaultStyles,\n  strokeWidth: 1\n};\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], Range.prototype, \"x1\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], Range.prototype, \"y1\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], Range.prototype, \"x2\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], Range.prototype, \"y2\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], Range.prototype, \"startLine\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], Range.prototype, \"endLine\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], Range.prototype, \"isRange\", 2);\n\n// packages/ag-charts-community/src/chart/label.ts\nvar Label = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n    this.fontSize = 12;\n    this.fontFamily = \"Verdana, sans-serif\";\n  }\n  getFont() {\n    return TextUtils.toFontString(this);\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], Label.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], Label.prototype, \"color\", 2);\n__decorateClass([\n  Validate(FONT_STYLE, { optional: true })\n], Label.prototype, \"fontStyle\", 2);\n__decorateClass([\n  Validate(FONT_WEIGHT, { optional: true })\n], Label.prototype, \"fontWeight\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Label.prototype, \"fontSize\", 2);\n__decorateClass([\n  Validate(STRING)\n], Label.prototype, \"fontFamily\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], Label.prototype, \"formatter\", 2);\nfunction calculateLabelRotation(opts) {\n  const { parallelFlipRotation = 0, regularFlipRotation = 0 } = opts;\n  const configuredRotation = opts.rotation ? normalizeAngle360(toRadians(opts.rotation)) : 0;\n  const parallelFlipFlag = !configuredRotation && parallelFlipRotation >= 0 && parallelFlipRotation <= Math.PI ? -1 : 1;\n  const regularFlipFlag = !configuredRotation && regularFlipRotation >= 0 && regularFlipRotation <= Math.PI ? -1 : 1;\n  let defaultRotation = 0;\n  if (opts.parallel) {\n    defaultRotation = parallelFlipFlag * Math.PI / 2;\n  } else if (regularFlipFlag === -1) {\n    defaultRotation = Math.PI;\n  }\n  return { configuredRotation, defaultRotation, parallelFlipFlag, regularFlipFlag };\n}\nfunction getLabelSpacing(minSpacing, rotated) {\n  if (!isNaN(minSpacing)) {\n    return minSpacing;\n  }\n  return rotated ? 0 : 10;\n}\nfunction getTextBaseline(parallel, labelRotation, sideFlag, parallelFlipFlag) {\n  if (parallel && !labelRotation) {\n    return sideFlag * parallelFlipFlag === -1 ? \"hanging\" : \"bottom\";\n  }\n  return \"middle\";\n}\nfunction getTextAlign(parallel, labelRotation, labelAutoRotation, sideFlag, regularFlipFlag) {\n  const labelRotated = labelRotation > 0 && labelRotation <= Math.PI;\n  const labelAutoRotated = labelAutoRotation > 0 && labelAutoRotation <= Math.PI;\n  const alignFlag = labelRotated || labelAutoRotated ? -1 : 1;\n  if (parallel) {\n    if (labelRotation || labelAutoRotation) {\n      if (sideFlag * alignFlag === -1) {\n        return \"end\";\n      }\n    } else {\n      return \"center\";\n    }\n  } else if (sideFlag * regularFlipFlag === -1) {\n    return \"end\";\n  }\n  return \"start\";\n}\nfunction calculateLabelBBox(text, bbox, labelMatrix) {\n  const { x: labelX, y: labelY, width: width2, height: height2 } = bbox;\n  const translatedBBox = new BBox(labelX, labelY, 0, 0);\n  labelMatrix.transformBBox(translatedBBox, bbox);\n  const { x, y } = bbox;\n  return {\n    point: { x, y },\n    label: { text, width: width2, height: height2 }\n  };\n}\n\n// packages/ag-charts-community/src/chart/zIndexMap.ts\nvar ZIndexMap = /* @__PURE__ */ ((ZIndexMap2) => {\n  ZIndexMap2[ZIndexMap2[\"SERIES_BACKGROUND\"] = 0] = \"SERIES_BACKGROUND\";\n  ZIndexMap2[ZIndexMap2[\"AXIS_GRID\"] = 1] = \"AXIS_GRID\";\n  ZIndexMap2[ZIndexMap2[\"AXIS\"] = 2] = \"AXIS\";\n  ZIndexMap2[ZIndexMap2[\"SERIES_CROSSLINE_RANGE\"] = 3] = \"SERIES_CROSSLINE_RANGE\";\n  ZIndexMap2[ZIndexMap2[\"SERIES_LAYER\"] = 4] = \"SERIES_LAYER\";\n  ZIndexMap2[ZIndexMap2[\"SERIES_HIGHLIGHT\"] = 5] = \"SERIES_HIGHLIGHT\";\n  ZIndexMap2[ZIndexMap2[\"AXIS_FOREGROUND\"] = 6] = \"AXIS_FOREGROUND\";\n  ZIndexMap2[ZIndexMap2[\"SERIES_CROSSHAIR\"] = 7] = \"SERIES_CROSSHAIR\";\n  ZIndexMap2[ZIndexMap2[\"CHART_OVERLAY\"] = 8] = \"CHART_OVERLAY\";\n  ZIndexMap2[ZIndexMap2[\"SERIES_CROSSLINE_LINE\"] = 9] = \"SERIES_CROSSLINE_LINE\";\n  ZIndexMap2[ZIndexMap2[\"SERIES_ANNOTATION\"] = 10] = \"SERIES_ANNOTATION\";\n  ZIndexMap2[ZIndexMap2[\"CHART_ANNOTATION\"] = 11] = \"CHART_ANNOTATION\";\n  ZIndexMap2[ZIndexMap2[\"CHART_ANNOTATION_FOCUSED\"] = 12] = \"CHART_ANNOTATION_FOCUSED\";\n  ZIndexMap2[ZIndexMap2[\"STATUS_BAR\"] = 13] = \"STATUS_BAR\";\n  ZIndexMap2[ZIndexMap2[\"SERIES_LABEL\"] = 14] = \"SERIES_LABEL\";\n  ZIndexMap2[ZIndexMap2[\"LEGEND\"] = 15] = \"LEGEND\";\n  ZIndexMap2[ZIndexMap2[\"NAVIGATOR\"] = 16] = \"NAVIGATOR\";\n  ZIndexMap2[ZIndexMap2[\"FOREGROUND\"] = 17] = \"FOREGROUND\";\n  return ZIndexMap2;\n})(ZIndexMap || {});\n\n// packages/ag-charts-community/src/util/value.ts\nfunction isStringObject(value) {\n  return value != null && Object.hasOwn(value, \"toString\") && isString(value.toString());\n}\nfunction isNumberObject(value) {\n  return value != null && Object.hasOwn(value, \"valueOf\") && isFiniteNumber(value.valueOf());\n}\nfunction isContinuous(value) {\n  return isFiniteNumber(value) || isValidDate(value) || isNumberObject(value);\n}\nfunction checkDatum(value, isContinuousScale) {\n  return value != null && (!isContinuousScale || isContinuous(value));\n}\nfunction transformIntegratedCategoryValue(value) {\n  if (isStringObject(value) && Object.hasOwn(value, \"id\")) {\n    return value.id;\n  }\n  return value;\n}\n\n// packages/ag-charts-community/src/chart/crossline/crossLine.ts\nvar MATCHING_CROSSLINE_TYPE = (property) => {\n  return property === \"value\" ? predicateWithMessage(\n    (_, ctx) => ctx.target[\"type\"] === \"line\",\n    (ctx) => ctx.target[\"type\"] === \"range\" ? `crossLine type 'range' to have a 'range' property instead of 'value'` : `crossLine property 'type' to be 'line'`\n  ) : predicateWithMessage(\n    (_, ctx) => ctx.target[\"type\"] === \"range\",\n    (ctx) => ctx.target.type === \"line\" ? `crossLine type 'line' to have a 'value' property instead of 'range'` : `crossLine property 'type' to be 'range'`\n  );\n};\nvar validateCrossLineValues = (type, value, range3, scale2, visibilityCheck) => {\n  const lineCrossLine = type === \"line\" && value !== void 0;\n  const rangeCrossLine = type === \"range\" && range3 !== void 0;\n  if (!lineCrossLine && !rangeCrossLine) {\n    return true;\n  }\n  const [start2, end2] = range3 ?? [value, void 0];\n  const isContinuous2 = ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2);\n  const validStart = checkDatum(start2, isContinuous2) && !isNaN(scale2.convert(start2));\n  const validEnd = checkDatum(end2, isContinuous2) && !isNaN(scale2.convert(end2));\n  if (lineCrossLine && validStart || rangeCrossLine && validStart && validEnd) {\n    return visibilityCheck?.() ?? true;\n  }\n  const message = [`Expecting crossLine`];\n  if (rangeCrossLine) {\n    if (!validStart) {\n      message.push(`range start ${stringify(start2)}`);\n    }\n    if (!validEnd) {\n      message.push(`${validStart ? \"\" : \"and \"}range end ${stringify(end2)}`);\n    }\n  } else {\n    message.push(`value ${stringify(start2)}`);\n  }\n  message.push(`to match the axis scale domain.`);\n  Logger.warnOnce(message.join(\" \"));\n  return false;\n};\n\n// packages/ag-charts-community/src/chart/crossline/crossLineLabelPosition.ts\nvar horizontalCrosslineTranslationDirections = {\n  top: { xTranslationDirection: 0, yTranslationDirection: -1 },\n  bottom: { xTranslationDirection: 0, yTranslationDirection: 1 },\n  left: { xTranslationDirection: -1, yTranslationDirection: 0 },\n  right: { xTranslationDirection: 1, yTranslationDirection: 0 },\n  topLeft: { xTranslationDirection: 1, yTranslationDirection: -1 },\n  topRight: { xTranslationDirection: -1, yTranslationDirection: -1 },\n  bottomLeft: { xTranslationDirection: 1, yTranslationDirection: 1 },\n  bottomRight: { xTranslationDirection: -1, yTranslationDirection: 1 },\n  inside: { xTranslationDirection: 0, yTranslationDirection: 0 },\n  insideLeft: { xTranslationDirection: 1, yTranslationDirection: 0 },\n  insideRight: { xTranslationDirection: -1, yTranslationDirection: 0 },\n  insideTop: { xTranslationDirection: 0, yTranslationDirection: 1 },\n  insideBottom: { xTranslationDirection: 0, yTranslationDirection: -1 },\n  insideTopLeft: { xTranslationDirection: 1, yTranslationDirection: 1 },\n  insideBottomLeft: { xTranslationDirection: 1, yTranslationDirection: -1 },\n  insideTopRight: { xTranslationDirection: -1, yTranslationDirection: 1 },\n  insideBottomRight: { xTranslationDirection: -1, yTranslationDirection: -1 }\n};\nvar verticalCrossLineTranslationDirections = {\n  top: { xTranslationDirection: 1, yTranslationDirection: 0 },\n  bottom: { xTranslationDirection: -1, yTranslationDirection: 0 },\n  left: { xTranslationDirection: 0, yTranslationDirection: -1 },\n  right: { xTranslationDirection: 0, yTranslationDirection: 1 },\n  topLeft: { xTranslationDirection: -1, yTranslationDirection: -1 },\n  topRight: { xTranslationDirection: -1, yTranslationDirection: 1 },\n  bottomLeft: { xTranslationDirection: 1, yTranslationDirection: -1 },\n  bottomRight: { xTranslationDirection: 1, yTranslationDirection: 1 },\n  inside: { xTranslationDirection: 0, yTranslationDirection: 0 },\n  insideLeft: { xTranslationDirection: 0, yTranslationDirection: 1 },\n  insideRight: { xTranslationDirection: 0, yTranslationDirection: -1 },\n  insideTop: { xTranslationDirection: -1, yTranslationDirection: 0 },\n  insideBottom: { xTranslationDirection: 1, yTranslationDirection: 0 },\n  insideTopLeft: { xTranslationDirection: -1, yTranslationDirection: 1 },\n  insideBottomLeft: { xTranslationDirection: 1, yTranslationDirection: 1 },\n  insideTopRight: { xTranslationDirection: -1, yTranslationDirection: -1 },\n  insideBottomRight: { xTranslationDirection: 1, yTranslationDirection: -1 }\n};\nfunction calculateLabelTranslation({\n  yDirection,\n  padding = 0,\n  position = \"top\",\n  bbox\n}) {\n  const crossLineTranslationDirections = yDirection ? horizontalCrosslineTranslationDirections : verticalCrossLineTranslationDirections;\n  const { xTranslationDirection, yTranslationDirection } = crossLineTranslationDirections[position];\n  const xTranslation = xTranslationDirection * (padding + bbox.width / 2);\n  const yTranslation = yTranslationDirection * (padding + bbox.height / 2);\n  return {\n    xTranslation,\n    yTranslation\n  };\n}\nfunction calculateLabelChartPadding({\n  yDirection,\n  bbox,\n  padding = 0,\n  position = \"top\"\n}) {\n  const chartPadding = {};\n  if (position.startsWith(\"inside\"))\n    return chartPadding;\n  if (position === \"top\" && !yDirection) {\n    chartPadding.top = padding + bbox.height;\n  } else if (position === \"bottom\" && !yDirection) {\n    chartPadding.bottom = padding + bbox.height;\n  } else if (position === \"left\" && yDirection) {\n    chartPadding.left = padding + bbox.width;\n  } else if (position === \"right\" && yDirection) {\n    chartPadding.right = padding + bbox.width;\n  }\n  return chartPadding;\n}\nvar POSITION_TOP_COORDINATES = ({ direction, xEnd, yStart, yEnd }) => {\n  if (direction === \"y\" /* Y */) {\n    return { x: xEnd / 2, y: yStart };\n  } else {\n    return { x: xEnd, y: isNaN(yEnd) ? yStart : (yStart + yEnd) / 2 };\n  }\n};\nvar POSITION_LEFT_COORDINATES = ({ direction, xStart, xEnd, yStart, yEnd }) => {\n  if (direction === \"y\" /* Y */) {\n    return { x: xStart, y: isNaN(yEnd) ? yStart : (yStart + yEnd) / 2 };\n  } else {\n    return { x: xEnd / 2, y: yStart };\n  }\n};\nvar POSITION_RIGHT_COORDINATES = ({ direction, xEnd, yStart, yEnd }) => {\n  if (direction === \"y\" /* Y */) {\n    return { x: xEnd, y: isNaN(yEnd) ? yStart : (yStart + yEnd) / 2 };\n  } else {\n    return { x: xEnd / 2, y: isNaN(yEnd) ? yStart : yEnd };\n  }\n};\nvar POSITION_BOTTOM_COORDINATES = ({ direction, xStart, xEnd, yStart, yEnd }) => {\n  if (direction === \"y\" /* Y */) {\n    return { x: xEnd / 2, y: isNaN(yEnd) ? yStart : yEnd };\n  } else {\n    return { x: xStart, y: isNaN(yEnd) ? yStart : (yStart + yEnd) / 2 };\n  }\n};\nvar POSITION_INSIDE_COORDINATES = ({ xEnd, yStart, yEnd }) => {\n  return { x: xEnd / 2, y: isNaN(yEnd) ? yStart : (yStart + yEnd) / 2 };\n};\nvar POSITION_TOP_LEFT_COORDINATES = ({ direction, xStart, xEnd, yStart }) => {\n  if (direction === \"y\" /* Y */) {\n    return { x: xStart / 2, y: yStart };\n  } else {\n    return { x: xEnd, y: yStart };\n  }\n};\nvar POSITION_BOTTOM_LEFT_COORDINATES = ({ direction, xStart, yStart, yEnd }) => {\n  if (direction === \"y\" /* Y */) {\n    return { x: xStart, y: isNaN(yEnd) ? yStart : yEnd };\n  } else {\n    return { x: xStart, y: yStart };\n  }\n};\nvar POSITION_TOP_RIGHT_COORDINATES = ({ direction, xEnd, yStart, yEnd }) => {\n  if (direction === \"y\" /* Y */) {\n    return { x: xEnd, y: yStart };\n  } else {\n    return { x: xEnd, y: isNaN(yEnd) ? yStart : yEnd };\n  }\n};\nvar POSITION_BOTTOM_RIGHT_COORDINATES = ({ direction, xStart, xEnd, yStart, yEnd }) => {\n  if (direction === \"y\" /* Y */) {\n    return { x: xEnd, y: isNaN(yEnd) ? yStart : yEnd };\n  } else {\n    return { x: xStart, y: isNaN(yEnd) ? yStart : yEnd };\n  }\n};\nvar labelDirectionHandling = {\n  top: { c: POSITION_TOP_COORDINATES },\n  bottom: { c: POSITION_BOTTOM_COORDINATES },\n  left: { c: POSITION_LEFT_COORDINATES },\n  right: { c: POSITION_RIGHT_COORDINATES },\n  topLeft: { c: POSITION_TOP_LEFT_COORDINATES },\n  topRight: { c: POSITION_TOP_RIGHT_COORDINATES },\n  bottomLeft: { c: POSITION_BOTTOM_LEFT_COORDINATES },\n  bottomRight: { c: POSITION_BOTTOM_RIGHT_COORDINATES },\n  inside: { c: POSITION_INSIDE_COORDINATES },\n  insideLeft: { c: POSITION_LEFT_COORDINATES },\n  insideRight: { c: POSITION_RIGHT_COORDINATES },\n  insideTop: { c: POSITION_TOP_COORDINATES },\n  insideBottom: { c: POSITION_BOTTOM_COORDINATES },\n  insideTopLeft: { c: POSITION_TOP_LEFT_COORDINATES },\n  insideBottomLeft: { c: POSITION_BOTTOM_LEFT_COORDINATES },\n  insideTopRight: { c: POSITION_TOP_RIGHT_COORDINATES },\n  insideBottomRight: { c: POSITION_BOTTOM_RIGHT_COORDINATES }\n};\n\n// packages/ag-charts-community/src/chart/crossline/cartesianCrossLine.ts\nvar CROSSLINE_LABEL_POSITION = UNION(\n  [\n    \"top\",\n    \"left\",\n    \"right\",\n    \"bottom\",\n    \"topLeft\",\n    \"topRight\",\n    \"bottomLeft\",\n    \"bottomRight\",\n    \"inside\",\n    \"insideLeft\",\n    \"insideRight\",\n    \"insideTop\",\n    \"insideBottom\",\n    \"insideTopLeft\",\n    \"insideBottomLeft\",\n    \"insideTopRight\",\n    \"insideBottomRight\"\n  ],\n  \"crossLine label position\"\n);\nvar CartesianCrossLineLabel = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.fontSize = 14;\n    this.fontFamily = \"Verdana, sans-serif\";\n    this.padding = 5;\n    this.color = \"rgba(87, 87, 87, 1)\";\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], CartesianCrossLineLabel.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], CartesianCrossLineLabel.prototype, \"text\", 2);\n__decorateClass([\n  Validate(FONT_STYLE, { optional: true })\n], CartesianCrossLineLabel.prototype, \"fontStyle\", 2);\n__decorateClass([\n  Validate(FONT_WEIGHT, { optional: true })\n], CartesianCrossLineLabel.prototype, \"fontWeight\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], CartesianCrossLineLabel.prototype, \"fontSize\", 2);\n__decorateClass([\n  Validate(STRING)\n], CartesianCrossLineLabel.prototype, \"fontFamily\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], CartesianCrossLineLabel.prototype, \"padding\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], CartesianCrossLineLabel.prototype, \"color\", 2);\n__decorateClass([\n  Validate(CROSSLINE_LABEL_POSITION, { optional: true })\n], CartesianCrossLineLabel.prototype, \"position\", 2);\n__decorateClass([\n  Validate(DEGREE, { optional: true })\n], CartesianCrossLineLabel.prototype, \"rotation\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], CartesianCrossLineLabel.prototype, \"parallel\", 2);\nvar _CartesianCrossLine = class _CartesianCrossLine extends BaseProperties {\n  constructor() {\n    super();\n    this.id = createId(this);\n    this.label = new CartesianCrossLineLabel();\n    this.scale = void 0;\n    this.clippedRange = [-Infinity, Infinity];\n    this.gridLength = 0;\n    this.sideFlag = -1;\n    this.parallelFlipRotation = 0;\n    this.regularFlipRotation = 0;\n    this.direction = \"x\" /* X */;\n    this.group = new Layer({ name: this.id, zIndex: _CartesianCrossLine.LINE_LAYER_ZINDEX });\n    this.labelGroup = new Layer({ name: this.id, zIndex: _CartesianCrossLine.LABEL_LAYER_ZINDEX });\n    this.crossLineRange = new Range();\n    this.crossLineLabel = new TransformableText();\n    this.labelPoint = void 0;\n    this.data = [];\n    this.startLine = false;\n    this.endLine = false;\n    this.isRange = false;\n    this.group.append(this.crossLineRange);\n    this.labelGroup.append(this.crossLineLabel);\n    this.crossLineRange.pointerEvents = 1 /* None */;\n  }\n  update(visible) {\n    const { enabled, data, type, value, range: range3, scale: scale2 } = this;\n    if (!type || !scale2 || !enabled || !visible || !validateCrossLineValues(type, value, range3, scale2) || data.length === 0) {\n      this.group.visible = false;\n      this.labelGroup.visible = false;\n      return;\n    }\n    this.group.visible = visible;\n    this.labelGroup.visible = visible;\n    this.group.zIndex = this.getZIndex(this.isRange);\n    this.updateNodes();\n  }\n  calculateLayout(visible, reversedAxis) {\n    if (!visible)\n      return;\n    const {\n      scale: scale2,\n      gridLength,\n      sideFlag,\n      direction,\n      label: { position = \"top\" },\n      clippedRange,\n      strokeWidth = 0\n    } = this;\n    this.data = [];\n    if (!scale2)\n      return;\n    const bandwidth = scale2.bandwidth ?? 0;\n    const step = scale2.step ?? 0;\n    const padding = (reversedAxis ? -1 : 1) * (scale2 instanceof BandScale ? (step - bandwidth) / 2 : 0);\n    const [xStart, xEnd] = [0, sideFlag * gridLength];\n    let [yStart, yEnd] = this.getRange();\n    const ordinalTimeScalePadding = yEnd === void 0 && OrdinalTimeScale.is(scale2) ? bandwidth / 2 + padding : 0;\n    let [clampedYStart, clampedYEnd] = [\n      Number(scale2.convert(yStart, { clampMode: \"clamped\" })) - padding + ordinalTimeScalePadding,\n      scale2.convert(yEnd, { clampMode: \"clamped\" }) + bandwidth + padding\n    ];\n    clampedYStart = clampArray(clampedYStart, clippedRange);\n    clampedYEnd = clampArray(clampedYEnd, clippedRange);\n    [yStart, yEnd] = [Number(scale2.convert(yStart)) + ordinalTimeScalePadding, scale2.convert(yEnd) + bandwidth];\n    const validRange = (yStart === clampedYStart || yEnd === clampedYEnd || clampedYStart !== clampedYEnd) && Math.abs(clampedYEnd - clampedYStart) > 0;\n    if (validRange && clampedYStart > clampedYEnd) {\n      [clampedYStart, clampedYEnd] = [clampedYEnd, clampedYStart];\n      [yStart, yEnd] = [yEnd, yStart];\n    }\n    if (yStart - padding >= clampedYStart)\n      yStart -= padding;\n    if (yEnd + padding <= clampedYEnd)\n      yEnd += padding;\n    this.isRange = validRange;\n    this.startLine = strokeWidth > 0 && yStart >= clampedYStart && yStart <= clampedYStart + padding;\n    this.endLine = strokeWidth > 0 && yEnd >= clampedYEnd - bandwidth - padding && yEnd <= clampedYEnd;\n    if (!validRange && !this.startLine && !this.endLine)\n      return;\n    this.data = [clampedYStart, clampedYEnd];\n    if (!this.label.enabled)\n      return;\n    const { c = POSITION_TOP_COORDINATES } = labelDirectionHandling[position] ?? {};\n    const { x: labelX, y: labelY } = c({\n      direction,\n      xStart,\n      xEnd,\n      yStart: clampedYStart,\n      yEnd: clampedYEnd\n    });\n    this.labelPoint = {\n      x: labelX,\n      y: labelY\n    };\n  }\n  updateNodes() {\n    this.updateRangeNode();\n    if (this.label.enabled) {\n      this.updateLabel();\n      this.positionLabel();\n    }\n  }\n  updateRangeNode() {\n    const {\n      crossLineRange,\n      sideFlag,\n      gridLength,\n      data,\n      startLine,\n      endLine,\n      isRange,\n      fill,\n      fillOpacity,\n      stroke,\n      strokeWidth,\n      lineDash\n    } = this;\n    crossLineRange.x1 = 0;\n    crossLineRange.x2 = sideFlag * gridLength;\n    crossLineRange.y1 = data[0];\n    crossLineRange.y2 = data[1];\n    crossLineRange.startLine = startLine;\n    crossLineRange.endLine = endLine;\n    crossLineRange.isRange = isRange;\n    crossLineRange.fill = fill;\n    crossLineRange.fillOpacity = fillOpacity ?? 1;\n    crossLineRange.stroke = stroke;\n    crossLineRange.strokeWidth = strokeWidth ?? 1;\n    crossLineRange.strokeOpacity = this.strokeOpacity ?? 1;\n    crossLineRange.lineDash = lineDash;\n  }\n  updateLabel() {\n    const { crossLineLabel, label } = this;\n    if (!label.text)\n      return;\n    crossLineLabel.fontStyle = label.fontStyle;\n    crossLineLabel.fontWeight = label.fontWeight;\n    crossLineLabel.fontSize = label.fontSize;\n    crossLineLabel.fontFamily = label.fontFamily;\n    crossLineLabel.fill = label.color;\n    crossLineLabel.text = label.text;\n  }\n  positionLabel() {\n    const {\n      crossLineLabel,\n      labelPoint: { x = void 0, y = void 0 } = {},\n      label: { parallel, rotation, position = \"top\", padding = 0 },\n      direction,\n      parallelFlipRotation,\n      regularFlipRotation\n    } = this;\n    if (x === void 0 || y === void 0)\n      return;\n    const { defaultRotation, configuredRotation } = calculateLabelRotation({\n      rotation,\n      parallel,\n      regularFlipRotation,\n      parallelFlipRotation\n    });\n    crossLineLabel.rotation = defaultRotation + configuredRotation;\n    crossLineLabel.textBaseline = \"middle\";\n    crossLineLabel.textAlign = \"center\";\n    const bbox = crossLineLabel.getBBox();\n    if (!bbox)\n      return;\n    const yDirection = direction === \"y\" /* Y */;\n    const { xTranslation, yTranslation } = calculateLabelTranslation({\n      yDirection,\n      padding,\n      position,\n      bbox\n    });\n    crossLineLabel.translationX = x + xTranslation;\n    crossLineLabel.translationY = y + yTranslation;\n  }\n  getZIndex(isRange = false) {\n    return isRange ? _CartesianCrossLine.RANGE_LAYER_ZINDEX : _CartesianCrossLine.LINE_LAYER_ZINDEX;\n  }\n  getRange() {\n    const { value, range: range3, scale: scale2 } = this;\n    const isContinuous2 = ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2);\n    const start2 = range3?.[0] ?? value;\n    let end2 = range3?.[1];\n    if (!isContinuous2 && end2 === void 0) {\n      end2 = start2;\n    }\n    if (isContinuous2 && start2 === end2) {\n      end2 = void 0;\n    }\n    return [start2, end2];\n  }\n  computeLabelBBox() {\n    const { label } = this;\n    if (!label.enabled)\n      return;\n    const tempText = new TransformableText();\n    tempText.fontFamily = label.fontFamily;\n    tempText.fontSize = label.fontSize;\n    tempText.fontStyle = label.fontStyle;\n    tempText.fontWeight = label.fontWeight;\n    tempText.text = label.text;\n    const {\n      labelPoint: { x = void 0, y = void 0 } = {},\n      label: { parallel, rotation, position = \"top\", padding = 0 },\n      direction,\n      parallelFlipRotation,\n      regularFlipRotation\n    } = this;\n    if (x === void 0 || y === void 0)\n      return;\n    const { configuredRotation } = calculateLabelRotation({\n      rotation,\n      parallel,\n      regularFlipRotation,\n      parallelFlipRotation\n    });\n    tempText.rotation = configuredRotation;\n    tempText.textBaseline = \"middle\";\n    tempText.textAlign = \"center\";\n    const bbox = tempText.getBBox();\n    if (!bbox)\n      return;\n    const yDirection = direction === \"y\" /* Y */;\n    const { xTranslation, yTranslation } = calculateLabelTranslation({\n      yDirection,\n      padding,\n      position,\n      bbox\n    });\n    tempText.x = x + xTranslation;\n    tempText.y = y + yTranslation;\n    return tempText.getBBox();\n  }\n  calculatePadding(padding) {\n    const {\n      isRange,\n      startLine,\n      endLine,\n      direction,\n      label: { padding: labelPadding = 0, position = \"top\" }\n    } = this;\n    if (!isRange && !startLine && !endLine)\n      return;\n    const crossLineLabelBBox = this.computeLabelBBox();\n    if (crossLineLabelBBox?.x == null || crossLineLabelBBox?.y == null)\n      return;\n    const chartPadding = calculateLabelChartPadding({\n      yDirection: direction === \"y\" /* Y */,\n      padding: labelPadding,\n      position,\n      bbox: crossLineLabelBBox\n    });\n    padding.left = Math.max(padding.left ?? 0, chartPadding.left ?? 0);\n    padding.right = Math.max(padding.right ?? 0, chartPadding.right ?? 0);\n    padding.top = Math.max(padding.top ?? 0, chartPadding.top ?? 0);\n    padding.bottom = Math.max(padding.bottom ?? 0, chartPadding.bottom ?? 0);\n  }\n};\n_CartesianCrossLine.LINE_LAYER_ZINDEX = 9 /* SERIES_CROSSLINE_LINE */;\n_CartesianCrossLine.RANGE_LAYER_ZINDEX = 3 /* SERIES_CROSSLINE_RANGE */;\n_CartesianCrossLine.LABEL_LAYER_ZINDEX = 14 /* SERIES_LABEL */;\n_CartesianCrossLine.className = \"CrossLine\";\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], _CartesianCrossLine.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(UNION([\"range\", \"line\"], \"a crossLine type\"), { optional: true })\n], _CartesianCrossLine.prototype, \"type\", 2);\n__decorateClass([\n  Validate(AND(MATCHING_CROSSLINE_TYPE(\"range\"), ARRAY.restrict({ length: 2 })), {\n    optional: true\n  })\n], _CartesianCrossLine.prototype, \"range\", 2);\n__decorateClass([\n  Validate(MATCHING_CROSSLINE_TYPE(\"value\"), { optional: true })\n], _CartesianCrossLine.prototype, \"value\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], _CartesianCrossLine.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], _CartesianCrossLine.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], _CartesianCrossLine.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(NUMBER, { optional: true })\n], _CartesianCrossLine.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], _CartesianCrossLine.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH, { optional: true })\n], _CartesianCrossLine.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], _CartesianCrossLine.prototype, \"label\", 2);\nvar CartesianCrossLine = _CartesianCrossLine;\n\n// packages/ag-charts-community/src/chart/axis/axisGridLine.ts\nvar GRID_STYLE_KEYS = [\"stroke\", \"lineDash\"];\nvar GRID_STYLE = ARRAY_OF(\n  (value) => isObject(value) && Object.keys(value).every((key) => GRID_STYLE_KEYS.includes(key)),\n  \"objects with gridline style properties such as 'stroke' or 'lineDash'\"\n);\nvar AxisGridLine = class {\n  constructor() {\n    this.enabled = true;\n    this.width = 1;\n    this.style = [\n      {\n        stroke: void 0,\n        lineDash: []\n      }\n    ];\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisGridLine.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AxisGridLine.prototype, \"width\", 2);\n__decorateClass([\n  Validate(GRID_STYLE)\n], AxisGridLine.prototype, \"style\", 2);\n\n// packages/ag-charts-community/src/util/default.ts\nfunction Default(defaultValue, replaces = [void 0]) {\n  return addTransformToInstanceProperty((_, __, v) => {\n    if (replaces.includes(v)) {\n      return isFunction(defaultValue) ? defaultValue(v) : defaultValue;\n    }\n    return v;\n  });\n}\n\n// packages/ag-charts-community/src/chart/axis/axisInterval.ts\nvar TICK_INTERVAL = predicateWithMessage(\n  (value) => isFiniteNumber(value) && value > 0 || value instanceof TimeInterval,\n  `a non-zero positive Number value or, for a time axis, a Time Interval such as 'agCharts.time.month'`\n);\nvar AxisInterval = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.minSpacing = NaN;\n    this.maxSpacing = NaN;\n  }\n};\n__decorateClass([\n  Validate(TICK_INTERVAL, { optional: true })\n], AxisInterval.prototype, \"step\", 2);\n__decorateClass([\n  Validate(ARRAY, { optional: true })\n], AxisInterval.prototype, \"values\", 2);\n__decorateClass([\n  Validate(MIN_SPACING),\n  Default(NaN)\n], AxisInterval.prototype, \"minSpacing\", 2);\n__decorateClass([\n  Validate(MAX_SPACING),\n  Default(NaN)\n], AxisInterval.prototype, \"maxSpacing\", 2);\n\n// packages/ag-charts-community/src/chart/axis/axisLabel.ts\nvar AxisLabel = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n    this.fontSize = 12;\n    this.fontFamily = \"Verdana, sans-serif\";\n    this.padding = 5;\n    this.minSpacing = NaN;\n    this.color = \"#575757\";\n    this.avoidCollisions = true;\n    this.mirrored = false;\n    this.parallel = false;\n  }\n  /**\n   * The side of the axis line to position the labels on.\n   * -1 = left (default)\n   * 1 = right\n   */\n  getSideFlag() {\n    return this.mirrored ? 1 : -1;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisLabel.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(FONT_STYLE, { optional: true })\n], AxisLabel.prototype, \"fontStyle\", 2);\n__decorateClass([\n  Validate(FONT_WEIGHT, { optional: true })\n], AxisLabel.prototype, \"fontWeight\", 2);\n__decorateClass([\n  Validate(NUMBER.restrict({ min: 1 }))\n], AxisLabel.prototype, \"fontSize\", 2);\n__decorateClass([\n  Validate(STRING)\n], AxisLabel.prototype, \"fontFamily\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AxisLabel.prototype, \"padding\", 2);\n__decorateClass([\n  Validate(NUMBER_OR_NAN),\n  Default(NaN)\n], AxisLabel.prototype, \"minSpacing\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], AxisLabel.prototype, \"color\", 2);\n__decorateClass([\n  Validate(DEGREE, { optional: true })\n], AxisLabel.prototype, \"rotation\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisLabel.prototype, \"avoidCollisions\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisLabel.prototype, \"mirrored\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisLabel.prototype, \"parallel\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], AxisLabel.prototype, \"formatter\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], AxisLabel.prototype, \"format\", 2);\n\n// packages/ag-charts-community/src/chart/axis/axisLine.ts\nvar AxisLine = class {\n  constructor() {\n    this.enabled = true;\n    this.width = 1;\n    this.stroke = void 0;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisLine.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AxisLine.prototype, \"width\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], AxisLine.prototype, \"stroke\", 2);\n\n// packages/ag-charts-community/src/chart/axis/axisTick.ts\nvar AxisTick = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n    this.width = 1;\n    this.size = 6;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisTick.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AxisTick.prototype, \"width\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AxisTick.prototype, \"size\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], AxisTick.prototype, \"stroke\", 2);\n\n// packages/ag-charts-community/src/chart/axis/axisTitle.ts\nvar AxisTitle = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.caption = new Caption();\n    this.enabled = false;\n    this.spacing = Caption.SMALL_PADDING;\n    this.fontSize = 10;\n    this.fontFamily = \"sans-serif\";\n    this.wrapping = \"always\";\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisTitle.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], AxisTitle.prototype, \"text\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], AxisTitle.prototype, \"spacing\", 2);\n__decorateClass([\n  Validate(FONT_STYLE, { optional: true })\n], AxisTitle.prototype, \"fontStyle\", 2);\n__decorateClass([\n  Validate(FONT_WEIGHT, { optional: true })\n], AxisTitle.prototype, \"fontWeight\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AxisTitle.prototype, \"fontSize\", 2);\n__decorateClass([\n  Validate(STRING)\n], AxisTitle.prototype, \"fontFamily\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], AxisTitle.prototype, \"color\", 2);\n__decorateClass([\n  Validate(TEXT_WRAP)\n], AxisTitle.prototype, \"wrapping\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], AxisTitle.prototype, \"formatter\", 2);\n\n// packages/ag-charts-community/src/chart/axis/axisUtil.ts\nfunction prepareAxisAnimationContext(axis) {\n  const [requestedRangeMin, requestedRangeMax] = findMinMax(axis.range);\n  const min = Math.floor(requestedRangeMin);\n  const max = Math.ceil(requestedRangeMax);\n  return { min, max, visible: min !== max };\n}\nvar fullCircle = Math.PI * 2;\nvar halfCircle = fullCircle / 2;\nfunction normaliseEndRotation(start2, end2) {\n  const directDistance = Math.abs(end2 - start2);\n  if (directDistance < halfCircle) {\n    return end2;\n  } else if (start2 > end2) {\n    return end2 + fullCircle;\n  }\n  return end2 - fullCircle;\n}\nfunction prepareAxisAnimationFunctions(ctx) {\n  const outOfBounds = (y, range3) => {\n    const [min = ctx.min, max = ctx.max] = findMinMax(range3 ?? []);\n    return y < min || y > max;\n  };\n  const tick = {\n    fromFn(node, datum, status) {\n      let y = node.y1 + node.translationY;\n      let opacity = node.opacity;\n      if (status === \"added\" || outOfBounds(node.datum.translationY, node.datum.range)) {\n        y = datum.translationY;\n        opacity = 0;\n      }\n      return { y: 0, translationY: y, opacity, phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[status] };\n    },\n    toFn(_node, datum, status) {\n      const y = datum.translationY;\n      let opacity = 1;\n      if (status === \"removed\") {\n        opacity = 0;\n      }\n      return {\n        y: 0,\n        translationY: y,\n        opacity,\n        finish: {\n          // Set explicit y after animation so it's pixel aligned\n          y,\n          translationY: 0\n        }\n      };\n    },\n    applyFn(node, props) {\n      node.setProperties(props);\n      node.visible = !outOfBounds(node.y);\n    }\n  };\n  const label = {\n    fromFn(node, newDatum, status) {\n      const datum = node.previousDatum ?? newDatum;\n      const x = datum.x;\n      const y = datum.y;\n      const rotationCenterX = datum.rotationCenterX;\n      let translationY = Math.round(node.translationY);\n      let rotation = datum.rotation;\n      let opacity = node.opacity;\n      if (status === \"removed\" || outOfBounds(datum.y, datum.range)) {\n        rotation = newDatum.rotation;\n      } else if (status === \"added\" || outOfBounds(node.datum.y, node.datum.range)) {\n        translationY = Math.round(datum.translationY);\n        opacity = 0;\n        rotation = newDatum.rotation;\n      }\n      return {\n        x,\n        y,\n        rotationCenterX,\n        translationY,\n        rotation,\n        opacity,\n        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[status]\n      };\n    },\n    toFn(node, datum, status) {\n      const x = datum.x;\n      const y = datum.y;\n      const rotationCenterX = datum.rotationCenterX;\n      const translationY = Math.round(datum.translationY);\n      let rotation = 0;\n      let opacity = 1;\n      if (status === \"added\") {\n        opacity = 1;\n        rotation = datum.rotation;\n      } else if (status === \"removed\") {\n        opacity = 0;\n        rotation = datum.rotation;\n      } else {\n        rotation = normaliseEndRotation(node.previousDatum?.rotation ?? datum.rotation, datum.rotation);\n      }\n      return { x, y, rotationCenterX, translationY, rotation, opacity, finish: { rotation: datum.rotation } };\n    }\n  };\n  const line = {\n    fromFn(node, datum) {\n      return {\n        ...node.previousDatum ?? datum,\n        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[\"updated\"]\n      };\n    },\n    toFn(_node, datum) {\n      return { ...datum };\n    }\n  };\n  const group = {\n    fromFn(node, _datum) {\n      const { rotation, translationX, translationY } = node;\n      return {\n        rotation,\n        translationX,\n        translationY,\n        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[\"updated\"]\n      };\n    },\n    toFn(_node, datum) {\n      const { rotation, translationX, translationY } = datum;\n      return {\n        rotation,\n        translationX,\n        translationY\n      };\n    }\n  };\n  return { tick, line, label, group };\n}\nfunction resetAxisGroupFn() {\n  return (_node, datum) => {\n    return {\n      rotation: datum.rotation,\n      rotationCenterX: datum.rotationCenterX,\n      rotationCenterY: datum.rotationCenterY,\n      translationX: datum.translationX,\n      translationY: datum.translationY\n    };\n  };\n}\nfunction resetAxisSelectionFn(ctx) {\n  const { visible: rangeVisible, min, max } = ctx;\n  return (_node, datum) => {\n    const y = datum.translationY;\n    const visible = rangeVisible && y >= min && y <= max;\n    return {\n      y,\n      translationY: 0,\n      opacity: 1,\n      visible\n    };\n  };\n}\nfunction resetAxisLabelSelectionFn() {\n  return (_node, datum) => {\n    return {\n      x: datum.x,\n      y: datum.y,\n      translationY: datum.translationY,\n      rotation: datum.rotation,\n      rotationCenterX: datum.rotationCenterX\n    };\n  };\n}\nfunction resetAxisLineSelectionFn() {\n  return (_node, datum) => {\n    return { ...datum };\n  };\n}\n\n// packages/ag-charts-community/src/chart/axis/axis.ts\nvar TranslatableLine = class extends Translatable(Line) {\n};\nvar _Axis = class _Axis {\n  constructor(moduleCtx, scale2) {\n    this.moduleCtx = moduleCtx;\n    this.scale = scale2;\n    this.id = createId(this);\n    this.nice = true;\n    this.reverse = false;\n    this.keys = [];\n    this.interval = new AxisInterval();\n    this.dataDomain = { domain: [], clipped: false };\n    this.layoutConstraints = {\n      stacked: true,\n      align: \"start\",\n      width: 100,\n      unit: \"percent\"\n    };\n    this.boundSeries = [];\n    this.includeInvisibleDomains = false;\n    this.interactionEnabled = true;\n    this.axisGroup = new TransformableGroup({ name: `${this.id}-axis`, zIndex: 2 /* AXIS */ });\n    this.lineNode = this.axisGroup.appendChild(new TranslatableLine({ name: `${this.id}-Axis-line` }));\n    this.tickLineGroup = this.axisGroup.appendChild(\n      new Group({ name: `${this.id}-Axis-tick-lines`, zIndex: 2 /* AXIS */ })\n    );\n    this.tickLabelGroup = this.axisGroup.appendChild(\n      new Group({ name: `${this.id}-Axis-tick-labels`, zIndex: 2 /* AXIS */ })\n    );\n    this.crossLineGroup = new TransformableGroup({ name: `${this.id}-CrossLines` });\n    this.labelGroup = new Group({ name: `${this.id}-Labels`, zIndex: 10 /* SERIES_ANNOTATION */ });\n    this.gridGroup = new TransformableGroup({ name: `${this.id}-Axis-grid` });\n    this.gridLineGroup = this.gridGroup.appendChild(\n      new Group({\n        name: `${this.id}-gridLines`,\n        zIndex: 1 /* AXIS_GRID */\n      })\n    );\n    this.tickLineGroupSelection = Selection.select(this.tickLineGroup, TranslatableLine, false);\n    this.tickLabelGroupSelection = Selection.select(\n      this.tickLabelGroup,\n      TransformableText,\n      false\n    );\n    this.gridLineGroupSelection = Selection.select(this.gridLineGroup, TranslatableLine, false);\n    this._crossLines = [];\n    this.line = new AxisLine();\n    this.tick = new AxisTick();\n    this.gridLine = new AxisGridLine();\n    this.label = this.createLabel();\n    this.defaultTickMinSpacing = _Axis.defaultTickMinSpacing;\n    this.translation = { x: 0, y: 0 };\n    this.rotation = 0;\n    // axis rotation angle in degrees\n    this.layout = {\n      label: {\n        fractionDigits: 0,\n        padding: this.label.padding,\n        format: this.label.format\n      }\n    };\n    this.destroyFns = [];\n    this.range = [0, 1];\n    this.visibleRange = [0, 1];\n    this.title = new AxisTitle();\n    this.gridLength = 0;\n    /**\n     * The distance between the grid ticks and the axis ticks.\n     */\n    this.gridPadding = 0;\n    /**\n     * Is used to avoid collisions between axis labels and series.\n     */\n    this.seriesAreaPadding = 0;\n    this.tickGenerationResult = void 0;\n    this.moduleMap = new ModuleMap();\n    this.range = this.scale.range.slice();\n    this.crossLines.forEach((crossLine) => this.initCrossLine(crossLine));\n    this.axisGroup.appendChild(this.title.caption.node);\n    this.animationManager = moduleCtx.animationManager;\n    this.animationState = new StateMachine(\"empty\", {\n      empty: {\n        update: {\n          target: \"ready\",\n          action: () => this.resetSelectionNodes()\n        },\n        reset: \"empty\"\n      },\n      ready: {\n        update: (data) => this.animateReadyUpdate(data),\n        resize: () => this.resetSelectionNodes(),\n        reset: \"empty\"\n      }\n    });\n    let previousSize = void 0;\n    this.destroyFns.push(\n      this.title.caption.registerInteraction(this.moduleCtx, \"afterend\"),\n      moduleCtx.layoutManager.addListener(\"layout:complete\", (e) => {\n        if (previousSize != null && jsonDiff(e.chart, previousSize) != null) {\n          this.animationState.transition(\"resize\");\n        }\n        previousSize = { ...e.chart };\n      })\n    );\n  }\n  get type() {\n    return this.constructor.type ?? \"\";\n  }\n  set crossLines(value) {\n    const { CrossLineConstructor } = this.constructor;\n    this._crossLines.forEach((crossLine) => this.detachCrossLine(crossLine));\n    this._crossLines = value.map((crossLine) => {\n      const instance = new CrossLineConstructor();\n      instance.set(crossLine);\n      return instance;\n    });\n    this._crossLines.forEach((crossLine) => {\n      this.attachCrossLine(crossLine);\n      this.initCrossLine(crossLine);\n    });\n  }\n  get crossLines() {\n    return this._crossLines;\n  }\n  resetAnimation(phase) {\n    if (phase === \"initial\") {\n      this.animationState.transition(\"reset\");\n    }\n  }\n  attachCrossLine(crossLine) {\n    this.crossLineGroup.appendChild(crossLine.group);\n    this.crossLineGroup.appendChild(crossLine.labelGroup);\n  }\n  detachCrossLine(crossLine) {\n    this.crossLineGroup.removeChild(crossLine.group);\n    this.crossLineGroup.removeChild(crossLine.labelGroup);\n  }\n  destroy() {\n    this.moduleMap.destroy();\n    this.destroyFns.forEach((f) => f());\n  }\n  updateRange() {\n    const { range: rr, visibleRange: vr, scale: scale2 } = this;\n    const span = (rr[1] - rr[0]) / (vr[1] - vr[0]);\n    const shift = span * vr[0];\n    const start2 = rr[0] - shift;\n    scale2.setVisibleRange?.(vr);\n    scale2.range = [start2, start2 + span];\n    this.crossLines.forEach((crossLine) => {\n      crossLine.clippedRange = [rr[0], rr[1]];\n    });\n  }\n  setCrossLinesVisible(visible) {\n    this.crossLineGroup.visible = visible;\n  }\n  attachAxis(axisNode, gridNode) {\n    gridNode.appendChild(this.gridGroup);\n    axisNode.appendChild(this.axisGroup);\n    axisNode.appendChild(this.crossLineGroup);\n    axisNode.appendChild(this.labelGroup);\n  }\n  attachLabel(axisLabelNode) {\n    this.labelGroup.append(axisLabelNode);\n  }\n  detachAxis(axisNode, gridNode) {\n    gridNode.removeChild(this.gridGroup);\n    axisNode.removeChild(this.axisGroup);\n    axisNode.removeChild(this.crossLineGroup);\n    axisNode.removeChild(this.labelGroup);\n  }\n  /**\n   * Checks if a point or an object is in range.\n   * @param x A point (or object's starting point).\n   * @param tolerance Expands the range on both ends by this amount.\n   */\n  inRange(x, tolerance = 0) {\n    const [min, max] = findMinMax(this.range);\n    return x >= min - tolerance && x <= max + tolerance;\n  }\n  onFormatChange(ticks, fractionDigits, _domain, format) {\n    const { scale: scale2 } = this;\n    const logScale = scale2 instanceof LogScale;\n    const defaultFormatter = (formatOffset) => logScale ? String : (x) => typeof x === \"number\" ? x.toFixed(fractionDigits + formatOffset) : String(x);\n    if (format && scale2 && scale2.tickFormat) {\n      try {\n        const formatter = scale2.tickFormat({ ticks, specifier: format });\n        this.labelFormatter = formatter;\n        this.datumFormatter = formatter;\n      } catch (e) {\n        this.labelFormatter = defaultFormatter(0);\n        this.datumFormatter = defaultFormatter(1);\n        Logger.warnOnce(`the axis label format string ${format} is invalid. No formatting will be applied`);\n      }\n    } else {\n      this.labelFormatter = defaultFormatter(0);\n      this.datumFormatter = defaultFormatter(1);\n    }\n  }\n  onGridLengthChange(value, prevValue) {\n    if (prevValue ^ value) {\n      this.onGridVisibilityChange();\n    }\n    this.crossLines.forEach((crossLine) => this.initCrossLine(crossLine));\n  }\n  onGridVisibilityChange() {\n    this.gridLineGroupSelection.clear();\n  }\n  createLabel() {\n    return new AxisLabel();\n  }\n  /**\n   * Creates/removes/updates the scene graph nodes that constitute the axis.\n   */\n  update(animated = true) {\n    if (!this.tickGenerationResult) {\n      return;\n    }\n    const { rotation, parallelFlipRotation, regularFlipRotation } = this.calculateRotations();\n    const sideFlag = this.label.getSideFlag();\n    this.updatePosition();\n    const lineData = this.getAxisLineCoordinates();\n    const { tickData, combinedRotation, textBaseline, textAlign, primaryTickCount } = this.tickGenerationResult;\n    const previousTicks = this.tickLabelGroupSelection.nodes().map((node) => node.datum.tickId);\n    this.updateSelections(lineData, tickData.ticks, {\n      combinedRotation,\n      textAlign,\n      textBaseline,\n      range: this.scale.range\n    });\n    if (!animated || this.animationManager.isSkipped()) {\n      this.resetSelectionNodes();\n    } else {\n      const diff2 = this.calculateUpdateDiff(previousTicks, tickData);\n      this.animationState.transition(\"update\", diff2);\n    }\n    this.updateAxisLine();\n    this.updateLabels();\n    this.updateVisibility();\n    this.updateGridLines(sideFlag);\n    this.updateTickLines();\n    this.updateTitle({ anyTickVisible: tickData.ticks.length > 0 });\n    this.updateCrossLines({ rotation, parallelFlipRotation, regularFlipRotation });\n    this.updateLayoutState(tickData.fractionDigits);\n    return primaryTickCount;\n  }\n  getAxisLineCoordinates() {\n    const [min, max] = findMinMax(this.range);\n    return { x: 0, y1: min, y2: max };\n  }\n  getTickLineCoordinates(datum) {\n    const sideFlag = this.label.getSideFlag();\n    const x = sideFlag * this.getTickSize();\n    const x1 = Math.min(0, x);\n    const x2 = x1 + Math.abs(x);\n    const y = datum.translationY;\n    return { x1, x2, y };\n  }\n  getTickLabelProps(datum, params) {\n    const { label } = this;\n    const { combinedRotation, textBaseline, textAlign, range: range3 } = params;\n    const text = datum.tickLabel;\n    const sideFlag = label.getSideFlag();\n    const labelX = sideFlag * (this.getTickSize() + label.padding + this.seriesAreaPadding);\n    const visible = text !== \"\" && text != null;\n    return {\n      tickId: datum.tickId,\n      translationY: datum.translationY,\n      fill: label.color,\n      fontFamily: label.fontFamily,\n      fontSize: label.fontSize,\n      fontStyle: label.fontStyle,\n      fontWeight: label.fontWeight,\n      rotation: combinedRotation,\n      rotationCenterX: labelX,\n      text,\n      textAlign,\n      textBaseline,\n      visible,\n      x: labelX,\n      y: 0,\n      range: range3\n    };\n  }\n  getTickSize() {\n    return this.tick.enabled ? this.tick.size : 6;\n  }\n  setTitleProps(caption, params) {\n    const { title } = this;\n    if (!title.enabled) {\n      caption.enabled = false;\n      caption.node.visible = false;\n      return;\n    }\n    caption.color = title.color;\n    caption.fontFamily = title.fontFamily;\n    caption.fontSize = title.fontSize;\n    caption.fontStyle = title.fontStyle;\n    caption.fontWeight = title.fontWeight;\n    caption.enabled = title.enabled;\n    caption.wrapping = title.wrapping;\n    const titleNode = caption.node;\n    const padding = (title.spacing ?? 0) + params.spacing;\n    const sideFlag = this.label.getSideFlag();\n    const parallelFlipRotation = normalizeAngle360(this.rotation);\n    const titleRotationFlag = sideFlag === -1 && parallelFlipRotation > Math.PI && parallelFlipRotation < Math.PI * 2 ? -1 : 1;\n    const rotation = titleRotationFlag * sideFlag * Math.PI / 2;\n    const textBaseline = titleRotationFlag === 1 ? \"bottom\" : \"top\";\n    const { range: range3 } = this;\n    const x = Math.floor(titleRotationFlag * sideFlag * (range3[0] + range3[1]) / 2);\n    const y = sideFlag === -1 ? Math.floor(titleRotationFlag * -padding) : Math.floor(-padding);\n    const { callbackCache } = this.moduleCtx;\n    const { formatter = (p) => p.defaultValue } = title;\n    const text = callbackCache.call(formatter, this.getTitleFormatterParams());\n    caption.text = text;\n    titleNode.setProperties({ visible: true, text, textBaseline, x, y, rotation });\n  }\n  calculateLayout(domain, primaryTickCount) {\n    const { rotation, parallelFlipRotation, regularFlipRotation } = this.calculateRotations();\n    const sideFlag = this.label.getSideFlag();\n    const labelX = sideFlag * (this.getTickSize() + this.label.padding + this.seriesAreaPadding);\n    this.updateScale(domain);\n    this.tickGenerationResult = this.generateTicks({\n      primaryTickCount,\n      parallelFlipRotation,\n      regularFlipRotation,\n      labelX,\n      sideFlag\n    });\n    const { tickData, combinedRotation, textBaseline, textAlign, ...ticksResult } = this.tickGenerationResult;\n    this.updateLayoutState(tickData.fractionDigits);\n    const boxes = [];\n    const { x, y1, y2 } = this.getAxisLineCoordinates();\n    const lineBox = new BBox(\n      x + Math.min(sideFlag * this.seriesAreaPadding, 0),\n      y1,\n      this.seriesAreaPadding,\n      y2 - y1\n    );\n    boxes.push(lineBox);\n    if (this.tick.enabled) {\n      tickData.ticks.forEach((datum) => {\n        const { x1, x2, y } = this.getTickLineCoordinates(datum);\n        const tickLineBox = new BBox(x1, y, x2 - x1, 0);\n        boxes.push(tickLineBox);\n      });\n    }\n    if (this.label.enabled) {\n      const tempText = new TransformableText();\n      tickData.ticks.forEach((datum) => {\n        const labelProps = this.getTickLabelProps(datum, {\n          combinedRotation,\n          textAlign,\n          textBaseline,\n          range: this.scale.range\n        });\n        if (!labelProps.visible) {\n          return;\n        }\n        tempText.setProperties({\n          ...labelProps,\n          translationY: Math.round(datum.translationY)\n        });\n        const box = tempText.getBBox();\n        if (box) {\n          boxes.push(box);\n        }\n      });\n    }\n    if (this.title?.enabled) {\n      const caption = new Caption();\n      const spacing = BBox.merge(boxes).width;\n      this.setTitleProps(caption, { spacing });\n      const titleBox = caption.node.getBBox();\n      if (titleBox) {\n        boxes.push(titleBox);\n      }\n    }\n    const bbox = BBox.merge(boxes);\n    const transformedBBox = this.getTransformBox(bbox);\n    const anySeriesActive = this.isAnySeriesActive();\n    this.crossLines.forEach((crossLine) => {\n      var _a;\n      crossLine.sideFlag = -sideFlag;\n      crossLine.direction = rotation === -Math.PI / 2 ? \"x\" /* X */ : \"y\" /* Y */;\n      if (crossLine instanceof CartesianCrossLine) {\n        (_a = crossLine.label).parallel ?? (_a.parallel = this.label.parallel);\n      }\n      crossLine.parallelFlipRotation = parallelFlipRotation;\n      crossLine.regularFlipRotation = regularFlipRotation;\n      crossLine.calculateLayout?.(anySeriesActive, this.reverse);\n    });\n    return {\n      primaryTickCount: ticksResult.primaryTickCount,\n      bbox: transformedBBox\n    };\n  }\n  updateLayoutState(fractionDigits) {\n    this.layout.label = {\n      fractionDigits,\n      padding: this.label.padding,\n      format: this.label.format\n    };\n  }\n  getTransformBox(bbox) {\n    const matrix = new Matrix();\n    const { rotation, translationX, translationY } = this.getAxisTransform();\n    Matrix.updateTransformMatrix(matrix, 1, 1, rotation, translationX, translationY);\n    return matrix.transformBBox(bbox);\n  }\n  setDomain(domain) {\n    this.dataDomain = this.normaliseDataDomain(domain);\n    if (this.reverse) {\n      this.dataDomain.domain.reverse();\n    }\n    this.scale.domain = this.dataDomain.domain;\n  }\n  updateScale(domain) {\n    if (domain) {\n      this.setDomain(domain);\n    } else {\n      this.calculateDomain();\n    }\n    this.updateRange();\n    this.scale.interval = this.interval.step;\n    if (ContinuousScale.is(this.scale)) {\n      this.scale.nice = this.nice;\n      this.scale.update();\n    }\n  }\n  calculateRotations() {\n    const rotation = toRadians(this.rotation);\n    const parallelFlipRotation = normalizeAngle360(rotation);\n    const regularFlipRotation = normalizeAngle360(rotation - Math.PI / 2);\n    return { rotation, parallelFlipRotation, regularFlipRotation };\n  }\n  generateTicks({\n    primaryTickCount,\n    parallelFlipRotation,\n    regularFlipRotation,\n    labelX,\n    sideFlag\n  }) {\n    const {\n      scale: scale2,\n      interval: { minSpacing, maxSpacing },\n      label: { parallel, rotation, fontFamily, fontSize, fontStyle, fontWeight }\n    } = this;\n    const secondaryAxis = primaryTickCount !== void 0;\n    const { defaultRotation, configuredRotation, parallelFlipFlag, regularFlipFlag } = calculateLabelRotation({\n      rotation,\n      parallel,\n      regularFlipRotation,\n      parallelFlipRotation\n    });\n    const initialRotation = configuredRotation + defaultRotation;\n    const labelMatrix = new Matrix();\n    const { maxTickCount } = this.estimateTickCount({ minSpacing, maxSpacing });\n    const continuous = ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2);\n    const maxIterations = !continuous || isNaN(maxTickCount) ? 10 : maxTickCount;\n    let textAlign = getTextAlign(parallel, configuredRotation, 0, sideFlag, regularFlipFlag);\n    const textBaseline = getTextBaseline(parallel, configuredRotation, sideFlag, parallelFlipFlag);\n    const font = TextUtils.toFontString({ fontFamily, fontSize, fontStyle, fontWeight });\n    const textMeasurer = CachedTextMeasurerPool.getMeasurer({ font });\n    const textProps = {\n      fontFamily,\n      fontSize,\n      fontStyle,\n      fontWeight,\n      textBaseline,\n      textAlign\n    };\n    let tickData = {\n      rawTicks: [],\n      fractionDigits: 0,\n      ticks: [],\n      labelCount: 0\n    };\n    let index = 0;\n    let autoRotation = 0;\n    let labelOverlap = true;\n    let labelData = [];\n    let terminate = false;\n    while (labelOverlap && index <= maxIterations) {\n      if (terminate) {\n        break;\n      }\n      autoRotation = 0;\n      textAlign = getTextAlign(parallel, configuredRotation, 0, sideFlag, regularFlipFlag);\n      const tickStrategies = this.getTickStrategies({ secondaryAxis, index });\n      for (const strategy of tickStrategies) {\n        ({ tickData, index, autoRotation, terminate } = strategy({\n          index,\n          tickData,\n          textProps,\n          labelOverlap,\n          terminate,\n          primaryTickCount\n        }));\n        const rotated = configuredRotation !== 0 || autoRotation !== 0;\n        const labelRotation = initialRotation + autoRotation;\n        const labelSpacing = getLabelSpacing(this.label.minSpacing, rotated);\n        Matrix.updateTransformMatrix(labelMatrix, 1, 1, labelRotation, 0, 0);\n        textAlign = getTextAlign(parallel, configuredRotation, autoRotation, sideFlag, regularFlipFlag);\n        labelData = this.createLabelData(tickData.ticks, labelX, labelMatrix, textMeasurer);\n        labelOverlap = this.label.avoidCollisions ? axisLabelsOverlap(labelData, labelSpacing) : false;\n      }\n    }\n    const combinedRotation = defaultRotation + configuredRotation + autoRotation;\n    if (!secondaryAxis && tickData.rawTicks.length > 0) {\n      primaryTickCount = tickData.rawTicks.length;\n    }\n    return { tickData, primaryTickCount, combinedRotation, textBaseline, textAlign, labelData };\n  }\n  getTickStrategies({\n    index: iteration,\n    secondaryAxis\n  }) {\n    const { scale: scale2, label } = this;\n    const { minSpacing } = this.interval;\n    const continuous = ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2);\n    const avoidLabelCollisions = label.enabled && label.avoidCollisions;\n    const filterTicks = !continuous && iteration !== 0 && avoidLabelCollisions;\n    const autoRotate = label.autoRotate === true && label.rotation === void 0;\n    const strategies = [];\n    let tickGenerationType;\n    if (this.interval.values) {\n      tickGenerationType = 3 /* VALUES */;\n    } else if (secondaryAxis) {\n      tickGenerationType = 1 /* CREATE_SECONDARY */;\n    } else if (filterTicks) {\n      tickGenerationType = 2 /* FILTER */;\n    } else {\n      tickGenerationType = 0 /* CREATE */;\n    }\n    const tickGenerationStrategy = ({ index, tickData, primaryTickCount, terminate }) => this.createTickData(tickGenerationType, index, tickData, terminate, primaryTickCount);\n    strategies.push(tickGenerationStrategy);\n    if (!continuous && !isNaN(minSpacing)) {\n      const tickFilterStrategy = ({ index, tickData, primaryTickCount, terminate }) => this.createTickData(2 /* FILTER */, index, tickData, terminate, primaryTickCount);\n      strategies.push(tickFilterStrategy);\n    }\n    if (!avoidLabelCollisions) {\n      return strategies;\n    }\n    if (autoRotate) {\n      const autoRotateStrategy = ({ index, tickData, labelOverlap, terminate }) => ({\n        index,\n        tickData,\n        autoRotation: this.getAutoRotation(labelOverlap),\n        terminate\n      });\n      strategies.push(autoRotateStrategy);\n    }\n    return strategies;\n  }\n  createTickData(tickGenerationType, index, tickData, terminate, primaryTickCount) {\n    const { scale: scale2 } = this;\n    const { step, values, minSpacing, maxSpacing } = this.interval;\n    const { maxTickCount, minTickCount, defaultTickCount } = this.estimateTickCount({ minSpacing, maxSpacing });\n    const continuous = ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2);\n    const maxIterations = !continuous || isNaN(maxTickCount) ? 10 : maxTickCount;\n    let tickCount = continuous ? Math.max(defaultTickCount - index, minTickCount) : maxTickCount;\n    const regenerateTicks = step === void 0 && values === void 0 && tickCount > minTickCount && (continuous || tickGenerationType === 2 /* FILTER */);\n    let unchanged = true;\n    while (unchanged && index <= maxIterations) {\n      const prevTicks = tickData.rawTicks;\n      tickCount = continuous ? Math.max(defaultTickCount - index, minTickCount) : maxTickCount;\n      const { rawTicks, fractionDigits, ticks, labelCount } = this.getTicks({\n        tickGenerationType,\n        previousTicks: prevTicks,\n        tickCount,\n        minTickCount,\n        maxTickCount,\n        primaryTickCount\n      });\n      tickData.rawTicks = rawTicks;\n      tickData.fractionDigits = fractionDigits;\n      tickData.ticks = ticks;\n      tickData.labelCount = labelCount;\n      unchanged = regenerateTicks ? areArrayNumbersEqual(rawTicks, prevTicks) : false;\n      index++;\n    }\n    const shouldTerminate = step !== void 0 || values !== void 0;\n    terminate || (terminate = shouldTerminate);\n    return { tickData, index, autoRotation: 0, terminate };\n  }\n  createLabelData(tickData, labelX, labelMatrix, textMeasurer) {\n    const labelData = [];\n    for (const { tickLabel, translationY } of tickData) {\n      if (!tickLabel)\n        continue;\n      const { width: width2, height: height2 } = textMeasurer.measureLines(tickLabel);\n      const bbox = new BBox(labelX, translationY, width2, height2);\n      const labelDatum = calculateLabelBBox(tickLabel, bbox, labelMatrix);\n      labelData.push(labelDatum);\n    }\n    return labelData;\n  }\n  getAutoRotation(labelOverlap) {\n    return labelOverlap ? normalizeAngle360(toRadians(this.label.autoRotateAngle ?? 0)) : 0;\n  }\n  getTicks({\n    tickGenerationType,\n    previousTicks,\n    tickCount,\n    minTickCount,\n    maxTickCount,\n    primaryTickCount\n  }) {\n    const { range: range3, scale: scale2, visibleRange } = this;\n    let rawTicks;\n    switch (tickGenerationType) {\n      case 3 /* VALUES */:\n        rawTicks = this.interval.values;\n        if (ContinuousScale.is(scale2)) {\n          const [d0, d1] = findMinMax(scale2.getDomain().map(Number));\n          rawTicks = rawTicks.filter((value) => value >= d0 && value <= d1).sort((a, b) => a - b);\n        }\n        break;\n      case 1 /* CREATE_SECONDARY */:\n        if (ContinuousScale.is(scale2)) {\n          rawTicks = this.updateSecondaryAxisTicks(primaryTickCount);\n        } else {\n          rawTicks = this.createTicks(tickCount, minTickCount, maxTickCount);\n        }\n        break;\n      case 2 /* FILTER */:\n        rawTicks = this.filterTicks(previousTicks, tickCount);\n        break;\n      default:\n        rawTicks = this.createTicks(tickCount, minTickCount, maxTickCount);\n        break;\n    }\n    const fractionDigits = rawTicks.reduce(\n      (max, tick) => Math.max(max, typeof tick === \"number\" ? countFractionDigits(tick) : 0),\n      0\n    );\n    const halfBandwidth = (scale2.bandwidth ?? 0) / 2;\n    const ticks = [];\n    let labelCount = 0;\n    const tickIdCounts = /* @__PURE__ */ new Map();\n    const start2 = Math.max(0, Math.floor(visibleRange[0] * rawTicks.length));\n    const end2 = Math.min(rawTicks.length, Math.ceil(visibleRange[1] * rawTicks.length));\n    const filteredTicks = rawTicks.slice(start2, end2);\n    this.onFormatChange(filteredTicks, fractionDigits, rawTicks, this.label.format);\n    for (let i = 0; i < filteredTicks.length; i++) {\n      const tick = filteredTicks[i];\n      const translationY = scale2.convert(tick) + halfBandwidth;\n      if (range3.length > 0 && !this.inRange(translationY, 1e-3))\n        continue;\n      const tickLabel = this.formatTick(tick, fractionDigits, start2 + i);\n      let tickId = tickLabel;\n      if (tickIdCounts.has(tickId)) {\n        const count = tickIdCounts.get(tickId);\n        tickIdCounts.set(tickId, count + 1);\n        tickId = `${tickId}_${count}`;\n      } else {\n        tickIdCounts.set(tickId, 1);\n      }\n      ticks.push({ tick, tickId, tickLabel, translationY: Math.floor(translationY) });\n      if (tickLabel === \"\" || tickLabel == null) {\n        continue;\n      }\n      labelCount++;\n    }\n    return { rawTicks, fractionDigits, ticks, labelCount };\n  }\n  filterTicks(ticks, tickCount) {\n    const { minSpacing, maxSpacing } = this.interval;\n    const tickSpacing = !isNaN(minSpacing) || !isNaN(maxSpacing);\n    const keepEvery = tickSpacing ? Math.ceil(ticks.length / tickCount) : 2;\n    return ticks.filter((_, i) => i % keepEvery === 0);\n  }\n  createTicks(tickCount, minTickCount, maxTickCount) {\n    const { scale: scale2 } = this;\n    if (tickCount && (ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2))) {\n      scale2.tickCount = tickCount;\n      scale2.minTickCount = minTickCount ?? 0;\n      scale2.maxTickCount = maxTickCount ?? Infinity;\n    }\n    return scale2.ticks?.() ?? [];\n  }\n  estimateTickCount({ minSpacing, maxSpacing }) {\n    if (!this.label.avoidCollisions) {\n      return {\n        minTickCount: ContinuousScale.defaultMaxTickCount,\n        maxTickCount: ContinuousScale.defaultMaxTickCount,\n        defaultTickCount: ContinuousScale.defaultMaxTickCount\n      };\n    }\n    const rangeWithBleed = this.calculateRangeWithBleed();\n    const defaultMinSpacing = Math.max(\n      this.defaultTickMinSpacing,\n      rangeWithBleed / ContinuousScale.defaultMaxTickCount\n    );\n    let clampMaxTickCount = !isNaN(maxSpacing);\n    if (isNaN(minSpacing)) {\n      minSpacing = defaultMinSpacing;\n    }\n    if (isNaN(maxSpacing)) {\n      maxSpacing = rangeWithBleed;\n    }\n    if (minSpacing > maxSpacing) {\n      if (minSpacing === defaultMinSpacing) {\n        minSpacing = maxSpacing;\n      } else {\n        maxSpacing = minSpacing;\n      }\n    }\n    const minRectDistance = 2;\n    clampMaxTickCount && (clampMaxTickCount = minRectDistance < defaultMinSpacing);\n    const maxTickCount = clamp(\n      1,\n      Math.floor(rangeWithBleed / minSpacing),\n      clampMaxTickCount ? Math.min(Math.floor(rangeWithBleed / minRectDistance), 100) : 100\n    );\n    const minTickCount = Math.min(maxTickCount, Math.ceil(rangeWithBleed / maxSpacing));\n    const defaultTickCount = clamp(minTickCount, ContinuousScale.defaultTickCount, maxTickCount);\n    return { minTickCount, maxTickCount, defaultTickCount };\n  }\n  updateVisibility() {\n    if (this.moduleCtx.animationManager.isSkipped()) {\n      this.resetSelectionNodes();\n    }\n    this.tickLineGroup.visible = this.tick.enabled;\n    this.gridLineGroup.visible = this.gridLine.enabled;\n    this.tickLabelGroup.visible = this.label.enabled;\n  }\n  updateCrossLines({\n    rotation,\n    parallelFlipRotation,\n    regularFlipRotation\n  }) {\n    const sideFlag = this.label.getSideFlag();\n    const anySeriesActive = this.isAnySeriesActive();\n    this.crossLines.forEach((crossLine) => {\n      var _a;\n      crossLine.sideFlag = -sideFlag;\n      crossLine.direction = rotation === -Math.PI / 2 ? \"x\" /* X */ : \"y\" /* Y */;\n      if (crossLine instanceof CartesianCrossLine) {\n        (_a = crossLine.label).parallel ?? (_a.parallel = this.label.parallel);\n      }\n      crossLine.parallelFlipRotation = parallelFlipRotation;\n      crossLine.regularFlipRotation = regularFlipRotation;\n      crossLine.update(anySeriesActive);\n    });\n  }\n  updateTickLines() {\n    const { tick, label } = this;\n    const sideFlag = label.getSideFlag();\n    this.tickLineGroupSelection.each((line) => {\n      line.strokeWidth = tick.width;\n      line.stroke = tick.stroke;\n      line.x1 = sideFlag * this.getTickSize();\n      line.x2 = 0;\n    });\n  }\n  calculateAvailableRange() {\n    return findRangeExtent(this.range);\n  }\n  /**\n   * Calculates the available range with an additional \"bleed\" beyond the canvas that encompasses the full axis when\n   * the visible range is only a portion of the axis.\n   */\n  calculateRangeWithBleed() {\n    const visibleScale = 1 / findRangeExtent(this.visibleRange);\n    return round(this.calculateAvailableRange() * visibleScale, 2);\n  }\n  calculateDomain() {\n    const visibleSeries = this.boundSeries.filter((s) => this.includeInvisibleDomains || s.isEnabled());\n    const domains = visibleSeries.flatMap((series) => series.getDomain(this.direction));\n    this.setDomain(domains);\n  }\n  getAxisTransform() {\n    return {\n      rotation: toRadians(this.rotation),\n      translationX: Math.floor(this.translation.x),\n      translationY: Math.floor(this.translation.y)\n    };\n  }\n  updatePosition() {\n    const { crossLineGroup, axisGroup, gridGroup, translation } = this;\n    const { rotation } = this.calculateRotations();\n    const translationX = Math.floor(translation.x);\n    const translationY = Math.floor(translation.y);\n    crossLineGroup.setProperties({ rotation, translationX, translationY });\n    gridGroup.setProperties({ rotation, translationX, translationY });\n    axisGroup.datum = this.getAxisTransform();\n  }\n  updateSecondaryAxisTicks(_primaryTickCount) {\n    throw new Error(\"AG Charts - unexpected call to updateSecondaryAxisTicks() - check axes configuration.\");\n  }\n  updateSelections(lineData, data, params) {\n    const getDatumId = (datum) => datum.tickId;\n    const labelsData = data.map((d) => this.getTickLabelProps(d, params));\n    this.lineNode.datum = lineData;\n    this.gridLineGroupSelection.update(this.gridLength ? data : [], void 0, getDatumId);\n    this.tickLineGroupSelection.update(data, void 0, getDatumId);\n    this.tickLabelGroupSelection.update(labelsData, void 0, getDatumId);\n  }\n  updateAxisLine() {\n    const { enabled, stroke, width: width2 } = this.line;\n    this.lineNode.setProperties({ stroke, strokeWidth: enabled ? width2 : 0 });\n  }\n  updateGridLines(sideFlag) {\n    const {\n      gridLine: { style, width: width2 },\n      gridPadding,\n      gridLength\n    } = this;\n    if (gridLength === 0 || style.length === 0) {\n      return;\n    }\n    this.gridLineGroupSelection.each((line, _, index) => {\n      const { stroke, lineDash } = style[index % style.length];\n      line.setProperties({\n        x1: gridPadding,\n        x2: -sideFlag * gridLength + gridPadding,\n        stroke,\n        strokeWidth: width2,\n        lineDash\n      });\n    });\n  }\n  updateLabels() {\n    if (!this.label.enabled)\n      return;\n    this.tickLabelGroupSelection.each((node, datum) => {\n      node.setProperties(datum, [\n        \"fill\",\n        \"fontFamily\",\n        \"fontSize\",\n        \"fontStyle\",\n        \"fontWeight\",\n        \"text\",\n        \"textAlign\",\n        \"textBaseline\"\n      ]);\n    });\n  }\n  updateTitle(params) {\n    const { title, lineNode, tickLineGroup, tickLabelGroup } = this;\n    let spacing = 0;\n    if (title.enabled && params.anyTickVisible) {\n      const tickBBox = Group.computeChildrenBBox([tickLineGroup, tickLabelGroup, lineNode]);\n      spacing += tickBBox.width + (this.tickLabelGroup.visible ? 0 : this.seriesAreaPadding);\n    }\n    this.setTitleProps(title.caption, { spacing });\n  }\n  // For formatting (nice rounded) tick values.\n  formatTick(datum, fractionDigits, index) {\n    return String(this.getFormatter(index, true)(datum, fractionDigits));\n  }\n  // For formatting arbitrary values between the ticks.\n  formatDatum(datum) {\n    return String(this.getFormatter()(datum));\n  }\n  getFormatter(index = 0, isTickLabel) {\n    const {\n      label,\n      labelFormatter,\n      datumFormatter,\n      moduleCtx: { callbackCache }\n    } = this;\n    if (label.formatter) {\n      return (datum, fractionDigits) => callbackCache.call(label.formatter, { value: datum, index, fractionDigits }) ?? datum;\n    } else if (!isTickLabel && datumFormatter) {\n      return (datum) => callbackCache.call(datumFormatter, datum) ?? String(datum);\n    } else if (labelFormatter) {\n      return (datum) => callbackCache.call(labelFormatter, datum) ?? String(datum);\n    }\n    return (datum) => String(datum);\n  }\n  getBBox() {\n    return this.axisGroup.getBBox();\n  }\n  getRegionNode() {\n    return void 0;\n  }\n  initCrossLine(crossLine) {\n    crossLine.scale = this.scale;\n    crossLine.gridLength = this.gridLength;\n  }\n  isAnySeriesActive() {\n    return this.boundSeries.some((s) => this.includeInvisibleDomains || s.isEnabled());\n  }\n  clipTickLines(x, y, width2, height2) {\n    this.tickLineGroup.setClipRect(new BBox(x, y, width2, height2));\n  }\n  clipGrid(x, y, width2, height2) {\n    this.gridGroup.setClipRect(new BBox(x, y, width2, height2));\n  }\n  getTitleFormatterParams() {\n    const { direction } = this;\n    const boundSeries = [];\n    for (const series of this.boundSeries) {\n      const keys = series.getKeys(direction);\n      const names = series.getNames(direction);\n      for (let idx = 0; idx < keys.length; idx++) {\n        boundSeries.push({ key: keys[idx], name: names[idx] });\n      }\n    }\n    return { direction, boundSeries, defaultValue: this.title?.text };\n  }\n  normaliseDataDomain(d) {\n    return { domain: [...d], clipped: false };\n  }\n  getLayoutState() {\n    return {\n      id: this.id,\n      rect: this.getBBox(),\n      gridPadding: this.gridPadding,\n      seriesAreaPadding: this.seriesAreaPadding,\n      tickSize: this.getTickSize(),\n      direction: this.direction,\n      domain: this.dataDomain.domain,\n      scale: this.scale,\n      ...this.layout\n    };\n  }\n  getModuleMap() {\n    return this.moduleMap;\n  }\n  createModuleContext() {\n    this.axisContext ?? (this.axisContext = this.createAxisContext());\n    return { ...this.moduleCtx, parent: this.axisContext };\n  }\n  createAxisContext() {\n    const { scale: scale2 } = this;\n    return {\n      axisId: this.id,\n      scale: this.scale,\n      direction: this.direction,\n      continuous: ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2),\n      keys: () => this.boundSeries.flatMap((s) => s.getKeys(this.direction)),\n      seriesKeyProperties: () => this.boundSeries.reduce((keys, series) => {\n        const seriesKeys = series.getKeyProperties(this.direction);\n        seriesKeys.forEach((key) => {\n          if (keys.indexOf(key) < 0) {\n            keys.push(key);\n          }\n        });\n        return keys;\n      }, []),\n      scaleValueFormatter: (specifier) => this.getScaleValueFormatter(specifier),\n      scaleBandwidth: () => scale2.bandwidth ?? 0,\n      scaleDomain: () => scale2.getDomain?.(),\n      scaleConvert: (val) => scale2.convert(val),\n      scaleInvert: OrdinalTimeScale.is(scale2) ? (val) => scale2.invertNearest?.(val) : (val) => scale2.invert?.(val),\n      scaleInvertNearest: (val) => scale2.invertNearest?.(val),\n      scaleStep: () => scale2.step ?? 0,\n      attachLabel: (node) => this.attachLabel(node),\n      inRange: (x, tolerance) => this.inRange(x, tolerance)\n    };\n  }\n  getScaleValueFormatter(format) {\n    const { scale: scale2 } = this;\n    if (format && scale2 && scale2.tickFormat) {\n      try {\n        return scale2.tickFormat({ specifier: format });\n      } catch (e) {\n        Logger.warnOnce(`the format string ${format} is invalid, ignoring.`);\n      }\n    }\n    return this.getFormatter();\n  }\n  animateReadyUpdate(diff2) {\n    const { animationManager } = this.moduleCtx;\n    const selectionCtx = prepareAxisAnimationContext(this);\n    const fns = prepareAxisAnimationFunctions(selectionCtx);\n    fromToMotion(this.id, \"axis-group\", animationManager, [this.axisGroup], fns.group);\n    fromToMotion(this.id, \"line\", animationManager, [this.lineNode], fns.line);\n    fromToMotion(\n      this.id,\n      \"line-paths\",\n      animationManager,\n      [this.gridLineGroupSelection, this.tickLineGroupSelection],\n      fns.tick,\n      (_, d) => d.tickId,\n      diff2\n    );\n    fromToMotion(\n      this.id,\n      \"tick-labels\",\n      animationManager,\n      [this.tickLabelGroupSelection],\n      fns.label,\n      (_, d) => d.tickId,\n      diff2\n    );\n  }\n  resetSelectionNodes() {\n    const { gridLineGroupSelection, tickLineGroupSelection, tickLabelGroupSelection, lineNode } = this;\n    const selectionCtx = prepareAxisAnimationContext(this);\n    resetMotion([this.axisGroup], resetAxisGroupFn());\n    resetMotion([gridLineGroupSelection, tickLineGroupSelection], resetAxisSelectionFn(selectionCtx));\n    resetMotion([tickLabelGroupSelection], resetAxisLabelSelectionFn());\n    resetMotion([lineNode], resetAxisLineSelectionFn());\n  }\n  calculateUpdateDiff(previous, tickData) {\n    const added = /* @__PURE__ */ new Set();\n    const removed = /* @__PURE__ */ new Set();\n    const tickMap = {};\n    const tickCount = Math.max(previous.length, tickData.ticks.length);\n    for (let i = 0; i < tickCount; i++) {\n      const tickDatum = tickData.ticks[i];\n      const prev = previous[i];\n      const tick = tickDatum?.tickId;\n      tickMap[tick ?? prev] = tickDatum;\n      if (prev === tick) {\n        continue;\n      }\n      if (removed.has(tick)) {\n        removed.delete(tick);\n      } else if (tick) {\n        added.add(tick);\n      }\n      if (added.has(prev)) {\n        added.delete(prev);\n      } else if (prev) {\n        removed.add(prev);\n      }\n    }\n    return { changed: added.size > 0 || removed.size > 0, added, removed };\n  }\n  isReversed() {\n    return this.reverse;\n  }\n};\n_Axis.defaultTickMinSpacing = 50;\n_Axis.CrossLineConstructor = CartesianCrossLine;\n__decorateClass([\n  Validate(BOOLEAN)\n], _Axis.prototype, \"nice\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], _Axis.prototype, \"reverse\", 2);\n__decorateClass([\n  Validate(STRING_ARRAY)\n], _Axis.prototype, \"keys\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], _Axis.prototype, \"interval\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], _Axis.prototype, \"title\", 2);\n__decorateClass([\n  ObserveChanges((target, value, oldValue) => target.onGridLengthChange(value, oldValue))\n], _Axis.prototype, \"gridLength\", 2);\nvar Axis = _Axis;\n\n// packages/ag-charts-community/src/chart/axis/cartesianAxisLabel.ts\nvar CartesianAxisLabel = class extends AxisLabel {\n  constructor() {\n    super(...arguments);\n    this.autoRotateAngle = 335;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], CartesianAxisLabel.prototype, \"autoRotate\", 2);\n__decorateClass([\n  Validate(DEGREE)\n], CartesianAxisLabel.prototype, \"autoRotateAngle\", 2);\n\n// packages/ag-charts-community/src/chart/axis/cartesianAxis.ts\nvar _CartesianAxis = class _CartesianAxis extends Axis {\n  constructor() {\n    super(...arguments);\n    this.thickness = 0;\n  }\n  static is(value) {\n    return value instanceof _CartesianAxis;\n  }\n  get direction() {\n    return this.position === \"top\" || this.position === \"bottom\" ? \"x\" /* X */ : \"y\" /* Y */;\n  }\n  updateDirection() {\n    switch (this.position) {\n      case \"top\":\n        this.rotation = -90;\n        this.label.mirrored = true;\n        this.label.parallel = true;\n        break;\n      case \"right\":\n        this.rotation = 0;\n        this.label.mirrored = true;\n        this.label.parallel = false;\n        break;\n      case \"bottom\":\n        this.rotation = -90;\n        this.label.mirrored = false;\n        this.label.parallel = true;\n        break;\n      case \"left\":\n        this.rotation = 0;\n        this.label.mirrored = false;\n        this.label.parallel = false;\n        break;\n    }\n    if (this.axisContext) {\n      this.axisContext.position = this.position;\n      this.axisContext.direction = this.direction;\n    }\n  }\n  update(animated) {\n    this.updateDirection();\n    return super.update(animated);\n  }\n  calculateLayout(domain, primaryTickCount) {\n    this.updateDirection();\n    return super.calculateLayout(domain, primaryTickCount);\n  }\n  createAxisContext() {\n    return { ...super.createAxisContext(), position: this.position };\n  }\n  createLabel() {\n    return new CartesianAxisLabel();\n  }\n  getRegionNode() {\n    return this.axisGroup;\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], _CartesianAxis.prototype, \"thickness\", 2);\n__decorateClass([\n  Validate(POSITION)\n], _CartesianAxis.prototype, \"position\", 2);\nvar CartesianAxis = _CartesianAxis;\n\n// packages/ag-charts-community/src/chart/axis/categoryAxis.ts\nvar _CategoryAxis = class _CategoryAxis extends CartesianAxis {\n  constructor(moduleCtx, scale2 = new BandScale()) {\n    super(moduleCtx, scale2);\n    this.groupPaddingInner = 0.1;\n    this.includeInvisibleDomains = true;\n  }\n  static is(value) {\n    return value instanceof _CategoryAxis;\n  }\n  normaliseDataDomain(d) {\n    const domain = [];\n    const uniqueValues = /* @__PURE__ */ new Set();\n    for (const v of d) {\n      const key = v instanceof Date ? v.getTime() : v;\n      if (!uniqueValues.has(key)) {\n        uniqueValues.add(key);\n        domain.push(v);\n      }\n    }\n    return { domain, clipped: false };\n  }\n  updateScale(domain) {\n    let { paddingInner, paddingOuter } = this;\n    if (!isFiniteNumber(paddingInner) || !isFiniteNumber(paddingOuter)) {\n      const padding = this.reduceBandScalePadding();\n      paddingInner ?? (paddingInner = padding.inner);\n      paddingOuter ?? (paddingOuter = padding.outer);\n    }\n    this.scale.paddingInner = paddingInner ?? 0;\n    this.scale.paddingOuter = paddingOuter ?? 0;\n    super.updateScale(domain);\n  }\n  reduceBandScalePadding() {\n    return this.boundSeries.reduce(\n      (result, series) => {\n        const padding = series.getBandScalePadding?.();\n        if (padding) {\n          if (result.inner > padding.inner) {\n            result.inner = padding.inner;\n          }\n          if (result.outer < padding.outer) {\n            result.outer = padding.outer;\n          }\n        }\n        return result;\n      },\n      { inner: Infinity, outer: -Infinity }\n    );\n  }\n};\n_CategoryAxis.className = \"CategoryAxis\";\n_CategoryAxis.type = \"category\";\n__decorateClass([\n  Validate(RATIO)\n], _CategoryAxis.prototype, \"groupPaddingInner\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], _CategoryAxis.prototype, \"paddingInner\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], _CategoryAxis.prototype, \"paddingOuter\", 2);\nvar CategoryAxis = _CategoryAxis;\n\n// packages/ag-charts-community/src/chart/axis/tree.ts\nvar TreeNode = class {\n  // current number in sibling group (index)\n  constructor(label = \"\", parent, number2 = 0) {\n    this.x = 0;\n    this.y = 0;\n    this.subtreeLeft = NaN;\n    this.subtreeRight = NaN;\n    this.screenX = 0;\n    this.screenY = 0;\n    this.children = [];\n    this.leafCount = 0;\n    this.prelim = 0;\n    this.mod = 0;\n    this.ancestor = this;\n    this.change = 0;\n    this.shift = 0;\n    this.label = label;\n    this.parent = parent;\n    this.depth = parent ? parent.depth + 1 : 0;\n    this.number = number2;\n  }\n  getLeftSibling() {\n    return this.number > 0 && this.parent ? this.parent.children[this.number - 1] : void 0;\n  }\n  getLeftmostSibling() {\n    return this.number > 0 && this.parent ? this.parent.children[0] : void 0;\n  }\n  // traverse the left contour of a subtree, return the successor of v on this contour\n  nextLeft() {\n    return this.children ? this.children[0] : this.thread;\n  }\n  // traverse the right contour of a subtree, return the successor of v on this contour\n  nextRight() {\n    return this.children ? this.children[this.children.length - 1] : this.thread;\n  }\n  getSiblings() {\n    return this.parent ? this.parent.children.filter((_, i) => i !== this.number) : [];\n  }\n};\nfunction ticksToTree(ticks, pad2 = true) {\n  const root = new TreeNode();\n  let depth = 0;\n  if (pad2) {\n    ticks.forEach((tick) => depth = Math.max(depth, tick.labels.length));\n  }\n  ticks.forEach((tick) => {\n    if (pad2) {\n      while (tick.labels.length < depth) {\n        tick.labels.unshift(\"\");\n      }\n    }\n    insertTick(root, tick);\n  });\n  return root;\n}\nfunction insertTick(root, tick) {\n  const pathParts = tick.labels.slice().reverse();\n  const lastPartIndex = pathParts.length - 1;\n  pathParts.forEach((pathPart, partIndex) => {\n    const children = root.children;\n    const existingNode = children.find((child) => child.label === pathPart);\n    const isNotLeaf = partIndex !== lastPartIndex;\n    if (existingNode && isNotLeaf) {\n      root = existingNode;\n    } else {\n      const node = new TreeNode(pathPart, root);\n      node.number = children.length;\n      children.push(node);\n      if (isNotLeaf) {\n        root = node;\n      }\n    }\n  });\n}\nfunction moveSubtree(wm, wp, shift) {\n  const subtrees = wp.number - wm.number;\n  const ratio2 = shift / subtrees;\n  wp.change -= ratio2;\n  wp.shift += shift;\n  wm.change += ratio2;\n  wp.prelim += shift;\n  wp.mod += shift;\n}\nfunction ancestor(vim, v, defaultAncestor) {\n  return v.getSiblings().indexOf(vim.ancestor) >= 0 ? vim.ancestor : defaultAncestor;\n}\nfunction executeShifts(v) {\n  const children = v.children;\n  if (children) {\n    let shift = 0;\n    let change = 0;\n    for (let i = children.length - 1; i >= 0; i--) {\n      const w = children[i];\n      w.prelim += shift;\n      w.mod += shift;\n      change += w.change;\n      shift += w.shift + change;\n    }\n  }\n}\nfunction apportion(v, defaultAncestor, distance3) {\n  const w = v.getLeftSibling();\n  if (w) {\n    let vop = v;\n    let vip = v;\n    let vim = w;\n    let vom = vip.getLeftmostSibling();\n    let sip = vip.mod;\n    let sop = vop.mod;\n    let sim = vim.mod;\n    let som = vom.mod;\n    while (vim.nextRight() && vip.nextLeft()) {\n      vim = vim.nextRight();\n      vip = vip.nextLeft();\n      vom = vom.nextLeft();\n      vop = vop.nextRight();\n      vop.ancestor = v;\n      const shift = vim.prelim + sim - (vip.prelim + sip) + distance3;\n      if (shift > 0) {\n        moveSubtree(ancestor(vim, v, defaultAncestor), v, shift);\n        sip += shift;\n        sop += shift;\n      }\n      sim += vim.mod;\n      sip += vip.mod;\n      som += vom.mod;\n      sop += vop.mod;\n    }\n    if (vim.nextRight() && !vop.nextRight()) {\n      vop.thread = vim.nextRight();\n      vop.mod += sim - sop;\n    } else {\n      if (vip.nextLeft() && !vom.nextLeft()) {\n        vom.thread = vip.nextLeft();\n        vom.mod += sip - som;\n      }\n      defaultAncestor = v;\n    }\n  }\n  return defaultAncestor;\n}\nfunction firstWalk(node, distance3) {\n  const children = node.children;\n  if (children.length) {\n    let defaultAncestor = children[0];\n    children.forEach((child) => {\n      firstWalk(child, distance3);\n      defaultAncestor = apportion(child, defaultAncestor, distance3);\n    });\n    executeShifts(node);\n    const midpoint = (children[0].prelim + children.at(-1).prelim) / 2;\n    const leftSibling = node.getLeftSibling();\n    if (leftSibling) {\n      node.prelim = leftSibling.prelim + distance3;\n      node.mod = node.prelim - midpoint;\n    } else {\n      node.prelim = midpoint;\n    }\n  } else {\n    const leftSibling = node.getLeftSibling();\n    node.prelim = leftSibling ? leftSibling.prelim + distance3 : 0;\n  }\n}\nvar Dimensions = class {\n  constructor() {\n    this.top = Infinity;\n    this.right = -Infinity;\n    this.bottom = -Infinity;\n    this.left = Infinity;\n  }\n  update(node, xy) {\n    const { x, y } = xy(node);\n    if (x > this.right) {\n      this.right = x;\n    }\n    if (x < this.left) {\n      this.left = x;\n    }\n    if (y > this.bottom) {\n      this.bottom = y;\n    }\n    if (y < this.top) {\n      this.top = y;\n    }\n  }\n};\nfunction secondWalk(v, m, layout) {\n  v.x = v.prelim + m;\n  v.y = v.depth;\n  layout.update(v);\n  v.children.forEach((w) => secondWalk(w, m + v.mod, layout));\n}\nfunction thirdWalk(v) {\n  const children = v.children;\n  let leafCount = 0;\n  children.forEach((w) => {\n    thirdWalk(w);\n    if (w.children.length) {\n      leafCount += w.leafCount;\n    } else {\n      leafCount++;\n    }\n  });\n  v.leafCount = leafCount;\n  if (children.length) {\n    v.subtreeLeft = children[0].subtreeLeft;\n    v.subtreeRight = children[v.children.length - 1].subtreeRight;\n    v.x = (v.subtreeLeft + v.subtreeRight) / 2;\n  } else {\n    v.subtreeLeft = v.x;\n    v.subtreeRight = v.x;\n  }\n}\nfunction treeLayout(root) {\n  const layout = new TreeLayout();\n  firstWalk(root, 1);\n  secondWalk(root, -root.prelim, layout);\n  thirdWalk(root);\n  return layout;\n}\nvar TreeLayout = class {\n  constructor() {\n    this.dimensions = new Dimensions();\n    this.leafCount = 0;\n    this.nodes = [];\n    // One might want to process leaf nodes separately from the rest of the tree.\n    // For example, position labels corresponding to leafs vertically, rather than horizontally.\n    this.leafNodes = [];\n    this.nonLeafNodes = [];\n    this.depth = 0;\n  }\n  update(node) {\n    this.dimensions.update(node, (n) => ({ x: n.x, y: n.y }));\n    if (node.children.length) {\n      this.nonLeafNodes.push(node);\n    } else {\n      this.leafCount++;\n      this.leafNodes.push(node);\n    }\n    if (node.depth > this.depth) {\n      this.depth = node.depth;\n    }\n    this.nodes.push(node);\n  }\n  resize(width2, height2, shiftX = 0, shiftY = 0, flipX = false) {\n    const xSteps = this.leafCount - 1;\n    const ySteps = this.depth;\n    const dimensions = this.dimensions;\n    let scalingX = 1;\n    let scalingY = 1;\n    if (width2 > 0 && xSteps) {\n      const existingSpacingX = (dimensions.right - dimensions.left) / xSteps;\n      const desiredSpacingX = width2 / xSteps;\n      scalingX = desiredSpacingX / existingSpacingX;\n      if (flipX) {\n        scalingX = -scalingX;\n      }\n    }\n    if (height2 > 0 && ySteps) {\n      const existingSpacingY = (dimensions.bottom - dimensions.top) / ySteps;\n      const desiredSpacingY = height2 / ySteps;\n      scalingY = desiredSpacingY / existingSpacingY;\n    }\n    const screenDimensions = new Dimensions();\n    this.nodes.forEach((node) => {\n      node.screenX = node.x * scalingX;\n      node.screenY = node.y * scalingY;\n      screenDimensions.update(node, (n) => ({ x: n.screenX, y: n.screenY }));\n    });\n    const offsetX = -screenDimensions.left;\n    const offsetY = -screenDimensions.top;\n    this.nodes.forEach((node) => {\n      node.screenX += offsetX + shiftX;\n      node.screenY += offsetY + shiftY;\n    });\n  }\n};\n\n// packages/ag-charts-community/src/chart/axis/groupedCategoryAxis.ts\nvar GroupedCategoryAxisLabel = class extends AxisLabel {\n  constructor() {\n    super(...arguments);\n    this.grid = false;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], GroupedCategoryAxisLabel.prototype, \"grid\", 2);\nvar GroupedCategoryAxis = class extends CartesianAxis {\n  constructor(moduleCtx) {\n    const scale2 = new BandScale();\n    scale2.paddingOuter = 0.1;\n    scale2.paddingInner = scale2.paddingOuter * 2;\n    super(moduleCtx, scale2);\n    // Label scale (labels are positioned between ticks, tick count = label count + 1).\n    // We don't call is `labelScale` for consistency with other axes.\n    this.tickScale = new BandScale();\n    this.line = new AxisLine();\n    this.label = new GroupedCategoryAxisLabel();\n    this.labelColor = \"rgba(87, 87, 87, 1)\";\n    this.includeInvisibleDomains = true;\n    const { tickLineGroup, tickLabelGroup, gridLineGroup, tickScale } = this;\n    tickScale.paddingInner = 1;\n    tickScale.paddingOuter = 0;\n    this.gridLineSelection = Selection.select(gridLineGroup, Line);\n    this.axisLineSelection = Selection.select(tickLineGroup, Line);\n    this.separatorSelection = Selection.select(tickLineGroup, Line);\n    this.labelSelection = Selection.select(tickLabelGroup, TransformableText);\n    this.lineNode.visible = false;\n  }\n  updateRange() {\n    const { range: rr, visibleRange: vr, scale: scale2 } = this;\n    const span = (rr[1] - rr[0]) / (vr[1] - vr[0]);\n    const shift = span * vr[0];\n    const start2 = rr[0] - shift;\n    this.tickScale.range = scale2.range = [start2, start2 + span];\n    this.resizeTickTree();\n  }\n  resizeTickTree() {\n    const s = this.scale;\n    const range3 = s.domain.length ? [s.convert(s.domain[0]), s.convert(s.domain[s.domain.length - 1])] : s.range;\n    const layout = this.tickTreeLayout;\n    const lineHeight = this.lineHeight;\n    if (layout) {\n      layout.resize(\n        Math.abs(range3[1] - range3[0]),\n        layout.depth * lineHeight,\n        (Math.min(range3[0], range3[1]) || 0) + (s.bandwidth ?? 0) / 2,\n        -layout.depth * lineHeight,\n        range3[1] - range3[0] < 0\n      );\n    }\n  }\n  get lineHeight() {\n    return this.label.fontSize * 1.5;\n  }\n  /**\n   * The length of the grid. The grid is only visible in case of a non-zero value.\n   */\n  onGridVisibilityChange() {\n    this.gridLineSelection.clear();\n    this.labelSelection.clear();\n  }\n  calculateDomain() {\n    const { direction } = this;\n    let isNumericX = null;\n    const flatDomains = this.boundSeries.filter((s) => s.visible).flatMap((series) => {\n      if (direction === \"y\" /* Y */ || isNumericX) {\n        return series.getDomain(direction);\n      }\n      if (isNumericX === null) {\n        const domain2 = series.getDomain(direction);\n        isNumericX = isNumber(domain2[0]);\n        return domain2;\n      }\n      return [];\n    });\n    this.setDomain(extent(flatDomains) ?? unique(flatDomains));\n    const { domain } = this.dataDomain;\n    this.tickTreeLayout = treeLayout(ticksToTree(domain));\n    this.tickScale.domain = domain.concat(\"\");\n    this.resizeTickTree();\n  }\n  /**\n   * Creates/removes/updates the scene graph nodes that constitute the axis.\n   * Supposed to be called _manually_ after changing _any_ of the axis properties.\n   * This allows to bulk set axis properties before updating the nodes.\n   * The node changes made by this method are rendered on the next animation frame.\n   * We could schedule this method call automatically on the next animation frame\n   * when any of the axis properties change (the way we do when properties of scene graph's\n   * nodes change), but this will mean that we first wait for the next animation\n   * frame to make changes to the nodes of the axis, then wait for another animation\n   * frame to render those changes. It's nice to have everything update automatically,\n   * but this extra level of async indirection will not just introduce an unwanted delay,\n   * it will also make it harder to reason about the program.\n   */\n  update() {\n    if (!this.computedLayout) {\n      return;\n    }\n    this.updatePosition();\n    this.updateTitleCaption();\n    this.updateCategoryLabels();\n    this.updateSeparators();\n    this.updateAxisLines();\n    this.updateCategoryGridLines();\n    this.resetSelectionNodes();\n  }\n  updateTitleCaption() {\n    this.title.caption.node.visible = false;\n  }\n  updateCategoryLabels() {\n    if (!this.computedLayout)\n      return;\n    const { tickLabelLayout } = this.computedLayout;\n    const labelSelection = this.labelSelection.update(tickLabelLayout);\n    labelSelection.each((node, datum) => {\n      node.setProperties(datum);\n    });\n  }\n  updateSeparators() {\n    if (!this.computedLayout)\n      return;\n    const { separatorLayout } = this.computedLayout;\n    const { range: range3 } = this;\n    const epsilon2 = 1e-7;\n    const separatorSelection = this.separatorSelection.update(separatorLayout);\n    separatorSelection.each((line, datum) => {\n      line.x1 = datum.x1;\n      line.x2 = datum.x2;\n      line.y1 = datum.y;\n      line.y2 = datum.y;\n      line.visible = this.tick.enabled && datum.y >= range3[0] - epsilon2 && datum.y <= range3[1] + epsilon2;\n      line.stroke = this.tick.stroke;\n      line.strokeWidth = 1;\n    });\n  }\n  updateAxisLines() {\n    if (!this.computedLayout)\n      return;\n    const { axisLineLayout } = this.computedLayout;\n    const axisLineSelection = this.axisLineSelection.update(axisLineLayout);\n    axisLineSelection.each((line, datum) => {\n      line.setProperties(datum);\n      line.stroke = this.line.stroke;\n      line.strokeWidth = this.line.width;\n    });\n  }\n  updateCategoryGridLines() {\n    const { gridLength, gridLine, label, range: range3, tickScale } = this;\n    const ticks = tickScale.ticks();\n    const sideFlag = label.getSideFlag();\n    const gridSelection = this.gridLineSelection.update(gridLength ? ticks : []);\n    if (gridLength) {\n      const { width: width2, style } = gridLine;\n      const styleCount = style.length;\n      gridSelection.each((line, datum, index) => {\n        const y = Math.round(tickScale.convert(datum));\n        const { stroke, lineDash } = style[index % styleCount];\n        line.visible = gridLine.enabled && y >= range3[0] && y <= range3[1];\n        line.x1 = 0;\n        line.x2 = -sideFlag * gridLength;\n        line.y1 = y;\n        line.y2 = y;\n        line.stroke = stroke;\n        line.strokeWidth = width2;\n        line.lineDash = lineDash;\n      });\n    }\n  }\n  computeLayout() {\n    this.updateDirection();\n    this.calculateDomain();\n    this.updateRange();\n    const {\n      scale: scale2,\n      label,\n      label: { parallel },\n      moduleCtx: { callbackCache },\n      range: range3,\n      title,\n      title: { formatter = (p) => p.defaultValue } = {}\n    } = this;\n    const rangeStart = scale2.range[0];\n    const rangeEnd = scale2.range[1];\n    const rangeLength = Math.abs(rangeEnd - rangeStart);\n    const bandwidth = rangeLength / scale2.domain.length || 0;\n    const keepEvery = Math.ceil(label.fontSize / bandwidth);\n    const rotation = toRadians(this.rotation);\n    const isHorizontal = Math.abs(Math.cos(rotation)) < 1e-8;\n    const sideFlag = label.getSideFlag();\n    const lineHeight = this.lineHeight;\n    const tickTreeLayout = this.tickTreeLayout;\n    const labels = scale2.ticks();\n    const treeLabels = tickTreeLayout ? tickTreeLayout.nodes : [];\n    const isLabelTree = tickTreeLayout ? tickTreeLayout.depth > 1 : false;\n    const isCaptionEnabled = title?.enabled && labels.length > 0;\n    const { defaultRotation, configuredRotation, parallelFlipFlag } = calculateLabelRotation({\n      rotation: label.rotation,\n      parallel,\n      regularFlipRotation: normalizeAngle360(rotation - Math.PI / 2),\n      parallelFlipRotation: normalizeAngle360(rotation)\n    });\n    const tickLabelLayout = [];\n    const copyLabelProps = (node) => {\n      return {\n        fill: node.fill,\n        fontFamily: node.fontFamily,\n        fontSize: node.fontSize,\n        fontStyle: node.fontStyle,\n        fontWeight: node.fontWeight,\n        rotation: node.rotation,\n        rotationCenterX: node.rotationCenterX,\n        rotationCenterY: node.rotationCenterY,\n        text: node.text,\n        textAlign: node.textAlign,\n        textBaseline: node.textBaseline,\n        translationX: node.translationX,\n        translationY: node.translationY,\n        visible: node.visible,\n        x: node.x,\n        y: node.y\n      };\n    };\n    const labelBBoxes = /* @__PURE__ */ new Map();\n    let maxLeafLabelWidth = 0;\n    const tempText = new TransformableText();\n    const setLabelProps = (datum, index) => {\n      if (index === 0) {\n        if (isCaptionEnabled) {\n          const text = callbackCache.call(formatter, this.getTitleFormatterParams());\n          tempText.setProperties({\n            text,\n            fill: title.color,\n            fontFamily: title.fontFamily,\n            fontSize: title.fontSize,\n            fontStyle: title.fontStyle,\n            fontWeight: title.fontWeight,\n            textAlign: \"center\",\n            textBaseline: \"hanging\",\n            translationX: datum.screenY - title.fontSize * 0.25,\n            translationY: datum.screenX\n          });\n          return true;\n        }\n        return false;\n      }\n      tempText.setProperties({\n        fill: label.color,\n        fontFamily: label.fontFamily,\n        fontSize: label.fontSize,\n        fontStyle: label.fontStyle,\n        fontWeight: label.fontWeight,\n        textAlign: \"center\",\n        textBaseline: parallelFlipFlag === -1 ? \"bottom\" : \"hanging\",\n        translationX: datum.screenY - label.fontSize * 0.25,\n        translationY: datum.screenX\n      });\n      if (index % keepEvery !== 0) {\n        return false;\n      }\n      if (datum.screenX < range3[0] || datum.screenX > range3[1]) {\n        return false;\n      }\n      if (label.formatter) {\n        tempText.text = callbackCache.call(label.formatter, {\n          value: String(datum.label),\n          index\n        }) ?? String(datum.label);\n      } else {\n        tempText.text = String(datum.label);\n      }\n      return true;\n    };\n    treeLabels.forEach((datum, index) => {\n      const isVisible = setLabelProps(datum, index);\n      if (!isVisible)\n        return;\n      const bbox2 = tempText.getBBox();\n      if (!bbox2)\n        return;\n      labelBBoxes.set(index, bbox2);\n      const isLeaf = !datum.children.length;\n      if (isLeaf && bbox2.width > maxLeafLabelWidth) {\n        maxLeafLabelWidth = bbox2.width;\n      }\n    });\n    const labelX = sideFlag * label.padding;\n    const labelGrid = this.label.grid;\n    const separatorData = [];\n    treeLabels.forEach((datum, index) => {\n      const isLeaf = !datum.children.length;\n      let visible = setLabelProps(datum, index);\n      tempText.x = labelX;\n      tempText.y = index === 0 && isCaptionEnabled ? title.spacing ?? 0 : 0;\n      tempText.rotationCenterX = labelX;\n      if (isLeaf) {\n        tempText.rotation = configuredRotation;\n        tempText.textAlign = \"end\";\n        tempText.textBaseline = \"middle\";\n      } else {\n        const availableRange = datum.leafCount * bandwidth;\n        const bbox2 = labelBBoxes.get(index);\n        tempText.translationX -= maxLeafLabelWidth - lineHeight + this.label.padding;\n        if (bbox2 && bbox2.width > availableRange) {\n          visible = false;\n          labelBBoxes.delete(index);\n        } else {\n          tempText.rotation = isHorizontal ? defaultRotation : -Math.PI / 2;\n        }\n      }\n      if (datum.parent && isLabelTree) {\n        const y = isLeaf ? datum.screenX - bandwidth / 2 : datum.screenX - datum.leafCount * bandwidth / 2;\n        if (isLeaf) {\n          if (datum.number !== datum.children.length - 1 || labelGrid) {\n            separatorData.push({\n              y,\n              x1: 0,\n              x2: -maxLeafLabelWidth - this.label.padding * 2\n            });\n          }\n        } else {\n          const x = -maxLeafLabelWidth - this.label.padding * 2 + datum.screenY;\n          separatorData.push({\n            y,\n            x1: x + lineHeight,\n            x2: x\n          });\n        }\n      }\n      let props;\n      if (visible) {\n        const bbox2 = Transformable.toCanvas(tempText);\n        if (bbox2) {\n          labelBBoxes.set(index, bbox2);\n        }\n        props = { ...copyLabelProps(tempText), visible };\n      } else {\n        labelBBoxes.delete(index);\n        props = { visible };\n      }\n      tickLabelLayout.push(props);\n    });\n    let minX = 0;\n    separatorData.forEach((d) => minX = Math.min(minX, d.x2));\n    separatorData.push({\n      y: Math.max(rangeStart, rangeEnd),\n      x1: 0,\n      x2: minX\n    });\n    const separatorLayout = [];\n    const separatorBoxes = [];\n    const epsilon2 = 1e-7;\n    separatorData.forEach((datum) => {\n      if (datum.y >= range3[0] - epsilon2 && datum.y <= range3[1] + epsilon2) {\n        const { x1, x2, y } = datum;\n        const separatorBox = new BBox(Math.min(x1, x2), y, Math.abs(x1 - x2), 0);\n        separatorBoxes.push(separatorBox);\n        separatorLayout.push({ x1, x2, y });\n      }\n    });\n    const axisLineLayout = [];\n    const axisLineBoxes = [];\n    const lineCount = tickTreeLayout ? tickTreeLayout.depth + 1 : 1;\n    for (let i = 0; i < lineCount; i++) {\n      const visible = labels.length > 0 && (i === 0 || labelGrid && isLabelTree);\n      const x = i > 0 ? -maxLeafLabelWidth - this.label.padding * 2 - (i - 1) * lineHeight : 0;\n      const lineBox = new BBox(x, Math.min(...range3), 0, Math.abs(range3[1] - range3[0]));\n      axisLineBoxes.push(lineBox);\n      axisLineLayout.push({ x, y1: range3[0], y2: range3[1], visible });\n    }\n    const bbox = BBox.merge(iterate(labelBBoxes.values(), separatorBoxes, axisLineBoxes));\n    const transformedBBox = this.getTransformBox(bbox);\n    return {\n      bbox: transformedBBox,\n      tickLabelLayout,\n      separatorLayout,\n      axisLineLayout\n    };\n  }\n  calculateLayout() {\n    const { axisLineLayout, separatorLayout, tickLabelLayout, bbox } = this.computeLayout();\n    this.computedLayout = { axisLineLayout, separatorLayout, tickLabelLayout };\n    return { bbox, primaryTickCount: void 0 };\n  }\n};\nGroupedCategoryAxis.className = \"GroupedCategoryAxis\";\nGroupedCategoryAxis.type = \"grouped-category\";\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], GroupedCategoryAxis.prototype, \"labelColor\", 2);\n\n// packages/ag-charts-community/src/module/module.ts\nvar BaseModuleInstance = class {\n  constructor() {\n    this.destroyFns = [];\n  }\n  destroy() {\n    for (const destroyFn of this.destroyFns) {\n      destroyFn();\n    }\n  }\n};\nvar ModuleRegistry = class {\n  constructor() {\n    this.modules = [];\n    this.dependencies = /* @__PURE__ */ new Map();\n    this.dependents = /* @__PURE__ */ new Map();\n  }\n  register(...modules) {\n    for (const module of modules) {\n      this.registerDependencies(module);\n      const otherModule = this.modules.find(\n        (other) => module.type === other.type && module.optionsKey === other.optionsKey && module.identifier === other.identifier\n      );\n      if (otherModule) {\n        if (module.packageType === \"enterprise\" && otherModule.packageType === \"community\") {\n          const index = this.modules.indexOf(otherModule);\n          this.modules.splice(index, 1, module);\n        }\n      } else {\n        this.modules.push(module);\n      }\n    }\n  }\n  hasEnterpriseModules() {\n    return this.modules.some((m) => m.packageType === \"enterprise\");\n  }\n  *byType(...types) {\n    const { dependents } = this;\n    const yielded = /* @__PURE__ */ new Set();\n    let count = 0;\n    const maxCount = 3;\n    const modulesByType = this.modules.filter((module) => types.includes(module.type));\n    do {\n      for (const module of modulesByType) {\n        if (yielded.has(module.optionsKey) || dependents.has(module.optionsKey)) {\n          continue;\n        }\n        yield module;\n        yielded.add(module.optionsKey);\n        for (const [key, dependencies] of dependents.entries()) {\n          dependencies.delete(module.optionsKey);\n          if (dependencies.size === 0) {\n            dependents.delete(key);\n          }\n        }\n      }\n      count++;\n    } while (yielded.size < modulesByType.length && count < maxCount);\n    if (dependents.size > 0) {\n      throw new Error(`Could not resolve module dependencies: [${[...dependents.keys()]}]`);\n    }\n  }\n  registerDependencies(module) {\n    if (module.dependencies == null || module.dependencies.length === 0)\n      return;\n    for (const key of module.dependencies) {\n      const dependencies = this.dependencies.get(key) ?? /* @__PURE__ */ new Set();\n      dependencies.add(module.optionsKey);\n      this.dependencies.set(key, dependencies);\n    }\n    this.dependents.set(module.optionsKey, new Set(module.dependencies));\n  }\n};\nvar moduleRegistry = new ModuleRegistry();\n\n// packages/ag-charts-community/src/util/async.ts\nfunction sleep(sleepTimeoutMs) {\n  return new Promise((resolve) => {\n    setTimeout(() => resolve(void 0), sleepTimeoutMs);\n  });\n}\n\n// packages/ag-charts-community/src/util/mutex.ts\nvar Mutex = class {\n  constructor() {\n    this.available = true;\n    this.acquireQueue = [];\n  }\n  acquire(cb) {\n    return new Promise((resolve) => {\n      this.acquireQueue.push([cb, resolve]);\n      if (this.available) {\n        this.dispatchNext().catch((e) => Logger.errorOnce(e));\n      }\n    });\n  }\n  async acquireImmediately(cb) {\n    if (!this.available) {\n      return false;\n    }\n    await this.acquire(cb);\n    return true;\n  }\n  async waitForClearAcquireQueue() {\n    return this.acquire(async () => void 0);\n  }\n  async dispatchNext() {\n    this.available = false;\n    let [next, done] = this.acquireQueue.shift() ?? [];\n    while (next) {\n      try {\n        await next();\n        done?.();\n      } catch (error) {\n        Logger.error(\"mutex callback error\", error);\n        done?.();\n      }\n      [next, done] = this.acquireQueue.shift() ?? [];\n    }\n    this.available = true;\n  }\n};\n\n// packages/ag-charts-community/src/util/observable.ts\nvar Observable = class {\n  constructor() {\n    this.eventListeners = /* @__PURE__ */ new Map();\n  }\n  addEventListener(eventType, listener) {\n    if (typeof listener !== \"function\") {\n      throw new Error(\"AG Charts - listener must be a Function\");\n    }\n    const eventTypeListeners = this.eventListeners.get(eventType);\n    if (eventTypeListeners) {\n      eventTypeListeners.add(listener);\n    } else {\n      this.eventListeners.set(eventType, /* @__PURE__ */ new Set([listener]));\n    }\n  }\n  removeEventListener(type, listener) {\n    this.eventListeners.get(type)?.delete(listener);\n    if (this.eventListeners.size === 0) {\n      this.eventListeners.delete(type);\n    }\n  }\n  hasEventListener(type) {\n    return this.eventListeners.has(type);\n  }\n  clearEventListeners() {\n    this.eventListeners.clear();\n  }\n  fireEvent(event) {\n    this.eventListeners.get(event.type)?.forEach((listener) => listener(event));\n  }\n};\n\n// packages/ag-charts-community/src/util/padding.ts\nvar Padding = class extends BaseProperties {\n  constructor(top = 0, right = top, bottom = top, left = right) {\n    super();\n    this.top = top;\n    this.right = right;\n    this.bottom = bottom;\n    this.left = left;\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Padding.prototype, \"top\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Padding.prototype, \"right\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Padding.prototype, \"bottom\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Padding.prototype, \"left\", 2);\n\n// packages/ag-charts-community/src/util/render.ts\nfunction debouncedAnimationFrame(cb) {\n  return buildScheduler((innerCb, _delayMs) => getWindow().requestAnimationFrame(innerCb), cb);\n}\nfunction debouncedCallback(cb) {\n  return buildScheduler((innerCb, delayMs = 0) => setTimeout(innerCb, delayMs), cb);\n}\nfunction buildScheduler(scheduleFn, cb) {\n  let scheduleCount = 0;\n  let promiseRunning = false;\n  let awaitingPromise;\n  let awaitingDone;\n  const busy = () => {\n    return promiseRunning;\n  };\n  const done = () => {\n    promiseRunning = false;\n    awaitingDone?.();\n    awaitingDone = void 0;\n    awaitingPromise = void 0;\n    if (scheduleCount > 0) {\n      scheduleFn(scheduleCb);\n    }\n  };\n  const scheduleCb = () => {\n    const count = scheduleCount;\n    scheduleCount = 0;\n    promiseRunning = true;\n    const maybePromise = cb({ count });\n    if (!maybePromise) {\n      done();\n      return;\n    }\n    maybePromise.then(done, done);\n  };\n  return {\n    schedule(delayMs) {\n      if (scheduleCount === 0 && !busy()) {\n        scheduleFn(scheduleCb, delayMs);\n      }\n      scheduleCount++;\n    },\n    async await() {\n      if (!busy()) {\n        return;\n      }\n      if (awaitingPromise == null) {\n        awaitingPromise = new Promise((resolve) => {\n          awaitingDone = resolve;\n        });\n      }\n      while (busy()) {\n        await awaitingPromise;\n      }\n    }\n  };\n}\n\n// packages/ag-charts-community/src/util/eventEmitter.ts\nvar EventEmitter = class {\n  constructor() {\n    this.events = /* @__PURE__ */ new Map();\n  }\n  /**\n   * Registers an event listener.\n   * @param eventName The event name to listen for.\n   * @param listener The callback to be invoked on the event.\n   * @returns A function to unregister the listener.\n   */\n  on(eventName, listener) {\n    if (!this.events.has(eventName)) {\n      this.events.set(eventName, /* @__PURE__ */ new Set());\n    }\n    this.events.get(eventName)?.add(listener);\n    return () => this.off(eventName, listener);\n  }\n  /**\n   * Unregisters an event listener.\n   * @param eventName The event name to stop listening for.\n   * @param listener The callback to be removed.\n   */\n  off(eventName, listener) {\n    const eventListeners = this.events.get(eventName);\n    if (eventListeners) {\n      eventListeners.delete(listener);\n      if (eventListeners.size === 0) {\n        this.events.delete(eventName);\n      }\n    }\n  }\n  /**\n   * Emits an event to all registered listeners.\n   * @param eventName The name of the event to emit.\n   * @param event The event payload.\n   */\n  emit(eventName, event) {\n    this.events.get(eventName)?.forEach((callback2) => callback2(event));\n  }\n  /**\n   * Clears all listeners for a specific event or all events if no event name is provided.\n   * @param eventName (Optional) The name of the event to clear listeners for. If not provided, all listeners for all events are cleared.\n   */\n  clear(eventName) {\n    if (eventName) {\n      this.events.delete(eventName);\n    } else {\n      this.events.clear();\n    }\n  }\n};\n\n// packages/ag-charts-community/src/chart/layout/layoutManager.ts\nvar LayoutElement = /* @__PURE__ */ ((LayoutElement2) => {\n  LayoutElement2[LayoutElement2[\"Caption\"] = 0] = \"Caption\";\n  LayoutElement2[LayoutElement2[\"Legend\"] = 1] = \"Legend\";\n  LayoutElement2[LayoutElement2[\"Toolbar\"] = 2] = \"Toolbar\";\n  LayoutElement2[LayoutElement2[\"Navigator\"] = 3] = \"Navigator\";\n  LayoutElement2[LayoutElement2[\"Overlay\"] = 4] = \"Overlay\";\n  return LayoutElement2;\n})(LayoutElement || {});\nvar LayoutManager = class {\n  constructor() {\n    this.events = new EventEmitter();\n    this.elements = /* @__PURE__ */ new Map();\n  }\n  addListener(eventName, listener) {\n    return this.events.on(eventName, listener);\n  }\n  registerElement(element2, listener) {\n    if (this.elements.has(element2)) {\n      this.elements.get(element2).add(listener);\n    } else {\n      this.elements.set(element2, /* @__PURE__ */ new Set([listener]));\n    }\n    return () => this.elements.get(element2)?.delete(listener);\n  }\n  createContext(width2, height2) {\n    const context = new LayoutContext(width2, height2);\n    for (const element2 of Object.values(LayoutElement)) {\n      if (typeof element2 !== \"number\")\n        continue;\n      this.elements.get(element2)?.forEach((listener) => listener(context));\n    }\n    return context;\n  }\n  emitLayoutComplete(context, options) {\n    const eventType = \"layout:complete\";\n    const { width: width2, height: height2 } = context;\n    this.events.emit(eventType, {\n      type: eventType,\n      axes: options.axes ?? [],\n      chart: { width: width2, height: height2 },\n      clipSeries: options.clipSeries ?? false,\n      series: options.series\n    });\n  }\n};\nvar LayoutContext = class {\n  constructor(width2, height2) {\n    this.width = width2;\n    this.height = height2;\n    this.layoutBox = new BBox(0, 0, width2, height2);\n  }\n};\n\n// packages/ag-charts-community/src/chart/chartCaptions.ts\nvar ChartCaptions = class {\n  constructor() {\n    this.title = new Caption();\n    this.subtitle = new Caption();\n    this.footnote = new Caption();\n  }\n  positionCaptions(ctx) {\n    const { title, subtitle, footnote } = this;\n    const maxHeight = ctx.layoutBox.height / 10;\n    if (title.enabled) {\n      const { spacing = subtitle.enabled ? Caption.SMALL_PADDING : Caption.LARGE_PADDING } = title;\n      this.positionCaption(\"top\", title, ctx.layoutBox, maxHeight);\n      this.shrinkLayoutByCaption(\"top\", title, ctx.layoutBox, spacing);\n    }\n    if (subtitle.enabled) {\n      this.positionCaption(\"top\", subtitle, ctx.layoutBox, maxHeight);\n      this.shrinkLayoutByCaption(\"top\", subtitle, ctx.layoutBox, subtitle.spacing);\n    }\n    if (footnote.enabled) {\n      this.positionCaption(\"bottom\", footnote, ctx.layoutBox, maxHeight);\n      this.shrinkLayoutByCaption(\"bottom\", footnote, ctx.layoutBox, footnote.spacing);\n    }\n  }\n  positionAbsoluteCaptions(ctx) {\n    const { title, subtitle, footnote } = this;\n    const { rect } = ctx.series;\n    for (const caption of [title, subtitle, footnote]) {\n      if (caption.layoutStyle !== \"overlay\")\n        continue;\n      if (caption.textAlign === \"left\") {\n        caption.node.x = rect.x + caption.padding;\n      } else if (caption.textAlign === \"right\") {\n        const bbox = caption.node.getBBox();\n        caption.node.x = rect.x + rect.width - bbox.width - caption.padding;\n      }\n    }\n  }\n  computeX(align, layoutBox) {\n    if (align === \"left\") {\n      return layoutBox.x;\n    } else if (align === \"right\") {\n      return layoutBox.x + layoutBox.width;\n    }\n    return layoutBox.x + layoutBox.width / 2;\n  }\n  positionCaption(vAlign, caption, layoutBox, maxHeight) {\n    const containerHeight = Math.max(TextUtils.getLineHeight(caption.fontSize), maxHeight);\n    caption.node.x = this.computeX(caption.textAlign, layoutBox) + caption.padding;\n    caption.node.y = layoutBox.y + (vAlign === \"top\" ? 0 : layoutBox.height) + caption.padding;\n    caption.node.textBaseline = vAlign;\n    caption.computeTextWrap(layoutBox.width, containerHeight);\n  }\n  shrinkLayoutByCaption(vAlign, caption, layoutBox, spacing = 0) {\n    if (caption.layoutStyle === \"block\") {\n      const bbox = caption.node.getBBox();\n      layoutBox.shrink(\n        vAlign === \"top\" ? Math.ceil(bbox.y - layoutBox.y + bbox.height + spacing) : Math.ceil(layoutBox.y + layoutBox.height - bbox.y + spacing),\n        vAlign\n      );\n    }\n  }\n};\n__decorateClass([\n  Validate(OBJECT)\n], ChartCaptions.prototype, \"title\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], ChartCaptions.prototype, \"subtitle\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], ChartCaptions.prototype, \"footnote\", 2);\n\n// packages/ag-charts-community/src/util/listeners.ts\nvar Listeners = class {\n  constructor() {\n    this.registeredListeners = /* @__PURE__ */ new Map();\n  }\n  addListener(eventType, handler) {\n    const record = { symbol: Symbol(eventType), handler };\n    if (this.registeredListeners.has(eventType)) {\n      this.registeredListeners.get(eventType).push(record);\n    } else {\n      this.registeredListeners.set(eventType, [record]);\n    }\n    return () => this.removeListener(record.symbol);\n  }\n  removeListener(eventSymbol) {\n    for (const [type, listeners] of this.registeredListeners.entries()) {\n      const matchIndex = listeners.findIndex((listener) => listener.symbol === eventSymbol);\n      if (matchIndex >= 0) {\n        listeners.splice(matchIndex, 1);\n        if (listeners.length === 0) {\n          this.registeredListeners.delete(type);\n        }\n        break;\n      }\n    }\n  }\n  dispatch(eventType, ...params) {\n    for (const listener of this.getListenersByType(eventType)) {\n      try {\n        listener.handler(...params);\n      } catch (e) {\n        Logger.errorOnce(e);\n      }\n    }\n  }\n  dispatchWrapHandlers(eventType, wrapFn, ...params) {\n    for (const listener of this.getListenersByType(eventType)) {\n      try {\n        wrapFn(listener.handler, ...params);\n      } catch (e) {\n        Logger.errorOnce(e);\n      }\n    }\n  }\n  getListenersByType(eventType) {\n    return this.registeredListeners.get(eventType) ?? [];\n  }\n  destroy() {\n    this.registeredListeners.clear();\n  }\n};\n\n// packages/ag-charts-community/src/chart/baseManager.ts\nvar BaseManager = class {\n  constructor() {\n    this.listeners = new Listeners();\n    this.destroyFns = [];\n  }\n  addListener(type, handler) {\n    return this.listeners.addListener(type, handler);\n  }\n  destroy() {\n    this.listeners.destroy();\n    this.destroyFns.forEach((fn) => fn());\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/interactionStateListener.ts\nvar InteractionState = /* @__PURE__ */ ((InteractionState2) => {\n  InteractionState2[InteractionState2[\"Default\"] = 32] = \"Default\";\n  InteractionState2[InteractionState2[\"ZoomDrag\"] = 16] = \"ZoomDrag\";\n  InteractionState2[InteractionState2[\"Annotations\"] = 8] = \"Annotations\";\n  InteractionState2[InteractionState2[\"ContextMenu\"] = 4] = \"ContextMenu\";\n  InteractionState2[InteractionState2[\"Animation\"] = 2] = \"Animation\";\n  InteractionState2[InteractionState2[\"AnnotationsSelected\"] = 1] = \"AnnotationsSelected\";\n  InteractionState2[InteractionState2[\"All\"] = 63] = \"All\";\n  return InteractionState2;\n})(InteractionState || {});\nvar InteractionStateListener = class extends BaseManager {\n  // Wrapper to only broadcast events when the InteractionManager is a given state.\n  addListener(type, handler, triggeringStates = 32 /* Default */) {\n    return super.addListener(type, (e) => {\n      const currentState = this.getState();\n      if (currentState & triggeringStates) {\n        handler(e);\n      }\n    });\n  }\n};\n\n// packages/ag-charts-community/src/util/destroy.ts\nvar DestroyFns = class {\n  constructor() {\n    this.destroyFns = [];\n  }\n  destroy() {\n    this.destroyFns.forEach((fn) => fn());\n    this.destroyFns.length = 0;\n  }\n  setFns(destroyFns) {\n    this.destroy();\n    this.destroyFns = destroyFns;\n  }\n};\n\n// packages/ag-charts-community/src/version.ts\nvar VERSION = \"10.3.3\";\n\n// packages/ag-charts-community/src/api/state/historyManager.ts\nvar NOT_FOUND = Symbol(\"previous-memento-not-found\");\nvar HistoryManager = class {\n  constructor(keyNavManager) {\n    this.history = [];\n    this.historyIndex = -1;\n    this.originators = /* @__PURE__ */ new Map();\n    this.clearState = /* @__PURE__ */ new Map();\n    this.maxHistoryLength = 100;\n    this.debug = Debug.create(true, \"history\");\n    this.destroyFns = new DestroyFns();\n    this.destroyFns.setFns([\n      keyNavManager.addListener(\"undo\", this.undo.bind(this), 63 /* All */),\n      keyNavManager.addListener(\"redo\", this.redo.bind(this), 63 /* All */)\n    ]);\n  }\n  destroy() {\n    this.destroyFns.destroy();\n  }\n  addMementoOriginator(originator) {\n    this.originators.set(originator.mementoOriginatorKey, originator);\n    this.clearState.set(originator.mementoOriginatorKey, originator.createMemento());\n    this.debugEvent(\"History add originator:\", originator.mementoOriginatorKey);\n  }\n  clear() {\n    this.debug(`History clear:`, Object.keys(this.originators));\n    this.history = [];\n    this.historyIndex = -1;\n    for (const [mementoOriginatorKey, originator] of this.originators.entries()) {\n      this.clearState.set(mementoOriginatorKey, originator.createMemento());\n    }\n  }\n  record(label, ...originators) {\n    if (this.historyIndex < this.history.length - 1) {\n      this.history = this.history.slice(0, this.historyIndex + 1);\n    }\n    if (this.history.length > this.maxHistoryLength) {\n      this.history = this.history.slice(-this.maxHistoryLength);\n    }\n    const mementos = /* @__PURE__ */ new Map();\n    for (const originator of originators) {\n      if (!this.originators.has(originator.mementoOriginatorKey)) {\n        throw new Error(\n          `Originator [${originator.mementoOriginatorKey}] has not been added to the HistoryManager.`\n        );\n      }\n      mementos.set(originator.mementoOriginatorKey, originator.createMemento());\n    }\n    this.history.push({ label, mementos });\n    this.historyIndex = this.history.length - 1;\n    this.debugEvent(`History record: [${label}]`);\n  }\n  undo() {\n    const undoAction = this.history[this.historyIndex];\n    if (!undoAction)\n      return;\n    for (const mementoOriginatorKey of undoAction.mementos.keys()) {\n      const previousMemento = this.findPreviousMemento(mementoOriginatorKey);\n      if (previousMemento === NOT_FOUND) {\n        throw new Error(`Could not find previous memento for [${mementoOriginatorKey}].`);\n      }\n      this.restoreMemento(mementoOriginatorKey, previousMemento);\n    }\n    this.historyIndex -= 1;\n    this.debugEvent(`History undo: [${undoAction.label}]`);\n  }\n  redo() {\n    const redoAction = this.history[this.historyIndex + 1];\n    if (!redoAction)\n      return;\n    for (const [mementoOriginatorKey, memento] of redoAction.mementos.entries()) {\n      this.restoreMemento(mementoOriginatorKey, memento);\n    }\n    this.historyIndex += 1;\n    this.debugEvent(`History redo: [${redoAction.label}]`);\n  }\n  findPreviousMemento(mementoOriginatorKey) {\n    for (let i = this.historyIndex - 1; i >= 0; i--) {\n      if (this.history[i].mementos.has(mementoOriginatorKey)) {\n        return this.history[i].mementos.get(mementoOriginatorKey);\n      }\n    }\n    if (this.clearState.has(mementoOriginatorKey)) {\n      return this.clearState.get(mementoOriginatorKey);\n    }\n    return NOT_FOUND;\n  }\n  restoreMemento(mementoOriginatorKey, memento) {\n    this.originators.get(mementoOriginatorKey)?.restoreMemento(VERSION, VERSION, memento);\n  }\n  debugEvent(...logContent) {\n    this.debug(\n      ...logContent,\n      this.history.map((action, index) => index === this.historyIndex ? `** ${action.label} **` : action.label)\n    );\n  }\n};\n\n// packages/ag-charts-community/src/api/state/memento.ts\nvar MementoCaretaker = class {\n  constructor(version) {\n    this.version = version.split(\"-\")[0];\n  }\n  save(...originators) {\n    const packet = { version: this.version };\n    for (const originator of Object.values(originators)) {\n      packet[originator.mementoOriginatorKey] = this.encode(originator, originator.createMemento());\n    }\n    return packet;\n  }\n  restore(blob, ...originators) {\n    if (typeof blob !== \"object\") {\n      Logger.warnOnce(`Could not restore data of type [${typeof blob}], expecting an object, ignoring.`);\n      return;\n    }\n    if (blob == null) {\n      Logger.warnOnce(`Could not restore data of type [null], expecting an object, ignoring.`);\n      return;\n    }\n    if (!(\"version\" in blob) || typeof blob.version !== \"string\") {\n      Logger.warnOnce(`Could not restore data, missing [version] string in object, ignoring.`);\n      return;\n    }\n    for (const originator of originators) {\n      if (!(originator.mementoOriginatorKey in blob)) {\n        continue;\n      }\n      const memento = this.decode(originator, blob[originator.mementoOriginatorKey]);\n      if (!originator.guardMemento(memento)) {\n        Logger.warnOnce(\n          `Could not restore [${originator.mementoOriginatorKey}] data, value was invalid, ignoring.`,\n          memento\n        );\n        return;\n      }\n      originator.restoreMemento(this.version, blob.version, memento);\n    }\n  }\n  /**\n   * Encode a memento as a serializable object, encoding any non-serializble types.\n   */\n  encode(originator, memento) {\n    try {\n      return JSON.parse(JSON.stringify(memento, this.encodeTypes));\n    } catch (error) {\n      throw new Error(`Failed to encode [${originator.mementoOriginatorKey}] value [${error}].`, {\n        cause: error\n      });\n    }\n  }\n  /**\n   * Decode an encoded memento, decoding any non-serializable types.\n   */\n  decode(originator, encoded) {\n    try {\n      return JSON.parse(JSON.stringify(encoded), this.decodeTypes);\n    } catch (error) {\n      throw new Error(`Failed to decode [${originator.mementoOriginatorKey}] value [${error}].`, {\n        cause: error\n      });\n    }\n  }\n  encodeTypes(key, value) {\n    if (isDate(this[key])) {\n      return { __type: \"date\", value: String(this[key]) };\n    }\n    return value;\n  }\n  decodeTypes(key, value) {\n    if (isObject(this[key]) && \"__type\" in this[key] && this[key].__type === \"date\") {\n      return new Date(this[key].value);\n    }\n    return value;\n  }\n};\n\n// packages/ag-charts-community/src/api/state/stateManager.ts\nvar StateManager = class {\n  constructor() {\n    this.caretaker = new MementoCaretaker(VERSION);\n    this.state = /* @__PURE__ */ new Map();\n  }\n  setState(originator, value) {\n    if (jsonDiff(this.state.get(originator.mementoOriginatorKey), value) == null) {\n      return;\n    }\n    this.state.set(originator.mementoOriginatorKey, value);\n    this.restoreState(originator);\n  }\n  restoreState(originator) {\n    const { caretaker, state } = this;\n    if (!state.has(originator.mementoOriginatorKey))\n      return;\n    const value = state.get(originator.mementoOriginatorKey);\n    caretaker.restore({ version: caretaker.version, [originator.mementoOriginatorKey]: value }, originator);\n  }\n};\n\n// packages/ag-charts-community/src/styles.css\nvar styles_default = '.ag-charts-wrapper,.ag-charts-wrapper:focus,.ag-charts-wrapper:after,.ag-charts-wrapper:before,.ag-charts-wrapper *,.ag-charts-wrapper *:focus,.ag-charts-wrapper *:after,.ag-charts-wrapper *:before{box-sizing:border-box;outline:none}.ag-charts-wrapper{position:relative;user-select:none}.ag-charts-canvas-center{width:100%;height:100%;position:absolute;touch-action:auto;display:flex;align-items:var(--ag-charts-align);justify-content:var(--ag-charts-justify)}.ag-charts-canvas-container,.ag-charts-canvas{position:relative;user-select:none}.ag-charts-canvas-container>*,.ag-charts-canvas>*{display:block;pointer-events:none}.ag-charts-series-area{opacity:0;pointer-events:auto;position:absolute}.ag-charts-series-area:focus-visible{opacity:1}.ag-charts-canvas-proxy,.ag-charts-canvas-overlay{inset:0;pointer-events:none;position:absolute;user-select:none}.ag-charts-canvas-overlay>*{position:absolute;pointer-events:auto}.ag-charts-theme-default,.ag-charts-theme-default-dark{--ag-charts-active-color: var(--ag-active-color, #2196f3);--ag-charts-background-color: var(--ag-background-color, #fff);--ag-charts-foreground-color: var(--ag-foreground-color, #181d1f);--ag-charts-border-color: var(--ag-border-color, #dddddd);--ag-charts-hover-color: color-mix(in srgb, var(--ag-charts-background-color), var(--ag-charts-active-color) 12%);--ag-charts-font-family: \"Verdana\", sans-serif;--ag-charts-font-size: var(--ag-font-size, 14px);--ag-charts-size: var(--ag-grid-size, 8px);--ag-charts-border: var(--ag-charts-border-color) var(--ag-borders, solid 1px);--ag-charts-border-critical: var(--ag-borders-critical, solid 1px);--ag-charts-layer-ui-overlay: 5;--ag-charts-layer-tooltip: 4;--ag-charts-layer-toolbar: 3;--ag-charts-layer-crosshair: 2;--ag-charts-layer-annotations: 1;--ag-charts-align: center;--ag-charts-justify: center;--ag-charts-axis-label-background-color: #474747;--ag-charts-axis-label-color: #ffffff;--ag-charts-toolbar-foreground-color: var(--ag-header-foreground-color, var(--ag-charts-foreground-color));--ag-charts-toolbar-background-color: var( --ag-header-background-color, color-mix(in srgb, var(--ag-charts-background-color), var(--ag-charts-foreground-color) 2%) );--ag-charts-toolbar-size: 34px;--ag-charts-toolbar-size-small: 24px;--ag-charts-toolbar-border: var(--ag-charts-border-critical, solid 1px) var(--ag-charts-border-color);--ag-charts-toolbar-hover-color: color-mix( in srgb, var(--ag-charts-background-color), var(--ag-charts-active-color) 12% );--ag-charts-toolbar-focus-color: var(--ag-charts-active-color);--ag-charts-toolbar-active-background-color: var(--ag-charts-toolbar-hover-color);--ag-charts-toolbar-active-color: var(--ag-charts-active-color);--ag-charts-toolbar-disabled-foreground-color: var( --ag-disabled-foreground-color, color-mix(in srgb, transparent, var(--ag-charts-toolbar-foreground-color) 50%) );--ag-charts-toolbar-disabled-background-color: color-mix( in srgb, var(--ag-charts-toolbar-background-color), var(--ag-charts-toolbar-foreground-color) 6% );--ag-charts-toolbar-gap: var(--ag-charts-size);--ag-charts-toolbar-font-size: 13px;--ag-charts-toolbar-font-size-small: 12px;--ag-charts-toolbar-button-padding: 6px;--ag-charts-toolbar-button-padding-small: 1px;--ag-charts-popover-background-color: var(--ag-charts-toolbar-background-color);--ag-charts-popover-foreground-color: var(--ag-charts-toolbar-foreground-color);--ag-charts-popover-border: var(--ag-charts-toolbar-border);--ag-charts-popover-border-radius: var(--ag-border-radius, 4px);--ag-charts-popover-active-color: var(--ag-charts-toolbar-active-color);--ag-charts-popover-hover-color: var(--ag-charts-toolbar-hover-color);--ag-charts-popover-active-background-color: var(--ag-charts-toolbar-active-background-color);--ag-charts-popover-font-size: 14px;--ag-charts-popover-font-size-small: var(--ag-charts-toolbar-font-size-small);--ag-charts-dialog-input-group-label-color: color-mix(in srgb, transparent, var(--ag-charts-foreground-color) 55%);--ag-charts-dialog-tab-color--inactive: color-mix(in srgb, transparent, var(--ag-charts-foreground-color) 55%);--ag-charts-button-radius: var(--ag-border-radius, 4px);--ag-charts-focus-border-color: var(--ag-input-focus-border-color, var(--ag-charts-active-color));--ag-charts-focus-border: solid 1px var(--ag-charts-focus-border-color);--ag-charts-focus-border-shadow: var( --ag-input-focus-box-shadow, 0 0 0 3px color-mix(in srgb, transparent, var(--ag-input-focus-border-color, var(--ag-charts-active-color)) 20%) );--ag-charts-focus-box-shadow: var(--box-shadow), 0 0 0 2px #fff8, var(--ag-charts-focus-border-shadow);--ag-charts-icon-font-family: \"agChartsDefault\";--ag-charts-icon-font-weight: normal;--ag-charts-icon-font-color: color-mix(in srgb, transparent, var(--ag-charts-foreground-color), 90%);--ag-charts-icon-size: 20px;--ag-charts-input-background-color: var(--ag-charts-background-color);--ag-charts-input-background-color--hover: var(--ag-charts-hover-color);--ag-charts-input-background-color--active: var(--ag-charts-hover-color);--ag-charts-input-border-color: var(--ag-charts-border-color);--ag-charts-input-border-color--active: var(--ag-charts-active-color);--ag-charts-input-border-radius: var(--ag-border-radius, 4px);--ag-charts-input-color--active: var(--ag-charts-active-color);--ag-charts-input-focus-outline: var(--ag-charts-focus-border);--ag-charts-input-focus-box-shadow: var(--ag-charts-focus-border-shadow);--ag-charts-input-font-family: var(--ag-charts-font-family);--ag-charts-input-font-size: var(--ag-charts-font-size);--ag-charts-input-padding: 8px;--ag-charts-input-padding-large: 10px;--ag-charts-input-placeholder-color: #888888;--ag-charts-input-spacing: 8px;--ag-charts-input-transition-duration: .25s;--ag-charts-input-transition-duration--fast: .1s;--ag-charts-input-transition-timing-function: ease-out;--ag-charts-input-checkbox-background-color: #babbbc;--ag-charts-input-checkbox-background-color--checked: var(--ag-charts-active-color)}.ag-charts-theme-default-dark{--ag-charts-background-color: var(--ag-background-color, color-mix(in srgb, #fff, #182230 97%));--ag-charts-foreground-color: var(--ag-foreground-color, #fff);--ag-charts-border-color: var(--ag-border-color, rgba(255, 255, 255, .16));--ag-charts-hover-color: color-mix(in srgb, var(--ag-charts-background-color), var(--ag-charts-active-color) 18%);--ag-charts-axis-label-background-color: #9caebb;--ag-charts-axis-label-color: #000000;--ag-charts-toolbar-background-color: var(--ag-header-background-color, color-mix(in srgb, #fff, #182230 93%));--ag-charts-toolbar-hover-color: color-mix( in srgb, var(--ag-charts-background-color), var(--ag-charts-active-color) 18% );--ag-charts-dialog-input-group-label-text-color: #ffffff;--ag-charts-focus-border-shadow: var( --ag-input-focus-box-shadow, 0 0 0 3px color-mix(in srgb, transparent, var(--ag-input-focus-border-color, var(--ag-charts-active-color)) 20%) );--ag-charts-input-placeholder-color: #aaaaaa}.ag-charts-icon{display:block;width:var(--ag-charts-icon-size);height:var(--ag-charts-icon-size);speak:none;speak:never;mask:var(--icon) center / contain no-repeat;background-color:currentColor;transition:background-color .25s ease-in-out}.ag-charts-icon-align-center{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJNNyAxMGg2djFIN3pNNCA3aDEydjFINHptMSA2aDEwdjFINXoiLz48L3N2Zz4=)}.ag-charts-icon-align-left{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJNNCAxMGg2djFINHptMC0zaDEydjFINHptMCA2aDEwdjFINHoiLz48L3N2Zz4=)}.ag-charts-icon-align-right{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMTAgMTBoNnYxaC02ek00IDdoMTJ2MUg0em0yIDZoMTB2MUg2eiIvPjwvc3ZnPg==)}.ag-charts-icon-arrow-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE1LjI5MyA0LjVIMTIuNXYtMUgxN3Y0aC0xVjUuMjA3bC05LjY0NiA5LjY0Ny0uNzA4LS43MDh6IiBmaWxsPSIjMDAwIi8+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik03IDE2YTIuNSAyLjUgMCAxIDEtNSAwIDIuNSAyLjUgMCAwIDEgNSAwbS0yLjUgMS41YTEuNSAxLjUgMCAxIDAgMC0zIDEuNSAxLjUgMCAwIDAgMCAzIiBmaWxsPSIjMDAwIi8+PC9zdmc+)}.ag-charts-icon-arrow-down-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik02IDhMMS41IDhMMTAgMThMMTguNSA4TDE0IDhMMTQgM0w2IDNMNiA4Wk03IDRMNyA5SDMuNjYyNDRMMTAgMTYuNDU2TDE2LjMzNzYgOUwxMyA5TDEzIDRMNyA0WiIgZmlsbD0iYmxhY2siLz4KPC9zdmc+Cg==)}.ag-charts-icon-arrow-up-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNCAxMkgxOC41TDEwIDJMMS41IDEySDZMNi4wMDAwMiAxN0gxNFYxMlpNMTMgMTZWMTFIMTYuMzM3NkwxMCAzLjU0NDA1TDMuNjYyNDQgMTFIN0w3LjAwMDAyIDE2SDEzWiIgZmlsbD0iYmxhY2siLz4KPC9zdmc+Cg==)}.ag-charts-icon-callout-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMyA0LjVBMS41IDEuNSAwIDAgMSA0LjUgM2gxMUExLjUgMS41IDAgMCAxIDE3IDQuNXY4YTEuNSAxLjUgMCAwIDEtMS41IDEuNWgtNC41MTRhMjYgMjYgMCAwIDAtMi4wMTcgMS41NGwtLjMxNC4yNmMtLjU1LjQ1Ny0xLjExNS45MjYtMS43NiAxLjQtLjY2OS40OTEtMS41NjItLjAxMi0xLjU2Mi0uOFYxNEg0LjVBMS41IDEuNSAwIDAgMSAzIDEyLjV6TTQuNSA0YS41LjUgMCAwIDAtLjUuNXY4YS41LjUgMCAwIDAgLjUuNWgxLjgzM3YzLjM3MmEzNiAzNiAwIDAgMCAxLjY3OC0xLjMzOGwuMzItLjI2NWEyNiAyNiAwIDAgMSAyLjIyNS0xLjY4NWwuMTI2LS4wODRIMTUuNWEuNS41IDAgMCAwIC41LS41di04YS41LjUgMCAwIDAtLjUtLjV6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-candlestick-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNyAxdjNoMnYxMkg3djNINnYtM0g0VjRoMlYxek01IDVoM3YxMEg1ek0xMSAxNFY2aDJWMy4yNWgxVjZoMnY4aC0ydjIuNzVoLTFWMTR6bTEtN2gzdjZoLTN6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-close{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJtNSA1IDEwIDEwTTUgMTUgMTUgNSIgc3Ryb2tlPSIjMDAwIi8+PC9zdmc+)}.ag-charts-icon-comment-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNy41MTMgMy45OTVhNi41IDYuNSAwIDAgMSA2LjA5OCAxMS40MWMtLjU4OC4zOTMtMS4yMTcuNTM2LTEuODI5LjU4NWExMyAxMyAwIDAgMS0xLjI3LjAxN0EyNyAyNyAwIDAgMCAxMCAxNkg0LjVhLjUuNSAwIDAgMS0uNS0uNVYxMHEwLS4yNDctLjAwNy0uNTEzYy0uMDA4LS40MTYtLjAxNi0uODU3LjAxNy0xLjI2OS4wNS0uNjEyLjE5Mi0xLjI0LjU4NS0xLjgzYTYuNSA2LjUgMCAwIDEgMi45MTgtMi4zOTNtMy41Ni42MWE1LjUgNS41IDAgMCAwLTUuNjQ2IDIuMzRjLS4yNjYuMzk3LS4zNzkuODQyLS40MiAxLjM1NC0uMDMuMzYtLjAyMi43MTgtLjAxNSAxLjEwOFE1IDkuNjg5IDUgMTB2NWg1cS4zMTEuMDAxLjU5My4wMDhjLjM5LjAwNy43NDcuMDE1IDEuMTA4LS4wMTUuNTEyLS4wNDEuOTU3LS4xNTQgMS4zNTUtLjQyYTUuNSA1LjUgMCAwIDAtMS45ODMtOS45NjciIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-crosshair-add-line{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZD0iTTEwIDUuNWEuNS41IDAgMCAxIC41LjV2My41aDMuODc1YS41LjUgMCAwIDEgMCAxSDEwLjV2NC4yNWEuNS41IDAgMSAxLTEgMFYxMC41SDUuNjI1YS41LjUgMCAxIDEgMC0xSDkuNVY2YS41LjUgMCAwIDEgLjUtLjUiLz48L3N2Zz4=)}.ag-charts-icon-date-range-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNMiAyaDF2MTZIMnptMTUgMGgxdjE2aC0xeiIgZmlsbD0iIzE4MUQxRiIvPjxwYXRoIGQ9Ik0xMy4xNTcgMTFINXYtMWg3Ljc5M0wxMSA4LjIwN2wuNzA3LS43MDcgMy4xODIgMy4xODItMy4xODIgMy4xODItLjcwNy0uNzA3eiIgZmlsbD0iIzAwMCIvPjwvc3ZnPg==)}.ag-charts-icon-date-price-range-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNMyAySDJ2MTZoMXptMy41MDcgNC44OUw4LjUgNC44OTVWMTBINXYxaDMuNXY3aDF2LTdoNS4wODhsLTEuOTU3IDEuOTU3LjcwNy43MDcgMy4xODItMy4xODJMMTMuMzM4IDcuM2wtLjcwNy43MDdMMTQuNjI0IDEwSDkuNVY0LjkzMmwxLjk1NyAxLjk1Ny43MDctLjcwN0w4Ljk4MiAzIDUuOCA2LjE4MnoiIGZpbGw9IiMxODFEMUYiLz48L3N2Zz4=)}.ag-charts-icon-delete{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZD0iTTguNDk2IDguOTk2QS41LjUgMCAwIDEgOSA5LjQ5MnY0YS41LjUgMCAxIDEtMSAuMDA4di00YS41LjUgMCAwIDEgLjQ5Ni0uNTA0TTEyIDkuNWEuNS41IDAgMCAwLTEgMHY0YS41LjUgMCAwIDAgMSAweiIvPjxwYXRoIGZpbGw9IiMxMzE3MjIiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTYgNVYzLjVBMi41IDIuNSAwIDAgMSA4LjUgMWgzQTIuNSAyLjUgMCAwIDEgMTQgMy41VjVoMi44MzNhLjUuNSAwIDAgMSAwIDFIMTV2MTAuMjVjMCAuNDE1LS4wNjYuODYzLS4zIDEuMjIxLS4yNTcuMzk0LS42NzIuNjEyLTEuMi42MTJoLTdjLS41MjggMC0uOTQzLS4yMTgtMS4yLS42MTItLjIzNC0uMzU4LS4zLS44MDYtLjMtMS4yMjFWNkgzLjMzM2EuNS41IDAgMCAxIDAtMXptMS0xLjVBMS41IDEuNSAwIDAgMSA4LjUgMmgzQTEuNSAxLjUgMCAwIDEgMTMgMy41VjVIN3pNNiAxNi4yNVY2aDh2MTAuMjVjMCAuMzM1LS4wNTkuNTU0LS4xMzguNjc1LS4wNTUuMDg1LS4xNC4xNTgtLjM2Mi4xNThoLTdjLS4yMjIgMC0uMzA3LS4wNzMtLjM2Mi0uMTU4LS4wOC0uMTIxLS4xMzgtLjM0LS4xMzgtLjY3NSIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-disjoint-channel,.ag-charts-icon-disjoint-channel-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTkuMDI4IDE3LjQ2YTIuMjUgMi4yNSAwIDAgMC00LjA5Mi0xLjg1bC05LjUxMS0yLjM3OGEyLjI1IDIuMjUgMCAxIDAtLjIyNS45NzRsOS40NzUgMi4zNjlhMi4yNTEgMi4yNTEgMCAwIDAgNC4zNTMuODg2bS0xLjY2Mi0xLjk2NWExLjI1IDEuMjUgMCAxIDEtLjg4NSAyLjMzOCAxLjI1IDEuMjUgMCAwIDEgLjg4NS0yLjMzOE00LjM0MyAxMy42NjlhMS4yNSAxLjI1IDAgMSAwLTIuMzM4LS44ODUgMS4yNSAxLjI1IDAgMCAwIDIuMzM4Ljg4NU0zLjk3IDguNzY5YTIuMjUgMi4yNSAwIDAgMCAxLjQ1NS0yLjExbDkuNTExLTIuMzc4YTIuMjUgMi4yNSAwIDEgMC0uMjYtLjk2NUw1LjIgNS42ODVhMi4yNSAyLjI1IDAgMSAwLTEuMjMgMy4wODRtLjM3My0yLjU0N2ExLjI1IDEuMjUgMCAxIDEtMi4zMzguODg1IDEuMjUgMS4yNSAwIDAgMSAyLjMzOC0uODg1bTEzLjc1LTMuNDM4YTEuMjUgMS4yNSAwIDEgMS0yLjMzOC44ODUgMS4yNSAxLjI1IDAgMCAxIDIuMzM4LS44ODUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-drag-handle{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48Y2lyY2xlIGN4PSI1Ljc1IiBjeT0iNy43NSIgcj0iLjc1IiBmaWxsPSIjMDAwIiBmaWxsLW9wYWNpdHk9Ii41Ii8+PGNpcmNsZSBjeD0iOS43NSIgY3k9IjcuNzUiIHI9Ii43NSIgZmlsbD0iIzAwMCIgZmlsbC1vcGFjaXR5PSIuNSIvPjxjaXJjbGUgY3g9IjEzLjc1IiBjeT0iNy43NSIgcj0iLjc1IiBmaWxsPSIjMDAwIiBmaWxsLW9wYWNpdHk9Ii41Ii8+PGNpcmNsZSBjeD0iMTMuNzUiIGN5PSIxMS43NSIgcj0iLjc1IiBmaWxsPSIjMDAwIiBmaWxsLW9wYWNpdHk9Ii41Ii8+PGNpcmNsZSBjeD0iOS43NSIgY3k9IjExLjc1IiByPSIuNzUiIGZpbGw9IiMwMDAiIGZpbGwtb3BhY2l0eT0iLjUiLz48Y2lyY2xlIGN4PSI1Ljc1IiBjeT0iMTEuNzUiIHI9Ii43NSIgZmlsbD0iIzAwMCIgZmlsbC1vcGFjaXR5PSIuNSIvPjwvc3ZnPg==)}.ag-charts-icon-fill-color{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJtOC4wNzEgNC4wNi0uOTI0LS45MjQuNzA3LS43MDcgNy4yODggNy4yODgtNC45NSA0Ljk1YTMuNSAzLjUgMCAwIDEtNC45NSAwbC0xLjQxNC0xLjQxNGEzLjUgMy41IDAgMCAxIDAtNC45NXptLjcwNy43MDhMNC41MzYgOS4wMWEyLjUgMi41IDAgMCAwIDAgMy41MzZMNS45NSAxMy45NmEyLjUgMi41IDAgMCAwIDMuNTM1IDBsNC4yNDMtNC4yNDN6bTYuOSA3LjIwMi0uMzQ1LjM2My0uMzQ0LS4zNjNhLjUuNSAwIDAgMSAuNjg4IDBtLS4zNDUgMS4wOGE4IDggMCAwIDAtLjI4LjMyMyA0LjMgNC4zIDAgMCAwLS40MDkuNTgyYy0uMTEzLjIwMS0uMTQ0LjMyNi0uMTQ0LjM3OGEuODMzLjgzMyAwIDAgMCAxLjY2NyAwYzAtLjA1Mi0uMDMxLS4xNzctLjE0NC0uMzc4YTQuMyA0LjMgMCAwIDAtLjQxLS41ODIgOCA4IDAgMCAwLS4yOC0uMzIybS0uMzQ0LTEuMDguMzQ0LjM2My4zNDQtLjM2My4wMDIuMDAyLjAwNC4wMDQuMDEzLjAxMmE2IDYgMCAwIDEgLjIwNi4yMDhjLjEzMS4xMzYuMzA4LjMyNy40ODUuNTQ1LjE3Ni4yMTUuMzYzLjQ2Ny41MDcuNzI0LjEzNy4yNDMuMjczLjU1My4yNzMuODY4YTEuODMzIDEuODMzIDAgMSAxLTMuNjY3IDBjMC0uMzE1LjEzNi0uNjI1LjI3My0uODY4LjE0NC0uMjU3LjMzLS41MDkuNTA3LS43MjRhOSA5IDAgMCAxIC42NDUtLjcwOGwuMDQ2LS4wNDUuMDEzLS4wMTIuMDA0LS4wMDR6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-hollow-candlestick-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1vcGFjaXR5PSIuMTUiIGQ9Ik01IDVoM3YxMEg1eiIvPjxwYXRoIGZpbGw9IiMxMzE3MjIiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTcgMXYzaDJ2MTJIN3YzSDZ2LTNINFY0aDJWMXpNNSA1aDN2MTBINXptNyAyaDN2NmgtM3ptLTEgN1Y2aDJWMy4yNWgxVjZoMnY4aC0ydjIuNzVoLTFWMTR6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-horizontal-line,.ag-charts-icon-horizontal-line-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNLjUgOS41aDcuMzA2YTIuMjUgMi4yNSAwIDAgMSA0LjM4OCAwSDE5LjV2MWgtNy4zMDZhMi4yNSAyLjI1IDAgMCAxLTQuMzg4IDBILjV6bTkuNSAxLjc1YTEuMjUgMS4yNSAwIDEgMCAwLTIuNSAxLjI1IDEuMjUgMCAwIDAgMCAyLjUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-line-color{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTQuMjQyIDIuNzIyYy0uNjEyIDAtMS4yLjI0My0xLjYzMi42NzVsLTEuMzQzIDEuMzQ0YS41LjUgMCAwIDAtLjExMi4xMTJMNC4wNSAxMS45NTljLS4yMDcuMjA3LS4zNi40Ni0uNDQ2Ljc0di4wMDFsLS42OSAyLjc2N3YuMDAyYS44Mi44MiAwIDAgMCAxLjAyMiAxLjAyMWguMDAybDIuNjM0LS44MjJjLjI4LS4wODUuNTM0LS4yMzcuNzQtLjQ0M2w3LjEwNy03LjEwOGEuNS41IDAgMCAwIC4xMTItLjExMmwxLjM0My0xLjM0M2EyLjMwOCAyLjMwOCAwIDAgMC0xLjYzMi0zLjk0TTE0LjEyMiA3bDEuMDQ0LTEuMDQ1YTEuMzA4IDEuMzA4IDAgMSAwLTEuODQ5LTEuODVMMTIuMjcxIDUuMTV6bS0yLjU1OC0xLjE0Mi02LjgwNyA2LjgwOWEuOC44IDAgMCAwLS4xOTYuMzI1bC0uNzUgMi40NjggMi40Ny0uNzQ5YS44LjggMCAwIDAgLjMyNS0uMTk0bDYuODA4LTYuODF6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-line-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJtMTcuMzYyIDQuODczLTQuNTk0IDYuNjU0LTQuODUtMy4zMTctNC4yNTEgNi45NzctLjg1NC0uNTJMNy42MTIgNi43OWw0Ljg5OSAzLjM1IDQuMDI4LTUuODM2eiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-line-style-dashed{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMiA5aDR2MUgyem0xMiAwaDR2MWgtNHpNOCA5aDR2MUg4eiIvPjwvc3ZnPg==)}.ag-charts-icon-line-style-dotted{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48Y2lyY2xlIGN4PSIyLjUiIGN5PSI5LjUiIHI9Ii41IiBmaWxsPSIjMDAwIi8+PGNpcmNsZSBjeD0iNC41IiBjeT0iOS41IiByPSIuNSIgZmlsbD0iIzAwMCIvPjxjaXJjbGUgY3g9IjYuNSIgY3k9IjkuNSIgcj0iLjUiIGZpbGw9IiMwMDAiLz48Y2lyY2xlIGN4PSI4LjUiIGN5PSI5LjUiIHI9Ii41IiBmaWxsPSIjMDAwIi8+PGNpcmNsZSBjeD0iMTAuNSIgY3k9IjkuNSIgcj0iLjUiIGZpbGw9IiMwMDAiLz48Y2lyY2xlIGN4PSIxMi41IiBjeT0iOS41IiByPSIuNSIgZmlsbD0iIzAwMCIvPjxjaXJjbGUgY3g9IjE0LjUiIGN5PSI5LjUiIHI9Ii41IiBmaWxsPSIjMDAwIi8+PGNpcmNsZSBjeD0iMTYuNSIgY3k9IjkuNSIgcj0iLjUiIGZpbGw9IiMwMDAiLz48L3N2Zz4=)}.ag-charts-icon-line-style-solid{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMiA5aDE2djFIMnoiLz48L3N2Zz4=)}.ag-charts-icon-line-with-markers-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJtMTguMTk4IDQuODg4LTMuNTU2IDQuOTE4YTIuMjUgMi4yNSAwIDEgMS0zLjg2Ni43NWwtMS40MzItLjlhMi4yNCAyLjI0IDAgMCAxLTIuMDA5LjQzNWwtMy44MjggNi40MjgtLjg2LS41MTJMNi40NSA5LjYyM2EyLjI1IDIuMjUgMCAxIDEgMy41MS0uNzYxbDEuMzI5LjgzNWEyLjI0IDIuMjQgMCAwIDEgMi41NTctLjQ5N2wzLjU0Mi00Ljg5OHptLTQuOTYgNS4xNTNhMS4yNSAxLjI1IDAgMSAwLS42NCAyLjQxOSAxLjI1IDEuMjUgMCAwIDAgLjY0LTIuNDE5TTkuMSA4LjMyMXEuMDY2LS4xOTIuMDY3LS40MDRhMS4yNSAxLjI1IDAgMSAwLS4wNjcuNDA0IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-lock,.ag-charts-icon-locked{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTAuMjA3IDMuNzY0YTIuODk0IDIuODk0IDAgMCAwLTIuODk1IDIuODk0VjloNS43ODlWNi42NThhMi44OTQgMi44OTQgMCAwIDAtMi44OTUtMi44OTRNMTQuMSA5VjYuNjU4YTMuODk0IDMuODk0IDAgMSAwLTcuNzg5IDB2Mi4zNDlBMi41IDIuNSAwIDAgMCA0IDExLjV2M0EyLjUgMi41IDAgMCAwIDYuNSAxN2g4YTIuNSAyLjUgMCAwIDAgMi41LTIuNXYtM0EyLjUgMi41IDAgMCAwIDE0LjUgOXpNNi41IDEwQTEuNSAxLjUgMCAwIDAgNSAxMS41djNBMS41IDEuNSAwIDAgMCA2LjUgMTZoOGExLjUgMS41IDAgMCAwIDEuNS0xLjV2LTNhMS41IDEuNSAwIDAgMC0xLjUtMS41eiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-measurer-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0ibTQuNDYxIDEyLjcxIDEuNTMyLTEuNTMxIDEuNDE0IDEuNDE0LjcwNy0uNzA3TDYuNyAxMC40NzJsMS41MzItMS41MzMgMiAyIC43MDctLjcwNy0yLTIgNi4wMS02LjAxIDIuODMgMi44MjhMNS4wNSAxNy43NzggMi4yMjIgMTQuOTVsMS41MzItMS41MzIgMS40MTQgMS40MTQuNzA3LS43MDd6TS44MDggMTQuOTVsLjcwNy0uNzA3TDE0LjI0MyAxLjUxNWwuNzA3LS43MDcuNzA3LjcwNyAyLjgyOCAyLjgyOC43MDcuNzA3LS43MDcuNzA3TDUuNzU3IDE4LjQ4NWwtLjcwNy43MDctLjcwNy0uNzA3LTIuODI4LTIuODI4em0xMS4wNzgtNi44MzVMMTAuNDcgNi43bC43MDctLjcwNyAxLjQxNSAxLjQxNHptLjgyNC0zLjY1NCAxIDEgLjcwOC0uNzA3LTEtMXoiIGZpbGw9IiMxODFEMUYiLz48L3N2Zz4=)}.ag-charts-icon-note-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMyA0LjVBMS41IDEuNSAwIDAgMSA0LjUgM2gxMUExLjUgMS41IDAgMCAxIDE3IDQuNXY4YTEuNSAxLjUgMCAwIDEtMS41IDEuNWgtMy4yMWwtMS40NjkgMi41N2ExIDEgMCAwIDEtMS42ODIuMDg1TDcuMjQzIDE0SDQuNUExLjUgMS41IDAgMCAxIDMgMTIuNXpNNC41IDRhLjUuNSAwIDAgMC0uNS41djhhLjUuNSAwIDAgMCAuNS41aDMuMjU3bDIuMTk2IDMuMDc0TDExLjcxIDEzaDMuNzlhLjUuNSAwIDAgMCAuNS0uNXYtOGEuNS41IDAgMCAwLS41LS41eiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNi41IDYuNUEuNS41IDAgMCAxIDcgNmg2YS41LjUgMCAwIDEgMCAxSDdhLjUuNSAwIDAgMS0uNS0uNU02LjUgOS41QS41LjUgMCAwIDEgNyA5aDZhLjUuNSAwIDAgMSAwIDFIN2EuNS41IDAgMCAxLS41LS41IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-ohlc-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZD0iTTEzIDExaC0zdi0xaDNWM2gxdjJoNHYxaC00djExaC0xek02IDE3di0yaDN2LTFINlY0SDV2MUgydjFoM3YxMXoiLz48L3N2Zz4=)}.ag-charts-icon-pan-end{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZD0ibTYuNjQ2IDEzLjgxMy0uMzUzLjM1NC43MDcuNzA3LjM1NC0uMzU0ek0xMS4xNjYgMTBsLjM1NC4zNTQuMzU0LS4zNTQtLjM1NC0uMzU0ek03LjM1NSA1LjQ4IDcgNS4xMjZsLS43MDcuNzA3LjM1My4zNTR6bTAgOS4wNCA0LjE2Ni00LjE2Ni0uNzA3LS43MDgtNC4xNjcgNC4xNjd6bTQuMTY2LTQuODc0TDcuMzU0IDUuNDhsLS43MDguNzA3IDQuMTY3IDQuMTY3ek0xMy4wODMgNXYxMGgxVjV6Ii8+PC9zdmc+)}.ag-charts-icon-pan-left{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTIuNzkgNS44MzMgOC42MjUgMTBsNC4xNjYgNC4xNjctLjcwNy43MDdMNy4yMSAxMGw0Ljg3My00Ljg3NHoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-pan-right{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNy4yMSAxNC4xNjcgMTEuMzc2IDEwIDcuMjEgNS44MzNsLjcwNy0uNzA3TDEyLjc5IDEwbC00Ljg3MyA0Ljg3NHoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-pan-start{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZD0iTTYgNXYxMGgxVjV6TTkuNjI0IDEwbDQuMTY2LTQuMTY3LS43MDctLjcwN0w4LjIxIDEwbDQuODc0IDQuODc0LjcwNy0uNzA3eiIvPjwvc3ZnPg==)}.ag-charts-icon-parallel-channel,.ag-charts-icon-parallel-channel-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTcuNzIgNS4zMzFBMi4yNSAyLjI1IDAgMSAwIDE0LjcwNSAzLjZsLTkuNDkgNC41NjJhMi4yNSAyLjI1IDAgMSAwIC4yMDkgMS4wMWw5LjY2Mi00LjY0NmEyLjI1IDIuMjUgMCAwIDAgMi42MzQuODA1bS4zNzMtMi41NDdhMS4yNSAxLjI1IDAgMSAxLTIuMzM4Ljg4NSAxLjI1IDEuMjUgMCAwIDEgMi4zMzgtLjg4NU00LjM0MyA4LjY3YTEuMjUgMS4yNSAwIDEgMS0yLjMzOC44ODUgMS4yNSAxLjI1IDAgMCAxIDIuMzM4LS44ODVNNS4zMDcgMTYuNzI4YTIuMjUgMi4yNSAwIDEgMS0uNTI1LS44NThsOS45MjMtNC43N2EyLjI1IDIuMjUgMCAxIDEgLjM4MS45MjZ6bS0uOTY0LjI3NGExLjI1IDEuMjUgMCAxIDEtMi4zMzguODg1IDEuMjUgMS4yNSAwIDAgMSAyLjMzOC0uODg1bTEzLjAyMy01LjEwNmExLjI1IDEuMjUgMCAxIDAtLjg4NS0yLjMzOSAxLjI1IDEuMjUgMCAwIDAgLjg4NSAyLjMzOSIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-position-bottom{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBmaWxsLW9wYWNpdHk9Ii4yNSIgZD0iTTMgMTBoMTR2MUgzem0zLTNoOHYxSDZ6Ii8+PHBhdGggZmlsbD0iIzAwMCIgZD0iTTYgMTNoOHYxSDZ6Ii8+PC9zdmc+)}.ag-charts-icon-position-center{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMyAxMGgxNHYxSDN6Ii8+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1vcGFjaXR5PSIuMjUiIGQ9Ik02IDdoOHYxSDZ6bTAgNmg4djFINnoiLz48L3N2Zz4=)}.ag-charts-icon-position-top{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBmaWxsLW9wYWNpdHk9Ii4yNSIgZD0iTTMgMTBoMTR2MUgzeiIvPjxwYXRoIGZpbGw9IiMwMDAiIGQ9Ik02IDdoOHYxSDZ6Ii8+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1vcGFjaXR5PSIuMjUiIGQ9Ik02IDEzaDh2MUg2eiIvPjwvc3ZnPg==)}.ag-charts-icon-price-label-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNC41IDNBMS41IDEuNSAwIDAgMCAzIDQuNVYxM2ExLjUgMS41IDAgMCAwIDEuNSAxLjVoLjgzM3YuMDU3Yy4yNDItLjI5OS41OTctLjUwMyAxLS41NDhWMTMuNUg0LjVBLjUuNSAwIDAgMSA0IDEzVjQuNWEuNS41IDAgMCAxIC41LS41aDExYS41LjUgMCAwIDEgLjUuNXY4YS41LjUgMCAwIDEtLjUuNWgtNC44MThsLS4xMjYuMDg0YTI2IDI2IDAgMCAwLTIuMjI1IDEuNjg1bC0uMzIuMjY1LS4wNjguMDU2YTEuNSAxLjUgMCAwIDEtMi42MDkgMS4zNTRjLjAzMy43NjMuOTA1IDEuMjM4IDEuNTYuNzU2LjY0Ni0uNDc0IDEuMjEtLjk0MyAxLjc2MS0xLjRsLjMxMy0uMjZBMjYgMjYgMCAwIDEgMTAuOTg2IDE0SDE1LjVhMS41IDEuNSAwIDAgMCAxLjUtMS41di04QTEuNSAxLjUgMCAwIDAgMTUuNSAzeiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNOC43MTYgMTQuODE1YTIuMjUgMi4yNSAwIDEgMS00LjIxIDEuNTkzIDIuMjUgMi4yNSAwIDAgMSA0LjIxLTEuNTkzbS0xLjY2MiAxLjk2NmExLjI1IDEuMjUgMCAxIDAtLjg4NS0yLjMzOSAxLjI1IDEuMjUgMCAwIDAgLjg4NSAyLjMzOSIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-price-range-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNOS4wNDYgMTVWNS44NzdoLjk0MlYxNXoiIGZpbGw9IiMxODFEMUYiLz48cGF0aCBkPSJNOS4wNDYgMTVWNS44NzdoLjk0MlYxNXoiIGZpbGw9IiMxODFEMUYiLz48cGF0aCBkPSJNOS41IDYuMjI4IDcuMTY3IDguMzc2IDYuNSA3Ljc2MiA5LjUgNWwzIDIuNzYyLS42NjcuNjE0eiIgZmlsbD0iIzAwMCIvPjxwYXRoIGQ9Ik0yIDE4di0xaDE2djF6TTIgM1YyaDE2djF6IiBmaWxsPSIjMTgxRDFGIi8+PC9zdmc+)}.ag-charts-icon-reset{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTIuMDQgNC40NDVhNS44MSA1LjgxIDAgMCAwLTcuMjU3IDIuNDUzLjUuNSAwIDAgMS0uODY1LS41MDJBNi44MSA2LjgxIDAgMSAxIDMgOS44MTNhLjUuNSAwIDAgMSAxIDAgNS44MSA1LjgxIDAgMSAwIDguMDQtNS4zNjgiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjxwYXRoIGZpbGw9IiMwMDAiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTQuMjg5IDMuMDAyYS41LjUgMCAwIDEgLjUuNXYyLjY1NWgyLjY1NWEuNS41IDAgMCAxIDAgMUg0LjI5YS41LjUgMCAwIDEtLjUtLjVWMy41MDJhLjUuNSAwIDAgMSAuNS0uNSIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-settings{--icon: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIgc3R5bGU9ImZpbGwtcnVsZTpldmVub2RkIj48cGF0aCBkPSJNMTAgMTNhMyAzIDAgMSAwIDAtNiAzIDMgMCAwIDAgMCA2bTAtMWEyIDIgMCAxIDEtLjAwMS0zLjk5OUEyIDIgMCAwIDEgMTAgMTIiLz48cGF0aCBkPSJNMi4zMSAxNC4zNDVjLS44MTctMS40OTEuMDI3LTIuNDk5LjQ3NC0yLjg2NS41MzEtLjQzNC45NjktLjM2NS45NzItMS40OC0uMDAzLTEuMTE1LS40NDEtMS4wNDYtLjk3Mi0xLjQ4MS0uNDU0LS4zNzEtMS4zMTctMS40MDUtLjQzNC0yLjkzNmwuMDA1LS4wMDljLjg4NC0xLjUyIDIuMjA3LTEuMjkgMi43NTUtMS4wODMuNjQxLjI0My44MDEuNjU2IDEuNzY4LjEwMS45NjQtLjU2LjY4Ni0uOTA0Ljc5Ni0xLjU4Mi4wOTQtLjU3OC41NTktMS44NDMgMi4zMjYtMS44NDNoLjAxYzEuNzU5LjAwNSAyLjIyMiAxLjI2NiAyLjMxNiAxLjg0My4xMS42NzgtLjE2OCAxLjAyMi43OTYgMS41ODIuOTY3LjU1NSAxLjEyNy4xNDIgMS43NjgtLjEwMS41NDktLjIwOCAxLjg3Ni0uNDM4IDIuNzYgMS4wOTJzLjAyIDIuNTY1LS40MzQgMi45MzZjLS41MzEuNDM1LS45NjkuMzY2LS45NzIgMS40ODEuMDAzIDEuMTE1LjQ0MSAxLjA0Ni45NzIgMS40OC40NTQuMzcyIDEuMzE3IDEuNDA2LjQzNCAyLjkzN2wtLjAwNS4wMDljLS44ODQgMS41Mi0yLjIwNyAxLjI5LTIuNzU1IDEuMDgzLS42NDEtLjI0My0uODAxLS42NTYtMS43NjgtLjEwMS0uOTY0LjU2LS42ODYuOTA0LS43OTYgMS41ODEtLjA5NC41NzktLjU1OSAxLjg0NC0yLjMyNiAxLjg0NGgtLjAxYy0xLjc1OS0uMDA1LTIuMjIyLTEuMjY2LTIuMzE2LTEuODQ0LS4xMS0uNjc3LjE2OC0xLjAyMS0uNzk2LTEuNTgxLS45NjctLjU1NS0xLjEyNy0uMTQyLTEuNzY4LjEwMS0uNTQ5LjIwOC0xLjg3Ni40MzgtMi43Ni0xLjA5MmwtLjAyLS4wMzZ6TTkuOTg0IDIuMTYySDEwYzEuMzU1IDAgMS4zNDIgMS4wMzkgMS4zNTMgMS40MjUuMDA4LjMxMi4wNCAxLjE2IDEuMjU5IDEuODcybC4wMTUuMDA4YzEuMjI1LjcgMS45NzYuMzA0IDIuMjUxLjE1NS4zMzctLjE4MyAxLjIyNi0uNzExIDEuOTAyLjQ0NWwuMDA4LjAxNGMuNjc4IDEuMTczLS4yMjkgMS42ODItLjU1OCAxLjg4NC0uMjY2LjE2My0uOTg0LjYxNS0uOTkxIDIuMDI3di4wMTZjLjAwNyAxLjQxMi43MjUgMS44NjQuOTkxIDIuMDI3LjMyOC4yMDEgMS4yMjkuNzA3LjU2NiAxLjg3bC0uMDA4LjAxNGMtLjY3NyAxLjE3NC0xLjU3MS42NDMtMS45MS40NTktLjI3NS0uMTQ5LTEuMDI2LS41NDUtMi4yNTEuMTU0bC0uMDE1LjAwOWMtMS4yMTkuNzEyLTEuMjUxIDEuNTYtMS4yNTkgMS44NzItLjAxMS4zODYuMDAyIDEuNDI1LTEuMzUzIDEuNDI1cy0xLjM0Mi0xLjAzOS0xLjM1My0xLjQyNWMtLjAwOC0uMzEyLS4wNC0xLjE2LTEuMjU5LTEuODcybC0uMDE1LS4wMDljLTEuMjI1LS42OTktMS45NzYtLjMwMy0yLjI1MS0uMTU0LS4zMzYuMTgzLTEuMjE5LjcwNi0xLjg5NC0uNDMybC0uMDE2LS4wMjdjLS42NzgtMS4xNzQuMjI5LTEuNjgyLjU1OC0xLjg4NC4yNjYtLjE2My45ODQtLjYxNS45OTEtMi4wMjd2LS4wMTZjLS4wMDctMS40MTItLjcyNS0xLjg2NC0uOTkxLTIuMDI3LS4zMjgtLjIwMS0xLjIyOS0uNzA3LS41NjYtMS44N2wuMDA4LS4wMTRjLjY3Ny0xLjE3NCAxLjU3MS0uNjQzIDEuOTEtLjQ1OS4yNzUuMTQ5IDEuMDI2LjU0NSAyLjI1MS0uMTU1bC4wMTUtLjAwOGMxLjIxOS0uNzEyIDEuMjUxLTEuNTYgMS4yNTktMS44NzIuMDEtLjM4NC0uMDAyLTEuNDE3IDEuMzM3LTEuNDI1Ii8+PC9zdmc+)}.ag-charts-icon-step-line-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzE4MUQxRiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNiA0aDV2OGgzVjhoNXYxaC00djRoLTVWNUg3djEwSDJ2LTFoNHoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-text-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00IDRIMTZWN0gxNVY1SDEwLjVWMTVIMTRWMTZINlYxNUg5LjVWNUg1VjdINFY0WiIgZmlsbD0iYmxhY2siLz4KPC9zdmc+Cg==)}.ag-charts-icon-trend-line,.ag-charts-icon-trend-line-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNS4zMTQgMTAuOTM4YTIuMjUgMi4yNSAwIDEgMSAuMDEtMWg5LjM1MmEyLjI1IDIuMjUgMCAxIDEgLjAxIDF6bS0yLjE4OS43MjlhMS4yNSAxLjI1IDAgMSAwIDAtMi41IDEuMjUgMS4yNSAwIDAgMCAwIDIuNW0xMy43NSAwYTEuMjUgMS4yNSAwIDEgMCAwLTIuNSAxLjI1IDEuMjUgMCAwIDAgMCAyLjUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-unlock,.ag-charts-icon-unlocked{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTAuNjUxIDMuNWEyLjg5NCAyLjg5NCAwIDAgMC0yLjg5NCAyLjg5NFY5SDE0LjVhMi41IDIuNSAwIDAgMSAyLjUgMi41djNhMi41IDIuNSAwIDAgMS0yLjUgMi41aC04QTIuNSAyLjUgMCAwIDEgNCAxNC41di0zQTIuNSAyLjUgMCAwIDEgNi41IDloLjI1N1Y2LjM5NGEzLjg5NCAzLjg5NCAwIDEgMSA3Ljc4OSAwIC41LjUgMCAwIDEtMSAwQTIuODk0IDIuODk0IDAgMCAwIDEwLjY1IDMuNU02LjUgMTBBMS41IDEuNSAwIDAgMCA1IDExLjV2M0ExLjUgMS41IDAgMCAwIDYuNSAxNmg4YTEuNSAxLjUgMCAwIDAgMS41LTEuNXYtM2ExLjUgMS41IDAgMCAwLTEuNS0xLjV6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-vertical-line,.ag-charts-icon-vertical-line-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTAuNSA3LjgwNmEyLjI1IDIuMjUgMCAwIDEgMCA0LjM4OFYxOS41aC0xdi03LjMwNmEyLjI1IDIuMjUgMCAwIDEgMC00LjM4OFYuNWgxem0tLjUuOTQ0YTEuMjUgMS4yNSAwIDEgMSAwIDIuNSAxLjI1IDEuMjUgMCAwIDEgMC0yLjUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-zoom-in{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZD0iTTEwIDUuNWEuNS41IDAgMCAxIC41LjV2My41aDMuODc1YS41LjUgMCAwIDEgMCAxSDEwLjV2NC4yNWEuNS41IDAgMSAxLTEgMFYxMC41SDUuNjI1YS41LjUgMCAxIDEgMC0xSDkuNVY2YS41LjUgMCAwIDEgLjUtLjUiLz48L3N2Zz4=)}.ag-charts-icon-zoom-out{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNS41IDEwYS41LjUgMCAwIDEgLjUtLjVoOGEuNS41IDAgMCAxIDAgMUg2YS41LjUgMCAwIDEtLjUtLjUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-high-low-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNyA0aDJ2MTJINFY0aDNNNSA1aDN2MTBINXpNMTEgMTRWNmg1djhoLTVtMS03aDN2NmgtM3oiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-hlc-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJtMTguMTYzIDEuODM3LTUuMzM0IDExLjYyMUw2Ljk1NyA4LjEybC00LjE5OSA5LjYyMi0uOTE2LS40IDQuNzU2LTEwLjlMMTIuNDkgMTEuOCAxNy4yNTQgMS40MnoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjxwYXRoIGZpbGw9IiMwMDAiIGZpbGwtb3BhY2l0eT0iLjQiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTUuODI1IDIuNzA0LjU1IDEzLjc4NWwuOTAyLjQzIDQuNzI0LTkuOTE5IDYuMDM0IDUuMDI5IDMuMjU1LTguMTQtLjkyOC0uMzctMi43NDUgNi44NnptNy44NTIgMTQuNjM2IDUuNzgtMTMuMTM5LS45MTUtLjQwMi01LjIxOSAxMS44Ni02LjAwNS01LjUwNC0zLjI3OCA3LjY0OC45Mi4zOTQgMi43MjItNi4zNTJ6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-zoom-in-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik04Ljc1IDQuNWEuNzUuNzUgMCAwIDAtMS41IDB2Mi43NUg0LjVhLjc1Ljc1IDAgMCAwIDAgMS41aDIuNzV2Mi43NWEuNzUuNzUgMCAwIDAgMS41IDBWOC43NWgyLjc1YS43NS43NSAwIDAgMCAwLTEuNUg4Ljc1VjQuNVoiIGZpbGw9IiMwMDAiLz48L3N2Zz4=)}.ag-charts-icon-zoom-out-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0zLjc1IDhhLjc1Ljc1IDAgMCAxIC43NS0uNzVoN2EuNzUuNzUgMCAwIDEgMCAxLjVoLTdBLjc1Ljc1IDAgMCAxIDMuNzUgOFoiIGZpbGw9IiMwMDAiLz48L3N2Zz4=)}.ag-charts-icon-zoom-in-alt,.ag-charts-icon-zoom-in-alt-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLXpvb20taW4iPjxjaXJjbGUgY3g9IjExIiBjeT0iMTEiIHI9IjgiLz48bGluZSB4MT0iMjEiIHgyPSIxNi42NSIgeTE9IjIxIiB5Mj0iMTYuNjUiLz48bGluZSB4MT0iMTEiIHgyPSIxMSIgeTE9IjgiIHkyPSIxNCIvPjxsaW5lIHgxPSI4IiB4Mj0iMTQiIHkxPSIxMSIgeTI9IjExIi8+PC9zdmc+)}.ag-charts-icon-zoom-out-alt,.ag-charts-icon-zoom-out-alt-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLXpvb20tb3V0Ij48Y2lyY2xlIGN4PSIxMSIgY3k9IjExIiByPSI4Ii8+PGxpbmUgeDE9IjIxIiB4Mj0iMTYuNjUiIHkxPSIyMSIgeTI9IjE2LjY1Ii8+PGxpbmUgeDE9IjgiIHgyPSIxNCIgeTE9IjExIiB5Mj0iMTEiLz48L3N2Zz4=)}.ag-charts-icon-reset-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00LjQxMiA0LjA1OCAyLjc1IDIuMzk2VjYuNzVoLjc0NGEuNzYuNzYgMCAwIDAgLjAxMiAwaDMuNTk4TDUuNDc4IDUuMTI1YTQuMTI1IDQuMTI1IDAgMCAxIDIuNTIzLS44NzUgMy43NSAzLjc1IDAgMSAxLTMuMTE5IDUuODMzLjc1Ljc1IDAgMCAwLTEuMjQ3LjgzNEE1LjI1IDUuMjUgMCAxIDAgOCAyLjc1aC0uMDAzYTUuNjI1IDUuNjI1IDAgMCAwLTMuNTg1IDEuMzA4WiIgZmlsbD0iIzAwMCIvPjwvc3ZnPg==)}.ag-charts-icon-pan-left-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xMC4wMyA0LjQ3YS43NS43NSAwIDAgMSAwIDEuMDZMNy41NiA4bDIuNDcgMi40N2EuNzUuNzUgMCAxIDEtMS4wNiAxLjA2bC0zLTNhLjc1Ljc1IDAgMCAxIDAtMS4wNmwzLTNhLjc1Ljc1IDAgMCAxIDEuMDYgMFoiIGZpbGw9IiMwMDAiLz48L3N2Zz4=)}.ag-charts-icon-pan-right-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik01Ljk3IDExLjUzYS43NS43NSAwIDAgMSAwLTEuMDZMOC40NCA4IDUuOTcgNS41M2EuNzUuNzUgMCAwIDEgMS4wNi0xLjA2bDMgM2EuNzUuNzUgMCAwIDEgMCAxLjA2bC0zIDNhLjc1Ljc1IDAgMCAxLTEuMDYgMFoiIGZpbGw9IiMwMDAiLz48L3N2Zz4=)}.ag-charts-icon-pan-start-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLWNoZXZyb24tZmlyc3QiPjxwYXRoIGQ9Im0xNyAxOC02LTYgNi02Ii8+PHBhdGggZD0iTTcgNnYxMiIvPjwvc3ZnPg==)}.ag-charts-icon-pan-end-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLWNoZXZyb24tbGFzdCI+PHBhdGggZD0ibTcgMTggNi02LTYtNiIvPjxwYXRoIGQ9Ik0xNyA2djEyIi8+PC9zdmc+)}.ag-charts-icon-trend-line-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGNpcmNsZSBjeD0iMi41IiBjeT0iOCIgcj0iMS43NSIgc3Ryb2tlPSIjMDAwIiBzdHJva2Utd2lkdGg9IjEuNSIvPjxjaXJjbGUgY3g9IjEzLjUiIGN5PSI4IiByPSIxLjc1IiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iMS41Ii8+PHBhdGggc3Ryb2tlPSIjMDAwIiBzdHJva2Utd2lkdGg9IjEuNSIgZD0iTTQgOGg4Ii8+PC9zdmc+)}.ag-charts-icon-horizontal-line-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xMC4zODYgOC43NWEyLjUwMSAyLjUwMSAwIDAgMS00Ljc3MiAwSC43NWEuNzUuNzUgMCAwIDEgMC0xLjVoNC44NjRhMi41MDEgMi41MDEgMCAwIDEgNC43NzIgMGg0Ljg2NGEuNzUuNzUgMCAwIDEgMCAxLjVoLTQuODY0Wk05IDhhMSAxIDAgMSAxLTIgMCAxIDEgMCAwIDEgMiAwWiIgZmlsbD0iIzAwMCIvPjwvc3ZnPg==)}.ag-charts-icon-vertical-line-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik04Ljc1IDUuNjE0YTIuNTAxIDIuNTAxIDAgMCAxIDAgNC43NzJ2NC44NjRhLjc1Ljc1IDAgMCAxLTEuNSAwdi00Ljg2NGEyLjUwMSAyLjUwMSAwIDAgMSAwLTQuNzcyVi43NWEuNzUuNzUgMCAwIDEgMS41IDB2NC44NjRaTTggN2ExIDEgMCAxIDEgMCAyIDEgMSAwIDAgMSAwLTJaIiBmaWxsPSIjMDAwIi8+PC9zdmc+)}.ag-charts-icon-parallel-channel-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTciIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNC40MjQgNC45MmEyLjUgMi41IDAgMSAwLTMuMzc3LTIuMTRsLTYuNjMgMi45YTIuNTAxIDIuNTAxIDAgMSAwIC42MDcgMS4zNzJsNi41ODUtMi44OGEyLjUwMSAyLjUwMSAwIDAgMCAyLjgxNS43NDhabS4wNS0yLjY5M2ExIDEgMCAxIDEtMS44Ny43MDggMSAxIDAgMCAxIDEuODctLjcwOFptLTExIDQuNzVhMSAxIDAgMSAxLTEuODcuNzA4IDEgMSAwIDAgMSAxLjg3LS43MDhabTEuNTUgNi4wNzVhMi41MDEgMi41MDEgMCAxIDEtLjYwNy0xLjM3Mmw2LjYzLTIuOWEyLjUwMSAyLjUwMSAwIDEgMSAuNTYyIDEuMzkxbC02LjU4NSAyLjg4Wm0tMS41NS0uMDc1YTEgMSAwIDEgMS0xLjg3LjcwOCAxIDEgMCAwIDEgMS44Ny0uNzA4Wm0xMC40Mi0zLjQ2YTEgMSAwIDEgMC0uNzA5LTEuODcgMSAxIDAgMCAwIC43MDggMS44N1oiIGZpbGw9IiMwMDAiLz48L3N2Zz4=)}.ag-charts-icon-disjoint-channel-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTciIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNC40MjQgNC45MmEyLjUgMi41IDAgMSAwLTMuMzgzLTIuNDUzTDQuNjkgNC4wNTVhMi41IDIuNSAwIDEgMCAuMzQ0IDEuNDZsNi4zOTItMS41OThhMi41MDEgMi41MDEgMCAwIDAgMyAxLjAwM1ptLjA1LTIuNjkzYTEgMSAwIDEgMS0xLjg3LjcwOCAxIDEgMCAwIDEgMS44Ny0uNzA4Wm0tMTEgMi43NWExIDEgMCAxIDEtMS44Ny43MDggMSAxIDAgMCAxIDEuODctLjcwOFptMS41NiA1LjQyYTIuNSAyLjUgMCAxIDAtLjM0NSAxLjQ2MWw2LjM1MiAxLjU4OGEyLjUgMi41IDAgMSAwIC4zODQtMS40NWwtNi4zOTItMS41OThabS0xLjU2LjUzOGExIDEgMCAxIDAtMS44Ny0uNzA4IDEgMSAwIDAgMCAxLjg3LjcwOFptMTAuNDIgMS40NjFhMSAxIDAgMSAxLS43MDkgMS44NyAxIDEgMCAwIDEgLjcwOC0xLjg3WiIgZmlsbD0iIzAwMCIvPjwvc3ZnPg==)}.ag-charts-icon-line-color-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgY2xpcC1wYXRoPSJ1cmwoI2EpIj48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEyLjc4OC41ODNhMi42MyAyLjYzIDAgMCAwLTEuODYuNzdMOS41NDQgMi43MzhhLjc1Ny43NTcgMCAwIDAtLjE0LjE0TDIuMDMyIDEwLjI1di4wMDFjLS4yNDIuMjQxLS40Mi41MzgtLjUyLjg2NGwtLjAwMi4wMDItLjg4IDIuOTAyLS4wMDEuMDAzYTEuMDgzIDEuMDgzIDAgMCAwIDEuMzUgMS4zNDdoLjAwMWwyLjkwMi0uODhoLjAwMWMuMzI2LS4xLjYyMy0uMjc3Ljg2NS0uNTE4di0uMDAxbDcuMzc1LTcuMzc2YS43NjMuNzYzIDAgMCAwIC4xMzktLjEzOWwxLjM4NC0xLjM4NEEyLjYzIDIuNjMgMCAwIDAgMTIuNzg4LjU4M1ptLS4xMjYgNC4zNTIuOTI0LS45MjRhMS4xMyAxLjEzIDAgMCAwLTEuNTk3LTEuNTk3bC0uOTI0LjkyNCAxLjU5NyAxLjU5N1ptLTIuNjU3LS41MzYtNi45MTMgNi45MTRIMy4wOWEuNTgzLjU4MyAwIDAgMC0uMTQ2LjI0MmwtLjY1MyAyLjE1MyAyLjE1NS0uNjU0YS41ODMuNTgzIDAgMCAwIC4yNDEtLjE0NGw2LjkxNC02LjkxNC0xLjU5Ny0xLjU5N1oiIGZpbGw9IiMwMDAiLz48L2c+PGRlZnM+PGNsaXBQYXRoIGlkPSJhIj48cGF0aCBmaWxsPSIjZmZmIiBkPSJNMCAwaDE2djE2SDB6Ii8+PC9jbGlwUGF0aD48L2RlZnM+PC9zdmc+)}.ag-charts-icon-delete-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik02LjA4MyAyLjY2N2MwLS4wOS4wNTMtLjI0Mi4xOTctLjM4Ny4xNDUtLjE0NC4yOTctLjE5Ny4zODctLjE5N2gyLjY2N2MuMDg5IDAgLjI0MS4wNTMuMzg2LjE5Ny4xNDUuMTQ1LjE5Ny4yOTcuMTk3LjM4N3YuNTgzSDYuMDg0di0uNTgzWk01LjMzIDQuNzVIMTEuOTE3djguNTgzYzAgLjA5LS4wNTIuMjQyLS4xOTcuMzg3LS4xNDUuMTQ0LS4yOTcuMTk3LS4zODYuMTk3SDQuNjY3Yy0uMDkgMC0uMjQyLS4wNTMtLjM4Ny0uMTk3LS4xNDQtLjE0NS0uMTk3LS4yOTctLjE5Ny0uMzg3VjQuNzVINS4zM1ptLS43NDUtMS41di0uNTgzYzAtLjU3OC4yOC0xLjA5Mi42MzYtMS40NDcuMzU1LS4zNTYuODctLjYzNyAxLjQ0Ny0uNjM3aDIuNjY3Yy41NzcgMCAxLjA5MS4yODEgMS40NDcuNjM3LjM1NS4zNTUuNjM2Ljg3LjYzNiAxLjQ0N3YuNTgzSDE0YS43NS43NSAwIDAgMSAwIDEuNWgtLjU4M3Y4LjU4M2MwIC41NzgtLjI4MSAxLjA5Mi0uNjM2IDEuNDQ3LS4zNTYuMzU2LS44Ny42MzctMS40NDcuNjM3SDQuNjY3Yy0uNTc3IDAtMS4wOTItLjI4MS0xLjQ0Ny0uNjM3LS4zNTUtLjM1NS0uNjM3LS44Ny0uNjM3LTEuNDQ3VjQuNzVIMmEuNzUuNzUgMCAwIDEgMC0xLjVoMi41ODNabTIuMDgzIDMuMzMzYS43NS43NSAwIDAgMSAuNzUuNzV2NGEuNzUuNzUgMCAxIDEtMS41IDB2LTRhLjc1Ljc1IDAgMCAxIC43NS0uNzVabTMuNDE3Ljc1YS43NS43NSAwIDAgMC0xLjUgMHY0YS43NS43NSAwIDEgMCAxLjUgMHYtNFoiIGZpbGw9IiMwMDAiLz48L3N2Zz4=)}.ag-charts-icon-lock-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik02LjE3MyAyLjg0YTIuNTgzIDIuNTgzIDAgMCAxIDQuNDEgMS44Mjd2MS45MTZINS40MTZWNC42NjdjMC0uNjg1LjI3My0xLjM0My43NTctMS44MjdaTTMuOTE3IDYuNTgzVjQuNjY3YTQuMDgzIDQuMDgzIDAgMCAxIDguMTY2IDB2MS45MTZoLjU4NGMxLjE1IDAgMi4wODMuOTMzIDIuMDgzIDIuMDg0djQuNjY2YzAgMS4xNS0uOTMzIDIuMDg0LTIuMDgzIDIuMDg0SDMuMzMzYTIuMDgzIDIuMDgzIDAgMCAxLTIuMDgzLTIuMDg0VjguNjY3YzAtMS4xNTEuOTMzLTIuMDg0IDIuMDgzLTIuMDg0aC41ODNabTcuNDE2IDEuNWgtOGEuNTgzLjU4MyAwIDAgMC0uNTgzLjU4NHY0LjY2NmMwIC4zMjIuMjYxLjU4NC41ODMuNTg0aDkuMzM0YS41ODMuNTgzIDAgMCAwIC41ODMtLjU4NFY4LjY2N2EuNTgzLjU4MyAwIDAgMC0uNTgzLS41ODRoLTEuMzM0WiIgZmlsbD0iIzAwMCIvPjwvc3ZnPg==)}.ag-charts-icon-unlock-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTciIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik02LjkyMyAyLjg0YTIuNTgzIDIuNTgzIDAgMCAxIDMuNjUzIDAgMyAzIDAgMCAxIC41Ny43OThjLjEzNC4yNzguMTcuNDc0LjE3LjU0NWEuNzUuNzUgMCAwIDAgMS41IDBjMC0uMzgxLS4xMzItLjgwOS0uMzItMS4xOThhNC41MDEgNC41MDEgMCAwIDAtLjg1OS0xLjIwNiA0LjA4MyA0LjA4MyAwIDAgMC02Ljk3IDIuODg4djEuOTE2aC0uNTg0QzIuOTMzIDYuNTgzIDIgNy41MTYgMiA4LjY2N3Y0LjY2NmMwIDEuMTUuOTMzIDIuMDg0IDIuMDgzIDIuMDg0aDkuMzM0YzEuMTUgMCAyLjA4My0uOTMzIDIuMDgzLTIuMDg0VjguNjY3YzAtMS4xNTEtLjkzMy0yLjA4NC0yLjA4My0yLjA4NGgtNy4yNVY0LjY2N2MwLS42ODUuMjcyLTEuMzQzLjc1Ni0xLjgyN1pNNS40MTcgOC4wODNINC4wODJhLjU4My41ODMgMCAwIDAtLjU4My41ODR2NC42NjZjMCAuMzIyLjI2MS41ODQuNTgzLjU4NGg5LjMzNGEuNTgzLjU4MyAwIDAgMCAuNTgzLS41ODRWOC42NjdhLjU4My41ODMgMCAwIDAtLjU4My0uNTg0aC04WiIgZmlsbD0iIzAwMCIvPjwvc3ZnPg==)}.ag-charts-icon-plus-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLXBsdXMiPjxwYXRoIGQ9Ik01IDEyaDE0Ii8+PHBhdGggZD0iTTEyIDV2MTQiLz48L3N2Zz4=)}.ag-charts-icon-crossline-add-line-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNOC43NSA0LjVhLjc1Ljc1IDAgMCAwLTEuNSAwdjIuNzVINC41YS43NS43NSAwIDAgMCAwIDEuNWgyLjc1djIuNzVhLjc1Ljc1IDAgMCAwIDEuNSAwVjguNzVoMi43NWEuNzUuNzUgMCAwIDAgMC0xLjVIOC43NXoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-input{--input-layer-active: 1;--input-layer-focus: 2;color:inherit;font-family:var(--ag-charts-input-font-family);font-size:var(--ag-charts-input-font-size);transition-duration:var(--ag-charts-input-transition-duration);transition-property:none;transition-timing-function:var(--ag-charts-input-transition-timing-function)}.ag-charts-input:focus-visible{outline:var(--ag-charts-input-focus-outline);box-shadow:var(--ag-charts-input-focus-box-shadow);z-index:var(--input-layer-focus)}.ag-charts-button{background:var(--ag-charts-input-background-color);border:1px solid var(--ag-charts-input-border-color);border-radius:var(--ag-charts-input-border-radius);cursor:pointer;padding:var(--ag-charts-input-padding);transition-property:background,border-color}.ag-charts-button:hover{background:var(--ag-charts-input-background-color--hover)}.ag-charts-button:has(.ag-charts-icon){padding:2px}.ag-charts-checkbox{appearance:none;background:var(--ag-charts-input-checkbox-background-color);border-radius:9px;cursor:pointer;height:18px;margin:0;transition-duration:var(--ag-charts-input-transition-duration--fast);transition-property:margin;width:29px}.ag-charts-checkbox:before{display:block;background:var(--ag-charts-input-background-color);border-radius:7px;content:\" \";height:14px;margin:2px;transition-duration:var(--ag-charts-input-transition-duration--fast);transition-property:margin;transition-timing-function:var(--ag-charts-input-transition-easing);width:14px}.ag-charts-checkbox:checked{background:var(--ag-charts-input-checkbox-background-color--checked)}.ag-charts-checkbox:checked:before{margin-left:13px}.ag-charts-select{background:var(--ag-charts-input-background-color);border:1px solid var(--ag-charts-input-border-color);border-radius:var(--ag-charts-input-border-radius);padding:3px 2px 4px;font-size:inherit}.ag-charts-textarea{--line-height: 1.38;background:var(--ag-charts-input-background-color);border:1px solid var(--ag-charts-input-border-color);border-radius:var(--ag-charts-input-border-radius);line-height:var(--line-height);font-family:var(--ag-charts-input-font-family);font-size:var(--ag-charts-input-font-size);padding:var(--ag-charts-input-padding-large) var(--ag-charts-input-padding)}.ag-charts-textarea[placeholder]:empty:before{color:var(--ag-charts-input-placeholder);content:attr(placeholder)}.ag-charts-proxy-container{pointer-events:none;position:absolute}.ag-charts-proxy-elem{-webkit-appearance:none;appearance:none;background:none;border:none;color:#0000;overflow:hidden;pointer-events:none;position:absolute}.ag-charts-proxy-elem::-moz-range-thumb,.ag-charts-proxy-elem::-moz-range-track{opacity:0}.ag-charts-proxy-elem::-webkit-slider-runnable-track,.ag-charts-proxy-elem::-webkit-slider-thumb{opacity:0}.ag-charts-proxy-elem:focus-visible{outline:var(--ag-charts-focus-border);box-shadow:var(--ag-charts-focus-border-shadow)}.ag-charts-focus-indicator{position:absolute;display:block;pointer-events:none;user-select:none;width:100%;height:100%}.ag-charts-focus-indicator>div{position:absolute;outline:var(--ag-charts-focus-border);outline-width:2px;box-shadow:var(--ag-charts-focus-border-shadow)}.ag-charts-focus-indicator>svg{width:100%;height:100%;fill:none;stroke:var(--ag-charts-focus-border-color);stroke-width:2px}.ag-charts-toolbar{align-items:center;background:none;border:none;display:flex;flex-wrap:nowrap;opacity:1;position:absolute;transform:translateY(0);transition:opacity .2s ease-in-out,transform .2s ease-in-out}.ag-charts-toolbar--hidden,.ag-charts-toolbar--prevent-flash{visibility:hidden}.ag-charts-toolbar--floating-hidden{opacity:0;transition:opacity .4s ease-in-out}.ag-charts-toolbar--small{--ag-charts-toolbar-size: var(--ag-charts-toolbar-size-small);--ag-charts-toolbar-font-size: var(--ag-charts-toolbar-font-size-small);--ag-charts-toolbar-button-padding: var(--ag-charts-toolbar-button-padding-small)}.ag-charts-toolbar--top,.ag-charts-toolbar--bottom{flex-direction:row;width:100%}.ag-charts-toolbar--left,.ag-charts-toolbar--right{flex-direction:column}.ag-charts-toolbar--floating,.ag-charts-toolbar--floating-top,.ag-charts-toolbar--floating-bottom{background:none;border:none;flex-direction:row;pointer-events:none;width:100%}.ag-charts-toolbar--floating{padding:0;width:auto;z-index:var(--ag-charts-layer-toolbar)}.ag-charts-toolbar--floating-top{height:calc(var(--ag-charts-toolbar-size) + 10px);padding-top:10px}.ag-charts-toolbar--floating-bottom{height:calc(var(--ag-charts-toolbar-size) + 10px);padding-bottom:10px;overflow:hidden}.ag-charts-toolbar__align{display:flex;flex-direction:inherit;flex-wrap:inherit;gap:var(--ag-charts-toolbar-gap);max-width:100%;width:100%}.ag-charts-toolbar__align--start{justify-content:start}.ag-charts-toolbar__align--center{justify-content:center}.ag-charts-toolbar__align--end{justify-content:end}.ag-charts-toolbar__align--center,.ag-charts-toolbar__align--end{margin-left:auto}.ag-charts-toolbar--left .ag-charts-toolbar__align--center,.ag-charts-toolbar--left .ag-charts-toolbar__align--end,.ag-charts-toolbar--right .ag-charts-toolbar__align--center,.ag-charts-toolbar--right .ag-charts-toolbar__align--end{margin-left:0;margin-top:auto}.ag-charts-toolbar--floating-top .ag-charts-toolbar__align,.ag-charts-toolbar--floating-bottom .ag-charts-toolbar__align{transition:transform .4s ease-in-out;width:auto}.ag-charts-toolbar__section{display:inherit;flex-direction:inherit;flex-wrap:inherit;justify-content:inherit;max-width:inherit;width:inherit}.ag-charts-toolbar__button{align-items:center;background:var(--ag-charts-toolbar-background-color);border:var(--ag-charts-toolbar-border);color:var(--ag-charts-toolbar-foreground-color);display:flex;font:var(--ag-charts-toolbar-font-size) var(--ag-charts-font-family);justify-content:center;margin:0 0 0 -1px;min-height:var(--ag-charts-toolbar-size);min-width:var(--ag-charts-toolbar-size);padding:var(--ag-charts-toolbar-button-padding);pointer-events:all;position:relative;white-space:nowrap;--stroke-width-color: var(--ag-charts-toolbar-foreground-color)}.ag-charts-toolbar__no-pointer-events{pointer-events:none}.ag-charts-toolbar__button--drag-handle{min-width:24px;padding-left:0;padding-right:0}.ag-charts-toolbar__button--with-transition{transition:background-color .25s ease-in-out,border-color .25s ease-in-out,color .25s ease-in-out}.ag-charts-toolbar__button[data-toolbar-group=ranges]{padding:var(--ag-charts-toolbar-button-padding) calc(var(--ag-charts-toolbar-button-padding) * 1.5)}.ag-charts-toolbar--top,.ag-charts-toolbar--bottom,.ag-charts-toolbar--floating,.ag-charts-toolbar--floating-top,.ag-charts-toolbar--floating-bottom{.ag-charts-toolbar__button--first{border-bottom-left-radius:var(--ag-charts-button-radius);border-top-left-radius:var(--ag-charts-button-radius);margin:0}.ag-charts-toolbar__button--last{border-bottom-right-radius:var(--ag-charts-button-radius);border-top-right-radius:var(--ag-charts-button-radius)}}.ag-charts-toolbar--left,.ag-charts-toolbar--right{.ag-charts-toolbar__button{border-radius:0;margin:-1px 0 0;max-width:100%}.ag-charts-toolbar__button--first{border-top-left-radius:var(--ag-charts-button-radius);border-top-right-radius:var(--ag-charts-button-radius);margin:0}.ag-charts-toolbar__button--last{border-bottom-left-radius:var(--ag-charts-button-radius);border-bottom-right-radius:var(--ag-charts-button-radius)}}.ag-charts-toolbar__button--hidden-value,.ag-charts-toolbar__button--hidden-toggled{display:none}.ag-charts-toolbar__button:hover:not([aria-disabled=true],.ag-charts-toolbar__button--drag-handle){background:var(--ag-charts-toolbar-hover-color);z-index:1}.ag-charts-toolbar__button:focus-visible{outline:var(--ag-charts-focus-border);box-shadow:var(--ag-charts-focus-border-shadow);z-index:calc(var(--ag-charts-layer-ui-overlay) + 1)}.ag-charts-toolbar__button.ag-charts-toolbar__button--active{background:var(--ag-charts-toolbar-active-background-color);border-color:var(--ag-charts-toolbar-active-color);color:var(--ag-charts-toolbar-active-color);z-index:2;--stroke-width-color: var(--ag-charts-toolbar-active-color)}.ag-charts-toolbar__button[aria-disabled=true]{background:var(--ag-charts-toolbar-disabled-background-color);color:var(--ag-charts-toolbar-disabled-foreground-color)}.ag-charts-toolbar__button:not([aria-disabled=true]){cursor:pointer}.ag-charts-toolbar__button.ag-charts-toolbar__button--drag-handle{cursor:grab}.ag-charts-toolbar__button.ag-charts-toolbar__button--dragging{cursor:grabbing}.ag-charts-toolbar__button--fill-visible:after{content:\"\";display:block;position:absolute;bottom:3px;left:5px;right:5px;height:4px;border-radius:99px;box-shadow:inset 0 0 0 1px color-mix(in srgb,var(--ag-charts-foreground-color) 10%,transparent);background:var(--fill)}.ag-charts-toolbar__button--fill-visible[aria-disabled=true]:after{filter:grayscale(1);opacity:.5}.ag-charts-toolbar__button--stroke-width-visible:before{content:\"\";height:min(var(--strokeWidth),20px);width:12px;background:var(--stroke-width-color);margin-right:var(--ag-charts-toolbar-button-padding)}.ag-charts-toolbar__button--stroke-width-visible[aria-disabled=true]:before{filter:grayscale(1);opacity:.5}.ag-charts-toolbar__icon+.ag-charts-toolbar__label{margin-left:var(--ag-charts-toolbar-gap)}.ag-charts-toolbar__icon,.ag-charts-toolbar__label{pointer-events:none}.ag-chart-overlay{color:#181d1f;pointer-events:none}.ag-chart-overlay.ag-chart-dark-overlay{color:#fff}.ag-chart-overlay--loading{color:#8c8c8c}.ag-chart-overlay__loading-background{background:#fff;pointer-events:none}.ag-chart-overlay.ag-chart-dark-overlay .ag-chart-overlay__loading-background{background:#192232}.ag-chart-tooltip{transition:transform .1s ease;width:max-content;z-index:99999;font:12px Verdana,sans-serif;color:#464646;box-shadow:0 4px 8px #00000014}.ag-chart-tooltip-wrap-always{overflow-wrap:break-word;word-break:break-word;hyphens:none}.ag-chart-tooltip-wrap-hyphenate{overflow-wrap:break-word;word-break:break-word;hyphens:auto}.ag-chart-tooltip-wrap-on-space{overflow-wrap:normal;word-break:normal}.ag-chart-tooltip-wrap-never{white-space:pre;text-overflow:ellipsis}.ag-chart-tooltip-no-interaction{pointer-events:none;user-select:none}.ag-chart-tooltip-no-animation{transition:none!important}.ag-chart-tooltip-hidden{visibility:hidden}.ag-chart-tooltip-title{overflow:hidden;position:relative;padding:8px 14px;border-top-left-radius:2px;border-top-right-radius:2px;color:#fff;background-color:#888;z-index:1;text-overflow:inherit}.ag-chart-tooltip-title:only-child{border-bottom-left-radius:2px;border-bottom-right-radius:2px}.ag-chart-tooltip-content{overflow:hidden;padding:6px 14px;line-height:1.7em;background:#fff;border-bottom-left-radius:2px;border-bottom-right-radius:2px;border:1px solid rgba(0,0,0,.15);text-overflow:inherit}.ag-chart-tooltip-arrow:before{content:\"\";position:absolute;top:100%;left:50%;transform:translate(-50%);border:5px solid #d9d9d9;border-left-color:transparent;border-right-color:transparent;border-bottom-color:transparent;width:0;height:0;margin:0 auto}.ag-chart-tooltip-arrow:after{content:\"\";position:absolute;top:calc(100% - 1px);left:50%;transform:translate(-50%);border:5px solid white;border-left-color:transparent;border-right-color:transparent;border-bottom-color:transparent;width:0;height:0;margin:0 auto}\\n';\n\n// packages/ag-charts-community/src/util/keynavUtil.ts\nfunction addRemovableEventListener(destroyFns, elem, type, listener) {\n  elem.addEventListener(type, listener);\n  const remover = () => elem.removeEventListener(type, listener);\n  destroyFns.push(remover);\n  return remover;\n}\nfunction addEscapeEventListener(destroyFns, elem, onEscape) {\n  addRemovableEventListener(destroyFns, elem, \"keydown\", (event) => {\n    if (event.key === \"Escape\") {\n      onEscape(event);\n    }\n  });\n}\nfunction addMouseCloseListener(destroyFns, menu, hideCallback) {\n  const self = addRemovableEventListener(destroyFns, window, \"mousedown\", (event) => {\n    if ([0, 2].includes(event.button) && !containsPoint(menu, event)) {\n      hideCallback();\n      self();\n    }\n  });\n  return self;\n}\nfunction containsPoint(container, event) {\n  if (event.target instanceof Element) {\n    const { x, y, width: width2, height: height2 } = container.getBoundingClientRect();\n    const { clientX: ex, clientY: ey } = event;\n    return ex >= x && ey >= y && ex <= x + width2 && ey <= y + height2;\n  }\n  return false;\n}\nfunction hasNoModifiers(event) {\n  return !(event.shiftKey || event.altKey || event.ctrlKey || event.metaKey);\n}\nfunction matchesKey(event, key, ...morekeys) {\n  return hasNoModifiers(event) && (event.key === key || morekeys.some((altkey) => event.key === altkey));\n}\nfunction linkTwoButtons(destroyFns, src, dst, key) {\n  if (!dst)\n    return;\n  addRemovableEventListener(destroyFns, src, \"keydown\", (event) => {\n    if (matchesKey(event, key)) {\n      dst.focus();\n    }\n  });\n}\nfunction linkThreeButtons(destroyFns, curr, next, nextKey, prev, prevKey) {\n  linkTwoButtons(destroyFns, curr, prev, prevKey);\n  linkTwoButtons(destroyFns, curr, next, nextKey);\n  addRemovableEventListener(destroyFns, curr, \"keydown\", (event) => {\n    if (matchesKey(event, nextKey, prevKey)) {\n      event.preventDefault();\n    }\n  });\n}\nvar PREV_NEXT_KEYS = {\n  horizontal: { nextKey: \"ArrowRight\", prevKey: \"ArrowLeft\" },\n  vertical: { nextKey: \"ArrowDown\", prevKey: \"ArrowUp\" }\n};\nfunction initToolbarKeyNav(opts) {\n  opts.toolbar.role = \"toolbar\";\n  opts.toolbar.ariaOrientation = opts.orientation;\n  opts.toolbar.ariaHidden = (opts.buttons.length === 0).toString();\n  return initRovingTabIndex(opts);\n}\nfunction initRovingTabIndex(opts) {\n  const { orientation, buttons, wrapAround = false, onEscape, onFocus, onBlur } = opts;\n  const { nextKey, prevKey } = PREV_NEXT_KEYS[orientation];\n  const setTabIndices = (event) => {\n    if (event.target && \"tabIndex\" in event.target) {\n      buttons.forEach((b) => b.tabIndex = -1);\n      event.target.tabIndex = 0;\n    }\n  };\n  const [c, m] = wrapAround ? [buttons.length, buttons.length] : [0, Infinity];\n  const destroyFns = [];\n  for (let i = 0; i < buttons.length; i++) {\n    const prev = buttons[(c + i - 1) % m];\n    const curr = buttons[i];\n    const next = buttons[(c + i + 1) % m];\n    addRemovableEventListener(destroyFns, curr, \"focus\", setTabIndices);\n    if (onFocus)\n      addRemovableEventListener(destroyFns, curr, \"focus\", onFocus);\n    if (onBlur)\n      addRemovableEventListener(destroyFns, curr, \"blur\", onBlur);\n    if (onEscape)\n      addEscapeEventListener(destroyFns, curr, onEscape);\n    linkThreeButtons(destroyFns, curr, prev, prevKey, next, nextKey);\n    curr.tabIndex = i === 0 ? 0 : -1;\n  }\n  return destroyFns;\n}\nvar MenuCloserImp = class {\n  constructor(menu, lastFocus, closeCallback) {\n    this.lastFocus = lastFocus;\n    this.closeCallback = closeCallback;\n    this.destroyFns = [];\n    this.destroyFns.push(addMouseCloseListener(this.destroyFns, menu, () => this.close()));\n  }\n  close() {\n    this.destroyFns.forEach((d) => d());\n    this.destroyFns.length = 0;\n    this.closeCallback();\n    this.finishClosing();\n  }\n  finishClosing() {\n    this.destroyFns.forEach((d) => d());\n    this.destroyFns.length = 0;\n    setAttribute(this.lastFocus, \"aria-expanded\", false);\n    this.lastFocus?.focus();\n    this.lastFocus = void 0;\n  }\n};\nfunction initMenuKeyNav(opts) {\n  const { sourceEvent, orientation, menu, buttons, closeCallback, autoCloseOnBlur = false } = opts;\n  const { nextKey, prevKey } = PREV_NEXT_KEYS[orientation];\n  const lastFocus = getLastFocus(sourceEvent);\n  setAttribute(lastFocus, \"aria-expanded\", true);\n  const menuCloser = new MenuCloserImp(menu, lastFocus, closeCallback);\n  const onEscape = () => menuCloser.close();\n  const { destroyFns } = menuCloser;\n  menu.role = \"menu\";\n  menu.ariaOrientation = orientation;\n  destroyFns.push(...initRovingTabIndex({ orientation, buttons, onEscape, wrapAround: true }));\n  menu.tabIndex = -1;\n  addEscapeEventListener(destroyFns, menu, onEscape);\n  addRemovableEventListener(destroyFns, menu, \"keydown\", (ev) => {\n    if (ev.target === menu && (ev.key === nextKey || ev.key === prevKey)) {\n      ev.preventDefault();\n      buttons[0]?.focus();\n    }\n  });\n  if (autoCloseOnBlur) {\n    const handler = (ev) => {\n      const buttonArray = buttons;\n      const isLeavingMenu = !buttonArray.includes(ev.relatedTarget);\n      if (isLeavingMenu) {\n        onEscape();\n      }\n    };\n    for (const button of buttons) {\n      addRemovableEventListener(destroyFns, button, \"blur\", handler);\n    }\n  }\n  buttons[0]?.focus();\n  return menuCloser;\n}\nfunction makeAccessibleClickListener(element2, onclick) {\n  return (event) => {\n    if (element2.ariaDisabled === \"true\") {\n      return event.preventDefault();\n    }\n    onclick(event);\n  };\n}\nfunction isButtonClickEvent(event) {\n  if (\"button\" in event) {\n    return event.button === 0;\n  }\n  return hasNoModifiers(event) && (event.code === \"Space\" || event.key === \"Enter\");\n}\nfunction getLastFocus(sourceEvent) {\n  if (sourceEvent?.target instanceof HTMLElement && \"tabindex\" in sourceEvent.target.attributes) {\n    return sourceEvent.target;\n  }\n  return void 0;\n}\nfunction stopPageScrolling(element2) {\n  const handler = (event) => {\n    if (event.defaultPrevented)\n      return;\n    const shouldPrevent = getAttribute(event.target, \"data-preventdefault\", true);\n    if (shouldPrevent && matchesKey(event, \"ArrowRight\", \"ArrowLeft\", \"ArrowDown\", \"ArrowUp\")) {\n      event.preventDefault();\n    }\n  };\n  element2.addEventListener(\"keydown\", handler);\n  return () => element2.removeEventListener(\"keydown\", handler);\n}\n\n// packages/ag-charts-community/src/util/sizeMonitor.ts\nvar SizeMonitor = class {\n  constructor() {\n    this.elements = /* @__PURE__ */ new Map();\n    this.documentReady = false;\n    this.queuedObserveRequests = [];\n    this.onLoad = () => {\n      this.documentReady = true;\n      this.queuedObserveRequests.forEach(([el, cb]) => this.observe(el, cb));\n      this.queuedObserveRequests = [];\n    };\n    if (typeof ResizeObserver === \"undefined\")\n      return;\n    this.resizeObserver = new ResizeObserver((entries) => {\n      for (const {\n        target,\n        contentRect: { width: width2, height: height2 }\n      } of entries) {\n        const entry = this.elements.get(target);\n        this.checkSize(entry, target, width2, height2);\n      }\n    });\n    this.documentReady = getDocument(\"readyState\") === \"complete\";\n    if (!this.documentReady) {\n      getWindow()?.addEventListener(\"load\", this.onLoad);\n    }\n  }\n  destroy() {\n    getWindow()?.removeEventListener(\"load\", this.onLoad);\n    this.resizeObserver?.disconnect();\n    this.resizeObserver = null;\n  }\n  checkSize(entry, element2, width2, height2) {\n    if (!entry)\n      return;\n    if (width2 !== entry.size?.width || height2 !== entry.size?.height) {\n      entry.size = { width: width2, height: height2 };\n      entry.cb(entry.size, element2);\n    }\n  }\n  // Only a single callback is supported.\n  observe(element2, cb) {\n    if (!this.documentReady) {\n      this.queuedObserveRequests.push([element2, cb]);\n      return;\n    }\n    if (this.elements.has(element2)) {\n      this.removeFromQueue(element2);\n    } else {\n      this.resizeObserver?.observe(element2);\n    }\n    const entry = { cb };\n    this.elements.set(element2, entry);\n  }\n  unobserve(element2) {\n    this.resizeObserver?.unobserve(element2);\n    this.elements.delete(element2);\n    this.removeFromQueue(element2);\n    if (!this.elements.size) {\n      this.destroy();\n    }\n  }\n  removeFromQueue(element2) {\n    this.queuedObserveRequests = this.queuedObserveRequests.filter(([el]) => el !== element2);\n  }\n};\n\n// packages/ag-charts-community/src/dom/domLayout.html\nvar domLayout_default = '<div role=\"presentation\" class=\"ag-charts-wrapper ag-charts-styles\" data-ag-charts><div role=\"presentation\" class=\"ag-charts-canvas-center\"><div role=\"presentation\" class=\"ag-charts-canvas-container\"><div role=\"presentation\" class=\"ag-charts-canvas\" aria-hidden=\"true\"></div><div role=\"figure\" class=\"ag-charts-canvas-proxy\"><div role=\"img\" class=\"ag-charts-series-area\" tabindex=\"-1\"></div></div><div role=\"presentation\" class=\"ag-charts-canvas-overlay\"></div></div></div></div>';\n\n// packages/ag-charts-community/src/dom/domManager.ts\nvar DOM_ELEMENT_CLASSES = [\n  \"styles\",\n  \"canvas\",\n  \"canvas-center\",\n  \"canvas-overlay\",\n  \"canvas-proxy\",\n  \"series-area\"\n];\nvar domElementConfig = /* @__PURE__ */ new Map([\n  [\"styles\", { childElementType: \"style\" }],\n  [\"canvas\", { childElementType: \"canvas\" }],\n  [\"canvas-proxy\", { childElementType: \"div\" }],\n  [\"canvas-overlay\", { childElementType: \"div\" }],\n  [\"canvas-center\", { childElementType: \"div\" }],\n  [\"series-area\", { childElementType: \"div\" }]\n]);\nfunction setupObserver(element2, cb) {\n  if (typeof IntersectionObserver === \"undefined\")\n    return;\n  const observer = new IntersectionObserver(\n    (entries) => {\n      for (const entry of entries) {\n        if (entry.target === element2) {\n          cb(entry.intersectionRatio);\n        }\n      }\n    },\n    { root: element2 }\n  );\n  observer.observe(element2);\n  return observer;\n}\nvar NULL_DOMRECT = {\n  x: 0,\n  y: 0,\n  width: 0,\n  height: 0,\n  top: 0,\n  bottom: 0,\n  left: 0,\n  right: 0,\n  toJSON() {\n    return NULL_DOMRECT;\n  }\n};\nvar DOMManager = class extends BaseManager {\n  constructor(container, styleContainer) {\n    super();\n    this.styles = /* @__PURE__ */ new Map();\n    this.container = void 0;\n    this.containerSize = void 0;\n    this.sizeMonitor = new SizeMonitor();\n    const templateEl = createElement(\"div\");\n    templateEl.innerHTML = domLayout_default;\n    this.element = templateEl.children.item(0);\n    this.styleRootElement = styleContainer;\n    this.rootElements = DOM_ELEMENT_CLASSES.reduce(\n      (r, c) => {\n        const cssClass = `ag-charts-${c}`;\n        const el = this.element.classList.contains(cssClass) ? this.element : this.element.querySelector(`.${cssClass}`);\n        if (!el)\n          throw new Error(`AG Charts - unable to find DOM element ${cssClass}`);\n        r[c] = { element: el, children: /* @__PURE__ */ new Map(), listeners: [] };\n        return r;\n      },\n      {}\n    );\n    let hidden = false;\n    this.observer = setupObserver(this.element, (intersectionRatio) => {\n      if (intersectionRatio === 0 && !hidden) {\n        this.listeners.dispatch(\"hidden\", { type: \"hidden\" });\n      }\n      hidden = intersectionRatio === 0;\n    });\n    this.setSizeOptions();\n    this.addStyles(\"ag-charts-community\", styles_default);\n    if (container) {\n      this.setContainer(container);\n    }\n    this.destroyFns.push(stopPageScrolling(this.element));\n  }\n  destroy() {\n    super.destroy();\n    this.observer?.unobserve(this.element);\n    if (this.container) {\n      this.sizeMonitor.unobserve(this.container);\n    }\n    Object.values(this.rootElements).forEach((el) => {\n      el.children.forEach((c) => c.remove());\n      el.element.remove();\n    });\n    this.element.remove();\n  }\n  setSizeOptions(minWidth = 300, minHeight = 300, optionsWidth, optionsHeight) {\n    const { style } = this.element;\n    style.width = `${optionsWidth ?? minWidth}px`;\n    style.height = `${optionsHeight ?? minHeight}px`;\n  }\n  updateContainerSize() {\n    const { style: centerStyle } = this.rootElements[\"canvas-center\"].element;\n    centerStyle.width = `${this.containerSize?.width ?? 0}px`;\n    centerStyle.height = `${this.containerSize?.height ?? 0}px`;\n  }\n  setContainer(newContainer) {\n    if (newContainer === this.container)\n      return;\n    if (this.container) {\n      this.container.removeChild(this.element);\n      this.sizeMonitor.unobserve(this.container);\n    }\n    const isShadowDom = this.getShadowDocumentRoot(newContainer) != null;\n    if (!isShadowDom) {\n      for (const id of this.rootElements[\"styles\"].children.keys()) {\n        this.removeChild(\"styles\", id);\n      }\n    }\n    this.container = newContainer;\n    for (const [id, styles] of this.styles) {\n      this.addStyles(id, styles);\n    }\n    newContainer.appendChild(this.element);\n    this.sizeMonitor.observe(newContainer, (size) => {\n      this.containerSize = size;\n      this.updateContainerSize();\n      this.listeners.dispatch(\"resize\", { type: \"resize\" });\n    });\n    this.listeners.dispatch(\"container-changed\", { type: \"container-changed\" });\n  }\n  setThemeClass(themeClassName) {\n    const themeClassNamePrefix = \"ag-charts-theme-\";\n    this.element.classList.forEach((className) => {\n      if (className.startsWith(themeClassNamePrefix) && className !== themeClassName) {\n        this.element.classList.remove(className);\n      }\n    });\n    this.element.classList.add(themeClassName);\n  }\n  setTabIndex(tabIndex) {\n    this.rootElements[\"series-area\"].element.tabIndex = tabIndex;\n  }\n  updateCanvasLabel(ariaLabel) {\n    setAttribute(this.rootElements[\"canvas-proxy\"].element, \"aria-label\", ariaLabel);\n  }\n  getEventElement(defaultElem, eventType) {\n    const events = [\"focus\", \"blur\", \"keydown\", \"keyup\"];\n    return events.includes(eventType) ? this.rootElements[\"series-area\"].element : defaultElem;\n  }\n  addEventListener(type, listener, options) {\n    this.getEventElement(this.element, type).addEventListener(type, listener, options);\n  }\n  removeEventListener(type, listener, options) {\n    this.getEventElement(this.element, type).removeEventListener(type, listener, options);\n  }\n  /** Get the main chart area client bound rect. */\n  getBoundingClientRect() {\n    return this.rootElements[\"canvas\"].element.getBoundingClientRect();\n  }\n  /**\n   * Get the client bounding rect for overlay elements that might float outside the bounds of the\n   * main chart area.\n   */\n  getOverlayClientRect() {\n    const window2 = getWindow();\n    const windowBBox = new BBox(0, 0, window2.innerWidth, window2.innerHeight);\n    const container = this.getRawOverlayClientRect();\n    const containerBBox = BBox.fromDOMRect(container ?? this.getBoundingClientRect());\n    return windowBBox.intersection(containerBBox)?.toDOMRect() ?? NULL_DOMRECT;\n  }\n  getRawOverlayClientRect() {\n    let element2 = this.element;\n    while (element2 != null) {\n      const styleMap = element2.computedStyleMap?.();\n      const overflowX = styleMap?.get(\"overflow-x\")?.toString();\n      const overflowY = styleMap?.get(\"overflow-y\")?.toString();\n      if (overflowX != null && overflowX !== \"visible\" || overflowY && overflowY !== \"visible\") {\n        return element2.getBoundingClientRect();\n      }\n      element2 = element2.parentElement;\n    }\n    const docRoot = this.getShadowDocumentRoot();\n    if (docRoot) {\n      return docRoot.getBoundingClientRect();\n    }\n  }\n  getShadowDocumentRoot(current = this.container) {\n    const docRoot = current?.ownerDocument?.body ?? getDocument(\"body\");\n    while (current != null) {\n      if (current === docRoot) {\n        return void 0;\n      }\n      if (current.parentNode instanceof DocumentFragment) {\n        return current;\n      }\n      current = current.parentNode;\n    }\n    return this.container;\n  }\n  getChildBoundingClientRect(type) {\n    const { children } = this.rootElements[type];\n    const childRects = [];\n    for (const child of children.values()) {\n      childRects.push(BBox.fromDOMRect(child.getBoundingClientRect()));\n    }\n    return BBox.merge(childRects);\n  }\n  calculateCanvasPosition(el) {\n    let x = 0;\n    let y = 0;\n    const { x: cx = 0, y: cy = 0 } = this.getChildBoundingClientRect(\"canvas\") ?? {};\n    const elRect = el.getBoundingClientRect();\n    x = elRect.x - cx;\n    y = elRect.y - cy;\n    return { x, y };\n  }\n  isManagedChildDOMElement(el, domElementClass, id) {\n    const { children } = this.rootElements[domElementClass];\n    const search = children?.get(id);\n    return search != null && el.contains(search);\n  }\n  isEventOverElement(event) {\n    const element2 = event.target;\n    return element2 != null && this.element.contains(element2);\n  }\n  addStyles(id, styles) {\n    const dataAttribute = \"data-ag-charts\";\n    this.styles.set(id, styles);\n    if (this.container == null)\n      return;\n    const checkId = (el) => {\n      return el.getAttribute(dataAttribute) === id;\n    };\n    const addStyleElement = (el) => {\n      for (const child of el.children) {\n        if (checkId(child))\n          return;\n      }\n      const styleEl = createElement(\"style\");\n      el.appendChild(styleEl);\n      return styleEl;\n    };\n    let styleElement;\n    if (this.styleRootElement) {\n      styleElement = addStyleElement(this.styleRootElement);\n    } else {\n      const documentRoot = this.getShadowDocumentRoot(this.container);\n      if (documentRoot != null) {\n        styleElement = this.addChild(\"styles\", id);\n      } else {\n        styleElement = addStyleElement(getDocument(\"head\"));\n      }\n    }\n    if (styleElement == null || checkId(styleElement))\n      return;\n    styleElement.setAttribute(dataAttribute, id);\n    styleElement.innerHTML = styles;\n  }\n  removeStyles(id) {\n    this.removeChild(\"styles\", id);\n  }\n  updateCursor(style) {\n    this.element.style.cursor = style;\n  }\n  getCursor() {\n    return this.element.style.cursor;\n  }\n  addChild(domElementClass, id, child, insert) {\n    const { element: element2, children, listeners } = this.rootElements[domElementClass];\n    if (!children) {\n      throw new Error(\"AG Charts - unable to create DOM elements after destroy()\");\n    }\n    if (children.has(id)) {\n      return children.get(id);\n    }\n    const { childElementType = \"div\" } = domElementConfig.get(domElementClass) ?? {};\n    if (child && child.tagName.toLowerCase() !== childElementType.toLowerCase()) {\n      throw new Error(\"AG Charts - mismatching DOM element type\");\n    }\n    const newChild = child ?? createElement(childElementType);\n    for (const [type, fn, opts] of listeners) {\n      newChild.addEventListener(type, fn, opts);\n    }\n    children.set(id, newChild);\n    if (insert) {\n      const queryResult = element2.querySelector(insert.query);\n      if (queryResult == null) {\n        throw new Error(`AG Charts - addChild query failed ${insert.query}`);\n      }\n      queryResult.insertAdjacentElement(insert.where, newChild);\n    } else {\n      element2?.appendChild(newChild);\n    }\n    return newChild;\n  }\n  removeChild(domElementClass, id) {\n    const { children } = this.rootElements[domElementClass];\n    if (!children)\n      return;\n    children.get(id)?.remove();\n    children.delete(id);\n  }\n  incrementDataCounter(name) {\n    const { dataset } = this.element;\n    dataset[name] ?? (dataset[name] = \"0\");\n    dataset[name] = String(Number(dataset[name]) + 1);\n  }\n  setDataBoolean(name, value) {\n    this.element.dataset[name] = String(value);\n  }\n  getIconClassNames(icon) {\n    return `ag-charts-icon ag-charts-icon-${icon}`;\n  }\n};\n\n// packages/ag-charts-community/src/scene/polyRoots.ts\nfunction linearRoot(a, b) {\n  const t = -b / a;\n  return a !== 0 && t >= 0 && t <= 1 ? [t] : [];\n}\nfunction quadraticRoots(a, b, c) {\n  if (a === 0) {\n    return linearRoot(b, c);\n  }\n  const D = b * b - 4 * a * c;\n  const roots = [];\n  if (D === 0) {\n    const t = -b / (2 * a);\n    if (t >= 0 && t <= 1) {\n      roots.push(t);\n    }\n  } else if (D > 0) {\n    const rD = Math.sqrt(D);\n    const t1 = (-b - rD) / (2 * a);\n    const t2 = (-b + rD) / (2 * a);\n    if (t1 >= 0 && t1 <= 1) {\n      roots.push(t1);\n    }\n    if (t2 >= 0 && t2 <= 1) {\n      roots.push(t2);\n    }\n  }\n  return roots;\n}\nfunction cubicRoots(a, b, c, d) {\n  if (a === 0) {\n    return quadraticRoots(b, c, d);\n  }\n  const A = b / a;\n  const B = c / a;\n  const C = d / a;\n  const Q = (3 * B - A * A) / 9;\n  const R = (9 * A * B - 27 * C - 2 * A * A * A) / 54;\n  const D = Q * Q * Q + R * R;\n  const third = 1 / 3;\n  const roots = [];\n  if (D >= 0) {\n    const rD = Math.sqrt(D);\n    const S = Math.sign(R + rD) * Math.pow(Math.abs(R + rD), third);\n    const T = Math.sign(R - rD) * Math.pow(Math.abs(R - rD), third);\n    const Im = Math.abs(Math.sqrt(3) * (S - T) / 2);\n    const t = -third * A + (S + T);\n    if (t >= 0 && t <= 1) {\n      roots.push(t);\n    }\n    if (Im === 0) {\n      const t2 = -third * A - (S + T) / 2;\n      if (t2 >= 0 && t2 <= 1) {\n        roots.push(t2);\n      }\n    }\n  } else {\n    const theta = Math.acos(R / Math.sqrt(-Q * Q * Q));\n    const thirdA = third * A;\n    const twoSqrtQ = 2 * Math.sqrt(-Q);\n    const t1 = twoSqrtQ * Math.cos(third * theta) - thirdA;\n    const t2 = twoSqrtQ * Math.cos(third * (theta + 2 * Math.PI)) - thirdA;\n    const t3 = twoSqrtQ * Math.cos(third * (theta + 4 * Math.PI)) - thirdA;\n    if (t1 >= 0 && t1 <= 1) {\n      roots.push(t1);\n    }\n    if (t2 >= 0 && t2 <= 1) {\n      roots.push(t2);\n    }\n    if (t3 >= 0 && t3 <= 1) {\n      roots.push(t3);\n    }\n  }\n  return roots;\n}\n\n// packages/ag-charts-community/src/scene/intersection.ts\nfunction segmentIntersection(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {\n  const d = (ax2 - ax1) * (by2 - by1) - (ay2 - ay1) * (bx2 - bx1);\n  if (d === 0) {\n    return 0;\n  }\n  const ua = ((bx2 - bx1) * (ay1 - by1) - (ax1 - bx1) * (by2 - by1)) / d;\n  const ub = ((ax2 - ax1) * (ay1 - by1) - (ay2 - ay1) * (ax1 - bx1)) / d;\n  if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {\n    return 1;\n  }\n  return 0;\n}\nfunction cubicSegmentIntersections(px1, py1, px2, py2, px3, py3, px4, py4, x1, y1, x2, y2) {\n  let intersections = 0;\n  const A = y1 - y2;\n  const B = x2 - x1;\n  const C = x1 * (y2 - y1) - y1 * (x2 - x1);\n  const bx = bezierCoefficients(px1, px2, px3, px4);\n  const by = bezierCoefficients(py1, py2, py3, py4);\n  const a = A * bx[0] + B * by[0];\n  const b = A * bx[1] + B * by[1];\n  const c = A * bx[2] + B * by[2];\n  const d = A * bx[3] + B * by[3] + C;\n  const roots = cubicRoots(a, b, c, d);\n  for (const t of roots) {\n    const tt = t * t;\n    const ttt = t * tt;\n    const x = bx[0] * ttt + bx[1] * tt + bx[2] * t + bx[3];\n    const y = by[0] * ttt + by[1] * tt + by[2] * t + by[3];\n    let s;\n    if (x1 === x2) {\n      s = (y - y1) / (y2 - y1);\n    } else {\n      s = (x - x1) / (x2 - x1);\n    }\n    if (s >= 0 && s <= 1) {\n      intersections++;\n    }\n  }\n  return intersections;\n}\nfunction bezierCoefficients(P1, P2, P3, P4) {\n  return [\n    // Bézier expressed as matrix operations:\n    -P1 + 3 * P2 - 3 * P3 + P4,\n    //                 |-1  3 -3  1| |P1|\n    3 * P1 - 6 * P2 + 3 * P3,\n    //   [t^3 t^2 t 1] | 3 -6  3  0| |P2|\n    -3 * P1 + 3 * P2,\n    //                 |-3  3  0  0| |P3|\n    P1\n    //                 | 1  0  0  0| |P4|\n  ];\n}\nfunction arcIntersections(cx, cy, r, startAngle, endAngle, counterClockwise, x1, y1, x2, y2) {\n  if (isNaN(cx) || isNaN(cy)) {\n    return 0;\n  }\n  if (counterClockwise) {\n    [endAngle, startAngle] = [startAngle, endAngle];\n  }\n  const k = (y2 - y1) / (x2 - x1);\n  const y0 = y1 - k * x1;\n  const a = Math.pow(k, 2) + 1;\n  const b = 2 * (k * (y0 - cy) - cx);\n  const c = Math.pow(cx, 2) + Math.pow(y0 - cy, 2) - Math.pow(r, 2);\n  const d = Math.pow(b, 2) - 4 * a * c;\n  if (d < 0) {\n    return 0;\n  }\n  const i1x = (-b + Math.sqrt(d)) / 2 / a;\n  const i2x = (-b - Math.sqrt(d)) / 2 / a;\n  let intersections = 0;\n  [i1x, i2x].forEach((x) => {\n    const isXInsideLine = x >= Math.min(x1, x2) && x <= Math.max(x1, x2);\n    if (!isXInsideLine) {\n      return;\n    }\n    const y = k * x + y0;\n    const adjacent = x - cx;\n    const opposite = y - cy;\n    const angle2 = Math.atan2(opposite, adjacent);\n    if (isBetweenAngles(angle2, startAngle, endAngle)) {\n      intersections++;\n    }\n  });\n  return intersections;\n}\n\n// packages/ag-charts-community/src/scene/util/bezier.ts\nfunction evaluateBezier(p0, p1, p2, p3, t) {\n  return (1 - t) ** 3 * p0 + 3 * (1 - t) ** 2 * t * p1 + 3 * (1 - t) * t ** 2 * p2 + t ** 3 * p3;\n}\nfunction solveBezier(p0, p1, p2, p3, value) {\n  if (value <= Math.min(p0, p3)) {\n    return p0 < p3 ? 0 : 1;\n  } else if (value >= Math.max(p0, p3)) {\n    return p0 < p3 ? 1 : 0;\n  }\n  let t0 = 0;\n  let t1 = 1;\n  let t = NaN;\n  for (let i = 0; i < 12; i += 1) {\n    t = (t0 + t1) / 2;\n    const curveValue = evaluateBezier(p0, p1, p2, p3, t);\n    if (curveValue < value) {\n      t0 = t;\n    } else {\n      t1 = t;\n    }\n  }\n  return t;\n}\nfunction splitBezier(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y, t) {\n  const x01 = (1 - t) * p0x + t * p1x;\n  const y01 = (1 - t) * p0y + t * p1y;\n  const x12 = (1 - t) * p1x + t * p2x;\n  const y12 = (1 - t) * p1y + t * p2y;\n  const x23 = (1 - t) * p2x + t * p3x;\n  const y23 = (1 - t) * p2y + t * p3y;\n  const x012 = (1 - t) * x01 + t * x12;\n  const y012 = (1 - t) * y01 + t * y12;\n  const x123 = (1 - t) * x12 + t * x23;\n  const y123 = (1 - t) * y12 + t * y23;\n  const x0123 = (1 - t) * x012 + t * x123;\n  const y0123 = (1 - t) * y012 + t * y123;\n  return [\n    [\n      { x: p0x, y: p0y },\n      { x: x01, y: y01 },\n      { x: x012, y: y012 },\n      { x: x0123, y: y0123 }\n    ],\n    [\n      { x: x0123, y: y0123 },\n      { x: x123, y: y123 },\n      { x: x23, y: y23 },\n      { x: p3x, y: p3y }\n    ]\n  ];\n}\nfunction calculateDerivativeExtrema(p0, p1, p2, p3) {\n  const a = -p0 + 3 * p1 - 3 * p2 + p3;\n  const b = 3 * p0 - 6 * p1 + 3 * p2;\n  const c = -3 * p0 + 3 * p1;\n  if (a === 0) {\n    if (b !== 0) {\n      const t = -c / b;\n      if (t > 0 && t < 1) {\n        return [t];\n      }\n    }\n    return [];\n  }\n  const discriminant = b * b - 4 * a * c;\n  if (discriminant >= 0) {\n    const sqrtDiscriminant = Math.sqrt(discriminant);\n    const t1 = (-b + sqrtDiscriminant) / (2 * a);\n    const t2 = (-b - sqrtDiscriminant) / (2 * a);\n    return [t1, t2].filter((t) => t > 0 && t < 1);\n  }\n  return [];\n}\nfunction calculateDerivativeExtremaXY(sx, sy, cp1x, cp1y, cp2x, cp2y, x, y) {\n  const tx = calculateDerivativeExtrema(sx, cp1x, cp2x, x);\n  const ty = calculateDerivativeExtrema(sy, cp1y, cp2y, y);\n  return [...tx, ...ty];\n}\n\n// packages/ag-charts-community/src/scene/extendedPath2D.ts\nvar ExtendedPath2D = class {\n  constructor() {\n    // The methods of this class will likely be called many times per animation frame,\n    // and any allocation can trigger a GC cycle during animation, so we attempt\n    // to minimize the number of allocations.\n    this.path2d = new Path2D();\n    this.previousCommands = [];\n    this.previousParams = [];\n    this.previousClosedPath = false;\n    this.commands = [];\n    this.params = [];\n    this.openedPath = false;\n    this.closedPath = false;\n  }\n  isDirty() {\n    return this.closedPath !== this.previousClosedPath || this.previousCommands.length !== this.commands.length || this.previousParams.length !== this.params.length || this.previousCommands.toString() !== this.commands.toString() || this.previousParams.toString() !== this.params.toString();\n  }\n  getPath2D() {\n    return this.path2d;\n  }\n  moveTo(x, y) {\n    this.openedPath = true;\n    this.path2d.moveTo(x, y);\n    this.commands.push(0 /* Move */);\n    this.params.push(x, y);\n  }\n  lineTo(x, y) {\n    if (this.openedPath) {\n      this.path2d.lineTo(x, y);\n      this.commands.push(1 /* Line */);\n      this.params.push(x, y);\n    } else {\n      this.moveTo(x, y);\n    }\n  }\n  rect(x, y, width2, height2) {\n    this.moveTo(x, y);\n    this.lineTo(x + width2, y);\n    this.lineTo(x + width2, y + height2);\n    this.lineTo(x, y + height2);\n    this.closePath();\n  }\n  roundRect(x, y, width2, height2, radii) {\n    radii = Math.min(radii, width2 / 2, height2 / 2);\n    this.moveTo(x, y + radii);\n    this.arc(x + radii, y + radii, radii, Math.PI, 1.5 * Math.PI);\n    this.lineTo(x + radii, y);\n    this.lineTo(x + width2 - radii, y);\n    this.arc(x + width2 - radii, y + radii, radii, 1.5 * Math.PI, 2 * Math.PI);\n    this.lineTo(x + width2, y + radii);\n    this.lineTo(x + width2, y + height2 - radii);\n    this.arc(x + width2 - radii, y + height2 - radii, radii, 0, Math.PI / 2);\n    this.lineTo(x + width2 - radii, y + height2);\n    this.lineTo(x + radii, y + height2);\n    this.arc(x + +radii, y + height2 - radii, radii, Math.PI / 2, Math.PI);\n    this.lineTo(x, y + height2 - radii);\n    this.closePath();\n  }\n  arc(x, y, r, sAngle, eAngle, counterClockwise) {\n    this.openedPath = true;\n    this.path2d.arc(x, y, r, sAngle, eAngle, counterClockwise);\n    this.commands.push(2 /* Arc */);\n    this.params.push(x, y, r, sAngle, eAngle, counterClockwise ? 1 : 0);\n  }\n  cubicCurveTo(cx1, cy1, cx2, cy2, x, y) {\n    if (!this.openedPath) {\n      this.moveTo(cx1, cy1);\n    }\n    this.path2d.bezierCurveTo(cx1, cy1, cx2, cy2, x, y);\n    this.commands.push(3 /* Curve */);\n    this.params.push(cx1, cy1, cx2, cy2, x, y);\n  }\n  closePath() {\n    if (this.openedPath) {\n      this.path2d.closePath();\n      this.commands.push(4 /* ClosePath */);\n      this.openedPath = false;\n      this.closedPath = true;\n    }\n  }\n  clear(trackChanges) {\n    if (trackChanges) {\n      this.previousCommands = this.commands;\n      this.previousParams = this.params;\n      this.previousClosedPath = this.closedPath;\n    }\n    this.path2d = new Path2D();\n    this.openedPath = false;\n    this.closedPath = false;\n    this.commands = [];\n    this.params = [];\n  }\n  isPointInPath(x, y) {\n    const commands = this.commands;\n    const params = this.params;\n    const cn = commands.length;\n    const ox = -1e4;\n    const oy = -1e4;\n    let sx = NaN;\n    let sy = NaN;\n    let px = 0;\n    let py = 0;\n    let intersectionCount = 0;\n    for (let ci = 0, pi = 0; ci < cn; ci++) {\n      switch (commands[ci]) {\n        case 0 /* Move */:\n          intersectionCount += segmentIntersection(sx, sy, px, py, ox, oy, x, y);\n          px = params[pi++];\n          sx = px;\n          py = params[pi++];\n          sy = py;\n          break;\n        case 1 /* Line */:\n          intersectionCount += segmentIntersection(px, py, params[pi++], params[pi++], ox, oy, x, y);\n          px = params[pi - 2];\n          py = params[pi - 1];\n          break;\n        case 3 /* Curve */:\n          intersectionCount += cubicSegmentIntersections(\n            px,\n            py,\n            params[pi++],\n            params[pi++],\n            params[pi++],\n            params[pi++],\n            params[pi++],\n            params[pi++],\n            ox,\n            oy,\n            x,\n            y\n          );\n          px = params[pi - 2];\n          py = params[pi - 1];\n          break;\n        case 2 /* Arc */: {\n          const cx = params[pi++];\n          const cy = params[pi++];\n          const r = params[pi++];\n          const startAngle = params[pi++];\n          const endAngle = params[pi++];\n          const counterClockwise = Boolean(params[pi++]);\n          intersectionCount += arcIntersections(\n            cx,\n            cy,\n            r,\n            startAngle,\n            endAngle,\n            counterClockwise,\n            ox,\n            oy,\n            x,\n            y\n          );\n          if (!isNaN(sx)) {\n            const startX = cx + Math.cos(startAngle) * r;\n            const startY = cy + Math.sin(startAngle) * r;\n            intersectionCount += segmentIntersection(px, py, startX, startY, ox, oy, x, y);\n          }\n          px = cx + Math.cos(endAngle) * r;\n          py = cy + Math.sin(endAngle) * r;\n          break;\n        }\n        case 4 /* ClosePath */:\n          intersectionCount += segmentIntersection(sx, sy, px, py, ox, oy, x, y);\n          break;\n      }\n    }\n    return intersectionCount % 2 === 1;\n  }\n  distanceSquared(x, y) {\n    let best = Infinity;\n    const commands = this.commands;\n    const params = this.params;\n    const cn = commands.length;\n    let sx = NaN;\n    let sy = NaN;\n    let px = 0;\n    let py = 0;\n    for (let ci = 0, pi = 0; ci < cn; ci++) {\n      switch (commands[ci]) {\n        case 0 /* Move */:\n          px = sx = params[pi++];\n          py = sy = params[pi++];\n          break;\n        case 1 /* Line */: {\n          const nx = params[pi++];\n          const ny = params[pi++];\n          best = lineDistanceSquared(x, y, px, py, nx, ny, best);\n          break;\n        }\n        case 3 /* Curve */:\n          Logger.error(\"Command.Curve distanceSquare not implemented\");\n          break;\n        case 2 /* Arc */: {\n          const cx = params[pi++];\n          const cy = params[pi++];\n          const r = params[pi++];\n          const startAngle = params[pi++];\n          const endAngle = params[pi++];\n          const startX = cx + Math.cos(startAngle) * r;\n          const startY = cy + Math.sin(startAngle) * r;\n          const counterClockwise = Boolean(params[pi++]);\n          best = lineDistanceSquared(x, y, px, py, startX, startY, best);\n          best = arcDistanceSquared(x, y, cx, cy, r, startAngle, endAngle, counterClockwise, best);\n          px = cx + Math.cos(endAngle) * r;\n          py = cy + Math.sin(endAngle) * r;\n          break;\n        }\n        case 4 /* ClosePath */:\n          best = lineDistanceSquared(x, y, px, py, sx, sy, best);\n          break;\n      }\n    }\n    return best;\n  }\n  getPoints() {\n    const { commands, params } = this;\n    const coords = [];\n    let pi = 0;\n    for (const command of commands) {\n      switch (command) {\n        case 0 /* Move */:\n        case 1 /* Line */:\n          coords.push({ x: params[pi++], y: params[pi++] });\n          break;\n        case 3 /* Curve */:\n          pi += 4;\n          coords.push({ x: params[pi++], y: params[pi++] });\n          break;\n        case 2 /* Arc */:\n          coords.push({ x: params[pi++], y: params[pi++] });\n          pi += 4;\n          break;\n        case 4 /* ClosePath */:\n          break;\n      }\n    }\n    return coords;\n  }\n  // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d\n  toSVG(transform = (x, y) => ({ x, y })) {\n    const buffer = [];\n    const { commands, params } = this;\n    const addCommand = (command, ...points) => {\n      buffer.push(command);\n      for (let i = 0; i < points.length; i += 2) {\n        const { x, y } = transform(points[i], points[i + 1]);\n        buffer.push(x, y);\n      }\n    };\n    let pi = 0;\n    for (const command of commands) {\n      switch (command) {\n        case 0 /* Move */:\n          addCommand(\"M\", params[pi++], params[pi++]);\n          break;\n        case 1 /* Line */:\n          addCommand(\"L\", params[pi++], params[pi++]);\n          break;\n        case 3 /* Curve */:\n          addCommand(\"C\", params[pi++], params[pi++], params[pi++], params[pi++], params[pi++], params[pi++]);\n          break;\n        case 2 /* Arc */: {\n          const cx = params[pi++];\n          const cy = params[pi++];\n          const r = params[pi++];\n          const A0 = params[pi++];\n          const A1 = params[pi++];\n          const ccw = params[pi++];\n          let sweep = ccw ? A0 - A1 : A1 - A0;\n          if (sweep < 0) {\n            sweep += Math.ceil(-sweep / (2 * Math.PI)) * 2 * Math.PI;\n          }\n          if (ccw) {\n            sweep = -sweep;\n          }\n          const arcSections = Math.max(Math.ceil(Math.abs(sweep) / (Math.PI / 2)), 1);\n          const step = sweep / arcSections;\n          const h = 4 / 3 * Math.tan(step / 4);\n          const move = buffer.length === 0 ? \"M\" : \"L\";\n          addCommand(move, cx + Math.cos(A0) * r, cy + Math.sin(A0) * r);\n          for (let i = 0; i < arcSections; i += 1) {\n            const a0 = A0 + step * (i + 0);\n            const a1 = A0 + step * (i + 1);\n            const rSinStart = r * Math.sin(a0);\n            const rCosStart = r * Math.cos(a0);\n            const rSinEnd = r * Math.sin(a1);\n            const rCosEnd = r * Math.cos(a1);\n            addCommand(\n              \"C\",\n              cx + rCosStart - h * rSinStart,\n              cy + rSinStart + h * rCosStart,\n              cx + rCosEnd + h * rSinEnd,\n              cy + rSinEnd - h * rCosEnd,\n              cx + rCosEnd,\n              cy + rSinEnd\n            );\n          }\n          break;\n        }\n        case 4 /* ClosePath */:\n          buffer.push(\"Z\");\n          break;\n      }\n    }\n    return buffer.join(\" \");\n  }\n  computeBBox() {\n    const { commands, params } = this;\n    let [top, left, right, bot] = [Infinity, Infinity, -Infinity, -Infinity];\n    let [sx, sy] = [NaN, NaN];\n    let [mx, my] = [NaN, NaN];\n    const joinPoint = (x, y, updatestart) => {\n      top = Math.min(y, top);\n      left = Math.min(x, left);\n      right = Math.max(x, right);\n      bot = Math.max(y, bot);\n      if (updatestart) {\n        [sx, sy] = [x, y];\n      }\n    };\n    let pi = 0;\n    for (const command of commands) {\n      switch (command) {\n        case 0 /* Move */:\n          joinPoint(params[pi++], params[pi++], true);\n          [mx, my] = [sx, sy];\n          break;\n        case 1 /* Line */:\n          joinPoint(params[pi++], params[pi++], true);\n          break;\n        case 3 /* Curve */: {\n          const cp1x = params[pi++];\n          const cp1y = params[pi++];\n          const cp2x = params[pi++];\n          const cp2y = params[pi++];\n          const x = params[pi++];\n          const y = params[pi++];\n          joinPoint(x, y, true);\n          const Ts = calculateDerivativeExtremaXY(sx, sy, cp1x, cp1y, cp2x, cp2y, x, y);\n          Ts.forEach((t) => {\n            const px = evaluateBezier(sx, cp1x, cp2x, x, t);\n            const py = evaluateBezier(sy, cp1y, cp2y, y, t);\n            joinPoint(px, py);\n          });\n          break;\n        }\n        case 2 /* Arc */: {\n          const cx = params[pi++];\n          const cy = params[pi++];\n          const r = params[pi++];\n          let A0 = normalizeAngle360(params[pi++]);\n          let A1 = normalizeAngle360(params[pi++]);\n          const ccw = params[pi++];\n          if (ccw) {\n            [A0, A1] = [A1, A0];\n          }\n          const joinAngle = (angle2, updatestart) => {\n            const px = cx + r * Math.cos(angle2);\n            const py = cy + r * Math.sin(angle2);\n            joinPoint(px, py, updatestart);\n          };\n          joinAngle(A0);\n          joinAngle(A1, true);\n          const criticalAngles = [0, Math.PI / 2, Math.PI, 3 * Math.PI / 2];\n          for (const crit of criticalAngles) {\n            if (A0 < A1 && A0 <= crit && crit <= A1 || A0 > A1 && (A0 <= crit || crit <= A1)) {\n              joinAngle(crit);\n            }\n          }\n          break;\n        }\n        case 4 /* ClosePath */:\n          [sx, sy] = [mx, my];\n          break;\n      }\n    }\n    return new BBox(left, top, right - left, bot - top);\n  }\n};\n\n// packages/ag-charts-community/src/scene/shape/path.ts\nfunction ScenePathChangeDetection(opts) {\n  const { redraw = 3 /* MAJOR */, changeCb, convertor } = opts ?? {};\n  return SceneChangeDetection({ redraw, type: \"path\", convertor, changeCb });\n}\nvar Path = class extends Shape {\n  constructor() {\n    super(...arguments);\n    /**\n     * Declare a path to retain for later rendering and hit testing\n     * using custom Path2D class. Think of it as a TypeScript version\n     * of the native Path2D (with some differences) that works in all browsers.\n     */\n    this.path = new ExtendedPath2D();\n    this._clipX = NaN;\n    this._clipY = NaN;\n    this.clip = false;\n    /**\n     * The path only has to be updated when certain attributes change.\n     * For example, if transform attributes (such as `translationX`)\n     * are changed, we don't have to update the path. The `dirtyPath` flag\n     * is how we keep track if the path has to be updated or not.\n     */\n    this._dirtyPath = true;\n  }\n  set clipX(value) {\n    this._clipX = value;\n    this.dirtyPath = true;\n  }\n  set clipY(value) {\n    this._clipY = value;\n    this.dirtyPath = true;\n  }\n  set dirtyPath(value) {\n    if (this._dirtyPath !== value) {\n      this._dirtyPath = value;\n      if (value) {\n        this.markDirty(3 /* MAJOR */);\n      }\n    }\n  }\n  get dirtyPath() {\n    return this._dirtyPath;\n  }\n  checkPathDirty() {\n    if (this._dirtyPath) {\n      return;\n    }\n    this.dirtyPath = this.path.isDirty() || (this.fillShadow?.isDirty() ?? false) || (this._clipPath?.isDirty() ?? false);\n  }\n  isPointInPath(x, y) {\n    this.updatePathIfDirty();\n    return this.path.closedPath && this.path.isPointInPath(x, y);\n  }\n  distanceSquared(x, y) {\n    return this.distanceSquaredTransformedPoint(x, y);\n  }\n  svgPathData(transform) {\n    if (this.dirtyPath) {\n      this.updatePath();\n      this.dirtyPath = false;\n    }\n    return this.path.toSVG(transform);\n  }\n  distanceSquaredTransformedPoint(x, y) {\n    this.updatePathIfDirty();\n    if (this.path.closedPath && this.path.isPointInPath(x, y)) {\n      return 0;\n    }\n    return this.path.distanceSquared(x, y);\n  }\n  isDirtyPath() {\n    return false;\n  }\n  updatePath() {\n  }\n  updatePathIfDirty() {\n    if (this.dirtyPath || this.isDirtyPath()) {\n      this.updatePath();\n      this.dirtyPath = false;\n    }\n  }\n  preRender() {\n    this.updatePathIfDirty();\n    return super.preRender();\n  }\n  render(renderCtx) {\n    const { ctx, forceRender, stats } = renderCtx;\n    if (this.dirty === 0 /* NONE */ && !forceRender) {\n      if (stats)\n        stats.nodesSkipped += nodeCount(this).count;\n      return;\n    }\n    if (this.clip && !isNaN(this._clipX) && !isNaN(this._clipY)) {\n      ctx.save();\n      const margin = this.strokeWidth / 2;\n      this._clipPath ?? (this._clipPath = new ExtendedPath2D());\n      this._clipPath.clear();\n      this._clipPath.rect(-margin, -margin, this._clipX + margin, this._clipY + margin + margin);\n      ctx.clip(this._clipPath?.getPath2D());\n      if (this._clipX > 0 && this._clipY > 0) {\n        this.drawPath(ctx);\n      }\n      ctx.restore();\n    } else {\n      this._clipPath = void 0;\n      this.drawPath(ctx);\n    }\n    this.fillShadow?.markClean();\n    super.render(renderCtx);\n  }\n  drawPath(ctx) {\n    this.fillStroke(ctx, this.path.getPath2D());\n  }\n  toSVG() {\n    if (!this.visible)\n      return;\n    const element2 = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n    element2.setAttribute(\"d\", this.svgPathData());\n    element2.setAttribute(\"fill\", typeof this.fill === \"string\" ? this.fill : \"none\");\n    element2.setAttribute(\"fill-opacity\", String(this.fillOpacity));\n    if (this.stroke != null) {\n      element2.setAttribute(\"stroke\", this.stroke);\n      element2.setAttribute(\"stroke-opacity\", String(this.strokeOpacity));\n      element2.setAttribute(\"stroke-width\", String(this.strokeWidth));\n    }\n    return {\n      elements: [element2]\n    };\n  }\n};\nPath.className = \"Path\";\n__decorateClass([\n  ScenePathChangeDetection()\n], Path.prototype, \"clip\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Path.prototype, \"clipX\", 1);\n__decorateClass([\n  ScenePathChangeDetection()\n], Path.prototype, \"clipY\", 1);\n\n// packages/ag-charts-community/src/dom/focusIndicator.ts\nvar FOCUS_INDICATOR_CSS_CLASS = \"ag-charts-focus-indicator\";\nvar FocusIndicator = class {\n  constructor(domManager) {\n    this.domManager = domManager;\n    this.div = getDocument().createElement(\"div\");\n    this.svg = getDocument().createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n    this.path = getDocument().createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n    this.svg.append(this.path);\n    this.element = domManager.addChild(\"series-area\", FOCUS_INDICATOR_CSS_CLASS);\n    this.element.classList.add(FOCUS_INDICATOR_CSS_CLASS);\n    this.element.ariaHidden = \"true\";\n    this.element.append(this.svg);\n  }\n  destroy() {\n    this.domManager.removeStyles(FOCUS_INDICATOR_CSS_CLASS);\n    this.domManager.removeChild(\"series-area\", FOCUS_INDICATOR_CSS_CLASS);\n  }\n  updateBounds(bounds) {\n    if (bounds === void 0) {\n    } else if (bounds instanceof Path) {\n      const transform = (x, y) => Transformable.toCanvasPoint(bounds, x, y);\n      this.path.setAttribute(\"d\", bounds.svgPathData(transform));\n      this.show(this.svg);\n    } else {\n      setElementBBox(this.div, bounds);\n      this.show(this.div);\n    }\n  }\n  show(child) {\n    this.element.innerHTML = \"\";\n    this.element.append(child);\n  }\n  getFocusableElement() {\n    const focusable = this.element.parentElement;\n    if (focusable == null || focusable.tabIndex !== 0 && focusable.tabIndex !== -1)\n      throw new Error(\"AG Charts - the focus indicator must be a child of a focusable element\");\n    return focusable;\n  }\n  // Use with caution! The focus must be visible when using the keyboard.\n  overrideFocusVisible(focusVisible) {\n    const opacity = { true: \"1\", false: \"0\", undefined: \"\" };\n    this.getFocusableElement().style.setProperty(\"opacity\", opacity[`${focusVisible}`]);\n  }\n  // Get the `:focus-visible` CSS state.\n  isFocusVisible() {\n    const focusable = this.getFocusableElement();\n    return focusable != null && getWindow().getComputedStyle(focusable).opacity === \"1\";\n  }\n};\n\n// packages/ag-charts-community/src/dom/boundedText.ts\nvar BoundedText = class {\n  set textContent(text) {\n    this.textElement.textContent = text;\n    const bboxCalculator = this.textElement;\n    const bbox = bboxCalculator.getBBox?.();\n    if (bbox) {\n      this.svgElement.setAttribute(\"viewBox\", `${bbox.x} ${bbox.y} ${bbox.width} ${bbox.height}`);\n    }\n  }\n  get textContent() {\n    return this.textElement.textContent;\n  }\n  constructor() {\n    this.textElement = createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n    this.textElement.role = \"presentation\";\n    this.svgElement = createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n    this.svgElement.appendChild(this.textElement);\n    this.svgElement.style.width = \"100%\";\n    this.svgElement.style.opacity = \"0\";\n    this.svgElement.role = \"presentation\";\n    this.boundedContainer = createElement(\"div\");\n    this.boundedContainer.appendChild(this.svgElement);\n    this.boundedContainer.role = \"presentation\";\n  }\n  remove() {\n    this.boundedContainer.remove();\n  }\n  getContainer() {\n    return this.boundedContainer;\n  }\n  updateBounds(bounds) {\n    setElementBBox(this.boundedContainer, bounds);\n  }\n};\n\n// packages/ag-charts-community/src/dom/proxyInteractionService.ts\nfunction checkType(type, meta) {\n  return meta.params?.type === type;\n}\nfunction allocateResult(type) {\n  if (\"button\" === type) {\n    return createElement(\"button\");\n  } else if (\"slider\" === type) {\n    return createElement(\"input\");\n  } else if ([\"toolbar\", \"group\", \"list\"].includes(type)) {\n    return createElement(\"div\");\n  } else if (\"text\" === type) {\n    return new BoundedText();\n  } else if (\"listswitch\" === type) {\n    return { button: createElement(\"button\"), listitem: createElement(\"div\") };\n  } else {\n    throw Error(\"AG Charts - error allocating meta\");\n  }\n}\nfunction allocateMeta(params) {\n  const meta = { params, result: void 0 };\n  meta.result = allocateResult(meta.params.type);\n  return meta;\n}\nvar ProxyInteractionService = class {\n  constructor(localeManager, domManager) {\n    this.localeManager = localeManager;\n    this.domManager = domManager;\n    this.destroyFns = [];\n  }\n  destroy() {\n    this.destroyFns.forEach((fn) => fn());\n  }\n  addLocalisation(fn) {\n    fn();\n    this.destroyFns.push(this.localeManager.addListener(\"locale-changed\", fn));\n  }\n  createProxyContainer(args) {\n    const meta = allocateMeta(args);\n    const { params, result: div } = meta;\n    this.domManager.addChild(\"canvas-proxy\", params.id, div);\n    div.classList.add(...params.classList, \"ag-charts-proxy-container\");\n    div.role = params.type;\n    if (\"ariaOrientation\" in params) {\n      div.ariaOrientation = params.ariaOrientation;\n    }\n    if (typeof params.ariaHidden === \"boolean\") {\n      div.ariaHidden = params.ariaHidden.toString();\n    }\n    this.addLocalisation(() => {\n      div.ariaLabel = this.localeManager.t(params.ariaLabel.id, params.ariaLabel.params);\n    });\n    return div;\n  }\n  createProxyElement(args) {\n    const meta = allocateMeta(args);\n    if (checkType(\"button\", meta)) {\n      const { params, result: button } = meta;\n      this.initInteract(params, button);\n      button.style.pointerEvents = \"auto\";\n      if (typeof params.textContent === \"string\") {\n        button.textContent = params.textContent;\n      } else {\n        const { textContent } = params;\n        this.addLocalisation(() => {\n          button.textContent = this.localeManager.t(textContent.id, textContent.params);\n        });\n      }\n      this.setParent(params, button);\n    }\n    if (checkType(\"slider\", meta)) {\n      const { params, result: slider } = meta;\n      this.initInteract(params, slider);\n      slider.type = \"range\";\n      slider.role = \"presentation\";\n      slider.style.margin = \"0px\";\n      slider.ariaOrientation = params.ariaOrientation;\n      this.addLocalisation(() => {\n        slider.ariaLabel = this.localeManager.t(params.ariaLabel.id, params.ariaLabel.params);\n      });\n      this.setParent(params, slider);\n    }\n    if (checkType(\"text\", meta)) {\n      const { params, result: text } = meta;\n      this.initElement(params, text.getContainer());\n      this.setParent(params, text.getContainer());\n    }\n    if (checkType(\"listswitch\", meta)) {\n      const {\n        params,\n        result: { button, listitem }\n      } = meta;\n      this.initInteract(params, button);\n      button.style.width = \"100%\";\n      button.style.height = \"100%\";\n      button.textContent = params.textContent;\n      button.role = \"switch\";\n      button.ariaChecked = params.ariaChecked.toString();\n      button.style.pointerEvents = \"auto\";\n      button.setAttribute(\"aria-describedby\", params.ariaDescribedBy);\n      listitem.role = \"listitem\";\n      listitem.style.position = \"absolute\";\n      listitem.replaceChildren(button);\n      this.setParent(params, listitem);\n    }\n    return meta.result;\n  }\n  initElement(params, element2) {\n    const { id } = params;\n    element2.id = id;\n    element2.classList.toggle(\"ag-charts-proxy-elem\", true);\n  }\n  initInteract(params, element2) {\n    const { onclick, ondblclick, onmouseenter, onmouseleave, oncontextmenu, onchange, onfocus, onblur, tabIndex } = params;\n    this.initElement(params, element2);\n    if (tabIndex !== void 0) {\n      element2.tabIndex = tabIndex;\n    }\n    if (onclick) {\n      element2.addEventListener(\"click\", onclick);\n    }\n    if (ondblclick) {\n      element2.addEventListener(\"dblclick\", ondblclick);\n    }\n    if (onmouseenter) {\n      element2.addEventListener(\"mouseenter\", onmouseenter);\n    }\n    if (onmouseleave) {\n      element2.addEventListener(\"mouseleave\", onmouseleave);\n    }\n    if (oncontextmenu) {\n      element2.addEventListener(\"contextmenu\", oncontextmenu);\n    }\n    if (onfocus) {\n      element2.addEventListener(\"focus\", onfocus);\n    }\n    if (onblur) {\n      element2.addEventListener(\"blur\", onblur);\n    }\n    if (onchange) {\n      element2.addEventListener(\"change\", onchange);\n    }\n  }\n  setParent(params, element2) {\n    const { id, parent } = params;\n    if (typeof parent === \"string\") {\n      const insert = { where: parent, query: \".ag-charts-series-area\" };\n      this.domManager.addChild(\"canvas-proxy\", id, element2, insert);\n    } else {\n      parent.appendChild(element2);\n    }\n  }\n};\n\n// packages/ag-charts-community/src/locale/defaultMessageFormatter.ts\nvar messageRegExp = /\\$\\{(\\w+)}(?:\\[(\\w+)])?/gi;\nvar formatters = {\n  number: new Intl.NumberFormat(\"en-US\"),\n  percent: new Intl.NumberFormat(\"en-US\", { style: \"percent\", minimumFractionDigits: 2, maximumFractionDigits: 2 }),\n  date: new Intl.DateTimeFormat(\"en-US\", { dateStyle: \"full\" }),\n  time: new Intl.DateTimeFormat(\"en-US\", { timeStyle: \"full\" }),\n  datetime: new Intl.DateTimeFormat(\"en-US\", { dateStyle: \"full\", timeStyle: \"full\" })\n};\nvar defaultMessageFormatter = ({ defaultValue, variables }) => {\n  return defaultValue?.replaceAll(messageRegExp, (_, match, format) => {\n    const value = variables[match];\n    const formatter = format != null ? formatters[format] : null;\n    if (format != null && formatter == null) {\n      Logger.warnOnce(`Format style [${format}] is not supported`);\n    }\n    if (formatter != null) {\n      return formatter.format(value);\n    } else if (typeof value === \"number\") {\n      return formatters.number.format(value);\n    } else if (value instanceof Date) {\n      return formatters.datetime.format(value);\n    }\n    return String(value);\n  });\n};\n\n// packages/ag-charts-community/src/locale/localeManager.ts\nvar LocaleManager = class extends Listeners {\n  constructor() {\n    super(...arguments);\n    this.localeText = void 0;\n    this.getLocaleText = void 0;\n  }\n  setLocaleText(localeText) {\n    if (this.localeText !== localeText) {\n      this.localeText = localeText;\n      this.dispatch(\"locale-changed\");\n    }\n  }\n  setLocaleTextFormatter(getLocaleText) {\n    this.getLocaleText = getLocaleText;\n    if (this.getLocaleText !== getLocaleText) {\n      this.getLocaleText = getLocaleText;\n      this.dispatch(\"locale-changed\");\n    }\n  }\n  t(key, variables = {}) {\n    const { localeText = AG_CHARTS_LOCALE_EN_US, getLocaleText } = this;\n    const defaultValue = localeText[key];\n    return getLocaleText?.({ key, defaultValue, variables }) ?? defaultMessageFormatter({ key, defaultValue, variables }) ?? key;\n  }\n};\n\n// packages/ag-charts-community/src/util/userAgent.ts\nfunction hasConstrainedCanvasMemory() {\n  if (typeof navigator === \"undefined\") {\n    return false;\n  }\n  const iPhoneOSMatch = /\\(iPhone; CPU iPhone OS (\\d+_\\d+_\\d+) like Mac OS X\\)/.exec(navigator.userAgent);\n  if (iPhoneOSMatch == null) {\n    return false;\n  }\n  const [major, minor] = iPhoneOSMatch[1].split(\"_\").map(Number);\n  return major < 16 || major === 16 && minor < 6;\n}\n\n// packages/ag-charts-community/src/scene/canvas/hdpiCanvas.ts\nvar _HdpiCanvas = class _HdpiCanvas {\n  constructor(options) {\n    this.enabled = true;\n    this.width = 600;\n    this.height = 300;\n    const { width: width2, height: height2, pixelRatio, canvasElement, willReadFrequently = false } = options;\n    this.pixelRatio = hasConstrainedCanvasMemory() ? 1 : pixelRatio ?? getWindow(\"devicePixelRatio\");\n    this.element = canvasElement ?? createElement(\"canvas\");\n    this.element.style.display = \"block\";\n    this.element.style.width = (width2 ?? this.width) + \"px\";\n    this.element.style.height = (height2 ?? this.height) + \"px\";\n    this.element.width = Math.round((width2 ?? this.width) * this.pixelRatio);\n    this.element.height = Math.round((height2 ?? this.height) * this.pixelRatio);\n    this.context = this.element.getContext(\"2d\", { willReadFrequently });\n    this.onEnabledChange();\n    this.resize(width2 ?? 0, height2 ?? 0);\n    _HdpiCanvas.debugContext(this.context);\n  }\n  static is(value) {\n    return value instanceof _HdpiCanvas;\n  }\n  drawImage(context, dx = 0, dy = 0) {\n    return context.drawImage(this.context.canvas, dx, dy);\n  }\n  toDataURL(type) {\n    return this.element.toDataURL(type);\n  }\n  resize(width2, height2) {\n    if (!(width2 > 0 && height2 > 0))\n      return;\n    const { element: element2, context, pixelRatio } = this;\n    element2.width = Math.round(width2 * pixelRatio);\n    element2.height = Math.round(height2 * pixelRatio);\n    context.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n    element2.style.width = width2 + \"px\";\n    element2.style.height = height2 + \"px\";\n    this.width = width2;\n    this.height = height2;\n  }\n  clear() {\n    this.context.save();\n    this.context.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);\n    this.context.clearRect(0, 0, this.width, this.height);\n    this.context.restore();\n  }\n  destroy() {\n    this.element.remove();\n    this.element.width = 0;\n    this.element.height = 0;\n    this.context.clearRect(0, 0, 0, 0);\n    Object.freeze(this);\n  }\n  onEnabledChange() {\n    if (this.element) {\n      this.element.style.display = this.enabled ? \"\" : \"none\";\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\n  static debugContext(ctx) {\n    if (Debug.check(\"canvas\")) {\n      const save = ctx.save.bind(ctx);\n      const restore = ctx.restore.bind(ctx);\n      let depth = 0;\n      Object.assign(ctx, {\n        save() {\n          save();\n          depth++;\n        },\n        restore() {\n          if (depth === 0) {\n            throw new Error(\"AG Charts - Unable to restore() past depth 0\");\n          }\n          restore();\n          depth--;\n        },\n        verifyDepthZero() {\n          if (depth !== 0) {\n            throw new Error(`AG Charts - Save/restore depth is non-zero: ${depth}`);\n          }\n        }\n      });\n    }\n  }\n};\n__decorateClass([\n  ObserveChanges((target) => target.onEnabledChange())\n], _HdpiCanvas.prototype, \"enabled\", 2);\nvar HdpiCanvas = _HdpiCanvas;\n\n// packages/ag-charts-community/src/scene/layersManager.ts\nvar LayersManager = class _LayersManager {\n  constructor(canvas, markDirty) {\n    this.canvas = canvas;\n    this.markDirty = markDirty;\n    this.debug = Debug.create(true, \"scene\");\n    this.layersMap = /* @__PURE__ */ new Map();\n    this.nextZIndex = 0;\n    this.nextLayerId = 0;\n  }\n  static sortLayers(a, b) {\n    return compoundAscending(\n      [a.zIndex, ...a.zIndexSubOrder ?? [void 0, void 0], a.id],\n      [b.zIndex, ...b.zIndexSubOrder ?? [void 0, void 0], b.id],\n      ascendingStringNumberUndefined\n    );\n  }\n  get size() {\n    return this.layersMap.size;\n  }\n  forEach(callback2) {\n    Array.from(this.layersMap.values()).sort(_LayersManager.sortLayers).forEach(callback2);\n  }\n  resize(width2, height2) {\n    this.canvas.resize(width2, height2);\n    this.layersMap.forEach(({ canvas }) => canvas.resize(width2, height2));\n  }\n  addLayer(opts) {\n    const { width: width2, height: height2, pixelRatio } = this.canvas;\n    const { zIndex = this.nextZIndex++, name, zIndexSubOrder, getComputedOpacity, getVisibility } = opts;\n    const canvas = new HdpiCanvas({ width: width2, height: height2, pixelRatio });\n    if (zIndex >= this.nextZIndex) {\n      this.nextZIndex = zIndex + 1;\n    }\n    this.layersMap.set(canvas, {\n      id: this.nextLayerId++,\n      name,\n      canvas,\n      zIndex,\n      zIndexSubOrder,\n      getComputedOpacity,\n      getVisibility\n    });\n    this.debug(\"Scene.addLayer() - layers\", this.layersMap);\n    return canvas;\n  }\n  removeLayer(canvas) {\n    if (this.layersMap.has(canvas)) {\n      this.layersMap.delete(canvas);\n      canvas.destroy();\n      this.markDirty();\n      this.debug(\"Scene.removeLayer() -  layers\", this.layersMap);\n    }\n  }\n  moveLayer(canvas, newZIndex, newZIndexSubOrder) {\n    const layer = this.layersMap.get(canvas);\n    if (layer) {\n      layer.zIndex = newZIndex;\n      layer.zIndexSubOrder = newZIndexSubOrder;\n      this.markDirty();\n      this.debug(\"Scene.moveLayer() -  layers\", this.layersMap);\n    }\n  }\n  clear() {\n    this.layersMap.clear();\n  }\n};\n\n// packages/ag-charts-community/src/scene/spriteRenderer.ts\nvar _SpriteRenderer = class _SpriteRenderer {\n  constructor() {\n    this.offscreenCanvas = typeof OffscreenCanvas !== \"undefined\" ? new OffscreenCanvas(0, 0) : createElement(\"canvas\");\n    _SpriteRenderer.offscreenCanvasCount++;\n    const ctx = this.offscreenCanvas.getContext(\"2d\");\n    if (ctx == null)\n      throw new TypeError(`AG Charts - invalid 2d context`);\n    this.renderCtx = {\n      ctx,\n      devicePixelRatio: 1,\n      forceRender: true,\n      resized: false,\n      debugNodes: {}\n    };\n  }\n  resize({ spritePixelRatio, spriteWidth, spriteHeight }) {\n    this.offscreenCanvas.width = Math.max(spriteWidth, 0) * spritePixelRatio;\n    this.offscreenCanvas.height = Math.max(spriteHeight, 0) * spritePixelRatio;\n  }\n  renderSprite(nodes, opts) {\n    nodes = toIterable(nodes);\n    const {\n      renderCtx,\n      renderCtx: { ctx },\n      offscreenCanvas\n    } = this;\n    const { scale: scale2 = 1, translateX = 0, translateY = 0 } = opts ?? {};\n    ctx.resetTransform();\n    ctx.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);\n    ctx.save();\n    ctx.beginPath();\n    ctx.setTransform(scale2, 0, 0, scale2, translateX, translateY);\n    for (const node of nodes) {\n      node.preRender();\n      node.render(renderCtx);\n    }\n    ctx.closePath();\n    ctx.restore();\n    if (\"transferToImageBitmap\" in this.offscreenCanvas) {\n      return this.offscreenCanvas.transferToImageBitmap();\n    }\n    const canvas = createElement(\"canvas\");\n    canvas.style.display = \"block\";\n    canvas.style.width = offscreenCanvas.width + \"px\";\n    canvas.style.height = offscreenCanvas.height + \"px\";\n    canvas.getContext(\"2d\")?.putImageData(ctx.getImageData(0, 0, offscreenCanvas.width, offscreenCanvas.height), 0, 0);\n    return canvas;\n  }\n};\n_SpriteRenderer.offscreenCanvasCount = 0;\nvar SpriteRenderer = _SpriteRenderer;\n\n// packages/ag-charts-community/src/scene/sceneDebug.ts\nfunction debugStats(layersManager, debugSplitTimes, ctx, renderCtxStats, extraDebugStats = {}, seriesRect = BBox.zero) {\n  if (!Debug.check(\"scene:stats\" /* SCENE_STATS */, \"scene:stats:verbose\" /* SCENE_STATS_VERBOSE */))\n    return;\n  const { layersRendered = 0, layersSkipped = 0, nodesRendered = 0, nodesSkipped = 0 } = renderCtxStats ?? {};\n  const end2 = performance.now();\n  const { start: start2, ...durations } = debugSplitTimes;\n  const splits = Object.entries(durations).map(([n, t]) => {\n    return time(n, t);\n  }).filter((v) => v != null).join(\" + \");\n  const extras = Object.entries(extraDebugStats).map(([k, v]) => `${k}: ${v}`).join(\" ; \");\n  const detailedStats = Debug.check(\"scene:stats:verbose\" /* SCENE_STATS_VERBOSE */);\n  const stats = [\n    `${time(\"\\u23F1\\uFE0F\", start2, end2)} (${splits})`,\n    `${extras}`,\n    `Layers: ${detailedStats ? pct(layersRendered, layersSkipped) : layersManager.size}; Sprites: ${SpriteRenderer.offscreenCanvasCount}`,\n    detailedStats ? `Nodes: ${pct(nodesRendered, nodesSkipped)}` : null\n  ].filter(isString);\n  const measurer = new SimpleTextMeasurer((t) => ctx.measureText(t));\n  const statsSize = new Map(stats.map((t) => [t, measurer.measureLines(t)]));\n  const width2 = Math.max(...Array.from(statsSize.values(), (s) => s.width));\n  const height2 = accumulate(statsSize.values(), (s) => s.height);\n  const x = 2 + seriesRect.x;\n  ctx.save();\n  ctx.fillStyle = \"white\";\n  ctx.fillRect(x, 0, width2, height2);\n  ctx.fillStyle = \"black\";\n  let y = 0;\n  for (const [stat, size] of statsSize.entries()) {\n    y += size.height;\n    ctx.fillText(stat, x, y);\n  }\n  ctx.restore();\n}\nfunction prepareSceneNodeHighlight(ctx) {\n  const config = toArray(getWindow(\"agChartsSceneDebug\"));\n  const result = [];\n  for (const name of config) {\n    if (name === \"layout\") {\n      result.push(\"seriesRoot\", \"legend\", \"root\", /.*Axis-\\d+-axis.*/);\n    } else {\n      result.push(name);\n    }\n  }\n  ctx.debugNodeSearch = result;\n}\nfunction debugSceneNodeHighlight(ctx, debugNodes) {\n  ctx.save();\n  for (const [name, node] of Object.entries(debugNodes)) {\n    const bbox = Transformable.toCanvas(node);\n    if (!bbox) {\n      Logger.log(`Scene.render() - no bbox for debugged node [${name}].`);\n      continue;\n    }\n    ctx.globalAlpha = 0.8;\n    ctx.strokeStyle = \"red\";\n    ctx.lineWidth = 1;\n    ctx.strokeRect(bbox.x, bbox.y, bbox.width, bbox.height);\n    ctx.fillStyle = \"red\";\n    ctx.strokeStyle = \"white\";\n    ctx.font = \"16px sans-serif\";\n    ctx.textBaseline = \"top\";\n    ctx.textAlign = \"left\";\n    ctx.lineWidth = 2;\n    ctx.strokeText(name, bbox.x, bbox.y, bbox.width);\n    ctx.fillText(name, bbox.x, bbox.y, bbox.width);\n  }\n  ctx.restore();\n}\nvar skippedProperties = /* @__PURE__ */ new Set();\nvar allowedProperties = /* @__PURE__ */ new Set([\n  \"gradient\",\n  // '_datum',\n  \"zIndex\",\n  \"clipRect\",\n  \"cachedBBox\",\n  \"childNodeCounts\",\n  \"path\",\n  \"__zIndex\",\n  \"name\",\n  \"__scalingCenterX\",\n  \"__scalingCenterY\",\n  \"__rotationCenterX\",\n  \"__rotationCenterY\",\n  \"_previousDatum\",\n  \"__fill\",\n  \"__lineDash\",\n  \"borderPath\",\n  \"borderClipPath\",\n  \"_clipPath\"\n]);\nfunction nodeProps(node) {\n  const { ...allProps } = node;\n  for (const prop in allProps) {\n    if (allowedProperties.has(prop))\n      continue;\n    if (typeof allProps[prop] === \"number\")\n      continue;\n    if (typeof allProps[prop] === \"string\")\n      continue;\n    if (typeof allProps[prop] === \"boolean\")\n      continue;\n    skippedProperties.add(prop);\n    delete allProps[prop];\n  }\n  return allProps;\n}\nfunction buildTree(node, mode) {\n  if (!Debug.check(true, \"scene\" /* SCENE */)) {\n    return {};\n  }\n  const { parentNode } = node;\n  let order = 0;\n  return {\n    node: mode === \"json\" ? nodeProps(node) : node,\n    name: node.name ?? node.id,\n    dirty: RedrawType[node.dirty],\n    ...parentNode?.isVirtual ? {\n      virtualParentDirty: RedrawType[parentNode.dirty],\n      virtualParent: parentNode\n    } : {},\n    ...Array.from(node.children(false), (c) => buildTree(c, mode)).reduce(\n      (result, childTree) => {\n        let { name: treeNodeName } = childTree;\n        const {\n          node: {\n            visible,\n            opacity,\n            zIndex,\n            zIndexSubOrder,\n            translationX,\n            translationY,\n            rotation,\n            scalingX,\n            scalingY\n          },\n          node: childNode,\n          virtualParent\n        } = childTree;\n        if (!visible || opacity <= 0) {\n          treeNodeName = `(${treeNodeName})`;\n        }\n        if (Layer.is(childNode)) {\n          treeNodeName = `*${treeNodeName}*`;\n        }\n        const subOrder = zIndexSubOrder?.map((v) => typeof v === \"function\" ? `${v()} (fn)` : v).join(\" / \");\n        const key = [\n          `${(order++).toString().padStart(3, \"0\")}|`,\n          `${treeNodeName ?? \"<unknown>\"}`,\n          `z: ${zIndex}`,\n          subOrder && `zo: ${subOrder}`,\n          virtualParent && `(virtual parent)`,\n          translationX && `x: ${translationX}`,\n          translationY && `y: ${translationY}`,\n          rotation && `r: ${rotation}`,\n          scalingX != null && scalingX !== 1 && `sx: ${scalingX}`,\n          scalingY != null && scalingY !== 1 && `sy: ${scalingY}`\n        ].filter((v) => !!v).join(\" \");\n        let selectedKey = key;\n        let index = 1;\n        while (result[selectedKey] != null && index < 100) {\n          selectedKey = `${key} (${index++})`;\n        }\n        result[selectedKey] = childTree;\n        return result;\n      },\n      {}\n    )\n  };\n}\nfunction buildDirtyTree(node) {\n  if (node.dirty === 0 /* NONE */) {\n    return { dirtyTree: {}, paths: [] };\n  }\n  const childrenDirtyTree = Array.from(node.children(), (c) => buildDirtyTree(c)).filter((c) => c.paths.length > 0);\n  const name = Group.is(node) ? node.name ?? node.id : node.id;\n  const paths = childrenDirtyTree.length ? childrenDirtyTree.flatMap((c) => c.paths).map((p) => `${name}.${p}`) : [name];\n  return {\n    dirtyTree: {\n      name,\n      node,\n      dirty: RedrawType[node.dirty],\n      ...childrenDirtyTree.map((c) => c.dirtyTree).filter((t) => t.dirty != null).reduce((result, childTree) => {\n        result[childTree.name ?? \"<unknown>\"] = childTree;\n        return result;\n      }, {})\n    },\n    paths\n  };\n}\nfunction pct(rendered, skipped) {\n  const total = rendered + skipped;\n  return `${rendered} / ${total} (${Math.round(100 * rendered / total)}%)`;\n}\nfunction time(name, start2, end2) {\n  const duration = end2 != null ? end2 - start2 : start2;\n  return `${name}: ${Math.round(duration * 100) / 100}ms`;\n}\nfunction accumulate(iterator, mapper) {\n  let sum2 = 0;\n  for (const item of iterator) {\n    sum2 += mapper(item);\n  }\n  return sum2;\n}\n\n// packages/ag-charts-community/src/scene/scene.ts\nvar Scene = class {\n  constructor(canvasOptions) {\n    this.debug = Debug.create(true, \"scene\" /* SCENE */);\n    this.id = createId(this);\n    this.root = null;\n    this.pendingSize = null;\n    this.isDirty = false;\n    this.canvas = new HdpiCanvas(canvasOptions);\n    this.layersManager = new LayersManager(this.canvas, () => {\n      this.isDirty = true;\n    });\n  }\n  get width() {\n    return this.pendingSize?.[0] ?? this.canvas.width;\n  }\n  get height() {\n    return this.pendingSize?.[1] ?? this.canvas.height;\n  }\n  /** @deprecated v10.2.0 Only used by AG Grid Sparklines */\n  setContainer(value) {\n    const { element: element2 } = this.canvas;\n    element2.parentElement?.removeChild(element2);\n    value.appendChild(element2);\n    return this;\n  }\n  setRoot(node) {\n    if (this.root === node) {\n      return this;\n    }\n    this.isDirty = true;\n    this.root?._setLayerManager();\n    this.root = node;\n    if (node) {\n      node.visible = true;\n      node._setLayerManager(this.layersManager);\n    }\n    return this;\n  }\n  attachNode(node) {\n    this.appendChild(node);\n    return () => this.removeChild(node);\n  }\n  appendChild(node) {\n    this.root?.appendChild(node);\n    return this;\n  }\n  removeChild(node) {\n    this.root?.removeChild(node);\n    return this;\n  }\n  download(fileName, fileFormat) {\n    downloadUrl(this.canvas.toDataURL(fileFormat), fileName?.trim() ?? \"image\");\n  }\n  /** NOTE: Integrated Charts undocumented image download method. */\n  getDataURL(fileFormat) {\n    return this.canvas.toDataURL(fileFormat);\n  }\n  resize(width2, height2) {\n    width2 = Math.round(width2);\n    height2 = Math.round(height2);\n    if (width2 > 0 && height2 > 0 && (width2 !== this.width || height2 !== this.height)) {\n      this.pendingSize = [width2, height2];\n      this.isDirty = true;\n      return true;\n    }\n    return false;\n  }\n  async render(opts) {\n    const { debugSplitTimes = { start: performance.now() }, extraDebugStats, seriesRect } = opts ?? {};\n    const { canvas, canvas: { context: ctx } = {}, root, pendingSize } = this;\n    if (!ctx) {\n      return;\n    }\n    const renderStartTime = performance.now();\n    if (pendingSize) {\n      this.layersManager.resize(...pendingSize);\n      this.pendingSize = null;\n    }\n    if (root && !root.visible) {\n      this.isDirty = false;\n      return;\n    }\n    if (root && !this.isDirty) {\n      if (this.debug.check()) {\n        this.debug(\"Scene.render() - no-op\", {\n          redrawType: RedrawType[root.dirty],\n          tree: buildTree(root, \"console\")\n        });\n      }\n      debugStats(this.layersManager, debugSplitTimes, ctx, void 0, extraDebugStats, seriesRect);\n      return;\n    }\n    const renderCtx = {\n      ctx,\n      devicePixelRatio: this.canvas.pixelRatio ?? 1,\n      forceRender: true,\n      resized: Boolean(pendingSize),\n      debugNodes: {}\n    };\n    if (Debug.check(\"scene:stats:verbose\" /* SCENE_STATS_VERBOSE */)) {\n      renderCtx.stats = { layersRendered: 0, layersSkipped: 0, nodesRendered: 0, nodesSkipped: 0 };\n    }\n    prepareSceneNodeHighlight(renderCtx);\n    let canvasCleared = false;\n    if (!root || root.dirty >= 1 /* TRIVIAL */) {\n      canvasCleared = true;\n      canvas.clear();\n    }\n    if (root && Debug.check(\"scene:dirtyTree\" /* SCENE_DIRTY_TREE */)) {\n      const { dirtyTree, paths } = buildDirtyTree(root);\n      Debug.create(\"scene:dirtyTree\" /* SCENE_DIRTY_TREE */)(\"Scene.render() - dirtyTree\", { dirtyTree, paths });\n    }\n    if (root && canvasCleared) {\n      if (root.visible) {\n        root.preRender();\n      }\n      if (this.debug.check()) {\n        const tree = buildTree(root, \"console\");\n        this.debug(\"Scene.render() - before\", {\n          redrawType: RedrawType[root.dirty],\n          canvasCleared,\n          tree\n        });\n      }\n      if (root.visible) {\n        ctx.save();\n        root.render(renderCtx);\n        ctx.restore();\n      }\n    }\n    debugSplitTimes[\"\\u270D\\uFE0F\"] = performance.now() - renderStartTime;\n    if (this.layersManager.size && canvasCleared) {\n      const layerRenderStart = performance.now();\n      ctx.save();\n      ctx.resetTransform();\n      this.layersManager.forEach((layer) => {\n        if (layer.canvas.enabled && layer.getVisibility()) {\n          ctx.globalAlpha = layer.getComputedOpacity();\n          layer.canvas.drawImage(ctx);\n        }\n      });\n      ctx.restore();\n      debugSplitTimes[\"\\u26D9\"] = performance.now() - layerRenderStart;\n    }\n    ctx.verifyDepthZero?.();\n    this.isDirty = false;\n    debugStats(this.layersManager, debugSplitTimes, ctx, renderCtx.stats, extraDebugStats, seriesRect);\n    debugSceneNodeHighlight(ctx, renderCtx.debugNodes);\n    if (root && this.debug.check()) {\n      this.debug(\"Scene.render() - after\", {\n        redrawType: RedrawType[root.dirty],\n        tree: buildTree(root, \"console\"),\n        canvasCleared\n      });\n    }\n  }\n  toSVG() {\n    const svg = this.root?.toSVG();\n    if (svg == null)\n      return;\n    const root = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n    root.setAttribute(\"width\", String(this.width));\n    root.setAttribute(\"height\", String(this.height));\n    if (svg.defs != null) {\n      const defs = document.createElementNS(\"http://www.w3.org/2000/svg\", \"defs\");\n      defs.append(...svg.defs);\n      root.append(defs);\n    }\n    root.append(...svg.elements);\n    return root.outerHTML;\n  }\n  /** Alternative to destroy() that preserves re-usable resources. */\n  strip() {\n    const { context, pixelRatio } = this.canvas;\n    context.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n    this.layersManager.clear();\n    this.setRoot(null);\n    this.isDirty = false;\n  }\n  destroy() {\n    this.strip();\n    this.canvas.destroy();\n    Object.assign(this, { canvas: void 0 });\n  }\n};\nScene.className = \"Scene\";\n\n// packages/ag-charts-community/src/util/callbackCache.ts\nvar CallbackCache = class {\n  constructor() {\n    this.cache = /* @__PURE__ */ new WeakMap();\n  }\n  call(fn, ...params) {\n    let serialisedParams;\n    let paramCache = this.cache.get(fn);\n    try {\n      serialisedParams = JSON.stringify(params);\n    } catch (e) {\n      return this.invoke(fn, params, paramCache);\n    }\n    if (paramCache == null) {\n      paramCache = /* @__PURE__ */ new Map();\n      this.cache.set(fn, paramCache);\n    }\n    if (!paramCache.has(serialisedParams)) {\n      return this.invoke(fn, params, paramCache, serialisedParams);\n    }\n    return paramCache.get(serialisedParams);\n  }\n  invoke(fn, params, paramCache, serialisedParams) {\n    try {\n      const result = fn(...params);\n      if (paramCache && serialisedParams != null) {\n        paramCache.set(serialisedParams, result);\n      }\n      return result;\n    } catch (e) {\n      Logger.warnOnce(`User callback errored, ignoring`, e);\n      return;\n    }\n  }\n  invalidateCache() {\n    this.cache = /* @__PURE__ */ new WeakMap();\n  }\n};\n\n// packages/ag-charts-community/src/chart/annotation/annotationManager.ts\nvar AnnotationManager = class extends BaseManager {\n  constructor(annotationRoot) {\n    super();\n    this.annotationRoot = annotationRoot;\n    this.mementoOriginatorKey = \"annotations\";\n    this.annotations = [];\n  }\n  createMemento() {\n    return this.annotations;\n  }\n  guardMemento(blob) {\n    return isArray(blob);\n  }\n  restoreMemento(_version, _mementoVersion, memento) {\n    this.annotations = this.cleanData(memento).map((annotation) => {\n      const annotationTheme = this.getAnnotationTypeStyles(annotation.type);\n      return mergeDefaults(annotation, annotationTheme);\n    });\n    this.listeners.dispatch(\"restore-annotations\", {\n      type: \"restore-annotations\",\n      annotations: this.annotations\n    });\n  }\n  updateData(annotations2) {\n    this.annotations = this.cleanData(annotations2 ?? []);\n  }\n  attachNode(node) {\n    this.annotationRoot.append(node);\n    return () => {\n      this.annotationRoot?.removeChild(node);\n      return this;\n    };\n  }\n  setAnnotationStyles(styles) {\n    this.styles = styles;\n  }\n  getAnnotationTypeStyles(type) {\n    return this.styles?.[type];\n  }\n  cleanData(annotations2) {\n    for (const annotation of annotations2) {\n      if (\"textAlign\" in annotation)\n        delete annotation.textAlign;\n    }\n    return annotations2;\n  }\n};\n\n// packages/ag-charts-community/src/chart/axis/axisManager.ts\nvar AxisManager = class {\n  constructor(sceneRoot) {\n    this.sceneRoot = sceneRoot;\n    this.axes = /* @__PURE__ */ new Map();\n    this.axisGridGroup = new Layer({ name: \"Axes-Grids\", zIndex: 1 /* AXIS_GRID */ });\n    this.axisGroup = new Layer({ name: \"Axes\", zIndex: 2 /* AXIS */ });\n    this.sceneRoot.appendChild(this.axisGroup);\n    this.sceneRoot.appendChild(this.axisGridGroup);\n  }\n  updateAxes(oldAxes, newAxes) {\n    for (const axis of oldAxes) {\n      if (newAxes.includes(axis))\n        continue;\n      axis.detachAxis(this.axisGroup, this.axisGridGroup);\n      axis.destroy();\n    }\n    for (const axis of newAxes) {\n      if (oldAxes?.includes(axis))\n        continue;\n      axis.attachAxis(this.axisGroup, this.axisGridGroup);\n    }\n    this.axes.clear();\n    for (const axis of newAxes) {\n      const ctx = axis.createAxisContext();\n      if (this.axes.has(ctx.direction)) {\n        this.axes.get(ctx.direction)?.push(ctx);\n      } else {\n        this.axes.set(ctx.direction, [ctx]);\n      }\n    }\n  }\n  getAxisContext(direction) {\n    return this.axes.get(direction) ?? [];\n  }\n  destroy() {\n    this.axes.clear();\n    this.sceneRoot.removeChild(this.axisGroup);\n    this.sceneRoot.removeChild(this.axisGridGroup);\n  }\n};\n\n// packages/ag-charts-community/src/chart/data/dataService.ts\nvar DataService = class extends Listeners {\n  constructor(animationManager) {\n    super();\n    this.animationManager = animationManager;\n    this.dispatchOnlyLatest = true;\n    this.dispatchThrottle = 0;\n    this.requestThrottle = 300;\n    this.isLoadingInitialData = false;\n    this.isLoadingData = false;\n    this.freshRequests = [];\n    this.requestCounter = 0;\n    this.debug = Debug.create(true, \"data-model\", \"data-source\");\n    this.throttledFetch = this.createThrottledFetch(this.requestThrottle);\n    this.throttledDispatch = this.createThrottledDispatch(this.dispatchThrottle);\n  }\n  updateCallback(dataSourceCallback) {\n    if (typeof dataSourceCallback !== \"function\")\n      return;\n    this.debug(\"DataService - updated data source callback\");\n    this.dataSourceCallback = dataSourceCallback;\n    this.isLoadingInitialData = true;\n    this.animationManager.skip();\n    this.dispatch(\"data-source-change\");\n  }\n  clearCallback() {\n    this.dataSourceCallback = void 0;\n  }\n  load(params) {\n    this.isLoadingData = true;\n    this.throttledFetch(params);\n  }\n  isLazy() {\n    return this.dataSourceCallback != null;\n  }\n  isLoading() {\n    return this.isLazy() && (this.isLoadingInitialData || this.isLoadingData);\n  }\n  createThrottledFetch(requestThrottle) {\n    return throttle((params) => this.fetch(params), requestThrottle, {\n      leading: false,\n      trailing: true\n    });\n  }\n  createThrottledDispatch(dispatchThrottle) {\n    return throttle(\n      (id, data) => {\n        this.debug(`DataService - dispatching 'data-load' | ${id}`);\n        this.dispatch(\"data-load\", { type: \"data-load\", data });\n      },\n      dispatchThrottle,\n      {\n        leading: true,\n        trailing: true\n      }\n    );\n  }\n  async fetch(params) {\n    if (!this.dataSourceCallback) {\n      throw new Error(\"DataService - [dataSource.getData] callback not initialised\");\n    }\n    const start2 = performance.now();\n    const id = this.requestCounter++;\n    this.debug(`DataService - requesting | ${id}`);\n    this.freshRequests.push(id);\n    let response;\n    try {\n      response = await this.dataSourceCallback(params);\n      this.debug(`DataService - response | ${performance.now() - start2}ms | ${id}`);\n    } catch (error) {\n      this.debug(`DataService - request failed | ${id}`);\n      Logger.errorOnce(`DataService - request failed | [${error}]`);\n    }\n    this.isLoadingInitialData = false;\n    const requestIndex = this.freshRequests.findIndex((rid) => rid === id);\n    if (requestIndex === -1 || this.dispatchOnlyLatest && requestIndex !== this.freshRequests.length - 1) {\n      this.debug(`DataService - discarding stale request | ${id}`);\n      return;\n    }\n    this.freshRequests = this.freshRequests.slice(requestIndex + 1);\n    if (this.freshRequests.length === 0) {\n      this.isLoadingData = false;\n    }\n    if (Array.isArray(response)) {\n      this.throttledDispatch(id, response);\n    } else {\n      this.dispatch(\"data-error\");\n    }\n  }\n};\n__decorateClass([\n  ActionOnSet({\n    newValue(dispatchThrottle) {\n      this.throttledDispatch = this.createThrottledDispatch(dispatchThrottle);\n    }\n  })\n], DataService.prototype, \"dispatchThrottle\", 2);\n__decorateClass([\n  ActionOnSet({\n    newValue(requestThrottle) {\n      this.throttledFetch = this.createThrottledFetch(requestThrottle);\n    }\n  })\n], DataService.prototype, \"requestThrottle\", 2);\n\n// packages/ag-charts-community/src/chart/interaction/animationBatch.ts\nvar AnimationBatch = class {\n  constructor(maxAnimationTime) {\n    this.maxAnimationTime = maxAnimationTime;\n    this.debug = Debug.create(true, \"animation\");\n    this.controllers = /* @__PURE__ */ new Map();\n    this.stoppedCbs = /* @__PURE__ */ new Set();\n    this.currentPhase = 0;\n    this.phases = new Map(PHASE_ORDER.map((p) => [p, []]));\n    this.skipAnimations = false;\n    this.animationTimeConsumed = 0;\n    /** Guard against premature animation execution. */\n    this.isReady = false;\n  }\n  get size() {\n    return this.controllers.size;\n  }\n  get consumedTimeMs() {\n    return this.animationTimeConsumed;\n  }\n  isActive() {\n    return this.controllers.size > 0;\n  }\n  getActiveControllers() {\n    return this.phases.get(PHASE_ORDER[this.currentPhase]) ?? [];\n  }\n  checkOverlappingId(id) {\n    if (id != null && this.controllers.has(id)) {\n      this.controllers.get(id).stop();\n      this.debug(`Skipping animation batch due to update of existing animation: ${id}`);\n      this.skip();\n    }\n  }\n  addAnimation(animation) {\n    if (animation.isComplete)\n      return;\n    const animationPhaseIdx = PHASE_ORDER.indexOf(animation.phase);\n    if (animationPhaseIdx < this.currentPhase) {\n      this.debug(`Skipping animation due to being for an earlier phase`, animation.id);\n      animation.stop();\n      return;\n    }\n    this.controllers.set(animation.id, animation);\n    this.phases.get(animation.phase)?.push(animation);\n  }\n  removeAnimation(animation) {\n    this.controllers.delete(animation.id);\n    const phase = this.phases.get(animation.phase);\n    const index = phase?.indexOf(animation);\n    if (index != null && index >= 0) {\n      phase?.splice(index, 1);\n    }\n  }\n  progress(deltaTime) {\n    if (!this.isReady)\n      return;\n    let unusedTime = deltaTime === 0 ? 0.01 : deltaTime;\n    const refresh = () => {\n      const phase2 = PHASE_ORDER[this.currentPhase];\n      return {\n        phaseControllers: [...this.getActiveControllers()],\n        phase: phase2,\n        phaseMeta: PHASE_METADATA[phase2]\n      };\n    };\n    let { phase, phaseControllers, phaseMeta } = refresh();\n    const arePhasesComplete = () => PHASE_ORDER[this.currentPhase] == null;\n    const progressPhase = () => {\n      ({ phase, phaseControllers, phaseMeta } = refresh());\n      while (!arePhasesComplete() && phaseControllers.length === 0) {\n        this.currentPhase++;\n        ({ phase, phaseControllers, phaseMeta } = refresh());\n        this.debug(`AnimationBatch - phase changing to ${phase}`, { unusedTime }, phaseControllers);\n      }\n    };\n    const total = this.controllers.size;\n    this.debug(`AnimationBatch - ${deltaTime}ms; phase ${phase} with ${phaseControllers?.length} of ${total}`);\n    do {\n      const phaseDeltaTime = unusedTime;\n      const skipPhase = phaseMeta.skipIfNoEarlierAnimations && this.animationTimeConsumed === 0;\n      let completeCount = 0;\n      for (const controller of phaseControllers) {\n        if (skipPhase) {\n          controller.stop();\n        } else {\n          unusedTime = Math.min(controller.update(phaseDeltaTime), unusedTime);\n        }\n        if (controller.isComplete) {\n          completeCount++;\n          this.removeAnimation(controller);\n        }\n      }\n      this.animationTimeConsumed += phaseDeltaTime - unusedTime;\n      this.debug(`AnimationBatch - updated ${phaseControllers.length} controllers; ${completeCount} completed`);\n      this.debug(`AnimationBatch - animationTimeConsumed: ${this.animationTimeConsumed}`);\n      progressPhase();\n    } while (unusedTime > 0 && !arePhasesComplete());\n    if (this.animationTimeConsumed > this.maxAnimationTime) {\n      this.debug(`Animation batch exceeded max animation time, skipping`, [...this.controllers]);\n      this.stop();\n    }\n  }\n  ready() {\n    if (this.isReady)\n      return;\n    this.isReady = true;\n    this.debug(`AnimationBatch - ready; skipped: ${this.skipAnimations}`, [...this.controllers]);\n    let skipAll = true;\n    for (const [, controller] of this.controllers) {\n      if (controller.duration > 0 && PHASE_METADATA[controller.phase].skipIfNoEarlierAnimations !== true) {\n        skipAll = false;\n        break;\n      }\n    }\n    if (!skipAll) {\n      for (const [, controller] of this.controllers) {\n        if (controller.autoplay) {\n          controller.play(true);\n        }\n      }\n    }\n  }\n  skip(skip = true) {\n    if (this.skipAnimations === false && skip === true) {\n      for (const controller of this.controllers.values()) {\n        controller.stop();\n      }\n      this.controllers.clear();\n    }\n    this.skipAnimations = skip;\n  }\n  play() {\n    for (const controller of this.controllers.values()) {\n      controller.play();\n    }\n  }\n  pause() {\n    for (const controller of this.controllers.values()) {\n      controller.pause();\n    }\n  }\n  stop() {\n    for (const controller of this.controllers.values()) {\n      try {\n        controller.stop();\n        this.removeAnimation(controller);\n      } catch (error) {\n        Logger.error(\"Error during animation stop\", error);\n      }\n    }\n    this.dispatchStopped();\n  }\n  stopByAnimationId(id) {\n    if (id != null && this.controllers.has(id)) {\n      const controller = this.controllers.get(id);\n      if (controller) {\n        controller.stop();\n        this.removeAnimation(controller);\n      }\n    }\n  }\n  stopByAnimationGroupId(id) {\n    for (const controller of this.controllers.values()) {\n      if (controller.groupId === id) {\n        this.stopByAnimationId(controller.id);\n      }\n    }\n  }\n  dispatchStopped() {\n    this.stoppedCbs.forEach((cb) => cb());\n    this.stoppedCbs.clear();\n  }\n  isSkipped() {\n    return this.skipAnimations;\n  }\n  destroy() {\n    this.stop();\n    this.controllers.clear();\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/preventableEvent.ts\nfunction buildPreventable(obj) {\n  const self = {\n    ...obj,\n    preventDefault() {\n      self.sourceEvent?.preventDefault();\n    }\n  };\n  return self;\n}\nfunction dispatchTypedEvent(listeners, event) {\n  listeners.dispatchWrapHandlers(event.type, (handler, e) => handler(e), buildPreventable(event));\n}\n\n// packages/ag-charts-community/src/chart/interaction/interactionManager.ts\nvar DRAG_INTERACTION_TYPES = [\"drag-start\", \"drag\", \"drag-end\"];\nvar POINTER_INTERACTION_TYPES = [\n  ...DRAG_INTERACTION_TYPES,\n  \"click\",\n  \"dblclick\",\n  \"contextmenu\",\n  \"hover\",\n  \"leave\",\n  \"enter\",\n  \"page-left\",\n  \"wheel\"\n];\nvar FOCUS_INTERACTION_TYPES = [\"blur\", \"focus\"];\nvar KEY_INTERACTION_TYPES = [\"keydown\", \"keyup\"];\nvar SHADOW_DOM_HANDLERS = [\"mousemove\", \"mouseup\"];\nvar WINDOW_EVENT_HANDLERS = [\"pagehide\", \"mousemove\", \"mouseup\"];\nvar EVENT_HANDLERS = [\n  \"dblclick\",\n  \"contextmenu\",\n  \"mousedown\",\n  \"mouseleave\",\n  \"mouseenter\",\n  \"touchstart\",\n  \"touchmove\",\n  \"touchend\",\n  \"touchcancel\",\n  \"wheel\",\n  \"blur\",\n  \"focus\",\n  \"keydown\",\n  \"keyup\"\n];\nfunction isPointerEvent(type) {\n  return POINTER_INTERACTION_TYPES.includes(type);\n}\nfunction isFocusEvent(type) {\n  return FOCUS_INTERACTION_TYPES.includes(type);\n}\nfunction isKeyEvent(type) {\n  return KEY_INTERACTION_TYPES.includes(type);\n}\nvar _InteractionManager = class _InteractionManager extends InteractionStateListener {\n  constructor(keyboardOptions, domManager) {\n    super();\n    this.keyboardOptions = keyboardOptions;\n    this.domManager = domManager;\n    this.debug = Debug.create(true, \"interaction\");\n    this.eventHandler = (event) => this.processEvent(event);\n    this.mouseDown = false;\n    this.touchDown = false;\n    this.clickHistory = [{ offsetX: NaN, offsetY: NaN, type: \"mousedown\" }];\n    this.dblclickHistory = [\n      { offsetX: NaN, offsetY: NaN, type: \"mousedown\" },\n      { offsetX: NaN, offsetY: NaN, type: \"mouseup\" },\n      { offsetX: NaN, offsetY: NaN, type: \"mousedown\" }\n    ];\n    this.stateQueue = 32 /* Default */ | 2 /* Animation */;\n    this.rootElement = this.domManager.getShadowDocumentRoot();\n    for (const type of EVENT_HANDLERS) {\n      if (type.startsWith(\"touch\") || type === \"wheel\") {\n        this.domManager.addEventListener(type, this.eventHandler, { passive: false });\n      } else {\n        this.domManager.addEventListener(type, this.eventHandler);\n      }\n    }\n    for (const type of WINDOW_EVENT_HANDLERS) {\n      getWindow().addEventListener(type, this.eventHandler);\n    }\n    this.containerChanged(true);\n    this.domManager.addListener(\"container-changed\", () => this.containerChanged());\n  }\n  containerChanged(force = false) {\n    const newRoot = this.domManager.getShadowDocumentRoot();\n    if (!force && newRoot === this.rootElement)\n      return;\n    for (const type of SHADOW_DOM_HANDLERS) {\n      this.rootElement?.removeEventListener(type, this.eventHandler);\n    }\n    this.rootElement = newRoot;\n    this.debug(\"[InteractionManager] Switching rootElement to:\", this.rootElement);\n    for (const type of SHADOW_DOM_HANDLERS) {\n      this.rootElement?.addEventListener(type, this.eventHandler);\n    }\n  }\n  destroy() {\n    super.destroy();\n    for (const type of WINDOW_EVENT_HANDLERS) {\n      getWindow().removeEventListener(type, this.eventHandler);\n    }\n    for (const type of SHADOW_DOM_HANDLERS) {\n      this.rootElement?.removeEventListener(type, this.eventHandler);\n    }\n    for (const type of EVENT_HANDLERS) {\n      this.domManager.removeEventListener(type, this.eventHandler);\n    }\n    this.domManager.removeStyles(\"interactionManager\");\n  }\n  pushState(state) {\n    this.stateQueue |= state;\n  }\n  popState(state) {\n    this.stateQueue &= ~state;\n  }\n  getState() {\n    return this.stateQueue & -this.stateQueue;\n  }\n  processEvent(event) {\n    this.debug(\"Received raw event\", event);\n    let types = this.decideInteractionEventTypes(event);\n    if (types != null && !Array.isArray(types)) {\n      types = [types];\n    }\n    for (const type of types ?? []) {\n      this.dispatchEvent(event, type).catch((e) => Logger.errorOnce(e));\n    }\n  }\n  async dispatchEvent(event, type) {\n    if (isPointerEvent(type)) {\n      this.dispatchPointerEvent(event, type);\n      return;\n    }\n    const { relatedElement, targetElement } = this.extractElements(event);\n    if (isFocusEvent(type)) {\n      const sourceEvent = event;\n      this.dispatchTypedEvent(this.listeners, { type, sourceEvent, relatedElement, targetElement });\n    } else if (isKeyEvent(type)) {\n      const sourceEvent = event;\n      this.dispatchTypedEvent(this.listeners, { type, sourceEvent, relatedElement, targetElement });\n    }\n  }\n  dispatchTypedEvent(listeners, event) {\n    const preventableEvent = buildPreventable(event);\n    this.debug(\"Dispatching typed event\", preventableEvent, this.getState());\n    listeners.dispatchWrapHandlers(event.type, (handler, e) => handler(e), preventableEvent);\n  }\n  extractElements(event) {\n    let relatedElement;\n    let targetElement;\n    if (\"relatedTarget\" in event && event[\"relatedTarget\"] instanceof HTMLElement) {\n      relatedElement = event[\"relatedTarget\"];\n    }\n    if (\"target\" in event && event[\"target\"] instanceof HTMLElement) {\n      targetElement = event[\"target\"];\n    }\n    return { relatedElement, targetElement };\n  }\n  dispatchPointerEvent(event, type) {\n    const coords = this.calculateCoordinates(event);\n    if (coords == null)\n      return;\n    const pointerEvent = this.buildPointerEvent({ type, event, ...coords });\n    this.debug(\"Dispatching pointer event\", pointerEvent, this.getState());\n    dispatchTypedEvent(this.listeners, pointerEvent);\n  }\n  getEventHTMLTarget(event) {\n    if (event.target instanceof HTMLElement) {\n      return event.target;\n    } else if (event.currentTarget instanceof HTMLElement) {\n      return event.currentTarget;\n    }\n    return void 0;\n  }\n  recordDown(event) {\n    if (event instanceof MouseEvent) {\n      partialAssign([\"offsetX\", \"offsetY\"], this.clickHistory[0], event);\n      partialAssign([\"offsetX\", \"offsetY\"], this.dblclickHistory[2], this.dblclickHistory[0]);\n      partialAssign([\"offsetX\", \"offsetY\"], this.dblclickHistory[0], event);\n    }\n    this.dragPreStartElement = this.getEventHTMLTarget(event);\n  }\n  recordUp(event) {\n    if (event instanceof MouseEvent) {\n      partialAssign([\"offsetX\", \"offsetY\"], this.dblclickHistory[1], event);\n    }\n    this.dragPreStartElement = void 0;\n    if (this.dragStartElement) {\n      this.dragStartElement = void 0;\n      return true;\n    }\n    return false;\n  }\n  decideInteractionEventTypes(event) {\n    const dragStart = \"drag-start\";\n    switch (event.type) {\n      case \"blur\":\n      case \"focus\":\n      case \"keydown\":\n      case \"keyup\":\n        return this.keyboardOptions.enabled ? event.type : void 0;\n      case \"dblclick\":\n        return event.type;\n      case \"contextmenu\":\n      case \"wheel\":\n        return event.type;\n      case \"mousedown\":\n        if (!this.isEventOverElement(event)) {\n          return;\n        }\n        this.mouseDown = true;\n        this.recordDown(event);\n        return;\n      case \"touchstart\":\n        if (!this.isEventOverElement(event)) {\n          return;\n        }\n        this.touchDown = true;\n        this.recordDown(event);\n        return;\n      case \"touchmove\":\n      case \"mousemove\":\n        if (!this.mouseDown && !this.touchDown && !this.isEventOverElement(event)) {\n          return;\n        }\n        if (!this.mouseDown && !this.touchDown)\n          return \"hover\";\n        if (this.dragStartElement)\n          return \"drag\";\n        this.dragStartElement = this.dragPreStartElement;\n        this.dragPreStartElement = void 0;\n        return [dragStart, \"drag\"];\n      case \"mouseup\":\n        if (!this.mouseDown && !this.isEventOverElement(event)) {\n          return;\n        }\n        this.mouseDown = false;\n        return this.recordUp(event) ? \"drag-end\" : \"click\";\n      case \"touchend\":\n        if (!this.touchDown && !this.isEventOverElement(event)) {\n          return;\n        }\n        this.touchDown = false;\n        return this.recordUp(event) ? \"drag-end\" : \"click\";\n      case \"mouseleave\":\n      case \"touchcancel\":\n        return \"leave\";\n      case \"mouseenter\":\n        return \"enter\";\n      case \"pagehide\":\n        return \"page-left\";\n    }\n  }\n  isEventOverElement(event) {\n    return this.domManager.isEventOverElement(event);\n  }\n  calculateCoordinates(event) {\n    if (event instanceof MouseEvent) {\n      return this.getMouseEventCoords(event);\n    } else if (typeof TouchEvent !== \"undefined\" && event instanceof TouchEvent) {\n      const lastTouch = event.touches[0] ?? event.changedTouches[0];\n      const { clientX, clientY, pageX, pageY } = lastTouch;\n      return { ..._InteractionManager.NULL_COORDS, clientX, clientY, pageX, pageY };\n    } else if (event instanceof PageTransitionEvent) {\n      if (event.persisted) {\n        return;\n      }\n      return _InteractionManager.NULL_COORDS;\n    }\n  }\n  getMouseEventCoords(event) {\n    const { clientX, clientY, pageX, pageY } = event;\n    let { offsetX, offsetY } = event;\n    const target = this.getEventHTMLTarget(event);\n    const { x = 0, y = 0 } = target ? this.domManager.calculateCanvasPosition(target) : {};\n    if (this.dragStartElement != null && event.target !== this.dragStartElement) {\n      const offsetDragStart = this.domManager.calculateCanvasPosition(this.dragStartElement);\n      offsetX -= offsetDragStart.x - x;\n      offsetY -= offsetDragStart.y - y;\n    } else {\n      offsetX += x;\n      offsetY += y;\n    }\n    return { clientX, clientY, pageX, pageY, offsetX, offsetY };\n  }\n  isWheelEvent(event) {\n    return event.type === \"wheel\";\n  }\n  buildPointerEvent(opts) {\n    const { type, event, clientX, clientY } = opts;\n    let { offsetX, offsetY, pageX, pageY } = opts;\n    if (!isFiniteNumber(offsetX) || !isFiniteNumber(offsetY)) {\n      const rect = this.domManager.getBoundingClientRect();\n      offsetX = clientX - rect.left;\n      offsetY = clientY - rect.top;\n    }\n    if (!isFiniteNumber(pageX) || !isFiniteNumber(pageY)) {\n      const pageRect = this.rootElement?.getBoundingClientRect();\n      pageX = clientX - (pageRect?.left ?? 0);\n      pageY = clientY - (pageRect?.top ?? 0);\n    }\n    let [deltaX, deltaY] = [NaN, NaN];\n    if (this.isWheelEvent(event)) {\n      const factor = event.deltaMode === 0 ? 0.01 : 1;\n      deltaX = event.deltaX * factor;\n      deltaY = event.deltaY * factor;\n    }\n    let pointerHistory = [];\n    if (event.type === \"click\") {\n      pointerHistory = this.clickHistory;\n    } else if (event.type === \"dblclick\") {\n      pointerHistory = this.dblclickHistory;\n    }\n    const { relatedElement, targetElement } = this.extractElements(event);\n    const button = \"button\" in event ? Number(event.button) : 0;\n    const builtEvent = {\n      type,\n      offsetX,\n      offsetY,\n      pageX,\n      pageY,\n      deltaX,\n      deltaY,\n      button,\n      pointerHistory,\n      sourceEvent: event,\n      relatedElement,\n      targetElement\n    };\n    this.debug(\"InteractionManager - builtEvent: \", builtEvent, this.getState());\n    return builtEvent;\n  }\n};\n_InteractionManager.NULL_COORDS = {\n  clientX: -Infinity,\n  clientY: -Infinity,\n  pageX: -Infinity,\n  pageY: -Infinity,\n  offsetX: -Infinity,\n  offsetY: -Infinity\n};\nvar InteractionManager = _InteractionManager;\n\n// packages/ag-charts-community/src/chart/interaction/animationManager.ts\nfunction validAnimationDuration(testee) {\n  if (testee == null)\n    return true;\n  return !isNaN(testee) && testee >= 0 && testee <= 2;\n}\nvar AnimationManager = class {\n  constructor(interactionManager, chartUpdateMutex) {\n    this.interactionManager = interactionManager;\n    this.chartUpdateMutex = chartUpdateMutex;\n    this.defaultDuration = 1e3;\n    this.batch = new AnimationBatch(this.defaultDuration * 1.5);\n    this.debug = Debug.create(true, \"animation\");\n    this.events = new EventEmitter();\n    this.rafAvailable = typeof requestAnimationFrame !== \"undefined\";\n    this.isPlaying = true;\n    this.requestId = null;\n    this.skipAnimations = true;\n    this.currentAnonymousAnimationId = 0;\n  }\n  addListener(eventName, listener) {\n    return this.events.on(eventName, listener);\n  }\n  /**\n   * Create an animation to tween a value between the `from` and `to` properties. If an animation already exists\n   * with the same `id`, immediately stop it.\n   */\n  animate(opts) {\n    const batch = this.batch;\n    try {\n      batch.checkOverlappingId(opts.id);\n    } catch (error) {\n      this.failsafeOnError(error);\n      return;\n    }\n    let { id } = opts;\n    if (id == null) {\n      id = `__${this.currentAnonymousAnimationId}`;\n      this.currentAnonymousAnimationId += 1;\n    }\n    const skip = this.isSkipped() || opts.phase === \"none\";\n    if (skip) {\n      this.debug(\"AnimationManager - skipping animation\");\n    }\n    const { delay, duration } = opts;\n    if (!validAnimationDuration(delay)) {\n      throw new Error(`Animation delay of ${delay} is unsupported (${id})`);\n    }\n    if (!validAnimationDuration(duration)) {\n      throw new Error(`Animation duration of ${duration} is unsupported (${id})`);\n    }\n    const animation = new Animation({\n      ...opts,\n      id,\n      skip,\n      autoplay: this.isPlaying ? opts.autoplay : false,\n      phase: opts.phase,\n      defaultDuration: this.defaultDuration\n    });\n    if (this.forceTimeJump(animation, this.defaultDuration)) {\n      return;\n    }\n    this.batch.addAnimation(animation);\n    return animation;\n  }\n  play() {\n    if (this.isPlaying) {\n      return;\n    }\n    this.isPlaying = true;\n    this.debug(\"AnimationManager.play()\");\n    try {\n      this.batch.play();\n    } catch (error) {\n      this.failsafeOnError(error);\n    }\n    this.requestAnimation();\n  }\n  pause() {\n    if (!this.isPlaying) {\n      return;\n    }\n    this.isPlaying = false;\n    this.cancelAnimation();\n    this.debug(\"AnimationManager.pause()\");\n    try {\n      this.batch.pause();\n    } catch (error) {\n      this.failsafeOnError(error);\n    }\n  }\n  stop() {\n    this.isPlaying = false;\n    this.cancelAnimation();\n    this.debug(\"AnimationManager.stop()\");\n    this.batch.stop();\n  }\n  stopByAnimationId(id) {\n    try {\n      this.batch.stopByAnimationId(id);\n    } catch (error) {\n      this.failsafeOnError(error);\n    }\n  }\n  stopByAnimationGroupId(id) {\n    try {\n      this.batch.stopByAnimationGroupId(id);\n    } catch (error) {\n      this.failsafeOnError(error);\n    }\n  }\n  reset() {\n    if (this.isPlaying) {\n      this.stop();\n      this.play();\n    } else {\n      this.stop();\n    }\n  }\n  skip(skip = true) {\n    this.skipAnimations = skip;\n  }\n  isSkipped() {\n    return !this.rafAvailable || this.skipAnimations || this.batch.isSkipped();\n  }\n  isActive() {\n    return this.isPlaying && this.batch.isActive();\n  }\n  skipCurrentBatch() {\n    if (this.debug.check()) {\n      this.debug(`AnimationManager - skipCurrentBatch()`, { stack: new Error().stack });\n    }\n    this.batch.skip();\n  }\n  /** Mocking point for tests to guarantee that animation updates happen. */\n  isSkippingFrames() {\n    return true;\n  }\n  /** Mocking point for tests to capture requestAnimationFrame callbacks. */\n  scheduleAnimationFrame(cb) {\n    this.requestId = getWindow().requestAnimationFrame(cb);\n  }\n  /** Mocking point for tests to skip animations to a specific point in time. */\n  forceTimeJump(_animation, _defaultDuration) {\n    return false;\n  }\n  requestAnimation() {\n    if (!this.rafAvailable)\n      return;\n    if (!this.batch.isActive() || this.requestId !== null)\n      return;\n    let prevTime;\n    const onAnimationFrame = async (time2) => {\n      const executeAnimationFrame = async () => {\n        const deltaTime = time2 - (prevTime ?? time2);\n        prevTime = time2;\n        this.debug(\"AnimationManager - onAnimationFrame()\", {\n          controllersCount: this.batch.size,\n          deltaTime\n        });\n        this.interactionManager.pushState(2 /* Animation */);\n        try {\n          this.batch.progress(deltaTime);\n        } catch (error) {\n          this.failsafeOnError(error);\n        }\n        this.events.emit(\"animation-frame\", {\n          type: \"animation-frame\",\n          deltaMs: deltaTime\n        });\n      };\n      if (this.isSkippingFrames()) {\n        await this.chartUpdateMutex.acquireImmediately(executeAnimationFrame);\n      } else {\n        await this.chartUpdateMutex.acquire(executeAnimationFrame);\n      }\n      if (this.batch.isActive()) {\n        this.scheduleAnimationFrame(onAnimationFrame);\n      } else {\n        this.batch.stop();\n        this.events.emit(\"animation-stop\", {\n          type: \"animation-stop\",\n          deltaMs: this.batch.consumedTimeMs\n        });\n      }\n    };\n    this.events.emit(\"animation-start\", {\n      type: \"animation-start\",\n      deltaMs: 0\n    });\n    this.scheduleAnimationFrame(onAnimationFrame);\n  }\n  cancelAnimation() {\n    if (this.requestId === null)\n      return;\n    cancelAnimationFrame(this.requestId);\n    this.requestId = null;\n    this.startBatch();\n  }\n  failsafeOnError(error, cancelAnimation = true) {\n    Logger.error(\"Error during animation, skipping animations\", error);\n    if (cancelAnimation) {\n      this.cancelAnimation();\n    }\n  }\n  startBatch(skipAnimations) {\n    this.debug(`AnimationManager - startBatch() with skipAnimations=${skipAnimations}.`);\n    this.reset();\n    this.batch.destroy();\n    this.batch = new AnimationBatch(this.defaultDuration * 1.5);\n    if (skipAnimations === true) {\n      this.batch.skip();\n    }\n  }\n  endBatch() {\n    if (this.batch.isActive()) {\n      this.batch.ready();\n      this.requestAnimation();\n    } else {\n      this.interactionManager.popState(2 /* Animation */);\n      if (this.batch.isSkipped()) {\n        this.batch.skip(false);\n      }\n    }\n  }\n  onBatchStop(cb) {\n    this.batch.stoppedCbs.add(cb);\n  }\n  destroy() {\n    this.stop();\n    this.events.clear();\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/chartEventManager.ts\nvar ChartEventManager = class extends BaseManager {\n  legendItemClick(series, itemId, enabled, legendItemName) {\n    const event = {\n      type: \"legend-item-click\",\n      series,\n      itemId,\n      enabled,\n      legendItemName\n    };\n    this.listeners.dispatch(\"legend-item-click\", event);\n  }\n  legendItemDoubleClick(series, itemId, enabled, numVisibleItems, legendItemName) {\n    const event = {\n      type: \"legend-item-double-click\",\n      series,\n      itemId,\n      enabled,\n      legendItemName,\n      numVisibleItems\n    };\n    this.listeners.dispatch(\"legend-item-double-click\", event);\n  }\n  axisHover(axisId, direction) {\n    const event = {\n      type: \"axis-hover\",\n      axisId,\n      direction\n    };\n    this.listeners.dispatch(\"axis-hover\", event);\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/contextMenuRegistry.ts\nvar ContextMenuRegistry = class _ContextMenuRegistry {\n  constructor(regionManager) {\n    this.defaultActions = [];\n    this.disabledActions = /* @__PURE__ */ new Set();\n    this.hiddenActions = /* @__PURE__ */ new Set();\n    this.listeners = new Listeners();\n    const { Default: Default2, ContextMenu } = InteractionState;\n    this.destroyFns = [regionManager.listenAll(\"contextmenu\", (e) => this.onContextMenu(e), Default2 | ContextMenu)];\n  }\n  destroy() {\n    this.destroyFns.forEach((d) => d());\n  }\n  onContextMenu(event) {\n    const type = _ContextMenuRegistry.toContextType(event.region);\n    if (type === \"all\") {\n      this.dispatchContext(\"all\", event, {});\n    }\n  }\n  static toContextType(region) {\n    if (region === \"legend\" || region === \"series\") {\n      return region;\n    }\n    return \"all\";\n  }\n  static check(type, event) {\n    return event.type === type;\n  }\n  static checkCallback(desiredType, type, _callback) {\n    return desiredType === type;\n  }\n  dispatchContext(type, pointerEvent, context, position) {\n    const { sourceEvent } = pointerEvent;\n    const x = position?.x ?? pointerEvent.offsetX;\n    const y = position?.y ?? pointerEvent.offsetY;\n    sourceEvent.stopPropagation();\n    this.listeners.dispatch(\"\", buildPreventable({ type, x, y, context, sourceEvent }));\n  }\n  addListener(handler) {\n    return this.listeners.addListener(\"\", handler);\n  }\n  filterActions(type) {\n    return this.defaultActions.filter((action) => {\n      return action.id && !this.hiddenActions.has(action.id) && [\"all\", type].includes(action.type);\n    });\n  }\n  registerDefaultAction(action) {\n    const didAdd = action.id != null && !this.defaultActions.some(({ id }) => id === action.id);\n    if (didAdd) {\n      this.defaultActions.push(action);\n    }\n    return () => {\n      const index = didAdd ? this.defaultActions.findIndex(({ id }) => id === action.id) : -1;\n      if (index !== -1) {\n        this.defaultActions.splice(index, 1);\n      }\n    };\n  }\n  enableAction(actionId) {\n    this.disabledActions.delete(actionId);\n  }\n  disableAction(actionId) {\n    this.disabledActions.add(actionId);\n  }\n  showAction(actionId) {\n    this.hiddenActions.add(actionId);\n  }\n  hideAction(actionId) {\n    this.hiddenActions.delete(actionId);\n  }\n  isDisabled(actionId) {\n    return this.disabledActions.has(actionId);\n  }\n};\n\n// packages/ag-charts-community/src/util/stateTracker.ts\nvar StateTracker = class extends Map {\n  constructor(defaultValue, defaultState) {\n    super();\n    this.defaultValue = defaultValue;\n    this.defaultState = defaultState;\n  }\n  set(key, value) {\n    this.delete(key);\n    if (typeof value !== \"undefined\") {\n      super.set(key, value);\n    }\n    return this;\n  }\n  stateId() {\n    return Array.from(this.keys()).pop() ?? this.defaultState;\n  }\n  stateValue() {\n    return Array.from(this.values()).pop() ?? this.defaultValue;\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/cursorManager.ts\nvar Cursor = /* @__PURE__ */ ((Cursor2) => {\n  Cursor2[\"Auto\"] = \"auto\";\n  Cursor2[\"Default\"] = \"default\";\n  Cursor2[\"Grab\"] = \"grab\";\n  Cursor2[\"Grabbing\"] = \"grabbing\";\n  Cursor2[\"Move\"] = \"move\";\n  Cursor2[\"NotAllowed\"] = \"not-allowed\";\n  Cursor2[\"Pointer\"] = \"pointer\";\n  Cursor2[\"EWResize\"] = \"ew-resize\";\n  Cursor2[\"NSResize\"] = \"ns-resize\";\n  Cursor2[\"ZoomIn\"] = \"zoom-in\";\n  Cursor2[\"ZoomOut\"] = \"zoom-out\";\n  return Cursor2;\n})(Cursor || {});\nvar CursorManager = class {\n  constructor(domManager) {\n    this.domManager = domManager;\n    this.stateTracker = new StateTracker(\"default\");\n  }\n  updateCursor(callerId, style) {\n    this.stateTracker.set(callerId, style);\n    this.domManager.updateCursor(this.stateTracker.stateValue());\n  }\n  getCursor() {\n    return this.domManager.getCursor();\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/gestureDetector.ts\nfunction distanceSquared(finger1, finger2) {\n  const dx = finger1.screenX - finger2.screenX;\n  const dy = finger1.screenY - finger2.screenY;\n  return dx * dx + dy * dy;\n}\nfunction distance(finger1, finger2) {\n  return Math.sqrt(distanceSquared(finger1, finger2));\n}\nvar MIN_DISTANCE_TO_START_PINCH = 1;\nvar GestureDetector = class extends BaseManager {\n  constructor(domManager) {\n    super();\n    this.domManager = domManager;\n    this.touchstart = (event) => this.onTouchStart(event);\n    this.touchmove = (event) => this.onTouchMove(event);\n    this.touchend = (event) => this.onTouchEnd(event);\n    this.touchcancel = (event) => this.onTouchCancel(event);\n    this.pinch = {\n      finger1: { identifier: NaN, screenX: NaN, screenY: NaN },\n      finger2: { identifier: NaN, screenX: NaN, screenY: NaN },\n      origin: { x: NaN, y: NaN },\n      distance: NaN,\n      status: 0 /* Off */\n    };\n    this.domManager.addEventListener(\"touchstart\", this.touchstart, { passive: true });\n    this.domManager.addEventListener(\"touchmove\", this.touchmove, { passive: false });\n    this.domManager.addEventListener(\"touchend\", this.touchend);\n    this.domManager.addEventListener(\"touchcancel\", this.touchcancel);\n  }\n  destroy() {\n    this.domManager.removeEventListener(\"touchstart\", this.touchstart);\n    this.domManager.removeEventListener(\"touchmove\", this.touchmove);\n    this.domManager.removeEventListener(\"touchend\", this.touchend);\n    this.domManager.removeEventListener(\"touchcancel\", this.touchcancel);\n  }\n  findPinchTouches(moveEvent) {\n    const { touches } = moveEvent;\n    const { finger1, finger2 } = this.pinch;\n    if (this.pinch.status !== 0 /* Off */ && touches.length === 2) {\n      if (touches[0].identifier === finger1.identifier && touches[1].identifier === finger2.identifier) {\n        return [touches[0], touches[1]];\n      }\n      if (touches[0].identifier === finger2.identifier && touches[1].identifier === finger1.identifier) {\n        return [touches[1], touches[0]];\n      }\n    }\n  }\n  copyTouchData(event) {\n    const keys = [\"identifier\", \"screenX\", \"screenY\"];\n    partialAssign(keys, this.pinch.finger1, event.touches[0]);\n    partialAssign(keys, this.pinch.finger2, event.touches[1]);\n    this.pinch.distance = distance(this.pinch.finger1, this.pinch.finger2);\n  }\n  dispatchPinchEvent(type, deltaDistance, sourceEvent) {\n    const { finger1, finger2, origin: origin3 } = this.pinch;\n    this.listeners.dispatch(type, buildPreventable({ sourceEvent, type, finger1, finger2, deltaDistance, origin: origin3 }));\n  }\n  onTouchStart(event) {\n    this.stopPinchTracking(event);\n    const { pinch } = this;\n    if (event.touches.length === 2) {\n      pinch.status = 1 /* Initialized */;\n      this.copyTouchData(event);\n      pinch.origin.x = (event.touches[0].clientX + event.touches[1].clientX) / 2;\n      pinch.origin.y = (event.touches[0].clientY + event.touches[1].clientY) / 2;\n    }\n  }\n  onTouchMove(event) {\n    const pinchTouches = this.findPinchTouches(event);\n    if (pinchTouches !== void 0) {\n      const [touch1, touch2] = pinchTouches;\n      const { pinch } = this;\n      const newDistance = distance(touch1, touch2);\n      const deltaDistance = newDistance - pinch.distance;\n      if (pinch.status === 1 /* Initialized */) {\n        if (Math.abs(deltaDistance) > MIN_DISTANCE_TO_START_PINCH) {\n          pinch.status = 2 /* Running */;\n          this.copyTouchData(event);\n          this.dispatchPinchEvent(\"pinch-start\", 0, event);\n        }\n      } else if (pinch.status === 2 /* Running */) {\n        pinch.distance = newDistance;\n        this.copyTouchData(event);\n        this.dispatchPinchEvent(\"pinch-move\", deltaDistance, event);\n      } else {\n        Logger.error(`unexpected pinch.status: ${pinch.status}`);\n      }\n    }\n  }\n  onTouchEnd(event) {\n    this.stopPinchTracking(event);\n  }\n  onTouchCancel(event) {\n    this.stopPinchTracking(event);\n  }\n  stopPinchTracking(event) {\n    const { pinch } = this;\n    if (pinch.status === 2 /* Running */) {\n      this.dispatchPinchEvent(\"pinch-end\", 0, event);\n    }\n    this.pinch.status = 0 /* Off */;\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/highlightManager.ts\nvar HighlightManager = class extends BaseManager {\n  constructor() {\n    super(...arguments);\n    this.highlightStates = new StateTracker();\n  }\n  updateHighlight(callerId, highlightedDatum) {\n    const { activeHighlight: previousHighlight } = this;\n    this.highlightStates.set(callerId, highlightedDatum);\n    this.activeHighlight = this.highlightStates.stateValue();\n    if (!this.isEqual(this.activeHighlight, previousHighlight)) {\n      this.listeners.dispatch(\"highlight-change\", {\n        type: \"highlight-change\",\n        currentHighlight: this.activeHighlight,\n        previousHighlight,\n        callerId\n      });\n    }\n  }\n  getActiveHighlight() {\n    return this.activeHighlight;\n  }\n  isEqual(a, b) {\n    return a === b || a != null && b != null && a?.series === b?.series && a?.itemId === b?.itemId && a?.datum === b?.datum;\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/keyNavManager.ts\nvar KeyNavManager = class extends InteractionStateListener {\n  constructor(focusIndicator, interactionManager, mode) {\n    super();\n    this.focusIndicator = focusIndicator;\n    this.interactionManager = interactionManager;\n    // This is the \"second last\" input event. It can be useful for keydown\n    // events that for which don't to set the isFocusVisible state\n    // (e.g. Backspace/Delete key on FC annotations, see AG-13041).\n    //\n    // Use with caution! The focus indicator must ALWAYS be visible for\n    // keyboard-only users.\n    this.previousInputDevice = \"keyboard\";\n    const mouseStates = 32 /* Default */ | 8 /* Annotations */ | 1 /* AnnotationsSelected */;\n    this.destroyFns.push(\n      interactionManager.addListener(\"click\", () => this.onClick(), mouseStates),\n      interactionManager.addListener(\"hover\", () => this.onMouse(), mouseStates),\n      interactionManager.addListener(\"drag-start\", () => this.onMouse(), mouseStates),\n      interactionManager.addListener(\"blur\", (e) => this.onBlur(e), 63 /* All */),\n      interactionManager.addListener(\"focus\", (e) => this.onFocus(e), 63 /* All */),\n      interactionManager.addListener(\"keydown\", (e) => this.onKeyDown(e), 63 /* All */)\n    );\n    this.focusIndicator.overrideFocusVisible(mode === \"integrated\" ? false : void 0);\n  }\n  getState() {\n    return this.interactionManager.getState();\n  }\n  destroy() {\n    super.destroy();\n  }\n  onClick() {\n    this.focusIndicator.overrideFocusVisible(false);\n    this.previousInputDevice = \"mouse\";\n  }\n  onMouse() {\n    this.previousInputDevice = \"mouse\";\n  }\n  onBlur(event) {\n    this.focusIndicator.overrideFocusVisible(void 0);\n    this.dispatch(\"blur\", 0, event);\n  }\n  onFocus(event) {\n    this.dispatch(\"focus\", 0, event);\n  }\n  onKeyDown(event) {\n    const state = this.getState();\n    const { key, code, altKey, shiftKey, metaKey, ctrlKey } = event.sourceEvent;\n    if (ctrlKey || metaKey) {\n      if (key === \"y\" || key === \"z\" && shiftKey) {\n        this.focusIndicator.overrideFocusVisible(this.previousInputDevice === \"keyboard\");\n        return this.dispatch(\"redo\", 0, event);\n      } else if (key === \"z\") {\n        this.focusIndicator.overrideFocusVisible(this.previousInputDevice === \"keyboard\");\n        return this.dispatch(\"undo\", 0, event);\n      }\n    }\n    if (state & (8 /* Annotations */ | 1 /* AnnotationsSelected */)) {\n      this.focusIndicator.overrideFocusVisible(false);\n      return;\n    }\n    switch (key) {\n      case \"+\":\n        return this.dispatch(\"nav-zoom\", 1, event);\n      case \"-\":\n        return this.dispatch(\"nav-zoom\", -1, event);\n    }\n    if (altKey || shiftKey || metaKey || ctrlKey)\n      return;\n    this.focusIndicator.overrideFocusVisible(true);\n    switch (code) {\n      case \"ArrowDown\":\n        return this.dispatch(\"nav-vert\", 1, event);\n      case \"ArrowUp\":\n        return this.dispatch(\"nav-vert\", -1, event);\n      case \"ArrowLeft\":\n        return this.dispatch(\"nav-hori\", -1, event);\n      case \"ArrowRight\":\n        return this.dispatch(\"nav-hori\", 1, event);\n      case \"ZoomIn\":\n      case \"Add\":\n        return this.dispatch(\"nav-zoom\", 1, event);\n      case \"ZoomOut\":\n      case \"Substract\":\n        return this.dispatch(\"nav-zoom\", -1, event);\n      case \"Space\":\n      case \"Enter\":\n        return this.dispatch(\"submit\", 0, event);\n    }\n  }\n  dispatch(type, delta4, sourceEvent) {\n    const { previousInputDevice } = this;\n    dispatchTypedEvent(this.listeners, { type, delta: delta4, sourceEvent, previousInputDevice });\n    const sharedKbmTypes = [\"redo\", \"undo\", \"nav-zoom\"];\n    if (sourceEvent.type === \"keydown\" && !sharedKbmTypes.includes(type)) {\n      this.previousInputDevice = \"keyboard\";\n    }\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/regions.ts\nvar REGIONS = /* @__PURE__ */ ((REGIONS2) => {\n  REGIONS2[\"NAVIGATOR\"] = \"navigator\";\n  REGIONS2[\"ROOT\"] = \"root\";\n  REGIONS2[\"SERIES\"] = \"series\";\n  REGIONS2[\"HORIZONTAL_AXES\"] = \"horizontal-axes\";\n  REGIONS2[\"VERTICAL_AXES\"] = \"vertical-axes\";\n  return REGIONS2;\n})(REGIONS || {});\nvar NodeRegionBBoxProvider = class {\n  constructor(node, overrideId) {\n    this.node = node;\n    this.overrideId = overrideId;\n  }\n  get id() {\n    return this.overrideId ?? this.node.id;\n  }\n  get visible() {\n    return this.node.visible;\n  }\n  toCanvasBBox() {\n    return Transformable.toCanvas(this.node);\n  }\n  fromCanvasPoint(x, y) {\n    return Transformable.fromCanvasPoint(this.node, x, y);\n  }\n};\nvar SimpleRegionBBoxProvider = class extends NodeRegionBBoxProvider {\n  constructor(node, bboxFn, overrideId) {\n    super(node, overrideId);\n    this.bboxFn = bboxFn;\n  }\n  toCanvasBBox() {\n    return this.bboxFn();\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/regionManager.ts\nvar RegionListeners = class extends Listeners {\n};\nfunction addHandler(listeners, interactionManager, type, handler, triggeringStates = 32 /* Default */) {\n  return listeners?.addListener(type, (e) => {\n    const currentState = interactionManager.getState();\n    if (currentState & triggeringStates) {\n      handler(e);\n    }\n  }) ?? (() => {\n  });\n}\nfunction nodeToBBoxProvider(node) {\n  if (node instanceof Node) {\n    return new NodeRegionBBoxProvider(node);\n  }\n  if (node instanceof NodeRegionBBoxProvider) {\n    return node;\n  }\n  return new NodeRegionBBoxProvider(node.node, node.id);\n}\nfunction getTooltipContainer(target) {\n  if (target == null || !(target instanceof HTMLElement))\n    return void 0;\n  let current = target;\n  while (current != null && !current?.classList.contains(\"ag-charts-wrapper\")) {\n    if (current.classList.contains(\"ag-chart-tooltip\")) {\n      return current;\n    }\n    current = current.parentElement;\n  }\n  return void 0;\n}\nfunction shouldIgnore(event) {\n  const { type, sourceEvent } = event;\n  const { id, className, classList, ariaHidden } = sourceEvent?.target ?? {};\n  if (!(classList instanceof DOMTokenList))\n    return \"leave\";\n  const dragTypes = DRAG_INTERACTION_TYPES;\n  if (\n    // Handle drag event on the axis 'add horizontal line annotation' button as canvas events.\n    classList.contains(\"ag-charts-annotations__axis-button-icon\") && !dragTypes.includes(type) || className === \"ag-charts-series-area\" || className === \"ag-charts-canvas-proxy\" || className === \"ag-charts-proxy-elem\" && !id?.toString().startsWith(\"ag-charts-legend-item-\") || // legend <buttons>\n    sourceEvent?.target instanceof HTMLCanvasElement\n  ) {\n    return \"none\";\n  }\n  if (getTooltipContainer(sourceEvent.target) && ariaHidden !== \"true\") {\n    return \"wait\";\n  }\n  return \"leave\";\n}\nvar RegionManager = class {\n  constructor(interactionManager) {\n    this.interactionManager = interactionManager;\n    this.debug = Debug.create(true, \"region\");\n    this.isDragging = false;\n    this.leftCanvas = false;\n    this.regions = /* @__PURE__ */ new Map();\n    this.destroyFns = [];\n    this.allRegionsListeners = new RegionListeners();\n    this.destroyFns.push(\n      ...POINTER_INTERACTION_TYPES.map(\n        (eventName) => interactionManager.addListener(eventName, this.processPointerEvent.bind(this), 63 /* All */)\n      )\n    );\n  }\n  destroy() {\n    this.destroyFns.forEach((fn) => fn());\n    this.current = void 0;\n    for (const region of this.regions.values()) {\n      region.listeners.destroy();\n    }\n    this.regions.clear();\n  }\n  addRegion(name, ...nodes) {\n    if (this.regions.has(name)) {\n      throw new Error(`AG Charts - Region: ${name} already exists`);\n    }\n    const region = {\n      properties: { name, bboxproviders: nodes.map(nodeToBBoxProvider) },\n      listeners: new RegionListeners()\n    };\n    this.regions.set(name, region);\n    return this.makeObserver(region);\n  }\n  updateRegion(name, ...nodes) {\n    const region = this.regions.get(name);\n    if (region) {\n      region.properties.bboxproviders = nodes.map(nodeToBBoxProvider);\n    } else {\n      throw new Error(\"AG Charts - unknown region: \" + name);\n    }\n  }\n  getRegion(name) {\n    return this.makeObserver(this.regions.get(name));\n  }\n  listenAll(type, handler, triggeringStates = 32 /* Default */) {\n    return addHandler(this.allRegionsListeners, this.interactionManager, type, handler, triggeringStates);\n  }\n  // This method return a wrapper object that matches the interface of InteractionManager.addListener.\n  // The intent is to allow the InteractionManager and RegionManager to be used almost interchangeably.\n  makeObserver(region) {\n    const { interactionManager } = this;\n    class ObservableRegionImplementation {\n      addListener(type, handler, triggeringStates = 32 /* Default */) {\n        return addHandler(region?.listeners, interactionManager, type, handler, triggeringStates);\n      }\n    }\n    return new ObservableRegionImplementation();\n  }\n  checkPointerHistory(targetRegion, event) {\n    for (const historyEvent of event.pointerHistory) {\n      const { region: historyRegion } = this.pickRegion(historyEvent.offsetX, historyEvent.offsetY) ?? {};\n      if (targetRegion.properties.name !== historyRegion?.properties.name) {\n        return false;\n      }\n    }\n    return true;\n  }\n  // Create and dispatch a copy of the InteractionEvent.\n  dispatch(current, partialEvent) {\n    if (current == null)\n      return;\n    const mainBBoxProvider = current.region.properties.bboxproviders[0];\n    let regionOffsetX = 0;\n    let regionOffsetY = 0;\n    if (\"offsetX\" in partialEvent && \"offsetY\" in partialEvent) {\n      ({ x: regionOffsetX, y: regionOffsetY } = mainBBoxProvider.fromCanvasPoint(\n        partialEvent.offsetX,\n        partialEvent.offsetY\n      ));\n    } else {\n      const regionBBox = mainBBoxProvider.toCanvasBBox();\n      regionOffsetX = regionBBox.width / 2;\n      regionOffsetY = regionBBox.height / 2;\n    }\n    const event = buildPreventable({\n      ...partialEvent,\n      region: current.region.properties.name,\n      bboxProviderId: current.bboxProvider?.id,\n      regionOffsetX,\n      regionOffsetY\n    });\n    this.debug(\"Dispatching region event: \", event);\n    this.allRegionsListeners.dispatch(event.type, event);\n    current.region.listeners.dispatch(event.type, event);\n  }\n  // Process events during a drag action. Returns false if this event should follow the standard\n  // RegionManager.processEvent flow, or true if this event already processed by this function.\n  handleDragging(event) {\n    const { current } = this;\n    switch (event.type) {\n      case \"drag-start\":\n        this.isDragging = true;\n        this.leftCanvas = false;\n        break;\n      case \"leave\":\n        this.leftCanvas = true;\n        return this.isDragging;\n      case \"enter\":\n        this.leftCanvas = false;\n        return this.isDragging;\n      case \"drag\":\n        if (this.isDragging) {\n          this.dispatch(current, event);\n          return true;\n        }\n        break;\n      case \"drag-end\":\n        if (this.isDragging) {\n          this.isDragging = false;\n          this.dispatch(current, event);\n          if (this.leftCanvas) {\n            this.dispatch(current, { ...event, type: \"leave\" });\n          }\n          return true;\n        }\n        break;\n    }\n    return false;\n  }\n  processPointerEvent(event) {\n    if (this.handleDragging(event)) {\n      return;\n    }\n    const { current } = this;\n    const ignore = shouldIgnore(event);\n    let newCurrent;\n    switch (ignore) {\n      case \"wait\":\n        return;\n      case \"none\":\n        newCurrent = this.pickRegion(event.offsetX, event.offsetY);\n        break;\n      case \"leave\":\n        newCurrent = void 0;\n        break;\n    }\n    const newRegion = newCurrent?.region;\n    if (current !== void 0 && newRegion?.properties.name !== current.region.properties.name) {\n      this.dispatch(current, { ...event, type: \"leave\" });\n    }\n    if (newRegion !== void 0 && newRegion.properties.name !== current?.region.properties.name) {\n      this.dispatch(newCurrent, { ...event, type: \"enter\" });\n    }\n    if (newRegion !== void 0 && this.checkPointerHistory(newRegion, event)) {\n      this.dispatch(newCurrent, event);\n    }\n    this.current = newCurrent;\n  }\n  pickRegion(x, y) {\n    let currentArea = Infinity;\n    let currentRegion;\n    let currentBBoxProvider;\n    for (const region of this.regions.values()) {\n      for (const provider of region.properties.bboxproviders) {\n        if (provider.visible === false)\n          continue;\n        const bbox = provider.toCanvasBBox();\n        const area2 = bbox.width * bbox.height;\n        if (area2 < currentArea && bbox.containsPoint(x, y)) {\n          currentArea = area2;\n          currentRegion = region;\n          currentBBoxProvider = provider;\n        }\n      }\n    }\n    return currentRegion ? { region: currentRegion, bboxProvider: currentBBoxProvider } : void 0;\n  }\n};\n\n// packages/ag-charts-community/src/chart/toolbar/toolbarTypes.ts\nvar TOOLBAR_ALIGNMENTS = [\"start\", \"center\", \"end\"];\nvar TOOLBAR_GROUPS = [\"seriesType\", \"annotations\", \"annotationOptions\", \"ranges\", \"zoom\"];\nvar TOOLBAR_GROUP_ORDERING = {\n  seriesType: 0,\n  annotations: 1,\n  annotationOptions: 2,\n  ranges: 3,\n  zoom: 4\n};\nvar ToolbarPosition = /* @__PURE__ */ ((ToolbarPosition2) => {\n  ToolbarPosition2[\"Top\"] = \"top\";\n  ToolbarPosition2[\"Left\"] = \"left\";\n  ToolbarPosition2[\"Right\"] = \"right\";\n  ToolbarPosition2[\"Bottom\"] = \"bottom\";\n  ToolbarPosition2[\"Floating\"] = \"floating\";\n  ToolbarPosition2[\"FloatingTop\"] = \"floating-top\";\n  ToolbarPosition2[\"FloatingBottom\"] = \"floating-bottom\";\n  return ToolbarPosition2;\n})(ToolbarPosition || {});\nvar TOOLBAR_POSITIONS = Object.values(ToolbarPosition);\nfunction isAnimatingFloatingPosition(position) {\n  return [\"floating-top\" /* FloatingTop */, \"floating-bottom\" /* FloatingBottom */].includes(position);\n}\n\n// packages/ag-charts-community/src/chart/interaction/toolbarManager.ts\nvar ToolbarManager = class extends BaseManager {\n  static isGroup(group, event) {\n    return event.group === group;\n  }\n  static isChildElement(domManager, element2) {\n    for (const position of TOOLBAR_POSITIONS) {\n      if (domManager.isManagedChildDOMElement(element2, \"canvas-overlay\", `toolbar-${position}`)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  pressButton(group, id, value, rect, sourceEvent) {\n    this.listeners.dispatch(\"button-pressed\", { type: \"button-pressed\", group, id, value, rect, sourceEvent });\n  }\n  cancel(group) {\n    this.listeners.dispatch(\"cancelled\", { type: \"cancelled\", group });\n  }\n  toggleButton(group, id, options) {\n    const { active = false, enabled = true, visible = true, checked = false } = options;\n    this.listeners.dispatch(\"button-toggled\", {\n      type: \"button-toggled\",\n      group,\n      id,\n      active,\n      enabled,\n      visible,\n      checked\n    });\n  }\n  updateButton(group, id, options) {\n    this.listeners.dispatch(\"button-updated\", { type: \"button-updated\", group, id, ...options });\n  }\n  toggleGroup(caller, group, options) {\n    const { active, visible } = options;\n    this.listeners.dispatch(\"group-toggled\", { type: \"group-toggled\", caller, group, active, visible });\n  }\n  updateGroup(group) {\n    this.listeners.dispatch(\"group-updated\", { type: \"group-updated\", group });\n  }\n  groupMoved(group) {\n    this.listeners.dispatch(\"group-moved\", { type: \"group-moved\", group });\n  }\n  changeFloatingAnchor(group, anchor) {\n    this.listeners.dispatch(\"floating-anchor-changed\", {\n      type: \"floating-anchor-changed\",\n      group,\n      anchor\n    });\n  }\n  buttonMoved(group, value, rect, groupRect) {\n    this.listeners.dispatch(\"button-moved\", { type: \"button-moved\", group, value, rect, groupRect });\n  }\n  proxyGroupOptions(caller, group, options) {\n    this.listeners.dispatch(\"proxy-group-options\", { type: \"proxy-group-options\", caller, group, options });\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/tooltipManager.ts\nvar TooltipManager = class {\n  constructor(domManager, tooltip) {\n    this.domManager = domManager;\n    this.tooltip = tooltip;\n    this.stateTracker = new StateTracker();\n    this.suppressState = new StateTracker(false);\n    this.appliedState = null;\n    tooltip.setup(domManager);\n    domManager.addListener(\"hidden\", () => this.tooltip.toggle(false));\n  }\n  updateTooltip(callerId, meta, content) {\n    if (!this.tooltip.enabled)\n      return;\n    content ?? (content = this.stateTracker.get(callerId)?.content);\n    this.stateTracker.set(callerId, { content, meta });\n    this.applyStates();\n  }\n  removeTooltip(callerId) {\n    if (!this.tooltip.enabled)\n      return;\n    this.stateTracker.delete(callerId);\n    this.applyStates();\n  }\n  suppressTooltip(callerId) {\n    this.suppressState.set(callerId, true);\n  }\n  unsuppressTooltip(callerId) {\n    this.suppressState.delete(callerId);\n  }\n  getTooltipMeta(callerId) {\n    return this.stateTracker.get(callerId)?.meta;\n  }\n  destroy() {\n    this.domManager.removeStyles(\"tooltip\");\n  }\n  applyStates() {\n    const id = this.stateTracker.stateId();\n    const state = id ? this.stateTracker.get(id) : null;\n    if (this.suppressState.stateValue() || state?.meta == null || state?.content == null) {\n      this.appliedState = null;\n      this.tooltip.toggle(false);\n      return;\n    }\n    const canvasRect = this.domManager.getBoundingClientRect();\n    const boundingRect = this.tooltip.bounds === \"extended\" ? this.domManager.getOverlayClientRect() : canvasRect;\n    if (this.appliedState?.content === state?.content) {\n      const renderInstantly = this.tooltip.isVisible();\n      this.tooltip.show(boundingRect, canvasRect, state?.meta, null, renderInstantly);\n    } else {\n      this.tooltip.show(boundingRect, canvasRect, state?.meta, state?.content);\n    }\n    this.appliedState = state;\n  }\n  static makeTooltipMeta(event, datum) {\n    const { offsetX, offsetY } = event;\n    const tooltip = datum.series.properties.tooltip;\n    const meta = {\n      offsetX,\n      offsetY,\n      enableInteraction: tooltip.interaction?.enabled ?? false,\n      lastPointerEvent: { type: event.type, offsetX, offsetY },\n      showArrow: tooltip.showArrow,\n      position: {\n        type: tooltip.position.type,\n        xOffset: tooltip.position.xOffset,\n        yOffset: tooltip.position.yOffset\n      }\n    };\n    const refPoint = datum.yBar?.upperPoint ?? datum.midPoint ?? datum.series.datumMidPoint?.(datum);\n    if ((tooltip.position.type === \"node\" || tooltip.position.type === \"sparkline\") && refPoint) {\n      const { x, y } = refPoint;\n      const point = Transformable.toCanvasPoint(datum.series.contentGroup, x, y);\n      return {\n        ...meta,\n        offsetX: Math.round(point.x),\n        offsetY: Math.round(point.y)\n      };\n    }\n    return meta;\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/zoomManager.ts\nvar ZoomManager = class extends BaseManager {\n  constructor() {\n    super(...arguments);\n    this.mementoOriginatorKey = \"zoom\";\n    this.axisZoomManagers = /* @__PURE__ */ new Map();\n    this.state = new StateTracker(void 0, \"initial\");\n    this.rejectCallbacks = /* @__PURE__ */ new Map();\n  }\n  addLayoutListeners(layoutManager) {\n    this.destroyFns.push(\n      layoutManager.addListener(\"layout:complete\", (event) => {\n        this.axes = event.axes;\n      })\n    );\n  }\n  createMemento() {\n    const zoom2 = this.getDefinedZoom();\n    return {\n      rangeX: this.getRangeDirection(zoom2, \"x\" /* X */),\n      rangeY: this.getRangeDirection(zoom2, \"y\" /* Y */),\n      ratioX: { start: zoom2.x.min, end: zoom2.x.max },\n      ratioY: { start: zoom2.y.min, end: zoom2.y.max }\n    };\n  }\n  guardMemento(blob) {\n    return isObject(blob) && (blob.ratioX != null || blob.ratioY != null || blob.rangeX != null || blob.rangeY != null);\n  }\n  restoreMemento(_version, _mementoVersion, memento) {\n    this.listeners.dispatch(\"restore-zoom\", { ...memento, type: \"restore-zoom\" });\n  }\n  updateAxes(axes) {\n    const zoomManagers = new Map(axes.map((axis) => [axis.id, this.axisZoomManagers.get(axis.id)]));\n    this.axisZoomManagers.clear();\n    for (const axis of axes) {\n      this.axisZoomManagers.set(axis.id, zoomManagers.get(axis.id) ?? new AxisZoomManager(axis));\n    }\n    if (this.state.size > 0 && axes.length > 0) {\n      this.updateZoom(this.state.stateId(), this.state.stateValue());\n    }\n  }\n  updateZoom(callerId, newZoom, canChangeInitial = true, rejectCallback) {\n    if (rejectCallback) {\n      this.rejectCallbacks.set(callerId, rejectCallback);\n    }\n    if (this.axisZoomManagers.size === 0) {\n      const stateId = this.state.stateId();\n      if (stateId === \"initial\" || stateId === callerId || canChangeInitial) {\n        this.state.set(callerId, newZoom);\n        if (stateId !== callerId) {\n          this.rejectCallbacks.get(stateId)?.(callerId);\n        }\n      } else {\n        rejectCallback?.(stateId);\n      }\n      return;\n    }\n    this.state.set(callerId, newZoom);\n    this.axisZoomManagers.forEach((axis) => {\n      axis.updateZoom(callerId, newZoom?.[axis.getDirection()]);\n    });\n    this.applyChanges(callerId);\n  }\n  updateAxisZoom(callerId, axisId, newZoom) {\n    this.axisZoomManagers.get(axisId)?.updateZoom(callerId, newZoom);\n    this.applyChanges(callerId);\n  }\n  // Fire this event to signal to listeners that the view is changing through a zoom and/or pan change.\n  fireZoomPanStartEvent(callerId) {\n    this.listeners.dispatch(\"zoom-pan-start\", { type: \"zoom-pan-start\", callerId });\n  }\n  getZoom() {\n    let x;\n    let y;\n    this.axisZoomManagers.forEach((axis) => {\n      if (axis.getDirection() === \"x\" /* X */) {\n        x ?? (x = axis.getZoom());\n      } else if (axis.getDirection() === \"y\" /* Y */) {\n        y ?? (y = axis.getZoom());\n      }\n    });\n    if (x || y) {\n      return { x, y };\n    }\n  }\n  getAxisZoom(axisId) {\n    return this.axisZoomManagers.get(axisId)?.getZoom() ?? { min: 0, max: 1 };\n  }\n  getAxisZooms() {\n    const axes = {};\n    for (const [axisId, axis] of this.axisZoomManagers.entries()) {\n      axes[axisId] = {\n        direction: axis.getDirection(),\n        zoom: axis.getZoom()\n      };\n    }\n    return axes;\n  }\n  applyChanges(callerId) {\n    const changed = Array.from(this.axisZoomManagers.values(), (axis) => axis.applyChanges()).some(Boolean);\n    if (!changed) {\n      return;\n    }\n    const axes = {};\n    for (const [axisId, axis] of this.axisZoomManagers.entries()) {\n      axes[axisId] = axis.getZoom();\n    }\n    this.listeners.dispatch(\"zoom-change\", { type: \"zoom-change\", ...this.getZoom(), axes, callerId });\n  }\n  getRangeDirection(zoom2, direction) {\n    for (const axis of this.axes ?? []) {\n      if (axis.direction !== direction)\n        continue;\n      const domain = axis.scale.getDomain?.();\n      const d0 = axis.scale.convert?.(domain?.at(0));\n      const d1 = axis.scale.convert?.(domain?.at(-1));\n      if (!isFiniteNumber(d0) || !isFiniteNumber(d1))\n        return;\n      let start2;\n      let end2;\n      if (d0 <= d1) {\n        const diff2 = d1 - d0;\n        start2 = axis.scale.invert?.(0);\n        end2 = axis.scale.invert?.(d0 + diff2 * zoom2[direction].max);\n      } else {\n        const diff2 = d0 - d1;\n        start2 = axis.scale.invert?.(d0 - diff2 * zoom2[direction].min);\n        end2 = axis.scale.invert?.(0);\n      }\n      return { start: start2, end: end2 };\n    }\n  }\n  getDefinedZoom() {\n    const zoom2 = this.getZoom();\n    return {\n      x: { min: zoom2?.x?.min ?? 0, max: zoom2?.x?.max ?? 1 },\n      y: { min: zoom2?.y?.min ?? 0, max: zoom2?.y?.max ?? 1 }\n    };\n  }\n};\nvar AxisZoomManager = class {\n  constructor(axis) {\n    this.axis = axis;\n    const [min = 0, max = 1] = axis.visibleRange;\n    this.state = new StateTracker({ min, max });\n    this.currentZoom = this.state.stateValue();\n  }\n  getDirection() {\n    return this.axis.direction;\n  }\n  updateZoom(callerId, newZoom) {\n    this.state.set(callerId, newZoom);\n  }\n  getZoom() {\n    return deepClone(this.state.stateValue());\n  }\n  applyChanges() {\n    const prevZoom = this.currentZoom;\n    this.currentZoom = this.state.stateValue();\n    return prevZoom.min !== this.currentZoom.min || prevZoom.max !== this.currentZoom.max;\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/seriesStateManager.ts\nvar SeriesStateManager = class {\n  constructor() {\n    this.groups = {};\n  }\n  registerSeries({ internalId, seriesGrouping, visible, type }) {\n    var _a;\n    if (!seriesGrouping)\n      return;\n    (_a = this.groups)[type] ?? (_a[type] = {});\n    this.groups[type][internalId] = { grouping: seriesGrouping, visible };\n  }\n  updateSeries({ internalId, seriesGrouping, visible, type }) {\n    if (!seriesGrouping)\n      return;\n    const entry = this.groups[type]?.[internalId];\n    if (entry) {\n      entry.grouping = seriesGrouping;\n      entry.visible = visible;\n    }\n  }\n  deregisterSeries({ internalId, type }) {\n    if (this.groups[type]) {\n      delete this.groups[type][internalId];\n    }\n    if (this.groups[type] && Object.keys(this.groups[type]).length === 0) {\n      delete this.groups[type];\n    }\n  }\n  getVisiblePeerGroupIndex({ type, seriesGrouping, visible }) {\n    if (!seriesGrouping)\n      return { visibleGroupCount: visible ? 1 : 0, visibleSameStackCount: visible ? 1 : 0, index: 0 };\n    const visibleGroupsSet = /* @__PURE__ */ new Set();\n    const visibleSameStackSet = /* @__PURE__ */ new Set();\n    for (const entry of Object.values(this.groups[type] ?? {})) {\n      if (!entry.visible)\n        continue;\n      visibleGroupsSet.add(entry.grouping.groupIndex);\n      if (entry.grouping.groupIndex === seriesGrouping.groupIndex) {\n        visibleSameStackSet.add(entry.grouping.stackIndex);\n      }\n    }\n    const visibleGroups = Array.from(visibleGroupsSet);\n    visibleGroups.sort((a, b) => a - b);\n    return {\n      visibleGroupCount: visibleGroups.length,\n      visibleSameStackCount: visibleSameStackSet.size,\n      index: visibleGroups.indexOf(seriesGrouping.groupIndex)\n    };\n  }\n};\n\n// packages/ag-charts-community/src/chart/chartUpdateType.ts\nvar ChartUpdateType = /* @__PURE__ */ ((ChartUpdateType2) => {\n  ChartUpdateType2[ChartUpdateType2[\"FULL\"] = 0] = \"FULL\";\n  ChartUpdateType2[ChartUpdateType2[\"UPDATE_DATA\"] = 1] = \"UPDATE_DATA\";\n  ChartUpdateType2[ChartUpdateType2[\"PROCESS_DATA\"] = 2] = \"PROCESS_DATA\";\n  ChartUpdateType2[ChartUpdateType2[\"PERFORM_LAYOUT\"] = 3] = \"PERFORM_LAYOUT\";\n  ChartUpdateType2[ChartUpdateType2[\"SERIES_UPDATE\"] = 4] = \"SERIES_UPDATE\";\n  ChartUpdateType2[ChartUpdateType2[\"PRE_SCENE_RENDER\"] = 5] = \"PRE_SCENE_RENDER\";\n  ChartUpdateType2[ChartUpdateType2[\"SCENE_RENDER\"] = 6] = \"SCENE_RENDER\";\n  ChartUpdateType2[ChartUpdateType2[\"NONE\"] = 7] = \"NONE\";\n  return ChartUpdateType2;\n})(ChartUpdateType || {});\n\n// packages/ag-charts-community/src/chart/updateService.ts\nvar UpdateService = class extends Listeners {\n  constructor(updateCallback) {\n    super();\n    this.updateCallback = updateCallback;\n  }\n  update(type = 0 /* FULL */, options) {\n    this.updateCallback(type, options);\n  }\n  dispatchUpdateComplete(rects) {\n    this.dispatch(\"update-complete\", {\n      type: \"update-complete\",\n      minRect: rects?.minRect,\n      minVisibleRect: rects?.minVisibleRect\n    });\n  }\n  dispatchPreDomUpdate() {\n    this.dispatch(\"pre-dom-update\", { type: \"pre-dom-update\" });\n  }\n  dispatchPreSceneRender(rects) {\n    this.dispatch(\"pre-scene-render\", { type: \"pre-scene-render\", ...rects });\n  }\n};\n\n// packages/ag-charts-community/src/chart/chartContext.ts\nvar ChartContext = class {\n  constructor(chart, vars) {\n    this.callbackCache = new CallbackCache();\n    this.chartEventManager = new ChartEventManager();\n    this.highlightManager = new HighlightManager();\n    this.layoutManager = new LayoutManager();\n    this.localeManager = new LocaleManager();\n    this.seriesStateManager = new SeriesStateManager();\n    this.stateManager = new StateManager();\n    this.toolbarManager = new ToolbarManager();\n    this.zoomManager = new ZoomManager();\n    const { scene, root, syncManager, container, updateCallback, updateMutex, pixelRatio, styleContainer } = vars;\n    this.chartService = chart;\n    this.syncManager = syncManager;\n    this.domManager = new DOMManager(container, styleContainer);\n    const canvasElement = this.domManager.addChild(\n      \"canvas\",\n      \"scene-canvas\",\n      scene?.canvas.element\n    );\n    this.scene = scene ?? new Scene({ pixelRatio, canvasElement });\n    this.scene.setRoot(root);\n    this.axisManager = new AxisManager(root);\n    this.annotationManager = new AnnotationManager(chart.annotationRoot);\n    this.cursorManager = new CursorManager(this.domManager);\n    this.interactionManager = new InteractionManager(chart.keyboard, this.domManager);\n    this.focusIndicator = new FocusIndicator(this.domManager);\n    this.keyNavManager = new KeyNavManager(this.focusIndicator, this.interactionManager, chart.mode);\n    this.regionManager = new RegionManager(this.interactionManager);\n    this.contextMenuRegistry = new ContextMenuRegistry(this.regionManager);\n    this.gestureDetector = new GestureDetector(this.domManager);\n    this.updateService = new UpdateService(updateCallback);\n    this.proxyInteractionService = new ProxyInteractionService(this.localeManager, this.domManager);\n    this.historyManager = new HistoryManager(this.keyNavManager);\n    this.animationManager = new AnimationManager(this.interactionManager, updateMutex);\n    this.dataService = new DataService(this.animationManager);\n    this.tooltipManager = new TooltipManager(this.domManager, chart.tooltip);\n    this.zoomManager.addLayoutListeners(this.layoutManager);\n  }\n  destroy() {\n    this.animationManager.destroy();\n    this.highlightManager.destroy();\n    this.axisManager.destroy();\n    this.callbackCache.invalidateCache();\n    this.chartEventManager.destroy();\n    this.contextMenuRegistry.destroy();\n    this.domManager.destroy();\n    this.highlightManager.destroy();\n    this.interactionManager.destroy();\n    this.keyNavManager.destroy();\n    this.focusIndicator.destroy();\n    this.proxyInteractionService.destroy();\n    this.regionManager.destroy();\n    this.syncManager.destroy();\n    this.tooltipManager.destroy();\n    this.zoomManager.destroy();\n  }\n};\n\n// packages/ag-charts-community/src/chart/chartHighlight.ts\nvar ChartHighlight = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.range = \"tooltip\";\n  }\n};\n__decorateClass([\n  Validate(UNION([\"tooltip\", \"node\"], \"a range\"))\n], ChartHighlight.prototype, \"range\", 2);\n\n// packages/ag-charts-community/src/chart/data/dataDomain.ts\nvar DiscreteDomain = class _DiscreteDomain {\n  constructor() {\n    this.domain = /* @__PURE__ */ new Set();\n  }\n  static is(value) {\n    return value instanceof _DiscreteDomain;\n  }\n  extend(val) {\n    this.domain.add(val);\n  }\n  getDomain() {\n    return Array.from(this.domain);\n  }\n};\nvar ContinuousDomain = class _ContinuousDomain {\n  constructor() {\n    this.domain = [Infinity, -Infinity];\n  }\n  static is(value) {\n    return value instanceof _ContinuousDomain;\n  }\n  static extendDomain(values, domain = [Infinity, -Infinity]) {\n    for (const value of values) {\n      if (typeof value !== \"number\") {\n        continue;\n      }\n      if (domain[0] > value) {\n        domain[0] = value;\n      }\n      if (domain[1] < value) {\n        domain[1] = value;\n      }\n    }\n    return domain;\n  }\n  extend(value) {\n    if (this.domain[0] > value) {\n      this.domain[0] = value;\n    }\n    if (this.domain[1] < value) {\n      this.domain[1] = value;\n    }\n  }\n  getDomain() {\n    return [...this.domain];\n  }\n};\n\n// packages/ag-charts-community/src/chart/data/dataModel.ts\nfunction toKeyString(keys) {\n  return keys.map((key) => isObject(key) ? JSON.stringify(key) : key).join(\"-\");\n}\nfunction round2(val) {\n  const accuracy = 1e4;\n  if (Number.isInteger(val)) {\n    return val;\n  } else if (Math.abs(val) > accuracy) {\n    return Math.trunc(val);\n  }\n  return Math.round(val * accuracy) / accuracy;\n}\nfunction fixNumericExtent(extent2) {\n  if (extent2 == null) {\n    return [];\n  }\n  const [min, max] = extent2.map(Number);\n  if (min === 0 && max === 0) {\n    return [0, 1];\n  }\n  return isFiniteNumber(min) && isFiniteNumber(max) ? [min, max] : [];\n}\nfunction getMissCount(scopeProvider, missMap) {\n  return missMap?.get(scopeProvider.id) ?? 0;\n}\nvar INVALID_VALUE = Symbol(\"invalid\");\nfunction getPathComponents(path) {\n  const components = [];\n  let matchIndex = 0;\n  let matchGroup;\n  const regExp = /((?:(?:^|\\.)\\s*\\w+|\\[\\s*(?:'(?:[^']|\\\\')*'|\"(?:[^\"]|\\\\\")*\"|-?\\d+)\\s*\\])\\s*)/g;\n  while (matchGroup = regExp.exec(path)) {\n    if (matchGroup.index !== matchIndex) {\n      return;\n    }\n    matchIndex = matchGroup.index + matchGroup[0].length;\n    const match = matchGroup[1].trim();\n    if (match.startsWith(\".\")) {\n      components.push(match.slice(1).trim());\n    } else if (match.startsWith(\"[\")) {\n      const accessor = match.slice(1, -1).trim();\n      if (accessor.startsWith(`'`)) {\n        components.push(accessor.slice(1, -1).replace(/\\\\'/g, `'`));\n      } else if (accessor.startsWith(`\"`)) {\n        components.push(accessor.slice(1, -1).replace(/\\\\\"/g, `\"`));\n      } else {\n        components.push(accessor);\n      }\n    } else {\n      components.push(match);\n    }\n  }\n  if (matchIndex !== path.length)\n    return;\n  return components;\n}\nfunction createPathAccessor(components) {\n  return (datum) => {\n    let current = datum;\n    for (const component of components) {\n      current = current[component];\n    }\n    return current;\n  };\n}\nvar DataModel = class {\n  constructor(opts, mode = \"standalone\") {\n    this.opts = opts;\n    this.mode = mode;\n    this.debug = Debug.create(true, \"data-model\");\n    this.scopeCache = /* @__PURE__ */ new Map();\n    this.keys = [];\n    this.values = [];\n    this.aggregates = [];\n    this.groupProcessors = [];\n    this.propertyProcessors = [];\n    this.reducers = [];\n    this.processors = [];\n    let keys = true;\n    for (const next of opts.props) {\n      if (next.type === \"key\" && !keys) {\n        throw new Error(\"AG Charts - internal config error: keys must come before values.\");\n      }\n      if (next.type === \"value\" && keys) {\n        keys = false;\n      }\n    }\n    const verifyMatchGroupId = ({ matchGroupIds = [] }) => {\n      for (const matchGroupId of matchGroupIds) {\n        if (this.values.every((def) => def.groupId !== matchGroupId)) {\n          throw new Error(\n            `AG Charts - internal config error: matchGroupIds properties must match defined groups (${matchGroupId}).`\n          );\n        }\n      }\n    };\n    for (const def of opts.props) {\n      switch (def.type) {\n        case \"key\":\n          this.keys.push({ ...def, index: this.keys.length, missing: /* @__PURE__ */ new Map() });\n          break;\n        case \"value\":\n          if (def.property == null) {\n            throw new Error(\n              `AG Charts - internal config error: no properties specified for value definitions: ${JSON.stringify(\n                def\n              )}`\n            );\n          }\n          this.values.push({ ...def, index: this.values.length, missing: /* @__PURE__ */ new Map() });\n          break;\n        case \"aggregate\":\n          verifyMatchGroupId(def);\n          this.aggregates.push({ ...def, index: this.aggregates.length });\n          break;\n        case \"group-value-processor\":\n          verifyMatchGroupId(def);\n          this.groupProcessors.push({ ...def, index: this.groupProcessors.length });\n          break;\n        case \"property-value-processor\":\n          this.propertyProcessors.push({ ...def, index: this.propertyProcessors.length });\n          break;\n        case \"reducer\":\n          this.reducers.push({ ...def, index: this.reducers.length });\n          break;\n        case \"processor\":\n          this.processors.push({ ...def, index: this.processors.length });\n          break;\n      }\n    }\n  }\n  resolveProcessedDataDefById(scope, searchId) {\n    const def = this.scopeCache.get(scope.id)?.get(searchId);\n    if (!def) {\n      throw new Error(`AG Charts - didn't find property definition for [${searchId}, ${scope.id}]`);\n    }\n    return { index: def.index, def };\n  }\n  resolveProcessedDataIndexById(scope, searchId) {\n    return this.resolveProcessedDataDefById(scope, searchId).index;\n  }\n  resolveProcessedDataDefsByIds(scope, searchIds) {\n    return searchIds.map((searchId) => [searchId, this.resolveProcessedDataDefById(scope, searchId)]);\n  }\n  resolveProcessedDataDefsValues(defs, { keys, values }) {\n    const result = {};\n    for (const [searchId, { index, def }] of defs) {\n      const processedData = def.type === \"key\" ? keys : values;\n      result[searchId] = processedData[index];\n    }\n    return result;\n  }\n  getDomain(scope, searchId, type = \"value\", processedData) {\n    const domains = this.getDomainsByType(type, processedData);\n    return domains?.[this.resolveProcessedDataIndexById(scope, searchId)] ?? [];\n  }\n  getDomainsByType(type, processedData) {\n    switch (type) {\n      case \"key\":\n        return processedData.domain.keys;\n      case \"value\":\n        return processedData.domain.values;\n      case \"aggregate\":\n        return processedData.domain.aggValues;\n      case \"group-value-processor\":\n        return processedData.domain.groups;\n      default:\n        return null;\n    }\n  }\n  processData(data, sources) {\n    const {\n      opts: { groupByKeys, groupByFn },\n      aggregates,\n      groupProcessors,\n      reducers,\n      processors,\n      propertyProcessors\n    } = this;\n    const start2 = performance.now();\n    if (groupByKeys && this.keys.length === 0) {\n      return;\n    }\n    let processedData = this.extractData(data, sources);\n    if (groupByKeys) {\n      processedData = this.groupData(processedData);\n    } else if (groupByFn) {\n      processedData = this.groupData(processedData, groupByFn(processedData));\n    }\n    if (groupProcessors.length > 0) {\n      this.postProcessGroups(processedData);\n    }\n    if (aggregates.length > 0) {\n      this.aggregateData(processedData);\n    }\n    if (propertyProcessors.length > 0) {\n      this.postProcessProperties(processedData);\n    }\n    if (reducers.length > 0) {\n      this.reduceData(processedData);\n    }\n    if (processors.length > 0) {\n      this.postProcessData(processedData);\n    }\n    if (data.length > 0) {\n      for (const def of iterate(this.keys, this.values)) {\n        for (const [scope, missCount] of def.missing) {\n          if (missCount >= data.length) {\n            const scopeHint = scope == null ? \"\" : ` for ${scope}`;\n            Logger.warnOnce(`the key '${def.property}' was not found in any data element${scopeHint}.`);\n          }\n        }\n      }\n    }\n    const end2 = performance.now();\n    processedData.time = end2 - start2;\n    if (this.debug.check()) {\n      logProcessedData(processedData);\n    }\n    this.scopeCache.clear();\n    for (const def of iterate(this.keys, this.values, this.aggregates)) {\n      if (!def.idsMap)\n        continue;\n      for (const [scope, ids] of def.idsMap) {\n        for (const id of ids) {\n          if (!this.scopeCache.has(scope)) {\n            this.scopeCache.set(scope, /* @__PURE__ */ new Map([[id, def]]));\n          } else if (this.scopeCache.get(scope)?.has(id)) {\n            throw new Error(\"duplicate definition ids on the same scope are not allowed.\");\n          } else {\n            this.scopeCache.get(scope).set(id, def);\n          }\n        }\n      }\n    }\n    return processedData;\n  }\n  valueGroupIdxLookup({ matchGroupIds }) {\n    const result = [];\n    for (const [index, def] of this.values.entries()) {\n      if (!matchGroupIds || def.groupId && matchGroupIds.includes(def.groupId)) {\n        result.push(index);\n      }\n    }\n    return result;\n  }\n  valueIdxLookup(scopes, prop) {\n    const noScopesToMatch = scopes == null || scopes.length === 0;\n    const propId = typeof prop === \"string\" ? prop : prop.id;\n    const hasMatchingScopeId = (def) => {\n      if (def.idsMap) {\n        for (const [scope, ids] of def.idsMap) {\n          if (scopes?.includes(scope) && ids.has(propId)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    };\n    const result = this.values.findIndex((def) => {\n      const validDefScopes = def.scopes == null || noScopesToMatch && !def.scopes.length || def.scopes.some((s) => scopes?.includes(s));\n      return validDefScopes && (def.property === propId || def.id === propId || hasMatchingScopeId(def));\n    });\n    if (result === -1) {\n      throw new Error(\n        `AG Charts - configuration error, unknown property ${JSON.stringify(prop)} in scope(s) ${JSON.stringify(\n          scopes\n        )}`\n      );\n    }\n    return result;\n  }\n  extractData(data, sources) {\n    const { dataDomain, processValue, scopes, allScopesHaveSameDefs } = this.initDataDomainProcessor();\n    const sourcesById = new Map(sources?.map((s) => [s.id, s]));\n    const { keys: keyDefs, values: valueDefs } = this;\n    const resultData = new Array(data.length);\n    let resultDataIdx = 0;\n    let partialValidDataCount = 0;\n    for (const [datumIdx, datum] of data.entries()) {\n      const sourceDatums = {};\n      const validScopes = scopes.size > 0 ? new Set(scopes) : void 0;\n      const keys = new Array(keyDefs.length);\n      let keyIdx = 0;\n      let key;\n      for (const def of keyDefs) {\n        key = processValue(def, datum, key);\n        if (key === INVALID_VALUE)\n          break;\n        if (keys) {\n          keys[keyIdx++] = key;\n        }\n      }\n      if (key === INVALID_VALUE)\n        continue;\n      const values = valueDefs.length > 0 ? new Array(valueDefs.length) : void 0;\n      let value;\n      for (const [valueDefIdx, def] of valueDefs.entries()) {\n        for (const scope of def.scopes ?? scopes) {\n          const source = sourcesById.get(scope);\n          const valueDatum = source?.data[datumIdx] ?? datum;\n          value = processValue(def, valueDatum, value, scope);\n          if (value === INVALID_VALUE || !values)\n            continue;\n          if (source != null && def.includeProperty !== false) {\n            const property = def.includeProperty && def.id != null ? def.id : def.property;\n            sourceDatums[scope] ?? (sourceDatums[scope] = {});\n            sourceDatums[scope][property] = value;\n          }\n          values[valueDefIdx] = value;\n        }\n        if (value === INVALID_VALUE) {\n          if (allScopesHaveSameDefs)\n            break;\n          for (const scope of def.scopes ?? scopes) {\n            validScopes?.delete(scope);\n          }\n          if (validScopes?.size === 0)\n            break;\n        }\n      }\n      if (value === INVALID_VALUE && allScopesHaveSameDefs)\n        continue;\n      if (validScopes?.size === 0)\n        continue;\n      const result = { datum: { ...datum, ...sourceDatums }, keys, values };\n      if (!allScopesHaveSameDefs && validScopes && validScopes.size < scopes.size) {\n        partialValidDataCount++;\n        result.validScopes = new Set(validScopes);\n      }\n      resultData[resultDataIdx++] = result;\n    }\n    resultData.length = resultDataIdx;\n    const propertyDomain = (def) => {\n      const defDomain = dataDomain.get(def);\n      const result = defDomain.getDomain();\n      if (ContinuousDomain.is(defDomain) && result[0] > result[1]) {\n        return [];\n      }\n      return result;\n    };\n    return {\n      type: \"ungrouped\",\n      input: { count: data.length },\n      data: resultData,\n      domain: {\n        keys: keyDefs.map(propertyDomain),\n        values: valueDefs.map(propertyDomain)\n      },\n      defs: {\n        allScopesHaveSameDefs,\n        keys: keyDefs,\n        values: valueDefs\n      },\n      partialValidDataCount,\n      time: 0\n    };\n  }\n  groupData(data, groupingFn) {\n    const processedData = /* @__PURE__ */ new Map();\n    for (const dataEntry of data.data) {\n      const { keys, values, datum, validScopes } = dataEntry;\n      const group = groupingFn?.(dataEntry) ?? keys;\n      const groupStr = toKeyString(group);\n      if (processedData.has(groupStr)) {\n        const existingData = processedData.get(groupStr);\n        existingData.values.push(values);\n        existingData.datum.push(datum);\n        if (validScopes != null && existingData.validScopes != null) {\n          for (const scope of existingData.validScopes) {\n            if (!validScopes.has(scope)) {\n              existingData.validScopes.delete(scope);\n            }\n          }\n        }\n      } else {\n        processedData.set(groupStr, {\n          keys: group,\n          values: [values],\n          datum: [datum],\n          validScopes\n        });\n      }\n    }\n    const resultData = new Array(processedData.size);\n    const resultGroups = new Array(processedData.size);\n    let dataIndex = 0;\n    for (const { keys, values, datum, validScopes } of processedData.values()) {\n      if (validScopes?.size === 0)\n        continue;\n      resultGroups[dataIndex] = keys;\n      resultData[dataIndex++] = {\n        keys,\n        values,\n        datum,\n        validScopes\n      };\n    }\n    return {\n      ...data,\n      type: \"grouped\",\n      data: resultData,\n      domain: {\n        ...data.domain,\n        groups: resultGroups\n      }\n    };\n  }\n  aggregateData(processedData) {\n    const isUngrouped = processedData.type === \"ungrouped\";\n    processedData.domain.aggValues = [];\n    for (const [index, def] of this.aggregates.entries()) {\n      const indices = this.valueGroupIdxLookup(def);\n      const domain = [Infinity, -Infinity];\n      for (const datum of processedData.data) {\n        datum.aggValues ?? (datum.aggValues = new Array(this.aggregates.length));\n        if (datum.validScopes)\n          continue;\n        const values = isUngrouped ? [datum.values] : datum.values;\n        let groupAggValues = def.groupAggregateFunction?.() ?? [Infinity, -Infinity];\n        for (const distinctValues of values) {\n          const valuesToAgg = indices.map((valueIdx) => distinctValues[valueIdx]);\n          const valuesAgg = def.aggregateFunction(valuesToAgg, datum.keys);\n          if (valuesAgg) {\n            groupAggValues = def.groupAggregateFunction?.(valuesAgg, groupAggValues) ?? ContinuousDomain.extendDomain(valuesAgg, groupAggValues);\n          }\n        }\n        const finalValues = (def.finalFunction?.(groupAggValues) ?? groupAggValues).map((v) => round2(v));\n        datum.aggValues[index] = finalValues;\n        ContinuousDomain.extendDomain(finalValues, domain);\n      }\n      processedData.domain.aggValues.push(domain);\n    }\n  }\n  postProcessGroups(processedData) {\n    const { groupProcessors } = this;\n    const affectedIndices = /* @__PURE__ */ new Set();\n    const updatedDomains = /* @__PURE__ */ new Map();\n    const groupProcessorIndices = /* @__PURE__ */ new Map();\n    const groupProcessorInitFns = /* @__PURE__ */ new Map();\n    for (const processor of groupProcessors) {\n      const indices = this.valueGroupIdxLookup(processor);\n      groupProcessorIndices.set(processor, indices);\n      groupProcessorInitFns.set(processor, processor.adjust());\n      for (const idx of indices) {\n        const valueDef = this.values[idx];\n        const isDiscrete = valueDef.valueType === \"category\";\n        affectedIndices.add(idx);\n        updatedDomains.set(idx, isDiscrete ? new DiscreteDomain() : new ContinuousDomain());\n      }\n    }\n    const updateDomains = (values) => {\n      for (const valueIndex of affectedIndices) {\n        updatedDomains.get(valueIndex)?.extend(values[valueIndex]);\n      }\n    };\n    for (const group of processedData.data) {\n      for (const processor of groupProcessors) {\n        if (group.validScopes)\n          continue;\n        const valueIndexes = groupProcessorIndices.get(processor) ?? [];\n        const adjustFn = groupProcessorInitFns.get(processor)?.();\n        if (!adjustFn)\n          continue;\n        if (processedData.type === \"grouped\") {\n          for (const values of group.values) {\n            if (values) {\n              adjustFn(values, valueIndexes);\n            }\n          }\n        } else if (group.values) {\n          adjustFn(group.values, valueIndexes);\n        }\n      }\n      if (processedData.type === \"grouped\") {\n        for (const values of group.values) {\n          updateDomains(values);\n        }\n      } else {\n        updateDomains(group.values);\n      }\n    }\n    for (const [idx, dataDomain] of updatedDomains) {\n      processedData.domain.values[idx] = dataDomain.getDomain();\n    }\n  }\n  postProcessProperties(processedData) {\n    for (const { adjust, property, scopes } of this.propertyProcessors) {\n      adjust()(processedData, this.valueIdxLookup(scopes, property));\n    }\n  }\n  reduceData(processedData) {\n    processedData.reduced ?? (processedData.reduced = {});\n    for (const def of this.reducers) {\n      const reducer = def.reducer();\n      let accValue = def.initialValue;\n      for (const datum of processedData.data) {\n        if (!datum.validScopes || def.scopes?.some((s) => datum.validScopes?.has(s))) {\n          accValue = reducer(accValue, datum);\n        }\n      }\n      processedData.reduced[def.property] = accValue;\n    }\n  }\n  postProcessData(processedData) {\n    processedData.reduced ?? (processedData.reduced = {});\n    for (const def of this.processors) {\n      processedData.reduced[def.property] = def.calculate(processedData);\n    }\n  }\n  initDataDomainProcessor() {\n    const { keys: keyDefs, values: valueDefs } = this;\n    const scopes = /* @__PURE__ */ new Set();\n    for (const valueDef of valueDefs) {\n      if (!valueDef.scopes)\n        continue;\n      for (const scope of valueDef.scopes) {\n        scopes.add(scope);\n      }\n    }\n    const dataDomain = /* @__PURE__ */ new Map();\n    const processorFns = /* @__PURE__ */ new Map();\n    let allScopesHaveSameDefs = true;\n    const initDataDomain = () => {\n      for (const def of iterate(keyDefs, valueDefs)) {\n        if (def.valueType === \"category\") {\n          dataDomain.set(def, new DiscreteDomain());\n        } else {\n          dataDomain.set(def, new ContinuousDomain());\n          allScopesHaveSameDefs && (allScopesHaveSameDefs = (def.scopes ?? []).length === scopes.size);\n        }\n      }\n    };\n    initDataDomain();\n    const accessors = this.buildAccessors(iterate(keyDefs, valueDefs));\n    const processValue = (def, datum, previousDatum, scope) => {\n      let valueInDatum;\n      let value;\n      if (accessors.has(def.property)) {\n        try {\n          value = accessors.get(def.property)(datum);\n        } catch (error) {\n        }\n        valueInDatum = value != null;\n      } else {\n        valueInDatum = def.property in datum;\n        value = valueInDatum ? datum[def.property] : def.missingValue;\n      }\n      if (def.forceValue != null) {\n        const valueNegative = valueInDatum && isNegative(value);\n        value = valueNegative ? -1 * def.forceValue : def.forceValue;\n        valueInDatum = true;\n      }\n      const missingValueDef = \"missingValue\" in def;\n      if (!valueInDatum && !missingValueDef) {\n        const missCount = def.missing.get(scope) ?? 0;\n        def.missing.set(scope, missCount + 1);\n      }\n      if (!dataDomain.has(def)) {\n        initDataDomain();\n      }\n      if (valueInDatum && def.validation?.(value, datum) === false) {\n        if (\"invalidValue\" in def) {\n          value = def.invalidValue;\n        } else {\n          if (this.mode !== \"integrated\") {\n            Logger.warnOnce(\n              `invalid value of type [${typeof value}] for [${def.scopes} / ${def.id}] ignored:`,\n              `[${value}]`\n            );\n          }\n          return INVALID_VALUE;\n        }\n      }\n      if (def.processor) {\n        if (!processorFns.has(def)) {\n          processorFns.set(def, def.processor());\n        }\n        value = processorFns.get(def)?.(value, previousDatum === INVALID_VALUE ? void 0 : previousDatum);\n      }\n      dataDomain.get(def)?.extend(value);\n      return value;\n    };\n    return { dataDomain, processValue, initDataDomain, scopes, allScopesHaveSameDefs };\n  }\n  buildAccessors(defs) {\n    const result = /* @__PURE__ */ new Map();\n    if (this.mode === \"integrated\") {\n      return result;\n    }\n    for (const def of defs) {\n      const isPath = def.property.includes(\".\") || def.property.includes(\"[\");\n      if (!isPath)\n        continue;\n      const components = getPathComponents(def.property);\n      if (components == null) {\n        Logger.warnOnce(\"Invalid property path [%s]\", def.property);\n        continue;\n      }\n      const accessor = createPathAccessor(components);\n      result.set(def.property, accessor);\n    }\n    return result;\n  }\n};\nfunction logProcessedData(processedData) {\n  const logValues = (name, data) => {\n    if (data.length > 0) {\n      Logger.log(`DataModel.processData() - ${name}`);\n      Logger.table(data);\n    }\n  };\n  Logger.log(\"DataModel.processData() - processedData\", processedData);\n  logValues(\"Key Domains\", processedData.domain.keys);\n  logValues(\"Group Domains\", processedData.domain.groups ?? []);\n  logValues(\"Value Domains\", processedData.domain.values);\n  logValues(\"Aggregate Domains\", processedData.domain.aggValues ?? []);\n  if (processedData.type === \"grouped\") {\n    const flattenedValues = processedData.data.reduce((acc, next) => {\n      const keys = next.keys ?? [];\n      const aggValues = next.aggValues ?? [];\n      const skipKeys = next.keys.map(() => void 0);\n      const skipAggValues = aggValues?.map(() => void 0);\n      acc.push(\n        ...next.values.map((v, i) => [\n          ...i === 0 ? keys : skipKeys,\n          ...v ?? [],\n          ...i == 0 ? aggValues : skipAggValues\n        ])\n      );\n      return acc;\n    }, []);\n    logValues(\"Values\", flattenedValues);\n  } else {\n    const flattenedValues = processedData.data.reduce((acc, next) => {\n      const aggValues = next.aggValues ?? [];\n      acc.push([...next.keys, ...next.values, ...aggValues]);\n      return acc;\n    }, []);\n    logValues(\"Values\", flattenedValues);\n  }\n}\n\n// packages/ag-charts-community/src/chart/data/dataController.ts\nvar _DataController = class _DataController {\n  constructor(mode) {\n    this.mode = mode;\n    this.debug = Debug.create(true, \"data-model\");\n    this.requested = [];\n    this.status = \"setup\";\n  }\n  async request(id, data, opts) {\n    if (this.status !== \"setup\") {\n      throw new Error(`AG Charts - data request after data setup phase.`);\n    }\n    return new Promise((resolve, reject) => {\n      this.requested.push({ id, opts, data, resolve, reject });\n    });\n  }\n  execute() {\n    if (this.status !== \"setup\") {\n      throw new Error(`AG Charts - data request after data setup phase.`);\n    }\n    this.status = \"executed\";\n    this.debug(\"DataController.execute() - requested\", this.requested);\n    const valid = this.validateRequests(this.requested);\n    this.debug(\"DataController.execute() - validated\", valid);\n    const merged = this.mergeRequested(valid);\n    this.debug(\"DataController.execute() - merged\", merged);\n    if (this.debug.check()) {\n      getWindow().processedData = [];\n    }\n    const scopes = this.requested.map(({ id }) => id);\n    const needsValueExtraction = this.hasMultipleDataSources(valid);\n    for (const { opts, data, resolves, rejects, ids } of merged) {\n      try {\n        const dataModel = new DataModel(opts, this.mode);\n        const processedData = dataModel.processData(data, valid);\n        if (this.debug.check()) {\n          getWindow(\"processedData\").push(processedData);\n        }\n        if (processedData?.partialValidDataCount === 0) {\n          resolves.forEach(\n            (resolve, requestIdx) => resolve({\n              dataModel,\n              processedData: this.processScopedData(\n                ids[requestIdx],\n                processedData,\n                scopes,\n                needsValueExtraction\n              )\n            })\n          );\n        } else if (processedData) {\n          this.splitResult(dataModel, processedData, ids, resolves);\n        } else {\n          rejects.forEach((cb) => cb(new Error(`AG Charts - no processed data generated`)));\n        }\n      } catch (error) {\n        rejects.forEach((cb) => cb(error));\n      }\n    }\n  }\n  hasMultipleDataSources(validRequests) {\n    if (validRequests.length) {\n      const [{ data }, ...restRequests] = validRequests;\n      return restRequests.some((v) => data !== v.data);\n    }\n    return false;\n  }\n  processScopedData(id, processedData, ids, needsValueExtraction) {\n    const extractDatum = (datum) => {\n      if (Array.isArray(datum)) {\n        return datum.map(extractDatum);\n      }\n      const extracted = needsValueExtraction ? { ...datum, ...datum[id] } : datum;\n      for (const otherId of ids) {\n        delete extracted[otherId];\n      }\n      return extracted;\n    };\n    const extractValues = (values) => {\n      if (Array.isArray(values)) {\n        return values.map(extractValues);\n      }\n      return values?.[id] ?? values;\n    };\n    return {\n      ...processedData,\n      data: processedData.data.map((datum) => ({\n        ...datum,\n        datum: extractDatum(datum.datum),\n        values: needsValueExtraction ? datum.values?.map(extractValues) : datum.values\n      }))\n    };\n  }\n  validateRequests(requested) {\n    const valid = [];\n    for (const [index, request] of requested.entries()) {\n      if (index > 0 && request.data.length !== requested[0].data.length && request.opts.groupByData === false) {\n        request.reject(\n          new Error(\"all series[].data arrays must be of the same length and have matching keys.\")\n        );\n      } else {\n        valid.push(request);\n      }\n    }\n    return valid;\n  }\n  mergeRequested(requested) {\n    const grouped = [];\n    for (const request of requested) {\n      const match = grouped.find(_DataController.groupMatch(request));\n      if (match) {\n        match.push(request);\n      } else {\n        grouped.push([request]);\n      }\n    }\n    return grouped.map(_DataController.mergeRequests);\n  }\n  splitResult(dataModel, processedData, scopes, resolves) {\n    for (let i = 0; i < scopes.length; i++) {\n      const scope = scopes[i];\n      const resolve = resolves[i];\n      resolve({\n        dataModel,\n        processedData: {\n          ...processedData,\n          data: processedData.data.filter(({ validScopes }) => validScopes?.has(scope) ?? true)\n        }\n      });\n    }\n  }\n  static groupMatch({ data, opts }) {\n    function keys(props) {\n      return props.filter((p) => p.type === \"key\").map((p) => p.property).join(\";\");\n    }\n    return ([group]) => (opts.groupByData === false || group.data === data) && group.opts.groupByKeys === opts.groupByKeys && group.opts.groupByFn === opts.groupByFn && keys(group.opts.props) === keys(opts.props);\n  }\n  static mergeRequests(requests) {\n    return requests.reduce(\n      (result, { id, data, resolve, reject, opts: { props, ...opts } }) => {\n        result.ids.push(id);\n        result.rejects.push(reject);\n        result.resolves.push(resolve);\n        result.data ?? (result.data = data);\n        result.opts ?? (result.opts = { ...opts, props: [] });\n        for (const prop of props) {\n          const clone2 = { ...prop, scopes: [id] };\n          _DataController.createIdsMap(id, clone2);\n          const match = result.opts.props.find(\n            (existing) => existing.type === clone2.type && _DataController.deepEqual(existing, clone2)\n          );\n          if (!match) {\n            result.opts.props.push(clone2);\n            continue;\n          }\n          match.scopes ?? (match.scopes = []);\n          match.scopes.push(...clone2.scopes ?? []);\n          if ((match.type === \"key\" || match.type === \"value\") && clone2.idsMap?.size) {\n            _DataController.mergeIdsMap(clone2.idsMap, match.idsMap);\n          }\n        }\n        return result;\n      },\n      { ids: [], rejects: [], resolves: [], data: null, opts: null }\n    );\n  }\n  static mergeIdsMap(fromMap, toMap) {\n    for (const [scope, ids] of fromMap) {\n      const toMapValue = toMap.get(scope);\n      if (toMapValue != null) {\n        for (const id of ids) {\n          toMapValue.add(id);\n        }\n      } else {\n        toMap.set(scope, new Set(ids));\n      }\n    }\n  }\n  static createIdsMap(scope, prop) {\n    if (prop.id == null)\n      return;\n    prop.idsMap ?? (prop.idsMap = /* @__PURE__ */ new Map());\n    if (prop.idsMap.has(scope)) {\n      prop.idsMap.get(scope).add(prop.id);\n    } else {\n      prop.idsMap.set(scope, /* @__PURE__ */ new Set([prop.id]));\n    }\n  }\n  static deepEqual(a, b) {\n    if (a === b) {\n      return true;\n    }\n    if (a && b && typeof a == \"object\" && typeof b == \"object\") {\n      if (a.constructor !== b.constructor) {\n        return false;\n      }\n      let i, length2;\n      if (Array.isArray(a)) {\n        length2 = a.length;\n        if (length2 !== b.length) {\n          return false;\n        }\n        for (i = length2 - 1; i >= 0; i--) {\n          if (!_DataController.deepEqual(a[i], b[i])) {\n            return false;\n          }\n        }\n        return true;\n      }\n      const keys = Object.keys(a);\n      length2 = keys.length;\n      if (length2 !== Object.keys(b).length) {\n        return false;\n      }\n      for (i = length2 - 1; i >= 0; i--) {\n        const key = keys[i];\n        if (!_DataController.skipKeys.has(key) && (!Object.hasOwn(b, key) || !_DataController.deepEqual(a[key], b[key]))) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n};\n// optimized version of deep equality for `mergeRequests` which can potentially loop over 1M times\n_DataController.skipKeys = /* @__PURE__ */ new Set([\"id\", \"idsMap\", \"type\", \"scopes\"]);\nvar DataController = _DataController;\n\n// packages/ag-charts-community/src/chart/factory/axisRegistry.ts\nvar AxisRegistry = class {\n  constructor() {\n    this.axesMap = /* @__PURE__ */ new Map();\n    this.hidden = /* @__PURE__ */ new Set();\n    this.themeTemplates = /* @__PURE__ */ new Map();\n  }\n  register(axisType, module) {\n    this.axesMap.set(axisType, module.moduleFactory);\n    if (module.themeTemplate) {\n      this.setThemeTemplate(axisType, module.themeTemplate);\n    }\n    if (module.hidden) {\n      this.hidden.add(axisType);\n    }\n  }\n  create(axisType, moduleContext) {\n    const axisFactory = this.axesMap.get(axisType);\n    if (axisFactory) {\n      return axisFactory(moduleContext);\n    }\n    throw new Error(`AG Charts - unknown axis type: ${axisType}`);\n  }\n  has(axisType) {\n    return this.axesMap.has(axisType);\n  }\n  keys() {\n    return this.axesMap.keys();\n  }\n  publicKeys() {\n    return [...this.keys()].filter((k) => !this.hidden.has(k));\n  }\n  setThemeTemplate(axisType, themeTemplate) {\n    this.themeTemplates.set(axisType, themeTemplate);\n    return this;\n  }\n  getThemeTemplate(axisType) {\n    return this.themeTemplates.get(axisType);\n  }\n};\nvar axisRegistry = new AxisRegistry();\n\n// packages/ag-charts-community/src/chart/factory/expectedEnterpriseModules.ts\nvar EXPECTED_ENTERPRISE_MODULES = [\n  {\n    type: \"root\",\n    optionsKey: \"animation\",\n    chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\", \"standalone\", \"gauge\"]\n  },\n  { type: \"root\", optionsKey: \"annotations\", chartTypes: [\"cartesian\"] },\n  {\n    type: \"root\",\n    optionsKey: \"background\",\n    chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\", \"standalone\", \"gauge\"],\n    optionsInnerKey: \"image\"\n  },\n  {\n    type: \"root\",\n    optionsKey: \"foreground\",\n    chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\", \"standalone\", \"gauge\"],\n    optionsInnerKey: \"image\"\n  },\n  {\n    type: \"root\",\n    optionsKey: \"chartToolbar\",\n    chartTypes: [\"cartesian\"]\n  },\n  {\n    type: \"root\",\n    optionsKey: \"contextMenu\",\n    chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\", \"standalone\", \"gauge\"]\n  },\n  { type: \"root\", optionsKey: \"statusBar\", chartTypes: [\"cartesian\"], identifier: \"status-bar\" },\n  {\n    type: \"root\",\n    optionsKey: \"dataSource\",\n    chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\", \"standalone\", \"gauge\"]\n  },\n  { type: \"root\", optionsKey: \"sync\", chartTypes: [\"cartesian\"] },\n  { type: \"root\", optionsKey: \"zoom\", chartTypes: [\"cartesian\", \"topology\"] },\n  {\n    type: \"legend\",\n    optionsKey: \"gradientLegend\",\n    chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\", \"standalone\", \"gauge\"],\n    identifier: \"gradient\"\n  },\n  { type: \"root\", optionsKey: \"navigator\", chartTypes: [\"cartesian\"], optionsInnerKey: \"miniChart\" },\n  { type: \"axis\", optionsKey: \"axes[]\", chartTypes: [\"polar\"], identifier: \"angle-category\" },\n  { type: \"axis\", optionsKey: \"axes[]\", chartTypes: [\"polar\"], identifier: \"angle-number\" },\n  { type: \"axis\", optionsKey: \"axes[]\", chartTypes: [\"polar\"], identifier: \"radius-category\" },\n  { type: \"axis\", optionsKey: \"axes[]\", chartTypes: [\"polar\"], identifier: \"radius-number\" },\n  { type: \"axis\", optionsKey: \"axes[]\", chartTypes: [\"cartesian\"], identifier: \"ordinal-time\" },\n  { type: \"axis-option\", optionsKey: \"crosshair\", chartTypes: [\"cartesian\"] },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"box-plot\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"candlestick\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"cone-funnel\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"funnel\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"ohlc\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"bullet\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"heatmap\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"range-area\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"range-bar\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"waterfall\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"polar\"], identifier: \"nightingale\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"polar\"], identifier: \"radar-area\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"polar\"], identifier: \"radar-line\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"polar\"], identifier: \"radial-bar\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"polar\"], identifier: \"radial-column\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"hierarchy\"], identifier: \"sunburst\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"hierarchy\"], identifier: \"treemap\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"topology\"], identifier: \"map-shape\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"topology\"], identifier: \"map-line\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"topology\"], identifier: \"map-marker\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"topology\"], identifier: \"map-shape-background\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"topology\"], identifier: \"map-line-background\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"flow-proportion\"], identifier: \"chord\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"flow-proportion\"], identifier: \"sankey\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"standalone\"], identifier: \"pyramid\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"gauge\"], identifier: \"linear-gauge\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"gauge\"], identifier: \"radial-gauge\" },\n  { type: \"series-option\", optionsKey: \"errorBar\", chartTypes: [\"cartesian\"], identifier: \"error-bars\" }\n];\nfunction isEnterpriseSeriesType(type) {\n  return EXPECTED_ENTERPRISE_MODULES.some((s) => s.type === \"series\" && s.identifier === type);\n}\nfunction getEnterpriseSeriesChartTypes(type) {\n  return EXPECTED_ENTERPRISE_MODULES.find((s) => s.type === \"series\" && s.identifier === type)?.chartTypes;\n}\nfunction isEnterpriseCartesian(seriesType2) {\n  const type = getEnterpriseSeriesChartTypes(seriesType2)?.find((v) => v === \"cartesian\");\n  return type === \"cartesian\";\n}\nfunction isEnterprisePolar(seriesType2) {\n  const type = getEnterpriseSeriesChartTypes(seriesType2)?.find((v) => v === \"polar\");\n  return type === \"polar\";\n}\nfunction isEnterpriseHierarchy(seriesType2) {\n  const type = getEnterpriseSeriesChartTypes(seriesType2)?.find((v) => v === \"hierarchy\");\n  return type === \"hierarchy\";\n}\nfunction isEnterpriseTopology(seriesType2) {\n  const type = getEnterpriseSeriesChartTypes(seriesType2)?.find((v) => v === \"topology\");\n  return type === \"topology\";\n}\nfunction isEnterpriseFlowProportion(seriesType2) {\n  const type = getEnterpriseSeriesChartTypes(seriesType2)?.find((v) => v === \"flow-proportion\");\n  return type === \"flow-proportion\";\n}\nfunction isEnterpriseStandalone(seriesType2) {\n  const type = getEnterpriseSeriesChartTypes(seriesType2)?.find((v) => v === \"standalone\");\n  return type === \"standalone\";\n}\nfunction isEnterpriseGauge(seriesType2) {\n  const type = getEnterpriseSeriesChartTypes(seriesType2)?.find((v) => v === \"gauge\");\n  return type === \"gauge\";\n}\nfunction isEnterpriseModule(module) {\n  return module.packageType === \"enterprise\";\n}\nfunction verifyIfModuleExpected(module) {\n  if (!isEnterpriseModule(module)) {\n    throw new Error(\"AG Charts - internal configuration error, only enterprise modules need verification.\");\n  }\n  const stub = EXPECTED_ENTERPRISE_MODULES.find((s) => {\n    return s.type === module.type && s.optionsKey === module.optionsKey && s.identifier === module.identifier && module.chartTypes.every((t) => s.chartTypes.includes(t));\n  });\n  if (stub) {\n    stub.useCount ?? (stub.useCount = 0);\n    stub.useCount++;\n  }\n  return stub != null;\n}\nfunction getUnusedExpectedModules() {\n  return EXPECTED_ENTERPRISE_MODULES.filter(({ useCount }) => useCount == null || useCount === 0);\n}\n\n// packages/ag-charts-community/src/chart/factory/legendRegistry.ts\nvar LegendRegistry = class {\n  constructor() {\n    this.legendMap = /* @__PURE__ */ new Map();\n    this.themeTemplates = /* @__PURE__ */ new Map();\n  }\n  register(legendType, { optionsKey, moduleFactory, themeTemplate }) {\n    this.legendMap.set(legendType, { optionsKey, moduleFactory });\n    this.themeTemplates.set(optionsKey, themeTemplate);\n  }\n  create(legendType, moduleContext) {\n    const legendFactory = this.legendMap.get(legendType)?.moduleFactory;\n    if (legendFactory) {\n      return legendFactory(moduleContext);\n    }\n    throw new Error(`AG Charts - unknown legend type: ${legendType}`);\n  }\n  getThemeTemplates() {\n    return Object.fromEntries(this.themeTemplates);\n  }\n  getKeys() {\n    return Array.from(this.legendMap.entries()).reduce(\n      (result, [legendType, record]) => {\n        result[legendType] = record.optionsKey;\n        return result;\n      },\n      {}\n    );\n  }\n};\nvar legendRegistry = new LegendRegistry();\n\n// packages/ag-charts-community/src/chart/factory/chartTypes.ts\nvar ChartTypes = class extends Map {\n  get(seriesType2) {\n    return super.get(seriesType2) ?? \"unknown\";\n  }\n  isCartesian(seriesType2) {\n    return this.get(seriesType2) === \"cartesian\";\n  }\n  isPolar(seriesType2) {\n    return this.get(seriesType2) === \"polar\";\n  }\n  isHierarchy(seriesType2) {\n    return this.get(seriesType2) === \"hierarchy\";\n  }\n  isTopology(seriesType2) {\n    return this.get(seriesType2) === \"topology\";\n  }\n  isFlowProportion(seriesType2) {\n    return this.get(seriesType2) === \"flow-proportion\";\n  }\n  isStandalone(seriesType2) {\n    return this.get(seriesType2) === \"standalone\";\n  }\n  isGauge(seriesType2) {\n    return this.get(seriesType2) === \"gauge\";\n  }\n  get seriesTypes() {\n    return Array.from(this.keys());\n  }\n  get cartesianTypes() {\n    return this.seriesTypes.filter((t) => this.isCartesian(t));\n  }\n  get polarTypes() {\n    return this.seriesTypes.filter((t) => this.isPolar(t));\n  }\n  get hierarchyTypes() {\n    return this.seriesTypes.filter((t) => this.isHierarchy(t));\n  }\n  get topologyTypes() {\n    return this.seriesTypes.filter((t) => this.isTopology(t));\n  }\n  get flowProportionTypes() {\n    return this.seriesTypes.filter((t) => this.isFlowProportion(t));\n  }\n  get standaloneTypes() {\n    return this.seriesTypes.filter((t) => this.isStandalone(t));\n  }\n  get gaugeTypes() {\n    return this.seriesTypes.filter((t) => this.isGauge(t));\n  }\n};\nvar ChartDefaults = class extends Map {\n  set(chartType2, defaults) {\n    return super.set(chartType2, mergeDefaults(defaults, this.get(chartType2)));\n  }\n};\nvar chartTypes = new ChartTypes();\nvar publicChartTypes = new ChartTypes();\nvar chartDefaults = new ChartDefaults();\n\n// packages/ag-charts-community/src/chart/factory/seriesRegistry.ts\nvar SeriesRegistry = class {\n  constructor() {\n    this.seriesMap = /* @__PURE__ */ new Map();\n    this.themeTemplates = /* @__PURE__ */ new Map();\n  }\n  register(seriesType2, {\n    chartTypes: [chartType2],\n    moduleFactory,\n    tooltipDefaults,\n    defaultAxes,\n    themeTemplate,\n    paletteFactory,\n    solo,\n    stackable,\n    groupable,\n    stackedByDefault,\n    hidden\n  }) {\n    this.setThemeTemplate(seriesType2, themeTemplate);\n    this.seriesMap.set(seriesType2, {\n      moduleFactory,\n      tooltipDefaults,\n      defaultAxes,\n      paletteFactory,\n      solo,\n      stackable,\n      groupable,\n      stackedByDefault\n    });\n    chartTypes.set(seriesType2, chartType2);\n    if (!hidden) {\n      publicChartTypes.set(seriesType2, chartType2);\n    }\n  }\n  create(seriesType2, moduleContext) {\n    const seriesFactory = this.seriesMap.get(seriesType2)?.moduleFactory;\n    if (seriesFactory) {\n      return seriesFactory(moduleContext);\n    }\n    throw new Error(`AG Charts - unknown series type: ${seriesType2}`);\n  }\n  cloneDefaultAxes(seriesType2, options) {\n    const defaultAxes = this.seriesMap.get(seriesType2)?.defaultAxes;\n    if (defaultAxes == null)\n      return null;\n    const axes = typeof defaultAxes === \"function\" ? defaultAxes(options) : defaultAxes;\n    return { axes: deepClone(axes) };\n  }\n  setThemeTemplate(seriesType2, themeTemplate) {\n    const currentTemplate = this.themeTemplates.get(seriesType2);\n    this.themeTemplates.set(seriesType2, mergeDefaults(themeTemplate, currentTemplate));\n  }\n  getThemeTemplate(seriesType2) {\n    return this.themeTemplates.get(seriesType2);\n  }\n  getPaletteFactory(seriesType2) {\n    return this.seriesMap.get(seriesType2)?.paletteFactory;\n  }\n  getTooltipDefauls(seriesType2) {\n    return this.seriesMap.get(seriesType2)?.tooltipDefaults;\n  }\n  isSolo(seriesType2) {\n    return this.seriesMap.get(seriesType2)?.solo ?? false;\n  }\n  isGroupable(seriesType2) {\n    return this.seriesMap.get(seriesType2)?.groupable ?? false;\n  }\n  isStackable(seriesType2) {\n    return this.seriesMap.get(seriesType2)?.stackable ?? false;\n  }\n  isStackedByDefault(seriesType2) {\n    return this.seriesMap.get(seriesType2)?.stackedByDefault ?? false;\n  }\n};\nvar seriesRegistry = new SeriesRegistry();\n\n// packages/ag-charts-community/src/chart/interaction/syncManager.ts\nvar _SyncManager = class _SyncManager extends BaseManager {\n  constructor(chart) {\n    super();\n    this.chart = chart;\n  }\n  subscribe(groupId = _SyncManager.DEFAULT_GROUP) {\n    let syncGroup = this.get(groupId);\n    if (!syncGroup) {\n      syncGroup = /* @__PURE__ */ new Set();\n      _SyncManager.chartsGroups.set(groupId, syncGroup);\n    }\n    syncGroup.add(this.chart);\n    return this;\n  }\n  unsubscribe(groupId = _SyncManager.DEFAULT_GROUP) {\n    this.get(groupId)?.delete(this.chart);\n    return this;\n  }\n  getChart() {\n    return this.chart;\n  }\n  getGroup(groupId = _SyncManager.DEFAULT_GROUP) {\n    const syncGroup = this.get(groupId);\n    return syncGroup ? Array.from(syncGroup) : [];\n  }\n  getGroupSiblings(groupId = _SyncManager.DEFAULT_GROUP) {\n    return this.getGroup(groupId).filter((chart) => chart !== this.chart);\n  }\n  get(groupId) {\n    return _SyncManager.chartsGroups.get(groupId);\n  }\n};\n_SyncManager.chartsGroups = /* @__PURE__ */ new Map();\n_SyncManager.DEFAULT_GROUP = Symbol(\"sync-group-default\");\nvar SyncManager = _SyncManager;\n\n// packages/ag-charts-community/src/chart/keyboard.ts\nvar Keyboard = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = false;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], Keyboard.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], Keyboard.prototype, \"tabIndex\", 2);\n\n// packages/ag-charts-community/src/chart/mapping/prepareAxis.ts\nvar CartesianAxisPositions = [\"top\", \"right\", \"bottom\", \"left\"];\nfunction isAxisPosition(position) {\n  return typeof position === \"string\" && CartesianAxisPositions.includes(position);\n}\nfunction guessInvalidPositions(axes) {\n  const invalidAxes = [];\n  const usedPositions = [];\n  const guesses = [...CartesianAxisPositions];\n  for (const axis of axes) {\n    if (axis instanceof CartesianAxis) {\n      if (isAxisPosition(axis.position)) {\n        usedPositions.push(axis.position);\n      } else {\n        invalidAxes.push(axis);\n      }\n    }\n  }\n  for (const axis of invalidAxes) {\n    let nextGuess;\n    do {\n      nextGuess = guesses.pop();\n    } while (nextGuess && usedPositions.includes(nextGuess));\n    if (nextGuess == null)\n      break;\n    axis.position = nextGuess;\n  }\n}\n\n// packages/ag-charts-community/src/chart/mapping/prepareSeries.ts\nvar MATCHING_KEYS = [\"direction\", \"xKey\", \"yKey\", \"sizeKey\", \"angleKey\", \"radiusKey\", \"normalizedTo\"];\nfunction matchSeriesOptions(series, optSeries, oldOptsSeries) {\n  const generateKey = (type, i, opts) => {\n    const result = [type];\n    for (const key of MATCHING_KEYS) {\n      if (key in i && i[key] != null)\n        result.push(`${key}=${i[key]}`);\n    }\n    if (opts?.seriesGrouping) {\n      result.push(`seriesGrouping.groupId=${opts?.seriesGrouping.groupId}`);\n    }\n    return result.join(\";\");\n  };\n  const seriesMap = /* @__PURE__ */ new Map();\n  let idx = 0;\n  for (const s of series) {\n    const key = generateKey(s.type, s.properties, oldOptsSeries?.[idx]);\n    if (!seriesMap.has(key)) {\n      seriesMap.set(key, []);\n    }\n    seriesMap.get(key)?.push([s, idx++]);\n  }\n  const optsMap = /* @__PURE__ */ new Map();\n  for (const o of optSeries) {\n    const key = generateKey(o.type, o, o);\n    if (!optsMap.has(key)) {\n      optsMap.set(key, []);\n    }\n    optsMap.get(key)?.push(o);\n  }\n  const overlap = [...seriesMap.keys()].some((k) => optsMap.has(k));\n  if (!overlap) {\n    return { status: \"no-overlap\", oldKeys: seriesMap.keys(), newKeys: optsMap.keys() };\n  }\n  const changes = [];\n  let targetIdx = -1;\n  for (const [key, optArray] of optsMap.entries()) {\n    for (const opts of optArray) {\n      targetIdx++;\n      const seriesArray = seriesMap.get(key);\n      if (seriesArray == null || seriesArray.length < 1) {\n        changes.push({ opts, idx: targetIdx, status: \"add\" });\n        seriesMap.delete(key);\n        continue;\n      }\n      const [outputSeries, outputIdx] = seriesArray.shift();\n      const previousOpts = oldOptsSeries?.[outputIdx] ?? {};\n      const diff2 = jsonDiff(previousOpts, opts ?? {});\n      const { groupIndex, stackIndex } = diff2?.seriesGrouping ?? {};\n      if (groupIndex != null || stackIndex != null) {\n        changes.push({ opts, series: outputSeries, diff: diff2, idx: outputIdx, status: \"series-grouping\" });\n      } else if (diff2) {\n        changes.push({ opts, series: outputSeries, diff: diff2, idx: outputIdx, status: \"update\" });\n      } else {\n        changes.push({ opts, series: outputSeries, idx: outputIdx, status: \"no-op\" });\n      }\n      if (seriesArray.length === 0) {\n        seriesMap.delete(key);\n      }\n    }\n  }\n  for (const seriesArray of seriesMap.values()) {\n    for (const [outputSeries, outputIdx] of seriesArray) {\n      changes.push({ series: outputSeries, idx: outputIdx, status: \"remove\" });\n    }\n  }\n  return { status: \"overlap\", changes };\n}\n\n// packages/ag-charts-community/src/chart/mapping/types.ts\nfunction optionsType(input) {\n  const { series } = input;\n  if (!series)\n    return;\n  return series[0]?.type ?? \"line\";\n}\nfunction isAgCartesianChartOptions(input) {\n  const specifiedType = optionsType(input);\n  if (specifiedType == null) {\n    return false;\n  }\n  return chartTypes.isCartesian(specifiedType) || isEnterpriseCartesian(specifiedType);\n}\nfunction isAgPolarChartOptions(input) {\n  const specifiedType = optionsType(input);\n  if (specifiedType == null) {\n    return false;\n  }\n  if (specifiedType === \"polar\") {\n    Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);\n    return true;\n  }\n  return chartTypes.isPolar(specifiedType) || isEnterprisePolar(specifiedType);\n}\nfunction isAgHierarchyChartOptions(input) {\n  const specifiedType = optionsType(input);\n  if (specifiedType == null) {\n    return false;\n  }\n  if (specifiedType === \"hierarchy\") {\n    Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);\n    return true;\n  }\n  return chartTypes.isHierarchy(specifiedType) || isEnterpriseHierarchy(specifiedType);\n}\nfunction isAgTopologyChartOptions(input) {\n  const specifiedType = optionsType(input);\n  if (specifiedType == null) {\n    return false;\n  }\n  if (specifiedType === \"topology\") {\n    Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);\n    return true;\n  }\n  return chartTypes.isTopology(specifiedType) || isEnterpriseTopology(specifiedType);\n}\nfunction isAgFlowProportionChartOptions(input) {\n  const specifiedType = optionsType(input);\n  if (specifiedType == null) {\n    return false;\n  }\n  if (specifiedType === \"flow-proportion\") {\n    Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);\n    return true;\n  }\n  return chartTypes.isFlowProportion(specifiedType) || isEnterpriseFlowProportion(specifiedType);\n}\nfunction isAgStandaloneChartOptions(input) {\n  const specifiedType = optionsType(input);\n  if (specifiedType == null) {\n    return false;\n  }\n  if (specifiedType === \"standalone\") {\n    Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);\n    return true;\n  }\n  return chartTypes.isStandalone(specifiedType) || isEnterpriseStandalone(specifiedType);\n}\nfunction isAgGaugeChartOptions(input) {\n  const specifiedType = optionsType(input);\n  if (specifiedType == null) {\n    return false;\n  }\n  if (specifiedType === \"gauge\") {\n    Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);\n    return true;\n  }\n  return chartTypes.isGauge(specifiedType) || isEnterpriseGauge(specifiedType);\n}\nfunction isAgPolarChartOptionsWithSeriesBasedLegend(input) {\n  const specifiedType = optionsType(input);\n  return isAgPolarChartOptions(input) && specifiedType !== \"pie\" && specifiedType !== \"donut\";\n}\nfunction isSeriesOptionType(input) {\n  if (input == null) {\n    return false;\n  }\n  return chartTypes.has(input);\n}\nfunction isAxisOptionType(input) {\n  if (input == null) {\n    return false;\n  }\n  return axisRegistry.has(input);\n}\n\n// packages/ag-charts-community/src/chart/modulesManager.ts\nvar ModulesManager = class extends ModuleMap {\n  applyOptions(options) {\n    for (const m of this.moduleMap.values()) {\n      if (m.module.optionsKey in options && isProperties(m.moduleInstance)) {\n        m.moduleInstance.set(options[m.module.optionsKey]);\n      }\n    }\n  }\n  *legends() {\n    for (const { module, moduleInstance } of this.moduleMap.values()) {\n      if (module.type !== \"legend\")\n        continue;\n      yield {\n        legendType: module.identifier,\n        legend: moduleInstance\n      };\n    }\n  }\n};\n\n// packages/ag-charts-community/src/chart/overlay/overlay.ts\nvar DEFAULT_OVERLAY_CLASS = \"ag-chart-overlay\";\nvar DEFAULT_OVERLAY_DARK_CLASS = \"ag-chart-dark-overlay\";\nvar Overlay = class extends BaseProperties {\n  constructor(className, defaultMessageId) {\n    super();\n    this.className = className;\n    this.defaultMessageId = defaultMessageId;\n  }\n  getText(localeManager) {\n    return localeManager.t(this.text ?? this.defaultMessageId);\n  }\n  getElement(animationManager, localeManager, rect) {\n    this.content?.remove();\n    this.focusBox = rect;\n    if (this.renderer) {\n      const htmlContent = this.renderer();\n      if (htmlContent instanceof HTMLElement) {\n        this.content = htmlContent;\n      } else {\n        const tempDiv = createElement(\"div\");\n        tempDiv.innerHTML = htmlContent;\n        this.content = tempDiv.firstElementChild;\n      }\n    } else {\n      const content = createElement(\"div\", {\n        display: \"flex\",\n        alignItems: \"center\",\n        justifyContent: \"center\",\n        boxSizing: \"border-box\",\n        height: \"100%\",\n        margin: \"8px\",\n        font: \"12px Verdana, sans-serif\"\n      });\n      content.innerText = this.getText(localeManager);\n      this.content = content;\n      animationManager?.animate({\n        from: 0,\n        to: 1,\n        id: \"overlay\",\n        phase: \"add\",\n        groupId: \"opacity\",\n        onUpdate(value) {\n          content.style.opacity = String(value);\n        },\n        onStop() {\n          content.style.opacity = \"1\";\n        }\n      });\n    }\n    return this.content;\n  }\n  removeElement(cleanup = () => this.content?.remove(), animationManager) {\n    if (!this.content)\n      return;\n    if (animationManager) {\n      const { content } = this;\n      animationManager.animate({\n        from: 1,\n        to: 0,\n        phase: \"remove\",\n        id: \"overlay\",\n        groupId: \"opacity\",\n        onUpdate(value) {\n          content.style.opacity = String(value);\n        },\n        onStop() {\n          cleanup?.();\n        }\n      });\n    } else {\n      cleanup?.();\n    }\n    this.content = void 0;\n    this.focusBox = void 0;\n  }\n};\n__decorateClass([\n  Validate(STRING, { optional: true })\n], Overlay.prototype, \"text\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], Overlay.prototype, \"renderer\", 2);\n\n// packages/ag-charts-community/src/chart/overlay/chartOverlays.ts\nvar ChartOverlays = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.darkTheme = false;\n    this.loading = new Overlay(\"ag-chart-loading-overlay\", \"overlayLoadingData\");\n    this.noData = new Overlay(\"ag-chart-no-data-overlay\", \"overlayNoData\");\n    this.noVisibleSeries = new Overlay(\"ag-chart-no-visible-series\", \"overlayNoVisibleSeries\");\n  }\n  getFocusInfo(localeManager) {\n    for (const overlay of [this.loading, this.noData, this.noVisibleSeries]) {\n      if (overlay.focusBox !== void 0) {\n        return { text: overlay.getText(localeManager), rect: overlay.focusBox };\n      }\n    }\n    return void 0;\n  }\n  destroy() {\n    this.loading.removeElement();\n    this.noData.removeElement();\n    this.noVisibleSeries.removeElement();\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], ChartOverlays.prototype, \"darkTheme\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], ChartOverlays.prototype, \"loading\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], ChartOverlays.prototype, \"noData\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], ChartOverlays.prototype, \"noVisibleSeries\", 2);\n\n// packages/ag-charts-community/src/chart/overlay/loadingSpinner.ts\nfunction getLoadingSpinner(text, defaultDuration) {\n  const { animationDuration } = PHASE_METADATA[\"add\"];\n  const duration = animationDuration * defaultDuration;\n  const container = createElement(\"div\", `${DEFAULT_OVERLAY_CLASS}--loading`, {\n    display: \"flex\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    flexDirection: \"column\",\n    height: \"100%\",\n    boxSizing: \"border-box\",\n    font: \"13px Verdana, sans-serif\",\n    // FONT_SIZE.MEDIUM\n    userSelect: \"none\",\n    animation: `ag-charts-loading ${duration}ms linear 50ms both`\n  });\n  const matrix = createElement(\"span\", {\n    width: \"45px\",\n    height: \"40px\",\n    backgroundImage: [\n      \"linear-gradient(#0000 calc(1 * 100% / 6), #ccc 0 calc(3 * 100% / 6), #0000 0), \",\n      \"linear-gradient(#0000 calc(2 * 100% / 6), #ccc 0 calc(4 * 100% / 6), #0000 0), \",\n      \"linear-gradient(#0000 calc(3 * 100% / 6), #ccc 0 calc(5 * 100% / 6), #0000 0)\"\n    ].join(\"\"),\n    backgroundSize: \"10px 400%\",\n    backgroundRepeat: \"no-repeat\",\n    animation: \"ag-charts-loading-matrix 1s infinite linear\"\n  });\n  const label = createElement(\"p\", { marginTop: \"1em\" });\n  label.innerText = text;\n  const background = createElement(\"div\", `${DEFAULT_OVERLAY_CLASS}__loading-background`, {\n    position: \"absolute\",\n    inset: \"0\",\n    opacity: \"0.5\",\n    zIndex: \"-1\"\n  });\n  const animationStyles = createElement(\"style\");\n  animationStyles.innerText = [\n    \"@keyframes ag-charts-loading { from { opacity: 0 } to { opacity: 1 } }\",\n    \"@keyframes ag-charts-loading-matrix {\",\n    \"0% { background-position: 0% 0%, 50% 0%, 100% 0%; }\",\n    \"100% { background-position: 0% 100%, 50% 100%, 100% 100%; }\",\n    \"}\"\n  ].join(\" \");\n  container.replaceChildren(animationStyles, matrix, label, background);\n  return container;\n}\n\n// packages/ag-charts-community/src/chart/series/series.ts\nvar SeriesNodePickMode = /* @__PURE__ */ ((SeriesNodePickMode2) => {\n  SeriesNodePickMode2[SeriesNodePickMode2[\"EXACT_SHAPE_MATCH\"] = 0] = \"EXACT_SHAPE_MATCH\";\n  SeriesNodePickMode2[SeriesNodePickMode2[\"NEAREST_NODE\"] = 1] = \"NEAREST_NODE\";\n  SeriesNodePickMode2[SeriesNodePickMode2[\"AXIS_ALIGNED\"] = 2] = \"AXIS_ALIGNED\";\n  return SeriesNodePickMode2;\n})(SeriesNodePickMode || {});\nvar CROSS_FILTER_MARKER_FILL_OPACITY_FACTOR = 0.25;\nvar CROSS_FILTER_MARKER_STROKE_OPACITY_FACTOR = 0.125;\nvar SeriesNodeEvent = class {\n  constructor(type, event, { datum }, series) {\n    this.type = type;\n    this.event = event;\n    this.datum = datum;\n    this.seriesId = series.id;\n  }\n};\nvar SeriesGroupingChangedEvent = class {\n  constructor(series, seriesGrouping, oldGrouping) {\n    this.series = series;\n    this.seriesGrouping = seriesGrouping;\n    this.oldGrouping = oldGrouping;\n    this.type = \"groupingChanged\";\n  }\n};\nvar Series = class extends Observable {\n  constructor(seriesOpts) {\n    super();\n    this.destroyFns = [];\n    this.seriesGrouping = void 0;\n    this.NodeEvent = SeriesNodeEvent;\n    this.internalId = createId(this);\n    // The group node that contains all the nodes used to render this series.\n    this.rootGroup = new Group({ name: \"seriesRoot\", isVirtual: true });\n    this.axes = {\n      [\"x\" /* X */]: void 0,\n      [\"y\" /* Y */]: void 0\n    };\n    this.directions = [\"x\" /* X */, \"y\" /* Y */];\n    // Flag to determine if we should recalculate node data.\n    this.nodeDataRefresh = true;\n    this.moduleMap = new ModuleMap();\n    this._declarationOrder = -1;\n    this.seriesListeners = new Listeners();\n    this._pickNodeCache = new LRUCache();\n    const {\n      moduleCtx,\n      pickModes,\n      directionKeys = {},\n      directionNames = {},\n      contentGroupVirtual = true,\n      canHaveAxes = false\n    } = seriesOpts;\n    this.ctx = moduleCtx;\n    this.directionKeys = directionKeys;\n    this.directionNames = directionNames;\n    this.canHaveAxes = canHaveAxes;\n    this.contentGroup = this.rootGroup.appendChild(\n      new TranslatableGroup({\n        name: `${this.internalId}-content`,\n        isVirtual: contentGroupVirtual,\n        zIndex: 4 /* SERIES_LAYER */,\n        zIndexSubOrder: this.getGroupZIndexSubOrder(\"data\")\n      })\n    );\n    this.highlightGroup = new TranslatableGroup({\n      name: `${this.internalId}-highlight`,\n      isVirtual: contentGroupVirtual,\n      zIndex: 4 /* SERIES_LAYER */,\n      zIndexSubOrder: this.getGroupZIndexSubOrder(\"highlight\")\n    });\n    this.highlightNode = this.highlightGroup.appendChild(new Group({ name: \"highlightNode\", zIndex: 0 }));\n    this.highlightLabel = this.highlightGroup.appendChild(new Group({ name: \"highlightLabel\", zIndex: 10 }));\n    this.pickModes = pickModes;\n    this.labelGroup = this.rootGroup.appendChild(\n      new TranslatableGroup({\n        name: `${this.internalId}-series-labels`,\n        zIndex: 14 /* SERIES_LABEL */\n      })\n    );\n    this.annotationGroup = new Group({\n      name: `${this.id}-annotation`,\n      isVirtual: contentGroupVirtual,\n      zIndex: 4 /* SERIES_LAYER */,\n      zIndexSubOrder: this.getGroupZIndexSubOrder(\"annotation\")\n    });\n  }\n  get pickModeAxis() {\n    return \"main\";\n  }\n  get id() {\n    return this.properties?.id ?? this.internalId;\n  }\n  get type() {\n    return this.constructor.type ?? \"\";\n  }\n  get data() {\n    return this._data ?? this._chartData;\n  }\n  set visible(value) {\n    this.properties.visible = value;\n    this.visibleMaybeChanged();\n  }\n  get visible() {\n    return this.properties.visible;\n  }\n  get hasData() {\n    return this.data != null && this.data.length > 0;\n  }\n  get tooltipEnabled() {\n    return this.properties.tooltip?.enabled ?? false;\n  }\n  onDataChange() {\n    this.nodeDataRefresh = true;\n    this._pickNodeCache.clear();\n  }\n  setOptionsData(input) {\n    this._data = input;\n    this.onDataChange();\n  }\n  setChartData(input) {\n    this._chartData = input;\n    if (this.data === input) {\n      this.onDataChange();\n    }\n  }\n  onSeriesGroupingChange(prev, next) {\n    const { internalId, type, visible } = this;\n    if (prev) {\n      this.ctx.seriesStateManager.deregisterSeries(this);\n    }\n    if (next) {\n      this.ctx.seriesStateManager.registerSeries({ internalId, type, visible, seriesGrouping: next });\n    }\n    this.fireEvent(new SeriesGroupingChangedEvent(this, next, prev));\n  }\n  getBandScalePadding() {\n    return { inner: 1, outer: 0 };\n  }\n  getGroupZIndexSubOrder(type, subIndex = 0) {\n    let mainAdjust = 0;\n    switch (type) {\n      case \"data\":\n      case \"paths\":\n        break;\n      case \"labels\":\n        mainAdjust += 2e4;\n        break;\n      case \"marker\":\n        mainAdjust += 1e4;\n        break;\n      case \"highlight\":\n        subIndex += 15e3;\n        break;\n      case \"annotation\":\n        mainAdjust += 15e3;\n        break;\n    }\n    const main = () => this._declarationOrder + mainAdjust;\n    return [main, subIndex];\n  }\n  addListener(type, listener) {\n    return this.seriesListeners.addListener(type, listener);\n  }\n  dispatch(type, event) {\n    this.seriesListeners.dispatch(type, event);\n  }\n  addChartEventListeners() {\n    return;\n  }\n  destroy() {\n    this.destroyFns.forEach((f) => f());\n    this.destroyFns = [];\n    this.ctx.seriesStateManager.deregisterSeries(this);\n  }\n  getDirectionValues(direction, properties) {\n    const resolvedDirection = this.resolveKeyDirection(direction);\n    const keys = properties?.[resolvedDirection];\n    const values = [];\n    if (!keys) {\n      return values;\n    }\n    const addValues = (...items) => {\n      for (const value of items) {\n        if (Array.isArray(value)) {\n          addValues(...value);\n        } else if (typeof value === \"object\") {\n          addValues(...Object.values(value));\n        } else {\n          values.push(value);\n        }\n      }\n    };\n    addValues(...keys.map((key) => this.properties[key]));\n    return values;\n  }\n  getKeys(direction) {\n    return this.getDirectionValues(direction, this.directionKeys);\n  }\n  getKeyProperties(direction) {\n    return this.directionKeys[this.resolveKeyDirection(direction)] ?? [];\n  }\n  getNames(direction) {\n    return this.getDirectionValues(direction, this.directionNames);\n  }\n  resolveKeyDirection(direction) {\n    return direction;\n  }\n  // The union of the series domain ('community') and series-option domains ('enterprise').\n  getDomain(direction) {\n    const seriesDomain = this.getSeriesDomain(direction);\n    const moduleDomains = this.moduleMap.mapModules((module) => module.getDomain(direction));\n    return seriesDomain.concat(moduleDomains.flat());\n  }\n  // Indicate that something external changed and we should recalculate nodeData.\n  markNodeDataDirty() {\n    this.nodeDataRefresh = true;\n    this._pickNodeCache.clear();\n    this.visibleMaybeChanged();\n  }\n  visibleMaybeChanged() {\n    this.ctx.seriesStateManager.updateSeries(this);\n  }\n  getOpacity() {\n    const defaultOpacity = 1;\n    const { dimOpacity = 1, enabled = true } = this.properties.highlightStyle.series;\n    if (!enabled || dimOpacity === defaultOpacity) {\n      return defaultOpacity;\n    }\n    switch (this.isItemIdHighlighted()) {\n      case 0 /* None */:\n      case 1 /* This */:\n        return defaultOpacity;\n      case 2 /* Other */:\n      default:\n        return dimOpacity;\n    }\n  }\n  getStrokeWidth(defaultStrokeWidth) {\n    const { strokeWidth, enabled = true } = this.properties.highlightStyle.series;\n    if (!enabled || strokeWidth === void 0) {\n      return defaultStrokeWidth;\n    }\n    switch (this.isItemIdHighlighted()) {\n      case 1 /* This */:\n        return strokeWidth;\n      case 0 /* None */:\n      case 2 /* Other */:\n        return defaultStrokeWidth;\n    }\n  }\n  isItemIdHighlighted() {\n    const series = this.ctx.highlightManager?.getActiveHighlight()?.series;\n    if (series == null) {\n      return 0 /* None */;\n    }\n    if (series !== this) {\n      return 2 /* Other */;\n    }\n    return 1 /* This */;\n  }\n  getModuleTooltipParams() {\n    return this.moduleMap.mapModules((module) => module.getTooltipParams()).reduce((total, current) => Object.assign(total, current), {});\n  }\n  pickNode(point, intent, exactMatchOnly = false) {\n    const { pickModes, pickModeAxis, visible, rootGroup } = this;\n    if (!visible || !rootGroup.visible)\n      return;\n    if (intent === \"highlight\" && !this.properties.highlight.enabled)\n      return;\n    if (intent === \"highlight-tooltip\" && !this.properties.highlight.enabled)\n      return;\n    let maxDistance = Infinity;\n    if (intent === \"tooltip\" || intent === \"highlight-tooltip\") {\n      const { tooltip } = this.properties;\n      maxDistance = typeof tooltip.range === \"number\" ? tooltip.range : Infinity;\n      exactMatchOnly || (exactMatchOnly = tooltip.range === \"exact\");\n    } else if (intent === \"event\" || intent === \"context-menu\") {\n      const { nodeClickRange } = this.properties;\n      maxDistance = typeof nodeClickRange === \"number\" ? nodeClickRange : Infinity;\n      exactMatchOnly || (exactMatchOnly = nodeClickRange === \"exact\");\n    }\n    const selectedPickModes = pickModes.filter(\n      (m) => !exactMatchOnly || m === 0 /* EXACT_SHAPE_MATCH */\n    );\n    const { x, y } = point;\n    const key = JSON.stringify({ x, y, maxDistance, selectedPickModes });\n    if (this._pickNodeCache.has(key)) {\n      return this._pickNodeCache.get(key);\n    }\n    for (const pickMode of selectedPickModes) {\n      let match;\n      switch (pickMode) {\n        case 0 /* EXACT_SHAPE_MATCH */:\n          match = this.pickNodeExactShape(point);\n          break;\n        case 1 /* NEAREST_NODE */:\n          match = this.pickNodeClosestDatum(point);\n          break;\n        case 2 /* AXIS_ALIGNED */:\n          match = pickMode != null ? this.pickNodeMainAxisFirst(point, pickModeAxis === \"main-category\") : void 0;\n          break;\n      }\n      if (match && match.distance <= maxDistance) {\n        return this._pickNodeCache.set(key, { pickMode, match: match.datum, distance: match.distance });\n      }\n    }\n    return this._pickNodeCache.set(key, void 0);\n  }\n  pickNodeExactShape(point) {\n    const match = this.contentGroup.pickNode(point.x, point.y);\n    if (match && match.datum.missing !== true) {\n      return { datum: match.datum, distance: 0 };\n    }\n    return void 0;\n  }\n  pickNodeClosestDatum(_point) {\n    throw new Error(\"AG Charts - Series.pickNodeClosestDatum() not implemented\");\n  }\n  pickNodeNearestDistantObject(point, items) {\n    const match = nearestSquared(point.x, point.y, items);\n    if (match.nearest !== void 0 && match.nearest.datum.missing !== true) {\n      return { datum: match.nearest.datum, distance: Math.sqrt(match.distanceSquared) };\n    }\n    return void 0;\n  }\n  pickNodeMainAxisFirst(_point, _requireCategoryAxis) {\n    throw new Error(\"AG Charts - Series.pickNodeMainAxisFirst() not implemented\");\n  }\n  fireNodeClickEvent(event, datum) {\n    this.fireEvent(new this.NodeEvent(\"nodeClick\", event, datum, this));\n  }\n  fireNodeDoubleClickEvent(event, datum) {\n    this.fireEvent(new this.NodeEvent(\"nodeDoubleClick\", event, datum, this));\n  }\n  createNodeContextMenuActionEvent(event, datum) {\n    return new this.NodeEvent(\"nodeContextMenuAction\", event, datum, this);\n  }\n  toggleSeriesItem(itemId, enabled) {\n    this.visible = enabled;\n    this.nodeDataRefresh = true;\n    this._pickNodeCache.clear();\n    this.dispatch(\"visibility-changed\", { itemId, enabled });\n  }\n  isEnabled() {\n    return this.visible;\n  }\n  getModuleMap() {\n    return this.moduleMap;\n  }\n  createModuleContext() {\n    return { ...this.ctx, series: this };\n  }\n  getLabelText(label, params, defaultFormatter = String) {\n    if (label.formatter) {\n      return this.ctx.callbackCache.call(label.formatter, { seriesId: this.id, ...params }) ?? defaultFormatter(params.value);\n    }\n    return defaultFormatter(params.value);\n  }\n  getMarkerStyle(marker, params, defaultStyle = marker.getStyle()) {\n    const defaultSize = { size: params.datum.point?.size ?? 0 };\n    const markerStyle = mergeDefaults(defaultSize, defaultStyle);\n    if (marker.itemStyler) {\n      const style = this.ctx.callbackCache.call(marker.itemStyler, {\n        seriesId: this.id,\n        ...markerStyle,\n        ...params,\n        datum: params.datum.datum\n      });\n      return mergeDefaults(style, markerStyle);\n    }\n    return markerStyle;\n  }\n  updateMarkerStyle(markerNode, marker, params, defaultStyle = marker.getStyle(), { applyTranslation = true, selected = true } = {}) {\n    const { point } = params.datum;\n    const activeStyle = this.getMarkerStyle(marker, params, defaultStyle);\n    const visible = this.visible && activeStyle.size > 0 && point && !isNaN(point.x) && !isNaN(point.y);\n    if (applyTranslation) {\n      markerNode.setProperties({ visible, ...activeStyle, translationX: point?.x, translationY: point?.y });\n    } else {\n      markerNode.setProperties({ visible, ...activeStyle });\n    }\n    if (!selected) {\n      markerNode.fillOpacity *= CROSS_FILTER_MARKER_FILL_OPACITY_FACTOR;\n      markerNode.strokeOpacity *= CROSS_FILTER_MARKER_STROKE_OPACITY_FACTOR;\n    }\n    if (typeof marker.shape === \"function\" && !markerNode.dirtyPath) {\n      markerNode.path.clear(true);\n      markerNode.updatePath();\n      markerNode.checkPathDirty();\n      const bb = markerNode.getBBox();\n      if (point !== void 0 && bb.isFinite()) {\n        const center2 = bb.computeCenter();\n        const [dx, dy] = [\"x\", \"y\"].map(\n          (key) => (activeStyle.strokeWidth ?? 0) + Math.abs(center2[key] - point[key])\n        );\n        const customSize = Math.max(bb.width + dx, bb.height + dy);\n        point.focusSize = customSize;\n      }\n    }\n  }\n  getMinRects(_width, _height) {\n    return;\n  }\n  get nodeDataDependencies() {\n    return this._nodeDataDependencies ?? { seriesRectWidth: NaN, seriesRectHeight: NaN };\n  }\n  checkResize(newSeriesRect) {\n    const { width: seriesRectWidth, height: seriesRectHeight } = newSeriesRect ?? { width: NaN, height: NaN };\n    const newNodeDataDependencies = newSeriesRect ? { seriesRectWidth, seriesRectHeight } : void 0;\n    const resize = jsonDiff(this.nodeDataDependencies, newNodeDataDependencies) != null;\n    if (resize) {\n      this._nodeDataDependencies = newNodeDataDependencies;\n      this.markNodeDataDirty();\n    }\n    return resize;\n  }\n  pickFocus(_opts) {\n    return void 0;\n  }\n};\nSeries.highlightedZIndex = 1e12;\n__decorateClass([\n  ActionOnSet({\n    changeValue: function(newVal, oldVal) {\n      this.onSeriesGroupingChange(oldVal, newVal);\n    }\n  })\n], Series.prototype, \"seriesGrouping\", 2);\n\n// packages/ag-charts-community/src/chart/keyboardUtil.ts\nfunction computeCenter(bboxOrPath) {\n  if (bboxOrPath == null)\n    return;\n  if (bboxOrPath instanceof BBox) {\n    return bboxOrPath.computeCenter();\n  }\n  return Transformable.toCanvas(bboxOrPath).computeCenter();\n}\nfunction drawPickedFocus(focusIndicator, pick) {\n  const { bounds, showFocusBox } = pick;\n  if (showFocusBox) {\n    focusIndicator?.updateBounds(bounds);\n  }\n}\nfunction makeKeyboardPointerEvent(focusIndicator, pick) {\n  drawPickedFocus(focusIndicator, pick);\n  const { x: offsetX, y: offsetY } = computeCenter(pick.bounds) ?? {};\n  if (offsetX !== void 0 && offsetY !== void 0) {\n    return { type: \"keyboard\", offsetX, offsetY };\n  }\n  return void 0;\n}\n\n// packages/ag-charts-community/src/chart/series/util.ts\nfunction convertValuesToScaleByDefs({\n  defs,\n  values,\n  xAxis,\n  yAxis\n}) {\n  if (!(xAxis && yAxis)) {\n    throw new Error(\"Axes must be defined\");\n  }\n  const result = {};\n  for (const [searchId, { def }] of defs) {\n    if (Object.hasOwn(values, searchId)) {\n      const { scale: scale2 } = def.type === \"key\" ? xAxis : yAxis;\n      result[searchId] = Math.round(scale2.convert(values[searchId]));\n    }\n  }\n  return result;\n}\nfunction pickNode(inputSeries, point, intent, exactMatchOnly) {\n  const reverseSeries = [...inputSeries].reverse();\n  let result;\n  for (const series of reverseSeries) {\n    if (!series.visible || !series.rootGroup.visible) {\n      continue;\n    }\n    const { match, distance: distance3 } = series.pickNode(point, intent, exactMatchOnly) ?? {};\n    if (!match || distance3 == null) {\n      continue;\n    }\n    if (!result || result.distance > distance3) {\n      result = { series, distance: distance3, datum: match };\n    }\n    if (distance3 === 0) {\n      break;\n    }\n  }\n  return result;\n}\n\n// packages/ag-charts-community/src/chart/series/seriesAreaManager.ts\nvar SeriesAreaAriaLabel = class {\n  constructor(element2, id) {\n    this.element = element2;\n    this.id = id;\n    element2.id = id;\n    element2.style.display = \"none\";\n    setAttribute(element2.parentElement, \"aria-labelledby\", id);\n  }\n  layoutComplete(event) {\n    this.element.parentElement.style.width = `${event.chart.width}px`;\n    this.element.parentElement.style.height = `${event.chart.height}px`;\n  }\n  set text(text) {\n    this.element.textContent = text;\n  }\n};\nvar SeriesAreaManager = class extends BaseManager {\n  constructor(chart) {\n    super();\n    this.chart = chart;\n    this.id = createId(this);\n    this.series = [];\n    this.highlight = {\n      /** Last received event that still needs to be applied. */\n      pendingHoverEvent: void 0,\n      /** Last applied event. */\n      appliedHoverEvent: void 0,\n      /** Last applied event, which has been temporarily stashed during the main chart update cycle. */\n      stashedHoverEvent: void 0\n    };\n    this.tooltip = {\n      lastHover: void 0\n    };\n    /**\n     * A11y Requirements for Tooltip/Highlight (see AG-13051 for details):\n     *\n     *   -   When the series-area is blurred, always the mouse to update the tooltip/highlight.\n     *\n     *   -   When the series-area receives a `focus` event, use `:focus-visible` to guess the input device.\n     *       (this is decided by the browser).\n     *\n     *   -   For keyboard users, `focus` and `keydown` events always updates & shows the tooltip/highlight on\n     *       the currently (or newly) focused datum.\n     *\n     *   -   For keyboard users, `mousemove` events update the tooltip/highlight iff `pickNode` finds a match\n     *       for the mouse event offsets.\n     */\n    this.hoverDevice = \"mouse\";\n    this.focus = {\n      sortedSeries: [],\n      series: void 0,\n      seriesIndex: 0,\n      datumIndex: 0,\n      datum: void 0\n    };\n    this.hoverScheduler = debouncedAnimationFrame(() => {\n      if (!this.tooltip.lastHover && !this.highlight.pendingHoverEvent)\n        return;\n      if (this.chart.getUpdateType() <= 4 /* SERIES_UPDATE */) {\n        this.hoverScheduler.schedule();\n        return;\n      }\n      if (this.highlight.pendingHoverEvent) {\n        this.handleHoverHighlight(false);\n      }\n      if (this.tooltip.lastHover) {\n        this.handleHoverTooltip(this.tooltip.lastHover, false);\n      }\n    });\n    const seriesRegion = chart.ctx.regionManager.getRegion(\"series\" /* SERIES */);\n    const horizontalAxesRegion = chart.ctx.regionManager.getRegion(\"horizontal-axes\" /* HORIZONTAL_AXES */);\n    const verticalAxesRegion = chart.ctx.regionManager.getRegion(\"vertical-axes\" /* VERTICAL_AXES */);\n    const mouseMoveStates = 32 /* Default */ | 8 /* Annotations */ | 1 /* AnnotationsSelected */;\n    const keyState = 32 /* Default */ | 2 /* Animation */;\n    const labelEl = chart.ctx.domManager.addChild(\"series-area\", \"series-area-aria-label\");\n    this.ariaLabel = new SeriesAreaAriaLabel(labelEl, `${this.id}-aria-label`);\n    this.destroyFns.push(\n      () => chart.ctx.domManager.removeChild(\"series-area\", \"series-area-aria-label\"),\n      seriesRegion.addListener(\"contextmenu\", (event) => this.onContextMenu(event), 63 /* All */),\n      seriesRegion.addListener(\"drag\", (event) => this.onHoverLikeEvent(event), mouseMoveStates),\n      seriesRegion.addListener(\"hover\", (event) => this.onHover(event), mouseMoveStates),\n      seriesRegion.addListener(\"leave\", () => this.onLeave(), mouseMoveStates),\n      horizontalAxesRegion.addListener(\"hover\", (event) => this.onHover(event), mouseMoveStates),\n      horizontalAxesRegion.addListener(\"leave\", () => this.onLeave()),\n      verticalAxesRegion.addListener(\"hover\", (event) => this.onHover(event), mouseMoveStates),\n      verticalAxesRegion.addListener(\"leave\", () => this.onLeave()),\n      chart.ctx.animationManager.addListener(\"animation-start\", () => this.clearAll()),\n      chart.ctx.domManager.addListener(\"resize\", () => this.clearAll()),\n      chart.ctx.highlightManager.addListener(\"highlight-change\", (event) => this.changeHighlightDatum(event)),\n      chart.ctx.keyNavManager.addListener(\"blur\", () => this.onBlur()),\n      chart.ctx.keyNavManager.addListener(\"focus\", (event) => this.onFocus(event), keyState),\n      chart.ctx.keyNavManager.addListener(\"nav-hori\", (event) => this.onNavHori(event), keyState),\n      chart.ctx.keyNavManager.addListener(\"nav-vert\", (event) => this.onNavVert(event), keyState),\n      chart.ctx.keyNavManager.addListener(\"submit\", (event) => this.onSubmit(event), keyState),\n      chart.ctx.layoutManager.addListener(\"layout:complete\", (event) => this.layoutComplete(event)),\n      chart.ctx.regionManager.listenAll(\"click\", (event) => this.onClick(event)),\n      chart.ctx.regionManager.listenAll(\"dblclick\", (event) => this.onClick(event)),\n      chart.ctx.updateService.addListener(\"pre-scene-render\", () => this.preSceneRender()),\n      chart.ctx.zoomManager.addListener(\"zoom-change\", () => this.clearAll()),\n      chart.ctx.zoomManager.addListener(\"zoom-pan-start\", () => this.clearAll())\n    );\n  }\n  dataChanged() {\n    var _a;\n    (_a = this.highlight).stashedHoverEvent ?? (_a.stashedHoverEvent = this.highlight.appliedHoverEvent);\n    this.chart.ctx.tooltipManager.removeTooltip(this.id);\n    this.chart.ctx.focusIndicator.updateBounds(void 0);\n    this.clearHighlight();\n  }\n  preSceneRender() {\n    this.refreshFocus();\n    if (this.highlight.stashedHoverEvent != null) {\n      this.highlight.pendingHoverEvent = this.highlight.stashedHoverEvent;\n      this.highlight.stashedHoverEvent = void 0;\n      this.handleHoverHighlight(true);\n    }\n    if (this.tooltip.lastHover != null) {\n      this.handleHoverTooltip(this.tooltip.lastHover, true);\n    }\n  }\n  update(type, opts) {\n    this.chart.ctx.updateService.update(type, opts);\n  }\n  seriesChanged(series) {\n    this.focus.sortedSeries = [...series].sort((a, b) => {\n      let fpA = a.properties.focusPriority ?? Infinity;\n      let fpB = b.properties.focusPriority ?? Infinity;\n      if (fpA === fpB) {\n        [fpA, fpB] = [a._declarationOrder, b._declarationOrder];\n      }\n      if (fpA < fpB) {\n        return -1;\n      } else if (fpA > fpB) {\n        return 1;\n      }\n      return 0;\n    });\n    this.series = series;\n  }\n  layoutComplete(event) {\n    this.seriesRect = event.series.rect;\n    this.hoverRect = event.series.paddedRect;\n    this.ariaLabel.layoutComplete(event);\n  }\n  onContextMenu(event) {\n    const { Default: Default2, ContextMenu } = InteractionState;\n    let pickedNode;\n    let position;\n    if (this.chart.ctx.focusIndicator.isFocusVisible()) {\n      pickedNode = this.chart.ctx.highlightManager.getActiveHighlight();\n      if (pickedNode && this.seriesRect && pickedNode.midPoint) {\n        position = Transformable.toCanvasPoint(\n          pickedNode.series.contentGroup,\n          pickedNode.midPoint.x,\n          pickedNode.midPoint.y\n        );\n      }\n    } else if (this.chart.ctx.interactionManager.getState() & (Default2 | ContextMenu)) {\n      const match = pickNode(this.series, { x: event.regionOffsetX, y: event.regionOffsetY }, \"context-menu\");\n      if (match) {\n        this.chart.ctx.highlightManager.updateHighlight(this.id);\n        pickedNode = match.datum;\n      }\n    }\n    this.clearAll();\n    this.chart.ctx.contextMenuRegistry.dispatchContext(\"series\", event, { pickedNode }, position);\n  }\n  onLeave() {\n    this.chart.ctx.cursorManager.updateCursor(this.id);\n    if (!this.chart.ctx.focusIndicator.isFocusVisible())\n      this.clearAll();\n  }\n  onHover(event) {\n    this.hoverDevice = \"mouse\";\n    this.onHoverLikeEvent(event);\n  }\n  onHoverLikeEvent(event) {\n    if (excludesType(event, \"drag\")) {\n      this.tooltip.lastHover = event;\n    }\n    this.highlight.pendingHoverEvent = event;\n    this.hoverScheduler.schedule();\n    if (this.chart.ctx.interactionManager.getState() === 32 /* Default */) {\n      const { regionOffsetX, regionOffsetY } = event;\n      const found = pickNode(this.series, { x: regionOffsetX, y: regionOffsetY }, \"event\");\n      if (found?.series.hasEventListener(\"nodeClick\") || found?.series.hasEventListener(\"nodeDoubleClick\")) {\n        this.chart.ctx.cursorManager.updateCursor(this.id, \"pointer\");\n      } else {\n        this.chart.ctx.cursorManager.updateCursor(this.id);\n      }\n    }\n  }\n  onClick(event) {\n    this.hoverDevice = \"mouse\";\n    this.onHoverLikeEvent(event);\n    if (this.seriesRect?.containsPoint(event.offsetX, event.offsetY) && this.checkSeriesNodeClick(event)) {\n      this.update(4 /* SERIES_UPDATE */);\n      event.preventDefault();\n      return;\n    }\n    const newEvent = { type: event.type === \"click\" ? \"click\" : \"doubleClick\", event: event.sourceEvent };\n    this.chart.fireEvent(newEvent);\n  }\n  onFocus(event) {\n    this.hoverDevice = this.chart.ctx.focusIndicator.isFocusVisible() ? \"keyboard\" : \"mouse\";\n    this.handleFocus(0, 0);\n    event.preventDefault();\n  }\n  onBlur() {\n    this.hoverDevice = \"mouse\";\n    this.clearAll();\n  }\n  onNavVert(event) {\n    this.hoverDevice = \"keyboard\";\n    this.focus.seriesIndex += event.delta;\n    this.handleFocus(event.delta, 0);\n    event.preventDefault();\n  }\n  onNavHori(event) {\n    this.hoverDevice = \"keyboard\";\n    this.focus.datumIndex += event.delta;\n    this.handleFocus(0, event.delta);\n    event.preventDefault();\n  }\n  onSubmit(event) {\n    const { series, datum } = this.focus;\n    const sourceEvent = event.sourceEvent.sourceEvent;\n    if (series !== void 0 && datum !== void 0) {\n      series.fireNodeClickEvent(sourceEvent, datum);\n    } else {\n      this.chart.fireEvent({\n        type: \"click\",\n        event: sourceEvent\n      });\n    }\n    event.preventDefault();\n  }\n  checkSeriesNodeClick(event) {\n    let point = { x: event.regionOffsetX, y: event.regionOffsetY };\n    if (event.region !== \"series\") {\n      point = Transformable.fromCanvasPoint(this.chart.seriesRoot, event.offsetX, event.offsetY);\n    }\n    const result = pickNode(this.series, point, \"event\");\n    if (result == null)\n      return false;\n    if (event.type === \"click\") {\n      result.series.fireNodeClickEvent(event.sourceEvent, result.datum);\n      return true;\n    }\n    if (event.type === \"dblclick\") {\n      event.preventZoomDblClick = result.distance === 0;\n      result.series.fireNodeDoubleClickEvent(event.sourceEvent, result.datum);\n      return true;\n    }\n    return false;\n  }\n  refreshFocus() {\n    if (this.chart.ctx.focusIndicator.isFocusVisible()) {\n      this.handleSeriesFocus(0, 0);\n    }\n  }\n  handleFocus(seriesIndexDelta, datumIndexDelta) {\n    const overlayFocus = this.chart.overlays.getFocusInfo(this.chart.ctx.localeManager);\n    if (overlayFocus == null) {\n      this.handleSeriesFocus(seriesIndexDelta, datumIndexDelta);\n    } else {\n      this.chart.ctx.focusIndicator.updateBounds(overlayFocus.rect);\n    }\n  }\n  handleSeriesFocus(otherIndexDelta, datumIndexDelta) {\n    if (this.chart.chartType === \"hierarchy\") {\n      this.handleHierarchySeriesFocus(otherIndexDelta, datumIndexDelta);\n      return;\n    }\n    const { focus, seriesRect } = this;\n    const visibleSeries = focus.sortedSeries.filter((s) => s.visible);\n    if (visibleSeries.length === 0)\n      return;\n    focus.seriesIndex = clamp(0, focus.seriesIndex, visibleSeries.length - 1);\n    focus.series = visibleSeries[focus.seriesIndex];\n    const { datumIndex, seriesIndex: otherIndex } = focus;\n    const pick = focus.series.pickFocus({ datumIndex, datumIndexDelta, otherIndex, otherIndexDelta, seriesRect });\n    this.updatePickedFocus(pick);\n  }\n  handleHierarchySeriesFocus(otherIndexDelta, datumIndexDelta) {\n    this.focus.series = this.focus.sortedSeries[0];\n    const {\n      focus: { series, seriesIndex: otherIndex, datumIndex },\n      seriesRect\n    } = this;\n    if (series === void 0)\n      return;\n    const pick = series.pickFocus({ datumIndex, datumIndexDelta, otherIndex, otherIndexDelta, seriesRect });\n    this.updatePickedFocus(pick);\n  }\n  updatePickedFocus(pick) {\n    const { focus } = this;\n    if (pick === void 0 || focus.series === void 0)\n      return;\n    const { datum, datumIndex } = pick;\n    focus.datumIndex = datumIndex;\n    focus.datum = datum;\n    if (this.chart.ctx.focusIndicator.isFocusVisible()) {\n      this.chart.ctx.animationManager.reset();\n    }\n    const keyboardEvent = makeKeyboardPointerEvent(this.chart.ctx.focusIndicator, pick);\n    if (keyboardEvent !== void 0 && this.hoverDevice === \"keyboard\") {\n      this.tooltip.lastHover = void 0;\n      this.highlight.appliedHoverEvent = void 0;\n      this.highlight.pendingHoverEvent = void 0;\n      this.highlight.stashedHoverEvent = void 0;\n      const html = focus.series.getTooltipHtml(datum);\n      const meta = TooltipManager.makeTooltipMeta(keyboardEvent, datum);\n      this.chart.ctx.highlightManager.updateHighlight(this.id, datum);\n      this.chart.ctx.tooltipManager.updateTooltip(this.id, meta, html);\n      this.ariaLabel.text = this.getDatumAriaText(datum, html);\n    }\n  }\n  getDatumAriaText(datum, html) {\n    const description = html.ariaLabel;\n    return this.chart.ctx.localeManager.t(\"ariaAnnounceHoverDatum\", {\n      datum: datum.series.getDatumAriaText?.(datum, description) ?? description\n    });\n  }\n  clearHighlight() {\n    this.highlight.pendingHoverEvent = void 0;\n    this.highlight.appliedHoverEvent = void 0;\n    this.chart.ctx.highlightManager.updateHighlight(this.id);\n  }\n  clearTooltip() {\n    this.chart.ctx.tooltipManager.removeTooltip(this.id);\n    this.tooltip.lastHover = void 0;\n  }\n  clearAll() {\n    this.clearHighlight();\n    this.clearTooltip();\n    this.chart.ctx.focusIndicator.updateBounds(void 0);\n  }\n  handleHoverHighlight(redisplay) {\n    this.highlight.appliedHoverEvent = this.highlight.pendingHoverEvent;\n    this.highlight.pendingHoverEvent = void 0;\n    const event = this.highlight.appliedHoverEvent;\n    if (!event)\n      return;\n    const state = this.chart.ctx.interactionManager.getState();\n    if (state !== 32 /* Default */ && state !== 8 /* Annotations */ && state !== 1 /* AnnotationsSelected */)\n      return;\n    const { offsetX, offsetY } = event;\n    if (redisplay ? this.chart.ctx.animationManager.isActive() : !this.hoverRect?.containsPoint(offsetX, offsetY)) {\n      this.clearHighlight();\n      return;\n    }\n    let pickCoords = { x: event.regionOffsetX, y: event.regionOffsetY };\n    if (event.region !== \"series\") {\n      pickCoords = Transformable.fromCanvasPoint(this.chart.seriesRoot, offsetX, offsetY);\n    }\n    const { range: range3 } = this.chart.highlight;\n    const intent = range3 === \"tooltip\" ? \"highlight-tooltip\" : \"highlight\";\n    const found = pickNode(this.series, pickCoords, intent);\n    if (found) {\n      this.chart.ctx.highlightManager.updateHighlight(this.id, found.datum);\n      this.hoverDevice = \"mouse\";\n      return;\n    }\n    this.chart.ctx.highlightManager.updateHighlight(this.id);\n  }\n  handleHoverTooltip(event, redisplay) {\n    const state = this.chart.ctx.interactionManager.getState();\n    if (state !== 32 /* Default */ && state !== 8 /* Annotations */ && state !== 1 /* AnnotationsSelected */)\n      return;\n    const { offsetX, offsetY, targetElement, regionOffsetX, regionOffsetY } = event;\n    if (redisplay ? this.chart.ctx.animationManager.isActive() : !this.hoverRect?.containsPoint(offsetX, offsetY)) {\n      if (this.hoverDevice == \"mouse\")\n        this.clearTooltip();\n      return;\n    }\n    if (targetElement && this.chart.tooltip.interactive && this.chart.ctx.domManager.isManagedChildDOMElement(targetElement, \"canvas-overlay\", DEFAULT_TOOLTIP_CLASS)) {\n      return;\n    }\n    let pickCoords = { x: regionOffsetX, y: regionOffsetY };\n    if (event.region !== \"series\") {\n      pickCoords = Transformable.fromCanvasPoint(this.chart.seriesRoot, offsetX, offsetY);\n    }\n    const pick = pickNode(this.series, pickCoords, \"tooltip\");\n    if (!pick) {\n      if (this.hoverDevice == \"mouse\")\n        this.clearTooltip();\n      return;\n    }\n    this.hoverDevice = \"mouse\";\n    const html = pick.series.getTooltipHtml(pick.datum);\n    const tooltipEnabled = this.chart.tooltip.enabled && pick.series.tooltipEnabled;\n    const shouldUpdateTooltip = tooltipEnabled && html != null;\n    if (shouldUpdateTooltip) {\n      const meta = TooltipManager.makeTooltipMeta(event, pick.datum);\n      this.chart.ctx.tooltipManager.updateTooltip(this.id, meta, html);\n    }\n  }\n  changeHighlightDatum(event) {\n    const seriesToUpdate = /* @__PURE__ */ new Set();\n    const { series: newSeries = void 0, datum: newDatum } = event.currentHighlight ?? {};\n    const { series: lastSeries = void 0, datum: lastDatum } = event.previousHighlight ?? {};\n    if (lastSeries) {\n      seriesToUpdate.add(lastSeries);\n    }\n    if (newSeries) {\n      seriesToUpdate.add(newSeries);\n    }\n    if (lastSeries?.properties.cursor && lastDatum) {\n      this.chart.ctx.cursorManager.updateCursor(lastSeries.id);\n    }\n    if (newSeries?.properties.cursor && newSeries?.properties.cursor !== \"default\" && newDatum) {\n      this.chart.ctx.cursorManager.updateCursor(newSeries.id, newSeries.properties.cursor);\n    }\n    const updateAll = newSeries == null || lastSeries == null;\n    if (updateAll) {\n      this.update(4 /* SERIES_UPDATE */);\n    } else {\n      this.update(4 /* SERIES_UPDATE */, { seriesToUpdate });\n    }\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/seriesLayerManager.ts\nvar SERIES_THRESHOLD_FOR_AGGRESSIVE_LAYER_REDUCTION = 30;\nvar SeriesLayerManager = class {\n  constructor(seriesRoot, highlightRoot, annotationRoot) {\n    this.seriesRoot = seriesRoot;\n    this.highlightRoot = highlightRoot;\n    this.annotationRoot = annotationRoot;\n    this.groups = {};\n    this.series = {};\n    this.expectedSeriesCount = 1;\n    this.mode = \"normal\";\n  }\n  setSeriesCount(count) {\n    this.expectedSeriesCount = count;\n  }\n  requestGroup(seriesConfig) {\n    var _a, _b;\n    const {\n      internalId,\n      type,\n      rootGroup: seriesRootGroup,\n      highlightGroup: seriesHighlightGroup,\n      annotationGroup: seriesAnnotationGroup,\n      seriesGrouping\n    } = seriesConfig;\n    const { groupIndex = internalId } = seriesGrouping ?? {};\n    if (this.series[internalId] != null) {\n      throw new Error(`AG Charts - series already has an allocated layer: ${this.series[internalId]}`);\n    }\n    if (Object.keys(this.series).length === 0) {\n      this.mode = this.expectedSeriesCount >= SERIES_THRESHOLD_FOR_AGGRESSIVE_LAYER_REDUCTION ? \"aggressive-grouping\" : \"normal\";\n    }\n    (_a = this.groups)[type] ?? (_a[type] = {});\n    const lookupIndex = this.lookupIdx(groupIndex);\n    const groupInfo = (_b = this.groups[type])[lookupIndex] ?? (_b[lookupIndex] = {\n      type,\n      id: lookupIndex,\n      seriesIds: [],\n      group: this.seriesRoot.appendChild(\n        new Layer({\n          name: `${type}-content`,\n          zIndex: 4 /* SERIES_LAYER */,\n          zIndexSubOrder: seriesConfig.getGroupZIndexSubOrder(\"data\")\n        })\n      ),\n      highlight: this.highlightRoot.appendChild(\n        new Group({\n          name: `${type}-highlight`,\n          zIndex: 4 /* SERIES_LAYER */,\n          zIndexSubOrder: seriesConfig.getGroupZIndexSubOrder(\"highlight\")\n        })\n      ),\n      annotation: this.annotationRoot.appendChild(\n        new Group({\n          name: `${type}-annotation`,\n          zIndex: 4 /* SERIES_LAYER */,\n          zIndexSubOrder: seriesConfig.getGroupZIndexSubOrder(\"annotation\")\n        })\n      )\n    });\n    this.series[internalId] = { layerState: groupInfo, seriesConfig };\n    groupInfo.seriesIds.push(internalId);\n    groupInfo.group.appendChild(seriesRootGroup);\n    groupInfo.highlight.appendChild(seriesHighlightGroup);\n    groupInfo.annotation.appendChild(seriesAnnotationGroup);\n    return groupInfo.group;\n  }\n  changeGroup(seriesConfig) {\n    const { internalId, seriesGrouping, type, rootGroup, highlightGroup, annotationGroup, oldGrouping } = seriesConfig;\n    const { groupIndex = internalId } = seriesGrouping ?? {};\n    if (this.groups[type]?.[groupIndex]?.seriesIds.includes(internalId)) {\n      return;\n    }\n    if (this.series[internalId] != null) {\n      this.releaseGroup({\n        internalId,\n        seriesGrouping: oldGrouping,\n        type,\n        rootGroup,\n        highlightGroup,\n        annotationGroup\n      });\n    }\n    this.requestGroup(seriesConfig);\n  }\n  releaseGroup(seriesConfig) {\n    const { internalId, rootGroup, highlightGroup, annotationGroup, type } = seriesConfig;\n    if (this.series[internalId] == null) {\n      throw new Error(`AG Charts - series doesn't have an allocated layer: ${internalId}`);\n    }\n    const groupInfo = this.series[internalId]?.layerState;\n    if (groupInfo) {\n      groupInfo.seriesIds = groupInfo.seriesIds.filter((v) => v !== internalId);\n      groupInfo.group.removeChild(rootGroup);\n      groupInfo.highlight.removeChild(highlightGroup);\n      groupInfo.annotation.removeChild(annotationGroup);\n    }\n    if (groupInfo?.seriesIds.length === 0) {\n      this.seriesRoot.removeChild(groupInfo.group);\n      this.highlightRoot.removeChild(groupInfo.highlight);\n      this.annotationRoot.removeChild(groupInfo.annotation);\n      delete this.groups[groupInfo.type][groupInfo.id];\n      delete this.groups[type][internalId];\n    } else if (groupInfo?.seriesIds.length > 0) {\n      const leadSeriesConfig = this.series[groupInfo?.seriesIds?.[0]]?.seriesConfig;\n      groupInfo.group.zIndexSubOrder = leadSeriesConfig?.getGroupZIndexSubOrder(\"data\");\n      groupInfo.highlight.zIndexSubOrder = leadSeriesConfig?.getGroupZIndexSubOrder(\"highlight\");\n      groupInfo.annotation.zIndexSubOrder = leadSeriesConfig?.getGroupZIndexSubOrder(\"annotation\");\n    }\n    delete this.series[internalId];\n  }\n  lookupIdx(groupIndex) {\n    if (this.mode === \"normal\") {\n      return groupIndex;\n    }\n    if (typeof groupIndex === \"string\") {\n      groupIndex = Number(groupIndex.split(\"-\").at(-1));\n      if (!groupIndex) {\n        return 0;\n      }\n    }\n    return Math.floor(\n      clamp(0, groupIndex / this.expectedSeriesCount, 1) * SERIES_THRESHOLD_FOR_AGGRESSIVE_LAYER_REDUCTION\n    );\n  }\n  destroy() {\n    for (const groups of Object.values(this.groups)) {\n      for (const groupInfo of Object.values(groups)) {\n        this.seriesRoot.removeChild(groupInfo.group);\n        this.highlightRoot.removeChild(groupInfo.highlight);\n        this.annotationRoot.removeChild(groupInfo.annotation);\n      }\n    }\n    this.groups = {};\n    this.series = {};\n  }\n};\n\n// packages/ag-charts-community/src/chart/update/dataWindowProcessor.ts\nvar DataWindowProcessor = class {\n  constructor(chart, dataService, updateService, zoomManager) {\n    this.chart = chart;\n    this.dataService = dataService;\n    this.updateService = updateService;\n    this.zoomManager = zoomManager;\n    this.dirtyZoom = false;\n    this.dirtyDataSource = false;\n    this.lastAxisZooms = /* @__PURE__ */ new Map();\n    this.destroyFns = [];\n    this.destroyFns.push(\n      this.dataService.addListener(\"data-source-change\", () => this.onDataSourceChange()),\n      this.dataService.addListener(\"data-load\", () => this.onDataLoad()),\n      this.dataService.addListener(\"data-error\", () => this.onDataError()),\n      this.updateService.addListener(\"update-complete\", () => this.onUpdateComplete()),\n      this.zoomManager.addListener(\"zoom-change\", () => this.onZoomChange())\n    );\n  }\n  destroy() {\n    this.destroyFns.forEach((cb) => cb());\n  }\n  onDataLoad() {\n    this.updateService.update(1 /* UPDATE_DATA */);\n  }\n  onDataError() {\n    this.updateService.update(3 /* PERFORM_LAYOUT */);\n  }\n  onDataSourceChange() {\n    this.dirtyDataSource = true;\n  }\n  onUpdateComplete() {\n    if (!this.dirtyZoom && !this.dirtyDataSource)\n      return;\n    this.updateWindow().catch((e) => Logger.errorOnce(e));\n  }\n  onZoomChange() {\n    this.dirtyZoom = true;\n  }\n  async updateWindow() {\n    if (!this.dataService.isLazy())\n      return;\n    const axis = this.getValidAxis();\n    let window2;\n    let shouldRefresh = true;\n    if (axis) {\n      const zoom2 = this.zoomManager.getAxisZoom(axis.id);\n      window2 = this.getAxisWindow(axis, zoom2);\n      shouldRefresh = this.shouldRefresh(axis, zoom2);\n    }\n    this.dirtyZoom = false;\n    this.dirtyDataSource = false;\n    if (!shouldRefresh)\n      return;\n    this.dataService.load({ windowStart: window2?.min, windowEnd: window2?.max });\n  }\n  getValidAxis() {\n    return this.chart.axes.find((axis) => axis.type === \"time\");\n  }\n  shouldRefresh(axis, zoom2) {\n    if (this.dirtyDataSource)\n      return true;\n    if (!this.dirtyZoom)\n      return false;\n    const lastZoom = this.lastAxisZooms.get(axis.id);\n    if (lastZoom && zoom2.min === lastZoom.min && zoom2.max === lastZoom.max) {\n      return false;\n    }\n    this.lastAxisZooms.set(axis.id, zoom2);\n    return true;\n  }\n  getAxisWindow(axis, zoom2) {\n    const domain = axis.scale.getDomain?.();\n    if (!zoom2 || !domain || domain.length === 0 || isNaN(Number(domain[0])))\n      return;\n    const diff2 = Number(domain[1]) - Number(domain[0]);\n    const min = new Date(Number(domain[0]) + diff2 * zoom2.min);\n    const max = new Date(Number(domain[0]) + diff2 * zoom2.max);\n    return { min, max };\n  }\n};\n\n// packages/ag-charts-community/src/chart/update/overlaysProcessor.ts\nvar OverlaysProcessor = class {\n  constructor(chartLike, overlays, dataService, layoutManager, localeManager, animationManager, domManager) {\n    this.chartLike = chartLike;\n    this.overlays = overlays;\n    this.dataService = dataService;\n    this.layoutManager = layoutManager;\n    this.localeManager = localeManager;\n    this.animationManager = animationManager;\n    this.domManager = domManager;\n    this.destroyFns = [];\n    this.overlayElem = this.domManager.addChild(\"canvas-overlay\", \"overlay\");\n    this.overlayElem.role = \"status\";\n    this.overlayElem.ariaAtomic = \"false\";\n    this.overlayElem.ariaLive = \"polite\";\n    this.overlayElem.classList.toggle(DEFAULT_OVERLAY_CLASS);\n    this.destroyFns.push(this.layoutManager.addListener(\"layout:complete\", (e) => this.onLayoutComplete(e)));\n  }\n  destroy() {\n    this.destroyFns.forEach((cb) => cb());\n    this.domManager.removeStyles(\"overlays\");\n    this.domManager.removeChild(\"canvas-overlay\", \"overlay\");\n  }\n  onLayoutComplete({ series: { rect } }) {\n    const isLoading = this.dataService.isLoading();\n    const hasData = this.chartLike.series.some((s) => s.hasData);\n    const anySeriesVisible = this.chartLike.series.some((s) => s.visible);\n    if (this.overlays.darkTheme) {\n      this.overlayElem.classList.add(DEFAULT_OVERLAY_DARK_CLASS);\n    } else {\n      this.overlayElem.classList.remove(DEFAULT_OVERLAY_DARK_CLASS);\n    }\n    this.overlayElem.style.left = `${rect.x}px`;\n    this.overlayElem.style.top = `${rect.y}px`;\n    this.overlayElem.style.width = `${rect.width}px`;\n    this.overlayElem.style.height = `${rect.height}px`;\n    const loadingShown = isLoading;\n    const noDataShown = !isLoading && !hasData;\n    const noVisibleSeriesShown = hasData && !anySeriesVisible;\n    if (loadingShown) {\n      this.showOverlay(this.overlays.loading, rect);\n    } else {\n      this.hideOverlay(this.overlays.loading);\n    }\n    if (noDataShown) {\n      this.showOverlay(this.overlays.noData, rect);\n    } else {\n      this.hideOverlay(this.overlays.noData);\n    }\n    if (noVisibleSeriesShown) {\n      this.showOverlay(this.overlays.noVisibleSeries, rect);\n    } else {\n      this.hideOverlay(this.overlays.noVisibleSeries);\n    }\n    const shown = loadingShown || noDataShown || noVisibleSeriesShown;\n    setAttribute(this.overlayElem, \"aria-hidden\", !shown);\n  }\n  showOverlay(overlay, seriesRect) {\n    const element2 = overlay.getElement(this.animationManager, this.localeManager, seriesRect);\n    this.overlayElem.appendChild(element2);\n  }\n  hideOverlay(overlay) {\n    overlay.removeElement(() => {\n      this.overlayElem.innerText = \"\\xA0\";\n    }, this.animationManager);\n  }\n};\n\n// packages/ag-charts-community/src/chart/chart.ts\nvar debug = Debug.create(true, \"opts\");\nvar SeriesArea = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.padding = new Padding(0);\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], SeriesArea.prototype, \"clip\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], SeriesArea.prototype, \"padding\", 2);\nvar _Chart = class _Chart extends Observable {\n  constructor(options, resources) {\n    var _a;\n    super();\n    this.id = createId(this);\n    this.seriesRoot = new TranslatableGroup({ name: `${this.id}-series-root` });\n    this.highlightRoot = new TranslatableLayer({\n      name: `${this.id}-highlight-root`,\n      zIndex: 5 /* SERIES_HIGHLIGHT */,\n      deriveZIndexFromChildren: true\n      // TODO remove feature\n    });\n    this.annotationRoot = new TranslatableLayer({\n      name: `${this.id}-annotation-root`,\n      zIndex: 10 /* SERIES_ANNOTATION */\n    });\n    this.debug = Debug.create();\n    this.extraDebugStats = {};\n    this.data = [];\n    this._firstAutoSize = true;\n    this.padding = new Padding(20);\n    this.seriesArea = new SeriesArea();\n    this.keyboard = new Keyboard();\n    this.mode = \"standalone\";\n    this.chartCaptions = new ChartCaptions();\n    this.destroyed = false;\n    this._destroyFns = [];\n    // Used to prevent infinite update loops when syncing charts.\n    this.skipSync = false;\n    this.chartAnimationPhase = \"initial\";\n    this.modulesManager = new ModulesManager();\n    this.processors = [];\n    this.queuedUserOptions = [];\n    this._pendingFactoryUpdatesCount = 0;\n    this._performUpdateNoRenderCount = 0;\n    this._performUpdateSkipAnimations = false;\n    this.performUpdateType = 7 /* NONE */;\n    this.updateShortcutCount = 0;\n    this.seriesToUpdate = /* @__PURE__ */ new Set();\n    this.updateMutex = new Mutex();\n    this.updateRequestors = {};\n    this.performUpdateTrigger = debouncedCallback(async ({ count }) => {\n      if (this.destroyed)\n        return;\n      this.updateMutex.acquire(async () => {\n        try {\n          await this.performUpdate(count);\n        } catch (error) {\n          Logger.error(\"update error\", error);\n        }\n      }).catch((e) => Logger.errorOnce(e));\n    });\n    this._performUpdateSplits = {};\n    this.axes = [];\n    this.series = [];\n    this.onSeriesNodeClick = (event) => {\n      this.fireEvent({ ...event, type: \"seriesNodeClick\" });\n    };\n    this.onSeriesNodeDoubleClick = (event) => {\n      this.fireEvent({ ...event, type: \"seriesNodeDoubleClick\" });\n    };\n    this.seriesGroupingChanged = (event) => {\n      if (!(event instanceof SeriesGroupingChangedEvent))\n        return;\n      const { series, seriesGrouping, oldGrouping } = event;\n      if (series.rootGroup.isRoot())\n        return;\n      this.seriesLayerManager.changeGroup({\n        internalId: series.internalId,\n        type: series.type,\n        rootGroup: series.rootGroup,\n        highlightGroup: series.highlightGroup,\n        annotationGroup: series.annotationGroup,\n        getGroupZIndexSubOrder: (type) => series.getGroupZIndexSubOrder(type),\n        seriesGrouping,\n        oldGrouping\n      });\n    };\n    this.chartOptions = options;\n    const scene = resources?.scene;\n    const container = resources?.container ?? options.processedOptions.container ?? void 0;\n    const styleContainer = resources?.styleContainer ?? options.specialOverrides.styleContainer;\n    const root = new Group({ name: \"root\" });\n    const titleGroup = new Layer({ name: \"titles\", zIndex: 14 /* SERIES_LABEL */ });\n    root.visible = false;\n    root.append(titleGroup);\n    root.append(this.seriesRoot);\n    root.append(this.highlightRoot);\n    root.append(this.annotationRoot);\n    titleGroup.append(this.title.node);\n    titleGroup.append(this.subtitle.node);\n    titleGroup.append(this.footnote.node);\n    this.tooltip = new Tooltip();\n    this.seriesLayerManager = new SeriesLayerManager(this.seriesRoot, this.highlightRoot, this.annotationRoot);\n    this.mode = options.userOptions.mode ?? this.mode;\n    const ctx = this.ctx = new ChartContext(this, {\n      scene,\n      root,\n      container,\n      styleContainer,\n      syncManager: new SyncManager(this),\n      pixelRatio: options.specialOverrides.overrideDevicePixelRatio,\n      updateCallback: (type = 0 /* FULL */, opts) => this.update(type, opts),\n      updateMutex: this.updateMutex\n    });\n    this._destroyFns.push(\n      ctx.domManager.addListener(\"resize\", () => this.parentResize(ctx.domManager.containerSize))\n    );\n    this.overlays = new ChartOverlays();\n    (_a = this.overlays.loading).renderer ?? (_a.renderer = () => getLoadingSpinner(this.overlays.loading.getText(ctx.localeManager), ctx.animationManager.defaultDuration));\n    this.processors = [\n      new DataWindowProcessor(this, ctx.dataService, ctx.updateService, ctx.zoomManager),\n      new OverlaysProcessor(\n        this,\n        this.overlays,\n        ctx.dataService,\n        ctx.layoutManager,\n        ctx.localeManager,\n        ctx.animationManager,\n        ctx.domManager\n      )\n    ];\n    this.highlight = new ChartHighlight();\n    this.container = container;\n    const moduleContext = this.getModuleContext();\n    ctx.regionManager.addRegion(\n      \"series\" /* SERIES */,\n      this.seriesRoot,\n      new SimpleRegionBBoxProvider(this.seriesRoot, () => this.seriesRect ?? BBox.zero),\n      this.ctx.axisManager.axisGridGroup\n    );\n    ctx.regionManager.addRegion(\"horizontal-axes\" /* HORIZONTAL_AXES */);\n    ctx.regionManager.addRegion(\"vertical-axes\" /* VERTICAL_AXES */);\n    ctx.regionManager.addRegion(\"root\", root);\n    ctx.domManager.setDataBoolean(\"animating\", false);\n    this.seriesAreaManager = new SeriesAreaManager(this.initSeriesAreaDependencies());\n    this._destroyFns.push(\n      ctx.layoutManager.registerElement(0 /* Caption */, (e) => {\n        e.layoutBox.shrink(this.padding.toJson());\n        this.chartCaptions.positionCaptions(e);\n      }),\n      ctx.layoutManager.addListener(\"layout:complete\", (e) => this.chartCaptions.positionAbsoluteCaptions(e)),\n      ctx.dataService.addListener(\"data-load\", (event) => {\n        this.data = event.data;\n      }),\n      this.title.registerInteraction(moduleContext, \"beforebegin\"),\n      this.subtitle.registerInteraction(moduleContext, \"beforebegin\"),\n      this.footnote.registerInteraction(moduleContext, \"afterend\"),\n      ctx.interactionManager.addListener(\"page-left\", () => this.destroy()),\n      ctx.animationManager.addListener(\"animation-frame\", () => {\n        this.update(6 /* SCENE_RENDER */);\n      }),\n      ctx.animationManager.addListener(\"animation-start\", () => ctx.domManager.setDataBoolean(\"animating\", true)),\n      ctx.animationManager.addListener(\"animation-stop\", () => ctx.domManager.setDataBoolean(\"animating\", false)),\n      ctx.zoomManager.addListener(\"zoom-change\", () => {\n        this.series.forEach((s) => s.animationState?.transition(\"updateData\"));\n        const skipAnimations = this.chartAnimationPhase !== \"initial\";\n        this.update(3 /* PERFORM_LAYOUT */, { forceNodeDataRefresh: true, skipAnimations });\n      })\n    );\n    this.parentResize(ctx.domManager.containerSize);\n  }\n  static getInstance(element2) {\n    return _Chart.chartsInstances.get(element2);\n  }\n  /** NOTE: This is exposed for use by Integrated charts only. */\n  get canvasElement() {\n    return this.ctx.scene.canvas.element;\n  }\n  download(fileName, fileFormat) {\n    this.ctx.scene.download(fileName, fileFormat);\n  }\n  getCanvasDataURL(fileFormat) {\n    return this.ctx.scene.getDataURL(fileFormat);\n  }\n  toSVG() {\n    return this.ctx.scene.toSVG();\n  }\n  getOptions() {\n    return this.queuedUserOptions.at(-1) ?? this.chartOptions.userOptions;\n  }\n  initSeriesAreaDependencies() {\n    const { ctx, tooltip, highlight, overlays, seriesRoot } = this;\n    const chartType2 = this.getChartType();\n    const fireEvent = this.fireEvent.bind(this);\n    const getUpdateType = () => this.performUpdateType;\n    return { fireEvent, getUpdateType, chartType: chartType2, ctx, tooltip, highlight, overlays, seriesRoot };\n  }\n  getModuleContext() {\n    return this.ctx;\n  }\n  getCaptionText() {\n    return [this.title, this.subtitle, this.footnote].filter((caption) => caption.enabled && caption.text).map((caption) => caption.text).join(\". \");\n  }\n  getAriaLabel() {\n    return this.ctx.localeManager.t(\"ariaAnnounceChart\", { seriesCount: this.series.length });\n  }\n  resetAnimations() {\n    this.chartAnimationPhase = \"initial\";\n    for (const series of this.series) {\n      series.resetAnimation(this.chartAnimationPhase);\n    }\n    for (const axis of this.axes) {\n      axis.resetAnimation(this.chartAnimationPhase);\n    }\n    this.animationRect = void 0;\n    this.ctx.animationManager.reset();\n  }\n  skipAnimations() {\n    this.ctx.animationManager.skipCurrentBatch();\n    this._performUpdateSkipAnimations = true;\n  }\n  destroy(opts) {\n    if (this.destroyed) {\n      return;\n    }\n    const keepTransferableResources = opts?.keepTransferableResources;\n    let result;\n    this.performUpdateType = 7 /* NONE */;\n    this._destroyFns.forEach((fn) => fn());\n    this.processors.forEach((p) => p.destroy());\n    this.tooltip.destroy(this.ctx.domManager);\n    this.overlays.destroy();\n    this.modulesManager.destroy();\n    if (keepTransferableResources) {\n      this.ctx.scene.strip();\n      result = {\n        container: this.container,\n        scene: this.ctx.scene\n      };\n    } else {\n      this.ctx.scene.destroy();\n      this.container = void 0;\n    }\n    this.destroySeries(this.series);\n    this.seriesLayerManager.destroy();\n    this.axes.forEach((a) => a.destroy());\n    this.axes = [];\n    this.animationRect = void 0;\n    this.ctx.destroy();\n    this.destroyed = true;\n    Object.freeze(this);\n    return result;\n  }\n  requestFactoryUpdate(cb) {\n    if (this.destroyed)\n      return;\n    this._pendingFactoryUpdatesCount++;\n    this.updateMutex.acquire(async () => {\n      if (this.destroyed)\n        return;\n      await cb(this);\n      if (this.destroyed)\n        return;\n      this._pendingFactoryUpdatesCount--;\n    }).catch((e) => Logger.errorOnce(e));\n  }\n  update(type = 0 /* FULL */, opts) {\n    const {\n      forceNodeDataRefresh = false,\n      skipAnimations,\n      seriesToUpdate = this.series,\n      newAnimationBatch\n    } = opts ?? {};\n    if (forceNodeDataRefresh) {\n      this.series.forEach((series) => series.markNodeDataDirty());\n    }\n    for (const series of seriesToUpdate) {\n      this.seriesToUpdate.add(series);\n    }\n    if (skipAnimations) {\n      this.ctx.animationManager.skipCurrentBatch();\n      this._performUpdateSkipAnimations = true;\n    }\n    if (newAnimationBatch && this.ctx.animationManager.isActive()) {\n      this._performUpdateSkipAnimations = true;\n    }\n    this.skipSync = opts?.skipSync ?? false;\n    if (this.debug.check()) {\n      let stack = new Error().stack ?? \"<unknown>\";\n      stack = stack.replace(/\\([^)]*/g, \"\");\n      this.updateRequestors[stack] = type;\n    }\n    if (type < this.performUpdateType) {\n      this.performUpdateType = type;\n      this.ctx.domManager.setDataBoolean(\"updatePending\", true);\n      this.performUpdateTrigger.schedule(opts?.backOffMs);\n    }\n  }\n  async performUpdate(count) {\n    const { performUpdateType, extraDebugStats, _performUpdateSplits: splits, ctx } = this;\n    const seriesToUpdate = [...this.seriesToUpdate];\n    this.performUpdateType = 7 /* NONE */;\n    this.seriesToUpdate.clear();\n    if (this.updateShortcutCount === 0 && performUpdateType < 6 /* SCENE_RENDER */) {\n      ctx.animationManager.startBatch(this._performUpdateSkipAnimations);\n      ctx.animationManager.onBatchStop(() => this.chartAnimationPhase = \"ready\");\n    }\n    this.debug(\"Chart.performUpdate() - start\", ChartUpdateType[performUpdateType]);\n    let previousSplit = performance.now();\n    splits.start ?? (splits.start = previousSplit);\n    const updateSplits = (splitName) => {\n      splits[splitName] ?? (splits[splitName] = 0);\n      splits[splitName] += performance.now() - previousSplit;\n      previousSplit = performance.now();\n    };\n    let updateDeferred = false;\n    switch (performUpdateType) {\n      case 0 /* FULL */:\n        this.ctx.updateService.dispatchPreDomUpdate();\n        this.updateDOM();\n      case 1 /* UPDATE_DATA */:\n        await this.updateData();\n        updateSplits(\"\\u2B07\\uFE0F\");\n      case 2 /* PROCESS_DATA */:\n        await this.processData();\n        this.seriesAreaManager.dataChanged();\n        updateSplits(\"\\u{1F3ED}\");\n      case 3 /* PERFORM_LAYOUT */:\n        if (this.checkUpdateShortcut(3 /* PERFORM_LAYOUT */))\n          break;\n        if (!this.checkFirstAutoSize(seriesToUpdate)) {\n          updateDeferred = true;\n          break;\n        }\n        await this.processLayout();\n        updateSplits(\"\\u2316\");\n      case 4 /* SERIES_UPDATE */: {\n        if (this.checkUpdateShortcut(4 /* SERIES_UPDATE */))\n          break;\n        const { seriesRect } = this;\n        await Promise.all(seriesToUpdate.map((series) => series.update({ seriesRect })));\n        updateSplits(\"\\u{1F914}\");\n        this.updateAriaLabels();\n      }\n      case 5 /* PRE_SCENE_RENDER */:\n        if (this.checkUpdateShortcut(5 /* PRE_SCENE_RENDER */))\n          break;\n        ctx.updateService.dispatchPreSceneRender(this.getMinRects());\n        updateSplits(\"\\u2196\");\n      case 6 /* SCENE_RENDER */:\n        if (this.checkUpdateShortcut(6 /* SCENE_RENDER */))\n          break;\n        ctx.animationManager.endBatch();\n        extraDebugStats[\"updateShortcutCount\"] = this.updateShortcutCount;\n        await ctx.scene.render({ debugSplitTimes: splits, extraDebugStats, seriesRect: this.seriesRect });\n        this.extraDebugStats = {};\n        for (const key in splits) {\n          delete splits[key];\n        }\n        this.ctx.domManager.incrementDataCounter(\"sceneRenders\");\n      case 7 /* NONE */:\n        this.updateShortcutCount = 0;\n        this.updateRequestors = {};\n        this._performUpdateSkipAnimations = false;\n        ctx.animationManager.endBatch();\n    }\n    if (!updateDeferred) {\n      ctx.updateService.dispatchUpdateComplete(this.getMinRects());\n      this.ctx.domManager.setDataBoolean(\"updatePending\", false);\n    }\n    const end2 = performance.now();\n    this.debug(\"Chart.performUpdate() - end\", {\n      chart: this,\n      durationMs: Math.round((end2 - splits[\"start\"]) * 100) / 100,\n      count,\n      performUpdateType: ChartUpdateType[performUpdateType]\n    });\n  }\n  updateThemeClassName() {\n    const { theme } = this.chartOptions.processedOptions;\n    const themeClassNamePrefix = \"ag-charts-theme-\";\n    const validThemeClassNames = [`${themeClassNamePrefix}default`, `${themeClassNamePrefix}default-dark`];\n    let themeClassName = validThemeClassNames[0];\n    let isDark = false;\n    if (typeof theme === \"string\") {\n      themeClassName = theme.replace(\"ag-\", themeClassNamePrefix);\n      isDark = theme.includes(\"-dark\");\n    } else if (typeof theme?.baseTheme === \"string\") {\n      themeClassName = theme.baseTheme.replace(\"ag-\", themeClassNamePrefix);\n      isDark = theme.baseTheme.includes(\"-dark\");\n    }\n    if (!validThemeClassNames.includes(themeClassName)) {\n      themeClassName = isDark ? validThemeClassNames[1] : validThemeClassNames[0];\n    }\n    this.ctx.domManager.setThemeClass(themeClassName);\n  }\n  updateDOM() {\n    this.updateThemeClassName();\n    const { enabled, tabIndex } = this.keyboard;\n    this.ctx.domManager.setTabIndex(enabled ? tabIndex ?? 0 : -1);\n  }\n  updateAriaLabels() {\n    this.ctx.domManager.updateCanvasLabel(this.getAriaLabel());\n  }\n  checkUpdateShortcut(checkUpdateType) {\n    const maxShortcuts = 3;\n    if (this.updateShortcutCount > maxShortcuts) {\n      Logger.warn(\n        `exceeded the maximum number of simultaneous updates (${maxShortcuts + 1}), discarding changes and rendering`,\n        this.updateRequestors\n      );\n      return false;\n    }\n    if (this.performUpdateType <= checkUpdateType) {\n      this.updateShortcutCount++;\n      return true;\n    }\n    return false;\n  }\n  checkFirstAutoSize(seriesToUpdate) {\n    if (this.width != null && this.height != null) {\n    } else if (!this._lastAutoSize) {\n      const count = this._performUpdateNoRenderCount++;\n      const backOffMs = (count + 1) ** 2 * 40;\n      if (count < 8) {\n        this.update(3 /* PERFORM_LAYOUT */, { seriesToUpdate, backOffMs });\n        this.debug(\"Chart.checkFirstAutoSize() - backing off until first size update\", backOffMs);\n        return false;\n      }\n      this.debug(\"Chart.checkFirstAutoSize() - timeout for first size update.\");\n    }\n    this._performUpdateNoRenderCount = 0;\n    return true;\n  }\n  onAxisChange(newValue, oldValue) {\n    if (oldValue == null && newValue.length === 0)\n      return;\n    this.ctx.axisManager.updateAxes(oldValue ?? [], newValue);\n  }\n  onSeriesChange(newValue, oldValue) {\n    const seriesToDestroy = oldValue?.filter((series) => !newValue.includes(series)) ?? [];\n    this.destroySeries(seriesToDestroy);\n    this.seriesLayerManager?.setSeriesCount(newValue.length);\n    for (const series of newValue) {\n      if (oldValue?.includes(series))\n        continue;\n      if (series.rootGroup.isRoot()) {\n        this.seriesLayerManager.requestGroup(series);\n      }\n      const chart = this;\n      series.chart = {\n        get mode() {\n          return chart.mode;\n        },\n        get isMiniChart() {\n          return false;\n        },\n        get seriesRect() {\n          return chart.seriesRect;\n        },\n        placeLabels(padding) {\n          return chart.placeLabels(padding);\n        }\n      };\n      series.resetAnimation(this.chartAnimationPhase);\n      this.addSeriesListeners(series);\n      series.addChartEventListeners();\n    }\n    this.seriesAreaManager?.seriesChanged(newValue);\n  }\n  destroySeries(allSeries) {\n    allSeries?.forEach((series) => {\n      series.removeEventListener(\"nodeClick\", this.onSeriesNodeClick);\n      series.removeEventListener(\"nodeDoubleClick\", this.onSeriesNodeDoubleClick);\n      series.removeEventListener(\"groupingChanged\", this.seriesGroupingChanged);\n      series.destroy();\n      this.seriesLayerManager.releaseGroup(series);\n      series.chart = void 0;\n    });\n  }\n  addSeriesListeners(series) {\n    if (this.hasEventListener(\"seriesNodeClick\")) {\n      series.addEventListener(\"nodeClick\", this.onSeriesNodeClick);\n    }\n    if (this.hasEventListener(\"seriesNodeDoubleClick\")) {\n      series.addEventListener(\"nodeDoubleClick\", this.onSeriesNodeDoubleClick);\n    }\n    series.addEventListener(\"groupingChanged\", this.seriesGroupingChanged);\n  }\n  assignSeriesToAxes() {\n    for (const axis of this.axes) {\n      axis.boundSeries = this.series.filter((s) => s.axes[axis.direction] === axis);\n    }\n  }\n  assignAxesToSeries() {\n    const directionToAxesMap = groupBy(this.axes, (axis) => axis.direction);\n    this.series.forEach((series) => {\n      series.directions.forEach((direction) => {\n        const directionAxes = directionToAxesMap[direction];\n        if (!directionAxes) {\n          Logger.warnOnce(\n            `no available axis for direction [${direction}]; check series and axes configuration.`\n          );\n          return;\n        }\n        const seriesKeys = series.getKeys(direction);\n        const newAxis = directionAxes.find(\n          (axis) => !axis.keys.length || seriesKeys.some((key) => axis.keys.includes(key))\n        );\n        if (!newAxis) {\n          Logger.warnOnce(\n            `no matching axis for direction [${direction}] and keys [${seriesKeys}]; check series and axes configuration.`\n          );\n          return;\n        }\n        series.axes[direction] = newAxis;\n      });\n    });\n  }\n  parentResize(size) {\n    if (size == null || this.width != null && this.height != null)\n      return;\n    let { width: width2, height: height2 } = size;\n    width2 = Math.floor(width2);\n    height2 = Math.floor(height2);\n    if (width2 === 0 && height2 === 0)\n      return;\n    const [autoWidth = 0, authHeight = 0] = this._lastAutoSize ?? [];\n    if (autoWidth === width2 && authHeight === height2)\n      return;\n    this._lastAutoSize = [width2, height2];\n    this.resize(\"SizeMonitor\", {});\n  }\n  resize(source, opts) {\n    const { scene, animationManager } = this.ctx;\n    const { inWidth, inHeight, inMinWidth, inMinHeight } = opts;\n    this.ctx.domManager.setSizeOptions(\n      inMinWidth ?? this.minWidth,\n      inMinHeight ?? this.minHeight,\n      inWidth ?? this.width,\n      inHeight ?? this.height\n    );\n    const width2 = inWidth ?? this.width ?? this._lastAutoSize?.[0];\n    const height2 = inHeight ?? this.height ?? this._lastAutoSize?.[1];\n    this.debug(`Chart.resize() from ${source}`, { width: width2, height: height2, stack: new Error().stack });\n    if (width2 == null || height2 == null || !isFiniteNumber(width2) || !isFiniteNumber(height2))\n      return;\n    if (scene.resize(width2, height2)) {\n      animationManager.reset();\n      let skipAnimations = true;\n      if ((this.width == null || this.height == null) && this._firstAutoSize) {\n        skipAnimations = false;\n        this._firstAutoSize = false;\n      }\n      this.update(3 /* PERFORM_LAYOUT */, { forceNodeDataRefresh: true, skipAnimations });\n    }\n  }\n  async updateData() {\n    this.series.forEach((s) => s.setChartData(this.data));\n    const modulePromises = this.modulesManager.mapModules((m) => m.updateData?.(this.data));\n    await Promise.all(modulePromises);\n  }\n  async processData() {\n    if (this.series.some((s) => s.canHaveAxes)) {\n      this.assignAxesToSeries();\n      this.assignSeriesToAxes();\n    }\n    const dataController = new DataController(this.mode);\n    const seriesPromises = this.series.map((s) => s.processData(dataController));\n    const modulePromises = this.modulesManager.mapModules((m) => m.processData?.(dataController));\n    dataController.execute();\n    await Promise.all([...seriesPromises, ...modulePromises]);\n    for (const { legendType, legend } of this.modulesManager.legends()) {\n      legend.data = this.getLegendData(legendType, this.mode !== \"integrated\");\n    }\n  }\n  placeLabels(padding) {\n    const visibleSeries = [];\n    const data = [];\n    for (const series of this.series) {\n      if (!series.visible)\n        continue;\n      const labelData = series.getLabelData();\n      if (isPointLabelDatum(labelData?.[0])) {\n        data.push(labelData);\n        visibleSeries.push(series);\n      }\n    }\n    const { seriesRect } = this;\n    const { top, right, bottom, left } = this.seriesArea.padding;\n    const labels = seriesRect && data.length > 0 ? placeLabels(\n      data,\n      {\n        x: -left,\n        y: -top,\n        width: seriesRect.width + left + right,\n        height: seriesRect.height + top + bottom\n      },\n      padding\n    ) : [];\n    return new Map(labels.map((l, i) => [visibleSeries[i], l]));\n  }\n  getLegendData(legendType, warnConflicts) {\n    var _a;\n    const legendData = this.series.filter((s) => s.properties.showInLegend).flatMap((s) => s.getLegendData(legendType));\n    const isCategoryLegendData = (data) => data.every((d) => d.legendType === \"category\");\n    if (warnConflicts && isCategoryLegendData(legendData)) {\n      const seriesMarkerFills = {};\n      const seriesTypeMap = new Map(this.series.map((s) => [s.id, s.type]));\n      for (const {\n        seriesId,\n        symbols: [{ marker }],\n        label\n      } of legendData) {\n        if (marker.fill == null)\n          continue;\n        const seriesType2 = seriesTypeMap.get(seriesId);\n        const markerFill = seriesMarkerFills[seriesType2] ?? (seriesMarkerFills[seriesType2] = {});\n        markerFill[_a = label.text] ?? (markerFill[_a] = marker.fill);\n        if (markerFill[label.text] !== marker.fill) {\n          Logger.warnOnce(\n            `legend item '${label.text}' has multiple fill colors, this may cause unexpected behaviour.`\n          );\n        }\n      }\n    }\n    return legendData;\n  }\n  async processLayout() {\n    const oldRect = this.animationRect;\n    const { width: width2, height: height2 } = this.ctx.scene;\n    const ctx = this.ctx.layoutManager.createContext(width2, height2);\n    await this.performLayout(ctx);\n    if (oldRect && !this.animationRect?.equals(oldRect)) {\n      this.ctx.animationManager.skipCurrentBatch();\n    }\n    this.debug(\"Chart.performUpdate() - seriesRect\", this.seriesRect);\n  }\n  async waitForUpdate(timeoutMs = 1e4, failOnTimeout = false) {\n    const start2 = performance.now();\n    if (this._pendingFactoryUpdatesCount > 0) {\n      await this.updateMutex.waitForClearAcquireQueue();\n    }\n    while (this.performUpdateType !== 7 /* NONE */) {\n      if (performance.now() - start2 > timeoutMs) {\n        const message = `Chart.waitForUpdate() timeout of ${timeoutMs} reached - first chart update taking too long.`;\n        if (failOnTimeout) {\n          throw new Error(message);\n        } else {\n          Logger.warnOnce(message);\n        }\n      }\n      await sleep(50);\n    }\n    await this.updateMutex.waitForClearAcquireQueue();\n  }\n  getMinRects() {\n    const { width: width2, height: height2 } = this.ctx.scene;\n    const minRects = this.series.map((series) => series.getMinRects(width2, height2)).filter(isDefined);\n    if (minRects.length === 0)\n      return;\n    let maxWidth = 0;\n    let maxHeight = 0;\n    let maxVisibleWidth = 0;\n    let maxVisibleHeight = 0;\n    for (const { minRect: minRect2, minVisibleRect: minVisibleRect2 } of minRects) {\n      maxWidth = Math.max(maxWidth, minRect2.width);\n      maxHeight = Math.max(maxHeight, minRect2.height);\n      maxVisibleWidth = Math.max(maxVisibleWidth, minVisibleRect2.width);\n      maxVisibleHeight = Math.max(maxVisibleHeight, minVisibleRect2.height);\n    }\n    const minRect = new BBox(0, 0, maxWidth, maxHeight);\n    let minVisibleRect = minRect.clone();\n    if (maxVisibleWidth > 0 && maxVisibleHeight > 0) {\n      minVisibleRect = new BBox(0, 0, maxVisibleWidth, maxVisibleHeight);\n    }\n    return { minRect, minVisibleRect };\n  }\n  filterMiniChartSeries(series) {\n    return series?.filter((s) => s.showInMiniChart !== false);\n  }\n  applyOptions(newChartOptions) {\n    const isDifferentOpts = newChartOptions !== this.chartOptions;\n    const oldOpts = isDifferentOpts ? this.chartOptions.processedOptions : {};\n    const newOpts = newChartOptions.processedOptions;\n    const deltaOptions = newChartOptions.diffOptions(oldOpts);\n    if (deltaOptions == null)\n      return;\n    debug(\"Chart.applyOptions() - applying delta\", deltaOptions);\n    const modulesChanged = this.applyModules(newOpts);\n    const skip = [\n      \"type\",\n      \"data\",\n      \"series\",\n      \"listeners\",\n      \"preset\",\n      \"theme\",\n      \"legend.listeners\",\n      \"navigator.miniChart.series\",\n      \"navigator.miniChart.label\",\n      \"locale.localeText\",\n      \"axes\",\n      \"topology\",\n      \"nodes\",\n      \"initialState\",\n      \"styleContainer\"\n    ];\n    if (deltaOptions.listeners) {\n      this.registerListeners(this, deltaOptions.listeners);\n    }\n    jsonApply(this, deltaOptions, { skip });\n    let forceNodeDataRefresh = false;\n    let seriesStatus = \"no-op\";\n    if (deltaOptions.series != null) {\n      seriesStatus = this.applySeries(this, deltaOptions.series, oldOpts?.series);\n      forceNodeDataRefresh = true;\n    }\n    if (seriesStatus === \"replaced\") {\n      this.resetAnimations();\n    }\n    if (this.applyAxes(this, newOpts, oldOpts, seriesStatus, [], true)) {\n      forceNodeDataRefresh = true;\n    }\n    if (deltaOptions.data) {\n      this.data = deltaOptions.data;\n    }\n    if (deltaOptions.legend?.listeners && this.modulesManager.isEnabled(\"legend\")) {\n      Object.assign(this.legend.listeners, deltaOptions.legend.listeners);\n    }\n    if (deltaOptions.locale?.localeText) {\n      this.modulesManager.getModule(\"locale\").localeText = deltaOptions.locale?.localeText;\n    }\n    this.chartOptions = newChartOptions;\n    const navigatorModule = this.modulesManager.getModule(\"navigator\");\n    const zoomModule = this.modulesManager.getModule(\"zoom\");\n    if (!navigatorModule?.enabled && !zoomModule?.enabled) {\n      this.ctx.zoomManager.updateZoom(\"chart\");\n    }\n    const miniChart = navigatorModule?.miniChart;\n    const miniChartSeries = newOpts.navigator?.miniChart?.series ?? newOpts.series;\n    if (miniChart?.enabled === true && miniChartSeries != null) {\n      this.applyMiniChartOptions(miniChart, miniChartSeries, newOpts, oldOpts);\n    } else if (miniChart?.enabled === false) {\n      miniChart.series = [];\n      miniChart.axes = [];\n    }\n    this.ctx.annotationManager.setAnnotationStyles(newChartOptions.annotationThemes);\n    forceNodeDataRefresh || (forceNodeDataRefresh = this.shouldForceNodeDataRefresh(deltaOptions, seriesStatus));\n    const majorChange = forceNodeDataRefresh || modulesChanged;\n    const updateType = majorChange ? 0 /* FULL */ : 3 /* PERFORM_LAYOUT */;\n    this.maybeResetAnimations(seriesStatus);\n    debug(\"Chart.applyOptions() - update type\", ChartUpdateType[updateType], {\n      seriesStatus,\n      forceNodeDataRefresh\n    });\n    this.update(updateType, { forceNodeDataRefresh, newAnimationBatch: true });\n    if (deltaOptions.initialState || deltaOptions.theme) {\n      this.applyInitialState(newChartOptions.userOptions.initialState);\n    }\n  }\n  applyInitialState(initialState) {\n    const {\n      ctx: { annotationManager, historyManager, stateManager }\n    } = this;\n    if (initialState?.annotations != null) {\n      const annotations2 = initialState.annotations.map((annotation) => {\n        const annotationTheme = annotationManager.getAnnotationTypeStyles(annotation.type);\n        return mergeDefaults(annotation, annotationTheme);\n      });\n      stateManager.setState(annotationManager, annotations2);\n    }\n    if (initialState != null) {\n      historyManager.clear();\n    }\n  }\n  maybeResetAnimations(seriesStatus) {\n    if (this.mode !== \"standalone\")\n      return;\n    switch (seriesStatus) {\n      case \"series-grouping-change\":\n      case \"replaced\":\n        this.resetAnimations();\n        break;\n      default:\n    }\n  }\n  shouldForceNodeDataRefresh(deltaOptions, seriesStatus) {\n    const seriesDataUpdate = !!deltaOptions.data || seriesStatus === \"data-change\" || seriesStatus === \"replaced\";\n    const legendKeys = legendRegistry.getKeys();\n    const optionsHaveLegend = Object.values(legendKeys).some(\n      (legendKey) => deltaOptions[legendKey] != null\n    );\n    const otherRefreshUpdate = deltaOptions.title != null && deltaOptions.subtitle != null;\n    return seriesDataUpdate || optionsHaveLegend || otherRefreshUpdate;\n  }\n  applyMiniChartOptions(miniChart, miniChartSeries, completeOptions, oldOpts) {\n    const oldSeries = oldOpts?.navigator?.miniChart?.series ?? oldOpts?.series;\n    const miniChartSeriesStatus = this.applySeries(\n      miniChart,\n      this.filterMiniChartSeries(miniChartSeries),\n      this.filterMiniChartSeries(oldSeries)\n    );\n    this.applyAxes(miniChart, completeOptions, oldOpts, miniChartSeriesStatus, [\n      \"axes[].tick\",\n      \"axes[].thickness\",\n      \"axes[].title\",\n      \"axes[].crosshair\",\n      \"axes[].gridLine\",\n      \"axes[].label\"\n    ]);\n    const series = miniChart.series;\n    for (const s of series) {\n      s.properties.id = void 0;\n    }\n    const axes = miniChart.axes;\n    const horizontalAxis = axes.find((axis) => axis.direction === \"x\" /* X */);\n    for (const axis of axes) {\n      axis.gridLine.enabled = false;\n      axis.label.enabled = axis === horizontalAxis;\n      axis.tick.enabled = false;\n      axis.interactionEnabled = false;\n    }\n    if (horizontalAxis != null) {\n      const miniChartOpts = completeOptions.navigator?.miniChart;\n      const labelOptions = miniChartOpts?.label;\n      const intervalOptions = miniChartOpts?.label?.interval;\n      horizontalAxis.line.enabled = false;\n      horizontalAxis.label.set(\n        without(labelOptions, [\"interval\", \"rotation\", \"minSpacing\", \"autoRotate\", \"autoRotateAngle\"])\n      );\n      horizontalAxis.tick.set(\n        without(intervalOptions, [\"enabled\", \"width\", \"size\", \"color\", \"interval\", \"step\"])\n      );\n      const step = intervalOptions?.step;\n      if (step != null) {\n        horizontalAxis.interval.step = step;\n      }\n    }\n  }\n  applyModules(options) {\n    const { type: chartType2 } = this.constructor;\n    let modulesChanged = false;\n    for (const module of moduleRegistry.byType(\"root\", \"legend\")) {\n      const isConfigured = options[module.optionsKey] != null;\n      const shouldBeEnabled = isConfigured && module.chartTypes.includes(chartType2);\n      if (shouldBeEnabled === this.modulesManager.isEnabled(module))\n        continue;\n      if (shouldBeEnabled) {\n        this.modulesManager.addModule(module, (m) => m.moduleFactory(this.getModuleContext()));\n        if (module.type === \"legend\") {\n          this.modulesManager.getModule(module)?.attachLegend(this.ctx.scene);\n        }\n        this[module.optionsKey] = this.modulesManager.getModule(module);\n      } else {\n        this.modulesManager.removeModule(module);\n        delete this[module.optionsKey];\n      }\n      modulesChanged = true;\n    }\n    return modulesChanged;\n  }\n  initSeriesDeclarationOrder(series) {\n    for (let idx = 0; idx < series.length; idx++) {\n      series[idx]._declarationOrder = idx;\n    }\n  }\n  applySeries(chart, optSeries, oldOptSeries) {\n    if (!optSeries) {\n      return \"no-change\";\n    }\n    const matchResult = matchSeriesOptions(chart.series, optSeries, oldOptSeries);\n    if (matchResult.status === \"no-overlap\") {\n      debug(`Chart.applySeries() - creating new series instances, status: ${matchResult.status}`, matchResult);\n      chart.series = optSeries.map((opts) => this.createSeries(opts));\n      this.initSeriesDeclarationOrder(chart.series);\n      return \"replaced\";\n    }\n    debug(`Chart.applySeries() - matchResult`, matchResult);\n    const seriesInstances = [];\n    let dataChanged = false;\n    let groupingChanged = false;\n    let isUpdated = false;\n    for (const change of matchResult.changes) {\n      groupingChanged || (groupingChanged = change.status === \"series-grouping\");\n      dataChanged || (dataChanged = change.diff?.data != null);\n      isUpdated || (isUpdated = change.status !== \"no-op\");\n      switch (change.status) {\n        case \"add\": {\n          const newSeries = this.createSeries(change.opts);\n          seriesInstances.push(newSeries);\n          debug(`Chart.applySeries() - created new series`, newSeries);\n          break;\n        }\n        case \"remove\":\n          debug(`Chart.applySeries() - removing series at previous idx ${change.idx}`, change.series);\n          break;\n        case \"no-op\":\n          seriesInstances.push(change.series);\n          debug(`Chart.applySeries() - no change to series at previous idx ${change.idx}`, change.series);\n          break;\n        case \"series-grouping\":\n        case \"update\":\n        default: {\n          const { series, diff: diff2, idx } = change;\n          debug(`Chart.applySeries() - applying series diff previous idx ${idx}`, diff2, series);\n          this.applySeriesValues(series, diff2);\n          series.markNodeDataDirty();\n          seriesInstances.push(series);\n        }\n      }\n    }\n    this.initSeriesDeclarationOrder(seriesInstances);\n    debug(`Chart.applySeries() - final series instances`, seriesInstances);\n    chart.series = seriesInstances;\n    if (groupingChanged) {\n      return \"series-grouping-change\";\n    }\n    if (dataChanged) {\n      return \"data-change\";\n    }\n    return isUpdated ? \"updated\" : \"no-op\";\n  }\n  applyAxes(chart, options, oldOpts, seriesStatus, skip = [], registerRegions = false) {\n    if (!(\"axes\" in options) || !options.axes) {\n      return false;\n    }\n    skip = [\"axes[].type\", ...skip];\n    const { axes } = options;\n    const forceRecreate = seriesStatus === \"replaced\";\n    const matchingTypes = !forceRecreate && chart.axes.length === axes.length && chart.axes.every((a, i) => a.type === axes[i].type);\n    if (matchingTypes && isAgCartesianChartOptions(oldOpts)) {\n      chart.axes.forEach((axis, index) => {\n        const previousOpts = oldOpts.axes?.[index] ?? {};\n        const axisDiff = jsonDiff(previousOpts, axes[index]);\n        debug(`Chart.applyAxes() - applying axis diff idx ${index}`, axisDiff);\n        const path = `axes[${index}]`;\n        jsonApply(axis, axisDiff, { path, skip });\n      });\n      return true;\n    }\n    debug(`Chart.applyAxes() - creating new axes instances; seriesStatus: ${seriesStatus}`);\n    chart.axes = this.createAxis(axes, skip);\n    const axisGroups = {\n      [\"x\" /* X */]: [],\n      [\"y\" /* Y */]: []\n    };\n    chart.axes.forEach((axis) => {\n      const { id } = axis;\n      const node = axis.getRegionNode();\n      if (node != null) {\n        axisGroups[axis.direction].push({ id, node });\n      }\n    });\n    if (registerRegions) {\n      this.ctx.regionManager.updateRegion(\"horizontal-axes\" /* HORIZONTAL_AXES */, ...axisGroups[\"x\" /* X */]);\n      this.ctx.regionManager.updateRegion(\"vertical-axes\" /* VERTICAL_AXES */, ...axisGroups[\"y\" /* Y */]);\n    }\n    return true;\n  }\n  createSeries(seriesOptions) {\n    const seriesInstance = seriesRegistry.create(seriesOptions.type, this.getModuleContext());\n    this.applySeriesOptionModules(seriesInstance, seriesOptions);\n    this.applySeriesValues(seriesInstance, seriesOptions);\n    return seriesInstance;\n  }\n  applySeriesOptionModules(series, options) {\n    const moduleContext = series.createModuleContext();\n    const moduleMap = series.getModuleMap();\n    for (const module of moduleRegistry.byType(\"series-option\")) {\n      if (module.optionsKey in options && module.seriesTypes.includes(series.type)) {\n        moduleMap.addModule(module, (m) => m.moduleFactory(moduleContext));\n      }\n    }\n  }\n  applySeriesValues(target, options) {\n    const moduleMap = target.getModuleMap();\n    const { type: _, data, listeners, seriesGrouping, showInMiniChart: __, ...seriesOptions } = options;\n    for (const moduleDef of EXPECTED_ENTERPRISE_MODULES) {\n      if (moduleDef.type !== \"series-option\")\n        continue;\n      if (moduleDef.optionsKey in seriesOptions) {\n        const module = moduleMap.getModule(moduleDef.optionsKey);\n        if (module) {\n          const moduleOptions = seriesOptions[moduleDef.optionsKey];\n          delete seriesOptions[moduleDef.optionsKey];\n          module.properties.set(moduleOptions);\n        }\n      }\n    }\n    target.properties.set(seriesOptions);\n    if (\"data\" in options) {\n      target.setOptionsData(data);\n    }\n    if (listeners) {\n      this.registerListeners(target, listeners);\n    }\n    if (\"seriesGrouping\" in options) {\n      if (seriesGrouping == null) {\n        target.seriesGrouping = void 0;\n      } else {\n        target.seriesGrouping = { ...target.seriesGrouping, ...seriesGrouping };\n      }\n    }\n  }\n  createAxis(options, skip) {\n    const newAxes = [];\n    const moduleContext = this.getModuleContext();\n    for (let index = 0; index < options.length; index++) {\n      const axisOptions = options[index];\n      const axis = axisRegistry.create(axisOptions.type, moduleContext);\n      this.applyAxisModules(axis, axisOptions);\n      jsonApply(axis, axisOptions, { path: `axes[${index}]`, skip });\n      newAxes.push(axis);\n    }\n    guessInvalidPositions(newAxes);\n    return newAxes;\n  }\n  applyAxisModules(axis, options) {\n    const moduleContext = axis.createModuleContext();\n    const moduleMap = axis.getModuleMap();\n    for (const module of moduleRegistry.byType(\"axis-option\")) {\n      const shouldBeEnabled = options[module.optionsKey] != null;\n      if (shouldBeEnabled === moduleMap.isEnabled(module))\n        continue;\n      if (shouldBeEnabled) {\n        moduleMap.addModule(module, (m) => m.moduleFactory(moduleContext));\n        axis[module.optionsKey] = moduleMap.getModule(module);\n      } else {\n        moduleMap.removeModule(module);\n        delete axis[module.optionsKey];\n      }\n    }\n  }\n  registerListeners(source, listeners) {\n    source.clearEventListeners();\n    for (const [property, listener] of Object.entries(listeners)) {\n      if (isFunction(listener)) {\n        source.addEventListener(property, listener);\n      }\n    }\n  }\n};\n_Chart.chartsInstances = /* @__PURE__ */ new WeakMap();\n__decorateClass([\n  ActionOnSet({\n    newValue(value) {\n      if (this.destroyed)\n        return;\n      this.ctx.domManager.setContainer(value);\n      _Chart.chartsInstances.set(value, this);\n    },\n    oldValue(value) {\n      _Chart.chartsInstances.delete(value);\n    }\n  })\n], _Chart.prototype, \"container\", 2);\n__decorateClass([\n  ActionOnSet({\n    newValue(value) {\n      this.resize(\"width option\", { inWidth: value });\n    }\n  })\n], _Chart.prototype, \"width\", 2);\n__decorateClass([\n  ActionOnSet({\n    newValue(value) {\n      this.resize(\"height option\", { inHeight: value });\n    }\n  })\n], _Chart.prototype, \"height\", 2);\n__decorateClass([\n  ActionOnSet({\n    newValue(value) {\n      this.resize(\"minWidth option\", { inMinWidth: value });\n    }\n  })\n], _Chart.prototype, \"minWidth\", 2);\n__decorateClass([\n  ActionOnSet({\n    newValue(value) {\n      this.resize(\"minHeight option\", { inMinHeight: value });\n    }\n  })\n], _Chart.prototype, \"minHeight\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], _Chart.prototype, \"padding\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], _Chart.prototype, \"seriesArea\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], _Chart.prototype, \"keyboard\", 2);\n__decorateClass([\n  Validate(UNION([\"standalone\", \"integrated\"], \"a chart mode\"))\n], _Chart.prototype, \"mode\", 2);\n__decorateClass([\n  ProxyProperty(\"chartCaptions.title\")\n], _Chart.prototype, \"title\", 2);\n__decorateClass([\n  ProxyProperty(\"chartCaptions.subtitle\")\n], _Chart.prototype, \"subtitle\", 2);\n__decorateClass([\n  ProxyProperty(\"chartCaptions.footnote\")\n], _Chart.prototype, \"footnote\", 2);\n__decorateClass([\n  ActionOnSet({\n    changeValue(newValue, oldValue) {\n      this.onAxisChange(newValue, oldValue);\n    }\n  })\n], _Chart.prototype, \"axes\", 2);\n__decorateClass([\n  ActionOnSet({\n    changeValue(newValue, oldValue) {\n      this.onSeriesChange(newValue, oldValue);\n    }\n  })\n], _Chart.prototype, \"series\", 2);\nvar Chart = _Chart;\n\n// packages/ag-charts-community/src/scene/util/quadtree.ts\nvar QuadtreeNearest = class {\n  constructor(capacity, maxdepth, boundary) {\n    this.root = new QuadtreeNodeNearest(capacity, maxdepth, boundary);\n  }\n  clear(boundary) {\n    this.root.clear(boundary);\n  }\n  addValue(hitTester, value) {\n    const elem = {\n      hitTester,\n      value,\n      distanceSquared: (x, y) => {\n        return hitTester.distanceSquared(x, y);\n      }\n    };\n    this.root.addElem(elem);\n  }\n  find(x, y) {\n    const arg = { best: { nearest: void 0, distanceSquared: Infinity } };\n    this.root.find(x, y, arg);\n    return arg.best;\n  }\n};\nvar QuadtreeSubdivisions = class {\n  constructor(nw, ne, sw, se) {\n    this.nw = nw;\n    this.ne = ne;\n    this.sw = sw;\n    this.se = se;\n  }\n  addElem(elem) {\n    this.nw.addElem(elem);\n    this.ne.addElem(elem);\n    this.sw.addElem(elem);\n    this.se.addElem(elem);\n  }\n  find(x, y, arg) {\n    this.nw.find(x, y, arg);\n    this.ne.find(x, y, arg);\n    this.sw.find(x, y, arg);\n    this.se.find(x, y, arg);\n  }\n};\nvar QuadtreeNode = class {\n  constructor(capacity, maxdepth, boundary) {\n    this.capacity = capacity;\n    this.maxdepth = maxdepth;\n    this.boundary = boundary ?? BBox.NaN;\n    this.elems = [];\n    this.subdivisions = void 0;\n  }\n  clear(boundary) {\n    this.elems.length = 0;\n    this.boundary = boundary;\n    this.subdivisions = void 0;\n  }\n  addElem(e) {\n    if (this.addCondition(e)) {\n      if (this.subdivisions === void 0) {\n        if (this.maxdepth === 0 || this.elems.length < this.capacity) {\n          this.elems.push(e);\n        } else {\n          this.subdivide(e);\n        }\n      } else {\n        this.subdivisions.addElem(e);\n      }\n    }\n  }\n  find(x, y, arg) {\n    if (this.findCondition(x, y, arg)) {\n      if (this.subdivisions === void 0) {\n        this.findAction(x, y, arg);\n      } else {\n        this.subdivisions.find(x, y, arg);\n      }\n    }\n  }\n  subdivide(newElem) {\n    this.subdivisions = this.makeSubdivisions();\n    for (const e of this.elems) {\n      this.subdivisions.addElem(e);\n    }\n    this.subdivisions.addElem(newElem);\n    this.elems.length = 0;\n  }\n  makeSubdivisions() {\n    const { x, y, width: width2, height: height2 } = this.boundary;\n    const { capacity } = this;\n    const depth = this.maxdepth - 1;\n    const halfWidth = width2 / 2;\n    const halfHeight = height2 / 2;\n    const nwBoundary = new BBox(x, y, halfWidth, halfHeight);\n    const neBoundary = new BBox(x + halfWidth, y, halfWidth, halfHeight);\n    const swBoundary = new BBox(x, y + halfHeight, halfWidth, halfHeight);\n    const seBoundary = new BBox(x + halfWidth, y + halfHeight, halfWidth, halfHeight);\n    return new QuadtreeSubdivisions(\n      this.child(capacity, depth, nwBoundary),\n      this.child(capacity, depth, neBoundary),\n      this.child(capacity, depth, swBoundary),\n      this.child(capacity, depth, seBoundary)\n    );\n  }\n};\nvar QuadtreeNodeNearest = class _QuadtreeNodeNearest extends QuadtreeNode {\n  addCondition(e) {\n    const { x, y } = e.hitTester.midPoint;\n    return this.boundary.containsPoint(x, y);\n  }\n  findCondition(x, y, arg) {\n    const { best } = arg;\n    return best.distanceSquared !== 0 && this.boundary.distanceSquared(x, y) < best.distanceSquared;\n  }\n  findAction(x, y, arg) {\n    const other = nearestSquared(x, y, this.elems, arg.best.distanceSquared);\n    if (other.nearest !== void 0 && other.distanceSquared < arg.best.distanceSquared) {\n      arg.best = other;\n    }\n  }\n  child(capacity, depth, boundary) {\n    return new _QuadtreeNodeNearest(capacity, depth, boundary);\n  }\n};\n\n// packages/ag-charts-community/src/chart/marker/marker.ts\nvar BUILTIN_MARKERS = [\n  \"ArrowDown\",\n  \"ArrowUp\",\n  \"Circle\",\n  \"Cross\",\n  \"Diamond\",\n  \"Heart\",\n  \"MapPin\",\n  \"Plus\",\n  \"Square\",\n  \"Star\",\n  \"Triangle\"\n];\nvar DEFAULT_CENTER_POINT = Object.freeze({ x: 0.5, y: 0.5 });\nvar InternalMarker = class extends Path {\n  constructor() {\n    super(...arguments);\n    this.x = 0;\n    this.y = 0;\n    this.size = 12;\n  }\n  isBuiltIn() {\n    return BUILTIN_MARKERS.includes(this.constructor.className ?? \"\");\n  }\n  computeBBox() {\n    if (!this.isBuiltIn()) {\n      return this.path.computeBBox();\n    }\n    const { x, y, size } = this;\n    const { center: center2 } = this.constructor;\n    return new BBox(x - size * center2.x, y - size * center2.y, size, size);\n  }\n  applyPath(s, moves) {\n    const { path } = this;\n    let { x, y } = this;\n    path.clear();\n    for (const { x: mx, y: my, t } of moves) {\n      x += mx * s;\n      y += my * s;\n      if (t === \"move\") {\n        path.moveTo(x, y);\n      } else {\n        path.lineTo(x, y);\n      }\n    }\n    path.closePath();\n  }\n  executeFill(ctx, path) {\n    if (!path)\n      return;\n    return super.executeFill(ctx, path);\n  }\n  executeStroke(ctx, path) {\n    if (!path)\n      return;\n    return super.executeStroke(ctx, path);\n  }\n};\n__decorateClass([\n  ScenePathChangeDetection()\n], InternalMarker.prototype, \"x\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], InternalMarker.prototype, \"y\", 2);\n__decorateClass([\n  ScenePathChangeDetection({ convertor: Math.abs })\n], InternalMarker.prototype, \"size\", 2);\nvar Marker = class extends Rotatable(Scalable(Translatable(InternalMarker))) {\n};\nMarker.center = DEFAULT_CENTER_POINT;\n\n// packages/ag-charts-community/src/chart/marker/circle.ts\nvar Circle = class extends Marker {\n  updatePath() {\n    const { x, y, path, size } = this;\n    const r = size / 2;\n    path.clear();\n    path.arc(x, y, r, 0, Math.PI * 2);\n    path.closePath();\n  }\n};\nCircle.className = \"Circle\";\n\n// packages/ag-charts-community/src/chart/marker/cross.ts\nvar _Cross = class _Cross extends Marker {\n  updatePath() {\n    const s = this.size / 4.2;\n    super.applyPath(s, _Cross.moves);\n  }\n};\n_Cross.className = \"Cross\";\n_Cross.moves = [\n  { x: -1, y: 0, t: \"move\" },\n  { x: -1, y: -1 },\n  { x: 1, y: -1 },\n  { x: 1, y: 1 },\n  { x: 1, y: -1 },\n  { x: 1, y: 1 },\n  { x: -1, y: 1 },\n  { x: 1, y: 1 },\n  { x: -1, y: 1 },\n  { x: -1, y: -1 },\n  { x: -1, y: 1 },\n  { x: -1, y: -1 }\n];\nvar Cross = _Cross;\n\n// packages/ag-charts-community/src/chart/marker/diamond.ts\nvar _Diamond = class _Diamond extends Marker {\n  updatePath() {\n    const s = this.size / 2;\n    super.applyPath(s, _Diamond.moves);\n  }\n};\n_Diamond.className = \"Diamond\";\n_Diamond.moves = [\n  { x: 0, y: -1, t: \"move\" },\n  { x: 1, y: 1 },\n  { x: -1, y: 1 },\n  { x: -1, y: -1 },\n  { x: 1, y: -1 }\n];\nvar Diamond = _Diamond;\n\n// packages/ag-charts-community/src/chart/marker/heart.ts\nvar Heart = class extends Marker {\n  rad(degree2) {\n    return degree2 / 180 * Math.PI;\n  }\n  updatePath() {\n    const { x, path, size, rad } = this;\n    const r = size / 4;\n    const y = this.y + r / 2;\n    path.clear();\n    path.arc(x - r, y - r, r, rad(130), rad(330));\n    path.arc(x + r, y - r, r, rad(220), rad(50));\n    path.lineTo(x, y + r);\n    path.closePath();\n  }\n};\nHeart.className = \"Heart\";\n\n// packages/ag-charts-community/src/chart/marker/pin.ts\nvar Pin = class extends Marker {\n  updatePath() {\n    const { path, x, y } = this;\n    const s = this.size;\n    const cx = 0.5;\n    const cy = 1;\n    path.clear();\n    path.moveTo(x + (0.15625 - cx) * s, y + (0.34375 - cy) * s);\n    path.cubicCurveTo(\n      x + (0.15625 - cx) * s,\n      y + (0.151491 - cy) * s,\n      x + (0.307741 - cx) * s,\n      y + (0 - cy) * s,\n      x + (0.5 - cx) * s,\n      y + (0 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.692259 - cx) * s,\n      y + (0 - cy) * s,\n      x + (0.84375 - cx) * s,\n      y + (0.151491 - cy) * s,\n      x + (0.84375 - cx) * s,\n      y + (0.34375 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.84375 - cx) * s,\n      y + (0.493824 - cy) * s,\n      x + (0.784625 - cx) * s,\n      y + (0.600181 - cy) * s,\n      x + (0.716461 - cx) * s,\n      y + (0.695393 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.699009 - cx) * s,\n      y + (0.719769 - cy) * s,\n      x + (0.681271 - cx) * s,\n      y + (0.743104 - cy) * s,\n      x + (0.663785 - cx) * s,\n      y + (0.766105 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.611893 - cx) * s,\n      y + (0.834367 - cy) * s,\n      x + (0.562228 - cx) * s,\n      y + (0.899699 - cy) * s,\n      x + (0.528896 - cx) * s,\n      y + (0.980648 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.524075 - cx) * s,\n      y + (0.992358 - cy) * s,\n      x + (0.512663 - cx) * s,\n      y + (1 - cy) * s,\n      x + (0.5 - cx) * s,\n      y + (1 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.487337 - cx) * s,\n      y + (1 - cy) * s,\n      x + (0.475925 - cx) * s,\n      y + (0.992358 - cy) * s,\n      x + (0.471104 - cx) * s,\n      y + (0.980648 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.487337 - cx) * s,\n      y + (1 - cy) * s,\n      x + (0.475925 - cx) * s,\n      y + (0.992358 - cy) * s,\n      x + (0.471104 - cx) * s,\n      y + (0.980648 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.437772 - cx) * s,\n      y + (0.899699 - cy) * s,\n      x + (0.388107 - cx) * s,\n      y + (0.834367 - cy) * s,\n      x + (0.336215 - cx) * s,\n      y + (0.766105 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.318729 - cx) * s,\n      y + (0.743104 - cy) * s,\n      x + (0.300991 - cx) * s,\n      y + (0.719769 - cy) * s,\n      x + (0.283539 - cx) * s,\n      y + (0.695393 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.215375 - cx) * s,\n      y + (0.600181 - cy) * s,\n      x + (0.15625 - cx) * s,\n      y + (0.493824 - cy) * s,\n      x + (0.15625 - cx) * s,\n      y + (0.34375 - cy) * s\n    );\n    path.closePath();\n  }\n};\nPin.className = \"MapPin\";\nPin.center = { x: 0.5, y: 1 };\n\n// packages/ag-charts-community/src/chart/marker/plus.ts\nvar _Plus = class _Plus extends Marker {\n  updatePath() {\n    const s = this.size / 3;\n    super.applyPath(s, _Plus.moves);\n  }\n};\n_Plus.className = \"Plus\";\n_Plus.moves = [\n  { x: -0.5, y: -0.5, t: \"move\" },\n  { x: 0, y: -1 },\n  { x: 1, y: 0 },\n  { x: 0, y: 1 },\n  { x: 1, y: 0 },\n  { x: 0, y: 1 },\n  { x: -1, y: 0 },\n  { x: 0, y: 1 },\n  { x: -1, y: 0 },\n  { x: 0, y: -1 },\n  { x: -1, y: 0 },\n  { x: 0, y: -1 }\n];\nvar Plus = _Plus;\n\n// packages/ag-charts-community/src/chart/marker/square.ts\nvar Square = class extends Marker {\n  updatePath() {\n    const { path, x, y } = this;\n    const hs = this.size / 2;\n    path.clear();\n    path.moveTo(this.align(x - hs), this.align(y - hs));\n    path.lineTo(this.align(x + hs), this.align(y - hs));\n    path.lineTo(this.align(x + hs), this.align(y + hs));\n    path.lineTo(this.align(x - hs), this.align(y + hs));\n    path.closePath();\n  }\n};\nSquare.className = \"Square\";\n\n// packages/ag-charts-community/src/chart/marker/star.ts\nvar Star = class extends Marker {\n  updatePath() {\n    const { x, y, path, size } = this;\n    const spikes = 5;\n    const innerRadius = size / 2;\n    const rotation = Math.PI / 2;\n    path.clear();\n    for (let i = 0; i < spikes * 2; i++) {\n      const radius = i % 2 === 0 ? size : innerRadius;\n      const angle2 = i * Math.PI / spikes - rotation;\n      const xCoordinate = x + Math.cos(angle2) * radius;\n      const yCoordinate = y + Math.sin(angle2) * radius;\n      path.lineTo(xCoordinate, yCoordinate);\n    }\n    path.closePath();\n  }\n};\nStar.className = \"Star\";\n\n// packages/ag-charts-community/src/chart/marker/triangle.ts\nvar _Triangle = class _Triangle extends Marker {\n  updatePath() {\n    const s = this.size * 1.1;\n    super.applyPath(s, _Triangle.moves);\n  }\n};\n_Triangle.className = \"Triangle\";\n_Triangle.moves = [\n  { x: 0, y: -0.48, t: \"move\" },\n  { x: 0.5, y: 0.87 },\n  { x: -1, y: 0 }\n];\nvar Triangle = _Triangle;\n\n// packages/ag-charts-community/src/chart/marker/util.ts\nvar MARKER_SHAPES = {\n  circle: Circle,\n  cross: Cross,\n  diamond: Diamond,\n  heart: Heart,\n  pin: Pin,\n  plus: Plus,\n  square: Square,\n  star: Star,\n  triangle: Triangle\n};\nvar MARKER_SUPPORTED_SHAPES = Object.keys(MARKER_SHAPES);\nfunction isMarkerShape(shape) {\n  return typeof shape === \"string\" && MARKER_SUPPORTED_SHAPES.includes(shape);\n}\nfunction getMarker(shape = Square) {\n  if (isMarkerShape(shape)) {\n    return MARKER_SHAPES[shape];\n  }\n  if (typeof shape === \"function\") {\n    return shape;\n  }\n  return Square;\n}\n\n// packages/ag-charts-community/src/chart/series/dataModelSeries.ts\nvar DataModelSeries = class extends Series {\n  constructor() {\n    super(...arguments);\n    this.showFocusBox = true;\n  }\n  getScaleInformation({\n    xScale,\n    yScale\n  }) {\n    const isContinuousX = ContinuousScale.is(xScale);\n    const isContinuousY = ContinuousScale.is(yScale);\n    return { isContinuousX, isContinuousY, xScaleType: xScale?.type, yScaleType: yScale?.type };\n  }\n  getModulePropertyDefinitions() {\n    const xScale = this.axes[\"x\" /* X */]?.scale;\n    const yScale = this.axes[\"y\" /* Y */]?.scale;\n    return this.moduleMap.mapModules((mod2) => mod2.getPropertyDefinitions(this.getScaleInformation({ xScale, yScale }))).flat();\n  }\n  // Request data, but with message dispatching to series-options (modules).\n  async requestDataModel(dataController, data, opts) {\n    opts.props.push(...this.getModulePropertyDefinitions());\n    const { dataModel, processedData } = await dataController.request(this.id, data ?? [], opts);\n    this.dataModel = dataModel;\n    this.processedData = processedData;\n    this.dispatch(\"data-processed\", { dataModel, processedData });\n    return { dataModel, processedData };\n  }\n  isProcessedDataAnimatable() {\n    const validationResults = this.processedData?.reduced?.animationValidation;\n    if (!validationResults) {\n      return true;\n    }\n    const { orderedKeys, uniqueKeys } = validationResults;\n    return orderedKeys && uniqueKeys;\n  }\n  checkProcessedDataAnimatable() {\n    if (!this.isProcessedDataAnimatable()) {\n      this.ctx.animationManager.skipCurrentBatch();\n    }\n  }\n  pickFocus(opts) {\n    const nodeData = this.getNodeData();\n    if (nodeData === void 0 || nodeData.length === 0) {\n      return;\n    }\n    const datumIndex = this.computeFocusDatumIndex(opts, nodeData);\n    if (datumIndex === void 0) {\n      return;\n    }\n    const { showFocusBox } = this;\n    const datum = nodeData[datumIndex];\n    const derivedOpts = { ...opts, datumIndex };\n    const bounds = this.computeFocusBounds(derivedOpts);\n    if (bounds !== void 0) {\n      return { bounds, showFocusBox, datum, datumIndex };\n    }\n  }\n  computeFocusDatumIndex(opts, nodeData) {\n    const isDatumEnabled = (datumIndex2) => {\n      const { missing = false, enabled = true, focusable = true } = nodeData[datumIndex2];\n      return !missing && enabled && focusable;\n    };\n    const searchBackward = (datumIndex2) => {\n      while (datumIndex2 >= 0 && !isDatumEnabled(datumIndex2)) {\n        datumIndex2--;\n      }\n      return datumIndex2 === -1 ? void 0 : datumIndex2;\n    };\n    const searchForward = (datumIndex2) => {\n      while (datumIndex2 < nodeData.length && !isDatumEnabled(datumIndex2)) {\n        datumIndex2++;\n      }\n      return datumIndex2 === nodeData.length ? void 0 : datumIndex2;\n    };\n    let datumIndex;\n    const clampedIndex = clamp(0, opts.datumIndex, nodeData.length - 1);\n    if (opts.datumIndexDelta < 0) {\n      datumIndex = searchBackward(clampedIndex);\n    } else if (opts.datumIndexDelta > 0) {\n      datumIndex = searchForward(clampedIndex);\n    } else {\n      datumIndex = searchForward(clampedIndex) ?? searchBackward(clampedIndex);\n    }\n    if (datumIndex === void 0) {\n      if (opts.datumIndexDelta === 0) {\n        return;\n      } else {\n        return opts.datumIndex - opts.datumIndexDelta;\n      }\n    } else {\n      return datumIndex;\n    }\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/seriesProperties.ts\nvar SeriesItemHighlightStyle = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.fill = \"rgba(255,255,255, 0.33)\";\n    this.stroke = `rgba(0, 0, 0, 0.4)`;\n    this.strokeWidth = 2;\n  }\n};\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], SeriesItemHighlightStyle.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], SeriesItemHighlightStyle.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], SeriesItemHighlightStyle.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], SeriesItemHighlightStyle.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], SeriesItemHighlightStyle.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH, { optional: true })\n], SeriesItemHighlightStyle.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], SeriesItemHighlightStyle.prototype, \"lineDashOffset\", 2);\nvar SeriesHighlightStyle = class extends BaseProperties {\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], SeriesHighlightStyle.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], SeriesHighlightStyle.prototype, \"dimOpacity\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], SeriesHighlightStyle.prototype, \"enabled\", 2);\nvar TextHighlightStyle = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.color = \"black\";\n  }\n};\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], TextHighlightStyle.prototype, \"color\", 2);\nvar HighlightProperties = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], HighlightProperties.prototype, \"enabled\", 2);\nvar HighlightStyle = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.item = new SeriesItemHighlightStyle();\n    this.series = new SeriesHighlightStyle();\n    this.text = new TextHighlightStyle();\n  }\n};\n__decorateClass([\n  Validate(OBJECT)\n], HighlightStyle.prototype, \"item\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], HighlightStyle.prototype, \"series\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], HighlightStyle.prototype, \"text\", 2);\nvar SeriesProperties = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.visible = true;\n    this.focusPriority = Infinity;\n    this.showInLegend = true;\n    this.cursor = \"default\";\n    this.nodeClickRange = \"exact\";\n    this.highlight = new HighlightProperties();\n    this.highlightStyle = new HighlightStyle();\n  }\n};\n__decorateClass([\n  Validate(STRING, { optional: true })\n], SeriesProperties.prototype, \"id\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], SeriesProperties.prototype, \"visible\", 2);\n__decorateClass([\n  Validate(REAL_NUMBER, { optional: true })\n], SeriesProperties.prototype, \"focusPriority\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], SeriesProperties.prototype, \"showInLegend\", 2);\n__decorateClass([\n  Validate(STRING)\n], SeriesProperties.prototype, \"cursor\", 2);\n__decorateClass([\n  Validate(INTERACTION_RANGE)\n], SeriesProperties.prototype, \"nodeClickRange\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], SeriesProperties.prototype, \"highlight\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], SeriesProperties.prototype, \"highlightStyle\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/cartesianSeries.ts\nvar DEFAULT_CARTESIAN_DIRECTION_KEYS = {\n  [\"x\" /* X */]: [\"xKey\"],\n  [\"y\" /* Y */]: [\"yKey\"]\n};\nvar DEFAULT_CARTESIAN_DIRECTION_NAMES = {\n  [\"x\" /* X */]: [\"xName\"],\n  [\"y\" /* Y */]: [\"yName\"]\n};\nvar CartesianSeriesNodeEvent = class extends SeriesNodeEvent {\n  constructor(type, nativeEvent, datum, series) {\n    super(type, nativeEvent, datum, series);\n    this.xKey = series.properties.xKey;\n    this.yKey = series.properties.yKey;\n  }\n};\nvar CartesianSeriesProperties = class extends SeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.pickOutsideVisibleMinorAxis = false;\n  }\n};\n__decorateClass([\n  Validate(STRING, { optional: true })\n], CartesianSeriesProperties.prototype, \"legendItemName\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], CartesianSeriesProperties.prototype, \"pickOutsideVisibleMinorAxis\", 2);\nvar CartesianSeries = class extends DataModelSeries {\n  constructor({\n    pathsPerSeries = [\"path\"],\n    hasMarkers = false,\n    hasHighlightedLabels = false,\n    pathsZIndexSubOrderOffset = [],\n    datumSelectionGarbageCollection = true,\n    markerSelectionGarbageCollection = true,\n    animationAlwaysUpdateSelections = false,\n    animationResetFns,\n    directionKeys,\n    directionNames,\n    ...otherOpts\n  }) {\n    super({\n      directionKeys,\n      directionNames,\n      canHaveAxes: true,\n      ...otherOpts\n    });\n    this.NodeEvent = CartesianSeriesNodeEvent;\n    this.dataNodeGroup = this.contentGroup.appendChild(\n      new Group({\n        name: `${this.id}-series-dataNodes`,\n        zIndex: 4 /* SERIES_LAYER */,\n        zIndexSubOrder: this.getGroupZIndexSubOrder(\"data\")\n      })\n    );\n    this.markerGroup = this.contentGroup.appendChild(\n      new Group({\n        name: `${this.id}-series-markers`,\n        zIndex: 4 /* SERIES_LAYER */,\n        zIndexSubOrder: this.getGroupZIndexSubOrder(\"marker\")\n      })\n    );\n    this.labelGroup = this.contentGroup.appendChild(\n      new TranslatableGroup({\n        name: `${this.id}-series-labels`,\n        zIndex: 14 /* SERIES_LABEL */,\n        zIndexSubOrder: this.getGroupZIndexSubOrder(\"labels\")\n      })\n    );\n    this.labelSelection = Selection.select(this.labelGroup, Text);\n    this.highlightSelection = Selection.select(\n      this.highlightNode,\n      () => this.opts.hasMarkers ? this.markerFactory() : this.nodeFactory()\n    );\n    this.highlightLabelSelection = Selection.select(this.highlightLabel, Text);\n    this.annotationSelections = /* @__PURE__ */ new Set();\n    this.minRectsCache = {\n      dirtyNodeData: true\n    };\n    this.debug = Debug.create();\n    if (!directionKeys || !directionNames)\n      throw new Error(`Unable to initialise series type ${this.type}`);\n    this.opts = {\n      pathsPerSeries,\n      hasMarkers,\n      hasHighlightedLabels,\n      pathsZIndexSubOrderOffset,\n      directionKeys,\n      directionNames,\n      animationResetFns,\n      animationAlwaysUpdateSelections,\n      datumSelectionGarbageCollection,\n      markerSelectionGarbageCollection\n    };\n    this.paths = [];\n    for (let index = 0; index < pathsPerSeries.length; index++) {\n      this.paths[index] = new Path({ name: `${this.id}-${pathsPerSeries[index]}` });\n      this.paths[index].zIndex = 4 /* SERIES_LAYER */;\n      this.paths[index].zIndexSubOrder = this.getGroupZIndexSubOrder(\"paths\", index);\n      this.contentGroup.appendChild(this.paths[index]);\n    }\n    this.datumSelection = Selection.select(\n      this.dataNodeGroup,\n      () => this.nodeFactory(),\n      datumSelectionGarbageCollection\n    );\n    this.markerSelection = Selection.select(\n      this.markerGroup,\n      () => this.markerFactory(),\n      markerSelectionGarbageCollection\n    );\n    this.animationState = new StateMachine(\n      \"empty\",\n      {\n        empty: {\n          update: {\n            target: \"ready\",\n            action: (data) => this.animateEmptyUpdateReady(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\",\n          disable: \"disabled\"\n        },\n        ready: {\n          updateData: \"waiting\",\n          clear: \"clearing\",\n          highlight: (data) => this.animateReadyHighlight(data),\n          highlightMarkers: (data) => this.animateReadyHighlightMarkers(data),\n          resize: (data) => this.animateReadyResize(data),\n          reset: \"empty\",\n          skip: \"ready\",\n          disable: \"disabled\"\n        },\n        waiting: {\n          update: {\n            target: \"ready\",\n            action: (data) => {\n              if (this.ctx.animationManager.isSkipped()) {\n                this.resetAllAnimation(data);\n              } else {\n                this.animateWaitingUpdateReady(data);\n              }\n            }\n          },\n          reset: \"empty\",\n          skip: \"ready\",\n          disable: \"disabled\"\n        },\n        disabled: {\n          update: (data) => this.resetAllAnimation(data),\n          reset: \"empty\"\n        },\n        clearing: {\n          update: {\n            target: \"empty\",\n            action: (data) => this.animateClearingUpdateEmpty(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\"\n        }\n      },\n      () => this.checkProcessedDataAnimatable()\n    );\n  }\n  get contextNodeData() {\n    return this._contextNodeData;\n  }\n  getNodeData() {\n    return this.contextNodeData?.nodeData;\n  }\n  resetAnimation(phase) {\n    if (phase === \"initial\") {\n      this.animationState.transition(\"reset\");\n    } else if (phase === \"ready\") {\n      this.animationState.transition(\"skip\");\n    } else if (phase === \"disabled\") {\n      this.animationState.transition(\"disable\");\n    }\n  }\n  addChartEventListeners() {\n    this.destroyFns.push(\n      this.ctx.chartEventManager.addListener(\"legend-item-click\", (event) => this.onLegendItemClick(event)),\n      this.ctx.chartEventManager.addListener(\n        \"legend-item-double-click\",\n        (event) => this.onLegendItemDoubleClick(event)\n      )\n    );\n  }\n  destroy() {\n    super.destroy();\n    this._contextNodeData = void 0;\n  }\n  async update({ seriesRect }) {\n    const { visible, _contextNodeData: previousContextData } = this;\n    const series = this.ctx.highlightManager?.getActiveHighlight()?.series;\n    const seriesHighlighted = series === this;\n    const resize = this.checkResize(seriesRect);\n    const highlightItems = await this.updateHighlightSelection(seriesHighlighted);\n    await this.updateSelections(visible);\n    await this.updateNodes(highlightItems, seriesHighlighted, visible);\n    const animationData = this.getAnimationData(seriesRect, previousContextData);\n    if (!animationData)\n      return;\n    if (resize) {\n      this.animationState.transition(\"resize\", animationData);\n    }\n    this.animationState.transition(\"update\", animationData);\n  }\n  async updateSelections(anySeriesItemEnabled) {\n    var _a;\n    const animationSkipUpdate = !this.opts.animationAlwaysUpdateSelections && this.ctx.animationManager.isSkipped();\n    if (!anySeriesItemEnabled && animationSkipUpdate) {\n      return;\n    }\n    if (!this.nodeDataRefresh && !this.isPathOrSelectionDirty()) {\n      return;\n    }\n    if (this.nodeDataRefresh) {\n      this.nodeDataRefresh = false;\n      this.debug(`CartesianSeries.updateSelections() - calling createNodeData() for`, this.id);\n      this.markQuadtreeDirty();\n      this._contextNodeData = await this.createNodeData();\n      const animationValid = this.isProcessedDataAnimatable();\n      if (this._contextNodeData) {\n        (_a = this._contextNodeData).animationValid ?? (_a.animationValid = animationValid);\n      }\n      this.minRectsCache.dirtyNodeData = true;\n      const { dataModel, processedData } = this;\n      if (dataModel !== void 0 && processedData !== void 0) {\n        this.dispatch(\"data-update\", { dataModel, processedData });\n      }\n    }\n    await this.updateSeriesSelections();\n  }\n  async updateSeriesSelections(seriesHighlighted) {\n    const { datumSelection, labelSelection, markerSelection, paths } = this;\n    const contextData = this._contextNodeData;\n    if (!contextData)\n      return;\n    const { nodeData, labelData, itemId } = contextData;\n    await this.updatePaths({ seriesHighlighted, itemId, contextData, paths });\n    this.datumSelection = await this.updateDatumSelection({ nodeData, datumSelection });\n    this.labelSelection = await this.updateLabelSelection({ labelData, labelSelection });\n    if (this.opts.hasMarkers) {\n      this.markerSelection = await this.updateMarkerSelection({ nodeData, markerSelection });\n    }\n  }\n  markerFactory() {\n    const MarkerShape = getMarker();\n    return new MarkerShape();\n  }\n  getGroupZIndexSubOrder(type, subIndex = 0) {\n    const result = super.getGroupZIndexSubOrder(type, subIndex);\n    if (type === \"paths\") {\n      const [superFn] = result;\n      const pathOffset = this.opts.pathsZIndexSubOrderOffset[subIndex] ?? 0;\n      result[0] = isFunction(superFn) ? () => Number(superFn()) + pathOffset : Number(superFn) + pathOffset;\n    }\n    return result;\n  }\n  async updateNodes(highlightedItems, seriesHighlighted, anySeriesItemEnabled) {\n    const {\n      highlightSelection,\n      highlightLabelSelection,\n      opts: { hasMarkers, hasHighlightedLabels }\n    } = this;\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    const visible = this.visible && this._contextNodeData != null && anySeriesItemEnabled;\n    this.rootGroup.visible = animationEnabled || visible;\n    this.contentGroup.visible = animationEnabled || visible;\n    this.highlightGroup.visible = (animationEnabled || visible) && seriesHighlighted;\n    const opacity = this.getOpacity();\n    if (hasMarkers) {\n      await this.updateMarkerNodes({\n        markerSelection: highlightSelection,\n        isHighlight: true\n      });\n      this.animationState.transition(\"highlightMarkers\", highlightSelection);\n    } else {\n      await this.updateDatumNodes({\n        datumSelection: highlightSelection,\n        isHighlight: true\n      });\n      this.animationState.transition(\"highlight\", highlightSelection);\n    }\n    if (hasHighlightedLabels) {\n      await this.updateLabelNodes({ labelSelection: highlightLabelSelection });\n    }\n    const { dataNodeGroup, markerGroup, datumSelection, labelSelection, markerSelection, paths, labelGroup } = this;\n    const { itemId } = this.contextNodeData ?? {};\n    dataNodeGroup.opacity = opacity;\n    dataNodeGroup.visible = animationEnabled || visible;\n    labelGroup.visible = visible;\n    if (hasMarkers) {\n      markerGroup.opacity = opacity;\n      markerGroup.zIndex = dataNodeGroup.zIndex >= 4 /* SERIES_LAYER */ ? dataNodeGroup.zIndex : dataNodeGroup.zIndex + 1;\n      markerGroup.visible = visible;\n    }\n    if (labelGroup) {\n      labelGroup.opacity = opacity;\n    }\n    await this.updatePathNodes({\n      seriesHighlighted,\n      itemId,\n      paths,\n      opacity,\n      visible,\n      animationEnabled\n    });\n    if (!dataNodeGroup.visible) {\n      return;\n    }\n    await this.updateDatumNodes({ datumSelection, highlightedItems, isHighlight: false });\n    await this.updateLabelNodes({ labelSelection });\n    if (hasMarkers) {\n      await this.updateMarkerNodes({ markerSelection, isHighlight: false });\n    }\n  }\n  getHighlightLabelData(labelData, highlightedItem) {\n    const labelItems = labelData.filter(\n      (ld) => ld.datum === highlightedItem.datum && ld.itemId === highlightedItem.itemId\n    );\n    return labelItems.length === 0 ? void 0 : labelItems;\n  }\n  getHighlightData(_nodeData, highlightedItem) {\n    return highlightedItem ? [highlightedItem] : void 0;\n  }\n  async updateHighlightSelection(seriesHighlighted) {\n    const { highlightSelection, highlightLabelSelection, _contextNodeData: contextNodeData } = this;\n    if (!contextNodeData)\n      return;\n    const highlightedDatum = this.ctx.highlightManager?.getActiveHighlight();\n    const item = seriesHighlighted && highlightedDatum?.datum ? highlightedDatum : void 0;\n    let labelItems;\n    let highlightItems;\n    if (item != null) {\n      const labelsEnabled = this.isLabelEnabled();\n      const { labelData, nodeData } = contextNodeData;\n      highlightItems = this.getHighlightData(nodeData, item);\n      labelItems = labelsEnabled ? this.getHighlightLabelData(labelData, item) : void 0;\n    }\n    this.highlightSelection = await this.updateHighlightSelectionItem({\n      items: highlightItems,\n      highlightSelection\n    });\n    this.highlightLabelSelection = await this.updateHighlightSelectionLabel({\n      items: labelItems,\n      highlightLabelSelection\n    });\n    return highlightItems;\n  }\n  markQuadtreeDirty() {\n    this.quadtree = void 0;\n  }\n  *datumNodesIter() {\n    for (const { node } of this.datumSelection) {\n      if (node.datum.missing === true)\n        continue;\n      yield node;\n    }\n  }\n  getQuadTree() {\n    if (this.quadtree === void 0) {\n      const { width: width2, height: height2 } = this.ctx.scene.canvas;\n      const canvasRect = new BBox(0, 0, width2, height2);\n      this.quadtree = new QuadtreeNearest(100, 10, canvasRect);\n      this.initQuadTree(this.quadtree);\n    }\n    return this.quadtree;\n  }\n  initQuadTree(_quadtree) {\n  }\n  pickNodeExactShape(point) {\n    const result = super.pickNodeExactShape(point);\n    if (result) {\n      return result;\n    }\n    const { x, y } = point;\n    const {\n      opts: { hasMarkers }\n    } = this;\n    let match;\n    const { dataNodeGroup, markerGroup } = this;\n    match = dataNodeGroup.pickNode(x, y);\n    if (!match && hasMarkers) {\n      match = markerGroup?.pickNode(x, y);\n    }\n    if (match && match.datum.missing !== true) {\n      return { datum: match.datum, distance: 0 };\n    }\n    for (const mod2 of this.moduleMap.modules()) {\n      const { datum } = mod2.pickNodeExact(point) ?? {};\n      if (datum == null)\n        continue;\n      if (datum?.missing === true)\n        continue;\n      return { datum, distance: 0 };\n    }\n  }\n  pickNodeClosestDatum(point) {\n    const { x, y } = point;\n    const { axes, _contextNodeData: contextNodeData } = this;\n    if (!contextNodeData)\n      return;\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    const hitPoint = { x, y };\n    let minDistance = Infinity;\n    let closestDatum;\n    for (const datum of contextNodeData.nodeData) {\n      const { point: { x: datumX = NaN, y: datumY = NaN } = {} } = datum;\n      if (isNaN(datumX) || isNaN(datumY)) {\n        continue;\n      }\n      const isInRange = xAxis?.inRange(datumX) && yAxis?.inRange(datumY);\n      if (!isInRange) {\n        continue;\n      }\n      const distance3 = Math.max((hitPoint.x - datumX) ** 2 + (hitPoint.y - datumY) ** 2, 0);\n      if (distance3 < minDistance) {\n        minDistance = distance3;\n        closestDatum = datum;\n      }\n    }\n    for (const mod2 of this.moduleMap.modules()) {\n      const modPick = mod2.pickNodeNearest(point);\n      if (modPick !== void 0 && modPick.distanceSquared < minDistance) {\n        minDistance = modPick.distanceSquared;\n        closestDatum = modPick.datum;\n        break;\n      }\n    }\n    if (closestDatum) {\n      const distance3 = Math.max(Math.sqrt(minDistance) - (closestDatum.point?.size ?? 0), 0);\n      return { datum: closestDatum, distance: distance3 };\n    }\n  }\n  pickNodeMainAxisFirst(point, requireCategoryAxis) {\n    const { x, y } = point;\n    const { axes, _contextNodeData: contextNodeData } = this;\n    const { pickOutsideVisibleMinorAxis } = this.properties;\n    if (!contextNodeData)\n      return;\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    const directions2 = [xAxis, yAxis].filter(CategoryAxis.is).map((a) => a.direction);\n    if (requireCategoryAxis && directions2.length === 0)\n      return;\n    const [majorDirection = \"x\" /* X */] = directions2;\n    const hitPointCoords = [x, y];\n    if (majorDirection !== \"x\" /* X */)\n      hitPointCoords.reverse();\n    const minDistance = [Infinity, Infinity];\n    let closestDatum;\n    for (const datum of contextNodeData.nodeData) {\n      const { x: datumX = NaN, y: datumY = NaN } = datum.point ?? datum.midPoint ?? {};\n      if (isNaN(datumX) || isNaN(datumY) || datum.missing === true)\n        continue;\n      const visible = [xAxis?.inRange(datumX), yAxis?.inRange(datumY)];\n      if (majorDirection !== \"x\" /* X */) {\n        visible.reverse();\n      }\n      if (!visible[0] || !pickOutsideVisibleMinorAxis && !visible[1])\n        continue;\n      const datumPoint = [datumX, datumY];\n      if (majorDirection !== \"x\" /* X */) {\n        datumPoint.reverse();\n      }\n      let newMinDistance = true;\n      for (let i = 0; i < datumPoint.length; i++) {\n        const dist = Math.abs(datumPoint[i] - hitPointCoords[i]);\n        if (dist > minDistance[i]) {\n          newMinDistance = false;\n          break;\n        } else if (dist < minDistance[i]) {\n          minDistance[i] = dist;\n          minDistance.fill(Infinity, i + 1, minDistance.length);\n        }\n      }\n      if (newMinDistance) {\n        closestDatum = datum;\n      }\n    }\n    if (closestDatum) {\n      let closestDistanceSquared = Math.max(\n        minDistance[0] ** 2 + minDistance[1] ** 2 - (closestDatum.point?.size ?? 0),\n        0\n      );\n      for (const mod2 of this.moduleMap.modules()) {\n        const modPick = mod2.pickNodeMainAxisFirst(point);\n        if (modPick !== void 0 && modPick.distanceSquared < closestDistanceSquared) {\n          closestDatum = modPick.datum;\n          closestDistanceSquared = modPick.distanceSquared;\n          break;\n        }\n      }\n      return { datum: closestDatum, distance: Math.sqrt(closestDistanceSquared) };\n    }\n  }\n  onLegendItemClick(event) {\n    const { legendItemName } = this.properties;\n    const { enabled, itemId, series } = event;\n    const matchedLegendItemName = legendItemName != null && legendItemName === event.legendItemName;\n    if (series.id === this.id || matchedLegendItemName) {\n      this.toggleSeriesItem(itemId, enabled);\n    }\n  }\n  onLegendItemDoubleClick(event) {\n    const { enabled, itemId, series, numVisibleItems } = event;\n    const { legendItemName } = this.properties;\n    const matchedLegendItemName = legendItemName != null && legendItemName === event.legendItemName;\n    if (series.id === this.id || matchedLegendItemName) {\n      this.toggleSeriesItem(itemId, true);\n    } else if (enabled && numVisibleItems === 1) {\n      this.toggleSeriesItem(itemId, true);\n    } else {\n      this.toggleSeriesItem(itemId, false);\n    }\n  }\n  isPathOrSelectionDirty() {\n    return false;\n  }\n  getLabelData() {\n    return [];\n  }\n  shouldFlipXY() {\n    return false;\n  }\n  /**\n   * Get the minimum bounding box that contains any adjacent two nodes. The axes are treated independently, so this\n   * may not represent the same two points for both directions. The dimensions represent the greatest distance\n   * between any two adjacent nodes.\n   */\n  getMinRects(width2, height2) {\n    const { dirtyNodeData, sizeCache, minRect, minVisibleRect } = this.minRectsCache;\n    const newSizeCache = JSON.stringify({ width: width2, height: height2 });\n    const dirtySize = newSizeCache !== sizeCache;\n    if (!dirtySize && !dirtyNodeData && minRect && minVisibleRect) {\n      return { minRect, minVisibleRect };\n    }\n    const rects = this.computeMinRects(width2, height2);\n    this.minRectsCache = {\n      dirtyNodeData: false,\n      sizeCache: newSizeCache,\n      minRect: rects?.minRect,\n      minVisibleRect: rects?.minVisibleRect\n    };\n    return rects;\n  }\n  computeMinRects(width2, height2) {\n    const context = this._contextNodeData;\n    if (!context?.nodeData.length) {\n      return;\n    }\n    const { nodeData } = context;\n    const minRectXs = Array(nodeData.length);\n    const minRectYs = Array(nodeData.length);\n    for (const [i, { midPoint }] of nodeData.entries()) {\n      minRectXs[i] = midPoint?.x ?? 0;\n      minRectYs[i] = midPoint?.y ?? 0;\n    }\n    minRectXs.sort((a, b) => a - b);\n    minRectYs.sort((a, b) => a - b);\n    let zeroX, widthX, zeroY, heightY;\n    let maxWidth = 0;\n    let maxHeight = 0;\n    for (let i = 1; i < nodeData.length; i++) {\n      if (minRectXs[i] >= 0)\n        zeroX ?? (zeroX = i);\n      if (minRectXs[i] > width2)\n        widthX ?? (widthX = i);\n      if (minRectYs[i] >= 0)\n        zeroY ?? (zeroY = i);\n      if (minRectYs[i] > height2)\n        heightY ?? (heightY = i);\n      maxWidth = Math.max(maxWidth, minRectXs[i] - minRectXs[i - 1]);\n      maxHeight = Math.max(maxHeight, minRectYs[i] - minRectYs[i - 1]);\n    }\n    widthX ?? (widthX = nodeData.length);\n    heightY ?? (heightY = nodeData.length);\n    const minVisibleRectXs = zeroX != null && widthX != null ? minRectXs.slice(zeroX, widthX) : [];\n    const minVisibleRectYs = zeroY != null && heightY != null ? minRectYs.slice(zeroY, heightY) : [];\n    let maxVisibleWidth = 0;\n    let maxVisibleHeight = 0;\n    for (let i = 1; i < Math.max(minVisibleRectXs.length, minVisibleRectYs.length); i++) {\n      const x1 = minVisibleRectXs[i];\n      const x2 = minVisibleRectXs[i - 1];\n      const y1 = minVisibleRectYs[i];\n      const y2 = minVisibleRectYs[i - 1];\n      if (x1 != null && x2 != null) {\n        maxVisibleWidth = Math.max(maxVisibleWidth, x1 - x2);\n      }\n      if (y1 != null && y2 != null) {\n        maxVisibleHeight = Math.max(maxVisibleHeight, y1 - y2);\n      }\n    }\n    const minRect = new BBox(0, 0, maxWidth, maxHeight);\n    const minVisibleRect = new BBox(0, 0, maxVisibleWidth, maxVisibleHeight);\n    return { minRect, minVisibleRect };\n  }\n  updateHighlightSelectionItem(opts) {\n    const {\n      opts: { hasMarkers }\n    } = this;\n    const { items, highlightSelection } = opts;\n    const nodeData = items ?? [];\n    if (hasMarkers) {\n      const markerSelection = highlightSelection;\n      return this.updateMarkerSelection({ nodeData, markerSelection });\n    } else {\n      return this.updateDatumSelection({\n        nodeData,\n        datumSelection: highlightSelection\n      });\n    }\n  }\n  updateHighlightSelectionLabel(opts) {\n    return this.updateLabelSelection({\n      labelData: opts.items ?? [],\n      labelSelection: opts.highlightLabelSelection\n    });\n  }\n  async updateDatumSelection(opts) {\n    return opts.datumSelection;\n  }\n  async updateDatumNodes(_opts) {\n  }\n  async updateMarkerSelection(opts) {\n    return opts.markerSelection;\n  }\n  async updateMarkerNodes(_opts) {\n  }\n  async updatePaths(opts) {\n    opts.paths.forEach((p) => p.visible = false);\n  }\n  async updatePathNodes(opts) {\n    const { paths, opacity, visible } = opts;\n    for (const path of paths) {\n      path.opacity = opacity;\n      path.visible = visible;\n    }\n  }\n  resetPathAnimation(data) {\n    const { path } = this.opts?.animationResetFns ?? {};\n    if (path) {\n      data.paths.forEach((paths) => {\n        resetMotion([paths], path);\n      });\n    }\n  }\n  resetDatumAnimation(data) {\n    const { datum } = this.opts?.animationResetFns ?? {};\n    if (datum) {\n      resetMotion([data.datumSelection], datum);\n    }\n  }\n  resetLabelAnimation(data) {\n    const { label } = this.opts?.animationResetFns ?? {};\n    if (label) {\n      resetMotion([data.labelSelection], label);\n    }\n  }\n  resetMarkerAnimation(data) {\n    const { marker } = this.opts?.animationResetFns ?? {};\n    if (marker && this.opts.hasMarkers) {\n      resetMotion([data.markerSelection], marker);\n    }\n  }\n  resetAllAnimation(data) {\n    this.ctx.animationManager.stopByAnimationGroupId(this.id);\n    this.resetPathAnimation(data);\n    this.resetDatumAnimation(data);\n    this.resetLabelAnimation(data);\n    this.resetMarkerAnimation(data);\n    if (data.contextData?.animationValid === false) {\n      this.ctx.animationManager.skipCurrentBatch();\n    }\n  }\n  animateEmptyUpdateReady(data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation(data);\n  }\n  animateWaitingUpdateReady(data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation(data);\n  }\n  animateReadyHighlight(data) {\n    const { datum } = this.opts?.animationResetFns ?? {};\n    if (datum) {\n      resetMotion([data], datum);\n    }\n  }\n  animateReadyHighlightMarkers(data) {\n    const { marker } = this.opts?.animationResetFns ?? {};\n    if (marker) {\n      resetMotion([data], marker);\n    }\n  }\n  animateReadyResize(data) {\n    this.resetAllAnimation(data);\n  }\n  animateClearingUpdateEmpty(data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation(data);\n  }\n  animationTransitionClear() {\n    const animationData = this.getAnimationData();\n    if (!animationData)\n      return;\n    this.animationState.transition(\"clear\", animationData);\n  }\n  getAnimationData(seriesRect, previousContextData) {\n    const { _contextNodeData: contextData } = this;\n    if (!contextData)\n      return;\n    const animationData = {\n      datumSelection: this.datumSelection,\n      markerSelection: this.markerSelection,\n      labelSelection: this.labelSelection,\n      annotationSelections: [...this.annotationSelections],\n      contextData,\n      previousContextData,\n      paths: this.paths,\n      seriesRect\n    };\n    return animationData;\n  }\n  calculateScaling() {\n    const result = {};\n    for (const direction of Object.values(ChartAxisDirection)) {\n      const axis = this.axes[direction];\n      if (!axis)\n        continue;\n      if (axis.scale instanceof LogScale) {\n        const { range: range3, domain } = axis.scale;\n        result[direction] = {\n          type: \"log\",\n          convert: (d) => axis.scale.convert(d),\n          domain: [domain[0], domain[1]],\n          range: [range3[0], range3[1]]\n        };\n      } else if (axis.scale instanceof ContinuousScale) {\n        const { range: range3 } = axis.scale;\n        const domain = axis.scale.getDomain();\n        result[direction] = {\n          type: \"continuous\",\n          domain: [domain[0], domain[1]],\n          range: [range3[0], range3[1]]\n        };\n      } else if (axis.scale) {\n        const { domain } = axis.scale;\n        result[direction] = {\n          type: \"category\",\n          domain,\n          range: domain.map((d) => axis.scale.convert(d))\n        };\n      }\n    }\n    return result;\n  }\n};\n\n// packages/ag-charts-community/src/chart/cartesianChart.ts\nvar directions = [\"top\", \"right\", \"bottom\", \"left\"];\nvar CartesianChart = class extends Chart {\n  constructor(options, resources) {\n    super(options, resources);\n    /** Integrated Charts feature state - not used in Standalone Charts. */\n    this.paired = true;\n    this.firstSeriesTranslation = true;\n    this.lastUpdateClipRect = void 0;\n    this._lastCrossLineIds = void 0;\n    this._lastAxisAreaWidths = /* @__PURE__ */ new Map();\n    this._lastClipSeries = false;\n    this._lastVisibility = {\n      crossLines: true,\n      series: true\n    };\n  }\n  onAxisChange(newValue, oldValue) {\n    super.onAxisChange(newValue, oldValue);\n    this.ctx?.zoomManager.updateAxes(newValue);\n  }\n  destroySeries(series) {\n    super.destroySeries(series);\n    this.firstSeriesTranslation = true;\n  }\n  getChartType() {\n    return \"cartesian\";\n  }\n  setRootClipRects(clipRect) {\n    const { seriesRoot, annotationRoot, highlightRoot } = this;\n    seriesRoot.setClipRect(clipRect);\n    highlightRoot.setClipRect(clipRect);\n    annotationRoot.setClipRect(clipRect);\n  }\n  performLayout(ctx) {\n    const { firstSeriesTranslation, seriesRoot, annotationRoot, highlightRoot } = this;\n    const { seriesRect, visibility, clipSeries } = this.updateAxes(ctx.layoutBox);\n    this.seriesRoot.visible = visibility.series;\n    this.seriesRect = seriesRect;\n    this.animationRect = ctx.layoutBox;\n    const { x, y } = seriesRect;\n    if (firstSeriesTranslation) {\n      for (const group of [seriesRoot, annotationRoot, highlightRoot]) {\n        group.translationX = Math.floor(x);\n        group.translationY = Math.floor(y);\n      }\n      this.firstSeriesTranslation = false;\n    } else {\n      const { translationX, translationY } = seriesRoot;\n      staticFromToMotion(\n        this.id,\n        \"seriesRect\",\n        this.ctx.animationManager,\n        [seriesRoot, highlightRoot, annotationRoot],\n        { translationX, translationY },\n        { translationX: Math.floor(x), translationY: Math.floor(y) },\n        { phase: \"update\" }\n      );\n    }\n    const seriesPaddedRect = seriesRect.clone().grow(this.seriesArea.padding);\n    const clipRect = this.seriesArea.clip || clipSeries ? seriesPaddedRect : void 0;\n    const { lastUpdateClipRect } = this;\n    this.lastUpdateClipRect = clipRect;\n    if (this.ctx.animationManager.isActive() && lastUpdateClipRect != null) {\n      this.ctx.animationManager.animate({\n        id: this.id,\n        groupId: \"clip-rect\",\n        phase: \"update\",\n        from: lastUpdateClipRect,\n        to: seriesPaddedRect,\n        onUpdate: (interpolatedClipRect) => this.setRootClipRects(interpolatedClipRect),\n        onComplete: () => this.setRootClipRects(clipRect)\n      });\n    } else {\n      this.setRootClipRects(clipRect);\n    }\n    this.ctx.layoutManager.emitLayoutComplete(ctx, {\n      axes: this.axes.map((axis) => axis.getLayoutState()),\n      series: {\n        rect: seriesRect,\n        paddedRect: seriesPaddedRect,\n        visible: visibility.series,\n        shouldFlipXY: this.shouldFlipXY()\n      },\n      clipSeries\n    });\n  }\n  updateAxes(layoutBox) {\n    const crossLineIds = this.axes.flatMap((axis) => axis.crossLines ?? []).map((crossLine) => crossLine.id);\n    const axesValid = this._lastCrossLineIds != null && this._lastCrossLineIds.length === crossLineIds.length && this._lastCrossLineIds.every((id, index) => crossLineIds[index] === id);\n    let axisAreaWidths;\n    let clipSeries;\n    let visibility;\n    if (axesValid) {\n      axisAreaWidths = new Map(this._lastAxisAreaWidths.entries());\n      clipSeries = this._lastClipSeries;\n      visibility = { ...this._lastVisibility };\n    } else {\n      axisAreaWidths = /* @__PURE__ */ new Map();\n      clipSeries = false;\n      visibility = { crossLines: true, series: true };\n      this._lastCrossLineIds = crossLineIds;\n    }\n    const liveAxisWidths = new Set(this.axes.map((a) => a.position));\n    for (const position of axisAreaWidths.keys()) {\n      if (!liveAxisWidths.has(position)) {\n        axisAreaWidths.delete(position);\n      }\n    }\n    const stableOutputs = (otherAxisWidths, otherClipSeries, otherVisibility) => {\n      if ([...otherAxisWidths.keys()].some((k) => !axisAreaWidths.has(k))) {\n        return false;\n      }\n      if (visibility.crossLines !== otherVisibility.crossLines || visibility.series !== otherVisibility.series || clipSeries !== otherClipSeries) {\n        return false;\n      }\n      for (const [p, w] of axisAreaWidths.entries()) {\n        const otherW = otherAxisWidths.get(p);\n        if ((w != null || otherW != null) && w !== otherW) {\n          return false;\n        }\n      }\n      return true;\n    };\n    const ceilValues = (map) => {\n      for (const [key, value] of map.entries()) {\n        if (value && Math.abs(value) === Infinity) {\n          map.set(key, 0);\n          continue;\n        }\n        map.set(key, value != null ? Math.ceil(value) : value);\n      }\n      return map;\n    };\n    let lastPassAxisAreaWidths = /* @__PURE__ */ new Map();\n    let lastPassVisibility = {};\n    let lastPassClipSeries = false;\n    let seriesRect = this.seriesRect?.clone();\n    let count = 0;\n    do {\n      axisAreaWidths = new Map(lastPassAxisAreaWidths.entries());\n      clipSeries = lastPassClipSeries;\n      Object.assign(visibility, lastPassVisibility);\n      const result = this.updateAxesPass(axisAreaWidths, layoutBox.clone(), seriesRect);\n      lastPassAxisAreaWidths = ceilValues(result.axisAreaWidths);\n      lastPassVisibility = result.visibility;\n      lastPassClipSeries = result.clipSeries;\n      ({ seriesRect } = result);\n      if (count++ > 10) {\n        Logger.warn(\"unable to find stable axis layout.\");\n        break;\n      }\n    } while (!stableOutputs(lastPassAxisAreaWidths, lastPassClipSeries, lastPassVisibility));\n    this.axes.forEach((axis) => {\n      axis.update();\n    });\n    const clipRectPadding = 5;\n    this.axes.forEach((axis) => {\n      axis.setCrossLinesVisible(visibility.crossLines);\n      if (!seriesRect) {\n        return;\n      }\n      axis.clipGrid(\n        seriesRect.x,\n        seriesRect.y,\n        seriesRect.width + clipRectPadding,\n        seriesRect.height + clipRectPadding\n      );\n      switch (axis.position) {\n        case \"left\":\n        case \"right\":\n          axis.clipTickLines(\n            layoutBox.x,\n            seriesRect.y,\n            layoutBox.width + clipRectPadding,\n            seriesRect.height + clipRectPadding\n          );\n          break;\n        case \"top\":\n        case \"bottom\":\n          axis.clipTickLines(\n            seriesRect.x,\n            layoutBox.y,\n            seriesRect.width + clipRectPadding,\n            layoutBox.height + clipRectPadding\n          );\n          break;\n      }\n    });\n    this._lastAxisAreaWidths = axisAreaWidths;\n    this._lastVisibility = visibility;\n    this._lastClipSeries = clipSeries;\n    return { seriesRect, visibility, clipSeries };\n  }\n  updateAxesPass(axisAreaWidths, bounds, lastPassSeriesRect) {\n    const axisWidths = /* @__PURE__ */ new Map();\n    const axisGroups = /* @__PURE__ */ new Map();\n    const visibility = {\n      series: true,\n      crossLines: true\n    };\n    let clipSeries = false;\n    const primaryTickCounts = {};\n    const paddedBounds = this.applySeriesPadding(bounds);\n    const crossLinePadding = lastPassSeriesRect ? this.buildCrossLinePadding(axisAreaWidths) : {};\n    const axisAreaBound = this.buildAxisBound(paddedBounds, axisAreaWidths, crossLinePadding, visibility);\n    const seriesRect = this.buildSeriesRect(axisAreaBound, axisAreaWidths);\n    for (const axis of this.axes) {\n      const { position = \"left\" } = axis;\n      const { clipSeries: newClipSeries, axisThickness } = this.calculateAxisDimensions({\n        axis,\n        seriesRect,\n        primaryTickCounts,\n        clipSeries\n      });\n      axisWidths.set(axis.id, axisThickness);\n      if (!axisGroups.has(position))\n        axisGroups.set(position, []);\n      axisGroups.get(position)?.push(axis);\n      clipSeries = clipSeries || newClipSeries;\n    }\n    const newAxisAreaWidths = /* @__PURE__ */ new Map();\n    const axisOffsets = /* @__PURE__ */ new Map();\n    for (const [position, axes] of axisGroups.entries()) {\n      const isVertical = position === \"left\" || position === \"right\";\n      newAxisAreaWidths.set(position, this.calculateAxisArea(axes, axisWidths, axisOffsets, isVertical));\n    }\n    for (const [position, axes] of axisGroups.entries()) {\n      this.positionAxes({\n        axes,\n        position,\n        axisWidths,\n        axisOffsets,\n        axisAreaWidths: newAxisAreaWidths,\n        axisBound: axisAreaBound,\n        seriesRect\n      });\n    }\n    return { clipSeries, seriesRect, axisAreaWidths: newAxisAreaWidths, visibility };\n  }\n  buildCrossLinePadding(axisAreaSize) {\n    const crossLinePadding = {};\n    this.axes.forEach((axis) => {\n      axis.crossLines?.forEach((crossLine) => {\n        crossLine.calculatePadding?.(crossLinePadding);\n      });\n    });\n    for (const [side, padding = 0] of Object.entries(crossLinePadding)) {\n      crossLinePadding[side] = Math.max(padding - (axisAreaSize.get(side) ?? 0), 0);\n    }\n    return crossLinePadding;\n  }\n  applySeriesPadding(bounds) {\n    const paddedRect = bounds.clone();\n    directions.forEach((dir) => {\n      const padding = this.seriesArea.padding[dir];\n      const axis = this.axes.findLast((a) => a.position === dir);\n      if (axis) {\n        axis.seriesAreaPadding = padding;\n      } else {\n        paddedRect.shrink(padding, dir);\n      }\n    });\n    return paddedRect;\n  }\n  buildAxisBound(bounds, axisAreaWidths, crossLinePadding, visibility) {\n    const result = bounds.clone();\n    const { top = 0, right = 0, bottom = 0, left = 0 } = crossLinePadding;\n    const horizontalPadding = left + right;\n    const verticalPadding = top + bottom;\n    const totalWidth = (axisAreaWidths.get(\"left\") ?? 0) + (axisAreaWidths.get(\"right\") ?? 0) + horizontalPadding;\n    const totalHeight = (axisAreaWidths.get(\"top\") ?? 0) + (axisAreaWidths.get(\"bottom\") ?? 0) + verticalPadding;\n    if (result.width <= totalWidth || result.height <= totalHeight) {\n      visibility.crossLines = false;\n      visibility.series = false;\n      return result;\n    }\n    result.x += left;\n    result.y += top;\n    result.width -= horizontalPadding;\n    result.height -= verticalPadding;\n    return result;\n  }\n  buildSeriesRect(axisBound, axisAreaWidths) {\n    const result = axisBound.clone();\n    result.x += axisAreaWidths.get(\"left\") ?? 0;\n    result.y += axisAreaWidths.get(\"top\") ?? 0;\n    result.width -= (axisAreaWidths.get(\"left\") ?? 0) + (axisAreaWidths.get(\"right\") ?? 0);\n    result.height -= (axisAreaWidths.get(\"top\") ?? 0) + (axisAreaWidths.get(\"bottom\") ?? 0);\n    result.width = Math.max(0, result.width);\n    result.height = Math.max(0, result.height);\n    return result;\n  }\n  clampToOutsideSeriesRect(seriesRect, value, dimension, direction) {\n    const { x, y, width: width2, height: height2 } = seriesRect;\n    const clampBounds = [x, y, x + width2, y + height2];\n    const compareTo = clampBounds[(dimension === \"x\" ? 0 : 1) + (direction === 1 ? 0 : 2)];\n    const clampFn = direction === 1 ? Math.min : Math.max;\n    return clampFn(value, compareTo);\n  }\n  calculateAxisDimensions(opts) {\n    const { axis, seriesRect, primaryTickCounts } = opts;\n    let { clipSeries } = opts;\n    const { position = \"left\", direction } = axis;\n    this.sizeAxis(axis, seriesRect, position);\n    const syncedDomain = this.getSyncedDomain(axis);\n    const layout = axis.calculateLayout(syncedDomain, axis.nice ? primaryTickCounts[direction] : void 0);\n    const isVertical = direction === \"y\" /* Y */;\n    primaryTickCounts[direction] ?? (primaryTickCounts[direction] = layout.primaryTickCount);\n    clipSeries || (clipSeries = axis.dataDomain.clipped || axis.visibleRange[0] > 0 || axis.visibleRange[1] < 1);\n    let axisThickness;\n    if (axis.thickness != null && axis.thickness > 0) {\n      axisThickness = axis.thickness;\n    } else {\n      axisThickness = isVertical ? layout.bbox.width : layout.bbox.height;\n    }\n    axisThickness = Math.ceil(axisThickness);\n    return { clipSeries, axisThickness };\n  }\n  getSyncedDomain(axis) {\n    const syncModule = this.modulesManager.getModule(\"sync\");\n    if (!syncModule?.enabled)\n      return;\n    const syncedDomain = syncModule.getSyncedDomain(axis);\n    if (syncedDomain && axis.dataDomain.domain.length) {\n      let shouldUpdate;\n      const { domain } = axis.scale;\n      if (ContinuousScale.is(axis.scale)) {\n        const [min, max] = findMinMax(syncedDomain);\n        shouldUpdate = min !== domain[0] || max !== domain[1];\n      } else {\n        shouldUpdate = !arraysEqual(syncedDomain, domain);\n      }\n      if (shouldUpdate && !this.skipSync) {\n        syncModule.updateSiblings();\n      }\n    }\n    return syncedDomain;\n  }\n  sizeAxis(axis, seriesRect, position) {\n    const isCategory = axis instanceof CategoryAxis || axis instanceof GroupedCategoryAxis;\n    const isLeftRight = position === \"left\" || position === \"right\";\n    let { min, max } = this.ctx.zoomManager.getAxisZoom(axis.id);\n    const { width: width2, height: height2 } = seriesRect;\n    const minStart = 0;\n    const maxEnd = isLeftRight ? height2 : width2;\n    let start2 = minStart;\n    let end2 = maxEnd;\n    const { width: axisWidth, unit, align } = axis.layoutConstraints;\n    if (unit === \"px\") {\n      end2 = start2 + axisWidth;\n    } else {\n      end2 = end2 * axisWidth / 100;\n    }\n    if (align === \"end\") {\n      start2 = maxEnd - (end2 - start2);\n      end2 = maxEnd;\n    }\n    if (isCategory && isLeftRight) {\n      [min, max] = [1 - max, 1 - min];\n    } else if (isLeftRight) {\n      [start2, end2] = [end2, start2];\n    }\n    axis.range = [start2, end2];\n    axis.visibleRange = [min, max];\n    axis.gridLength = isLeftRight ? width2 : height2;\n  }\n  calculateAxisArea(axes, axisWidths, axisOffsets, isVertical) {\n    const { width: width2, height: height2, canvas } = this.ctx.scene;\n    let currentOffset = isVertical ? height2 % canvas.pixelRatio : width2 % canvas.pixelRatio;\n    let totalAxisWidth = 0;\n    for (const axis of axes) {\n      axisOffsets.set(axis.id, currentOffset);\n      const axisThickness = axisWidths.get(axis.id) ?? 0;\n      totalAxisWidth = Math.max(totalAxisWidth, currentOffset + axisThickness);\n      if (axis.layoutConstraints.stacked) {\n        currentOffset += axisThickness + 15;\n      }\n    }\n    return totalAxisWidth;\n  }\n  positionAxes(opts) {\n    const { axes, axisBound, axisWidths, axisOffsets, axisAreaWidths, seriesRect, position } = opts;\n    const axisAreaWidth = axisAreaWidths.get(position) ?? 0;\n    let mainDimension = \"x\";\n    let minorDimension = \"y\";\n    let direction = 1;\n    let axisBoundMainOffset = 0;\n    if (position === \"top\" || position === \"bottom\") {\n      mainDimension = \"y\";\n      minorDimension = \"x\";\n      axisBoundMainOffset += 1;\n    }\n    axisBoundMainOffset += axisBound[mainDimension];\n    if (position === \"right\" || position === \"bottom\") {\n      direction = -1;\n      axisBoundMainOffset += mainDimension === \"x\" ? axisBound.width : axisBound.height;\n    }\n    for (const axis of axes) {\n      const minorOffset = axisAreaWidths.get(minorDimension === \"x\" ? \"left\" : \"top\") ?? 0;\n      axis.translation[minorDimension] = axisBound[minorDimension] + minorOffset;\n      const axisThickness = axisWidths.get(axis.id) ?? 0;\n      const axisOffset = axisOffsets.get(axis.id) ?? 0;\n      axis.translation[mainDimension] = this.clampToOutsideSeriesRect(\n        seriesRect,\n        axisBoundMainOffset + direction * (axisOffset + axisThickness),\n        mainDimension,\n        direction\n      );\n      axis.gridPadding = axisAreaWidth - axisOffset - axisThickness;\n      axis.updatePosition();\n    }\n  }\n  shouldFlipXY() {\n    return this.series.every((series) => series instanceof CartesianSeries && series.shouldFlipXY());\n  }\n};\nCartesianChart.className = \"CartesianChart\";\nCartesianChart.type = \"cartesian\";\n\n// packages/ag-charts-community/src/chart/chartProxy.ts\nvar _AgChartInstanceProxy = class _AgChartInstanceProxy {\n  constructor(chart, factoryApi, licenseManager) {\n    this.factoryApi = factoryApi;\n    this.licenseManager = licenseManager;\n    this.chart = chart;\n  }\n  static isInstance(x) {\n    if (x instanceof _AgChartInstanceProxy) {\n      return true;\n    }\n    if (x.constructor?.name === \"AgChartInstanceProxy\" && x.chart != null) {\n      return true;\n    }\n    return x.chart != null && this.validateImplementation(x);\n  }\n  static validateImplementation(x) {\n    const chartProps = [\"getOptions\", \"destroy\"];\n    const signatureProps = Object.keys(Object.getPrototypeOf(x) ?? {});\n    return chartProps.every((prop) => signatureProps.includes(prop));\n  }\n  async update(options) {\n    this.factoryApi.update(options, this);\n    await this.chart.waitForUpdate();\n  }\n  async updateDelta(deltaOptions) {\n    this.factoryApi.updateUserDelta(this, deltaOptions);\n    await this.chart.waitForUpdate();\n  }\n  getOptions() {\n    const options = deepClone(this.chart.getOptions());\n    for (const key in options) {\n      if (key.startsWith(\"_\")) {\n        delete options[key];\n      }\n    }\n    return options;\n  }\n  waitForUpdate() {\n    return this.chart.waitForUpdate();\n  }\n  async download(opts) {\n    const clone2 = await this.prepareResizedChart(this, opts);\n    try {\n      clone2.chart.download(opts?.fileName, opts?.fileFormat);\n    } finally {\n      clone2.destroy();\n    }\n  }\n  async __toSVG(opts) {\n    const clone2 = await this.prepareResizedChart(this, { width: 600, height: 300, ...opts });\n    try {\n      return clone2.chart.toSVG();\n    } finally {\n      clone2.destroy();\n    }\n  }\n  async getImageDataURL(opts) {\n    const clone2 = await this.prepareResizedChart(this, opts);\n    try {\n      return clone2.chart.getCanvasDataURL(opts?.fileFormat);\n    } finally {\n      clone2.destroy();\n    }\n  }\n  getState() {\n    const {\n      factoryApi: { caretaker },\n      chart: {\n        ctx: { annotationManager }\n      }\n    } = this;\n    return caretaker.save(annotationManager);\n  }\n  async setState(state) {\n    const {\n      factoryApi: { caretaker },\n      chart: {\n        ctx: { annotationManager }\n      }\n    } = this;\n    caretaker.restore(state, annotationManager);\n    await this.chart.waitForUpdate();\n  }\n  resetAnimations() {\n    this.chart.resetAnimations();\n  }\n  skipAnimations() {\n    this.chart.skipAnimations();\n  }\n  destroy() {\n    this.chart.publicApi = void 0;\n    this.chart.destroy();\n  }\n  async prepareResizedChart(proxy, opts = {}) {\n    const { chart } = proxy;\n    const width2 = opts.width ?? chart.width ?? chart.ctx.scene.canvas.width;\n    const height2 = opts.height ?? chart.height ?? chart.ctx.scene.canvas.height;\n    const state = proxy.getState();\n    const isEnterprise = moduleRegistry.hasEnterpriseModules();\n    const processedOverrides = {\n      ...chart.chartOptions.processedOverrides,\n      container: document.createElement(\"div\"),\n      width: width2,\n      height: height2\n    };\n    const userOptions = chart.getOptions();\n    if (isEnterprise) {\n      processedOverrides.animation = { enabled: false };\n      if (isAgCartesianChartOptions(userOptions)) {\n        processedOverrides.toolbar = { enabled: false };\n      }\n      if (this.licenseManager?.isDisplayWatermark()) {\n        processedOverrides.foreground = {\n          text: this.licenseManager.getWatermarkMessage(),\n          image: {\n            url: `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjU4IiBoZWlnaHQ9IjQwIiB2aWV3Qm94PSIwIDAgMjU4IDQwIiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8cGF0aCBkPSJNMjUuNzc5IDI4LjY1N0gxMy4zNTlMMTEuMTczIDM0LjAxMkg1LjY3Mjk3TDE3LjE4MiA3LjA1OTk5SDIxLjk1M0wzMy40NjIgMzQuMDEySDI3Ljk2MkwyNS43NzYgMjguNjU3SDI1Ljc3OVpNMjQuMDY4IDI0LjM5N0wxOS41ODggMTMuNDM0TDE1LjEwNyAyNC4zOTdIMjQuMDY4Wk02Mi4wOTIgMTguODIzSDQ5LjgxN1YyMy4wODZINTYuNzc1QzU2LjU1NSAyNS4yMjIgNTUuNzU1IDI2LjkyNyA1NC4zNzIgMjguMjAyQzUyLjk4OSAyOS40NzYgNTEuMTY2IDMwLjExNSA0OC45MDkgMzAuMTE1QzQ3LjYyMiAzMC4xMTUgNDYuNDUgMjkuODg1IDQ1LjM5MyAyOS40MjNDNDQuMzU4MyAyOC45NzgxIDQzLjQzMjYgMjguMzEzOCA0Mi42OCAyNy40NzZDNDEuOTI3IDI2LjYzOSA0MS4zNDQgMjUuNjMxIDQwLjkzMSAyNC40NTNDNDAuNTE5IDIzLjI3NSA0MC4zMTEgMjEuOTcgNDAuMzExIDIwLjUzN0M0MC4zMTEgMTkuMTA1IDQwLjUxNiAxNy44IDQwLjkzMSAxNi42MjFDNDEuMzQ0IDE1LjQ0MyA0MS45MjcgMTQuNDM2IDQyLjY4IDEzLjU5OEM0My40Mzc2IDEyLjc1NzcgNDQuMzY5NiAxMi4wOTMyIDQ1LjQxMSAxMS42NTFDNDYuNDc4IDExLjE4OSA0Ny42NTYgMTAuOTYgNDguOTQ2IDEwLjk2QzUxLjYxMiAxMC45NiA1My42MzcgMTEuNjAyIDU1LjAyIDEyLjg4NUw1OC4zIDkuNjA0OTlDNTUuODE3IDcuNjY5OTkgNTIuNjc2IDYuNjk5OTkgNDguODcyIDYuNjk5OTlDNDYuNzYgNi42OTk5OSA0NC44NTMgNy4wMzQ5OSA0My4xNTQgNy43MDA5OUM0MS40NTUgOC4zNjc5OSAzOS45OTggOS4zMDM5OSAzOC43ODMgMTAuNTA0QzM3LjU2NyAxMS43MDcgMzYuNjM0IDEzLjE1OCAzNS45NzcgMTQuODU3QzM1LjMxOSAxNi41NTYgMzQuOTk0IDE4LjQ1MSAzNC45OTQgMjAuNTRDMzQuOTk0IDIyLjYzIDM1LjMyOSAyNC40OTQgMzUuOTk1IDI2LjIwNUMzNi42NjIgMjcuOTE2IDM3LjYwNSAyOS4zNzQgMzguODE3IDMwLjU3N0M0MC4wMzIgMzEuNzggNDEuNDg2IDMyLjcxMyA0My4xODggMzMuMzgzQzQ0Ljg4OCAzNC4wNDkgNDYuNzgyIDM0LjM4NCA0OC44NzIgMzQuMzg0QzUwLjk2MSAzNC4zODQgNTIuNzUgMzQuMDQ5IDU0LjM5IDMzLjM4M0M1Ni4wMzEgMzIuNzE2IDU3LjQyNiAzMS43OCA1OC41NzkgMzAuNTc3QzU5LjczMyAyOS4zNzQgNjAuNjE5IDI3LjkxNiA2MS4yMzkgMjYuMjA1QzYxLjg2IDI0LjQ5NCA2Mi4xNyAyMi42MDUgNjIuMTcgMjAuNTRDNjIuMTY5NiAxOS45Njg4IDYyLjE0NDUgMTkuMzk4IDYyLjA5NSAxOC44MjlMNjIuMDkyIDE4LjgyM1pNMTUxLjgxIDE2Ljk4MUMxNTMuNDEgMTQuNjA5IDE1Ny40MTkgMTQuMzU4IDE1OS4wMjIgMTQuMzU4VjE4LjkxQzE1Ni45NTcgMTguOTEgMTU0Ljk4NSAxOC45OTYgMTUzLjc1NyAxOS44OTJDMTUyLjUyOSAyMC43OTIgMTUxLjkxOSAyMS45ODIgMTUxLjkxOSAyMy40NjRWMzMuOTlIMTQ2Ljk2NFYxNC4zNThIMTUxLjczNkwxNTEuODEgMTYuOTgxWk0xNDMuMDExIDE0LjM2MVYzNC4wMzFIMTM4LjI0TDEzOC4xMzEgMzEuMDQ1QzEzNy40NjYgMzIuMDc2IDEzNi41NTEgMzIuOTIxOSAxMzUuNDcxIDMzLjUwNEMxMzQuMzc2IDM0LjA5OSAxMzMuMDY4IDM0LjM5NiAxMzEuNTM2IDM0LjM5NkMxMzAuMiAzNC4zOTYgMTI4Ljk2MyAzNC4xNTIgMTI3LjgyMiAzMy42NjhDMTI2LjcgMzMuMTk2NCAxMjUuNjg5IDMyLjQ5NSAxMjQuODU1IDMxLjYwOUMxMjQuMDE4IDMwLjcyMiAxMjMuMzU0IDI5LjY2MiAxMjIuODcxIDI4LjQyMkMxMjIuMzg0IDI3LjE4NSAxMjIuMTQyIDI1LjgxMSAxMjIuMTQyIDI0LjMwNEMxMjIuMTQyIDIyLjc5OCAxMjIuMzg0IDIxLjM3OCAxMjIuODcxIDIwLjExNkMxMjMuMzU3IDE4Ljg1NCAxMjQuMDE4IDE3Ljc3MiAxMjQuODU1IDE2Ljg3M0MxMjUuNjg4IDE1Ljk3NjQgMTI2LjY5OCAxNS4yNjM2IDEyNy44MjIgMTQuNzhDMTI4Ljk2MyAxNC4yODEgMTMwLjIwMyAxNC4wMzMgMTMxLjUzNiAxNC4wMzNDMTMzLjA0MyAxNC4wMzMgMTM0LjMzIDE0LjMxOCAxMzUuMzk3IDE0Ljg4OEMxMzYuNDYyIDE1LjQ1ODkgMTM3LjM3NSAxNi4yNzggMTM4LjA1NyAxNy4yNzZWMTQuMzYxSDE0My4wMTFaTTEzMi42MzEgMzAuMTMzQzEzNC4yNTYgMzAuMTMzIDEzNS41NjcgMjkuNTk0IDEzNi41NjUgMjguNTEyQzEzNy41NjEgMjcuNDMgMTM4LjA2IDI1Ljk5MSAxMzguMDYgMjQuMTk2QzEzOC4wNiAyMi40MDEgMTM3LjU2MSAyMC45OSAxMzYuNTY1IDE5Ljg5OUMxMzUuNTcgMTguODA3IDEzNC4yNTkgMTguMjU4IDEzMi42MzEgMTguMjU4QzEzMS4wMDMgMTguMjU4IDEyOS43MjkgMTguODA0IDEyOC43MzQgMTkuODk5QzEyNy43MzggMjAuOTkzIDEyNy4yMzkgMjIuNDM4IDEyNy4yMzkgMjQuMjMzQzEyNy4yMzkgMjYuMDI4IDEyNy43MzUgMjcuNDMzIDEyOC43MzQgMjguNTE1QzEyOS43MjkgMjkuNTk0IDEzMS4wMjggMzAuMTM2IDEzMi42MzEgMzAuMTM2VjMwLjEzM1pNOTMuNjk4IDI3Ljg3NkM5My41Nzk1IDI4LjAwMjUgOTMuNDU2NCAyOC4xMjQ2IDkzLjMyOSAyOC4yNDJDOTEuOTQ3IDI5LjUxNiA5MC4xMjMgMzAuMTU1IDg3Ljg2NiAzMC4xNTVDODYuNTggMzAuMTU1IDg1LjQwOCAyOS45MjYgODQuMzUgMjkuNDY0QzgzLjMxNTUgMjkuMDE4OSA4Mi4zODk4IDI4LjM1NDYgODEuNjM3IDI3LjUxN0M4MC44ODQgMjYuNjc5IDgwLjMwMSAyNS42NzIgNzkuODg5IDI0LjQ5NEM3OS40NzYgMjMuMzE1IDc5LjI2OSAyMi4wMSA3OS4yNjkgMjAuNTc4Qzc5LjI2OSAxOS4xNDUgNzkuNDczIDE3Ljg0IDc5Ljg4OSAxNi42NjJDODAuMzAxIDE1LjQ4NCA4MC44ODQgMTQuNDc2IDgxLjYzNyAxMy42MzlDODIuMzk0OSAxMi43OTg3IDgzLjMyNzMgMTIuMTM0MiA4NC4zNjkgMTEuNjkyQzg1LjQzNiAxMS4yMyA4Ni42MTQgMTEgODcuOTAzIDExQzkwLjU3IDExIDkyLjU5NSAxMS42NDIgOTMuOTc3IDEyLjkyNkw5Ny4yNTggOS42NDQ5OUM5NC43NzQgNy43MTA5OSA5MS42MzMgNi43Mzk5OSA4Ny44MjkgNi43Mzk5OUM4NS43MTggNi43Mzk5OSA4My44MTEgNy4wNzQ5OSA4Mi4xMTIgNy43NDE5OUM4MC40MTMgOC40MDc5OSA3OC45NTYgOS4zNDQ5OSA3Ny43NCAxMC41NDVDNzYuNTI1IDExLjc0NyA3NS41OTIgMTMuMTk5IDc0LjkzNCAxNC44OThDNzQuMjc3IDE2LjU5NyA3My45NTEgMTguNDkxIDczLjk1MSAyMC41ODFDNzMuOTUxIDIyLjY3IDc0LjI4NiAyNC41MzQgNzQuOTUzIDI2LjI0NUM3NS42MTkgMjcuOTU3IDc2LjU2MiAyOS40MTQgNzcuNzc0IDMwLjYxN0M3OC45OSAzMS44MiA4MC40NDQgMzIuNzUzIDgyLjE0NiAzMy40MjNDODMuODQ1IDM0LjA5IDg1LjczOSAzNC40MjQgODcuODI5IDM0LjQyNEM4OS45MTkgMzQuNDI0IDkxLjcwOCAzNC4wOSA5My4zNDggMzMuNDIzQzk0LjcxOCAzMi44NjUgOTUuOTE4IDMyLjEyMSA5Ni45NDggMzEuMTkxQzk3LjE0OSAzMS4wMDggOTcuMzQ4IDMwLjgxNSA5Ny41MzcgMzAuNjJMOTMuNzAxIDI3Ljg4NUw5My42OTggMjcuODc2Wk0xMTAuODAyIDE0LjAxNUMxMDkuMTk5IDE0LjAxNSAxMDYuODM2IDE0LjQ3MSAxMDUuNjExIDE2LjE1OEwxMDUuNTM3IDYuMDE1OTlIMTAwLjc2NVYzMy45MzlIMTA1LjcyVjIyLjY0MUMxMDUuNzcxIDIxLjQ2MDcgMTA2LjI4OCAyMC4zNDg4IDEwNy4xNTcgMTkuNTQ4OUMxMDguMDI3IDE4Ljc0OTEgMTA5LjE3OCAxOC4zMjY2IDExMC4zNTggMTguMzc0QzExMy4zOTcgMTguMzc0IDExNC4yNjggMjEuMTU5IDExNC4yNjggMjIuNjQxVjMzLjkzOUgxMTkuMjIzVjIxLjA1OUMxMTkuMjIzIDIxLjA1OSAxMTkuMTQyIDE0LjAxNSAxMTAuODAyIDE0LjAxNVpNMTczLjc2MyAxNC4zNThIMTY5Ljk5OVY4LjcxNDk5SDE2NS4wNDhWMTQuMzU4SDE2MS4yODRWMTguOTE2SDE2NS4wNDhWMzQuMDAzSDE2OS45OTlWMTguOTE2SDE3My43NjNWMTQuMzU4Wk0xOTAuNzg3IDI1LjI2MkMxOTAuMTI5IDI0LjUwMTQgMTg5LjMwNyAyMy44OTk0IDE4OC4zODQgMjMuNTAxQzE4Ny40ODggMjMuMTE3IDE4Ni4zMzEgMjIuNzMyIDE4NC45NDggMjIuMzY0QzE4NC4xNjUgMjIuMTQzOSAxODMuMzkgMjEuODk3OCAxODIuNjIzIDIxLjYyNkMxODIuMTYzIDIxLjQ2MjEgMTgxLjc0MSAyMS4yMDY2IDE4MS4zODMgMjAuODc1QzE4MS4yMzUgMjAuNzQyMSAxODEuMTE4IDIwLjU3ODkgMTgxLjAzOSAyMC4zOTY0QzE4MC45NjEgMjAuMjE0IDE4MC45MjIgMjAuMDE2NiAxODAuOTI3IDE5LjgxOEMxODAuOTI3IDE5LjI3MiAxODEuMTU2IDE4Ljg0NCAxODEuNjI1IDE4LjUxQzE4Mi4xMjEgMTguMTU2IDE4Mi44NjIgMTcuOTc2IDE4My44MjYgMTcuOTc2QzE4NC43OSAxNy45NzYgMTg1LjU4NyAxOC4yMDkgMTg2LjE0OCAxOC42NjhDMTg2LjcwNiAxOS4xMjQgMTg3LjAwNyAxOS43MjUgMTg3LjA3MiAyMC41TDE4Ny4wOTQgMjAuNzgySDE5MS42MzNMMTkxLjYxNyAyMC40NkMxOTEuNTIxIDE4LjQ4NSAxOTAuNzcxIDE2LjkgMTg5LjM4NSAxNS43NUMxODguMDEyIDE0LjYxMiAxODYuMTg1IDE0LjAzMyAxODMuOTYyIDE0LjAzM0MxODIuNDc3IDE0LjAzMyAxODEuMTQxIDE0LjI4NyAxNzkuOTk0IDE0Ljc4NkMxNzguODMxIDE1LjI5MSAxNzcuOTI2IDE1Ljk5NSAxNzcuMjk2IDE2Ljg4MkMxNzYuNjczIDE3Ljc0NTUgMTc2LjMzOCAxOC43ODQgMTc2LjM0MSAxOS44NDlDMTc2LjM0MSAyMS4xNjcgMTc2LjY5OCAyMi4yNDkgMTc3LjM5OSAyMy4wNjRDMTc4LjA2IDIzLjg0MzIgMTc4Ljg5OCAyNC40NTM0IDE3OS44NDIgMjQuODQ0QzE4MC43NDQgMjUuMjE2IDE4MS45MjggMjUuNjA3IDE4My4zNjEgMjZDMTg0LjgwNiAyNi40MSAxODUuODcyIDI2Ljc4NSAxODYuNTMgMjcuMTIzQzE4Ny4xIDI3LjQxNCAxODcuMzc5IDI3Ljg0NSAxODcuMzc5IDI4LjQ0NEMxODcuMzc5IDI5LjA0MiAxODcuMTIyIDI5LjQ2NyAxODYuNTk1IDI5LjgzOUMxODYuMDQzIDMwLjIyNiAxODUuMjM3IDMwLjQyNSAxODQuMjAxIDMwLjQyNUMxODMuMTY2IDMwLjQyNSAxODIuMzk0IDMwLjE3NCAxODEuNzQ5IDI5LjY3NEMxODEuMTEzIDI5LjE4MSAxODAuNzcyIDI4LjU4OSAxODAuNzEgMjcuODY0TDE4MC42ODUgMjcuNTgySDE3Ni4wMTNMMTc2LjAyNSAyNy45MDFDMTc2LjA2NyAyOS4wOTU1IDE3Ni40NzIgMzAuMjQ4NyAxNzcuMTg4IDMxLjIwNkMxNzcuOTA3IDMyLjE4IDE3OC44OTMgMzIuOTU4IDE4MC4xMTggMzMuNTE5QzE4MS4zMzYgMzQuMDc3IDE4Mi43MzIgMzQuMzYyIDE4NC4yNjYgMzQuMzYyQzE4NS44MDEgMzQuMzYyIDE4Ny4xMDkgMzQuMTA4IDE4OC4yMzggMzMuNjA5QzE4OS4zNzYgMzMuMTA0IDE5MC4yNzIgMzIuMzk0IDE5MC45MDEgMzEuNDk0QzE5MS41MzQgMzAuNTkyIDE5MS44NTMgMjkuNTU0IDE5MS44NTMgMjguNDAzQzE5MS44MjggMjcuMTEgMTkxLjQ2NiAyNi4wNTMgMTkwLjc3NyAyNS4yNjJIMTkwLjc4N1oiIGZpbGw9IiM5QjlCOUIiLz4KPHBhdGggZD0iTTI0MS45ODIgMjUuNjU4MlYxNy43MTE3SDIyOC40NDFMMjIwLjQ5NCAyNS42NTgySDI0MS45ODJaIiBmaWxsPSIjOUI5QjlCIi8+CjxwYXRoIGQ9Ik0yNTcuMjM5IDUuOTUwODFIMjQwLjI2NUwyMzIuMjU1IDEzLjg5NzNIMjU3LjIzOVY1Ljk1MDgxWiIgZmlsbD0iIzlCOUI5QiIvPgo8cGF0aCBkPSJNMjEyLjYxMSAzMy42MDQ4TDIxNi42OCAyOS41MzYxSDIzMC40MTJWMzcuNDgyN0gyMTIuNjExVjMzLjYwNDhaIiBmaWxsPSIjOUI5QjlCIi8+CjxwYXRoIGQ9Ik0yMTUuNTk5IDIxLjc4MDNIMjI0LjM3MkwyMzIuMzgyIDEzLjgzMzdIMjE1LjU5OVYyMS43ODAzWiIgZmlsbD0iIzlCOUI5QiIvPgo8cGF0aCBkPSJNMjA2IDMzLjYwNDdIMjEyLjYxMUwyMjAuNDk0IDI1LjY1ODJIMjA2VjMzLjYwNDdaIiBmaWxsPSIjOUI5QjlCIi8+CjxwYXRoIGQ9Ik0yNDAuMjY1IDUuOTUwODFMMjM2LjE5NyAxMC4wMTk0SDIxMC4yNTlWMi4wNzI4OEgyNDAuMjY1VjUuOTUwODFaIiBmaWxsPSIjOUI5QjlCIi8+Cjwvc3ZnPgo=`,\n            width: 170,\n            height: 25,\n            right: 25,\n            bottom: 50,\n            opacity: 0.7\n          }\n        };\n      }\n    }\n    const specialOverrides = { ...chart.chartOptions.specialOverrides };\n    const optionsMetadata = { ...chart.chartOptions.optionMetadata };\n    if (opts.width != null && opts.height != null) {\n      specialOverrides.overrideDevicePixelRatio = 1;\n    }\n    const cloneProxy = await this.factoryApi.create(\n      userOptions,\n      processedOverrides,\n      specialOverrides,\n      optionsMetadata\n    );\n    await cloneProxy.setState(state);\n    cloneProxy.chart.ctx.zoomManager.updateZoom(\"chartProxy\", chart.ctx.zoomManager.getZoom());\n    chart.series.forEach((series, index) => {\n      if (!series.visible) {\n        cloneProxy.chart.series[index].visible = false;\n      }\n    });\n    cloneProxy.chart.update(0 /* FULL */, { forceNodeDataRefresh: true });\n    await cloneProxy.waitForUpdate();\n    return cloneProxy;\n  }\n};\n_AgChartInstanceProxy.chartInstances = /* @__PURE__ */ new WeakMap();\n__decorateClass([\n  ActionOnSet({\n    oldValue(chart) {\n      if (!chart.destroyed) {\n        chart.publicApi = void 0;\n      }\n      _AgChartInstanceProxy.chartInstances.delete(chart);\n    },\n    newValue(chart) {\n      chart.publicApi = this;\n      _AgChartInstanceProxy.chartInstances.set(chart, this);\n    }\n  })\n], _AgChartInstanceProxy.prototype, \"chart\", 2);\nvar AgChartInstanceProxy = _AgChartInstanceProxy;\n\n// packages/ag-charts-community/src/locale/locale.ts\nvar Locale = class extends BaseModuleInstance {\n  constructor(ctx) {\n    super();\n    this.ctx = ctx;\n    this.localeText = void 0;\n  }\n};\n__decorateClass([\n  ObserveChanges((target) => {\n    target.ctx.localeManager.setLocaleText(target.localeText);\n  }),\n  Validate(PLAIN_OBJECT, { optional: true })\n], Locale.prototype, \"localeText\", 2);\n__decorateClass([\n  ObserveChanges((target) => {\n    target.ctx.localeManager.setLocaleTextFormatter(target.getLocaleText);\n  }),\n  Validate(FUNCTION, { optional: true })\n], Locale.prototype, \"getLocaleText\", 2);\n\n// packages/ag-charts-community/src/locale/localeModule.ts\nvar LocaleModule = {\n  type: \"root\",\n  optionsKey: \"locale\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\", \"standalone\", \"gauge\"],\n  moduleFactory: (ctx) => new Locale(ctx)\n};\n\n// packages/ag-charts-community/src/scale/linearScale.ts\nvar LinearScale = class extends ContinuousScale {\n  constructor() {\n    super([0, 1], [0, 1]);\n    this.type = \"number\";\n  }\n  toDomain(d) {\n    return d;\n  }\n  ticks() {\n    const count = this.tickCount ?? ContinuousScale.defaultTickCount;\n    if (!this.domain || this.domain.length < 2 || count < 1 || !this.domain.every(isFinite)) {\n      return [];\n    }\n    this.refresh();\n    const [d0, d1] = this.getDomain();\n    if (this.interval) {\n      const step = Math.abs(this.interval);\n      if (!isDenseInterval((d1 - d0) / step, this.getPixelRange())) {\n        return range(d0, d1, step);\n      }\n    }\n    return createTicks(d0, d1, count, this.minTickCount, this.maxTickCount);\n  }\n  update() {\n    if (!this.domain || this.domain.length < 2) {\n      return;\n    }\n    if (this.nice) {\n      this.updateNiceDomain();\n    }\n  }\n  getTickStep(start2, stop) {\n    return this.interval ?? tickStep(start2, stop, this.tickCount, this.minTickCount, this.maxTickCount);\n  }\n  /**\n   * Extends the domain so that it starts and ends on nice round values.\n   */\n  updateNiceDomain() {\n    const count = this.tickCount;\n    if (count < 1) {\n      this.niceDomain = [...this.domain];\n      return;\n    }\n    let [start2, stop] = this.domain;\n    if (count === 1) {\n      [start2, stop] = niceTicksDomain(start2, stop);\n    } else {\n      const roundStart = start2 > stop ? Math.ceil : Math.floor;\n      const roundStop = stop < start2 ? Math.floor : Math.ceil;\n      const maxAttempts = 4;\n      for (let i = 0; i < maxAttempts; i++) {\n        const prev0 = start2;\n        const prev1 = stop;\n        const step = this.getTickStep(start2, stop);\n        const [d0, d1] = this.domain;\n        if (step >= 1) {\n          start2 = roundStart(d0 / step) * step;\n          stop = roundStop(d1 / step) * step;\n        } else {\n          const s = 1 / step;\n          start2 = roundStart(d0 * s) / s;\n          stop = roundStop(d1 * s) / s;\n        }\n        if (start2 === prev0 && stop === prev1) {\n          break;\n        }\n      }\n    }\n    this.niceDomain = [start2, stop];\n  }\n  tickFormat({ ticks: specifiedTicks, specifier }) {\n    return tickFormat(specifiedTicks ?? this.ticks(), specifier);\n  }\n};\n\n// packages/ag-charts-community/src/util/secondaryAxisTicks.ts\nfunction calculateNiceSecondaryAxis(domain, primaryTickCount, reverse) {\n  let [start2, stop] = findMinMax(domain);\n  start2 = calculateNiceStart(Math.floor(start2), stop, primaryTickCount);\n  const step = getTickStep(start2, stop, primaryTickCount);\n  const segments = primaryTickCount - 1;\n  stop = start2 + segments * step;\n  const d = reverse ? [stop, start2] : [start2, stop];\n  const ticks = getTicks(start2, step, primaryTickCount);\n  return { domain: d, ticks };\n}\nfunction calculateNiceStart(a, b, count) {\n  const rawStep = Math.abs(b - a) / (count - 1);\n  const order = Math.floor(Math.log10(rawStep));\n  const magnitude = Math.pow(10, order);\n  return Math.floor(a / magnitude) * magnitude;\n}\nfunction getTicks(start2, step, count) {\n  const stepPower = Math.floor(Math.log10(step));\n  const fractionDigits = step > 0 && step < 1 ? Math.abs(stepPower) : 0;\n  const f = Math.pow(10, fractionDigits);\n  const ticks = [];\n  for (let i = 0; i < count; i++) {\n    const tick = start2 + step * i;\n    ticks[i] = Math.round(tick * f) / f;\n  }\n  return ticks;\n}\nfunction getTickStep(start2, stop, count) {\n  const segments = count - 1;\n  const rawStep = (stop - start2) / segments;\n  return calculateNextNiceStep(rawStep);\n}\nfunction calculateNextNiceStep(rawStep) {\n  const order = Math.floor(Math.log10(rawStep));\n  const magnitude = Math.pow(10, order);\n  const step = rawStep / magnitude * 10;\n  if (step > 0 && step <= 1) {\n    return magnitude / 10;\n  }\n  if (step > 1 && step <= 2) {\n    return 2 * magnitude / 10;\n  }\n  if (step > 1 && step <= 5) {\n    return 5 * magnitude / 10;\n  }\n  if (step > 5 && step <= 10) {\n    return 10 * magnitude / 10;\n  }\n  if (step > 10 && step <= 20) {\n    return 20 * magnitude / 10;\n  }\n  if (step > 20 && step <= 40) {\n    return 40 * magnitude / 10;\n  }\n  if (step > 40 && step <= 50) {\n    return 50 * magnitude / 10;\n  }\n  if (step > 50 && step <= 100) {\n    return 100 * magnitude / 10;\n  }\n  return step;\n}\n\n// packages/ag-charts-community/src/chart/axis/numberAxis.ts\nvar NumberAxis = class extends CartesianAxis {\n  constructor(moduleCtx, scale2 = new LinearScale()) {\n    super(moduleCtx, scale2);\n    this.min = NaN;\n    this.max = NaN;\n  }\n  normaliseDataDomain(d) {\n    const { min, max } = this;\n    const { extent: extent2, clipped } = normalisedExtentWithMetadata(d, min, max);\n    return { domain: extent2, clipped };\n  }\n  updateSecondaryAxisTicks(primaryTickCount) {\n    if (this.dataDomain == null) {\n      throw new Error(\"AG Charts - dataDomain not calculated, cannot perform tick calculation.\");\n    }\n    if (this.dataDomain.domain.length === 0) {\n      return [];\n    }\n    const { domain, ticks } = calculateNiceSecondaryAxis(\n      this.dataDomain.domain,\n      primaryTickCount ?? 0,\n      this.reverse\n    );\n    this.scale.nice = false;\n    this.scale.domain = domain;\n    this.scale.update();\n    return ticks;\n  }\n};\nNumberAxis.className = \"NumberAxis\";\nNumberAxis.type = \"number\";\n__decorateClass([\n  Validate(AND(NUMBER_OR_NAN, LESS_THAN(\"max\"))),\n  Default(NaN)\n], NumberAxis.prototype, \"min\", 2);\n__decorateClass([\n  Validate(AND(NUMBER_OR_NAN, GREATER_THAN(\"min\"))),\n  Default(NaN)\n], NumberAxis.prototype, \"max\", 2);\n\n// packages/ag-charts-community/src/chart/axis/logAxis.ts\nvar NON_ZERO_NUMBER = predicateWithMessage((value) => isNumber(value) && value !== 0, \"a non-zero number\");\nvar LogAxis = class extends NumberAxis {\n  constructor(moduleCtx) {\n    super(moduleCtx, new LogScale());\n    this.min = NaN;\n    this.max = NaN;\n  }\n  normaliseDataDomain(d) {\n    const { min, max } = this;\n    const { extent: extent2, clipped } = normalisedExtentWithMetadata(d, min, max);\n    const isInverted = extent2[0] > extent2[1];\n    const crossesZero = extent2[0] < 0 && extent2[1] > 0;\n    const hasZeroExtent = extent2[0] === 0 && extent2[1] === 0;\n    const invalidDomain = isInverted || crossesZero || hasZeroExtent;\n    if (invalidDomain) {\n      if (crossesZero) {\n        Logger.warn(\n          `the data domain crosses zero, the chart data cannot be rendered. See log axis documentation for more information.`\n        );\n      } else if (hasZeroExtent) {\n        Logger.warn(`the data domain has 0 extent, no data is rendered.`);\n      }\n    }\n    if (extent2[0] === 0) {\n      extent2[0] = 1;\n    }\n    if (extent2[1] === 0) {\n      extent2[1] = -1;\n    }\n    return { domain: extent2, clipped };\n  }\n  set base(value) {\n    this.scale.base = value;\n  }\n  get base() {\n    return this.scale.base;\n  }\n};\nLogAxis.className = \"LogAxis\";\nLogAxis.type = \"log\";\n__decorateClass([\n  Validate(AND(NUMBER_OR_NAN, NON_ZERO_NUMBER, LESS_THAN(\"max\"))),\n  Default(NaN)\n], LogAxis.prototype, \"min\", 2);\n__decorateClass([\n  Validate(AND(NUMBER_OR_NAN, NON_ZERO_NUMBER, GREATER_THAN(\"min\"))),\n  Default(NaN)\n], LogAxis.prototype, \"max\", 2);\n\n// packages/ag-charts-community/src/chart/axis/timeAxis.ts\nvar TimeAxis = class extends CartesianAxis {\n  constructor(moduleCtx) {\n    super(moduleCtx, new TimeScale());\n    this.min = void 0;\n    this.max = void 0;\n  }\n  normaliseDataDomain(d) {\n    let { min, max } = this;\n    let clipped = false;\n    if (typeof min === \"number\") {\n      min = new Date(min);\n    }\n    if (typeof max === \"number\") {\n      max = new Date(max);\n    }\n    if (d.length > 2) {\n      d = extent(d)?.map((x) => new Date(x)) ?? [];\n    }\n    if (min instanceof Date) {\n      clipped || (clipped = min > d[0]);\n      d = [min, d[1]];\n    }\n    if (max instanceof Date) {\n      clipped || (clipped = max < d[1]);\n      d = [d[0], max];\n    }\n    if (d[0] > d[1]) {\n      d = [];\n    }\n    return { domain: d, clipped };\n  }\n  onFormatChange(ticks, fractionDigits, domain, format) {\n    if (format) {\n      super.onFormatChange(ticks, fractionDigits, domain, format);\n    } else {\n      this.labelFormatter = this.scale.tickFormat({ ticks, domain });\n      this.datumFormatter = this.scale.tickFormat({ ticks, domain, formatOffset: 1 });\n    }\n  }\n};\nTimeAxis.className = \"TimeAxis\";\nTimeAxis.type = \"time\";\n__decorateClass([\n  Validate(AND(DATE_OR_DATETIME_MS, LESS_THAN(\"max\")), { optional: true })\n], TimeAxis.prototype, \"min\", 2);\n__decorateClass([\n  Validate(AND(DATE_OR_DATETIME_MS, GREATER_THAN(\"min\")), { optional: true })\n], TimeAxis.prototype, \"max\", 2);\n\n// packages/ag-charts-community/src/scene/util/corner.ts\nvar drawCorner = (path, { x0, y0, x1, y1, cx, cy }, cornerRadius, move) => {\n  if (move) {\n    path.moveTo(x0, y0);\n  }\n  if (x0 !== x1 || y0 !== y1) {\n    const r0 = Math.atan2(y0 - cy, x0 - cx);\n    const r1 = Math.atan2(y1 - cy, x1 - cx);\n    path.arc(cx, cy, cornerRadius, r0, r1);\n  } else {\n    path.lineTo(x0, y0);\n  }\n};\n\n// packages/ag-charts-community/src/scene/shape/rect.ts\nvar epsilon = 1e-6;\nvar cornerEdges = (leadingEdge, trailingEdge, leadingInset, trailingInset, cornerRadius) => {\n  let leadingClipped = false;\n  let trailingClipped = false;\n  let leading0 = trailingInset - Math.sqrt(Math.max(cornerRadius ** 2 - leadingInset ** 2, 0));\n  let leading1 = 0;\n  let trailing0 = 0;\n  let trailing1 = leadingInset - Math.sqrt(Math.max(cornerRadius ** 2 - trailingInset ** 2, 0));\n  if (leading0 > leadingEdge) {\n    leadingClipped = true;\n    leading0 = leadingEdge;\n    leading1 = leadingInset - Math.sqrt(Math.max(cornerRadius ** 2 - (trailingInset - leadingEdge) ** 2));\n  } else if (leading0 < epsilon) {\n    leading0 = 0;\n  }\n  if (trailing1 > trailingEdge) {\n    trailingClipped = true;\n    trailing0 = trailingInset - Math.sqrt(Math.max(cornerRadius ** 2 - (leadingInset - trailingEdge) ** 2));\n    trailing1 = trailingEdge;\n  } else if (trailing1 < epsilon) {\n    trailing1 = 0;\n  }\n  return { leading0, leading1, trailing0, trailing1, leadingClipped, trailingClipped };\n};\nvar insetCornerRadiusRect = (path, x, y, width2, height2, cornerRadii, clipBBox) => {\n  let {\n    topLeft: topLeftCornerRadius,\n    topRight: topRightCornerRadius,\n    bottomRight: bottomRightCornerRadius,\n    bottomLeft: bottomLeftCornerRadius\n  } = cornerRadii;\n  const maxVerticalCornerRadius = Math.max(\n    topLeftCornerRadius + bottomLeftCornerRadius,\n    topRightCornerRadius + bottomRightCornerRadius\n  );\n  const maxHorizontalCornerRadius = Math.max(\n    topLeftCornerRadius + topRightCornerRadius,\n    bottomLeftCornerRadius + bottomRightCornerRadius\n  );\n  if (maxVerticalCornerRadius <= 0 && maxHorizontalCornerRadius <= 0) {\n    if (clipBBox == null) {\n      path.rect(x, y, width2, height2);\n    } else {\n      path.rect(clipBBox.x, clipBBox.y, clipBBox.width, clipBBox.height);\n    }\n    return;\n  } else if (clipBBox == null && topLeftCornerRadius === topRightCornerRadius && topLeftCornerRadius === bottomRightCornerRadius && topLeftCornerRadius === bottomLeftCornerRadius) {\n    path.roundRect(x, y, width2, height2, topLeftCornerRadius);\n    return;\n  }\n  if (width2 < 0) {\n    x += width2;\n    width2 = Math.abs(width2);\n  }\n  if (height2 < 0) {\n    y += height2;\n    height2 = Math.abs(height2);\n  }\n  if (width2 <= 0 || height2 <= 0)\n    return;\n  if (clipBBox == null) {\n    clipBBox = new BBox(x, y, width2, height2);\n  } else {\n    const x0 = Math.max(x, clipBBox.x);\n    const x1 = Math.min(x + width2, clipBBox.x + clipBBox.width);\n    const y0 = Math.max(y, clipBBox.y);\n    const y1 = Math.min(y + height2, clipBBox.y + clipBBox.height);\n    clipBBox = new BBox(x0, y0, x1 - x0, y1 - y0);\n  }\n  const borderScale = Math.max(maxVerticalCornerRadius / height2, maxHorizontalCornerRadius / width2, 1);\n  if (borderScale > 1) {\n    topLeftCornerRadius /= borderScale;\n    topRightCornerRadius /= borderScale;\n    bottomRightCornerRadius /= borderScale;\n    bottomLeftCornerRadius /= borderScale;\n  }\n  let drawTopLeftCorner = true;\n  let drawTopRightCorner = true;\n  let drawBottomRightCorner = true;\n  let drawBottomLeftCorner = true;\n  let topLeftCorner;\n  let topRightCorner;\n  let bottomRightCorner;\n  let bottomLeftCorner;\n  if (drawTopLeftCorner) {\n    const nodes = cornerEdges(\n      clipBBox.height,\n      clipBBox.width,\n      Math.max(x + topLeftCornerRadius - clipBBox.x, 0),\n      Math.max(y + topLeftCornerRadius - clipBBox.y, 0),\n      topLeftCornerRadius\n    );\n    if (nodes.leadingClipped)\n      drawBottomLeftCorner = false;\n    if (nodes.trailingClipped)\n      drawTopRightCorner = false;\n    const x0 = Math.max(clipBBox.x + nodes.leading1, clipBBox.x);\n    const y0 = Math.max(clipBBox.y + nodes.leading0, clipBBox.y);\n    const x1 = Math.max(clipBBox.x + nodes.trailing1, clipBBox.x);\n    const y1 = Math.max(clipBBox.y + nodes.trailing0, clipBBox.y);\n    const cx = x + topLeftCornerRadius;\n    const cy = y + topLeftCornerRadius;\n    topLeftCorner = { x0, y0, x1, y1, cx, cy };\n  }\n  if (drawTopRightCorner) {\n    const nodes = cornerEdges(\n      clipBBox.width,\n      clipBBox.height,\n      Math.max(y + topRightCornerRadius - clipBBox.y, 0),\n      Math.max(clipBBox.x + clipBBox.width - (x + width2 - topRightCornerRadius), 0),\n      topRightCornerRadius\n    );\n    if (nodes.leadingClipped)\n      drawTopLeftCorner = false;\n    if (nodes.trailingClipped)\n      drawBottomRightCorner = false;\n    const x0 = Math.min(clipBBox.x + clipBBox.width - nodes.leading0, clipBBox.x + clipBBox.width);\n    const y0 = Math.max(clipBBox.y + nodes.leading1, clipBBox.y);\n    const x1 = Math.min(clipBBox.x + clipBBox.width - nodes.trailing0, clipBBox.x + clipBBox.width);\n    const y1 = Math.max(clipBBox.y + nodes.trailing1, clipBBox.y);\n    const cx = x + width2 - topRightCornerRadius;\n    const cy = y + topRightCornerRadius;\n    topRightCorner = { x0, y0, x1, y1, cx, cy };\n  }\n  if (drawBottomRightCorner) {\n    const nodes = cornerEdges(\n      clipBBox.height,\n      clipBBox.width,\n      Math.max(clipBBox.x + clipBBox.width - (x + width2 - bottomRightCornerRadius), 0),\n      Math.max(clipBBox.y + clipBBox.height - (y + height2 - bottomRightCornerRadius), 0),\n      bottomRightCornerRadius\n    );\n    if (nodes.leadingClipped)\n      drawTopRightCorner = false;\n    if (nodes.trailingClipped)\n      drawBottomLeftCorner = false;\n    const x0 = Math.min(clipBBox.x + clipBBox.width - nodes.leading1, clipBBox.x + clipBBox.width);\n    const y0 = Math.min(clipBBox.y + clipBBox.height - nodes.leading0, clipBBox.y + clipBBox.height);\n    const x1 = Math.min(clipBBox.x + clipBBox.width - nodes.trailing1, clipBBox.x + clipBBox.width);\n    const y1 = Math.min(clipBBox.y + clipBBox.height - nodes.trailing0, clipBBox.y + clipBBox.height);\n    const cx = x + width2 - bottomRightCornerRadius;\n    const cy = y + height2 - bottomRightCornerRadius;\n    bottomRightCorner = { x0, y0, x1, y1, cx, cy };\n  }\n  if (drawBottomLeftCorner) {\n    const nodes = cornerEdges(\n      clipBBox.width,\n      clipBBox.height,\n      Math.max(clipBBox.y + clipBBox.height - (y + height2 - bottomLeftCornerRadius), 0),\n      Math.max(x + bottomLeftCornerRadius - clipBBox.x, 0),\n      bottomLeftCornerRadius\n    );\n    if (nodes.leadingClipped)\n      drawBottomRightCorner = false;\n    if (nodes.trailingClipped)\n      drawTopLeftCorner = false;\n    const x0 = Math.max(clipBBox.x + nodes.leading0, clipBBox.x);\n    const y0 = Math.min(clipBBox.y + clipBBox.height - nodes.leading1, clipBBox.y + clipBBox.height);\n    const x1 = Math.max(clipBBox.x + nodes.trailing0, clipBBox.x);\n    const y1 = Math.min(clipBBox.y + clipBBox.height - nodes.trailing1, clipBBox.y + clipBBox.height);\n    const cx = x + bottomLeftCornerRadius;\n    const cy = y + height2 - bottomLeftCornerRadius;\n    bottomLeftCorner = { x0, y0, x1, y1, cx, cy };\n  }\n  let didMove = false;\n  if (drawTopLeftCorner && topLeftCorner != null) {\n    drawCorner(path, topLeftCorner, topLeftCornerRadius, !didMove);\n    didMove || (didMove = true);\n  }\n  if (drawTopRightCorner && topRightCorner != null) {\n    drawCorner(path, topRightCorner, topRightCornerRadius, !didMove);\n    didMove || (didMove = true);\n  }\n  if (drawBottomRightCorner && bottomRightCorner != null) {\n    drawCorner(path, bottomRightCorner, bottomRightCornerRadius, !didMove);\n    didMove || (didMove = true);\n  }\n  if (drawBottomLeftCorner && bottomLeftCorner != null) {\n    drawCorner(path, bottomLeftCorner, bottomLeftCornerRadius, !didMove);\n    didMove || (didMove = true);\n  }\n  path.closePath();\n};\nvar Rect = class extends Path {\n  constructor() {\n    super(...arguments);\n    this.borderPath = new ExtendedPath2D();\n    this.x = 0;\n    this.y = 0;\n    this.width = 10;\n    this.height = 10;\n    this.topLeftCornerRadius = 0;\n    this.topRightCornerRadius = 0;\n    this.bottomRightCornerRadius = 0;\n    this.bottomLeftCornerRadius = 0;\n    this.clipBBox = void 0;\n    this.crisp = false;\n    this.lastUpdatePathStrokeWidth = Shape.defaultStyles.strokeWidth;\n    this.effectiveStrokeWidth = Shape.defaultStyles.strokeWidth;\n    this.hittester = super.isPointInPath;\n    this.distanceCalculator = super.distanceSquaredTransformedPoint;\n    /**\n     * When the rectangle's width or height is less than a pixel\n     * and crisp mode is on, the rectangle will still fit into the pixel,\n     * but will be less opaque to make an effect of holding less space.\n     */\n    this.microPixelEffectOpacity = 1;\n  }\n  set cornerRadius(cornerRadius) {\n    this.topLeftCornerRadius = cornerRadius;\n    this.topRightCornerRadius = cornerRadius;\n    this.bottomRightCornerRadius = cornerRadius;\n    this.bottomLeftCornerRadius = cornerRadius;\n  }\n  isDirtyPath() {\n    return this.lastUpdatePathStrokeWidth !== this.strokeWidth || Boolean(this.path.isDirty() || this.borderPath.isDirty());\n  }\n  updatePath() {\n    const {\n      path,\n      borderPath,\n      crisp,\n      topLeftCornerRadius: topLeft,\n      topRightCornerRadius: topRight,\n      bottomRightCornerRadius: bottomRight,\n      bottomLeftCornerRadius: bottomLeft\n    } = this;\n    let { x, y, width: w, height: h, strokeWidth, clipBBox } = this;\n    const pixelRatio = this.layerManager?.canvas.pixelRatio ?? 1;\n    const pixelSize = 1 / pixelRatio;\n    let microPixelEffectOpacity = 1;\n    path.clear(true);\n    borderPath.clear(true);\n    if (crisp) {\n      if (w <= pixelSize) {\n        microPixelEffectOpacity *= w / pixelSize;\n      }\n      if (h <= pixelSize) {\n        microPixelEffectOpacity *= h / pixelSize;\n      }\n      w = this.align(x, w);\n      h = this.align(y, h);\n      x = this.align(x);\n      y = this.align(y);\n      clipBBox = clipBBox != null ? new BBox(\n        this.align(clipBBox.x),\n        this.align(clipBBox.y),\n        this.align(clipBBox.x, clipBBox.width),\n        this.align(clipBBox.y, clipBBox.height)\n      ) : void 0;\n    }\n    if (strokeWidth) {\n      if (w < pixelSize) {\n        const lx = x + pixelSize / 2;\n        borderPath.moveTo(lx, y);\n        borderPath.lineTo(lx, y + h);\n        strokeWidth = pixelSize;\n        this.borderClipPath = void 0;\n      } else if (h < pixelSize) {\n        const ly = y + pixelSize / 2;\n        borderPath.moveTo(x, ly);\n        borderPath.lineTo(x + w, ly);\n        strokeWidth = pixelSize;\n        this.borderClipPath = void 0;\n      } else if (strokeWidth < w && strokeWidth < h) {\n        const halfStrokeWidth = strokeWidth / 2;\n        x += halfStrokeWidth;\n        y += halfStrokeWidth;\n        w -= strokeWidth;\n        h -= strokeWidth;\n        const adjustedClipBBox = clipBBox?.clone().shrink(halfStrokeWidth);\n        const cornerRadii = {\n          topLeft: topLeft > 0 ? topLeft - strokeWidth : 0,\n          topRight: topRight > 0 ? topRight - strokeWidth : 0,\n          bottomRight: bottomRight > 0 ? bottomRight - strokeWidth : 0,\n          bottomLeft: bottomLeft > 0 ? bottomLeft - strokeWidth : 0\n        };\n        this.borderClipPath = void 0;\n        if (w > 0 && h > 0 && (adjustedClipBBox == null || adjustedClipBBox?.width > 0 && adjustedClipBBox?.height > 0)) {\n          insetCornerRadiusRect(path, x, y, w, h, cornerRadii, adjustedClipBBox);\n          insetCornerRadiusRect(borderPath, x, y, w, h, cornerRadii, adjustedClipBBox);\n        }\n      } else {\n        this.borderClipPath = this.borderClipPath ?? new ExtendedPath2D();\n        this.borderClipPath.clear(true);\n        this.borderClipPath.rect(x, y, w, h);\n        borderPath.rect(x, y, w, h);\n      }\n    } else {\n      const cornerRadii = { topLeft, topRight, bottomRight, bottomLeft };\n      this.borderClipPath = void 0;\n      insetCornerRadiusRect(path, x, y, w, h, cornerRadii, clipBBox);\n    }\n    if ([topLeft, topRight, bottomRight, bottomLeft].every((r) => r === 0)) {\n      const bbox = this.getBBox();\n      this.hittester = bbox.containsPoint.bind(bbox);\n      this.distanceSquared = (hitX, hitY) => this.getBBox().distanceSquared(hitX, hitY);\n    } else {\n      this.hittester = super.isPointInPath;\n      this.distanceCalculator = super.distanceSquaredTransformedPoint;\n    }\n    this.effectiveStrokeWidth = strokeWidth;\n    this.lastUpdatePathStrokeWidth = strokeWidth;\n    this.microPixelEffectOpacity = microPixelEffectOpacity;\n  }\n  computeBBox() {\n    const { x, y, width: width2, height: height2, clipBBox } = this;\n    return clipBBox?.clone() ?? new BBox(x, y, width2, height2);\n  }\n  isPointInPath(x, y) {\n    return this.hittester(x, y);\n  }\n  get midPoint() {\n    return { x: this.x + this.width / 2, y: this.y + this.height / 2 };\n  }\n  distanceSquared(x, y) {\n    return this.distanceCalculator(x, y);\n  }\n  applyFillAlpha(ctx) {\n    const { fillOpacity, microPixelEffectOpacity, opacity } = this;\n    ctx.globalAlpha *= opacity * fillOpacity * microPixelEffectOpacity;\n  }\n  renderStroke(ctx) {\n    const { stroke, effectiveStrokeWidth } = this;\n    if (stroke && effectiveStrokeWidth) {\n      const { globalAlpha } = ctx;\n      const {\n        strokeOpacity,\n        lineDash,\n        lineDashOffset,\n        lineCap,\n        lineJoin,\n        borderPath,\n        borderClipPath,\n        opacity,\n        microPixelEffectOpacity\n      } = this;\n      if (borderClipPath) {\n        ctx.clip(borderClipPath.getPath2D());\n      }\n      ctx.strokeStyle = stroke;\n      ctx.globalAlpha *= opacity * strokeOpacity * microPixelEffectOpacity;\n      ctx.lineWidth = effectiveStrokeWidth;\n      if (lineDash) {\n        ctx.setLineDash(lineDash);\n      }\n      if (lineDashOffset) {\n        ctx.lineDashOffset = lineDashOffset;\n      }\n      if (lineCap) {\n        ctx.lineCap = lineCap;\n      }\n      if (lineJoin) {\n        ctx.lineJoin = lineJoin;\n      }\n      ctx.stroke(borderPath.getPath2D());\n      ctx.globalAlpha = globalAlpha;\n    }\n  }\n};\nRect.className = \"Rect\";\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"x\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"y\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"width\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"height\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"topLeftCornerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"topRightCornerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"bottomRightCornerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"bottomLeftCornerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"clipBBox\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"crisp\", 2);\n\n// packages/ag-charts-community/src/chart/background/background.ts\nvar Background = class extends BaseModuleInstance {\n  constructor(ctx) {\n    super();\n    this.ctx = ctx;\n    this.rectNode = new Rect();\n    this.textNode = new Text();\n    this.fill = \"white\";\n    this.node = this.createNode();\n    this.node.append([this.rectNode, this.textNode]);\n    this.visible = true;\n    this.destroyFns.push(\n      ctx.scene.attachNode(this.node),\n      ctx.layoutManager.addListener(\"layout:complete\", (e) => this.onLayoutComplete(e))\n    );\n  }\n  createNode() {\n    return new Group({ name: \"background\", zIndex: 0 /* SERIES_BACKGROUND */ });\n  }\n  onLayoutComplete(e) {\n    const { width: width2, height: height2 } = e.chart;\n    this.rectNode.width = width2;\n    this.rectNode.height = height2;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN),\n  ProxyPropertyOnWrite(\"node\", \"visible\")\n], Background.prototype, \"visible\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true }),\n  ProxyPropertyOnWrite(\"rectNode\", \"fill\")\n], Background.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(OBJECT, { optional: true })\n], Background.prototype, \"image\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true }),\n  ProxyPropertyOnWrite(\"textNode\")\n], Background.prototype, \"text\", 2);\n\n// packages/ag-charts-community/src/chart/background/backgroundModule.ts\nvar BackgroundModule = {\n  type: \"root\",\n  optionsKey: \"background\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\", \"standalone\", \"gauge\"],\n  moduleFactory: (ctx) => new Background(ctx)\n};\n\n// packages/ag-charts-community/src/chart/gridLayout.ts\nfunction gridLayout({\n  orientation,\n  bboxes,\n  maxHeight,\n  maxWidth,\n  itemPaddingY = 0,\n  itemPaddingX = 0,\n  forceResult = false\n}) {\n  const horizontal = orientation === \"horizontal\";\n  const primary = {\n    max: horizontal ? maxWidth : maxHeight,\n    fn: horizontal ? (b) => b.width : (b) => b.height,\n    padding: horizontal ? itemPaddingX : itemPaddingY\n  };\n  const secondary = {\n    max: horizontal ? maxHeight : maxWidth,\n    fn: horizontal ? (b) => b.height : (b) => b.width,\n    padding: horizontal ? itemPaddingY : itemPaddingX\n  };\n  let processedBBoxCount = 0;\n  const rawPages = [];\n  while (processedBBoxCount < bboxes.length) {\n    const unprocessedBBoxes = bboxes.slice(processedBBoxCount);\n    const result = processBBoxes(unprocessedBBoxes, processedBBoxCount, primary, secondary, forceResult);\n    if (!result) {\n      return;\n    }\n    processedBBoxCount += result.processedBBoxCount;\n    rawPages.push(result.pageIndices);\n  }\n  return buildPages(rawPages, orientation, bboxes, itemPaddingY, itemPaddingX);\n}\nfunction processBBoxes(bboxes, indexOffset, primary, secondary, forceResult) {\n  const minGuess = 1;\n  let startingGuess = estimateStartingGuess(bboxes, primary);\n  if (startingGuess < minGuess) {\n    if (!forceResult) {\n      return;\n    }\n    startingGuess = minGuess;\n  }\n  let guess = startingGuess;\n  while (guess >= minGuess) {\n    const pageIndices = calculatePage(bboxes, indexOffset, guess, primary, secondary, forceResult);\n    if (pageIndices == null && guess <= minGuess) {\n      return;\n    }\n    if (pageIndices == null) {\n      guess--;\n      continue;\n    }\n    if (typeof pageIndices === \"number\") {\n      if (pageIndices <= minGuess) {\n        return;\n      }\n      guess = pageIndices < guess && pageIndices > minGuess ? pageIndices : guess;\n      guess--;\n      continue;\n    }\n    const processedBBoxCount = pageIndices.length * pageIndices[0].length;\n    return { processedBBoxCount, pageIndices };\n  }\n}\nfunction calculatePage(bboxes, indexOffset, primaryCount, primary, secondary, forceResult) {\n  const result = [];\n  let sumSecondary = 0;\n  let currentMaxSecondary = 0;\n  let currentPrimaryIndices = [];\n  const maxPrimaryValues = [];\n  for (let bboxIndex = 0; bboxIndex < bboxes.length; bboxIndex++) {\n    const primaryValueIdx = (bboxIndex + primaryCount) % primaryCount;\n    if (primaryValueIdx === 0) {\n      sumSecondary += currentMaxSecondary;\n      currentMaxSecondary = 0;\n      if (currentPrimaryIndices.length > 0) {\n        result.push(currentPrimaryIndices);\n      }\n      currentPrimaryIndices = [];\n    }\n    const primaryValue = primary.fn(bboxes[bboxIndex]) + primary.padding;\n    maxPrimaryValues[primaryValueIdx] = Math.max(maxPrimaryValues[primaryValueIdx] ?? 0, primaryValue);\n    currentMaxSecondary = Math.max(currentMaxSecondary, secondary.fn(bboxes[bboxIndex]) + secondary.padding);\n    const currentSecondaryDimension = sumSecondary + currentMaxSecondary;\n    const returnResult = !forceResult || result.length > 0;\n    if (currentSecondaryDimension > secondary.max && returnResult) {\n      currentPrimaryIndices = [];\n      break;\n    }\n    const sumPrimary = maxPrimaryValues.reduce((sum2, next) => sum2 + next, 0);\n    if (sumPrimary > primary.max && !forceResult) {\n      if (maxPrimaryValues.length < primaryCount) {\n        return maxPrimaryValues.length;\n      }\n      return;\n    }\n    currentPrimaryIndices.push(bboxIndex + indexOffset);\n  }\n  if (currentPrimaryIndices.length > 0) {\n    result.push(currentPrimaryIndices);\n  }\n  return result.length > 0 ? result : void 0;\n}\nfunction buildPages(rawPages, orientation, bboxes, itemPaddingY, itemPaddingX) {\n  let maxPageWidth = 0;\n  let maxPageHeight = 0;\n  const pages = rawPages.map((indices) => {\n    if (orientation === \"horizontal\") {\n      indices = transpose(indices);\n    }\n    let endIndex = 0;\n    const columns = indices.map((colIndices) => {\n      const colBBoxes = colIndices.map((bboxIndex) => {\n        endIndex = Math.max(bboxIndex, endIndex);\n        return bboxes[bboxIndex];\n      });\n      let columnHeight = 0;\n      let columnWidth = 0;\n      colBBoxes.forEach((bbox) => {\n        columnHeight += bbox.height + itemPaddingY;\n        columnWidth = Math.max(columnWidth, bbox.width + itemPaddingX);\n      });\n      return {\n        indices: colIndices,\n        bboxes: colBBoxes,\n        columnHeight: Math.ceil(columnHeight),\n        columnWidth: Math.ceil(columnWidth)\n      };\n    });\n    let pageWidth = 0;\n    let pageHeight = 0;\n    columns.forEach((column) => {\n      pageWidth += column.columnWidth;\n      pageHeight = Math.max(pageHeight, column.columnHeight);\n    });\n    maxPageWidth = Math.max(pageWidth, maxPageWidth);\n    maxPageHeight = Math.max(pageHeight, maxPageHeight);\n    return {\n      columns,\n      startIndex: indices[0][0],\n      endIndex,\n      pageWidth,\n      pageHeight\n    };\n  });\n  return { pages, maxPageWidth, maxPageHeight };\n}\nfunction transpose(data) {\n  const result = [];\n  for (const _ of data[0]) {\n    result.push([]);\n  }\n  data.forEach((innerData, dataIdx) => {\n    innerData.forEach((item, itemIdx) => {\n      result[itemIdx][dataIdx] = item;\n    });\n  });\n  return result;\n}\nfunction estimateStartingGuess(bboxes, primary) {\n  const n = bboxes.length;\n  let primarySum = 0;\n  for (let bboxIndex = 0; bboxIndex < n; bboxIndex++) {\n    primarySum += primary.fn(bboxes[bboxIndex]) + primary.padding;\n    if (primarySum > primary.max) {\n      const ratio2 = n / bboxIndex;\n      if (ratio2 < 2) {\n        return Math.ceil(n / 2);\n      }\n      return bboxIndex;\n    }\n  }\n  return n;\n}\n\n// packages/ag-charts-community/src/scene/image.ts\nvar Image = class extends Node {\n  constructor(sourceImage) {\n    super();\n    this.sourceImage = sourceImage;\n    this.x = 0;\n    this.y = 0;\n    this.width = 0;\n    this.height = 0;\n    this.opacity = 1;\n  }\n  updateBitmap(newBitmap, bitmapPixelRatio, x, y) {\n    this.sourceImage = newBitmap;\n    this.width = newBitmap.width / bitmapPixelRatio;\n    this.height = newBitmap.height / bitmapPixelRatio;\n    this.x = x / bitmapPixelRatio;\n    this.y = y / bitmapPixelRatio;\n    this.markDirty(3 /* MAJOR */);\n  }\n  render(renderCtx) {\n    const { ctx, forceRender, stats } = renderCtx;\n    if (this.dirty === 0 /* NONE */ && !forceRender) {\n      if (stats)\n        stats.nodesSkipped++;\n      return;\n    }\n    const image = this.sourceImage;\n    if (!image)\n      return;\n    ctx.globalAlpha = this.opacity;\n    ctx.drawImage(image, 0, 0, image.width, image.height, this.x, this.y, this.width, this.height);\n    super.render(renderCtx);\n  }\n};\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Image.prototype, \"x\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Image.prototype, \"y\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Image.prototype, \"width\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Image.prototype, \"height\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Image.prototype, \"opacity\", 2);\n\n// packages/ag-charts-community/src/chart/legendMarkerLabel.ts\nvar LegendMarkerLabel = class extends Translatable(Group) {\n  constructor() {\n    super({ name: \"markerLabelGroup\" });\n    this.label = new Text();\n    this.symbolsGroup = new Group({\n      name: \"legend-markerLabel-symbols\"\n    });\n    this.bitmap = new Image();\n    this.bitmapDirty = true;\n    this.enabled = true;\n    this.pageIndex = NaN;\n    this._markers = [];\n    this._lines = [];\n    const { markers, label, lines } = this;\n    label.textBaseline = \"middle\";\n    label.fontSize = 12;\n    label.fontFamily = \"Verdana, sans-serif\";\n    label.fill = \"black\";\n    label.y = 1;\n    this.updateSymbols(markers, lines);\n    this.append([this.symbolsGroup, label]);\n  }\n  destroy() {\n    super.destroy();\n    this.destroyProxyButton();\n  }\n  destroyProxyButton() {\n    this.proxyButton?.button.remove();\n    this.proxyButton?.listitem.remove();\n    this.proxyButton = void 0;\n  }\n  get markers() {\n    return this._markers;\n  }\n  get lines() {\n    return this._lines;\n  }\n  updateSymbols(markers, lines) {\n    if (arraysEqual(this._markers, markers) && arraysEqual(this._lines, lines))\n      return;\n    this.bitmapDirty = true;\n    this._markers = markers;\n    this._lines = lines;\n    this.symbolsGroup.clear();\n    this.symbolsGroup.append([this.bitmap, ...lines, ...markers]);\n  }\n  setEnabled(enabled) {\n    this.enabled = enabled;\n    this.refreshVisibilities();\n  }\n  refreshVisibilities() {\n    const opacity = this.enabled ? 1 : 0.5;\n    this.label.opacity = opacity;\n    this.opacity = opacity;\n    this.bitmap.opacity = opacity;\n    this.setBitmapVisibility(!this.enabled);\n  }\n  setBitmapVisibility(visible) {\n    const { lines, markers } = this;\n    [lines, markers].forEach((shapes) => shapes.forEach((shape) => shape.visible = !visible));\n    this.bitmap.visible = visible;\n  }\n  // The BBox of this.bitmap is `spritePadding` pixels bigger in each direction than BBox of the markers and lines.\n  // This padding allows the SpriteRenderer to draw antialiasing pixels that can extend beyond the shapes' bounds.\n  update(spriteRenderer, { spriteAAPadding, spritePixelRatio: scale2 }, dimensionProps) {\n    const { markers, lines } = this;\n    let spriteX = 0;\n    let spriteY = 0;\n    let shift = 0;\n    for (let i = 0; i < Math.max(markers.length, lines.length); i++) {\n      const { length: length2, spacing, isCustomMarker } = dimensionProps[i] ?? 0;\n      const marker = markers[i];\n      const line = lines[i];\n      const size = marker?.size ?? 0;\n      let lineTop = Infinity;\n      let lineX1 = Infinity;\n      let lineX2 = Infinity;\n      let markerTop = Infinity;\n      let markerLeft = Infinity;\n      if (marker) {\n        const center2 = marker.constructor.center;\n        const radius = (size + marker.strokeWidth) / 2;\n        if (isCustomMarker) {\n          marker.x = 0;\n          marker.y = 0;\n          marker.translationX = (center2.x - 0.5) * size + length2 / 2 + shift;\n          marker.translationY = (center2.y - 0.5) * size;\n          markerTop = marker.translationY - radius;\n          markerLeft = marker.translationX - radius;\n        } else {\n          marker.x = (center2.x - 0.5) * size + length2 / 2 + shift;\n          marker.y = (center2.y - 0.5) * size;\n          markerTop = marker.y - radius;\n          markerLeft = marker.x - radius;\n        }\n      }\n      if (line) {\n        line.x1 = shift;\n        line.x2 = shift + length2;\n        line.y1 = 0;\n        line.y2 = 0;\n        line.markDirty(3 /* MAJOR */);\n        lineTop = -line.strokeWidth / 2;\n        lineX1 = line.x1;\n        lineX2 = line.x2;\n      }\n      shift += spacing + Math.max(length2, size);\n      spriteX = Math.min(spriteX, lineX1, lineX2, markerLeft);\n      spriteY = Math.min(spriteY, lineTop, markerTop);\n    }\n    const lastSymbolProps = dimensionProps.at(-1);\n    const lastLine = this.lines.at(-1);\n    const lastMarker = this.markers.at(-1);\n    const lineEnd = lastLine ? lastLine.x2 : -Infinity;\n    const markerEnd = (lastMarker?.x ?? 0) + (lastMarker?.size ?? 0) / 2;\n    this.label.x = Math.max(lineEnd, markerEnd) + (lastSymbolProps?.spacing ?? 0);\n    if (this.bitmapDirty) {\n      this.setBitmapVisibility(false);\n      const translateX = (spriteAAPadding + spriteX) * scale2;\n      const translateY = (spriteAAPadding - spriteY) * scale2;\n      const sprite = spriteRenderer.renderSprite(this.symbolsGroup, {\n        scale: scale2,\n        translateX: Math.floor(translateX),\n        translateY: Math.floor(translateY)\n      });\n      this.bitmap.updateBitmap(sprite, scale2, Math.ceil(-translateX), Math.ceil(-translateY));\n      this.bitmapDirty = false;\n      this.refreshVisibilities();\n    }\n    if (dimensionProps.length < 2) {\n      return;\n    }\n    const bbox = this.symbolsGroup.getBBox();\n    const clippedWidth = Math.max(lastMarker?.size ?? 0, lastSymbolProps?.length ?? 0);\n    const clipRect = new BBox(bbox.x + clippedWidth / 2, bbox.y, clippedWidth, bbox.height);\n    this.symbolsGroup.setClipRect(clipRect);\n  }\n  computeBBox() {\n    const { label, lines, markers } = this;\n    return this.toParent(Group.computeChildrenBBox(iterate([label], lines, markers), false));\n  }\n};\nLegendMarkerLabel.className = \"MarkerLabel\";\n__decorateClass([\n  ProxyPropertyOnWrite(\"label\")\n], LegendMarkerLabel.prototype, \"text\", 2);\n__decorateClass([\n  ProxyPropertyOnWrite(\"label\")\n], LegendMarkerLabel.prototype, \"fontStyle\", 2);\n__decorateClass([\n  ProxyPropertyOnWrite(\"label\")\n], LegendMarkerLabel.prototype, \"fontWeight\", 2);\n__decorateClass([\n  ProxyPropertyOnWrite(\"label\")\n], LegendMarkerLabel.prototype, \"fontSize\", 2);\n__decorateClass([\n  ProxyPropertyOnWrite(\"label\")\n], LegendMarkerLabel.prototype, \"fontFamily\", 2);\n__decorateClass([\n  ProxyPropertyOnWrite(\"label\", \"fill\")\n], LegendMarkerLabel.prototype, \"color\", 2);\n\n// packages/ag-charts-community/src/chart/pagination/pagination.ts\nvar PaginationLabel = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.color = \"black\";\n    this.fontStyle = void 0;\n    this.fontWeight = void 0;\n    this.fontSize = 12;\n    this.fontFamily = \"Verdana, sans-serif\";\n  }\n};\n__decorateClass([\n  Validate(COLOR_STRING)\n], PaginationLabel.prototype, \"color\", 2);\n__decorateClass([\n  Validate(FONT_STYLE, { optional: true })\n], PaginationLabel.prototype, \"fontStyle\", 2);\n__decorateClass([\n  Validate(FONT_WEIGHT, { optional: true })\n], PaginationLabel.prototype, \"fontWeight\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PaginationLabel.prototype, \"fontSize\", 2);\n__decorateClass([\n  Validate(STRING)\n], PaginationLabel.prototype, \"fontFamily\", 2);\nvar PaginationMarkerStyle = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.size = 15;\n    this.fill = void 0;\n    this.fillOpacity = void 0;\n    this.stroke = void 0;\n    this.strokeWidth = 1;\n    this.strokeOpacity = 1;\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PaginationMarkerStyle.prototype, \"size\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], PaginationMarkerStyle.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], PaginationMarkerStyle.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], PaginationMarkerStyle.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PaginationMarkerStyle.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO)\n], PaginationMarkerStyle.prototype, \"strokeOpacity\", 2);\nvar PaginationMarker = class extends BaseProperties {\n  constructor(parent) {\n    super();\n    this.parent = parent;\n    this.shape = Triangle;\n    this.size = 15;\n    this.padding = 8;\n  }\n};\n__decorateClass([\n  ActionOnSet({\n    changeValue() {\n      if (this.parent.marker === this) {\n        this.parent.onMarkerShapeChange();\n      }\n    }\n  })\n], PaginationMarker.prototype, \"shape\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PaginationMarker.prototype, \"size\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PaginationMarker.prototype, \"padding\", 2);\nvar Pagination = class extends BaseProperties {\n  constructor(chartUpdateCallback, pageUpdateCallback) {\n    super();\n    this.chartUpdateCallback = chartUpdateCallback;\n    this.pageUpdateCallback = pageUpdateCallback;\n    this.id = createId(this);\n    this.marker = new PaginationMarker(this);\n    this.activeStyle = new PaginationMarkerStyle();\n    this.inactiveStyle = new PaginationMarkerStyle();\n    this.highlightStyle = new PaginationMarkerStyle();\n    this.label = new PaginationLabel();\n    this.group = new TranslatableGroup({ name: \"pagination\" });\n    this.labelNode = new Text();\n    this.destroyFns = [];\n    this.totalPages = 0;\n    this.currentPage = 0;\n    this.translationX = 0;\n    this.translationY = 0;\n    this.nextButtonDisabled = false;\n    this.previousButtonDisabled = false;\n    this._visible = true;\n    this._enabled = true;\n    this._orientation = \"vertical\";\n    this._nextButton = new Triangle();\n    this._previousButton = new Triangle();\n    this.labelNode.setProperties({\n      textBaseline: \"middle\",\n      fontSize: 12,\n      fontFamily: \"Verdana, sans-serif\",\n      fill: \"black\",\n      y: 1\n    });\n    this.group.append([this.nextButton, this.previousButton, this.labelNode]);\n    this.update();\n    this.updateMarkers();\n  }\n  destroy() {\n    this.destroyFns.forEach((f) => f());\n  }\n  set visible(value) {\n    this._visible = value;\n    this.updateGroupVisibility();\n  }\n  get visible() {\n    return this._visible;\n  }\n  set enabled(value) {\n    this._enabled = value;\n    this.updateGroupVisibility();\n  }\n  get enabled() {\n    return this._enabled;\n  }\n  updateGroupVisibility() {\n    this.group.visible = this.enabled && this.visible;\n  }\n  set orientation(value) {\n    this._orientation = value;\n    switch (value) {\n      case \"horizontal\": {\n        this.previousButton.rotation = -Math.PI / 2;\n        this.nextButton.rotation = Math.PI / 2;\n        break;\n      }\n      case \"vertical\":\n      default: {\n        this.previousButton.rotation = 0;\n        this.nextButton.rotation = Math.PI;\n      }\n    }\n  }\n  get orientation() {\n    return this._orientation;\n  }\n  set nextButton(value) {\n    if (this._nextButton !== value) {\n      this.group.removeChild(this._nextButton);\n      this._nextButton = value;\n      this.group.appendChild(value);\n    }\n  }\n  get nextButton() {\n    return this._nextButton;\n  }\n  set previousButton(value) {\n    if (this._previousButton !== value) {\n      this.group.removeChild(this._previousButton);\n      this._previousButton = value;\n      this.group.appendChild(value);\n    }\n  }\n  get previousButton() {\n    return this._previousButton;\n  }\n  update() {\n    this.updateLabel();\n    this.updatePositions();\n    this.enableOrDisableButtons();\n  }\n  updatePositions() {\n    this.group.translationX = this.translationX;\n    this.group.translationY = this.translationY;\n    this.updateLabelPosition();\n    this.updateNextButtonPosition();\n  }\n  updateLabelPosition() {\n    const { size: markerSize, padding: markerPadding } = this.marker;\n    this.nextButton.size = markerSize;\n    this.previousButton.size = markerSize;\n    this.labelNode.x = markerSize / 2 + markerPadding;\n  }\n  updateNextButtonPosition() {\n    const labelBBox = this.labelNode.getBBox();\n    this.nextButton.translationX = labelBBox.width + (this.marker.size / 2 + this.marker.padding) * 2;\n  }\n  updateLabel() {\n    const {\n      currentPage,\n      totalPages: pages,\n      labelNode,\n      label: { color, fontStyle, fontWeight, fontSize, fontFamily }\n    } = this;\n    labelNode.text = `${currentPage + 1} / ${pages}`;\n    labelNode.fill = color;\n    labelNode.fontStyle = fontStyle;\n    labelNode.fontWeight = fontWeight;\n    labelNode.fontSize = fontSize;\n    labelNode.fontFamily = fontFamily;\n  }\n  updateMarkers() {\n    const {\n      nextButton,\n      previousButton,\n      nextButtonDisabled,\n      previousButtonDisabled,\n      activeStyle,\n      inactiveStyle,\n      highlightStyle,\n      highlightActive\n    } = this;\n    const buttonStyle = (button, disabled) => {\n      if (disabled) {\n        return inactiveStyle;\n      } else if (button === highlightActive) {\n        return highlightStyle;\n      }\n      return activeStyle;\n    };\n    this.updateMarker(nextButton, buttonStyle(\"next\", nextButtonDisabled));\n    this.updateMarker(previousButton, buttonStyle(\"previous\", previousButtonDisabled));\n  }\n  updateMarker(marker, style) {\n    const { size } = this.marker;\n    marker.size = size;\n    marker.fill = style.fill;\n    marker.fillOpacity = style.fillOpacity ?? 1;\n    marker.stroke = style.stroke;\n    marker.strokeWidth = style.strokeWidth;\n    marker.strokeOpacity = style.strokeOpacity;\n  }\n  enableOrDisableButtons() {\n    const { currentPage, totalPages } = this;\n    const zeroPagesToDisplay = totalPages === 0;\n    const onLastPage = currentPage === totalPages - 1;\n    const onFirstPage = currentPage === 0;\n    this.nextButtonDisabled = onLastPage || zeroPagesToDisplay;\n    this.previousButtonDisabled = onFirstPage || zeroPagesToDisplay;\n  }\n  setPage(pageNumber) {\n    pageNumber = clamp(0, pageNumber, this.totalPages - 1);\n    if (this.currentPage !== pageNumber) {\n      this.currentPage = pageNumber;\n      this.onPaginationChanged();\n    }\n  }\n  getCursor(node) {\n    return { previous: this.previousButtonDisabled, next: this.nextButtonDisabled }[node] ? void 0 : \"pointer\";\n  }\n  onClick(event, node) {\n    event.preventDefault();\n    if (node === \"next\" && !this.nextButtonDisabled) {\n      this.incrementPage();\n      this.onPaginationChanged();\n    } else if (node === \"previous\" && !this.previousButtonDisabled) {\n      this.decrementPage();\n      this.onPaginationChanged();\n    }\n  }\n  onMouseHover(node) {\n    this.highlightActive = node;\n    this.updateMarkers();\n    this.chartUpdateCallback(6 /* SCENE_RENDER */);\n  }\n  onPaginationChanged() {\n    this.pageUpdateCallback(this.currentPage);\n  }\n  incrementPage() {\n    this.currentPage = Math.min(this.currentPage + 1, this.totalPages - 1);\n  }\n  decrementPage() {\n    this.currentPage = Math.max(this.currentPage - 1, 0);\n  }\n  onMarkerShapeChange() {\n    const Marker2 = Rotatable(getMarker(this.marker.shape || Triangle));\n    this.previousButton = new Marker2();\n    this.nextButton = new Marker2();\n    this.updatePositions();\n    this.updateMarkers();\n    this.chartUpdateCallback(6 /* SCENE_RENDER */);\n  }\n  attachPagination(node) {\n    node.append(this.group);\n  }\n  getBBox() {\n    return this.group.getBBox();\n  }\n  computeCSSBounds() {\n    const prev = Transformable.toCanvas(this.previousButton);\n    const next = Transformable.toCanvas(this.nextButton);\n    return { prev, next };\n  }\n};\nPagination.className = \"Pagination\";\n__decorateClass([\n  Validate(OBJECT)\n], Pagination.prototype, \"marker\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Pagination.prototype, \"activeStyle\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Pagination.prototype, \"inactiveStyle\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Pagination.prototype, \"highlightStyle\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Pagination.prototype, \"label\", 2);\n\n// packages/ag-charts-community/src/chart/legend.ts\nvar LegendLabel = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.maxLength = void 0;\n    this.color = \"black\";\n    this.fontStyle = void 0;\n    this.fontWeight = void 0;\n    this.fontSize = 12;\n    this.fontFamily = \"Verdana, sans-serif\";\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], LegendLabel.prototype, \"maxLength\", 2);\n__decorateClass([\n  Validate(COLOR_STRING)\n], LegendLabel.prototype, \"color\", 2);\n__decorateClass([\n  Validate(FONT_STYLE, { optional: true })\n], LegendLabel.prototype, \"fontStyle\", 2);\n__decorateClass([\n  Validate(FONT_WEIGHT, { optional: true })\n], LegendLabel.prototype, \"fontWeight\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], LegendLabel.prototype, \"fontSize\", 2);\n__decorateClass([\n  Validate(STRING)\n], LegendLabel.prototype, \"fontFamily\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], LegendLabel.prototype, \"formatter\", 2);\nvar LegendMarker = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.size = 15;\n    this.padding = 8;\n  }\n};\n__decorateClass([\n  ObserveChanges((target) => target.parent?.onMarkerShapeChange())\n], LegendMarker.prototype, \"shape\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], LegendMarker.prototype, \"size\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], LegendMarker.prototype, \"padding\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], LegendMarker.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], LegendMarker.prototype, \"enabled\", 2);\nvar LegendLine = class extends BaseProperties {\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], LegendLine.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], LegendLine.prototype, \"length\", 2);\nvar LegendItem = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.paddingX = 16;\n    this.paddingY = 8;\n    this.showSeriesStroke = false;\n    this.marker = new LegendMarker();\n    this.label = new LegendLabel();\n    this.line = new LegendLine();\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], LegendItem.prototype, \"maxWidth\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], LegendItem.prototype, \"paddingX\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], LegendItem.prototype, \"paddingY\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], LegendItem.prototype, \"showSeriesStroke\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], LegendItem.prototype, \"marker\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], LegendItem.prototype, \"label\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], LegendItem.prototype, \"line\", 2);\nvar LegendListeners = class extends BaseProperties {\n};\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], LegendListeners.prototype, \"legendItemClick\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], LegendListeners.prototype, \"legendItemDoubleClick\", 2);\nvar ID_LEGEND_VISIBILITY = \"legend-visibility\";\nvar ID_LEGEND_OTHER_SERIES = \"legend-other-series\";\nvar LegendItemEvent = class {\n  constructor(type, enabled, itemId, seriesId, event) {\n    this.type = type;\n    this.enabled = enabled;\n    this.itemId = itemId;\n    this.seriesId = seriesId;\n    this.event = event;\n    this.defaultPrevented = false;\n  }\n  preventDefault() {\n    this.defaultPrevented = true;\n  }\n};\nvar Legend = class extends BaseProperties {\n  constructor(ctx) {\n    super();\n    this.ctx = ctx;\n    this.id = createId(this);\n    this.group = new TranslatableLayer({ name: \"legend\", zIndex: 15 /* LEGEND */ });\n    this.itemSelection = Selection.select(\n      this.group,\n      LegendMarkerLabel\n    );\n    this.spriteRenderer = void 0;\n    this.oldSize = [0, 0];\n    this.pages = [];\n    this.maxPageSize = [0, 0];\n    /** Item index to track on re-pagination, so current page updates appropriately. */\n    this.paginationTrackingIndex = 0;\n    this.truncatedItems = /* @__PURE__ */ new Set();\n    this._data = [];\n    this._symbolsDirty = true;\n    this.toggleSeries = true;\n    this.item = new LegendItem();\n    this.listeners = new LegendListeners();\n    this.enabled = true;\n    this.position = \"bottom\";\n    this.spacing = 20;\n    this.destroyFns = [];\n    this.proxyLegendDirty = true;\n    this.proxyLegendToolbarDestroyFns = new DestroyFns();\n    this.size = [0, 0];\n    this._visible = true;\n    this.item.marker.parent = this;\n    this.pagination = new Pagination(\n      (type) => ctx.updateService.update(type),\n      (page) => this.updatePageNumber(page)\n    );\n    this.pagination.attachPagination(this.group);\n    this.destroyFns.push(\n      ctx.contextMenuRegistry.registerDefaultAction({\n        id: ID_LEGEND_VISIBILITY,\n        type: \"legend\",\n        label: \"contextMenuToggleSeriesVisibility\",\n        action: (params) => this.contextToggleVisibility(params)\n      }),\n      ctx.contextMenuRegistry.registerDefaultAction({\n        id: ID_LEGEND_OTHER_SERIES,\n        type: \"legend\",\n        label: \"contextMenuToggleOtherSeries\",\n        action: (params) => this.contextToggleOtherSeries(params)\n      })\n    );\n    this.destroyFns.push(\n      ctx.layoutManager.registerElement(1 /* Legend */, (e) => this.positionLegend(e)),\n      ctx.localeManager.addListener(\"locale-changed\", () => this.onLocaleChanged()),\n      () => this.group.remove()\n    );\n    this.proxyLegendToolbar = this.ctx.proxyInteractionService.createProxyContainer({\n      type: \"list\",\n      id: `${this.id}-toolbar`,\n      classList: [\"ag-charts-proxy-legend-toolbar\"],\n      ariaLabel: { id: \"ariaLabelLegend\" },\n      ariaHidden: true\n    });\n    this.proxyLegendPagination = this.ctx.proxyInteractionService.createProxyContainer({\n      type: \"group\",\n      id: `${this.id}-pagination`,\n      classList: [\"ag-charts-proxy-legend-pagination\"],\n      ariaLabel: { id: \"ariaLabelLegendPagination\" },\n      ariaOrientation: \"horizontal\",\n      ariaHidden: true\n    });\n    this.proxyLegendItemDescription = createElement(\"p\");\n    this.proxyLegendItemDescription.style.display = \"none\";\n    this.proxyLegendItemDescription.id = `${this.id}-ariaDescription`;\n    this.proxyLegendItemDescription.textContent = this.getItemAriaDescription();\n    this.proxyLegendToolbar.append(this.proxyLegendItemDescription);\n  }\n  set data(value) {\n    this.onDataUpdate(this._data, value);\n    this._data = value;\n    this._symbolsDirty = true;\n    this.updateGroupVisibility();\n  }\n  get data() {\n    return this._data;\n  }\n  destroy() {\n    this.ctx.domManager.removeChild(\"canvas-overlay\", `${this.id}-toolbar`);\n    this.ctx.domManager.removeChild(\"canvas-overlay\", `${this.id}-pagination`);\n    this.destroyFns.forEach((f) => f());\n    this.pagination.destroy();\n    this.itemSelection.clear();\n    this.proxyLegendToolbarDestroyFns.destroy();\n  }\n  initLegendItemToolbar() {\n    if (!this.proxyLegendDirty)\n      return;\n    this.itemSelection.each((markerLabel, _, i) => {\n      markerLabel.destroyProxyButton();\n      markerLabel.proxyButton ?? (markerLabel.proxyButton = this.ctx.proxyInteractionService.createProxyElement({\n        type: \"listswitch\",\n        id: `ag-charts-legend-item-${i}`,\n        textContent: this.getItemAriaText(i),\n        ariaChecked: !!markerLabel.datum.enabled,\n        ariaDescribedBy: this.proxyLegendItemDescription.id,\n        parent: this.proxyLegendToolbar,\n        // Retrieve the datum from the node rather than from the method parameter.\n        // The method parameter `datum` gets destroyed when the data is refreshed\n        // using Series.getLegendData(). But the scene node will stay the same.\n        onclick: (ev) => this.onClick(ev, markerLabel.datum, markerLabel.proxyButton.button),\n        ondblclick: (ev) => this.onDoubleClick(ev, markerLabel.datum),\n        onmouseenter: (ev) => this.onHover(ev, markerLabel),\n        onmouseleave: () => this.onLeave(),\n        oncontextmenu: (ev) => this.onContextClick(ev, markerLabel),\n        onblur: () => this.onLeave(),\n        onfocus: (ev) => this.onHover(ev, markerLabel)\n      }));\n    });\n    const buttons = this.itemSelection.nodes().map((markerLabel) => markerLabel.proxyButton?.button).filter(isDefined);\n    this.proxyLegendToolbarDestroyFns.setFns([\n      ...initRovingTabIndex({ orientation: \"horizontal\", buttons }),\n      ...initRovingTabIndex({ orientation: \"vertical\", buttons })\n    ]);\n    this.proxyLegendToolbar.ariaHidden = (buttons.length === 0).toString();\n    this.proxyLegendDirty = false;\n  }\n  onDataUpdate(oldData, newData) {\n    this.proxyLegendDirty = oldData.length !== newData.length || oldData.some((_v, index, _a) => {\n      const [newValue, oldValue] = [newData[index], oldData[index]];\n      return newValue.id !== oldValue.id;\n    });\n  }\n  onMarkerShapeChange() {\n    this.itemSelection.clear();\n    this.group.markDirty(2 /* MINOR */);\n  }\n  getOrientation() {\n    if (this.orientation !== void 0) {\n      return this.orientation;\n    }\n    switch (this.position) {\n      case \"right\":\n      case \"left\":\n        return \"vertical\";\n      case \"bottom\":\n      case \"top\":\n        return \"horizontal\";\n    }\n  }\n  set visible(value) {\n    this._visible = value;\n    this.updateGroupVisibility();\n  }\n  get visible() {\n    return this._visible;\n  }\n  updateGroupVisibility() {\n    this.group.visible = this.enabled && this.visible && this.data.length > 0;\n  }\n  attachLegend(scene) {\n    scene.appendChild(this.group);\n  }\n  getItemLabel(datum) {\n    const {\n      ctx: { callbackCache }\n    } = this;\n    const { formatter } = this.item.label;\n    if (formatter) {\n      return callbackCache.call(formatter, {\n        itemId: datum.itemId,\n        value: datum.label.text,\n        seriesId: datum.seriesId\n      });\n    }\n    return datum.label.text;\n  }\n  /**\n   * The method is given the desired size of the legend, which only serves as a hint.\n   * The vertically oriented legend will take as much horizontal space as needed, but will\n   * respect the height constraints, and the horizontal legend will take as much vertical\n   * space as needed in an attempt not to exceed the given width.\n   * After the layout is done, the {@link size} will contain the actual size of the legend.\n   * If the actual size is not the same as the previous actual size, the legend will fire\n   * the 'layoutChange' event to communicate that another layout is needed, and the above\n   * process should be repeated.\n   * @param width\n   * @param height\n   */\n  calcLayout(width2, height2) {\n    const {\n      paddingX,\n      paddingY,\n      label,\n      maxWidth,\n      label: { maxLength = Infinity, fontStyle, fontWeight, fontSize, fontFamily }\n    } = this.item;\n    const data = [...this.data];\n    if (this.reverseOrder) {\n      data.reverse();\n    }\n    this.itemSelection.update(data);\n    this.initLegendItemToolbar();\n    const bboxes = [];\n    const font = TextUtils.toFontString(label);\n    const itemMaxWidthPercentage = 0.8;\n    const maxItemWidth = maxWidth ?? width2 * itemMaxWidthPercentage;\n    const spriteDims = this.calculateSpriteDimensions();\n    this.spriteRenderer ?? (this.spriteRenderer = new SpriteRenderer());\n    this.spriteRenderer.resize(spriteDims);\n    this.itemSelection.each((markerLabel, datum) => {\n      markerLabel.fontStyle = fontStyle;\n      markerLabel.fontWeight = fontWeight;\n      markerLabel.fontSize = fontSize;\n      markerLabel.fontFamily = fontFamily;\n      const paddedSymbolWidth = this.updateMarkerLabel(this.spriteRenderer, markerLabel, datum, spriteDims);\n      const id = datum.itemId ?? datum.id;\n      const labelText = this.getItemLabel(datum);\n      const text = (labelText ?? \"<unknown>\").replace(/\\r?\\n/g, \" \");\n      markerLabel.text = this.truncate(text, maxLength, maxItemWidth, paddedSymbolWidth, font, id);\n      bboxes.push(markerLabel.getBBox());\n    });\n    this._symbolsDirty = false;\n    width2 = Math.max(1, width2);\n    height2 = Math.max(1, height2);\n    if (!isFinite(width2)) {\n      return {};\n    }\n    const size = this.size;\n    const oldSize = this.oldSize;\n    size[0] = width2;\n    size[1] = height2;\n    if (size[0] !== oldSize[0] || size[1] !== oldSize[1]) {\n      oldSize[0] = size[0];\n      oldSize[1] = size[1];\n    }\n    const { pages, maxPageHeight, maxPageWidth } = this.updatePagination(bboxes, width2, height2);\n    const oldPages = this.pages;\n    this.pages = pages;\n    this.maxPageSize = [maxPageWidth - paddingX, maxPageHeight - paddingY];\n    const pageNumber = this.pagination.currentPage;\n    const page = this.pages[pageNumber];\n    if (this.pages.length < 1 || !page) {\n      this.visible = false;\n      return { oldPages };\n    }\n    this.visible = true;\n    this.updatePositions(pageNumber);\n    this.update();\n    return { oldPages };\n  }\n  isCustomMarker(markerEnabled, shape) {\n    return markerEnabled && shape !== void 0 && typeof shape !== \"string\";\n  }\n  calcSymbolsEnabled(symbol) {\n    const { showSeriesStroke, marker } = this.item;\n    const markerEnabled = !!marker.enabled || !showSeriesStroke || (symbol.marker.enabled ?? true);\n    const lineEnabled = !!(symbol.line && showSeriesStroke);\n    const isCustomMarker = this.isCustomMarker(markerEnabled, symbol.marker.shape);\n    return { markerEnabled, lineEnabled, isCustomMarker };\n  }\n  calcSymbolsLengths(symbol) {\n    const { marker, line } = this.item;\n    const { markerEnabled, lineEnabled } = this.calcSymbolsEnabled(symbol);\n    const { strokeWidth: markerStrokeWidth } = this.getMarkerStyles(symbol);\n    const { strokeWidth: lineStrokeWidth } = lineEnabled ? this.getLineStyles(symbol) : { strokeWidth: 0 };\n    let customMarkerSize;\n    const { shape } = symbol.marker;\n    if (this.isCustomMarker(markerEnabled, shape)) {\n      const tmpShape = new shape();\n      tmpShape.updatePath();\n      const bbox = tmpShape.getBBox();\n      customMarkerSize = Math.max(bbox.width, bbox.height);\n    }\n    const markerLength = markerEnabled ? marker.size : 0;\n    const lineLength = lineEnabled ? line.length ?? 25 : 0;\n    return { markerLength, markerStrokeWidth, lineLength, lineStrokeWidth, customMarkerSize };\n  }\n  calculateSpriteDimensions() {\n    let spriteAAPadding = 0;\n    let spriteWidth = 0;\n    let spriteHeight = 0;\n    let markerWidth = 0;\n    this.itemSelection.each((_, datum) => {\n      datum.symbols.forEach((symbol) => {\n        const {\n          markerLength,\n          markerStrokeWidth,\n          lineLength,\n          lineStrokeWidth,\n          customMarkerSize = -Infinity\n        } = this.calcSymbolsLengths(symbol);\n        const markerTotalLength = markerLength + markerStrokeWidth;\n        markerWidth = Math.max(markerWidth, lineLength, customMarkerSize, markerLength);\n        spriteWidth = Math.max(spriteWidth, lineLength, customMarkerSize, markerTotalLength);\n        spriteHeight = Math.max(spriteHeight, lineStrokeWidth, markerTotalLength);\n        spriteAAPadding = Math.max(spriteAAPadding, markerStrokeWidth + 0.5);\n      });\n    });\n    spriteWidth += spriteAAPadding * 2;\n    spriteHeight += spriteAAPadding * 2;\n    const spritePixelRatio = getWindow().devicePixelRatio;\n    return { spritePixelRatio, spriteAAPadding, spriteWidth, spriteHeight, markerWidth };\n  }\n  updateMarkerLabel(spriteRenderer, markerLabel, datum, spriteDims) {\n    const { marker: itemMarker, paddingX } = this.item;\n    const { markerWidth } = spriteDims;\n    const dimensionProps = [];\n    let paddedSymbolWidth = paddingX;\n    if (this._symbolsDirty) {\n      const markers = [];\n      const lines = [];\n      datum.symbols.forEach((symbol) => {\n        const { shape: markerShape = symbol.marker.shape } = itemMarker;\n        const MarkerCtr = getMarker(markerShape);\n        lines.push(new Line({ zIndex: 0 }));\n        markers.push(new MarkerCtr({ zIndex: 1 }));\n      });\n      markerLabel.updateSymbols(markers, lines);\n    }\n    datum.symbols.forEach((symbol, i) => {\n      const spacing = symbol.marker.padding ?? itemMarker.padding;\n      const { markerEnabled, lineEnabled, isCustomMarker } = this.calcSymbolsEnabled(symbol);\n      markerLabel.markers[i].size = markerEnabled || !lineEnabled ? itemMarker.size : 0;\n      dimensionProps.push({ length: markerWidth, spacing, isCustomMarker });\n      if (markerEnabled || lineEnabled) {\n        paddedSymbolWidth += spacing + markerWidth;\n      }\n      const marker = markerLabel.markers[i];\n      const line = markerLabel.lines[i];\n      if (marker) {\n        const { strokeWidth, fill, stroke, fillOpacity, strokeOpacity } = this.getMarkerStyles(symbol);\n        marker.fill = fill;\n        marker.stroke = stroke;\n        marker.strokeWidth = strokeWidth;\n        marker.fillOpacity = fillOpacity;\n        marker.strokeOpacity = strokeOpacity;\n      }\n      if (line) {\n        const lineStyles = this.getLineStyles(symbol);\n        line.stroke = lineStyles.stroke;\n        line.strokeOpacity = lineStyles.strokeOpacity;\n        line.strokeWidth = lineStyles.strokeWidth;\n        line.lineDash = lineStyles.lineDash;\n      }\n    });\n    markerLabel.update(spriteRenderer, spriteDims, dimensionProps);\n    return paddedSymbolWidth;\n  }\n  truncate(text, maxCharLength, maxItemWidth, paddedMarkerWidth, font, id) {\n    let addEllipsis = false;\n    if (text.length > maxCharLength) {\n      text = text.substring(0, maxCharLength);\n      addEllipsis = true;\n    }\n    const measurer = CachedTextMeasurerPool.getMeasurer({ font });\n    const result = TextWrapper.truncateLine(text, measurer, maxItemWidth - paddedMarkerWidth, addEllipsis);\n    if (result.endsWith(TextUtils.EllipsisChar)) {\n      this.truncatedItems.add(id);\n    } else {\n      this.truncatedItems.delete(id);\n    }\n    return result;\n  }\n  updatePagination(bboxes, width2, height2) {\n    const orientation = this.getOrientation();\n    const trackingIndex = Math.min(this.paginationTrackingIndex, bboxes.length);\n    this.pagination.orientation = orientation;\n    this.pagination.translationX = 0;\n    this.pagination.translationY = 0;\n    const { pages, maxPageHeight, maxPageWidth, paginationBBox, paginationVertical } = this.calculatePagination(\n      bboxes,\n      width2,\n      height2\n    );\n    const newCurrentPage = pages.findIndex((p) => p.endIndex >= trackingIndex);\n    this.pagination.currentPage = clamp(0, newCurrentPage, pages.length - 1);\n    const { paddingX: itemPaddingX, paddingY: itemPaddingY } = this.item;\n    const paginationComponentPadding = 8;\n    const legendItemsWidth = maxPageWidth - itemPaddingX;\n    const legendItemsHeight = maxPageHeight - itemPaddingY;\n    let paginationX = 0;\n    let paginationY = -paginationBBox.y - this.item.marker.size / 2;\n    if (paginationVertical) {\n      paginationY += legendItemsHeight + paginationComponentPadding;\n    } else {\n      paginationX += -paginationBBox.x + legendItemsWidth + paginationComponentPadding;\n      paginationY += (legendItemsHeight - paginationBBox.height) / 2;\n    }\n    this.pagination.translationX = paginationX;\n    this.pagination.translationY = paginationY;\n    this.pagination.update();\n    this.pagination.updateMarkers();\n    let pageIndex = 0;\n    this.itemSelection.each((markerLabel, _, nodeIndex) => {\n      if (nodeIndex > (pages[pageIndex]?.endIndex ?? Infinity)) {\n        pageIndex++;\n      }\n      markerLabel.pageIndex = pageIndex;\n    });\n    return {\n      maxPageHeight,\n      maxPageWidth,\n      pages\n    };\n  }\n  updateItemProxyButtons() {\n    const pointer = this.toggleSeries ? \"pointer\" : void 0;\n    const maxHeight = Math.max(...this.itemSelection.nodes().map((l) => l.getBBox().height));\n    this.itemSelection.each((l) => {\n      if (l.proxyButton) {\n        const { listitem, button } = l.proxyButton;\n        const visible = l.pageIndex === this.pagination.currentPage;\n        let bbox = Transformable.toCanvas(l);\n        if (bbox.height !== maxHeight) {\n          const margin = (maxHeight - bbox.height) / 2;\n          bbox = { x: bbox.x, y: bbox.y - margin, height: maxHeight, width: bbox.width };\n        }\n        setElementStyle(button, \"pointer-events\", visible ? \"auto\" : \"none\");\n        setElementStyle(button, \"cursor\", pointer);\n        setElementBBox(listitem, bbox);\n      }\n    });\n  }\n  updatePaginationProxyButtons(oldPages) {\n    this.proxyLegendPagination.style.display = this.pagination.visible ? \"absolute\" : \"none\";\n    const oldNeedsButtons = (oldPages?.length ?? this.pages.length) > 1;\n    const newNeedsButtons = this.pages.length > 1;\n    if (oldNeedsButtons !== newNeedsButtons) {\n      if (newNeedsButtons) {\n        this.proxyPrevButton = this.ctx.proxyInteractionService.createProxyElement({\n          type: \"button\",\n          id: `${this.id}-prev-page`,\n          textContent: { id: \"ariaLabelLegendPagePrevious\" },\n          tabIndex: 0,\n          parent: this.proxyLegendPagination,\n          onclick: (ev) => this.pagination.onClick(ev, \"previous\"),\n          onmouseenter: () => this.pagination.onMouseHover(\"previous\"),\n          onmouseleave: () => this.pagination.onMouseHover(void 0)\n        });\n        this.proxyNextButton ?? (this.proxyNextButton = this.ctx.proxyInteractionService.createProxyElement({\n          type: \"button\",\n          id: `${this.id}-next-page`,\n          textContent: { id: \"ariaLabelLegendPageNext\" },\n          tabIndex: 0,\n          parent: this.proxyLegendPagination,\n          onclick: (ev) => this.pagination.onClick(ev, \"next\"),\n          onmouseenter: () => this.pagination.onMouseHover(\"next\"),\n          onmouseleave: () => this.pagination.onMouseHover(void 0)\n        }));\n        this.proxyLegendPagination.ariaHidden = \"false\";\n      } else {\n        this.proxyNextButton?.remove();\n        this.proxyPrevButton?.remove();\n        [this.proxyNextButton, this.proxyPrevButton] = [void 0, void 0];\n        this.proxyLegendPagination.ariaHidden = \"true\";\n      }\n    }\n    const { prev, next } = this.pagination.computeCSSBounds();\n    setElementBBox(this.proxyPrevButton, prev);\n    setElementBBox(this.proxyNextButton, next);\n    setElementStyle(this.proxyNextButton, \"cursor\", this.pagination.getCursor(\"next\"));\n    setElementStyle(this.proxyPrevButton, \"cursor\", this.pagination.getCursor(\"previous\"));\n  }\n  calculatePagination(bboxes, width2, height2) {\n    const { paddingX: itemPaddingX, paddingY: itemPaddingY } = this.item;\n    const orientation = this.getOrientation();\n    const paginationVertical = [\"left\", \"right\"].includes(this.position);\n    let paginationBBox = this.pagination.getBBox();\n    let lastPassPaginationBBox = new BBox(0, 0, 0, 0);\n    let pages = [];\n    let maxPageWidth = 0;\n    let maxPageHeight = 0;\n    let count = 0;\n    const stableOutput = (bbox) => {\n      return bbox.width === paginationBBox.width && bbox.height === paginationBBox.height;\n    };\n    const forceResult = this.maxWidth !== void 0 && this.maxHeight !== void 0;\n    do {\n      if (count++ > 10) {\n        Logger.warn(\"unable to find stable legend layout.\");\n        break;\n      }\n      paginationBBox = lastPassPaginationBBox;\n      const maxWidth = width2 - (paginationVertical ? 0 : paginationBBox.width);\n      const maxHeight = height2 - (paginationVertical ? paginationBBox.height : 0);\n      const layout = gridLayout({\n        orientation,\n        bboxes,\n        maxHeight,\n        maxWidth,\n        itemPaddingY,\n        itemPaddingX,\n        forceResult\n      });\n      pages = layout?.pages ?? [];\n      maxPageWidth = layout?.maxPageWidth ?? 0;\n      maxPageHeight = layout?.maxPageHeight ?? 0;\n      const totalPages = pages.length;\n      this.pagination.visible = totalPages > 1;\n      this.pagination.totalPages = totalPages;\n      this.pagination.update();\n      this.pagination.updateMarkers();\n      lastPassPaginationBBox = this.pagination.getBBox();\n      if (!this.pagination.visible) {\n        break;\n      }\n    } while (!stableOutput(lastPassPaginationBBox));\n    return { maxPageWidth, maxPageHeight, pages, paginationBBox: lastPassPaginationBBox, paginationVertical };\n  }\n  updatePositions(pageNumber = 0) {\n    const {\n      item: { paddingY },\n      itemSelection,\n      pages\n    } = this;\n    if (pages.length < 1 || !pages[pageNumber]) {\n      return;\n    }\n    const { columns, startIndex: visibleStart, endIndex: visibleEnd } = pages[pageNumber];\n    let x = 0;\n    let y = 0;\n    const columnCount = columns.length;\n    const rowCount = columns[0].indices.length;\n    const horizontal = this.getOrientation() === \"horizontal\";\n    const itemHeight = columns[0].bboxes[0].height + paddingY;\n    const rowSumColumnWidths = [];\n    itemSelection.each((markerLabel, _, i) => {\n      if (i < visibleStart || i > visibleEnd) {\n        markerLabel.visible = false;\n        return;\n      }\n      const pageIndex = i - visibleStart;\n      let columnIndex;\n      let rowIndex;\n      if (horizontal) {\n        columnIndex = pageIndex % columnCount;\n        rowIndex = Math.floor(pageIndex / columnCount);\n      } else {\n        columnIndex = Math.floor(pageIndex / rowCount);\n        rowIndex = pageIndex % rowCount;\n      }\n      markerLabel.visible = true;\n      const column = columns[columnIndex];\n      if (!column) {\n        return;\n      }\n      y = Math.floor(itemHeight * rowIndex);\n      x = Math.floor(rowSumColumnWidths[rowIndex] ?? 0);\n      rowSumColumnWidths[rowIndex] = (rowSumColumnWidths[rowIndex] ?? 0) + column.columnWidth;\n      markerLabel.translationX = x;\n      markerLabel.translationY = y;\n    });\n    this.updateItemProxyButtons();\n  }\n  updatePageNumber(pageNumber) {\n    const { pages } = this;\n    const { startIndex, endIndex } = pages[pageNumber];\n    if (startIndex === 0) {\n      this.paginationTrackingIndex = 0;\n    } else if (pageNumber === pages.length - 1) {\n      this.paginationTrackingIndex = endIndex;\n    } else {\n      this.paginationTrackingIndex = Math.floor((startIndex + endIndex) / 2);\n    }\n    this.pagination.update();\n    this.pagination.updateMarkers();\n    this.updatePositions(pageNumber);\n    setElementStyle(this.proxyNextButton, \"cursor\", this.pagination.getCursor(\"next\"));\n    setElementStyle(this.proxyPrevButton, \"cursor\", this.pagination.getCursor(\"previous\"));\n    this.ctx.updateService.update(6 /* SCENE_RENDER */);\n  }\n  update() {\n    const {\n      label: { color }\n    } = this.item;\n    this.itemSelection.each((markerLabel, datum) => {\n      markerLabel.setEnabled(datum.enabled);\n      markerLabel.color = color;\n    });\n    this.updateContextMenu();\n  }\n  updateContextMenu() {\n    const {\n      toggleSeries,\n      ctx: { contextMenuRegistry }\n    } = this;\n    if (toggleSeries) {\n      contextMenuRegistry.hideAction(ID_LEGEND_VISIBILITY);\n      contextMenuRegistry.hideAction(ID_LEGEND_OTHER_SERIES);\n    } else {\n      contextMenuRegistry.showAction(ID_LEGEND_VISIBILITY);\n      contextMenuRegistry.showAction(ID_LEGEND_OTHER_SERIES);\n    }\n  }\n  getLineStyles(datum) {\n    const { stroke, strokeOpacity = 1, strokeWidth, lineDash } = datum.line ?? {};\n    const defaultLineStrokeWidth = Math.min(2, strokeWidth ?? 1);\n    return {\n      stroke,\n      strokeOpacity,\n      strokeWidth: this.item.line.strokeWidth ?? defaultLineStrokeWidth,\n      lineDash\n    };\n  }\n  getMarkerStyles(datum) {\n    const { fill, stroke, strokeOpacity = 1, fillOpacity = 1, strokeWidth } = datum.marker;\n    const defaultLineStrokeWidth = Math.min(2, strokeWidth ?? 1);\n    return {\n      fill,\n      stroke,\n      strokeOpacity,\n      fillOpacity,\n      strokeWidth: this.item.marker.strokeWidth ?? defaultLineStrokeWidth\n    };\n  }\n  computePagedBBox() {\n    const actualBBox = Group.computeChildrenBBox(this.group.children());\n    if (this.pages.length > 1) {\n      const [maxPageWidth, maxPageHeight] = this.maxPageSize;\n      actualBBox.height = Math.max(maxPageHeight, actualBBox.height);\n      actualBBox.width = Math.max(maxPageWidth, actualBBox.width);\n    }\n    return actualBBox;\n  }\n  findNode(params) {\n    const { datum, proxyButton } = this.itemSelection.select((ml) => ml.datum?.itemId === params.itemId)[0] ?? {};\n    if (datum === void 0 || proxyButton === void 0) {\n      throw new Error(`AG Charts - Missing required properties { datum: ${datum}, proxyButton: ${proxyButton} }`);\n    }\n    return { datum, proxyButton };\n  }\n  contextToggleVisibility(params) {\n    const { datum, proxyButton } = this.findNode(params);\n    this.doClick(params.event, datum, proxyButton.button);\n  }\n  contextToggleOtherSeries(params) {\n    this.doDoubleClick(params.event, this.findNode(params).datum);\n  }\n  onContextClick(sourceEvent, node) {\n    const legendItem = node.datum;\n    if (this.preventHidingAll && this.contextMenuDatum?.enabled && this.getVisibleItemCount() <= 1) {\n      this.ctx.contextMenuRegistry.disableAction(ID_LEGEND_VISIBILITY);\n    } else {\n      this.ctx.contextMenuRegistry.enableAction(ID_LEGEND_VISIBILITY);\n    }\n    const { button, offsetX, offsetY } = sourceEvent;\n    const { x: canvasOffsetX, y: canvasOffsetY } = Transformable.toCanvasPoint(node, offsetX, offsetY);\n    const event = {\n      type: \"contextmenu\",\n      sourceEvent,\n      button,\n      offsetX: canvasOffsetX,\n      offsetY: canvasOffsetY,\n      deltaX: 0,\n      deltaY: 0,\n      pageX: NaN,\n      pageY: NaN,\n      preventDefault: () => sourceEvent.preventDefault(),\n      pointerHistory: []\n    };\n    this.ctx.contextMenuRegistry.dispatchContext(\"legend\", event, { legendItem });\n  }\n  onClick(event, datum, proxyButton) {\n    if (this.doClick(event, datum, proxyButton)) {\n      event.preventDefault();\n    }\n  }\n  getVisibleItemCount() {\n    return this.ctx.chartService.series.flatMap((s) => s.getLegendData(\"category\")).filter((d) => d.enabled).length;\n  }\n  doClick(event, datum, proxyButton) {\n    const {\n      listeners: { legendItemClick },\n      ctx: { chartService, highlightManager },\n      preventHidingAll,\n      toggleSeries\n    } = this;\n    if (!datum) {\n      return false;\n    }\n    const { id, itemId, enabled } = datum;\n    const series = chartService.series.find((s) => s.id === id);\n    if (!series) {\n      return false;\n    }\n    let newEnabled = enabled;\n    const clickEvent = new LegendItemEvent(\"click\", newEnabled, itemId, series.id, event);\n    legendItemClick?.(clickEvent);\n    if (clickEvent.defaultPrevented)\n      return true;\n    if (toggleSeries) {\n      newEnabled = !enabled;\n      if (preventHidingAll && !newEnabled) {\n        const numVisibleItems = this.getVisibleItemCount();\n        if (numVisibleItems < 2) {\n          newEnabled = true;\n        }\n      }\n      proxyButton.ariaChecked = newEnabled.toString();\n      this.ctx.chartEventManager.legendItemClick(series, itemId, newEnabled, datum.legendItemName);\n    }\n    if (newEnabled) {\n      highlightManager.updateHighlight(this.id, {\n        series,\n        itemId,\n        datum: void 0\n      });\n    } else {\n      highlightManager.updateHighlight(this.id);\n    }\n    this.ctx.updateService.update(2 /* PROCESS_DATA */, { forceNodeDataRefresh: true });\n    return true;\n  }\n  onDoubleClick(event, datum) {\n    if (this.doDoubleClick(event, datum)) {\n      event.preventDefault();\n    }\n  }\n  doDoubleClick(event, datum) {\n    const {\n      listeners: { legendItemDoubleClick },\n      ctx: { chartService },\n      toggleSeries\n    } = this;\n    if (chartService.mode === \"integrated\") {\n      return false;\n    }\n    if (!datum) {\n      return false;\n    }\n    const { id, itemId, seriesId } = datum;\n    const series = chartService.series.find((s) => s.id === id);\n    if (!series) {\n      return false;\n    }\n    const doubleClickEvent = new LegendItemEvent(\"dblclick\", true, itemId, series.id, event);\n    legendItemDoubleClick?.(doubleClickEvent);\n    if (doubleClickEvent.defaultPrevented)\n      return true;\n    if (toggleSeries) {\n      const legendData = chartService.series.flatMap((s) => s.getLegendData(\"category\"));\n      const numVisibleItems = legendData.filter((d) => d.enabled).length;\n      const clickedItem = legendData.find((d) => d.itemId === itemId && d.seriesId === seriesId);\n      this.ctx.chartEventManager.legendItemDoubleClick(\n        series,\n        itemId,\n        clickedItem?.enabled ?? false,\n        numVisibleItems,\n        clickedItem?.legendItemName\n      );\n    }\n    this.ctx.updateService.update(2 /* PROCESS_DATA */, { forceNodeDataRefresh: true });\n    return true;\n  }\n  toTooltipMeta(event, node) {\n    let lastPointerEvent;\n    if (event instanceof FocusEvent) {\n      const { x, y } = Transformable.toCanvas(node).computeCenter();\n      lastPointerEvent = { type: \"keyboard\", offsetX: x, offsetY: y };\n    } else {\n      event.preventDefault();\n      const { x, y } = Transformable.toCanvasPoint(node, event.offsetX, event.offsetY);\n      lastPointerEvent = { type: \"hover\", offsetX: x, offsetY: y };\n    }\n    const { offsetX, offsetY } = lastPointerEvent;\n    return { offsetX, offsetY, lastPointerEvent, showArrow: false };\n  }\n  onHover(event, node) {\n    if (!this.enabled)\n      throw new Error(\"AG Charts - onHover handler called on disabled legend\");\n    this.pagination.setPage(node.pageIndex);\n    const datum = node.datum;\n    const series = datum ? this.ctx.chartService.series.find((s) => s.id === datum?.id) : void 0;\n    if (datum && this.truncatedItems.has(datum.itemId ?? datum.id)) {\n      const meta = this.toTooltipMeta(event, node);\n      this.ctx.tooltipManager.updateTooltip(this.id, meta, toTooltipHtml({ content: this.getItemLabel(datum) }));\n    } else {\n      this.ctx.tooltipManager.removeTooltip(this.id);\n    }\n    if (datum?.enabled && series) {\n      this.updateHighlight({ series, itemId: datum?.itemId, datum: void 0 });\n    } else {\n      this.updateHighlight();\n    }\n  }\n  onLeave() {\n    this.ctx.tooltipManager.removeTooltip(this.id);\n    this.updateHighlight();\n  }\n  updateHighlight(datum) {\n    const state = this.ctx.interactionManager.getState();\n    if (state === 32 /* Default */) {\n      this.ctx.highlightManager.updateHighlight(this.id, datum);\n    } else if (state === 2 /* Animation */) {\n      this.pendingHighlightDatum = datum;\n      this.ctx.animationManager.onBatchStop(() => {\n        this.ctx.highlightManager.updateHighlight(this.id, this.pendingHighlightDatum);\n      });\n    }\n  }\n  onLocaleChanged() {\n    this.itemSelection.each(({ proxyButton }, _, i) => {\n      if (proxyButton?.button != null) {\n        proxyButton.button.textContent = this.getItemAriaText(i);\n      }\n    });\n    this.proxyLegendItemDescription.textContent = this.getItemAriaDescription();\n  }\n  getItemAriaText(nodeIndex) {\n    const datum = this.data[nodeIndex];\n    const label = datum && this.getItemLabel(datum);\n    const lm = this.ctx.localeManager;\n    if (nodeIndex >= 0 && label) {\n      const index = nodeIndex + 1;\n      const count = this.data.length;\n      return lm.t(\"ariaLabelLegendItem\", { label, index, count });\n    }\n    return lm.t(\"ariaLabelLegendItemUnknown\");\n  }\n  getItemAriaDescription() {\n    return this.ctx.localeManager.t(\"ariaDescriptionLegendItem\");\n  }\n  positionLegend(ctx) {\n    setElementStyle(this.proxyLegendToolbar, \"display\", this.visible && this.enabled ? void 0 : \"none\");\n    if (!this.enabled || !this.data.length)\n      return;\n    const { layoutBox } = ctx;\n    const { x, y, width: width2, height: height2 } = layoutBox;\n    const [legendWidth, legendHeight] = this.calculateLegendDimensions(layoutBox);\n    const { oldPages } = this.calcLayout(legendWidth, legendHeight);\n    const legendBBox = this.computePagedBBox();\n    const calculateTranslationPerpendicularDimension = () => {\n      switch (this.position) {\n        case \"top\":\n        case \"left\":\n          return 0;\n        case \"bottom\":\n          return height2 - legendBBox.height;\n        case \"right\":\n        default:\n          return width2 - legendBBox.width;\n      }\n    };\n    if (this.visible) {\n      const legendPadding = this.spacing;\n      let translationX;\n      let translationY;\n      switch (this.position) {\n        case \"top\":\n        case \"bottom\":\n          translationX = (width2 - legendBBox.width) / 2;\n          translationY = calculateTranslationPerpendicularDimension();\n          layoutBox.shrink(legendBBox.height + legendPadding, this.position);\n          break;\n        case \"left\":\n        case \"right\":\n        default:\n          translationX = calculateTranslationPerpendicularDimension();\n          translationY = (height2 - legendBBox.height) / 2;\n          layoutBox.shrink(legendBBox.width + legendPadding, this.position);\n      }\n      this.group.translationX = Math.floor(x + translationX - legendBBox.x);\n      this.group.translationY = Math.floor(y + translationY - legendBBox.y);\n      this.proxyLegendToolbar.ariaOrientation = this.getOrientation();\n    }\n    this.updateItemProxyButtons();\n    this.updatePaginationProxyButtons(oldPages);\n  }\n  calculateLegendDimensions(shrinkRect) {\n    const { width: width2, height: height2 } = shrinkRect;\n    const aspectRatio = width2 / height2;\n    const maxCoefficient = 0.5;\n    const minHeightCoefficient = 0.2;\n    const minWidthCoefficient = 0.25;\n    let legendWidth, legendHeight;\n    switch (this.position) {\n      case \"top\":\n      case \"bottom\": {\n        const heightCoefficient = aspectRatio < 1 ? Math.min(maxCoefficient, minHeightCoefficient * (1 / aspectRatio)) : minHeightCoefficient;\n        legendWidth = this.maxWidth ? Math.min(this.maxWidth, width2) : width2;\n        legendHeight = this.maxHeight ? Math.min(this.maxHeight, height2) : Math.round(height2 * heightCoefficient);\n        break;\n      }\n      case \"left\":\n      case \"right\":\n      default: {\n        const widthCoefficient = aspectRatio > 1 ? Math.min(maxCoefficient, minWidthCoefficient * aspectRatio) : minWidthCoefficient;\n        legendWidth = this.maxWidth ? Math.min(this.maxWidth, width2) : Math.round(width2 * widthCoefficient);\n        legendHeight = this.maxHeight ? Math.min(this.maxHeight, height2) : height2;\n      }\n    }\n    return [legendWidth, legendHeight];\n  }\n};\nLegend.className = \"Legend\";\n__decorateClass([\n  Validate(BOOLEAN)\n], Legend.prototype, \"toggleSeries\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Legend.prototype, \"pagination\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Legend.prototype, \"item\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Legend.prototype, \"listeners\", 2);\n__decorateClass([\n  ObserveChanges((target) => target.updateGroupVisibility()),\n  Validate(BOOLEAN)\n], Legend.prototype, \"enabled\", 2);\n__decorateClass([\n  ObserveChanges((target) => target.proxyLegendDirty = true),\n  Validate(POSITION)\n], Legend.prototype, \"position\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], Legend.prototype, \"maxWidth\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], Legend.prototype, \"maxHeight\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], Legend.prototype, \"reverseOrder\", 2);\n__decorateClass([\n  Validate(UNION([\"horizontal\", \"vertical\"], \"an orientation\"), { optional: true })\n], Legend.prototype, \"orientation\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], Legend.prototype, \"preventHidingAll\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Legend.prototype, \"spacing\", 2);\n\n// packages/ag-charts-community/src/chart/legendModule.ts\nvar CommunityLegendModule = {\n  type: \"legend\",\n  optionsKey: \"legend\",\n  identifier: \"category\",\n  chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\", \"standalone\", \"gauge\"],\n  moduleFactory: (ctx) => new Legend(ctx),\n  packageType: \"community\"\n};\n\n// packages/ag-charts-community/src/chart/navigator/shapes/rangeHandle.ts\nvar RangeHandle = class extends Path {\n  constructor() {\n    super(...arguments);\n    this.zIndex = 3;\n    this.centerX = 0;\n    this.centerY = 0;\n    this.width = 8;\n    this.height = 16;\n    this.gripLineGap = 2;\n    this.gripLineLength = 8;\n  }\n  setCenter(x, y) {\n    this.dirtyPath = true;\n    if (this.centerX !== x || this.centerY !== y) {\n      this.centerX = x;\n      this.centerY = y;\n      this.markDirty(3 /* MAJOR */);\n    }\n  }\n  static align(minHandle, maxHandle, x, y, width2, height2, min, max) {\n    const handlePixelAlign = minHandle.strokeWidth / 2;\n    const minHandleX = minHandle.align(x + width2 * min) + handlePixelAlign;\n    const maxHandleX = minHandleX + minHandle.align(x + width2 * min, width2 * (max - min)) - 2 * handlePixelAlign;\n    const handleY = minHandle.align(y + height2 / 2) + handlePixelAlign;\n    minHandle.setCenter(minHandleX, handleY);\n    maxHandle.setCenter(maxHandleX, handleY);\n  }\n  computeBBox() {\n    const { centerX, centerY, width: width2, height: height2 } = this;\n    const x = centerX - width2 / 2;\n    const y = centerY - height2 / 2;\n    return new BBox(x, y, width2, height2);\n  }\n  isPointInPath(x, y) {\n    const bbox = this.getBBox();\n    return bbox.containsPoint(x, y);\n  }\n  updatePath() {\n    const { centerX, centerY, path, strokeWidth, gripLineGap, gripLineLength } = this;\n    const pixelRatio = this.layerManager?.canvas?.pixelRatio ?? 1;\n    path.clear();\n    const halfWidth = Math.floor(this.width / 2 * pixelRatio) / pixelRatio;\n    const halfHeight = Math.floor(this.height / 2 * pixelRatio) / pixelRatio;\n    path.moveTo(centerX - halfWidth, centerY - halfHeight);\n    path.lineTo(centerX + halfWidth, centerY - halfHeight);\n    path.lineTo(centerX + halfWidth, centerY + halfHeight);\n    path.lineTo(centerX - halfWidth, centerY + halfHeight);\n    path.closePath();\n    const dx = Math.floor((gripLineGap + strokeWidth) / 2 * pixelRatio) / pixelRatio;\n    const dy = Math.floor(gripLineLength / 2 * pixelRatio) / pixelRatio;\n    path.moveTo(centerX - dx, centerY - dy);\n    path.lineTo(centerX - dx, centerY + dy);\n    path.moveTo(centerX + dx, centerY - dy);\n    path.lineTo(centerX + dx, centerY + dy);\n  }\n};\nRangeHandle.className = \"RangeHandle\";\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */, type: \"path\" })\n], RangeHandle.prototype, \"width\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */, type: \"path\" })\n], RangeHandle.prototype, \"height\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */, type: \"path\" })\n], RangeHandle.prototype, \"gripLineGap\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */, type: \"path\" })\n], RangeHandle.prototype, \"gripLineLength\", 2);\n\n// packages/ag-charts-community/src/chart/navigator/shapes/rangeMask.ts\nvar RangeMask = class extends Path {\n  constructor() {\n    super(...arguments);\n    this.zIndex = 2;\n    this.x = 0;\n    this.y = 0;\n    this.width = 200;\n    this.height = 30;\n    this.min = 0;\n    this.max = 1;\n  }\n  layout(x, y, width2, height2) {\n    if (x !== this.x || y !== this.y || width2 !== this.width || this.height !== height2) {\n      this.x = x;\n      this.y = y;\n      this.width = width2;\n      this.height = height2;\n      this.dirtyPath = true;\n      this.markDirty(3 /* MAJOR */);\n    }\n  }\n  update(min, max) {\n    min = isNaN(min) ? this.min : min;\n    max = isNaN(max) ? this.max : max;\n    if (min !== this.min || max !== this.max) {\n      this.min = min;\n      this.max = max;\n      this.dirtyPath = true;\n      this.markDirty(3 /* MAJOR */);\n    }\n  }\n  computeBBox() {\n    const { x, y, width: width2, height: height2 } = this;\n    return new BBox(x, y, width2, height2);\n  }\n  computeVisibleRangeBBox() {\n    const { x, y, width: width2, height: height2, min, max } = this;\n    const minX = x + width2 * min;\n    const maxX = x + width2 * max;\n    return new BBox(minX, y, maxX - minX, height2);\n  }\n  updatePath() {\n    const { path, x, y, width: width2, height: height2, min, max, strokeWidth } = this;\n    const pixelAlign = strokeWidth / 2;\n    path.clear();\n    const ax = this.align(x) + pixelAlign;\n    const ay = this.align(y) + pixelAlign;\n    const axw = ax + this.align(x, width2) - 2 * pixelAlign;\n    const ayh = ay + this.align(y, height2) - 2 * pixelAlign;\n    path.moveTo(ax, ay);\n    path.lineTo(axw, ay);\n    path.lineTo(axw, ayh);\n    path.lineTo(ax, ayh);\n    path.closePath();\n    const minX = this.align(x + width2 * min) + pixelAlign;\n    const maxX = minX + this.align(x + width2 * min, width2 * (max - min)) - 2 * pixelAlign;\n    path.moveTo(minX, ay);\n    path.lineTo(minX, ayh);\n    path.lineTo(maxX, ayh);\n    path.lineTo(maxX, ay);\n    path.closePath();\n  }\n};\nRangeMask.className = \"RangeMask\";\n\n// packages/ag-charts-community/src/chart/navigator/shapes/rangeSelector.ts\nvar RangeSelector = class extends Layer {\n  constructor(children) {\n    super({ name: \"rangeSelectorGroup\", zIndex: 16 /* NAVIGATOR */ });\n    this.x = 0;\n    this.y = 0;\n    this.width = 200;\n    this.height = 30;\n    this.lOffset = 0;\n    this.rOffset = 0;\n    this.background = this.appendChild(new TranslatableGroup({ name: \"navigator-background\", zIndex: 1 }));\n    this.append(children);\n  }\n  layout(x, y, width2, height2, lOffset, rOffset) {\n    this.x = x;\n    this.y = y;\n    this.width = width2;\n    this.height = height2;\n    this.lOffset = lOffset;\n    this.rOffset = rOffset;\n    this.background.translationX = x;\n    this.background.translationY = y;\n    this.markDirty(3 /* MAJOR */);\n  }\n  updateBackground(oldGroup, newGroup) {\n    if (oldGroup != null) {\n      this.background.removeChild(oldGroup);\n    }\n    if (newGroup != null) {\n      this.background.appendChild(newGroup);\n    }\n    this.markDirty(3 /* MAJOR */);\n  }\n  computeBBox() {\n    const { x, y, width: width2, height: height2, lOffset, rOffset } = this;\n    return new BBox(x - lOffset, y, width2 + (lOffset + rOffset), height2);\n  }\n};\n\n// packages/ag-charts-community/src/chart/navigator/navigator.ts\nvar Navigator = class extends BaseModuleInstance {\n  constructor(ctx) {\n    super();\n    this.ctx = ctx;\n    this.miniChart = void 0;\n    this.enabled = false;\n    this.mask = new RangeMask();\n    this.minHandle = new RangeHandle();\n    this.maxHandle = new RangeHandle();\n    this.maskVisibleRange = {\n      id: \"navigator-mask-visible-range\",\n      getBBox: () => this.mask.computeVisibleRangeBBox(),\n      toCanvasBBox: () => this.mask.computeVisibleRangeBBox(),\n      fromCanvasPoint: (x, y) => ({ x, y })\n    };\n    this.height = 30;\n    this.spacing = 10;\n    this.x = 0;\n    this.y = 0;\n    this.width = 0;\n    this.rangeSelector = new RangeSelector([this.mask, this.minHandle, this.maxHandle]);\n    this._min = 0;\n    this._max = 1;\n    this.minRange = 1e-3;\n    const region = ctx.regionManager.addRegion(\"navigator\", this.rangeSelector);\n    const dragStates = 32 /* Default */ | 2 /* Animation */ | 16 /* ZoomDrag */;\n    this.destroyFns.push(\n      ctx.scene.attachNode(this.rangeSelector),\n      region.addListener(\"hover\", (event) => this.onHover(event), dragStates),\n      region.addListener(\"drag-start\", (event) => this.onDragStart(event), dragStates),\n      region.addListener(\"drag\", (event) => this.onDrag(event), dragStates),\n      region.addListener(\"drag-end\", (event) => this.onDragEnd(event), dragStates),\n      region.addListener(\"leave\", (event) => this.onLeave(event), dragStates),\n      this.ctx.localeManager.addListener(\"locale-changed\", () => this.updateZoom()),\n      this.ctx.layoutManager.registerElement(3 /* Navigator */, (e) => this.onLayoutStart(e)),\n      this.ctx.layoutManager.addListener(\"layout:complete\", (e) => this.onLayoutComplete(e)),\n      ctx.zoomManager.addListener(\"zoom-change\", (event) => this.onZoomChange(event))\n    );\n    this.proxyNavigatorToolbar = this.ctx.proxyInteractionService.createProxyContainer({\n      type: \"toolbar\",\n      id: `navigator-toolbar`,\n      classList: [\"ag-charts-proxy-navigator-toolbar\"],\n      ariaOrientation: \"vertical\",\n      ariaLabel: { id: \"ariaLabelNavigator\" }\n    });\n    this.updateGroupVisibility();\n    this.proxyNavigatorElements = [\n      this.ctx.proxyInteractionService.createProxyElement({\n        type: \"slider\",\n        id: \"ag-charts-navigator-min\",\n        ariaLabel: { id: \"ariaLabelNavigatorMinimum\" },\n        ariaOrientation: \"horizontal\",\n        parent: this.proxyNavigatorToolbar,\n        onchange: (ev) => this.onMinSliderChange(ev)\n      }),\n      this.ctx.proxyInteractionService.createProxyElement({\n        type: \"slider\",\n        id: \"ag-charts-navigator-pan\",\n        ariaLabel: { id: \"ariaLabelNavigatorRange\" },\n        ariaOrientation: \"horizontal\",\n        parent: this.proxyNavigatorToolbar,\n        onchange: (ev) => this.onPanSliderChange(ev)\n      }),\n      this.ctx.proxyInteractionService.createProxyElement({\n        type: \"slider\",\n        id: \"ag-charts-navigator-max\",\n        ariaLabel: { id: \"ariaLabelNavigatorMaximum\" },\n        ariaOrientation: \"horizontal\",\n        parent: this.proxyNavigatorToolbar,\n        onchange: (ev) => this.onMaxSliderChange(ev)\n      })\n    ];\n    this.proxyNavigatorElements.forEach((slider) => setAttribute(slider, \"data-preventdefault\", false));\n    this.setSliderRatio(this.proxyNavigatorElements[0], this._min);\n    this.setSliderRatio(this.proxyNavigatorElements[2], this._max);\n    this.setPanSliderValue(this._min, this._max);\n    initToolbarKeyNav({\n      orientation: \"vertical\",\n      toolbar: this.proxyNavigatorToolbar,\n      buttons: this.proxyNavigatorElements\n    });\n    this.destroyFns.push(() => {\n      this.proxyNavigatorElements.forEach((e) => e.remove());\n      this.proxyNavigatorToolbar.remove();\n    });\n  }\n  updateBackground(oldGroup, newGroup) {\n    this.rangeSelector?.updateBackground(oldGroup, newGroup);\n  }\n  updateGroupVisibility() {\n    const { enabled } = this;\n    if (this.rangeSelector == null || enabled === this.rangeSelector.visible)\n      return;\n    this.rangeSelector.visible = enabled;\n    this.proxyNavigatorToolbar.ariaHidden = (!enabled).toString();\n    if (enabled) {\n      this.updateZoom();\n    } else {\n      this.ctx.zoomManager.updateZoom(\"navigator\");\n    }\n  }\n  onLayoutStart(ctx) {\n    if (this.enabled) {\n      const { layoutBox } = ctx;\n      const navigatorTotalHeight = this.height + this.spacing;\n      layoutBox.shrink(navigatorTotalHeight, \"bottom\");\n      this.y = layoutBox.y + layoutBox.height + this.spacing;\n    } else {\n      this.y = 0;\n    }\n  }\n  onLayoutComplete(opts) {\n    const { x, width: width2 } = opts.series.rect;\n    if (this.enabled) {\n      const { y, height: height2 } = this;\n      this.layoutNodes(x, y, width2, height2);\n      setElementBBox(this.proxyNavigatorToolbar, { x, y, width: width2, height: height2 });\n      this.proxyNavigatorToolbar.style.removeProperty(\"display\");\n    } else {\n      this.proxyNavigatorToolbar.style.display = \"none\";\n    }\n    this.x = x;\n    this.width = width2;\n  }\n  onHover(event) {\n    if (!this.enabled)\n      return;\n    this.updateCursor(event);\n  }\n  updateCursor(event) {\n    if (!this.enabled)\n      return;\n    const { mask, minHandle, maxHandle } = this;\n    const { regionOffsetX, regionOffsetY } = event;\n    if (minHandle.containsPoint(regionOffsetX, regionOffsetY) || maxHandle.containsPoint(regionOffsetX, regionOffsetY)) {\n      this.ctx.cursorManager.updateCursor(\"navigator\", \"ew-resize\");\n    } else if (mask.computeVisibleRangeBBox().containsPoint(regionOffsetX, regionOffsetY)) {\n      this.ctx.cursorManager.updateCursor(\"navigator\", \"grab\");\n    } else {\n      this.ctx.cursorManager.updateCursor(\"navigator\");\n    }\n  }\n  onDragStart(event) {\n    if (!this.enabled)\n      return;\n    this.updateCursor(event);\n    const { mask, minHandle, maxHandle, x, width: width2, _min: min } = this;\n    const { regionOffsetX, regionOffsetY } = event;\n    if (minHandle.zIndex < maxHandle.zIndex) {\n      if (maxHandle.containsPoint(regionOffsetX, regionOffsetY)) {\n        this.dragging = \"max\";\n      } else if (minHandle.containsPoint(regionOffsetX, regionOffsetY)) {\n        this.dragging = \"min\";\n      }\n    } else if (minHandle.containsPoint(regionOffsetX, regionOffsetY)) {\n      this.dragging = \"min\";\n    } else if (maxHandle.containsPoint(regionOffsetX, regionOffsetY)) {\n      this.dragging = \"max\";\n    }\n    if (this.dragging == null && mask.computeVisibleRangeBBox().containsPoint(regionOffsetX, regionOffsetY)) {\n      this.dragging = \"pan\";\n      this.panStart = (regionOffsetX - x) / width2 - min;\n    }\n    if (this.dragging != null) {\n      this.ctx.zoomManager.fireZoomPanStartEvent(\"navigator\");\n    }\n  }\n  onDrag(event) {\n    if (!this.enabled || this.dragging == null)\n      return;\n    const { dragging, minRange, panStart, x, width: width2 } = this;\n    let { _min: min, _max: max } = this;\n    const { regionOffsetX } = event;\n    const ratio2 = (regionOffsetX - x) / width2;\n    if (dragging === \"min\") {\n      min = clamp(0, ratio2, max - minRange);\n    } else if (dragging === \"max\") {\n      max = clamp(min + minRange, ratio2, 1);\n    } else if (dragging === \"pan\" && panStart != null) {\n      const span = max - min;\n      min = clamp(0, ratio2 - panStart, 1 - span);\n      max = min + span;\n    }\n    this._min = min;\n    this._max = max;\n    this.updateZoom();\n  }\n  onDragEnd(event) {\n    this.dragging = void 0;\n    this.updateCursor(event);\n  }\n  onLeave(_event) {\n    this.ctx.cursorManager.updateCursor(\"navigator\");\n  }\n  onZoomChange(event) {\n    const { x } = event;\n    if (!x)\n      return;\n    this._min = x.min;\n    this._max = x.max;\n    this.updateNodes(x.min, x.max);\n    this.setPanSliderValue(x.min, x.max);\n    this.setSliderRatio(this.proxyNavigatorElements[0], x.min);\n    this.setSliderRatio(this.proxyNavigatorElements[2], x.max);\n  }\n  onPanSliderChange(_event) {\n    const ratio2 = this.getSliderRatio(this.proxyNavigatorElements[1]);\n    const span = this._max - this._min;\n    this._min = clamp(0, ratio2, 1 - span);\n    this._max = this._min + span;\n    this.updateZoom();\n  }\n  onMinSliderChange(_event) {\n    const slider = this.proxyNavigatorElements[0];\n    this._min = this.setSliderRatioClamped(slider, 0, this._max - this.minRange);\n    this.updateZoom();\n  }\n  onMaxSliderChange(_event) {\n    const slider = this.proxyNavigatorElements[2];\n    this._max = this.setSliderRatioClamped(slider, this._min + this.minRange, 1);\n    this.updateZoom();\n  }\n  setPanSliderValue(min, max) {\n    this.proxyNavigatorElements[1].value = `${Math.round(min * 100)}`;\n    this.proxyNavigatorElements[1].ariaValueText = this.ctx.localeManager.t(\"ariaValuePanRange\", { min, max });\n  }\n  setSliderRatioClamped(slider, clampMin, clampMax) {\n    const ratio2 = this.getSliderRatio(slider);\n    const clampedRatio = clamp(clampMin, ratio2, clampMax);\n    if (clampedRatio !== ratio2) {\n      this.setSliderRatio(slider, clampedRatio);\n    }\n    return clampedRatio;\n  }\n  setSliderRatio(slider, ratio2) {\n    const value = Math.round(ratio2 * 100);\n    slider.value = `${value}`;\n    slider.ariaValueText = formatPercentage(value);\n  }\n  getSliderRatio(slider) {\n    return parseFloat(slider.value) / 100;\n  }\n  layoutNodes(x, y, width2, height2) {\n    const { rangeSelector, mask, minHandle, maxHandle, _min: min, _max: max } = this;\n    rangeSelector.layout(x, y, width2, height2, minHandle.width / 2, maxHandle.width / 2);\n    mask.layout(x, y, width2, height2);\n    RangeHandle.align(minHandle, maxHandle, x, y, width2, height2, min, max);\n    if (min + (max - min) / 2 < 0.5) {\n      minHandle.zIndex = 3;\n      maxHandle.zIndex = 4;\n    } else {\n      minHandle.zIndex = 4;\n      maxHandle.zIndex = 3;\n    }\n    [minHandle, this.maskVisibleRange, maxHandle].forEach((node, index) => {\n      const bbox = node.getBBox();\n      const tbox = { x: bbox.x - x, y: bbox.y - y, height: bbox.height, width: bbox.width };\n      setElementBBox(this.proxyNavigatorElements[index], tbox);\n    });\n  }\n  updateNodes(min, max) {\n    this.mask.update(min, max);\n  }\n  updateZoom() {\n    if (!this.enabled)\n      return;\n    const { _min: min, _max: max } = this;\n    if (min == null || max == null)\n      return;\n    const warnOnConflict = (stateId) => {\n      if (this.min == null && this.max == null)\n        return;\n      Logger.warnOnce(\n        `Could not apply [navigator.min] or [navigator.max] as [${stateId}] has modified the initial zoom state.`\n      );\n    };\n    return this.ctx.zoomManager.updateZoom(\"navigator\", { x: { min, max } }, false, warnOnConflict);\n  }\n};\n__decorateClass([\n  Validate(OBJECT, { optional: true })\n], Navigator.prototype, \"miniChart\", 2);\n__decorateClass([\n  Validate(BOOLEAN),\n  ObserveChanges((target) => target.updateGroupVisibility())\n], Navigator.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Navigator.prototype, \"height\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Navigator.prototype, \"spacing\", 2);\n__decorateClass([\n  ActionOnSet({\n    newValue(min) {\n      this._min = min;\n      this.updateZoom();\n    }\n  }),\n  Validate(AND(RATIO, LESS_THAN(\"max\")), { optional: true })\n], Navigator.prototype, \"min\", 2);\n__decorateClass([\n  ActionOnSet({\n    newValue(max) {\n      this._max = max;\n      this.updateZoom();\n    }\n  }),\n  Validate(AND(RATIO, GREATER_THAN(\"min\")), { optional: true })\n], Navigator.prototype, \"max\", 2);\n\n// packages/ag-charts-community/src/chart/navigator/navigatorModule.ts\nvar NavigatorModule = {\n  type: \"root\",\n  optionsKey: \"navigator\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  moduleFactory: (ctx) => new Navigator(ctx),\n  themeTemplate: {\n    navigator: {\n      enabled: false,\n      height: 30,\n      mask: {\n        fill: \"#999999\",\n        stroke: \"#999999\",\n        strokeWidth: 1,\n        fillOpacity: 0.2\n      },\n      minHandle: {\n        fill: \"#f2f2f2\",\n        stroke: \"#999999\",\n        strokeWidth: 1,\n        width: 9,\n        height: 16,\n        gripLineGap: 1,\n        gripLineLength: 8\n      },\n      maxHandle: {\n        fill: \"#f2f2f2\",\n        stroke: \"#999999\",\n        strokeWidth: 1,\n        width: 9,\n        height: 16,\n        gripLineGap: 1,\n        gripLineLength: 8\n      }\n    }\n  }\n};\n\n// packages/ag-charts-community/src/module/theme.ts\nfunction singleSeriesPaletteFactory({ takeColors }) {\n  const {\n    fills: [fill],\n    strokes: [stroke]\n  } = takeColors(1);\n  return { fill, stroke };\n}\nfunction markerPaletteFactory(params) {\n  return { marker: singleSeriesPaletteFactory(params) };\n}\n\n// packages/ag-charts-community/src/chart/themes/constants.ts\nvar FONT_SIZE = /* @__PURE__ */ ((FONT_SIZE2) => {\n  FONT_SIZE2[FONT_SIZE2[\"SMALL\"] = 12] = \"SMALL\";\n  FONT_SIZE2[FONT_SIZE2[\"MEDIUM\"] = 13] = \"MEDIUM\";\n  FONT_SIZE2[FONT_SIZE2[\"LARGE\"] = 17] = \"LARGE\";\n  return FONT_SIZE2;\n})(FONT_SIZE || {});\nvar FONT_WEIGHT2 = /* @__PURE__ */ ((FONT_WEIGHT3) => {\n  FONT_WEIGHT3[\"NORMAL\"] = \"normal\";\n  FONT_WEIGHT3[\"BOLD\"] = \"bold\";\n  FONT_WEIGHT3[\"BOLDER\"] = \"bolder\";\n  FONT_WEIGHT3[\"LIGHTER\"] = \"lighter\";\n  return FONT_WEIGHT3;\n})(FONT_WEIGHT2 || {});\nvar CARTESIAN_POSITION = /* @__PURE__ */ ((CARTESIAN_POSITION2) => {\n  CARTESIAN_POSITION2[\"TOP\"] = \"top\";\n  CARTESIAN_POSITION2[\"RIGHT\"] = \"right\";\n  CARTESIAN_POSITION2[\"BOTTOM\"] = \"bottom\";\n  CARTESIAN_POSITION2[\"LEFT\"] = \"left\";\n  return CARTESIAN_POSITION2;\n})(CARTESIAN_POSITION || {});\nvar CARTESIAN_AXIS_TYPE = /* @__PURE__ */ ((CARTESIAN_AXIS_TYPE2) => {\n  CARTESIAN_AXIS_TYPE2[\"CATEGORY\"] = \"category\";\n  CARTESIAN_AXIS_TYPE2[\"ORDINAL_TIME\"] = \"ordinal-time\";\n  CARTESIAN_AXIS_TYPE2[\"NUMBER\"] = \"number\";\n  CARTESIAN_AXIS_TYPE2[\"TIME\"] = \"time\";\n  CARTESIAN_AXIS_TYPE2[\"LOG\"] = \"log\";\n  return CARTESIAN_AXIS_TYPE2;\n})(CARTESIAN_AXIS_TYPE || {});\nvar POLAR_AXIS_TYPE = /* @__PURE__ */ ((POLAR_AXIS_TYPE2) => {\n  POLAR_AXIS_TYPE2[\"ANGLE_CATEGORY\"] = \"angle-category\";\n  POLAR_AXIS_TYPE2[\"ANGLE_NUMBER\"] = \"angle-number\";\n  POLAR_AXIS_TYPE2[\"RADIUS_CATEGORY\"] = \"radius-category\";\n  POLAR_AXIS_TYPE2[\"RADIUS_NUMBER\"] = \"radius-number\";\n  return POLAR_AXIS_TYPE2;\n})(POLAR_AXIS_TYPE || {});\nvar POLAR_AXIS_SHAPE = /* @__PURE__ */ ((POLAR_AXIS_SHAPE2) => {\n  POLAR_AXIS_SHAPE2[\"CIRCLE\"] = \"circle\";\n  POLAR_AXIS_SHAPE2[\"POLYGON\"] = \"polygon\";\n  return POLAR_AXIS_SHAPE2;\n})(POLAR_AXIS_SHAPE || {});\n\n// packages/ag-charts-community/src/chart/themes/symbols.ts\nvar IS_DARK_THEME = Symbol(\"is-dark-theme\");\nvar IS_COMMUNITY = Symbol(\"is-community\");\nvar IS_ENTERPRISE = Symbol(\"is-enterprise\");\nvar DEFAULT_FONT_FAMILY = Symbol(\"default-font\");\nvar DEFAULT_LABEL_COLOUR = Symbol(\"default-label-colour\");\nvar DEFAULT_INVERTED_LABEL_COLOUR = Symbol(\"default-inverted-label-colour\");\nvar DEFAULT_INSIDE_SERIES_LABEL_COLOUR = Symbol(\"default-inside-series-label-colour\");\nvar DEFAULT_MUTED_LABEL_COLOUR = Symbol(\"default-muted-label-colour\");\nvar DEFAULT_AXIS_GRID_COLOUR = Symbol(\"default-axis-grid-colour\");\nvar DEFAULT_AXIS_LINE_COLOUR = Symbol(\"default-axis-line-colour\");\nvar DEFAULT_CROSS_LINES_COLOUR = Symbol(\"default-cross-lines-colour\");\nvar DEFAULT_BACKGROUND_COLOUR = Symbol(\"default-background-colour\");\nvar DEFAULT_SHADOW_COLOUR = Symbol(\"default-shadow-colour\");\nvar DEFAULT_COLOURS = Symbol(\"default-colours\");\nvar DEFAULT_PADDING = Symbol(\"default-padding\");\nvar DEFAULT_CAPTION_LAYOUT_STYLE = Symbol(\"default-caption-layout-style\");\nvar DEFAULT_CAPTION_ALIGNMENT = Symbol(\"default-caption-alignment\");\nvar PALETTE_UP_STROKE = Symbol(\"palette-up-stroke\");\nvar PALETTE_DOWN_STROKE = Symbol(\"palette-down-stroke\");\nvar PALETTE_UP_FILL = Symbol(\"palette-up-fill\");\nvar PALETTE_DOWN_FILL = Symbol(\"palette-down-fill\");\nvar PALETTE_NEUTRAL_STROKE = Symbol(\"palette-neutral-stroke\");\nvar PALETTE_NEUTRAL_FILL = Symbol(\"palette-neutral-fill\");\nvar PALETTE_ALT_UP_STROKE = Symbol(\"palette-alt-up-stroke\");\nvar PALETTE_ALT_DOWN_STROKE = Symbol(\"palette-alt-down-stroke\");\nvar PALETTE_ALT_UP_FILL = Symbol(\"palette-alt-up-fill\");\nvar PALETTE_ALT_DOWN_FILL = Symbol(\"palette-alt-down-fill\");\nvar PALETTE_ALT_NEUTRAL_FILL = Symbol(\"palette-gray-fill\");\nvar PALETTE_ALT_NEUTRAL_STROKE = Symbol(\"palette-gray-stroke\");\nvar DEFAULT_POLAR_SERIES_STROKE = Symbol(\"default-polar-series-stroke\");\nvar DEFAULT_DIVERGING_SERIES_COLOR_RANGE = Symbol(\n  \"default-diverging-series-colour-range\"\n);\nvar DEFAULT_GAUGE_SERIES_COLOR_RANGE = Symbol(\"default-gauge-series-colour-range\");\nvar DEFAULT_FUNNEL_SERIES_COLOR_RANGE = Symbol(\"default-funnel-series-colour-range\");\nvar DEFAULT_HIERARCHY_FILLS = Symbol(\"default-hierarchy-fills\");\nvar DEFAULT_HIERARCHY_STROKES = Symbol(\"default-hierarchy-strokes\");\nvar DEFAULT_ANNOTATION_COLOR = Symbol(\"default-annotation-stroke\");\nvar DEFAULT_TEXT_ANNOTATION_COLOR = Symbol(\"default-text-annotation-color\");\nvar DEFAULT_ANNOTATION_BACKGROUND_FILL = Symbol(\"default-annotation-background-fill\");\nvar DEFAULT_ANNOTATION_HANDLE_FILL = Symbol(\"default-annotation-handle-fill\");\nvar DEFAULT_ANNOTATION_STATISTICS_FILL = Symbol(\"default-annotation-statistics-fill\");\nvar DEFAULT_ANNOTATION_STATISTICS_STROKE = Symbol(\"default-annotation-statistics-stroke\");\nvar DEFAULT_ANNOTATION_STATISTICS_COLOR = Symbol(\"default-annotation-statistics-color\");\nvar DEFAULT_ANNOTATION_STATISTICS_DIVIDER_STROKE = Symbol(\n  \"default-annotation-statistics-divider-stroke\"\n);\nvar DEFAULT_ANNOTATION_STATISTICS_DOWN_FILL = Symbol(\n  \"default-annotation-statistics-fill\"\n);\nvar DEFAULT_ANNOTATION_STATISTICS_DOWN_STROKE = Symbol(\n  \"default-annotation-statistics-stroke\"\n);\nvar DEFAULT_TEXTBOX_FILL = Symbol(\"default-textbox-fill\");\nvar DEFAULT_TEXTBOX_STROKE = Symbol(\"default-textbox-stroke\");\nvar DEFAULT_TEXTBOX_COLOR = Symbol(\"default-textbox-color\");\nvar DEFAULT_TOOLBAR_POSITION = Symbol(\"default-toolbar-position\");\nvar DEFAULT_GRIDLINE_ENABLED = Symbol(\"default-gridline-enabled\");\n\n// packages/ag-charts-community/src/motion/pathMotion.ts\nfunction pathMotion(groupId, subId, animationManager, paths, fns) {\n  const { addPhaseFn, updatePhaseFn, removePhaseFn } = fns;\n  const animate = (phase, path, updateFn) => {\n    animationManager.animate({\n      id: `${groupId}_${subId}_${path.id}_${phase}`,\n      groupId,\n      from: 0,\n      to: 1,\n      ease: easeOut,\n      collapsable: false,\n      onUpdate(ratio2, preInit) {\n        if (preInit && phase !== \"removed\")\n          return;\n        path.path.clear(true);\n        updateFn(ratio2, path);\n        path.checkPathDirty();\n      },\n      onStop() {\n        if (phase !== \"added\")\n          return;\n        path.path.clear(true);\n        updateFn(1, path);\n        path.checkPathDirty();\n      },\n      phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[phase]\n    });\n  };\n  for (const path of paths) {\n    if (!animationManager.isSkipped()) {\n      animate(\"removed\", path, removePhaseFn);\n      animate(\"updated\", path, updatePhaseFn);\n    }\n    animate(\"added\", path, addPhaseFn);\n  }\n}\n\n// packages/ag-charts-community/src/util/format.util.ts\nfunction formatValue(value) {\n  if (typeof value === \"number\") {\n    return value.toFixed(2);\n  }\n  return String(value ?? \"\");\n}\n\n// packages/ag-charts-community/src/util/sanitize.ts\nvar element = null;\nfunction sanitizeHtml(text) {\n  if (text == null) {\n    return;\n  } else if (text === \"\") {\n    return \"\";\n  }\n  element ?? (element = createElement(\"div\"));\n  element.textContent = String(text);\n  return element.innerHTML;\n}\n\n// packages/ag-charts-community/src/util/memo.ts\nvar memorizedFns = /* @__PURE__ */ new WeakMap();\nfunction memo(params, fnGenerator) {\n  const serialisedParams = JSON.stringify(params, null, 0);\n  if (!memorizedFns.has(fnGenerator)) {\n    memorizedFns.set(fnGenerator, /* @__PURE__ */ new Map());\n  }\n  if (!memorizedFns.get(fnGenerator)?.has(serialisedParams)) {\n    memorizedFns.get(fnGenerator)?.set(serialisedParams, fnGenerator(params));\n  }\n  return memorizedFns.get(fnGenerator)?.get(serialisedParams);\n}\n\n// packages/ag-charts-community/src/chart/data/aggregateFunctions.ts\nfunction sumValues(values, accumulator = [0, 0]) {\n  for (const value of values) {\n    if (typeof value !== \"number\") {\n      continue;\n    }\n    if (value < 0) {\n      accumulator[0] += value;\n    }\n    if (value > 0) {\n      accumulator[1] += value;\n    }\n  }\n  return accumulator;\n}\nfunction sum(id, matchGroupId) {\n  const result = {\n    id,\n    matchGroupIds: [matchGroupId],\n    type: \"aggregate\",\n    aggregateFunction: (values) => sumValues(values)\n  };\n  return result;\n}\nfunction groupSum(id, matchGroupId) {\n  return {\n    id,\n    type: \"aggregate\",\n    matchGroupIds: matchGroupId ? [matchGroupId] : void 0,\n    aggregateFunction: (values) => sumValues(values),\n    groupAggregateFunction: (next, acc = [0, 0]) => {\n      acc[0] += next?.[0] ?? 0;\n      acc[1] += next?.[1] ?? 0;\n      return acc;\n    }\n  };\n}\nfunction range2(id, matchGroupId) {\n  const result = {\n    id,\n    matchGroupIds: [matchGroupId],\n    type: \"aggregate\",\n    aggregateFunction: (values) => ContinuousDomain.extendDomain(values)\n  };\n  return result;\n}\nfunction groupCount(id) {\n  return {\n    id,\n    type: \"aggregate\",\n    aggregateFunction: () => [0, 1],\n    groupAggregateFunction: (next, acc = [0, 0]) => {\n      acc[0] += next?.[0] ?? 0;\n      acc[1] += next?.[1] ?? 0;\n      return acc;\n    }\n  };\n}\nfunction groupAverage(id, matchGroupId) {\n  const def = {\n    id,\n    matchGroupIds: matchGroupId ? [matchGroupId] : void 0,\n    type: \"aggregate\",\n    aggregateFunction: (values) => sumValues(values),\n    groupAggregateFunction: (next, acc = [0, 0, -1]) => {\n      acc[0] += next?.[0] ?? 0;\n      acc[1] += next?.[1] ?? 0;\n      acc[2]++;\n      return acc;\n    },\n    finalFunction: (acc = [0, 0, 0]) => {\n      const result = acc[0] + acc[1];\n      if (result >= 0) {\n        return [0, result / acc[2]];\n      }\n      return [result / acc[2], 0];\n    }\n  };\n  return def;\n}\nfunction area(id, aggFn, matchGroupId) {\n  const result = {\n    id,\n    matchGroupIds: matchGroupId ? [matchGroupId] : void 0,\n    type: \"aggregate\",\n    aggregateFunction: (values, keyRange = []) => {\n      const keyWidth = keyRange[1] - keyRange[0];\n      return aggFn.aggregateFunction(values).map((v) => v / keyWidth);\n    }\n  };\n  if (aggFn.groupAggregateFunction) {\n    result.groupAggregateFunction = aggFn.groupAggregateFunction;\n  }\n  return result;\n}\nfunction accumulatedValue(onlyPositive) {\n  return () => {\n    let value = 0;\n    return (datum) => {\n      if (!isFiniteNumber(datum)) {\n        return datum;\n      }\n      value += onlyPositive ? Math.max(0, datum) : datum;\n      return value;\n    };\n  };\n}\nfunction trailingAccumulatedValue() {\n  return () => {\n    let value = 0;\n    return (datum) => {\n      if (!isFiniteNumber(datum)) {\n        return datum;\n      }\n      const trailingValue = value;\n      value += datum;\n      return trailingValue;\n    };\n  };\n}\n\n// packages/ag-charts-community/src/chart/data/processors.ts\nfunction basicContinuousCheckDatumValidation(value) {\n  return value != null && isContinuous(value);\n}\nfunction basicDiscreteCheckDatumValidation(value) {\n  return value != null;\n}\nfunction getValidationFn(scaleType) {\n  switch (scaleType) {\n    case \"number\":\n    case \"log\":\n    case \"ordinal-time\":\n    case \"time\":\n    case \"color\":\n      return basicContinuousCheckDatumValidation;\n    default:\n      return basicDiscreteCheckDatumValidation;\n  }\n}\nfunction getValueType(scaleType) {\n  switch (scaleType) {\n    case \"number\":\n    case \"log\":\n    case \"time\":\n    case \"color\":\n      return \"range\";\n    default:\n      return \"category\";\n  }\n}\nfunction keyProperty(propName, scaleType, opts = {}) {\n  const result = {\n    property: propName,\n    type: \"key\",\n    valueType: getValueType(scaleType),\n    validation: getValidationFn(scaleType),\n    ...opts\n  };\n  return result;\n}\nfunction valueProperty(propName, scaleType, opts = {}) {\n  const result = {\n    property: propName,\n    type: \"value\",\n    valueType: getValueType(scaleType),\n    validation: getValidationFn(scaleType),\n    ...opts\n  };\n  return result;\n}\nfunction rangedValueProperty(propName, opts = {}) {\n  const { min = -Infinity, max = Infinity, ...defOpts } = opts;\n  return {\n    type: \"value\",\n    property: propName,\n    valueType: \"range\",\n    validation: basicContinuousCheckDatumValidation,\n    processor: () => (datum) => isFiniteNumber(datum) ? clamp(min, datum, max) : datum,\n    ...defOpts\n  };\n}\nfunction accumulativeValueProperty(propName, scaleType, opts = {}) {\n  const { onlyPositive, ...defOpts } = opts;\n  const result = {\n    ...valueProperty(propName, scaleType, defOpts),\n    processor: accumulatedValue(onlyPositive)\n  };\n  return result;\n}\nfunction trailingAccumulatedValueProperty(propName, scaleType, opts = {}) {\n  const result = {\n    ...valueProperty(propName, scaleType, opts),\n    processor: trailingAccumulatedValue()\n  };\n  return result;\n}\nfunction groupAccumulativeValueProperty(propName, mode, sum2 = \"current\", opts, scaleType) {\n  return [\n    valueProperty(propName, scaleType, opts),\n    accumulateGroup(opts.groupId, mode, sum2, opts.separateNegative),\n    ...opts.rangeId != null ? [range2(opts.rangeId, opts.groupId)] : []\n  ];\n}\nfunction groupStackValueProperty(propName, scaleType, opts) {\n  return [valueProperty(propName, scaleType, opts), accumulateStack(opts.groupId)];\n}\nvar SMALLEST_KEY_INTERVAL = {\n  type: \"reducer\",\n  property: \"smallestKeyInterval\",\n  initialValue: Infinity,\n  reducer: () => {\n    let prevX = NaN;\n    return (smallestSoFar = Infinity, next) => {\n      const nextX = next.keys[0];\n      const interval = Math.abs(nextX - prevX);\n      prevX = nextX;\n      if (!isNaN(interval) && interval > 0 && interval < smallestSoFar) {\n        return interval;\n      }\n      return smallestSoFar;\n    };\n  }\n};\nvar LARGEST_KEY_INTERVAL = {\n  type: \"reducer\",\n  property: \"largestKeyInterval\",\n  initialValue: -Infinity,\n  reducer: () => {\n    let prevX = NaN;\n    return (largestSoFar = -Infinity, next) => {\n      const nextX = next.keys[0];\n      const interval = Math.abs(nextX - prevX);\n      prevX = nextX;\n      if (!isNaN(interval) && interval > 0 && interval > largestSoFar) {\n        return interval;\n      }\n      return largestSoFar;\n    };\n  }\n};\nvar SORT_DOMAIN_GROUPS = {\n  type: \"processor\",\n  property: \"sortedGroupDomain\",\n  calculate: ({ domain: { groups } }) => groups?.slice().sort((a, b) => {\n    for (let i = 0; i < a.length; i++) {\n      const result = a[i] - b[i];\n      if (result !== 0) {\n        return result;\n      }\n    }\n    return 0;\n  })\n};\nfunction normaliseFnBuilder({ normaliseTo, mode }) {\n  const normalise = (val, extent2) => {\n    const result = val * normaliseTo / extent2;\n    if (result >= 0) {\n      return Math.min(normaliseTo, result);\n    }\n    return Math.max(-normaliseTo, result);\n  };\n  return () => () => (values, valueIndexes) => {\n    const valuesExtent = [0, 0];\n    for (const valueIdx of valueIndexes) {\n      const value = values[valueIdx];\n      const valueExtent = typeof value === \"number\" ? value : Math.max(...value);\n      const valIdx = valueExtent < 0 ? 0 : 1;\n      if (mode === \"sum\") {\n        valuesExtent[valIdx] += valueExtent;\n      } else if (valIdx === 0) {\n        valuesExtent[valIdx] = Math.min(valuesExtent[valIdx], valueExtent);\n      } else {\n        valuesExtent[valIdx] = Math.max(valuesExtent[valIdx], valueExtent);\n      }\n    }\n    const extent2 = Math.max(Math.abs(valuesExtent[0]), valuesExtent[1]);\n    for (const valueIdx of valueIndexes) {\n      const value = values[valueIdx];\n      values[valueIdx] = typeof value === \"number\" ? normalise(value, extent2) : value.map((v) => normalise(v, extent2));\n    }\n  };\n}\nfunction normaliseGroupTo(matchGroupIds, normaliseTo, mode = \"sum\") {\n  return {\n    type: \"group-value-processor\",\n    matchGroupIds,\n    adjust: memo({ normaliseTo, mode }, normaliseFnBuilder)\n  };\n}\nfunction normalisePropertyFnBuilder({\n  normaliseTo,\n  zeroDomain,\n  rangeMin,\n  rangeMax\n}) {\n  const normaliseSpan = normaliseTo[1] - normaliseTo[0];\n  const normalise = (val, start2, span) => {\n    const result = normaliseTo[0] + (val - start2) / span * normaliseSpan;\n    if (span === 0) {\n      return zeroDomain;\n    } else if (result >= normaliseTo[1]) {\n      return normaliseTo[1];\n    } else if (result < normaliseTo[0]) {\n      return normaliseTo[0];\n    }\n    return result;\n  };\n  return () => (pData, pIdx) => {\n    let [start2, end2] = pData.domain.values[pIdx];\n    if (rangeMin != null)\n      start2 = rangeMin;\n    if (rangeMax != null)\n      end2 = rangeMax;\n    const span = end2 - start2;\n    pData.domain.values[pIdx] = [normaliseTo[0], normaliseTo[1]];\n    for (const group of pData.data) {\n      let groupValues = group.values;\n      if (pData.type === \"ungrouped\") {\n        groupValues = [groupValues];\n      }\n      for (const values of groupValues) {\n        values[pIdx] = normalise(values[pIdx], start2, span);\n      }\n    }\n  };\n}\nfunction normalisePropertyTo(property, normaliseTo, zeroDomain, rangeMin, rangeMax) {\n  return {\n    type: \"property-value-processor\",\n    property,\n    adjust: memo({ normaliseTo, rangeMin, rangeMax, zeroDomain }, normalisePropertyFnBuilder)\n  };\n}\nfunction animationValidation(valueKeyIds) {\n  return {\n    type: \"processor\",\n    property: \"animationValidation\",\n    calculate(result) {\n      const { keys, values } = result.defs;\n      const { input, data } = result;\n      let uniqueKeys = true;\n      let orderedKeys = true;\n      const valueKeys = [];\n      for (let k = 0; k < values.length; k++) {\n        if (!valueKeyIds?.includes(values[k].id))\n          continue;\n        valueKeys.push([k, values[k]]);\n      }\n      const processKey = (idx, def, type) => {\n        if (def.valueType === \"category\") {\n          const keyValues = result.domain[type][idx];\n          uniqueKeys && (uniqueKeys = keyValues.length === input.count);\n          return;\n        }\n        let lastValue = data[0]?.[type][idx];\n        for (let d = 1; (uniqueKeys || orderedKeys) && d < data.length; d++) {\n          const keyValue = data[d][type][idx];\n          orderedKeys && (orderedKeys = lastValue <= keyValue);\n          uniqueKeys && (uniqueKeys = lastValue !== keyValue);\n          lastValue = keyValue;\n        }\n      };\n      for (let k = 0; (uniqueKeys || orderedKeys) && k < keys.length; k++) {\n        processKey(k, keys[k], \"keys\");\n      }\n      for (let k = 0; (uniqueKeys || orderedKeys) && k < valueKeys.length; k++) {\n        const [idx, key] = valueKeys[k];\n        processKey(idx, key, \"values\");\n      }\n      return { uniqueKeys, orderedKeys };\n    }\n  };\n}\nfunction buildGroupAccFn({ mode, separateNegative }) {\n  return () => () => (values, valueIndexes) => {\n    const acc = [0, 0];\n    for (const valueIdx of valueIndexes) {\n      const currentVal = values[valueIdx];\n      const accIndex = isNegative(currentVal) && separateNegative ? 0 : 1;\n      if (!isFiniteNumber(currentVal))\n        continue;\n      if (mode === \"normal\")\n        acc[accIndex] += currentVal;\n      values[valueIdx] = acc[accIndex];\n      if (mode === \"trailing\")\n        acc[accIndex] += currentVal;\n    }\n  };\n}\nfunction buildGroupWindowAccFn({ mode, sum: sum2 }) {\n  return () => {\n    const lastValues = [];\n    let firstRow = true;\n    return () => {\n      return (values, valueIndexes) => {\n        let acc = 0;\n        for (const valueIdx of valueIndexes) {\n          const currentVal = values[valueIdx];\n          const lastValue = firstRow && sum2 === \"current\" ? 0 : lastValues[valueIdx];\n          lastValues[valueIdx] = currentVal;\n          const sumValue = sum2 === \"current\" ? currentVal : lastValue;\n          if (!isFiniteNumber(currentVal) || !isFiniteNumber(lastValue)) {\n            values[valueIdx] = acc;\n            continue;\n          }\n          if (mode === \"normal\") {\n            acc += sumValue;\n          }\n          values[valueIdx] = acc;\n          if (mode === \"trailing\") {\n            acc += sumValue;\n          }\n        }\n        firstRow = false;\n      };\n    };\n  };\n}\nfunction accumulateGroup(matchGroupId, mode, sum2, separateNegative = false) {\n  let adjust;\n  if (mode.startsWith(\"window\")) {\n    const modeParam = mode.endsWith(\"-trailing\") ? \"trailing\" : \"normal\";\n    adjust = memo({ mode: modeParam, sum: sum2 }, buildGroupWindowAccFn);\n  } else {\n    adjust = memo({ mode, separateNegative }, buildGroupAccFn);\n  }\n  return {\n    type: \"group-value-processor\",\n    matchGroupIds: [matchGroupId],\n    adjust\n  };\n}\nfunction groupStackAccFn() {\n  return () => (values, valueIndexes) => {\n    const acc = new Float64Array(32);\n    let stackCount = 0;\n    for (const valueIdx of valueIndexes) {\n      const currentValue = values[valueIdx];\n      acc[stackCount] = Number.isFinite(currentValue) ? currentValue : NaN;\n      stackCount += 1;\n      values[valueIdx] = acc.subarray(0, stackCount);\n    }\n  };\n}\nfunction accumulateStack(matchGroupId) {\n  return {\n    type: \"group-value-processor\",\n    matchGroupIds: [matchGroupId],\n    adjust: groupStackAccFn\n  };\n}\nfunction diff(previousData, updateMovedData = true) {\n  return {\n    type: \"processor\",\n    property: \"diff\",\n    calculate: (processedData) => {\n      const moved = /* @__PURE__ */ new Map();\n      const added = /* @__PURE__ */ new Map();\n      const updated = /* @__PURE__ */ new Map();\n      const removed = /* @__PURE__ */ new Map();\n      const length2 = Math.max(previousData.data.length, processedData.data.length);\n      for (let i = 0; i < length2; i++) {\n        const prev = previousData.data[i];\n        const datum = processedData.data[i];\n        const prevId = prev ? createDatumId(prev.keys) : \"\";\n        const datumId = datum ? createDatumId(datum.keys) : \"\";\n        if (datum && prev && prevId === datumId) {\n          if (!arraysEqual(prev.values, datum.values)) {\n            updated.set(datumId, datum);\n          }\n          continue;\n        }\n        if (removed.has(datumId)) {\n          if (updateMovedData || !arraysEqual(removed.get(datumId).values, datum.values)) {\n            updated.set(datumId, datum);\n            moved.set(datumId, datum);\n          }\n          removed.delete(datumId);\n        } else if (datum) {\n          added.set(datumId, datum);\n        }\n        if (added.has(prevId)) {\n          if (updateMovedData || !arraysEqual(added.get(prevId).values, prev.values)) {\n            updated.set(prevId, prev);\n            moved.set(prevId, prev);\n          }\n          added.delete(prevId);\n        } else if (prev) {\n          updated.delete(prevId);\n          removed.set(prevId, prev);\n        }\n      }\n      const changed = added.size > 0 || updated.size > 0 || removed.size > 0;\n      return { changed, added, updated, removed, moved };\n    }\n  };\n}\nfunction createDatumId(keys, ...extraKeys) {\n  let result;\n  if (isArray(keys)) {\n    result = keys.map((key) => transformIntegratedCategoryValue(key)).join(\"___\");\n  } else {\n    result = transformIntegratedCategoryValue(keys);\n  }\n  const primitiveType = typeof result === \"string\" || typeof result === \"number\" || typeof result === \"boolean\" || result instanceof Date;\n  if (primitiveType && extraKeys.length > 0) {\n    result += `___${extraKeys.join(\"___\")}`;\n  }\n  return result;\n}\n\n// packages/ag-charts-community/src/chart/series/seriesLabelUtil.ts\nfunction seriesLabelFadeInAnimation({ id }, subId, animationManager, ...labelSelections) {\n  staticFromToMotion(\n    id,\n    subId,\n    animationManager,\n    labelSelections,\n    { opacity: 0 },\n    { opacity: 1 },\n    { phase: \"trailing\" }\n  );\n}\nfunction seriesLabelFadeOutAnimation({ id }, subId, animationManager, ...labelSelections) {\n  staticFromToMotion(\n    id,\n    subId,\n    animationManager,\n    labelSelections,\n    { opacity: 1 },\n    { opacity: 0 },\n    { phase: \"remove\" }\n  );\n}\nfunction resetLabelFn(_node) {\n  return { opacity: 1 };\n}\n\n// packages/ag-charts-community/src/scene/util/changeDetectableProperties.ts\nvar ChangeDetectableProperties = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this._dirty = 3 /* MAJOR */;\n  }\n  markDirty(type = 1 /* TRIVIAL */) {\n    if (this._dirty < type) {\n      this._dirty = type;\n    }\n  }\n  markClean(_opts) {\n    this._dirty = 0 /* NONE */;\n  }\n  isDirty() {\n    return this._dirty > 0 /* NONE */;\n  }\n};\n\n// packages/ag-charts-community/src/scene/dropShadow.ts\nvar DropShadow = class extends ChangeDetectableProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n    this.color = \"rgba(0, 0, 0, 0.5)\";\n    this.xOffset = 0;\n    this.yOffset = 0;\n    this.blur = 5;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], DropShadow.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(COLOR_STRING),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], DropShadow.prototype, \"color\", 2);\n__decorateClass([\n  Validate(NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], DropShadow.prototype, \"xOffset\", 2);\n__decorateClass([\n  Validate(NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], DropShadow.prototype, \"yOffset\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], DropShadow.prototype, \"blur\", 2);\n\n// packages/ag-charts-community/src/chart/series/seriesMarker.ts\nvar MARKER_SHAPE = predicateWithMessage(\n  (value) => isMarkerShape(value) || typeof value === \"function\" && Object.create(value.prototype) instanceof Marker,\n  `a marker shape keyword such as 'circle', 'diamond' or 'square' or an object extending the Marker class`\n);\nvar SeriesMarker = class extends ChangeDetectableProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n    this.shape = Circle;\n    this.size = 6;\n    this.fillOpacity = 1;\n    this.strokeWidth = 1;\n    this.strokeOpacity = 1;\n  }\n  getStyle() {\n    const { size, shape, fill, fillOpacity, stroke, strokeWidth, strokeOpacity } = this;\n    return { size, shape, fill, fillOpacity, stroke, strokeWidth, strokeOpacity };\n  }\n  getDiameter() {\n    return this.size + this.strokeWidth;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(MARKER_SHAPE),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"shape\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"size\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true }),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true }),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true }),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"itemStyler\", 2);\n\n// packages/ag-charts-community/src/chart/series/seriesTooltip.ts\nvar SeriesTooltipInteraction = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = false;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], SeriesTooltipInteraction.prototype, \"enabled\", 2);\nvar SeriesTooltip = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n    this.interaction = new SeriesTooltipInteraction();\n    this.position = new TooltipPosition();\n    this.range = void 0;\n  }\n  toTooltipHtml(defaults, params) {\n    if (this.renderer) {\n      return toTooltipHtml(this.renderer(params), defaults);\n    }\n    return toTooltipHtml(defaults);\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], SeriesTooltip.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], SeriesTooltip.prototype, \"showArrow\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], SeriesTooltip.prototype, \"renderer\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], SeriesTooltip.prototype, \"interaction\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], SeriesTooltip.prototype, \"position\", 2);\n__decorateClass([\n  Validate(INTERACTION_RANGE, { optional: true })\n], SeriesTooltip.prototype, \"range\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/interpolationProperties.ts\nvar INTERPOLATION_TYPE = UNION([\"linear\", \"smooth\", \"step\"], \"a line style\");\nvar INTERPOLATION_STEP_POSITION = UNION([\"start\", \"middle\", \"end\"]);\nvar InterpolationProperties = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.type = \"linear\";\n    this.tension = 1;\n    this.position = \"end\";\n  }\n};\n__decorateClass([\n  Validate(INTERPOLATION_TYPE)\n], InterpolationProperties.prototype, \"type\", 2);\n__decorateClass([\n  Validate(RATIO)\n], InterpolationProperties.prototype, \"tension\", 2);\n__decorateClass([\n  Validate(INTERPOLATION_STEP_POSITION)\n], InterpolationProperties.prototype, \"position\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/areaSeriesProperties.ts\nvar AreaSeriesProperties = class extends CartesianSeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.xName = void 0;\n    this.fill = \"#c16068\";\n    this.fillOpacity = 1;\n    this.stroke = \"#874349\";\n    this.strokeWidth = 2;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.interpolation = new InterpolationProperties();\n    this.shadow = new DropShadow();\n    this.marker = new SeriesMarker();\n    this.label = new Label();\n    this.tooltip = new SeriesTooltip();\n    this.connectMissingData = false;\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], AreaSeriesProperties.prototype, \"xKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], AreaSeriesProperties.prototype, \"xName\", 2);\n__decorateClass([\n  Validate(STRING)\n], AreaSeriesProperties.prototype, \"yKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], AreaSeriesProperties.prototype, \"yName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], AreaSeriesProperties.prototype, \"yFilterKey\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], AreaSeriesProperties.prototype, \"normalizedTo\", 2);\n__decorateClass([\n  Validate(COLOR_STRING)\n], AreaSeriesProperties.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO)\n], AreaSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(COLOR_STRING)\n], AreaSeriesProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AreaSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO)\n], AreaSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH)\n], AreaSeriesProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AreaSeriesProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], AreaSeriesProperties.prototype, \"interpolation\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], AreaSeriesProperties.prototype, \"shadow\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], AreaSeriesProperties.prototype, \"marker\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], AreaSeriesProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], AreaSeriesProperties.prototype, \"tooltip\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], AreaSeriesProperties.prototype, \"connectMissingData\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/lineInterpolation.ts\nfunction spanRange(span) {\n  switch (span.type) {\n    case \"linear\":\n    case \"step\":\n      return [\n        { x: span.x0, y: span.y0 },\n        { x: span.x1, y: span.y1 }\n      ];\n    case \"cubic\":\n      return [\n        { x: span.cp0x, y: span.cp0y },\n        { x: span.cp3x, y: span.cp3y }\n      ];\n  }\n}\nfunction spanRangeNormalized(span) {\n  const range3 = spanRange(span);\n  if (range3[0].x > range3[1].x) {\n    range3.reverse();\n  }\n  return range3;\n}\nfunction rescaleSpan(span, nextStart, nextEnd) {\n  const [prevStart, prevEnd] = spanRange(span);\n  const widthScale = prevEnd.x !== prevStart.x ? (nextEnd.x - nextStart.x) / (prevEnd.x - prevStart.x) : 0;\n  const heightScale = prevEnd.y !== prevStart.y ? (nextEnd.y - nextStart.y) / (prevEnd.y - prevStart.y) : 0;\n  switch (span.type) {\n    case \"linear\":\n      return {\n        type: \"linear\",\n        moveTo: span.moveTo,\n        x0: nextStart.x,\n        y0: nextStart.y,\n        x1: nextEnd.x,\n        y1: nextEnd.y\n      };\n    case \"cubic\":\n      return {\n        type: \"cubic\",\n        moveTo: span.moveTo,\n        cp0x: nextStart.x,\n        cp0y: nextStart.y,\n        cp1x: nextEnd.x - (span.cp2x - prevStart.x) * widthScale,\n        cp1y: nextEnd.y - (span.cp2y - prevStart.y) * heightScale,\n        cp2x: nextEnd.x - (span.cp1x - prevStart.x) * widthScale,\n        cp2y: nextEnd.y - (span.cp1y - prevStart.y) * heightScale,\n        cp3x: nextEnd.x,\n        cp3y: nextEnd.y\n      };\n    case \"step\":\n      return {\n        type: \"step\",\n        moveTo: span.moveTo,\n        x0: nextStart.x,\n        y0: nextStart.y,\n        x1: nextEnd.x,\n        y1: nextEnd.y,\n        stepX: nextEnd.x - (span.stepX - prevStart.x) * widthScale\n      };\n  }\n}\nfunction clipSpanX(span, x0, x1) {\n  const { moveTo } = span;\n  const [start2, end2] = spanRangeNormalized(span);\n  const { x: spanX0, y: spanY0 } = start2;\n  const { x: spanX1, y: spanY1 } = end2;\n  if (x1 < spanX0) {\n    return rescaleSpan(span, start2, start2);\n  } else if (x0 > spanX1) {\n    return rescaleSpan(span, end2, end2);\n  }\n  switch (span.type) {\n    case \"linear\": {\n      const m = spanY0 === spanY1 ? void 0 : (spanY1 - spanY0) / (spanX1 - spanX0);\n      const y0 = m == null ? spanY0 : m * (x0 - spanX0) + spanY0;\n      const y1 = m == null ? spanY0 : m * (x1 - spanX0) + spanY0;\n      return { type: \"linear\", moveTo, x0, y0, x1, y1 };\n    }\n    case \"step\":\n      if (x1 <= span.stepX) {\n        const y = span.y0;\n        return { type: \"step\", moveTo, x0, y0: y, x1, y1: y, stepX: x1 };\n      } else if (x0 >= span.stepX) {\n        const y = span.y1;\n        return { type: \"step\", moveTo, x0, y0: y, x1, y1: y, stepX: x0 };\n      } else {\n        const { y0, y1, stepX } = span;\n        return { type: \"step\", moveTo, x0, y0, x1, y1, stepX };\n      }\n    case \"cubic\": {\n      const t0 = solveBezier(span.cp0x, span.cp1x, span.cp2x, span.cp3x, x0);\n      let [_unused, bezier] = splitBezier(\n        span.cp0x,\n        span.cp0y,\n        span.cp1x,\n        span.cp1y,\n        span.cp2x,\n        span.cp2y,\n        span.cp3x,\n        span.cp3y,\n        t0\n      );\n      const t1 = solveBezier(bezier[0].x, bezier[1].x, bezier[2].x, bezier[3].x, x1);\n      [bezier, _unused] = splitBezier(\n        bezier[0].x,\n        bezier[0].y,\n        bezier[1].x,\n        bezier[1].y,\n        bezier[2].x,\n        bezier[2].y,\n        bezier[3].x,\n        bezier[3].y,\n        t1\n      );\n      return {\n        type: \"cubic\",\n        moveTo,\n        cp0x: bezier[0].x,\n        cp0y: bezier[0].y,\n        cp1x: bezier[1].x,\n        cp1y: bezier[1].y,\n        cp2x: bezier[2].x,\n        cp2y: bezier[2].y,\n        cp3x: bezier[3].x,\n        cp3y: bezier[3].y\n      };\n    }\n  }\n}\nfunction linearPoints(points) {\n  const spans = [];\n  let i = 0;\n  let x0 = NaN;\n  let y0 = NaN;\n  for (const { x: x1, y: y1 } of points) {\n    if (i > 0) {\n      const moveTo = i === 1;\n      spans.push({ type: \"linear\", moveTo, x0, y0, x1, y1 });\n    }\n    i += 1;\n    x0 = x1;\n    y0 = y1;\n  }\n  return spans;\n}\nvar lineSteps = {\n  start: 0,\n  middle: 0.5,\n  end: 1\n};\nfunction stepPoints(points, position) {\n  const spans = [];\n  let i = 0;\n  let x0 = NaN;\n  let y0 = NaN;\n  const p0 = typeof position === \"number\" ? position : lineSteps[position];\n  for (const { x: x1, y: y1 } of points) {\n    if (i > 0) {\n      const moveTo = i === 1;\n      const stepX = x0 + (x1 - x0) * p0;\n      spans.push({ type: \"step\", moveTo, x0, y0, x1, y1, stepX });\n    }\n    i += 1;\n    x0 = x1;\n    y0 = y1;\n  }\n  return spans;\n}\nvar flatnessRatio = 0.05;\nfunction smoothPoints(iPoints, tension) {\n  const points = Array.isArray(iPoints) ? iPoints : Array.from(iPoints);\n  if (points.length <= 1)\n    return [];\n  const gradients = points.map((c, i) => {\n    const p = i === 0 ? c : points[i - 1];\n    const n = i === points.length - 1 ? c : points[i + 1];\n    const isTerminalPoint = i === 0 || i === points.length - 1;\n    if (Math.sign(p.y - c.y) === Math.sign(n.y - c.y)) {\n      return 0;\n    }\n    if (!isTerminalPoint) {\n      const range3 = Math.abs(p.y - n.y);\n      const prevRatio = Math.abs(c.y - p.y) / range3;\n      const nextRatio = Math.abs(c.y - n.y) / range3;\n      if (prevRatio <= flatnessRatio || 1 - prevRatio <= flatnessRatio || nextRatio <= flatnessRatio || 1 - nextRatio <= flatnessRatio) {\n        return 0;\n      }\n    }\n    return (n.y - p.y) / (n.x - p.x);\n  });\n  if (gradients[1] === 0) {\n    gradients[0] *= 2;\n  }\n  if (gradients[gradients.length - 2] === 0) {\n    gradients[gradients.length - 1] *= 2;\n  }\n  const spans = [];\n  for (let i = 1; i < points.length; i += 1) {\n    const prev = points[i - 1];\n    const prevM = gradients[i - 1];\n    const cur = points[i];\n    const curM = gradients[i];\n    const dx = cur.x - prev.x;\n    const dy = cur.y - prev.y;\n    let dcp1x = dx * tension / 3;\n    let dcp1y = dx * prevM * tension / 3;\n    let dcp2x = dx * tension / 3;\n    let dcp2y = dx * curM * tension / 3;\n    if (curM === 0 && Math.abs(dcp1y) > Math.abs(dy)) {\n      dcp1x *= Math.abs(dy / dcp1y);\n      dcp1y = Math.sign(dcp1y) * Math.abs(dy);\n    }\n    if (prevM === 0 && Math.abs(dcp2y) > Math.abs(dy)) {\n      dcp2x *= Math.abs(dy / dcp2y);\n      dcp2y = Math.sign(dcp2y) * Math.abs(dy);\n    }\n    spans.push({\n      type: \"cubic\",\n      moveTo: i === 1,\n      cp0x: prev.x,\n      cp0y: prev.y,\n      cp1x: prev.x + dcp1x,\n      cp1y: prev.y + dcp1y,\n      cp2x: cur.x - dcp2x,\n      cp2y: cur.y - dcp2y,\n      cp3x: cur.x,\n      cp3y: cur.y\n    });\n  }\n  return spans;\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/lineInterpolationPlotting.ts\nfunction lerp2(a, b, ratio2) {\n  return (b - a) * ratio2 + a;\n}\nfunction linearSupertype(span, stepX) {\n  const { x0, y0, x1, y1 } = span;\n  const m = (y1 - y0) / (x1 - x0);\n  const stepY = m * (stepX - x0) + y0;\n  return {\n    leftCp1x: x0,\n    leftCp1y: y0,\n    leftCp2x: stepX,\n    leftCp2y: stepY,\n    stepX,\n    stepY0: stepY,\n    stepY1: stepY,\n    rightCp1x: stepX,\n    rightCp1y: stepY,\n    rightCp2x: x1,\n    rightCp2y: y1\n  };\n}\nfunction bezierSupertype(span, stepX) {\n  const { cp0x, cp0y, cp1x, cp1y, cp2x, cp2y, cp3x, cp3y } = span;\n  const t = solveBezier(cp0x, cp1x, cp2x, cp3x, stepX);\n  const [left, right] = splitBezier(cp0x, cp0y, cp1x, cp1y, cp2x, cp2y, cp3x, cp3y, t);\n  const stepY = left[3].y;\n  return {\n    leftCp1x: left[1].x,\n    leftCp1y: left[1].y,\n    leftCp2x: left[2].x,\n    leftCp2y: left[2].y,\n    stepX,\n    stepY0: stepY,\n    stepY1: stepY,\n    rightCp1x: right[1].x,\n    rightCp1y: right[1].y,\n    rightCp2x: right[2].x,\n    rightCp2y: right[2].y\n  };\n}\nfunction stepSupertype(span) {\n  const { x0, y0, x1, y1, stepX } = span;\n  return {\n    leftCp1x: (x0 + stepX) / 2,\n    leftCp1y: y0,\n    leftCp2x: (x0 + stepX) / 2,\n    leftCp2y: y0,\n    stepX,\n    stepY0: y0,\n    stepY1: y1,\n    rightCp1x: (stepX + x1) / 2,\n    rightCp1y: y1,\n    rightCp2x: (stepX + x1) / 2,\n    rightCp2y: y1\n  };\n}\nfunction spanSupertype(span, stepX) {\n  if (span.type === \"linear\") {\n    return linearSupertype(span, stepX);\n  } else if (span.type === \"cubic\") {\n    return bezierSupertype(span, stepX);\n  } else {\n    return stepSupertype(span);\n  }\n}\nfunction plotStart(path, moveTo, x0, y0, x1, y1, reversed) {\n  switch (moveTo) {\n    case 1 /* MoveTo */:\n      if (reversed) {\n        path.moveTo(x1, y1);\n      } else {\n        path.moveTo(x0, y0);\n      }\n      break;\n    case 2 /* LineTo */:\n      if (reversed) {\n        path.lineTo(x1, y1);\n      } else {\n        path.lineTo(x0, y0);\n      }\n      break;\n  }\n}\nfunction plotLinear(path, x0, y0, x1, y1, reversed) {\n  if (reversed) {\n    path.lineTo(x0, y0);\n  } else {\n    path.lineTo(x1, y1);\n  }\n}\nfunction plotCubic(path, cp0x, cp0y, cp1x, cp1y, cp2x, cp2y, cp3x, cp3y, reversed) {\n  if (reversed) {\n    path.cubicCurveTo(cp2x, cp2y, cp1x, cp1y, cp0x, cp0y);\n  } else {\n    path.cubicCurveTo(cp1x, cp1y, cp2x, cp2y, cp3x, cp3y);\n  }\n}\nfunction plotStep(path, x0, y0, x1, y1, stepX, reversed) {\n  if (reversed) {\n    path.lineTo(stepX, y1);\n    path.lineTo(stepX, y0);\n    path.lineTo(x0, y0);\n  } else {\n    path.lineTo(stepX, y0);\n    path.lineTo(stepX, y1);\n    path.lineTo(x1, y1);\n  }\n}\nfunction plotSpan(path, span, moveTo, reversed) {\n  const [start2, end2] = spanRange(span);\n  plotStart(path, moveTo, start2.x, start2.y, end2.x, end2.y, reversed);\n  switch (span.type) {\n    case \"linear\":\n      plotLinear(path, span.x0, span.y0, span.x1, span.y1, reversed);\n      break;\n    case \"cubic\":\n      plotCubic(\n        path,\n        span.cp0x,\n        span.cp0y,\n        span.cp1x,\n        span.cp1y,\n        span.cp2x,\n        span.cp2y,\n        span.cp3x,\n        span.cp3y,\n        reversed\n      );\n      break;\n    case \"step\":\n      plotStep(path, span.x0, span.y0, span.x1, span.y1, span.stepX, reversed);\n      break;\n  }\n}\nfunction plotInterpolatedSpans(path, a, b, ratio2, moveTo, reversed) {\n  const [aStart, aEnd] = spanRange(a);\n  const [bStart, bEnd] = spanRange(b);\n  const x0 = lerp2(aStart.x, bStart.x, ratio2);\n  const y0 = lerp2(aStart.y, bStart.y, ratio2);\n  const x1 = lerp2(aEnd.x, bEnd.x, ratio2);\n  const y1 = lerp2(aEnd.y, bEnd.y, ratio2);\n  plotStart(path, moveTo, x0, y0, x1, y1, reversed);\n  if (a.type === \"cubic\" && b.type === \"cubic\") {\n    const cp1x = lerp2(a.cp1x, b.cp1x, ratio2);\n    const cp1y = lerp2(a.cp1y, b.cp1y, ratio2);\n    const cp2x = lerp2(a.cp2x, b.cp2x, ratio2);\n    const cp2y = lerp2(a.cp2y, b.cp2y, ratio2);\n    plotCubic(path, x0, y0, cp1x, cp1y, cp2x, cp2y, x1, y1, reversed);\n  } else if (a.type === \"step\" && b.type === \"step\") {\n    const stepX = lerp2(a.stepX, b.stepX, ratio2);\n    plotStep(path, x0, y0, x1, y1, stepX, reversed);\n  } else if (a.type === \"linear\" && b.type === \"linear\") {\n    plotLinear(path, x0, y0, x1, y1, reversed);\n  } else {\n    let defaultStepX;\n    if (a.type === \"step\") {\n      defaultStepX = a.stepX;\n    } else if (b.type === \"step\") {\n      defaultStepX = b.stepX;\n    } else {\n      defaultStepX = (x0 + x1) / 2;\n    }\n    const as = spanSupertype(a, defaultStepX);\n    const bs = spanSupertype(b, defaultStepX);\n    const leftCp1x = lerp2(as.leftCp1x, bs.leftCp1x, ratio2);\n    const leftCp1y = lerp2(as.leftCp1y, bs.leftCp1y, ratio2);\n    const leftCp2x = lerp2(as.leftCp2x, bs.leftCp2x, ratio2);\n    const leftCp2y = lerp2(as.leftCp2y, bs.leftCp2y, ratio2);\n    const stepX = lerp2(as.stepX, bs.stepX, ratio2);\n    const stepY0 = lerp2(as.stepY0, bs.stepY0, ratio2);\n    const stepY1 = lerp2(as.stepY1, bs.stepY1, ratio2);\n    const rightCp1x = lerp2(as.rightCp1x, bs.rightCp1x, ratio2);\n    const rightCp1y = lerp2(as.rightCp1y, bs.rightCp1y, ratio2);\n    const rightCp2x = lerp2(as.rightCp2x, bs.rightCp2x, ratio2);\n    const rightCp2y = lerp2(as.rightCp2y, bs.rightCp2y, ratio2);\n    if (reversed) {\n      path.cubicCurveTo(rightCp2x, rightCp2y, rightCp1x, rightCp1y, stepX, stepY1);\n      path.lineTo(stepX, stepY0);\n      path.cubicCurveTo(leftCp2x, leftCp2y, leftCp1x, leftCp1y, x0, y0);\n    } else {\n      path.cubicCurveTo(leftCp1x, leftCp1y, leftCp2x, leftCp2y, stepX, stepY0);\n      path.lineTo(stepX, stepY1);\n      path.cubicCurveTo(rightCp1x, rightCp1y, rightCp2x, rightCp2y, x1, y1);\n    }\n  }\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/markerUtil.ts\nfunction markerFadeInAnimation({ id }, animationManager, status, ...markerSelections) {\n  const params = { phase: status ? NODE_UPDATE_STATE_TO_PHASE_MAPPING[status] : \"trailing\" };\n  staticFromToMotion(id, \"markers\", animationManager, markerSelections, { opacity: 0 }, { opacity: 1 }, params);\n  markerSelections.forEach((s) => s.cleanup());\n}\nfunction markerScaleInAnimation({ id }, animationManager, ...markerSelections) {\n  staticFromToMotion(\n    id,\n    \"markers\",\n    animationManager,\n    markerSelections,\n    { scalingX: 0, scalingY: 0 },\n    { scalingX: 1, scalingY: 1 },\n    { phase: \"initial\" }\n  );\n  markerSelections.forEach((s) => s.cleanup());\n}\nfunction markerSwipeScaleInAnimation({ id, nodeDataDependencies }, animationManager, ...markerSelections) {\n  const seriesWidth = nodeDataDependencies.seriesRectWidth;\n  const fromFn = (_, datum) => {\n    const x = datum.midPoint?.x ?? seriesWidth;\n    let delay = clamp(0, inverseEaseOut(x / seriesWidth), 1);\n    if (isNaN(delay)) {\n      delay = 0;\n    }\n    return { scalingX: 0, scalingY: 0, delay, duration: QUICK_TRANSITION, phase: \"initial\" };\n  };\n  const toFn = () => {\n    return { scalingX: 1, scalingY: 1 };\n  };\n  fromToMotion(id, \"markers\", animationManager, markerSelections, { fromFn, toFn });\n}\nfunction resetMarkerFn(_node) {\n  return { opacity: 1, scalingX: 1, scalingY: 1 };\n}\nfunction resetMarkerPositionFn(_node, datum) {\n  return {\n    translationX: datum.point?.x ?? NaN,\n    translationY: datum.point?.y ?? NaN\n  };\n}\nfunction prepareMarkerAnimation(pairMap, parentStatus) {\n  const readFirstPair = (xValue, type) => {\n    const val = pairMap[type][xValue];\n    return Array.isArray(val) ? val[0] : val;\n  };\n  const markerStatus = (datum) => {\n    const { xValue } = datum;\n    if (pairMap.moved[xValue]) {\n      return { point: readFirstPair(xValue, \"moved\"), status: \"updated\" };\n    } else if (pairMap.removed[xValue]) {\n      return { point: readFirstPair(xValue, \"removed\"), status: \"removed\" };\n    } else if (pairMap.added[xValue]) {\n      return { point: readFirstPair(xValue, \"added\"), status: \"added\" };\n    }\n    return { status: \"unknown\" };\n  };\n  const fromFn = (marker, datum) => {\n    const { status, point } = markerStatus(datum);\n    if (status === \"unknown\")\n      return { opacity: 0 };\n    const defaults = {\n      translationX: point?.from?.x ?? marker.translationX,\n      translationY: point?.from?.y ?? marker.translationY,\n      opacity: marker.opacity,\n      phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[status]\n    };\n    if (parentStatus === \"added\") {\n      return {\n        ...defaults,\n        opacity: 0,\n        translationX: point?.to?.x,\n        translationY: point?.to?.y,\n        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[\"added\"]\n      };\n    }\n    if (status === \"added\") {\n      defaults.opacity = 0;\n    }\n    return defaults;\n  };\n  const toFn = (_marker, datum) => {\n    const { status, point } = markerStatus(datum);\n    if (status === \"unknown\")\n      return { opacity: 0 };\n    const defaults = {\n      translationX: datum.point.x,\n      translationY: datum.point.y,\n      opacity: 1,\n      phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[status]\n    };\n    if (status === \"removed\" || parentStatus === \"removed\") {\n      return {\n        ...defaults,\n        translationX: point?.to?.x,\n        translationY: point?.to?.y,\n        opacity: 0,\n        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[\"removed\"]\n      };\n    }\n    return defaults;\n  };\n  return { fromFn, toFn };\n}\nfunction computeMarkerFocusBounds(series, { datumIndex }) {\n  const nodeData = series.getNodeData();\n  if (nodeData === void 0)\n    return void 0;\n  const datum = nodeData[datumIndex];\n  const { point } = datum;\n  if (datum == null || point == null)\n    return void 0;\n  const size = point.focusSize ?? series.getFormattedMarkerStyle(datum).size;\n  const radius = size / 2;\n  const x = datum.point.x - radius;\n  const y = datum.point.y - radius;\n  return Transformable.toCanvas(series.contentGroup, new BBox(x, y, size, size));\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/linePlotter.ts\nfunction plotLinearPoints(path, points, continuePath) {\n  let didMove = continuePath;\n  for (const { x, y } of points) {\n    if (didMove) {\n      path.lineTo(x, y);\n    } else {\n      path.moveTo(x, y);\n      didMove = true;\n    }\n  }\n}\nvar flatnessRatio2 = 0.05;\nfunction plotSmoothPoints(path, iPoints, tension, continuePath) {\n  const points = Array.isArray(iPoints) ? iPoints : Array.from(iPoints);\n  if (points.length === 0)\n    return;\n  if (continuePath) {\n    path.lineTo(points[0].x, points[0].y);\n  } else {\n    path.moveTo(points[0].x, points[0].y);\n  }\n  if (points.length <= 1)\n    return;\n  const gradients = points.map((c, i) => {\n    const p = i === 0 ? c : points[i - 1];\n    const n = i === points.length - 1 ? c : points[i + 1];\n    const isTerminalPoint = i === 0 || i === points.length - 1;\n    if (Math.sign(p.y - c.y) === Math.sign(n.y - c.y)) {\n      return 0;\n    }\n    if (!isTerminalPoint) {\n      const range3 = Math.abs(p.y - n.y);\n      const prevRatio = Math.abs(c.y - p.y) / range3;\n      const nextRatio = Math.abs(c.y - n.y) / range3;\n      if (prevRatio <= flatnessRatio2 || 1 - prevRatio <= flatnessRatio2 || nextRatio <= flatnessRatio2 || 1 - nextRatio <= flatnessRatio2) {\n        return 0;\n      }\n    }\n    return (n.y - p.y) / (n.x - p.x);\n  });\n  if (gradients[1] === 0) {\n    gradients[0] *= 2;\n  }\n  if (gradients[gradients.length - 2] === 0) {\n    gradients[gradients.length - 1] *= 2;\n  }\n  for (let i = 1; i < points.length; i += 1) {\n    const prev = points[i - 1];\n    const prevM = gradients[i - 1];\n    const cur = points[i];\n    const curM = gradients[i];\n    const dx = cur.x - prev.x;\n    const dy = cur.y - prev.y;\n    let dcp1x = dx * tension / 3;\n    let dcp1y = dx * prevM * tension / 3;\n    let dcp2x = dx * tension / 3;\n    let dcp2y = dx * curM * tension / 3;\n    if (curM === 0 && Math.abs(dcp1y) > Math.abs(dy)) {\n      dcp1x *= Math.abs(dy / dcp1y);\n      dcp1y = Math.sign(dcp1y) * Math.abs(dy);\n    }\n    if (prevM === 0 && Math.abs(dcp2y) > Math.abs(dy)) {\n      dcp2x *= Math.abs(dy / dcp2y);\n      dcp2y = Math.sign(dcp2y) * Math.abs(dy);\n    }\n    path.cubicCurveTo(prev.x + dcp1x, prev.y + dcp1y, cur.x - dcp2x, cur.y - dcp2y, cur.x, cur.y);\n  }\n}\nfunction plotStepPoints(path, points, align, continuePath) {\n  let lastPoint;\n  for (const point of points) {\n    if (lastPoint != null) {\n      const directionalAlign = lastPoint.x < point.x ? align : 1 - align;\n      const x = (point.x - lastPoint.x) * directionalAlign + lastPoint.x;\n      path.lineTo(x, lastPoint?.y ?? point.y);\n      path.lineTo(x, point.y);\n      path.lineTo(point.x, point.y);\n    } else if (continuePath) {\n      path.lineTo(point.x, point.y);\n    } else {\n      path.moveTo(point.x, point.y);\n    }\n    lastPoint = point;\n  }\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/pathUtil.ts\nfunction minMax(nodeData) {\n  return nodeData.reduce(\n    ({ min, max }, node) => {\n      if (min == null || min.point.x > node.point.x) {\n        min = node;\n      }\n      if (max == null || max.point.x < node.point.x) {\n        max = node;\n      }\n      return { min, max };\n    },\n    {}\n  );\n}\nfunction intersectionOnLine(a, b, targetX) {\n  const m = (b.y - a.y) / (b.x - a.x);\n  const y = (targetX - a.x) * m + a.y;\n  return { x: targetX, y };\n}\nfunction backfillPathPoint(results, process, skip, processFn) {\n  let prevMarkerIdx = -1, nextMarkerIdx = 0;\n  const toProcess = [];\n  while (nextMarkerIdx < results.length) {\n    if (results[nextMarkerIdx].change === process) {\n      toProcess.push(results[nextMarkerIdx]);\n      nextMarkerIdx++;\n      continue;\n    }\n    if (results[nextMarkerIdx].change === skip) {\n      nextMarkerIdx++;\n      continue;\n    }\n    if (toProcess.length > 0) {\n      processFn(toProcess, prevMarkerIdx, nextMarkerIdx);\n      toProcess.length = 0;\n    }\n    prevMarkerIdx = nextMarkerIdx;\n    nextMarkerIdx++;\n  }\n  if (toProcess.length > 0) {\n    processFn(toProcess, prevMarkerIdx, nextMarkerIdx);\n  }\n}\nfunction backfillPathPointData(result, splitMode) {\n  backfillPathPoint(result, \"out\", \"in\", (toProcess, sIdx, eIdx) => {\n    if (sIdx === -1 && result[eIdx]) {\n      toProcess.forEach((d) => d.to = result[eIdx].from);\n    } else if (eIdx === result.length && result[sIdx]) {\n      toProcess.forEach((d) => d.to = result[sIdx].from);\n    } else if (splitMode === \"intersect\" && result[sIdx]?.from && result[eIdx]?.from) {\n      toProcess.forEach((d) => d.to = intersectionOnLine(result[sIdx].from, result[eIdx].from, d.from.x));\n    } else {\n      toProcess.forEach((d) => d.to = d.from);\n    }\n  });\n  backfillPathPoint(result, \"in\", \"out\", (toProcess, sIdx, eIdx) => {\n    if (sIdx === -1 && result[eIdx]) {\n      toProcess.forEach((d) => d.from = result[eIdx].to);\n    } else if (eIdx === result.length && result[sIdx]) {\n      toProcess.forEach((d) => d.from = result[sIdx].to);\n    } else if (splitMode === \"intersect\" && result[sIdx]?.to && result[eIdx]?.to) {\n      toProcess.forEach((d) => d.from = intersectionOnLine(result[sIdx].to, result[eIdx].to, d.to.x));\n    } else {\n      toProcess.forEach((d) => d.from = d.to);\n    }\n  });\n}\nfunction calculatePoint(from3, to, ratio2) {\n  const x1 = isNaN(from3.x) ? to.x : from3.x;\n  const y1 = isNaN(from3.y) ? to.y : from3.y;\n  const xd = to.x - from3.x;\n  const yd = to.y - from3.y;\n  const xr = isNaN(xd) ? 0 : xd * ratio2;\n  const yr = isNaN(yd) ? 0 : yd * ratio2;\n  return {\n    x: x1 + xr,\n    y: y1 + yr\n  };\n}\nvar lineSteps2 = {\n  start: 0,\n  middle: 0.5,\n  end: 1\n};\nfunction plotPath(points, path, interpolation, continuePath = false) {\n  const { path: linePath } = path;\n  if (interpolation?.type === \"smooth\") {\n    plotSmoothPoints(linePath, points, interpolation.tension ?? 1, continuePath);\n  } else if (interpolation?.type === \"step\") {\n    plotStepPoints(linePath, points, lineSteps2[interpolation.position ?? \"end\"], continuePath);\n  } else {\n    plotLinearPoints(linePath, points, continuePath);\n  }\n}\nfunction splitPairData(pairData, ratios) {\n  let previousTo;\n  let points = void 0;\n  const out = [];\n  const flushCurrent = () => {\n    if (points != null) {\n      out.push(points);\n      points = void 0;\n    }\n  };\n  for (const data of pairData) {\n    const { from: from3, to } = data;\n    const ratio2 = ratios[data.change];\n    if (ratio2 == null || from3 == null || to == null)\n      continue;\n    const point = calculatePoint(from3, to, ratio2);\n    if (data.moveTo === false) {\n      points ?? (points = []);\n      points.push(point);\n    } else if (data.moveTo === true || !previousTo) {\n      flushCurrent();\n      points = [point];\n    } else if (previousTo) {\n      const moveToRatio = data.moveTo === \"in\" ? ratio2 : 1 - ratio2;\n      const { x: midPointX, y: midPointY } = calculatePoint(previousTo, point, moveToRatio);\n      points ?? (points = []);\n      points.push({ x: midPointX, y: midPointY });\n      flushCurrent();\n      points = [point];\n    }\n    previousTo = point;\n  }\n  flushCurrent();\n  return out;\n}\nfunction renderPartialPath(pairData, ratios, path, interpolation) {\n  splitPairData(pairData, ratios).forEach((points) => {\n    plotPath(points, path, interpolation);\n  });\n}\nfunction pathSwipeInAnimation({ id, visible, nodeDataDependencies }, animationManager, ...paths) {\n  const { seriesRectWidth: width2, seriesRectHeight: height2 } = nodeDataDependencies;\n  staticFromToMotion(\n    id,\n    \"path_properties\",\n    animationManager,\n    paths,\n    { clipX: 0 },\n    { clipX: width2 },\n    {\n      phase: \"initial\",\n      start: { clip: true, clipY: height2, visible },\n      finish: { clip: false, visible }\n    }\n  );\n}\nfunction pathFadeInAnimation({ id }, subId, animationManager, phase = \"add\", ...selection) {\n  staticFromToMotion(id, subId, animationManager, selection, { opacity: 0 }, { opacity: 1 }, { phase });\n}\nfunction pathFadeOutAnimation({ id }, subId, animationManager, ...selection) {\n  staticFromToMotion(id, subId, animationManager, selection, { opacity: 1 }, { opacity: 0 }, { phase: \"remove\" });\n}\nfunction buildResetPathFn(opts) {\n  return (_node) => ({\n    visible: opts.getVisible(),\n    opacity: opts.getOpacity(),\n    clipScalingX: 1,\n    clip: false\n  });\n}\nfunction updateClipPath({ nodeDataDependencies }, path) {\n  const toFinite = (value) => isFinite(value) ? value : 0;\n  path.clipX = toFinite(nodeDataDependencies.seriesRectWidth);\n  path.clipY = toFinite(nodeDataDependencies.seriesRectHeight);\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/scaling.ts\nfunction isContinuousScaling(scaling) {\n  return scaling.type === \"continuous\" || scaling.type === \"log\";\n}\nfunction isCategoryScaling(scaling) {\n  return scaling.type === \"category\";\n}\nfunction areEqual(a, b) {\n  return a.domain.length === b.domain.length && a.range.length === b.range.length && a.domain.every((val, index) => val === b.domain[index]) && a.range.every((val, index) => val === b.range[index]);\n}\nfunction areScalingEqual(a, b) {\n  if (a === void 0 || b === void 0) {\n    return a !== void 0 || b !== void 0;\n  }\n  if (isContinuousScaling(a) && isContinuousScaling(b)) {\n    return a.type === b.type && areEqual(a, b);\n  }\n  if (isCategoryScaling(a) && isCategoryScaling(b)) {\n    return areEqual(a, b);\n  }\n  return false;\n}\nfunction isScaleValid(scale2) {\n  if (scale2 == null)\n    return false;\n  if (!scale2.range.every((v) => Number.isFinite(v)))\n    return false;\n  if (scale2.type === \"category\") {\n    return scale2.domain.every((v) => v != null);\n  }\n  return scale2.domain.every((v) => Number.isFinite(v) || v instanceof Date);\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/lineUtil.ts\nfunction* pathRanges(points) {\n  let start2 = -1;\n  let end2 = 0;\n  for (const { point } of points) {\n    if (point.moveTo) {\n      const range3 = start2 >= 0 ? { start: start2, end: end2 } : void 0;\n      start2 = end2;\n      end2 = start2;\n      if (range3 !== void 0) {\n        yield range3;\n      }\n    }\n    end2 += 1;\n  }\n  if (start2 !== -1) {\n    yield { start: start2, end: end2 };\n  }\n}\nfunction* pathRangePoints(points, { start: start2, end: end2 }) {\n  for (let i = start2; i < end2; i += 1) {\n    yield points[i].point;\n  }\n}\nfunction* pathRangePointsReverse(points, { start: start2, end: end2 }) {\n  for (let i = end2 - 1; i >= start2; i -= 1) {\n    yield points[i].point;\n  }\n}\nfunction integratedCategoryMatch(a, b) {\n  if (a == null || b == null)\n    return false;\n  if (typeof a !== \"object\" || typeof b !== \"object\")\n    return false;\n  if (\"id\" in a && \"id\" in b) {\n    return a.id === b.id;\n  }\n  return a.toString() === b.toString();\n}\nfunction scale(val, scaling) {\n  if (!scaling)\n    return NaN;\n  if (val instanceof Date) {\n    val = val.getTime();\n  }\n  if (scaling.type === \"continuous\" && typeof val === \"number\") {\n    const domainRatio = (val - scaling.domain[0]) / (scaling.domain[1] - scaling.domain[0]);\n    return domainRatio * (scaling.range[1] - scaling.range[0]) + scaling.range[0];\n  }\n  if (scaling.type === \"log\" && typeof val === \"number\") {\n    return scaling.convert(val);\n  }\n  const matchingIndex = scaling.domain.findIndex((d) => d === val);\n  if (matchingIndex >= 0) {\n    return scaling.range[matchingIndex];\n  }\n  const matchingIntegratedIndex = scaling.domain.findIndex((d) => integratedCategoryMatch(val, d));\n  if (matchingIntegratedIndex >= 0) {\n    return scaling.range[matchingIntegratedIndex];\n  }\n  return NaN;\n}\nfunction scalesChanged(newData, oldData) {\n  return !areScalingEqual(newData.scales.x, oldData.scales.x) || !areScalingEqual(newData.scales.y, oldData.scales.y);\n}\nfunction closeMatch(a, b) {\n  const an = Number(a);\n  const bn = Number(b);\n  if (!isNaN(an) && !isNaN(bn)) {\n    return Math.abs(bn - an) < 0.25;\n  }\n  return a === b;\n}\nfunction calculateMoveTo(from3 = false, to = false) {\n  if (from3 === to) {\n    return Boolean(from3);\n  }\n  return from3 ? \"in\" : \"out\";\n}\nfunction pairContinuousData(newData, oldData, opts = {}) {\n  const { backfillSplitMode = \"intersect\" } = opts;\n  const result = [];\n  const resultMap = {\n    added: {},\n    moved: {},\n    removed: {}\n  };\n  const pairUp = (from3, to, xValue, change = \"move\") => {\n    if (from3 && (isNaN(from3.point.x) || isNaN(from3.point.y))) {\n      from3 = to;\n    }\n    const resultPoint = {\n      from: from3?.point,\n      to: to?.point,\n      moveTo: calculateMoveTo(from3?.point.moveTo, to?.point.moveTo),\n      change\n    };\n    if (change === \"move\") {\n      resultMap.moved[xValue] = resultPoint;\n      oldIdx++;\n      newIdx++;\n    } else if (change === \"in\") {\n      resultMap.added[xValue] = resultPoint;\n      newIdx++;\n    } else if (change === \"out\") {\n      resultMap.removed[xValue] = resultPoint;\n      oldIdx++;\n    }\n    result.push(resultPoint);\n  };\n  const { min: minFromNode, max: maxFromNode } = minMax(oldData.nodeData);\n  const { min: minToNode, max: maxToNode } = minMax(newData.nodeData);\n  let oldIdx = 0;\n  let newIdx = 0;\n  while (oldIdx < oldData.nodeData.length || newIdx < newData.nodeData.length) {\n    const from3 = oldData.nodeData[oldIdx];\n    const to = newData.nodeData[newIdx];\n    const fromShifted = from3 ? scale(from3.xValue ?? NaN, newData.scales.x) : void 0;\n    const toUnshifted = to ? scale(to.xValue ?? NaN, oldData.scales.x) : void 0;\n    const NA = void 0;\n    if (fromShifted != null && closeMatch(fromShifted, to?.point.x)) {\n      pairUp(from3, to, to.xValue, \"move\");\n    } else if (fromShifted != null && fromShifted < (minToNode?.point.x ?? -Infinity)) {\n      pairUp(from3, NA, from3.xValue, \"out\");\n    } else if (fromShifted != null && fromShifted > (maxToNode?.point.x ?? Infinity)) {\n      pairUp(from3, NA, from3.xValue, \"out\");\n    } else if (toUnshifted != null && toUnshifted < (minFromNode?.point.x ?? -Infinity)) {\n      pairUp(NA, to, to.xValue, \"in\");\n    } else if (toUnshifted != null && toUnshifted > (maxFromNode?.point.x ?? Infinity)) {\n      pairUp(NA, to, to.xValue, \"in\");\n    } else if (fromShifted != null && fromShifted < to?.point.x) {\n      pairUp(from3, NA, from3.xValue, \"out\");\n    } else if (toUnshifted != null && toUnshifted < from3?.point.x) {\n      pairUp(NA, to, to.xValue, \"in\");\n    } else if (from3) {\n      pairUp(from3, NA, from3.xValue, \"out\");\n    } else if (to) {\n      pairUp(NA, to, to.xValue, \"in\");\n    } else {\n      throw new Error(\"Unable to process points\");\n    }\n  }\n  backfillPathPointData(result, backfillSplitMode);\n  return { result, resultMap };\n}\nfunction pairCategoryData(newData, oldData, diff2, opts = {}) {\n  const { backfillSplitMode = \"intersect\", multiDatum = false } = opts;\n  const result = [];\n  const resultMapSingle = {\n    added: {},\n    moved: {},\n    removed: {}\n  };\n  const resultMapMulti = {\n    added: {},\n    moved: {},\n    removed: {}\n  };\n  const pointResultMapping = {\n    in: \"added\",\n    move: \"moved\",\n    out: \"removed\"\n  };\n  let previousResultPoint = void 0;\n  let previousXValue = void 0;\n  const addToResultMap = (xValue, newPoint) => {\n    var _a;\n    const type = pointResultMapping[newPoint.change];\n    if (multiDatum) {\n      (_a = resultMapMulti[type])[xValue] ?? (_a[xValue] = []);\n      resultMapMulti[type][xValue].push(newPoint);\n    } else {\n      resultMapSingle[type][xValue] = newPoint;\n    }\n    previousResultPoint = newPoint;\n    previousXValue = transformIntegratedCategoryValue(xValue);\n  };\n  let oldIndex = 0;\n  let newIndex = 0;\n  let isXUnordered = false;\n  while (oldIndex < oldData.nodeData.length || newIndex < newData.nodeData.length) {\n    const before = oldData.nodeData[oldIndex];\n    const after = newData.nodeData[newIndex];\n    const bXValue = transformIntegratedCategoryValue(before?.xValue);\n    const aXValue = transformIntegratedCategoryValue(after?.xValue);\n    let resultPoint;\n    if (bXValue === aXValue) {\n      resultPoint = {\n        change: \"move\",\n        moveTo: calculateMoveTo(before.point.moveTo ?? false, after.point.moveTo),\n        from: before.point,\n        to: after.point\n      };\n      addToResultMap(before?.xValue, resultPoint);\n      oldIndex++;\n      newIndex++;\n    } else if (diff2?.removed.has(String(bXValue))) {\n      resultPoint = {\n        change: \"out\",\n        moveTo: before.point.moveTo ?? false,\n        from: before.point\n      };\n      addToResultMap(before?.xValue, resultPoint);\n      oldIndex++;\n    } else if (diff2?.added.has(String(aXValue))) {\n      resultPoint = {\n        change: \"in\",\n        moveTo: after.point.moveTo ?? false,\n        to: after.point\n      };\n      addToResultMap(after?.xValue, resultPoint);\n      newIndex++;\n    } else if (multiDatum && previousResultPoint && previousXValue === bXValue) {\n      resultPoint = {\n        ...previousResultPoint\n      };\n      addToResultMap(before?.xValue, resultPoint);\n      oldIndex++;\n    } else if (multiDatum && previousResultPoint && previousXValue === aXValue) {\n      resultPoint = {\n        ...previousResultPoint\n      };\n      addToResultMap(after?.xValue, resultPoint);\n      newIndex++;\n    } else {\n      isXUnordered = true;\n      break;\n    }\n    result.push(resultPoint);\n  }\n  let previousX = -Infinity;\n  isXUnordered || (isXUnordered = result.some((pathPoint) => {\n    const { change: marker, to: { x = -Infinity } = {} } = pathPoint;\n    if (marker === \"out\")\n      return;\n    const unordered = x < previousX;\n    previousX = x;\n    return unordered;\n  }));\n  if (isXUnordered) {\n    return { result: void 0, resultMap: void 0 };\n  }\n  backfillPathPointData(result, backfillSplitMode);\n  return { result, resultMap: multiDatum ? resultMapMulti : resultMapSingle };\n}\nfunction determinePathStatus(newData, oldData, pairData) {\n  let status = \"updated\";\n  const visible = (data) => {\n    return data.visible;\n  };\n  if (!visible(oldData) && visible(newData)) {\n    status = \"added\";\n  } else if (visible(oldData) && !visible(newData)) {\n    status = \"removed\";\n  } else {\n    for (let i = 0; i < pairData.length; i++) {\n      if (pairData[i].change !== \"move\")\n        break;\n      if (pairData[i].from?.x !== pairData[i].to?.x)\n        break;\n      if (pairData[i].from?.y !== pairData[i].to?.y)\n        break;\n      if (i === pairData.length - 1)\n        return \"no-op\";\n    }\n  }\n  return status;\n}\nfunction prepareLinePathPropertyAnimation(status, visibleToggleMode) {\n  const phase = visibleToggleMode === \"none\" ? \"updated\" : status;\n  const result = {\n    fromFn: (_path) => {\n      let mixin;\n      if (status === \"removed\") {\n        mixin = { finish: { visible: false } };\n      } else if (status === \"added\") {\n        mixin = { start: { visible: true } };\n      } else {\n        mixin = {};\n      }\n      return { phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[phase], ...mixin };\n    },\n    toFn: (_path) => {\n      return { phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[phase] };\n    }\n  };\n  if (visibleToggleMode === \"fade\") {\n    return {\n      fromFn: (path) => {\n        const opacity = status === \"added\" ? 0 : path.opacity;\n        return { opacity, ...result.fromFn(path) };\n      },\n      toFn: (path) => {\n        const opacity = status === \"removed\" ? 0 : 1;\n        return { opacity, ...result.toFn(path) };\n      }\n    };\n  }\n  return result;\n}\nfunction prepareLinePathAnimationFns(newData, oldData, pairData, visibleToggleMode, interpolation, render) {\n  const status = determinePathStatus(newData, oldData, pairData);\n  const removePhaseFn = (ratio2, path) => {\n    render(pairData, { move: 0, out: ratio2 }, path, interpolation);\n  };\n  const updatePhaseFn = (ratio2, path) => {\n    render(pairData, { move: ratio2 }, path, interpolation);\n  };\n  const addPhaseFn = (ratio2, path) => {\n    render(pairData, { move: 1, in: ratio2 }, path, interpolation);\n  };\n  const pathProperties = prepareLinePathPropertyAnimation(status, visibleToggleMode);\n  return { status, path: { addPhaseFn, updatePhaseFn, removePhaseFn }, pathProperties };\n}\nfunction prepareLinePathAnimation(newData, oldData, diff2, interpolation) {\n  const isCategoryBased = newData.scales.x?.type === \"category\";\n  const wasCategoryBased = oldData.scales.x?.type === \"category\";\n  if (isCategoryBased !== wasCategoryBased || !isScaleValid(newData.scales.x) || !isScaleValid(oldData.scales.x)) {\n    return;\n  }\n  const { result: pairData, resultMap: pairMap } = isCategoryBased ? pairCategoryData(newData, oldData, diff2) : pairContinuousData(newData, oldData);\n  let status = \"updated\";\n  if (oldData.visible && !newData.visible) {\n    status = \"removed\";\n  } else if (!oldData.visible && newData.visible) {\n    status = \"added\";\n  }\n  if (pairData === void 0 || pairMap === void 0) {\n    return;\n  }\n  const hasMotion = (diff2?.changed ?? true) || scalesChanged(newData, oldData) || status !== \"updated\";\n  const pathFns = prepareLinePathAnimationFns(newData, oldData, pairData, \"fade\", interpolation, renderPartialPath);\n  const marker = prepareMarkerAnimation(pairMap, status);\n  return { ...pathFns, marker, hasMotion };\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/lineInterpolationUtil.ts\nfunction toAxisValue(value) {\n  return transformIntegratedCategoryValue(value).valueOf();\n}\nfunction getAxisIndices({ data }, axisValues) {\n  return data.map((datum, datumIndex) => ({\n    xValue0Index: axisValues.indexOf(toAxisValue(datum.xValue0)),\n    xValue1Index: axisValues.indexOf(toAxisValue(datum.xValue1)),\n    datumIndex\n  }));\n}\nfunction validateAxisValuesOrder(axisValues, data) {\n  let x0 = -Infinity;\n  for (const axisValue of axisValues) {\n    const x = scale(axisValue, data.scales.x);\n    if (!Number.isFinite(x)) {\n      continue;\n    } else if (x < x0) {\n      return false;\n    } else {\n      x0 = x;\n    }\n  }\n  return true;\n}\nfunction getAxisValues(newData, oldData) {\n  const allAxisValues = /* @__PURE__ */ new Set();\n  for (const { xValue0, xValue1 } of newData.data) {\n    const xValue0Value = toAxisValue(xValue0);\n    const xValue1Value = toAxisValue(xValue1);\n    allAxisValues.add(xValue0Value).add(xValue1Value);\n  }\n  const newAxisValues = Array.from(allAxisValues).sort((a, b) => {\n    return scale(a, newData.scales.x) - scale(b, newData.scales.x);\n  });\n  const exclusivelyOldAxisValues = [];\n  for (const { xValue0, xValue1 } of oldData.data) {\n    const xValue0Value = toAxisValue(xValue0);\n    const xValue1Value = toAxisValue(xValue1);\n    if (!allAxisValues.has(xValue0Value)) {\n      allAxisValues.add(xValue0Value);\n      exclusivelyOldAxisValues.push(xValue0Value);\n    }\n    if (!allAxisValues.has(xValue1Value)) {\n      allAxisValues.add(xValue1Value);\n      exclusivelyOldAxisValues.push(xValue1Value);\n    }\n  }\n  exclusivelyOldAxisValues.sort((a, b) => {\n    return scale(a, oldData.scales.x) - scale(b, oldData.scales.x);\n  });\n  const axisValues = newAxisValues;\n  let insertionIndex = 0;\n  for (const oldValue of exclusivelyOldAxisValues) {\n    inner:\n      for (let i = axisValues.length; i > insertionIndex; i -= 1) {\n        const oldValueX = scale(oldValue, oldData.scales.x);\n        const newValueX = scale(axisValues[i], oldData.scales.x);\n        if (oldValueX > newValueX) {\n          insertionIndex = i + 1;\n          break inner;\n        }\n      }\n    axisValues.splice(insertionIndex, 0, oldValue);\n    insertionIndex += 1;\n  }\n  if (!validateAxisValuesOrder(axisValues, oldData))\n    return;\n  const oldDataAxisIndices = getAxisIndices(oldData, axisValues);\n  const newDataAxisIndices = getAxisIndices(newData, axisValues);\n  return { axisValues, oldDataAxisIndices, newDataAxisIndices };\n}\nfunction clipSpan(span, xValue0Index, xIndices) {\n  if (xIndices.xValue1Index === xIndices.xValue0Index + 1)\n    return span;\n  const range3 = spanRange(span);\n  const step = (range3[1].x - range3[0].x) / (xIndices.xValue1Index - xIndices.xValue0Index);\n  const start2 = range3[0].x + (xValue0Index - xIndices.xValue0Index) * step;\n  const end2 = start2 + step;\n  return clipSpanX(span, start2, end2);\n}\nfunction axisZeroSpan(span, data) {\n  const [r0, r1] = spanRange(span);\n  const y0 = scale(0, data.scales.y);\n  return rescaleSpan(span, { x: r0.x, y: y0 }, { x: r1.x, y: y0 });\n}\nfunction collapseSpan(span, data, axisIndices, indices, range3) {\n  let xValue;\n  let yValue;\n  if (indices.xValue0Index >= range3.xValue1Index) {\n    const datumIndex = axisIndices.findLast((i) => i.xValue1Index <= range3.xValue1Index)?.datumIndex;\n    const datum = datumIndex != null ? data.data[datumIndex] : void 0;\n    xValue = datum?.xValue1;\n    yValue = datum?.yValue1;\n  } else if (indices.xValue0Index <= range3.xValue0Index) {\n    const datumIndex = axisIndices.find((i) => i.xValue0Index >= range3.xValue0Index)?.datumIndex;\n    const datum = datumIndex != null ? data.data[datumIndex] : void 0;\n    xValue = datum?.xValue0;\n    yValue = datum?.yValue0;\n  }\n  if (xValue == null || yValue == null) {\n    return axisZeroSpan(span, data);\n  }\n  const x = scale(xValue, data.scales.x);\n  const y = scale(yValue, data.scales.y);\n  const point = { x, y };\n  return rescaleSpan(span, point, point);\n}\nfunction zeroDataSpan(spanDatum, zeroData) {\n  const newSpanXValue0 = toAxisValue(spanDatum.xValue0);\n  const newSpanXValue1 = toAxisValue(spanDatum.xValue1);\n  return zeroData?.find(\n    (span) => toAxisValue(span.xValue0) === newSpanXValue0 && toAxisValue(span.xValue1) === newSpanXValue1\n  )?.span;\n}\nfunction addSpan(newData, newAxisIndices, newIndices, oldZeroData, range3, out) {\n  const newSpanDatum = newData.data[newIndices.datumIndex];\n  const newSpan = newSpanDatum.span;\n  const zeroSpan = zeroDataSpan(newSpanDatum, oldZeroData);\n  if (zeroSpan != null) {\n    out.removed.push({ from: zeroSpan, to: zeroSpan });\n    out.moved.push({ from: zeroSpan, to: newSpan });\n    out.added.push({ from: newSpan, to: newSpan });\n  } else {\n    const oldSpan = collapseSpan(newSpan, newData, newAxisIndices, newIndices, range3);\n    out.added.push({ from: oldSpan, to: newSpan });\n  }\n}\nfunction removeSpan(oldData, oldAxisIndices, oldIndices, newZeroData, range3, out) {\n  const oldSpanDatum = oldData.data[oldIndices.datumIndex];\n  const oldSpan = oldSpanDatum.span;\n  const zeroSpan = zeroDataSpan(oldSpanDatum, newZeroData);\n  if (zeroSpan != null) {\n    out.removed.push({ from: oldSpan, to: oldSpan });\n    out.moved.push({ from: oldSpan, to: zeroSpan });\n    out.added.push({ from: zeroSpan, to: zeroSpan });\n  } else {\n    const newSpan = collapseSpan(oldSpan, oldData, oldAxisIndices, oldIndices, range3);\n    out.removed.push({ from: oldSpan, to: newSpan });\n  }\n}\nfunction alignSpanToContainingSpan(span, axisValues, preData, postData, postSpanIndices) {\n  const startXValue0 = axisValues[postSpanIndices.xValue0Index];\n  const startDatum = preData.data.find((spanDatum) => toAxisValue(spanDatum.xValue0) === startXValue0);\n  const endXValue1 = axisValues[postSpanIndices.xValue1Index];\n  const endDatum = preData.data.find((spanDatum) => toAxisValue(spanDatum.xValue1) === endXValue1);\n  if (startDatum == null || endDatum == null)\n    return;\n  const [{ x: x0 }, { x: x1 }] = spanRange(span);\n  const startX = scale(startDatum.xValue0, preData.scales.x);\n  const startY = scale(startDatum.yValue0, preData.scales.y);\n  const endX = scale(endDatum.xValue1, preData.scales.x);\n  const endY = scale(endDatum.yValue1, preData.scales.y);\n  let altSpan = postData.data[postSpanIndices.datumIndex].span;\n  altSpan = rescaleSpan(altSpan, { x: startX, y: startY }, { x: endX, y: endY });\n  altSpan = clipSpanX(altSpan, x0, x1);\n  return altSpan;\n}\nfunction appendSpanPhases(newData, oldData, axisValues, xValue0Index, newAxisIndices, oldAxisIndices, range3, out) {\n  const xValue1Index = xValue0Index + 1;\n  const oldIndices = oldAxisIndices.find((i) => i.xValue0Index <= xValue0Index && i.xValue1Index >= xValue1Index);\n  const newIndices = newAxisIndices.find((i) => i.xValue0Index <= xValue0Index && i.xValue1Index >= xValue1Index);\n  const oldZeroData = oldData.zeroData;\n  const newZeroData = newData.zeroData;\n  if (oldIndices == null && newIndices != null) {\n    addSpan(newData, newAxisIndices, newIndices, oldZeroData, range3, out);\n    return;\n  } else if (oldIndices != null && newIndices == null) {\n    removeSpan(oldData, oldAxisIndices, oldIndices, newZeroData, range3, out);\n    return;\n  } else if (oldIndices == null || newIndices == null) {\n    return;\n  }\n  let ordering;\n  if (oldIndices.xValue0Index === newIndices.xValue0Index && oldIndices.xValue1Index === newIndices.xValue1Index) {\n    ordering = 0;\n  } else if (oldIndices.xValue0Index <= newIndices.xValue0Index && oldIndices.xValue1Index >= newIndices.xValue1Index) {\n    ordering = -1;\n  } else if (oldIndices.xValue0Index >= newIndices.xValue0Index && oldIndices.xValue1Index <= newIndices.xValue1Index) {\n    ordering = 1;\n  } else {\n    ordering = 0;\n  }\n  const oldSpanDatum = oldData.data[oldIndices.datumIndex];\n  const clippedOldSpanOldScale = clipSpan(oldSpanDatum.span, xValue0Index, oldIndices);\n  const newSpanDatum = newData.data[newIndices.datumIndex];\n  const clippedNewSpanNewScale = clipSpan(newSpanDatum.span, xValue0Index, newIndices);\n  if (ordering === 1) {\n    const clippedPostRemoveOldSpanOldScale = alignSpanToContainingSpan(\n      clippedOldSpanOldScale,\n      axisValues,\n      oldData,\n      newData,\n      newIndices\n    );\n    if (clippedPostRemoveOldSpanOldScale != null) {\n      out.removed.push({ from: clippedOldSpanOldScale, to: clippedPostRemoveOldSpanOldScale });\n      out.moved.push({ from: clippedPostRemoveOldSpanOldScale, to: clippedNewSpanNewScale });\n      out.added.push({ from: clippedNewSpanNewScale, to: clippedNewSpanNewScale });\n    } else {\n      removeSpan(oldData, oldAxisIndices, oldIndices, newZeroData, range3, out);\n    }\n  } else if (ordering === -1) {\n    const clippedPreAddedNewSpanNewScale = alignSpanToContainingSpan(\n      clippedNewSpanNewScale,\n      axisValues,\n      newData,\n      oldData,\n      oldIndices\n    );\n    if (clippedPreAddedNewSpanNewScale != null) {\n      out.removed.push({ from: clippedOldSpanOldScale, to: clippedOldSpanOldScale });\n      out.moved.push({ from: clippedOldSpanOldScale, to: clippedPreAddedNewSpanNewScale });\n      out.added.push({ from: clippedPreAddedNewSpanNewScale, to: clippedNewSpanNewScale });\n    } else {\n      addSpan(newData, newAxisIndices, newIndices, oldZeroData, range3, out);\n    }\n  } else {\n    out.removed.push({ from: clippedOldSpanOldScale, to: clippedOldSpanOldScale });\n    out.moved.push({ from: clippedOldSpanOldScale, to: clippedNewSpanNewScale });\n    out.added.push({ from: clippedNewSpanNewScale, to: clippedNewSpanNewScale });\n  }\n}\nfunction phaseAnimation(axisContext, newData, oldData, out) {\n  const { axisValues, oldDataAxisIndices, newDataAxisIndices } = axisContext;\n  const range3 = {\n    xValue0Index: Math.max(\n      oldDataAxisIndices.at(0)?.xValue0Index ?? -Infinity,\n      newDataAxisIndices.at(0)?.xValue0Index ?? -Infinity\n    ),\n    xValue1Index: Math.min(\n      oldDataAxisIndices.at(-1)?.xValue1Index ?? Infinity,\n      newDataAxisIndices.at(-1)?.xValue1Index ?? Infinity\n    )\n  };\n  for (let xValue0Index = 0; xValue0Index < axisValues.length - 1; xValue0Index += 1) {\n    appendSpanPhases(\n      newData,\n      oldData,\n      axisValues,\n      xValue0Index,\n      newDataAxisIndices,\n      oldDataAxisIndices,\n      range3,\n      out\n    );\n  }\n}\nfunction resetAnimation(newData, oldData, out) {\n  for (const oldSpanDatum of oldData.data) {\n    const oldSpan = oldSpanDatum.span;\n    const zeroSpan = zeroDataSpan(oldSpanDatum, oldData.zeroData) ?? axisZeroSpan(oldSpan, oldData);\n    out.removed.push({ from: oldSpan, to: zeroSpan });\n  }\n  for (const newSpanDatum of newData.data) {\n    const newSpan = newSpanDatum.span;\n    const zeroSpan = zeroDataSpan(newSpanDatum, newData.zeroData) ?? axisZeroSpan(newSpan, newData);\n    out.added.push({ from: zeroSpan, to: newSpan });\n  }\n}\nfunction pairUpSpans(newData, oldData) {\n  const out = {\n    removed: [],\n    moved: [],\n    added: []\n  };\n  const axisContext = getAxisValues(newData, oldData);\n  if (axisContext == null) {\n    resetAnimation(newData, oldData, out);\n  } else {\n    phaseAnimation(axisContext, newData, oldData, out);\n  }\n  return out;\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/areaUtil.ts\nfunction plotFillSpans(ratio2, path, spans, fillPhantomSpans) {\n  for (let i = 0; i < spans.length; i += 1) {\n    const span = spans[i];\n    const reversedPhantomSpan = fillPhantomSpans[i];\n    plotInterpolatedSpans(path.path, span.from, span.to, ratio2, 1 /* MoveTo */, false);\n    plotInterpolatedSpans(\n      path.path,\n      reversedPhantomSpan.from,\n      reversedPhantomSpan.to,\n      ratio2,\n      2 /* LineTo */,\n      true\n    );\n    path.path.closePath();\n  }\n}\nfunction prepareAreaFillAnimationFns(status, spans, fillPhantomSpans, visibleToggleMode) {\n  const removePhaseFn = (ratio2, path) => plotFillSpans(ratio2, path, spans.removed, fillPhantomSpans.removed);\n  const updatePhaseFn = (ratio2, path) => plotFillSpans(ratio2, path, spans.moved, fillPhantomSpans.moved);\n  const addPhaseFn = (ratio2, path) => plotFillSpans(ratio2, path, spans.added, fillPhantomSpans.added);\n  const pathProperties = prepareLinePathPropertyAnimation(status, visibleToggleMode);\n  return { status, path: { addPhaseFn, updatePhaseFn, removePhaseFn }, pathProperties };\n}\nfunction plotStrokeSpans(ratio2, path, spans) {\n  for (const span of spans) {\n    plotInterpolatedSpans(path.path, span.from, span.to, ratio2, 1 /* MoveTo */, false);\n  }\n}\nfunction prepareAreaStrokeAnimationFns(status, spans, visibleToggleMode) {\n  const removePhaseFn = (ratio2, path) => plotStrokeSpans(ratio2, path, spans.removed);\n  const updatePhaseFn = (ratio2, path) => plotStrokeSpans(ratio2, path, spans.moved);\n  const addPhaseFn = (ratio2, path) => plotStrokeSpans(ratio2, path, spans.added);\n  const pathProperties = prepareLinePathPropertyAnimation(status, visibleToggleMode);\n  return { status, path: { addPhaseFn, updatePhaseFn, removePhaseFn }, pathProperties };\n}\nfunction prepareAreaPathAnimation(newData, oldData) {\n  const isCategoryBased = newData.scales.x?.type === \"category\";\n  const wasCategoryBased = oldData.scales.x?.type === \"category\";\n  if (isCategoryBased !== wasCategoryBased || !isScaleValid(newData.scales.x) || !isScaleValid(oldData.scales.x)) {\n    return;\n  }\n  let status = \"updated\";\n  if (oldData.visible && !newData.visible) {\n    status = \"removed\";\n  } else if (!oldData.visible && newData.visible) {\n    status = \"added\";\n  }\n  const fillSpans = pairUpSpans(\n    { scales: newData.scales, data: newData.fillData.spans, visible: newData.visible },\n    { scales: oldData.scales, data: oldData.fillData.spans, visible: oldData.visible }\n  );\n  const fillPhantomSpans = pairUpSpans(\n    { scales: newData.scales, data: newData.fillData.phantomSpans, visible: newData.visible },\n    { scales: oldData.scales, data: oldData.fillData.phantomSpans, visible: oldData.visible }\n  );\n  const strokeSpans = pairUpSpans(\n    {\n      scales: newData.scales,\n      data: newData.strokeData.spans,\n      visible: newData.visible,\n      zeroData: newData.fillData.phantomSpans\n    },\n    {\n      scales: oldData.scales,\n      data: oldData.strokeData.spans,\n      visible: oldData.visible,\n      zeroData: oldData.fillData.phantomSpans\n    }\n  );\n  const fadeMode = \"none\";\n  const fill = prepareAreaFillAnimationFns(status, fillSpans, fillPhantomSpans, fadeMode);\n  const stroke = prepareAreaStrokeAnimationFns(status, strokeSpans, fadeMode);\n  return { status, fill, stroke };\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/areaSeries.ts\nvar CROSS_FILTER_AREA_FILL_OPACITY_FACTOR = 0.125;\nvar CROSS_FILTER_AREA_STROKE_OPACITY_FACTOR = 0.25;\nvar AreaSeries = class extends CartesianSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,\n      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,\n      pathsPerSeries: [\"fill\", \"stroke\"],\n      pathsZIndexSubOrderOffset: [0, 1e3],\n      hasMarkers: true,\n      markerSelectionGarbageCollection: false,\n      pickModes: [2 /* AXIS_ALIGNED */, 0 /* EXACT_SHAPE_MATCH */],\n      animationResetFns: {\n        path: buildResetPathFn({ getVisible: () => this.visible, getOpacity: () => this.getOpacity() }),\n        label: resetLabelFn,\n        marker: (node, datum) => ({ ...resetMarkerFn(node), ...resetMarkerPositionFn(node, datum) })\n      }\n    });\n    this.properties = new AreaSeriesProperties();\n  }\n  async processData(dataController) {\n    if (this.data == null || !this.properties.isValid()) {\n      return;\n    }\n    const { data, visible, seriesGrouping: { groupIndex = this.id, stackCount = 1 } = {} } = this;\n    const { xKey, yKey, yFilterKey, connectMissingData, normalizedTo } = this.properties;\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    const xScale = this.axes[\"x\" /* X */]?.scale;\n    const yScale = this.axes[\"y\" /* Y */]?.scale;\n    const { xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });\n    const idMap = {\n      value: `area-stack-${groupIndex}-yValue`,\n      values: `area-stack-${groupIndex}-yValues`,\n      stack: `area-stack-${groupIndex}-yValue-stack`,\n      marker: `area-stack-${groupIndex}-yValues-marker`\n    };\n    const extraProps = [];\n    if (isDefined(normalizedTo)) {\n      extraProps.push(normaliseGroupTo(Object.values(idMap), normalizedTo, \"range\"));\n    }\n    if (animationEnabled) {\n      extraProps.push(animationValidation());\n    }\n    const common = { invalidValue: null };\n    if (connectMissingData && stackCount > 1) {\n      common.invalidValue = 0;\n    }\n    if (!visible) {\n      common.forceValue = 0;\n    }\n    await this.requestDataModel(dataController, data, {\n      props: [\n        keyProperty(xKey, xScaleType, { id: \"xValue\" }),\n        valueProperty(yKey, yScaleType, { id: `yValueRaw`, ...common }),\n        ...yFilterKey != null ? [valueProperty(yFilterKey, yScaleType, { id: \"yFilterRaw\" })] : [],\n        ...groupStackValueProperty(yKey, yScaleType, { id: `yValueStack`, ...common, groupId: idMap.stack }),\n        valueProperty(yKey, yScaleType, { id: `yValue`, ...common, groupId: idMap.value }),\n        ...groupAccumulativeValueProperty(\n          yKey,\n          \"window\",\n          \"current\",\n          { id: `yValueEnd`, ...common, groupId: idMap.values },\n          yScaleType\n        ),\n        ...groupAccumulativeValueProperty(\n          yKey,\n          \"normal\",\n          \"current\",\n          { id: `yValueCumulative`, ...common, groupId: idMap.marker },\n          yScaleType\n        ),\n        ...extraProps\n      ],\n      groupByKeys: true,\n      groupByData: false\n    });\n    this.animationState.transition(\"updateData\");\n  }\n  getSeriesDomain(direction) {\n    const { processedData, dataModel, axes } = this;\n    if (!processedData || !dataModel || processedData.data.length === 0)\n      return [];\n    const yAxis = axes[\"y\" /* Y */];\n    const keyDef = dataModel.resolveProcessedDataDefById(this, `xValue`);\n    const keys = dataModel.getDomain(this, `xValue`, \"key\", processedData);\n    const yExtent = dataModel.getDomain(this, `yValueEnd`, \"value\", processedData);\n    if (direction === \"x\" /* X */) {\n      if (keyDef?.def.type === \"key\" && keyDef.def.valueType === \"category\") {\n        return keys;\n      }\n      return fixNumericExtent(extent(keys));\n    } else if (yAxis instanceof LogAxis || yAxis instanceof TimeAxis) {\n      return fixNumericExtent(yExtent);\n    } else {\n      const fixedYExtent = [yExtent[0] > 0 ? 0 : yExtent[0], yExtent[1] < 0 ? 0 : yExtent[1]];\n      return fixNumericExtent(fixedYExtent);\n    }\n  }\n  async createNodeData() {\n    const { axes, data, processedData: { data: groupedData } = {}, dataModel } = this;\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    if (!xAxis || !yAxis || !data || !dataModel || !this.properties.isValid()) {\n      return;\n    }\n    const {\n      yKey,\n      xKey,\n      yFilterKey,\n      marker,\n      label,\n      fill: seriesFill,\n      stroke: seriesStroke,\n      connectMissingData\n    } = this.properties;\n    const { scale: xScale } = xAxis;\n    const { scale: yScale } = yAxis;\n    const { isContinuousY } = this.getScaleInformation({ xScale, yScale });\n    const xOffset = (xScale.bandwidth ?? 0) / 2;\n    const defs = dataModel.resolveProcessedDataDefsByIds(this, [`yValueEnd`, `yValueRaw`, `yValueCumulative`]);\n    const yFilterIndex = yFilterKey != null ? dataModel.resolveProcessedDataIndexById(this, \"yFilterRaw\") : void 0;\n    const yValueStackIndex = dataModel.resolveProcessedDataIndexById(this, \"yValueStack\");\n    const createMarkerCoordinate = (xDatum, yEnd, rawYDatum) => {\n      let currY;\n      if (isDefined(this.properties.normalizedTo) ? isContinuousY && isContinuous(rawYDatum) : !isNaN(rawYDatum)) {\n        currY = yEnd;\n      }\n      return {\n        x: xScale.convert(xDatum) + xOffset,\n        y: yScale.convert(currY),\n        size: marker.size\n      };\n    };\n    const itemId = yKey;\n    const labelData = [];\n    const markerData = [];\n    const { visibleSameStackCount } = this.ctx.seriesStateManager.getVisiblePeerGroupIndex(this);\n    let datumIdx = -1;\n    let crossFiltering = false;\n    groupedData?.forEach((datumGroup) => {\n      const {\n        keys,\n        keys: [xDatum],\n        datum: datumArray,\n        values: valuesArray\n      } = datumGroup;\n      valuesArray.forEach((values, valueIdx) => {\n        datumIdx++;\n        const seriesDatum = datumArray[valueIdx];\n        const dataValues2 = dataModel.resolveProcessedDataDefsValues(defs, { keys, values });\n        const { yValueRaw: yDatum, yValueCumulative, yValueEnd } = dataValues2;\n        const validPoint = Number.isFinite(yDatum);\n        const point = createMarkerCoordinate(xDatum, +yValueCumulative, yDatum);\n        const selected = yFilterIndex != null ? values[yFilterIndex] === yDatum : void 0;\n        if (selected === false) {\n          crossFiltering = true;\n        }\n        if (validPoint && marker) {\n          markerData.push({\n            index: datumIdx,\n            series: this,\n            itemId,\n            datum: seriesDatum,\n            midPoint: { x: point.x, y: point.y },\n            cumulativeValue: yValueEnd,\n            yValue: yDatum,\n            xValue: xDatum,\n            yKey,\n            xKey,\n            point,\n            fill: marker.fill ?? seriesFill,\n            stroke: marker.stroke ?? seriesStroke,\n            strokeWidth: marker.strokeWidth ?? this.getStrokeWidth(this.properties.strokeWidth),\n            selected\n          });\n        }\n        if (validPoint && label) {\n          const labelText = this.getLabelText(\n            label,\n            {\n              value: yDatum,\n              datum: seriesDatum,\n              xKey,\n              yKey,\n              xName: this.properties.xName,\n              yName: this.properties.yName\n            },\n            formatValue\n          );\n          labelData.push({\n            index: datumIdx,\n            series: this,\n            itemId: yKey,\n            datum: seriesDatum,\n            x: point.x,\n            y: point.y,\n            labelText\n          });\n        }\n      });\n    });\n    const { interpolation } = this.properties;\n    const interpolatePoints = (points) => {\n      let spans;\n      const pointsIter = points.map((point) => point.point);\n      switch (interpolation.type) {\n        case \"linear\":\n          spans = linearPoints(pointsIter);\n          break;\n        case \"smooth\":\n          spans = smoothPoints(pointsIter, interpolation.tension);\n          break;\n        case \"step\":\n          spans = stepPoints(pointsIter, interpolation.position);\n          break;\n      }\n      return spans.map((span, i) => ({\n        span,\n        xValue0: points[i].xDatum,\n        yValue0: points[i].yDatum,\n        xValue1: points[i + 1].xDatum,\n        yValue1: points[i + 1].yDatum\n      }));\n    };\n    const spansForPoints = (points) => {\n      return points.flatMap((p) => {\n        return Array.isArray(p) ? interpolatePoints(p) : new Array(p.skip).fill(null);\n      });\n    };\n    const dataValues = groupedData?.flatMap((datumGroup) => {\n      const {\n        keys: [xDatum],\n        values: valuesArray\n      } = datumGroup;\n      return valuesArray.map((values) => ({ xDatum, values }));\n    });\n    const createPoint = (xDatum, yDatum) => ({\n      point: {\n        x: xScale.convert(xDatum) + xOffset,\n        y: yScale.convert(yDatum)\n      },\n      xDatum,\n      yDatum\n    });\n    const getSeriesSpans = (index) => {\n      const points = [];\n      if (dataValues == null)\n        return [];\n      for (let i = 0; i < dataValues.length; i += 1) {\n        const { xDatum, values } = dataValues[i];\n        const yValueStack = values[yValueStackIndex];\n        const yDatum = yValueStack[index];\n        const yDatumIsFinite = Number.isFinite(yDatum);\n        if (connectMissingData && !yDatumIsFinite)\n          continue;\n        const lastYValueStack = dataValues[i - 1]?.values[yValueStackIndex];\n        const nextYValueStack = dataValues[i + 1]?.values[yValueStackIndex];\n        let yValueEndBackwards = 0;\n        let yValueEndForwards = 0;\n        for (let j = 0; j <= index; j += 1) {\n          const value = yValueStack[j];\n          if (Number.isFinite(value)) {\n            const lastWasFinite = lastYValueStack == null || Number.isFinite(lastYValueStack[j]);\n            const nextWasFinite = nextYValueStack == null || Number.isFinite(nextYValueStack[j]);\n            if (lastWasFinite) {\n              yValueEndBackwards += value;\n            }\n            if (nextWasFinite) {\n              yValueEndForwards += value;\n            }\n          }\n        }\n        const currentPoints = points[points.length - 1];\n        if (!connectMissingData && (yValueEndBackwards !== yValueEndForwards || !yDatumIsFinite)) {\n          if (!yDatumIsFinite && Array.isArray(currentPoints) && currentPoints.length === 1) {\n            points[points.length - 1] = { skip: 1 };\n          } else {\n            const pointBackwards = createPoint(xDatum, yValueEndBackwards);\n            const pointForwards = createPoint(xDatum, yValueEndForwards);\n            if (Array.isArray(currentPoints)) {\n              currentPoints.push(pointBackwards);\n            } else if (currentPoints != null) {\n              currentPoints.skip += 1;\n            }\n            points.push(yDatumIsFinite ? [pointForwards] : { skip: 0 });\n          }\n        } else {\n          const yValueEnd = Math.max(yValueEndBackwards, yValueEndForwards);\n          const point = createPoint(xDatum, yValueEnd);\n          if (Array.isArray(currentPoints)) {\n            currentPoints.push(point);\n          } else if (currentPoints != null) {\n            currentPoints.skip += 1;\n            points.push([point]);\n          } else {\n            points.push([point]);\n          }\n        }\n      }\n      return spansForPoints(points);\n    };\n    const stackIndex = this.seriesGrouping?.stackIndex ?? 0;\n    const getAxisSpans = () => {\n      if (dataValues == null)\n        return [];\n      const yValueZeroPoints = dataValues.map(({ xDatum, values }) => {\n        const yValueStack = values[yValueStackIndex];\n        const yDatum = yValueStack[stackIndex];\n        if (connectMissingData && !Number.isFinite(yDatum))\n          return;\n        return createPoint(xDatum, 0);\n      }).filter((x) => x != null);\n      return interpolatePoints(yValueZeroPoints);\n    };\n    const currentSeriesSpans = getSeriesSpans(stackIndex);\n    const phantomSpans = currentSeriesSpans.map(() => null);\n    for (let j = stackIndex - 1; j >= -1; j -= 1) {\n      let spans;\n      for (let i = 0; i < phantomSpans.length; i += 1) {\n        if (phantomSpans[i] != null)\n          continue;\n        spans ?? (spans = j !== -1 ? getSeriesSpans(j) : getAxisSpans());\n        phantomSpans[i] = spans[i];\n      }\n    }\n    const fillSpans = currentSeriesSpans.map((span, index) => span ?? phantomSpans[index]);\n    const strokeSpans = currentSeriesSpans.filter((span) => span != null);\n    const context = {\n      itemId,\n      fillData: { itemId, spans: fillSpans, phantomSpans },\n      strokeData: { itemId, spans: strokeSpans },\n      labelData,\n      nodeData: markerData,\n      scales: this.calculateScaling(),\n      visible: this.visible,\n      stackVisible: visibleSameStackCount > 0,\n      crossFiltering\n    };\n    return context;\n  }\n  isPathOrSelectionDirty() {\n    return this.properties.marker.isDirty();\n  }\n  markerFactory() {\n    const { shape } = this.properties.marker;\n    const MarkerShape = getMarker(shape);\n    return new MarkerShape();\n  }\n  async updatePathNodes(opts) {\n    const { opacity, visible, animationEnabled } = opts;\n    const [fill, stroke] = opts.paths;\n    const crossFiltering = this.contextNodeData?.crossFiltering === true;\n    const strokeWidth = this.getStrokeWidth(this.properties.strokeWidth);\n    stroke.setProperties({\n      fill: void 0,\n      lineJoin: stroke.lineCap = \"round\",\n      pointerEvents: 1 /* None */,\n      stroke: this.properties.stroke,\n      strokeWidth,\n      strokeOpacity: this.properties.strokeOpacity * (crossFiltering ? CROSS_FILTER_AREA_STROKE_OPACITY_FACTOR : 1),\n      lineDash: this.properties.lineDash,\n      lineDashOffset: this.properties.lineDashOffset,\n      opacity,\n      visible: visible || animationEnabled\n    });\n    fill.setProperties({\n      stroke: void 0,\n      lineJoin: \"round\",\n      pointerEvents: 1 /* None */,\n      fill: this.properties.fill,\n      fillOpacity: this.properties.fillOpacity * (crossFiltering ? CROSS_FILTER_AREA_FILL_OPACITY_FACTOR : 1),\n      fillShadow: this.properties.shadow,\n      opacity,\n      visible: visible || animationEnabled\n    });\n    updateClipPath(this, stroke);\n    updateClipPath(this, fill);\n  }\n  async updatePaths(opts) {\n    this.updateAreaPaths(opts.paths, opts.contextData);\n  }\n  updateAreaPaths(paths, contextData) {\n    for (const path of paths) {\n      path.visible = contextData.visible;\n    }\n    if (contextData.visible) {\n      this.updateFillPath(paths, contextData);\n      this.updateStrokePath(paths, contextData);\n    } else {\n      for (const path of paths) {\n        path.path.clear();\n        path.checkPathDirty();\n      }\n    }\n  }\n  updateFillPath(paths, contextData) {\n    const { spans, phantomSpans } = contextData.fillData;\n    const [fill] = paths;\n    const { path } = fill;\n    path.clear(true);\n    for (let i = 0; i < spans.length; i += 1) {\n      const { span } = spans[i];\n      const phantomSpan = phantomSpans[i].span;\n      plotSpan(path, span, 1 /* MoveTo */, false);\n      plotSpan(path, phantomSpan, 2 /* LineTo */, true);\n      path.closePath();\n    }\n    fill.checkPathDirty();\n  }\n  updateStrokePath(paths, contextData) {\n    const { spans } = contextData.strokeData;\n    const [, stroke] = paths;\n    const { path } = stroke;\n    path.clear(true);\n    for (const { span } of spans) {\n      plotSpan(path, span, 1 /* MoveTo */, false);\n    }\n    stroke.checkPathDirty();\n  }\n  async updateMarkerSelection(opts) {\n    const { nodeData, markerSelection } = opts;\n    const markersEnabled = this.properties.marker.enabled || this.contextNodeData?.crossFiltering === true;\n    if (this.properties.marker.isDirty()) {\n      markerSelection.clear();\n      markerSelection.cleanup();\n    }\n    return markerSelection.update(markersEnabled ? nodeData : []);\n  }\n  async updateMarkerNodes(opts) {\n    const { markerSelection, isHighlight: highlighted } = opts;\n    const { xKey, yKey, marker, fill, stroke, strokeWidth, fillOpacity, strokeOpacity, highlightStyle } = this.properties;\n    const baseStyle = mergeDefaults(highlighted && highlightStyle.item, marker.getStyle(), {\n      fill,\n      stroke,\n      strokeWidth,\n      fillOpacity,\n      strokeOpacity\n    });\n    markerSelection.each((node, datum) => {\n      this.updateMarkerStyle(node, marker, { datum, highlighted, xKey, yKey }, baseStyle, {\n        selected: datum.selected\n      });\n    });\n    if (!highlighted) {\n      this.properties.marker.markClean();\n    }\n  }\n  async updateLabelSelection(opts) {\n    const { labelData, labelSelection } = opts;\n    return labelSelection.update(labelData);\n  }\n  async updateLabelNodes(opts) {\n    const { labelSelection } = opts;\n    const { enabled: labelEnabled, fontStyle, fontWeight, fontSize, fontFamily, color } = this.properties.label;\n    labelSelection.each((text, datum) => {\n      const { x, y, labelText } = datum;\n      if (labelText && labelEnabled && this.visible) {\n        text.fontStyle = fontStyle;\n        text.fontWeight = fontWeight;\n        text.fontSize = fontSize;\n        text.fontFamily = fontFamily;\n        text.textAlign = \"center\";\n        text.textBaseline = \"bottom\";\n        text.text = labelText;\n        text.x = x;\n        text.y = y - 10;\n        text.fill = color;\n        text.visible = true;\n      } else {\n        text.visible = false;\n      }\n    });\n  }\n  getTooltipHtml(nodeDatum) {\n    const { id: seriesId, axes, dataModel } = this;\n    const { xKey, xName, yName, tooltip, marker } = this.properties;\n    const { yKey, xValue, yValue, datum, itemId } = nodeDatum;\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    if (!this.properties.isValid() || !(xAxis && yAxis && isFiniteNumber(yValue)) || !dataModel) {\n      return EMPTY_TOOLTIP_CONTENT;\n    }\n    const xString = xAxis.formatDatum(xValue);\n    const yString = yAxis.formatDatum(yValue);\n    const title = sanitizeHtml(yName);\n    const content = sanitizeHtml(xString + \": \" + yString);\n    const baseStyle = mergeDefaults({ fill: this.properties.fill }, marker.getStyle(), {\n      stroke: this.properties.stroke,\n      strokeWidth: this.properties.strokeWidth\n    });\n    const { fill: color } = this.getMarkerStyle(\n      marker,\n      { datum: nodeDatum, xKey, yKey, highlighted: false },\n      baseStyle\n    );\n    return tooltip.toTooltipHtml(\n      { title, content, backgroundColor: color },\n      {\n        datum,\n        itemId,\n        xKey,\n        xName,\n        yKey,\n        yName,\n        color,\n        title,\n        seriesId\n      }\n    );\n  }\n  getLegendData(legendType) {\n    if (!this.data?.length || !this.properties.isValid() || !this.properties.showInLegend || legendType !== \"category\") {\n      return [];\n    }\n    const {\n      yKey,\n      yName,\n      fill,\n      stroke,\n      fillOpacity,\n      strokeOpacity,\n      strokeWidth,\n      lineDash,\n      marker,\n      visible,\n      legendItemName\n    } = this.properties;\n    const useAreaFill = !marker.enabled || marker.fill === void 0;\n    return [\n      {\n        legendType,\n        id: this.id,\n        itemId: yKey,\n        seriesId: this.id,\n        enabled: visible,\n        label: {\n          text: legendItemName ?? yName ?? yKey\n        },\n        symbols: [\n          {\n            marker: {\n              shape: marker.shape,\n              fill: useAreaFill ? fill : marker.fill,\n              fillOpacity: useAreaFill ? fillOpacity : marker.fillOpacity,\n              stroke: marker.stroke ?? stroke,\n              strokeOpacity: marker.strokeOpacity ?? strokeOpacity,\n              strokeWidth: marker.strokeWidth ?? 0,\n              enabled: marker.enabled || strokeWidth <= 0\n            },\n            line: {\n              stroke,\n              strokeOpacity,\n              strokeWidth,\n              lineDash\n            }\n          }\n        ],\n        legendItemName\n      }\n    ];\n  }\n  animateEmptyUpdateReady(animationData) {\n    const { markerSelection, labelSelection, contextData, paths } = animationData;\n    const { animationManager } = this.ctx;\n    this.updateAreaPaths(paths, contextData);\n    pathSwipeInAnimation(this, animationManager, ...paths);\n    resetMotion([markerSelection], resetMarkerPositionFn);\n    markerSwipeScaleInAnimation(this, animationManager, markerSelection);\n    seriesLabelFadeInAnimation(this, \"labels\", animationManager, labelSelection);\n  }\n  animateReadyResize(animationData) {\n    const { contextData, paths } = animationData;\n    this.updateAreaPaths(paths, contextData);\n    super.animateReadyResize(animationData);\n  }\n  animateWaitingUpdateReady(animationData) {\n    const { animationManager } = this.ctx;\n    const { markerSelection, labelSelection, contextData, paths, previousContextData } = animationData;\n    const [fill, stroke] = paths;\n    if (fill == null && stroke == null)\n      return;\n    this.resetMarkerAnimation(animationData);\n    this.resetLabelAnimation(animationData);\n    const update = () => {\n      this.resetPathAnimation(animationData);\n      this.updateAreaPaths(paths, contextData);\n    };\n    const skip = () => {\n      animationManager.skipCurrentBatch();\n      update();\n    };\n    if (contextData == null || previousContextData == null) {\n      update();\n      markerFadeInAnimation(this, animationManager, \"added\", markerSelection);\n      pathFadeInAnimation(this, \"fill_path_properties\", animationManager, \"add\", fill);\n      pathFadeInAnimation(this, \"stroke_path_properties\", animationManager, \"add\", stroke);\n      seriesLabelFadeInAnimation(this, \"labels\", animationManager, labelSelection);\n      return;\n    }\n    if (contextData.crossFiltering !== previousContextData.crossFiltering) {\n      skip();\n      return;\n    }\n    const fns = prepareAreaPathAnimation(contextData, previousContextData);\n    if (fns === void 0) {\n      skip();\n      return;\n    } else if (fns.status === \"no-op\") {\n      return;\n    }\n    markerFadeInAnimation(this, animationManager, void 0, markerSelection);\n    fromToMotion(this.id, \"fill_path_properties\", animationManager, [fill], fns.fill.pathProperties);\n    pathMotion(this.id, \"fill_path_update\", animationManager, [fill], fns.fill.path);\n    fromToMotion(this.id, \"stroke_path_properties\", animationManager, [stroke], fns.stroke.pathProperties);\n    pathMotion(this.id, \"stroke_path_update\", animationManager, [stroke], fns.stroke.path);\n    seriesLabelFadeInAnimation(this, \"labels\", animationManager, labelSelection);\n    this.ctx.animationManager.animate({\n      id: this.id,\n      groupId: \"reset_after_animation\",\n      phase: \"trailing\",\n      from: {},\n      to: {},\n      onComplete: () => this.updateAreaPaths(paths, contextData)\n    });\n  }\n  isLabelEnabled() {\n    return this.properties.label.enabled;\n  }\n  nodeFactory() {\n    return new Group();\n  }\n  getFormattedMarkerStyle(datum) {\n    const { xKey, yKey } = datum;\n    return this.getMarkerStyle(this.properties.marker, { datum, xKey, yKey, highlighted: true });\n  }\n  computeFocusBounds(opts) {\n    return computeMarkerFocusBounds(this, opts);\n  }\n};\nAreaSeries.className = \"AreaSeries\";\nAreaSeries.type = \"area\";\n\n// packages/ag-charts-community/src/chart/series/cartesian/areaSeriesModule.ts\nvar AreaSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  identifier: \"area\",\n  moduleFactory: (ctx) => new AreaSeries(ctx),\n  stackable: true,\n  tooltipDefaults: { range: \"nearest\" },\n  defaultAxes: [\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"left\" /* LEFT */\n    },\n    {\n      type: \"category\" /* CATEGORY */,\n      position: \"bottom\" /* BOTTOM */\n    }\n  ],\n  themeTemplate: {\n    series: {\n      nodeClickRange: \"nearest\",\n      tooltip: { position: { type: \"node\" } },\n      fillOpacity: 0.8,\n      strokeOpacity: 1,\n      strokeWidth: 0,\n      lineDash: [0],\n      lineDashOffset: 0,\n      shadow: {\n        enabled: false,\n        color: DEFAULT_SHADOW_COLOUR,\n        xOffset: 3,\n        yOffset: 3,\n        blur: 5\n      },\n      interpolation: {\n        type: \"linear\",\n        // @ts-expect-error - users shouldn't specify all options, but we have to for theming to work\n        tension: 1,\n        position: \"end\"\n      },\n      marker: {\n        enabled: false,\n        shape: \"circle\",\n        size: 7,\n        strokeWidth: 0\n      },\n      label: {\n        enabled: false,\n        fontSize: 12,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_LABEL_COLOUR\n      }\n    }\n  },\n  paletteFactory: (params) => {\n    const { marker } = markerPaletteFactory(params);\n    return { fill: marker.fill, stroke: marker.stroke, marker };\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/util.ts\nfunction swapAxisCondition(axes, swap) {\n  return (series) => {\n    if (!swap(series))\n      return axes;\n    return [\n      { ...axes[0], position: axes[1].position },\n      { ...axes[1], position: axes[0].position }\n    ];\n  };\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/quadtreeUtil.ts\nfunction addHitTestersToQuadtree(quadtree, hitTesters) {\n  for (const node of hitTesters) {\n    const datum = node.datum;\n    if (datum === void 0) {\n      Logger.error(\"undefined datum\");\n    } else {\n      quadtree.addValue(node, datum);\n    }\n  }\n}\nfunction findQuadtreeMatch(series, point) {\n  const { x, y } = point;\n  const { nearest, distanceSquared: distanceSquared3 } = series.getQuadTree().find(x, y);\n  if (nearest !== void 0) {\n    return { datum: nearest.value, distance: Math.sqrt(distanceSquared3) };\n  }\n  return void 0;\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/abstractBarSeries.ts\nvar AbstractBarSeriesProperties = class extends CartesianSeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.direction = \"vertical\";\n  }\n};\n__decorateClass([\n  Validate(DIRECTION)\n], AbstractBarSeriesProperties.prototype, \"direction\", 2);\nvar AbstractBarSeries = class extends CartesianSeries {\n  constructor() {\n    super(...arguments);\n    /**\n     * Used to get the position of bars within each group.\n     */\n    this.groupScale = new BandScale();\n    this.smallestDataInterval = void 0;\n    this.largestDataInterval = void 0;\n  }\n  padBandExtent(keys, alignStart) {\n    const ratio2 = typeof alignStart === \"boolean\" ? 1 : 0.5;\n    const scalePadding = isFiniteNumber(this.smallestDataInterval) ? this.smallestDataInterval * ratio2 : 0;\n    const keysExtent = extent(keys) ?? [NaN, NaN];\n    if (typeof alignStart === \"boolean\") {\n      keysExtent[alignStart ? 0 : 1] -= (alignStart ? 1 : -1) * scalePadding;\n    } else {\n      keysExtent[0] -= scalePadding;\n      keysExtent[1] += scalePadding;\n    }\n    return fixNumericExtent(keysExtent);\n  }\n  getBandScalePadding() {\n    return { inner: 0.3, outer: 0.15 };\n  }\n  shouldFlipXY() {\n    return !this.isVertical();\n  }\n  isVertical() {\n    return this.properties.direction === \"vertical\";\n  }\n  getBarDirection() {\n    return this.shouldFlipXY() ? \"x\" /* X */ : \"y\" /* Y */;\n  }\n  getCategoryDirection() {\n    return this.shouldFlipXY() ? \"y\" /* Y */ : \"x\" /* X */;\n  }\n  getValueAxis() {\n    const direction = this.getBarDirection();\n    return this.axes[direction];\n  }\n  getCategoryAxis() {\n    const direction = this.getCategoryDirection();\n    return this.axes[direction];\n  }\n  getBandwidth(xAxis) {\n    return ContinuousScale.is(xAxis.scale) ? xAxis.scale.calcBandwidth(this.smallestDataInterval) : xAxis.scale.bandwidth;\n  }\n  updateGroupScale(xAxis) {\n    const domain = [];\n    const { groupScale } = this;\n    const xBandWidth = this.getBandwidth(xAxis);\n    const { index: groupIndex, visibleGroupCount } = this.ctx.seriesStateManager.getVisiblePeerGroupIndex(this);\n    for (let groupIdx = 0; groupIdx < visibleGroupCount; groupIdx++) {\n      domain.push(String(groupIdx));\n    }\n    groupScale.domain = domain;\n    groupScale.range = [0, xBandWidth ?? 0];\n    if (xAxis instanceof CategoryAxis) {\n      groupScale.paddingInner = xAxis.groupPaddingInner;\n    } else if (xAxis instanceof GroupedCategoryAxis) {\n      groupScale.padding = 0.1;\n    } else {\n      groupScale.padding = 0;\n    }\n    groupScale.round = groupScale.padding !== 0;\n    const barWidth = groupScale.bandwidth >= 1 ? (\n      // Pixel-rounded value for low-volume bar charts.\n      groupScale.bandwidth\n    ) : (\n      // Handle high-volume bar charts gracefully.\n      groupScale.rawBandwidth\n    );\n    return { barWidth, groupIndex };\n  }\n  resolveKeyDirection(direction) {\n    if (this.getBarDirection() === \"x\" /* X */) {\n      if (direction === \"x\" /* X */) {\n        return \"y\" /* Y */;\n      }\n      return \"x\" /* X */;\n    }\n    return direction;\n  }\n  initQuadTree(quadtree) {\n    addHitTestersToQuadtree(quadtree, this.datumNodesIter());\n  }\n  pickNodeClosestDatum(point) {\n    return findQuadtreeMatch(this, point);\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/cartesian/barSeriesProperties.ts\nvar BarSeriesLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.placement = \"inside-center\";\n    this.padding = 0;\n  }\n};\n__decorateClass([\n  Validate(\n    UNION(\n      [\n        \"inside-center\",\n        \"inside-start\",\n        \"inside-end\",\n        \"outside-start\",\n        \"outside-end\",\n        // @todo(AG-5950) Deprecate\n        { value: \"inside\", deprecatedTo: \"inside-center\" },\n        { value: \"outside\", deprecatedTo: \"outside-end\" }\n      ],\n      \"a placement\"\n    )\n  )\n], BarSeriesLabel.prototype, \"placement\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], BarSeriesLabel.prototype, \"padding\", 2);\nvar BarSeriesProperties = class extends AbstractBarSeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.fill = \"#c16068\";\n    this.fillOpacity = 1;\n    this.stroke = \"#874349\";\n    this.strokeWidth = 1;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.cornerRadius = 0;\n    this.crisp = void 0;\n    this.shadow = new DropShadow();\n    this.label = new BarSeriesLabel();\n    this.tooltip = new SeriesTooltip();\n    this.sparklineMode = false;\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], BarSeriesProperties.prototype, \"xKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BarSeriesProperties.prototype, \"xName\", 2);\n__decorateClass([\n  Validate(STRING)\n], BarSeriesProperties.prototype, \"yKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BarSeriesProperties.prototype, \"yName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BarSeriesProperties.prototype, \"yFilterKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BarSeriesProperties.prototype, \"stackGroup\", 2);\n__decorateClass([\n  Validate(NUMBER, { optional: true })\n], BarSeriesProperties.prototype, \"normalizedTo\", 2);\n__decorateClass([\n  Validate(COLOR_STRING)\n], BarSeriesProperties.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO)\n], BarSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(COLOR_STRING)\n], BarSeriesProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], BarSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO)\n], BarSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH)\n], BarSeriesProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], BarSeriesProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], BarSeriesProperties.prototype, \"cornerRadius\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], BarSeriesProperties.prototype, \"crisp\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], BarSeriesProperties.prototype, \"itemStyler\", 2);\n__decorateClass([\n  Validate(OBJECT, { optional: true })\n], BarSeriesProperties.prototype, \"shadow\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], BarSeriesProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], BarSeriesProperties.prototype, \"tooltip\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], BarSeriesProperties.prototype, \"sparklineMode\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/barUtil.ts\nfunction updateRect(rect, config) {\n  rect.crisp = config.crisp ?? true;\n  rect.fill = config.fill;\n  rect.stroke = config.stroke;\n  rect.strokeWidth = config.strokeWidth;\n  rect.fillOpacity = config.fillOpacity;\n  rect.strokeOpacity = config.strokeOpacity;\n  rect.lineDash = config.lineDash;\n  rect.lineDashOffset = config.lineDashOffset;\n  rect.fillShadow = config.fillShadow;\n  rect.topLeftCornerRadius = config.topLeftCornerRadius !== false ? config.cornerRadius ?? 0 : 0;\n  rect.topRightCornerRadius = config.topRightCornerRadius !== false ? config.cornerRadius ?? 0 : 0;\n  rect.bottomRightCornerRadius = config.bottomRightCornerRadius !== false ? config.cornerRadius ?? 0 : 0;\n  rect.bottomLeftCornerRadius = config.bottomLeftCornerRadius !== false ? config.cornerRadius ?? 0 : 0;\n  rect.visible = config.visible ?? true;\n}\nfunction getRectConfig({\n  datum,\n  isHighlighted,\n  style,\n  highlightStyle,\n  itemStyler,\n  seriesId,\n  ctx: { callbackCache },\n  ...opts\n}) {\n  const {\n    fill,\n    fillOpacity,\n    stroke,\n    strokeWidth,\n    strokeOpacity,\n    lineDash,\n    lineDashOffset,\n    cornerRadius = 0\n  } = mergeDefaults(isHighlighted && highlightStyle, style);\n  let format;\n  if (itemStyler) {\n    format = callbackCache.call(itemStyler, {\n      datum: datum.datum,\n      xKey: datum.xKey,\n      fill,\n      fillOpacity,\n      stroke,\n      strokeWidth,\n      strokeOpacity,\n      lineDash,\n      lineDashOffset,\n      cornerRadius,\n      highlighted: isHighlighted,\n      seriesId,\n      ...opts\n    });\n  }\n  return {\n    fill: format?.fill ?? fill,\n    fillOpacity: format?.fillOpacity ?? fillOpacity,\n    stroke: format?.stroke ?? stroke,\n    strokeWidth: format?.strokeWidth ?? strokeWidth,\n    strokeOpacity: format?.strokeOpacity ?? strokeOpacity,\n    lineDash: format?.lineDash ?? lineDash,\n    lineDashOffset: format?.lineDashOffset ?? lineDashOffset,\n    cornerRadius: format?.cornerRadius ?? cornerRadius,\n    topLeftCornerRadius: style.topLeftCornerRadius,\n    topRightCornerRadius: style.topRightCornerRadius,\n    bottomRightCornerRadius: style.bottomRightCornerRadius,\n    bottomLeftCornerRadius: style.bottomLeftCornerRadius,\n    fillShadow: style.fillShadow\n  };\n}\nfunction checkCrisp(scale2, visibleRange, smallestDataInterval, largestDataInterval) {\n  if (visibleRange != null) {\n    const [visibleMin, visibleMax] = visibleRange;\n    const isZoomed = visibleMin !== 0 || visibleMax !== 1;\n    if (isZoomed)\n      return false;\n  }\n  if (ContinuousScale.is(scale2)) {\n    const spacing = scale2.calcBandwidth(largestDataInterval) - scale2.calcBandwidth(smallestDataInterval);\n    if (spacing > 0 && spacing < 1)\n      return false;\n  }\n  return true;\n}\nvar isDatumNegative = (datum) => {\n  return isNegative(datum.yValue ?? 0);\n};\nfunction collapsedStartingBarPosition(isVertical, axes, mode) {\n  const { startingX, startingY } = getStartingValues(isVertical, axes);\n  const calculate = (datum, prevDatum) => {\n    let x = isVertical ? datum.x : startingX;\n    let y = isVertical ? startingY : datum.y;\n    let width2 = isVertical ? datum.width : 0;\n    let height2 = isVertical ? 0 : datum.height;\n    const { opacity } = datum;\n    if (prevDatum && (isNaN(x) || isNaN(y))) {\n      ({ x, y } = prevDatum);\n      width2 = isVertical ? prevDatum.width : 0;\n      height2 = isVertical ? 0 : prevDatum.height;\n      if (isVertical && !isDatumNegative(prevDatum)) {\n        y += prevDatum.height;\n      } else if (!isVertical && isDatumNegative(prevDatum)) {\n        x += prevDatum.width;\n      }\n    }\n    let clipBBox;\n    if (datum.clipBBox == null) {\n      clipBBox = void 0;\n    } else if (isDatumNegative(datum)) {\n      clipBBox = isVertical ? new BBox(x, y - height2, width2, height2) : new BBox(x - width2, y, width2, height2);\n    } else {\n      clipBBox = new BBox(x, y, width2, height2);\n    }\n    return { x, y, width: width2, height: height2, clipBBox, opacity };\n  };\n  return { isVertical, calculate, mode };\n}\nfunction midpointStartingBarPosition(isVertical, mode) {\n  return {\n    isVertical,\n    calculate: (datum) => {\n      return {\n        x: isVertical ? datum.x : datum.x + datum.width / 2,\n        y: isVertical ? datum.y + datum.height / 2 : datum.y,\n        width: isVertical ? datum.width : 0,\n        height: isVertical ? 0 : datum.height,\n        clipBBox: datum.clipBBox,\n        opacity: datum.opacity\n      };\n    },\n    mode\n  };\n}\nfunction prepareBarAnimationFunctions(initPos) {\n  const isRemoved = (datum) => datum == null || isNaN(datum.x) || isNaN(datum.y);\n  const fromFn = (rect, datum, status) => {\n    if (status === \"updated\" && isRemoved(datum)) {\n      status = \"removed\";\n    } else if (status === \"updated\" && isRemoved(rect.previousDatum)) {\n      status = \"added\";\n    }\n    let source;\n    if (status === \"added\" && rect.previousDatum == null && initPos.mode === \"fade\") {\n      source = { ...resetBarSelectionsFn(rect, datum), opacity: 0 };\n    } else if (status === \"unknown\" || status === \"added\") {\n      source = initPos.calculate(datum, rect.previousDatum);\n    } else {\n      source = {\n        x: rect.x,\n        y: rect.y,\n        width: rect.width,\n        height: rect.height,\n        clipBBox: rect.clipBBox,\n        opacity: rect.opacity\n      };\n    }\n    const phase = NODE_UPDATE_STATE_TO_PHASE_MAPPING[status];\n    return { ...source, phase };\n  };\n  const toFn = (rect, datum, status) => {\n    let source;\n    if (status === \"removed\" && rect.datum == null && initPos.mode === \"fade\") {\n      source = { ...resetBarSelectionsFn(rect, datum), opacity: 0 };\n    } else if (status === \"removed\" || isRemoved(datum)) {\n      source = initPos.calculate(datum, rect.previousDatum);\n    } else {\n      source = {\n        x: datum.x,\n        y: datum.y,\n        width: datum.width,\n        height: datum.height,\n        clipBBox: datum.clipBBox,\n        opacity: datum.opacity\n      };\n    }\n    return source;\n  };\n  return { toFn, fromFn };\n}\nfunction getStartingValues(isVertical, axes) {\n  const axis = axes[isVertical ? \"y\" /* Y */ : \"x\" /* X */];\n  let startingX = Infinity;\n  let startingY = 0;\n  if (!axis) {\n    return { startingX, startingY };\n  }\n  if (isVertical) {\n    startingY = axis.scale.convert(ContinuousScale.is(axis.scale) ? 0 : Math.max(...axis.range));\n  } else {\n    startingX = axis.scale.convert(ContinuousScale.is(axis.scale) ? 0 : Math.min(...axis.range));\n  }\n  return { startingX, startingY };\n}\nfunction resetBarSelectionsFn(_node, { x, y, width: width2, height: height2, clipBBox, opacity }) {\n  return { x, y, width: width2, height: height2, clipBBox, opacity };\n}\nfunction computeBarFocusBounds(datum, barGroup, seriesRect) {\n  if (datum === void 0)\n    return void 0;\n  const { x, y, width: width2, height: height2 } = datum;\n  return Transformable.toCanvas(barGroup, new BBox(x, y, width2, height2)).clip(seriesRect);\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/labelUtil.ts\nfunction updateLabelNode(textNode, label, labelDatum) {\n  if (label.enabled && labelDatum) {\n    const { x, y, text, textAlign, textBaseline } = labelDatum;\n    const { color: fill, fontStyle, fontWeight, fontSize, fontFamily } = label;\n    textNode.setProperties({\n      visible: true,\n      x,\n      y,\n      text,\n      fill,\n      fontStyle,\n      fontWeight,\n      fontSize,\n      fontFamily,\n      textAlign,\n      textBaseline\n    });\n  } else {\n    textNode.visible = false;\n  }\n}\nvar placements = {\n  \"inside-start\": { inside: true, direction: -1, textAlignment: 1 },\n  \"inside-end\": { inside: true, direction: 1, textAlignment: -1 },\n  \"outside-start\": { inside: false, direction: -1, textAlignment: -1 },\n  \"outside-end\": { inside: false, direction: 1, textAlignment: 1 }\n};\nfunction adjustLabelPlacement({\n  isUpward,\n  isVertical,\n  placement,\n  padding = 0,\n  rect\n}) {\n  let x = rect.x + rect.width / 2;\n  let y = rect.y + rect.height / 2;\n  let textAlign = \"center\";\n  let textBaseline = \"middle\";\n  if (placement !== \"inside-center\") {\n    const barDirection = (isUpward ? 1 : -1) * (isVertical ? -1 : 1);\n    const { direction, textAlignment } = placements[placement];\n    const displacementRatio = (direction + 1) * 0.5;\n    if (isVertical) {\n      const y0 = isUpward ? rect.y + rect.height : rect.y;\n      const height2 = rect.height * barDirection;\n      y = y0 + height2 * displacementRatio + padding * textAlignment * barDirection;\n      textBaseline = textAlignment === barDirection ? \"top\" : \"bottom\";\n    } else {\n      const x0 = isUpward ? rect.x : rect.x + rect.width;\n      const width2 = rect.width * barDirection;\n      x = x0 + width2 * displacementRatio + padding * textAlignment * barDirection;\n      textAlign = textAlignment === barDirection ? \"left\" : \"right\";\n    }\n  }\n  return { x, y, textAlign, textBaseline };\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/barSeries.ts\nvar labelPlacements2 = {\n  \"inside-center\": \"inside-center\",\n  \"inside-start\": \"inside-start\",\n  \"inside-end\": \"inside-end\",\n  \"outside-start\": \"outside-start\",\n  \"outside-end\": \"outside-end\",\n  inside: \"inside-center\",\n  outside: \"outside-end\"\n};\nvar BarSeries = class extends AbstractBarSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,\n      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,\n      pickModes: [\n        2 /* AXIS_ALIGNED */,\n        // Only used in sparklineMode\n        1 /* NEAREST_NODE */,\n        0 /* EXACT_SHAPE_MATCH */\n      ],\n      pathsPerSeries: [],\n      hasHighlightedLabels: true,\n      datumSelectionGarbageCollection: false,\n      animationAlwaysUpdateSelections: true,\n      animationResetFns: {\n        datum: resetBarSelectionsFn,\n        label: resetLabelFn\n      }\n    });\n    this.properties = new BarSeriesProperties();\n  }\n  get pickModeAxis() {\n    return this.properties.sparklineMode ? \"main\" : void 0;\n  }\n  crossFilteringEnabled() {\n    return this.properties.yFilterKey != null && (this.seriesGrouping == null || this.seriesGrouping.stackIndex === 0);\n  }\n  async processData(dataController) {\n    if (!this.properties.isValid() || !this.data) {\n      return;\n    }\n    const { seriesGrouping: { groupIndex = this.id } = {}, data = [] } = this;\n    const { xKey, yKey, yFilterKey, normalizedTo } = this.properties;\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    const xScale = this.getCategoryAxis()?.scale;\n    const yScale = this.getValueAxis()?.scale;\n    const { isContinuousX, xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });\n    const stackGroupName = `bar-stack-${groupIndex}-yValues`;\n    const stackGroupTrailingName = `${stackGroupName}-trailing`;\n    const extraProps = [];\n    if (isFiniteNumber(normalizedTo)) {\n      extraProps.push(\n        normaliseGroupTo([stackGroupName, stackGroupTrailingName], Math.abs(normalizedTo), \"range\")\n      );\n    }\n    if (animationEnabled && this.processedData) {\n      extraProps.push(diff(this.processedData));\n    }\n    if (animationEnabled) {\n      extraProps.push(animationValidation());\n    }\n    const visibleProps = this.visible ? {} : { forceValue: 0 };\n    const { processedData } = await this.requestDataModel(dataController, data, {\n      props: [\n        keyProperty(xKey, xScaleType, { id: \"xValue\" }),\n        valueProperty(yKey, yScaleType, { id: `yValue-raw`, invalidValue: null, ...visibleProps }),\n        ...this.crossFilteringEnabled() ? [\n          valueProperty(yFilterKey, yScaleType, {\n            id: `yFilterValue`,\n            invalidValue: null,\n            ...visibleProps\n          })\n        ] : [],\n        ...groupAccumulativeValueProperty(\n          yKey,\n          \"normal\",\n          \"current\",\n          {\n            id: `yValue-end`,\n            rangeId: `yValue-range`,\n            invalidValue: null,\n            missingValue: 0,\n            groupId: stackGroupName,\n            separateNegative: true,\n            ...visibleProps\n          },\n          yScaleType\n        ),\n        ...groupAccumulativeValueProperty(\n          yKey,\n          \"trailing\",\n          \"current\",\n          {\n            id: `yValue-start`,\n            invalidValue: null,\n            missingValue: 0,\n            groupId: stackGroupTrailingName,\n            separateNegative: true,\n            ...visibleProps\n          },\n          yScaleType\n        ),\n        ...isContinuousX ? [SMALLEST_KEY_INTERVAL, LARGEST_KEY_INTERVAL] : [],\n        ...extraProps\n      ],\n      groupByKeys: true,\n      groupByData: false\n    });\n    this.smallestDataInterval = processedData.reduced?.smallestKeyInterval;\n    this.largestDataInterval = processedData.reduced?.largestKeyInterval;\n    this.animationState.transition(\"updateData\");\n  }\n  getSeriesDomain(direction) {\n    const { processedData, dataModel } = this;\n    if (!dataModel || !processedData?.data.length)\n      return [];\n    const keyDef = dataModel.resolveProcessedDataDefById(this, `xValue`);\n    const keys = dataModel.getDomain(this, `xValue`, \"key\", processedData);\n    let yExtent = dataModel.getDomain(this, `yValue-end`, \"value\", processedData);\n    const yFilterExtent = this.crossFilteringEnabled() ? dataModel.getDomain(this, `yFilterValue`, \"value\", processedData) : void 0;\n    if (yFilterExtent != null) {\n      yExtent = [Math.min(yExtent[0], yFilterExtent[0]), Math.max(yExtent[1], yFilterExtent[1])];\n    }\n    if (direction === this.getCategoryDirection()) {\n      if (keyDef?.def.type === \"key\" && keyDef.def.valueType === \"category\") {\n        return keys;\n      }\n      return this.padBandExtent(keys);\n    } else if (this.getValueAxis() instanceof LogAxis) {\n      return fixNumericExtent(yExtent);\n    } else {\n      const fixedYExtent = [Math.min(0, yExtent[0]), Math.max(0, yExtent[1])];\n      return fixNumericExtent(fixedYExtent);\n    }\n  }\n  async createNodeData() {\n    const { dataModel } = this;\n    const xAxis = this.getCategoryAxis();\n    const yAxis = this.getValueAxis();\n    if (!dataModel || !xAxis || !yAxis || !this.properties.isValid())\n      return;\n    const xScale = xAxis.scale;\n    const yScale = yAxis.scale;\n    const { xKey, yKey, xName, yName, fill, stroke, strokeWidth, cornerRadius, legendItemName, label } = this.properties;\n    const yReversed = yAxis.isReversed();\n    const { barWidth, groupIndex } = this.updateGroupScale(xAxis);\n    const barOffset = ContinuousScale.is(xScale) ? barWidth * -0.5 : 0;\n    const xIndex = dataModel.resolveProcessedDataIndexById(this, `xValue`);\n    const yRawIndex = dataModel.resolveProcessedDataIndexById(this, `yValue-raw`);\n    const yFilterIndex = this.crossFilteringEnabled() ? dataModel.resolveProcessedDataIndexById(this, `yFilterValue`) : void 0;\n    const yStartIndex = dataModel.resolveProcessedDataIndexById(this, `yValue-start`);\n    const yEndIndex = dataModel.resolveProcessedDataIndexById(this, `yValue-end`);\n    const yRangeIndex = dataModel.resolveProcessedDataIndexById(this, `yValue-range`);\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    const nodeDatum = ({\n      datum,\n      valueIndex,\n      xValue,\n      yValue,\n      cumulativeValue,\n      phantom,\n      currY,\n      prevY,\n      isPositive,\n      yRange,\n      labelText,\n      crossScale = 1\n    }) => {\n      const x = xScale.convert(xValue);\n      const isUpward = isPositive !== yReversed;\n      const barX = x + groupScale.convert(String(groupIndex)) + barOffset;\n      const y = yScale.convert(currY);\n      const bottomY = yScale.convert(prevY);\n      const barAlongX = this.getBarDirection() === \"x\" /* X */;\n      const bboxHeight = yScale.convert(yRange);\n      const bboxBottom = yScale.convert(0);\n      const xOffset = barWidth * 0.5 * (1 - crossScale);\n      const rect = {\n        x: barAlongX ? Math.min(y, bottomY) : barX + xOffset,\n        y: barAlongX ? barX + xOffset : Math.min(y, bottomY),\n        width: barAlongX ? Math.abs(bottomY - y) : barWidth * crossScale,\n        height: barAlongX ? barWidth * crossScale : Math.abs(bottomY - y)\n      };\n      const clipBBox = new BBox(rect.x, rect.y, rect.width, rect.height);\n      const barRect = {\n        x: barAlongX ? Math.min(bboxBottom, bboxHeight) : barX + xOffset,\n        y: barAlongX ? barX + xOffset : Math.min(bboxBottom, bboxHeight),\n        width: barAlongX ? Math.abs(bboxBottom - bboxHeight) : barWidth * crossScale,\n        height: barAlongX ? barWidth * crossScale : Math.abs(bboxBottom - bboxHeight)\n      };\n      const lengthRatioMultiplier = this.shouldFlipXY() ? rect.height : rect.width;\n      return {\n        series: this,\n        itemId: phantom ? createDatumId(yKey, phantom) : yKey,\n        datum,\n        valueIndex,\n        cumulativeValue,\n        phantom,\n        xValue,\n        yValue,\n        yKey,\n        xKey,\n        capDefaults: {\n          lengthRatioMultiplier,\n          lengthMax: lengthRatioMultiplier\n        },\n        x: barRect.x,\n        y: barRect.y,\n        width: barRect.width,\n        height: barRect.height,\n        midPoint: { x: rect.x + rect.width / 2, y: rect.y + rect.height / 2 },\n        fill,\n        stroke,\n        opacity: 1,\n        strokeWidth,\n        cornerRadius,\n        topLeftCornerRadius: barAlongX !== isUpward,\n        topRightCornerRadius: isUpward,\n        bottomRightCornerRadius: barAlongX === isUpward,\n        bottomLeftCornerRadius: !isUpward,\n        clipBBox,\n        label: labelText != null ? {\n          text: labelText,\n          ...adjustLabelPlacement({\n            isUpward,\n            isVertical: !barAlongX,\n            placement: labelPlacements2[label.placement],\n            padding: label.padding,\n            rect\n          })\n        } : void 0,\n        missing: yValue == null,\n        focusable: !phantom\n      };\n    };\n    const { groupScale, processedData } = this;\n    const phantomNodes = [];\n    const nodes = [];\n    const labels = [];\n    processedData?.data.forEach(({ keys, datum: seriesDatum, values, aggValues }) => {\n      values.forEach((value, valueIndex) => {\n        const xValue = keys[xIndex];\n        const yRawValue = value[yRawIndex];\n        const yStart = Number(value[yStartIndex]);\n        const yFilterValue = yFilterIndex != null ? Number(value[yFilterIndex]) : void 0;\n        const yEnd = Number(value[yEndIndex]);\n        const isPositive = yRawValue >= 0 && !Object.is(yRawValue, -0);\n        const yRange = aggValues?.[yRangeIndex][isPositive ? 1 : 0] ?? 0;\n        if (!Number.isFinite(yEnd))\n          return;\n        if (yFilterValue != null && !Number.isFinite(yFilterValue))\n          return;\n        const labelText = yRawValue != null ? this.getLabelText(\n          this.properties.label,\n          {\n            datum: seriesDatum[valueIndex],\n            value: yFilterValue ?? yRawValue,\n            xKey,\n            yKey,\n            xName,\n            yName,\n            legendItemName\n          },\n          formatValue\n        ) : void 0;\n        const inset = yFilterValue != null && yFilterValue > yRawValue;\n        const nodeData = nodeDatum({\n          datum: seriesDatum[valueIndex],\n          valueIndex,\n          xValue,\n          yValue: yFilterValue ?? yRawValue,\n          cumulativeValue: yFilterValue ?? yEnd,\n          phantom: false,\n          currY: yFilterValue != null ? yStart + yFilterValue : yEnd,\n          prevY: yStart,\n          isPositive,\n          yRange: Math.max(yStart + (yFilterValue ?? -Infinity), yRange),\n          labelText,\n          crossScale: inset ? 0.6 : void 0\n        });\n        nodes.push(nodeData);\n        labels.push(nodeData);\n        if (yFilterValue != null) {\n          const phantomNodeData = nodeDatum({\n            datum: seriesDatum[valueIndex],\n            valueIndex,\n            xValue,\n            yValue: yFilterValue,\n            cumulativeValue: yFilterValue,\n            phantom: true,\n            currY: yEnd,\n            prevY: yStart,\n            isPositive,\n            yRange,\n            labelText: void 0,\n            crossScale: void 0\n          });\n          phantomNodes.push(phantomNodeData);\n        }\n      });\n    });\n    return {\n      itemId: yKey,\n      nodeData: phantomNodes.length > 0 ? [...phantomNodes, ...nodes] : nodes,\n      labelData: labels,\n      scales: this.calculateScaling(),\n      visible: this.visible || animationEnabled\n    };\n  }\n  nodeFactory() {\n    return new Rect();\n  }\n  getHighlightData(nodeData, highlightedItem) {\n    const highlightItem = nodeData.find(\n      (nodeDatum) => nodeDatum.datum === highlightedItem.datum && !nodeDatum.phantom\n    );\n    return highlightItem != null ? [highlightItem] : void 0;\n  }\n  async updateDatumSelection(opts) {\n    return opts.datumSelection.update(\n      opts.nodeData,\n      void 0,\n      (datum) => createDatumId(datum.xValue, datum.valueIndex, datum.phantom)\n    );\n  }\n  async updateDatumNodes(opts) {\n    if (!this.properties.isValid()) {\n      return;\n    }\n    const {\n      yKey,\n      stackGroup,\n      fill,\n      fillOpacity,\n      stroke,\n      strokeWidth,\n      strokeOpacity,\n      lineDash,\n      lineDashOffset,\n      itemStyler,\n      shadow,\n      highlightStyle: { item: itemHighlightStyle }\n    } = this.properties;\n    const xAxis = this.axes[\"x\" /* X */];\n    const crisp = this.properties.crisp ?? checkCrisp(xAxis?.scale, xAxis?.visibleRange, this.smallestDataInterval, this.largestDataInterval);\n    const categoryAlongX = this.getCategoryDirection() === \"x\" /* X */;\n    const style = {\n      fill,\n      stroke,\n      lineDash,\n      lineDashOffset,\n      fillShadow: shadow,\n      strokeWidth: this.getStrokeWidth(strokeWidth),\n      fillOpacity: 0,\n      strokeOpacity: 0\n    };\n    const rectParams = {\n      datum: void 0,\n      ctx: this.ctx,\n      seriesId: this.id,\n      isHighlighted: opts.isHighlight,\n      highlightStyle: itemHighlightStyle,\n      yKey,\n      style,\n      itemStyler,\n      stackGroup\n    };\n    opts.datumSelection.each((rect, datum) => {\n      style.fillOpacity = fillOpacity * (datum.phantom ? 0.2 : 1);\n      style.strokeOpacity = strokeOpacity * (datum.phantom ? 0.2 : 1);\n      style.cornerRadius = datum.cornerRadius;\n      style.topLeftCornerRadius = datum.topLeftCornerRadius;\n      style.topRightCornerRadius = datum.topRightCornerRadius;\n      style.bottomRightCornerRadius = datum.bottomRightCornerRadius;\n      style.bottomLeftCornerRadius = datum.bottomLeftCornerRadius;\n      const visible = categoryAlongX ? (datum.clipBBox?.width ?? datum.width) > 0 : (datum.clipBBox?.height ?? datum.height) > 0;\n      rectParams.datum = datum;\n      const config = getRectConfig(rectParams);\n      config.crisp = crisp;\n      config.visible = visible;\n      updateRect(rect, config);\n    });\n  }\n  async updateLabelSelection(opts) {\n    const data = this.isLabelEnabled() ? opts.labelData : [];\n    return opts.labelSelection.update(data, (text) => {\n      text.pointerEvents = 1 /* None */;\n    });\n  }\n  async updateLabelNodes(opts) {\n    opts.labelSelection.each((textNode, datum) => {\n      updateLabelNode(textNode, this.properties.label, datum.label);\n    });\n  }\n  getTooltipHtml(nodeDatum) {\n    const {\n      id: seriesId,\n      processedData,\n      ctx: { callbackCache }\n    } = this;\n    const xAxis = this.getCategoryAxis();\n    const yAxis = this.getValueAxis();\n    if (!processedData || !this.properties.isValid() || !xAxis || !yAxis) {\n      return EMPTY_TOOLTIP_CONTENT;\n    }\n    const { xKey, yKey, xName, yName, fill, stroke, strokeWidth, tooltip, itemStyler, stackGroup, legendItemName } = this.properties;\n    const { xValue, yValue, datum, itemId } = nodeDatum;\n    const xString = xAxis.formatDatum(xValue);\n    const yString = yAxis.formatDatum(yValue);\n    const title = sanitizeHtml(yName);\n    const content = sanitizeHtml(xString + \": \" + yString);\n    let format;\n    if (itemStyler) {\n      format = callbackCache.call(itemStyler, {\n        seriesId,\n        datum,\n        xKey,\n        yKey,\n        stackGroup,\n        fill,\n        stroke,\n        strokeWidth: this.getStrokeWidth(strokeWidth),\n        highlighted: false,\n        cornerRadius: this.properties.cornerRadius,\n        fillOpacity: this.properties.fillOpacity,\n        strokeOpacity: this.properties.strokeOpacity,\n        lineDash: this.properties.lineDash ?? [],\n        lineDashOffset: this.properties.lineDashOffset\n      });\n    }\n    const color = format?.fill ?? fill;\n    return tooltip.toTooltipHtml(\n      { title, content, backgroundColor: color },\n      {\n        seriesId,\n        itemId,\n        datum,\n        xKey,\n        yKey,\n        xName,\n        yName,\n        stackGroup,\n        title,\n        color,\n        legendItemName,\n        ...this.getModuleTooltipParams()\n      }\n    );\n  }\n  getLegendData(legendType) {\n    const { showInLegend } = this.properties;\n    if (legendType !== \"category\" || !this.data?.length || !this.properties.isValid() || !showInLegend) {\n      return [];\n    }\n    const { yKey, yName, fill, stroke, strokeWidth, fillOpacity, strokeOpacity, legendItemName, visible } = this.properties;\n    return [\n      {\n        legendType: \"category\",\n        id: this.id,\n        itemId: yKey,\n        seriesId: this.id,\n        enabled: visible,\n        label: { text: legendItemName ?? yName ?? yKey },\n        symbols: [{ marker: { fill, fillOpacity, stroke, strokeWidth, strokeOpacity } }],\n        legendItemName\n      }\n    ];\n  }\n  animateEmptyUpdateReady({ datumSelection, labelSelection, annotationSelections }) {\n    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(this.isVertical(), this.axes, \"normal\"));\n    fromToMotion(this.id, \"nodes\", this.ctx.animationManager, [datumSelection], fns);\n    seriesLabelFadeInAnimation(this, \"labels\", this.ctx.animationManager, labelSelection);\n    seriesLabelFadeInAnimation(this, \"annotations\", this.ctx.animationManager, ...annotationSelections);\n  }\n  animateWaitingUpdateReady(data) {\n    const { datumSelection, labelSelection, annotationSelections, previousContextData } = data;\n    this.ctx.animationManager.stopByAnimationGroupId(this.id);\n    const dataDiff = this.processedData?.reduced?.diff;\n    const mode = previousContextData == null ? \"fade\" : \"normal\";\n    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(this.isVertical(), this.axes, mode));\n    fromToMotion(\n      this.id,\n      \"nodes\",\n      this.ctx.animationManager,\n      [datumSelection],\n      fns,\n      (_, datum) => createDatumId(datum.xValue, datum.valueIndex, datum.phantom),\n      dataDiff\n    );\n    const hasMotion = dataDiff?.changed ?? true;\n    if (hasMotion) {\n      seriesLabelFadeInAnimation(this, \"labels\", this.ctx.animationManager, labelSelection);\n      seriesLabelFadeInAnimation(this, \"annotations\", this.ctx.animationManager, ...annotationSelections);\n    }\n  }\n  isLabelEnabled() {\n    return this.properties.label.enabled;\n  }\n  computeFocusBounds({ datumIndex, seriesRect }) {\n    const datumBox = this.contextNodeData?.nodeData[datumIndex].clipBBox;\n    return computeBarFocusBounds(datumBox, this.contentGroup, seriesRect);\n  }\n};\nBarSeries.className = \"BarSeries\";\nBarSeries.type = \"bar\";\n\n// packages/ag-charts-community/src/chart/series/cartesian/barSeriesModule.ts\nvar BarSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  identifier: \"bar\",\n  moduleFactory: (ctx) => new BarSeries(ctx),\n  stackable: true,\n  groupable: true,\n  tooltipDefaults: { range: \"exact\" },\n  defaultAxes: swapAxisCondition(\n    [\n      { type: \"number\" /* NUMBER */, position: \"left\" /* LEFT */ },\n      { type: \"category\" /* CATEGORY */, position: \"bottom\" /* BOTTOM */ }\n    ],\n    (series) => series?.direction === \"horizontal\"\n  ),\n  themeTemplate: {\n    series: {\n      direction: \"vertical\",\n      fillOpacity: 1,\n      strokeWidth: 0,\n      lineDash: [0],\n      lineDashOffset: 0,\n      label: {\n        enabled: false,\n        fontWeight: \"normal\" /* NORMAL */,\n        fontSize: 12,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR,\n        placement: \"inside-center\"\n      },\n      shadow: {\n        enabled: false,\n        color: DEFAULT_SHADOW_COLOUR,\n        xOffset: 3,\n        yOffset: 3,\n        blur: 5\n      },\n      errorBar: {\n        cap: {\n          lengthRatio: 0.3\n        }\n      }\n    }\n  },\n  paletteFactory: singleSeriesPaletteFactory\n};\n\n// packages/ag-charts-community/src/chart/series/cartesian/bubbleSeriesProperties.ts\nvar BubbleSeriesMarker = class extends SeriesMarker {\n  constructor() {\n    super(...arguments);\n    this.maxSize = 30;\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], BubbleSeriesMarker.prototype, \"maxSize\", 2);\n__decorateClass([\n  Validate(NUMBER_ARRAY, { optional: true }),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], BubbleSeriesMarker.prototype, \"domain\", 2);\nvar BubbleSeriesLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.placement = \"top\";\n  }\n};\n__decorateClass([\n  Validate(LABEL_PLACEMENT)\n], BubbleSeriesLabel.prototype, \"placement\", 2);\nvar BubbleSeriesProperties = class extends CartesianSeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.colorRange = [\"#ffff00\", \"#00ff00\", \"#0000ff\"];\n    this.label = new BubbleSeriesLabel();\n    this.tooltip = new SeriesTooltip();\n    // No validation. Not a part of the options contract.\n    this.marker = new BubbleSeriesMarker();\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], BubbleSeriesProperties.prototype, \"xKey\", 2);\n__decorateClass([\n  Validate(STRING)\n], BubbleSeriesProperties.prototype, \"yKey\", 2);\n__decorateClass([\n  Validate(STRING)\n], BubbleSeriesProperties.prototype, \"sizeKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"labelKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"colorKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"xFilterKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"yFilterKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"sizeFilterKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"xName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"yName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"sizeName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"labelName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"colorName\", 2);\n__decorateClass([\n  Validate(NUMBER_ARRAY, { optional: true })\n], BubbleSeriesProperties.prototype, \"colorDomain\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], BubbleSeriesProperties.prototype, \"colorRange\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"title\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.shape\")\n], BubbleSeriesProperties.prototype, \"shape\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.size\")\n], BubbleSeriesProperties.prototype, \"size\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.maxSize\")\n], BubbleSeriesProperties.prototype, \"maxSize\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.domain\", { optional: true })\n], BubbleSeriesProperties.prototype, \"domain\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.fill\", { optional: true })\n], BubbleSeriesProperties.prototype, \"fill\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.fillOpacity\")\n], BubbleSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.stroke\", { optional: true })\n], BubbleSeriesProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.strokeWidth\")\n], BubbleSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.strokeOpacity\")\n], BubbleSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.itemStyler\", { optional: true })\n], BubbleSeriesProperties.prototype, \"itemStyler\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], BubbleSeriesProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], BubbleSeriesProperties.prototype, \"tooltip\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/bubbleSeries.ts\nvar BubbleSeriesNodeEvent = class extends CartesianSeriesNodeEvent {\n  constructor(type, nativeEvent, datum, series) {\n    super(type, nativeEvent, datum, series);\n    this.sizeKey = series.properties.sizeKey;\n  }\n};\nvar BubbleSeries = class extends CartesianSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,\n      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,\n      pickModes: [\n        2 /* AXIS_ALIGNED */,\n        1 /* NEAREST_NODE */,\n        0 /* EXACT_SHAPE_MATCH */\n      ],\n      pathsPerSeries: [],\n      hasMarkers: true,\n      markerSelectionGarbageCollection: false,\n      animationResetFns: {\n        label: resetLabelFn,\n        marker: resetMarkerFn\n      }\n    });\n    this.NodeEvent = BubbleSeriesNodeEvent;\n    this.properties = new BubbleSeriesProperties();\n    this.sizeScale = new LinearScale();\n    this.colorScale = new ColorScale();\n  }\n  get pickModeAxis() {\n    return \"main-category\";\n  }\n  async processData(dataController) {\n    if (!this.properties.isValid() || this.data == null || !this.visible)\n      return;\n    const xScale = this.axes[\"x\" /* X */]?.scale;\n    const yScale = this.axes[\"y\" /* Y */]?.scale;\n    const { xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });\n    const colorScaleType = this.colorScale.type;\n    const sizeScaleType = this.sizeScale.type;\n    const {\n      xKey,\n      yKey,\n      sizeKey,\n      xFilterKey,\n      yFilterKey,\n      sizeFilterKey,\n      labelKey,\n      colorDomain,\n      colorRange,\n      colorKey,\n      marker\n    } = this.properties;\n    const { dataModel, processedData } = await this.requestDataModel(dataController, this.data, {\n      props: [\n        valueProperty(xKey, xScaleType, { id: `xValue` }),\n        valueProperty(yKey, yScaleType, { id: `yValue` }),\n        ...xFilterKey != null ? [valueProperty(xFilterKey, xScaleType, { id: `xFilterValue` })] : [],\n        ...yFilterKey != null ? [valueProperty(yFilterKey, yScaleType, { id: `yFilterValue` })] : [],\n        ...sizeFilterKey != null ? [valueProperty(sizeFilterKey, sizeScaleType, { id: `sizeFilterValue` })] : [],\n        valueProperty(sizeKey, sizeScaleType, { id: `sizeValue` }),\n        ...colorKey ? [valueProperty(colorKey, colorScaleType, { id: `colorValue` })] : [],\n        ...labelKey ? [valueProperty(labelKey, \"band\", { id: `labelValue` })] : []\n      ]\n    });\n    const sizeKeyIdx = dataModel.resolveProcessedDataIndexById(this, `sizeValue`);\n    const processedSize = processedData.domain.values[sizeKeyIdx] ?? [];\n    this.sizeScale.domain = marker.domain ? marker.domain : processedSize;\n    if (colorKey) {\n      const colorKeyIdx = dataModel.resolveProcessedDataIndexById(this, `colorValue`);\n      this.colorScale.domain = colorDomain ?? processedData.domain.values[colorKeyIdx] ?? [];\n      this.colorScale.range = colorRange;\n      this.colorScale.update();\n    }\n    this.animationState.transition(\"updateData\");\n  }\n  getSeriesDomain(direction) {\n    const { dataModel, processedData } = this;\n    if (!processedData || !dataModel)\n      return [];\n    const id = direction === \"x\" /* X */ ? `xValue` : `yValue`;\n    const dataDef = dataModel.resolveProcessedDataDefById(this, id);\n    const domain = dataModel.getDomain(this, id, \"value\", processedData);\n    if (dataDef?.def.type === \"value\" && dataDef?.def.valueType === \"category\") {\n      return domain;\n    }\n    return fixNumericExtent(extent(domain));\n  }\n  async createNodeData() {\n    const { axes, dataModel, processedData, colorScale, sizeScale } = this;\n    const {\n      xKey,\n      yKey,\n      sizeKey,\n      xFilterKey,\n      yFilterKey,\n      sizeFilterKey,\n      labelKey,\n      xName,\n      yName,\n      sizeName,\n      labelName,\n      label,\n      colorKey,\n      marker,\n      visible\n    } = this.properties;\n    const markerShape = getMarker(marker.shape);\n    const { placement } = label;\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    if (!(dataModel && processedData && visible && xAxis && yAxis)) {\n      return;\n    }\n    const xDataIdx = dataModel.resolveProcessedDataIndexById(this, `xValue`);\n    const yDataIdx = dataModel.resolveProcessedDataIndexById(this, `yValue`);\n    const sizeDataIdx = sizeKey != null ? dataModel.resolveProcessedDataIndexById(this, `sizeValue`) : void 0;\n    const colorDataIdx = colorKey != null ? dataModel.resolveProcessedDataIndexById(this, `colorValue`) : -1;\n    const labelDataIdx = labelKey != null ? dataModel.resolveProcessedDataIndexById(this, `labelValue`) : -1;\n    const xFilterDataIdx = xFilterKey != null ? dataModel.resolveProcessedDataIndexById(this, `xFilterValue`) : void 0;\n    const yFilterDataIdx = yFilterKey != null ? dataModel.resolveProcessedDataIndexById(this, `yFilterValue`) : void 0;\n    const sizeFilterDataIdx = sizeFilterKey != null ? dataModel.resolveProcessedDataIndexById(this, `sizeFilterValue`) : void 0;\n    const xScale = xAxis.scale;\n    const yScale = yAxis.scale;\n    const xOffset = (xScale.bandwidth ?? 0) / 2;\n    const yOffset = (yScale.bandwidth ?? 0) / 2;\n    const nodeData = [];\n    sizeScale.range = [marker.size, marker.maxSize];\n    const font = label.getFont();\n    const textMeasurer = CachedTextMeasurerPool.getMeasurer({ font });\n    for (const { values, datum } of processedData.data ?? []) {\n      const xDatum = values[xDataIdx];\n      const yDatum = values[yDataIdx];\n      const sizeValue = sizeDataIdx != null ? values[sizeDataIdx] : void 0;\n      const x = xScale.convert(xDatum) + xOffset;\n      const y = yScale.convert(yDatum) + yOffset;\n      let selected;\n      if (xFilterDataIdx != null && yFilterDataIdx != null) {\n        selected = values[xFilterDataIdx] === xDatum && values[yFilterDataIdx] === yDatum;\n        if (sizeFilterDataIdx != null) {\n          selected && (selected = values[sizeFilterDataIdx] === sizeValue);\n        }\n      }\n      const labelText = this.getLabelText(label, {\n        value: labelKey ? values[labelDataIdx] : yDatum,\n        datum,\n        xKey,\n        yKey,\n        sizeKey,\n        labelKey,\n        xName,\n        yName,\n        sizeName,\n        labelName\n      });\n      const size = textMeasurer.measureText(String(labelText));\n      const markerSize = sizeValue ? sizeScale.convert(sizeValue) : marker.size;\n      const fill = colorKey ? colorScale.convert(values[colorDataIdx]) : void 0;\n      nodeData.push({\n        series: this,\n        itemId: yKey,\n        yKey,\n        xKey,\n        datum,\n        xValue: xDatum,\n        yValue: yDatum,\n        sizeValue,\n        point: { x, y, size: markerSize },\n        midPoint: { x, y },\n        fill,\n        label: { text: labelText, ...size },\n        marker: markerShape,\n        placement,\n        selected\n      });\n    }\n    return {\n      itemId: yKey,\n      nodeData,\n      labelData: nodeData,\n      scales: this.calculateScaling(),\n      visible: this.visible\n    };\n  }\n  isPathOrSelectionDirty() {\n    return this.properties.marker.isDirty();\n  }\n  getLabelData() {\n    return this.contextNodeData?.labelData ?? [];\n  }\n  markerFactory() {\n    const { shape } = this.properties.marker;\n    const MarkerShape = getMarker(shape);\n    return new MarkerShape();\n  }\n  async updateMarkerSelection(opts) {\n    const { nodeData, markerSelection } = opts;\n    if (this.properties.marker.isDirty()) {\n      markerSelection.clear();\n      markerSelection.cleanup();\n    }\n    const data = this.properties.marker.enabled ? nodeData : [];\n    return markerSelection.update(\n      data,\n      void 0,\n      (datum) => createDatumId([datum.xValue, datum.yValue, datum.label.text])\n    );\n  }\n  async updateMarkerNodes(opts) {\n    const { markerSelection, isHighlight: highlighted } = opts;\n    const { xKey, yKey, sizeKey, labelKey, marker } = this.properties;\n    const { size, shape, fill, fillOpacity, stroke, strokeWidth, strokeOpacity } = mergeDefaults(\n      highlighted && this.properties.highlightStyle.item,\n      marker.getStyle()\n    );\n    const baseStyle = { size, shape, fill, fillOpacity, stroke, strokeWidth, strokeOpacity };\n    this.sizeScale.range = [marker.size, marker.maxSize];\n    markerSelection.each((node, datum) => {\n      this.updateMarkerStyle(node, marker, { datum, highlighted, xKey, yKey, sizeKey, labelKey }, baseStyle, {\n        selected: datum.selected\n      });\n    });\n    if (!highlighted) {\n      this.properties.marker.markClean();\n    }\n  }\n  async updateLabelSelection(opts) {\n    const placedLabels = this.properties.label.enabled ? this.chart?.placeLabels().get(this) ?? [] : [];\n    return opts.labelSelection.update(\n      placedLabels.map((v) => ({\n        ...v.datum,\n        point: {\n          x: v.x,\n          y: v.y,\n          size: v.datum.point.size\n        }\n      }))\n    );\n  }\n  async updateLabelNodes(opts) {\n    const { label } = this.properties;\n    opts.labelSelection.each((text, datum) => {\n      text.text = datum.label.text;\n      text.fill = label.color;\n      text.x = datum.point?.x ?? 0;\n      text.y = datum.point?.y ?? 0;\n      text.fontStyle = label.fontStyle;\n      text.fontWeight = label.fontWeight;\n      text.fontSize = label.fontSize;\n      text.fontFamily = label.fontFamily;\n      text.textAlign = \"left\";\n      text.textBaseline = \"top\";\n    });\n  }\n  getTooltipHtml(nodeDatum) {\n    const xAxis = this.axes[\"x\" /* X */];\n    const yAxis = this.axes[\"y\" /* Y */];\n    if (!this.properties.isValid() || !xAxis || !yAxis) {\n      return EMPTY_TOOLTIP_CONTENT;\n    }\n    const { xKey, yKey, sizeKey, labelKey, xName, yName, sizeName, labelName, marker, tooltip } = this.properties;\n    const title = this.properties.title ?? yName;\n    const baseStyle = mergeDefaults(\n      { fill: nodeDatum.fill, strokeWidth: this.getStrokeWidth(marker.strokeWidth) },\n      marker.getStyle()\n    );\n    const { fill: color = \"gray\" } = this.getMarkerStyle(\n      marker,\n      { datum: nodeDatum, highlighted: false, xKey, yKey, sizeKey, labelKey },\n      baseStyle\n    );\n    const {\n      datum,\n      xValue,\n      yValue,\n      sizeValue,\n      label: { text: labelText },\n      itemId\n    } = nodeDatum;\n    const xString = sanitizeHtml(xAxis.formatDatum(xValue));\n    const yString = sanitizeHtml(yAxis.formatDatum(yValue));\n    let content = `<b>${sanitizeHtml(xName ?? xKey)}</b>: ${xString}<br><b>${sanitizeHtml(yName ?? yKey)}</b>: ${yString}`;\n    if (sizeKey) {\n      content += `<br><b>${sanitizeHtml(sizeName ?? sizeKey)}</b>: ${sanitizeHtml(String(sizeValue))}`;\n    }\n    if (labelKey) {\n      content = `<b>${sanitizeHtml(labelName ?? labelKey)}</b>: ${sanitizeHtml(labelText)}<br>` + content;\n    }\n    return tooltip.toTooltipHtml(\n      { title, content, backgroundColor: color },\n      {\n        datum,\n        itemId,\n        xKey,\n        xName,\n        yKey,\n        yName,\n        sizeKey,\n        sizeName,\n        labelKey,\n        labelName,\n        title,\n        color,\n        seriesId: this.id\n      }\n    );\n  }\n  getLegendData() {\n    if (!this.data?.length || !this.properties.isValid()) {\n      return [];\n    }\n    const { yKey, yName, title, marker, visible } = this.properties;\n    const { shape, fill, stroke, fillOpacity, strokeOpacity, strokeWidth } = marker;\n    return [\n      {\n        legendType: \"category\",\n        id: this.id,\n        itemId: yKey,\n        seriesId: this.id,\n        enabled: visible,\n        label: {\n          text: title ?? yName ?? yKey\n        },\n        symbols: [\n          {\n            marker: {\n              shape,\n              fill: fill ?? \"rgba(0, 0, 0, 0)\",\n              stroke: stroke ?? \"rgba(0, 0, 0, 0)\",\n              fillOpacity: fillOpacity ?? 1,\n              strokeOpacity: strokeOpacity ?? 1,\n              strokeWidth: strokeWidth ?? 0\n            }\n          }\n        ]\n      }\n    ];\n  }\n  animateEmptyUpdateReady({ markerSelection, labelSelection }) {\n    markerScaleInAnimation(this, this.ctx.animationManager, markerSelection);\n    seriesLabelFadeInAnimation(this, \"labels\", this.ctx.animationManager, labelSelection);\n  }\n  isLabelEnabled() {\n    return this.properties.label.enabled;\n  }\n  nodeFactory() {\n    return new Group();\n  }\n  getFormattedMarkerStyle(datum) {\n    const { xKey, yKey, sizeKey, labelKey } = this.properties;\n    return this.getMarkerStyle(this.properties.marker, {\n      datum,\n      xKey,\n      yKey,\n      sizeKey,\n      labelKey,\n      highlighted: false\n    });\n  }\n  computeFocusBounds(opts) {\n    return computeMarkerFocusBounds(this, opts);\n  }\n};\nBubbleSeries.className = \"BubbleSeries\";\nBubbleSeries.type = \"bubble\";\n\n// packages/ag-charts-community/src/chart/series/cartesian/bubbleSeriesModule.ts\nvar BubbleSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  identifier: \"bubble\",\n  moduleFactory: (ctx) => new BubbleSeries(ctx),\n  tooltipDefaults: { range: \"nearest\" },\n  defaultAxes: [\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"bottom\" /* BOTTOM */\n    },\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"left\" /* LEFT */\n    }\n  ],\n  themeTemplate: {\n    series: {\n      shape: \"circle\",\n      size: 7,\n      maxSize: 30,\n      fillOpacity: 0.8,\n      tooltip: { position: { type: \"node\" } },\n      label: {\n        enabled: false,\n        fontSize: 12,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_LABEL_COLOUR\n      }\n    }\n  },\n  paletteFactory: singleSeriesPaletteFactory\n};\n\n// packages/ag-charts-community/src/chart/series/cartesian/histogramSeriesProperties.ts\nvar HistogramSeriesProperties = class extends CartesianSeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.fillOpacity = 1;\n    this.strokeWidth = 1;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.cornerRadius = 0;\n    this.areaPlot = false;\n    this.aggregation = \"sum\";\n    this.shadow = new DropShadow();\n    this.label = new Label();\n    this.tooltip = new SeriesTooltip();\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], HistogramSeriesProperties.prototype, \"xKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], HistogramSeriesProperties.prototype, \"yKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], HistogramSeriesProperties.prototype, \"xName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], HistogramSeriesProperties.prototype, \"yName\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], HistogramSeriesProperties.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO)\n], HistogramSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], HistogramSeriesProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], HistogramSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO)\n], HistogramSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH)\n], HistogramSeriesProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], HistogramSeriesProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], HistogramSeriesProperties.prototype, \"cornerRadius\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], HistogramSeriesProperties.prototype, \"areaPlot\", 2);\n__decorateClass([\n  Validate(ARRAY, { optional: true })\n], HistogramSeriesProperties.prototype, \"bins\", 2);\n__decorateClass([\n  Validate(UNION([\"count\", \"sum\", \"mean\"], \"a histogram aggregation\"))\n], HistogramSeriesProperties.prototype, \"aggregation\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], HistogramSeriesProperties.prototype, \"binCount\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], HistogramSeriesProperties.prototype, \"shadow\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], HistogramSeriesProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], HistogramSeriesProperties.prototype, \"tooltip\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/histogramSeries.ts\nvar defaultBinCount = 10;\nvar HistogramSeries = class extends CartesianSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,\n      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,\n      pickModes: [1 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */],\n      datumSelectionGarbageCollection: false,\n      animationResetFns: {\n        datum: resetBarSelectionsFn,\n        label: resetLabelFn\n      }\n    });\n    this.properties = new HistogramSeriesProperties();\n    this.calculatedBins = [];\n  }\n  // During processData phase, used to unify different ways of the user specifying\n  // the bins. Returns bins in format[[min1, max1], [min2, max2], ... ].\n  deriveBins(xDomain) {\n    const binStarts = createTicks(xDomain[0], xDomain[1], defaultBinCount);\n    const binSize = tickStep(xDomain[0], xDomain[1], defaultBinCount);\n    const [firstBinEnd] = binStarts;\n    const expandStartToBin = (n) => [n, n + binSize];\n    return [[firstBinEnd - binSize, firstBinEnd], ...binStarts.map(expandStartToBin)];\n  }\n  calculateNiceBins(domain, binCount) {\n    const startGuess = Math.floor(domain[0]);\n    const stop = domain[1];\n    const segments = binCount || 1;\n    const { start: start2, binSize } = this.calculateNiceStart(startGuess, stop, segments);\n    return this.getBins(start2, stop, binSize, segments);\n  }\n  getBins(start2, stop, step, count) {\n    const bins = [];\n    const precision = this.calculatePrecision(step);\n    for (let i = 0; i < count; i++) {\n      const a = Math.round((start2 + i * step) * precision) / precision;\n      let b = Math.round((start2 + (i + 1) * step) * precision) / precision;\n      if (i === count - 1) {\n        b = Math.max(b, stop);\n      }\n      bins[i] = [a, b];\n    }\n    return bins;\n  }\n  calculatePrecision(step) {\n    let precision = 10;\n    if (isFinite(step) && step > 0) {\n      while (step < 1) {\n        precision *= 10;\n        step *= 10;\n      }\n    }\n    return precision;\n  }\n  calculateNiceStart(a, b, segments) {\n    const binSize = Math.abs(b - a) / segments;\n    const order = Math.floor(Math.log10(binSize));\n    const magnitude = Math.pow(10, order);\n    const start2 = Math.floor(a / magnitude) * magnitude;\n    return {\n      start: start2,\n      binSize\n    };\n  }\n  async processData(dataController) {\n    if (!this.visible) {\n      this.processedData = void 0;\n      this.animationState.transition(\"updateData\");\n    }\n    const { xKey, yKey, areaPlot, aggregation } = this.properties;\n    const xScale = this.axes[\"x\" /* X */]?.scale;\n    const yScale = this.axes[\"y\" /* Y */]?.scale;\n    const { xScaleType, yScaleType } = this.getScaleInformation({ yScale, xScale });\n    const props = [keyProperty(xKey, xScaleType), SORT_DOMAIN_GROUPS];\n    if (yKey) {\n      let aggProp = groupCount(\"groupAgg\");\n      if (aggregation === \"count\") {\n      } else if (aggregation === \"sum\") {\n        aggProp = groupSum(\"groupAgg\");\n      } else if (aggregation === \"mean\") {\n        aggProp = groupAverage(\"groupAgg\");\n      }\n      if (areaPlot) {\n        aggProp = area(\"groupAgg\", aggProp);\n      }\n      props.push(valueProperty(yKey, yScaleType, { invalidValue: void 0 }), aggProp);\n    } else {\n      let aggProp = groupCount(\"groupAgg\");\n      if (areaPlot) {\n        aggProp = area(\"groupAgg\", aggProp);\n      }\n      props.push(aggProp);\n    }\n    const groupByFn = (dataSet) => {\n      const xExtent = fixNumericExtent(dataSet.domain.keys[0]);\n      if (xExtent.length === 0) {\n        dataSet.domain.groups = [];\n        return () => [];\n      }\n      const bins = isNumber(this.properties.binCount) ? this.calculateNiceBins(xExtent, this.properties.binCount) : this.properties.bins ?? this.deriveBins(xExtent);\n      const binCount = bins.length;\n      this.calculatedBins = [...bins];\n      return (item) => {\n        const xValue = item.keys[0];\n        for (let i = 0; i < binCount; i++) {\n          const nextBin = bins[i];\n          if (xValue >= nextBin[0] && xValue < nextBin[1]) {\n            return nextBin;\n          }\n          if (i === binCount - 1 && xValue <= nextBin[1]) {\n            return nextBin;\n          }\n        }\n        return [];\n      };\n    };\n    if (!this.ctx.animationManager.isSkipped() && this.processedData) {\n      props.push(diff(this.processedData, false));\n    }\n    await this.requestDataModel(dataController, this.data, { props, groupByFn });\n    this.animationState.transition(\"updateData\");\n  }\n  getSeriesDomain(direction) {\n    const { processedData, dataModel } = this;\n    if (!processedData || !dataModel || !this.calculatedBins.length)\n      return [];\n    const yDomain = dataModel.getDomain(this, `groupAgg`, \"aggregate\", processedData);\n    const xDomainMin = this.calculatedBins?.[0][0];\n    const xDomainMax = this.calculatedBins?.[(this.calculatedBins?.length ?? 0) - 1][1];\n    if (direction === \"x\" /* X */) {\n      return fixNumericExtent([xDomainMin, xDomainMax]);\n    }\n    return fixNumericExtent(yDomain);\n  }\n  async createNodeData() {\n    const {\n      id: seriesId,\n      axes,\n      processedData,\n      ctx: { callbackCache }\n    } = this;\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    if (!xAxis || !yAxis) {\n      return;\n    }\n    const { scale: xScale } = xAxis;\n    const { scale: yScale } = yAxis;\n    const { xKey, yKey, xName, yName, fill, stroke, strokeWidth, cornerRadius } = this.properties;\n    const labelFormatter = this.properties.label.formatter ?? ((params) => String(params.value));\n    const nodeData = [];\n    const context = {\n      itemId: this.properties.yKey ?? this.id,\n      nodeData,\n      labelData: nodeData,\n      scales: this.calculateScaling(),\n      animationValid: true,\n      visible: this.visible\n    };\n    if (!this.visible || !processedData || processedData.type !== \"grouped\")\n      return context;\n    processedData.data.forEach((group) => {\n      const {\n        aggValues: [[negativeAgg, positiveAgg]] = [[0, 0]],\n        datum,\n        datum: { length: frequency },\n        keys: domain,\n        keys: [xDomainMin, xDomainMax]\n      } = group;\n      const xMinPx = xScale.convert(xDomainMin);\n      const xMaxPx = xScale.convert(xDomainMax);\n      const total = negativeAgg + positiveAgg;\n      const yZeroPx = yScale.convert(0);\n      const yMaxPx = yScale.convert(total);\n      const w = Math.abs(xMaxPx - xMinPx);\n      const h = Math.abs(yMaxPx - yZeroPx);\n      const x = Math.min(xMinPx, xMaxPx);\n      const y = Math.min(yZeroPx, yMaxPx);\n      let selectionDatumLabel = void 0;\n      if (total !== 0) {\n        selectionDatumLabel = {\n          x: x + w / 2,\n          y: y + h / 2,\n          text: callbackCache.call(labelFormatter, {\n            value: total,\n            datum,\n            seriesId,\n            xKey,\n            yKey,\n            xName,\n            yName\n          }) ?? String(total)\n        };\n      }\n      const nodeMidPoint = {\n        x: x + w / 2,\n        y: y + h / 2\n      };\n      const yAxisReversed = yAxis.isReversed();\n      nodeData.push({\n        series: this,\n        datum,\n        // required by SeriesNodeDatum, but might not make sense here\n        // since each selection is an aggregation of multiple data.\n        aggregatedValue: total,\n        frequency,\n        domain,\n        yKey,\n        xKey,\n        x,\n        y,\n        xValue: xMinPx,\n        yValue: yMaxPx,\n        width: w,\n        height: h,\n        midPoint: nodeMidPoint,\n        fill,\n        stroke,\n        cornerRadius,\n        topLeftCornerRadius: !yAxisReversed,\n        topRightCornerRadius: !yAxisReversed,\n        bottomRightCornerRadius: yAxisReversed,\n        bottomLeftCornerRadius: yAxisReversed,\n        opacity: 1,\n        strokeWidth,\n        label: selectionDatumLabel\n      });\n    });\n    nodeData.sort((a, b) => a.x - b.x);\n    return context;\n  }\n  nodeFactory() {\n    return new Rect();\n  }\n  async updateDatumSelection(opts) {\n    const { nodeData, datumSelection } = opts;\n    return datumSelection.update(\n      nodeData,\n      (rect) => {\n        rect.crisp = true;\n      },\n      (datum) => datum.domain.join(\"_\")\n    );\n  }\n  async updateDatumNodes(opts) {\n    const { isHighlight: isDatumHighlighted } = opts;\n    const {\n      fillOpacity: seriesFillOpacity,\n      strokeOpacity,\n      lineDash,\n      lineDashOffset,\n      shadow,\n      highlightStyle: {\n        item: {\n          fill: highlightedFill,\n          fillOpacity: highlightFillOpacity = seriesFillOpacity,\n          stroke: highlightedStroke,\n          strokeWidth: highlightedDatumStrokeWidth\n        }\n      }\n    } = this.properties;\n    opts.datumSelection.each((rect, datum, index) => {\n      const {\n        cornerRadius,\n        topLeftCornerRadius,\n        topRightCornerRadius,\n        bottomRightCornerRadius,\n        bottomLeftCornerRadius\n      } = datum;\n      const strokeWidth = isDatumHighlighted && highlightedDatumStrokeWidth !== void 0 ? highlightedDatumStrokeWidth : datum.strokeWidth;\n      const fillOpacity = isDatumHighlighted ? highlightFillOpacity : seriesFillOpacity;\n      rect.fill = (isDatumHighlighted ? highlightedFill : void 0) ?? datum.fill;\n      rect.stroke = (isDatumHighlighted ? highlightedStroke : void 0) ?? datum.stroke;\n      rect.fillOpacity = fillOpacity;\n      rect.strokeOpacity = strokeOpacity;\n      rect.strokeWidth = strokeWidth;\n      rect.lineDash = lineDash;\n      rect.lineDashOffset = lineDashOffset;\n      rect.topLeftCornerRadius = topLeftCornerRadius ? cornerRadius : 0;\n      rect.topRightCornerRadius = topRightCornerRadius ? cornerRadius : 0;\n      rect.bottomRightCornerRadius = bottomRightCornerRadius ? cornerRadius : 0;\n      rect.bottomLeftCornerRadius = bottomLeftCornerRadius ? cornerRadius : 0;\n      rect.fillShadow = shadow;\n      rect.zIndex = isDatumHighlighted ? Series.highlightedZIndex : index;\n      rect.visible = datum.height > 0;\n    });\n  }\n  async updateLabelSelection(opts) {\n    const { labelData, labelSelection } = opts;\n    return labelSelection.update(labelData, (text) => {\n      text.pointerEvents = 1 /* None */;\n      text.textAlign = \"center\";\n      text.textBaseline = \"middle\";\n    });\n  }\n  async updateLabelNodes(opts) {\n    const { fontStyle, fontWeight, fontFamily, fontSize, color } = this.properties.label;\n    const labelEnabled = this.isLabelEnabled();\n    opts.labelSelection.each((text, datum) => {\n      if (labelEnabled && datum?.label) {\n        text.text = datum.label.text;\n        text.x = datum.label.x;\n        text.y = datum.label.y;\n        text.fontStyle = fontStyle;\n        text.fontWeight = fontWeight;\n        text.fontFamily = fontFamily;\n        text.fontSize = fontSize;\n        text.fill = color;\n        text.visible = true;\n      } else {\n        text.visible = false;\n      }\n    });\n  }\n  initQuadTree(quadtree) {\n    const { value: childNode } = this.contentGroup.children().next();\n    if (childNode) {\n      addHitTestersToQuadtree(quadtree, childNode.children());\n    }\n  }\n  pickNodeClosestDatum(point) {\n    return findQuadtreeMatch(this, point);\n  }\n  getTooltipHtml(nodeDatum) {\n    const xAxis = this.axes[\"x\" /* X */];\n    const yAxis = this.axes[\"y\" /* Y */];\n    if (!this.properties.isValid() || !xAxis || !yAxis) {\n      return EMPTY_TOOLTIP_CONTENT;\n    }\n    const { xKey, yKey, xName, yName, fill: color, aggregation, tooltip } = this.properties;\n    const {\n      aggregatedValue,\n      frequency,\n      domain: [rangeMin, rangeMax],\n      itemId\n    } = nodeDatum;\n    const title = `${sanitizeHtml(xName ?? xKey)}: ${xAxis.formatDatum(rangeMin)} - ${xAxis.formatDatum(rangeMax)}`;\n    let content = yKey ? `<b>${sanitizeHtml(yName ?? yKey)} (${aggregation})</b>: ${yAxis.formatDatum(aggregatedValue)}<br>` : \"\";\n    content += `<b>Frequency</b>: ${frequency}`;\n    const defaults = {\n      title,\n      backgroundColor: color,\n      content\n    };\n    return tooltip.toTooltipHtml(defaults, {\n      datum: {\n        data: nodeDatum.datum,\n        aggregatedValue: nodeDatum.aggregatedValue,\n        domain: nodeDatum.domain,\n        frequency: nodeDatum.frequency\n      },\n      itemId,\n      xKey,\n      xName,\n      yKey,\n      yName,\n      color,\n      title,\n      seriesId: this.id\n    });\n  }\n  getLegendData(legendType) {\n    if (!this.data?.length || legendType !== \"category\") {\n      return [];\n    }\n    const { xKey, yName, fill, fillOpacity, stroke, strokeWidth, strokeOpacity, visible } = this.properties;\n    return [\n      {\n        legendType: \"category\",\n        id: this.id,\n        itemId: xKey,\n        seriesId: this.id,\n        enabled: visible,\n        label: {\n          text: yName ?? xKey ?? \"Frequency\"\n        },\n        symbols: [\n          {\n            marker: {\n              fill: fill ?? \"rgba(0, 0, 0, 0)\",\n              stroke: stroke ?? \"rgba(0, 0, 0, 0)\",\n              fillOpacity,\n              strokeOpacity,\n              strokeWidth\n            }\n          }\n        ]\n      }\n    ];\n  }\n  animateEmptyUpdateReady({ datumSelection, labelSelection }) {\n    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(true, this.axes, \"normal\"));\n    fromToMotion(this.id, \"datums\", this.ctx.animationManager, [datumSelection], fns);\n    seriesLabelFadeInAnimation(this, \"labels\", this.ctx.animationManager, labelSelection);\n  }\n  animateWaitingUpdateReady(data) {\n    const dataDiff = this.processedData?.reduced?.diff;\n    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(true, this.axes, \"normal\"));\n    fromToMotion(\n      this.id,\n      \"datums\",\n      this.ctx.animationManager,\n      [data.datumSelection],\n      fns,\n      (_, datum) => createDatumId(datum.domain),\n      dataDiff\n    );\n    seriesLabelFadeInAnimation(this, \"labels\", this.ctx.animationManager, data.labelSelection);\n  }\n  isLabelEnabled() {\n    return this.properties.label.enabled;\n  }\n  computeFocusBounds({ datumIndex, seriesRect }) {\n    return computeBarFocusBounds(this.contextNodeData?.nodeData[datumIndex], this.contentGroup, seriesRect);\n  }\n};\nHistogramSeries.className = \"HistogramSeries\";\nHistogramSeries.type = \"histogram\";\n\n// packages/ag-charts-community/src/chart/series/cartesian/histogramSeriesModule.ts\nvar HistogramSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  identifier: \"histogram\",\n  moduleFactory: (ctx) => new HistogramSeries(ctx),\n  tooltipDefaults: { range: \"exact\" },\n  defaultAxes: [\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"bottom\" /* BOTTOM */\n    },\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"left\" /* LEFT */\n    }\n  ],\n  themeTemplate: {\n    series: {\n      strokeWidth: 1,\n      fillOpacity: 1,\n      strokeOpacity: 1,\n      lineDash: [0],\n      lineDashOffset: 0,\n      label: {\n        enabled: false,\n        fontSize: 12,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR\n      },\n      shadow: {\n        enabled: false,\n        color: DEFAULT_SHADOW_COLOUR,\n        xOffset: 3,\n        yOffset: 3,\n        blur: 5\n      }\n    }\n  },\n  paletteFactory: ({ takeColors }) => {\n    const {\n      fills: [fill],\n      strokes: [stroke]\n    } = takeColors(1);\n    return { fill, stroke };\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/cartesian/lineSeriesProperties.ts\nvar LineSeriesProperties = class extends CartesianSeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.stroke = \"#874349\";\n    this.strokeWidth = 2;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.interpolation = new InterpolationProperties();\n    this.marker = new SeriesMarker();\n    this.label = new Label();\n    this.tooltip = new SeriesTooltip();\n    this.connectMissingData = false;\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], LineSeriesProperties.prototype, \"xKey\", 2);\n__decorateClass([\n  Validate(STRING)\n], LineSeriesProperties.prototype, \"yKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], LineSeriesProperties.prototype, \"xName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], LineSeriesProperties.prototype, \"yName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], LineSeriesProperties.prototype, \"yFilterKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], LineSeriesProperties.prototype, \"stackGroup\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], LineSeriesProperties.prototype, \"normalizedTo\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], LineSeriesProperties.prototype, \"title\", 2);\n__decorateClass([\n  Validate(COLOR_STRING)\n], LineSeriesProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], LineSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO)\n], LineSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH)\n], LineSeriesProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], LineSeriesProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], LineSeriesProperties.prototype, \"interpolation\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], LineSeriesProperties.prototype, \"marker\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], LineSeriesProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], LineSeriesProperties.prototype, \"tooltip\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], LineSeriesProperties.prototype, \"connectMissingData\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/lineSeries.ts\nvar CROSS_FILTER_LINE_STROKE_OPACITY_FACTOR = 0.25;\nvar LineSeries = class extends CartesianSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,\n      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,\n      hasMarkers: true,\n      pickModes: [\n        2 /* AXIS_ALIGNED */,\n        1 /* NEAREST_NODE */,\n        0 /* EXACT_SHAPE_MATCH */\n      ],\n      markerSelectionGarbageCollection: false,\n      animationResetFns: {\n        path: buildResetPathFn({ getVisible: () => this.visible, getOpacity: () => this.getOpacity() }),\n        label: resetLabelFn,\n        marker: (node, datum) => ({ ...resetMarkerFn(node), ...resetMarkerPositionFn(node, datum) })\n      }\n    });\n    this.properties = new LineSeriesProperties();\n  }\n  get pickModeAxis() {\n    return \"main-category\";\n  }\n  async processData(dataController) {\n    if (this.data == null || !this.properties.isValid()) {\n      return;\n    }\n    const { data, visible, seriesGrouping: { groupIndex = this.id, stackCount = 1 } = {} } = this;\n    const { xKey, yKey, yFilterKey, connectMissingData, normalizedTo } = this.properties;\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    const xScale = this.axes[\"x\" /* X */]?.scale;\n    const yScale = this.axes[\"y\" /* Y */]?.scale;\n    const { isContinuousX, xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });\n    const common = { invalidValue: null };\n    if (connectMissingData && stackCount > 1) {\n      common.invalidValue = 0;\n    }\n    if (!visible) {\n      common.forceValue = 0;\n    }\n    const props = [];\n    if (!isContinuousX) {\n      props.push(keyProperty(xKey, xScaleType, { id: \"xKey\" }));\n    }\n    props.push(\n      valueProperty(xKey, xScaleType, { id: \"xValue\" }),\n      valueProperty(yKey, yScaleType, {\n        id: `yValueRaw`,\n        ...common,\n        invalidValue: void 0\n      })\n    );\n    if (yFilterKey != null) {\n      props.push(valueProperty(yFilterKey, yScaleType, { id: \"yFilterRaw\" }));\n    }\n    if (stackCount > 1) {\n      const ids = [\n        `line-stack-${groupIndex}-yValues`,\n        `line-stack-${groupIndex}-yValues-trailing`,\n        `line-stack-${groupIndex}-yValues-marker`\n      ];\n      props.push(\n        ...groupAccumulativeValueProperty(\n          yKey,\n          \"window\",\n          \"current\",\n          { id: `yValueEnd`, ...common, groupId: ids[0] },\n          yScaleType\n        ),\n        ...groupAccumulativeValueProperty(\n          yKey,\n          \"window-trailing\",\n          \"current\",\n          { id: `yValueStart`, ...common, groupId: ids[1] },\n          yScaleType\n        ),\n        ...groupAccumulativeValueProperty(\n          yKey,\n          \"normal\",\n          \"current\",\n          { id: `yValueCumulative`, ...common, groupId: ids[2] },\n          yScaleType\n        )\n      );\n      if (isDefined(normalizedTo)) {\n        props.push(normaliseGroupTo([ids[0], ids[1], ids[2]], normalizedTo, \"range\"));\n      }\n    }\n    if (animationEnabled) {\n      props.push(animationValidation(isContinuousX ? [\"xValue\"] : void 0));\n      if (this.processedData) {\n        props.push(diff(this.processedData));\n      }\n    }\n    await this.requestDataModel(dataController, data, { props });\n    this.animationState.transition(\"updateData\");\n  }\n  getSeriesDomain(direction) {\n    const { dataModel, processedData } = this;\n    if (!dataModel || !processedData?.data.length)\n      return [];\n    const xDef = dataModel.resolveProcessedDataDefById(this, `xValue`);\n    if (direction === \"x\" /* X */) {\n      const domain = dataModel.getDomain(this, `xValue`, \"value\", processedData);\n      if (xDef?.def.type === \"value\" && xDef.def.valueType === \"category\") {\n        return domain;\n      }\n      return fixNumericExtent(extent(domain));\n    } else {\n      const stackCount = this.seriesGrouping?.stackCount ?? 1;\n      const domain = stackCount > 1 ? dataModel.getDomain(this, `yValueEnd`, \"value\", processedData) : dataModel.getDomain(this, `yValueRaw`, \"value\", processedData);\n      return fixNumericExtent(domain);\n    }\n  }\n  async createNodeData() {\n    const { processedData, dataModel, axes } = this;\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    if (!processedData || !dataModel || !xAxis || !yAxis) {\n      return;\n    }\n    const { xKey, yKey, yFilterKey, xName, yName, marker, label, connectMissingData, legendItemName } = this.properties;\n    const stacked = (this.seriesGrouping?.stackCount ?? 1) > 1;\n    const xScale = xAxis.scale;\n    const yScale = yAxis.scale;\n    const xOffset = (xScale.bandwidth ?? 0) / 2;\n    const yOffset = (yScale.bandwidth ?? 0) / 2;\n    const nodeData = [];\n    const size = marker.enabled ? marker.size : 0;\n    const xIdx = dataModel.resolveProcessedDataIndexById(this, `xValue`);\n    const yIdx = dataModel.resolveProcessedDataIndexById(this, `yValueRaw`);\n    const ySelectionIdx = yFilterKey != null ? dataModel.resolveProcessedDataIndexById(this, `yFilterRaw`) : void 0;\n    const yCumulativeIdx = stacked ? dataModel.resolveProcessedDataIndexById(this, `yValueCumulative`) : yIdx;\n    const yEndIdx = stacked ? dataModel.resolveProcessedDataIndexById(this, `yValueEnd`) : void 0;\n    let moveTo = true;\n    let crossFiltering = false;\n    processedData.data?.forEach(({ datum, values }) => {\n      const xDatum = values[xIdx];\n      const yDatum = values[yIdx];\n      const yCumulativeDatum = values[yCumulativeIdx];\n      const yEndDatum = yEndIdx != null ? values[yEndIdx] : void 0;\n      if (yDatum == null) {\n        moveTo || (moveTo = !connectMissingData);\n        return;\n      }\n      const x = xScale.convert(xDatum) + xOffset;\n      if (isNaN(x)) {\n        moveTo || (moveTo = !connectMissingData);\n        return;\n      }\n      const y = yScale.convert(yCumulativeDatum) + yOffset;\n      const selected = ySelectionIdx != null ? values[ySelectionIdx] === yDatum : void 0;\n      if (selected === false) {\n        crossFiltering = true;\n      }\n      const labelText = this.getLabelText(\n        label,\n        { value: yDatum, datum, xKey, yKey, xName, yName, legendItemName },\n        formatValue\n      );\n      nodeData.push({\n        series: this,\n        datum,\n        yKey,\n        xKey,\n        point: { x, y, moveTo, size },\n        midPoint: { x, y },\n        cumulativeValue: yEndDatum,\n        yValue: yDatum,\n        xValue: xDatum,\n        capDefaults: {\n          lengthRatioMultiplier: this.properties.marker.getDiameter(),\n          lengthMax: Infinity\n        },\n        labelText,\n        selected\n      });\n      moveTo = false;\n    });\n    return {\n      itemId: yKey,\n      nodeData,\n      labelData: nodeData,\n      scales: this.calculateScaling(),\n      visible: this.visible,\n      crossFiltering\n    };\n  }\n  isPathOrSelectionDirty() {\n    return this.properties.marker.isDirty();\n  }\n  markerFactory() {\n    const { shape } = this.properties.marker;\n    const MarkerShape = getMarker(shape);\n    return new MarkerShape();\n  }\n  async updatePathNodes(opts) {\n    const {\n      paths: [lineNode],\n      opacity,\n      visible,\n      animationEnabled\n    } = opts;\n    const crossFiltering = this.contextNodeData?.crossFiltering === true;\n    lineNode.setProperties({\n      fill: void 0,\n      lineJoin: \"round\",\n      pointerEvents: 1 /* None */,\n      opacity,\n      stroke: this.properties.stroke,\n      strokeWidth: this.getStrokeWidth(this.properties.strokeWidth),\n      strokeOpacity: this.properties.strokeOpacity * (crossFiltering ? CROSS_FILTER_LINE_STROKE_OPACITY_FACTOR : 1),\n      lineDash: this.properties.lineDash,\n      lineDashOffset: this.properties.lineDashOffset\n    });\n    if (!animationEnabled) {\n      lineNode.visible = visible;\n    }\n    updateClipPath(this, lineNode);\n  }\n  async updateMarkerSelection(opts) {\n    let { nodeData } = opts;\n    const { markerSelection } = opts;\n    const markersEnabled = this.properties.marker.enabled || this.contextNodeData?.crossFiltering === true;\n    nodeData = markersEnabled ? nodeData : [];\n    if (this.properties.marker.isDirty()) {\n      markerSelection.clear();\n      markerSelection.cleanup();\n    }\n    return markerSelection.update(nodeData, void 0, (datum) => createDatumId(datum.xValue));\n  }\n  async updateMarkerNodes(opts) {\n    const { markerSelection, isHighlight: highlighted } = opts;\n    const { xKey, yKey, stroke, strokeWidth, strokeOpacity, marker, highlightStyle } = this.properties;\n    const baseStyle = mergeDefaults(highlighted && highlightStyle.item, marker.getStyle(), {\n      stroke,\n      strokeWidth,\n      strokeOpacity\n    });\n    const applyTranslation = this.ctx.animationManager.isSkipped();\n    markerSelection.each((node, datum) => {\n      this.updateMarkerStyle(node, marker, { datum, highlighted, xKey, yKey }, baseStyle, {\n        applyTranslation,\n        selected: datum.selected\n      });\n    });\n    if (!highlighted) {\n      marker.markClean();\n    }\n  }\n  async updateLabelSelection(opts) {\n    return opts.labelSelection.update(this.isLabelEnabled() ? opts.labelData : []);\n  }\n  async updateLabelNodes(opts) {\n    const { enabled, fontStyle, fontWeight, fontSize, fontFamily, color } = this.properties.label;\n    opts.labelSelection.each((text, datum) => {\n      if (enabled && datum?.labelText) {\n        text.fontStyle = fontStyle;\n        text.fontWeight = fontWeight;\n        text.fontSize = fontSize;\n        text.fontFamily = fontFamily;\n        text.textAlign = \"center\";\n        text.textBaseline = \"bottom\";\n        text.text = datum.labelText;\n        text.x = datum.point.x;\n        text.y = datum.point.y - 10;\n        text.fill = color;\n        text.visible = true;\n      } else {\n        text.visible = false;\n      }\n    });\n  }\n  getTooltipHtml(nodeDatum) {\n    const xAxis = this.axes[\"x\" /* X */];\n    const yAxis = this.axes[\"y\" /* Y */];\n    if (!this.properties.isValid() || !xAxis || !yAxis) {\n      return EMPTY_TOOLTIP_CONTENT;\n    }\n    const { xKey, yKey, xName, yName, strokeWidth, marker, tooltip } = this.properties;\n    const { datum, xValue, yValue, itemId } = nodeDatum;\n    const xString = xAxis.formatDatum(xValue);\n    const yString = yAxis.formatDatum(yValue);\n    const title = sanitizeHtml(this.properties.title ?? yName);\n    const content = sanitizeHtml(xString + \": \" + yString);\n    const baseStyle = mergeDefaults({ fill: marker.stroke }, marker.getStyle(), { strokeWidth });\n    const { fill: color } = this.getMarkerStyle(\n      marker,\n      { datum: nodeDatum, xKey, yKey, highlighted: false },\n      baseStyle\n    );\n    return tooltip.toTooltipHtml(\n      { title, content, backgroundColor: color },\n      {\n        datum,\n        itemId,\n        xKey,\n        xName,\n        yKey,\n        yName,\n        title,\n        color,\n        seriesId: this.id,\n        ...this.getModuleTooltipParams()\n      }\n    );\n  }\n  getLegendData(legendType) {\n    if (!(this.data?.length && this.properties.isValid() && legendType === \"category\")) {\n      return [];\n    }\n    const { yKey, yName, stroke, strokeOpacity, strokeWidth, lineDash, title, marker, visible, legendItemName } = this.properties;\n    const color0 = \"rgba(0, 0, 0, 0)\";\n    return [\n      {\n        legendType: \"category\",\n        id: this.id,\n        itemId: yKey,\n        legendItemName,\n        seriesId: this.id,\n        enabled: visible,\n        label: {\n          text: legendItemName ?? title ?? yName ?? yKey\n        },\n        symbols: [\n          {\n            marker: {\n              shape: marker.shape,\n              fill: marker.fill ?? color0,\n              stroke: marker.stroke ?? stroke ?? color0,\n              fillOpacity: marker.fillOpacity ?? 1,\n              strokeOpacity: marker.strokeOpacity ?? strokeOpacity ?? 1,\n              strokeWidth: marker.strokeWidth ?? 0,\n              enabled: marker.enabled\n            },\n            line: {\n              stroke: stroke ?? color0,\n              strokeOpacity,\n              strokeWidth,\n              lineDash\n            }\n          }\n        ]\n      }\n    ];\n  }\n  async updatePaths(opts) {\n    this.updateLinePaths(opts.paths, opts.contextData);\n  }\n  updateLinePaths(paths, contextData) {\n    const { interpolation } = this.properties;\n    const { nodeData } = contextData;\n    const [lineNode] = paths;\n    lineNode.path.clear(true);\n    for (const range3 of pathRanges(nodeData)) {\n      plotPath(pathRangePoints(nodeData, range3), lineNode, interpolation);\n    }\n    lineNode.checkPathDirty();\n  }\n  animateEmptyUpdateReady(animationData) {\n    const { markerSelection, labelSelection, annotationSelections, contextData, paths } = animationData;\n    const { animationManager } = this.ctx;\n    this.updateLinePaths(paths, contextData);\n    pathSwipeInAnimation(this, animationManager, ...paths);\n    resetMotion([markerSelection], resetMarkerPositionFn);\n    markerSwipeScaleInAnimation(this, animationManager, markerSelection);\n    seriesLabelFadeInAnimation(this, \"labels\", animationManager, labelSelection);\n    seriesLabelFadeInAnimation(this, \"annotations\", animationManager, ...annotationSelections);\n  }\n  animateReadyResize(animationData) {\n    const { contextData, paths } = animationData;\n    this.updateLinePaths(paths, contextData);\n    super.animateReadyResize(animationData);\n  }\n  animateWaitingUpdateReady(animationData) {\n    const { animationManager } = this.ctx;\n    const {\n      markerSelection: markerSelections,\n      labelSelection: labelSelections,\n      annotationSelections,\n      contextData,\n      paths,\n      previousContextData\n    } = animationData;\n    const [path] = paths;\n    this.resetMarkerAnimation(animationData);\n    this.resetLabelAnimation(animationData);\n    const update = () => {\n      this.resetPathAnimation(animationData);\n      this.updateLinePaths(paths, contextData);\n    };\n    const skip = () => {\n      animationManager.skipCurrentBatch();\n      update();\n    };\n    if (contextData == null || previousContextData == null) {\n      update();\n      markerFadeInAnimation(this, animationManager, \"added\", markerSelections);\n      pathFadeInAnimation(this, \"path_properties\", animationManager, \"add\", path);\n      seriesLabelFadeInAnimation(this, \"labels\", animationManager, labelSelections);\n      seriesLabelFadeInAnimation(this, \"annotations\", animationManager, ...annotationSelections);\n      return;\n    }\n    if (contextData.crossFiltering !== previousContextData.crossFiltering) {\n      skip();\n      return;\n    }\n    let fns;\n    try {\n      fns = prepareLinePathAnimation(\n        contextData,\n        previousContextData,\n        this.processedData?.reduced?.diff,\n        this.properties.interpolation\n      );\n    } catch {\n      fns = void 0;\n    }\n    if (fns === void 0) {\n      skip();\n      return;\n    } else if (fns.status === \"no-op\") {\n      return;\n    }\n    markerFadeInAnimation(this, animationManager, void 0, markerSelections);\n    fromToMotion(this.id, \"path_properties\", animationManager, [path], fns.pathProperties);\n    if (fns.status === \"added\") {\n      this.updateLinePaths(paths, contextData);\n    } else if (fns.status === \"removed\") {\n      this.updateLinePaths(paths, previousContextData);\n    } else {\n      pathMotion(this.id, \"path_update\", animationManager, [path], fns.path);\n    }\n    if (fns.hasMotion) {\n      seriesLabelFadeInAnimation(this, \"labels\", animationManager, labelSelections);\n      seriesLabelFadeInAnimation(this, \"annotations\", animationManager, ...annotationSelections);\n    }\n  }\n  isLabelEnabled() {\n    return this.properties.label.enabled;\n  }\n  getBandScalePadding() {\n    return { inner: 1, outer: 0.1 };\n  }\n  nodeFactory() {\n    return new Group();\n  }\n  getFormattedMarkerStyle(datum) {\n    const { xKey, yKey } = this.properties;\n    return this.getMarkerStyle(this.properties.marker, { datum, xKey, yKey, highlighted: true });\n  }\n  computeFocusBounds(opts) {\n    return computeMarkerFocusBounds(this, opts);\n  }\n};\nLineSeries.className = \"LineSeries\";\nLineSeries.type = \"line\";\n\n// packages/ag-charts-community/src/chart/series/cartesian/lineSeriesModule.ts\nvar LineSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  identifier: \"line\",\n  moduleFactory: (ctx) => new LineSeries(ctx),\n  stackable: true,\n  tooltipDefaults: { range: \"nearest\" },\n  defaultAxes: [\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"left\" /* LEFT */\n    },\n    {\n      type: \"category\" /* CATEGORY */,\n      position: \"bottom\" /* BOTTOM */\n    }\n  ],\n  themeTemplate: {\n    series: {\n      tooltip: { position: { type: \"node\" } },\n      strokeWidth: 2,\n      strokeOpacity: 1,\n      lineDash: [0],\n      lineDashOffset: 0,\n      interpolation: {\n        type: \"linear\",\n        // @ts-expect-error - users shouldn't specify all options, but we have to for theming to work\n        tension: 1,\n        position: \"end\"\n      },\n      marker: {\n        shape: \"circle\",\n        size: 7,\n        strokeWidth: 0\n      },\n      label: {\n        enabled: false,\n        fontSize: 12,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_LABEL_COLOUR\n      },\n      errorBar: {\n        cap: {\n          lengthRatio: 1\n        }\n      }\n    }\n  },\n  paletteFactory: (params) => {\n    const { marker } = markerPaletteFactory(params);\n    return { stroke: marker.fill, marker };\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/cartesian/scatterSeriesProperties.ts\nvar ScatterSeriesLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.placement = \"top\";\n  }\n};\n__decorateClass([\n  Validate(LABEL_PLACEMENT)\n], ScatterSeriesLabel.prototype, \"placement\", 2);\nvar ScatterSeriesProperties = class extends CartesianSeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.colorRange = [\"#ffff00\", \"#00ff00\", \"#0000ff\"];\n    this.label = new ScatterSeriesLabel();\n    this.tooltip = new SeriesTooltip();\n    // No validation. Not a part of the options contract.\n    this.marker = new SeriesMarker();\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], ScatterSeriesProperties.prototype, \"xKey\", 2);\n__decorateClass([\n  Validate(STRING)\n], ScatterSeriesProperties.prototype, \"yKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"labelKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"colorKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"xFilterKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"yFilterKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"xName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"yName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"labelName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"colorName\", 2);\n__decorateClass([\n  Validate(NUMBER_ARRAY, { optional: true })\n], ScatterSeriesProperties.prototype, \"colorDomain\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], ScatterSeriesProperties.prototype, \"colorRange\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"title\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.shape\")\n], ScatterSeriesProperties.prototype, \"shape\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.size\")\n], ScatterSeriesProperties.prototype, \"size\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.fill\")\n], ScatterSeriesProperties.prototype, \"fill\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.fillOpacity\")\n], ScatterSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.stroke\")\n], ScatterSeriesProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.strokeWidth\")\n], ScatterSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.strokeOpacity\")\n], ScatterSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.itemStyler\", { optional: true })\n], ScatterSeriesProperties.prototype, \"itemStyler\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], ScatterSeriesProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], ScatterSeriesProperties.prototype, \"tooltip\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/scatterSeries.ts\nvar ScatterSeries = class extends CartesianSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,\n      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,\n      pickModes: [\n        2 /* AXIS_ALIGNED */,\n        1 /* NEAREST_NODE */,\n        0 /* EXACT_SHAPE_MATCH */\n      ],\n      pathsPerSeries: [],\n      hasMarkers: true,\n      markerSelectionGarbageCollection: false,\n      animationResetFns: {\n        marker: resetMarkerFn,\n        label: resetLabelFn\n      }\n    });\n    this.properties = new ScatterSeriesProperties();\n    this.colorScale = new ColorScale();\n  }\n  get pickModeAxis() {\n    return \"main-category\";\n  }\n  async processData(dataController) {\n    if (!this.properties.isValid() || this.data == null || !this.visible)\n      return;\n    const xScale = this.axes[\"x\" /* X */]?.scale;\n    const yScale = this.axes[\"y\" /* Y */]?.scale;\n    const { xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });\n    const colorScaleType = this.colorScale.type;\n    const { xKey, yKey, xFilterKey, yFilterKey, labelKey, colorKey, colorDomain, colorRange } = this.properties;\n    const { dataModel, processedData } = await this.requestDataModel(dataController, this.data, {\n      props: [\n        valueProperty(xKey, xScaleType, { id: `xValue` }),\n        valueProperty(yKey, yScaleType, { id: `yValue` }),\n        ...xFilterKey != null ? [valueProperty(xFilterKey, xScaleType, { id: \"xFilterValue\" })] : [],\n        ...yFilterKey != null ? [valueProperty(yFilterKey, yScaleType, { id: \"yFilterValue\" })] : [],\n        ...colorKey ? [valueProperty(colorKey, colorScaleType, { id: `colorValue` })] : [],\n        ...labelKey ? [valueProperty(labelKey, \"band\", { id: `labelValue` })] : []\n      ]\n    });\n    if (colorKey) {\n      const colorKeyIdx = dataModel.resolveProcessedDataIndexById(this, `colorValue`);\n      this.colorScale.domain = colorDomain ?? processedData.domain.values[colorKeyIdx] ?? [];\n      this.colorScale.range = colorRange;\n      this.colorScale.update();\n    }\n    this.animationState.transition(\"updateData\");\n  }\n  getSeriesDomain(direction) {\n    const { dataModel, processedData } = this;\n    if (!processedData || !dataModel)\n      return [];\n    const id = direction === \"x\" /* X */ ? `xValue` : `yValue`;\n    const dataDef = dataModel.resolveProcessedDataDefById(this, id);\n    const domain = dataModel.getDomain(this, id, \"value\", processedData);\n    if (dataDef?.def.type === \"value\" && dataDef?.def.valueType === \"category\") {\n      return domain;\n    }\n    return fixNumericExtent(extent(domain));\n  }\n  async createNodeData() {\n    const { axes, dataModel, processedData, colorScale } = this;\n    const {\n      xKey,\n      yKey,\n      xFilterKey,\n      yFilterKey,\n      labelKey,\n      colorKey,\n      xName,\n      yName,\n      labelName,\n      marker,\n      label,\n      visible\n    } = this.properties;\n    const { placement } = label;\n    const markerShape = getMarker(marker.shape);\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    if (!(dataModel && processedData && visible && xAxis && yAxis)) {\n      return;\n    }\n    const xDataIdx = dataModel.resolveProcessedDataIndexById(this, `xValue`);\n    const yDataIdx = dataModel.resolveProcessedDataIndexById(this, `yValue`);\n    const colorDataIdx = colorKey != null ? dataModel.resolveProcessedDataIndexById(this, `colorValue`) : -1;\n    const labelDataIdx = labelKey != null ? dataModel.resolveProcessedDataIndexById(this, `labelValue`) : -1;\n    const xFilterDataIdx = xFilterKey != null ? dataModel.resolveProcessedDataIndexById(this, `xFilterValue`) : void 0;\n    const yFilterDataIdx = yFilterKey != null ? dataModel.resolveProcessedDataIndexById(this, `yFilterValue`) : void 0;\n    const xScale = xAxis.scale;\n    const yScale = yAxis.scale;\n    const xOffset = (xScale.bandwidth ?? 0) / 2;\n    const yOffset = (yScale.bandwidth ?? 0) / 2;\n    const nodeData = [];\n    const font = label.getFont();\n    const textMeasurer = CachedTextMeasurerPool.getMeasurer({ font });\n    for (const { values, datum } of processedData.data ?? []) {\n      const xDatum = values[xDataIdx];\n      const yDatum = values[yDataIdx];\n      const x = xScale.convert(xDatum) + xOffset;\n      const y = yScale.convert(yDatum) + yOffset;\n      const selected = xFilterDataIdx != null && yFilterDataIdx != null ? values[xFilterDataIdx] === xDatum && values[yFilterDataIdx] === yDatum : void 0;\n      const labelText = this.getLabelText(label, {\n        value: labelKey ? values[labelDataIdx] : yDatum,\n        datum,\n        xKey,\n        yKey,\n        labelKey,\n        xName,\n        yName,\n        labelName\n      });\n      const size = textMeasurer.measureText(labelText);\n      const fill = colorKey ? colorScale.convert(values[colorDataIdx]) : void 0;\n      nodeData.push({\n        series: this,\n        itemId: yKey,\n        yKey,\n        xKey,\n        datum,\n        xValue: xDatum,\n        yValue: yDatum,\n        capDefaults: { lengthRatioMultiplier: marker.getDiameter(), lengthMax: Infinity },\n        point: { x, y, size: marker.size },\n        midPoint: { x, y },\n        fill,\n        label: { text: labelText, ...size },\n        marker: markerShape,\n        placement,\n        selected\n      });\n    }\n    return {\n      itemId: yKey,\n      nodeData,\n      labelData: nodeData,\n      scales: this.calculateScaling(),\n      visible: this.visible\n    };\n  }\n  isPathOrSelectionDirty() {\n    return this.properties.marker.isDirty();\n  }\n  getLabelData() {\n    return this.contextNodeData?.labelData ?? [];\n  }\n  markerFactory() {\n    const { shape } = this.properties.marker;\n    const MarkerShape = getMarker(shape);\n    return new MarkerShape();\n  }\n  async updateMarkerSelection(opts) {\n    const { nodeData, markerSelection } = opts;\n    if (this.properties.marker.isDirty()) {\n      markerSelection.clear();\n      markerSelection.cleanup();\n    }\n    return markerSelection.update(this.properties.marker.enabled ? nodeData : []);\n  }\n  async updateMarkerNodes(opts) {\n    const { markerSelection, isHighlight: highlighted } = opts;\n    const { xKey, yKey, labelKey, marker, highlightStyle } = this.properties;\n    const baseStyle = mergeDefaults(highlighted && highlightStyle.item, marker.getStyle());\n    markerSelection.each((node, datum) => {\n      this.updateMarkerStyle(node, marker, { datum, highlighted, xKey, yKey, labelKey }, baseStyle, {\n        selected: datum.selected\n      });\n    });\n    if (!highlighted) {\n      marker.markClean();\n    }\n  }\n  async updateLabelSelection(opts) {\n    const placedLabels = this.isLabelEnabled() ? this.chart?.placeLabels().get(this) ?? [] : [];\n    return opts.labelSelection.update(\n      placedLabels.map(({ datum, x, y }) => ({\n        ...datum,\n        point: { x, y, size: datum.point.size },\n        placement: \"top\"\n      })),\n      (text) => {\n        text.pointerEvents = 1 /* None */;\n      }\n    );\n  }\n  async updateLabelNodes(opts) {\n    const { label } = this.properties;\n    opts.labelSelection.each((text, datum) => {\n      text.text = datum.label.text;\n      text.fill = label.color;\n      text.x = datum.point?.x ?? 0;\n      text.y = datum.point?.y ?? 0;\n      text.fontStyle = label.fontStyle;\n      text.fontWeight = label.fontWeight;\n      text.fontSize = label.fontSize;\n      text.fontFamily = label.fontFamily;\n      text.textAlign = \"left\";\n      text.textBaseline = \"top\";\n    });\n  }\n  getTooltipHtml(nodeDatum) {\n    const xAxis = this.axes[\"x\" /* X */];\n    const yAxis = this.axes[\"y\" /* Y */];\n    if (!this.properties.isValid() || !xAxis || !yAxis) {\n      return EMPTY_TOOLTIP_CONTENT;\n    }\n    const { xKey, yKey, labelKey, xName, yName, labelName, title = yName, marker, tooltip } = this.properties;\n    const { datum, xValue, yValue, label, itemId } = nodeDatum;\n    const baseStyle = mergeDefaults(\n      { fill: nodeDatum.fill, strokeWidth: this.getStrokeWidth(marker.strokeWidth) },\n      marker.getStyle()\n    );\n    const { fill: color = \"gray\" } = this.getMarkerStyle(\n      marker,\n      { datum: nodeDatum, highlighted: false, xKey, yKey, labelKey },\n      baseStyle\n    );\n    const xString = sanitizeHtml(xAxis.formatDatum(xValue));\n    const yString = sanitizeHtml(yAxis.formatDatum(yValue));\n    let content = `<b>${sanitizeHtml(xName ?? xKey)}</b>: ${xString}<br><b>${sanitizeHtml(yName ?? yKey)}</b>: ${yString}`;\n    if (labelKey) {\n      content = `<b>${sanitizeHtml(labelName ?? labelKey)}</b>: ${sanitizeHtml(label.text)}<br>` + content;\n    }\n    return tooltip.toTooltipHtml(\n      { title, content, backgroundColor: color },\n      {\n        datum,\n        itemId,\n        xKey,\n        xName,\n        yKey,\n        yName,\n        labelKey,\n        labelName,\n        title,\n        color,\n        seriesId: this.id,\n        ...this.getModuleTooltipParams()\n      }\n    );\n  }\n  getLegendData(legendType) {\n    const { yKey, yName, title, marker, visible } = this.properties;\n    const { fill, stroke, fillOpacity, strokeOpacity, strokeWidth } = marker;\n    if (!this.data?.length || !this.properties.isValid() || legendType !== \"category\") {\n      return [];\n    }\n    return [\n      {\n        legendType: \"category\",\n        id: this.id,\n        itemId: yKey,\n        seriesId: this.id,\n        enabled: visible,\n        label: {\n          text: title ?? yName ?? yKey\n        },\n        symbols: [\n          {\n            marker: {\n              shape: marker.shape,\n              fill: marker.fill ?? fill ?? \"rgba(0, 0, 0, 0)\",\n              stroke: marker.stroke ?? stroke ?? \"rgba(0, 0, 0, 0)\",\n              fillOpacity: fillOpacity ?? 1,\n              strokeOpacity: strokeOpacity ?? 1,\n              strokeWidth: strokeWidth ?? 0\n            }\n          }\n        ]\n      }\n    ];\n  }\n  animateEmptyUpdateReady(data) {\n    const { markerSelection, labelSelection, annotationSelections } = data;\n    markerScaleInAnimation(this, this.ctx.animationManager, markerSelection);\n    seriesLabelFadeInAnimation(this, \"labels\", this.ctx.animationManager, labelSelection);\n    seriesLabelFadeInAnimation(this, \"annotations\", this.ctx.animationManager, ...annotationSelections);\n  }\n  isLabelEnabled() {\n    return this.properties.label.enabled;\n  }\n  nodeFactory() {\n    return new Group();\n  }\n  getFormattedMarkerStyle(datum) {\n    const { xKey, yKey, labelKey } = this.properties;\n    return this.getMarkerStyle(this.properties.marker, { datum, xKey, yKey, labelKey, highlighted: true });\n  }\n  computeFocusBounds(opts) {\n    return computeMarkerFocusBounds(this, opts);\n  }\n};\nScatterSeries.className = \"ScatterSeries\";\nScatterSeries.type = \"scatter\";\n\n// packages/ag-charts-community/src/chart/series/cartesian/scatterSeriesModule.ts\nvar ScatterSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  identifier: \"scatter\",\n  moduleFactory: (ctx) => new ScatterSeries(ctx),\n  tooltipDefaults: { range: \"nearest\" },\n  defaultAxes: [\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"bottom\" /* BOTTOM */\n    },\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"left\" /* LEFT */\n    }\n  ],\n  themeTemplate: {\n    series: {\n      shape: \"circle\",\n      size: 7,\n      fillOpacity: 0.8,\n      tooltip: { position: { type: \"node\" } },\n      label: {\n        enabled: false,\n        fontSize: 12,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_LABEL_COLOUR\n      },\n      errorBar: {\n        cap: {\n          lengthRatio: 1\n        }\n      }\n    }\n  },\n  paletteFactory: singleSeriesPaletteFactory\n};\n\n// packages/ag-charts-community/src/scene/sectorBox.ts\nvar SectorBox = class _SectorBox {\n  constructor(startAngle, endAngle, innerRadius, outerRadius) {\n    this.startAngle = startAngle;\n    this.endAngle = endAngle;\n    this.innerRadius = innerRadius;\n    this.outerRadius = outerRadius;\n  }\n  clone() {\n    const { startAngle, endAngle, innerRadius, outerRadius } = this;\n    return new _SectorBox(startAngle, endAngle, innerRadius, outerRadius);\n  }\n  equals(other) {\n    return this.startAngle === other.startAngle && this.endAngle === other.endAngle && this.innerRadius === other.innerRadius && this.outerRadius === other.outerRadius;\n  }\n  [interpolate](other, d) {\n    return new _SectorBox(\n      this.startAngle * (1 - d) + other.startAngle * d,\n      this.endAngle * (1 - d) + other.endAngle * d,\n      this.innerRadius * (1 - d) + other.innerRadius * d,\n      this.outerRadius * (1 - d) + other.outerRadius * d\n    );\n  }\n};\n\n// packages/ag-charts-community/src/scene/util/sector.ts\nfunction sectorBox({ startAngle, endAngle, innerRadius, outerRadius }) {\n  let x0 = Infinity;\n  let y0 = Infinity;\n  let x1 = -Infinity;\n  let y1 = -Infinity;\n  const addPoint = (x, y) => {\n    x0 = Math.min(x, x0);\n    y0 = Math.min(y, y0);\n    x1 = Math.max(x, x1);\n    y1 = Math.max(y, y1);\n  };\n  addPoint(innerRadius * Math.cos(startAngle), innerRadius * Math.sin(startAngle));\n  addPoint(innerRadius * Math.cos(endAngle), innerRadius * Math.sin(endAngle));\n  addPoint(outerRadius * Math.cos(startAngle), outerRadius * Math.sin(startAngle));\n  addPoint(outerRadius * Math.cos(endAngle), outerRadius * Math.sin(endAngle));\n  if (isBetweenAngles(0, startAngle, endAngle)) {\n    addPoint(outerRadius, 0);\n  }\n  if (isBetweenAngles(Math.PI * 0.5, startAngle, endAngle)) {\n    addPoint(0, outerRadius);\n  }\n  if (isBetweenAngles(Math.PI, startAngle, endAngle)) {\n    addPoint(-outerRadius, 0);\n  }\n  if (isBetweenAngles(Math.PI * 1.5, startAngle, endAngle)) {\n    addPoint(0, -outerRadius);\n  }\n  return new BBox(x0, y0, x1 - x0, y1 - y0);\n}\nfunction isPointInSector(x, y, sector) {\n  const radius = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));\n  const { innerRadius, outerRadius } = sector;\n  if (sector.startAngle === sector.endAngle || radius < Math.min(innerRadius, outerRadius) || radius > Math.max(innerRadius, outerRadius)) {\n    return false;\n  }\n  const startAngle = normalizeAngle180(sector.startAngle);\n  const endAngle = normalizeAngle180(sector.endAngle);\n  const angle2 = Math.atan2(y, x);\n  return startAngle < endAngle ? angle2 <= endAngle && angle2 >= startAngle : angle2 <= endAngle && angle2 >= -Math.PI || angle2 >= startAngle && angle2 <= Math.PI;\n}\nfunction lineCollidesSector(line, sector) {\n  const { startAngle, endAngle, innerRadius, outerRadius } = sector;\n  const outerStart = { x: outerRadius * Math.cos(startAngle), y: outerRadius * Math.sin(startAngle) };\n  const outerEnd = { x: outerRadius * Math.cos(endAngle), y: outerRadius * Math.sin(endAngle) };\n  const innerStart = innerRadius === 0 ? { x: 0, y: 0 } : { x: innerRadius * Math.cos(startAngle), y: innerRadius * Math.sin(startAngle) };\n  const innerEnd = innerRadius === 0 ? { x: 0, y: 0 } : { x: innerRadius * Math.cos(endAngle), y: innerRadius * Math.sin(endAngle) };\n  return segmentIntersection(\n    line.start.x,\n    line.start.y,\n    line.end.x,\n    line.end.y,\n    outerStart.x,\n    outerStart.y,\n    innerStart.x,\n    innerStart.y\n  ) || segmentIntersection(\n    line.start.x,\n    line.start.y,\n    line.end.x,\n    line.end.y,\n    outerEnd.x,\n    outerEnd.y,\n    innerEnd.x,\n    innerEnd.y\n  ) || arcIntersections(\n    0,\n    0,\n    outerRadius,\n    startAngle,\n    endAngle,\n    true,\n    line.start.x,\n    line.start.y,\n    line.end.x,\n    line.end.y\n  );\n}\nfunction boxCollidesSector(box, sector) {\n  const topLeft = { x: box.x, y: box.y };\n  const topRight = { x: box.x + box.width, y: box.y };\n  const bottomLeft = { x: box.x, y: box.y + box.height };\n  const bottomRight = { x: box.x + box.width, y: box.y + box.height };\n  return lineCollidesSector({ start: topLeft, end: topRight }, sector) || lineCollidesSector({ start: bottomLeft, end: bottomRight }, sector);\n}\nfunction radiiScalingFactor(r, sweep, a, b) {\n  if (a === 0 && b === 0)\n    return 0;\n  const fs1 = Math.asin(Math.abs(1 * a) / (r + 1 * a)) + Math.asin(Math.abs(1 * b) / (r + 1 * b)) - sweep;\n  if (fs1 < 0)\n    return 1;\n  let start2 = 0;\n  let end2 = 1;\n  for (let i = 0; i < 8; i += 1) {\n    const s = (start2 + end2) / 2;\n    const fs = Math.asin(Math.abs(s * a) / (r + s * a)) + Math.asin(Math.abs(s * b) / (r + s * b)) - sweep;\n    if (fs < 0) {\n      start2 = s;\n    } else {\n      end2 = s;\n    }\n  }\n  return start2;\n}\nvar delta3 = 1e-6;\nfunction clockwiseAngle2(angle2, relativeToStartAngle) {\n  if (angleBetween(angle2, relativeToStartAngle) < delta3) {\n    return relativeToStartAngle;\n  } else {\n    return normalizeAngle360(angle2 - relativeToStartAngle) + relativeToStartAngle;\n  }\n}\nfunction clockwiseAngles2(startAngle, endAngle, relativeToStartAngle = 0) {\n  const fullPie = Math.abs(endAngle - startAngle) >= 2 * Math.PI;\n  const sweepAngle = fullPie ? 2 * Math.PI : normalizeAngle360(endAngle - startAngle);\n  startAngle = clockwiseAngle2(startAngle, relativeToStartAngle);\n  endAngle = startAngle + sweepAngle;\n  return { startAngle, endAngle };\n}\nfunction arcRadialLineIntersectionAngle(cx, cy, r, startAngle, endAngle, clipAngle) {\n  const sinA = Math.sin(clipAngle);\n  const cosA = Math.cos(clipAngle);\n  const c = cx ** 2 + cy ** 2 - r ** 2;\n  let p0x = NaN;\n  let p0y = NaN;\n  let p1x = NaN;\n  let p1y = NaN;\n  if (cosA > 0.5) {\n    const tanA = sinA / cosA;\n    const a = 1 + tanA ** 2;\n    const b = -2 * (cx + cy * tanA);\n    const d = b ** 2 - 4 * a * c;\n    if (d < 0)\n      return;\n    const x0 = (-b + Math.sqrt(d)) / (2 * a);\n    const x1 = (-b - Math.sqrt(d)) / (2 * a);\n    p0x = x0;\n    p0y = x0 * tanA;\n    p1x = x1;\n    p1y = x1 * tanA;\n  } else {\n    const cotA = cosA / sinA;\n    const a = 1 + cotA ** 2;\n    const b = -2 * (cy + cx * cotA);\n    const d = b ** 2 - 4 * a * c;\n    if (d < 0)\n      return;\n    const y0 = (-b + Math.sqrt(d)) / (2 * a);\n    const y1 = (-b - Math.sqrt(d)) / (2 * a);\n    p0x = y0 * cotA;\n    p0y = y0;\n    p1x = y1 * cotA;\n    p1y = y1;\n  }\n  const normalisedX = cosA;\n  const normalisedY = sinA;\n  const p0DotNormalized = p0x * normalisedX + p0y * normalisedY;\n  const p1DotNormalized = p1x * normalisedX + p1y * normalisedY;\n  const a0 = p0DotNormalized > 0 ? clockwiseAngle2(Math.atan2(p0y - cy, p0x - cx), startAngle) : NaN;\n  const a1 = p1DotNormalized > 0 ? clockwiseAngle2(Math.atan2(p1y - cy, p1x - cx), startAngle) : NaN;\n  if (a0 >= startAngle && a0 <= endAngle) {\n    return a0;\n  } else if (a1 >= startAngle && a1 <= endAngle) {\n    return a1;\n  }\n}\nfunction arcCircleIntersectionAngle(cx, cy, r, startAngle, endAngle, circleR) {\n  const d = Math.hypot(cx, cy);\n  const d1 = (d ** 2 - r ** 2 + circleR ** 2) / (2 * d);\n  const d2 = d - d1;\n  const theta = Math.atan2(cy, cx);\n  const deltaTheta = Math.acos(-d2 / r);\n  const a0 = clockwiseAngle2(theta + deltaTheta, startAngle);\n  const a1 = clockwiseAngle2(theta - deltaTheta, startAngle);\n  if (a0 >= startAngle && a0 <= endAngle) {\n    return a0;\n  } else if (a1 >= startAngle && a1 <= endAngle) {\n    return a1;\n  }\n}\n\n// packages/ag-charts-community/src/scene/shape/sector.ts\nvar Arc = class {\n  constructor(cx, cy, r, a0, a1) {\n    this.cx = cx;\n    this.cy = cy;\n    this.r = r;\n    this.a0 = a0;\n    this.a1 = a1;\n    if (this.a0 >= this.a1) {\n      this.a0 = NaN;\n      this.a1 = NaN;\n    }\n  }\n  isValid() {\n    return Number.isFinite(this.a0) && Number.isFinite(this.a1);\n  }\n  pointAt(a) {\n    return {\n      x: this.cx + this.r * Math.cos(a),\n      y: this.cy + this.r * Math.sin(a)\n    };\n  }\n  clipStart(a) {\n    if (a == null || !this.isValid() || a < this.a0)\n      return;\n    this.a0 = a;\n    if (Number.isNaN(a) || this.a0 >= this.a1) {\n      this.a0 = NaN;\n      this.a1 = NaN;\n    }\n  }\n  clipEnd(a) {\n    if (a == null || !this.isValid() || a > this.a1)\n      return;\n    this.a1 = a;\n    if (Number.isNaN(a) || this.a0 >= this.a1) {\n      this.a0 = NaN;\n      this.a1 = NaN;\n    }\n  }\n};\nvar Sector = class extends Path {\n  constructor() {\n    super(...arguments);\n    this.centerX = 0;\n    this.centerY = 0;\n    this.innerRadius = 10;\n    this.outerRadius = 20;\n    this.startAngle = 0;\n    this.endAngle = Math.PI * 2;\n    this.clipSector = void 0;\n    this.concentricEdgeInset = 0;\n    this.radialEdgeInset = 0;\n    this.startOuterCornerRadius = 0;\n    this.endOuterCornerRadius = 0;\n    this.startInnerCornerRadius = 0;\n    this.endInnerCornerRadius = 0;\n  }\n  set inset(value) {\n    this.concentricEdgeInset = value;\n    this.radialEdgeInset = value;\n  }\n  set cornerRadius(value) {\n    this.startOuterCornerRadius = value;\n    this.endOuterCornerRadius = value;\n    this.startInnerCornerRadius = value;\n    this.endInnerCornerRadius = value;\n  }\n  computeBBox() {\n    return sectorBox(this).translate(this.centerX, this.centerY);\n  }\n  normalizedRadii() {\n    const { concentricEdgeInset } = this;\n    let { innerRadius, outerRadius } = this;\n    innerRadius = innerRadius > 0 ? innerRadius + concentricEdgeInset : 0;\n    outerRadius = Math.max(outerRadius - concentricEdgeInset, 0);\n    return { innerRadius, outerRadius };\n  }\n  normalizedClipSector() {\n    const { clipSector } = this;\n    if (clipSector == null)\n      return;\n    const { startAngle, endAngle } = clockwiseAngles2(this.startAngle, this.endAngle);\n    const { innerRadius, outerRadius } = this.normalizedRadii();\n    const clipAngles = clockwiseAngles2(clipSector.startAngle, clipSector.endAngle, startAngle);\n    return new SectorBox(\n      Math.max(startAngle, clipAngles.startAngle),\n      Math.min(endAngle, clipAngles.endAngle),\n      Math.max(innerRadius, clipSector.innerRadius),\n      Math.min(outerRadius, clipSector.outerRadius)\n    );\n  }\n  getAngleOffset(radius) {\n    return radius > 0 ? this.radialEdgeInset / radius : 0;\n  }\n  arc(r, angleSweep, a0, a1, outerArc, innerArc, start2, inner) {\n    if (r <= 0)\n      return;\n    const { startAngle, endAngle } = clockwiseAngles2(this.startAngle, this.endAngle);\n    const { innerRadius, outerRadius } = this.normalizedRadii();\n    const clipSector = this.normalizedClipSector();\n    if (inner && innerRadius <= 0)\n      return;\n    const angleOffset = inner ? this.getAngleOffset(innerRadius + r) : this.getAngleOffset(outerRadius - r);\n    const angle2 = start2 ? startAngle + angleOffset + angleSweep : endAngle - angleOffset - angleSweep;\n    const radius = inner ? innerRadius + r : outerRadius - r;\n    const cx = radius * Math.cos(angle2);\n    const cy = radius * Math.sin(angle2);\n    if (clipSector != null) {\n      const delta4 = 1e-6;\n      if (!start2 && !(angle2 >= startAngle - delta4 && angle2 <= clipSector.endAngle - delta4))\n        return;\n      if (start2 && !(angle2 >= clipSector.startAngle + delta4 && angle2 <= endAngle - delta4))\n        return;\n      if (inner && radius < clipSector.innerRadius - delta4)\n        return;\n      if (!inner && radius > clipSector.outerRadius + delta4)\n        return;\n    }\n    const arc = new Arc(cx, cy, r, a0, a1);\n    if (clipSector != null) {\n      if (inner) {\n        arc.clipStart(arcRadialLineIntersectionAngle(cx, cy, r, a0, a1, clipSector.endAngle));\n        arc.clipEnd(arcRadialLineIntersectionAngle(cx, cy, r, a0, a1, clipSector.startAngle));\n      } else {\n        arc.clipStart(arcRadialLineIntersectionAngle(cx, cy, r, a0, a1, clipSector.startAngle));\n        arc.clipEnd(arcRadialLineIntersectionAngle(cx, cy, r, a0, a1, clipSector.endAngle));\n      }\n      let circleClipStart;\n      let circleClipEnd;\n      if (start2) {\n        circleClipStart = arcCircleIntersectionAngle(cx, cy, r, a0, a1, clipSector.innerRadius);\n        circleClipEnd = arcCircleIntersectionAngle(cx, cy, r, a0, a1, clipSector.outerRadius);\n      } else {\n        circleClipStart = arcCircleIntersectionAngle(cx, cy, r, a0, a1, clipSector.outerRadius);\n        circleClipEnd = arcCircleIntersectionAngle(cx, cy, r, a0, a1, clipSector.innerRadius);\n      }\n      arc.clipStart(circleClipStart);\n      arc.clipEnd(circleClipEnd);\n      if (circleClipStart != null) {\n        const { x: x2, y: y2 } = arc.pointAt(circleClipStart);\n        const theta2 = clockwiseAngle2(Math.atan2(y2, x2), startAngle);\n        if (start2) {\n          innerArc?.clipStart(theta2);\n        } else {\n          outerArc.clipEnd(theta2);\n        }\n      }\n      if (circleClipEnd != null) {\n        const { x: x2, y: y2 } = arc.pointAt(circleClipEnd);\n        const theta2 = clockwiseAngle2(Math.atan2(y2, x2), startAngle);\n        if (start2) {\n          outerArc.clipStart(theta2);\n        } else {\n          innerArc?.clipEnd(theta2);\n        }\n      }\n    }\n    if (clipSector != null) {\n      const { x: x2, y: y2 } = arc.pointAt((arc.a0 + arc.a1) / 2);\n      if (!isPointInSector(x2, y2, clipSector))\n        return;\n    }\n    const { x, y } = arc.pointAt(start2 === inner ? arc.a0 : arc.a1);\n    const theta = clockwiseAngle2(Math.atan2(y, x), startAngle);\n    const radialArc = inner ? innerArc : outerArc;\n    if (start2) {\n      radialArc?.clipStart(theta);\n    } else {\n      radialArc?.clipEnd(theta);\n    }\n    return arc;\n  }\n  updatePath() {\n    const delta4 = 1e-6;\n    const { path, centerX, centerY, concentricEdgeInset, radialEdgeInset } = this;\n    let { startOuterCornerRadius, endOuterCornerRadius, startInnerCornerRadius, endInnerCornerRadius } = this;\n    const { startAngle, endAngle } = clockwiseAngles2(this.startAngle, this.endAngle);\n    const { innerRadius, outerRadius } = this.normalizedRadii();\n    const clipSector = this.normalizedClipSector();\n    const sweepAngle = endAngle - startAngle;\n    const fullPie = sweepAngle >= 2 * Math.PI - delta4;\n    path.clear();\n    if (innerRadius === 0 && outerRadius === 0 || innerRadius > outerRadius) {\n      return;\n    } else if ((clipSector?.startAngle ?? startAngle) === (clipSector?.endAngle ?? endAngle)) {\n      return;\n    } else if (fullPie && this.clipSector == null && startOuterCornerRadius === 0 && endOuterCornerRadius === 0 && startInnerCornerRadius === 0 && endInnerCornerRadius === 0) {\n      path.moveTo(centerX + outerRadius * Math.cos(startAngle), centerY + outerRadius * Math.sin(startAngle));\n      path.arc(centerX, centerY, outerRadius, startAngle, endAngle);\n      if (innerRadius > concentricEdgeInset) {\n        path.moveTo(centerX + innerRadius * Math.cos(endAngle), centerY + innerRadius * Math.sin(endAngle));\n        path.arc(centerX, centerY, innerRadius, endAngle, startAngle, true);\n      }\n      path.closePath();\n      return;\n    } else if (this.clipSector == null && Math.abs(innerRadius - outerRadius) < 1e-6) {\n      path.arc(centerX, centerY, outerRadius, startAngle, endAngle, false);\n      path.arc(centerX, centerY, outerRadius, endAngle, startAngle, true);\n      path.closePath();\n      return;\n    }\n    const innerAngleOffset = this.getAngleOffset(innerRadius);\n    const outerAngleOffset = this.getAngleOffset(outerRadius);\n    const outerAngleExceeded = sweepAngle < 2 * outerAngleOffset;\n    if (outerAngleExceeded)\n      return;\n    const hasInnerSweep = (clipSector?.innerRadius ?? innerRadius) > concentricEdgeInset;\n    const innerAngleExceeded = innerRadius < concentricEdgeInset || sweepAngle < 2 * innerAngleOffset;\n    const radialLength = outerRadius - innerRadius;\n    const maxRadialLength = Math.max(\n      startOuterCornerRadius,\n      startInnerCornerRadius,\n      endOuterCornerRadius,\n      endInnerCornerRadius\n    );\n    const initialScalingFactor = maxRadialLength > 0 ? Math.min(radialLength / maxRadialLength, 1) : 1;\n    startOuterCornerRadius *= initialScalingFactor;\n    endOuterCornerRadius *= initialScalingFactor;\n    startInnerCornerRadius *= initialScalingFactor;\n    endInnerCornerRadius *= initialScalingFactor;\n    const outerScalingFactor = radiiScalingFactor(\n      outerRadius,\n      sweepAngle - 2 * outerAngleOffset,\n      -startOuterCornerRadius,\n      -endOuterCornerRadius\n    );\n    startOuterCornerRadius *= outerScalingFactor;\n    endOuterCornerRadius *= outerScalingFactor;\n    if (!innerAngleExceeded && hasInnerSweep) {\n      const innerScalingFactor = radiiScalingFactor(\n        innerRadius,\n        sweepAngle - 2 * innerAngleOffset,\n        startInnerCornerRadius,\n        endInnerCornerRadius\n      );\n      startInnerCornerRadius *= innerScalingFactor;\n      endInnerCornerRadius *= innerScalingFactor;\n    } else {\n      startInnerCornerRadius = 0;\n      endInnerCornerRadius = 0;\n    }\n    const maxCombinedRadialLength = Math.max(\n      startOuterCornerRadius + startInnerCornerRadius,\n      endOuterCornerRadius + endInnerCornerRadius\n    );\n    const edgesScalingFactor = maxCombinedRadialLength > 0 ? Math.min(radialLength / maxCombinedRadialLength, 1) : 1;\n    startOuterCornerRadius *= edgesScalingFactor;\n    endOuterCornerRadius *= edgesScalingFactor;\n    startInnerCornerRadius *= edgesScalingFactor;\n    endInnerCornerRadius *= edgesScalingFactor;\n    let startOuterCornerRadiusAngleSweep = 0;\n    let endOuterCornerRadiusAngleSweep = 0;\n    const startOuterCornerRadiusSweep = startOuterCornerRadius / (outerRadius - startOuterCornerRadius);\n    const endOuterCornerRadiusSweep = endOuterCornerRadius / (outerRadius - endOuterCornerRadius);\n    if (startOuterCornerRadiusSweep >= 0 && startOuterCornerRadiusSweep < 1 - delta4) {\n      startOuterCornerRadiusAngleSweep = Math.asin(startOuterCornerRadiusSweep);\n    } else {\n      startOuterCornerRadiusAngleSweep = sweepAngle / 2;\n      const maxStartOuterCornerRadius = outerRadius / (1 / Math.sin(startOuterCornerRadiusAngleSweep) + 1);\n      startOuterCornerRadius = Math.min(maxStartOuterCornerRadius, startOuterCornerRadius);\n    }\n    if (endOuterCornerRadiusSweep >= 0 && endOuterCornerRadiusSweep < 1 - delta4) {\n      endOuterCornerRadiusAngleSweep = Math.asin(endOuterCornerRadiusSweep);\n    } else {\n      endOuterCornerRadiusAngleSweep = sweepAngle / 2;\n      const maxEndOuterCornerRadius = outerRadius / (1 / Math.sin(endOuterCornerRadiusAngleSweep) + 1);\n      endOuterCornerRadius = Math.min(maxEndOuterCornerRadius, endOuterCornerRadius);\n    }\n    const startInnerCornerRadiusAngleSweep = Math.asin(\n      startInnerCornerRadius / (innerRadius + startInnerCornerRadius)\n    );\n    const endInnerCornerRadiusAngleSweep = Math.asin(endInnerCornerRadius / (innerRadius + endInnerCornerRadius));\n    const outerArcRadius = clipSector?.outerRadius ?? outerRadius;\n    const outerArcRadiusOffset = this.getAngleOffset(outerArcRadius);\n    const outerArc = new Arc(\n      0,\n      0,\n      outerArcRadius,\n      startAngle + outerArcRadiusOffset,\n      endAngle - outerArcRadiusOffset\n    );\n    const innerArcRadius = clipSector?.innerRadius ?? innerRadius;\n    const innerArcRadiusOffset = this.getAngleOffset(innerArcRadius);\n    const innerArc = hasInnerSweep ? new Arc(0, 0, innerArcRadius, startAngle + innerArcRadiusOffset, endAngle - innerArcRadiusOffset) : void 0;\n    if (clipSector != null) {\n      outerArc.clipStart(clipSector.startAngle);\n      outerArc.clipEnd(clipSector.endAngle);\n      innerArc?.clipStart(clipSector.startAngle);\n      innerArc?.clipEnd(clipSector.endAngle);\n    }\n    const startOuterArc = this.arc(\n      startOuterCornerRadius,\n      startOuterCornerRadiusAngleSweep,\n      startAngle - Math.PI * 0.5,\n      startAngle + startOuterCornerRadiusAngleSweep,\n      outerArc,\n      innerArc,\n      true,\n      false\n    );\n    const endOuterArc = this.arc(\n      endOuterCornerRadius,\n      endOuterCornerRadiusAngleSweep,\n      endAngle - endOuterCornerRadiusAngleSweep,\n      endAngle + Math.PI * 0.5,\n      outerArc,\n      innerArc,\n      false,\n      false\n    );\n    const endInnerArc = this.arc(\n      endInnerCornerRadius,\n      endInnerCornerRadiusAngleSweep,\n      endAngle + Math.PI * 0.5,\n      endAngle + Math.PI - endInnerCornerRadiusAngleSweep,\n      outerArc,\n      innerArc,\n      false,\n      true\n    );\n    const startInnerArc = this.arc(\n      startInnerCornerRadius,\n      startInnerCornerRadiusAngleSweep,\n      startAngle + Math.PI + startInnerCornerRadiusAngleSweep,\n      startAngle + Math.PI * 1.5,\n      outerArc,\n      innerArc,\n      true,\n      true\n    );\n    if (innerAngleExceeded) {\n      const x = sweepAngle < Math.PI * 0.5 ? radialEdgeInset * (1 + Math.cos(sweepAngle)) / Math.sin(sweepAngle) : NaN;\n      let r;\n      if (x > 0 && x < outerRadius) {\n        r = Math.max(Math.hypot(radialEdgeInset, x), innerRadius);\n      } else {\n        r = radialEdgeInset;\n      }\n      r = Math.max(r, innerRadius);\n      const midAngle = startAngle + sweepAngle * 0.5;\n      path.moveTo(centerX + r * Math.cos(midAngle), centerY + r * Math.sin(midAngle));\n    } else if (startInnerArc?.isValid() === true || innerArc?.isValid() === true) {\n    } else {\n      const midAngle = startAngle + sweepAngle / 2;\n      const cx = innerRadius * Math.cos(midAngle);\n      const cy = innerRadius * Math.sin(midAngle);\n      path.moveTo(centerX + cx, centerY + cy);\n    }\n    if (startOuterArc?.isValid() === true) {\n      const { cx, cy, r, a0, a1 } = startOuterArc;\n      path.arc(centerX + cx, centerY + cy, r, a0, a1);\n    }\n    if (outerArc.isValid()) {\n      const { r, a0, a1 } = outerArc;\n      path.arc(centerX, centerY, r, a0, a1);\n    }\n    if (endOuterArc?.isValid() === true) {\n      const { cx, cy, r, a0, a1 } = endOuterArc;\n      path.arc(centerX + cx, centerY + cy, r, a0, a1);\n    }\n    if (!innerAngleExceeded) {\n      if (endInnerArc?.isValid() === true) {\n        const { cx, cy, r, a0, a1 } = endInnerArc;\n        path.arc(centerX + cx, centerY + cy, r, a0, a1);\n      }\n      if (innerArc?.isValid() === true) {\n        const { r, a0, a1 } = innerArc;\n        path.arc(centerX, centerY, r, a1, a0, true);\n      }\n      if (startInnerArc?.isValid() === true) {\n        const { cx, cy, r, a0, a1 } = startInnerArc;\n        path.arc(centerX + cx, centerY + cy, r, a0, a1);\n      }\n    }\n    path.closePath();\n  }\n  isPointInPath(x, y) {\n    const { startAngle, endAngle, innerRadius, outerRadius } = this.clipSector ?? this;\n    return isPointInSector(x - this.centerX, y - this.centerY, {\n      startAngle,\n      endAngle,\n      innerRadius: Math.min(innerRadius, outerRadius),\n      outerRadius: Math.max(innerRadius, outerRadius)\n    });\n  }\n};\nSector.className = \"Sector\";\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"centerX\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"centerY\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"innerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"outerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"startAngle\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"endAngle\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"clipSector\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"concentricEdgeInset\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"radialEdgeInset\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"startOuterCornerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"endOuterCornerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"startInnerCornerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"endInnerCornerRadius\", 2);\n\n// packages/ag-charts-community/src/chart/themes/defaultColors.ts\nvar DEFAULT_FILLS = {\n  BLUE: \"#5090dc\",\n  ORANGE: \"#ffa03a\",\n  GREEN: \"#459d55\",\n  CYAN: \"#34bfe1\",\n  YELLOW: \"#e1cc00\",\n  VIOLET: \"#9669cb\",\n  GRAY: \"#b5b5b5\",\n  MAGENTA: \"#bd5aa7\",\n  BROWN: \"#8a6224\",\n  RED: \"#ef5452\"\n};\nvar DEFAULT_STROKES = {\n  BLUE: \"#2b5c95\",\n  ORANGE: \"#cc6f10\",\n  GREEN: \"#1e652e\",\n  CYAN: \"#18859e\",\n  YELLOW: \"#a69400\",\n  VIOLET: \"#603c88\",\n  GRAY: \"#575757\",\n  MAGENTA: \"#7d2f6d\",\n  BROWN: \"#4f3508\",\n  RED: \"#a82529\"\n};\n\n// packages/ag-charts-community/src/chart/series/polar/donutSeriesProperties.ts\nvar DonutTitle = class extends Caption {\n  constructor() {\n    super(...arguments);\n    this.showInLegend = false;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], DonutTitle.prototype, \"showInLegend\", 2);\nvar DonutInnerLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.spacing = 2;\n  }\n  set(properties, _reset) {\n    return super.set(properties);\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], DonutInnerLabel.prototype, \"text\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], DonutInnerLabel.prototype, \"spacing\", 2);\nvar DonutInnerCircle = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.fill = \"transparent\";\n    this.fillOpacity = 1;\n  }\n};\n__decorateClass([\n  Validate(COLOR_STRING)\n], DonutInnerCircle.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO)\n], DonutInnerCircle.prototype, \"fillOpacity\", 2);\nvar DonutSeriesCalloutLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.offset = 3;\n    this.minAngle = 0;\n    this.minSpacing = 4;\n    this.maxCollisionOffset = 50;\n    this.avoidCollisions = true;\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesCalloutLabel.prototype, \"offset\", 2);\n__decorateClass([\n  Validate(DEGREE)\n], DonutSeriesCalloutLabel.prototype, \"minAngle\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesCalloutLabel.prototype, \"minSpacing\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesCalloutLabel.prototype, \"maxCollisionOffset\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], DonutSeriesCalloutLabel.prototype, \"avoidCollisions\", 2);\nvar DonutSeriesSectorLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.positionOffset = 0;\n    this.positionRatio = 0.5;\n  }\n};\n__decorateClass([\n  Validate(NUMBER)\n], DonutSeriesSectorLabel.prototype, \"positionOffset\", 2);\n__decorateClass([\n  Validate(RATIO)\n], DonutSeriesSectorLabel.prototype, \"positionRatio\", 2);\nvar DonutSeriesCalloutLine = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.length = 10;\n    this.strokeWidth = 1;\n  }\n};\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY, { optional: true })\n], DonutSeriesCalloutLine.prototype, \"colors\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesCalloutLine.prototype, \"length\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesCalloutLine.prototype, \"strokeWidth\", 2);\nvar DonutSeriesProperties = class extends SeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.fills = Object.values(DEFAULT_FILLS);\n    this.strokes = Object.values(DEFAULT_STROKES);\n    this.fillOpacity = 1;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.cornerRadius = 0;\n    this.rotation = 0;\n    this.outerRadiusOffset = 0;\n    this.outerRadiusRatio = 1;\n    this.strokeWidth = 1;\n    this.sectorSpacing = 0;\n    this.innerLabels = new PropertiesArray(DonutInnerLabel);\n    this.title = new DonutTitle();\n    this.innerCircle = new DonutInnerCircle();\n    this.shadow = new DropShadow();\n    this.calloutLabel = new DonutSeriesCalloutLabel();\n    this.sectorLabel = new DonutSeriesSectorLabel();\n    this.calloutLine = new DonutSeriesCalloutLine();\n    this.tooltip = new SeriesTooltip();\n  }\n  isValid() {\n    const superIsValid = super.isValid();\n    if (this.innerRadiusRatio == null && this.innerRadiusOffset == null) {\n      Logger.warnOnce(\n        \"Either an [innerRadiusRatio] or an [innerRadiusOffset] must be set to render a donut series.\"\n      );\n      return false;\n    }\n    return superIsValid;\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], DonutSeriesProperties.prototype, \"angleKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"angleName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"angleFilterKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"radiusKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"radiusName\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], DonutSeriesProperties.prototype, \"radiusMin\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], DonutSeriesProperties.prototype, \"radiusMax\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"calloutLabelKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"calloutLabelName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"sectorLabelKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"sectorLabelName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"legendItemKey\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], DonutSeriesProperties.prototype, \"fills\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], DonutSeriesProperties.prototype, \"strokes\", 2);\n__decorateClass([\n  Validate(RATIO)\n], DonutSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(RATIO)\n], DonutSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH)\n], DonutSeriesProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesProperties.prototype, \"cornerRadius\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], DonutSeriesProperties.prototype, \"itemStyler\", 2);\n__decorateClass([\n  Validate(DEGREE)\n], DonutSeriesProperties.prototype, \"rotation\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], DonutSeriesProperties.prototype, \"outerRadiusOffset\", 2);\n__decorateClass([\n  Validate(RATIO)\n], DonutSeriesProperties.prototype, \"outerRadiusRatio\", 2);\n__decorateClass([\n  Validate(NUMBER, { optional: true })\n], DonutSeriesProperties.prototype, \"innerRadiusOffset\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], DonutSeriesProperties.prototype, \"innerRadiusRatio\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], DonutSeriesProperties.prototype, \"sectorSpacing\", 2);\n__decorateClass([\n  Validate(OBJECT_ARRAY)\n], DonutSeriesProperties.prototype, \"innerLabels\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], DonutSeriesProperties.prototype, \"title\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], DonutSeriesProperties.prototype, \"innerCircle\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], DonutSeriesProperties.prototype, \"shadow\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], DonutSeriesProperties.prototype, \"calloutLabel\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], DonutSeriesProperties.prototype, \"sectorLabel\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], DonutSeriesProperties.prototype, \"calloutLine\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], DonutSeriesProperties.prototype, \"tooltip\", 2);\n\n// packages/ag-charts-community/src/chart/series/polar/pieUtil.ts\nfunction preparePieSeriesAnimationFunctions(initialLoad, rotationDegrees, scaleFn, oldScaleFn) {\n  const scale2 = [scaleFn.convert(0), scaleFn.convert(1)];\n  const oldScale = [oldScaleFn.convert(0), oldScaleFn.convert(1)];\n  const rotation = Math.PI / -2 + toRadians(rotationDegrees);\n  const phase = initialLoad ? \"initial\" : \"update\";\n  const scaleToNewRadius = ({ radius }) => {\n    return { innerRadius: scale2[0], outerRadius: scale2[0] + (scale2[1] - scale2[0]) * radius };\n  };\n  const scaleToOldRadius = ({ radius }) => {\n    return { innerRadius: oldScale[0], outerRadius: oldScale[0] + (oldScale[1] - oldScale[0]) * radius };\n  };\n  const fromFn = (sect, datum, status, { prevFromProps }) => {\n    let { startAngle, endAngle, innerRadius, outerRadius } = sect;\n    let { fill, stroke } = datum.sectorFormat;\n    if (status === \"unknown\" || status === \"added\" && !prevFromProps) {\n      startAngle = rotation;\n      endAngle = rotation;\n      innerRadius = datum.innerRadius;\n      outerRadius = datum.outerRadius;\n    } else if (status === \"added\" && prevFromProps) {\n      startAngle = prevFromProps.endAngle ?? rotation;\n      endAngle = prevFromProps.endAngle ?? rotation;\n      innerRadius = prevFromProps.innerRadius ?? datum.innerRadius;\n      outerRadius = prevFromProps.outerRadius ?? datum.outerRadius;\n    }\n    if (status === \"added\" && !initialLoad) {\n      const radii = scaleToOldRadius(datum);\n      innerRadius = radii.innerRadius;\n      outerRadius = radii.outerRadius;\n    }\n    if (status === \"updated\") {\n      fill = sect.fill ?? fill;\n      stroke = sect.stroke ?? stroke;\n    }\n    return { startAngle, endAngle, innerRadius, outerRadius, fill, stroke, phase };\n  };\n  const toFn = (_sect, datum, status, { prevLive }) => {\n    let { startAngle, endAngle, innerRadius, outerRadius } = datum;\n    const { stroke, fill } = datum.sectorFormat;\n    if (status === \"removed\" && prevLive) {\n      startAngle = prevLive.datum?.endAngle;\n      endAngle = prevLive.datum?.endAngle;\n    } else if (status === \"removed\" && !prevLive) {\n      startAngle = rotation;\n      endAngle = rotation;\n    }\n    if (status === \"removed\") {\n      const radii = scaleToNewRadius(datum);\n      innerRadius = radii.innerRadius;\n      outerRadius = radii.outerRadius;\n    }\n    return { startAngle, endAngle, outerRadius, innerRadius, stroke, fill };\n  };\n  const innerCircleFromFn = (node, _) => {\n    return { size: node.previousDatum?.radius ?? node.size ?? 0, phase };\n  };\n  const innerCircleToFn = (_, datum) => {\n    return { size: datum.radius ?? 0 };\n  };\n  return { nodes: { toFn, fromFn }, innerCircle: { fromFn: innerCircleFromFn, toFn: innerCircleToFn } };\n}\nfunction resetPieSelectionsFn(_node, datum) {\n  return {\n    startAngle: datum.startAngle,\n    endAngle: datum.endAngle,\n    innerRadius: datum.innerRadius,\n    outerRadius: datum.outerRadius,\n    fill: datum.sectorFormat.fill,\n    stroke: datum.sectorFormat.stroke\n  };\n}\nfunction pickByMatchingAngle(series, point) {\n  const dy = point.y - series.centerY;\n  const dx = point.x - series.centerX;\n  const angle2 = Math.atan2(dy, dx);\n  const sectors = series.getItemNodes();\n  for (const sector of sectors) {\n    if (sector.datum.missing === true)\n      continue;\n    if (isBetweenAngles(angle2, sector.startAngle, sector.endAngle)) {\n      const radius = Math.sqrt(dx * dx + dy * dy);\n      let distance3 = 0;\n      if (radius < sector.innerRadius) {\n        distance3 = sector.innerRadius - radius;\n      } else if (radius > sector.outerRadius) {\n        distance3 = radius - sector.outerRadius;\n      }\n      return { datum: sector.datum, distance: distance3 };\n    }\n  }\n  return void 0;\n}\n\n// packages/ag-charts-community/src/chart/series/polar/polarSeries.ts\nvar PolarSeries = class extends DataModelSeries {\n  constructor({\n    useLabelLayer = false,\n    pickModes = [1 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */],\n    canHaveAxes = false,\n    animationResetFns,\n    ...opts\n  }) {\n    super({\n      ...opts,\n      useLabelLayer,\n      pickModes,\n      contentGroupVirtual: false,\n      directionKeys: {\n        [\"x\" /* X */]: [\"angleKey\"],\n        [\"y\" /* Y */]: [\"radiusKey\"]\n      },\n      directionNames: {\n        [\"x\" /* X */]: [\"angleName\"],\n        [\"y\" /* Y */]: [\"radiusName\"]\n      },\n      canHaveAxes\n    });\n    this.itemGroup = this.contentGroup.appendChild(new Group());\n    this.nodeData = [];\n    this.itemSelection = Selection.select(\n      this.itemGroup,\n      () => this.nodeFactory(),\n      false\n    );\n    this.labelSelection = Selection.select(\n      this.labelGroup,\n      () => this.labelFactory(),\n      false\n    );\n    this.highlightSelection = Selection.select(\n      this.highlightGroup,\n      () => this.nodeFactory()\n    );\n    this.highlightLabelSelection = Selection.select(\n      this.highlightLabel,\n      () => this.labelFactory()\n    );\n    /**\n     * The center of the polar series (for example, the center of a pie).\n     * If the polar chart has multiple series, all of them will have their\n     * center set to the same value as a result of the polar chart layout.\n     * The center coordinates are not supposed to be set by the user.\n     */\n    this.centerX = 0;\n    this.centerY = 0;\n    /**\n     * The maximum radius the series can use.\n     * This value is set automatically as a result of the polar chart layout\n     * and is not supposed to be set by the user.\n     */\n    this.radius = 0;\n    this.itemGroup.zIndexSubOrder = [() => this._declarationOrder, 1];\n    this.animationResetFns = animationResetFns;\n    this.animationState = new StateMachine(\n      \"empty\",\n      {\n        empty: {\n          update: {\n            target: \"ready\",\n            action: (data) => this.animateEmptyUpdateReady(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\"\n        },\n        ready: {\n          updateData: \"waiting\",\n          clear: \"clearing\",\n          highlight: (data) => this.animateReadyHighlight(data),\n          highlightMarkers: (data) => this.animateReadyHighlightMarkers(data),\n          resize: (data) => this.animateReadyResize(data),\n          reset: \"empty\",\n          skip: \"ready\"\n        },\n        waiting: {\n          update: {\n            target: \"ready\",\n            action: (data) => this.animateWaitingUpdateReady(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\"\n        },\n        clearing: {\n          update: {\n            target: \"empty\",\n            action: (data) => this.animateClearingUpdateEmpty(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\"\n        }\n      },\n      () => this.checkProcessedDataAnimatable()\n    );\n  }\n  getItemNodes() {\n    return [...this.itemGroup.children()];\n  }\n  getNodeData() {\n    return this.nodeData;\n  }\n  resetAnimation(phase) {\n    if (phase === \"initial\") {\n      this.animationState.transition(\"reset\");\n    } else if (phase === \"ready\") {\n      this.animationState.transition(\"skip\");\n    }\n  }\n  labelFactory() {\n    const text = new Text();\n    text.pointerEvents = 1 /* None */;\n    return text;\n  }\n  getInnerRadius() {\n    return 0;\n  }\n  getLabelData() {\n    return [];\n  }\n  computeLabelsBBox(_options, _seriesRect) {\n    return null;\n  }\n  resetAllAnimation() {\n    const { item, label } = this.animationResetFns ?? {};\n    this.ctx.animationManager.stopByAnimationGroupId(this.id);\n    if (item) {\n      resetMotion([this.itemSelection, this.highlightSelection], item);\n    }\n    if (label) {\n      resetMotion([this.labelSelection, this.highlightLabelSelection], label);\n    }\n    this.itemSelection.cleanup();\n    this.labelSelection.cleanup();\n    this.highlightSelection.cleanup();\n    this.highlightLabelSelection.cleanup();\n  }\n  animateEmptyUpdateReady(_data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation();\n  }\n  animateWaitingUpdateReady(_data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation();\n  }\n  animateReadyHighlight(_data) {\n    const { item, label } = this.animationResetFns ?? {};\n    if (item) {\n      resetMotion([this.highlightSelection], item);\n    }\n    if (label) {\n      resetMotion([this.highlightLabelSelection], label);\n    }\n  }\n  animateReadyHighlightMarkers(_data) {\n  }\n  animateReadyResize(_data) {\n    this.resetAllAnimation();\n  }\n  animateClearingUpdateEmpty(_data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation();\n  }\n  animationTransitionClear() {\n    this.animationState.transition(\"clear\", this.getAnimationData());\n  }\n  getAnimationData(seriesRect) {\n    return { seriesRect };\n  }\n  computeFocusBounds(opts) {\n    const datum = this.getNodeData()?.[opts.datumIndex];\n    if (datum !== void 0) {\n      return this.itemSelection.select((node) => node instanceof Path && node.datum === datum)[0];\n    }\n    return void 0;\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/polar/donutSeries.ts\nvar DonutSeriesNodeEvent = class extends SeriesNodeEvent {\n  constructor(type, nativeEvent, datum, series) {\n    super(type, nativeEvent, datum, series);\n    this.angleKey = series.properties.angleKey;\n    this.radiusKey = series.properties.radiusKey;\n    this.calloutLabelKey = series.properties.calloutLabelKey;\n    this.sectorLabelKey = series.properties.sectorLabelKey;\n  }\n};\nvar DonutSeries = class extends PolarSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      pickModes: [1 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */],\n      useLabelLayer: true,\n      animationResetFns: { item: resetPieSelectionsFn, label: resetLabelFn }\n    });\n    this.properties = new DonutSeriesProperties();\n    this.phantomNodeData = void 0;\n    this.previousRadiusScale = new LinearScale();\n    this.radiusScale = new LinearScale();\n    this.phantomGroup = this.contentGroup.appendChild(new Group());\n    this.phantomSelection = Selection.select(\n      this.phantomGroup,\n      () => this.nodeFactory(),\n      false\n    );\n    this.calloutLabelGroup = this.contentGroup.appendChild(new Group({ name: \"pieCalloutLabels\" }));\n    this.calloutLabelSelection = new Selection(\n      this.calloutLabelGroup,\n      Group\n    );\n    // The group node that contains the background graphics.\n    this.backgroundGroup = this.rootGroup.appendChild(\n      new TranslatableLayer({\n        name: `${this.id}-background`,\n        zIndex: 0 /* SERIES_BACKGROUND */\n      })\n    );\n    // AG-6193 If the sum of all datums is 0, then we'll draw 1 or 2 rings to represent the empty series.\n    this.zerosumRingsGroup = this.backgroundGroup.appendChild(new Group({ name: `${this.id}-zerosumRings` }));\n    this.zerosumOuterRing = this.zerosumRingsGroup.appendChild(new Circle());\n    this.zerosumInnerRing = this.zerosumRingsGroup.appendChild(new Circle());\n    this.innerLabelsGroup = this.contentGroup.appendChild(new Group({ name: \"innerLabels\" }));\n    this.innerCircleGroup = this.backgroundGroup.appendChild(new Group({ name: `${this.id}-innerCircle` }));\n    this.innerLabelsSelection = Selection.select(this.innerLabelsGroup, Text);\n    this.innerCircleSelection = Selection.select(\n      this.innerCircleGroup,\n      Circle\n    );\n    // When a user toggles a series item (e.g. from the legend), its boolean state is recorded here.\n    this.seriesItemEnabled = [];\n    this.legendItemEnabled = [];\n    this.surroundingRadius = void 0;\n    this.NodeEvent = DonutSeriesNodeEvent;\n    this.angleScale = new LinearScale();\n    this.angleScale.domain = [0, 1];\n    this.angleScale.range = [-Math.PI, Math.PI].map((angle2) => angle2 + Math.PI / 2);\n    this.phantomGroup.opacity = 0.2;\n    this.phantomGroup.zIndexSubOrder = [() => this._declarationOrder, 0];\n  }\n  get calloutNodeData() {\n    return this.phantomNodeData ?? this.nodeData;\n  }\n  addChartEventListeners() {\n    this.destroyFns.push(\n      this.ctx.chartEventManager?.addListener(\"legend-item-click\", (event) => this.onLegendItemClick(event))\n    );\n  }\n  get visible() {\n    return super.visible && (this.seriesItemEnabled.length === 0 || this.seriesItemEnabled.includes(true));\n  }\n  nodeFactory() {\n    return new Sector();\n  }\n  getSeriesDomain(direction) {\n    if (direction === \"x\" /* X */) {\n      return this.angleScale.domain;\n    } else {\n      return this.radiusScale.domain;\n    }\n  }\n  async processData(dataController) {\n    if (this.data == null || !this.properties.isValid()) {\n      return;\n    }\n    let { data } = this;\n    const { visible, seriesItemEnabled } = this;\n    const { angleKey, angleFilterKey, radiusKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    const extraKeyProps = [];\n    const extraProps = [];\n    if (legendItemKey) {\n      extraKeyProps.push(keyProperty(legendItemKey, \"band\", { id: `legendItemKey` }));\n    } else if (calloutLabelKey) {\n      extraKeyProps.push(keyProperty(calloutLabelKey, \"band\", { id: `calloutLabelKey` }));\n    } else if (sectorLabelKey) {\n      extraKeyProps.push(keyProperty(sectorLabelKey, \"band\", { id: `sectorLabelKey` }));\n    }\n    const radiusScaleType = this.radiusScale.type;\n    const angleScaleType = this.radiusScale.type;\n    if (radiusKey) {\n      extraProps.push(\n        rangedValueProperty(radiusKey, {\n          id: \"radiusValue\",\n          min: this.properties.radiusMin ?? 0,\n          max: this.properties.radiusMax\n        }),\n        valueProperty(radiusKey, radiusScaleType, { id: `radiusRaw` }),\n        // Raw value pass-through.\n        normalisePropertyTo(\"radiusValue\", [0, 1], 1, this.properties.radiusMin ?? 0, this.properties.radiusMax)\n      );\n    }\n    if (calloutLabelKey) {\n      extraProps.push(valueProperty(calloutLabelKey, \"band\", { id: `calloutLabelValue` }));\n    }\n    if (sectorLabelKey) {\n      extraProps.push(valueProperty(sectorLabelKey, \"band\", { id: `sectorLabelValue` }));\n    }\n    if (legendItemKey) {\n      extraProps.push(valueProperty(legendItemKey, \"band\", { id: `legendItemValue` }));\n    }\n    if (angleFilterKey) {\n      extraProps.push(\n        accumulativeValueProperty(angleFilterKey, angleScaleType, {\n          id: `angleFilterValue`,\n          onlyPositive: true\n        }),\n        valueProperty(angleFilterKey, angleScaleType, { id: `angleFilterRaw` }),\n        normalisePropertyTo(\"angleFilterValue\", [0, 1], 0, 0)\n      );\n    }\n    if (animationEnabled && this.processedData && extraKeyProps.length > 0) {\n      extraProps.push(diff(this.processedData));\n    }\n    extraProps.push(animationValidation());\n    data = data.map((d, idx) => visible && seriesItemEnabled[idx] ? d : { ...d, [angleKey]: 0 });\n    await this.requestDataModel(dataController, data, {\n      props: [\n        ...extraKeyProps,\n        accumulativeValueProperty(angleKey, angleScaleType, { id: `angleValue`, onlyPositive: true }),\n        valueProperty(angleKey, angleScaleType, { id: `angleRaw` }),\n        // Raw value pass-through.\n        normalisePropertyTo(\"angleValue\", [0, 1], 0, 0),\n        ...extraProps\n      ]\n    });\n    for (const valueDef of this.processedData?.defs?.values ?? []) {\n      const { id, missing, property } = valueDef;\n      const missCount = getMissCount(this, missing);\n      if (id !== \"angleRaw\" && missCount > 0) {\n        Logger.warnOnce(\n          `no value was found for the key '${String(property)}' on ${missCount} data element${missCount > 1 ? \"s\" : \"\"}`\n        );\n      }\n    }\n    this.animationState.transition(\"updateData\");\n  }\n  async maybeRefreshNodeData() {\n    if (!this.nodeDataRefresh)\n      return;\n    const { nodeData = [], phantomNodeData } = await this.createNodeData() ?? {};\n    this.nodeData = nodeData;\n    this.phantomNodeData = phantomNodeData;\n    this.nodeDataRefresh = false;\n  }\n  getProcessedDataIndexes(dataModel) {\n    const angleIdx = dataModel.resolveProcessedDataIndexById(this, `angleValue`);\n    const angleRawIdx = dataModel.resolveProcessedDataIndexById(this, `angleRaw`);\n    const angleFilterIdx = this.properties.angleFilterKey != null ? dataModel.resolveProcessedDataIndexById(this, `angleFilterValue`) : void 0;\n    const angleFilterRawIdx = this.properties.angleFilterKey != null ? dataModel.resolveProcessedDataIndexById(this, `angleFilterRaw`) : void 0;\n    const radiusIdx = this.properties.radiusKey ? dataModel.resolveProcessedDataIndexById(this, `radiusValue`) : void 0;\n    const radiusRawIdx = this.properties.radiusKey ? dataModel.resolveProcessedDataIndexById(this, `radiusRaw`) : void 0;\n    const calloutLabelIdx = this.properties.calloutLabelKey ? dataModel.resolveProcessedDataIndexById(this, `calloutLabelValue`) : void 0;\n    const sectorLabelIdx = this.properties.sectorLabelKey ? dataModel.resolveProcessedDataIndexById(this, `sectorLabelValue`) : void 0;\n    const legendItemIdx = this.properties.legendItemKey ? dataModel.resolveProcessedDataIndexById(this, `legendItemValue`) : void 0;\n    return {\n      angleIdx,\n      angleRawIdx,\n      angleFilterIdx,\n      angleFilterRawIdx,\n      radiusIdx,\n      radiusRawIdx,\n      calloutLabelIdx,\n      sectorLabelIdx,\n      legendItemIdx\n    };\n  }\n  async createNodeData() {\n    const { id: seriesId, processedData, dataModel, angleScale } = this;\n    const { rotation, innerRadiusRatio } = this.properties;\n    if (!this.properties.isValid()) {\n      this.zerosumOuterRing.visible = true;\n      this.zerosumInnerRing.visible = true;\n      return { itemId: seriesId, nodeData: [], labelData: [] };\n    }\n    if (!processedData || !dataModel || processedData.type !== \"ungrouped\")\n      return;\n    const {\n      angleIdx,\n      angleRawIdx,\n      angleFilterIdx,\n      angleFilterRawIdx,\n      radiusIdx,\n      radiusRawIdx,\n      calloutLabelIdx,\n      sectorLabelIdx,\n      legendItemIdx\n    } = this.getProcessedDataIndexes(dataModel);\n    const useFilterAngles = angleFilterRawIdx != null && processedData.data.some(({ values }) => {\n      return values[angleFilterRawIdx] > values[angleRawIdx];\n    });\n    let currentStart = 0;\n    let sum2 = 0;\n    const nodes = [];\n    const phantomNodes = angleFilterRawIdx != null ? [] : void 0;\n    processedData.data.forEach((group, index) => {\n      const { datum, values } = group;\n      const currentValue = useFilterAngles ? values[angleFilterIdx] : values[angleIdx];\n      const crossFilterScale = angleFilterRawIdx != null && !useFilterAngles ? Math.sqrt(values[angleFilterRawIdx] / values[angleRawIdx]) : 1;\n      const startAngle = angleScale.convert(currentStart) + toRadians(rotation);\n      currentStart = currentValue;\n      sum2 += currentValue;\n      const endAngle = angleScale.convert(currentStart) + toRadians(rotation);\n      const span = Math.abs(endAngle - startAngle);\n      const midAngle = startAngle + span / 2;\n      const angleValue = values[angleRawIdx];\n      const radiusRaw = radiusIdx != null ? values[radiusIdx] ?? 1 : 1;\n      const radius = radiusRaw * crossFilterScale;\n      const radiusValue = radiusRawIdx != null ? values[radiusRawIdx] : void 0;\n      const legendItemValue = legendItemIdx != null ? values[legendItemIdx] : void 0;\n      const nodeLabels = this.getLabels(\n        datum,\n        midAngle,\n        span,\n        true,\n        calloutLabelIdx != null ? values[calloutLabelIdx] : void 0,\n        sectorLabelIdx != null ? values[sectorLabelIdx] : void 0,\n        legendItemValue\n      );\n      const sectorFormat = this.getSectorFormat(datum, index, false);\n      const node = {\n        itemId: index,\n        series: this,\n        datum,\n        index,\n        angleValue,\n        midAngle,\n        midCos: Math.cos(midAngle),\n        midSin: Math.sin(midAngle),\n        startAngle,\n        endAngle,\n        radius,\n        innerRadius: Math.max(this.radiusScale.convert(0), 0),\n        outerRadius: Math.max(this.radiusScale.convert(radius), 0),\n        sectorFormat,\n        radiusValue,\n        legendItemValue,\n        enabled: this.seriesItemEnabled[index],\n        focusable: true,\n        ...nodeLabels\n      };\n      nodes.push(node);\n      if (phantomNodes != null) {\n        phantomNodes.push({\n          ...node,\n          radius: 1,\n          innerRadius: Math.max(this.radiusScale.convert(0), 0),\n          outerRadius: Math.max(this.radiusScale.convert(1), 0),\n          focusable: false\n        });\n      }\n    });\n    this.zerosumOuterRing.visible = sum2 === 0;\n    this.zerosumInnerRing.visible = sum2 === 0 && innerRadiusRatio != null && innerRadiusRatio !== 1 && innerRadiusRatio > 0;\n    return {\n      itemId: seriesId,\n      nodeData: nodes,\n      labelData: nodes,\n      phantomNodeData: phantomNodes\n    };\n  }\n  getLabels(datum, midAngle, span, skipDisabled, calloutLabelValue, sectorLabelValue, legendItemValue) {\n    const { calloutLabel, sectorLabel, legendItemKey } = this.properties;\n    const calloutLabelKey = !skipDisabled || calloutLabel.enabled ? this.properties.calloutLabelKey : void 0;\n    const sectorLabelKey = !skipDisabled || sectorLabel.enabled ? this.properties.sectorLabelKey : void 0;\n    if (!calloutLabelKey && !sectorLabelKey && !legendItemKey) {\n      return {};\n    }\n    const labelFormatterParams = {\n      datum,\n      angleKey: this.properties.angleKey,\n      angleName: this.properties.angleName,\n      radiusKey: this.properties.radiusKey,\n      radiusName: this.properties.radiusName,\n      calloutLabelKey: this.properties.calloutLabelKey,\n      calloutLabelName: this.properties.calloutLabelName,\n      sectorLabelKey: this.properties.sectorLabelKey,\n      sectorLabelName: this.properties.sectorLabelName,\n      legendItemKey: this.properties.legendItemKey\n    };\n    const result = {};\n    if (calloutLabelKey && span > toRadians(calloutLabel.minAngle)) {\n      result.calloutLabel = {\n        ...this.getTextAlignment(midAngle),\n        text: this.getLabelText(calloutLabel, {\n          ...labelFormatterParams,\n          value: calloutLabelValue\n        }),\n        hidden: false,\n        collisionTextAlign: void 0,\n        collisionOffsetY: 0,\n        box: void 0\n      };\n    }\n    if (sectorLabelKey) {\n      result.sectorLabel = {\n        text: this.getLabelText(sectorLabel, {\n          ...labelFormatterParams,\n          value: sectorLabelValue\n        })\n      };\n    }\n    if (legendItemKey != null && legendItemValue != null) {\n      result.legendItem = { key: legendItemKey, text: legendItemValue };\n    }\n    return result;\n  }\n  getTextAlignment(midAngle) {\n    const quadrantTextOpts = [\n      { textAlign: \"center\", textBaseline: \"bottom\" },\n      { textAlign: \"left\", textBaseline: \"middle\" },\n      { textAlign: \"center\", textBaseline: \"hanging\" },\n      { textAlign: \"right\", textBaseline: \"middle\" }\n    ];\n    const midAngle180 = normalizeAngle180(midAngle);\n    const quadrantStart = -0.75 * Math.PI;\n    const quadrantOffset = midAngle180 - quadrantStart;\n    const quadrant = Math.floor(quadrantOffset / (Math.PI / 2));\n    const quadrantIndex = mod(quadrant, quadrantTextOpts.length);\n    return quadrantTextOpts[quadrantIndex];\n  }\n  getSectorFormat(datum, formatIndex, highlighted) {\n    const { callbackCache } = this.ctx;\n    const { angleKey, radiusKey, calloutLabelKey, sectorLabelKey, legendItemKey, fills, strokes, itemStyler } = this.properties;\n    const defaultStroke = strokes[formatIndex % strokes.length];\n    const { fill, fillOpacity, stroke, strokeWidth, strokeOpacity, lineDash, lineDashOffset, cornerRadius } = mergeDefaults(\n      highlighted && this.properties.highlightStyle.item,\n      {\n        fill: fills.length > 0 ? fills[formatIndex % fills.length] : void 0,\n        stroke: defaultStroke,\n        strokeWidth: this.getStrokeWidth(this.properties.strokeWidth),\n        strokeOpacity: this.getOpacity()\n      },\n      this.properties\n    );\n    let format;\n    if (itemStyler) {\n      format = callbackCache.call(itemStyler, {\n        datum,\n        angleKey,\n        radiusKey,\n        calloutLabelKey,\n        sectorLabelKey,\n        legendItemKey,\n        fill,\n        fillOpacity,\n        stroke,\n        strokeWidth,\n        strokeOpacity,\n        lineDash,\n        lineDashOffset,\n        cornerRadius,\n        highlighted,\n        seriesId: this.id\n      });\n    }\n    return {\n      fill: format?.fill ?? fill,\n      fillOpacity: format?.fillOpacity ?? fillOpacity,\n      stroke: format?.stroke ?? stroke,\n      strokeWidth: format?.strokeWidth ?? strokeWidth,\n      strokeOpacity: format?.strokeOpacity ?? strokeOpacity,\n      lineDash: format?.lineDash ?? lineDash,\n      lineDashOffset: format?.lineDashOffset ?? lineDashOffset,\n      cornerRadius: format?.cornerRadius ?? cornerRadius\n    };\n  }\n  getInnerRadius() {\n    const { radius } = this;\n    const { innerRadiusRatio = 1, innerRadiusOffset = 0 } = this.properties;\n    const innerRadius = radius * innerRadiusRatio + innerRadiusOffset;\n    if (innerRadius === radius || innerRadius < 0) {\n      return 0;\n    }\n    return innerRadius;\n  }\n  getOuterRadius() {\n    const { outerRadiusRatio, outerRadiusOffset } = this.properties;\n    return Math.max(this.radius * outerRadiusRatio + outerRadiusOffset, 0);\n  }\n  updateRadiusScale(resize) {\n    const newRange = [this.getInnerRadius(), this.getOuterRadius()];\n    this.radiusScale.range = newRange;\n    if (resize) {\n      this.previousRadiusScale.range = newRange;\n    }\n    const setRadii = (d) => ({\n      ...d,\n      innerRadius: Math.max(this.radiusScale.convert(0), 0),\n      outerRadius: Math.max(this.radiusScale.convert(d.radius), 0)\n    });\n    this.nodeData = this.nodeData.map(setRadii);\n    this.phantomNodeData = this.phantomNodeData?.map(setRadii);\n  }\n  getTitleTranslationY() {\n    const outerRadius = Math.max(0, this.radiusScale.range[1]);\n    if (outerRadius === 0) {\n      return NaN;\n    }\n    const spacing = this.properties.title?.spacing ?? 0;\n    const titleOffset = 2 + spacing;\n    const dy = Math.max(0, -outerRadius);\n    return -outerRadius - titleOffset - dy;\n  }\n  async update({ seriesRect }) {\n    const { title } = this.properties;\n    const newNodeDataDependencies = {\n      seriesRectWidth: seriesRect?.width,\n      seriesRectHeight: seriesRect?.height\n    };\n    const resize = jsonDiff(this.nodeDataDependencies, newNodeDataDependencies) != null;\n    if (resize) {\n      this._nodeDataDependencies = newNodeDataDependencies;\n    }\n    await this.maybeRefreshNodeData();\n    this.updateTitleNodes();\n    this.updateRadiusScale(resize);\n    this.contentGroup.translationX = this.centerX;\n    this.contentGroup.translationY = this.centerY;\n    this.highlightGroup.translationX = this.centerX;\n    this.highlightGroup.translationY = this.centerY;\n    this.backgroundGroup.translationX = this.centerX;\n    this.backgroundGroup.translationY = this.centerY;\n    if (this.labelGroup) {\n      this.labelGroup.translationX = this.centerX;\n      this.labelGroup.translationY = this.centerY;\n    }\n    if (title) {\n      const dy = this.getTitleTranslationY();\n      title.node.y = isFinite(dy) ? dy : 0;\n      const titleBox = title.node.getBBox();\n      title.node.visible = title.enabled && isFinite(dy) && !this.bboxIntersectsSurroundingSeries(titleBox);\n    }\n    for (const circle of [this.zerosumInnerRing, this.zerosumOuterRing]) {\n      circle.fillOpacity = 0;\n      circle.stroke = this.properties.calloutLabel.color;\n      circle.strokeWidth = 1;\n      circle.strokeOpacity = 1;\n    }\n    this.updateNodeMidPoint();\n    await this.updateSelections();\n    await this.updateNodes(seriesRect);\n  }\n  updateTitleNodes() {\n    const { oldTitle } = this;\n    const { title } = this.properties;\n    if (oldTitle !== title) {\n      if (oldTitle) {\n        this.labelGroup?.removeChild(oldTitle.node);\n      }\n      if (title) {\n        title.node.textBaseline = \"bottom\";\n        this.labelGroup?.appendChild(title.node);\n      }\n      this.oldTitle = title;\n    }\n  }\n  updateNodeMidPoint() {\n    const setMidPoint = (d) => {\n      const radius = d.innerRadius + (d.outerRadius - d.innerRadius) / 2;\n      d.midPoint = {\n        x: d.midCos * Math.max(0, radius),\n        y: d.midSin * Math.max(0, radius)\n      };\n    };\n    this.nodeData.forEach(setMidPoint);\n    this.phantomNodeData?.forEach(setMidPoint);\n  }\n  async updateSelections() {\n    await this.updateGroupSelection();\n    this.updateInnerCircleSelection();\n  }\n  async updateGroupSelection() {\n    const {\n      itemSelection,\n      highlightSelection,\n      phantomSelection,\n      highlightLabelSelection,\n      calloutLabelSelection,\n      labelSelection,\n      innerLabelsSelection\n    } = this;\n    const highlightedNodeData = this.nodeData.map((datum) => ({\n      ...datum,\n      // Allow mutable sectorFormat, so formatted sector styles can be updated and varied\n      // between normal and highlighted cases.\n      sectorFormat: { ...datum.sectorFormat }\n    }));\n    const update = (selection, nodeData) => {\n      selection.update(nodeData, void 0, (datum) => this.getDatumId(datum));\n      if (this.ctx.animationManager.isSkipped()) {\n        selection.cleanup();\n      }\n    };\n    update(itemSelection, this.nodeData);\n    update(highlightSelection, highlightedNodeData);\n    update(phantomSelection, this.phantomNodeData ?? []);\n    calloutLabelSelection.update(this.calloutNodeData, (group) => {\n      const line = new Line();\n      line.tag = 0 /* Callout */;\n      line.pointerEvents = 1 /* None */;\n      group.appendChild(line);\n      const text = new Text();\n      text.tag = 1 /* Label */;\n      text.pointerEvents = 1 /* None */;\n      group.appendChild(text);\n    });\n    labelSelection.update(this.nodeData);\n    highlightLabelSelection.update(highlightedNodeData);\n    innerLabelsSelection.update(this.properties.innerLabels, (node) => {\n      node.pointerEvents = 1 /* None */;\n    });\n  }\n  updateInnerCircleSelection() {\n    const { innerCircle } = this.properties;\n    let radius = 0;\n    const innerRadius = this.getInnerRadius();\n    if (innerRadius > 0) {\n      const circleRadius = Math.min(innerRadius, this.getOuterRadius());\n      const antiAliasingPadding = 1;\n      radius = Math.ceil(circleRadius * 2 + antiAliasingPadding);\n    }\n    const datums = innerCircle ? [{ radius }] : [];\n    this.innerCircleSelection.update(datums);\n  }\n  async updateNodes(seriesRect) {\n    const highlightedDatum = this.ctx.highlightManager.getActiveHighlight();\n    const isVisible = this.visible && this.seriesItemEnabled.includes(true);\n    this.rootGroup.visible = isVisible;\n    this.backgroundGroup.visible = isVisible;\n    this.contentGroup.visible = isVisible;\n    this.highlightGroup.visible = isVisible && highlightedDatum?.series === this;\n    this.highlightLabel.visible = isVisible && highlightedDatum?.series === this;\n    this.labelGroup.visible = isVisible;\n    this.contentGroup.opacity = this.getOpacity();\n    this.innerCircleSelection.each((node, { radius }) => {\n      node.setProperties({\n        fill: this.properties.innerCircle?.fill,\n        opacity: this.properties.innerCircle?.fillOpacity,\n        size: radius\n      });\n    });\n    const animationDisabled = this.ctx.animationManager.isSkipped();\n    const updateSectorFn = (sector, datum, _index, isDatumHighlighted) => {\n      const format = this.getSectorFormat(datum.datum, datum.itemId, isDatumHighlighted);\n      datum.sectorFormat.fill = format.fill;\n      datum.sectorFormat.stroke = format.stroke;\n      if (animationDisabled) {\n        sector.startAngle = datum.startAngle;\n        sector.endAngle = datum.endAngle;\n        sector.innerRadius = datum.innerRadius;\n        sector.outerRadius = datum.outerRadius;\n      }\n      if (isDatumHighlighted || animationDisabled) {\n        sector.fill = format.fill;\n        sector.stroke = format.stroke;\n      }\n      sector.strokeWidth = format.strokeWidth;\n      sector.fillOpacity = format.fillOpacity;\n      sector.strokeOpacity = format.strokeOpacity;\n      sector.lineDash = format.lineDash;\n      sector.lineDashOffset = format.lineDashOffset;\n      sector.cornerRadius = format.cornerRadius;\n      sector.fillShadow = this.properties.shadow;\n      const inset = Math.max(\n        (this.properties.sectorSpacing + (format.stroke != null ? format.strokeWidth : 0)) / 2,\n        0\n      );\n      sector.inset = inset;\n      sector.lineJoin = this.properties.sectorSpacing >= 0 || inset > 0 ? \"miter\" : \"round\";\n    };\n    this.itemSelection.each((node, datum, index) => updateSectorFn(node, datum, index, false));\n    this.highlightSelection.each((node, datum, index) => {\n      updateSectorFn(node, datum, index, true);\n      node.visible = datum.itemId === highlightedDatum?.itemId;\n    });\n    this.phantomSelection.each((node, datum, index) => updateSectorFn(node, datum, index, false));\n    this.updateCalloutLineNodes();\n    this.updateCalloutLabelNodes(seriesRect);\n    this.updateSectorLabelNodes();\n    this.updateInnerLabelNodes();\n    this.updateZerosumRings();\n    this.animationState.transition(\"update\");\n  }\n  updateCalloutLineNodes() {\n    const { calloutLine } = this.properties;\n    const calloutLength = calloutLine.length;\n    const calloutStrokeWidth = calloutLine.strokeWidth;\n    const calloutColors = calloutLine.colors ?? this.properties.strokes;\n    const { offset: offset4 } = this.properties.calloutLabel;\n    this.calloutLabelSelection.selectByTag(0 /* Callout */).forEach((line, index) => {\n      const datum = line.datum;\n      const { calloutLabel: label, outerRadius } = datum;\n      if (label?.text && !label.hidden && outerRadius !== 0) {\n        line.visible = true;\n        line.strokeWidth = calloutStrokeWidth;\n        line.stroke = calloutColors[index % calloutColors.length];\n        line.fill = void 0;\n        const x1 = datum.midCos * outerRadius;\n        const y1 = datum.midSin * outerRadius;\n        let x2 = datum.midCos * (outerRadius + calloutLength);\n        let y2 = datum.midSin * (outerRadius + calloutLength);\n        const isMoved = label.collisionTextAlign ?? label.collisionOffsetY !== 0;\n        if (isMoved && label.box != null) {\n          const box = label.box;\n          let cx = x2;\n          let cy = y2;\n          if (x2 < box.x) {\n            cx = box.x;\n          } else if (x2 > box.x + box.width) {\n            cx = box.x + box.width;\n          }\n          if (y2 < box.y) {\n            cy = box.y;\n          } else if (y2 > box.y + box.height) {\n            cy = box.y + box.height;\n          }\n          const dx = cx - x2;\n          const dy = cy - y2;\n          const length2 = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n          const paddedLength = length2 - offset4;\n          if (paddedLength > 0) {\n            x2 = x2 + dx * paddedLength / length2;\n            y2 = y2 + dy * paddedLength / length2;\n          }\n        }\n        line.x1 = x1;\n        line.y1 = y1;\n        line.x2 = x2;\n        line.y2 = y2;\n      } else {\n        line.visible = false;\n      }\n    });\n  }\n  getLabelOverflow(text, box, seriesRect) {\n    const seriesLeft = seriesRect.x - this.centerX;\n    const seriesRight = seriesRect.x + seriesRect.width - this.centerX;\n    const seriesTop = seriesRect.y - this.centerY;\n    const seriesBottom = seriesRect.y + seriesRect.height - this.centerY;\n    const errPx = 1;\n    let visibleTextPart = 1;\n    if (box.x + errPx < seriesLeft) {\n      visibleTextPart = (box.x + box.width - seriesLeft) / box.width;\n    } else if (box.x + box.width - errPx > seriesRight) {\n      visibleTextPart = (seriesRight - box.x) / box.width;\n    }\n    const hasVerticalOverflow = box.y + errPx < seriesTop || box.y + box.height - errPx > seriesBottom;\n    const textLength = visibleTextPart === 1 ? text.length : Math.floor(text.length * visibleTextPart) - 1;\n    const hasSurroundingSeriesOverflow = this.bboxIntersectsSurroundingSeries(box);\n    return { textLength, hasVerticalOverflow, hasSurroundingSeriesOverflow };\n  }\n  bboxIntersectsSurroundingSeries(box) {\n    const { surroundingRadius } = this;\n    if (surroundingRadius == null) {\n      return false;\n    }\n    const corners = [\n      { x: box.x, y: box.y },\n      { x: box.x + box.width, y: box.y },\n      { x: box.x + box.width, y: box.y + box.height },\n      { x: box.x, y: box.y + box.height }\n    ];\n    const sur2 = surroundingRadius ** 2;\n    return corners.some((corner) => corner.x ** 2 + corner.y ** 2 > sur2);\n  }\n  computeCalloutLabelCollisionOffsets() {\n    const { radiusScale } = this;\n    const { calloutLabel, calloutLine } = this.properties;\n    const { offset: offset4, minSpacing } = calloutLabel;\n    const innerRadius = radiusScale.convert(0);\n    const shouldSkip = (datum) => {\n      const label = datum.calloutLabel;\n      return !label || datum.outerRadius === 0;\n    };\n    const fullData = this.calloutNodeData;\n    const data = fullData.filter((t) => !shouldSkip(t));\n    data.forEach((datum) => {\n      const label = datum.calloutLabel;\n      if (label == null)\n        return;\n      label.hidden = false;\n      label.collisionTextAlign = void 0;\n      label.collisionOffsetY = 0;\n    });\n    if (data.length <= 1) {\n      return;\n    }\n    const leftLabels = data.filter((d) => d.midCos < 0).sort((a, b) => a.midSin - b.midSin);\n    const rightLabels = data.filter((d) => d.midCos >= 0).sort((a, b) => a.midSin - b.midSin);\n    const topLabels = data.filter((d) => d.midSin < 0 && d.calloutLabel?.textAlign === \"center\").sort((a, b) => a.midCos - b.midCos);\n    const bottomLabels = data.filter((d) => d.midSin >= 0 && d.calloutLabel?.textAlign === \"center\").sort((a, b) => a.midCos - b.midCos);\n    const getTextBBox = (datum) => {\n      const label = datum.calloutLabel;\n      if (label == null)\n        return BBox.zero.clone();\n      const labelRadius = datum.outerRadius + calloutLine.length + offset4;\n      const x = datum.midCos * labelRadius;\n      const y = datum.midSin * labelRadius + label.collisionOffsetY;\n      const textAlign = label.collisionTextAlign ?? label.textAlign;\n      const textBaseline = label.textBaseline;\n      return Text.computeBBox(label.text, x, y, {\n        font: this.properties.calloutLabel,\n        textAlign,\n        textBaseline\n      });\n    };\n    const avoidNeighbourYCollision = (label, next, direction) => {\n      const box = getTextBBox(label).grow(minSpacing / 2);\n      const other = getTextBBox(next).grow(minSpacing / 2);\n      const collidesOrBehind = box.x < other.x + other.width && box.x + box.width > other.x && (direction === \"to-top\" ? box.y < other.y + other.height : box.y + box.height > other.y);\n      if (collidesOrBehind) {\n        const dy = direction === \"to-top\" ? box.y - other.y - other.height : box.y + box.height - other.y;\n        next.calloutLabel.collisionOffsetY = dy;\n      }\n    };\n    const avoidYCollisions = (labels) => {\n      const midLabel = labels.slice().sort((a, b) => Math.abs(a.midSin) - Math.abs(b.midSin))[0];\n      const midIndex = labels.indexOf(midLabel);\n      for (let i = midIndex - 1; i >= 0; i--) {\n        const prev = labels[i + 1];\n        const next = labels[i];\n        avoidNeighbourYCollision(prev, next, \"to-top\");\n      }\n      for (let i = midIndex + 1; i < labels.length; i++) {\n        const prev = labels[i - 1];\n        const next = labels[i];\n        avoidNeighbourYCollision(prev, next, \"to-bottom\");\n      }\n    };\n    const avoidXCollisions = (labels) => {\n      const labelsCollideLabelsByY = data.some((datum) => datum.calloutLabel.collisionOffsetY !== 0);\n      const boxes = labels.map((label) => getTextBBox(label));\n      const paddedBoxes = boxes.map((box) => box.clone().grow(minSpacing / 2));\n      let labelsCollideLabelsByX = false;\n      for (let i = 0; i < paddedBoxes.length && !labelsCollideLabelsByX; i++) {\n        const box = paddedBoxes[i];\n        for (let j = i + 1; j < labels.length; j++) {\n          const other = paddedBoxes[j];\n          if (box.collidesBBox(other)) {\n            labelsCollideLabelsByX = true;\n            break;\n          }\n        }\n      }\n      const sectors = fullData.map((datum) => {\n        const { startAngle, endAngle, outerRadius } = datum;\n        return { startAngle, endAngle, innerRadius, outerRadius };\n      });\n      const labelsCollideSectors = boxes.some((box) => {\n        return sectors.some((sector) => boxCollidesSector(box, sector));\n      });\n      if (!labelsCollideLabelsByX && !labelsCollideLabelsByY && !labelsCollideSectors) {\n        return;\n      }\n      labels.filter((d) => d.calloutLabel.textAlign === \"center\").forEach((d) => {\n        const label = d.calloutLabel;\n        if (d.midCos < 0) {\n          label.collisionTextAlign = \"right\";\n        } else if (d.midCos > 0) {\n          label.collisionTextAlign = \"left\";\n        } else {\n          label.collisionTextAlign = \"center\";\n        }\n      });\n    };\n    avoidYCollisions(leftLabels);\n    avoidYCollisions(rightLabels);\n    avoidXCollisions(topLabels);\n    avoidXCollisions(bottomLabels);\n  }\n  updateCalloutLabelNodes(seriesRect) {\n    const { radiusScale } = this;\n    const { calloutLabel, calloutLine } = this.properties;\n    const calloutLength = calloutLine.length;\n    const { offset: offset4, color } = calloutLabel;\n    const tempTextNode = new Text();\n    this.calloutLabelSelection.selectByTag(1 /* Label */).forEach((text) => {\n      const { datum } = text;\n      const label = datum.calloutLabel;\n      const radius = radiusScale.convert(datum.radius);\n      const outerRadius = Math.max(0, radius);\n      if (!label?.text || outerRadius === 0 || label.hidden) {\n        text.visible = false;\n        return;\n      }\n      const labelRadius = outerRadius + calloutLength + offset4;\n      const x = datum.midCos * labelRadius;\n      const y = datum.midSin * labelRadius + label.collisionOffsetY;\n      const align = {\n        textAlign: label.collisionTextAlign ?? label.textAlign,\n        textBaseline: label.textBaseline\n      };\n      tempTextNode.text = label.text;\n      tempTextNode.x = x;\n      tempTextNode.y = y;\n      tempTextNode.setFont(this.properties.calloutLabel);\n      tempTextNode.setAlign(align);\n      const box = tempTextNode.getBBox();\n      let displayText = label.text;\n      let visible = true;\n      if (calloutLabel.avoidCollisions) {\n        const { textLength, hasVerticalOverflow } = this.getLabelOverflow(label.text, box, seriesRect);\n        displayText = label.text.length === textLength ? label.text : `${label.text.substring(0, textLength)}\\u2026`;\n        visible = !hasVerticalOverflow;\n      }\n      text.text = displayText;\n      text.x = x;\n      text.y = y;\n      text.setFont(this.properties.calloutLabel);\n      text.setAlign(align);\n      text.fill = color;\n      text.visible = visible;\n    });\n  }\n  async computeLabelsBBox(options, seriesRect) {\n    const { calloutLabel, calloutLine } = this.properties;\n    const calloutLength = calloutLine.length;\n    const { offset: offset4, maxCollisionOffset, minSpacing } = calloutLabel;\n    if (!calloutLabel.avoidCollisions) {\n      return null;\n    }\n    await this.maybeRefreshNodeData();\n    this.updateRadiusScale(false);\n    this.computeCalloutLabelCollisionOffsets();\n    const textBoxes = [];\n    const text = new Text();\n    let titleBox;\n    const { title } = this.properties;\n    if (title?.text && title.enabled) {\n      const dy = this.getTitleTranslationY();\n      if (isFinite(dy)) {\n        text.text = title.text;\n        text.x = 0;\n        text.y = dy;\n        text.setFont(title);\n        text.setAlign({\n          textBaseline: \"bottom\",\n          textAlign: \"center\"\n        });\n        titleBox = text.getBBox();\n        textBoxes.push(titleBox);\n      }\n    }\n    this.calloutNodeData.forEach((datum) => {\n      const label = datum.calloutLabel;\n      if (!label || datum.outerRadius === 0) {\n        return null;\n      }\n      const labelRadius = datum.outerRadius + calloutLength + offset4;\n      const x = datum.midCos * labelRadius;\n      const y = datum.midSin * labelRadius + label.collisionOffsetY;\n      text.text = label.text;\n      text.x = x;\n      text.y = y;\n      text.setFont(this.properties.calloutLabel);\n      text.setAlign({\n        textAlign: label.collisionTextAlign ?? label.textAlign,\n        textBaseline: label.textBaseline\n      });\n      const box = text.getBBox();\n      label.box = box;\n      if (Math.abs(label.collisionOffsetY) > maxCollisionOffset) {\n        label.hidden = true;\n        return;\n      }\n      if (titleBox) {\n        const seriesTop = seriesRect.y - this.centerY;\n        const titleCleanArea = new BBox(\n          titleBox.x - minSpacing,\n          seriesTop,\n          titleBox.width + 2 * minSpacing,\n          titleBox.y + titleBox.height + minSpacing - seriesTop\n        );\n        if (box.collidesBBox(titleCleanArea)) {\n          label.hidden = true;\n          return;\n        }\n      }\n      if (options.hideWhenNecessary) {\n        const { textLength, hasVerticalOverflow, hasSurroundingSeriesOverflow } = this.getLabelOverflow(\n          label.text,\n          box,\n          seriesRect\n        );\n        const isTooShort = label.text.length > 2 && textLength < 2;\n        if (hasVerticalOverflow || isTooShort || hasSurroundingSeriesOverflow) {\n          label.hidden = true;\n          return;\n        }\n      }\n      label.hidden = false;\n      textBoxes.push(box);\n    });\n    if (textBoxes.length === 0) {\n      return null;\n    }\n    return BBox.merge(textBoxes);\n  }\n  updateSectorLabelNodes() {\n    const { radiusScale } = this;\n    const innerRadius = radiusScale.convert(0);\n    const { fontSize, fontStyle, fontWeight, fontFamily, positionOffset, positionRatio, color } = this.properties.sectorLabel;\n    const updateSectorLabel = (text, datum) => {\n      const { sectorLabel, outerRadius } = datum;\n      let isTextVisible = false;\n      if (sectorLabel && outerRadius !== 0) {\n        const labelRadius = innerRadius * (1 - positionRatio) + outerRadius * positionRatio + positionOffset;\n        text.fill = color;\n        text.fontStyle = fontStyle;\n        text.fontWeight = fontWeight;\n        text.fontSize = fontSize;\n        text.fontFamily = fontFamily;\n        text.text = sectorLabel.text;\n        text.x = datum.midCos * labelRadius;\n        text.y = datum.midSin * labelRadius;\n        text.textAlign = \"center\";\n        text.textBaseline = \"middle\";\n        const bbox = text.getBBox();\n        const corners = [\n          [bbox.x, bbox.y],\n          [bbox.x + bbox.width, bbox.y],\n          [bbox.x + bbox.width, bbox.y + bbox.height],\n          [bbox.x, bbox.y + bbox.height]\n        ];\n        const { startAngle, endAngle } = datum;\n        const sectorBounds = { startAngle, endAngle, innerRadius, outerRadius };\n        if (corners.every(([x, y]) => isPointInSector(x, y, sectorBounds))) {\n          isTextVisible = true;\n        }\n      }\n      text.visible = isTextVisible;\n    };\n    this.labelSelection.each(updateSectorLabel);\n    this.highlightLabelSelection.each(updateSectorLabel);\n  }\n  updateInnerLabelNodes() {\n    const textBBoxes = [];\n    const margins = [];\n    this.innerLabelsSelection.each((text, datum) => {\n      const { fontStyle, fontWeight, fontSize, fontFamily, color } = datum;\n      text.fontStyle = fontStyle;\n      text.fontWeight = fontWeight;\n      text.fontSize = fontSize;\n      text.fontFamily = fontFamily;\n      text.text = datum.text;\n      text.x = 0;\n      text.y = 0;\n      text.fill = color;\n      text.textAlign = \"center\";\n      text.textBaseline = \"alphabetic\";\n      textBBoxes.push(text.getBBox());\n      margins.push(datum.spacing);\n    });\n    const getMarginTop = (index) => index === 0 ? 0 : margins[index];\n    const getMarginBottom = (index) => index === margins.length - 1 ? 0 : margins[index];\n    const totalHeight = textBBoxes.reduce((sum2, bbox, i) => {\n      return sum2 + bbox.height + getMarginTop(i) + getMarginBottom(i);\n    }, 0);\n    const totalWidth = Math.max(...textBBoxes.map((bbox) => bbox.width));\n    const innerRadius = this.getInnerRadius();\n    const labelRadius = Math.sqrt(Math.pow(totalWidth / 2, 2) + Math.pow(totalHeight / 2, 2));\n    const labelsVisible = labelRadius <= (innerRadius > 0 ? innerRadius : this.getOuterRadius());\n    const textBottoms = [];\n    for (let i = 0, prev = -totalHeight / 2; i < textBBoxes.length; i++) {\n      const bbox = textBBoxes[i];\n      const bottom = bbox.height + prev + getMarginTop(i);\n      textBottoms.push(bottom);\n      prev = bottom + getMarginBottom(i);\n    }\n    this.innerLabelsSelection.each((text, _datum, index) => {\n      text.y = textBottoms[index];\n      text.visible = labelsVisible;\n    });\n  }\n  updateZerosumRings() {\n    this.zerosumOuterRing.size = this.getOuterRadius() * 2;\n    this.zerosumInnerRing.size = this.getInnerRadius() * 2;\n  }\n  getDatumLegendName(nodeDatum) {\n    const { angleKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;\n    const { sectorLabel, calloutLabel, legendItem } = nodeDatum;\n    if (legendItemKey && legendItem !== void 0) {\n      return legendItem.text;\n    } else if (calloutLabelKey && calloutLabelKey !== angleKey && calloutLabel?.text !== void 0) {\n      return calloutLabel.text;\n    } else if (sectorLabelKey && sectorLabelKey !== angleKey && sectorLabel?.text !== void 0) {\n      return sectorLabel.text;\n    }\n  }\n  pickNodeClosestDatum(point) {\n    return pickByMatchingAngle(this, point);\n  }\n  getTooltipHtml(nodeDatum) {\n    if (!this.properties.isValid()) {\n      return EMPTY_TOOLTIP_CONTENT;\n    }\n    const {\n      datum,\n      angleValue,\n      sectorFormat: { fill: color },\n      itemId\n    } = nodeDatum;\n    const title = sanitizeHtml(this.properties.title?.text);\n    const content = isFiniteNumber(angleValue) ? toFixed(angleValue) : String(angleValue);\n    const labelText = this.getDatumLegendName(nodeDatum);\n    return this.properties.tooltip.toTooltipHtml(\n      {\n        title: title ?? labelText,\n        content: title && labelText ? `${labelText}: ${content}` : content,\n        backgroundColor: color\n      },\n      {\n        datum,\n        itemId,\n        title,\n        color,\n        seriesId: this.id,\n        angleKey: this.properties.angleKey,\n        angleName: this.properties.angleName,\n        radiusKey: this.properties.radiusKey,\n        radiusName: this.properties.radiusName,\n        calloutLabelKey: this.properties.calloutLabelKey,\n        calloutLabelName: this.properties.calloutLabelName,\n        sectorLabelKey: this.properties.sectorLabelKey,\n        sectorLabelName: this.properties.sectorLabelName,\n        legendItemKey: this.properties.legendItemKey\n      }\n    );\n  }\n  getLegendData(legendType) {\n    const { visible, processedData, dataModel } = this;\n    if (!dataModel || !processedData?.data.length || !this.properties.isValid() || legendType !== \"category\") {\n      return [];\n    }\n    const { angleKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;\n    if (!legendItemKey && (!calloutLabelKey || calloutLabelKey === angleKey) && (!sectorLabelKey || sectorLabelKey === angleKey))\n      return [];\n    const { calloutLabelIdx, sectorLabelIdx, legendItemIdx } = this.getProcessedDataIndexes(dataModel);\n    const titleText = this.properties.title?.showInLegend && this.properties.title.text;\n    const legendData = [];\n    for (let index = 0; index < processedData.data.length; index++) {\n      const { datum, values } = processedData.data[index];\n      const labelParts = [];\n      if (titleText) {\n        labelParts.push(titleText);\n      }\n      const labels = this.getLabels(\n        datum,\n        2 * Math.PI,\n        2 * Math.PI,\n        false,\n        calloutLabelIdx != null ? values[calloutLabelIdx] : void 0,\n        sectorLabelIdx != null ? values[sectorLabelIdx] : void 0,\n        legendItemIdx != null ? values[legendItemIdx] : void 0\n      );\n      if (legendItemKey && labels.legendItem !== void 0) {\n        labelParts.push(labels.legendItem.text);\n      } else if (calloutLabelKey && calloutLabelKey !== angleKey && labels.calloutLabel?.text !== void 0) {\n        labelParts.push(labels.calloutLabel?.text);\n      } else if (sectorLabelKey && sectorLabelKey !== angleKey && labels.sectorLabel?.text !== void 0) {\n        labelParts.push(labels.sectorLabel?.text);\n      }\n      if (labelParts.length === 0)\n        continue;\n      const sectorFormat = this.getSectorFormat(datum, index, false);\n      legendData.push({\n        legendType: \"category\",\n        id: this.id,\n        itemId: index,\n        seriesId: this.id,\n        enabled: visible && this.legendItemEnabled[index],\n        label: {\n          text: labelParts.join(\" - \")\n        },\n        symbols: [\n          {\n            marker: {\n              fill: sectorFormat.fill,\n              stroke: sectorFormat.stroke,\n              fillOpacity: this.properties.fillOpacity,\n              strokeOpacity: this.properties.strokeOpacity,\n              strokeWidth: this.properties.strokeWidth\n            }\n          }\n        ],\n        legendItemName: legendItemKey != null ? datum[legendItemKey] : void 0\n      });\n    }\n    return legendData;\n  }\n  onLegendItemClick(event) {\n    const { enabled, itemId, series, legendItemName } = event;\n    if (series.id === this.id) {\n      this.toggleSeriesItem(itemId, enabled);\n    } else if (legendItemName != null) {\n      this.toggleOtherSeriesItems(legendItemName, enabled);\n    }\n  }\n  toggleSeriesItem(itemId, enabled) {\n    this.seriesItemEnabled[itemId] = enabled;\n    this.legendItemEnabled[itemId] = enabled;\n    if (this.nodeData[itemId]) {\n      this.nodeData[itemId].enabled = enabled;\n    }\n    this.nodeDataRefresh = true;\n  }\n  // Used for grid\n  setLegendState(enabledItems) {\n    this.legendItemEnabled = enabledItems;\n    this.ctx.updateService.update(4 /* SERIES_UPDATE */);\n  }\n  toggleOtherSeriesItems(legendItemName, enabled) {\n    if (!this.properties.legendItemKey || !this.dataModel) {\n      return;\n    }\n    const legendItemIdx = this.dataModel.resolveProcessedDataIndexById(this, `legendItemValue`);\n    this.processedData?.data.forEach(({ values }, datumItemId) => {\n      if (values[legendItemIdx] === legendItemName) {\n        this.toggleSeriesItem(datumItemId, enabled);\n      }\n    });\n  }\n  animateEmptyUpdateReady(_data) {\n    const { animationManager } = this.ctx;\n    const fns = preparePieSeriesAnimationFunctions(\n      true,\n      this.properties.rotation,\n      this.radiusScale,\n      this.previousRadiusScale\n    );\n    fromToMotion(\n      this.id,\n      \"nodes\",\n      animationManager,\n      [this.itemSelection, this.highlightSelection, this.phantomSelection],\n      fns.nodes,\n      (_, datum) => this.getDatumId(datum)\n    );\n    fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);\n    seriesLabelFadeInAnimation(this, \"callout\", animationManager, this.calloutLabelSelection);\n    seriesLabelFadeInAnimation(this, \"sector\", animationManager, this.labelSelection);\n    seriesLabelFadeInAnimation(this, \"highlight\", animationManager, this.highlightLabelSelection);\n    seriesLabelFadeInAnimation(this, \"inner\", animationManager, this.innerLabelsSelection);\n    this.previousRadiusScale.range = this.radiusScale.range;\n  }\n  animateWaitingUpdateReady() {\n    const { itemSelection, highlightSelection, phantomSelection, processedData, radiusScale, previousRadiusScale } = this;\n    const { animationManager } = this.ctx;\n    const dataDiff = processedData?.reduced?.diff;\n    this.ctx.animationManager.stopByAnimationGroupId(this.id);\n    const supportedDiff = (dataDiff?.moved.size ?? 0) === 0;\n    const hasKeys = (processedData?.defs.keys.length ?? 0) > 0;\n    const hasUniqueKeys = processedData?.reduced?.animationValidation?.uniqueKeys ?? true;\n    if (!supportedDiff || !hasKeys || !hasUniqueKeys) {\n      this.ctx.animationManager.skipCurrentBatch();\n    }\n    const fns = preparePieSeriesAnimationFunctions(\n      false,\n      this.properties.rotation,\n      radiusScale,\n      previousRadiusScale\n    );\n    fromToMotion(\n      this.id,\n      \"nodes\",\n      animationManager,\n      [itemSelection, highlightSelection, phantomSelection],\n      fns.nodes,\n      (_, datum) => this.getDatumId(datum),\n      dataDiff\n    );\n    fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);\n    seriesLabelFadeInAnimation(this, \"callout\", this.ctx.animationManager, this.calloutLabelSelection);\n    seriesLabelFadeInAnimation(this, \"sector\", this.ctx.animationManager, this.labelSelection);\n    seriesLabelFadeInAnimation(this, \"highlight\", this.ctx.animationManager, this.highlightLabelSelection);\n    seriesLabelFadeInAnimation(this, \"inner\", this.ctx.animationManager, this.innerLabelsSelection);\n    this.previousRadiusScale.range = this.radiusScale.range;\n  }\n  animateClearingUpdateEmpty() {\n    const { itemSelection, highlightSelection, phantomSelection, radiusScale, previousRadiusScale } = this;\n    const { animationManager } = this.ctx;\n    const fns = preparePieSeriesAnimationFunctions(\n      false,\n      this.properties.rotation,\n      radiusScale,\n      previousRadiusScale\n    );\n    fromToMotion(\n      this.id,\n      \"nodes\",\n      animationManager,\n      [itemSelection, highlightSelection, phantomSelection],\n      fns.nodes,\n      (_, datum) => this.getDatumId(datum)\n    );\n    fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);\n    seriesLabelFadeOutAnimation(this, \"callout\", this.ctx.animationManager, this.calloutLabelSelection);\n    seriesLabelFadeOutAnimation(this, \"sector\", this.ctx.animationManager, this.labelSelection);\n    seriesLabelFadeOutAnimation(this, \"highlight\", this.ctx.animationManager, this.highlightLabelSelection);\n    seriesLabelFadeOutAnimation(this, \"inner\", this.ctx.animationManager, this.innerLabelsSelection);\n    this.previousRadiusScale.range = this.radiusScale.range;\n  }\n  getDatumIdFromData(datum) {\n    const { calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;\n    if (!this.processedData?.reduced?.animationValidation?.uniqueKeys) {\n      return;\n    }\n    if (legendItemKey) {\n      return datum[legendItemKey];\n    } else if (calloutLabelKey) {\n      return datum[calloutLabelKey];\n    } else if (sectorLabelKey) {\n      return datum[sectorLabelKey];\n    }\n  }\n  getDatumId(datum) {\n    const { index } = datum;\n    const datumId = this.getDatumIdFromData(datum.datum);\n    return datumId != null ? String(datumId) : `${index}`;\n  }\n  onDataChange() {\n    const { data, seriesItemEnabled, legendItemEnabled } = this;\n    this.seriesItemEnabled = data?.map((_, index) => seriesItemEnabled[index] ?? true) ?? [];\n    this.legendItemEnabled = data?.map((_, index) => legendItemEnabled[index] ?? true) ?? [];\n  }\n};\nDonutSeries.className = \"DonutSeries\";\nDonutSeries.type = \"donut\";\n\n// packages/ag-charts-community/src/chart/series/polar/donutTheme.ts\nvar donutTheme = {\n  series: {\n    title: {\n      enabled: true,\n      fontWeight: \"normal\" /* NORMAL */,\n      fontSize: 14,\n      fontFamily: DEFAULT_FONT_FAMILY,\n      color: DEFAULT_MUTED_LABEL_COLOUR,\n      spacing: 5\n    },\n    calloutLabel: {\n      enabled: true,\n      fontSize: 12 /* SMALL */,\n      fontFamily: DEFAULT_FONT_FAMILY,\n      color: DEFAULT_LABEL_COLOUR,\n      offset: 3,\n      minAngle: 0\n    },\n    sectorLabel: {\n      enabled: true,\n      fontWeight: \"normal\" /* NORMAL */,\n      fontSize: 12 /* SMALL */,\n      fontFamily: DEFAULT_FONT_FAMILY,\n      color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR,\n      positionOffset: 0,\n      positionRatio: 0.5\n    },\n    calloutLine: {\n      length: 10,\n      strokeWidth: 2\n    },\n    fillOpacity: 1,\n    strokeOpacity: 1,\n    strokeWidth: 0,\n    lineDash: [0],\n    lineDashOffset: 0,\n    rotation: 0,\n    sectorSpacing: 1,\n    shadow: {\n      enabled: false,\n      color: DEFAULT_SHADOW_COLOUR,\n      xOffset: 3,\n      yOffset: 3,\n      blur: 5\n    },\n    innerLabels: {\n      fontSize: 12 /* SMALL */,\n      fontFamily: DEFAULT_FONT_FAMILY,\n      color: DEFAULT_LABEL_COLOUR,\n      spacing: 2\n    }\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/polar/pieTheme.ts\nvar pieTheme = {\n  series: {\n    title: {\n      enabled: true,\n      fontWeight: \"normal\" /* NORMAL */,\n      fontSize: 14,\n      fontFamily: DEFAULT_FONT_FAMILY,\n      color: DEFAULT_MUTED_LABEL_COLOUR,\n      spacing: 5\n    },\n    calloutLabel: {\n      enabled: true,\n      fontSize: 12 /* SMALL */,\n      fontFamily: DEFAULT_FONT_FAMILY,\n      color: DEFAULT_LABEL_COLOUR,\n      offset: 3,\n      minAngle: 0\n    },\n    sectorLabel: {\n      enabled: true,\n      fontWeight: \"normal\" /* NORMAL */,\n      fontSize: 12 /* SMALL */,\n      fontFamily: DEFAULT_FONT_FAMILY,\n      color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR,\n      positionOffset: 0,\n      positionRatio: 0.5\n    },\n    calloutLine: {\n      length: 10,\n      strokeWidth: 2\n    },\n    fillOpacity: 1,\n    strokeOpacity: 1,\n    strokeWidth: 0,\n    lineDash: [0],\n    lineDashOffset: 0,\n    rotation: 0,\n    sectorSpacing: 1,\n    shadow: {\n      enabled: false,\n      color: DEFAULT_SHADOW_COLOUR,\n      xOffset: 3,\n      yOffset: 3,\n      blur: 5\n    }\n  }\n};\nvar piePaletteFactory = ({ takeColors, colorsCount }) => {\n  const { fills, strokes } = takeColors(colorsCount);\n  return { fills, strokes, calloutLine: { colors: strokes } };\n};\n\n// packages/ag-charts-community/src/chart/series/polar/donutSeriesModule.ts\nvar DonutSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"polar\"],\n  identifier: \"donut\",\n  moduleFactory: (ctx) => new DonutSeries(ctx),\n  tooltipDefaults: { range: \"exact\" },\n  themeTemplate: donutTheme,\n  paletteFactory: piePaletteFactory\n};\n\n// packages/ag-charts-community/src/chart/series/polar/pieSeriesProperties.ts\nvar PieTitle = class extends Caption {\n  constructor() {\n    super(...arguments);\n    this.showInLegend = false;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], PieTitle.prototype, \"showInLegend\", 2);\nvar PieSeriesCalloutLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.offset = 3;\n    this.minAngle = 0;\n    this.minSpacing = 4;\n    this.maxCollisionOffset = 50;\n    this.avoidCollisions = true;\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesCalloutLabel.prototype, \"offset\", 2);\n__decorateClass([\n  Validate(DEGREE)\n], PieSeriesCalloutLabel.prototype, \"minAngle\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesCalloutLabel.prototype, \"minSpacing\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesCalloutLabel.prototype, \"maxCollisionOffset\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], PieSeriesCalloutLabel.prototype, \"avoidCollisions\", 2);\nvar PieSeriesSectorLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.positionOffset = 0;\n    this.positionRatio = 0.5;\n  }\n};\n__decorateClass([\n  Validate(NUMBER)\n], PieSeriesSectorLabel.prototype, \"positionOffset\", 2);\n__decorateClass([\n  Validate(RATIO)\n], PieSeriesSectorLabel.prototype, \"positionRatio\", 2);\nvar PieSeriesCalloutLine = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.length = 10;\n    this.strokeWidth = 1;\n  }\n};\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY, { optional: true })\n], PieSeriesCalloutLine.prototype, \"colors\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesCalloutLine.prototype, \"length\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesCalloutLine.prototype, \"strokeWidth\", 2);\nvar PieSeriesProperties = class extends SeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.fills = Object.values(DEFAULT_FILLS);\n    this.strokes = Object.values(DEFAULT_STROKES);\n    this.fillOpacity = 1;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.cornerRadius = 0;\n    this.rotation = 0;\n    this.outerRadiusOffset = 0;\n    this.outerRadiusRatio = 1;\n    this.strokeWidth = 1;\n    this.sectorSpacing = 0;\n    this.title = new PieTitle();\n    this.shadow = new DropShadow();\n    this.calloutLabel = new PieSeriesCalloutLabel();\n    this.sectorLabel = new PieSeriesSectorLabel();\n    this.calloutLine = new PieSeriesCalloutLine();\n    this.tooltip = new SeriesTooltip();\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], PieSeriesProperties.prototype, \"angleKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"angleName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"angleFilterKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"radiusKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"radiusName\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], PieSeriesProperties.prototype, \"radiusMin\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], PieSeriesProperties.prototype, \"radiusMax\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"calloutLabelKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"calloutLabelName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"sectorLabelKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"sectorLabelName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"legendItemKey\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], PieSeriesProperties.prototype, \"fills\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], PieSeriesProperties.prototype, \"strokes\", 2);\n__decorateClass([\n  Validate(RATIO)\n], PieSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(RATIO)\n], PieSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH)\n], PieSeriesProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesProperties.prototype, \"cornerRadius\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], PieSeriesProperties.prototype, \"itemStyler\", 2);\n__decorateClass([\n  Validate(DEGREE)\n], PieSeriesProperties.prototype, \"rotation\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], PieSeriesProperties.prototype, \"outerRadiusOffset\", 2);\n__decorateClass([\n  Validate(RATIO)\n], PieSeriesProperties.prototype, \"outerRadiusRatio\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], PieSeriesProperties.prototype, \"sectorSpacing\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], PieSeriesProperties.prototype, \"title\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], PieSeriesProperties.prototype, \"shadow\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], PieSeriesProperties.prototype, \"calloutLabel\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], PieSeriesProperties.prototype, \"sectorLabel\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], PieSeriesProperties.prototype, \"calloutLine\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], PieSeriesProperties.prototype, \"tooltip\", 2);\n\n// packages/ag-charts-community/src/chart/series/polar/pieSeries.ts\nvar PieSeriesNodeEvent = class extends SeriesNodeEvent {\n  constructor(type, nativeEvent, datum, series) {\n    super(type, nativeEvent, datum, series);\n    this.angleKey = series.properties.angleKey;\n    this.radiusKey = series.properties.radiusKey;\n    this.calloutLabelKey = series.properties.calloutLabelKey;\n    this.sectorLabelKey = series.properties.sectorLabelKey;\n  }\n};\nvar PieSeries = class extends PolarSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      pickModes: [1 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */],\n      useLabelLayer: true,\n      animationResetFns: { item: resetPieSelectionsFn, label: resetLabelFn }\n    });\n    this.properties = new PieSeriesProperties();\n    this.phantomNodeData = void 0;\n    this.previousRadiusScale = new LinearScale();\n    this.radiusScale = new LinearScale();\n    this.phantomGroup = this.contentGroup.appendChild(new Group());\n    this.phantomSelection = Selection.select(\n      this.phantomGroup,\n      () => this.nodeFactory(),\n      false\n    );\n    this.calloutLabelGroup = this.contentGroup.appendChild(new Group({ name: \"pieCalloutLabels\" }));\n    this.calloutLabelSelection = new Selection(\n      this.calloutLabelGroup,\n      Group\n    );\n    // The group node that contains the background graphics.\n    this.backgroundGroup = this.rootGroup.appendChild(\n      new TranslatableLayer({\n        name: `${this.id}-background`,\n        zIndex: 0 /* SERIES_BACKGROUND */\n      })\n    );\n    // AG-6193 If the sum of all datums is 0, then we'll draw 1 or 2 rings to represent the empty series.\n    this.zerosumRingsGroup = this.backgroundGroup.appendChild(new Group({ name: `${this.id}-zerosumRings` }));\n    this.zerosumOuterRing = this.zerosumRingsGroup.appendChild(new Circle());\n    // When a user toggles a series item (e.g. from the legend), its boolean state is recorded here.\n    this.seriesItemEnabled = [];\n    this.legendItemEnabled = [];\n    this.surroundingRadius = void 0;\n    this.NodeEvent = PieSeriesNodeEvent;\n    this.angleScale = new LinearScale();\n    this.angleScale.domain = [0, 1];\n    this.angleScale.range = [-Math.PI, Math.PI].map((angle2) => angle2 + Math.PI / 2);\n    this.phantomGroup.opacity = 0.2;\n    this.phantomGroup.zIndexSubOrder = [() => this._declarationOrder, 0];\n  }\n  get calloutNodeData() {\n    return this.phantomNodeData ?? this.nodeData;\n  }\n  addChartEventListeners() {\n    this.destroyFns.push(\n      this.ctx.chartEventManager?.addListener(\"legend-item-click\", (event) => this.onLegendItemClick(event))\n    );\n  }\n  get visible() {\n    return super.visible && (this.seriesItemEnabled.length === 0 || this.seriesItemEnabled.includes(true));\n  }\n  nodeFactory() {\n    const sector = new Sector();\n    sector.miterLimit = 1e9;\n    return sector;\n  }\n  getSeriesDomain(direction) {\n    if (direction === \"x\" /* X */) {\n      return this.angleScale.domain;\n    } else {\n      return this.radiusScale.domain;\n    }\n  }\n  async processData(dataController) {\n    if (this.data == null || !this.properties.isValid()) {\n      return;\n    }\n    let { data } = this;\n    const { visible, seriesItemEnabled } = this;\n    const { angleKey, angleFilterKey, radiusKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    const extraKeyProps = [];\n    const extraProps = [];\n    if (legendItemKey) {\n      extraKeyProps.push(keyProperty(legendItemKey, \"band\", { id: `legendItemKey` }));\n    } else if (calloutLabelKey) {\n      extraKeyProps.push(keyProperty(calloutLabelKey, \"band\", { id: `calloutLabelKey` }));\n    } else if (sectorLabelKey) {\n      extraKeyProps.push(keyProperty(sectorLabelKey, \"band\", { id: `sectorLabelKey` }));\n    }\n    const radiusScaleType = this.radiusScale.type;\n    const angleScaleType = this.radiusScale.type;\n    if (radiusKey) {\n      extraProps.push(\n        rangedValueProperty(radiusKey, {\n          id: \"radiusValue\",\n          min: this.properties.radiusMin ?? 0,\n          max: this.properties.radiusMax\n        }),\n        valueProperty(radiusKey, radiusScaleType, { id: `radiusRaw` }),\n        // Raw value pass-through.\n        normalisePropertyTo(\"radiusValue\", [0, 1], 1, this.properties.radiusMin ?? 0, this.properties.radiusMax)\n      );\n    }\n    if (calloutLabelKey) {\n      extraProps.push(valueProperty(calloutLabelKey, \"band\", { id: `calloutLabelValue` }));\n    }\n    if (sectorLabelKey) {\n      extraProps.push(valueProperty(sectorLabelKey, \"band\", { id: `sectorLabelValue` }));\n    }\n    if (legendItemKey) {\n      extraProps.push(valueProperty(legendItemKey, \"band\", { id: `legendItemValue` }));\n    }\n    if (angleFilterKey) {\n      extraProps.push(\n        accumulativeValueProperty(angleFilterKey, angleScaleType, {\n          id: `angleFilterValue`,\n          onlyPositive: true\n        }),\n        valueProperty(angleFilterKey, angleScaleType, { id: `angleFilterRaw` }),\n        normalisePropertyTo(\"angleFilterValue\", [0, 1], 0, 0)\n      );\n    }\n    if (animationEnabled && this.processedData?.reduced?.animationValidation?.uniqueKeys && extraKeyProps.length > 0) {\n      extraProps.push(diff(this.processedData));\n    }\n    extraProps.push(animationValidation());\n    data = data.map((d, idx) => visible && seriesItemEnabled[idx] ? d : { ...d, [angleKey]: 0 });\n    await this.requestDataModel(dataController, data, {\n      props: [\n        ...extraKeyProps,\n        accumulativeValueProperty(angleKey, angleScaleType, { id: `angleValue`, onlyPositive: true }),\n        valueProperty(angleKey, angleScaleType, { id: `angleRaw` }),\n        // Raw value pass-through.\n        normalisePropertyTo(\"angleValue\", [0, 1], 0, 0),\n        ...extraProps\n      ]\n    });\n    for (const valueDef of this.processedData?.defs?.values ?? []) {\n      const { id, missing, property } = valueDef;\n      const missCount = getMissCount(this, missing);\n      if (id !== \"angleRaw\" && missCount > 0) {\n        Logger.warnOnce(\n          `no value was found for the key '${String(property)}' on ${missCount} data element${missCount > 1 ? \"s\" : \"\"}`\n        );\n      }\n    }\n    this.animationState.transition(\"updateData\");\n  }\n  async maybeRefreshNodeData() {\n    if (!this.nodeDataRefresh)\n      return;\n    const { nodeData = [], phantomNodeData } = await this.createNodeData() ?? {};\n    this.nodeData = nodeData;\n    this.phantomNodeData = phantomNodeData;\n    this.nodeDataRefresh = false;\n  }\n  getProcessedDataIndexes(dataModel) {\n    const angleIdx = dataModel.resolveProcessedDataIndexById(this, `angleValue`);\n    const angleRawIdx = dataModel.resolveProcessedDataIndexById(this, `angleRaw`);\n    const angleFilterIdx = this.properties.angleFilterKey != null ? dataModel.resolveProcessedDataIndexById(this, `angleFilterValue`) : void 0;\n    const angleFilterRawIdx = this.properties.angleFilterKey != null ? dataModel.resolveProcessedDataIndexById(this, `angleFilterRaw`) : void 0;\n    const radiusIdx = this.properties.radiusKey ? dataModel.resolveProcessedDataIndexById(this, `radiusValue`) : void 0;\n    const radiusRawIdx = this.properties.radiusKey ? dataModel.resolveProcessedDataIndexById(this, `radiusRaw`) : void 0;\n    const calloutLabelIdx = this.properties.calloutLabelKey ? dataModel.resolveProcessedDataIndexById(this, `calloutLabelValue`) : void 0;\n    const sectorLabelIdx = this.properties.sectorLabelKey ? dataModel.resolveProcessedDataIndexById(this, `sectorLabelValue`) : void 0;\n    const legendItemIdx = this.properties.legendItemKey ? dataModel.resolveProcessedDataIndexById(this, `legendItemValue`) : void 0;\n    return {\n      angleIdx,\n      angleRawIdx,\n      angleFilterIdx,\n      angleFilterRawIdx,\n      radiusIdx,\n      radiusRawIdx,\n      calloutLabelIdx,\n      sectorLabelIdx,\n      legendItemIdx\n    };\n  }\n  async createNodeData() {\n    const { id: seriesId, processedData, dataModel, angleScale } = this;\n    const { rotation } = this.properties;\n    if (!processedData || !dataModel || processedData.type !== \"ungrouped\")\n      return;\n    const {\n      angleIdx,\n      angleRawIdx,\n      angleFilterIdx,\n      angleFilterRawIdx,\n      radiusIdx,\n      radiusRawIdx,\n      calloutLabelIdx,\n      sectorLabelIdx,\n      legendItemIdx\n    } = this.getProcessedDataIndexes(dataModel);\n    const useFilterAngles = angleFilterRawIdx != null && processedData.data.some(({ values }) => {\n      return values[angleFilterRawIdx] > values[angleRawIdx];\n    });\n    let currentStart = 0;\n    let sum2 = 0;\n    const nodes = [];\n    const phantomNodes = angleFilterRawIdx != null ? [] : void 0;\n    processedData.data.forEach((group, index) => {\n      const { datum, values } = group;\n      const currentValue = useFilterAngles ? values[angleFilterIdx] : values[angleIdx];\n      const crossFilterScale = angleFilterRawIdx != null && !useFilterAngles ? Math.sqrt(values[angleFilterRawIdx] / values[angleRawIdx]) : 1;\n      const startAngle = angleScale.convert(currentStart) + toRadians(rotation);\n      currentStart = currentValue;\n      sum2 += currentValue;\n      const endAngle = angleScale.convert(currentStart) + toRadians(rotation);\n      const span = Math.abs(endAngle - startAngle);\n      const midAngle = startAngle + span / 2;\n      const angleValue = values[angleRawIdx];\n      const radiusRaw = radiusIdx != null ? values[radiusIdx] ?? 1 : 1;\n      const radius = radiusRaw * crossFilterScale;\n      const radiusValue = radiusRawIdx != null ? values[radiusRawIdx] : void 0;\n      const legendItemValue = legendItemIdx != null ? values[legendItemIdx] : void 0;\n      const nodeLabels = this.getLabels(\n        datum,\n        midAngle,\n        span,\n        true,\n        calloutLabelIdx != null ? values[calloutLabelIdx] : void 0,\n        sectorLabelIdx != null ? values[sectorLabelIdx] : void 0,\n        legendItemValue\n      );\n      const sectorFormat = this.getSectorFormat(datum, index, false);\n      const node = {\n        itemId: index,\n        series: this,\n        datum,\n        index,\n        angleValue,\n        midAngle,\n        midCos: Math.cos(midAngle),\n        midSin: Math.sin(midAngle),\n        startAngle,\n        endAngle,\n        radius,\n        innerRadius: Math.max(this.radiusScale.convert(0), 0),\n        outerRadius: Math.max(this.radiusScale.convert(radius), 0),\n        sectorFormat,\n        radiusValue,\n        legendItemValue,\n        enabled: this.seriesItemEnabled[index],\n        ...nodeLabels\n      };\n      nodes.push(node);\n      if (phantomNodes != null) {\n        phantomNodes.push({\n          ...node,\n          radius: 1,\n          innerRadius: Math.max(this.radiusScale.convert(0), 0),\n          outerRadius: Math.max(this.radiusScale.convert(1), 0)\n        });\n      }\n    });\n    this.zerosumOuterRing.visible = sum2 === 0;\n    return {\n      itemId: seriesId,\n      nodeData: nodes,\n      labelData: nodes,\n      phantomNodeData: phantomNodes\n    };\n  }\n  getLabels(datum, midAngle, span, skipDisabled, calloutLabelValue, sectorLabelValue, legendItemValue) {\n    const { calloutLabel, sectorLabel, legendItemKey } = this.properties;\n    const calloutLabelKey = !skipDisabled || calloutLabel.enabled ? this.properties.calloutLabelKey : void 0;\n    const sectorLabelKey = !skipDisabled || sectorLabel.enabled ? this.properties.sectorLabelKey : void 0;\n    if (!calloutLabelKey && !sectorLabelKey && !legendItemKey) {\n      return {};\n    }\n    const labelFormatterParams = {\n      datum,\n      angleKey: this.properties.angleKey,\n      angleName: this.properties.angleName,\n      radiusKey: this.properties.radiusKey,\n      radiusName: this.properties.radiusName,\n      calloutLabelKey: this.properties.calloutLabelKey,\n      calloutLabelName: this.properties.calloutLabelName,\n      sectorLabelKey: this.properties.sectorLabelKey,\n      sectorLabelName: this.properties.sectorLabelName,\n      legendItemKey: this.properties.legendItemKey\n    };\n    const result = {};\n    if (calloutLabelKey && span > toRadians(calloutLabel.minAngle)) {\n      result.calloutLabel = {\n        ...this.getTextAlignment(midAngle),\n        text: this.getLabelText(calloutLabel, {\n          ...labelFormatterParams,\n          value: calloutLabelValue\n        }),\n        hidden: false,\n        collisionTextAlign: void 0,\n        collisionOffsetY: 0,\n        box: void 0\n      };\n    }\n    if (sectorLabelKey) {\n      result.sectorLabel = {\n        text: this.getLabelText(sectorLabel, {\n          ...labelFormatterParams,\n          value: sectorLabelValue\n        })\n      };\n    }\n    if (legendItemKey != null && legendItemValue != null) {\n      result.legendItem = { key: legendItemKey, text: legendItemValue };\n    }\n    return result;\n  }\n  getTextAlignment(midAngle) {\n    const quadrantTextOpts = [\n      { textAlign: \"center\", textBaseline: \"bottom\" },\n      { textAlign: \"left\", textBaseline: \"middle\" },\n      { textAlign: \"center\", textBaseline: \"hanging\" },\n      { textAlign: \"right\", textBaseline: \"middle\" }\n    ];\n    const midAngle180 = normalizeAngle180(midAngle);\n    const quadrantStart = -0.75 * Math.PI;\n    const quadrantOffset = midAngle180 - quadrantStart;\n    const quadrant = Math.floor(quadrantOffset / (Math.PI / 2));\n    const quadrantIndex = mod(quadrant, quadrantTextOpts.length);\n    return quadrantTextOpts[quadrantIndex];\n  }\n  getSectorFormat(datum, formatIndex, highlighted) {\n    const { callbackCache } = this.ctx;\n    const { angleKey, radiusKey, calloutLabelKey, sectorLabelKey, legendItemKey, fills, strokes, itemStyler } = this.properties;\n    const defaultStroke = strokes[formatIndex % strokes.length];\n    const { fill, fillOpacity, stroke, strokeWidth, strokeOpacity, lineDash, lineDashOffset, cornerRadius } = mergeDefaults(\n      highlighted && this.properties.highlightStyle.item,\n      {\n        fill: fills.length > 0 ? fills[formatIndex % fills.length] : void 0,\n        stroke: defaultStroke,\n        strokeWidth: this.getStrokeWidth(this.properties.strokeWidth),\n        strokeOpacity: this.getOpacity()\n      },\n      this.properties\n    );\n    let format;\n    if (itemStyler) {\n      format = callbackCache.call(itemStyler, {\n        datum,\n        angleKey,\n        radiusKey,\n        calloutLabelKey,\n        sectorLabelKey,\n        legendItemKey,\n        fill,\n        strokeOpacity,\n        stroke,\n        strokeWidth,\n        fillOpacity,\n        lineDash,\n        lineDashOffset,\n        cornerRadius,\n        highlighted,\n        seriesId: this.id\n      });\n    }\n    return {\n      fill: format?.fill ?? fill,\n      fillOpacity: format?.fillOpacity ?? fillOpacity,\n      stroke: format?.stroke ?? stroke,\n      strokeWidth: format?.strokeWidth ?? strokeWidth,\n      strokeOpacity: format?.strokeOpacity ?? strokeOpacity,\n      lineDash: format?.lineDash ?? lineDash,\n      lineDashOffset: format?.lineDashOffset ?? lineDashOffset,\n      cornerRadius: format?.cornerRadius ?? cornerRadius\n    };\n  }\n  getOuterRadius() {\n    return Math.max(this.radius * this.properties.outerRadiusRatio + this.properties.outerRadiusOffset, 0);\n  }\n  updateRadiusScale(resize) {\n    const newRange = [0, this.getOuterRadius()];\n    this.radiusScale.range = newRange;\n    if (resize) {\n      this.previousRadiusScale.range = newRange;\n    }\n    const setRadii = (d) => ({\n      ...d,\n      innerRadius: Math.max(this.radiusScale.convert(0), 0),\n      outerRadius: Math.max(this.radiusScale.convert(d.radius), 0)\n    });\n    this.nodeData = this.nodeData.map(setRadii);\n    this.phantomNodeData = this.phantomNodeData?.map(setRadii);\n  }\n  getTitleTranslationY() {\n    const outerRadius = Math.max(0, this.radiusScale.range[1]);\n    if (outerRadius === 0) {\n      return NaN;\n    }\n    const spacing = this.properties.title?.spacing ?? 0;\n    const titleOffset = 2 + spacing;\n    const dy = Math.max(0, -outerRadius);\n    return -outerRadius - titleOffset - dy;\n  }\n  async update({ seriesRect }) {\n    const { title } = this.properties;\n    const newNodeDataDependencies = {\n      seriesRectWidth: seriesRect?.width,\n      seriesRectHeight: seriesRect?.height\n    };\n    const resize = jsonDiff(this.nodeDataDependencies, newNodeDataDependencies) != null;\n    if (resize) {\n      this._nodeDataDependencies = newNodeDataDependencies;\n    }\n    await this.maybeRefreshNodeData();\n    this.updateTitleNodes();\n    this.updateRadiusScale(resize);\n    this.contentGroup.translationX = this.centerX;\n    this.contentGroup.translationY = this.centerY;\n    this.highlightGroup.translationX = this.centerX;\n    this.highlightGroup.translationY = this.centerY;\n    this.backgroundGroup.translationX = this.centerX;\n    this.backgroundGroup.translationY = this.centerY;\n    if (this.labelGroup) {\n      this.labelGroup.translationX = this.centerX;\n      this.labelGroup.translationY = this.centerY;\n    }\n    if (title) {\n      const dy = this.getTitleTranslationY();\n      title.node.y = isFinite(dy) ? dy : 0;\n      const titleBox = title.node.getBBox();\n      title.node.visible = title.enabled && isFinite(dy) && !this.bboxIntersectsSurroundingSeries(titleBox);\n    }\n    this.zerosumOuterRing.fillOpacity = 0;\n    this.zerosumOuterRing.stroke = this.properties.calloutLabel.color;\n    this.zerosumOuterRing.strokeWidth = 1;\n    this.zerosumOuterRing.strokeOpacity = 1;\n    this.updateNodeMidPoint();\n    await this.updateSelections();\n    await this.updateNodes(seriesRect);\n  }\n  updateTitleNodes() {\n    const { oldTitle } = this;\n    const { title } = this.properties;\n    if (oldTitle !== title) {\n      if (oldTitle) {\n        this.labelGroup?.removeChild(oldTitle.node);\n      }\n      if (title) {\n        title.node.textBaseline = \"bottom\";\n        this.labelGroup?.appendChild(title.node);\n      }\n      this.oldTitle = title;\n    }\n  }\n  updateNodeMidPoint() {\n    const setMidPoint = (d) => {\n      const radius = d.innerRadius + (d.outerRadius - d.innerRadius) / 2;\n      d.midPoint = {\n        x: d.midCos * Math.max(0, radius),\n        y: d.midSin * Math.max(0, radius)\n      };\n    };\n    this.nodeData.forEach(setMidPoint);\n    this.phantomNodeData?.forEach(setMidPoint);\n  }\n  async updateSelections() {\n    await this.updateGroupSelection();\n  }\n  async updateGroupSelection() {\n    const {\n      itemSelection,\n      highlightSelection,\n      phantomSelection,\n      highlightLabelSelection,\n      calloutLabelSelection,\n      labelSelection\n    } = this;\n    const highlightedNodeData = this.nodeData.map((datum) => ({\n      ...datum,\n      // Allow mutable sectorFormat, so formatted sector styles can be updated and varied\n      // between normal and highlighted cases.\n      sectorFormat: { ...datum.sectorFormat }\n    }));\n    const update = (selection, nodeData) => {\n      selection.update(nodeData, void 0, (datum) => this.getDatumId(datum));\n      if (this.ctx.animationManager.isSkipped()) {\n        selection.cleanup();\n      }\n    };\n    update(itemSelection, this.nodeData);\n    update(highlightSelection, highlightedNodeData);\n    update(phantomSelection, this.phantomNodeData ?? []);\n    calloutLabelSelection.update(this.calloutNodeData, (group) => {\n      const line = new Line();\n      line.tag = 0 /* Callout */;\n      line.pointerEvents = 1 /* None */;\n      group.appendChild(line);\n      const text = new Text();\n      text.tag = 1 /* Label */;\n      text.pointerEvents = 1 /* None */;\n      group.appendChild(text);\n    });\n    labelSelection.update(this.nodeData);\n    highlightLabelSelection.update(highlightedNodeData);\n  }\n  async updateNodes(seriesRect) {\n    const highlightedDatum = this.ctx.highlightManager.getActiveHighlight();\n    const isVisible = this.visible && this.seriesItemEnabled.includes(true);\n    this.rootGroup.visible = isVisible;\n    this.backgroundGroup.visible = isVisible;\n    this.contentGroup.visible = isVisible;\n    this.highlightGroup.visible = isVisible && highlightedDatum?.series === this;\n    this.highlightLabel.visible = isVisible && highlightedDatum?.series === this;\n    if (this.labelGroup) {\n      this.labelGroup.visible = isVisible;\n    }\n    this.contentGroup.opacity = this.getOpacity();\n    const animationDisabled = this.ctx.animationManager.isSkipped();\n    const updateSectorFn = (sector, datum, _index, isDatumHighlighted) => {\n      const format = this.getSectorFormat(datum.datum, datum.itemId, isDatumHighlighted);\n      datum.sectorFormat.fill = format.fill;\n      datum.sectorFormat.stroke = format.stroke;\n      if (animationDisabled) {\n        sector.startAngle = datum.startAngle;\n        sector.endAngle = datum.endAngle;\n        sector.innerRadius = datum.innerRadius;\n        sector.outerRadius = datum.outerRadius;\n      }\n      if (isDatumHighlighted || animationDisabled) {\n        sector.fill = format.fill;\n        sector.stroke = format.stroke;\n      }\n      sector.strokeWidth = format.strokeWidth;\n      sector.fillOpacity = format.fillOpacity;\n      sector.strokeOpacity = format.strokeOpacity;\n      sector.lineDash = format.lineDash;\n      sector.lineDashOffset = format.lineDashOffset;\n      sector.cornerRadius = format.cornerRadius;\n      sector.fillShadow = this.properties.shadow;\n      const inset = Math.max(\n        (this.properties.sectorSpacing + (format.stroke != null ? format.strokeWidth : 0)) / 2,\n        0\n      );\n      sector.inset = inset;\n      sector.lineJoin = this.properties.sectorSpacing >= 0 || inset > 0 ? \"miter\" : \"round\";\n    };\n    this.itemSelection.each((node, datum, index) => updateSectorFn(node, datum, index, false));\n    this.highlightSelection.each((node, datum, index) => {\n      updateSectorFn(node, datum, index, true);\n      node.visible = datum.itemId === highlightedDatum?.itemId;\n    });\n    this.phantomSelection.each((node, datum, index) => updateSectorFn(node, datum, index, false));\n    this.updateCalloutLineNodes();\n    this.updateCalloutLabelNodes(seriesRect);\n    this.updateSectorLabelNodes();\n    this.updateZerosumRings();\n    this.animationState.transition(\"update\");\n  }\n  updateCalloutLineNodes() {\n    const { calloutLine } = this.properties;\n    const calloutLength = calloutLine.length;\n    const calloutStrokeWidth = calloutLine.strokeWidth;\n    const calloutColors = calloutLine.colors ?? this.properties.strokes;\n    const { offset: offset4 } = this.properties.calloutLabel;\n    this.calloutLabelSelection.selectByTag(0 /* Callout */).forEach((line, index) => {\n      const datum = line.datum;\n      const { calloutLabel: label, outerRadius } = datum;\n      if (label?.text && !label.hidden && outerRadius !== 0) {\n        line.visible = true;\n        line.strokeWidth = calloutStrokeWidth;\n        line.stroke = calloutColors[index % calloutColors.length];\n        line.fill = void 0;\n        const x1 = datum.midCos * outerRadius;\n        const y1 = datum.midSin * outerRadius;\n        let x2 = datum.midCos * (outerRadius + calloutLength);\n        let y2 = datum.midSin * (outerRadius + calloutLength);\n        const isMoved = label.collisionTextAlign ?? label.collisionOffsetY !== 0;\n        if (isMoved && label.box != null) {\n          const box = label.box;\n          let cx = x2;\n          let cy = y2;\n          if (x2 < box.x) {\n            cx = box.x;\n          } else if (x2 > box.x + box.width) {\n            cx = box.x + box.width;\n          }\n          if (y2 < box.y) {\n            cy = box.y;\n          } else if (y2 > box.y + box.height) {\n            cy = box.y + box.height;\n          }\n          const dx = cx - x2;\n          const dy = cy - y2;\n          const length2 = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n          const paddedLength = length2 - offset4;\n          if (paddedLength > 0) {\n            x2 = x2 + dx * paddedLength / length2;\n            y2 = y2 + dy * paddedLength / length2;\n          }\n        }\n        line.x1 = x1;\n        line.y1 = y1;\n        line.x2 = x2;\n        line.y2 = y2;\n      } else {\n        line.visible = false;\n      }\n    });\n  }\n  getLabelOverflow(text, box, seriesRect) {\n    const seriesLeft = seriesRect.x - this.centerX;\n    const seriesRight = seriesRect.x + seriesRect.width - this.centerX;\n    const seriesTop = seriesRect.y - this.centerY;\n    const seriesBottom = seriesRect.y + seriesRect.height - this.centerY;\n    const errPx = 1;\n    let visibleTextPart = 1;\n    if (box.x + errPx < seriesLeft) {\n      visibleTextPart = (box.x + box.width - seriesLeft) / box.width;\n    } else if (box.x + box.width - errPx > seriesRight) {\n      visibleTextPart = (seriesRight - box.x) / box.width;\n    }\n    const hasVerticalOverflow = box.y + errPx < seriesTop || box.y + box.height - errPx > seriesBottom;\n    const textLength = visibleTextPart === 1 ? text.length : Math.floor(text.length * visibleTextPart) - 1;\n    const hasSurroundingSeriesOverflow = this.bboxIntersectsSurroundingSeries(box);\n    return { textLength, hasVerticalOverflow, hasSurroundingSeriesOverflow };\n  }\n  bboxIntersectsSurroundingSeries(box) {\n    const { surroundingRadius } = this;\n    if (surroundingRadius == null) {\n      return false;\n    }\n    const corners = [\n      { x: box.x, y: box.y },\n      { x: box.x + box.width, y: box.y },\n      { x: box.x + box.width, y: box.y + box.height },\n      { x: box.x, y: box.y + box.height }\n    ];\n    const sur2 = surroundingRadius ** 2;\n    return corners.some((corner) => corner.x ** 2 + corner.y ** 2 > sur2);\n  }\n  computeCalloutLabelCollisionOffsets() {\n    const { radiusScale } = this;\n    const { calloutLabel, calloutLine } = this.properties;\n    const { offset: offset4, minSpacing } = calloutLabel;\n    const innerRadius = radiusScale.convert(0);\n    const shouldSkip = (datum) => {\n      const label = datum.calloutLabel;\n      return !label || datum.outerRadius === 0;\n    };\n    const fullData = this.calloutNodeData;\n    const data = fullData.filter((t) => !shouldSkip(t));\n    data.forEach((datum) => {\n      const label = datum.calloutLabel;\n      if (label == null)\n        return;\n      label.hidden = false;\n      label.collisionTextAlign = void 0;\n      label.collisionOffsetY = 0;\n    });\n    if (data.length <= 1) {\n      return;\n    }\n    const leftLabels = data.filter((d) => d.midCos < 0).sort((a, b) => a.midSin - b.midSin);\n    const rightLabels = data.filter((d) => d.midCos >= 0).sort((a, b) => a.midSin - b.midSin);\n    const topLabels = data.filter((d) => d.midSin < 0 && d.calloutLabel?.textAlign === \"center\").sort((a, b) => a.midCos - b.midCos);\n    const bottomLabels = data.filter((d) => d.midSin >= 0 && d.calloutLabel?.textAlign === \"center\").sort((a, b) => a.midCos - b.midCos);\n    const getTextBBox = (datum) => {\n      const label = datum.calloutLabel;\n      if (label == null)\n        return BBox.zero.clone();\n      const labelRadius = datum.outerRadius + calloutLine.length + offset4;\n      const x = datum.midCos * labelRadius;\n      const y = datum.midSin * labelRadius + label.collisionOffsetY;\n      const textAlign = label.collisionTextAlign ?? label.textAlign;\n      const textBaseline = label.textBaseline;\n      return Text.computeBBox(label.text, x, y, {\n        font: this.properties.calloutLabel,\n        textAlign,\n        textBaseline\n      });\n    };\n    const avoidNeighbourYCollision = (label, next, direction) => {\n      const box = getTextBBox(label).grow(minSpacing / 2);\n      const other = getTextBBox(next).grow(minSpacing / 2);\n      const collidesOrBehind = box.x < other.x + other.width && box.x + box.width > other.x && (direction === \"to-top\" ? box.y < other.y + other.height : box.y + box.height > other.y);\n      if (collidesOrBehind) {\n        const dy = direction === \"to-top\" ? box.y - other.y - other.height : box.y + box.height - other.y;\n        next.calloutLabel.collisionOffsetY = dy;\n      }\n    };\n    const avoidYCollisions = (labels) => {\n      const midLabel = labels.slice().sort((a, b) => Math.abs(a.midSin) - Math.abs(b.midSin))[0];\n      const midIndex = labels.indexOf(midLabel);\n      for (let i = midIndex - 1; i >= 0; i--) {\n        const prev = labels[i + 1];\n        const next = labels[i];\n        avoidNeighbourYCollision(prev, next, \"to-top\");\n      }\n      for (let i = midIndex + 1; i < labels.length; i++) {\n        const prev = labels[i - 1];\n        const next = labels[i];\n        avoidNeighbourYCollision(prev, next, \"to-bottom\");\n      }\n    };\n    const avoidXCollisions = (labels) => {\n      const labelsCollideLabelsByY = data.some((datum) => datum.calloutLabel.collisionOffsetY !== 0);\n      const boxes = labels.map((label) => getTextBBox(label));\n      const paddedBoxes = boxes.map((box) => box.clone().grow(minSpacing / 2));\n      let labelsCollideLabelsByX = false;\n      for (let i = 0; i < paddedBoxes.length && !labelsCollideLabelsByX; i++) {\n        const box = paddedBoxes[i];\n        for (let j = i + 1; j < labels.length; j++) {\n          const other = paddedBoxes[j];\n          if (box.collidesBBox(other)) {\n            labelsCollideLabelsByX = true;\n            break;\n          }\n        }\n      }\n      const sectors = fullData.map((datum) => {\n        const { startAngle, endAngle, outerRadius } = datum;\n        return { startAngle, endAngle, innerRadius, outerRadius };\n      });\n      const labelsCollideSectors = boxes.some((box) => {\n        return sectors.some((sector) => boxCollidesSector(box, sector));\n      });\n      if (!labelsCollideLabelsByX && !labelsCollideLabelsByY && !labelsCollideSectors) {\n        return;\n      }\n      labels.filter((d) => d.calloutLabel.textAlign === \"center\").forEach((d) => {\n        const label = d.calloutLabel;\n        if (d.midCos < 0) {\n          label.collisionTextAlign = \"right\";\n        } else if (d.midCos > 0) {\n          label.collisionTextAlign = \"left\";\n        } else {\n          label.collisionTextAlign = \"center\";\n        }\n      });\n    };\n    avoidYCollisions(leftLabels);\n    avoidYCollisions(rightLabels);\n    avoidXCollisions(topLabels);\n    avoidXCollisions(bottomLabels);\n  }\n  updateCalloutLabelNodes(seriesRect) {\n    const { radiusScale } = this;\n    const { calloutLabel, calloutLine } = this.properties;\n    const calloutLength = calloutLine.length;\n    const { offset: offset4, color } = calloutLabel;\n    const tempTextNode = new Text();\n    this.calloutLabelSelection.selectByTag(1 /* Label */).forEach((text) => {\n      const { datum } = text;\n      const label = datum.calloutLabel;\n      const radius = radiusScale.convert(datum.radius);\n      const outerRadius = Math.max(0, radius);\n      if (!label?.text || outerRadius === 0 || label.hidden) {\n        text.visible = false;\n        return;\n      }\n      const labelRadius = outerRadius + calloutLength + offset4;\n      const x = datum.midCos * labelRadius;\n      const y = datum.midSin * labelRadius + label.collisionOffsetY;\n      const align = {\n        textAlign: label.collisionTextAlign ?? label.textAlign,\n        textBaseline: label.textBaseline\n      };\n      tempTextNode.text = label.text;\n      tempTextNode.x = x;\n      tempTextNode.y = y;\n      tempTextNode.setFont(this.properties.calloutLabel);\n      tempTextNode.setAlign(align);\n      const box = tempTextNode.getBBox();\n      let displayText = label.text;\n      let visible = true;\n      if (calloutLabel.avoidCollisions) {\n        const { textLength, hasVerticalOverflow } = this.getLabelOverflow(label.text, box, seriesRect);\n        displayText = label.text.length === textLength ? label.text : `${label.text.substring(0, textLength)}\\u2026`;\n        visible = !hasVerticalOverflow;\n      }\n      text.text = displayText;\n      text.x = x;\n      text.y = y;\n      text.setFont(this.properties.calloutLabel);\n      text.setAlign(align);\n      text.fill = color;\n      text.visible = visible;\n    });\n  }\n  async computeLabelsBBox(options, seriesRect) {\n    const { calloutLabel, calloutLine } = this.properties;\n    const calloutLength = calloutLine.length;\n    const { offset: offset4, maxCollisionOffset, minSpacing } = calloutLabel;\n    if (!calloutLabel.avoidCollisions) {\n      return null;\n    }\n    await this.maybeRefreshNodeData();\n    this.updateRadiusScale(false);\n    this.computeCalloutLabelCollisionOffsets();\n    const textBoxes = [];\n    const text = new Text();\n    let titleBox;\n    const { title } = this.properties;\n    if (title?.text && title.enabled) {\n      const dy = this.getTitleTranslationY();\n      if (isFinite(dy)) {\n        text.text = title.text;\n        text.x = 0;\n        text.y = dy;\n        text.setFont(title);\n        text.setAlign({\n          textBaseline: \"bottom\",\n          textAlign: \"center\"\n        });\n        titleBox = text.getBBox();\n        textBoxes.push(titleBox);\n      }\n    }\n    this.calloutNodeData.forEach((datum) => {\n      const label = datum.calloutLabel;\n      if (!label || datum.outerRadius === 0) {\n        return null;\n      }\n      const labelRadius = datum.outerRadius + calloutLength + offset4;\n      const x = datum.midCos * labelRadius;\n      const y = datum.midSin * labelRadius + label.collisionOffsetY;\n      text.text = label.text;\n      text.x = x;\n      text.y = y;\n      text.setFont(this.properties.calloutLabel);\n      text.setAlign({\n        textAlign: label.collisionTextAlign ?? label.textAlign,\n        textBaseline: label.textBaseline\n      });\n      const box = text.getBBox();\n      label.box = box;\n      if (Math.abs(label.collisionOffsetY) > maxCollisionOffset) {\n        label.hidden = true;\n        return;\n      }\n      if (titleBox) {\n        const seriesTop = seriesRect.y - this.centerY;\n        const titleCleanArea = new BBox(\n          titleBox.x - minSpacing,\n          seriesTop,\n          titleBox.width + 2 * minSpacing,\n          titleBox.y + titleBox.height + minSpacing - seriesTop\n        );\n        if (box.collidesBBox(titleCleanArea)) {\n          label.hidden = true;\n          return;\n        }\n      }\n      if (options.hideWhenNecessary) {\n        const { textLength, hasVerticalOverflow, hasSurroundingSeriesOverflow } = this.getLabelOverflow(\n          label.text,\n          box,\n          seriesRect\n        );\n        const isTooShort = label.text.length > 2 && textLength < 2;\n        if (hasVerticalOverflow || isTooShort || hasSurroundingSeriesOverflow) {\n          label.hidden = true;\n          return;\n        }\n      }\n      label.hidden = false;\n      textBoxes.push(box);\n    });\n    if (textBoxes.length === 0) {\n      return null;\n    }\n    return BBox.merge(textBoxes);\n  }\n  updateSectorLabelNodes() {\n    const { radiusScale } = this;\n    const innerRadius = radiusScale.convert(0);\n    const { fontSize, fontStyle, fontWeight, fontFamily, positionOffset, positionRatio, color } = this.properties.sectorLabel;\n    const isDonut = innerRadius > 0;\n    const singleVisibleSector = this.seriesItemEnabled.filter(Boolean).length === 1;\n    const updateSectorLabel = (text, datum) => {\n      const { sectorLabel, outerRadius, startAngle, endAngle } = datum;\n      let isTextVisible = false;\n      if (sectorLabel && outerRadius !== 0) {\n        const labelRadius = innerRadius * (1 - positionRatio) + outerRadius * positionRatio + positionOffset;\n        text.fill = color;\n        text.fontStyle = fontStyle;\n        text.fontWeight = fontWeight;\n        text.fontSize = fontSize;\n        text.fontFamily = fontFamily;\n        text.text = sectorLabel.text;\n        const shouldPutTextInCenter = !isDonut && singleVisibleSector;\n        if (shouldPutTextInCenter) {\n          text.x = 0;\n          text.y = 0;\n        } else {\n          text.x = datum.midCos * labelRadius;\n          text.y = datum.midSin * labelRadius;\n        }\n        text.textAlign = \"center\";\n        text.textBaseline = \"middle\";\n        const bbox = text.getBBox();\n        const corners = [\n          [bbox.x, bbox.y],\n          [bbox.x + bbox.width, bbox.y],\n          [bbox.x + bbox.width, bbox.y + bbox.height],\n          [bbox.x, bbox.y + bbox.height]\n        ];\n        const sectorBounds = { startAngle, endAngle, innerRadius, outerRadius };\n        if (corners.every(([x, y]) => isPointInSector(x, y, sectorBounds))) {\n          isTextVisible = true;\n        }\n      }\n      text.visible = isTextVisible;\n    };\n    this.labelSelection.each(updateSectorLabel);\n    this.highlightLabelSelection.each(updateSectorLabel);\n  }\n  updateZerosumRings() {\n    this.zerosumOuterRing.size = this.getOuterRadius() * 2;\n  }\n  getDatumLegendName(nodeDatum) {\n    const { angleKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;\n    const { sectorLabel, calloutLabel, legendItem } = nodeDatum;\n    if (legendItemKey && legendItem !== void 0) {\n      return legendItem.text;\n    } else if (calloutLabelKey && calloutLabelKey !== angleKey && calloutLabel?.text !== void 0) {\n      return calloutLabel.text;\n    } else if (sectorLabelKey && sectorLabelKey !== angleKey && sectorLabel?.text !== void 0) {\n      return sectorLabel.text;\n    }\n  }\n  pickNodeClosestDatum(point) {\n    return pickByMatchingAngle(this, point);\n  }\n  getTooltipHtml(nodeDatum) {\n    if (!this.properties.isValid()) {\n      return EMPTY_TOOLTIP_CONTENT;\n    }\n    const {\n      datum,\n      angleValue,\n      sectorFormat: { fill: color },\n      itemId\n    } = nodeDatum;\n    const title = sanitizeHtml(this.properties.title?.text);\n    const content = isFiniteNumber(angleValue) ? toFixed(angleValue) : String(angleValue);\n    const labelText = this.getDatumLegendName(nodeDatum);\n    return this.properties.tooltip.toTooltipHtml(\n      {\n        title: title ?? labelText,\n        content: title && labelText ? `${labelText}: ${content}` : content,\n        backgroundColor: color\n      },\n      {\n        datum,\n        itemId,\n        title,\n        color,\n        seriesId: this.id,\n        angleKey: this.properties.angleKey,\n        angleName: this.properties.angleName,\n        radiusKey: this.properties.radiusKey,\n        radiusName: this.properties.radiusName,\n        calloutLabelKey: this.properties.calloutLabelKey,\n        calloutLabelName: this.properties.calloutLabelName,\n        sectorLabelKey: this.properties.sectorLabelKey,\n        sectorLabelName: this.properties.sectorLabelName,\n        legendItemKey: this.properties.legendItemKey\n      }\n    );\n  }\n  getLegendData(legendType) {\n    const { visible, processedData, dataModel } = this;\n    if (!dataModel || !processedData?.data.length || legendType !== \"category\") {\n      return [];\n    }\n    const { angleKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;\n    if (!legendItemKey && (!calloutLabelKey || calloutLabelKey === angleKey) && (!sectorLabelKey || sectorLabelKey === angleKey)) {\n      return [];\n    }\n    const { calloutLabelIdx, sectorLabelIdx, legendItemIdx } = this.getProcessedDataIndexes(dataModel);\n    const titleText = this.properties.title?.showInLegend && this.properties.title.text;\n    const legendData = [];\n    for (let index = 0; index < processedData.data.length; index++) {\n      const { datum, values } = processedData.data[index];\n      const labelParts = [];\n      if (titleText) {\n        labelParts.push(titleText);\n      }\n      const labels = this.getLabels(\n        datum,\n        2 * Math.PI,\n        2 * Math.PI,\n        false,\n        calloutLabelIdx != null ? values[calloutLabelIdx] : void 0,\n        sectorLabelIdx != null ? values[sectorLabelIdx] : void 0,\n        legendItemIdx != null ? values[legendItemIdx] : void 0\n      );\n      if (legendItemKey && labels.legendItem !== void 0) {\n        labelParts.push(labels.legendItem.text);\n      } else if (calloutLabelKey && calloutLabelKey !== angleKey && labels.calloutLabel?.text !== void 0) {\n        labelParts.push(labels.calloutLabel?.text);\n      } else if (sectorLabelKey && sectorLabelKey !== angleKey && labels.sectorLabel?.text !== void 0) {\n        labelParts.push(labels.sectorLabel?.text);\n      }\n      if (labelParts.length === 0)\n        continue;\n      const sectorFormat = this.getSectorFormat(datum, index, false);\n      legendData.push({\n        legendType: \"category\",\n        id: this.id,\n        itemId: index,\n        seriesId: this.id,\n        enabled: visible && this.legendItemEnabled[index],\n        label: {\n          text: labelParts.join(\" - \")\n        },\n        symbols: [\n          {\n            marker: {\n              fill: sectorFormat.fill,\n              stroke: sectorFormat.stroke,\n              fillOpacity: this.properties.fillOpacity,\n              strokeOpacity: this.properties.strokeOpacity,\n              strokeWidth: this.properties.strokeWidth\n            }\n          }\n        ],\n        legendItemName: legendItemKey != null ? datum[legendItemKey] : void 0\n      });\n    }\n    return legendData;\n  }\n  onLegendItemClick(event) {\n    const { enabled, itemId, series, legendItemName } = event;\n    if (series.id === this.id) {\n      this.toggleSeriesItem(itemId, enabled);\n    } else if (legendItemName != null) {\n      this.toggleOtherSeriesItems(legendItemName, enabled);\n    }\n  }\n  toggleSeriesItem(itemId, enabled) {\n    this.seriesItemEnabled[itemId] = enabled;\n    this.legendItemEnabled[itemId] = enabled;\n    if (this.nodeData[itemId]) {\n      this.nodeData[itemId].enabled = enabled;\n    }\n    this.nodeDataRefresh = true;\n  }\n  // Used for grid\n  setLegendState(enabledItems) {\n    this.legendItemEnabled = enabledItems;\n    this.ctx.updateService.update(4 /* SERIES_UPDATE */);\n  }\n  toggleOtherSeriesItems(legendItemName, enabled) {\n    if (!this.properties.legendItemKey || !this.dataModel) {\n      return;\n    }\n    const legendItemIdx = this.dataModel.resolveProcessedDataIndexById(this, `legendItemValue`);\n    this.processedData?.data.forEach(({ values }, datumItemId) => {\n      if (values[legendItemIdx] === legendItemName) {\n        this.toggleSeriesItem(datumItemId, enabled);\n      }\n    });\n  }\n  animateEmptyUpdateReady(_data) {\n    const { animationManager } = this.ctx;\n    const fns = preparePieSeriesAnimationFunctions(\n      true,\n      this.properties.rotation,\n      this.radiusScale,\n      this.previousRadiusScale\n    );\n    fromToMotion(\n      this.id,\n      \"nodes\",\n      animationManager,\n      [this.itemSelection, this.highlightSelection, this.phantomSelection],\n      fns.nodes,\n      (_, datum) => this.getDatumId(datum)\n    );\n    seriesLabelFadeInAnimation(this, \"callout\", animationManager, this.calloutLabelSelection);\n    seriesLabelFadeInAnimation(this, \"sector\", animationManager, this.labelSelection);\n    seriesLabelFadeInAnimation(this, \"highlight\", animationManager, this.highlightLabelSelection);\n    this.previousRadiusScale.range = this.radiusScale.range;\n  }\n  animateWaitingUpdateReady() {\n    const { itemSelection, highlightSelection, phantomSelection, processedData, radiusScale, previousRadiusScale } = this;\n    const { animationManager } = this.ctx;\n    const dataDiff = processedData?.reduced?.diff;\n    this.ctx.animationManager.stopByAnimationGroupId(this.id);\n    const supportedDiff = (dataDiff?.moved.size ?? 0) === 0;\n    const hasKeys = (processedData?.defs.keys.length ?? 0) > 0;\n    const hasUniqueKeys = processedData?.reduced?.animationValidation?.uniqueKeys ?? true;\n    if (!supportedDiff || !hasKeys || !hasUniqueKeys) {\n      this.ctx.animationManager.skipCurrentBatch();\n    }\n    const fns = preparePieSeriesAnimationFunctions(\n      false,\n      this.properties.rotation,\n      radiusScale,\n      previousRadiusScale\n    );\n    fromToMotion(\n      this.id,\n      \"nodes\",\n      animationManager,\n      [itemSelection, highlightSelection, phantomSelection],\n      fns.nodes,\n      (_, datum) => this.getDatumId(datum),\n      dataDiff\n    );\n    seriesLabelFadeInAnimation(this, \"callout\", this.ctx.animationManager, this.calloutLabelSelection);\n    seriesLabelFadeInAnimation(this, \"sector\", this.ctx.animationManager, this.labelSelection);\n    seriesLabelFadeInAnimation(this, \"highlight\", this.ctx.animationManager, this.highlightLabelSelection);\n    this.previousRadiusScale.range = this.radiusScale.range;\n  }\n  animateClearingUpdateEmpty() {\n    const { itemSelection, highlightSelection, phantomSelection, radiusScale, previousRadiusScale } = this;\n    const { animationManager } = this.ctx;\n    const fns = preparePieSeriesAnimationFunctions(\n      false,\n      this.properties.rotation,\n      radiusScale,\n      previousRadiusScale\n    );\n    fromToMotion(\n      this.id,\n      \"nodes\",\n      animationManager,\n      [itemSelection, highlightSelection, phantomSelection],\n      fns.nodes,\n      (_, datum) => this.getDatumId(datum)\n    );\n    seriesLabelFadeOutAnimation(this, \"callout\", this.ctx.animationManager, this.calloutLabelSelection);\n    seriesLabelFadeOutAnimation(this, \"sector\", this.ctx.animationManager, this.labelSelection);\n    seriesLabelFadeOutAnimation(this, \"highlight\", this.ctx.animationManager, this.highlightLabelSelection);\n    this.previousRadiusScale.range = this.radiusScale.range;\n  }\n  getDatumIdFromData(datum) {\n    const { calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;\n    if (!this.processedData?.reduced?.animationValidation?.uniqueKeys) {\n      return;\n    }\n    if (legendItemKey) {\n      return datum[legendItemKey];\n    } else if (calloutLabelKey) {\n      return datum[calloutLabelKey];\n    } else if (sectorLabelKey) {\n      return datum[sectorLabelKey];\n    }\n  }\n  getDatumId(datum) {\n    const { index } = datum;\n    const datumId = this.getDatumIdFromData(datum.datum);\n    return datumId != null ? String(datumId) : `${index}`;\n  }\n  onDataChange() {\n    const { data, seriesItemEnabled, legendItemEnabled } = this;\n    this.seriesItemEnabled = data?.map((_, index) => seriesItemEnabled[index] ?? true) ?? [];\n    this.legendItemEnabled = data?.map((_, index) => legendItemEnabled[index] ?? true) ?? [];\n  }\n};\nPieSeries.className = \"PieSeries\";\nPieSeries.type = \"pie\";\n\n// packages/ag-charts-community/src/chart/series/polar/pieSeriesModule.ts\nvar PieSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"polar\"],\n  identifier: \"pie\",\n  moduleFactory: (ctx) => new PieSeries(ctx),\n  tooltipDefaults: { range: \"exact\" },\n  themeTemplate: pieTheme,\n  paletteFactory: piePaletteFactory\n};\n\n// packages/ag-charts-community/src/util/vector.ts\nvar Vec2 = {\n  add,\n  angle,\n  apply,\n  equal,\n  distance: distance2,\n  distanceSquared: distanceSquared2,\n  from,\n  gradient,\n  intercept,\n  intersectAtX,\n  intersectAtY,\n  length,\n  lengthSquared,\n  multiply,\n  normalized,\n  origin,\n  required,\n  rotate,\n  round: round3,\n  sub\n};\nfunction add(a, b) {\n  if (typeof b === \"number\") {\n    return { x: a.x + b, y: a.y + b };\n  }\n  return { x: a.x + b.x, y: a.y + b.y };\n}\nfunction sub(a, b) {\n  if (typeof b === \"number\") {\n    return { x: a.x - b, y: a.y - b };\n  }\n  return { x: a.x - b.x, y: a.y - b.y };\n}\nfunction multiply(a, b) {\n  if (typeof b === \"number\") {\n    return { x: a.x * b, y: a.y * b };\n  }\n  return { x: a.x * b.x, y: a.y * b.y };\n}\nfunction length(a) {\n  return Math.sqrt(a.x * a.x + a.y * a.y);\n}\nfunction lengthSquared(a) {\n  return a.x * a.x + a.y * a.y;\n}\nfunction distance2(a, b) {\n  const d = sub(a, b);\n  return Math.sqrt(d.x * d.x + d.y * d.y);\n}\nfunction distanceSquared2(a, b) {\n  const d = sub(a, b);\n  return d.x * d.x + d.y * d.y;\n}\nfunction normalized(a) {\n  const l = length(a);\n  return { x: a.x / l, y: a.y / l };\n}\nfunction angle(a, b = origin()) {\n  return Math.atan2(a.y, a.x) - Math.atan2(b.y, b.x);\n}\nfunction rotate(a, theta, b = origin()) {\n  const l = length(a);\n  return { x: b.x + l * Math.cos(theta), y: b.y + l * Math.sin(theta) };\n}\nfunction gradient(a, b, reflection) {\n  const dx = b.x - a.x;\n  const dy = reflection == null ? b.y - a.y : reflection - b.y - (reflection - a.y);\n  return dy / dx;\n}\nfunction intercept(a, gradient2, reflection) {\n  const y = reflection == null ? a.y : reflection - a.y;\n  return y - gradient2 * a.x;\n}\nfunction intersectAtY(gradient2, coefficient, y = 0, reflection) {\n  return {\n    x: gradient2 === Infinity ? Infinity : (y - coefficient) / gradient2,\n    y: reflection == null ? y : reflection - y\n  };\n}\nfunction intersectAtX(gradient2, coefficient, x = 0, reflection) {\n  const y = gradient2 === Infinity ? Infinity : gradient2 * x + coefficient;\n  return { x, y: reflection == null ? y : reflection - y };\n}\nfunction round3(a) {\n  return { x: Math.round(a.x), y: Math.round(a.y) };\n}\nfunction equal(a, b) {\n  return a.x === b.x && a.y === b.y;\n}\nfunction from(a, b) {\n  if (typeof a === \"number\") {\n    return { x: a, y: b };\n  }\n  if (\"regionOffsetX\" in a) {\n    return { x: a.regionOffsetX, y: a.regionOffsetY };\n  }\n  if (\"offsetWidth\" in a) {\n    return { x: a.offsetWidth, y: a.offsetHeight };\n  }\n  if (\"width\" in a) {\n    return [\n      { x: a.x, y: a.y },\n      { x: a.x + a.width, y: a.y + a.height }\n    ];\n  }\n  if (\"x1\" in a) {\n    return [\n      { x: a.x1, y: a.y1 },\n      { x: a.x2, y: a.y2 }\n    ];\n  }\n  throw new Error(`Values can not be converted into a vector: [${a}] [${b}]`);\n}\nfunction apply(a, b) {\n  a.x = b.x;\n  a.y = b.y;\n  return a;\n}\nfunction required(a) {\n  return { x: a?.x ?? 0, y: a?.y ?? 0 };\n}\nfunction origin() {\n  return { x: 0, y: 0 };\n}\n\n// packages/ag-charts-community/src/chart/toolbar/toolbarProperties.ts\nvar ToolbarGroupProperties = class extends BaseProperties {\n  constructor(onChange, onButtonsChange) {\n    super();\n    this.onChange = onChange;\n    this.onButtonsChange = onButtonsChange;\n    this.align = \"start\";\n    this.position = \"top\" /* Top */;\n    this.size = \"normal\";\n    this.buttonOverrides = /* @__PURE__ */ new Map();\n  }\n  buttonConfigurations() {\n    const buttons = [...this.buttons ?? []];\n    if (this.draggable) {\n      buttons.unshift({\n        icon: \"drag-handle\",\n        tooltip: \"toolbarAnnotationsDragHandle\",\n        value: \"drag\",\n        id: \"drag\"\n      });\n    }\n    return buttons?.map((button) => {\n      const id = button.id ?? button.value;\n      const overrides = this.buttonOverrides.get(id);\n      return overrides != null ? { ...button, ...overrides } : button;\n    }) ?? [];\n  }\n  buttonsChanged(configurationOnly) {\n    this.onButtonsChange(this.buttonConfigurations(), configurationOnly);\n  }\n  overrideButtonConfiguration(id, options) {\n    let overrides = this.buttonOverrides.get(id);\n    if (overrides == null) {\n      overrides = /* @__PURE__ */ Object.create(null);\n      this.buttonOverrides.set(id, overrides);\n    }\n    for (const key in options) {\n      const value = options[key];\n      if (value == null) {\n        delete overrides[key];\n      } else {\n        overrides[key] = value;\n      }\n    }\n    this.buttonsChanged(true);\n  }\n};\n__decorateClass([\n  ObserveChanges((target) => {\n    target.onChange(target.enabled);\n  }),\n  Validate(BOOLEAN)\n], ToolbarGroupProperties.prototype, \"enabled\", 2);\n__decorateClass([\n  ObserveChanges((target) => {\n    target.onChange(target.enabled);\n  }),\n  Validate(UNION([...TOOLBAR_ALIGNMENTS]), { optional: true })\n], ToolbarGroupProperties.prototype, \"align\", 2);\n__decorateClass([\n  ObserveChanges((target) => {\n    target.onChange(target.enabled);\n  }),\n  Validate(UNION(TOOLBAR_POSITIONS), { optional: true })\n], ToolbarGroupProperties.prototype, \"position\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], ToolbarGroupProperties.prototype, \"draggable\", 2);\n__decorateClass([\n  ObserveChanges((target) => {\n    target.onChange(target.enabled);\n  }),\n  Validate(UNION([\"small\", \"normal\"]), { optional: true })\n], ToolbarGroupProperties.prototype, \"size\", 2);\n__decorateClass([\n  ObserveChanges((target) => {\n    for (const button of target.buttons ?? []) {\n      if (button.icon != null && ICONS_LEGACY.includes(button.icon)) {\n        Logger.warnOnce(`Icon '${button.icon}' is deprecated, use another icon instead.`);\n      }\n      if (button.ariaLabel === \"toolbarAnnotationsColor\") {\n        Logger.warnOnce(\n          `Aria label '${button.ariaLabel}' is deprecated, use 'toolbarAnnotationsLineColor' instead.`\n        );\n      }\n    }\n    target.buttonsChanged(false);\n  }),\n  Validate(ARRAY, { optional: true })\n], ToolbarGroupProperties.prototype, \"buttons\", 2);\n\n// packages/ag-charts-community/src/chart/toolbar/toolbarStyles.ts\nvar block = \"ag-charts-toolbar\";\nvar elements = {\n  align: \"ag-charts-toolbar__align\",\n  section: \"ag-charts-toolbar__section\",\n  button: \"ag-charts-toolbar__button\",\n  icon: \"ag-charts-toolbar__icon\",\n  label: \"ag-charts-toolbar__label\"\n};\nvar modifiers = {\n  [\"top\" /* Top */]: \"ag-charts-toolbar--top\",\n  [\"right\" /* Right */]: \"ag-charts-toolbar--right\",\n  [\"bottom\" /* Bottom */]: \"ag-charts-toolbar--bottom\",\n  [\"left\" /* Left */]: \"ag-charts-toolbar--left\",\n  [\"floating\" /* Floating */]: \"ag-charts-toolbar--floating\",\n  [\"floating-top\" /* FloatingTop */]: \"ag-charts-toolbar--floating-top\",\n  [\"floating-bottom\" /* FloatingBottom */]: \"ag-charts-toolbar--floating-bottom\",\n  small: \"ag-charts-toolbar--small\",\n  normal: \"ag-charts-toolbar--normal\",\n  hidden: \"ag-charts-toolbar--hidden\",\n  preventFlash: \"ag-charts-toolbar--prevent-flash\",\n  floatingHidden: \"ag-charts-toolbar--floating-hidden\",\n  align: {\n    start: \"ag-charts-toolbar__align--start\",\n    center: \"ag-charts-toolbar__align--center\",\n    end: \"ag-charts-toolbar__align--end\"\n  },\n  button: {\n    first: \"ag-charts-toolbar__button--first\",\n    last: \"ag-charts-toolbar__button--last\",\n    active: \"ag-charts-toolbar__button--active\",\n    hiddenValue: \"ag-charts-toolbar__button--hidden-value\",\n    hiddenToggled: \"ag-charts-toolbar__button--hidden-toggled\",\n    fillVisible: \"ag-charts-toolbar__button--fill-visible\",\n    strokeWidthVisible: \"ag-charts-toolbar__button--stroke-width-visible\",\n    withTransition: \"ag-charts-toolbar__button--with-transition\",\n    dragHandle: \"ag-charts-toolbar__button--drag-handle\",\n    dragging: \"ag-charts-toolbar__button--dragging\"\n  }\n};\n\n// packages/ag-charts-community/src/chart/toolbar/toolbar.ts\nvar Toolbar = class extends BaseModuleInstance {\n  constructor(ctx) {\n    super();\n    this.ctx = ctx;\n    this.enabled = true;\n    this.seriesType = new ToolbarGroupProperties(\n      this.onGroupChanged.bind(this, \"seriesType\"),\n      this.onGroupButtonsChanged.bind(this, \"seriesType\")\n    );\n    this.annotations = new ToolbarGroupProperties(\n      this.onGroupChanged.bind(this, \"annotations\"),\n      this.onGroupButtonsChanged.bind(this, \"annotations\")\n    );\n    this.annotationOptions = new ToolbarGroupProperties(\n      this.onGroupChanged.bind(this, \"annotationOptions\"),\n      this.onGroupButtonsChanged.bind(this, \"annotationOptions\")\n    );\n    this.ranges = new ToolbarGroupProperties(\n      this.onGroupChanged.bind(this, \"ranges\"),\n      this.onGroupButtonsChanged.bind(this, \"ranges\")\n    );\n    this.zoom = new ToolbarGroupProperties(\n      this.onGroupChanged.bind(this, \"zoom\"),\n      this.onGroupButtonsChanged.bind(this, \"zoom\")\n    );\n    this.dragState = {\n      client: { x: 0, y: 0 },\n      position: {\n        x: 0,\n        y: 0\n      },\n      detached: false\n    };\n    this.horizontalSpacing = 10;\n    this.verticalSpacing = 10;\n    this.floatingDetectionRange = 38;\n    this.positions = {\n      [\"top\" /* Top */]: /* @__PURE__ */ new Set(),\n      [\"left\" /* Left */]: /* @__PURE__ */ new Set(),\n      [\"right\" /* Right */]: /* @__PURE__ */ new Set(),\n      [\"bottom\" /* Bottom */]: /* @__PURE__ */ new Set(),\n      [\"floating\" /* Floating */]: /* @__PURE__ */ new Set(),\n      [\"floating-top\" /* FloatingTop */]: /* @__PURE__ */ new Set(),\n      [\"floating-bottom\" /* FloatingBottom */]: /* @__PURE__ */ new Set()\n    };\n    this.positionAlignments = {\n      [\"top\" /* Top */]: {},\n      [\"left\" /* Left */]: {},\n      [\"right\" /* Right */]: {},\n      [\"bottom\" /* Bottom */]: {},\n      [\"floating\" /* Floating */]: {},\n      [\"floating-top\" /* FloatingTop */]: {},\n      [\"floating-bottom\" /* FloatingBottom */]: {}\n    };\n    this.groupCallers = {\n      seriesType: /* @__PURE__ */ new Set(),\n      annotations: /* @__PURE__ */ new Set(),\n      annotationOptions: /* @__PURE__ */ new Set(),\n      ranges: /* @__PURE__ */ new Set(),\n      zoom: /* @__PURE__ */ new Set()\n    };\n    this.groupButtons = {\n      seriesType: [],\n      annotations: [],\n      annotationOptions: [],\n      ranges: [],\n      zoom: []\n    };\n    this.ariaToolbars = [\n      { groups: [\"seriesType\", \"annotations\"], destroyFns: [], resetListeners: () => {\n      } },\n      { groups: [\"annotationOptions\"], destroyFns: [], resetListeners: () => {\n      } },\n      { groups: [\"ranges\"], destroyFns: [], resetListeners: () => {\n      } },\n      { groups: [\"zoom\"], destroyFns: [], resetListeners: () => {\n      } }\n    ];\n    this.pendingButtonToggledEvents = [];\n    this.groupProxied = /* @__PURE__ */ new Map();\n    this.hasNewLocale = true;\n    this.elements = {};\n    for (const position of TOOLBAR_POSITIONS) {\n      this.elements[position] = ctx.domManager.addChild(\"canvas-overlay\", `toolbar-${position}`);\n      this.elements[position].role = \"presentation\";\n      this.renderToolbar(position);\n    }\n    this.toggleVisibilities();\n    const dragStates = 32 /* Default */ | 8 /* Annotations */;\n    const seriesRegion = ctx.regionManager.getRegion(\"series\");\n    this.destroyFns.push(\n      ctx.interactionManager.addListener(\"hover\", this.onHover.bind(this), 63 /* All */),\n      ctx.interactionManager.addListener(\"leave\", this.onLeave.bind(this), 63 /* All */),\n      seriesRegion.addListener(\"drag-start\", this.toggleNoPointerEvents.bind(this, true), dragStates),\n      seriesRegion.addListener(\"drag-end\", this.toggleNoPointerEvents.bind(this, false), 63 /* All */),\n      ctx.toolbarManager.addListener(\"button-toggled\", this.onButtonToggled.bind(this)),\n      ctx.toolbarManager.addListener(\"button-updated\", this.onButtonUpdated.bind(this)),\n      ctx.toolbarManager.addListener(\"group-toggled\", this.onGroupToggled.bind(this)),\n      ctx.toolbarManager.addListener(\"group-updated\", this.onGroupUpdated.bind(this)),\n      ctx.toolbarManager.addListener(\"floating-anchor-changed\", this.onFloatingAnchorChanged.bind(this)),\n      ctx.toolbarManager.addListener(\"proxy-group-options\", this.onProxyGroupOptions.bind(this)),\n      ctx.layoutManager.registerElement(2 /* Toolbar */, this.onLayoutStart.bind(this)),\n      ctx.layoutManager.addListener(\"layout:complete\", this.onLayoutComplete.bind(this)),\n      ctx.updateService.addListener(\"pre-dom-update\", this.onPreDomUpdate.bind(this)),\n      ctx.updateService.addListener(\"update-complete\", this.onUpdateComplete.bind(this)),\n      ctx.localeManager.addListener(\"locale-changed\", () => {\n        this.hasNewLocale = true;\n      }),\n      () => this.destroyElements()\n    );\n  }\n  destroyElements() {\n    this.ctx.domManager.removeStyles(block);\n    for (const element2 of Object.keys(this.elements)) {\n      this.ctx.domManager.removeChild(\"canvas-overlay\", `toolbar-${element2}`);\n    }\n  }\n  onHover(event) {\n    const {\n      enabled,\n      elements: elements2,\n      floatingDetectionRange,\n      ctx: { scene }\n    } = this;\n    const {\n      offsetY,\n      sourceEvent: { target }\n    } = event;\n    const { FloatingBottom, FloatingTop } = ToolbarPosition;\n    if (!enabled)\n      return;\n    const bottom = elements2[FloatingBottom];\n    const top = elements2[FloatingTop];\n    const bottomDetectionY = bottom.offsetTop - floatingDetectionRange;\n    const bottomVisible = offsetY > bottomDetectionY && offsetY < scene.canvas.element.offsetHeight || target === bottom;\n    const topDetectionY = top.offsetTop + top.offsetHeight + floatingDetectionRange;\n    const topVisible = offsetY > 0 && offsetY < topDetectionY || target === top;\n    this.translateFloatingElements(FloatingBottom, bottomVisible);\n    this.translateFloatingElements(FloatingTop, topVisible);\n  }\n  onLeave(event) {\n    const {\n      enabled,\n      ctx: { scene }\n    } = this;\n    const { relatedElement, targetElement } = event;\n    const { FloatingBottom, FloatingTop } = ToolbarPosition;\n    if (!enabled || targetElement !== scene.canvas.element)\n      return;\n    const isTargetButton = TOOLBAR_GROUPS.some(\n      (group) => this.groupButtons[group].some((button) => button === relatedElement)\n    );\n    if (isTargetButton)\n      return;\n    this.translateFloatingElements(FloatingBottom, false);\n    this.translateFloatingElements(FloatingTop, false);\n  }\n  // AG-12695 Temporarily set `pointer-events: none` on the annotationOptions when dragging, because the\n  // buttons block to mouse from hovering over the canvas.\n  toggleNoPointerEvents(on) {\n    const className = \"ag-charts-toolbar__no-pointer-events\";\n    this.groupButtons[\"annotationOptions\"].forEach((b) => b.classList.toggle(className, on));\n  }\n  onGroupChanged(group) {\n    if (this[group] == null || this.groupProxied.has(group))\n      return;\n    this.createGroup(group);\n    this.toggleVisibilities();\n  }\n  onGroupButtonsChanged(group, buttons, configurationOnly) {\n    if (!this.enabled || this.groupProxied.has(group))\n      return;\n    if (configurationOnly) {\n      for (const buttonOptions of this[group].buttonConfigurations()) {\n        this.refreshButtonContent(group, buttonOptions);\n      }\n    } else {\n      this.createGroupButtons(group, buttons);\n    }\n    this.toggleVisibilities();\n  }\n  onLayoutComplete(opts) {\n    for (const position of TOOLBAR_POSITIONS) {\n      this.elements[position].classList.remove(modifiers.preventFlash);\n    }\n    if (this.enabled) {\n      this.refreshInnerLayout(opts.series.rect);\n    }\n  }\n  toggleButtonsTransition(enabled) {\n    const className = modifiers.button.withTransition;\n    for (const button of Object.values(this.groupButtons).flat()) {\n      if (enabled && !button.classList.contains(className)) {\n        button.getBoundingClientRect();\n      }\n      button.classList.toggle(className, enabled);\n    }\n  }\n  onPreDomUpdate() {\n    this.toggleButtonsTransition(false);\n  }\n  onUpdateComplete() {\n    this.toggleButtonsTransition(true);\n  }\n  onButtonUpdated(event) {\n    const { type: _type, group, id, ...params } = event;\n    this[group].overrideButtonConfiguration(id, params);\n  }\n  setButtonActive(button, active) {\n    button.classList.toggle(modifiers.button.active, active);\n  }\n  setButtonChecked(button, checked) {\n    if (button.role === \"switch\") {\n      button.ariaChecked = checked.toString();\n    }\n  }\n  setButtonGroupFirstLast(group) {\n    const childNodes = Array.from(group.childNodes ?? []);\n    const setFirstClass = (first2, button, modifier) => {\n      const buttonVisible = !button.classList.contains(modifiers.button.hiddenToggled);\n      button.classList.toggle(modifier, buttonVisible && first2);\n      return buttonVisible ? false : first2;\n    };\n    let first = true;\n    childNodes.forEach((button) => first = setFirstClass(first, button, modifiers.button.first));\n    let last = true;\n    childNodes.toReversed().forEach((button) => last = setFirstClass(last, button, modifiers.button.last));\n  }\n  onButtonToggled(event) {\n    const { group, id, active, enabled, visible, checked } = event;\n    if (this.groupButtons[group].length === 0) {\n      this.pendingButtonToggledEvents.push(event);\n      return;\n    }\n    const button = this.groupButtons[group].find((b) => b.dataset.toolbarId === `${id}`);\n    if (button == null)\n      return;\n    button.ariaDisabled = `${!enabled}`;\n    button.classList.toggle(modifiers.button.hiddenToggled, !visible);\n    this.setButtonActive(button, active);\n    this.setButtonChecked(button, checked);\n    this.setButtonGroupFirstLast(button.parentNode);\n  }\n  onGroupToggled(event) {\n    const { caller, group, active, visible } = event;\n    this.toggleGroup(caller, group, active, visible);\n    this.toggleVisibilities();\n  }\n  onGroupUpdated(event) {\n    const { group } = event;\n    for (const ariaToolbar of this.ariaToolbars) {\n      if (ariaToolbar.groups.includes(group)) {\n        ariaToolbar.resetListeners();\n        return;\n      }\n    }\n  }\n  onFloatingAnchorChanged(event) {\n    const { elements: elements2, positions, horizontalSpacing, verticalSpacing } = this;\n    const { group, anchor } = event;\n    const element2 = elements2[\"floating\" /* Floating */];\n    if (this.dragState.detached || element2.classList.contains(modifiers.hidden)) {\n      return;\n    }\n    this.dragState.detached = false;\n    if (!positions[\"floating\" /* Floating */].has(group))\n      return;\n    const position = anchor.position ?? \"above\";\n    const { offsetWidth: width2, offsetHeight: height2 } = element2;\n    let top = anchor.y - height2 - verticalSpacing;\n    let left = anchor.x - width2 / 2;\n    if (position === \"below\") {\n      top = anchor.y + verticalSpacing;\n    } else if (position === \"right\") {\n      top = anchor.y - height2 / 2;\n      left = anchor.x + horizontalSpacing;\n    } else if (position === \"above-left\") {\n      left = anchor.x;\n    }\n    const groupBBox = new BBox(left, top, width2, height2);\n    this.positionGroup(element2, group, groupBBox);\n  }\n  positionGroup(element2, group, bbox) {\n    const {\n      ctx: { domManager }\n    } = this;\n    const canvasRect = domManager.getBoundingClientRect();\n    bbox.x = clamp(0, bbox.x, canvasRect.width - bbox.width);\n    bbox.y = clamp(0, bbox.y, canvasRect.height - bbox.height);\n    const left = `${Math.floor(bbox.x)}px`;\n    const top = `${Math.floor(bbox.y)}px`;\n    const dirty = element2.style.getPropertyValue(\"left\") !== left || element2.style.getPropertyValue(\"top\") !== top;\n    if (!dirty)\n      return;\n    element2.style.setProperty(\"left\", left);\n    element2.style.setProperty(\"top\", top);\n    this.onGroupMoved(group, bbox);\n  }\n  onGroupMoved(group, bbox) {\n    const {\n      groupButtons,\n      ctx: { toolbarManager }\n    } = this;\n    for (const button of groupButtons[group]) {\n      if (button.classList.contains(modifiers.button.hiddenToggled))\n        continue;\n      const parent = button.offsetParent;\n      toolbarManager.buttonMoved(\n        group,\n        button.dataset.toolbarId,\n        new BBox(\n          button.offsetLeft + (parent?.offsetLeft ?? 0),\n          button.offsetTop + (parent?.offsetTop ?? 0),\n          button.offsetWidth,\n          button.offsetHeight\n        ),\n        bbox\n      );\n    }\n  }\n  buttonRect(button, canvasRect = this.ctx.domManager.getBoundingClientRect()) {\n    const buttonRect = button.getBoundingClientRect();\n    return new BBox(\n      buttonRect.left - canvasRect.left,\n      buttonRect.top - canvasRect.top,\n      buttonRect.width,\n      buttonRect.height\n    );\n  }\n  onProxyGroupOptions(event) {\n    if (!this.enabled)\n      return;\n    const { caller, group, options } = event;\n    this.groupProxied.set(group, options);\n    this[group].set(options);\n    this.toggleGroup(caller, group, void 0, options.enabled);\n    this.createGroup(group, options.enabled, options.position);\n    if (options.enabled) {\n      this.createGroupButtons(group, options.buttons);\n    }\n  }\n  createGroup(group, enabled, position) {\n    enabled ?? (enabled = this[group].enabled);\n    position ?? (position = this[group].position);\n    for (const pos of TOOLBAR_POSITIONS) {\n      if (enabled && position === pos) {\n        this.positions[pos].add(group);\n      } else {\n        this.positions[pos].delete(group);\n      }\n    }\n  }\n  createGroupButtons(group, buttons = []) {\n    for (const button of this.groupButtons[group]) {\n      button.remove();\n    }\n    this.groupButtons[group] = [];\n    if (buttons.length === 0)\n      return;\n    const { align, position } = this[group];\n    const alignElement = this.positionAlignments[position][align];\n    if (!alignElement)\n      return;\n    const nextSection = (section2) => {\n      const alignElementChildren = Array.from(alignElement.children);\n      const dataGroup = \"data-group\";\n      const dataSection = \"data-section\";\n      let sectionElement = alignElementChildren.find((prevSection2) => {\n        return prevSection2.getAttribute(dataGroup) === group && prevSection2.getAttribute(dataSection) === (section2 ?? \"\");\n      });\n      if (!sectionElement) {\n        sectionElement = createElement(\"div\");\n        sectionElement.role = \"presentation\";\n        sectionElement.setAttribute(dataGroup, group);\n        sectionElement.setAttribute(dataSection, section2 ?? \"\");\n        const groupIndex = TOOLBAR_GROUP_ORDERING[group];\n        const insertBeforeElement = alignElementChildren.find((prevSection2) => {\n          const prevGroup = prevSection2.getAttribute(dataGroup);\n          const prevGroupIndex = TOOLBAR_GROUP_ORDERING[prevGroup];\n          return prevGroupIndex > groupIndex;\n        });\n        if (insertBeforeElement != null) {\n          alignElement.insertBefore(sectionElement, insertBeforeElement);\n        } else {\n          alignElement.appendChild(sectionElement);\n        }\n        this.destroyFns.push(() => sectionElement.remove());\n      }\n      sectionElement.classList.add(elements.section, modifiers[this[group].size]);\n      return sectionElement;\n    };\n    let prevSection = buttons.at(0)?.section;\n    let section = nextSection(prevSection);\n    for (const options of buttons) {\n      if (prevSection !== options.section) {\n        this.setButtonGroupFirstLast(section);\n        section = nextSection(options.section);\n      }\n      prevSection = options.section;\n      const button = this.createButtonElement(group, options);\n      section.appendChild(button);\n      this.groupButtons[group].push(button);\n    }\n    this.setButtonGroupFirstLast(section);\n    const onEscape = () => {\n      this.ctx.toolbarManager.cancel(group);\n    };\n    let onFocus;\n    let onBlur;\n    if (isAnimatingFloatingPosition(position)) {\n      onFocus = () => this.translateFloatingElements(position, true);\n      onBlur = () => this.translateFloatingElements(position, false);\n    }\n    this.createAriaToolbar(group, alignElement, onFocus, onBlur, onEscape);\n  }\n  createAriaToolbar(group, toolbar, onFocus, onBlur, onEscape) {\n    const orientation = this.computeAriaOrientation(this[group].position);\n    const ariaToolbar = this.getAriaToolbar(group);\n    ariaToolbar.resetListeners = () => {\n      const buttons = ariaToolbar.groups.map((g) => this.groupButtons[g]).flat().filter(\n        (b) => !b.classList.contains(modifiers.button.hiddenToggled) && !b.classList.contains(modifiers.button.dragHandle)\n      );\n      ariaToolbar.destroyFns.forEach((d) => d());\n      ariaToolbar.destroyFns = initToolbarKeyNav({ orientation, toolbar, buttons, onEscape, onFocus, onBlur });\n    };\n    ariaToolbar.resetListeners();\n    this.updateToolbarAriaLabel(group, toolbar);\n  }\n  computeAriaOrientation(position) {\n    return {\n      top: \"horizontal\",\n      right: \"vertical\",\n      bottom: \"horizontal\",\n      left: \"vertical\",\n      floating: \"horizontal\",\n      \"floating-top\": \"horizontal\",\n      \"floating-bottom\": \"horizontal\"\n    }[position];\n  }\n  toggleGroup(caller, group, active, enabled) {\n    if (enabled === true) {\n      this.groupCallers[group].add(caller);\n    } else if (enabled === false) {\n      this.groupCallers[group].delete(caller);\n    }\n    if (active != null) {\n      for (const button of this.groupButtons[group]) {\n        this.setButtonActive(button, active);\n      }\n    }\n  }\n  processPendingEvents() {\n    const pendingButtonToggledEvents = (this.pendingButtonToggledEvents ?? []).slice();\n    for (const event of pendingButtonToggledEvents) {\n      this.onButtonToggled(event);\n    }\n    this.pendingButtonToggledEvents = [];\n  }\n  onLayoutStart(ctx) {\n    if (this.enabled) {\n      this.refreshOuterLayout(ctx.layoutBox);\n      this.refreshLocale();\n    }\n  }\n  refreshOuterLayout(shrinkRect) {\n    const { elements: elements2, horizontalSpacing, verticalSpacing } = this;\n    if (!elements2.top.classList.contains(modifiers.hidden)) {\n      shrinkRect.shrink(elements2.top.offsetHeight + verticalSpacing, \"top\");\n    }\n    if (!elements2.right.classList.contains(modifiers.hidden)) {\n      shrinkRect.shrink(elements2.right.offsetWidth + horizontalSpacing, \"right\");\n    }\n    if (!elements2.bottom.classList.contains(modifiers.hidden)) {\n      shrinkRect.shrink(elements2.bottom.offsetHeight + verticalSpacing, \"bottom\");\n      elements2.bottom.style.top = `${shrinkRect.y + shrinkRect.height + verticalSpacing}px`;\n    }\n    if (!elements2.left.classList.contains(modifiers.hidden)) {\n      shrinkRect.shrink(elements2.left.offsetWidth + horizontalSpacing, \"left\");\n    }\n  }\n  refreshLocale() {\n    const { hasNewLocale } = this;\n    if (!hasNewLocale)\n      return;\n    for (const group of TOOLBAR_GROUPS) {\n      const buttons = this[group].buttonConfigurations();\n      for (const buttonOptions of buttons) {\n        this.refreshButtonContent(group, buttonOptions);\n      }\n      this.updateToolbarAriaLabel(group);\n    }\n    this.hasNewLocale = false;\n  }\n  refreshInnerLayout(rect) {\n    const { elements: elements2, verticalSpacing } = this;\n    const { FloatingBottom, FloatingTop } = ToolbarPosition;\n    elements2.top.style.top = `${rect.y - elements2.top.offsetHeight - verticalSpacing}px`;\n    elements2.top.style.left = `${rect.x}px`;\n    elements2.top.style.width = `${rect.width}px`;\n    elements2.bottom.style.left = `${rect.x}px`;\n    elements2.bottom.style.width = `${rect.width}px`;\n    elements2.right.style.top = `${rect.y}px`;\n    elements2.right.style.right = `0px`;\n    elements2.right.style.height = `${rect.height}px`;\n    elements2.left.style.top = `${rect.y}px`;\n    elements2.left.style.left = `0px`;\n    elements2.left.style.height = `${rect.height}px`;\n    elements2[FloatingTop].style.top = `${rect.y}px`;\n    elements2[FloatingBottom].style.top = `${rect.y + rect.height - elements2[FloatingBottom].offsetHeight}px`;\n  }\n  refreshButtonContent(group, buttonOptions) {\n    const id = this.buttonId(buttonOptions);\n    const button = this.groupProxied.get(group)?.buttons?.find((b) => this.buttonId(b) === id) ?? buttonOptions;\n    const element2 = this.groupButtons[group].find((b) => b.getAttribute(\"data-toolbar-id\") === id);\n    if (element2 == null)\n      return;\n    this.updateButton(element2, button);\n  }\n  toggleVisibilities() {\n    if (this.elements == null)\n      return;\n    const isGroupVisible = (group) => this[group].enabled && this.groupCallers[group].size > 0;\n    const isButtonVisible = (element2) => (button) => {\n      const id = this.buttonId(button);\n      return id == null || id === element2.dataset.toolbarId;\n    };\n    for (const position of TOOLBAR_POSITIONS) {\n      const visible = this.enabled && Array.from(this.positions[position].values()).some(isGroupVisible);\n      if (position === \"floating\" /* Floating */ && !visible) {\n        this.dragState.detached = false;\n      }\n      this.elements[position].classList.toggle(modifiers.hidden, !visible);\n    }\n    for (const group of TOOLBAR_GROUPS) {\n      if (this[group] == null)\n        continue;\n      const groupVisible = isGroupVisible(group);\n      for (const button of this.groupButtons[group]) {\n        const buttonVisible = groupVisible && this[group].buttonConfigurations().some(isButtonVisible(button));\n        button.classList.toggle(modifiers.button.hiddenValue, !buttonVisible);\n      }\n    }\n  }\n  translateFloatingElements(position, visible) {\n    const { elements: elements2, verticalSpacing: verticalMargin, positionAlignments } = this;\n    const element2 = elements2[position];\n    const alignments = Object.values(positionAlignments[position]);\n    element2.classList.toggle(modifiers.floatingHidden, !visible);\n    const dir = position === \"floating-bottom\" /* FloatingBottom */ ? 1 : -1;\n    for (const align of alignments) {\n      align.style.transform = visible && align.style.transform !== \"\" ? \"translateY(0)\" : `translateY(${(element2.offsetHeight + verticalMargin) * dir}px)`;\n    }\n  }\n  renderToolbar(position = \"top\" /* Top */) {\n    const element2 = this.elements[position];\n    element2.classList.add(block, modifiers[position], modifiers.preventFlash);\n    if (isAnimatingFloatingPosition(position)) {\n      element2.classList.add(modifiers.floatingHidden);\n    }\n    for (const align of TOOLBAR_ALIGNMENTS) {\n      const alignmentElement = createElement(\"div\");\n      alignmentElement.role = \"presentation\";\n      alignmentElement.classList.add(elements.align, modifiers.align[align]);\n      element2.appendChild(alignmentElement);\n      this.positionAlignments[position][align] = alignmentElement;\n    }\n  }\n  createButtonElement(group, options) {\n    const button = createElement(\"button\");\n    button.classList.add(elements.button);\n    button.dataset.toolbarGroup = group;\n    setAttribute(button, \"tabindex\", -1);\n    if (options.haspopup) {\n      setAttributes(button, { \"aria-haspopup\": true, \"aria-expanded\": false });\n    }\n    button.dataset.toolbarId = this.buttonId(options);\n    button.addEventListener(\n      \"click\",\n      makeAccessibleClickListener(\n        button,\n        (event) => this.onButtonPress(event, button, group, options.id, options.value)\n      )\n    );\n    if (options.value === \"drag\") {\n      button.addEventListener(\n        \"mousedown\",\n        makeAccessibleClickListener(button, (event) => this.onDragStart(event, button, group))\n      );\n      button.classList.add(modifiers.button.dragHandle);\n    }\n    if (options.role === \"switch\") {\n      setAttributes(button, { role: options.role, \"aria-checked\": false });\n    }\n    this.updateButton(button, options);\n    this.destroyFns.push(() => button.remove());\n    return button;\n  }\n  getAriaToolbar(group) {\n    for (const ariaToolbar of this.ariaToolbars) {\n      if (ariaToolbar.groups.includes(group)) {\n        return ariaToolbar;\n      }\n    }\n    throw new Error(`AG Charts - cannot find aria-toolbar of '${group}'`);\n  }\n  updateToolbarAriaLabel(group, alignElement) {\n    if (!alignElement) {\n      const { align, position } = this[group];\n      alignElement = this.positionAlignments[position][align];\n      if (!alignElement)\n        return;\n    }\n    const map = {\n      seriesType: \"ariaLabelFinancialCharts\",\n      annotations: \"ariaLabelFinancialCharts\",\n      annotationOptions: \"ariaLabelAnnotationOptionsToolbar\",\n      ranges: \"ariaLabelRangesToolbar\",\n      zoom: \"ariaLabelZoomToolbar\"\n    };\n    alignElement.ariaLabel = this.ctx.localeManager.t(map[group]);\n  }\n  expandButtonConfig(button, options) {\n    if (options.role !== \"switch\" || button.ariaChecked !== \"true\" || options.checkedOverrides === void 0)\n      return options;\n    return {\n      icon: options.checkedOverrides.icon ?? options.icon,\n      label: options.checkedOverrides.label ?? options.label,\n      ariaLabel: options.checkedOverrides.ariaLabel ?? options.ariaLabel,\n      tooltip: options.checkedOverrides.tooltip ?? options.tooltip\n    };\n  }\n  updateButton(button, options) {\n    const { domManager, localeManager } = this.ctx;\n    const { icon, label, ariaLabel, tooltip } = this.expandButtonConfig(button, options);\n    if (tooltip) {\n      button.title = localeManager.t(tooltip);\n    }\n    let inner = \"\";\n    if (icon != null) {\n      inner = `<span class=\"${domManager.getIconClassNames(icon)} ${elements.icon}\"></span>`;\n    }\n    if (label != null) {\n      const tlabel = localeManager.t(label);\n      inner = `${inner}<span class=\"${elements.label}\">${tlabel}</span>`;\n    }\n    button.innerHTML = inner;\n    button.classList.toggle(modifiers.button.fillVisible, options.fill != null);\n    button.style.setProperty(\"--fill\", options.fill ?? null);\n    const strokeWidthVisible = options.strokeWidth != null;\n    button.classList.toggle(modifiers.button.strokeWidthVisible, strokeWidthVisible);\n    button.style.setProperty(\"--strokeWidth\", strokeWidthVisible ? `${options.strokeWidth}px` : null);\n    const tAriaLabel = ariaLabel ? this.ctx.localeManager.t(ariaLabel) : void 0;\n    setAttribute(button, \"aria-label\", tAriaLabel);\n  }\n  onButtonPress(event, button, group, id, value) {\n    this.ctx.toolbarManager.pressButton(group, this.buttonId({ id, value }), value, this.buttonRect(button), event);\n  }\n  onDragStart(event, button, group) {\n    const element2 = this.elements[\"floating\" /* Floating */];\n    event.preventDefault();\n    event.stopPropagation();\n    this.dragState = {\n      client: Vec2.from(event.clientX, event.clientY),\n      position: Vec2.from(\n        Number(element2.style.getPropertyValue(\"left\").replace(\"px\", \"\")),\n        Number(element2.style.getPropertyValue(\"top\").replace(\"px\", \"\"))\n      ),\n      detached: true\n    };\n    button.classList.toggle(modifiers.button.dragging, true);\n    const onDrag = (e) => this.onDrag(e, group);\n    const onDragEnd = () => {\n      button.classList.toggle(modifiers.button.dragging, false);\n      window2.removeEventListener(\"mousemove\", onDrag);\n    };\n    const window2 = getWindow();\n    window2.addEventListener(\"mousemove\", onDrag);\n    window2.addEventListener(\"mouseup\", onDragEnd, {\n      once: true\n    });\n    this.ctx.toolbarManager.groupMoved(group);\n  }\n  onDrag(event, group) {\n    const { elements: elements2, dragState } = this;\n    const element2 = elements2[\"floating\" /* Floating */];\n    const { offsetWidth: width2, offsetHeight: height2 } = element2;\n    const offset4 = Vec2.sub(Vec2.from(event.clientX, event.clientY), dragState.client);\n    const position = Vec2.add(dragState.position, offset4);\n    const groupBBox = new BBox(position.x, position.y, width2, height2);\n    this.positionGroup(element2, group, groupBBox);\n  }\n  buttonId(button) {\n    const { id, value, label } = button;\n    if (id != null) {\n      return id;\n    } else if (value != null && typeof value !== \"object\") {\n      return String(value);\n    }\n    return label ?? \"\";\n  }\n};\n__decorateClass([\n  ObserveChanges((target) => {\n    target.processPendingEvents();\n    target.toggleVisibilities();\n  }),\n  Validate(BOOLEAN)\n], Toolbar.prototype, \"enabled\", 2);\n\n// packages/ag-charts-community/src/chart/toolbar/toolbarModule.ts\nvar DAY = 1e3 * 60 * 60 * 24;\nvar MONTH = DAY * 30;\nvar YEAR = DAY * 365;\nvar seriesType = {\n  enabled: false,\n  position: \"left\",\n  align: \"start\",\n  buttons: [\n    {\n      tooltip: \"toolbarSeriesTypeDropdown\",\n      value: \"type\",\n      // @ts-expect-error\n      haspopup: true\n    }\n  ]\n};\nvar annotations = {\n  enabled: true,\n  position: \"left\",\n  align: \"start\",\n  buttons: [\n    {\n      icon: \"trend-line-drawing\",\n      tooltip: \"toolbarAnnotationsLineAnnotations\",\n      value: \"line-menu\",\n      section: \"line-annotations\",\n      // @ts-expect-error\n      haspopup: true\n    },\n    {\n      icon: \"text-annotation\",\n      tooltip: \"toolbarAnnotationsTextAnnotations\",\n      value: \"text-menu\",\n      section: \"text-annotations\",\n      // @ts-expect-error\n      haspopup: true\n    },\n    {\n      icon: \"arrow-drawing\",\n      tooltip: \"toolbarAnnotationsShapeAnnotations\",\n      value: \"shape-menu\",\n      section: \"shape-annotations\",\n      // @ts-expect-error\n      haspopup: true\n    },\n    {\n      icon: \"measurer-drawing\",\n      tooltip: \"toolbarAnnotationsMeasurerAnnotations\",\n      value: \"measurer-menu\",\n      section: \"measure-annotations\",\n      // @ts-expect-error\n      haspopup: true\n    },\n    {\n      icon: \"delete\",\n      tooltip: \"toolbarAnnotationsClearAll\",\n      value: \"clear\",\n      section: \"tools\"\n    }\n  ]\n};\nvar annotationOptions = {\n  enabled: true,\n  position: \"floating\",\n  align: \"start\",\n  draggable: true,\n  buttons: [\n    {\n      icon: \"text-annotation\",\n      tooltip: \"toolbarAnnotationsTextColor\",\n      value: \"text-color\",\n      // @ts-expect-error\n      haspopup: true\n    },\n    {\n      icon: \"line-color\",\n      tooltip: \"toolbarAnnotationsLineColor\",\n      value: \"line-color\",\n      // @ts-expect-error\n      haspopup: true\n    },\n    {\n      icon: \"fill-color\",\n      tooltip: \"toolbarAnnotationsFillColor\",\n      value: \"fill-color\",\n      // @ts-expect-error\n      haspopup: true\n    },\n    {\n      tooltip: \"toolbarAnnotationsTextSize\",\n      value: \"text-size\",\n      // @ts-expect-error\n      haspopup: true\n    },\n    {\n      tooltip: \"toolbarAnnotationsLineStrokeWidth\",\n      value: \"line-stroke-width\",\n      // @ts-expect-error\n      haspopup: true\n    },\n    {\n      icon: \"line-style-solid\",\n      tooltip: \"toolbarAnnotationsLineStyle\",\n      value: \"line-style-type\",\n      // @ts-expect-error\n      haspopup: true\n    },\n    {\n      icon: \"settings\",\n      tooltip: \"toolbarAnnotationsSettings\",\n      value: \"settings\",\n      // @ts-expect-error\n      haspopup: true\n    },\n    {\n      role: \"switch\",\n      icon: \"unlocked\",\n      tooltip: \"toolbarAnnotationsLock\",\n      ariaLabel: \"toolbarAnnotationsLock\",\n      checkedOverrides: {\n        icon: \"locked\",\n        tooltip: \"toolbarAnnotationsUnlock\"\n      },\n      value: \"lock\"\n    },\n    {\n      icon: \"delete\",\n      tooltip: \"toolbarAnnotationsDelete\",\n      value: \"delete\"\n    }\n  ]\n};\nvar ranges = {\n  enabled: false,\n  position: DEFAULT_TOOLBAR_POSITION,\n  align: \"start\",\n  buttons: [\n    {\n      label: \"toolbarRange1Month\",\n      ariaLabel: \"toolbarRange1MonthAria\",\n      value: MONTH\n    },\n    {\n      label: \"toolbarRange3Months\",\n      ariaLabel: \"toolbarRange3MonthsAria\",\n      value: 3 * MONTH\n    },\n    {\n      label: \"toolbarRange6Months\",\n      ariaLabel: \"toolbarRange6MonthsAria\",\n      value: 6 * MONTH\n    },\n    {\n      label: \"toolbarRangeYearToDate\",\n      ariaLabel: \"toolbarRangeYearToDateAria\",\n      value: (_start, end2) => [(/* @__PURE__ */ new Date(`${new Date(end2).getFullYear()}-01-01`)).getTime(), end2],\n      id: \"year-to-date\"\n    },\n    {\n      label: \"toolbarRange1Year\",\n      ariaLabel: \"toolbarRange1YearAria\",\n      value: YEAR\n    },\n    {\n      label: \"toolbarRangeAll\",\n      ariaLabel: \"toolbarRangeAllAria\",\n      value: (start2, end2) => [start2, end2],\n      id: \"all\"\n    }\n  ]\n};\nvar zoom = {\n  enabled: true,\n  position: \"top\",\n  align: \"end\",\n  buttons: [\n    {\n      icon: \"zoom-out\",\n      tooltip: \"toolbarZoomZoomOut\",\n      value: \"zoom-out\"\n    },\n    {\n      icon: \"zoom-in\",\n      tooltip: \"toolbarZoomZoomIn\",\n      value: \"zoom-in\"\n    },\n    {\n      icon: \"pan-left\",\n      tooltip: \"toolbarZoomPanLeft\",\n      value: \"pan-left\"\n    },\n    {\n      icon: \"pan-right\",\n      tooltip: \"toolbarZoomPanRight\",\n      value: \"pan-right\"\n    },\n    {\n      icon: \"pan-start\",\n      tooltip: \"toolbarZoomPanStart\",\n      value: \"pan-start\"\n    },\n    {\n      icon: \"pan-end\",\n      tooltip: \"toolbarZoomPanEnd\",\n      value: \"pan-end\"\n    },\n    {\n      icon: \"reset\",\n      tooltip: \"toolbarZoomReset\",\n      value: \"reset\"\n    }\n  ]\n};\nvar ToolbarModule = {\n  type: \"root\",\n  optionsKey: \"toolbar\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  moduleFactory: (ctx) => new Toolbar(ctx),\n  themeTemplate: {\n    toolbar: {\n      enabled: true,\n      seriesType,\n      annotations,\n      annotationOptions,\n      ranges,\n      zoom\n    }\n  }\n};\n\n// packages/ag-charts-community/src/chart/factory/registerInbuiltModules.ts\nfunction registerInbuiltModules() {\n  moduleRegistry.register(\n    BackgroundModule,\n    CommunityLegendModule,\n    LocaleModule,\n    NavigatorModule,\n    ToolbarModule,\n    AreaSeriesModule,\n    BarSeriesModule,\n    BubbleSeriesModule,\n    LineSeriesModule,\n    ScatterSeriesModule,\n    DonutSeriesModule,\n    PieSeriesModule,\n    HistogramSeriesModule\n  );\n  for (const AxisConstructor of [NumberAxis, CategoryAxis, TimeAxis, GroupedCategoryAxis, LogAxis]) {\n    axisRegistry.register(AxisConstructor.type, {\n      moduleFactory: (ctx) => new AxisConstructor(ctx),\n      hidden: AxisConstructor === GroupedCategoryAxis\n    });\n  }\n}\n\n// packages/ag-charts-community/src/chart/factory/setupModules.ts\nfunction setupModules() {\n  for (const m of moduleRegistry.modules) {\n    if (m.packageType === \"enterprise\" && !verifyIfModuleExpected(m)) {\n      Logger.errorOnce(\"Unexpected enterprise module registered: \" + m.identifier);\n    }\n    if (m.type === \"root\" && m.themeTemplate) {\n      for (const chartType2 of m.chartTypes) {\n        chartDefaults.set(chartType2, m.themeTemplate);\n      }\n    }\n    if (m.type === \"series\") {\n      if (m.chartTypes.length > 1) {\n        throw new Error(`AG Charts - Module definition error: ${m.identifier}`);\n      }\n      seriesRegistry.register(m.identifier, m);\n    }\n    if (m.type === \"series-option\" && m.themeTemplate) {\n      for (const seriesType2 of m.seriesTypes) {\n        seriesRegistry.setThemeTemplate(seriesType2, m.themeTemplate);\n      }\n    }\n    if (m.type === \"axis-option\" && m.themeTemplate) {\n      for (const axisType of m.axisTypes) {\n        const axisTypeTheme = axisRegistry.getThemeTemplate(axisType);\n        const theme = mergeDefaults(m.themeTemplate, axisTypeTheme);\n        axisRegistry.setThemeTemplate(axisType, theme);\n      }\n    }\n    if (m.type === \"axis\") {\n      axisRegistry.register(m.identifier, m);\n    }\n    if (m.type === \"legend\") {\n      legendRegistry.register(m.identifier, m);\n    }\n  }\n  if (moduleRegistry.hasEnterpriseModules()) {\n    const expectedButUnused = getUnusedExpectedModules();\n    if (expectedButUnused.length > 0) {\n      Logger.errorOnce(\"Enterprise modules expected but not registered: \", expectedButUnused);\n    }\n  }\n}\n\n// packages/ag-charts-community/src/chart/flowProportionChart.ts\nfunction isFlowProportion(series) {\n  return series.type === \"sankey\" || series.type === \"chord\";\n}\nvar FlowProportionChart = class extends Chart {\n  getChartType() {\n    return \"flow-proportion\";\n  }\n  async updateData() {\n    await super.updateData();\n    const { nodes } = this.getOptions();\n    this.series.forEach((series) => {\n      if (isFlowProportion(series)) {\n        series.setChartNodes(nodes);\n      }\n    });\n  }\n  performLayout(ctx) {\n    const { seriesRoot, annotationRoot, highlightRoot } = this;\n    const { layoutBox } = ctx;\n    const seriesRect = layoutBox.clone();\n    layoutBox.shrink(this.seriesArea.padding.toJson());\n    this.seriesRect = layoutBox;\n    this.animationRect = layoutBox;\n    seriesRoot.visible = this.series.some((s) => s.visible);\n    for (const group of [seriesRoot, annotationRoot, highlightRoot]) {\n      group.translationX = Math.floor(layoutBox.x);\n      group.translationY = Math.floor(layoutBox.y);\n      group.setClipRect(seriesRect.clone());\n    }\n    this.ctx.layoutManager.emitLayoutComplete(ctx, {\n      series: { visible: seriesRoot.visible, rect: seriesRect, paddedRect: layoutBox }\n    });\n  }\n};\nFlowProportionChart.className = \"FlowProportionChart\";\nFlowProportionChart.type = \"flow-proportion\";\n\n// packages/ag-charts-community/src/chart/axis/polarAxis.ts\nvar PolarAxis = class extends Axis {\n  constructor() {\n    super(...arguments);\n    this.shape = \"polygon\";\n    this.innerRadiusRatio = 0;\n    this.defaultTickMinSpacing = 20;\n  }\n  computeLabelsBBox(_options, _seriesRect) {\n    return null;\n  }\n  computeRange() {\n  }\n  getAxisLinePoints() {\n    return void 0;\n  }\n};\n__decorateClass([\n  Validate(UNION([\"polygon\", \"circle\"], \"a polar axis shape\"))\n], PolarAxis.prototype, \"shape\", 2);\n__decorateClass([\n  Validate(RATIO)\n], PolarAxis.prototype, \"innerRadiusRatio\", 2);\n\n// packages/ag-charts-community/src/chart/gaugeChart.ts\nfunction isRadialGaugeSeries(series) {\n  return series.type === \"radial-gauge\";\n}\nfunction isLinearGaugeSeries(series) {\n  return series.type === \"linear-gauge\";\n}\nvar GaugeChart = class extends Chart {\n  getChartType() {\n    return \"gauge\";\n  }\n  updateRadialGauge(seriesRect, series) {\n    const angleAxis = this.axes.find((axis) => axis.direction === \"x\" /* X */);\n    if (!(angleAxis instanceof PolarAxis))\n      return;\n    angleAxis.computeRange();\n    const seriesRectX0 = seriesRect.x;\n    const seriesRectX1 = seriesRectX0 + seriesRect.width;\n    const seriesRectY0 = seriesRect.y;\n    const seriesRectY1 = seriesRectY0 + seriesRect.height;\n    const [startAngle, endAngle] = angleAxis.range;\n    const sweepAngle = normalizeAngle360Inclusive(endAngle - startAngle);\n    const largerThanHalf = sweepAngle > Math.PI;\n    const containsTop = largerThanHalf || isBetweenAngles(1.5 * Math.PI, startAngle, endAngle);\n    const containsRight = largerThanHalf || isBetweenAngles(0 * Math.PI, startAngle, endAngle);\n    const containsBottom = largerThanHalf || isBetweenAngles(0.5 * Math.PI, startAngle, endAngle);\n    const containsLeft = largerThanHalf || isBetweenAngles(1 * Math.PI, startAngle, endAngle);\n    let textAlign;\n    if (containsLeft && !containsRight) {\n      textAlign = \"right\";\n    } else if (!containsLeft && containsRight) {\n      textAlign = \"left\";\n    } else {\n      textAlign = \"center\";\n    }\n    let verticalAlign;\n    if (containsTop && !containsBottom) {\n      verticalAlign = \"bottom\";\n    } else if (!containsTop && containsBottom) {\n      verticalAlign = \"top\";\n    } else {\n      verticalAlign = \"middle\";\n    }\n    const unitBox = sectorBox({\n      startAngle,\n      endAngle,\n      innerRadius: 0,\n      outerRadius: 0.5\n    });\n    const centerXOffset = -(unitBox.x + unitBox.width / 2) * 2;\n    const centerYOffset = -(unitBox.y + unitBox.height / 2) * 2;\n    const { minimumRadius = 0, maximumRadius } = series;\n    const radiusBounds = Math.max(\n      0.5 * Math.min(seriesRect.width / unitBox.width, seriesRect.height / unitBox.height),\n      // seriesRect may have negative size\n      0\n    );\n    let radius = Math.min(maximumRadius ?? Infinity, Math.max(radiusBounds, minimumRadius ?? 0));\n    const MAX_ITERATIONS = 8;\n    for (let i = 0; i < MAX_ITERATIONS; i += 1) {\n      const isFinalIteration = radius <= minimumRadius || i === MAX_ITERATIONS - 1;\n      const centerX = seriesRect.x + seriesRect.width / 2 + centerXOffset * radius;\n      const centerY = seriesRect.y + seriesRect.height / 2 + centerYOffset * radius;\n      angleAxis.translation.x = centerX;\n      angleAxis.translation.y = centerY;\n      angleAxis.gridLength = radius;\n      angleAxis.calculateLayout();\n      const bbox = angleAxis.computeLabelsBBox({ hideWhenNecessary: isFinalIteration }, seriesRect);\n      if (isFinalIteration)\n        break;\n      let shrinkDelta = 0;\n      if (bbox != null) {\n        const bboxX0 = bbox.x + centerX;\n        const bboxX1 = bboxX0 + bbox.width;\n        const bboxY0 = bbox.y + centerY;\n        const bboxY1 = bboxY0 + bbox.height;\n        shrinkDelta = Math.max(\n          seriesRectY0 - bboxY0,\n          seriesRectX0 - bboxX0,\n          bboxY1 - seriesRectY1,\n          bboxX1 - seriesRectX1,\n          0\n        );\n      }\n      if (shrinkDelta > 0) {\n        radius = Math.max(radius - shrinkDelta, minimumRadius);\n      } else {\n        break;\n      }\n    }\n    angleAxis.translation.x = seriesRect.x + seriesRect.width / 2 + centerXOffset * radius;\n    angleAxis.translation.y = seriesRect.y + seriesRect.height / 2 + centerYOffset * radius;\n    series.centerX = seriesRect.width / 2 + centerXOffset * radius;\n    series.centerY = seriesRect.height / 2 + centerYOffset * radius;\n    series.radius = radius;\n    series.textAlign = textAlign;\n    series.verticalAlign = verticalAlign;\n    if (radius === 0 || radius > radiusBounds) {\n      Logger.warnOnce(\"There was insufficient space to display the Radial Gauge.\");\n    }\n  }\n  updateLinearGauge(seriesRect, series) {\n    const xAxis = this.axes.find((axis) => axis.direction === \"x\" /* X */);\n    const yAxis = this.axes.find((axis) => axis.direction === \"y\" /* Y */);\n    if (!(xAxis instanceof CartesianAxis))\n      return seriesRect;\n    if (!(yAxis instanceof CartesianAxis))\n      return seriesRect;\n    const { horizontal, thickness } = series;\n    let horizontalInset = 0;\n    let verticalInset = 0;\n    const scale2 = new LinearScale();\n    scale2.domain = [0, 100];\n    scale2.range = horizontal ? xAxis.range : yAxis.range;\n    const ticks = scale2.ticks();\n    if (horizontal) {\n      horizontalInset = series.computeInset(\"x\" /* X */, ticks);\n    } else {\n      verticalInset = series.computeInset(\"y\" /* Y */, ticks);\n    }\n    const seriesWidth = seriesRect.width - Math.abs(horizontalInset);\n    const seriesHeight = seriesRect.height - Math.abs(verticalInset);\n    const width2 = Math.max(horizontal ? seriesWidth : thickness, 0);\n    const height2 = Math.max(horizontal ? thickness : seriesHeight, 0);\n    const x0 = seriesRect.x + (seriesWidth - width2) / 2 + Math.max(horizontalInset, 0);\n    const y0 = seriesRect.y + (seriesHeight - height2) / 2 - Math.min(verticalInset, 0);\n    xAxis.range = [0, width2];\n    xAxis.gridLength = width2;\n    xAxis.calculateLayout();\n    xAxis.translation.x = x0;\n    xAxis.translation.y = y0 + (xAxis.position === \"bottom\" ? thickness : 0);\n    yAxis.range = [0, height2];\n    yAxis.gridLength = height2;\n    yAxis.calculateLayout();\n    yAxis.translation.x = x0 + (yAxis.position === \"right\" ? thickness : 0);\n    yAxis.translation.y = y0;\n    series.originX = x0 - seriesRect.x;\n    series.originY = y0 - seriesRect.y;\n    if (width2 === 0 || height2 === 0) {\n      Logger.warnOnce(\"There was insufficient space to display the Linear Gauge.\");\n    }\n  }\n  performLayout(ctx) {\n    const { seriesRoot, annotationRoot, highlightRoot, series, seriesArea } = this;\n    const { layoutBox } = ctx;\n    const seriesRect = layoutBox.clone();\n    layoutBox.shrink(seriesArea.padding.toJson());\n    const firstSeries = this.series[0];\n    if (isRadialGaugeSeries(firstSeries)) {\n      this.updateRadialGauge(layoutBox, firstSeries);\n    } else if (isLinearGaugeSeries(firstSeries)) {\n      this.updateLinearGauge(layoutBox, firstSeries);\n    }\n    this.axes.forEach((axis) => axis.update());\n    this.seriesRect = seriesRect.clone().translate(seriesRect.x - layoutBox.x, seriesRect.y - layoutBox.y);\n    this.animationRect = layoutBox;\n    seriesRoot.visible = series.some((s) => s.visible);\n    for (const group of [seriesRoot, annotationRoot, highlightRoot]) {\n      group.translationX = Math.floor(layoutBox.x);\n      group.translationY = Math.floor(layoutBox.y);\n    }\n    this.ctx.layoutManager.emitLayoutComplete(ctx, {\n      series: { visible: seriesRoot.visible, rect: seriesRect, paddedRect: layoutBox }\n    });\n  }\n  getAriaLabel() {\n    const captions = [];\n    const chartCaption = this.getCaptionText();\n    if (chartCaption.length !== 0) {\n      captions.push(chartCaption);\n    }\n    for (const series of this.series) {\n      captions.push(series.getCaptionText());\n    }\n    const caption = captions.join(\". \");\n    return this.ctx.localeManager.t(\"ariaAnnounceGaugeChart\", { caption });\n  }\n};\nGaugeChart.className = \"GaugeChart\";\nGaugeChart.type = \"gauge\";\n\n// packages/ag-charts-community/src/chart/hierarchyChart.ts\nvar HierarchyChart = class extends Chart {\n  constructor(options, resources) {\n    super(options, resources);\n  }\n  getChartType() {\n    return \"hierarchy\";\n  }\n  performLayout(ctx) {\n    const { seriesRoot, annotationRoot, highlightRoot } = this;\n    const { layoutBox } = ctx;\n    const seriesRect = layoutBox.clone();\n    layoutBox.shrink(this.seriesArea.padding.toJson());\n    this.seriesRect = layoutBox;\n    this.animationRect = layoutBox;\n    for (const group of [seriesRoot, annotationRoot, highlightRoot]) {\n      group.translationX = Math.floor(layoutBox.x);\n      group.translationY = Math.floor(layoutBox.y);\n    }\n    seriesRoot.visible = this.series[0].visible;\n    seriesRoot.setClipRect(layoutBox.clone());\n    this.ctx.layoutManager.emitLayoutComplete(ctx, {\n      series: { visible: true, rect: seriesRect, paddedRect: layoutBox }\n    });\n  }\n  getAriaLabel() {\n    const caption = this.getCaptionText();\n    return this.ctx.localeManager.t(\"ariaAnnounceHierarchyChart\", { caption });\n  }\n};\nHierarchyChart.className = \"HierarchyChart\";\nHierarchyChart.type = \"hierarchy\";\n\n// packages/ag-charts-community/src/chart/polarChart.ts\nvar PolarChart = class extends Chart {\n  constructor(options, resources) {\n    super(options, resources);\n    this.padding = new Padding(40);\n    this.ctx.axisManager.axisGroup.zIndex = 6 /* AXIS_FOREGROUND */;\n  }\n  getChartType() {\n    return \"polar\";\n  }\n  async performLayout(ctx) {\n    const { layoutBox } = ctx;\n    const seriesRect = layoutBox.clone();\n    layoutBox.shrink(this.seriesArea.padding.toJson());\n    this.seriesRect = layoutBox;\n    this.animationRect = layoutBox;\n    await this.computeCircle(layoutBox);\n    this.axes.forEach((axis) => axis.update());\n    this.ctx.layoutManager.emitLayoutComplete(ctx, {\n      series: { visible: true, rect: seriesRect, paddedRect: layoutBox }\n    });\n  }\n  updateAxes(cx, cy, radius) {\n    const angleAxis = this.axes.find((axis) => axis.direction === \"x\" /* X */);\n    const radiusAxis = this.axes.find((axis) => axis.direction === \"y\" /* Y */);\n    if (!(angleAxis instanceof PolarAxis) || !(radiusAxis instanceof PolarAxis))\n      return;\n    const angleScale = angleAxis.scale;\n    const innerRadiusRatio = radiusAxis.innerRadiusRatio;\n    angleAxis.innerRadiusRatio = innerRadiusRatio;\n    angleAxis.computeRange();\n    angleAxis.gridLength = radius;\n    radiusAxis.gridAngles = angleScale.ticks?.().map((value) => angleScale.convert(value));\n    radiusAxis.gridRange = angleAxis.range;\n    radiusAxis.range = [radius, radius * innerRadiusRatio];\n    [angleAxis, radiusAxis].forEach((axis) => {\n      axis.translation.x = cx;\n      axis.translation.y = cy;\n      axis.calculateLayout();\n    });\n  }\n  async computeCircle(seriesBox) {\n    const polarSeries = this.series.filter(isPolarSeries);\n    const polarAxes = this.axes.filter(isPolarAxis);\n    const setSeriesCircle = (cx, cy, r) => {\n      this.updateAxes(cx, cy, r);\n      polarSeries.forEach((series) => {\n        series.centerX = cx;\n        series.centerY = cy;\n        series.radius = r;\n      });\n      const pieSeries = polarSeries.filter((s) => s.type === \"donut\" || s.type === \"pie\");\n      if (pieSeries.length > 1) {\n        const innerRadii = pieSeries.map((series) => {\n          const innerRadius = series.getInnerRadius();\n          return { series, innerRadius };\n        }).sort((a, b) => a.innerRadius - b.innerRadius);\n        innerRadii.at(-1).series.surroundingRadius = void 0;\n        for (let i = 0; i < innerRadii.length - 1; i++) {\n          innerRadii[i].series.surroundingRadius = innerRadii[i + 1].innerRadius;\n        }\n      }\n    };\n    const centerX = seriesBox.x + seriesBox.width / 2;\n    const centerY = seriesBox.y + seriesBox.height / 2;\n    const initialRadius = Math.max(0, Math.min(seriesBox.width, seriesBox.height) / 2);\n    let radius = initialRadius;\n    setSeriesCircle(centerX, centerY, radius);\n    const shake = async ({ hideWhenNecessary = false } = {}) => {\n      const labelBoxes = [];\n      for (const series of iterate(polarAxes, polarSeries)) {\n        const box = await series.computeLabelsBBox({ hideWhenNecessary }, seriesBox);\n        if (box) {\n          labelBoxes.push(box);\n        }\n      }\n      if (labelBoxes.length === 0) {\n        setSeriesCircle(centerX, centerY, initialRadius);\n        return;\n      }\n      const labelBox = BBox.merge(labelBoxes);\n      const refined = this.refineCircle(labelBox, radius, seriesBox);\n      setSeriesCircle(refined.centerX, refined.centerY, refined.radius);\n      radius = refined.radius;\n    };\n    await shake();\n    await shake();\n    await shake();\n    await shake({ hideWhenNecessary: true });\n    await shake({ hideWhenNecessary: true });\n    for (const series of iterate(polarAxes, polarSeries)) {\n      await series.computeLabelsBBox({ hideWhenNecessary: true }, seriesBox);\n    }\n    return { radius, centerX, centerY };\n  }\n  refineCircle(labelsBox, radius, seriesBox) {\n    const minCircleRatio = 0.5;\n    const circleLeft = -radius;\n    const circleTop = -radius;\n    const circleRight = radius;\n    const circleBottom = radius;\n    let padLeft = Math.max(0, circleLeft - labelsBox.x);\n    let padTop = Math.max(0, circleTop - labelsBox.y);\n    let padRight = Math.max(0, labelsBox.x + labelsBox.width - circleRight);\n    let padBottom = Math.max(0, labelsBox.y + labelsBox.height - circleBottom);\n    padLeft = padRight = Math.max(padLeft, padRight);\n    padTop = padBottom = Math.max(padTop, padBottom);\n    const availCircleWidth = seriesBox.width - padLeft - padRight;\n    const availCircleHeight = seriesBox.height - padTop - padBottom;\n    let newRadius = Math.min(availCircleWidth, availCircleHeight) / 2;\n    const minHorizontalRadius = minCircleRatio * seriesBox.width / 2;\n    const minVerticalRadius = minCircleRatio * seriesBox.height / 2;\n    const minRadius = Math.min(minHorizontalRadius, minVerticalRadius);\n    if (newRadius < minRadius) {\n      newRadius = minRadius;\n      const horizontalPadding = padLeft + padRight;\n      const verticalPadding = padTop + padBottom;\n      if (2 * newRadius + verticalPadding > seriesBox.height) {\n        const padHeight = seriesBox.height - 2 * newRadius;\n        if (Math.min(padTop, padBottom) * 2 > padHeight) {\n          padTop = padHeight / 2;\n          padBottom = padHeight / 2;\n        } else if (padTop > padBottom) {\n          padTop = padHeight - padBottom;\n        } else {\n          padBottom = padHeight - padTop;\n        }\n      }\n      if (2 * newRadius + horizontalPadding > seriesBox.width) {\n        const padWidth = seriesBox.width - 2 * newRadius;\n        if (Math.min(padLeft, padRight) * 2 > padWidth) {\n          padLeft = padWidth / 2;\n          padRight = padWidth / 2;\n        } else if (padLeft > padRight) {\n          padLeft = padWidth - padRight;\n        } else {\n          padRight = padWidth - padLeft;\n        }\n      }\n    }\n    const newWidth = padLeft + 2 * newRadius + padRight;\n    const newHeight = padTop + 2 * newRadius + padBottom;\n    return {\n      centerX: seriesBox.x + (seriesBox.width - newWidth) / 2 + padLeft + newRadius,\n      centerY: seriesBox.y + (seriesBox.height - newHeight) / 2 + padTop + newRadius,\n      radius: newRadius\n    };\n  }\n};\nPolarChart.className = \"PolarChart\";\nPolarChart.type = \"polar\";\nfunction isPolarSeries(series) {\n  return series instanceof PolarSeries;\n}\nfunction isPolarAxis(axis) {\n  return axis instanceof PolarAxis;\n}\n\n// packages/ag-charts-community/src/chart/standaloneChart.ts\nvar StandaloneChart = class extends Chart {\n  constructor(options, resources) {\n    super(options, resources);\n  }\n  getChartType() {\n    return \"standalone\";\n  }\n  performLayout(ctx) {\n    const { seriesRoot, annotationRoot, highlightRoot } = this;\n    const { layoutBox } = ctx;\n    const seriesRect = layoutBox.clone();\n    layoutBox.shrink(this.seriesArea.padding.toJson());\n    this.seriesRect = layoutBox;\n    this.animationRect = layoutBox;\n    for (const group of [seriesRoot, annotationRoot, highlightRoot]) {\n      group.translationX = Math.floor(layoutBox.x);\n      group.translationY = Math.floor(layoutBox.y);\n    }\n    seriesRoot.visible = this.series[0].visible;\n    this.ctx.layoutManager.emitLayoutComplete(ctx, {\n      series: { visible: true, rect: seriesRect, paddedRect: layoutBox }\n    });\n  }\n  getAriaLabel() {\n    const caption = this.getCaptionText();\n    return this.ctx.localeManager.t(\"ariaAnnounceHierarchyChart\", { caption });\n  }\n};\nStandaloneChart.className = \"StandaloneChart\";\nStandaloneChart.type = \"standalone\";\n\n// packages/ag-charts-community/src/chart/series/topology/mercatorScale.ts\nvar radsInDeg = Math.PI / 180;\nvar lonX = (lon) => lon * radsInDeg;\nvar latY = (lat) => -Math.log(Math.tan(Math.PI * 0.25 + lat * radsInDeg * 0.5));\nvar xLon = (x) => x / radsInDeg;\nvar yLat = (y) => (Math.atan(Math.exp(-y)) - Math.PI * 0.25) / (radsInDeg * 0.5);\nvar MercatorScale = class _MercatorScale {\n  constructor(domain, range3) {\n    this.domain = domain;\n    this.range = range3;\n    this.type = \"mercator\";\n    this.bounds = _MercatorScale.bounds(domain);\n  }\n  static bounds(domain) {\n    const [[lon0, lat0], [lon1, lat1]] = domain;\n    const x0 = lonX(lon0);\n    const y0 = latY(lat0);\n    const x1 = lonX(lon1);\n    const y1 = latY(lat1);\n    return new BBox(Math.min(x0, x1), Math.min(y0, y1), Math.abs(x1 - x0), Math.abs(y1 - y0));\n  }\n  static fixedScale() {\n    return new _MercatorScale(\n      [\n        [xLon(0), yLat(0)],\n        [xLon(1), yLat(1)]\n      ],\n      [\n        [0, 0],\n        [1, 1]\n      ]\n    );\n  }\n  convert([lon, lat]) {\n    const [[x0, y0], [x1, y1]] = this.range;\n    const xScale = (x1 - x0) / this.bounds.width;\n    const yScale = (y1 - y0) / this.bounds.height;\n    return [(lonX(lon) - this.bounds.x) * xScale + x0, (latY(lat) - this.bounds.y) * yScale + y0];\n  }\n  invert([x, y]) {\n    const [[x0, y0], [x1, y1]] = this.range;\n    const xScale = (x1 - x0) / this.bounds.width;\n    const yScale = (y1 - y0) / this.bounds.height;\n    return [xLon((x - x0) / xScale + this.bounds.x), yLat((y - y0) / yScale + this.bounds.y)];\n  }\n};\n\n// packages/ag-charts-community/src/chart/topologyChart.ts\nfunction isTopologySeries(series) {\n  return series.type === \"map-shape\" || series.type === \"map-line\" || series.type === \"map-marker\" || series.type === \"map-shape-background\" || series.type === \"map-line-background\";\n}\nvar TopologyChart = class extends Chart {\n  constructor(options, resources) {\n    super(options, resources);\n    this.xAxis = new NumberAxis(this.getModuleContext());\n    this.xAxis.position = \"bottom\";\n    this.yAxis = new NumberAxis(this.getModuleContext());\n    this.yAxis.position = \"left\";\n    this.ctx.zoomManager.updateAxes([this.xAxis, this.yAxis]);\n  }\n  getChartType() {\n    return \"topology\";\n  }\n  async updateData() {\n    await super.updateData();\n    const { topology } = this.getOptions();\n    this.series.forEach((series) => {\n      if (isTopologySeries(series)) {\n        series.setChartTopology(topology);\n      }\n    });\n  }\n  performLayout(ctx) {\n    const { seriesRoot, annotationRoot, highlightRoot } = this;\n    const { layoutBox } = ctx;\n    const seriesRect = layoutBox.clone();\n    layoutBox.shrink(this.seriesArea.padding.toJson());\n    this.seriesRect = layoutBox;\n    this.animationRect = layoutBox;\n    const mapSeries = this.series.filter(isTopologySeries);\n    const combinedBbox = mapSeries.reduce((combined, series) => {\n      if (!series.visible)\n        return combined;\n      const bbox = series.topologyBounds;\n      if (bbox == null)\n        return combined;\n      if (combined == null)\n        return bbox;\n      combined.merge(bbox);\n      return combined;\n    }, void 0);\n    let scale2;\n    if (combinedBbox != null) {\n      const { lon0, lat0, lon1, lat1 } = combinedBbox;\n      const domain = [\n        [lon0, lat0],\n        [lon1, lat1]\n      ];\n      const bounds = MercatorScale.bounds(domain);\n      const { width: width2, height: height2 } = layoutBox;\n      const viewBoxScale = Math.min(width2 / bounds.width, height2 / bounds.height);\n      const viewBoxWidth = bounds.width * viewBoxScale;\n      const viewBoxHeight = bounds.height * viewBoxScale;\n      const viewBoxOriginX = (width2 - viewBoxWidth) / 2;\n      const viewBoxOriginY = (height2 - viewBoxHeight) / 2;\n      const x0 = viewBoxOriginX;\n      const y0 = viewBoxOriginY;\n      const x1 = viewBoxOriginX + viewBoxWidth;\n      const y1 = viewBoxOriginY + viewBoxHeight;\n      const xZoom = this.ctx.zoomManager.getAxisZoom(this.xAxis.id);\n      const yZoom = this.ctx.zoomManager.getAxisZoom(this.yAxis.id);\n      const xSpan = (x1 - x0) / (xZoom.max - xZoom.min);\n      const xStart = x0 - xSpan * xZoom.min;\n      const ySpan = (y1 - y0) / (1 - yZoom.min - (1 - yZoom.max));\n      const yStart = y0 - ySpan * (1 - yZoom.max);\n      scale2 = new MercatorScale(domain, [\n        [xStart, yStart],\n        [xStart + xSpan, yStart + ySpan]\n      ]);\n    }\n    mapSeries.forEach((series) => {\n      series.scale = scale2;\n    });\n    const seriesVisible = this.series.some((s) => s.visible);\n    seriesRoot.visible = seriesVisible;\n    for (const group of [seriesRoot, annotationRoot, highlightRoot]) {\n      group.translationX = Math.floor(layoutBox.x);\n      group.translationY = Math.floor(layoutBox.y);\n      group.setClipRect(layoutBox.clone());\n    }\n    this.ctx.layoutManager.emitLayoutComplete(ctx, {\n      series: { visible: seriesVisible, rect: seriesRect, paddedRect: layoutBox }\n    });\n  }\n};\nTopologyChart.className = \"TopologyChart\";\nTopologyChart.type = \"topology\";\n\n// packages/ag-charts-community/src/api/preset/presetUtils.ts\nfunction assertEmpty(_t) {\n}\nvar IGNORED_PROP = Symbol(\"IGNORED_PROP\");\nfunction pickProps(opts, values) {\n  const out = {};\n  for (const key in values) {\n    const value = values[key];\n    if (value !== IGNORED_PROP && Object.hasOwn(opts, key)) {\n      out[key] = value;\n    }\n  }\n  return out;\n}\n\n// packages/ag-charts-community/src/api/preset/gauge.ts\nfunction isRadialGauge(opts) {\n  return opts.type === \"radial-gauge\";\n}\nfunction isLinearGauge(opts) {\n  return opts.type === \"linear-gauge\";\n}\nfunction radialGaugeOptions(opts) {\n  const {\n    animation,\n    background,\n    container,\n    contextMenu,\n    footnote,\n    height: height2,\n    listeners,\n    locale,\n    minHeight,\n    minWidth,\n    padding,\n    subtitle,\n    theme,\n    title,\n    width: width2,\n    type,\n    cursor,\n    nodeClickRange,\n    tooltip,\n    value,\n    scale: scale2 = {},\n    startAngle,\n    endAngle,\n    highlightStyle,\n    segmentation,\n    bar,\n    needle,\n    targets,\n    outerRadius,\n    innerRadius,\n    outerRadiusRatio,\n    innerRadiusRatio,\n    cornerRadius,\n    cornerMode,\n    label,\n    secondaryLabel,\n    spacing,\n    ...rest\n  } = opts;\n  assertEmpty(rest);\n  const {\n    fills: scaleFills,\n    fillMode: scaleFillMode,\n    fill: scaleFill,\n    fillOpacity: scaleFillOpacity,\n    stroke: scaleStroke,\n    strokeWidth: scaleStrokeWidth,\n    strokeOpacity: scaleStrokeOpacity,\n    lineDash: scaleLineDash,\n    lineDashOffset: scaleLineDashOffset,\n    min: scaleMin = 0,\n    max: scaleMax = 1,\n    interval: scaleInterval = {},\n    label: scaleLabel = {},\n    ...scaleRest\n  } = scale2;\n  assertEmpty(scaleRest);\n  const chartOpts = pickProps(opts, {\n    animation,\n    background,\n    container,\n    contextMenu,\n    footnote,\n    height: height2,\n    listeners,\n    locale,\n    minHeight,\n    minWidth,\n    padding,\n    subtitle,\n    theme,\n    title,\n    width: width2\n  });\n  const scaleOpts = pickProps(scale2, {\n    fills: scaleFills,\n    fillMode: scaleFillMode,\n    fill: scaleFill,\n    fillOpacity: scaleFillOpacity,\n    stroke: scaleStroke,\n    strokeWidth: scaleStrokeWidth,\n    strokeOpacity: scaleStrokeOpacity,\n    lineDash: scaleLineDash,\n    lineDashOffset: scaleLineDashOffset\n  });\n  const seriesOpts = pickProps(opts, {\n    startAngle: IGNORED_PROP,\n    endAngle: IGNORED_PROP,\n    needle: needle != null ? { enabled: true, ...needle } : IGNORED_PROP,\n    scale: scaleOpts,\n    type,\n    cursor,\n    nodeClickRange,\n    listeners,\n    tooltip,\n    value,\n    highlightStyle,\n    segmentation,\n    bar,\n    targets,\n    outerRadius,\n    innerRadius,\n    outerRadiusRatio,\n    innerRadiusRatio,\n    cornerRadius,\n    cornerMode,\n    label,\n    secondaryLabel,\n    spacing,\n    ...rest\n  });\n  const axesOpts = [\n    {\n      type: \"angle-number\",\n      min: scaleMin,\n      max: scaleMax,\n      startAngle,\n      endAngle,\n      interval: scaleInterval ?? {},\n      label: scaleLabel ?? {}\n    },\n    { type: \"radius-number\" }\n  ];\n  return {\n    ...chartOpts,\n    series: [seriesOpts],\n    axes: axesOpts\n  };\n}\nfunction linearGaugeOptions(opts) {\n  const {\n    animation,\n    background,\n    container,\n    contextMenu,\n    footnote,\n    height: height2,\n    listeners,\n    locale,\n    minHeight,\n    minWidth,\n    padding,\n    subtitle,\n    theme,\n    title,\n    width: width2,\n    type,\n    cursor,\n    nodeClickRange,\n    tooltip,\n    value,\n    scale: scale2 = {},\n    direction = \"vertical\",\n    thickness,\n    highlightStyle,\n    segmentation,\n    bar,\n    targets,\n    cornerRadius,\n    cornerMode,\n    label,\n    ...rest\n  } = opts;\n  assertEmpty(rest);\n  const {\n    fills: scaleFills,\n    fillMode: scaleFillMode,\n    fill: scaleFill,\n    fillOpacity: scaleFillOpacity,\n    stroke: scaleStroke,\n    strokeWidth: scaleStrokeWidth,\n    strokeOpacity: scaleStrokeOpacity,\n    lineDash: scaleLineDash,\n    lineDashOffset: scaleLineDashOffset,\n    min: scaleMin = 0,\n    max: scaleMax = 1,\n    interval: scaleInterval = {},\n    label: scaleLabel = {},\n    ...scaleRest\n  } = scale2;\n  assertEmpty(scaleRest);\n  const chartOpts = pickProps(opts, {\n    animation,\n    background,\n    container,\n    contextMenu,\n    footnote,\n    height: height2,\n    listeners,\n    locale,\n    minHeight,\n    minWidth,\n    padding,\n    subtitle,\n    theme,\n    title,\n    width: width2\n  });\n  const scaleOpts = pickProps(scale2, {\n    fills: scaleFills,\n    fillMode: scaleFillMode,\n    fill: scaleFill,\n    fillOpacity: scaleFillOpacity,\n    stroke: scaleStroke,\n    strokeWidth: scaleStrokeWidth,\n    strokeOpacity: scaleStrokeOpacity,\n    lineDash: scaleLineDash,\n    lineDashOffset: scaleLineDashOffset\n  });\n  const seriesOpts = pickProps(opts, {\n    scale: scaleOpts,\n    type,\n    cursor,\n    nodeClickRange,\n    listeners,\n    tooltip,\n    value,\n    direction,\n    thickness,\n    highlightStyle,\n    segmentation,\n    bar,\n    targets,\n    cornerRadius,\n    cornerMode,\n    label,\n    ...rest\n  });\n  const { placement: labelPlacement, ...axisLabel } = scaleLabel;\n  let mainAxisPosition;\n  let crossAxisPosition;\n  const horizontal = direction === \"horizontal\";\n  if (horizontal) {\n    mainAxisPosition = labelPlacement === \"before\" ? \"top\" : \"bottom\";\n    crossAxisPosition = \"left\";\n  } else {\n    mainAxisPosition = labelPlacement === \"after\" ? \"right\" : \"left\";\n    crossAxisPosition = \"bottom\";\n  }\n  const mainAxis = {\n    type: \"number\",\n    position: mainAxisPosition,\n    min: scaleMin,\n    max: scaleMax,\n    reverse: !horizontal,\n    interval: scaleInterval,\n    label: axisLabel,\n    nice: false\n  };\n  const crossAxis = {\n    type: \"number\",\n    position: crossAxisPosition,\n    min: 0,\n    max: 1,\n    label: {\n      enabled: false\n    }\n  };\n  const axesOpts = horizontal ? [mainAxis, crossAxis] : [crossAxis, mainAxis];\n  return {\n    ...chartOpts,\n    series: [seriesOpts],\n    axes: axesOpts\n  };\n}\nfunction applyThemeDefaults(opts, presetTheme) {\n  if (presetTheme == null)\n    return opts;\n  const { targets: targetsTheme, ...gaugeTheme } = presetTheme;\n  opts = mergeDefaults(opts, gaugeTheme);\n  if (opts.targets != null && targetsTheme != null) {\n    opts.targets = mergeArrayDefaults(opts.targets, targetsTheme);\n  }\n  return opts;\n}\nfunction gauge(opts, presetTheme) {\n  if (isRadialGauge(opts)) {\n    const radialGaugeOpts = applyThemeDefaults(opts, presetTheme);\n    return radialGaugeOptions(radialGaugeOpts);\n  } else if (isLinearGauge(opts)) {\n    const linearGaugeOpts = applyThemeDefaults(opts, presetTheme);\n    return linearGaugeOptions(linearGaugeOpts);\n  }\n  const {\n    animation,\n    background,\n    container,\n    contextMenu,\n    footnote,\n    height: height2,\n    listeners,\n    locale,\n    minHeight,\n    minWidth,\n    padding,\n    subtitle,\n    theme,\n    title,\n    width: width2\n  } = opts;\n  return pickProps(opts, {\n    animation,\n    background,\n    container,\n    contextMenu,\n    footnote,\n    height: height2,\n    listeners,\n    locale,\n    minHeight,\n    minWidth,\n    padding,\n    subtitle,\n    theme,\n    title,\n    width: width2\n  });\n}\n\n// packages/ag-charts-community/src/api/preset/priceVolumePreset.ts\nfunction fromTheme(theme, cb) {\n  if (isObject(theme)) {\n    return cb(theme);\n  }\n}\nvar chartTypes2 = [\"ohlc\", \"line\", \"step-line\", \"hlc\", \"high-low\", \"candlestick\", \"hollow-candlestick\"];\nfunction priceVolume(opts, _presetTheme, getTheme) {\n  const {\n    xKey,\n    dateKey = xKey ?? \"date\",\n    highKey = \"high\",\n    openKey = \"open\",\n    lowKey = \"low\",\n    closeKey = \"close\",\n    volumeKey = \"volume\",\n    chartType: chartType2 = \"candlestick\",\n    navigator: navigator2 = false,\n    volume = true,\n    rangeToolbar,\n    rangeButtons = rangeToolbar ?? true,\n    statusBar = true,\n    annotations: annotations2,\n    toolbar = annotations2 ?? true,\n    zoom: zoom2 = true,\n    theme,\n    data,\n    ...unusedOpts\n  } = opts;\n  if (xKey != null) {\n    Logger.warnOnce(\"Property [xKey] is deprecated, use [dateKey] instead.\");\n  }\n  if (rangeToolbar != null) {\n    Logger.warnOnce(\"Property [rangeToolbar] is deprecated, use [rangeButtons] instead.\");\n  }\n  if (annotations2 != null) {\n    Logger.warnOnce(\"Property [annotations] is deprecated, use [toolbar] instead.\");\n  }\n  const priceSeries = createPriceSeries(theme, chartType2, dateKey, highKey, lowKey, openKey, closeKey);\n  const volumeSeries = createVolumeSeries(theme, getTheme, openKey, closeKey, volume, volumeKey);\n  const miniChart = volume ? {\n    miniChart: {\n      enabled: navigator2,\n      series: [\n        {\n          type: \"line\",\n          xKey: dateKey,\n          yKey: volumeKey,\n          marker: { enabled: false }\n        }\n      ]\n    }\n  } : null;\n  const navigatorOpts = {\n    navigator: {\n      enabled: navigator2,\n      ...miniChart\n    }\n  };\n  const annotationOpts = {\n    annotations: {\n      enabled: toolbar,\n      // @ts-expect-error\n      data,\n      xKey: dateKey,\n      volumeKey: volume ? volumeKey : void 0\n    }\n  };\n  const statusBarOpts = statusBar ? {\n    statusBar: {\n      enabled: true,\n      data,\n      highKey,\n      openKey,\n      lowKey,\n      closeKey,\n      volumeKey: volume ? volumeKey : void 0\n    }\n  } : null;\n  const zoomOpts = {\n    zoom: {\n      enabled: zoom2,\n      // @ts-expect-error\n      enableIndependentAxes: true\n    }\n  };\n  const toolbarOpts = {\n    chartToolbar: { enabled: true },\n    toolbar: {\n      seriesType: {\n        enabled: toolbar\n      },\n      annotationOptions: {\n        enabled: toolbar\n      },\n      annotations: {\n        enabled: toolbar\n      },\n      ranges: {\n        enabled: rangeButtons\n      }\n    }\n  };\n  const volumeAxis = volume ? [\n    {\n      type: \"number\",\n      position: \"left\",\n      keys: [volumeKey],\n      label: { enabled: false },\n      crosshair: { enabled: false },\n      gridLine: { enabled: false },\n      nice: false,\n      // @ts-expect-error\n      layoutConstraints: {\n        stacked: false,\n        width: 20,\n        unit: \"percentage\",\n        align: \"end\"\n      }\n    }\n  ] : [];\n  return {\n    theme: {\n      baseTheme: typeof theme === \"string\" ? theme : \"ag-financial\",\n      ...mergeDefaults(typeof theme === \"object\" ? theme : null, {\n        overrides: {\n          common: {\n            title: { padding: 4 },\n            padding: {\n              top: 6,\n              right: 8,\n              bottom: 5\n            }\n          }\n        }\n      })\n    },\n    animation: { enabled: false },\n    legend: { enabled: false },\n    series: [...volumeSeries, ...priceSeries],\n    axes: [\n      {\n        type: \"number\",\n        position: \"right\",\n        keys: [openKey, closeKey, highKey, lowKey],\n        interval: {\n          maxSpacing: fromTheme(theme, (t) => t.overrides?.common?.axes?.number?.interval?.maxSpacing) ?? 45\n        },\n        label: {\n          format: fromTheme(theme, (t) => t.overrides?.common?.axes?.number?.label?.format) ?? \".2f\"\n        },\n        crosshair: {\n          enabled: true,\n          snap: false\n        },\n        // @ts-expect-error\n        layoutConstraints: {\n          stacked: false,\n          width: 100,\n          unit: \"percentage\",\n          align: \"start\"\n        }\n      },\n      ...volumeAxis,\n      {\n        type: \"ordinal-time\",\n        position: \"bottom\",\n        line: {\n          enabled: false\n        },\n        label: {\n          enabled: true\n        },\n        crosshair: {\n          enabled: true\n        }\n      }\n    ],\n    tooltip: { enabled: false },\n    data,\n    ...annotationOpts,\n    ...navigatorOpts,\n    ...statusBarOpts,\n    ...zoomOpts,\n    ...toolbarOpts,\n    ...unusedOpts\n  };\n}\nfunction createVolumeSeries(theme, getTheme, openKey, closeKey, volume, volumeKey) {\n  if (!volume)\n    return [];\n  const barSeriesFill = fromTheme(theme, (t) => t.overrides?.bar?.series?.fill);\n  const itemStyler = barSeriesFill ? { fill: barSeriesFill } : {\n    itemStyler({ datum }) {\n      const { up, down } = getTheme().palette;\n      return { fill: datum[openKey] < datum[closeKey] ? up?.fill : down?.fill };\n    }\n  };\n  return [\n    {\n      type: \"bar\",\n      xKey: \"date\",\n      yKey: volumeKey,\n      // @ts-expect-error\n      focusPriority: 1,\n      tooltip: { enabled: false },\n      highlight: { enabled: false },\n      fillOpacity: fromTheme(theme, (t) => t.overrides?.bar?.series?.fillOpacity) ?? 0.5,\n      ...itemStyler\n    }\n  ];\n}\nvar RANGE_AREA_TYPE = \"range-area\";\nfunction createPriceSeries(theme, chartType2, xKey, highKey, lowKey, openKey, closeKey) {\n  if (chartType2 === RANGE_AREA_TYPE) {\n    Logger.warnOnce(`type '${chartType2}' is deprecated, use 'hlc' chart type instead`);\n    chartType2 = \"hlc\";\n  }\n  const keys = {\n    xKey,\n    openKey,\n    closeKey,\n    highKey,\n    lowKey\n  };\n  const singleKeys = {\n    xKey,\n    yKey: closeKey\n  };\n  const common = {\n    pickOutsideVisibleMinorAxis: true\n  };\n  switch (chartType2 ?? \"candlestick\") {\n    case \"ohlc\":\n      return [\n        {\n          type: \"ohlc\",\n          // @ts-expect-error\n          focusPriority: 0,\n          ...common,\n          ...keys\n        }\n      ];\n    case \"line\":\n      return [\n        {\n          type: \"line\",\n          // @ts-expect-error\n          focusPriority: 0,\n          ...common,\n          ...singleKeys,\n          stroke: fromTheme(theme, (t) => t.overrides?.line?.series?.stroke) ?? PALETTE_NEUTRAL_STROKE,\n          marker: fromTheme(theme, (t) => t.overrides?.line?.series?.marker) ?? { enabled: false }\n        }\n      ];\n    case \"step-line\":\n      return [\n        {\n          type: \"line\",\n          // @ts-expect-error\n          focusPriority: 0,\n          ...common,\n          ...singleKeys,\n          stroke: fromTheme(theme, (t) => t.overrides?.line?.series?.stroke) ?? PALETTE_NEUTRAL_STROKE,\n          interpolation: fromTheme(theme, (t) => t.overrides?.line?.series?.interpolation) ?? {\n            type: \"step\"\n          },\n          marker: fromTheme(theme, (t) => t.overrides?.line?.series?.marker) ?? { enabled: false }\n        }\n      ];\n    case \"hlc\": {\n      const rangeAreaColors = getThemeColors(RANGE_AREA_TYPE, theme);\n      return [\n        {\n          type: RANGE_AREA_TYPE,\n          // @ts-expect-error\n          focusPriority: 0,\n          ...common,\n          xKey,\n          yHighKey: highKey,\n          yLowKey: closeKey,\n          fill: rangeAreaColors.fill ?? PALETTE_UP_FILL,\n          stroke: rangeAreaColors.stroke ?? PALETTE_UP_STROKE,\n          fillOpacity: fromTheme(theme, (t) => t.overrides?.[\"range-area\"]?.series?.fillOpacity) ?? 0.3,\n          strokeWidth: fromTheme(theme, (t) => t.overrides?.[\"range-area\"]?.series?.strokeWidth) ?? 2\n        },\n        {\n          type: RANGE_AREA_TYPE,\n          // @ts-expect-error\n          focusPriority: 0,\n          ...common,\n          xKey,\n          yHighKey: closeKey,\n          yLowKey: lowKey,\n          fill: rangeAreaColors.fill ?? PALETTE_DOWN_FILL,\n          stroke: rangeAreaColors.stroke ?? PALETTE_DOWN_STROKE,\n          fillOpacity: fromTheme(theme, (t) => t.overrides?.[\"range-area\"]?.series?.fillOpacity) ?? 0.3,\n          strokeWidth: fromTheme(theme, (t) => t.overrides?.[\"range-area\"]?.series?.strokeWidth) ?? 2\n        },\n        {\n          type: \"line\",\n          ...common,\n          ...singleKeys,\n          stroke: fromTheme(theme, (t) => t.overrides?.line?.series?.stroke) ?? PALETTE_ALT_NEUTRAL_STROKE,\n          strokeWidth: fromTheme(theme, (t) => t.overrides?.line?.series?.strokeWidth) ?? 2,\n          marker: fromTheme(theme, (t) => t.overrides?.line?.series?.marker) ?? { enabled: false }\n        }\n      ];\n    }\n    case \"high-low\": {\n      const rangeBarColors = getThemeColors(\"range-bar\", theme);\n      return [\n        {\n          type: \"range-bar\",\n          // @ts-expect-error\n          focusPriority: 0,\n          ...common,\n          xKey,\n          yHighKey: highKey,\n          yLowKey: lowKey,\n          fill: rangeBarColors.fill ?? PALETTE_NEUTRAL_FILL,\n          stroke: rangeBarColors.stroke ?? PALETTE_NEUTRAL_STROKE,\n          tooltip: {\n            range: \"nearest\"\n          }\n        }\n      ];\n    }\n    case \"candlestick\":\n      return [\n        {\n          type: \"candlestick\",\n          // @ts-expect-error\n          focusPriority: 0,\n          ...common,\n          ...keys\n        }\n      ];\n    case \"hollow-candlestick\": {\n      const item = fromTheme(theme, (t) => t.overrides?.candlestick?.series?.item);\n      return [\n        {\n          type: \"candlestick\",\n          // @ts-expect-error\n          focusPriority: 0,\n          ...common,\n          ...keys,\n          item: {\n            up: {\n              fill: item?.up?.fill ?? \"transparent\"\n            }\n          }\n        }\n      ];\n    }\n    default:\n      Logger.warnOnce(`unknown chart type: ${chartType2}; expected one of: ${chartTypes2.join(\", \")}`);\n      return [\n        {\n          type: \"candlestick\",\n          // @ts-expect-error\n          focusPriority: 0,\n          ...common,\n          ...keys\n        }\n      ];\n  }\n}\nfunction getThemeColors(seriesType2, theme) {\n  const fill = fromTheme(theme, (t) => t.overrides?.[seriesType2]?.series?.fill);\n  const stroke = fromTheme(theme, (t) => t.overrides?.[seriesType2]?.series?.stroke);\n  return { fill, stroke };\n}\n\n// packages/ag-charts-community/src/api/preset/sparkline.ts\nvar commonAxisProperties = {\n  line: {\n    enabled: false\n  },\n  title: {\n    enabled: false\n  },\n  label: {\n    enabled: false\n  },\n  crosshair: {\n    enabled: false,\n    strokeOpacity: 0.25,\n    lineDash: [0],\n    label: {\n      enabled: false\n    }\n  }\n};\nvar numericAxisProperties = {\n  ...commonAxisProperties,\n  nice: false\n};\nvar bottomCrossHairAxisProperties = {\n  bottom: {\n    crosshair: {\n      enabled: IS_ENTERPRISE\n    }\n  }\n};\nvar crossHairAxes = {\n  category: bottomCrossHairAxisProperties,\n  number: bottomCrossHairAxisProperties,\n  log: bottomCrossHairAxisProperties,\n  time: bottomCrossHairAxisProperties\n};\nvar crossHairTooltip = {\n  position: {\n    type: \"sparkline\"\n  }\n};\nvar SPARKLINE_THEME = {\n  overrides: {\n    common: {\n      animation: {\n        enabled: false\n      },\n      padding: {\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0\n      },\n      axes: {\n        number: {\n          ...numericAxisProperties,\n          interval: {\n            values: [0]\n          }\n        },\n        log: {\n          ...numericAxisProperties\n        },\n        time: {\n          ...numericAxisProperties\n        },\n        category: {\n          ...commonAxisProperties,\n          gridLine: {\n            enabled: false\n          }\n        }\n      }\n    },\n    bar: {\n      series: {\n        // @ts-expect-error\n        sparklineMode: true\n      },\n      tooltip: {\n        range: \"nearest\"\n      }\n    },\n    line: {\n      seriesArea: {\n        padding: {\n          top: 2,\n          right: 2,\n          bottom: 2,\n          left: 2\n        }\n      },\n      axes: crossHairAxes,\n      series: {\n        strokeWidth: 1,\n        marker: {\n          enabled: false,\n          size: 3\n        },\n        tooltip: crossHairTooltip\n      }\n    },\n    area: {\n      seriesArea: {\n        padding: {\n          top: 1,\n          right: 0,\n          bottom: 1,\n          left: 0\n        }\n      },\n      axes: crossHairAxes,\n      series: {\n        strokeWidth: 1,\n        fillOpacity: 0.4,\n        tooltip: crossHairTooltip\n      }\n    }\n  }\n};\nfunction setInitialBaseTheme(baseTheme, initialBaseTheme) {\n  if (typeof baseTheme === \"string\") {\n    return {\n      ...initialBaseTheme,\n      baseTheme\n    };\n  }\n  if (baseTheme != null) {\n    return {\n      ...baseTheme,\n      // @ts-expect-error internal implementation\n      baseTheme: setInitialBaseTheme(baseTheme.baseTheme, initialBaseTheme)\n    };\n  }\n  return initialBaseTheme;\n}\nfunction sparkline(opts) {\n  const {\n    background,\n    container,\n    height: height2,\n    listeners,\n    locale,\n    minHeight,\n    minWidth,\n    padding,\n    width: width2,\n    theme: baseTheme,\n    data,\n    xAxis,\n    yAxis,\n    ...optsRest\n  } = opts;\n  assertEmpty(optsRest);\n  const seriesOptions = optsRest;\n  const swapAxes = seriesOptions.type !== \"bar\" || seriesOptions.direction !== \"horizontal\";\n  const chartOpts = pickProps(opts, {\n    background,\n    container,\n    height: height2,\n    listeners,\n    locale,\n    minHeight,\n    minWidth,\n    padding,\n    width: width2,\n    data,\n    xAxis: IGNORED_PROP,\n    yAxis: IGNORED_PROP,\n    theme: IGNORED_PROP\n  });\n  chartOpts.theme = setInitialBaseTheme(baseTheme, SPARKLINE_THEME);\n  chartOpts.series = [seriesOptions];\n  chartOpts.axes = swapAxes ? [\n    { type: \"number\", ...yAxis, position: \"left\" },\n    { type: \"category\", ...xAxis, position: \"bottom\" }\n  ] : [\n    { type: \"category\", ...xAxis, position: \"left\" },\n    { type: \"number\", ...yAxis, position: \"bottom\" }\n  ];\n  return chartOpts;\n}\n\n// packages/ag-charts-community/src/api/preset/presets.ts\nvar PRESETS = {\n  \"price-volume\": priceVolume,\n  gauge,\n  sparkline\n};\n\n// packages/ag-charts-community/src/chart/factory/processEnterpriseOptions.ts\nfunction removeUsedEnterpriseOptions(options, silent) {\n  let usedOptions = [];\n  const isGaugeChart = isAgGaugeChartOptions(options);\n  const type = optionsType(options);\n  const optionsChartType = type ? chartTypes.get(type) : \"unknown\";\n  for (const {\n    type: type2,\n    chartTypes: moduleChartTypes,\n    optionsKey,\n    optionsInnerKey,\n    identifier\n  } of EXPECTED_ENTERPRISE_MODULES) {\n    if (optionsChartType !== \"unknown\" && !moduleChartTypes.includes(optionsChartType))\n      continue;\n    if (type2 === \"root\" || type2 === \"legend\") {\n      const optionValue = options[optionsKey];\n      if (optionValue == null)\n        continue;\n      if (!optionsInnerKey) {\n        usedOptions.push(optionsKey);\n        delete options[optionsKey];\n      } else if (optionValue[optionsInnerKey]) {\n        usedOptions.push(`${optionsKey}.${optionsInnerKey}`);\n        delete optionValue[optionsInnerKey];\n      }\n    } else if (type2 === \"axis\") {\n      if (!(\"axes\" in options) || !options.axes?.some((axis) => axis.type === identifier))\n        continue;\n      usedOptions.push(`axis[type=${identifier}]`);\n      options.axes = options.axes.filter((axis) => axis.type !== identifier);\n    } else if (type2 === \"axis-option\") {\n      if (!(\"axes\" in options) || !options.axes?.some((axis) => axis[optionsKey]))\n        continue;\n      usedOptions.push(`axis.${optionsKey}`);\n      options.axes.forEach((axis) => {\n        if (axis[optionsKey]) {\n          delete axis[optionsKey];\n        }\n      });\n    } else if (type2 === \"series\") {\n      if (!options.series?.some((series) => series.type === identifier))\n        continue;\n      usedOptions.push(`series[type=${identifier}]`);\n      options.series = options.series.filter((series) => series.type !== identifier);\n    } else if (type2 === \"series-option\") {\n      if (!options.series?.some((series) => series[optionsKey]))\n        continue;\n      usedOptions.push(`series.${optionsKey}`);\n      options.series.forEach((series) => {\n        if (series[optionsKey]) {\n          delete series[optionsKey];\n        }\n      });\n    }\n  }\n  if (usedOptions.length && !silent) {\n    if (isGaugeChart) {\n      usedOptions = [\"AgCharts.createGauge\"];\n    }\n    let enterprisePackageName = \"ag-charts-enterprise\";\n    let enterpriseReferenceUrl = \"https://ag-grid.com/charts/javascript/installation/\";\n    if (options.mode === \"integrated\") {\n      enterprisePackageName = \"ag-grid-charts-enterprise' or 'ag-grid-enterprise/charts-enterprise\";\n      enterpriseReferenceUrl = \"https://www.ag-grid.com/javascript-data-grid/integrated-charts-installation/\";\n    }\n    Logger.warnOnce(\n      [\n        `unable to use these enterprise features as '${enterprisePackageName}' has not been loaded:`,\n        \"\",\n        ...usedOptions,\n        \"\",\n        `See: ${enterpriseReferenceUrl}`\n      ].join(\"\\n\")\n    );\n  }\n}\n\n// packages/ag-charts-community/src/util/string.util.ts\nfunction stringifyValue(value, maxLength = Infinity) {\n  switch (typeof value) {\n    case \"undefined\":\n      return \"undefined\";\n    case \"number\":\n      if (isNaN(value)) {\n        return \"NaN\";\n      } else if (value === Infinity) {\n        return \"Infinity\";\n      } else if (value === -Infinity) {\n        return \"-Infinity\";\n      }\n    default:\n      value = JSON.stringify(value);\n      if (value.length > maxLength) {\n        return `${value.slice(0, maxLength)}... (+${value.length - maxLength} characters)`;\n      }\n      return value;\n  }\n}\n\n// packages/ag-charts-community/src/util/validate.ts\nvar descriptionSymbol = Symbol(\"description\");\nvar requiredSymbol = Symbol(\"required\");\nfunction isValid(options, optionsDefs, path) {\n  const { errors } = validate(options, optionsDefs, path);\n  for (const { message } of errors) {\n    Logger.warn(message);\n  }\n  return errors.length === 0;\n}\nfunction validateMessage(path, value, validatorOrDefs) {\n  const description = isString(validatorOrDefs) ? validatorOrDefs : validatorOrDefs[descriptionSymbol];\n  const expecting = description ? `; expecting ${description}` : \"\";\n  const prefix = path ? `Option \\`${path}\\`` : \"Value\";\n  return `${prefix} cannot be set to \\`${stringifyValue(value)}\\`${expecting}, ignoring.`;\n}\nfunction validate(options, optionsDefs, path = \"\") {\n  if (!isObject(options)) {\n    return {\n      valid: null,\n      errors: [{ path, value: options, message: validateMessage(path, options, \"an object\") }]\n    };\n  }\n  const optionsKeys = new Set(Object.keys(options));\n  const errors = [];\n  const valid = {};\n  function extendPath(key) {\n    if (isArray(optionsDefs)) {\n      return `${path}[${key}]`;\n    }\n    return path ? `${path}.${key}` : key;\n  }\n  for (const [key, validatorOrDefs] of Object.entries(optionsDefs)) {\n    optionsKeys.delete(key);\n    const value = options[key];\n    if (!validatorOrDefs[requiredSymbol] && typeof value === \"undefined\")\n      continue;\n    if (isFunction(validatorOrDefs)) {\n      if (validatorOrDefs(value)) {\n        valid[key] = value;\n      } else {\n        errors.push({ key, path, value, message: validateMessage(extendPath(key), value, validatorOrDefs) });\n      }\n    } else {\n      const nestedResult = validate(value, validatorOrDefs, extendPath(key));\n      valid[key] = nestedResult.valid;\n      errors.push(...nestedResult.errors);\n    }\n  }\n  for (const key of optionsKeys) {\n    errors.push({\n      key,\n      path,\n      unknown: true,\n      message: `Unknown option \\`${extendPath(key)}\\`, ignoring.`\n    });\n  }\n  return { valid, errors };\n}\nfunction attachDescription(validator, description) {\n  return Object.assign((value) => validator(value), { [descriptionSymbol]: description });\n}\nvar or = (...validators) => attachDescription(\n  (value) => validators.some((validator) => validator(value)),\n  validators.map((v) => v[descriptionSymbol]).filter(Boolean).join(\" or \")\n);\nvar array = attachDescription(isArray, \"an array\");\nvar boolean = attachDescription(isBoolean, \"a boolean\");\nvar callback = attachDescription(isFunction, \"a function\");\nvar number = attachDescription(isFiniteNumber, \"a number\");\nvar object = attachDescription(isObject, \"an object\");\nvar string = attachDescription(isString, \"a string\");\nvar numberMin = (min, inclusive = true) => attachDescription(\n  (value) => isFiniteNumber(value) && (value > min || inclusive && value === min),\n  `a number greater than ${inclusive ? \"or equal to \" : \"\"}${min}`\n);\nvar numberRange = (min, max) => attachDescription(\n  (value) => isFiniteNumber(value) && value >= min && value <= max,\n  `a number between ${min} and ${max} inclusive`\n);\nvar positiveNumber = numberMin(0);\nvar minOneNumber = numberMin(1);\nvar ratio = numberRange(0, 1);\nvar degree = numberRange(0, 360);\nvar arrayOf = (validator, description) => attachDescription(\n  (value) => isArray(value) && value.every(validator),\n  description ?? `${validator[descriptionSymbol]} array`\n);\n\n// packages/ag-charts-community/src/module/coreModulesTypes.ts\nfunction paletteType(partial) {\n  if (partial?.up || partial?.down || partial?.neutral) {\n    return \"user-full\";\n  } else if (partial?.fills || partial?.strokes) {\n    return \"user-indexed\";\n  }\n  return \"inbuilt\";\n}\n\n// packages/ag-charts-community/src/chart/themes/chartTheme.ts\nvar DEFAULT_BACKGROUND_FILL = \"white\";\nvar CHART_TYPE_CONFIG = {\n  get cartesian() {\n    return { seriesTypes: chartTypes.cartesianTypes, commonOptions: [\"zoom\", \"navigator\"] };\n  },\n  get polar() {\n    return { seriesTypes: chartTypes.polarTypes, commonOptions: [] };\n  },\n  get hierarchy() {\n    return { seriesTypes: chartTypes.hierarchyTypes, commonOptions: [] };\n  },\n  get topology() {\n    return { seriesTypes: chartTypes.topologyTypes, commonOptions: [] };\n  },\n  get \"flow-proportion\"() {\n    return { seriesTypes: chartTypes.flowProportionTypes, commonOptions: [] };\n  },\n  get standalone() {\n    return { seriesTypes: chartTypes.standaloneTypes, commonOptions: [] };\n  },\n  get gauge() {\n    return { seriesTypes: chartTypes.gaugeTypes, commonOptions: [] };\n  }\n};\nvar PRESET_OVERRIDES_TYPES = {\n  \"radial-gauge\": true,\n  \"linear-gauge\": true\n};\nfunction isPresetOverridesType(type) {\n  return PRESET_OVERRIDES_TYPES[type] === true;\n}\nvar CHART_TYPE_SPECIFIC_COMMON_OPTIONS = Object.values(CHART_TYPE_CONFIG).reduce((r, { commonOptions }) => r.concat(commonOptions), []);\nvar _ChartTheme = class _ChartTheme {\n  static getAxisDefaults(overrideDefaults) {\n    return mergeDefaults(overrideDefaults, {\n      title: {\n        enabled: false,\n        text: \"Axis Title\",\n        spacing: 25,\n        fontWeight: \"normal\" /* NORMAL */,\n        fontSize: 13 /* MEDIUM */,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_LABEL_COLOUR\n      },\n      label: {\n        fontSize: 12 /* SMALL */,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        padding: 5,\n        color: DEFAULT_LABEL_COLOUR,\n        avoidCollisions: true\n      },\n      line: {\n        enabled: true,\n        width: 1,\n        stroke: DEFAULT_AXIS_LINE_COLOUR\n      },\n      tick: {\n        enabled: false,\n        width: 1,\n        stroke: DEFAULT_AXIS_LINE_COLOUR\n      },\n      gridLine: {\n        enabled: true,\n        style: [{ stroke: DEFAULT_AXIS_GRID_COLOUR, lineDash: [] }]\n      },\n      crossLines: {\n        enabled: false,\n        fill: DEFAULT_CROSS_LINES_COLOUR,\n        stroke: DEFAULT_CROSS_LINES_COLOUR,\n        fillOpacity: 0.1,\n        strokeWidth: 1,\n        label: {\n          enabled: false,\n          fontSize: 12 /* SMALL */,\n          fontFamily: DEFAULT_FONT_FAMILY,\n          padding: 5,\n          color: DEFAULT_LABEL_COLOUR\n        }\n      },\n      crosshair: {\n        enabled: true\n      }\n    });\n  }\n  getChartDefaults() {\n    return {\n      minHeight: 300,\n      minWidth: 300,\n      background: { visible: true, fill: DEFAULT_BACKGROUND_COLOUR },\n      padding: { top: DEFAULT_PADDING, right: DEFAULT_PADDING, bottom: DEFAULT_PADDING, left: DEFAULT_PADDING },\n      keyboard: { enabled: true },\n      title: {\n        enabled: false,\n        text: \"Title\",\n        fontWeight: \"normal\" /* NORMAL */,\n        fontSize: 17 /* LARGE */,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_LABEL_COLOUR,\n        wrapping: \"hyphenate\",\n        layoutStyle: DEFAULT_CAPTION_LAYOUT_STYLE,\n        textAlign: DEFAULT_CAPTION_ALIGNMENT\n      },\n      subtitle: {\n        enabled: false,\n        text: \"Subtitle\",\n        spacing: 20,\n        fontSize: 13 /* MEDIUM */,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_MUTED_LABEL_COLOUR,\n        wrapping: \"hyphenate\",\n        layoutStyle: DEFAULT_CAPTION_LAYOUT_STYLE,\n        textAlign: DEFAULT_CAPTION_ALIGNMENT\n      },\n      footnote: {\n        enabled: false,\n        text: \"Footnote\",\n        spacing: 20,\n        fontSize: 13 /* MEDIUM */,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: \"rgb(140, 140, 140)\",\n        wrapping: \"hyphenate\",\n        layoutStyle: DEFAULT_CAPTION_LAYOUT_STYLE,\n        textAlign: DEFAULT_CAPTION_ALIGNMENT\n      },\n      legend: {\n        position: \"bottom\" /* BOTTOM */,\n        spacing: 30,\n        listeners: {},\n        toggleSeries: true,\n        item: {\n          paddingX: 16,\n          paddingY: 8,\n          marker: { size: 15, padding: 8 },\n          showSeriesStroke: true,\n          label: {\n            color: DEFAULT_LABEL_COLOUR,\n            fontSize: 12 /* SMALL */,\n            fontFamily: DEFAULT_FONT_FAMILY\n          }\n        },\n        reverseOrder: false,\n        pagination: {\n          marker: { size: 12 },\n          activeStyle: { fill: DEFAULT_LABEL_COLOUR },\n          inactiveStyle: { fill: DEFAULT_MUTED_LABEL_COLOUR },\n          highlightStyle: { fill: DEFAULT_LABEL_COLOUR },\n          label: { color: DEFAULT_LABEL_COLOUR }\n        }\n      },\n      tooltip: {\n        enabled: true,\n        darkTheme: IS_DARK_THEME,\n        delay: 0\n      },\n      overlays: { darkTheme: IS_DARK_THEME },\n      listeners: {}\n    };\n  }\n  constructor(options = {}) {\n    const { overrides, palette } = deepClone(options);\n    const defaults = this.createChartConfigPerChartType(this.getDefaults());\n    const presets = {};\n    if (overrides) {\n      this.mergeOverrides(defaults, presets, overrides);\n    }\n    const { fills, strokes, ...otherColors } = this.getDefaultColors();\n    this.palette = mergeDefaults(palette, {\n      fills: Object.values(fills),\n      strokes: Object.values(strokes),\n      ...otherColors\n    });\n    this.paletteType = paletteType(palette);\n    this.config = Object.freeze(this.templateTheme(defaults));\n    this.presets = presets;\n  }\n  mergeOverrides(defaults, presets, overrides) {\n    for (const { seriesTypes, commonOptions } of Object.values(CHART_TYPE_CONFIG)) {\n      const cleanedCommon = { ...overrides.common };\n      for (const commonKey of CHART_TYPE_SPECIFIC_COMMON_OPTIONS) {\n        if (!commonOptions.includes(commonKey)) {\n          delete cleanedCommon[commonKey];\n        }\n      }\n      if (!cleanedCommon)\n        continue;\n      for (const s of seriesTypes) {\n        const seriesType2 = s;\n        if (!isPresetOverridesType(seriesType2)) {\n          defaults[seriesType2] = mergeDefaults(cleanedCommon, defaults[seriesType2]);\n        }\n      }\n    }\n    chartTypes.seriesTypes.forEach((s) => {\n      const seriesType2 = s;\n      const seriesOverrides = overrides[seriesType2];\n      if (isPresetOverridesType(seriesType2)) {\n        presets[seriesType2] = seriesOverrides;\n      } else {\n        defaults[seriesType2] = mergeDefaults(seriesOverrides, defaults[seriesType2]);\n      }\n    });\n  }\n  createChartConfigPerChartType(config) {\n    for (const [nextType, { seriesTypes }] of Object.entries(CHART_TYPE_CONFIG)) {\n      const typeDefaults = chartDefaults.get(nextType);\n      for (const seriesType2 of seriesTypes) {\n        config[seriesType2] || (config[seriesType2] = deepClone(typeDefaults));\n      }\n    }\n    return config;\n  }\n  getDefaults() {\n    const getOverridesByType = (chartType2, seriesTypes) => {\n      const result = {};\n      const chartTypeDefaults = {\n        axes: {},\n        ...legendRegistry.getThemeTemplates(),\n        ...this.getChartDefaults(),\n        ...chartDefaults.get(chartType2)\n      };\n      for (const seriesType2 of seriesTypes) {\n        result[seriesType2] = mergeDefaults(\n          seriesRegistry.getThemeTemplate(seriesType2),\n          result[seriesType2] ?? deepClone(chartTypeDefaults)\n        );\n        const { axes } = result[seriesType2];\n        for (const axisType of axisRegistry.keys()) {\n          axes[axisType] = mergeDefaults(\n            axes[axisType],\n            axisRegistry.getThemeTemplate(axisType),\n            _ChartTheme.cartesianAxisDefault[axisType]\n          );\n        }\n      }\n      return result;\n    };\n    return mergeDefaults(\n      getOverridesByType(\"cartesian\", chartTypes.cartesianTypes),\n      getOverridesByType(\"polar\", chartTypes.polarTypes),\n      getOverridesByType(\"hierarchy\", chartTypes.hierarchyTypes),\n      getOverridesByType(\"topology\", chartTypes.topologyTypes),\n      getOverridesByType(\"flow-proportion\", chartTypes.flowProportionTypes),\n      getOverridesByType(\"standalone\", chartTypes.standaloneTypes),\n      getOverridesByType(\"gauge\", chartTypes.gaugeTypes)\n    );\n  }\n  templateTheme(themeTemplate) {\n    const themeInstance = deepClone(themeTemplate);\n    const params = this.getTemplateParameters();\n    jsonWalk(themeInstance, (node) => {\n      if (isArray(node)) {\n        for (let i = 0; i < node.length; i++) {\n          const symbol = node[i];\n          if (params.has(symbol)) {\n            node[i] = params.get(symbol);\n          }\n        }\n      } else {\n        for (const [name, value] of Object.entries(node)) {\n          if (params.has(value)) {\n            node[name] = params.get(value);\n          }\n        }\n      }\n    });\n    return deepClone(themeInstance);\n  }\n  getDefaultColors() {\n    return {\n      fills: DEFAULT_FILLS,\n      strokes: DEFAULT_STROKES,\n      up: { fill: DEFAULT_FILLS.GREEN, stroke: DEFAULT_STROKES.GREEN },\n      down: { fill: DEFAULT_FILLS.RED, stroke: DEFAULT_STROKES.RED },\n      neutral: { fill: DEFAULT_FILLS.GRAY, stroke: DEFAULT_STROKES.GRAY },\n      altUp: { fill: DEFAULT_FILLS.BLUE, stroke: DEFAULT_STROKES.BLUE },\n      altDown: { fill: DEFAULT_FILLS.ORANGE, stroke: DEFAULT_STROKES.ORANGE },\n      altNeutral: { fill: DEFAULT_FILLS.GRAY, stroke: DEFAULT_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const { isEnterprise } = enterpriseModule;\n    const params = /* @__PURE__ */ new Map();\n    params.set(IS_DARK_THEME, false);\n    params.set(IS_ENTERPRISE, isEnterprise);\n    params.set(IS_COMMUNITY, !isEnterprise);\n    params.set(DEFAULT_FONT_FAMILY, \"Verdana, sans-serif\");\n    params.set(DEFAULT_LABEL_COLOUR, \"rgb(70, 70, 70)\");\n    params.set(DEFAULT_INVERTED_LABEL_COLOUR, \"white\");\n    params.set(DEFAULT_MUTED_LABEL_COLOUR, \"rgb(140, 140, 140)\");\n    params.set(DEFAULT_AXIS_GRID_COLOUR, \"rgb(224,234,241)\");\n    params.set(DEFAULT_AXIS_LINE_COLOUR, \"rgb(195, 195, 195)\");\n    params.set(DEFAULT_CROSS_LINES_COLOUR, \"rgb(70, 70, 70)\");\n    params.set(DEFAULT_INSIDE_SERIES_LABEL_COLOUR, DEFAULT_BACKGROUND_FILL);\n    params.set(DEFAULT_BACKGROUND_COLOUR, DEFAULT_BACKGROUND_FILL);\n    params.set(DEFAULT_SHADOW_COLOUR, \"rgba(0, 0, 0, 0.5)\");\n    params.set(DEFAULT_DIVERGING_SERIES_COLOR_RANGE, [\n      DEFAULT_FILLS.ORANGE,\n      DEFAULT_FILLS.YELLOW,\n      DEFAULT_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_GAUGE_SERIES_COLOR_RANGE, [DEFAULT_FILLS.GREEN, DEFAULT_FILLS.YELLOW, DEFAULT_FILLS.RED]);\n    params.set(DEFAULT_FUNNEL_SERIES_COLOR_RANGE, [\n      \"#5090dc\",\n      \"#629be0\",\n      \"#73a6e3\",\n      \"#85b1e7\",\n      \"#96bcea\",\n      \"#a8c8ee\",\n      \"#b9d3f1\",\n      \"#cbdef5\"\n    ]);\n    params.set(DEFAULT_PADDING, 20);\n    params.set(DEFAULT_CAPTION_LAYOUT_STYLE, \"block\");\n    params.set(DEFAULT_CAPTION_ALIGNMENT, \"center\");\n    params.set(DEFAULT_HIERARCHY_FILLS, [\"#ffffff\", \"#e0e5ea\", \"#c1ccd5\", \"#a3b4c1\", \"#859cad\"]);\n    params.set(DEFAULT_HIERARCHY_STROKES, [\"#ffffff\", \"#c5cbd1\", \"#a4b1bd\", \"#8498a9\", \"#648096\"]);\n    params.set(DEFAULT_POLAR_SERIES_STROKE, DEFAULT_BACKGROUND_FILL);\n    params.set(DEFAULT_ANNOTATION_COLOR, DEFAULT_FILLS.BLUE);\n    params.set(DEFAULT_TEXT_ANNOTATION_COLOR, DEFAULT_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, DEFAULT_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_HANDLE_FILL, DEFAULT_BACKGROUND_FILL);\n    params.set(DEFAULT_ANNOTATION_STATISTICS_FILL, \"#fafafa\");\n    params.set(DEFAULT_ANNOTATION_STATISTICS_STROKE, \"#dddddd\");\n    params.set(DEFAULT_ANNOTATION_STATISTICS_COLOR, \"#000000\");\n    params.set(DEFAULT_ANNOTATION_STATISTICS_DIVIDER_STROKE, \"#181d1f\");\n    params.set(DEFAULT_ANNOTATION_STATISTICS_DOWN_FILL, \"#e35c5c\");\n    params.set(DEFAULT_ANNOTATION_STATISTICS_DOWN_STROKE, \"#e35c5c\");\n    params.set(DEFAULT_TEXTBOX_FILL, \"#fafafa\");\n    params.set(DEFAULT_TEXTBOX_STROKE, \"#dddddd\");\n    params.set(DEFAULT_TEXTBOX_COLOR, \"#000000\");\n    params.set(DEFAULT_TOOLBAR_POSITION, \"top\");\n    params.set(DEFAULT_GRIDLINE_ENABLED, false);\n    const defaultColors = this.getDefaultColors();\n    params.set(PALETTE_UP_STROKE, this.palette.up?.stroke ?? defaultColors.up.stroke);\n    params.set(PALETTE_UP_FILL, this.palette.up?.fill ?? defaultColors.up.fill);\n    params.set(PALETTE_DOWN_STROKE, this.palette.down?.stroke ?? defaultColors.down.stroke);\n    params.set(PALETTE_DOWN_FILL, this.palette.down?.fill ?? defaultColors.down.fill);\n    params.set(PALETTE_NEUTRAL_STROKE, this.palette.neutral?.stroke ?? defaultColors.neutral.stroke);\n    params.set(PALETTE_NEUTRAL_FILL, this.palette.neutral?.fill ?? defaultColors.neutral.fill);\n    params.set(PALETTE_ALT_UP_STROKE, this.palette.altUp?.stroke ?? defaultColors.up.stroke);\n    params.set(PALETTE_ALT_UP_FILL, this.palette.altUp?.fill ?? defaultColors.up.fill);\n    params.set(PALETTE_ALT_DOWN_STROKE, this.palette.altDown?.stroke ?? defaultColors.down.stroke);\n    params.set(PALETTE_ALT_DOWN_FILL, this.palette.altDown?.fill ?? defaultColors.down.fill);\n    params.set(PALETTE_ALT_NEUTRAL_FILL, this.palette.altNeutral?.fill ?? defaultColors.altNeutral.fill);\n    params.set(PALETTE_ALT_NEUTRAL_STROKE, this.palette.altNeutral?.stroke ?? defaultColors.altNeutral.stroke);\n    return params;\n  }\n};\n_ChartTheme.cartesianAxisDefault = {\n  [\"number\" /* NUMBER */]: _ChartTheme.getAxisDefaults({\n    line: { enabled: false }\n  }),\n  [\"log\" /* LOG */]: _ChartTheme.getAxisDefaults({\n    base: 10,\n    line: { enabled: false },\n    interval: { minSpacing: NaN }\n  }),\n  [\"category\" /* CATEGORY */]: _ChartTheme.getAxisDefaults({\n    groupPaddingInner: 0.1,\n    label: { autoRotate: true },\n    gridLine: { enabled: DEFAULT_GRIDLINE_ENABLED },\n    crosshair: { enabled: false }\n  }),\n  [\"time\" /* TIME */]: _ChartTheme.getAxisDefaults({ gridLine: { enabled: DEFAULT_GRIDLINE_ENABLED } }),\n  [\"ordinal-time\" /* ORDINAL_TIME */]: _ChartTheme.getAxisDefaults({\n    groupPaddingInner: 0,\n    label: { autoRotate: false },\n    gridLine: { enabled: DEFAULT_GRIDLINE_ENABLED }\n  }),\n  [\"angle-category\" /* ANGLE_CATEGORY */]: _ChartTheme.getAxisDefaults({\n    gridLine: { enabled: DEFAULT_GRIDLINE_ENABLED }\n  }),\n  [\"angle-number\" /* ANGLE_NUMBER */]: _ChartTheme.getAxisDefaults({ gridLine: { enabled: DEFAULT_GRIDLINE_ENABLED } }),\n  [\"radius-category\" /* RADIUS_CATEGORY */]: _ChartTheme.getAxisDefaults({\n    line: { enabled: false }\n  }),\n  [\"radius-number\" /* RADIUS_NUMBER */]: _ChartTheme.getAxisDefaults({\n    line: { enabled: false }\n  }),\n  \"grouped-category\": _ChartTheme.getAxisDefaults({\n    tick: { enabled: true }\n  })\n};\nvar ChartTheme = _ChartTheme;\n\n// packages/ag-charts-community/src/chart/themes/darkTheme.ts\nvar DEFAULT_DARK_BACKGROUND_FILL = \"#192232\";\nvar DEFAULT_DARK_FILLS = {\n  BLUE: \"#5090dc\",\n  ORANGE: \"#ffa03a\",\n  GREEN: \"#459d55\",\n  CYAN: \"#34bfe1\",\n  YELLOW: \"#e1cc00\",\n  VIOLET: \"#9669cb\",\n  GRAY: \"#b5b5b5\",\n  MAGENTA: \"#bd5aa7\",\n  BROWN: \"#8a6224\",\n  RED: \"#ef5452\"\n};\nvar DEFAULT_DARK_STROKES = {\n  BLUE: \"#74a8e6\",\n  ORANGE: \"#ffbe70\",\n  GREEN: \"#6cb176\",\n  CYAN: \"#75d4ef\",\n  YELLOW: \"#f6e559\",\n  VIOLET: \"#aa86d8\",\n  GRAY: \"#a1a1a1\",\n  MAGENTA: \"#ce7ab9\",\n  BROWN: \"#997b52\",\n  RED: \"#ff7872\"\n};\nvar DarkTheme = class extends ChartTheme {\n  getDefaultColors() {\n    return {\n      fills: DEFAULT_DARK_FILLS,\n      strokes: DEFAULT_DARK_STROKES,\n      up: { fill: DEFAULT_DARK_FILLS.GREEN, stroke: DEFAULT_DARK_STROKES.GREEN },\n      down: { fill: DEFAULT_DARK_FILLS.RED, stroke: DEFAULT_DARK_STROKES.RED },\n      neutral: { fill: DEFAULT_DARK_FILLS.GRAY, stroke: DEFAULT_DARK_STROKES.GRAY },\n      altUp: { fill: DEFAULT_DARK_FILLS.BLUE, stroke: DEFAULT_DARK_STROKES.BLUE },\n      altDown: { fill: DEFAULT_DARK_FILLS.ORANGE, stroke: DEFAULT_DARK_STROKES.ORANGE },\n      altNeutral: { fill: DEFAULT_DARK_FILLS.GRAY, stroke: DEFAULT_DARK_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(IS_DARK_THEME, true);\n    params.set(DEFAULT_POLAR_SERIES_STROKE, DEFAULT_DARK_BACKGROUND_FILL);\n    params.set(DEFAULT_LABEL_COLOUR, \"white\");\n    params.set(DEFAULT_MUTED_LABEL_COLOUR, \"#7D91A0\");\n    params.set(DEFAULT_AXIS_GRID_COLOUR, \"#545A6E\");\n    params.set(DEFAULT_CROSS_LINES_COLOUR, \"white\");\n    params.set(DEFAULT_DIVERGING_SERIES_COLOR_RANGE, [\n      DEFAULT_DARK_FILLS.ORANGE,\n      DEFAULT_DARK_FILLS.YELLOW,\n      DEFAULT_DARK_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_GAUGE_SERIES_COLOR_RANGE, [\n      DEFAULT_DARK_FILLS.GREEN,\n      DEFAULT_DARK_FILLS.YELLOW,\n      DEFAULT_DARK_FILLS.RED\n    ]);\n    params.set(DEFAULT_FUNNEL_SERIES_COLOR_RANGE, [\n      \"#5090dc\",\n      \"#4882c6\",\n      \"#4073b0\",\n      \"#38659a\",\n      \"#305684\",\n      \"#28486e\",\n      \"#203a58\",\n      \"#182b42\"\n    ]);\n    params.set(DEFAULT_HIERARCHY_FILLS, [\"#192834\", \"#253746\", \"#324859\", \"#3f596c\", \"#4d6a80\"]);\n    params.set(DEFAULT_HIERARCHY_STROKES, [\"#192834\", \"#3b5164\", \"#496275\", \"#577287\", \"#668399\"]);\n    params.set(DEFAULT_BACKGROUND_COLOUR, DEFAULT_DARK_BACKGROUND_FILL);\n    params.set(DEFAULT_INSIDE_SERIES_LABEL_COLOUR, DEFAULT_DARK_BACKGROUND_FILL);\n    params.set(DEFAULT_ANNOTATION_COLOR, DEFAULT_DARK_FILLS.BLUE);\n    params.set(DEFAULT_TEXT_ANNOTATION_COLOR, \"white\");\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, DEFAULT_DARK_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_HANDLE_FILL, DEFAULT_DARK_BACKGROUND_FILL);\n    params.set(DEFAULT_ANNOTATION_STATISTICS_FILL, \"#28313e\");\n    params.set(DEFAULT_ANNOTATION_STATISTICS_STROKE, \"#4b525d\");\n    params.set(DEFAULT_ANNOTATION_STATISTICS_COLOR, \"#ffffff\");\n    params.set(DEFAULT_ANNOTATION_STATISTICS_DIVIDER_STROKE, \"#ffffff\");\n    params.set(DEFAULT_TEXTBOX_FILL, \"#28313e\");\n    params.set(DEFAULT_TEXTBOX_STROKE, \"#4b525d\");\n    params.set(DEFAULT_TEXTBOX_COLOR, \"#ffffff\");\n    return params;\n  }\n  constructor(options) {\n    super(options);\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/financialDark.ts\nvar FINANCIAL_DARK_FILLS = {\n  GREEN: \"#089981\",\n  RED: \"#F23645\",\n  BLUE: \"#5090dc\",\n  GRAY: \"#A9A9A9\"\n};\nvar FINANCIAL_DARK_STROKES = {\n  GREEN: \"#089981\",\n  RED: \"#F23645\",\n  BLUE: \"#5090dc\",\n  GRAY: \"#909090\"\n};\nvar FinancialDark = class extends DarkTheme {\n  getDefaultColors() {\n    return {\n      fills: { ...FINANCIAL_DARK_FILLS },\n      strokes: { ...FINANCIAL_DARK_STROKES },\n      up: { fill: FINANCIAL_DARK_FILLS.GREEN, stroke: FINANCIAL_DARK_STROKES.GREEN },\n      down: { fill: FINANCIAL_DARK_FILLS.RED, stroke: FINANCIAL_DARK_STROKES.RED },\n      neutral: { fill: FINANCIAL_DARK_FILLS.BLUE, stroke: FINANCIAL_DARK_STROKES.BLUE },\n      altUp: { fill: FINANCIAL_DARK_FILLS.GREEN, stroke: FINANCIAL_DARK_STROKES.GREEN },\n      altDown: { fill: FINANCIAL_DARK_FILLS.RED, stroke: FINANCIAL_DARK_STROKES.RED },\n      altNeutral: { fill: FINANCIAL_DARK_FILLS.GRAY, stroke: FINANCIAL_DARK_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOR_RANGE, [\n      FINANCIAL_DARK_FILLS.GREEN,\n      FINANCIAL_DARK_FILLS.BLUE,\n      FINANCIAL_DARK_FILLS.RED\n    ]);\n    params.set(DEFAULT_ANNOTATION_COLOR, FINANCIAL_DARK_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, FINANCIAL_DARK_FILLS.BLUE);\n    params.set(DEFAULT_AXIS_GRID_COLOUR, \"#343A4E\");\n    params.set(DEFAULT_PADDING, 0);\n    params.set(DEFAULT_CAPTION_LAYOUT_STYLE, \"overlay\");\n    params.set(DEFAULT_CAPTION_ALIGNMENT, \"left\");\n    params.set(DEFAULT_TOOLBAR_POSITION, \"bottom\");\n    params.set(DEFAULT_GRIDLINE_ENABLED, true);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/financialLight.ts\nvar FINANCIAL_LIGHT_FILLS = {\n  GREEN: \"#089981\",\n  RED: \"#F23645\",\n  BLUE: \"#5090dc\",\n  GRAY: \"#A9A9A9\"\n};\nvar FINANCIAL_LIGHT_STROKES = {\n  GREEN: \"#089981\",\n  RED: \"#F23645\",\n  BLUE: \"#5090dc\",\n  GRAY: \"#909090\"\n};\nvar FinancialLight = class extends ChartTheme {\n  getDefaultColors() {\n    return {\n      fills: { ...FINANCIAL_LIGHT_FILLS },\n      strokes: { ...FINANCIAL_LIGHT_STROKES },\n      up: { fill: FINANCIAL_LIGHT_FILLS.GREEN, stroke: FINANCIAL_LIGHT_STROKES.GREEN },\n      down: { fill: FINANCIAL_LIGHT_FILLS.RED, stroke: FINANCIAL_LIGHT_STROKES.RED },\n      neutral: { fill: FINANCIAL_LIGHT_FILLS.BLUE, stroke: FINANCIAL_LIGHT_STROKES.BLUE },\n      altUp: { fill: FINANCIAL_LIGHT_FILLS.GREEN, stroke: FINANCIAL_LIGHT_STROKES.GREEN },\n      altDown: { fill: FINANCIAL_LIGHT_FILLS.RED, stroke: FINANCIAL_LIGHT_STROKES.RED },\n      altNeutral: { fill: FINANCIAL_LIGHT_FILLS.GRAY, stroke: FINANCIAL_LIGHT_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOR_RANGE, [\n      FINANCIAL_LIGHT_FILLS.GREEN,\n      FINANCIAL_LIGHT_FILLS.BLUE,\n      FINANCIAL_LIGHT_FILLS.RED\n    ]);\n    params.set(DEFAULT_ANNOTATION_COLOR, FINANCIAL_LIGHT_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, FINANCIAL_LIGHT_FILLS.BLUE);\n    params.set(DEFAULT_AXIS_GRID_COLOUR, \"#F2F3F3\");\n    params.set(DEFAULT_PADDING, 0);\n    params.set(DEFAULT_CAPTION_LAYOUT_STYLE, \"overlay\");\n    params.set(DEFAULT_CAPTION_ALIGNMENT, \"left\");\n    params.set(DEFAULT_TOOLBAR_POSITION, \"bottom\");\n    params.set(DEFAULT_GRIDLINE_ENABLED, true);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/materialDark.ts\nvar MATERIAL_DARK_FILLS = {\n  BLUE: \"#2196F3\",\n  ORANGE: \"#FF9800\",\n  GREEN: \"#4CAF50\",\n  CYAN: \"#00BCD4\",\n  YELLOW: \"#FFEB3B\",\n  VIOLET: \"#7E57C2\",\n  GRAY: \"#9E9E9E\",\n  MAGENTA: \"#F06292\",\n  BROWN: \"#795548\",\n  RED: \"#F44336\"\n};\nvar MATERIAL_DARK_STROKES = {\n  BLUE: \"#90CAF9\",\n  ORANGE: \"#FFCC80\",\n  GREEN: \"#A5D6A7\",\n  CYAN: \"#80DEEA\",\n  YELLOW: \"#FFF9C4\",\n  VIOLET: \"#B39DDB\",\n  GRAY: \"#E0E0E0\",\n  MAGENTA: \"#F48FB1\",\n  BROWN: \"#A1887F\",\n  RED: \"#EF9A9A\"\n};\nvar MaterialDark = class extends DarkTheme {\n  getDefaultColors() {\n    return {\n      fills: MATERIAL_DARK_FILLS,\n      strokes: MATERIAL_DARK_STROKES,\n      up: { fill: MATERIAL_DARK_FILLS.GREEN, stroke: MATERIAL_DARK_STROKES.GREEN },\n      down: { fill: MATERIAL_DARK_FILLS.RED, stroke: MATERIAL_DARK_STROKES.RED },\n      neutral: { fill: MATERIAL_DARK_FILLS.GRAY, stroke: MATERIAL_DARK_STROKES.GRAY },\n      altUp: { fill: MATERIAL_DARK_FILLS.BLUE, stroke: MATERIAL_DARK_STROKES.BLUE },\n      altDown: { fill: MATERIAL_DARK_FILLS.RED, stroke: MATERIAL_DARK_STROKES.RED },\n      altNeutral: { fill: MATERIAL_DARK_FILLS.GRAY, stroke: MATERIAL_DARK_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOR_RANGE, [\n      MATERIAL_DARK_FILLS.ORANGE,\n      MATERIAL_DARK_FILLS.YELLOW,\n      MATERIAL_DARK_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_FUNNEL_SERIES_COLOR_RANGE, [\n      \"#2196f3\",\n      // 500\n      \"#208FEC\",\n      // (interpolated)\n      \"#1E88E5\",\n      // 600\n      \"#1C7FDC\",\n      // (interpolated)\n      \"#1976d2\",\n      // 700\n      \"#176EC9\",\n      // (interpolated)\n      \"#1565c0\"\n      // 800\n    ]);\n    params.set(DEFAULT_GAUGE_SERIES_COLOR_RANGE, [\n      MATERIAL_DARK_FILLS.GREEN,\n      MATERIAL_DARK_FILLS.YELLOW,\n      MATERIAL_DARK_FILLS.RED\n    ]);\n    params.set(DEFAULT_ANNOTATION_COLOR, MATERIAL_DARK_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, MATERIAL_DARK_FILLS.BLUE);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/materialLight.ts\nvar MATERIAL_LIGHT_FILLS = {\n  BLUE: \"#2196F3\",\n  ORANGE: \"#FF9800\",\n  GREEN: \"#4CAF50\",\n  CYAN: \"#00BCD4\",\n  YELLOW: \"#FFEB3B\",\n  VIOLET: \"#7E57C2\",\n  GRAY: \"#9E9E9E\",\n  MAGENTA: \"#F06292\",\n  BROWN: \"#795548\",\n  RED: \"#F44336\"\n};\nvar MATERIAL_LIGHT_STROKES = {\n  BLUE: \"#1565C0\",\n  ORANGE: \"#E65100\",\n  GREEN: \"#2E7D32\",\n  CYAN: \"#00838F\",\n  YELLOW: \"#F9A825\",\n  VIOLET: \"#4527A0\",\n  GRAY: \"#616161\",\n  MAGENTA: \"#C2185B\",\n  BROWN: \"#4E342E\",\n  RED: \"#B71C1C\"\n};\nvar MaterialLight = class extends ChartTheme {\n  getDefaultColors() {\n    return {\n      fills: MATERIAL_LIGHT_FILLS,\n      strokes: MATERIAL_LIGHT_STROKES,\n      up: { fill: MATERIAL_LIGHT_FILLS.GREEN, stroke: MATERIAL_LIGHT_STROKES.GREEN },\n      down: { fill: MATERIAL_LIGHT_FILLS.RED, stroke: MATERIAL_LIGHT_STROKES.RED },\n      neutral: { fill: MATERIAL_LIGHT_FILLS.GRAY, stroke: MATERIAL_LIGHT_STROKES.GRAY },\n      altUp: { fill: MATERIAL_LIGHT_FILLS.BLUE, stroke: MATERIAL_LIGHT_STROKES.BLUE },\n      altDown: { fill: MATERIAL_LIGHT_FILLS.RED, stroke: MATERIAL_LIGHT_STROKES.RED },\n      altNeutral: { fill: MATERIAL_LIGHT_FILLS.GRAY, stroke: MATERIAL_LIGHT_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOR_RANGE, [\n      MATERIAL_LIGHT_FILLS.ORANGE,\n      MATERIAL_LIGHT_FILLS.YELLOW,\n      MATERIAL_LIGHT_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_FUNNEL_SERIES_COLOR_RANGE, [\n      \"#2196f3\",\n      // 500\n      \"#329EF4\",\n      // (interpolated)\n      \"#42a5f5\",\n      // 400\n      \"#53ADF6\",\n      // (interpolated)\n      \"#64b5f6\",\n      // 300\n      \"#7AC0F8\",\n      // (interpolated)\n      \"#90caf9\"\n      // 200\n    ]);\n    params.set(DEFAULT_GAUGE_SERIES_COLOR_RANGE, [\n      MATERIAL_LIGHT_FILLS.GREEN,\n      MATERIAL_LIGHT_FILLS.YELLOW,\n      MATERIAL_LIGHT_FILLS.RED\n    ]);\n    params.set(DEFAULT_ANNOTATION_COLOR, MATERIAL_LIGHT_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, MATERIAL_LIGHT_FILLS.BLUE);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/polychromaDark.ts\nvar POLYCHROMA_DARK_FILLS = {\n  BLUE: \"#436ff4\",\n  PURPLE: \"#9a7bff\",\n  MAGENTA: \"#d165d2\",\n  PINK: \"#f0598b\",\n  RED: \"#f47348\",\n  ORANGE: \"#f2a602\",\n  YELLOW: \"#e9e201\",\n  GREEN: \"#21b448\",\n  CYAN: \"#00b9a2\",\n  MODERATE_BLUE: \"#00aee4\",\n  GRAY: \"#bbbbbb\"\n};\nvar POLYCHROMA_DARK_STROKES = {\n  BLUE: \"#6698ff\",\n  PURPLE: \"#c0a3ff\",\n  MAGENTA: \"#fc8dfc\",\n  PINK: \"#ff82b1\",\n  RED: \"#ff9b70\",\n  ORANGE: \"#ffcf4e\",\n  YELLOW: \"#ffff58\",\n  GREEN: \"#58dd70\",\n  CYAN: \"#51e2c9\",\n  MODERATE_BLUE: \"#4fd7ff\",\n  GRAY: \"#eeeeee\"\n};\nvar PolychromaDark = class extends DarkTheme {\n  getDefaultColors() {\n    return {\n      fills: POLYCHROMA_DARK_FILLS,\n      strokes: POLYCHROMA_DARK_STROKES,\n      up: { fill: POLYCHROMA_DARK_FILLS.GREEN, stroke: POLYCHROMA_DARK_STROKES.GREEN },\n      down: { fill: POLYCHROMA_DARK_FILLS.RED, stroke: POLYCHROMA_DARK_STROKES.RED },\n      neutral: { fill: POLYCHROMA_DARK_FILLS.GRAY, stroke: POLYCHROMA_DARK_STROKES.GRAY },\n      altUp: { fill: POLYCHROMA_DARK_FILLS.BLUE, stroke: POLYCHROMA_DARK_STROKES.BLUE },\n      altDown: { fill: POLYCHROMA_DARK_FILLS.RED, stroke: POLYCHROMA_DARK_STROKES.RED },\n      altNeutral: { fill: POLYCHROMA_DARK_FILLS.GRAY, stroke: POLYCHROMA_DARK_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOR_RANGE, [POLYCHROMA_DARK_FILLS.BLUE, POLYCHROMA_DARK_FILLS.RED]);\n    params.set(DEFAULT_FUNNEL_SERIES_COLOR_RANGE, [\n      POLYCHROMA_DARK_FILLS.BLUE,\n      POLYCHROMA_DARK_FILLS.PURPLE,\n      POLYCHROMA_DARK_FILLS.MAGENTA,\n      POLYCHROMA_DARK_FILLS.PINK,\n      POLYCHROMA_DARK_FILLS.RED,\n      POLYCHROMA_DARK_FILLS.ORANGE,\n      POLYCHROMA_DARK_FILLS.YELLOW,\n      POLYCHROMA_DARK_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_GAUGE_SERIES_COLOR_RANGE, [POLYCHROMA_DARK_FILLS.BLUE, POLYCHROMA_DARK_FILLS.RED]);\n    params.set(DEFAULT_ANNOTATION_COLOR, POLYCHROMA_DARK_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, POLYCHROMA_DARK_FILLS.BLUE);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/polychromaLight.ts\nvar POLYCHROMA_LIGHT_FILLS = {\n  BLUE: \"#436ff4\",\n  PURPLE: \"#9a7bff\",\n  MAGENTA: \"#d165d2\",\n  PINK: \"#f0598b\",\n  RED: \"#f47348\",\n  ORANGE: \"#f2a602\",\n  YELLOW: \"#e9e201\",\n  GREEN: \"#21b448\",\n  CYAN: \"#00b9a2\",\n  MODERATE_BLUE: \"#00aee4\",\n  GRAY: \"#bbbbbb\"\n};\nvar POLYCHROMA_LIGHT_STROKES = {\n  BLUE: \"#2346c9\",\n  PURPLE: \"#7653d4\",\n  MAGENTA: \"#a73da9\",\n  PINK: \"#c32d66\",\n  RED: \"#c84b1c\",\n  ORANGE: \"#c87f00\",\n  YELLOW: \"#c1b900\",\n  GREEN: \"#008c1c\",\n  CYAN: \"#00927c\",\n  MODERATE_BLUE: \"#0087bb\",\n  GRAY: \"#888888\"\n};\nvar PolychromaLight = class extends ChartTheme {\n  getDefaultColors() {\n    return {\n      fills: POLYCHROMA_LIGHT_FILLS,\n      strokes: POLYCHROMA_LIGHT_STROKES,\n      up: { fill: POLYCHROMA_LIGHT_FILLS.GREEN, stroke: POLYCHROMA_LIGHT_STROKES.GREEN },\n      down: { fill: POLYCHROMA_LIGHT_FILLS.RED, stroke: POLYCHROMA_LIGHT_STROKES.RED },\n      neutral: { fill: POLYCHROMA_LIGHT_FILLS.GRAY, stroke: POLYCHROMA_LIGHT_STROKES.GRAY },\n      altUp: { fill: POLYCHROMA_LIGHT_FILLS.BLUE, stroke: POLYCHROMA_LIGHT_STROKES.BLUE },\n      altDown: { fill: POLYCHROMA_LIGHT_FILLS.RED, stroke: POLYCHROMA_LIGHT_STROKES.RED },\n      altNeutral: { fill: POLYCHROMA_LIGHT_FILLS.GRAY, stroke: POLYCHROMA_LIGHT_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOR_RANGE, [POLYCHROMA_LIGHT_FILLS.BLUE, POLYCHROMA_LIGHT_FILLS.RED]);\n    params.set(DEFAULT_FUNNEL_SERIES_COLOR_RANGE, [\n      POLYCHROMA_LIGHT_FILLS.BLUE,\n      POLYCHROMA_LIGHT_FILLS.PURPLE,\n      POLYCHROMA_LIGHT_FILLS.MAGENTA,\n      POLYCHROMA_LIGHT_FILLS.PINK,\n      POLYCHROMA_LIGHT_FILLS.RED,\n      POLYCHROMA_LIGHT_FILLS.ORANGE,\n      POLYCHROMA_LIGHT_FILLS.YELLOW,\n      POLYCHROMA_LIGHT_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_GAUGE_SERIES_COLOR_RANGE, [POLYCHROMA_LIGHT_FILLS.BLUE, POLYCHROMA_LIGHT_FILLS.RED]);\n    params.set(DEFAULT_ANNOTATION_COLOR, POLYCHROMA_LIGHT_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, POLYCHROMA_LIGHT_FILLS.BLUE);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/sheetsDark.ts\nvar SHEETS_DARK_FILLS = {\n  BLUE: \"#4472C4\",\n  ORANGE: \"#ED7D31\",\n  GRAY: \"#A5A5A5\",\n  YELLOW: \"#FFC000\",\n  MODERATE_BLUE: \"#5B9BD5\",\n  GREEN: \"#70AD47\",\n  DARK_GRAY: \"#7B7B7B\",\n  DARK_BLUE: \"#264478\",\n  VERY_DARK_GRAY: \"#636363\",\n  DARK_YELLOW: \"#997300\"\n};\nvar SHEETS_DARK_STROKES = {\n  BLUE: \"#6899ee\",\n  ORANGE: \"#ffa55d\",\n  GRAY: \"#cdcdcd\",\n  YELLOW: \"#ffea53\",\n  MODERATE_BLUE: \"#82c3ff\",\n  GREEN: \"#96d56f\",\n  DARK_GRAY: \"#a1a1a1\",\n  DARK_BLUE: \"#47689f\",\n  VERY_DARK_GRAY: \"#878787\",\n  DARK_YELLOW: \"#c0993d\"\n};\nvar SheetsDark = class extends DarkTheme {\n  getDefaultColors() {\n    return {\n      fills: { ...SHEETS_DARK_FILLS, RED: SHEETS_DARK_FILLS.ORANGE },\n      strokes: { ...SHEETS_DARK_STROKES, RED: SHEETS_DARK_STROKES.ORANGE },\n      up: { fill: SHEETS_DARK_FILLS.GREEN, stroke: SHEETS_DARK_STROKES.GREEN },\n      down: { fill: SHEETS_DARK_FILLS.ORANGE, stroke: SHEETS_DARK_STROKES.ORANGE },\n      neutral: { fill: SHEETS_DARK_FILLS.GRAY, stroke: SHEETS_DARK_STROKES.GRAY },\n      altUp: { fill: SHEETS_DARK_FILLS.BLUE, stroke: SHEETS_DARK_STROKES.BLUE },\n      altDown: { fill: SHEETS_DARK_FILLS.ORANGE, stroke: SHEETS_DARK_STROKES.ORANGE },\n      altNeutral: { fill: SHEETS_DARK_FILLS.GRAY, stroke: SHEETS_DARK_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOR_RANGE, [\n      SHEETS_DARK_FILLS.ORANGE,\n      SHEETS_DARK_FILLS.YELLOW,\n      SHEETS_DARK_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_GAUGE_SERIES_COLOR_RANGE, [\n      SHEETS_DARK_FILLS.GREEN,\n      SHEETS_DARK_FILLS.YELLOW,\n      SHEETS_DARK_FILLS.ORANGE\n    ]);\n    params.set(DEFAULT_ANNOTATION_COLOR, SHEETS_DARK_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, SHEETS_DARK_FILLS.BLUE);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/sheetsLight.ts\nvar SHEETS_LIGHT_FILLS = {\n  BLUE: \"#5281d5\",\n  ORANGE: \"#ff8d44\",\n  GRAY: \"#b5b5b5\",\n  YELLOW: \"#ffd02f\",\n  MODERATE_BLUE: \"#6aabe6\",\n  GREEN: \"#7fbd57\",\n  DARK_GRAY: \"#8a8a8a\",\n  DARK_BLUE: \"#335287\",\n  VERY_DARK_GRAY: \"#717171\",\n  DARK_YELLOW: \"#a98220\"\n};\nvar SHEETS_LIGHT_STROKES = {\n  BLUE: \"#214d9b\",\n  ORANGE: \"#c25600\",\n  GRAY: \"#7f7f7f\",\n  YELLOW: \"#d59800\",\n  MODERATE_BLUE: \"#3575ac\",\n  GREEN: \"#4b861a\",\n  DARK_GRAY: \"#575757\",\n  DARK_BLUE: \"#062253\",\n  VERY_DARK_GRAY: \"#414141\",\n  DARK_YELLOW: \"#734f00\"\n};\nvar SheetsLight = class extends ChartTheme {\n  getDefaultColors() {\n    return {\n      fills: { ...SHEETS_LIGHT_FILLS, RED: SHEETS_LIGHT_FILLS.ORANGE },\n      strokes: { ...SHEETS_LIGHT_STROKES, RED: SHEETS_LIGHT_STROKES.ORANGE },\n      up: { fill: SHEETS_LIGHT_FILLS.GREEN, stroke: SHEETS_LIGHT_STROKES.GREEN },\n      down: { fill: SHEETS_LIGHT_FILLS.ORANGE, stroke: SHEETS_LIGHT_STROKES.ORANGE },\n      neutral: { fill: SHEETS_LIGHT_STROKES.GRAY, stroke: SHEETS_LIGHT_STROKES.GRAY },\n      altUp: { fill: SHEETS_LIGHT_FILLS.BLUE, stroke: SHEETS_LIGHT_STROKES.BLUE },\n      altDown: { fill: SHEETS_LIGHT_FILLS.ORANGE, stroke: SHEETS_LIGHT_STROKES.ORANGE },\n      altNeutral: { fill: SHEETS_LIGHT_FILLS.GRAY, stroke: SHEETS_LIGHT_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOR_RANGE, [\n      SHEETS_LIGHT_FILLS.ORANGE,\n      SHEETS_LIGHT_FILLS.YELLOW,\n      SHEETS_LIGHT_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_GAUGE_SERIES_COLOR_RANGE, [\n      SHEETS_LIGHT_FILLS.GREEN,\n      SHEETS_LIGHT_FILLS.YELLOW,\n      SHEETS_LIGHT_FILLS.ORANGE\n    ]);\n    params.set(DEFAULT_ANNOTATION_COLOR, SHEETS_LIGHT_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, SHEETS_LIGHT_FILLS.BLUE);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/vividDark.ts\nvar VIVID_DARK_FILLS = {\n  BLUE: \"#0083ff\",\n  ORANGE: \"#ff6600\",\n  GREEN: \"#00af00\",\n  CYAN: \"#00ccff\",\n  YELLOW: \"#f7c700\",\n  VIOLET: \"#ac26ff\",\n  GRAY: \"#a7a7b7\",\n  MAGENTA: \"#e800c5\",\n  BROWN: \"#b54300\",\n  RED: \"#ff0000\"\n};\nvar VIVID_DARK_STROKES = {\n  BLUE: \"#67b7ff\",\n  ORANGE: \"#ffc24d\",\n  GREEN: \"#5cc86f\",\n  CYAN: \"#54ebff\",\n  VIOLET: \"#fff653\",\n  YELLOW: \"#c18aff\",\n  GRAY: \"#aeaeae\",\n  MAGENTA: \"#f078d4\",\n  BROWN: \"#ba8438\",\n  RED: \"#ff726e\"\n};\nvar VividDark = class extends DarkTheme {\n  getDefaultColors() {\n    return {\n      fills: VIVID_DARK_FILLS,\n      strokes: VIVID_DARK_STROKES,\n      up: { fill: VIVID_DARK_FILLS.GREEN, stroke: VIVID_DARK_STROKES.GREEN },\n      down: { fill: VIVID_DARK_FILLS.RED, stroke: VIVID_DARK_STROKES.RED },\n      neutral: { fill: VIVID_DARK_FILLS.GRAY, stroke: VIVID_DARK_STROKES.GRAY },\n      altUp: { fill: VIVID_DARK_FILLS.BLUE, stroke: VIVID_DARK_STROKES.BLUE },\n      altDown: { fill: VIVID_DARK_FILLS.ORANGE, stroke: VIVID_DARK_STROKES.ORANGE },\n      altNeutral: { fill: VIVID_DARK_FILLS.GRAY, stroke: VIVID_DARK_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOR_RANGE, [\n      VIVID_DARK_FILLS.ORANGE,\n      VIVID_DARK_FILLS.YELLOW,\n      VIVID_DARK_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_FUNNEL_SERIES_COLOR_RANGE, [\n      \"#0083ff\",\n      \"#0076e6\",\n      \"#0069cc\",\n      \"#005cb3\",\n      \"#004f99\",\n      \"#004280\",\n      \"#003466\",\n      \"#00274c\"\n    ]);\n    params.set(DEFAULT_GAUGE_SERIES_COLOR_RANGE, [\n      VIVID_DARK_FILLS.GREEN,\n      VIVID_DARK_FILLS.YELLOW,\n      VIVID_DARK_FILLS.RED\n    ]);\n    params.set(DEFAULT_ANNOTATION_COLOR, VIVID_DARK_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, VIVID_DARK_FILLS.BLUE);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/vividLight.ts\nvar VIVID_FILLS = {\n  BLUE: \"#0083ff\",\n  ORANGE: \"#ff6600\",\n  GREEN: \"#00af00\",\n  CYAN: \"#00ccff\",\n  YELLOW: \"#f7c700\",\n  VIOLET: \"#ac26ff\",\n  GRAY: \"#a7a7b7\",\n  MAGENTA: \"#e800c5\",\n  BROWN: \"#b54300\",\n  RED: \"#ff0000\"\n};\nvar VIVID_STROKES = {\n  BLUE: \"#0f68c0\",\n  ORANGE: \"#d47100\",\n  GREEN: \"#007922\",\n  CYAN: \"#009ac2\",\n  VIOLET: \"#bca400\",\n  YELLOW: \"#753cac\",\n  GRAY: \"#646464\",\n  MAGENTA: \"#9b2685\",\n  BROWN: \"#6c3b00\",\n  RED: \"#cb0021\"\n};\nvar VividLight = class extends ChartTheme {\n  getDefaultColors() {\n    return {\n      fills: VIVID_FILLS,\n      strokes: VIVID_STROKES,\n      up: { fill: VIVID_FILLS.GREEN, stroke: VIVID_STROKES.GREEN },\n      down: { fill: VIVID_FILLS.RED, stroke: VIVID_STROKES.RED },\n      neutral: { fill: VIVID_FILLS.GRAY, stroke: VIVID_STROKES.GRAY },\n      altUp: { fill: VIVID_FILLS.BLUE, stroke: VIVID_STROKES.BLUE },\n      altDown: { fill: VIVID_FILLS.ORANGE, stroke: VIVID_STROKES.ORANGE },\n      altNeutral: { fill: VIVID_FILLS.GRAY, stroke: VIVID_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOR_RANGE, [VIVID_FILLS.ORANGE, VIVID_FILLS.YELLOW, VIVID_FILLS.GREEN]);\n    params.set(DEFAULT_FUNNEL_SERIES_COLOR_RANGE, [\n      \"#0083ff\",\n      \"#1a8fff\",\n      \"#339cff\",\n      \"#4da8ff\",\n      \"#66b5ff\",\n      \"#80c1ff\",\n      \"#99cdff\",\n      \"#b3daff\"\n    ]);\n    params.set(DEFAULT_GAUGE_SERIES_COLOR_RANGE, [VIVID_FILLS.GREEN, VIVID_FILLS.YELLOW, VIVID_FILLS.RED]);\n    params.set(DEFAULT_ANNOTATION_COLOR, VIVID_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, VIVID_FILLS.BLUE);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/mapping/themes.ts\nvar lightTheme = () => new ChartTheme();\nvar darkTheme = () => new DarkTheme();\nvar themes = {\n  // darkThemes,\n  \"ag-default-dark\": darkTheme,\n  \"ag-sheets-dark\": () => new SheetsDark(),\n  \"ag-polychroma-dark\": () => new PolychromaDark(),\n  \"ag-vivid-dark\": () => new VividDark(),\n  \"ag-material-dark\": () => new MaterialDark(),\n  \"ag-financial-dark\": () => new FinancialDark(),\n  // lightThemes,\n  null: lightTheme,\n  undefined: lightTheme,\n  \"ag-default\": lightTheme,\n  \"ag-sheets\": () => new SheetsLight(),\n  \"ag-polychroma\": () => new PolychromaLight(),\n  \"ag-vivid\": () => new VividLight(),\n  \"ag-material\": () => new MaterialLight(),\n  \"ag-financial\": () => new FinancialLight()\n};\nfunction getChartTheme(value) {\n  if (value instanceof ChartTheme) {\n    return value;\n  }\n  if (value == null || typeof value === \"string\") {\n    const stockTheme = themes[value];\n    if (stockTheme) {\n      return stockTheme();\n    }\n    Logger.warnOnce(`the theme [${value}] is invalid, using [ag-default] instead.`);\n    return lightTheme();\n  }\n  if (isValid(value, themeOptionsDef, \"theme\")) {\n    const flattenedTheme = reduceThemeOptions(value);\n    const baseTheme = flattenedTheme.baseTheme ? getChartTheme(flattenedTheme.baseTheme) : lightTheme();\n    return new baseTheme.constructor(flattenedTheme);\n  }\n  return lightTheme();\n}\nfunction reduceThemeOptions(options) {\n  let maybeNested = options;\n  let palette;\n  const overrides = [];\n  while (typeof maybeNested === \"object\") {\n    palette ?? (palette = maybeNested.palette);\n    if (maybeNested.overrides) {\n      overrides.push(maybeNested.overrides);\n    }\n    maybeNested = maybeNested.baseTheme;\n  }\n  return {\n    baseTheme: maybeNested,\n    overrides: mergeDefaults(...overrides),\n    palette\n  };\n}\nvar themeOptionsDef = {\n  baseTheme: or(string, object),\n  overrides: object,\n  palette: {\n    fills: arrayOf(string),\n    strokes: arrayOf(string),\n    up: { fill: string, stroke: string },\n    down: { fill: string, stroke: string },\n    neutral: { fill: string, stroke: string }\n  }\n};\n\n// packages/ag-charts-community/src/module/optionsModule.ts\nvar unthemedSeries = /* @__PURE__ */ new Set([\"map-shape-background\", \"map-line-background\"]);\nvar ChartOptions = class {\n  constructor(userOptions, processedOverrides, specialOverrides, metadata) {\n    this.debug = Debug.create(true, \"opts\");\n    var _a;\n    this.optionMetadata = metadata ?? {};\n    this.processedOverrides = processedOverrides ?? {};\n    const cloneOptions = { shallow: [\"data\"] };\n    this.userOptions = deepClone(userOptions, cloneOptions);\n    let options = deepClone(userOptions, cloneOptions);\n    const { presetType } = this.optionMetadata;\n    if (presetType != null) {\n      const presetConstructor = PRESETS[presetType];\n      const presetParams = options;\n      const presetSubType = options.type;\n      const presetTheme = presetSubType != null ? getChartTheme(options.theme).presets[presetSubType] : void 0;\n      this.debug(\">>> AgCharts.createOrUpdate() - applying preset\", presetParams);\n      options = presetConstructor?.(presetParams, presetTheme, () => this.activeTheme) ?? options;\n    }\n    if (!enterpriseModule.isEnterprise) {\n      removeUsedEnterpriseOptions(options);\n    }\n    this.activeTheme = getChartTheme(options.theme);\n    if (presetType) {\n      options = this.activeTheme.templateTheme(options);\n    }\n    this.sanityCheckAndCleanup(options);\n    this.defaultAxes = this.getDefaultAxes(options);\n    this.specialOverrides = this.specialOverridesDefaults({ ...specialOverrides });\n    const chartType2 = this.optionsType(options);\n    const {\n      axes: axesThemes = {},\n      annotations: { axesButtons = null, ...annotationsThemes } = {},\n      series: _,\n      ...themeDefaults\n    } = this.getSeriesThemeConfig(chartType2);\n    this.processedOptions = deepClone(\n      mergeDefaults(\n        processedOverrides,\n        options,\n        axesButtons != null ? { annotations: { axesButtons } } : {},\n        themeDefaults,\n        this.defaultAxes\n      ),\n      cloneOptions\n    );\n    this.processAxesOptions(this.processedOptions, axesThemes);\n    this.processSeriesOptions(this.processedOptions);\n    this.processMiniChartSeriesOptions(this.processedOptions);\n    this.annotationThemes = annotationsThemes;\n    if ((isAgCartesianChartOptions(this.processedOptions) || isAgPolarChartOptionsWithSeriesBasedLegend(this.processedOptions)) && this.processedOptions.legend?.enabled == null) {\n      (_a = this.processedOptions).legend ?? (_a.legend = {});\n      this.processedOptions.legend.enabled = this.processedOptions.series.length > 1;\n    }\n    this.enableConfiguredOptions(this.processedOptions, options);\n    if (!enterpriseModule.isEnterprise) {\n      removeUsedEnterpriseOptions(this.processedOptions, true);\n    }\n  }\n  getOptions() {\n    return this.processedOptions ?? {};\n  }\n  diffOptions(options) {\n    return jsonDiff(options, this.processedOptions);\n  }\n  getSeriesThemeConfig(seriesType2) {\n    const themeConfig = deepClone(this.activeTheme?.config[seriesType2] ?? {});\n    this.removeLeftoverSymbols(themeConfig);\n    return themeConfig;\n  }\n  getDefaultAxes(options) {\n    const optionsType2 = this.optionsType(options);\n    const firstSeriesOptions = options.series?.find((series) => (series.type ?? \"line\") === optionsType2) ?? {};\n    return seriesRegistry.cloneDefaultAxes(optionsType2, firstSeriesOptions);\n  }\n  optionsType(options) {\n    return options.series?.[0]?.type ?? \"line\";\n  }\n  sanityCheckAndCleanup(options) {\n    this.deprecationWarnings(options);\n    this.axesTypeIntegrity(options);\n    this.seriesTypeIntegrity(options);\n    this.soloSeriesIntegrity(options);\n    this.removeDisabledOptions(options);\n    this.removeLeftoverSymbols(options);\n    if (options.series?.some((s) => s.type === \"bullet\") && options.sync != null && options.sync.enabled !== false) {\n      Logger.warnOnce(\"bullet series cannot be synced, disabling synchronization.\");\n      delete options.sync;\n    }\n  }\n  processAxesOptions(options, axesThemes) {\n    if (!(\"axes\" in options))\n      return;\n    options.axes = options.axes.map((axis) => {\n      const { crossLines: crossLinesTheme, ...axisTheme } = mergeDefaults(\n        axesThemes[axis.type]?.[axis.position],\n        axesThemes[axis.type]\n      );\n      if (axis.crossLines) {\n        axis.crossLines = mergeArrayDefaults(axis.crossLines, crossLinesTheme);\n      }\n      const gridLineStyle = axisTheme.gridLine?.style;\n      if (axis.gridLine?.style && gridLineStyle?.length) {\n        axis.gridLine.style = axis.gridLine.style.map(\n          (style, index) => style.stroke != null || style.lineDash != null ? mergeDefaults(style, gridLineStyle.at(index % gridLineStyle.length)) : style\n        );\n      }\n      const { top: _1, right: _2, bottom: _3, left: _4, ...axisOptions } = mergeDefaults(axis, axisTheme);\n      return axisOptions;\n    });\n  }\n  processSeriesOptions(options) {\n    const defaultTooltipPosition = this.getTooltipPositionDefaults(options);\n    const userPalette = isObject(options.theme) ? paletteType(options.theme?.palette) : \"inbuilt\";\n    const paletteOptions = {\n      colourIndex: 0,\n      userPalette\n    };\n    const processedSeries = options.series?.map((series) => {\n      series.type ?? (series.type = this.getDefaultSeriesType(options));\n      const { innerLabels: innerLabelsTheme, ...seriesTheme } = this.getSeriesThemeConfig(series.type).series ?? {};\n      const seriesPaletteOptions = unthemedSeries.has(series.type) ? { colourIndex: 0, userPalette } : paletteOptions;\n      const palette = this.getSeriesPalette(series.type, seriesPaletteOptions);\n      const defaultTooltipRange = this.getTooltipRangeDefaults(options, series.type);\n      const seriesOptions = mergeDefaults(\n        this.getSeriesGroupingOptions(series),\n        series,\n        defaultTooltipPosition,\n        defaultTooltipRange,\n        seriesTheme,\n        palette,\n        { visible: true }\n      );\n      if (seriesOptions.innerLabels) {\n        seriesOptions.innerLabels = mergeArrayDefaults(seriesOptions.innerLabels, innerLabelsTheme);\n      }\n      return this.activeTheme.templateTheme(seriesOptions);\n    });\n    options.series = this.setSeriesGroupingOptions(processedSeries ?? []);\n  }\n  processMiniChartSeriesOptions(options) {\n    let miniChartSeries = options.navigator?.miniChart?.series;\n    if (miniChartSeries == null)\n      return;\n    const paletteOptions = {\n      colourIndex: 0,\n      userPalette: isObject(options.theme) ? paletteType(options.theme.palette) : \"inbuilt\"\n    };\n    miniChartSeries = miniChartSeries.map((series) => {\n      series.type ?? (series.type = \"line\");\n      const { innerLabels: _, ...seriesTheme } = this.getSeriesThemeConfig(series.type).series ?? {};\n      const seriesOptions = mergeDefaults(\n        this.getSeriesGroupingOptions(series),\n        series,\n        seriesTheme,\n        this.getSeriesPalette(series.type, paletteOptions)\n      );\n      return this.activeTheme.templateTheme(seriesOptions);\n    });\n    options.navigator.miniChart.series = this.setSeriesGroupingOptions(miniChartSeries);\n  }\n  getSeriesPalette(seriesType2, options) {\n    const paletteFactory = seriesRegistry.getPaletteFactory(seriesType2);\n    const { colourIndex: colourOffset, userPalette } = options;\n    const { fills = [], strokes = [] } = this.activeTheme.palette;\n    return paletteFactory?.({\n      userPalette,\n      colorsCount: Math.max(fills.length, strokes.length),\n      themeTemplateParameters: this.activeTheme.getTemplateParameters(),\n      palette: this.activeTheme.palette,\n      takeColors(count) {\n        options.colourIndex += count;\n        return {\n          fills: circularSliceArray(fills, count, colourOffset),\n          strokes: circularSliceArray(strokes, count, colourOffset)\n        };\n      }\n    });\n  }\n  getSeriesGroupingOptions(series) {\n    const groupable = seriesRegistry.isGroupable(series.type);\n    const stackable = seriesRegistry.isStackable(series.type);\n    const stackedByDefault = seriesRegistry.isStackedByDefault(series.type);\n    if (series.grouped && !groupable) {\n      Logger.warnOnce(`unsupported grouping of series type \"${series.type}\".`);\n    }\n    if ((series.stacked || series.stackGroup) && !stackable) {\n      Logger.warnOnce(`unsupported stacking of series type \"${series.type}\".`);\n    }\n    let { grouped, stacked } = series;\n    stacked ?? (stacked = (stackedByDefault || series.stackGroup != null) && !(groupable && grouped));\n    grouped ?? (grouped = true);\n    return {\n      stacked: stackable && stacked,\n      grouped: groupable && grouped && !(stackable && stacked)\n    };\n  }\n  setSeriesGroupingOptions(allSeries) {\n    const seriesGroups = this.getSeriesGrouping(allSeries);\n    this.debug(\"setSeriesGroupingOptions() - series grouping: \", seriesGroups);\n    const groupIdx = {};\n    const groupCount2 = seriesGroups.reduce((countMap, seriesGroup) => {\n      var _a;\n      if (seriesGroup.groupType === \"default\" /* DEFAULT */) {\n        return countMap;\n      }\n      countMap[_a = seriesGroup.seriesType] ?? (countMap[_a] = 0);\n      countMap[seriesGroup.seriesType] += seriesGroup.groupType === \"stack\" /* STACK */ ? 1 : seriesGroup.series.length;\n      return countMap;\n    }, {});\n    return seriesGroups.flatMap((seriesGroup) => {\n      var _a;\n      groupIdx[_a = seriesGroup.seriesType] ?? (groupIdx[_a] = 0);\n      switch (seriesGroup.groupType) {\n        case \"stack\" /* STACK */: {\n          const groupIndex = groupIdx[seriesGroup.seriesType]++;\n          return seriesGroup.series.map(\n            (series, stackIndex) => Object.assign(series, {\n              seriesGrouping: {\n                groupId: seriesGroup.groupId,\n                groupIndex,\n                groupCount: groupCount2[seriesGroup.seriesType],\n                stackIndex,\n                stackCount: seriesGroup.series.length\n              }\n            })\n          );\n        }\n        case \"group\" /* GROUP */:\n          return seriesGroup.series.map(\n            (series) => Object.assign(series, {\n              seriesGrouping: {\n                groupId: seriesGroup.groupId,\n                groupIndex: groupIdx[seriesGroup.seriesType]++,\n                groupCount: groupCount2[seriesGroup.seriesType],\n                stackIndex: 0,\n                stackCount: 0\n              }\n            })\n          );\n      }\n      return seriesGroup.series;\n    }).map(({ stacked: _, grouped: __, ...seriesOptions }) => seriesOptions);\n  }\n  getSeriesGroupId(series) {\n    return [series.type, series.xKey, series.stacked ? series.stackGroup ?? \"stacked\" : \"grouped\"].filter(Boolean).join(\"-\");\n  }\n  getSeriesGrouping(allSeries) {\n    const groupMap = /* @__PURE__ */ new Map();\n    return allSeries.reduce((result, series) => {\n      const seriesType2 = series.type;\n      if (!series.stacked && !series.grouped) {\n        result.push({ groupType: \"default\" /* DEFAULT */, seriesType: seriesType2, series: [series], groupId: \"__default__\" });\n      } else {\n        const groupId = this.getSeriesGroupId(series);\n        if (!groupMap.has(groupId)) {\n          const groupType = series.stacked ? \"stack\" /* STACK */ : \"group\" /* GROUP */;\n          const record = { groupType, seriesType: seriesType2, series: [], groupId };\n          groupMap.set(groupId, record);\n          result.push(record);\n        }\n        groupMap.get(groupId).series.push(series);\n      }\n      return result;\n    }, []);\n  }\n  getDefaultSeriesType(options) {\n    if (isAgCartesianChartOptions(options)) {\n      return \"line\";\n    } else if (isAgPolarChartOptions(options)) {\n      return \"pie\";\n    } else if (isAgHierarchyChartOptions(options)) {\n      return \"treemap\";\n    } else if (isAgTopologyChartOptions(options)) {\n      return \"map-shape\";\n    } else if (isAgFlowProportionChartOptions(options)) {\n      return \"sankey\";\n    } else if (isAgStandaloneChartOptions(options)) {\n      return \"pyramid\";\n    } else if (isAgGaugeChartOptions(options)) {\n      return \"radial-gauge\";\n    }\n    throw new Error(\"Invalid chart options type detected.\");\n  }\n  getTooltipPositionDefaults(options) {\n    const position = options.tooltip?.position;\n    if (!isPlainObject(position)) {\n      return;\n    }\n    const { type, xOffset, yOffset } = position;\n    const result = {};\n    if (isString(type) && isEnumValue(AgTooltipPositionType, type)) {\n      result.type = type;\n    }\n    if (isFiniteNumber(xOffset)) {\n      result.xOffset = xOffset;\n    }\n    if (isFiniteNumber(yOffset)) {\n      result.yOffset = yOffset;\n    }\n    return { tooltip: { position: result } };\n  }\n  // AG-11591 Support for new series-specific & legacy chart-global 'tooltip.range' options\n  //\n  // The `chart.series[].tooltip.range` option is a bit different for legacy reason. This use to be\n  // global option (`chart.tooltip.range`) that could override the theme. But now, the tooltip range\n  // option is series-specific.\n  //\n  // To preserve backward compatiblity, the `chart.tooltip.range` theme default has been changed from\n  // 'nearest' to undefined.\n  getTooltipRangeDefaults(options, seriesType2) {\n    return {\n      tooltip: {\n        range: options.tooltip?.range ?? seriesRegistry.getTooltipDefauls(seriesType2)?.range\n      }\n    };\n  }\n  deprecationWarnings(options) {\n    const deprecatedArrayProps = { yKeys: \"yKey\", yNames: \"yName\" };\n    Object.entries(deprecatedArrayProps).forEach(([oldProp, newProp]) => {\n      if (options.series?.some((s) => s[oldProp] != null)) {\n        Logger.warnOnce(\n          `Property [series.${oldProp}] is deprecated, please use [series.${newProp}] and multiple series instead.`\n        );\n      }\n    });\n  }\n  axesTypeIntegrity(options) {\n    if (\"axes\" in options) {\n      const axes = options.axes ?? [];\n      for (const { type } of axes) {\n        if (!isAxisOptionType(type)) {\n          delete options.axes;\n          const expectedTypes = axisRegistry.publicKeys().join(\", \");\n          Logger.warnOnce(`unknown axis type: ${type}; expected one of: ${expectedTypes}`);\n        }\n      }\n    }\n  }\n  seriesTypeIntegrity(options) {\n    options.series = options.series?.filter(({ type }) => {\n      if (type == null || isSeriesOptionType(type) || isEnterpriseSeriesType(type)) {\n        return true;\n      }\n      Logger.warnOnce(\n        `unknown series type: ${type}; expected one of: ${publicChartTypes.seriesTypes.join(\", \")}`\n      );\n    });\n  }\n  soloSeriesIntegrity(options) {\n    const allSeries = options.series;\n    if (allSeries && allSeries.length > 1 && allSeries.some((series) => seriesRegistry.isSolo(series.type))) {\n      const mainSeriesType = this.optionsType(options);\n      if (seriesRegistry.isSolo(mainSeriesType)) {\n        Logger.warn(\n          `series[0] of type '${mainSeriesType}' is incompatible with other series types. Only processing series[0]`\n        );\n        options.series = allSeries.slice(0, 1);\n      } else {\n        const { solo, nonSolo } = groupBy(\n          allSeries,\n          (s) => seriesRegistry.isSolo(s.type) ? \"solo\" : \"nonSolo\"\n        );\n        const rejects = unique(solo.map((s) => s.type)).join(\", \");\n        Logger.warn(`Unable to mix these series types with the lead series type: ${rejects}`);\n        options.series = nonSolo;\n      }\n    }\n  }\n  enableConfiguredOptions(options, userOptions) {\n    jsonWalk(\n      userOptions,\n      (visitingUserOpts, visitingMergedOpts) => {\n        if (visitingMergedOpts && \"enabled\" in visitingMergedOpts && !visitingMergedOpts._enabledFromTheme && visitingUserOpts.enabled == null) {\n          visitingMergedOpts.enabled = true;\n        }\n      },\n      { skip: [\"data\", \"theme\"] },\n      options\n    );\n    jsonWalk(\n      options,\n      (visitingMergedOpts) => {\n        if (visitingMergedOpts._enabledFromTheme != null) {\n          delete visitingMergedOpts._enabledFromTheme;\n        }\n      },\n      { skip: [\"data\", \"theme\"] }\n    );\n  }\n  removeDisabledOptions(options) {\n    jsonWalk(\n      options,\n      (optionsNode) => {\n        if (\"enabled\" in optionsNode && optionsNode.enabled === false) {\n          Object.keys(optionsNode).forEach((key) => {\n            if (key === \"enabled\")\n              return;\n            delete optionsNode[key];\n          });\n        }\n      },\n      { skip: [\"data\", \"theme\"] }\n    );\n  }\n  removeLeftoverSymbols(options) {\n    jsonWalk(\n      options,\n      (optionsNode) => {\n        if (!optionsNode || !isObject(optionsNode))\n          return;\n        for (const [key, value] of Object.entries(optionsNode)) {\n          if (isSymbol(value)) {\n            delete optionsNode[key];\n          }\n        }\n      },\n      { skip: [\"data\"] }\n    );\n  }\n  specialOverridesDefaults(options) {\n    if (options.window != null) {\n      setWindow(options.window);\n    } else if (typeof window !== \"undefined\") {\n      options.window = window;\n    } else if (typeof global !== \"undefined\") {\n      options.window = global.window;\n    }\n    if (options.document != null) {\n      setDocument(options.document);\n    } else if (typeof document !== \"undefined\") {\n      options.document = document;\n    } else if (typeof global !== \"undefined\") {\n      options.document = global.document;\n    }\n    if (options.window == null) {\n      throw new Error(\"AG Charts - unable to resolve global window\");\n    }\n    if (options.document == null) {\n      throw new Error(\"AG Charts - unable to resolve global document\");\n    }\n    return options;\n  }\n};\n\n// packages/ag-charts-community/src/api/agCharts.ts\nvar debug2 = Debug.create(true, \"opts\");\nfunction chartType(options) {\n  if (isAgCartesianChartOptions(options)) {\n    return \"cartesian\";\n  } else if (isAgPolarChartOptions(options)) {\n    return \"polar\";\n  } else if (isAgHierarchyChartOptions(options)) {\n    return \"hierarchy\";\n  } else if (isAgTopologyChartOptions(options)) {\n    return \"topology\";\n  } else if (isAgFlowProportionChartOptions(options)) {\n    return \"flow-proportion\";\n  } else if (isAgStandaloneChartOptions(options)) {\n    return \"standalone\";\n  } else if (isAgGaugeChartOptions(options)) {\n    return \"gauge\";\n  }\n  throw new Error(`AG Chart - unknown type of chart for options with type: ${options.type}`);\n}\nvar AgCharts = class {\n  static licenseCheck(options) {\n    if (this.licenseChecked)\n      return;\n    this.licenseManager = enterpriseModule.licenseManager?.(options);\n    this.licenseManager?.setLicenseKey(this.licenseKey, this.gridContext);\n    this.licenseManager?.validateLicense();\n    this.licenseChecked = true;\n  }\n  static setLicenseKey(licenseKey) {\n    this.licenseKey = licenseKey;\n  }\n  static setGridContext(gridContext) {\n    this.gridContext = gridContext;\n  }\n  static getLicenseDetails(licenseKey) {\n    return enterpriseModule.licenseManager?.({}).getLicenseDetails(licenseKey);\n  }\n  /**\n   * Returns the `AgChartInstance` for a DOM node, if there is one.\n   */\n  static getInstance(element2) {\n    return AgChartsInternal.getInstance(element2);\n  }\n  /**\n   * Create a new `AgChartInstance` based upon the given configuration options.\n   */\n  static create(userOptions, optionsMetadata) {\n    this.licenseCheck(userOptions);\n    const chart = AgChartsInternal.createOrUpdate({\n      userOptions,\n      licenseManager: this.licenseManager,\n      styles: enterpriseModule.styles != null ? [[\"ag-charts-enterprise\", enterpriseModule.styles]] : [],\n      optionsMetadata\n    });\n    if (this.licenseManager?.isDisplayWatermark() && this.licenseManager) {\n      enterpriseModule.injectWatermark?.(chart.chart.ctx.domManager, this.licenseManager.getWatermarkMessage());\n    }\n    return chart;\n  }\n  static createFinancialChart(options) {\n    return this.create(options, { presetType: \"price-volume\" });\n  }\n  static createGauge(options) {\n    return this.create(options, { presetType: \"gauge\" });\n  }\n  static __createSparkline(options) {\n    return this.create(options, { presetType: \"sparkline\" });\n  }\n};\nAgCharts.licenseChecked = false;\nAgCharts.gridContext = false;\nvar _AgChartsInternal = class _AgChartsInternal {\n  static getInstance(element2) {\n    const chart = Chart.getInstance(element2);\n    return chart ? AgChartInstanceProxy.chartInstances.get(chart) : void 0;\n  }\n  static initialiseModules() {\n    if (_AgChartsInternal.initialised)\n      return;\n    registerInbuiltModules();\n    setupModules();\n    _AgChartsInternal.initialised = true;\n  }\n  static createOrUpdate(opts) {\n    let { proxy } = opts;\n    const {\n      userOptions,\n      licenseManager,\n      styles,\n      processedOverrides = proxy?.chart.chartOptions.processedOverrides ?? {},\n      specialOverrides = proxy?.chart.chartOptions.specialOverrides ?? {},\n      optionsMetadata = proxy?.chart.chartOptions.optionMetadata ?? {}\n    } = opts;\n    const { presetType } = optionsMetadata;\n    _AgChartsInternal.initialiseModules();\n    debug2(\">>> AgCharts.createOrUpdate() user options\", userOptions);\n    let mutableOptions = userOptions;\n    if (AgCharts.optionsMutationFn) {\n      mutableOptions = AgCharts.optionsMutationFn(mutableOptions, presetType);\n      debug2(\">>> AgCharts.createOrUpdate() MUTATED user options\", mutableOptions);\n    }\n    const { overrideDevicePixelRatio, document: document2, window: userWindow, styleContainer, ...options } = mutableOptions;\n    const chartOptions = new ChartOptions(\n      options,\n      processedOverrides,\n      {\n        ...specialOverrides,\n        document: document2,\n        window: userWindow,\n        overrideDevicePixelRatio,\n        styleContainer\n      },\n      optionsMetadata\n    );\n    let chart = proxy?.chart;\n    if (chart == null || chartType(chartOptions.processedOptions) !== chartType(chart?.chartOptions.processedOptions)) {\n      chart = _AgChartsInternal.createChartInstance(chartOptions, chart);\n      styles?.forEach(([id, css]) => {\n        chart?.ctx.domManager.addStyles(id, css);\n      });\n    }\n    if (proxy == null) {\n      proxy = new AgChartInstanceProxy(chart, _AgChartsInternal.callbackApi, licenseManager);\n    } else {\n      proxy.chart = chart;\n    }\n    if (debug2.check() && typeof window !== \"undefined\") {\n      window.agChartInstances ?? (window.agChartInstances = {});\n      window.agChartInstances[chart.id] = chart;\n    }\n    chart.queuedUserOptions.push(userOptions);\n    chart.requestFactoryUpdate((chartRef) => {\n      chartRef.applyOptions(chartOptions);\n      const queueIdx = chartRef.queuedUserOptions.indexOf(userOptions) + 1;\n      chartRef.queuedUserOptions.splice(0, queueIdx);\n    });\n    return proxy;\n  }\n  static updateUserDelta(proxy, deltaOptions) {\n    deltaOptions = deepClone(deltaOptions, { shallow: [\"data\"] });\n    jsonWalk(\n      deltaOptions,\n      (node) => {\n        if (typeof node !== \"object\")\n          return;\n        for (const [key, value] of Object.entries(node)) {\n          if (typeof value === \"undefined\") {\n            Object.assign(node, { [key]: Symbol(\"UNSET\") });\n          }\n        }\n      },\n      { skip: [\"data\"] }\n    );\n    const { chart } = proxy;\n    const lastUpdateOptions = chart.getOptions();\n    const userOptions = mergeDefaults(deltaOptions, lastUpdateOptions);\n    debug2(\">>> AgCharts.updateUserDelta() user delta\", deltaOptions);\n    debug2(\"AgCharts.updateUserDelta() - base options\", lastUpdateOptions);\n    _AgChartsInternal.createOrUpdate({ userOptions, proxy });\n  }\n  static createChartInstance(options, oldChart) {\n    const transferableResource = oldChart?.destroy({ keepTransferableResources: true });\n    const ChartConstructor = _AgChartsInternal.getChartByOptions(options.processedOptions);\n    return new ChartConstructor(options, transferableResource);\n  }\n  static getChartByOptions(options) {\n    if (isAgCartesianChartOptions(options)) {\n      return CartesianChart;\n    } else if (isAgHierarchyChartOptions(options)) {\n      return HierarchyChart;\n    } else if (isAgPolarChartOptions(options)) {\n      return PolarChart;\n    } else if (isAgTopologyChartOptions(options)) {\n      return TopologyChart;\n    } else if (isAgFlowProportionChartOptions(options)) {\n      return FlowProportionChart;\n    } else if (isAgStandaloneChartOptions(options)) {\n      return StandaloneChart;\n    } else if (isAgGaugeChartOptions(options)) {\n      return GaugeChart;\n    }\n    throw new Error(\n      `AG Charts - couldn't apply configuration, check options are correctly structured and series types are specified`\n    );\n  }\n};\n_AgChartsInternal.caretaker = new MementoCaretaker(VERSION);\n_AgChartsInternal.initialised = false;\n_AgChartsInternal.callbackApi = {\n  caretaker: _AgChartsInternal.caretaker,\n  create(userOptions, processedOverrides, specialOverrides, optionsMetadata) {\n    return _AgChartsInternal.createOrUpdate({\n      userOptions,\n      processedOverrides,\n      specialOverrides,\n      optionsMetadata\n    });\n  },\n  update(opts, chart) {\n    return _AgChartsInternal.createOrUpdate({ userOptions: opts, proxy: chart });\n  },\n  updateUserDelta(chart, deltaOptions) {\n    return _AgChartsInternal.updateUserDelta(chart, deltaOptions);\n  }\n};\nvar AgChartsInternal = _AgChartsInternal;\n\n// packages/ag-charts-community/src/main-modules.ts\nfunction setupCommunityModules() {\n  registerInbuiltModules();\n  return { AgCharts, version: VERSION };\n}\n\n// packages/ag-charts-community/src/integrated-charts-scene.ts\nvar integrated_charts_scene_exports = {};\n__export(integrated_charts_scene_exports, {\n  Arc: () => Arc2,\n  ArrowDown: () => ArrowDown,\n  ArrowUp: () => ArrowUp,\n  BBox: () => BBox,\n  BandScale: () => BandScale,\n  Caption: () => Caption,\n  ChangeDetectableProperties: () => ChangeDetectableProperties,\n  Circle: () => Circle,\n  ConicGradient: () => ConicGradient,\n  ContinuousScale: () => ContinuousScale,\n  Diamond: () => Diamond,\n  DropShadow: () => DropShadow,\n  ExtendedPath2D: () => ExtendedPath2D,\n  Gradient: () => Gradient,\n  Group: () => Group,\n  HdpiCanvas: () => HdpiCanvas,\n  Image: () => Image,\n  Label: () => Label,\n  Layer: () => Layer,\n  Line: () => Line,\n  LinearGradient: () => LinearGradient,\n  LinearScale: () => LinearScale,\n  Marker: () => Marker,\n  Node: () => Node,\n  OrdinalTimeScale: () => OrdinalTimeScale,\n  Path: () => Path,\n  PointerEvents: () => PointerEvents,\n  RadialColumnShape: () => RadialColumnShape,\n  Rect: () => Rect,\n  RedrawType: () => RedrawType,\n  Rotatable: () => Rotatable,\n  RotatableGroup: () => RotatableGroup,\n  RotatableText: () => RotatableText,\n  Scalable: () => Scalable,\n  ScalableGroup: () => ScalableGroup,\n  Scene: () => Scene,\n  SceneChangeDetection: () => SceneChangeDetection,\n  ScenePathChangeDetection: () => ScenePathChangeDetection,\n  Sector: () => Sector,\n  SectorBox: () => SectorBox,\n  Selection: () => Selection,\n  Shape: () => Shape,\n  Square: () => Square,\n  SvgPath: () => SvgPath,\n  Text: () => Text,\n  Tooltip: () => Tooltip,\n  Transformable: () => Transformable,\n  TransformableText: () => TransformableText,\n  Translatable: () => Translatable,\n  TranslatableGroup: () => TranslatableGroup,\n  TranslatableLayer: () => TranslatableLayer,\n  Triangle: () => Triangle,\n  calculateDerivativeExtrema: () => calculateDerivativeExtrema,\n  calculateDerivativeExtremaXY: () => calculateDerivativeExtremaXY,\n  drawCorner: () => drawCorner,\n  easing: () => easing_exports,\n  evaluateBezier: () => evaluateBezier,\n  getFont: () => getFont,\n  getMarker: () => getMarker,\n  getRadialColumnWidth: () => getRadialColumnWidth,\n  motion: () => motion,\n  sectorBox: () => sectorBox,\n  solveBezier: () => solveBezier,\n  splitBezier: () => splitBezier,\n  toRadians: () => toRadians,\n  toTooltipHtml: () => toTooltipHtml\n});\n\n// packages/ag-charts-community/src/scene/shape/arc.ts\nvar Arc2 = class extends Path {\n  constructor() {\n    super();\n    this.centerX = 0;\n    this.centerY = 0;\n    this.radius = 10;\n    this.startAngle = 0;\n    this.endAngle = Math.PI * 2;\n    this.counterClockwise = false;\n    this.type = 0 /* Open */;\n    this.restoreOwnStyles();\n  }\n  get fullPie() {\n    return isEqual(normalizeAngle360(this.startAngle), normalizeAngle360(this.endAngle));\n  }\n  updatePath() {\n    const path = this.path;\n    path.clear();\n    path.arc(this.centerX, this.centerY, this.radius, this.startAngle, this.endAngle, this.counterClockwise);\n    if (this.type === 1 /* Chord */) {\n      path.closePath();\n    } else if (this.type === 2 /* Round */ && !this.fullPie) {\n      path.lineTo(this.centerX, this.centerY);\n      path.closePath();\n    }\n  }\n  computeBBox() {\n    return new BBox(this.centerX - this.radius, this.centerY - this.radius, this.radius * 2, this.radius * 2);\n  }\n  isPointInPath(x, y) {\n    const bbox = this.getBBox();\n    return this.type !== 0 /* Open */ && bbox.containsPoint(x, y) && this.path.isPointInPath(x, y);\n  }\n};\nArc2.className = \"Arc\";\nArc2.defaultStyles = { ...Shape.defaultStyles, lineWidth: 1, fillStyle: null };\n__decorateClass([\n  ScenePathChangeDetection()\n], Arc2.prototype, \"centerX\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Arc2.prototype, \"centerY\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Arc2.prototype, \"radius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Arc2.prototype, \"startAngle\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Arc2.prototype, \"endAngle\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Arc2.prototype, \"counterClockwise\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Arc2.prototype, \"type\", 2);\n\n// packages/ag-charts-community/src/scene/gradient/conicGradient.ts\nvar ConicGradient = class extends Gradient {\n  constructor(colorSpace, stops, angle2 = 0, bbox) {\n    super(colorSpace, stops, bbox);\n    this.angle = angle2;\n  }\n  createCanvasGradient(ctx, bbox) {\n    const angleOffset = 90;\n    const { colorSpace, stops, angle: angle2 } = this;\n    const radians = normalizeAngle360(toRadians(angle2 + angleOffset));\n    if (!(\"createConicGradient\" in ctx)) {\n      const linearGradient = new LinearGradient(colorSpace, stops, angle2);\n      return linearGradient.createCanvasGradient(ctx, bbox);\n    }\n    const cx = bbox.x + bbox.width * 0.5;\n    const cy = bbox.y + bbox.height * 0.5;\n    return ctx.createConicGradient(radians, cx, cy);\n  }\n};\n\n// packages/ag-charts-community/src/scene/shape/radialColumnShape.ts\nfunction rotatePoint(x, y, rotation) {\n  const radius = Math.sqrt(x ** 2 + y ** 2);\n  const angle2 = Math.atan2(y, x);\n  const rotated = angle2 + rotation;\n  return {\n    x: Math.cos(rotated) * radius,\n    y: Math.sin(rotated) * radius\n  };\n}\nvar RadialColumnShape = class extends Path {\n  constructor() {\n    super(...arguments);\n    this.isBeveled = true;\n    this.columnWidth = 0;\n    this.startAngle = 0;\n    this.endAngle = 0;\n    this.outerRadius = 0;\n    this.innerRadius = 0;\n    this.axisInnerRadius = 0;\n    this.axisOuterRadius = 0;\n    this.isRadiusAxisReversed = false;\n  }\n  set cornerRadius(_value) {\n  }\n  computeBBox() {\n    const { innerRadius, outerRadius, columnWidth } = this;\n    const rotation = this.getRotation();\n    const left = -columnWidth / 2;\n    const right = columnWidth / 2;\n    const top = -outerRadius;\n    const bottom = -innerRadius;\n    let x0 = Infinity;\n    let y0 = Infinity;\n    let x1 = -Infinity;\n    let y1 = -Infinity;\n    for (let i = 0; i < 4; i += 1) {\n      const { x, y } = rotatePoint(i % 2 === 0 ? left : right, i < 2 ? top : bottom, rotation);\n      x0 = Math.min(x, x0);\n      y0 = Math.min(y, y0);\n      x1 = Math.max(x, x1);\n      y1 = Math.max(y, y1);\n    }\n    return new BBox(x0, y0, x1 - x0, y1 - y0);\n  }\n  getRotation() {\n    const { startAngle, endAngle } = this;\n    const midAngle = angleBetween(startAngle, endAngle);\n    return normalizeAngle360(startAngle + midAngle / 2 + Math.PI / 2);\n  }\n  updatePath() {\n    const { isBeveled } = this;\n    if (isBeveled) {\n      this.updateBeveledPath();\n    } else {\n      this.updateRectangularPath();\n    }\n    this.checkPathDirty();\n  }\n  updateRectangularPath() {\n    const { columnWidth, innerRadius, outerRadius, path } = this;\n    const left = -columnWidth / 2;\n    const right = columnWidth / 2;\n    const top = -outerRadius;\n    const bottom = -innerRadius;\n    const rotation = this.getRotation();\n    const points = [\n      [left, bottom],\n      [left, top],\n      [right, top],\n      [right, bottom]\n    ].map(([x, y]) => rotatePoint(x, y, rotation));\n    path.clear(true);\n    path.moveTo(points[0].x, points[0].y);\n    path.lineTo(points[1].x, points[1].y);\n    path.lineTo(points[2].x, points[2].y);\n    path.lineTo(points[3].x, points[3].y);\n    path.closePath();\n  }\n  updateBeveledPath() {\n    const { columnWidth, path, outerRadius, innerRadius, axisInnerRadius, axisOuterRadius, isRadiusAxisReversed } = this;\n    const isStackBottom = isEqual(innerRadius, axisInnerRadius);\n    const sideRotation = Math.asin(columnWidth / 2 / innerRadius);\n    const pointRotation = this.getRotation();\n    const rotate2 = (x, y) => rotatePoint(x, y, pointRotation);\n    const getTriangleHypotenuse = (leg, otherLeg) => Math.sqrt(leg ** 2 + otherLeg ** 2);\n    const getTriangleLeg = (hypotenuse, otherLeg) => {\n      if (otherLeg > hypotenuse) {\n        return 0;\n      }\n      return Math.sqrt(hypotenuse ** 2 - otherLeg ** 2);\n    };\n    const compare = (value, otherValue, lessThan) => lessThan ? value < otherValue : value > otherValue;\n    const shouldConnectBottomCircle = isStackBottom && !isNaN(sideRotation) && sideRotation < Math.PI / 6;\n    let left = -columnWidth / 2;\n    let right = columnWidth / 2;\n    const top = -outerRadius;\n    const bottom = -innerRadius * (shouldConnectBottomCircle ? Math.cos(sideRotation) : 1);\n    const hasBottomIntersection = compare(\n      axisOuterRadius,\n      getTriangleHypotenuse(innerRadius, columnWidth / 2),\n      !isRadiusAxisReversed\n    );\n    if (hasBottomIntersection) {\n      const bottomIntersectionX = getTriangleLeg(axisOuterRadius, innerRadius);\n      left = -bottomIntersectionX;\n      right = bottomIntersectionX;\n    }\n    path.clear(true);\n    const bottomLeftPt = rotate2(left, bottom);\n    path.moveTo(bottomLeftPt.x, bottomLeftPt.y);\n    const isEmpty = isEqual(innerRadius, outerRadius);\n    const hasSideIntersection = compare(\n      axisOuterRadius,\n      getTriangleHypotenuse(outerRadius, columnWidth / 2),\n      !isRadiusAxisReversed\n    );\n    if (isEmpty && shouldConnectBottomCircle) {\n      path.arc(\n        0,\n        0,\n        innerRadius,\n        normalizeAngle360(-sideRotation - Math.PI / 2) + pointRotation,\n        normalizeAngle360(sideRotation - Math.PI / 2) + pointRotation,\n        false\n      );\n    } else if (hasSideIntersection) {\n      const sideIntersectionY = -getTriangleLeg(axisOuterRadius, columnWidth / 2);\n      const topIntersectionX = getTriangleLeg(axisOuterRadius, outerRadius);\n      if (!hasBottomIntersection) {\n        const topLeftPt = rotate2(left, sideIntersectionY);\n        path.lineTo(topLeftPt.x, topLeftPt.y);\n      }\n      path.arc(\n        0,\n        0,\n        axisOuterRadius,\n        Math.atan2(sideIntersectionY, left) + pointRotation,\n        Math.atan2(top, -topIntersectionX) + pointRotation,\n        false\n      );\n      if (!isEqual(topIntersectionX, 0)) {\n        const topRightBevelPt = rotate2(topIntersectionX, top);\n        path.lineTo(topRightBevelPt.x, topRightBevelPt.y);\n      }\n      path.arc(\n        0,\n        0,\n        axisOuterRadius,\n        Math.atan2(top, topIntersectionX) + pointRotation,\n        Math.atan2(sideIntersectionY, right) + pointRotation,\n        false\n      );\n    } else {\n      const topLeftPt = rotate2(left, top);\n      const topRightPt = rotate2(right, top);\n      path.lineTo(topLeftPt.x, topLeftPt.y);\n      path.lineTo(topRightPt.x, topRightPt.y);\n    }\n    const bottomRightPt = rotate2(right, bottom);\n    path.lineTo(bottomRightPt.x, bottomRightPt.y);\n    if (shouldConnectBottomCircle) {\n      path.arc(\n        0,\n        0,\n        innerRadius,\n        normalizeAngle360(sideRotation - Math.PI / 2) + pointRotation,\n        normalizeAngle360(-sideRotation - Math.PI / 2) + pointRotation,\n        true\n      );\n    } else {\n      const rotatedBottomLeftPt = rotate2(left, bottom);\n      path.lineTo(rotatedBottomLeftPt.x, rotatedBottomLeftPt.y);\n    }\n    path.closePath();\n  }\n};\nRadialColumnShape.className = \"RadialColumnShape\";\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"isBeveled\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"columnWidth\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"startAngle\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"endAngle\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"outerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"innerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"axisInnerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"axisOuterRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"isRadiusAxisReversed\", 2);\nfunction getRadialColumnWidth(startAngle, endAngle, axisOuterRadius, columnWidthRatio, maxColumnWidthRatio) {\n  const rotation = angleBetween(startAngle, endAngle);\n  const pad2 = rotation * (1 - columnWidthRatio) / 2;\n  startAngle += pad2;\n  endAngle -= pad2;\n  if (rotation < 1e-3) {\n    return 2 * axisOuterRadius * maxColumnWidthRatio;\n  }\n  if (rotation >= 2 * Math.PI) {\n    const midAngle = startAngle + rotation / 2;\n    startAngle = midAngle - Math.PI;\n    endAngle = midAngle + Math.PI;\n  }\n  const startX = axisOuterRadius * Math.cos(startAngle);\n  const startY = axisOuterRadius * Math.sin(startAngle);\n  const endX = axisOuterRadius * Math.cos(endAngle);\n  const endY = axisOuterRadius * Math.sin(endAngle);\n  const colWidth = Math.floor(Math.sqrt((startX - endX) ** 2 + (startY - endY) ** 2));\n  const maxWidth = 2 * axisOuterRadius * maxColumnWidthRatio;\n  return Math.max(1, Math.min(maxWidth, colWidth));\n}\n\n// packages/ag-charts-community/src/scene/shape/svgPath.ts\nvar SvgPath = class extends Path {\n  constructor(d = \"\") {\n    super();\n    this.x = 0;\n    this.y = 0;\n    this.commands = [];\n    this._d = \"\";\n    this.d = d;\n  }\n  get d() {\n    return this._d;\n  }\n  set d(d) {\n    if (d === this._d)\n      return;\n    this._d = d;\n    this.commands.length = 0;\n    for (const [_, command, paramsString] of d.matchAll(/([A-Z])([0-9. ]*)/g)) {\n      const params = paramsString.split(/\\s+/g).map(Number);\n      this.commands.push([command, params]);\n    }\n    this.checkPathDirty();\n  }\n  updatePath() {\n    const { path, x, y } = this;\n    path.clear();\n    let lastX = x;\n    let lastY = y;\n    for (const [command, params] of this.commands) {\n      switch (command) {\n        case \"M\":\n          path.moveTo(x + params[0], y + params[1]);\n          lastX = x + params[0];\n          break;\n        case \"C\":\n          path.cubicCurveTo(\n            x + params[0],\n            y + params[1],\n            x + params[2],\n            y + params[3],\n            x + params[4],\n            y + params[5]\n          );\n          lastX = x + params[4];\n          lastY = y + params[5];\n          break;\n        case \"H\":\n          path.lineTo(x + params[0], lastY);\n          lastX = y + params[0];\n          break;\n        case \"L\":\n          path.lineTo(x + params[0], y + params[1]);\n          lastX = x + params[0];\n          lastY = y + params[1];\n          break;\n        case \"V\":\n          path.lineTo(lastX, y + params[0]);\n          lastY = y + params[0];\n          break;\n        case \"Z\":\n          path.closePath();\n          break;\n        default:\n          throw new Error(`Could not translate command '${command}' with '${params.join(\" \")}'`);\n      }\n    }\n    path.closePath();\n  }\n};\n__decorateClass([\n  ScenePathChangeDetection()\n], SvgPath.prototype, \"x\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], SvgPath.prototype, \"y\", 2);\n\n// packages/ag-charts-community/src/chart/marker/arrowUp.ts\nvar _ArrowUp = class _ArrowUp extends Marker {\n  updatePath() {\n    const s = this.size / 2;\n    super.applyPath(s, _ArrowUp.moves);\n  }\n};\n_ArrowUp.className = \"ArrowUp\";\n_ArrowUp.moves = [\n  { x: 0, y: 0, t: \"move\" },\n  { x: 1, y: 1.2 },\n  { x: -0.5, y: 0 },\n  { x: 0, y: 0.8 },\n  { x: -1, y: 0 },\n  { x: 0, y: -0.8 },\n  { x: -0.5, y: 0 }\n];\nvar ArrowUp = _ArrowUp;\n\n// packages/ag-charts-community/src/chart/marker/arrowDown.ts\nvar ArrowDown = class extends Marker {\n  updatePath() {\n    const s = this.size / 2;\n    super.applyPath(\n      s,\n      ArrowUp.moves.map((m) => ({ x: m.x * -1, y: m.y * -1 }))\n    );\n  }\n};\nArrowDown.className = \"ArrowDown\";\n\n// packages/ag-charts-community/src/integrated-charts-scene.ts\nvar motion = { ...fromToMotion_exports, ...resetMotion_exports };\nvar getFont = TextUtils.toFontString;\n\n// packages/ag-charts-community/src/integrated-charts-theme.ts\nvar integrated_charts_theme_exports = {};\n__export(integrated_charts_theme_exports, {\n  CARTESIAN_AXIS_TYPE: () => CARTESIAN_AXIS_TYPE,\n  CARTESIAN_POSITION: () => CARTESIAN_POSITION,\n  ChartTheme: () => ChartTheme,\n  DEFAULT_ANNOTATION_BACKGROUND_FILL: () => DEFAULT_ANNOTATION_BACKGROUND_FILL,\n  DEFAULT_ANNOTATION_COLOR: () => DEFAULT_ANNOTATION_COLOR,\n  DEFAULT_ANNOTATION_HANDLE_FILL: () => DEFAULT_ANNOTATION_HANDLE_FILL,\n  DEFAULT_ANNOTATION_STATISTICS_COLOR: () => DEFAULT_ANNOTATION_STATISTICS_COLOR,\n  DEFAULT_ANNOTATION_STATISTICS_DIVIDER_STROKE: () => DEFAULT_ANNOTATION_STATISTICS_DIVIDER_STROKE,\n  DEFAULT_ANNOTATION_STATISTICS_DOWN_FILL: () => DEFAULT_ANNOTATION_STATISTICS_DOWN_FILL,\n  DEFAULT_ANNOTATION_STATISTICS_DOWN_STROKE: () => DEFAULT_ANNOTATION_STATISTICS_DOWN_STROKE,\n  DEFAULT_ANNOTATION_STATISTICS_FILL: () => DEFAULT_ANNOTATION_STATISTICS_FILL,\n  DEFAULT_ANNOTATION_STATISTICS_STROKE: () => DEFAULT_ANNOTATION_STATISTICS_STROKE,\n  DEFAULT_AXIS_GRID_COLOUR: () => DEFAULT_AXIS_GRID_COLOUR,\n  DEFAULT_AXIS_LINE_COLOUR: () => DEFAULT_AXIS_LINE_COLOUR,\n  DEFAULT_BACKGROUND_COLOUR: () => DEFAULT_BACKGROUND_COLOUR,\n  DEFAULT_CAPTION_ALIGNMENT: () => DEFAULT_CAPTION_ALIGNMENT,\n  DEFAULT_CAPTION_LAYOUT_STYLE: () => DEFAULT_CAPTION_LAYOUT_STYLE,\n  DEFAULT_COLOURS: () => DEFAULT_COLOURS,\n  DEFAULT_CROSS_LINES_COLOUR: () => DEFAULT_CROSS_LINES_COLOUR,\n  DEFAULT_DIVERGING_SERIES_COLOR_RANGE: () => DEFAULT_DIVERGING_SERIES_COLOR_RANGE,\n  DEFAULT_FONT_FAMILY: () => DEFAULT_FONT_FAMILY,\n  DEFAULT_FUNNEL_SERIES_COLOR_RANGE: () => DEFAULT_FUNNEL_SERIES_COLOR_RANGE,\n  DEFAULT_GAUGE_SERIES_COLOR_RANGE: () => DEFAULT_GAUGE_SERIES_COLOR_RANGE,\n  DEFAULT_GRIDLINE_ENABLED: () => DEFAULT_GRIDLINE_ENABLED,\n  DEFAULT_HIERARCHY_FILLS: () => DEFAULT_HIERARCHY_FILLS,\n  DEFAULT_HIERARCHY_STROKES: () => DEFAULT_HIERARCHY_STROKES,\n  DEFAULT_INSIDE_SERIES_LABEL_COLOUR: () => DEFAULT_INSIDE_SERIES_LABEL_COLOUR,\n  DEFAULT_INVERTED_LABEL_COLOUR: () => DEFAULT_INVERTED_LABEL_COLOUR,\n  DEFAULT_LABEL_COLOUR: () => DEFAULT_LABEL_COLOUR,\n  DEFAULT_MUTED_LABEL_COLOUR: () => DEFAULT_MUTED_LABEL_COLOUR,\n  DEFAULT_PADDING: () => DEFAULT_PADDING,\n  DEFAULT_POLAR_SERIES_STROKE: () => DEFAULT_POLAR_SERIES_STROKE,\n  DEFAULT_SHADOW_COLOUR: () => DEFAULT_SHADOW_COLOUR,\n  DEFAULT_TEXTBOX_COLOR: () => DEFAULT_TEXTBOX_COLOR,\n  DEFAULT_TEXTBOX_FILL: () => DEFAULT_TEXTBOX_FILL,\n  DEFAULT_TEXTBOX_STROKE: () => DEFAULT_TEXTBOX_STROKE,\n  DEFAULT_TEXT_ANNOTATION_COLOR: () => DEFAULT_TEXT_ANNOTATION_COLOR,\n  DEFAULT_TOOLBAR_POSITION: () => DEFAULT_TOOLBAR_POSITION,\n  FONT_SIZE: () => FONT_SIZE,\n  FONT_WEIGHT: () => FONT_WEIGHT2,\n  IS_COMMUNITY: () => IS_COMMUNITY,\n  IS_DARK_THEME: () => IS_DARK_THEME,\n  IS_ENTERPRISE: () => IS_ENTERPRISE,\n  PALETTE_ALT_DOWN_FILL: () => PALETTE_ALT_DOWN_FILL,\n  PALETTE_ALT_DOWN_STROKE: () => PALETTE_ALT_DOWN_STROKE,\n  PALETTE_ALT_NEUTRAL_FILL: () => PALETTE_ALT_NEUTRAL_FILL,\n  PALETTE_ALT_NEUTRAL_STROKE: () => PALETTE_ALT_NEUTRAL_STROKE,\n  PALETTE_ALT_UP_FILL: () => PALETTE_ALT_UP_FILL,\n  PALETTE_ALT_UP_STROKE: () => PALETTE_ALT_UP_STROKE,\n  PALETTE_DOWN_FILL: () => PALETTE_DOWN_FILL,\n  PALETTE_DOWN_STROKE: () => PALETTE_DOWN_STROKE,\n  PALETTE_NEUTRAL_FILL: () => PALETTE_NEUTRAL_FILL,\n  PALETTE_NEUTRAL_STROKE: () => PALETTE_NEUTRAL_STROKE,\n  PALETTE_UP_FILL: () => PALETTE_UP_FILL,\n  PALETTE_UP_STROKE: () => PALETTE_UP_STROKE,\n  POLAR_AXIS_SHAPE: () => POLAR_AXIS_SHAPE,\n  POLAR_AXIS_TYPE: () => POLAR_AXIS_TYPE,\n  getChartTheme: () => getChartTheme,\n  markerPaletteFactory: () => markerPaletteFactory,\n  singleSeriesPaletteFactory: () => singleSeriesPaletteFactory,\n  swapAxisCondition: () => swapAxisCondition,\n  themes: () => themes2\n});\nvar themes2 = mapValues(\n  themes,\n  (themeFactory) => themeFactory?.()\n);\n\n// packages/ag-charts-community/src/sparklines-scale.ts\nvar sparklines_scale_exports = {};\n__export(sparklines_scale_exports, {\n  BandScale: () => BandScale,\n  ColorScale: () => ColorScale,\n  ContinuousScale: () => ContinuousScale,\n  Invalidating: () => Invalidating,\n  LinearScale: () => LinearScale,\n  OrdinalTimeScale: () => OrdinalTimeScale,\n  TimeScale: () => TimeScale\n});\n\n// packages/ag-charts-community/src/sparklines-util.ts\nvar sparklines_util_exports = {};\n__export(sparklines_util_exports, {\n  Color: () => Color,\n  Debug: () => Debug,\n  Logger: () => Logger,\n  Padding: () => Padding,\n  TimeInterval: () => TimeInterval,\n  angleBetween: () => angleBetween,\n  angleDiff: () => angleDiff,\n  arcDistanceSquared: () => arcDistanceSquared,\n  areArrayNumbersEqual: () => areArrayNumbersEqual,\n  checkDatum: () => checkDatum,\n  clamp: () => clamp,\n  clampArray: () => clampArray,\n  clockwiseAngle: () => clockwiseAngle,\n  clockwiseAngles: () => clockwiseAngles,\n  countFractionDigits: () => countFractionDigits,\n  createId: () => createId,\n  day: () => day,\n  deepClone: () => deepClone,\n  displacePointFromVector: () => displacePointFromVector,\n  extent: () => extent,\n  findMinMax: () => findMinMax,\n  findRangeExtent: () => findRangeExtent,\n  formatNormalizedPercentage: () => formatNormalizedPercentage,\n  formatPercentage: () => formatPercentage,\n  friday: () => friday,\n  generateUUID: () => generateUUID,\n  getAttribute: () => getAttribute,\n  hour: () => hour,\n  interpolateColor: () => interpolateColor,\n  interpolateNumber: () => interpolateNumber,\n  isBetweenAngles: () => isBetweenAngles,\n  isContinuous: () => isContinuous,\n  isDate: () => isValidDate,\n  isDenseInterval: () => isDenseInterval,\n  isEqual: () => isEqual,\n  isNegative: () => isNegative,\n  isNumber: () => isFiniteNumber,\n  isNumberEqual: () => isEqual,\n  isNumberObject: () => isNumberObject,\n  isString: () => isString,\n  isStringObject: () => isStringObject,\n  jsonApply: () => jsonApply,\n  jsonDiff: () => jsonDiff,\n  jsonWalk: () => jsonWalk,\n  lineDistanceSquared: () => lineDistanceSquared,\n  millisecond: () => millisecond,\n  minute: () => minute,\n  mod: () => mod,\n  monday: () => monday,\n  month: () => month,\n  normalisedExtentWithMetadata: () => normalisedExtentWithMetadata,\n  normalizeAngle180: () => normalizeAngle180,\n  normalizeAngle360: () => normalizeAngle360,\n  normalizeAngle360Inclusive: () => normalizeAngle360Inclusive,\n  range: () => range,\n  resetIds: () => resetIds,\n  round: () => round,\n  sanitizeHtml: () => sanitizeHtml,\n  saturday: () => saturday,\n  second: () => second,\n  setAttribute: () => setAttribute,\n  setAttributes: () => setAttributes,\n  setElementStyle: () => setElementStyle,\n  shallowClone: () => shallowClone,\n  sunday: () => sunday,\n  thursday: () => thursday,\n  tickFormat: () => tickFormat,\n  tickStep: () => tickStep,\n  ticks: () => createTicks,\n  toDegrees: () => toDegrees,\n  toFixed: () => toFixed,\n  toRadians: () => toRadians,\n  transformIntegratedCategoryValue: () => transformIntegratedCategoryValue,\n  tuesday: () => tuesday,\n  utcDay: () => utcDay,\n  utcHour: () => utcHour,\n  utcMinute: () => utcMinute,\n  utcMonth: () => utcMonth,\n  utcYear: () => utcYear,\n  wednesday: () => wednesday,\n  year: () => year\n});\n\n// packages/ag-charts-community/src/module-support.ts\nvar module_support_exports = {};\n__export(module_support_exports, {\n  AND: () => AND,\n  ARRAY: () => ARRAY,\n  ARRAY_OF: () => ARRAY_OF,\n  AbstractBarSeries: () => AbstractBarSeries,\n  AbstractBarSeriesProperties: () => AbstractBarSeriesProperties,\n  ActionOnSet: () => ActionOnSet,\n  Animation: () => Animation,\n  AnimationManager: () => AnimationManager,\n  Axis: () => Axis,\n  AxisInterval: () => AxisInterval,\n  AxisLabel: () => AxisLabel,\n  AxisTick: () => AxisTick,\n  AxisTicks: () => AxisTicks,\n  BOOLEAN: () => BOOLEAN,\n  BOOLEAN_ARRAY: () => BOOLEAN_ARRAY,\n  Background: () => Background,\n  BackgroundModule: () => BackgroundModule,\n  BaseModuleInstance: () => BaseModuleInstance,\n  BaseProperties: () => BaseProperties,\n  COLOR_STRING: () => COLOR_STRING,\n  COLOR_STRING_ARRAY: () => COLOR_STRING_ARRAY,\n  CachedTextMeasurer: () => CachedTextMeasurer,\n  CachedTextMeasurerPool: () => CachedTextMeasurerPool,\n  CartesianAxis: () => CartesianAxis,\n  CartesianSeries: () => CartesianSeries,\n  CartesianSeriesNodeEvent: () => CartesianSeriesNodeEvent,\n  CartesianSeriesProperties: () => CartesianSeriesProperties,\n  CategoryAxis: () => CategoryAxis,\n  ChartAxisDirection: () => ChartAxisDirection,\n  ChartEventManager: () => ChartEventManager,\n  ChartOptions: () => ChartOptions,\n  ChartUpdateType: () => ChartUpdateType,\n  ContextMenuRegistry: () => ContextMenuRegistry,\n  Cursor: () => Cursor,\n  CursorManager: () => CursorManager,\n  DATE: () => DATE,\n  DATE_ARRAY: () => DATE_ARRAY,\n  DATE_OR_DATETIME_MS: () => DATE_OR_DATETIME_MS,\n  DEFAULT_CARTESIAN_DIRECTION_KEYS: () => DEFAULT_CARTESIAN_DIRECTION_KEYS,\n  DEFAULT_CARTESIAN_DIRECTION_NAMES: () => DEFAULT_CARTESIAN_DIRECTION_NAMES,\n  DEFAULT_TOOLTIP_CLASS: () => DEFAULT_TOOLTIP_CLASS,\n  DEFAULT_TOOLTIP_DARK_CLASS: () => DEFAULT_TOOLTIP_DARK_CLASS,\n  DEGREE: () => DEGREE,\n  DIRECTION: () => DIRECTION,\n  DOMManager: () => DOMManager,\n  DRAG_INTERACTION_TYPES: () => DRAG_INTERACTION_TYPES,\n  DataController: () => DataController,\n  DataModel: () => DataModel,\n  DataModelSeries: () => DataModelSeries,\n  DataService: () => DataService,\n  Default: () => Default,\n  Deprecated: () => Deprecated,\n  DeprecatedAndRenamedTo: () => DeprecatedAndRenamedTo,\n  EMPTY_TOOLTIP_CONTENT: () => EMPTY_TOOLTIP_CONTENT,\n  FONT_STYLE: () => FONT_STYLE,\n  FONT_WEIGHT: () => FONT_WEIGHT,\n  FUNCTION: () => FUNCTION,\n  GREATER_THAN: () => GREATER_THAN,\n  GestureDetector: () => GestureDetector,\n  GroupedCategoryAxis: () => GroupedCategoryAxis,\n  HierarchyNode: () => HierarchyNode,\n  HierarchySeries: () => HierarchySeries,\n  HierarchySeriesProperties: () => HierarchySeriesProperties,\n  HighlightManager: () => HighlightManager,\n  HighlightProperties: () => HighlightProperties,\n  HighlightStyle: () => HighlightStyle,\n  INTERACTION_RANGE: () => INTERACTION_RANGE,\n  INTERPOLATION_STEP_POSITION: () => INTERPOLATION_STEP_POSITION,\n  INTERPOLATION_TYPE: () => INTERPOLATION_TYPE,\n  InteractionManager: () => InteractionManager,\n  InteractionState: () => InteractionState,\n  InterpolationProperties: () => InterpolationProperties,\n  KeyNavManager: () => KeyNavManager,\n  LABEL_PLACEMENT: () => LABEL_PLACEMENT,\n  LARGEST_KEY_INTERVAL: () => LARGEST_KEY_INTERVAL,\n  LESS_THAN: () => LESS_THAN,\n  LINE_CAP: () => LINE_CAP,\n  LINE_DASH: () => LINE_DASH,\n  LINE_JOIN: () => LINE_JOIN,\n  LINE_STYLE: () => LINE_STYLE,\n  LayoutElement: () => LayoutElement,\n  LayoutManager: () => LayoutManager,\n  LonLatBBox: () => LonLatBBox,\n  MARKER_SHAPE: () => MARKER_SHAPE,\n  MATCHING_CROSSLINE_TYPE: () => MATCHING_CROSSLINE_TYPE,\n  MAX_SPACING: () => MAX_SPACING,\n  MIN_SPACING: () => MIN_SPACING,\n  MercatorScale: () => MercatorScale,\n  ModuleRegistry: () => ModuleRegistry,\n  Motion: () => easing_exports,\n  NAN: () => NAN,\n  NODE_UPDATE_STATE_TO_PHASE_MAPPING: () => NODE_UPDATE_STATE_TO_PHASE_MAPPING,\n  NUMBER: () => NUMBER,\n  NUMBER_ARRAY: () => NUMBER_ARRAY,\n  NUMBER_OR_NAN: () => NUMBER_OR_NAN,\n  Navigator: () => Navigator,\n  NavigatorModule: () => NavigatorModule,\n  NodeRegionBBoxProvider: () => NodeRegionBBoxProvider,\n  OBJECT: () => OBJECT,\n  OBJECT_ARRAY: () => OBJECT_ARRAY,\n  OR: () => OR,\n  OVERFLOW_STRATEGY: () => OVERFLOW_STRATEGY,\n  ObserveChanges: () => ObserveChanges,\n  PHASE_METADATA: () => PHASE_METADATA,\n  PHASE_ORDER: () => PHASE_ORDER,\n  PLACEMENT: () => PLACEMENT,\n  PLAIN_OBJECT: () => PLAIN_OBJECT,\n  POINTER_INTERACTION_TYPES: () => POINTER_INTERACTION_TYPES,\n  POSITION: () => POSITION,\n  POSITION_TOP_COORDINATES: () => POSITION_TOP_COORDINATES,\n  POSITIVE_NUMBER: () => POSITIVE_NUMBER,\n  PolarAxis: () => PolarAxis,\n  PolarSeries: () => PolarSeries,\n  PropertiesArray: () => PropertiesArray,\n  ProxyOnWrite: () => ProxyOnWrite,\n  ProxyProperty: () => ProxyProperty,\n  ProxyPropertyOnWrite: () => ProxyPropertyOnWrite,\n  QUICK_TRANSITION: () => QUICK_TRANSITION,\n  RATIO: () => RATIO,\n  REAL_NUMBER: () => REAL_NUMBER,\n  REGIONS: () => REGIONS,\n  RegionManager: () => RegionManager,\n  RepeatType: () => RepeatType,\n  SKIP_JS_BUILTINS: () => SKIP_JS_BUILTINS,\n  SMALLEST_KEY_INTERVAL: () => SMALLEST_KEY_INTERVAL,\n  SORT_DOMAIN_GROUPS: () => SORT_DOMAIN_GROUPS,\n  STRING: () => STRING,\n  STRING_ARRAY: () => STRING_ARRAY,\n  Series: () => Series,\n  SeriesGroupingChangedEvent: () => SeriesGroupingChangedEvent,\n  SeriesItemHighlightStyle: () => SeriesItemHighlightStyle,\n  SeriesMarker: () => SeriesMarker,\n  SeriesNodeEvent: () => SeriesNodeEvent,\n  SeriesNodePickMode: () => SeriesNodePickMode,\n  SeriesProperties: () => SeriesProperties,\n  SeriesTooltip: () => SeriesTooltip,\n  SimpleRegionBBoxProvider: () => SimpleRegionBBoxProvider,\n  SimpleTextMeasurer: () => SimpleTextMeasurer,\n  StateMachine: () => StateMachine,\n  TEXT_ALIGN: () => TEXT_ALIGN,\n  TEXT_WRAP: () => TEXT_WRAP,\n  TICK_INTERVAL: () => TICK_INTERVAL,\n  TOOLBAR_ALIGNMENTS: () => TOOLBAR_ALIGNMENTS,\n  TOOLBAR_GROUPS: () => TOOLBAR_GROUPS,\n  TOOLBAR_GROUP_ORDERING: () => TOOLBAR_GROUP_ORDERING,\n  TOOLBAR_POSITIONS: () => TOOLBAR_POSITIONS,\n  TextUtils: () => TextUtils,\n  TextWrapper: () => TextWrapper,\n  ToolbarManager: () => ToolbarManager,\n  ToolbarPosition: () => ToolbarPosition,\n  Tooltip: () => Tooltip,\n  TooltipManager: () => TooltipManager,\n  TooltipPosition: () => TooltipPosition,\n  UNION: () => UNION,\n  UpdateService: () => UpdateService,\n  VERTICAL_ALIGN: () => VERTICAL_ALIGN,\n  Validate: () => Validate,\n  Vec2: () => Vec2,\n  Vec4: () => Vec4,\n  ZIndexMap: () => ZIndexMap,\n  ZoomManager: () => ZoomManager,\n  __FORCE_MODULE_DETECTION: () => __FORCE_MODULE_DETECTION,\n  accumulateGroup: () => accumulateGroup,\n  accumulateStack: () => accumulateStack,\n  accumulatedValue: () => accumulatedValue,\n  accumulativeValueProperty: () => accumulativeValueProperty,\n  addHitTestersToQuadtree: () => addHitTestersToQuadtree,\n  adjustLabelPlacement: () => adjustLabelPlacement,\n  animationValidation: () => animationValidation,\n  area: () => area,\n  arraysEqual: () => arraysEqual,\n  backfillPathPointData: () => backfillPathPointData,\n  buildFormatter: () => buildFormatter,\n  buildResetPathFn: () => buildResetPathFn,\n  calculateDefaultTimeTickFormat: () => calculateDefaultTimeTickFormat,\n  calculateLabelChartPadding: () => calculateLabelChartPadding,\n  calculateLabelTranslation: () => calculateLabelTranslation,\n  calculatePlacement: () => calculatePlacement,\n  checkCrisp: () => checkCrisp,\n  circularSliceArray: () => circularSliceArray,\n  clamp: () => clamp,\n  clampArray: () => clampArray,\n  collapsedStartingBarPosition: () => collapsedStartingBarPosition,\n  computeBarFocusBounds: () => computeBarFocusBounds,\n  computeMarkerFocusBounds: () => computeMarkerFocusBounds,\n  convertValuesToScaleByDefs: () => convertValuesToScaleByDefs,\n  countFractionDigits: () => countFractionDigits,\n  createButton: () => createButton,\n  createCheckbox: () => createCheckbox,\n  createDatumId: () => createDatumId,\n  createDeprecationWarning: () => createDeprecationWarning,\n  createElement: () => createElement,\n  createElementId: () => createElementId,\n  createElementNS: () => createElementNS,\n  createIcon: () => createIcon,\n  createSelect: () => createSelect,\n  createTextArea: () => createTextArea,\n  dateToNumber: () => dateToNumber,\n  deconstructSelectionsOrNodes: () => deconstructSelectionsOrNodes,\n  deepClone: () => deepClone,\n  deepMerge: () => deepMerge,\n  defaultTimeTickFormat: () => defaultTimeTickFormat,\n  determinePathStatus: () => determinePathStatus,\n  diff: () => diff,\n  downloadUrl: () => downloadUrl,\n  enterpriseModule: () => enterpriseModule,\n  excludesType: () => excludesType,\n  extent: () => extent,\n  extractDecoratedProperties: () => extractDecoratedProperties,\n  findMaxValue: () => findMaxValue,\n  findMinMax: () => findMinMax,\n  findQuadtreeMatch: () => findQuadtreeMatch,\n  findRangeExtent: () => findRangeExtent,\n  fixNumericExtent: () => fixNumericExtent,\n  focusCursorAtEnd: () => focusCursorAtEnd,\n  formatNormalizedPercentage: () => formatNormalizedPercentage,\n  formatPercentage: () => formatPercentage,\n  formatValue: () => formatValue,\n  fromToMotion: () => fromToMotion,\n  getDocument: () => getDocument,\n  getLastFocus: () => getLastFocus,\n  getMissCount: () => getMissCount,\n  getPath: () => getPath,\n  getPathComponents: () => getPathComponents,\n  getRectConfig: () => getRectConfig,\n  getWindow: () => getWindow,\n  groupAccumulativeValueProperty: () => groupAccumulativeValueProperty,\n  groupAverage: () => groupAverage,\n  groupBy: () => groupBy,\n  groupCount: () => groupCount,\n  groupStackValueProperty: () => groupStackValueProperty,\n  groupSum: () => groupSum,\n  initMenuKeyNav: () => initMenuKeyNav,\n  initRovingTabIndex: () => initRovingTabIndex,\n  initToolbarKeyNav: () => initToolbarKeyNav,\n  isAnimatingFloatingPosition: () => isAnimatingFloatingPosition,\n  isArray: () => isArray,\n  isBoolean: () => isBoolean,\n  isButtonClickEvent: () => isButtonClickEvent,\n  isDate: () => isDate,\n  isDecoratedObject: () => isDecoratedObject,\n  isDefined: () => isDefined,\n  isEnumKey: () => isEnumKey,\n  isEnumValue: () => isEnumValue,\n  isEqual: () => isEqual,\n  isFiniteNumber: () => isFiniteNumber,\n  isFunction: () => isFunction,\n  isHtmlElement: () => isHtmlElement,\n  isNegative: () => isNegative,\n  isNumber: () => isNumber,\n  isObject: () => isObject,\n  isObjectLike: () => isObjectLike,\n  isPlainObject: () => isPlainObject,\n  isProperties: () => isProperties,\n  isRegExp: () => isRegExp,\n  isString: () => isString,\n  isSymbol: () => isSymbol,\n  isValidDate: () => isValidDate,\n  jsonApply: () => jsonApply,\n  jsonDiff: () => jsonDiff,\n  jsonWalk: () => jsonWalk,\n  keyProperty: () => keyProperty,\n  labelDirectionHandling: () => labelDirectionHandling,\n  listDecoratedProperties: () => listDecoratedProperties,\n  makeAccessibleClickListener: () => makeAccessibleClickListener,\n  mapValues: () => mapValues,\n  markerFadeInAnimation: () => markerFadeInAnimation,\n  markerPaletteFactory: () => markerPaletteFactory,\n  markerScaleInAnimation: () => markerScaleInAnimation,\n  markerSwipeScaleInAnimation: () => markerSwipeScaleInAnimation,\n  mergeArrayDefaults: () => mergeArrayDefaults,\n  mergeDefaults: () => mergeDefaults,\n  midpointStartingBarPosition: () => midpointStartingBarPosition,\n  minMax: () => minMax,\n  mod: () => mod,\n  moduleRegistry: () => moduleRegistry,\n  nearestSquared: () => nearestSquared,\n  nearestSquaredInContainer: () => nearestSquaredInContainer,\n  normaliseGroupTo: () => normaliseGroupTo,\n  normalisePropertyTo: () => normalisePropertyTo,\n  normalisedExtentWithMetadata: () => normalisedExtentWithMetadata,\n  objectEqualWith: () => objectEqualWith,\n  pairCategoryData: () => pairCategoryData,\n  pairContinuousData: () => pairContinuousData,\n  partialAssign: () => partialAssign,\n  pathFadeInAnimation: () => pathFadeInAnimation,\n  pathFadeOutAnimation: () => pathFadeOutAnimation,\n  pathRangePoints: () => pathRangePoints,\n  pathRangePointsReverse: () => pathRangePointsReverse,\n  pathRanges: () => pathRanges,\n  pathSwipeInAnimation: () => pathSwipeInAnimation,\n  pickByMatchingAngle: () => pickByMatchingAngle,\n  pickNode: () => pickNode,\n  plotPath: () => plotPath,\n  predicateWithMessage: () => predicateWithMessage,\n  prepareAreaPathAnimation: () => prepareAreaPathAnimation,\n  prepareAxisAnimationContext: () => prepareAxisAnimationContext,\n  prepareAxisAnimationFunctions: () => prepareAxisAnimationFunctions,\n  prepareBarAnimationFunctions: () => prepareBarAnimationFunctions,\n  prepareLinePathAnimation: () => prepareLinePathAnimation,\n  prepareLinePathAnimationFns: () => prepareLinePathAnimationFns,\n  prepareLinePathPropertyAnimation: () => prepareLinePathPropertyAnimation,\n  prepareMarkerAnimation: () => prepareMarkerAnimation,\n  preparePieSeriesAnimationFunctions: () => preparePieSeriesAnimationFunctions,\n  range: () => range2,\n  rangedValueProperty: () => rangedValueProperty,\n  renderPartialPath: () => renderPartialPath,\n  resetAxisGroupFn: () => resetAxisGroupFn,\n  resetAxisLabelSelectionFn: () => resetAxisLabelSelectionFn,\n  resetAxisLineSelectionFn: () => resetAxisLineSelectionFn,\n  resetAxisSelectionFn: () => resetAxisSelectionFn,\n  resetBarSelectionsFn: () => resetBarSelectionsFn,\n  resetIds: () => resetIds,\n  resetLabelFn: () => resetLabelFn,\n  resetMarkerFn: () => resetMarkerFn,\n  resetMarkerPositionFn: () => resetMarkerPositionFn,\n  resetMotion: () => resetMotion,\n  resetPieSelectionsFn: () => resetPieSelectionsFn,\n  round: () => round,\n  scale: () => scale,\n  seriesLabelFadeInAnimation: () => seriesLabelFadeInAnimation,\n  seriesLabelFadeOutAnimation: () => seriesLabelFadeOutAnimation,\n  setDocument: () => setDocument,\n  setElementBBox: () => setElementBBox,\n  setPath: () => setPath,\n  setWindow: () => setWindow,\n  shallowClone: () => shallowClone,\n  singleSeriesPaletteFactory: () => singleSeriesPaletteFactory,\n  sortBasedOnArray: () => sortBasedOnArray,\n  splitPairData: () => splitPairData,\n  staticFromToMotion: () => staticFromToMotion,\n  stopPageScrolling: () => stopPageScrolling,\n  stringify: () => stringify,\n  sum: () => sum,\n  sumValues: () => sumValues,\n  toArray: () => toArray,\n  toFixed: () => toFixed,\n  toTooltipHtml: () => toTooltipHtml,\n  trailingAccumulatedValue: () => trailingAccumulatedValue,\n  trailingAccumulatedValueProperty: () => trailingAccumulatedValueProperty,\n  unique: () => unique,\n  updateClipPath: () => updateClipPath,\n  updateLabelNode: () => updateLabelNode,\n  updateRect: () => updateRect,\n  validateCrossLineValues: () => validateCrossLineValues,\n  valueProperty: () => valueProperty,\n  without: () => without\n});\n\n// packages/ag-charts-community/src/util/deprecation.ts\nfunction createDeprecationWarning() {\n  return (key, message) => {\n    const msg = [`Property [${key}] is deprecated.`, message].filter(Boolean).join(\" \");\n    Logger.warnOnce(msg);\n  };\n}\nfunction Deprecated(message, opts) {\n  const warnDeprecated = createDeprecationWarning();\n  const def = opts?.default;\n  return addTransformToInstanceProperty((_, key, value) => {\n    if (value !== def) {\n      warnDeprecated(key.toString(), message);\n    }\n    return value;\n  });\n}\nfunction DeprecatedAndRenamedTo(newPropName, mapValue) {\n  const warnDeprecated = createDeprecationWarning();\n  return addTransformToInstanceProperty(\n    (target, key, value) => {\n      if (value !== target[newPropName]) {\n        warnDeprecated(key.toString(), `Use [${newPropName}] instead.`);\n        setPath(target, newPropName, mapValue ? mapValue(value) : value);\n      }\n      return BREAK_TRANSFORM_CHAIN;\n    },\n    (target, key) => {\n      warnDeprecated(key.toString(), `Use [${newPropName}] instead.`);\n      return getPath(target, newPropName);\n    }\n  );\n}\n\n// packages/ag-charts-community/src/util/search.util.ts\nfunction findMaxValue(min, max, iteratee) {\n  if (min > max)\n    return;\n  let found;\n  while (max >= min) {\n    const index = Math.floor((max + min) / 2);\n    const value = iteratee(index);\n    if (value == null) {\n      max = index - 1;\n    } else {\n      found = value;\n      min = index + 1;\n    }\n  }\n  return found;\n}\n\n// packages/ag-charts-community/src/util/vector4.ts\nvar Vec4 = {\n  bottomCenter,\n  center,\n  clone,\n  end,\n  from: from2,\n  height,\n  round: round4,\n  start,\n  topCenter,\n  origin: origin2,\n  width\n};\nfunction start(a) {\n  return { x: a.x1, y: a.y1 };\n}\nfunction end(a) {\n  return { x: a.x2, y: a.y2 };\n}\nfunction topCenter(a) {\n  return { x: (a.x1 + a.x2) / 2, y: Math.min(a.y1, a.y2) };\n}\nfunction center(a) {\n  return { x: (a.x1 + a.x2) / 2, y: (a.y1 + a.y2) / 2 };\n}\nfunction bottomCenter(a) {\n  return { x: (a.x1 + a.x2) / 2, y: Math.max(a.y1, a.y2) };\n}\nfunction width(a) {\n  return Math.abs(a.x2 - a.x1);\n}\nfunction height(a) {\n  return Math.abs(a.y2 - a.y1);\n}\nfunction round4(a) {\n  return { x1: Math.round(a.x1), y1: Math.round(a.y1), x2: Math.round(a.x2), y2: Math.round(a.y2) };\n}\nfunction clone(a) {\n  return { x1: a.x1, y1: a.y1, x2: a.x2, y2: a.y2 };\n}\nfunction from2(a, b, c, d) {\n  if (typeof a === \"number\") {\n    return { x1: a, y1: b, x2: c, y2: d };\n  }\n  if (\"width\" in a) {\n    return {\n      x1: a.x,\n      y1: a.y,\n      x2: a.x + a.width,\n      y2: a.y + a.height\n    };\n  }\n  throw new Error(`Values can not be converted into a vector4: [${a}] [${b}] [${c}] [${d}]`);\n}\nfunction origin2() {\n  return { x1: 0, y1: 0, x2: 0, y2: 0 };\n}\n\n// packages/ag-charts-community/src/chart/series/hierarchy/hierarchySeries.ts\nvar _HierarchyNode = class _HierarchyNode {\n  constructor(series, index, datum, size, colorValue, fill, stroke, sumSize, depth, parent, children) {\n    this.series = series;\n    this.index = index;\n    this.datum = datum;\n    this.size = size;\n    this.colorValue = colorValue;\n    this.fill = fill;\n    this.stroke = stroke;\n    this.sumSize = sumSize;\n    this.depth = depth;\n    this.parent = parent;\n    this.children = children;\n    this.midPoint = { x: 0, y: 0 };\n  }\n  contains(other) {\n    let current = other;\n    while (current != null && current.index >= this.index) {\n      if (current === this) {\n        return true;\n      }\n      current = current.parent;\n    }\n    return false;\n  }\n  walk(callback2, order = _HierarchyNode.Walk.PreOrder) {\n    if (order === _HierarchyNode.Walk.PreOrder) {\n      callback2(this);\n    }\n    this.children.forEach((child) => {\n      child.walk(callback2, order);\n    });\n    if (order === _HierarchyNode.Walk.PostOrder) {\n      callback2(this);\n    }\n  }\n  *[Symbol.iterator]() {\n    yield this;\n    for (const child of this.children) {\n      yield* child;\n    }\n  }\n};\n_HierarchyNode.Walk = {\n  PreOrder: 0,\n  PostOrder: 1\n};\nvar HierarchyNode = _HierarchyNode;\nvar HierarchySeries = class extends Series {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      pickModes: [1 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */],\n      contentGroupVirtual: false\n    });\n    this.rootNode = new HierarchyNode(\n      this,\n      0,\n      void 0,\n      0,\n      void 0,\n      void 0,\n      void 0,\n      0,\n      void 0,\n      void 0,\n      []\n    );\n    this.colorDomain = [0, 0];\n    this.maxDepth = 0;\n    this.focusPath = [];\n    this.animationState = new StateMachine(\n      \"empty\",\n      {\n        empty: {\n          update: {\n            target: \"ready\",\n            action: (data) => this.animateEmptyUpdateReady(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\"\n        },\n        ready: {\n          updateData: \"waiting\",\n          clear: \"clearing\",\n          highlight: (data) => this.animateReadyHighlight(data),\n          resize: (data) => this.animateReadyResize(data),\n          reset: \"empty\",\n          skip: \"ready\"\n        },\n        waiting: {\n          update: {\n            target: \"ready\",\n            action: (data) => this.animateWaitingUpdateReady(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\"\n        },\n        clearing: {\n          update: {\n            target: \"empty\",\n            action: (data) => this.animateClearingUpdateEmpty(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\"\n        }\n      },\n      () => this.checkProcessedDataAnimatable()\n    );\n  }\n  resetAnimation(phase) {\n    if (phase === \"initial\") {\n      this.animationState.transition(\"reset\");\n    } else if (phase === \"ready\") {\n      this.animationState.transition(\"skip\");\n    }\n  }\n  async processData() {\n    const { childrenKey, sizeKey, colorKey, fills, strokes, colorRange } = this.properties;\n    let index = 0;\n    const getIndex = () => {\n      index += 1;\n      return index;\n    };\n    let maxDepth = 0;\n    let minColor = Infinity;\n    let maxColor = -Infinity;\n    const colors = new Array((this.data?.length ?? 0) + 1).fill(void 0);\n    const createNode = (datum, parent) => {\n      const nodeIndex = getIndex();\n      const depth = parent.depth != null ? parent.depth + 1 : 0;\n      const children = childrenKey != null ? datum[childrenKey] : void 0;\n      const isLeaf = children == null || children.length === 0;\n      let size = sizeKey != null ? datum[sizeKey] : void 0;\n      if (Number.isFinite(size)) {\n        size = Math.max(size, 0);\n      } else {\n        size = isLeaf ? 1 : 0;\n      }\n      const sumSize = size;\n      maxDepth = Math.max(maxDepth, depth);\n      const color = colorKey != null ? datum[colorKey] : void 0;\n      if (typeof color === \"number\") {\n        colors[nodeIndex] = color;\n        minColor = Math.min(minColor, color);\n        maxColor = Math.max(maxColor, color);\n      }\n      return appendChildren(\n        new HierarchyNode(\n          this,\n          nodeIndex,\n          datum,\n          size,\n          color,\n          void 0,\n          void 0,\n          sumSize,\n          depth,\n          parent,\n          []\n        ),\n        children\n      );\n    };\n    const appendChildren = (node, data) => {\n      data?.forEach((datum) => {\n        const child = createNode(datum, node);\n        node.children.push(child);\n        node.sumSize += child.sumSize;\n      });\n      return node;\n    };\n    const rootNode = appendChildren(\n      new HierarchyNode(\n        this,\n        0,\n        void 0,\n        0,\n        void 0,\n        void 0,\n        void 0,\n        0,\n        void 0,\n        void 0,\n        []\n      ),\n      this.data\n    );\n    const colorDomain = [minColor, maxColor];\n    let colorScale;\n    if (colorRange != null && Number.isFinite(minColor) && Number.isFinite(maxColor)) {\n      colorScale = new ColorScale();\n      colorScale.domain = colorDomain;\n      colorScale.range = colorRange;\n      colorScale.update();\n    }\n    rootNode.children.forEach((child, childIndex) => {\n      child.walk((node) => {\n        let fill;\n        const color = colors[node.index];\n        if (color != null) {\n          fill = colorScale?.convert(color);\n        }\n        fill ?? (fill = fills?.[childIndex % fills.length]);\n        node.fill = fill;\n        node.stroke = colorScale == null ? strokes?.[childIndex % strokes.length] : \"rgba(0, 0, 0, 0.2)\";\n      });\n    });\n    this.rootNode = rootNode;\n    this.maxDepth = maxDepth;\n    this.colorDomain = colorDomain;\n    this.focusPath = [{ nodeDatum: this.rootNode, childIndex: 0 }];\n  }\n  async update({ seriesRect }) {\n    await this.updateSelections();\n    await this.updateNodes();\n    const animationData = this.getAnimationData();\n    const resize = this.checkResize(seriesRect);\n    if (resize) {\n      this.animationState.transition(\"resize\", animationData);\n    }\n    this.animationState.transition(\"update\", animationData);\n  }\n  resetAllAnimation(data) {\n    const datum = this.animationResetFns?.datum;\n    this.ctx.animationManager.stopByAnimationGroupId(this.id);\n    if (datum != null) {\n      resetMotion(data.datumSelections, datum);\n    }\n  }\n  animateEmptyUpdateReady(data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation(data);\n  }\n  animateWaitingUpdateReady(data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation(data);\n  }\n  animateReadyHighlight(data) {\n    const datum = this.animationResetFns?.datum;\n    if (datum != null) {\n      resetMotion([data], datum);\n    }\n  }\n  animateReadyResize(data) {\n    this.resetAllAnimation(data);\n  }\n  animateClearingUpdateEmpty(data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation(data);\n  }\n  animationTransitionClear() {\n    this.animationState.transition(\"clear\", this.getAnimationData());\n  }\n  getAnimationData() {\n    const animationData = {\n      datumSelections: [this.groupSelection]\n    };\n    return animationData;\n  }\n  isProcessedDataAnimatable() {\n    return true;\n  }\n  checkProcessedDataAnimatable() {\n    if (!this.isProcessedDataAnimatable()) {\n      this.ctx.animationManager.skipCurrentBatch();\n    }\n  }\n  getLabelData() {\n    return [];\n  }\n  getSeriesDomain() {\n    return [NaN, NaN];\n  }\n  getLegendData(legendType) {\n    const { colorKey, colorName, colorRange, visible } = this.properties;\n    return legendType === \"gradient\" && colorKey != null && colorRange != null ? [\n      {\n        legendType: \"gradient\",\n        enabled: visible,\n        seriesId: this.id,\n        colorName,\n        colorRange,\n        colorDomain: this.colorDomain\n      }\n    ] : [];\n  }\n  getDatumIdFromData(node) {\n    return `${node.index}`;\n  }\n  getDatumId(node) {\n    return this.getDatumIdFromData(node);\n  }\n  pickFocus(opts) {\n    if (this.rootNode.children.length === 0)\n      return void 0;\n    if (this.focusPath.length === 0) {\n      Logger.error(\"this.focusPath should not be empty\");\n    }\n    const { datumIndexDelta: childDelta, otherIndexDelta: depthDelta } = opts;\n    const { focusPath: path } = this;\n    const depth = path.length - 2;\n    if (depthDelta !== 0 || path.length === 1) {\n      const targetDepth = Math.max(0, depth + depthDelta);\n      if (path[targetDepth + 1] !== void 0) {\n        path.length = targetDepth + 2;\n        return this.computeFocusOutputs(path[targetDepth + 1]);\n      } else {\n        let deepest = path[path.length - 1];\n        while (deepest.nodeDatum.children.length > 0 && (deepest.nodeDatum.depth ?? -1) < targetDepth) {\n          const nextDeepest = { nodeDatum: deepest.nodeDatum.children[0], childIndex: 0 };\n          path.push(nextDeepest);\n          deepest = nextDeepest;\n        }\n        return this.computeFocusOutputs(deepest);\n      }\n    } else if (childDelta !== 0) {\n      const targetChild = path[depth + 1].childIndex + childDelta;\n      const currentParent = path[depth].nodeDatum;\n      const childCount = currentParent?.children?.length;\n      if (childCount !== void 0) {\n        const newChild = clamp(0, targetChild, childCount - 1);\n        const newFocus = { nodeDatum: currentParent.children[newChild], childIndex: newChild };\n        path[depth + 1] = newFocus;\n        path.length = depth + 2;\n        return this.computeFocusOutputs(newFocus);\n      }\n    } else {\n      return this.computeFocusOutputs(path[path.length - 1]);\n    }\n  }\n  getDatumAriaText(datum, description) {\n    if (!(datum instanceof HierarchyNode)) {\n      Logger.error(`datum is not HierarchyNode: ${datum}`);\n      return;\n    }\n    return this.ctx.localeManager.t(\"ariaAnnounceHierarchyDatum\", {\n      level: (datum.depth ?? -1) + 1,\n      count: datum.children.length,\n      description\n    });\n  }\n  computeFocusOutputs({ nodeDatum, childIndex }) {\n    const bounds = this.computeFocusBounds(nodeDatum);\n    if (bounds) {\n      return {\n        datum: nodeDatum,\n        datumIndex: childIndex,\n        otherIndex: nodeDatum.depth,\n        bounds,\n        showFocusBox: true\n      };\n    }\n    return void 0;\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/hierarchy/hierarchySeriesProperties.ts\nvar HierarchySeriesProperties = class extends SeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.childrenKey = \"children\";\n    this.fills = Object.values(DEFAULT_FILLS);\n    this.strokes = Object.values(DEFAULT_STROKES);\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], HierarchySeriesProperties.prototype, \"childrenKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], HierarchySeriesProperties.prototype, \"sizeKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], HierarchySeriesProperties.prototype, \"colorKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], HierarchySeriesProperties.prototype, \"colorName\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], HierarchySeriesProperties.prototype, \"fills\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], HierarchySeriesProperties.prototype, \"strokes\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY, { optional: true })\n], HierarchySeriesProperties.prototype, \"colorRange\", 2);\n\n// packages/ag-charts-community/src/chart/series/topology/lonLatBbox.ts\nvar LonLatBBox = class {\n  constructor(lon0, lat0, lon1, lat1) {\n    this.lon0 = lon0;\n    this.lat0 = lat0;\n    this.lon1 = lon1;\n    this.lat1 = lat1;\n  }\n  merge(other) {\n    this.lon0 = Math.min(this.lon0, other.lon0);\n    this.lat0 = Math.min(this.lat0, other.lat0);\n    this.lon1 = Math.max(this.lon1, other.lon1);\n    this.lat1 = Math.max(this.lat1, other.lat1);\n  }\n};\n\n// packages/ag-charts-community/src/util/tempUtils.ts\nfunction createIdsGenerator() {\n  const idsCounter = /* @__PURE__ */ new Map();\n  return (name) => {\n    const counter = idsCounter.get(name);\n    if (counter) {\n      idsCounter.set(name, counter + 1);\n      return `${name}${counter}`;\n    }\n    idsCounter.set(name, 1);\n    return name;\n  };\n}\n\n// packages/ag-charts-community/src/chart/axis/axisTicks.ts\nvar _AxisTicks = class _AxisTicks {\n  constructor() {\n    this.id = createId(this);\n    this.axisGroup = new TranslatableGroup({ name: `${this.id}-AxisTicks`, zIndex: 2 /* AXIS */ });\n    this.labelSelection = Selection.select(this.axisGroup, Text);\n    this.interval = new AxisInterval();\n    this.label = new AxisLabel();\n    this.scale = new LinearScale();\n    this.position = \"bottom\";\n    this.translationX = 0;\n    this.translationY = 0;\n    this.padding = 0;\n  }\n  attachAxis(axisNode) {\n    axisNode.appendChild(this.axisGroup);\n  }\n  calculateLayout() {\n    this.scale.interval = this.interval.step;\n    const boxes = [];\n    const tickData = this.generateTicks();\n    const { translationX, translationY } = this;\n    this.labelSelection.update(\n      tickData.ticks.map((d) => this.createLabelDatum(d)),\n      void 0,\n      (datum) => datum.tickId\n    );\n    this.labelSelection.each((node, datum) => {\n      node.setProperties(datum);\n      if (datum.visible) {\n        boxes.push(node.getBBox());\n      }\n    });\n    this.axisGroup.setProperties({ translationX, translationY });\n    return BBox.merge(boxes);\n  }\n  getLabelParams(datum) {\n    const { padding } = this;\n    const { translate } = datum;\n    switch (this.position) {\n      case \"top\":\n      case \"bottom\":\n        return {\n          x: translate,\n          y: padding,\n          textAlign: \"center\",\n          textBaseline: \"top\"\n        };\n      case \"left\":\n      case \"right\":\n        return {\n          x: padding,\n          y: translate,\n          textAlign: \"start\",\n          textBaseline: \"middle\"\n        };\n    }\n  }\n  inRange(x, tolerance = 1e-3) {\n    const [min, max] = findMinMax(this.scale.range);\n    return x >= min - tolerance && x <= max + tolerance;\n  }\n  createLabelDatum(datum) {\n    const { x, y, textBaseline, textAlign } = this.getLabelParams(datum);\n    return {\n      visible: Boolean(datum.tickLabel),\n      tickId: datum.tickId,\n      fill: this.label.color,\n      fontFamily: this.label.fontFamily,\n      fontSize: this.label.fontSize,\n      fontStyle: this.label.fontStyle,\n      fontWeight: this.label.fontWeight,\n      rotation: 0,\n      rotationCenterX: 0,\n      text: datum.tickLabel,\n      textAlign,\n      textBaseline,\n      x,\n      y\n    };\n  }\n  generateTicks() {\n    const { minSpacing, maxSpacing } = this.interval;\n    const extentWithBleed = round(findRangeExtent(this.scale.range), 2);\n    const { maxTickCount, minTickCount, tickCount } = estimateTickCount(\n      extentWithBleed,\n      minSpacing,\n      maxSpacing,\n      _AxisTicks.DefaultTickCount,\n      _AxisTicks.DefaultMinSpacing\n    );\n    if (tickCount) {\n      this.scale.tickCount = tickCount;\n      this.scale.minTickCount = minTickCount;\n      this.scale.maxTickCount = maxTickCount;\n    }\n    const tickData = this.getTicksData();\n    if (this.position === \"bottom\" || this.position === \"top\") {\n      const measurer = CachedTextMeasurerPool.getMeasurer({ font: this.label });\n      const domain = this.scale.getDomain();\n      const reversed = domain[0] > domain[1];\n      const direction = reversed ? -1 : 1;\n      let lastTickPosition = -Infinity * direction;\n      tickData.ticks = tickData.ticks.filter((data) => {\n        if (Math.sign(data.translate - lastTickPosition) !== direction)\n          return false;\n        lastTickPosition = data.translate + measurer.textWidth(data.tickLabel, true) * direction;\n        return true;\n      });\n    }\n    return tickData;\n  }\n  getTicksData() {\n    const ticks = [];\n    const rawTicks = this.scale.ticks();\n    const fractionDigits = rawTicks.reduce(\n      (max, tick) => Math.max(max, typeof tick === \"number\" ? countFractionDigits(tick) : 0),\n      0\n    );\n    const idGenerator = createIdsGenerator();\n    const labelFormatter = this.label.format ? this.scale.tickFormat({ ticks: rawTicks, specifier: this.label.format }) : (x) => isNumber(x) ? x.toFixed(fractionDigits) : String(x);\n    for (let index = 0; index < rawTicks.length; index++) {\n      const tick = rawTicks[index];\n      const translate = this.scale.convert(tick);\n      if (!this.inRange(translate))\n        continue;\n      const tickLabel = this.label.formatter?.({ value: tick, index, fractionDigits }) ?? labelFormatter(tick);\n      const tickId = idGenerator(tickLabel);\n      ticks.push({ tick, tickId, tickLabel, translate });\n    }\n    return { rawTicks, fractionDigits, ticks };\n  }\n};\n_AxisTicks.DefaultTickCount = 5;\n_AxisTicks.DefaultMinSpacing = 50;\nvar AxisTicks = _AxisTicks;\n\n// packages/ag-charts-community/src/chart/legendDatum.ts\nvar __FORCE_MODULE_DETECTION = 0;\n\n// packages/ag-charts-community/src/dom/elements.ts\nfunction createButton(options, attrs) {\n  const button = createElement(\"button\", getClassName(\"ag-charts-input ag-charts-button\", attrs));\n  if (options.label !== void 0) {\n    button.append(options.label);\n  } else {\n    button.append(createIcon(options.icon));\n    button.ariaLabel = options.altText;\n  }\n  button.addEventListener(\"click\", options.onPress);\n  setAttributes(button, attrs);\n  return button;\n}\nfunction createCheckbox(options, attrs) {\n  const checkbox = createElement(\"input\", getClassName(\"ag-charts-input ag-charts-checkbox\", attrs));\n  checkbox.type = \"checkbox\";\n  checkbox.checked = options.checked;\n  checkbox.addEventListener(\"change\", (event) => options.onChange(checkbox.checked, event));\n  checkbox.addEventListener(\"keydown\", (event) => {\n    if (isButtonClickEvent(event)) {\n      event.preventDefault();\n      checkbox.click();\n    }\n  });\n  setAttributes(checkbox, attrs);\n  return checkbox;\n}\nfunction createSelect(options, attrs) {\n  const select = createElement(\"select\", getClassName(\"ag-charts-input ag-charts-select\", attrs));\n  select.append(\n    ...options.options.map((option) => {\n      const optionEl = createElement(\"option\");\n      optionEl.value = option.value;\n      optionEl.textContent = option.label;\n      return optionEl;\n    })\n  );\n  setAttribute(select, \"data-preventdefault\", false);\n  select.value = options.value;\n  select.addEventListener(\"change\", (event) => options.onChange(select.value, event));\n  setAttributes(select, attrs);\n  return select;\n}\nfunction createTextArea(options, attrs) {\n  const textArea = createElement(\"textarea\", getClassName(\"ag-charts-input ag-charts-textarea\", attrs));\n  textArea.value = options.value;\n  textArea.addEventListener(\"input\", (event) => options.onChange(textArea.value, event));\n  setAttributes(textArea, attrs);\n  return textArea;\n}\nfunction createIcon(icon) {\n  const el = createElement(\"span\", `ag-charts-icon ag-charts-icon-${icon}`);\n  setAttribute(el, \"aria-hidden\", true);\n  return el;\n}\nfunction getClassName(baseClass, attrs) {\n  if (attrs == null)\n    return baseClass;\n  return `${baseClass} ${attrs.class}`;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWctY2hhcnRzLWNvbW11bml0eS9kaXN0L3BhY2thZ2UvbWFpbi5lc20ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxRQUFRO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsTUFBTTtBQUNuQztBQUNBLCtCQUErQixZQUFZO0FBQzNDO0FBQ0Esa0RBQWtELFFBQVE7QUFDMUQ7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBLHVDQUF1QyxNQUFNLFlBQVksTUFBTSxxQkFBcUIsWUFBWTtBQUNoRztBQUNBLDBDQUEwQyxPQUFPLEtBQUssTUFBTSxTQUFTLE1BQU0sS0FBSyxHQUFHLElBQUksVUFBVSxFQUFFLEtBQUs7QUFDeEc7QUFDQSwwQ0FBMEMsT0FBTyxLQUFLLE1BQU0sSUFBSSxZQUFZO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE1BQU0sZ0JBQWdCLE1BQU0sY0FBYyxNQUFNO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsSUFBSSxlQUFlLElBQUk7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVUsR0FBRyxPQUFPO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsdUJBQXVCO0FBQ2pDLG1CQUFtQjtBQUNuQjtBQUNBLFlBQVksNkNBQTZDO0FBQ3pEO0FBQ0EsZUFBZTtBQUNmLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakIsd0NBQXdDLGlCQUFpQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFdBQVc7QUFDekMsK0JBQStCLFlBQVk7QUFDM0MsNkJBQTZCLE9BQU87QUFDcEMsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw2QkFBNkIsR0FBRyxNQUFNO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQ0FBc0M7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1Q0FBdUM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVDQUF1QztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQkFBa0I7QUFDbkI7QUFDQTtBQUNBLDRCQUE0QixJQUFJO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFdBQVc7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx5QkFBeUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxxQ0FBcUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwyQkFBMkI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMkJBQTJCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHFCQUFxQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG9CQUFvQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFdBQVc7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0JBQWtCO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDJDQUEyQyxJQUFJO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxxREFBcUQsRUFBRSxJQUFJLEVBQUU7QUFDN0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHFFQUFxRTtBQUMvRSxVQUFVLG9CQUFvQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsUUFBUSxHQUFHLE1BQU0sR0FBRyxRQUFRO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMERBQTBEO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpQ0FBaUM7QUFDM0QsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUSxHQUFHLE1BQU0sYUFBYSxlQUFlO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsb0JBQW9CO0FBQzlCLFVBQVUsK0JBQStCO0FBQ3pDO0FBQ0EsV0FBVyxRQUFRLEdBQUcsTUFBTTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDZCQUE2QixrQkFBa0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGtCQUFrQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixVQUFVO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUFLLEVBQUUsNkNBQTZDLEVBQUUsNkNBQTZDO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQ0FBcUMsRUFBRSxPQUFPO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTiwwQkFBMEIsZUFBZSxFQUFFLHdCQUF3QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxjQUFjO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQThCO0FBQ3hDLFlBQVksNkNBQTZDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBLFlBQVksc0JBQXNCLEVBQUUsZUFBZTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsVUFBVTtBQUNoRDtBQUNBO0FBQ0EsWUFBWSxnQ0FBZ0MsRUFBRSxVQUFVO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUscUJBQXFCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLEtBQUs7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNEJBQTRCO0FBQ3BEO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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LGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGlCQUFpQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrQkFBK0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHdCQUF3QjtBQUNsRSxjQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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cEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsZ0JBQWdCO0FBQzNEO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsNEJBQTRCO0FBQzFFLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMERBQTBEO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkNBQTZDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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UUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLE9BQU87QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMscUJBQXFCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpQ0FBaUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQ0FBZ0M7QUFDL0M7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNEJBQTRCO0FBQ3hDO0FBQ0E7QUFDQSxjQUFjLDZFQUE2RTtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNEJBQTRCO0FBQ3hDLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdCQUFnQjtBQUN4QixRQUFRLGdCQUFnQjtBQUN4QixRQUFRLGtCQUFrQjtBQUMxQixRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVEsb0JBQW9CO0FBQzVCLFFBQVEsa0JBQWtCO0FBQzFCLFFBQVEsZ0JBQWdCO0FBQ3hCLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwQkFBMEI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLHVFQUF1RSxhQUFhO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFFBQVEsRUFBRSxRQUFRLEVBQUUsWUFBWSxFQUFFLFlBQVk7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKLGFBQWE7QUFDYixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5QkFBeUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMseUJBQXlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEtBQUs7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNHQUFzRztBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsTUFBTTtBQUMvQjtBQUNBO0FBQ0EsNENBQTRDLHNFQUFzRTtBQUNsSCwyQ0FBMkMsbUJBQW1CO0FBQzlELDJDQUEyQyxtQkFBbUI7QUFDOUQsK0NBQStDLHNDQUFzQztBQUNyRjtBQUNBLGlDQUFpQyx5QkFBeUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsWUFBWSxxREFBcUQ7QUFDakU7QUFDQSw2QkFBNkIsOEJBQThCLCtCQUErQiw4QkFBOEI7QUFDeEg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdGQUF3RjtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxvQkFBb0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlDQUF5QztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwyRUFBMkUsTUFBTTtBQUNqRjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFFBQVE7QUFDdEM7QUFDQTtBQUNBLFlBQVksNkNBQTZDO0FBQ3pELFlBQVksc0ZBQXNGO0FBQ2xHLG9DQUFvQyw0Q0FBNEM7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDZDQUE2QztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixLQUFLO0FBQ3hCO0FBQ0EsTUFBTTtBQUNOLFlBQVksb0RBQW9EO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZGQUE2RjtBQUM3RjtBQUNBO0FBQ0EsVUFBVSw2RUFBNkU7QUFDdkY7QUFDQSxVQUFVLDhCQUE4QjtBQUN4QztBQUNBO0FBQ0EsR0FBRztBQUNILG9FQUFvRSxFQUFFLElBQUksRUFBRSxZQUFZO0FBQ3hGO0FBQ0E7QUFDQSxPQUFPLG9DQUFvQyxHQUFHLE9BQU87QUFDckQsT0FBTyxPQUFPO0FBQ2QsZUFBZSwwRUFBMEUsV0FBVyxvQ0FBb0M7QUFDeEksOEJBQThCLGlDQUFpQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLEtBQUs7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGNBQWM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxhQUFhO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQUk7QUFDVjtBQUNBO0FBQ0EsY0FBYyxxQkFBcUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsNkJBQTZCLGFBQWE7QUFDMUM7QUFDQTtBQUNBLDZCQUE2QixhQUFhO0FBQzFDO0FBQ0EsaUZBQWlGLEtBQUs7QUFDdEY7QUFDQSxhQUFhLHNDQUFzQztBQUNuRCxhQUFhLDRCQUE0QjtBQUN6QyxnQkFBZ0IsT0FBTztBQUN2Qiw2QkFBNkIsU0FBUztBQUN0QztBQUNBLGdDQUFnQyxhQUFhO0FBQzdDLGdDQUFnQyxhQUFhO0FBQzdDLDRCQUE0QixTQUFTO0FBQ3JDLHVEQUF1RCxTQUFTO0FBQ2hFLHVEQUF1RCxTQUFTO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLEtBQUssR0FBRyxRQUFRO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLEtBQUssR0FBRyxFQUFFO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLElBQUk7QUFDWCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVSxJQUFJLE9BQU8sR0FBRyxtQ0FBbUM7QUFDdkU7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUFLLElBQUksaUNBQWlDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQkFBb0IsMEJBQTBCLGdDQUFnQztBQUMxRixZQUFZLGtCQUFrQixlQUFlLElBQUksc0JBQXNCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFtQjtBQUNqQyw2RkFBNkYsa0JBQWtCO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdCQUFnQjtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLCtDQUErQztBQUNwRixpQ0FBaUMsb0NBQW9DO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsY0FBYyxpQ0FBaUM7QUFDL0MsZUFBZTtBQUNmLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUNBQWlDO0FBQzdDLFVBQVUsbUJBQW1CO0FBQzdCO0FBQ0EsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQ0FBZ0M7QUFDNUMsVUFBVSxpQ0FBaUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFlBQVksZ0NBQWdDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMkJBQTJCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQ0FBbUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLHdDQUF3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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsWUFBWTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGtCQUFrQjtBQUNsRSxpREFBaUQsbUJBQW1CO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsUUFBUTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpQ0FBaUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw0Q0FBNEMsZ0RBQWdEO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxZQUFZO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLCtCQUErQjtBQUM3Qyw0Q0FBNEMsb0NBQW9DO0FBQ2hGO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0NBQXNDO0FBQ2xELDBDQUEwQyxzRUFBc0U7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNkNBQTZDO0FBQzVEO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxvQ0FBb0Msc0VBQXNFO0FBQzFHO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0EsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdFQUFnRTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDhDQUE4QztBQUMxRCxZQUFZLGdEQUFnRDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMkNBQTJDLGdCQUFnQjtBQUMzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLFlBQVksMEJBQTBCO0FBQ3RDO0FBQ0EsNEVBQTRFLHdCQUF3QjtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixLQUFLO0FBQ3hCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEtBQUs7QUFDeEI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsS0FBSztBQUN4QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNEZBQTRGO0FBQ3hHLFlBQVksMEJBQTBCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtEQUErRDtBQUMzRTtBQUNBLDZFQUE2RSxXQUFXO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixvREFBb0Q7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsVUFBVSxRQUFRO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDLG9DQUFvQyxPQUFPO0FBQzNDLHNDQUFzQyxXQUFXO0FBQ2pELHVDQUF1QyxZQUFZO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsU0FBUyxRQUFRLGVBQWU7QUFDOUU7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELE9BQU87QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQ0FBbUM7QUFDMUQ7QUFDQTtBQUNBLHVCQUF1Qix5Q0FBeUM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNDQUFzQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsY0FBYztBQUMzQyxtQ0FBbUMsK0NBQStDO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsNENBQTRDO0FBQzFGLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnREFBZ0Q7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsaUNBQWlDO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3RUFBd0U7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixNQUFNO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCLHlFQUF5RSxZQUFZO0FBQ3JGLHlCQUF5QixNQUFNO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx1RUFBdUU7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQSxxQ0FBcUMscUJBQXFCLGFBQWEscUJBQXFCO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsaUJBQWlCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsMkJBQTJCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFVBQVUsR0FBRztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsVUFBVSxjQUFjLFdBQVcsR0FBRztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlDQUFpQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxZQUFZLDBCQUEwQjtBQUN0QyxZQUFZLDZDQUE2QztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLE9BQU8sS0FBSywwREFBMEQ7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDRDQUE0QztBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFCQUFxQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekIsWUFBWSwyQkFBMkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxpR0FBaUc7QUFDakc7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFdBQVc7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUNBQWlDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsV0FBVztBQUN2RTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlDQUFpQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxREFBcUQ7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE1BQU07QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw4QkFBOEIsK0NBQStDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFCQUFxQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsbUJBQW1CO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxXQUFXO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxXQUFXO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDJCQUEyQjtBQUM3QywyRUFBMkUsSUFBSTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsTUFBTTtBQUNsRSw2QkFBNkIsTUFBTTtBQUNuQyxvQ0FBb0MsWUFBWTtBQUNoRCxPQUFPO0FBQ1A7QUFDQTtBQUNBLDREQUE0RCxnQkFBZ0IsYUFBYTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEtBQUs7QUFDbkI7QUFDQTtBQUNBLDBDQUEwQyxVQUFVO0FBQ3BEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtGQUFrRjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsY0FBYyxNQUFNLFVBQVU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxnQkFBZ0I7QUFDcEQ7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsaUJBQWlCO0FBQ3REO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLG1CQUFtQjtBQUMxRDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxvQkFBb0I7QUFDNUQ7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdUNBQXVDO0FBQ25ELFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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O0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFdBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QixZQUFZLDJCQUEyQjtBQUN2QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCLFlBQVksMkJBQTJCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFdBQVc7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLG9EQUFvRCxlQUFlO0FBQ25FLG9EQUFvRCxnQ0FBZ0M7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELGdCQUFnQjtBQUN6RTtBQUNBO0FBQ0EsNERBQTRELGdCQUFnQjtBQUM1RTs7QUFFQTtBQUNBLDBCQUEwQix3QkFBd0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLFVBQVUsbURBQW1EO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaURBQWlEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnREFBZ0Q7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrQkFBK0I7QUFDM0M7QUFDQSxjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdURBQXVEO0FBQzlFO0FBQ0E7QUFDQSxZQUFZLGlDQUFpQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDJCQUEyQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHVCQUF1QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLDJDQUEyQztBQUNyRDtBQUNBO0FBQ0EsYUFBYSxRQUFRLEdBQUcsTUFBTSxHQUFHLFFBQVEsR0FBRyxNQUFNO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQsVUFBVSw4Q0FBOEM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFLFVBQVUsMkJB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O0FBQ0EsVUFBVSx3QkFBd0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsSUFBSTtBQUNyQyxtQkFBbUI7QUFDbkIsMEVBQTBFLFlBQVksSUFBSSxZQUFZO0FBQ3RHO0FBQ0E7QUFDQSxrQ0FBa0MsSUFBSTtBQUN0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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdEQUFnRDtBQUMxRCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGVBQWU7QUFDeEI7QUFDQSxD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O0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVksZ0JBQWdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLFlBQVksU0FBUztBQUNyQixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsZ0JBQWdCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Qy9CO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxlQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtEQUErRDtBQUMzRSxVQUFVLDZGQUE2RjtBQUN2RyxZQUFZLHVCQUF1QjtBQUNuQyxZQUFZLDJCQUEyQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG9CQUFvQjtBQUNsQztBQUNBO0FBQ0E7QUFDQSxjQUFjLFlBQVk7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxvQkFBb0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpREFBaUQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdCQUFnQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBLDhCQUE4QixnQkFBZ0I7QUFDOUM7QUFDQTtBQUNBLDhCQUE4QixnQkFBZ0I7QUFDOUM7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFFBQVE7QUFDdEMsYUFBYTtBQUNiO0FBQ0EsOEJBQThCLFFBQVE7QUFDdEMsYUFBYTtBQUNiO0FBQ0EseUNBQXlDLGVBQWU7QUFDeEQsVUFBVSxpREFBaUQ7QUFDM0QsVUFBVSxlQUFlO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHdDQUF3QyxVQUFVO0FBQ2xELFVBQVUsaURBQWlEO0FBQzNELFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXLFNBQVMsY0FBYyxpQkFBaUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckIsWUFBWSw4Q0FBOEM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNDQUFzQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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LFlBQVksNkNBQTZDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHlCQUF5QjtBQUNwRCxVQUFVLGlCQUFpQjtBQUMzQixXQUFXLCtCQUErQjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSw4QkFBOEIsZ0JBQWdCO0FBQzlDO0FBQ0E7QUFDQSw4QkFBOEIsZ0JBQWdCO0FBQzlDO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0EsY0FBYyxtQ0FBbUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlCQUF5QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsMERBQTBEO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELDZCQUE2QjtBQUMxRjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxhQUFhO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVksNENBQTRDO0FBQ3hELFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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QUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsMEJBQTBCO0FBQzFCO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDJCQUEyQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSxLQUFLO0FBQ0wsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsMEJBQTBCO0FBQzFCO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFVBQVUsMENBQTBDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx1Q0FBdUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdUJBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOENBQThDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzR0FBc0c7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxRQUFRLFVBQVUsaUJBQWlCO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx1QkFBdUI7QUFDM0IsSUFBSSxjQUFjO0FBQ2xCLElBQUksZUFBZTtBQUNuQixJQUFJLGNBQWM7QUFDbEIsSUFBSSxhQUFhO0FBQ2pCLElBQUksZUFBZTtBQUNuQixJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsMEJBQTBCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLElBQUk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsWUFBWTtBQUMzRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw2Q0FBNkMsWUFBWTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRTtBQUN6RjtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFT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QXVFLCtDQUErQztBQUN0SCx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELG9DQUFvQztBQUNyRjtBQUNBLG1CQUFtQixvQ0FBb0M7QUFDdkQ7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxLQUFLO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVyxFQUFFLFlBQVk7QUFDckM7QUFnQkUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYXdlbG5pZWR6d2llZHovRGVza3RvcC92b3V5LWJ1c2luZXNzL25vZGVfbW9kdWxlcy9hZy1jaGFydHMtY29tbXVuaXR5L2Rpc3QvcGFja2FnZS9tYWluLmVzbS5tanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2RlY29yYXRlQ2xhc3MgPSAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGtpbmQpID0+IHtcbiAgdmFyIHJlc3VsdCA9IGtpbmQgPiAxID8gdm9pZCAwIDoga2luZCA/IF9fZ2V0T3duUHJvcERlc2ModGFyZ2V0LCBrZXkpIDogdGFyZ2V0O1xuICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxLCBkZWNvcmF0b3I7IGkgPj0gMDsgaS0tKVxuICAgIGlmIChkZWNvcmF0b3IgPSBkZWNvcmF0b3JzW2ldKVxuICAgICAgcmVzdWx0ID0gKGtpbmQgPyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHJlc3VsdCkgOiBkZWNvcmF0b3IocmVzdWx0KSkgfHwgcmVzdWx0O1xuICBpZiAoa2luZCAmJiByZXN1bHQpXG4gICAgX19kZWZQcm9wKHRhcmdldCwga2V5LCByZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWxvY2FsZS9zcmMvZW4tVVMudHNcbnZhciBBR19DSEFSVFNfTE9DQUxFX0VOX1VTID0ge1xuICAvLyBTY3JlZW4gcmVhZGVyIGFubm91bmNlbWVudCB3aGVuIGZvY3VzaW5nIGFuIGl0ZW0gaW4gdGhlIGNoYXJ0XG4gIGFyaWFBbm5vdW5jZUhvdmVyRGF0dW06IFwiJHtkYXR1bX1cIixcbiAgLy8gU2NyZWVuIHJlYWRlciBhbm5vdW5jZW1lbnQgd2hlbiBmb2N1c2luZyBhIGNoYXJ0XG4gIGFyaWFBbm5vdW5jZUNoYXJ0OiBcImNoYXJ0LCAke3Nlcmllc0NvdW50fVtudW1iZXJdIHNlcmllc1wiLFxuICAvLyBTY3JlZW4gcmVhZGVyIGFubm91bmNlbWVudCB3aGVuIGZvY3VzaW5nIGEgaGllcmFyY2h5IGNoYXJ0XG4gIGFyaWFBbm5vdW5jZUhpZXJhcmNoeUNoYXJ0OiBcImhpZXJhcmNoeSBjaGFydCwgJHtjYXB0aW9ufVwiLFxuICAvLyBTY3JlZW4gcmVhZGVyIGFubm91bmNlbWVudCB3aGVuIGZvY3VzaW5nIGEgZ2F1Z2UgY2hhcnRcbiAgYXJpYUFubm91bmNlR2F1Z2VDaGFydDogXCJnYXVnZSBjaGFydCwgJHtjYXB0aW9ufVwiLFxuICAvLyBTY3JlZW4gcmVhZGVyIGFubm91bmNlbWVudCB3aGVuIGZvY3VzaW5nIGFuIGl0ZW0gaW4gYSB0cmVlbWFwIG9yIHN1bmJ1cnN0IGNoYXJ0XG4gIGFyaWFBbm5vdW5jZUhpZXJhcmNoeURhdHVtOiBcImxldmVsICR7bGV2ZWx9W251bWJlcl0sICR7Y291bnR9W251bWJlcl0gY2hpbGRyZW4sICR7ZGVzY3JpcHRpb259XCIsXG4gIC8vIFNjcmVlbiByZWFkZXIgYW5ub3VuY2VtZW50IHdoZW4gZm9jdXNpbmcgYSBsaW5rIGluIGEgU2Fua2V5IG9yIGNob3JkIGNoYXJ0XG4gIGFyaWFBbm5vdW5jZUZsb3dQcm9wb3J0aW9uTGluazogXCJsaW5rICR7aW5kZXh9IG9mICR7Y291bnR9LCBmcm9tICR7ZnJvbX0gdG8gJHt0b30sICR7c2l6ZU5hbWV9ICR7c2l6ZX1cIixcbiAgLy8gU2NyZWVuIHJlYWRlciBhbm5vdW5jZW1lbnQgd2hlbiBmb2N1c2luZyBhIG5vZGUgaW4gYSBTYW5rZXkgb3IgY2hvcmQgY2hhcnRcbiAgYXJpYUFubm91bmNlRmxvd1Byb3BvcnRpb25Ob2RlOiBcIm5vZGUgJHtpbmRleH0gb2YgJHtjb3VudH0sICR7ZGVzY3JpcHRpb259XCIsXG4gIC8vIFNjcmVlbiByZWFkZXIgZGVzY3JpcHRpb24gZm9yIGxlZ2VuZCBpdGVtc1xuICBhcmlhRGVzY3JpcHRpb25MZWdlbmRJdGVtOiBcIlByZXNzIFNwYWNlIG9yIEVudGVyIHRvIHRvZ2dsZSB2aXNpYmlsaXR5XCIsXG4gIC8vIFNjcmVlbiByZWFkZXIgdGV4dCBmb3IgYW5ub3RhdGlvbi1vcHRpb25zIHRvb2xiYXJcbiAgYXJpYUxhYmVsQW5ub3RhdGlvbk9wdGlvbnNUb29sYmFyOiBcIkFubm90YXRpb24gT3B0aW9uc1wiLFxuICAvLyBTY3JlZW4gcmVhZGVyIHRleHQgZm9yIGFubm90YXRpb24tc2V0dGluZ3MgZGlhbG9nXG4gIGFyaWFMYWJlbEFubm90YXRpb25TZXR0aW5nc0RpYWxvZzogXCJBbm5vdGF0aW9uIFNldHRpbmdzXCIsXG4gIC8vIFNjcmVlbiByZWFkZXIgdGV4dCBmb3IgdGhlIGNvbG9yIHBpY2tlciBkaWFsb2dcbiAgYXJpYUxhYmVsQ29sb3JQaWNrZXI6IFwiQ29sb3IgcGlja2VyXCIsXG4gIC8vIFNjcmVlbiByZWFkZXIgdGV4dCBmb3IgdGhlIGZpbmFuY2lhbCBjaGFydHMgdG9vbGJhclxuICBhcmlhTGFiZWxGaW5hbmNpYWxDaGFydHM6IFwiRmluYW5jaWFsIENoYXJ0c1wiLFxuICAvLyBTY3JlZW4gcmVhZGVyIHRleHQgZm9yIHRoZSBsZWdlbmQgdG9vbGJhclxuICBhcmlhTGFiZWxMZWdlbmQ6IFwiTGVnZW5kXCIsXG4gIC8vIFNjcmVlbiByZWFkZXIgdGV4dCBmb3IgdGhlIGxlZ2VuZCBwYWdpbmF0aW9uIGJ1dHRvblxuICBhcmlhTGFiZWxMZWdlbmRQYWdpbmF0aW9uOiBcIkxlZ2VuZCBQYWdpbmF0aW9uXCIsXG4gIC8vIFNjcmVlbiByZWFkZXIgdGV4dCBmb3IgdGhlIHByZXZpb3VzIGxlZ2VuZCBwYWdlIGJ1dHRvblxuICBhcmlhTGFiZWxMZWdlbmRQYWdlUHJldmlvdXM6IFwiUHJldmlvdXMgTGVnZW5kIFBhZ2VcIixcbiAgLy8gU2NyZWVuIHJlYWRlciB0ZXh0IGZvciB0aGUgbmV4dCBsZWdlbmQgcGFnZSBidXR0b25cbiAgYXJpYUxhYmVsTGVnZW5kUGFnZU5leHQ6IFwiTmV4dCBMZWdlbmQgUGFnZVwiLFxuICAvLyBTY3JlZW4gcmVhZGVyIHRleHQgZm9yIHRoZSBhbiBpdGVtIGluIHRoZSBsZWdlbmRcbiAgYXJpYUxhYmVsTGVnZW5kSXRlbTogXCIke2xhYmVsfSwgTGVnZW5kIGl0ZW0gJHtpbmRleH1bbnVtYmVyXSBvZiAke2NvdW50fVtudW1iZXJdXCIsXG4gIC8vIFNjcmVlbiByZWFkZXIgdGV4dCBmb3IgdGhlIGFuIHVua25vd24gaXRlbSBpbiB0aGUgbGVnZW5kXG4gIGFyaWFMYWJlbExlZ2VuZEl0ZW1Vbmtub3duOiBcIlVua25vd24gbGVnZW5kIGl0ZW1cIixcbiAgLy8gU2NyZWVuIHJlYWRlciB0ZXh0IGZvciB0aGUgbmF2aWdhdG9yIGVsZW1lbnRcbiAgYXJpYUxhYmVsTmF2aWdhdG9yOiBcIk5hdmlnYXRvclwiLFxuICAvLyBTY3JlZW4gcmVhZGVyIHRleHQgZm9yIGFuIGFjY2Vzc2liaWxpdHkgY29udHJvbCB0aGF0IGNoYW5nZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBuYXZpZ2F0b3IncyByYW5nZVxuICBhcmlhTGFiZWxOYXZpZ2F0b3JSYW5nZTogXCJSYW5nZVwiLFxuICAvLyBTY3JlZW4gcmVhZGVyIHRleHQgZm9yIGFuIGFjY2Vzc2liaWxpdHkgY29udHJvbCB0aGF0IGNoYW5nZXMgdGhlIHN0YXJ0IG9mIHRoZSBuYXZpZ2F0b3IncyByYW5nZVxuICBhcmlhTGFiZWxOYXZpZ2F0b3JNaW5pbXVtOiBcIk1pbmltdW1cIixcbiAgLy8gU2NyZWVuIHJlYWRlciB0ZXh0IGZvciBhbiBhY2Nlc3NpYmlsaXR5IGNvbnRyb2wgdGhhdCBjaGFuZ2VzIHRoZSBlbmQgb2YgdGhlIG5hdmlnYXRvcidzIHJhbmdlXG4gIGFyaWFMYWJlbE5hdmlnYXRvck1heGltdW06IFwiTWF4aW11bVwiLFxuICAvLyBTY3JlZW4gcmVhZGVyIHRleHQgZm9yIHJhbmdlcyB0b29sYmFyXG4gIGFyaWFMYWJlbFJhbmdlc1Rvb2xiYXI6IFwiUmFuZ2VzXCIsXG4gIC8vIFNjcmVlbiByZWFkZXIgdGV4dCBmb3IgdGhlIHNldHRpbmdzIGRpYWxvZyB0YWItYmFyXG4gIGFyaWFMYWJlbFNldHRpbmdzVGFiQmFyOiBcIlNldHRpbmdzXCIsXG4gIC8vIFNjcmVlbiByZWFkZXIgdGV4dCBmb3Igem9vbSB0b29sYmFyXG4gIGFyaWFMYWJlbFpvb21Ub29sYmFyOiBcIlpvb21cIixcbiAgLy8gU2NyZWVuIHJlYWRlciB0ZXh0IGZvciB0aGUgdmFsdWUgb2YgdGhlIG5hdmlnYXRvcidzIHJhbmdlXG4gIGFyaWFWYWx1ZVBhblJhbmdlOiBcIiR7bWlufVtwZXJjZW50XSB0byAke21heH1bcGVyY2VudF1cIixcbiAgLy8gQWx0LXRleHQgZm9yIHRoZSBzb2xpZCBsaW5lIGRhc2ggc3R5bGUgbWVudSBpdGVtIGljb25cbiAgaWNvbkFsdFRleHRMaW5lU3R5bGVTb2xpZDogXCJTb2xpZFwiLFxuICAvLyBBbHQtdGV4dCBmb3IgdGhlIGxvbmctZGFzaGVkIGxpbmUgZGFzaCBzdHlsZSBtZW51IGl0ZW0gaWNvblxuICBpY29uQWx0VGV4dExpbmVTdHlsZURhc2hlZDogXCJMb25nLWRhc2hlZFwiLFxuICAvLyBBbHQtdGV4dCBmb3IgdGhlIHNob3J0LWRhc2hlZCBsaW5lIGRhc2ggc3R5bGUgbWVudSBpdGVtIGljb25cbiAgaWNvbkFsdFRleHRMaW5lU3R5bGVEb3R0ZWQ6IFwiU2hvcnQtZGFzaGVkXCIsXG4gIC8vIEFsdC10ZXh0IGZvciB0aGUgJ3Bvc2l0aW9uLXRvcCcgaWNvblxuICBpY29uQWx0VGV4dFBvc2l0aW9uVG9wOiBcIlRvcFwiLFxuICAvLyBBbHQtdGV4dCBmb3IgdGhlICdwb3NpdGlvbi1jZW50ZXInIGljb25cbiAgaWNvbkFsdFRleHRQb3NpdGlvbkNlbnRlcjogXCJDZW50ZXJcIixcbiAgLy8gQWx0LXRleHQgZm9yIHRoZSAncG9zaXRpb24tYm90dG9tJyBpY29uXG4gIGljb25BbHRUZXh0UG9zaXRpb25Cb3R0b206IFwiQm90dG9tXCIsXG4gIC8vIEFsdC10ZXh0IGZvciB0aGUgJ3Bvc2l0aW9uLWxlZnQnIGljb25cbiAgaWNvbkFsdFRleHRBbGlnbkxlZnQ6IFwiTGVmdFwiLFxuICAvLyBBbHQtdGV4dCBmb3IgdGhlICdhbGlnbi1jZW50ZXInIGljb25cbiAgaWNvbkFsdFRleHRBbGlnbkNlbnRlcjogXCJDZW50ZXJcIixcbiAgLy8gQWx0LXRleHQgZm9yIHRoZSAncG9zaXRpb24tcmlnaHQnIGljb25cbiAgaWNvbkFsdFRleHRBbGlnblJpZ2h0OiBcIlJpZ2h0XCIsXG4gIC8vIEFsdC10ZXh0IGZvciB0aGUgJ2Nsb3NlJyBpY29uXG4gIGljb25BbHRUZXh0Q2xvc2U6IFwiQ2xvc2VcIixcbiAgLy8gRGVmYXVsdCB0ZXh0IGZvciB0aGUgJ2xvYWRpbmcgZGF0YScgb3ZlcmxheVxuICBvdmVybGF5TG9hZGluZ0RhdGE6IFwiTG9hZGluZyBkYXRhLi4uXCIsXG4gIC8vIERlZmF1bHQgdGV4dCBmb3IgdGhlICdubyBkYXRhJyBvdmVybGF5XG4gIG92ZXJsYXlOb0RhdGE6IFwiTm8gZGF0YSB0byBkaXNwbGF5XCIsXG4gIC8vIERlZmF1bHQgdGV4dCBmb3IgdGhlICdubyB2aXNpYmxlIHNlcmllcycgb3ZlcmxheVxuICBvdmVybGF5Tm9WaXNpYmxlU2VyaWVzOiBcIk5vIHZpc2libGUgc2VyaWVzXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBzZXJpZXMgdHlwZSB0b29sYmFyJ3MgY2hhcnQgdHlwZSBidXR0b25cbiAgdG9vbGJhclNlcmllc1R5cGVEcm9wZG93bjogXCJDaGFydCBUeXBlXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBzZXJpZXMgdHlwZSB0b29sYmFyJ3MgT0hMQyBjaGFydCB0eXBlIGJ1dHRvblxuICB0b29sYmFyU2VyaWVzVHlwZU9ITEM6IFwiT0hMQ1wiLFxuICAvLyBUZXh0IGZvciB0aGUgc2VyaWVzIHR5cGUgdG9vbGJhcidzIEhMQyBjaGFydCB0eXBlIGJ1dHRvblxuICB0b29sYmFyU2VyaWVzVHlwZUhMQzogXCJITENcIixcbiAgLy8gVGV4dCBmb3IgdGhlIHNlcmllcyB0eXBlIHRvb2xiYXIncyBoaWdoIGxvdyBjaGFydCB0eXBlIGJ1dHRvblxuICB0b29sYmFyU2VyaWVzVHlwZUhpZ2hMb3c6IFwiSGlnaCBMb3dcIixcbiAgLy8gVGV4dCBmb3IgdGhlIHNlcmllcyB0eXBlIHRvb2xiYXIncyBjYW5kbGVzIGNoYXJ0IHR5cGUgYnV0dG9uXG4gIHRvb2xiYXJTZXJpZXNUeXBlQ2FuZGxlczogXCJDYW5kbGVzXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBzZXJpZXMgdHlwZSB0b29sYmFyJ3MgaG9sbG93IGNhbmRsZXMgY2hhcnQgdHlwZSBidXR0b25cbiAgdG9vbGJhclNlcmllc1R5cGVIb2xsb3dDYW5kbGVzOiBcIkhvbGxvdyBDYW5kbGVzXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBzZXJpZXMgdHlwZSB0b29sYmFyJ3MgbGluZSBjaGFydCB0eXBlIGJ1dHRvblxuICB0b29sYmFyU2VyaWVzVHlwZUxpbmU6IFwiTGluZVwiLFxuICAvLyBUZXh0IGZvciB0aGUgc2VyaWVzIHR5cGUgdG9vbGJhcidzIGxpbmUgd2l0aCBtYXJrZXJzIGNoYXJ0IHR5cGUgYnV0dG9uXG4gIHRvb2xiYXJTZXJpZXNUeXBlTGluZVdpdGhNYXJrZXJzOiBcIkxpbmUgd2l0aCBNYXJrZXJzXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBzZXJpZXMgdHlwZSB0b29sYmFyJ3MgbGluZSB3aXRoIHN0ZXAgbGluZSBjaGFydCB0eXBlIGJ1dHRvblxuICB0b29sYmFyU2VyaWVzVHlwZVN0ZXBMaW5lOiBcIlN0ZXAgTGluZVwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiB0b29sYmFyJ3MgdHJlbmQgbGluZSBidXR0b25cbiAgdG9vbGJhckFubm90YXRpb25zVHJlbmRMaW5lOiBcIlRyZW5kIExpbmVcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIGhvcml6b250YWwgbGluZSBidXR0b25cbiAgdG9vbGJhckFubm90YXRpb25zSG9yaXpvbnRhbExpbmU6IFwiSG9yaXpvbnRhbCBMaW5lXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIHRvb2xiYXIncyB2ZXJ0aWNhbCBsaW5lIGJ1dHRvblxuICB0b29sYmFyQW5ub3RhdGlvbnNWZXJ0aWNhbExpbmU6IFwiVmVydGljYWwgTGluZVwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiB0b29sYmFyJ3MgcGFyYWxsZWwgY2hhbm5lbCBidXR0b25cbiAgdG9vbGJhckFubm90YXRpb25zUGFyYWxsZWxDaGFubmVsOiBcIlBhcmFsbGVsIENoYW5uZWxcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIGRpc2pvaW50IGNoYW5uZWwgYnV0dG9uXG4gIHRvb2xiYXJBbm5vdGF0aW9uc0Rpc2pvaW50Q2hhbm5lbDogXCJEaXNqb2ludCBDaGFubmVsXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIHRvb2xiYXIncyBjbGVhciBhbGwgYnV0dG9uXG4gIHRvb2xiYXJBbm5vdGF0aW9uc0NsZWFyQWxsOiBcIkNsZWFyIEFsbFwiLFxuICAvKipcbiAgICogVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIGNvbG9yIHBpY2tlciBhbm5vdGF0aW9uIGJ1dHRvblxuICAgKiBAZGVwcmVjYXRlZCB2MTAuMS4wIHVzZSBgdG9vbGJhckFubm90YXRpb25zTGluZUNvbG9yYCBpbnN0ZWFkLlxuICAgKi9cbiAgdG9vbGJhckFubm90YXRpb25zQ29sb3I6IFwiQ29sb3JcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIGZpbGwgY29sb3IgcGlja2VyIGFubm90YXRpb24gYnV0dG9uXG4gIHRvb2xiYXJBbm5vdGF0aW9uc0ZpbGxDb2xvcjogXCJGaWxsIENvbG9yXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIHRvb2xiYXIncyBsaW5lIGNvbG9yIHBpY2tlciBhbm5vdGF0aW9uIGJ1dHRvblxuICB0b29sYmFyQW5ub3RhdGlvbnNMaW5lQ29sb3I6IFwiTGluZSBDb2xvclwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiB0b29sYmFyJ3MgbGluZSBzdHlsZSB0eXBlIGJ1dHRvblxuICB0b29sYmFyQW5ub3RhdGlvbnNMaW5lU3R5bGU6IFwiTGluZSBTdHlsZVwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiB0b29sYmFyJ3MgbGluZSBzdHJva2Ugd2lkdGggYnV0dG9uXG4gIHRvb2xiYXJBbm5vdGF0aW9uc0xpbmVTdHJva2VXaWR0aDogXCJMaW5lIFN0cm9rZSBXaWR0aFwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiB0b29sYmFyJ3Mgc2V0dGluZ3MgYW5ub3RhdGlvbiBidXR0b25cbiAgdG9vbGJhckFubm90YXRpb25zU2V0dGluZ3M6IFwiU2V0dGluZ3NcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIHRleHQgY29sb3IgcGlja2VyIGFubm90YXRpb24gYnV0dG9uXG4gIHRvb2xiYXJBbm5vdGF0aW9uc1RleHRDb2xvcjogXCJUZXh0IENvbG9yXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIHRvb2xiYXIncyB0ZXh0IHNpemUgcGlja2VyIGFubm90YXRpb24gYnV0dG9uXG4gIHRvb2xiYXJBbm5vdGF0aW9uc1RleHRTaXplOiBcIlRleHQgU2l6ZVwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiB0b29sYmFyJ3MgbG9jayBhbm5vdGF0aW9uIGJ1dHRvblxuICB0b29sYmFyQW5ub3RhdGlvbnNMb2NrOiBcIkxvY2tcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIHVubG9jayBhbm5vdGF0aW9uIGJ1dHRvblxuICB0b29sYmFyQW5ub3RhdGlvbnNVbmxvY2s6IFwiVW5sb2NrXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIHRvb2xiYXIncyBkZWxldGUgYW5ub3RhdGlvbiBidXR0b25cbiAgdG9vbGJhckFubm90YXRpb25zRGVsZXRlOiBcIkRlbGV0ZVwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiB0b29sYmFyJ3MgZHJhZyBoYW5kbGVcbiAgdG9vbGJhckFubm90YXRpb25zRHJhZ0hhbmRsZTogXCJEcmFnIFRvb2xiYXJcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIGxpbmUgZHJhd2luZ3MgbWVudSBidXR0b25cbiAgdG9vbGJhckFubm90YXRpb25zTGluZUFubm90YXRpb25zOiBcIlRyZW5kIExpbmVzXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIHRvb2xiYXIncyB0ZXh0IGFubm90YXRpb25zIG1lbnUgYnV0dG9uXG4gIHRvb2xiYXJBbm5vdGF0aW9uc1RleHRBbm5vdGF0aW9uczogXCJUZXh0IEFubm90YXRpb25zXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIHRvb2xiYXIncyBzaGFwZXMgbWVudSBidXR0b25cbiAgdG9vbGJhckFubm90YXRpb25zU2hhcGVBbm5vdGF0aW9uczogXCJBcnJvd3NcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIG1lYXN1cmVycyBtZW51IGJ1dHRvblxuICB0b29sYmFyQW5ub3RhdGlvbnNNZWFzdXJlckFubm90YXRpb25zOiBcIk1lYXN1cmVyc1wiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiB0b29sYmFyJ3MgY2FsbG91dCBidXR0b25cbiAgdG9vbGJhckFubm90YXRpb25zQ2FsbG91dDogXCJDYWxsb3V0XCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIHRvb2xiYXIncyBjb21tZW50IGJ1dHRvblxuICB0b29sYmFyQW5ub3RhdGlvbnNDb21tZW50OiBcIkNvbW1lbnRcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIG5vdGUgYnV0dG9uXG4gIHRvb2xiYXJBbm5vdGF0aW9uc05vdGU6IFwiTm90ZVwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiB0b29sYmFyJ3MgdGV4dCBidXR0b25cbiAgdG9vbGJhckFubm90YXRpb25zVGV4dDogXCJUZXh0XCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIHRvb2xiYXIncyBhcnJvdyBidXR0b25cbiAgdG9vbGJhckFubm90YXRpb25zQXJyb3c6IFwiQXJyb3dcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIGFycm93IHVwIGJ1dHRvblxuICB0b29sYmFyQW5ub3RhdGlvbnNBcnJvd1VwOiBcIkFycm93IFVwXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIHRvb2xiYXIncyBhcnJvdyBkb3duIGJ1dHRvblxuICB0b29sYmFyQW5ub3RhdGlvbnNBcnJvd0Rvd246IFwiQXJyb3cgRG93blwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiB0b29sYmFyJ3MgZGF0ZSByYW5nZSBidXR0b25cbiAgdG9vbGJhckFubm90YXRpb25zRGF0ZVJhbmdlOiBcIkRhdGUgUmFuZ2VcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIHByaWNlIHJhbmdlIGJ1dHRvblxuICB0b29sYmFyQW5ub3RhdGlvbnNQcmljZVJhbmdlOiBcIlByaWNlIFJhbmdlXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIHRvb2xiYXIncyBkYXRlIGFuZCBwcmljZSByYW5nZSBidXR0b25cbiAgdG9vbGJhckFubm90YXRpb25zRGF0ZVByaWNlUmFuZ2U6IFwiRGF0ZSBhbmQgUHJpY2VcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIHF1aWNrIGRhdGUgYW5kIHByaWNlIHJhbmdlIGJ1dHRvblxuICB0b29sYmFyQW5ub3RhdGlvbnNRdWlja0RhdGVQcmljZVJhbmdlOiBcIk1lYXN1cmVcIixcbiAgLy8gVGV4dCBmb3IgdGhlIHJhbmdlIHRvb2xiYXIncyAxIG1vbnRoIGJ1dHRvblxuICB0b29sYmFyUmFuZ2UxTW9udGg6IFwiMU1cIixcbiAgLy8gQXJpYSBsYWJlbCBmb3IgdGhlIHJhbmdlIHRvb2xiYXIncyAxIG1vbnRoIGJ1dHRvblxuICB0b29sYmFyUmFuZ2UxTW9udGhBcmlhOiBcIjEgbW9udGhcIixcbiAgLy8gVGV4dCBmb3IgdGhlIHJhbmdlIHRvb2xiYXIncyAzIG1vbnRoIGJ1dHRvblxuICB0b29sYmFyUmFuZ2UzTW9udGhzOiBcIjNNXCIsXG4gIC8vIEFyaWEgbGFiZWwgZm9yIHRoZSByYW5nZSB0b29sYmFyJ3MgMyBtb250aCBidXR0b25cbiAgdG9vbGJhclJhbmdlM01vbnRoc0FyaWE6IFwiMyBtb250aHNcIixcbiAgLy8gVGV4dCBmb3IgdGhlIHJhbmdlIHRvb2xiYXIncyA2IG1vbnRoIGJ1dHRvblxuICB0b29sYmFyUmFuZ2U2TW9udGhzOiBcIjZNXCIsXG4gIC8vIEFyaWEgbGFiZWwgZm9yIHRoZSByYW5nZSB0b29sYmFyJ3MgNiBtb250aCBidXR0b25cbiAgdG9vbGJhclJhbmdlNk1vbnRoc0FyaWE6IFwiNiBtb250aHNcIixcbiAgLy8gVGV4dCBmb3IgdGhlIHJhbmdlIHRvb2xiYXIncyB5ZWFyIHRvIGRhdGUgYnV0dG9uXG4gIHRvb2xiYXJSYW5nZVllYXJUb0RhdGU6IFwiWVREXCIsXG4gIC8vIEFyaWEgbGFiZWwgZm9yIHRoZSByYW5nZSB0b29sYmFyJ3MgeWVhciB0byBkYXRlIG1vbnRoIGJ1dHRvblxuICB0b29sYmFyUmFuZ2VZZWFyVG9EYXRlQXJpYTogXCJZZWFyIHRvIGRhdGVcIixcbiAgLy8gVGV4dCBmb3IgdGhlIHJhbmdlIHRvb2xiYXIncyAxIHllYXIgYnV0dG9uXG4gIHRvb2xiYXJSYW5nZTFZZWFyOiBcIjFZXCIsXG4gIC8vIEFyaWEgbGFiZWwgZm9yIHRoZSByYW5nZSB0b29sYmFyJ3MgMSB5ZWFyIGJ1dHRvblxuICB0b29sYmFyUmFuZ2UxWWVhckFyaWE6IFwiMSB5ZWFyXCIsXG4gIC8vIFRleHQgZm9yIHRoZSByYW5nZSB0b29sYmFyJ3MgZnVsbCByYW5nZSBidXR0b25cbiAgdG9vbGJhclJhbmdlQWxsOiBcIkFsbFwiLFxuICAvLyBBcmlhIGxhYmVsIGZvciB0aGUgcmFuZ2UgdG9vbGJhcidzIGZ1bGwgcmFuZ2UgYnV0dG9uXG4gIHRvb2xiYXJSYW5nZUFsbEFyaWE6IFwiQWxsXCIsXG4gIC8vIFRleHQgZm9yIHRoZSB6b29tIHRvb2xiYXIncyB6b29tIG91dCBidXR0b25cbiAgdG9vbGJhclpvb21ab29tT3V0OiBcIlpvb20gb3V0XCIsXG4gIC8vIFRleHQgZm9yIHRoZSB6b29tIHRvb2xiYXIncyB6b29tIGluIGJ1dHRvblxuICB0b29sYmFyWm9vbVpvb21JbjogXCJab29tIGluXCIsXG4gIC8vIFRleHQgZm9yIHRoZSB6b29tIHRvb2xiYXIncyBwYW4gbGVmdCBidXR0b25cbiAgdG9vbGJhclpvb21QYW5MZWZ0OiBcIlBhbiBsZWZ0XCIsXG4gIC8vIFRleHQgZm9yIHRoZSB6b29tIHRvb2xiYXIncyBwYW4gcmlnaHQgYnV0dG9uXG4gIHRvb2xiYXJab29tUGFuUmlnaHQ6IFwiUGFuIHJpZ2h0XCIsXG4gIC8vIFRleHQgZm9yIHRoZSB6b29tIHRvb2xiYXIncyBwYW4gdG8gdGhlIHN0YXJ0IGJ1dHRvblxuICB0b29sYmFyWm9vbVBhblN0YXJ0OiBcIlBhbiB0byB0aGUgc3RhcnRcIixcbiAgLy8gVGV4dCBmb3IgdGhlIHpvb20gdG9vbGJhcidzIHBhbiB0byB0aGUgZW5kIGJ1dHRvblxuICB0b29sYmFyWm9vbVBhbkVuZDogXCJQYW4gdG8gdGhlIGVuZFwiLFxuICAvLyBUZXh0IGZvciB0aGUgem9vbSB0b29sYmFyJ3MgcGFuIHJlc2V0IGJ1dHRvblxuICB0b29sYmFyWm9vbVJlc2V0OiBcIlJlc2V0IHRoZSB6b29tXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBjb250ZXh0IG1lbnUncyBkb3dubG9hZCBidXR0b25cbiAgY29udGV4dE1lbnVEb3dubG9hZDogXCJEb3dubG9hZFwiLFxuICAvLyBUZXh0IGZvciB0aGUgY29udGV4dCBtZW51J3MgdG9nZ2xlIHNlcmllcyB2aXNpYmlsaXR5IGJ1dHRvblxuICBjb250ZXh0TWVudVRvZ2dsZVNlcmllc1Zpc2liaWxpdHk6IFwiVG9nZ2xlIFZpc2liaWxpdHlcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGNvbnRleHQgbWVudSdzIHRvZ2dsZSBvdGhlciBzZXJpZXMgdmlzaWJpbGl0eSBidXR0b25cbiAgY29udGV4dE1lbnVUb2dnbGVPdGhlclNlcmllczogXCJUb2dnbGUgT3RoZXIgU2VyaWVzXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBjb250ZXh0IG1lbnUncyB6b29tIHRvIHBvaW50IGJ1dHRvblxuICBjb250ZXh0TWVudVpvb21Ub0N1cnNvcjogXCJab29tIHRvIGhlcmVcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGNvbnRleHQgbWVudSdzIHBhbiB0byBwb2ludCBidXR0b25cbiAgY29udGV4dE1lbnVQYW5Ub0N1cnNvcjogXCJQYW4gdG8gaGVyZVwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiBkaWFsb2cncyBoZWFkZXIgY2hhbm5lbCB0YWIgbGFiZWxcbiAgZGlhbG9nSGVhZGVyQ2hhbm5lbDogXCJDaGFubmVsXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIGRpYWxvZydzIGhlYWRlciBsaW5lIHRhYiBsYWJlbFxuICBkaWFsb2dIZWFkZXJMaW5lOiBcIkxpbmVcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gZGlhbG9nJ3MgaGVhZGVyIGRhdGUgcmFuZ2UgdGFiIGxhYmVsXG4gIGRpYWxvZ0hlYWRlckRhdGVSYW5nZTogXCJEYXRlIFJhbmdlXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIGRpYWxvZydzIGhlYWRlciBwcmljZSByYW5nZSB0YWIgbGFiZWxcbiAgZGlhbG9nSGVhZGVyUHJpY2VSYW5nZTogXCJQcmljZSBSYW5nZVwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiBkaWFsb2cncyBoZWFkZXIgZGF0ZSBhbmQgcHJpY2UgcmFuZ2UgdGFiIGxhYmVsXG4gIGRpYWxvZ0hlYWRlckRhdGVQcmljZVJhbmdlOiBcIkRhdGUgYW5kIFByaWNlXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIGRpYWxvZydzIGhlYWRlciB0ZXh0IHRhYiBsYWJlbFxuICBkaWFsb2dIZWFkZXJUZXh0OiBcIlRleHRcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gZGlhbG9nJ3MgdGV4dCBhbGlnbm1lbnQgcmFkaW8gbGFiZWxcbiAgZGlhbG9nSW5wdXRBbGlnbjogXCJBbGlnblwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiBkaWFsb2cncyBjb2xvciBwaWNrZXIgbGFiZWxcbiAgZGlhbG9nSW5wdXRDb2xvclBpY2tlcjogXCJDb2xvclwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiBkaWFsb2cncyBjb2xvciBwaWNrZXIgYWx0IHRleHRcbiAgZGlhbG9nSW5wdXRDb2xvclBpY2tlckFsdFRleHQ6IFwiVGV4dCBDb2xvclwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiBkaWFsb2cncyBmaWxsIGNvbG9yIHBpY2tlciBsYWJlbFxuICBkaWFsb2dJbnB1dEZpbGxDb2xvclBpY2tlcjogXCJGaWxsXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIGRpYWxvZydzIGZpbGwgY29sb3IgcGlja2VyIGFsdCB0ZXh0XG4gIGRpYWxvZ0lucHV0RmlsbENvbG9yUGlja2VyQWx0VGV4dDogXCJGaWxsIENvbG9yXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIGRpYWxvZydzIGV4dGVuZCBjaGFubmVsIHN0YXJ0IGNoZWNrYm94XG4gIGRpYWxvZ0lucHV0RXh0ZW5kQ2hhbm5lbFN0YXJ0OiBcIkV4dGVuZCBjaGFubmVsIHN0YXJ0XCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIGRpYWxvZydzIGV4dGVuZCBjaGFubmVsIGVuZCBjaGVja2JveFxuICBkaWFsb2dJbnB1dEV4dGVuZENoYW5uZWxFbmQ6IFwiRXh0ZW5kIGNoYW5uZWwgZW5kXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIGRpYWxvZydzIGV4dGVuZCBsaW5lIHN0YXJ0IGNoZWNrYm94XG4gIGRpYWxvZ0lucHV0RXh0ZW5kTGluZVN0YXJ0OiBcIkV4dGVuZCBsaW5lIHN0YXJ0XCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIGRpYWxvZydzIGV4dGVuZCBsaW5lIGVuZCBjaGVja2JveFxuICBkaWFsb2dJbnB1dEV4dGVuZExpbmVFbmQ6IFwiRXh0ZW5kIGxpbmUgZW5kXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIGRpYWxvZydzIGV4dGVuZCBhYm92ZSBjaGVja2JveFxuICBkaWFsb2dJbnB1dEV4dGVuZEFib3ZlOiBcIkV4dGVuZCBhYm92ZVwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiBkaWFsb2cncyBleHRlbmQgYmVsb3cgY2hlY2tib3hcbiAgZGlhbG9nSW5wdXRFeHRlbmRCZWxvdzogXCJFeHRlbmQgYmVsb3dcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gZGlhbG9nJ3MgZXh0ZW5kIGxlZnQgY2hlY2tib3hcbiAgZGlhbG9nSW5wdXRFeHRlbmRMZWZ0OiBcIkV4dGVuZCBsZWZ0XCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIGRpYWxvZydzIGV4dGVuZCByaWdodCBjaGVja2JveFxuICBkaWFsb2dJbnB1dEV4dGVuZFJpZ2h0OiBcIkV4dGVuZCByaWdodFwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiBkaWFsb2cncyBmb250IHNpemUgc2VsZWN0IGJveCBsYWJlbFxuICBkaWFsb2dJbnB1dEZvbnRTaXplOiBcIlNpemVcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gZGlhbG9nJ3MgZm9udCBzaXplIHNlbGVjdCBib3ggYWx0IHRleHRcbiAgZGlhbG9nSW5wdXRGb250U2l6ZUFsdFRleHQ6IFwiRm9udCBTaXplXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIGRpYWxvZydzIGxpbmUgc3R5bGUgcmFkaW8gbGFiZWxcbiAgZGlhbG9nSW5wdXRMaW5lU3R5bGU6IFwiRGFzaFwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiBkaWFsb2cncyB0ZXh0IHBvc2l0aW9uIHJhZGlvIGxhYmVsXG4gIGRpYWxvZ0lucHV0UG9zaXRpb246IFwiUG9zaXRpb25cIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gZGlhbG9nJ3Mgc3Ryb2tlIHdpZHRoIGxhYmVsXG4gIGRpYWxvZ0lucHV0U3Ryb2tlV2lkdGg6IFwiV2VpZ2h0XCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIGRpYWxvZydzIHN0cm9rZSB3aWR0aCBsYWJlbFxuICBkaWFsb2dJbnB1dFN0cm9rZVdpZHRoQWx0VGV4dDogXCJMaW5lIFdlaWdodFwiLFxuICAvLyBUZXh0IGZvciB0ZXh0IGFyZWEgaW5wdXQgcGxhY2Vob2xkZXJzXG4gIGlucHV0VGV4dGFyZWFQbGFjZWhvbGRlcjogXCJBZGQgVGV4dFwiLFxuICAvLyBUZXh0IGZvciB0aGUgbWVhc3VyZXIgc3RhdGlzdGljcyBkYXRlIHJhbmdlIGJhcnMgdmFsdWVcbiAgbWVhc3VyZXJEYXRlUmFuZ2VCYXJzOiBcIiR7dmFsdWV9W251bWJlcl0gYmFyc1wiLFxuICAvLyBUZXh0IGZvciB0aGUgbWVhc3VyZXIgc3RhdGlzdGljcyBwcmljZSByYW5nZSB2YWx1ZVxuICBtZWFzdXJlclByaWNlUmFuZ2VWYWx1ZTogXCIke3ZhbHVlfVtudW1iZXJdXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBtZWFzdXJlciBzdGF0aXN0aWNzIHByaWNlIHJhbmdlIHBlcmNlbnRhZ2VcbiAgbWVhc3VyZXJQcmljZVJhbmdlUGVyY2VudDogXCIke3ZhbHVlfVtwZXJjZW50XVwiLFxuICAvLyBUZXh0IGZvciB0aGUgbWVhc3VyZXIgc3RhdGlzdGljcyB2b2x1bWUgdmFsdWVcbiAgbWVhc3VyZXJWb2x1bWU6IFwiVm9sICR7dmFsdWV9XCJcbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy10eXBlcy9zcmMvY2hhcnQvZXJyb3JCYXJPcHRpb25zLnRzXG52YXIgQWdFcnJvckJhclN1cHBvcnRlZFNlcmllc1R5cGVzID0gW1wiYmFyXCIsIFwibGluZVwiLCBcInNjYXR0ZXJcIl07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy10eXBlcy9zcmMvY2hhcnQvaWNvbnMudHNcbnZhciBJQ09OU19MRUdBQ1kgPSBbXG4gIFwiZGVsZXRlLWxlZ2FjeVwiLFxuICBcImRpc2pvaW50LWNoYW5uZWxcIixcbiAgXCJkaXNqb2ludC1jaGFubmVsLWxlZ2FjeVwiLFxuICBcImhvcml6b250YWwtbGluZS1sZWdhY3lcIixcbiAgXCJsaW5lLWNvbG9yLWxlZ2FjeVwiLFxuICBcImxvY2tcIixcbiAgXCJsb2NrLWxlZ2FjeVwiLFxuICBcInBhbi1lbmQtbGVnYWN5XCIsXG4gIFwicGFuLWxlZnQtbGVnYWN5XCIsXG4gIFwicGFuLXJpZ2h0LWxlZ2FjeVwiLFxuICBcInBhbi1zdGFydC1sZWdhY3lcIixcbiAgXCJwYXJhbGxlbC1jaGFubmVsXCIsXG4gIFwicGFyYWxsZWwtY2hhbm5lbC1sZWdhY3lcIixcbiAgXCJyZXNldC1sZWdhY3lcIixcbiAgXCJ0cmVuZC1saW5lXCIsXG4gIFwidHJlbmQtbGluZS1sZWdhY3lcIixcbiAgXCJ1bmxvY2tcIixcbiAgXCJ1bmxvY2stbGVnYWN5XCIsXG4gIFwidmVydGljYWwtbGluZVwiLFxuICBcInZlcnRpY2FsLWxpbmUtbGVnYWN5XCIsXG4gIFwiem9vbS1pbi1sZWdhY3lcIixcbiAgXCJ6b29tLWluLWFsdFwiLFxuICBcInpvb20taW4tYWx0LWxlZ2FjeVwiLFxuICBcInpvb20tb3V0LWxlZ2FjeVwiLFxuICBcInpvb20tb3V0LWFsdFwiLFxuICBcInpvb20tb3V0LWFsdC1sZWdhY3lcIlxuXTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLXR5cGVzL3NyYy9jaGFydC9uYXZpZ2F0b3JPcHRpb25zLnRzXG52YXIgX19NSU5JX0NIQVJUX1NFUklFU19PUFRJT05TID0gdm9pZCAwO1xudmFyIF9fVkVSSUZZX01JTklfQ0hBUlRfU0VSSUVTX09QVElPTlMgPSB2b2lkIDA7XG5fX1ZFUklGWV9NSU5JX0NIQVJUX1NFUklFU19PUFRJT05TID0gX19NSU5JX0NIQVJUX1NFUklFU19PUFRJT05TO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtdHlwZXMvc3JjL2NoYXJ0L3RoZW1lT3B0aW9ucy50c1xudmFyIF9fVEhFTUVfT1ZFUlJJREVTID0gdm9pZCAwO1xudmFyIF9fVkVSSUZZX1RIRU1FX09WRVJSSURFUyA9IHZvaWQgMDtcbl9fVkVSSUZZX1RIRU1FX09WRVJSSURFUyA9IF9fVEhFTUVfT1ZFUlJJREVTO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtdHlwZXMvc3JjL2NoYXJ0L3Rvb2x0aXBPcHRpb25zLnRzXG52YXIgQWdUb29sdGlwUG9zaXRpb25UeXBlID0gLyogQF9fUFVSRV9fICovICgoQWdUb29sdGlwUG9zaXRpb25UeXBlMikgPT4ge1xuICBBZ1Rvb2x0aXBQb3NpdGlvblR5cGUyW1wiUE9JTlRFUlwiXSA9IFwicG9pbnRlclwiO1xuICBBZ1Rvb2x0aXBQb3NpdGlvblR5cGUyW1wiTk9ERVwiXSA9IFwibm9kZVwiO1xuICBBZ1Rvb2x0aXBQb3NpdGlvblR5cGUyW1wiVE9QXCJdID0gXCJ0b3BcIjtcbiAgQWdUb29sdGlwUG9zaXRpb25UeXBlMltcIlJJR0hUXCJdID0gXCJyaWdodFwiO1xuICBBZ1Rvb2x0aXBQb3NpdGlvblR5cGUyW1wiQk9UVE9NXCJdID0gXCJib3R0b21cIjtcbiAgQWdUb29sdGlwUG9zaXRpb25UeXBlMltcIkxFRlRcIl0gPSBcImxlZnRcIjtcbiAgQWdUb29sdGlwUG9zaXRpb25UeXBlMltcIlRPUF9MRUZUXCJdID0gXCJ0b3AtbGVmdFwiO1xuICBBZ1Rvb2x0aXBQb3NpdGlvblR5cGUyW1wiVE9QX1JJR0hUXCJdID0gXCJ0b3AtcmlnaHRcIjtcbiAgQWdUb29sdGlwUG9zaXRpb25UeXBlMltcIkJPVFRPTV9SSUdIVFwiXSA9IFwiYm90dG9tLXJpZ2h0XCI7XG4gIEFnVG9vbHRpcFBvc2l0aW9uVHlwZTJbXCJCT1RUT01fTEVGVFwiXSA9IFwiYm90dG9tLWxlZnRcIjtcbiAgcmV0dXJuIEFnVG9vbHRpcFBvc2l0aW9uVHlwZTI7XG59KShBZ1Rvb2x0aXBQb3NpdGlvblR5cGUgfHwge30pO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtdHlwZXMvc3JjL3ByZXNldHMvZ2F1Z2UvY29tbW9uT3B0aW9ucy50c1xudmFyIF9fVEhFTUVBQkxFX09QVElPTlMgPSB2b2lkIDA7XG52YXIgX19WRVJJRllfVEhFTUVBQkxFX09QVElPTlMgPSB2b2lkIDA7XG5fX1ZFUklGWV9USEVNRUFCTEVfT1BUSU9OUyA9IF9fVEhFTUVBQkxFX09QVElPTlM7XG52YXIgX19BWElTX0xBQkVMX09QVElPTlMgPSB2b2lkIDA7XG52YXIgX19WRVJJRllfQVhJU19MQUJFTF9PUFRJT05TID0gdm9pZCAwO1xuX19WRVJJRllfQVhJU19MQUJFTF9PUFRJT05TID0gX19BWElTX0xBQkVMX09QVElPTlM7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvdGltZS9pbmRleC50c1xudmFyIHRpbWVfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodGltZV9leHBvcnRzLCB7XG4gIFRpbWVJbnRlcnZhbDogKCkgPT4gVGltZUludGVydmFsLFxuICBkYXk6ICgpID0+IGRheSxcbiAgZnJpZGF5OiAoKSA9PiBmcmlkYXksXG4gIGhvdXI6ICgpID0+IGhvdXIsXG4gIG1pbGxpc2Vjb25kOiAoKSA9PiBtaWxsaXNlY29uZCxcbiAgbWludXRlOiAoKSA9PiBtaW51dGUsXG4gIG1vbmRheTogKCkgPT4gbW9uZGF5LFxuICBtb250aDogKCkgPT4gbW9udGgsXG4gIHNhdHVyZGF5OiAoKSA9PiBzYXR1cmRheSxcbiAgc2Vjb25kOiAoKSA9PiBzZWNvbmQsXG4gIHN1bmRheTogKCkgPT4gc3VuZGF5LFxuICB0aHVyc2RheTogKCkgPT4gdGh1cnNkYXksXG4gIHR1ZXNkYXk6ICgpID0+IHR1ZXNkYXksXG4gIHV0Y0RheTogKCkgPT4gdXRjRGF5LFxuICB1dGNIb3VyOiAoKSA9PiB1dGNIb3VyLFxuICB1dGNNaW51dGU6ICgpID0+IHV0Y01pbnV0ZSxcbiAgdXRjTW9udGg6ICgpID0+IHV0Y01vbnRoLFxuICB1dGNZZWFyOiAoKSA9PiB1dGNZZWFyLFxuICB3ZWRuZXNkYXk6ICgpID0+IHdlZG5lc2RheSxcbiAgeWVhcjogKCkgPT4geWVhclxufSk7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvZnVuY3Rpb24udHNcbnZhciBkb09uY2VTdGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG5mdW5jdGlvbiBkb09uY2UoZnVuYywga2V5KSB7XG4gIGlmIChkb09uY2VTdGF0ZS5oYXMoa2V5KSlcbiAgICByZXR1cm47XG4gIGRvT25jZVN0YXRlLnNldChrZXksIHRydWUpO1xuICBmdW5jKCk7XG59XG5kb09uY2UuY2xlYXIgPSAoKSA9PiBkb09uY2VTdGF0ZS5jbGVhcigpO1xuZnVuY3Rpb24gaWRlbnRpdHkoeCkge1xuICByZXR1cm4geDtcbn1cbmZ1bmN0aW9uIHRocm90dGxlKGNhbGxiYWNrMiwgd2FpdE1zID0gMCwgb3B0aW9ucykge1xuICBjb25zdCB7IGxlYWRpbmcgPSB0cnVlLCB0cmFpbGluZyA9IHRydWUgfSA9IG9wdGlvbnMgPz8ge307XG4gIGxldCB0aW1lcklkO1xuICBsZXQgbGFzdEFyZ3M7XG4gIGxldCBzaG91bGRXYWl0ID0gZmFsc2U7XG4gIGZ1bmN0aW9uIHRpbWVvdXRIYW5kbGVyKCkge1xuICAgIGlmICh0cmFpbGluZyAmJiBsYXN0QXJncykge1xuICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZW91dEhhbmRsZXIsIHdhaXRNcyk7XG4gICAgICBjYWxsYmFjazIoLi4ubGFzdEFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaG91bGRXYWl0ID0gZmFsc2U7XG4gICAgfVxuICAgIGxhc3RBcmdzID0gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiB0aHJvdHRsZUNhbGxiYWNrKC4uLmFyZ3MpIHtcbiAgICBpZiAoc2hvdWxkV2FpdCkge1xuICAgICAgbGFzdEFyZ3MgPSBhcmdzO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaG91bGRXYWl0ID0gdHJ1ZTtcbiAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVvdXRIYW5kbGVyLCB3YWl0TXMpO1xuICAgICAgaWYgKGxlYWRpbmcpIHtcbiAgICAgICAgY2FsbGJhY2syKC4uLmFyZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGFzdEFyZ3MgPSBhcmdzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gT2JqZWN0LmFzc2lnbih0aHJvdHRsZUNhbGxiYWNrLCB7XG4gICAgY2FuY2VsKCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgICAgc2hvdWxkV2FpdCA9IGZhbHNlO1xuICAgICAgbGFzdEFyZ3MgPSBudWxsO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBqb2luRnVuY3Rpb25zKC4uLmZucykge1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGZvciAoY29uc3QgZm4gb2YgZm5zKSB7XG4gICAgICBmbigpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9sb2dnZXIudHNcbnZhciBMb2dnZXIgPSB7XG4gIGxvZyguLi5sb2dDb250ZW50KSB7XG4gICAgY29uc29sZS5sb2coLi4ubG9nQ29udGVudCk7XG4gIH0sXG4gIHdhcm4obWVzc2FnZSwgLi4ubG9nQ29udGVudCkge1xuICAgIGNvbnNvbGUud2FybihgQUcgQ2hhcnRzIC0gJHttZXNzYWdlfWAsIC4uLmxvZ0NvbnRlbnQpO1xuICB9LFxuICBlcnJvcihtZXNzYWdlLCAuLi5sb2dDb250ZW50KSB7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBBRyBDaGFydHMgZXJyb3JgLCBtZXNzYWdlLCAuLi5sb2dDb250ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcihgQUcgQ2hhcnRzIC0gJHttZXNzYWdlfWAsIC4uLmxvZ0NvbnRlbnQpO1xuICAgIH1cbiAgfSxcbiAgdGFibGUoLi4ubG9nQ29udGVudCkge1xuICAgIGNvbnNvbGUudGFibGUoLi4ubG9nQ29udGVudCk7XG4gIH0sXG4gIHdhcm5PbmNlKG1lc3NhZ2UsIC4uLmxvZ0NvbnRlbnQpIHtcbiAgICBkb09uY2UoKCkgPT4gTG9nZ2VyLndhcm4obWVzc2FnZSwgLi4ubG9nQ29udGVudCksIGBMb2dnZXIud2FybjogJHttZXNzYWdlfWApO1xuICB9LFxuICBlcnJvck9uY2UobWVzc2FnZSwgLi4ubG9nQ29udGVudCkge1xuICAgIGRvT25jZSgoKSA9PiBMb2dnZXIuZXJyb3IobWVzc2FnZSwgLi4ubG9nQ29udGVudCksIGBMb2dnZXIuZXJyb3I6ICR7bWVzc2FnZX1gKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC90aW1lL2ludGVydmFsLnRzXG52YXIgVGltZUludGVydmFsID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihfZW5jb2RlLCBfZGVjb2RlLCBfcmFuZ2VDYWxsYmFjaykge1xuICAgIHRoaXMuX2VuY29kZSA9IF9lbmNvZGU7XG4gICAgdGhpcy5fZGVjb2RlID0gX2RlY29kZTtcbiAgICB0aGlzLl9yYW5nZUNhbGxiYWNrID0gX3JhbmdlQ2FsbGJhY2s7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgZGF0ZSByZXByZXNlbnRpbmcgdGhlIGxhdGVzdCBpbnRlcnZhbCBib3VuZGFyeSBkYXRlIGJlZm9yZSBvciBlcXVhbCB0byBkYXRlLlxuICAgKiBGb3IgZXhhbXBsZSwgYGRheS5mbG9vcihkYXRlKWAgdHlwaWNhbGx5IHJldHVybnMgMTI6MDAgQU0gbG9jYWwgdGltZSBvbiB0aGUgZ2l2ZW4gZGF0ZS5cbiAgICogQHBhcmFtIGRhdGVcbiAgICovXG4gIGZsb29yKGRhdGUpIHtcbiAgICBjb25zdCBkID0gbmV3IERhdGUoZGF0ZSk7XG4gICAgY29uc3QgZSA9IHRoaXMuX2VuY29kZShkKTtcbiAgICByZXR1cm4gdGhpcy5fZGVjb2RlKGUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IGRhdGUgcmVwcmVzZW50aW5nIHRoZSBlYXJsaWVzdCBpbnRlcnZhbCBib3VuZGFyeSBkYXRlIGFmdGVyIG9yIGVxdWFsIHRvIGRhdGUuXG4gICAqIEBwYXJhbSBkYXRlXG4gICAqL1xuICBjZWlsKGRhdGUpIHtcbiAgICBjb25zdCBkID0gbmV3IERhdGUoTnVtYmVyKGRhdGUpIC0gMSk7XG4gICAgY29uc3QgZSA9IHRoaXMuX2VuY29kZShkKTtcbiAgICByZXR1cm4gdGhpcy5fZGVjb2RlKGUgKyAxKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiBkYXRlcyByZXByZXNlbnRpbmcgZXZlcnkgaW50ZXJ2YWwgYm91bmRhcnkgYWZ0ZXIgb3IgZXF1YWwgdG8gc3RhcnQgKGluY2x1c2l2ZSkgYW5kIGJlZm9yZSBzdG9wIChleGNsdXNpdmUpLlxuICAgKiBAcGFyYW0gc3RhcnQgUmFuZ2Ugc3RhcnQuXG4gICAqIEBwYXJhbSBzdG9wIFJhbmdlIGVuZC5cbiAgICogQHBhcmFtIGV4dGVuZCBJZiBzcGVjaWZpZWQsIHRoZSByZXF1ZXN0ZWQgcmFuZ2Ugd2lsbCBiZSBleHRlbmRlZCB0byB0aGUgY2xvc2VzdCBcIm5pY2VcIiB2YWx1ZXMuXG4gICAqL1xuICByYW5nZShzdGFydDIsIHN0b3AsIGV4dGVuZCkge1xuICAgIGNvbnN0IHJhbmdlQ2FsbGJhY2sgPSB0aGlzLl9yYW5nZUNhbGxiYWNrPy4oc3RhcnQyLCBzdG9wKTtcbiAgICBjb25zdCBlMCA9IHRoaXMuX2VuY29kZShleHRlbmQgPyB0aGlzLmZsb29yKHN0YXJ0MikgOiB0aGlzLmNlaWwoc3RhcnQyKSk7XG4gICAgY29uc3QgZTEgPSB0aGlzLl9lbmNvZGUoZXh0ZW5kID8gdGhpcy5jZWlsKHN0b3ApIDogdGhpcy5mbG9vcihzdG9wKSk7XG4gICAgaWYgKGUxIDwgZTApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgcmFuZ2UzID0gW107XG4gICAgZm9yIChsZXQgZSA9IGUwOyBlIDw9IGUxOyBlKyspIHtcbiAgICAgIGNvbnN0IGQgPSB0aGlzLl9kZWNvZGUoZSk7XG4gICAgICByYW5nZTMucHVzaChkKTtcbiAgICB9XG4gICAgcmFuZ2VDYWxsYmFjaz8uKCk7XG4gICAgcmV0dXJuIHJhbmdlMztcbiAgfVxufTtcbnZhciBDb3VudGFibGVUaW1lSW50ZXJ2YWwgPSBjbGFzcyBleHRlbmRzIFRpbWVJbnRlcnZhbCB7XG4gIGdldE9mZnNldChzbmFwVG8sIHN0ZXApIHtcbiAgICBjb25zdCBzID0gdHlwZW9mIHNuYXBUbyA9PT0gXCJudW1iZXJcIiB8fCBzbmFwVG8gaW5zdGFuY2VvZiBEYXRlID8gdGhpcy5fZW5jb2RlKG5ldyBEYXRlKHNuYXBUbykpIDogMDtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihzKSAlIHN0ZXA7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBmaWx0ZXJlZCB2aWV3IG9mIHRoaXMgaW50ZXJ2YWwgcmVwcmVzZW50aW5nIGV2ZXJ5IHN0ZXAndGggZGF0ZS5cbiAgICogSXQgY2FuIGJlIGEgbnVtYmVyIG9mIG1pbnV0ZXMsIGhvdXJzLCBkYXlzIGV0Yy5cbiAgICogTXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIuXG4gICAqIEBwYXJhbSBzdGVwXG4gICAqL1xuICBldmVyeShzdGVwLCBvcHRpb25zKSB7XG4gICAgbGV0IG9mZnNldDQgPSAwO1xuICAgIGxldCByYW5nZUNhbGxiYWNrO1xuICAgIGNvbnN0IHVuc2FmZVN0ZXAgPSBzdGVwO1xuICAgIHN0ZXAgPSBNYXRoLm1heCgxLCBNYXRoLnJvdW5kKHN0ZXApKTtcbiAgICBpZiAodW5zYWZlU3RlcCAhPT0gc3RlcCkge1xuICAgICAgTG9nZ2VyLndhcm5PbmNlKGBpbnRlcnZhbCBzdGVwIG9mIFske3Vuc2FmZVN0ZXB9XSByb3VuZGVkIHRvIFske3N0ZXB9XS5gKTtcbiAgICB9XG4gICAgY29uc3QgeyBzbmFwVG8gPSBcInN0YXJ0XCIgfSA9IG9wdGlvbnMgPz8ge307XG4gICAgaWYgKHR5cGVvZiBzbmFwVG8gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnN0IGluaXRpYWxPZmZzZXQgPSBvZmZzZXQ0O1xuICAgICAgcmFuZ2VDYWxsYmFjayA9IChzdGFydDIsIHN0b3ApID0+IHtcbiAgICAgICAgY29uc3QgcyA9IHNuYXBUbyA9PT0gXCJzdGFydFwiID8gc3RhcnQyIDogc3RvcDtcbiAgICAgICAgb2Zmc2V0NCA9IHRoaXMuZ2V0T2Zmc2V0KHMsIHN0ZXApO1xuICAgICAgICByZXR1cm4gKCkgPT4gb2Zmc2V0NCA9IGluaXRpYWxPZmZzZXQ7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNuYXBUbyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgb2Zmc2V0NCA9IHRoaXMuZ2V0T2Zmc2V0KG5ldyBEYXRlKHNuYXBUbyksIHN0ZXApO1xuICAgIH0gZWxzZSBpZiAoc25hcFRvIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgb2Zmc2V0NCA9IHRoaXMuZ2V0T2Zmc2V0KHNuYXBUbywgc3RlcCk7XG4gICAgfVxuICAgIGNvbnN0IGVuY29kZTEzID0gKGRhdGUpID0+IHtcbiAgICAgIGNvbnN0IGUgPSB0aGlzLl9lbmNvZGUoZGF0ZSk7XG4gICAgICByZXR1cm4gTWF0aC5mbG9vcigoZSAtIG9mZnNldDQpIC8gc3RlcCk7XG4gICAgfTtcbiAgICBjb25zdCBkZWNvZGUxMyA9IChlbmNvZGVkKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5fZGVjb2RlKGVuY29kZWQgKiBzdGVwICsgb2Zmc2V0NCk7XG4gICAgfTtcbiAgICByZXR1cm4gbmV3IFRpbWVJbnRlcnZhbChlbmNvZGUxMywgZGVjb2RlMTMsIHJhbmdlQ2FsbGJhY2spO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3RpbWUvbWlsbGlzZWNvbmQudHNcbmZ1bmN0aW9uIGVuY29kZShkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldFRpbWUoKTtcbn1cbmZ1bmN0aW9uIGRlY29kZShlbmNvZGVkKSB7XG4gIHJldHVybiBuZXcgRGF0ZShlbmNvZGVkKTtcbn1cbnZhciBtaWxsaXNlY29uZCA9IG5ldyBDb3VudGFibGVUaW1lSW50ZXJ2YWwoZW5jb2RlLCBkZWNvZGUpO1xudmFyIG1pbGxpc2Vjb25kX2RlZmF1bHQgPSBtaWxsaXNlY29uZDtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC90aW1lL2R1cmF0aW9uLnRzXG52YXIgZXBvY2hZZWFyID0gKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgwKSkuZ2V0RnVsbFllYXIoKTtcbnZhciBkdXJhdGlvblNlY29uZCA9IDFlMztcbnZhciBkdXJhdGlvbk1pbnV0ZSA9IGR1cmF0aW9uU2Vjb25kICogNjA7XG52YXIgZHVyYXRpb25Ib3VyID0gZHVyYXRpb25NaW51dGUgKiA2MDtcbnZhciBkdXJhdGlvbkRheSA9IGR1cmF0aW9uSG91ciAqIDI0O1xudmFyIGR1cmF0aW9uV2VlayA9IGR1cmF0aW9uRGF5ICogNztcbnZhciBkdXJhdGlvbk1vbnRoID0gZHVyYXRpb25EYXkgKiAzMDtcbnZhciBkdXJhdGlvblllYXIgPSBkdXJhdGlvbkRheSAqIDM2NTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC90aW1lL3NlY29uZC50c1xudmFyIG9mZnNldCA9ICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIGR1cmF0aW9uTWludXRlO1xuZnVuY3Rpb24gZW5jb2RlMihkYXRlKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKChkYXRlLmdldFRpbWUoKSAtIG9mZnNldCkgLyBkdXJhdGlvblNlY29uZCk7XG59XG5mdW5jdGlvbiBkZWNvZGUyKGVuY29kZWQpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKG9mZnNldCArIGVuY29kZWQgKiBkdXJhdGlvblNlY29uZCk7XG59XG52YXIgc2Vjb25kID0gbmV3IENvdW50YWJsZVRpbWVJbnRlcnZhbChlbmNvZGUyLCBkZWNvZGUyKTtcbnZhciBzZWNvbmRfZGVmYXVsdCA9IHNlY29uZDtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC90aW1lL21pbnV0ZS50c1xudmFyIG9mZnNldDIgPSAoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLmdldFRpbWV6b25lT2Zmc2V0KCkgKiBkdXJhdGlvbk1pbnV0ZTtcbmZ1bmN0aW9uIGVuY29kZTMoZGF0ZSkge1xuICByZXR1cm4gTWF0aC5mbG9vcigoZGF0ZS5nZXRUaW1lKCkgLSBvZmZzZXQyKSAvIGR1cmF0aW9uTWludXRlKTtcbn1cbmZ1bmN0aW9uIGRlY29kZTMoZW5jb2RlZCkge1xuICByZXR1cm4gbmV3IERhdGUob2Zmc2V0MiArIGVuY29kZWQgKiBkdXJhdGlvbk1pbnV0ZSk7XG59XG52YXIgbWludXRlID0gbmV3IENvdW50YWJsZVRpbWVJbnRlcnZhbChlbmNvZGUzLCBkZWNvZGUzKTtcbnZhciBtaW51dGVfZGVmYXVsdCA9IG1pbnV0ZTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC90aW1lL2hvdXIudHNcbnZhciBvZmZzZXQzID0gKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS5nZXRUaW1lem9uZU9mZnNldCgpICogZHVyYXRpb25NaW51dGU7XG5mdW5jdGlvbiBlbmNvZGU0KGRhdGUpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoKGRhdGUuZ2V0VGltZSgpIC0gb2Zmc2V0MykgLyBkdXJhdGlvbkhvdXIpO1xufVxuZnVuY3Rpb24gZGVjb2RlNChlbmNvZGVkKSB7XG4gIHJldHVybiBuZXcgRGF0ZShvZmZzZXQzICsgZW5jb2RlZCAqIGR1cmF0aW9uSG91cik7XG59XG52YXIgaG91ciA9IG5ldyBDb3VudGFibGVUaW1lSW50ZXJ2YWwoZW5jb2RlNCwgZGVjb2RlNCk7XG52YXIgaG91cl9kZWZhdWx0ID0gaG91cjtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC90aW1lL2RheS50c1xuZnVuY3Rpb24gZW5jb2RlNShkYXRlKSB7XG4gIGNvbnN0IHR6T2Zmc2V0TXMgPSBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgKiBkdXJhdGlvbk1pbnV0ZTtcbiAgcmV0dXJuIE1hdGguZmxvb3IoKGRhdGUuZ2V0VGltZSgpIC0gdHpPZmZzZXRNcykgLyBkdXJhdGlvbkRheSk7XG59XG5mdW5jdGlvbiBkZWNvZGU1KGVuY29kZWQpIHtcbiAgY29uc3QgZCA9IG5ldyBEYXRlKDE5NzAsIDAsIDEpO1xuICBkLnNldERhdGUoZC5nZXREYXRlKCkgKyBlbmNvZGVkKTtcbiAgcmV0dXJuIGQ7XG59XG52YXIgZGF5ID0gbmV3IENvdW50YWJsZVRpbWVJbnRlcnZhbChlbmNvZGU1LCBkZWNvZGU1KTtcbnZhciBkYXlfZGVmYXVsdCA9IGRheTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC90aW1lL3dlZWsudHNcbmZ1bmN0aW9uIHdlZWtkYXkod2Vla1N0YXJ0KSB7XG4gIGNvbnN0IHRodXJzZGF5MiA9IDQ7XG4gIGNvbnN0IGRheVNoaWZ0ID0gKDcgKyB3ZWVrU3RhcnQgLSB0aHVyc2RheTIpICUgNztcbiAgZnVuY3Rpb24gZW5jb2RlMTMoZGF0ZSkge1xuICAgIGNvbnN0IHR6T2Zmc2V0TXMgPSBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgKiBkdXJhdGlvbk1pbnV0ZTtcbiAgICByZXR1cm4gTWF0aC5mbG9vcigoZGF0ZS5nZXRUaW1lKCkgLSB0ek9mZnNldE1zKSAvIGR1cmF0aW9uV2VlayAtIGRheVNoaWZ0IC8gNyk7XG4gIH1cbiAgZnVuY3Rpb24gZGVjb2RlMTMoZW5jb2RlZCkge1xuICAgIGNvbnN0IGQgPSBuZXcgRGF0ZSgxOTcwLCAwLCAxKTtcbiAgICBkLnNldERhdGUoZC5nZXREYXRlKCkgKyBlbmNvZGVkICogNyArIGRheVNoaWZ0KTtcbiAgICByZXR1cm4gZDtcbiAgfVxuICByZXR1cm4gbmV3IENvdW50YWJsZVRpbWVJbnRlcnZhbChlbmNvZGUxMywgZGVjb2RlMTMpO1xufVxudmFyIHN1bmRheSA9IHdlZWtkYXkoMCk7XG52YXIgbW9uZGF5ID0gd2Vla2RheSgxKTtcbnZhciB0dWVzZGF5ID0gd2Vla2RheSgyKTtcbnZhciB3ZWRuZXNkYXkgPSB3ZWVrZGF5KDMpO1xudmFyIHRodXJzZGF5ID0gd2Vla2RheSg0KTtcbnZhciBmcmlkYXkgPSB3ZWVrZGF5KDUpO1xudmFyIHNhdHVyZGF5ID0gd2Vla2RheSg2KTtcbnZhciB3ZWVrX2RlZmF1bHQgPSBzdW5kYXk7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvdGltZS9tb250aC50c1xuZnVuY3Rpb24gZW5jb2RlNihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldEZ1bGxZZWFyKCkgKiAxMiArIGRhdGUuZ2V0TW9udGgoKTtcbn1cbmZ1bmN0aW9uIGRlY29kZTYoZW5jb2RlZCkge1xuICBjb25zdCB5ZWFyMiA9IE1hdGguZmxvb3IoZW5jb2RlZCAvIDEyKTtcbiAgY29uc3QgbW9udGgyID0gZW5jb2RlZCAtIHllYXIyICogMTI7XG4gIHJldHVybiBuZXcgRGF0ZSh5ZWFyMiwgbW9udGgyLCAxKTtcbn1cbnZhciBtb250aCA9IG5ldyBDb3VudGFibGVUaW1lSW50ZXJ2YWwoZW5jb2RlNiwgZGVjb2RlNik7XG52YXIgbW9udGhfZGVmYXVsdCA9IG1vbnRoO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3RpbWUveWVhci50c1xuZnVuY3Rpb24gZW5jb2RlNyhkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldEZ1bGxZZWFyKCk7XG59XG5mdW5jdGlvbiBkZWNvZGU3KGVuY29kZWQpIHtcbiAgY29uc3QgZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICBkLnNldEZ1bGxZZWFyKGVuY29kZWQpO1xuICBkLnNldE1vbnRoKDAsIDEpO1xuICBkLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICByZXR1cm4gZDtcbn1cbnZhciB5ZWFyID0gbmV3IENvdW50YWJsZVRpbWVJbnRlcnZhbChlbmNvZGU3LCBkZWNvZGU3KTtcbnZhciB5ZWFyX2RlZmF1bHQgPSB5ZWFyO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3RpbWUvdXRjTWludXRlLnRzXG5mdW5jdGlvbiBlbmNvZGU4KGRhdGUpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoZGF0ZS5nZXRUaW1lKCkgLyBkdXJhdGlvbk1pbnV0ZSk7XG59XG5mdW5jdGlvbiBkZWNvZGU4KGVuY29kZWQpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKGVuY29kZWQgKiBkdXJhdGlvbk1pbnV0ZSk7XG59XG52YXIgdXRjTWludXRlID0gbmV3IENvdW50YWJsZVRpbWVJbnRlcnZhbChlbmNvZGU4LCBkZWNvZGU4KTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC90aW1lL3V0Y0hvdXIudHNcbmZ1bmN0aW9uIGVuY29kZTkoZGF0ZSkge1xuICByZXR1cm4gTWF0aC5mbG9vcihkYXRlLmdldFRpbWUoKSAvIGR1cmF0aW9uSG91cik7XG59XG5mdW5jdGlvbiBkZWNvZGU5KGVuY29kZWQpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKGVuY29kZWQgKiBkdXJhdGlvbkhvdXIpO1xufVxudmFyIHV0Y0hvdXIgPSBuZXcgQ291bnRhYmxlVGltZUludGVydmFsKGVuY29kZTksIGRlY29kZTkpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3RpbWUvdXRjRGF5LnRzXG5mdW5jdGlvbiBlbmNvZGUxMChkYXRlKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKGRhdGUuZ2V0VGltZSgpIC8gZHVyYXRpb25EYXkpO1xufVxuZnVuY3Rpb24gZGVjb2RlMTAoZW5jb2RlZCkge1xuICBjb25zdCBkID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKDApO1xuICBkLnNldFVUQ0RhdGUoZC5nZXRVVENEYXRlKCkgKyBlbmNvZGVkKTtcbiAgZC5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgcmV0dXJuIGQ7XG59XG52YXIgdXRjRGF5ID0gbmV3IENvdW50YWJsZVRpbWVJbnRlcnZhbChlbmNvZGUxMCwgZGVjb2RlMTApO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3RpbWUvdXRjTW9udGgudHNcbmZ1bmN0aW9uIGVuY29kZTExKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0VVRDRnVsbFllYXIoKSAqIDEyICsgZGF0ZS5nZXRVVENNb250aCgpO1xufVxuZnVuY3Rpb24gZGVjb2RlMTEoZW5jb2RlZCkge1xuICBjb25zdCB5ZWFyMiA9IE1hdGguZmxvb3IoZW5jb2RlZCAvIDEyKTtcbiAgY29uc3QgbW9udGgyID0gZW5jb2RlZCAtIHllYXIyICogMTI7XG4gIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyMiwgbW9udGgyLCAxKSk7XG59XG52YXIgdXRjTW9udGggPSBuZXcgQ291bnRhYmxlVGltZUludGVydmFsKGVuY29kZTExLCBkZWNvZGUxMSk7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvdGltZS91dGNZZWFyLnRzXG5mdW5jdGlvbiBlbmNvZGUxMihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldFVUQ0Z1bGxZZWFyKCk7XG59XG5mdW5jdGlvbiBkZWNvZGUxMihlbmNvZGVkKSB7XG4gIGNvbnN0IGQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgZC5zZXRVVENGdWxsWWVhcihlbmNvZGVkKTtcbiAgZC5zZXRVVENNb250aCgwLCAxKTtcbiAgZC5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgcmV0dXJuIGQ7XG59XG52YXIgdXRjWWVhciA9IG5ldyBDb3VudGFibGVUaW1lSW50ZXJ2YWwoZW5jb2RlMTIsIGRlY29kZTEyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvbW90aW9uL2Zyb21Ub01vdGlvbi50c1xudmFyIGZyb21Ub01vdGlvbl9leHBvcnRzID0ge307XG5fX2V4cG9ydChmcm9tVG9Nb3Rpb25fZXhwb3J0cywge1xuICBOT0RFX1VQREFURV9TVEFURV9UT19QSEFTRV9NQVBQSU5HOiAoKSA9PiBOT0RFX1VQREFURV9TVEFURV9UT19QSEFTRV9NQVBQSU5HLFxuICBmcm9tVG9Nb3Rpb246ICgpID0+IGZyb21Ub01vdGlvbixcbiAgc3RhdGljRnJvbVRvTW90aW9uOiAoKSA9PiBzdGF0aWNGcm9tVG9Nb3Rpb25cbn0pO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2lkLnRzXG52YXIgSURfTUFQID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbmZ1bmN0aW9uIHJlc2V0SWRzKCkge1xuICBJRF9NQVAuY2xlYXIoKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUlkKGluc3RhbmNlKSB7XG4gIGNvbnN0IGNvbnN0cnVjdG9yID0gaW5zdGFuY2UuY29uc3RydWN0b3I7XG4gIGNvbnN0IGNsYXNzTmFtZSA9IE9iamVjdC5oYXNPd24oY29uc3RydWN0b3IsIFwiY2xhc3NOYW1lXCIpID8gY29uc3RydWN0b3IuY2xhc3NOYW1lIDogY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKCFjbGFzc05hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSAke2NvbnN0cnVjdG9yfSBpcyBtaXNzaW5nIHRoZSAnY2xhc3NOYW1lJyBwcm9wZXJ0eS5gKTtcbiAgfVxuICBjb25zdCBuZXh0SWQgPSAoSURfTUFQLmdldChjbGFzc05hbWUpID8/IDApICsgMTtcbiAgSURfTUFQLnNldChjbGFzc05hbWUsIG5leHRJZCk7XG4gIHJldHVybiBgJHtjbGFzc05hbWV9LSR7bmV4dElkfWA7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVVVSUQoKSB7XG4gIHJldHVybiBjcnlwdG8ucmFuZG9tVVVJRD8uKCkgPz8gZ2VuZXJhdGVVVUlEdjQoKTtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVVVJRHY0KCkge1xuICBjb25zdCB1dWlkQXJyYXkgPSBuZXcgVWludDhBcnJheSgxNik7XG4gIGNyeXB0by5nZXRSYW5kb21WYWx1ZXModXVpZEFycmF5KTtcbiAgdXVpZEFycmF5WzZdID0gdXVpZEFycmF5WzZdICYgMTUgfCA2NDtcbiAgdXVpZEFycmF5WzhdID0gdXVpZEFycmF5WzhdICYgNjMgfCAxMjg7XG4gIGxldCB1dWlkID0gXCJcIjtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB1dWlkQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaSA9PT0gNCB8fCBpID09PSA2IHx8IGkgPT09IDggfHwgaSA9PT0gMTApIHtcbiAgICAgIHV1aWQgKz0gXCItXCI7XG4gICAgfVxuICAgIHV1aWQgKz0gdXVpZEFycmF5W2ldLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIik7XG4gIH1cbiAgcmV0dXJuIHV1aWQ7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvaXRlcmF0b3IudHNcbmZ1bmN0aW9uKiBpdGVyYXRlKC4uLml0ZXJhdG9ycykge1xuICBmb3IgKGNvbnN0IGl0ZXJhdG9yIG9mIGl0ZXJhdG9ycykge1xuICAgIHlpZWxkKiBpdGVyYXRvcjtcbiAgfVxufVxuZnVuY3Rpb24gdG9JdGVyYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgU3ltYm9sLml0ZXJhdG9yIGluIHZhbHVlID8gdmFsdWUgOiBbdmFsdWVdO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2ludGVycG9sYXRpbmcudHNcbnZhciBpbnRlcnBvbGF0ZSA9IFN5bWJvbChcImludGVycG9sYXRlXCIpO1xudmFyIGlzSW50ZXJwb2xhdGluZyA9ICh4KSA9PiB4W2ludGVycG9sYXRlXSAhPSBudWxsO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL25lYXJlc3QudHNcbmZ1bmN0aW9uIG5lYXJlc3RTcXVhcmVkKHgsIHksIG9iamVjdHMsIG1heERpc3RhbmNlU3F1YXJlZCA9IEluZmluaXR5KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHsgbmVhcmVzdDogdm9pZCAwLCBkaXN0YW5jZVNxdWFyZWQ6IG1heERpc3RhbmNlU3F1YXJlZCB9O1xuICBmb3IgKGNvbnN0IG9iaiBvZiBvYmplY3RzKSB7XG4gICAgY29uc3QgdGhpc0Rpc3RhbmNlID0gb2JqLmRpc3RhbmNlU3F1YXJlZCh4LCB5KTtcbiAgICBpZiAodGhpc0Rpc3RhbmNlID09PSAwKSB7XG4gICAgICByZXR1cm4geyBuZWFyZXN0OiBvYmosIGRpc3RhbmNlU3F1YXJlZDogMCB9O1xuICAgIH0gZWxzZSBpZiAodGhpc0Rpc3RhbmNlIDwgcmVzdWx0LmRpc3RhbmNlU3F1YXJlZCkge1xuICAgICAgcmVzdWx0Lm5lYXJlc3QgPSBvYmo7XG4gICAgICByZXN1bHQuZGlzdGFuY2VTcXVhcmVkID0gdGhpc0Rpc3RhbmNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbmVhcmVzdFNxdWFyZWRJbkNvbnRhaW5lcih4LCB5LCBjb250YWluZXIsIG1heERpc3RhbmNlU3F1YXJlZCA9IEluZmluaXR5KSB7XG4gIGNvbnN0IHsgeDogdHggPSB4LCB5OiB0eSA9IHkgfSA9IGNvbnRhaW5lci50cmFuc2Zvcm1Qb2ludD8uKHgsIHkpID8/IHt9O1xuICBjb25zdCByZXN1bHQgPSB7IG5lYXJlc3Q6IHZvaWQgMCwgZGlzdGFuY2VTcXVhcmVkOiBtYXhEaXN0YW5jZVNxdWFyZWQgfTtcbiAgZm9yIChjb25zdCBjaGlsZCBvZiBjb250YWluZXIuY2hpbGRyZW4pIHtcbiAgICBjb25zdCB7IG5lYXJlc3QsIGRpc3RhbmNlU3F1YXJlZDogZGlzdGFuY2VTcXVhcmVkMyB9ID0gY2hpbGQubmVhcmVzdFNxdWFyZWQodHgsIHR5LCByZXN1bHQuZGlzdGFuY2VTcXVhcmVkKTtcbiAgICBpZiAoZGlzdGFuY2VTcXVhcmVkMyA9PT0gMCkge1xuICAgICAgcmV0dXJuIHsgbmVhcmVzdCwgZGlzdGFuY2VTcXVhcmVkOiBkaXN0YW5jZVNxdWFyZWQzIH07XG4gICAgfSBlbHNlIGlmIChkaXN0YW5jZVNxdWFyZWQzIDwgcmVzdWx0LmRpc3RhbmNlU3F1YXJlZCkge1xuICAgICAgcmVzdWx0Lm5lYXJlc3QgPSBuZWFyZXN0O1xuICAgICAgcmVzdWx0LmRpc3RhbmNlU3F1YXJlZCA9IGRpc3RhbmNlU3F1YXJlZDM7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvZG9tLnRzXG52YXIgdmVyaWZpZWRHbG9iYWxzID0ge307XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICB2ZXJpZmllZEdsb2JhbHMud2luZG93ID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIHZlcmlmaWVkR2xvYmFscy53aW5kb3cgPSBnbG9iYWwud2luZG93O1xufVxuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICB2ZXJpZmllZEdsb2JhbHMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbn0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICB2ZXJpZmllZEdsb2JhbHMuZG9jdW1lbnQgPSBnbG9iYWwuZG9jdW1lbnQ7XG59XG5mdW5jdGlvbiBnZXREb2N1bWVudChwcm9wZXJ0eU5hbWUpIHtcbiAgcmV0dXJuIHByb3BlcnR5TmFtZSA/IHZlcmlmaWVkR2xvYmFscy5kb2N1bWVudD8uW3Byb3BlcnR5TmFtZV0gOiB2ZXJpZmllZEdsb2JhbHMuZG9jdW1lbnQ7XG59XG5mdW5jdGlvbiBnZXRXaW5kb3cocHJvcGVydHlOYW1lKSB7XG4gIHJldHVybiBwcm9wZXJ0eU5hbWUgPyB2ZXJpZmllZEdsb2JhbHMud2luZG93Py5bcHJvcGVydHlOYW1lXSA6IHZlcmlmaWVkR2xvYmFscy53aW5kb3c7XG59XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50KHRhZ05hbWUsIGNsYXNzTmFtZSwgc3R5bGUpIHtcbiAgY29uc3QgZWxlbWVudDIgPSBnZXREb2N1bWVudCgpLmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gIGlmICh0eXBlb2YgY2xhc3NOYW1lID09PSBcIm9iamVjdFwiKSB7XG4gICAgc3R5bGUgPSBjbGFzc05hbWU7XG4gICAgY2xhc3NOYW1lID0gdm9pZCAwO1xuICB9XG4gIGlmIChjbGFzc05hbWUpIHtcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgY2xhc3NOYW1lLnNwbGl0KFwiIFwiKSkge1xuICAgICAgZWxlbWVudDIuY2xhc3NMaXN0LmFkZChuYW1lKTtcbiAgICB9XG4gIH1cbiAgaWYgKHN0eWxlKSB7XG4gICAgT2JqZWN0LmFzc2lnbihlbGVtZW50Mi5zdHlsZSwgc3R5bGUpO1xuICB9XG4gIHJldHVybiBlbGVtZW50Mjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VVUkksIHF1YWxpZmllZE5hbWUpIHtcbiAgcmV0dXJuIGdldERvY3VtZW50KCkuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZVVSSSwgcXVhbGlmaWVkTmFtZSk7XG59XG5mdW5jdGlvbiBkb3dubG9hZFVybChkYXRhVXJsLCBmaWxlTmFtZSkge1xuICBjb25zdCB7IGJvZHkgfSA9IGdldERvY3VtZW50KCk7XG4gIGNvbnN0IGVsZW1lbnQyID0gY3JlYXRlRWxlbWVudChcImFcIiwgeyBkaXNwbGF5OiBcIm5vbmVcIiB9KTtcbiAgZWxlbWVudDIuaHJlZiA9IGRhdGFVcmw7XG4gIGVsZW1lbnQyLmRvd25sb2FkID0gZmlsZU5hbWU7XG4gIGJvZHkuYXBwZW5kQ2hpbGQoZWxlbWVudDIpO1xuICBlbGVtZW50Mi5jbGljaygpO1xuICBzZXRUaW1lb3V0KCgpID0+IGJvZHkucmVtb3ZlQ2hpbGQoZWxlbWVudDIpKTtcbn1cbmZ1bmN0aW9uIHNldERvY3VtZW50KGRvY3VtZW50Mikge1xuICB2ZXJpZmllZEdsb2JhbHMuZG9jdW1lbnQgPSBkb2N1bWVudDI7XG59XG5mdW5jdGlvbiBzZXRXaW5kb3cod2luZG93Mikge1xuICB2ZXJpZmllZEdsb2JhbHMud2luZG93ID0gd2luZG93Mjtcbn1cbmZ1bmN0aW9uIHNldEVsZW1lbnRCQm94KGVsZW1lbnQyLCBiYm94KSB7XG4gIGlmIChlbGVtZW50Mikge1xuICAgIGVsZW1lbnQyLnN0eWxlLndpZHRoID0gYCR7YmJveC53aWR0aH1weGA7XG4gICAgZWxlbWVudDIuc3R5bGUuaGVpZ2h0ID0gYCR7YmJveC5oZWlnaHR9cHhgO1xuICAgIGVsZW1lbnQyLnN0eWxlLmxlZnQgPSBgJHtiYm94Lnh9cHhgO1xuICAgIGVsZW1lbnQyLnN0eWxlLnRvcCA9IGAke2Jib3gueX1weGA7XG4gIH1cbn1cbmZ1bmN0aW9uIGZvY3VzQ3Vyc29yQXRFbmQoZWxlbWVudDIpIHtcbiAgZWxlbWVudDIuZm9jdXMoeyBwcmV2ZW50U2Nyb2xsOiB0cnVlIH0pO1xuICBpZiAoZWxlbWVudDIubGFzdENoaWxkPy50ZXh0Q29udGVudCA9PSBudWxsKVxuICAgIHJldHVybjtcbiAgY29uc3QgcmFuZ2UzID0gZ2V0RG9jdW1lbnQoKS5jcmVhdGVSYW5nZSgpO1xuICByYW5nZTMuc2V0U3RhcnQoZWxlbWVudDIubGFzdENoaWxkLCBlbGVtZW50Mi5sYXN0Q2hpbGQudGV4dENvbnRlbnQubGVuZ3RoKTtcbiAgcmFuZ2UzLnNldEVuZChlbGVtZW50Mi5sYXN0Q2hpbGQsIGVsZW1lbnQyLmxhc3RDaGlsZC50ZXh0Q29udGVudC5sZW5ndGgpO1xuICBjb25zdCBzZWxlY3Rpb24gPSBnZXRXaW5kb3coKS5nZXRTZWxlY3Rpb24oKTtcbiAgc2VsZWN0aW9uPy5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgc2VsZWN0aW9uPy5hZGRSYW5nZShyYW5nZTMpO1xufVxudmFyIF9pZCA9IDA7XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50SWQobGFiZWwpIHtcbiAgcmV0dXJuIGAke2xhYmVsID8/IFwiYWctY2hhcnRzLWVsZW1lbnRcIn0tJHtfaWQrK31gO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL251bWJlci50c1xuZnVuY3Rpb24gY2xhbXAobWluLCB2YWx1ZSwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1pbihtYXgsIE1hdGgubWF4KG1pbiwgdmFsdWUpKTtcbn1cbmZ1bmN0aW9uIGNsYW1wQXJyYXkodmFsdWUsIGFycmF5Mikge1xuICBjb25zdCBbbWluLCBtYXhdID0gZmluZE1pbk1heChhcnJheTIpO1xuICByZXR1cm4gY2xhbXAobWluLCB2YWx1ZSwgbWF4KTtcbn1cbmZ1bmN0aW9uIGZpbmRNaW5NYXgoYXJyYXkyKSB7XG4gIGlmIChhcnJheTIubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiBbXTtcbiAgY29uc3QgcmVzdWx0ID0gW0luZmluaXR5LCAtSW5maW5pdHldO1xuICBmb3IgKGNvbnN0IHZhbCBvZiBhcnJheTIpIHtcbiAgICBpZiAodmFsIDwgcmVzdWx0WzBdKVxuICAgICAgcmVzdWx0WzBdID0gdmFsO1xuICAgIGlmICh2YWwgPiByZXN1bHRbMV0pXG4gICAgICByZXN1bHRbMV0gPSB2YWw7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGZpbmRSYW5nZUV4dGVudChhcnJheTIpIHtcbiAgY29uc3QgW21pbiwgbWF4XSA9IGZpbmRNaW5NYXgoYXJyYXkyKTtcbiAgcmV0dXJuIG1heCAtIG1pbjtcbn1cbmZ1bmN0aW9uIGlzRXF1YWwoYSwgYiwgZXBzaWxvbjIgPSAxZS0xMCkge1xuICByZXR1cm4gTWF0aC5hYnMoYSAtIGIpIDwgZXBzaWxvbjI7XG59XG5mdW5jdGlvbiBpc05lZ2F0aXZlKHZhbHVlKSB7XG4gIHJldHVybiBNYXRoLnNpZ24odmFsdWUpID09PSAtMSB8fCBPYmplY3QuaXModmFsdWUsIC0wKTtcbn1cbmZ1bmN0aW9uIHJvdW5kKHZhbHVlLCBkZWNpbWFscyA9IDIpIHtcbiAgY29uc3QgYmFzZSA9IDEwICoqIGRlY2ltYWxzO1xuICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIGJhc2UpIC8gYmFzZTtcbn1cbmZ1bmN0aW9uIHRvRml4ZWQodmFsdWUsIGZyYWN0aW9uT3JTaWduaWZpY2FudERpZ2l0cyA9IDIpIHtcbiAgY29uc3QgcG93ZXIgPSBNYXRoLmZsb29yKE1hdGgubG9nKE1hdGguYWJzKHZhbHVlKSkgLyBNYXRoLkxOMTApO1xuICBpZiAocG93ZXIgPj0gMCB8fCAhaXNGaW5pdGUocG93ZXIpKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvRml4ZWQoZnJhY3Rpb25PclNpZ25pZmljYW50RGlnaXRzKTtcbiAgfVxuICByZXR1cm4gdmFsdWUudG9GaXhlZChNYXRoLmFicyhwb3dlcikgLSAxICsgZnJhY3Rpb25PclNpZ25pZmljYW50RGlnaXRzKTtcbn1cbmZ1bmN0aW9uIG1vZChuLCBtKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKG4gJSBtICsgKG4gPCAwID8gbSA6IDApKTtcbn1cbmZ1bmN0aW9uIGNvdW50RnJhY3Rpb25EaWdpdHModmFsdWUpIHtcbiAgaWYgKE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZSlcbiAgICByZXR1cm4gMDtcbiAgbGV0IHZhbHVlU3RyaW5nID0gU3RyaW5nKHZhbHVlKTtcbiAgbGV0IGV4cG9uZW50ID0gMDtcbiAgaWYgKHZhbHVlIDwgMWUtNiB8fCB2YWx1ZSA+PSAxZTIxKSB7XG4gICAgbGV0IGV4cG9uZW50U3RyaW5nO1xuICAgIFt2YWx1ZVN0cmluZywgZXhwb25lbnRTdHJpbmddID0gdmFsdWVTdHJpbmcuc3BsaXQoXCJlXCIpO1xuICAgIGlmIChleHBvbmVudFN0cmluZyAhPSBudWxsKSB7XG4gICAgICBleHBvbmVudCA9IE51bWJlcihleHBvbmVudFN0cmluZyk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGRlY2ltYWxQbGFjZXMyID0gdmFsdWVTdHJpbmcuc3BsaXQoXCIuXCIpWzFdPy5sZW5ndGggPz8gMDtcbiAgcmV0dXJuIE1hdGgubWF4KGRlY2ltYWxQbGFjZXMyIC0gZXhwb25lbnQsIDApO1xufVxuZnVuY3Rpb24gZm9ybWF0Tm9ybWFsaXplZFBlcmNlbnRhZ2UocmF0aW8yLCBsb2NhbGUpIHtcbiAgbG9jYWxlID0gbG9jYWxlID8/IGdldFdpbmRvdyhcIm5hdmlnYXRvclwiKS5sYW5ndWFnZTtcbiAgcmV0dXJuIG5ldyBJbnRsLk51bWJlckZvcm1hdChsb2NhbGUsIHtcbiAgICBzdHlsZTogXCJwZXJjZW50XCIsXG4gICAgbWluaW11bUZyYWN0aW9uRGlnaXRzOiAyLFxuICAgIG1heGltdW1GcmFjdGlvbkRpZ2l0czogMlxuICB9KS5mb3JtYXQocmF0aW8yKTtcbn1cbmZ1bmN0aW9uIGZvcm1hdFBlcmNlbnRhZ2UocGVyY2VudCwgbG9jYWxlKSB7XG4gIHJldHVybiBmb3JtYXROb3JtYWxpemVkUGVyY2VudGFnZShwZXJjZW50IC8gMTAwLCBsb2NhbGUpO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9iYm94LnRzXG52YXIgX0JCb3ggPSBjbGFzcyBfQkJveCB7XG4gIGNvbnN0cnVjdG9yKHgsIHksIHdpZHRoMiwgaGVpZ2h0Mikge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLndpZHRoID0gd2lkdGgyO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0MjtcbiAgfVxuICBzdGF0aWMgZnJvbURPTVJlY3QoeyB4LCB5LCB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIgfSkge1xuICAgIHJldHVybiBuZXcgX0JCb3goeCwgeSwgd2lkdGgyLCBoZWlnaHQyKTtcbiAgfVxuICB0b0RPTVJlY3QoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHRoaXMueCxcbiAgICAgIHk6IHRoaXMueSxcbiAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgIHRvcDogdGhpcy55LFxuICAgICAgbGVmdDogdGhpcy54LFxuICAgICAgcmlnaHQ6IHRoaXMueCArIHRoaXMud2lkdGgsXG4gICAgICBib3R0b206IHRoaXMueSArIHRoaXMuaGVpZ2h0LFxuICAgICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICBjb25zdCB7IHgsIHksIHdpZHRoOiB3aWR0aDIsIGhlaWdodDogaGVpZ2h0MiB9ID0gdGhpcztcbiAgICByZXR1cm4gbmV3IF9CQm94KHgsIHksIHdpZHRoMiwgaGVpZ2h0Mik7XG4gIH1cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMueCA9PT0gb3RoZXIueCAmJiB0aGlzLnkgPT09IG90aGVyLnkgJiYgdGhpcy53aWR0aCA9PT0gb3RoZXIud2lkdGggJiYgdGhpcy5oZWlnaHQgPT09IG90aGVyLmhlaWdodDtcbiAgfVxuICBjb250YWluc1BvaW50KHgsIHkpIHtcbiAgICByZXR1cm4geCA+PSB0aGlzLnggJiYgeCA8PSB0aGlzLnggKyB0aGlzLndpZHRoICYmIHkgPj0gdGhpcy55ICYmIHkgPD0gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG4gIH1cbiAgaW50ZXJzZWN0aW9uKG90aGVyKSB7XG4gICAgaWYgKCF0aGlzLmNvbGxpZGVzQkJveChvdGhlcikpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbmV3WDEgPSBjbGFtcChvdGhlci54LCB0aGlzLngsIG90aGVyLnggKyBvdGhlci53aWR0aCk7XG4gICAgY29uc3QgbmV3WTEgPSBjbGFtcChvdGhlci55LCB0aGlzLnksIG90aGVyLnkgKyBvdGhlci5oZWlnaHQpO1xuICAgIGNvbnN0IG5ld1gyID0gY2xhbXAob3RoZXIueCwgdGhpcy54ICsgdGhpcy53aWR0aCwgb3RoZXIueCArIG90aGVyLndpZHRoKTtcbiAgICBjb25zdCBuZXdZMiA9IGNsYW1wKG90aGVyLnksIHRoaXMueSArIHRoaXMuaGVpZ2h0LCBvdGhlci55ICsgb3RoZXIuaGVpZ2h0KTtcbiAgICByZXR1cm4gbmV3IF9CQm94KG5ld1gxLCBuZXdZMSwgbmV3WDIgLSBuZXdYMSwgbmV3WTIgLSBuZXdZMSk7XG4gIH1cbiAgY29sbGlkZXNCQm94KG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMueCA8IG90aGVyLnggKyBvdGhlci53aWR0aCAmJiB0aGlzLnggKyB0aGlzLndpZHRoID4gb3RoZXIueCAmJiB0aGlzLnkgPCBvdGhlci55ICsgb3RoZXIuaGVpZ2h0ICYmIHRoaXMueSArIHRoaXMuaGVpZ2h0ID4gb3RoZXIueTtcbiAgfVxuICBjb21wdXRlQ2VudGVyKCkge1xuICAgIHJldHVybiB7IHg6IHRoaXMueCArIHRoaXMud2lkdGggLyAyLCB5OiB0aGlzLnkgKyB0aGlzLmhlaWdodCAvIDIgfTtcbiAgfVxuICBpc0Zpbml0ZSgpIHtcbiAgICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKHRoaXMueCkgJiYgTnVtYmVyLmlzRmluaXRlKHRoaXMueSkgJiYgTnVtYmVyLmlzRmluaXRlKHRoaXMud2lkdGgpICYmIE51bWJlci5pc0Zpbml0ZSh0aGlzLmhlaWdodCk7XG4gIH1cbiAgZGlzdGFuY2VTcXVhcmVkKHgsIHkpIHtcbiAgICBpZiAodGhpcy5jb250YWluc1BvaW50KHgsIHkpKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgY29uc3QgZHggPSB4IC0gY2xhbXAodGhpcy54LCB4LCB0aGlzLnggKyB0aGlzLndpZHRoKTtcbiAgICBjb25zdCBkeSA9IHkgLSBjbGFtcCh0aGlzLnksIHksIHRoaXMueSArIHRoaXMuaGVpZ2h0KTtcbiAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG4gIH1cbiAgc3RhdGljIG5lYXJlc3RCb3goeCwgeSwgYm94ZXMpIHtcbiAgICByZXR1cm4gbmVhcmVzdFNxdWFyZWQoeCwgeSwgYm94ZXMpO1xuICB9XG4gIGNsaXAoY2xpcFJlY3QpIHtcbiAgICBpZiAoY2xpcFJlY3QgPT09IHZvaWQgMClcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IHgxID0gTWF0aC5tYXgodGhpcy54LCBjbGlwUmVjdC54KTtcbiAgICBjb25zdCB5MSA9IE1hdGgubWF4KHRoaXMueSwgY2xpcFJlY3QueSk7XG4gICAgY29uc3QgeDIgPSBNYXRoLm1pbih0aGlzLnggKyB0aGlzLndpZHRoLCBjbGlwUmVjdC54ICsgY2xpcFJlY3Qud2lkdGgpO1xuICAgIGNvbnN0IHkyID0gTWF0aC5taW4odGhpcy55ICsgdGhpcy5oZWlnaHQsIGNsaXBSZWN0LnkgKyBjbGlwUmVjdC5oZWlnaHQpO1xuICAgIHRoaXMueCA9IHgxO1xuICAgIHRoaXMueSA9IHkxO1xuICAgIHRoaXMud2lkdGggPSBNYXRoLm1heCgwLCB4MiAtIHgxKTtcbiAgICB0aGlzLmhlaWdodCA9IE1hdGgubWF4KDAsIHkyIC0geTEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNocmluayhhbW91bnQsIHBvc2l0aW9uKSB7XG4gICAgY29uc3QgYXBwbHkyID0gKHBvcywgYW10KSA9PiB7XG4gICAgICBzd2l0Y2ggKHBvcykge1xuICAgICAgICBjYXNlIFwidG9wXCI6XG4gICAgICAgICAgdGhpcy55ICs9IGFtdDtcbiAgICAgICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgICAgIHRoaXMuaGVpZ2h0IC09IGFtdDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgICB0aGlzLnggKz0gYW10O1xuICAgICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgICB0aGlzLndpZHRoIC09IGFtdDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInZlcnRpY2FsXCI6XG4gICAgICAgICAgdGhpcy55ICs9IGFtdDtcbiAgICAgICAgICB0aGlzLmhlaWdodCAtPSBhbXQgKiAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaG9yaXpvbnRhbFwiOlxuICAgICAgICAgIHRoaXMueCArPSBhbXQ7XG4gICAgICAgICAgdGhpcy53aWR0aCAtPSBhbXQgKiAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHZvaWQgMDpcbiAgICAgICAgICB0aGlzLnggKz0gYW10O1xuICAgICAgICAgIHRoaXMud2lkdGggLT0gYW10ICogMjtcbiAgICAgICAgICB0aGlzLnkgKz0gYW10O1xuICAgICAgICAgIHRoaXMuaGVpZ2h0IC09IGFtdCAqIDI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAodHlwZW9mIGFtb3VudCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgYXBwbHkyKHBvc2l0aW9uLCBhbW91bnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFtb3VudCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgT2JqZWN0LmVudHJpZXMoYW1vdW50KS5mb3JFYWNoKChbcG9zLCBhbXRdKSA9PiBhcHBseTIocG9zLCBhbXQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZ3JvdyhhbW91bnQsIHBvc2l0aW9uKSB7XG4gICAgaWYgKHR5cGVvZiBhbW91bnQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRoaXMuc2hyaW5rKC1hbW91bnQsIHBvc2l0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcGFkZGluZ0NvcHkgPSB7IC4uLmFtb3VudCB9O1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFkZGluZ0NvcHkpIHtcbiAgICAgICAgcGFkZGluZ0NvcHlba2V5XSAqPSAtMTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2hyaW5rKHBhZGRpbmdDb3B5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdHJhbnNsYXRlKHgsIHkpIHtcbiAgICB0aGlzLnggKz0geDtcbiAgICB0aGlzLnkgKz0geTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjb21iaW5lKG90aGVyKSB7XG4gICAgY29uc3QgeyB4LCB5LCB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIgfSA9IHRoaXM7XG4gICAgdGhpcy54ID0gTWF0aC5taW4oeCwgb3RoZXIueCk7XG4gICAgdGhpcy55ID0gTWF0aC5taW4oeSwgb3RoZXIueSk7XG4gICAgdGhpcy53aWR0aCA9IE1hdGgubWF4KHggKyB3aWR0aDIsIG90aGVyLnggKyBvdGhlci53aWR0aCkgLSB0aGlzLng7XG4gICAgdGhpcy5oZWlnaHQgPSBNYXRoLm1heCh5ICsgaGVpZ2h0Miwgb3RoZXIueSArIG90aGVyLmhlaWdodCkgLSB0aGlzLnk7XG4gIH1cbiAgc3RhdGljIG1lcmdlKGJveGVzKSB7XG4gICAgbGV0IGxlZnQgPSBJbmZpbml0eTtcbiAgICBsZXQgdG9wID0gSW5maW5pdHk7XG4gICAgbGV0IHJpZ2h0ID0gLUluZmluaXR5O1xuICAgIGxldCBib3R0b20gPSAtSW5maW5pdHk7XG4gICAgZm9yIChjb25zdCBib3ggb2YgYm94ZXMpIHtcbiAgICAgIGlmIChib3gueCA8IGxlZnQpIHtcbiAgICAgICAgbGVmdCA9IGJveC54O1xuICAgICAgfVxuICAgICAgaWYgKGJveC55IDwgdG9wKSB7XG4gICAgICAgIHRvcCA9IGJveC55O1xuICAgICAgfVxuICAgICAgaWYgKGJveC54ICsgYm94LndpZHRoID4gcmlnaHQpIHtcbiAgICAgICAgcmlnaHQgPSBib3gueCArIGJveC53aWR0aDtcbiAgICAgIH1cbiAgICAgIGlmIChib3gueSArIGJveC5oZWlnaHQgPiBib3R0b20pIHtcbiAgICAgICAgYm90dG9tID0gYm94LnkgKyBib3guaGVpZ2h0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IF9CQm94KGxlZnQsIHRvcCwgcmlnaHQgLSBsZWZ0LCBib3R0b20gLSB0b3ApO1xuICB9XG4gIFtpbnRlcnBvbGF0ZV0ob3RoZXIsIGQpIHtcbiAgICByZXR1cm4gbmV3IF9CQm94KFxuICAgICAgdGhpcy54ICogKDEgLSBkKSArIG90aGVyLnggKiBkLFxuICAgICAgdGhpcy55ICogKDEgLSBkKSArIG90aGVyLnkgKiBkLFxuICAgICAgdGhpcy53aWR0aCAqICgxIC0gZCkgKyBvdGhlci53aWR0aCAqIGQsXG4gICAgICB0aGlzLmhlaWdodCAqICgxIC0gZCkgKyBvdGhlci5oZWlnaHQgKiBkXG4gICAgKTtcbiAgfVxufTtcbl9CQm94Lnplcm8gPSBPYmplY3QuZnJlZXplKG5ldyBfQkJveCgwLCAwLCAwLCAwKSk7XG5fQkJveC5OYU4gPSBPYmplY3QuZnJlZXplKG5ldyBfQkJveChOYU4sIE5hTiwgTmFOLCBOYU4pKTtcbnZhciBCQm94ID0gX0JCb3g7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL2NoYW5nZURldGVjdGFibGUudHNcbnZhciBSZWRyYXdUeXBlID0gLyogQF9fUFVSRV9fICovICgoUmVkcmF3VHlwZTIpID0+IHtcbiAgUmVkcmF3VHlwZTJbUmVkcmF3VHlwZTJbXCJOT05FXCJdID0gMF0gPSBcIk5PTkVcIjtcbiAgUmVkcmF3VHlwZTJbUmVkcmF3VHlwZTJbXCJUUklWSUFMXCJdID0gMV0gPSBcIlRSSVZJQUxcIjtcbiAgUmVkcmF3VHlwZTJbUmVkcmF3VHlwZTJbXCJNSU5PUlwiXSA9IDJdID0gXCJNSU5PUlwiO1xuICBSZWRyYXdUeXBlMltSZWRyYXdUeXBlMltcIk1BSk9SXCJdID0gM10gPSBcIk1BSk9SXCI7XG4gIHJldHVybiBSZWRyYXdUeXBlMjtcbn0pKFJlZHJhd1R5cGUgfHwge30pO1xuZnVuY3Rpb24gU2NlbmVDaGFuZ2VEZXRlY3Rpb24ob3B0cykge1xuICByZXR1cm4gZnVuY3Rpb24odGFyZ2V0LCBrZXkpIHtcbiAgICBjb25zdCBwcml2YXRlS2V5ID0gYF9fJHtrZXl9YDtcbiAgICBpZiAodGFyZ2V0W2tleV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcHJlcGFyZUdldFNldCh0YXJnZXQsIGtleSwgcHJpdmF0ZUtleSwgb3B0cyk7XG4gIH07XG59XG5mdW5jdGlvbiBwcmVwYXJlR2V0U2V0KHRhcmdldCwga2V5LCBwcml2YXRlS2V5LCBvcHRzKSB7XG4gIGNvbnN0IHtcbiAgICByZWRyYXcgPSAxIC8qIFRSSVZJQUwgKi8sXG4gICAgdHlwZSA9IFwibm9ybWFsXCIsXG4gICAgY2hhbmdlQ2IsXG4gICAgY29udmVydG9yLFxuICAgIGNoZWNrRGlydHlPbkFzc2lnbm1lbnQgPSBmYWxzZVxuICB9ID0gb3B0cyA/PyB7fTtcbiAgY29uc3QgcmVxdWlyZWRPcHRzID0geyByZWRyYXcsIHR5cGUsIGNoYW5nZUNiLCBjaGVja0RpcnR5T25Bc3NpZ25tZW50LCBjb252ZXJ0b3IgfTtcbiAgbGV0IHNldHRlcjtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBcIm5vcm1hbFwiOlxuICAgICAgc2V0dGVyID0gYnVpbGROb3JtYWxTZXR0ZXIocHJpdmF0ZUtleSwgcmVxdWlyZWRPcHRzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJ0cmFuc2Zvcm1cIjpcbiAgICAgIHNldHRlciA9IGJ1aWxkVHJhbnNmb3JtU2V0dGVyKHByaXZhdGVLZXksIHJlcXVpcmVkT3B0cyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwicGF0aFwiOlxuICAgICAgc2V0dGVyID0gYnVpbGRQYXRoU2V0dGVyKHByaXZhdGVLZXksIHJlcXVpcmVkT3B0cyk7XG4gICAgICBicmVhaztcbiAgfVxuICBzZXR0ZXIgPSBidWlsZENoZWNrRGlydHlDaGFpbihcbiAgICBidWlsZENoYW5nZUNhbGxiYWNrQ2hhaW4oYnVpbGRDb252ZXJ0b3JDaGFpbihzZXR0ZXIsIHJlcXVpcmVkT3B0cyksIHJlcXVpcmVkT3B0cyksXG4gICAgcmVxdWlyZWRPcHRzXG4gICk7XG4gIGNvbnN0IGdldHRlciA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzW3ByaXZhdGVLZXldO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHtcbiAgICBzZXQ6IHNldHRlcixcbiAgICBnZXQ6IGdldHRlcixcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cbmZ1bmN0aW9uIGJ1aWxkQ29udmVydG9yQ2hhaW4oc2V0dGVyRm4sIG9wdHMpIHtcbiAgY29uc3QgeyBjb252ZXJ0b3IgfSA9IG9wdHM7XG4gIGlmIChjb252ZXJ0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHNldHRlckZuLmNhbGwodGhpcywgY29udmVydG9yKHZhbHVlKSk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gc2V0dGVyRm47XG59XG52YXIgTk9fQ0hBTkdFID0gU3ltYm9sKFwibm8tY2hhbmdlXCIpO1xuZnVuY3Rpb24gYnVpbGRDaGFuZ2VDYWxsYmFja0NoYWluKHNldHRlckZuLCBvcHRzKSB7XG4gIGNvbnN0IHsgY2hhbmdlQ2IgfSA9IG9wdHM7XG4gIGlmIChjaGFuZ2VDYikge1xuICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgY29uc3QgY2hhbmdlID0gc2V0dGVyRm4uY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICBpZiAoY2hhbmdlICE9PSBOT19DSEFOR0UpIHtcbiAgICAgICAgY2hhbmdlQ2IuY2FsbCh0aGlzLCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjaGFuZ2U7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gc2V0dGVyRm47XG59XG5mdW5jdGlvbiBidWlsZENoZWNrRGlydHlDaGFpbihzZXR0ZXJGbiwgb3B0cykge1xuICBjb25zdCB7IGNoZWNrRGlydHlPbkFzc2lnbm1lbnQgfSA9IG9wdHM7XG4gIGlmIChjaGVja0RpcnR5T25Bc3NpZ25tZW50KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBjb25zdCBjaGFuZ2UgPSBzZXR0ZXJGbi5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgIGlmIChjaGFuZ2UgIT09IE5PX0NIQU5HRSAmJiB2YWx1ZSAhPSBudWxsICYmIHZhbHVlLl9kaXJ0eSA+IDAgLyogTk9ORSAqLykge1xuICAgICAgICB0aGlzLm1hcmtEaXJ0eSh2YWx1ZS5fZGlydHkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBzZXR0ZXJGbjtcbn1cbmZ1bmN0aW9uIGJ1aWxkTm9ybWFsU2V0dGVyKHByaXZhdGVLZXksIG9wdHMpIHtcbiAgY29uc3QgeyByZWRyYXcgPSAxIC8qIFRSSVZJQUwgKi8sIGNoYW5nZUNiIH0gPSBvcHRzO1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXNbcHJpdmF0ZUtleV07XG4gICAgaWYgKHZhbHVlICE9PSBvbGRWYWx1ZSkge1xuICAgICAgdGhpc1twcml2YXRlS2V5XSA9IHZhbHVlO1xuICAgICAgdGhpcy5tYXJrRGlydHkocmVkcmF3KTtcbiAgICAgIGNoYW5nZUNiPy4odGhpcyk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBOT19DSEFOR0U7XG4gIH07XG59XG5mdW5jdGlvbiBidWlsZFRyYW5zZm9ybVNldHRlcihwcml2YXRlS2V5LCBvcHRzKSB7XG4gIGNvbnN0IHsgcmVkcmF3ID0gMSAvKiBUUklWSUFMICovIH0gPSBvcHRzO1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXNbcHJpdmF0ZUtleV07XG4gICAgaWYgKHZhbHVlICE9PSBvbGRWYWx1ZSkge1xuICAgICAgdGhpc1twcml2YXRlS2V5XSA9IHZhbHVlO1xuICAgICAgdGhpcy5tYXJrRGlydHlUcmFuc2Zvcm0ocmVkcmF3KTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIE5PX0NIQU5HRTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkUGF0aFNldHRlcihwcml2YXRlS2V5LCBvcHRzKSB7XG4gIGNvbnN0IHsgcmVkcmF3ID0gMSAvKiBUUklWSUFMICovIH0gPSBvcHRzO1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXNbcHJpdmF0ZUtleV07XG4gICAgaWYgKHZhbHVlICE9PSBvbGRWYWx1ZSkge1xuICAgICAgdGhpc1twcml2YXRlS2V5XSA9IHZhbHVlO1xuICAgICAgaWYgKCF0aGlzLl9kaXJ0eVBhdGgpIHtcbiAgICAgICAgdGhpcy5fZGlydHlQYXRoID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5tYXJrRGlydHkocmVkcmF3KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIE5PX0NIQU5HRTtcbiAgfTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvbm9kZS50c1xudmFyIFBvaW50ZXJFdmVudHMgPSAvKiBAX19QVVJFX18gKi8gKChQb2ludGVyRXZlbnRzMikgPT4ge1xuICBQb2ludGVyRXZlbnRzMltQb2ludGVyRXZlbnRzMltcIkFsbFwiXSA9IDBdID0gXCJBbGxcIjtcbiAgUG9pbnRlckV2ZW50czJbUG9pbnRlckV2ZW50czJbXCJOb25lXCJdID0gMV0gPSBcIk5vbmVcIjtcbiAgcmV0dXJuIFBvaW50ZXJFdmVudHMyO1xufSkoUG9pbnRlckV2ZW50cyB8fCB7fSk7XG52YXIgX05vZGUgPSBjbGFzcyBfTm9kZSB7XG4gIC8vIERpc2NyaW1pbmF0b3JzIGZvciByZW5kZXIgb3JkZXIgd2l0aGluIGEgekluZGV4XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAvKiogVW5pcXVlIG51bWJlciB0byBhbGxvdyBjcmVhdGlvbiBvcmRlciB0byBiZSBlYXNpbHkgZGV0ZXJtaW5lZC4gKi9cbiAgICB0aGlzLnNlcmlhbE51bWJlciA9IF9Ob2RlLl9uZXh0U2VyaWFsTnVtYmVyKys7XG4gICAgdGhpcy5jaGlsZE5vZGVDb3VudHMgPSB7IGdyb3VwczogMCwgbm9uR3JvdXBzOiAwIH07XG4gICAgLyoqIFVuaXF1ZSBub2RlIElEIGluIHRoZSBmb3JtIGBDbGFzc05hbWUtTmF0dXJhbE51bWJlcmAuICovXG4gICAgdGhpcy5pZCA9IGNyZWF0ZUlkKHRoaXMpO1xuICAgIHRoaXMucG9pbnRlckV2ZW50cyA9IDAgLyogQWxsICovO1xuICAgIHRoaXMuX2RpcnR5ID0gMyAvKiBNQUpPUiAqLztcbiAgICB0aGlzLmRpcnR5WkluZGV4ID0gZmFsc2U7XG4gICAgdGhpcy52aXJ0dWFsQ2hpbGRyZW5Db3VudCA9IDA7XG4gICAgLyoqXG4gICAgICogVG8gc2ltcGxpZnkgdGhlIHR5cGUgc3lzdGVtIChlc3BlY2lhbGx5IGluIFNlbGVjdGlvbnMpIHdlIGRvbid0IGhhdmUgdGhlIGBQYXJlbnRgIG5vZGVcbiAgICAgKiAob25lIHRoYXQgaGFzIGNoaWxkcmVuKS4gSW5zdGVhZCwgd2UgbWltaWMgSFRNTCBET00sIHdoZXJlIGFueSBub2RlIGNhbiBoYXZlIGNoaWxkcmVuLlxuICAgICAqIEJ1dCB3ZSBzdGlsbCBuZWVkIHRvIGRpc3Rpbmd1aXNoIHJlZ3VsYXIgbGVhZiBub2RlcyBmcm9tIGNvbnRhaW5lciBsZWFmcyBzb21laG93LlxuICAgICAqL1xuICAgIHRoaXMuaXNDb250YWluZXJOb2RlID0gZmFsc2U7XG4gICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICB0aGlzLnpJbmRleCA9IDA7XG4gICAgdGhpcy56SW5kZXhTdWJPcmRlciA9IHZvaWQgMDtcbiAgICB0aGlzLm5hbWUgPSBvcHRpb25zPy5uYW1lO1xuICAgIHRoaXMuaXNWaXJ0dWFsID0gb3B0aW9ucz8uaXNWaXJ0dWFsID8/IGZhbHNlO1xuICAgIHRoaXMudGFnID0gb3B0aW9ucz8udGFnID8/IE5hTjtcbiAgICB0aGlzLnpJbmRleCA9IG9wdGlvbnM/LnpJbmRleCA/PyAwO1xuICB9XG4gIHN0YXRpYyAqZXh0cmFjdEJCb3hlcyhub2Rlcywgc2tpcEludmlzaWJsZSkge1xuICAgIGZvciAoY29uc3QgbiBvZiBub2Rlcykge1xuICAgICAgaWYgKCFza2lwSW52aXNpYmxlIHx8IG4udmlzaWJsZSAmJiAhbi50cmFuc2l0aW9uT3V0KSB7XG4gICAgICAgIGNvbnN0IGJib3ggPSBuLmdldEJCb3goKTtcbiAgICAgICAgaWYgKGJib3gpXG4gICAgICAgICAgeWllbGQgYmJveDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNvbWUgYXJiaXRyYXJ5IGRhdGEgYm91bmQgdG8gdGhlIG5vZGUuXG4gICAqL1xuICBnZXQgZGF0dW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdHVtID8/IHRoaXMucGFyZW50Tm9kZT8uZGF0dW07XG4gIH1cbiAgc2V0IGRhdHVtKGRhdHVtKSB7XG4gICAgaWYgKHRoaXMuX2RhdHVtICE9PSBkYXR1bSkge1xuICAgICAgdGhpcy5fcHJldmlvdXNEYXR1bSA9IHRoaXMuX2RhdHVtO1xuICAgICAgdGhpcy5fZGF0dW0gPSBkYXR1bTtcbiAgICB9XG4gIH1cbiAgZ2V0IHByZXZpb3VzRGF0dW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByZXZpb3VzRGF0dW07XG4gIH1cbiAgZ2V0IGxheWVyTWFuYWdlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fbGF5ZXJNYW5hZ2VyO1xuICB9XG4gIGdldCBkaXJ0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGlydHk7XG4gIH1cbiAgLyoqIFBlcmZvcm0gYW55IHByZS1yZW5kZXJpbmcgaW5pdGlhbGl6YXRpb24uICovXG4gIHByZVJlbmRlcigpIHtcbiAgICB0aGlzLmNoaWxkTm9kZUNvdW50cy5ncm91cHMgPSAwO1xuICAgIHRoaXMuY2hpbGROb2RlQ291bnRzLm5vbkdyb3VwcyA9IDE7XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKCkpIHtcbiAgICAgIGNvbnN0IGNoaWxkQ291bnRzID0gY2hpbGQucHJlUmVuZGVyKCk7XG4gICAgICB0aGlzLmNoaWxkTm9kZUNvdW50cy5ncm91cHMgKz0gY2hpbGRDb3VudHMuZ3JvdXBzO1xuICAgICAgdGhpcy5jaGlsZE5vZGVDb3VudHMubm9uR3JvdXBzICs9IGNoaWxkQ291bnRzLm5vbkdyb3VwcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2hpbGROb2RlQ291bnRzO1xuICB9XG4gIHJlbmRlcihyZW5kZXJDdHgpIHtcbiAgICBjb25zdCB7IHN0YXRzIH0gPSByZW5kZXJDdHg7XG4gICAgdGhpcy5fZGlydHkgPSAwIC8qIE5PTkUgKi87XG4gICAgaWYgKHJlbmRlckN0eC5kZWJ1Z05vZGVTZWFyY2gpIHtcbiAgICAgIGNvbnN0IGlkT3JOYW1lID0gdGhpcy5uYW1lID8/IHRoaXMuaWQ7XG4gICAgICBpZiAocmVuZGVyQ3R4LmRlYnVnTm9kZVNlYXJjaC5zb21lKCh2KSA9PiB0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIiA/IHYgPT09IGlkT3JOYW1lIDogdi50ZXN0KGlkT3JOYW1lKSkpIHtcbiAgICAgICAgcmVuZGVyQ3R4LmRlYnVnTm9kZXNbdGhpcy5uYW1lID8/IHRoaXMuaWRdID0gdGhpcztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0YXRzKSB7XG4gICAgICBzdGF0cy5ub2Rlc1JlbmRlcmVkKys7XG4gICAgfVxuICB9XG4gIF9zZXRMYXllck1hbmFnZXIodmFsdWUpIHtcbiAgICB0aGlzLl9sYXllck1hbmFnZXIgPSB2YWx1ZTtcbiAgICB0aGlzLl9kZWJ1ZyA9IHZhbHVlPy5kZWJ1ZztcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4oZmFsc2UpKSB7XG4gICAgICBjaGlsZC5fc2V0TGF5ZXJNYW5hZ2VyKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgc29ydENoaWxkcmVuKGNvbXBhcmVGbikge1xuICAgIHRoaXMuZGlydHlaSW5kZXggPSBmYWxzZTtcbiAgICBpZiAoIXRoaXMuY2hpbGROb2RlcylcbiAgICAgIHJldHVybjtcbiAgICBpZiAodGhpcy5oYXNWaXJ0dWFsQ2hpbGRyZW4oKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBzb3J0ZWRDaGlsZHJlbiA9IFsuLi50aGlzLmNoaWxkTm9kZXNdLnNvcnQoY29tcGFyZUZuKTtcbiAgICB0aGlzLmNoaWxkTm9kZXMuY2xlYXIoKTtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHNvcnRlZENoaWxkcmVuKSB7XG4gICAgICB0aGlzLmNoaWxkTm9kZXMuYWRkKGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgKnRyYXZlcnNlVXAoaW5jbHVkZVNlbGYpIHtcbiAgICBsZXQgbm9kZSA9IHRoaXM7XG4gICAgaWYgKGluY2x1ZGVTZWxmKSB7XG4gICAgICB5aWVsZCBub2RlO1xuICAgIH1cbiAgICB3aGlsZSAobm9kZSA9IG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgeWllbGQgbm9kZTtcbiAgICB9XG4gIH1cbiAgKmNoaWxkcmVuKGZsYXR0ZW5WaXJ0dWFsID0gdHJ1ZSkge1xuICAgIGlmICghdGhpcy5jaGlsZE5vZGVzKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHZpcnR1YWxDaGlsZHJlbiA9IFtdO1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5jaGlsZE5vZGVzKSB7XG4gICAgICBpZiAoZmxhdHRlblZpcnR1YWwgJiYgY2hpbGQuaXNWaXJ0dWFsKSB7XG4gICAgICAgIHZpcnR1YWxDaGlsZHJlbi5wdXNoKGNoaWxkLmNoaWxkcmVuKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeWllbGQgY2hpbGQ7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgdkNoaWxkcmVuIG9mIHZpcnR1YWxDaGlsZHJlbikge1xuICAgICAgeWllbGQqIHZDaGlsZHJlbjtcbiAgICB9XG4gIH1cbiAgKnZpcnR1YWxDaGlsZHJlbigpIHtcbiAgICBpZiAoIXRoaXMuY2hpbGROb2RlcyB8fCAhdGhpcy52aXJ0dWFsQ2hpbGRyZW5Db3VudClcbiAgICAgIHJldHVybjtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuY2hpbGROb2Rlcykge1xuICAgICAgaWYgKGNoaWxkLmlzVmlydHVhbCkge1xuICAgICAgICB5aWVsZCBjaGlsZDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaGFzVmlydHVhbENoaWxkcmVuKCkge1xuICAgIHJldHVybiB0aGlzLnZpcnR1YWxDaGlsZHJlbkNvdW50ID4gMDtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBub2RlIGlzIGEgbGVhZiAoaGFzIG5vIGNoaWxkcmVuKS5cbiAgICovXG4gIGlzTGVhZigpIHtcbiAgICByZXR1cm4gIXRoaXMuY2hpbGROb2Rlcz8uc2l6ZTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBub2RlIGlzIHRoZSByb290IChoYXMgbm8gcGFyZW50KS5cbiAgICovXG4gIGlzUm9vdCgpIHtcbiAgICByZXR1cm4gIXRoaXMucGFyZW50Tm9kZTtcbiAgfVxuICAvKipcbiAgICogQXBwZW5kcyBvbmUgb3IgbW9yZSBuZXcgbm9kZSBpbnN0YW5jZXMgdG8gdGhpcyBwYXJlbnQuXG4gICAqIElmIG9uZSBuZWVkcyB0bzpcbiAgICogLSBtb3ZlIGEgY2hpbGQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdCBvZiBjaGlsZHJlblxuICAgKiAtIG1vdmUgYSBjaGlsZCBmcm9tIG9uZSBwYXJlbnQgdG8gYW5vdGhlciAoaW5jbHVkaW5nIHBhcmVudHMgaW4gb3RoZXIgc2NlbmVzKVxuICAgKiBvbmUgc2hvdWxkIHVzZSB0aGUge0BsaW5rIGluc2VydEJlZm9yZX0gbWV0aG9kIGluc3RlYWQuXG4gICAqIEBwYXJhbSBub2RlcyBBIG5vZGUgb3Igbm9kZXMgdG8gYXBwZW5kLlxuICAgKi9cbiAgYXBwZW5kKG5vZGVzKSB7XG4gICAgdGhpcy5jaGlsZE5vZGVzID8/ICh0aGlzLmNoaWxkTm9kZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgdG9JdGVyYWJsZShub2RlcykpIHtcbiAgICAgIG5vZGUucGFyZW50Tm9kZT8ucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICB0aGlzLmNoaWxkTm9kZXMuYWRkKG5vZGUpO1xuICAgICAgbm9kZS5wYXJlbnROb2RlID0gdGhpcztcbiAgICAgIG5vZGUuX3NldExheWVyTWFuYWdlcih0aGlzLmxheWVyTWFuYWdlcik7XG4gICAgICBpZiAobm9kZS5pc1ZpcnR1YWwpIHtcbiAgICAgICAgdGhpcy52aXJ0dWFsQ2hpbGRyZW5Db3VudCsrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmludmFsaWRhdGVDYWNoZWRCQm94KCk7XG4gICAgdGhpcy5kaXJ0eVpJbmRleCA9IHRydWU7XG4gICAgdGhpcy5tYXJrRGlydHkoMyAvKiBNQUpPUiAqLyk7XG4gIH1cbiAgYXBwZW5kQ2hpbGQobm9kZSkge1xuICAgIHRoaXMuYXBwZW5kKG5vZGUpO1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIHJlbW92ZUNoaWxkKG5vZGUpIHtcbiAgICBpZiAoIXRoaXMuY2hpbGROb2Rlcz8uZGVsZXRlKG5vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGRlbGV0ZSBub2RlLnBhcmVudE5vZGU7XG4gICAgbm9kZS5fc2V0TGF5ZXJNYW5hZ2VyKCk7XG4gICAgaWYgKG5vZGUuaXNWaXJ0dWFsKSB7XG4gICAgICB0aGlzLnZpcnR1YWxDaGlsZHJlbkNvdW50LS07XG4gICAgfVxuICAgIHRoaXMuaW52YWxpZGF0ZUNhY2hlZEJCb3goKTtcbiAgICB0aGlzLmRpcnR5WkluZGV4ID0gdHJ1ZTtcbiAgICB0aGlzLm1hcmtEaXJ0eSgzIC8qIE1BSk9SICovKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZW1vdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyZW50Tm9kZT8ucmVtb3ZlQ2hpbGQodGhpcykgPz8gZmFsc2U7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKGZhbHNlKSkge1xuICAgICAgZGVsZXRlIGNoaWxkLnBhcmVudE5vZGU7XG4gICAgICBjaGlsZC5fc2V0TGF5ZXJNYW5hZ2VyKCk7XG4gICAgfVxuICAgIHRoaXMuY2hpbGROb2Rlcz8uY2xlYXIoKTtcbiAgICB0aGlzLmludmFsaWRhdGVDYWNoZWRCQm94KCk7XG4gICAgdGhpcy52aXJ0dWFsQ2hpbGRyZW5Db3VudCA9IDA7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnBhcmVudE5vZGU/LnJlbW92ZUNoaWxkKHRoaXMpO1xuICB9XG4gIHNldFByb3BlcnRpZXMoc3R5bGVzLCBwaWNrS2V5cykge1xuICAgIGlmIChwaWNrS2V5cykge1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgcGlja0tleXMpIHtcbiAgICAgICAgdGhpc1trZXldID0gc3R5bGVzW2tleV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgc3R5bGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY29udGFpbnNQb2ludChfeCwgX3kpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIEhpdCB0ZXN0aW5nIG1ldGhvZC5cbiAgICogUmVjdXJzaXZlbHkgY2hlY2tzIGlmIHRoZSBnaXZlbiBwb2ludCBpcyBpbnNpZGUgdGhpcyBub2RlIG9yIGFueSBvZiBpdHMgY2hpbGRyZW4uXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IG1hdGNoaW5nIG5vZGUgb3IgYHVuZGVmaW5lZGAuXG4gICAqIE5vZGVzIHRoYXQgcmVuZGVyIGxhdGVyIChzaG93IG9uIHRvcCkgYXJlIGhpdCB0ZXN0ZWQgZmlyc3QuXG4gICAqL1xuICBwaWNrTm9kZSh4LCB5LCBfbG9jYWxDb29yZHMgPSBmYWxzZSkge1xuICAgIGlmICghdGhpcy52aXNpYmxlIHx8IHRoaXMucG9pbnRlckV2ZW50cyA9PT0gMSAvKiBOb25lICovIHx8ICF0aGlzLmNvbnRhaW5zUG9pbnQoeCwgeSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2hpbGRyZW4gPSBbLi4udGhpcy5jaGlsZHJlbigpXTtcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMWUzKSB7XG4gICAgICBmb3IgKGxldCBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgY29uc3QgY29udGFpbnNQb2ludDIgPSBjaGlsZC5jb250YWluc1BvaW50KHgsIHkpO1xuICAgICAgICBjb25zdCBoaXQgPSBjb250YWluc1BvaW50MiA/IGNoaWxkLnBpY2tOb2RlKHgsIHkpIDogdm9pZCAwO1xuICAgICAgICBpZiAoaGl0KSB7XG4gICAgICAgICAgcmV0dXJuIGhpdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICBmb3IgKGxldCBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgaGl0ID0gY2hpbGRyZW5baV0ucGlja05vZGUoeCwgeSk7XG4gICAgICAgIGlmIChoaXQpIHtcbiAgICAgICAgICByZXR1cm4gaGl0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghdGhpcy5pc0NvbnRhaW5lck5vZGUpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuICBpbnZhbGlkYXRlQ2FjaGVkQkJveCgpIHtcbiAgICB0aGlzLmNhY2hlZEJCb3ggPSB2b2lkIDA7XG4gICAgdGhpcy5wYXJlbnROb2RlPy5pbnZhbGlkYXRlQ2FjaGVkQkJveCgpO1xuICB9XG4gIGdldEJCb3goKSB7XG4gICAgaWYgKHRoaXMuY2FjaGVkQkJveCA9PSBudWxsKSB7XG4gICAgICB0aGlzLmNhY2hlZEJCb3ggPSBPYmplY3QuZnJlZXplKHRoaXMuY29tcHV0ZUJCb3goKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNhY2hlZEJCb3g7XG4gIH1cbiAgY29tcHV0ZUJCb3goKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIG1hcmtEaXJ0eSh0eXBlID0gMSAvKiBUUklWSUFMICovLCBwYXJlbnRUeXBlID0gdHlwZSkge1xuICAgIGNvbnN0IHsgX2RpcnR5IH0gPSB0aGlzO1xuICAgIGNvbnN0IGRpcnR5VHlwZUJlbG93SGlnaFdhdGVybWFyayA9IF9kaXJ0eSA+IHR5cGUgfHwgX2RpcnR5ID09PSB0eXBlICYmIHR5cGUgPT09IHBhcmVudFR5cGU7XG4gICAgY29uc3Qgbm9QYXJlbnRDYWNoZWRCQm94ID0gdGhpcy5jYWNoZWRCQm94ID09IG51bGw7XG4gICAgaWYgKG5vUGFyZW50Q2FjaGVkQkJveCAmJiBkaXJ0eVR5cGVCZWxvd0hpZ2hXYXRlcm1hcmspXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5pbnZhbGlkYXRlQ2FjaGVkQkJveCgpO1xuICAgIHRoaXMuX2RpcnR5ID0gTWF0aC5tYXgoX2RpcnR5LCB0eXBlKTtcbiAgICBpZiAodGhpcy5wYXJlbnROb2RlKSB7XG4gICAgICB0aGlzLnBhcmVudE5vZGUubWFya0RpcnR5KHBhcmVudFR5cGUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5sYXllck1hbmFnZXIpIHtcbiAgICAgIHRoaXMubGF5ZXJNYW5hZ2VyLm1hcmtEaXJ0eSgpO1xuICAgIH1cbiAgfVxuICBtYXJrQ2xlYW4ob3B0cykge1xuICAgIGNvbnN0IHsgZm9yY2UgPSBmYWxzZSwgcmVjdXJzaXZlID0gdHJ1ZSB9ID0gb3B0cyA/PyB7fTtcbiAgICBpZiAodGhpcy5fZGlydHkgPT09IDAgLyogTk9ORSAqLyAmJiAhZm9yY2UpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fZGlydHkgPSAwIC8qIE5PTkUgKi87XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKGZhbHNlKSkge1xuICAgICAgaWYgKGNoaWxkLmlzVmlydHVhbCA/IHJlY3Vyc2l2ZSAhPT0gZmFsc2UgOiByZWN1cnNpdmUgPT09IHRydWUpIHtcbiAgICAgICAgY2hpbGQubWFya0NsZWFuKHsgZm9yY2UgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIG9uVmlzaWJsZUNoYW5nZSgpIHtcbiAgfVxuICBvblpJbmRleENoYW5nZSgpIHtcbiAgICBpZiAodGhpcy5wYXJlbnROb2RlKSB7XG4gICAgICB0aGlzLnBhcmVudE5vZGUuZGlydHlaSW5kZXggPSB0cnVlO1xuICAgIH1cbiAgfVxuICB0b1NWRygpIHtcbiAgICByZXR1cm47XG4gIH1cbn07XG5fTm9kZS5fbmV4dFNlcmlhbE51bWJlciA9IDA7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7XG4gICAgcmVkcmF3OiAzIC8qIE1BSk9SICovLFxuICAgIGNoYW5nZUNiOiAodGFyZ2V0KSA9PiB0YXJnZXQub25WaXNpYmxlQ2hhbmdlKClcbiAgfSlcbl0sIF9Ob2RlLnByb3RvdHlwZSwgXCJ2aXNpYmxlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oe1xuICAgIHJlZHJhdzogMSAvKiBUUklWSUFMICovLFxuICAgIGNoYW5nZUNiOiAodGFyZ2V0KSA9PiB0YXJnZXQub25aSW5kZXhDaGFuZ2UoKVxuICB9KVxuXSwgX05vZGUucHJvdG90eXBlLCBcInpJbmRleFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHtcbiAgICByZWRyYXc6IDEgLyogVFJJVklBTCAqLyxcbiAgICBjaGFuZ2VDYjogKHRhcmdldCkgPT4gdGFyZ2V0Lm9uWkluZGV4Q2hhbmdlKClcbiAgfSlcbl0sIF9Ob2RlLnByb3RvdHlwZSwgXCJ6SW5kZXhTdWJPcmRlclwiLCAyKTtcbnZhciBOb2RlID0gX05vZGU7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvY29sb3IudHNcbnZhciBsZXJwID0gKHgsIHksIHQpID0+IHggKiAoMSAtIHQpICsgeSAqIHQ7XG52YXIgc3JnYlRvTGluZWFyID0gKHZhbHVlKSA9PiB7XG4gIGNvbnN0IHNpZ24gPSB2YWx1ZSA8IDAgPyAtMSA6IDE7XG4gIGNvbnN0IGFicyA9IE1hdGguYWJzKHZhbHVlKTtcbiAgaWYgKGFicyA8PSAwLjA0MDQ1KVxuICAgIHJldHVybiB2YWx1ZSAvIDEyLjkyO1xuICByZXR1cm4gc2lnbiAqICgoYWJzICsgMC4wNTUpIC8gMS4wNTUpICoqIDIuNDtcbn07XG52YXIgc3JnYkZyb21MaW5lYXIgPSAodmFsdWUpID0+IHtcbiAgY29uc3Qgc2lnbiA9IHZhbHVlIDwgMCA/IC0xIDogMTtcbiAgY29uc3QgYWJzID0gTWF0aC5hYnModmFsdWUpO1xuICBpZiAoYWJzID4gMzEzMDhlLTcpIHtcbiAgICByZXR1cm4gc2lnbiAqICgxLjA1NSAqIGFicyAqKiAoMSAvIDIuNCkgLSAwLjA1NSk7XG4gIH1cbiAgcmV0dXJuIDEyLjkyICogdmFsdWU7XG59O1xudmFyIF9Db2xvciA9IGNsYXNzIF9Db2xvciB7XG4gIC8qKlxuICAgKiBFdmVyeSBjb2xvciBjb21wb25lbnQgc2hvdWxkIGJlIGluIHRoZSBbMCwgMV0gcmFuZ2UuXG4gICAqIFNvbWUgZWFzaW5nIGZ1bmN0aW9ucyAoc3VjaCBhcyBlbGFzdGljIGVhc2luZykgY2FuIG92ZXJzaG9vdCB0aGUgdGFyZ2V0IHZhbHVlIGJ5IHNvbWUgYW1vdW50LlxuICAgKiBTbywgd2hlbiBhbmltYXRpbmcgY29sb3JzLCBpZiB0aGUgc291cmNlIG9yIHRhcmdldCBjb2xvciBjb21wb25lbnRzIGFyZSBhbHJlYWR5IG5lYXJcbiAgICogb3IgYXQgdGhlIGVkZ2Ugb2YgdGhlIGFsbG93ZWQgWzAsIDFdIHJhbmdlLCBpdCBpcyBwb3NzaWJsZSBmb3IgdGhlIGludGVybWVkaWF0ZSBjb2xvclxuICAgKiBjb21wb25lbnQgdmFsdWUgdG8gZW5kIHVwIG91dHNpZGUgb2YgdGhhdCByYW5nZSBtaWQtYW5pbWF0aW9uLiBGb3IgdGhpcyByZWFzb24gdGhlIGNvbnN0cnVjdG9yXG4gICAqIHBlcmZvcm1zIHJhbmdlIGNoZWNraW5nL2NvbnN0cmFpbmluZy5cbiAgICogQHBhcmFtIHIgUmVkIGNvbXBvbmVudC5cbiAgICogQHBhcmFtIGcgR3JlZW4gY29tcG9uZW50LlxuICAgKiBAcGFyYW0gYiBCbHVlIGNvbXBvbmVudC5cbiAgICogQHBhcmFtIGEgQWxwaGEgKG9wYWNpdHkpIGNvbXBvbmVudC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHIsIGcsIGIsIGEgPSAxKSB7XG4gICAgdGhpcy5yID0gY2xhbXAoMCwgciB8fCAwLCAxKTtcbiAgICB0aGlzLmcgPSBjbGFtcCgwLCBnIHx8IDAsIDEpO1xuICAgIHRoaXMuYiA9IGNsYW1wKDAsIGIgfHwgMCwgMSk7XG4gICAgdGhpcy5hID0gY2xhbXAoMCwgYSB8fCAwLCAxKTtcbiAgfVxuICAvKipcbiAgICogQSBjb2xvciBzdHJpbmcgY2FuIGJlIGluIG9uZSBvZiB0aGUgZm9sbG93aW5nIGZvcm1hdHMgdG8gYmUgdmFsaWQ6XG4gICAqIC0gI3JnYlxuICAgKiAtICNycmdnYmJcbiAgICogLSByZ2IociwgZywgYilcbiAgICogLSByZ2JhKHIsIGcsIGIsIGEpXG4gICAqIC0gQ1NTIGNvbG9yIG5hbWUgc3VjaCBhcyAnd2hpdGUnLCAnb3JhbmdlJywgJ2N5YW4nLCBldGMuXG4gICAqL1xuICBzdGF0aWMgdmFsaWRDb2xvclN0cmluZyhzdHIpIHtcbiAgICBpZiAoc3RyLmluZGV4T2YoXCIjXCIpID49IDApIHtcbiAgICAgIHJldHVybiAhIV9Db2xvci5wYXJzZUhleChzdHIpO1xuICAgIH1cbiAgICBpZiAoc3RyLmluZGV4T2YoXCJyZ2JcIikgPj0gMCkge1xuICAgICAgcmV0dXJuICEhX0NvbG9yLnN0cmluZ1RvUmdiYShzdHIpO1xuICAgIH1cbiAgICByZXR1cm4gISFfQ29sb3IubmFtZVRvSGV4W3N0ci50b0xvd2VyQ2FzZSgpXTtcbiAgfVxuICAvKipcbiAgICogVGhlIGdpdmVuIHN0cmluZyBjYW4gYmUgaW4gb25lIG9mIHRoZSBmb2xsb3dpbmcgZm9ybWF0czpcbiAgICogLSAjcmdiXG4gICAqIC0gI3JyZ2diYlxuICAgKiAtIHJnYihyLCBnLCBiKVxuICAgKiAtIHJnYmEociwgZywgYiwgYSlcbiAgICogLSBDU1MgY29sb3IgbmFtZSBzdWNoIGFzICd3aGl0ZScsICdvcmFuZ2UnLCAnY3lhbicsIGV0Yy5cbiAgICogQHBhcmFtIHN0clxuICAgKi9cbiAgc3RhdGljIGZyb21TdHJpbmcoc3RyKSB7XG4gICAgaWYgKHN0ci5pbmRleE9mKFwiI1wiKSA+PSAwKSB7XG4gICAgICByZXR1cm4gX0NvbG9yLmZyb21IZXhTdHJpbmcoc3RyKTtcbiAgICB9XG4gICAgY29uc3QgaGV4ID0gX0NvbG9yLm5hbWVUb0hleFtzdHIudG9Mb3dlckNhc2UoKV07XG4gICAgaWYgKGhleCkge1xuICAgICAgcmV0dXJuIF9Db2xvci5mcm9tSGV4U3RyaW5nKGhleCk7XG4gICAgfVxuICAgIGlmIChzdHIuaW5kZXhPZihcInJnYlwiKSA+PSAwKSB7XG4gICAgICByZXR1cm4gX0NvbG9yLmZyb21SZ2JhU3RyaW5nKHN0cik7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjb2xvciBzdHJpbmc6ICcke3N0cn0nYCk7XG4gIH1cbiAgLy8gU2VlIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3MtY29sb3IvI2hleC1ub3RhdGlvblxuICBzdGF0aWMgcGFyc2VIZXgoaW5wdXQpIHtcbiAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoLyAvZywgXCJcIikuc2xpY2UoMSk7XG4gICAgbGV0IHBhcnRzO1xuICAgIHN3aXRjaCAoaW5wdXQubGVuZ3RoKSB7XG4gICAgICBjYXNlIDY6XG4gICAgICBjYXNlIDg6XG4gICAgICAgIHBhcnRzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKHBhcnNlSW50KGAke2lucHV0W2ldfSR7aW5wdXRbaSArIDFdfWAsIDE2KSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHBhcnRzID0gaW5wdXQuc3BsaXQoXCJcIikubWFwKChwKSA9PiBwYXJzZUludChwLCAxNikpLm1hcCgocCkgPT4gcCArIHAgKiAxNik7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAocGFydHM/Lmxlbmd0aCA+PSAzICYmIHBhcnRzLmV2ZXJ5KChwKSA9PiBwID49IDApKSB7XG4gICAgICBpZiAocGFydHMubGVuZ3RoID09PSAzKSB7XG4gICAgICAgIHBhcnRzLnB1c2goMjU1KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJ0cztcbiAgICB9XG4gIH1cbiAgc3RhdGljIGZyb21IZXhTdHJpbmcoc3RyKSB7XG4gICAgY29uc3QgdmFsdWVzID0gX0NvbG9yLnBhcnNlSGV4KHN0cik7XG4gICAgaWYgKHZhbHVlcykge1xuICAgICAgY29uc3QgW3IsIGcsIGIsIGFdID0gdmFsdWVzO1xuICAgICAgcmV0dXJuIG5ldyBfQ29sb3IociAvIDI1NSwgZyAvIDI1NSwgYiAvIDI1NSwgYSAvIDI1NSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgTWFsZm9ybWVkIGhleGFkZWNpbWFsIGNvbG9yIHN0cmluZzogJyR7c3RyfSdgKTtcbiAgfVxuICBzdGF0aWMgc3RyaW5nVG9SZ2JhKHN0cikge1xuICAgIGxldCBwbyA9IC0xO1xuICAgIGxldCBwYyA9IC0xO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjID0gc3RyW2ldO1xuICAgICAgaWYgKHBvID09PSAtMSAmJiBjID09PSBcIihcIikge1xuICAgICAgICBwbyA9IGk7XG4gICAgICB9IGVsc2UgaWYgKGMgPT09IFwiKVwiKSB7XG4gICAgICAgIHBjID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwbyA9PT0gLTEgfHwgcGMgPT09IC0xKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGNvbnRlbnRzID0gc3RyLnN1YnN0cmluZyhwbyArIDEsIHBjKTtcbiAgICBjb25zdCBwYXJ0cyA9IGNvbnRlbnRzLnNwbGl0KFwiLFwiKTtcbiAgICBjb25zdCByZ2JhID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgbGV0IHZhbHVlID0gcGFyc2VGbG9hdChwYXJ0KTtcbiAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAocGFydC5pbmRleE9mKFwiJVwiKSA+PSAwKSB7XG4gICAgICAgIHZhbHVlID0gY2xhbXAoMCwgdmFsdWUsIDEwMCk7XG4gICAgICAgIHZhbHVlIC89IDEwMDtcbiAgICAgIH0gZWxzZSBpZiAoaSA9PT0gMykge1xuICAgICAgICB2YWx1ZSA9IGNsYW1wKDAsIHZhbHVlLCAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gY2xhbXAoMCwgdmFsdWUsIDI1NSk7XG4gICAgICAgIHZhbHVlIC89IDI1NTtcbiAgICAgIH1cbiAgICAgIHJnYmEucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiByZ2JhO1xuICB9XG4gIHN0YXRpYyBmcm9tUmdiYVN0cmluZyhzdHIpIHtcbiAgICBjb25zdCByZ2JhID0gX0NvbG9yLnN0cmluZ1RvUmdiYShzdHIpO1xuICAgIGlmIChyZ2JhKSB7XG4gICAgICBpZiAocmdiYS5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBfQ29sb3IocmdiYVswXSwgcmdiYVsxXSwgcmdiYVsyXSk7XG4gICAgICB9IGVsc2UgaWYgKHJnYmEubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIHJldHVybiBuZXcgX0NvbG9yKHJnYmFbMF0sIHJnYmFbMV0sIHJnYmFbMl0sIHJnYmFbM10pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYE1hbGZvcm1lZCByZ2IvcmdiYSBjb2xvciBzdHJpbmc6ICcke3N0cn0nYCk7XG4gIH1cbiAgc3RhdGljIGZyb21BcnJheShhcnIpIHtcbiAgICBpZiAoYXJyLmxlbmd0aCA9PT0gNCkge1xuICAgICAgcmV0dXJuIG5ldyBfQ29sb3IoYXJyWzBdLCBhcnJbMV0sIGFyclsyXSwgYXJyWzNdKTtcbiAgICB9XG4gICAgaWYgKGFyci5sZW5ndGggPT09IDMpIHtcbiAgICAgIHJldHVybiBuZXcgX0NvbG9yKGFyclswXSwgYXJyWzFdLCBhcnJbMl0pO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZ2l2ZW4gYXJyYXkgc2hvdWxkIGNvbnRhaW4gMyBvciA0IGNvbG9yIGNvbXBvbmVudHMgKG51bWJlcnMpLlwiKTtcbiAgfVxuICBzdGF0aWMgZnJvbUhTQihoLCBzLCBiLCBhbHBoYSA9IDEpIHtcbiAgICBjb25zdCByZ2IgPSBfQ29sb3IuSFNCdG9SR0IoaCwgcywgYik7XG4gICAgcmV0dXJuIG5ldyBfQ29sb3IocmdiWzBdLCByZ2JbMV0sIHJnYlsyXSwgYWxwaGEpO1xuICB9XG4gIHN0YXRpYyBmcm9tSFNMKGgsIHMsIGwsIGFscGhhID0gMSkge1xuICAgIGNvbnN0IHJnYiA9IF9Db2xvci5IU0x0b1JHQihoLCBzLCBsKTtcbiAgICByZXR1cm4gbmV3IF9Db2xvcihyZ2JbMF0sIHJnYlsxXSwgcmdiWzJdLCBhbHBoYSk7XG4gIH1cbiAgc3RhdGljIGZyb21PS0xDSChsLCBjLCBoLCBhbHBoYSA9IDEpIHtcbiAgICBjb25zdCByZ2IgPSBfQ29sb3IuT0tMQ0h0b1JHQihsLCBjLCBoKTtcbiAgICByZXR1cm4gbmV3IF9Db2xvcihyZ2JbMF0sIHJnYlsxXSwgcmdiWzJdLCBhbHBoYSk7XG4gIH1cbiAgc3RhdGljIHBhZEhleChzdHIpIHtcbiAgICByZXR1cm4gc3RyLmxlbmd0aCA9PT0gMSA/IFwiMFwiICsgc3RyIDogc3RyO1xuICB9XG4gIHRvSGV4U3RyaW5nKCkge1xuICAgIGxldCBoZXggPSBcIiNcIiArIF9Db2xvci5wYWRIZXgoTWF0aC5yb3VuZCh0aGlzLnIgKiAyNTUpLnRvU3RyaW5nKDE2KSkgKyBfQ29sb3IucGFkSGV4KE1hdGgucm91bmQodGhpcy5nICogMjU1KS50b1N0cmluZygxNikpICsgX0NvbG9yLnBhZEhleChNYXRoLnJvdW5kKHRoaXMuYiAqIDI1NSkudG9TdHJpbmcoMTYpKTtcbiAgICBpZiAodGhpcy5hIDwgMSkge1xuICAgICAgaGV4ICs9IF9Db2xvci5wYWRIZXgoTWF0aC5yb3VuZCh0aGlzLmEgKiAyNTUpLnRvU3RyaW5nKDE2KSk7XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG4gIH1cbiAgdG9SZ2JhU3RyaW5nKGZyYWN0aW9uRGlnaXRzID0gMykge1xuICAgIGNvbnN0IGNvbXBvbmVudHMgPSBbTWF0aC5yb3VuZCh0aGlzLnIgKiAyNTUpLCBNYXRoLnJvdW5kKHRoaXMuZyAqIDI1NSksIE1hdGgucm91bmQodGhpcy5iICogMjU1KV07XG4gICAgY29uc3QgayA9IE1hdGgucG93KDEwLCBmcmFjdGlvbkRpZ2l0cyk7XG4gICAgaWYgKHRoaXMuYSAhPT0gMSkge1xuICAgICAgY29tcG9uZW50cy5wdXNoKE1hdGgucm91bmQodGhpcy5hICogaykgLyBrKTtcbiAgICAgIHJldHVybiBgcmdiYSgke2NvbXBvbmVudHMuam9pbihcIiwgXCIpfSlgO1xuICAgIH1cbiAgICByZXR1cm4gYHJnYigke2NvbXBvbmVudHMuam9pbihcIiwgXCIpfSlgO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIGlmICh0aGlzLmEgPT09IDEpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvSGV4U3RyaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRvUmdiYVN0cmluZygpO1xuICB9XG4gIHRvSFNCKCkge1xuICAgIHJldHVybiBfQ29sb3IuUkdCdG9IU0IodGhpcy5yLCB0aGlzLmcsIHRoaXMuYik7XG4gIH1cbiAgc3RhdGljIFJHQnRvT0tMQ0gociwgZywgYikge1xuICAgIGNvbnN0IExTUkdCMCA9IHNyZ2JUb0xpbmVhcihyKTtcbiAgICBjb25zdCBMU1JHQjEgPSBzcmdiVG9MaW5lYXIoZyk7XG4gICAgY29uc3QgTFNSR0IyID0gc3JnYlRvTGluZWFyKGIpO1xuICAgIGNvbnN0IExNUzAgPSBNYXRoLmNicnQoMC40MTIyMjE0NzA4ICogTFNSR0IwICsgMC41MzYzMzI1MzYzICogTFNSR0IxICsgMC4wNTE0NDU5OTI5ICogTFNSR0IyKTtcbiAgICBjb25zdCBMTVMxID0gTWF0aC5jYnJ0KDAuMjExOTAzNDk4MiAqIExTUkdCMCArIDAuNjgwNjk5NTQ1MSAqIExTUkdCMSArIDAuMTA3Mzk2OTU2NiAqIExTUkdCMik7XG4gICAgY29uc3QgTE1TMiA9IE1hdGguY2JydCgwLjA4ODMwMjQ2MTkgKiBMU1JHQjAgKyAwLjI4MTcxODgzNzYgKiBMU1JHQjEgKyAwLjYyOTk3ODcwMDUgKiBMU1JHQjIpO1xuICAgIGNvbnN0IE9LTEFCMCA9IDAuMjEwNDU0MjU1MyAqIExNUzAgKyAwLjc5MzYxNzc4NSAqIExNUzEgLSAwLjAwNDA3MjA0NjggKiBMTVMyO1xuICAgIGNvbnN0IE9LTEFCMSA9IDEuOTc3OTk4NDk1MSAqIExNUzAgLSAyLjQyODU5MjIwNSAqIExNUzEgKyAwLjQ1MDU5MzcwOTkgKiBMTVMyO1xuICAgIGNvbnN0IE9LTEFCMiA9IDAuMDI1OTA0MDM3MSAqIExNUzAgKyAwLjc4Mjc3MTc2NjIgKiBMTVMxIC0gMC44MDg2NzU3NjYgKiBMTVMyO1xuICAgIGNvbnN0IGh1ZSA9IE1hdGguYXRhbjIoT0tMQUIyLCBPS0xBQjEpICogMTgwIC8gTWF0aC5QSTtcbiAgICBjb25zdCBPS0xDSDAgPSBPS0xBQjA7XG4gICAgY29uc3QgT0tMQ0gxID0gTWF0aC5oeXBvdChPS0xBQjEsIE9LTEFCMik7XG4gICAgY29uc3QgT0tMQ0gyID0gaHVlID49IDAgPyBodWUgOiBodWUgKyAzNjA7XG4gICAgcmV0dXJuIFtPS0xDSDAsIE9LTENIMSwgT0tMQ0gyXTtcbiAgfVxuICBzdGF0aWMgT0tMQ0h0b1JHQihsLCBjLCBoKSB7XG4gICAgY29uc3QgT0tMQUIwID0gbDtcbiAgICBjb25zdCBPS0xBQjEgPSBjICogTWF0aC5jb3MoaCAqIE1hdGguUEkgLyAxODApO1xuICAgIGNvbnN0IE9LTEFCMiA9IGMgKiBNYXRoLnNpbihoICogTWF0aC5QSSAvIDE4MCk7XG4gICAgY29uc3QgTE1TMCA9IChPS0xBQjAgKyAwLjM5NjMzNzc3NzQgKiBPS0xBQjEgKyAwLjIxNTgwMzc1NzMgKiBPS0xBQjIpICoqIDM7XG4gICAgY29uc3QgTE1TMSA9IChPS0xBQjAgLSAwLjEwNTU2MTM0NTggKiBPS0xBQjEgLSAwLjA2Mzg1NDE3MjggKiBPS0xBQjIpICoqIDM7XG4gICAgY29uc3QgTE1TMiA9IChPS0xBQjAgLSAwLjA4OTQ4NDE3NzUgKiBPS0xBQjEgLSAxLjI5MTQ4NTU0OCAqIE9LTEFCMikgKiogMztcbiAgICBjb25zdCBMU1JHQjAgPSA0LjA3Njc0MTY2MjEgKiBMTVMwIC0gMy4zMDc3MTE1OTEzICogTE1TMSArIDAuMjMwOTY5OTI5MiAqIExNUzI7XG4gICAgY29uc3QgTFNSR0IxID0gLTEuMjY4NDM4MDA0NiAqIExNUzAgKyAyLjYwOTc1NzQwMTEgKiBMTVMxIC0gMC4zNDEzMTkzOTY1ICogTE1TMjtcbiAgICBjb25zdCBMU1JHQjIgPSAtMC4wMDQxOTYwODYzICogTE1TMCAtIDAuNzAzNDE4NjE0NyAqIExNUzEgKyAxLjcwNzYxNDcwMSAqIExNUzI7XG4gICAgY29uc3QgU1JHQjAgPSBzcmdiRnJvbUxpbmVhcihMU1JHQjApO1xuICAgIGNvbnN0IFNSR0IxID0gc3JnYkZyb21MaW5lYXIoTFNSR0IxKTtcbiAgICBjb25zdCBTUkdCMiA9IHNyZ2JGcm9tTGluZWFyKExTUkdCMik7XG4gICAgcmV0dXJuIFtTUkdCMCwgU1JHQjEsIFNSR0IyXTtcbiAgfVxuICBzdGF0aWMgUkdCdG9IU0wociwgZywgYikge1xuICAgIGNvbnN0IG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuICAgIGNvbnN0IGwgPSAobWF4ICsgbWluKSAvIDI7XG4gICAgbGV0IGg7XG4gICAgbGV0IHM7XG4gICAgaWYgKG1heCA9PT0gbWluKSB7XG4gICAgICBoID0gMDtcbiAgICAgIHMgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBkZWx0YTQgPSBtYXggLSBtaW47XG4gICAgICBzID0gbCA+IDAuNSA/IGRlbHRhNCAvICgyIC0gbWF4IC0gbWluKSA6IGRlbHRhNCAvIChtYXggKyBtaW4pO1xuICAgICAgaWYgKG1heCA9PT0gcikge1xuICAgICAgICBoID0gKGcgLSBiKSAvIGRlbHRhNCArIChnIDwgYiA/IDYgOiAwKTtcbiAgICAgIH0gZWxzZSBpZiAobWF4ID09PSBnKSB7XG4gICAgICAgIGggPSAoYiAtIHIpIC8gZGVsdGE0ICsgMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGggPSAociAtIGcpIC8gZGVsdGE0ICsgNDtcbiAgICAgIH1cbiAgICAgIGggKj0gMzYwIC8gNjtcbiAgICB9XG4gICAgcmV0dXJuIFtoLCBzLCBsXTtcbiAgfVxuICBzdGF0aWMgSFNMdG9SR0IoaCwgcywgbCkge1xuICAgIGggPSAoaCAlIDM2MCArIDM2MCkgJSAzNjA7XG4gICAgaWYgKHMgPT09IDApIHtcbiAgICAgIHJldHVybiBbbCwgbCwgbF07XG4gICAgfVxuICAgIGNvbnN0IHEgPSBsIDwgMC41ID8gbCAqICgxICsgcykgOiBsICsgcyAtIGwgKiBzO1xuICAgIGNvbnN0IHAgPSAyICogbCAtIHE7XG4gICAgZnVuY3Rpb24gaHVlVG9SZ2IodCkge1xuICAgICAgaWYgKHQgPCAwKVxuICAgICAgICB0ICs9IDE7XG4gICAgICBpZiAodCA+IDEpXG4gICAgICAgIHQgLT0gMTtcbiAgICAgIGlmICh0IDwgMSAvIDYpXG4gICAgICAgIHJldHVybiBwICsgKHEgLSBwKSAqIDYgKiB0O1xuICAgICAgaWYgKHQgPCAxIC8gMilcbiAgICAgICAgcmV0dXJuIHE7XG4gICAgICBpZiAodCA8IDIgLyAzKVxuICAgICAgICByZXR1cm4gcCArIChxIC0gcCkgKiAoMiAvIDMgLSB0KSAqIDY7XG4gICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgY29uc3QgciA9IGh1ZVRvUmdiKGggLyAzNjAgKyAxIC8gMyk7XG4gICAgY29uc3QgZyA9IGh1ZVRvUmdiKGggLyAzNjApO1xuICAgIGNvbnN0IGIgPSBodWVUb1JnYihoIC8gMzYwIC0gMSAvIDMpO1xuICAgIHJldHVybiBbciwgZywgYl07XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBnaXZlbiBSR0IgdHJpcGxlIHRvIGFuIGFycmF5IG9mIEhTQiAoSFNWKSBjb21wb25lbnRzLlxuICAgKi9cbiAgc3RhdGljIFJHQnRvSFNCKHIsIGcsIGIpIHtcbiAgICBjb25zdCBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcbiAgICBjb25zdCBtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcbiAgICBjb25zdCBTID0gbWF4ID09PSAwID8gMCA6IChtYXggLSBtaW4pIC8gbWF4O1xuICAgIGxldCBIID0gMDtcbiAgICBpZiAobWluICE9PSBtYXgpIHtcbiAgICAgIGNvbnN0IGRlbHRhNCA9IG1heCAtIG1pbjtcbiAgICAgIGNvbnN0IHJjID0gKG1heCAtIHIpIC8gZGVsdGE0O1xuICAgICAgY29uc3QgZ2MgPSAobWF4IC0gZykgLyBkZWx0YTQ7XG4gICAgICBjb25zdCBiYyA9IChtYXggLSBiKSAvIGRlbHRhNDtcbiAgICAgIGlmIChyID09PSBtYXgpIHtcbiAgICAgICAgSCA9IGJjIC0gZ2M7XG4gICAgICB9IGVsc2UgaWYgKGcgPT09IG1heCkge1xuICAgICAgICBIID0gMiArIHJjIC0gYmM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBIID0gNCArIGdjIC0gcmM7XG4gICAgICB9XG4gICAgICBIIC89IDY7XG4gICAgICBpZiAoSCA8IDApIHtcbiAgICAgICAgSCA9IEggKyAxO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW0ggKiAzNjAsIFMsIG1heF07XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBnaXZlbiBIU0IgKEhTVikgdHJpcGxlIHRvIGFuIGFycmF5IG9mIFJHQiBjb21wb25lbnRzLlxuICAgKi9cbiAgc3RhdGljIEhTQnRvUkdCKEgsIFMsIEIpIHtcbiAgICBIID0gKEggJSAzNjAgKyAzNjApICUgMzYwIC8gMzYwO1xuICAgIGxldCByID0gMDtcbiAgICBsZXQgZyA9IDA7XG4gICAgbGV0IGIgPSAwO1xuICAgIGlmIChTID09PSAwKSB7XG4gICAgICByID0gZyA9IGIgPSBCO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBoID0gKEggLSBNYXRoLmZsb29yKEgpKSAqIDY7XG4gICAgICBjb25zdCBmID0gaCAtIE1hdGguZmxvb3IoaCk7XG4gICAgICBjb25zdCBwID0gQiAqICgxIC0gUyk7XG4gICAgICBjb25zdCBxID0gQiAqICgxIC0gUyAqIGYpO1xuICAgICAgY29uc3QgdCA9IEIgKiAoMSAtIFMgKiAoMSAtIGYpKTtcbiAgICAgIHN3aXRjaCAoaCA+PiAwKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByID0gQjtcbiAgICAgICAgICBnID0gdDtcbiAgICAgICAgICBiID0gcDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHIgPSBxO1xuICAgICAgICAgIGcgPSBCO1xuICAgICAgICAgIGIgPSBwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgciA9IHA7XG4gICAgICAgICAgZyA9IEI7XG4gICAgICAgICAgYiA9IHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICByID0gcDtcbiAgICAgICAgICBnID0gcTtcbiAgICAgICAgICBiID0gQjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHIgPSB0O1xuICAgICAgICAgIGcgPSBwO1xuICAgICAgICAgIGIgPSBCO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgciA9IEI7XG4gICAgICAgICAgZyA9IHA7XG4gICAgICAgICAgYiA9IHE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbciwgZywgYl07XG4gIH1cbiAgc3RhdGljIG1peChjMCwgYzEsIHQpIHtcbiAgICByZXR1cm4gbmV3IF9Db2xvcihsZXJwKGMwLnIsIGMxLnIsIHQpLCBsZXJwKGMwLmcsIGMxLmcsIHQpLCBsZXJwKGMwLmIsIGMxLmIsIHQpLCBsZXJwKGMwLmEsIGMxLmEsIHQpKTtcbiAgfVxufTtcbi8qKlxuICogQ1NTIENvbG9yIE1vZHVsZSBMZXZlbCA0OlxuICogaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzcy1jb2xvci8jbmFtZWQtY29sb3JzXG4gKi9cbl9Db2xvci5uYW1lVG9IZXggPSB7XG4gIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgX19wcm90b19fOiBudWxsLFxuICBhbGljZWJsdWU6IFwiI0YwRjhGRlwiLFxuICBhbnRpcXVld2hpdGU6IFwiI0ZBRUJEN1wiLFxuICBhcXVhOiBcIiMwMEZGRkZcIixcbiAgYXF1YW1hcmluZTogXCIjN0ZGRkQ0XCIsXG4gIGF6dXJlOiBcIiNGMEZGRkZcIixcbiAgYmVpZ2U6IFwiI0Y1RjVEQ1wiLFxuICBiaXNxdWU6IFwiI0ZGRTRDNFwiLFxuICBibGFjazogXCIjMDAwMDAwXCIsXG4gIGJsYW5jaGVkYWxtb25kOiBcIiNGRkVCQ0RcIixcbiAgYmx1ZTogXCIjMDAwMEZGXCIsXG4gIGJsdWV2aW9sZXQ6IFwiIzhBMkJFMlwiLFxuICBicm93bjogXCIjQTUyQTJBXCIsXG4gIGJ1cmx5d29vZDogXCIjREVCODg3XCIsXG4gIGNhZGV0Ymx1ZTogXCIjNUY5RUEwXCIsXG4gIGNoYXJ0cmV1c2U6IFwiIzdGRkYwMFwiLFxuICBjaG9jb2xhdGU6IFwiI0QyNjkxRVwiLFxuICBjb3JhbDogXCIjRkY3RjUwXCIsXG4gIGNvcm5mbG93ZXJibHVlOiBcIiM2NDk1RURcIixcbiAgY29ybnNpbGs6IFwiI0ZGRjhEQ1wiLFxuICBjcmltc29uOiBcIiNEQzE0M0NcIixcbiAgY3lhbjogXCIjMDBGRkZGXCIsXG4gIGRhcmtibHVlOiBcIiMwMDAwOEJcIixcbiAgZGFya2N5YW46IFwiIzAwOEI4QlwiLFxuICBkYXJrZ29sZGVucm9kOiBcIiNCODg2MEJcIixcbiAgZGFya2dyYXk6IFwiI0E5QTlBOVwiLFxuICBkYXJrZ3JlZW46IFwiIzAwNjQwMFwiLFxuICBkYXJrZ3JleTogXCIjQTlBOUE5XCIsXG4gIGRhcmtraGFraTogXCIjQkRCNzZCXCIsXG4gIGRhcmttYWdlbnRhOiBcIiM4QjAwOEJcIixcbiAgZGFya29saXZlZ3JlZW46IFwiIzU1NkIyRlwiLFxuICBkYXJrb3JhbmdlOiBcIiNGRjhDMDBcIixcbiAgZGFya29yY2hpZDogXCIjOTkzMkNDXCIsXG4gIGRhcmtyZWQ6IFwiIzhCMDAwMFwiLFxuICBkYXJrc2FsbW9uOiBcIiNFOTk2N0FcIixcbiAgZGFya3NlYWdyZWVuOiBcIiM4RkJDOEZcIixcbiAgZGFya3NsYXRlYmx1ZTogXCIjNDgzRDhCXCIsXG4gIGRhcmtzbGF0ZWdyYXk6IFwiIzJGNEY0RlwiLFxuICBkYXJrc2xhdGVncmV5OiBcIiMyRjRGNEZcIixcbiAgZGFya3R1cnF1b2lzZTogXCIjMDBDRUQxXCIsXG4gIGRhcmt2aW9sZXQ6IFwiIzk0MDBEM1wiLFxuICBkZWVwcGluazogXCIjRkYxNDkzXCIsXG4gIGRlZXBza3libHVlOiBcIiMwMEJGRkZcIixcbiAgZGltZ3JheTogXCIjNjk2OTY5XCIsXG4gIGRpbWdyZXk6IFwiIzY5Njk2OVwiLFxuICBkb2RnZXJibHVlOiBcIiMxRTkwRkZcIixcbiAgZmlyZWJyaWNrOiBcIiNCMjIyMjJcIixcbiAgZmxvcmFsd2hpdGU6IFwiI0ZGRkFGMFwiLFxuICBmb3Jlc3RncmVlbjogXCIjMjI4QjIyXCIsXG4gIGZ1Y2hzaWE6IFwiI0ZGMDBGRlwiLFxuICBnYWluc2Jvcm86IFwiI0RDRENEQ1wiLFxuICBnaG9zdHdoaXRlOiBcIiNGOEY4RkZcIixcbiAgZ29sZDogXCIjRkZENzAwXCIsXG4gIGdvbGRlbnJvZDogXCIjREFBNTIwXCIsXG4gIGdyYXk6IFwiIzgwODA4MFwiLFxuICBncmVlbjogXCIjMDA4MDAwXCIsXG4gIGdyZWVueWVsbG93OiBcIiNBREZGMkZcIixcbiAgZ3JleTogXCIjODA4MDgwXCIsXG4gIGhvbmV5ZGV3OiBcIiNGMEZGRjBcIixcbiAgaG90cGluazogXCIjRkY2OUI0XCIsXG4gIGluZGlhbnJlZDogXCIjQ0Q1QzVDXCIsXG4gIGluZGlnbzogXCIjNEIwMDgyXCIsXG4gIGl2b3J5OiBcIiNGRkZGRjBcIixcbiAga2hha2k6IFwiI0YwRTY4Q1wiLFxuICBsYXZlbmRlcjogXCIjRTZFNkZBXCIsXG4gIGxhdmVuZGVyYmx1c2g6IFwiI0ZGRjBGNVwiLFxuICBsYXduZ3JlZW46IFwiIzdDRkMwMFwiLFxuICBsZW1vbmNoaWZmb246IFwiI0ZGRkFDRFwiLFxuICBsaWdodGJsdWU6IFwiI0FERDhFNlwiLFxuICBsaWdodGNvcmFsOiBcIiNGMDgwODBcIixcbiAgbGlnaHRjeWFuOiBcIiNFMEZGRkZcIixcbiAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IFwiI0ZBRkFEMlwiLFxuICBsaWdodGdyYXk6IFwiI0QzRDNEM1wiLFxuICBsaWdodGdyZWVuOiBcIiM5MEVFOTBcIixcbiAgbGlnaHRncmV5OiBcIiNEM0QzRDNcIixcbiAgbGlnaHRwaW5rOiBcIiNGRkI2QzFcIixcbiAgbGlnaHRzYWxtb246IFwiI0ZGQTA3QVwiLFxuICBsaWdodHNlYWdyZWVuOiBcIiMyMEIyQUFcIixcbiAgbGlnaHRza3libHVlOiBcIiM4N0NFRkFcIixcbiAgbGlnaHRzbGF0ZWdyYXk6IFwiIzc3ODg5OVwiLFxuICBsaWdodHNsYXRlZ3JleTogXCIjNzc4ODk5XCIsXG4gIGxpZ2h0c3RlZWxibHVlOiBcIiNCMEM0REVcIixcbiAgbGlnaHR5ZWxsb3c6IFwiI0ZGRkZFMFwiLFxuICBsaW1lOiBcIiMwMEZGMDBcIixcbiAgbGltZWdyZWVuOiBcIiMzMkNEMzJcIixcbiAgbGluZW46IFwiI0ZBRjBFNlwiLFxuICBtYWdlbnRhOiBcIiNGRjAwRkZcIixcbiAgbWFyb29uOiBcIiM4MDAwMDBcIixcbiAgbWVkaXVtYXF1YW1hcmluZTogXCIjNjZDREFBXCIsXG4gIG1lZGl1bWJsdWU6IFwiIzAwMDBDRFwiLFxuICBtZWRpdW1vcmNoaWQ6IFwiI0JBNTVEM1wiLFxuICBtZWRpdW1wdXJwbGU6IFwiIzkzNzBEQlwiLFxuICBtZWRpdW1zZWFncmVlbjogXCIjM0NCMzcxXCIsXG4gIG1lZGl1bXNsYXRlYmx1ZTogXCIjN0I2OEVFXCIsXG4gIG1lZGl1bXNwcmluZ2dyZWVuOiBcIiMwMEZBOUFcIixcbiAgbWVkaXVtdHVycXVvaXNlOiBcIiM0OEQxQ0NcIixcbiAgbWVkaXVtdmlvbGV0cmVkOiBcIiNDNzE1ODVcIixcbiAgbWlkbmlnaHRibHVlOiBcIiMxOTE5NzBcIixcbiAgbWludGNyZWFtOiBcIiNGNUZGRkFcIixcbiAgbWlzdHlyb3NlOiBcIiNGRkU0RTFcIixcbiAgbW9jY2FzaW46IFwiI0ZGRTRCNVwiLFxuICBuYXZham93aGl0ZTogXCIjRkZERUFEXCIsXG4gIG5hdnk6IFwiIzAwMDA4MFwiLFxuICBvbGRsYWNlOiBcIiNGREY1RTZcIixcbiAgb2xpdmU6IFwiIzgwODAwMFwiLFxuICBvbGl2ZWRyYWI6IFwiIzZCOEUyM1wiLFxuICBvcmFuZ2U6IFwiI0ZGQTUwMFwiLFxuICBvcmFuZ2VyZWQ6IFwiI0ZGNDUwMFwiLFxuICBvcmNoaWQ6IFwiI0RBNzBENlwiLFxuICBwYWxlZ29sZGVucm9kOiBcIiNFRUU4QUFcIixcbiAgcGFsZWdyZWVuOiBcIiM5OEZCOThcIixcbiAgcGFsZXR1cnF1b2lzZTogXCIjQUZFRUVFXCIsXG4gIHBhbGV2aW9sZXRyZWQ6IFwiI0RCNzA5M1wiLFxuICBwYXBheWF3aGlwOiBcIiNGRkVGRDVcIixcbiAgcGVhY2hwdWZmOiBcIiNGRkRBQjlcIixcbiAgcGVydTogXCIjQ0Q4NTNGXCIsXG4gIHBpbms6IFwiI0ZGQzBDQlwiLFxuICBwbHVtOiBcIiNEREEwRERcIixcbiAgcG93ZGVyYmx1ZTogXCIjQjBFMEU2XCIsXG4gIHB1cnBsZTogXCIjODAwMDgwXCIsXG4gIHJlYmVjY2FwdXJwbGU6IFwiIzY2MzM5OVwiLFxuICByZWQ6IFwiI0ZGMDAwMFwiLFxuICByb3N5YnJvd246IFwiI0JDOEY4RlwiLFxuICByb3lhbGJsdWU6IFwiIzQxNjlFMVwiLFxuICBzYWRkbGVicm93bjogXCIjOEI0NTEzXCIsXG4gIHNhbG1vbjogXCIjRkE4MDcyXCIsXG4gIHNhbmR5YnJvd246IFwiI0Y0QTQ2MFwiLFxuICBzZWFncmVlbjogXCIjMkU4QjU3XCIsXG4gIHNlYXNoZWxsOiBcIiNGRkY1RUVcIixcbiAgc2llbm5hOiBcIiNBMDUyMkRcIixcbiAgc2lsdmVyOiBcIiNDMEMwQzBcIixcbiAgc2t5Ymx1ZTogXCIjODdDRUVCXCIsXG4gIHNsYXRlYmx1ZTogXCIjNkE1QUNEXCIsXG4gIHNsYXRlZ3JheTogXCIjNzA4MDkwXCIsXG4gIHNsYXRlZ3JleTogXCIjNzA4MDkwXCIsXG4gIHNub3c6IFwiI0ZGRkFGQVwiLFxuICBzcHJpbmdncmVlbjogXCIjMDBGRjdGXCIsXG4gIHN0ZWVsYmx1ZTogXCIjNDY4MkI0XCIsXG4gIHRhbjogXCIjRDJCNDhDXCIsXG4gIHRlYWw6IFwiIzAwODA4MFwiLFxuICB0aGlzdGxlOiBcIiNEOEJGRDhcIixcbiAgdG9tYXRvOiBcIiNGRjYzNDdcIixcbiAgdHJhbnNwYXJlbnQ6IFwiIzAwMDAwMDAwXCIsXG4gIHR1cnF1b2lzZTogXCIjNDBFMEQwXCIsXG4gIHZpb2xldDogXCIjRUU4MkVFXCIsXG4gIHdoZWF0OiBcIiNGNURFQjNcIixcbiAgd2hpdGU6IFwiI0ZGRkZGRlwiLFxuICB3aGl0ZXNtb2tlOiBcIiNGNUY1RjVcIixcbiAgeWVsbG93OiBcIiNGRkZGMDBcIixcbiAgeWVsbG93Z3JlZW46IFwiIzlBQ0QzMlwiXG59O1xudmFyIENvbG9yID0gX0NvbG9yO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2ludGVycG9sYXRlLnRzXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZU51bWJlcihhLCBiKSB7XG4gIHJldHVybiAoZCkgPT4gTnVtYmVyKGEpICogKDEgLSBkKSArIE51bWJlcihiKSAqIGQ7XG59XG5mdW5jdGlvbiBpbnRlcnBvbGF0ZUNvbG9yKGEsIGIpIHtcbiAgaWYgKHR5cGVvZiBhID09PSBcInN0cmluZ1wiKSB7XG4gICAgdHJ5IHtcbiAgICAgIGEgPSBDb2xvci5mcm9tU3RyaW5nKGEpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGEgPSBDb2xvci5mcm9tQXJyYXkoWzAsIDAsIDBdKTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiBiID09PSBcInN0cmluZ1wiKSB7XG4gICAgdHJ5IHtcbiAgICAgIGIgPSBDb2xvci5mcm9tU3RyaW5nKGIpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGIgPSBDb2xvci5mcm9tQXJyYXkoWzAsIDAsIDBdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIChkKSA9PiBDb2xvci5taXgoYSwgYiwgZCkudG9SZ2JhU3RyaW5nKCk7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvZGVjb3JhdG9yLnRzXG52YXIgQlJFQUtfVFJBTlNGT1JNX0NIQUlOID0gU3ltYm9sKFwiQlJFQUtcIik7XG52YXIgQ09ORklHX0tFWSA9IFwiX19kZWNvcmF0b3JfY29uZmlnXCI7XG5mdW5jdGlvbiBpbml0aWFsaXNlQ29uZmlnKHRhcmdldCwgcHJvcGVydHlLZXlPclN5bWJvbCkge1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIENPTkZJR19LRVkpID09IG51bGwpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBDT05GSUdfS0VZLCB7IHZhbHVlOiB7fSB9KTtcbiAgfVxuICBjb25zdCBjb25maWcgPSB0YXJnZXRbQ09ORklHX0tFWV07XG4gIGNvbnN0IHByb3BlcnR5S2V5ID0gcHJvcGVydHlLZXlPclN5bWJvbC50b1N0cmluZygpO1xuICBpZiAodHlwZW9mIGNvbmZpZ1twcm9wZXJ0eUtleV0gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gY29uZmlnW3Byb3BlcnR5S2V5XTtcbiAgfVxuICBjb25zdCB2YWx1ZXNNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgY29uZmlnW3Byb3BlcnR5S2V5XSA9IHsgc2V0dGVyczogW10sIGdldHRlcnM6IFtdLCBvYnNlcnZlcnM6IFtdLCB2YWx1ZXNNYXAgfTtcbiAgY29uc3QgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wZXJ0eUtleU9yU3ltYm9sKTtcbiAgY29uc3QgcHJldlNldCA9IGRlc2NyaXB0b3I/LnNldDtcbiAgY29uc3QgcHJldkdldCA9IGRlc2NyaXB0b3I/LmdldDtcbiAgY29uc3QgZ2V0dGVyID0gZnVuY3Rpb24oKSB7XG4gICAgbGV0IHZhbHVlID0gcHJldkdldCA/IHByZXZHZXQuY2FsbCh0aGlzKSA6IHZhbHVlc01hcC5nZXQodGhpcyk7XG4gICAgZm9yIChjb25zdCB0cmFuc2Zvcm1GbiBvZiBjb25maWdbcHJvcGVydHlLZXldLmdldHRlcnMpIHtcbiAgICAgIHZhbHVlID0gdHJhbnNmb3JtRm4odGhpcywgcHJvcGVydHlLZXlPclN5bWJvbCwgdmFsdWUpO1xuICAgICAgaWYgKHZhbHVlID09PSBCUkVBS19UUkFOU0ZPUk1fQ0hBSU4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG4gIGNvbnN0IHNldHRlciA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgY29uc3QgeyBzZXR0ZXJzLCBvYnNlcnZlcnMgfSA9IGNvbmZpZ1twcm9wZXJ0eUtleV07XG4gICAgbGV0IG9sZFZhbHVlO1xuICAgIGlmIChzZXR0ZXJzLnNvbWUoKGYpID0+IGYubGVuZ3RoID4gMikpIHtcbiAgICAgIG9sZFZhbHVlID0gcHJldkdldCA/IHByZXZHZXQuY2FsbCh0aGlzKSA6IHZhbHVlc01hcC5nZXQodGhpcyk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgdHJhbnNmb3JtRm4gb2Ygc2V0dGVycykge1xuICAgICAgdmFsdWUgPSB0cmFuc2Zvcm1Gbih0aGlzLCBwcm9wZXJ0eUtleU9yU3ltYm9sLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgaWYgKHZhbHVlID09PSBCUkVBS19UUkFOU0ZPUk1fQ0hBSU4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJldlNldCkge1xuICAgICAgcHJldlNldC5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWVzTWFwLnNldCh0aGlzLCB2YWx1ZSk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgb2JzZXJ2ZXJGbiBvZiBvYnNlcnZlcnMpIHtcbiAgICAgIG9ic2VydmVyRm4odGhpcywgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICB9XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5T3JTeW1ib2wsIHtcbiAgICBzZXQ6IHNldHRlcixcbiAgICBnZXQ6IGdldHRlcixcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgfSk7XG4gIHJldHVybiBjb25maWdbcHJvcGVydHlLZXldO1xufVxuZnVuY3Rpb24gYWRkVHJhbnNmb3JtVG9JbnN0YW5jZVByb3BlcnR5KHNldFRyYW5zZm9ybSwgZ2V0VHJhbnNmb3JtLCBjb25maWdNZXRhZGF0YSkge1xuICByZXR1cm4gKHRhcmdldCwgcHJvcGVydHlLZXlPclN5bWJvbCkgPT4ge1xuICAgIGNvbnN0IGNvbmZpZyA9IGluaXRpYWxpc2VDb25maWcodGFyZ2V0LCBwcm9wZXJ0eUtleU9yU3ltYm9sKTtcbiAgICBjb25maWcuc2V0dGVycy5wdXNoKHNldFRyYW5zZm9ybSk7XG4gICAgaWYgKGdldFRyYW5zZm9ybSkge1xuICAgICAgY29uZmlnLmdldHRlcnMudW5zaGlmdChnZXRUcmFuc2Zvcm0pO1xuICAgIH1cbiAgICBpZiAoY29uZmlnTWV0YWRhdGEpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24oY29uZmlnLCBjb25maWdNZXRhZGF0YSk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gYWRkT2JzZXJ2ZXJUb0luc3RhbmNlUHJvcGVydHkoc2V0T2JzZXJ2ZXIpIHtcbiAgcmV0dXJuICh0YXJnZXQsIHByb3BlcnR5S2V5T3JTeW1ib2wpID0+IHtcbiAgICBpbml0aWFsaXNlQ29uZmlnKHRhcmdldCwgcHJvcGVydHlLZXlPclN5bWJvbCkub2JzZXJ2ZXJzLnB1c2goc2V0T2JzZXJ2ZXIpO1xuICB9O1xufVxuZnVuY3Rpb24gaXNEZWNvcmF0ZWRPYmplY3QodGFyZ2V0KSB7XG4gIHJldHVybiB0eXBlb2YgdGFyZ2V0ICE9PSBcInVuZGVmaW5lZFwiICYmIENPTkZJR19LRVkgaW4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gbGlzdERlY29yYXRlZFByb3BlcnRpZXModGFyZ2V0KSB7XG4gIGNvbnN0IHRhcmdldHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICB3aGlsZSAoaXNEZWNvcmF0ZWRPYmplY3QodGFyZ2V0KSkge1xuICAgIHRhcmdldHMuYWRkKHRhcmdldD8uW0NPTkZJR19LRVldKTtcbiAgICB0YXJnZXQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KTtcbiAgfVxuICByZXR1cm4gQXJyYXkuZnJvbSh0YXJnZXRzKS5mbGF0TWFwKChjb25maWdNYXApID0+IE9iamVjdC5rZXlzKGNvbmZpZ01hcCkpO1xufVxuZnVuY3Rpb24gZXh0cmFjdERlY29yYXRlZFByb3BlcnRpZXModGFyZ2V0KSB7XG4gIHJldHVybiBsaXN0RGVjb3JhdGVkUHJvcGVydGllcyh0YXJnZXQpLnJlZHVjZSgocmVzdWx0LCBrZXkpID0+IHtcbiAgICByZXN1bHRba2V5XSA9IHRhcmdldFtrZXldID8/IG51bGw7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwge30pO1xufVxuZnVuY3Rpb24gZXh0cmFjdERlY29yYXRlZFByb3BlcnR5TWV0YWRhdGEodGFyZ2V0LCBwcm9wZXJ0eUtleU9yU3ltYm9sKSB7XG4gIGNvbnN0IHByb3BlcnR5S2V5ID0gcHJvcGVydHlLZXlPclN5bWJvbC50b1N0cmluZygpO1xuICB3aGlsZSAoaXNEZWNvcmF0ZWRPYmplY3QodGFyZ2V0KSkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRhcmdldFtDT05GSUdfS0VZXTtcbiAgICBpZiAoT2JqZWN0Lmhhc093bihjb25maWcsIHByb3BlcnR5S2V5KSkge1xuICAgICAgcmV0dXJuIGNvbmZpZ1twcm9wZXJ0eUtleV07XG4gICAgfVxuICAgIHRhcmdldCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpO1xuICB9XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvdHlwZS1ndWFyZHMudHNcbmZ1bmN0aW9uIGlzRGVmaW5lZCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPSBudWxsO1xufVxuZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBpc0Jvb2xlYW4odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCI7XG59XG5mdW5jdGlvbiBpc0RhdGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRGF0ZTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWREYXRlKHZhbHVlKSB7XG4gIHJldHVybiBpc0RhdGUodmFsdWUpICYmICFpc05hTihOdW1iZXIodmFsdWUpKTtcbn1cbmZ1bmN0aW9uIGlzUmVnRXhwKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cDtcbn1cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCAmJiAhaXNBcnJheSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIGlzQXJyYXkodmFsdWUpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkgPT09IE9iamVjdC5wcm90b3R5cGU7XG59XG5mdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiO1xufVxuZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIjtcbn1cbmZ1bmN0aW9uIGlzRmluaXRlTnVtYmVyKHZhbHVlKSB7XG4gIHJldHVybiBOdW1iZXIuaXNGaW5pdGUodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNIdG1sRWxlbWVudCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB2YWx1ZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xufVxuZnVuY3Rpb24gaXNFbnVtS2V5KGVudW1PYmplY3QsIGVudW1LZXkpIHtcbiAgcmV0dXJuIGlzU3RyaW5nKGVudW1LZXkpICYmIE9iamVjdC5rZXlzKGVudW1PYmplY3QpLmluY2x1ZGVzKGVudW1LZXkpO1xufVxuZnVuY3Rpb24gaXNFbnVtVmFsdWUoZW51bU9iamVjdCwgZW51bVZhbHVlKSB7XG4gIHJldHVybiBPYmplY3QudmFsdWVzKGVudW1PYmplY3QpLmluY2x1ZGVzKGVudW1WYWx1ZSk7XG59XG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN5bWJvbFwiO1xufVxuZnVuY3Rpb24gZXhjbHVkZXNUeXBlKG9iaiwgZXhjbHVkZWQpIHtcbiAgcmV0dXJuIG9iai50eXBlICE9PSBleGNsdWRlZDtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9vYmplY3QudHNcbmZ1bmN0aW9uIG9iamVjdEVxdWFsV2l0aChhLCBiLCBjbXApIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gYikge1xuICAgIGlmICghKGtleSBpbiBhKSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGNvbnN0IGtleSBpbiBhKSB7XG4gICAgaWYgKCEoa2V5IGluIGIpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghY21wKGFba2V5XSwgYltrZXldKSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGRlZXBNZXJnZSguLi5zb3VyY2VzKSB7XG4gIHJldHVybiBtZXJnZURlZmF1bHRzKC4uLnNvdXJjZXMucmV2ZXJzZSgpKTtcbn1cbmZ1bmN0aW9uIG1lcmdlRGVmYXVsdHMoLi4uc291cmNlcykge1xuICBjb25zdCB0YXJnZXQgPSB7fTtcbiAgZm9yIChjb25zdCBzb3VyY2Ugb2Ygc291cmNlcykge1xuICAgIGlmICghaXNPYmplY3Qoc291cmNlKSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIGNvbnN0IGtleXMgPSBpc0RlY29yYXRlZE9iamVjdChzb3VyY2UpID8gbGlzdERlY29yYXRlZFByb3BlcnRpZXMoc291cmNlKSA6IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgaWYgKGlzUGxhaW5PYmplY3QodGFyZ2V0W2tleV0pICYmIGlzUGxhaW5PYmplY3Qoc291cmNlW2tleV0pKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gbWVyZ2VEZWZhdWx0cyh0YXJnZXRba2V5XSwgc291cmNlW2tleV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPz8gKHRhcmdldFtrZXldID0gc291cmNlW2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gbWVyZ2VBcnJheURlZmF1bHRzKGRhdGFBcnJheSwgLi4uaXRlbURlZmF1bHRzKSB7XG4gIGlmIChpdGVtRGVmYXVsdHMgJiYgaXNBcnJheShkYXRhQXJyYXkpKSB7XG4gICAgcmV0dXJuIGRhdGFBcnJheS5tYXAoKGl0ZW0pID0+IG1lcmdlRGVmYXVsdHMoaXRlbSwgLi4uaXRlbURlZmF1bHRzKSk7XG4gIH1cbiAgcmV0dXJuIGRhdGFBcnJheTtcbn1cbmZ1bmN0aW9uIG1hcFZhbHVlcyhvYmplY3QyLCBtYXBwZXIpIHtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKG9iamVjdDIpLnJlZHVjZShcbiAgICAocmVzdWx0LCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIHJlc3VsdFtrZXldID0gbWFwcGVyKHZhbHVlLCBrZXksIG9iamVjdDIpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIHt9XG4gICk7XG59XG5mdW5jdGlvbiB3aXRob3V0KG9iamVjdDIsIGtleXMpIHtcbiAgY29uc3QgY2xvbmUyID0geyAuLi5vYmplY3QyIH07XG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBkZWxldGUgY2xvbmUyW2tleV07XG4gIH1cbiAgcmV0dXJuIGNsb25lMjtcbn1cbmZ1bmN0aW9uIGdldFBhdGgob2JqZWN0MiwgcGF0aCkge1xuICBjb25zdCBwYXRoQXJyYXkgPSBpc0FycmF5KHBhdGgpID8gcGF0aCA6IHBhdGguc3BsaXQoXCIuXCIpO1xuICByZXR1cm4gcGF0aEFycmF5LnJlZHVjZSgodmFsdWUsIHBhdGhLZXkpID0+IHZhbHVlW3BhdGhLZXldLCBvYmplY3QyKTtcbn1cbnZhciBTS0lQX0pTX0JVSUxUSU5TID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiX19wcm90b19fXCIsIFwiY29uc3RydWN0b3JcIiwgXCJwcm90b3R5cGVcIl0pO1xuZnVuY3Rpb24gc2V0UGF0aChvYmplY3QyLCBwYXRoLCBuZXdWYWx1ZSkge1xuICBjb25zdCBwYXRoQXJyYXkgPSBpc0FycmF5KHBhdGgpID8gcGF0aC5zbGljZSgpIDogcGF0aC5zcGxpdChcIi5cIik7XG4gIGNvbnN0IGxhc3RLZXkgPSBwYXRoQXJyYXkucG9wKCk7XG4gIGlmIChwYXRoQXJyYXkuc29tZSgocCkgPT4gU0tJUF9KU19CVUlMVElOUy5oYXMocCkpKVxuICAgIHJldHVybjtcbiAgY29uc3QgbGFzdE9iamVjdCA9IHBhdGhBcnJheS5yZWR1Y2UoKHZhbHVlLCBwYXRoS2V5KSA9PiB2YWx1ZVtwYXRoS2V5XSwgb2JqZWN0Mik7XG4gIGxhc3RPYmplY3RbbGFzdEtleV0gPSBuZXdWYWx1ZTtcbiAgcmV0dXJuIGxhc3RPYmplY3RbbGFzdEtleV07XG59XG5mdW5jdGlvbiBwYXJ0aWFsQXNzaWduKGtleXNUb0NvcHksIHRhcmdldCwgc291cmNlKSB7XG4gIGlmIChzb3VyY2UgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5c1RvQ29weSkge1xuICAgIGNvbnN0IHZhbHVlID0gc291cmNlW2tleV07XG4gICAgaWYgKHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL21vdGlvbi9lYXNpbmcudHNcbnZhciBlYXNpbmdfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoZWFzaW5nX2V4cG9ydHMsIHtcbiAgZWFzZUluOiAoKSA9PiBlYXNlSW4sXG4gIGVhc2VJbk91dDogKCkgPT4gZWFzZUluT3V0LFxuICBlYXNlSW5PdXRRdWFkOiAoKSA9PiBlYXNlSW5PdXRRdWFkLFxuICBlYXNlSW5RdWFkOiAoKSA9PiBlYXNlSW5RdWFkLFxuICBlYXNlT3V0OiAoKSA9PiBlYXNlT3V0LFxuICBlYXNlT3V0UXVhZDogKCkgPT4gZWFzZU91dFF1YWQsXG4gIGludmVyc2VFYXNlT3V0OiAoKSA9PiBpbnZlcnNlRWFzZU91dCxcbiAgbGluZWFyOiAoKSA9PiBsaW5lYXJcbn0pO1xudmFyIGxpbmVhciA9IChuKSA9PiBuO1xudmFyIGVhc2VJbiA9IChuKSA9PiAxIC0gTWF0aC5jb3MobiAqIE1hdGguUEkgLyAyKTtcbnZhciBlYXNlT3V0ID0gKG4pID0+IE1hdGguc2luKG4gKiBNYXRoLlBJIC8gMik7XG52YXIgZWFzZUluT3V0ID0gKG4pID0+IC0oTWF0aC5jb3MobiAqIE1hdGguUEkpIC0gMSkgLyAyO1xudmFyIGVhc2VJblF1YWQgPSAobikgPT4gbiAqIG47XG52YXIgZWFzZU91dFF1YWQgPSAobikgPT4gMSAtICgxIC0gbikgKiogMjtcbnZhciBlYXNlSW5PdXRRdWFkID0gKG4pID0+IG4gPCAwLjUgPyAyICogbiAqIG4gOiAxIC0gKC0yICogbiArIDIpICoqIDIgLyAyO1xudmFyIGludmVyc2VFYXNlT3V0ID0gKHgpID0+IDIgKiBNYXRoLmFzaW4oeCkgLyBNYXRoLlBJO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9tb3Rpb24vYW5pbWF0aW9uLnRzXG52YXIgUVVJQ0tfVFJBTlNJVElPTiA9IDAuMjtcbnZhciBQSEFTRV9PUkRFUiA9IFtcImluaXRpYWxcIiwgXCJyZW1vdmVcIiwgXCJ1cGRhdGVcIiwgXCJhZGRcIiwgXCJ0cmFpbGluZ1wiLCBcImVuZFwiLCBcIm5vbmVcIl07XG52YXIgUEhBU0VfTUVUQURBVEEgPSB7XG4gIGluaXRpYWw6IHtcbiAgICBhbmltYXRpb25EdXJhdGlvbjogMSxcbiAgICBhbmltYXRpb25EZWxheTogMFxuICB9LFxuICBhZGQ6IHtcbiAgICBhbmltYXRpb25EdXJhdGlvbjogMC4yNSxcbiAgICBhbmltYXRpb25EZWxheTogMC43NVxuICB9LFxuICByZW1vdmU6IHtcbiAgICBhbmltYXRpb25EdXJhdGlvbjogMC4yNSxcbiAgICBhbmltYXRpb25EZWxheTogMFxuICB9LFxuICB1cGRhdGU6IHtcbiAgICBhbmltYXRpb25EdXJhdGlvbjogMC41LFxuICAgIGFuaW1hdGlvbkRlbGF5OiAwLjI1XG4gIH0sXG4gIHRyYWlsaW5nOiB7XG4gICAgYW5pbWF0aW9uRHVyYXRpb246IFFVSUNLX1RSQU5TSVRJT04sXG4gICAgYW5pbWF0aW9uRGVsYXk6IDEsXG4gICAgc2tpcElmTm9FYXJsaWVyQW5pbWF0aW9uczogdHJ1ZVxuICB9LFxuICBlbmQ6IHtcbiAgICBhbmltYXRpb25EZWxheTogMSArIFFVSUNLX1RSQU5TSVRJT04sXG4gICAgYW5pbWF0aW9uRHVyYXRpb246IDAsXG4gICAgc2tpcElmTm9FYXJsaWVyQW5pbWF0aW9uczogdHJ1ZVxuICB9LFxuICBub25lOiB7XG4gICAgYW5pbWF0aW9uRHVyYXRpb246IDAsXG4gICAgYW5pbWF0aW9uRGVsYXk6IDBcbiAgfVxufTtcbnZhciBSZXBlYXRUeXBlID0gLyogQF9fUFVSRV9fICovICgoUmVwZWF0VHlwZTIpID0+IHtcbiAgUmVwZWF0VHlwZTJbXCJMb29wXCJdID0gXCJsb29wXCI7XG4gIFJlcGVhdFR5cGUyW1wiUmV2ZXJzZVwiXSA9IFwicmV2ZXJzZVwiO1xuICByZXR1cm4gUmVwZWF0VHlwZTI7XG59KShSZXBlYXRUeXBlIHx8IHt9KTtcbmZ1bmN0aW9uIGlzTm9kZUFycmF5KGFycmF5Mikge1xuICByZXR1cm4gYXJyYXkyLmV2ZXJ5KChuKSA9PiBuIGluc3RhbmNlb2YgTm9kZSk7XG59XG5mdW5jdGlvbiBkZWNvbnN0cnVjdFNlbGVjdGlvbnNPck5vZGVzKHNlbGVjdGlvbnNPck5vZGVzKSB7XG4gIHJldHVybiBpc05vZGVBcnJheShzZWxlY3Rpb25zT3JOb2RlcykgPyB7IG5vZGVzOiBzZWxlY3Rpb25zT3JOb2Rlcywgc2VsZWN0aW9uczogW10gfSA6IHsgbm9kZXM6IFtdLCBzZWxlY3Rpb25zOiBzZWxlY3Rpb25zT3JOb2RlcyB9O1xufVxuZnVuY3Rpb24gYW5pbWF0aW9uVmFsdWVzRXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYSkgJiYgQXJyYXkuaXNBcnJheShiKSkge1xuICAgIHJldHVybiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5ldmVyeSgodiwgaSkgPT4gYW5pbWF0aW9uVmFsdWVzRXF1YWwodiwgYltpXSkpO1xuICB9IGVsc2UgaWYgKGlzSW50ZXJwb2xhdGluZyhhKSAmJiBpc0ludGVycG9sYXRpbmcoYikpIHtcbiAgICByZXR1cm4gYS5lcXVhbHMoYik7XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChhKSAmJiBpc1BsYWluT2JqZWN0KGIpKSB7XG4gICAgcmV0dXJuIG9iamVjdEVxdWFsV2l0aChhLCBiLCBhbmltYXRpb25WYWx1ZXNFcXVhbCk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxudmFyIEFuaW1hdGlvbiA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHRoaXMuaXNDb21wbGV0ZSA9IGZhbHNlO1xuICAgIHRoaXMuZWxhcHNlZCA9IDA7XG4gICAgdGhpcy5pdGVyYXRpb24gPSAwO1xuICAgIHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG4gICAgdGhpcy5pc1JldmVyc2UgPSBmYWxzZTtcbiAgICB0aGlzLmlkID0gb3B0cy5pZDtcbiAgICB0aGlzLmdyb3VwSWQgPSBvcHRzLmdyb3VwSWQ7XG4gICAgdGhpcy5hdXRvcGxheSA9IG9wdHMuYXV0b3BsYXkgPz8gdHJ1ZTtcbiAgICB0aGlzLmVhc2UgPSBvcHRzLmVhc2UgPz8gbGluZWFyO1xuICAgIHRoaXMucGhhc2UgPSBvcHRzLnBoYXNlO1xuICAgIGNvbnN0IGR1cmF0aW9uUHJvcG9ydGlvbiA9IG9wdHMuZHVyYXRpb24gPz8gUEhBU0VfTUVUQURBVEFbdGhpcy5waGFzZV0uYW5pbWF0aW9uRHVyYXRpb247XG4gICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uUHJvcG9ydGlvbiAqIG9wdHMuZGVmYXVsdER1cmF0aW9uO1xuICAgIHRoaXMuZGVsYXkgPSAob3B0cy5kZWxheSA/PyAwKSAqIG9wdHMuZGVmYXVsdER1cmF0aW9uO1xuICAgIHRoaXMub25Db21wbGV0ZSA9IG9wdHMub25Db21wbGV0ZTtcbiAgICB0aGlzLm9uUGxheSA9IG9wdHMub25QbGF5O1xuICAgIHRoaXMub25TdG9wID0gb3B0cy5vblN0b3A7XG4gICAgdGhpcy5vblVwZGF0ZSA9IG9wdHMub25VcGRhdGU7XG4gICAgdGhpcy5pbnRlcnBvbGF0ZSA9IHRoaXMuY3JlYXRlSW50ZXJwb2xhdG9yKG9wdHMuZnJvbSwgb3B0cy50byk7XG4gICAgdGhpcy5mcm9tID0gb3B0cy5mcm9tO1xuICAgIGlmIChvcHRzLnNraXAgPT09IHRydWUpIHtcbiAgICAgIHRoaXMub25VcGRhdGU/LihvcHRzLnRvLCBmYWxzZSwgdGhpcyk7XG4gICAgICB0aGlzLm9uU3RvcD8uKHRoaXMpO1xuICAgICAgdGhpcy5vbkNvbXBsZXRlPy4odGhpcyk7XG4gICAgICB0aGlzLmlzQ29tcGxldGUgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAob3B0cy5jb2xsYXBzYWJsZSAhPT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuZHVyYXRpb24gPSB0aGlzLmNoZWNrQ29sbGFwc2Uob3B0cywgdGhpcy5kdXJhdGlvbik7XG4gICAgfVxuICB9XG4gIGNoZWNrQ29sbGFwc2Uob3B0cywgY2FsY3VsYXRlZER1cmF0aW9uKSB7XG4gICAgcmV0dXJuIGFuaW1hdGlvblZhbHVlc0VxdWFsKG9wdHMuZnJvbSwgb3B0cy50bykgPyAwIDogY2FsY3VsYXRlZER1cmF0aW9uO1xuICB9XG4gIHBsYXkoaW5pdGlhbFVwZGF0ZSA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMuaXNQbGF5aW5nIHx8IHRoaXMuaXNDb21wbGV0ZSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmlzUGxheWluZyA9IHRydWU7XG4gICAgdGhpcy5vblBsYXk/Lih0aGlzKTtcbiAgICBpZiAoIXRoaXMuYXV0b3BsYXkpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5hdXRvcGxheSA9IGZhbHNlO1xuICAgIGlmICghaW5pdGlhbFVwZGF0ZSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLm9uVXBkYXRlPy4odGhpcy5mcm9tLCB0cnVlLCB0aGlzKTtcbiAgfVxuICBwYXVzZSgpIHtcbiAgICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuICB9XG4gIHN0b3AoKSB7XG4gICAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcbiAgICBpZiAoIXRoaXMuaXNDb21wbGV0ZSkge1xuICAgICAgdGhpcy5pc0NvbXBsZXRlID0gdHJ1ZTtcbiAgICAgIHRoaXMub25TdG9wPy4odGhpcyk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZSh0aW1lMikge1xuICAgIGlmICh0aGlzLmlzQ29tcGxldGUpXG4gICAgICByZXR1cm4gdGltZTI7XG4gICAgaWYgKCF0aGlzLmlzUGxheWluZyAmJiB0aGlzLmF1dG9wbGF5KSB7XG4gICAgICB0aGlzLnBsYXkodHJ1ZSk7XG4gICAgfVxuICAgIGNvbnN0IHByZXZpb3VzRWxhcHNlZCA9IHRoaXMuZWxhcHNlZDtcbiAgICB0aGlzLmVsYXBzZWQgKz0gdGltZTI7XG4gICAgaWYgKHRoaXMuZGVsYXkgPiB0aGlzLmVsYXBzZWQpXG4gICAgICByZXR1cm4gMDtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuaW50ZXJwb2xhdGUodGhpcy5pc1JldmVyc2UgPyAxIC0gdGhpcy5kZWx0YSA6IHRoaXMuZGVsdGEpO1xuICAgIHRoaXMub25VcGRhdGU/Lih2YWx1ZSwgZmFsc2UsIHRoaXMpO1xuICAgIGNvbnN0IHRvdGFsRHVyYXRpb24gPSB0aGlzLmRlbGF5ICsgdGhpcy5kdXJhdGlvbjtcbiAgICBpZiAodGhpcy5lbGFwc2VkID49IHRvdGFsRHVyYXRpb24pIHtcbiAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgdGhpcy5pc0NvbXBsZXRlID0gdHJ1ZTtcbiAgICAgIHRoaXMub25Db21wbGV0ZT8uKHRoaXMpO1xuICAgICAgcmV0dXJuIHRpbWUyIC0gKHRvdGFsRHVyYXRpb24gLSBwcmV2aW91c0VsYXBzZWQpO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuICBnZXQgZGVsdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFzZShjbGFtcCgwLCAodGhpcy5lbGFwc2VkIC0gdGhpcy5kZWxheSkgLyB0aGlzLmR1cmF0aW9uLCAxKSk7XG4gIH1cbiAgY3JlYXRlSW50ZXJwb2xhdG9yKGZyb20zLCB0bykge1xuICAgIGlmICh0eXBlb2YgdG8gIT09IFwib2JqZWN0XCIgfHwgaXNJbnRlcnBvbGF0aW5nKHRvKSkge1xuICAgICAgcmV0dXJuIHRoaXMuaW50ZXJwb2xhdGVWYWx1ZShmcm9tMywgdG8pO1xuICAgIH1cbiAgICBjb25zdCBpbnRlcnBvbGF0b3JFbnRyaWVzID0gW107XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdG8pIHtcbiAgICAgIGNvbnN0IGludGVycG9sYXRvciA9IHRoaXMuaW50ZXJwb2xhdGVWYWx1ZShmcm9tM1trZXldLCB0b1trZXldKTtcbiAgICAgIGlmIChpbnRlcnBvbGF0b3IgIT0gbnVsbCkge1xuICAgICAgICBpbnRlcnBvbGF0b3JFbnRyaWVzLnB1c2goW2tleSwgaW50ZXJwb2xhdG9yXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoZCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIGludGVycG9sYXRvcl0gb2YgaW50ZXJwb2xhdG9yRW50cmllcykge1xuICAgICAgICByZXN1bHRba2V5XSA9IGludGVycG9sYXRvcihkKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfVxuICBpbnRlcnBvbGF0ZVZhbHVlKGEsIGIpIHtcbiAgICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoaXNJbnRlcnBvbGF0aW5nKGEpKSB7XG4gICAgICByZXR1cm4gKGQpID0+IGFbaW50ZXJwb2xhdGVdKGIsIGQpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgc3dpdGNoICh0eXBlb2YgYSkge1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgcmV0dXJuIGludGVycG9sYXRlTnVtYmVyKGEsIGIpO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgcmV0dXJuIGludGVycG9sYXRlQ29sb3IoYSwgYik7XG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiBhO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGludGVycG9sYXRlIHZhbHVlczogJHthfSwgJHtifWApO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9tb3Rpb24vZnJvbVRvTW90aW9uLnRzXG52YXIgTk9ERV9VUERBVEVfU1RBVEVfVE9fUEhBU0VfTUFQUElORyA9IHtcbiAgYWRkZWQ6IFwiYWRkXCIsXG4gIHVwZGF0ZWQ6IFwidXBkYXRlXCIsXG4gIHJlbW92ZWQ6IFwicmVtb3ZlXCIsXG4gIHVua25vd246IFwiaW5pdGlhbFwiLFxuICBcIm5vLW9wXCI6IFwibm9uZVwiXG59O1xuZnVuY3Rpb24gZnJvbVRvTW90aW9uKGdyb3VwSWQsIHN1YklkLCBhbmltYXRpb25NYW5hZ2VyLCBzZWxlY3Rpb25zT3JOb2RlcywgZm5zLCBnZXREYXR1bUlkLCBkaWZmMikge1xuICBjb25zdCB7IGZyb21GbiwgdG9GbiwgYXBwbHlGbiA9IChub2RlLCBwcm9wcykgPT4gbm9kZS5zZXRQcm9wZXJ0aWVzKHByb3BzKSB9ID0gZm5zO1xuICBjb25zdCB7IG5vZGVzLCBzZWxlY3Rpb25zIH0gPSBkZWNvbnN0cnVjdFNlbGVjdGlvbnNPck5vZGVzKHNlbGVjdGlvbnNPck5vZGVzKTtcbiAgY29uc3QgcHJvY2Vzc05vZGVzID0gKGxpdmVOb2Rlcywgc3ViTm9kZXMpID0+IHtcbiAgICBsZXQgcHJldkZyb21Qcm9wcztcbiAgICBsZXQgbGl2ZU5vZGVJbmRleCA9IDA7XG4gICAgbGV0IG5vZGVJbmRleCA9IDA7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIHN1Yk5vZGVzKSB7XG4gICAgICBjb25zdCBpc0xpdmUgPSBsaXZlTm9kZXNbbGl2ZU5vZGVJbmRleF0gPT09IG5vZGU7XG4gICAgICBjb25zdCBjdHggPSB7XG4gICAgICAgIGxhc3Q6IG5vZGVJbmRleCA+PSBzdWJOb2Rlcy5sZW5ndGggLSAxLFxuICAgICAgICBsYXN0TGl2ZTogbGl2ZU5vZGVJbmRleCA+PSBsaXZlTm9kZXMubGVuZ3RoIC0gMSxcbiAgICAgICAgcHJldjogc3ViTm9kZXNbbm9kZUluZGV4IC0gMV0sXG4gICAgICAgIHByZXZGcm9tUHJvcHMsXG4gICAgICAgIHByZXZMaXZlOiBsaXZlTm9kZXNbbGl2ZU5vZGVJbmRleCAtIDFdLFxuICAgICAgICBuZXh0OiBzdWJOb2Rlc1tub2RlSW5kZXggKyAxXSxcbiAgICAgICAgbmV4dExpdmU6IGxpdmVOb2Rlc1tsaXZlTm9kZUluZGV4ICsgKGlzTGl2ZSA/IDEgOiAwKV1cbiAgICAgIH07XG4gICAgICBjb25zdCBhbmltYXRpb25JZCA9IGAke2dyb3VwSWR9XyR7c3ViSWR9XyR7bm9kZS5pZH1gO1xuICAgICAgYW5pbWF0aW9uTWFuYWdlci5zdG9wQnlBbmltYXRpb25JZChhbmltYXRpb25JZCk7XG4gICAgICBsZXQgc3RhdHVzID0gXCJ1bmtub3duXCI7XG4gICAgICBpZiAoIWlzTGl2ZSkge1xuICAgICAgICBzdGF0dXMgPSBcInJlbW92ZWRcIjtcbiAgICAgIH0gZWxzZSBpZiAoZ2V0RGF0dW1JZCAmJiBkaWZmMikge1xuICAgICAgICBzdGF0dXMgPSBjYWxjdWxhdGVTdGF0dXMobm9kZSwgbm9kZS5kYXR1bSwgZ2V0RGF0dW1JZCwgZGlmZjIpO1xuICAgICAgfVxuICAgICAgbm9kZS50cmFuc2l0aW9uT3V0ID0gc3RhdHVzID09PSBcInJlbW92ZWRcIjtcbiAgICAgIGNvbnN0IHsgcGhhc2UsIHN0YXJ0OiBzdGFydDIsIGZpbmlzaCwgZGVsYXksIGR1cmF0aW9uLCAuLi5mcm9tMyB9ID0gZnJvbUZuKG5vZGUsIG5vZGUuZGF0dW0sIHN0YXR1cywgY3R4KTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGhhc2U6IHRvUGhhc2UsXG4gICAgICAgIHN0YXJ0OiB0b1N0YXJ0LFxuICAgICAgICBmaW5pc2g6IHRvRmluaXNoLFxuICAgICAgICBkZWxheTogdG9EZWxheSxcbiAgICAgICAgZHVyYXRpb246IHRvRHVyYXRpb24sXG4gICAgICAgIC4uLnRvXG4gICAgICB9ID0gdG9Gbihub2RlLCBub2RlLmRhdHVtLCBzdGF0dXMsIGN0eCk7XG4gICAgICBjb25zdCBjb2xsYXBzYWJsZSA9IGZpbmlzaCA9PSBudWxsO1xuICAgICAgYW5pbWF0aW9uTWFuYWdlci5hbmltYXRlKHtcbiAgICAgICAgaWQ6IGFuaW1hdGlvbklkLFxuICAgICAgICBncm91cElkLFxuICAgICAgICBwaGFzZTogcGhhc2UgPz8gdG9QaGFzZSA/PyBcInVwZGF0ZVwiLFxuICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24gPz8gdG9EdXJhdGlvbixcbiAgICAgICAgZGVsYXk6IGRlbGF5ID8/IHRvRGVsYXksXG4gICAgICAgIGZyb206IGZyb20zLFxuICAgICAgICB0byxcbiAgICAgICAgZWFzZTogZWFzZU91dCxcbiAgICAgICAgY29sbGFwc2FibGUsXG4gICAgICAgIG9uUGxheTogKCkgPT4ge1xuICAgICAgICAgIGFwcGx5Rm4obm9kZSwgeyAuLi5zdGFydDIsIC4uLnRvU3RhcnQsIC4uLmZyb20zIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvblVwZGF0ZShwcm9wcykge1xuICAgICAgICAgIGFwcGx5Rm4obm9kZSwgcHJvcHMpO1xuICAgICAgICB9LFxuICAgICAgICBvblN0b3A6ICgpID0+IHtcbiAgICAgICAgICBhcHBseUZuKG5vZGUsIHtcbiAgICAgICAgICAgIC4uLnN0YXJ0MixcbiAgICAgICAgICAgIC4uLnRvU3RhcnQsXG4gICAgICAgICAgICAuLi5mcm9tMyxcbiAgICAgICAgICAgIC4uLnRvLFxuICAgICAgICAgICAgLi4uZmluaXNoLFxuICAgICAgICAgICAgLi4udG9GaW5pc2hcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoaXNMaXZlKSB7XG4gICAgICAgIGxpdmVOb2RlSW5kZXgrKztcbiAgICAgIH1cbiAgICAgIG5vZGVJbmRleCsrO1xuICAgICAgcHJldkZyb21Qcm9wcyA9IGZyb20zO1xuICAgIH1cbiAgfTtcbiAgbGV0IHNlbGVjdGlvbkluZGV4ID0gMDtcbiAgZm9yIChjb25zdCBzZWxlY3Rpb24gb2Ygc2VsZWN0aW9ucykge1xuICAgIGNvbnN0IHNlbGVjdGlvbk5vZGVzID0gc2VsZWN0aW9uLm5vZGVzKCk7XG4gICAgY29uc3QgbGl2ZU5vZGVzID0gc2VsZWN0aW9uTm9kZXMuZmlsdGVyKChuKSA9PiAhc2VsZWN0aW9uLmlzR2FyYmFnZShuKSk7XG4gICAgcHJvY2Vzc05vZGVzKGxpdmVOb2Rlcywgc2VsZWN0aW9uTm9kZXMpO1xuICAgIGFuaW1hdGlvbk1hbmFnZXIuYW5pbWF0ZSh7XG4gICAgICBpZDogYCR7Z3JvdXBJZH1fJHtzdWJJZH1fc2VsZWN0aW9uXyR7c2VsZWN0aW9uSW5kZXh9YCxcbiAgICAgIGdyb3VwSWQsXG4gICAgICBwaGFzZTogXCJlbmRcIixcbiAgICAgIGZyb206IDAsXG4gICAgICB0bzogMSxcbiAgICAgIGVhc2U6IGVhc2VPdXQsXG4gICAgICBvblN0b3AoKSB7XG4gICAgICAgIHNlbGVjdGlvbi5jbGVhbnVwKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgc2VsZWN0aW9uSW5kZXgrKztcbiAgfVxuICBwcm9jZXNzTm9kZXMobm9kZXMsIG5vZGVzKTtcbn1cbmZ1bmN0aW9uIHN0YXRpY0Zyb21Ub01vdGlvbihncm91cElkLCBzdWJJZCwgYW5pbWF0aW9uTWFuYWdlciwgc2VsZWN0aW9uc09yTm9kZXMsIGZyb20zLCB0bywgZXh0cmFPcHRzKSB7XG4gIGNvbnN0IHsgbm9kZXMsIHNlbGVjdGlvbnMgfSA9IGRlY29uc3RydWN0U2VsZWN0aW9uc09yTm9kZXMoc2VsZWN0aW9uc09yTm9kZXMpO1xuICBjb25zdCB7IHN0YXJ0OiBzdGFydDIsIGZpbmlzaCwgcGhhc2UgfSA9IGV4dHJhT3B0cztcbiAgYW5pbWF0aW9uTWFuYWdlci5hbmltYXRlKHtcbiAgICBpZDogYCR7Z3JvdXBJZH1fJHtzdWJJZH1gLFxuICAgIGdyb3VwSWQsXG4gICAgcGhhc2U6IHBoYXNlID8/IFwidXBkYXRlXCIsXG4gICAgZnJvbTogZnJvbTMsXG4gICAgdG8sXG4gICAgZWFzZTogZWFzZU91dCxcbiAgICBvblBsYXk6ICgpID0+IHtcbiAgICAgIGlmICghc3RhcnQyKVxuICAgICAgICByZXR1cm47XG4gICAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICAgICAgbm9kZS5zZXRQcm9wZXJ0aWVzKHN0YXJ0Mik7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHNlbGVjdGlvbiBvZiBzZWxlY3Rpb25zKSB7XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBzZWxlY3Rpb24ubm9kZXMoKSkge1xuICAgICAgICAgIG5vZGUuc2V0UHJvcGVydGllcyhzdGFydDIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBvblVwZGF0ZShwcm9wcykge1xuICAgICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgICAgIG5vZGUuc2V0UHJvcGVydGllcyhwcm9wcyk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHNlbGVjdGlvbiBvZiBzZWxlY3Rpb25zKSB7XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBzZWxlY3Rpb24ubm9kZXMoKSkge1xuICAgICAgICAgIG5vZGUuc2V0UHJvcGVydGllcyhwcm9wcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIG9uU3RvcDogKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgICAgIG5vZGUuc2V0UHJvcGVydGllcyh7IC4uLnRvLCAuLi5maW5pc2ggfSk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHNlbGVjdGlvbiBvZiBzZWxlY3Rpb25zKSB7XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBzZWxlY3Rpb24ubm9kZXMoKSkge1xuICAgICAgICAgIG5vZGUuc2V0UHJvcGVydGllcyh7IC4uLnRvLCAuLi5maW5pc2ggfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZWN0aW9uLmNsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlU3RhdHVzKG5vZGUsIGRhdHVtLCBnZXREYXR1bUlkLCBkaWZmMikge1xuICBjb25zdCBpZCA9IGdldERhdHVtSWQobm9kZSwgZGF0dW0pO1xuICBpZiAoZGlmZjIuYWRkZWQuaGFzKGlkKSkge1xuICAgIHJldHVybiBcImFkZGVkXCI7XG4gIH1cbiAgaWYgKGRpZmYyLnJlbW92ZWQuaGFzKGlkKSkge1xuICAgIHJldHVybiBcInJlbW92ZWRcIjtcbiAgfVxuICByZXR1cm4gXCJ1cGRhdGVkXCI7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjYWxlL2ludmFsaWRhdGluZy50c1xudmFyIEludmFsaWRhdGluZyA9ICh0YXJnZXQsIHByb3BlcnR5S2V5KSA9PiB7XG4gIGNvbnN0IG1hcHBlZFByb3BlcnR5ID0gU3ltYm9sKFN0cmluZyhwcm9wZXJ0eUtleSkpO1xuICB0YXJnZXRbbWFwcGVkUHJvcGVydHldID0gdm9pZCAwO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSwge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzW21hcHBlZFByb3BlcnR5XTtcbiAgICB9LFxuICAgIHNldChuZXdWYWx1ZSkge1xuICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzW21hcHBlZFByb3BlcnR5XTtcbiAgICAgIGlmIChvbGRWYWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgdGhpc1ttYXBwZWRQcm9wZXJ0eV0gPSBuZXdWYWx1ZTtcbiAgICAgICAgdGhpcy5pbnZhbGlkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICB9KTtcbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjYWxlL2NvbnRpbnVvdXNTY2FsZS50c1xudmFyIF9Db250aW51b3VzU2NhbGUgPSBjbGFzcyBfQ29udGludW91c1NjYWxlIHtcbiAgY29uc3RydWN0b3IoZG9tYWluLCByYW5nZTMpIHtcbiAgICB0aGlzLmludmFsaWQgPSB0cnVlO1xuICAgIHRoaXMubmljZSA9IGZhbHNlO1xuICAgIHRoaXMuaW50ZXJ2YWwgPSB2b2lkIDA7XG4gICAgdGhpcy50aWNrQ291bnQgPSBfQ29udGludW91c1NjYWxlLmRlZmF1bHRUaWNrQ291bnQ7XG4gICAgdGhpcy5taW5UaWNrQ291bnQgPSAwO1xuICAgIHRoaXMubWF4VGlja0NvdW50ID0gSW5maW5pdHk7XG4gICAgLy8gVE9ETyhvbGVnYXQpIHNob3VsZCBiZSBvZiB0eXBlIERbXVxuICAgIHRoaXMubmljZURvbWFpbiA9IFtdO1xuICAgIHRoaXMuZGVmYXVsdENsYW1wTW9kZSA9IFwicmF3XCI7XG4gICAgdGhpcy5kb21haW4gPSBkb21haW47XG4gICAgdGhpcy5yYW5nZSA9IHJhbmdlMztcbiAgfVxuICBzdGF0aWMgaXModmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBfQ29udGludW91c1NjYWxlO1xuICB9XG4gIHRyYW5zZm9ybSh4KSB7XG4gICAgcmV0dXJuIHg7XG4gIH1cbiAgdHJhbnNmb3JtSW52ZXJ0KHgpIHtcbiAgICByZXR1cm4geDtcbiAgfVxuICBjYWxjQmFuZHdpZHRoKHNtYWxsZXN0SW50ZXJ2YWwgPSAxKSB7XG4gICAgY29uc3QgZG9tYWluID0gdGhpcy5nZXREb21haW4oKTtcbiAgICBjb25zdCByYW5nZURpc3RhbmNlID0gdGhpcy5nZXRQaXhlbFJhbmdlKCk7XG4gICAgY29uc3QgaW50ZXJ2YWxzID0gTWF0aC5hYnMoZG9tYWluWzFdIC0gZG9tYWluWzBdKSAvIHNtYWxsZXN0SW50ZXJ2YWwgKyAxO1xuICAgIGNvbnN0IG1heEJhbmRzID0gTWF0aC5mbG9vcihyYW5nZURpc3RhbmNlKTtcbiAgICBjb25zdCBiYW5kcyA9IE1hdGgubWluKGludGVydmFscywgbWF4QmFuZHMpO1xuICAgIHJldHVybiByYW5nZURpc3RhbmNlIC8gTWF0aC5tYXgoMSwgYmFuZHMpO1xuICB9XG4gIGdldERvbWFpbigpIHtcbiAgICBpZiAodGhpcy5uaWNlKSB7XG4gICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgIGlmICh0aGlzLm5pY2VEb21haW4ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5pY2VEb21haW47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRvbWFpbjtcbiAgfVxuICBjb252ZXJ0KHgsIG9wdHMpIHtcbiAgICBjb25zdCBjbGFtcE1vZGUgPSBvcHRzPy5jbGFtcE1vZGUgPz8gdGhpcy5kZWZhdWx0Q2xhbXBNb2RlO1xuICAgIGlmICghdGhpcy5kb21haW4gfHwgdGhpcy5kb21haW4ubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgY29uc3QgZG9tYWluID0gdGhpcy5nZXREb21haW4oKS5tYXAoKGQpID0+IHRoaXMudHJhbnNmb3JtKGQpKTtcbiAgICBjb25zdCBbZDAsIGQxXSA9IGRvbWFpbjtcbiAgICBjb25zdCB7IHJhbmdlOiByYW5nZTMgfSA9IHRoaXM7XG4gICAgY29uc3QgW3IwLCByMV0gPSByYW5nZTM7XG4gICAgeCA9IHRoaXMudHJhbnNmb3JtKHgpO1xuICAgIGlmIChjbGFtcE1vZGUgPT09IFwiY2xhbXBlZFwiKSB7XG4gICAgICBjb25zdCBbc3RhcnQyLCBzdG9wXSA9IGZpbmRNaW5NYXgoZG9tYWluLm1hcChOdW1iZXIpKTtcbiAgICAgIGlmIChOdW1iZXIoeCkgPCBzdGFydDIpIHtcbiAgICAgICAgcmV0dXJuIHIwO1xuICAgICAgfSBlbHNlIGlmIChOdW1iZXIoeCkgPiBzdG9wKSB7XG4gICAgICAgIHJldHVybiByMTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGQwID09PSBkMSkge1xuICAgICAgcmV0dXJuIChyMCArIHIxKSAvIDI7XG4gICAgfSBlbHNlIGlmICh4ID09PSBkMCkge1xuICAgICAgcmV0dXJuIHIwO1xuICAgIH0gZWxzZSBpZiAoeCA9PT0gZDEpIHtcbiAgICAgIHJldHVybiByMTtcbiAgICB9XG4gICAgcmV0dXJuIHIwICsgKE51bWJlcih4KSAtIE51bWJlcihkMCkpIC8gKE51bWJlcihkMSkgLSBOdW1iZXIoZDApKSAqIChyMSAtIHIwKTtcbiAgfVxuICBpbnZlcnQoeCkge1xuICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIGNvbnN0IGRvbWFpbiA9IHRoaXMuZ2V0RG9tYWluKCkubWFwKChkMikgPT4gdGhpcy50cmFuc2Zvcm0oZDIpKTtcbiAgICBjb25zdCBbZDAsIGQxXSA9IGRvbWFpbjtcbiAgICBjb25zdCB7IHJhbmdlOiByYW5nZTMgfSA9IHRoaXM7XG4gICAgY29uc3QgW3IwLCByMV0gPSByYW5nZTM7XG4gICAgY29uc3QgaXNSZXZlcnNlZCA9IHIwID4gcjE7XG4gICAgY29uc3Qgck1pbiA9IGlzUmV2ZXJzZWQgPyByMSA6IHIwO1xuICAgIGNvbnN0IHJNYXggPSBpc1JldmVyc2VkID8gcjAgOiByMTtcbiAgICBsZXQgZDtcbiAgICBpZiAoeCA8IHJNaW4pIHtcbiAgICAgIHJldHVybiBpc1JldmVyc2VkID8gZDEgOiBkMDtcbiAgICB9IGVsc2UgaWYgKHggPiByTWF4KSB7XG4gICAgICByZXR1cm4gaXNSZXZlcnNlZCA/IGQwIDogZDE7XG4gICAgfSBlbHNlIGlmIChyMCA9PT0gcjEpIHtcbiAgICAgIGQgPSB0aGlzLnRvRG9tYWluKChOdW1iZXIoZDApICsgTnVtYmVyKGQxKSkgLyAyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZCA9IHRoaXMudG9Eb21haW4oTnVtYmVyKGQwKSArICh4IC0gcjApIC8gKHIxIC0gcjApICogKE51bWJlcihkMSkgLSBOdW1iZXIoZDApKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUludmVydChkKTtcbiAgfVxuICByZWZyZXNoKCkge1xuICAgIGlmICghdGhpcy5pbnZhbGlkKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuaW52YWxpZCA9IGZhbHNlO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gICAgaWYgKHRoaXMuaW52YWxpZCkge1xuICAgICAgTG9nZ2VyLndhcm5PbmNlKFwiRXhwZWN0ZWQgdXBkYXRlIHRvIG5vdCBpbnZhbGlkYXRlIHNjYWxlXCIpO1xuICAgIH1cbiAgfVxuICBnZXRQaXhlbFJhbmdlKCkge1xuICAgIGNvbnN0IFthLCBiXSA9IHRoaXMucmFuZ2U7XG4gICAgcmV0dXJuIE1hdGguYWJzKGIgLSBhKTtcbiAgfVxufTtcbl9Db250aW51b3VzU2NhbGUuZGVmYXVsdFRpY2tDb3VudCA9IDU7XG5fQ29udGludW91c1NjYWxlLmRlZmF1bHRNYXhUaWNrQ291bnQgPSA2O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgSW52YWxpZGF0aW5nXG5dLCBfQ29udGludW91c1NjYWxlLnByb3RvdHlwZSwgXCJkb21haW5cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBJbnZhbGlkYXRpbmdcbl0sIF9Db250aW51b3VzU2NhbGUucHJvdG90eXBlLCBcInJhbmdlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgSW52YWxpZGF0aW5nXG5dLCBfQ29udGludW91c1NjYWxlLnByb3RvdHlwZSwgXCJuaWNlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgSW52YWxpZGF0aW5nXG5dLCBfQ29udGludW91c1NjYWxlLnByb3RvdHlwZSwgXCJpbnRlcnZhbFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEludmFsaWRhdGluZ1xuXSwgX0NvbnRpbnVvdXNTY2FsZS5wcm90b3R5cGUsIFwidGlja0NvdW50XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgSW52YWxpZGF0aW5nXG5dLCBfQ29udGludW91c1NjYWxlLnByb3RvdHlwZSwgXCJtaW5UaWNrQ291bnRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBJbnZhbGlkYXRpbmdcbl0sIF9Db250aW51b3VzU2NhbGUucHJvdG90eXBlLCBcIm1heFRpY2tDb3VudFwiLCAyKTtcbnZhciBDb250aW51b3VzU2NhbGUgPSBfQ29udGludW91c1NjYWxlO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2FycmF5LnRzXG5mdW5jdGlvbiBleHRlbnQodmFsdWVzKSB7XG4gIGlmICh2YWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbGV0IG1pbiA9IEluZmluaXR5O1xuICBsZXQgbWF4ID0gLUluZmluaXR5O1xuICBmb3IgKGxldCBuIG9mIHZhbHVlcykge1xuICAgIGlmIChuIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgbiA9IG4uZ2V0VGltZSgpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG4gIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobiA8IG1pbikge1xuICAgICAgbWluID0gbjtcbiAgICB9XG4gICAgaWYgKG4gPiBtYXgpIHtcbiAgICAgIG1heCA9IG47XG4gICAgfVxuICB9XG4gIGNvbnN0IHJlc3VsdCA9IFttaW4sIG1heF07XG4gIHJldHVybiByZXN1bHQuZXZlcnkoaXNGaW5pdGUpID8gcmVzdWx0IDogbnVsbDtcbn1cbmZ1bmN0aW9uIG5vcm1hbGlzZWRFeHRlbnRXaXRoTWV0YWRhdGEoZCwgbWluLCBtYXgpIHtcbiAgbGV0IGNsaXBwZWQgPSBmYWxzZTtcbiAgaWYgKGQubGVuZ3RoID4gMikge1xuICAgIGQgPSBleHRlbnQoZCkgPz8gW05hTiwgTmFOXTtcbiAgfVxuICBpZiAoIWlzTmFOKG1pbikpIHtcbiAgICBjbGlwcGVkIHx8IChjbGlwcGVkID0gbWluID4gZFswXSk7XG4gICAgZCA9IFttaW4sIGRbMV1dO1xuICB9XG4gIGlmICghaXNOYU4obWF4KSkge1xuICAgIGNsaXBwZWQgfHwgKGNsaXBwZWQgPSBtYXggPCBkWzFdKTtcbiAgICBkID0gW2RbMF0sIG1heF07XG4gIH1cbiAgaWYgKGRbMF0gPiBkWzFdKSB7XG4gICAgZCA9IFtdO1xuICB9XG4gIHJldHVybiB7IGV4dGVudDogZCwgY2xpcHBlZCB9O1xufVxuZnVuY3Rpb24gYXJyYXlzRXF1YWwoYSwgYikge1xuICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCB8fCBhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYVtpXSkgJiYgQXJyYXkuaXNBcnJheShiW2ldKSkge1xuICAgICAgaWYgKCFhcnJheXNFcXVhbChhW2ldLCBiW2ldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gdG9BcnJheSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcbn1cbmZ1bmN0aW9uIHVuaXF1ZShhcnJheTIpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldChhcnJheTIpKTtcbn1cbmZ1bmN0aW9uIGdyb3VwQnkoYXJyYXkyLCBpdGVyYXRlZSkge1xuICByZXR1cm4gYXJyYXkyLnJlZHVjZSgocmVzdWx0LCBpdGVtKSA9PiB7XG4gICAgY29uc3QgZ3JvdXBLZXkgPSBpdGVyYXRlZShpdGVtKTtcbiAgICByZXN1bHRbZ3JvdXBLZXldID8/IChyZXN1bHRbZ3JvdXBLZXldID0gW10pO1xuICAgIHJlc3VsdFtncm91cEtleV0ucHVzaChpdGVtKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LCB7fSk7XG59XG5mdW5jdGlvbiBjaXJjdWxhclNsaWNlQXJyYXkoZGF0YSwgc2l6ZSwgb2Zmc2V0NCA9IDApIHtcbiAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgIHJlc3VsdC5wdXNoKGRhdGEuYXQoKGkgKyBvZmZzZXQ0KSAlIGRhdGEubGVuZ3RoKSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHNvcnRCYXNlZE9uQXJyYXkoYmFzZUFycmF5LCBvcmRlckFycmF5KSB7XG4gIGNvbnN0IG9yZGVyTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgb3JkZXJBcnJheS5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgIG9yZGVyTWFwLnNldChpdGVtLCBpbmRleCk7XG4gIH0pO1xuICByZXR1cm4gYmFzZUFycmF5LnNvcnQoKGEsIGIpID0+IHtcbiAgICBjb25zdCBpbmRleEEgPSBvcmRlck1hcC5nZXQoYSkgPz8gSW5maW5pdHk7XG4gICAgY29uc3QgaW5kZXhCID0gb3JkZXJNYXAuZ2V0KGIpID8/IEluZmluaXR5O1xuICAgIHJldHVybiBpbmRleEEgLSBpbmRleEI7XG4gIH0pO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3RpbWVGb3JtYXQudHNcbnZhciBDT05TVEFOVFMgPSB7XG4gIHBlcmlvZHM6IFtcIkFNXCIsIFwiUE1cIl0sXG4gIGRheXM6IFtcIlN1bmRheVwiLCBcIk1vbmRheVwiLCBcIlR1ZXNkYXlcIiwgXCJXZWRuZXNkYXlcIiwgXCJUaHVyc2RheVwiLCBcIkZyaWRheVwiLCBcIlNhdHVyZGF5XCJdLFxuICBzaG9ydERheXM6IFtcIlN1blwiLCBcIk1vblwiLCBcIlR1ZVwiLCBcIldlZFwiLCBcIlRodVwiLCBcIkZyaVwiLCBcIlNhdFwiXSxcbiAgbW9udGhzOiBbXG4gICAgXCJKYW51YXJ5XCIsXG4gICAgXCJGZWJydWFyeVwiLFxuICAgIFwiTWFyY2hcIixcbiAgICBcIkFwcmlsXCIsXG4gICAgXCJNYXlcIixcbiAgICBcIkp1bmVcIixcbiAgICBcIkp1bHlcIixcbiAgICBcIkF1Z3VzdFwiLFxuICAgIFwiU2VwdGVtYmVyXCIsXG4gICAgXCJPY3RvYmVyXCIsXG4gICAgXCJOb3ZlbWJlclwiLFxuICAgIFwiRGVjZW1iZXJcIlxuICBdLFxuICBzaG9ydE1vbnRoczogW1wiSmFuXCIsIFwiRmViXCIsIFwiTWFyXCIsIFwiQXByXCIsIFwiTWF5XCIsIFwiSnVuXCIsIFwiSnVsXCIsIFwiQXVnXCIsIFwiU2VwXCIsIFwiT2N0XCIsIFwiTm92XCIsIFwiRGVjXCJdXG59O1xuZnVuY3Rpb24gZGF5T2ZZZWFyKGRhdGUsIHN0YXJ0T2ZZZWFyID0gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCAwLCAxKSkge1xuICBjb25zdCBzdGFydE9mZnNldCA9IGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSAtIHN0YXJ0T2ZZZWFyLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gIGNvbnN0IHRpbWVEaWZmID0gZGF0ZS5nZXRUaW1lKCkgLSBzdGFydE9mWWVhci5nZXRUaW1lKCkgKyBzdGFydE9mZnNldCAqIDZlNDtcbiAgY29uc3QgdGltZU9uZURheSA9IDM2ZTUgKiAyNDtcbiAgcmV0dXJuIE1hdGguZmxvb3IodGltZURpZmYgLyB0aW1lT25lRGF5KTtcbn1cbmZ1bmN0aW9uIHdlZWtPZlllYXIoZGF0ZSwgc3RhcnREYXkpIHtcbiAgY29uc3Qgc3RhcnRPZlllYXIgPSBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIDAsIDEpO1xuICBjb25zdCBzdGFydE9mWWVhckRheSA9IHN0YXJ0T2ZZZWFyLmdldERheSgpO1xuICBjb25zdCBmaXJzdFdlZWtTdGFydE9mZnNldCA9IChzdGFydERheSAtIHN0YXJ0T2ZZZWFyRGF5ICsgNykgJSA3O1xuICBjb25zdCBzdGFydE9mZnNldCA9IG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgMCwgZmlyc3RXZWVrU3RhcnRPZmZzZXQgKyAxKTtcbiAgaWYgKHN0YXJ0T2Zmc2V0IDw9IGRhdGUpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihkYXlPZlllYXIoZGF0ZSwgc3RhcnRPZmZzZXQpIC8gNykgKyAxO1xuICB9XG4gIHJldHVybiAwO1xufVxudmFyIFNVTkRBWSA9IDA7XG52YXIgTU9OREFZID0gMTtcbnZhciBUSFVSU0RBWSA9IDQ7XG5mdW5jdGlvbiBpc29XZWVrT2ZZZWFyKGRhdGUsIHllYXIyID0gZGF0ZS5nZXRGdWxsWWVhcigpKSB7XG4gIGNvbnN0IGZpcnN0T2ZZZWFyID0gbmV3IERhdGUoeWVhcjIsIDAsIDEpO1xuICBjb25zdCBmaXJzdE9mWWVhckRheSA9IGZpcnN0T2ZZZWFyLmdldERheSgpO1xuICBjb25zdCBmaXJzdFRodXJzZGF5T2Zmc2V0ID0gKFRIVVJTREFZIC0gZmlyc3RPZlllYXJEYXkgKyA3KSAlIDc7XG4gIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gbmV3IERhdGUoeWVhcjIsIDAsIGZpcnN0VGh1cnNkYXlPZmZzZXQgLSAoVEhVUlNEQVkgLSBNT05EQVkpICsgMSk7XG4gIGlmIChzdGFydE9mZnNldCA8PSBkYXRlKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoZGF5T2ZZZWFyKGRhdGUsIHN0YXJ0T2Zmc2V0KSAvIDcpICsgMTtcbiAgfVxuICByZXR1cm4gaXNvV2Vla09mWWVhcihkYXRlLCB5ZWFyMiAtIDEpO1xufVxuZnVuY3Rpb24gdGltZXpvbmUoZGF0ZSkge1xuICBjb25zdCBvZmZzZXQ0ID0gZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpO1xuICBjb25zdCB1bnNpZ25lZE9mZnNldCA9IE1hdGguYWJzKG9mZnNldDQpO1xuICBjb25zdCBzaWduID0gb2Zmc2V0NCA+IDAgPyBcIi1cIiA6IFwiK1wiO1xuICByZXR1cm4gYCR7c2lnbn0ke3BhZChNYXRoLmZsb29yKHVuc2lnbmVkT2Zmc2V0IC8gNjApLCAyLCBcIjBcIil9JHtwYWQoTWF0aC5mbG9vcih1bnNpZ25lZE9mZnNldCAlIDYwKSwgMiwgXCIwXCIpfWA7XG59XG52YXIgRk9STUFUVEVSUyA9IHtcbiAgYTogKGQpID0+IENPTlNUQU5UUy5zaG9ydERheXNbZC5nZXREYXkoKV0sXG4gIEE6IChkKSA9PiBDT05TVEFOVFMuZGF5c1tkLmdldERheSgpXSxcbiAgYjogKGQpID0+IENPTlNUQU5UUy5zaG9ydE1vbnRoc1tkLmdldE1vbnRoKCldLFxuICBCOiAoZCkgPT4gQ09OU1RBTlRTLm1vbnRoc1tkLmdldE1vbnRoKCldLFxuICBjOiBcIiV4LCAlWFwiLFxuICBkOiAoZCwgcCkgPT4gcGFkKGQuZ2V0RGF0ZSgpLCAyLCBwID8/IFwiMFwiKSxcbiAgZTogXCIlX2RcIixcbiAgZjogKGQsIHApID0+IHBhZChkLmdldE1pbGxpc2Vjb25kcygpICogMWUzLCA2LCBwID8/IFwiMFwiKSxcbiAgSDogKGQsIHApID0+IHBhZChkLmdldEhvdXJzKCksIDIsIHAgPz8gXCIwXCIpLFxuICBJOiAoZCwgcCkgPT4ge1xuICAgIGNvbnN0IGhvdXJzID0gZC5nZXRIb3VycygpICUgMTI7XG4gICAgcmV0dXJuIGhvdXJzID09PSAwID8gXCIxMlwiIDogcGFkKGhvdXJzLCAyLCBwID8/IFwiMFwiKTtcbiAgfSxcbiAgajogKGQsIHApID0+IHBhZChkYXlPZlllYXIoZCkgKyAxLCAzLCBwID8/IFwiMFwiKSxcbiAgbTogKGQsIHApID0+IHBhZChkLmdldE1vbnRoKCkgKyAxLCAyLCBwID8/IFwiMFwiKSxcbiAgTTogKGQsIHApID0+IHBhZChkLmdldE1pbnV0ZXMoKSwgMiwgcCA/PyBcIjBcIiksXG4gIEw6IChkLCBwKSA9PiBwYWQoZC5nZXRNaWxsaXNlY29uZHMoKSwgMywgcCA/PyBcIjBcIiksXG4gIHA6IChkKSA9PiBkLmdldEhvdXJzKCkgPCAxMiA/IFwiQU1cIiA6IFwiUE1cIixcbiAgUTogKGQpID0+IFN0cmluZyhkLmdldFRpbWUoKSksXG4gIHM6IChkKSA9PiBTdHJpbmcoTWF0aC5mbG9vcihkLmdldFRpbWUoKSAvIDFlMykpLFxuICBTOiAoZCwgcCkgPT4gcGFkKGQuZ2V0U2Vjb25kcygpLCAyLCBwID8/IFwiMFwiKSxcbiAgdTogKGQpID0+IHtcbiAgICBsZXQgZGF5MiA9IGQuZ2V0RGF5KCk7XG4gICAgaWYgKGRheTIgPCAxKVxuICAgICAgZGF5MiArPSA3O1xuICAgIHJldHVybiBTdHJpbmcoZGF5MiAlIDcpO1xuICB9LFxuICBVOiAoZCwgcCkgPT4gcGFkKHdlZWtPZlllYXIoZCwgU1VOREFZKSwgMiwgcCA/PyBcIjBcIiksXG4gIFY6IChkLCBwKSA9PiBwYWQoaXNvV2Vla09mWWVhcihkKSwgMiwgcCA/PyBcIjBcIiksXG4gIHc6IChkLCBwKSA9PiBwYWQoZC5nZXREYXkoKSwgMiwgcCA/PyBcIjBcIiksXG4gIFc6IChkLCBwKSA9PiBwYWQod2Vla09mWWVhcihkLCBNT05EQVkpLCAyLCBwID8/IFwiMFwiKSxcbiAgeDogXCIlLW0vJS1kLyVZXCIsXG4gIFg6IFwiJS1JOiVNOiVTICVwXCIsXG4gIHk6IChkLCBwKSA9PiBwYWQoZC5nZXRGdWxsWWVhcigpICUgMTAwLCAyLCBwID8/IFwiMFwiKSxcbiAgWTogKGQsIHApID0+IHBhZChkLmdldEZ1bGxZZWFyKCksIDQsIHAgPz8gXCIwXCIpLFxuICBaOiAoZCkgPT4gdGltZXpvbmUoZCksXG4gIFwiJVwiOiAoKSA9PiBcIiVcIlxufTtcbnZhciBQQURTID0ge1xuICBfOiBcIiBcIixcbiAgXCIwXCI6IFwiMFwiLFxuICBcIi1cIjogXCJcIlxufTtcbmZ1bmN0aW9uIHBhZCh2YWx1ZSwgc2l6ZSwgcGFkQ2hhcikge1xuICBjb25zdCBvdXRwdXQgPSBTdHJpbmcoTWF0aC5mbG9vcih2YWx1ZSkpO1xuICBpZiAob3V0cHV0Lmxlbmd0aCA+PSBzaXplKSB7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxuICByZXR1cm4gYCR7cGFkQ2hhci5yZXBlYXQoc2l6ZSAtIG91dHB1dC5sZW5ndGgpfSR7b3V0cHV0fWA7XG59XG5mdW5jdGlvbiBidWlsZEZvcm1hdHRlcihmb3JtYXRTdHJpbmcpIHtcbiAgY29uc3QgZm9ybWF0UGFydHMgPSBbXTtcbiAgd2hpbGUgKGZvcm1hdFN0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgbGV0IG5leHRFc2NhcGVJZHggPSBmb3JtYXRTdHJpbmcuaW5kZXhPZihcIiVcIik7XG4gICAgaWYgKG5leHRFc2NhcGVJZHggIT09IDApIHtcbiAgICAgIGNvbnN0IGxpdGVyYWxQYXJ0ID0gbmV4dEVzY2FwZUlkeCA+IDAgPyBmb3JtYXRTdHJpbmcuc3Vic3RyaW5nKDAsIG5leHRFc2NhcGVJZHgpIDogZm9ybWF0U3RyaW5nO1xuICAgICAgZm9ybWF0UGFydHMucHVzaChsaXRlcmFsUGFydCk7XG4gICAgfVxuICAgIGlmIChuZXh0RXNjYXBlSWR4IDwgMClcbiAgICAgIGJyZWFrO1xuICAgIGNvbnN0IG1heWJlUGFkU3BlY2lmaWVyID0gZm9ybWF0U3RyaW5nW25leHRFc2NhcGVJZHggKyAxXTtcbiAgICBjb25zdCBtYXliZVBhZCA9IFBBRFNbbWF5YmVQYWRTcGVjaWZpZXJdO1xuICAgIGlmIChtYXliZVBhZCAhPSBudWxsKSB7XG4gICAgICBuZXh0RXNjYXBlSWR4Kys7XG4gICAgfVxuICAgIGNvbnN0IG1heWJlRm9ybWF0dGVyU3BlY2lmaWVyID0gZm9ybWF0U3RyaW5nW25leHRFc2NhcGVJZHggKyAxXTtcbiAgICBjb25zdCBtYXliZUZvcm1hdHRlciA9IEZPUk1BVFRFUlNbbWF5YmVGb3JtYXR0ZXJTcGVjaWZpZXJdO1xuICAgIGlmICh0eXBlb2YgbWF5YmVGb3JtYXR0ZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgZm9ybWF0UGFydHMucHVzaChbbWF5YmVGb3JtYXR0ZXIsIG1heWJlUGFkXSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbWF5YmVGb3JtYXR0ZXIgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnN0IGZvcm1hdHRlciA9IGJ1aWxkRm9ybWF0dGVyKG1heWJlRm9ybWF0dGVyKTtcbiAgICAgIGZvcm1hdFBhcnRzLnB1c2goW2Zvcm1hdHRlciwgbWF5YmVQYWRdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9ybWF0UGFydHMucHVzaChgJHttYXliZVBhZCA/PyBcIlwifSR7bWF5YmVGb3JtYXR0ZXJTcGVjaWZpZXJ9YCk7XG4gICAgfVxuICAgIGZvcm1hdFN0cmluZyA9IGZvcm1hdFN0cmluZy5zdWJzdHJpbmcobmV4dEVzY2FwZUlkeCArIDIpO1xuICB9XG4gIHJldHVybiAoZGF0ZVRpbWUpID0+IHtcbiAgICBjb25zdCBkYXRlVGltZUFzRGF0ZSA9IHR5cGVvZiBkYXRlVGltZSA9PT0gXCJudW1iZXJcIiA/IG5ldyBEYXRlKGRhdGVUaW1lKSA6IGRhdGVUaW1lO1xuICAgIHJldHVybiBmb3JtYXRQYXJ0cy5tYXAoKGMpID0+IHR5cGVvZiBjID09PSBcInN0cmluZ1wiID8gYyA6IGNbMF0oZGF0ZVRpbWVBc0RhdGUsIGNbMV0pKS5qb2luKFwiXCIpO1xuICB9O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3RpbWVGb3JtYXREZWZhdWx0cy50c1xuZnVuY3Rpb24gZGF0ZVRvTnVtYmVyKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIERhdGUgPyB2YWx1ZS5nZXRUaW1lKCkgOiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRUaW1lVGlja0Zvcm1hdCh0aWNrcywgZG9tYWluLCBmb3JtYXRPZmZzZXQpIHtcbiAgY29uc3QgZm9ybWF0U3RyaW5nID0gY2FsY3VsYXRlRGVmYXVsdFRpbWVUaWNrRm9ybWF0KHRpY2tzLCBkb21haW4sIGZvcm1hdE9mZnNldCk7XG4gIGNvbnN0IGZvcm1hdHRlciA9IGJ1aWxkRm9ybWF0dGVyKGZvcm1hdFN0cmluZyk7XG4gIHJldHVybiAoZGF0ZSkgPT4gZm9ybWF0dGVyKGRhdGUpO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlRGVmYXVsdFRpbWVUaWNrRm9ybWF0KHRpY2tzID0gW10sIGRvbWFpbiA9IHRpY2tzLCBmb3JtYXRPZmZzZXQgPSAwKSB7XG4gIGxldCBtaW5JbnRlcnZhbCA9IEluZmluaXR5O1xuICBmb3IgKGxldCBpID0gMTsgaSA8IHRpY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgbWluSW50ZXJ2YWwgPSBNYXRoLm1pbihtaW5JbnRlcnZhbCwgTWF0aC5hYnModGlja3NbaV0gLSB0aWNrc1tpIC0gMV0pKTtcbiAgfVxuICBjb25zdCBzdGFydFllYXIgPSBuZXcgRGF0ZShkb21haW5bMF0pLmdldEZ1bGxZZWFyKCk7XG4gIGNvbnN0IHN0b3BZZWFyID0gbmV3IERhdGUoZG9tYWluLmF0KC0xKSkuZ2V0RnVsbFllYXIoKTtcbiAgY29uc3QgeWVhckNoYW5nZSA9IHN0b3BZZWFyIC0gc3RhcnRZZWFyID4gMDtcbiAgY29uc3QgdGltZUZvcm1hdCA9IGlzRmluaXRlKG1pbkludGVydmFsKSA/IGdldEludGVydmFsTG93ZXN0R3JhbnVsYXJpdHlGb3JtYXQobWluSW50ZXJ2YWwsIHRpY2tzKSA6IGdldExvd2VzdEdyYW51bGFyaXR5Rm9ybWF0KHRpY2tzWzBdKTtcbiAgcmV0dXJuIGZvcm1hdFN0cmluZ0J1aWxkZXIoTWF0aC5tYXgodGltZUZvcm1hdCAtIGZvcm1hdE9mZnNldCwgMCksIHllYXJDaGFuZ2UsIHRpY2tzKTtcbn1cbmZ1bmN0aW9uIGdldEludGVydmFsTG93ZXN0R3JhbnVsYXJpdHlGb3JtYXQodmFsdWUsIHRpY2tzKSB7XG4gIGlmICh2YWx1ZSA8IGR1cmF0aW9uU2Vjb25kKSB7XG4gICAgcmV0dXJuIDAgLyogTUlMTElTRUNPTkQgKi87XG4gIH0gZWxzZSBpZiAodmFsdWUgPCBkdXJhdGlvbk1pbnV0ZSkge1xuICAgIHJldHVybiAxIC8qIFNFQ09ORCAqLztcbiAgfSBlbHNlIGlmICh2YWx1ZSA8IGR1cmF0aW9uSG91cikge1xuICAgIHJldHVybiAyIC8qIE1JTlVURSAqLztcbiAgfSBlbHNlIGlmICh2YWx1ZSA8IGR1cmF0aW9uRGF5KSB7XG4gICAgcmV0dXJuIDMgLyogSE9VUiAqLztcbiAgfSBlbHNlIGlmICh2YWx1ZSA8IGR1cmF0aW9uV2Vlaykge1xuICAgIHJldHVybiA0IC8qIFdFRUtfREFZICovO1xuICB9IGVsc2UgaWYgKHZhbHVlIDwgZHVyYXRpb25EYXkgKiAyOCB8fCB2YWx1ZSA8IGR1cmF0aW9uRGF5ICogMzEgJiYgaGFzRHVwbGljYXRlTW9udGgodGlja3MpKSB7XG4gICAgcmV0dXJuIDUgLyogU0hPUlRfTU9OVEggKi87XG4gIH0gZWxzZSBpZiAodmFsdWUgPCBkdXJhdGlvblllYXIpIHtcbiAgICByZXR1cm4gNiAvKiBNT05USCAqLztcbiAgfVxuICByZXR1cm4gNyAvKiBZRUFSICovO1xufVxuZnVuY3Rpb24gZ2V0TG93ZXN0R3JhbnVsYXJpdHlGb3JtYXQodmFsdWUpIHtcbiAgaWYgKHNlY29uZF9kZWZhdWx0LmZsb29yKHZhbHVlKSA8IHZhbHVlKSB7XG4gICAgcmV0dXJuIDAgLyogTUlMTElTRUNPTkQgKi87XG4gIH0gZWxzZSBpZiAobWludXRlX2RlZmF1bHQuZmxvb3IodmFsdWUpIDwgdmFsdWUpIHtcbiAgICByZXR1cm4gMSAvKiBTRUNPTkQgKi87XG4gIH0gZWxzZSBpZiAoaG91cl9kZWZhdWx0LmZsb29yKHZhbHVlKSA8IHZhbHVlKSB7XG4gICAgcmV0dXJuIDIgLyogTUlOVVRFICovO1xuICB9IGVsc2UgaWYgKGRheV9kZWZhdWx0LmZsb29yKHZhbHVlKSA8IHZhbHVlKSB7XG4gICAgcmV0dXJuIDMgLyogSE9VUiAqLztcbiAgfSBlbHNlIGlmIChtb250aF9kZWZhdWx0LmZsb29yKHZhbHVlKSA8IHZhbHVlKSB7XG4gICAgaWYgKHdlZWtfZGVmYXVsdC5mbG9vcih2YWx1ZSkgPCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIDQgLyogV0VFS19EQVkgKi87XG4gICAgfVxuICAgIHJldHVybiA1IC8qIFNIT1JUX01PTlRIICovO1xuICB9IGVsc2UgaWYgKHllYXJfZGVmYXVsdC5mbG9vcih2YWx1ZSkgPCB2YWx1ZSkge1xuICAgIHJldHVybiA2IC8qIE1PTlRIICovO1xuICB9XG4gIHJldHVybiA3IC8qIFlFQVIgKi87XG59XG5mdW5jdGlvbiBoYXNEdXBsaWNhdGVNb250aCh0aWNrcykge1xuICBsZXQgcHJldk1vbnRoID0gbmV3IERhdGUodGlja3NbMF0pLmdldE1vbnRoKCk7XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgdGlja3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB0aWNrTW9udGggPSBuZXcgRGF0ZSh0aWNrc1tpXSkuZ2V0TW9udGgoKTtcbiAgICBpZiAocHJldk1vbnRoID09PSB0aWNrTW9udGgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBwcmV2TW9udGggPSB0aWNrTW9udGg7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZm9ybWF0U3RyaW5nQnVpbGRlcihkZWZhdWx0VGltZUZvcm1hdCwgeWVhckNoYW5nZSwgdGlja3MpIHtcbiAgY29uc3QgZmlyc3RUaWNrID0gZGF0ZVRvTnVtYmVyKHRpY2tzWzBdKTtcbiAgY29uc3QgbGFzdFRpY2sgPSBkYXRlVG9OdW1iZXIodGlja3MuYXQoLTEpKTtcbiAgY29uc3QgZXh0ZW50MiA9IE1hdGguYWJzKGxhc3RUaWNrIC0gZmlyc3RUaWNrKTtcbiAgY29uc3QgYWN0aXZlWWVhciA9IHllYXJDaGFuZ2UgfHwgZGVmYXVsdFRpbWVGb3JtYXQgPT09IDcgLyogWUVBUiAqLztcbiAgY29uc3QgYWN0aXZlRGF0ZSA9IGV4dGVudDIgPT09IDA7XG4gIGNvbnN0IHBhcnRzID0gW1xuICAgIFtcImhvdXJcIiwgNiAqIGR1cmF0aW9uSG91ciwgMTQgKiBkdXJhdGlvbkRheSwgMyAvKiBIT1VSICovLCBcIiVJICVwXCJdLFxuICAgIFtcImhvdXJcIiwgZHVyYXRpb25NaW51dGUsIDYgKiBkdXJhdGlvbkhvdXIsIDMgLyogSE9VUiAqLywgXCIlSTolTVwiXSxcbiAgICBbXCJzZWNvbmRcIiwgMWUzLCA2ICogZHVyYXRpb25Ib3VyLCAxIC8qIFNFQ09ORCAqLywgXCI6JVNcIl0sXG4gICAgW1wibXNcIiwgMCwgNiAqIGR1cmF0aW9uSG91ciwgMCAvKiBNSUxMSVNFQ09ORCAqLywgXCIuJUxcIl0sXG4gICAgW1wiYW0vcG1cIiwgZHVyYXRpb25NaW51dGUsIDYgKiBkdXJhdGlvbkhvdXIsIDMgLyogSE9VUiAqLywgXCIlcFwiXSxcbiAgICBcIiBcIixcbiAgICBbXCJkYXlcIiwgZHVyYXRpb25EYXksIGR1cmF0aW9uV2VlaywgNCAvKiBXRUVLX0RBWSAqLywgXCIlYVwiXSxcbiAgICBbXCJtb250aFwiLCBhY3RpdmVEYXRlID8gMCA6IGR1cmF0aW9uV2VlaywgNTIgKiBkdXJhdGlvbldlZWssIDUgLyogU0hPUlRfTU9OVEggKi8sIFwiJWIgJWRcIl0sXG4gICAgW1wibW9udGhcIiwgNSAqIGR1cmF0aW9uV2VlaywgMTAgKiBkdXJhdGlvblllYXIsIDYgLyogTU9OVEggKi8sIFwiJUJcIl0sXG4gICAgXCIgXCIsXG4gICAgW1wieWVhclwiLCBhY3RpdmVZZWFyID8gMCA6IGR1cmF0aW9uWWVhciwgSW5maW5pdHksIDcgLyogWUVBUiAqLywgXCIlWVwiXVxuICBdO1xuICBjb25zdCBmb3JtYXRQYXJ0cyA9IHBhcnRzLmZpbHRlcigodikgPT4ge1xuICAgIGlmICh0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IFtfLCBtaW4sIG1heCwgZm9ybWF0XSA9IHY7XG4gICAgcmV0dXJuIGZvcm1hdCA+PSBkZWZhdWx0VGltZUZvcm1hdCAmJiBtaW4gPD0gZXh0ZW50MiAmJiBleHRlbnQyIDwgbWF4O1xuICB9KS5yZWR1Y2UoXG4gICAgKHIsIG5leHQpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgbmV4dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByLnJlc3VsdC5wdXNoKG5leHQpO1xuICAgICAgfSBlbHNlIGlmICghci51c2VkLmhhcyhuZXh0WzBdKSkge1xuICAgICAgICByLnJlc3VsdC5wdXNoKG5leHQpO1xuICAgICAgICByLnVzZWQuYWRkKG5leHRbMF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHI7XG4gICAgfSxcbiAgICB7IHJlc3VsdDogW10sIHVzZWQ6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkgfVxuICApLnJlc3VsdDtcbiAgY29uc3QgZmlyc3RGb3JtYXQgPSBmb3JtYXRQYXJ0cy5maW5kSW5kZXgoKHYpID0+IHR5cGVvZiB2ICE9PSBcInN0cmluZ1wiKTtcbiAgY29uc3QgbGFzdEZvcm1hdCA9IGZvcm1hdFBhcnRzLmZpbmRMYXN0SW5kZXgoKHYpID0+IHR5cGVvZiB2ICE9PSBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIGZvcm1hdFBhcnRzLnNsaWNlKGZpcnN0Rm9ybWF0LCBsYXN0Rm9ybWF0ICsgMSkubWFwKCh2KSA9PiB0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIiA/IHYgOiB2WzRdKS5qb2luKFwiXCIpLnJlcGxhY2VBbGwoL1xccysvZywgXCIgXCIpLnRyaW0oKTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NhbGUvYmFuZFNjYWxlLnRzXG52YXIgX0JhbmRTY2FsZSA9IGNsYXNzIF9CYW5kU2NhbGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnR5cGUgPSBcImJhbmRcIjtcbiAgICB0aGlzLmludmFsaWQgPSB0cnVlO1xuICAgIHRoaXMucmFuZ2UgPSBbMCwgMV07XG4gICAgdGhpcy5yb3VuZCA9IGZhbHNlO1xuICAgIHRoaXMuaW50ZXJ2YWwgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogTWFwcyBkYXR1bSB0byBpdHMgaW5kZXggaW4gdGhlIHtAbGluayBkb21haW59IGFycmF5LlxuICAgICAqIFVzZWQgdG8gY2hlY2sgZm9yIGR1cGxpY2F0ZSBkYXRhIChub3QgYWxsb3dlZCkuXG4gICAgICovXG4gICAgdGhpcy5pbmRleCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgLyoqXG4gICAgICogVGhlIG91dHB1dCByYW5nZSB2YWx1ZXMgZm9yIGRhdHVtIGF0IGVhY2ggaW5kZXguXG4gICAgICovXG4gICAgdGhpcy5vcmRpbmFsUmFuZ2UgPSBbXTtcbiAgICAvKipcbiAgICAgKiBDb250YWlucyB1bmlxdWUgZGF0YSBvbmx5LlxuICAgICAqL1xuICAgIHRoaXMuX2RvbWFpbiA9IFtdO1xuICAgIHRoaXMuX2JhbmR3aWR0aCA9IDE7XG4gICAgdGhpcy5fc3RlcCA9IDE7XG4gICAgdGhpcy5faW5zZXQgPSAxO1xuICAgIHRoaXMuX3Jhd0JhbmR3aWR0aCA9IDE7XG4gICAgLyoqXG4gICAgICogVGhlIHJhdGlvIG9mIHRoZSByYW5nZSB0aGF0IGlzIHJlc2VydmVkIGZvciBzcGFjZSBiZXR3ZWVuIGJhbmRzLlxuICAgICAqL1xuICAgIHRoaXMuX3BhZGRpbmdJbm5lciA9IDA7XG4gICAgLyoqXG4gICAgICogVGhlIHJhdGlvIG9mIHRoZSByYW5nZSB0aGF0IGlzIHJlc2VydmVkIGZvciBzcGFjZSBiZWZvcmUgdGhlIGZpcnN0XG4gICAgICogYW5kIGFmdGVyIHRoZSBsYXN0IGJhbmQuXG4gICAgICovXG4gICAgdGhpcy5fcGFkZGluZ091dGVyID0gMDtcbiAgfVxuICBzdGF0aWMgaXModmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBfQmFuZFNjYWxlO1xuICB9XG4gIHJlZnJlc2goKSB7XG4gICAgaWYgKCF0aGlzLmludmFsaWQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5pbnZhbGlkID0gZmFsc2U7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgICBpZiAodGhpcy5pbnZhbGlkKSB7XG4gICAgICBMb2dnZXIud2Fybk9uY2UoXCJFeHBlY3RlZCB1cGRhdGUgdG8gbm90IGludmFsaWRhdGUgc2NhbGVcIik7XG4gICAgfVxuICB9XG4gIHNldCBkb21haW4odmFsdWVzKSB7XG4gICAgdGhpcy5pbmRleCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5pbnZhbGlkID0gdHJ1ZTtcbiAgICB0aGlzLl9kb21haW4gPSBbXTtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgY29uc3Qga2V5ID0gZGF0ZVRvTnVtYmVyKHZhbHVlKTtcbiAgICAgIGlmICh0aGlzLmdldEluZGV4KGtleSkgPT09IHZvaWQgMCkge1xuICAgICAgICB0aGlzLmluZGV4LnNldChrZXksIHRoaXMuX2RvbWFpbi5wdXNoKHZhbHVlKSAtIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQgZG9tYWluKCkge1xuICAgIHJldHVybiB0aGlzLl9kb21haW47XG4gIH1cbiAgZ2V0RG9tYWluKCkge1xuICAgIHJldHVybiB0aGlzLl9kb21haW47XG4gIH1cbiAgdGlja3MoKSB7XG4gICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgcmV0dXJuIHRoaXMuX2RvbWFpbjtcbiAgfVxuICBjb252ZXJ0KGQpIHtcbiAgICB0aGlzLnJlZnJlc2goKTtcbiAgICBjb25zdCBpID0gdGhpcy5nZXRJbmRleChkKTtcbiAgICBpZiAoaSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5vcmRpbmFsUmFuZ2VbaV0gPz8gTmFOO1xuICB9XG4gIGludmVydChwb3NpdGlvbikge1xuICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5vcmRpbmFsUmFuZ2UuZmluZEluZGV4KChwKSA9PiBwID09PSBwb3NpdGlvbik7XG4gICAgcmV0dXJuIHRoaXMuZG9tYWluW2luZGV4XTtcbiAgfVxuICBpbnZlcnROZWFyZXN0KHBvc2l0aW9uKSB7XG4gICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgbGV0IG5lYXJlc3QgPSAtMTtcbiAgICBsZXQgbWluRGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMub3JkaW5hbFJhbmdlLmZpbmRJbmRleCgocCwgaSkgPT4ge1xuICAgICAgaWYgKHAgPT09IHBvc2l0aW9uKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNvbnN0IGRpc3RhbmNlMyA9IE1hdGguYWJzKHBvc2l0aW9uIC0gcCk7XG4gICAgICBpZiAoZGlzdGFuY2UzIDwgbWluRGlzdGFuY2UpIHtcbiAgICAgICAgbWluRGlzdGFuY2UgPSBkaXN0YW5jZTM7XG4gICAgICAgIG5lYXJlc3QgPSBpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmRvbWFpbltpbmRleF0gPz8gdGhpcy5kb21haW5bbmVhcmVzdF07XG4gIH1cbiAgZ2V0IGJhbmR3aWR0aCgpIHtcbiAgICB0aGlzLnJlZnJlc2goKTtcbiAgICByZXR1cm4gdGhpcy5fYmFuZHdpZHRoO1xuICB9XG4gIGdldCBzdGVwKCkge1xuICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIHJldHVybiB0aGlzLl9zdGVwO1xuICB9XG4gIGdldCBpbnNldCgpIHtcbiAgICB0aGlzLnJlZnJlc2goKTtcbiAgICByZXR1cm4gdGhpcy5faW5zZXQ7XG4gIH1cbiAgZ2V0IHJhd0JhbmR3aWR0aCgpIHtcbiAgICB0aGlzLnJlZnJlc2goKTtcbiAgICByZXR1cm4gdGhpcy5fcmF3QmFuZHdpZHRoO1xuICB9XG4gIHNldCBwYWRkaW5nKHZhbHVlKSB7XG4gICAgdmFsdWUgPSBjbGFtcCgwLCB2YWx1ZSwgMSk7XG4gICAgdGhpcy5fcGFkZGluZ0lubmVyID0gdmFsdWU7XG4gICAgdGhpcy5fcGFkZGluZ091dGVyID0gdmFsdWU7XG4gIH1cbiAgZ2V0IHBhZGRpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZGRpbmdJbm5lcjtcbiAgfVxuICBzZXQgcGFkZGluZ0lubmVyKHZhbHVlKSB7XG4gICAgdGhpcy5fcGFkZGluZ0lubmVyID0gY2xhbXAoMCwgdmFsdWUsIDEpO1xuICB9XG4gIGdldCBwYWRkaW5nSW5uZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZGRpbmdJbm5lcjtcbiAgfVxuICBzZXQgcGFkZGluZ091dGVyKHZhbHVlKSB7XG4gICAgdGhpcy5fcGFkZGluZ091dGVyID0gY2xhbXAoMCwgdmFsdWUsIDEpO1xuICB9XG4gIGdldCBwYWRkaW5nT3V0ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZGRpbmdPdXRlcjtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgY29uc3QgY291bnQgPSB0aGlzLl9kb21haW4ubGVuZ3RoO1xuICAgIGlmIChjb3VudCA9PT0gMClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBbcjAsIHIxXSA9IHRoaXMucmFuZ2U7XG4gICAgbGV0IHsgX3BhZGRpbmdJbm5lcjogcGFkZGluZ0lubmVyIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgX3BhZGRpbmdPdXRlcjogcGFkZGluZ091dGVyLCByb3VuZDogcm91bmQ1IH0gPSB0aGlzO1xuICAgIGNvbnN0IHJhbmdlRGlzdGFuY2UgPSByMSAtIHIwO1xuICAgIGxldCByYXdTdGVwO1xuICAgIGlmIChjb3VudCA9PT0gMSkge1xuICAgICAgcGFkZGluZ0lubmVyID0gMDtcbiAgICAgIHJhd1N0ZXAgPSByYW5nZURpc3RhbmNlICogKDEgLSBwYWRkaW5nT3V0ZXIgKiAyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmF3U3RlcCA9IHJhbmdlRGlzdGFuY2UgLyBNYXRoLm1heCgxLCBjb3VudCAtIHBhZGRpbmdJbm5lciArIHBhZGRpbmdPdXRlciAqIDIpO1xuICAgIH1cbiAgICBjb25zdCBzdGVwID0gcm91bmQ1ID8gTWF0aC5mbG9vcihyYXdTdGVwKSA6IHJhd1N0ZXA7XG4gICAgbGV0IGluc2V0ID0gcjAgKyAocmFuZ2VEaXN0YW5jZSAtIHN0ZXAgKiAoY291bnQgLSBwYWRkaW5nSW5uZXIpKSAvIDI7XG4gICAgbGV0IGJhbmR3aWR0aCA9IHN0ZXAgKiAoMSAtIHBhZGRpbmdJbm5lcik7XG4gICAgaWYgKHJvdW5kNSkge1xuICAgICAgaW5zZXQgPSBNYXRoLnJvdW5kKGluc2V0KTtcbiAgICAgIGJhbmR3aWR0aCA9IE1hdGgucm91bmQoYmFuZHdpZHRoKTtcbiAgICB9XG4gICAgdGhpcy5fc3RlcCA9IHN0ZXA7XG4gICAgdGhpcy5faW5zZXQgPSBpbnNldDtcbiAgICB0aGlzLl9iYW5kd2lkdGggPSBiYW5kd2lkdGg7XG4gICAgdGhpcy5fcmF3QmFuZHdpZHRoID0gcmF3U3RlcCAqICgxIC0gcGFkZGluZ0lubmVyKTtcbiAgICB0aGlzLm9yZGluYWxSYW5nZSA9IHRoaXMuX2RvbWFpbi5tYXAoKF8sIGkpID0+IGluc2V0ICsgc3RlcCAqIGkpO1xuICB9XG4gIGdldEluZGV4KHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXguZ2V0KHZhbHVlIGluc3RhbmNlb2YgRGF0ZSA/IHZhbHVlLmdldFRpbWUoKSA6IHZhbHVlKTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEludmFsaWRhdGluZ1xuXSwgX0JhbmRTY2FsZS5wcm90b3R5cGUsIFwicmFuZ2VcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBJbnZhbGlkYXRpbmdcbl0sIF9CYW5kU2NhbGUucHJvdG90eXBlLCBcInJvdW5kXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgSW52YWxpZGF0aW5nXG5dLCBfQmFuZFNjYWxlLnByb3RvdHlwZSwgXCJpbnRlcnZhbFwiLCAyKTtcbnZhciBCYW5kU2NhbGUgPSBfQmFuZFNjYWxlO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3Byb3BlcnRpZXMudHNcbnZhciBCYXNlUHJvcGVydGllcyA9IGNsYXNzIHtcbiAgc2V0KHByb3BlcnRpZXMpIHtcbiAgICBjb25zdCB7IGNsYXNzTmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZSB9ID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICBpZiAodHlwZW9mIHByb3BlcnRpZXMgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgIExvZ2dlci53YXJuKGB1bmFibGUgdG8gc2V0ICR7Y2xhc3NOYW1lfSAtIGV4cGVjdGluZyBhIHByb3BlcnRpZXMgb2JqZWN0YCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY29uc3Qga2V5cyA9IG5ldyBTZXQoT2JqZWN0LmtleXMocHJvcGVydGllcykpO1xuICAgIGZvciAoY29uc3QgcHJvcGVydHlLZXkgb2YgbGlzdERlY29yYXRlZFByb3BlcnRpZXModGhpcykpIHtcbiAgICAgIGlmIChrZXlzLmhhcyhwcm9wZXJ0eUtleSkpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwcm9wZXJ0aWVzW3Byb3BlcnR5S2V5XTtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmIChpc1Byb3BlcnRpZXMoc2VsZltwcm9wZXJ0eUtleV0pKSB7XG4gICAgICAgICAgaWYgKHNlbGZbcHJvcGVydHlLZXldIGluc3RhbmNlb2YgUHJvcGVydGllc0FycmF5KSB7XG4gICAgICAgICAgICBjb25zdCBhcnJheTIgPSBzZWxmW3Byb3BlcnR5S2V5XS5yZXNldCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoYXJyYXkyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgc2VsZltwcm9wZXJ0eUtleV0gPSBhcnJheTI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBMb2dnZXIud2FybihgdW5hYmxlIHRvIHNldCBbJHtwcm9wZXJ0eUtleX1dIC0gZXhwZWN0aW5nIGEgcHJvcGVydGllcyBhcnJheWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmW3Byb3BlcnR5S2V5XS5zZXQodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmW3Byb3BlcnR5S2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGtleXMuZGVsZXRlKHByb3BlcnR5S2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCB1bmtub3duS2V5IG9mIGtleXMpIHtcbiAgICAgIExvZ2dlci53YXJuKGB1bmFibGUgdG8gc2V0IFske3Vua25vd25LZXl9XSBpbiAke2NsYXNzTmFtZX0gLSBwcm9wZXJ0eSBpcyB1bmtub3duYCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGlzVmFsaWQod2FybmluZ1ByZWZpeCkge1xuICAgIHJldHVybiBsaXN0RGVjb3JhdGVkUHJvcGVydGllcyh0aGlzKS5ldmVyeSgocHJvcGVydHlLZXkpID0+IHtcbiAgICAgIGNvbnN0IHsgb3B0aW9uYWwgfSA9IGV4dHJhY3REZWNvcmF0ZWRQcm9wZXJ0eU1ldGFkYXRhKHRoaXMsIHByb3BlcnR5S2V5KTtcbiAgICAgIGNvbnN0IHZhbGlkID0gb3B0aW9uYWwgPT09IHRydWUgfHwgdHlwZW9mIHRoaXNbcHJvcGVydHlLZXldICE9PSBcInVuZGVmaW5lZFwiO1xuICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICBMb2dnZXIud2Fybk9uY2UoYCR7d2FybmluZ1ByZWZpeCA/PyBcIlwifVske3Byb3BlcnR5S2V5fV0gaXMgcmVxdWlyZWQuYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsaWQ7XG4gICAgfSk7XG4gIH1cbiAgdG9Kc29uKCkge1xuICAgIHJldHVybiBsaXN0RGVjb3JhdGVkUHJvcGVydGllcyh0aGlzKS5yZWR1Y2UoKG9iamVjdDIsIHByb3BlcnR5S2V5KSA9PiB7XG4gICAgICBjb25zdCBwcm9wZXJ0eVZhbHVlID0gdGhpc1twcm9wZXJ0eUtleV07XG4gICAgICBvYmplY3QyW3Byb3BlcnR5S2V5XSA9IGlzUHJvcGVydGllcyhwcm9wZXJ0eVZhbHVlKSA/IHByb3BlcnR5VmFsdWUudG9Kc29uKCkgOiBwcm9wZXJ0eVZhbHVlO1xuICAgICAgcmV0dXJuIG9iamVjdDI7XG4gICAgfSwge30pO1xuICB9XG59O1xudmFyIFByb3BlcnRpZXNBcnJheSA9IGNsYXNzIF9Qcm9wZXJ0aWVzQXJyYXkgZXh0ZW5kcyBBcnJheSB7XG4gIGNvbnN0cnVjdG9yKGl0ZW1GYWN0b3J5LCAuLi5wcm9wZXJ0aWVzKSB7XG4gICAgc3VwZXIocHJvcGVydGllcy5sZW5ndGgpO1xuICAgIGNvbnN0IGlzQ29uc3RydWN0b3IgPSAodmFsdWUyKSA9PiBCb29sZWFuKHZhbHVlMj8ucHJvdG90eXBlPy5jb25zdHJ1Y3Rvcj8ubmFtZSk7XG4gICAgY29uc3QgdmFsdWUgPSBpc0NvbnN0cnVjdG9yKGl0ZW1GYWN0b3J5KSA/IChwYXJhbXMpID0+IG5ldyBpdGVtRmFjdG9yeSgpLnNldChwYXJhbXMpIDogaXRlbUZhY3Rvcnk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaXRlbUZhY3RvcnlcIiwgeyB2YWx1ZSwgZW51bWVyYWJsZTogZmFsc2UsIGNvbmZpZ3VyYWJsZTogZmFsc2UgfSk7XG4gICAgdGhpcy5zZXQocHJvcGVydGllcyk7XG4gIH1cbiAgc2V0KHByb3BlcnRpZXMpIHtcbiAgICBpZiAoaXNBcnJheShwcm9wZXJ0aWVzKSkge1xuICAgICAgdGhpcy5sZW5ndGggPSBwcm9wZXJ0aWVzLmxlbmd0aDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzW2ldID0gdGhpcy5pdGVtRmFjdG9yeShwcm9wZXJ0aWVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVzZXQocHJvcGVydGllcykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BlcnRpZXMpKSB7XG4gICAgICByZXR1cm4gbmV3IF9Qcm9wZXJ0aWVzQXJyYXkodGhpcy5pdGVtRmFjdG9yeSwgLi4ucHJvcGVydGllcyk7XG4gICAgfVxuICB9XG4gIHRvSnNvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAoKHZhbHVlKSA9PiB2YWx1ZT8udG9Kc29uPy4oKSA/PyB2YWx1ZSk7XG4gIH1cbn07XG5mdW5jdGlvbiBpc1Byb3BlcnRpZXModmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgQmFzZVByb3BlcnRpZXMgfHwgdmFsdWUgaW5zdGFuY2VvZiBQcm9wZXJ0aWVzQXJyYXk7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvdmFsaWRhdGlvbi50c1xuZnVuY3Rpb24gVmFsaWRhdGUocHJlZGljYXRlLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgeyBvcHRpb25hbCA9IGZhbHNlLCBwcm9wZXJ0eTogb3ZlcnJpZGVQcm9wZXJ0eSB9ID0gb3B0aW9ucztcbiAgcmV0dXJuIGFkZFRyYW5zZm9ybVRvSW5zdGFuY2VQcm9wZXJ0eShcbiAgICAodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSB7IC4uLm9wdGlvbnMsIHRhcmdldCwgcHJvcGVydHkgfTtcbiAgICAgIGlmIChvcHRpb25hbCAmJiB0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIgfHwgcHJlZGljYXRlKHZhbHVlLCBjb250ZXh0KSkge1xuICAgICAgICBpZiAoaXNQcm9wZXJ0aWVzKHRhcmdldFtwcm9wZXJ0eV0pICYmICFpc1Byb3BlcnRpZXModmFsdWUpKSB7XG4gICAgICAgICAgdGFyZ2V0W3Byb3BlcnR5XS5zZXQodmFsdWUpO1xuICAgICAgICAgIHJldHVybiB0YXJnZXRbcHJvcGVydHldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNsZWFuS2V5ID0gb3ZlcnJpZGVQcm9wZXJ0eSA/PyBTdHJpbmcocHJvcGVydHkpLnJlcGxhY2UoL15fKi8sIFwiXCIpO1xuICAgICAgY29uc3QgdGFyZ2V0TmFtZSA9IHRhcmdldC5jb25zdHJ1Y3Rvci5jbGFzc05hbWUgPz8gdGFyZ2V0LmNvbnN0cnVjdG9yLm5hbWUucmVwbGFjZSgvUHJvcGVydGllcyQvLCBcIlwiKTtcbiAgICAgIGxldCB2YWx1ZVN0cmluZyA9IHN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICBjb25zdCBtYXhMZW5ndGggPSA1MDtcbiAgICAgIGlmICh2YWx1ZVN0cmluZyAhPSBudWxsICYmIHZhbHVlU3RyaW5nLmxlbmd0aCA+IG1heExlbmd0aCkge1xuICAgICAgICBjb25zdCBleGNlc3NDaGFyYWN0ZXJzID0gdmFsdWVTdHJpbmcubGVuZ3RoIC0gbWF4TGVuZ3RoO1xuICAgICAgICB2YWx1ZVN0cmluZyA9IHZhbHVlU3RyaW5nLnNsaWNlKDAsIG1heExlbmd0aCkgKyBgLi4uICgrJHtleGNlc3NDaGFyYWN0ZXJzfSBjaGFyYWN0ZXJzKWA7XG4gICAgICB9XG4gICAgICBMb2dnZXIud2FybihcbiAgICAgICAgYFByb3BlcnR5IFske2NsZWFuS2V5fV0gb2YgWyR7dGFyZ2V0TmFtZX1dIGNhbm5vdCBiZSBzZXQgdG8gWyR7dmFsdWVTdHJpbmd9XSR7cHJlZGljYXRlLm1lc3NhZ2UgPyBgOyBleHBlY3RpbmcgJHtnZXRQcmVkaWNhdGVNZXNzYWdlKHByZWRpY2F0ZSwgY29udGV4dCl9YCA6IFwiXCJ9LCBpZ25vcmluZy5gXG4gICAgICApO1xuICAgICAgcmV0dXJuIEJSRUFLX1RSQU5TRk9STV9DSEFJTjtcbiAgICB9LFxuICAgIHZvaWQgMCxcbiAgICB7IG9wdGlvbmFsIH1cbiAgKTtcbn1cbnZhciBBTkQgPSAoLi4ucHJlZGljYXRlcykgPT4ge1xuICBjb25zdCBtZXNzYWdlcyA9IFtdO1xuICByZXR1cm4gcHJlZGljYXRlV2l0aE1lc3NhZ2UoXG4gICAgKHZhbHVlLCBjdHgpID0+IHtcbiAgICAgIG1lc3NhZ2VzLmxlbmd0aCA9IDA7XG4gICAgICByZXR1cm4gcHJlZGljYXRlcy5ldmVyeSgocHJlZGljYXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IGlzVmFsaWQyID0gcHJlZGljYXRlKHZhbHVlLCBjdHgpO1xuICAgICAgICBpZiAoIWlzVmFsaWQyKSB7XG4gICAgICAgICAgbWVzc2FnZXMucHVzaChnZXRQcmVkaWNhdGVNZXNzYWdlKHByZWRpY2F0ZSwgY3R4KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzVmFsaWQyO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICAoKSA9PiBtZXNzYWdlcy5maWx0ZXIoQm9vbGVhbikuam9pbihcIiBBTkQgXCIpXG4gICk7XG59O1xudmFyIE9SID0gKC4uLnByZWRpY2F0ZXMpID0+IHByZWRpY2F0ZVdpdGhNZXNzYWdlKFxuICAodmFsdWUsIGN0eCkgPT4gcHJlZGljYXRlcy5zb21lKChwcmVkaWNhdGUpID0+IHByZWRpY2F0ZSh2YWx1ZSwgY3R4KSksXG4gIChjdHgpID0+IHByZWRpY2F0ZXMubWFwKGdldFByZWRpY2F0ZU1lc3NhZ2VNYXBwZXIoY3R4KSkuZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCIgT1IgXCIpXG4pO1xudmFyIE9CSkVDVCA9IGF0dGFjaE9iamVjdFJlc3RyaWN0aW9ucyhcbiAgcHJlZGljYXRlV2l0aE1lc3NhZ2UoXG4gICAgKHZhbHVlLCBjdHgpID0+IGlzUHJvcGVydGllcyh2YWx1ZSkgfHwgaXNPYmplY3QodmFsdWUpICYmIGlzUHJvcGVydGllcyhjdHgudGFyZ2V0W2N0eC5wcm9wZXJ0eV0pLFxuICAgIFwiYSBwcm9wZXJ0aWVzIG9iamVjdFwiXG4gIClcbik7XG52YXIgUExBSU5fT0JKRUNUID0gYXR0YWNoT2JqZWN0UmVzdHJpY3Rpb25zKHByZWRpY2F0ZVdpdGhNZXNzYWdlKCh2YWx1ZSkgPT4gaXNPYmplY3QodmFsdWUpLCBcImFuIG9iamVjdFwiKSk7XG52YXIgQk9PTEVBTiA9IHByZWRpY2F0ZVdpdGhNZXNzYWdlKGlzQm9vbGVhbiwgXCJhIGJvb2xlYW5cIik7XG52YXIgRlVOQ1RJT04gPSBwcmVkaWNhdGVXaXRoTWVzc2FnZShpc0Z1bmN0aW9uLCBcImEgZnVuY3Rpb25cIik7XG52YXIgU1RSSU5HID0gcHJlZGljYXRlV2l0aE1lc3NhZ2UoaXNTdHJpbmcsIFwiYSBzdHJpbmdcIik7XG52YXIgTlVNQkVSID0gYXR0YWNoTnVtYmVyUmVzdHJpY3Rpb25zKHByZWRpY2F0ZVdpdGhNZXNzYWdlKGlzRmluaXRlTnVtYmVyLCBcImEgbnVtYmVyXCIpKTtcbnZhciBSRUFMX05VTUJFUiA9IHByZWRpY2F0ZVdpdGhNZXNzYWdlKCh2YWx1ZSkgPT4gaXNOdW1iZXIodmFsdWUpICYmICFpc05hTih2YWx1ZSksIFwiYSByZWFsIG51bWJlclwiKTtcbnZhciBOQU4gPSBwcmVkaWNhdGVXaXRoTWVzc2FnZSgodmFsdWUpID0+IGlzTnVtYmVyKHZhbHVlKSAmJiBpc05hTih2YWx1ZSksIFwiTmFOXCIpO1xudmFyIFBPU0lUSVZFX05VTUJFUiA9IE5VTUJFUi5yZXN0cmljdCh7IG1pbjogMCB9KTtcbnZhciBSQVRJTyA9IE5VTUJFUi5yZXN0cmljdCh7IG1pbjogMCwgbWF4OiAxIH0pO1xudmFyIERFR1JFRSA9IE5VTUJFUi5yZXN0cmljdCh7IG1pbjogLTM2MCwgbWF4OiAzNjAgfSk7XG52YXIgTlVNQkVSX09SX05BTiA9IE9SKE5VTUJFUiwgTkFOKTtcbnZhciBBUlJBWSA9IGF0dGFjaEFycmF5UmVzdHJpY3Rpb25zKHByZWRpY2F0ZVdpdGhNZXNzYWdlKGlzQXJyYXksIFwiYW4gYXJyYXlcIikpO1xudmFyIEFSUkFZX09GID0gKHByZWRpY2F0ZSwgbWVzc2FnZSkgPT4gcHJlZGljYXRlV2l0aE1lc3NhZ2UoXG4gICh2YWx1ZSwgY3R4KSA9PiBpc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5ldmVyeSgoaXRlbSkgPT4gcHJlZGljYXRlKGl0ZW0sIGN0eCkpLFxuICAoY3R4KSA9PiB7XG4gICAgY29uc3QgYXJyYXlNZXNzYWdlID0gZ2V0UHJlZGljYXRlTWVzc2FnZShBUlJBWSwgY3R4KSA/PyBcIlwiO1xuICAgIHJldHVybiBtZXNzYWdlID8gYCR7YXJyYXlNZXNzYWdlfSBvZiAke21lc3NhZ2V9YCA6IGFycmF5TWVzc2FnZTtcbiAgfVxuKTtcbnZhciBpc0NvbXBhcmFibGUgPSAodmFsdWUpID0+IGlzRmluaXRlTnVtYmVyKHZhbHVlKSB8fCBpc1ZhbGlkRGF0ZSh2YWx1ZSk7XG52YXIgTEVTU19USEFOID0gKG90aGVyRmllbGQpID0+IHByZWRpY2F0ZVdpdGhNZXNzYWdlKFxuICAodiwgY3R4KSA9PiAhaXNDb21wYXJhYmxlKHYpIHx8ICFpc0NvbXBhcmFibGUoY3R4LnRhcmdldFtvdGhlckZpZWxkXSkgfHwgdiA8IGN0eC50YXJnZXRbb3RoZXJGaWVsZF0sXG4gIGB0byBiZSBsZXNzIHRoYW4gJHtvdGhlckZpZWxkfWBcbik7XG52YXIgR1JFQVRFUl9USEFOID0gKG90aGVyRmllbGQpID0+IHByZWRpY2F0ZVdpdGhNZXNzYWdlKFxuICAodiwgY3R4KSA9PiAhaXNDb21wYXJhYmxlKHYpIHx8ICFpc0NvbXBhcmFibGUoY3R4LnRhcmdldFtvdGhlckZpZWxkXSkgfHwgdiA+IGN0eC50YXJnZXRbb3RoZXJGaWVsZF0sXG4gIGB0byBiZSBncmVhdGVyIHRoYW4gJHtvdGhlckZpZWxkfWBcbik7XG52YXIgREFURSA9IHByZWRpY2F0ZVdpdGhNZXNzYWdlKGlzVmFsaWREYXRlLCBcIkRhdGUgb2JqZWN0XCIpO1xudmFyIERBVEVfT1JfREFURVRJTUVfTVMgPSBPUihEQVRFLCBQT1NJVElWRV9OVU1CRVIpO1xudmFyIGNvbG9yTWVzc2FnZSA9IGBBIGNvbG9yIHN0cmluZyBjYW4gYmUgaW4gb25lIG9mIHRoZSBmb2xsb3dpbmcgZm9ybWF0cyB0byBiZSB2YWxpZDogI3JnYiwgI3JyZ2diYiwgcmdiKHIsIGcsIGIpLCByZ2JhKHIsIGcsIGIsIGEpIG9yIGEgQ1NTIGNvbG9yIG5hbWUgc3VjaCBhcyAnd2hpdGUnLCAnb3JhbmdlJywgJ2N5YW4nLCBldGNgO1xudmFyIENPTE9SX1NUUklORyA9IHByZWRpY2F0ZVdpdGhNZXNzYWdlKFxuICAodikgPT4gaXNTdHJpbmcodikgJiYgQ29sb3IudmFsaWRDb2xvclN0cmluZyh2KSxcbiAgYGNvbG9yIFN0cmluZy4gJHtjb2xvck1lc3NhZ2V9YFxuKTtcbnZhciBDT0xPUl9TVFJJTkdfQVJSQVkgPSBwcmVkaWNhdGVXaXRoTWVzc2FnZShBUlJBWV9PRihDT0xPUl9TVFJJTkcpLCBgY29sb3Igc3RyaW5ncy4gJHtjb2xvck1lc3NhZ2V9YCk7XG52YXIgQk9PTEVBTl9BUlJBWSA9IEFSUkFZX09GKEJPT0xFQU4sIFwiYm9vbGVhbiB2YWx1ZXNcIik7XG52YXIgTlVNQkVSX0FSUkFZID0gQVJSQVlfT0YoTlVNQkVSLCBcIm51bWJlcnNcIik7XG52YXIgU1RSSU5HX0FSUkFZID0gQVJSQVlfT0YoU1RSSU5HLCBcInN0cmluZ3NcIik7XG52YXIgREFURV9BUlJBWSA9IHByZWRpY2F0ZVdpdGhNZXNzYWdlKEFSUkFZX09GKERBVEUpLCBcIkRhdGUgb2JqZWN0c1wiKTtcbnZhciBPQkpFQ1RfQVJSQVkgPSBwcmVkaWNhdGVXaXRoTWVzc2FnZShBUlJBWV9PRihPQkpFQ1QpLCBcIm9iamVjdHNcIik7XG52YXIgTElORV9DQVAgPSBVTklPTihbXCJidXR0XCIsIFwicm91bmRcIiwgXCJzcXVhcmVcIl0sIFwiYSBsaW5lIGNhcFwiKTtcbnZhciBMSU5FX0pPSU4gPSBVTklPTihbXCJyb3VuZFwiLCBcImJldmVsXCIsIFwibWl0ZXJcIl0sIFwiYSBsaW5lIGpvaW5cIik7XG52YXIgTElORV9TVFlMRSA9IFVOSU9OKFtcInNvbGlkXCIsIFwiZGFzaGVkXCIsIFwiZG90dGVkXCJdLCBcImEgbGluZSBzdHlsZVwiKTtcbnZhciBMSU5FX0RBU0ggPSBwcmVkaWNhdGVXaXRoTWVzc2FnZShcbiAgQVJSQVlfT0YoUE9TSVRJVkVfTlVNQkVSKSxcbiAgXCJudW1iZXJzIHNwZWNpZnlpbmcgdGhlIGxlbmd0aCBpbiBwaXhlbHMgb2YgYWx0ZXJuYXRpbmcgZGFzaGVzIGFuZCBnYXBzLCBmb3IgZXhhbXBsZSwgWzYsIDNdIG1lYW5zIGRhc2hlcyB3aXRoIGEgbGVuZ3RoIG9mIDYgcGl4ZWxzIHdpdGggZ2FwcyBiZXR3ZWVuIG9mIDMgcGl4ZWxzLlwiXG4pO1xudmFyIFBPU0lUSU9OID0gVU5JT04oW1widG9wXCIsIFwicmlnaHRcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCJdLCBcImEgcG9zaXRpb25cIik7XG52YXIgRk9OVF9TVFlMRSA9IFVOSU9OKFtcIm5vcm1hbFwiLCBcIml0YWxpY1wiLCBcIm9ibGlxdWVcIl0sIFwiYSBmb250IHN0eWxlXCIpO1xudmFyIEZPTlRfV0VJR0hUID0gT1IoXG4gIFVOSU9OKFtcIm5vcm1hbFwiLCBcImJvbGRcIiwgXCJib2xkZXJcIiwgXCJsaWdodGVyXCJdLCBcImEgZm9udCB3ZWlnaHRcIiksXG4gIE5VTUJFUi5yZXN0cmljdCh7IG1pbjogMSwgbWF4OiAxZTMgfSlcbik7XG52YXIgVEVYVF9XUkFQID0gVU5JT04oW1wibmV2ZXJcIiwgXCJhbHdheXNcIiwgXCJoeXBoZW5hdGVcIiwgXCJvbi1zcGFjZVwiXSwgXCJhIHRleHQgd3JhcCBzdHJhdGVneVwiKTtcbnZhciBURVhUX0FMSUdOID0gVU5JT04oW1wibGVmdFwiLCBcImNlbnRlclwiLCBcInJpZ2h0XCJdLCBcImEgdGV4dCBhbGlnblwiKTtcbnZhciBWRVJUSUNBTF9BTElHTiA9IFVOSU9OKFtcInRvcFwiLCBcIm1pZGRsZVwiLCBcImJvdHRvbVwiXSwgXCJhIHZlcnRpY2FsIGFsaWduXCIpO1xudmFyIE9WRVJGTE9XX1NUUkFURUdZID0gVU5JT04oW1wiZWxsaXBzaXNcIiwgXCJoaWRlXCJdLCBcImFuIG92ZXJmbG93IHN0cmF0ZWd5XCIpO1xudmFyIERJUkVDVElPTiA9IFVOSU9OKFtcImhvcml6b250YWxcIiwgXCJ2ZXJ0aWNhbFwiXSwgXCJhIGRpcmVjdGlvblwiKTtcbnZhciBQTEFDRU1FTlQgPSBVTklPTihbXCJpbnNpZGVcIiwgXCJvdXRzaWRlXCJdLCBcImEgcGxhY2VtZW50XCIpO1xudmFyIElOVEVSQUNUSU9OX1JBTkdFID0gT1IoVU5JT04oW1wiZXhhY3RcIiwgXCJuZWFyZXN0XCJdLCBcImludGVyYWN0aW9uIHJhbmdlXCIpLCBOVU1CRVIpO1xudmFyIExBQkVMX1BMQUNFTUVOVCA9IFVOSU9OKFtcInRvcFwiLCBcImJvdHRvbVwiLCBcImxlZnRcIiwgXCJyaWdodFwiXSk7XG5mdW5jdGlvbiBVTklPTihvcHRpb25zLCBtZXNzYWdlID0gXCJhXCIpIHtcbiAgcmV0dXJuIHByZWRpY2F0ZVdpdGhNZXNzYWdlKFxuICAgICh2LCBjdHgpID0+IHtcbiAgICAgIGNvbnN0IG9wdGlvbiA9IG9wdGlvbnMuZmluZCgobykgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHR5cGVvZiBvID09PSBcInN0cmluZ1wiID8gbyA6IG8udmFsdWU7XG4gICAgICAgIHJldHVybiB2ID09PSB2YWx1ZTtcbiAgICAgIH0pO1xuICAgICAgaWYgKG9wdGlvbiA9PSBudWxsKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbiAhPT0gXCJzdHJpbmdcIiAmJiAob3B0aW9uLmRlcHJlY2F0ZWQgPT09IHRydWUgfHwgb3B0aW9uLmRlcHJlY2F0ZWRUbyAhPSBudWxsKSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlcyA9IFtgUHJvcGVydHkgWyVzXSB3aXRoIHZhbHVlICcke29wdGlvbi52YWx1ZX0nIGlzIGRlcHJlY2F0ZWQuYF07XG4gICAgICAgIGlmIChvcHRpb24uZGVwcmVjYXRlZFRvKSB7XG4gICAgICAgICAgbWVzc2FnZXMucHVzaChgVXNlICR7b3B0aW9uLmRlcHJlY2F0ZWRUb30gaW5zdGVhZC5gKTtcbiAgICAgICAgfVxuICAgICAgICBMb2dnZXIud2Fybk9uY2UobWVzc2FnZXMuam9pbihcIiBcIiksIGN0eC5wcm9wZXJ0eSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGAke21lc3NhZ2V9IGtleXdvcmQgc3VjaCBhcyAke2pvaW5Vbmlvbk9wdGlvbnMob3B0aW9ucyl9YFxuICApO1xufVxudmFyIE1JTl9TUEFDSU5HID0gT1IoQU5EKE5VTUJFUi5yZXN0cmljdCh7IG1pbjogMSB9KSwgTEVTU19USEFOKFwibWF4U3BhY2luZ1wiKSksIE5BTik7XG52YXIgTUFYX1NQQUNJTkcgPSBPUihBTkQoTlVNQkVSLnJlc3RyaWN0KHsgbWluOiAxIH0pLCBHUkVBVEVSX1RIQU4oXCJtaW5TcGFjaW5nXCIpKSwgTkFOKTtcbmZ1bmN0aW9uIHByZWRpY2F0ZVdpdGhNZXNzYWdlKHByZWRpY2F0ZSwgbWVzc2FnZSkge1xuICBwcmVkaWNhdGUubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIHJldHVybiBwcmVkaWNhdGU7XG59XG5mdW5jdGlvbiBqb2luVW5pb25PcHRpb25zKG9wdGlvbnMpIHtcbiAgY29uc3QgdmFsdWVzID0gb3B0aW9ucy5maWx0ZXIoKG9wdGlvbikgPT4gdHlwZW9mIG9wdGlvbiA9PT0gXCJzdHJpbmdcIiB8fCBvcHRpb24udW5kb2N1bWVudGVkICE9PSB0cnVlKS5tYXAoKG9wdGlvbikgPT4gYCcke3R5cGVvZiBvcHRpb24gPT09IFwic3RyaW5nXCIgPyBvcHRpb24gOiBvcHRpb24udmFsdWV9J2ApO1xuICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiB2YWx1ZXNbMF07XG4gIH1cbiAgY29uc3QgbGFzdFZhbHVlID0gdmFsdWVzLnBvcCgpO1xuICByZXR1cm4gYCR7dmFsdWVzLmpvaW4oXCIsIFwiKX0gb3IgJHtsYXN0VmFsdWV9YDtcbn1cbmZ1bmN0aW9uIGdldFByZWRpY2F0ZU1lc3NhZ2UocHJlZGljYXRlLCBjdHgpIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24ocHJlZGljYXRlLm1lc3NhZ2UpID8gcHJlZGljYXRlLm1lc3NhZ2UoY3R4KSA6IHByZWRpY2F0ZS5tZXNzYWdlO1xufVxuZnVuY3Rpb24gZ2V0UHJlZGljYXRlTWVzc2FnZU1hcHBlcihjdHgpIHtcbiAgcmV0dXJuIChwcmVkaWNhdGUpID0+IGdldFByZWRpY2F0ZU1lc3NhZ2UocHJlZGljYXRlLCBjdHgpO1xufVxuZnVuY3Rpb24gYXR0YWNoQXJyYXlSZXN0cmljdGlvbnMocHJlZGljYXRlKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHByZWRpY2F0ZSwge1xuICAgIHJlc3RyaWN0KHsgbGVuZ3RoOiBsZW5ndGgyLCBtaW5MZW5ndGggfSA9IHt9KSB7XG4gICAgICBsZXQgbWVzc2FnZSA9IFwiYW4gYXJyYXlcIjtcbiAgICAgIGlmIChpc051bWJlcihtaW5MZW5ndGgpICYmIG1pbkxlbmd0aCA+IDApIHtcbiAgICAgICAgbWVzc2FnZSA9IFwiYSBub24tZW1wdHkgYXJyYXlcIjtcbiAgICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIobGVuZ3RoMikpIHtcbiAgICAgICAgbWVzc2FnZSA9IGBhbiBhcnJheSBvZiBsZW5ndGggJHtsZW5ndGgyfWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJlZGljYXRlV2l0aE1lc3NhZ2UoXG4gICAgICAgICh2YWx1ZSkgPT4gaXNBcnJheSh2YWx1ZSkgJiYgKGlzTnVtYmVyKGxlbmd0aDIpID8gdmFsdWUubGVuZ3RoID09PSBsZW5ndGgyIDogdHJ1ZSkgJiYgKGlzTnVtYmVyKG1pbkxlbmd0aCkgPyB2YWx1ZS5sZW5ndGggPj0gbWluTGVuZ3RoIDogdHJ1ZSksXG4gICAgICAgIG1lc3NhZ2VcbiAgICAgICk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGF0dGFjaE51bWJlclJlc3RyaWN0aW9ucyhwcmVkaWNhdGUpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24ocHJlZGljYXRlLCB7XG4gICAgcmVzdHJpY3QoeyBtaW4sIG1heCB9ID0ge30pIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBbXCJhIG51bWJlclwiXTtcbiAgICAgIGNvbnN0IGhhc01pbiA9IGlzTnVtYmVyKG1pbik7XG4gICAgICBjb25zdCBoYXNNYXggPSBpc051bWJlcihtYXgpO1xuICAgICAgaWYgKGhhc01pbiAmJiBoYXNNYXgpIHtcbiAgICAgICAgbWVzc2FnZS5wdXNoKGBiZXR3ZWVuICR7bWlufSBhbmQgJHttYXh9IGluY2x1c2l2ZWApO1xuICAgICAgfSBlbHNlIGlmIChoYXNNaW4pIHtcbiAgICAgICAgbWVzc2FnZS5wdXNoKGBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gJHttaW59YCk7XG4gICAgICB9IGVsc2UgaWYgKGhhc01heCkge1xuICAgICAgICBtZXNzYWdlLnB1c2goYGxlc3MgdGhhbiBvciBlcXVhbCB0byAke21heH1gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcmVkaWNhdGVXaXRoTWVzc2FnZShcbiAgICAgICAgKHZhbHVlKSA9PiBpc0Zpbml0ZU51bWJlcih2YWx1ZSkgJiYgKGhhc01pbiA/IHZhbHVlID49IG1pbiA6IHRydWUpICYmIChoYXNNYXggPyB2YWx1ZSA8PSBtYXggOiB0cnVlKSxcbiAgICAgICAgbWVzc2FnZS5qb2luKFwiIFwiKVxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gYXR0YWNoT2JqZWN0UmVzdHJpY3Rpb25zKHByZWRpY2F0ZSkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihwcmVkaWNhdGUsIHtcbiAgICByZXN0cmljdChvYmplY3RUeXBlKSB7XG4gICAgICByZXR1cm4gcHJlZGljYXRlV2l0aE1lc3NhZ2UoXG4gICAgICAgICh2YWx1ZSkgPT4gdmFsdWUgaW5zdGFuY2VvZiBvYmplY3RUeXBlLFxuICAgICAgICAoY3R4KSA9PiBnZXRQcmVkaWNhdGVNZXNzYWdlKHByZWRpY2F0ZSwgY3R4KSA/PyBgYW4gaW5zdGFuY2Ugb2YgJHtvYmplY3RUeXBlLm5hbWV9YFxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICBpZiAoaXNOYU4odmFsdWUpKVxuICAgICAgcmV0dXJuIFwiTmFOXCI7XG4gICAgaWYgKHZhbHVlID09PSBJbmZpbml0eSlcbiAgICAgIHJldHVybiBcIkluZmluaXR5XCI7XG4gICAgaWYgKHZhbHVlID09PSAtSW5maW5pdHkpXG4gICAgICByZXR1cm4gXCItSW5maW5pdHlcIjtcbiAgfVxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9jaGFydEF4aXNEaXJlY3Rpb24udHNcbnZhciBDaGFydEF4aXNEaXJlY3Rpb24gPSAvKiBAX19QVVJFX18gKi8gKChDaGFydEF4aXNEaXJlY3Rpb24yKSA9PiB7XG4gIENoYXJ0QXhpc0RpcmVjdGlvbjJbXCJYXCJdID0gXCJ4XCI7XG4gIENoYXJ0QXhpc0RpcmVjdGlvbjJbXCJZXCJdID0gXCJ5XCI7XG4gIHJldHVybiBDaGFydEF4aXNEaXJlY3Rpb24yO1xufSkoQ2hhcnRBeGlzRGlyZWN0aW9uIHx8IHt9KTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvbW9kdWxlL21vZHVsZU1hcC50c1xudmFyIE1vZHVsZU1hcCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5tb2R1bGVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gICptb2R1bGVzKCkge1xuICAgIGZvciAoY29uc3QgbSBvZiB0aGlzLm1vZHVsZU1hcC52YWx1ZXMoKSkge1xuICAgICAgeWllbGQgbS5tb2R1bGVJbnN0YW5jZTtcbiAgICB9XG4gIH1cbiAgYWRkTW9kdWxlKG1vZHVsZSwgbW9kdWxlRmFjdG9yeSkge1xuICAgIGlmICh0aGlzLm1vZHVsZU1hcC5oYXMobW9kdWxlLm9wdGlvbnNLZXkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFHIENoYXJ0cyAtIG1vZHVsZSBhbHJlYWR5IGluaXRpYWxpc2VkOiAke21vZHVsZS5vcHRpb25zS2V5fWApO1xuICAgIH1cbiAgICB0aGlzLm1vZHVsZU1hcC5zZXQobW9kdWxlLm9wdGlvbnNLZXksIHsgbW9kdWxlLCBtb2R1bGVJbnN0YW5jZTogbW9kdWxlRmFjdG9yeShtb2R1bGUpIH0pO1xuICB9XG4gIHJlbW92ZU1vZHVsZShtb2R1bGUpIHtcbiAgICBjb25zdCBtb2R1bGVLZXkgPSBpc1N0cmluZyhtb2R1bGUpID8gbW9kdWxlIDogbW9kdWxlLm9wdGlvbnNLZXk7XG4gICAgdGhpcy5tb2R1bGVNYXAuZ2V0KG1vZHVsZUtleSk/Lm1vZHVsZUluc3RhbmNlLmRlc3Ryb3koKTtcbiAgICB0aGlzLm1vZHVsZU1hcC5kZWxldGUobW9kdWxlS2V5KTtcbiAgfVxuICBnZXRNb2R1bGUobW9kdWxlKSB7XG4gICAgcmV0dXJuIHRoaXMubW9kdWxlTWFwLmdldChpc1N0cmluZyhtb2R1bGUpID8gbW9kdWxlIDogbW9kdWxlLm9wdGlvbnNLZXkpPy5tb2R1bGVJbnN0YW5jZTtcbiAgfVxuICBpc0VuYWJsZWQobW9kdWxlKSB7XG4gICAgcmV0dXJuIHRoaXMubW9kdWxlTWFwLmhhcyhpc1N0cmluZyhtb2R1bGUpID8gbW9kdWxlIDogbW9kdWxlLm9wdGlvbnNLZXkpO1xuICB9XG4gIG1hcE1vZHVsZXMoY2FsbGJhY2syKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5tb2R1bGVNYXAudmFsdWVzKCksIChtLCBpKSA9PiBjYWxsYmFjazIobS5tb2R1bGVJbnN0YW5jZSwgaSkpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgZm9yIChjb25zdCBtb2R1bGVLZXkgb2YgdGhpcy5tb2R1bGVNYXAua2V5cygpKSB7XG4gICAgICB0aGlzLm1vZHVsZU1hcC5nZXQobW9kdWxlS2V5KT8ubW9kdWxlSW5zdGFuY2UuZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLm1vZHVsZU1hcC5jbGVhcigpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9tb3Rpb24vcmVzZXRNb3Rpb24udHNcbnZhciByZXNldE1vdGlvbl9leHBvcnRzID0ge307XG5fX2V4cG9ydChyZXNldE1vdGlvbl9leHBvcnRzLCB7XG4gIHJlc2V0TW90aW9uOiAoKSA9PiByZXNldE1vdGlvblxufSk7XG5mdW5jdGlvbiByZXNldE1vdGlvbihzZWxlY3Rpb25zT3JOb2RlcywgcHJvcHNGbikge1xuICBjb25zdCB7IG5vZGVzLCBzZWxlY3Rpb25zIH0gPSBkZWNvbnN0cnVjdFNlbGVjdGlvbnNPck5vZGVzKHNlbGVjdGlvbnNPck5vZGVzKTtcbiAgZm9yIChjb25zdCBzZWxlY3Rpb24gb2Ygc2VsZWN0aW9ucykge1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBzZWxlY3Rpb24ubm9kZXMoKSkge1xuICAgICAgY29uc3QgZnJvbTMgPSBwcm9wc0ZuKG5vZGUsIG5vZGUuZGF0dW0pO1xuICAgICAgbm9kZS5zZXRQcm9wZXJ0aWVzKGZyb20zKTtcbiAgICB9XG4gICAgc2VsZWN0aW9uLmNsZWFudXAoKTtcbiAgfVxuICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICBjb25zdCBmcm9tMyA9IHByb3BzRm4obm9kZSwgbm9kZS5kYXR1bSk7XG4gICAgbm9kZS5zZXRQcm9wZXJ0aWVzKGZyb20zKTtcbiAgfVxufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL251bWJlckZvcm1hdC50c1xuZnVuY3Rpb24gcGFyc2VGb3JtYXQoZm9ybWF0KSB7XG4gIGxldCBwcmVmaXg7XG4gIGxldCBzdWZmaXg7XG4gIGNvbnN0IHN1cnJvdW5kZWQgPSBzdXJyb3VuZGVkUmVnRXguZXhlYyhmb3JtYXQpO1xuICBpZiAoc3Vycm91bmRlZCkge1xuICAgIFssIHByZWZpeCwgZm9ybWF0LCBzdWZmaXhdID0gc3Vycm91bmRlZDtcbiAgfVxuICBjb25zdCBtYXRjaCA9IGZvcm1hdFJlZ0V4LmV4ZWMoZm9ybWF0KTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlIG51bWJlciBmb3JtYXR0ZXIgaXMgaW52YWxpZDogJHtmb3JtYXR9YCk7XG4gIH1cbiAgY29uc3QgWywgZmlsbCwgYWxpZ24sIHNpZ24sIHN5bWJvbCwgemVybywgd2lkdGgyLCBjb21tYSwgcHJlY2lzaW9uLCB0cmltLCB0eXBlXSA9IG1hdGNoO1xuICByZXR1cm4ge1xuICAgIGZpbGwsXG4gICAgYWxpZ24sXG4gICAgc2lnbixcbiAgICBzeW1ib2wsXG4gICAgemVybyxcbiAgICB3aWR0aDogcGFyc2VJbnQod2lkdGgyKSxcbiAgICBjb21tYSxcbiAgICBwcmVjaXNpb246IHBhcnNlSW50KHByZWNpc2lvbiksXG4gICAgdHJpbTogQm9vbGVhbih0cmltKSxcbiAgICB0eXBlLFxuICAgIHByZWZpeCxcbiAgICBzdWZmaXhcbiAgfTtcbn1cbmZ1bmN0aW9uIG51bWJlckZvcm1hdChmb3JtYXQpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHR5cGVvZiBmb3JtYXQgPT09IFwic3RyaW5nXCIgPyBwYXJzZUZvcm1hdChmb3JtYXQpIDogZm9ybWF0O1xuICBjb25zdCB7IGZpbGwsIGFsaWduLCBzaWduID0gXCItXCIsIHN5bWJvbCwgemVybywgd2lkdGg6IHdpZHRoMiwgY29tbWEsIHR5cGUsIHByZWZpeCA9IFwiXCIsIHN1ZmZpeCA9IFwiXCIsIHByZWNpc2lvbiB9ID0gb3B0aW9ucztcbiAgbGV0IHsgdHJpbSB9ID0gb3B0aW9ucztcbiAgY29uc3QgcHJlY2lzaW9uSXNOYU4gPSBwcmVjaXNpb24gPT0gbnVsbCB8fCBpc05hTihwcmVjaXNpb24pO1xuICBsZXQgZm9ybWF0Qm9keTtcbiAgaWYgKCF0eXBlKSB7XG4gICAgZm9ybWF0Qm9keSA9IGRlY2ltYWxUeXBlc1tcImdcIl07XG4gICAgdHJpbSA9IHRydWU7XG4gIH0gZWxzZSBpZiAodHlwZSBpbiBkZWNpbWFsVHlwZXMgJiYgdHlwZSBpbiBpbnRlZ2VyVHlwZXMpIHtcbiAgICBmb3JtYXRCb2R5ID0gcHJlY2lzaW9uSXNOYU4gPyBpbnRlZ2VyVHlwZXNbdHlwZV0gOiBkZWNpbWFsVHlwZXNbdHlwZV07XG4gIH0gZWxzZSBpZiAodHlwZSBpbiBkZWNpbWFsVHlwZXMpIHtcbiAgICBmb3JtYXRCb2R5ID0gZGVjaW1hbFR5cGVzW3R5cGVdO1xuICB9IGVsc2UgaWYgKHR5cGUgaW4gaW50ZWdlclR5cGVzKSB7XG4gICAgZm9ybWF0Qm9keSA9IGludGVnZXJUeXBlc1t0eXBlXTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBudW1iZXIgZm9ybWF0dGVyIHR5cGUgaXMgaW52YWxpZDogJHt0eXBlfWApO1xuICB9XG4gIGxldCBmb3JtYXR0ZXJQcmVjaXNpb247XG4gIGlmIChwcmVjaXNpb24gPT0gbnVsbCB8fCBwcmVjaXNpb25Jc05hTikge1xuICAgIGZvcm1hdHRlclByZWNpc2lvbiA9IHR5cGUgPyA2IDogMTI7XG4gIH0gZWxzZSB7XG4gICAgZm9ybWF0dGVyUHJlY2lzaW9uID0gcHJlY2lzaW9uO1xuICB9XG4gIHJldHVybiAobikgPT4ge1xuICAgIGxldCByZXN1bHQgPSBmb3JtYXRCb2R5KG4sIGZvcm1hdHRlclByZWNpc2lvbik7XG4gICAgaWYgKHRyaW0pIHtcbiAgICAgIHJlc3VsdCA9IHJlbW92ZVRyYWlsaW5nWmVyb3MocmVzdWx0KTtcbiAgICB9XG4gICAgaWYgKGNvbW1hKSB7XG4gICAgICByZXN1bHQgPSBpbnNlcnRTZXBhcmF0b3IocmVzdWx0LCBjb21tYSk7XG4gICAgfVxuICAgIHJlc3VsdCA9IGFkZFNpZ24obiwgcmVzdWx0LCBzaWduKTtcbiAgICBpZiAoc3ltYm9sICYmIHN5bWJvbCAhPT0gXCIjXCIpIHtcbiAgICAgIHJlc3VsdCA9IGAke3N5bWJvbH0ke3Jlc3VsdH1gO1xuICAgIH1cbiAgICBpZiAoc3ltYm9sID09PSBcIiNcIiAmJiB0eXBlID09PSBcInhcIikge1xuICAgICAgcmVzdWx0ID0gYDB4JHtyZXN1bHR9YDtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFwic1wiKSB7XG4gICAgICByZXN1bHQgPSBgJHtyZXN1bHR9JHtnZXRTSVByZWZpeChuKX1gO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gXCIlXCIgfHwgdHlwZSA9PT0gXCJwXCIpIHtcbiAgICAgIHJlc3VsdCA9IGAke3Jlc3VsdH0lYDtcbiAgICB9XG4gICAgaWYgKHdpZHRoMiAhPSBudWxsICYmICFpc05hTih3aWR0aDIpKSB7XG4gICAgICByZXN1bHQgPSBhZGRQYWRkaW5nKHJlc3VsdCwgd2lkdGgyLCBmaWxsID8/IHplcm8sIGFsaWduKTtcbiAgICB9XG4gICAgcmVzdWx0ID0gYCR7cHJlZml4fSR7cmVzdWx0fSR7c3VmZml4fWA7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cbnZhciBmb3JtYXRSZWdFeCA9IC9eKD86KC4pPyhbPD49Xl0pKT8oWytcXC0oIF0pPyhbJOKCrMKjwqXigqPigrkjXSk/KDApPyhcXGQrKT8oLCk/KD86XFwuKFxcZCspKT8ofik/KFslYS16XSk/JC9pO1xudmFyIHN1cnJvdW5kZWRSZWdFeCA9IC9eKCg/OlteI118I1tee10pKikjeyhbXn1dKyl9KC4qKSQvO1xudmFyIGludGVnZXJUeXBlcyA9IHtcbiAgYjogKG4pID0+IGFic0Zsb29yKG4pLnRvU3RyaW5nKDIpLFxuICBjOiAobikgPT4gU3RyaW5nLmZyb21DaGFyQ29kZShuKSxcbiAgZDogKG4pID0+IE1hdGgucm91bmQoTWF0aC5hYnMobikpLnRvRml4ZWQoMCksXG4gIG86IChuKSA9PiBhYnNGbG9vcihuKS50b1N0cmluZyg4KSxcbiAgeDogKG4pID0+IGFic0Zsb29yKG4pLnRvU3RyaW5nKDE2KSxcbiAgWDogKG4pID0+IGludGVnZXJUeXBlcy54KG4pLnRvVXBwZXJDYXNlKCksXG4gIG46IChuKSA9PiBpbnRlZ2VyVHlwZXMuZChuKSxcbiAgXCIlXCI6IChuKSA9PiBgJHthYnNGbG9vcihuICogMTAwKS50b0ZpeGVkKDApfWBcbn07XG52YXIgZGVjaW1hbFR5cGVzID0ge1xuICBlOiAobiwgZikgPT4gTWF0aC5hYnMobikudG9FeHBvbmVudGlhbChmKSxcbiAgRTogKG4sIGYpID0+IGRlY2ltYWxUeXBlcy5lKG4sIGYpLnRvVXBwZXJDYXNlKCksXG4gIGY6IChuLCBmKSA9PiBNYXRoLmFicyhuKS50b0ZpeGVkKGYpLFxuICBGOiAobiwgZikgPT4gZGVjaW1hbFR5cGVzLmYobiwgZikudG9VcHBlckNhc2UoKSxcbiAgZzogKG4sIGYpID0+IHtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgcmV0dXJuIFwiMFwiO1xuICAgIH1cbiAgICBjb25zdCBhID0gTWF0aC5hYnMobik7XG4gICAgY29uc3QgcCA9IE1hdGguZmxvb3IoTWF0aC5sb2cxMChhKSk7XG4gICAgaWYgKHAgPj0gLTQgJiYgcCA8IGYpIHtcbiAgICAgIHJldHVybiBhLnRvRml4ZWQoZiAtIDEgLSBwKTtcbiAgICB9XG4gICAgcmV0dXJuIGEudG9FeHBvbmVudGlhbChmIC0gMSk7XG4gIH0sXG4gIEc6IChuLCBmKSA9PiBkZWNpbWFsVHlwZXMuZyhuLCBmKS50b1VwcGVyQ2FzZSgpLFxuICBuOiAobiwgZikgPT4gZGVjaW1hbFR5cGVzLmcobiwgZiksXG4gIHA6IChuLCBmKSA9PiBkZWNpbWFsVHlwZXMucihuICogMTAwLCBmKSxcbiAgcjogKG4sIGYpID0+IHtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgcmV0dXJuIFwiMFwiO1xuICAgIH1cbiAgICBjb25zdCBhID0gTWF0aC5hYnMobik7XG4gICAgY29uc3QgcCA9IE1hdGguZmxvb3IoTWF0aC5sb2cxMChhKSk7XG4gICAgY29uc3QgcSA9IHAgLSAoZiAtIDEpO1xuICAgIGlmIChxIDw9IDApIHtcbiAgICAgIHJldHVybiBhLnRvRml4ZWQoLXEpO1xuICAgIH1cbiAgICBjb25zdCB4ID0gMTAgKiogcTtcbiAgICByZXR1cm4gKE1hdGgucm91bmQoYSAvIHgpICogeCkudG9GaXhlZCgpO1xuICB9LFxuICBzOiAobiwgZikgPT4ge1xuICAgIGNvbnN0IHAgPSBnZXRTSVByZWZpeFBvd2VyKG4pO1xuICAgIHJldHVybiBkZWNpbWFsVHlwZXMucihuIC8gMTAgKiogcCwgZik7XG4gIH0sXG4gIFwiJVwiOiAobiwgZikgPT4gZGVjaW1hbFR5cGVzLmYobiAqIDEwMCwgZilcbn07XG52YXIgbWluU0lQcmVmaXggPSAtMjQ7XG52YXIgbWF4U0lQcmVmaXggPSAyNDtcbnZhciBzaVByZWZpeGVzID0ge1xuICBbbWluU0lQcmVmaXhdOiBcInlcIixcbiAgWy0yMV06IFwielwiLFxuICBbLTE4XTogXCJhXCIsXG4gIFstMTVdOiBcImZcIixcbiAgWy0xMl06IFwicFwiLFxuICBbLTldOiBcIm5cIixcbiAgWy02XTogXCJcXHhCNVwiLFxuICBbLTNdOiBcIm1cIixcbiAgWzBdOiBcIlwiLFxuICBbM106IFwia1wiLFxuICBbNl06IFwiTVwiLFxuICBbOV06IFwiR1wiLFxuICBbMTJdOiBcIlRcIixcbiAgWzE1XTogXCJQXCIsXG4gIFsxOF06IFwiRVwiLFxuICBbMjFdOiBcIlpcIixcbiAgW21heFNJUHJlZml4XTogXCJZXCJcbn07XG52YXIgbWludXNTaWduID0gXCJcXHUyMjEyXCI7XG5mdW5jdGlvbiBhYnNGbG9vcihuKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKE1hdGguYWJzKG4pKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZVRyYWlsaW5nWmVyb3MobnVtU3RyaW5nKSB7XG4gIHJldHVybiBudW1TdHJpbmcucmVwbGFjZSgvXFwuMCskLywgXCJcIikucmVwbGFjZSgvKFxcLlsxLTldKTArJC8sIFwiJDFcIik7XG59XG5mdW5jdGlvbiBpbnNlcnRTZXBhcmF0b3IobnVtU3RyaW5nLCBzZXBhcmF0b3IpIHtcbiAgbGV0IGRvdEluZGV4ID0gbnVtU3RyaW5nLmluZGV4T2YoXCIuXCIpO1xuICBpZiAoZG90SW5kZXggPCAwKSB7XG4gICAgZG90SW5kZXggPSBudW1TdHJpbmcubGVuZ3RoO1xuICB9XG4gIGNvbnN0IGludGVnZXJDaGFycyA9IG51bVN0cmluZy5zdWJzdHJpbmcoMCwgZG90SW5kZXgpLnNwbGl0KFwiXCIpO1xuICBjb25zdCBmcmFjdGlvbmFsUGFydCA9IG51bVN0cmluZy5zdWJzdHJpbmcoZG90SW5kZXgpO1xuICBmb3IgKGxldCBpID0gaW50ZWdlckNoYXJzLmxlbmd0aCAtIDM7IGkgPiAwOyBpIC09IDMpIHtcbiAgICBpbnRlZ2VyQ2hhcnMuc3BsaWNlKGksIDAsIHNlcGFyYXRvcik7XG4gIH1cbiAgcmV0dXJuIGAke2ludGVnZXJDaGFycy5qb2luKFwiXCIpfSR7ZnJhY3Rpb25hbFBhcnR9YDtcbn1cbmZ1bmN0aW9uIGdldFNJUHJlZml4KG4pIHtcbiAgcmV0dXJuIHNpUHJlZml4ZXNbZ2V0U0lQcmVmaXhQb3dlcihuKV07XG59XG5mdW5jdGlvbiBnZXRTSVByZWZpeFBvd2VyKG4pIHtcbiAgcmV0dXJuIGNsYW1wKG1pblNJUHJlZml4LCBuID8gTWF0aC5mbG9vcihNYXRoLmxvZzEwKE1hdGguYWJzKG4pKSAvIDMpICogMyA6IDAsIG1heFNJUHJlZml4KTtcbn1cbmZ1bmN0aW9uIGFkZFNpZ24obnVtLCBudW1TdHJpbmcsIHNpZ25UeXBlID0gXCJcIikge1xuICBpZiAoc2lnblR5cGUgPT09IFwiKFwiKSB7XG4gICAgcmV0dXJuIG51bSA+PSAwID8gbnVtU3RyaW5nIDogYCgke251bVN0cmluZ30pYDtcbiAgfVxuICBjb25zdCBwbHVzU2lnbiA9IHNpZ25UeXBlID09PSBcIitcIiA/IFwiK1wiIDogXCJcIjtcbiAgcmV0dXJuIGAke251bSA+PSAwID8gcGx1c1NpZ24gOiBtaW51c1NpZ259JHtudW1TdHJpbmd9YDtcbn1cbmZ1bmN0aW9uIGFkZFBhZGRpbmcobnVtU3RyaW5nLCB3aWR0aDIsIGZpbGwgPSBcIiBcIiwgYWxpZ24gPSBcIj5cIikge1xuICBsZXQgcmVzdWx0ID0gbnVtU3RyaW5nO1xuICBpZiAoYWxpZ24gPT09IFwiPlwiIHx8ICFhbGlnbikge1xuICAgIHJlc3VsdCA9IHJlc3VsdC5wYWRTdGFydCh3aWR0aDIsIGZpbGwpO1xuICB9IGVsc2UgaWYgKGFsaWduID09PSBcIjxcIikge1xuICAgIHJlc3VsdCA9IHJlc3VsdC5wYWRFbmQod2lkdGgyLCBmaWxsKTtcbiAgfSBlbHNlIGlmIChhbGlnbiA9PT0gXCJeXCIpIHtcbiAgICBjb25zdCBwYWRXaWR0aCA9IE1hdGgubWF4KDAsIHdpZHRoMiAtIHJlc3VsdC5sZW5ndGgpO1xuICAgIGNvbnN0IHBhZExlZnQgPSBNYXRoLmNlaWwocGFkV2lkdGggLyAyKTtcbiAgICBjb25zdCBwYWRSaWdodCA9IE1hdGguZmxvb3IocGFkV2lkdGggLyAyKTtcbiAgICByZXN1bHQgPSByZXN1bHQucGFkU3RhcnQocGFkTGVmdCArIHJlc3VsdC5sZW5ndGgsIGZpbGwpO1xuICAgIHJlc3VsdCA9IHJlc3VsdC5wYWRFbmQocGFkUmlnaHQgKyByZXN1bHQubGVuZ3RoLCBmaWxsKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3RpY2tzLnRzXG52YXIgdEludGVydmFsID0gKHRpbWVJbnRlcnZhbCwgYmFzZUR1cmF0aW9uLCBzdGVwKSA9PiAoe1xuICBkdXJhdGlvbjogYmFzZUR1cmF0aW9uICogc3RlcCxcbiAgdGltZUludGVydmFsLFxuICBzdGVwXG59KTtcbnZhciBUaWNrSW50ZXJ2YWxzID0gW1xuICB0SW50ZXJ2YWwoc2Vjb25kX2RlZmF1bHQsIGR1cmF0aW9uU2Vjb25kLCAxKSxcbiAgdEludGVydmFsKHNlY29uZF9kZWZhdWx0LCBkdXJhdGlvblNlY29uZCwgNSksXG4gIHRJbnRlcnZhbChzZWNvbmRfZGVmYXVsdCwgZHVyYXRpb25TZWNvbmQsIDE1KSxcbiAgdEludGVydmFsKHNlY29uZF9kZWZhdWx0LCBkdXJhdGlvblNlY29uZCwgMzApLFxuICB0SW50ZXJ2YWwobWludXRlX2RlZmF1bHQsIGR1cmF0aW9uTWludXRlLCAxKSxcbiAgdEludGVydmFsKG1pbnV0ZV9kZWZhdWx0LCBkdXJhdGlvbk1pbnV0ZSwgNSksXG4gIHRJbnRlcnZhbChtaW51dGVfZGVmYXVsdCwgZHVyYXRpb25NaW51dGUsIDE1KSxcbiAgdEludGVydmFsKG1pbnV0ZV9kZWZhdWx0LCBkdXJhdGlvbk1pbnV0ZSwgMzApLFxuICB0SW50ZXJ2YWwoaG91cl9kZWZhdWx0LCBkdXJhdGlvbkhvdXIsIDEpLFxuICB0SW50ZXJ2YWwoaG91cl9kZWZhdWx0LCBkdXJhdGlvbkhvdXIsIDMpLFxuICB0SW50ZXJ2YWwoaG91cl9kZWZhdWx0LCBkdXJhdGlvbkhvdXIsIDYpLFxuICB0SW50ZXJ2YWwoaG91cl9kZWZhdWx0LCBkdXJhdGlvbkhvdXIsIDEyKSxcbiAgdEludGVydmFsKGRheV9kZWZhdWx0LCBkdXJhdGlvbkRheSwgMSksXG4gIHRJbnRlcnZhbChkYXlfZGVmYXVsdCwgZHVyYXRpb25EYXksIDIpLFxuICB0SW50ZXJ2YWwod2Vla19kZWZhdWx0LCBkdXJhdGlvbldlZWssIDEpLFxuICB0SW50ZXJ2YWwod2Vla19kZWZhdWx0LCBkdXJhdGlvbldlZWssIDIpLFxuICB0SW50ZXJ2YWwod2Vla19kZWZhdWx0LCBkdXJhdGlvbldlZWssIDMpLFxuICB0SW50ZXJ2YWwobW9udGhfZGVmYXVsdCwgZHVyYXRpb25Nb250aCwgMSksXG4gIHRJbnRlcnZhbChtb250aF9kZWZhdWx0LCBkdXJhdGlvbk1vbnRoLCAyKSxcbiAgdEludGVydmFsKG1vbnRoX2RlZmF1bHQsIGR1cmF0aW9uTW9udGgsIDMpLFxuICB0SW50ZXJ2YWwobW9udGhfZGVmYXVsdCwgZHVyYXRpb25Nb250aCwgNCksXG4gIHRJbnRlcnZhbChtb250aF9kZWZhdWx0LCBkdXJhdGlvbk1vbnRoLCA2KSxcbiAgdEludGVydmFsKHllYXJfZGVmYXVsdCwgZHVyYXRpb25ZZWFyLCAxKVxuXTtcbnZhciBUaWNrTXVsdGlwbGllcnMgPSBbMSwgMiwgNSwgMTBdO1xuZnVuY3Rpb24gaXNDbG9zZVRvSW50ZWdlcihuLCBkZWx0YTQpIHtcbiAgcmV0dXJuIE1hdGguYWJzKE1hdGgucm91bmQobikgLSBuKSA8IGRlbHRhNDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRpY2tzKHN0YXJ0Miwgc3RvcCwgY291bnQsIG1pbkNvdW50LCBtYXhDb3VudCkge1xuICBpZiAoY291bnQgPCAyKSB7XG4gICAgcmV0dXJuIFtzdGFydDIsIHN0b3BdO1xuICB9XG4gIGNvbnN0IHN0ZXAgPSB0aWNrU3RlcChzdGFydDIsIHN0b3AsIGNvdW50LCBtaW5Db3VudCwgbWF4Q291bnQpO1xuICBpZiAoIU51bWJlci5pc0Zpbml0ZShzdGVwKSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBpZiAoIWlzQ2xvc2VUb0ludGVnZXIoc3RhcnQyIC8gc3RlcCwgMWUtMTIpKSB7XG4gICAgc3RhcnQyID0gTWF0aC5jZWlsKHN0YXJ0MiAvIHN0ZXApICogc3RlcDtcbiAgfVxuICBpZiAoIWlzQ2xvc2VUb0ludGVnZXIoc3RvcCAvIHN0ZXAsIDFlLTEyKSkge1xuICAgIHN0b3AgPSBNYXRoLmZsb29yKHN0b3AgLyBzdGVwKSAqIHN0ZXA7XG4gIH1cbiAgcmV0dXJuIHJhbmdlKHN0YXJ0Miwgc3RvcCwgc3RlcCk7XG59XG5mdW5jdGlvbiBnZXRUaWNrSW50ZXJ2YWwoc3RhcnQyLCBzdG9wLCBjb3VudCwgbWluQ291bnQsIG1heENvdW50LCB0YXJnZXRJbnRlcnZhbCkge1xuICBjb25zdCB0YXJnZXQgPSB0YXJnZXRJbnRlcnZhbCA/PyBNYXRoLmFicyhzdG9wIC0gc3RhcnQyKSAvIE1hdGgubWF4KGNvdW50LCAxKTtcbiAgbGV0IGkgPSAwO1xuICBmb3IgKGNvbnN0IHRpY2tJbnRlcnZhbCBvZiBUaWNrSW50ZXJ2YWxzKSB7XG4gICAgaWYgKHRhcmdldCA8PSB0aWNrSW50ZXJ2YWwuZHVyYXRpb24pXG4gICAgICBicmVhaztcbiAgICBpKys7XG4gIH1cbiAgaWYgKGkgPT09IDApIHtcbiAgICBjb25zdCBzdGVwMiA9IE1hdGgubWF4KHRpY2tTdGVwKHN0YXJ0Miwgc3RvcCwgY291bnQsIG1pbkNvdW50LCBtYXhDb3VudCksIDEpO1xuICAgIHJldHVybiBtaWxsaXNlY29uZF9kZWZhdWx0LmV2ZXJ5KHN0ZXAyKTtcbiAgfSBlbHNlIGlmIChpID09PSBUaWNrSW50ZXJ2YWxzLmxlbmd0aCkge1xuICAgIGNvbnN0IHN0ZXAyID0gdGFyZ2V0SW50ZXJ2YWwgPT0gbnVsbCA/IHRpY2tTdGVwKHN0YXJ0MiAvIGR1cmF0aW9uWWVhciwgc3RvcCAvIGR1cmF0aW9uWWVhciwgY291bnQsIG1pbkNvdW50LCBtYXhDb3VudCkgOiAxO1xuICAgIHJldHVybiB5ZWFyX2RlZmF1bHQuZXZlcnkoc3RlcDIpO1xuICB9XG4gIGNvbnN0IGkwID0gVGlja0ludGVydmFsc1tpIC0gMV07XG4gIGNvbnN0IGkxID0gVGlja0ludGVydmFsc1tpXTtcbiAgY29uc3QgeyB0aW1lSW50ZXJ2YWwsIHN0ZXAgfSA9IHRhcmdldCAtIGkwLmR1cmF0aW9uIDwgaTEuZHVyYXRpb24gLSB0YXJnZXQgPyBpMCA6IGkxO1xuICByZXR1cm4gdGltZUludGVydmFsLmV2ZXJ5KHN0ZXApO1xufVxuZnVuY3Rpb24gdGlja1N0ZXAoc3RhcnQyLCBlbmQyLCBjb3VudCwgbWluQ291bnQgPSAwLCBtYXhDb3VudCA9IEluZmluaXR5KSB7XG4gIGlmIChzdGFydDIgPT09IGVuZDIpIHtcbiAgICByZXR1cm4gY2xhbXAoMSwgbWluQ291bnQsIG1heENvdW50KTtcbiAgfSBlbHNlIGlmIChjb3VudCA8IDEpIHtcbiAgICByZXR1cm4gTmFOO1xuICB9XG4gIGNvbnN0IGV4dGVudDIgPSBNYXRoLmFicyhlbmQyIC0gc3RhcnQyKTtcbiAgY29uc3Qgc3RlcCA9IDEwICoqIE1hdGguZmxvb3IoTWF0aC5sb2cxMChleHRlbnQyIC8gY291bnQpKTtcbiAgbGV0IG0gPSBOYU4sIG1pbkRpZmYgPSBJbmZpbml0eSwgaXNJbkJvdW5kcyA9IGZhbHNlO1xuICBmb3IgKGNvbnN0IG11bHRpcGxpZXIgb2YgVGlja011bHRpcGxpZXJzKSB7XG4gICAgY29uc3QgYyA9IE1hdGguY2VpbChleHRlbnQyIC8gKG11bHRpcGxpZXIgKiBzdGVwKSk7XG4gICAgY29uc3QgdmFsaWRCb3VuZHMgPSBjID49IG1pbkNvdW50ICYmIGMgPD0gbWF4Q291bnQ7XG4gICAgaWYgKGlzSW5Cb3VuZHMgJiYgIXZhbGlkQm91bmRzKVxuICAgICAgY29udGludWU7XG4gICAgY29uc3QgZGlmZkNvdW50ID0gTWF0aC5hYnMoYyAtIGNvdW50KTtcbiAgICBpZiAobWluRGlmZiA+IGRpZmZDb3VudCB8fCBpc0luQm91bmRzICE9PSB2YWxpZEJvdW5kcykge1xuICAgICAgaXNJbkJvdW5kcyB8fCAoaXNJbkJvdW5kcyA9IHZhbGlkQm91bmRzKTtcbiAgICAgIG1pbkRpZmYgPSBkaWZmQ291bnQ7XG4gICAgICBtID0gbXVsdGlwbGllcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG0gKiBzdGVwO1xufVxuZnVuY3Rpb24gZGVjaW1hbFBsYWNlcyhkZWNpbWFsKSB7XG4gIGZvciAobGV0IGkgPSBkZWNpbWFsLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgaWYgKGRlY2ltYWxbaV0gIT09IFwiMFwiKSB7XG4gICAgICByZXR1cm4gaSArIDE7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gdGlja0Zvcm1hdCh0aWNrcywgZm9ybWF0KSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBwYXJzZUZvcm1hdChmb3JtYXQgPz8gXCIsZlwiKTtcbiAgaWYgKG9wdGlvbnMucHJlY2lzaW9uID09IG51bGwgfHwgaXNOYU4ob3B0aW9ucy5wcmVjaXNpb24pKSB7XG4gICAgaWYgKCFvcHRpb25zLnR5cGUgfHwgXCJlRUZnR25wcnNcIi5pbmNsdWRlcyhvcHRpb25zLnR5cGUpKSB7XG4gICAgICBvcHRpb25zLnByZWNpc2lvbiA9IE1hdGgubWF4KFxuICAgICAgICAuLi50aWNrcy5tYXAoKHgpID0+IHtcbiAgICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZSh4KSlcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIGNvbnN0IFtpbnRlZ2VyLCBkZWNpbWFsXSA9IHgudG9FeHBvbmVudGlhbCgob3B0aW9ucy50eXBlID8gNiA6IDEyKSAtIDEpLnNwbGl0KC9cXC58ZS9nKTtcbiAgICAgICAgICByZXR1cm4gKGludGVnZXIgIT09IFwiMVwiICYmIGludGVnZXIgIT09IFwiLTFcIiA/IDEgOiAwKSArIGRlY2ltYWxQbGFjZXMoZGVjaW1hbCkgKyAxO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKFwiZiVcIi5pbmNsdWRlcyhvcHRpb25zLnR5cGUpKSB7XG4gICAgICBvcHRpb25zLnByZWNpc2lvbiA9IE1hdGgubWF4KFxuICAgICAgICAuLi50aWNrcy5tYXAoKHgpID0+IHtcbiAgICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZSh4KSB8fCB4ID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgY29uc3QgbCA9IE1hdGguZmxvb3IoTWF0aC5sb2cxMChNYXRoLmFicyh4KSkpO1xuICAgICAgICAgIGNvbnN0IGRpZ2l0cyA9IG9wdGlvbnMudHlwZSA/IDYgOiAxMjtcbiAgICAgICAgICBjb25zdCBkZWNpbWFsID0geC50b0V4cG9uZW50aWFsKGRpZ2l0cyAtIDEpLnNwbGl0KC9cXC58ZS9nKVsxXTtcbiAgICAgICAgICBjb25zdCBkZWNpbWFsTGVuZ3RoID0gZGVjaW1hbFBsYWNlcyhkZWNpbWFsKTtcbiAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgZGVjaW1hbExlbmd0aCAtIGwpO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZm9ybWF0dGVyID0gbnVtYmVyRm9ybWF0KG9wdGlvbnMpO1xuICByZXR1cm4gKG4pID0+IGZvcm1hdHRlcihOdW1iZXIobikpO1xufVxuZnVuY3Rpb24gcmFuZ2Uoc3RhcnQyLCBlbmQyLCBzdGVwKSB7XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKHN0ZXApIHx8IHN0ZXAgPD0gMClcbiAgICByZXR1cm4gW107XG4gIGNvbnN0IGYgPSAxMCAqKiBjb3VudEZyYWN0aW9uRGlnaXRzKHN0ZXApO1xuICBjb25zdCBkMCA9IE1hdGgubWluKHN0YXJ0MiwgZW5kMik7XG4gIGNvbnN0IGQxID0gTWF0aC5tYXgoc3RhcnQyLCBlbmQyKTtcbiAgY29uc3Qgb3V0ID0gW107XG4gIGZvciAobGV0IGkgPSAwOyA7IGkgKz0gMSkge1xuICAgIGNvbnN0IHAgPSBNYXRoLnJvdW5kKChkMCArIHN0ZXAgKiBpKSAqIGYpIC8gZjtcbiAgICBpZiAocCA8PSBkMSkge1xuICAgICAgb3V0LnB1c2gocCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0O1xufVxuZnVuY3Rpb24gaXNEZW5zZUludGVydmFsKGNvdW50LCBhdmFpbGFibGVSYW5nZSkge1xuICBpZiAoY291bnQgPj0gYXZhaWxhYmxlUmFuZ2UpIHtcbiAgICBMb2dnZXIud2Fybk9uY2UoXG4gICAgICBgdGhlIGNvbmZpZ3VyZWQgaW50ZXJ2YWwgcmVzdWx0cyBpbiBtb3JlIHRoYW4gMSBpdGVtIHBlciBwaXhlbCwgaWdub3JpbmcuIFN1cHBseSBhIGxhcmdlciBpbnRlcnZhbCBvciBvbWl0IHRoaXMgY29uZmlndXJhdGlvbmBcbiAgICApO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIG5pY2VUaWNrc0RvbWFpbihzdGFydDIsIGVuZDIpIHtcbiAgY29uc3QgZXh0ZW50MiA9IE1hdGguYWJzKGVuZDIgLSBzdGFydDIpO1xuICBjb25zdCBzdGVwID0gMTAgKiogTWF0aC5mbG9vcihNYXRoLmxvZzEwKGV4dGVudDIpKTtcbiAgbGV0IG1pbkVycm9yID0gSW5maW5pdHksIHRpY2tzID0gW3N0YXJ0MiwgZW5kMl07XG4gIGZvciAoY29uc3QgbXVsdGlwbGllciBvZiBUaWNrTXVsdGlwbGllcnMpIHtcbiAgICBjb25zdCBtID0gbXVsdGlwbGllciAqIHN0ZXA7XG4gICAgY29uc3QgZDAgPSBNYXRoLmZsb29yKHN0YXJ0MiAvIG0pICogbTtcbiAgICBjb25zdCBkMSA9IE1hdGguY2VpbChlbmQyIC8gbSkgKiBtO1xuICAgIGNvbnN0IGVycm9yID0gMSAtIGV4dGVudDIgLyBNYXRoLmFicyhkMSAtIGQwKTtcbiAgICBpZiAobWluRXJyb3IgPiBlcnJvcikge1xuICAgICAgbWluRXJyb3IgPSBlcnJvcjtcbiAgICAgIHRpY2tzID0gW2QwLCBkMV07XG4gICAgfVxuICB9XG4gIHJldHVybiB0aWNrcztcbn1cbmZ1bmN0aW9uIGVzdGltYXRlVGlja0NvdW50KHJhbmdlRXh0ZW50LCBtaW5TcGFjaW5nLCBtYXhTcGFjaW5nLCBkZWZhdWx0VGlja0NvdW50LCBkZWZhdWx0TWluU3BhY2luZykge1xuICBkZWZhdWx0TWluU3BhY2luZyA9IE1hdGgubWF4KGRlZmF1bHRNaW5TcGFjaW5nLCByYW5nZUV4dGVudCAvIChkZWZhdWx0VGlja0NvdW50ICsgMSkpO1xuICBpZiAoaXNOYU4obWluU3BhY2luZykpIHtcbiAgICBtaW5TcGFjaW5nID0gZGVmYXVsdE1pblNwYWNpbmc7XG4gIH1cbiAgaWYgKGlzTmFOKG1heFNwYWNpbmcpKSB7XG4gICAgbWF4U3BhY2luZyA9IHJhbmdlRXh0ZW50O1xuICB9XG4gIGlmIChtaW5TcGFjaW5nID4gbWF4U3BhY2luZykge1xuICAgIGlmIChtaW5TcGFjaW5nID09PSBkZWZhdWx0TWluU3BhY2luZykge1xuICAgICAgbWluU3BhY2luZyA9IG1heFNwYWNpbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1heFNwYWNpbmcgPSBtaW5TcGFjaW5nO1xuICAgIH1cbiAgfVxuICBjb25zdCBtYXhUaWNrQ291bnQgPSBjbGFtcCgxLCBNYXRoLmZsb29yKHJhbmdlRXh0ZW50IC8gbWluU3BhY2luZyksIE1hdGgubWluKE1hdGguZmxvb3IocmFuZ2VFeHRlbnQpLCAxMDApKTtcbiAgY29uc3QgbWluVGlja0NvdW50ID0gTWF0aC5taW4obWF4VGlja0NvdW50LCBNYXRoLmNlaWwocmFuZ2VFeHRlbnQgLyBtYXhTcGFjaW5nKSk7XG4gIGNvbnN0IHRpY2tDb3VudCA9IGNsYW1wKG1pblRpY2tDb3VudCwgZGVmYXVsdFRpY2tDb3VudCwgbWF4VGlja0NvdW50KTtcbiAgcmV0dXJuIHsgbWluVGlja0NvdW50LCBtYXhUaWNrQ291bnQsIHRpY2tDb3VudCB9O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2FsZS9sb2dTY2FsZS50c1xudmFyIF9Mb2dTY2FsZSA9IGNsYXNzIF9Mb2dTY2FsZSBleHRlbmRzIENvbnRpbnVvdXNTY2FsZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFsxLCAxMF0sIFswLCAxXSk7XG4gICAgdGhpcy50eXBlID0gXCJsb2dcIjtcbiAgICB0aGlzLmJhc2UgPSAxMDtcbiAgICB0aGlzLmJhc2VMb2cgPSBpZGVudGl0eTtcbiAgICB0aGlzLmJhc2VQb3cgPSBpZGVudGl0eTtcbiAgICB0aGlzLmxvZyA9ICh4KSA9PiB7XG4gICAgICBjb25zdCBzdGFydDIgPSBNYXRoLm1pbiguLi50aGlzLmRvbWFpbik7XG4gICAgICByZXR1cm4gc3RhcnQyID49IDAgPyB0aGlzLmJhc2VMb2coeCkgOiAtdGhpcy5iYXNlTG9nKC14KTtcbiAgICB9O1xuICAgIHRoaXMucG93ID0gKHgpID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0MiA9IE1hdGgubWluKC4uLnRoaXMuZG9tYWluKTtcbiAgICAgIHJldHVybiBzdGFydDIgPj0gMCA/IHRoaXMuYmFzZVBvdyh4KSA6IC10aGlzLmJhc2VQb3coLXgpO1xuICAgIH07XG4gICAgdGhpcy5kZWZhdWx0Q2xhbXBNb2RlID0gXCJjbGFtcGVkXCI7XG4gIH1cbiAgdG9Eb21haW4oZCkge1xuICAgIHJldHVybiBkO1xuICB9XG4gIHRyYW5zZm9ybSh4KSB7XG4gICAgY29uc3Qgc3RhcnQyID0gTWF0aC5taW4oLi4udGhpcy5kb21haW4pO1xuICAgIHJldHVybiBzdGFydDIgPj0gMCA/IE1hdGgubG9nKHgpIDogLU1hdGgubG9nKC14KTtcbiAgfVxuICB0cmFuc2Zvcm1JbnZlcnQoeCkge1xuICAgIGNvbnN0IHN0YXJ0MiA9IE1hdGgubWluKC4uLnRoaXMuZG9tYWluKTtcbiAgICByZXR1cm4gc3RhcnQyID49IDAgPyBNYXRoLmV4cCh4KSA6IC1NYXRoLmV4cCgteCk7XG4gIH1cbiAgcmVmcmVzaCgpIHtcbiAgICBpZiAodGhpcy5iYXNlIDw9IDApIHtcbiAgICAgIHRoaXMuYmFzZSA9IDA7XG4gICAgICBMb2dnZXIud2Fybk9uY2UoXCJleHBlY3RpbmcgYSBmaW5pdGUgTnVtYmVyIGdyZWF0ZXIgdGhhbiB0byAwXCIpO1xuICAgIH1cbiAgICBzdXBlci5yZWZyZXNoKCk7XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIGlmICghdGhpcy5kb21haW4gfHwgdGhpcy5kb21haW4ubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmJhc2VMb2cgPSBfTG9nU2NhbGUuZ2V0QmFzZUxvZ01ldGhvZCh0aGlzLmJhc2UpO1xuICAgIHRoaXMuYmFzZVBvdyA9IF9Mb2dTY2FsZS5nZXRCYXNlUG93ZXJNZXRob2QodGhpcy5iYXNlKTtcbiAgICBpZiAodGhpcy5uaWNlKSB7XG4gICAgICB0aGlzLnVwZGF0ZU5pY2VEb21haW4oKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlTmljZURvbWFpbigpIHtcbiAgICBjb25zdCBbZDAsIGQxXSA9IHRoaXMuZG9tYWluO1xuICAgIGNvbnN0IHJvdW5kU3RhcnQgPSBkMCA+IGQxID8gTWF0aC5jZWlsIDogTWF0aC5mbG9vcjtcbiAgICBjb25zdCByb3VuZFN0b3AgPSBkMCA+IGQxID8gTWF0aC5mbG9vciA6IE1hdGguY2VpbDtcbiAgICBjb25zdCBuMCA9IHRoaXMucG93KHJvdW5kU3RhcnQodGhpcy5sb2coZDApKSk7XG4gICAgY29uc3QgbjEgPSB0aGlzLnBvdyhyb3VuZFN0b3AodGhpcy5sb2coZDEpKSk7XG4gICAgdGhpcy5uaWNlRG9tYWluID0gW24wLCBuMV07XG4gIH1cbiAgdGlja3MoKSB7XG4gICAgY29uc3QgY291bnQgPSB0aGlzLnRpY2tDb3VudCA/PyAxMDtcbiAgICBpZiAoIXRoaXMuZG9tYWluIHx8IHRoaXMuZG9tYWluLmxlbmd0aCA8IDIgfHwgY291bnQgPCAxKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIGNvbnN0IGJhc2UgPSB0aGlzLmJhc2U7XG4gICAgY29uc3QgW2QwLCBkMV0gPSB0aGlzLmdldERvbWFpbigpO1xuICAgIGNvbnN0IHN0YXJ0MiA9IE1hdGgubWluKGQwLCBkMSk7XG4gICAgY29uc3Qgc3RvcCA9IE1hdGgubWF4KGQwLCBkMSk7XG4gICAgbGV0IHAwID0gdGhpcy5sb2coc3RhcnQyKTtcbiAgICBsZXQgcDEgPSB0aGlzLmxvZyhzdG9wKTtcbiAgICBpZiAodGhpcy5pbnRlcnZhbCkge1xuICAgICAgY29uc3QgaW5Cb3VuZHMgPSAodGljaykgPT4gdGljayA+PSBzdGFydDIgJiYgdGljayA8PSBzdG9wO1xuICAgICAgY29uc3Qgc3RlcCA9IE1hdGgubWluKE1hdGguYWJzKHRoaXMuaW50ZXJ2YWwpLCBNYXRoLmFicyhwMSAtIHAwKSk7XG4gICAgICBjb25zdCB0aWNrczIgPSByYW5nZShwMCwgcDEsIHN0ZXApLm1hcCh0aGlzLnBvdykuZmlsdGVyKGluQm91bmRzKTtcbiAgICAgIGlmICghaXNEZW5zZUludGVydmFsKHRpY2tzMi5sZW5ndGgsIHRoaXMuZ2V0UGl4ZWxSYW5nZSgpKSkge1xuICAgICAgICByZXR1cm4gdGlja3MyO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBpc0Jhc2VJbnRlZ2VyID0gYmFzZSAlIDEgPT09IDA7XG4gICAgY29uc3QgaXNEaWZmTGFyZ2UgPSBwMSAtIHAwID49IGNvdW50O1xuICAgIGlmICghaXNCYXNlSW50ZWdlciB8fCBpc0RpZmZMYXJnZSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVRpY2tzKHAwLCBwMSwgTWF0aC5taW4ocDEgLSBwMCwgY291bnQpKS5tYXAodGhpcy5wb3cpO1xuICAgIH1cbiAgICBjb25zdCB0aWNrcyA9IFtdO1xuICAgIGNvbnN0IGlzUG9zaXRpdmUgPSBzdGFydDIgPiAwO1xuICAgIHAwID0gTWF0aC5mbG9vcihwMCkgLSAxO1xuICAgIHAxID0gTWF0aC5yb3VuZChwMSkgKyAxO1xuICAgIGNvbnN0IGF2YWlsYWJsZVNwYWNpbmcgPSBmaW5kUmFuZ2VFeHRlbnQodGhpcy5yYW5nZSkgLyBjb3VudDtcbiAgICBsZXQgbGFzdFRpY2tQb3NpdGlvbiA9IEluZmluaXR5O1xuICAgIGZvciAobGV0IHAgPSBwMDsgcCA8PSBwMTsgcCsrKSB7XG4gICAgICBjb25zdCBuZXh0TWFnbml0dWRlVGlja1Bvc2l0aW9uID0gdGhpcy5jb252ZXJ0KHRoaXMucG93KHAgKyAxKSk7XG4gICAgICBmb3IgKGxldCBrID0gMTsgayA8IGJhc2U7IGsrKykge1xuICAgICAgICBjb25zdCBxID0gaXNQb3NpdGl2ZSA/IGsgOiBiYXNlIC0gayArIDE7XG4gICAgICAgIGNvbnN0IHQgPSB0aGlzLnBvdyhwKSAqIHE7XG4gICAgICAgIGNvbnN0IHRpY2tQb3NpdGlvbiA9IHRoaXMuY29udmVydCh0KTtcbiAgICAgICAgY29uc3QgcHJldlNwYWNpbmcgPSBNYXRoLmFicyhsYXN0VGlja1Bvc2l0aW9uIC0gdGlja1Bvc2l0aW9uKTtcbiAgICAgICAgY29uc3QgbmV4dFNwYWNpbmcgPSBNYXRoLmFicyh0aWNrUG9zaXRpb24gLSBuZXh0TWFnbml0dWRlVGlja1Bvc2l0aW9uKTtcbiAgICAgICAgY29uc3QgZml0cyA9IHByZXZTcGFjaW5nID49IGF2YWlsYWJsZVNwYWNpbmcgJiYgbmV4dFNwYWNpbmcgPj0gYXZhaWxhYmxlU3BhY2luZztcbiAgICAgICAgaWYgKHQgPj0gc3RhcnQyICYmIHQgPD0gc3RvcCAmJiAoayA9PT0gMSB8fCBmaXRzIHx8IHRpY2tzLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgICB0aWNrcy5wdXNoKHQpO1xuICAgICAgICAgIGxhc3RUaWNrUG9zaXRpb24gPSB0aWNrUG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRpY2tzO1xuICB9XG4gIHRpY2tGb3JtYXQoe1xuICAgIGNvdW50LFxuICAgIHRpY2tzLFxuICAgIHNwZWNpZmllclxuICB9KSB7XG4gICAgaWYgKGNvdW50ICE9PSBJbmZpbml0eSAmJiB0aWNrcyA9PSBudWxsKSB7XG4gICAgICB0aGlzLnRpY2tzKCk7XG4gICAgfVxuICAgIHNwZWNpZmllciA/PyAoc3BlY2lmaWVyID0gdGhpcy5iYXNlID09PSAxMCA/IFwiLjBlXCIgOiBcIixcIik7XG4gICAgcmV0dXJuIGlzU3RyaW5nKHNwZWNpZmllcikgPyBudW1iZXJGb3JtYXQoc3BlY2lmaWVyKSA6IHNwZWNpZmllcjtcbiAgfVxuICBzdGF0aWMgZ2V0QmFzZUxvZ01ldGhvZChiYXNlKSB7XG4gICAgc3dpdGNoIChiYXNlKSB7XG4gICAgICBjYXNlIDEwOlxuICAgICAgICByZXR1cm4gTWF0aC5sb2cxMDtcbiAgICAgIGNhc2UgTWF0aC5FOlxuICAgICAgICByZXR1cm4gTWF0aC5sb2c7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiBNYXRoLmxvZzI7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gKHgpID0+IE1hdGgubG9nKHgpIC8gTWF0aC5sb2coYmFzZSk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBnZXRCYXNlUG93ZXJNZXRob2QoYmFzZSkge1xuICAgIHN3aXRjaCAoYmFzZSkge1xuICAgICAgY2FzZSAxMDpcbiAgICAgICAgcmV0dXJuICh4KSA9PiB4ID49IDAgPyAxMCAqKiB4IDogMSAvIDEwICoqIC14O1xuICAgICAgY2FzZSBNYXRoLkU6XG4gICAgICAgIHJldHVybiBNYXRoLmV4cDtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAoeCkgPT4gYmFzZSAqKiB4O1xuICAgIH1cbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEludmFsaWRhdGluZ1xuXSwgX0xvZ1NjYWxlLnByb3RvdHlwZSwgXCJiYXNlXCIsIDIpO1xudmFyIExvZ1NjYWxlID0gX0xvZ1NjYWxlO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2FsZS90aW1lU2NhbGUudHNcbnZhciBUaW1lU2NhbGUgPSBjbGFzcyBfVGltZVNjYWxlIGV4dGVuZHMgQ29udGludW91c1NjYWxlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoW10sIFswLCAxXSk7XG4gICAgdGhpcy50eXBlID0gXCJ0aW1lXCI7XG4gIH1cbiAgdG9Eb21haW4oZCkge1xuICAgIHJldHVybiBuZXcgRGF0ZShkKTtcbiAgfVxuICBjb252ZXJ0KHgsIG9wdHMpIHtcbiAgICByZXR1cm4gc3VwZXIuY29udmVydChuZXcgRGF0ZSh4KSwgb3B0cyk7XG4gIH1cbiAgaW52ZXJ0KHkpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoc3VwZXIuaW52ZXJ0KHkpKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB1bmlmb3JtbHktc3BhY2VkIGRhdGVzIHRoYXQgcmVwcmVzZW50IHRoZSBzY2FsZSdzIGRvbWFpbi5cbiAgICovXG4gIHRpY2tzKCkge1xuICAgIGlmICghdGhpcy5kb21haW4gfHwgdGhpcy5kb21haW4ubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICB0aGlzLnJlZnJlc2goKTtcbiAgICBjb25zdCB7IGludGVydmFsLCBuaWNlLCB0aWNrQ291bnQsIG1pblRpY2tDb3VudCwgbWF4VGlja0NvdW50IH0gPSB0aGlzO1xuICAgIGNvbnN0IFtzdGFydDIsIHN0b3BdID0gZmluZE1pbk1heCh0aGlzLmdldERvbWFpbigpLm1hcChkYXRlVG9OdW1iZXIpKTtcbiAgICBpZiAoaW50ZXJ2YWwgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIF9UaW1lU2NhbGUuZ2V0VGlja3NGb3JJbnRlcnZhbCh7IHN0YXJ0OiBzdGFydDIsIHN0b3AsIGludGVydmFsLCBhdmFpbGFibGVSYW5nZTogdGhpcy5nZXRQaXhlbFJhbmdlKCkgfSkgPz8gX1RpbWVTY2FsZS5nZXREZWZhdWx0VGlja3MoeyBzdGFydDogc3RhcnQyLCBzdG9wLCB0aWNrQ291bnQsIG1pblRpY2tDb3VudCwgbWF4VGlja0NvdW50IH0pO1xuICAgIH0gZWxzZSBpZiAobmljZSAmJiB0aWNrQ291bnQgPT09IDIpIHtcbiAgICAgIHJldHVybiB0aGlzLm5pY2VEb21haW47XG4gICAgfSBlbHNlIGlmIChuaWNlICYmIHRpY2tDb3VudCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHRoaXMubmljZURvbWFpbi5zbGljZSgwLCAxKTtcbiAgICB9XG4gICAgcmV0dXJuIF9UaW1lU2NhbGUuZ2V0RGVmYXVsdFRpY2tzKHsgc3RhcnQ6IHN0YXJ0Miwgc3RvcCwgdGlja0NvdW50LCBtaW5UaWNrQ291bnQsIG1heFRpY2tDb3VudCB9KTtcbiAgfVxuICBzdGF0aWMgZ2V0RGVmYXVsdFRpY2tzKHtcbiAgICBzdGFydDogc3RhcnQyLFxuICAgIHN0b3AsXG4gICAgdGlja0NvdW50LFxuICAgIG1pblRpY2tDb3VudCxcbiAgICBtYXhUaWNrQ291bnRcbiAgfSkge1xuICAgIGNvbnN0IHQgPSBnZXRUaWNrSW50ZXJ2YWwoc3RhcnQyLCBzdG9wLCB0aWNrQ291bnQsIG1pblRpY2tDb3VudCwgbWF4VGlja0NvdW50KTtcbiAgICByZXR1cm4gdCA/IHQucmFuZ2UobmV3IERhdGUoc3RhcnQyKSwgbmV3IERhdGUoc3RvcCkpIDogW107XG4gIH1cbiAgc3RhdGljIGdldFRpY2tzRm9ySW50ZXJ2YWwoe1xuICAgIHN0YXJ0OiBzdGFydDIsXG4gICAgc3RvcCxcbiAgICBpbnRlcnZhbCxcbiAgICBhdmFpbGFibGVSYW5nZVxuICB9KSB7XG4gICAgaWYgKCFpbnRlcnZhbCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBpZiAoaW50ZXJ2YWwgaW5zdGFuY2VvZiBUaW1lSW50ZXJ2YWwpIHtcbiAgICAgIGNvbnN0IHRpY2tzMiA9IGludGVydmFsLnJhbmdlKG5ldyBEYXRlKHN0YXJ0MiksIG5ldyBEYXRlKHN0b3ApKTtcbiAgICAgIGlmIChpc0RlbnNlSW50ZXJ2YWwodGlja3MyLmxlbmd0aCwgYXZhaWxhYmxlUmFuZ2UpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aWNrczI7XG4gICAgfVxuICAgIGNvbnN0IGFic0ludGVydmFsID0gTWF0aC5hYnMoaW50ZXJ2YWwpO1xuICAgIGlmIChpc0RlbnNlSW50ZXJ2YWwoKHN0b3AgLSBzdGFydDIpIC8gYWJzSW50ZXJ2YWwsIGF2YWlsYWJsZVJhbmdlKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0aW1lSW50ZXJ2YWwgPSBUaWNrSW50ZXJ2YWxzLmZpbmRMYXN0KCh0aWNrSW50ZXJ2YWwpID0+IGFic0ludGVydmFsICUgdGlja0ludGVydmFsLmR1cmF0aW9uID09PSAwKTtcbiAgICBpZiAodGltZUludGVydmFsKSB7XG4gICAgICBjb25zdCBpID0gdGltZUludGVydmFsLnRpbWVJbnRlcnZhbC5ldmVyeShhYnNJbnRlcnZhbCAvICh0aW1lSW50ZXJ2YWwuZHVyYXRpb24gLyB0aW1lSW50ZXJ2YWwuc3RlcCkpO1xuICAgICAgcmV0dXJuIGkucmFuZ2UobmV3IERhdGUoc3RhcnQyKSwgbmV3IERhdGUoc3RvcCkpO1xuICAgIH1cbiAgICBsZXQgZGF0ZSA9IG5ldyBEYXRlKHN0YXJ0Mik7XG4gICAgY29uc3Qgc3RvcERhdGUgPSBuZXcgRGF0ZShzdG9wKTtcbiAgICBjb25zdCB0aWNrcyA9IFtdO1xuICAgIHdoaWxlIChkYXRlIDw9IHN0b3BEYXRlKSB7XG4gICAgICB0aWNrcy5wdXNoKGRhdGUpO1xuICAgICAgZGF0ZSA9IG5ldyBEYXRlKGRhdGUpO1xuICAgICAgZGF0ZS5zZXRNaWxsaXNlY29uZHMoZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSArIGFic0ludGVydmFsKTtcbiAgICB9XG4gICAgcmV0dXJuIHRpY2tzO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdGltZSBmb3JtYXQgZnVuY3Rpb24gc3VpdGFibGUgZm9yIGRpc3BsYXlpbmcgdGljayB2YWx1ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB0aWNrcyBPcHRpb25hbCBhcnJheSBvZiB0aWNrIHZhbHVlcyBmb3IgY3VzdG9tIGZvcm1hdHRpbmcuXG4gICAqIEBwYXJhbSBkb21haW4gT3B0aW9uYWwgYXJyYXkgcmVwcmVzZW50aW5nIHRoZSBbbWluLCBtYXhdIHZhbHVlcyBvZiB0aGUgdGltZSBheGlzLlxuICAgKiBAcGFyYW0gc3BlY2lmaWVyIE9wdGlvbmFsIGZvcm1hdCBzcGVjaWZpZXIgc3RyaW5nIGZvciBjdXN0b20gZGF0ZSBmb3JtYXR0aW5nIChlLmcuLCBgJVlgLCBgJW1gLCBgJWRgKS5cbiAgICogQHBhcmFtIGZvcm1hdE9mZnNldCBPcHRpb25hbCBudW1iZXIgZm9yIGFwcGx5aW5nIGFuIG9mZnNldCB0byB0aGUgZm9ybWF0IChlLmcuLCB0aW1lem9uZSBzaGlmdHMpLlxuICAgKiBAcmV0dXJucyBBIGZ1bmN0aW9uIHRoYXQgZm9ybWF0cyBhIGBEYXRlYCBvYmplY3QgaW50byBhIHN0cmluZyBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgc3BlY2lmaWVyIG9yIGRlZmF1bHQgZm9ybWF0LlxuICAgKi9cbiAgdGlja0Zvcm1hdCh7XG4gICAgdGlja3MsXG4gICAgZG9tYWluLFxuICAgIHNwZWNpZmllcixcbiAgICBmb3JtYXRPZmZzZXRcbiAgfSkge1xuICAgIHJldHVybiBzcGVjaWZpZXIgPT0gbnVsbCA/IGRlZmF1bHRUaW1lVGlja0Zvcm1hdCh0aWNrcywgZG9tYWluLCBmb3JtYXRPZmZzZXQpIDogYnVpbGRGb3JtYXR0ZXIoc3BlY2lmaWVyKTtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgaWYgKCF0aGlzLmRvbWFpbiB8fCB0aGlzLmRvbWFpbi5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLm5pY2UpIHtcbiAgICAgIHRoaXMudXBkYXRlTmljZURvbWFpbigpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRXh0ZW5kcyB0aGUgZG9tYWluIHNvIHRoYXQgaXQgc3RhcnRzIGFuZCBlbmRzIG9uIG5pY2Ugcm91bmQgdmFsdWVzLlxuICAgKiBUaGlzIG1ldGhvZCB0eXBpY2FsbHkgbW9kaWZpZXMgdGhlIHNjYWxl4oCZcyBkb21haW4sIGFuZCBtYXkgb25seSBleHRlbmQgdGhlIGJvdW5kcyB0byB0aGUgbmVhcmVzdCByb3VuZCB2YWx1ZS5cbiAgICovXG4gIHVwZGF0ZU5pY2VEb21haW4oKSB7XG4gICAgY29uc3QgbWF4QXR0ZW1wdHMgPSA0O1xuICAgIGxldCBbZDAsIGQxXSA9IHRoaXMuZG9tYWluO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4QXR0ZW1wdHM7IGkrKykge1xuICAgICAgdGhpcy51cGRhdGVOaWNlRG9tYWluSXRlcmF0aW9uKGQwLCBkMSk7XG4gICAgICBjb25zdCBbbjAsIG4xXSA9IHRoaXMubmljZURvbWFpbjtcbiAgICAgIGlmIChkYXRlVG9OdW1iZXIoZDApID09PSBkYXRlVG9OdW1iZXIobjApICYmIGRhdGVUb051bWJlcihkMSkgPT09IGRhdGVUb051bWJlcihuMSkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkMCA9IG4wO1xuICAgICAgZDEgPSBuMTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlTmljZURvbWFpbkl0ZXJhdGlvbihkMCwgZDEpIHtcbiAgICBjb25zdCBzdGFydDIgPSBNYXRoLm1pbihkYXRlVG9OdW1iZXIoZDApLCBkYXRlVG9OdW1iZXIoZDEpKTtcbiAgICBjb25zdCBzdG9wID0gTWF0aC5tYXgoZGF0ZVRvTnVtYmVyKGQwKSwgZGF0ZVRvTnVtYmVyKGQxKSk7XG4gICAgY29uc3QgaXNSZXZlcnNlZCA9IGQwID4gZDE7XG4gICAgY29uc3QgeyBpbnRlcnZhbCB9ID0gdGhpcztcbiAgICBsZXQgaTtcbiAgICBpZiAoaW50ZXJ2YWwgaW5zdGFuY2VvZiBUaW1lSW50ZXJ2YWwpIHtcbiAgICAgIGkgPSBpbnRlcnZhbDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdGlja0NvdW50ID0gdHlwZW9mIGludGVydmFsID09PSBcIm51bWJlclwiID8gKHN0b3AgLSBzdGFydDIpIC8gTWF0aC5tYXgoaW50ZXJ2YWwsIDEpIDogdGhpcy50aWNrQ291bnQ7XG4gICAgICBpID0gZ2V0VGlja0ludGVydmFsKHN0YXJ0Miwgc3RvcCwgdGlja0NvdW50LCB0aGlzLm1pblRpY2tDb3VudCwgdGhpcy5tYXhUaWNrQ291bnQpO1xuICAgIH1cbiAgICBpZiAoaSkge1xuICAgICAgY29uc3QgaW50ZXJ2YWxSYW5nZSA9IGkucmFuZ2UobmV3IERhdGUoc3RhcnQyKSwgbmV3IERhdGUoc3RvcCksIHRydWUpO1xuICAgICAgY29uc3QgZG9tYWluID0gaXNSZXZlcnNlZCA/IFsuLi5pbnRlcnZhbFJhbmdlXS5yZXZlcnNlKCkgOiBpbnRlcnZhbFJhbmdlO1xuICAgICAgY29uc3QgbjAgPSBkb21haW5bMF07XG4gICAgICBjb25zdCBuMSA9IGRvbWFpbi5hdCgtMSk7XG4gICAgICB0aGlzLm5pY2VEb21haW4gPSBbbjAsIG4xXTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjYWxlL29yZGluYWxUaW1lU2NhbGUudHNcbmZ1bmN0aW9uIGNvbXBhcmVOdW1iZXJzKGEsIGIpIHtcbiAgcmV0dXJuIGEgLSBiO1xufVxudmFyIF9PcmRpbmFsVGltZVNjYWxlID0gY2xhc3MgX09yZGluYWxUaW1lU2NhbGUgZXh0ZW5kcyBCYW5kU2NhbGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9IFwib3JkaW5hbC10aW1lXCI7XG4gICAgdGhpcy50aWNrQ291bnQgPSBDb250aW51b3VzU2NhbGUuZGVmYXVsdFRpY2tDb3VudDtcbiAgICB0aGlzLm1pblRpY2tDb3VudCA9IDA7XG4gICAgdGhpcy5tYXhUaWNrQ291bnQgPSBJbmZpbml0eTtcbiAgICB0aGlzLmludGVydmFsID0gdm9pZCAwO1xuICAgIHRoaXMuX2RvbWFpbiA9IFtdO1xuICAgIHRoaXMudGltZXN0YW1wcyA9IFtdO1xuICAgIHRoaXMuc29ydGVkVGltZXN0YW1wcyA9IFtdO1xuICAgIHRoaXMudmlzaWJsZVJhbmdlID0gWzAsIDFdO1xuICB9XG4gIHN0YXRpYyBpcyh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIF9PcmRpbmFsVGltZVNjYWxlO1xuICB9XG4gIHNldFZpc2libGVSYW5nZSh2aXNpYmxlUmFuZ2UpIHtcbiAgICB0aGlzLnZpc2libGVSYW5nZSA9IHZpc2libGVSYW5nZTtcbiAgfVxuICBzZXQgZG9tYWluKHZhbHVlcykge1xuICAgIHRoaXMuaW52YWxpZCA9IHRydWU7XG4gICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuX2RvbWFpbiA9IFtdO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9kb21haW4gPSB2YWx1ZXM7XG4gICAgdGhpcy50aW1lc3RhbXBzID0gdW5pcXVlKHZhbHVlcy5tYXAoZGF0ZVRvTnVtYmVyKSk7XG4gICAgdGhpcy5zb3J0ZWRUaW1lc3RhbXBzID0gdGhpcy50aW1lc3RhbXBzLnNsaWNlKCkuc29ydChjb21wYXJlTnVtYmVycyk7XG4gIH1cbiAgZ2V0IGRvbWFpbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZG9tYWluO1xuICB9XG4gIHRpY2tzKCkge1xuICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIGNvbnN0IFt0MCwgdDFdID0gW3RoaXMudGltZXN0YW1wc1swXSwgdGhpcy50aW1lc3RhbXBzLmF0KC0xKV07XG4gICAgY29uc3Qgc3RhcnQyID0gTWF0aC5taW4odDAsIHQxKTtcbiAgICBjb25zdCBzdG9wID0gTWF0aC5tYXgodDAsIHQxKTtcbiAgICBjb25zdCBpc1JldmVyc2VkID0gdDAgPiB0MTtcbiAgICBsZXQgdGlja3M7XG4gICAgaWYgKHRoaXMuaW50ZXJ2YWwgPT0gbnVsbCkge1xuICAgICAgdGlja3MgPSB0aGlzLmdldERlZmF1bHRUaWNrcyh0aGlzLm1heFRpY2tDb3VudCwgaXNSZXZlcnNlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IFtyMCwgcjFdID0gdGhpcy5yYW5nZTtcbiAgICAgIGNvbnN0IGF2YWlsYWJsZVJhbmdlID0gTWF0aC5hYnMocjEgLSByMCk7XG4gICAgICB0aWNrcyA9IFRpbWVTY2FsZS5nZXRUaWNrc0ZvckludGVydmFsKHsgc3RhcnQ6IHN0YXJ0Miwgc3RvcCwgaW50ZXJ2YWw6IHRoaXMuaW50ZXJ2YWwsIGF2YWlsYWJsZVJhbmdlIH0pID8/IFtdO1xuICAgIH1cbiAgICBjb25zdCB0aWNrUG9zaXRpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICByZXR1cm4gdGlja3MuZmlsdGVyKCh0aWNrKSA9PiB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMuY29udmVydCh0aWNrKTtcbiAgICAgIGlmIChpc05hTihwb3NpdGlvbikgfHwgdGlja1Bvc2l0aW9ucy5oYXMocG9zaXRpb24pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRpY2tQb3NpdGlvbnMuYWRkKHBvc2l0aW9uKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICB9XG4gIGdldERlZmF1bHRUaWNrcyhtYXhUaWNrQ291bnQsIGlzUmV2ZXJzZWQpIHtcbiAgICBjb25zdCB0aWNrcyA9IFtdO1xuICAgIGNvbnN0IGNvdW50ID0gdGhpcy50aW1lc3RhbXBzLmxlbmd0aDtcbiAgICBjb25zdCB0aWNrRXZlcnkgPSBNYXRoLmNlaWwoY291bnQgKiAodGhpcy52aXNpYmxlUmFuZ2VbMV0gLSB0aGlzLnZpc2libGVSYW5nZVswXSkgLyBtYXhUaWNrQ291bnQpO1xuICAgIGNvbnN0IHRpY2tPZmZzZXQgPSBNYXRoLmZsb29yKHRpY2tFdmVyeSAvIDIpO1xuICAgIGZvciAoY29uc3QgW2luZGV4LCB2YWx1ZV0gb2YgdGhpcy50aW1lc3RhbXBzLmVudHJpZXMoKSkge1xuICAgICAgaWYgKHRpY2tFdmVyeSA+IDAgJiYgKGluZGV4ICsgdGlja09mZnNldCkgJSB0aWNrRXZlcnkpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgaWYgKGlzUmV2ZXJzZWQpIHtcbiAgICAgICAgdGlja3MucHVzaChuZXcgRGF0ZSh0aGlzLnRpbWVzdGFtcHNbY291bnQgLSBpbmRleCAtIDFdKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aWNrcy5wdXNoKG5ldyBEYXRlKHZhbHVlKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aWNrcztcbiAgfVxuICBjb252ZXJ0KGQpIHtcbiAgICB0aGlzLnJlZnJlc2goKTtcbiAgICBjb25zdCBuID0gTnVtYmVyKGQpO1xuICAgIGlmIChuIDwgdGhpcy5zb3J0ZWRUaW1lc3RhbXBzWzBdKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICBsZXQgaSA9IHRoaXMuZmluZEludGVydmFsKG4pO1xuICAgIGlmICh0aGlzLnRpbWVzdGFtcHNbMF0gIT09IHRoaXMuc29ydGVkVGltZXN0YW1wc1swXSkge1xuICAgICAgaSA9IHRoaXMudGltZXN0YW1wcy5sZW5ndGggLSBpIC0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMub3JkaW5hbFJhbmdlW2ldID8/IE5hTjtcbiAgfVxuICBmaW5kSW50ZXJ2YWwodGFyZ2V0KSB7XG4gICAgY29uc3QgeyBzb3J0ZWRUaW1lc3RhbXBzIH0gPSB0aGlzO1xuICAgIGxldCBsb3cgPSAwO1xuICAgIGxldCBoaWdoID0gc29ydGVkVGltZXN0YW1wcy5sZW5ndGggLSAxO1xuICAgIHdoaWxlIChsb3cgPD0gaGlnaCkge1xuICAgICAgY29uc3QgbWlkID0gTWF0aC5mbG9vcigobG93ICsgaGlnaCkgLyAyKTtcbiAgICAgIGlmIChzb3J0ZWRUaW1lc3RhbXBzW21pZF0gPT09IHRhcmdldCkge1xuICAgICAgICByZXR1cm4gbWlkO1xuICAgICAgfSBlbHNlIGlmIChzb3J0ZWRUaW1lc3RhbXBzW21pZF0gPCB0YXJnZXQpIHtcbiAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhpZ2ggPSBtaWQgLSAxO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbG93O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdGltZSBmb3JtYXQgZnVuY3Rpb24gc3VpdGFibGUgZm9yIGRpc3BsYXlpbmcgdGljayB2YWx1ZXMuXG4gICAqIEBwYXJhbSBzcGVjaWZpZXIgSWYgdGhlIHNwZWNpZmllciBzdHJpbmcgaXMgcHJvdmlkZWQsIHRoaXMgbWV0aG9kIGlzIGVxdWl2YWxlbnQgdG9cbiAgICogdGhlIHtAbGluayBUaW1lTG9jYWxlT2JqZWN0LmZvcm1hdH0gbWV0aG9kLlxuICAgKiBJZiBubyBzcGVjaWZpZXIgaXMgcHJvdmlkZWQsIHRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGRlZmF1bHQgdGltZSBmb3JtYXQgZnVuY3Rpb24uXG4gICAqL1xuICB0aWNrRm9ybWF0KHtcbiAgICB0aWNrcyxcbiAgICBkb21haW4sXG4gICAgc3BlY2lmaWVyXG4gIH0pIHtcbiAgICByZXR1cm4gc3BlY2lmaWVyID09IG51bGwgPyBkZWZhdWx0VGltZVRpY2tGb3JtYXQodGlja3MsIGRvbWFpbikgOiBidWlsZEZvcm1hdHRlcihzcGVjaWZpZXIpO1xuICB9XG4gIGludmVydChwb3NpdGlvbikge1xuICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5vcmRpbmFsUmFuZ2UuZmluZEluZGV4KChwKSA9PiBwb3NpdGlvbiA8PSBwKTtcbiAgICByZXR1cm4gdGhpcy5kb21haW5baW5kZXhdO1xuICB9XG4gIGludmVydE5lYXJlc3QoeSkge1xuICAgIHJldHVybiBuZXcgRGF0ZShzdXBlci5pbnZlcnROZWFyZXN0KHkpKTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEludmFsaWRhdGluZ1xuXSwgX09yZGluYWxUaW1lU2NhbGUucHJvdG90eXBlLCBcInRpY2tDb3VudFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEludmFsaWRhdGluZ1xuXSwgX09yZGluYWxUaW1lU2NhbGUucHJvdG90eXBlLCBcIm1pblRpY2tDb3VudFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEludmFsaWRhdGluZ1xuXSwgX09yZGluYWxUaW1lU2NhbGUucHJvdG90eXBlLCBcIm1heFRpY2tDb3VudFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEludmFsaWRhdGluZ1xuXSwgX09yZGluYWxUaW1lU2NhbGUucHJvdG90eXBlLCBcImludGVydmFsXCIsIDIpO1xudmFyIE9yZGluYWxUaW1lU2NhbGUgPSBfT3JkaW5hbFRpbWVTY2FsZTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9jb21wYXJlLnRzXG5mdW5jdGlvbiBhc2NlbmRpbmdTdHJpbmdOdW1iZXJVbmRlZmluZWQoYSwgYikge1xuICBpZiAodHlwZW9mIGEgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIGIgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gYSAtIGI7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGEgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGIgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gYS5sb2NhbGVDb21wYXJlKGIpO1xuICB9IGVsc2UgaWYgKGEgPT0gbnVsbCAmJiBiID09IG51bGwpIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIGlmIChhID09IG51bGwpIHtcbiAgICByZXR1cm4gLTE7XG4gIH0gZWxzZSBpZiAoYiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIFN0cmluZyhhKS5sb2NhbGVDb21wYXJlKFN0cmluZyhiKSk7XG59XG5mdW5jdGlvbiB0b0xpdGVyYWwodikge1xuICByZXR1cm4gdHlwZW9mIHYgPT09IFwiZnVuY3Rpb25cIiA/IHYoKSA6IHY7XG59XG5mdW5jdGlvbiBjb21wb3VuZEFzY2VuZGluZyhhLCBiLCBjb21wYXJhdG9yKSB7XG4gIGZvciAoY29uc3QgaWR4IGluIGEpIHtcbiAgICBjb25zdCBkaWZmMiA9IGNvbXBhcmF0b3IodG9MaXRlcmFsKGFbaWR4XSksIHRvTGl0ZXJhbChiW2lkeF0pKTtcbiAgICBpZiAoZGlmZjIgIT09IDApIHtcbiAgICAgIHJldHVybiBkaWZmMjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL2RlYnVnLnV0aWwudHNcbmZ1bmN0aW9uIG5vZGVDb3VudChub2RlKSB7XG4gIGxldCBjb3VudCA9IDE7XG4gIGxldCB2aXNpYmxlQ291bnQgPSBub2RlLnZpc2libGUgPyAxIDogMDtcbiAgbGV0IGRpcnR5Q291bnQgPSBub2RlLmRpcnR5ID4gMCAvKiBOT05FICovID8gMSA6IDA7XG4gIGZvciAoY29uc3QgY2hpbGQgb2Ygbm9kZS5jaGlsZHJlbihmYWxzZSkpIHtcbiAgICBjb25zdCBjID0gbm9kZUNvdW50KGNoaWxkKTtcbiAgICBjb3VudCArPSBjLmNvdW50O1xuICAgIGRpcnR5Q291bnQgKz0gYy5kaXJ0eUNvdW50O1xuICAgIHZpc2libGVDb3VudCArPSBjLnZpc2libGVDb3VudDtcbiAgfVxuICByZXR1cm4geyBjb3VudCwgdmlzaWJsZUNvdW50LCBkaXJ0eUNvdW50IH07XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL21hdHJpeC50c1xudmFyIElERU5USVRZX01BVFJJWF9FTEVNRU5UUyA9IE9iamVjdC5mcmVlemUoWzEsIDAsIDAsIDEsIDAsIDBdKTtcbmZ1bmN0aW9uIGNsb3NlVmFsdWUodmFsLCByZWYsIGVycm9yTWFyZ2luID0gMWUtOCkge1xuICByZXR1cm4gdmFsID09PSByZWYgfHwgTWF0aC5hYnMocmVmIC0gdmFsKSA8IGVycm9yTWFyZ2luO1xufVxudmFyIF9NYXRyaXggPSBjbGFzcyBfTWF0cml4IHtcbiAgZ2V0IGUoKSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLmVsZW1lbnRzXTtcbiAgfVxuICBjb25zdHJ1Y3RvcihlbGVtZW50czIgPSBbLi4uSURFTlRJVFlfTUFUUklYX0VMRU1FTlRTXSkge1xuICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50czI7XG4gIH1cbiAgc2V0RWxlbWVudHMoZWxlbWVudHMyKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgZVswXSA9IGVsZW1lbnRzMlswXTtcbiAgICBlWzFdID0gZWxlbWVudHMyWzFdO1xuICAgIGVbMl0gPSBlbGVtZW50czJbMl07XG4gICAgZVszXSA9IGVsZW1lbnRzMlszXTtcbiAgICBlWzRdID0gZWxlbWVudHMyWzRdO1xuICAgIGVbNV0gPSBlbGVtZW50czJbNV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZ2V0IGlkZW50aXR5KCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgIHJldHVybiBjbG9zZVZhbHVlKGVbMF0sIDEpICYmIGNsb3NlVmFsdWUoZVsxXSwgMCkgJiYgY2xvc2VWYWx1ZShlWzJdLCAwKSAmJiBjbG9zZVZhbHVlKGVbM10sIDEpICYmIGNsb3NlVmFsdWUoZVs0XSwgMCkgJiYgY2xvc2VWYWx1ZShlWzVdLCAwKTtcbiAgfVxuICAvKipcbiAgICogUGVyZm9ybXMgdGhlIEF4QiBtYXRyaXggbXVsdGlwbGljYXRpb24gYW5kIHNhdmVzIHRoZSByZXN1bHRcbiAgICogdG8gYENgLCBpZiBnaXZlbiwgb3IgdG8gYEFgIG90aGVyd2lzZS5cbiAgICovXG4gIEF4QihBLCBCLCBDKSB7XG4gICAgY29uc3QgYSA9IEFbMF0gKiBCWzBdICsgQVsyXSAqIEJbMV0sIGIgPSBBWzFdICogQlswXSArIEFbM10gKiBCWzFdLCBjID0gQVswXSAqIEJbMl0gKyBBWzJdICogQlszXSwgZCA9IEFbMV0gKiBCWzJdICsgQVszXSAqIEJbM10sIGUgPSBBWzBdICogQls0XSArIEFbMl0gKiBCWzVdICsgQVs0XSwgZiA9IEFbMV0gKiBCWzRdICsgQVszXSAqIEJbNV0gKyBBWzVdO1xuICAgIEMgPSBDID8/IEE7XG4gICAgQ1swXSA9IGE7XG4gICAgQ1sxXSA9IGI7XG4gICAgQ1syXSA9IGM7XG4gICAgQ1szXSA9IGQ7XG4gICAgQ1s0XSA9IGU7XG4gICAgQ1s1XSA9IGY7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBgb3RoZXJgIG1hdHJpeCBnZXRzIHBvc3QtbXVsdGlwbGllZCB0byB0aGUgY3VycmVudCBtYXRyaXguXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgbWF0cml4LlxuICAgKiBAcGFyYW0gb3RoZXJcbiAgICovXG4gIG11bHRpcGx5U2VsZihvdGhlcikge1xuICAgIHRoaXMuQXhCKHRoaXMuZWxlbWVudHMsIG90aGVyLmVsZW1lbnRzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogVGhlIGBvdGhlcmAgbWF0cml4IGdldHMgcG9zdC1tdWx0aXBsaWVkIHRvIHRoZSBjdXJyZW50IG1hdHJpeC5cbiAgICogUmV0dXJucyBhIG5ldyBtYXRyaXguXG4gICAqIEBwYXJhbSBvdGhlclxuICAgKi9cbiAgbXVsdGlwbHkob3RoZXIpIHtcbiAgICBjb25zdCBlbGVtZW50czIgPSBuZXcgQXJyYXkoNik7XG4gICAgaWYgKG90aGVyIGluc3RhbmNlb2YgX01hdHJpeCkge1xuICAgICAgdGhpcy5BeEIodGhpcy5lbGVtZW50cywgb3RoZXIuZWxlbWVudHMsIGVsZW1lbnRzMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuQXhCKHRoaXMuZWxlbWVudHMsIFtvdGhlci5hLCBvdGhlci5iLCBvdGhlci5jLCBvdGhlci5kLCBvdGhlci5lLCBvdGhlci5mXSwgZWxlbWVudHMyKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBfTWF0cml4KGVsZW1lbnRzMik7XG4gIH1cbiAgcHJlTXVsdGlwbHlTZWxmKG90aGVyKSB7XG4gICAgdGhpcy5BeEIob3RoZXIuZWxlbWVudHMsIHRoaXMuZWxlbWVudHMsIHRoaXMuZWxlbWVudHMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbnZlcnNlIG9mIHRoaXMgbWF0cml4IGFzIGEgbmV3IG1hdHJpeC5cbiAgICovXG4gIGludmVyc2UoKSB7XG4gICAgY29uc3QgZWwgPSB0aGlzLmVsZW1lbnRzO1xuICAgIGxldCBhID0gZWxbMF0sIGIgPSBlbFsxXSwgYyA9IGVsWzJdLCBkID0gZWxbM107XG4gICAgY29uc3QgZSA9IGVsWzRdLCBmID0gZWxbNV07XG4gICAgY29uc3QgckQgPSAxIC8gKGEgKiBkIC0gYiAqIGMpO1xuICAgIGEgKj0gckQ7XG4gICAgYiAqPSByRDtcbiAgICBjICo9IHJEO1xuICAgIGQgKj0gckQ7XG4gICAgcmV0dXJuIG5ldyBfTWF0cml4KFtkLCAtYiwgLWMsIGEsIGMgKiBmIC0gZCAqIGUsIGIgKiBlIC0gYSAqIGZdKTtcbiAgfVxuICAvKipcbiAgICogU2F2ZSB0aGUgaW52ZXJzZSBvZiB0aGlzIG1hdHJpeCB0byB0aGUgZ2l2ZW4gbWF0cml4LlxuICAgKi9cbiAgaW52ZXJzZVRvKG90aGVyKSB7XG4gICAgY29uc3QgZWwgPSB0aGlzLmVsZW1lbnRzO1xuICAgIGxldCBhID0gZWxbMF0sIGIgPSBlbFsxXSwgYyA9IGVsWzJdLCBkID0gZWxbM107XG4gICAgY29uc3QgZSA9IGVsWzRdLCBmID0gZWxbNV07XG4gICAgY29uc3QgckQgPSAxIC8gKGEgKiBkIC0gYiAqIGMpO1xuICAgIGEgKj0gckQ7XG4gICAgYiAqPSByRDtcbiAgICBjICo9IHJEO1xuICAgIGQgKj0gckQ7XG4gICAgb3RoZXIuc2V0RWxlbWVudHMoW2QsIC1iLCAtYywgYSwgYyAqIGYgLSBkICogZSwgYiAqIGUgLSBhICogZl0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGludmVydFNlbGYoKSB7XG4gICAgY29uc3QgZWwgPSB0aGlzLmVsZW1lbnRzO1xuICAgIGxldCBhID0gZWxbMF0sIGIgPSBlbFsxXSwgYyA9IGVsWzJdLCBkID0gZWxbM107XG4gICAgY29uc3QgZSA9IGVsWzRdLCBmID0gZWxbNV07XG4gICAgY29uc3QgckQgPSAxIC8gKGEgKiBkIC0gYiAqIGMpO1xuICAgIGEgKj0gckQ7XG4gICAgYiAqPSByRDtcbiAgICBjICo9IHJEO1xuICAgIGQgKj0gckQ7XG4gICAgZWxbMF0gPSBkO1xuICAgIGVsWzFdID0gLWI7XG4gICAgZWxbMl0gPSAtYztcbiAgICBlbFszXSA9IGE7XG4gICAgZWxbNF0gPSBjICogZiAtIGQgKiBlO1xuICAgIGVsWzVdID0gYiAqIGUgLSBhICogZjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB0cmFuc2Zvcm1Qb2ludCh4LCB5KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHggKiBlWzBdICsgeSAqIGVbMl0gKyBlWzRdLFxuICAgICAgeTogeCAqIGVbMV0gKyB5ICogZVszXSArIGVbNV1cbiAgICB9O1xuICB9XG4gIHRyYW5zZm9ybUJCb3goYmJveCwgdGFyZ2V0KSB7XG4gICAgY29uc3QgZWwgPSB0aGlzLmVsZW1lbnRzO1xuICAgIGNvbnN0IHh4ID0gZWxbMF07XG4gICAgY29uc3QgeHkgPSBlbFsxXTtcbiAgICBjb25zdCB5eCA9IGVsWzJdO1xuICAgIGNvbnN0IHl5ID0gZWxbM107XG4gICAgY29uc3QgaF93ID0gYmJveC53aWR0aCAqIDAuNTtcbiAgICBjb25zdCBoX2ggPSBiYm94LmhlaWdodCAqIDAuNTtcbiAgICBjb25zdCBjeCA9IGJib3gueCArIGhfdztcbiAgICBjb25zdCBjeSA9IGJib3gueSArIGhfaDtcbiAgICBjb25zdCB3ID0gTWF0aC5hYnMoaF93ICogeHgpICsgTWF0aC5hYnMoaF9oICogeXgpO1xuICAgIGNvbnN0IGggPSBNYXRoLmFicyhoX3cgKiB4eSkgKyBNYXRoLmFicyhoX2ggKiB5eSk7XG4gICAgdGFyZ2V0ID8/ICh0YXJnZXQgPSBuZXcgQkJveCgwLCAwLCAwLCAwKSk7XG4gICAgdGFyZ2V0LnggPSBjeCAqIHh4ICsgY3kgKiB5eCArIGVsWzRdIC0gdztcbiAgICB0YXJnZXQueSA9IGN4ICogeHkgKyBjeSAqIHl5ICsgZWxbNV0gLSBoO1xuICAgIHRhcmdldC53aWR0aCA9IHcgKyB3O1xuICAgIHRhcmdldC5oZWlnaHQgPSBoICsgaDtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIHRvQ29udGV4dChjdHgpIHtcbiAgICBpZiAodGhpcy5pZGVudGl0eSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBlID0gdGhpcy5lbGVtZW50cztcbiAgICBjdHgudHJhbnNmb3JtKGVbMF0sIGVbMV0sIGVbMl0sIGVbM10sIGVbNF0sIGVbNV0pO1xuICB9XG4gIHN0YXRpYyBmbHl3ZWlnaHQoc291cmNlTWF0cml4KSB7XG4gICAgcmV0dXJuIF9NYXRyaXguaW5zdGFuY2Uuc2V0RWxlbWVudHMoc291cmNlTWF0cml4LmVsZW1lbnRzKTtcbiAgfVxuICBzdGF0aWMgdXBkYXRlVHJhbnNmb3JtTWF0cml4KG1hdHJpeCwgc2NhbGluZ1gsIHNjYWxpbmdZLCByb3RhdGlvbiwgdHJhbnNsYXRpb25YLCB0cmFuc2xhdGlvblksIG9wdHMpIHtcbiAgICBjb25zdCBzeCA9IHNjYWxpbmdYO1xuICAgIGNvbnN0IHN5ID0gc2NhbGluZ1k7XG4gICAgbGV0IHNjeDtcbiAgICBsZXQgc2N5O1xuICAgIGlmIChzeCA9PT0gMSAmJiBzeSA9PT0gMSkge1xuICAgICAgc2N4ID0gMDtcbiAgICAgIHNjeSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjeCA9IG9wdHM/LnNjYWxpbmdDZW50ZXJYID8/IDA7XG4gICAgICBzY3kgPSBvcHRzPy5zY2FsaW5nQ2VudGVyWSA/PyAwO1xuICAgIH1cbiAgICBjb25zdCByID0gcm90YXRpb247XG4gICAgY29uc3QgY29zID0gTWF0aC5jb3Mocik7XG4gICAgY29uc3Qgc2luID0gTWF0aC5zaW4ocik7XG4gICAgbGV0IHJjeDtcbiAgICBsZXQgcmN5O1xuICAgIGlmIChyID09PSAwKSB7XG4gICAgICByY3ggPSAwO1xuICAgICAgcmN5ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmN4ID0gb3B0cz8ucm90YXRpb25DZW50ZXJYID8/IDA7XG4gICAgICByY3kgPSBvcHRzPy5yb3RhdGlvbkNlbnRlclkgPz8gMDtcbiAgICB9XG4gICAgY29uc3QgdHggPSB0cmFuc2xhdGlvblg7XG4gICAgY29uc3QgdHkgPSB0cmFuc2xhdGlvblk7XG4gICAgY29uc3QgdHg0ID0gc2N4ICogKDEgLSBzeCkgLSByY3g7XG4gICAgY29uc3QgdHk0ID0gc2N5ICogKDEgLSBzeSkgLSByY3k7XG4gICAgbWF0cml4LnNldEVsZW1lbnRzKFtcbiAgICAgIGNvcyAqIHN4LFxuICAgICAgc2luICogc3gsXG4gICAgICAtc2luICogc3ksXG4gICAgICBjb3MgKiBzeSxcbiAgICAgIGNvcyAqIHR4NCAtIHNpbiAqIHR5NCArIHJjeCArIHR4LFxuICAgICAgc2luICogdHg0ICsgY29zICogdHk0ICsgcmN5ICsgdHlcbiAgICBdKTtcbiAgICByZXR1cm4gbWF0cml4O1xuICB9XG4gIHN0YXRpYyBmcm9tQ29udGV4dChjdHgpIHtcbiAgICBjb25zdCBkb21NYXRyaXggPSBjdHguZ2V0VHJhbnNmb3JtKCk7XG4gICAgcmV0dXJuIG5ldyBfTWF0cml4KFtkb21NYXRyaXguYSwgZG9tTWF0cml4LmIsIGRvbU1hdHJpeC5jLCBkb21NYXRyaXguZCwgZG9tTWF0cml4LmUsIGRvbU1hdHJpeC5mXSk7XG4gIH1cbn07XG5fTWF0cml4Lmluc3RhbmNlID0gbmV3IF9NYXRyaXgoKTtcbnZhciBNYXRyaXggPSBfTWF0cml4O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS90cmFuc2Zvcm1hYmxlLnRzXG5mdW5jdGlvbiBpc01hdHJpeFRyYW5zZm9ybShub2RlKSB7XG4gIHJldHVybiBpc01hdHJpeFRyYW5zZm9ybVR5cGUobm9kZS5jb25zdHJ1Y3Rvcik7XG59XG52YXIgTUFUUklYX1RSQU5TRk9STV9UWVBFID0gU3ltYm9sKFwiaXNNYXRyaXhUcmFuc2Zvcm1cIik7XG5mdW5jdGlvbiBpc01hdHJpeFRyYW5zZm9ybVR5cGUoY3N0cikge1xuICByZXR1cm4gY3N0cltNQVRSSVhfVFJBTlNGT1JNX1RZUEVdID09PSB0cnVlO1xufVxuZnVuY3Rpb24gTWF0cml4VHJhbnNmb3JtKFBhcmVudCkge1xuICB2YXIgX2EsIF9iO1xuICBjb25zdCBQYXJlbnROb2RlID0gUGFyZW50O1xuICBpZiAoaXNNYXRyaXhUcmFuc2Zvcm1UeXBlKFBhcmVudCkpIHtcbiAgICByZXR1cm4gUGFyZW50O1xuICB9XG4gIGNvbnN0IFRSQU5TRk9STV9NQVRSSVggPSBTeW1ib2woXCJtYXRyaXhfY29tYmluZWRfdHJhbnNmb3JtXCIpO1xuICBjbGFzcyBNYXRyaXhUcmFuc2Zvcm1JbnRlcm5hbCBleHRlbmRzIFBhcmVudE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgIHRoaXNbX2JdID0gbmV3IE1hdHJpeCgpO1xuICAgICAgdGhpcy5fZGlydHlUcmFuc2Zvcm0gPSB0cnVlO1xuICAgIH1cbiAgICBtYXJrRGlydHlUcmFuc2Zvcm0oKSB7XG4gICAgICB0aGlzLl9kaXJ0eVRyYW5zZm9ybSA9IHRydWU7XG4gICAgICBzdXBlci5tYXJrRGlydHkoMyAvKiBNQUpPUiAqLyk7XG4gICAgfVxuICAgIHVwZGF0ZU1hdHJpeChfbWF0cml4KSB7XG4gICAgfVxuICAgIGNvbXB1dGVUcmFuc2Zvcm1NYXRyaXgoKSB7XG4gICAgICBpZiAoIXRoaXMuX2RpcnR5VHJhbnNmb3JtKVxuICAgICAgICByZXR1cm47XG4gICAgICB0aGlzW1RSQU5TRk9STV9NQVRSSVhdLnNldEVsZW1lbnRzKElERU5USVRZX01BVFJJWF9FTEVNRU5UUyk7XG4gICAgICB0aGlzLnVwZGF0ZU1hdHJpeCh0aGlzW1RSQU5TRk9STV9NQVRSSVhdKTtcbiAgICAgIHRoaXMuX2RpcnR5VHJhbnNmb3JtID0gZmFsc2U7XG4gICAgfVxuICAgIHRvUGFyZW50KGJib3gpIHtcbiAgICAgIHRoaXMuY29tcHV0ZVRyYW5zZm9ybU1hdHJpeCgpO1xuICAgICAgaWYgKHRoaXNbVFJBTlNGT1JNX01BVFJJWF0uaWRlbnRpdHkpXG4gICAgICAgIHJldHVybiBiYm94LmNsb25lKCk7XG4gICAgICByZXR1cm4gdGhpc1tUUkFOU0ZPUk1fTUFUUklYXS50cmFuc2Zvcm1CQm94KGJib3gpO1xuICAgIH1cbiAgICB0b1BhcmVudFBvaW50KHgsIHkpIHtcbiAgICAgIHRoaXMuY29tcHV0ZVRyYW5zZm9ybU1hdHJpeCgpO1xuICAgICAgaWYgKHRoaXNbVFJBTlNGT1JNX01BVFJJWF0uaWRlbnRpdHkpXG4gICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICAgIHJldHVybiB0aGlzW1RSQU5TRk9STV9NQVRSSVhdLnRyYW5zZm9ybVBvaW50KHgsIHkpO1xuICAgIH1cbiAgICBmcm9tUGFyZW50KGJib3gpIHtcbiAgICAgIHRoaXMuY29tcHV0ZVRyYW5zZm9ybU1hdHJpeCgpO1xuICAgICAgaWYgKHRoaXNbVFJBTlNGT1JNX01BVFJJWF0uaWRlbnRpdHkpXG4gICAgICAgIHJldHVybiBiYm94LmNsb25lKCk7XG4gICAgICByZXR1cm4gdGhpc1tUUkFOU0ZPUk1fTUFUUklYXS5pbnZlcnNlKCkudHJhbnNmb3JtQkJveChiYm94KTtcbiAgICB9XG4gICAgZnJvbVBhcmVudFBvaW50KHgsIHkpIHtcbiAgICAgIHRoaXMuY29tcHV0ZVRyYW5zZm9ybU1hdHJpeCgpO1xuICAgICAgaWYgKHRoaXNbVFJBTlNGT1JNX01BVFJJWF0uaWRlbnRpdHkpXG4gICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICAgIHJldHVybiB0aGlzW1RSQU5TRk9STV9NQVRSSVhdLmludmVyc2UoKS50cmFuc2Zvcm1Qb2ludCh4LCB5KTtcbiAgICB9XG4gICAgY29tcHV0ZUJCb3goKSB7XG4gICAgICBjb25zdCBiYm94ID0gc3VwZXIuY29tcHV0ZUJCb3goKTtcbiAgICAgIGlmICghYmJveClcbiAgICAgICAgcmV0dXJuIGJib3g7XG4gICAgICByZXR1cm4gdGhpcy50b1BhcmVudChiYm94KTtcbiAgICB9XG4gICAgY29tcHV0ZUJCb3hXaXRob3V0VHJhbnNmb3JtcygpIHtcbiAgICAgIHJldHVybiBzdXBlci5jb21wdXRlQkJveCgpO1xuICAgIH1cbiAgICBwaWNrTm9kZSh4LCB5LCBsb2NhbENvb3JkcyA9IGZhbHNlKSB7XG4gICAgICBpZiAoIWxvY2FsQ29vcmRzKSB7XG4gICAgICAgICh7IHgsIHkgfSA9IHRoaXMuZnJvbVBhcmVudFBvaW50KHgsIHkpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdXBlci5waWNrTm9kZSh4LCB5KTtcbiAgICB9XG4gICAgcmVuZGVyKHJlbmRlckN0eCkge1xuICAgICAgaWYgKHRoaXMuX2RpcnR5VHJhbnNmb3JtKSB7XG4gICAgICAgIHRoaXMuY29tcHV0ZVRyYW5zZm9ybU1hdHJpeCgpO1xuICAgICAgICBpZiAoIXJlbmRlckN0eC5mb3JjZVJlbmRlcikge1xuICAgICAgICAgIHJlbmRlckN0eCA9IHsgLi4ucmVuZGVyQ3R4LCBmb3JjZVJlbmRlcjogXCJkaXJ0eVRyYW5zZm9ybVwiIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IG1hdHJpeCA9IHRoaXNbVFJBTlNGT1JNX01BVFJJWF07XG4gICAgICBsZXQgcGVyZm9ybVJlc3RvcmUgPSBmYWxzZTtcbiAgICAgIGlmICghbWF0cml4LmlkZW50aXR5KSB7XG4gICAgICAgIHJlbmRlckN0eC5jdHguc2F2ZSgpO1xuICAgICAgICBwZXJmb3JtUmVzdG9yZSA9IHRydWU7XG4gICAgICAgIG1hdHJpeC50b0NvbnRleHQocmVuZGVyQ3R4LmN0eCk7XG4gICAgICB9XG4gICAgICBzdXBlci5yZW5kZXIocmVuZGVyQ3R4KTtcbiAgICAgIGlmIChwZXJmb3JtUmVzdG9yZSkge1xuICAgICAgICByZW5kZXJDdHguY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdG9TVkcoKSB7XG4gICAgICBjb25zdCBzdmcgPSBzdXBlci50b1NWRygpO1xuICAgICAgY29uc3QgbWF0cml4ID0gdGhpc1tUUkFOU0ZPUk1fTUFUUklYXTtcbiAgICAgIGlmIChtYXRyaXguaWRlbnRpdHkgfHwgc3ZnID09IG51bGwpXG4gICAgICAgIHJldHVybiBzdmc7XG4gICAgICBjb25zdCBnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJnXCIpO1xuICAgICAgZy5hcHBlbmQoLi4uc3ZnLmVsZW1lbnRzKTtcbiAgICAgIGNvbnN0IFthLCBiLCBjLCBkLCBlLCBmXSA9IG1hdHJpeC5lO1xuICAgICAgZy5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgYG1hdHJpeCgke2F9ICR7Yn0gJHtjfSAke2R9ICR7ZX0gJHtmfSlgKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVsZW1lbnRzOiBbZ10sXG4gICAgICAgIGRlZnM6IHN2Zy5kZWZzXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICBfYSA9IE1BVFJJWF9UUkFOU0ZPUk1fVFlQRSwgX2IgPSBUUkFOU0ZPUk1fTUFUUklYO1xuICBNYXRyaXhUcmFuc2Zvcm1JbnRlcm5hbFtfYV0gPSB0cnVlO1xuICByZXR1cm4gTWF0cml4VHJhbnNmb3JtSW50ZXJuYWw7XG59XG5mdW5jdGlvbiBSb3RhdGFibGUoUGFyZW50KSB7XG4gIHZhciBfYTtcbiAgY29uc3QgUGFyZW50Tm9kZSA9IFBhcmVudDtcbiAgY29uc3QgUk9UQVRBQkxFX01BVFJJWCA9IFN5bWJvbChcIm1hdHJpeF9yb3RhdGlvblwiKTtcbiAgY2xhc3MgUm90YXRhYmxlSW50ZXJuYWwgZXh0ZW5kcyBNYXRyaXhUcmFuc2Zvcm0oUGFyZW50Tm9kZSkge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgIHRoaXNbX2FdID0gbmV3IE1hdHJpeCgpO1xuICAgICAgdGhpcy5yb3RhdGlvbkNlbnRlclggPSBudWxsO1xuICAgICAgdGhpcy5yb3RhdGlvbkNlbnRlclkgPSBudWxsO1xuICAgICAgdGhpcy5yb3RhdGlvbiA9IDA7XG4gICAgfVxuICAgIHVwZGF0ZU1hdHJpeChtYXRyaXgpIHtcbiAgICAgIHN1cGVyLnVwZGF0ZU1hdHJpeChtYXRyaXgpO1xuICAgICAgY29uc3QgeyByb3RhdGlvbiwgcm90YXRpb25DZW50ZXJYLCByb3RhdGlvbkNlbnRlclkgfSA9IHRoaXM7XG4gICAgICBpZiAocm90YXRpb24gPT09IDApXG4gICAgICAgIHJldHVybjtcbiAgICAgIE1hdHJpeC51cGRhdGVUcmFuc2Zvcm1NYXRyaXgodGhpc1tST1RBVEFCTEVfTUFUUklYXSwgMSwgMSwgcm90YXRpb24sIDAsIDAsIHtcbiAgICAgICAgcm90YXRpb25DZW50ZXJYLFxuICAgICAgICByb3RhdGlvbkNlbnRlcllcbiAgICAgIH0pO1xuICAgICAgbWF0cml4Lm11bHRpcGx5U2VsZih0aGlzW1JPVEFUQUJMRV9NQVRSSVhdKTtcbiAgICB9XG4gIH1cbiAgX2EgPSBST1RBVEFCTEVfTUFUUklYO1xuICBfX2RlY29yYXRlQ2xhc3MoW1xuICAgIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgdHlwZTogXCJ0cmFuc2Zvcm1cIiB9KVxuICBdLCBSb3RhdGFibGVJbnRlcm5hbC5wcm90b3R5cGUsIFwicm90YXRpb25DZW50ZXJYXCIsIDIpO1xuICBfX2RlY29yYXRlQ2xhc3MoW1xuICAgIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgdHlwZTogXCJ0cmFuc2Zvcm1cIiB9KVxuICBdLCBSb3RhdGFibGVJbnRlcm5hbC5wcm90b3R5cGUsIFwicm90YXRpb25DZW50ZXJZXCIsIDIpO1xuICBfX2RlY29yYXRlQ2xhc3MoW1xuICAgIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgdHlwZTogXCJ0cmFuc2Zvcm1cIiB9KVxuICBdLCBSb3RhdGFibGVJbnRlcm5hbC5wcm90b3R5cGUsIFwicm90YXRpb25cIiwgMik7XG4gIHJldHVybiBSb3RhdGFibGVJbnRlcm5hbDtcbn1cbmZ1bmN0aW9uIFNjYWxhYmxlKFBhcmVudCkge1xuICB2YXIgX2E7XG4gIGNvbnN0IFBhcmVudE5vZGUgPSBQYXJlbnQ7XG4gIGNvbnN0IFNDQUxBQkxFX01BVFJJWCA9IFN5bWJvbChcIm1hdHJpeF9zY2FsZVwiKTtcbiAgY2xhc3MgU2NhbGFibGVJbnRlcm5hbCBleHRlbmRzIE1hdHJpeFRyYW5zZm9ybShQYXJlbnROb2RlKSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgdGhpc1tfYV0gPSBuZXcgTWF0cml4KCk7XG4gICAgICB0aGlzLnNjYWxpbmdYID0gMTtcbiAgICAgIHRoaXMuc2NhbGluZ1kgPSAxO1xuICAgICAgdGhpcy5zY2FsaW5nQ2VudGVyWCA9IG51bGw7XG4gICAgICB0aGlzLnNjYWxpbmdDZW50ZXJZID0gbnVsbDtcbiAgICB9XG4gICAgdXBkYXRlTWF0cml4KG1hdHJpeCkge1xuICAgICAgc3VwZXIudXBkYXRlTWF0cml4KG1hdHJpeCk7XG4gICAgICBjb25zdCB7IHNjYWxpbmdYLCBzY2FsaW5nWSwgc2NhbGluZ0NlbnRlclgsIHNjYWxpbmdDZW50ZXJZIH0gPSB0aGlzO1xuICAgICAgaWYgKHNjYWxpbmdYID09PSAxICYmIHNjYWxpbmdZID09PSAxKVxuICAgICAgICByZXR1cm47XG4gICAgICBNYXRyaXgudXBkYXRlVHJhbnNmb3JtTWF0cml4KHRoaXNbU0NBTEFCTEVfTUFUUklYXSwgc2NhbGluZ1gsIHNjYWxpbmdZLCAwLCAwLCAwLCB7XG4gICAgICAgIHNjYWxpbmdDZW50ZXJYLFxuICAgICAgICBzY2FsaW5nQ2VudGVyWVxuICAgICAgfSk7XG4gICAgICBtYXRyaXgubXVsdGlwbHlTZWxmKHRoaXNbU0NBTEFCTEVfTUFUUklYXSk7XG4gICAgfVxuICB9XG4gIF9hID0gU0NBTEFCTEVfTUFUUklYO1xuICBfX2RlY29yYXRlQ2xhc3MoW1xuICAgIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgdHlwZTogXCJ0cmFuc2Zvcm1cIiB9KVxuICBdLCBTY2FsYWJsZUludGVybmFsLnByb3RvdHlwZSwgXCJzY2FsaW5nWFwiLCAyKTtcbiAgX19kZWNvcmF0ZUNsYXNzKFtcbiAgICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHR5cGU6IFwidHJhbnNmb3JtXCIgfSlcbiAgXSwgU2NhbGFibGVJbnRlcm5hbC5wcm90b3R5cGUsIFwic2NhbGluZ1lcIiwgMik7XG4gIF9fZGVjb3JhdGVDbGFzcyhbXG4gICAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyB0eXBlOiBcInRyYW5zZm9ybVwiIH0pXG4gIF0sIFNjYWxhYmxlSW50ZXJuYWwucHJvdG90eXBlLCBcInNjYWxpbmdDZW50ZXJYXCIsIDIpO1xuICBfX2RlY29yYXRlQ2xhc3MoW1xuICAgIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgdHlwZTogXCJ0cmFuc2Zvcm1cIiB9KVxuICBdLCBTY2FsYWJsZUludGVybmFsLnByb3RvdHlwZSwgXCJzY2FsaW5nQ2VudGVyWVwiLCAyKTtcbiAgcmV0dXJuIFNjYWxhYmxlSW50ZXJuYWw7XG59XG5mdW5jdGlvbiBUcmFuc2xhdGFibGUoUGFyZW50KSB7XG4gIHZhciBfYTtcbiAgY29uc3QgUGFyZW50Tm9kZSA9IFBhcmVudDtcbiAgY29uc3QgVFJBTlNMQVRBQkxFX01BVFJJWCA9IFN5bWJvbChcIm1hdHJpeF90cmFuc2xhdGlvblwiKTtcbiAgY2xhc3MgVHJhbnNsYXRhYmxlSW50ZXJuYWwgZXh0ZW5kcyBNYXRyaXhUcmFuc2Zvcm0oUGFyZW50Tm9kZSkge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgIHRoaXNbX2FdID0gbmV3IE1hdHJpeCgpO1xuICAgICAgdGhpcy50cmFuc2xhdGlvblggPSAwO1xuICAgICAgdGhpcy50cmFuc2xhdGlvblkgPSAwO1xuICAgIH1cbiAgICB1cGRhdGVNYXRyaXgobWF0cml4KSB7XG4gICAgICBzdXBlci51cGRhdGVNYXRyaXgobWF0cml4KTtcbiAgICAgIGNvbnN0IHsgdHJhbnNsYXRpb25YLCB0cmFuc2xhdGlvblkgfSA9IHRoaXM7XG4gICAgICBpZiAodHJhbnNsYXRpb25YID09PSAwICYmIHRyYW5zbGF0aW9uWSA9PT0gMClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgTWF0cml4LnVwZGF0ZVRyYW5zZm9ybU1hdHJpeCh0aGlzW1RSQU5TTEFUQUJMRV9NQVRSSVhdLCAxLCAxLCAwLCB0cmFuc2xhdGlvblgsIHRyYW5zbGF0aW9uWSk7XG4gICAgICBtYXRyaXgubXVsdGlwbHlTZWxmKHRoaXNbVFJBTlNMQVRBQkxFX01BVFJJWF0pO1xuICAgIH1cbiAgfVxuICBfYSA9IFRSQU5TTEFUQUJMRV9NQVRSSVg7XG4gIF9fZGVjb3JhdGVDbGFzcyhbXG4gICAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyB0eXBlOiBcInRyYW5zZm9ybVwiIH0pXG4gIF0sIFRyYW5zbGF0YWJsZUludGVybmFsLnByb3RvdHlwZSwgXCJ0cmFuc2xhdGlvblhcIiwgMik7XG4gIF9fZGVjb3JhdGVDbGFzcyhbXG4gICAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyB0eXBlOiBcInRyYW5zZm9ybVwiIH0pXG4gIF0sIFRyYW5zbGF0YWJsZUludGVybmFsLnByb3RvdHlwZSwgXCJ0cmFuc2xhdGlvbllcIiwgMik7XG4gIHJldHVybiBUcmFuc2xhdGFibGVJbnRlcm5hbDtcbn1cbnZhciBUcmFuc2Zvcm1hYmxlID0gY2xhc3Mge1xuICAvKipcbiAgICogQ29udmVydHMgYSBCQm94IGZyb20gY2FudmFzIGNvb3JkaW5hdGUgc3BhY2UgaW50byB0aGUgY29vcmRpbmF0ZSBzcGFjZSBvZiB0aGUgZ2l2ZW4gTm9kZS5cbiAgICovXG4gIHN0YXRpYyBmcm9tQ2FudmFzKG5vZGUsIGJib3gpIHtcbiAgICBjb25zdCBwYXJlbnRzID0gW107XG4gICAgZm9yIChjb25zdCBwYXJlbnQgb2Ygbm9kZS50cmF2ZXJzZVVwKCkpIHtcbiAgICAgIGlmIChpc01hdHJpeFRyYW5zZm9ybShwYXJlbnQpKSB7XG4gICAgICAgIHBhcmVudHMudW5zaGlmdChwYXJlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IHBhcmVudCBvZiBwYXJlbnRzKSB7XG4gICAgICBiYm94ID0gcGFyZW50LmZyb21QYXJlbnQoYmJveCk7XG4gICAgfVxuICAgIGlmIChpc01hdHJpeFRyYW5zZm9ybShub2RlKSkge1xuICAgICAgYmJveCA9IG5vZGUuZnJvbVBhcmVudChiYm94KTtcbiAgICB9XG4gICAgcmV0dXJuIGJib3g7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgTm9kZXMgQkJveCAob3IgYW4gYXJiaXRyYXJ5IEJCb3ggaWYgc3VwcGxpZWQpIGZyb20gbG9jYWwgTm9kZSBjb29yZGluYXRlIHNwYWNlXG4gICAqIGludG8gdGhlIENhbnZhcyBjb29yZGluYXRlIHNwYWNlLlxuICAgKi9cbiAgc3RhdGljIHRvQ2FudmFzKG5vZGUsIGJib3gpIHtcbiAgICBpZiAoYmJveCA9PSBudWxsKSB7XG4gICAgICBiYm94ID0gbm9kZS5nZXRCQm94KCk7XG4gICAgfSBlbHNlIGlmIChpc01hdHJpeFRyYW5zZm9ybShub2RlKSkge1xuICAgICAgYmJveCA9IG5vZGUudG9QYXJlbnQoYmJveCk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgcGFyZW50IG9mIG5vZGUudHJhdmVyc2VVcCgpKSB7XG4gICAgICBpZiAoaXNNYXRyaXhUcmFuc2Zvcm0ocGFyZW50KSkge1xuICAgICAgICBiYm94ID0gcGFyZW50LnRvUGFyZW50KGJib3gpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYmJveDtcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgYSBwb2ludCBmcm9tIGNhbnZhcyBjb29yZGluYXRlIHNwYWNlIGludG8gdGhlIGNvb3JkaW5hdGUgc3BhY2Ugb2YgdGhlIGdpdmVuIE5vZGUuXG4gICAqL1xuICBzdGF0aWMgZnJvbUNhbnZhc1BvaW50KG5vZGUsIHgsIHkpIHtcbiAgICBjb25zdCBwYXJlbnRzID0gW107XG4gICAgZm9yIChjb25zdCBwYXJlbnQgb2Ygbm9kZS50cmF2ZXJzZVVwKCkpIHtcbiAgICAgIGlmIChpc01hdHJpeFRyYW5zZm9ybShwYXJlbnQpKSB7XG4gICAgICAgIHBhcmVudHMudW5zaGlmdChwYXJlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IHBhcmVudCBvZiBwYXJlbnRzKSB7XG4gICAgICAoeyB4LCB5IH0gPSBwYXJlbnQuZnJvbVBhcmVudFBvaW50KHgsIHkpKTtcbiAgICB9XG4gICAgaWYgKGlzTWF0cml4VHJhbnNmb3JtKG5vZGUpKSB7XG4gICAgICAoeyB4LCB5IH0gPSBub2RlLmZyb21QYXJlbnRQb2ludCh4LCB5KSk7XG4gICAgfVxuICAgIHJldHVybiB7IHgsIHkgfTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgYSBwb2ludCBmcm9tIGEgTm9kZXMgbG9jYWwgY29vcmRpbmF0ZSBzcGFjZSBpbnRvIHRoZSBDYW52YXMgY29vcmRpbmF0ZSBzcGFjZS5cbiAgICovXG4gIHN0YXRpYyB0b0NhbnZhc1BvaW50KG5vZGUsIHgsIHkpIHtcbiAgICBpZiAoaXNNYXRyaXhUcmFuc2Zvcm0obm9kZSkpIHtcbiAgICAgICh7IHgsIHkgfSA9IG5vZGUudG9QYXJlbnRQb2ludCh4LCB5KSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgcGFyZW50IG9mIG5vZGUudHJhdmVyc2VVcCgpKSB7XG4gICAgICBpZiAoaXNNYXRyaXhUcmFuc2Zvcm0ocGFyZW50KSkge1xuICAgICAgICAoeyB4LCB5IH0gPSBwYXJlbnQudG9QYXJlbnRQb2ludCh4LCB5KSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHgsIHkgfTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvZ3JvdXAudHNcbnZhciBfR3JvdXAgPSBjbGFzcyBfR3JvdXAgZXh0ZW5kcyBOb2RlIHtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHN1cGVyKG9wdHMpO1xuICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgdGhpcy5vcGFjaXR5ID0gMTtcbiAgICB0aGlzLmlzQ29udGFpbmVyTm9kZSA9IHRydWU7XG4gICAgdGhpcy56SW5kZXhTdWJPcmRlciA9IG9wdHM/LnpJbmRleFN1Yk9yZGVyO1xuICB9XG4gIHN0YXRpYyBpcyh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIF9Hcm91cDtcbiAgfVxuICBzdGF0aWMgY29tcHV0ZUNoaWxkcmVuQkJveChub2Rlcywgc2tpcEludmlzaWJsZSA9IHRydWUpIHtcbiAgICByZXR1cm4gQkJveC5tZXJnZShOb2RlLmV4dHJhY3RCQm94ZXMobm9kZXMsIHNraXBJbnZpc2libGUpKTtcbiAgfVxuICBzdGF0aWMgY29tcGFyZUNoaWxkcmVuKGEsIGIpIHtcbiAgICByZXR1cm4gY29tcG91bmRBc2NlbmRpbmcoXG4gICAgICBbYS56SW5kZXgsIC4uLmEuekluZGV4U3ViT3JkZXIgPz8gW3ZvaWQgMCwgdm9pZCAwXSwgYS5zZXJpYWxOdW1iZXJdLFxuICAgICAgW2IuekluZGV4LCAuLi5iLnpJbmRleFN1Yk9yZGVyID8/IFt2b2lkIDAsIHZvaWQgMF0sIGIuc2VyaWFsTnVtYmVyXSxcbiAgICAgIGFzY2VuZGluZ1N0cmluZ051bWJlclVuZGVmaW5lZFxuICAgICk7XG4gIH1cbiAgLy8gV2UgY29uc2lkZXIgYSBncm91cCB0byBiZSBib3VuZGxlc3MsIHRodXMgYW55IHBvaW50IGJlbG9uZ3MgdG8gaXQuXG4gIGNvbnRhaW5zUG9pbnQoX3gsIF95KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29tcHV0ZUJCb3goKSB7XG4gICAgcmV0dXJuIF9Hcm91cC5jb21wdXRlQ2hpbGRyZW5CQm94KHRoaXMuY2hpbGRyZW4oKSk7XG4gIH1cbiAgcHJlUmVuZGVyKCkge1xuICAgIGNvbnN0IGNvdW50cyA9IHN1cGVyLnByZVJlbmRlcigpO1xuICAgIGNvdW50cy5ncm91cHMgKz0gMTtcbiAgICBjb3VudHMubm9uR3JvdXBzIC09IDE7XG4gICAgcmV0dXJuIGNvdW50cztcbiAgfVxuICBpc0RpcnR5KHJlbmRlckN0eCkge1xuICAgIGNvbnN0IHsgcmVzaXplZCB9ID0gcmVuZGVyQ3R4O1xuICAgIGNvbnN0IHsgZGlydHksIGRpcnR5WkluZGV4IH0gPSB0aGlzO1xuICAgIGNvbnN0IGlzRGlydHkgPSBkaXJ0eSA+PSAyIC8qIE1JTk9SICovIHx8IGRpcnR5WkluZGV4IHx8IHJlc2l6ZWQ7XG4gICAgbGV0IGlzQ2hpbGREaXJ0eSA9IGlzRGlydHk7XG4gICAgbGV0IGlzQ2hpbGRMYXllckRpcnR5ID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKCkpIHtcbiAgICAgIGlzQ2hpbGREaXJ0eSB8fCAoaXNDaGlsZERpcnR5ID0gY2hpbGQubGF5ZXJNYW5hZ2VyID09IG51bGwgJiYgY2hpbGQuZGlydHkgPj0gMSAvKiBUUklWSUFMICovKTtcbiAgICAgIGlzQ2hpbGRMYXllckRpcnR5IHx8IChpc0NoaWxkTGF5ZXJEaXJ0eSA9IGNoaWxkLmxheWVyTWFuYWdlciAhPSBudWxsICYmIGNoaWxkLmRpcnR5ID49IDEgLyogVFJJVklBTCAqLyk7XG4gICAgICBpZiAoaXNDaGlsZERpcnR5KVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0cz8ubmFtZSkge1xuICAgICAgdGhpcy5fZGVidWc/Lih7IG5hbWU6IHRoaXMub3B0cy5uYW1lLCBncm91cDogdGhpcywgaXNEaXJ0eSwgaXNDaGlsZERpcnR5LCByZW5kZXJDdHggfSk7XG4gICAgfVxuICAgIHJldHVybiB7IGlzRGlydHksIGlzQ2hpbGREaXJ0eSwgaXNDaGlsZExheWVyRGlydHkgfTtcbiAgfVxuICBkZWJ1Z1NraXAocmVuZGVyQ3R4KSB7XG4gICAgaWYgKHJlbmRlckN0eC5zdGF0cyAmJiB0aGlzLm9wdHM/Lm5hbWUpIHtcbiAgICAgIHRoaXMuX2RlYnVnPy4oe1xuICAgICAgICBuYW1lOiB0aGlzLm9wdHMubmFtZSxcbiAgICAgICAgZ3JvdXA6IHRoaXMsXG4gICAgICAgIHJlc3VsdDogXCJza2lwcGluZ1wiLFxuICAgICAgICBjb3VudHM6IG5vZGVDb3VudCh0aGlzKSxcbiAgICAgICAgcmVuZGVyQ3R4XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmVuZGVyKHJlbmRlckN0eCwgc2tpcCkge1xuICAgIGlmIChza2lwKSB7XG4gICAgICByZXR1cm4gc3VwZXIucmVuZGVyKHJlbmRlckN0eCk7XG4gICAgfVxuICAgIGNvbnN0IHsgb3B0czogeyBuYW1lIH0gPSB7fSwgX2RlYnVnOiBkZWJ1ZzMgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBpc0RpcnR5LCBpc0NoaWxkRGlydHksIGlzQ2hpbGRMYXllckRpcnR5IH0gPSB0aGlzLmlzRGlydHkocmVuZGVyQ3R4KTtcbiAgICBjb25zdCB7IGN0eCwgc3RhdHMgfSA9IHJlbmRlckN0eDtcbiAgICBsZXQgeyBmb3JjZVJlbmRlciB9ID0gcmVuZGVyQ3R4O1xuICAgIGlmICghaXNEaXJ0eSAmJiAhaXNDaGlsZERpcnR5ICYmICFpc0NoaWxkTGF5ZXJEaXJ0eSAmJiAhZm9yY2VSZW5kZXIpIHtcbiAgICAgIHRoaXMuZGVidWdTa2lwKHJlbmRlckN0eCk7XG4gICAgICB0aGlzLm1hcmtDbGVhbih7IHJlY3Vyc2l2ZTogZmFsc2UgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChmb3JjZVJlbmRlciAhPT0gXCJkaXJ0eVRyYW5zZm9ybVwiKSB7XG4gICAgICBmb3JjZVJlbmRlciB8fCAoZm9yY2VSZW5kZXIgPSB0aGlzLmRpcnR5WkluZGV4KTtcbiAgICB9XG4gICAgY3R4Lmdsb2JhbEFscGhhICo9IHRoaXMub3BhY2l0eTtcbiAgICBpZiAodGhpcy5kaXJ0eVpJbmRleCkge1xuICAgICAgdGhpcy5zb3J0Q2hpbGRyZW4oX0dyb3VwLmNvbXBhcmVDaGlsZHJlbik7XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5zb3J0ZWRDaGlsZHJlbigpO1xuICAgIGNvbnN0IGNsaXBCQm94ID0gdGhpcy5yZW5kZXJDbGlwKHJlbmRlckN0eCkgPz8gcmVuZGVyQ3R4LmNsaXBCQm94O1xuICAgIGNvbnN0IHJlbmRlckN0eENoYW5nZWQgPSBmb3JjZVJlbmRlciAhPT0gcmVuZGVyQ3R4LmZvcmNlUmVuZGVyIHx8IGNsaXBCQm94ICE9PSByZW5kZXJDdHguY2xpcEJCb3g7XG4gICAgdGhpcy5yZW5kZXJDaGlsZHJlbihjaGlsZHJlbiwgcmVuZGVyQ3R4Q2hhbmdlZCA/IHsgLi4ucmVuZGVyQ3R4LCBmb3JjZVJlbmRlciwgY2xpcEJCb3ggfSA6IHJlbmRlckN0eCk7XG4gICAgc3VwZXIucmVuZGVyKHJlbmRlckN0eCk7XG4gICAgaWYgKHRoaXMuY2xpcFJlY3QpIHtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy52aXJ0dWFsQ2hpbGRyZW4oKSkge1xuICAgICAgY2hpbGQubWFya0NsZWFuKHsgcmVjdXJzaXZlOiBcInZpcnR1YWxcIiB9KTtcbiAgICB9XG4gICAgaWYgKG5hbWUgJiYgc3RhdHMpIHtcbiAgICAgIGRlYnVnMz8uKHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgcmVuZGVyQ3R4LFxuICAgICAgICByZXN1bHQ6IFwicmVuZGVyZWRcIixcbiAgICAgICAgc2tpcHBlZDogc3RhdHMubm9kZXNTa2lwcGVkLFxuICAgICAgICBjb3VudHM6IG5vZGVDb3VudCh0aGlzKSxcbiAgICAgICAgZ3JvdXA6IHRoaXNcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBzb3J0ZWRDaGlsZHJlbigpIHtcbiAgICBsZXQgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuKCk7XG4gICAgaWYgKHRoaXMuaGFzVmlydHVhbENoaWxkcmVuKCkpIHtcbiAgICAgIGNoaWxkcmVuID0gWy4uLmNoaWxkcmVuXS5zb3J0KF9Hcm91cC5jb21wYXJlQ2hpbGRyZW4pO1xuICAgIH1cbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgcmVuZGVyQ2xpcChyZW5kZXJDdHgpIHtcbiAgICBpZiAoIXRoaXMuY2xpcFJlY3QpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyB4LCB5LCB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIgfSA9IHRoaXMuY2xpcFJlY3Q7XG4gICAgY29uc3QgeyBjdHggfSA9IHJlbmRlckN0eDtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgucmVjdCh4LCB5LCB3aWR0aDIsIGhlaWdodDIpO1xuICAgIGN0eC5jbGlwKCk7XG4gICAgdGhpcy5fZGVidWc/LigoKSA9PiAoe1xuICAgICAgbmFtZTogdGhpcy5vcHRzPy5uYW1lLFxuICAgICAgY2xpcFJlY3Q6IHRoaXMuY2xpcFJlY3QsXG4gICAgICBjdHhUcmFuc2Zvcm06IGN0eC5nZXRUcmFuc2Zvcm0oKSxcbiAgICAgIHJlbmRlckN0eCxcbiAgICAgIGdyb3VwOiB0aGlzXG4gICAgfSkpO1xuICAgIHJldHVybiBUcmFuc2Zvcm1hYmxlLnRvQ2FudmFzKHRoaXMsIHRoaXMuY2xpcFJlY3QpO1xuICB9XG4gIHJlbmRlckNoaWxkcmVuKGNoaWxkcmVuLCByZW5kZXJDdHgpIHtcbiAgICBjb25zdCB7IGN0eCwgZm9yY2VSZW5kZXIsIHN0YXRzIH0gPSByZW5kZXJDdHg7XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgICAgaWYgKCFjaGlsZC52aXNpYmxlIHx8ICF0aGlzLnZpc2libGUpIHtcbiAgICAgICAgY2hpbGQubWFya0NsZWFuKCk7XG4gICAgICAgIGlmIChzdGF0cykge1xuICAgICAgICAgIHN0YXRzLm5vZGVzU2tpcHBlZCArPSBub2RlQ291bnQoY2hpbGQpLmNvdW50O1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFmb3JjZVJlbmRlciAmJiBjaGlsZC5kaXJ0eSA9PT0gMCAvKiBOT05FICovKSB7XG4gICAgICAgIGlmIChzdGF0cykge1xuICAgICAgICAgIHN0YXRzLm5vZGVzU2tpcHBlZCArPSBub2RlQ291bnQoY2hpbGQpLmNvdW50O1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGNoaWxkLnJlbmRlcihyZW5kZXJDdHgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRyYW5zZm9ybXMgYmJveCBnaXZlbiBpbiB0aGUgY2FudmFzIGNvb3JkaW5hdGUgc3BhY2UgdG8gYmJveCBpbiB0aGlzIGdyb3VwJ3MgY29vcmRpbmF0ZSBzcGFjZSBhbmRcbiAgICogc2V0cyB0aGlzIGdyb3VwJ3MgY2xpcFJlY3QgdG8gdGhlIHRyYW5zZm9ybWVkIGJib3guXG4gICAqIEBwYXJhbSBiYm94IGNsaXBSZWN0IGJib3ggaW4gdGhlIGNhbnZhcyBjb29yZGluYXRlIHNwYWNlLlxuICAgKi9cbiAgc2V0Q2xpcFJlY3QoYmJveCkge1xuICAgIHRoaXMuY2xpcFJlY3QgPSBiYm94ID8gVHJhbnNmb3JtYWJsZS5mcm9tQ2FudmFzKHRoaXMsIGJib3gpIDogdm9pZCAwO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgdGhlIGNsaXAgcmVjdCB3aXRoaW4gdGhlIGNhbnZhcyBjb29yZGluYXRlIHNwYWNlLlxuICAgKiBAcGFyYW0gYmJveCBjbGlwUmVjdCBiYm94IGluIHRoZSBjYW52YXMgY29vcmRpbmF0ZSBzcGFjZS5cbiAgICovXG4gIHNldENsaXBSZWN0Q2FudmFzU3BhY2UoYmJveCkge1xuICAgIHRoaXMuY2xpcFJlY3QgPSBiYm94O1xuICB9XG4gIHRvU1ZHKCkge1xuICAgIGlmICghdGhpcy52aXNpYmxlKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGRlZnMgPSBbXTtcbiAgICBjb25zdCBlbGVtZW50czIgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuc29ydGVkQ2hpbGRyZW4oKSkge1xuICAgICAgY29uc3Qgc3ZnID0gY2hpbGQudG9TVkcoKTtcbiAgICAgIGlmIChzdmcgIT0gbnVsbCkge1xuICAgICAgICBlbGVtZW50czIucHVzaCguLi5zdmcuZWxlbWVudHMpO1xuICAgICAgICBpZiAoc3ZnLmRlZnMgIT0gbnVsbCkge1xuICAgICAgICAgIGRlZnMucHVzaCguLi5zdmcuZGVmcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgZWxlbWVudHM6IGVsZW1lbnRzMiwgZGVmcyB9O1xuICB9XG59O1xuX0dyb3VwLmNsYXNzTmFtZSA9IFwiR3JvdXBcIjtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHtcbiAgICByZWRyYXc6IDMgLyogTUFKT1IgKi8sXG4gICAgY29udmVydG9yOiAodikgPT4gY2xhbXAoMCwgdiwgMSlcbiAgfSlcbl0sIF9Hcm91cC5wcm90b3R5cGUsIFwib3BhY2l0eVwiLCAyKTtcbnZhciBHcm91cCA9IF9Hcm91cDtcbnZhciBTY2FsYWJsZUdyb3VwID0gY2xhc3MgZXh0ZW5kcyBTY2FsYWJsZShHcm91cCkge1xufTtcbnZhciBSb3RhdGFibGVHcm91cCA9IGNsYXNzIGV4dGVuZHMgUm90YXRhYmxlKEdyb3VwKSB7XG59O1xudmFyIFRyYW5zbGF0YWJsZUdyb3VwID0gY2xhc3MgZXh0ZW5kcyBUcmFuc2xhdGFibGUoR3JvdXApIHtcbn07XG52YXIgVHJhbnNmb3JtYWJsZUdyb3VwID0gY2xhc3MgZXh0ZW5kcyBSb3RhdGFibGUoVHJhbnNsYXRhYmxlKEdyb3VwKSkge1xufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9kZWJ1Zy50c1xudmFyIExPTkdfVElNRV9QRVJJT0RfVEhSRVNIT0xEID0gMmUzO1xudmFyIHRpbWVPZkxhc3RMb2cgPSBEYXRlLm5vdygpO1xudmFyIGxvZ1RpbWVHYXAgPSAoKSA9PiB7XG4gIGNvbnN0IHRpbWVTaW5jZUxhc3RMb2cgPSBEYXRlLm5vdygpIC0gdGltZU9mTGFzdExvZztcbiAgaWYgKHRpbWVTaW5jZUxhc3RMb2cgPiBMT05HX1RJTUVfUEVSSU9EX1RIUkVTSE9MRCkge1xuICAgIGNvbnN0IHByZXR0eUR1cmF0aW9uID0gKE1hdGguZmxvb3IodGltZVNpbmNlTGFzdExvZyAvIDEwMCkgLyAxMCkudG9GaXhlZCgxKTtcbiAgICBMb2dnZXIubG9nKGAqKioqICR7cHJldHR5RHVyYXRpb259cyBzaW5jZSBsYXN0IGxvZyBtZXNzYWdlICoqKipgKTtcbiAgfVxuICB0aW1lT2ZMYXN0TG9nID0gRGF0ZS5ub3coKTtcbn07XG52YXIgRGVidWcgPSB7XG4gIGNyZWF0ZSguLi5kZWJ1Z1NlbGVjdG9ycykge1xuICAgIGNvbnN0IHJlc3VsdEZuID0gKC4uLmxvZ0NvbnRlbnQpID0+IHtcbiAgICAgIGlmIChEZWJ1Zy5jaGVjayguLi5kZWJ1Z1NlbGVjdG9ycykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsb2dDb250ZW50WzBdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBsb2dDb250ZW50ID0gdG9BcnJheShsb2dDb250ZW50WzBdKCkpO1xuICAgICAgICB9XG4gICAgICAgIGxvZ1RpbWVHYXAoKTtcbiAgICAgICAgTG9nZ2VyLmxvZyguLi5sb2dDb250ZW50KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHJlc3VsdEZuLCB7IGNoZWNrOiAoKSA9PiBEZWJ1Zy5jaGVjayguLi5kZWJ1Z1NlbGVjdG9ycykgfSk7XG4gIH0sXG4gIGNoZWNrKC4uLmRlYnVnU2VsZWN0b3JzKSB7XG4gICAgaWYgKGRlYnVnU2VsZWN0b3JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZGVidWdTZWxlY3RvcnMucHVzaCh0cnVlKTtcbiAgICB9XG4gICAgY29uc3QgY2hhcnREZWJ1ZyA9IHRvQXJyYXkoZ2V0V2luZG93KFwiYWdDaGFydHNEZWJ1Z1wiKSk7XG4gICAgcmV0dXJuIGNoYXJ0RGVidWcuc29tZSgoc2VsZWN0b3IpID0+IGRlYnVnU2VsZWN0b3JzLmluY2x1ZGVzKHNlbGVjdG9yKSk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL3NlbGVjdGlvbi50c1xudmFyIFNlbGVjdGlvbiA9IGNsYXNzIF9TZWxlY3Rpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJlbnROb2RlLCBjbGFzc09yRmFjdG9yeSwgYXV0b0NsZWFudXAgPSB0cnVlKSB7XG4gICAgdGhpcy5wYXJlbnROb2RlID0gcGFyZW50Tm9kZTtcbiAgICB0aGlzLmF1dG9DbGVhbnVwID0gYXV0b0NsZWFudXA7XG4gICAgdGhpcy5nYXJiYWdlQmluID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLl9ub2Rlc01hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5fbm9kZXMgPSBbXTtcbiAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICB0aGlzLmRlYnVnID0gRGVidWcuY3JlYXRlKHRydWUsIFwic2NlbmVcIiwgXCJzY2VuZTpzZWxlY3Rpb25zXCIpO1xuICAgIHRoaXMubm9kZUZhY3RvcnkgPSBPYmplY3QucHJvdG90eXBlLmlzUHJvdG90eXBlT2YuY2FsbChOb2RlLCBjbGFzc09yRmFjdG9yeSkgPyAoKSA9PiBuZXcgY2xhc3NPckZhY3RvcnkoKSA6IGNsYXNzT3JGYWN0b3J5O1xuICB9XG4gIHN0YXRpYyBzZWxlY3QocGFyZW50LCBjbGFzc09yRmFjdG9yeSwgZ2FyYmFnZUNvbGxlY3Rpb24gPSB0cnVlKSB7XG4gICAgcmV0dXJuIG5ldyBfU2VsZWN0aW9uKHBhcmVudCwgY2xhc3NPckZhY3RvcnksIGdhcmJhZ2VDb2xsZWN0aW9uKTtcbiAgfVxuICBzdGF0aWMgc2VsZWN0QWxsKHBhcmVudCwgcHJlZGljYXRlKSB7XG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgIGNvbnN0IHRyYXZlcnNlID0gKG5vZGUpID0+IHtcbiAgICAgIGlmIChwcmVkaWNhdGUobm9kZSkpIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBub2RlLmNoaWxkcmVuKCkpIHtcbiAgICAgICAgdHJhdmVyc2UoY2hpbGQpO1xuICAgICAgfVxuICAgIH07XG4gICAgdHJhdmVyc2UocGFyZW50KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuICBzdGF0aWMgc2VsZWN0QnlDbGFzcyhub2RlLCAuLi5DbGFzc2VzKSB7XG4gICAgcmV0dXJuIF9TZWxlY3Rpb24uc2VsZWN0QWxsKG5vZGUsIChuKSA9PiBDbGFzc2VzLnNvbWUoKEMpID0+IG4gaW5zdGFuY2VvZiBDKSk7XG4gIH1cbiAgc3RhdGljIHNlbGVjdEJ5VGFnKG5vZGUsIHRhZykge1xuICAgIHJldHVybiBfU2VsZWN0aW9uLnNlbGVjdEFsbChub2RlLCAobikgPT4gbi50YWcgPT09IHRhZyk7XG4gIH1cbiAgY3JlYXRlTm9kZShkYXR1bSwgaW5pdGlhbGl6ZXIsIGlkeCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLm5vZGVGYWN0b3J5KGRhdHVtKTtcbiAgICBub2RlLmRhdHVtID0gZGF0dW07XG4gICAgaW5pdGlhbGl6ZXI/Lihub2RlKTtcbiAgICBpZiAoaWR4ID09IG51bGwpIHtcbiAgICAgIHRoaXMuX25vZGVzLnB1c2gobm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX25vZGVzLnNwbGljZShpZHgsIDAsIG5vZGUpO1xuICAgIH1cbiAgICB0aGlzLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgZGF0YSBpbiBhIHNlbGVjdGlvbi4gSWYgYW4gYGdldERhdHVtSWQoKWAgZnVuY3Rpb24gaXMgcHJvdmlkZWQsIG1haW50YWluIGEgbGlzdCBvZiBpZHMgcmVsYXRlZCB0b1xuICAgKiB0aGUgbm9kZXMuIE90aGVyd2lzZSwgdGFrZSB0aGUgbW9yZSBlZmZpY2llbnQgcm91dGUgb2Ygc2ltcGx5IGNyZWF0aW5nIGFuZCBkZXN0cm95aW5nIG5vZGVzIGF0IHRoZSBlbmRcbiAgICogb2YgdGhlIGFycmF5LlxuICAgKi9cbiAgdXBkYXRlKGRhdGEsIGluaXRpYWxpemVyLCBnZXREYXR1bUlkKSB7XG4gICAgaWYgKHRoaXMuZ2FyYmFnZUJpbi5zaXplID4gMCkge1xuICAgICAgdGhpcy5kZWJ1ZyhgU2VsZWN0aW9uIC0gdXBkYXRlKCkgY2FsbGVkIHdpdGggcGVuZGluZyBnYXJiYWdlOiAke2RhdGF9YCk7XG4gICAgfVxuICAgIGlmIChnZXREYXR1bUlkKSB7XG4gICAgICBjb25zdCBkYXRhTWFwID0gbmV3IE1hcChcbiAgICAgICAgZGF0YS5tYXAoKGRhdHVtLCBpZHgpID0+IFtnZXREYXR1bUlkKGRhdHVtKSwgW2RhdHVtLCBpZHhdXSlcbiAgICAgICk7XG4gICAgICBmb3IgKGNvbnN0IFtub2RlLCBkYXR1bUlkXSBvZiB0aGlzLl9ub2Rlc01hcC5lbnRyaWVzKCkpIHtcbiAgICAgICAgaWYgKGRhdGFNYXAuaGFzKGRhdHVtSWQpKSB7XG4gICAgICAgICAgY29uc3QgW25ld0RhdHVtXSA9IGRhdGFNYXAuZ2V0KGRhdHVtSWQpO1xuICAgICAgICAgIG5vZGUuZGF0dW0gPSBuZXdEYXR1bTtcbiAgICAgICAgICB0aGlzLmdhcmJhZ2VCaW4uZGVsZXRlKG5vZGUpO1xuICAgICAgICAgIGRhdGFNYXAuZGVsZXRlKGRhdHVtSWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZ2FyYmFnZUJpbi5hZGQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgW2RhdHVtSWQsIFtkYXR1bSwgaWR4XV0gb2YgZGF0YU1hcC5lbnRyaWVzKCkpIHtcbiAgICAgICAgdGhpcy5fbm9kZXNNYXAuc2V0KHRoaXMuY3JlYXRlTm9kZShkYXR1bSwgaW5pdGlhbGl6ZXIsIGlkeCksIGRhdHVtSWQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtYXhMZW5ndGggPSBNYXRoLm1heChkYXRhLmxlbmd0aCwgdGhpcy5kYXRhLmxlbmd0aCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heExlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpID49IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5nYXJiYWdlQmluLmFkZCh0aGlzLl9ub2Rlc1tpXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaSA+PSB0aGlzLl9ub2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLmNyZWF0ZU5vZGUoZGF0YVtpXSwgaW5pdGlhbGl6ZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX25vZGVzW2ldLmRhdHVtID0gZGF0YVtpXTtcbiAgICAgICAgICB0aGlzLmdhcmJhZ2VCaW4uZGVsZXRlKHRoaXMuX25vZGVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmRhdGEgPSBkYXRhLnNsaWNlKCk7XG4gICAgaWYgKHRoaXMuYXV0b0NsZWFudXApIHtcbiAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjbGVhbnVwKCkge1xuICAgIGlmICh0aGlzLmdhcmJhZ2VCaW4uc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRoaXMuX25vZGVzID0gdGhpcy5fbm9kZXMuZmlsdGVyKChub2RlKSA9PiB7XG4gICAgICBpZiAodGhpcy5nYXJiYWdlQmluLmhhcyhub2RlKSkge1xuICAgICAgICB0aGlzLl9ub2Rlc01hcC5kZWxldGUobm9kZSk7XG4gICAgICAgIHRoaXMuZ2FyYmFnZUJpbi5kZWxldGUobm9kZSk7XG4gICAgICAgIG5vZGUuZGVzdHJveSgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLnVwZGF0ZShbXSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaXNHYXJiYWdlKG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5nYXJiYWdlQmluLmhhcyhub2RlKTtcbiAgfVxuICBoYXNHYXJiYWdlKCkge1xuICAgIHJldHVybiB0aGlzLmdhcmJhZ2VCaW4uc2l6ZSA+IDA7XG4gIH1cbiAgZWFjaChpdGVyYXRlMikge1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgdGhpcy5fbm9kZXMuZW50cmllcygpKSB7XG4gICAgICBpdGVyYXRlMihlbnRyeVsxXSwgZW50cnlbMV0uZGF0dW0sIGVudHJ5WzBdKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLl9ub2Rlcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLl9ub2Rlc1tpbmRleF07XG4gICAgICB5aWVsZCB7IG5vZGUsIGRhdHVtOiBub2RlLmRhdHVtLCBpbmRleCB9O1xuICAgIH1cbiAgfVxuICBzZWxlY3QocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIF9TZWxlY3Rpb24uc2VsZWN0QWxsKHRoaXMucGFyZW50Tm9kZSwgcHJlZGljYXRlKTtcbiAgfVxuICBzZWxlY3RCeUNsYXNzKENsYXNzKSB7XG4gICAgcmV0dXJuIF9TZWxlY3Rpb24uc2VsZWN0QnlDbGFzcyh0aGlzLnBhcmVudE5vZGUsIENsYXNzKTtcbiAgfVxuICBzZWxlY3RCeVRhZyh0YWcpIHtcbiAgICByZXR1cm4gX1NlbGVjdGlvbi5zZWxlY3RCeVRhZyh0aGlzLnBhcmVudE5vZGUsIHRhZyk7XG4gIH1cbiAgbm9kZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25vZGVzO1xuICB9XG4gIGF0KGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX25vZGVzLmF0KGluZGV4KTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9hbmdsZS50c1xudmFyIHR3b1BpID0gTWF0aC5QSSAqIDI7XG5mdW5jdGlvbiBub3JtYWxpemVBbmdsZTM2MChyYWRpYW5zKSB7XG4gIHJhZGlhbnMgJT0gdHdvUGk7XG4gIHJhZGlhbnMgKz0gdHdvUGk7XG4gIHJhZGlhbnMgJT0gdHdvUGk7XG4gIHJldHVybiByYWRpYW5zO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplQW5nbGUzNjBJbmNsdXNpdmUocmFkaWFucykge1xuICByYWRpYW5zICU9IHR3b1BpO1xuICByYWRpYW5zICs9IHR3b1BpO1xuICBpZiAocmFkaWFucyAhPT0gdHdvUGkpIHtcbiAgICByYWRpYW5zICU9IHR3b1BpO1xuICB9XG4gIHJldHVybiByYWRpYW5zO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplQW5nbGUxODAocmFkaWFucykge1xuICByYWRpYW5zICU9IHR3b1BpO1xuICBpZiAocmFkaWFucyA8IC1NYXRoLlBJKSB7XG4gICAgcmFkaWFucyArPSB0d29QaTtcbiAgfSBlbHNlIGlmIChyYWRpYW5zID49IE1hdGguUEkpIHtcbiAgICByYWRpYW5zIC09IHR3b1BpO1xuICB9XG4gIHJldHVybiByYWRpYW5zO1xufVxuZnVuY3Rpb24gaXNCZXR3ZWVuQW5nbGVzKHRhcmdldEFuZ2xlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSkge1xuICBjb25zdCB0ID0gbm9ybWFsaXplQW5nbGUzNjAodGFyZ2V0QW5nbGUpO1xuICBjb25zdCBhMCA9IG5vcm1hbGl6ZUFuZ2xlMzYwKHN0YXJ0QW5nbGUpO1xuICBjb25zdCBhMSA9IG5vcm1hbGl6ZUFuZ2xlMzYwKGVuZEFuZ2xlKTtcbiAgaWYgKGEwIDwgYTEpIHtcbiAgICByZXR1cm4gYTAgPD0gdCAmJiB0IDw9IGExO1xuICB9IGVsc2UgaWYgKGEwID4gYTEpIHtcbiAgICByZXR1cm4gYTAgPD0gdCB8fCB0IDw9IGExO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5mdW5jdGlvbiB0b1JhZGlhbnMoZGVncmVlcykge1xuICByZXR1cm4gZGVncmVlcyAvIDE4MCAqIE1hdGguUEk7XG59XG5mdW5jdGlvbiB0b0RlZ3JlZXMocmFkaWFucykge1xuICByZXR1cm4gcmFkaWFucyAvIE1hdGguUEkgKiAxODA7XG59XG5mdW5jdGlvbiBhbmdsZURpZmYoYW5nbGUwLCBhbmdsZTEsIGNvdW50ZXJDbG9ja3dpc2UpIHtcbiAgaWYgKGNvdW50ZXJDbG9ja3dpc2UpIHtcbiAgICBbYW5nbGUwLCBhbmdsZTFdID0gW2FuZ2xlMSwgYW5nbGUwXTtcbiAgfVxuICBjb25zdCBhMCA9IG5vcm1hbGl6ZUFuZ2xlMzYwKGFuZ2xlMCk7XG4gIGNvbnN0IGExID0gbm9ybWFsaXplQW5nbGUzNjAoYW5nbGUxKSArIHR3b1BpO1xuICByZXR1cm4gKGExIC0gYTApICUgdHdvUGk7XG59XG5mdW5jdGlvbiBhbmdsZUJldHdlZW4oYW5nbGUwLCBhbmdsZTEpIHtcbiAgYW5nbGUwID0gbm9ybWFsaXplQW5nbGUzNjAoYW5nbGUwKTtcbiAgYW5nbGUxID0gbm9ybWFsaXplQW5nbGUzNjAoYW5nbGUxKTtcbiAgcmV0dXJuIGFuZ2xlMSAtIGFuZ2xlMCArIChhbmdsZTAgPiBhbmdsZTEgPyAyICogTWF0aC5QSSA6IDApO1xufVxuZnVuY3Rpb24gZGlzcGxhY2VQb2ludEZyb21WZWN0b3IoY2VudGVyWCwgY2VudGVyWSwgcmFkaXVzLCBhbmdsZTIpIHtcbiAgY29uc3QgeCA9IGNlbnRlclggKyByYWRpdXMgKiBNYXRoLmNvcyhhbmdsZTIpO1xuICBjb25zdCB5ID0gY2VudGVyWSArIHJhZGl1cyAqIE1hdGguc2luKGFuZ2xlMik7XG4gIHJldHVybiB7IHgsIHkgfTtcbn1cbnZhciBkZWx0YSA9IDFlLTY7XG5mdW5jdGlvbiBjbG9ja3dpc2VBbmdsZShhbmdsZTIsIHJlbGF0aXZlVG9TdGFydEFuZ2xlKSB7XG4gIGlmIChhbmdsZUJldHdlZW4oYW5nbGUyLCByZWxhdGl2ZVRvU3RhcnRBbmdsZSkgPCBkZWx0YSkge1xuICAgIHJldHVybiByZWxhdGl2ZVRvU3RhcnRBbmdsZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbm9ybWFsaXplQW5nbGUzNjAoYW5nbGUyIC0gcmVsYXRpdmVUb1N0YXJ0QW5nbGUpICsgcmVsYXRpdmVUb1N0YXJ0QW5nbGU7XG4gIH1cbn1cbmZ1bmN0aW9uIGNsb2Nrd2lzZUFuZ2xlcyhzdGFydEFuZ2xlLCBlbmRBbmdsZSwgcmVsYXRpdmVUb1N0YXJ0QW5nbGUgPSAwKSB7XG4gIGNvbnN0IGZ1bGxQaWUgPSBNYXRoLmFicyhlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpID49IDIgKiBNYXRoLlBJO1xuICBjb25zdCBzd2VlcEFuZ2xlID0gZnVsbFBpZSA/IDIgKiBNYXRoLlBJIDogbm9ybWFsaXplQW5nbGUzNjAoZW5kQW5nbGUgLSBzdGFydEFuZ2xlKTtcbiAgc3RhcnRBbmdsZSA9IGNsb2Nrd2lzZUFuZ2xlKHN0YXJ0QW5nbGUsIHJlbGF0aXZlVG9TdGFydEFuZ2xlKTtcbiAgZW5kQW5nbGUgPSBzdGFydEFuZ2xlICsgc3dlZXBBbmdsZTtcbiAgcmV0dXJuIHsgc3RhcnRBbmdsZSwgZW5kQW5nbGUgfTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9kaXN0YW5jZS50c1xuZnVuY3Rpb24gcG9pbnRzRGlzdGFuY2VTcXVhcmVkKHgxLCB5MSwgeDIsIHkyKSB7XG4gIGNvbnN0IGR4ID0geDEgLSB4MjtcbiAgY29uc3QgZHkgPSB5MSAtIHkyO1xuICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG59XG5mdW5jdGlvbiBsaW5lRGlzdGFuY2VTcXVhcmVkKHgsIHksIHgxLCB5MSwgeDIsIHkyLCBiZXN0KSB7XG4gIGlmICh4MSA9PT0geDIgJiYgeTEgPT09IHkyKSB7XG4gICAgcmV0dXJuIE1hdGgubWluKGJlc3QsIHBvaW50c0Rpc3RhbmNlU3F1YXJlZCh4LCB5LCB4MSwgeTEpKTtcbiAgfVxuICBjb25zdCBkeCA9IHgyIC0geDE7XG4gIGNvbnN0IGR5ID0geTIgLSB5MTtcbiAgY29uc3QgdCA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsICgoeCAtIHgxKSAqIGR4ICsgKHkgLSB5MSkgKiBkeSkgLyAoZHggKiBkeCArIGR5ICogZHkpKSk7XG4gIGNvbnN0IGl4ID0geDEgKyB0ICogZHg7XG4gIGNvbnN0IGl5ID0geTEgKyB0ICogZHk7XG4gIHJldHVybiBNYXRoLm1pbihiZXN0LCBwb2ludHNEaXN0YW5jZVNxdWFyZWQoeCwgeSwgaXgsIGl5KSk7XG59XG5mdW5jdGlvbiBhcmNEaXN0YW5jZVNxdWFyZWQoeCwgeSwgY3gsIGN5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBjb3VudGVyQ2xvY2t3aXNlLCBiZXN0KSB7XG4gIGlmIChjb3VudGVyQ2xvY2t3aXNlKSB7XG4gICAgW2VuZEFuZ2xlLCBzdGFydEFuZ2xlXSA9IFtzdGFydEFuZ2xlLCBlbmRBbmdsZV07XG4gIH1cbiAgY29uc3QgYW5nbGUyID0gTWF0aC5hdGFuMih5IC0gY3ksIHggLSBjeCk7XG4gIGlmICghaXNCZXR3ZWVuQW5nbGVzKGFuZ2xlMiwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpKSB7XG4gICAgY29uc3Qgc3RhcnRYID0gY3ggKyBNYXRoLmNvcyhzdGFydEFuZ2xlKSAqIHJhZGl1cztcbiAgICBjb25zdCBzdGFydFkgPSBjeSArIE1hdGguc2luKHN0YXJ0QW5nbGUpICogcmFkaXVzO1xuICAgIGNvbnN0IGVuZFggPSBjeCArIE1hdGguY29zKHN0YXJ0QW5nbGUpICogcmFkaXVzO1xuICAgIGNvbnN0IGVuZFkgPSBjeSArIE1hdGguc2luKHN0YXJ0QW5nbGUpICogcmFkaXVzO1xuICAgIHJldHVybiBNYXRoLm1pbihiZXN0LCBwb2ludHNEaXN0YW5jZVNxdWFyZWQoeCwgeSwgc3RhcnRYLCBzdGFydFkpLCBwb2ludHNEaXN0YW5jZVNxdWFyZWQoeCwgeSwgZW5kWCwgZW5kWSkpO1xuICB9XG4gIGNvbnN0IGRpc3RUb0FyYyA9IHJhZGl1cyAtIE1hdGguc3FydChwb2ludHNEaXN0YW5jZVNxdWFyZWQoeCwgeSwgY3gsIGN5KSk7XG4gIHJldHVybiBNYXRoLm1pbihiZXN0LCBkaXN0VG9BcmMgKiBkaXN0VG9BcmMpO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2FsZS9jb2xvclNjYWxlLnRzXG52YXIgY29udmVydENvbG9yU3RyaW5nVG9Pa2xjaGEgPSAodikgPT4ge1xuICBjb25zdCBjb2xvciA9IENvbG9yLmZyb21TdHJpbmcodik7XG4gIGNvbnN0IFtsLCBjLCBoXSA9IENvbG9yLlJHQnRvT0tMQ0goY29sb3IuciwgY29sb3IuZywgY29sb3IuYik7XG4gIHJldHVybiB7IGwsIGMsIGgsIGE6IGNvbG9yLmEgfTtcbn07XG52YXIgZGVsdGEyID0gMWUtNjtcbnZhciBpc0FjaHJvbWF0aWMgPSAoeCkgPT4geC5jIDwgZGVsdGEyIHx8IHgubCA8IGRlbHRhMiB8fCB4LmwgPiAxIC0gZGVsdGEyO1xudmFyIGludGVycG9sYXRlT2tsY2ggPSAoeCwgeSwgZCkgPT4ge1xuICBkID0gY2xhbXAoMCwgZCwgMSk7XG4gIGxldCBoO1xuICBpZiAoaXNBY2hyb21hdGljKHgpKSB7XG4gICAgaCA9IHkuaDtcbiAgfSBlbHNlIGlmIChpc0FjaHJvbWF0aWMoeSkpIHtcbiAgICBoID0geC5oO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHhIID0geC5oO1xuICAgIGxldCB5SCA9IHkuaDtcbiAgICBjb25zdCBkZWx0YUggPSB5LmggLSB4Lmg7XG4gICAgaWYgKGRlbHRhSCA+IDE4MCkge1xuICAgICAgeUggLT0gMzYwO1xuICAgIH0gZWxzZSBpZiAoZGVsdGFIIDwgLTE4MCkge1xuICAgICAgeUggKz0gMzYwO1xuICAgIH1cbiAgICBoID0geEggKiAoMSAtIGQpICsgeUggKiBkO1xuICB9XG4gIGNvbnN0IGMgPSB4LmMgKiAoMSAtIGQpICsgeS5jICogZDtcbiAgY29uc3QgbCA9IHgubCAqICgxIC0gZCkgKyB5LmwgKiBkO1xuICBjb25zdCBhID0geC5hICogKDEgLSBkKSArIHkuYSAqIGQ7XG4gIHJldHVybiBDb2xvci5mcm9tT0tMQ0gobCwgYywgaCwgYSk7XG59O1xudmFyIENvbG9yU2NhbGUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMudHlwZSA9IFwiY29sb3JcIjtcbiAgICB0aGlzLmludmFsaWQgPSB0cnVlO1xuICAgIHRoaXMuZG9tYWluID0gWzAsIDFdO1xuICAgIHRoaXMucmFuZ2UgPSBbXCJyZWRcIiwgXCJibHVlXCJdO1xuICAgIHRoaXMucGFyc2VkUmFuZ2UgPSB0aGlzLnJhbmdlLm1hcChjb252ZXJ0Q29sb3JTdHJpbmdUb09rbGNoYSk7XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIGNvbnN0IHsgZG9tYWluLCByYW5nZTogcmFuZ2UzIH0gPSB0aGlzO1xuICAgIGlmIChkb21haW4ubGVuZ3RoIDwgMikge1xuICAgICAgTG9nZ2VyLndhcm5PbmNlKFwiYGNvbG9yRG9tYWluYCBzaG91bGQgaGF2ZSBhdCBsZWFzdCAyIHZhbHVlcy5cIik7XG4gICAgICBpZiAoZG9tYWluLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBkb21haW4ucHVzaCgwLCAxKTtcbiAgICAgIH0gZWxzZSBpZiAoZG9tYWluLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBkb21haW4ucHVzaChkb21haW5bMF0gKyAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBkb21haW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGEgPSBkb21haW5baSAtIDFdO1xuICAgICAgY29uc3QgYiA9IGRvbWFpbltpXTtcbiAgICAgIGlmIChhID49IGIpIHtcbiAgICAgICAgTG9nZ2VyLndhcm5PbmNlKFwiYGNvbG9yRG9tYWluYCB2YWx1ZXMgc2hvdWxkIGJlIHN1cHBsaWVkIGluIGFzY2VuZGluZyBvcmRlci5cIik7XG4gICAgICAgIGRvbWFpbi5zb3J0KChhMiwgYjIpID0+IGEyIC0gYjIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJhbmdlMy5sZW5ndGggPCBkb21haW4ubGVuZ3RoKSB7XG4gICAgICBmb3IgKGxldCBpID0gcmFuZ2UzLmxlbmd0aDsgaSA8IGRvbWFpbi5sZW5ndGg7IGkrKykge1xuICAgICAgICByYW5nZTMucHVzaChyYW5nZTMubGVuZ3RoID4gMCA/IHJhbmdlM1swXSA6IFwiYmxhY2tcIik7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucGFyc2VkUmFuZ2UgPSB0aGlzLnJhbmdlLm1hcChjb252ZXJ0Q29sb3JTdHJpbmdUb09rbGNoYSk7XG4gIH1cbiAgY29udmVydCh4KSB7XG4gICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgY29uc3QgeyBkb21haW4sIHJhbmdlOiByYW5nZTMsIHBhcnNlZFJhbmdlIH0gPSB0aGlzO1xuICAgIGNvbnN0IGQwID0gZG9tYWluWzBdO1xuICAgIGNvbnN0IGQxID0gZG9tYWluLmF0KC0xKTtcbiAgICBjb25zdCByMCA9IHJhbmdlM1swXTtcbiAgICBjb25zdCByMSA9IHJhbmdlM1tyYW5nZTMubGVuZ3RoIC0gMV07XG4gICAgaWYgKHggPD0gZDApIHtcbiAgICAgIHJldHVybiByMDtcbiAgICB9XG4gICAgaWYgKHggPj0gZDEpIHtcbiAgICAgIHJldHVybiByMTtcbiAgICB9XG4gICAgbGV0IGluZGV4O1xuICAgIGxldCBxO1xuICAgIGlmIChkb21haW4ubGVuZ3RoID09PSAyKSB7XG4gICAgICBjb25zdCB0ID0gKHggLSBkMCkgLyAoZDEgLSBkMCk7XG4gICAgICBjb25zdCBzdGVwID0gMSAvIChyYW5nZTMubGVuZ3RoIC0gMSk7XG4gICAgICBpbmRleCA9IHJhbmdlMy5sZW5ndGggPD0gMiA/IDAgOiBNYXRoLm1pbihNYXRoLmZsb29yKHQgKiAocmFuZ2UzLmxlbmd0aCAtIDEpKSwgcmFuZ2UzLmxlbmd0aCAtIDIpO1xuICAgICAgcSA9ICh0IC0gaW5kZXggKiBzdGVwKSAvIHN0ZXA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IGRvbWFpbi5sZW5ndGggLSAyOyBpbmRleCsrKSB7XG4gICAgICAgIGlmICh4IDwgZG9tYWluW2luZGV4ICsgMV0pIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgYSA9IGRvbWFpbltpbmRleF07XG4gICAgICBjb25zdCBiID0gZG9tYWluW2luZGV4ICsgMV07XG4gICAgICBxID0gKHggLSBhKSAvIChiIC0gYSk7XG4gICAgfVxuICAgIGNvbnN0IGMwID0gcGFyc2VkUmFuZ2VbaW5kZXhdO1xuICAgIGNvbnN0IGMxID0gcGFyc2VkUmFuZ2VbaW5kZXggKyAxXTtcbiAgICByZXR1cm4gaW50ZXJwb2xhdGVPa2xjaChjMCwgYzEsIHEpLnRvUmdiYVN0cmluZygpO1xuICB9XG4gIHJlZnJlc2goKSB7XG4gICAgaWYgKCF0aGlzLmludmFsaWQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5pbnZhbGlkID0gZmFsc2U7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgICBpZiAodGhpcy5pbnZhbGlkKSB7XG4gICAgICBMb2dnZXIud2Fybk9uY2UoXCJFeHBlY3RlZCB1cGRhdGUgdG8gbm90IGludmFsaWRhdGUgc2NhbGVcIik7XG4gICAgfVxuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgSW52YWxpZGF0aW5nXG5dLCBDb2xvclNjYWxlLnByb3RvdHlwZSwgXCJkb21haW5cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBJbnZhbGlkYXRpbmdcbl0sIENvbG9yU2NhbGUucHJvdG90eXBlLCBcInJhbmdlXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9ncmFkaWVudC9ncmFkaWVudC50c1xudmFyIEdyYWRpZW50ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihjb2xvclNwYWNlLCBzdG9wcyA9IFtdLCBiYm94KSB7XG4gICAgdGhpcy5jb2xvclNwYWNlID0gY29sb3JTcGFjZTtcbiAgICB0aGlzLnN0b3BzID0gc3RvcHM7XG4gICAgdGhpcy5iYm94ID0gYmJveDtcbiAgICB0aGlzLl9jYWNoZSA9IHZvaWQgMDtcbiAgfVxuICBjcmVhdGVHcmFkaWVudChjdHgsIHNoYXBlQmJveCkge1xuICAgIGNvbnN0IGJib3ggPSB0aGlzLmJib3ggPz8gc2hhcGVCYm94O1xuICAgIGlmICh0aGlzLl9jYWNoZSAhPSBudWxsICYmIHRoaXMuX2NhY2hlLmN0eCA9PT0gY3R4ICYmIHRoaXMuX2NhY2hlLmJib3guZXF1YWxzKGJib3gpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2FjaGUuZ3JhZGllbnQ7XG4gICAgfVxuICAgIGNvbnN0IHsgc3RvcHMsIGNvbG9yU3BhY2UgfSA9IHRoaXM7XG4gICAgaWYgKHN0b3BzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybjtcbiAgICBpZiAoc3RvcHMubGVuZ3RoID09PSAxKVxuICAgICAgcmV0dXJuIHN0b3BzWzBdLmNvbG9yO1xuICAgIGxldCBncmFkaWVudDIgPSB0aGlzLmNyZWF0ZUNhbnZhc0dyYWRpZW50KGN0eCwgYmJveCk7XG4gICAgaWYgKGdyYWRpZW50MiA9PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGlzT2tMY2ggPSBjb2xvclNwYWNlID09PSBcIm9rbGNoXCI7XG4gICAgY29uc3Qgc3RlcCA9IDAuMDU7XG4gICAgbGV0IGMwID0gc3RvcHNbMF07XG4gICAgZ3JhZGllbnQyLmFkZENvbG9yU3RvcChjMC5vZmZzZXQsIGMwLmNvbG9yKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHN0b3BzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBjb25zdCBjMSA9IHN0b3BzW2ldO1xuICAgICAgaWYgKGlzT2tMY2gpIHtcbiAgICAgICAgY29uc3Qgc2NhbGUyID0gbmV3IENvbG9yU2NhbGUoKTtcbiAgICAgICAgc2NhbGUyLmRvbWFpbiA9IFtjMC5vZmZzZXQsIGMxLm9mZnNldF07XG4gICAgICAgIHNjYWxlMi5yYW5nZSA9IFtjMC5jb2xvciwgYzEuY29sb3JdO1xuICAgICAgICBmb3IgKGxldCBvZmZzZXQ0ID0gYzAub2Zmc2V0ICsgc3RlcDsgb2Zmc2V0NCA8IGMxLm9mZnNldDsgb2Zmc2V0NCArPSBzdGVwKSB7XG4gICAgICAgICAgZ3JhZGllbnQyLmFkZENvbG9yU3RvcChvZmZzZXQ0LCBzY2FsZTIuY29udmVydChvZmZzZXQ0KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGdyYWRpZW50Mi5hZGRDb2xvclN0b3AoYzEub2Zmc2V0LCBjMS5jb2xvcik7XG4gICAgICBjMCA9IGMxO1xuICAgIH1cbiAgICBpZiAoXCJjcmVhdGVQYXR0ZXJuXCIgaW4gZ3JhZGllbnQyKSB7XG4gICAgICBncmFkaWVudDIgPSBncmFkaWVudDIuY3JlYXRlUGF0dGVybigpO1xuICAgIH1cbiAgICB0aGlzLl9jYWNoZSA9IHsgY3R4LCBiYm94LCBncmFkaWVudDogZ3JhZGllbnQyIH07XG4gICAgcmV0dXJuIGdyYWRpZW50MjtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvZ3JhZGllbnQvbGluZWFyR3JhZGllbnQudHNcbnZhciBMaW5lYXJHcmFkaWVudCA9IGNsYXNzIGV4dGVuZHMgR3JhZGllbnQge1xuICBjb25zdHJ1Y3Rvcihjb2xvclNwYWNlLCBzdG9wcywgYW5nbGUyID0gMCwgYmJveCkge1xuICAgIHN1cGVyKGNvbG9yU3BhY2UsIHN0b3BzLCBiYm94KTtcbiAgICB0aGlzLmFuZ2xlID0gYW5nbGUyO1xuICB9XG4gIGNyZWF0ZUNhbnZhc0dyYWRpZW50KGN0eCwgYmJveCkge1xuICAgIGNvbnN0IGFuZ2xlT2Zmc2V0ID0gOTA7XG4gICAgY29uc3QgeyBhbmdsZTogYW5nbGUyIH0gPSB0aGlzO1xuICAgIGNvbnN0IHJhZGlhbnMgPSBub3JtYWxpemVBbmdsZTM2MCh0b1JhZGlhbnMoYW5nbGUyICsgYW5nbGVPZmZzZXQpKTtcbiAgICBjb25zdCBjb3MgPSBNYXRoLmNvcyhyYWRpYW5zKTtcbiAgICBjb25zdCBzaW4gPSBNYXRoLnNpbihyYWRpYW5zKTtcbiAgICBjb25zdCB3ID0gYmJveC53aWR0aDtcbiAgICBjb25zdCBoID0gYmJveC5oZWlnaHQ7XG4gICAgY29uc3QgY3ggPSBiYm94LnggKyB3ICogMC41O1xuICAgIGNvbnN0IGN5ID0gYmJveC55ICsgaCAqIDAuNTtcbiAgICBjb25zdCBkaWFnb25hbCA9IE1hdGguc3FydChoICogaCArIHcgKiB3KSAvIDI7XG4gICAgY29uc3QgZGlhZ29uYWxBbmdsZSA9IE1hdGguYXRhbjIoaCwgdyk7XG4gICAgbGV0IHF1YXJ0ZXJlZEFuZ2xlO1xuICAgIGlmIChyYWRpYW5zIDwgTWF0aC5QSSAvIDIpIHtcbiAgICAgIHF1YXJ0ZXJlZEFuZ2xlID0gcmFkaWFucztcbiAgICB9IGVsc2UgaWYgKHJhZGlhbnMgPCBNYXRoLlBJKSB7XG4gICAgICBxdWFydGVyZWRBbmdsZSA9IE1hdGguUEkgLSByYWRpYW5zO1xuICAgIH0gZWxzZSBpZiAocmFkaWFucyA8IDEuNSAqIE1hdGguUEkpIHtcbiAgICAgIHF1YXJ0ZXJlZEFuZ2xlID0gcmFkaWFucyAtIE1hdGguUEk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHF1YXJ0ZXJlZEFuZ2xlID0gMiAqIE1hdGguUEkgLSByYWRpYW5zO1xuICAgIH1cbiAgICBjb25zdCBsID0gZGlhZ29uYWwgKiBNYXRoLmFicyhNYXRoLmNvcyhxdWFydGVyZWRBbmdsZSAtIGRpYWdvbmFsQW5nbGUpKTtcbiAgICByZXR1cm4gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KGN4ICsgY29zICogbCwgY3kgKyBzaW4gKiBsLCBjeCAtIGNvcyAqIGwsIGN5IC0gc2luICogbCk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL3NoYXBlL3NoYXBlLnRzXG52YXIgTElORUFSX0dSQURJRU5UX1JFR0VYUCA9IC9ebGluZWFyLWdyYWRpZW50XFwoKC0/W1xcZC5dKylkZWcsKC4qPylcXCkkL2k7XG52YXIgX1NoYXBlID0gY2xhc3MgX1NoYXBlIGV4dGVuZHMgTm9kZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5maWxsT3BhY2l0eSA9IDE7XG4gICAgdGhpcy5zdHJva2VPcGFjaXR5ID0gMTtcbiAgICB0aGlzLmZpbGwgPSBfU2hhcGUuZGVmYXVsdFN0eWxlcy5maWxsO1xuICAgIHRoaXMuc3Ryb2tlID0gX1NoYXBlLmRlZmF1bHRTdHlsZXMuc3Ryb2tlO1xuICAgIHRoaXMuc3Ryb2tlV2lkdGggPSBfU2hhcGUuZGVmYXVsdFN0eWxlcy5zdHJva2VXaWR0aDtcbiAgICB0aGlzLmxpbmVEYXNoID0gX1NoYXBlLmRlZmF1bHRTdHlsZXMubGluZURhc2g7XG4gICAgdGhpcy5saW5lRGFzaE9mZnNldCA9IF9TaGFwZS5kZWZhdWx0U3R5bGVzLmxpbmVEYXNoT2Zmc2V0O1xuICAgIHRoaXMubGluZUNhcCA9IF9TaGFwZS5kZWZhdWx0U3R5bGVzLmxpbmVDYXA7XG4gICAgdGhpcy5saW5lSm9pbiA9IF9TaGFwZS5kZWZhdWx0U3R5bGVzLmxpbmVKb2luO1xuICAgIHRoaXMubWl0ZXJMaW1pdCA9IHZvaWQgMDtcbiAgICB0aGlzLm9wYWNpdHkgPSBfU2hhcGUuZGVmYXVsdFN0eWxlcy5vcGFjaXR5O1xuICAgIHRoaXMuZmlsbFNoYWRvdyA9IF9TaGFwZS5kZWZhdWx0U3R5bGVzLmZpbGxTaGFkb3c7XG4gIH1cbiAgLyoqXG4gICAqIFJlc3RvcmVzIHRoZSBkZWZhdWx0IHN0eWxlcyBpbnRyb2R1Y2VkIGJ5IHRoaXMgc3ViY2xhc3MuXG4gICAqL1xuICByZXN0b3JlT3duU3R5bGVzKCkge1xuICAgIGNvbnN0IHsgZGVmYXVsdFN0eWxlcyB9ID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIGRlZmF1bHRTdHlsZXMpO1xuICB9XG4gIG9uRmlsbENoYW5nZSgpIHtcbiAgICBjb25zdCB7IGZpbGwgfSA9IHRoaXM7XG4gICAgbGV0IGxpbmVhckdyYWRpZW50TWF0Y2g7XG4gICAgaWYgKGZpbGwgaW5zdGFuY2VvZiBHcmFkaWVudCkge1xuICAgICAgdGhpcy5ncmFkaWVudCA9IGZpbGw7XG4gICAgfSBlbHNlIGlmIChmaWxsPy5zdGFydHNXaXRoKFwibGluZWFyLWdyYWRpZW50XCIpICYmIChsaW5lYXJHcmFkaWVudE1hdGNoID0gTElORUFSX0dSQURJRU5UX1JFR0VYUC5leGVjKGZpbGwpKSkge1xuICAgICAgY29uc3QgYW5nbGUyID0gcGFyc2VGbG9hdChsaW5lYXJHcmFkaWVudE1hdGNoWzFdKTtcbiAgICAgIGNvbnN0IGNvbG9ycyA9IFtdO1xuICAgICAgY29uc3QgY29sb3JzUGFydCA9IGxpbmVhckdyYWRpZW50TWF0Y2hbMl07XG4gICAgICBjb25zdCBjb2xvclJlZ2V4ID0gLygjWzAtOWEtZl0rKXwocmdiYT9cXCguKz9cXCkpfChbYS16XSspL2dpO1xuICAgICAgbGV0IGM7XG4gICAgICB3aGlsZSAoYyA9IGNvbG9yUmVnZXguZXhlYyhjb2xvcnNQYXJ0KSkge1xuICAgICAgICBjb2xvcnMucHVzaChjWzBdKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZ3JhZGllbnQgPSBuZXcgTGluZWFyR3JhZGllbnQoXG4gICAgICAgIFwicmdiXCIsXG4gICAgICAgIGNvbG9ycy5tYXAoKGNvbG9yLCBpbmRleCkgPT4gKHsgY29sb3IsIG9mZnNldDogaW5kZXggLyAoY29sb3JzLmxlbmd0aCAtIDEpIH0pKSxcbiAgICAgICAgYW5nbGUyXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmdyYWRpZW50ID0gdm9pZCAwO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIGRldmljZS1waXhlbCBhbGlnbmVkIGNvb3JkaW5hdGUgKG9yIGxlbmd0aCBpZiBsZW5ndGggaXMgc3VwcGxpZWQpLlxuICAgKlxuICAgKiBOT1RFOiBOb3Qgc3VpdGFibGUgZm9yIHN0cm9rZXMsIHNpbmNlIHRoZSBzdHJva2UgbmVlZHMgdG8gYmUgb2Zmc2V0IHRvIHRoZSBtaWRkbGVcbiAgICogb2YgYSBkZXZpY2UgcGl4ZWwuXG4gICAqL1xuICBhbGlnbihzdGFydDIsIGxlbmd0aDIpIHtcbiAgICBjb25zdCBwaXhlbFJhdGlvID0gdGhpcy5sYXllck1hbmFnZXI/LmNhbnZhcz8ucGl4ZWxSYXRpbyA/PyAxO1xuICAgIGNvbnN0IGFsaWduZWRTdGFydCA9IE1hdGgucm91bmQoc3RhcnQyICogcGl4ZWxSYXRpbykgLyBwaXhlbFJhdGlvO1xuICAgIGlmIChsZW5ndGgyID09IG51bGwpIHtcbiAgICAgIHJldHVybiBhbGlnbmVkU3RhcnQ7XG4gICAgfSBlbHNlIGlmIChsZW5ndGgyID09PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2UgaWYgKGxlbmd0aDIgPCAxKSB7XG4gICAgICByZXR1cm4gTWF0aC5jZWlsKGxlbmd0aDIgKiBwaXhlbFJhdGlvKSAvIHBpeGVsUmF0aW87XG4gICAgfVxuICAgIHJldHVybiBNYXRoLnJvdW5kKChsZW5ndGgyICsgc3RhcnQyKSAqIHBpeGVsUmF0aW8pIC8gcGl4ZWxSYXRpbyAtIGFsaWduZWRTdGFydDtcbiAgfVxuICBmaWxsU3Ryb2tlKGN0eCwgcGF0aCkge1xuICAgIHRoaXMucmVuZGVyRmlsbChjdHgsIHBhdGgpO1xuICAgIHRoaXMucmVuZGVyU3Ryb2tlKGN0eCwgcGF0aCk7XG4gIH1cbiAgcmVuZGVyRmlsbChjdHgsIHBhdGgpIHtcbiAgICBpZiAodGhpcy5maWxsKSB7XG4gICAgICBjb25zdCB7IGdsb2JhbEFscGhhIH0gPSBjdHg7XG4gICAgICB0aGlzLmFwcGx5RmlsbChjdHgpO1xuICAgICAgdGhpcy5hcHBseUZpbGxBbHBoYShjdHgpO1xuICAgICAgdGhpcy5hcHBseVNoYWRvdyhjdHgpO1xuICAgICAgdGhpcy5leGVjdXRlRmlsbChjdHgsIHBhdGgpO1xuICAgICAgY3R4Lmdsb2JhbEFscGhhID0gZ2xvYmFsQWxwaGE7XG4gICAgfVxuICAgIGN0eC5zaGFkb3dDb2xvciA9IFwicmdiYSgwLCAwLCAwLCAwKVwiO1xuICB9XG4gIGV4ZWN1dGVGaWxsKGN0eCwgcGF0aCkge1xuICAgIHBhdGggPyBjdHguZmlsbChwYXRoKSA6IGN0eC5maWxsKCk7XG4gIH1cbiAgYXBwbHlGaWxsKGN0eCkge1xuICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmdyYWRpZW50Py5jcmVhdGVHcmFkaWVudChjdHgsIHRoaXMuZ2V0QkJveCgpKSA/PyAodHlwZW9mIHRoaXMuZmlsbCA9PT0gXCJzdHJpbmdcIiA/IHRoaXMuZmlsbCA6IHZvaWQgMCkgPz8gXCJibGFja1wiO1xuICB9XG4gIGFwcGx5RmlsbEFscGhhKGN0eCkge1xuICAgIGN0eC5nbG9iYWxBbHBoYSAqPSB0aGlzLm9wYWNpdHkgKiB0aGlzLmZpbGxPcGFjaXR5O1xuICB9XG4gIGFwcGx5U2hhZG93KGN0eCkge1xuICAgIGNvbnN0IHBpeGVsUmF0aW8gPSB0aGlzLmxheWVyTWFuYWdlcj8uY2FudmFzLnBpeGVsUmF0aW8gPz8gMTtcbiAgICBjb25zdCBmaWxsU2hhZG93ID0gdGhpcy5maWxsU2hhZG93O1xuICAgIGlmIChmaWxsU2hhZG93Py5lbmFibGVkKSB7XG4gICAgICBjdHguc2hhZG93Q29sb3IgPSBmaWxsU2hhZG93LmNvbG9yO1xuICAgICAgY3R4LnNoYWRvd09mZnNldFggPSBmaWxsU2hhZG93LnhPZmZzZXQgKiBwaXhlbFJhdGlvO1xuICAgICAgY3R4LnNoYWRvd09mZnNldFkgPSBmaWxsU2hhZG93LnlPZmZzZXQgKiBwaXhlbFJhdGlvO1xuICAgICAgY3R4LnNoYWRvd0JsdXIgPSBmaWxsU2hhZG93LmJsdXIgKiBwaXhlbFJhdGlvO1xuICAgIH1cbiAgfVxuICByZW5kZXJTdHJva2UoY3R4LCBwYXRoKSB7XG4gICAgaWYgKHRoaXMuc3Ryb2tlICYmIHRoaXMuc3Ryb2tlV2lkdGgpIHtcbiAgICAgIGNvbnN0IHsgZ2xvYmFsQWxwaGEgfSA9IGN0eDtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuc3Ryb2tlO1xuICAgICAgY3R4Lmdsb2JhbEFscGhhICo9IHRoaXMub3BhY2l0eSAqIHRoaXMuc3Ryb2tlT3BhY2l0eTtcbiAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLnN0cm9rZVdpZHRoO1xuICAgICAgaWYgKHRoaXMubGluZURhc2gpIHtcbiAgICAgICAgY3R4LnNldExpbmVEYXNoKHRoaXMubGluZURhc2gpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubGluZURhc2hPZmZzZXQpIHtcbiAgICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gdGhpcy5saW5lRGFzaE9mZnNldDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmxpbmVDYXApIHtcbiAgICAgICAgY3R4LmxpbmVDYXAgPSB0aGlzLmxpbmVDYXA7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5saW5lSm9pbikge1xuICAgICAgICBjdHgubGluZUpvaW4gPSB0aGlzLmxpbmVKb2luO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubWl0ZXJMaW1pdCAhPSBudWxsKSB7XG4gICAgICAgIGN0eC5taXRlckxpbWl0ID0gdGhpcy5taXRlckxpbWl0O1xuICAgICAgfVxuICAgICAgdGhpcy5leGVjdXRlU3Ryb2tlKGN0eCwgcGF0aCk7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgPSBnbG9iYWxBbHBoYTtcbiAgICB9XG4gIH1cbiAgZXhlY3V0ZVN0cm9rZShjdHgsIHBhdGgpIHtcbiAgICBwYXRoID8gY3R4LnN0cm9rZShwYXRoKSA6IGN0eC5zdHJva2UoKTtcbiAgfVxuICBjb250YWluc1BvaW50KHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy5pc1BvaW50SW5QYXRoKHgsIHkpO1xuICB9XG59O1xuLyoqXG4gKiBEZWZhdWx0cyBmb3Igc3R5bGUgcHJvcGVydGllcy4gTm90ZSB0aGF0IHByb3BlcnRpZXMgdGhhdCBhZmZlY3QgdGhlIHBvc2l0aW9uXG4gKiBhbmQgc2hhcGUgb2YgdGhlIG5vZGUgYXJlIG5vdCBjb25zaWRlcmVkIHN0eWxlIHByb3BlcnRpZXMsIGZvciBleGFtcGxlOlxuICogYHhgLCBgeWAsIGB3aWR0aGAsIGBoZWlnaHRgLCBgcmFkaXVzYCwgYHJvdGF0aW9uYCwgZXRjLlxuICogQ2FuIGJlIHVzZWQgdG8gcmVzZXQgdG8gdGhlIG9yaWdpbmFsIHN0eWxpbmcgYWZ0ZXIgc29tZSBjdXN0b20gc3R5bGluZ1xuICogaGFzIGJlZW4gYXBwbGllZCAodXNpbmcgdGhlIGByZXN0b3JlT3duU3R5bGVzYCBtZXRob2QpLlxuICogVGhlc2Ugc3RhdGljIGRlZmF1bHRzIGFyZSBtZWFudCB0byBiZSBpbmhlcml0ZWQgYnkgc3ViY2xhc3Nlcy5cbiAqL1xuX1NoYXBlLmRlZmF1bHRTdHlsZXMgPSB7XG4gIGZpbGw6IFwiYmxhY2tcIixcbiAgc3Ryb2tlOiB2b2lkIDAsXG4gIHN0cm9rZVdpZHRoOiAwLFxuICBsaW5lRGFzaDogdm9pZCAwLFxuICBsaW5lRGFzaE9mZnNldDogMCxcbiAgbGluZUNhcDogdm9pZCAwLFxuICBsaW5lSm9pbjogdm9pZCAwLFxuICBvcGFjaXR5OiAxLFxuICBmaWxsU2hhZG93OiB2b2lkIDBcbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMiAvKiBNSU5PUiAqLyB9KVxuXSwgX1NoYXBlLnByb3RvdHlwZSwgXCJmaWxsT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAyIC8qIE1JTk9SICovIH0pXG5dLCBfU2hhcGUucHJvdG90eXBlLCBcInN0cm9rZU9wYWNpdHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMiAvKiBNSU5PUiAqLywgY2hhbmdlQ2I6IChzKSA9PiBzLm9uRmlsbENoYW5nZSgpIH0pXG5dLCBfU2hhcGUucHJvdG90eXBlLCBcImZpbGxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMiAvKiBNSU5PUiAqLyB9KVxuXSwgX1NoYXBlLnByb3RvdHlwZSwgXCJzdHJva2VcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMiAvKiBNSU5PUiAqLyB9KVxuXSwgX1NoYXBlLnByb3RvdHlwZSwgXCJzdHJva2VXaWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAyIC8qIE1JTk9SICovIH0pXG5dLCBfU2hhcGUucHJvdG90eXBlLCBcImxpbmVEYXNoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDIgLyogTUlOT1IgKi8gfSlcbl0sIF9TaGFwZS5wcm90b3R5cGUsIFwibGluZURhc2hPZmZzZXRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMiAvKiBNSU5PUiAqLyB9KVxuXSwgX1NoYXBlLnByb3RvdHlwZSwgXCJsaW5lQ2FwXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDIgLyogTUlOT1IgKi8gfSlcbl0sIF9TaGFwZS5wcm90b3R5cGUsIFwibGluZUpvaW5cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMiAvKiBNSU5PUiAqLyB9KVxuXSwgX1NoYXBlLnByb3RvdHlwZSwgXCJtaXRlckxpbWl0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oe1xuICAgIHJlZHJhdzogMiAvKiBNSU5PUiAqLyxcbiAgICBjb252ZXJ0b3I6ICh2KSA9PiBjbGFtcCgwLCB2LCAxKVxuICB9KVxuXSwgX1NoYXBlLnByb3RvdHlwZSwgXCJvcGFjaXR5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDIgLyogTUlOT1IgKi8sIGNoZWNrRGlydHlPbkFzc2lnbm1lbnQ6IHRydWUgfSlcbl0sIF9TaGFwZS5wcm90b3R5cGUsIFwiZmlsbFNoYWRvd1wiLCAyKTtcbnZhciBTaGFwZSA9IF9TaGFwZTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvc2hhcGUvbGluZS50c1xudmFyIExpbmUgPSBjbGFzcyBleHRlbmRzIFNoYXBlIHtcbiAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgc3VwZXIob3B0cyk7XG4gICAgdGhpcy54MSA9IDA7XG4gICAgdGhpcy55MSA9IDA7XG4gICAgdGhpcy54MiA9IDA7XG4gICAgdGhpcy55MiA9IDA7XG4gICAgdGhpcy5yZXN0b3JlT3duU3R5bGVzKCk7XG4gIH1cbiAgc2V0IHgodmFsdWUpIHtcbiAgICB0aGlzLngxID0gdmFsdWU7XG4gICAgdGhpcy54MiA9IHZhbHVlO1xuICB9XG4gIHNldCB5KHZhbHVlKSB7XG4gICAgdGhpcy55MSA9IHZhbHVlO1xuICAgIHRoaXMueTIgPSB2YWx1ZTtcbiAgfVxuICBnZXQgbWlkUG9pbnQoKSB7XG4gICAgcmV0dXJuIHsgeDogKHRoaXMueDEgKyB0aGlzLngyKSAvIDIsIHk6ICh0aGlzLnkxICsgdGhpcy55MikgLyAyIH07XG4gIH1cbiAgY29tcHV0ZUJCb3goKSB7XG4gICAgcmV0dXJuIG5ldyBCQm94KFxuICAgICAgTWF0aC5taW4odGhpcy54MSwgdGhpcy54MiksXG4gICAgICBNYXRoLm1pbih0aGlzLnkxLCB0aGlzLnkyKSxcbiAgICAgIE1hdGguYWJzKHRoaXMueDIgLSB0aGlzLngxKSxcbiAgICAgIE1hdGguYWJzKHRoaXMueTIgLSB0aGlzLnkxKVxuICAgICk7XG4gIH1cbiAgaXNQb2ludEluUGF0aCh4LCB5KSB7XG4gICAgaWYgKHRoaXMueDEgPT09IHRoaXMueDIgfHwgdGhpcy55MSA9PT0gdGhpcy55Mikge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0QkJveCgpLmNsb25lKCkuZ3Jvdyh0aGlzLnN0cm9rZVdpZHRoIC8gMikuY29udGFpbnNQb2ludCh4LCB5KTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGRpc3RhbmNlU3F1YXJlZChweCwgcHkpIHtcbiAgICBjb25zdCB7IHgxLCB5MSwgeDIsIHkyIH0gPSB0aGlzO1xuICAgIHJldHVybiBsaW5lRGlzdGFuY2VTcXVhcmVkKHB4LCBweSwgeDEsIHkxLCB4MiwgeTIsIEluZmluaXR5KTtcbiAgfVxuICByZW5kZXIocmVuZGVyQ3R4KSB7XG4gICAgY29uc3QgeyBjdHgsIGZvcmNlUmVuZGVyLCBzdGF0cywgZGV2aWNlUGl4ZWxSYXRpbyB9ID0gcmVuZGVyQ3R4O1xuICAgIGlmICh0aGlzLmRpcnR5ID09PSAwIC8qIE5PTkUgKi8gJiYgIWZvcmNlUmVuZGVyKSB7XG4gICAgICBpZiAoc3RhdHMpXG4gICAgICAgIHN0YXRzLm5vZGVzU2tpcHBlZCArPSBub2RlQ291bnQodGhpcykuY291bnQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCB7IHgxLCB5MSwgeDIsIHkyIH0gPSB0aGlzO1xuICAgIGlmICh4MSA9PT0geDIpIHtcbiAgICAgIGNvbnN0IHsgc3Ryb2tlV2lkdGggfSA9IHRoaXM7XG4gICAgICBjb25zdCB4ID0gTWF0aC5yb3VuZCh4MSAqIGRldmljZVBpeGVsUmF0aW8pIC8gZGV2aWNlUGl4ZWxSYXRpbyArIE1hdGgudHJ1bmMoc3Ryb2tlV2lkdGggKiBkZXZpY2VQaXhlbFJhdGlvKSAlIDIgLyAoZGV2aWNlUGl4ZWxSYXRpbyAqIDIpO1xuICAgICAgeDEgPSB4O1xuICAgICAgeDIgPSB4O1xuICAgIH0gZWxzZSBpZiAoeTEgPT09IHkyKSB7XG4gICAgICBjb25zdCB7IHN0cm9rZVdpZHRoIH0gPSB0aGlzO1xuICAgICAgY29uc3QgeSA9IE1hdGgucm91bmQoeTEgKiBkZXZpY2VQaXhlbFJhdGlvKSAvIGRldmljZVBpeGVsUmF0aW8gKyBNYXRoLnRydW5jKHN0cm9rZVdpZHRoICogZGV2aWNlUGl4ZWxSYXRpbykgJSAyIC8gKGRldmljZVBpeGVsUmF0aW8gKiAyKTtcbiAgICAgIHkxID0geTtcbiAgICAgIHkyID0geTtcbiAgICB9XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5tb3ZlVG8oeDEsIHkxKTtcbiAgICBjdHgubGluZVRvKHgyLCB5Mik7XG4gICAgdGhpcy5maWxsU3Ryb2tlKGN0eCk7XG4gICAgdGhpcy5maWxsU2hhZG93Py5tYXJrQ2xlYW4oKTtcbiAgICBzdXBlci5yZW5kZXIocmVuZGVyQ3R4KTtcbiAgfVxuICB0b1NWRygpIHtcbiAgICBpZiAoIXRoaXMudmlzaWJsZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlbGVtZW50MiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwibGluZVwiKTtcbiAgICBlbGVtZW50Mi5zZXRBdHRyaWJ1dGUoXCJ4MVwiLCBTdHJpbmcodGhpcy54MSkpO1xuICAgIGVsZW1lbnQyLnNldEF0dHJpYnV0ZShcInkxXCIsIFN0cmluZyh0aGlzLnkxKSk7XG4gICAgZWxlbWVudDIuc2V0QXR0cmlidXRlKFwieDJcIiwgU3RyaW5nKHRoaXMueDIpKTtcbiAgICBlbGVtZW50Mi5zZXRBdHRyaWJ1dGUoXCJ5MlwiLCBTdHJpbmcodGhpcy55MikpO1xuICAgIGVsZW1lbnQyLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCB0aGlzLnN0cm9rZSA/PyBcIm5vbmVcIik7XG4gICAgZWxlbWVudDIuc2V0QXR0cmlidXRlKFwic3Ryb2tlLW9wYWNpdHlcIiwgU3RyaW5nKHRoaXMuc3Ryb2tlT3BhY2l0eSkpO1xuICAgIGVsZW1lbnQyLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBTdHJpbmcodGhpcy5zdHJva2VXaWR0aCkpO1xuICAgIHJldHVybiB7XG4gICAgICBlbGVtZW50czogW2VsZW1lbnQyXVxuICAgIH07XG4gIH1cbn07XG5MaW5lLmNsYXNzTmFtZSA9IFwiTGluZVwiO1xuTGluZS5kZWZhdWx0U3R5bGVzID0geyAuLi5TaGFwZS5kZWZhdWx0U3R5bGVzLCBmaWxsOiB2b2lkIDAsIHN0cm9rZVdpZHRoOiAxIH07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLyB9KVxuXSwgTGluZS5wcm90b3R5cGUsIFwieDFcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLyB9KVxuXSwgTGluZS5wcm90b3R5cGUsIFwieTFcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLyB9KVxuXSwgTGluZS5wcm90b3R5cGUsIFwieDJcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLyB9KVxuXSwgTGluZS5wcm90b3R5cGUsIFwieTJcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvY2FudmFzLnV0aWwudHNcbmZ1bmN0aW9uIGNyZWF0ZUNhbnZhc0NvbnRleHQod2lkdGgyID0gMCwgaGVpZ2h0MiA9IDApIHtcbiAgY29uc3QgY2FudmFzID0gY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgY2FudmFzLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gIGNhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoMiArIFwicHhcIjtcbiAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodDIgKyBcInB4XCI7XG4gIHJldHVybiBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2xydUNhY2hlLnRzXG52YXIgTFJVQ2FjaGUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG1heENhY2hlU2l6ZSA9IDUpIHtcbiAgICB0aGlzLm1heENhY2hlU2l6ZSA9IG1heENhY2hlU2l6ZTtcbiAgICB0aGlzLnN0b3JlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICBnZXQoa2V5KSB7XG4gICAgaWYgKCF0aGlzLnN0b3JlLmhhcyhrZXkpKVxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICBjb25zdCBoaXQgPSB0aGlzLnN0b3JlLmdldChrZXkpO1xuICAgIHRoaXMuc3RvcmUuZGVsZXRlKGtleSk7XG4gICAgdGhpcy5zdG9yZS5zZXQoa2V5LCBoaXQpO1xuICAgIHJldHVybiBoaXQ7XG4gIH1cbiAgaGFzKGtleSkge1xuICAgIHJldHVybiB0aGlzLnN0b3JlLmhhcyhrZXkpO1xuICB9XG4gIHNldChrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5zdG9yZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgaWYgKHRoaXMuc3RvcmUuc2l6ZSA+IHRoaXMubWF4Q2FjaGVTaXplKSB7XG4gICAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMuc3RvcmUua2V5cygpO1xuICAgICAgbGV0IGV2aWN0Q291bnQgPSB0aGlzLnN0b3JlLnNpemUgLSB0aGlzLm1heENhY2hlU2l6ZTtcbiAgICAgIHdoaWxlIChldmljdENvdW50ID4gMCkge1xuICAgICAgICBjb25zdCBldmljdEtleUl0ZXJhdG9yID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAoIWV2aWN0S2V5SXRlcmF0b3IuZG9uZSkge1xuICAgICAgICAgIHRoaXMuc3RvcmUuZGVsZXRlKGV2aWN0S2V5SXRlcmF0b3IudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGV2aWN0Q291bnQtLTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMuc3RvcmUuY2xlYXIoKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC90ZXh0TWVhc3VyZXIudHNcbnZhciBDYWNoZWRUZXh0TWVhc3VyZXJQb29sID0gY2xhc3Mge1xuICAvLyBNZWFzdXJlcyB0aGUgZGltZW5zaW9ucyBvZiB0aGUgcHJvdmlkZWQgdGV4dCwgaGFuZGxpbmcgbXVsdGlsaW5lIGlmIG5lZWRlZC5cbiAgc3RhdGljIG1lYXN1cmVUZXh0KHRleHQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0ZXh0TWVhc3VyZXIgPSB0aGlzLmdldE1lYXN1cmVyKG9wdGlvbnMpO1xuICAgIHJldHVybiB0ZXh0TWVhc3VyZXIubWVhc3VyZVRleHQodGV4dCk7XG4gIH1cbiAgc3RhdGljIG1lYXN1cmVMaW5lcyh0ZXh0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgdGV4dE1lYXN1cmVyID0gdGhpcy5nZXRNZWFzdXJlcihvcHRpb25zKTtcbiAgICByZXR1cm4gdGV4dE1lYXN1cmVyLm1lYXN1cmVMaW5lcyh0ZXh0KTtcbiAgfVxuICAvLyBHZXRzIGEgVGV4dE1lYXN1cmVyIGluc3RhbmNlLCBjb25maWd1cmluZyB0ZXh0IGFsaWdubWVudCBhbmQgYmFzZWxpbmUgaWYgcHJvdmlkZWQuXG4gIHN0YXRpYyBnZXRNZWFzdXJlcihvcHRpb25zKSB7XG4gICAgY29uc3QgZm9udCA9IHR5cGVvZiBvcHRpb25zLmZvbnQgPT09IFwic3RyaW5nXCIgPyBvcHRpb25zLmZvbnQgOiBUZXh0VXRpbHMudG9Gb250U3RyaW5nKG9wdGlvbnMuZm9udCk7XG4gICAgY29uc3Qga2V5ID0gYCR7Zm9udH0tJHtvcHRpb25zLnRleHRBbGlnbiA/PyBcInN0YXJ0XCJ9LSR7b3B0aW9ucy50ZXh0QmFzZWxpbmUgPz8gXCJhbHBoYWJldGljXCJ9YDtcbiAgICByZXR1cm4gdGhpcy5pbnN0YW5jZU1hcC5nZXQoa2V5KSA/PyB0aGlzLmNyZWF0ZUZvbnRNZWFzdXJlcihmb250LCBvcHRpb25zLCBrZXkpO1xuICB9XG4gIC8vIENyZWF0ZXMgb3IgcmV0cmlldmVzIGEgVGV4dE1lYXN1cmVyIGluc3RhbmNlIGZvciBhIHNwZWNpZmljIGZvbnQuXG4gIHN0YXRpYyBjcmVhdGVGb250TWVhc3VyZXIoZm9udCwgb3B0aW9ucywga2V5KSB7XG4gICAgY29uc3QgY3R4ID0gY3JlYXRlQ2FudmFzQ29udGV4dCgpO1xuICAgIGN0eC5mb250ID0gZm9udDtcbiAgICBjdHgudGV4dEFsaWduID0gb3B0aW9ucy50ZXh0QWxpZ24gPz8gXCJzdGFydFwiO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBvcHRpb25zLnRleHRCYXNlbGluZSA/PyBcImFscGhhYmV0aWNcIjtcbiAgICBjb25zdCBtZWFzdXJlciA9IG5ldyBDYWNoZWRUZXh0TWVhc3VyZXIoY3R4LCBvcHRpb25zKTtcbiAgICB0aGlzLmluc3RhbmNlTWFwLnNldChrZXksIG1lYXN1cmVyKTtcbiAgICByZXR1cm4gbWVhc3VyZXI7XG4gIH1cbn07XG5DYWNoZWRUZXh0TWVhc3VyZXJQb29sLmluc3RhbmNlTWFwID0gbmV3IExSVUNhY2hlKDEwKTtcbnZhciBDYWNoZWRUZXh0TWVhc3VyZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGN0eCwgb3B0aW9ucykge1xuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIC8vIGNhY2hlZCB0ZXh0IG1lYXN1cmVtZW50c1xuICAgIHRoaXMubWVhc3VyZU1hcCA9IG5ldyBMUlVDYWNoZSgxMDApO1xuICAgIGlmIChvcHRpb25zLnRleHRBbGlnbikge1xuICAgICAgY3R4LnRleHRBbGlnbiA9IG9wdGlvbnMudGV4dEFsaWduO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy50ZXh0QmFzZWxpbmUpIHtcbiAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBvcHRpb25zLnRleHRCYXNlbGluZTtcbiAgICB9XG4gICAgY3R4LmZvbnQgPSB0eXBlb2Ygb3B0aW9ucy5mb250ID09PSBcInN0cmluZ1wiID8gb3B0aW9ucy5mb250IDogVGV4dFV0aWxzLnRvRm9udFN0cmluZyhvcHRpb25zLmZvbnQpO1xuICAgIHRoaXMudGV4dE1lYXN1cmVyID0gbmV3IFNpbXBsZVRleHRNZWFzdXJlcihcbiAgICAgICh0KSA9PiB0aGlzLmNhY2hlZEN0eE1lYXN1cmVUZXh0KHQpLFxuICAgICAgb3B0aW9ucy50ZXh0QmFzZWxpbmUgPz8gXCJhbHBoYWJldGljXCJcbiAgICApO1xuICB9XG4gIHRleHRXaWR0aCh0ZXh0LCBlc3RpbWF0ZSkge1xuICAgIHJldHVybiB0aGlzLnRleHRNZWFzdXJlci50ZXh0V2lkdGgodGV4dCwgZXN0aW1hdGUpO1xuICB9XG4gIG1lYXN1cmVUZXh0KHRleHQpIHtcbiAgICByZXR1cm4gdGhpcy50ZXh0TWVhc3VyZXIubWVhc3VyZVRleHQodGV4dCk7XG4gIH1cbiAgbWVhc3VyZUxpbmVzKHRleHQpIHtcbiAgICByZXR1cm4gdGhpcy50ZXh0TWVhc3VyZXIubWVhc3VyZUxpbmVzKHRleHQpO1xuICB9XG4gIGNhY2hlZEN0eE1lYXN1cmVUZXh0KHRleHQpIHtcbiAgICBpZiAoIXRoaXMubWVhc3VyZU1hcC5oYXModGV4dCkpIHtcbiAgICAgIGNvbnN0IHJhd1Jlc3VsdCA9IHRoaXMuY3R4Lm1lYXN1cmVUZXh0KHRleHQpO1xuICAgICAgdGhpcy5tZWFzdXJlTWFwLnNldCh0ZXh0LCB7XG4gICAgICAgIGFjdHVhbEJvdW5kaW5nQm94QXNjZW50OiByYXdSZXN1bHQuYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQsXG4gICAgICAgIGVtSGVpZ2h0QXNjZW50OiByYXdSZXN1bHQuZW1IZWlnaHRBc2NlbnQsXG4gICAgICAgIGVtSGVpZ2h0RGVzY2VudDogcmF3UmVzdWx0LmVtSGVpZ2h0RGVzY2VudCxcbiAgICAgICAgYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50OiByYXdSZXN1bHQuYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50LFxuICAgICAgICBhY3R1YWxCb3VuZGluZ0JveExlZnQ6IHJhd1Jlc3VsdC5hY3R1YWxCb3VuZGluZ0JveExlZnQsXG4gICAgICAgIGFjdHVhbEJvdW5kaW5nQm94UmlnaHQ6IHJhd1Jlc3VsdC5hY3R1YWxCb3VuZGluZ0JveFJpZ2h0LFxuICAgICAgICBhbHBoYWJldGljQmFzZWxpbmU6IHJhd1Jlc3VsdC5hbHBoYWJldGljQmFzZWxpbmUsXG4gICAgICAgIGZvbnRCb3VuZGluZ0JveEFzY2VudDogcmF3UmVzdWx0LmZvbnRCb3VuZGluZ0JveEFzY2VudCxcbiAgICAgICAgZm9udEJvdW5kaW5nQm94RGVzY2VudDogcmF3UmVzdWx0LmZvbnRCb3VuZGluZ0JveERlc2NlbnQsXG4gICAgICAgIGhhbmdpbmdCYXNlbGluZTogcmF3UmVzdWx0LmhhbmdpbmdCYXNlbGluZSxcbiAgICAgICAgaWRlb2dyYXBoaWNCYXNlbGluZTogcmF3UmVzdWx0LmlkZW9ncmFwaGljQmFzZWxpbmUsXG4gICAgICAgIHdpZHRoOiByYXdSZXN1bHQud2lkdGhcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tZWFzdXJlTWFwLmdldCh0ZXh0KTtcbiAgfVxufTtcbnZhciBUZXh0VXRpbHMgPSBjbGFzcyB7XG4gIHN0YXRpYyB0b0ZvbnRTdHJpbmcoeyBmb250U2l6ZSA9IDEwLCBmb250U3R5bGUsIGZvbnRXZWlnaHQsIGZvbnRGYW1pbHksIGxpbmVIZWlnaHQgfSkge1xuICAgIGxldCBmb250U3RyaW5nID0gXCJcIjtcbiAgICBpZiAoZm9udFN0eWxlKSB7XG4gICAgICBmb250U3RyaW5nICs9IGAke2ZvbnRTdHlsZX0gYDtcbiAgICB9XG4gICAgaWYgKGZvbnRXZWlnaHQpIHtcbiAgICAgIGZvbnRTdHJpbmcgKz0gYCR7Zm9udFdlaWdodH0gYDtcbiAgICB9XG4gICAgZm9udFN0cmluZyArPSBgJHtmb250U2l6ZX1weGA7XG4gICAgaWYgKGxpbmVIZWlnaHQpIHtcbiAgICAgIGZvbnRTdHJpbmcgKz0gYC8ke2xpbmVIZWlnaHR9cHhgO1xuICAgIH1cbiAgICBmb250U3RyaW5nICs9IGAgJHtmb250RmFtaWx5fWA7XG4gICAgcmV0dXJuIGZvbnRTdHJpbmcudHJpbSgpO1xuICB9XG4gIHN0YXRpYyBnZXRMaW5lSGVpZ2h0KGZvbnRTaXplKSB7XG4gICAgcmV0dXJuIE1hdGguY2VpbChmb250U2l6ZSAqIHRoaXMuZGVmYXVsdExpbmVIZWlnaHQpO1xuICB9XG4gIC8vIERldGVybWluZXMgdmVydGljYWwgb2Zmc2V0IG1vZGlmaWVyIGJhc2VkIG9uIHRleHQgYmFzZWxpbmUuXG4gIHN0YXRpYyBnZXRWZXJ0aWNhbE1vZGlmaWVyKHRleHRCYXNlbGluZSkge1xuICAgIHN3aXRjaCAodGV4dEJhc2VsaW5lKSB7XG4gICAgICBjYXNlIFwiaGFuZ2luZ1wiOlxuICAgICAgY2FzZSBcInRvcFwiOlxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIGNhc2UgXCJtaWRkbGVcIjpcbiAgICAgICAgcmV0dXJuIDAuNTtcbiAgICAgIGNhc2UgXCJhbHBoYWJldGljXCI6XG4gICAgICBjYXNlIFwiYm90dG9tXCI6XG4gICAgICBjYXNlIFwiaWRlb2dyYXBoaWNcIjpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfVxufTtcblRleHRVdGlscy5FbGxpcHNpc0NoYXIgPSBcIlxcdTIwMjZcIjtcbi8vIFJlcHJlc2VudGF0aW9uIGZvciB0ZXh0IGNsaXBwaW5nLlxuVGV4dFV0aWxzLmRlZmF1bHRMaW5lSGVpZ2h0ID0gMS4xNTtcbi8vIE5vcm1hbGx5IGJldHdlZW4gMS4xIGFuZCAxLjJcblRleHRVdGlscy5saW5lU3BsaXR0ZXIgPSAvXFxyP1xcbi9nO1xudmFyIFNpbXBsZVRleHRNZWFzdXJlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IobWVhc3VyZVRleHRGbiwgdGV4dEJhc2VsaW5lID0gXCJhbHBoYWJldGljXCIpIHtcbiAgICB0aGlzLm1lYXN1cmVUZXh0Rm4gPSBtZWFzdXJlVGV4dEZuO1xuICAgIHRoaXMudGV4dEJhc2VsaW5lID0gdGV4dEJhc2VsaW5lO1xuICAgIC8vIGxvY2FsIGNoYXJzIHdpZHRoIGNhY2hlIHBlciBUZXh0TWVhc3VyZXJcbiAgICB0aGlzLmNoYXJNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIC8vIE1lYXN1cmVzIG1ldHJpY3MgZm9yIGEgc2luZ2xlIGxpbmUgb2YgdGV4dC5cbiAgZ2V0TWV0cmljcyh0ZXh0KSB7XG4gICAgY29uc3QgbSA9IHRoaXMubWVhc3VyZVRleHRGbih0ZXh0KTtcbiAgICBtLmZvbnRCb3VuZGluZ0JveEFzY2VudCA/PyAobS5mb250Qm91bmRpbmdCb3hBc2NlbnQgPSBtLmVtSGVpZ2h0QXNjZW50KTtcbiAgICBtLmZvbnRCb3VuZGluZ0JveERlc2NlbnQgPz8gKG0uZm9udEJvdW5kaW5nQm94RGVzY2VudCA9IG0uZW1IZWlnaHREZXNjZW50KTtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IG0ud2lkdGgsXG4gICAgICBoZWlnaHQ6IG0uYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQgKyBtLmFjdHVhbEJvdW5kaW5nQm94RGVzY2VudCxcbiAgICAgIGxpbmVIZWlnaHQ6IG0uZm9udEJvdW5kaW5nQm94QXNjZW50ICsgbS5mb250Qm91bmRpbmdCb3hEZXNjZW50LFxuICAgICAgb2Zmc2V0VG9wOiBtLmFjdHVhbEJvdW5kaW5nQm94QXNjZW50LFxuICAgICAgb2Zmc2V0TGVmdDogbS5hY3R1YWxCb3VuZGluZ0JveExlZnRcbiAgICB9O1xuICB9XG4gIC8vIENhbGN1bGF0ZXMgYWdncmVnYXRlZCBtZXRyaWNzIGZvciBtdWx0aWxpbmUgdGV4dC5cbiAgZ2V0TXVsdGlsaW5lTWV0cmljcyhsaW5lcykge1xuICAgIGxldCB3aWR0aDIgPSAwO1xuICAgIGxldCBoZWlnaHQyID0gMDtcbiAgICBsZXQgb2Zmc2V0VG9wID0gMDtcbiAgICBsZXQgb2Zmc2V0TGVmdCA9IDA7XG4gICAgbGV0IGJhc2VsaW5lRGlzdGFuY2UgPSAwO1xuICAgIGNvbnN0IHZlcnRpY2FsTW9kaWZpZXIgPSBUZXh0VXRpbHMuZ2V0VmVydGljYWxNb2RpZmllcih0aGlzLnRleHRCYXNlbGluZSk7XG4gICAgY29uc3QgbGluZU1ldHJpY3MgPSBbXTtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGNvbnN0IGxlbmd0aDIgPSBsaW5lcy5sZW5ndGg7XG4gICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICBjb25zdCBtID0gdGhpcy5tZWFzdXJlVGV4dEZuKGxpbmUpO1xuICAgICAgbS5mb250Qm91bmRpbmdCb3hBc2NlbnQgPz8gKG0uZm9udEJvdW5kaW5nQm94QXNjZW50ID0gbS5lbUhlaWdodEFzY2VudCk7XG4gICAgICBtLmZvbnRCb3VuZGluZ0JveERlc2NlbnQgPz8gKG0uZm9udEJvdW5kaW5nQm94RGVzY2VudCA9IG0uZW1IZWlnaHREZXNjZW50KTtcbiAgICAgIGlmICh3aWR0aDIgPCBtLndpZHRoKSB7XG4gICAgICAgIHdpZHRoMiA9IG0ud2lkdGg7XG4gICAgICB9XG4gICAgICBpZiAob2Zmc2V0TGVmdCA8IG0uYWN0dWFsQm91bmRpbmdCb3hMZWZ0KSB7XG4gICAgICAgIG9mZnNldExlZnQgPSBtLmFjdHVhbEJvdW5kaW5nQm94TGVmdDtcbiAgICAgIH1cbiAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICBoZWlnaHQyICs9IG0uYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQ7XG4gICAgICAgIG9mZnNldFRvcCArPSBtLmFjdHVhbEJvdW5kaW5nQm94QXNjZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFzZWxpbmVEaXN0YW5jZSArPSBtLmZvbnRCb3VuZGluZ0JveEFzY2VudDtcbiAgICAgIH1cbiAgICAgIGlmIChpbmRleCA9PT0gbGVuZ3RoMiAtIDEpIHtcbiAgICAgICAgaGVpZ2h0MiArPSBtLmFjdHVhbEJvdW5kaW5nQm94RGVzY2VudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhc2VsaW5lRGlzdGFuY2UgKz0gbS5mb250Qm91bmRpbmdCb3hEZXNjZW50O1xuICAgICAgfVxuICAgICAgbGluZU1ldHJpY3MucHVzaCh7XG4gICAgICAgIHRleHQ6IGxpbmUsXG4gICAgICAgIHdpZHRoOiBtLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IG0uYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQgKyBtLmFjdHVhbEJvdW5kaW5nQm94RGVzY2VudCxcbiAgICAgICAgbGluZUhlaWdodDogbS5mb250Qm91bmRpbmdCb3hBc2NlbnQgKyBtLmZvbnRCb3VuZGluZ0JveERlc2NlbnQsXG4gICAgICAgIG9mZnNldFRvcDogbS5hY3R1YWxCb3VuZGluZ0JveEFzY2VudCxcbiAgICAgICAgb2Zmc2V0TGVmdDogbS5hY3R1YWxCb3VuZGluZ0JveExlZnRcbiAgICAgIH0pO1xuICAgICAgaW5kZXgrKztcbiAgICB9XG4gICAgaGVpZ2h0MiArPSBiYXNlbGluZURpc3RhbmNlO1xuICAgIG9mZnNldFRvcCArPSBiYXNlbGluZURpc3RhbmNlICogdmVydGljYWxNb2RpZmllcjtcbiAgICByZXR1cm4geyB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIsIG9mZnNldFRvcCwgb2Zmc2V0TGVmdCwgbGluZU1ldHJpY3MgfTtcbiAgfVxuICB0ZXh0V2lkdGgodGV4dCwgZXN0aW1hdGUpIHtcbiAgICBpZiAoZXN0aW1hdGUpIHtcbiAgICAgIGxldCBlc3RpbWF0ZWRXaWR0aCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZXN0aW1hdGVkV2lkdGggKz0gdGhpcy50ZXh0V2lkdGgodGV4dC5jaGFyQXQoaSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVzdGltYXRlZFdpZHRoO1xuICAgIH1cbiAgICBpZiAodGV4dC5sZW5ndGggPiAxKSB7XG4gICAgICByZXR1cm4gdGhpcy5tZWFzdXJlVGV4dEZuKHRleHQpLndpZHRoO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jaGFyTWFwLmdldCh0ZXh0KSA/PyB0aGlzLmNoYXJXaWR0aCh0ZXh0KTtcbiAgfVxuICBtZWFzdXJlVGV4dCh0ZXh0KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TWV0cmljcyh0ZXh0KTtcbiAgfVxuICAvLyBNZWFzdXJlcyB0aGUgZGltZW5zaW9ucyBvZiB0aGUgcHJvdmlkZWQgdGV4dCwgaGFuZGxpbmcgbXVsdGlsaW5lIGlmIG5lZWRlZC5cbiAgbWVhc3VyZUxpbmVzKHRleHQpIHtcbiAgICBjb25zdCBsaW5lcyA9IHR5cGVvZiB0ZXh0ID09PSBcInN0cmluZ1wiID8gdGV4dC5zcGxpdChUZXh0VXRpbHMubGluZVNwbGl0dGVyKSA6IHRleHQ7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TXVsdGlsaW5lTWV0cmljcyhsaW5lcyk7XG4gIH1cbiAgY2hhcldpZHRoKGNoYXIpIHtcbiAgICBjb25zdCB7IHdpZHRoOiB3aWR0aDIgfSA9IHRoaXMubWVhc3VyZVRleHRGbihjaGFyKTtcbiAgICB0aGlzLmNoYXJNYXAuc2V0KGNoYXIsIHdpZHRoMik7XG4gICAgcmV0dXJuIHdpZHRoMjtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvc2hhcGUvdGV4dC50c1xudmFyIF9UZXh0ID0gY2xhc3MgX1RleHQgZXh0ZW5kcyBTaGFwZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy54ID0gMDtcbiAgICB0aGlzLnkgPSAwO1xuICAgIHRoaXMubGluZXMgPSBbXTtcbiAgICB0aGlzLnRleHQgPSB2b2lkIDA7XG4gICAgdGhpcy5mb250U2l6ZSA9IDEwO1xuICAgIHRoaXMuZm9udEZhbWlseSA9IFwic2Fucy1zZXJpZlwiO1xuICAgIHRoaXMudGV4dEFsaWduID0gX1RleHQuZGVmYXVsdFN0eWxlcy50ZXh0QWxpZ247XG4gICAgdGhpcy50ZXh0QmFzZWxpbmUgPSBfVGV4dC5kZWZhdWx0U3R5bGVzLnRleHRCYXNlbGluZTtcbiAgfVxuICBvblRleHRDaGFuZ2UoKSB7XG4gICAgdGhpcy5saW5lcyA9IHRoaXMudGV4dD8uc3BsaXQoXCJcXG5cIikubWFwKChzKSA9PiBzLnRyaW0oKSkgPz8gW107XG4gIH1cbiAgc3RhdGljIGNvbXB1dGVCQm94KGxpbmVzLCB4LCB5LCBvcHRzKSB7XG4gICAgY29uc3QgeyBvZmZzZXRUb3AsIG9mZnNldExlZnQsIHdpZHRoOiB3aWR0aDIsIGhlaWdodDogaGVpZ2h0MiB9ID0gQ2FjaGVkVGV4dE1lYXN1cmVyUG9vbC5tZWFzdXJlTGluZXMobGluZXMsIG9wdHMpO1xuICAgIHJldHVybiBuZXcgQkJveCh4IC0gb2Zmc2V0TGVmdCwgeSAtIG9mZnNldFRvcCwgd2lkdGgyLCBoZWlnaHQyKTtcbiAgfVxuICBjb21wdXRlQkJveCgpIHtcbiAgICBjb25zdCB7IHgsIHksIGxpbmVzLCB0ZXh0QmFzZWxpbmUsIHRleHRBbGlnbiB9ID0gdGhpcztcbiAgICByZXR1cm4gX1RleHQuY29tcHV0ZUJCb3gobGluZXMsIHgsIHksIHsgZm9udDogdGhpcywgdGV4dEJhc2VsaW5lLCB0ZXh0QWxpZ24gfSk7XG4gIH1cbiAgaXNQb2ludEluUGF0aCh4LCB5KSB7XG4gICAgY29uc3QgYmJveCA9IHRoaXMuZ2V0QkJveCgpO1xuICAgIHJldHVybiBiYm94ID8gYmJveC5jb250YWluc1BvaW50KHgsIHkpIDogZmFsc2U7XG4gIH1cbiAgcmVuZGVyKHJlbmRlckN0eCkge1xuICAgIGNvbnN0IHsgY3R4LCBmb3JjZVJlbmRlciwgc3RhdHMgfSA9IHJlbmRlckN0eDtcbiAgICBpZiAodGhpcy5kaXJ0eSA9PT0gMCAvKiBOT05FICovICYmICFmb3JjZVJlbmRlcikge1xuICAgICAgaWYgKHN0YXRzKVxuICAgICAgICBzdGF0cy5ub2Rlc1NraXBwZWQgKz0gbm9kZUNvdW50KHRoaXMpLmNvdW50O1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMubGluZXMubGVuZ3RoIHx8ICF0aGlzLmxheWVyTWFuYWdlcikge1xuICAgICAgaWYgKHN0YXRzKVxuICAgICAgICBzdGF0cy5ub2Rlc1NraXBwZWQgKz0gbm9kZUNvdW50KHRoaXMpLmNvdW50O1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGZpbGwsIHN0cm9rZSwgc3Ryb2tlV2lkdGggfSA9IHRoaXM7XG4gICAgY29uc3QgeyBwaXhlbFJhdGlvIH0gPSB0aGlzLmxheWVyTWFuYWdlci5jYW52YXM7XG4gICAgY3R4LmZvbnQgPSBUZXh0VXRpbHMudG9Gb250U3RyaW5nKHRoaXMpO1xuICAgIGN0eC50ZXh0QWxpZ24gPSB0aGlzLnRleHRBbGlnbjtcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gdGhpcy50ZXh0QmFzZWxpbmU7XG4gICAgaWYgKGZpbGwpIHtcbiAgICAgIHRoaXMuYXBwbHlGaWxsKGN0eCk7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgKj0gdGhpcy5vcGFjaXR5ICogdGhpcy5maWxsT3BhY2l0eTtcbiAgICAgIGNvbnN0IHsgZmlsbFNoYWRvdyB9ID0gdGhpcztcbiAgICAgIGlmIChmaWxsU2hhZG93Py5lbmFibGVkKSB7XG4gICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IGZpbGxTaGFkb3cuY29sb3I7XG4gICAgICAgIGN0eC5zaGFkb3dPZmZzZXRYID0gZmlsbFNoYWRvdy54T2Zmc2V0ICogcGl4ZWxSYXRpbztcbiAgICAgICAgY3R4LnNoYWRvd09mZnNldFkgPSBmaWxsU2hhZG93LnlPZmZzZXQgKiBwaXhlbFJhdGlvO1xuICAgICAgICBjdHguc2hhZG93Qmx1ciA9IGZpbGxTaGFkb3cuYmx1ciAqIHBpeGVsUmF0aW87XG4gICAgICB9XG4gICAgICB0aGlzLnJlbmRlckxpbmVzKChsaW5lLCB4LCB5KSA9PiBjdHguZmlsbFRleHQobGluZSwgeCwgeSkpO1xuICAgIH1cbiAgICBpZiAoc3Ryb2tlICYmIHN0cm9rZVdpZHRoKSB7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2U7XG4gICAgICBjdHgubGluZVdpZHRoID0gc3Ryb2tlV2lkdGg7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgKj0gdGhpcy5vcGFjaXR5ICogdGhpcy5zdHJva2VPcGFjaXR5O1xuICAgICAgY29uc3QgeyBsaW5lRGFzaCwgbGluZURhc2hPZmZzZXQsIGxpbmVDYXAsIGxpbmVKb2luIH0gPSB0aGlzO1xuICAgICAgaWYgKGxpbmVEYXNoKSB7XG4gICAgICAgIGN0eC5zZXRMaW5lRGFzaChsaW5lRGFzaCk7XG4gICAgICB9XG4gICAgICBpZiAobGluZURhc2hPZmZzZXQpIHtcbiAgICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gbGluZURhc2hPZmZzZXQ7XG4gICAgICB9XG4gICAgICBpZiAobGluZUNhcCkge1xuICAgICAgICBjdHgubGluZUNhcCA9IGxpbmVDYXA7XG4gICAgICB9XG4gICAgICBpZiAobGluZUpvaW4pIHtcbiAgICAgICAgY3R4LmxpbmVKb2luID0gbGluZUpvaW47XG4gICAgICB9XG4gICAgICB0aGlzLnJlbmRlckxpbmVzKChsaW5lLCB4LCB5KSA9PiBjdHguc3Ryb2tlVGV4dChsaW5lLCB4LCB5KSk7XG4gICAgfVxuICAgIHN1cGVyLnJlbmRlcihyZW5kZXJDdHgpO1xuICB9XG4gIHJlbmRlckxpbmVzKHJlbmRlckNhbGxiYWNrKSB7XG4gICAgY29uc3QgeyBsaW5lcywgeCwgeSB9ID0gdGhpcztcbiAgICBjb25zdCBsaW5lSGVpZ2h0ID0gdGhpcy5saW5lSGVpZ2h0ID8/IFRleHRVdGlscy5nZXRMaW5lSGVpZ2h0KHRoaXMuZm9udFNpemUpO1xuICAgIGxldCBvZmZzZXRZID0gKGxpbmVIZWlnaHQgLSBsaW5lSGVpZ2h0ICogbGluZXMubGVuZ3RoKSAqIFRleHRVdGlscy5nZXRWZXJ0aWNhbE1vZGlmaWVyKHRoaXMudGV4dEJhc2VsaW5lKTtcbiAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcbiAgICAgIHJlbmRlckNhbGxiYWNrKGxpbmUsIHgsIHkgKyBvZmZzZXRZKTtcbiAgICAgIG9mZnNldFkgKz0gbGluZUhlaWdodDtcbiAgICB9XG4gIH1cbiAgc2V0Rm9udChwcm9wcykge1xuICAgIHRoaXMuZm9udEZhbWlseSA9IHByb3BzLmZvbnRGYW1pbHk7XG4gICAgdGhpcy5mb250U2l6ZSA9IHByb3BzLmZvbnRTaXplO1xuICAgIHRoaXMuZm9udFN0eWxlID0gcHJvcHMuZm9udFN0eWxlO1xuICAgIHRoaXMuZm9udFdlaWdodCA9IHByb3BzLmZvbnRXZWlnaHQ7XG4gIH1cbiAgc2V0QWxpZ24ocHJvcHMpIHtcbiAgICB0aGlzLnRleHRBbGlnbiA9IHByb3BzLnRleHRBbGlnbjtcbiAgICB0aGlzLnRleHRCYXNlbGluZSA9IHByb3BzLnRleHRCYXNlbGluZTtcbiAgfVxuICB0b1NWRygpIHtcbiAgICBpZiAoIXRoaXMudmlzaWJsZSB8fCAhdGhpcy50ZXh0KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGVsZW1lbnQyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJ0ZXh0XCIpO1xuICAgIGVsZW1lbnQyLnNldEF0dHJpYnV0ZShcImZvbnQtZmFtaWx5XCIsIHRoaXMuZm9udEZhbWlseT8uc3BsaXQoXCIsXCIpWzBdID8/IFwiXCIpO1xuICAgIGVsZW1lbnQyLnNldEF0dHJpYnV0ZShcImZvbnQtc2l6ZVwiLCBTdHJpbmcodGhpcy5mb250U2l6ZSkpO1xuICAgIGVsZW1lbnQyLnNldEF0dHJpYnV0ZShcImZvbnQtc3R5bGVcIiwgdGhpcy5mb250U3R5bGUgPz8gXCJcIik7XG4gICAgZWxlbWVudDIuc2V0QXR0cmlidXRlKFwiZm9udC13ZWlnaHRcIiwgU3RyaW5nKHRoaXMuZm9udFdlaWdodCA/PyBcIlwiKSk7XG4gICAgZWxlbWVudDIuc2V0QXR0cmlidXRlKFxuICAgICAgXCJ0ZXh0LWFuY2hvclwiLFxuICAgICAge1xuICAgICAgICBjZW50ZXI6IFwibWlkZGxlXCIsXG4gICAgICAgIGxlZnQ6IFwic3RhcnRcIixcbiAgICAgICAgcmlnaHQ6IFwiZW5kXCIsXG4gICAgICAgIHN0YXJ0OiBcInN0YXJ0XCIsXG4gICAgICAgIGVuZDogXCJlbmRcIlxuICAgICAgfVt0aGlzLnRleHRBbGlnbiA/PyBcInN0YXJ0XCJdXG4gICAgKTtcbiAgICBlbGVtZW50Mi5zZXRBdHRyaWJ1dGUoXG4gICAgICBcImFsaWdubWVudC1iYXNlbGluZVwiLFxuICAgICAge1xuICAgICAgICBhbHBoYWJldGljOiBcImFscGhhYmV0aWNcIixcbiAgICAgICAgdG9wOiBcInRvcFwiLFxuICAgICAgICBib3R0b206IFwiYm90dG9tXCIsXG4gICAgICAgIGhhbmdpbmc6IFwiaGFuZ2luZ1wiLFxuICAgICAgICBtaWRkbGU6IFwibWlkZGxlXCIsXG4gICAgICAgIGlkZW9ncmFwaGljOiBcImlkZW9ncmFwaGljXCJcbiAgICAgIH1bdGhpcy50ZXh0QmFzZWxpbmUgPz8gXCJhbHBoYWJldGljXCJdXG4gICAgKTtcbiAgICBlbGVtZW50Mi5zZXRBdHRyaWJ1dGUoXCJ4XCIsIFN0cmluZyh0aGlzLngpKTtcbiAgICBlbGVtZW50Mi5zZXRBdHRyaWJ1dGUoXCJ5XCIsIFN0cmluZyh0aGlzLnkpKTtcbiAgICBlbGVtZW50Mi50ZXh0Q29udGVudCA9IHRoaXMudGV4dCA/PyBcIlwiO1xuICAgIHJldHVybiB7IGVsZW1lbnRzOiBbZWxlbWVudDJdIH07XG4gIH1cbn07XG5fVGV4dC5jbGFzc05hbWUgPSBcIlRleHRcIjtcbl9UZXh0LmRlZmF1bHRTdHlsZXMgPSB7XG4gIC4uLlNoYXBlLmRlZmF1bHRTdHlsZXMsXG4gIHRleHRBbGlnbjogXCJzdGFydFwiLFxuICBmb250U3R5bGU6IHZvaWQgMCxcbiAgZm9udFdlaWdodDogdm9pZCAwLFxuICBmb250U2l6ZTogMTAsXG4gIGZvbnRGYW1pbHk6IFwic2Fucy1zZXJpZlwiLFxuICB0ZXh0QmFzZWxpbmU6IFwiYWxwaGFiZXRpY1wiXG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8gfSlcbl0sIF9UZXh0LnByb3RvdHlwZSwgXCJ4XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8gfSlcbl0sIF9UZXh0LnByb3RvdHlwZSwgXCJ5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8sIGNoYW5nZUNiOiAobykgPT4gby5vblRleHRDaGFuZ2UoKSB9KVxuXSwgX1RleHQucHJvdG90eXBlLCBcInRleHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbigpXG5dLCBfVGV4dC5wcm90b3R5cGUsIFwiZm9udFN0eWxlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgX1RleHQucHJvdG90eXBlLCBcImZvbnRXZWlnaHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbigpXG5dLCBfVGV4dC5wcm90b3R5cGUsIFwiZm9udFNpemVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbigpXG5dLCBfVGV4dC5wcm90b3R5cGUsIFwiZm9udEZhbWlseVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBfVGV4dC5wcm90b3R5cGUsIFwidGV4dEFsaWduXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8gfSlcbl0sIF9UZXh0LnByb3RvdHlwZSwgXCJ0ZXh0QmFzZWxpbmVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLyB9KVxuXSwgX1RleHQucHJvdG90eXBlLCBcImxpbmVIZWlnaHRcIiwgMik7XG52YXIgVGV4dCA9IF9UZXh0O1xudmFyIFJvdGF0YWJsZVRleHQgPSBjbGFzcyBleHRlbmRzIFJvdGF0YWJsZShUZXh0KSB7XG59O1xudmFyIFRyYW5zZm9ybWFibGVUZXh0ID0gY2xhc3MgZXh0ZW5kcyBSb3RhdGFibGUoVHJhbnNsYXRhYmxlKFRleHQpKSB7XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS91dGlsL2xhYmVsUGxhY2VtZW50LnRzXG5mdW5jdGlvbiBjaXJjbGVSZWN0T3ZlcmxhcChjLCB1bml0Q2VudGVyLCB4LCB5LCB3LCBoKSB7XG4gIGlmIChjLnNpemUgPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbGV0IGN4ID0gYy54O1xuICBsZXQgY3kgPSBjLnk7XG4gIGlmICh1bml0Q2VudGVyICE9IG51bGwpIHtcbiAgICBjeCAtPSAodW5pdENlbnRlci54IC0gMC41KSAqIGMuc2l6ZTtcbiAgICBjeSAtPSAodW5pdENlbnRlci55IC0gMC41KSAqIGMuc2l6ZTtcbiAgfVxuICBsZXQgZWRnZVggPSBjeDtcbiAgaWYgKGN4IDwgeCkge1xuICAgIGVkZ2VYID0geDtcbiAgfSBlbHNlIGlmIChjeCA+IHggKyB3KSB7XG4gICAgZWRnZVggPSB4ICsgdztcbiAgfVxuICBsZXQgZWRnZVkgPSBjeTtcbiAgaWYgKGN5IDwgeSkge1xuICAgIGVkZ2VZID0geTtcbiAgfSBlbHNlIGlmIChjeSA+IHkgKyBoKSB7XG4gICAgZWRnZVkgPSB5ICsgaDtcbiAgfVxuICBjb25zdCBkeCA9IGN4IC0gZWRnZVg7XG4gIGNvbnN0IGR5ID0gY3kgLSBlZGdlWTtcbiAgY29uc3QgZCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gIHJldHVybiBkIDw9IGMuc2l6ZSAqIDAuNTtcbn1cbmZ1bmN0aW9uIHJlY3RSZWN0T3ZlcmxhcChyMSwgeDIsIHkyLCB3MiwgaDIpIHtcbiAgY29uc3QgeE92ZXJsYXAgPSByMS54ICsgcjEud2lkdGggPiB4MiAmJiByMS54IDwgeDIgKyB3MjtcbiAgY29uc3QgeU92ZXJsYXAgPSByMS55ICsgcjEuaGVpZ2h0ID4geTIgJiYgcjEueSA8IHkyICsgaDI7XG4gIHJldHVybiB4T3ZlcmxhcCAmJiB5T3ZlcmxhcDtcbn1cbmZ1bmN0aW9uIHJlY3RDb250YWluc1JlY3QocjEsIHIyeCwgcjJ5LCByMncsIHIyaCkge1xuICByZXR1cm4gcjJ4ICsgcjJ3IDwgcjEueCArIHIxLndpZHRoICYmIHIyeCA+IHIxLnggJiYgcjJ5ID4gcjEueSAmJiByMnkgKyByMmggPCByMS55ICsgcjEuaGVpZ2h0O1xufVxuZnVuY3Rpb24gaXNQb2ludExhYmVsRGF0dW0oeCkge1xuICByZXR1cm4geCAhPSBudWxsICYmIHR5cGVvZiB4LnBvaW50ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiB4LmxhYmVsID09PSBcIm9iamVjdFwiO1xufVxudmFyIGxhYmVsUGxhY2VtZW50cyA9IHtcbiAgdG9wOiB7IHg6IDAsIHk6IC0xIH0sXG4gIGJvdHRvbTogeyB4OiAwLCB5OiAxIH0sXG4gIGxlZnQ6IHsgeDogLTEsIHk6IDAgfSxcbiAgcmlnaHQ6IHsgeDogMSwgeTogMCB9LFxuICBcInRvcC1sZWZ0XCI6IHsgeDogLTEsIHk6IC0xIH0sXG4gIFwidG9wLXJpZ2h0XCI6IHsgeDogMSwgeTogLTEgfSxcbiAgXCJib3R0b20tbGVmdFwiOiB7IHg6IC0xLCB5OiAxIH0sXG4gIFwiYm90dG9tLXJpZ2h0XCI6IHsgeDogMSwgeTogMSB9XG59O1xuZnVuY3Rpb24gcGxhY2VMYWJlbHMoZGF0YSwgYm91bmRzLCBwYWRkaW5nID0gNSkge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZGF0YSA9IGRhdGEubWFwKChkKSA9PiBkLnNsaWNlKCkuc29ydCgoYSwgYikgPT4gYi5wb2ludC5zaXplIC0gYS5wb2ludC5zaXplKSk7XG4gIGZvciAobGV0IGogPSAwOyBqIDwgZGF0YS5sZW5ndGg7IGorKykge1xuICAgIGNvbnN0IGxhYmVscyA9IHJlc3VsdFtqXSA9IFtdO1xuICAgIGNvbnN0IGRhdHVtID0gZGF0YVtqXTtcbiAgICBpZiAoIShkYXR1bT8ubGVuZ3RoICYmIGRhdHVtWzBdLmxhYmVsKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGZvciAobGV0IGluZGV4ID0gMCwgbG4gPSBkYXR1bS5sZW5ndGg7IGluZGV4IDwgbG47IGluZGV4KyspIHtcbiAgICAgIGNvbnN0IGQgPSBkYXR1bVtpbmRleF07XG4gICAgICBjb25zdCB7IHBvaW50LCBsYWJlbCwgbWFya2VyIH0gPSBkO1xuICAgICAgY29uc3QgeyB0ZXh0LCB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIgfSA9IGxhYmVsO1xuICAgICAgY29uc3QgciA9IHBvaW50LnNpemUgKiAwLjU7XG4gICAgICBsZXQgZHggPSAwO1xuICAgICAgbGV0IGR5ID0gMDtcbiAgICAgIGlmIChyID4gMCAmJiBkLnBsYWNlbWVudCAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHBsYWNlbWVudCA9IGxhYmVsUGxhY2VtZW50c1tkLnBsYWNlbWVudF07XG4gICAgICAgIGR4ID0gKHdpZHRoMiAqIDAuNSArIHIgKyBwYWRkaW5nKSAqIHBsYWNlbWVudC54O1xuICAgICAgICBkeSA9IChoZWlnaHQyICogMC41ICsgciArIHBhZGRpbmcpICogcGxhY2VtZW50Lnk7XG4gICAgICB9XG4gICAgICBjb25zdCB4ID0gcG9pbnQueCAtIHdpZHRoMiAqIDAuNSArIGR4IC0gKChtYXJrZXI/LmNlbnRlci54ID8/IDAuNSkgLSAwLjUpICogcG9pbnQuc2l6ZTtcbiAgICAgIGNvbnN0IHkgPSBwb2ludC55IC0gaGVpZ2h0MiAqIDAuNSArIGR5IC0gKChtYXJrZXI/LmNlbnRlci55ID8/IDAuNSkgLSAwLjUpICogcG9pbnQuc2l6ZTtcbiAgICAgIGNvbnN0IHdpdGhpbkJvdW5kcyA9ICFib3VuZHMgfHwgcmVjdENvbnRhaW5zUmVjdChib3VuZHMsIHgsIHksIHdpZHRoMiwgaGVpZ2h0Mik7XG4gICAgICBpZiAoIXdpdGhpbkJvdW5kcykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG92ZXJsYXBQb2ludHMgPSBkYXRhLnNvbWUoXG4gICAgICAgIChkYXRhRGF0dW1zKSA9PiBkYXRhRGF0dW1zLnNvbWUoXG4gICAgICAgICAgKGRhdGFEYXR1bSkgPT4gY2lyY2xlUmVjdE92ZXJsYXAoZGF0YURhdHVtLnBvaW50LCBkYXRhRGF0dW0ubWFya2VyPy5jZW50ZXIsIHgsIHksIHdpZHRoMiwgaGVpZ2h0MilcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIGlmIChvdmVybGFwUG9pbnRzKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3ZlcmxhcExhYmVscyA9IHJlc3VsdC5zb21lKChsMikgPT4gbDIuc29tZSgobDMpID0+IHJlY3RSZWN0T3ZlcmxhcChsMywgeCwgeSwgd2lkdGgyLCBoZWlnaHQyKSkpO1xuICAgICAgaWYgKG92ZXJsYXBMYWJlbHMpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBsYWJlbHMucHVzaCh7IGluZGV4LCB0ZXh0LCB4LCB5LCB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIsIGRhdHVtOiBkIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gYXhpc0xhYmVsc092ZXJsYXAoZGF0YSwgcGFkZGluZyA9IDApIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBkYXRhLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGNvbnN0IGRhdHVtID0gZGF0YVtpbmRleF07XG4gICAgY29uc3Qge1xuICAgICAgcG9pbnQ6IHsgeCwgeSB9LFxuICAgICAgbGFiZWw6IHsgdGV4dCB9XG4gICAgfSA9IGRhdHVtO1xuICAgIGxldCB7IHdpZHRoOiB3aWR0aDIsIGhlaWdodDogaGVpZ2h0MiB9ID0gZGF0dW0ubGFiZWw7XG4gICAgd2lkdGgyICs9IHBhZGRpbmc7XG4gICAgaGVpZ2h0MiArPSBwYWRkaW5nO1xuICAgIGlmIChyZXN1bHQuc29tZSgobCkgPT4gcmVjdFJlY3RPdmVybGFwKGwsIHgsIHksIHdpZHRoMiwgaGVpZ2h0MikpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2goeyBpbmRleCwgdGV4dCwgeCwgeSwgd2lkdGg6IHdpZHRoMiwgaGVpZ2h0OiBoZWlnaHQyLCBkYXR1bSB9KTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvZXF1YWwudHNcbmZ1bmN0aW9uIGFyZUFycmF5TnVtYmVyc0VxdWFsKGFyckEsIGFyckIpIHtcbiAgcmV0dXJuIGFyckEubGVuZ3RoID09PSBhcnJCLmxlbmd0aCAmJiBhcnJBLmV2ZXJ5KChpdGVtLCBpKSA9PiBOdW1iZXIoaXRlbSkgPT09IE51bWJlcihhcnJCW2ldKSk7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvanNvbi50c1xudmFyIENMQVNTX0lOU1RBTkNFX1RZUEUgPSBcImNsYXNzLWluc3RhbmNlXCI7XG5mdW5jdGlvbiBqc29uRGlmZihzb3VyY2UsIHRhcmdldCwgc2tpcCkge1xuICBpZiAoaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgaWYgKCFpc0FycmF5KHNvdXJjZSkgfHwgc291cmNlLmxlbmd0aCAhPT0gdGFyZ2V0Lmxlbmd0aCB8fCB0YXJnZXQuc29tZSgodiwgaSkgPT4ganNvbkRpZmYoc291cmNlW2ldLCB2KSAhPSBudWxsKSkge1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh0YXJnZXQpKSB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGNvbnN0IGFsbEtleXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gICAgICAuLi5PYmplY3Qua2V5cyhzb3VyY2UpLFxuICAgICAgLi4uT2JqZWN0LmtleXModGFyZ2V0KVxuICAgIF0pO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGFsbEtleXMpIHtcbiAgICAgIGlmIChzb3VyY2Vba2V5XSA9PT0gdGFyZ2V0W2tleV0gfHwgc2tpcD8uaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygc291cmNlW2tleV0gPT09IHR5cGVvZiB0YXJnZXRba2V5XSkge1xuICAgICAgICBjb25zdCBkaWZmMiA9IGpzb25EaWZmKHNvdXJjZVtrZXldLCB0YXJnZXRba2V5XSk7XG4gICAgICAgIGlmIChkaWZmMiAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gZGlmZjI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gdGFyZ2V0W2tleV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBPYmplY3Qua2V5cyhyZXN1bHQpLmxlbmd0aCA/IHJlc3VsdCA6IG51bGw7XG4gIH0gZWxzZSBpZiAoc291cmNlICE9PSB0YXJnZXQpIHtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZGVlcENsb25lKHNvdXJjZSwgb3B0aW9ucykge1xuICBpZiAoaXNBcnJheShzb3VyY2UpKSB7XG4gICAgcmV0dXJuIHNvdXJjZS5tYXAoKGl0ZW0pID0+IGRlZXBDbG9uZShpdGVtLCBvcHRpb25zKSk7XG4gIH1cbiAgaWYgKGlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xuICAgIHJldHVybiBtYXBWYWx1ZXMoXG4gICAgICBzb3VyY2UsXG4gICAgICAodmFsdWUsIGtleSkgPT4gb3B0aW9ucz8uc2hhbGxvdz8uaW5jbHVkZXMoa2V5KSA/IHNoYWxsb3dDbG9uZSh2YWx1ZSkgOiBkZWVwQ2xvbmUodmFsdWUsIG9wdGlvbnMpXG4gICAgKTtcbiAgfVxuICBpZiAoc291cmNlIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgcmV0dXJuIG5ldyBNYXAoZGVlcENsb25lKEFycmF5LmZyb20oc291cmNlKSkpO1xuICB9XG4gIHJldHVybiBzaGFsbG93Q2xvbmUoc291cmNlKTtcbn1cbmZ1bmN0aW9uIHNoYWxsb3dDbG9uZShzb3VyY2UpIHtcbiAgaWYgKGlzQXJyYXkoc291cmNlKSkge1xuICAgIHJldHVybiBbLi4uc291cmNlXTtcbiAgfVxuICBpZiAoaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgcmV0dXJuIHsgLi4uc291cmNlIH07XG4gIH1cbiAgaWYgKGlzRGF0ZShzb3VyY2UpKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHNvdXJjZSk7XG4gIH1cbiAgaWYgKGlzUmVnRXhwKHNvdXJjZSkpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChzb3VyY2Uuc291cmNlLCBzb3VyY2UuZmxhZ3MpO1xuICB9XG4gIHJldHVybiBzb3VyY2U7XG59XG5mdW5jdGlvbiBqc29uV2Fsayhqc29uLCB2aXNpdCwgb3B0cywgLi4uanNvbnMpIHtcbiAgaWYgKGlzQXJyYXkoanNvbikpIHtcbiAgICB2aXNpdChqc29uLCAuLi5qc29ucyk7XG4gICAganNvbi5mb3JFYWNoKChub2RlLCBpbmRleCkgPT4ge1xuICAgICAganNvbldhbGsobm9kZSwgdmlzaXQsIG9wdHMsIC4uLmtleU1hcHBlcihqc29ucywgaW5kZXgpKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KGpzb24pKSB7XG4gICAgdmlzaXQoanNvbiwgLi4uanNvbnMpO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGpzb24pKSB7XG4gICAgICBpZiAob3B0cz8uc2tpcD8uaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlID0ganNvbltrZXldO1xuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICAgIGpzb25XYWxrKHZhbHVlLCB2aXNpdCwgb3B0cywgLi4ua2V5TWFwcGVyKGpzb25zLCBrZXkpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGpzb25BcHBseSh0YXJnZXQsIHNvdXJjZSwgcGFyYW1zID0ge30pIHtcbiAgY29uc3QgeyBwYXRoLCBtYXRjaGVyUGF0aCA9IHBhdGg/LnJlcGxhY2UoLyhcXFtbMC05K10rXSkvaSwgXCJbXVwiKSwgc2tpcCA9IFtdIH0gPSBwYXJhbXM7XG4gIGlmICh0YXJnZXQgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQUcgQ2hhcnRzIC0gdGFyZ2V0IGlzIHVuaW5pdGlhbGlzZWQ6ICR7cGF0aCA/PyBcIjxyb290PlwifWApO1xuICB9XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkge1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgaWYgKGlzUHJvcGVydGllcyh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIHRhcmdldC5zZXQoc291cmNlKTtcbiAgfVxuICBjb25zdCB0YXJnZXRBbnkgPSB0YXJnZXQ7XG4gIGNvbnN0IHRhcmdldFR5cGUgPSBjbGFzc2lmeSh0YXJnZXQpO1xuICBmb3IgKGNvbnN0IHByb3BlcnR5IGluIHNvdXJjZSkge1xuICAgIGlmIChTS0lQX0pTX0JVSUxUSU5TLmhhcyhwcm9wZXJ0eSkpXG4gICAgICBjb250aW51ZTtcbiAgICBjb25zdCBwcm9wZXJ0eU1hdGNoZXJQYXRoID0gYCR7bWF0Y2hlclBhdGggPyBtYXRjaGVyUGF0aCArIFwiLlwiIDogXCJcIn0ke3Byb3BlcnR5fWA7XG4gICAgaWYgKHNraXAuaW5jbHVkZXMocHJvcGVydHlNYXRjaGVyUGF0aCkpXG4gICAgICBjb250aW51ZTtcbiAgICBjb25zdCBuZXdWYWx1ZSA9IHNvdXJjZVtwcm9wZXJ0eV07XG4gICAgY29uc3QgcHJvcGVydHlQYXRoID0gYCR7cGF0aCA/IHBhdGggKyBcIi5cIiA6IFwiXCJ9JHtwcm9wZXJ0eX1gO1xuICAgIGNvbnN0IHRhcmdldENsYXNzID0gdGFyZ2V0QW55LmNvbnN0cnVjdG9yO1xuICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHRhcmdldEFueVtwcm9wZXJ0eV07XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZVR5cGUgPSBjbGFzc2lmeShjdXJyZW50VmFsdWUpO1xuICAgICAgY29uc3QgbmV3VmFsdWVUeXBlID0gY2xhc3NpZnkobmV3VmFsdWUpO1xuICAgICAgaWYgKHRhcmdldFR5cGUgPT09IENMQVNTX0lOU1RBTkNFX1RZUEUgJiYgIShwcm9wZXJ0eSBpbiB0YXJnZXQpKSB7XG4gICAgICAgIExvZ2dlci53YXJuKGB1bmFibGUgdG8gc2V0IFske3Byb3BlcnR5UGF0aH1dIGluICR7dGFyZ2V0Q2xhc3M/Lm5hbWV9IC0gcHJvcGVydHkgaXMgdW5rbm93bmApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50VmFsdWVUeXBlICE9IG51bGwgJiYgbmV3VmFsdWVUeXBlICE9IG51bGwgJiYgbmV3VmFsdWVUeXBlICE9PSBjdXJyZW50VmFsdWVUeXBlICYmIChjdXJyZW50VmFsdWVUeXBlICE9PSBDTEFTU19JTlNUQU5DRV9UWVBFIHx8IG5ld1ZhbHVlVHlwZSAhPT0gXCJvYmplY3RcIikpIHtcbiAgICAgICAgTG9nZ2VyLndhcm4oXG4gICAgICAgICAgYHVuYWJsZSB0byBzZXQgWyR7cHJvcGVydHlQYXRofV0gaW4gJHt0YXJnZXRDbGFzcz8ubmFtZX0gLSBjYW4ndCBhcHBseSB0eXBlIG9mIFske25ld1ZhbHVlVHlwZX1dLCBhbGxvd2VkIHR5cGVzIGFyZTogWyR7Y3VycmVudFZhbHVlVHlwZX1dYFxuICAgICAgICApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1Byb3BlcnRpZXMoY3VycmVudFZhbHVlKSkge1xuICAgICAgICB0YXJnZXRBbnlbcHJvcGVydHldLnNldChuZXdWYWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKG5ld1ZhbHVlVHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBpZiAoY3VycmVudFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICB0YXJnZXRBbnlbcHJvcGVydHldID0ge307XG4gICAgICAgIH1cbiAgICAgICAganNvbkFwcGx5KGN1cnJlbnRWYWx1ZSA/PyB0YXJnZXRBbnlbcHJvcGVydHldLCBuZXdWYWx1ZSwge1xuICAgICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgICBwYXRoOiBwcm9wZXJ0eVBhdGgsXG4gICAgICAgICAgbWF0Y2hlclBhdGg6IHByb3BlcnR5TWF0Y2hlclBhdGhcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRBbnlbcHJvcGVydHldID0gbmV3VmFsdWU7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIExvZ2dlci53YXJuKGB1bmFibGUgdG8gc2V0IFske3Byb3BlcnR5UGF0aH1dIGluIFske3RhcmdldENsYXNzPy5uYW1lfV07IG5lc3RlZCBlcnJvciBpczogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24ga2V5TWFwcGVyKGRhdGEsIGtleSkge1xuICByZXR1cm4gZGF0YS5tYXAoKGRhdGFPYmplY3QpID0+IGRhdGFPYmplY3Q/LltrZXldKTtcbn1cbmZ1bmN0aW9uIGNsYXNzaWZ5KHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGlzSHRtbEVsZW1lbnQodmFsdWUpIHx8IGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gXCJwcmltaXRpdmVcIjtcbiAgfVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gXCJhcnJheVwiO1xuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gaXNQbGFpbk9iamVjdCh2YWx1ZSkgPyBcIm9iamVjdFwiIDogQ0xBU1NfSU5TVEFOQ0VfVFlQRTtcbiAgfVxuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICByZXR1cm4gXCJmdW5jdGlvblwiO1xuICB9XG4gIHJldHVybiBcInByaW1pdGl2ZVwiO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3Byb3h5LnRzXG5mdW5jdGlvbiBQcm94eVByb3BlcnR5KHByb3h5UGF0aCwgY29uZmlnTWV0YWRhdGEpIHtcbiAgY29uc3QgcGF0aEFycmF5ID0gaXNBcnJheShwcm94eVBhdGgpID8gcHJveHlQYXRoIDogcHJveHlQYXRoLnNwbGl0KFwiLlwiKTtcbiAgaWYgKHBhdGhBcnJheS5sZW5ndGggPT09IDEpIHtcbiAgICBjb25zdCBbcHJvcGVydHldID0gcGF0aEFycmF5O1xuICAgIHJldHVybiBhZGRUcmFuc2Zvcm1Ub0luc3RhbmNlUHJvcGVydHkoXG4gICAgICAodGFyZ2V0LCBfLCB2YWx1ZSkgPT4gdGFyZ2V0W3Byb3BlcnR5XSA9IHZhbHVlLFxuICAgICAgKHRhcmdldCkgPT4gdGFyZ2V0W3Byb3BlcnR5XSxcbiAgICAgIGNvbmZpZ01ldGFkYXRhXG4gICAgKTtcbiAgfVxuICByZXR1cm4gYWRkVHJhbnNmb3JtVG9JbnN0YW5jZVByb3BlcnR5KFxuICAgICh0YXJnZXQsIF8sIHZhbHVlKSA9PiBzZXRQYXRoKHRhcmdldCwgcGF0aEFycmF5LCB2YWx1ZSksXG4gICAgKHRhcmdldCkgPT4gZ2V0UGF0aCh0YXJnZXQsIHBhdGhBcnJheSksXG4gICAgY29uZmlnTWV0YWRhdGFcbiAgKTtcbn1cbmZ1bmN0aW9uIFByb3h5T25Xcml0ZShwcm94eVByb3BlcnR5KSB7XG4gIHJldHVybiBhZGRUcmFuc2Zvcm1Ub0luc3RhbmNlUHJvcGVydHkoKHRhcmdldCwgXywgdmFsdWUpID0+IHRhcmdldFtwcm94eVByb3BlcnR5XSA9IHZhbHVlKTtcbn1cbmZ1bmN0aW9uIFByb3h5UHJvcGVydHlPbldyaXRlKGNoaWxkTmFtZSwgY2hpbGRQcm9wZXJ0eSkge1xuICByZXR1cm4gYWRkVHJhbnNmb3JtVG9JbnN0YW5jZVByb3BlcnR5KCh0YXJnZXQsIGtleSwgdmFsdWUpID0+IHRhcmdldFtjaGlsZE5hbWVdW2NoaWxkUHJvcGVydHkgPz8ga2V5XSA9IHZhbHVlKTtcbn1cbmZ1bmN0aW9uIEFjdGlvbk9uU2V0KG9wdHMpIHtcbiAgY29uc3QgeyBuZXdWYWx1ZTogbmV3VmFsdWVGbiwgb2xkVmFsdWU6IG9sZFZhbHVlRm4sIGNoYW5nZVZhbHVlOiBjaGFuZ2VWYWx1ZUZuIH0gPSBvcHRzO1xuICByZXR1cm4gYWRkVHJhbnNmb3JtVG9JbnN0YW5jZVByb3BlcnR5KCh0YXJnZXQsIF8sIG5ld1ZhbHVlLCBvbGRWYWx1ZSkgPT4ge1xuICAgIGlmIChuZXdWYWx1ZSAhPT0gb2xkVmFsdWUpIHtcbiAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIG9sZFZhbHVlRm4/LmNhbGwodGFyZ2V0LCBvbGRWYWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAobmV3VmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICBuZXdWYWx1ZUZuPy5jYWxsKHRhcmdldCwgbmV3VmFsdWUpO1xuICAgICAgfVxuICAgICAgY2hhbmdlVmFsdWVGbj8uY2FsbCh0YXJnZXQsIG5ld1ZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBuZXdWYWx1ZTtcbiAgfSk7XG59XG5mdW5jdGlvbiBPYnNlcnZlQ2hhbmdlcyhvYnNlcnZlckZuKSB7XG4gIHJldHVybiBhZGRPYnNlcnZlclRvSW5zdGFuY2VQcm9wZXJ0eShvYnNlcnZlckZuKTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9zdGF0ZU1hY2hpbmUudHNcbnZhciBkZWJ1Z0NvbG9yID0gXCJjb2xvcjogZ3JlZW5cIjtcbnZhciBkZWJ1Z1F1aWV0Q29sb3IgPSBcImNvbG9yOiBncmV5XCI7XG52YXIgX1N0YXRlTWFjaGluZSA9IGNsYXNzIF9TdGF0ZU1hY2hpbmUge1xuICBjb25zdHJ1Y3RvcihkZWZhdWx0U3RhdGUsIHN0YXRlcywgZW50ZXJFYWNoKSB7XG4gICAgdGhpcy5kZWZhdWx0U3RhdGUgPSBkZWZhdWx0U3RhdGU7XG4gICAgdGhpcy5zdGF0ZXMgPSBzdGF0ZXM7XG4gICAgdGhpcy5lbnRlckVhY2ggPSBlbnRlckVhY2g7XG4gICAgdGhpcy5kZWJ1ZyA9IERlYnVnLmNyZWF0ZSh0cnVlLCBcImFuaW1hdGlvblwiKTtcbiAgICB0aGlzLnN0YXRlID0gZGVmYXVsdFN0YXRlO1xuICAgIHRoaXMuZGVidWcoYCVjJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9IHwgaW5pdCAtPiAke2RlZmF1bHRTdGF0ZX1gLCBkZWJ1Z0NvbG9yKTtcbiAgfVxuICB0cmFuc2l0aW9uKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3Qgc2hvdWxkVHJhbnNpdGlvblNlbGYgPSB0aGlzLnRyYW5zaXRpb25DaGlsZChldmVudCwgZGF0YSk7XG4gICAgaWYgKCFzaG91bGRUcmFuc2l0aW9uU2VsZiB8fCB0aGlzLnN0YXRlID09PSBfU3RhdGVNYWNoaW5lLmNoaWxkIHx8IHRoaXMuc3RhdGUgPT09IF9TdGF0ZU1hY2hpbmUucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgY3VycmVudFN0YXRlQ29uZmlnID0gdGhpcy5zdGF0ZXNbdGhpcy5zdGF0ZV07XG4gICAgbGV0IGRlc3RpbmF0aW9uID0gY3VycmVudFN0YXRlQ29uZmlnW2V2ZW50XTtcbiAgICBjb25zdCBkZWJ1Z1ByZWZpeCA9IGAlYyR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSB8ICR7dGhpcy5zdGF0ZX0gLT4gJHtldmVudH0gLT5gO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGRlc3RpbmF0aW9uKSkge1xuICAgICAgZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbi5maW5kKCh0cmFuc2l0aW9uKSA9PiB7XG4gICAgICAgIGlmICghdHJhbnNpdGlvbi5ndWFyZClcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY29uc3QgdmFsaWQgPSB0cmFuc2l0aW9uLmd1YXJkKGRhdGEpO1xuICAgICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgICAgdGhpcy5kZWJ1ZyhgJHtkZWJ1Z1ByZWZpeH0gJHt0cmFuc2l0aW9uLnRhcmdldH0gKGd1YXJkZWQpYCwgZGVidWdRdWlldENvbG9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsaWQ7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZXN0aW5hdGlvbiA9PT0gXCJvYmplY3RcIiAmJiAhKGRlc3RpbmF0aW9uIGluc3RhbmNlb2YgX1N0YXRlTWFjaGluZSkgJiYgZGVzdGluYXRpb24uZ3VhcmQgJiYgIWRlc3RpbmF0aW9uLmd1YXJkKGRhdGEpKSB7XG4gICAgICB0aGlzLmRlYnVnKGAke2RlYnVnUHJlZml4fSAke2Rlc3RpbmF0aW9uLnRhcmdldH0gKGd1YXJkZWQpYCwgZGVidWdRdWlldENvbG9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFkZXN0aW5hdGlvbikge1xuICAgICAgdGhpcy5kZWJ1ZyhgJHtkZWJ1Z1ByZWZpeH0gJHt0aGlzLnN0YXRlfWAsIGRlYnVnUXVpZXRDb2xvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRlc3RpbmF0aW9uU3RhdGUgPSB0aGlzLmdldERlc3RpbmF0aW9uU3RhdGUoZGVzdGluYXRpb24pO1xuICAgIGNvbnN0IGV4aXRGbiA9IGRlc3RpbmF0aW9uU3RhdGUgPT09IHRoaXMuc3RhdGUgPyB2b2lkIDAgOiBjdXJyZW50U3RhdGVDb25maWcub25FeGl0O1xuICAgIHRoaXMuZGVidWcoYCR7ZGVidWdQcmVmaXh9ICR7ZGVzdGluYXRpb25TdGF0ZX1gLCBkZWJ1Z0NvbG9yKTtcbiAgICB0aGlzLnN0YXRlID0gZGVzdGluYXRpb25TdGF0ZTtcbiAgICBpZiAodHlwZW9mIGRlc3RpbmF0aW9uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGRlc3RpbmF0aW9uKGRhdGEpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlc3RpbmF0aW9uID09PSBcIm9iamVjdFwiICYmICEoZGVzdGluYXRpb24gaW5zdGFuY2VvZiBfU3RhdGVNYWNoaW5lKSkge1xuICAgICAgZGVzdGluYXRpb24uYWN0aW9uPy4oZGF0YSk7XG4gICAgfVxuICAgIGV4aXRGbj8uKCk7XG4gICAgdGhpcy5lbnRlckVhY2g/LihjdXJyZW50U3RhdGUsIGRlc3RpbmF0aW9uU3RhdGUpO1xuICAgIGlmIChkZXN0aW5hdGlvblN0YXRlICE9PSBjdXJyZW50U3RhdGUgJiYgZGVzdGluYXRpb25TdGF0ZSAhPT0gX1N0YXRlTWFjaGluZS5jaGlsZCAmJiBkZXN0aW5hdGlvblN0YXRlICE9PSBfU3RhdGVNYWNoaW5lLnBhcmVudCkge1xuICAgICAgdGhpcy5zdGF0ZXNbZGVzdGluYXRpb25TdGF0ZV0ub25FbnRlcj8uKGN1cnJlbnRTdGF0ZSwgZGF0YSk7XG4gICAgfVxuICB9XG4gIHRyYW5zaXRpb25Bc3luYyhldmVudCwgZGF0YSkge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy50cmFuc2l0aW9uKGV2ZW50LCBkYXRhKTtcbiAgICB9LCAwKTtcbiAgfVxuICBpcyh2YWx1ZSkge1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBfU3RhdGVNYWNoaW5lLmNoaWxkICYmIHRoaXMuY2hpbGRTdGF0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2hpbGRTdGF0ZS5pcyh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnN0YXRlID09PSB2YWx1ZTtcbiAgfVxuICByZXNldEhpZXJhcmNoeSgpIHtcbiAgICB0aGlzLmRlYnVnKFxuICAgICAgYCVjJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9IHwgJHt0aGlzLnN0YXRlfSAtPiBbcmVzZXRIaWVyYXJjaHldIC0+ICR7dGhpcy5kZWZhdWx0U3RhdGV9YCxcbiAgICAgIFwiY29sb3I6IGdyZWVuXCJcbiAgICApO1xuICAgIHRoaXMuc3RhdGUgPSB0aGlzLmRlZmF1bHRTdGF0ZTtcbiAgfVxuICB0cmFuc2l0aW9uQ2hpbGQoZXZlbnQsIGRhdGEpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gX1N0YXRlTWFjaGluZS5jaGlsZCB8fCAhdGhpcy5jaGlsZFN0YXRlKVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgdGhpcy5jaGlsZFN0YXRlLnRyYW5zaXRpb24oZXZlbnQsIGRhdGEpO1xuICAgIGlmICghdGhpcy5jaGlsZFN0YXRlLmlzKF9TdGF0ZU1hY2hpbmUucGFyZW50KSlcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIHRoaXMuZGVidWcoYCVjJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9IHwgJHt0aGlzLnN0YXRlfSAtPiAke2V2ZW50fSAtPiAke3RoaXMuZGVmYXVsdFN0YXRlfWAsIGRlYnVnQ29sb3IpO1xuICAgIHRoaXMuc3RhdGUgPSB0aGlzLmRlZmF1bHRTdGF0ZTtcbiAgICB0aGlzLnN0YXRlc1t0aGlzLnN0YXRlXS5vbkVudGVyPy4oKTtcbiAgICB0aGlzLmNoaWxkU3RhdGUucmVzZXRIaWVyYXJjaHkoKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZ2V0RGVzdGluYXRpb25TdGF0ZShkZXN0aW5hdGlvbikge1xuICAgIGxldCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHR5cGVvZiBkZXN0aW5hdGlvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgc3RhdGUgPSBkZXN0aW5hdGlvbjtcbiAgICB9IGVsc2UgaWYgKGRlc3RpbmF0aW9uIGluc3RhbmNlb2YgX1N0YXRlTWFjaGluZSkge1xuICAgICAgdGhpcy5jaGlsZFN0YXRlID0gZGVzdGluYXRpb247XG4gICAgICBzdGF0ZSA9IF9TdGF0ZU1hY2hpbmUuY2hpbGQ7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGVzdGluYXRpb24gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGlmIChkZXN0aW5hdGlvbi50YXJnZXQgaW5zdGFuY2VvZiBfU3RhdGVNYWNoaW5lKSB7XG4gICAgICAgIHRoaXMuY2hpbGRTdGF0ZSA9IGRlc3RpbmF0aW9uLnRhcmdldDtcbiAgICAgICAgc3RhdGUgPSBfU3RhdGVNYWNoaW5lLmNoaWxkO1xuICAgICAgfSBlbHNlIGlmIChkZXN0aW5hdGlvbi50YXJnZXQgIT0gbnVsbCkge1xuICAgICAgICBzdGF0ZSA9IGRlc3RpbmF0aW9uLnRhcmdldDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG59O1xuX1N0YXRlTWFjaGluZS5jaGlsZCA9IFwiX19jaGlsZFwiO1xuX1N0YXRlTWFjaGluZS5wYXJlbnQgPSBcIl9fcGFyZW50XCI7XG52YXIgU3RhdGVNYWNoaW5lID0gX1N0YXRlTWFjaGluZTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC90ZXh0V3JhcHBlci50c1xudmFyIFRleHRXcmFwcGVyID0gY2xhc3Mge1xuICBzdGF0aWMgd3JhcFRleHQodGV4dCwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLndyYXBMaW5lcyh0ZXh0LCBvcHRpb25zKS5qb2luKFwiXFxuXCIpO1xuICB9XG4gIHN0YXRpYyB3cmFwTGluZXModGV4dCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGNsaXBwZWRSZXN1bHQgPSB0aGlzLnRleHRXcmFwKHRleHQsIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLm92ZXJmbG93ID09PSBcImhpZGVcIiAmJiBjbGlwcGVkUmVzdWx0LnNvbWUoKGwpID0+IGwuZW5kc1dpdGgoVGV4dFV0aWxzLkVsbGlwc2lzQ2hhcikpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiBjbGlwcGVkUmVzdWx0O1xuICB9XG4gIHN0YXRpYyBhcHBlbmRFbGxpcHNpcyh0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHQucmVwbGFjZSgvWy4sXXsxLDV9JC8sIFwiXCIpICsgVGV4dFV0aWxzLkVsbGlwc2lzQ2hhcjtcbiAgfVxuICBzdGF0aWMgdHJ1bmNhdGVMaW5lKHRleHQsIG1lYXN1cmVyLCBtYXhXaWR0aCwgZWxsaXBzaXNGb3JjZSkge1xuICAgIGNvbnN0IGVsbGlwc2lzV2lkdGggPSBtZWFzdXJlci50ZXh0V2lkdGgoVGV4dFV0aWxzLkVsbGlwc2lzQ2hhcik7XG4gICAgbGV0IGVzdGltYXRlZFdpZHRoID0gMDtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yICg7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGFyV2lkdGggPSBtZWFzdXJlci50ZXh0V2lkdGgodGV4dC5jaGFyQXQoaSkpO1xuICAgICAgaWYgKGVzdGltYXRlZFdpZHRoICsgY2hhcldpZHRoID4gbWF4V2lkdGgpXG4gICAgICAgIGJyZWFrO1xuICAgICAgZXN0aW1hdGVkV2lkdGggKz0gY2hhcldpZHRoO1xuICAgIH1cbiAgICBpZiAodGV4dC5sZW5ndGggPT09IGkgJiYgKCFlbGxpcHNpc0ZvcmNlIHx8IGVzdGltYXRlZFdpZHRoICsgZWxsaXBzaXNXaWR0aCA8PSBtYXhXaWR0aCkpIHtcbiAgICAgIHJldHVybiBlbGxpcHNpc0ZvcmNlID8gdGV4dCArIFRleHRVdGlscy5FbGxpcHNpc0NoYXIgOiB0ZXh0O1xuICAgIH1cbiAgICB0ZXh0ID0gdGV4dC5zbGljZSgwLCBpKS50cmltRW5kKCk7XG4gICAgd2hpbGUgKHRleHQubGVuZ3RoICYmIG1lYXN1cmVyLnRleHRXaWR0aCh0ZXh0KSArIGVsbGlwc2lzV2lkdGggPiBtYXhXaWR0aCkge1xuICAgICAgdGV4dCA9IHRleHQuc2xpY2UoMCwgLTEpLnRyaW1FbmQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRleHQgKyBUZXh0VXRpbHMuRWxsaXBzaXNDaGFyO1xuICB9XG4gIHN0YXRpYyB0ZXh0V3JhcCh0ZXh0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgbGluZXMgPSB0ZXh0LnNwbGl0KFRleHRVdGlscy5saW5lU3BsaXR0ZXIpO1xuICAgIGNvbnN0IG1lYXN1cmVyID0gQ2FjaGVkVGV4dE1lYXN1cmVyUG9vbC5nZXRNZWFzdXJlcihvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy50ZXh0V3JhcCA9PT0gXCJuZXZlclwiKSB7XG4gICAgICByZXR1cm4gbGluZXMubWFwKChsaW5lKSA9PiB0aGlzLnRydW5jYXRlTGluZShsaW5lLnRyaW1FbmQoKSwgbWVhc3VyZXIsIG9wdGlvbnMubWF4V2lkdGgpKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3Qgd3JhcEh5cGhlbmF0ZSA9IG9wdGlvbnMudGV4dFdyYXAgPT09IFwiaHlwaGVuYXRlXCI7XG4gICAgY29uc3Qgd3JhcE9uU3BhY2UgPSBvcHRpb25zLnRleHRXcmFwID09IG51bGwgfHwgb3B0aW9ucy50ZXh0V3JhcCA9PT0gXCJvbi1zcGFjZVwiO1xuICAgIGZvciAobGV0IGxpbmUgb2YgbGluZXMpIHtcbiAgICAgIGxpbmUgPSBsaW5lLnRyaW1FbmQoKTtcbiAgICAgIGlmIChsaW5lID09PSBcIlwiKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGxpbmUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwLCBlc3RpbWF0ZWRXaWR0aCA9IDAsIGxhc3RTcGFjZUluZGV4ID0gMDsgaSA8IGxpbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hhciA9IGxpbmUuY2hhckF0KGkpO1xuICAgICAgICBlc3RpbWF0ZWRXaWR0aCArPSBtZWFzdXJlci50ZXh0V2lkdGgoY2hhcik7XG4gICAgICAgIGlmIChjaGFyID09PSBcIiBcIikge1xuICAgICAgICAgIGxhc3RTcGFjZUluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXN0aW1hdGVkV2lkdGggPiBvcHRpb25zLm1heFdpZHRoKSB7XG4gICAgICAgICAgaWYgKGkgPT09IDApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjb25zdCBhY3R1YWxXaWR0aCA9IG1lYXN1cmVyLnRleHRXaWR0aChsaW5lLnNsaWNlKDAsIGkgKyAxKSk7XG4gICAgICAgICAgaWYgKGFjdHVhbFdpZHRoIDw9IG9wdGlvbnMubWF4V2lkdGgpIHtcbiAgICAgICAgICAgIGVzdGltYXRlZFdpZHRoID0gYWN0dWFsV2lkdGg7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxhc3RTcGFjZUluZGV4KSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0V29yZCA9IHRoaXMuZ2V0V29yZEF0KGxpbmUsIGxhc3RTcGFjZUluZGV4ICsgMSk7XG4gICAgICAgICAgICBjb25zdCB0ZXh0V2lkdGggPSBtZWFzdXJlci50ZXh0V2lkdGgobmV4dFdvcmQpO1xuICAgICAgICAgICAgaWYgKHRleHRXaWR0aCA8PSBvcHRpb25zLm1heFdpZHRoKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGxpbmUuc2xpY2UoMCwgbGFzdFNwYWNlSW5kZXgpLnRyaW1FbmQoKSk7XG4gICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnNsaWNlKGxhc3RTcGFjZUluZGV4KS50cmltU3RhcnQoKTtcbiAgICAgICAgICAgICAgaSA9IC0xO1xuICAgICAgICAgICAgICBlc3RpbWF0ZWRXaWR0aCA9IDA7XG4gICAgICAgICAgICAgIGxhc3RTcGFjZUluZGV4ID0gMDtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHdyYXBPblNwYWNlICYmIHRleHRXaWR0aCA+IG9wdGlvbnMubWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgICAgICAgbGluZS5zbGljZSgwLCBsYXN0U3BhY2VJbmRleCkudHJpbUVuZCgpLFxuICAgICAgICAgICAgICAgIHRoaXMudHJ1bmNhdGVMaW5lKFxuICAgICAgICAgICAgICAgICAgbGluZS5zbGljZShsYXN0U3BhY2VJbmRleCkudHJpbVN0YXJ0KCksXG4gICAgICAgICAgICAgICAgICBtZWFzdXJlcixcbiAgICAgICAgICAgICAgICAgIG9wdGlvbnMubWF4V2lkdGgsXG4gICAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAod3JhcE9uU3BhY2UpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMudHJ1bmNhdGVMaW5lKGxpbmUsIG1lYXN1cmVyLCBvcHRpb25zLm1heFdpZHRoLCB0cnVlKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh3cmFwT25TcGFjZSkge1xuICAgICAgICAgICAgbGluZSA9IFwiXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgcG9zdGZpeCA9IHdyYXBIeXBoZW5hdGUgPyBcIi1cIiA6IFwiXCI7XG4gICAgICAgICAgbGV0IG5ld0xpbmUgPSBsaW5lLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgICAgICAgICB3aGlsZSAobmV3TGluZS5sZW5ndGggJiYgbWVhc3VyZXIudGV4dFdpZHRoKG5ld0xpbmUgKyBwb3N0Zml4KSA+IG9wdGlvbnMubWF4V2lkdGgpIHtcbiAgICAgICAgICAgIG5ld0xpbmUgPSBuZXdMaW5lLnNsaWNlKDAsIC0xKS50cmltRW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld0xpbmUgKyBwb3N0Zml4KTtcbiAgICAgICAgICBpZiAoIW5ld0xpbmUubGVuZ3RoKSB7XG4gICAgICAgICAgICBsaW5lID0gXCJcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsaW5lID0gbGluZS5zbGljZShuZXdMaW5lLmxlbmd0aCkudHJpbVN0YXJ0KCk7XG4gICAgICAgICAgaSA9IC0xO1xuICAgICAgICAgIGVzdGltYXRlZFdpZHRoID0gMDtcbiAgICAgICAgICBsYXN0U3BhY2VJbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsaW5lKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGxpbmUpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmF2b2lkT3JwaGFucyhyZXN1bHQsIG1lYXN1cmVyLCBvcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcy5jbGlwTGluZXMocmVzdWx0LCBtZWFzdXJlciwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGdldFdvcmRBdCh0ZXh0LCBwb3NpdGlvbikge1xuICAgIGNvbnN0IG5leHRTcGFjZUluZGV4ID0gdGV4dC5pbmRleE9mKFwiIFwiLCBwb3NpdGlvbik7XG4gICAgcmV0dXJuIG5leHRTcGFjZUluZGV4ID09PSAtMSA/IHRleHQuc2xpY2UocG9zaXRpb24pIDogdGV4dC5zbGljZShwb3NpdGlvbiwgbmV4dFNwYWNlSW5kZXgpO1xuICB9XG4gIHN0YXRpYyBjbGlwTGluZXMobGluZXMsIG1lYXN1cmVyLCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLm1heEhlaWdodCkge1xuICAgICAgcmV0dXJuIGxpbmVzO1xuICAgIH1cbiAgICBjb25zdCB7IGhlaWdodDogaGVpZ2h0MiwgbGluZU1ldHJpY3MgfSA9IG1lYXN1cmVyLm1lYXN1cmVMaW5lcyhsaW5lcyk7XG4gICAgaWYgKGhlaWdodDIgPD0gb3B0aW9ucy5tYXhIZWlnaHQpIHtcbiAgICAgIHJldHVybiBsaW5lcztcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIGN1bXVsYXRpdmVIZWlnaHQgPSAwOyBpIDwgbGluZU1ldHJpY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHsgbGluZUhlaWdodCB9ID0gbGluZU1ldHJpY3NbaV07XG4gICAgICBjdW11bGF0aXZlSGVpZ2h0ICs9IGxpbmVIZWlnaHQ7XG4gICAgICBpZiAoY3VtdWxhdGl2ZUhlaWdodCA+IG9wdGlvbnMubWF4SGVpZ2h0KSB7XG4gICAgICAgIGlmIChvcHRpb25zLm92ZXJmbG93ID09PSBcImhpZGVcIikge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjbGlwcGVkUmVzdWx0cyA9IGxpbmVzLnNsaWNlKDAsIGkgfHwgMSk7XG4gICAgICAgIGNvbnN0IGxhc3RMaW5lID0gY2xpcHBlZFJlc3VsdHMucG9wKCk7XG4gICAgICAgIHJldHVybiBjbGlwcGVkUmVzdWx0cy5jb25jYXQodGhpcy50cnVuY2F0ZUxpbmUobGFzdExpbmUsIG1lYXN1cmVyLCBvcHRpb25zLm1heFdpZHRoLCB0cnVlKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsaW5lcztcbiAgfVxuICBzdGF0aWMgYXZvaWRPcnBoYW5zKGxpbmVzLCBtZWFzdXJlciwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmF2b2lkT3JwaGFucyA9PT0gZmFsc2UgfHwgbGluZXMubGVuZ3RoIDwgMilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IGxlbmd0aDogbGVuZ3RoMiB9ID0gbGluZXM7XG4gICAgY29uc3QgbGFzdExpbmUgPSBsaW5lc1tsZW5ndGgyIC0gMV07XG4gICAgY29uc3QgYmVmb3JlTGFzdCA9IGxpbmVzW2xlbmd0aDIgLSAyXTtcbiAgICBpZiAoYmVmb3JlTGFzdC5sZW5ndGggPCBsYXN0TGluZS5sZW5ndGgpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbGFzdFNwYWNlSW5kZXggPSBiZWZvcmVMYXN0Lmxhc3RJbmRleE9mKFwiIFwiKTtcbiAgICBpZiAobGFzdFNwYWNlSW5kZXggPT09IC0xIHx8IGxhc3RTcGFjZUluZGV4ID09PSBiZWZvcmVMYXN0LmluZGV4T2YoXCIgXCIpIHx8IGxhc3RMaW5lLmluY2x1ZGVzKFwiIFwiKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBsYXN0V29yZCA9IGJlZm9yZUxhc3Quc2xpY2UobGFzdFNwYWNlSW5kZXggKyAxKTtcbiAgICBpZiAobWVhc3VyZXIudGV4dFdpZHRoKGxhc3RMaW5lICsgbGFzdFdvcmQpIDw9IG9wdGlvbnMubWF4V2lkdGgpIHtcbiAgICAgIGxpbmVzW2xlbmd0aDIgLSAyXSA9IGJlZm9yZUxhc3Quc2xpY2UoMCwgbGFzdFNwYWNlSW5kZXgpO1xuICAgICAgbGluZXNbbGVuZ3RoMiAtIDFdID0gbGFzdFdvcmQgKyBcIiBcIiArIGxhc3RMaW5lO1xuICAgIH1cbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvbW9kdWxlL2VudGVycHJpc2VNb2R1bGUudHNcbnZhciBlbnRlcnByaXNlTW9kdWxlID0ge1xuICBpc0VudGVycHJpc2U6IGZhbHNlXG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2F0dHJpYnV0ZVV0aWwudHNcbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZShlLCBxdWFsaWZpZWROYW1lLCB2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IHZvaWQgMCB8fCB2YWx1ZSA9PT0gXCJcIikge1xuICAgIGU/LnJlbW92ZUF0dHJpYnV0ZShxdWFsaWZpZWROYW1lKTtcbiAgfSBlbHNlIHtcbiAgICBlPy5zZXRBdHRyaWJ1dGUocXVhbGlmaWVkTmFtZSwgdmFsdWUudG9TdHJpbmcoKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZXMoZSwgYXR0cnMpIHtcbiAgaWYgKGF0dHJzID09IG51bGwpXG4gICAgcmV0dXJuO1xuICBsZXQga2V5O1xuICBmb3IgKGtleSBpbiBhdHRycykge1xuICAgIGlmIChrZXkgPT09IFwiY2xhc3NcIilcbiAgICAgIGNvbnRpbnVlO1xuICAgIHNldEF0dHJpYnV0ZShlLCBrZXksIGF0dHJzW2tleV0pO1xuICB9XG59XG5mdW5jdGlvbiBnZXRBdHRyaWJ1dGUoZSwgcXVhbGlmaWVkTmFtZSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICghKGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpXG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgY29uc3QgdmFsdWUgPSBlLmdldEF0dHJpYnV0ZShxdWFsaWZpZWROYW1lKTtcbiAgaWYgKHZhbHVlID09PSBudWxsKVxuICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gIGNvbnN0IHR5cGUgPSB0eXBlb2Yge31bcXVhbGlmaWVkTmFtZV07XG4gIGlmICh0eXBlID09PSBcImJvb2xlYW5cIilcbiAgICByZXR1cm4gdmFsdWUgPT09IFwidHJ1ZVwiO1xuICBpZiAodHlwZSA9PT0gXCJudW1iZXJcIilcbiAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcbiAgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIHZhbHVlO1xuICByZXR1cm4gdm9pZCAwO1xufVxuZnVuY3Rpb24gc2V0RWxlbWVudFN0eWxlKGUsIHByb3BlcnR5LCB2YWx1ZSkge1xuICBpZiAoZSA9PSBudWxsKVxuICAgIHJldHVybjtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICBlLnN0eWxlLnJlbW92ZVByb3BlcnR5KHByb3BlcnR5KTtcbiAgfSBlbHNlIHtcbiAgICBlLnN0eWxlLnNldFByb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSk7XG4gIH1cbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9wbGFjZW1lbnQudHNcbmZ1bmN0aW9uIGNhbGN1bGF0ZVBsYWNlbWVudChuYXR1cmFsV2lkdGgsIG5hdHVyYWxIZWlnaHQsIGNvbnRhaW5lciwgYm91bmRzKSB7XG4gIGxldCB7IHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCwgd2lkdGg6IHdpZHRoMiwgaGVpZ2h0OiBoZWlnaHQyIH0gPSBib3VuZHM7XG4gIGlmIChsZWZ0ICE9IG51bGwpIHtcbiAgICBpZiAod2lkdGgyICE9IG51bGwpIHtcbiAgICAgIHJpZ2h0ID0gY29udGFpbmVyLndpZHRoIC0gbGVmdCArIHdpZHRoMjtcbiAgICB9IGVsc2UgaWYgKHJpZ2h0ICE9IG51bGwpIHtcbiAgICAgIHdpZHRoMiA9IGNvbnRhaW5lci53aWR0aCAtIGxlZnQgLSByaWdodDtcbiAgICB9XG4gIH0gZWxzZSBpZiAocmlnaHQgIT0gbnVsbCAmJiB3aWR0aDIgIT0gbnVsbCkge1xuICAgIGxlZnQgPSBjb250YWluZXIud2lkdGggLSByaWdodCAtIHdpZHRoMjtcbiAgfVxuICBpZiAodG9wICE9IG51bGwpIHtcbiAgICBpZiAoaGVpZ2h0MiAhPSBudWxsKSB7XG4gICAgICBib3R0b20gPSBjb250YWluZXIuaGVpZ2h0IC0gdG9wIC0gaGVpZ2h0MjtcbiAgICB9IGVsc2UgaWYgKGJvdHRvbSAhPSBudWxsKSB7XG4gICAgICBoZWlnaHQyID0gY29udGFpbmVyLmhlaWdodCAtIGJvdHRvbSAtIHRvcDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYm90dG9tICE9IG51bGwgJiYgaGVpZ2h0MiAhPSBudWxsKSB7XG4gICAgdG9wID0gY29udGFpbmVyLmhlaWdodCAtIGJvdHRvbSAtIGhlaWdodDI7XG4gIH1cbiAgaWYgKHdpZHRoMiA9PSBudWxsKSB7XG4gICAgaWYgKGhlaWdodDIgPT0gbnVsbCkge1xuICAgICAgd2lkdGgyID0gbmF0dXJhbFdpZHRoO1xuICAgICAgaGVpZ2h0MiA9IG5hdHVyYWxIZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpZHRoMiA9IE1hdGguY2VpbChuYXR1cmFsV2lkdGggKiBoZWlnaHQyIC8gbmF0dXJhbEhlaWdodCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGhlaWdodDIgPT0gbnVsbCkge1xuICAgIGhlaWdodDIgPSBNYXRoLmNlaWwobmF0dXJhbEhlaWdodCAqIHdpZHRoMiAvIG5hdHVyYWxXaWR0aCk7XG4gIH1cbiAgaWYgKGxlZnQgPT0gbnVsbCkge1xuICAgIGlmIChyaWdodCA9PSBudWxsKSB7XG4gICAgICBsZWZ0ID0gTWF0aC5mbG9vcigoY29udGFpbmVyLndpZHRoIC0gd2lkdGgyKSAvIDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZWZ0ID0gY29udGFpbmVyLndpZHRoIC0gcmlnaHQgLSB3aWR0aDI7XG4gICAgfVxuICB9XG4gIGlmICh0b3AgPT0gbnVsbCkge1xuICAgIGlmIChib3R0b20gPT0gbnVsbCkge1xuICAgICAgdG9wID0gTWF0aC5mbG9vcigoY29udGFpbmVyLmhlaWdodCAtIGhlaWdodDIpIC8gMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvcCA9IGNvbnRhaW5lci5oZWlnaHQgLSBoZWlnaHQyIC0gYm90dG9tO1xuICAgIH1cbiAgfVxuICByZXR1cm4geyB4OiBsZWZ0LCB5OiB0b3AsIHdpZHRoOiB3aWR0aDIsIGhlaWdodDogaGVpZ2h0MiB9O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC90b29sdGlwL3Rvb2x0aXAudHNcbnZhciBERUZBVUxUX1RPT0xUSVBfQ0xBU1MgPSBcImFnLWNoYXJ0LXRvb2x0aXBcIjtcbnZhciBERUZBVUxUX1RPT0xUSVBfREFSS19DTEFTUyA9IFwiYWctY2hhcnQtZGFyay10b29sdGlwXCI7XG52YXIgRU1QVFlfVE9PTFRJUF9DT05URU5UID0geyBodG1sOiBcIlwiLCBhcmlhTGFiZWw6IFwiXCIgfTtcbmZ1bmN0aW9uIHRvQWNjZXNzaWJsZVRleHQoaW5wdXRIdG1sKSB7XG4gIGNvbnN0IGxpbmVDb252ZXJ0ZXIgPSAoX21hdGNoLCBvZmZzZXQ0LCBzdHIpID0+IHtcbiAgICBpZiAob2Zmc2V0NCA9PT0gMCB8fCBzdHJbb2Zmc2V0NCAtIDFdICE9PSBcIi5cIikge1xuICAgICAgcmV0dXJuIFwiLiBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwiIFwiO1xuICB9O1xuICByZXR1cm4gaW5wdXRIdG1sLnJlcGxhY2UoLzxiclxccypcXC8/Pi9nLCBsaW5lQ29udmVydGVyKS5yZXBsYWNlKC88XFwvcFxccys+L2csIGxpbmVDb252ZXJ0ZXIpLnJlcGxhY2UoLzxcXC9saVxccyo+L2csIGxpbmVDb252ZXJ0ZXIpLnJlcGxhY2UoLzxbXjw+XSs+L2csIFwiXCIpLnJlcGxhY2UoL1xcbisvZywgXCIgXCIpLnJlcGxhY2UoL1xccysvZywgXCIgXCIpO1xufVxuZnVuY3Rpb24gdG9Ub29sdGlwSHRtbChpbnB1dCwgZGVmYXVsdHMpIHtcbiAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiB7IGh0bWw6IGlucHV0LCBhcmlhTGFiZWw6IGlucHV0IH07XG4gIH1cbiAgY29uc3Qge1xuICAgIGNvbnRlbnQgPSBkZWZhdWx0cz8uY29udGVudCA/PyBcIlwiLFxuICAgIHRpdGxlID0gZGVmYXVsdHM/LnRpdGxlLFxuICAgIGNvbG9yID0gZGVmYXVsdHM/LmNvbG9yID8/IFwid2hpdGVcIixcbiAgICBiYWNrZ3JvdW5kQ29sb3IgPSBkZWZhdWx0cz8uYmFja2dyb3VuZENvbG9yID8/IFwiIzg4OFwiXG4gIH0gPSBpbnB1dDtcbiAgY29uc3QgdGl0bGVIdG1sID0gdGl0bGUgPyBgPGRpdiBjbGFzcz1cIiR7REVGQVVMVF9UT09MVElQX0NMQVNTfS10aXRsZVwiXG4gICAgICAgIHN0eWxlPVwiY29sb3I6ICR7Y29sb3J9OyBiYWNrZ3JvdW5kLWNvbG9yOiAke2JhY2tncm91bmRDb2xvcn1cIj4ke3RpdGxlfTwvZGl2PmAgOiBcIlwiO1xuICBjb25zdCB0aXRsZUFyaWEgPSB0aXRsZSA/IGAke3RpdGxlfTogYCA6IFwiXCI7XG4gIGNvbnN0IGNvbnRlbnRIdG1sID0gY29udGVudCA/IGA8ZGl2IGNsYXNzPVwiJHtERUZBVUxUX1RPT0xUSVBfQ0xBU1N9LWNvbnRlbnRcIj4ke2NvbnRlbnR9PC9kaXY+YCA6IFwiXCI7XG4gIHJldHVybiB7XG4gICAgaHRtbDogYCR7dGl0bGVIdG1sfSR7Y29udGVudEh0bWx9YCxcbiAgICBhcmlhTGFiZWw6IHRvQWNjZXNzaWJsZVRleHQoYCR7dGl0bGVBcmlhfSR7Y29udGVudH1gKVxuICB9O1xufVxudmFyIFRvb2x0aXBQb3NpdGlvbiA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIC8qKiBUaGUgdHlwZSBvZiBwb3NpdGlvbmluZyBmb3IgdGhlIHRvb2x0aXAuIEJ5IGRlZmF1bHQsIHRoZSB0b29sdGlwIGZvbGxvd3MgdGhlIHBvaW50ZXIuICovXG4gICAgdGhpcy50eXBlID0gXCJwb2ludGVyXCI7XG4gICAgLyoqIFRoZSBob3Jpem9udGFsIG9mZnNldCBpbiBwaXhlbHMgZm9yIHRoZSBwb3NpdGlvbiBvZiB0aGUgdG9vbHRpcC4gKi9cbiAgICB0aGlzLnhPZmZzZXQgPSAwO1xuICAgIC8qKiBUaGUgdmVydGljYWwgb2Zmc2V0IGluIHBpeGVscyBmb3IgdGhlIHBvc2l0aW9uIG9mIHRoZSB0b29sdGlwLiAqL1xuICAgIHRoaXMueU9mZnNldCA9IDA7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShcbiAgICBVTklPTihcbiAgICAgIFtcbiAgICAgICAgXCJwb2ludGVyXCIsXG4gICAgICAgIFwibm9kZVwiLFxuICAgICAgICBcInRvcFwiLFxuICAgICAgICBcInJpZ2h0XCIsXG4gICAgICAgIFwiYm90dG9tXCIsXG4gICAgICAgIFwibGVmdFwiLFxuICAgICAgICBcInRvcC1sZWZ0XCIsXG4gICAgICAgIFwidG9wLXJpZ2h0XCIsXG4gICAgICAgIFwiYm90dG9tLXJpZ2h0XCIsXG4gICAgICAgIFwiYm90dG9tLWxlZnRcIixcbiAgICAgICAgeyB2YWx1ZTogXCJzcGFya2xpbmVcIiwgdW5kb2N1bWVudGVkOiB0cnVlIH1cbiAgICAgIF0sXG4gICAgICBcImEgcG9zaXRpb24gdHlwZVwiXG4gICAgKVxuICApXG5dLCBUb29sdGlwUG9zaXRpb24ucHJvdG90eXBlLCBcInR5cGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShOVU1CRVIpXG5dLCBUb29sdGlwUG9zaXRpb24ucHJvdG90eXBlLCBcInhPZmZzZXRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShOVU1CRVIpXG5dLCBUb29sdGlwUG9zaXRpb24ucHJvdG90eXBlLCBcInlPZmZzZXRcIiwgMik7XG52YXIgVG9vbHRpcCA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5kZWxheSA9IDA7XG4gICAgdGhpcy5yYW5nZSA9IHZvaWQgMDtcbiAgICB0aGlzLndyYXBwaW5nID0gXCJoeXBoZW5hdGVcIjtcbiAgICB0aGlzLnBvc2l0aW9uID0gbmV3IFRvb2x0aXBQb3NpdGlvbigpO1xuICAgIHRoaXMuZGFya1RoZW1lID0gZmFsc2U7XG4gICAgdGhpcy5ib3VuZHMgPSBcImV4dGVuZGVkXCI7XG4gICAgdGhpcy5lbmFibGVJbnRlcmFjdGlvbiA9IGZhbHNlO1xuICAgIHRoaXMubGFzdFZpc2liaWxpdHlDaGFuZ2UgPSBEYXRlLm5vdygpO1xuICAgIHRoaXMud3JhcFR5cGVzID0gW1wiYWx3YXlzXCIsIFwiaHlwaGVuYXRlXCIsIFwib24tc3BhY2VcIiwgXCJuZXZlclwiXTtcbiAgICB0aGlzLnNob3dUaW1lb3V0ID0gMDtcbiAgICB0aGlzLl9zaG93QXJyb3cgPSB0cnVlO1xuICB9XG4gIGdldCBpbnRlcmFjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5lbmFibGVJbnRlcmFjdGlvbjtcbiAgfVxuICBzZXR1cChkb21NYW5hZ2VyKSB7XG4gICAgdGhpcy5lbGVtZW50ID0gZG9tTWFuYWdlci5hZGRDaGlsZChcImNhbnZhcy1vdmVybGF5XCIsIERFRkFVTFRfVE9PTFRJUF9DTEFTUyk7XG4gICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoREVGQVVMVF9UT09MVElQX0NMQVNTKTtcbiAgfVxuICBkZXN0cm95KGRvbU1hbmFnZXIpIHtcbiAgICBkb21NYW5hZ2VyLnJlbW92ZUNoaWxkKFwiY2FudmFzLW92ZXJsYXlcIiwgREVGQVVMVF9UT09MVElQX0NMQVNTKTtcbiAgfVxuICBpc1Zpc2libGUoKSB7XG4gICAgcmV0dXJuICF0aGlzLmVsZW1lbnQ/LmNsYXNzTGlzdC5jb250YWlucyhERUZBVUxUX1RPT0xUSVBfQ0xBU1MgKyBcIi1oaWRkZW5cIik7XG4gIH1cbiAgLyoqXG4gICAqIFNob3dzIHRvb2x0aXAgYXQgdGhlIGdpdmVuIGV2ZW50J3MgY29vcmRpbmF0ZXMuXG4gICAqIElmIHRoZSBgaHRtbGAgcGFyYW1ldGVyIGlzIG1pc3NpbmcsIG1vdmVzIHRoZSBleGlzdGluZyB0b29sdGlwIHRvIHRoZSBuZXcgcG9zaXRpb24uXG4gICAqL1xuICBzaG93KGJvdW5kaW5nUmVjdCwgY2FudmFzUmVjdCwgbWV0YSwgY29udGVudCwgaW5zdGFudGx5ID0gZmFsc2UpIHtcbiAgICBjb25zdCB7IGVsZW1lbnQ6IGVsZW1lbnQyIH0gPSB0aGlzO1xuICAgIGNvbnN0IGV4aXN0aW5nUG9zaXRpb24gPSBlbGVtZW50Mj8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgaWYgKGNvbnRlbnQgIT0gbnVsbCAmJiBlbGVtZW50MiAhPSBudWxsKSB7XG4gICAgICBlbGVtZW50Mi5pbm5lckhUTUwgPSBjb250ZW50Lmh0bWw7XG4gICAgfSBlbHNlIGlmICghZWxlbWVudDI/LmlubmVySFRNTCkge1xuICAgICAgdGhpcy50b2dnbGUoZmFsc2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwb3NpdGlvblR5cGUgPSBtZXRhLnBvc2l0aW9uPy50eXBlID8/IHRoaXMucG9zaXRpb24udHlwZTtcbiAgICBjb25zdCB4T2Zmc2V0ID0gbWV0YS5wb3NpdGlvbj8ueE9mZnNldCA/PyAwO1xuICAgIGNvbnN0IHlPZmZzZXQgPSBtZXRhLnBvc2l0aW9uPy55T2Zmc2V0ID8/IDA7XG4gICAgY29uc3QgdG9vbHRpcEJvdW5kcyA9IHRoaXMuZ2V0VG9vbHRpcEJvdW5kcyh7IHBvc2l0aW9uVHlwZSwgbWV0YSwgeU9mZnNldCwgeE9mZnNldCwgY2FudmFzUmVjdCB9KTtcbiAgICBjb25zdCByZWxhdGl2ZVJlY3QgPSB7XG4gICAgICB4OiBib3VuZGluZ1JlY3QueCAtIGNhbnZhc1JlY3QueCxcbiAgICAgIHk6IGJvdW5kaW5nUmVjdC55IC0gY2FudmFzUmVjdC55LFxuICAgICAgd2lkdGg6IGJvdW5kaW5nUmVjdC53aWR0aCxcbiAgICAgIGhlaWdodDogYm91bmRpbmdSZWN0LmhlaWdodFxuICAgIH07XG4gICAgY29uc3QgcG9zaXRpb24gPSBjYWxjdWxhdGVQbGFjZW1lbnQoZWxlbWVudDIuY2xpZW50V2lkdGgsIGVsZW1lbnQyLmNsaWVudEhlaWdodCwgcmVsYXRpdmVSZWN0LCB0b29sdGlwQm91bmRzKTtcbiAgICBjb25zdCBtaW5YID0gcmVsYXRpdmVSZWN0Lng7XG4gICAgY29uc3QgbWluWSA9IHJlbGF0aXZlUmVjdC55O1xuICAgIGNvbnN0IG1heFggPSByZWxhdGl2ZVJlY3Qud2lkdGggLSBlbGVtZW50Mi5jbGllbnRXaWR0aCAtIDEgKyBtaW5YO1xuICAgIGNvbnN0IG1heFkgPSByZWxhdGl2ZVJlY3QuaGVpZ2h0IC0gZWxlbWVudDIuY2xpZW50SGVpZ2h0ICsgbWluWTtcbiAgICBjb25zdCBsZWZ0ID0gY2xhbXAobWluWCwgcG9zaXRpb24ueCwgbWF4WCk7XG4gICAgY29uc3QgdG9wID0gY2xhbXAobWluWSwgcG9zaXRpb24ueSwgbWF4WSk7XG4gICAgbGV0IHdpbGxFeGlzdE91dHNpZGVCb3VuZGluZ1JlY3REdXJpbmdUcmFuc2l0aW9uID0gZmFsc2U7XG4gICAgaWYgKGV4aXN0aW5nUG9zaXRpb24gIT0gbnVsbCkge1xuICAgICAgY29uc3QgbWF4WFdpdGhQcmV2aW91c1Bvc2l0aW9uID0gcmVsYXRpdmVSZWN0LndpZHRoIC0gZXhpc3RpbmdQb3NpdGlvbi53aWR0aCAtIDEgKyBtaW5YO1xuICAgICAgY29uc3QgbWF4WVdpdGhQcmV2aW91c1Bvc2l0aW9uID0gcmVsYXRpdmVSZWN0LmhlaWdodCAtIGV4aXN0aW5nUG9zaXRpb24uaGVpZ2h0ICsgbWluWTtcbiAgICAgIHdpbGxFeGlzdE91dHNpZGVCb3VuZGluZ1JlY3REdXJpbmdUcmFuc2l0aW9uID0gbWF4WFdpdGhQcmV2aW91c1Bvc2l0aW9uID4gbWF4WCB8fCBtYXhZV2l0aFByZXZpb3VzUG9zaXRpb24gPiBtYXhZO1xuICAgIH1cbiAgICBjb25zdCBjb25zdHJhaW5lZCA9IGxlZnQgIT09IHBvc2l0aW9uLnggfHwgdG9wICE9PSBwb3NpdGlvbi55O1xuICAgIGNvbnN0IGRlZmF1bHRTaG93QXJyb3cgPSAocG9zaXRpb25UeXBlID09PSBcIm5vZGVcIiB8fCBwb3NpdGlvblR5cGUgPT09IFwicG9pbnRlclwiIHx8IHBvc2l0aW9uVHlwZSA9PT0gXCJzcGFya2xpbmVcIikgJiYgIWNvbnN0cmFpbmVkICYmICF4T2Zmc2V0ICYmICF5T2Zmc2V0O1xuICAgIGNvbnN0IHNob3dBcnJvdyA9IG1ldGEuc2hvd0Fycm93ID8/IHRoaXMuc2hvd0Fycm93ID8/IGRlZmF1bHRTaG93QXJyb3c7XG4gICAgdGhpcy51cGRhdGVTaG93QXJyb3coc2hvd0Fycm93KTtcbiAgICBpZiAod2lsbEV4aXN0T3V0c2lkZUJvdW5kaW5nUmVjdER1cmluZ1RyYW5zaXRpb24pIHtcbiAgICAgIGVsZW1lbnQyLnN0eWxlLnRyYW5zaXRpb24gPSBcIm5vbmVcIjtcbiAgICB9XG4gICAgZWxlbWVudDIuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgke01hdGgucm91bmQobGVmdCl9cHgsICR7TWF0aC5yb3VuZCh0b3ApfXB4KWA7XG4gICAgaWYgKHdpbGxFeGlzdE91dHNpZGVCb3VuZGluZ1JlY3REdXJpbmdUcmFuc2l0aW9uKSB7XG4gICAgICBlbGVtZW50Mi5zdHlsZS50cmFuc2l0aW9uID0gXCJcIjtcbiAgICB9XG4gICAgaWYgKG1ldGEuZW5hYmxlSW50ZXJhY3Rpb24pIHtcbiAgICAgIHRoaXMuZW5hYmxlSW50ZXJhY3Rpb24gPSB0cnVlO1xuICAgICAgZWxlbWVudDIuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwiYXV0b1wiO1xuICAgICAgc2V0QXR0cmlidXRlKGVsZW1lbnQyLCBcImFyaWEtaGlkZGVuXCIsIHZvaWQgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZW5hYmxlSW50ZXJhY3Rpb24gPSBmYWxzZTtcbiAgICAgIGVsZW1lbnQyLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIm5vbmVcIjtcbiAgICAgIHNldEF0dHJpYnV0ZShlbGVtZW50MiwgXCJhcmlhLWhpZGRlblwiLCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGVsYXkgPiAwICYmICFpbnN0YW50bHkpIHtcbiAgICAgIHRoaXMudG9nZ2xlKGZhbHNlKTtcbiAgICAgIHRoaXMuc2hvd1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy50b2dnbGUodHJ1ZSk7XG4gICAgICB9LCB0aGlzLmRlbGF5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50b2dnbGUodHJ1ZSk7XG4gICAgfVxuICB9XG4gIHRvZ2dsZSh2aXNpYmxlKSB7XG4gICAgaWYgKCF0aGlzLmVsZW1lbnQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBjbGFzc0xpc3QgfSA9IHRoaXMuZWxlbWVudDtcbiAgICBjb25zdCB0b2dnbGVDbGFzcyA9IChuYW1lLCBpbmNsdWRlKSA9PiBjbGFzc0xpc3QudG9nZ2xlKGAke0RFRkFVTFRfVE9PTFRJUF9DTEFTU30tJHtuYW1lfWAsIGluY2x1ZGUpO1xuICAgIGNvbnN0IHdhc1Zpc2libGUgPSB0aGlzLmlzVmlzaWJsZSgpO1xuICAgIGxldCB0aW1lU2luY2VMYXN0VmlzaWJpbGl0eUNoYW5nZU1zID0gSW5maW5pdHk7XG4gICAgaWYgKCF2aXNpYmxlKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5zaG93VGltZW91dCk7XG4gICAgfVxuICAgIGlmICh3YXNWaXNpYmxlICE9PSB2aXNpYmxlKSB7XG4gICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgdGltZVNpbmNlTGFzdFZpc2liaWxpdHlDaGFuZ2VNcyA9IG5vdyAtIHRoaXMubGFzdFZpc2liaWxpdHlDaGFuZ2U7XG4gICAgICB0aGlzLmxhc3RWaXNpYmlsaXR5Q2hhbmdlID0gbm93O1xuICAgIH1cbiAgICBjb25zdCBhbmltYXRlZE1vdmVUaHJlc2hvbGRNcyA9IDEwMDtcbiAgICBjb25zdCB0aHJhc2hpbmdUaHJlc2hvbGRNcyA9IDU7XG4gICAgY29uc3Qgbm9BbmltYXRpb24gPSAhd2FzVmlzaWJsZSAmJiB2aXNpYmxlICYmIHRpbWVTaW5jZUxhc3RWaXNpYmlsaXR5Q2hhbmdlTXMgPiBhbmltYXRlZE1vdmVUaHJlc2hvbGRNcztcbiAgICBpZiAodGltZVNpbmNlTGFzdFZpc2liaWxpdHlDaGFuZ2VNcyA+IHRocmFzaGluZ1RocmVzaG9sZE1zKSB7XG4gICAgICB0b2dnbGVDbGFzcyhcIm5vLWFuaW1hdGlvblwiLCBub0FuaW1hdGlvbik7XG4gICAgfVxuICAgIHRvZ2dsZUNsYXNzKFwibm8taW50ZXJhY3Rpb25cIiwgIXRoaXMuZW5hYmxlSW50ZXJhY3Rpb24pO1xuICAgIHRvZ2dsZUNsYXNzKFwiaGlkZGVuXCIsICF2aXNpYmxlKTtcbiAgICB0b2dnbGVDbGFzcyhcImFycm93XCIsIHRoaXMuX3Nob3dBcnJvdyk7XG4gICAgY2xhc3NMaXN0LnRvZ2dsZShERUZBVUxUX1RPT0xUSVBfREFSS19DTEFTUywgdGhpcy5kYXJrVGhlbWUpO1xuICAgIGZvciAoY29uc3Qgd3JhcFR5cGUgb2YgdGhpcy53cmFwVHlwZXMpIHtcbiAgICAgIGNsYXNzTGlzdC50b2dnbGUoYCR7REVGQVVMVF9UT09MVElQX0NMQVNTfS13cmFwLSR7d3JhcFR5cGV9YCwgd3JhcFR5cGUgPT09IHRoaXMud3JhcHBpbmcpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVTaG93QXJyb3coc2hvdykge1xuICAgIHRoaXMuX3Nob3dBcnJvdyA9IHNob3c7XG4gIH1cbiAgZ2V0VG9vbHRpcEJvdW5kcyhvcHRzKSB7XG4gICAgaWYgKCF0aGlzLmVsZW1lbnQpXG4gICAgICByZXR1cm4ge307XG4gICAgY29uc3QgeyBwb3NpdGlvblR5cGUsIG1ldGEsIHlPZmZzZXQsIHhPZmZzZXQsIGNhbnZhc1JlY3QgfSA9IG9wdHM7XG4gICAgY29uc3QgeyBjbGllbnRXaWR0aDogdG9vbHRpcFdpZHRoLCBjbGllbnRIZWlnaHQ6IHRvb2x0aXBIZWlnaHQgfSA9IHRoaXMuZWxlbWVudDtcbiAgICBjb25zdCBib3VuZHMgPSB7IHdpZHRoOiB0b29sdGlwV2lkdGgsIGhlaWdodDogdG9vbHRpcEhlaWdodCB9O1xuICAgIHN3aXRjaCAocG9zaXRpb25UeXBlKSB7XG4gICAgICBjYXNlIFwibm9kZVwiOlxuICAgICAgY2FzZSBcInBvaW50ZXJcIjoge1xuICAgICAgICBib3VuZHMudG9wID0gbWV0YS5vZmZzZXRZICsgeU9mZnNldCAtIHRvb2x0aXBIZWlnaHQgLSA4O1xuICAgICAgICBib3VuZHMubGVmdCA9IG1ldGEub2Zmc2V0WCArIHhPZmZzZXQgLSB0b29sdGlwV2lkdGggLyAyO1xuICAgICAgICByZXR1cm4gYm91bmRzO1xuICAgICAgfVxuICAgICAgY2FzZSBcInRvcFwiOiB7XG4gICAgICAgIGJvdW5kcy50b3AgPSB5T2Zmc2V0O1xuICAgICAgICBib3VuZHMubGVmdCA9IGNhbnZhc1JlY3Qud2lkdGggLyAyIC0gdG9vbHRpcFdpZHRoIC8gMiArIHhPZmZzZXQ7XG4gICAgICAgIHJldHVybiBib3VuZHM7XG4gICAgICB9XG4gICAgICBjYXNlIFwicmlnaHRcIjoge1xuICAgICAgICBib3VuZHMudG9wID0gY2FudmFzUmVjdC5oZWlnaHQgLyAyIC0gdG9vbHRpcEhlaWdodCAvIDIgKyB5T2Zmc2V0O1xuICAgICAgICBib3VuZHMubGVmdCA9IGNhbnZhc1JlY3Qud2lkdGggLSB0b29sdGlwV2lkdGggLyAyICsgeE9mZnNldDtcbiAgICAgICAgcmV0dXJuIGJvdW5kcztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJsZWZ0XCI6IHtcbiAgICAgICAgYm91bmRzLnRvcCA9IGNhbnZhc1JlY3QuaGVpZ2h0IC8gMiAtIHRvb2x0aXBIZWlnaHQgLyAyICsgeU9mZnNldDtcbiAgICAgICAgYm91bmRzLmxlZnQgPSB4T2Zmc2V0O1xuICAgICAgICByZXR1cm4gYm91bmRzO1xuICAgICAgfVxuICAgICAgY2FzZSBcImJvdHRvbVwiOiB7XG4gICAgICAgIGJvdW5kcy50b3AgPSBjYW52YXNSZWN0LmhlaWdodCAtIHRvb2x0aXBIZWlnaHQgKyB5T2Zmc2V0O1xuICAgICAgICBib3VuZHMubGVmdCA9IGNhbnZhc1JlY3Qud2lkdGggLyAyIC0gdG9vbHRpcFdpZHRoIC8gMiArIHhPZmZzZXQ7XG4gICAgICAgIHJldHVybiBib3VuZHM7XG4gICAgICB9XG4gICAgICBjYXNlIFwidG9wLWxlZnRcIjoge1xuICAgICAgICBib3VuZHMudG9wID0geU9mZnNldDtcbiAgICAgICAgYm91bmRzLmxlZnQgPSB4T2Zmc2V0O1xuICAgICAgICByZXR1cm4gYm91bmRzO1xuICAgICAgfVxuICAgICAgY2FzZSBcInRvcC1yaWdodFwiOiB7XG4gICAgICAgIGJvdW5kcy50b3AgPSB5T2Zmc2V0O1xuICAgICAgICBib3VuZHMubGVmdCA9IGNhbnZhc1JlY3Qud2lkdGggLSB0b29sdGlwV2lkdGggKyB4T2Zmc2V0O1xuICAgICAgICByZXR1cm4gYm91bmRzO1xuICAgICAgfVxuICAgICAgY2FzZSBcImJvdHRvbS1yaWdodFwiOiB7XG4gICAgICAgIGJvdW5kcy50b3AgPSBjYW52YXNSZWN0LmhlaWdodCAtIHRvb2x0aXBIZWlnaHQgKyB5T2Zmc2V0O1xuICAgICAgICBib3VuZHMubGVmdCA9IGNhbnZhc1JlY3Qud2lkdGggLSB0b29sdGlwV2lkdGggKyB4T2Zmc2V0O1xuICAgICAgICByZXR1cm4gYm91bmRzO1xuICAgICAgfVxuICAgICAgY2FzZSBcImJvdHRvbS1sZWZ0XCI6IHtcbiAgICAgICAgYm91bmRzLnRvcCA9IGNhbnZhc1JlY3QuaGVpZ2h0IC0gdG9vbHRpcEhlaWdodCArIHlPZmZzZXQ7XG4gICAgICAgIGJvdW5kcy5sZWZ0ID0geE9mZnNldDtcbiAgICAgICAgcmV0dXJuIGJvdW5kcztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJzcGFya2xpbmVcIjoge1xuICAgICAgICBpZiAoZW50ZXJwcmlzZU1vZHVsZS5pc0VudGVycHJpc2UpIHtcbiAgICAgICAgICBib3VuZHMudG9wID0geU9mZnNldCAtIHRvb2x0aXBIZWlnaHQgLSA4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJvdW5kcy50b3AgPSBtZXRhLm9mZnNldFkgKyB5T2Zmc2V0IC0gdG9vbHRpcEhlaWdodCAtIDg7XG4gICAgICAgIH1cbiAgICAgICAgYm91bmRzLmxlZnQgPSBtZXRhLm9mZnNldFggKyB4T2Zmc2V0IC0gdG9vbHRpcFdpZHRoIC8gMjtcbiAgICAgICAgcmV0dXJuIGJvdW5kcztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgVG9vbHRpcC5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFRvb2x0aXAucHJvdG90eXBlLCBcInNob3dBcnJvd1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIE9ic2VydmVDaGFuZ2VzKCh0YXJnZXQsIG5ld1ZhbHVlLCBvbGRWYWx1ZSkgPT4ge1xuICAgIGlmIChuZXdWYWx1ZSkge1xuICAgICAgdGFyZ2V0LmVsZW1lbnQ/LmNsYXNzTGlzdC5hZGQobmV3VmFsdWUpO1xuICAgIH1cbiAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgIHRhcmdldC5lbGVtZW50Py5jbGFzc0xpc3QucmVtb3ZlKG9sZFZhbHVlKTtcbiAgICB9XG4gIH0pLFxuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFRvb2x0aXAucHJvdG90eXBlLCBcImNsYXNzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgVG9vbHRpcC5wcm90b3R5cGUsIFwiZGVsYXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShJTlRFUkFDVElPTl9SQU5HRSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgVG9vbHRpcC5wcm90b3R5cGUsIFwicmFuZ2VcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShURVhUX1dSQVApXG5dLCBUb29sdGlwLnByb3RvdHlwZSwgXCJ3cmFwcGluZ1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIFRvb2x0aXAucHJvdG90eXBlLCBcInBvc2l0aW9uXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIFRvb2x0aXAucHJvdG90eXBlLCBcImRhcmtUaGVtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFVOSU9OKFtcImV4dGVuZGVkXCIsIFwiY2FudmFzXCJdKSlcbl0sIFRvb2x0aXAucHJvdG90eXBlLCBcImJvdW5kc1wiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvY2FwdGlvbi50c1xudmFyIENhcHRpb24gPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmlkID0gY3JlYXRlSWQodGhpcyk7XG4gICAgdGhpcy5ub2RlID0gbmV3IFJvdGF0YWJsZVRleHQoeyB6SW5kZXg6IDEgfSkuc2V0UHJvcGVydGllcyh7XG4gICAgICB0ZXh0QWxpZ246IFwiY2VudGVyXCIsXG4gICAgICBwb2ludGVyRXZlbnRzOiAxIC8qIE5vbmUgKi9cbiAgICB9KTtcbiAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgdGhpcy5mb250U2l6ZSA9IDEwO1xuICAgIHRoaXMuZm9udEZhbWlseSA9IFwic2Fucy1zZXJpZlwiO1xuICAgIHRoaXMud3JhcHBpbmcgPSBcImFsd2F5c1wiO1xuICAgIHRoaXMucGFkZGluZyA9IDA7XG4gICAgdGhpcy5sYXlvdXRTdHlsZSA9IFwiYmxvY2tcIjtcbiAgICB0aGlzLnRydW5jYXRlZCA9IGZhbHNlO1xuICB9XG4gIHJlZ2lzdGVySW50ZXJhY3Rpb24obW9kdWxlQ3R4LCB3aGVyZSkge1xuICAgIGNvbnN0IHsgcmVnaW9uTWFuYWdlciwgcHJveHlJbnRlcmFjdGlvblNlcnZpY2UsIGxheW91dE1hbmFnZXIgfSA9IG1vZHVsZUN0eDtcbiAgICBjb25zdCByZWdpb24gPSByZWdpb25NYW5hZ2VyLmdldFJlZ2lvbihcInJvb3RcIik7XG4gICAgY29uc3QgZGVzdHJveUZucyA9IFtcbiAgICAgIGxheW91dE1hbmFnZXIuYWRkTGlzdGVuZXIoXCJsYXlvdXQ6Y29tcGxldGVcIiwgKCkgPT4gdGhpcy51cGRhdGVBMTF5VGV4dChwcm94eUludGVyYWN0aW9uU2VydmljZSwgd2hlcmUpKSxcbiAgICAgIHJlZ2lvbi5hZGRMaXN0ZW5lcihcImhvdmVyXCIsIChldmVudCkgPT4gdGhpcy5oYW5kbGVNb3VzZU1vdmUobW9kdWxlQ3R4LCBldmVudCkpLFxuICAgICAgcmVnaW9uLmFkZExpc3RlbmVyKFwibGVhdmVcIiwgKGV2ZW50KSA9PiB0aGlzLmhhbmRsZU1vdXNlTGVhdmUobW9kdWxlQ3R4LCBldmVudCkpXG4gICAgXTtcbiAgICByZXR1cm4gam9pbkZ1bmN0aW9ucyguLi5kZXN0cm95Rm5zKTtcbiAgfVxuICBjb21wdXRlVGV4dFdyYXAoY29udGFpbmVyV2lkdGgsIGNvbnRhaW5lckhlaWdodCkge1xuICAgIGNvbnN0IHsgdGV4dCwgcGFkZGluZywgd3JhcHBpbmcgfSA9IHRoaXM7XG4gICAgY29uc3QgbWF4V2lkdGggPSBNYXRoLm1pbih0aGlzLm1heFdpZHRoID8/IEluZmluaXR5LCBjb250YWluZXJXaWR0aCkgLSBwYWRkaW5nICogMjtcbiAgICBjb25zdCBtYXhIZWlnaHQgPSB0aGlzLm1heEhlaWdodCA/PyBjb250YWluZXJIZWlnaHQgLSBwYWRkaW5nICogMjtcbiAgICBpZiAoIWlzRmluaXRlKG1heFdpZHRoKSAmJiAhaXNGaW5pdGUobWF4SGVpZ2h0KSkge1xuICAgICAgdGhpcy5ub2RlLnRleHQgPSB0ZXh0O1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB3cmFwcGVkVGV4dCA9IFRleHRXcmFwcGVyLndyYXBUZXh0KHRleHQgPz8gXCJcIiwgeyBtYXhXaWR0aCwgbWF4SGVpZ2h0LCBmb250OiB0aGlzLCB0ZXh0V3JhcDogd3JhcHBpbmcgfSk7XG4gICAgdGhpcy5ub2RlLnRleHQgPSB3cmFwcGVkVGV4dDtcbiAgICB0aGlzLnRydW5jYXRlZCA9IHdyYXBwZWRUZXh0LmluY2x1ZGVzKFRleHRVdGlscy5FbGxpcHNpc0NoYXIpO1xuICB9XG4gIHVwZGF0ZUExMXlUZXh0KHByb3h5U2VydmljZSwgd2hlcmUpIHtcbiAgICBpZiAodGhpcy5lbmFibGVkICYmIHRoaXMudGV4dCkge1xuICAgICAgY29uc3QgYmJveCA9IFRyYW5zZm9ybWFibGUudG9DYW52YXModGhpcy5ub2RlKTtcbiAgICAgIGlmIChiYm94KSB7XG4gICAgICAgIGNvbnN0IHsgaWQgfSA9IHRoaXM7XG4gICAgICAgIHRoaXMucHJveHlUZXh0ID8/ICh0aGlzLnByb3h5VGV4dCA9IHByb3h5U2VydmljZS5jcmVhdGVQcm94eUVsZW1lbnQoeyB0eXBlOiBcInRleHRcIiwgaWQsIHBhcmVudDogd2hlcmUgfSkpO1xuICAgICAgICB0aGlzLnByb3h5VGV4dC50ZXh0Q29udGVudCA9IHRoaXMudGV4dDtcbiAgICAgICAgdGhpcy5wcm94eVRleHQudXBkYXRlQm91bmRzKGJib3gpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnByb3h5VGV4dD8ucmVtb3ZlKCk7XG4gICAgICB0aGlzLnByb3h5VGV4dCA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgaGFuZGxlTW91c2VNb3ZlKG1vZHVsZUN0eCwgZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQgIT09IHZvaWQgMCAmJiB0aGlzLmVuYWJsZWQgJiYgdGhpcy5ub2RlLnZpc2libGUgJiYgdGhpcy50cnVuY2F0ZWQpIHtcbiAgICAgIGNvbnN0IHsgb2Zmc2V0WCwgb2Zmc2V0WSB9ID0gZXZlbnQ7XG4gICAgICBtb2R1bGVDdHgudG9vbHRpcE1hbmFnZXIudXBkYXRlVG9vbHRpcChcbiAgICAgICAgdGhpcy5pZCxcbiAgICAgICAgeyBvZmZzZXRYLCBvZmZzZXRZLCBsYXN0UG9pbnRlckV2ZW50OiBldmVudCwgc2hvd0Fycm93OiBmYWxzZSB9LFxuICAgICAgICB0b1Rvb2x0aXBIdG1sKHsgY29udGVudDogdGhpcy50ZXh0IH0pXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBoYW5kbGVNb3VzZUxlYXZlKG1vZHVsZUN0eCwgX2V2ZW50KSB7XG4gICAgbW9kdWxlQ3R4LnRvb2x0aXBNYW5hZ2VyLnJlbW92ZVRvb2x0aXAodGhpcy5pZCk7XG4gIH1cbn07XG5DYXB0aW9uLlNNQUxMX1BBRERJTkcgPSAxMDtcbkNhcHRpb24uTEFSR0VfUEFERElORyA9IDIwO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTiksXG4gIFByb3h5UHJvcGVydHlPbldyaXRlKFwibm9kZVwiLCBcInZpc2libGVcIilcbl0sIENhcHRpb24ucHJvdG90eXBlLCBcImVuYWJsZWRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSksXG4gIFByb3h5UHJvcGVydHlPbldyaXRlKFwibm9kZVwiKVxuXSwgQ2FwdGlvbi5wcm90b3R5cGUsIFwidGV4dFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFRFWFRfQUxJR04sIHsgb3B0aW9uYWw6IHRydWUgfSksXG4gIFByb3h5UHJvcGVydHlPbldyaXRlKFwibm9kZVwiKVxuXSwgQ2FwdGlvbi5wcm90b3R5cGUsIFwidGV4dEFsaWduXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoRk9OVF9TVFlMRSwgeyBvcHRpb25hbDogdHJ1ZSB9KSxcbiAgUHJveHlQcm9wZXJ0eU9uV3JpdGUoXCJub2RlXCIpXG5dLCBDYXB0aW9uLnByb3RvdHlwZSwgXCJmb250U3R5bGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGT05UX1dFSUdIVCwgeyBvcHRpb25hbDogdHJ1ZSB9KSxcbiAgUHJveHlQcm9wZXJ0eU9uV3JpdGUoXCJub2RlXCIpXG5dLCBDYXB0aW9uLnByb3RvdHlwZSwgXCJmb250V2VpZ2h0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKSxcbiAgUHJveHlQcm9wZXJ0eU9uV3JpdGUoXCJub2RlXCIpXG5dLCBDYXB0aW9uLnByb3RvdHlwZSwgXCJmb250U2l6ZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORyksXG4gIFByb3h5UHJvcGVydHlPbldyaXRlKFwibm9kZVwiKVxuXSwgQ2FwdGlvbi5wcm90b3R5cGUsIFwiZm9udEZhbWlseVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KSxcbiAgUHJveHlQcm9wZXJ0eU9uV3JpdGUoXCJub2RlXCIsIFwiZmlsbFwiKVxuXSwgQ2FwdGlvbi5wcm90b3R5cGUsIFwiY29sb3JcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIENhcHRpb24ucHJvdG90eXBlLCBcInNwYWNpbmdcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIENhcHRpb24ucHJvdG90eXBlLCBcIm1heFdpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBDYXB0aW9uLnByb3RvdHlwZSwgXCJtYXhIZWlnaHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShURVhUX1dSQVApXG5dLCBDYXB0aW9uLnByb3RvdHlwZSwgXCJ3cmFwcGluZ1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIENhcHRpb24ucHJvdG90eXBlLCBcInBhZGRpbmdcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcpXG5dLCBDYXB0aW9uLnByb3RvdHlwZSwgXCJsYXlvdXRTdHlsZVwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvbGF5ZXIudHNcbnZhciBfTGF5ZXIgPSBjbGFzcyBfTGF5ZXIgZXh0ZW5kcyBHcm91cCB7XG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzKTtcbiAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgIHRoaXMubGFzdEJCb3ggPSB2b2lkIDA7XG4gIH1cbiAgc3RhdGljIGlzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgX0xheWVyO1xuICB9XG4gIG1hcmtEaXJ0eSh0eXBlID0gMSAvKiBUUklWSUFMICovKSB7XG4gICAgc3VwZXIubWFya0RpcnR5KHR5cGUsIDEgLyogVFJJVklBTCAqLyk7XG4gIH1cbiAgcHJlUmVuZGVyKCkge1xuICAgIGNvbnN0IGNvdW50cyA9IHN1cGVyLnByZVJlbmRlcigpO1xuICAgIGlmIChjb3VudHMubm9uR3JvdXBzID4gMCkge1xuICAgICAgdGhpcy5sYXllciA/PyAodGhpcy5sYXllciA9IHRoaXMuX2xheWVyTWFuYWdlcj8uYWRkTGF5ZXIoe1xuICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgIHpJbmRleDogdGhpcy56SW5kZXgsXG4gICAgICAgIHpJbmRleFN1Yk9yZGVyOiB0aGlzLnpJbmRleFN1Yk9yZGVyLFxuICAgICAgICBnZXRDb21wdXRlZE9wYWNpdHk6ICgpID0+IHRoaXMuZ2V0Q29tcHV0ZWRPcGFjaXR5KCksXG4gICAgICAgIGdldFZpc2liaWxpdHk6ICgpID0+IHRoaXMuZ2V0VmlzaWJpbGl0eSgpXG4gICAgICB9KSk7XG4gICAgICBpZiAodGhpcy5vcHRzPy5kZXJpdmVaSW5kZXhGcm9tQ2hpbGRyZW4pIHtcbiAgICAgICAgdGhpcy5kZXJpdmVaSW5kZXhGcm9tQ2hpbGRyZW4oKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvdW50cztcbiAgfVxuICBkZWJ1Z1NraXAocmVuZGVyQ3R4KSB7XG4gICAgc3VwZXIuZGVidWdTa2lwKHJlbmRlckN0eCk7XG4gICAgY29uc3QgeyBzdGF0cyB9ID0gcmVuZGVyQ3R4O1xuICAgIGlmIChzdGF0cykge1xuICAgICAgc3RhdHMubGF5ZXJzU2tpcHBlZCsrO1xuICAgICAgc3RhdHMubm9kZXNTa2lwcGVkICs9IG5vZGVDb3VudCh0aGlzKS5jb3VudDtcbiAgICB9XG4gIH1cbiAgcmVuZGVyKHJlbmRlckN0eCkge1xuICAgIGlmICghdGhpcy5sYXllcikge1xuICAgICAgcmV0dXJuIHN1cGVyLnJlbmRlcihyZW5kZXJDdHgpO1xuICAgIH1cbiAgICBjb25zdCB7IG9wdHM6IHsgbmFtZSB9ID0ge30sIF9kZWJ1ZzogZGVidWczLCBjbGlwUmVjdCB9ID0gdGhpcztcbiAgICBjb25zdCB7IGlzRGlydHksIGlzQ2hpbGREaXJ0eSwgaXNDaGlsZExheWVyRGlydHkgfSA9IHRoaXMuaXNEaXJ0eShyZW5kZXJDdHgpO1xuICAgIGNvbnN0IHsgc3RhdHMgfSA9IHJlbmRlckN0eDtcbiAgICBsZXQgeyBmb3JjZVJlbmRlciwgY2xpcEJCb3ggfSA9IHJlbmRlckN0eDtcbiAgICBjb25zdCBjdXJyZW50QkJveCA9IHRoaXMuZ2V0QkJveCgpO1xuICAgIGlmICghdGhpcy5sYXN0QkJveD8uZXF1YWxzKGN1cnJlbnRCQm94KSkge1xuICAgICAgZm9yY2VSZW5kZXIgPSBcImRpcnR5VHJhbnNmb3JtXCI7XG4gICAgICB0aGlzLmxhc3RCQm94ID0gY3VycmVudEJCb3g7XG4gICAgfVxuICAgIGlmICghaXNEaXJ0eSAmJiAhaXNDaGlsZERpcnR5ICYmICFpc0NoaWxkTGF5ZXJEaXJ0eSAmJiAhZm9yY2VSZW5kZXIpIHtcbiAgICAgIHRoaXMuZGVidWdTa2lwKHJlbmRlckN0eCk7XG4gICAgICB0aGlzLm1hcmtDbGVhbih7IHJlY3Vyc2l2ZTogZmFsc2UgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChmb3JjZVJlbmRlciAhPT0gXCJkaXJ0eVRyYW5zZm9ybVwiKSB7XG4gICAgICBmb3JjZVJlbmRlciA9IGlzQ2hpbGREaXJ0eSB8fCB0aGlzLmRpcnR5WkluZGV4O1xuICAgIH1cbiAgICBpZiAoZm9yY2VSZW5kZXIpIHtcbiAgICAgIHRoaXMubGF5ZXIuY2xlYXIoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGlydHlaSW5kZXgpIHtcbiAgICAgIHRoaXMuc29ydENoaWxkcmVuKEdyb3VwLmNvbXBhcmVDaGlsZHJlbik7XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5zb3J0ZWRDaGlsZHJlbigpO1xuICAgIGNvbnN0IHJlbmRlckN0eFRyYW5zZm9ybSA9IHJlbmRlckN0eC5jdHguZ2V0VHJhbnNmb3JtKCk7XG4gICAgY29uc3QgeyBjb250ZXh0OiBjdHggfSA9IHRoaXMubGF5ZXI7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBpZiAoY2xpcEJCb3gpIHtcbiAgICAgIGNvbnN0IHsgd2lkdGg6IHdpZHRoMiwgaGVpZ2h0OiBoZWlnaHQyLCB4LCB5IH0gPSBjbGlwQkJveDtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5yZWN0KHgsIHksIHdpZHRoMiwgaGVpZ2h0Mik7XG4gICAgICBjdHguY2xpcCgpO1xuICAgICAgZGVidWczPy4oKCkgPT4gKHsgbmFtZSwgY2xpcEJCb3gsIHJlbmRlckN0eCwgZ3JvdXA6IHRoaXMsIGN0eFRyYW5zZm9ybTogY3R4LmdldFRyYW5zZm9ybSgpIH0pKTtcbiAgICB9XG4gICAgY3R4LnNldFRyYW5zZm9ybShyZW5kZXJDdHhUcmFuc2Zvcm0pO1xuICAgIGlmICh0aGlzLmNsaXBSZWN0KSB7XG4gICAgICBjbGlwQkJveCA9IHRoaXMucmVuZGVyQ2xpcCh7IC4uLnJlbmRlckN0eCwgY3R4IH0pO1xuICAgIH1cbiAgICB0aGlzLnJlbmRlckNoaWxkcmVuKGNoaWxkcmVuLCB7IC4uLnJlbmRlckN0eCwgY3R4LCBmb3JjZVJlbmRlciwgY2xpcEJCb3ggfSk7XG4gICAgc3VwZXIucmVuZGVyKHJlbmRlckN0eCwgdHJ1ZSk7XG4gICAgaWYgKGNsaXBSZWN0KSB7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMudmlydHVhbENoaWxkcmVuKCkpIHtcbiAgICAgIGNoaWxkLm1hcmtDbGVhbih7IHJlY3Vyc2l2ZTogXCJ2aXJ0dWFsXCIgfSk7XG4gICAgfVxuICAgIGlmIChzdGF0cylcbiAgICAgIHN0YXRzLmxheWVyc1JlbmRlcmVkKys7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgICBjdHgudmVyaWZ5RGVwdGhaZXJvPy4oKTtcbiAgICBpZiAobmFtZSAmJiBzdGF0cykge1xuICAgICAgZGVidWczPy4oe1xuICAgICAgICBuYW1lLFxuICAgICAgICByZW5kZXJDdHgsXG4gICAgICAgIHJlc3VsdDogXCJyZW5kZXJlZFwiLFxuICAgICAgICBza2lwcGVkOiBzdGF0cy5ub2Rlc1NraXBwZWQsXG4gICAgICAgIGNvdW50czogbm9kZUNvdW50KHRoaXMpLFxuICAgICAgICBncm91cDogdGhpc1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGRlcml2ZVpJbmRleEZyb21DaGlsZHJlbigpIHtcbiAgICBsZXQgbGFzdENoaWxkO1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbigpKSB7XG4gICAgICBpZiAoIWNoaWxkLmNoaWxkTm9kZUNvdW50cy5ub25Hcm91cHMpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgaWYgKCFsYXN0Q2hpbGQgfHwgR3JvdXAuY29tcGFyZUNoaWxkcmVuKGxhc3RDaGlsZCwgY2hpbGQpIDwgMCkge1xuICAgICAgICBsYXN0Q2hpbGQgPSBjaGlsZDtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy56SW5kZXggPSBsYXN0Q2hpbGQ/LnpJbmRleCA/PyAtSW5maW5pdHk7XG4gICAgdGhpcy56SW5kZXhTdWJPcmRlciA9IGxhc3RDaGlsZD8uekluZGV4U3ViT3JkZXI7XG4gIH1cbiAgX3NldExheWVyTWFuYWdlcihsYXllcnNNYW5hZ2VyKSB7XG4gICAgaWYgKHRoaXMubGF5ZXIpIHtcbiAgICAgIHRoaXMuX2xheWVyTWFuYWdlcj8ucmVtb3ZlTGF5ZXIodGhpcy5sYXllcik7XG4gICAgICB0aGlzLmxheWVyID0gdm9pZCAwO1xuICAgIH1cbiAgICBzdXBlci5fc2V0TGF5ZXJNYW5hZ2VyKGxheWVyc01hbmFnZXIpO1xuICB9XG4gIGdldENvbXB1dGVkT3BhY2l0eSgpIHtcbiAgICBsZXQgb3BhY2l0eSA9IDE7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIHRoaXMudHJhdmVyc2VVcCh0cnVlKSkge1xuICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICBvcGFjaXR5ICo9IG5vZGUub3BhY2l0eTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wYWNpdHk7XG4gIH1cbiAgZ2V0VmlzaWJpbGl0eSgpIHtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgdGhpcy50cmF2ZXJzZVVwKHRydWUpKSB7XG4gICAgICBpZiAoIW5vZGUudmlzaWJsZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIG9uVmlzaWJsZUNoYW5nZSgpIHtcbiAgICBpZiAodGhpcy5sYXllcikge1xuICAgICAgdGhpcy5sYXllci5lbmFibGVkID0gdGhpcy52aXNpYmxlO1xuICAgIH1cbiAgfVxuICBvblpJbmRleENoYW5nZSgpIHtcbiAgICBzdXBlci5vblpJbmRleENoYW5nZSgpO1xuICAgIGlmICh0aGlzLmxheWVyKSB7XG4gICAgICB0aGlzLl9sYXllck1hbmFnZXI/Lm1vdmVMYXllcih0aGlzLmxheWVyLCB0aGlzLnpJbmRleCwgdGhpcy56SW5kZXhTdWJPcmRlcik7XG4gICAgfVxuICB9XG59O1xuX0xheWVyLmNsYXNzTmFtZSA9IFwiTGF5ZXJcIjtcbnZhciBMYXllciA9IF9MYXllcjtcbnZhciBUcmFuc2xhdGFibGVMYXllciA9IGNsYXNzIGV4dGVuZHMgVHJhbnNsYXRhYmxlKExheWVyKSB7XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9zaGFwZS9yYW5nZS50c1xudmFyIFJhbmdlID0gY2xhc3MgZXh0ZW5kcyBTaGFwZSB7XG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIHN1cGVyKG9wdHMpO1xuICAgIHRoaXMueDEgPSAwO1xuICAgIHRoaXMueTEgPSAwO1xuICAgIHRoaXMueDIgPSAwO1xuICAgIHRoaXMueTIgPSAwO1xuICAgIHRoaXMuc3RhcnRMaW5lID0gZmFsc2U7XG4gICAgdGhpcy5lbmRMaW5lID0gZmFsc2U7XG4gICAgdGhpcy5pc1JhbmdlID0gZmFsc2U7XG4gICAgdGhpcy5yZXN0b3JlT3duU3R5bGVzKCk7XG4gIH1cbiAgY29tcHV0ZUJCb3goKSB7XG4gICAgcmV0dXJuIG5ldyBCQm94KHRoaXMueDEsIHRoaXMueTEsIHRoaXMueDIgLSB0aGlzLngxLCB0aGlzLnkyIC0gdGhpcy55MSk7XG4gIH1cbiAgaXNQb2ludEluUGF0aChfeCwgX3kpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmVuZGVyKHJlbmRlckN0eCkge1xuICAgIGNvbnN0IHsgY3R4LCBmb3JjZVJlbmRlciwgc3RhdHMgfSA9IHJlbmRlckN0eDtcbiAgICBpZiAodGhpcy5kaXJ0eSA9PT0gMCAvKiBOT05FICovICYmICFmb3JjZVJlbmRlcikge1xuICAgICAgaWYgKHN0YXRzKVxuICAgICAgICBzdGF0cy5ub2Rlc1NraXBwZWQgKz0gbm9kZUNvdW50KHRoaXMpLmNvdW50O1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgeyB4MSwgeTEsIHgyLCB5MiB9ID0gdGhpcztcbiAgICB4MSA9IHRoaXMuYWxpZ24oeDEpO1xuICAgIHkxID0gdGhpcy5hbGlnbih5MSk7XG4gICAgeDIgPSB0aGlzLmFsaWduKHgyKTtcbiAgICB5MiA9IHRoaXMuYWxpZ24oeTIpO1xuICAgIGNvbnN0IHsgZmlsbCwgb3BhY2l0eSwgaXNSYW5nZSB9ID0gdGhpcztcbiAgICBjb25zdCBmaWxsQWN0aXZlID0gISEoaXNSYW5nZSAmJiBmaWxsKTtcbiAgICBpZiAoZmlsbEFjdGl2ZSkge1xuICAgICAgY29uc3QgeyBmaWxsT3BhY2l0eSB9ID0gdGhpcztcbiAgICAgIHRoaXMuYXBwbHlGaWxsKGN0eCk7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgPSBvcGFjaXR5ICogZmlsbE9wYWNpdHk7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKHgxLCB5MSk7XG4gICAgICBjdHgubGluZVRvKHgyLCB5MSk7XG4gICAgICBjdHgubGluZVRvKHgyLCB5Mik7XG4gICAgICBjdHgubGluZVRvKHgxLCB5Mik7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBjdHguZmlsbCgpO1xuICAgIH1cbiAgICBjb25zdCB7IHN0cm9rZSwgc3Ryb2tlV2lkdGgsIHN0YXJ0TGluZSwgZW5kTGluZSB9ID0gdGhpcztcbiAgICBjb25zdCBzdHJva2VBY3RpdmUgPSAhISgoc3RhcnRMaW5lIHx8IGVuZExpbmUpICYmIHN0cm9rZSAmJiBzdHJva2VXaWR0aCk7XG4gICAgaWYgKHN0cm9rZUFjdGl2ZSkge1xuICAgICAgY29uc3QgeyBzdHJva2VPcGFjaXR5LCBsaW5lRGFzaCwgbGluZURhc2hPZmZzZXQsIGxpbmVDYXAsIGxpbmVKb2luIH0gPSB0aGlzO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlO1xuICAgICAgY3R4Lmdsb2JhbEFscGhhID0gb3BhY2l0eSAqIHN0cm9rZU9wYWNpdHk7XG4gICAgICBjdHgubGluZVdpZHRoID0gc3Ryb2tlV2lkdGg7XG4gICAgICBpZiAobGluZURhc2gpIHtcbiAgICAgICAgY3R4LnNldExpbmVEYXNoKGxpbmVEYXNoKTtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lRGFzaE9mZnNldCkge1xuICAgICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBsaW5lRGFzaE9mZnNldDtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lQ2FwKSB7XG4gICAgICAgIGN0eC5saW5lQ2FwID0gbGluZUNhcDtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lSm9pbikge1xuICAgICAgICBjdHgubGluZUpvaW4gPSBsaW5lSm9pbjtcbiAgICAgIH1cbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGlmIChzdGFydExpbmUpIHtcbiAgICAgICAgY3R4Lm1vdmVUbyh4MSwgeTEpO1xuICAgICAgICBjdHgubGluZVRvKHgyLCB5MSk7XG4gICAgICB9XG4gICAgICBpZiAoZW5kTGluZSkge1xuICAgICAgICBjdHgubW92ZVRvKHgyLCB5Mik7XG4gICAgICAgIGN0eC5saW5lVG8oeDEsIHkyKTtcbiAgICAgIH1cbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG4gICAgdGhpcy5maWxsU2hhZG93Py5tYXJrQ2xlYW4oKTtcbiAgICBzdXBlci5yZW5kZXIocmVuZGVyQ3R4KTtcbiAgfVxufTtcblJhbmdlLmNsYXNzTmFtZSA9IFwiUmFuZ2VcIjtcblJhbmdlLmRlZmF1bHRTdHlsZXMgPSB7XG4gIC4uLlNoYXBlLmRlZmF1bHRTdHlsZXMsXG4gIHN0cm9rZVdpZHRoOiAxXG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDIgLyogTUlOT1IgKi8gfSlcbl0sIFJhbmdlLnByb3RvdHlwZSwgXCJ4MVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAyIC8qIE1JTk9SICovIH0pXG5dLCBSYW5nZS5wcm90b3R5cGUsIFwieTFcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMiAvKiBNSU5PUiAqLyB9KVxuXSwgUmFuZ2UucHJvdG90eXBlLCBcIngyXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDIgLyogTUlOT1IgKi8gfSlcbl0sIFJhbmdlLnByb3RvdHlwZSwgXCJ5MlwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAyIC8qIE1JTk9SICovIH0pXG5dLCBSYW5nZS5wcm90b3R5cGUsIFwic3RhcnRMaW5lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDIgLyogTUlOT1IgKi8gfSlcbl0sIFJhbmdlLnByb3RvdHlwZSwgXCJlbmRMaW5lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDIgLyogTUlOT1IgKi8gfSlcbl0sIFJhbmdlLnByb3RvdHlwZSwgXCJpc1JhbmdlXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9sYWJlbC50c1xudmFyIExhYmVsID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLmZvbnRTaXplID0gMTI7XG4gICAgdGhpcy5mb250RmFtaWx5ID0gXCJWZXJkYW5hLCBzYW5zLXNlcmlmXCI7XG4gIH1cbiAgZ2V0Rm9udCgpIHtcbiAgICByZXR1cm4gVGV4dFV0aWxzLnRvRm9udFN0cmluZyh0aGlzKTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBMYWJlbC5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGFiZWwucHJvdG90eXBlLCBcImNvbG9yXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoRk9OVF9TVFlMRSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGFiZWwucHJvdG90eXBlLCBcImZvbnRTdHlsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZPTlRfV0VJR0hULCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBMYWJlbC5wcm90b3R5cGUsIFwiZm9udFdlaWdodFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIExhYmVsLnByb3RvdHlwZSwgXCJmb250U2l6ZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORylcbl0sIExhYmVsLnByb3RvdHlwZSwgXCJmb250RmFtaWx5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoRlVOQ1RJT04sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIExhYmVsLnByb3RvdHlwZSwgXCJmb3JtYXR0ZXJcIiwgMik7XG5mdW5jdGlvbiBjYWxjdWxhdGVMYWJlbFJvdGF0aW9uKG9wdHMpIHtcbiAgY29uc3QgeyBwYXJhbGxlbEZsaXBSb3RhdGlvbiA9IDAsIHJlZ3VsYXJGbGlwUm90YXRpb24gPSAwIH0gPSBvcHRzO1xuICBjb25zdCBjb25maWd1cmVkUm90YXRpb24gPSBvcHRzLnJvdGF0aW9uID8gbm9ybWFsaXplQW5nbGUzNjAodG9SYWRpYW5zKG9wdHMucm90YXRpb24pKSA6IDA7XG4gIGNvbnN0IHBhcmFsbGVsRmxpcEZsYWcgPSAhY29uZmlndXJlZFJvdGF0aW9uICYmIHBhcmFsbGVsRmxpcFJvdGF0aW9uID49IDAgJiYgcGFyYWxsZWxGbGlwUm90YXRpb24gPD0gTWF0aC5QSSA/IC0xIDogMTtcbiAgY29uc3QgcmVndWxhckZsaXBGbGFnID0gIWNvbmZpZ3VyZWRSb3RhdGlvbiAmJiByZWd1bGFyRmxpcFJvdGF0aW9uID49IDAgJiYgcmVndWxhckZsaXBSb3RhdGlvbiA8PSBNYXRoLlBJID8gLTEgOiAxO1xuICBsZXQgZGVmYXVsdFJvdGF0aW9uID0gMDtcbiAgaWYgKG9wdHMucGFyYWxsZWwpIHtcbiAgICBkZWZhdWx0Um90YXRpb24gPSBwYXJhbGxlbEZsaXBGbGFnICogTWF0aC5QSSAvIDI7XG4gIH0gZWxzZSBpZiAocmVndWxhckZsaXBGbGFnID09PSAtMSkge1xuICAgIGRlZmF1bHRSb3RhdGlvbiA9IE1hdGguUEk7XG4gIH1cbiAgcmV0dXJuIHsgY29uZmlndXJlZFJvdGF0aW9uLCBkZWZhdWx0Um90YXRpb24sIHBhcmFsbGVsRmxpcEZsYWcsIHJlZ3VsYXJGbGlwRmxhZyB9O1xufVxuZnVuY3Rpb24gZ2V0TGFiZWxTcGFjaW5nKG1pblNwYWNpbmcsIHJvdGF0ZWQpIHtcbiAgaWYgKCFpc05hTihtaW5TcGFjaW5nKSkge1xuICAgIHJldHVybiBtaW5TcGFjaW5nO1xuICB9XG4gIHJldHVybiByb3RhdGVkID8gMCA6IDEwO1xufVxuZnVuY3Rpb24gZ2V0VGV4dEJhc2VsaW5lKHBhcmFsbGVsLCBsYWJlbFJvdGF0aW9uLCBzaWRlRmxhZywgcGFyYWxsZWxGbGlwRmxhZykge1xuICBpZiAocGFyYWxsZWwgJiYgIWxhYmVsUm90YXRpb24pIHtcbiAgICByZXR1cm4gc2lkZUZsYWcgKiBwYXJhbGxlbEZsaXBGbGFnID09PSAtMSA/IFwiaGFuZ2luZ1wiIDogXCJib3R0b21cIjtcbiAgfVxuICByZXR1cm4gXCJtaWRkbGVcIjtcbn1cbmZ1bmN0aW9uIGdldFRleHRBbGlnbihwYXJhbGxlbCwgbGFiZWxSb3RhdGlvbiwgbGFiZWxBdXRvUm90YXRpb24sIHNpZGVGbGFnLCByZWd1bGFyRmxpcEZsYWcpIHtcbiAgY29uc3QgbGFiZWxSb3RhdGVkID0gbGFiZWxSb3RhdGlvbiA+IDAgJiYgbGFiZWxSb3RhdGlvbiA8PSBNYXRoLlBJO1xuICBjb25zdCBsYWJlbEF1dG9Sb3RhdGVkID0gbGFiZWxBdXRvUm90YXRpb24gPiAwICYmIGxhYmVsQXV0b1JvdGF0aW9uIDw9IE1hdGguUEk7XG4gIGNvbnN0IGFsaWduRmxhZyA9IGxhYmVsUm90YXRlZCB8fCBsYWJlbEF1dG9Sb3RhdGVkID8gLTEgOiAxO1xuICBpZiAocGFyYWxsZWwpIHtcbiAgICBpZiAobGFiZWxSb3RhdGlvbiB8fCBsYWJlbEF1dG9Sb3RhdGlvbikge1xuICAgICAgaWYgKHNpZGVGbGFnICogYWxpZ25GbGFnID09PSAtMSkge1xuICAgICAgICByZXR1cm4gXCJlbmRcIjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFwiY2VudGVyXCI7XG4gICAgfVxuICB9IGVsc2UgaWYgKHNpZGVGbGFnICogcmVndWxhckZsaXBGbGFnID09PSAtMSkge1xuICAgIHJldHVybiBcImVuZFwiO1xuICB9XG4gIHJldHVybiBcInN0YXJ0XCI7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVMYWJlbEJCb3godGV4dCwgYmJveCwgbGFiZWxNYXRyaXgpIHtcbiAgY29uc3QgeyB4OiBsYWJlbFgsIHk6IGxhYmVsWSwgd2lkdGg6IHdpZHRoMiwgaGVpZ2h0OiBoZWlnaHQyIH0gPSBiYm94O1xuICBjb25zdCB0cmFuc2xhdGVkQkJveCA9IG5ldyBCQm94KGxhYmVsWCwgbGFiZWxZLCAwLCAwKTtcbiAgbGFiZWxNYXRyaXgudHJhbnNmb3JtQkJveCh0cmFuc2xhdGVkQkJveCwgYmJveCk7XG4gIGNvbnN0IHsgeCwgeSB9ID0gYmJveDtcbiAgcmV0dXJuIHtcbiAgICBwb2ludDogeyB4LCB5IH0sXG4gICAgbGFiZWw6IHsgdGV4dCwgd2lkdGg6IHdpZHRoMiwgaGVpZ2h0OiBoZWlnaHQyIH1cbiAgfTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvekluZGV4TWFwLnRzXG52YXIgWkluZGV4TWFwID0gLyogQF9fUFVSRV9fICovICgoWkluZGV4TWFwMikgPT4ge1xuICBaSW5kZXhNYXAyW1pJbmRleE1hcDJbXCJTRVJJRVNfQkFDS0dST1VORFwiXSA9IDBdID0gXCJTRVJJRVNfQkFDS0dST1VORFwiO1xuICBaSW5kZXhNYXAyW1pJbmRleE1hcDJbXCJBWElTX0dSSURcIl0gPSAxXSA9IFwiQVhJU19HUklEXCI7XG4gIFpJbmRleE1hcDJbWkluZGV4TWFwMltcIkFYSVNcIl0gPSAyXSA9IFwiQVhJU1wiO1xuICBaSW5kZXhNYXAyW1pJbmRleE1hcDJbXCJTRVJJRVNfQ1JPU1NMSU5FX1JBTkdFXCJdID0gM10gPSBcIlNFUklFU19DUk9TU0xJTkVfUkFOR0VcIjtcbiAgWkluZGV4TWFwMltaSW5kZXhNYXAyW1wiU0VSSUVTX0xBWUVSXCJdID0gNF0gPSBcIlNFUklFU19MQVlFUlwiO1xuICBaSW5kZXhNYXAyW1pJbmRleE1hcDJbXCJTRVJJRVNfSElHSExJR0hUXCJdID0gNV0gPSBcIlNFUklFU19ISUdITElHSFRcIjtcbiAgWkluZGV4TWFwMltaSW5kZXhNYXAyW1wiQVhJU19GT1JFR1JPVU5EXCJdID0gNl0gPSBcIkFYSVNfRk9SRUdST1VORFwiO1xuICBaSW5kZXhNYXAyW1pJbmRleE1hcDJbXCJTRVJJRVNfQ1JPU1NIQUlSXCJdID0gN10gPSBcIlNFUklFU19DUk9TU0hBSVJcIjtcbiAgWkluZGV4TWFwMltaSW5kZXhNYXAyW1wiQ0hBUlRfT1ZFUkxBWVwiXSA9IDhdID0gXCJDSEFSVF9PVkVSTEFZXCI7XG4gIFpJbmRleE1hcDJbWkluZGV4TWFwMltcIlNFUklFU19DUk9TU0xJTkVfTElORVwiXSA9IDldID0gXCJTRVJJRVNfQ1JPU1NMSU5FX0xJTkVcIjtcbiAgWkluZGV4TWFwMltaSW5kZXhNYXAyW1wiU0VSSUVTX0FOTk9UQVRJT05cIl0gPSAxMF0gPSBcIlNFUklFU19BTk5PVEFUSU9OXCI7XG4gIFpJbmRleE1hcDJbWkluZGV4TWFwMltcIkNIQVJUX0FOTk9UQVRJT05cIl0gPSAxMV0gPSBcIkNIQVJUX0FOTk9UQVRJT05cIjtcbiAgWkluZGV4TWFwMltaSW5kZXhNYXAyW1wiQ0hBUlRfQU5OT1RBVElPTl9GT0NVU0VEXCJdID0gMTJdID0gXCJDSEFSVF9BTk5PVEFUSU9OX0ZPQ1VTRURcIjtcbiAgWkluZGV4TWFwMltaSW5kZXhNYXAyW1wiU1RBVFVTX0JBUlwiXSA9IDEzXSA9IFwiU1RBVFVTX0JBUlwiO1xuICBaSW5kZXhNYXAyW1pJbmRleE1hcDJbXCJTRVJJRVNfTEFCRUxcIl0gPSAxNF0gPSBcIlNFUklFU19MQUJFTFwiO1xuICBaSW5kZXhNYXAyW1pJbmRleE1hcDJbXCJMRUdFTkRcIl0gPSAxNV0gPSBcIkxFR0VORFwiO1xuICBaSW5kZXhNYXAyW1pJbmRleE1hcDJbXCJOQVZJR0FUT1JcIl0gPSAxNl0gPSBcIk5BVklHQVRPUlwiO1xuICBaSW5kZXhNYXAyW1pJbmRleE1hcDJbXCJGT1JFR1JPVU5EXCJdID0gMTddID0gXCJGT1JFR1JPVU5EXCI7XG4gIHJldHVybiBaSW5kZXhNYXAyO1xufSkoWkluZGV4TWFwIHx8IHt9KTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC92YWx1ZS50c1xuZnVuY3Rpb24gaXNTdHJpbmdPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093bih2YWx1ZSwgXCJ0b1N0cmluZ1wiKSAmJiBpc1N0cmluZyh2YWx1ZS50b1N0cmluZygpKTtcbn1cbmZ1bmN0aW9uIGlzTnVtYmVyT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd24odmFsdWUsIFwidmFsdWVPZlwiKSAmJiBpc0Zpbml0ZU51bWJlcih2YWx1ZS52YWx1ZU9mKCkpO1xufVxuZnVuY3Rpb24gaXNDb250aW51b3VzKHZhbHVlKSB7XG4gIHJldHVybiBpc0Zpbml0ZU51bWJlcih2YWx1ZSkgfHwgaXNWYWxpZERhdGUodmFsdWUpIHx8IGlzTnVtYmVyT2JqZWN0KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGNoZWNrRGF0dW0odmFsdWUsIGlzQ29udGludW91c1NjYWxlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICghaXNDb250aW51b3VzU2NhbGUgfHwgaXNDb250aW51b3VzKHZhbHVlKSk7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1JbnRlZ3JhdGVkQ2F0ZWdvcnlWYWx1ZSh2YWx1ZSkge1xuICBpZiAoaXNTdHJpbmdPYmplY3QodmFsdWUpICYmIE9iamVjdC5oYXNPd24odmFsdWUsIFwiaWRcIikpIHtcbiAgICByZXR1cm4gdmFsdWUuaWQ7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9jcm9zc2xpbmUvY3Jvc3NMaW5lLnRzXG52YXIgTUFUQ0hJTkdfQ1JPU1NMSU5FX1RZUEUgPSAocHJvcGVydHkpID0+IHtcbiAgcmV0dXJuIHByb3BlcnR5ID09PSBcInZhbHVlXCIgPyBwcmVkaWNhdGVXaXRoTWVzc2FnZShcbiAgICAoXywgY3R4KSA9PiBjdHgudGFyZ2V0W1widHlwZVwiXSA9PT0gXCJsaW5lXCIsXG4gICAgKGN0eCkgPT4gY3R4LnRhcmdldFtcInR5cGVcIl0gPT09IFwicmFuZ2VcIiA/IGBjcm9zc0xpbmUgdHlwZSAncmFuZ2UnIHRvIGhhdmUgYSAncmFuZ2UnIHByb3BlcnR5IGluc3RlYWQgb2YgJ3ZhbHVlJ2AgOiBgY3Jvc3NMaW5lIHByb3BlcnR5ICd0eXBlJyB0byBiZSAnbGluZSdgXG4gICkgOiBwcmVkaWNhdGVXaXRoTWVzc2FnZShcbiAgICAoXywgY3R4KSA9PiBjdHgudGFyZ2V0W1widHlwZVwiXSA9PT0gXCJyYW5nZVwiLFxuICAgIChjdHgpID0+IGN0eC50YXJnZXQudHlwZSA9PT0gXCJsaW5lXCIgPyBgY3Jvc3NMaW5lIHR5cGUgJ2xpbmUnIHRvIGhhdmUgYSAndmFsdWUnIHByb3BlcnR5IGluc3RlYWQgb2YgJ3JhbmdlJ2AgOiBgY3Jvc3NMaW5lIHByb3BlcnR5ICd0eXBlJyB0byBiZSAncmFuZ2UnYFxuICApO1xufTtcbnZhciB2YWxpZGF0ZUNyb3NzTGluZVZhbHVlcyA9ICh0eXBlLCB2YWx1ZSwgcmFuZ2UzLCBzY2FsZTIsIHZpc2liaWxpdHlDaGVjaykgPT4ge1xuICBjb25zdCBsaW5lQ3Jvc3NMaW5lID0gdHlwZSA9PT0gXCJsaW5lXCIgJiYgdmFsdWUgIT09IHZvaWQgMDtcbiAgY29uc3QgcmFuZ2VDcm9zc0xpbmUgPSB0eXBlID09PSBcInJhbmdlXCIgJiYgcmFuZ2UzICE9PSB2b2lkIDA7XG4gIGlmICghbGluZUNyb3NzTGluZSAmJiAhcmFuZ2VDcm9zc0xpbmUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBbc3RhcnQyLCBlbmQyXSA9IHJhbmdlMyA/PyBbdmFsdWUsIHZvaWQgMF07XG4gIGNvbnN0IGlzQ29udGludW91czIgPSBDb250aW51b3VzU2NhbGUuaXMoc2NhbGUyKSB8fCBPcmRpbmFsVGltZVNjYWxlLmlzKHNjYWxlMik7XG4gIGNvbnN0IHZhbGlkU3RhcnQgPSBjaGVja0RhdHVtKHN0YXJ0MiwgaXNDb250aW51b3VzMikgJiYgIWlzTmFOKHNjYWxlMi5jb252ZXJ0KHN0YXJ0MikpO1xuICBjb25zdCB2YWxpZEVuZCA9IGNoZWNrRGF0dW0oZW5kMiwgaXNDb250aW51b3VzMikgJiYgIWlzTmFOKHNjYWxlMi5jb252ZXJ0KGVuZDIpKTtcbiAgaWYgKGxpbmVDcm9zc0xpbmUgJiYgdmFsaWRTdGFydCB8fCByYW5nZUNyb3NzTGluZSAmJiB2YWxpZFN0YXJ0ICYmIHZhbGlkRW5kKSB7XG4gICAgcmV0dXJuIHZpc2liaWxpdHlDaGVjaz8uKCkgPz8gdHJ1ZTtcbiAgfVxuICBjb25zdCBtZXNzYWdlID0gW2BFeHBlY3RpbmcgY3Jvc3NMaW5lYF07XG4gIGlmIChyYW5nZUNyb3NzTGluZSkge1xuICAgIGlmICghdmFsaWRTdGFydCkge1xuICAgICAgbWVzc2FnZS5wdXNoKGByYW5nZSBzdGFydCAke3N0cmluZ2lmeShzdGFydDIpfWApO1xuICAgIH1cbiAgICBpZiAoIXZhbGlkRW5kKSB7XG4gICAgICBtZXNzYWdlLnB1c2goYCR7dmFsaWRTdGFydCA/IFwiXCIgOiBcImFuZCBcIn1yYW5nZSBlbmQgJHtzdHJpbmdpZnkoZW5kMil9YCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG1lc3NhZ2UucHVzaChgdmFsdWUgJHtzdHJpbmdpZnkoc3RhcnQyKX1gKTtcbiAgfVxuICBtZXNzYWdlLnB1c2goYHRvIG1hdGNoIHRoZSBheGlzIHNjYWxlIGRvbWFpbi5gKTtcbiAgTG9nZ2VyLndhcm5PbmNlKG1lc3NhZ2Uuam9pbihcIiBcIikpO1xuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9jcm9zc2xpbmUvY3Jvc3NMaW5lTGFiZWxQb3NpdGlvbi50c1xudmFyIGhvcml6b250YWxDcm9zc2xpbmVUcmFuc2xhdGlvbkRpcmVjdGlvbnMgPSB7XG4gIHRvcDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IDAsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEgfSxcbiAgYm90dG9tOiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogMCwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxIH0sXG4gIGxlZnQ6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAtMSwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAwIH0sXG4gIHJpZ2h0OiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAwIH0sXG4gIHRvcExlZnQ6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xIH0sXG4gIHRvcFJpZ2h0OiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEgfSxcbiAgYm90dG9tTGVmdDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IDEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSB9LFxuICBib3R0b21SaWdodDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IDEgfSxcbiAgaW5zaWRlOiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogMCwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAwIH0sXG4gIGluc2lkZUxlZnQ6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IDAgfSxcbiAgaW5zaWRlUmlnaHQ6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAtMSwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAwIH0sXG4gIGluc2lkZVRvcDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IDAsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSB9LFxuICBpbnNpZGVCb3R0b206IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAwLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xIH0sXG4gIGluc2lkZVRvcExlZnQ6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IDEgfSxcbiAgaW5zaWRlQm90dG9tTGVmdDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IDEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEgfSxcbiAgaW5zaWRlVG9wUmlnaHQ6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAtMSwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxIH0sXG4gIGluc2lkZUJvdHRvbVJpZ2h0OiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEgfVxufTtcbnZhciB2ZXJ0aWNhbENyb3NzTGluZVRyYW5zbGF0aW9uRGlyZWN0aW9ucyA9IHtcbiAgdG9wOiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAwIH0sXG4gIGJvdHRvbTogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IDAgfSxcbiAgbGVmdDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IDAsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEgfSxcbiAgcmlnaHQ6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAwLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IDEgfSxcbiAgdG9wTGVmdDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xIH0sXG4gIHRvcFJpZ2h0OiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSB9LFxuICBib3R0b21MZWZ0OiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAtMSB9LFxuICBib3R0b21SaWdodDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IDEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSB9LFxuICBpbnNpZGU6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAwLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IDAgfSxcbiAgaW5zaWRlTGVmdDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IDAsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSB9LFxuICBpbnNpZGVSaWdodDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IDAsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEgfSxcbiAgaW5zaWRlVG9wOiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogMCB9LFxuICBpbnNpZGVCb3R0b206IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IDAgfSxcbiAgaW5zaWRlVG9wTGVmdDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IDEgfSxcbiAgaW5zaWRlQm90dG9tTGVmdDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IDEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSB9LFxuICBpbnNpZGVUb3BSaWdodDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xIH0sXG4gIGluc2lkZUJvdHRvbVJpZ2h0OiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAtMSB9XG59O1xuZnVuY3Rpb24gY2FsY3VsYXRlTGFiZWxUcmFuc2xhdGlvbih7XG4gIHlEaXJlY3Rpb24sXG4gIHBhZGRpbmcgPSAwLFxuICBwb3NpdGlvbiA9IFwidG9wXCIsXG4gIGJib3hcbn0pIHtcbiAgY29uc3QgY3Jvc3NMaW5lVHJhbnNsYXRpb25EaXJlY3Rpb25zID0geURpcmVjdGlvbiA/IGhvcml6b250YWxDcm9zc2xpbmVUcmFuc2xhdGlvbkRpcmVjdGlvbnMgOiB2ZXJ0aWNhbENyb3NzTGluZVRyYW5zbGF0aW9uRGlyZWN0aW9ucztcbiAgY29uc3QgeyB4VHJhbnNsYXRpb25EaXJlY3Rpb24sIHlUcmFuc2xhdGlvbkRpcmVjdGlvbiB9ID0gY3Jvc3NMaW5lVHJhbnNsYXRpb25EaXJlY3Rpb25zW3Bvc2l0aW9uXTtcbiAgY29uc3QgeFRyYW5zbGF0aW9uID0geFRyYW5zbGF0aW9uRGlyZWN0aW9uICogKHBhZGRpbmcgKyBiYm94LndpZHRoIC8gMik7XG4gIGNvbnN0IHlUcmFuc2xhdGlvbiA9IHlUcmFuc2xhdGlvbkRpcmVjdGlvbiAqIChwYWRkaW5nICsgYmJveC5oZWlnaHQgLyAyKTtcbiAgcmV0dXJuIHtcbiAgICB4VHJhbnNsYXRpb24sXG4gICAgeVRyYW5zbGF0aW9uXG4gIH07XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVMYWJlbENoYXJ0UGFkZGluZyh7XG4gIHlEaXJlY3Rpb24sXG4gIGJib3gsXG4gIHBhZGRpbmcgPSAwLFxuICBwb3NpdGlvbiA9IFwidG9wXCJcbn0pIHtcbiAgY29uc3QgY2hhcnRQYWRkaW5nID0ge307XG4gIGlmIChwb3NpdGlvbi5zdGFydHNXaXRoKFwiaW5zaWRlXCIpKVxuICAgIHJldHVybiBjaGFydFBhZGRpbmc7XG4gIGlmIChwb3NpdGlvbiA9PT0gXCJ0b3BcIiAmJiAheURpcmVjdGlvbikge1xuICAgIGNoYXJ0UGFkZGluZy50b3AgPSBwYWRkaW5nICsgYmJveC5oZWlnaHQ7XG4gIH0gZWxzZSBpZiAocG9zaXRpb24gPT09IFwiYm90dG9tXCIgJiYgIXlEaXJlY3Rpb24pIHtcbiAgICBjaGFydFBhZGRpbmcuYm90dG9tID0gcGFkZGluZyArIGJib3guaGVpZ2h0O1xuICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSBcImxlZnRcIiAmJiB5RGlyZWN0aW9uKSB7XG4gICAgY2hhcnRQYWRkaW5nLmxlZnQgPSBwYWRkaW5nICsgYmJveC53aWR0aDtcbiAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gXCJyaWdodFwiICYmIHlEaXJlY3Rpb24pIHtcbiAgICBjaGFydFBhZGRpbmcucmlnaHQgPSBwYWRkaW5nICsgYmJveC53aWR0aDtcbiAgfVxuICByZXR1cm4gY2hhcnRQYWRkaW5nO1xufVxudmFyIFBPU0lUSU9OX1RPUF9DT09SRElOQVRFUyA9ICh7IGRpcmVjdGlvbiwgeEVuZCwgeVN0YXJ0LCB5RW5kIH0pID0+IHtcbiAgaWYgKGRpcmVjdGlvbiA9PT0gXCJ5XCIgLyogWSAqLykge1xuICAgIHJldHVybiB7IHg6IHhFbmQgLyAyLCB5OiB5U3RhcnQgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geyB4OiB4RW5kLCB5OiBpc05hTih5RW5kKSA/IHlTdGFydCA6ICh5U3RhcnQgKyB5RW5kKSAvIDIgfTtcbiAgfVxufTtcbnZhciBQT1NJVElPTl9MRUZUX0NPT1JESU5BVEVTID0gKHsgZGlyZWN0aW9uLCB4U3RhcnQsIHhFbmQsIHlTdGFydCwgeUVuZCB9KSA9PiB7XG4gIGlmIChkaXJlY3Rpb24gPT09IFwieVwiIC8qIFkgKi8pIHtcbiAgICByZXR1cm4geyB4OiB4U3RhcnQsIHk6IGlzTmFOKHlFbmQpID8geVN0YXJ0IDogKHlTdGFydCArIHlFbmQpIC8gMiB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7IHg6IHhFbmQgLyAyLCB5OiB5U3RhcnQgfTtcbiAgfVxufTtcbnZhciBQT1NJVElPTl9SSUdIVF9DT09SRElOQVRFUyA9ICh7IGRpcmVjdGlvbiwgeEVuZCwgeVN0YXJ0LCB5RW5kIH0pID0+IHtcbiAgaWYgKGRpcmVjdGlvbiA9PT0gXCJ5XCIgLyogWSAqLykge1xuICAgIHJldHVybiB7IHg6IHhFbmQsIHk6IGlzTmFOKHlFbmQpID8geVN0YXJ0IDogKHlTdGFydCArIHlFbmQpIC8gMiB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7IHg6IHhFbmQgLyAyLCB5OiBpc05hTih5RW5kKSA/IHlTdGFydCA6IHlFbmQgfTtcbiAgfVxufTtcbnZhciBQT1NJVElPTl9CT1RUT01fQ09PUkRJTkFURVMgPSAoeyBkaXJlY3Rpb24sIHhTdGFydCwgeEVuZCwgeVN0YXJ0LCB5RW5kIH0pID0+IHtcbiAgaWYgKGRpcmVjdGlvbiA9PT0gXCJ5XCIgLyogWSAqLykge1xuICAgIHJldHVybiB7IHg6IHhFbmQgLyAyLCB5OiBpc05hTih5RW5kKSA/IHlTdGFydCA6IHlFbmQgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geyB4OiB4U3RhcnQsIHk6IGlzTmFOKHlFbmQpID8geVN0YXJ0IDogKHlTdGFydCArIHlFbmQpIC8gMiB9O1xuICB9XG59O1xudmFyIFBPU0lUSU9OX0lOU0lERV9DT09SRElOQVRFUyA9ICh7IHhFbmQsIHlTdGFydCwgeUVuZCB9KSA9PiB7XG4gIHJldHVybiB7IHg6IHhFbmQgLyAyLCB5OiBpc05hTih5RW5kKSA/IHlTdGFydCA6ICh5U3RhcnQgKyB5RW5kKSAvIDIgfTtcbn07XG52YXIgUE9TSVRJT05fVE9QX0xFRlRfQ09PUkRJTkFURVMgPSAoeyBkaXJlY3Rpb24sIHhTdGFydCwgeEVuZCwgeVN0YXJ0IH0pID0+IHtcbiAgaWYgKGRpcmVjdGlvbiA9PT0gXCJ5XCIgLyogWSAqLykge1xuICAgIHJldHVybiB7IHg6IHhTdGFydCAvIDIsIHk6IHlTdGFydCB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7IHg6IHhFbmQsIHk6IHlTdGFydCB9O1xuICB9XG59O1xudmFyIFBPU0lUSU9OX0JPVFRPTV9MRUZUX0NPT1JESU5BVEVTID0gKHsgZGlyZWN0aW9uLCB4U3RhcnQsIHlTdGFydCwgeUVuZCB9KSA9PiB7XG4gIGlmIChkaXJlY3Rpb24gPT09IFwieVwiIC8qIFkgKi8pIHtcbiAgICByZXR1cm4geyB4OiB4U3RhcnQsIHk6IGlzTmFOKHlFbmQpID8geVN0YXJ0IDogeUVuZCB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7IHg6IHhTdGFydCwgeTogeVN0YXJ0IH07XG4gIH1cbn07XG52YXIgUE9TSVRJT05fVE9QX1JJR0hUX0NPT1JESU5BVEVTID0gKHsgZGlyZWN0aW9uLCB4RW5kLCB5U3RhcnQsIHlFbmQgfSkgPT4ge1xuICBpZiAoZGlyZWN0aW9uID09PSBcInlcIiAvKiBZICovKSB7XG4gICAgcmV0dXJuIHsgeDogeEVuZCwgeTogeVN0YXJ0IH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHsgeDogeEVuZCwgeTogaXNOYU4oeUVuZCkgPyB5U3RhcnQgOiB5RW5kIH07XG4gIH1cbn07XG52YXIgUE9TSVRJT05fQk9UVE9NX1JJR0hUX0NPT1JESU5BVEVTID0gKHsgZGlyZWN0aW9uLCB4U3RhcnQsIHhFbmQsIHlTdGFydCwgeUVuZCB9KSA9PiB7XG4gIGlmIChkaXJlY3Rpb24gPT09IFwieVwiIC8qIFkgKi8pIHtcbiAgICByZXR1cm4geyB4OiB4RW5kLCB5OiBpc05hTih5RW5kKSA/IHlTdGFydCA6IHlFbmQgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geyB4OiB4U3RhcnQsIHk6IGlzTmFOKHlFbmQpID8geVN0YXJ0IDogeUVuZCB9O1xuICB9XG59O1xudmFyIGxhYmVsRGlyZWN0aW9uSGFuZGxpbmcgPSB7XG4gIHRvcDogeyBjOiBQT1NJVElPTl9UT1BfQ09PUkRJTkFURVMgfSxcbiAgYm90dG9tOiB7IGM6IFBPU0lUSU9OX0JPVFRPTV9DT09SRElOQVRFUyB9LFxuICBsZWZ0OiB7IGM6IFBPU0lUSU9OX0xFRlRfQ09PUkRJTkFURVMgfSxcbiAgcmlnaHQ6IHsgYzogUE9TSVRJT05fUklHSFRfQ09PUkRJTkFURVMgfSxcbiAgdG9wTGVmdDogeyBjOiBQT1NJVElPTl9UT1BfTEVGVF9DT09SRElOQVRFUyB9LFxuICB0b3BSaWdodDogeyBjOiBQT1NJVElPTl9UT1BfUklHSFRfQ09PUkRJTkFURVMgfSxcbiAgYm90dG9tTGVmdDogeyBjOiBQT1NJVElPTl9CT1RUT01fTEVGVF9DT09SRElOQVRFUyB9LFxuICBib3R0b21SaWdodDogeyBjOiBQT1NJVElPTl9CT1RUT01fUklHSFRfQ09PUkRJTkFURVMgfSxcbiAgaW5zaWRlOiB7IGM6IFBPU0lUSU9OX0lOU0lERV9DT09SRElOQVRFUyB9LFxuICBpbnNpZGVMZWZ0OiB7IGM6IFBPU0lUSU9OX0xFRlRfQ09PUkRJTkFURVMgfSxcbiAgaW5zaWRlUmlnaHQ6IHsgYzogUE9TSVRJT05fUklHSFRfQ09PUkRJTkFURVMgfSxcbiAgaW5zaWRlVG9wOiB7IGM6IFBPU0lUSU9OX1RPUF9DT09SRElOQVRFUyB9LFxuICBpbnNpZGVCb3R0b206IHsgYzogUE9TSVRJT05fQk9UVE9NX0NPT1JESU5BVEVTIH0sXG4gIGluc2lkZVRvcExlZnQ6IHsgYzogUE9TSVRJT05fVE9QX0xFRlRfQ09PUkRJTkFURVMgfSxcbiAgaW5zaWRlQm90dG9tTGVmdDogeyBjOiBQT1NJVElPTl9CT1RUT01fTEVGVF9DT09SRElOQVRFUyB9LFxuICBpbnNpZGVUb3BSaWdodDogeyBjOiBQT1NJVElPTl9UT1BfUklHSFRfQ09PUkRJTkFURVMgfSxcbiAgaW5zaWRlQm90dG9tUmlnaHQ6IHsgYzogUE9TSVRJT05fQk9UVE9NX1JJR0hUX0NPT1JESU5BVEVTIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2Nyb3NzbGluZS9jYXJ0ZXNpYW5Dcm9zc0xpbmUudHNcbnZhciBDUk9TU0xJTkVfTEFCRUxfUE9TSVRJT04gPSBVTklPTihcbiAgW1xuICAgIFwidG9wXCIsXG4gICAgXCJsZWZ0XCIsXG4gICAgXCJyaWdodFwiLFxuICAgIFwiYm90dG9tXCIsXG4gICAgXCJ0b3BMZWZ0XCIsXG4gICAgXCJ0b3BSaWdodFwiLFxuICAgIFwiYm90dG9tTGVmdFwiLFxuICAgIFwiYm90dG9tUmlnaHRcIixcbiAgICBcImluc2lkZVwiLFxuICAgIFwiaW5zaWRlTGVmdFwiLFxuICAgIFwiaW5zaWRlUmlnaHRcIixcbiAgICBcImluc2lkZVRvcFwiLFxuICAgIFwiaW5zaWRlQm90dG9tXCIsXG4gICAgXCJpbnNpZGVUb3BMZWZ0XCIsXG4gICAgXCJpbnNpZGVCb3R0b21MZWZ0XCIsXG4gICAgXCJpbnNpZGVUb3BSaWdodFwiLFxuICAgIFwiaW5zaWRlQm90dG9tUmlnaHRcIlxuICBdLFxuICBcImNyb3NzTGluZSBsYWJlbCBwb3NpdGlvblwiXG4pO1xudmFyIENhcnRlc2lhbkNyb3NzTGluZUxhYmVsID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5mb250U2l6ZSA9IDE0O1xuICAgIHRoaXMuZm9udEZhbWlseSA9IFwiVmVyZGFuYSwgc2Fucy1zZXJpZlwiO1xuICAgIHRoaXMucGFkZGluZyA9IDU7XG4gICAgdGhpcy5jb2xvciA9IFwicmdiYSg4NywgODcsIDg3LCAxKVwiO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQ2FydGVzaWFuQ3Jvc3NMaW5lTGFiZWwucHJvdG90eXBlLCBcImVuYWJsZWRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIENhcnRlc2lhbkNyb3NzTGluZUxhYmVsLnByb3RvdHlwZSwgXCJ0ZXh0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoRk9OVF9TVFlMRSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQ2FydGVzaWFuQ3Jvc3NMaW5lTGFiZWwucHJvdG90eXBlLCBcImZvbnRTdHlsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZPTlRfV0VJR0hULCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBDYXJ0ZXNpYW5Dcm9zc0xpbmVMYWJlbC5wcm90b3R5cGUsIFwiZm9udFdlaWdodFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIENhcnRlc2lhbkNyb3NzTGluZUxhYmVsLnByb3RvdHlwZSwgXCJmb250U2l6ZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORylcbl0sIENhcnRlc2lhbkNyb3NzTGluZUxhYmVsLnByb3RvdHlwZSwgXCJmb250RmFtaWx5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTlVNQkVSKVxuXSwgQ2FydGVzaWFuQ3Jvc3NMaW5lTGFiZWwucHJvdG90eXBlLCBcInBhZGRpbmdcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIENhcnRlc2lhbkNyb3NzTGluZUxhYmVsLnByb3RvdHlwZSwgXCJjb2xvclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENST1NTTElORV9MQUJFTF9QT1NJVElPTiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQ2FydGVzaWFuQ3Jvc3NMaW5lTGFiZWwucHJvdG90eXBlLCBcInBvc2l0aW9uXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoREVHUkVFLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBDYXJ0ZXNpYW5Dcm9zc0xpbmVMYWJlbC5wcm90b3R5cGUsIFwicm90YXRpb25cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBDYXJ0ZXNpYW5Dcm9zc0xpbmVMYWJlbC5wcm90b3R5cGUsIFwicGFyYWxsZWxcIiwgMik7XG52YXIgX0NhcnRlc2lhbkNyb3NzTGluZSA9IGNsYXNzIF9DYXJ0ZXNpYW5Dcm9zc0xpbmUgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5pZCA9IGNyZWF0ZUlkKHRoaXMpO1xuICAgIHRoaXMubGFiZWwgPSBuZXcgQ2FydGVzaWFuQ3Jvc3NMaW5lTGFiZWwoKTtcbiAgICB0aGlzLnNjYWxlID0gdm9pZCAwO1xuICAgIHRoaXMuY2xpcHBlZFJhbmdlID0gWy1JbmZpbml0eSwgSW5maW5pdHldO1xuICAgIHRoaXMuZ3JpZExlbmd0aCA9IDA7XG4gICAgdGhpcy5zaWRlRmxhZyA9IC0xO1xuICAgIHRoaXMucGFyYWxsZWxGbGlwUm90YXRpb24gPSAwO1xuICAgIHRoaXMucmVndWxhckZsaXBSb3RhdGlvbiA9IDA7XG4gICAgdGhpcy5kaXJlY3Rpb24gPSBcInhcIiAvKiBYICovO1xuICAgIHRoaXMuZ3JvdXAgPSBuZXcgTGF5ZXIoeyBuYW1lOiB0aGlzLmlkLCB6SW5kZXg6IF9DYXJ0ZXNpYW5Dcm9zc0xpbmUuTElORV9MQVlFUl9aSU5ERVggfSk7XG4gICAgdGhpcy5sYWJlbEdyb3VwID0gbmV3IExheWVyKHsgbmFtZTogdGhpcy5pZCwgekluZGV4OiBfQ2FydGVzaWFuQ3Jvc3NMaW5lLkxBQkVMX0xBWUVSX1pJTkRFWCB9KTtcbiAgICB0aGlzLmNyb3NzTGluZVJhbmdlID0gbmV3IFJhbmdlKCk7XG4gICAgdGhpcy5jcm9zc0xpbmVMYWJlbCA9IG5ldyBUcmFuc2Zvcm1hYmxlVGV4dCgpO1xuICAgIHRoaXMubGFiZWxQb2ludCA9IHZvaWQgMDtcbiAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICB0aGlzLnN0YXJ0TGluZSA9IGZhbHNlO1xuICAgIHRoaXMuZW5kTGluZSA9IGZhbHNlO1xuICAgIHRoaXMuaXNSYW5nZSA9IGZhbHNlO1xuICAgIHRoaXMuZ3JvdXAuYXBwZW5kKHRoaXMuY3Jvc3NMaW5lUmFuZ2UpO1xuICAgIHRoaXMubGFiZWxHcm91cC5hcHBlbmQodGhpcy5jcm9zc0xpbmVMYWJlbCk7XG4gICAgdGhpcy5jcm9zc0xpbmVSYW5nZS5wb2ludGVyRXZlbnRzID0gMSAvKiBOb25lICovO1xuICB9XG4gIHVwZGF0ZSh2aXNpYmxlKSB7XG4gICAgY29uc3QgeyBlbmFibGVkLCBkYXRhLCB0eXBlLCB2YWx1ZSwgcmFuZ2U6IHJhbmdlMywgc2NhbGU6IHNjYWxlMiB9ID0gdGhpcztcbiAgICBpZiAoIXR5cGUgfHwgIXNjYWxlMiB8fCAhZW5hYmxlZCB8fCAhdmlzaWJsZSB8fCAhdmFsaWRhdGVDcm9zc0xpbmVWYWx1ZXModHlwZSwgdmFsdWUsIHJhbmdlMywgc2NhbGUyKSB8fCBkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5ncm91cC52aXNpYmxlID0gZmFsc2U7XG4gICAgICB0aGlzLmxhYmVsR3JvdXAudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmdyb3VwLnZpc2libGUgPSB2aXNpYmxlO1xuICAgIHRoaXMubGFiZWxHcm91cC52aXNpYmxlID0gdmlzaWJsZTtcbiAgICB0aGlzLmdyb3VwLnpJbmRleCA9IHRoaXMuZ2V0WkluZGV4KHRoaXMuaXNSYW5nZSk7XG4gICAgdGhpcy51cGRhdGVOb2RlcygpO1xuICB9XG4gIGNhbGN1bGF0ZUxheW91dCh2aXNpYmxlLCByZXZlcnNlZEF4aXMpIHtcbiAgICBpZiAoIXZpc2libGUpXG4gICAgICByZXR1cm47XG4gICAgY29uc3Qge1xuICAgICAgc2NhbGU6IHNjYWxlMixcbiAgICAgIGdyaWRMZW5ndGgsXG4gICAgICBzaWRlRmxhZyxcbiAgICAgIGRpcmVjdGlvbixcbiAgICAgIGxhYmVsOiB7IHBvc2l0aW9uID0gXCJ0b3BcIiB9LFxuICAgICAgY2xpcHBlZFJhbmdlLFxuICAgICAgc3Ryb2tlV2lkdGggPSAwXG4gICAgfSA9IHRoaXM7XG4gICAgdGhpcy5kYXRhID0gW107XG4gICAgaWYgKCFzY2FsZTIpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgYmFuZHdpZHRoID0gc2NhbGUyLmJhbmR3aWR0aCA/PyAwO1xuICAgIGNvbnN0IHN0ZXAgPSBzY2FsZTIuc3RlcCA/PyAwO1xuICAgIGNvbnN0IHBhZGRpbmcgPSAocmV2ZXJzZWRBeGlzID8gLTEgOiAxKSAqIChzY2FsZTIgaW5zdGFuY2VvZiBCYW5kU2NhbGUgPyAoc3RlcCAtIGJhbmR3aWR0aCkgLyAyIDogMCk7XG4gICAgY29uc3QgW3hTdGFydCwgeEVuZF0gPSBbMCwgc2lkZUZsYWcgKiBncmlkTGVuZ3RoXTtcbiAgICBsZXQgW3lTdGFydCwgeUVuZF0gPSB0aGlzLmdldFJhbmdlKCk7XG4gICAgY29uc3Qgb3JkaW5hbFRpbWVTY2FsZVBhZGRpbmcgPSB5RW5kID09PSB2b2lkIDAgJiYgT3JkaW5hbFRpbWVTY2FsZS5pcyhzY2FsZTIpID8gYmFuZHdpZHRoIC8gMiArIHBhZGRpbmcgOiAwO1xuICAgIGxldCBbY2xhbXBlZFlTdGFydCwgY2xhbXBlZFlFbmRdID0gW1xuICAgICAgTnVtYmVyKHNjYWxlMi5jb252ZXJ0KHlTdGFydCwgeyBjbGFtcE1vZGU6IFwiY2xhbXBlZFwiIH0pKSAtIHBhZGRpbmcgKyBvcmRpbmFsVGltZVNjYWxlUGFkZGluZyxcbiAgICAgIHNjYWxlMi5jb252ZXJ0KHlFbmQsIHsgY2xhbXBNb2RlOiBcImNsYW1wZWRcIiB9KSArIGJhbmR3aWR0aCArIHBhZGRpbmdcbiAgICBdO1xuICAgIGNsYW1wZWRZU3RhcnQgPSBjbGFtcEFycmF5KGNsYW1wZWRZU3RhcnQsIGNsaXBwZWRSYW5nZSk7XG4gICAgY2xhbXBlZFlFbmQgPSBjbGFtcEFycmF5KGNsYW1wZWRZRW5kLCBjbGlwcGVkUmFuZ2UpO1xuICAgIFt5U3RhcnQsIHlFbmRdID0gW051bWJlcihzY2FsZTIuY29udmVydCh5U3RhcnQpKSArIG9yZGluYWxUaW1lU2NhbGVQYWRkaW5nLCBzY2FsZTIuY29udmVydCh5RW5kKSArIGJhbmR3aWR0aF07XG4gICAgY29uc3QgdmFsaWRSYW5nZSA9ICh5U3RhcnQgPT09IGNsYW1wZWRZU3RhcnQgfHwgeUVuZCA9PT0gY2xhbXBlZFlFbmQgfHwgY2xhbXBlZFlTdGFydCAhPT0gY2xhbXBlZFlFbmQpICYmIE1hdGguYWJzKGNsYW1wZWRZRW5kIC0gY2xhbXBlZFlTdGFydCkgPiAwO1xuICAgIGlmICh2YWxpZFJhbmdlICYmIGNsYW1wZWRZU3RhcnQgPiBjbGFtcGVkWUVuZCkge1xuICAgICAgW2NsYW1wZWRZU3RhcnQsIGNsYW1wZWRZRW5kXSA9IFtjbGFtcGVkWUVuZCwgY2xhbXBlZFlTdGFydF07XG4gICAgICBbeVN0YXJ0LCB5RW5kXSA9IFt5RW5kLCB5U3RhcnRdO1xuICAgIH1cbiAgICBpZiAoeVN0YXJ0IC0gcGFkZGluZyA+PSBjbGFtcGVkWVN0YXJ0KVxuICAgICAgeVN0YXJ0IC09IHBhZGRpbmc7XG4gICAgaWYgKHlFbmQgKyBwYWRkaW5nIDw9IGNsYW1wZWRZRW5kKVxuICAgICAgeUVuZCArPSBwYWRkaW5nO1xuICAgIHRoaXMuaXNSYW5nZSA9IHZhbGlkUmFuZ2U7XG4gICAgdGhpcy5zdGFydExpbmUgPSBzdHJva2VXaWR0aCA+IDAgJiYgeVN0YXJ0ID49IGNsYW1wZWRZU3RhcnQgJiYgeVN0YXJ0IDw9IGNsYW1wZWRZU3RhcnQgKyBwYWRkaW5nO1xuICAgIHRoaXMuZW5kTGluZSA9IHN0cm9rZVdpZHRoID4gMCAmJiB5RW5kID49IGNsYW1wZWRZRW5kIC0gYmFuZHdpZHRoIC0gcGFkZGluZyAmJiB5RW5kIDw9IGNsYW1wZWRZRW5kO1xuICAgIGlmICghdmFsaWRSYW5nZSAmJiAhdGhpcy5zdGFydExpbmUgJiYgIXRoaXMuZW5kTGluZSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmRhdGEgPSBbY2xhbXBlZFlTdGFydCwgY2xhbXBlZFlFbmRdO1xuICAgIGlmICghdGhpcy5sYWJlbC5lbmFibGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgYyA9IFBPU0lUSU9OX1RPUF9DT09SRElOQVRFUyB9ID0gbGFiZWxEaXJlY3Rpb25IYW5kbGluZ1twb3NpdGlvbl0gPz8ge307XG4gICAgY29uc3QgeyB4OiBsYWJlbFgsIHk6IGxhYmVsWSB9ID0gYyh7XG4gICAgICBkaXJlY3Rpb24sXG4gICAgICB4U3RhcnQsXG4gICAgICB4RW5kLFxuICAgICAgeVN0YXJ0OiBjbGFtcGVkWVN0YXJ0LFxuICAgICAgeUVuZDogY2xhbXBlZFlFbmRcbiAgICB9KTtcbiAgICB0aGlzLmxhYmVsUG9pbnQgPSB7XG4gICAgICB4OiBsYWJlbFgsXG4gICAgICB5OiBsYWJlbFlcbiAgICB9O1xuICB9XG4gIHVwZGF0ZU5vZGVzKCkge1xuICAgIHRoaXMudXBkYXRlUmFuZ2VOb2RlKCk7XG4gICAgaWYgKHRoaXMubGFiZWwuZW5hYmxlZCkge1xuICAgICAgdGhpcy51cGRhdGVMYWJlbCgpO1xuICAgICAgdGhpcy5wb3NpdGlvbkxhYmVsKCk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVJhbmdlTm9kZSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBjcm9zc0xpbmVSYW5nZSxcbiAgICAgIHNpZGVGbGFnLFxuICAgICAgZ3JpZExlbmd0aCxcbiAgICAgIGRhdGEsXG4gICAgICBzdGFydExpbmUsXG4gICAgICBlbmRMaW5lLFxuICAgICAgaXNSYW5nZSxcbiAgICAgIGZpbGwsXG4gICAgICBmaWxsT3BhY2l0eSxcbiAgICAgIHN0cm9rZSxcbiAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgbGluZURhc2hcbiAgICB9ID0gdGhpcztcbiAgICBjcm9zc0xpbmVSYW5nZS54MSA9IDA7XG4gICAgY3Jvc3NMaW5lUmFuZ2UueDIgPSBzaWRlRmxhZyAqIGdyaWRMZW5ndGg7XG4gICAgY3Jvc3NMaW5lUmFuZ2UueTEgPSBkYXRhWzBdO1xuICAgIGNyb3NzTGluZVJhbmdlLnkyID0gZGF0YVsxXTtcbiAgICBjcm9zc0xpbmVSYW5nZS5zdGFydExpbmUgPSBzdGFydExpbmU7XG4gICAgY3Jvc3NMaW5lUmFuZ2UuZW5kTGluZSA9IGVuZExpbmU7XG4gICAgY3Jvc3NMaW5lUmFuZ2UuaXNSYW5nZSA9IGlzUmFuZ2U7XG4gICAgY3Jvc3NMaW5lUmFuZ2UuZmlsbCA9IGZpbGw7XG4gICAgY3Jvc3NMaW5lUmFuZ2UuZmlsbE9wYWNpdHkgPSBmaWxsT3BhY2l0eSA/PyAxO1xuICAgIGNyb3NzTGluZVJhbmdlLnN0cm9rZSA9IHN0cm9rZTtcbiAgICBjcm9zc0xpbmVSYW5nZS5zdHJva2VXaWR0aCA9IHN0cm9rZVdpZHRoID8/IDE7XG4gICAgY3Jvc3NMaW5lUmFuZ2Uuc3Ryb2tlT3BhY2l0eSA9IHRoaXMuc3Ryb2tlT3BhY2l0eSA/PyAxO1xuICAgIGNyb3NzTGluZVJhbmdlLmxpbmVEYXNoID0gbGluZURhc2g7XG4gIH1cbiAgdXBkYXRlTGFiZWwoKSB7XG4gICAgY29uc3QgeyBjcm9zc0xpbmVMYWJlbCwgbGFiZWwgfSA9IHRoaXM7XG4gICAgaWYgKCFsYWJlbC50ZXh0KVxuICAgICAgcmV0dXJuO1xuICAgIGNyb3NzTGluZUxhYmVsLmZvbnRTdHlsZSA9IGxhYmVsLmZvbnRTdHlsZTtcbiAgICBjcm9zc0xpbmVMYWJlbC5mb250V2VpZ2h0ID0gbGFiZWwuZm9udFdlaWdodDtcbiAgICBjcm9zc0xpbmVMYWJlbC5mb250U2l6ZSA9IGxhYmVsLmZvbnRTaXplO1xuICAgIGNyb3NzTGluZUxhYmVsLmZvbnRGYW1pbHkgPSBsYWJlbC5mb250RmFtaWx5O1xuICAgIGNyb3NzTGluZUxhYmVsLmZpbGwgPSBsYWJlbC5jb2xvcjtcbiAgICBjcm9zc0xpbmVMYWJlbC50ZXh0ID0gbGFiZWwudGV4dDtcbiAgfVxuICBwb3NpdGlvbkxhYmVsKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNyb3NzTGluZUxhYmVsLFxuICAgICAgbGFiZWxQb2ludDogeyB4ID0gdm9pZCAwLCB5ID0gdm9pZCAwIH0gPSB7fSxcbiAgICAgIGxhYmVsOiB7IHBhcmFsbGVsLCByb3RhdGlvbiwgcG9zaXRpb24gPSBcInRvcFwiLCBwYWRkaW5nID0gMCB9LFxuICAgICAgZGlyZWN0aW9uLFxuICAgICAgcGFyYWxsZWxGbGlwUm90YXRpb24sXG4gICAgICByZWd1bGFyRmxpcFJvdGF0aW9uXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKHggPT09IHZvaWQgMCB8fCB5ID09PSB2b2lkIDApXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBkZWZhdWx0Um90YXRpb24sIGNvbmZpZ3VyZWRSb3RhdGlvbiB9ID0gY2FsY3VsYXRlTGFiZWxSb3RhdGlvbih7XG4gICAgICByb3RhdGlvbixcbiAgICAgIHBhcmFsbGVsLFxuICAgICAgcmVndWxhckZsaXBSb3RhdGlvbixcbiAgICAgIHBhcmFsbGVsRmxpcFJvdGF0aW9uXG4gICAgfSk7XG4gICAgY3Jvc3NMaW5lTGFiZWwucm90YXRpb24gPSBkZWZhdWx0Um90YXRpb24gKyBjb25maWd1cmVkUm90YXRpb247XG4gICAgY3Jvc3NMaW5lTGFiZWwudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIjtcbiAgICBjcm9zc0xpbmVMYWJlbC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgIGNvbnN0IGJib3ggPSBjcm9zc0xpbmVMYWJlbC5nZXRCQm94KCk7XG4gICAgaWYgKCFiYm94KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHlEaXJlY3Rpb24gPSBkaXJlY3Rpb24gPT09IFwieVwiIC8qIFkgKi87XG4gICAgY29uc3QgeyB4VHJhbnNsYXRpb24sIHlUcmFuc2xhdGlvbiB9ID0gY2FsY3VsYXRlTGFiZWxUcmFuc2xhdGlvbih7XG4gICAgICB5RGlyZWN0aW9uLFxuICAgICAgcGFkZGluZyxcbiAgICAgIHBvc2l0aW9uLFxuICAgICAgYmJveFxuICAgIH0pO1xuICAgIGNyb3NzTGluZUxhYmVsLnRyYW5zbGF0aW9uWCA9IHggKyB4VHJhbnNsYXRpb247XG4gICAgY3Jvc3NMaW5lTGFiZWwudHJhbnNsYXRpb25ZID0geSArIHlUcmFuc2xhdGlvbjtcbiAgfVxuICBnZXRaSW5kZXgoaXNSYW5nZSA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIGlzUmFuZ2UgPyBfQ2FydGVzaWFuQ3Jvc3NMaW5lLlJBTkdFX0xBWUVSX1pJTkRFWCA6IF9DYXJ0ZXNpYW5Dcm9zc0xpbmUuTElORV9MQVlFUl9aSU5ERVg7XG4gIH1cbiAgZ2V0UmFuZ2UoKSB7XG4gICAgY29uc3QgeyB2YWx1ZSwgcmFuZ2U6IHJhbmdlMywgc2NhbGU6IHNjYWxlMiB9ID0gdGhpcztcbiAgICBjb25zdCBpc0NvbnRpbnVvdXMyID0gQ29udGludW91c1NjYWxlLmlzKHNjYWxlMikgfHwgT3JkaW5hbFRpbWVTY2FsZS5pcyhzY2FsZTIpO1xuICAgIGNvbnN0IHN0YXJ0MiA9IHJhbmdlMz8uWzBdID8/IHZhbHVlO1xuICAgIGxldCBlbmQyID0gcmFuZ2UzPy5bMV07XG4gICAgaWYgKCFpc0NvbnRpbnVvdXMyICYmIGVuZDIgPT09IHZvaWQgMCkge1xuICAgICAgZW5kMiA9IHN0YXJ0MjtcbiAgICB9XG4gICAgaWYgKGlzQ29udGludW91czIgJiYgc3RhcnQyID09PSBlbmQyKSB7XG4gICAgICBlbmQyID0gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gW3N0YXJ0MiwgZW5kMl07XG4gIH1cbiAgY29tcHV0ZUxhYmVsQkJveCgpIHtcbiAgICBjb25zdCB7IGxhYmVsIH0gPSB0aGlzO1xuICAgIGlmICghbGFiZWwuZW5hYmxlZClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ZW1wVGV4dCA9IG5ldyBUcmFuc2Zvcm1hYmxlVGV4dCgpO1xuICAgIHRlbXBUZXh0LmZvbnRGYW1pbHkgPSBsYWJlbC5mb250RmFtaWx5O1xuICAgIHRlbXBUZXh0LmZvbnRTaXplID0gbGFiZWwuZm9udFNpemU7XG4gICAgdGVtcFRleHQuZm9udFN0eWxlID0gbGFiZWwuZm9udFN0eWxlO1xuICAgIHRlbXBUZXh0LmZvbnRXZWlnaHQgPSBsYWJlbC5mb250V2VpZ2h0O1xuICAgIHRlbXBUZXh0LnRleHQgPSBsYWJlbC50ZXh0O1xuICAgIGNvbnN0IHtcbiAgICAgIGxhYmVsUG9pbnQ6IHsgeCA9IHZvaWQgMCwgeSA9IHZvaWQgMCB9ID0ge30sXG4gICAgICBsYWJlbDogeyBwYXJhbGxlbCwgcm90YXRpb24sIHBvc2l0aW9uID0gXCJ0b3BcIiwgcGFkZGluZyA9IDAgfSxcbiAgICAgIGRpcmVjdGlvbixcbiAgICAgIHBhcmFsbGVsRmxpcFJvdGF0aW9uLFxuICAgICAgcmVndWxhckZsaXBSb3RhdGlvblxuICAgIH0gPSB0aGlzO1xuICAgIGlmICh4ID09PSB2b2lkIDAgfHwgeSA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgY29uZmlndXJlZFJvdGF0aW9uIH0gPSBjYWxjdWxhdGVMYWJlbFJvdGF0aW9uKHtcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgcGFyYWxsZWwsXG4gICAgICByZWd1bGFyRmxpcFJvdGF0aW9uLFxuICAgICAgcGFyYWxsZWxGbGlwUm90YXRpb25cbiAgICB9KTtcbiAgICB0ZW1wVGV4dC5yb3RhdGlvbiA9IGNvbmZpZ3VyZWRSb3RhdGlvbjtcbiAgICB0ZW1wVGV4dC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xuICAgIHRlbXBUZXh0LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgY29uc3QgYmJveCA9IHRlbXBUZXh0LmdldEJCb3goKTtcbiAgICBpZiAoIWJib3gpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeURpcmVjdGlvbiA9IGRpcmVjdGlvbiA9PT0gXCJ5XCIgLyogWSAqLztcbiAgICBjb25zdCB7IHhUcmFuc2xhdGlvbiwgeVRyYW5zbGF0aW9uIH0gPSBjYWxjdWxhdGVMYWJlbFRyYW5zbGF0aW9uKHtcbiAgICAgIHlEaXJlY3Rpb24sXG4gICAgICBwYWRkaW5nLFxuICAgICAgcG9zaXRpb24sXG4gICAgICBiYm94XG4gICAgfSk7XG4gICAgdGVtcFRleHQueCA9IHggKyB4VHJhbnNsYXRpb247XG4gICAgdGVtcFRleHQueSA9IHkgKyB5VHJhbnNsYXRpb247XG4gICAgcmV0dXJuIHRlbXBUZXh0LmdldEJCb3goKTtcbiAgfVxuICBjYWxjdWxhdGVQYWRkaW5nKHBhZGRpbmcpIHtcbiAgICBjb25zdCB7XG4gICAgICBpc1JhbmdlLFxuICAgICAgc3RhcnRMaW5lLFxuICAgICAgZW5kTGluZSxcbiAgICAgIGRpcmVjdGlvbixcbiAgICAgIGxhYmVsOiB7IHBhZGRpbmc6IGxhYmVsUGFkZGluZyA9IDAsIHBvc2l0aW9uID0gXCJ0b3BcIiB9XG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFpc1JhbmdlICYmICFzdGFydExpbmUgJiYgIWVuZExpbmUpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgY3Jvc3NMaW5lTGFiZWxCQm94ID0gdGhpcy5jb21wdXRlTGFiZWxCQm94KCk7XG4gICAgaWYgKGNyb3NzTGluZUxhYmVsQkJveD8ueCA9PSBudWxsIHx8IGNyb3NzTGluZUxhYmVsQkJveD8ueSA9PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGNoYXJ0UGFkZGluZyA9IGNhbGN1bGF0ZUxhYmVsQ2hhcnRQYWRkaW5nKHtcbiAgICAgIHlEaXJlY3Rpb246IGRpcmVjdGlvbiA9PT0gXCJ5XCIgLyogWSAqLyxcbiAgICAgIHBhZGRpbmc6IGxhYmVsUGFkZGluZyxcbiAgICAgIHBvc2l0aW9uLFxuICAgICAgYmJveDogY3Jvc3NMaW5lTGFiZWxCQm94XG4gICAgfSk7XG4gICAgcGFkZGluZy5sZWZ0ID0gTWF0aC5tYXgocGFkZGluZy5sZWZ0ID8/IDAsIGNoYXJ0UGFkZGluZy5sZWZ0ID8/IDApO1xuICAgIHBhZGRpbmcucmlnaHQgPSBNYXRoLm1heChwYWRkaW5nLnJpZ2h0ID8/IDAsIGNoYXJ0UGFkZGluZy5yaWdodCA/PyAwKTtcbiAgICBwYWRkaW5nLnRvcCA9IE1hdGgubWF4KHBhZGRpbmcudG9wID8/IDAsIGNoYXJ0UGFkZGluZy50b3AgPz8gMCk7XG4gICAgcGFkZGluZy5ib3R0b20gPSBNYXRoLm1heChwYWRkaW5nLmJvdHRvbSA/PyAwLCBjaGFydFBhZGRpbmcuYm90dG9tID8/IDApO1xuICB9XG59O1xuX0NhcnRlc2lhbkNyb3NzTGluZS5MSU5FX0xBWUVSX1pJTkRFWCA9IDkgLyogU0VSSUVTX0NST1NTTElORV9MSU5FICovO1xuX0NhcnRlc2lhbkNyb3NzTGluZS5SQU5HRV9MQVlFUl9aSU5ERVggPSAzIC8qIFNFUklFU19DUk9TU0xJTkVfUkFOR0UgKi87XG5fQ2FydGVzaWFuQ3Jvc3NMaW5lLkxBQkVMX0xBWUVSX1pJTkRFWCA9IDE0IC8qIFNFUklFU19MQUJFTCAqLztcbl9DYXJ0ZXNpYW5Dcm9zc0xpbmUuY2xhc3NOYW1lID0gXCJDcm9zc0xpbmVcIjtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIF9DYXJ0ZXNpYW5Dcm9zc0xpbmUucHJvdG90eXBlLCBcImVuYWJsZWRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShVTklPTihbXCJyYW5nZVwiLCBcImxpbmVcIl0sIFwiYSBjcm9zc0xpbmUgdHlwZVwiKSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgX0NhcnRlc2lhbkNyb3NzTGluZS5wcm90b3R5cGUsIFwidHlwZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEFORChNQVRDSElOR19DUk9TU0xJTkVfVFlQRShcInJhbmdlXCIpLCBBUlJBWS5yZXN0cmljdCh7IGxlbmd0aDogMiB9KSksIHtcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9KVxuXSwgX0NhcnRlc2lhbkNyb3NzTGluZS5wcm90b3R5cGUsIFwicmFuZ2VcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShNQVRDSElOR19DUk9TU0xJTkVfVFlQRShcInZhbHVlXCIpLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBfQ2FydGVzaWFuQ3Jvc3NMaW5lLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgX0NhcnRlc2lhbkNyb3NzTGluZS5wcm90b3R5cGUsIFwiZmlsbFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBfQ2FydGVzaWFuQ3Jvc3NMaW5lLnByb3RvdHlwZSwgXCJmaWxsT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgX0NhcnRlc2lhbkNyb3NzTGluZS5wcm90b3R5cGUsIFwic3Ryb2tlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTlVNQkVSLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBfQ2FydGVzaWFuQ3Jvc3NMaW5lLnByb3RvdHlwZSwgXCJzdHJva2VXaWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBfQ2FydGVzaWFuQ3Jvc3NMaW5lLnByb3RvdHlwZSwgXCJzdHJva2VPcGFjaXR5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTElORV9EQVNILCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBfQ2FydGVzaWFuQ3Jvc3NMaW5lLnByb3RvdHlwZSwgXCJsaW5lRGFzaFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIF9DYXJ0ZXNpYW5Dcm9zc0xpbmUucHJvdG90eXBlLCBcImxhYmVsXCIsIDIpO1xudmFyIENhcnRlc2lhbkNyb3NzTGluZSA9IF9DYXJ0ZXNpYW5Dcm9zc0xpbmU7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2F4aXMvYXhpc0dyaWRMaW5lLnRzXG52YXIgR1JJRF9TVFlMRV9LRVlTID0gW1wic3Ryb2tlXCIsIFwibGluZURhc2hcIl07XG52YXIgR1JJRF9TVFlMRSA9IEFSUkFZX09GKFxuICAodmFsdWUpID0+IGlzT2JqZWN0KHZhbHVlKSAmJiBPYmplY3Qua2V5cyh2YWx1ZSkuZXZlcnkoKGtleSkgPT4gR1JJRF9TVFlMRV9LRVlTLmluY2x1ZGVzKGtleSkpLFxuICBcIm9iamVjdHMgd2l0aCBncmlkbGluZSBzdHlsZSBwcm9wZXJ0aWVzIHN1Y2ggYXMgJ3N0cm9rZScgb3IgJ2xpbmVEYXNoJ1wiXG4pO1xudmFyIEF4aXNHcmlkTGluZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLndpZHRoID0gMTtcbiAgICB0aGlzLnN0eWxlID0gW1xuICAgICAge1xuICAgICAgICBzdHJva2U6IHZvaWQgMCxcbiAgICAgICAgbGluZURhc2g6IFtdXG4gICAgICB9XG4gICAgXTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBBeGlzR3JpZExpbmUucHJvdG90eXBlLCBcImVuYWJsZWRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBBeGlzR3JpZExpbmUucHJvdG90eXBlLCBcIndpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoR1JJRF9TVFlMRSlcbl0sIEF4aXNHcmlkTGluZS5wcm90b3R5cGUsIFwic3R5bGVcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvZGVmYXVsdC50c1xuZnVuY3Rpb24gRGVmYXVsdChkZWZhdWx0VmFsdWUsIHJlcGxhY2VzID0gW3ZvaWQgMF0pIHtcbiAgcmV0dXJuIGFkZFRyYW5zZm9ybVRvSW5zdGFuY2VQcm9wZXJ0eSgoXywgX18sIHYpID0+IHtcbiAgICBpZiAocmVwbGFjZXMuaW5jbHVkZXModikpIHtcbiAgICAgIHJldHVybiBpc0Z1bmN0aW9uKGRlZmF1bHRWYWx1ZSkgPyBkZWZhdWx0VmFsdWUodikgOiBkZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB2O1xuICB9KTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvYXhpcy9heGlzSW50ZXJ2YWwudHNcbnZhciBUSUNLX0lOVEVSVkFMID0gcHJlZGljYXRlV2l0aE1lc3NhZ2UoXG4gICh2YWx1ZSkgPT4gaXNGaW5pdGVOdW1iZXIodmFsdWUpICYmIHZhbHVlID4gMCB8fCB2YWx1ZSBpbnN0YW5jZW9mIFRpbWVJbnRlcnZhbCxcbiAgYGEgbm9uLXplcm8gcG9zaXRpdmUgTnVtYmVyIHZhbHVlIG9yLCBmb3IgYSB0aW1lIGF4aXMsIGEgVGltZSBJbnRlcnZhbCBzdWNoIGFzICdhZ0NoYXJ0cy50aW1lLm1vbnRoJ2Bcbik7XG52YXIgQXhpc0ludGVydmFsID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5taW5TcGFjaW5nID0gTmFOO1xuICAgIHRoaXMubWF4U3BhY2luZyA9IE5hTjtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFRJQ0tfSU5URVJWQUwsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEF4aXNJbnRlcnZhbC5wcm90b3R5cGUsIFwic3RlcFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEFSUkFZLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBBeGlzSW50ZXJ2YWwucHJvdG90eXBlLCBcInZhbHVlc1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE1JTl9TUEFDSU5HKSxcbiAgRGVmYXVsdChOYU4pXG5dLCBBeGlzSW50ZXJ2YWwucHJvdG90eXBlLCBcIm1pblNwYWNpbmdcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShNQVhfU1BBQ0lORyksXG4gIERlZmF1bHQoTmFOKVxuXSwgQXhpc0ludGVydmFsLnByb3RvdHlwZSwgXCJtYXhTcGFjaW5nXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9heGlzL2F4aXNMYWJlbC50c1xudmFyIEF4aXNMYWJlbCA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5mb250U2l6ZSA9IDEyO1xuICAgIHRoaXMuZm9udEZhbWlseSA9IFwiVmVyZGFuYSwgc2Fucy1zZXJpZlwiO1xuICAgIHRoaXMucGFkZGluZyA9IDU7XG4gICAgdGhpcy5taW5TcGFjaW5nID0gTmFOO1xuICAgIHRoaXMuY29sb3IgPSBcIiM1NzU3NTdcIjtcbiAgICB0aGlzLmF2b2lkQ29sbGlzaW9ucyA9IHRydWU7XG4gICAgdGhpcy5taXJyb3JlZCA9IGZhbHNlO1xuICAgIHRoaXMucGFyYWxsZWwgPSBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHNpZGUgb2YgdGhlIGF4aXMgbGluZSB0byBwb3NpdGlvbiB0aGUgbGFiZWxzIG9uLlxuICAgKiAtMSA9IGxlZnQgKGRlZmF1bHQpXG4gICAqIDEgPSByaWdodFxuICAgKi9cbiAgZ2V0U2lkZUZsYWcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWlycm9yZWQgPyAxIDogLTE7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgQXhpc0xhYmVsLnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoRk9OVF9TVFlMRSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQXhpc0xhYmVsLnByb3RvdHlwZSwgXCJmb250U3R5bGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGT05UX1dFSUdIVCwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQXhpc0xhYmVsLnByb3RvdHlwZSwgXCJmb250V2VpZ2h0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTlVNQkVSLnJlc3RyaWN0KHsgbWluOiAxIH0pKVxuXSwgQXhpc0xhYmVsLnByb3RvdHlwZSwgXCJmb250U2l6ZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORylcbl0sIEF4aXNMYWJlbC5wcm90b3R5cGUsIFwiZm9udEZhbWlseVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIEF4aXNMYWJlbC5wcm90b3R5cGUsIFwicGFkZGluZ1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE5VTUJFUl9PUl9OQU4pLFxuICBEZWZhdWx0KE5hTilcbl0sIEF4aXNMYWJlbC5wcm90b3R5cGUsIFwibWluU3BhY2luZ1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQXhpc0xhYmVsLnByb3RvdHlwZSwgXCJjb2xvclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKERFR1JFRSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQXhpc0xhYmVsLnByb3RvdHlwZSwgXCJyb3RhdGlvblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBBeGlzTGFiZWwucHJvdG90eXBlLCBcImF2b2lkQ29sbGlzaW9uc1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBBeGlzTGFiZWwucHJvdG90eXBlLCBcIm1pcnJvcmVkXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIEF4aXNMYWJlbC5wcm90b3R5cGUsIFwicGFyYWxsZWxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGVU5DVElPTiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQXhpc0xhYmVsLnByb3RvdHlwZSwgXCJmb3JtYXR0ZXJcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEF4aXNMYWJlbC5wcm90b3R5cGUsIFwiZm9ybWF0XCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9heGlzL2F4aXNMaW5lLnRzXG52YXIgQXhpc0xpbmUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy53aWR0aCA9IDE7XG4gICAgdGhpcy5zdHJva2UgPSB2b2lkIDA7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgQXhpc0xpbmUucHJvdG90eXBlLCBcImVuYWJsZWRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBBeGlzTGluZS5wcm90b3R5cGUsIFwid2lkdGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEF4aXNMaW5lLnByb3RvdHlwZSwgXCJzdHJva2VcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2F4aXMvYXhpc1RpY2sudHNcbnZhciBBeGlzVGljayA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy53aWR0aCA9IDE7XG4gICAgdGhpcy5zaXplID0gNjtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBBeGlzVGljay5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIEF4aXNUaWNrLnByb3RvdHlwZSwgXCJ3aWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIEF4aXNUaWNrLnByb3RvdHlwZSwgXCJzaXplXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBBeGlzVGljay5wcm90b3R5cGUsIFwic3Ryb2tlXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9heGlzL2F4aXNUaXRsZS50c1xudmFyIEF4aXNUaXRsZSA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuY2FwdGlvbiA9IG5ldyBDYXB0aW9uKCk7XG4gICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XG4gICAgdGhpcy5zcGFjaW5nID0gQ2FwdGlvbi5TTUFMTF9QQURESU5HO1xuICAgIHRoaXMuZm9udFNpemUgPSAxMDtcbiAgICB0aGlzLmZvbnRGYW1pbHkgPSBcInNhbnMtc2VyaWZcIjtcbiAgICB0aGlzLndyYXBwaW5nID0gXCJhbHdheXNcIjtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBBeGlzVGl0bGUucHJvdG90eXBlLCBcImVuYWJsZWRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEF4aXNUaXRsZS5wcm90b3R5cGUsIFwidGV4dFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQXhpc1RpdGxlLnByb3RvdHlwZSwgXCJzcGFjaW5nXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoRk9OVF9TVFlMRSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQXhpc1RpdGxlLnByb3RvdHlwZSwgXCJmb250U3R5bGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGT05UX1dFSUdIVCwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQXhpc1RpdGxlLnByb3RvdHlwZSwgXCJmb250V2VpZ2h0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgQXhpc1RpdGxlLnByb3RvdHlwZSwgXCJmb250U2l6ZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORylcbl0sIEF4aXNUaXRsZS5wcm90b3R5cGUsIFwiZm9udEZhbWlseVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQXhpc1RpdGxlLnByb3RvdHlwZSwgXCJjb2xvclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFRFWFRfV1JBUClcbl0sIEF4aXNUaXRsZS5wcm90b3R5cGUsIFwid3JhcHBpbmdcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGVU5DVElPTiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQXhpc1RpdGxlLnByb3RvdHlwZSwgXCJmb3JtYXR0ZXJcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2F4aXMvYXhpc1V0aWwudHNcbmZ1bmN0aW9uIHByZXBhcmVBeGlzQW5pbWF0aW9uQ29udGV4dChheGlzKSB7XG4gIGNvbnN0IFtyZXF1ZXN0ZWRSYW5nZU1pbiwgcmVxdWVzdGVkUmFuZ2VNYXhdID0gZmluZE1pbk1heChheGlzLnJhbmdlKTtcbiAgY29uc3QgbWluID0gTWF0aC5mbG9vcihyZXF1ZXN0ZWRSYW5nZU1pbik7XG4gIGNvbnN0IG1heCA9IE1hdGguY2VpbChyZXF1ZXN0ZWRSYW5nZU1heCk7XG4gIHJldHVybiB7IG1pbiwgbWF4LCB2aXNpYmxlOiBtaW4gIT09IG1heCB9O1xufVxudmFyIGZ1bGxDaXJjbGUgPSBNYXRoLlBJICogMjtcbnZhciBoYWxmQ2lyY2xlID0gZnVsbENpcmNsZSAvIDI7XG5mdW5jdGlvbiBub3JtYWxpc2VFbmRSb3RhdGlvbihzdGFydDIsIGVuZDIpIHtcbiAgY29uc3QgZGlyZWN0RGlzdGFuY2UgPSBNYXRoLmFicyhlbmQyIC0gc3RhcnQyKTtcbiAgaWYgKGRpcmVjdERpc3RhbmNlIDwgaGFsZkNpcmNsZSkge1xuICAgIHJldHVybiBlbmQyO1xuICB9IGVsc2UgaWYgKHN0YXJ0MiA+IGVuZDIpIHtcbiAgICByZXR1cm4gZW5kMiArIGZ1bGxDaXJjbGU7XG4gIH1cbiAgcmV0dXJuIGVuZDIgLSBmdWxsQ2lyY2xlO1xufVxuZnVuY3Rpb24gcHJlcGFyZUF4aXNBbmltYXRpb25GdW5jdGlvbnMoY3R4KSB7XG4gIGNvbnN0IG91dE9mQm91bmRzID0gKHksIHJhbmdlMykgPT4ge1xuICAgIGNvbnN0IFttaW4gPSBjdHgubWluLCBtYXggPSBjdHgubWF4XSA9IGZpbmRNaW5NYXgocmFuZ2UzID8/IFtdKTtcbiAgICByZXR1cm4geSA8IG1pbiB8fCB5ID4gbWF4O1xuICB9O1xuICBjb25zdCB0aWNrID0ge1xuICAgIGZyb21Gbihub2RlLCBkYXR1bSwgc3RhdHVzKSB7XG4gICAgICBsZXQgeSA9IG5vZGUueTEgKyBub2RlLnRyYW5zbGF0aW9uWTtcbiAgICAgIGxldCBvcGFjaXR5ID0gbm9kZS5vcGFjaXR5O1xuICAgICAgaWYgKHN0YXR1cyA9PT0gXCJhZGRlZFwiIHx8IG91dE9mQm91bmRzKG5vZGUuZGF0dW0udHJhbnNsYXRpb25ZLCBub2RlLmRhdHVtLnJhbmdlKSkge1xuICAgICAgICB5ID0gZGF0dW0udHJhbnNsYXRpb25ZO1xuICAgICAgICBvcGFjaXR5ID0gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHk6IDAsIHRyYW5zbGF0aW9uWTogeSwgb3BhY2l0eSwgcGhhc2U6IE5PREVfVVBEQVRFX1NUQVRFX1RPX1BIQVNFX01BUFBJTkdbc3RhdHVzXSB9O1xuICAgIH0sXG4gICAgdG9Gbihfbm9kZSwgZGF0dW0sIHN0YXR1cykge1xuICAgICAgY29uc3QgeSA9IGRhdHVtLnRyYW5zbGF0aW9uWTtcbiAgICAgIGxldCBvcGFjaXR5ID0gMTtcbiAgICAgIGlmIChzdGF0dXMgPT09IFwicmVtb3ZlZFwiKSB7XG4gICAgICAgIG9wYWNpdHkgPSAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeTogMCxcbiAgICAgICAgdHJhbnNsYXRpb25ZOiB5LFxuICAgICAgICBvcGFjaXR5LFxuICAgICAgICBmaW5pc2g6IHtcbiAgICAgICAgICAvLyBTZXQgZXhwbGljaXQgeSBhZnRlciBhbmltYXRpb24gc28gaXQncyBwaXhlbCBhbGlnbmVkXG4gICAgICAgICAgeSxcbiAgICAgICAgICB0cmFuc2xhdGlvblk6IDBcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIGFwcGx5Rm4obm9kZSwgcHJvcHMpIHtcbiAgICAgIG5vZGUuc2V0UHJvcGVydGllcyhwcm9wcyk7XG4gICAgICBub2RlLnZpc2libGUgPSAhb3V0T2ZCb3VuZHMobm9kZS55KTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGxhYmVsID0ge1xuICAgIGZyb21Gbihub2RlLCBuZXdEYXR1bSwgc3RhdHVzKSB7XG4gICAgICBjb25zdCBkYXR1bSA9IG5vZGUucHJldmlvdXNEYXR1bSA/PyBuZXdEYXR1bTtcbiAgICAgIGNvbnN0IHggPSBkYXR1bS54O1xuICAgICAgY29uc3QgeSA9IGRhdHVtLnk7XG4gICAgICBjb25zdCByb3RhdGlvbkNlbnRlclggPSBkYXR1bS5yb3RhdGlvbkNlbnRlclg7XG4gICAgICBsZXQgdHJhbnNsYXRpb25ZID0gTWF0aC5yb3VuZChub2RlLnRyYW5zbGF0aW9uWSk7XG4gICAgICBsZXQgcm90YXRpb24gPSBkYXR1bS5yb3RhdGlvbjtcbiAgICAgIGxldCBvcGFjaXR5ID0gbm9kZS5vcGFjaXR5O1xuICAgICAgaWYgKHN0YXR1cyA9PT0gXCJyZW1vdmVkXCIgfHwgb3V0T2ZCb3VuZHMoZGF0dW0ueSwgZGF0dW0ucmFuZ2UpKSB7XG4gICAgICAgIHJvdGF0aW9uID0gbmV3RGF0dW0ucm90YXRpb247XG4gICAgICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gXCJhZGRlZFwiIHx8IG91dE9mQm91bmRzKG5vZGUuZGF0dW0ueSwgbm9kZS5kYXR1bS5yYW5nZSkpIHtcbiAgICAgICAgdHJhbnNsYXRpb25ZID0gTWF0aC5yb3VuZChkYXR1bS50cmFuc2xhdGlvblkpO1xuICAgICAgICBvcGFjaXR5ID0gMDtcbiAgICAgICAgcm90YXRpb24gPSBuZXdEYXR1bS5yb3RhdGlvbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHJvdGF0aW9uQ2VudGVyWCxcbiAgICAgICAgdHJhbnNsYXRpb25ZLFxuICAgICAgICByb3RhdGlvbixcbiAgICAgICAgb3BhY2l0eSxcbiAgICAgICAgcGhhc2U6IE5PREVfVVBEQVRFX1NUQVRFX1RPX1BIQVNFX01BUFBJTkdbc3RhdHVzXVxuICAgICAgfTtcbiAgICB9LFxuICAgIHRvRm4obm9kZSwgZGF0dW0sIHN0YXR1cykge1xuICAgICAgY29uc3QgeCA9IGRhdHVtLng7XG4gICAgICBjb25zdCB5ID0gZGF0dW0ueTtcbiAgICAgIGNvbnN0IHJvdGF0aW9uQ2VudGVyWCA9IGRhdHVtLnJvdGF0aW9uQ2VudGVyWDtcbiAgICAgIGNvbnN0IHRyYW5zbGF0aW9uWSA9IE1hdGgucm91bmQoZGF0dW0udHJhbnNsYXRpb25ZKTtcbiAgICAgIGxldCByb3RhdGlvbiA9IDA7XG4gICAgICBsZXQgb3BhY2l0eSA9IDE7XG4gICAgICBpZiAoc3RhdHVzID09PSBcImFkZGVkXCIpIHtcbiAgICAgICAgb3BhY2l0eSA9IDE7XG4gICAgICAgIHJvdGF0aW9uID0gZGF0dW0ucm90YXRpb247XG4gICAgICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gXCJyZW1vdmVkXCIpIHtcbiAgICAgICAgb3BhY2l0eSA9IDA7XG4gICAgICAgIHJvdGF0aW9uID0gZGF0dW0ucm90YXRpb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb3RhdGlvbiA9IG5vcm1hbGlzZUVuZFJvdGF0aW9uKG5vZGUucHJldmlvdXNEYXR1bT8ucm90YXRpb24gPz8gZGF0dW0ucm90YXRpb24sIGRhdHVtLnJvdGF0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHgsIHksIHJvdGF0aW9uQ2VudGVyWCwgdHJhbnNsYXRpb25ZLCByb3RhdGlvbiwgb3BhY2l0eSwgZmluaXNoOiB7IHJvdGF0aW9uOiBkYXR1bS5yb3RhdGlvbiB9IH07XG4gICAgfVxuICB9O1xuICBjb25zdCBsaW5lID0ge1xuICAgIGZyb21Gbihub2RlLCBkYXR1bSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubm9kZS5wcmV2aW91c0RhdHVtID8/IGRhdHVtLFxuICAgICAgICBwaGFzZTogTk9ERV9VUERBVEVfU1RBVEVfVE9fUEhBU0VfTUFQUElOR1tcInVwZGF0ZWRcIl1cbiAgICAgIH07XG4gICAgfSxcbiAgICB0b0ZuKF9ub2RlLCBkYXR1bSkge1xuICAgICAgcmV0dXJuIHsgLi4uZGF0dW0gfTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGdyb3VwID0ge1xuICAgIGZyb21Gbihub2RlLCBfZGF0dW0pIHtcbiAgICAgIGNvbnN0IHsgcm90YXRpb24sIHRyYW5zbGF0aW9uWCwgdHJhbnNsYXRpb25ZIH0gPSBub2RlO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcm90YXRpb24sXG4gICAgICAgIHRyYW5zbGF0aW9uWCxcbiAgICAgICAgdHJhbnNsYXRpb25ZLFxuICAgICAgICBwaGFzZTogTk9ERV9VUERBVEVfU1RBVEVfVE9fUEhBU0VfTUFQUElOR1tcInVwZGF0ZWRcIl1cbiAgICAgIH07XG4gICAgfSxcbiAgICB0b0ZuKF9ub2RlLCBkYXR1bSkge1xuICAgICAgY29uc3QgeyByb3RhdGlvbiwgdHJhbnNsYXRpb25YLCB0cmFuc2xhdGlvblkgfSA9IGRhdHVtO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcm90YXRpb24sXG4gICAgICAgIHRyYW5zbGF0aW9uWCxcbiAgICAgICAgdHJhbnNsYXRpb25ZXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHsgdGljaywgbGluZSwgbGFiZWwsIGdyb3VwIH07XG59XG5mdW5jdGlvbiByZXNldEF4aXNHcm91cEZuKCkge1xuICByZXR1cm4gKF9ub2RlLCBkYXR1bSkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICByb3RhdGlvbjogZGF0dW0ucm90YXRpb24sXG4gICAgICByb3RhdGlvbkNlbnRlclg6IGRhdHVtLnJvdGF0aW9uQ2VudGVyWCxcbiAgICAgIHJvdGF0aW9uQ2VudGVyWTogZGF0dW0ucm90YXRpb25DZW50ZXJZLFxuICAgICAgdHJhbnNsYXRpb25YOiBkYXR1bS50cmFuc2xhdGlvblgsXG4gICAgICB0cmFuc2xhdGlvblk6IGRhdHVtLnRyYW5zbGF0aW9uWVxuICAgIH07XG4gIH07XG59XG5mdW5jdGlvbiByZXNldEF4aXNTZWxlY3Rpb25GbihjdHgpIHtcbiAgY29uc3QgeyB2aXNpYmxlOiByYW5nZVZpc2libGUsIG1pbiwgbWF4IH0gPSBjdHg7XG4gIHJldHVybiAoX25vZGUsIGRhdHVtKSA9PiB7XG4gICAgY29uc3QgeSA9IGRhdHVtLnRyYW5zbGF0aW9uWTtcbiAgICBjb25zdCB2aXNpYmxlID0gcmFuZ2VWaXNpYmxlICYmIHkgPj0gbWluICYmIHkgPD0gbWF4O1xuICAgIHJldHVybiB7XG4gICAgICB5LFxuICAgICAgdHJhbnNsYXRpb25ZOiAwLFxuICAgICAgb3BhY2l0eTogMSxcbiAgICAgIHZpc2libGVcbiAgICB9O1xuICB9O1xufVxuZnVuY3Rpb24gcmVzZXRBeGlzTGFiZWxTZWxlY3Rpb25GbigpIHtcbiAgcmV0dXJuIChfbm9kZSwgZGF0dW0pID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogZGF0dW0ueCxcbiAgICAgIHk6IGRhdHVtLnksXG4gICAgICB0cmFuc2xhdGlvblk6IGRhdHVtLnRyYW5zbGF0aW9uWSxcbiAgICAgIHJvdGF0aW9uOiBkYXR1bS5yb3RhdGlvbixcbiAgICAgIHJvdGF0aW9uQ2VudGVyWDogZGF0dW0ucm90YXRpb25DZW50ZXJYXG4gICAgfTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlc2V0QXhpc0xpbmVTZWxlY3Rpb25GbigpIHtcbiAgcmV0dXJuIChfbm9kZSwgZGF0dW0pID0+IHtcbiAgICByZXR1cm4geyAuLi5kYXR1bSB9O1xuICB9O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9heGlzL2F4aXMudHNcbnZhciBUcmFuc2xhdGFibGVMaW5lID0gY2xhc3MgZXh0ZW5kcyBUcmFuc2xhdGFibGUoTGluZSkge1xufTtcbnZhciBfQXhpcyA9IGNsYXNzIF9BeGlzIHtcbiAgY29uc3RydWN0b3IobW9kdWxlQ3R4LCBzY2FsZTIpIHtcbiAgICB0aGlzLm1vZHVsZUN0eCA9IG1vZHVsZUN0eDtcbiAgICB0aGlzLnNjYWxlID0gc2NhbGUyO1xuICAgIHRoaXMuaWQgPSBjcmVhdGVJZCh0aGlzKTtcbiAgICB0aGlzLm5pY2UgPSB0cnVlO1xuICAgIHRoaXMucmV2ZXJzZSA9IGZhbHNlO1xuICAgIHRoaXMua2V5cyA9IFtdO1xuICAgIHRoaXMuaW50ZXJ2YWwgPSBuZXcgQXhpc0ludGVydmFsKCk7XG4gICAgdGhpcy5kYXRhRG9tYWluID0geyBkb21haW46IFtdLCBjbGlwcGVkOiBmYWxzZSB9O1xuICAgIHRoaXMubGF5b3V0Q29uc3RyYWludHMgPSB7XG4gICAgICBzdGFja2VkOiB0cnVlLFxuICAgICAgYWxpZ246IFwic3RhcnRcIixcbiAgICAgIHdpZHRoOiAxMDAsXG4gICAgICB1bml0OiBcInBlcmNlbnRcIlxuICAgIH07XG4gICAgdGhpcy5ib3VuZFNlcmllcyA9IFtdO1xuICAgIHRoaXMuaW5jbHVkZUludmlzaWJsZURvbWFpbnMgPSBmYWxzZTtcbiAgICB0aGlzLmludGVyYWN0aW9uRW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5heGlzR3JvdXAgPSBuZXcgVHJhbnNmb3JtYWJsZUdyb3VwKHsgbmFtZTogYCR7dGhpcy5pZH0tYXhpc2AsIHpJbmRleDogMiAvKiBBWElTICovIH0pO1xuICAgIHRoaXMubGluZU5vZGUgPSB0aGlzLmF4aXNHcm91cC5hcHBlbmRDaGlsZChuZXcgVHJhbnNsYXRhYmxlTGluZSh7IG5hbWU6IGAke3RoaXMuaWR9LUF4aXMtbGluZWAgfSkpO1xuICAgIHRoaXMudGlja0xpbmVHcm91cCA9IHRoaXMuYXhpc0dyb3VwLmFwcGVuZENoaWxkKFxuICAgICAgbmV3IEdyb3VwKHsgbmFtZTogYCR7dGhpcy5pZH0tQXhpcy10aWNrLWxpbmVzYCwgekluZGV4OiAyIC8qIEFYSVMgKi8gfSlcbiAgICApO1xuICAgIHRoaXMudGlja0xhYmVsR3JvdXAgPSB0aGlzLmF4aXNHcm91cC5hcHBlbmRDaGlsZChcbiAgICAgIG5ldyBHcm91cCh7IG5hbWU6IGAke3RoaXMuaWR9LUF4aXMtdGljay1sYWJlbHNgLCB6SW5kZXg6IDIgLyogQVhJUyAqLyB9KVxuICAgICk7XG4gICAgdGhpcy5jcm9zc0xpbmVHcm91cCA9IG5ldyBUcmFuc2Zvcm1hYmxlR3JvdXAoeyBuYW1lOiBgJHt0aGlzLmlkfS1Dcm9zc0xpbmVzYCB9KTtcbiAgICB0aGlzLmxhYmVsR3JvdXAgPSBuZXcgR3JvdXAoeyBuYW1lOiBgJHt0aGlzLmlkfS1MYWJlbHNgLCB6SW5kZXg6IDEwIC8qIFNFUklFU19BTk5PVEFUSU9OICovIH0pO1xuICAgIHRoaXMuZ3JpZEdyb3VwID0gbmV3IFRyYW5zZm9ybWFibGVHcm91cCh7IG5hbWU6IGAke3RoaXMuaWR9LUF4aXMtZ3JpZGAgfSk7XG4gICAgdGhpcy5ncmlkTGluZUdyb3VwID0gdGhpcy5ncmlkR3JvdXAuYXBwZW5kQ2hpbGQoXG4gICAgICBuZXcgR3JvdXAoe1xuICAgICAgICBuYW1lOiBgJHt0aGlzLmlkfS1ncmlkTGluZXNgLFxuICAgICAgICB6SW5kZXg6IDEgLyogQVhJU19HUklEICovXG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy50aWNrTGluZUdyb3VwU2VsZWN0aW9uID0gU2VsZWN0aW9uLnNlbGVjdCh0aGlzLnRpY2tMaW5lR3JvdXAsIFRyYW5zbGF0YWJsZUxpbmUsIGZhbHNlKTtcbiAgICB0aGlzLnRpY2tMYWJlbEdyb3VwU2VsZWN0aW9uID0gU2VsZWN0aW9uLnNlbGVjdChcbiAgICAgIHRoaXMudGlja0xhYmVsR3JvdXAsXG4gICAgICBUcmFuc2Zvcm1hYmxlVGV4dCxcbiAgICAgIGZhbHNlXG4gICAgKTtcbiAgICB0aGlzLmdyaWRMaW5lR3JvdXBTZWxlY3Rpb24gPSBTZWxlY3Rpb24uc2VsZWN0KHRoaXMuZ3JpZExpbmVHcm91cCwgVHJhbnNsYXRhYmxlTGluZSwgZmFsc2UpO1xuICAgIHRoaXMuX2Nyb3NzTGluZXMgPSBbXTtcbiAgICB0aGlzLmxpbmUgPSBuZXcgQXhpc0xpbmUoKTtcbiAgICB0aGlzLnRpY2sgPSBuZXcgQXhpc1RpY2soKTtcbiAgICB0aGlzLmdyaWRMaW5lID0gbmV3IEF4aXNHcmlkTGluZSgpO1xuICAgIHRoaXMubGFiZWwgPSB0aGlzLmNyZWF0ZUxhYmVsKCk7XG4gICAgdGhpcy5kZWZhdWx0VGlja01pblNwYWNpbmcgPSBfQXhpcy5kZWZhdWx0VGlja01pblNwYWNpbmc7XG4gICAgdGhpcy50cmFuc2xhdGlvbiA9IHsgeDogMCwgeTogMCB9O1xuICAgIHRoaXMucm90YXRpb24gPSAwO1xuICAgIC8vIGF4aXMgcm90YXRpb24gYW5nbGUgaW4gZGVncmVlc1xuICAgIHRoaXMubGF5b3V0ID0ge1xuICAgICAgbGFiZWw6IHtcbiAgICAgICAgZnJhY3Rpb25EaWdpdHM6IDAsXG4gICAgICAgIHBhZGRpbmc6IHRoaXMubGFiZWwucGFkZGluZyxcbiAgICAgICAgZm9ybWF0OiB0aGlzLmxhYmVsLmZvcm1hdFxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5kZXN0cm95Rm5zID0gW107XG4gICAgdGhpcy5yYW5nZSA9IFswLCAxXTtcbiAgICB0aGlzLnZpc2libGVSYW5nZSA9IFswLCAxXTtcbiAgICB0aGlzLnRpdGxlID0gbmV3IEF4aXNUaXRsZSgpO1xuICAgIHRoaXMuZ3JpZExlbmd0aCA9IDA7XG4gICAgLyoqXG4gICAgICogVGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGdyaWQgdGlja3MgYW5kIHRoZSBheGlzIHRpY2tzLlxuICAgICAqL1xuICAgIHRoaXMuZ3JpZFBhZGRpbmcgPSAwO1xuICAgIC8qKlxuICAgICAqIElzIHVzZWQgdG8gYXZvaWQgY29sbGlzaW9ucyBiZXR3ZWVuIGF4aXMgbGFiZWxzIGFuZCBzZXJpZXMuXG4gICAgICovXG4gICAgdGhpcy5zZXJpZXNBcmVhUGFkZGluZyA9IDA7XG4gICAgdGhpcy50aWNrR2VuZXJhdGlvblJlc3VsdCA9IHZvaWQgMDtcbiAgICB0aGlzLm1vZHVsZU1hcCA9IG5ldyBNb2R1bGVNYXAoKTtcbiAgICB0aGlzLnJhbmdlID0gdGhpcy5zY2FsZS5yYW5nZS5zbGljZSgpO1xuICAgIHRoaXMuY3Jvc3NMaW5lcy5mb3JFYWNoKChjcm9zc0xpbmUpID0+IHRoaXMuaW5pdENyb3NzTGluZShjcm9zc0xpbmUpKTtcbiAgICB0aGlzLmF4aXNHcm91cC5hcHBlbmRDaGlsZCh0aGlzLnRpdGxlLmNhcHRpb24ubm9kZSk7XG4gICAgdGhpcy5hbmltYXRpb25NYW5hZ2VyID0gbW9kdWxlQ3R4LmFuaW1hdGlvbk1hbmFnZXI7XG4gICAgdGhpcy5hbmltYXRpb25TdGF0ZSA9IG5ldyBTdGF0ZU1hY2hpbmUoXCJlbXB0eVwiLCB7XG4gICAgICBlbXB0eToge1xuICAgICAgICB1cGRhdGU6IHtcbiAgICAgICAgICB0YXJnZXQ6IFwicmVhZHlcIixcbiAgICAgICAgICBhY3Rpb246ICgpID0+IHRoaXMucmVzZXRTZWxlY3Rpb25Ob2RlcygpXG4gICAgICAgIH0sXG4gICAgICAgIHJlc2V0OiBcImVtcHR5XCJcbiAgICAgIH0sXG4gICAgICByZWFkeToge1xuICAgICAgICB1cGRhdGU6IChkYXRhKSA9PiB0aGlzLmFuaW1hdGVSZWFkeVVwZGF0ZShkYXRhKSxcbiAgICAgICAgcmVzaXplOiAoKSA9PiB0aGlzLnJlc2V0U2VsZWN0aW9uTm9kZXMoKSxcbiAgICAgICAgcmVzZXQ6IFwiZW1wdHlcIlxuICAgICAgfVxuICAgIH0pO1xuICAgIGxldCBwcmV2aW91c1NpemUgPSB2b2lkIDA7XG4gICAgdGhpcy5kZXN0cm95Rm5zLnB1c2goXG4gICAgICB0aGlzLnRpdGxlLmNhcHRpb24ucmVnaXN0ZXJJbnRlcmFjdGlvbih0aGlzLm1vZHVsZUN0eCwgXCJhZnRlcmVuZFwiKSxcbiAgICAgIG1vZHVsZUN0eC5sYXlvdXRNYW5hZ2VyLmFkZExpc3RlbmVyKFwibGF5b3V0OmNvbXBsZXRlXCIsIChlKSA9PiB7XG4gICAgICAgIGlmIChwcmV2aW91c1NpemUgIT0gbnVsbCAmJiBqc29uRGlmZihlLmNoYXJ0LCBwcmV2aW91c1NpemUpICE9IG51bGwpIHtcbiAgICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJyZXNpemVcIik7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXNTaXplID0geyAuLi5lLmNoYXJ0IH07XG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudHlwZSA/PyBcIlwiO1xuICB9XG4gIHNldCBjcm9zc0xpbmVzKHZhbHVlKSB7XG4gICAgY29uc3QgeyBDcm9zc0xpbmVDb25zdHJ1Y3RvciB9ID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICB0aGlzLl9jcm9zc0xpbmVzLmZvckVhY2goKGNyb3NzTGluZSkgPT4gdGhpcy5kZXRhY2hDcm9zc0xpbmUoY3Jvc3NMaW5lKSk7XG4gICAgdGhpcy5fY3Jvc3NMaW5lcyA9IHZhbHVlLm1hcCgoY3Jvc3NMaW5lKSA9PiB7XG4gICAgICBjb25zdCBpbnN0YW5jZSA9IG5ldyBDcm9zc0xpbmVDb25zdHJ1Y3RvcigpO1xuICAgICAgaW5zdGFuY2Uuc2V0KGNyb3NzTGluZSk7XG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfSk7XG4gICAgdGhpcy5fY3Jvc3NMaW5lcy5mb3JFYWNoKChjcm9zc0xpbmUpID0+IHtcbiAgICAgIHRoaXMuYXR0YWNoQ3Jvc3NMaW5lKGNyb3NzTGluZSk7XG4gICAgICB0aGlzLmluaXRDcm9zc0xpbmUoY3Jvc3NMaW5lKTtcbiAgICB9KTtcbiAgfVxuICBnZXQgY3Jvc3NMaW5lcygpIHtcbiAgICByZXR1cm4gdGhpcy5fY3Jvc3NMaW5lcztcbiAgfVxuICByZXNldEFuaW1hdGlvbihwaGFzZSkge1xuICAgIGlmIChwaGFzZSA9PT0gXCJpbml0aWFsXCIpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcInJlc2V0XCIpO1xuICAgIH1cbiAgfVxuICBhdHRhY2hDcm9zc0xpbmUoY3Jvc3NMaW5lKSB7XG4gICAgdGhpcy5jcm9zc0xpbmVHcm91cC5hcHBlbmRDaGlsZChjcm9zc0xpbmUuZ3JvdXApO1xuICAgIHRoaXMuY3Jvc3NMaW5lR3JvdXAuYXBwZW5kQ2hpbGQoY3Jvc3NMaW5lLmxhYmVsR3JvdXApO1xuICB9XG4gIGRldGFjaENyb3NzTGluZShjcm9zc0xpbmUpIHtcbiAgICB0aGlzLmNyb3NzTGluZUdyb3VwLnJlbW92ZUNoaWxkKGNyb3NzTGluZS5ncm91cCk7XG4gICAgdGhpcy5jcm9zc0xpbmVHcm91cC5yZW1vdmVDaGlsZChjcm9zc0xpbmUubGFiZWxHcm91cCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLm1vZHVsZU1hcC5kZXN0cm95KCk7XG4gICAgdGhpcy5kZXN0cm95Rm5zLmZvckVhY2goKGYpID0+IGYoKSk7XG4gIH1cbiAgdXBkYXRlUmFuZ2UoKSB7XG4gICAgY29uc3QgeyByYW5nZTogcnIsIHZpc2libGVSYW5nZTogdnIsIHNjYWxlOiBzY2FsZTIgfSA9IHRoaXM7XG4gICAgY29uc3Qgc3BhbiA9IChyclsxXSAtIHJyWzBdKSAvICh2clsxXSAtIHZyWzBdKTtcbiAgICBjb25zdCBzaGlmdCA9IHNwYW4gKiB2clswXTtcbiAgICBjb25zdCBzdGFydDIgPSByclswXSAtIHNoaWZ0O1xuICAgIHNjYWxlMi5zZXRWaXNpYmxlUmFuZ2U/Lih2cik7XG4gICAgc2NhbGUyLnJhbmdlID0gW3N0YXJ0Miwgc3RhcnQyICsgc3Bhbl07XG4gICAgdGhpcy5jcm9zc0xpbmVzLmZvckVhY2goKGNyb3NzTGluZSkgPT4ge1xuICAgICAgY3Jvc3NMaW5lLmNsaXBwZWRSYW5nZSA9IFtyclswXSwgcnJbMV1dO1xuICAgIH0pO1xuICB9XG4gIHNldENyb3NzTGluZXNWaXNpYmxlKHZpc2libGUpIHtcbiAgICB0aGlzLmNyb3NzTGluZUdyb3VwLnZpc2libGUgPSB2aXNpYmxlO1xuICB9XG4gIGF0dGFjaEF4aXMoYXhpc05vZGUsIGdyaWROb2RlKSB7XG4gICAgZ3JpZE5vZGUuYXBwZW5kQ2hpbGQodGhpcy5ncmlkR3JvdXApO1xuICAgIGF4aXNOb2RlLmFwcGVuZENoaWxkKHRoaXMuYXhpc0dyb3VwKTtcbiAgICBheGlzTm9kZS5hcHBlbmRDaGlsZCh0aGlzLmNyb3NzTGluZUdyb3VwKTtcbiAgICBheGlzTm9kZS5hcHBlbmRDaGlsZCh0aGlzLmxhYmVsR3JvdXApO1xuICB9XG4gIGF0dGFjaExhYmVsKGF4aXNMYWJlbE5vZGUpIHtcbiAgICB0aGlzLmxhYmVsR3JvdXAuYXBwZW5kKGF4aXNMYWJlbE5vZGUpO1xuICB9XG4gIGRldGFjaEF4aXMoYXhpc05vZGUsIGdyaWROb2RlKSB7XG4gICAgZ3JpZE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5ncmlkR3JvdXApO1xuICAgIGF4aXNOb2RlLnJlbW92ZUNoaWxkKHRoaXMuYXhpc0dyb3VwKTtcbiAgICBheGlzTm9kZS5yZW1vdmVDaGlsZCh0aGlzLmNyb3NzTGluZUdyb3VwKTtcbiAgICBheGlzTm9kZS5yZW1vdmVDaGlsZCh0aGlzLmxhYmVsR3JvdXApO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBwb2ludCBvciBhbiBvYmplY3QgaXMgaW4gcmFuZ2UuXG4gICAqIEBwYXJhbSB4IEEgcG9pbnQgKG9yIG9iamVjdCdzIHN0YXJ0aW5nIHBvaW50KS5cbiAgICogQHBhcmFtIHRvbGVyYW5jZSBFeHBhbmRzIHRoZSByYW5nZSBvbiBib3RoIGVuZHMgYnkgdGhpcyBhbW91bnQuXG4gICAqL1xuICBpblJhbmdlKHgsIHRvbGVyYW5jZSA9IDApIHtcbiAgICBjb25zdCBbbWluLCBtYXhdID0gZmluZE1pbk1heCh0aGlzLnJhbmdlKTtcbiAgICByZXR1cm4geCA+PSBtaW4gLSB0b2xlcmFuY2UgJiYgeCA8PSBtYXggKyB0b2xlcmFuY2U7XG4gIH1cbiAgb25Gb3JtYXRDaGFuZ2UodGlja3MsIGZyYWN0aW9uRGlnaXRzLCBfZG9tYWluLCBmb3JtYXQpIHtcbiAgICBjb25zdCB7IHNjYWxlOiBzY2FsZTIgfSA9IHRoaXM7XG4gICAgY29uc3QgbG9nU2NhbGUgPSBzY2FsZTIgaW5zdGFuY2VvZiBMb2dTY2FsZTtcbiAgICBjb25zdCBkZWZhdWx0Rm9ybWF0dGVyID0gKGZvcm1hdE9mZnNldCkgPT4gbG9nU2NhbGUgPyBTdHJpbmcgOiAoeCkgPT4gdHlwZW9mIHggPT09IFwibnVtYmVyXCIgPyB4LnRvRml4ZWQoZnJhY3Rpb25EaWdpdHMgKyBmb3JtYXRPZmZzZXQpIDogU3RyaW5nKHgpO1xuICAgIGlmIChmb3JtYXQgJiYgc2NhbGUyICYmIHNjYWxlMi50aWNrRm9ybWF0KSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBmb3JtYXR0ZXIgPSBzY2FsZTIudGlja0Zvcm1hdCh7IHRpY2tzLCBzcGVjaWZpZXI6IGZvcm1hdCB9KTtcbiAgICAgICAgdGhpcy5sYWJlbEZvcm1hdHRlciA9IGZvcm1hdHRlcjtcbiAgICAgICAgdGhpcy5kYXR1bUZvcm1hdHRlciA9IGZvcm1hdHRlcjtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy5sYWJlbEZvcm1hdHRlciA9IGRlZmF1bHRGb3JtYXR0ZXIoMCk7XG4gICAgICAgIHRoaXMuZGF0dW1Gb3JtYXR0ZXIgPSBkZWZhdWx0Rm9ybWF0dGVyKDEpO1xuICAgICAgICBMb2dnZXIud2Fybk9uY2UoYHRoZSBheGlzIGxhYmVsIGZvcm1hdCBzdHJpbmcgJHtmb3JtYXR9IGlzIGludmFsaWQuIE5vIGZvcm1hdHRpbmcgd2lsbCBiZSBhcHBsaWVkYCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGFiZWxGb3JtYXR0ZXIgPSBkZWZhdWx0Rm9ybWF0dGVyKDApO1xuICAgICAgdGhpcy5kYXR1bUZvcm1hdHRlciA9IGRlZmF1bHRGb3JtYXR0ZXIoMSk7XG4gICAgfVxuICB9XG4gIG9uR3JpZExlbmd0aENoYW5nZSh2YWx1ZSwgcHJldlZhbHVlKSB7XG4gICAgaWYgKHByZXZWYWx1ZSBeIHZhbHVlKSB7XG4gICAgICB0aGlzLm9uR3JpZFZpc2liaWxpdHlDaGFuZ2UoKTtcbiAgICB9XG4gICAgdGhpcy5jcm9zc0xpbmVzLmZvckVhY2goKGNyb3NzTGluZSkgPT4gdGhpcy5pbml0Q3Jvc3NMaW5lKGNyb3NzTGluZSkpO1xuICB9XG4gIG9uR3JpZFZpc2liaWxpdHlDaGFuZ2UoKSB7XG4gICAgdGhpcy5ncmlkTGluZUdyb3VwU2VsZWN0aW9uLmNsZWFyKCk7XG4gIH1cbiAgY3JlYXRlTGFiZWwoKSB7XG4gICAgcmV0dXJuIG5ldyBBeGlzTGFiZWwoKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcy9yZW1vdmVzL3VwZGF0ZXMgdGhlIHNjZW5lIGdyYXBoIG5vZGVzIHRoYXQgY29uc3RpdHV0ZSB0aGUgYXhpcy5cbiAgICovXG4gIHVwZGF0ZShhbmltYXRlZCA9IHRydWUpIHtcbiAgICBpZiAoIXRoaXMudGlja0dlbmVyYXRpb25SZXN1bHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyByb3RhdGlvbiwgcGFyYWxsZWxGbGlwUm90YXRpb24sIHJlZ3VsYXJGbGlwUm90YXRpb24gfSA9IHRoaXMuY2FsY3VsYXRlUm90YXRpb25zKCk7XG4gICAgY29uc3Qgc2lkZUZsYWcgPSB0aGlzLmxhYmVsLmdldFNpZGVGbGFnKCk7XG4gICAgdGhpcy51cGRhdGVQb3NpdGlvbigpO1xuICAgIGNvbnN0IGxpbmVEYXRhID0gdGhpcy5nZXRBeGlzTGluZUNvb3JkaW5hdGVzKCk7XG4gICAgY29uc3QgeyB0aWNrRGF0YSwgY29tYmluZWRSb3RhdGlvbiwgdGV4dEJhc2VsaW5lLCB0ZXh0QWxpZ24sIHByaW1hcnlUaWNrQ291bnQgfSA9IHRoaXMudGlja0dlbmVyYXRpb25SZXN1bHQ7XG4gICAgY29uc3QgcHJldmlvdXNUaWNrcyA9IHRoaXMudGlja0xhYmVsR3JvdXBTZWxlY3Rpb24ubm9kZXMoKS5tYXAoKG5vZGUpID0+IG5vZGUuZGF0dW0udGlja0lkKTtcbiAgICB0aGlzLnVwZGF0ZVNlbGVjdGlvbnMobGluZURhdGEsIHRpY2tEYXRhLnRpY2tzLCB7XG4gICAgICBjb21iaW5lZFJvdGF0aW9uLFxuICAgICAgdGV4dEFsaWduLFxuICAgICAgdGV4dEJhc2VsaW5lLFxuICAgICAgcmFuZ2U6IHRoaXMuc2NhbGUucmFuZ2VcbiAgICB9KTtcbiAgICBpZiAoIWFuaW1hdGVkIHx8IHRoaXMuYW5pbWF0aW9uTWFuYWdlci5pc1NraXBwZWQoKSkge1xuICAgICAgdGhpcy5yZXNldFNlbGVjdGlvbk5vZGVzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGRpZmYyID0gdGhpcy5jYWxjdWxhdGVVcGRhdGVEaWZmKHByZXZpb3VzVGlja3MsIHRpY2tEYXRhKTtcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcInVwZGF0ZVwiLCBkaWZmMik7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlQXhpc0xpbmUoKTtcbiAgICB0aGlzLnVwZGF0ZUxhYmVscygpO1xuICAgIHRoaXMudXBkYXRlVmlzaWJpbGl0eSgpO1xuICAgIHRoaXMudXBkYXRlR3JpZExpbmVzKHNpZGVGbGFnKTtcbiAgICB0aGlzLnVwZGF0ZVRpY2tMaW5lcygpO1xuICAgIHRoaXMudXBkYXRlVGl0bGUoeyBhbnlUaWNrVmlzaWJsZTogdGlja0RhdGEudGlja3MubGVuZ3RoID4gMCB9KTtcbiAgICB0aGlzLnVwZGF0ZUNyb3NzTGluZXMoeyByb3RhdGlvbiwgcGFyYWxsZWxGbGlwUm90YXRpb24sIHJlZ3VsYXJGbGlwUm90YXRpb24gfSk7XG4gICAgdGhpcy51cGRhdGVMYXlvdXRTdGF0ZSh0aWNrRGF0YS5mcmFjdGlvbkRpZ2l0cyk7XG4gICAgcmV0dXJuIHByaW1hcnlUaWNrQ291bnQ7XG4gIH1cbiAgZ2V0QXhpc0xpbmVDb29yZGluYXRlcygpIHtcbiAgICBjb25zdCBbbWluLCBtYXhdID0gZmluZE1pbk1heCh0aGlzLnJhbmdlKTtcbiAgICByZXR1cm4geyB4OiAwLCB5MTogbWluLCB5MjogbWF4IH07XG4gIH1cbiAgZ2V0VGlja0xpbmVDb29yZGluYXRlcyhkYXR1bSkge1xuICAgIGNvbnN0IHNpZGVGbGFnID0gdGhpcy5sYWJlbC5nZXRTaWRlRmxhZygpO1xuICAgIGNvbnN0IHggPSBzaWRlRmxhZyAqIHRoaXMuZ2V0VGlja1NpemUoKTtcbiAgICBjb25zdCB4MSA9IE1hdGgubWluKDAsIHgpO1xuICAgIGNvbnN0IHgyID0geDEgKyBNYXRoLmFicyh4KTtcbiAgICBjb25zdCB5ID0gZGF0dW0udHJhbnNsYXRpb25ZO1xuICAgIHJldHVybiB7IHgxLCB4MiwgeSB9O1xuICB9XG4gIGdldFRpY2tMYWJlbFByb3BzKGRhdHVtLCBwYXJhbXMpIHtcbiAgICBjb25zdCB7IGxhYmVsIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgY29tYmluZWRSb3RhdGlvbiwgdGV4dEJhc2VsaW5lLCB0ZXh0QWxpZ24sIHJhbmdlOiByYW5nZTMgfSA9IHBhcmFtcztcbiAgICBjb25zdCB0ZXh0ID0gZGF0dW0udGlja0xhYmVsO1xuICAgIGNvbnN0IHNpZGVGbGFnID0gbGFiZWwuZ2V0U2lkZUZsYWcoKTtcbiAgICBjb25zdCBsYWJlbFggPSBzaWRlRmxhZyAqICh0aGlzLmdldFRpY2tTaXplKCkgKyBsYWJlbC5wYWRkaW5nICsgdGhpcy5zZXJpZXNBcmVhUGFkZGluZyk7XG4gICAgY29uc3QgdmlzaWJsZSA9IHRleHQgIT09IFwiXCIgJiYgdGV4dCAhPSBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICB0aWNrSWQ6IGRhdHVtLnRpY2tJZCxcbiAgICAgIHRyYW5zbGF0aW9uWTogZGF0dW0udHJhbnNsYXRpb25ZLFxuICAgICAgZmlsbDogbGFiZWwuY29sb3IsXG4gICAgICBmb250RmFtaWx5OiBsYWJlbC5mb250RmFtaWx5LFxuICAgICAgZm9udFNpemU6IGxhYmVsLmZvbnRTaXplLFxuICAgICAgZm9udFN0eWxlOiBsYWJlbC5mb250U3R5bGUsXG4gICAgICBmb250V2VpZ2h0OiBsYWJlbC5mb250V2VpZ2h0LFxuICAgICAgcm90YXRpb246IGNvbWJpbmVkUm90YXRpb24sXG4gICAgICByb3RhdGlvbkNlbnRlclg6IGxhYmVsWCxcbiAgICAgIHRleHQsXG4gICAgICB0ZXh0QWxpZ24sXG4gICAgICB0ZXh0QmFzZWxpbmUsXG4gICAgICB2aXNpYmxlLFxuICAgICAgeDogbGFiZWxYLFxuICAgICAgeTogMCxcbiAgICAgIHJhbmdlOiByYW5nZTNcbiAgICB9O1xuICB9XG4gIGdldFRpY2tTaXplKCkge1xuICAgIHJldHVybiB0aGlzLnRpY2suZW5hYmxlZCA/IHRoaXMudGljay5zaXplIDogNjtcbiAgfVxuICBzZXRUaXRsZVByb3BzKGNhcHRpb24sIHBhcmFtcykge1xuICAgIGNvbnN0IHsgdGl0bGUgfSA9IHRoaXM7XG4gICAgaWYgKCF0aXRsZS5lbmFibGVkKSB7XG4gICAgICBjYXB0aW9uLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgIGNhcHRpb24ubm9kZS52aXNpYmxlID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhcHRpb24uY29sb3IgPSB0aXRsZS5jb2xvcjtcbiAgICBjYXB0aW9uLmZvbnRGYW1pbHkgPSB0aXRsZS5mb250RmFtaWx5O1xuICAgIGNhcHRpb24uZm9udFNpemUgPSB0aXRsZS5mb250U2l6ZTtcbiAgICBjYXB0aW9uLmZvbnRTdHlsZSA9IHRpdGxlLmZvbnRTdHlsZTtcbiAgICBjYXB0aW9uLmZvbnRXZWlnaHQgPSB0aXRsZS5mb250V2VpZ2h0O1xuICAgIGNhcHRpb24uZW5hYmxlZCA9IHRpdGxlLmVuYWJsZWQ7XG4gICAgY2FwdGlvbi53cmFwcGluZyA9IHRpdGxlLndyYXBwaW5nO1xuICAgIGNvbnN0IHRpdGxlTm9kZSA9IGNhcHRpb24ubm9kZTtcbiAgICBjb25zdCBwYWRkaW5nID0gKHRpdGxlLnNwYWNpbmcgPz8gMCkgKyBwYXJhbXMuc3BhY2luZztcbiAgICBjb25zdCBzaWRlRmxhZyA9IHRoaXMubGFiZWwuZ2V0U2lkZUZsYWcoKTtcbiAgICBjb25zdCBwYXJhbGxlbEZsaXBSb3RhdGlvbiA9IG5vcm1hbGl6ZUFuZ2xlMzYwKHRoaXMucm90YXRpb24pO1xuICAgIGNvbnN0IHRpdGxlUm90YXRpb25GbGFnID0gc2lkZUZsYWcgPT09IC0xICYmIHBhcmFsbGVsRmxpcFJvdGF0aW9uID4gTWF0aC5QSSAmJiBwYXJhbGxlbEZsaXBSb3RhdGlvbiA8IE1hdGguUEkgKiAyID8gLTEgOiAxO1xuICAgIGNvbnN0IHJvdGF0aW9uID0gdGl0bGVSb3RhdGlvbkZsYWcgKiBzaWRlRmxhZyAqIE1hdGguUEkgLyAyO1xuICAgIGNvbnN0IHRleHRCYXNlbGluZSA9IHRpdGxlUm90YXRpb25GbGFnID09PSAxID8gXCJib3R0b21cIiA6IFwidG9wXCI7XG4gICAgY29uc3QgeyByYW5nZTogcmFuZ2UzIH0gPSB0aGlzO1xuICAgIGNvbnN0IHggPSBNYXRoLmZsb29yKHRpdGxlUm90YXRpb25GbGFnICogc2lkZUZsYWcgKiAocmFuZ2UzWzBdICsgcmFuZ2UzWzFdKSAvIDIpO1xuICAgIGNvbnN0IHkgPSBzaWRlRmxhZyA9PT0gLTEgPyBNYXRoLmZsb29yKHRpdGxlUm90YXRpb25GbGFnICogLXBhZGRpbmcpIDogTWF0aC5mbG9vcigtcGFkZGluZyk7XG4gICAgY29uc3QgeyBjYWxsYmFja0NhY2hlIH0gPSB0aGlzLm1vZHVsZUN0eDtcbiAgICBjb25zdCB7IGZvcm1hdHRlciA9IChwKSA9PiBwLmRlZmF1bHRWYWx1ZSB9ID0gdGl0bGU7XG4gICAgY29uc3QgdGV4dCA9IGNhbGxiYWNrQ2FjaGUuY2FsbChmb3JtYXR0ZXIsIHRoaXMuZ2V0VGl0bGVGb3JtYXR0ZXJQYXJhbXMoKSk7XG4gICAgY2FwdGlvbi50ZXh0ID0gdGV4dDtcbiAgICB0aXRsZU5vZGUuc2V0UHJvcGVydGllcyh7IHZpc2libGU6IHRydWUsIHRleHQsIHRleHRCYXNlbGluZSwgeCwgeSwgcm90YXRpb24gfSk7XG4gIH1cbiAgY2FsY3VsYXRlTGF5b3V0KGRvbWFpbiwgcHJpbWFyeVRpY2tDb3VudCkge1xuICAgIGNvbnN0IHsgcm90YXRpb24sIHBhcmFsbGVsRmxpcFJvdGF0aW9uLCByZWd1bGFyRmxpcFJvdGF0aW9uIH0gPSB0aGlzLmNhbGN1bGF0ZVJvdGF0aW9ucygpO1xuICAgIGNvbnN0IHNpZGVGbGFnID0gdGhpcy5sYWJlbC5nZXRTaWRlRmxhZygpO1xuICAgIGNvbnN0IGxhYmVsWCA9IHNpZGVGbGFnICogKHRoaXMuZ2V0VGlja1NpemUoKSArIHRoaXMubGFiZWwucGFkZGluZyArIHRoaXMuc2VyaWVzQXJlYVBhZGRpbmcpO1xuICAgIHRoaXMudXBkYXRlU2NhbGUoZG9tYWluKTtcbiAgICB0aGlzLnRpY2tHZW5lcmF0aW9uUmVzdWx0ID0gdGhpcy5nZW5lcmF0ZVRpY2tzKHtcbiAgICAgIHByaW1hcnlUaWNrQ291bnQsXG4gICAgICBwYXJhbGxlbEZsaXBSb3RhdGlvbixcbiAgICAgIHJlZ3VsYXJGbGlwUm90YXRpb24sXG4gICAgICBsYWJlbFgsXG4gICAgICBzaWRlRmxhZ1xuICAgIH0pO1xuICAgIGNvbnN0IHsgdGlja0RhdGEsIGNvbWJpbmVkUm90YXRpb24sIHRleHRCYXNlbGluZSwgdGV4dEFsaWduLCAuLi50aWNrc1Jlc3VsdCB9ID0gdGhpcy50aWNrR2VuZXJhdGlvblJlc3VsdDtcbiAgICB0aGlzLnVwZGF0ZUxheW91dFN0YXRlKHRpY2tEYXRhLmZyYWN0aW9uRGlnaXRzKTtcbiAgICBjb25zdCBib3hlcyA9IFtdO1xuICAgIGNvbnN0IHsgeCwgeTEsIHkyIH0gPSB0aGlzLmdldEF4aXNMaW5lQ29vcmRpbmF0ZXMoKTtcbiAgICBjb25zdCBsaW5lQm94ID0gbmV3IEJCb3goXG4gICAgICB4ICsgTWF0aC5taW4oc2lkZUZsYWcgKiB0aGlzLnNlcmllc0FyZWFQYWRkaW5nLCAwKSxcbiAgICAgIHkxLFxuICAgICAgdGhpcy5zZXJpZXNBcmVhUGFkZGluZyxcbiAgICAgIHkyIC0geTFcbiAgICApO1xuICAgIGJveGVzLnB1c2gobGluZUJveCk7XG4gICAgaWYgKHRoaXMudGljay5lbmFibGVkKSB7XG4gICAgICB0aWNrRGF0YS50aWNrcy5mb3JFYWNoKChkYXR1bSkgPT4ge1xuICAgICAgICBjb25zdCB7IHgxLCB4MiwgeSB9ID0gdGhpcy5nZXRUaWNrTGluZUNvb3JkaW5hdGVzKGRhdHVtKTtcbiAgICAgICAgY29uc3QgdGlja0xpbmVCb3ggPSBuZXcgQkJveCh4MSwgeSwgeDIgLSB4MSwgMCk7XG4gICAgICAgIGJveGVzLnB1c2godGlja0xpbmVCb3gpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmxhYmVsLmVuYWJsZWQpIHtcbiAgICAgIGNvbnN0IHRlbXBUZXh0ID0gbmV3IFRyYW5zZm9ybWFibGVUZXh0KCk7XG4gICAgICB0aWNrRGF0YS50aWNrcy5mb3JFYWNoKChkYXR1bSkgPT4ge1xuICAgICAgICBjb25zdCBsYWJlbFByb3BzID0gdGhpcy5nZXRUaWNrTGFiZWxQcm9wcyhkYXR1bSwge1xuICAgICAgICAgIGNvbWJpbmVkUm90YXRpb24sXG4gICAgICAgICAgdGV4dEFsaWduLFxuICAgICAgICAgIHRleHRCYXNlbGluZSxcbiAgICAgICAgICByYW5nZTogdGhpcy5zY2FsZS5yYW5nZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFsYWJlbFByb3BzLnZpc2libGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGVtcFRleHQuc2V0UHJvcGVydGllcyh7XG4gICAgICAgICAgLi4ubGFiZWxQcm9wcyxcbiAgICAgICAgICB0cmFuc2xhdGlvblk6IE1hdGgucm91bmQoZGF0dW0udHJhbnNsYXRpb25ZKVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYm94ID0gdGVtcFRleHQuZ2V0QkJveCgpO1xuICAgICAgICBpZiAoYm94KSB7XG4gICAgICAgICAgYm94ZXMucHVzaChib3gpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGl0bGU/LmVuYWJsZWQpIHtcbiAgICAgIGNvbnN0IGNhcHRpb24gPSBuZXcgQ2FwdGlvbigpO1xuICAgICAgY29uc3Qgc3BhY2luZyA9IEJCb3gubWVyZ2UoYm94ZXMpLndpZHRoO1xuICAgICAgdGhpcy5zZXRUaXRsZVByb3BzKGNhcHRpb24sIHsgc3BhY2luZyB9KTtcbiAgICAgIGNvbnN0IHRpdGxlQm94ID0gY2FwdGlvbi5ub2RlLmdldEJCb3goKTtcbiAgICAgIGlmICh0aXRsZUJveCkge1xuICAgICAgICBib3hlcy5wdXNoKHRpdGxlQm94KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYmJveCA9IEJCb3gubWVyZ2UoYm94ZXMpO1xuICAgIGNvbnN0IHRyYW5zZm9ybWVkQkJveCA9IHRoaXMuZ2V0VHJhbnNmb3JtQm94KGJib3gpO1xuICAgIGNvbnN0IGFueVNlcmllc0FjdGl2ZSA9IHRoaXMuaXNBbnlTZXJpZXNBY3RpdmUoKTtcbiAgICB0aGlzLmNyb3NzTGluZXMuZm9yRWFjaCgoY3Jvc3NMaW5lKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjcm9zc0xpbmUuc2lkZUZsYWcgPSAtc2lkZUZsYWc7XG4gICAgICBjcm9zc0xpbmUuZGlyZWN0aW9uID0gcm90YXRpb24gPT09IC1NYXRoLlBJIC8gMiA/IFwieFwiIC8qIFggKi8gOiBcInlcIiAvKiBZICovO1xuICAgICAgaWYgKGNyb3NzTGluZSBpbnN0YW5jZW9mIENhcnRlc2lhbkNyb3NzTGluZSkge1xuICAgICAgICAoX2EgPSBjcm9zc0xpbmUubGFiZWwpLnBhcmFsbGVsID8/IChfYS5wYXJhbGxlbCA9IHRoaXMubGFiZWwucGFyYWxsZWwpO1xuICAgICAgfVxuICAgICAgY3Jvc3NMaW5lLnBhcmFsbGVsRmxpcFJvdGF0aW9uID0gcGFyYWxsZWxGbGlwUm90YXRpb247XG4gICAgICBjcm9zc0xpbmUucmVndWxhckZsaXBSb3RhdGlvbiA9IHJlZ3VsYXJGbGlwUm90YXRpb247XG4gICAgICBjcm9zc0xpbmUuY2FsY3VsYXRlTGF5b3V0Py4oYW55U2VyaWVzQWN0aXZlLCB0aGlzLnJldmVyc2UpO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBwcmltYXJ5VGlja0NvdW50OiB0aWNrc1Jlc3VsdC5wcmltYXJ5VGlja0NvdW50LFxuICAgICAgYmJveDogdHJhbnNmb3JtZWRCQm94XG4gICAgfTtcbiAgfVxuICB1cGRhdGVMYXlvdXRTdGF0ZShmcmFjdGlvbkRpZ2l0cykge1xuICAgIHRoaXMubGF5b3V0LmxhYmVsID0ge1xuICAgICAgZnJhY3Rpb25EaWdpdHMsXG4gICAgICBwYWRkaW5nOiB0aGlzLmxhYmVsLnBhZGRpbmcsXG4gICAgICBmb3JtYXQ6IHRoaXMubGFiZWwuZm9ybWF0XG4gICAgfTtcbiAgfVxuICBnZXRUcmFuc2Zvcm1Cb3goYmJveCkge1xuICAgIGNvbnN0IG1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcbiAgICBjb25zdCB7IHJvdGF0aW9uLCB0cmFuc2xhdGlvblgsIHRyYW5zbGF0aW9uWSB9ID0gdGhpcy5nZXRBeGlzVHJhbnNmb3JtKCk7XG4gICAgTWF0cml4LnVwZGF0ZVRyYW5zZm9ybU1hdHJpeChtYXRyaXgsIDEsIDEsIHJvdGF0aW9uLCB0cmFuc2xhdGlvblgsIHRyYW5zbGF0aW9uWSk7XG4gICAgcmV0dXJuIG1hdHJpeC50cmFuc2Zvcm1CQm94KGJib3gpO1xuICB9XG4gIHNldERvbWFpbihkb21haW4pIHtcbiAgICB0aGlzLmRhdGFEb21haW4gPSB0aGlzLm5vcm1hbGlzZURhdGFEb21haW4oZG9tYWluKTtcbiAgICBpZiAodGhpcy5yZXZlcnNlKSB7XG4gICAgICB0aGlzLmRhdGFEb21haW4uZG9tYWluLnJldmVyc2UoKTtcbiAgICB9XG4gICAgdGhpcy5zY2FsZS5kb21haW4gPSB0aGlzLmRhdGFEb21haW4uZG9tYWluO1xuICB9XG4gIHVwZGF0ZVNjYWxlKGRvbWFpbikge1xuICAgIGlmIChkb21haW4pIHtcbiAgICAgIHRoaXMuc2V0RG9tYWluKGRvbWFpbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2FsY3VsYXRlRG9tYWluKCk7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlUmFuZ2UoKTtcbiAgICB0aGlzLnNjYWxlLmludGVydmFsID0gdGhpcy5pbnRlcnZhbC5zdGVwO1xuICAgIGlmIChDb250aW51b3VzU2NhbGUuaXModGhpcy5zY2FsZSkpIHtcbiAgICAgIHRoaXMuc2NhbGUubmljZSA9IHRoaXMubmljZTtcbiAgICAgIHRoaXMuc2NhbGUudXBkYXRlKCk7XG4gICAgfVxuICB9XG4gIGNhbGN1bGF0ZVJvdGF0aW9ucygpIHtcbiAgICBjb25zdCByb3RhdGlvbiA9IHRvUmFkaWFucyh0aGlzLnJvdGF0aW9uKTtcbiAgICBjb25zdCBwYXJhbGxlbEZsaXBSb3RhdGlvbiA9IG5vcm1hbGl6ZUFuZ2xlMzYwKHJvdGF0aW9uKTtcbiAgICBjb25zdCByZWd1bGFyRmxpcFJvdGF0aW9uID0gbm9ybWFsaXplQW5nbGUzNjAocm90YXRpb24gLSBNYXRoLlBJIC8gMik7XG4gICAgcmV0dXJuIHsgcm90YXRpb24sIHBhcmFsbGVsRmxpcFJvdGF0aW9uLCByZWd1bGFyRmxpcFJvdGF0aW9uIH07XG4gIH1cbiAgZ2VuZXJhdGVUaWNrcyh7XG4gICAgcHJpbWFyeVRpY2tDb3VudCxcbiAgICBwYXJhbGxlbEZsaXBSb3RhdGlvbixcbiAgICByZWd1bGFyRmxpcFJvdGF0aW9uLFxuICAgIGxhYmVsWCxcbiAgICBzaWRlRmxhZ1xuICB9KSB7XG4gICAgY29uc3Qge1xuICAgICAgc2NhbGU6IHNjYWxlMixcbiAgICAgIGludGVydmFsOiB7IG1pblNwYWNpbmcsIG1heFNwYWNpbmcgfSxcbiAgICAgIGxhYmVsOiB7IHBhcmFsbGVsLCByb3RhdGlvbiwgZm9udEZhbWlseSwgZm9udFNpemUsIGZvbnRTdHlsZSwgZm9udFdlaWdodCB9XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgc2Vjb25kYXJ5QXhpcyA9IHByaW1hcnlUaWNrQ291bnQgIT09IHZvaWQgMDtcbiAgICBjb25zdCB7IGRlZmF1bHRSb3RhdGlvbiwgY29uZmlndXJlZFJvdGF0aW9uLCBwYXJhbGxlbEZsaXBGbGFnLCByZWd1bGFyRmxpcEZsYWcgfSA9IGNhbGN1bGF0ZUxhYmVsUm90YXRpb24oe1xuICAgICAgcm90YXRpb24sXG4gICAgICBwYXJhbGxlbCxcbiAgICAgIHJlZ3VsYXJGbGlwUm90YXRpb24sXG4gICAgICBwYXJhbGxlbEZsaXBSb3RhdGlvblxuICAgIH0pO1xuICAgIGNvbnN0IGluaXRpYWxSb3RhdGlvbiA9IGNvbmZpZ3VyZWRSb3RhdGlvbiArIGRlZmF1bHRSb3RhdGlvbjtcbiAgICBjb25zdCBsYWJlbE1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcbiAgICBjb25zdCB7IG1heFRpY2tDb3VudCB9ID0gdGhpcy5lc3RpbWF0ZVRpY2tDb3VudCh7IG1pblNwYWNpbmcsIG1heFNwYWNpbmcgfSk7XG4gICAgY29uc3QgY29udGludW91cyA9IENvbnRpbnVvdXNTY2FsZS5pcyhzY2FsZTIpIHx8IE9yZGluYWxUaW1lU2NhbGUuaXMoc2NhbGUyKTtcbiAgICBjb25zdCBtYXhJdGVyYXRpb25zID0gIWNvbnRpbnVvdXMgfHwgaXNOYU4obWF4VGlja0NvdW50KSA/IDEwIDogbWF4VGlja0NvdW50O1xuICAgIGxldCB0ZXh0QWxpZ24gPSBnZXRUZXh0QWxpZ24ocGFyYWxsZWwsIGNvbmZpZ3VyZWRSb3RhdGlvbiwgMCwgc2lkZUZsYWcsIHJlZ3VsYXJGbGlwRmxhZyk7XG4gICAgY29uc3QgdGV4dEJhc2VsaW5lID0gZ2V0VGV4dEJhc2VsaW5lKHBhcmFsbGVsLCBjb25maWd1cmVkUm90YXRpb24sIHNpZGVGbGFnLCBwYXJhbGxlbEZsaXBGbGFnKTtcbiAgICBjb25zdCBmb250ID0gVGV4dFV0aWxzLnRvRm9udFN0cmluZyh7IGZvbnRGYW1pbHksIGZvbnRTaXplLCBmb250U3R5bGUsIGZvbnRXZWlnaHQgfSk7XG4gICAgY29uc3QgdGV4dE1lYXN1cmVyID0gQ2FjaGVkVGV4dE1lYXN1cmVyUG9vbC5nZXRNZWFzdXJlcih7IGZvbnQgfSk7XG4gICAgY29uc3QgdGV4dFByb3BzID0ge1xuICAgICAgZm9udEZhbWlseSxcbiAgICAgIGZvbnRTaXplLFxuICAgICAgZm9udFN0eWxlLFxuICAgICAgZm9udFdlaWdodCxcbiAgICAgIHRleHRCYXNlbGluZSxcbiAgICAgIHRleHRBbGlnblxuICAgIH07XG4gICAgbGV0IHRpY2tEYXRhID0ge1xuICAgICAgcmF3VGlja3M6IFtdLFxuICAgICAgZnJhY3Rpb25EaWdpdHM6IDAsXG4gICAgICB0aWNrczogW10sXG4gICAgICBsYWJlbENvdW50OiAwXG4gICAgfTtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGxldCBhdXRvUm90YXRpb24gPSAwO1xuICAgIGxldCBsYWJlbE92ZXJsYXAgPSB0cnVlO1xuICAgIGxldCBsYWJlbERhdGEgPSBbXTtcbiAgICBsZXQgdGVybWluYXRlID0gZmFsc2U7XG4gICAgd2hpbGUgKGxhYmVsT3ZlcmxhcCAmJiBpbmRleCA8PSBtYXhJdGVyYXRpb25zKSB7XG4gICAgICBpZiAodGVybWluYXRlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgYXV0b1JvdGF0aW9uID0gMDtcbiAgICAgIHRleHRBbGlnbiA9IGdldFRleHRBbGlnbihwYXJhbGxlbCwgY29uZmlndXJlZFJvdGF0aW9uLCAwLCBzaWRlRmxhZywgcmVndWxhckZsaXBGbGFnKTtcbiAgICAgIGNvbnN0IHRpY2tTdHJhdGVnaWVzID0gdGhpcy5nZXRUaWNrU3RyYXRlZ2llcyh7IHNlY29uZGFyeUF4aXMsIGluZGV4IH0pO1xuICAgICAgZm9yIChjb25zdCBzdHJhdGVneSBvZiB0aWNrU3RyYXRlZ2llcykge1xuICAgICAgICAoeyB0aWNrRGF0YSwgaW5kZXgsIGF1dG9Sb3RhdGlvbiwgdGVybWluYXRlIH0gPSBzdHJhdGVneSh7XG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgdGlja0RhdGEsXG4gICAgICAgICAgdGV4dFByb3BzLFxuICAgICAgICAgIGxhYmVsT3ZlcmxhcCxcbiAgICAgICAgICB0ZXJtaW5hdGUsXG4gICAgICAgICAgcHJpbWFyeVRpY2tDb3VudFxuICAgICAgICB9KSk7XG4gICAgICAgIGNvbnN0IHJvdGF0ZWQgPSBjb25maWd1cmVkUm90YXRpb24gIT09IDAgfHwgYXV0b1JvdGF0aW9uICE9PSAwO1xuICAgICAgICBjb25zdCBsYWJlbFJvdGF0aW9uID0gaW5pdGlhbFJvdGF0aW9uICsgYXV0b1JvdGF0aW9uO1xuICAgICAgICBjb25zdCBsYWJlbFNwYWNpbmcgPSBnZXRMYWJlbFNwYWNpbmcodGhpcy5sYWJlbC5taW5TcGFjaW5nLCByb3RhdGVkKTtcbiAgICAgICAgTWF0cml4LnVwZGF0ZVRyYW5zZm9ybU1hdHJpeChsYWJlbE1hdHJpeCwgMSwgMSwgbGFiZWxSb3RhdGlvbiwgMCwgMCk7XG4gICAgICAgIHRleHRBbGlnbiA9IGdldFRleHRBbGlnbihwYXJhbGxlbCwgY29uZmlndXJlZFJvdGF0aW9uLCBhdXRvUm90YXRpb24sIHNpZGVGbGFnLCByZWd1bGFyRmxpcEZsYWcpO1xuICAgICAgICBsYWJlbERhdGEgPSB0aGlzLmNyZWF0ZUxhYmVsRGF0YSh0aWNrRGF0YS50aWNrcywgbGFiZWxYLCBsYWJlbE1hdHJpeCwgdGV4dE1lYXN1cmVyKTtcbiAgICAgICAgbGFiZWxPdmVybGFwID0gdGhpcy5sYWJlbC5hdm9pZENvbGxpc2lvbnMgPyBheGlzTGFiZWxzT3ZlcmxhcChsYWJlbERhdGEsIGxhYmVsU3BhY2luZykgOiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY29tYmluZWRSb3RhdGlvbiA9IGRlZmF1bHRSb3RhdGlvbiArIGNvbmZpZ3VyZWRSb3RhdGlvbiArIGF1dG9Sb3RhdGlvbjtcbiAgICBpZiAoIXNlY29uZGFyeUF4aXMgJiYgdGlja0RhdGEucmF3VGlja3MubGVuZ3RoID4gMCkge1xuICAgICAgcHJpbWFyeVRpY2tDb3VudCA9IHRpY2tEYXRhLnJhd1RpY2tzLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHsgdGlja0RhdGEsIHByaW1hcnlUaWNrQ291bnQsIGNvbWJpbmVkUm90YXRpb24sIHRleHRCYXNlbGluZSwgdGV4dEFsaWduLCBsYWJlbERhdGEgfTtcbiAgfVxuICBnZXRUaWNrU3RyYXRlZ2llcyh7XG4gICAgaW5kZXg6IGl0ZXJhdGlvbixcbiAgICBzZWNvbmRhcnlBeGlzXG4gIH0pIHtcbiAgICBjb25zdCB7IHNjYWxlOiBzY2FsZTIsIGxhYmVsIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgbWluU3BhY2luZyB9ID0gdGhpcy5pbnRlcnZhbDtcbiAgICBjb25zdCBjb250aW51b3VzID0gQ29udGludW91c1NjYWxlLmlzKHNjYWxlMikgfHwgT3JkaW5hbFRpbWVTY2FsZS5pcyhzY2FsZTIpO1xuICAgIGNvbnN0IGF2b2lkTGFiZWxDb2xsaXNpb25zID0gbGFiZWwuZW5hYmxlZCAmJiBsYWJlbC5hdm9pZENvbGxpc2lvbnM7XG4gICAgY29uc3QgZmlsdGVyVGlja3MgPSAhY29udGludW91cyAmJiBpdGVyYXRpb24gIT09IDAgJiYgYXZvaWRMYWJlbENvbGxpc2lvbnM7XG4gICAgY29uc3QgYXV0b1JvdGF0ZSA9IGxhYmVsLmF1dG9Sb3RhdGUgPT09IHRydWUgJiYgbGFiZWwucm90YXRpb24gPT09IHZvaWQgMDtcbiAgICBjb25zdCBzdHJhdGVnaWVzID0gW107XG4gICAgbGV0IHRpY2tHZW5lcmF0aW9uVHlwZTtcbiAgICBpZiAodGhpcy5pbnRlcnZhbC52YWx1ZXMpIHtcbiAgICAgIHRpY2tHZW5lcmF0aW9uVHlwZSA9IDMgLyogVkFMVUVTICovO1xuICAgIH0gZWxzZSBpZiAoc2Vjb25kYXJ5QXhpcykge1xuICAgICAgdGlja0dlbmVyYXRpb25UeXBlID0gMSAvKiBDUkVBVEVfU0VDT05EQVJZICovO1xuICAgIH0gZWxzZSBpZiAoZmlsdGVyVGlja3MpIHtcbiAgICAgIHRpY2tHZW5lcmF0aW9uVHlwZSA9IDIgLyogRklMVEVSICovO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aWNrR2VuZXJhdGlvblR5cGUgPSAwIC8qIENSRUFURSAqLztcbiAgICB9XG4gICAgY29uc3QgdGlja0dlbmVyYXRpb25TdHJhdGVneSA9ICh7IGluZGV4LCB0aWNrRGF0YSwgcHJpbWFyeVRpY2tDb3VudCwgdGVybWluYXRlIH0pID0+IHRoaXMuY3JlYXRlVGlja0RhdGEodGlja0dlbmVyYXRpb25UeXBlLCBpbmRleCwgdGlja0RhdGEsIHRlcm1pbmF0ZSwgcHJpbWFyeVRpY2tDb3VudCk7XG4gICAgc3RyYXRlZ2llcy5wdXNoKHRpY2tHZW5lcmF0aW9uU3RyYXRlZ3kpO1xuICAgIGlmICghY29udGludW91cyAmJiAhaXNOYU4obWluU3BhY2luZykpIHtcbiAgICAgIGNvbnN0IHRpY2tGaWx0ZXJTdHJhdGVneSA9ICh7IGluZGV4LCB0aWNrRGF0YSwgcHJpbWFyeVRpY2tDb3VudCwgdGVybWluYXRlIH0pID0+IHRoaXMuY3JlYXRlVGlja0RhdGEoMiAvKiBGSUxURVIgKi8sIGluZGV4LCB0aWNrRGF0YSwgdGVybWluYXRlLCBwcmltYXJ5VGlja0NvdW50KTtcbiAgICAgIHN0cmF0ZWdpZXMucHVzaCh0aWNrRmlsdGVyU3RyYXRlZ3kpO1xuICAgIH1cbiAgICBpZiAoIWF2b2lkTGFiZWxDb2xsaXNpb25zKSB7XG4gICAgICByZXR1cm4gc3RyYXRlZ2llcztcbiAgICB9XG4gICAgaWYgKGF1dG9Sb3RhdGUpIHtcbiAgICAgIGNvbnN0IGF1dG9Sb3RhdGVTdHJhdGVneSA9ICh7IGluZGV4LCB0aWNrRGF0YSwgbGFiZWxPdmVybGFwLCB0ZXJtaW5hdGUgfSkgPT4gKHtcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIHRpY2tEYXRhLFxuICAgICAgICBhdXRvUm90YXRpb246IHRoaXMuZ2V0QXV0b1JvdGF0aW9uKGxhYmVsT3ZlcmxhcCksXG4gICAgICAgIHRlcm1pbmF0ZVxuICAgICAgfSk7XG4gICAgICBzdHJhdGVnaWVzLnB1c2goYXV0b1JvdGF0ZVN0cmF0ZWd5KTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmF0ZWdpZXM7XG4gIH1cbiAgY3JlYXRlVGlja0RhdGEodGlja0dlbmVyYXRpb25UeXBlLCBpbmRleCwgdGlja0RhdGEsIHRlcm1pbmF0ZSwgcHJpbWFyeVRpY2tDb3VudCkge1xuICAgIGNvbnN0IHsgc2NhbGU6IHNjYWxlMiB9ID0gdGhpcztcbiAgICBjb25zdCB7IHN0ZXAsIHZhbHVlcywgbWluU3BhY2luZywgbWF4U3BhY2luZyB9ID0gdGhpcy5pbnRlcnZhbDtcbiAgICBjb25zdCB7IG1heFRpY2tDb3VudCwgbWluVGlja0NvdW50LCBkZWZhdWx0VGlja0NvdW50IH0gPSB0aGlzLmVzdGltYXRlVGlja0NvdW50KHsgbWluU3BhY2luZywgbWF4U3BhY2luZyB9KTtcbiAgICBjb25zdCBjb250aW51b3VzID0gQ29udGludW91c1NjYWxlLmlzKHNjYWxlMikgfHwgT3JkaW5hbFRpbWVTY2FsZS5pcyhzY2FsZTIpO1xuICAgIGNvbnN0IG1heEl0ZXJhdGlvbnMgPSAhY29udGludW91cyB8fCBpc05hTihtYXhUaWNrQ291bnQpID8gMTAgOiBtYXhUaWNrQ291bnQ7XG4gICAgbGV0IHRpY2tDb3VudCA9IGNvbnRpbnVvdXMgPyBNYXRoLm1heChkZWZhdWx0VGlja0NvdW50IC0gaW5kZXgsIG1pblRpY2tDb3VudCkgOiBtYXhUaWNrQ291bnQ7XG4gICAgY29uc3QgcmVnZW5lcmF0ZVRpY2tzID0gc3RlcCA9PT0gdm9pZCAwICYmIHZhbHVlcyA9PT0gdm9pZCAwICYmIHRpY2tDb3VudCA+IG1pblRpY2tDb3VudCAmJiAoY29udGludW91cyB8fCB0aWNrR2VuZXJhdGlvblR5cGUgPT09IDIgLyogRklMVEVSICovKTtcbiAgICBsZXQgdW5jaGFuZ2VkID0gdHJ1ZTtcbiAgICB3aGlsZSAodW5jaGFuZ2VkICYmIGluZGV4IDw9IG1heEl0ZXJhdGlvbnMpIHtcbiAgICAgIGNvbnN0IHByZXZUaWNrcyA9IHRpY2tEYXRhLnJhd1RpY2tzO1xuICAgICAgdGlja0NvdW50ID0gY29udGludW91cyA/IE1hdGgubWF4KGRlZmF1bHRUaWNrQ291bnQgLSBpbmRleCwgbWluVGlja0NvdW50KSA6IG1heFRpY2tDb3VudDtcbiAgICAgIGNvbnN0IHsgcmF3VGlja3MsIGZyYWN0aW9uRGlnaXRzLCB0aWNrcywgbGFiZWxDb3VudCB9ID0gdGhpcy5nZXRUaWNrcyh7XG4gICAgICAgIHRpY2tHZW5lcmF0aW9uVHlwZSxcbiAgICAgICAgcHJldmlvdXNUaWNrczogcHJldlRpY2tzLFxuICAgICAgICB0aWNrQ291bnQsXG4gICAgICAgIG1pblRpY2tDb3VudCxcbiAgICAgICAgbWF4VGlja0NvdW50LFxuICAgICAgICBwcmltYXJ5VGlja0NvdW50XG4gICAgICB9KTtcbiAgICAgIHRpY2tEYXRhLnJhd1RpY2tzID0gcmF3VGlja3M7XG4gICAgICB0aWNrRGF0YS5mcmFjdGlvbkRpZ2l0cyA9IGZyYWN0aW9uRGlnaXRzO1xuICAgICAgdGlja0RhdGEudGlja3MgPSB0aWNrcztcbiAgICAgIHRpY2tEYXRhLmxhYmVsQ291bnQgPSBsYWJlbENvdW50O1xuICAgICAgdW5jaGFuZ2VkID0gcmVnZW5lcmF0ZVRpY2tzID8gYXJlQXJyYXlOdW1iZXJzRXF1YWwocmF3VGlja3MsIHByZXZUaWNrcykgOiBmYWxzZTtcbiAgICAgIGluZGV4Kys7XG4gICAgfVxuICAgIGNvbnN0IHNob3VsZFRlcm1pbmF0ZSA9IHN0ZXAgIT09IHZvaWQgMCB8fCB2YWx1ZXMgIT09IHZvaWQgMDtcbiAgICB0ZXJtaW5hdGUgfHwgKHRlcm1pbmF0ZSA9IHNob3VsZFRlcm1pbmF0ZSk7XG4gICAgcmV0dXJuIHsgdGlja0RhdGEsIGluZGV4LCBhdXRvUm90YXRpb246IDAsIHRlcm1pbmF0ZSB9O1xuICB9XG4gIGNyZWF0ZUxhYmVsRGF0YSh0aWNrRGF0YSwgbGFiZWxYLCBsYWJlbE1hdHJpeCwgdGV4dE1lYXN1cmVyKSB7XG4gICAgY29uc3QgbGFiZWxEYXRhID0gW107XG4gICAgZm9yIChjb25zdCB7IHRpY2tMYWJlbCwgdHJhbnNsYXRpb25ZIH0gb2YgdGlja0RhdGEpIHtcbiAgICAgIGlmICghdGlja0xhYmVsKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IHsgd2lkdGg6IHdpZHRoMiwgaGVpZ2h0OiBoZWlnaHQyIH0gPSB0ZXh0TWVhc3VyZXIubWVhc3VyZUxpbmVzKHRpY2tMYWJlbCk7XG4gICAgICBjb25zdCBiYm94ID0gbmV3IEJCb3gobGFiZWxYLCB0cmFuc2xhdGlvblksIHdpZHRoMiwgaGVpZ2h0Mik7XG4gICAgICBjb25zdCBsYWJlbERhdHVtID0gY2FsY3VsYXRlTGFiZWxCQm94KHRpY2tMYWJlbCwgYmJveCwgbGFiZWxNYXRyaXgpO1xuICAgICAgbGFiZWxEYXRhLnB1c2gobGFiZWxEYXR1bSk7XG4gICAgfVxuICAgIHJldHVybiBsYWJlbERhdGE7XG4gIH1cbiAgZ2V0QXV0b1JvdGF0aW9uKGxhYmVsT3ZlcmxhcCkge1xuICAgIHJldHVybiBsYWJlbE92ZXJsYXAgPyBub3JtYWxpemVBbmdsZTM2MCh0b1JhZGlhbnModGhpcy5sYWJlbC5hdXRvUm90YXRlQW5nbGUgPz8gMCkpIDogMDtcbiAgfVxuICBnZXRUaWNrcyh7XG4gICAgdGlja0dlbmVyYXRpb25UeXBlLFxuICAgIHByZXZpb3VzVGlja3MsXG4gICAgdGlja0NvdW50LFxuICAgIG1pblRpY2tDb3VudCxcbiAgICBtYXhUaWNrQ291bnQsXG4gICAgcHJpbWFyeVRpY2tDb3VudFxuICB9KSB7XG4gICAgY29uc3QgeyByYW5nZTogcmFuZ2UzLCBzY2FsZTogc2NhbGUyLCB2aXNpYmxlUmFuZ2UgfSA9IHRoaXM7XG4gICAgbGV0IHJhd1RpY2tzO1xuICAgIHN3aXRjaCAodGlja0dlbmVyYXRpb25UeXBlKSB7XG4gICAgICBjYXNlIDMgLyogVkFMVUVTICovOlxuICAgICAgICByYXdUaWNrcyA9IHRoaXMuaW50ZXJ2YWwudmFsdWVzO1xuICAgICAgICBpZiAoQ29udGludW91c1NjYWxlLmlzKHNjYWxlMikpIHtcbiAgICAgICAgICBjb25zdCBbZDAsIGQxXSA9IGZpbmRNaW5NYXgoc2NhbGUyLmdldERvbWFpbigpLm1hcChOdW1iZXIpKTtcbiAgICAgICAgICByYXdUaWNrcyA9IHJhd1RpY2tzLmZpbHRlcigodmFsdWUpID0+IHZhbHVlID49IGQwICYmIHZhbHVlIDw9IGQxKS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEgLyogQ1JFQVRFX1NFQ09OREFSWSAqLzpcbiAgICAgICAgaWYgKENvbnRpbnVvdXNTY2FsZS5pcyhzY2FsZTIpKSB7XG4gICAgICAgICAgcmF3VGlja3MgPSB0aGlzLnVwZGF0ZVNlY29uZGFyeUF4aXNUaWNrcyhwcmltYXJ5VGlja0NvdW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByYXdUaWNrcyA9IHRoaXMuY3JlYXRlVGlja3ModGlja0NvdW50LCBtaW5UaWNrQ291bnQsIG1heFRpY2tDb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDIgLyogRklMVEVSICovOlxuICAgICAgICByYXdUaWNrcyA9IHRoaXMuZmlsdGVyVGlja3MocHJldmlvdXNUaWNrcywgdGlja0NvdW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByYXdUaWNrcyA9IHRoaXMuY3JlYXRlVGlja3ModGlja0NvdW50LCBtaW5UaWNrQ291bnQsIG1heFRpY2tDb3VudCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBmcmFjdGlvbkRpZ2l0cyA9IHJhd1RpY2tzLnJlZHVjZShcbiAgICAgIChtYXgsIHRpY2spID0+IE1hdGgubWF4KG1heCwgdHlwZW9mIHRpY2sgPT09IFwibnVtYmVyXCIgPyBjb3VudEZyYWN0aW9uRGlnaXRzKHRpY2spIDogMCksXG4gICAgICAwXG4gICAgKTtcbiAgICBjb25zdCBoYWxmQmFuZHdpZHRoID0gKHNjYWxlMi5iYW5kd2lkdGggPz8gMCkgLyAyO1xuICAgIGNvbnN0IHRpY2tzID0gW107XG4gICAgbGV0IGxhYmVsQ291bnQgPSAwO1xuICAgIGNvbnN0IHRpY2tJZENvdW50cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgY29uc3Qgc3RhcnQyID0gTWF0aC5tYXgoMCwgTWF0aC5mbG9vcih2aXNpYmxlUmFuZ2VbMF0gKiByYXdUaWNrcy5sZW5ndGgpKTtcbiAgICBjb25zdCBlbmQyID0gTWF0aC5taW4ocmF3VGlja3MubGVuZ3RoLCBNYXRoLmNlaWwodmlzaWJsZVJhbmdlWzFdICogcmF3VGlja3MubGVuZ3RoKSk7XG4gICAgY29uc3QgZmlsdGVyZWRUaWNrcyA9IHJhd1RpY2tzLnNsaWNlKHN0YXJ0MiwgZW5kMik7XG4gICAgdGhpcy5vbkZvcm1hdENoYW5nZShmaWx0ZXJlZFRpY2tzLCBmcmFjdGlvbkRpZ2l0cywgcmF3VGlja3MsIHRoaXMubGFiZWwuZm9ybWF0KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbHRlcmVkVGlja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHRpY2sgPSBmaWx0ZXJlZFRpY2tzW2ldO1xuICAgICAgY29uc3QgdHJhbnNsYXRpb25ZID0gc2NhbGUyLmNvbnZlcnQodGljaykgKyBoYWxmQmFuZHdpZHRoO1xuICAgICAgaWYgKHJhbmdlMy5sZW5ndGggPiAwICYmICF0aGlzLmluUmFuZ2UodHJhbnNsYXRpb25ZLCAxZS0zKSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCB0aWNrTGFiZWwgPSB0aGlzLmZvcm1hdFRpY2sodGljaywgZnJhY3Rpb25EaWdpdHMsIHN0YXJ0MiArIGkpO1xuICAgICAgbGV0IHRpY2tJZCA9IHRpY2tMYWJlbDtcbiAgICAgIGlmICh0aWNrSWRDb3VudHMuaGFzKHRpY2tJZCkpIHtcbiAgICAgICAgY29uc3QgY291bnQgPSB0aWNrSWRDb3VudHMuZ2V0KHRpY2tJZCk7XG4gICAgICAgIHRpY2tJZENvdW50cy5zZXQodGlja0lkLCBjb3VudCArIDEpO1xuICAgICAgICB0aWNrSWQgPSBgJHt0aWNrSWR9XyR7Y291bnR9YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpY2tJZENvdW50cy5zZXQodGlja0lkLCAxKTtcbiAgICAgIH1cbiAgICAgIHRpY2tzLnB1c2goeyB0aWNrLCB0aWNrSWQsIHRpY2tMYWJlbCwgdHJhbnNsYXRpb25ZOiBNYXRoLmZsb29yKHRyYW5zbGF0aW9uWSkgfSk7XG4gICAgICBpZiAodGlja0xhYmVsID09PSBcIlwiIHx8IHRpY2tMYWJlbCA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGFiZWxDb3VudCsrO1xuICAgIH1cbiAgICByZXR1cm4geyByYXdUaWNrcywgZnJhY3Rpb25EaWdpdHMsIHRpY2tzLCBsYWJlbENvdW50IH07XG4gIH1cbiAgZmlsdGVyVGlja3ModGlja3MsIHRpY2tDb3VudCkge1xuICAgIGNvbnN0IHsgbWluU3BhY2luZywgbWF4U3BhY2luZyB9ID0gdGhpcy5pbnRlcnZhbDtcbiAgICBjb25zdCB0aWNrU3BhY2luZyA9ICFpc05hTihtaW5TcGFjaW5nKSB8fCAhaXNOYU4obWF4U3BhY2luZyk7XG4gICAgY29uc3Qga2VlcEV2ZXJ5ID0gdGlja1NwYWNpbmcgPyBNYXRoLmNlaWwodGlja3MubGVuZ3RoIC8gdGlja0NvdW50KSA6IDI7XG4gICAgcmV0dXJuIHRpY2tzLmZpbHRlcigoXywgaSkgPT4gaSAlIGtlZXBFdmVyeSA9PT0gMCk7XG4gIH1cbiAgY3JlYXRlVGlja3ModGlja0NvdW50LCBtaW5UaWNrQ291bnQsIG1heFRpY2tDb3VudCkge1xuICAgIGNvbnN0IHsgc2NhbGU6IHNjYWxlMiB9ID0gdGhpcztcbiAgICBpZiAodGlja0NvdW50ICYmIChDb250aW51b3VzU2NhbGUuaXMoc2NhbGUyKSB8fCBPcmRpbmFsVGltZVNjYWxlLmlzKHNjYWxlMikpKSB7XG4gICAgICBzY2FsZTIudGlja0NvdW50ID0gdGlja0NvdW50O1xuICAgICAgc2NhbGUyLm1pblRpY2tDb3VudCA9IG1pblRpY2tDb3VudCA/PyAwO1xuICAgICAgc2NhbGUyLm1heFRpY2tDb3VudCA9IG1heFRpY2tDb3VudCA/PyBJbmZpbml0eTtcbiAgICB9XG4gICAgcmV0dXJuIHNjYWxlMi50aWNrcz8uKCkgPz8gW107XG4gIH1cbiAgZXN0aW1hdGVUaWNrQ291bnQoeyBtaW5TcGFjaW5nLCBtYXhTcGFjaW5nIH0pIHtcbiAgICBpZiAoIXRoaXMubGFiZWwuYXZvaWRDb2xsaXNpb25zKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtaW5UaWNrQ291bnQ6IENvbnRpbnVvdXNTY2FsZS5kZWZhdWx0TWF4VGlja0NvdW50LFxuICAgICAgICBtYXhUaWNrQ291bnQ6IENvbnRpbnVvdXNTY2FsZS5kZWZhdWx0TWF4VGlja0NvdW50LFxuICAgICAgICBkZWZhdWx0VGlja0NvdW50OiBDb250aW51b3VzU2NhbGUuZGVmYXVsdE1heFRpY2tDb3VudFxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcmFuZ2VXaXRoQmxlZWQgPSB0aGlzLmNhbGN1bGF0ZVJhbmdlV2l0aEJsZWVkKCk7XG4gICAgY29uc3QgZGVmYXVsdE1pblNwYWNpbmcgPSBNYXRoLm1heChcbiAgICAgIHRoaXMuZGVmYXVsdFRpY2tNaW5TcGFjaW5nLFxuICAgICAgcmFuZ2VXaXRoQmxlZWQgLyBDb250aW51b3VzU2NhbGUuZGVmYXVsdE1heFRpY2tDb3VudFxuICAgICk7XG4gICAgbGV0IGNsYW1wTWF4VGlja0NvdW50ID0gIWlzTmFOKG1heFNwYWNpbmcpO1xuICAgIGlmIChpc05hTihtaW5TcGFjaW5nKSkge1xuICAgICAgbWluU3BhY2luZyA9IGRlZmF1bHRNaW5TcGFjaW5nO1xuICAgIH1cbiAgICBpZiAoaXNOYU4obWF4U3BhY2luZykpIHtcbiAgICAgIG1heFNwYWNpbmcgPSByYW5nZVdpdGhCbGVlZDtcbiAgICB9XG4gICAgaWYgKG1pblNwYWNpbmcgPiBtYXhTcGFjaW5nKSB7XG4gICAgICBpZiAobWluU3BhY2luZyA9PT0gZGVmYXVsdE1pblNwYWNpbmcpIHtcbiAgICAgICAgbWluU3BhY2luZyA9IG1heFNwYWNpbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXhTcGFjaW5nID0gbWluU3BhY2luZztcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbWluUmVjdERpc3RhbmNlID0gMjtcbiAgICBjbGFtcE1heFRpY2tDb3VudCAmJiAoY2xhbXBNYXhUaWNrQ291bnQgPSBtaW5SZWN0RGlzdGFuY2UgPCBkZWZhdWx0TWluU3BhY2luZyk7XG4gICAgY29uc3QgbWF4VGlja0NvdW50ID0gY2xhbXAoXG4gICAgICAxLFxuICAgICAgTWF0aC5mbG9vcihyYW5nZVdpdGhCbGVlZCAvIG1pblNwYWNpbmcpLFxuICAgICAgY2xhbXBNYXhUaWNrQ291bnQgPyBNYXRoLm1pbihNYXRoLmZsb29yKHJhbmdlV2l0aEJsZWVkIC8gbWluUmVjdERpc3RhbmNlKSwgMTAwKSA6IDEwMFxuICAgICk7XG4gICAgY29uc3QgbWluVGlja0NvdW50ID0gTWF0aC5taW4obWF4VGlja0NvdW50LCBNYXRoLmNlaWwocmFuZ2VXaXRoQmxlZWQgLyBtYXhTcGFjaW5nKSk7XG4gICAgY29uc3QgZGVmYXVsdFRpY2tDb3VudCA9IGNsYW1wKG1pblRpY2tDb3VudCwgQ29udGludW91c1NjYWxlLmRlZmF1bHRUaWNrQ291bnQsIG1heFRpY2tDb3VudCk7XG4gICAgcmV0dXJuIHsgbWluVGlja0NvdW50LCBtYXhUaWNrQ291bnQsIGRlZmF1bHRUaWNrQ291bnQgfTtcbiAgfVxuICB1cGRhdGVWaXNpYmlsaXR5KCkge1xuICAgIGlmICh0aGlzLm1vZHVsZUN0eC5hbmltYXRpb25NYW5hZ2VyLmlzU2tpcHBlZCgpKSB7XG4gICAgICB0aGlzLnJlc2V0U2VsZWN0aW9uTm9kZXMoKTtcbiAgICB9XG4gICAgdGhpcy50aWNrTGluZUdyb3VwLnZpc2libGUgPSB0aGlzLnRpY2suZW5hYmxlZDtcbiAgICB0aGlzLmdyaWRMaW5lR3JvdXAudmlzaWJsZSA9IHRoaXMuZ3JpZExpbmUuZW5hYmxlZDtcbiAgICB0aGlzLnRpY2tMYWJlbEdyb3VwLnZpc2libGUgPSB0aGlzLmxhYmVsLmVuYWJsZWQ7XG4gIH1cbiAgdXBkYXRlQ3Jvc3NMaW5lcyh7XG4gICAgcm90YXRpb24sXG4gICAgcGFyYWxsZWxGbGlwUm90YXRpb24sXG4gICAgcmVndWxhckZsaXBSb3RhdGlvblxuICB9KSB7XG4gICAgY29uc3Qgc2lkZUZsYWcgPSB0aGlzLmxhYmVsLmdldFNpZGVGbGFnKCk7XG4gICAgY29uc3QgYW55U2VyaWVzQWN0aXZlID0gdGhpcy5pc0FueVNlcmllc0FjdGl2ZSgpO1xuICAgIHRoaXMuY3Jvc3NMaW5lcy5mb3JFYWNoKChjcm9zc0xpbmUpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNyb3NzTGluZS5zaWRlRmxhZyA9IC1zaWRlRmxhZztcbiAgICAgIGNyb3NzTGluZS5kaXJlY3Rpb24gPSByb3RhdGlvbiA9PT0gLU1hdGguUEkgLyAyID8gXCJ4XCIgLyogWCAqLyA6IFwieVwiIC8qIFkgKi87XG4gICAgICBpZiAoY3Jvc3NMaW5lIGluc3RhbmNlb2YgQ2FydGVzaWFuQ3Jvc3NMaW5lKSB7XG4gICAgICAgIChfYSA9IGNyb3NzTGluZS5sYWJlbCkucGFyYWxsZWwgPz8gKF9hLnBhcmFsbGVsID0gdGhpcy5sYWJlbC5wYXJhbGxlbCk7XG4gICAgICB9XG4gICAgICBjcm9zc0xpbmUucGFyYWxsZWxGbGlwUm90YXRpb24gPSBwYXJhbGxlbEZsaXBSb3RhdGlvbjtcbiAgICAgIGNyb3NzTGluZS5yZWd1bGFyRmxpcFJvdGF0aW9uID0gcmVndWxhckZsaXBSb3RhdGlvbjtcbiAgICAgIGNyb3NzTGluZS51cGRhdGUoYW55U2VyaWVzQWN0aXZlKTtcbiAgICB9KTtcbiAgfVxuICB1cGRhdGVUaWNrTGluZXMoKSB7XG4gICAgY29uc3QgeyB0aWNrLCBsYWJlbCB9ID0gdGhpcztcbiAgICBjb25zdCBzaWRlRmxhZyA9IGxhYmVsLmdldFNpZGVGbGFnKCk7XG4gICAgdGhpcy50aWNrTGluZUdyb3VwU2VsZWN0aW9uLmVhY2goKGxpbmUpID0+IHtcbiAgICAgIGxpbmUuc3Ryb2tlV2lkdGggPSB0aWNrLndpZHRoO1xuICAgICAgbGluZS5zdHJva2UgPSB0aWNrLnN0cm9rZTtcbiAgICAgIGxpbmUueDEgPSBzaWRlRmxhZyAqIHRoaXMuZ2V0VGlja1NpemUoKTtcbiAgICAgIGxpbmUueDIgPSAwO1xuICAgIH0pO1xuICB9XG4gIGNhbGN1bGF0ZUF2YWlsYWJsZVJhbmdlKCkge1xuICAgIHJldHVybiBmaW5kUmFuZ2VFeHRlbnQodGhpcy5yYW5nZSk7XG4gIH1cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIGF2YWlsYWJsZSByYW5nZSB3aXRoIGFuIGFkZGl0aW9uYWwgXCJibGVlZFwiIGJleW9uZCB0aGUgY2FudmFzIHRoYXQgZW5jb21wYXNzZXMgdGhlIGZ1bGwgYXhpcyB3aGVuXG4gICAqIHRoZSB2aXNpYmxlIHJhbmdlIGlzIG9ubHkgYSBwb3J0aW9uIG9mIHRoZSBheGlzLlxuICAgKi9cbiAgY2FsY3VsYXRlUmFuZ2VXaXRoQmxlZWQoKSB7XG4gICAgY29uc3QgdmlzaWJsZVNjYWxlID0gMSAvIGZpbmRSYW5nZUV4dGVudCh0aGlzLnZpc2libGVSYW5nZSk7XG4gICAgcmV0dXJuIHJvdW5kKHRoaXMuY2FsY3VsYXRlQXZhaWxhYmxlUmFuZ2UoKSAqIHZpc2libGVTY2FsZSwgMik7XG4gIH1cbiAgY2FsY3VsYXRlRG9tYWluKCkge1xuICAgIGNvbnN0IHZpc2libGVTZXJpZXMgPSB0aGlzLmJvdW5kU2VyaWVzLmZpbHRlcigocykgPT4gdGhpcy5pbmNsdWRlSW52aXNpYmxlRG9tYWlucyB8fCBzLmlzRW5hYmxlZCgpKTtcbiAgICBjb25zdCBkb21haW5zID0gdmlzaWJsZVNlcmllcy5mbGF0TWFwKChzZXJpZXMpID0+IHNlcmllcy5nZXREb21haW4odGhpcy5kaXJlY3Rpb24pKTtcbiAgICB0aGlzLnNldERvbWFpbihkb21haW5zKTtcbiAgfVxuICBnZXRBeGlzVHJhbnNmb3JtKCkge1xuICAgIHJldHVybiB7XG4gICAgICByb3RhdGlvbjogdG9SYWRpYW5zKHRoaXMucm90YXRpb24pLFxuICAgICAgdHJhbnNsYXRpb25YOiBNYXRoLmZsb29yKHRoaXMudHJhbnNsYXRpb24ueCksXG4gICAgICB0cmFuc2xhdGlvblk6IE1hdGguZmxvb3IodGhpcy50cmFuc2xhdGlvbi55KVxuICAgIH07XG4gIH1cbiAgdXBkYXRlUG9zaXRpb24oKSB7XG4gICAgY29uc3QgeyBjcm9zc0xpbmVHcm91cCwgYXhpc0dyb3VwLCBncmlkR3JvdXAsIHRyYW5zbGF0aW9uIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgcm90YXRpb24gfSA9IHRoaXMuY2FsY3VsYXRlUm90YXRpb25zKCk7XG4gICAgY29uc3QgdHJhbnNsYXRpb25YID0gTWF0aC5mbG9vcih0cmFuc2xhdGlvbi54KTtcbiAgICBjb25zdCB0cmFuc2xhdGlvblkgPSBNYXRoLmZsb29yKHRyYW5zbGF0aW9uLnkpO1xuICAgIGNyb3NzTGluZUdyb3VwLnNldFByb3BlcnRpZXMoeyByb3RhdGlvbiwgdHJhbnNsYXRpb25YLCB0cmFuc2xhdGlvblkgfSk7XG4gICAgZ3JpZEdyb3VwLnNldFByb3BlcnRpZXMoeyByb3RhdGlvbiwgdHJhbnNsYXRpb25YLCB0cmFuc2xhdGlvblkgfSk7XG4gICAgYXhpc0dyb3VwLmRhdHVtID0gdGhpcy5nZXRBeGlzVHJhbnNmb3JtKCk7XG4gIH1cbiAgdXBkYXRlU2Vjb25kYXJ5QXhpc1RpY2tzKF9wcmltYXJ5VGlja0NvdW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQUcgQ2hhcnRzIC0gdW5leHBlY3RlZCBjYWxsIHRvIHVwZGF0ZVNlY29uZGFyeUF4aXNUaWNrcygpIC0gY2hlY2sgYXhlcyBjb25maWd1cmF0aW9uLlwiKTtcbiAgfVxuICB1cGRhdGVTZWxlY3Rpb25zKGxpbmVEYXRhLCBkYXRhLCBwYXJhbXMpIHtcbiAgICBjb25zdCBnZXREYXR1bUlkID0gKGRhdHVtKSA9PiBkYXR1bS50aWNrSWQ7XG4gICAgY29uc3QgbGFiZWxzRGF0YSA9IGRhdGEubWFwKChkKSA9PiB0aGlzLmdldFRpY2tMYWJlbFByb3BzKGQsIHBhcmFtcykpO1xuICAgIHRoaXMubGluZU5vZGUuZGF0dW0gPSBsaW5lRGF0YTtcbiAgICB0aGlzLmdyaWRMaW5lR3JvdXBTZWxlY3Rpb24udXBkYXRlKHRoaXMuZ3JpZExlbmd0aCA/IGRhdGEgOiBbXSwgdm9pZCAwLCBnZXREYXR1bUlkKTtcbiAgICB0aGlzLnRpY2tMaW5lR3JvdXBTZWxlY3Rpb24udXBkYXRlKGRhdGEsIHZvaWQgMCwgZ2V0RGF0dW1JZCk7XG4gICAgdGhpcy50aWNrTGFiZWxHcm91cFNlbGVjdGlvbi51cGRhdGUobGFiZWxzRGF0YSwgdm9pZCAwLCBnZXREYXR1bUlkKTtcbiAgfVxuICB1cGRhdGVBeGlzTGluZSgpIHtcbiAgICBjb25zdCB7IGVuYWJsZWQsIHN0cm9rZSwgd2lkdGg6IHdpZHRoMiB9ID0gdGhpcy5saW5lO1xuICAgIHRoaXMubGluZU5vZGUuc2V0UHJvcGVydGllcyh7IHN0cm9rZSwgc3Ryb2tlV2lkdGg6IGVuYWJsZWQgPyB3aWR0aDIgOiAwIH0pO1xuICB9XG4gIHVwZGF0ZUdyaWRMaW5lcyhzaWRlRmxhZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGdyaWRMaW5lOiB7IHN0eWxlLCB3aWR0aDogd2lkdGgyIH0sXG4gICAgICBncmlkUGFkZGluZyxcbiAgICAgIGdyaWRMZW5ndGhcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoZ3JpZExlbmd0aCA9PT0gMCB8fCBzdHlsZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5ncmlkTGluZUdyb3VwU2VsZWN0aW9uLmVhY2goKGxpbmUsIF8sIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCB7IHN0cm9rZSwgbGluZURhc2ggfSA9IHN0eWxlW2luZGV4ICUgc3R5bGUubGVuZ3RoXTtcbiAgICAgIGxpbmUuc2V0UHJvcGVydGllcyh7XG4gICAgICAgIHgxOiBncmlkUGFkZGluZyxcbiAgICAgICAgeDI6IC1zaWRlRmxhZyAqIGdyaWRMZW5ndGggKyBncmlkUGFkZGluZyxcbiAgICAgICAgc3Ryb2tlLFxuICAgICAgICBzdHJva2VXaWR0aDogd2lkdGgyLFxuICAgICAgICBsaW5lRGFzaFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlTGFiZWxzKCkge1xuICAgIGlmICghdGhpcy5sYWJlbC5lbmFibGVkKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMudGlja0xhYmVsR3JvdXBTZWxlY3Rpb24uZWFjaCgobm9kZSwgZGF0dW0pID0+IHtcbiAgICAgIG5vZGUuc2V0UHJvcGVydGllcyhkYXR1bSwgW1xuICAgICAgICBcImZpbGxcIixcbiAgICAgICAgXCJmb250RmFtaWx5XCIsXG4gICAgICAgIFwiZm9udFNpemVcIixcbiAgICAgICAgXCJmb250U3R5bGVcIixcbiAgICAgICAgXCJmb250V2VpZ2h0XCIsXG4gICAgICAgIFwidGV4dFwiLFxuICAgICAgICBcInRleHRBbGlnblwiLFxuICAgICAgICBcInRleHRCYXNlbGluZVwiXG4gICAgICBdKTtcbiAgICB9KTtcbiAgfVxuICB1cGRhdGVUaXRsZShwYXJhbXMpIHtcbiAgICBjb25zdCB7IHRpdGxlLCBsaW5lTm9kZSwgdGlja0xpbmVHcm91cCwgdGlja0xhYmVsR3JvdXAgfSA9IHRoaXM7XG4gICAgbGV0IHNwYWNpbmcgPSAwO1xuICAgIGlmICh0aXRsZS5lbmFibGVkICYmIHBhcmFtcy5hbnlUaWNrVmlzaWJsZSkge1xuICAgICAgY29uc3QgdGlja0JCb3ggPSBHcm91cC5jb21wdXRlQ2hpbGRyZW5CQm94KFt0aWNrTGluZUdyb3VwLCB0aWNrTGFiZWxHcm91cCwgbGluZU5vZGVdKTtcbiAgICAgIHNwYWNpbmcgKz0gdGlja0JCb3gud2lkdGggKyAodGhpcy50aWNrTGFiZWxHcm91cC52aXNpYmxlID8gMCA6IHRoaXMuc2VyaWVzQXJlYVBhZGRpbmcpO1xuICAgIH1cbiAgICB0aGlzLnNldFRpdGxlUHJvcHModGl0bGUuY2FwdGlvbiwgeyBzcGFjaW5nIH0pO1xuICB9XG4gIC8vIEZvciBmb3JtYXR0aW5nIChuaWNlIHJvdW5kZWQpIHRpY2sgdmFsdWVzLlxuICBmb3JtYXRUaWNrKGRhdHVtLCBmcmFjdGlvbkRpZ2l0cywgaW5kZXgpIHtcbiAgICByZXR1cm4gU3RyaW5nKHRoaXMuZ2V0Rm9ybWF0dGVyKGluZGV4LCB0cnVlKShkYXR1bSwgZnJhY3Rpb25EaWdpdHMpKTtcbiAgfVxuICAvLyBGb3IgZm9ybWF0dGluZyBhcmJpdHJhcnkgdmFsdWVzIGJldHdlZW4gdGhlIHRpY2tzLlxuICBmb3JtYXREYXR1bShkYXR1bSkge1xuICAgIHJldHVybiBTdHJpbmcodGhpcy5nZXRGb3JtYXR0ZXIoKShkYXR1bSkpO1xuICB9XG4gIGdldEZvcm1hdHRlcihpbmRleCA9IDAsIGlzVGlja0xhYmVsKSB7XG4gICAgY29uc3Qge1xuICAgICAgbGFiZWwsXG4gICAgICBsYWJlbEZvcm1hdHRlcixcbiAgICAgIGRhdHVtRm9ybWF0dGVyLFxuICAgICAgbW9kdWxlQ3R4OiB7IGNhbGxiYWNrQ2FjaGUgfVxuICAgIH0gPSB0aGlzO1xuICAgIGlmIChsYWJlbC5mb3JtYXR0ZXIpIHtcbiAgICAgIHJldHVybiAoZGF0dW0sIGZyYWN0aW9uRGlnaXRzKSA9PiBjYWxsYmFja0NhY2hlLmNhbGwobGFiZWwuZm9ybWF0dGVyLCB7IHZhbHVlOiBkYXR1bSwgaW5kZXgsIGZyYWN0aW9uRGlnaXRzIH0pID8/IGRhdHVtO1xuICAgIH0gZWxzZSBpZiAoIWlzVGlja0xhYmVsICYmIGRhdHVtRm9ybWF0dGVyKSB7XG4gICAgICByZXR1cm4gKGRhdHVtKSA9PiBjYWxsYmFja0NhY2hlLmNhbGwoZGF0dW1Gb3JtYXR0ZXIsIGRhdHVtKSA/PyBTdHJpbmcoZGF0dW0pO1xuICAgIH0gZWxzZSBpZiAobGFiZWxGb3JtYXR0ZXIpIHtcbiAgICAgIHJldHVybiAoZGF0dW0pID0+IGNhbGxiYWNrQ2FjaGUuY2FsbChsYWJlbEZvcm1hdHRlciwgZGF0dW0pID8/IFN0cmluZyhkYXR1bSk7XG4gICAgfVxuICAgIHJldHVybiAoZGF0dW0pID0+IFN0cmluZyhkYXR1bSk7XG4gIH1cbiAgZ2V0QkJveCgpIHtcbiAgICByZXR1cm4gdGhpcy5heGlzR3JvdXAuZ2V0QkJveCgpO1xuICB9XG4gIGdldFJlZ2lvbk5vZGUoKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBpbml0Q3Jvc3NMaW5lKGNyb3NzTGluZSkge1xuICAgIGNyb3NzTGluZS5zY2FsZSA9IHRoaXMuc2NhbGU7XG4gICAgY3Jvc3NMaW5lLmdyaWRMZW5ndGggPSB0aGlzLmdyaWRMZW5ndGg7XG4gIH1cbiAgaXNBbnlTZXJpZXNBY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuYm91bmRTZXJpZXMuc29tZSgocykgPT4gdGhpcy5pbmNsdWRlSW52aXNpYmxlRG9tYWlucyB8fCBzLmlzRW5hYmxlZCgpKTtcbiAgfVxuICBjbGlwVGlja0xpbmVzKHgsIHksIHdpZHRoMiwgaGVpZ2h0Mikge1xuICAgIHRoaXMudGlja0xpbmVHcm91cC5zZXRDbGlwUmVjdChuZXcgQkJveCh4LCB5LCB3aWR0aDIsIGhlaWdodDIpKTtcbiAgfVxuICBjbGlwR3JpZCh4LCB5LCB3aWR0aDIsIGhlaWdodDIpIHtcbiAgICB0aGlzLmdyaWRHcm91cC5zZXRDbGlwUmVjdChuZXcgQkJveCh4LCB5LCB3aWR0aDIsIGhlaWdodDIpKTtcbiAgfVxuICBnZXRUaXRsZUZvcm1hdHRlclBhcmFtcygpIHtcbiAgICBjb25zdCB7IGRpcmVjdGlvbiB9ID0gdGhpcztcbiAgICBjb25zdCBib3VuZFNlcmllcyA9IFtdO1xuICAgIGZvciAoY29uc3Qgc2VyaWVzIG9mIHRoaXMuYm91bmRTZXJpZXMpIHtcbiAgICAgIGNvbnN0IGtleXMgPSBzZXJpZXMuZ2V0S2V5cyhkaXJlY3Rpb24pO1xuICAgICAgY29uc3QgbmFtZXMgPSBzZXJpZXMuZ2V0TmFtZXMoZGlyZWN0aW9uKTtcbiAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGtleXMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICBib3VuZFNlcmllcy5wdXNoKHsga2V5OiBrZXlzW2lkeF0sIG5hbWU6IG5hbWVzW2lkeF0gfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGRpcmVjdGlvbiwgYm91bmRTZXJpZXMsIGRlZmF1bHRWYWx1ZTogdGhpcy50aXRsZT8udGV4dCB9O1xuICB9XG4gIG5vcm1hbGlzZURhdGFEb21haW4oZCkge1xuICAgIHJldHVybiB7IGRvbWFpbjogWy4uLmRdLCBjbGlwcGVkOiBmYWxzZSB9O1xuICB9XG4gIGdldExheW91dFN0YXRlKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpZDogdGhpcy5pZCxcbiAgICAgIHJlY3Q6IHRoaXMuZ2V0QkJveCgpLFxuICAgICAgZ3JpZFBhZGRpbmc6IHRoaXMuZ3JpZFBhZGRpbmcsXG4gICAgICBzZXJpZXNBcmVhUGFkZGluZzogdGhpcy5zZXJpZXNBcmVhUGFkZGluZyxcbiAgICAgIHRpY2tTaXplOiB0aGlzLmdldFRpY2tTaXplKCksXG4gICAgICBkaXJlY3Rpb246IHRoaXMuZGlyZWN0aW9uLFxuICAgICAgZG9tYWluOiB0aGlzLmRhdGFEb21haW4uZG9tYWluLFxuICAgICAgc2NhbGU6IHRoaXMuc2NhbGUsXG4gICAgICAuLi50aGlzLmxheW91dFxuICAgIH07XG4gIH1cbiAgZ2V0TW9kdWxlTWFwKCkge1xuICAgIHJldHVybiB0aGlzLm1vZHVsZU1hcDtcbiAgfVxuICBjcmVhdGVNb2R1bGVDb250ZXh0KCkge1xuICAgIHRoaXMuYXhpc0NvbnRleHQgPz8gKHRoaXMuYXhpc0NvbnRleHQgPSB0aGlzLmNyZWF0ZUF4aXNDb250ZXh0KCkpO1xuICAgIHJldHVybiB7IC4uLnRoaXMubW9kdWxlQ3R4LCBwYXJlbnQ6IHRoaXMuYXhpc0NvbnRleHQgfTtcbiAgfVxuICBjcmVhdGVBeGlzQ29udGV4dCgpIHtcbiAgICBjb25zdCB7IHNjYWxlOiBzY2FsZTIgfSA9IHRoaXM7XG4gICAgcmV0dXJuIHtcbiAgICAgIGF4aXNJZDogdGhpcy5pZCxcbiAgICAgIHNjYWxlOiB0aGlzLnNjYWxlLFxuICAgICAgZGlyZWN0aW9uOiB0aGlzLmRpcmVjdGlvbixcbiAgICAgIGNvbnRpbnVvdXM6IENvbnRpbnVvdXNTY2FsZS5pcyhzY2FsZTIpIHx8IE9yZGluYWxUaW1lU2NhbGUuaXMoc2NhbGUyKSxcbiAgICAgIGtleXM6ICgpID0+IHRoaXMuYm91bmRTZXJpZXMuZmxhdE1hcCgocykgPT4gcy5nZXRLZXlzKHRoaXMuZGlyZWN0aW9uKSksXG4gICAgICBzZXJpZXNLZXlQcm9wZXJ0aWVzOiAoKSA9PiB0aGlzLmJvdW5kU2VyaWVzLnJlZHVjZSgoa2V5cywgc2VyaWVzKSA9PiB7XG4gICAgICAgIGNvbnN0IHNlcmllc0tleXMgPSBzZXJpZXMuZ2V0S2V5UHJvcGVydGllcyh0aGlzLmRpcmVjdGlvbik7XG4gICAgICAgIHNlcmllc0tleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgaWYgKGtleXMuaW5kZXhPZihrZXkpIDwgMCkge1xuICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgICB9LCBbXSksXG4gICAgICBzY2FsZVZhbHVlRm9ybWF0dGVyOiAoc3BlY2lmaWVyKSA9PiB0aGlzLmdldFNjYWxlVmFsdWVGb3JtYXR0ZXIoc3BlY2lmaWVyKSxcbiAgICAgIHNjYWxlQmFuZHdpZHRoOiAoKSA9PiBzY2FsZTIuYmFuZHdpZHRoID8/IDAsXG4gICAgICBzY2FsZURvbWFpbjogKCkgPT4gc2NhbGUyLmdldERvbWFpbj8uKCksXG4gICAgICBzY2FsZUNvbnZlcnQ6ICh2YWwpID0+IHNjYWxlMi5jb252ZXJ0KHZhbCksXG4gICAgICBzY2FsZUludmVydDogT3JkaW5hbFRpbWVTY2FsZS5pcyhzY2FsZTIpID8gKHZhbCkgPT4gc2NhbGUyLmludmVydE5lYXJlc3Q/Lih2YWwpIDogKHZhbCkgPT4gc2NhbGUyLmludmVydD8uKHZhbCksXG4gICAgICBzY2FsZUludmVydE5lYXJlc3Q6ICh2YWwpID0+IHNjYWxlMi5pbnZlcnROZWFyZXN0Py4odmFsKSxcbiAgICAgIHNjYWxlU3RlcDogKCkgPT4gc2NhbGUyLnN0ZXAgPz8gMCxcbiAgICAgIGF0dGFjaExhYmVsOiAobm9kZSkgPT4gdGhpcy5hdHRhY2hMYWJlbChub2RlKSxcbiAgICAgIGluUmFuZ2U6ICh4LCB0b2xlcmFuY2UpID0+IHRoaXMuaW5SYW5nZSh4LCB0b2xlcmFuY2UpXG4gICAgfTtcbiAgfVxuICBnZXRTY2FsZVZhbHVlRm9ybWF0dGVyKGZvcm1hdCkge1xuICAgIGNvbnN0IHsgc2NhbGU6IHNjYWxlMiB9ID0gdGhpcztcbiAgICBpZiAoZm9ybWF0ICYmIHNjYWxlMiAmJiBzY2FsZTIudGlja0Zvcm1hdCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHNjYWxlMi50aWNrRm9ybWF0KHsgc3BlY2lmaWVyOiBmb3JtYXQgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIExvZ2dlci53YXJuT25jZShgdGhlIGZvcm1hdCBzdHJpbmcgJHtmb3JtYXR9IGlzIGludmFsaWQsIGlnbm9yaW5nLmApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRGb3JtYXR0ZXIoKTtcbiAgfVxuICBhbmltYXRlUmVhZHlVcGRhdGUoZGlmZjIpIHtcbiAgICBjb25zdCB7IGFuaW1hdGlvbk1hbmFnZXIgfSA9IHRoaXMubW9kdWxlQ3R4O1xuICAgIGNvbnN0IHNlbGVjdGlvbkN0eCA9IHByZXBhcmVBeGlzQW5pbWF0aW9uQ29udGV4dCh0aGlzKTtcbiAgICBjb25zdCBmbnMgPSBwcmVwYXJlQXhpc0FuaW1hdGlvbkZ1bmN0aW9ucyhzZWxlY3Rpb25DdHgpO1xuICAgIGZyb21Ub01vdGlvbih0aGlzLmlkLCBcImF4aXMtZ3JvdXBcIiwgYW5pbWF0aW9uTWFuYWdlciwgW3RoaXMuYXhpc0dyb3VwXSwgZm5zLmdyb3VwKTtcbiAgICBmcm9tVG9Nb3Rpb24odGhpcy5pZCwgXCJsaW5lXCIsIGFuaW1hdGlvbk1hbmFnZXIsIFt0aGlzLmxpbmVOb2RlXSwgZm5zLmxpbmUpO1xuICAgIGZyb21Ub01vdGlvbihcbiAgICAgIHRoaXMuaWQsXG4gICAgICBcImxpbmUtcGF0aHNcIixcbiAgICAgIGFuaW1hdGlvbk1hbmFnZXIsXG4gICAgICBbdGhpcy5ncmlkTGluZUdyb3VwU2VsZWN0aW9uLCB0aGlzLnRpY2tMaW5lR3JvdXBTZWxlY3Rpb25dLFxuICAgICAgZm5zLnRpY2ssXG4gICAgICAoXywgZCkgPT4gZC50aWNrSWQsXG4gICAgICBkaWZmMlxuICAgICk7XG4gICAgZnJvbVRvTW90aW9uKFxuICAgICAgdGhpcy5pZCxcbiAgICAgIFwidGljay1sYWJlbHNcIixcbiAgICAgIGFuaW1hdGlvbk1hbmFnZXIsXG4gICAgICBbdGhpcy50aWNrTGFiZWxHcm91cFNlbGVjdGlvbl0sXG4gICAgICBmbnMubGFiZWwsXG4gICAgICAoXywgZCkgPT4gZC50aWNrSWQsXG4gICAgICBkaWZmMlxuICAgICk7XG4gIH1cbiAgcmVzZXRTZWxlY3Rpb25Ob2RlcygpIHtcbiAgICBjb25zdCB7IGdyaWRMaW5lR3JvdXBTZWxlY3Rpb24sIHRpY2tMaW5lR3JvdXBTZWxlY3Rpb24sIHRpY2tMYWJlbEdyb3VwU2VsZWN0aW9uLCBsaW5lTm9kZSB9ID0gdGhpcztcbiAgICBjb25zdCBzZWxlY3Rpb25DdHggPSBwcmVwYXJlQXhpc0FuaW1hdGlvbkNvbnRleHQodGhpcyk7XG4gICAgcmVzZXRNb3Rpb24oW3RoaXMuYXhpc0dyb3VwXSwgcmVzZXRBeGlzR3JvdXBGbigpKTtcbiAgICByZXNldE1vdGlvbihbZ3JpZExpbmVHcm91cFNlbGVjdGlvbiwgdGlja0xpbmVHcm91cFNlbGVjdGlvbl0sIHJlc2V0QXhpc1NlbGVjdGlvbkZuKHNlbGVjdGlvbkN0eCkpO1xuICAgIHJlc2V0TW90aW9uKFt0aWNrTGFiZWxHcm91cFNlbGVjdGlvbl0sIHJlc2V0QXhpc0xhYmVsU2VsZWN0aW9uRm4oKSk7XG4gICAgcmVzZXRNb3Rpb24oW2xpbmVOb2RlXSwgcmVzZXRBeGlzTGluZVNlbGVjdGlvbkZuKCkpO1xuICB9XG4gIGNhbGN1bGF0ZVVwZGF0ZURpZmYocHJldmlvdXMsIHRpY2tEYXRhKSB7XG4gICAgY29uc3QgYWRkZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGNvbnN0IHJlbW92ZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGNvbnN0IHRpY2tNYXAgPSB7fTtcbiAgICBjb25zdCB0aWNrQ291bnQgPSBNYXRoLm1heChwcmV2aW91cy5sZW5ndGgsIHRpY2tEYXRhLnRpY2tzLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aWNrQ291bnQ7IGkrKykge1xuICAgICAgY29uc3QgdGlja0RhdHVtID0gdGlja0RhdGEudGlja3NbaV07XG4gICAgICBjb25zdCBwcmV2ID0gcHJldmlvdXNbaV07XG4gICAgICBjb25zdCB0aWNrID0gdGlja0RhdHVtPy50aWNrSWQ7XG4gICAgICB0aWNrTWFwW3RpY2sgPz8gcHJldl0gPSB0aWNrRGF0dW07XG4gICAgICBpZiAocHJldiA9PT0gdGljaykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChyZW1vdmVkLmhhcyh0aWNrKSkge1xuICAgICAgICByZW1vdmVkLmRlbGV0ZSh0aWNrKTtcbiAgICAgIH0gZWxzZSBpZiAodGljaykge1xuICAgICAgICBhZGRlZC5hZGQodGljayk7XG4gICAgICB9XG4gICAgICBpZiAoYWRkZWQuaGFzKHByZXYpKSB7XG4gICAgICAgIGFkZGVkLmRlbGV0ZShwcmV2KTtcbiAgICAgIH0gZWxzZSBpZiAocHJldikge1xuICAgICAgICByZW1vdmVkLmFkZChwcmV2KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgY2hhbmdlZDogYWRkZWQuc2l6ZSA+IDAgfHwgcmVtb3ZlZC5zaXplID4gMCwgYWRkZWQsIHJlbW92ZWQgfTtcbiAgfVxuICBpc1JldmVyc2VkKCkge1xuICAgIHJldHVybiB0aGlzLnJldmVyc2U7XG4gIH1cbn07XG5fQXhpcy5kZWZhdWx0VGlja01pblNwYWNpbmcgPSA1MDtcbl9BeGlzLkNyb3NzTGluZUNvbnN0cnVjdG9yID0gQ2FydGVzaWFuQ3Jvc3NMaW5lO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIF9BeGlzLnByb3RvdHlwZSwgXCJuaWNlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIF9BeGlzLnByb3RvdHlwZSwgXCJyZXZlcnNlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HX0FSUkFZKVxuXSwgX0F4aXMucHJvdG90eXBlLCBcImtleXNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBfQXhpcy5wcm90b3R5cGUsIFwiaW50ZXJ2YWxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBfQXhpcy5wcm90b3R5cGUsIFwidGl0bGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBPYnNlcnZlQ2hhbmdlcygodGFyZ2V0LCB2YWx1ZSwgb2xkVmFsdWUpID0+IHRhcmdldC5vbkdyaWRMZW5ndGhDaGFuZ2UodmFsdWUsIG9sZFZhbHVlKSlcbl0sIF9BeGlzLnByb3RvdHlwZSwgXCJncmlkTGVuZ3RoXCIsIDIpO1xudmFyIEF4aXMgPSBfQXhpcztcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvYXhpcy9jYXJ0ZXNpYW5BeGlzTGFiZWwudHNcbnZhciBDYXJ0ZXNpYW5BeGlzTGFiZWwgPSBjbGFzcyBleHRlbmRzIEF4aXNMYWJlbCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5hdXRvUm90YXRlQW5nbGUgPSAzMzU7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBDYXJ0ZXNpYW5BeGlzTGFiZWwucHJvdG90eXBlLCBcImF1dG9Sb3RhdGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShERUdSRUUpXG5dLCBDYXJ0ZXNpYW5BeGlzTGFiZWwucHJvdG90eXBlLCBcImF1dG9Sb3RhdGVBbmdsZVwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvYXhpcy9jYXJ0ZXNpYW5BeGlzLnRzXG52YXIgX0NhcnRlc2lhbkF4aXMgPSBjbGFzcyBfQ2FydGVzaWFuQXhpcyBleHRlbmRzIEF4aXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudGhpY2tuZXNzID0gMDtcbiAgfVxuICBzdGF0aWMgaXModmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBfQ2FydGVzaWFuQXhpcztcbiAgfVxuICBnZXQgZGlyZWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnBvc2l0aW9uID09PSBcInRvcFwiIHx8IHRoaXMucG9zaXRpb24gPT09IFwiYm90dG9tXCIgPyBcInhcIiAvKiBYICovIDogXCJ5XCIgLyogWSAqLztcbiAgfVxuICB1cGRhdGVEaXJlY3Rpb24oKSB7XG4gICAgc3dpdGNoICh0aGlzLnBvc2l0aW9uKSB7XG4gICAgICBjYXNlIFwidG9wXCI6XG4gICAgICAgIHRoaXMucm90YXRpb24gPSAtOTA7XG4gICAgICAgIHRoaXMubGFiZWwubWlycm9yZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmxhYmVsLnBhcmFsbGVsID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgdGhpcy5yb3RhdGlvbiA9IDA7XG4gICAgICAgIHRoaXMubGFiZWwubWlycm9yZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmxhYmVsLnBhcmFsbGVsID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgICB0aGlzLnJvdGF0aW9uID0gLTkwO1xuICAgICAgICB0aGlzLmxhYmVsLm1pcnJvcmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGFiZWwucGFyYWxsZWwgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICAgIHRoaXMucm90YXRpb24gPSAwO1xuICAgICAgICB0aGlzLmxhYmVsLm1pcnJvcmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGFiZWwucGFyYWxsZWwgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICh0aGlzLmF4aXNDb250ZXh0KSB7XG4gICAgICB0aGlzLmF4aXNDb250ZXh0LnBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgIHRoaXMuYXhpc0NvbnRleHQuZGlyZWN0aW9uID0gdGhpcy5kaXJlY3Rpb247XG4gICAgfVxuICB9XG4gIHVwZGF0ZShhbmltYXRlZCkge1xuICAgIHRoaXMudXBkYXRlRGlyZWN0aW9uKCk7XG4gICAgcmV0dXJuIHN1cGVyLnVwZGF0ZShhbmltYXRlZCk7XG4gIH1cbiAgY2FsY3VsYXRlTGF5b3V0KGRvbWFpbiwgcHJpbWFyeVRpY2tDb3VudCkge1xuICAgIHRoaXMudXBkYXRlRGlyZWN0aW9uKCk7XG4gICAgcmV0dXJuIHN1cGVyLmNhbGN1bGF0ZUxheW91dChkb21haW4sIHByaW1hcnlUaWNrQ291bnQpO1xuICB9XG4gIGNyZWF0ZUF4aXNDb250ZXh0KCkge1xuICAgIHJldHVybiB7IC4uLnN1cGVyLmNyZWF0ZUF4aXNDb250ZXh0KCksIHBvc2l0aW9uOiB0aGlzLnBvc2l0aW9uIH07XG4gIH1cbiAgY3JlYXRlTGFiZWwoKSB7XG4gICAgcmV0dXJuIG5ldyBDYXJ0ZXNpYW5BeGlzTGFiZWwoKTtcbiAgfVxuICBnZXRSZWdpb25Ob2RlKCkge1xuICAgIHJldHVybiB0aGlzLmF4aXNHcm91cDtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIF9DYXJ0ZXNpYW5BeGlzLnByb3RvdHlwZSwgXCJ0aGlja25lc3NcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElPTilcbl0sIF9DYXJ0ZXNpYW5BeGlzLnByb3RvdHlwZSwgXCJwb3NpdGlvblwiLCAyKTtcbnZhciBDYXJ0ZXNpYW5BeGlzID0gX0NhcnRlc2lhbkF4aXM7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2F4aXMvY2F0ZWdvcnlBeGlzLnRzXG52YXIgX0NhdGVnb3J5QXhpcyA9IGNsYXNzIF9DYXRlZ29yeUF4aXMgZXh0ZW5kcyBDYXJ0ZXNpYW5BeGlzIHtcbiAgY29uc3RydWN0b3IobW9kdWxlQ3R4LCBzY2FsZTIgPSBuZXcgQmFuZFNjYWxlKCkpIHtcbiAgICBzdXBlcihtb2R1bGVDdHgsIHNjYWxlMik7XG4gICAgdGhpcy5ncm91cFBhZGRpbmdJbm5lciA9IDAuMTtcbiAgICB0aGlzLmluY2x1ZGVJbnZpc2libGVEb21haW5zID0gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgaXModmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBfQ2F0ZWdvcnlBeGlzO1xuICB9XG4gIG5vcm1hbGlzZURhdGFEb21haW4oZCkge1xuICAgIGNvbnN0IGRvbWFpbiA9IFtdO1xuICAgIGNvbnN0IHVuaXF1ZVZhbHVlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCB2IG9mIGQpIHtcbiAgICAgIGNvbnN0IGtleSA9IHYgaW5zdGFuY2VvZiBEYXRlID8gdi5nZXRUaW1lKCkgOiB2O1xuICAgICAgaWYgKCF1bmlxdWVWYWx1ZXMuaGFzKGtleSkpIHtcbiAgICAgICAgdW5pcXVlVmFsdWVzLmFkZChrZXkpO1xuICAgICAgICBkb21haW4ucHVzaCh2KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgZG9tYWluLCBjbGlwcGVkOiBmYWxzZSB9O1xuICB9XG4gIHVwZGF0ZVNjYWxlKGRvbWFpbikge1xuICAgIGxldCB7IHBhZGRpbmdJbm5lciwgcGFkZGluZ091dGVyIH0gPSB0aGlzO1xuICAgIGlmICghaXNGaW5pdGVOdW1iZXIocGFkZGluZ0lubmVyKSB8fCAhaXNGaW5pdGVOdW1iZXIocGFkZGluZ091dGVyKSkge1xuICAgICAgY29uc3QgcGFkZGluZyA9IHRoaXMucmVkdWNlQmFuZFNjYWxlUGFkZGluZygpO1xuICAgICAgcGFkZGluZ0lubmVyID8/IChwYWRkaW5nSW5uZXIgPSBwYWRkaW5nLmlubmVyKTtcbiAgICAgIHBhZGRpbmdPdXRlciA/PyAocGFkZGluZ091dGVyID0gcGFkZGluZy5vdXRlcik7XG4gICAgfVxuICAgIHRoaXMuc2NhbGUucGFkZGluZ0lubmVyID0gcGFkZGluZ0lubmVyID8/IDA7XG4gICAgdGhpcy5zY2FsZS5wYWRkaW5nT3V0ZXIgPSBwYWRkaW5nT3V0ZXIgPz8gMDtcbiAgICBzdXBlci51cGRhdGVTY2FsZShkb21haW4pO1xuICB9XG4gIHJlZHVjZUJhbmRTY2FsZVBhZGRpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuYm91bmRTZXJpZXMucmVkdWNlKFxuICAgICAgKHJlc3VsdCwgc2VyaWVzKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhZGRpbmcgPSBzZXJpZXMuZ2V0QmFuZFNjYWxlUGFkZGluZz8uKCk7XG4gICAgICAgIGlmIChwYWRkaW5nKSB7XG4gICAgICAgICAgaWYgKHJlc3VsdC5pbm5lciA+IHBhZGRpbmcuaW5uZXIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5pbm5lciA9IHBhZGRpbmcuaW5uZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQub3V0ZXIgPCBwYWRkaW5nLm91dGVyKSB7XG4gICAgICAgICAgICByZXN1bHQub3V0ZXIgPSBwYWRkaW5nLm91dGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSxcbiAgICAgIHsgaW5uZXI6IEluZmluaXR5LCBvdXRlcjogLUluZmluaXR5IH1cbiAgICApO1xuICB9XG59O1xuX0NhdGVnb3J5QXhpcy5jbGFzc05hbWUgPSBcIkNhdGVnb3J5QXhpc1wiO1xuX0NhdGVnb3J5QXhpcy50eXBlID0gXCJjYXRlZ29yeVwiO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8pXG5dLCBfQ2F0ZWdvcnlBeGlzLnByb3RvdHlwZSwgXCJncm91cFBhZGRpbmdJbm5lclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBfQ2F0ZWdvcnlBeGlzLnByb3RvdHlwZSwgXCJwYWRkaW5nSW5uZXJcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgX0NhdGVnb3J5QXhpcy5wcm90b3R5cGUsIFwicGFkZGluZ091dGVyXCIsIDIpO1xudmFyIENhdGVnb3J5QXhpcyA9IF9DYXRlZ29yeUF4aXM7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2F4aXMvdHJlZS50c1xudmFyIFRyZWVOb2RlID0gY2xhc3Mge1xuICAvLyBjdXJyZW50IG51bWJlciBpbiBzaWJsaW5nIGdyb3VwIChpbmRleClcbiAgY29uc3RydWN0b3IobGFiZWwgPSBcIlwiLCBwYXJlbnQsIG51bWJlcjIgPSAwKSB7XG4gICAgdGhpcy54ID0gMDtcbiAgICB0aGlzLnkgPSAwO1xuICAgIHRoaXMuc3VidHJlZUxlZnQgPSBOYU47XG4gICAgdGhpcy5zdWJ0cmVlUmlnaHQgPSBOYU47XG4gICAgdGhpcy5zY3JlZW5YID0gMDtcbiAgICB0aGlzLnNjcmVlblkgPSAwO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICB0aGlzLmxlYWZDb3VudCA9IDA7XG4gICAgdGhpcy5wcmVsaW0gPSAwO1xuICAgIHRoaXMubW9kID0gMDtcbiAgICB0aGlzLmFuY2VzdG9yID0gdGhpcztcbiAgICB0aGlzLmNoYW5nZSA9IDA7XG4gICAgdGhpcy5zaGlmdCA9IDA7XG4gICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMuZGVwdGggPSBwYXJlbnQgPyBwYXJlbnQuZGVwdGggKyAxIDogMDtcbiAgICB0aGlzLm51bWJlciA9IG51bWJlcjI7XG4gIH1cbiAgZ2V0TGVmdFNpYmxpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubnVtYmVyID4gMCAmJiB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LmNoaWxkcmVuW3RoaXMubnVtYmVyIC0gMV0gOiB2b2lkIDA7XG4gIH1cbiAgZ2V0TGVmdG1vc3RTaWJsaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm51bWJlciA+IDAgJiYgdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5jaGlsZHJlblswXSA6IHZvaWQgMDtcbiAgfVxuICAvLyB0cmF2ZXJzZSB0aGUgbGVmdCBjb250b3VyIG9mIGEgc3VidHJlZSwgcmV0dXJuIHRoZSBzdWNjZXNzb3Igb2YgdiBvbiB0aGlzIGNvbnRvdXJcbiAgbmV4dExlZnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4gPyB0aGlzLmNoaWxkcmVuWzBdIDogdGhpcy50aHJlYWQ7XG4gIH1cbiAgLy8gdHJhdmVyc2UgdGhlIHJpZ2h0IGNvbnRvdXIgb2YgYSBzdWJ0cmVlLCByZXR1cm4gdGhlIHN1Y2Nlc3NvciBvZiB2IG9uIHRoaXMgY29udG91clxuICBuZXh0UmlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4gPyB0aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMV0gOiB0aGlzLnRocmVhZDtcbiAgfVxuICBnZXRTaWJsaW5ncygpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5jaGlsZHJlbi5maWx0ZXIoKF8sIGkpID0+IGkgIT09IHRoaXMubnVtYmVyKSA6IFtdO1xuICB9XG59O1xuZnVuY3Rpb24gdGlja3NUb1RyZWUodGlja3MsIHBhZDIgPSB0cnVlKSB7XG4gIGNvbnN0IHJvb3QgPSBuZXcgVHJlZU5vZGUoKTtcbiAgbGV0IGRlcHRoID0gMDtcbiAgaWYgKHBhZDIpIHtcbiAgICB0aWNrcy5mb3JFYWNoKCh0aWNrKSA9PiBkZXB0aCA9IE1hdGgubWF4KGRlcHRoLCB0aWNrLmxhYmVscy5sZW5ndGgpKTtcbiAgfVxuICB0aWNrcy5mb3JFYWNoKCh0aWNrKSA9PiB7XG4gICAgaWYgKHBhZDIpIHtcbiAgICAgIHdoaWxlICh0aWNrLmxhYmVscy5sZW5ndGggPCBkZXB0aCkge1xuICAgICAgICB0aWNrLmxhYmVscy51bnNoaWZ0KFwiXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpbnNlcnRUaWNrKHJvb3QsIHRpY2spO1xuICB9KTtcbiAgcmV0dXJuIHJvb3Q7XG59XG5mdW5jdGlvbiBpbnNlcnRUaWNrKHJvb3QsIHRpY2spIHtcbiAgY29uc3QgcGF0aFBhcnRzID0gdGljay5sYWJlbHMuc2xpY2UoKS5yZXZlcnNlKCk7XG4gIGNvbnN0IGxhc3RQYXJ0SW5kZXggPSBwYXRoUGFydHMubGVuZ3RoIC0gMTtcbiAgcGF0aFBhcnRzLmZvckVhY2goKHBhdGhQYXJ0LCBwYXJ0SW5kZXgpID0+IHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHJvb3QuY2hpbGRyZW47XG4gICAgY29uc3QgZXhpc3RpbmdOb2RlID0gY2hpbGRyZW4uZmluZCgoY2hpbGQpID0+IGNoaWxkLmxhYmVsID09PSBwYXRoUGFydCk7XG4gICAgY29uc3QgaXNOb3RMZWFmID0gcGFydEluZGV4ICE9PSBsYXN0UGFydEluZGV4O1xuICAgIGlmIChleGlzdGluZ05vZGUgJiYgaXNOb3RMZWFmKSB7XG4gICAgICByb290ID0gZXhpc3RpbmdOb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBub2RlID0gbmV3IFRyZWVOb2RlKHBhdGhQYXJ0LCByb290KTtcbiAgICAgIG5vZGUubnVtYmVyID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgY2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgIGlmIChpc05vdExlYWYpIHtcbiAgICAgICAgcm9vdCA9IG5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIG1vdmVTdWJ0cmVlKHdtLCB3cCwgc2hpZnQpIHtcbiAgY29uc3Qgc3VidHJlZXMgPSB3cC5udW1iZXIgLSB3bS5udW1iZXI7XG4gIGNvbnN0IHJhdGlvMiA9IHNoaWZ0IC8gc3VidHJlZXM7XG4gIHdwLmNoYW5nZSAtPSByYXRpbzI7XG4gIHdwLnNoaWZ0ICs9IHNoaWZ0O1xuICB3bS5jaGFuZ2UgKz0gcmF0aW8yO1xuICB3cC5wcmVsaW0gKz0gc2hpZnQ7XG4gIHdwLm1vZCArPSBzaGlmdDtcbn1cbmZ1bmN0aW9uIGFuY2VzdG9yKHZpbSwgdiwgZGVmYXVsdEFuY2VzdG9yKSB7XG4gIHJldHVybiB2LmdldFNpYmxpbmdzKCkuaW5kZXhPZih2aW0uYW5jZXN0b3IpID49IDAgPyB2aW0uYW5jZXN0b3IgOiBkZWZhdWx0QW5jZXN0b3I7XG59XG5mdW5jdGlvbiBleGVjdXRlU2hpZnRzKHYpIHtcbiAgY29uc3QgY2hpbGRyZW4gPSB2LmNoaWxkcmVuO1xuICBpZiAoY2hpbGRyZW4pIHtcbiAgICBsZXQgc2hpZnQgPSAwO1xuICAgIGxldCBjaGFuZ2UgPSAwO1xuICAgIGZvciAobGV0IGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgdyA9IGNoaWxkcmVuW2ldO1xuICAgICAgdy5wcmVsaW0gKz0gc2hpZnQ7XG4gICAgICB3Lm1vZCArPSBzaGlmdDtcbiAgICAgIGNoYW5nZSArPSB3LmNoYW5nZTtcbiAgICAgIHNoaWZ0ICs9IHcuc2hpZnQgKyBjaGFuZ2U7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhcHBvcnRpb24odiwgZGVmYXVsdEFuY2VzdG9yLCBkaXN0YW5jZTMpIHtcbiAgY29uc3QgdyA9IHYuZ2V0TGVmdFNpYmxpbmcoKTtcbiAgaWYgKHcpIHtcbiAgICBsZXQgdm9wID0gdjtcbiAgICBsZXQgdmlwID0gdjtcbiAgICBsZXQgdmltID0gdztcbiAgICBsZXQgdm9tID0gdmlwLmdldExlZnRtb3N0U2libGluZygpO1xuICAgIGxldCBzaXAgPSB2aXAubW9kO1xuICAgIGxldCBzb3AgPSB2b3AubW9kO1xuICAgIGxldCBzaW0gPSB2aW0ubW9kO1xuICAgIGxldCBzb20gPSB2b20ubW9kO1xuICAgIHdoaWxlICh2aW0ubmV4dFJpZ2h0KCkgJiYgdmlwLm5leHRMZWZ0KCkpIHtcbiAgICAgIHZpbSA9IHZpbS5uZXh0UmlnaHQoKTtcbiAgICAgIHZpcCA9IHZpcC5uZXh0TGVmdCgpO1xuICAgICAgdm9tID0gdm9tLm5leHRMZWZ0KCk7XG4gICAgICB2b3AgPSB2b3AubmV4dFJpZ2h0KCk7XG4gICAgICB2b3AuYW5jZXN0b3IgPSB2O1xuICAgICAgY29uc3Qgc2hpZnQgPSB2aW0ucHJlbGltICsgc2ltIC0gKHZpcC5wcmVsaW0gKyBzaXApICsgZGlzdGFuY2UzO1xuICAgICAgaWYgKHNoaWZ0ID4gMCkge1xuICAgICAgICBtb3ZlU3VidHJlZShhbmNlc3Rvcih2aW0sIHYsIGRlZmF1bHRBbmNlc3RvciksIHYsIHNoaWZ0KTtcbiAgICAgICAgc2lwICs9IHNoaWZ0O1xuICAgICAgICBzb3AgKz0gc2hpZnQ7XG4gICAgICB9XG4gICAgICBzaW0gKz0gdmltLm1vZDtcbiAgICAgIHNpcCArPSB2aXAubW9kO1xuICAgICAgc29tICs9IHZvbS5tb2Q7XG4gICAgICBzb3AgKz0gdm9wLm1vZDtcbiAgICB9XG4gICAgaWYgKHZpbS5uZXh0UmlnaHQoKSAmJiAhdm9wLm5leHRSaWdodCgpKSB7XG4gICAgICB2b3AudGhyZWFkID0gdmltLm5leHRSaWdodCgpO1xuICAgICAgdm9wLm1vZCArPSBzaW0gLSBzb3A7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh2aXAubmV4dExlZnQoKSAmJiAhdm9tLm5leHRMZWZ0KCkpIHtcbiAgICAgICAgdm9tLnRocmVhZCA9IHZpcC5uZXh0TGVmdCgpO1xuICAgICAgICB2b20ubW9kICs9IHNpcCAtIHNvbTtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHRBbmNlc3RvciA9IHY7XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWZhdWx0QW5jZXN0b3I7XG59XG5mdW5jdGlvbiBmaXJzdFdhbGsobm9kZSwgZGlzdGFuY2UzKSB7XG4gIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgIGxldCBkZWZhdWx0QW5jZXN0b3IgPSBjaGlsZHJlblswXTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgZmlyc3RXYWxrKGNoaWxkLCBkaXN0YW5jZTMpO1xuICAgICAgZGVmYXVsdEFuY2VzdG9yID0gYXBwb3J0aW9uKGNoaWxkLCBkZWZhdWx0QW5jZXN0b3IsIGRpc3RhbmNlMyk7XG4gICAgfSk7XG4gICAgZXhlY3V0ZVNoaWZ0cyhub2RlKTtcbiAgICBjb25zdCBtaWRwb2ludCA9IChjaGlsZHJlblswXS5wcmVsaW0gKyBjaGlsZHJlbi5hdCgtMSkucHJlbGltKSAvIDI7XG4gICAgY29uc3QgbGVmdFNpYmxpbmcgPSBub2RlLmdldExlZnRTaWJsaW5nKCk7XG4gICAgaWYgKGxlZnRTaWJsaW5nKSB7XG4gICAgICBub2RlLnByZWxpbSA9IGxlZnRTaWJsaW5nLnByZWxpbSArIGRpc3RhbmNlMztcbiAgICAgIG5vZGUubW9kID0gbm9kZS5wcmVsaW0gLSBtaWRwb2ludDtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5wcmVsaW0gPSBtaWRwb2ludDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbGVmdFNpYmxpbmcgPSBub2RlLmdldExlZnRTaWJsaW5nKCk7XG4gICAgbm9kZS5wcmVsaW0gPSBsZWZ0U2libGluZyA/IGxlZnRTaWJsaW5nLnByZWxpbSArIGRpc3RhbmNlMyA6IDA7XG4gIH1cbn1cbnZhciBEaW1lbnNpb25zID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnRvcCA9IEluZmluaXR5O1xuICAgIHRoaXMucmlnaHQgPSAtSW5maW5pdHk7XG4gICAgdGhpcy5ib3R0b20gPSAtSW5maW5pdHk7XG4gICAgdGhpcy5sZWZ0ID0gSW5maW5pdHk7XG4gIH1cbiAgdXBkYXRlKG5vZGUsIHh5KSB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSB4eShub2RlKTtcbiAgICBpZiAoeCA+IHRoaXMucmlnaHQpIHtcbiAgICAgIHRoaXMucmlnaHQgPSB4O1xuICAgIH1cbiAgICBpZiAoeCA8IHRoaXMubGVmdCkge1xuICAgICAgdGhpcy5sZWZ0ID0geDtcbiAgICB9XG4gICAgaWYgKHkgPiB0aGlzLmJvdHRvbSkge1xuICAgICAgdGhpcy5ib3R0b20gPSB5O1xuICAgIH1cbiAgICBpZiAoeSA8IHRoaXMudG9wKSB7XG4gICAgICB0aGlzLnRvcCA9IHk7XG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gc2Vjb25kV2Fsayh2LCBtLCBsYXlvdXQpIHtcbiAgdi54ID0gdi5wcmVsaW0gKyBtO1xuICB2LnkgPSB2LmRlcHRoO1xuICBsYXlvdXQudXBkYXRlKHYpO1xuICB2LmNoaWxkcmVuLmZvckVhY2goKHcpID0+IHNlY29uZFdhbGsodywgbSArIHYubW9kLCBsYXlvdXQpKTtcbn1cbmZ1bmN0aW9uIHRoaXJkV2Fsayh2KSB7XG4gIGNvbnN0IGNoaWxkcmVuID0gdi5jaGlsZHJlbjtcbiAgbGV0IGxlYWZDb3VudCA9IDA7XG4gIGNoaWxkcmVuLmZvckVhY2goKHcpID0+IHtcbiAgICB0aGlyZFdhbGsodyk7XG4gICAgaWYgKHcuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICBsZWFmQ291bnQgKz0gdy5sZWFmQ291bnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlYWZDb3VudCsrO1xuICAgIH1cbiAgfSk7XG4gIHYubGVhZkNvdW50ID0gbGVhZkNvdW50O1xuICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgdi5zdWJ0cmVlTGVmdCA9IGNoaWxkcmVuWzBdLnN1YnRyZWVMZWZ0O1xuICAgIHYuc3VidHJlZVJpZ2h0ID0gY2hpbGRyZW5bdi5jaGlsZHJlbi5sZW5ndGggLSAxXS5zdWJ0cmVlUmlnaHQ7XG4gICAgdi54ID0gKHYuc3VidHJlZUxlZnQgKyB2LnN1YnRyZWVSaWdodCkgLyAyO1xuICB9IGVsc2Uge1xuICAgIHYuc3VidHJlZUxlZnQgPSB2Lng7XG4gICAgdi5zdWJ0cmVlUmlnaHQgPSB2Lng7XG4gIH1cbn1cbmZ1bmN0aW9uIHRyZWVMYXlvdXQocm9vdCkge1xuICBjb25zdCBsYXlvdXQgPSBuZXcgVHJlZUxheW91dCgpO1xuICBmaXJzdFdhbGsocm9vdCwgMSk7XG4gIHNlY29uZFdhbGsocm9vdCwgLXJvb3QucHJlbGltLCBsYXlvdXQpO1xuICB0aGlyZFdhbGsocm9vdCk7XG4gIHJldHVybiBsYXlvdXQ7XG59XG52YXIgVHJlZUxheW91dCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5kaW1lbnNpb25zID0gbmV3IERpbWVuc2lvbnMoKTtcbiAgICB0aGlzLmxlYWZDb3VudCA9IDA7XG4gICAgdGhpcy5ub2RlcyA9IFtdO1xuICAgIC8vIE9uZSBtaWdodCB3YW50IHRvIHByb2Nlc3MgbGVhZiBub2RlcyBzZXBhcmF0ZWx5IGZyb20gdGhlIHJlc3Qgb2YgdGhlIHRyZWUuXG4gICAgLy8gRm9yIGV4YW1wbGUsIHBvc2l0aW9uIGxhYmVscyBjb3JyZXNwb25kaW5nIHRvIGxlYWZzIHZlcnRpY2FsbHksIHJhdGhlciB0aGFuIGhvcml6b250YWxseS5cbiAgICB0aGlzLmxlYWZOb2RlcyA9IFtdO1xuICAgIHRoaXMubm9uTGVhZk5vZGVzID0gW107XG4gICAgdGhpcy5kZXB0aCA9IDA7XG4gIH1cbiAgdXBkYXRlKG5vZGUpIHtcbiAgICB0aGlzLmRpbWVuc2lvbnMudXBkYXRlKG5vZGUsIChuKSA9PiAoeyB4OiBuLngsIHk6IG4ueSB9KSk7XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICB0aGlzLm5vbkxlYWZOb2Rlcy5wdXNoKG5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxlYWZDb3VudCsrO1xuICAgICAgdGhpcy5sZWFmTm9kZXMucHVzaChub2RlKTtcbiAgICB9XG4gICAgaWYgKG5vZGUuZGVwdGggPiB0aGlzLmRlcHRoKSB7XG4gICAgICB0aGlzLmRlcHRoID0gbm9kZS5kZXB0aDtcbiAgICB9XG4gICAgdGhpcy5ub2Rlcy5wdXNoKG5vZGUpO1xuICB9XG4gIHJlc2l6ZSh3aWR0aDIsIGhlaWdodDIsIHNoaWZ0WCA9IDAsIHNoaWZ0WSA9IDAsIGZsaXBYID0gZmFsc2UpIHtcbiAgICBjb25zdCB4U3RlcHMgPSB0aGlzLmxlYWZDb3VudCAtIDE7XG4gICAgY29uc3QgeVN0ZXBzID0gdGhpcy5kZXB0aDtcbiAgICBjb25zdCBkaW1lbnNpb25zID0gdGhpcy5kaW1lbnNpb25zO1xuICAgIGxldCBzY2FsaW5nWCA9IDE7XG4gICAgbGV0IHNjYWxpbmdZID0gMTtcbiAgICBpZiAod2lkdGgyID4gMCAmJiB4U3RlcHMpIHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nU3BhY2luZ1ggPSAoZGltZW5zaW9ucy5yaWdodCAtIGRpbWVuc2lvbnMubGVmdCkgLyB4U3RlcHM7XG4gICAgICBjb25zdCBkZXNpcmVkU3BhY2luZ1ggPSB3aWR0aDIgLyB4U3RlcHM7XG4gICAgICBzY2FsaW5nWCA9IGRlc2lyZWRTcGFjaW5nWCAvIGV4aXN0aW5nU3BhY2luZ1g7XG4gICAgICBpZiAoZmxpcFgpIHtcbiAgICAgICAgc2NhbGluZ1ggPSAtc2NhbGluZ1g7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChoZWlnaHQyID4gMCAmJiB5U3RlcHMpIHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nU3BhY2luZ1kgPSAoZGltZW5zaW9ucy5ib3R0b20gLSBkaW1lbnNpb25zLnRvcCkgLyB5U3RlcHM7XG4gICAgICBjb25zdCBkZXNpcmVkU3BhY2luZ1kgPSBoZWlnaHQyIC8geVN0ZXBzO1xuICAgICAgc2NhbGluZ1kgPSBkZXNpcmVkU3BhY2luZ1kgLyBleGlzdGluZ1NwYWNpbmdZO1xuICAgIH1cbiAgICBjb25zdCBzY3JlZW5EaW1lbnNpb25zID0gbmV3IERpbWVuc2lvbnMoKTtcbiAgICB0aGlzLm5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgIG5vZGUuc2NyZWVuWCA9IG5vZGUueCAqIHNjYWxpbmdYO1xuICAgICAgbm9kZS5zY3JlZW5ZID0gbm9kZS55ICogc2NhbGluZ1k7XG4gICAgICBzY3JlZW5EaW1lbnNpb25zLnVwZGF0ZShub2RlLCAobikgPT4gKHsgeDogbi5zY3JlZW5YLCB5OiBuLnNjcmVlblkgfSkpO1xuICAgIH0pO1xuICAgIGNvbnN0IG9mZnNldFggPSAtc2NyZWVuRGltZW5zaW9ucy5sZWZ0O1xuICAgIGNvbnN0IG9mZnNldFkgPSAtc2NyZWVuRGltZW5zaW9ucy50b3A7XG4gICAgdGhpcy5ub2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICBub2RlLnNjcmVlblggKz0gb2Zmc2V0WCArIHNoaWZ0WDtcbiAgICAgIG5vZGUuc2NyZWVuWSArPSBvZmZzZXRZICsgc2hpZnRZO1xuICAgIH0pO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9heGlzL2dyb3VwZWRDYXRlZ29yeUF4aXMudHNcbnZhciBHcm91cGVkQ2F0ZWdvcnlBeGlzTGFiZWwgPSBjbGFzcyBleHRlbmRzIEF4aXNMYWJlbCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5ncmlkID0gZmFsc2U7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgR3JvdXBlZENhdGVnb3J5QXhpc0xhYmVsLnByb3RvdHlwZSwgXCJncmlkXCIsIDIpO1xudmFyIEdyb3VwZWRDYXRlZ29yeUF4aXMgPSBjbGFzcyBleHRlbmRzIENhcnRlc2lhbkF4aXMge1xuICBjb25zdHJ1Y3Rvcihtb2R1bGVDdHgpIHtcbiAgICBjb25zdCBzY2FsZTIgPSBuZXcgQmFuZFNjYWxlKCk7XG4gICAgc2NhbGUyLnBhZGRpbmdPdXRlciA9IDAuMTtcbiAgICBzY2FsZTIucGFkZGluZ0lubmVyID0gc2NhbGUyLnBhZGRpbmdPdXRlciAqIDI7XG4gICAgc3VwZXIobW9kdWxlQ3R4LCBzY2FsZTIpO1xuICAgIC8vIExhYmVsIHNjYWxlIChsYWJlbHMgYXJlIHBvc2l0aW9uZWQgYmV0d2VlbiB0aWNrcywgdGljayBjb3VudCA9IGxhYmVsIGNvdW50ICsgMSkuXG4gICAgLy8gV2UgZG9uJ3QgY2FsbCBpcyBgbGFiZWxTY2FsZWAgZm9yIGNvbnNpc3RlbmN5IHdpdGggb3RoZXIgYXhlcy5cbiAgICB0aGlzLnRpY2tTY2FsZSA9IG5ldyBCYW5kU2NhbGUoKTtcbiAgICB0aGlzLmxpbmUgPSBuZXcgQXhpc0xpbmUoKTtcbiAgICB0aGlzLmxhYmVsID0gbmV3IEdyb3VwZWRDYXRlZ29yeUF4aXNMYWJlbCgpO1xuICAgIHRoaXMubGFiZWxDb2xvciA9IFwicmdiYSg4NywgODcsIDg3LCAxKVwiO1xuICAgIHRoaXMuaW5jbHVkZUludmlzaWJsZURvbWFpbnMgPSB0cnVlO1xuICAgIGNvbnN0IHsgdGlja0xpbmVHcm91cCwgdGlja0xhYmVsR3JvdXAsIGdyaWRMaW5lR3JvdXAsIHRpY2tTY2FsZSB9ID0gdGhpcztcbiAgICB0aWNrU2NhbGUucGFkZGluZ0lubmVyID0gMTtcbiAgICB0aWNrU2NhbGUucGFkZGluZ091dGVyID0gMDtcbiAgICB0aGlzLmdyaWRMaW5lU2VsZWN0aW9uID0gU2VsZWN0aW9uLnNlbGVjdChncmlkTGluZUdyb3VwLCBMaW5lKTtcbiAgICB0aGlzLmF4aXNMaW5lU2VsZWN0aW9uID0gU2VsZWN0aW9uLnNlbGVjdCh0aWNrTGluZUdyb3VwLCBMaW5lKTtcbiAgICB0aGlzLnNlcGFyYXRvclNlbGVjdGlvbiA9IFNlbGVjdGlvbi5zZWxlY3QodGlja0xpbmVHcm91cCwgTGluZSk7XG4gICAgdGhpcy5sYWJlbFNlbGVjdGlvbiA9IFNlbGVjdGlvbi5zZWxlY3QodGlja0xhYmVsR3JvdXAsIFRyYW5zZm9ybWFibGVUZXh0KTtcbiAgICB0aGlzLmxpbmVOb2RlLnZpc2libGUgPSBmYWxzZTtcbiAgfVxuICB1cGRhdGVSYW5nZSgpIHtcbiAgICBjb25zdCB7IHJhbmdlOiByciwgdmlzaWJsZVJhbmdlOiB2ciwgc2NhbGU6IHNjYWxlMiB9ID0gdGhpcztcbiAgICBjb25zdCBzcGFuID0gKHJyWzFdIC0gcnJbMF0pIC8gKHZyWzFdIC0gdnJbMF0pO1xuICAgIGNvbnN0IHNoaWZ0ID0gc3BhbiAqIHZyWzBdO1xuICAgIGNvbnN0IHN0YXJ0MiA9IHJyWzBdIC0gc2hpZnQ7XG4gICAgdGhpcy50aWNrU2NhbGUucmFuZ2UgPSBzY2FsZTIucmFuZ2UgPSBbc3RhcnQyLCBzdGFydDIgKyBzcGFuXTtcbiAgICB0aGlzLnJlc2l6ZVRpY2tUcmVlKCk7XG4gIH1cbiAgcmVzaXplVGlja1RyZWUoKSB7XG4gICAgY29uc3QgcyA9IHRoaXMuc2NhbGU7XG4gICAgY29uc3QgcmFuZ2UzID0gcy5kb21haW4ubGVuZ3RoID8gW3MuY29udmVydChzLmRvbWFpblswXSksIHMuY29udmVydChzLmRvbWFpbltzLmRvbWFpbi5sZW5ndGggLSAxXSldIDogcy5yYW5nZTtcbiAgICBjb25zdCBsYXlvdXQgPSB0aGlzLnRpY2tUcmVlTGF5b3V0O1xuICAgIGNvbnN0IGxpbmVIZWlnaHQgPSB0aGlzLmxpbmVIZWlnaHQ7XG4gICAgaWYgKGxheW91dCkge1xuICAgICAgbGF5b3V0LnJlc2l6ZShcbiAgICAgICAgTWF0aC5hYnMocmFuZ2UzWzFdIC0gcmFuZ2UzWzBdKSxcbiAgICAgICAgbGF5b3V0LmRlcHRoICogbGluZUhlaWdodCxcbiAgICAgICAgKE1hdGgubWluKHJhbmdlM1swXSwgcmFuZ2UzWzFdKSB8fCAwKSArIChzLmJhbmR3aWR0aCA/PyAwKSAvIDIsXG4gICAgICAgIC1sYXlvdXQuZGVwdGggKiBsaW5lSGVpZ2h0LFxuICAgICAgICByYW5nZTNbMV0gLSByYW5nZTNbMF0gPCAwXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBnZXQgbGluZUhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5sYWJlbC5mb250U2l6ZSAqIDEuNTtcbiAgfVxuICAvKipcbiAgICogVGhlIGxlbmd0aCBvZiB0aGUgZ3JpZC4gVGhlIGdyaWQgaXMgb25seSB2aXNpYmxlIGluIGNhc2Ugb2YgYSBub24temVybyB2YWx1ZS5cbiAgICovXG4gIG9uR3JpZFZpc2liaWxpdHlDaGFuZ2UoKSB7XG4gICAgdGhpcy5ncmlkTGluZVNlbGVjdGlvbi5jbGVhcigpO1xuICAgIHRoaXMubGFiZWxTZWxlY3Rpb24uY2xlYXIoKTtcbiAgfVxuICBjYWxjdWxhdGVEb21haW4oKSB7XG4gICAgY29uc3QgeyBkaXJlY3Rpb24gfSA9IHRoaXM7XG4gICAgbGV0IGlzTnVtZXJpY1ggPSBudWxsO1xuICAgIGNvbnN0IGZsYXREb21haW5zID0gdGhpcy5ib3VuZFNlcmllcy5maWx0ZXIoKHMpID0+IHMudmlzaWJsZSkuZmxhdE1hcCgoc2VyaWVzKSA9PiB7XG4gICAgICBpZiAoZGlyZWN0aW9uID09PSBcInlcIiAvKiBZICovIHx8IGlzTnVtZXJpY1gpIHtcbiAgICAgICAgcmV0dXJuIHNlcmllcy5nZXREb21haW4oZGlyZWN0aW9uKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc051bWVyaWNYID09PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGRvbWFpbjIgPSBzZXJpZXMuZ2V0RG9tYWluKGRpcmVjdGlvbik7XG4gICAgICAgIGlzTnVtZXJpY1ggPSBpc051bWJlcihkb21haW4yWzBdKTtcbiAgICAgICAgcmV0dXJuIGRvbWFpbjI7XG4gICAgICB9XG4gICAgICByZXR1cm4gW107XG4gICAgfSk7XG4gICAgdGhpcy5zZXREb21haW4oZXh0ZW50KGZsYXREb21haW5zKSA/PyB1bmlxdWUoZmxhdERvbWFpbnMpKTtcbiAgICBjb25zdCB7IGRvbWFpbiB9ID0gdGhpcy5kYXRhRG9tYWluO1xuICAgIHRoaXMudGlja1RyZWVMYXlvdXQgPSB0cmVlTGF5b3V0KHRpY2tzVG9UcmVlKGRvbWFpbikpO1xuICAgIHRoaXMudGlja1NjYWxlLmRvbWFpbiA9IGRvbWFpbi5jb25jYXQoXCJcIik7XG4gICAgdGhpcy5yZXNpemVUaWNrVHJlZSgpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzL3JlbW92ZXMvdXBkYXRlcyB0aGUgc2NlbmUgZ3JhcGggbm9kZXMgdGhhdCBjb25zdGl0dXRlIHRoZSBheGlzLlxuICAgKiBTdXBwb3NlZCB0byBiZSBjYWxsZWQgX21hbnVhbGx5XyBhZnRlciBjaGFuZ2luZyBfYW55XyBvZiB0aGUgYXhpcyBwcm9wZXJ0aWVzLlxuICAgKiBUaGlzIGFsbG93cyB0byBidWxrIHNldCBheGlzIHByb3BlcnRpZXMgYmVmb3JlIHVwZGF0aW5nIHRoZSBub2Rlcy5cbiAgICogVGhlIG5vZGUgY2hhbmdlcyBtYWRlIGJ5IHRoaXMgbWV0aG9kIGFyZSByZW5kZXJlZCBvbiB0aGUgbmV4dCBhbmltYXRpb24gZnJhbWUuXG4gICAqIFdlIGNvdWxkIHNjaGVkdWxlIHRoaXMgbWV0aG9kIGNhbGwgYXV0b21hdGljYWxseSBvbiB0aGUgbmV4dCBhbmltYXRpb24gZnJhbWVcbiAgICogd2hlbiBhbnkgb2YgdGhlIGF4aXMgcHJvcGVydGllcyBjaGFuZ2UgKHRoZSB3YXkgd2UgZG8gd2hlbiBwcm9wZXJ0aWVzIG9mIHNjZW5lIGdyYXBoJ3NcbiAgICogbm9kZXMgY2hhbmdlKSwgYnV0IHRoaXMgd2lsbCBtZWFuIHRoYXQgd2UgZmlyc3Qgd2FpdCBmb3IgdGhlIG5leHQgYW5pbWF0aW9uXG4gICAqIGZyYW1lIHRvIG1ha2UgY2hhbmdlcyB0byB0aGUgbm9kZXMgb2YgdGhlIGF4aXMsIHRoZW4gd2FpdCBmb3IgYW5vdGhlciBhbmltYXRpb25cbiAgICogZnJhbWUgdG8gcmVuZGVyIHRob3NlIGNoYW5nZXMuIEl0J3MgbmljZSB0byBoYXZlIGV2ZXJ5dGhpbmcgdXBkYXRlIGF1dG9tYXRpY2FsbHksXG4gICAqIGJ1dCB0aGlzIGV4dHJhIGxldmVsIG9mIGFzeW5jIGluZGlyZWN0aW9uIHdpbGwgbm90IGp1c3QgaW50cm9kdWNlIGFuIHVud2FudGVkIGRlbGF5LFxuICAgKiBpdCB3aWxsIGFsc28gbWFrZSBpdCBoYXJkZXIgdG8gcmVhc29uIGFib3V0IHRoZSBwcm9ncmFtLlxuICAgKi9cbiAgdXBkYXRlKCkge1xuICAgIGlmICghdGhpcy5jb21wdXRlZExheW91dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uKCk7XG4gICAgdGhpcy51cGRhdGVUaXRsZUNhcHRpb24oKTtcbiAgICB0aGlzLnVwZGF0ZUNhdGVnb3J5TGFiZWxzKCk7XG4gICAgdGhpcy51cGRhdGVTZXBhcmF0b3JzKCk7XG4gICAgdGhpcy51cGRhdGVBeGlzTGluZXMoKTtcbiAgICB0aGlzLnVwZGF0ZUNhdGVnb3J5R3JpZExpbmVzKCk7XG4gICAgdGhpcy5yZXNldFNlbGVjdGlvbk5vZGVzKCk7XG4gIH1cbiAgdXBkYXRlVGl0bGVDYXB0aW9uKCkge1xuICAgIHRoaXMudGl0bGUuY2FwdGlvbi5ub2RlLnZpc2libGUgPSBmYWxzZTtcbiAgfVxuICB1cGRhdGVDYXRlZ29yeUxhYmVscygpIHtcbiAgICBpZiAoIXRoaXMuY29tcHV0ZWRMYXlvdXQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyB0aWNrTGFiZWxMYXlvdXQgfSA9IHRoaXMuY29tcHV0ZWRMYXlvdXQ7XG4gICAgY29uc3QgbGFiZWxTZWxlY3Rpb24gPSB0aGlzLmxhYmVsU2VsZWN0aW9uLnVwZGF0ZSh0aWNrTGFiZWxMYXlvdXQpO1xuICAgIGxhYmVsU2VsZWN0aW9uLmVhY2goKG5vZGUsIGRhdHVtKSA9PiB7XG4gICAgICBub2RlLnNldFByb3BlcnRpZXMoZGF0dW0pO1xuICAgIH0pO1xuICB9XG4gIHVwZGF0ZVNlcGFyYXRvcnMoKSB7XG4gICAgaWYgKCF0aGlzLmNvbXB1dGVkTGF5b3V0KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgc2VwYXJhdG9yTGF5b3V0IH0gPSB0aGlzLmNvbXB1dGVkTGF5b3V0O1xuICAgIGNvbnN0IHsgcmFuZ2U6IHJhbmdlMyB9ID0gdGhpcztcbiAgICBjb25zdCBlcHNpbG9uMiA9IDFlLTc7XG4gICAgY29uc3Qgc2VwYXJhdG9yU2VsZWN0aW9uID0gdGhpcy5zZXBhcmF0b3JTZWxlY3Rpb24udXBkYXRlKHNlcGFyYXRvckxheW91dCk7XG4gICAgc2VwYXJhdG9yU2VsZWN0aW9uLmVhY2goKGxpbmUsIGRhdHVtKSA9PiB7XG4gICAgICBsaW5lLngxID0gZGF0dW0ueDE7XG4gICAgICBsaW5lLngyID0gZGF0dW0ueDI7XG4gICAgICBsaW5lLnkxID0gZGF0dW0ueTtcbiAgICAgIGxpbmUueTIgPSBkYXR1bS55O1xuICAgICAgbGluZS52aXNpYmxlID0gdGhpcy50aWNrLmVuYWJsZWQgJiYgZGF0dW0ueSA+PSByYW5nZTNbMF0gLSBlcHNpbG9uMiAmJiBkYXR1bS55IDw9IHJhbmdlM1sxXSArIGVwc2lsb24yO1xuICAgICAgbGluZS5zdHJva2UgPSB0aGlzLnRpY2suc3Ryb2tlO1xuICAgICAgbGluZS5zdHJva2VXaWR0aCA9IDE7XG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlQXhpc0xpbmVzKCkge1xuICAgIGlmICghdGhpcy5jb21wdXRlZExheW91dClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IGF4aXNMaW5lTGF5b3V0IH0gPSB0aGlzLmNvbXB1dGVkTGF5b3V0O1xuICAgIGNvbnN0IGF4aXNMaW5lU2VsZWN0aW9uID0gdGhpcy5heGlzTGluZVNlbGVjdGlvbi51cGRhdGUoYXhpc0xpbmVMYXlvdXQpO1xuICAgIGF4aXNMaW5lU2VsZWN0aW9uLmVhY2goKGxpbmUsIGRhdHVtKSA9PiB7XG4gICAgICBsaW5lLnNldFByb3BlcnRpZXMoZGF0dW0pO1xuICAgICAgbGluZS5zdHJva2UgPSB0aGlzLmxpbmUuc3Ryb2tlO1xuICAgICAgbGluZS5zdHJva2VXaWR0aCA9IHRoaXMubGluZS53aWR0aDtcbiAgICB9KTtcbiAgfVxuICB1cGRhdGVDYXRlZ29yeUdyaWRMaW5lcygpIHtcbiAgICBjb25zdCB7IGdyaWRMZW5ndGgsIGdyaWRMaW5lLCBsYWJlbCwgcmFuZ2U6IHJhbmdlMywgdGlja1NjYWxlIH0gPSB0aGlzO1xuICAgIGNvbnN0IHRpY2tzID0gdGlja1NjYWxlLnRpY2tzKCk7XG4gICAgY29uc3Qgc2lkZUZsYWcgPSBsYWJlbC5nZXRTaWRlRmxhZygpO1xuICAgIGNvbnN0IGdyaWRTZWxlY3Rpb24gPSB0aGlzLmdyaWRMaW5lU2VsZWN0aW9uLnVwZGF0ZShncmlkTGVuZ3RoID8gdGlja3MgOiBbXSk7XG4gICAgaWYgKGdyaWRMZW5ndGgpIHtcbiAgICAgIGNvbnN0IHsgd2lkdGg6IHdpZHRoMiwgc3R5bGUgfSA9IGdyaWRMaW5lO1xuICAgICAgY29uc3Qgc3R5bGVDb3VudCA9IHN0eWxlLmxlbmd0aDtcbiAgICAgIGdyaWRTZWxlY3Rpb24uZWFjaCgobGluZSwgZGF0dW0sIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IHkgPSBNYXRoLnJvdW5kKHRpY2tTY2FsZS5jb252ZXJ0KGRhdHVtKSk7XG4gICAgICAgIGNvbnN0IHsgc3Ryb2tlLCBsaW5lRGFzaCB9ID0gc3R5bGVbaW5kZXggJSBzdHlsZUNvdW50XTtcbiAgICAgICAgbGluZS52aXNpYmxlID0gZ3JpZExpbmUuZW5hYmxlZCAmJiB5ID49IHJhbmdlM1swXSAmJiB5IDw9IHJhbmdlM1sxXTtcbiAgICAgICAgbGluZS54MSA9IDA7XG4gICAgICAgIGxpbmUueDIgPSAtc2lkZUZsYWcgKiBncmlkTGVuZ3RoO1xuICAgICAgICBsaW5lLnkxID0geTtcbiAgICAgICAgbGluZS55MiA9IHk7XG4gICAgICAgIGxpbmUuc3Ryb2tlID0gc3Ryb2tlO1xuICAgICAgICBsaW5lLnN0cm9rZVdpZHRoID0gd2lkdGgyO1xuICAgICAgICBsaW5lLmxpbmVEYXNoID0gbGluZURhc2g7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgY29tcHV0ZUxheW91dCgpIHtcbiAgICB0aGlzLnVwZGF0ZURpcmVjdGlvbigpO1xuICAgIHRoaXMuY2FsY3VsYXRlRG9tYWluKCk7XG4gICAgdGhpcy51cGRhdGVSYW5nZSgpO1xuICAgIGNvbnN0IHtcbiAgICAgIHNjYWxlOiBzY2FsZTIsXG4gICAgICBsYWJlbCxcbiAgICAgIGxhYmVsOiB7IHBhcmFsbGVsIH0sXG4gICAgICBtb2R1bGVDdHg6IHsgY2FsbGJhY2tDYWNoZSB9LFxuICAgICAgcmFuZ2U6IHJhbmdlMyxcbiAgICAgIHRpdGxlLFxuICAgICAgdGl0bGU6IHsgZm9ybWF0dGVyID0gKHApID0+IHAuZGVmYXVsdFZhbHVlIH0gPSB7fVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHJhbmdlU3RhcnQgPSBzY2FsZTIucmFuZ2VbMF07XG4gICAgY29uc3QgcmFuZ2VFbmQgPSBzY2FsZTIucmFuZ2VbMV07XG4gICAgY29uc3QgcmFuZ2VMZW5ndGggPSBNYXRoLmFicyhyYW5nZUVuZCAtIHJhbmdlU3RhcnQpO1xuICAgIGNvbnN0IGJhbmR3aWR0aCA9IHJhbmdlTGVuZ3RoIC8gc2NhbGUyLmRvbWFpbi5sZW5ndGggfHwgMDtcbiAgICBjb25zdCBrZWVwRXZlcnkgPSBNYXRoLmNlaWwobGFiZWwuZm9udFNpemUgLyBiYW5kd2lkdGgpO1xuICAgIGNvbnN0IHJvdGF0aW9uID0gdG9SYWRpYW5zKHRoaXMucm90YXRpb24pO1xuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IE1hdGguYWJzKE1hdGguY29zKHJvdGF0aW9uKSkgPCAxZS04O1xuICAgIGNvbnN0IHNpZGVGbGFnID0gbGFiZWwuZ2V0U2lkZUZsYWcoKTtcbiAgICBjb25zdCBsaW5lSGVpZ2h0ID0gdGhpcy5saW5lSGVpZ2h0O1xuICAgIGNvbnN0IHRpY2tUcmVlTGF5b3V0ID0gdGhpcy50aWNrVHJlZUxheW91dDtcbiAgICBjb25zdCBsYWJlbHMgPSBzY2FsZTIudGlja3MoKTtcbiAgICBjb25zdCB0cmVlTGFiZWxzID0gdGlja1RyZWVMYXlvdXQgPyB0aWNrVHJlZUxheW91dC5ub2RlcyA6IFtdO1xuICAgIGNvbnN0IGlzTGFiZWxUcmVlID0gdGlja1RyZWVMYXlvdXQgPyB0aWNrVHJlZUxheW91dC5kZXB0aCA+IDEgOiBmYWxzZTtcbiAgICBjb25zdCBpc0NhcHRpb25FbmFibGVkID0gdGl0bGU/LmVuYWJsZWQgJiYgbGFiZWxzLmxlbmd0aCA+IDA7XG4gICAgY29uc3QgeyBkZWZhdWx0Um90YXRpb24sIGNvbmZpZ3VyZWRSb3RhdGlvbiwgcGFyYWxsZWxGbGlwRmxhZyB9ID0gY2FsY3VsYXRlTGFiZWxSb3RhdGlvbih7XG4gICAgICByb3RhdGlvbjogbGFiZWwucm90YXRpb24sXG4gICAgICBwYXJhbGxlbCxcbiAgICAgIHJlZ3VsYXJGbGlwUm90YXRpb246IG5vcm1hbGl6ZUFuZ2xlMzYwKHJvdGF0aW9uIC0gTWF0aC5QSSAvIDIpLFxuICAgICAgcGFyYWxsZWxGbGlwUm90YXRpb246IG5vcm1hbGl6ZUFuZ2xlMzYwKHJvdGF0aW9uKVxuICAgIH0pO1xuICAgIGNvbnN0IHRpY2tMYWJlbExheW91dCA9IFtdO1xuICAgIGNvbnN0IGNvcHlMYWJlbFByb3BzID0gKG5vZGUpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGZpbGw6IG5vZGUuZmlsbCxcbiAgICAgICAgZm9udEZhbWlseTogbm9kZS5mb250RmFtaWx5LFxuICAgICAgICBmb250U2l6ZTogbm9kZS5mb250U2l6ZSxcbiAgICAgICAgZm9udFN0eWxlOiBub2RlLmZvbnRTdHlsZSxcbiAgICAgICAgZm9udFdlaWdodDogbm9kZS5mb250V2VpZ2h0LFxuICAgICAgICByb3RhdGlvbjogbm9kZS5yb3RhdGlvbixcbiAgICAgICAgcm90YXRpb25DZW50ZXJYOiBub2RlLnJvdGF0aW9uQ2VudGVyWCxcbiAgICAgICAgcm90YXRpb25DZW50ZXJZOiBub2RlLnJvdGF0aW9uQ2VudGVyWSxcbiAgICAgICAgdGV4dDogbm9kZS50ZXh0LFxuICAgICAgICB0ZXh0QWxpZ246IG5vZGUudGV4dEFsaWduLFxuICAgICAgICB0ZXh0QmFzZWxpbmU6IG5vZGUudGV4dEJhc2VsaW5lLFxuICAgICAgICB0cmFuc2xhdGlvblg6IG5vZGUudHJhbnNsYXRpb25YLFxuICAgICAgICB0cmFuc2xhdGlvblk6IG5vZGUudHJhbnNsYXRpb25ZLFxuICAgICAgICB2aXNpYmxlOiBub2RlLnZpc2libGUsXG4gICAgICAgIHg6IG5vZGUueCxcbiAgICAgICAgeTogbm9kZS55XG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgbGFiZWxCQm94ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGxldCBtYXhMZWFmTGFiZWxXaWR0aCA9IDA7XG4gICAgY29uc3QgdGVtcFRleHQgPSBuZXcgVHJhbnNmb3JtYWJsZVRleHQoKTtcbiAgICBjb25zdCBzZXRMYWJlbFByb3BzID0gKGRhdHVtLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgIGlmIChpc0NhcHRpb25FbmFibGVkKSB7XG4gICAgICAgICAgY29uc3QgdGV4dCA9IGNhbGxiYWNrQ2FjaGUuY2FsbChmb3JtYXR0ZXIsIHRoaXMuZ2V0VGl0bGVGb3JtYXR0ZXJQYXJhbXMoKSk7XG4gICAgICAgICAgdGVtcFRleHQuc2V0UHJvcGVydGllcyh7XG4gICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgZmlsbDogdGl0bGUuY29sb3IsXG4gICAgICAgICAgICBmb250RmFtaWx5OiB0aXRsZS5mb250RmFtaWx5LFxuICAgICAgICAgICAgZm9udFNpemU6IHRpdGxlLmZvbnRTaXplLFxuICAgICAgICAgICAgZm9udFN0eWxlOiB0aXRsZS5mb250U3R5bGUsXG4gICAgICAgICAgICBmb250V2VpZ2h0OiB0aXRsZS5mb250V2VpZ2h0LFxuICAgICAgICAgICAgdGV4dEFsaWduOiBcImNlbnRlclwiLFxuICAgICAgICAgICAgdGV4dEJhc2VsaW5lOiBcImhhbmdpbmdcIixcbiAgICAgICAgICAgIHRyYW5zbGF0aW9uWDogZGF0dW0uc2NyZWVuWSAtIHRpdGxlLmZvbnRTaXplICogMC4yNSxcbiAgICAgICAgICAgIHRyYW5zbGF0aW9uWTogZGF0dW0uc2NyZWVuWFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRlbXBUZXh0LnNldFByb3BlcnRpZXMoe1xuICAgICAgICBmaWxsOiBsYWJlbC5jb2xvcixcbiAgICAgICAgZm9udEZhbWlseTogbGFiZWwuZm9udEZhbWlseSxcbiAgICAgICAgZm9udFNpemU6IGxhYmVsLmZvbnRTaXplLFxuICAgICAgICBmb250U3R5bGU6IGxhYmVsLmZvbnRTdHlsZSxcbiAgICAgICAgZm9udFdlaWdodDogbGFiZWwuZm9udFdlaWdodCxcbiAgICAgICAgdGV4dEFsaWduOiBcImNlbnRlclwiLFxuICAgICAgICB0ZXh0QmFzZWxpbmU6IHBhcmFsbGVsRmxpcEZsYWcgPT09IC0xID8gXCJib3R0b21cIiA6IFwiaGFuZ2luZ1wiLFxuICAgICAgICB0cmFuc2xhdGlvblg6IGRhdHVtLnNjcmVlblkgLSBsYWJlbC5mb250U2l6ZSAqIDAuMjUsXG4gICAgICAgIHRyYW5zbGF0aW9uWTogZGF0dW0uc2NyZWVuWFxuICAgICAgfSk7XG4gICAgICBpZiAoaW5kZXggJSBrZWVwRXZlcnkgIT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGRhdHVtLnNjcmVlblggPCByYW5nZTNbMF0gfHwgZGF0dW0uc2NyZWVuWCA+IHJhbmdlM1sxXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAobGFiZWwuZm9ybWF0dGVyKSB7XG4gICAgICAgIHRlbXBUZXh0LnRleHQgPSBjYWxsYmFja0NhY2hlLmNhbGwobGFiZWwuZm9ybWF0dGVyLCB7XG4gICAgICAgICAgdmFsdWU6IFN0cmluZyhkYXR1bS5sYWJlbCksXG4gICAgICAgICAgaW5kZXhcbiAgICAgICAgfSkgPz8gU3RyaW5nKGRhdHVtLmxhYmVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRlbXBUZXh0LnRleHQgPSBTdHJpbmcoZGF0dW0ubGFiZWwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICB0cmVlTGFiZWxzLmZvckVhY2goKGRhdHVtLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgaXNWaXNpYmxlID0gc2V0TGFiZWxQcm9wcyhkYXR1bSwgaW5kZXgpO1xuICAgICAgaWYgKCFpc1Zpc2libGUpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IGJib3gyID0gdGVtcFRleHQuZ2V0QkJveCgpO1xuICAgICAgaWYgKCFiYm94MilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgbGFiZWxCQm94ZXMuc2V0KGluZGV4LCBiYm94Mik7XG4gICAgICBjb25zdCBpc0xlYWYgPSAhZGF0dW0uY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgaWYgKGlzTGVhZiAmJiBiYm94Mi53aWR0aCA+IG1heExlYWZMYWJlbFdpZHRoKSB7XG4gICAgICAgIG1heExlYWZMYWJlbFdpZHRoID0gYmJveDIud2lkdGg7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgbGFiZWxYID0gc2lkZUZsYWcgKiBsYWJlbC5wYWRkaW5nO1xuICAgIGNvbnN0IGxhYmVsR3JpZCA9IHRoaXMubGFiZWwuZ3JpZDtcbiAgICBjb25zdCBzZXBhcmF0b3JEYXRhID0gW107XG4gICAgdHJlZUxhYmVscy5mb3JFYWNoKChkYXR1bSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGlzTGVhZiA9ICFkYXR1bS5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICBsZXQgdmlzaWJsZSA9IHNldExhYmVsUHJvcHMoZGF0dW0sIGluZGV4KTtcbiAgICAgIHRlbXBUZXh0LnggPSBsYWJlbFg7XG4gICAgICB0ZW1wVGV4dC55ID0gaW5kZXggPT09IDAgJiYgaXNDYXB0aW9uRW5hYmxlZCA/IHRpdGxlLnNwYWNpbmcgPz8gMCA6IDA7XG4gICAgICB0ZW1wVGV4dC5yb3RhdGlvbkNlbnRlclggPSBsYWJlbFg7XG4gICAgICBpZiAoaXNMZWFmKSB7XG4gICAgICAgIHRlbXBUZXh0LnJvdGF0aW9uID0gY29uZmlndXJlZFJvdGF0aW9uO1xuICAgICAgICB0ZW1wVGV4dC50ZXh0QWxpZ24gPSBcImVuZFwiO1xuICAgICAgICB0ZW1wVGV4dC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYXZhaWxhYmxlUmFuZ2UgPSBkYXR1bS5sZWFmQ291bnQgKiBiYW5kd2lkdGg7XG4gICAgICAgIGNvbnN0IGJib3gyID0gbGFiZWxCQm94ZXMuZ2V0KGluZGV4KTtcbiAgICAgICAgdGVtcFRleHQudHJhbnNsYXRpb25YIC09IG1heExlYWZMYWJlbFdpZHRoIC0gbGluZUhlaWdodCArIHRoaXMubGFiZWwucGFkZGluZztcbiAgICAgICAgaWYgKGJib3gyICYmIGJib3gyLndpZHRoID4gYXZhaWxhYmxlUmFuZ2UpIHtcbiAgICAgICAgICB2aXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgbGFiZWxCQm94ZXMuZGVsZXRlKGluZGV4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZW1wVGV4dC5yb3RhdGlvbiA9IGlzSG9yaXpvbnRhbCA/IGRlZmF1bHRSb3RhdGlvbiA6IC1NYXRoLlBJIC8gMjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRhdHVtLnBhcmVudCAmJiBpc0xhYmVsVHJlZSkge1xuICAgICAgICBjb25zdCB5ID0gaXNMZWFmID8gZGF0dW0uc2NyZWVuWCAtIGJhbmR3aWR0aCAvIDIgOiBkYXR1bS5zY3JlZW5YIC0gZGF0dW0ubGVhZkNvdW50ICogYmFuZHdpZHRoIC8gMjtcbiAgICAgICAgaWYgKGlzTGVhZikge1xuICAgICAgICAgIGlmIChkYXR1bS5udW1iZXIgIT09IGRhdHVtLmNoaWxkcmVuLmxlbmd0aCAtIDEgfHwgbGFiZWxHcmlkKSB7XG4gICAgICAgICAgICBzZXBhcmF0b3JEYXRhLnB1c2goe1xuICAgICAgICAgICAgICB5LFxuICAgICAgICAgICAgICB4MTogMCxcbiAgICAgICAgICAgICAgeDI6IC1tYXhMZWFmTGFiZWxXaWR0aCAtIHRoaXMubGFiZWwucGFkZGluZyAqIDJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCB4ID0gLW1heExlYWZMYWJlbFdpZHRoIC0gdGhpcy5sYWJlbC5wYWRkaW5nICogMiArIGRhdHVtLnNjcmVlblk7XG4gICAgICAgICAgc2VwYXJhdG9yRGF0YS5wdXNoKHtcbiAgICAgICAgICAgIHksXG4gICAgICAgICAgICB4MTogeCArIGxpbmVIZWlnaHQsXG4gICAgICAgICAgICB4MjogeFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgcHJvcHM7XG4gICAgICBpZiAodmlzaWJsZSkge1xuICAgICAgICBjb25zdCBiYm94MiA9IFRyYW5zZm9ybWFibGUudG9DYW52YXModGVtcFRleHQpO1xuICAgICAgICBpZiAoYmJveDIpIHtcbiAgICAgICAgICBsYWJlbEJCb3hlcy5zZXQoaW5kZXgsIGJib3gyKTtcbiAgICAgICAgfVxuICAgICAgICBwcm9wcyA9IHsgLi4uY29weUxhYmVsUHJvcHModGVtcFRleHQpLCB2aXNpYmxlIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYWJlbEJCb3hlcy5kZWxldGUoaW5kZXgpO1xuICAgICAgICBwcm9wcyA9IHsgdmlzaWJsZSB9O1xuICAgICAgfVxuICAgICAgdGlja0xhYmVsTGF5b3V0LnB1c2gocHJvcHMpO1xuICAgIH0pO1xuICAgIGxldCBtaW5YID0gMDtcbiAgICBzZXBhcmF0b3JEYXRhLmZvckVhY2goKGQpID0+IG1pblggPSBNYXRoLm1pbihtaW5YLCBkLngyKSk7XG4gICAgc2VwYXJhdG9yRGF0YS5wdXNoKHtcbiAgICAgIHk6IE1hdGgubWF4KHJhbmdlU3RhcnQsIHJhbmdlRW5kKSxcbiAgICAgIHgxOiAwLFxuICAgICAgeDI6IG1pblhcbiAgICB9KTtcbiAgICBjb25zdCBzZXBhcmF0b3JMYXlvdXQgPSBbXTtcbiAgICBjb25zdCBzZXBhcmF0b3JCb3hlcyA9IFtdO1xuICAgIGNvbnN0IGVwc2lsb24yID0gMWUtNztcbiAgICBzZXBhcmF0b3JEYXRhLmZvckVhY2goKGRhdHVtKSA9PiB7XG4gICAgICBpZiAoZGF0dW0ueSA+PSByYW5nZTNbMF0gLSBlcHNpbG9uMiAmJiBkYXR1bS55IDw9IHJhbmdlM1sxXSArIGVwc2lsb24yKSB7XG4gICAgICAgIGNvbnN0IHsgeDEsIHgyLCB5IH0gPSBkYXR1bTtcbiAgICAgICAgY29uc3Qgc2VwYXJhdG9yQm94ID0gbmV3IEJCb3goTWF0aC5taW4oeDEsIHgyKSwgeSwgTWF0aC5hYnMoeDEgLSB4MiksIDApO1xuICAgICAgICBzZXBhcmF0b3JCb3hlcy5wdXNoKHNlcGFyYXRvckJveCk7XG4gICAgICAgIHNlcGFyYXRvckxheW91dC5wdXNoKHsgeDEsIHgyLCB5IH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGF4aXNMaW5lTGF5b3V0ID0gW107XG4gICAgY29uc3QgYXhpc0xpbmVCb3hlcyA9IFtdO1xuICAgIGNvbnN0IGxpbmVDb3VudCA9IHRpY2tUcmVlTGF5b3V0ID8gdGlja1RyZWVMYXlvdXQuZGVwdGggKyAxIDogMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCB2aXNpYmxlID0gbGFiZWxzLmxlbmd0aCA+IDAgJiYgKGkgPT09IDAgfHwgbGFiZWxHcmlkICYmIGlzTGFiZWxUcmVlKTtcbiAgICAgIGNvbnN0IHggPSBpID4gMCA/IC1tYXhMZWFmTGFiZWxXaWR0aCAtIHRoaXMubGFiZWwucGFkZGluZyAqIDIgLSAoaSAtIDEpICogbGluZUhlaWdodCA6IDA7XG4gICAgICBjb25zdCBsaW5lQm94ID0gbmV3IEJCb3goeCwgTWF0aC5taW4oLi4ucmFuZ2UzKSwgMCwgTWF0aC5hYnMocmFuZ2UzWzFdIC0gcmFuZ2UzWzBdKSk7XG4gICAgICBheGlzTGluZUJveGVzLnB1c2gobGluZUJveCk7XG4gICAgICBheGlzTGluZUxheW91dC5wdXNoKHsgeCwgeTE6IHJhbmdlM1swXSwgeTI6IHJhbmdlM1sxXSwgdmlzaWJsZSB9KTtcbiAgICB9XG4gICAgY29uc3QgYmJveCA9IEJCb3gubWVyZ2UoaXRlcmF0ZShsYWJlbEJCb3hlcy52YWx1ZXMoKSwgc2VwYXJhdG9yQm94ZXMsIGF4aXNMaW5lQm94ZXMpKTtcbiAgICBjb25zdCB0cmFuc2Zvcm1lZEJCb3ggPSB0aGlzLmdldFRyYW5zZm9ybUJveChiYm94KTtcbiAgICByZXR1cm4ge1xuICAgICAgYmJveDogdHJhbnNmb3JtZWRCQm94LFxuICAgICAgdGlja0xhYmVsTGF5b3V0LFxuICAgICAgc2VwYXJhdG9yTGF5b3V0LFxuICAgICAgYXhpc0xpbmVMYXlvdXRcbiAgICB9O1xuICB9XG4gIGNhbGN1bGF0ZUxheW91dCgpIHtcbiAgICBjb25zdCB7IGF4aXNMaW5lTGF5b3V0LCBzZXBhcmF0b3JMYXlvdXQsIHRpY2tMYWJlbExheW91dCwgYmJveCB9ID0gdGhpcy5jb21wdXRlTGF5b3V0KCk7XG4gICAgdGhpcy5jb21wdXRlZExheW91dCA9IHsgYXhpc0xpbmVMYXlvdXQsIHNlcGFyYXRvckxheW91dCwgdGlja0xhYmVsTGF5b3V0IH07XG4gICAgcmV0dXJuIHsgYmJveCwgcHJpbWFyeVRpY2tDb3VudDogdm9pZCAwIH07XG4gIH1cbn07XG5Hcm91cGVkQ2F0ZWdvcnlBeGlzLmNsYXNzTmFtZSA9IFwiR3JvdXBlZENhdGVnb3J5QXhpc1wiO1xuR3JvdXBlZENhdGVnb3J5QXhpcy50eXBlID0gXCJncm91cGVkLWNhdGVnb3J5XCI7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEdyb3VwZWRDYXRlZ29yeUF4aXMucHJvdG90eXBlLCBcImxhYmVsQ29sb3JcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL21vZHVsZS9tb2R1bGUudHNcbnZhciBCYXNlTW9kdWxlSW5zdGFuY2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZGVzdHJveUZucyA9IFtdO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgZm9yIChjb25zdCBkZXN0cm95Rm4gb2YgdGhpcy5kZXN0cm95Rm5zKSB7XG4gICAgICBkZXN0cm95Rm4oKTtcbiAgICB9XG4gIH1cbn07XG52YXIgTW9kdWxlUmVnaXN0cnkgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubW9kdWxlcyA9IFtdO1xuICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLmRlcGVuZGVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIHJlZ2lzdGVyKC4uLm1vZHVsZXMpIHtcbiAgICBmb3IgKGNvbnN0IG1vZHVsZSBvZiBtb2R1bGVzKSB7XG4gICAgICB0aGlzLnJlZ2lzdGVyRGVwZW5kZW5jaWVzKG1vZHVsZSk7XG4gICAgICBjb25zdCBvdGhlck1vZHVsZSA9IHRoaXMubW9kdWxlcy5maW5kKFxuICAgICAgICAob3RoZXIpID0+IG1vZHVsZS50eXBlID09PSBvdGhlci50eXBlICYmIG1vZHVsZS5vcHRpb25zS2V5ID09PSBvdGhlci5vcHRpb25zS2V5ICYmIG1vZHVsZS5pZGVudGlmaWVyID09PSBvdGhlci5pZGVudGlmaWVyXG4gICAgICApO1xuICAgICAgaWYgKG90aGVyTW9kdWxlKSB7XG4gICAgICAgIGlmIChtb2R1bGUucGFja2FnZVR5cGUgPT09IFwiZW50ZXJwcmlzZVwiICYmIG90aGVyTW9kdWxlLnBhY2thZ2VUeXBlID09PSBcImNvbW11bml0eVwiKSB7XG4gICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLm1vZHVsZXMuaW5kZXhPZihvdGhlck1vZHVsZSk7XG4gICAgICAgICAgdGhpcy5tb2R1bGVzLnNwbGljZShpbmRleCwgMSwgbW9kdWxlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tb2R1bGVzLnB1c2gobW9kdWxlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaGFzRW50ZXJwcmlzZU1vZHVsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMubW9kdWxlcy5zb21lKChtKSA9PiBtLnBhY2thZ2VUeXBlID09PSBcImVudGVycHJpc2VcIik7XG4gIH1cbiAgKmJ5VHlwZSguLi50eXBlcykge1xuICAgIGNvbnN0IHsgZGVwZW5kZW50cyB9ID0gdGhpcztcbiAgICBjb25zdCB5aWVsZGVkID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGNvbnN0IG1heENvdW50ID0gMztcbiAgICBjb25zdCBtb2R1bGVzQnlUeXBlID0gdGhpcy5tb2R1bGVzLmZpbHRlcigobW9kdWxlKSA9PiB0eXBlcy5pbmNsdWRlcyhtb2R1bGUudHlwZSkpO1xuICAgIGRvIHtcbiAgICAgIGZvciAoY29uc3QgbW9kdWxlIG9mIG1vZHVsZXNCeVR5cGUpIHtcbiAgICAgICAgaWYgKHlpZWxkZWQuaGFzKG1vZHVsZS5vcHRpb25zS2V5KSB8fCBkZXBlbmRlbnRzLmhhcyhtb2R1bGUub3B0aW9uc0tleSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCBtb2R1bGU7XG4gICAgICAgIHlpZWxkZWQuYWRkKG1vZHVsZS5vcHRpb25zS2V5KTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCBkZXBlbmRlbmNpZXNdIG9mIGRlcGVuZGVudHMuZW50cmllcygpKSB7XG4gICAgICAgICAgZGVwZW5kZW5jaWVzLmRlbGV0ZShtb2R1bGUub3B0aW9uc0tleSk7XG4gICAgICAgICAgaWYgKGRlcGVuZGVuY2llcy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICBkZXBlbmRlbnRzLmRlbGV0ZShrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY291bnQrKztcbiAgICB9IHdoaWxlICh5aWVsZGVkLnNpemUgPCBtb2R1bGVzQnlUeXBlLmxlbmd0aCAmJiBjb3VudCA8IG1heENvdW50KTtcbiAgICBpZiAoZGVwZW5kZW50cy5zaXplID4gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgcmVzb2x2ZSBtb2R1bGUgZGVwZW5kZW5jaWVzOiBbJHtbLi4uZGVwZW5kZW50cy5rZXlzKCldfV1gKTtcbiAgICB9XG4gIH1cbiAgcmVnaXN0ZXJEZXBlbmRlbmNpZXMobW9kdWxlKSB7XG4gICAgaWYgKG1vZHVsZS5kZXBlbmRlbmNpZXMgPT0gbnVsbCB8fCBtb2R1bGUuZGVwZW5kZW5jaWVzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybjtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBtb2R1bGUuZGVwZW5kZW5jaWVzKSB7XG4gICAgICBjb25zdCBkZXBlbmRlbmNpZXMgPSB0aGlzLmRlcGVuZGVuY2llcy5nZXQoa2V5KSA/PyAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgZGVwZW5kZW5jaWVzLmFkZChtb2R1bGUub3B0aW9uc0tleSk7XG4gICAgICB0aGlzLmRlcGVuZGVuY2llcy5zZXQoa2V5LCBkZXBlbmRlbmNpZXMpO1xuICAgIH1cbiAgICB0aGlzLmRlcGVuZGVudHMuc2V0KG1vZHVsZS5vcHRpb25zS2V5LCBuZXcgU2V0KG1vZHVsZS5kZXBlbmRlbmNpZXMpKTtcbiAgfVxufTtcbnZhciBtb2R1bGVSZWdpc3RyeSA9IG5ldyBNb2R1bGVSZWdpc3RyeSgpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2FzeW5jLnRzXG5mdW5jdGlvbiBzbGVlcChzbGVlcFRpbWVvdXRNcykge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHJlc29sdmUodm9pZCAwKSwgc2xlZXBUaW1lb3V0TXMpO1xuICB9KTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9tdXRleC50c1xudmFyIE11dGV4ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmF2YWlsYWJsZSA9IHRydWU7XG4gICAgdGhpcy5hY3F1aXJlUXVldWUgPSBbXTtcbiAgfVxuICBhY3F1aXJlKGNiKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICB0aGlzLmFjcXVpcmVRdWV1ZS5wdXNoKFtjYiwgcmVzb2x2ZV0pO1xuICAgICAgaWYgKHRoaXMuYXZhaWxhYmxlKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hOZXh0KCkuY2F0Y2goKGUpID0+IExvZ2dlci5lcnJvck9uY2UoZSkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGFjcXVpcmVJbW1lZGlhdGVseShjYikge1xuICAgIGlmICghdGhpcy5hdmFpbGFibGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5hY3F1aXJlKGNiKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBhc3luYyB3YWl0Rm9yQ2xlYXJBY3F1aXJlUXVldWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWNxdWlyZShhc3luYyAoKSA9PiB2b2lkIDApO1xuICB9XG4gIGFzeW5jIGRpc3BhdGNoTmV4dCgpIHtcbiAgICB0aGlzLmF2YWlsYWJsZSA9IGZhbHNlO1xuICAgIGxldCBbbmV4dCwgZG9uZV0gPSB0aGlzLmFjcXVpcmVRdWV1ZS5zaGlmdCgpID8/IFtdO1xuICAgIHdoaWxlIChuZXh0KSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBuZXh0KCk7XG4gICAgICAgIGRvbmU/LigpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgTG9nZ2VyLmVycm9yKFwibXV0ZXggY2FsbGJhY2sgZXJyb3JcIiwgZXJyb3IpO1xuICAgICAgICBkb25lPy4oKTtcbiAgICAgIH1cbiAgICAgIFtuZXh0LCBkb25lXSA9IHRoaXMuYWNxdWlyZVF1ZXVlLnNoaWZ0KCkgPz8gW107XG4gICAgfVxuICAgIHRoaXMuYXZhaWxhYmxlID0gdHJ1ZTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9vYnNlcnZhYmxlLnRzXG52YXIgT2JzZXJ2YWJsZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5ldmVudExpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGxpc3RlbmVyKSB7XG4gICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBRyBDaGFydHMgLSBsaXN0ZW5lciBtdXN0IGJlIGEgRnVuY3Rpb25cIik7XG4gICAgfVxuICAgIGNvbnN0IGV2ZW50VHlwZUxpc3RlbmVycyA9IHRoaXMuZXZlbnRMaXN0ZW5lcnMuZ2V0KGV2ZW50VHlwZSk7XG4gICAgaWYgKGV2ZW50VHlwZUxpc3RlbmVycykge1xuICAgICAgZXZlbnRUeXBlTGlzdGVuZXJzLmFkZChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMuc2V0KGV2ZW50VHlwZSwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW2xpc3RlbmVyXSkpO1xuICAgIH1cbiAgfVxuICByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgdGhpcy5ldmVudExpc3RlbmVycy5nZXQodHlwZSk/LmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgaWYgKHRoaXMuZXZlbnRMaXN0ZW5lcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgdGhpcy5ldmVudExpc3RlbmVycy5kZWxldGUodHlwZSk7XG4gICAgfVxuICB9XG4gIGhhc0V2ZW50TGlzdGVuZXIodHlwZSkge1xuICAgIHJldHVybiB0aGlzLmV2ZW50TGlzdGVuZXJzLmhhcyh0eXBlKTtcbiAgfVxuICBjbGVhckV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMuY2xlYXIoKTtcbiAgfVxuICBmaXJlRXZlbnQoZXZlbnQpIHtcbiAgICB0aGlzLmV2ZW50TGlzdGVuZXJzLmdldChldmVudC50eXBlKT8uZm9yRWFjaCgobGlzdGVuZXIpID0+IGxpc3RlbmVyKGV2ZW50KSk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvcGFkZGluZy50c1xudmFyIFBhZGRpbmcgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IodG9wID0gMCwgcmlnaHQgPSB0b3AsIGJvdHRvbSA9IHRvcCwgbGVmdCA9IHJpZ2h0KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnRvcCA9IHRvcDtcbiAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgdGhpcy5ib3R0b20gPSBib3R0b207XG4gICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIFBhZGRpbmcucHJvdG90eXBlLCBcInRvcFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIFBhZGRpbmcucHJvdG90eXBlLCBcInJpZ2h0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgUGFkZGluZy5wcm90b3R5cGUsIFwiYm90dG9tXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgUGFkZGluZy5wcm90b3R5cGUsIFwibGVmdFwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9yZW5kZXIudHNcbmZ1bmN0aW9uIGRlYm91bmNlZEFuaW1hdGlvbkZyYW1lKGNiKSB7XG4gIHJldHVybiBidWlsZFNjaGVkdWxlcigoaW5uZXJDYiwgX2RlbGF5TXMpID0+IGdldFdpbmRvdygpLnJlcXVlc3RBbmltYXRpb25GcmFtZShpbm5lckNiKSwgY2IpO1xufVxuZnVuY3Rpb24gZGVib3VuY2VkQ2FsbGJhY2soY2IpIHtcbiAgcmV0dXJuIGJ1aWxkU2NoZWR1bGVyKChpbm5lckNiLCBkZWxheU1zID0gMCkgPT4gc2V0VGltZW91dChpbm5lckNiLCBkZWxheU1zKSwgY2IpO1xufVxuZnVuY3Rpb24gYnVpbGRTY2hlZHVsZXIoc2NoZWR1bGVGbiwgY2IpIHtcbiAgbGV0IHNjaGVkdWxlQ291bnQgPSAwO1xuICBsZXQgcHJvbWlzZVJ1bm5pbmcgPSBmYWxzZTtcbiAgbGV0IGF3YWl0aW5nUHJvbWlzZTtcbiAgbGV0IGF3YWl0aW5nRG9uZTtcbiAgY29uc3QgYnVzeSA9ICgpID0+IHtcbiAgICByZXR1cm4gcHJvbWlzZVJ1bm5pbmc7XG4gIH07XG4gIGNvbnN0IGRvbmUgPSAoKSA9PiB7XG4gICAgcHJvbWlzZVJ1bm5pbmcgPSBmYWxzZTtcbiAgICBhd2FpdGluZ0RvbmU/LigpO1xuICAgIGF3YWl0aW5nRG9uZSA9IHZvaWQgMDtcbiAgICBhd2FpdGluZ1Byb21pc2UgPSB2b2lkIDA7XG4gICAgaWYgKHNjaGVkdWxlQ291bnQgPiAwKSB7XG4gICAgICBzY2hlZHVsZUZuKHNjaGVkdWxlQ2IpO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc2NoZWR1bGVDYiA9ICgpID0+IHtcbiAgICBjb25zdCBjb3VudCA9IHNjaGVkdWxlQ291bnQ7XG4gICAgc2NoZWR1bGVDb3VudCA9IDA7XG4gICAgcHJvbWlzZVJ1bm5pbmcgPSB0cnVlO1xuICAgIGNvbnN0IG1heWJlUHJvbWlzZSA9IGNiKHsgY291bnQgfSk7XG4gICAgaWYgKCFtYXliZVByb21pc2UpIHtcbiAgICAgIGRvbmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbWF5YmVQcm9taXNlLnRoZW4oZG9uZSwgZG9uZSk7XG4gIH07XG4gIHJldHVybiB7XG4gICAgc2NoZWR1bGUoZGVsYXlNcykge1xuICAgICAgaWYgKHNjaGVkdWxlQ291bnQgPT09IDAgJiYgIWJ1c3koKSkge1xuICAgICAgICBzY2hlZHVsZUZuKHNjaGVkdWxlQ2IsIGRlbGF5TXMpO1xuICAgICAgfVxuICAgICAgc2NoZWR1bGVDb3VudCsrO1xuICAgIH0sXG4gICAgYXN5bmMgYXdhaXQoKSB7XG4gICAgICBpZiAoIWJ1c3koKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoYXdhaXRpbmdQcm9taXNlID09IG51bGwpIHtcbiAgICAgICAgYXdhaXRpbmdQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICBhd2FpdGluZ0RvbmUgPSByZXNvbHZlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChidXN5KCkpIHtcbiAgICAgICAgYXdhaXQgYXdhaXRpbmdQcm9taXNlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9ldmVudEVtaXR0ZXIudHNcbnZhciBFdmVudEVtaXR0ZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZXZlbnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICAvKipcbiAgICogUmVnaXN0ZXJzIGFuIGV2ZW50IGxpc3RlbmVyLlxuICAgKiBAcGFyYW0gZXZlbnROYW1lIFRoZSBldmVudCBuYW1lIHRvIGxpc3RlbiBmb3IuXG4gICAqIEBwYXJhbSBsaXN0ZW5lciBUaGUgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCBvbiB0aGUgZXZlbnQuXG4gICAqIEByZXR1cm5zIEEgZnVuY3Rpb24gdG8gdW5yZWdpc3RlciB0aGUgbGlzdGVuZXIuXG4gICAqL1xuICBvbihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgaWYgKCF0aGlzLmV2ZW50cy5oYXMoZXZlbnROYW1lKSkge1xuICAgICAgdGhpcy5ldmVudHMuc2V0KGV2ZW50TmFtZSwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSk7XG4gICAgfVxuICAgIHRoaXMuZXZlbnRzLmdldChldmVudE5hbWUpPy5hZGQobGlzdGVuZXIpO1xuICAgIHJldHVybiAoKSA9PiB0aGlzLm9mZihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgfVxuICAvKipcbiAgICogVW5yZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIuXG4gICAqIEBwYXJhbSBldmVudE5hbWUgVGhlIGV2ZW50IG5hbWUgdG8gc3RvcCBsaXN0ZW5pbmcgZm9yLlxuICAgKiBAcGFyYW0gbGlzdGVuZXIgVGhlIGNhbGxiYWNrIHRvIGJlIHJlbW92ZWQuXG4gICAqL1xuICBvZmYoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgIGNvbnN0IGV2ZW50TGlzdGVuZXJzID0gdGhpcy5ldmVudHMuZ2V0KGV2ZW50TmFtZSk7XG4gICAgaWYgKGV2ZW50TGlzdGVuZXJzKSB7XG4gICAgICBldmVudExpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xuICAgICAgaWYgKGV2ZW50TGlzdGVuZXJzLnNpemUgPT09IDApIHtcbiAgICAgICAgdGhpcy5ldmVudHMuZGVsZXRlKGV2ZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBFbWl0cyBhbiBldmVudCB0byBhbGwgcmVnaXN0ZXJlZCBsaXN0ZW5lcnMuXG4gICAqIEBwYXJhbSBldmVudE5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGVtaXQuXG4gICAqIEBwYXJhbSBldmVudCBUaGUgZXZlbnQgcGF5bG9hZC5cbiAgICovXG4gIGVtaXQoZXZlbnROYW1lLCBldmVudCkge1xuICAgIHRoaXMuZXZlbnRzLmdldChldmVudE5hbWUpPy5mb3JFYWNoKChjYWxsYmFjazIpID0+IGNhbGxiYWNrMihldmVudCkpO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhcnMgYWxsIGxpc3RlbmVycyBmb3IgYSBzcGVjaWZpYyBldmVudCBvciBhbGwgZXZlbnRzIGlmIG5vIGV2ZW50IG5hbWUgaXMgcHJvdmlkZWQuXG4gICAqIEBwYXJhbSBldmVudE5hbWUgKE9wdGlvbmFsKSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gY2xlYXIgbGlzdGVuZXJzIGZvci4gSWYgbm90IHByb3ZpZGVkLCBhbGwgbGlzdGVuZXJzIGZvciBhbGwgZXZlbnRzIGFyZSBjbGVhcmVkLlxuICAgKi9cbiAgY2xlYXIoZXZlbnROYW1lKSB7XG4gICAgaWYgKGV2ZW50TmFtZSkge1xuICAgICAgdGhpcy5ldmVudHMuZGVsZXRlKGV2ZW50TmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZXZlbnRzLmNsZWFyKCk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9sYXlvdXQvbGF5b3V0TWFuYWdlci50c1xudmFyIExheW91dEVsZW1lbnQgPSAvKiBAX19QVVJFX18gKi8gKChMYXlvdXRFbGVtZW50MikgPT4ge1xuICBMYXlvdXRFbGVtZW50MltMYXlvdXRFbGVtZW50MltcIkNhcHRpb25cIl0gPSAwXSA9IFwiQ2FwdGlvblwiO1xuICBMYXlvdXRFbGVtZW50MltMYXlvdXRFbGVtZW50MltcIkxlZ2VuZFwiXSA9IDFdID0gXCJMZWdlbmRcIjtcbiAgTGF5b3V0RWxlbWVudDJbTGF5b3V0RWxlbWVudDJbXCJUb29sYmFyXCJdID0gMl0gPSBcIlRvb2xiYXJcIjtcbiAgTGF5b3V0RWxlbWVudDJbTGF5b3V0RWxlbWVudDJbXCJOYXZpZ2F0b3JcIl0gPSAzXSA9IFwiTmF2aWdhdG9yXCI7XG4gIExheW91dEVsZW1lbnQyW0xheW91dEVsZW1lbnQyW1wiT3ZlcmxheVwiXSA9IDRdID0gXCJPdmVybGF5XCI7XG4gIHJldHVybiBMYXlvdXRFbGVtZW50Mjtcbn0pKExheW91dEVsZW1lbnQgfHwge30pO1xudmFyIExheW91dE1hbmFnZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZXZlbnRzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIHRoaXMuZWxlbWVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIGFkZExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICByZXR1cm4gdGhpcy5ldmVudHMub24oZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gIH1cbiAgcmVnaXN0ZXJFbGVtZW50KGVsZW1lbnQyLCBsaXN0ZW5lcikge1xuICAgIGlmICh0aGlzLmVsZW1lbnRzLmhhcyhlbGVtZW50MikpIHtcbiAgICAgIHRoaXMuZWxlbWVudHMuZ2V0KGVsZW1lbnQyKS5hZGQobGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVsZW1lbnRzLnNldChlbGVtZW50MiwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW2xpc3RlbmVyXSkpO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4gdGhpcy5lbGVtZW50cy5nZXQoZWxlbWVudDIpPy5kZWxldGUobGlzdGVuZXIpO1xuICB9XG4gIGNyZWF0ZUNvbnRleHQod2lkdGgyLCBoZWlnaHQyKSB7XG4gICAgY29uc3QgY29udGV4dCA9IG5ldyBMYXlvdXRDb250ZXh0KHdpZHRoMiwgaGVpZ2h0Mik7XG4gICAgZm9yIChjb25zdCBlbGVtZW50MiBvZiBPYmplY3QudmFsdWVzKExheW91dEVsZW1lbnQpKSB7XG4gICAgICBpZiAodHlwZW9mIGVsZW1lbnQyICE9PSBcIm51bWJlclwiKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHRoaXMuZWxlbWVudHMuZ2V0KGVsZW1lbnQyKT8uZm9yRWFjaCgobGlzdGVuZXIpID0+IGxpc3RlbmVyKGNvbnRleHQpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRleHQ7XG4gIH1cbiAgZW1pdExheW91dENvbXBsZXRlKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBldmVudFR5cGUgPSBcImxheW91dDpjb21wbGV0ZVwiO1xuICAgIGNvbnN0IHsgd2lkdGg6IHdpZHRoMiwgaGVpZ2h0OiBoZWlnaHQyIH0gPSBjb250ZXh0O1xuICAgIHRoaXMuZXZlbnRzLmVtaXQoZXZlbnRUeXBlLCB7XG4gICAgICB0eXBlOiBldmVudFR5cGUsXG4gICAgICBheGVzOiBvcHRpb25zLmF4ZXMgPz8gW10sXG4gICAgICBjaGFydDogeyB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIgfSxcbiAgICAgIGNsaXBTZXJpZXM6IG9wdGlvbnMuY2xpcFNlcmllcyA/PyBmYWxzZSxcbiAgICAgIHNlcmllczogb3B0aW9ucy5zZXJpZXNcbiAgICB9KTtcbiAgfVxufTtcbnZhciBMYXlvdXRDb250ZXh0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih3aWR0aDIsIGhlaWdodDIpIHtcbiAgICB0aGlzLndpZHRoID0gd2lkdGgyO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0MjtcbiAgICB0aGlzLmxheW91dEJveCA9IG5ldyBCQm94KDAsIDAsIHdpZHRoMiwgaGVpZ2h0Mik7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2NoYXJ0Q2FwdGlvbnMudHNcbnZhciBDaGFydENhcHRpb25zID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnRpdGxlID0gbmV3IENhcHRpb24oKTtcbiAgICB0aGlzLnN1YnRpdGxlID0gbmV3IENhcHRpb24oKTtcbiAgICB0aGlzLmZvb3Rub3RlID0gbmV3IENhcHRpb24oKTtcbiAgfVxuICBwb3NpdGlvbkNhcHRpb25zKGN0eCkge1xuICAgIGNvbnN0IHsgdGl0bGUsIHN1YnRpdGxlLCBmb290bm90ZSB9ID0gdGhpcztcbiAgICBjb25zdCBtYXhIZWlnaHQgPSBjdHgubGF5b3V0Qm94LmhlaWdodCAvIDEwO1xuICAgIGlmICh0aXRsZS5lbmFibGVkKSB7XG4gICAgICBjb25zdCB7IHNwYWNpbmcgPSBzdWJ0aXRsZS5lbmFibGVkID8gQ2FwdGlvbi5TTUFMTF9QQURESU5HIDogQ2FwdGlvbi5MQVJHRV9QQURESU5HIH0gPSB0aXRsZTtcbiAgICAgIHRoaXMucG9zaXRpb25DYXB0aW9uKFwidG9wXCIsIHRpdGxlLCBjdHgubGF5b3V0Qm94LCBtYXhIZWlnaHQpO1xuICAgICAgdGhpcy5zaHJpbmtMYXlvdXRCeUNhcHRpb24oXCJ0b3BcIiwgdGl0bGUsIGN0eC5sYXlvdXRCb3gsIHNwYWNpbmcpO1xuICAgIH1cbiAgICBpZiAoc3VidGl0bGUuZW5hYmxlZCkge1xuICAgICAgdGhpcy5wb3NpdGlvbkNhcHRpb24oXCJ0b3BcIiwgc3VidGl0bGUsIGN0eC5sYXlvdXRCb3gsIG1heEhlaWdodCk7XG4gICAgICB0aGlzLnNocmlua0xheW91dEJ5Q2FwdGlvbihcInRvcFwiLCBzdWJ0aXRsZSwgY3R4LmxheW91dEJveCwgc3VidGl0bGUuc3BhY2luZyk7XG4gICAgfVxuICAgIGlmIChmb290bm90ZS5lbmFibGVkKSB7XG4gICAgICB0aGlzLnBvc2l0aW9uQ2FwdGlvbihcImJvdHRvbVwiLCBmb290bm90ZSwgY3R4LmxheW91dEJveCwgbWF4SGVpZ2h0KTtcbiAgICAgIHRoaXMuc2hyaW5rTGF5b3V0QnlDYXB0aW9uKFwiYm90dG9tXCIsIGZvb3Rub3RlLCBjdHgubGF5b3V0Qm94LCBmb290bm90ZS5zcGFjaW5nKTtcbiAgICB9XG4gIH1cbiAgcG9zaXRpb25BYnNvbHV0ZUNhcHRpb25zKGN0eCkge1xuICAgIGNvbnN0IHsgdGl0bGUsIHN1YnRpdGxlLCBmb290bm90ZSB9ID0gdGhpcztcbiAgICBjb25zdCB7IHJlY3QgfSA9IGN0eC5zZXJpZXM7XG4gICAgZm9yIChjb25zdCBjYXB0aW9uIG9mIFt0aXRsZSwgc3VidGl0bGUsIGZvb3Rub3RlXSkge1xuICAgICAgaWYgKGNhcHRpb24ubGF5b3V0U3R5bGUgIT09IFwib3ZlcmxheVwiKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGlmIChjYXB0aW9uLnRleHRBbGlnbiA9PT0gXCJsZWZ0XCIpIHtcbiAgICAgICAgY2FwdGlvbi5ub2RlLnggPSByZWN0LnggKyBjYXB0aW9uLnBhZGRpbmc7XG4gICAgICB9IGVsc2UgaWYgKGNhcHRpb24udGV4dEFsaWduID09PSBcInJpZ2h0XCIpIHtcbiAgICAgICAgY29uc3QgYmJveCA9IGNhcHRpb24ubm9kZS5nZXRCQm94KCk7XG4gICAgICAgIGNhcHRpb24ubm9kZS54ID0gcmVjdC54ICsgcmVjdC53aWR0aCAtIGJib3gud2lkdGggLSBjYXB0aW9uLnBhZGRpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbXB1dGVYKGFsaWduLCBsYXlvdXRCb3gpIHtcbiAgICBpZiAoYWxpZ24gPT09IFwibGVmdFwiKSB7XG4gICAgICByZXR1cm4gbGF5b3V0Qm94Lng7XG4gICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gXCJyaWdodFwiKSB7XG4gICAgICByZXR1cm4gbGF5b3V0Qm94LnggKyBsYXlvdXRCb3gud2lkdGg7XG4gICAgfVxuICAgIHJldHVybiBsYXlvdXRCb3gueCArIGxheW91dEJveC53aWR0aCAvIDI7XG4gIH1cbiAgcG9zaXRpb25DYXB0aW9uKHZBbGlnbiwgY2FwdGlvbiwgbGF5b3V0Qm94LCBtYXhIZWlnaHQpIHtcbiAgICBjb25zdCBjb250YWluZXJIZWlnaHQgPSBNYXRoLm1heChUZXh0VXRpbHMuZ2V0TGluZUhlaWdodChjYXB0aW9uLmZvbnRTaXplKSwgbWF4SGVpZ2h0KTtcbiAgICBjYXB0aW9uLm5vZGUueCA9IHRoaXMuY29tcHV0ZVgoY2FwdGlvbi50ZXh0QWxpZ24sIGxheW91dEJveCkgKyBjYXB0aW9uLnBhZGRpbmc7XG4gICAgY2FwdGlvbi5ub2RlLnkgPSBsYXlvdXRCb3gueSArICh2QWxpZ24gPT09IFwidG9wXCIgPyAwIDogbGF5b3V0Qm94LmhlaWdodCkgKyBjYXB0aW9uLnBhZGRpbmc7XG4gICAgY2FwdGlvbi5ub2RlLnRleHRCYXNlbGluZSA9IHZBbGlnbjtcbiAgICBjYXB0aW9uLmNvbXB1dGVUZXh0V3JhcChsYXlvdXRCb3gud2lkdGgsIGNvbnRhaW5lckhlaWdodCk7XG4gIH1cbiAgc2hyaW5rTGF5b3V0QnlDYXB0aW9uKHZBbGlnbiwgY2FwdGlvbiwgbGF5b3V0Qm94LCBzcGFjaW5nID0gMCkge1xuICAgIGlmIChjYXB0aW9uLmxheW91dFN0eWxlID09PSBcImJsb2NrXCIpIHtcbiAgICAgIGNvbnN0IGJib3ggPSBjYXB0aW9uLm5vZGUuZ2V0QkJveCgpO1xuICAgICAgbGF5b3V0Qm94LnNocmluayhcbiAgICAgICAgdkFsaWduID09PSBcInRvcFwiID8gTWF0aC5jZWlsKGJib3gueSAtIGxheW91dEJveC55ICsgYmJveC5oZWlnaHQgKyBzcGFjaW5nKSA6IE1hdGguY2VpbChsYXlvdXRCb3gueSArIGxheW91dEJveC5oZWlnaHQgLSBiYm94LnkgKyBzcGFjaW5nKSxcbiAgICAgICAgdkFsaWduXG4gICAgICApO1xuICAgIH1cbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIENoYXJ0Q2FwdGlvbnMucHJvdG90eXBlLCBcInRpdGxlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgQ2hhcnRDYXB0aW9ucy5wcm90b3R5cGUsIFwic3VidGl0bGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBDaGFydENhcHRpb25zLnByb3RvdHlwZSwgXCJmb290bm90ZVwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9saXN0ZW5lcnMudHNcbnZhciBMaXN0ZW5lcnMgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucmVnaXN0ZXJlZExpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgYWRkTGlzdGVuZXIoZXZlbnRUeXBlLCBoYW5kbGVyKSB7XG4gICAgY29uc3QgcmVjb3JkID0geyBzeW1ib2w6IFN5bWJvbChldmVudFR5cGUpLCBoYW5kbGVyIH07XG4gICAgaWYgKHRoaXMucmVnaXN0ZXJlZExpc3RlbmVycy5oYXMoZXZlbnRUeXBlKSkge1xuICAgICAgdGhpcy5yZWdpc3RlcmVkTGlzdGVuZXJzLmdldChldmVudFR5cGUpLnB1c2gocmVjb3JkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZWdpc3RlcmVkTGlzdGVuZXJzLnNldChldmVudFR5cGUsIFtyZWNvcmRdKTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHRoaXMucmVtb3ZlTGlzdGVuZXIocmVjb3JkLnN5bWJvbCk7XG4gIH1cbiAgcmVtb3ZlTGlzdGVuZXIoZXZlbnRTeW1ib2wpIHtcbiAgICBmb3IgKGNvbnN0IFt0eXBlLCBsaXN0ZW5lcnNdIG9mIHRoaXMucmVnaXN0ZXJlZExpc3RlbmVycy5lbnRyaWVzKCkpIHtcbiAgICAgIGNvbnN0IG1hdGNoSW5kZXggPSBsaXN0ZW5lcnMuZmluZEluZGV4KChsaXN0ZW5lcikgPT4gbGlzdGVuZXIuc3ltYm9sID09PSBldmVudFN5bWJvbCk7XG4gICAgICBpZiAobWF0Y2hJbmRleCA+PSAwKSB7XG4gICAgICAgIGxpc3RlbmVycy5zcGxpY2UobWF0Y2hJbmRleCwgMSk7XG4gICAgICAgIGlmIChsaXN0ZW5lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5yZWdpc3RlcmVkTGlzdGVuZXJzLmRlbGV0ZSh0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZGlzcGF0Y2goZXZlbnRUeXBlLCAuLi5wYXJhbXMpIHtcbiAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuZ2V0TGlzdGVuZXJzQnlUeXBlKGV2ZW50VHlwZSkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxpc3RlbmVyLmhhbmRsZXIoLi4ucGFyYW1zKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgTG9nZ2VyLmVycm9yT25jZShlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZGlzcGF0Y2hXcmFwSGFuZGxlcnMoZXZlbnRUeXBlLCB3cmFwRm4sIC4uLnBhcmFtcykge1xuICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5nZXRMaXN0ZW5lcnNCeVR5cGUoZXZlbnRUeXBlKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgd3JhcEZuKGxpc3RlbmVyLmhhbmRsZXIsIC4uLnBhcmFtcyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIExvZ2dlci5lcnJvck9uY2UoZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldExpc3RlbmVyc0J5VHlwZShldmVudFR5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5yZWdpc3RlcmVkTGlzdGVuZXJzLmdldChldmVudFR5cGUpID8/IFtdO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZWdpc3RlcmVkTGlzdGVuZXJzLmNsZWFyKCk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2Jhc2VNYW5hZ2VyLnRzXG52YXIgQmFzZU1hbmFnZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubGlzdGVuZXJzID0gbmV3IExpc3RlbmVycygpO1xuICAgIHRoaXMuZGVzdHJveUZucyA9IFtdO1xuICB9XG4gIGFkZExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpIHtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lcnMuYWRkTGlzdGVuZXIodHlwZSwgaGFuZGxlcik7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmxpc3RlbmVycy5kZXN0cm95KCk7XG4gICAgdGhpcy5kZXN0cm95Rm5zLmZvckVhY2goKGZuKSA9PiBmbigpKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvaW50ZXJhY3Rpb24vaW50ZXJhY3Rpb25TdGF0ZUxpc3RlbmVyLnRzXG52YXIgSW50ZXJhY3Rpb25TdGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyAoKEludGVyYWN0aW9uU3RhdGUyKSA9PiB7XG4gIEludGVyYWN0aW9uU3RhdGUyW0ludGVyYWN0aW9uU3RhdGUyW1wiRGVmYXVsdFwiXSA9IDMyXSA9IFwiRGVmYXVsdFwiO1xuICBJbnRlcmFjdGlvblN0YXRlMltJbnRlcmFjdGlvblN0YXRlMltcIlpvb21EcmFnXCJdID0gMTZdID0gXCJab29tRHJhZ1wiO1xuICBJbnRlcmFjdGlvblN0YXRlMltJbnRlcmFjdGlvblN0YXRlMltcIkFubm90YXRpb25zXCJdID0gOF0gPSBcIkFubm90YXRpb25zXCI7XG4gIEludGVyYWN0aW9uU3RhdGUyW0ludGVyYWN0aW9uU3RhdGUyW1wiQ29udGV4dE1lbnVcIl0gPSA0XSA9IFwiQ29udGV4dE1lbnVcIjtcbiAgSW50ZXJhY3Rpb25TdGF0ZTJbSW50ZXJhY3Rpb25TdGF0ZTJbXCJBbmltYXRpb25cIl0gPSAyXSA9IFwiQW5pbWF0aW9uXCI7XG4gIEludGVyYWN0aW9uU3RhdGUyW0ludGVyYWN0aW9uU3RhdGUyW1wiQW5ub3RhdGlvbnNTZWxlY3RlZFwiXSA9IDFdID0gXCJBbm5vdGF0aW9uc1NlbGVjdGVkXCI7XG4gIEludGVyYWN0aW9uU3RhdGUyW0ludGVyYWN0aW9uU3RhdGUyW1wiQWxsXCJdID0gNjNdID0gXCJBbGxcIjtcbiAgcmV0dXJuIEludGVyYWN0aW9uU3RhdGUyO1xufSkoSW50ZXJhY3Rpb25TdGF0ZSB8fCB7fSk7XG52YXIgSW50ZXJhY3Rpb25TdGF0ZUxpc3RlbmVyID0gY2xhc3MgZXh0ZW5kcyBCYXNlTWFuYWdlciB7XG4gIC8vIFdyYXBwZXIgdG8gb25seSBicm9hZGNhc3QgZXZlbnRzIHdoZW4gdGhlIEludGVyYWN0aW9uTWFuYWdlciBpcyBhIGdpdmVuIHN0YXRlLlxuICBhZGRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCB0cmlnZ2VyaW5nU3RhdGVzID0gMzIgLyogRGVmYXVsdCAqLykge1xuICAgIHJldHVybiBzdXBlci5hZGRMaXN0ZW5lcih0eXBlLCAoZSkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudFN0YXRlID0gdGhpcy5nZXRTdGF0ZSgpO1xuICAgICAgaWYgKGN1cnJlbnRTdGF0ZSAmIHRyaWdnZXJpbmdTdGF0ZXMpIHtcbiAgICAgICAgaGFuZGxlcihlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9kZXN0cm95LnRzXG52YXIgRGVzdHJveUZucyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5kZXN0cm95Rm5zID0gW107XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRlc3Ryb3lGbnMuZm9yRWFjaCgoZm4pID0+IGZuKCkpO1xuICAgIHRoaXMuZGVzdHJveUZucy5sZW5ndGggPSAwO1xuICB9XG4gIHNldEZucyhkZXN0cm95Rm5zKSB7XG4gICAgdGhpcy5kZXN0cm95KCk7XG4gICAgdGhpcy5kZXN0cm95Rm5zID0gZGVzdHJveUZucztcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdmVyc2lvbi50c1xudmFyIFZFUlNJT04gPSBcIjEwLjMuM1wiO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9hcGkvc3RhdGUvaGlzdG9yeU1hbmFnZXIudHNcbnZhciBOT1RfRk9VTkQgPSBTeW1ib2woXCJwcmV2aW91cy1tZW1lbnRvLW5vdC1mb3VuZFwiKTtcbnZhciBIaXN0b3J5TWFuYWdlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioa2V5TmF2TWFuYWdlcikge1xuICAgIHRoaXMuaGlzdG9yeSA9IFtdO1xuICAgIHRoaXMuaGlzdG9yeUluZGV4ID0gLTE7XG4gICAgdGhpcy5vcmlnaW5hdG9ycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5jbGVhclN0YXRlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLm1heEhpc3RvcnlMZW5ndGggPSAxMDA7XG4gICAgdGhpcy5kZWJ1ZyA9IERlYnVnLmNyZWF0ZSh0cnVlLCBcImhpc3RvcnlcIik7XG4gICAgdGhpcy5kZXN0cm95Rm5zID0gbmV3IERlc3Ryb3lGbnMoKTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMuc2V0Rm5zKFtcbiAgICAgIGtleU5hdk1hbmFnZXIuYWRkTGlzdGVuZXIoXCJ1bmRvXCIsIHRoaXMudW5kby5iaW5kKHRoaXMpLCA2MyAvKiBBbGwgKi8pLFxuICAgICAga2V5TmF2TWFuYWdlci5hZGRMaXN0ZW5lcihcInJlZG9cIiwgdGhpcy5yZWRvLmJpbmQodGhpcyksIDYzIC8qIEFsbCAqLylcbiAgICBdKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveUZucy5kZXN0cm95KCk7XG4gIH1cbiAgYWRkTWVtZW50b09yaWdpbmF0b3Iob3JpZ2luYXRvcikge1xuICAgIHRoaXMub3JpZ2luYXRvcnMuc2V0KG9yaWdpbmF0b3IubWVtZW50b09yaWdpbmF0b3JLZXksIG9yaWdpbmF0b3IpO1xuICAgIHRoaXMuY2xlYXJTdGF0ZS5zZXQob3JpZ2luYXRvci5tZW1lbnRvT3JpZ2luYXRvcktleSwgb3JpZ2luYXRvci5jcmVhdGVNZW1lbnRvKCkpO1xuICAgIHRoaXMuZGVidWdFdmVudChcIkhpc3RvcnkgYWRkIG9yaWdpbmF0b3I6XCIsIG9yaWdpbmF0b3IubWVtZW50b09yaWdpbmF0b3JLZXkpO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMuZGVidWcoYEhpc3RvcnkgY2xlYXI6YCwgT2JqZWN0LmtleXModGhpcy5vcmlnaW5hdG9ycykpO1xuICAgIHRoaXMuaGlzdG9yeSA9IFtdO1xuICAgIHRoaXMuaGlzdG9yeUluZGV4ID0gLTE7XG4gICAgZm9yIChjb25zdCBbbWVtZW50b09yaWdpbmF0b3JLZXksIG9yaWdpbmF0b3JdIG9mIHRoaXMub3JpZ2luYXRvcnMuZW50cmllcygpKSB7XG4gICAgICB0aGlzLmNsZWFyU3RhdGUuc2V0KG1lbWVudG9PcmlnaW5hdG9yS2V5LCBvcmlnaW5hdG9yLmNyZWF0ZU1lbWVudG8oKSk7XG4gICAgfVxuICB9XG4gIHJlY29yZChsYWJlbCwgLi4ub3JpZ2luYXRvcnMpIHtcbiAgICBpZiAodGhpcy5oaXN0b3J5SW5kZXggPCB0aGlzLmhpc3RvcnkubGVuZ3RoIC0gMSkge1xuICAgICAgdGhpcy5oaXN0b3J5ID0gdGhpcy5oaXN0b3J5LnNsaWNlKDAsIHRoaXMuaGlzdG9yeUluZGV4ICsgMSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmhpc3RvcnkubGVuZ3RoID4gdGhpcy5tYXhIaXN0b3J5TGVuZ3RoKSB7XG4gICAgICB0aGlzLmhpc3RvcnkgPSB0aGlzLmhpc3Rvcnkuc2xpY2UoLXRoaXMubWF4SGlzdG9yeUxlbmd0aCk7XG4gICAgfVxuICAgIGNvbnN0IG1lbWVudG9zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IG9yaWdpbmF0b3Igb2Ygb3JpZ2luYXRvcnMpIHtcbiAgICAgIGlmICghdGhpcy5vcmlnaW5hdG9ycy5oYXMob3JpZ2luYXRvci5tZW1lbnRvT3JpZ2luYXRvcktleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBPcmlnaW5hdG9yIFske29yaWdpbmF0b3IubWVtZW50b09yaWdpbmF0b3JLZXl9XSBoYXMgbm90IGJlZW4gYWRkZWQgdG8gdGhlIEhpc3RvcnlNYW5hZ2VyLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIG1lbWVudG9zLnNldChvcmlnaW5hdG9yLm1lbWVudG9PcmlnaW5hdG9yS2V5LCBvcmlnaW5hdG9yLmNyZWF0ZU1lbWVudG8oKSk7XG4gICAgfVxuICAgIHRoaXMuaGlzdG9yeS5wdXNoKHsgbGFiZWwsIG1lbWVudG9zIH0pO1xuICAgIHRoaXMuaGlzdG9yeUluZGV4ID0gdGhpcy5oaXN0b3J5Lmxlbmd0aCAtIDE7XG4gICAgdGhpcy5kZWJ1Z0V2ZW50KGBIaXN0b3J5IHJlY29yZDogWyR7bGFiZWx9XWApO1xuICB9XG4gIHVuZG8oKSB7XG4gICAgY29uc3QgdW5kb0FjdGlvbiA9IHRoaXMuaGlzdG9yeVt0aGlzLmhpc3RvcnlJbmRleF07XG4gICAgaWYgKCF1bmRvQWN0aW9uKVxuICAgICAgcmV0dXJuO1xuICAgIGZvciAoY29uc3QgbWVtZW50b09yaWdpbmF0b3JLZXkgb2YgdW5kb0FjdGlvbi5tZW1lbnRvcy5rZXlzKCkpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzTWVtZW50byA9IHRoaXMuZmluZFByZXZpb3VzTWVtZW50byhtZW1lbnRvT3JpZ2luYXRvcktleSk7XG4gICAgICBpZiAocHJldmlvdXNNZW1lbnRvID09PSBOT1RfRk9VTkQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBwcmV2aW91cyBtZW1lbnRvIGZvciBbJHttZW1lbnRvT3JpZ2luYXRvcktleX1dLmApO1xuICAgICAgfVxuICAgICAgdGhpcy5yZXN0b3JlTWVtZW50byhtZW1lbnRvT3JpZ2luYXRvcktleSwgcHJldmlvdXNNZW1lbnRvKTtcbiAgICB9XG4gICAgdGhpcy5oaXN0b3J5SW5kZXggLT0gMTtcbiAgICB0aGlzLmRlYnVnRXZlbnQoYEhpc3RvcnkgdW5kbzogWyR7dW5kb0FjdGlvbi5sYWJlbH1dYCk7XG4gIH1cbiAgcmVkbygpIHtcbiAgICBjb25zdCByZWRvQWN0aW9uID0gdGhpcy5oaXN0b3J5W3RoaXMuaGlzdG9yeUluZGV4ICsgMV07XG4gICAgaWYgKCFyZWRvQWN0aW9uKVxuICAgICAgcmV0dXJuO1xuICAgIGZvciAoY29uc3QgW21lbWVudG9PcmlnaW5hdG9yS2V5LCBtZW1lbnRvXSBvZiByZWRvQWN0aW9uLm1lbWVudG9zLmVudHJpZXMoKSkge1xuICAgICAgdGhpcy5yZXN0b3JlTWVtZW50byhtZW1lbnRvT3JpZ2luYXRvcktleSwgbWVtZW50byk7XG4gICAgfVxuICAgIHRoaXMuaGlzdG9yeUluZGV4ICs9IDE7XG4gICAgdGhpcy5kZWJ1Z0V2ZW50KGBIaXN0b3J5IHJlZG86IFske3JlZG9BY3Rpb24ubGFiZWx9XWApO1xuICB9XG4gIGZpbmRQcmV2aW91c01lbWVudG8obWVtZW50b09yaWdpbmF0b3JLZXkpIHtcbiAgICBmb3IgKGxldCBpID0gdGhpcy5oaXN0b3J5SW5kZXggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKHRoaXMuaGlzdG9yeVtpXS5tZW1lbnRvcy5oYXMobWVtZW50b09yaWdpbmF0b3JLZXkpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhpc3RvcnlbaV0ubWVtZW50b3MuZ2V0KG1lbWVudG9PcmlnaW5hdG9yS2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuY2xlYXJTdGF0ZS5oYXMobWVtZW50b09yaWdpbmF0b3JLZXkpKSB7XG4gICAgICByZXR1cm4gdGhpcy5jbGVhclN0YXRlLmdldChtZW1lbnRvT3JpZ2luYXRvcktleSk7XG4gICAgfVxuICAgIHJldHVybiBOT1RfRk9VTkQ7XG4gIH1cbiAgcmVzdG9yZU1lbWVudG8obWVtZW50b09yaWdpbmF0b3JLZXksIG1lbWVudG8pIHtcbiAgICB0aGlzLm9yaWdpbmF0b3JzLmdldChtZW1lbnRvT3JpZ2luYXRvcktleSk/LnJlc3RvcmVNZW1lbnRvKFZFUlNJT04sIFZFUlNJT04sIG1lbWVudG8pO1xuICB9XG4gIGRlYnVnRXZlbnQoLi4ubG9nQ29udGVudCkge1xuICAgIHRoaXMuZGVidWcoXG4gICAgICAuLi5sb2dDb250ZW50LFxuICAgICAgdGhpcy5oaXN0b3J5Lm1hcCgoYWN0aW9uLCBpbmRleCkgPT4gaW5kZXggPT09IHRoaXMuaGlzdG9yeUluZGV4ID8gYCoqICR7YWN0aW9uLmxhYmVsfSAqKmAgOiBhY3Rpb24ubGFiZWwpXG4gICAgKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvYXBpL3N0YXRlL21lbWVudG8udHNcbnZhciBNZW1lbnRvQ2FyZXRha2VyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih2ZXJzaW9uKSB7XG4gICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbi5zcGxpdChcIi1cIilbMF07XG4gIH1cbiAgc2F2ZSguLi5vcmlnaW5hdG9ycykge1xuICAgIGNvbnN0IHBhY2tldCA9IHsgdmVyc2lvbjogdGhpcy52ZXJzaW9uIH07XG4gICAgZm9yIChjb25zdCBvcmlnaW5hdG9yIG9mIE9iamVjdC52YWx1ZXMob3JpZ2luYXRvcnMpKSB7XG4gICAgICBwYWNrZXRbb3JpZ2luYXRvci5tZW1lbnRvT3JpZ2luYXRvcktleV0gPSB0aGlzLmVuY29kZShvcmlnaW5hdG9yLCBvcmlnaW5hdG9yLmNyZWF0ZU1lbWVudG8oKSk7XG4gICAgfVxuICAgIHJldHVybiBwYWNrZXQ7XG4gIH1cbiAgcmVzdG9yZShibG9iLCAuLi5vcmlnaW5hdG9ycykge1xuICAgIGlmICh0eXBlb2YgYmxvYiAhPT0gXCJvYmplY3RcIikge1xuICAgICAgTG9nZ2VyLndhcm5PbmNlKGBDb3VsZCBub3QgcmVzdG9yZSBkYXRhIG9mIHR5cGUgWyR7dHlwZW9mIGJsb2J9XSwgZXhwZWN0aW5nIGFuIG9iamVjdCwgaWdub3JpbmcuYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChibG9iID09IG51bGwpIHtcbiAgICAgIExvZ2dlci53YXJuT25jZShgQ291bGQgbm90IHJlc3RvcmUgZGF0YSBvZiB0eXBlIFtudWxsXSwgZXhwZWN0aW5nIGFuIG9iamVjdCwgaWdub3JpbmcuYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghKFwidmVyc2lvblwiIGluIGJsb2IpIHx8IHR5cGVvZiBibG9iLnZlcnNpb24gIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIExvZ2dlci53YXJuT25jZShgQ291bGQgbm90IHJlc3RvcmUgZGF0YSwgbWlzc2luZyBbdmVyc2lvbl0gc3RyaW5nIGluIG9iamVjdCwgaWdub3JpbmcuYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3Qgb3JpZ2luYXRvciBvZiBvcmlnaW5hdG9ycykge1xuICAgICAgaWYgKCEob3JpZ2luYXRvci5tZW1lbnRvT3JpZ2luYXRvcktleSBpbiBibG9iKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1lbWVudG8gPSB0aGlzLmRlY29kZShvcmlnaW5hdG9yLCBibG9iW29yaWdpbmF0b3IubWVtZW50b09yaWdpbmF0b3JLZXldKTtcbiAgICAgIGlmICghb3JpZ2luYXRvci5ndWFyZE1lbWVudG8obWVtZW50bykpIHtcbiAgICAgICAgTG9nZ2VyLndhcm5PbmNlKFxuICAgICAgICAgIGBDb3VsZCBub3QgcmVzdG9yZSBbJHtvcmlnaW5hdG9yLm1lbWVudG9PcmlnaW5hdG9yS2V5fV0gZGF0YSwgdmFsdWUgd2FzIGludmFsaWQsIGlnbm9yaW5nLmAsXG4gICAgICAgICAgbWVtZW50b1xuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBvcmlnaW5hdG9yLnJlc3RvcmVNZW1lbnRvKHRoaXMudmVyc2lvbiwgYmxvYi52ZXJzaW9uLCBtZW1lbnRvKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEVuY29kZSBhIG1lbWVudG8gYXMgYSBzZXJpYWxpemFibGUgb2JqZWN0LCBlbmNvZGluZyBhbnkgbm9uLXNlcmlhbGl6YmxlIHR5cGVzLlxuICAgKi9cbiAgZW5jb2RlKG9yaWdpbmF0b3IsIG1lbWVudG8pIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobWVtZW50bywgdGhpcy5lbmNvZGVUeXBlcykpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBlbmNvZGUgWyR7b3JpZ2luYXRvci5tZW1lbnRvT3JpZ2luYXRvcktleX1dIHZhbHVlIFske2Vycm9yfV0uYCwge1xuICAgICAgICBjYXVzZTogZXJyb3JcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGVjb2RlIGFuIGVuY29kZWQgbWVtZW50bywgZGVjb2RpbmcgYW55IG5vbi1zZXJpYWxpemFibGUgdHlwZXMuXG4gICAqL1xuICBkZWNvZGUob3JpZ2luYXRvciwgZW5jb2RlZCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShlbmNvZGVkKSwgdGhpcy5kZWNvZGVUeXBlcyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGRlY29kZSBbJHtvcmlnaW5hdG9yLm1lbWVudG9PcmlnaW5hdG9yS2V5fV0gdmFsdWUgWyR7ZXJyb3J9XS5gLCB7XG4gICAgICAgIGNhdXNlOiBlcnJvclxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGVuY29kZVR5cGVzKGtleSwgdmFsdWUpIHtcbiAgICBpZiAoaXNEYXRlKHRoaXNba2V5XSkpIHtcbiAgICAgIHJldHVybiB7IF9fdHlwZTogXCJkYXRlXCIsIHZhbHVlOiBTdHJpbmcodGhpc1trZXldKSB9O1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgZGVjb2RlVHlwZXMoa2V5LCB2YWx1ZSkge1xuICAgIGlmIChpc09iamVjdCh0aGlzW2tleV0pICYmIFwiX190eXBlXCIgaW4gdGhpc1trZXldICYmIHRoaXNba2V5XS5fX3R5cGUgPT09IFwiZGF0ZVwiKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUodGhpc1trZXldLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9hcGkvc3RhdGUvc3RhdGVNYW5hZ2VyLnRzXG52YXIgU3RhdGVNYW5hZ2VyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNhcmV0YWtlciA9IG5ldyBNZW1lbnRvQ2FyZXRha2VyKFZFUlNJT04pO1xuICAgIHRoaXMuc3RhdGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIHNldFN0YXRlKG9yaWdpbmF0b3IsIHZhbHVlKSB7XG4gICAgaWYgKGpzb25EaWZmKHRoaXMuc3RhdGUuZ2V0KG9yaWdpbmF0b3IubWVtZW50b09yaWdpbmF0b3JLZXkpLCB2YWx1ZSkgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlLnNldChvcmlnaW5hdG9yLm1lbWVudG9PcmlnaW5hdG9yS2V5LCB2YWx1ZSk7XG4gICAgdGhpcy5yZXN0b3JlU3RhdGUob3JpZ2luYXRvcik7XG4gIH1cbiAgcmVzdG9yZVN0YXRlKG9yaWdpbmF0b3IpIHtcbiAgICBjb25zdCB7IGNhcmV0YWtlciwgc3RhdGUgfSA9IHRoaXM7XG4gICAgaWYgKCFzdGF0ZS5oYXMob3JpZ2luYXRvci5tZW1lbnRvT3JpZ2luYXRvcktleSkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdmFsdWUgPSBzdGF0ZS5nZXQob3JpZ2luYXRvci5tZW1lbnRvT3JpZ2luYXRvcktleSk7XG4gICAgY2FyZXRha2VyLnJlc3RvcmUoeyB2ZXJzaW9uOiBjYXJldGFrZXIudmVyc2lvbiwgW29yaWdpbmF0b3IubWVtZW50b09yaWdpbmF0b3JLZXldOiB2YWx1ZSB9LCBvcmlnaW5hdG9yKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc3R5bGVzLmNzc1xudmFyIHN0eWxlc19kZWZhdWx0ID0gJy5hZy1jaGFydHMtd3JhcHBlciwuYWctY2hhcnRzLXdyYXBwZXI6Zm9jdXMsLmFnLWNoYXJ0cy13cmFwcGVyOmFmdGVyLC5hZy1jaGFydHMtd3JhcHBlcjpiZWZvcmUsLmFnLWNoYXJ0cy13cmFwcGVyICosLmFnLWNoYXJ0cy13cmFwcGVyICo6Zm9jdXMsLmFnLWNoYXJ0cy13cmFwcGVyICo6YWZ0ZXIsLmFnLWNoYXJ0cy13cmFwcGVyICo6YmVmb3Jle2JveC1zaXppbmc6Ym9yZGVyLWJveDtvdXRsaW5lOm5vbmV9LmFnLWNoYXJ0cy13cmFwcGVye3Bvc2l0aW9uOnJlbGF0aXZlO3VzZXItc2VsZWN0Om5vbmV9LmFnLWNoYXJ0cy1jYW52YXMtY2VudGVye3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7cG9zaXRpb246YWJzb2x1dGU7dG91Y2gtYWN0aW9uOmF1dG87ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOnZhcigtLWFnLWNoYXJ0cy1hbGlnbik7anVzdGlmeS1jb250ZW50OnZhcigtLWFnLWNoYXJ0cy1qdXN0aWZ5KX0uYWctY2hhcnRzLWNhbnZhcy1jb250YWluZXIsLmFnLWNoYXJ0cy1jYW52YXN7cG9zaXRpb246cmVsYXRpdmU7dXNlci1zZWxlY3Q6bm9uZX0uYWctY2hhcnRzLWNhbnZhcy1jb250YWluZXI+KiwuYWctY2hhcnRzLWNhbnZhcz4qe2Rpc3BsYXk6YmxvY2s7cG9pbnRlci1ldmVudHM6bm9uZX0uYWctY2hhcnRzLXNlcmllcy1hcmVhe29wYWNpdHk6MDtwb2ludGVyLWV2ZW50czphdXRvO3Bvc2l0aW9uOmFic29sdXRlfS5hZy1jaGFydHMtc2VyaWVzLWFyZWE6Zm9jdXMtdmlzaWJsZXtvcGFjaXR5OjF9LmFnLWNoYXJ0cy1jYW52YXMtcHJveHksLmFnLWNoYXJ0cy1jYW52YXMtb3ZlcmxheXtpbnNldDowO3BvaW50ZXItZXZlbnRzOm5vbmU7cG9zaXRpb246YWJzb2x1dGU7dXNlci1zZWxlY3Q6bm9uZX0uYWctY2hhcnRzLWNhbnZhcy1vdmVybGF5Pip7cG9zaXRpb246YWJzb2x1dGU7cG9pbnRlci1ldmVudHM6YXV0b30uYWctY2hhcnRzLXRoZW1lLWRlZmF1bHQsLmFnLWNoYXJ0cy10aGVtZS1kZWZhdWx0LWRhcmt7LS1hZy1jaGFydHMtYWN0aXZlLWNvbG9yOiB2YXIoLS1hZy1hY3RpdmUtY29sb3IsICMyMTk2ZjMpOy0tYWctY2hhcnRzLWJhY2tncm91bmQtY29sb3I6IHZhcigtLWFnLWJhY2tncm91bmQtY29sb3IsICNmZmYpOy0tYWctY2hhcnRzLWZvcmVncm91bmQtY29sb3I6IHZhcigtLWFnLWZvcmVncm91bmQtY29sb3IsICMxODFkMWYpOy0tYWctY2hhcnRzLWJvcmRlci1jb2xvcjogdmFyKC0tYWctYm9yZGVyLWNvbG9yLCAjZGRkZGRkKTstLWFnLWNoYXJ0cy1ob3Zlci1jb2xvcjogY29sb3ItbWl4KGluIHNyZ2IsIHZhcigtLWFnLWNoYXJ0cy1iYWNrZ3JvdW5kLWNvbG9yKSwgdmFyKC0tYWctY2hhcnRzLWFjdGl2ZS1jb2xvcikgMTIlKTstLWFnLWNoYXJ0cy1mb250LWZhbWlseTogXCJWZXJkYW5hXCIsIHNhbnMtc2VyaWY7LS1hZy1jaGFydHMtZm9udC1zaXplOiB2YXIoLS1hZy1mb250LXNpemUsIDE0cHgpOy0tYWctY2hhcnRzLXNpemU6IHZhcigtLWFnLWdyaWQtc2l6ZSwgOHB4KTstLWFnLWNoYXJ0cy1ib3JkZXI6IHZhcigtLWFnLWNoYXJ0cy1ib3JkZXItY29sb3IpIHZhcigtLWFnLWJvcmRlcnMsIHNvbGlkIDFweCk7LS1hZy1jaGFydHMtYm9yZGVyLWNyaXRpY2FsOiB2YXIoLS1hZy1ib3JkZXJzLWNyaXRpY2FsLCBzb2xpZCAxcHgpOy0tYWctY2hhcnRzLWxheWVyLXVpLW92ZXJsYXk6IDU7LS1hZy1jaGFydHMtbGF5ZXItdG9vbHRpcDogNDstLWFnLWNoYXJ0cy1sYXllci10b29sYmFyOiAzOy0tYWctY2hhcnRzLWxheWVyLWNyb3NzaGFpcjogMjstLWFnLWNoYXJ0cy1sYXllci1hbm5vdGF0aW9uczogMTstLWFnLWNoYXJ0cy1hbGlnbjogY2VudGVyOy0tYWctY2hhcnRzLWp1c3RpZnk6IGNlbnRlcjstLWFnLWNoYXJ0cy1heGlzLWxhYmVsLWJhY2tncm91bmQtY29sb3I6ICM0NzQ3NDc7LS1hZy1jaGFydHMtYXhpcy1sYWJlbC1jb2xvcjogI2ZmZmZmZjstLWFnLWNoYXJ0cy10b29sYmFyLWZvcmVncm91bmQtY29sb3I6IHZhcigtLWFnLWhlYWRlci1mb3JlZ3JvdW5kLWNvbG9yLCB2YXIoLS1hZy1jaGFydHMtZm9yZWdyb3VuZC1jb2xvcikpOy0tYWctY2hhcnRzLXRvb2xiYXItYmFja2dyb3VuZC1jb2xvcjogdmFyKCAtLWFnLWhlYWRlci1iYWNrZ3JvdW5kLWNvbG9yLCBjb2xvci1taXgoaW4gc3JnYiwgdmFyKC0tYWctY2hhcnRzLWJhY2tncm91bmQtY29sb3IpLCB2YXIoLS1hZy1jaGFydHMtZm9yZWdyb3VuZC1jb2xvcikgMiUpICk7LS1hZy1jaGFydHMtdG9vbGJhci1zaXplOiAzNHB4Oy0tYWctY2hhcnRzLXRvb2xiYXItc2l6ZS1zbWFsbDogMjRweDstLWFnLWNoYXJ0cy10b29sYmFyLWJvcmRlcjogdmFyKC0tYWctY2hhcnRzLWJvcmRlci1jcml0aWNhbCwgc29saWQgMXB4KSB2YXIoLS1hZy1jaGFydHMtYm9yZGVyLWNvbG9yKTstLWFnLWNoYXJ0cy10b29sYmFyLWhvdmVyLWNvbG9yOiBjb2xvci1taXgoIGluIHNyZ2IsIHZhcigtLWFnLWNoYXJ0cy1iYWNrZ3JvdW5kLWNvbG9yKSwgdmFyKC0tYWctY2hhcnRzLWFjdGl2ZS1jb2xvcikgMTIlICk7LS1hZy1jaGFydHMtdG9vbGJhci1mb2N1cy1jb2xvcjogdmFyKC0tYWctY2hhcnRzLWFjdGl2ZS1jb2xvcik7LS1hZy1jaGFydHMtdG9vbGJhci1hY3RpdmUtYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tYWctY2hhcnRzLXRvb2xiYXItaG92ZXItY29sb3IpOy0tYWctY2hhcnRzLXRvb2xiYXItYWN0aXZlLWNvbG9yOiB2YXIoLS1hZy1jaGFydHMtYWN0aXZlLWNvbG9yKTstLWFnLWNoYXJ0cy10b29sYmFyLWRpc2FibGVkLWZvcmVncm91bmQtY29sb3I6IHZhciggLS1hZy1kaXNhYmxlZC1mb3JlZ3JvdW5kLWNvbG9yLCBjb2xvci1taXgoaW4gc3JnYiwgdHJhbnNwYXJlbnQsIHZhcigtLWFnLWNoYXJ0cy10b29sYmFyLWZvcmVncm91bmQtY29sb3IpIDUwJSkgKTstLWFnLWNoYXJ0cy10b29sYmFyLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6IGNvbG9yLW1peCggaW4gc3JnYiwgdmFyKC0tYWctY2hhcnRzLXRvb2xiYXItYmFja2dyb3VuZC1jb2xvciksIHZhcigtLWFnLWNoYXJ0cy10b29sYmFyLWZvcmVncm91bmQtY29sb3IpIDYlICk7LS1hZy1jaGFydHMtdG9vbGJhci1nYXA6IHZhcigtLWFnLWNoYXJ0cy1zaXplKTstLWFnLWNoYXJ0cy10b29sYmFyLWZvbnQtc2l6ZTogMTNweDstLWFnLWNoYXJ0cy10b29sYmFyLWZvbnQtc2l6ZS1zbWFsbDogMTJweDstLWFnLWNoYXJ0cy10b29sYmFyLWJ1dHRvbi1wYWRkaW5nOiA2cHg7LS1hZy1jaGFydHMtdG9vbGJhci1idXR0b24tcGFkZGluZy1zbWFsbDogMXB4Oy0tYWctY2hhcnRzLXBvcG92ZXItYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tYWctY2hhcnRzLXRvb2xiYXItYmFja2dyb3VuZC1jb2xvcik7LS1hZy1jaGFydHMtcG9wb3Zlci1mb3JlZ3JvdW5kLWNvbG9yOiB2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1mb3JlZ3JvdW5kLWNvbG9yKTstLWFnLWNoYXJ0cy1wb3BvdmVyLWJvcmRlcjogdmFyKC0tYWctY2hhcnRzLXRvb2xiYXItYm9yZGVyKTstLWFnLWNoYXJ0cy1wb3BvdmVyLWJvcmRlci1yYWRpdXM6IHZhcigtLWFnLWJvcmRlci1yYWRpdXMsIDRweCk7LS1hZy1jaGFydHMtcG9wb3Zlci1hY3RpdmUtY29sb3I6IHZhcigtLWFnLWNoYXJ0cy10b29sYmFyLWFjdGl2ZS1jb2xvcik7LS1hZy1jaGFydHMtcG9wb3Zlci1ob3Zlci1jb2xvcjogdmFyKC0tYWctY2hhcnRzLXRvb2xiYXItaG92ZXItY29sb3IpOy0tYWctY2hhcnRzLXBvcG92ZXItYWN0aXZlLWJhY2tncm91bmQtY29sb3I6IHZhcigtLWFnLWNoYXJ0cy10b29sYmFyLWFjdGl2ZS1iYWNrZ3JvdW5kLWNvbG9yKTstLWFnLWNoYXJ0cy1wb3BvdmVyLWZvbnQtc2l6ZTogMTRweDstLWFnLWNoYXJ0cy1wb3BvdmVyLWZvbnQtc2l6ZS1zbWFsbDogdmFyKC0tYWctY2hhcnRzLXRvb2xiYXItZm9udC1zaXplLXNtYWxsKTstLWFnLWNoYXJ0cy1kaWFsb2ctaW5wdXQtZ3JvdXAtbGFiZWwtY29sb3I6IGNvbG9yLW1peChpbiBzcmdiLCB0cmFuc3BhcmVudCwgdmFyKC0tYWctY2hhcnRzLWZvcmVncm91bmQtY29sb3IpIDU1JSk7LS1hZy1jaGFydHMtZGlhbG9nLXRhYi1jb2xvci0taW5hY3RpdmU6IGNvbG9yLW1peChpbiBzcmdiLCB0cmFuc3BhcmVudCwgdmFyKC0tYWctY2hhcnRzLWZvcmVncm91bmQtY29sb3IpIDU1JSk7LS1hZy1jaGFydHMtYnV0dG9uLXJhZGl1czogdmFyKC0tYWctYm9yZGVyLXJhZGl1cywgNHB4KTstLWFnLWNoYXJ0cy1mb2N1cy1ib3JkZXItY29sb3I6IHZhcigtLWFnLWlucHV0LWZvY3VzLWJvcmRlci1jb2xvciwgdmFyKC0tYWctY2hhcnRzLWFjdGl2ZS1jb2xvcikpOy0tYWctY2hhcnRzLWZvY3VzLWJvcmRlcjogc29saWQgMXB4IHZhcigtLWFnLWNoYXJ0cy1mb2N1cy1ib3JkZXItY29sb3IpOy0tYWctY2hhcnRzLWZvY3VzLWJvcmRlci1zaGFkb3c6IHZhciggLS1hZy1pbnB1dC1mb2N1cy1ib3gtc2hhZG93LCAwIDAgMCAzcHggY29sb3ItbWl4KGluIHNyZ2IsIHRyYW5zcGFyZW50LCB2YXIoLS1hZy1pbnB1dC1mb2N1cy1ib3JkZXItY29sb3IsIHZhcigtLWFnLWNoYXJ0cy1hY3RpdmUtY29sb3IpKSAyMCUpICk7LS1hZy1jaGFydHMtZm9jdXMtYm94LXNoYWRvdzogdmFyKC0tYm94LXNoYWRvdyksIDAgMCAwIDJweCAjZmZmOCwgdmFyKC0tYWctY2hhcnRzLWZvY3VzLWJvcmRlci1zaGFkb3cpOy0tYWctY2hhcnRzLWljb24tZm9udC1mYW1pbHk6IFwiYWdDaGFydHNEZWZhdWx0XCI7LS1hZy1jaGFydHMtaWNvbi1mb250LXdlaWdodDogbm9ybWFsOy0tYWctY2hhcnRzLWljb24tZm9udC1jb2xvcjogY29sb3ItbWl4KGluIHNyZ2IsIHRyYW5zcGFyZW50LCB2YXIoLS1hZy1jaGFydHMtZm9yZWdyb3VuZC1jb2xvciksIDkwJSk7LS1hZy1jaGFydHMtaWNvbi1zaXplOiAyMHB4Oy0tYWctY2hhcnRzLWlucHV0LWJhY2tncm91bmQtY29sb3I6IHZhcigtLWFnLWNoYXJ0cy1iYWNrZ3JvdW5kLWNvbG9yKTstLWFnLWNoYXJ0cy1pbnB1dC1iYWNrZ3JvdW5kLWNvbG9yLS1ob3ZlcjogdmFyKC0tYWctY2hhcnRzLWhvdmVyLWNvbG9yKTstLWFnLWNoYXJ0cy1pbnB1dC1iYWNrZ3JvdW5kLWNvbG9yLS1hY3RpdmU6IHZhcigtLWFnLWNoYXJ0cy1ob3Zlci1jb2xvcik7LS1hZy1jaGFydHMtaW5wdXQtYm9yZGVyLWNvbG9yOiB2YXIoLS1hZy1jaGFydHMtYm9yZGVyLWNvbG9yKTstLWFnLWNoYXJ0cy1pbnB1dC1ib3JkZXItY29sb3ItLWFjdGl2ZTogdmFyKC0tYWctY2hhcnRzLWFjdGl2ZS1jb2xvcik7LS1hZy1jaGFydHMtaW5wdXQtYm9yZGVyLXJhZGl1czogdmFyKC0tYWctYm9yZGVyLXJhZGl1cywgNHB4KTstLWFnLWNoYXJ0cy1pbnB1dC1jb2xvci0tYWN0aXZlOiB2YXIoLS1hZy1jaGFydHMtYWN0aXZlLWNvbG9yKTstLWFnLWNoYXJ0cy1pbnB1dC1mb2N1cy1vdXRsaW5lOiB2YXIoLS1hZy1jaGFydHMtZm9jdXMtYm9yZGVyKTstLWFnLWNoYXJ0cy1pbnB1dC1mb2N1cy1ib3gtc2hhZG93OiB2YXIoLS1hZy1jaGFydHMtZm9jdXMtYm9yZGVyLXNoYWRvdyk7LS1hZy1jaGFydHMtaW5wdXQtZm9udC1mYW1pbHk6IHZhcigtLWFnLWNoYXJ0cy1mb250LWZhbWlseSk7LS1hZy1jaGFydHMtaW5wdXQtZm9udC1zaXplOiB2YXIoLS1hZy1jaGFydHMtZm9udC1zaXplKTstLWFnLWNoYXJ0cy1pbnB1dC1wYWRkaW5nOiA4cHg7LS1hZy1jaGFydHMtaW5wdXQtcGFkZGluZy1sYXJnZTogMTBweDstLWFnLWNoYXJ0cy1pbnB1dC1wbGFjZWhvbGRlci1jb2xvcjogIzg4ODg4ODstLWFnLWNoYXJ0cy1pbnB1dC1zcGFjaW5nOiA4cHg7LS1hZy1jaGFydHMtaW5wdXQtdHJhbnNpdGlvbi1kdXJhdGlvbjogLjI1czstLWFnLWNoYXJ0cy1pbnB1dC10cmFuc2l0aW9uLWR1cmF0aW9uLS1mYXN0OiAuMXM7LS1hZy1jaGFydHMtaW5wdXQtdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246IGVhc2Utb3V0Oy0tYWctY2hhcnRzLWlucHV0LWNoZWNrYm94LWJhY2tncm91bmQtY29sb3I6ICNiYWJiYmM7LS1hZy1jaGFydHMtaW5wdXQtY2hlY2tib3gtYmFja2dyb3VuZC1jb2xvci0tY2hlY2tlZDogdmFyKC0tYWctY2hhcnRzLWFjdGl2ZS1jb2xvcil9LmFnLWNoYXJ0cy10aGVtZS1kZWZhdWx0LWRhcmt7LS1hZy1jaGFydHMtYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tYWctYmFja2dyb3VuZC1jb2xvciwgY29sb3ItbWl4KGluIHNyZ2IsICNmZmYsICMxODIyMzAgOTclKSk7LS1hZy1jaGFydHMtZm9yZWdyb3VuZC1jb2xvcjogdmFyKC0tYWctZm9yZWdyb3VuZC1jb2xvciwgI2ZmZik7LS1hZy1jaGFydHMtYm9yZGVyLWNvbG9yOiB2YXIoLS1hZy1ib3JkZXItY29sb3IsIHJnYmEoMjU1LCAyNTUsIDI1NSwgLjE2KSk7LS1hZy1jaGFydHMtaG92ZXItY29sb3I6IGNvbG9yLW1peChpbiBzcmdiLCB2YXIoLS1hZy1jaGFydHMtYmFja2dyb3VuZC1jb2xvciksIHZhcigtLWFnLWNoYXJ0cy1hY3RpdmUtY29sb3IpIDE4JSk7LS1hZy1jaGFydHMtYXhpcy1sYWJlbC1iYWNrZ3JvdW5kLWNvbG9yOiAjOWNhZWJiOy0tYWctY2hhcnRzLWF4aXMtbGFiZWwtY29sb3I6ICMwMDAwMDA7LS1hZy1jaGFydHMtdG9vbGJhci1iYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1hZy1oZWFkZXItYmFja2dyb3VuZC1jb2xvciwgY29sb3ItbWl4KGluIHNyZ2IsICNmZmYsICMxODIyMzAgOTMlKSk7LS1hZy1jaGFydHMtdG9vbGJhci1ob3Zlci1jb2xvcjogY29sb3ItbWl4KCBpbiBzcmdiLCB2YXIoLS1hZy1jaGFydHMtYmFja2dyb3VuZC1jb2xvciksIHZhcigtLWFnLWNoYXJ0cy1hY3RpdmUtY29sb3IpIDE4JSApOy0tYWctY2hhcnRzLWRpYWxvZy1pbnB1dC1ncm91cC1sYWJlbC10ZXh0LWNvbG9yOiAjZmZmZmZmOy0tYWctY2hhcnRzLWZvY3VzLWJvcmRlci1zaGFkb3c6IHZhciggLS1hZy1pbnB1dC1mb2N1cy1ib3gtc2hhZG93LCAwIDAgMCAzcHggY29sb3ItbWl4KGluIHNyZ2IsIHRyYW5zcGFyZW50LCB2YXIoLS1hZy1pbnB1dC1mb2N1cy1ib3JkZXItY29sb3IsIHZhcigtLWFnLWNoYXJ0cy1hY3RpdmUtY29sb3IpKSAyMCUpICk7LS1hZy1jaGFydHMtaW5wdXQtcGxhY2Vob2xkZXItY29sb3I6ICNhYWFhYWF9LmFnLWNoYXJ0cy1pY29ue2Rpc3BsYXk6YmxvY2s7d2lkdGg6dmFyKC0tYWctY2hhcnRzLWljb24tc2l6ZSk7aGVpZ2h0OnZhcigtLWFnLWNoYXJ0cy1pY29uLXNpemUpO3NwZWFrOm5vbmU7c3BlYWs6bmV2ZXI7bWFzazp2YXIoLS1pY29uKSBjZW50ZXIgLyBjb250YWluIG5vLXJlcGVhdDtiYWNrZ3JvdW5kLWNvbG9yOmN1cnJlbnRDb2xvcjt0cmFuc2l0aW9uOmJhY2tncm91bmQtY29sb3IgLjI1cyBlYXNlLWluLW91dH0uYWctY2hhcnRzLWljb24tYWxpZ24tY2VudGVyey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1qQWlJR2hsYVdkb2REMGlNakFpSUhacFpYZENiM2c5SWpBZ01DQXlNQ0F5TUNJZ1ptbHNiRDBpYm05dVpTSWdlRzFzYm5NOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6SXdNREF2YzNabklqNDhjR0YwYUNCbWFXeHNQU0lqTURBd0lpQmtQU0pOTnlBeE1HZzJkakZJTjNwTk5DQTNhREV5ZGpGSU5IcHRNU0EyYURFd2RqRklOWG9pTHo0OEwzTjJaejQ9KX0uYWctY2hhcnRzLWljb24tYWxpZ24tbGVmdHstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNakFpSUdobGFXZG9kRDBpTWpBaUlIWnBaWGRDYjNnOUlqQWdNQ0F5TUNBeU1DSWdabWxzYkQwaWJtOXVaU0lnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JajQ4Y0dGMGFDQm1hV3hzUFNJak1EQXdJaUJrUFNKTk5DQXhNR2cyZGpGSU5IcHRNQzB6YURFeWRqRklOSHB0TUNBMmFERXdkakZJTkhvaUx6NDhMM04yWno0PSl9LmFnLWNoYXJ0cy1pY29uLWFsaWduLXJpZ2h0ey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1qQWlJR2hsYVdkb2REMGlNakFpSUhacFpYZENiM2c5SWpBZ01DQXlNQ0F5TUNJZ1ptbHNiRDBpYm05dVpTSWdlRzFzYm5NOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6SXdNREF2YzNabklqNDhjR0YwYUNCbWFXeHNQU0lqTURBd0lpQmtQU0pOTVRBZ01UQm9Obll4YUMwMmVrMDBJRGRvTVRKMk1VZzBlbTB5SURab01UQjJNVWcyZWlJdlBqd3ZjM1puUGc9PSl9LmFnLWNoYXJ0cy1pY29uLWFycm93LWRyYXdpbmd7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTWpBaUlHaGxhV2RvZEQwaU1qQWlJSFpwWlhkQ2IzZzlJakFnTUNBeU1DQXlNQ0lnWm1sc2JEMGlibTl1WlNJZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWo0OGNHRjBhQ0JtYVd4c0xYSjFiR1U5SW1WMlpXNXZaR1FpSUdOc2FYQXRjblZzWlQwaVpYWmxibTlrWkNJZ1pEMGlUVEUxTGpJNU15QTBMalZJTVRJdU5YWXRNVWd4TjNZMGFDMHhWalV1TWpBM2JDMDVMalkwTmlBNUxqWTBOeTB1TnpBNExTNDNNRGg2SWlCbWFXeHNQU0lqTURBd0lpOCtQSEJoZEdnZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmpiR2x3TFhKMWJHVTlJbVYyWlc1dlpHUWlJR1E5SWswM0lERTJZVEl1TlNBeUxqVWdNQ0F4SURFdE5TQXdJREl1TlNBeUxqVWdNQ0F3SURFZ05TQXdiUzB5TGpVZ01TNDFZVEV1TlNBeExqVWdNQ0F4SURBZ01DMHpJREV1TlNBeExqVWdNQ0F3SURBZ01DQXpJaUJtYVd4c1BTSWpNREF3SWk4K1BDOXpkbWMrKX0uYWctY2hhcnRzLWljb24tYXJyb3ctZG93bi1kcmF3aW5ney0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1qQWlJR2hsYVdkb2REMGlNakFpSUhacFpYZENiM2c5SWpBZ01DQXlNQ0F5TUNJZ1ptbHNiRDBpYm05dVpTSWdlRzFzYm5NOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6SXdNREF2YzNabklqNEtQSEJoZEdnZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmpiR2x3TFhKMWJHVTlJbVYyWlc1dlpHUWlJR1E5SWswMklEaE1NUzQxSURoTU1UQWdNVGhNTVRndU5TQTRUREUwSURoTU1UUWdNMHcySUROTU5pQTRXazAzSURSTU55QTVTRE11TmpZeU5EUk1NVEFnTVRZdU5EVTJUREUyTGpNek56WWdPVXd4TXlBNVRERXpJRFJNTnlBMFdpSWdabWxzYkQwaVlteGhZMnNpTHo0S1BDOXpkbWMrQ2c9PSl9LmFnLWNoYXJ0cy1pY29uLWFycm93LXVwLWRyYXdpbmd7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTWpBaUlHaGxhV2RvZEQwaU1qQWlJSFpwWlhkQ2IzZzlJakFnTUNBeU1DQXlNQ0lnWm1sc2JEMGlibTl1WlNJZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWo0S1BIQmhkR2dnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCamJHbHdMWEoxYkdVOUltVjJaVzV2WkdRaUlHUTlJazB4TkNBeE1rZ3hPQzQxVERFd0lESk1NUzQxSURFeVNEWk1OaTR3TURBd01pQXhOMGd4TkZZeE1scE5NVE1nTVRaV01URklNVFl1TXpNM05rd3hNQ0F6TGpVME5EQTFURE11TmpZeU5EUWdNVEZJTjB3M0xqQXdNREF5SURFMlNERXpXaUlnWm1sc2JEMGlZbXhoWTJzaUx6NEtQQzl6ZG1jK0NnPT0pfS5hZy1jaGFydHMtaWNvbi1jYWxsb3V0LWFubm90YXRpb257LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6QXdNQ0lnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSk5NeUEwTGpWQk1TNDFJREV1TlNBd0lEQWdNU0EwTGpVZ00yZ3hNVUV4TGpVZ01TNDFJREFnTUNBeElERTNJRFF1TlhZNFlURXVOU0F4TGpVZ01DQXdJREV0TVM0MUlERXVOV2d0TkM0MU1UUmhNallnTWpZZ01DQXdJREF0TWk0d01UY2dNUzQxTkd3dExqTXhOQzR5Tm1NdExqVTFMalExTnkweExqRXhOUzQ1TWpZdE1TNDNOaUF4TGpRdExqWTJPUzQwT1RFdE1TNDFOakl0TGpBeE1pMHhMalUyTWkwdU9GWXhORWcwTGpWQk1TNDFJREV1TlNBd0lEQWdNU0F6SURFeUxqVjZUVFF1TlNBMFlTNDFMalVnTUNBd0lEQXRMalV1TlhZNFlTNDFMalVnTUNBd0lEQWdMalV1TldneExqZ3pNM1l6TGpNM01tRXpOaUF6TmlBd0lEQWdNQ0F4TGpZM09DMHhMak16T0d3dU16SXRMakkyTldFeU5pQXlOaUF3SURBZ01TQXlMakl5TlMweExqWTROV3d1TVRJMkxTNHdPRFJJTVRVdU5XRXVOUzQxSURBZ01DQXdJQzQxTFM0MWRpMDRZUzQxTGpVZ01DQXdJREF0TGpVdExqVjZJaUJqYkdsd0xYSjFiR1U5SW1WMlpXNXZaR1FpTHo0OEwzTjJaejQ9KX0uYWctY2hhcnRzLWljb24tY2FuZGxlc3RpY2stc2VyaWVzey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekV6TVRjeU1pSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKTk55QXhkak5vTW5ZeE1rZzNkak5JTm5ZdE0wZzBWalJvTWxZeGVrMDFJRFZvTTNZeE1FZzFlazB4TVNBeE5GWTJhREpXTXk0eU5XZ3hWalpvTW5ZNGFDMHlkakl1TnpWb0xURldNVFI2YlRFdE4yZ3pkalpvTFRONklpQmpiR2x3TFhKMWJHVTlJbVYyWlc1dlpHUWlMejQ4TDNOMlp6ND0pfS5hZy1jaGFydHMtaWNvbi1jbG9zZXstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNakFpSUdobGFXZG9kRDBpTWpBaUlIWnBaWGRDYjNnOUlqQWdNQ0F5TUNBeU1DSWdabWxzYkQwaWJtOXVaU0lnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JajQ4Y0dGMGFDQmtQU0p0TlNBMUlERXdJREV3VFRVZ01UVWdNVFVnTlNJZ2MzUnliMnRsUFNJak1EQXdJaTgrUEM5emRtYyspfS5hZy1jaGFydHMtaWNvbi1jb21tZW50LWFubm90YXRpb257LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6QXdNQ0lnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSk5OeTQxTVRNZ015NDVPVFZoTmk0MUlEWXVOU0F3SURBZ01TQTJMakE1T0NBeE1TNDBNV010TGpVNE9DNHpPVE10TVM0eU1UY3VOVE0yTFRFdU9ESTVMalU0TldFeE15QXhNeUF3SURBZ01TMHhMakkzTGpBeE4wRXlOeUF5TnlBd0lEQWdNQ0F4TUNBeE5rZzBMalZoTGpVdU5TQXdJREFnTVMwdU5TMHVOVll4TUhFd0xTNHlORGN0TGpBd055MHVOVEV6WXkwdU1EQTRMUzQwTVRZdExqQXhOaTB1T0RVM0xqQXhOeTB4TGpJMk9TNHdOUzB1TmpFeUxqRTVNaTB4TGpJMExqVTROUzB4TGpnellUWXVOU0EyTGpVZ01DQXdJREVnTWk0NU1UZ3RNaTR6T1ROdE15NDFOaTQyTVdFMUxqVWdOUzQxSURBZ01DQXdMVFV1TmpRMklESXVNelJqTFM0eU5qWXVNemszTFM0ek56a3VPRFF5TFM0ME1pQXhMak0xTkMwdU1ETXVNell0TGpBeU1pNDNNVGd0TGpBeE5TQXhMakV3T0ZFMUlEa3VOamc1SURVZ01UQjJOV2cxY1M0ek1URXVNREF4TGpVNU15NHdNRGhqTGpNNUxqQXdOeTQzTkRjdU1ERTFJREV1TVRBNExTNHdNVFV1TlRFeUxTNHdOREV1T1RVM0xTNHhOVFFnTVM0ek5UVXRMalF5WVRVdU5TQTFMalVnTUNBd0lEQXRNUzQ1T0RNdE9TNDVOamNpSUdOc2FYQXRjblZzWlQwaVpYWmxibTlrWkNJdlBqd3ZjM1puUGc9PSl9LmFnLWNoYXJ0cy1pY29uLWNyb3NzaGFpci1hZGQtbGluZXstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpBd01DSWdaRDBpVFRFd0lEVXVOV0V1TlM0MUlEQWdNQ0F4SUM0MUxqVjJNeTQxYURNdU9EYzFZUzQxTGpVZ01DQXdJREVnTUNBeFNERXdMalYyTkM0eU5XRXVOUzQxSURBZ01TQXhMVEVnTUZZeE1DNDFTRFV1TmpJMVlTNDFMalVnTUNBeElERWdNQzB4U0RrdU5WWTJZUzQxTGpVZ01DQXdJREVnTGpVdExqVWlMejQ4TDNOMlp6ND0pfS5hZy1jaGFydHMtaWNvbi1kYXRlLXJhbmdlLWRyYXdpbmd7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTWpBaUlHaGxhV2RvZEQwaU1qQWlJSFpwWlhkQ2IzZzlJakFnTUNBeU1DQXlNQ0lnWm1sc2JEMGlibTl1WlNJZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWo0OGNHRjBhQ0JrUFNKTk1pQXlhREYyTVRaSU1ucHRNVFVnTUdneGRqRTJhQzB4ZWlJZ1ptbHNiRDBpSXpFNE1VUXhSaUl2UGp4d1lYUm9JR1E5SWsweE15NHhOVGNnTVRGSU5YWXRNV2czTGpjNU0wd3hNU0E0TGpJd04yd3VOekEzTFM0M01EY2dNeTR4T0RJZ015NHhPREl0TXk0eE9ESWdNeTR4T0RJdExqY3dOeTB1TnpBM2VpSWdabWxzYkQwaUl6QXdNQ0l2UGp3dmMzWm5QZz09KX0uYWctY2hhcnRzLWljb24tZGF0ZS1wcmljZS1yYW5nZS1kcmF3aW5ney0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1qQWlJR2hsYVdkb2REMGlNakFpSUhacFpYZENiM2c5SWpBZ01DQXlNQ0F5TUNJZ1ptbHNiRDBpYm05dVpTSWdlRzFzYm5NOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6SXdNREF2YzNabklqNDhjR0YwYUNCa1BTSk5NeUF5U0RKMk1UWm9NWHB0TXk0MU1EY2dOQzQ0T1V3NExqVWdOQzQ0T1RWV01UQklOWFl4YURNdU5YWTNhREYyTFRkb05TNHdPRGhzTFRFdU9UVTNJREV1T1RVM0xqY3dOeTQzTURjZ015NHhPREl0TXk0eE9ESk1NVE11TXpNNElEY3VNMnd0TGpjd055NDNNRGRNTVRRdU5qSTBJREV3U0RrdU5WWTBMamt6TW13eExqazFOeUF4TGprMU55NDNNRGN0TGpjd04wdzRMams0TWlBeklEVXVPQ0EyTGpFNE1ub2lJR1pwYkd3OUlpTXhPREZFTVVZaUx6NDhMM04yWno0PSl9LmFnLWNoYXJ0cy1pY29uLWRlbGV0ZXstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpFek1UY3lNaUlnWkQwaVRUZ3VORGsySURndU9UazJRUzQxTGpVZ01DQXdJREVnT1NBNUxqUTVNblkwWVM0MUxqVWdNQ0F4SURFdE1TQXVNREE0ZGkwMFlTNDFMalVnTUNBd0lERWdMalE1TmkwdU5UQTBUVEV5SURrdU5XRXVOUzQxSURBZ01DQXdMVEVnTUhZMFlTNDFMalVnTUNBd0lEQWdNU0F3ZWlJdlBqeHdZWFJvSUdacGJHdzlJaU14TXpFM01qSWlJR1pwYkd3dGNuVnNaVDBpWlhabGJtOWtaQ0lnWkQwaVRUWWdOVll6TGpWQk1pNDFJREl1TlNBd0lEQWdNU0E0TGpVZ01XZ3pRVEl1TlNBeUxqVWdNQ0F3SURFZ01UUWdNeTQxVmpWb01pNDRNek5oTGpVdU5TQXdJREFnTVNBd0lERklNVFYyTVRBdU1qVmpNQ0F1TkRFMUxTNHdOall1T0RZekxTNHpJREV1TWpJeExTNHlOVGN1TXprMExTNDJOekl1TmpFeUxURXVNaTQyTVRKb0xUZGpMUzQxTWpnZ01DMHVPVFF6TFM0eU1UZ3RNUzR5TFM0Mk1USXRMakl6TkMwdU16VTRMUzR6TFM0NE1EWXRMak10TVM0eU1qRldOa2d6TGpNek0yRXVOUzQxSURBZ01DQXhJREF0TVhwdE1TMHhMalZCTVM0MUlERXVOU0F3SURBZ01TQTRMalVnTW1nelFURXVOU0F4TGpVZ01DQXdJREVnTVRNZ015NDFWalZJTjNwTk5pQXhOaTR5TlZZMmFEaDJNVEF1TWpWak1DQXVNek0xTFM0d05Ua3VOVFUwTFM0eE16Z3VOamMxTFM0d05UVXVNRGcxTFM0eE5DNHhOVGd0TGpNMk1pNHhOVGhvTFRkakxTNHlNaklnTUMwdU16QTNMUzR3TnpNdExqTTJNaTB1TVRVNExTNHdPQzB1TVRJeExTNHhNemd0TGpNMExTNHhNemd0TGpZM05TSWdZMnhwY0MxeWRXeGxQU0psZG1WdWIyUmtJaTgrUEM5emRtYyspfS5hZy1jaGFydHMtaWNvbi1kaXNqb2ludC1jaGFubmVsLC5hZy1jaGFydHMtaWNvbi1kaXNqb2ludC1jaGFubmVsLWRyYXdpbmd7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6RXpNVGN5TWlJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmtQU0pOTVRrdU1ESTRJREUzTGpRMllUSXVNalVnTWk0eU5TQXdJREFnTUMwMExqQTVNaTB4TGpnMWJDMDVMalV4TVMweUxqTTNPR0V5TGpJMUlESXVNalVnTUNBeElEQXRMakl5TlM0NU56UnNPUzQwTnpVZ01pNHpOamxoTWk0eU5URWdNaTR5TlRFZ01DQXdJREFnTkM0ek5UTXVPRGcyYlMweExqWTJNaTB4TGprMk5XRXhMakkxSURFdU1qVWdNQ0F4SURFdExqZzROU0F5TGpNek9DQXhMakkxSURFdU1qVWdNQ0F3SURFZ0xqZzROUzB5TGpNek9FMDBMak0wTXlBeE15NDJOamxoTVM0eU5TQXhMakkxSURBZ01TQXdMVEl1TXpNNExTNDRPRFVnTVM0eU5TQXhMakkxSURBZ01DQXdJREl1TXpNNExqZzROVTB6TGprM0lEZ3VOelk1WVRJdU1qVWdNaTR5TlNBd0lEQWdNQ0F4TGpRMU5TMHlMakV4YkRrdU5URXhMVEl1TXpjNFlUSXVNalVnTWk0eU5TQXdJREVnTUMwdU1qWXRMamsyTlV3MUxqSWdOUzQyT0RWaE1pNHlOU0F5TGpJMUlEQWdNU0F3TFRFdU1qTWdNeTR3T0RSdExqTTNNeTB5TGpVME4yRXhMakkxSURFdU1qVWdNQ0F4SURFdE1pNHpNemd1T0RnMUlERXVNalVnTVM0eU5TQXdJREFnTVNBeUxqTXpPQzB1T0RnMWJURXpMamMxTFRNdU5ETTRZVEV1TWpVZ01TNHlOU0F3SURFZ01TMHlMak16T0M0NE9EVWdNUzR5TlNBeExqSTFJREFnTUNBeElESXVNek00TFM0NE9EVWlJR05zYVhBdGNuVnNaVDBpWlhabGJtOWtaQ0l2UGp3dmMzWm5QZz09KX0uYWctY2hhcnRzLWljb24tZHJhZy1oYW5kbGV7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTWpBaUlHaGxhV2RvZEQwaU1qQWlJSFpwWlhkQ2IzZzlJakFnTUNBeU1DQXlNQ0lnWm1sc2JEMGlibTl1WlNJZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWo0OFkybHlZMnhsSUdONFBTSTFMamMxSWlCamVUMGlOeTQzTlNJZ2NqMGlMamMxSWlCbWFXeHNQU0lqTURBd0lpQm1hV3hzTFc5d1lXTnBkSGs5SWk0MUlpOCtQR05wY21Oc1pTQmplRDBpT1M0M05TSWdZM2s5SWpjdU56VWlJSEk5SWk0M05TSWdabWxzYkQwaUl6QXdNQ0lnWm1sc2JDMXZjR0ZqYVhSNVBTSXVOU0l2UGp4amFYSmpiR1VnWTNnOUlqRXpMamMxSWlCamVUMGlOeTQzTlNJZ2NqMGlMamMxSWlCbWFXeHNQU0lqTURBd0lpQm1hV3hzTFc5d1lXTnBkSGs5SWk0MUlpOCtQR05wY21Oc1pTQmplRDBpTVRNdU56VWlJR041UFNJeE1TNDNOU0lnY2owaUxqYzFJaUJtYVd4c1BTSWpNREF3SWlCbWFXeHNMVzl3WVdOcGRIazlJaTQxSWk4K1BHTnBjbU5zWlNCamVEMGlPUzQzTlNJZ1kzazlJakV4TGpjMUlpQnlQU0l1TnpVaUlHWnBiR3c5SWlNd01EQWlJR1pwYkd3dGIzQmhZMmwwZVQwaUxqVWlMejQ4WTJseVkyeGxJR040UFNJMUxqYzFJaUJqZVQwaU1URXVOelVpSUhJOUlpNDNOU0lnWm1sc2JEMGlJekF3TUNJZ1ptbHNiQzF2Y0dGamFYUjVQU0l1TlNJdlBqd3ZjM1puUGc9PSl9LmFnLWNoYXJ0cy1pY29uLWZpbGwtY29sb3J7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6QXdNQ0lnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSnRPQzR3TnpFZ05DNHdOaTB1T1RJMExTNDVNalF1TnpBM0xTNDNNRGNnTnk0eU9EZ2dOeTR5T0RndE5DNDVOU0EwTGprMVlUTXVOU0F6TGpVZ01DQXdJREV0TkM0NU5TQXdiQzB4TGpReE5DMHhMalF4TkdFekxqVWdNeTQxSURBZ01DQXhJREF0TkM0NU5YcHRMamN3Tnk0M01EaE1OQzQxTXpZZ09TNHdNV0V5TGpVZ01pNDFJREFnTUNBd0lEQWdNeTQxTXpaTU5TNDVOU0F4TXk0NU5tRXlMalVnTWk0MUlEQWdNQ0F3SURNdU5UTTFJREJzTkM0eU5ETXROQzR5TkRONmJUWXVPU0EzTGpJd01pMHVNelExTGpNMk15MHVNelEwTFM0ek5qTmhMalV1TlNBd0lEQWdNU0F1TmpnNElEQnRMUzR6TkRVZ01TNHdPR0U0SURnZ01DQXdJREF0TGpJNExqTXlNeUEwTGpNZ05DNHpJREFnTUNBd0xTNDBNRGt1TlRneVl5MHVNVEV6TGpJd01TMHVNVFEwTGpNeU5pMHVNVFEwTGpNM09HRXVPRE16TGpnek15QXdJREFnTUNBeExqWTJOeUF3WXpBdExqQTFNaTB1TURNeExTNHhOemN0TGpFME5DMHVNemM0WVRRdU15QTBMak1nTUNBd0lEQXRMalF4TFM0MU9ESWdPQ0E0SURBZ01DQXdMUzR5T0MwdU16SXliUzB1TXpRMExURXVNRGd1TXpRMExqTTJNeTR6TkRRdExqTTJNeTR3TURJdU1EQXlMakF3TkM0d01EUXVNREV6TGpBeE1tRTJJRFlnTUNBd0lERWdMakl3Tmk0eU1EaGpMakV6TVM0eE16WXVNekE0TGpNeU55NDBPRFV1TlRRMUxqRTNOaTR5TVRVdU16WXpMalEyTnk0MU1EY3VOekkwTGpFek55NHlORE11TWpjekxqVTFNeTR5TnpNdU9EWTRZVEV1T0RNeklERXVPRE16SURBZ01TQXhMVE11TmpZM0lEQmpNQzB1TXpFMUxqRXpOaTB1TmpJMUxqSTNNeTB1T0RZNExqRTBOQzB1TWpVM0xqTXpMUzQxTURrdU5UQTNMUzQzTWpSaE9TQTVJREFnTUNBeElDNDJORFV0TGpjd09Hd3VNRFEyTFM0d05EVXVNREV6TFM0d01USXVNREEwTFM0d01EUjZJaUJqYkdsd0xYSjFiR1U5SW1WMlpXNXZaR1FpTHo0OEwzTjJaejQ9KX0uYWctY2hhcnRzLWljb24taG9sbG93LWNhbmRsZXN0aWNrLXNlcmllc3stLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpFek1UY3lNaUlnWm1sc2JDMXZjR0ZqYVhSNVBTSXVNVFVpSUdROUlrMDFJRFZvTTNZeE1FZzFlaUl2UGp4d1lYUm9JR1pwYkd3OUlpTXhNekUzTWpJaUlHWnBiR3d0Y25Wc1pUMGlaWFpsYm05a1pDSWdaRDBpVFRjZ01YWXphREoyTVRKSU4zWXpTRFoyTFROSU5GWTBhREpXTVhwTk5TQTFhRE4yTVRCSU5YcHROeUF5YUROMk5tZ3RNM3B0TFRFZ04xWTJhREpXTXk0eU5XZ3hWalpvTW5ZNGFDMHlkakl1TnpWb0xURldNVFI2SWlCamJHbHdMWEoxYkdVOUltVjJaVzV2WkdRaUx6NDhMM04yWno0PSl9LmFnLWNoYXJ0cy1pY29uLWhvcml6b250YWwtbGluZSwuYWctY2hhcnRzLWljb24taG9yaXpvbnRhbC1saW5lLWRyYXdpbmd7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6RXpNVGN5TWlJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmtQU0pOTGpVZ09TNDFhRGN1TXpBMllUSXVNalVnTWk0eU5TQXdJREFnTVNBMExqTTRPQ0F3U0RFNUxqVjJNV2d0Tnk0ek1EWmhNaTR5TlNBeUxqSTFJREFnTUNBeExUUXVNemc0SURCSUxqVjZiVGt1TlNBeExqYzFZVEV1TWpVZ01TNHlOU0F3SURFZ01DQXdMVEl1TlNBeExqSTFJREV1TWpVZ01DQXdJREFnTUNBeUxqVWlJR05zYVhBdGNuVnNaVDBpWlhabGJtOWtaQ0l2UGp3dmMzWm5QZz09KX0uYWctY2hhcnRzLWljb24tbGluZS1jb2xvcnstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpBd01DSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKTk1UUXVNalF5SURJdU56SXlZeTB1TmpFeUlEQXRNUzR5TGpJME15MHhMall6TWk0Mk56VnNMVEV1TXpReklERXVNelEwWVM0MUxqVWdNQ0F3SURBdExqRXhNaTR4TVRKTU5DNHdOU0F4TVM0NU5UbGpMUzR5TURjdU1qQTNMUzR6Tmk0ME5pMHVORFEyTGpjMGRpNHdNREZzTFM0Mk9TQXlMamMyTjNZdU1EQXlZUzQ0TWk0NE1pQXdJREFnTUNBeExqQXlNaUF4TGpBeU1XZ3VNREF5YkRJdU5qTTBMUzQ0TWpKakxqSTRMUzR3T0RVdU5UTTBMUzR5TXpjdU56UXRMalEwTTJ3M0xqRXdOeTAzTGpFd09HRXVOUzQxSURBZ01DQXdJQzR4TVRJdExqRXhNbXd4TGpNME15MHhMak0wTTJFeUxqTXdPQ0F5TGpNd09DQXdJREFnTUMweExqWXpNaTB6TGprMFRURTBMakV5TWlBM2JERXVNRFEwTFRFdU1EUTFZVEV1TXpBNElERXVNekE0SURBZ01TQXdMVEV1T0RRNUxURXVPRFZNTVRJdU1qY3hJRFV1TVRWNmJTMHlMalUxT0MweExqRTBNaTAyTGpnd055QTJMamd3T1dFdU9DNDRJREFnTUNBd0xTNHhPVFl1TXpJMWJDMHVOelVnTWk0ME5qZ2dNaTQwTnkwdU56UTVZUzQ0TGpnZ01DQXdJREFnTGpNeU5TMHVNVGswYkRZdU9EQTRMVFl1T0RGNklpQmpiR2x3TFhKMWJHVTlJbVYyWlc1dlpHUWlMejQ4TDNOMlp6ND0pfS5hZy1jaGFydHMtaWNvbi1saW5lLXNlcmllc3stLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpFek1UY3lNaUlnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSnRNVGN1TXpZeUlEUXVPRGN6TFRRdU5UazBJRFl1TmpVMExUUXVPRFV0TXk0ek1UY3ROQzR5TlRFZ05pNDVOemN0TGpnMU5DMHVOVEpNTnk0Mk1USWdOaTQzT1d3MExqZzVPU0F6TGpNMUlEUXVNREk0TFRVdU9ETTJlaUlnWTJ4cGNDMXlkV3hsUFNKbGRtVnViMlJrSWk4K1BDOXpkbWMrKX0uYWctY2hhcnRzLWljb24tbGluZS1zdHlsZS1kYXNoZWR7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTWpBaUlHaGxhV2RvZEQwaU1qQWlJSFpwWlhkQ2IzZzlJakFnTUNBeU1DQXlNQ0lnWm1sc2JEMGlibTl1WlNJZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWo0OGNHRjBhQ0JtYVd4c1BTSWpNREF3SWlCa1BTSk5NaUE1YURSMk1VZ3llbTB4TWlBd2FEUjJNV2d0TkhwTk9DQTVhRFIyTVVnNGVpSXZQand2YzNablBnPT0pfS5hZy1jaGFydHMtaWNvbi1saW5lLXN0eWxlLWRvdHRlZHstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNakFpSUdobGFXZG9kRDBpTWpBaUlIWnBaWGRDYjNnOUlqQWdNQ0F5TUNBeU1DSWdabWxzYkQwaWJtOXVaU0lnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JajQ4WTJseVkyeGxJR040UFNJeUxqVWlJR041UFNJNUxqVWlJSEk5SWk0MUlpQm1hV3hzUFNJak1EQXdJaTgrUEdOcGNtTnNaU0JqZUQwaU5DNDFJaUJqZVQwaU9TNDFJaUJ5UFNJdU5TSWdabWxzYkQwaUl6QXdNQ0l2UGp4amFYSmpiR1VnWTNnOUlqWXVOU0lnWTNrOUlqa3VOU0lnY2owaUxqVWlJR1pwYkd3OUlpTXdNREFpTHo0OFkybHlZMnhsSUdONFBTSTRMalVpSUdONVBTSTVMalVpSUhJOUlpNDFJaUJtYVd4c1BTSWpNREF3SWk4K1BHTnBjbU5zWlNCamVEMGlNVEF1TlNJZ1kzazlJamt1TlNJZ2NqMGlMalVpSUdacGJHdzlJaU13TURBaUx6NDhZMmx5WTJ4bElHTjRQU0l4TWk0MUlpQmplVDBpT1M0MUlpQnlQU0l1TlNJZ1ptbHNiRDBpSXpBd01DSXZQanhqYVhKamJHVWdZM2c5SWpFMExqVWlJR041UFNJNUxqVWlJSEk5SWk0MUlpQm1hV3hzUFNJak1EQXdJaTgrUEdOcGNtTnNaU0JqZUQwaU1UWXVOU0lnWTNrOUlqa3VOU0lnY2owaUxqVWlJR1pwYkd3OUlpTXdNREFpTHo0OEwzTjJaejQ9KX0uYWctY2hhcnRzLWljb24tbGluZS1zdHlsZS1zb2xpZHstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNakFpSUdobGFXZG9kRDBpTWpBaUlIWnBaWGRDYjNnOUlqQWdNQ0F5TUNBeU1DSWdabWxzYkQwaWJtOXVaU0lnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JajQ4Y0dGMGFDQm1hV3hzUFNJak1EQXdJaUJrUFNKTk1pQTVhREUyZGpGSU1ub2lMejQ4TDNOMlp6ND0pfS5hZy1jaGFydHMtaWNvbi1saW5lLXdpdGgtbWFya2Vycy1zZXJpZXN7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6RXpNVGN5TWlJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmtQU0p0TVRndU1UazRJRFF1T0RnNExUTXVOVFUySURRdU9URTRZVEl1TWpVZ01pNHlOU0F3SURFZ01TMHpMamcyTmk0M05Xd3RNUzQwTXpJdExqbGhNaTR5TkNBeUxqSTBJREFnTUNBeExUSXVNREE1TGpRek5Xd3RNeTQ0TWpnZ05pNDBNamd0TGpnMkxTNDFNVEpNTmk0ME5TQTVMall5TTJFeUxqSTFJREl1TWpVZ01DQXhJREVnTXk0MU1TMHVOell4YkRFdU16STVMamd6TldFeUxqSTBJREl1TWpRZ01DQXdJREVnTWk0MU5UY3RMalE1TjJ3ekxqVTBNaTAwTGpnNU9IcHRMVFF1T1RZZ05TNHhOVE5oTVM0eU5TQXhMakkxSURBZ01TQXdMUzQyTkNBeUxqUXhPU0F4TGpJMUlERXVNalVnTUNBd0lEQWdMalkwTFRJdU5ERTVUVGt1TVNBNExqTXlNWEV1TURZMkxTNHhPVEl1TURZM0xTNDBNRFJoTVM0eU5TQXhMakkxSURBZ01TQXdMUzR3TmpjdU5EQTBJaUJqYkdsd0xYSjFiR1U5SW1WMlpXNXZaR1FpTHo0OEwzTjJaejQ9KX0uYWctY2hhcnRzLWljb24tbG9jaywuYWctY2hhcnRzLWljb24tbG9ja2Vkey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekF3TUNJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmtQU0pOTVRBdU1qQTNJRE11TnpZMFlUSXVPRGswSURJdU9EazBJREFnTUNBd0xUSXVPRGsxSURJdU9EazBWamxvTlM0M09EbFdOaTQyTlRoaE1pNDRPVFFnTWk0NE9UUWdNQ0F3SURBdE1pNDRPVFV0TWk0NE9UUk5NVFF1TVNBNVZqWXVOalU0WVRNdU9EazBJRE11T0RrMElEQWdNU0F3TFRjdU56ZzVJREIyTWk0ek5EbEJNaTQxSURJdU5TQXdJREFnTUNBMElERXhMalYyTTBFeUxqVWdNaTQxSURBZ01DQXdJRFl1TlNBeE4yZzRZVEl1TlNBeUxqVWdNQ0F3SURBZ01pNDFMVEl1TlhZdE0wRXlMalVnTWk0MUlEQWdNQ0F3SURFMExqVWdPWHBOTmk0MUlERXdRVEV1TlNBeExqVWdNQ0F3SURBZ05TQXhNUzQxZGpOQk1TNDFJREV1TlNBd0lEQWdNQ0EyTGpVZ01UWm9PR0V4TGpVZ01TNDFJREFnTUNBd0lERXVOUzB4TGpWMkxUTmhNUzQxSURFdU5TQXdJREFnTUMweExqVXRNUzQxZWlJZ1kyeHBjQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpOCtQQzl6ZG1jKyl9LmFnLWNoYXJ0cy1pY29uLW1lYXN1cmVyLWRyYXdpbmd7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTWpBaUlHaGxhV2RvZEQwaU1qQWlJSFpwWlhkQ2IzZzlJakFnTUNBeU1DQXlNQ0lnWm1sc2JEMGlibTl1WlNJZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWo0OGNHRjBhQ0JtYVd4c0xYSjFiR1U5SW1WMlpXNXZaR1FpSUdOc2FYQXRjblZzWlQwaVpYWmxibTlrWkNJZ1pEMGliVFF1TkRZeElERXlMamN4SURFdU5UTXlMVEV1TlRNeElERXVOREUwSURFdU5ERTBMamN3TnkwdU56QTNURFl1TnlBeE1DNDBOekpzTVM0MU16SXRNUzQxTXpNZ01pQXlJQzQzTURjdExqY3dOeTB5TFRJZ05pNHdNUzAyTGpBeElESXVPRE1nTWk0NE1qaE1OUzR3TlNBeE55NDNOemdnTWk0eU1qSWdNVFF1T1RWc01TNDFNekl0TVM0MU16SWdNUzQwTVRRZ01TNDBNVFF1TnpBM0xTNDNNRGQ2VFM0NE1EZ2dNVFF1T1RWc0xqY3dOeTB1TnpBM1RERTBMakkwTXlBeExqVXhOV3d1TnpBM0xTNDNNRGN1TnpBM0xqY3dOeUF5TGpneU9DQXlMamd5T0M0M01EY3VOekEzTFM0M01EY3VOekEzVERVdU56VTNJREU0TGpRNE5Xd3RMamN3Tnk0M01EY3RMamN3TnkwdU56QTNMVEl1T0RJNExUSXVPREk0ZW0weE1TNHdOemd0Tmk0NE16Vk1NVEF1TkRjZ05pNDNiQzQzTURjdExqY3dOeUF4TGpReE5TQXhMalF4TkhwdExqZ3lOQzB6TGpZMU5DQXhJREVnTGpjd09DMHVOekEzTFRFdE1Yb2lJR1pwYkd3OUlpTXhPREZFTVVZaUx6NDhMM04yWno0PSl9LmFnLWNoYXJ0cy1pY29uLW5vdGUtYW5ub3RhdGlvbnstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpBd01DSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKTk15QTBMalZCTVM0MUlERXVOU0F3SURBZ01TQTBMalVnTTJneE1VRXhMalVnTVM0MUlEQWdNQ0F4SURFM0lEUXVOWFk0WVRFdU5TQXhMalVnTUNBd0lERXRNUzQxSURFdU5XZ3RNeTR5TVd3dE1TNDBOamtnTWk0MU4yRXhJREVnTUNBd0lERXRNUzQyT0RJdU1EZzFURGN1TWpReklERTBTRFF1TlVFeExqVWdNUzQxSURBZ01DQXhJRE1nTVRJdU5YcE5OQzQxSURSaExqVXVOU0F3SURBZ01DMHVOUzQxZGpoaExqVXVOU0F3SURBZ01DQXVOUzQxYURNdU1qVTNiREl1TVRrMklETXVNRGMwVERFeExqY3hJREV6YURNdU56bGhMalV1TlNBd0lEQWdNQ0F1TlMwdU5YWXRPR0V1TlM0MUlEQWdNQ0F3TFM0MUxTNDFlaUlnWTJ4cGNDMXlkV3hsUFNKbGRtVnViMlJrSWk4K1BIQmhkR2dnWm1sc2JEMGlJekF3TUNJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmtQU0pOTmk0MUlEWXVOVUV1TlM0MUlEQWdNQ0F4SURjZ05tZzJZUzQxTGpVZ01DQXdJREVnTUNBeFNEZGhMalV1TlNBd0lEQWdNUzB1TlMwdU5VMDJMalVnT1M0MVFTNDFMalVnTUNBd0lERWdOeUE1YURaaExqVXVOU0F3SURBZ01TQXdJREZJTjJFdU5TNDFJREFnTUNBeExTNDFMUzQxSWlCamJHbHdMWEoxYkdVOUltVjJaVzV2WkdRaUx6NDhMM04yWno0PSl9LmFnLWNoYXJ0cy1pY29uLW9obGMtc2VyaWVzey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekV6TVRjeU1pSWdaRDBpVFRFeklERXhhQzB6ZGkweGFETldNMmd4ZGpKb05IWXhhQzAwZGpFeGFDMHhlazAySURFM2RpMHlhRE4yTFRGSU5sWTBTRFYyTVVneWRqRm9NM1l4TVhvaUx6NDhMM04yWno0PSl9LmFnLWNoYXJ0cy1pY29uLXBhbi1lbmR7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6QXdNQ0lnWkQwaWJUWXVOalEySURFekxqZ3hNeTB1TXpVekxqTTFOQzQzTURjdU56QTNMak0xTkMwdU16VTBlazB4TVM0eE5qWWdNVEJzTGpNMU5DNHpOVFF1TXpVMExTNHpOVFF0TGpNMU5DMHVNelUwZWswM0xqTTFOU0ExTGpRNElEY2dOUzR4TWpac0xTNDNNRGN1TnpBM0xqTTFNeTR6TlRSNmJUQWdPUzR3TkNBMExqRTJOaTAwTGpFMk5pMHVOekEzTFM0M01EZ3ROQzR4TmpjZ05DNHhOamQ2YlRRdU1UWTJMVFF1T0RjMFREY3VNelUwSURVdU5EaHNMUzQzTURndU56QTNJRFF1TVRZM0lEUXVNVFkzZWsweE15NHdPRE1nTlhZeE1HZ3hWalY2SWk4K1BDOXpkbWMrKX0uYWctY2hhcnRzLWljb24tcGFuLWxlZnR7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6QXdNQ0lnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSk5NVEl1TnprZ05TNDRNek1nT0M0Mk1qVWdNVEJzTkM0eE5qWWdOQzR4TmpjdExqY3dOeTQzTURkTU55NHlNU0F4TUd3MExqZzNNeTAwTGpnM05Ib2lJR05zYVhBdGNuVnNaVDBpWlhabGJtOWtaQ0l2UGp3dmMzWm5QZz09KX0uYWctY2hhcnRzLWljb24tcGFuLXJpZ2h0ey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekF3TUNJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmtQU0pOTnk0eU1TQXhOQzR4TmpjZ01URXVNemMySURFd0lEY3VNakVnTlM0NE16TnNMamN3TnkwdU56QTNUREV5TGpjNUlERXdiQzAwTGpnM015QTBMamczTkhvaUlHTnNhWEF0Y25Wc1pUMGlaWFpsYm05a1pDSXZQand2YzNablBnPT0pfS5hZy1jaGFydHMtaWNvbi1wYW4tc3RhcnR7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6QXdNQ0lnWkQwaVRUWWdOWFl4TUdneFZqVjZUVGt1TmpJMElERXdiRFF1TVRZMkxUUXVNVFkzTFM0M01EY3RMamN3TjB3NExqSXhJREV3YkRRdU9EYzBJRFF1T0RjMExqY3dOeTB1TnpBM2VpSXZQand2YzNablBnPT0pfS5hZy1jaGFydHMtaWNvbi1wYXJhbGxlbC1jaGFubmVsLC5hZy1jaGFydHMtaWNvbi1wYXJhbGxlbC1jaGFubmVsLWRyYXdpbmd7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6RXpNVGN5TWlJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmtQU0pOTVRjdU56SWdOUzR6TXpGQk1pNHlOU0F5TGpJMUlEQWdNU0F3SURFMExqY3dOU0F6TGpac0xUa3VORGtnTkM0MU5qSmhNaTR5TlNBeUxqSTFJREFnTVNBd0lDNHlNRGtnTVM0d01XdzVMalkyTWkwMExqWTBObUV5TGpJMUlESXVNalVnTUNBd0lEQWdNaTQyTXpRdU9EQTFiUzR6TnpNdE1pNDFORGRoTVM0eU5TQXhMakkxSURBZ01TQXhMVEl1TXpNNExqZzROU0F4TGpJMUlERXVNalVnTUNBd0lERWdNaTR6TXpndExqZzROVTAwTGpNME15QTRMalkzWVRFdU1qVWdNUzR5TlNBd0lERWdNUzB5TGpNek9DNDRPRFVnTVM0eU5TQXhMakkxSURBZ01DQXhJREl1TXpNNExTNDRPRFZOTlM0ek1EY2dNVFl1TnpJNFlUSXVNalVnTWk0eU5TQXdJREVnTVMwdU5USTFMUzQ0TlRoc09TNDVNak10TkM0M04yRXlMakkxSURJdU1qVWdNQ0F4SURFZ0xqTTRNUzQ1TWpaNmJTMHVPVFkwTGpJM05HRXhMakkxSURFdU1qVWdNQ0F4SURFdE1pNHpNemd1T0RnMUlERXVNalVnTVM0eU5TQXdJREFnTVNBeUxqTXpPQzB1T0RnMWJURXpMakF5TXkwMUxqRXdObUV4TGpJMUlERXVNalVnTUNBeElEQXRMamc0TlMweUxqTXpPU0F4TGpJMUlERXVNalVnTUNBd0lEQWdMamc0TlNBeUxqTXpPU0lnWTJ4cGNDMXlkV3hsUFNKbGRtVnViMlJrSWk4K1BDOXpkbWMrKX0uYWctY2hhcnRzLWljb24tcG9zaXRpb24tYm90dG9tey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1qQWlJR2hsYVdkb2REMGlNakFpSUhacFpYZENiM2c5SWpBZ01DQXlNQ0F5TUNJZ1ptbHNiRDBpYm05dVpTSWdlRzFzYm5NOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6SXdNREF2YzNabklqNDhjR0YwYUNCbWFXeHNQU0lqTURBd0lpQm1hV3hzTFc5d1lXTnBkSGs5SWk0eU5TSWdaRDBpVFRNZ01UQm9NVFIyTVVnemVtMHpMVE5vT0hZeFNEWjZJaTgrUEhCaGRHZ2dabWxzYkQwaUl6QXdNQ0lnWkQwaVRUWWdNVE5vT0hZeFNEWjZJaTgrUEM5emRtYyspfS5hZy1jaGFydHMtaWNvbi1wb3NpdGlvbi1jZW50ZXJ7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTWpBaUlHaGxhV2RvZEQwaU1qQWlJSFpwWlhkQ2IzZzlJakFnTUNBeU1DQXlNQ0lnWm1sc2JEMGlibTl1WlNJZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWo0OGNHRjBhQ0JtYVd4c1BTSWpNREF3SWlCa1BTSk5NeUF4TUdneE5IWXhTRE42SWk4K1BIQmhkR2dnWm1sc2JEMGlJekF3TUNJZ1ptbHNiQzF2Y0dGamFYUjVQU0l1TWpVaUlHUTlJazAySURkb09IWXhTRFo2YlRBZ05tZzRkakZJTm5vaUx6NDhMM04yWno0PSl9LmFnLWNoYXJ0cy1pY29uLXBvc2l0aW9uLXRvcHstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNakFpSUdobGFXZG9kRDBpTWpBaUlIWnBaWGRDYjNnOUlqQWdNQ0F5TUNBeU1DSWdabWxzYkQwaWJtOXVaU0lnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JajQ4Y0dGMGFDQm1hV3hzUFNJak1EQXdJaUJtYVd4c0xXOXdZV05wZEhrOUlpNHlOU0lnWkQwaVRUTWdNVEJvTVRSMk1VZ3plaUl2UGp4d1lYUm9JR1pwYkd3OUlpTXdNREFpSUdROUlrMDJJRGRvT0hZeFNEWjZJaTgrUEhCaGRHZ2dabWxzYkQwaUl6QXdNQ0lnWm1sc2JDMXZjR0ZqYVhSNVBTSXVNalVpSUdROUlrMDJJREV6YURoMk1VZzJlaUl2UGp3dmMzWm5QZz09KX0uYWctY2hhcnRzLWljb24tcHJpY2UtbGFiZWwtYW5ub3RhdGlvbnstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpBd01DSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKTk5DNDFJRE5CTVM0MUlERXVOU0F3SURBZ01DQXpJRFF1TlZZeE0yRXhMalVnTVM0MUlEQWdNQ0F3SURFdU5TQXhMalZvTGpnek0zWXVNRFUzWXk0eU5ESXRMakk1T1M0MU9UY3RMalV3TXlBeExTNDFORGhXTVRNdU5VZzBMalZCTGpVdU5TQXdJREFnTVNBMElERXpWalF1TldFdU5TNDFJREFnTUNBeElDNDFMUzQxYURFeFlTNDFMalVnTUNBd0lERWdMalV1TlhZNFlTNDFMalVnTUNBd0lERXRMalV1TldndE5DNDRNVGhzTFM0eE1qWXVNRGcwWVRJMklESTJJREFnTUNBd0xUSXVNakkxSURFdU5qZzFiQzB1TXpJdU1qWTFMUzR3TmpndU1EVTJZVEV1TlNBeExqVWdNQ0F3SURFdE1pNDJNRGtnTVM0ek5UUmpMakF6TXk0M05qTXVPVEExSURFdU1qTTRJREV1TlRZdU56VTJMalkwTmkwdU5EYzBJREV1TWpFdExqazBNeUF4TGpjMk1TMHhMalJzTGpNeE15MHVNalpCTWpZZ01qWWdNQ0F3SURFZ01UQXVPVGcySURFMFNERTFMalZoTVM0MUlERXVOU0F3SURBZ01DQXhMalV0TVM0MWRpMDRRVEV1TlNBeExqVWdNQ0F3SURBZ01UVXVOU0F6ZWlJZ1kyeHBjQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpOCtQSEJoZEdnZ1ptbHNiRDBpSXpFek1UY3lNaUlnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSk5PQzQzTVRZZ01UUXVPREUxWVRJdU1qVWdNaTR5TlNBd0lERWdNUzAwTGpJeElERXVOVGt6SURJdU1qVWdNaTR5TlNBd0lEQWdNU0EwTGpJeExURXVOVGt6YlMweExqWTJNaUF4TGprMk5tRXhMakkxSURFdU1qVWdNQ0F4SURBdExqZzROUzB5TGpNek9TQXhMakkxSURFdU1qVWdNQ0F3SURBZ0xqZzROU0F5TGpNek9TSWdZMnhwY0MxeWRXeGxQU0psZG1WdWIyUmtJaTgrUEM5emRtYyspfS5hZy1jaGFydHMtaWNvbi1wcmljZS1yYW5nZS1kcmF3aW5ney0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1qQWlJR2hsYVdkb2REMGlNakFpSUhacFpYZENiM2c5SWpBZ01DQXlNQ0F5TUNJZ1ptbHNiRDBpYm05dVpTSWdlRzFzYm5NOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6SXdNREF2YzNabklqNDhjR0YwYUNCa1BTSk5PUzR3TkRZZ01UVldOUzQ0Tnpkb0xqazBNbFl4TlhvaUlHWnBiR3c5SWlNeE9ERkVNVVlpTHo0OGNHRjBhQ0JrUFNKTk9TNHdORFlnTVRWV05TNDROemRvTGprME1sWXhOWG9pSUdacGJHdzlJaU14T0RGRU1VWWlMejQ4Y0dGMGFDQmtQU0pOT1M0MUlEWXVNakk0SURjdU1UWTNJRGd1TXpjMklEWXVOU0EzTGpjMk1pQTVMalVnTld3eklESXVOell5TFM0Mk5qY3VOakUwZWlJZ1ptbHNiRDBpSXpBd01DSXZQanh3WVhSb0lHUTlJazB5SURFNGRpMHhhREUyZGpGNlRUSWdNMVl5YURFMmRqRjZJaUJtYVd4c1BTSWpNVGd4UkRGR0lpOCtQQzl6ZG1jKyl9LmFnLWNoYXJ0cy1pY29uLXJlc2V0ey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekF3TUNJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmtQU0pOTVRJdU1EUWdOQzQwTkRWaE5TNDRNU0ExTGpneElEQWdNQ0F3TFRjdU1qVTNJREl1TkRVekxqVXVOU0F3SURBZ01TMHVPRFkxTFM0MU1ESkJOaTQ0TVNBMkxqZ3hJREFnTVNBeElETWdPUzQ0TVROaExqVXVOU0F3SURBZ01TQXhJREFnTlM0NE1TQTFMamd4SURBZ01TQXdJRGd1TURRdE5TNHpOamdpSUdOc2FYQXRjblZzWlQwaVpYWmxibTlrWkNJdlBqeHdZWFJvSUdacGJHdzlJaU13TURBaUlHWnBiR3d0Y25Wc1pUMGlaWFpsYm05a1pDSWdaRDBpVFRRdU1qZzVJRE11TURBeVlTNDFMalVnTUNBd0lERWdMalV1TlhZeUxqWTFOV2d5TGpZMU5XRXVOUzQxSURBZ01DQXhJREFnTVVnMExqSTVZUzQxTGpVZ01DQXdJREV0TGpVdExqVldNeTQxTURKaExqVXVOU0F3SURBZ01TQXVOUzB1TlNJZ1kyeHBjQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpOCtQQzl6ZG1jKyl9LmFnLWNoYXJ0cy1pY29uLXNldHRpbmdzey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjJhV1YzUW05NFBTSXdJREFnTWpBZ01qQWlJSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SWdlRzFzT25Od1lXTmxQU0p3Y21WelpYSjJaU0lnYzNSNWJHVTlJbVpwYkd3dGNuVnNaVHBsZG1WdWIyUmtJajQ4Y0dGMGFDQmtQU0pOTVRBZ01UTmhNeUF6SURBZ01TQXdJREF0TmlBeklETWdNQ0F3SURBZ01DQTJiVEF0TVdFeUlESWdNQ0F4SURFdExqQXdNUzB6TGprNU9VRXlJRElnTUNBd0lERWdNVEFnTVRJaUx6NDhjR0YwYUNCa1BTSk5NaTR6TVNBeE5DNHpORFZqTFM0NE1UY3RNUzQwT1RFdU1ESTNMVEl1TkRrNUxqUTNOQzB5TGpnMk5TNDFNekV0TGpRek5DNDVOamt0TGpNMk5TNDVOekl0TVM0ME9DMHVNREF6TFRFdU1URTFMUzQwTkRFdE1TNHdORFl0TGprM01pMHhMalE0TVMwdU5EVTBMUzR6TnpFdE1TNHpNVGN0TVM0ME1EVXRMalF6TkMweUxqa3pObXd1TURBMUxTNHdNRGxqTGpnNE5DMHhMalV5SURJdU1qQTNMVEV1TWprZ01pNDNOVFV0TVM0d09ETXVOalF4TGpJME15NDRNREV1TmpVMklERXVOelk0TGpFd01TNDVOalF0TGpVMkxqWTROaTB1T1RBMExqYzVOaTB4TGpVNE1pNHdPVFF0TGpVM09DNDFOVGt0TVM0NE5ETWdNaTR6TWpZdE1TNDRORE5vTGpBeFl6RXVOelU1TGpBd05TQXlMakl5TWlBeExqSTJOaUF5TGpNeE5pQXhMamcwTXk0eE1TNDJOemd0TGpFMk9DQXhMakF5TWk0M09UWWdNUzQxT0RJdU9UWTNMalUxTlNBeExqRXlOeTR4TkRJZ01TNDNOamd0TGpFd01TNDFORGt0TGpJd09DQXhMamczTmkwdU5ETTRJREl1TnpZZ01TNHdPVEp6TGpBeUlESXVOVFkxTFM0ME16UWdNaTQ1TXpaakxTNDFNekV1TkRNMUxTNDVOamt1TXpZMkxTNDVOeklnTVM0ME9ERXVNREF6SURFdU1URTFMalEwTVNBeExqQTBOaTQ1TnpJZ01TNDBPQzQwTlRRdU16Y3lJREV1TXpFM0lERXVOREEyTGpRek5DQXlMamt6TjJ3dExqQXdOUzR3TURsakxTNDRPRFFnTVM0MU1pMHlMakl3TnlBeExqSTVMVEl1TnpVMUlERXVNRGd6TFM0Mk5ERXRMakkwTXkwdU9EQXhMUzQyTlRZdE1TNDNOamd0TGpFd01TMHVPVFkwTGpVMkxTNDJPRFl1T1RBMExTNDNPVFlnTVM0MU9ERXRMakE1TkM0MU56a3RMalUxT1NBeExqZzBOQzB5TGpNeU5pQXhMamcwTkdndExqQXhZeTB4TGpjMU9TMHVNREExTFRJdU1qSXlMVEV1TWpZMkxUSXVNekUyTFRFdU9EUTBMUzR4TVMwdU5qYzNMakUyT0MweExqQXlNUzB1TnprMkxURXVOVGd4TFM0NU5qY3RMalUxTlMweExqRXlOeTB1TVRReUxURXVOelk0TGpFd01TMHVOVFE1TGpJd09DMHhMamczTmk0ME16Z3RNaTQzTmkweExqQTVNbXd0TGpBeUxTNHdNelo2VFRrdU9UZzBJREl1TVRZeVNERXdZekV1TXpVMUlEQWdNUzR6TkRJZ01TNHdNemtnTVM0ek5UTWdNUzQwTWpVdU1EQTRMak14TWk0d05DQXhMakUySURFdU1qVTVJREV1T0RjeWJDNHdNVFV1TURBNFl6RXVNakkxTGpjZ01TNDVOell1TXpBMElESXVNalV4TGpFMU5TNHpNemN0TGpFNE15QXhMakl5TmkwdU56RXhJREV1T1RBeUxqUTBOV3d1TURBNExqQXhOR011TmpjNElERXVNVGN6TFM0eU1qa2dNUzQyT0RJdExqVTFPQ0F4TGpnNE5DMHVNalkyTGpFMk15MHVPVGcwTGpZeE5TMHVPVGt4SURJdU1ESTNkaTR3TVRaakxqQXdOeUF4TGpReE1pNDNNalVnTVM0NE5qUXVPVGt4SURJdU1ESTNMak15T0M0eU1ERWdNUzR5TWprdU56QTNMalUyTmlBeExqZzNiQzB1TURBNExqQXhOR010TGpZM055QXhMakUzTkMweExqVTNNUzQyTkRNdE1TNDVNUzQwTlRrdExqSTNOUzB1TVRRNUxURXVNREkyTFM0MU5EVXRNaTR5TlRFdU1UVTBiQzB1TURFMUxqQXdPV010TVM0eU1Ua3VOekV5TFRFdU1qVXhJREV1TlRZdE1TNHlOVGtnTVM0NE56SXRMakF4TVM0ek9EWXVNREF5SURFdU5ESTFMVEV1TXpVeklERXVOREkxY3kweExqTTBNaTB4TGpBek9TMHhMak0xTXkweExqUXlOV010TGpBd09DMHVNekV5TFM0d05DMHhMakUyTFRFdU1qVTVMVEV1T0RjeWJDMHVNREUxTFM0d01EbGpMVEV1TWpJMUxTNDJPVGt0TVM0NU56WXRMak13TXkweUxqSTFNUzB1TVRVMExTNHpNell1TVRnekxURXVNakU1TGpjd05pMHhMamc1TkMwdU5ETXliQzB1TURFMkxTNHdNamRqTFM0Mk56Z3RNUzR4TnpRdU1qSTVMVEV1TmpneUxqVTFPQzB4TGpnNE5DNHlOall0TGpFMk15NDVPRFF0TGpZeE5TNDVPVEV0TWk0d01qZDJMUzR3TVRaakxTNHdNRGN0TVM0ME1USXRMamN5TlMweExqZzJOQzB1T1RreExUSXVNREkzTFM0ek1qZ3RMakl3TVMweExqSXlPUzB1TnpBM0xTNDFOall0TVM0NE4yd3VNREE0TFM0d01UUmpMalkzTnkweExqRTNOQ0F4TGpVM01TMHVOalF6SURFdU9URXRMalExT1M0eU56VXVNVFE1SURFdU1ESTJMalUwTlNBeUxqSTFNUzB1TVRVMWJDNHdNVFV0TGpBd09HTXhMakl4T1MwdU56RXlJREV1TWpVeExURXVOVFlnTVM0eU5Ua3RNUzQ0TnpJdU1ERXRMak00TkMwdU1EQXlMVEV1TkRFM0lERXVNek0zTFRFdU5ESTFJaTgrUEM5emRtYyspfS5hZy1jaGFydHMtaWNvbi1zdGVwLWxpbmUtc2VyaWVzey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekU0TVVReFJpSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKTk5pQTBhRFYyT0dnelZqaG9OWFl4YUMwMGRqUm9MVFZXTlVnM2RqRXdTREoyTFRGb05Ib2lJR05zYVhBdGNuVnNaVDBpWlhabGJtOWtaQ0l2UGp3dmMzWm5QZz09KX0uYWctY2hhcnRzLWljb24tdGV4dC1hbm5vdGF0aW9uey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1qQWlJR2hsYVdkb2REMGlNakFpSUhacFpYZENiM2c5SWpBZ01DQXlNQ0F5TUNJZ1ptbHNiRDBpYm05dVpTSWdlRzFzYm5NOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6SXdNREF2YzNabklqNEtQSEJoZEdnZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmpiR2x3TFhKMWJHVTlJbVYyWlc1dlpHUWlJR1E5SWswMElEUklNVFpXTjBneE5WWTFTREV3TGpWV01UVklNVFJXTVRaSU5sWXhOVWc1TGpWV05VZzFWamRJTkZZMFdpSWdabWxzYkQwaVlteGhZMnNpTHo0S1BDOXpkbWMrQ2c9PSl9LmFnLWNoYXJ0cy1pY29uLXRyZW5kLWxpbmUsLmFnLWNoYXJ0cy1pY29uLXRyZW5kLWxpbmUtZHJhd2luZ3stLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpFek1UY3lNaUlnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSk5OUzR6TVRRZ01UQXVPVE00WVRJdU1qVWdNaTR5TlNBd0lERWdNU0F1TURFdE1XZzVMak0xTW1FeUxqSTFJREl1TWpVZ01DQXhJREVnTGpBeElERjZiUzB5TGpFNE9TNDNNamxoTVM0eU5TQXhMakkxSURBZ01TQXdJREF0TWk0MUlERXVNalVnTVM0eU5TQXdJREFnTUNBd0lESXVOVzB4TXk0M05TQXdZVEV1TWpVZ01TNHlOU0F3SURFZ01DQXdMVEl1TlNBeExqSTFJREV1TWpVZ01DQXdJREFnTUNBeUxqVWlJR05zYVhBdGNuVnNaVDBpWlhabGJtOWtaQ0l2UGp3dmMzWm5QZz09KX0uYWctY2hhcnRzLWljb24tdW5sb2NrLC5hZy1jaGFydHMtaWNvbi11bmxvY2tlZHstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpBd01DSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKTk1UQXVOalV4SURNdU5XRXlMamc1TkNBeUxqZzVOQ0F3SURBZ01DMHlMamc1TkNBeUxqZzVORlk1U0RFMExqVmhNaTQxSURJdU5TQXdJREFnTVNBeUxqVWdNaTQxZGpOaE1pNDFJREl1TlNBd0lEQWdNUzB5TGpVZ01pNDFhQzA0UVRJdU5TQXlMalVnTUNBd0lERWdOQ0F4TkM0MWRpMHpRVEl1TlNBeUxqVWdNQ0F3SURFZ05pNDFJRGxvTGpJMU4xWTJMak01TkdFekxqZzVOQ0F6TGpnNU5DQXdJREVnTVNBM0xqYzRPU0F3SUM0MUxqVWdNQ0F3SURFdE1TQXdRVEl1T0RrMElESXVPRGswSURBZ01DQXdJREV3TGpZMUlETXVOVTAyTGpVZ01UQkJNUzQxSURFdU5TQXdJREFnTUNBMUlERXhMalYyTTBFeExqVWdNUzQxSURBZ01DQXdJRFl1TlNBeE5tZzRZVEV1TlNBeExqVWdNQ0F3SURBZ01TNDFMVEV1TlhZdE0yRXhMalVnTVM0MUlEQWdNQ0F3TFRFdU5TMHhMalY2SWlCamJHbHdMWEoxYkdVOUltVjJaVzV2WkdRaUx6NDhMM04yWno0PSl9LmFnLWNoYXJ0cy1pY29uLXZlcnRpY2FsLWxpbmUsLmFnLWNoYXJ0cy1pY29uLXZlcnRpY2FsLWxpbmUtZHJhd2luZ3stLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpFek1UY3lNaUlnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSk5NVEF1TlNBM0xqZ3dObUV5TGpJMUlESXVNalVnTUNBd0lERWdNQ0EwTGpNNE9GWXhPUzQxYUMweGRpMDNMak13Tm1FeUxqSTFJREl1TWpVZ01DQXdJREVnTUMwMExqTTRPRll1TldneGVtMHRMalV1T1RRMFlURXVNalVnTVM0eU5TQXdJREVnTVNBd0lESXVOU0F4TGpJMUlERXVNalVnTUNBd0lERWdNQzB5TGpVaUlHTnNhWEF0Y25Wc1pUMGlaWFpsYm05a1pDSXZQand2YzNablBnPT0pfS5hZy1jaGFydHMtaWNvbi16b29tLWluey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekF3TUNJZ1pEMGlUVEV3SURVdU5XRXVOUzQxSURBZ01DQXhJQzQxTGpWMk15NDFhRE11T0RjMVlTNDFMalVnTUNBd0lERWdNQ0F4U0RFd0xqVjJOQzR5TldFdU5TNDFJREFnTVNBeExURWdNRll4TUM0MVNEVXVOakkxWVM0MUxqVWdNQ0F4SURFZ01DMHhTRGt1TlZZMllTNDFMalVnTUNBd0lERWdMalV0TGpVaUx6NDhMM04yWno0PSl9LmFnLWNoYXJ0cy1pY29uLXpvb20tb3V0ey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekF3TUNJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmtQU0pOTlM0MUlERXdZUzQxTGpVZ01DQXdJREVnTGpVdExqVm9PR0V1TlM0MUlEQWdNQ0F4SURBZ01VZzJZUzQxTGpVZ01DQXdJREV0TGpVdExqVWlJR05zYVhBdGNuVnNaVDBpWlhabGJtOWtaQ0l2UGp3dmMzWm5QZz09KX0uYWctY2hhcnRzLWljb24taGlnaC1sb3ctc2VyaWVzey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekV6TVRjeU1pSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKTk55QTBhREoyTVRKSU5GWTBhRE5OTlNBMWFETjJNVEJJTlhwTk1URWdNVFJXTm1nMWRqaG9MVFZ0TVMwM2FETjJObWd0TTNvaUlHTnNhWEF0Y25Wc1pUMGlaWFpsYm05a1pDSXZQand2YzNablBnPT0pfS5hZy1jaGFydHMtaWNvbi1obGMtc2VyaWVzey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekV6TVRjeU1pSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKdE1UZ3VNVFl6SURFdU9ETTNMVFV1TXpNMElERXhMall5TVV3MkxqazFOeUE0TGpFeWJDMDBMakU1T1NBNUxqWXlNaTB1T1RFMkxTNDBJRFF1TnpVMkxURXdMamxNTVRJdU5Ea2dNVEV1T0NBeE55NHlOVFFnTVM0ME1ub2lJR05zYVhBdGNuVnNaVDBpWlhabGJtOWtaQ0l2UGp4d1lYUm9JR1pwYkd3OUlpTXdNREFpSUdacGJHd3RiM0JoWTJsMGVUMGlMalFpSUdacGJHd3RjblZzWlQwaVpYWmxibTlrWkNJZ1pEMGlUVFV1T0RJMUlESXVOekEwTGpVMUlERXpMamM0Tld3dU9UQXlMalF6SURRdU56STBMVGt1T1RFNUlEWXVNRE0wSURVdU1ESTVJRE11TWpVMUxUZ3VNVFF0TGpreU9DMHVNemN0TWk0M05EVWdOaTQ0Tm5wdE55NDROVElnTVRRdU5qTTJJRFV1TnpndE1UTXVNVE01TFM0NU1UVXRMalF3TWkwMUxqSXhPU0F4TVM0NE5pMDJMakF3TlMwMUxqVXdOQzB6TGpJM09DQTNMalkwT0M0NU1pNHpPVFFnTWk0M01qSXROaTR6TlRKNklpQmpiR2x3TFhKMWJHVTlJbVYyWlc1dlpHUWlMejQ4TDNOMlp6ND0pfS5hZy1jaGFydHMtaWNvbi16b29tLWluLWxlZ2FjeXstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNVFlpSUdobGFXZG9kRDBpTVRZaUlHWnBiR3c5SW01dmJtVWlJSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SStQSEJoZEdnZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmpiR2x3TFhKMWJHVTlJbVYyWlc1dlpHUWlJR1E5SWswNExqYzFJRFF1TldFdU56VXVOelVnTUNBd0lEQXRNUzQxSURCMk1pNDNOVWcwTGpWaExqYzFMamMxSURBZ01DQXdJREFnTVM0MWFESXVOelYyTWk0M05XRXVOelV1TnpVZ01DQXdJREFnTVM0MUlEQldPQzQzTldneUxqYzFZUzQzTlM0M05TQXdJREFnTUNBd0xURXVOVWc0TGpjMVZqUXVOVm9pSUdacGJHdzlJaU13TURBaUx6NDhMM04yWno0PSl9LmFnLWNoYXJ0cy1pY29uLXpvb20tb3V0LWxlZ2FjeXstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNVFlpSUdobGFXZG9kRDBpTVRZaUlHWnBiR3c5SW01dmJtVWlJSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SStQSEJoZEdnZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmpiR2x3TFhKMWJHVTlJbVYyWlc1dlpHUWlJR1E5SWswekxqYzFJRGhoTGpjMUxqYzFJREFnTUNBeElDNDNOUzB1TnpWb04yRXVOelV1TnpVZ01DQXdJREVnTUNBeExqVm9MVGRCTGpjMUxqYzFJREFnTUNBeElETXVOelVnT0ZvaUlHWnBiR3c5SWlNd01EQWlMejQ4TDNOMlp6ND0pfS5hZy1jaGFydHMtaWNvbi16b29tLWluLWFsdCwuYWctY2hhcnRzLWljb24tem9vbS1pbi1hbHQtbGVnYWN5ey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU5DSWdhR1ZwWjJoMFBTSXlOQ0lnZG1sbGQwSnZlRDBpTUNBd0lESTBJREkwSWlCbWFXeHNQU0p1YjI1bElpQnpkSEp2YTJVOUltTjFjbkpsYm5SRGIyeHZjaUlnYzNSeWIydGxMWGRwWkhSb1BTSXlJaUJ6ZEhKdmEyVXRiR2x1WldOaGNEMGljbTkxYm1RaUlITjBjbTlyWlMxc2FXNWxhbTlwYmowaWNtOTFibVFpSUdOc1lYTnpQU0pzZFdOcFpHVWdiSFZqYVdSbExYcHZiMjB0YVc0aVBqeGphWEpqYkdVZ1kzZzlJakV4SWlCamVUMGlNVEVpSUhJOUlqZ2lMejQ4YkdsdVpTQjRNVDBpTWpFaUlIZ3lQU0l4Tmk0Mk5TSWdlVEU5SWpJeElpQjVNajBpTVRZdU5qVWlMejQ4YkdsdVpTQjRNVDBpTVRFaUlIZ3lQU0l4TVNJZ2VURTlJamdpSUhreVBTSXhOQ0l2UGp4c2FXNWxJSGd4UFNJNElpQjRNajBpTVRRaUlIa3hQU0l4TVNJZ2VUSTlJakV4SWk4K1BDOXpkbWMrKX0uYWctY2hhcnRzLWljb24tem9vbS1vdXQtYWx0LC5hZy1jaGFydHMtaWNvbi16b29tLW91dC1hbHQtbGVnYWN5ey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU5DSWdhR1ZwWjJoMFBTSXlOQ0lnZG1sbGQwSnZlRDBpTUNBd0lESTBJREkwSWlCbWFXeHNQU0p1YjI1bElpQnpkSEp2YTJVOUltTjFjbkpsYm5SRGIyeHZjaUlnYzNSeWIydGxMWGRwWkhSb1BTSXlJaUJ6ZEhKdmEyVXRiR2x1WldOaGNEMGljbTkxYm1RaUlITjBjbTlyWlMxc2FXNWxhbTlwYmowaWNtOTFibVFpSUdOc1lYTnpQU0pzZFdOcFpHVWdiSFZqYVdSbExYcHZiMjB0YjNWMElqNDhZMmx5WTJ4bElHTjRQU0l4TVNJZ1kzazlJakV4SWlCeVBTSTRJaTgrUEd4cGJtVWdlREU5SWpJeElpQjRNajBpTVRZdU5qVWlJSGt4UFNJeU1TSWdlVEk5SWpFMkxqWTFJaTgrUEd4cGJtVWdlREU5SWpnaUlIZ3lQU0l4TkNJZ2VURTlJakV4SWlCNU1qMGlNVEVpTHo0OEwzTjJaejQ9KX0uYWctY2hhcnRzLWljb24tcmVzZXQtbGVnYWN5ey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1UWWlJR2hsYVdkb2REMGlNVFlpSUdacGJHdzlJbTV2Ym1VaUlIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJK1BIQmhkR2dnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCamJHbHdMWEoxYkdVOUltVjJaVzV2WkdRaUlHUTlJazAwTGpReE1pQTBMakExT0NBeUxqYzFJREl1TXprMlZqWXVOelZvTGpjME5HRXVOell1TnpZZ01DQXdJREFnTGpBeE1pQXdhRE11TlRrNFREVXVORGM0SURVdU1USTFZVFF1TVRJMUlEUXVNVEkxSURBZ01DQXhJREl1TlRJekxTNDROelVnTXk0M05TQXpMamMxSURBZ01TQXhMVE11TVRFNUlEVXVPRE16TGpjMUxqYzFJREFnTUNBd0xURXVNalEzTGpnek5FRTFMakkxSURVdU1qVWdNQ0F4SURBZ09DQXlMamMxYUMwdU1EQXpZVFV1TmpJMUlEVXVOakkxSURBZ01DQXdMVE11TlRnMUlERXVNekE0V2lJZ1ptbHNiRDBpSXpBd01DSXZQand2YzNablBnPT0pfS5hZy1jaGFydHMtaWNvbi1wYW4tbGVmdC1sZWdhY3l7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTVRZaUlHaGxhV2RvZEQwaU1UWWlJR1pwYkd3OUltNXZibVVpSUhodGJHNXpQU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh5TURBd0wzTjJaeUkrUEhCaGRHZ2dabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJqYkdsd0xYSjFiR1U5SW1WMlpXNXZaR1FpSUdROUlrMHhNQzR3TXlBMExqUTNZUzQzTlM0M05TQXdJREFnTVNBd0lERXVNRFpNTnk0MU5pQTRiREl1TkRjZ01pNDBOMkV1TnpVdU56VWdNQ0F4SURFdE1TNHdOaUF4TGpBMmJDMHpMVE5oTGpjMUxqYzFJREFnTUNBeElEQXRNUzR3Tm13ekxUTmhMamMxTGpjMUlEQWdNQ0F4SURFdU1EWWdNRm9pSUdacGJHdzlJaU13TURBaUx6NDhMM04yWno0PSl9LmFnLWNoYXJ0cy1pY29uLXBhbi1yaWdodC1sZWdhY3l7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTVRZaUlHaGxhV2RvZEQwaU1UWWlJR1pwYkd3OUltNXZibVVpSUhodGJHNXpQU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh5TURBd0wzTjJaeUkrUEhCaGRHZ2dabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJqYkdsd0xYSjFiR1U5SW1WMlpXNXZaR1FpSUdROUlrMDFMamszSURFeExqVXpZUzQzTlM0M05TQXdJREFnTVNBd0xURXVNRFpNT0M0ME5DQTRJRFV1T1RjZ05TNDFNMkV1TnpVdU56VWdNQ0F3SURFZ01TNHdOaTB4TGpBMmJETWdNMkV1TnpVdU56VWdNQ0F3SURFZ01DQXhMakEyYkMweklETmhMamMxTGpjMUlEQWdNQ0F4TFRFdU1EWWdNRm9pSUdacGJHdzlJaU13TURBaUx6NDhMM04yWno0PSl9LmFnLWNoYXJ0cy1pY29uLXBhbi1zdGFydC1sZWdhY3l7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TkNJZ2FHVnBaMmgwUFNJeU5DSWdkbWxsZDBKdmVEMGlNQ0F3SURJMElESTBJaUJtYVd4c1BTSnViMjVsSWlCemRISnZhMlU5SW1OMWNuSmxiblJEYjJ4dmNpSWdjM1J5YjJ0bExYZHBaSFJvUFNJeUlpQnpkSEp2YTJVdGJHbHVaV05oY0QwaWNtOTFibVFpSUhOMGNtOXJaUzFzYVc1bGFtOXBiajBpY205MWJtUWlJR05zWVhOelBTSnNkV05wWkdVZ2JIVmphV1JsTFdOb1pYWnliMjR0Wm1seWMzUWlQanh3WVhSb0lHUTlJbTB4TnlBeE9DMDJMVFlnTmkwMklpOCtQSEJoZEdnZ1pEMGlUVGNnTm5ZeE1pSXZQand2YzNablBnPT0pfS5hZy1jaGFydHMtaWNvbi1wYW4tZW5kLWxlZ2FjeXstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlOQ0lnYUdWcFoyaDBQU0l5TkNJZ2RtbGxkMEp2ZUQwaU1DQXdJREkwSURJMElpQm1hV3hzUFNKdWIyNWxJaUJ6ZEhKdmEyVTlJbU4xY25KbGJuUkRiMnh2Y2lJZ2MzUnliMnRsTFhkcFpIUm9QU0l5SWlCemRISnZhMlV0YkdsdVpXTmhjRDBpY205MWJtUWlJSE4wY205clpTMXNhVzVsYW05cGJqMGljbTkxYm1RaUlHTnNZWE56UFNKc2RXTnBaR1VnYkhWamFXUmxMV05vWlhaeWIyNHRiR0Z6ZENJK1BIQmhkR2dnWkQwaWJUY2dNVGdnTmkwMkxUWXROaUl2UGp4d1lYUm9JR1E5SWsweE55QTJkakV5SWk4K1BDOXpkbWMrKX0uYWctY2hhcnRzLWljb24tdHJlbmQtbGluZS1sZWdhY3l7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTVRZaUlHaGxhV2RvZEQwaU1UWWlJR1pwYkd3OUltNXZibVVpSUhodGJHNXpQU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh5TURBd0wzTjJaeUkrUEdOcGNtTnNaU0JqZUQwaU1pNDFJaUJqZVQwaU9DSWdjajBpTVM0M05TSWdjM1J5YjJ0bFBTSWpNREF3SWlCemRISnZhMlV0ZDJsa2RHZzlJakV1TlNJdlBqeGphWEpqYkdVZ1kzZzlJakV6TGpVaUlHTjVQU0k0SWlCeVBTSXhMamMxSWlCemRISnZhMlU5SWlNd01EQWlJSE4wY205clpTMTNhV1IwYUQwaU1TNDFJaTgrUEhCaGRHZ2djM1J5YjJ0bFBTSWpNREF3SWlCemRISnZhMlV0ZDJsa2RHZzlJakV1TlNJZ1pEMGlUVFFnT0dnNElpOCtQQzl6ZG1jKyl9LmFnLWNoYXJ0cy1pY29uLWhvcml6b250YWwtbGluZS1sZWdhY3l7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTVRZaUlHaGxhV2RvZEQwaU1UWWlJR1pwYkd3OUltNXZibVVpSUhodGJHNXpQU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh5TURBd0wzTjJaeUkrUEhCaGRHZ2dabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJqYkdsd0xYSjFiR1U5SW1WMlpXNXZaR1FpSUdROUlrMHhNQzR6T0RZZ09DNDNOV0V5TGpVd01TQXlMalV3TVNBd0lEQWdNUzAwTGpjM01pQXdTQzQzTldFdU56VXVOelVnTUNBd0lERWdNQzB4TGpWb05DNDROalJoTWk0MU1ERWdNaTQxTURFZ01DQXdJREVnTkM0M056SWdNR2cwTGpnMk5HRXVOelV1TnpVZ01DQXdJREVnTUNBeExqVm9MVFF1T0RZMFdrMDVJRGhoTVNBeElEQWdNU0F4TFRJZ01DQXhJREVnTUNBd0lERWdNaUF3V2lJZ1ptbHNiRDBpSXpBd01DSXZQand2YzNablBnPT0pfS5hZy1jaGFydHMtaWNvbi12ZXJ0aWNhbC1saW5lLWxlZ2FjeXstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNVFlpSUdobGFXZG9kRDBpTVRZaUlHWnBiR3c5SW01dmJtVWlJSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SStQSEJoZEdnZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmpiR2x3TFhKMWJHVTlJbVYyWlc1dlpHUWlJR1E5SWswNExqYzFJRFV1TmpFMFlUSXVOVEF4SURJdU5UQXhJREFnTUNBeElEQWdOQzQzTnpKMk5DNDROalJoTGpjMUxqYzFJREFnTUNBeExURXVOU0F3ZGkwMExqZzJOR0V5TGpVd01TQXlMalV3TVNBd0lEQWdNU0F3TFRRdU56Y3lWaTQzTldFdU56VXVOelVnTUNBd0lERWdNUzQxSURCMk5DNDROalJhVFRnZ04yRXhJREVnTUNBeElERWdNQ0F5SURFZ01TQXdJREFnTVNBd0xUSmFJaUJtYVd4c1BTSWpNREF3SWk4K1BDOXpkbWMrKX0uYWctY2hhcnRzLWljb24tcGFyYWxsZWwtY2hhbm5lbC1sZWdhY3l7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTVRjaUlHaGxhV2RvZEQwaU1UWWlJR1pwYkd3OUltNXZibVVpSUhodGJHNXpQU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh5TURBd0wzTjJaeUkrUEhCaGRHZ2dabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJqYkdsd0xYSjFiR1U5SW1WMlpXNXZaR1FpSUdROUlrMHhOQzQwTWpRZ05DNDVNbUV5TGpVZ01pNDFJREFnTVNBd0xUTXVNemMzTFRJdU1UUnNMVFl1TmpNZ01pNDVZVEl1TlRBeElESXVOVEF4SURBZ01TQXdJQzQyTURjZ01TNHpOekpzTmk0MU9EVXRNaTQ0T0dFeUxqVXdNU0F5TGpVd01TQXdJREFnTUNBeUxqZ3hOUzQzTkRoYWJTNHdOUzB5TGpZNU0yRXhJREVnTUNBeElERXRNUzQ0Tnk0M01EZ2dNU0F4SURBZ01DQXhJREV1T0RjdExqY3dPRnB0TFRFeElEUXVOelZoTVNBeElEQWdNU0F4TFRFdU9EY3VOekE0SURFZ01TQXdJREFnTVNBeExqZzNMUzQzTURoYWJURXVOVFVnTmk0d056VmhNaTQxTURFZ01pNDFNREVnTUNBeElERXRMall3TnkweExqTTNNbXcyTGpZekxUSXVPV0V5TGpVd01TQXlMalV3TVNBd0lERWdNU0F1TlRZeUlERXVNemt4YkMwMkxqVTROU0F5TGpnNFdtMHRNUzQxTlMwdU1EYzFZVEVnTVNBd0lERWdNUzB4TGpnM0xqY3dPQ0F4SURFZ01DQXdJREVnTVM0NE55MHVOekE0V20weE1DNDBNaTB6TGpRMllURWdNU0F3SURFZ01DMHVOekE1TFRFdU9EY2dNU0F4SURBZ01DQXdJQzQzTURnZ01TNDROMW9pSUdacGJHdzlJaU13TURBaUx6NDhMM04yWno0PSl9LmFnLWNoYXJ0cy1pY29uLWRpc2pvaW50LWNoYW5uZWwtbGVnYWN5ey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1UY2lJR2hsYVdkb2REMGlNVFlpSUdacGJHdzlJbTV2Ym1VaUlIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJK1BIQmhkR2dnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCamJHbHdMWEoxYkdVOUltVjJaVzV2WkdRaUlHUTlJazB4TkM0ME1qUWdOQzQ1TW1FeUxqVWdNaTQxSURBZ01TQXdMVE11TXpnekxUSXVORFV6VERRdU5qa2dOQzR3TlRWaE1pNDFJREl1TlNBd0lERWdNQ0F1TXpRMElERXVORFpzTmk0ek9USXRNUzQxT1RoaE1pNDFNREVnTWk0MU1ERWdNQ0F3SURBZ015QXhMakF3TTFwdExqQTFMVEl1TmprellURWdNU0F3SURFZ01TMHhMamczTGpjd09DQXhJREVnTUNBd0lERWdNUzQ0TnkwdU56QTRXbTB0TVRFZ01pNDNOV0V4SURFZ01DQXhJREV0TVM0NE55NDNNRGdnTVNBeElEQWdNQ0F4SURFdU9EY3RMamN3T0ZwdE1TNDFOaUExTGpReVlUSXVOU0F5TGpVZ01DQXhJREF0TGpNME5TQXhMalEyTVd3MkxqTTFNaUF4TGpVNE9HRXlMalVnTWk0MUlEQWdNU0F3SUM0ek9EUXRNUzQwTld3dE5pNHpPVEl0TVM0MU9UaGFiUzB4TGpVMkxqVXpPR0V4SURFZ01DQXhJREF0TVM0NE55MHVOekE0SURFZ01TQXdJREFnTUNBeExqZzNMamN3T0ZwdE1UQXVORElnTVM0ME5qRmhNU0F4SURBZ01TQXhMUzQzTURrZ01TNDROeUF4SURFZ01DQXdJREVnTGpjd09DMHhMamczV2lJZ1ptbHNiRDBpSXpBd01DSXZQand2YzNablBnPT0pfS5hZy1jaGFydHMtaWNvbi1saW5lLWNvbG9yLWxlZ2FjeXstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNVFlpSUdobGFXZG9kRDBpTVRZaUlHWnBiR3c5SW01dmJtVWlJSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SStQR2NnWTJ4cGNDMXdZWFJvUFNKMWNtd29JMkVwSWo0OGNHRjBhQ0JtYVd4c0xYSjFiR1U5SW1WMlpXNXZaR1FpSUdOc2FYQXRjblZzWlQwaVpYWmxibTlrWkNJZ1pEMGlUVEV5TGpjNE9DNDFPRE5oTWk0Mk15QXlMall6SURBZ01DQXdMVEV1T0RZdU56ZE1PUzQxTkRRZ01pNDNNemhoTGpjMU55NDNOVGNnTUNBd0lEQXRMakUwTGpFMFRESXVNRE15SURFd0xqSTFkaTR3TURGakxTNHlOREl1TWpReExTNDBNaTQxTXpndExqVXlMamcyTkd3dExqQXdNaTR3TURJdExqZzRJREl1T1RBeUxTNHdNREV1TURBellURXVNRGd6SURFdU1EZ3pJREFnTUNBd0lERXVNelVnTVM0ek5EZG9MakF3TVd3eUxqa3dNaTB1T0Rob0xqQXdNV011TXpJMkxTNHhMall5TXkwdU1qYzNMamcyTlMwdU5URTRkaTB1TURBeGJEY3VNemMxTFRjdU16YzJZUzQzTmpNdU56WXpJREFnTUNBd0lDNHhNemt0TGpFek9Xd3hMak00TkMweExqTTRORUV5TGpZeklESXVOak1nTUNBd0lEQWdNVEl1TnpnNExqVTRNMXB0TFM0eE1qWWdOQzR6TlRJdU9USTBMUzQ1TWpSaE1TNHhNeUF4TGpFeklEQWdNQ0F3TFRFdU5UazNMVEV1TlRrM2JDMHVPVEkwTGpreU5DQXhMalU1TnlBeExqVTVOMXB0TFRJdU5qVTNMUzQxTXpZdE5pNDVNVE1nTmk0NU1UUklNeTR3T1dFdU5UZ3pMalU0TXlBd0lEQWdNQzB1TVRRMkxqSTBNbXd0TGpZMU15QXlMakUxTXlBeUxqRTFOUzB1TmpVMFlTNDFPRE11TlRneklEQWdNQ0F3SUM0eU5ERXRMakUwTkd3Mkxqa3hOQzAyTGpreE5DMHhMalU1TnkweExqVTVOMW9pSUdacGJHdzlJaU13TURBaUx6NDhMMmMrUEdSbFpuTStQR05zYVhCUVlYUm9JR2xrUFNKaElqNDhjR0YwYUNCbWFXeHNQU0lqWm1abUlpQmtQU0pOTUNBd2FERTJkakUyU0RCNklpOCtQQzlqYkdsd1VHRjBhRDQ4TDJSbFpuTStQQzl6ZG1jKyl9LmFnLWNoYXJ0cy1pY29uLWRlbGV0ZS1sZWdhY3l7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTVRZaUlHaGxhV2RvZEQwaU1UWWlJR1pwYkd3OUltNXZibVVpSUhodGJHNXpQU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh5TURBd0wzTjJaeUkrUEhCaGRHZ2dabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJqYkdsd0xYSjFiR1U5SW1WMlpXNXZaR1FpSUdROUlrMDJMakE0TXlBeUxqWTJOMk13TFM0d09TNHdOVE10TGpJME1pNHhPVGN0TGpNNE55NHhORFV0TGpFME5DNHlPVGN0TGpFNU55NHpPRGN0TGpFNU4yZ3lMalkyTjJNdU1EZzVJREFnTGpJME1TNHdOVE11TXpnMkxqRTVOeTR4TkRVdU1UUTFMakU1Tnk0eU9UY3VNVGszTGpNNE4zWXVOVGd6U0RZdU1EZzBkaTB1TlRneldrMDFMak16SURRdU56VklNVEV1T1RFM2RqZ3VOVGd6WXpBZ0xqQTVMUzR3TlRJdU1qUXlMUzR4T1RjdU16ZzNMUzR4TkRVdU1UUTBMUzR5T1RjdU1UazNMUzR6T0RZdU1UazNTRFF1TmpZM1l5MHVNRGtnTUMwdU1qUXlMUzR3TlRNdExqTTROeTB1TVRrM0xTNHhORFF0TGpFME5TMHVNVGszTFM0eU9UY3RMakU1TnkwdU16ZzNWalF1TnpWSU5TNHpNMXB0TFM0M05EVXRNUzQxZGkwdU5UZ3pZekF0TGpVM09DNHlPQzB4TGpBNU1pNDJNell0TVM0ME5EY3VNelUxTFM0ek5UWXVPRGN0TGpZek55QXhMalEwTnkwdU5qTTNhREl1TmpZM1l5NDFOemNnTUNBeExqQTVNUzR5T0RFZ01TNDBORGN1TmpNM0xqTTFOUzR6TlRVdU5qTTJMamczTGpZek5pQXhMalEwTjNZdU5UZ3pTREUwWVM0M05TNDNOU0F3SURBZ01TQXdJREV1TldndExqVTRNM1k0TGpVNE0yTXdJQzQxTnpndExqSTRNU0F4TGpBNU1pMHVOak0ySURFdU5EUTNMUzR6TlRZdU16VTJMUzQ0Tnk0Mk16Y3RNUzQwTkRjdU5qTTNTRFF1TmpZM1l5MHVOVGMzSURBdE1TNHdPVEl0TGpJNE1TMHhMalEwTnkwdU5qTTNMUzR6TlRVdExqTTFOUzB1TmpNM0xTNDROeTB1TmpNM0xURXVORFEzVmpRdU56VklNbUV1TnpVdU56VWdNQ0F3SURFZ01DMHhMalZvTWk0MU9ETmFiVEl1TURneklETXVNek16WVM0M05TNDNOU0F3SURBZ01TQXVOelV1TnpWMk5HRXVOelV1TnpVZ01DQXhJREV0TVM0MUlEQjJMVFJoTGpjMUxqYzFJREFnTUNBeElDNDNOUzB1TnpWYWJUTXVOREUzTGpjMVlTNDNOUzQzTlNBd0lEQWdNQzB4TGpVZ01IWTBZUzQzTlM0M05TQXdJREVnTUNBeExqVWdNSFl0TkZvaUlHWnBiR3c5SWlNd01EQWlMejQ4TDNOMlp6ND0pfS5hZy1jaGFydHMtaWNvbi1sb2NrLWxlZ2FjeXstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNVFlpSUdobGFXZG9kRDBpTVRZaUlHWnBiR3c5SW01dmJtVWlJSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SStQSEJoZEdnZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmpiR2x3TFhKMWJHVTlJbVYyWlc1dlpHUWlJR1E5SWswMkxqRTNNeUF5TGpnMFlUSXVOVGd6SURJdU5UZ3pJREFnTUNBeElEUXVOREVnTVM0NE1qZDJNUzQ1TVRaSU5TNDBNVFpXTkM0Mk5qZGpNQzB1TmpnMUxqSTNNeTB4TGpNME15NDNOVGN0TVM0NE1qZGFUVE11T1RFM0lEWXVOVGd6VmpRdU5qWTNZVFF1TURneklEUXVNRGd6SURBZ01DQXhJRGd1TVRZMklEQjJNUzQ1TVRab0xqVTROR014TGpFMUlEQWdNaTR3T0RNdU9UTXpJREl1TURneklESXVNRGcwZGpRdU5qWTJZekFnTVM0eE5TMHVPVE16SURJdU1EZzBMVEl1TURneklESXVNRGcwU0RNdU16TXpZVEl1TURneklESXVNRGd6SURBZ01DQXhMVEl1TURnekxUSXVNRGcwVmpndU5qWTNZekF0TVM0eE5URXVPVE16TFRJdU1EZzBJREl1TURnekxUSXVNRGcwYUM0MU9ETmFiVGN1TkRFMklERXVOV2d0T0dFdU5UZ3pMalU0TXlBd0lEQWdNQzB1TlRnekxqVTROSFkwTGpZMk5tTXdJQzR6TWpJdU1qWXhMalU0TkM0MU9ETXVOVGcwYURrdU16TTBZUzQxT0RNdU5UZ3pJREFnTUNBd0lDNDFPRE10TGpVNE5GWTRMalkyTjJFdU5UZ3pMalU0TXlBd0lEQWdNQzB1TlRnekxTNDFPRFJvTFRFdU16TTBXaUlnWm1sc2JEMGlJekF3TUNJdlBqd3ZjM1puUGc9PSl9LmFnLWNoYXJ0cy1pY29uLXVubG9jay1sZWdhY3l7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTVRjaUlHaGxhV2RvZEQwaU1UWWlJR1pwYkd3OUltNXZibVVpSUhodGJHNXpQU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh5TURBd0wzTjJaeUkrUEhCaGRHZ2dabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJqYkdsd0xYSjFiR1U5SW1WMlpXNXZaR1FpSUdROUlrMDJMamt5TXlBeUxqZzBZVEl1TlRneklESXVOVGd6SURBZ01DQXhJRE11TmpVeklEQWdNeUF6SURBZ01DQXhJQzQxTnk0M09UaGpMakV6TkM0eU56Z3VNVGN1TkRjMExqRTNMalUwTldFdU56VXVOelVnTUNBd0lEQWdNUzQxSURCak1DMHVNemd4TFM0eE16SXRMamd3T1MwdU16SXRNUzR4T1RoaE5DNDFNREVnTkM0MU1ERWdNQ0F3SURBdExqZzFPUzB4TGpJd05pQTBMakE0TXlBMExqQTRNeUF3SURBZ01DMDJMamszSURJdU9EZzRkakV1T1RFMmFDMHVOVGcwUXpJdU9UTXpJRFl1TlRneklESWdOeTQxTVRZZ01pQTRMalkyTjNZMExqWTJObU13SURFdU1UVXVPVE16SURJdU1EZzBJREl1TURneklESXVNRGcwYURrdU16TTBZekV1TVRVZ01DQXlMakE0TXkwdU9UTXpJREl1TURnekxUSXVNRGcwVmpndU5qWTNZekF0TVM0eE5URXRMamt6TXkweUxqQTROQzB5TGpBNE15MHlMakE0TkdndE55NHlOVlkwTGpZMk4yTXdMUzQyT0RVdU1qY3lMVEV1TXpRekxqYzFOaTB4TGpneU4xcE5OUzQwTVRjZ09DNHdPRE5JTkM0d09ESmhMalU0TXk0MU9ETWdNQ0F3SURBdExqVTRNeTQxT0RSMk5DNDJOalpqTUNBdU16SXlMakkyTVM0MU9EUXVOVGd6TGpVNE5HZzVMak16TkdFdU5UZ3pMalU0TXlBd0lEQWdNQ0F1TlRnekxTNDFPRFJXT0M0Mk5qZGhMalU0TXk0MU9ETWdNQ0F3SURBdExqVTRNeTB1TlRnMGFDMDRXaUlnWm1sc2JEMGlJekF3TUNJdlBqd3ZjM1puUGc9PSl9LmFnLWNoYXJ0cy1pY29uLXBsdXMtbGVnYWN5ey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU5DSWdhR1ZwWjJoMFBTSXlOQ0lnZG1sbGQwSnZlRDBpTUNBd0lESTBJREkwSWlCbWFXeHNQU0p1YjI1bElpQnpkSEp2YTJVOUltTjFjbkpsYm5SRGIyeHZjaUlnYzNSeWIydGxMWGRwWkhSb1BTSXlJaUJ6ZEhKdmEyVXRiR2x1WldOaGNEMGljbTkxYm1RaUlITjBjbTlyWlMxc2FXNWxhbTlwYmowaWNtOTFibVFpSUdOc1lYTnpQU0pzZFdOcFpHVWdiSFZqYVdSbExYQnNkWE1pUGp4d1lYUm9JR1E5SWswMUlERXlhREUwSWk4K1BIQmhkR2dnWkQwaVRURXlJRFYyTVRRaUx6NDhMM04yWno0PSl9LmFnLWNoYXJ0cy1pY29uLWNyb3NzbGluZS1hZGQtbGluZS1sZWdhY3l7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l4TmlJZ2FHVnBaMmgwUFNJeE5pSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6QXdNQ0lnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSk5PQzQzTlNBMExqVmhMamMxTGpjMUlEQWdNQ0F3TFRFdU5TQXdkakl1TnpWSU5DNDFZUzQzTlM0M05TQXdJREFnTUNBd0lERXVOV2d5TGpjMWRqSXVOelZoTGpjMUxqYzFJREFnTUNBd0lERXVOU0F3VmpndU56Vm9NaTQzTldFdU56VXVOelVnTUNBd0lEQWdNQzB4TGpWSU9DNDNOWG9pSUdOc2FYQXRjblZzWlQwaVpYWmxibTlrWkNJdlBqd3ZjM1puUGc9PSl9LmFnLWNoYXJ0cy1pbnB1dHstLWlucHV0LWxheWVyLWFjdGl2ZTogMTstLWlucHV0LWxheWVyLWZvY3VzOiAyO2NvbG9yOmluaGVyaXQ7Zm9udC1mYW1pbHk6dmFyKC0tYWctY2hhcnRzLWlucHV0LWZvbnQtZmFtaWx5KTtmb250LXNpemU6dmFyKC0tYWctY2hhcnRzLWlucHV0LWZvbnQtc2l6ZSk7dHJhbnNpdGlvbi1kdXJhdGlvbjp2YXIoLS1hZy1jaGFydHMtaW5wdXQtdHJhbnNpdGlvbi1kdXJhdGlvbik7dHJhbnNpdGlvbi1wcm9wZXJ0eTpub25lO3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOnZhcigtLWFnLWNoYXJ0cy1pbnB1dC10cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbil9LmFnLWNoYXJ0cy1pbnB1dDpmb2N1cy12aXNpYmxle291dGxpbmU6dmFyKC0tYWctY2hhcnRzLWlucHV0LWZvY3VzLW91dGxpbmUpO2JveC1zaGFkb3c6dmFyKC0tYWctY2hhcnRzLWlucHV0LWZvY3VzLWJveC1zaGFkb3cpO3otaW5kZXg6dmFyKC0taW5wdXQtbGF5ZXItZm9jdXMpfS5hZy1jaGFydHMtYnV0dG9ue2JhY2tncm91bmQ6dmFyKC0tYWctY2hhcnRzLWlucHV0LWJhY2tncm91bmQtY29sb3IpO2JvcmRlcjoxcHggc29saWQgdmFyKC0tYWctY2hhcnRzLWlucHV0LWJvcmRlci1jb2xvcik7Ym9yZGVyLXJhZGl1czp2YXIoLS1hZy1jaGFydHMtaW5wdXQtYm9yZGVyLXJhZGl1cyk7Y3Vyc29yOnBvaW50ZXI7cGFkZGluZzp2YXIoLS1hZy1jaGFydHMtaW5wdXQtcGFkZGluZyk7dHJhbnNpdGlvbi1wcm9wZXJ0eTpiYWNrZ3JvdW5kLGJvcmRlci1jb2xvcn0uYWctY2hhcnRzLWJ1dHRvbjpob3ZlcntiYWNrZ3JvdW5kOnZhcigtLWFnLWNoYXJ0cy1pbnB1dC1iYWNrZ3JvdW5kLWNvbG9yLS1ob3Zlcil9LmFnLWNoYXJ0cy1idXR0b246aGFzKC5hZy1jaGFydHMtaWNvbil7cGFkZGluZzoycHh9LmFnLWNoYXJ0cy1jaGVja2JveHthcHBlYXJhbmNlOm5vbmU7YmFja2dyb3VuZDp2YXIoLS1hZy1jaGFydHMtaW5wdXQtY2hlY2tib3gtYmFja2dyb3VuZC1jb2xvcik7Ym9yZGVyLXJhZGl1czo5cHg7Y3Vyc29yOnBvaW50ZXI7aGVpZ2h0OjE4cHg7bWFyZ2luOjA7dHJhbnNpdGlvbi1kdXJhdGlvbjp2YXIoLS1hZy1jaGFydHMtaW5wdXQtdHJhbnNpdGlvbi1kdXJhdGlvbi0tZmFzdCk7dHJhbnNpdGlvbi1wcm9wZXJ0eTptYXJnaW47d2lkdGg6MjlweH0uYWctY2hhcnRzLWNoZWNrYm94OmJlZm9yZXtkaXNwbGF5OmJsb2NrO2JhY2tncm91bmQ6dmFyKC0tYWctY2hhcnRzLWlucHV0LWJhY2tncm91bmQtY29sb3IpO2JvcmRlci1yYWRpdXM6N3B4O2NvbnRlbnQ6XCIgXCI7aGVpZ2h0OjE0cHg7bWFyZ2luOjJweDt0cmFuc2l0aW9uLWR1cmF0aW9uOnZhcigtLWFnLWNoYXJ0cy1pbnB1dC10cmFuc2l0aW9uLWR1cmF0aW9uLS1mYXN0KTt0cmFuc2l0aW9uLXByb3BlcnR5Om1hcmdpbjt0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjp2YXIoLS1hZy1jaGFydHMtaW5wdXQtdHJhbnNpdGlvbi1lYXNpbmcpO3dpZHRoOjE0cHh9LmFnLWNoYXJ0cy1jaGVja2JveDpjaGVja2Vke2JhY2tncm91bmQ6dmFyKC0tYWctY2hhcnRzLWlucHV0LWNoZWNrYm94LWJhY2tncm91bmQtY29sb3ItLWNoZWNrZWQpfS5hZy1jaGFydHMtY2hlY2tib3g6Y2hlY2tlZDpiZWZvcmV7bWFyZ2luLWxlZnQ6MTNweH0uYWctY2hhcnRzLXNlbGVjdHtiYWNrZ3JvdW5kOnZhcigtLWFnLWNoYXJ0cy1pbnB1dC1iYWNrZ3JvdW5kLWNvbG9yKTtib3JkZXI6MXB4IHNvbGlkIHZhcigtLWFnLWNoYXJ0cy1pbnB1dC1ib3JkZXItY29sb3IpO2JvcmRlci1yYWRpdXM6dmFyKC0tYWctY2hhcnRzLWlucHV0LWJvcmRlci1yYWRpdXMpO3BhZGRpbmc6M3B4IDJweCA0cHg7Zm9udC1zaXplOmluaGVyaXR9LmFnLWNoYXJ0cy10ZXh0YXJlYXstLWxpbmUtaGVpZ2h0OiAxLjM4O2JhY2tncm91bmQ6dmFyKC0tYWctY2hhcnRzLWlucHV0LWJhY2tncm91bmQtY29sb3IpO2JvcmRlcjoxcHggc29saWQgdmFyKC0tYWctY2hhcnRzLWlucHV0LWJvcmRlci1jb2xvcik7Ym9yZGVyLXJhZGl1czp2YXIoLS1hZy1jaGFydHMtaW5wdXQtYm9yZGVyLXJhZGl1cyk7bGluZS1oZWlnaHQ6dmFyKC0tbGluZS1oZWlnaHQpO2ZvbnQtZmFtaWx5OnZhcigtLWFnLWNoYXJ0cy1pbnB1dC1mb250LWZhbWlseSk7Zm9udC1zaXplOnZhcigtLWFnLWNoYXJ0cy1pbnB1dC1mb250LXNpemUpO3BhZGRpbmc6dmFyKC0tYWctY2hhcnRzLWlucHV0LXBhZGRpbmctbGFyZ2UpIHZhcigtLWFnLWNoYXJ0cy1pbnB1dC1wYWRkaW5nKX0uYWctY2hhcnRzLXRleHRhcmVhW3BsYWNlaG9sZGVyXTplbXB0eTpiZWZvcmV7Y29sb3I6dmFyKC0tYWctY2hhcnRzLWlucHV0LXBsYWNlaG9sZGVyKTtjb250ZW50OmF0dHIocGxhY2Vob2xkZXIpfS5hZy1jaGFydHMtcHJveHktY29udGFpbmVye3BvaW50ZXItZXZlbnRzOm5vbmU7cG9zaXRpb246YWJzb2x1dGV9LmFnLWNoYXJ0cy1wcm94eS1lbGVtey13ZWJraXQtYXBwZWFyYW5jZTpub25lO2FwcGVhcmFuY2U6bm9uZTtiYWNrZ3JvdW5kOm5vbmU7Ym9yZGVyOm5vbmU7Y29sb3I6IzAwMDA7b3ZlcmZsb3c6aGlkZGVuO3BvaW50ZXItZXZlbnRzOm5vbmU7cG9zaXRpb246YWJzb2x1dGV9LmFnLWNoYXJ0cy1wcm94eS1lbGVtOjotbW96LXJhbmdlLXRodW1iLC5hZy1jaGFydHMtcHJveHktZWxlbTo6LW1vei1yYW5nZS10cmFja3tvcGFjaXR5OjB9LmFnLWNoYXJ0cy1wcm94eS1lbGVtOjotd2Via2l0LXNsaWRlci1ydW5uYWJsZS10cmFjaywuYWctY2hhcnRzLXByb3h5LWVsZW06Oi13ZWJraXQtc2xpZGVyLXRodW1ie29wYWNpdHk6MH0uYWctY2hhcnRzLXByb3h5LWVsZW06Zm9jdXMtdmlzaWJsZXtvdXRsaW5lOnZhcigtLWFnLWNoYXJ0cy1mb2N1cy1ib3JkZXIpO2JveC1zaGFkb3c6dmFyKC0tYWctY2hhcnRzLWZvY3VzLWJvcmRlci1zaGFkb3cpfS5hZy1jaGFydHMtZm9jdXMtaW5kaWNhdG9ye3Bvc2l0aW9uOmFic29sdXRlO2Rpc3BsYXk6YmxvY2s7cG9pbnRlci1ldmVudHM6bm9uZTt1c2VyLXNlbGVjdDpub25lO3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCV9LmFnLWNoYXJ0cy1mb2N1cy1pbmRpY2F0b3I+ZGl2e3Bvc2l0aW9uOmFic29sdXRlO291dGxpbmU6dmFyKC0tYWctY2hhcnRzLWZvY3VzLWJvcmRlcik7b3V0bGluZS13aWR0aDoycHg7Ym94LXNoYWRvdzp2YXIoLS1hZy1jaGFydHMtZm9jdXMtYm9yZGVyLXNoYWRvdyl9LmFnLWNoYXJ0cy1mb2N1cy1pbmRpY2F0b3I+c3Zne3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7ZmlsbDpub25lO3N0cm9rZTp2YXIoLS1hZy1jaGFydHMtZm9jdXMtYm9yZGVyLWNvbG9yKTtzdHJva2Utd2lkdGg6MnB4fS5hZy1jaGFydHMtdG9vbGJhcnthbGlnbi1pdGVtczpjZW50ZXI7YmFja2dyb3VuZDpub25lO2JvcmRlcjpub25lO2Rpc3BsYXk6ZmxleDtmbGV4LXdyYXA6bm93cmFwO29wYWNpdHk6MTtwb3NpdGlvbjphYnNvbHV0ZTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgwKTt0cmFuc2l0aW9uOm9wYWNpdHkgLjJzIGVhc2UtaW4tb3V0LHRyYW5zZm9ybSAuMnMgZWFzZS1pbi1vdXR9LmFnLWNoYXJ0cy10b29sYmFyLS1oaWRkZW4sLmFnLWNoYXJ0cy10b29sYmFyLS1wcmV2ZW50LWZsYXNoe3Zpc2liaWxpdHk6aGlkZGVufS5hZy1jaGFydHMtdG9vbGJhci0tZmxvYXRpbmctaGlkZGVue29wYWNpdHk6MDt0cmFuc2l0aW9uOm9wYWNpdHkgLjRzIGVhc2UtaW4tb3V0fS5hZy1jaGFydHMtdG9vbGJhci0tc21hbGx7LS1hZy1jaGFydHMtdG9vbGJhci1zaXplOiB2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1zaXplLXNtYWxsKTstLWFnLWNoYXJ0cy10b29sYmFyLWZvbnQtc2l6ZTogdmFyKC0tYWctY2hhcnRzLXRvb2xiYXItZm9udC1zaXplLXNtYWxsKTstLWFnLWNoYXJ0cy10b29sYmFyLWJ1dHRvbi1wYWRkaW5nOiB2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1idXR0b24tcGFkZGluZy1zbWFsbCl9LmFnLWNoYXJ0cy10b29sYmFyLS10b3AsLmFnLWNoYXJ0cy10b29sYmFyLS1ib3R0b217ZmxleC1kaXJlY3Rpb246cm93O3dpZHRoOjEwMCV9LmFnLWNoYXJ0cy10b29sYmFyLS1sZWZ0LC5hZy1jaGFydHMtdG9vbGJhci0tcmlnaHR7ZmxleC1kaXJlY3Rpb246Y29sdW1ufS5hZy1jaGFydHMtdG9vbGJhci0tZmxvYXRpbmcsLmFnLWNoYXJ0cy10b29sYmFyLS1mbG9hdGluZy10b3AsLmFnLWNoYXJ0cy10b29sYmFyLS1mbG9hdGluZy1ib3R0b217YmFja2dyb3VuZDpub25lO2JvcmRlcjpub25lO2ZsZXgtZGlyZWN0aW9uOnJvdztwb2ludGVyLWV2ZW50czpub25lO3dpZHRoOjEwMCV9LmFnLWNoYXJ0cy10b29sYmFyLS1mbG9hdGluZ3twYWRkaW5nOjA7d2lkdGg6YXV0bzt6LWluZGV4OnZhcigtLWFnLWNoYXJ0cy1sYXllci10b29sYmFyKX0uYWctY2hhcnRzLXRvb2xiYXItLWZsb2F0aW5nLXRvcHtoZWlnaHQ6Y2FsYyh2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1zaXplKSArIDEwcHgpO3BhZGRpbmctdG9wOjEwcHh9LmFnLWNoYXJ0cy10b29sYmFyLS1mbG9hdGluZy1ib3R0b217aGVpZ2h0OmNhbGModmFyKC0tYWctY2hhcnRzLXRvb2xiYXItc2l6ZSkgKyAxMHB4KTtwYWRkaW5nLWJvdHRvbToxMHB4O292ZXJmbG93OmhpZGRlbn0uYWctY2hhcnRzLXRvb2xiYXJfX2FsaWdue2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjppbmhlcml0O2ZsZXgtd3JhcDppbmhlcml0O2dhcDp2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1nYXApO21heC13aWR0aDoxMDAlO3dpZHRoOjEwMCV9LmFnLWNoYXJ0cy10b29sYmFyX19hbGlnbi0tc3RhcnR7anVzdGlmeS1jb250ZW50OnN0YXJ0fS5hZy1jaGFydHMtdG9vbGJhcl9fYWxpZ24tLWNlbnRlcntqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyfS5hZy1jaGFydHMtdG9vbGJhcl9fYWxpZ24tLWVuZHtqdXN0aWZ5LWNvbnRlbnQ6ZW5kfS5hZy1jaGFydHMtdG9vbGJhcl9fYWxpZ24tLWNlbnRlciwuYWctY2hhcnRzLXRvb2xiYXJfX2FsaWduLS1lbmR7bWFyZ2luLWxlZnQ6YXV0b30uYWctY2hhcnRzLXRvb2xiYXItLWxlZnQgLmFnLWNoYXJ0cy10b29sYmFyX19hbGlnbi0tY2VudGVyLC5hZy1jaGFydHMtdG9vbGJhci0tbGVmdCAuYWctY2hhcnRzLXRvb2xiYXJfX2FsaWduLS1lbmQsLmFnLWNoYXJ0cy10b29sYmFyLS1yaWdodCAuYWctY2hhcnRzLXRvb2xiYXJfX2FsaWduLS1jZW50ZXIsLmFnLWNoYXJ0cy10b29sYmFyLS1yaWdodCAuYWctY2hhcnRzLXRvb2xiYXJfX2FsaWduLS1lbmR7bWFyZ2luLWxlZnQ6MDttYXJnaW4tdG9wOmF1dG99LmFnLWNoYXJ0cy10b29sYmFyLS1mbG9hdGluZy10b3AgLmFnLWNoYXJ0cy10b29sYmFyX19hbGlnbiwuYWctY2hhcnRzLXRvb2xiYXItLWZsb2F0aW5nLWJvdHRvbSAuYWctY2hhcnRzLXRvb2xiYXJfX2FsaWdue3RyYW5zaXRpb246dHJhbnNmb3JtIC40cyBlYXNlLWluLW91dDt3aWR0aDphdXRvfS5hZy1jaGFydHMtdG9vbGJhcl9fc2VjdGlvbntkaXNwbGF5OmluaGVyaXQ7ZmxleC1kaXJlY3Rpb246aW5oZXJpdDtmbGV4LXdyYXA6aW5oZXJpdDtqdXN0aWZ5LWNvbnRlbnQ6aW5oZXJpdDttYXgtd2lkdGg6aW5oZXJpdDt3aWR0aDppbmhlcml0fS5hZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9ue2FsaWduLWl0ZW1zOmNlbnRlcjtiYWNrZ3JvdW5kOnZhcigtLWFnLWNoYXJ0cy10b29sYmFyLWJhY2tncm91bmQtY29sb3IpO2JvcmRlcjp2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1ib3JkZXIpO2NvbG9yOnZhcigtLWFnLWNoYXJ0cy10b29sYmFyLWZvcmVncm91bmQtY29sb3IpO2Rpc3BsYXk6ZmxleDtmb250OnZhcigtLWFnLWNoYXJ0cy10b29sYmFyLWZvbnQtc2l6ZSkgdmFyKC0tYWctY2hhcnRzLWZvbnQtZmFtaWx5KTtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO21hcmdpbjowIDAgMCAtMXB4O21pbi1oZWlnaHQ6dmFyKC0tYWctY2hhcnRzLXRvb2xiYXItc2l6ZSk7bWluLXdpZHRoOnZhcigtLWFnLWNoYXJ0cy10b29sYmFyLXNpemUpO3BhZGRpbmc6dmFyKC0tYWctY2hhcnRzLXRvb2xiYXItYnV0dG9uLXBhZGRpbmcpO3BvaW50ZXItZXZlbnRzOmFsbDtwb3NpdGlvbjpyZWxhdGl2ZTt3aGl0ZS1zcGFjZTpub3dyYXA7LS1zdHJva2Utd2lkdGgtY29sb3I6IHZhcigtLWFnLWNoYXJ0cy10b29sYmFyLWZvcmVncm91bmQtY29sb3IpfS5hZy1jaGFydHMtdG9vbGJhcl9fbm8tcG9pbnRlci1ldmVudHN7cG9pbnRlci1ldmVudHM6bm9uZX0uYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvbi0tZHJhZy1oYW5kbGV7bWluLXdpZHRoOjI0cHg7cGFkZGluZy1sZWZ0OjA7cGFkZGluZy1yaWdodDowfS5hZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uLS13aXRoLXRyYW5zaXRpb257dHJhbnNpdGlvbjpiYWNrZ3JvdW5kLWNvbG9yIC4yNXMgZWFzZS1pbi1vdXQsYm9yZGVyLWNvbG9yIC4yNXMgZWFzZS1pbi1vdXQsY29sb3IgLjI1cyBlYXNlLWluLW91dH0uYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvbltkYXRhLXRvb2xiYXItZ3JvdXA9cmFuZ2VzXXtwYWRkaW5nOnZhcigtLWFnLWNoYXJ0cy10b29sYmFyLWJ1dHRvbi1wYWRkaW5nKSBjYWxjKHZhcigtLWFnLWNoYXJ0cy10b29sYmFyLWJ1dHRvbi1wYWRkaW5nKSAqIDEuNSl9LmFnLWNoYXJ0cy10b29sYmFyLS10b3AsLmFnLWNoYXJ0cy10b29sYmFyLS1ib3R0b20sLmFnLWNoYXJ0cy10b29sYmFyLS1mbG9hdGluZywuYWctY2hhcnRzLXRvb2xiYXItLWZsb2F0aW5nLXRvcCwuYWctY2hhcnRzLXRvb2xiYXItLWZsb2F0aW5nLWJvdHRvbXsuYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvbi0tZmlyc3R7Ym9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czp2YXIoLS1hZy1jaGFydHMtYnV0dG9uLXJhZGl1cyk7Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1czp2YXIoLS1hZy1jaGFydHMtYnV0dG9uLXJhZGl1cyk7bWFyZ2luOjB9LmFnLWNoYXJ0cy10b29sYmFyX19idXR0b24tLWxhc3R7Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6dmFyKC0tYWctY2hhcnRzLWJ1dHRvbi1yYWRpdXMpO2JvcmRlci10b3AtcmlnaHQtcmFkaXVzOnZhcigtLWFnLWNoYXJ0cy1idXR0b24tcmFkaXVzKX19LmFnLWNoYXJ0cy10b29sYmFyLS1sZWZ0LC5hZy1jaGFydHMtdG9vbGJhci0tcmlnaHR7LmFnLWNoYXJ0cy10b29sYmFyX19idXR0b257Ym9yZGVyLXJhZGl1czowO21hcmdpbjotMXB4IDAgMDttYXgtd2lkdGg6MTAwJX0uYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvbi0tZmlyc3R7Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1czp2YXIoLS1hZy1jaGFydHMtYnV0dG9uLXJhZGl1cyk7Ym9yZGVyLXRvcC1yaWdodC1yYWRpdXM6dmFyKC0tYWctY2hhcnRzLWJ1dHRvbi1yYWRpdXMpO21hcmdpbjowfS5hZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uLS1sYXN0e2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6dmFyKC0tYWctY2hhcnRzLWJ1dHRvbi1yYWRpdXMpO2JvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOnZhcigtLWFnLWNoYXJ0cy1idXR0b24tcmFkaXVzKX19LmFnLWNoYXJ0cy10b29sYmFyX19idXR0b24tLWhpZGRlbi12YWx1ZSwuYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvbi0taGlkZGVuLXRvZ2dsZWR7ZGlzcGxheTpub25lfS5hZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uOmhvdmVyOm5vdChbYXJpYS1kaXNhYmxlZD10cnVlXSwuYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvbi0tZHJhZy1oYW5kbGUpe2JhY2tncm91bmQ6dmFyKC0tYWctY2hhcnRzLXRvb2xiYXItaG92ZXItY29sb3IpO3otaW5kZXg6MX0uYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvbjpmb2N1cy12aXNpYmxle291dGxpbmU6dmFyKC0tYWctY2hhcnRzLWZvY3VzLWJvcmRlcik7Ym94LXNoYWRvdzp2YXIoLS1hZy1jaGFydHMtZm9jdXMtYm9yZGVyLXNoYWRvdyk7ei1pbmRleDpjYWxjKHZhcigtLWFnLWNoYXJ0cy1sYXllci11aS1vdmVybGF5KSArIDEpfS5hZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uLmFnLWNoYXJ0cy10b29sYmFyX19idXR0b24tLWFjdGl2ZXtiYWNrZ3JvdW5kOnZhcigtLWFnLWNoYXJ0cy10b29sYmFyLWFjdGl2ZS1iYWNrZ3JvdW5kLWNvbG9yKTtib3JkZXItY29sb3I6dmFyKC0tYWctY2hhcnRzLXRvb2xiYXItYWN0aXZlLWNvbG9yKTtjb2xvcjp2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1hY3RpdmUtY29sb3IpO3otaW5kZXg6MjstLXN0cm9rZS13aWR0aC1jb2xvcjogdmFyKC0tYWctY2hhcnRzLXRvb2xiYXItYWN0aXZlLWNvbG9yKX0uYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvblthcmlhLWRpc2FibGVkPXRydWVde2JhY2tncm91bmQ6dmFyKC0tYWctY2hhcnRzLXRvb2xiYXItZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcik7Y29sb3I6dmFyKC0tYWctY2hhcnRzLXRvb2xiYXItZGlzYWJsZWQtZm9yZWdyb3VuZC1jb2xvcil9LmFnLWNoYXJ0cy10b29sYmFyX19idXR0b246bm90KFthcmlhLWRpc2FibGVkPXRydWVdKXtjdXJzb3I6cG9pbnRlcn0uYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvbi5hZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uLS1kcmFnLWhhbmRsZXtjdXJzb3I6Z3JhYn0uYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvbi5hZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uLS1kcmFnZ2luZ3tjdXJzb3I6Z3JhYmJpbmd9LmFnLWNoYXJ0cy10b29sYmFyX19idXR0b24tLWZpbGwtdmlzaWJsZTphZnRlcntjb250ZW50OlwiXCI7ZGlzcGxheTpibG9jaztwb3NpdGlvbjphYnNvbHV0ZTtib3R0b206M3B4O2xlZnQ6NXB4O3JpZ2h0OjVweDtoZWlnaHQ6NHB4O2JvcmRlci1yYWRpdXM6OTlweDtib3gtc2hhZG93Omluc2V0IDAgMCAwIDFweCBjb2xvci1taXgoaW4gc3JnYix2YXIoLS1hZy1jaGFydHMtZm9yZWdyb3VuZC1jb2xvcikgMTAlLHRyYW5zcGFyZW50KTtiYWNrZ3JvdW5kOnZhcigtLWZpbGwpfS5hZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uLS1maWxsLXZpc2libGVbYXJpYS1kaXNhYmxlZD10cnVlXTphZnRlcntmaWx0ZXI6Z3JheXNjYWxlKDEpO29wYWNpdHk6LjV9LmFnLWNoYXJ0cy10b29sYmFyX19idXR0b24tLXN0cm9rZS13aWR0aC12aXNpYmxlOmJlZm9yZXtjb250ZW50OlwiXCI7aGVpZ2h0Om1pbih2YXIoLS1zdHJva2VXaWR0aCksMjBweCk7d2lkdGg6MTJweDtiYWNrZ3JvdW5kOnZhcigtLXN0cm9rZS13aWR0aC1jb2xvcik7bWFyZ2luLXJpZ2h0OnZhcigtLWFnLWNoYXJ0cy10b29sYmFyLWJ1dHRvbi1wYWRkaW5nKX0uYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvbi0tc3Ryb2tlLXdpZHRoLXZpc2libGVbYXJpYS1kaXNhYmxlZD10cnVlXTpiZWZvcmV7ZmlsdGVyOmdyYXlzY2FsZSgxKTtvcGFjaXR5Oi41fS5hZy1jaGFydHMtdG9vbGJhcl9faWNvbisuYWctY2hhcnRzLXRvb2xiYXJfX2xhYmVse21hcmdpbi1sZWZ0OnZhcigtLWFnLWNoYXJ0cy10b29sYmFyLWdhcCl9LmFnLWNoYXJ0cy10b29sYmFyX19pY29uLC5hZy1jaGFydHMtdG9vbGJhcl9fbGFiZWx7cG9pbnRlci1ldmVudHM6bm9uZX0uYWctY2hhcnQtb3ZlcmxheXtjb2xvcjojMTgxZDFmO3BvaW50ZXItZXZlbnRzOm5vbmV9LmFnLWNoYXJ0LW92ZXJsYXkuYWctY2hhcnQtZGFyay1vdmVybGF5e2NvbG9yOiNmZmZ9LmFnLWNoYXJ0LW92ZXJsYXktLWxvYWRpbmd7Y29sb3I6IzhjOGM4Y30uYWctY2hhcnQtb3ZlcmxheV9fbG9hZGluZy1iYWNrZ3JvdW5ke2JhY2tncm91bmQ6I2ZmZjtwb2ludGVyLWV2ZW50czpub25lfS5hZy1jaGFydC1vdmVybGF5LmFnLWNoYXJ0LWRhcmstb3ZlcmxheSAuYWctY2hhcnQtb3ZlcmxheV9fbG9hZGluZy1iYWNrZ3JvdW5ke2JhY2tncm91bmQ6IzE5MjIzMn0uYWctY2hhcnQtdG9vbHRpcHt0cmFuc2l0aW9uOnRyYW5zZm9ybSAuMXMgZWFzZTt3aWR0aDptYXgtY29udGVudDt6LWluZGV4Ojk5OTk5O2ZvbnQ6MTJweCBWZXJkYW5hLHNhbnMtc2VyaWY7Y29sb3I6IzQ2NDY0Njtib3gtc2hhZG93OjAgNHB4IDhweCAjMDAwMDAwMTR9LmFnLWNoYXJ0LXRvb2x0aXAtd3JhcC1hbHdheXN7b3ZlcmZsb3ctd3JhcDpicmVhay13b3JkO3dvcmQtYnJlYWs6YnJlYWstd29yZDtoeXBoZW5zOm5vbmV9LmFnLWNoYXJ0LXRvb2x0aXAtd3JhcC1oeXBoZW5hdGV7b3ZlcmZsb3ctd3JhcDpicmVhay13b3JkO3dvcmQtYnJlYWs6YnJlYWstd29yZDtoeXBoZW5zOmF1dG99LmFnLWNoYXJ0LXRvb2x0aXAtd3JhcC1vbi1zcGFjZXtvdmVyZmxvdy13cmFwOm5vcm1hbDt3b3JkLWJyZWFrOm5vcm1hbH0uYWctY2hhcnQtdG9vbHRpcC13cmFwLW5ldmVye3doaXRlLXNwYWNlOnByZTt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzfS5hZy1jaGFydC10b29sdGlwLW5vLWludGVyYWN0aW9ue3BvaW50ZXItZXZlbnRzOm5vbmU7dXNlci1zZWxlY3Q6bm9uZX0uYWctY2hhcnQtdG9vbHRpcC1uby1hbmltYXRpb257dHJhbnNpdGlvbjpub25lIWltcG9ydGFudH0uYWctY2hhcnQtdG9vbHRpcC1oaWRkZW57dmlzaWJpbGl0eTpoaWRkZW59LmFnLWNoYXJ0LXRvb2x0aXAtdGl0bGV7b3ZlcmZsb3c6aGlkZGVuO3Bvc2l0aW9uOnJlbGF0aXZlO3BhZGRpbmc6OHB4IDE0cHg7Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1czoycHg7Ym9yZGVyLXRvcC1yaWdodC1yYWRpdXM6MnB4O2NvbG9yOiNmZmY7YmFja2dyb3VuZC1jb2xvcjojODg4O3otaW5kZXg6MTt0ZXh0LW92ZXJmbG93OmluaGVyaXR9LmFnLWNoYXJ0LXRvb2x0aXAtdGl0bGU6b25seS1jaGlsZHtib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOjJweDtib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czoycHh9LmFnLWNoYXJ0LXRvb2x0aXAtY29udGVudHtvdmVyZmxvdzpoaWRkZW47cGFkZGluZzo2cHggMTRweDtsaW5lLWhlaWdodDoxLjdlbTtiYWNrZ3JvdW5kOiNmZmY7Ym9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czoycHg7Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6MnB4O2JvcmRlcjoxcHggc29saWQgcmdiYSgwLDAsMCwuMTUpO3RleHQtb3ZlcmZsb3c6aW5oZXJpdH0uYWctY2hhcnQtdG9vbHRpcC1hcnJvdzpiZWZvcmV7Y29udGVudDpcIlwiO3Bvc2l0aW9uOmFic29sdXRlO3RvcDoxMDAlO2xlZnQ6NTAlO3RyYW5zZm9ybTp0cmFuc2xhdGUoLTUwJSk7Ym9yZGVyOjVweCBzb2xpZCAjZDlkOWQ5O2JvcmRlci1sZWZ0LWNvbG9yOnRyYW5zcGFyZW50O2JvcmRlci1yaWdodC1jb2xvcjp0cmFuc3BhcmVudDtib3JkZXItYm90dG9tLWNvbG9yOnRyYW5zcGFyZW50O3dpZHRoOjA7aGVpZ2h0OjA7bWFyZ2luOjAgYXV0b30uYWctY2hhcnQtdG9vbHRpcC1hcnJvdzphZnRlcntjb250ZW50OlwiXCI7cG9zaXRpb246YWJzb2x1dGU7dG9wOmNhbGMoMTAwJSAtIDFweCk7bGVmdDo1MCU7dHJhbnNmb3JtOnRyYW5zbGF0ZSgtNTAlKTtib3JkZXI6NXB4IHNvbGlkIHdoaXRlO2JvcmRlci1sZWZ0LWNvbG9yOnRyYW5zcGFyZW50O2JvcmRlci1yaWdodC1jb2xvcjp0cmFuc3BhcmVudDtib3JkZXItYm90dG9tLWNvbG9yOnRyYW5zcGFyZW50O3dpZHRoOjA7aGVpZ2h0OjA7bWFyZ2luOjAgYXV0b31cXG4nO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2tleW5hdlV0aWwudHNcbmZ1bmN0aW9uIGFkZFJlbW92YWJsZUV2ZW50TGlzdGVuZXIoZGVzdHJveUZucywgZWxlbSwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgZWxlbS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKTtcbiAgY29uc3QgcmVtb3ZlciA9ICgpID0+IGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcik7XG4gIGRlc3Ryb3lGbnMucHVzaChyZW1vdmVyKTtcbiAgcmV0dXJuIHJlbW92ZXI7XG59XG5mdW5jdGlvbiBhZGRFc2NhcGVFdmVudExpc3RlbmVyKGRlc3Ryb3lGbnMsIGVsZW0sIG9uRXNjYXBlKSB7XG4gIGFkZFJlbW92YWJsZUV2ZW50TGlzdGVuZXIoZGVzdHJveUZucywgZWxlbSwgXCJrZXlkb3duXCIsIChldmVudCkgPT4ge1xuICAgIGlmIChldmVudC5rZXkgPT09IFwiRXNjYXBlXCIpIHtcbiAgICAgIG9uRXNjYXBlKGV2ZW50KTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gYWRkTW91c2VDbG9zZUxpc3RlbmVyKGRlc3Ryb3lGbnMsIG1lbnUsIGhpZGVDYWxsYmFjaykge1xuICBjb25zdCBzZWxmID0gYWRkUmVtb3ZhYmxlRXZlbnRMaXN0ZW5lcihkZXN0cm95Rm5zLCB3aW5kb3csIFwibW91c2Vkb3duXCIsIChldmVudCkgPT4ge1xuICAgIGlmIChbMCwgMl0uaW5jbHVkZXMoZXZlbnQuYnV0dG9uKSAmJiAhY29udGFpbnNQb2ludChtZW51LCBldmVudCkpIHtcbiAgICAgIGhpZGVDYWxsYmFjaygpO1xuICAgICAgc2VsZigpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBzZWxmO1xufVxuZnVuY3Rpb24gY29udGFpbnNQb2ludChjb250YWluZXIsIGV2ZW50KSB7XG4gIGlmIChldmVudC50YXJnZXQgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgY29uc3QgeyB4LCB5LCB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIgfSA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCB7IGNsaWVudFg6IGV4LCBjbGllbnRZOiBleSB9ID0gZXZlbnQ7XG4gICAgcmV0dXJuIGV4ID49IHggJiYgZXkgPj0geSAmJiBleCA8PSB4ICsgd2lkdGgyICYmIGV5IDw9IHkgKyBoZWlnaHQyO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGhhc05vTW9kaWZpZXJzKGV2ZW50KSB7XG4gIHJldHVybiAhKGV2ZW50LnNoaWZ0S2V5IHx8IGV2ZW50LmFsdEtleSB8fCBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkpO1xufVxuZnVuY3Rpb24gbWF0Y2hlc0tleShldmVudCwga2V5LCAuLi5tb3Jla2V5cykge1xuICByZXR1cm4gaGFzTm9Nb2RpZmllcnMoZXZlbnQpICYmIChldmVudC5rZXkgPT09IGtleSB8fCBtb3Jla2V5cy5zb21lKChhbHRrZXkpID0+IGV2ZW50LmtleSA9PT0gYWx0a2V5KSk7XG59XG5mdW5jdGlvbiBsaW5rVHdvQnV0dG9ucyhkZXN0cm95Rm5zLCBzcmMsIGRzdCwga2V5KSB7XG4gIGlmICghZHN0KVxuICAgIHJldHVybjtcbiAgYWRkUmVtb3ZhYmxlRXZlbnRMaXN0ZW5lcihkZXN0cm95Rm5zLCBzcmMsIFwia2V5ZG93blwiLCAoZXZlbnQpID0+IHtcbiAgICBpZiAobWF0Y2hlc0tleShldmVudCwga2V5KSkge1xuICAgICAgZHN0LmZvY3VzKCk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGxpbmtUaHJlZUJ1dHRvbnMoZGVzdHJveUZucywgY3VyciwgbmV4dCwgbmV4dEtleSwgcHJldiwgcHJldktleSkge1xuICBsaW5rVHdvQnV0dG9ucyhkZXN0cm95Rm5zLCBjdXJyLCBwcmV2LCBwcmV2S2V5KTtcbiAgbGlua1R3b0J1dHRvbnMoZGVzdHJveUZucywgY3VyciwgbmV4dCwgbmV4dEtleSk7XG4gIGFkZFJlbW92YWJsZUV2ZW50TGlzdGVuZXIoZGVzdHJveUZucywgY3VyciwgXCJrZXlkb3duXCIsIChldmVudCkgPT4ge1xuICAgIGlmIChtYXRjaGVzS2V5KGV2ZW50LCBuZXh0S2V5LCBwcmV2S2V5KSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0pO1xufVxudmFyIFBSRVZfTkVYVF9LRVlTID0ge1xuICBob3Jpem9udGFsOiB7IG5leHRLZXk6IFwiQXJyb3dSaWdodFwiLCBwcmV2S2V5OiBcIkFycm93TGVmdFwiIH0sXG4gIHZlcnRpY2FsOiB7IG5leHRLZXk6IFwiQXJyb3dEb3duXCIsIHByZXZLZXk6IFwiQXJyb3dVcFwiIH1cbn07XG5mdW5jdGlvbiBpbml0VG9vbGJhcktleU5hdihvcHRzKSB7XG4gIG9wdHMudG9vbGJhci5yb2xlID0gXCJ0b29sYmFyXCI7XG4gIG9wdHMudG9vbGJhci5hcmlhT3JpZW50YXRpb24gPSBvcHRzLm9yaWVudGF0aW9uO1xuICBvcHRzLnRvb2xiYXIuYXJpYUhpZGRlbiA9IChvcHRzLmJ1dHRvbnMubGVuZ3RoID09PSAwKS50b1N0cmluZygpO1xuICByZXR1cm4gaW5pdFJvdmluZ1RhYkluZGV4KG9wdHMpO1xufVxuZnVuY3Rpb24gaW5pdFJvdmluZ1RhYkluZGV4KG9wdHMpIHtcbiAgY29uc3QgeyBvcmllbnRhdGlvbiwgYnV0dG9ucywgd3JhcEFyb3VuZCA9IGZhbHNlLCBvbkVzY2FwZSwgb25Gb2N1cywgb25CbHVyIH0gPSBvcHRzO1xuICBjb25zdCB7IG5leHRLZXksIHByZXZLZXkgfSA9IFBSRVZfTkVYVF9LRVlTW29yaWVudGF0aW9uXTtcbiAgY29uc3Qgc2V0VGFiSW5kaWNlcyA9IChldmVudCkgPT4ge1xuICAgIGlmIChldmVudC50YXJnZXQgJiYgXCJ0YWJJbmRleFwiIGluIGV2ZW50LnRhcmdldCkge1xuICAgICAgYnV0dG9ucy5mb3JFYWNoKChiKSA9PiBiLnRhYkluZGV4ID0gLTEpO1xuICAgICAgZXZlbnQudGFyZ2V0LnRhYkluZGV4ID0gMDtcbiAgICB9XG4gIH07XG4gIGNvbnN0IFtjLCBtXSA9IHdyYXBBcm91bmQgPyBbYnV0dG9ucy5sZW5ndGgsIGJ1dHRvbnMubGVuZ3RoXSA6IFswLCBJbmZpbml0eV07XG4gIGNvbnN0IGRlc3Ryb3lGbnMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBidXR0b25zLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcHJldiA9IGJ1dHRvbnNbKGMgKyBpIC0gMSkgJSBtXTtcbiAgICBjb25zdCBjdXJyID0gYnV0dG9uc1tpXTtcbiAgICBjb25zdCBuZXh0ID0gYnV0dG9uc1soYyArIGkgKyAxKSAlIG1dO1xuICAgIGFkZFJlbW92YWJsZUV2ZW50TGlzdGVuZXIoZGVzdHJveUZucywgY3VyciwgXCJmb2N1c1wiLCBzZXRUYWJJbmRpY2VzKTtcbiAgICBpZiAob25Gb2N1cylcbiAgICAgIGFkZFJlbW92YWJsZUV2ZW50TGlzdGVuZXIoZGVzdHJveUZucywgY3VyciwgXCJmb2N1c1wiLCBvbkZvY3VzKTtcbiAgICBpZiAob25CbHVyKVxuICAgICAgYWRkUmVtb3ZhYmxlRXZlbnRMaXN0ZW5lcihkZXN0cm95Rm5zLCBjdXJyLCBcImJsdXJcIiwgb25CbHVyKTtcbiAgICBpZiAob25Fc2NhcGUpXG4gICAgICBhZGRFc2NhcGVFdmVudExpc3RlbmVyKGRlc3Ryb3lGbnMsIGN1cnIsIG9uRXNjYXBlKTtcbiAgICBsaW5rVGhyZWVCdXR0b25zKGRlc3Ryb3lGbnMsIGN1cnIsIHByZXYsIHByZXZLZXksIG5leHQsIG5leHRLZXkpO1xuICAgIGN1cnIudGFiSW5kZXggPSBpID09PSAwID8gMCA6IC0xO1xuICB9XG4gIHJldHVybiBkZXN0cm95Rm5zO1xufVxudmFyIE1lbnVDbG9zZXJJbXAgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG1lbnUsIGxhc3RGb2N1cywgY2xvc2VDYWxsYmFjaykge1xuICAgIHRoaXMubGFzdEZvY3VzID0gbGFzdEZvY3VzO1xuICAgIHRoaXMuY2xvc2VDYWxsYmFjayA9IGNsb3NlQ2FsbGJhY2s7XG4gICAgdGhpcy5kZXN0cm95Rm5zID0gW107XG4gICAgdGhpcy5kZXN0cm95Rm5zLnB1c2goYWRkTW91c2VDbG9zZUxpc3RlbmVyKHRoaXMuZGVzdHJveUZucywgbWVudSwgKCkgPT4gdGhpcy5jbG9zZSgpKSk7XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5kZXN0cm95Rm5zLmZvckVhY2goKGQpID0+IGQoKSk7XG4gICAgdGhpcy5kZXN0cm95Rm5zLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5jbG9zZUNhbGxiYWNrKCk7XG4gICAgdGhpcy5maW5pc2hDbG9zaW5nKCk7XG4gIH1cbiAgZmluaXNoQ2xvc2luZygpIHtcbiAgICB0aGlzLmRlc3Ryb3lGbnMuZm9yRWFjaCgoZCkgPT4gZCgpKTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMubGVuZ3RoID0gMDtcbiAgICBzZXRBdHRyaWJ1dGUodGhpcy5sYXN0Rm9jdXMsIFwiYXJpYS1leHBhbmRlZFwiLCBmYWxzZSk7XG4gICAgdGhpcy5sYXN0Rm9jdXM/LmZvY3VzKCk7XG4gICAgdGhpcy5sYXN0Rm9jdXMgPSB2b2lkIDA7XG4gIH1cbn07XG5mdW5jdGlvbiBpbml0TWVudUtleU5hdihvcHRzKSB7XG4gIGNvbnN0IHsgc291cmNlRXZlbnQsIG9yaWVudGF0aW9uLCBtZW51LCBidXR0b25zLCBjbG9zZUNhbGxiYWNrLCBhdXRvQ2xvc2VPbkJsdXIgPSBmYWxzZSB9ID0gb3B0cztcbiAgY29uc3QgeyBuZXh0S2V5LCBwcmV2S2V5IH0gPSBQUkVWX05FWFRfS0VZU1tvcmllbnRhdGlvbl07XG4gIGNvbnN0IGxhc3RGb2N1cyA9IGdldExhc3RGb2N1cyhzb3VyY2VFdmVudCk7XG4gIHNldEF0dHJpYnV0ZShsYXN0Rm9jdXMsIFwiYXJpYS1leHBhbmRlZFwiLCB0cnVlKTtcbiAgY29uc3QgbWVudUNsb3NlciA9IG5ldyBNZW51Q2xvc2VySW1wKG1lbnUsIGxhc3RGb2N1cywgY2xvc2VDYWxsYmFjayk7XG4gIGNvbnN0IG9uRXNjYXBlID0gKCkgPT4gbWVudUNsb3Nlci5jbG9zZSgpO1xuICBjb25zdCB7IGRlc3Ryb3lGbnMgfSA9IG1lbnVDbG9zZXI7XG4gIG1lbnUucm9sZSA9IFwibWVudVwiO1xuICBtZW51LmFyaWFPcmllbnRhdGlvbiA9IG9yaWVudGF0aW9uO1xuICBkZXN0cm95Rm5zLnB1c2goLi4uaW5pdFJvdmluZ1RhYkluZGV4KHsgb3JpZW50YXRpb24sIGJ1dHRvbnMsIG9uRXNjYXBlLCB3cmFwQXJvdW5kOiB0cnVlIH0pKTtcbiAgbWVudS50YWJJbmRleCA9IC0xO1xuICBhZGRFc2NhcGVFdmVudExpc3RlbmVyKGRlc3Ryb3lGbnMsIG1lbnUsIG9uRXNjYXBlKTtcbiAgYWRkUmVtb3ZhYmxlRXZlbnRMaXN0ZW5lcihkZXN0cm95Rm5zLCBtZW51LCBcImtleWRvd25cIiwgKGV2KSA9PiB7XG4gICAgaWYgKGV2LnRhcmdldCA9PT0gbWVudSAmJiAoZXYua2V5ID09PSBuZXh0S2V5IHx8IGV2LmtleSA9PT0gcHJldktleSkpIHtcbiAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBidXR0b25zWzBdPy5mb2N1cygpO1xuICAgIH1cbiAgfSk7XG4gIGlmIChhdXRvQ2xvc2VPbkJsdXIpIHtcbiAgICBjb25zdCBoYW5kbGVyID0gKGV2KSA9PiB7XG4gICAgICBjb25zdCBidXR0b25BcnJheSA9IGJ1dHRvbnM7XG4gICAgICBjb25zdCBpc0xlYXZpbmdNZW51ID0gIWJ1dHRvbkFycmF5LmluY2x1ZGVzKGV2LnJlbGF0ZWRUYXJnZXQpO1xuICAgICAgaWYgKGlzTGVhdmluZ01lbnUpIHtcbiAgICAgICAgb25Fc2NhcGUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGZvciAoY29uc3QgYnV0dG9uIG9mIGJ1dHRvbnMpIHtcbiAgICAgIGFkZFJlbW92YWJsZUV2ZW50TGlzdGVuZXIoZGVzdHJveUZucywgYnV0dG9uLCBcImJsdXJcIiwgaGFuZGxlcik7XG4gICAgfVxuICB9XG4gIGJ1dHRvbnNbMF0/LmZvY3VzKCk7XG4gIHJldHVybiBtZW51Q2xvc2VyO1xufVxuZnVuY3Rpb24gbWFrZUFjY2Vzc2libGVDbGlja0xpc3RlbmVyKGVsZW1lbnQyLCBvbmNsaWNrKSB7XG4gIHJldHVybiAoZXZlbnQpID0+IHtcbiAgICBpZiAoZWxlbWVudDIuYXJpYURpc2FibGVkID09PSBcInRydWVcIikge1xuICAgICAgcmV0dXJuIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIG9uY2xpY2soZXZlbnQpO1xuICB9O1xufVxuZnVuY3Rpb24gaXNCdXR0b25DbGlja0V2ZW50KGV2ZW50KSB7XG4gIGlmIChcImJ1dHRvblwiIGluIGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LmJ1dHRvbiA9PT0gMDtcbiAgfVxuICByZXR1cm4gaGFzTm9Nb2RpZmllcnMoZXZlbnQpICYmIChldmVudC5jb2RlID09PSBcIlNwYWNlXCIgfHwgZXZlbnQua2V5ID09PSBcIkVudGVyXCIpO1xufVxuZnVuY3Rpb24gZ2V0TGFzdEZvY3VzKHNvdXJjZUV2ZW50KSB7XG4gIGlmIChzb3VyY2VFdmVudD8udGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgXCJ0YWJpbmRleFwiIGluIHNvdXJjZUV2ZW50LnRhcmdldC5hdHRyaWJ1dGVzKSB7XG4gICAgcmV0dXJuIHNvdXJjZUV2ZW50LnRhcmdldDtcbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxuZnVuY3Rpb24gc3RvcFBhZ2VTY3JvbGxpbmcoZWxlbWVudDIpIHtcbiAgY29uc3QgaGFuZGxlciA9IChldmVudCkgPT4ge1xuICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHNob3VsZFByZXZlbnQgPSBnZXRBdHRyaWJ1dGUoZXZlbnQudGFyZ2V0LCBcImRhdGEtcHJldmVudGRlZmF1bHRcIiwgdHJ1ZSk7XG4gICAgaWYgKHNob3VsZFByZXZlbnQgJiYgbWF0Y2hlc0tleShldmVudCwgXCJBcnJvd1JpZ2h0XCIsIFwiQXJyb3dMZWZ0XCIsIFwiQXJyb3dEb3duXCIsIFwiQXJyb3dVcFwiKSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH07XG4gIGVsZW1lbnQyLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGhhbmRsZXIpO1xuICByZXR1cm4gKCkgPT4gZWxlbWVudDIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgaGFuZGxlcik7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvc2l6ZU1vbml0b3IudHNcbnZhciBTaXplTW9uaXRvciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5lbGVtZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5kb2N1bWVudFJlYWR5ID0gZmFsc2U7XG4gICAgdGhpcy5xdWV1ZWRPYnNlcnZlUmVxdWVzdHMgPSBbXTtcbiAgICB0aGlzLm9uTG9hZCA9ICgpID0+IHtcbiAgICAgIHRoaXMuZG9jdW1lbnRSZWFkeSA9IHRydWU7XG4gICAgICB0aGlzLnF1ZXVlZE9ic2VydmVSZXF1ZXN0cy5mb3JFYWNoKChbZWwsIGNiXSkgPT4gdGhpcy5vYnNlcnZlKGVsLCBjYikpO1xuICAgICAgdGhpcy5xdWV1ZWRPYnNlcnZlUmVxdWVzdHMgPSBbXTtcbiAgICB9O1xuICAgIGlmICh0eXBlb2YgUmVzaXplT2JzZXJ2ZXIgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5yZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoZW50cmllcykgPT4ge1xuICAgICAgZm9yIChjb25zdCB7XG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgY29udGVudFJlY3Q6IHsgd2lkdGg6IHdpZHRoMiwgaGVpZ2h0OiBoZWlnaHQyIH1cbiAgICAgIH0gb2YgZW50cmllcykge1xuICAgICAgICBjb25zdCBlbnRyeSA9IHRoaXMuZWxlbWVudHMuZ2V0KHRhcmdldCk7XG4gICAgICAgIHRoaXMuY2hlY2tTaXplKGVudHJ5LCB0YXJnZXQsIHdpZHRoMiwgaGVpZ2h0Mik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5kb2N1bWVudFJlYWR5ID0gZ2V0RG9jdW1lbnQoXCJyZWFkeVN0YXRlXCIpID09PSBcImNvbXBsZXRlXCI7XG4gICAgaWYgKCF0aGlzLmRvY3VtZW50UmVhZHkpIHtcbiAgICAgIGdldFdpbmRvdygpPy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCB0aGlzLm9uTG9hZCk7XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgZ2V0V2luZG93KCk/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIHRoaXMub25Mb2FkKTtcbiAgICB0aGlzLnJlc2l6ZU9ic2VydmVyPy5kaXNjb25uZWN0KCk7XG4gICAgdGhpcy5yZXNpemVPYnNlcnZlciA9IG51bGw7XG4gIH1cbiAgY2hlY2tTaXplKGVudHJ5LCBlbGVtZW50Miwgd2lkdGgyLCBoZWlnaHQyKSB7XG4gICAgaWYgKCFlbnRyeSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAod2lkdGgyICE9PSBlbnRyeS5zaXplPy53aWR0aCB8fCBoZWlnaHQyICE9PSBlbnRyeS5zaXplPy5oZWlnaHQpIHtcbiAgICAgIGVudHJ5LnNpemUgPSB7IHdpZHRoOiB3aWR0aDIsIGhlaWdodDogaGVpZ2h0MiB9O1xuICAgICAgZW50cnkuY2IoZW50cnkuc2l6ZSwgZWxlbWVudDIpO1xuICAgIH1cbiAgfVxuICAvLyBPbmx5IGEgc2luZ2xlIGNhbGxiYWNrIGlzIHN1cHBvcnRlZC5cbiAgb2JzZXJ2ZShlbGVtZW50MiwgY2IpIHtcbiAgICBpZiAoIXRoaXMuZG9jdW1lbnRSZWFkeSkge1xuICAgICAgdGhpcy5xdWV1ZWRPYnNlcnZlUmVxdWVzdHMucHVzaChbZWxlbWVudDIsIGNiXSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmVsZW1lbnRzLmhhcyhlbGVtZW50MikpIHtcbiAgICAgIHRoaXMucmVtb3ZlRnJvbVF1ZXVlKGVsZW1lbnQyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZXNpemVPYnNlcnZlcj8ub2JzZXJ2ZShlbGVtZW50Mik7XG4gICAgfVxuICAgIGNvbnN0IGVudHJ5ID0geyBjYiB9O1xuICAgIHRoaXMuZWxlbWVudHMuc2V0KGVsZW1lbnQyLCBlbnRyeSk7XG4gIH1cbiAgdW5vYnNlcnZlKGVsZW1lbnQyKSB7XG4gICAgdGhpcy5yZXNpemVPYnNlcnZlcj8udW5vYnNlcnZlKGVsZW1lbnQyKTtcbiAgICB0aGlzLmVsZW1lbnRzLmRlbGV0ZShlbGVtZW50Mik7XG4gICAgdGhpcy5yZW1vdmVGcm9tUXVldWUoZWxlbWVudDIpO1xuICAgIGlmICghdGhpcy5lbGVtZW50cy5zaXplKSB7XG4gICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlRnJvbVF1ZXVlKGVsZW1lbnQyKSB7XG4gICAgdGhpcy5xdWV1ZWRPYnNlcnZlUmVxdWVzdHMgPSB0aGlzLnF1ZXVlZE9ic2VydmVSZXF1ZXN0cy5maWx0ZXIoKFtlbF0pID0+IGVsICE9PSBlbGVtZW50Mik7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2RvbS9kb21MYXlvdXQuaHRtbFxudmFyIGRvbUxheW91dF9kZWZhdWx0ID0gJzxkaXYgcm9sZT1cInByZXNlbnRhdGlvblwiIGNsYXNzPVwiYWctY2hhcnRzLXdyYXBwZXIgYWctY2hhcnRzLXN0eWxlc1wiIGRhdGEtYWctY2hhcnRzPjxkaXYgcm9sZT1cInByZXNlbnRhdGlvblwiIGNsYXNzPVwiYWctY2hhcnRzLWNhbnZhcy1jZW50ZXJcIj48ZGl2IHJvbGU9XCJwcmVzZW50YXRpb25cIiBjbGFzcz1cImFnLWNoYXJ0cy1jYW52YXMtY29udGFpbmVyXCI+PGRpdiByb2xlPVwicHJlc2VudGF0aW9uXCIgY2xhc3M9XCJhZy1jaGFydHMtY2FudmFzXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9kaXY+PGRpdiByb2xlPVwiZmlndXJlXCIgY2xhc3M9XCJhZy1jaGFydHMtY2FudmFzLXByb3h5XCI+PGRpdiByb2xlPVwiaW1nXCIgY2xhc3M9XCJhZy1jaGFydHMtc2VyaWVzLWFyZWFcIiB0YWJpbmRleD1cIi0xXCI+PC9kaXY+PC9kaXY+PGRpdiByb2xlPVwicHJlc2VudGF0aW9uXCIgY2xhc3M9XCJhZy1jaGFydHMtY2FudmFzLW92ZXJsYXlcIj48L2Rpdj48L2Rpdj48L2Rpdj48L2Rpdj4nO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9kb20vZG9tTWFuYWdlci50c1xudmFyIERPTV9FTEVNRU5UX0NMQVNTRVMgPSBbXG4gIFwic3R5bGVzXCIsXG4gIFwiY2FudmFzXCIsXG4gIFwiY2FudmFzLWNlbnRlclwiLFxuICBcImNhbnZhcy1vdmVybGF5XCIsXG4gIFwiY2FudmFzLXByb3h5XCIsXG4gIFwic2VyaWVzLWFyZWFcIlxuXTtcbnZhciBkb21FbGVtZW50Q29uZmlnID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICBbXCJzdHlsZXNcIiwgeyBjaGlsZEVsZW1lbnRUeXBlOiBcInN0eWxlXCIgfV0sXG4gIFtcImNhbnZhc1wiLCB7IGNoaWxkRWxlbWVudFR5cGU6IFwiY2FudmFzXCIgfV0sXG4gIFtcImNhbnZhcy1wcm94eVwiLCB7IGNoaWxkRWxlbWVudFR5cGU6IFwiZGl2XCIgfV0sXG4gIFtcImNhbnZhcy1vdmVybGF5XCIsIHsgY2hpbGRFbGVtZW50VHlwZTogXCJkaXZcIiB9XSxcbiAgW1wiY2FudmFzLWNlbnRlclwiLCB7IGNoaWxkRWxlbWVudFR5cGU6IFwiZGl2XCIgfV0sXG4gIFtcInNlcmllcy1hcmVhXCIsIHsgY2hpbGRFbGVtZW50VHlwZTogXCJkaXZcIiB9XVxuXSk7XG5mdW5jdGlvbiBzZXR1cE9ic2VydmVyKGVsZW1lbnQyLCBjYikge1xuICBpZiAodHlwZW9mIEludGVyc2VjdGlvbk9ic2VydmVyID09PSBcInVuZGVmaW5lZFwiKVxuICAgIHJldHVybjtcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoXG4gICAgKGVudHJpZXMpID0+IHtcbiAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgICBpZiAoZW50cnkudGFyZ2V0ID09PSBlbGVtZW50Mikge1xuICAgICAgICAgIGNiKGVudHJ5LmludGVyc2VjdGlvblJhdGlvKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgeyByb290OiBlbGVtZW50MiB9XG4gICk7XG4gIG9ic2VydmVyLm9ic2VydmUoZWxlbWVudDIpO1xuICByZXR1cm4gb2JzZXJ2ZXI7XG59XG52YXIgTlVMTF9ET01SRUNUID0ge1xuICB4OiAwLFxuICB5OiAwLFxuICB3aWR0aDogMCxcbiAgaGVpZ2h0OiAwLFxuICB0b3A6IDAsXG4gIGJvdHRvbTogMCxcbiAgbGVmdDogMCxcbiAgcmlnaHQ6IDAsXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gTlVMTF9ET01SRUNUO1xuICB9XG59O1xudmFyIERPTU1hbmFnZXIgPSBjbGFzcyBleHRlbmRzIEJhc2VNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoY29udGFpbmVyLCBzdHlsZUNvbnRhaW5lcikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zdHlsZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuY29udGFpbmVyID0gdm9pZCAwO1xuICAgIHRoaXMuY29udGFpbmVyU2l6ZSA9IHZvaWQgMDtcbiAgICB0aGlzLnNpemVNb25pdG9yID0gbmV3IFNpemVNb25pdG9yKCk7XG4gICAgY29uc3QgdGVtcGxhdGVFbCA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGVtcGxhdGVFbC5pbm5lckhUTUwgPSBkb21MYXlvdXRfZGVmYXVsdDtcbiAgICB0aGlzLmVsZW1lbnQgPSB0ZW1wbGF0ZUVsLmNoaWxkcmVuLml0ZW0oMCk7XG4gICAgdGhpcy5zdHlsZVJvb3RFbGVtZW50ID0gc3R5bGVDb250YWluZXI7XG4gICAgdGhpcy5yb290RWxlbWVudHMgPSBET01fRUxFTUVOVF9DTEFTU0VTLnJlZHVjZShcbiAgICAgIChyLCBjKSA9PiB7XG4gICAgICAgIGNvbnN0IGNzc0NsYXNzID0gYGFnLWNoYXJ0cy0ke2N9YDtcbiAgICAgICAgY29uc3QgZWwgPSB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKGNzc0NsYXNzKSA/IHRoaXMuZWxlbWVudCA6IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKGAuJHtjc3NDbGFzc31gKTtcbiAgICAgICAgaWYgKCFlbClcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFHIENoYXJ0cyAtIHVuYWJsZSB0byBmaW5kIERPTSBlbGVtZW50ICR7Y3NzQ2xhc3N9YCk7XG4gICAgICAgIHJbY10gPSB7IGVsZW1lbnQ6IGVsLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgbGlzdGVuZXJzOiBbXSB9O1xuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH0sXG4gICAgICB7fVxuICAgICk7XG4gICAgbGV0IGhpZGRlbiA9IGZhbHNlO1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBzZXR1cE9ic2VydmVyKHRoaXMuZWxlbWVudCwgKGludGVyc2VjdGlvblJhdGlvKSA9PiB7XG4gICAgICBpZiAoaW50ZXJzZWN0aW9uUmF0aW8gPT09IDAgJiYgIWhpZGRlbikge1xuICAgICAgICB0aGlzLmxpc3RlbmVycy5kaXNwYXRjaChcImhpZGRlblwiLCB7IHR5cGU6IFwiaGlkZGVuXCIgfSk7XG4gICAgICB9XG4gICAgICBoaWRkZW4gPSBpbnRlcnNlY3Rpb25SYXRpbyA9PT0gMDtcbiAgICB9KTtcbiAgICB0aGlzLnNldFNpemVPcHRpb25zKCk7XG4gICAgdGhpcy5hZGRTdHlsZXMoXCJhZy1jaGFydHMtY29tbXVuaXR5XCIsIHN0eWxlc19kZWZhdWx0KTtcbiAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICB0aGlzLnNldENvbnRhaW5lcihjb250YWluZXIpO1xuICAgIH1cbiAgICB0aGlzLmRlc3Ryb3lGbnMucHVzaChzdG9wUGFnZVNjcm9sbGluZyh0aGlzLmVsZW1lbnQpKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLm9ic2VydmVyPy51bm9ic2VydmUodGhpcy5lbGVtZW50KTtcbiAgICBpZiAodGhpcy5jb250YWluZXIpIHtcbiAgICAgIHRoaXMuc2l6ZU1vbml0b3IudW5vYnNlcnZlKHRoaXMuY29udGFpbmVyKTtcbiAgICB9XG4gICAgT2JqZWN0LnZhbHVlcyh0aGlzLnJvb3RFbGVtZW50cykuZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgIGVsLmNoaWxkcmVuLmZvckVhY2goKGMpID0+IGMucmVtb3ZlKCkpO1xuICAgICAgZWwuZWxlbWVudC5yZW1vdmUoKTtcbiAgICB9KTtcbiAgICB0aGlzLmVsZW1lbnQucmVtb3ZlKCk7XG4gIH1cbiAgc2V0U2l6ZU9wdGlvbnMobWluV2lkdGggPSAzMDAsIG1pbkhlaWdodCA9IDMwMCwgb3B0aW9uc1dpZHRoLCBvcHRpb25zSGVpZ2h0KSB7XG4gICAgY29uc3QgeyBzdHlsZSB9ID0gdGhpcy5lbGVtZW50O1xuICAgIHN0eWxlLndpZHRoID0gYCR7b3B0aW9uc1dpZHRoID8/IG1pbldpZHRofXB4YDtcbiAgICBzdHlsZS5oZWlnaHQgPSBgJHtvcHRpb25zSGVpZ2h0ID8/IG1pbkhlaWdodH1weGA7XG4gIH1cbiAgdXBkYXRlQ29udGFpbmVyU2l6ZSgpIHtcbiAgICBjb25zdCB7IHN0eWxlOiBjZW50ZXJTdHlsZSB9ID0gdGhpcy5yb290RWxlbWVudHNbXCJjYW52YXMtY2VudGVyXCJdLmVsZW1lbnQ7XG4gICAgY2VudGVyU3R5bGUud2lkdGggPSBgJHt0aGlzLmNvbnRhaW5lclNpemU/LndpZHRoID8/IDB9cHhgO1xuICAgIGNlbnRlclN0eWxlLmhlaWdodCA9IGAke3RoaXMuY29udGFpbmVyU2l6ZT8uaGVpZ2h0ID8/IDB9cHhgO1xuICB9XG4gIHNldENvbnRhaW5lcihuZXdDb250YWluZXIpIHtcbiAgICBpZiAobmV3Q29udGFpbmVyID09PSB0aGlzLmNvbnRhaW5lcilcbiAgICAgIHJldHVybjtcbiAgICBpZiAodGhpcy5jb250YWluZXIpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuZWxlbWVudCk7XG4gICAgICB0aGlzLnNpemVNb25pdG9yLnVub2JzZXJ2ZSh0aGlzLmNvbnRhaW5lcik7XG4gICAgfVxuICAgIGNvbnN0IGlzU2hhZG93RG9tID0gdGhpcy5nZXRTaGFkb3dEb2N1bWVudFJvb3QobmV3Q29udGFpbmVyKSAhPSBudWxsO1xuICAgIGlmICghaXNTaGFkb3dEb20pIHtcbiAgICAgIGZvciAoY29uc3QgaWQgb2YgdGhpcy5yb290RWxlbWVudHNbXCJzdHlsZXNcIl0uY2hpbGRyZW4ua2V5cygpKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQ2hpbGQoXCJzdHlsZXNcIiwgaWQpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lciA9IG5ld0NvbnRhaW5lcjtcbiAgICBmb3IgKGNvbnN0IFtpZCwgc3R5bGVzXSBvZiB0aGlzLnN0eWxlcykge1xuICAgICAgdGhpcy5hZGRTdHlsZXMoaWQsIHN0eWxlcyk7XG4gICAgfVxuICAgIG5ld0NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmVsZW1lbnQpO1xuICAgIHRoaXMuc2l6ZU1vbml0b3Iub2JzZXJ2ZShuZXdDb250YWluZXIsIChzaXplKSA9PiB7XG4gICAgICB0aGlzLmNvbnRhaW5lclNpemUgPSBzaXplO1xuICAgICAgdGhpcy51cGRhdGVDb250YWluZXJTaXplKCk7XG4gICAgICB0aGlzLmxpc3RlbmVycy5kaXNwYXRjaChcInJlc2l6ZVwiLCB7IHR5cGU6IFwicmVzaXplXCIgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5saXN0ZW5lcnMuZGlzcGF0Y2goXCJjb250YWluZXItY2hhbmdlZFwiLCB7IHR5cGU6IFwiY29udGFpbmVyLWNoYW5nZWRcIiB9KTtcbiAgfVxuICBzZXRUaGVtZUNsYXNzKHRoZW1lQ2xhc3NOYW1lKSB7XG4gICAgY29uc3QgdGhlbWVDbGFzc05hbWVQcmVmaXggPSBcImFnLWNoYXJ0cy10aGVtZS1cIjtcbiAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmZvckVhY2goKGNsYXNzTmFtZSkgPT4ge1xuICAgICAgaWYgKGNsYXNzTmFtZS5zdGFydHNXaXRoKHRoZW1lQ2xhc3NOYW1lUHJlZml4KSAmJiBjbGFzc05hbWUgIT09IHRoZW1lQ2xhc3NOYW1lKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQodGhlbWVDbGFzc05hbWUpO1xuICB9XG4gIHNldFRhYkluZGV4KHRhYkluZGV4KSB7XG4gICAgdGhpcy5yb290RWxlbWVudHNbXCJzZXJpZXMtYXJlYVwiXS5lbGVtZW50LnRhYkluZGV4ID0gdGFiSW5kZXg7XG4gIH1cbiAgdXBkYXRlQ2FudmFzTGFiZWwoYXJpYUxhYmVsKSB7XG4gICAgc2V0QXR0cmlidXRlKHRoaXMucm9vdEVsZW1lbnRzW1wiY2FudmFzLXByb3h5XCJdLmVsZW1lbnQsIFwiYXJpYS1sYWJlbFwiLCBhcmlhTGFiZWwpO1xuICB9XG4gIGdldEV2ZW50RWxlbWVudChkZWZhdWx0RWxlbSwgZXZlbnRUeXBlKSB7XG4gICAgY29uc3QgZXZlbnRzID0gW1wiZm9jdXNcIiwgXCJibHVyXCIsIFwia2V5ZG93blwiLCBcImtleXVwXCJdO1xuICAgIHJldHVybiBldmVudHMuaW5jbHVkZXMoZXZlbnRUeXBlKSA/IHRoaXMucm9vdEVsZW1lbnRzW1wic2VyaWVzLWFyZWFcIl0uZWxlbWVudCA6IGRlZmF1bHRFbGVtO1xuICB9XG4gIGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmdldEV2ZW50RWxlbWVudCh0aGlzLmVsZW1lbnQsIHR5cGUpLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpO1xuICB9XG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmdldEV2ZW50RWxlbWVudCh0aGlzLmVsZW1lbnQsIHR5cGUpLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpO1xuICB9XG4gIC8qKiBHZXQgdGhlIG1haW4gY2hhcnQgYXJlYSBjbGllbnQgYm91bmQgcmVjdC4gKi9cbiAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkge1xuICAgIHJldHVybiB0aGlzLnJvb3RFbGVtZW50c1tcImNhbnZhc1wiXS5lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGNsaWVudCBib3VuZGluZyByZWN0IGZvciBvdmVybGF5IGVsZW1lbnRzIHRoYXQgbWlnaHQgZmxvYXQgb3V0c2lkZSB0aGUgYm91bmRzIG9mIHRoZVxuICAgKiBtYWluIGNoYXJ0IGFyZWEuXG4gICAqL1xuICBnZXRPdmVybGF5Q2xpZW50UmVjdCgpIHtcbiAgICBjb25zdCB3aW5kb3cyID0gZ2V0V2luZG93KCk7XG4gICAgY29uc3Qgd2luZG93QkJveCA9IG5ldyBCQm94KDAsIDAsIHdpbmRvdzIuaW5uZXJXaWR0aCwgd2luZG93Mi5pbm5lckhlaWdodCk7XG4gICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5nZXRSYXdPdmVybGF5Q2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IGNvbnRhaW5lckJCb3ggPSBCQm94LmZyb21ET01SZWN0KGNvbnRhaW5lciA/PyB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcbiAgICByZXR1cm4gd2luZG93QkJveC5pbnRlcnNlY3Rpb24oY29udGFpbmVyQkJveCk/LnRvRE9NUmVjdCgpID8/IE5VTExfRE9NUkVDVDtcbiAgfVxuICBnZXRSYXdPdmVybGF5Q2xpZW50UmVjdCgpIHtcbiAgICBsZXQgZWxlbWVudDIgPSB0aGlzLmVsZW1lbnQ7XG4gICAgd2hpbGUgKGVsZW1lbnQyICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHN0eWxlTWFwID0gZWxlbWVudDIuY29tcHV0ZWRTdHlsZU1hcD8uKCk7XG4gICAgICBjb25zdCBvdmVyZmxvd1ggPSBzdHlsZU1hcD8uZ2V0KFwib3ZlcmZsb3cteFwiKT8udG9TdHJpbmcoKTtcbiAgICAgIGNvbnN0IG92ZXJmbG93WSA9IHN0eWxlTWFwPy5nZXQoXCJvdmVyZmxvdy15XCIpPy50b1N0cmluZygpO1xuICAgICAgaWYgKG92ZXJmbG93WCAhPSBudWxsICYmIG92ZXJmbG93WCAhPT0gXCJ2aXNpYmxlXCIgfHwgb3ZlcmZsb3dZICYmIG92ZXJmbG93WSAhPT0gXCJ2aXNpYmxlXCIpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgfVxuICAgICAgZWxlbWVudDIgPSBlbGVtZW50Mi5wYXJlbnRFbGVtZW50O1xuICAgIH1cbiAgICBjb25zdCBkb2NSb290ID0gdGhpcy5nZXRTaGFkb3dEb2N1bWVudFJvb3QoKTtcbiAgICBpZiAoZG9jUm9vdCkge1xuICAgICAgcmV0dXJuIGRvY1Jvb3QuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgfVxuICB9XG4gIGdldFNoYWRvd0RvY3VtZW50Um9vdChjdXJyZW50ID0gdGhpcy5jb250YWluZXIpIHtcbiAgICBjb25zdCBkb2NSb290ID0gY3VycmVudD8ub3duZXJEb2N1bWVudD8uYm9keSA/PyBnZXREb2N1bWVudChcImJvZHlcIik7XG4gICAgd2hpbGUgKGN1cnJlbnQgIT0gbnVsbCkge1xuICAgICAgaWYgKGN1cnJlbnQgPT09IGRvY1Jvb3QpIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50LnBhcmVudE5vZGUgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50KSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgfVxuICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG4gIGdldENoaWxkQm91bmRpbmdDbGllbnRSZWN0KHR5cGUpIHtcbiAgICBjb25zdCB7IGNoaWxkcmVuIH0gPSB0aGlzLnJvb3RFbGVtZW50c1t0eXBlXTtcbiAgICBjb25zdCBjaGlsZFJlY3RzID0gW107XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbi52YWx1ZXMoKSkge1xuICAgICAgY2hpbGRSZWN0cy5wdXNoKEJCb3guZnJvbURPTVJlY3QoY2hpbGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpKTtcbiAgICB9XG4gICAgcmV0dXJuIEJCb3gubWVyZ2UoY2hpbGRSZWN0cyk7XG4gIH1cbiAgY2FsY3VsYXRlQ2FudmFzUG9zaXRpb24oZWwpIHtcbiAgICBsZXQgeCA9IDA7XG4gICAgbGV0IHkgPSAwO1xuICAgIGNvbnN0IHsgeDogY3ggPSAwLCB5OiBjeSA9IDAgfSA9IHRoaXMuZ2V0Q2hpbGRCb3VuZGluZ0NsaWVudFJlY3QoXCJjYW52YXNcIikgPz8ge307XG4gICAgY29uc3QgZWxSZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgeCA9IGVsUmVjdC54IC0gY3g7XG4gICAgeSA9IGVsUmVjdC55IC0gY3k7XG4gICAgcmV0dXJuIHsgeCwgeSB9O1xuICB9XG4gIGlzTWFuYWdlZENoaWxkRE9NRWxlbWVudChlbCwgZG9tRWxlbWVudENsYXNzLCBpZCkge1xuICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IHRoaXMucm9vdEVsZW1lbnRzW2RvbUVsZW1lbnRDbGFzc107XG4gICAgY29uc3Qgc2VhcmNoID0gY2hpbGRyZW4/LmdldChpZCk7XG4gICAgcmV0dXJuIHNlYXJjaCAhPSBudWxsICYmIGVsLmNvbnRhaW5zKHNlYXJjaCk7XG4gIH1cbiAgaXNFdmVudE92ZXJFbGVtZW50KGV2ZW50KSB7XG4gICAgY29uc3QgZWxlbWVudDIgPSBldmVudC50YXJnZXQ7XG4gICAgcmV0dXJuIGVsZW1lbnQyICE9IG51bGwgJiYgdGhpcy5lbGVtZW50LmNvbnRhaW5zKGVsZW1lbnQyKTtcbiAgfVxuICBhZGRTdHlsZXMoaWQsIHN0eWxlcykge1xuICAgIGNvbnN0IGRhdGFBdHRyaWJ1dGUgPSBcImRhdGEtYWctY2hhcnRzXCI7XG4gICAgdGhpcy5zdHlsZXMuc2V0KGlkLCBzdHlsZXMpO1xuICAgIGlmICh0aGlzLmNvbnRhaW5lciA9PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGNoZWNrSWQgPSAoZWwpID0+IHtcbiAgICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoZGF0YUF0dHJpYnV0ZSkgPT09IGlkO1xuICAgIH07XG4gICAgY29uc3QgYWRkU3R5bGVFbGVtZW50ID0gKGVsKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGVsLmNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChjaGVja0lkKGNoaWxkKSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzdHlsZUVsID0gY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgICAgZWwuYXBwZW5kQ2hpbGQoc3R5bGVFbCk7XG4gICAgICByZXR1cm4gc3R5bGVFbDtcbiAgICB9O1xuICAgIGxldCBzdHlsZUVsZW1lbnQ7XG4gICAgaWYgKHRoaXMuc3R5bGVSb290RWxlbWVudCkge1xuICAgICAgc3R5bGVFbGVtZW50ID0gYWRkU3R5bGVFbGVtZW50KHRoaXMuc3R5bGVSb290RWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGRvY3VtZW50Um9vdCA9IHRoaXMuZ2V0U2hhZG93RG9jdW1lbnRSb290KHRoaXMuY29udGFpbmVyKTtcbiAgICAgIGlmIChkb2N1bWVudFJvb3QgIT0gbnVsbCkge1xuICAgICAgICBzdHlsZUVsZW1lbnQgPSB0aGlzLmFkZENoaWxkKFwic3R5bGVzXCIsIGlkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlRWxlbWVudCA9IGFkZFN0eWxlRWxlbWVudChnZXREb2N1bWVudChcImhlYWRcIikpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3R5bGVFbGVtZW50ID09IG51bGwgfHwgY2hlY2tJZChzdHlsZUVsZW1lbnQpKVxuICAgICAgcmV0dXJuO1xuICAgIHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoZGF0YUF0dHJpYnV0ZSwgaWQpO1xuICAgIHN0eWxlRWxlbWVudC5pbm5lckhUTUwgPSBzdHlsZXM7XG4gIH1cbiAgcmVtb3ZlU3R5bGVzKGlkKSB7XG4gICAgdGhpcy5yZW1vdmVDaGlsZChcInN0eWxlc1wiLCBpZCk7XG4gIH1cbiAgdXBkYXRlQ3Vyc29yKHN0eWxlKSB7XG4gICAgdGhpcy5lbGVtZW50LnN0eWxlLmN1cnNvciA9IHN0eWxlO1xuICB9XG4gIGdldEN1cnNvcigpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50LnN0eWxlLmN1cnNvcjtcbiAgfVxuICBhZGRDaGlsZChkb21FbGVtZW50Q2xhc3MsIGlkLCBjaGlsZCwgaW5zZXJ0KSB7XG4gICAgY29uc3QgeyBlbGVtZW50OiBlbGVtZW50MiwgY2hpbGRyZW4sIGxpc3RlbmVycyB9ID0gdGhpcy5yb290RWxlbWVudHNbZG9tRWxlbWVudENsYXNzXTtcbiAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBRyBDaGFydHMgLSB1bmFibGUgdG8gY3JlYXRlIERPTSBlbGVtZW50cyBhZnRlciBkZXN0cm95KClcIik7XG4gICAgfVxuICAgIGlmIChjaGlsZHJlbi5oYXMoaWQpKSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW4uZ2V0KGlkKTtcbiAgICB9XG4gICAgY29uc3QgeyBjaGlsZEVsZW1lbnRUeXBlID0gXCJkaXZcIiB9ID0gZG9tRWxlbWVudENvbmZpZy5nZXQoZG9tRWxlbWVudENsYXNzKSA/PyB7fTtcbiAgICBpZiAoY2hpbGQgJiYgY2hpbGQudGFnTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBjaGlsZEVsZW1lbnRUeXBlLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFHIENoYXJ0cyAtIG1pc21hdGNoaW5nIERPTSBlbGVtZW50IHR5cGVcIik7XG4gICAgfVxuICAgIGNvbnN0IG5ld0NoaWxkID0gY2hpbGQgPz8gY3JlYXRlRWxlbWVudChjaGlsZEVsZW1lbnRUeXBlKTtcbiAgICBmb3IgKGNvbnN0IFt0eXBlLCBmbiwgb3B0c10gb2YgbGlzdGVuZXJzKSB7XG4gICAgICBuZXdDaGlsZC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZuLCBvcHRzKTtcbiAgICB9XG4gICAgY2hpbGRyZW4uc2V0KGlkLCBuZXdDaGlsZCk7XG4gICAgaWYgKGluc2VydCkge1xuICAgICAgY29uc3QgcXVlcnlSZXN1bHQgPSBlbGVtZW50Mi5xdWVyeVNlbGVjdG9yKGluc2VydC5xdWVyeSk7XG4gICAgICBpZiAocXVlcnlSZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFHIENoYXJ0cyAtIGFkZENoaWxkIHF1ZXJ5IGZhaWxlZCAke2luc2VydC5xdWVyeX1gKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5UmVzdWx0Lmluc2VydEFkamFjZW50RWxlbWVudChpbnNlcnQud2hlcmUsIG5ld0NoaWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudDI/LmFwcGVuZENoaWxkKG5ld0NoaWxkKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0NoaWxkO1xuICB9XG4gIHJlbW92ZUNoaWxkKGRvbUVsZW1lbnRDbGFzcywgaWQpIHtcbiAgICBjb25zdCB7IGNoaWxkcmVuIH0gPSB0aGlzLnJvb3RFbGVtZW50c1tkb21FbGVtZW50Q2xhc3NdO1xuICAgIGlmICghY2hpbGRyZW4pXG4gICAgICByZXR1cm47XG4gICAgY2hpbGRyZW4uZ2V0KGlkKT8ucmVtb3ZlKCk7XG4gICAgY2hpbGRyZW4uZGVsZXRlKGlkKTtcbiAgfVxuICBpbmNyZW1lbnREYXRhQ291bnRlcihuYW1lKSB7XG4gICAgY29uc3QgeyBkYXRhc2V0IH0gPSB0aGlzLmVsZW1lbnQ7XG4gICAgZGF0YXNldFtuYW1lXSA/PyAoZGF0YXNldFtuYW1lXSA9IFwiMFwiKTtcbiAgICBkYXRhc2V0W25hbWVdID0gU3RyaW5nKE51bWJlcihkYXRhc2V0W25hbWVdKSArIDEpO1xuICB9XG4gIHNldERhdGFCb29sZWFuKG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy5lbGVtZW50LmRhdGFzZXRbbmFtZV0gPSBTdHJpbmcodmFsdWUpO1xuICB9XG4gIGdldEljb25DbGFzc05hbWVzKGljb24pIHtcbiAgICByZXR1cm4gYGFnLWNoYXJ0cy1pY29uIGFnLWNoYXJ0cy1pY29uLSR7aWNvbn1gO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9wb2x5Um9vdHMudHNcbmZ1bmN0aW9uIGxpbmVhclJvb3QoYSwgYikge1xuICBjb25zdCB0ID0gLWIgLyBhO1xuICByZXR1cm4gYSAhPT0gMCAmJiB0ID49IDAgJiYgdCA8PSAxID8gW3RdIDogW107XG59XG5mdW5jdGlvbiBxdWFkcmF0aWNSb290cyhhLCBiLCBjKSB7XG4gIGlmIChhID09PSAwKSB7XG4gICAgcmV0dXJuIGxpbmVhclJvb3QoYiwgYyk7XG4gIH1cbiAgY29uc3QgRCA9IGIgKiBiIC0gNCAqIGEgKiBjO1xuICBjb25zdCByb290cyA9IFtdO1xuICBpZiAoRCA9PT0gMCkge1xuICAgIGNvbnN0IHQgPSAtYiAvICgyICogYSk7XG4gICAgaWYgKHQgPj0gMCAmJiB0IDw9IDEpIHtcbiAgICAgIHJvb3RzLnB1c2godCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKEQgPiAwKSB7XG4gICAgY29uc3QgckQgPSBNYXRoLnNxcnQoRCk7XG4gICAgY29uc3QgdDEgPSAoLWIgLSByRCkgLyAoMiAqIGEpO1xuICAgIGNvbnN0IHQyID0gKC1iICsgckQpIC8gKDIgKiBhKTtcbiAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICByb290cy5wdXNoKHQxKTtcbiAgICB9XG4gICAgaWYgKHQyID49IDAgJiYgdDIgPD0gMSkge1xuICAgICAgcm9vdHMucHVzaCh0Mik7XG4gICAgfVxuICB9XG4gIHJldHVybiByb290cztcbn1cbmZ1bmN0aW9uIGN1YmljUm9vdHMoYSwgYiwgYywgZCkge1xuICBpZiAoYSA9PT0gMCkge1xuICAgIHJldHVybiBxdWFkcmF0aWNSb290cyhiLCBjLCBkKTtcbiAgfVxuICBjb25zdCBBID0gYiAvIGE7XG4gIGNvbnN0IEIgPSBjIC8gYTtcbiAgY29uc3QgQyA9IGQgLyBhO1xuICBjb25zdCBRID0gKDMgKiBCIC0gQSAqIEEpIC8gOTtcbiAgY29uc3QgUiA9ICg5ICogQSAqIEIgLSAyNyAqIEMgLSAyICogQSAqIEEgKiBBKSAvIDU0O1xuICBjb25zdCBEID0gUSAqIFEgKiBRICsgUiAqIFI7XG4gIGNvbnN0IHRoaXJkID0gMSAvIDM7XG4gIGNvbnN0IHJvb3RzID0gW107XG4gIGlmIChEID49IDApIHtcbiAgICBjb25zdCByRCA9IE1hdGguc3FydChEKTtcbiAgICBjb25zdCBTID0gTWF0aC5zaWduKFIgKyByRCkgKiBNYXRoLnBvdyhNYXRoLmFicyhSICsgckQpLCB0aGlyZCk7XG4gICAgY29uc3QgVCA9IE1hdGguc2lnbihSIC0gckQpICogTWF0aC5wb3coTWF0aC5hYnMoUiAtIHJEKSwgdGhpcmQpO1xuICAgIGNvbnN0IEltID0gTWF0aC5hYnMoTWF0aC5zcXJ0KDMpICogKFMgLSBUKSAvIDIpO1xuICAgIGNvbnN0IHQgPSAtdGhpcmQgKiBBICsgKFMgKyBUKTtcbiAgICBpZiAodCA+PSAwICYmIHQgPD0gMSkge1xuICAgICAgcm9vdHMucHVzaCh0KTtcbiAgICB9XG4gICAgaWYgKEltID09PSAwKSB7XG4gICAgICBjb25zdCB0MiA9IC10aGlyZCAqIEEgLSAoUyArIFQpIC8gMjtcbiAgICAgIGlmICh0MiA+PSAwICYmIHQyIDw9IDEpIHtcbiAgICAgICAgcm9vdHMucHVzaCh0Mik7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IHRoZXRhID0gTWF0aC5hY29zKFIgLyBNYXRoLnNxcnQoLVEgKiBRICogUSkpO1xuICAgIGNvbnN0IHRoaXJkQSA9IHRoaXJkICogQTtcbiAgICBjb25zdCB0d29TcXJ0USA9IDIgKiBNYXRoLnNxcnQoLVEpO1xuICAgIGNvbnN0IHQxID0gdHdvU3FydFEgKiBNYXRoLmNvcyh0aGlyZCAqIHRoZXRhKSAtIHRoaXJkQTtcbiAgICBjb25zdCB0MiA9IHR3b1NxcnRRICogTWF0aC5jb3ModGhpcmQgKiAodGhldGEgKyAyICogTWF0aC5QSSkpIC0gdGhpcmRBO1xuICAgIGNvbnN0IHQzID0gdHdvU3FydFEgKiBNYXRoLmNvcyh0aGlyZCAqICh0aGV0YSArIDQgKiBNYXRoLlBJKSkgLSB0aGlyZEE7XG4gICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgcm9vdHMucHVzaCh0MSk7XG4gICAgfVxuICAgIGlmICh0MiA+PSAwICYmIHQyIDw9IDEpIHtcbiAgICAgIHJvb3RzLnB1c2godDIpO1xuICAgIH1cbiAgICBpZiAodDMgPj0gMCAmJiB0MyA8PSAxKSB7XG4gICAgICByb290cy5wdXNoKHQzKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJvb3RzO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9pbnRlcnNlY3Rpb24udHNcbmZ1bmN0aW9uIHNlZ21lbnRJbnRlcnNlY3Rpb24oYXgxLCBheTEsIGF4MiwgYXkyLCBieDEsIGJ5MSwgYngyLCBieTIpIHtcbiAgY29uc3QgZCA9IChheDIgLSBheDEpICogKGJ5MiAtIGJ5MSkgLSAoYXkyIC0gYXkxKSAqIChieDIgLSBieDEpO1xuICBpZiAoZCA9PT0gMCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGNvbnN0IHVhID0gKChieDIgLSBieDEpICogKGF5MSAtIGJ5MSkgLSAoYXgxIC0gYngxKSAqIChieTIgLSBieTEpKSAvIGQ7XG4gIGNvbnN0IHViID0gKChheDIgLSBheDEpICogKGF5MSAtIGJ5MSkgLSAoYXkyIC0gYXkxKSAqIChheDEgLSBieDEpKSAvIGQ7XG4gIGlmICh1YSA+PSAwICYmIHVhIDw9IDEgJiYgdWIgPj0gMCAmJiB1YiA8PSAxKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBjdWJpY1NlZ21lbnRJbnRlcnNlY3Rpb25zKHB4MSwgcHkxLCBweDIsIHB5MiwgcHgzLCBweTMsIHB4NCwgcHk0LCB4MSwgeTEsIHgyLCB5Mikge1xuICBsZXQgaW50ZXJzZWN0aW9ucyA9IDA7XG4gIGNvbnN0IEEgPSB5MSAtIHkyO1xuICBjb25zdCBCID0geDIgLSB4MTtcbiAgY29uc3QgQyA9IHgxICogKHkyIC0geTEpIC0geTEgKiAoeDIgLSB4MSk7XG4gIGNvbnN0IGJ4ID0gYmV6aWVyQ29lZmZpY2llbnRzKHB4MSwgcHgyLCBweDMsIHB4NCk7XG4gIGNvbnN0IGJ5ID0gYmV6aWVyQ29lZmZpY2llbnRzKHB5MSwgcHkyLCBweTMsIHB5NCk7XG4gIGNvbnN0IGEgPSBBICogYnhbMF0gKyBCICogYnlbMF07XG4gIGNvbnN0IGIgPSBBICogYnhbMV0gKyBCICogYnlbMV07XG4gIGNvbnN0IGMgPSBBICogYnhbMl0gKyBCICogYnlbMl07XG4gIGNvbnN0IGQgPSBBICogYnhbM10gKyBCICogYnlbM10gKyBDO1xuICBjb25zdCByb290cyA9IGN1YmljUm9vdHMoYSwgYiwgYywgZCk7XG4gIGZvciAoY29uc3QgdCBvZiByb290cykge1xuICAgIGNvbnN0IHR0ID0gdCAqIHQ7XG4gICAgY29uc3QgdHR0ID0gdCAqIHR0O1xuICAgIGNvbnN0IHggPSBieFswXSAqIHR0dCArIGJ4WzFdICogdHQgKyBieFsyXSAqIHQgKyBieFszXTtcbiAgICBjb25zdCB5ID0gYnlbMF0gKiB0dHQgKyBieVsxXSAqIHR0ICsgYnlbMl0gKiB0ICsgYnlbM107XG4gICAgbGV0IHM7XG4gICAgaWYgKHgxID09PSB4Mikge1xuICAgICAgcyA9ICh5IC0geTEpIC8gKHkyIC0geTEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzID0gKHggLSB4MSkgLyAoeDIgLSB4MSk7XG4gICAgfVxuICAgIGlmIChzID49IDAgJiYgcyA8PSAxKSB7XG4gICAgICBpbnRlcnNlY3Rpb25zKys7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbnRlcnNlY3Rpb25zO1xufVxuZnVuY3Rpb24gYmV6aWVyQ29lZmZpY2llbnRzKFAxLCBQMiwgUDMsIFA0KSB7XG4gIHJldHVybiBbXG4gICAgLy8gQsOpemllciBleHByZXNzZWQgYXMgbWF0cml4IG9wZXJhdGlvbnM6XG4gICAgLVAxICsgMyAqIFAyIC0gMyAqIFAzICsgUDQsXG4gICAgLy8gICAgICAgICAgICAgICAgIHwtMSAgMyAtMyAgMXwgfFAxfFxuICAgIDMgKiBQMSAtIDYgKiBQMiArIDMgKiBQMyxcbiAgICAvLyAgIFt0XjMgdF4yIHQgMV0gfCAzIC02ICAzICAwfCB8UDJ8XG4gICAgLTMgKiBQMSArIDMgKiBQMixcbiAgICAvLyAgICAgICAgICAgICAgICAgfC0zICAzICAwICAwfCB8UDN8XG4gICAgUDFcbiAgICAvLyAgICAgICAgICAgICAgICAgfCAxICAwICAwICAwfCB8UDR8XG4gIF07XG59XG5mdW5jdGlvbiBhcmNJbnRlcnNlY3Rpb25zKGN4LCBjeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGNvdW50ZXJDbG9ja3dpc2UsIHgxLCB5MSwgeDIsIHkyKSB7XG4gIGlmIChpc05hTihjeCkgfHwgaXNOYU4oY3kpKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKGNvdW50ZXJDbG9ja3dpc2UpIHtcbiAgICBbZW5kQW5nbGUsIHN0YXJ0QW5nbGVdID0gW3N0YXJ0QW5nbGUsIGVuZEFuZ2xlXTtcbiAgfVxuICBjb25zdCBrID0gKHkyIC0geTEpIC8gKHgyIC0geDEpO1xuICBjb25zdCB5MCA9IHkxIC0gayAqIHgxO1xuICBjb25zdCBhID0gTWF0aC5wb3coaywgMikgKyAxO1xuICBjb25zdCBiID0gMiAqIChrICogKHkwIC0gY3kpIC0gY3gpO1xuICBjb25zdCBjID0gTWF0aC5wb3coY3gsIDIpICsgTWF0aC5wb3coeTAgLSBjeSwgMikgLSBNYXRoLnBvdyhyLCAyKTtcbiAgY29uc3QgZCA9IE1hdGgucG93KGIsIDIpIC0gNCAqIGEgKiBjO1xuICBpZiAoZCA8IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBjb25zdCBpMXggPSAoLWIgKyBNYXRoLnNxcnQoZCkpIC8gMiAvIGE7XG4gIGNvbnN0IGkyeCA9ICgtYiAtIE1hdGguc3FydChkKSkgLyAyIC8gYTtcbiAgbGV0IGludGVyc2VjdGlvbnMgPSAwO1xuICBbaTF4LCBpMnhdLmZvckVhY2goKHgpID0+IHtcbiAgICBjb25zdCBpc1hJbnNpZGVMaW5lID0geCA+PSBNYXRoLm1pbih4MSwgeDIpICYmIHggPD0gTWF0aC5tYXgoeDEsIHgyKTtcbiAgICBpZiAoIWlzWEluc2lkZUxpbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeSA9IGsgKiB4ICsgeTA7XG4gICAgY29uc3QgYWRqYWNlbnQgPSB4IC0gY3g7XG4gICAgY29uc3Qgb3Bwb3NpdGUgPSB5IC0gY3k7XG4gICAgY29uc3QgYW5nbGUyID0gTWF0aC5hdGFuMihvcHBvc2l0ZSwgYWRqYWNlbnQpO1xuICAgIGlmIChpc0JldHdlZW5BbmdsZXMoYW5nbGUyLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSkpIHtcbiAgICAgIGludGVyc2VjdGlvbnMrKztcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gaW50ZXJzZWN0aW9ucztcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvdXRpbC9iZXppZXIudHNcbmZ1bmN0aW9uIGV2YWx1YXRlQmV6aWVyKHAwLCBwMSwgcDIsIHAzLCB0KSB7XG4gIHJldHVybiAoMSAtIHQpICoqIDMgKiBwMCArIDMgKiAoMSAtIHQpICoqIDIgKiB0ICogcDEgKyAzICogKDEgLSB0KSAqIHQgKiogMiAqIHAyICsgdCAqKiAzICogcDM7XG59XG5mdW5jdGlvbiBzb2x2ZUJlemllcihwMCwgcDEsIHAyLCBwMywgdmFsdWUpIHtcbiAgaWYgKHZhbHVlIDw9IE1hdGgubWluKHAwLCBwMykpIHtcbiAgICByZXR1cm4gcDAgPCBwMyA/IDAgOiAxO1xuICB9IGVsc2UgaWYgKHZhbHVlID49IE1hdGgubWF4KHAwLCBwMykpIHtcbiAgICByZXR1cm4gcDAgPCBwMyA/IDEgOiAwO1xuICB9XG4gIGxldCB0MCA9IDA7XG4gIGxldCB0MSA9IDE7XG4gIGxldCB0ID0gTmFOO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDEyOyBpICs9IDEpIHtcbiAgICB0ID0gKHQwICsgdDEpIC8gMjtcbiAgICBjb25zdCBjdXJ2ZVZhbHVlID0gZXZhbHVhdGVCZXppZXIocDAsIHAxLCBwMiwgcDMsIHQpO1xuICAgIGlmIChjdXJ2ZVZhbHVlIDwgdmFsdWUpIHtcbiAgICAgIHQwID0gdDtcbiAgICB9IGVsc2Uge1xuICAgICAgdDEgPSB0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIHNwbGl0QmV6aWVyKHAweCwgcDB5LCBwMXgsIHAxeSwgcDJ4LCBwMnksIHAzeCwgcDN5LCB0KSB7XG4gIGNvbnN0IHgwMSA9ICgxIC0gdCkgKiBwMHggKyB0ICogcDF4O1xuICBjb25zdCB5MDEgPSAoMSAtIHQpICogcDB5ICsgdCAqIHAxeTtcbiAgY29uc3QgeDEyID0gKDEgLSB0KSAqIHAxeCArIHQgKiBwMng7XG4gIGNvbnN0IHkxMiA9ICgxIC0gdCkgKiBwMXkgKyB0ICogcDJ5O1xuICBjb25zdCB4MjMgPSAoMSAtIHQpICogcDJ4ICsgdCAqIHAzeDtcbiAgY29uc3QgeTIzID0gKDEgLSB0KSAqIHAyeSArIHQgKiBwM3k7XG4gIGNvbnN0IHgwMTIgPSAoMSAtIHQpICogeDAxICsgdCAqIHgxMjtcbiAgY29uc3QgeTAxMiA9ICgxIC0gdCkgKiB5MDEgKyB0ICogeTEyO1xuICBjb25zdCB4MTIzID0gKDEgLSB0KSAqIHgxMiArIHQgKiB4MjM7XG4gIGNvbnN0IHkxMjMgPSAoMSAtIHQpICogeTEyICsgdCAqIHkyMztcbiAgY29uc3QgeDAxMjMgPSAoMSAtIHQpICogeDAxMiArIHQgKiB4MTIzO1xuICBjb25zdCB5MDEyMyA9ICgxIC0gdCkgKiB5MDEyICsgdCAqIHkxMjM7XG4gIHJldHVybiBbXG4gICAgW1xuICAgICAgeyB4OiBwMHgsIHk6IHAweSB9LFxuICAgICAgeyB4OiB4MDEsIHk6IHkwMSB9LFxuICAgICAgeyB4OiB4MDEyLCB5OiB5MDEyIH0sXG4gICAgICB7IHg6IHgwMTIzLCB5OiB5MDEyMyB9XG4gICAgXSxcbiAgICBbXG4gICAgICB7IHg6IHgwMTIzLCB5OiB5MDEyMyB9LFxuICAgICAgeyB4OiB4MTIzLCB5OiB5MTIzIH0sXG4gICAgICB7IHg6IHgyMywgeTogeTIzIH0sXG4gICAgICB7IHg6IHAzeCwgeTogcDN5IH1cbiAgICBdXG4gIF07XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVEZXJpdmF0aXZlRXh0cmVtYShwMCwgcDEsIHAyLCBwMykge1xuICBjb25zdCBhID0gLXAwICsgMyAqIHAxIC0gMyAqIHAyICsgcDM7XG4gIGNvbnN0IGIgPSAzICogcDAgLSA2ICogcDEgKyAzICogcDI7XG4gIGNvbnN0IGMgPSAtMyAqIHAwICsgMyAqIHAxO1xuICBpZiAoYSA9PT0gMCkge1xuICAgIGlmIChiICE9PSAwKSB7XG4gICAgICBjb25zdCB0ID0gLWMgLyBiO1xuICAgICAgaWYgKHQgPiAwICYmIHQgPCAxKSB7XG4gICAgICAgIHJldHVybiBbdF07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfVxuICBjb25zdCBkaXNjcmltaW5hbnQgPSBiICogYiAtIDQgKiBhICogYztcbiAgaWYgKGRpc2NyaW1pbmFudCA+PSAwKSB7XG4gICAgY29uc3Qgc3FydERpc2NyaW1pbmFudCA9IE1hdGguc3FydChkaXNjcmltaW5hbnQpO1xuICAgIGNvbnN0IHQxID0gKC1iICsgc3FydERpc2NyaW1pbmFudCkgLyAoMiAqIGEpO1xuICAgIGNvbnN0IHQyID0gKC1iIC0gc3FydERpc2NyaW1pbmFudCkgLyAoMiAqIGEpO1xuICAgIHJldHVybiBbdDEsIHQyXS5maWx0ZXIoKHQpID0+IHQgPiAwICYmIHQgPCAxKTtcbiAgfVxuICByZXR1cm4gW107XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVEZXJpdmF0aXZlRXh0cmVtYVhZKHN4LCBzeSwgY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgeCwgeSkge1xuICBjb25zdCB0eCA9IGNhbGN1bGF0ZURlcml2YXRpdmVFeHRyZW1hKHN4LCBjcDF4LCBjcDJ4LCB4KTtcbiAgY29uc3QgdHkgPSBjYWxjdWxhdGVEZXJpdmF0aXZlRXh0cmVtYShzeSwgY3AxeSwgY3AyeSwgeSk7XG4gIHJldHVybiBbLi4udHgsIC4uLnR5XTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvZXh0ZW5kZWRQYXRoMkQudHNcbnZhciBFeHRlbmRlZFBhdGgyRCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLy8gVGhlIG1ldGhvZHMgb2YgdGhpcyBjbGFzcyB3aWxsIGxpa2VseSBiZSBjYWxsZWQgbWFueSB0aW1lcyBwZXIgYW5pbWF0aW9uIGZyYW1lLFxuICAgIC8vIGFuZCBhbnkgYWxsb2NhdGlvbiBjYW4gdHJpZ2dlciBhIEdDIGN5Y2xlIGR1cmluZyBhbmltYXRpb24sIHNvIHdlIGF0dGVtcHRcbiAgICAvLyB0byBtaW5pbWl6ZSB0aGUgbnVtYmVyIG9mIGFsbG9jYXRpb25zLlxuICAgIHRoaXMucGF0aDJkID0gbmV3IFBhdGgyRCgpO1xuICAgIHRoaXMucHJldmlvdXNDb21tYW5kcyA9IFtdO1xuICAgIHRoaXMucHJldmlvdXNQYXJhbXMgPSBbXTtcbiAgICB0aGlzLnByZXZpb3VzQ2xvc2VkUGF0aCA9IGZhbHNlO1xuICAgIHRoaXMuY29tbWFuZHMgPSBbXTtcbiAgICB0aGlzLnBhcmFtcyA9IFtdO1xuICAgIHRoaXMub3BlbmVkUGF0aCA9IGZhbHNlO1xuICAgIHRoaXMuY2xvc2VkUGF0aCA9IGZhbHNlO1xuICB9XG4gIGlzRGlydHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvc2VkUGF0aCAhPT0gdGhpcy5wcmV2aW91c0Nsb3NlZFBhdGggfHwgdGhpcy5wcmV2aW91c0NvbW1hbmRzLmxlbmd0aCAhPT0gdGhpcy5jb21tYW5kcy5sZW5ndGggfHwgdGhpcy5wcmV2aW91c1BhcmFtcy5sZW5ndGggIT09IHRoaXMucGFyYW1zLmxlbmd0aCB8fCB0aGlzLnByZXZpb3VzQ29tbWFuZHMudG9TdHJpbmcoKSAhPT0gdGhpcy5jb21tYW5kcy50b1N0cmluZygpIHx8IHRoaXMucHJldmlvdXNQYXJhbXMudG9TdHJpbmcoKSAhPT0gdGhpcy5wYXJhbXMudG9TdHJpbmcoKTtcbiAgfVxuICBnZXRQYXRoMkQoKSB7XG4gICAgcmV0dXJuIHRoaXMucGF0aDJkO1xuICB9XG4gIG1vdmVUbyh4LCB5KSB7XG4gICAgdGhpcy5vcGVuZWRQYXRoID0gdHJ1ZTtcbiAgICB0aGlzLnBhdGgyZC5tb3ZlVG8oeCwgeSk7XG4gICAgdGhpcy5jb21tYW5kcy5wdXNoKDAgLyogTW92ZSAqLyk7XG4gICAgdGhpcy5wYXJhbXMucHVzaCh4LCB5KTtcbiAgfVxuICBsaW5lVG8oeCwgeSkge1xuICAgIGlmICh0aGlzLm9wZW5lZFBhdGgpIHtcbiAgICAgIHRoaXMucGF0aDJkLmxpbmVUbyh4LCB5KTtcbiAgICAgIHRoaXMuY29tbWFuZHMucHVzaCgxIC8qIExpbmUgKi8pO1xuICAgICAgdGhpcy5wYXJhbXMucHVzaCh4LCB5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tb3ZlVG8oeCwgeSk7XG4gICAgfVxuICB9XG4gIHJlY3QoeCwgeSwgd2lkdGgyLCBoZWlnaHQyKSB7XG4gICAgdGhpcy5tb3ZlVG8oeCwgeSk7XG4gICAgdGhpcy5saW5lVG8oeCArIHdpZHRoMiwgeSk7XG4gICAgdGhpcy5saW5lVG8oeCArIHdpZHRoMiwgeSArIGhlaWdodDIpO1xuICAgIHRoaXMubGluZVRvKHgsIHkgKyBoZWlnaHQyKTtcbiAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICB9XG4gIHJvdW5kUmVjdCh4LCB5LCB3aWR0aDIsIGhlaWdodDIsIHJhZGlpKSB7XG4gICAgcmFkaWkgPSBNYXRoLm1pbihyYWRpaSwgd2lkdGgyIC8gMiwgaGVpZ2h0MiAvIDIpO1xuICAgIHRoaXMubW92ZVRvKHgsIHkgKyByYWRpaSk7XG4gICAgdGhpcy5hcmMoeCArIHJhZGlpLCB5ICsgcmFkaWksIHJhZGlpLCBNYXRoLlBJLCAxLjUgKiBNYXRoLlBJKTtcbiAgICB0aGlzLmxpbmVUbyh4ICsgcmFkaWksIHkpO1xuICAgIHRoaXMubGluZVRvKHggKyB3aWR0aDIgLSByYWRpaSwgeSk7XG4gICAgdGhpcy5hcmMoeCArIHdpZHRoMiAtIHJhZGlpLCB5ICsgcmFkaWksIHJhZGlpLCAxLjUgKiBNYXRoLlBJLCAyICogTWF0aC5QSSk7XG4gICAgdGhpcy5saW5lVG8oeCArIHdpZHRoMiwgeSArIHJhZGlpKTtcbiAgICB0aGlzLmxpbmVUbyh4ICsgd2lkdGgyLCB5ICsgaGVpZ2h0MiAtIHJhZGlpKTtcbiAgICB0aGlzLmFyYyh4ICsgd2lkdGgyIC0gcmFkaWksIHkgKyBoZWlnaHQyIC0gcmFkaWksIHJhZGlpLCAwLCBNYXRoLlBJIC8gMik7XG4gICAgdGhpcy5saW5lVG8oeCArIHdpZHRoMiAtIHJhZGlpLCB5ICsgaGVpZ2h0Mik7XG4gICAgdGhpcy5saW5lVG8oeCArIHJhZGlpLCB5ICsgaGVpZ2h0Mik7XG4gICAgdGhpcy5hcmMoeCArICtyYWRpaSwgeSArIGhlaWdodDIgLSByYWRpaSwgcmFkaWksIE1hdGguUEkgLyAyLCBNYXRoLlBJKTtcbiAgICB0aGlzLmxpbmVUbyh4LCB5ICsgaGVpZ2h0MiAtIHJhZGlpKTtcbiAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICB9XG4gIGFyYyh4LCB5LCByLCBzQW5nbGUsIGVBbmdsZSwgY291bnRlckNsb2Nrd2lzZSkge1xuICAgIHRoaXMub3BlbmVkUGF0aCA9IHRydWU7XG4gICAgdGhpcy5wYXRoMmQuYXJjKHgsIHksIHIsIHNBbmdsZSwgZUFuZ2xlLCBjb3VudGVyQ2xvY2t3aXNlKTtcbiAgICB0aGlzLmNvbW1hbmRzLnB1c2goMiAvKiBBcmMgKi8pO1xuICAgIHRoaXMucGFyYW1zLnB1c2goeCwgeSwgciwgc0FuZ2xlLCBlQW5nbGUsIGNvdW50ZXJDbG9ja3dpc2UgPyAxIDogMCk7XG4gIH1cbiAgY3ViaWNDdXJ2ZVRvKGN4MSwgY3kxLCBjeDIsIGN5MiwgeCwgeSkge1xuICAgIGlmICghdGhpcy5vcGVuZWRQYXRoKSB7XG4gICAgICB0aGlzLm1vdmVUbyhjeDEsIGN5MSk7XG4gICAgfVxuICAgIHRoaXMucGF0aDJkLmJlemllckN1cnZlVG8oY3gxLCBjeTEsIGN4MiwgY3kyLCB4LCB5KTtcbiAgICB0aGlzLmNvbW1hbmRzLnB1c2goMyAvKiBDdXJ2ZSAqLyk7XG4gICAgdGhpcy5wYXJhbXMucHVzaChjeDEsIGN5MSwgY3gyLCBjeTIsIHgsIHkpO1xuICB9XG4gIGNsb3NlUGF0aCgpIHtcbiAgICBpZiAodGhpcy5vcGVuZWRQYXRoKSB7XG4gICAgICB0aGlzLnBhdGgyZC5jbG9zZVBhdGgoKTtcbiAgICAgIHRoaXMuY29tbWFuZHMucHVzaCg0IC8qIENsb3NlUGF0aCAqLyk7XG4gICAgICB0aGlzLm9wZW5lZFBhdGggPSBmYWxzZTtcbiAgICAgIHRoaXMuY2xvc2VkUGF0aCA9IHRydWU7XG4gICAgfVxuICB9XG4gIGNsZWFyKHRyYWNrQ2hhbmdlcykge1xuICAgIGlmICh0cmFja0NoYW5nZXMpIHtcbiAgICAgIHRoaXMucHJldmlvdXNDb21tYW5kcyA9IHRoaXMuY29tbWFuZHM7XG4gICAgICB0aGlzLnByZXZpb3VzUGFyYW1zID0gdGhpcy5wYXJhbXM7XG4gICAgICB0aGlzLnByZXZpb3VzQ2xvc2VkUGF0aCA9IHRoaXMuY2xvc2VkUGF0aDtcbiAgICB9XG4gICAgdGhpcy5wYXRoMmQgPSBuZXcgUGF0aDJEKCk7XG4gICAgdGhpcy5vcGVuZWRQYXRoID0gZmFsc2U7XG4gICAgdGhpcy5jbG9zZWRQYXRoID0gZmFsc2U7XG4gICAgdGhpcy5jb21tYW5kcyA9IFtdO1xuICAgIHRoaXMucGFyYW1zID0gW107XG4gIH1cbiAgaXNQb2ludEluUGF0aCh4LCB5KSB7XG4gICAgY29uc3QgY29tbWFuZHMgPSB0aGlzLmNvbW1hbmRzO1xuICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMucGFyYW1zO1xuICAgIGNvbnN0IGNuID0gY29tbWFuZHMubGVuZ3RoO1xuICAgIGNvbnN0IG94ID0gLTFlNDtcbiAgICBjb25zdCBveSA9IC0xZTQ7XG4gICAgbGV0IHN4ID0gTmFOO1xuICAgIGxldCBzeSA9IE5hTjtcbiAgICBsZXQgcHggPSAwO1xuICAgIGxldCBweSA9IDA7XG4gICAgbGV0IGludGVyc2VjdGlvbkNvdW50ID0gMDtcbiAgICBmb3IgKGxldCBjaSA9IDAsIHBpID0gMDsgY2kgPCBjbjsgY2krKykge1xuICAgICAgc3dpdGNoIChjb21tYW5kc1tjaV0pIHtcbiAgICAgICAgY2FzZSAwIC8qIE1vdmUgKi86XG4gICAgICAgICAgaW50ZXJzZWN0aW9uQ291bnQgKz0gc2VnbWVudEludGVyc2VjdGlvbihzeCwgc3ksIHB4LCBweSwgb3gsIG95LCB4LCB5KTtcbiAgICAgICAgICBweCA9IHBhcmFtc1twaSsrXTtcbiAgICAgICAgICBzeCA9IHB4O1xuICAgICAgICAgIHB5ID0gcGFyYW1zW3BpKytdO1xuICAgICAgICAgIHN5ID0gcHk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMSAvKiBMaW5lICovOlxuICAgICAgICAgIGludGVyc2VjdGlvbkNvdW50ICs9IHNlZ21lbnRJbnRlcnNlY3Rpb24ocHgsIHB5LCBwYXJhbXNbcGkrK10sIHBhcmFtc1twaSsrXSwgb3gsIG95LCB4LCB5KTtcbiAgICAgICAgICBweCA9IHBhcmFtc1twaSAtIDJdO1xuICAgICAgICAgIHB5ID0gcGFyYW1zW3BpIC0gMV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMyAvKiBDdXJ2ZSAqLzpcbiAgICAgICAgICBpbnRlcnNlY3Rpb25Db3VudCArPSBjdWJpY1NlZ21lbnRJbnRlcnNlY3Rpb25zKFxuICAgICAgICAgICAgcHgsXG4gICAgICAgICAgICBweSxcbiAgICAgICAgICAgIHBhcmFtc1twaSsrXSxcbiAgICAgICAgICAgIHBhcmFtc1twaSsrXSxcbiAgICAgICAgICAgIHBhcmFtc1twaSsrXSxcbiAgICAgICAgICAgIHBhcmFtc1twaSsrXSxcbiAgICAgICAgICAgIHBhcmFtc1twaSsrXSxcbiAgICAgICAgICAgIHBhcmFtc1twaSsrXSxcbiAgICAgICAgICAgIG94LFxuICAgICAgICAgICAgb3ksXG4gICAgICAgICAgICB4LFxuICAgICAgICAgICAgeVxuICAgICAgICAgICk7XG4gICAgICAgICAgcHggPSBwYXJhbXNbcGkgLSAyXTtcbiAgICAgICAgICBweSA9IHBhcmFtc1twaSAtIDFdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIgLyogQXJjICovOiB7XG4gICAgICAgICAgY29uc3QgY3ggPSBwYXJhbXNbcGkrK107XG4gICAgICAgICAgY29uc3QgY3kgPSBwYXJhbXNbcGkrK107XG4gICAgICAgICAgY29uc3QgciA9IHBhcmFtc1twaSsrXTtcbiAgICAgICAgICBjb25zdCBzdGFydEFuZ2xlID0gcGFyYW1zW3BpKytdO1xuICAgICAgICAgIGNvbnN0IGVuZEFuZ2xlID0gcGFyYW1zW3BpKytdO1xuICAgICAgICAgIGNvbnN0IGNvdW50ZXJDbG9ja3dpc2UgPSBCb29sZWFuKHBhcmFtc1twaSsrXSk7XG4gICAgICAgICAgaW50ZXJzZWN0aW9uQ291bnQgKz0gYXJjSW50ZXJzZWN0aW9ucyhcbiAgICAgICAgICAgIGN4LFxuICAgICAgICAgICAgY3ksXG4gICAgICAgICAgICByLFxuICAgICAgICAgICAgc3RhcnRBbmdsZSxcbiAgICAgICAgICAgIGVuZEFuZ2xlLFxuICAgICAgICAgICAgY291bnRlckNsb2Nrd2lzZSxcbiAgICAgICAgICAgIG94LFxuICAgICAgICAgICAgb3ksXG4gICAgICAgICAgICB4LFxuICAgICAgICAgICAgeVxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKCFpc05hTihzeCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0WCA9IGN4ICsgTWF0aC5jb3Moc3RhcnRBbmdsZSkgKiByO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRZID0gY3kgKyBNYXRoLnNpbihzdGFydEFuZ2xlKSAqIHI7XG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25Db3VudCArPSBzZWdtZW50SW50ZXJzZWN0aW9uKHB4LCBweSwgc3RhcnRYLCBzdGFydFksIG94LCBveSwgeCwgeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHB4ID0gY3ggKyBNYXRoLmNvcyhlbmRBbmdsZSkgKiByO1xuICAgICAgICAgIHB5ID0gY3kgKyBNYXRoLnNpbihlbmRBbmdsZSkgKiByO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgNCAvKiBDbG9zZVBhdGggKi86XG4gICAgICAgICAgaW50ZXJzZWN0aW9uQ291bnQgKz0gc2VnbWVudEludGVyc2VjdGlvbihzeCwgc3ksIHB4LCBweSwgb3gsIG95LCB4LCB5KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGludGVyc2VjdGlvbkNvdW50ICUgMiA9PT0gMTtcbiAgfVxuICBkaXN0YW5jZVNxdWFyZWQoeCwgeSkge1xuICAgIGxldCBiZXN0ID0gSW5maW5pdHk7XG4gICAgY29uc3QgY29tbWFuZHMgPSB0aGlzLmNvbW1hbmRzO1xuICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMucGFyYW1zO1xuICAgIGNvbnN0IGNuID0gY29tbWFuZHMubGVuZ3RoO1xuICAgIGxldCBzeCA9IE5hTjtcbiAgICBsZXQgc3kgPSBOYU47XG4gICAgbGV0IHB4ID0gMDtcbiAgICBsZXQgcHkgPSAwO1xuICAgIGZvciAobGV0IGNpID0gMCwgcGkgPSAwOyBjaSA8IGNuOyBjaSsrKSB7XG4gICAgICBzd2l0Y2ggKGNvbW1hbmRzW2NpXSkge1xuICAgICAgICBjYXNlIDAgLyogTW92ZSAqLzpcbiAgICAgICAgICBweCA9IHN4ID0gcGFyYW1zW3BpKytdO1xuICAgICAgICAgIHB5ID0gc3kgPSBwYXJhbXNbcGkrK107XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMSAvKiBMaW5lICovOiB7XG4gICAgICAgICAgY29uc3QgbnggPSBwYXJhbXNbcGkrK107XG4gICAgICAgICAgY29uc3QgbnkgPSBwYXJhbXNbcGkrK107XG4gICAgICAgICAgYmVzdCA9IGxpbmVEaXN0YW5jZVNxdWFyZWQoeCwgeSwgcHgsIHB5LCBueCwgbnksIGJlc3QpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMyAvKiBDdXJ2ZSAqLzpcbiAgICAgICAgICBMb2dnZXIuZXJyb3IoXCJDb21tYW5kLkN1cnZlIGRpc3RhbmNlU3F1YXJlIG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyIC8qIEFyYyAqLzoge1xuICAgICAgICAgIGNvbnN0IGN4ID0gcGFyYW1zW3BpKytdO1xuICAgICAgICAgIGNvbnN0IGN5ID0gcGFyYW1zW3BpKytdO1xuICAgICAgICAgIGNvbnN0IHIgPSBwYXJhbXNbcGkrK107XG4gICAgICAgICAgY29uc3Qgc3RhcnRBbmdsZSA9IHBhcmFtc1twaSsrXTtcbiAgICAgICAgICBjb25zdCBlbmRBbmdsZSA9IHBhcmFtc1twaSsrXTtcbiAgICAgICAgICBjb25zdCBzdGFydFggPSBjeCArIE1hdGguY29zKHN0YXJ0QW5nbGUpICogcjtcbiAgICAgICAgICBjb25zdCBzdGFydFkgPSBjeSArIE1hdGguc2luKHN0YXJ0QW5nbGUpICogcjtcbiAgICAgICAgICBjb25zdCBjb3VudGVyQ2xvY2t3aXNlID0gQm9vbGVhbihwYXJhbXNbcGkrK10pO1xuICAgICAgICAgIGJlc3QgPSBsaW5lRGlzdGFuY2VTcXVhcmVkKHgsIHksIHB4LCBweSwgc3RhcnRYLCBzdGFydFksIGJlc3QpO1xuICAgICAgICAgIGJlc3QgPSBhcmNEaXN0YW5jZVNxdWFyZWQoeCwgeSwgY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgY291bnRlckNsb2Nrd2lzZSwgYmVzdCk7XG4gICAgICAgICAgcHggPSBjeCArIE1hdGguY29zKGVuZEFuZ2xlKSAqIHI7XG4gICAgICAgICAgcHkgPSBjeSArIE1hdGguc2luKGVuZEFuZ2xlKSAqIHI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSA0IC8qIENsb3NlUGF0aCAqLzpcbiAgICAgICAgICBiZXN0ID0gbGluZURpc3RhbmNlU3F1YXJlZCh4LCB5LCBweCwgcHksIHN4LCBzeSwgYmVzdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBiZXN0O1xuICB9XG4gIGdldFBvaW50cygpIHtcbiAgICBjb25zdCB7IGNvbW1hbmRzLCBwYXJhbXMgfSA9IHRoaXM7XG4gICAgY29uc3QgY29vcmRzID0gW107XG4gICAgbGV0IHBpID0gMDtcbiAgICBmb3IgKGNvbnN0IGNvbW1hbmQgb2YgY29tbWFuZHMpIHtcbiAgICAgIHN3aXRjaCAoY29tbWFuZCkge1xuICAgICAgICBjYXNlIDAgLyogTW92ZSAqLzpcbiAgICAgICAgY2FzZSAxIC8qIExpbmUgKi86XG4gICAgICAgICAgY29vcmRzLnB1c2goeyB4OiBwYXJhbXNbcGkrK10sIHk6IHBhcmFtc1twaSsrXSB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzIC8qIEN1cnZlICovOlxuICAgICAgICAgIHBpICs9IDQ7XG4gICAgICAgICAgY29vcmRzLnB1c2goeyB4OiBwYXJhbXNbcGkrK10sIHk6IHBhcmFtc1twaSsrXSB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyIC8qIEFyYyAqLzpcbiAgICAgICAgICBjb29yZHMucHVzaCh7IHg6IHBhcmFtc1twaSsrXSwgeTogcGFyYW1zW3BpKytdIH0pO1xuICAgICAgICAgIHBpICs9IDQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNCAvKiBDbG9zZVBhdGggKi86XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb29yZHM7XG4gIH1cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9kXG4gIHRvU1ZHKHRyYW5zZm9ybSA9ICh4LCB5KSA9PiAoeyB4LCB5IH0pKSB7XG4gICAgY29uc3QgYnVmZmVyID0gW107XG4gICAgY29uc3QgeyBjb21tYW5kcywgcGFyYW1zIH0gPSB0aGlzO1xuICAgIGNvbnN0IGFkZENvbW1hbmQgPSAoY29tbWFuZCwgLi4ucG9pbnRzKSA9PiB7XG4gICAgICBidWZmZXIucHVzaChjb21tYW5kKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gdHJhbnNmb3JtKHBvaW50c1tpXSwgcG9pbnRzW2kgKyAxXSk7XG4gICAgICAgIGJ1ZmZlci5wdXNoKHgsIHkpO1xuICAgICAgfVxuICAgIH07XG4gICAgbGV0IHBpID0gMDtcbiAgICBmb3IgKGNvbnN0IGNvbW1hbmQgb2YgY29tbWFuZHMpIHtcbiAgICAgIHN3aXRjaCAoY29tbWFuZCkge1xuICAgICAgICBjYXNlIDAgLyogTW92ZSAqLzpcbiAgICAgICAgICBhZGRDb21tYW5kKFwiTVwiLCBwYXJhbXNbcGkrK10sIHBhcmFtc1twaSsrXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMSAvKiBMaW5lICovOlxuICAgICAgICAgIGFkZENvbW1hbmQoXCJMXCIsIHBhcmFtc1twaSsrXSwgcGFyYW1zW3BpKytdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzIC8qIEN1cnZlICovOlxuICAgICAgICAgIGFkZENvbW1hbmQoXCJDXCIsIHBhcmFtc1twaSsrXSwgcGFyYW1zW3BpKytdLCBwYXJhbXNbcGkrK10sIHBhcmFtc1twaSsrXSwgcGFyYW1zW3BpKytdLCBwYXJhbXNbcGkrK10pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIgLyogQXJjICovOiB7XG4gICAgICAgICAgY29uc3QgY3ggPSBwYXJhbXNbcGkrK107XG4gICAgICAgICAgY29uc3QgY3kgPSBwYXJhbXNbcGkrK107XG4gICAgICAgICAgY29uc3QgciA9IHBhcmFtc1twaSsrXTtcbiAgICAgICAgICBjb25zdCBBMCA9IHBhcmFtc1twaSsrXTtcbiAgICAgICAgICBjb25zdCBBMSA9IHBhcmFtc1twaSsrXTtcbiAgICAgICAgICBjb25zdCBjY3cgPSBwYXJhbXNbcGkrK107XG4gICAgICAgICAgbGV0IHN3ZWVwID0gY2N3ID8gQTAgLSBBMSA6IEExIC0gQTA7XG4gICAgICAgICAgaWYgKHN3ZWVwIDwgMCkge1xuICAgICAgICAgICAgc3dlZXAgKz0gTWF0aC5jZWlsKC1zd2VlcCAvICgyICogTWF0aC5QSSkpICogMiAqIE1hdGguUEk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjY3cpIHtcbiAgICAgICAgICAgIHN3ZWVwID0gLXN3ZWVwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBhcmNTZWN0aW9ucyA9IE1hdGgubWF4KE1hdGguY2VpbChNYXRoLmFicyhzd2VlcCkgLyAoTWF0aC5QSSAvIDIpKSwgMSk7XG4gICAgICAgICAgY29uc3Qgc3RlcCA9IHN3ZWVwIC8gYXJjU2VjdGlvbnM7XG4gICAgICAgICAgY29uc3QgaCA9IDQgLyAzICogTWF0aC50YW4oc3RlcCAvIDQpO1xuICAgICAgICAgIGNvbnN0IG1vdmUgPSBidWZmZXIubGVuZ3RoID09PSAwID8gXCJNXCIgOiBcIkxcIjtcbiAgICAgICAgICBhZGRDb21tYW5kKG1vdmUsIGN4ICsgTWF0aC5jb3MoQTApICogciwgY3kgKyBNYXRoLnNpbihBMCkgKiByKTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyY1NlY3Rpb25zOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGEwID0gQTAgKyBzdGVwICogKGkgKyAwKTtcbiAgICAgICAgICAgIGNvbnN0IGExID0gQTAgKyBzdGVwICogKGkgKyAxKTtcbiAgICAgICAgICAgIGNvbnN0IHJTaW5TdGFydCA9IHIgKiBNYXRoLnNpbihhMCk7XG4gICAgICAgICAgICBjb25zdCByQ29zU3RhcnQgPSByICogTWF0aC5jb3MoYTApO1xuICAgICAgICAgICAgY29uc3QgclNpbkVuZCA9IHIgKiBNYXRoLnNpbihhMSk7XG4gICAgICAgICAgICBjb25zdCByQ29zRW5kID0gciAqIE1hdGguY29zKGExKTtcbiAgICAgICAgICAgIGFkZENvbW1hbmQoXG4gICAgICAgICAgICAgIFwiQ1wiLFxuICAgICAgICAgICAgICBjeCArIHJDb3NTdGFydCAtIGggKiByU2luU3RhcnQsXG4gICAgICAgICAgICAgIGN5ICsgclNpblN0YXJ0ICsgaCAqIHJDb3NTdGFydCxcbiAgICAgICAgICAgICAgY3ggKyByQ29zRW5kICsgaCAqIHJTaW5FbmQsXG4gICAgICAgICAgICAgIGN5ICsgclNpbkVuZCAtIGggKiByQ29zRW5kLFxuICAgICAgICAgICAgICBjeCArIHJDb3NFbmQsXG4gICAgICAgICAgICAgIGN5ICsgclNpbkVuZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSA0IC8qIENsb3NlUGF0aCAqLzpcbiAgICAgICAgICBidWZmZXIucHVzaChcIlpcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBidWZmZXIuam9pbihcIiBcIik7XG4gIH1cbiAgY29tcHV0ZUJCb3goKSB7XG4gICAgY29uc3QgeyBjb21tYW5kcywgcGFyYW1zIH0gPSB0aGlzO1xuICAgIGxldCBbdG9wLCBsZWZ0LCByaWdodCwgYm90XSA9IFtJbmZpbml0eSwgSW5maW5pdHksIC1JbmZpbml0eSwgLUluZmluaXR5XTtcbiAgICBsZXQgW3N4LCBzeV0gPSBbTmFOLCBOYU5dO1xuICAgIGxldCBbbXgsIG15XSA9IFtOYU4sIE5hTl07XG4gICAgY29uc3Qgam9pblBvaW50ID0gKHgsIHksIHVwZGF0ZXN0YXJ0KSA9PiB7XG4gICAgICB0b3AgPSBNYXRoLm1pbih5LCB0b3ApO1xuICAgICAgbGVmdCA9IE1hdGgubWluKHgsIGxlZnQpO1xuICAgICAgcmlnaHQgPSBNYXRoLm1heCh4LCByaWdodCk7XG4gICAgICBib3QgPSBNYXRoLm1heCh5LCBib3QpO1xuICAgICAgaWYgKHVwZGF0ZXN0YXJ0KSB7XG4gICAgICAgIFtzeCwgc3ldID0gW3gsIHldO1xuICAgICAgfVxuICAgIH07XG4gICAgbGV0IHBpID0gMDtcbiAgICBmb3IgKGNvbnN0IGNvbW1hbmQgb2YgY29tbWFuZHMpIHtcbiAgICAgIHN3aXRjaCAoY29tbWFuZCkge1xuICAgICAgICBjYXNlIDAgLyogTW92ZSAqLzpcbiAgICAgICAgICBqb2luUG9pbnQocGFyYW1zW3BpKytdLCBwYXJhbXNbcGkrK10sIHRydWUpO1xuICAgICAgICAgIFtteCwgbXldID0gW3N4LCBzeV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMSAvKiBMaW5lICovOlxuICAgICAgICAgIGpvaW5Qb2ludChwYXJhbXNbcGkrK10sIHBhcmFtc1twaSsrXSwgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMyAvKiBDdXJ2ZSAqLzoge1xuICAgICAgICAgIGNvbnN0IGNwMXggPSBwYXJhbXNbcGkrK107XG4gICAgICAgICAgY29uc3QgY3AxeSA9IHBhcmFtc1twaSsrXTtcbiAgICAgICAgICBjb25zdCBjcDJ4ID0gcGFyYW1zW3BpKytdO1xuICAgICAgICAgIGNvbnN0IGNwMnkgPSBwYXJhbXNbcGkrK107XG4gICAgICAgICAgY29uc3QgeCA9IHBhcmFtc1twaSsrXTtcbiAgICAgICAgICBjb25zdCB5ID0gcGFyYW1zW3BpKytdO1xuICAgICAgICAgIGpvaW5Qb2ludCh4LCB5LCB0cnVlKTtcbiAgICAgICAgICBjb25zdCBUcyA9IGNhbGN1bGF0ZURlcml2YXRpdmVFeHRyZW1hWFkoc3gsIHN5LCBjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCB4LCB5KTtcbiAgICAgICAgICBUcy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBweCA9IGV2YWx1YXRlQmV6aWVyKHN4LCBjcDF4LCBjcDJ4LCB4LCB0KTtcbiAgICAgICAgICAgIGNvbnN0IHB5ID0gZXZhbHVhdGVCZXppZXIoc3ksIGNwMXksIGNwMnksIHksIHQpO1xuICAgICAgICAgICAgam9pblBvaW50KHB4LCBweSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAyIC8qIEFyYyAqLzoge1xuICAgICAgICAgIGNvbnN0IGN4ID0gcGFyYW1zW3BpKytdO1xuICAgICAgICAgIGNvbnN0IGN5ID0gcGFyYW1zW3BpKytdO1xuICAgICAgICAgIGNvbnN0IHIgPSBwYXJhbXNbcGkrK107XG4gICAgICAgICAgbGV0IEEwID0gbm9ybWFsaXplQW5nbGUzNjAocGFyYW1zW3BpKytdKTtcbiAgICAgICAgICBsZXQgQTEgPSBub3JtYWxpemVBbmdsZTM2MChwYXJhbXNbcGkrK10pO1xuICAgICAgICAgIGNvbnN0IGNjdyA9IHBhcmFtc1twaSsrXTtcbiAgICAgICAgICBpZiAoY2N3KSB7XG4gICAgICAgICAgICBbQTAsIEExXSA9IFtBMSwgQTBdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBqb2luQW5nbGUgPSAoYW5nbGUyLCB1cGRhdGVzdGFydCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHggPSBjeCArIHIgKiBNYXRoLmNvcyhhbmdsZTIpO1xuICAgICAgICAgICAgY29uc3QgcHkgPSBjeSArIHIgKiBNYXRoLnNpbihhbmdsZTIpO1xuICAgICAgICAgICAgam9pblBvaW50KHB4LCBweSwgdXBkYXRlc3RhcnQpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgam9pbkFuZ2xlKEEwKTtcbiAgICAgICAgICBqb2luQW5nbGUoQTEsIHRydWUpO1xuICAgICAgICAgIGNvbnN0IGNyaXRpY2FsQW5nbGVzID0gWzAsIE1hdGguUEkgLyAyLCBNYXRoLlBJLCAzICogTWF0aC5QSSAvIDJdO1xuICAgICAgICAgIGZvciAoY29uc3QgY3JpdCBvZiBjcml0aWNhbEFuZ2xlcykge1xuICAgICAgICAgICAgaWYgKEEwIDwgQTEgJiYgQTAgPD0gY3JpdCAmJiBjcml0IDw9IEExIHx8IEEwID4gQTEgJiYgKEEwIDw9IGNyaXQgfHwgY3JpdCA8PSBBMSkpIHtcbiAgICAgICAgICAgICAgam9pbkFuZ2xlKGNyaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDQgLyogQ2xvc2VQYXRoICovOlxuICAgICAgICAgIFtzeCwgc3ldID0gW214LCBteV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgQkJveChsZWZ0LCB0b3AsIHJpZ2h0IC0gbGVmdCwgYm90IC0gdG9wKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvc2hhcGUvcGF0aC50c1xuZnVuY3Rpb24gU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKG9wdHMpIHtcbiAgY29uc3QgeyByZWRyYXcgPSAzIC8qIE1BSk9SICovLCBjaGFuZ2VDYiwgY29udmVydG9yIH0gPSBvcHRzID8/IHt9O1xuICByZXR1cm4gU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXcsIHR5cGU6IFwicGF0aFwiLCBjb252ZXJ0b3IsIGNoYW5nZUNiIH0pO1xufVxudmFyIFBhdGggPSBjbGFzcyBleHRlbmRzIFNoYXBlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAvKipcbiAgICAgKiBEZWNsYXJlIGEgcGF0aCB0byByZXRhaW4gZm9yIGxhdGVyIHJlbmRlcmluZyBhbmQgaGl0IHRlc3RpbmdcbiAgICAgKiB1c2luZyBjdXN0b20gUGF0aDJEIGNsYXNzLiBUaGluayBvZiBpdCBhcyBhIFR5cGVTY3JpcHQgdmVyc2lvblxuICAgICAqIG9mIHRoZSBuYXRpdmUgUGF0aDJEICh3aXRoIHNvbWUgZGlmZmVyZW5jZXMpIHRoYXQgd29ya3MgaW4gYWxsIGJyb3dzZXJzLlxuICAgICAqL1xuICAgIHRoaXMucGF0aCA9IG5ldyBFeHRlbmRlZFBhdGgyRCgpO1xuICAgIHRoaXMuX2NsaXBYID0gTmFOO1xuICAgIHRoaXMuX2NsaXBZID0gTmFOO1xuICAgIHRoaXMuY2xpcCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIFRoZSBwYXRoIG9ubHkgaGFzIHRvIGJlIHVwZGF0ZWQgd2hlbiBjZXJ0YWluIGF0dHJpYnV0ZXMgY2hhbmdlLlxuICAgICAqIEZvciBleGFtcGxlLCBpZiB0cmFuc2Zvcm0gYXR0cmlidXRlcyAoc3VjaCBhcyBgdHJhbnNsYXRpb25YYClcbiAgICAgKiBhcmUgY2hhbmdlZCwgd2UgZG9uJ3QgaGF2ZSB0byB1cGRhdGUgdGhlIHBhdGguIFRoZSBgZGlydHlQYXRoYCBmbGFnXG4gICAgICogaXMgaG93IHdlIGtlZXAgdHJhY2sgaWYgdGhlIHBhdGggaGFzIHRvIGJlIHVwZGF0ZWQgb3Igbm90LlxuICAgICAqL1xuICAgIHRoaXMuX2RpcnR5UGF0aCA9IHRydWU7XG4gIH1cbiAgc2V0IGNsaXBYKHZhbHVlKSB7XG4gICAgdGhpcy5fY2xpcFggPSB2YWx1ZTtcbiAgICB0aGlzLmRpcnR5UGF0aCA9IHRydWU7XG4gIH1cbiAgc2V0IGNsaXBZKHZhbHVlKSB7XG4gICAgdGhpcy5fY2xpcFkgPSB2YWx1ZTtcbiAgICB0aGlzLmRpcnR5UGF0aCA9IHRydWU7XG4gIH1cbiAgc2V0IGRpcnR5UGF0aCh2YWx1ZSkge1xuICAgIGlmICh0aGlzLl9kaXJ0eVBhdGggIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLl9kaXJ0eVBhdGggPSB2YWx1ZTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgzIC8qIE1BSk9SICovKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0IGRpcnR5UGF0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGlydHlQYXRoO1xuICB9XG4gIGNoZWNrUGF0aERpcnR5KCkge1xuICAgIGlmICh0aGlzLl9kaXJ0eVBhdGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kaXJ0eVBhdGggPSB0aGlzLnBhdGguaXNEaXJ0eSgpIHx8ICh0aGlzLmZpbGxTaGFkb3c/LmlzRGlydHkoKSA/PyBmYWxzZSkgfHwgKHRoaXMuX2NsaXBQYXRoPy5pc0RpcnR5KCkgPz8gZmFsc2UpO1xuICB9XG4gIGlzUG9pbnRJblBhdGgoeCwgeSkge1xuICAgIHRoaXMudXBkYXRlUGF0aElmRGlydHkoKTtcbiAgICByZXR1cm4gdGhpcy5wYXRoLmNsb3NlZFBhdGggJiYgdGhpcy5wYXRoLmlzUG9pbnRJblBhdGgoeCwgeSk7XG4gIH1cbiAgZGlzdGFuY2VTcXVhcmVkKHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy5kaXN0YW5jZVNxdWFyZWRUcmFuc2Zvcm1lZFBvaW50KHgsIHkpO1xuICB9XG4gIHN2Z1BhdGhEYXRhKHRyYW5zZm9ybSkge1xuICAgIGlmICh0aGlzLmRpcnR5UGF0aCkge1xuICAgICAgdGhpcy51cGRhdGVQYXRoKCk7XG4gICAgICB0aGlzLmRpcnR5UGF0aCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYXRoLnRvU1ZHKHRyYW5zZm9ybSk7XG4gIH1cbiAgZGlzdGFuY2VTcXVhcmVkVHJhbnNmb3JtZWRQb2ludCh4LCB5KSB7XG4gICAgdGhpcy51cGRhdGVQYXRoSWZEaXJ0eSgpO1xuICAgIGlmICh0aGlzLnBhdGguY2xvc2VkUGF0aCAmJiB0aGlzLnBhdGguaXNQb2ludEluUGF0aCh4LCB5KSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhdGguZGlzdGFuY2VTcXVhcmVkKHgsIHkpO1xuICB9XG4gIGlzRGlydHlQYXRoKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB1cGRhdGVQYXRoKCkge1xuICB9XG4gIHVwZGF0ZVBhdGhJZkRpcnR5KCkge1xuICAgIGlmICh0aGlzLmRpcnR5UGF0aCB8fCB0aGlzLmlzRGlydHlQYXRoKCkpIHtcbiAgICAgIHRoaXMudXBkYXRlUGF0aCgpO1xuICAgICAgdGhpcy5kaXJ0eVBhdGggPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcHJlUmVuZGVyKCkge1xuICAgIHRoaXMudXBkYXRlUGF0aElmRGlydHkoKTtcbiAgICByZXR1cm4gc3VwZXIucHJlUmVuZGVyKCk7XG4gIH1cbiAgcmVuZGVyKHJlbmRlckN0eCkge1xuICAgIGNvbnN0IHsgY3R4LCBmb3JjZVJlbmRlciwgc3RhdHMgfSA9IHJlbmRlckN0eDtcbiAgICBpZiAodGhpcy5kaXJ0eSA9PT0gMCAvKiBOT05FICovICYmICFmb3JjZVJlbmRlcikge1xuICAgICAgaWYgKHN0YXRzKVxuICAgICAgICBzdGF0cy5ub2Rlc1NraXBwZWQgKz0gbm9kZUNvdW50KHRoaXMpLmNvdW50O1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5jbGlwICYmICFpc05hTih0aGlzLl9jbGlwWCkgJiYgIWlzTmFOKHRoaXMuX2NsaXBZKSkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGNvbnN0IG1hcmdpbiA9IHRoaXMuc3Ryb2tlV2lkdGggLyAyO1xuICAgICAgdGhpcy5fY2xpcFBhdGggPz8gKHRoaXMuX2NsaXBQYXRoID0gbmV3IEV4dGVuZGVkUGF0aDJEKCkpO1xuICAgICAgdGhpcy5fY2xpcFBhdGguY2xlYXIoKTtcbiAgICAgIHRoaXMuX2NsaXBQYXRoLnJlY3QoLW1hcmdpbiwgLW1hcmdpbiwgdGhpcy5fY2xpcFggKyBtYXJnaW4sIHRoaXMuX2NsaXBZICsgbWFyZ2luICsgbWFyZ2luKTtcbiAgICAgIGN0eC5jbGlwKHRoaXMuX2NsaXBQYXRoPy5nZXRQYXRoMkQoKSk7XG4gICAgICBpZiAodGhpcy5fY2xpcFggPiAwICYmIHRoaXMuX2NsaXBZID4gMCkge1xuICAgICAgICB0aGlzLmRyYXdQYXRoKGN0eCk7XG4gICAgICB9XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9jbGlwUGF0aCA9IHZvaWQgMDtcbiAgICAgIHRoaXMuZHJhd1BhdGgoY3R4KTtcbiAgICB9XG4gICAgdGhpcy5maWxsU2hhZG93Py5tYXJrQ2xlYW4oKTtcbiAgICBzdXBlci5yZW5kZXIocmVuZGVyQ3R4KTtcbiAgfVxuICBkcmF3UGF0aChjdHgpIHtcbiAgICB0aGlzLmZpbGxTdHJva2UoY3R4LCB0aGlzLnBhdGguZ2V0UGF0aDJEKCkpO1xuICB9XG4gIHRvU1ZHKCkge1xuICAgIGlmICghdGhpcy52aXNpYmxlKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGVsZW1lbnQyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJwYXRoXCIpO1xuICAgIGVsZW1lbnQyLnNldEF0dHJpYnV0ZShcImRcIiwgdGhpcy5zdmdQYXRoRGF0YSgpKTtcbiAgICBlbGVtZW50Mi5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIHR5cGVvZiB0aGlzLmZpbGwgPT09IFwic3RyaW5nXCIgPyB0aGlzLmZpbGwgOiBcIm5vbmVcIik7XG4gICAgZWxlbWVudDIuc2V0QXR0cmlidXRlKFwiZmlsbC1vcGFjaXR5XCIsIFN0cmluZyh0aGlzLmZpbGxPcGFjaXR5KSk7XG4gICAgaWYgKHRoaXMuc3Ryb2tlICE9IG51bGwpIHtcbiAgICAgIGVsZW1lbnQyLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCB0aGlzLnN0cm9rZSk7XG4gICAgICBlbGVtZW50Mi5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utb3BhY2l0eVwiLCBTdHJpbmcodGhpcy5zdHJva2VPcGFjaXR5KSk7XG4gICAgICBlbGVtZW50Mi5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgU3RyaW5nKHRoaXMuc3Ryb2tlV2lkdGgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGVsZW1lbnRzOiBbZWxlbWVudDJdXG4gICAgfTtcbiAgfVxufTtcblBhdGguY2xhc3NOYW1lID0gXCJQYXRoXCI7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgUGF0aC5wcm90b3R5cGUsIFwiY2xpcFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBQYXRoLnByb3RvdHlwZSwgXCJjbGlwWFwiLCAxKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBQYXRoLnByb3RvdHlwZSwgXCJjbGlwWVwiLCAxKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvZG9tL2ZvY3VzSW5kaWNhdG9yLnRzXG52YXIgRk9DVVNfSU5ESUNBVE9SX0NTU19DTEFTUyA9IFwiYWctY2hhcnRzLWZvY3VzLWluZGljYXRvclwiO1xudmFyIEZvY3VzSW5kaWNhdG9yID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihkb21NYW5hZ2VyKSB7XG4gICAgdGhpcy5kb21NYW5hZ2VyID0gZG9tTWFuYWdlcjtcbiAgICB0aGlzLmRpdiA9IGdldERvY3VtZW50KCkuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLnN2ZyA9IGdldERvY3VtZW50KCkuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJzdmdcIik7XG4gICAgdGhpcy5wYXRoID0gZ2V0RG9jdW1lbnQoKS5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcInBhdGhcIik7XG4gICAgdGhpcy5zdmcuYXBwZW5kKHRoaXMucGF0aCk7XG4gICAgdGhpcy5lbGVtZW50ID0gZG9tTWFuYWdlci5hZGRDaGlsZChcInNlcmllcy1hcmVhXCIsIEZPQ1VTX0lORElDQVRPUl9DU1NfQ0xBU1MpO1xuICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKEZPQ1VTX0lORElDQVRPUl9DU1NfQ0xBU1MpO1xuICAgIHRoaXMuZWxlbWVudC5hcmlhSGlkZGVuID0gXCJ0cnVlXCI7XG4gICAgdGhpcy5lbGVtZW50LmFwcGVuZCh0aGlzLnN2Zyk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRvbU1hbmFnZXIucmVtb3ZlU3R5bGVzKEZPQ1VTX0lORElDQVRPUl9DU1NfQ0xBU1MpO1xuICAgIHRoaXMuZG9tTWFuYWdlci5yZW1vdmVDaGlsZChcInNlcmllcy1hcmVhXCIsIEZPQ1VTX0lORElDQVRPUl9DU1NfQ0xBU1MpO1xuICB9XG4gIHVwZGF0ZUJvdW5kcyhib3VuZHMpIHtcbiAgICBpZiAoYm91bmRzID09PSB2b2lkIDApIHtcbiAgICB9IGVsc2UgaWYgKGJvdW5kcyBpbnN0YW5jZW9mIFBhdGgpIHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9ICh4LCB5KSA9PiBUcmFuc2Zvcm1hYmxlLnRvQ2FudmFzUG9pbnQoYm91bmRzLCB4LCB5KTtcbiAgICAgIHRoaXMucGF0aC5zZXRBdHRyaWJ1dGUoXCJkXCIsIGJvdW5kcy5zdmdQYXRoRGF0YSh0cmFuc2Zvcm0pKTtcbiAgICAgIHRoaXMuc2hvdyh0aGlzLnN2Zyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldEVsZW1lbnRCQm94KHRoaXMuZGl2LCBib3VuZHMpO1xuICAgICAgdGhpcy5zaG93KHRoaXMuZGl2KTtcbiAgICB9XG4gIH1cbiAgc2hvdyhjaGlsZCkge1xuICAgIHRoaXMuZWxlbWVudC5pbm5lckhUTUwgPSBcIlwiO1xuICAgIHRoaXMuZWxlbWVudC5hcHBlbmQoY2hpbGQpO1xuICB9XG4gIGdldEZvY3VzYWJsZUVsZW1lbnQoKSB7XG4gICAgY29uc3QgZm9jdXNhYmxlID0gdGhpcy5lbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgaWYgKGZvY3VzYWJsZSA9PSBudWxsIHx8IGZvY3VzYWJsZS50YWJJbmRleCAhPT0gMCAmJiBmb2N1c2FibGUudGFiSW5kZXggIT09IC0xKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQUcgQ2hhcnRzIC0gdGhlIGZvY3VzIGluZGljYXRvciBtdXN0IGJlIGEgY2hpbGQgb2YgYSBmb2N1c2FibGUgZWxlbWVudFwiKTtcbiAgICByZXR1cm4gZm9jdXNhYmxlO1xuICB9XG4gIC8vIFVzZSB3aXRoIGNhdXRpb24hIFRoZSBmb2N1cyBtdXN0IGJlIHZpc2libGUgd2hlbiB1c2luZyB0aGUga2V5Ym9hcmQuXG4gIG92ZXJyaWRlRm9jdXNWaXNpYmxlKGZvY3VzVmlzaWJsZSkge1xuICAgIGNvbnN0IG9wYWNpdHkgPSB7IHRydWU6IFwiMVwiLCBmYWxzZTogXCIwXCIsIHVuZGVmaW5lZDogXCJcIiB9O1xuICAgIHRoaXMuZ2V0Rm9jdXNhYmxlRWxlbWVudCgpLnN0eWxlLnNldFByb3BlcnR5KFwib3BhY2l0eVwiLCBvcGFjaXR5W2Ake2ZvY3VzVmlzaWJsZX1gXSk7XG4gIH1cbiAgLy8gR2V0IHRoZSBgOmZvY3VzLXZpc2libGVgIENTUyBzdGF0ZS5cbiAgaXNGb2N1c1Zpc2libGUoKSB7XG4gICAgY29uc3QgZm9jdXNhYmxlID0gdGhpcy5nZXRGb2N1c2FibGVFbGVtZW50KCk7XG4gICAgcmV0dXJuIGZvY3VzYWJsZSAhPSBudWxsICYmIGdldFdpbmRvdygpLmdldENvbXB1dGVkU3R5bGUoZm9jdXNhYmxlKS5vcGFjaXR5ID09PSBcIjFcIjtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvZG9tL2JvdW5kZWRUZXh0LnRzXG52YXIgQm91bmRlZFRleHQgPSBjbGFzcyB7XG4gIHNldCB0ZXh0Q29udGVudCh0ZXh0KSB7XG4gICAgdGhpcy50ZXh0RWxlbWVudC50ZXh0Q29udGVudCA9IHRleHQ7XG4gICAgY29uc3QgYmJveENhbGN1bGF0b3IgPSB0aGlzLnRleHRFbGVtZW50O1xuICAgIGNvbnN0IGJib3ggPSBiYm94Q2FsY3VsYXRvci5nZXRCQm94Py4oKTtcbiAgICBpZiAoYmJveCkge1xuICAgICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZShcInZpZXdCb3hcIiwgYCR7YmJveC54fSAke2Jib3gueX0gJHtiYm94LndpZHRofSAke2Jib3guaGVpZ2h0fWApO1xuICAgIH1cbiAgfVxuICBnZXQgdGV4dENvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dEVsZW1lbnQudGV4dENvbnRlbnQ7XG4gIH1cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy50ZXh0RWxlbWVudCA9IGNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwidGV4dFwiKTtcbiAgICB0aGlzLnRleHRFbGVtZW50LnJvbGUgPSBcInByZXNlbnRhdGlvblwiO1xuICAgIHRoaXMuc3ZnRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwic3ZnXCIpO1xuICAgIHRoaXMuc3ZnRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnRleHRFbGVtZW50KTtcbiAgICB0aGlzLnN2Z0VsZW1lbnQuc3R5bGUud2lkdGggPSBcIjEwMCVcIjtcbiAgICB0aGlzLnN2Z0VsZW1lbnQuc3R5bGUub3BhY2l0eSA9IFwiMFwiO1xuICAgIHRoaXMuc3ZnRWxlbWVudC5yb2xlID0gXCJwcmVzZW50YXRpb25cIjtcbiAgICB0aGlzLmJvdW5kZWRDb250YWluZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRoaXMuYm91bmRlZENvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLnN2Z0VsZW1lbnQpO1xuICAgIHRoaXMuYm91bmRlZENvbnRhaW5lci5yb2xlID0gXCJwcmVzZW50YXRpb25cIjtcbiAgfVxuICByZW1vdmUoKSB7XG4gICAgdGhpcy5ib3VuZGVkQ29udGFpbmVyLnJlbW92ZSgpO1xuICB9XG4gIGdldENvbnRhaW5lcigpIHtcbiAgICByZXR1cm4gdGhpcy5ib3VuZGVkQ29udGFpbmVyO1xuICB9XG4gIHVwZGF0ZUJvdW5kcyhib3VuZHMpIHtcbiAgICBzZXRFbGVtZW50QkJveCh0aGlzLmJvdW5kZWRDb250YWluZXIsIGJvdW5kcyk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2RvbS9wcm94eUludGVyYWN0aW9uU2VydmljZS50c1xuZnVuY3Rpb24gY2hlY2tUeXBlKHR5cGUsIG1ldGEpIHtcbiAgcmV0dXJuIG1ldGEucGFyYW1zPy50eXBlID09PSB0eXBlO1xufVxuZnVuY3Rpb24gYWxsb2NhdGVSZXN1bHQodHlwZSkge1xuICBpZiAoXCJidXR0b25cIiA9PT0gdHlwZSkge1xuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICB9IGVsc2UgaWYgKFwic2xpZGVyXCIgPT09IHR5cGUpIHtcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICB9IGVsc2UgaWYgKFtcInRvb2xiYXJcIiwgXCJncm91cFwiLCBcImxpc3RcIl0uaW5jbHVkZXModHlwZSkpIHtcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgfSBlbHNlIGlmIChcInRleHRcIiA9PT0gdHlwZSkge1xuICAgIHJldHVybiBuZXcgQm91bmRlZFRleHQoKTtcbiAgfSBlbHNlIGlmIChcImxpc3Rzd2l0Y2hcIiA9PT0gdHlwZSkge1xuICAgIHJldHVybiB7IGJ1dHRvbjogY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKSwgbGlzdGl0ZW06IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIikgfTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBFcnJvcihcIkFHIENoYXJ0cyAtIGVycm9yIGFsbG9jYXRpbmcgbWV0YVwiKTtcbiAgfVxufVxuZnVuY3Rpb24gYWxsb2NhdGVNZXRhKHBhcmFtcykge1xuICBjb25zdCBtZXRhID0geyBwYXJhbXMsIHJlc3VsdDogdm9pZCAwIH07XG4gIG1ldGEucmVzdWx0ID0gYWxsb2NhdGVSZXN1bHQobWV0YS5wYXJhbXMudHlwZSk7XG4gIHJldHVybiBtZXRhO1xufVxudmFyIFByb3h5SW50ZXJhY3Rpb25TZXJ2aWNlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihsb2NhbGVNYW5hZ2VyLCBkb21NYW5hZ2VyKSB7XG4gICAgdGhpcy5sb2NhbGVNYW5hZ2VyID0gbG9jYWxlTWFuYWdlcjtcbiAgICB0aGlzLmRvbU1hbmFnZXIgPSBkb21NYW5hZ2VyO1xuICAgIHRoaXMuZGVzdHJveUZucyA9IFtdO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXN0cm95Rm5zLmZvckVhY2goKGZuKSA9PiBmbigpKTtcbiAgfVxuICBhZGRMb2NhbGlzYXRpb24oZm4pIHtcbiAgICBmbigpO1xuICAgIHRoaXMuZGVzdHJveUZucy5wdXNoKHRoaXMubG9jYWxlTWFuYWdlci5hZGRMaXN0ZW5lcihcImxvY2FsZS1jaGFuZ2VkXCIsIGZuKSk7XG4gIH1cbiAgY3JlYXRlUHJveHlDb250YWluZXIoYXJncykge1xuICAgIGNvbnN0IG1ldGEgPSBhbGxvY2F0ZU1ldGEoYXJncyk7XG4gICAgY29uc3QgeyBwYXJhbXMsIHJlc3VsdDogZGl2IH0gPSBtZXRhO1xuICAgIHRoaXMuZG9tTWFuYWdlci5hZGRDaGlsZChcImNhbnZhcy1wcm94eVwiLCBwYXJhbXMuaWQsIGRpdik7XG4gICAgZGl2LmNsYXNzTGlzdC5hZGQoLi4ucGFyYW1zLmNsYXNzTGlzdCwgXCJhZy1jaGFydHMtcHJveHktY29udGFpbmVyXCIpO1xuICAgIGRpdi5yb2xlID0gcGFyYW1zLnR5cGU7XG4gICAgaWYgKFwiYXJpYU9yaWVudGF0aW9uXCIgaW4gcGFyYW1zKSB7XG4gICAgICBkaXYuYXJpYU9yaWVudGF0aW9uID0gcGFyYW1zLmFyaWFPcmllbnRhdGlvbjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMuYXJpYUhpZGRlbiA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIGRpdi5hcmlhSGlkZGVuID0gcGFyYW1zLmFyaWFIaWRkZW4udG9TdHJpbmcoKTtcbiAgICB9XG4gICAgdGhpcy5hZGRMb2NhbGlzYXRpb24oKCkgPT4ge1xuICAgICAgZGl2LmFyaWFMYWJlbCA9IHRoaXMubG9jYWxlTWFuYWdlci50KHBhcmFtcy5hcmlhTGFiZWwuaWQsIHBhcmFtcy5hcmlhTGFiZWwucGFyYW1zKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZGl2O1xuICB9XG4gIGNyZWF0ZVByb3h5RWxlbWVudChhcmdzKSB7XG4gICAgY29uc3QgbWV0YSA9IGFsbG9jYXRlTWV0YShhcmdzKTtcbiAgICBpZiAoY2hlY2tUeXBlKFwiYnV0dG9uXCIsIG1ldGEpKSB7XG4gICAgICBjb25zdCB7IHBhcmFtcywgcmVzdWx0OiBidXR0b24gfSA9IG1ldGE7XG4gICAgICB0aGlzLmluaXRJbnRlcmFjdChwYXJhbXMsIGJ1dHRvbik7XG4gICAgICBidXR0b24uc3R5bGUucG9pbnRlckV2ZW50cyA9IFwiYXV0b1wiO1xuICAgICAgaWYgKHR5cGVvZiBwYXJhbXMudGV4dENvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgYnV0dG9uLnRleHRDb250ZW50ID0gcGFyYW1zLnRleHRDb250ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgeyB0ZXh0Q29udGVudCB9ID0gcGFyYW1zO1xuICAgICAgICB0aGlzLmFkZExvY2FsaXNhdGlvbigoKSA9PiB7XG4gICAgICAgICAgYnV0dG9uLnRleHRDb250ZW50ID0gdGhpcy5sb2NhbGVNYW5hZ2VyLnQodGV4dENvbnRlbnQuaWQsIHRleHRDb250ZW50LnBhcmFtcyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRQYXJlbnQocGFyYW1zLCBidXR0b24pO1xuICAgIH1cbiAgICBpZiAoY2hlY2tUeXBlKFwic2xpZGVyXCIsIG1ldGEpKSB7XG4gICAgICBjb25zdCB7IHBhcmFtcywgcmVzdWx0OiBzbGlkZXIgfSA9IG1ldGE7XG4gICAgICB0aGlzLmluaXRJbnRlcmFjdChwYXJhbXMsIHNsaWRlcik7XG4gICAgICBzbGlkZXIudHlwZSA9IFwicmFuZ2VcIjtcbiAgICAgIHNsaWRlci5yb2xlID0gXCJwcmVzZW50YXRpb25cIjtcbiAgICAgIHNsaWRlci5zdHlsZS5tYXJnaW4gPSBcIjBweFwiO1xuICAgICAgc2xpZGVyLmFyaWFPcmllbnRhdGlvbiA9IHBhcmFtcy5hcmlhT3JpZW50YXRpb247XG4gICAgICB0aGlzLmFkZExvY2FsaXNhdGlvbigoKSA9PiB7XG4gICAgICAgIHNsaWRlci5hcmlhTGFiZWwgPSB0aGlzLmxvY2FsZU1hbmFnZXIudChwYXJhbXMuYXJpYUxhYmVsLmlkLCBwYXJhbXMuYXJpYUxhYmVsLnBhcmFtcyk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2V0UGFyZW50KHBhcmFtcywgc2xpZGVyKTtcbiAgICB9XG4gICAgaWYgKGNoZWNrVHlwZShcInRleHRcIiwgbWV0YSkpIHtcbiAgICAgIGNvbnN0IHsgcGFyYW1zLCByZXN1bHQ6IHRleHQgfSA9IG1ldGE7XG4gICAgICB0aGlzLmluaXRFbGVtZW50KHBhcmFtcywgdGV4dC5nZXRDb250YWluZXIoKSk7XG4gICAgICB0aGlzLnNldFBhcmVudChwYXJhbXMsIHRleHQuZ2V0Q29udGFpbmVyKCkpO1xuICAgIH1cbiAgICBpZiAoY2hlY2tUeXBlKFwibGlzdHN3aXRjaFwiLCBtZXRhKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBwYXJhbXMsXG4gICAgICAgIHJlc3VsdDogeyBidXR0b24sIGxpc3RpdGVtIH1cbiAgICAgIH0gPSBtZXRhO1xuICAgICAgdGhpcy5pbml0SW50ZXJhY3QocGFyYW1zLCBidXR0b24pO1xuICAgICAgYnV0dG9uLnN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG4gICAgICBidXR0b24uc3R5bGUuaGVpZ2h0ID0gXCIxMDAlXCI7XG4gICAgICBidXR0b24udGV4dENvbnRlbnQgPSBwYXJhbXMudGV4dENvbnRlbnQ7XG4gICAgICBidXR0b24ucm9sZSA9IFwic3dpdGNoXCI7XG4gICAgICBidXR0b24uYXJpYUNoZWNrZWQgPSBwYXJhbXMuYXJpYUNoZWNrZWQudG9TdHJpbmcoKTtcbiAgICAgIGJ1dHRvbi5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJhdXRvXCI7XG4gICAgICBidXR0b24uc2V0QXR0cmlidXRlKFwiYXJpYS1kZXNjcmliZWRieVwiLCBwYXJhbXMuYXJpYURlc2NyaWJlZEJ5KTtcbiAgICAgIGxpc3RpdGVtLnJvbGUgPSBcImxpc3RpdGVtXCI7XG4gICAgICBsaXN0aXRlbS5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgIGxpc3RpdGVtLnJlcGxhY2VDaGlsZHJlbihidXR0b24pO1xuICAgICAgdGhpcy5zZXRQYXJlbnQocGFyYW1zLCBsaXN0aXRlbSk7XG4gICAgfVxuICAgIHJldHVybiBtZXRhLnJlc3VsdDtcbiAgfVxuICBpbml0RWxlbWVudChwYXJhbXMsIGVsZW1lbnQyKSB7XG4gICAgY29uc3QgeyBpZCB9ID0gcGFyYW1zO1xuICAgIGVsZW1lbnQyLmlkID0gaWQ7XG4gICAgZWxlbWVudDIuY2xhc3NMaXN0LnRvZ2dsZShcImFnLWNoYXJ0cy1wcm94eS1lbGVtXCIsIHRydWUpO1xuICB9XG4gIGluaXRJbnRlcmFjdChwYXJhbXMsIGVsZW1lbnQyKSB7XG4gICAgY29uc3QgeyBvbmNsaWNrLCBvbmRibGNsaWNrLCBvbm1vdXNlZW50ZXIsIG9ubW91c2VsZWF2ZSwgb25jb250ZXh0bWVudSwgb25jaGFuZ2UsIG9uZm9jdXMsIG9uYmx1ciwgdGFiSW5kZXggfSA9IHBhcmFtcztcbiAgICB0aGlzLmluaXRFbGVtZW50KHBhcmFtcywgZWxlbWVudDIpO1xuICAgIGlmICh0YWJJbmRleCAhPT0gdm9pZCAwKSB7XG4gICAgICBlbGVtZW50Mi50YWJJbmRleCA9IHRhYkluZGV4O1xuICAgIH1cbiAgICBpZiAob25jbGljaykge1xuICAgICAgZWxlbWVudDIuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIG9uY2xpY2spO1xuICAgIH1cbiAgICBpZiAob25kYmxjbGljaykge1xuICAgICAgZWxlbWVudDIuYWRkRXZlbnRMaXN0ZW5lcihcImRibGNsaWNrXCIsIG9uZGJsY2xpY2spO1xuICAgIH1cbiAgICBpZiAob25tb3VzZWVudGVyKSB7XG4gICAgICBlbGVtZW50Mi5hZGRFdmVudExpc3RlbmVyKFwibW91c2VlbnRlclwiLCBvbm1vdXNlZW50ZXIpO1xuICAgIH1cbiAgICBpZiAob25tb3VzZWxlYXZlKSB7XG4gICAgICBlbGVtZW50Mi5hZGRFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCBvbm1vdXNlbGVhdmUpO1xuICAgIH1cbiAgICBpZiAob25jb250ZXh0bWVudSkge1xuICAgICAgZWxlbWVudDIuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIG9uY29udGV4dG1lbnUpO1xuICAgIH1cbiAgICBpZiAob25mb2N1cykge1xuICAgICAgZWxlbWVudDIuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIG9uZm9jdXMpO1xuICAgIH1cbiAgICBpZiAob25ibHVyKSB7XG4gICAgICBlbGVtZW50Mi5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBvbmJsdXIpO1xuICAgIH1cbiAgICBpZiAob25jaGFuZ2UpIHtcbiAgICAgIGVsZW1lbnQyLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgb25jaGFuZ2UpO1xuICAgIH1cbiAgfVxuICBzZXRQYXJlbnQocGFyYW1zLCBlbGVtZW50Mikge1xuICAgIGNvbnN0IHsgaWQsIHBhcmVudCB9ID0gcGFyYW1zO1xuICAgIGlmICh0eXBlb2YgcGFyZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb25zdCBpbnNlcnQgPSB7IHdoZXJlOiBwYXJlbnQsIHF1ZXJ5OiBcIi5hZy1jaGFydHMtc2VyaWVzLWFyZWFcIiB9O1xuICAgICAgdGhpcy5kb21NYW5hZ2VyLmFkZENoaWxkKFwiY2FudmFzLXByb3h5XCIsIGlkLCBlbGVtZW50MiwgaW5zZXJ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGVsZW1lbnQyKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2xvY2FsZS9kZWZhdWx0TWVzc2FnZUZvcm1hdHRlci50c1xudmFyIG1lc3NhZ2VSZWdFeHAgPSAvXFwkXFx7KFxcdyspfSg/OlxcWyhcXHcrKV0pPy9naTtcbnZhciBmb3JtYXR0ZXJzID0ge1xuICBudW1iZXI6IG5ldyBJbnRsLk51bWJlckZvcm1hdChcImVuLVVTXCIpLFxuICBwZXJjZW50OiBuZXcgSW50bC5OdW1iZXJGb3JtYXQoXCJlbi1VU1wiLCB7IHN0eWxlOiBcInBlcmNlbnRcIiwgbWluaW11bUZyYWN0aW9uRGlnaXRzOiAyLCBtYXhpbXVtRnJhY3Rpb25EaWdpdHM6IDIgfSksXG4gIGRhdGU6IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KFwiZW4tVVNcIiwgeyBkYXRlU3R5bGU6IFwiZnVsbFwiIH0pLFxuICB0aW1lOiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChcImVuLVVTXCIsIHsgdGltZVN0eWxlOiBcImZ1bGxcIiB9KSxcbiAgZGF0ZXRpbWU6IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KFwiZW4tVVNcIiwgeyBkYXRlU3R5bGU6IFwiZnVsbFwiLCB0aW1lU3R5bGU6IFwiZnVsbFwiIH0pXG59O1xudmFyIGRlZmF1bHRNZXNzYWdlRm9ybWF0dGVyID0gKHsgZGVmYXVsdFZhbHVlLCB2YXJpYWJsZXMgfSkgPT4ge1xuICByZXR1cm4gZGVmYXVsdFZhbHVlPy5yZXBsYWNlQWxsKG1lc3NhZ2VSZWdFeHAsIChfLCBtYXRjaCwgZm9ybWF0KSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSB2YXJpYWJsZXNbbWF0Y2hdO1xuICAgIGNvbnN0IGZvcm1hdHRlciA9IGZvcm1hdCAhPSBudWxsID8gZm9ybWF0dGVyc1tmb3JtYXRdIDogbnVsbDtcbiAgICBpZiAoZm9ybWF0ICE9IG51bGwgJiYgZm9ybWF0dGVyID09IG51bGwpIHtcbiAgICAgIExvZ2dlci53YXJuT25jZShgRm9ybWF0IHN0eWxlIFske2Zvcm1hdH1dIGlzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgICB9XG4gICAgaWYgKGZvcm1hdHRlciAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdCh2YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiBmb3JtYXR0ZXJzLm51bWJlci5mb3JtYXQodmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICByZXR1cm4gZm9ybWF0dGVycy5kYXRldGltZS5mb3JtYXQodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgfSk7XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9sb2NhbGUvbG9jYWxlTWFuYWdlci50c1xudmFyIExvY2FsZU1hbmFnZXIgPSBjbGFzcyBleHRlbmRzIExpc3RlbmVycyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5sb2NhbGVUZXh0ID0gdm9pZCAwO1xuICAgIHRoaXMuZ2V0TG9jYWxlVGV4dCA9IHZvaWQgMDtcbiAgfVxuICBzZXRMb2NhbGVUZXh0KGxvY2FsZVRleHQpIHtcbiAgICBpZiAodGhpcy5sb2NhbGVUZXh0ICE9PSBsb2NhbGVUZXh0KSB7XG4gICAgICB0aGlzLmxvY2FsZVRleHQgPSBsb2NhbGVUZXh0O1xuICAgICAgdGhpcy5kaXNwYXRjaChcImxvY2FsZS1jaGFuZ2VkXCIpO1xuICAgIH1cbiAgfVxuICBzZXRMb2NhbGVUZXh0Rm9ybWF0dGVyKGdldExvY2FsZVRleHQpIHtcbiAgICB0aGlzLmdldExvY2FsZVRleHQgPSBnZXRMb2NhbGVUZXh0O1xuICAgIGlmICh0aGlzLmdldExvY2FsZVRleHQgIT09IGdldExvY2FsZVRleHQpIHtcbiAgICAgIHRoaXMuZ2V0TG9jYWxlVGV4dCA9IGdldExvY2FsZVRleHQ7XG4gICAgICB0aGlzLmRpc3BhdGNoKFwibG9jYWxlLWNoYW5nZWRcIik7XG4gICAgfVxuICB9XG4gIHQoa2V5LCB2YXJpYWJsZXMgPSB7fSkge1xuICAgIGNvbnN0IHsgbG9jYWxlVGV4dCA9IEFHX0NIQVJUU19MT0NBTEVfRU5fVVMsIGdldExvY2FsZVRleHQgfSA9IHRoaXM7XG4gICAgY29uc3QgZGVmYXVsdFZhbHVlID0gbG9jYWxlVGV4dFtrZXldO1xuICAgIHJldHVybiBnZXRMb2NhbGVUZXh0Py4oeyBrZXksIGRlZmF1bHRWYWx1ZSwgdmFyaWFibGVzIH0pID8/IGRlZmF1bHRNZXNzYWdlRm9ybWF0dGVyKHsga2V5LCBkZWZhdWx0VmFsdWUsIHZhcmlhYmxlcyB9KSA/PyBrZXk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvdXNlckFnZW50LnRzXG5mdW5jdGlvbiBoYXNDb25zdHJhaW5lZENhbnZhc01lbW9yeSgpIHtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgaVBob25lT1NNYXRjaCA9IC9cXChpUGhvbmU7IENQVSBpUGhvbmUgT1MgKFxcZCtfXFxkK19cXGQrKSBsaWtlIE1hYyBPUyBYXFwpLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICBpZiAoaVBob25lT1NNYXRjaCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IFttYWpvciwgbWlub3JdID0gaVBob25lT1NNYXRjaFsxXS5zcGxpdChcIl9cIikubWFwKE51bWJlcik7XG4gIHJldHVybiBtYWpvciA8IDE2IHx8IG1ham9yID09PSAxNiAmJiBtaW5vciA8IDY7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL2NhbnZhcy9oZHBpQ2FudmFzLnRzXG52YXIgX0hkcGlDYW52YXMgPSBjbGFzcyBfSGRwaUNhbnZhcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMud2lkdGggPSA2MDA7XG4gICAgdGhpcy5oZWlnaHQgPSAzMDA7XG4gICAgY29uc3QgeyB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIsIHBpeGVsUmF0aW8sIGNhbnZhc0VsZW1lbnQsIHdpbGxSZWFkRnJlcXVlbnRseSA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICAgIHRoaXMucGl4ZWxSYXRpbyA9IGhhc0NvbnN0cmFpbmVkQ2FudmFzTWVtb3J5KCkgPyAxIDogcGl4ZWxSYXRpbyA/PyBnZXRXaW5kb3coXCJkZXZpY2VQaXhlbFJhdGlvXCIpO1xuICAgIHRoaXMuZWxlbWVudCA9IGNhbnZhc0VsZW1lbnQgPz8gY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICB0aGlzLmVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICB0aGlzLmVsZW1lbnQuc3R5bGUud2lkdGggPSAod2lkdGgyID8/IHRoaXMud2lkdGgpICsgXCJweFwiO1xuICAgIHRoaXMuZWxlbWVudC5zdHlsZS5oZWlnaHQgPSAoaGVpZ2h0MiA/PyB0aGlzLmhlaWdodCkgKyBcInB4XCI7XG4gICAgdGhpcy5lbGVtZW50LndpZHRoID0gTWF0aC5yb3VuZCgod2lkdGgyID8/IHRoaXMud2lkdGgpICogdGhpcy5waXhlbFJhdGlvKTtcbiAgICB0aGlzLmVsZW1lbnQuaGVpZ2h0ID0gTWF0aC5yb3VuZCgoaGVpZ2h0MiA/PyB0aGlzLmhlaWdodCkgKiB0aGlzLnBpeGVsUmF0aW8pO1xuICAgIHRoaXMuY29udGV4dCA9IHRoaXMuZWxlbWVudC5nZXRDb250ZXh0KFwiMmRcIiwgeyB3aWxsUmVhZEZyZXF1ZW50bHkgfSk7XG4gICAgdGhpcy5vbkVuYWJsZWRDaGFuZ2UoKTtcbiAgICB0aGlzLnJlc2l6ZSh3aWR0aDIgPz8gMCwgaGVpZ2h0MiA/PyAwKTtcbiAgICBfSGRwaUNhbnZhcy5kZWJ1Z0NvbnRleHQodGhpcy5jb250ZXh0KTtcbiAgfVxuICBzdGF0aWMgaXModmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBfSGRwaUNhbnZhcztcbiAgfVxuICBkcmF3SW1hZ2UoY29udGV4dCwgZHggPSAwLCBkeSA9IDApIHtcbiAgICByZXR1cm4gY29udGV4dC5kcmF3SW1hZ2UodGhpcy5jb250ZXh0LmNhbnZhcywgZHgsIGR5KTtcbiAgfVxuICB0b0RhdGFVUkwodHlwZSkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnQudG9EYXRhVVJMKHR5cGUpO1xuICB9XG4gIHJlc2l6ZSh3aWR0aDIsIGhlaWdodDIpIHtcbiAgICBpZiAoISh3aWR0aDIgPiAwICYmIGhlaWdodDIgPiAwKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IGVsZW1lbnQ6IGVsZW1lbnQyLCBjb250ZXh0LCBwaXhlbFJhdGlvIH0gPSB0aGlzO1xuICAgIGVsZW1lbnQyLndpZHRoID0gTWF0aC5yb3VuZCh3aWR0aDIgKiBwaXhlbFJhdGlvKTtcbiAgICBlbGVtZW50Mi5oZWlnaHQgPSBNYXRoLnJvdW5kKGhlaWdodDIgKiBwaXhlbFJhdGlvKTtcbiAgICBjb250ZXh0LnNldFRyYW5zZm9ybShwaXhlbFJhdGlvLCAwLCAwLCBwaXhlbFJhdGlvLCAwLCAwKTtcbiAgICBlbGVtZW50Mi5zdHlsZS53aWR0aCA9IHdpZHRoMiArIFwicHhcIjtcbiAgICBlbGVtZW50Mi5zdHlsZS5oZWlnaHQgPSBoZWlnaHQyICsgXCJweFwiO1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDI7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQyO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMuY29udGV4dC5zYXZlKCk7XG4gICAgdGhpcy5jb250ZXh0LnNldFRyYW5zZm9ybSh0aGlzLnBpeGVsUmF0aW8sIDAsIDAsIHRoaXMucGl4ZWxSYXRpbywgMCwgMCk7XG4gICAgdGhpcy5jb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgdGhpcy5jb250ZXh0LnJlc3RvcmUoKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZWxlbWVudC5yZW1vdmUoKTtcbiAgICB0aGlzLmVsZW1lbnQud2lkdGggPSAwO1xuICAgIHRoaXMuZWxlbWVudC5oZWlnaHQgPSAwO1xuICAgIHRoaXMuY29udGV4dC5jbGVhclJlY3QoMCwgMCwgMCwgMCk7XG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgfVxuICBvbkVuYWJsZWRDaGFuZ2UoKSB7XG4gICAgaWYgKHRoaXMuZWxlbWVudCkge1xuICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSB0aGlzLmVuYWJsZWQgPyBcIlwiIDogXCJub25lXCI7XG4gICAgfVxuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVkdW5kYW50LXR5cGUtY29uc3RpdHVlbnRzXG4gIHN0YXRpYyBkZWJ1Z0NvbnRleHQoY3R4KSB7XG4gICAgaWYgKERlYnVnLmNoZWNrKFwiY2FudmFzXCIpKSB7XG4gICAgICBjb25zdCBzYXZlID0gY3R4LnNhdmUuYmluZChjdHgpO1xuICAgICAgY29uc3QgcmVzdG9yZSA9IGN0eC5yZXN0b3JlLmJpbmQoY3R4KTtcbiAgICAgIGxldCBkZXB0aCA9IDA7XG4gICAgICBPYmplY3QuYXNzaWduKGN0eCwge1xuICAgICAgICBzYXZlKCkge1xuICAgICAgICAgIHNhdmUoKTtcbiAgICAgICAgICBkZXB0aCsrO1xuICAgICAgICB9LFxuICAgICAgICByZXN0b3JlKCkge1xuICAgICAgICAgIGlmIChkZXB0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQUcgQ2hhcnRzIC0gVW5hYmxlIHRvIHJlc3RvcmUoKSBwYXN0IGRlcHRoIDBcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3RvcmUoKTtcbiAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICB9LFxuICAgICAgICB2ZXJpZnlEZXB0aFplcm8oKSB7XG4gICAgICAgICAgaWYgKGRlcHRoICE9PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFHIENoYXJ0cyAtIFNhdmUvcmVzdG9yZSBkZXB0aCBpcyBub24temVybzogJHtkZXB0aH1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIE9ic2VydmVDaGFuZ2VzKCh0YXJnZXQpID0+IHRhcmdldC5vbkVuYWJsZWRDaGFuZ2UoKSlcbl0sIF9IZHBpQ2FudmFzLnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIDIpO1xudmFyIEhkcGlDYW52YXMgPSBfSGRwaUNhbnZhcztcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvbGF5ZXJzTWFuYWdlci50c1xudmFyIExheWVyc01hbmFnZXIgPSBjbGFzcyBfTGF5ZXJzTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGNhbnZhcywgbWFya0RpcnR5KSB7XG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgdGhpcy5tYXJrRGlydHkgPSBtYXJrRGlydHk7XG4gICAgdGhpcy5kZWJ1ZyA9IERlYnVnLmNyZWF0ZSh0cnVlLCBcInNjZW5lXCIpO1xuICAgIHRoaXMubGF5ZXJzTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLm5leHRaSW5kZXggPSAwO1xuICAgIHRoaXMubmV4dExheWVySWQgPSAwO1xuICB9XG4gIHN0YXRpYyBzb3J0TGF5ZXJzKGEsIGIpIHtcbiAgICByZXR1cm4gY29tcG91bmRBc2NlbmRpbmcoXG4gICAgICBbYS56SW5kZXgsIC4uLmEuekluZGV4U3ViT3JkZXIgPz8gW3ZvaWQgMCwgdm9pZCAwXSwgYS5pZF0sXG4gICAgICBbYi56SW5kZXgsIC4uLmIuekluZGV4U3ViT3JkZXIgPz8gW3ZvaWQgMCwgdm9pZCAwXSwgYi5pZF0sXG4gICAgICBhc2NlbmRpbmdTdHJpbmdOdW1iZXJVbmRlZmluZWRcbiAgICApO1xuICB9XG4gIGdldCBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLmxheWVyc01hcC5zaXplO1xuICB9XG4gIGZvckVhY2goY2FsbGJhY2syKSB7XG4gICAgQXJyYXkuZnJvbSh0aGlzLmxheWVyc01hcC52YWx1ZXMoKSkuc29ydChfTGF5ZXJzTWFuYWdlci5zb3J0TGF5ZXJzKS5mb3JFYWNoKGNhbGxiYWNrMik7XG4gIH1cbiAgcmVzaXplKHdpZHRoMiwgaGVpZ2h0Mikge1xuICAgIHRoaXMuY2FudmFzLnJlc2l6ZSh3aWR0aDIsIGhlaWdodDIpO1xuICAgIHRoaXMubGF5ZXJzTWFwLmZvckVhY2goKHsgY2FudmFzIH0pID0+IGNhbnZhcy5yZXNpemUod2lkdGgyLCBoZWlnaHQyKSk7XG4gIH1cbiAgYWRkTGF5ZXIob3B0cykge1xuICAgIGNvbnN0IHsgd2lkdGg6IHdpZHRoMiwgaGVpZ2h0OiBoZWlnaHQyLCBwaXhlbFJhdGlvIH0gPSB0aGlzLmNhbnZhcztcbiAgICBjb25zdCB7IHpJbmRleCA9IHRoaXMubmV4dFpJbmRleCsrLCBuYW1lLCB6SW5kZXhTdWJPcmRlciwgZ2V0Q29tcHV0ZWRPcGFjaXR5LCBnZXRWaXNpYmlsaXR5IH0gPSBvcHRzO1xuICAgIGNvbnN0IGNhbnZhcyA9IG5ldyBIZHBpQ2FudmFzKHsgd2lkdGg6IHdpZHRoMiwgaGVpZ2h0OiBoZWlnaHQyLCBwaXhlbFJhdGlvIH0pO1xuICAgIGlmICh6SW5kZXggPj0gdGhpcy5uZXh0WkluZGV4KSB7XG4gICAgICB0aGlzLm5leHRaSW5kZXggPSB6SW5kZXggKyAxO1xuICAgIH1cbiAgICB0aGlzLmxheWVyc01hcC5zZXQoY2FudmFzLCB7XG4gICAgICBpZDogdGhpcy5uZXh0TGF5ZXJJZCsrLFxuICAgICAgbmFtZSxcbiAgICAgIGNhbnZhcyxcbiAgICAgIHpJbmRleCxcbiAgICAgIHpJbmRleFN1Yk9yZGVyLFxuICAgICAgZ2V0Q29tcHV0ZWRPcGFjaXR5LFxuICAgICAgZ2V0VmlzaWJpbGl0eVxuICAgIH0pO1xuICAgIHRoaXMuZGVidWcoXCJTY2VuZS5hZGRMYXllcigpIC0gbGF5ZXJzXCIsIHRoaXMubGF5ZXJzTWFwKTtcbiAgICByZXR1cm4gY2FudmFzO1xuICB9XG4gIHJlbW92ZUxheWVyKGNhbnZhcykge1xuICAgIGlmICh0aGlzLmxheWVyc01hcC5oYXMoY2FudmFzKSkge1xuICAgICAgdGhpcy5sYXllcnNNYXAuZGVsZXRlKGNhbnZhcyk7XG4gICAgICBjYW52YXMuZGVzdHJveSgpO1xuICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgIHRoaXMuZGVidWcoXCJTY2VuZS5yZW1vdmVMYXllcigpIC0gIGxheWVyc1wiLCB0aGlzLmxheWVyc01hcCk7XG4gICAgfVxuICB9XG4gIG1vdmVMYXllcihjYW52YXMsIG5ld1pJbmRleCwgbmV3WkluZGV4U3ViT3JkZXIpIHtcbiAgICBjb25zdCBsYXllciA9IHRoaXMubGF5ZXJzTWFwLmdldChjYW52YXMpO1xuICAgIGlmIChsYXllcikge1xuICAgICAgbGF5ZXIuekluZGV4ID0gbmV3WkluZGV4O1xuICAgICAgbGF5ZXIuekluZGV4U3ViT3JkZXIgPSBuZXdaSW5kZXhTdWJPcmRlcjtcbiAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICB0aGlzLmRlYnVnKFwiU2NlbmUubW92ZUxheWVyKCkgLSAgbGF5ZXJzXCIsIHRoaXMubGF5ZXJzTWFwKTtcbiAgICB9XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5sYXllcnNNYXAuY2xlYXIoKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvc3ByaXRlUmVuZGVyZXIudHNcbnZhciBfU3ByaXRlUmVuZGVyZXIgPSBjbGFzcyBfU3ByaXRlUmVuZGVyZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm9mZnNjcmVlbkNhbnZhcyA9IHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09IFwidW5kZWZpbmVkXCIgPyBuZXcgT2Zmc2NyZWVuQ2FudmFzKDAsIDApIDogY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICBfU3ByaXRlUmVuZGVyZXIub2Zmc2NyZWVuQ2FudmFzQ291bnQrKztcbiAgICBjb25zdCBjdHggPSB0aGlzLm9mZnNjcmVlbkNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgaWYgKGN0eCA9PSBudWxsKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQUcgQ2hhcnRzIC0gaW52YWxpZCAyZCBjb250ZXh0YCk7XG4gICAgdGhpcy5yZW5kZXJDdHggPSB7XG4gICAgICBjdHgsXG4gICAgICBkZXZpY2VQaXhlbFJhdGlvOiAxLFxuICAgICAgZm9yY2VSZW5kZXI6IHRydWUsXG4gICAgICByZXNpemVkOiBmYWxzZSxcbiAgICAgIGRlYnVnTm9kZXM6IHt9XG4gICAgfTtcbiAgfVxuICByZXNpemUoeyBzcHJpdGVQaXhlbFJhdGlvLCBzcHJpdGVXaWR0aCwgc3ByaXRlSGVpZ2h0IH0pIHtcbiAgICB0aGlzLm9mZnNjcmVlbkNhbnZhcy53aWR0aCA9IE1hdGgubWF4KHNwcml0ZVdpZHRoLCAwKSAqIHNwcml0ZVBpeGVsUmF0aW87XG4gICAgdGhpcy5vZmZzY3JlZW5DYW52YXMuaGVpZ2h0ID0gTWF0aC5tYXgoc3ByaXRlSGVpZ2h0LCAwKSAqIHNwcml0ZVBpeGVsUmF0aW87XG4gIH1cbiAgcmVuZGVyU3ByaXRlKG5vZGVzLCBvcHRzKSB7XG4gICAgbm9kZXMgPSB0b0l0ZXJhYmxlKG5vZGVzKTtcbiAgICBjb25zdCB7XG4gICAgICByZW5kZXJDdHgsXG4gICAgICByZW5kZXJDdHg6IHsgY3R4IH0sXG4gICAgICBvZmZzY3JlZW5DYW52YXNcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB7IHNjYWxlOiBzY2FsZTIgPSAxLCB0cmFuc2xhdGVYID0gMCwgdHJhbnNsYXRlWSA9IDAgfSA9IG9wdHMgPz8ge307XG4gICAgY3R4LnJlc2V0VHJhbnNmb3JtKCk7XG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBvZmZzY3JlZW5DYW52YXMud2lkdGgsIG9mZnNjcmVlbkNhbnZhcy5oZWlnaHQpO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oc2NhbGUyLCAwLCAwLCBzY2FsZTIsIHRyYW5zbGF0ZVgsIHRyYW5zbGF0ZVkpO1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xuICAgICAgbm9kZS5wcmVSZW5kZXIoKTtcbiAgICAgIG5vZGUucmVuZGVyKHJlbmRlckN0eCk7XG4gICAgfVxuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICAgIGlmIChcInRyYW5zZmVyVG9JbWFnZUJpdG1hcFwiIGluIHRoaXMub2Zmc2NyZWVuQ2FudmFzKSB7XG4gICAgICByZXR1cm4gdGhpcy5vZmZzY3JlZW5DYW52YXMudHJhbnNmZXJUb0ltYWdlQml0bWFwKCk7XG4gICAgfVxuICAgIGNvbnN0IGNhbnZhcyA9IGNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgY2FudmFzLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgY2FudmFzLnN0eWxlLndpZHRoID0gb2Zmc2NyZWVuQ2FudmFzLndpZHRoICsgXCJweFwiO1xuICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBvZmZzY3JlZW5DYW52YXMuaGVpZ2h0ICsgXCJweFwiO1xuICAgIGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik/LnB1dEltYWdlRGF0YShjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIG9mZnNjcmVlbkNhbnZhcy53aWR0aCwgb2Zmc2NyZWVuQ2FudmFzLmhlaWdodCksIDAsIDApO1xuICAgIHJldHVybiBjYW52YXM7XG4gIH1cbn07XG5fU3ByaXRlUmVuZGVyZXIub2Zmc2NyZWVuQ2FudmFzQ291bnQgPSAwO1xudmFyIFNwcml0ZVJlbmRlcmVyID0gX1Nwcml0ZVJlbmRlcmVyO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9zY2VuZURlYnVnLnRzXG5mdW5jdGlvbiBkZWJ1Z1N0YXRzKGxheWVyc01hbmFnZXIsIGRlYnVnU3BsaXRUaW1lcywgY3R4LCByZW5kZXJDdHhTdGF0cywgZXh0cmFEZWJ1Z1N0YXRzID0ge30sIHNlcmllc1JlY3QgPSBCQm94Lnplcm8pIHtcbiAgaWYgKCFEZWJ1Zy5jaGVjayhcInNjZW5lOnN0YXRzXCIgLyogU0NFTkVfU1RBVFMgKi8sIFwic2NlbmU6c3RhdHM6dmVyYm9zZVwiIC8qIFNDRU5FX1NUQVRTX1ZFUkJPU0UgKi8pKVxuICAgIHJldHVybjtcbiAgY29uc3QgeyBsYXllcnNSZW5kZXJlZCA9IDAsIGxheWVyc1NraXBwZWQgPSAwLCBub2Rlc1JlbmRlcmVkID0gMCwgbm9kZXNTa2lwcGVkID0gMCB9ID0gcmVuZGVyQ3R4U3RhdHMgPz8ge307XG4gIGNvbnN0IGVuZDIgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgY29uc3QgeyBzdGFydDogc3RhcnQyLCAuLi5kdXJhdGlvbnMgfSA9IGRlYnVnU3BsaXRUaW1lcztcbiAgY29uc3Qgc3BsaXRzID0gT2JqZWN0LmVudHJpZXMoZHVyYXRpb25zKS5tYXAoKFtuLCB0XSkgPT4ge1xuICAgIHJldHVybiB0aW1lKG4sIHQpO1xuICB9KS5maWx0ZXIoKHYpID0+IHYgIT0gbnVsbCkuam9pbihcIiArIFwiKTtcbiAgY29uc3QgZXh0cmFzID0gT2JqZWN0LmVudHJpZXMoZXh0cmFEZWJ1Z1N0YXRzKS5tYXAoKFtrLCB2XSkgPT4gYCR7a306ICR7dn1gKS5qb2luKFwiIDsgXCIpO1xuICBjb25zdCBkZXRhaWxlZFN0YXRzID0gRGVidWcuY2hlY2soXCJzY2VuZTpzdGF0czp2ZXJib3NlXCIgLyogU0NFTkVfU1RBVFNfVkVSQk9TRSAqLyk7XG4gIGNvbnN0IHN0YXRzID0gW1xuICAgIGAke3RpbWUoXCJcXHUyM0YxXFx1RkUwRlwiLCBzdGFydDIsIGVuZDIpfSAoJHtzcGxpdHN9KWAsXG4gICAgYCR7ZXh0cmFzfWAsXG4gICAgYExheWVyczogJHtkZXRhaWxlZFN0YXRzID8gcGN0KGxheWVyc1JlbmRlcmVkLCBsYXllcnNTa2lwcGVkKSA6IGxheWVyc01hbmFnZXIuc2l6ZX07IFNwcml0ZXM6ICR7U3ByaXRlUmVuZGVyZXIub2Zmc2NyZWVuQ2FudmFzQ291bnR9YCxcbiAgICBkZXRhaWxlZFN0YXRzID8gYE5vZGVzOiAke3BjdChub2Rlc1JlbmRlcmVkLCBub2Rlc1NraXBwZWQpfWAgOiBudWxsXG4gIF0uZmlsdGVyKGlzU3RyaW5nKTtcbiAgY29uc3QgbWVhc3VyZXIgPSBuZXcgU2ltcGxlVGV4dE1lYXN1cmVyKCh0KSA9PiBjdHgubWVhc3VyZVRleHQodCkpO1xuICBjb25zdCBzdGF0c1NpemUgPSBuZXcgTWFwKHN0YXRzLm1hcCgodCkgPT4gW3QsIG1lYXN1cmVyLm1lYXN1cmVMaW5lcyh0KV0pKTtcbiAgY29uc3Qgd2lkdGgyID0gTWF0aC5tYXgoLi4uQXJyYXkuZnJvbShzdGF0c1NpemUudmFsdWVzKCksIChzKSA9PiBzLndpZHRoKSk7XG4gIGNvbnN0IGhlaWdodDIgPSBhY2N1bXVsYXRlKHN0YXRzU2l6ZS52YWx1ZXMoKSwgKHMpID0+IHMuaGVpZ2h0KTtcbiAgY29uc3QgeCA9IDIgKyBzZXJpZXNSZWN0Lng7XG4gIGN0eC5zYXZlKCk7XG4gIGN0eC5maWxsU3R5bGUgPSBcIndoaXRlXCI7XG4gIGN0eC5maWxsUmVjdCh4LCAwLCB3aWR0aDIsIGhlaWdodDIpO1xuICBjdHguZmlsbFN0eWxlID0gXCJibGFja1wiO1xuICBsZXQgeSA9IDA7XG4gIGZvciAoY29uc3QgW3N0YXQsIHNpemVdIG9mIHN0YXRzU2l6ZS5lbnRyaWVzKCkpIHtcbiAgICB5ICs9IHNpemUuaGVpZ2h0O1xuICAgIGN0eC5maWxsVGV4dChzdGF0LCB4LCB5KTtcbiAgfVxuICBjdHgucmVzdG9yZSgpO1xufVxuZnVuY3Rpb24gcHJlcGFyZVNjZW5lTm9kZUhpZ2hsaWdodChjdHgpIHtcbiAgY29uc3QgY29uZmlnID0gdG9BcnJheShnZXRXaW5kb3coXCJhZ0NoYXJ0c1NjZW5lRGVidWdcIikpO1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZm9yIChjb25zdCBuYW1lIG9mIGNvbmZpZykge1xuICAgIGlmIChuYW1lID09PSBcImxheW91dFwiKSB7XG4gICAgICByZXN1bHQucHVzaChcInNlcmllc1Jvb3RcIiwgXCJsZWdlbmRcIiwgXCJyb290XCIsIC8uKkF4aXMtXFxkKy1heGlzLiovKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnB1c2gobmFtZSk7XG4gICAgfVxuICB9XG4gIGN0eC5kZWJ1Z05vZGVTZWFyY2ggPSByZXN1bHQ7XG59XG5mdW5jdGlvbiBkZWJ1Z1NjZW5lTm9kZUhpZ2hsaWdodChjdHgsIGRlYnVnTm9kZXMpIHtcbiAgY3R4LnNhdmUoKTtcbiAgZm9yIChjb25zdCBbbmFtZSwgbm9kZV0gb2YgT2JqZWN0LmVudHJpZXMoZGVidWdOb2RlcykpIHtcbiAgICBjb25zdCBiYm94ID0gVHJhbnNmb3JtYWJsZS50b0NhbnZhcyhub2RlKTtcbiAgICBpZiAoIWJib3gpIHtcbiAgICAgIExvZ2dlci5sb2coYFNjZW5lLnJlbmRlcigpIC0gbm8gYmJveCBmb3IgZGVidWdnZWQgbm9kZSBbJHtuYW1lfV0uYCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY3R4Lmdsb2JhbEFscGhhID0gMC44O1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IFwicmVkXCI7XG4gICAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gICAgY3R4LnN0cm9rZVJlY3QoYmJveC54LCBiYm94LnksIGJib3gud2lkdGgsIGJib3guaGVpZ2h0KTtcbiAgICBjdHguZmlsbFN0eWxlID0gXCJyZWRcIjtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBcIndoaXRlXCI7XG4gICAgY3R4LmZvbnQgPSBcIjE2cHggc2Fucy1zZXJpZlwiO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBcInRvcFwiO1xuICAgIGN0eC50ZXh0QWxpZ24gPSBcImxlZnRcIjtcbiAgICBjdHgubGluZVdpZHRoID0gMjtcbiAgICBjdHguc3Ryb2tlVGV4dChuYW1lLCBiYm94LngsIGJib3gueSwgYmJveC53aWR0aCk7XG4gICAgY3R4LmZpbGxUZXh0KG5hbWUsIGJib3gueCwgYmJveC55LCBiYm94LndpZHRoKTtcbiAgfVxuICBjdHgucmVzdG9yZSgpO1xufVxudmFyIHNraXBwZWRQcm9wZXJ0aWVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbnZhciBhbGxvd2VkUHJvcGVydGllcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgXCJncmFkaWVudFwiLFxuICAvLyAnX2RhdHVtJyxcbiAgXCJ6SW5kZXhcIixcbiAgXCJjbGlwUmVjdFwiLFxuICBcImNhY2hlZEJCb3hcIixcbiAgXCJjaGlsZE5vZGVDb3VudHNcIixcbiAgXCJwYXRoXCIsXG4gIFwiX196SW5kZXhcIixcbiAgXCJuYW1lXCIsXG4gIFwiX19zY2FsaW5nQ2VudGVyWFwiLFxuICBcIl9fc2NhbGluZ0NlbnRlcllcIixcbiAgXCJfX3JvdGF0aW9uQ2VudGVyWFwiLFxuICBcIl9fcm90YXRpb25DZW50ZXJZXCIsXG4gIFwiX3ByZXZpb3VzRGF0dW1cIixcbiAgXCJfX2ZpbGxcIixcbiAgXCJfX2xpbmVEYXNoXCIsXG4gIFwiYm9yZGVyUGF0aFwiLFxuICBcImJvcmRlckNsaXBQYXRoXCIsXG4gIFwiX2NsaXBQYXRoXCJcbl0pO1xuZnVuY3Rpb24gbm9kZVByb3BzKG5vZGUpIHtcbiAgY29uc3QgeyAuLi5hbGxQcm9wcyB9ID0gbm9kZTtcbiAgZm9yIChjb25zdCBwcm9wIGluIGFsbFByb3BzKSB7XG4gICAgaWYgKGFsbG93ZWRQcm9wZXJ0aWVzLmhhcyhwcm9wKSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIGlmICh0eXBlb2YgYWxsUHJvcHNbcHJvcF0gPT09IFwibnVtYmVyXCIpXG4gICAgICBjb250aW51ZTtcbiAgICBpZiAodHlwZW9mIGFsbFByb3BzW3Byb3BdID09PSBcInN0cmluZ1wiKVxuICAgICAgY29udGludWU7XG4gICAgaWYgKHR5cGVvZiBhbGxQcm9wc1twcm9wXSA9PT0gXCJib29sZWFuXCIpXG4gICAgICBjb250aW51ZTtcbiAgICBza2lwcGVkUHJvcGVydGllcy5hZGQocHJvcCk7XG4gICAgZGVsZXRlIGFsbFByb3BzW3Byb3BdO1xuICB9XG4gIHJldHVybiBhbGxQcm9wcztcbn1cbmZ1bmN0aW9uIGJ1aWxkVHJlZShub2RlLCBtb2RlKSB7XG4gIGlmICghRGVidWcuY2hlY2sodHJ1ZSwgXCJzY2VuZVwiIC8qIFNDRU5FICovKSkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICBjb25zdCB7IHBhcmVudE5vZGUgfSA9IG5vZGU7XG4gIGxldCBvcmRlciA9IDA7XG4gIHJldHVybiB7XG4gICAgbm9kZTogbW9kZSA9PT0gXCJqc29uXCIgPyBub2RlUHJvcHMobm9kZSkgOiBub2RlLFxuICAgIG5hbWU6IG5vZGUubmFtZSA/PyBub2RlLmlkLFxuICAgIGRpcnR5OiBSZWRyYXdUeXBlW25vZGUuZGlydHldLFxuICAgIC4uLnBhcmVudE5vZGU/LmlzVmlydHVhbCA/IHtcbiAgICAgIHZpcnR1YWxQYXJlbnREaXJ0eTogUmVkcmF3VHlwZVtwYXJlbnROb2RlLmRpcnR5XSxcbiAgICAgIHZpcnR1YWxQYXJlbnQ6IHBhcmVudE5vZGVcbiAgICB9IDoge30sXG4gICAgLi4uQXJyYXkuZnJvbShub2RlLmNoaWxkcmVuKGZhbHNlKSwgKGMpID0+IGJ1aWxkVHJlZShjLCBtb2RlKSkucmVkdWNlKFxuICAgICAgKHJlc3VsdCwgY2hpbGRUcmVlKSA9PiB7XG4gICAgICAgIGxldCB7IG5hbWU6IHRyZWVOb2RlTmFtZSB9ID0gY2hpbGRUcmVlO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgbm9kZToge1xuICAgICAgICAgICAgdmlzaWJsZSxcbiAgICAgICAgICAgIG9wYWNpdHksXG4gICAgICAgICAgICB6SW5kZXgsXG4gICAgICAgICAgICB6SW5kZXhTdWJPcmRlcixcbiAgICAgICAgICAgIHRyYW5zbGF0aW9uWCxcbiAgICAgICAgICAgIHRyYW5zbGF0aW9uWSxcbiAgICAgICAgICAgIHJvdGF0aW9uLFxuICAgICAgICAgICAgc2NhbGluZ1gsXG4gICAgICAgICAgICBzY2FsaW5nWVxuICAgICAgICAgIH0sXG4gICAgICAgICAgbm9kZTogY2hpbGROb2RlLFxuICAgICAgICAgIHZpcnR1YWxQYXJlbnRcbiAgICAgICAgfSA9IGNoaWxkVHJlZTtcbiAgICAgICAgaWYgKCF2aXNpYmxlIHx8IG9wYWNpdHkgPD0gMCkge1xuICAgICAgICAgIHRyZWVOb2RlTmFtZSA9IGAoJHt0cmVlTm9kZU5hbWV9KWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKExheWVyLmlzKGNoaWxkTm9kZSkpIHtcbiAgICAgICAgICB0cmVlTm9kZU5hbWUgPSBgKiR7dHJlZU5vZGVOYW1lfSpgO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN1Yk9yZGVyID0gekluZGV4U3ViT3JkZXI/Lm1hcCgodikgPT4gdHlwZW9mIHYgPT09IFwiZnVuY3Rpb25cIiA/IGAke3YoKX0gKGZuKWAgOiB2KS5qb2luKFwiIC8gXCIpO1xuICAgICAgICBjb25zdCBrZXkgPSBbXG4gICAgICAgICAgYCR7KG9yZGVyKyspLnRvU3RyaW5nKCkucGFkU3RhcnQoMywgXCIwXCIpfXxgLFxuICAgICAgICAgIGAke3RyZWVOb2RlTmFtZSA/PyBcIjx1bmtub3duPlwifWAsXG4gICAgICAgICAgYHo6ICR7ekluZGV4fWAsXG4gICAgICAgICAgc3ViT3JkZXIgJiYgYHpvOiAke3N1Yk9yZGVyfWAsXG4gICAgICAgICAgdmlydHVhbFBhcmVudCAmJiBgKHZpcnR1YWwgcGFyZW50KWAsXG4gICAgICAgICAgdHJhbnNsYXRpb25YICYmIGB4OiAke3RyYW5zbGF0aW9uWH1gLFxuICAgICAgICAgIHRyYW5zbGF0aW9uWSAmJiBgeTogJHt0cmFuc2xhdGlvbll9YCxcbiAgICAgICAgICByb3RhdGlvbiAmJiBgcjogJHtyb3RhdGlvbn1gLFxuICAgICAgICAgIHNjYWxpbmdYICE9IG51bGwgJiYgc2NhbGluZ1ggIT09IDEgJiYgYHN4OiAke3NjYWxpbmdYfWAsXG4gICAgICAgICAgc2NhbGluZ1kgIT0gbnVsbCAmJiBzY2FsaW5nWSAhPT0gMSAmJiBgc3k6ICR7c2NhbGluZ1l9YFxuICAgICAgICBdLmZpbHRlcigodikgPT4gISF2KS5qb2luKFwiIFwiKTtcbiAgICAgICAgbGV0IHNlbGVjdGVkS2V5ID0ga2V5O1xuICAgICAgICBsZXQgaW5kZXggPSAxO1xuICAgICAgICB3aGlsZSAocmVzdWx0W3NlbGVjdGVkS2V5XSAhPSBudWxsICYmIGluZGV4IDwgMTAwKSB7XG4gICAgICAgICAgc2VsZWN0ZWRLZXkgPSBgJHtrZXl9ICgke2luZGV4Kyt9KWA7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W3NlbGVjdGVkS2V5XSA9IGNoaWxkVHJlZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sXG4gICAgICB7fVxuICAgIClcbiAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRGlydHlUcmVlKG5vZGUpIHtcbiAgaWYgKG5vZGUuZGlydHkgPT09IDAgLyogTk9ORSAqLykge1xuICAgIHJldHVybiB7IGRpcnR5VHJlZToge30sIHBhdGhzOiBbXSB9O1xuICB9XG4gIGNvbnN0IGNoaWxkcmVuRGlydHlUcmVlID0gQXJyYXkuZnJvbShub2RlLmNoaWxkcmVuKCksIChjKSA9PiBidWlsZERpcnR5VHJlZShjKSkuZmlsdGVyKChjKSA9PiBjLnBhdGhzLmxlbmd0aCA+IDApO1xuICBjb25zdCBuYW1lID0gR3JvdXAuaXMobm9kZSkgPyBub2RlLm5hbWUgPz8gbm9kZS5pZCA6IG5vZGUuaWQ7XG4gIGNvbnN0IHBhdGhzID0gY2hpbGRyZW5EaXJ0eVRyZWUubGVuZ3RoID8gY2hpbGRyZW5EaXJ0eVRyZWUuZmxhdE1hcCgoYykgPT4gYy5wYXRocykubWFwKChwKSA9PiBgJHtuYW1lfS4ke3B9YCkgOiBbbmFtZV07XG4gIHJldHVybiB7XG4gICAgZGlydHlUcmVlOiB7XG4gICAgICBuYW1lLFxuICAgICAgbm9kZSxcbiAgICAgIGRpcnR5OiBSZWRyYXdUeXBlW25vZGUuZGlydHldLFxuICAgICAgLi4uY2hpbGRyZW5EaXJ0eVRyZWUubWFwKChjKSA9PiBjLmRpcnR5VHJlZSkuZmlsdGVyKCh0KSA9PiB0LmRpcnR5ICE9IG51bGwpLnJlZHVjZSgocmVzdWx0LCBjaGlsZFRyZWUpID0+IHtcbiAgICAgICAgcmVzdWx0W2NoaWxkVHJlZS5uYW1lID8/IFwiPHVua25vd24+XCJdID0gY2hpbGRUcmVlO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSwge30pXG4gICAgfSxcbiAgICBwYXRoc1xuICB9O1xufVxuZnVuY3Rpb24gcGN0KHJlbmRlcmVkLCBza2lwcGVkKSB7XG4gIGNvbnN0IHRvdGFsID0gcmVuZGVyZWQgKyBza2lwcGVkO1xuICByZXR1cm4gYCR7cmVuZGVyZWR9IC8gJHt0b3RhbH0gKCR7TWF0aC5yb3VuZCgxMDAgKiByZW5kZXJlZCAvIHRvdGFsKX0lKWA7XG59XG5mdW5jdGlvbiB0aW1lKG5hbWUsIHN0YXJ0MiwgZW5kMikge1xuICBjb25zdCBkdXJhdGlvbiA9IGVuZDIgIT0gbnVsbCA/IGVuZDIgLSBzdGFydDIgOiBzdGFydDI7XG4gIHJldHVybiBgJHtuYW1lfTogJHtNYXRoLnJvdW5kKGR1cmF0aW9uICogMTAwKSAvIDEwMH1tc2A7XG59XG5mdW5jdGlvbiBhY2N1bXVsYXRlKGl0ZXJhdG9yLCBtYXBwZXIpIHtcbiAgbGV0IHN1bTIgPSAwO1xuICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlcmF0b3IpIHtcbiAgICBzdW0yICs9IG1hcHBlcihpdGVtKTtcbiAgfVxuICByZXR1cm4gc3VtMjtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvc2NlbmUudHNcbnZhciBTY2VuZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2FudmFzT3B0aW9ucykge1xuICAgIHRoaXMuZGVidWcgPSBEZWJ1Zy5jcmVhdGUodHJ1ZSwgXCJzY2VuZVwiIC8qIFNDRU5FICovKTtcbiAgICB0aGlzLmlkID0gY3JlYXRlSWQodGhpcyk7XG4gICAgdGhpcy5yb290ID0gbnVsbDtcbiAgICB0aGlzLnBlbmRpbmdTaXplID0gbnVsbDtcbiAgICB0aGlzLmlzRGlydHkgPSBmYWxzZTtcbiAgICB0aGlzLmNhbnZhcyA9IG5ldyBIZHBpQ2FudmFzKGNhbnZhc09wdGlvbnMpO1xuICAgIHRoaXMubGF5ZXJzTWFuYWdlciA9IG5ldyBMYXllcnNNYW5hZ2VyKHRoaXMuY2FudmFzLCAoKSA9PiB7XG4gICAgICB0aGlzLmlzRGlydHkgPSB0cnVlO1xuICAgIH0pO1xuICB9XG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5wZW5kaW5nU2l6ZT8uWzBdID8/IHRoaXMuY2FudmFzLndpZHRoO1xuICB9XG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMucGVuZGluZ1NpemU/LlsxXSA/PyB0aGlzLmNhbnZhcy5oZWlnaHQ7XG4gIH1cbiAgLyoqIEBkZXByZWNhdGVkIHYxMC4yLjAgT25seSB1c2VkIGJ5IEFHIEdyaWQgU3BhcmtsaW5lcyAqL1xuICBzZXRDb250YWluZXIodmFsdWUpIHtcbiAgICBjb25zdCB7IGVsZW1lbnQ6IGVsZW1lbnQyIH0gPSB0aGlzLmNhbnZhcztcbiAgICBlbGVtZW50Mi5wYXJlbnRFbGVtZW50Py5yZW1vdmVDaGlsZChlbGVtZW50Mik7XG4gICAgdmFsdWUuYXBwZW5kQ2hpbGQoZWxlbWVudDIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNldFJvb3Qobm9kZSkge1xuICAgIGlmICh0aGlzLnJvb3QgPT09IG5vZGUpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0aGlzLmlzRGlydHkgPSB0cnVlO1xuICAgIHRoaXMucm9vdD8uX3NldExheWVyTWFuYWdlcigpO1xuICAgIHRoaXMucm9vdCA9IG5vZGU7XG4gICAgaWYgKG5vZGUpIHtcbiAgICAgIG5vZGUudmlzaWJsZSA9IHRydWU7XG4gICAgICBub2RlLl9zZXRMYXllck1hbmFnZXIodGhpcy5sYXllcnNNYW5hZ2VyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYXR0YWNoTm9kZShub2RlKSB7XG4gICAgdGhpcy5hcHBlbmRDaGlsZChub2RlKTtcbiAgICByZXR1cm4gKCkgPT4gdGhpcy5yZW1vdmVDaGlsZChub2RlKTtcbiAgfVxuICBhcHBlbmRDaGlsZChub2RlKSB7XG4gICAgdGhpcy5yb290Py5hcHBlbmRDaGlsZChub2RlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZW1vdmVDaGlsZChub2RlKSB7XG4gICAgdGhpcy5yb290Py5yZW1vdmVDaGlsZChub2RlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBkb3dubG9hZChmaWxlTmFtZSwgZmlsZUZvcm1hdCkge1xuICAgIGRvd25sb2FkVXJsKHRoaXMuY2FudmFzLnRvRGF0YVVSTChmaWxlRm9ybWF0KSwgZmlsZU5hbWU/LnRyaW0oKSA/PyBcImltYWdlXCIpO1xuICB9XG4gIC8qKiBOT1RFOiBJbnRlZ3JhdGVkIENoYXJ0cyB1bmRvY3VtZW50ZWQgaW1hZ2UgZG93bmxvYWQgbWV0aG9kLiAqL1xuICBnZXREYXRhVVJMKGZpbGVGb3JtYXQpIHtcbiAgICByZXR1cm4gdGhpcy5jYW52YXMudG9EYXRhVVJMKGZpbGVGb3JtYXQpO1xuICB9XG4gIHJlc2l6ZSh3aWR0aDIsIGhlaWdodDIpIHtcbiAgICB3aWR0aDIgPSBNYXRoLnJvdW5kKHdpZHRoMik7XG4gICAgaGVpZ2h0MiA9IE1hdGgucm91bmQoaGVpZ2h0Mik7XG4gICAgaWYgKHdpZHRoMiA+IDAgJiYgaGVpZ2h0MiA+IDAgJiYgKHdpZHRoMiAhPT0gdGhpcy53aWR0aCB8fCBoZWlnaHQyICE9PSB0aGlzLmhlaWdodCkpIHtcbiAgICAgIHRoaXMucGVuZGluZ1NpemUgPSBbd2lkdGgyLCBoZWlnaHQyXTtcbiAgICAgIHRoaXMuaXNEaXJ0eSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGFzeW5jIHJlbmRlcihvcHRzKSB7XG4gICAgY29uc3QgeyBkZWJ1Z1NwbGl0VGltZXMgPSB7IHN0YXJ0OiBwZXJmb3JtYW5jZS5ub3coKSB9LCBleHRyYURlYnVnU3RhdHMsIHNlcmllc1JlY3QgfSA9IG9wdHMgPz8ge307XG4gICAgY29uc3QgeyBjYW52YXMsIGNhbnZhczogeyBjb250ZXh0OiBjdHggfSA9IHt9LCByb290LCBwZW5kaW5nU2l6ZSB9ID0gdGhpcztcbiAgICBpZiAoIWN0eCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZW5kZXJTdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBpZiAocGVuZGluZ1NpemUpIHtcbiAgICAgIHRoaXMubGF5ZXJzTWFuYWdlci5yZXNpemUoLi4ucGVuZGluZ1NpemUpO1xuICAgICAgdGhpcy5wZW5kaW5nU2l6ZSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChyb290ICYmICFyb290LnZpc2libGUpIHtcbiAgICAgIHRoaXMuaXNEaXJ0eSA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocm9vdCAmJiAhdGhpcy5pc0RpcnR5KSB7XG4gICAgICBpZiAodGhpcy5kZWJ1Zy5jaGVjaygpKSB7XG4gICAgICAgIHRoaXMuZGVidWcoXCJTY2VuZS5yZW5kZXIoKSAtIG5vLW9wXCIsIHtcbiAgICAgICAgICByZWRyYXdUeXBlOiBSZWRyYXdUeXBlW3Jvb3QuZGlydHldLFxuICAgICAgICAgIHRyZWU6IGJ1aWxkVHJlZShyb290LCBcImNvbnNvbGVcIilcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBkZWJ1Z1N0YXRzKHRoaXMubGF5ZXJzTWFuYWdlciwgZGVidWdTcGxpdFRpbWVzLCBjdHgsIHZvaWQgMCwgZXh0cmFEZWJ1Z1N0YXRzLCBzZXJpZXNSZWN0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVuZGVyQ3R4ID0ge1xuICAgICAgY3R4LFxuICAgICAgZGV2aWNlUGl4ZWxSYXRpbzogdGhpcy5jYW52YXMucGl4ZWxSYXRpbyA/PyAxLFxuICAgICAgZm9yY2VSZW5kZXI6IHRydWUsXG4gICAgICByZXNpemVkOiBCb29sZWFuKHBlbmRpbmdTaXplKSxcbiAgICAgIGRlYnVnTm9kZXM6IHt9XG4gICAgfTtcbiAgICBpZiAoRGVidWcuY2hlY2soXCJzY2VuZTpzdGF0czp2ZXJib3NlXCIgLyogU0NFTkVfU1RBVFNfVkVSQk9TRSAqLykpIHtcbiAgICAgIHJlbmRlckN0eC5zdGF0cyA9IHsgbGF5ZXJzUmVuZGVyZWQ6IDAsIGxheWVyc1NraXBwZWQ6IDAsIG5vZGVzUmVuZGVyZWQ6IDAsIG5vZGVzU2tpcHBlZDogMCB9O1xuICAgIH1cbiAgICBwcmVwYXJlU2NlbmVOb2RlSGlnaGxpZ2h0KHJlbmRlckN0eCk7XG4gICAgbGV0IGNhbnZhc0NsZWFyZWQgPSBmYWxzZTtcbiAgICBpZiAoIXJvb3QgfHwgcm9vdC5kaXJ0eSA+PSAxIC8qIFRSSVZJQUwgKi8pIHtcbiAgICAgIGNhbnZhc0NsZWFyZWQgPSB0cnVlO1xuICAgICAgY2FudmFzLmNsZWFyKCk7XG4gICAgfVxuICAgIGlmIChyb290ICYmIERlYnVnLmNoZWNrKFwic2NlbmU6ZGlydHlUcmVlXCIgLyogU0NFTkVfRElSVFlfVFJFRSAqLykpIHtcbiAgICAgIGNvbnN0IHsgZGlydHlUcmVlLCBwYXRocyB9ID0gYnVpbGREaXJ0eVRyZWUocm9vdCk7XG4gICAgICBEZWJ1Zy5jcmVhdGUoXCJzY2VuZTpkaXJ0eVRyZWVcIiAvKiBTQ0VORV9ESVJUWV9UUkVFICovKShcIlNjZW5lLnJlbmRlcigpIC0gZGlydHlUcmVlXCIsIHsgZGlydHlUcmVlLCBwYXRocyB9KTtcbiAgICB9XG4gICAgaWYgKHJvb3QgJiYgY2FudmFzQ2xlYXJlZCkge1xuICAgICAgaWYgKHJvb3QudmlzaWJsZSkge1xuICAgICAgICByb290LnByZVJlbmRlcigpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZGVidWcuY2hlY2soKSkge1xuICAgICAgICBjb25zdCB0cmVlID0gYnVpbGRUcmVlKHJvb3QsIFwiY29uc29sZVwiKTtcbiAgICAgICAgdGhpcy5kZWJ1ZyhcIlNjZW5lLnJlbmRlcigpIC0gYmVmb3JlXCIsIHtcbiAgICAgICAgICByZWRyYXdUeXBlOiBSZWRyYXdUeXBlW3Jvb3QuZGlydHldLFxuICAgICAgICAgIGNhbnZhc0NsZWFyZWQsXG4gICAgICAgICAgdHJlZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChyb290LnZpc2libGUpIHtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgcm9vdC5yZW5kZXIocmVuZGVyQ3R4KTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZGVidWdTcGxpdFRpbWVzW1wiXFx1MjcwRFxcdUZFMEZcIl0gPSBwZXJmb3JtYW5jZS5ub3coKSAtIHJlbmRlclN0YXJ0VGltZTtcbiAgICBpZiAodGhpcy5sYXllcnNNYW5hZ2VyLnNpemUgJiYgY2FudmFzQ2xlYXJlZCkge1xuICAgICAgY29uc3QgbGF5ZXJSZW5kZXJTdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5yZXNldFRyYW5zZm9ybSgpO1xuICAgICAgdGhpcy5sYXllcnNNYW5hZ2VyLmZvckVhY2goKGxheWVyKSA9PiB7XG4gICAgICAgIGlmIChsYXllci5jYW52YXMuZW5hYmxlZCAmJiBsYXllci5nZXRWaXNpYmlsaXR5KCkpIHtcbiAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBsYXllci5nZXRDb21wdXRlZE9wYWNpdHkoKTtcbiAgICAgICAgICBsYXllci5jYW52YXMuZHJhd0ltYWdlKGN0eCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIGRlYnVnU3BsaXRUaW1lc1tcIlxcdTI2RDlcIl0gPSBwZXJmb3JtYW5jZS5ub3coKSAtIGxheWVyUmVuZGVyU3RhcnQ7XG4gICAgfVxuICAgIGN0eC52ZXJpZnlEZXB0aFplcm8/LigpO1xuICAgIHRoaXMuaXNEaXJ0eSA9IGZhbHNlO1xuICAgIGRlYnVnU3RhdHModGhpcy5sYXllcnNNYW5hZ2VyLCBkZWJ1Z1NwbGl0VGltZXMsIGN0eCwgcmVuZGVyQ3R4LnN0YXRzLCBleHRyYURlYnVnU3RhdHMsIHNlcmllc1JlY3QpO1xuICAgIGRlYnVnU2NlbmVOb2RlSGlnaGxpZ2h0KGN0eCwgcmVuZGVyQ3R4LmRlYnVnTm9kZXMpO1xuICAgIGlmIChyb290ICYmIHRoaXMuZGVidWcuY2hlY2soKSkge1xuICAgICAgdGhpcy5kZWJ1ZyhcIlNjZW5lLnJlbmRlcigpIC0gYWZ0ZXJcIiwge1xuICAgICAgICByZWRyYXdUeXBlOiBSZWRyYXdUeXBlW3Jvb3QuZGlydHldLFxuICAgICAgICB0cmVlOiBidWlsZFRyZWUocm9vdCwgXCJjb25zb2xlXCIpLFxuICAgICAgICBjYW52YXNDbGVhcmVkXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgdG9TVkcoKSB7XG4gICAgY29uc3Qgc3ZnID0gdGhpcy5yb290Py50b1NWRygpO1xuICAgIGlmIChzdmcgPT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCByb290ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJzdmdcIik7XG4gICAgcm9vdC5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBTdHJpbmcodGhpcy53aWR0aCkpO1xuICAgIHJvb3Quc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIFN0cmluZyh0aGlzLmhlaWdodCkpO1xuICAgIGlmIChzdmcuZGVmcyAhPSBudWxsKSB7XG4gICAgICBjb25zdCBkZWZzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJkZWZzXCIpO1xuICAgICAgZGVmcy5hcHBlbmQoLi4uc3ZnLmRlZnMpO1xuICAgICAgcm9vdC5hcHBlbmQoZGVmcyk7XG4gICAgfVxuICAgIHJvb3QuYXBwZW5kKC4uLnN2Zy5lbGVtZW50cyk7XG4gICAgcmV0dXJuIHJvb3Qub3V0ZXJIVE1MO1xuICB9XG4gIC8qKiBBbHRlcm5hdGl2ZSB0byBkZXN0cm95KCkgdGhhdCBwcmVzZXJ2ZXMgcmUtdXNhYmxlIHJlc291cmNlcy4gKi9cbiAgc3RyaXAoKSB7XG4gICAgY29uc3QgeyBjb250ZXh0LCBwaXhlbFJhdGlvIH0gPSB0aGlzLmNhbnZhcztcbiAgICBjb250ZXh0LnNldFRyYW5zZm9ybShwaXhlbFJhdGlvLCAwLCAwLCBwaXhlbFJhdGlvLCAwLCAwKTtcbiAgICB0aGlzLmxheWVyc01hbmFnZXIuY2xlYXIoKTtcbiAgICB0aGlzLnNldFJvb3QobnVsbCk7XG4gICAgdGhpcy5pc0RpcnR5ID0gZmFsc2U7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnN0cmlwKCk7XG4gICAgdGhpcy5jYW52YXMuZGVzdHJveSgpO1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgeyBjYW52YXM6IHZvaWQgMCB9KTtcbiAgfVxufTtcblNjZW5lLmNsYXNzTmFtZSA9IFwiU2NlbmVcIjtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9jYWxsYmFja0NhY2hlLnRzXG52YXIgQ2FsbGJhY2tDYWNoZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICB9XG4gIGNhbGwoZm4sIC4uLnBhcmFtcykge1xuICAgIGxldCBzZXJpYWxpc2VkUGFyYW1zO1xuICAgIGxldCBwYXJhbUNhY2hlID0gdGhpcy5jYWNoZS5nZXQoZm4pO1xuICAgIHRyeSB7XG4gICAgICBzZXJpYWxpc2VkUGFyYW1zID0gSlNPTi5zdHJpbmdpZnkocGFyYW1zKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbnZva2UoZm4sIHBhcmFtcywgcGFyYW1DYWNoZSk7XG4gICAgfVxuICAgIGlmIChwYXJhbUNhY2hlID09IG51bGwpIHtcbiAgICAgIHBhcmFtQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgdGhpcy5jYWNoZS5zZXQoZm4sIHBhcmFtQ2FjaGUpO1xuICAgIH1cbiAgICBpZiAoIXBhcmFtQ2FjaGUuaGFzKHNlcmlhbGlzZWRQYXJhbXMpKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbnZva2UoZm4sIHBhcmFtcywgcGFyYW1DYWNoZSwgc2VyaWFsaXNlZFBhcmFtcyk7XG4gICAgfVxuICAgIHJldHVybiBwYXJhbUNhY2hlLmdldChzZXJpYWxpc2VkUGFyYW1zKTtcbiAgfVxuICBpbnZva2UoZm4sIHBhcmFtcywgcGFyYW1DYWNoZSwgc2VyaWFsaXNlZFBhcmFtcykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBmbiguLi5wYXJhbXMpO1xuICAgICAgaWYgKHBhcmFtQ2FjaGUgJiYgc2VyaWFsaXNlZFBhcmFtcyAhPSBudWxsKSB7XG4gICAgICAgIHBhcmFtQ2FjaGUuc2V0KHNlcmlhbGlzZWRQYXJhbXMsIHJlc3VsdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIExvZ2dlci53YXJuT25jZShgVXNlciBjYWxsYmFjayBlcnJvcmVkLCBpZ25vcmluZ2AsIGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBpbnZhbGlkYXRlQ2FjaGUoKSB7XG4gICAgdGhpcy5jYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9hbm5vdGF0aW9uL2Fubm90YXRpb25NYW5hZ2VyLnRzXG52YXIgQW5ub3RhdGlvbk1hbmFnZXIgPSBjbGFzcyBleHRlbmRzIEJhc2VNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoYW5ub3RhdGlvblJvb3QpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuYW5ub3RhdGlvblJvb3QgPSBhbm5vdGF0aW9uUm9vdDtcbiAgICB0aGlzLm1lbWVudG9PcmlnaW5hdG9yS2V5ID0gXCJhbm5vdGF0aW9uc1wiO1xuICAgIHRoaXMuYW5ub3RhdGlvbnMgPSBbXTtcbiAgfVxuICBjcmVhdGVNZW1lbnRvKCkge1xuICAgIHJldHVybiB0aGlzLmFubm90YXRpb25zO1xuICB9XG4gIGd1YXJkTWVtZW50byhibG9iKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkoYmxvYik7XG4gIH1cbiAgcmVzdG9yZU1lbWVudG8oX3ZlcnNpb24sIF9tZW1lbnRvVmVyc2lvbiwgbWVtZW50bykge1xuICAgIHRoaXMuYW5ub3RhdGlvbnMgPSB0aGlzLmNsZWFuRGF0YShtZW1lbnRvKS5tYXAoKGFubm90YXRpb24pID0+IHtcbiAgICAgIGNvbnN0IGFubm90YXRpb25UaGVtZSA9IHRoaXMuZ2V0QW5ub3RhdGlvblR5cGVTdHlsZXMoYW5ub3RhdGlvbi50eXBlKTtcbiAgICAgIHJldHVybiBtZXJnZURlZmF1bHRzKGFubm90YXRpb24sIGFubm90YXRpb25UaGVtZSk7XG4gICAgfSk7XG4gICAgdGhpcy5saXN0ZW5lcnMuZGlzcGF0Y2goXCJyZXN0b3JlLWFubm90YXRpb25zXCIsIHtcbiAgICAgIHR5cGU6IFwicmVzdG9yZS1hbm5vdGF0aW9uc1wiLFxuICAgICAgYW5ub3RhdGlvbnM6IHRoaXMuYW5ub3RhdGlvbnNcbiAgICB9KTtcbiAgfVxuICB1cGRhdGVEYXRhKGFubm90YXRpb25zMikge1xuICAgIHRoaXMuYW5ub3RhdGlvbnMgPSB0aGlzLmNsZWFuRGF0YShhbm5vdGF0aW9uczIgPz8gW10pO1xuICB9XG4gIGF0dGFjaE5vZGUobm9kZSkge1xuICAgIHRoaXMuYW5ub3RhdGlvblJvb3QuYXBwZW5kKG5vZGUpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB0aGlzLmFubm90YXRpb25Sb290Py5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gIH1cbiAgc2V0QW5ub3RhdGlvblN0eWxlcyhzdHlsZXMpIHtcbiAgICB0aGlzLnN0eWxlcyA9IHN0eWxlcztcbiAgfVxuICBnZXRBbm5vdGF0aW9uVHlwZVN0eWxlcyh0eXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuc3R5bGVzPy5bdHlwZV07XG4gIH1cbiAgY2xlYW5EYXRhKGFubm90YXRpb25zMikge1xuICAgIGZvciAoY29uc3QgYW5ub3RhdGlvbiBvZiBhbm5vdGF0aW9uczIpIHtcbiAgICAgIGlmIChcInRleHRBbGlnblwiIGluIGFubm90YXRpb24pXG4gICAgICAgIGRlbGV0ZSBhbm5vdGF0aW9uLnRleHRBbGlnbjtcbiAgICB9XG4gICAgcmV0dXJuIGFubm90YXRpb25zMjtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvYXhpcy9heGlzTWFuYWdlci50c1xudmFyIEF4aXNNYW5hZ2VyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihzY2VuZVJvb3QpIHtcbiAgICB0aGlzLnNjZW5lUm9vdCA9IHNjZW5lUm9vdDtcbiAgICB0aGlzLmF4ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuYXhpc0dyaWRHcm91cCA9IG5ldyBMYXllcih7IG5hbWU6IFwiQXhlcy1Hcmlkc1wiLCB6SW5kZXg6IDEgLyogQVhJU19HUklEICovIH0pO1xuICAgIHRoaXMuYXhpc0dyb3VwID0gbmV3IExheWVyKHsgbmFtZTogXCJBeGVzXCIsIHpJbmRleDogMiAvKiBBWElTICovIH0pO1xuICAgIHRoaXMuc2NlbmVSb290LmFwcGVuZENoaWxkKHRoaXMuYXhpc0dyb3VwKTtcbiAgICB0aGlzLnNjZW5lUm9vdC5hcHBlbmRDaGlsZCh0aGlzLmF4aXNHcmlkR3JvdXApO1xuICB9XG4gIHVwZGF0ZUF4ZXMob2xkQXhlcywgbmV3QXhlcykge1xuICAgIGZvciAoY29uc3QgYXhpcyBvZiBvbGRBeGVzKSB7XG4gICAgICBpZiAobmV3QXhlcy5pbmNsdWRlcyhheGlzKSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBheGlzLmRldGFjaEF4aXModGhpcy5heGlzR3JvdXAsIHRoaXMuYXhpc0dyaWRHcm91cCk7XG4gICAgICBheGlzLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBheGlzIG9mIG5ld0F4ZXMpIHtcbiAgICAgIGlmIChvbGRBeGVzPy5pbmNsdWRlcyhheGlzKSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBheGlzLmF0dGFjaEF4aXModGhpcy5heGlzR3JvdXAsIHRoaXMuYXhpc0dyaWRHcm91cCk7XG4gICAgfVxuICAgIHRoaXMuYXhlcy5jbGVhcigpO1xuICAgIGZvciAoY29uc3QgYXhpcyBvZiBuZXdBeGVzKSB7XG4gICAgICBjb25zdCBjdHggPSBheGlzLmNyZWF0ZUF4aXNDb250ZXh0KCk7XG4gICAgICBpZiAodGhpcy5heGVzLmhhcyhjdHguZGlyZWN0aW9uKSkge1xuICAgICAgICB0aGlzLmF4ZXMuZ2V0KGN0eC5kaXJlY3Rpb24pPy5wdXNoKGN0eCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmF4ZXMuc2V0KGN0eC5kaXJlY3Rpb24sIFtjdHhdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0QXhpc0NvbnRleHQoZGlyZWN0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuYXhlcy5nZXQoZGlyZWN0aW9uKSA/PyBbXTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuYXhlcy5jbGVhcigpO1xuICAgIHRoaXMuc2NlbmVSb290LnJlbW92ZUNoaWxkKHRoaXMuYXhpc0dyb3VwKTtcbiAgICB0aGlzLnNjZW5lUm9vdC5yZW1vdmVDaGlsZCh0aGlzLmF4aXNHcmlkR3JvdXApO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9kYXRhL2RhdGFTZXJ2aWNlLnRzXG52YXIgRGF0YVNlcnZpY2UgPSBjbGFzcyBleHRlbmRzIExpc3RlbmVycyB7XG4gIGNvbnN0cnVjdG9yKGFuaW1hdGlvbk1hbmFnZXIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuYW5pbWF0aW9uTWFuYWdlciA9IGFuaW1hdGlvbk1hbmFnZXI7XG4gICAgdGhpcy5kaXNwYXRjaE9ubHlMYXRlc3QgPSB0cnVlO1xuICAgIHRoaXMuZGlzcGF0Y2hUaHJvdHRsZSA9IDA7XG4gICAgdGhpcy5yZXF1ZXN0VGhyb3R0bGUgPSAzMDA7XG4gICAgdGhpcy5pc0xvYWRpbmdJbml0aWFsRGF0YSA9IGZhbHNlO1xuICAgIHRoaXMuaXNMb2FkaW5nRGF0YSA9IGZhbHNlO1xuICAgIHRoaXMuZnJlc2hSZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMucmVxdWVzdENvdW50ZXIgPSAwO1xuICAgIHRoaXMuZGVidWcgPSBEZWJ1Zy5jcmVhdGUodHJ1ZSwgXCJkYXRhLW1vZGVsXCIsIFwiZGF0YS1zb3VyY2VcIik7XG4gICAgdGhpcy50aHJvdHRsZWRGZXRjaCA9IHRoaXMuY3JlYXRlVGhyb3R0bGVkRmV0Y2godGhpcy5yZXF1ZXN0VGhyb3R0bGUpO1xuICAgIHRoaXMudGhyb3R0bGVkRGlzcGF0Y2ggPSB0aGlzLmNyZWF0ZVRocm90dGxlZERpc3BhdGNoKHRoaXMuZGlzcGF0Y2hUaHJvdHRsZSk7XG4gIH1cbiAgdXBkYXRlQ2FsbGJhY2soZGF0YVNvdXJjZUNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhU291cmNlQ2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmRlYnVnKFwiRGF0YVNlcnZpY2UgLSB1cGRhdGVkIGRhdGEgc291cmNlIGNhbGxiYWNrXCIpO1xuICAgIHRoaXMuZGF0YVNvdXJjZUNhbGxiYWNrID0gZGF0YVNvdXJjZUNhbGxiYWNrO1xuICAgIHRoaXMuaXNMb2FkaW5nSW5pdGlhbERhdGEgPSB0cnVlO1xuICAgIHRoaXMuYW5pbWF0aW9uTWFuYWdlci5za2lwKCk7XG4gICAgdGhpcy5kaXNwYXRjaChcImRhdGEtc291cmNlLWNoYW5nZVwiKTtcbiAgfVxuICBjbGVhckNhbGxiYWNrKCkge1xuICAgIHRoaXMuZGF0YVNvdXJjZUNhbGxiYWNrID0gdm9pZCAwO1xuICB9XG4gIGxvYWQocGFyYW1zKSB7XG4gICAgdGhpcy5pc0xvYWRpbmdEYXRhID0gdHJ1ZTtcbiAgICB0aGlzLnRocm90dGxlZEZldGNoKHBhcmFtcyk7XG4gIH1cbiAgaXNMYXp5KCkge1xuICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2VDYWxsYmFjayAhPSBudWxsO1xuICB9XG4gIGlzTG9hZGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5pc0xhenkoKSAmJiAodGhpcy5pc0xvYWRpbmdJbml0aWFsRGF0YSB8fCB0aGlzLmlzTG9hZGluZ0RhdGEpO1xuICB9XG4gIGNyZWF0ZVRocm90dGxlZEZldGNoKHJlcXVlc3RUaHJvdHRsZSkge1xuICAgIHJldHVybiB0aHJvdHRsZSgocGFyYW1zKSA9PiB0aGlzLmZldGNoKHBhcmFtcyksIHJlcXVlc3RUaHJvdHRsZSwge1xuICAgICAgbGVhZGluZzogZmFsc2UsXG4gICAgICB0cmFpbGluZzogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIGNyZWF0ZVRocm90dGxlZERpc3BhdGNoKGRpc3BhdGNoVGhyb3R0bGUpIHtcbiAgICByZXR1cm4gdGhyb3R0bGUoXG4gICAgICAoaWQsIGRhdGEpID0+IHtcbiAgICAgICAgdGhpcy5kZWJ1ZyhgRGF0YVNlcnZpY2UgLSBkaXNwYXRjaGluZyAnZGF0YS1sb2FkJyB8ICR7aWR9YCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goXCJkYXRhLWxvYWRcIiwgeyB0eXBlOiBcImRhdGEtbG9hZFwiLCBkYXRhIH0pO1xuICAgICAgfSxcbiAgICAgIGRpc3BhdGNoVGhyb3R0bGUsXG4gICAgICB7XG4gICAgICAgIGxlYWRpbmc6IHRydWUsXG4gICAgICAgIHRyYWlsaW5nOiB0cnVlXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBhc3luYyBmZXRjaChwYXJhbXMpIHtcbiAgICBpZiAoIXRoaXMuZGF0YVNvdXJjZUNhbGxiYWNrKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhU2VydmljZSAtIFtkYXRhU291cmNlLmdldERhdGFdIGNhbGxiYWNrIG5vdCBpbml0aWFsaXNlZFwiKTtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnQyID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgY29uc3QgaWQgPSB0aGlzLnJlcXVlc3RDb3VudGVyKys7XG4gICAgdGhpcy5kZWJ1ZyhgRGF0YVNlcnZpY2UgLSByZXF1ZXN0aW5nIHwgJHtpZH1gKTtcbiAgICB0aGlzLmZyZXNoUmVxdWVzdHMucHVzaChpZCk7XG4gICAgbGV0IHJlc3BvbnNlO1xuICAgIHRyeSB7XG4gICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMuZGF0YVNvdXJjZUNhbGxiYWNrKHBhcmFtcyk7XG4gICAgICB0aGlzLmRlYnVnKGBEYXRhU2VydmljZSAtIHJlc3BvbnNlIHwgJHtwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0Mn1tcyB8ICR7aWR9YCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMuZGVidWcoYERhdGFTZXJ2aWNlIC0gcmVxdWVzdCBmYWlsZWQgfCAke2lkfWApO1xuICAgICAgTG9nZ2VyLmVycm9yT25jZShgRGF0YVNlcnZpY2UgLSByZXF1ZXN0IGZhaWxlZCB8IFske2Vycm9yfV1gKTtcbiAgICB9XG4gICAgdGhpcy5pc0xvYWRpbmdJbml0aWFsRGF0YSA9IGZhbHNlO1xuICAgIGNvbnN0IHJlcXVlc3RJbmRleCA9IHRoaXMuZnJlc2hSZXF1ZXN0cy5maW5kSW5kZXgoKHJpZCkgPT4gcmlkID09PSBpZCk7XG4gICAgaWYgKHJlcXVlc3RJbmRleCA9PT0gLTEgfHwgdGhpcy5kaXNwYXRjaE9ubHlMYXRlc3QgJiYgcmVxdWVzdEluZGV4ICE9PSB0aGlzLmZyZXNoUmVxdWVzdHMubGVuZ3RoIC0gMSkge1xuICAgICAgdGhpcy5kZWJ1ZyhgRGF0YVNlcnZpY2UgLSBkaXNjYXJkaW5nIHN0YWxlIHJlcXVlc3QgfCAke2lkfWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmZyZXNoUmVxdWVzdHMgPSB0aGlzLmZyZXNoUmVxdWVzdHMuc2xpY2UocmVxdWVzdEluZGV4ICsgMSk7XG4gICAgaWYgKHRoaXMuZnJlc2hSZXF1ZXN0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuaXNMb2FkaW5nRGF0YSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZXNwb25zZSkpIHtcbiAgICAgIHRoaXMudGhyb3R0bGVkRGlzcGF0Y2goaWQsIHJlc3BvbnNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kaXNwYXRjaChcImRhdGEtZXJyb3JcIik7XG4gICAgfVxuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgQWN0aW9uT25TZXQoe1xuICAgIG5ld1ZhbHVlKGRpc3BhdGNoVGhyb3R0bGUpIHtcbiAgICAgIHRoaXMudGhyb3R0bGVkRGlzcGF0Y2ggPSB0aGlzLmNyZWF0ZVRocm90dGxlZERpc3BhdGNoKGRpc3BhdGNoVGhyb3R0bGUpO1xuICAgIH1cbiAgfSlcbl0sIERhdGFTZXJ2aWNlLnByb3RvdHlwZSwgXCJkaXNwYXRjaFRocm90dGxlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgQWN0aW9uT25TZXQoe1xuICAgIG5ld1ZhbHVlKHJlcXVlc3RUaHJvdHRsZSkge1xuICAgICAgdGhpcy50aHJvdHRsZWRGZXRjaCA9IHRoaXMuY3JlYXRlVGhyb3R0bGVkRmV0Y2gocmVxdWVzdFRocm90dGxlKTtcbiAgICB9XG4gIH0pXG5dLCBEYXRhU2VydmljZS5wcm90b3R5cGUsIFwicmVxdWVzdFRocm90dGxlXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9pbnRlcmFjdGlvbi9hbmltYXRpb25CYXRjaC50c1xudmFyIEFuaW1hdGlvbkJhdGNoID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihtYXhBbmltYXRpb25UaW1lKSB7XG4gICAgdGhpcy5tYXhBbmltYXRpb25UaW1lID0gbWF4QW5pbWF0aW9uVGltZTtcbiAgICB0aGlzLmRlYnVnID0gRGVidWcuY3JlYXRlKHRydWUsIFwiYW5pbWF0aW9uXCIpO1xuICAgIHRoaXMuY29udHJvbGxlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuc3RvcHBlZENicyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy5jdXJyZW50UGhhc2UgPSAwO1xuICAgIHRoaXMucGhhc2VzID0gbmV3IE1hcChQSEFTRV9PUkRFUi5tYXAoKHApID0+IFtwLCBbXV0pKTtcbiAgICB0aGlzLnNraXBBbmltYXRpb25zID0gZmFsc2U7XG4gICAgdGhpcy5hbmltYXRpb25UaW1lQ29uc3VtZWQgPSAwO1xuICAgIC8qKiBHdWFyZCBhZ2FpbnN0IHByZW1hdHVyZSBhbmltYXRpb24gZXhlY3V0aW9uLiAqL1xuICAgIHRoaXMuaXNSZWFkeSA9IGZhbHNlO1xuICB9XG4gIGdldCBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRyb2xsZXJzLnNpemU7XG4gIH1cbiAgZ2V0IGNvbnN1bWVkVGltZU1zKCkge1xuICAgIHJldHVybiB0aGlzLmFuaW1hdGlvblRpbWVDb25zdW1lZDtcbiAgfVxuICBpc0FjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250cm9sbGVycy5zaXplID4gMDtcbiAgfVxuICBnZXRBY3RpdmVDb250cm9sbGVycygpIHtcbiAgICByZXR1cm4gdGhpcy5waGFzZXMuZ2V0KFBIQVNFX09SREVSW3RoaXMuY3VycmVudFBoYXNlXSkgPz8gW107XG4gIH1cbiAgY2hlY2tPdmVybGFwcGluZ0lkKGlkKSB7XG4gICAgaWYgKGlkICE9IG51bGwgJiYgdGhpcy5jb250cm9sbGVycy5oYXMoaWQpKSB7XG4gICAgICB0aGlzLmNvbnRyb2xsZXJzLmdldChpZCkuc3RvcCgpO1xuICAgICAgdGhpcy5kZWJ1ZyhgU2tpcHBpbmcgYW5pbWF0aW9uIGJhdGNoIGR1ZSB0byB1cGRhdGUgb2YgZXhpc3RpbmcgYW5pbWF0aW9uOiAke2lkfWApO1xuICAgICAgdGhpcy5za2lwKCk7XG4gICAgfVxuICB9XG4gIGFkZEFuaW1hdGlvbihhbmltYXRpb24pIHtcbiAgICBpZiAoYW5pbWF0aW9uLmlzQ29tcGxldGUpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgYW5pbWF0aW9uUGhhc2VJZHggPSBQSEFTRV9PUkRFUi5pbmRleE9mKGFuaW1hdGlvbi5waGFzZSk7XG4gICAgaWYgKGFuaW1hdGlvblBoYXNlSWR4IDwgdGhpcy5jdXJyZW50UGhhc2UpIHtcbiAgICAgIHRoaXMuZGVidWcoYFNraXBwaW5nIGFuaW1hdGlvbiBkdWUgdG8gYmVpbmcgZm9yIGFuIGVhcmxpZXIgcGhhc2VgLCBhbmltYXRpb24uaWQpO1xuICAgICAgYW5pbWF0aW9uLnN0b3AoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jb250cm9sbGVycy5zZXQoYW5pbWF0aW9uLmlkLCBhbmltYXRpb24pO1xuICAgIHRoaXMucGhhc2VzLmdldChhbmltYXRpb24ucGhhc2UpPy5wdXNoKGFuaW1hdGlvbik7XG4gIH1cbiAgcmVtb3ZlQW5pbWF0aW9uKGFuaW1hdGlvbikge1xuICAgIHRoaXMuY29udHJvbGxlcnMuZGVsZXRlKGFuaW1hdGlvbi5pZCk7XG4gICAgY29uc3QgcGhhc2UgPSB0aGlzLnBoYXNlcy5nZXQoYW5pbWF0aW9uLnBoYXNlKTtcbiAgICBjb25zdCBpbmRleCA9IHBoYXNlPy5pbmRleE9mKGFuaW1hdGlvbik7XG4gICAgaWYgKGluZGV4ICE9IG51bGwgJiYgaW5kZXggPj0gMCkge1xuICAgICAgcGhhc2U/LnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICB9XG4gIHByb2dyZXNzKGRlbHRhVGltZSkge1xuICAgIGlmICghdGhpcy5pc1JlYWR5KVxuICAgICAgcmV0dXJuO1xuICAgIGxldCB1bnVzZWRUaW1lID0gZGVsdGFUaW1lID09PSAwID8gMC4wMSA6IGRlbHRhVGltZTtcbiAgICBjb25zdCByZWZyZXNoID0gKCkgPT4ge1xuICAgICAgY29uc3QgcGhhc2UyID0gUEhBU0VfT1JERVJbdGhpcy5jdXJyZW50UGhhc2VdO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGhhc2VDb250cm9sbGVyczogWy4uLnRoaXMuZ2V0QWN0aXZlQ29udHJvbGxlcnMoKV0sXG4gICAgICAgIHBoYXNlOiBwaGFzZTIsXG4gICAgICAgIHBoYXNlTWV0YTogUEhBU0VfTUVUQURBVEFbcGhhc2UyXVxuICAgICAgfTtcbiAgICB9O1xuICAgIGxldCB7IHBoYXNlLCBwaGFzZUNvbnRyb2xsZXJzLCBwaGFzZU1ldGEgfSA9IHJlZnJlc2goKTtcbiAgICBjb25zdCBhcmVQaGFzZXNDb21wbGV0ZSA9ICgpID0+IFBIQVNFX09SREVSW3RoaXMuY3VycmVudFBoYXNlXSA9PSBudWxsO1xuICAgIGNvbnN0IHByb2dyZXNzUGhhc2UgPSAoKSA9PiB7XG4gICAgICAoeyBwaGFzZSwgcGhhc2VDb250cm9sbGVycywgcGhhc2VNZXRhIH0gPSByZWZyZXNoKCkpO1xuICAgICAgd2hpbGUgKCFhcmVQaGFzZXNDb21wbGV0ZSgpICYmIHBoYXNlQ29udHJvbGxlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFBoYXNlKys7XG4gICAgICAgICh7IHBoYXNlLCBwaGFzZUNvbnRyb2xsZXJzLCBwaGFzZU1ldGEgfSA9IHJlZnJlc2goKSk7XG4gICAgICAgIHRoaXMuZGVidWcoYEFuaW1hdGlvbkJhdGNoIC0gcGhhc2UgY2hhbmdpbmcgdG8gJHtwaGFzZX1gLCB7IHVudXNlZFRpbWUgfSwgcGhhc2VDb250cm9sbGVycyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB0b3RhbCA9IHRoaXMuY29udHJvbGxlcnMuc2l6ZTtcbiAgICB0aGlzLmRlYnVnKGBBbmltYXRpb25CYXRjaCAtICR7ZGVsdGFUaW1lfW1zOyBwaGFzZSAke3BoYXNlfSB3aXRoICR7cGhhc2VDb250cm9sbGVycz8ubGVuZ3RofSBvZiAke3RvdGFsfWApO1xuICAgIGRvIHtcbiAgICAgIGNvbnN0IHBoYXNlRGVsdGFUaW1lID0gdW51c2VkVGltZTtcbiAgICAgIGNvbnN0IHNraXBQaGFzZSA9IHBoYXNlTWV0YS5za2lwSWZOb0VhcmxpZXJBbmltYXRpb25zICYmIHRoaXMuYW5pbWF0aW9uVGltZUNvbnN1bWVkID09PSAwO1xuICAgICAgbGV0IGNvbXBsZXRlQ291bnQgPSAwO1xuICAgICAgZm9yIChjb25zdCBjb250cm9sbGVyIG9mIHBoYXNlQ29udHJvbGxlcnMpIHtcbiAgICAgICAgaWYgKHNraXBQaGFzZSkge1xuICAgICAgICAgIGNvbnRyb2xsZXIuc3RvcCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVudXNlZFRpbWUgPSBNYXRoLm1pbihjb250cm9sbGVyLnVwZGF0ZShwaGFzZURlbHRhVGltZSksIHVudXNlZFRpbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250cm9sbGVyLmlzQ29tcGxldGUpIHtcbiAgICAgICAgICBjb21wbGV0ZUNvdW50Kys7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBbmltYXRpb24oY29udHJvbGxlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuYW5pbWF0aW9uVGltZUNvbnN1bWVkICs9IHBoYXNlRGVsdGFUaW1lIC0gdW51c2VkVGltZTtcbiAgICAgIHRoaXMuZGVidWcoYEFuaW1hdGlvbkJhdGNoIC0gdXBkYXRlZCAke3BoYXNlQ29udHJvbGxlcnMubGVuZ3RofSBjb250cm9sbGVyczsgJHtjb21wbGV0ZUNvdW50fSBjb21wbGV0ZWRgKTtcbiAgICAgIHRoaXMuZGVidWcoYEFuaW1hdGlvbkJhdGNoIC0gYW5pbWF0aW9uVGltZUNvbnN1bWVkOiAke3RoaXMuYW5pbWF0aW9uVGltZUNvbnN1bWVkfWApO1xuICAgICAgcHJvZ3Jlc3NQaGFzZSgpO1xuICAgIH0gd2hpbGUgKHVudXNlZFRpbWUgPiAwICYmICFhcmVQaGFzZXNDb21wbGV0ZSgpKTtcbiAgICBpZiAodGhpcy5hbmltYXRpb25UaW1lQ29uc3VtZWQgPiB0aGlzLm1heEFuaW1hdGlvblRpbWUpIHtcbiAgICAgIHRoaXMuZGVidWcoYEFuaW1hdGlvbiBiYXRjaCBleGNlZWRlZCBtYXggYW5pbWF0aW9uIHRpbWUsIHNraXBwaW5nYCwgWy4uLnRoaXMuY29udHJvbGxlcnNdKTtcbiAgICAgIHRoaXMuc3RvcCgpO1xuICAgIH1cbiAgfVxuICByZWFkeSgpIHtcbiAgICBpZiAodGhpcy5pc1JlYWR5KVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuaXNSZWFkeSA9IHRydWU7XG4gICAgdGhpcy5kZWJ1ZyhgQW5pbWF0aW9uQmF0Y2ggLSByZWFkeTsgc2tpcHBlZDogJHt0aGlzLnNraXBBbmltYXRpb25zfWAsIFsuLi50aGlzLmNvbnRyb2xsZXJzXSk7XG4gICAgbGV0IHNraXBBbGwgPSB0cnVlO1xuICAgIGZvciAoY29uc3QgWywgY29udHJvbGxlcl0gb2YgdGhpcy5jb250cm9sbGVycykge1xuICAgICAgaWYgKGNvbnRyb2xsZXIuZHVyYXRpb24gPiAwICYmIFBIQVNFX01FVEFEQVRBW2NvbnRyb2xsZXIucGhhc2VdLnNraXBJZk5vRWFybGllckFuaW1hdGlvbnMgIT09IHRydWUpIHtcbiAgICAgICAgc2tpcEFsbCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFza2lwQWxsKSB7XG4gICAgICBmb3IgKGNvbnN0IFssIGNvbnRyb2xsZXJdIG9mIHRoaXMuY29udHJvbGxlcnMpIHtcbiAgICAgICAgaWYgKGNvbnRyb2xsZXIuYXV0b3BsYXkpIHtcbiAgICAgICAgICBjb250cm9sbGVyLnBsYXkodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc2tpcChza2lwID0gdHJ1ZSkge1xuICAgIGlmICh0aGlzLnNraXBBbmltYXRpb25zID09PSBmYWxzZSAmJiBza2lwID09PSB0cnVlKSB7XG4gICAgICBmb3IgKGNvbnN0IGNvbnRyb2xsZXIgb2YgdGhpcy5jb250cm9sbGVycy52YWx1ZXMoKSkge1xuICAgICAgICBjb250cm9sbGVyLnN0b3AoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY29udHJvbGxlcnMuY2xlYXIoKTtcbiAgICB9XG4gICAgdGhpcy5za2lwQW5pbWF0aW9ucyA9IHNraXA7XG4gIH1cbiAgcGxheSgpIHtcbiAgICBmb3IgKGNvbnN0IGNvbnRyb2xsZXIgb2YgdGhpcy5jb250cm9sbGVycy52YWx1ZXMoKSkge1xuICAgICAgY29udHJvbGxlci5wbGF5KCk7XG4gICAgfVxuICB9XG4gIHBhdXNlKCkge1xuICAgIGZvciAoY29uc3QgY29udHJvbGxlciBvZiB0aGlzLmNvbnRyb2xsZXJzLnZhbHVlcygpKSB7XG4gICAgICBjb250cm9sbGVyLnBhdXNlKCk7XG4gICAgfVxuICB9XG4gIHN0b3AoKSB7XG4gICAgZm9yIChjb25zdCBjb250cm9sbGVyIG9mIHRoaXMuY29udHJvbGxlcnMudmFsdWVzKCkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnRyb2xsZXIuc3RvcCgpO1xuICAgICAgICB0aGlzLnJlbW92ZUFuaW1hdGlvbihjb250cm9sbGVyKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIExvZ2dlci5lcnJvcihcIkVycm9yIGR1cmluZyBhbmltYXRpb24gc3RvcFwiLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZGlzcGF0Y2hTdG9wcGVkKCk7XG4gIH1cbiAgc3RvcEJ5QW5pbWF0aW9uSWQoaWQpIHtcbiAgICBpZiAoaWQgIT0gbnVsbCAmJiB0aGlzLmNvbnRyb2xsZXJzLmhhcyhpZCkpIHtcbiAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSB0aGlzLmNvbnRyb2xsZXJzLmdldChpZCk7XG4gICAgICBpZiAoY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyLnN0b3AoKTtcbiAgICAgICAgdGhpcy5yZW1vdmVBbmltYXRpb24oY29udHJvbGxlcik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHN0b3BCeUFuaW1hdGlvbkdyb3VwSWQoaWQpIHtcbiAgICBmb3IgKGNvbnN0IGNvbnRyb2xsZXIgb2YgdGhpcy5jb250cm9sbGVycy52YWx1ZXMoKSkge1xuICAgICAgaWYgKGNvbnRyb2xsZXIuZ3JvdXBJZCA9PT0gaWQpIHtcbiAgICAgICAgdGhpcy5zdG9wQnlBbmltYXRpb25JZChjb250cm9sbGVyLmlkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZGlzcGF0Y2hTdG9wcGVkKCkge1xuICAgIHRoaXMuc3RvcHBlZENicy5mb3JFYWNoKChjYikgPT4gY2IoKSk7XG4gICAgdGhpcy5zdG9wcGVkQ2JzLmNsZWFyKCk7XG4gIH1cbiAgaXNTa2lwcGVkKCkge1xuICAgIHJldHVybiB0aGlzLnNraXBBbmltYXRpb25zO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdG9wKCk7XG4gICAgdGhpcy5jb250cm9sbGVycy5jbGVhcigpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9pbnRlcmFjdGlvbi9wcmV2ZW50YWJsZUV2ZW50LnRzXG5mdW5jdGlvbiBidWlsZFByZXZlbnRhYmxlKG9iaikge1xuICBjb25zdCBzZWxmID0ge1xuICAgIC4uLm9iaixcbiAgICBwcmV2ZW50RGVmYXVsdCgpIHtcbiAgICAgIHNlbGYuc291cmNlRXZlbnQ/LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIGRpc3BhdGNoVHlwZWRFdmVudChsaXN0ZW5lcnMsIGV2ZW50KSB7XG4gIGxpc3RlbmVycy5kaXNwYXRjaFdyYXBIYW5kbGVycyhldmVudC50eXBlLCAoaGFuZGxlciwgZSkgPT4gaGFuZGxlcihlKSwgYnVpbGRQcmV2ZW50YWJsZShldmVudCkpO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9pbnRlcmFjdGlvbi9pbnRlcmFjdGlvbk1hbmFnZXIudHNcbnZhciBEUkFHX0lOVEVSQUNUSU9OX1RZUEVTID0gW1wiZHJhZy1zdGFydFwiLCBcImRyYWdcIiwgXCJkcmFnLWVuZFwiXTtcbnZhciBQT0lOVEVSX0lOVEVSQUNUSU9OX1RZUEVTID0gW1xuICAuLi5EUkFHX0lOVEVSQUNUSU9OX1RZUEVTLFxuICBcImNsaWNrXCIsXG4gIFwiZGJsY2xpY2tcIixcbiAgXCJjb250ZXh0bWVudVwiLFxuICBcImhvdmVyXCIsXG4gIFwibGVhdmVcIixcbiAgXCJlbnRlclwiLFxuICBcInBhZ2UtbGVmdFwiLFxuICBcIndoZWVsXCJcbl07XG52YXIgRk9DVVNfSU5URVJBQ1RJT05fVFlQRVMgPSBbXCJibHVyXCIsIFwiZm9jdXNcIl07XG52YXIgS0VZX0lOVEVSQUNUSU9OX1RZUEVTID0gW1wia2V5ZG93blwiLCBcImtleXVwXCJdO1xudmFyIFNIQURPV19ET01fSEFORExFUlMgPSBbXCJtb3VzZW1vdmVcIiwgXCJtb3VzZXVwXCJdO1xudmFyIFdJTkRPV19FVkVOVF9IQU5ETEVSUyA9IFtcInBhZ2VoaWRlXCIsIFwibW91c2Vtb3ZlXCIsIFwibW91c2V1cFwiXTtcbnZhciBFVkVOVF9IQU5ETEVSUyA9IFtcbiAgXCJkYmxjbGlja1wiLFxuICBcImNvbnRleHRtZW51XCIsXG4gIFwibW91c2Vkb3duXCIsXG4gIFwibW91c2VsZWF2ZVwiLFxuICBcIm1vdXNlZW50ZXJcIixcbiAgXCJ0b3VjaHN0YXJ0XCIsXG4gIFwidG91Y2htb3ZlXCIsXG4gIFwidG91Y2hlbmRcIixcbiAgXCJ0b3VjaGNhbmNlbFwiLFxuICBcIndoZWVsXCIsXG4gIFwiYmx1clwiLFxuICBcImZvY3VzXCIsXG4gIFwia2V5ZG93blwiLFxuICBcImtleXVwXCJcbl07XG5mdW5jdGlvbiBpc1BvaW50ZXJFdmVudCh0eXBlKSB7XG4gIHJldHVybiBQT0lOVEVSX0lOVEVSQUNUSU9OX1RZUEVTLmluY2x1ZGVzKHR5cGUpO1xufVxuZnVuY3Rpb24gaXNGb2N1c0V2ZW50KHR5cGUpIHtcbiAgcmV0dXJuIEZPQ1VTX0lOVEVSQUNUSU9OX1RZUEVTLmluY2x1ZGVzKHR5cGUpO1xufVxuZnVuY3Rpb24gaXNLZXlFdmVudCh0eXBlKSB7XG4gIHJldHVybiBLRVlfSU5URVJBQ1RJT05fVFlQRVMuaW5jbHVkZXModHlwZSk7XG59XG52YXIgX0ludGVyYWN0aW9uTWFuYWdlciA9IGNsYXNzIF9JbnRlcmFjdGlvbk1hbmFnZXIgZXh0ZW5kcyBJbnRlcmFjdGlvblN0YXRlTGlzdGVuZXIge1xuICBjb25zdHJ1Y3RvcihrZXlib2FyZE9wdGlvbnMsIGRvbU1hbmFnZXIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMua2V5Ym9hcmRPcHRpb25zID0ga2V5Ym9hcmRPcHRpb25zO1xuICAgIHRoaXMuZG9tTWFuYWdlciA9IGRvbU1hbmFnZXI7XG4gICAgdGhpcy5kZWJ1ZyA9IERlYnVnLmNyZWF0ZSh0cnVlLCBcImludGVyYWN0aW9uXCIpO1xuICAgIHRoaXMuZXZlbnRIYW5kbGVyID0gKGV2ZW50KSA9PiB0aGlzLnByb2Nlc3NFdmVudChldmVudCk7XG4gICAgdGhpcy5tb3VzZURvd24gPSBmYWxzZTtcbiAgICB0aGlzLnRvdWNoRG93biA9IGZhbHNlO1xuICAgIHRoaXMuY2xpY2tIaXN0b3J5ID0gW3sgb2Zmc2V0WDogTmFOLCBvZmZzZXRZOiBOYU4sIHR5cGU6IFwibW91c2Vkb3duXCIgfV07XG4gICAgdGhpcy5kYmxjbGlja0hpc3RvcnkgPSBbXG4gICAgICB7IG9mZnNldFg6IE5hTiwgb2Zmc2V0WTogTmFOLCB0eXBlOiBcIm1vdXNlZG93blwiIH0sXG4gICAgICB7IG9mZnNldFg6IE5hTiwgb2Zmc2V0WTogTmFOLCB0eXBlOiBcIm1vdXNldXBcIiB9LFxuICAgICAgeyBvZmZzZXRYOiBOYU4sIG9mZnNldFk6IE5hTiwgdHlwZTogXCJtb3VzZWRvd25cIiB9XG4gICAgXTtcbiAgICB0aGlzLnN0YXRlUXVldWUgPSAzMiAvKiBEZWZhdWx0ICovIHwgMiAvKiBBbmltYXRpb24gKi87XG4gICAgdGhpcy5yb290RWxlbWVudCA9IHRoaXMuZG9tTWFuYWdlci5nZXRTaGFkb3dEb2N1bWVudFJvb3QoKTtcbiAgICBmb3IgKGNvbnN0IHR5cGUgb2YgRVZFTlRfSEFORExFUlMpIHtcbiAgICAgIGlmICh0eXBlLnN0YXJ0c1dpdGgoXCJ0b3VjaFwiKSB8fCB0eXBlID09PSBcIndoZWVsXCIpIHtcbiAgICAgICAgdGhpcy5kb21NYW5hZ2VyLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgdGhpcy5ldmVudEhhbmRsZXIsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRvbU1hbmFnZXIuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCB0aGlzLmV2ZW50SGFuZGxlcik7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgdHlwZSBvZiBXSU5ET1dfRVZFTlRfSEFORExFUlMpIHtcbiAgICAgIGdldFdpbmRvdygpLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgdGhpcy5ldmVudEhhbmRsZXIpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lckNoYW5nZWQodHJ1ZSk7XG4gICAgdGhpcy5kb21NYW5hZ2VyLmFkZExpc3RlbmVyKFwiY29udGFpbmVyLWNoYW5nZWRcIiwgKCkgPT4gdGhpcy5jb250YWluZXJDaGFuZ2VkKCkpO1xuICB9XG4gIGNvbnRhaW5lckNoYW5nZWQoZm9yY2UgPSBmYWxzZSkge1xuICAgIGNvbnN0IG5ld1Jvb3QgPSB0aGlzLmRvbU1hbmFnZXIuZ2V0U2hhZG93RG9jdW1lbnRSb290KCk7XG4gICAgaWYgKCFmb3JjZSAmJiBuZXdSb290ID09PSB0aGlzLnJvb3RFbGVtZW50KVxuICAgICAgcmV0dXJuO1xuICAgIGZvciAoY29uc3QgdHlwZSBvZiBTSEFET1dfRE9NX0hBTkRMRVJTKSB7XG4gICAgICB0aGlzLnJvb3RFbGVtZW50Py5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIHRoaXMuZXZlbnRIYW5kbGVyKTtcbiAgICB9XG4gICAgdGhpcy5yb290RWxlbWVudCA9IG5ld1Jvb3Q7XG4gICAgdGhpcy5kZWJ1ZyhcIltJbnRlcmFjdGlvbk1hbmFnZXJdIFN3aXRjaGluZyByb290RWxlbWVudCB0bzpcIiwgdGhpcy5yb290RWxlbWVudCk7XG4gICAgZm9yIChjb25zdCB0eXBlIG9mIFNIQURPV19ET01fSEFORExFUlMpIHtcbiAgICAgIHRoaXMucm9vdEVsZW1lbnQ/LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgdGhpcy5ldmVudEhhbmRsZXIpO1xuICAgIH1cbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICBmb3IgKGNvbnN0IHR5cGUgb2YgV0lORE9XX0VWRU5UX0hBTkRMRVJTKSB7XG4gICAgICBnZXRXaW5kb3coKS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIHRoaXMuZXZlbnRIYW5kbGVyKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCB0eXBlIG9mIFNIQURPV19ET01fSEFORExFUlMpIHtcbiAgICAgIHRoaXMucm9vdEVsZW1lbnQ/LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgdGhpcy5ldmVudEhhbmRsZXIpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHR5cGUgb2YgRVZFTlRfSEFORExFUlMpIHtcbiAgICAgIHRoaXMuZG9tTWFuYWdlci5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIHRoaXMuZXZlbnRIYW5kbGVyKTtcbiAgICB9XG4gICAgdGhpcy5kb21NYW5hZ2VyLnJlbW92ZVN0eWxlcyhcImludGVyYWN0aW9uTWFuYWdlclwiKTtcbiAgfVxuICBwdXNoU3RhdGUoc3RhdGUpIHtcbiAgICB0aGlzLnN0YXRlUXVldWUgfD0gc3RhdGU7XG4gIH1cbiAgcG9wU3RhdGUoc3RhdGUpIHtcbiAgICB0aGlzLnN0YXRlUXVldWUgJj0gfnN0YXRlO1xuICB9XG4gIGdldFN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlUXVldWUgJiAtdGhpcy5zdGF0ZVF1ZXVlO1xuICB9XG4gIHByb2Nlc3NFdmVudChldmVudCkge1xuICAgIHRoaXMuZGVidWcoXCJSZWNlaXZlZCByYXcgZXZlbnRcIiwgZXZlbnQpO1xuICAgIGxldCB0eXBlcyA9IHRoaXMuZGVjaWRlSW50ZXJhY3Rpb25FdmVudFR5cGVzKGV2ZW50KTtcbiAgICBpZiAodHlwZXMgIT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheSh0eXBlcykpIHtcbiAgICAgIHR5cGVzID0gW3R5cGVzXTtcbiAgICB9XG4gICAgZm9yIChjb25zdCB0eXBlIG9mIHR5cGVzID8/IFtdKSB7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQsIHR5cGUpLmNhdGNoKChlKSA9PiBMb2dnZXIuZXJyb3JPbmNlKGUpKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZGlzcGF0Y2hFdmVudChldmVudCwgdHlwZSkge1xuICAgIGlmIChpc1BvaW50ZXJFdmVudCh0eXBlKSkge1xuICAgICAgdGhpcy5kaXNwYXRjaFBvaW50ZXJFdmVudChldmVudCwgdHlwZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgcmVsYXRlZEVsZW1lbnQsIHRhcmdldEVsZW1lbnQgfSA9IHRoaXMuZXh0cmFjdEVsZW1lbnRzKGV2ZW50KTtcbiAgICBpZiAoaXNGb2N1c0V2ZW50KHR5cGUpKSB7XG4gICAgICBjb25zdCBzb3VyY2VFdmVudCA9IGV2ZW50O1xuICAgICAgdGhpcy5kaXNwYXRjaFR5cGVkRXZlbnQodGhpcy5saXN0ZW5lcnMsIHsgdHlwZSwgc291cmNlRXZlbnQsIHJlbGF0ZWRFbGVtZW50LCB0YXJnZXRFbGVtZW50IH0pO1xuICAgIH0gZWxzZSBpZiAoaXNLZXlFdmVudCh0eXBlKSkge1xuICAgICAgY29uc3Qgc291cmNlRXZlbnQgPSBldmVudDtcbiAgICAgIHRoaXMuZGlzcGF0Y2hUeXBlZEV2ZW50KHRoaXMubGlzdGVuZXJzLCB7IHR5cGUsIHNvdXJjZUV2ZW50LCByZWxhdGVkRWxlbWVudCwgdGFyZ2V0RWxlbWVudCB9KTtcbiAgICB9XG4gIH1cbiAgZGlzcGF0Y2hUeXBlZEV2ZW50KGxpc3RlbmVycywgZXZlbnQpIHtcbiAgICBjb25zdCBwcmV2ZW50YWJsZUV2ZW50ID0gYnVpbGRQcmV2ZW50YWJsZShldmVudCk7XG4gICAgdGhpcy5kZWJ1ZyhcIkRpc3BhdGNoaW5nIHR5cGVkIGV2ZW50XCIsIHByZXZlbnRhYmxlRXZlbnQsIHRoaXMuZ2V0U3RhdGUoKSk7XG4gICAgbGlzdGVuZXJzLmRpc3BhdGNoV3JhcEhhbmRsZXJzKGV2ZW50LnR5cGUsIChoYW5kbGVyLCBlKSA9PiBoYW5kbGVyKGUpLCBwcmV2ZW50YWJsZUV2ZW50KTtcbiAgfVxuICBleHRyYWN0RWxlbWVudHMoZXZlbnQpIHtcbiAgICBsZXQgcmVsYXRlZEVsZW1lbnQ7XG4gICAgbGV0IHRhcmdldEVsZW1lbnQ7XG4gICAgaWYgKFwicmVsYXRlZFRhcmdldFwiIGluIGV2ZW50ICYmIGV2ZW50W1wicmVsYXRlZFRhcmdldFwiXSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICByZWxhdGVkRWxlbWVudCA9IGV2ZW50W1wicmVsYXRlZFRhcmdldFwiXTtcbiAgICB9XG4gICAgaWYgKFwidGFyZ2V0XCIgaW4gZXZlbnQgJiYgZXZlbnRbXCJ0YXJnZXRcIl0gaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgdGFyZ2V0RWxlbWVudCA9IGV2ZW50W1widGFyZ2V0XCJdO1xuICAgIH1cbiAgICByZXR1cm4geyByZWxhdGVkRWxlbWVudCwgdGFyZ2V0RWxlbWVudCB9O1xuICB9XG4gIGRpc3BhdGNoUG9pbnRlckV2ZW50KGV2ZW50LCB0eXBlKSB7XG4gICAgY29uc3QgY29vcmRzID0gdGhpcy5jYWxjdWxhdGVDb29yZGluYXRlcyhldmVudCk7XG4gICAgaWYgKGNvb3JkcyA9PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHBvaW50ZXJFdmVudCA9IHRoaXMuYnVpbGRQb2ludGVyRXZlbnQoeyB0eXBlLCBldmVudCwgLi4uY29vcmRzIH0pO1xuICAgIHRoaXMuZGVidWcoXCJEaXNwYXRjaGluZyBwb2ludGVyIGV2ZW50XCIsIHBvaW50ZXJFdmVudCwgdGhpcy5nZXRTdGF0ZSgpKTtcbiAgICBkaXNwYXRjaFR5cGVkRXZlbnQodGhpcy5saXN0ZW5lcnMsIHBvaW50ZXJFdmVudCk7XG4gIH1cbiAgZ2V0RXZlbnRIVE1MVGFyZ2V0KGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICByZXR1cm4gZXZlbnQudGFyZ2V0O1xuICAgIH0gZWxzZSBpZiAoZXZlbnQuY3VycmVudFRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICByZXR1cm4gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZWNvcmREb3duKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgTW91c2VFdmVudCkge1xuICAgICAgcGFydGlhbEFzc2lnbihbXCJvZmZzZXRYXCIsIFwib2Zmc2V0WVwiXSwgdGhpcy5jbGlja0hpc3RvcnlbMF0sIGV2ZW50KTtcbiAgICAgIHBhcnRpYWxBc3NpZ24oW1wib2Zmc2V0WFwiLCBcIm9mZnNldFlcIl0sIHRoaXMuZGJsY2xpY2tIaXN0b3J5WzJdLCB0aGlzLmRibGNsaWNrSGlzdG9yeVswXSk7XG4gICAgICBwYXJ0aWFsQXNzaWduKFtcIm9mZnNldFhcIiwgXCJvZmZzZXRZXCJdLCB0aGlzLmRibGNsaWNrSGlzdG9yeVswXSwgZXZlbnQpO1xuICAgIH1cbiAgICB0aGlzLmRyYWdQcmVTdGFydEVsZW1lbnQgPSB0aGlzLmdldEV2ZW50SFRNTFRhcmdldChldmVudCk7XG4gIH1cbiAgcmVjb3JkVXAoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQgaW5zdGFuY2VvZiBNb3VzZUV2ZW50KSB7XG4gICAgICBwYXJ0aWFsQXNzaWduKFtcIm9mZnNldFhcIiwgXCJvZmZzZXRZXCJdLCB0aGlzLmRibGNsaWNrSGlzdG9yeVsxXSwgZXZlbnQpO1xuICAgIH1cbiAgICB0aGlzLmRyYWdQcmVTdGFydEVsZW1lbnQgPSB2b2lkIDA7XG4gICAgaWYgKHRoaXMuZHJhZ1N0YXJ0RWxlbWVudCkge1xuICAgICAgdGhpcy5kcmFnU3RhcnRFbGVtZW50ID0gdm9pZCAwO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBkZWNpZGVJbnRlcmFjdGlvbkV2ZW50VHlwZXMoZXZlbnQpIHtcbiAgICBjb25zdCBkcmFnU3RhcnQgPSBcImRyYWctc3RhcnRcIjtcbiAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgIGNhc2UgXCJibHVyXCI6XG4gICAgICBjYXNlIFwiZm9jdXNcIjpcbiAgICAgIGNhc2UgXCJrZXlkb3duXCI6XG4gICAgICBjYXNlIFwia2V5dXBcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5Ym9hcmRPcHRpb25zLmVuYWJsZWQgPyBldmVudC50eXBlIDogdm9pZCAwO1xuICAgICAgY2FzZSBcImRibGNsaWNrXCI6XG4gICAgICAgIHJldHVybiBldmVudC50eXBlO1xuICAgICAgY2FzZSBcImNvbnRleHRtZW51XCI6XG4gICAgICBjYXNlIFwid2hlZWxcIjpcbiAgICAgICAgcmV0dXJuIGV2ZW50LnR5cGU7XG4gICAgICBjYXNlIFwibW91c2Vkb3duXCI6XG4gICAgICAgIGlmICghdGhpcy5pc0V2ZW50T3ZlckVsZW1lbnQoZXZlbnQpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW91c2VEb3duID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZWNvcmREb3duKGV2ZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcInRvdWNoc3RhcnRcIjpcbiAgICAgICAgaWYgKCF0aGlzLmlzRXZlbnRPdmVyRWxlbWVudChldmVudCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b3VjaERvd24gPSB0cnVlO1xuICAgICAgICB0aGlzLnJlY29yZERvd24oZXZlbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwidG91Y2htb3ZlXCI6XG4gICAgICBjYXNlIFwibW91c2Vtb3ZlXCI6XG4gICAgICAgIGlmICghdGhpcy5tb3VzZURvd24gJiYgIXRoaXMudG91Y2hEb3duICYmICF0aGlzLmlzRXZlbnRPdmVyRWxlbWVudChldmVudCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLm1vdXNlRG93biAmJiAhdGhpcy50b3VjaERvd24pXG4gICAgICAgICAgcmV0dXJuIFwiaG92ZXJcIjtcbiAgICAgICAgaWYgKHRoaXMuZHJhZ1N0YXJ0RWxlbWVudClcbiAgICAgICAgICByZXR1cm4gXCJkcmFnXCI7XG4gICAgICAgIHRoaXMuZHJhZ1N0YXJ0RWxlbWVudCA9IHRoaXMuZHJhZ1ByZVN0YXJ0RWxlbWVudDtcbiAgICAgICAgdGhpcy5kcmFnUHJlU3RhcnRFbGVtZW50ID0gdm9pZCAwO1xuICAgICAgICByZXR1cm4gW2RyYWdTdGFydCwgXCJkcmFnXCJdO1xuICAgICAgY2FzZSBcIm1vdXNldXBcIjpcbiAgICAgICAgaWYgKCF0aGlzLm1vdXNlRG93biAmJiAhdGhpcy5pc0V2ZW50T3ZlckVsZW1lbnQoZXZlbnQpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW91c2VEb3duID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzLnJlY29yZFVwKGV2ZW50KSA/IFwiZHJhZy1lbmRcIiA6IFwiY2xpY2tcIjtcbiAgICAgIGNhc2UgXCJ0b3VjaGVuZFwiOlxuICAgICAgICBpZiAoIXRoaXMudG91Y2hEb3duICYmICF0aGlzLmlzRXZlbnRPdmVyRWxlbWVudChldmVudCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b3VjaERvd24gPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVjb3JkVXAoZXZlbnQpID8gXCJkcmFnLWVuZFwiIDogXCJjbGlja1wiO1xuICAgICAgY2FzZSBcIm1vdXNlbGVhdmVcIjpcbiAgICAgIGNhc2UgXCJ0b3VjaGNhbmNlbFwiOlxuICAgICAgICByZXR1cm4gXCJsZWF2ZVwiO1xuICAgICAgY2FzZSBcIm1vdXNlZW50ZXJcIjpcbiAgICAgICAgcmV0dXJuIFwiZW50ZXJcIjtcbiAgICAgIGNhc2UgXCJwYWdlaGlkZVwiOlxuICAgICAgICByZXR1cm4gXCJwYWdlLWxlZnRcIjtcbiAgICB9XG4gIH1cbiAgaXNFdmVudE92ZXJFbGVtZW50KGV2ZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuZG9tTWFuYWdlci5pc0V2ZW50T3ZlckVsZW1lbnQoZXZlbnQpO1xuICB9XG4gIGNhbGN1bGF0ZUNvb3JkaW5hdGVzKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgTW91c2VFdmVudCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0TW91c2VFdmVudENvb3JkcyhldmVudCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgVG91Y2hFdmVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBldmVudCBpbnN0YW5jZW9mIFRvdWNoRXZlbnQpIHtcbiAgICAgIGNvbnN0IGxhc3RUb3VjaCA9IGV2ZW50LnRvdWNoZXNbMF0gPz8gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgICBjb25zdCB7IGNsaWVudFgsIGNsaWVudFksIHBhZ2VYLCBwYWdlWSB9ID0gbGFzdFRvdWNoO1xuICAgICAgcmV0dXJuIHsgLi4uX0ludGVyYWN0aW9uTWFuYWdlci5OVUxMX0NPT1JEUywgY2xpZW50WCwgY2xpZW50WSwgcGFnZVgsIHBhZ2VZIH07XG4gICAgfSBlbHNlIGlmIChldmVudCBpbnN0YW5jZW9mIFBhZ2VUcmFuc2l0aW9uRXZlbnQpIHtcbiAgICAgIGlmIChldmVudC5wZXJzaXN0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9JbnRlcmFjdGlvbk1hbmFnZXIuTlVMTF9DT09SRFM7XG4gICAgfVxuICB9XG4gIGdldE1vdXNlRXZlbnRDb29yZHMoZXZlbnQpIHtcbiAgICBjb25zdCB7IGNsaWVudFgsIGNsaWVudFksIHBhZ2VYLCBwYWdlWSB9ID0gZXZlbnQ7XG4gICAgbGV0IHsgb2Zmc2V0WCwgb2Zmc2V0WSB9ID0gZXZlbnQ7XG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5nZXRFdmVudEhUTUxUYXJnZXQoZXZlbnQpO1xuICAgIGNvbnN0IHsgeCA9IDAsIHkgPSAwIH0gPSB0YXJnZXQgPyB0aGlzLmRvbU1hbmFnZXIuY2FsY3VsYXRlQ2FudmFzUG9zaXRpb24odGFyZ2V0KSA6IHt9O1xuICAgIGlmICh0aGlzLmRyYWdTdGFydEVsZW1lbnQgIT0gbnVsbCAmJiBldmVudC50YXJnZXQgIT09IHRoaXMuZHJhZ1N0YXJ0RWxlbWVudCkge1xuICAgICAgY29uc3Qgb2Zmc2V0RHJhZ1N0YXJ0ID0gdGhpcy5kb21NYW5hZ2VyLmNhbGN1bGF0ZUNhbnZhc1Bvc2l0aW9uKHRoaXMuZHJhZ1N0YXJ0RWxlbWVudCk7XG4gICAgICBvZmZzZXRYIC09IG9mZnNldERyYWdTdGFydC54IC0geDtcbiAgICAgIG9mZnNldFkgLT0gb2Zmc2V0RHJhZ1N0YXJ0LnkgLSB5O1xuICAgIH0gZWxzZSB7XG4gICAgICBvZmZzZXRYICs9IHg7XG4gICAgICBvZmZzZXRZICs9IHk7XG4gICAgfVxuICAgIHJldHVybiB7IGNsaWVudFgsIGNsaWVudFksIHBhZ2VYLCBwYWdlWSwgb2Zmc2V0WCwgb2Zmc2V0WSB9O1xuICB9XG4gIGlzV2hlZWxFdmVudChldmVudCkge1xuICAgIHJldHVybiBldmVudC50eXBlID09PSBcIndoZWVsXCI7XG4gIH1cbiAgYnVpbGRQb2ludGVyRXZlbnQob3B0cykge1xuICAgIGNvbnN0IHsgdHlwZSwgZXZlbnQsIGNsaWVudFgsIGNsaWVudFkgfSA9IG9wdHM7XG4gICAgbGV0IHsgb2Zmc2V0WCwgb2Zmc2V0WSwgcGFnZVgsIHBhZ2VZIH0gPSBvcHRzO1xuICAgIGlmICghaXNGaW5pdGVOdW1iZXIob2Zmc2V0WCkgfHwgIWlzRmluaXRlTnVtYmVyKG9mZnNldFkpKSB7XG4gICAgICBjb25zdCByZWN0ID0gdGhpcy5kb21NYW5hZ2VyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgb2Zmc2V0WCA9IGNsaWVudFggLSByZWN0LmxlZnQ7XG4gICAgICBvZmZzZXRZID0gY2xpZW50WSAtIHJlY3QudG9wO1xuICAgIH1cbiAgICBpZiAoIWlzRmluaXRlTnVtYmVyKHBhZ2VYKSB8fCAhaXNGaW5pdGVOdW1iZXIocGFnZVkpKSB7XG4gICAgICBjb25zdCBwYWdlUmVjdCA9IHRoaXMucm9vdEVsZW1lbnQ/LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgcGFnZVggPSBjbGllbnRYIC0gKHBhZ2VSZWN0Py5sZWZ0ID8/IDApO1xuICAgICAgcGFnZVkgPSBjbGllbnRZIC0gKHBhZ2VSZWN0Py50b3AgPz8gMCk7XG4gICAgfVxuICAgIGxldCBbZGVsdGFYLCBkZWx0YVldID0gW05hTiwgTmFOXTtcbiAgICBpZiAodGhpcy5pc1doZWVsRXZlbnQoZXZlbnQpKSB7XG4gICAgICBjb25zdCBmYWN0b3IgPSBldmVudC5kZWx0YU1vZGUgPT09IDAgPyAwLjAxIDogMTtcbiAgICAgIGRlbHRhWCA9IGV2ZW50LmRlbHRhWCAqIGZhY3RvcjtcbiAgICAgIGRlbHRhWSA9IGV2ZW50LmRlbHRhWSAqIGZhY3RvcjtcbiAgICB9XG4gICAgbGV0IHBvaW50ZXJIaXN0b3J5ID0gW107XG4gICAgaWYgKGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIikge1xuICAgICAgcG9pbnRlckhpc3RvcnkgPSB0aGlzLmNsaWNrSGlzdG9yeTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50LnR5cGUgPT09IFwiZGJsY2xpY2tcIikge1xuICAgICAgcG9pbnRlckhpc3RvcnkgPSB0aGlzLmRibGNsaWNrSGlzdG9yeTtcbiAgICB9XG4gICAgY29uc3QgeyByZWxhdGVkRWxlbWVudCwgdGFyZ2V0RWxlbWVudCB9ID0gdGhpcy5leHRyYWN0RWxlbWVudHMoZXZlbnQpO1xuICAgIGNvbnN0IGJ1dHRvbiA9IFwiYnV0dG9uXCIgaW4gZXZlbnQgPyBOdW1iZXIoZXZlbnQuYnV0dG9uKSA6IDA7XG4gICAgY29uc3QgYnVpbHRFdmVudCA9IHtcbiAgICAgIHR5cGUsXG4gICAgICBvZmZzZXRYLFxuICAgICAgb2Zmc2V0WSxcbiAgICAgIHBhZ2VYLFxuICAgICAgcGFnZVksXG4gICAgICBkZWx0YVgsXG4gICAgICBkZWx0YVksXG4gICAgICBidXR0b24sXG4gICAgICBwb2ludGVySGlzdG9yeSxcbiAgICAgIHNvdXJjZUV2ZW50OiBldmVudCxcbiAgICAgIHJlbGF0ZWRFbGVtZW50LFxuICAgICAgdGFyZ2V0RWxlbWVudFxuICAgIH07XG4gICAgdGhpcy5kZWJ1ZyhcIkludGVyYWN0aW9uTWFuYWdlciAtIGJ1aWx0RXZlbnQ6IFwiLCBidWlsdEV2ZW50LCB0aGlzLmdldFN0YXRlKCkpO1xuICAgIHJldHVybiBidWlsdEV2ZW50O1xuICB9XG59O1xuX0ludGVyYWN0aW9uTWFuYWdlci5OVUxMX0NPT1JEUyA9IHtcbiAgY2xpZW50WDogLUluZmluaXR5LFxuICBjbGllbnRZOiAtSW5maW5pdHksXG4gIHBhZ2VYOiAtSW5maW5pdHksXG4gIHBhZ2VZOiAtSW5maW5pdHksXG4gIG9mZnNldFg6IC1JbmZpbml0eSxcbiAgb2Zmc2V0WTogLUluZmluaXR5XG59O1xudmFyIEludGVyYWN0aW9uTWFuYWdlciA9IF9JbnRlcmFjdGlvbk1hbmFnZXI7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2ludGVyYWN0aW9uL2FuaW1hdGlvbk1hbmFnZXIudHNcbmZ1bmN0aW9uIHZhbGlkQW5pbWF0aW9uRHVyYXRpb24odGVzdGVlKSB7XG4gIGlmICh0ZXN0ZWUgPT0gbnVsbClcbiAgICByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuICFpc05hTih0ZXN0ZWUpICYmIHRlc3RlZSA+PSAwICYmIHRlc3RlZSA8PSAyO1xufVxudmFyIEFuaW1hdGlvbk1hbmFnZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGludGVyYWN0aW9uTWFuYWdlciwgY2hhcnRVcGRhdGVNdXRleCkge1xuICAgIHRoaXMuaW50ZXJhY3Rpb25NYW5hZ2VyID0gaW50ZXJhY3Rpb25NYW5hZ2VyO1xuICAgIHRoaXMuY2hhcnRVcGRhdGVNdXRleCA9IGNoYXJ0VXBkYXRlTXV0ZXg7XG4gICAgdGhpcy5kZWZhdWx0RHVyYXRpb24gPSAxZTM7XG4gICAgdGhpcy5iYXRjaCA9IG5ldyBBbmltYXRpb25CYXRjaCh0aGlzLmRlZmF1bHREdXJhdGlvbiAqIDEuNSk7XG4gICAgdGhpcy5kZWJ1ZyA9IERlYnVnLmNyZWF0ZSh0cnVlLCBcImFuaW1hdGlvblwiKTtcbiAgICB0aGlzLmV2ZW50cyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB0aGlzLnJhZkF2YWlsYWJsZSA9IHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgIT09IFwidW5kZWZpbmVkXCI7XG4gICAgdGhpcy5pc1BsYXlpbmcgPSB0cnVlO1xuICAgIHRoaXMucmVxdWVzdElkID0gbnVsbDtcbiAgICB0aGlzLnNraXBBbmltYXRpb25zID0gdHJ1ZTtcbiAgICB0aGlzLmN1cnJlbnRBbm9ueW1vdXNBbmltYXRpb25JZCA9IDA7XG4gIH1cbiAgYWRkTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgIHJldHVybiB0aGlzLmV2ZW50cy5vbihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGFuIGFuaW1hdGlvbiB0byB0d2VlbiBhIHZhbHVlIGJldHdlZW4gdGhlIGBmcm9tYCBhbmQgYHRvYCBwcm9wZXJ0aWVzLiBJZiBhbiBhbmltYXRpb24gYWxyZWFkeSBleGlzdHNcbiAgICogd2l0aCB0aGUgc2FtZSBgaWRgLCBpbW1lZGlhdGVseSBzdG9wIGl0LlxuICAgKi9cbiAgYW5pbWF0ZShvcHRzKSB7XG4gICAgY29uc3QgYmF0Y2ggPSB0aGlzLmJhdGNoO1xuICAgIHRyeSB7XG4gICAgICBiYXRjaC5jaGVja092ZXJsYXBwaW5nSWQob3B0cy5pZCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMuZmFpbHNhZmVPbkVycm9yKGVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHsgaWQgfSA9IG9wdHM7XG4gICAgaWYgKGlkID09IG51bGwpIHtcbiAgICAgIGlkID0gYF9fJHt0aGlzLmN1cnJlbnRBbm9ueW1vdXNBbmltYXRpb25JZH1gO1xuICAgICAgdGhpcy5jdXJyZW50QW5vbnltb3VzQW5pbWF0aW9uSWQgKz0gMTtcbiAgICB9XG4gICAgY29uc3Qgc2tpcCA9IHRoaXMuaXNTa2lwcGVkKCkgfHwgb3B0cy5waGFzZSA9PT0gXCJub25lXCI7XG4gICAgaWYgKHNraXApIHtcbiAgICAgIHRoaXMuZGVidWcoXCJBbmltYXRpb25NYW5hZ2VyIC0gc2tpcHBpbmcgYW5pbWF0aW9uXCIpO1xuICAgIH1cbiAgICBjb25zdCB7IGRlbGF5LCBkdXJhdGlvbiB9ID0gb3B0cztcbiAgICBpZiAoIXZhbGlkQW5pbWF0aW9uRHVyYXRpb24oZGVsYXkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFuaW1hdGlvbiBkZWxheSBvZiAke2RlbGF5fSBpcyB1bnN1cHBvcnRlZCAoJHtpZH0pYCk7XG4gICAgfVxuICAgIGlmICghdmFsaWRBbmltYXRpb25EdXJhdGlvbihkdXJhdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQW5pbWF0aW9uIGR1cmF0aW9uIG9mICR7ZHVyYXRpb259IGlzIHVuc3VwcG9ydGVkICgke2lkfSlgKTtcbiAgICB9XG4gICAgY29uc3QgYW5pbWF0aW9uID0gbmV3IEFuaW1hdGlvbih7XG4gICAgICAuLi5vcHRzLFxuICAgICAgaWQsXG4gICAgICBza2lwLFxuICAgICAgYXV0b3BsYXk6IHRoaXMuaXNQbGF5aW5nID8gb3B0cy5hdXRvcGxheSA6IGZhbHNlLFxuICAgICAgcGhhc2U6IG9wdHMucGhhc2UsXG4gICAgICBkZWZhdWx0RHVyYXRpb246IHRoaXMuZGVmYXVsdER1cmF0aW9uXG4gICAgfSk7XG4gICAgaWYgKHRoaXMuZm9yY2VUaW1lSnVtcChhbmltYXRpb24sIHRoaXMuZGVmYXVsdER1cmF0aW9uKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmJhdGNoLmFkZEFuaW1hdGlvbihhbmltYXRpb24pO1xuICAgIHJldHVybiBhbmltYXRpb247XG4gIH1cbiAgcGxheSgpIHtcbiAgICBpZiAodGhpcy5pc1BsYXlpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5pc1BsYXlpbmcgPSB0cnVlO1xuICAgIHRoaXMuZGVidWcoXCJBbmltYXRpb25NYW5hZ2VyLnBsYXkoKVwiKTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5iYXRjaC5wbGF5KCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMuZmFpbHNhZmVPbkVycm9yKGVycm9yKTtcbiAgICB9XG4gICAgdGhpcy5yZXF1ZXN0QW5pbWF0aW9uKCk7XG4gIH1cbiAgcGF1c2UoKSB7XG4gICAgaWYgKCF0aGlzLmlzUGxheWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuICAgIHRoaXMuY2FuY2VsQW5pbWF0aW9uKCk7XG4gICAgdGhpcy5kZWJ1ZyhcIkFuaW1hdGlvbk1hbmFnZXIucGF1c2UoKVwiKTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5iYXRjaC5wYXVzZSgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmZhaWxzYWZlT25FcnJvcihlcnJvcik7XG4gICAgfVxuICB9XG4gIHN0b3AoKSB7XG4gICAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmNhbmNlbEFuaW1hdGlvbigpO1xuICAgIHRoaXMuZGVidWcoXCJBbmltYXRpb25NYW5hZ2VyLnN0b3AoKVwiKTtcbiAgICB0aGlzLmJhdGNoLnN0b3AoKTtcbiAgfVxuICBzdG9wQnlBbmltYXRpb25JZChpZCkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmJhdGNoLnN0b3BCeUFuaW1hdGlvbklkKGlkKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5mYWlsc2FmZU9uRXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfVxuICBzdG9wQnlBbmltYXRpb25Hcm91cElkKGlkKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuYmF0Y2guc3RvcEJ5QW5pbWF0aW9uR3JvdXBJZChpZCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMuZmFpbHNhZmVPbkVycm9yKGVycm9yKTtcbiAgICB9XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgaWYgKHRoaXMuaXNQbGF5aW5nKSB7XG4gICAgICB0aGlzLnN0b3AoKTtcbiAgICAgIHRoaXMucGxheSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0b3AoKTtcbiAgICB9XG4gIH1cbiAgc2tpcChza2lwID0gdHJ1ZSkge1xuICAgIHRoaXMuc2tpcEFuaW1hdGlvbnMgPSBza2lwO1xuICB9XG4gIGlzU2tpcHBlZCgpIHtcbiAgICByZXR1cm4gIXRoaXMucmFmQXZhaWxhYmxlIHx8IHRoaXMuc2tpcEFuaW1hdGlvbnMgfHwgdGhpcy5iYXRjaC5pc1NraXBwZWQoKTtcbiAgfVxuICBpc0FjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1BsYXlpbmcgJiYgdGhpcy5iYXRjaC5pc0FjdGl2ZSgpO1xuICB9XG4gIHNraXBDdXJyZW50QmF0Y2goKSB7XG4gICAgaWYgKHRoaXMuZGVidWcuY2hlY2soKSkge1xuICAgICAgdGhpcy5kZWJ1ZyhgQW5pbWF0aW9uTWFuYWdlciAtIHNraXBDdXJyZW50QmF0Y2goKWAsIHsgc3RhY2s6IG5ldyBFcnJvcigpLnN0YWNrIH0pO1xuICAgIH1cbiAgICB0aGlzLmJhdGNoLnNraXAoKTtcbiAgfVxuICAvKiogTW9ja2luZyBwb2ludCBmb3IgdGVzdHMgdG8gZ3VhcmFudGVlIHRoYXQgYW5pbWF0aW9uIHVwZGF0ZXMgaGFwcGVuLiAqL1xuICBpc1NraXBwaW5nRnJhbWVzKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKiBNb2NraW5nIHBvaW50IGZvciB0ZXN0cyB0byBjYXB0dXJlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBjYWxsYmFja3MuICovXG4gIHNjaGVkdWxlQW5pbWF0aW9uRnJhbWUoY2IpIHtcbiAgICB0aGlzLnJlcXVlc3RJZCA9IGdldFdpbmRvdygpLnJlcXVlc3RBbmltYXRpb25GcmFtZShjYik7XG4gIH1cbiAgLyoqIE1vY2tpbmcgcG9pbnQgZm9yIHRlc3RzIHRvIHNraXAgYW5pbWF0aW9ucyB0byBhIHNwZWNpZmljIHBvaW50IGluIHRpbWUuICovXG4gIGZvcmNlVGltZUp1bXAoX2FuaW1hdGlvbiwgX2RlZmF1bHREdXJhdGlvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXF1ZXN0QW5pbWF0aW9uKCkge1xuICAgIGlmICghdGhpcy5yYWZBdmFpbGFibGUpXG4gICAgICByZXR1cm47XG4gICAgaWYgKCF0aGlzLmJhdGNoLmlzQWN0aXZlKCkgfHwgdGhpcy5yZXF1ZXN0SWQgIT09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgbGV0IHByZXZUaW1lO1xuICAgIGNvbnN0IG9uQW5pbWF0aW9uRnJhbWUgPSBhc3luYyAodGltZTIpID0+IHtcbiAgICAgIGNvbnN0IGV4ZWN1dGVBbmltYXRpb25GcmFtZSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgZGVsdGFUaW1lID0gdGltZTIgLSAocHJldlRpbWUgPz8gdGltZTIpO1xuICAgICAgICBwcmV2VGltZSA9IHRpbWUyO1xuICAgICAgICB0aGlzLmRlYnVnKFwiQW5pbWF0aW9uTWFuYWdlciAtIG9uQW5pbWF0aW9uRnJhbWUoKVwiLCB7XG4gICAgICAgICAgY29udHJvbGxlcnNDb3VudDogdGhpcy5iYXRjaC5zaXplLFxuICAgICAgICAgIGRlbHRhVGltZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5pbnRlcmFjdGlvbk1hbmFnZXIucHVzaFN0YXRlKDIgLyogQW5pbWF0aW9uICovKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmJhdGNoLnByb2dyZXNzKGRlbHRhVGltZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgdGhpcy5mYWlsc2FmZU9uRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXZlbnRzLmVtaXQoXCJhbmltYXRpb24tZnJhbWVcIiwge1xuICAgICAgICAgIHR5cGU6IFwiYW5pbWF0aW9uLWZyYW1lXCIsXG4gICAgICAgICAgZGVsdGFNczogZGVsdGFUaW1lXG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmlzU2tpcHBpbmdGcmFtZXMoKSkge1xuICAgICAgICBhd2FpdCB0aGlzLmNoYXJ0VXBkYXRlTXV0ZXguYWNxdWlyZUltbWVkaWF0ZWx5KGV4ZWN1dGVBbmltYXRpb25GcmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhd2FpdCB0aGlzLmNoYXJ0VXBkYXRlTXV0ZXguYWNxdWlyZShleGVjdXRlQW5pbWF0aW9uRnJhbWUpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuYmF0Y2guaXNBY3RpdmUoKSkge1xuICAgICAgICB0aGlzLnNjaGVkdWxlQW5pbWF0aW9uRnJhbWUob25BbmltYXRpb25GcmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJhdGNoLnN0b3AoKTtcbiAgICAgICAgdGhpcy5ldmVudHMuZW1pdChcImFuaW1hdGlvbi1zdG9wXCIsIHtcbiAgICAgICAgICB0eXBlOiBcImFuaW1hdGlvbi1zdG9wXCIsXG4gICAgICAgICAgZGVsdGFNczogdGhpcy5iYXRjaC5jb25zdW1lZFRpbWVNc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuZXZlbnRzLmVtaXQoXCJhbmltYXRpb24tc3RhcnRcIiwge1xuICAgICAgdHlwZTogXCJhbmltYXRpb24tc3RhcnRcIixcbiAgICAgIGRlbHRhTXM6IDBcbiAgICB9KTtcbiAgICB0aGlzLnNjaGVkdWxlQW5pbWF0aW9uRnJhbWUob25BbmltYXRpb25GcmFtZSk7XG4gIH1cbiAgY2FuY2VsQW5pbWF0aW9uKCkge1xuICAgIGlmICh0aGlzLnJlcXVlc3RJZCA9PT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnJlcXVlc3RJZCk7XG4gICAgdGhpcy5yZXF1ZXN0SWQgPSBudWxsO1xuICAgIHRoaXMuc3RhcnRCYXRjaCgpO1xuICB9XG4gIGZhaWxzYWZlT25FcnJvcihlcnJvciwgY2FuY2VsQW5pbWF0aW9uID0gdHJ1ZSkge1xuICAgIExvZ2dlci5lcnJvcihcIkVycm9yIGR1cmluZyBhbmltYXRpb24sIHNraXBwaW5nIGFuaW1hdGlvbnNcIiwgZXJyb3IpO1xuICAgIGlmIChjYW5jZWxBbmltYXRpb24pIHtcbiAgICAgIHRoaXMuY2FuY2VsQW5pbWF0aW9uKCk7XG4gICAgfVxuICB9XG4gIHN0YXJ0QmF0Y2goc2tpcEFuaW1hdGlvbnMpIHtcbiAgICB0aGlzLmRlYnVnKGBBbmltYXRpb25NYW5hZ2VyIC0gc3RhcnRCYXRjaCgpIHdpdGggc2tpcEFuaW1hdGlvbnM9JHtza2lwQW5pbWF0aW9uc30uYCk7XG4gICAgdGhpcy5yZXNldCgpO1xuICAgIHRoaXMuYmF0Y2guZGVzdHJveSgpO1xuICAgIHRoaXMuYmF0Y2ggPSBuZXcgQW5pbWF0aW9uQmF0Y2godGhpcy5kZWZhdWx0RHVyYXRpb24gKiAxLjUpO1xuICAgIGlmIChza2lwQW5pbWF0aW9ucyA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5iYXRjaC5za2lwKCk7XG4gICAgfVxuICB9XG4gIGVuZEJhdGNoKCkge1xuICAgIGlmICh0aGlzLmJhdGNoLmlzQWN0aXZlKCkpIHtcbiAgICAgIHRoaXMuYmF0Y2gucmVhZHkoKTtcbiAgICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmludGVyYWN0aW9uTWFuYWdlci5wb3BTdGF0ZSgyIC8qIEFuaW1hdGlvbiAqLyk7XG4gICAgICBpZiAodGhpcy5iYXRjaC5pc1NraXBwZWQoKSkge1xuICAgICAgICB0aGlzLmJhdGNoLnNraXAoZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBvbkJhdGNoU3RvcChjYikge1xuICAgIHRoaXMuYmF0Y2guc3RvcHBlZENicy5hZGQoY2IpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdG9wKCk7XG4gICAgdGhpcy5ldmVudHMuY2xlYXIoKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvaW50ZXJhY3Rpb24vY2hhcnRFdmVudE1hbmFnZXIudHNcbnZhciBDaGFydEV2ZW50TWFuYWdlciA9IGNsYXNzIGV4dGVuZHMgQmFzZU1hbmFnZXIge1xuICBsZWdlbmRJdGVtQ2xpY2soc2VyaWVzLCBpdGVtSWQsIGVuYWJsZWQsIGxlZ2VuZEl0ZW1OYW1lKSB7XG4gICAgY29uc3QgZXZlbnQgPSB7XG4gICAgICB0eXBlOiBcImxlZ2VuZC1pdGVtLWNsaWNrXCIsXG4gICAgICBzZXJpZXMsXG4gICAgICBpdGVtSWQsXG4gICAgICBlbmFibGVkLFxuICAgICAgbGVnZW5kSXRlbU5hbWVcbiAgICB9O1xuICAgIHRoaXMubGlzdGVuZXJzLmRpc3BhdGNoKFwibGVnZW5kLWl0ZW0tY2xpY2tcIiwgZXZlbnQpO1xuICB9XG4gIGxlZ2VuZEl0ZW1Eb3VibGVDbGljayhzZXJpZXMsIGl0ZW1JZCwgZW5hYmxlZCwgbnVtVmlzaWJsZUl0ZW1zLCBsZWdlbmRJdGVtTmFtZSkge1xuICAgIGNvbnN0IGV2ZW50ID0ge1xuICAgICAgdHlwZTogXCJsZWdlbmQtaXRlbS1kb3VibGUtY2xpY2tcIixcbiAgICAgIHNlcmllcyxcbiAgICAgIGl0ZW1JZCxcbiAgICAgIGVuYWJsZWQsXG4gICAgICBsZWdlbmRJdGVtTmFtZSxcbiAgICAgIG51bVZpc2libGVJdGVtc1xuICAgIH07XG4gICAgdGhpcy5saXN0ZW5lcnMuZGlzcGF0Y2goXCJsZWdlbmQtaXRlbS1kb3VibGUtY2xpY2tcIiwgZXZlbnQpO1xuICB9XG4gIGF4aXNIb3ZlcihheGlzSWQsIGRpcmVjdGlvbikge1xuICAgIGNvbnN0IGV2ZW50ID0ge1xuICAgICAgdHlwZTogXCJheGlzLWhvdmVyXCIsXG4gICAgICBheGlzSWQsXG4gICAgICBkaXJlY3Rpb25cbiAgICB9O1xuICAgIHRoaXMubGlzdGVuZXJzLmRpc3BhdGNoKFwiYXhpcy1ob3ZlclwiLCBldmVudCk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2ludGVyYWN0aW9uL2NvbnRleHRNZW51UmVnaXN0cnkudHNcbnZhciBDb250ZXh0TWVudVJlZ2lzdHJ5ID0gY2xhc3MgX0NvbnRleHRNZW51UmVnaXN0cnkge1xuICBjb25zdHJ1Y3RvcihyZWdpb25NYW5hZ2VyKSB7XG4gICAgdGhpcy5kZWZhdWx0QWN0aW9ucyA9IFtdO1xuICAgIHRoaXMuZGlzYWJsZWRBY3Rpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLmhpZGRlbkFjdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMubGlzdGVuZXJzID0gbmV3IExpc3RlbmVycygpO1xuICAgIGNvbnN0IHsgRGVmYXVsdDogRGVmYXVsdDIsIENvbnRleHRNZW51IH0gPSBJbnRlcmFjdGlvblN0YXRlO1xuICAgIHRoaXMuZGVzdHJveUZucyA9IFtyZWdpb25NYW5hZ2VyLmxpc3RlbkFsbChcImNvbnRleHRtZW51XCIsIChlKSA9PiB0aGlzLm9uQ29udGV4dE1lbnUoZSksIERlZmF1bHQyIHwgQ29udGV4dE1lbnUpXTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveUZucy5mb3JFYWNoKChkKSA9PiBkKCkpO1xuICB9XG4gIG9uQ29udGV4dE1lbnUoZXZlbnQpIHtcbiAgICBjb25zdCB0eXBlID0gX0NvbnRleHRNZW51UmVnaXN0cnkudG9Db250ZXh0VHlwZShldmVudC5yZWdpb24pO1xuICAgIGlmICh0eXBlID09PSBcImFsbFwiKSB7XG4gICAgICB0aGlzLmRpc3BhdGNoQ29udGV4dChcImFsbFwiLCBldmVudCwge30pO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgdG9Db250ZXh0VHlwZShyZWdpb24pIHtcbiAgICBpZiAocmVnaW9uID09PSBcImxlZ2VuZFwiIHx8IHJlZ2lvbiA9PT0gXCJzZXJpZXNcIikge1xuICAgICAgcmV0dXJuIHJlZ2lvbjtcbiAgICB9XG4gICAgcmV0dXJuIFwiYWxsXCI7XG4gIH1cbiAgc3RhdGljIGNoZWNrKHR5cGUsIGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LnR5cGUgPT09IHR5cGU7XG4gIH1cbiAgc3RhdGljIGNoZWNrQ2FsbGJhY2soZGVzaXJlZFR5cGUsIHR5cGUsIF9jYWxsYmFjaykge1xuICAgIHJldHVybiBkZXNpcmVkVHlwZSA9PT0gdHlwZTtcbiAgfVxuICBkaXNwYXRjaENvbnRleHQodHlwZSwgcG9pbnRlckV2ZW50LCBjb250ZXh0LCBwb3NpdGlvbikge1xuICAgIGNvbnN0IHsgc291cmNlRXZlbnQgfSA9IHBvaW50ZXJFdmVudDtcbiAgICBjb25zdCB4ID0gcG9zaXRpb24/LnggPz8gcG9pbnRlckV2ZW50Lm9mZnNldFg7XG4gICAgY29uc3QgeSA9IHBvc2l0aW9uPy55ID8/IHBvaW50ZXJFdmVudC5vZmZzZXRZO1xuICAgIHNvdXJjZUV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIHRoaXMubGlzdGVuZXJzLmRpc3BhdGNoKFwiXCIsIGJ1aWxkUHJldmVudGFibGUoeyB0eXBlLCB4LCB5LCBjb250ZXh0LCBzb3VyY2VFdmVudCB9KSk7XG4gIH1cbiAgYWRkTGlzdGVuZXIoaGFuZGxlcikge1xuICAgIHJldHVybiB0aGlzLmxpc3RlbmVycy5hZGRMaXN0ZW5lcihcIlwiLCBoYW5kbGVyKTtcbiAgfVxuICBmaWx0ZXJBY3Rpb25zKHR5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5kZWZhdWx0QWN0aW9ucy5maWx0ZXIoKGFjdGlvbikgPT4ge1xuICAgICAgcmV0dXJuIGFjdGlvbi5pZCAmJiAhdGhpcy5oaWRkZW5BY3Rpb25zLmhhcyhhY3Rpb24uaWQpICYmIFtcImFsbFwiLCB0eXBlXS5pbmNsdWRlcyhhY3Rpb24udHlwZSk7XG4gICAgfSk7XG4gIH1cbiAgcmVnaXN0ZXJEZWZhdWx0QWN0aW9uKGFjdGlvbikge1xuICAgIGNvbnN0IGRpZEFkZCA9IGFjdGlvbi5pZCAhPSBudWxsICYmICF0aGlzLmRlZmF1bHRBY3Rpb25zLnNvbWUoKHsgaWQgfSkgPT4gaWQgPT09IGFjdGlvbi5pZCk7XG4gICAgaWYgKGRpZEFkZCkge1xuICAgICAgdGhpcy5kZWZhdWx0QWN0aW9ucy5wdXNoKGFjdGlvbik7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjb25zdCBpbmRleCA9IGRpZEFkZCA/IHRoaXMuZGVmYXVsdEFjdGlvbnMuZmluZEluZGV4KCh7IGlkIH0pID0+IGlkID09PSBhY3Rpb24uaWQpIDogLTE7XG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIHRoaXMuZGVmYXVsdEFjdGlvbnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGVuYWJsZUFjdGlvbihhY3Rpb25JZCkge1xuICAgIHRoaXMuZGlzYWJsZWRBY3Rpb25zLmRlbGV0ZShhY3Rpb25JZCk7XG4gIH1cbiAgZGlzYWJsZUFjdGlvbihhY3Rpb25JZCkge1xuICAgIHRoaXMuZGlzYWJsZWRBY3Rpb25zLmFkZChhY3Rpb25JZCk7XG4gIH1cbiAgc2hvd0FjdGlvbihhY3Rpb25JZCkge1xuICAgIHRoaXMuaGlkZGVuQWN0aW9ucy5hZGQoYWN0aW9uSWQpO1xuICB9XG4gIGhpZGVBY3Rpb24oYWN0aW9uSWQpIHtcbiAgICB0aGlzLmhpZGRlbkFjdGlvbnMuZGVsZXRlKGFjdGlvbklkKTtcbiAgfVxuICBpc0Rpc2FibGVkKGFjdGlvbklkKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzYWJsZWRBY3Rpb25zLmhhcyhhY3Rpb25JZCk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvc3RhdGVUcmFja2VyLnRzXG52YXIgU3RhdGVUcmFja2VyID0gY2xhc3MgZXh0ZW5kcyBNYXAge1xuICBjb25zdHJ1Y3RvcihkZWZhdWx0VmFsdWUsIGRlZmF1bHRTdGF0ZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5kZWZhdWx0VmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgdGhpcy5kZWZhdWx0U3RhdGUgPSBkZWZhdWx0U3RhdGU7XG4gIH1cbiAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLmRlbGV0ZShrZXkpO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHN1cGVyLnNldChrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc3RhdGVJZCgpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmtleXMoKSkucG9wKCkgPz8gdGhpcy5kZWZhdWx0U3RhdGU7XG4gIH1cbiAgc3RhdGVWYWx1ZSgpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnZhbHVlcygpKS5wb3AoKSA/PyB0aGlzLmRlZmF1bHRWYWx1ZTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvaW50ZXJhY3Rpb24vY3Vyc29yTWFuYWdlci50c1xudmFyIEN1cnNvciA9IC8qIEBfX1BVUkVfXyAqLyAoKEN1cnNvcjIpID0+IHtcbiAgQ3Vyc29yMltcIkF1dG9cIl0gPSBcImF1dG9cIjtcbiAgQ3Vyc29yMltcIkRlZmF1bHRcIl0gPSBcImRlZmF1bHRcIjtcbiAgQ3Vyc29yMltcIkdyYWJcIl0gPSBcImdyYWJcIjtcbiAgQ3Vyc29yMltcIkdyYWJiaW5nXCJdID0gXCJncmFiYmluZ1wiO1xuICBDdXJzb3IyW1wiTW92ZVwiXSA9IFwibW92ZVwiO1xuICBDdXJzb3IyW1wiTm90QWxsb3dlZFwiXSA9IFwibm90LWFsbG93ZWRcIjtcbiAgQ3Vyc29yMltcIlBvaW50ZXJcIl0gPSBcInBvaW50ZXJcIjtcbiAgQ3Vyc29yMltcIkVXUmVzaXplXCJdID0gXCJldy1yZXNpemVcIjtcbiAgQ3Vyc29yMltcIk5TUmVzaXplXCJdID0gXCJucy1yZXNpemVcIjtcbiAgQ3Vyc29yMltcIlpvb21JblwiXSA9IFwiem9vbS1pblwiO1xuICBDdXJzb3IyW1wiWm9vbU91dFwiXSA9IFwiem9vbS1vdXRcIjtcbiAgcmV0dXJuIEN1cnNvcjI7XG59KShDdXJzb3IgfHwge30pO1xudmFyIEN1cnNvck1hbmFnZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGRvbU1hbmFnZXIpIHtcbiAgICB0aGlzLmRvbU1hbmFnZXIgPSBkb21NYW5hZ2VyO1xuICAgIHRoaXMuc3RhdGVUcmFja2VyID0gbmV3IFN0YXRlVHJhY2tlcihcImRlZmF1bHRcIik7XG4gIH1cbiAgdXBkYXRlQ3Vyc29yKGNhbGxlcklkLCBzdHlsZSkge1xuICAgIHRoaXMuc3RhdGVUcmFja2VyLnNldChjYWxsZXJJZCwgc3R5bGUpO1xuICAgIHRoaXMuZG9tTWFuYWdlci51cGRhdGVDdXJzb3IodGhpcy5zdGF0ZVRyYWNrZXIuc3RhdGVWYWx1ZSgpKTtcbiAgfVxuICBnZXRDdXJzb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuZG9tTWFuYWdlci5nZXRDdXJzb3IoKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvaW50ZXJhY3Rpb24vZ2VzdHVyZURldGVjdG9yLnRzXG5mdW5jdGlvbiBkaXN0YW5jZVNxdWFyZWQoZmluZ2VyMSwgZmluZ2VyMikge1xuICBjb25zdCBkeCA9IGZpbmdlcjEuc2NyZWVuWCAtIGZpbmdlcjIuc2NyZWVuWDtcbiAgY29uc3QgZHkgPSBmaW5nZXIxLnNjcmVlblkgLSBmaW5nZXIyLnNjcmVlblk7XG4gIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cbmZ1bmN0aW9uIGRpc3RhbmNlKGZpbmdlcjEsIGZpbmdlcjIpIHtcbiAgcmV0dXJuIE1hdGguc3FydChkaXN0YW5jZVNxdWFyZWQoZmluZ2VyMSwgZmluZ2VyMikpO1xufVxudmFyIE1JTl9ESVNUQU5DRV9UT19TVEFSVF9QSU5DSCA9IDE7XG52YXIgR2VzdHVyZURldGVjdG9yID0gY2xhc3MgZXh0ZW5kcyBCYXNlTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGRvbU1hbmFnZXIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZG9tTWFuYWdlciA9IGRvbU1hbmFnZXI7XG4gICAgdGhpcy50b3VjaHN0YXJ0ID0gKGV2ZW50KSA9PiB0aGlzLm9uVG91Y2hTdGFydChldmVudCk7XG4gICAgdGhpcy50b3VjaG1vdmUgPSAoZXZlbnQpID0+IHRoaXMub25Ub3VjaE1vdmUoZXZlbnQpO1xuICAgIHRoaXMudG91Y2hlbmQgPSAoZXZlbnQpID0+IHRoaXMub25Ub3VjaEVuZChldmVudCk7XG4gICAgdGhpcy50b3VjaGNhbmNlbCA9IChldmVudCkgPT4gdGhpcy5vblRvdWNoQ2FuY2VsKGV2ZW50KTtcbiAgICB0aGlzLnBpbmNoID0ge1xuICAgICAgZmluZ2VyMTogeyBpZGVudGlmaWVyOiBOYU4sIHNjcmVlblg6IE5hTiwgc2NyZWVuWTogTmFOIH0sXG4gICAgICBmaW5nZXIyOiB7IGlkZW50aWZpZXI6IE5hTiwgc2NyZWVuWDogTmFOLCBzY3JlZW5ZOiBOYU4gfSxcbiAgICAgIG9yaWdpbjogeyB4OiBOYU4sIHk6IE5hTiB9LFxuICAgICAgZGlzdGFuY2U6IE5hTixcbiAgICAgIHN0YXR1czogMCAvKiBPZmYgKi9cbiAgICB9O1xuICAgIHRoaXMuZG9tTWFuYWdlci5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCB0aGlzLnRvdWNoc3RhcnQsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICB0aGlzLmRvbU1hbmFnZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLnRvdWNobW92ZSwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgICB0aGlzLmRvbU1hbmFnZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMudG91Y2hlbmQpO1xuICAgIHRoaXMuZG9tTWFuYWdlci5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hjYW5jZWxcIiwgdGhpcy50b3VjaGNhbmNlbCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRvbU1hbmFnZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdGhpcy50b3VjaHN0YXJ0KTtcbiAgICB0aGlzLmRvbU1hbmFnZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLnRvdWNobW92ZSk7XG4gICAgdGhpcy5kb21NYW5hZ2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLnRvdWNoZW5kKTtcbiAgICB0aGlzLmRvbU1hbmFnZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoY2FuY2VsXCIsIHRoaXMudG91Y2hjYW5jZWwpO1xuICB9XG4gIGZpbmRQaW5jaFRvdWNoZXMobW92ZUV2ZW50KSB7XG4gICAgY29uc3QgeyB0b3VjaGVzIH0gPSBtb3ZlRXZlbnQ7XG4gICAgY29uc3QgeyBmaW5nZXIxLCBmaW5nZXIyIH0gPSB0aGlzLnBpbmNoO1xuICAgIGlmICh0aGlzLnBpbmNoLnN0YXR1cyAhPT0gMCAvKiBPZmYgKi8gJiYgdG91Y2hlcy5sZW5ndGggPT09IDIpIHtcbiAgICAgIGlmICh0b3VjaGVzWzBdLmlkZW50aWZpZXIgPT09IGZpbmdlcjEuaWRlbnRpZmllciAmJiB0b3VjaGVzWzFdLmlkZW50aWZpZXIgPT09IGZpbmdlcjIuaWRlbnRpZmllcikge1xuICAgICAgICByZXR1cm4gW3RvdWNoZXNbMF0sIHRvdWNoZXNbMV1dO1xuICAgICAgfVxuICAgICAgaWYgKHRvdWNoZXNbMF0uaWRlbnRpZmllciA9PT0gZmluZ2VyMi5pZGVudGlmaWVyICYmIHRvdWNoZXNbMV0uaWRlbnRpZmllciA9PT0gZmluZ2VyMS5pZGVudGlmaWVyKSB7XG4gICAgICAgIHJldHVybiBbdG91Y2hlc1sxXSwgdG91Y2hlc1swXV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvcHlUb3VjaERhdGEoZXZlbnQpIHtcbiAgICBjb25zdCBrZXlzID0gW1wiaWRlbnRpZmllclwiLCBcInNjcmVlblhcIiwgXCJzY3JlZW5ZXCJdO1xuICAgIHBhcnRpYWxBc3NpZ24oa2V5cywgdGhpcy5waW5jaC5maW5nZXIxLCBldmVudC50b3VjaGVzWzBdKTtcbiAgICBwYXJ0aWFsQXNzaWduKGtleXMsIHRoaXMucGluY2guZmluZ2VyMiwgZXZlbnQudG91Y2hlc1sxXSk7XG4gICAgdGhpcy5waW5jaC5kaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMucGluY2guZmluZ2VyMSwgdGhpcy5waW5jaC5maW5nZXIyKTtcbiAgfVxuICBkaXNwYXRjaFBpbmNoRXZlbnQodHlwZSwgZGVsdGFEaXN0YW5jZSwgc291cmNlRXZlbnQpIHtcbiAgICBjb25zdCB7IGZpbmdlcjEsIGZpbmdlcjIsIG9yaWdpbjogb3JpZ2luMyB9ID0gdGhpcy5waW5jaDtcbiAgICB0aGlzLmxpc3RlbmVycy5kaXNwYXRjaCh0eXBlLCBidWlsZFByZXZlbnRhYmxlKHsgc291cmNlRXZlbnQsIHR5cGUsIGZpbmdlcjEsIGZpbmdlcjIsIGRlbHRhRGlzdGFuY2UsIG9yaWdpbjogb3JpZ2luMyB9KSk7XG4gIH1cbiAgb25Ub3VjaFN0YXJ0KGV2ZW50KSB7XG4gICAgdGhpcy5zdG9wUGluY2hUcmFja2luZyhldmVudCk7XG4gICAgY29uc3QgeyBwaW5jaCB9ID0gdGhpcztcbiAgICBpZiAoZXZlbnQudG91Y2hlcy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHBpbmNoLnN0YXR1cyA9IDEgLyogSW5pdGlhbGl6ZWQgKi87XG4gICAgICB0aGlzLmNvcHlUb3VjaERhdGEoZXZlbnQpO1xuICAgICAgcGluY2gub3JpZ2luLnggPSAoZXZlbnQudG91Y2hlc1swXS5jbGllbnRYICsgZXZlbnQudG91Y2hlc1sxXS5jbGllbnRYKSAvIDI7XG4gICAgICBwaW5jaC5vcmlnaW4ueSA9IChldmVudC50b3VjaGVzWzBdLmNsaWVudFkgKyBldmVudC50b3VjaGVzWzFdLmNsaWVudFkpIC8gMjtcbiAgICB9XG4gIH1cbiAgb25Ub3VjaE1vdmUoZXZlbnQpIHtcbiAgICBjb25zdCBwaW5jaFRvdWNoZXMgPSB0aGlzLmZpbmRQaW5jaFRvdWNoZXMoZXZlbnQpO1xuICAgIGlmIChwaW5jaFRvdWNoZXMgIT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgW3RvdWNoMSwgdG91Y2gyXSA9IHBpbmNoVG91Y2hlcztcbiAgICAgIGNvbnN0IHsgcGluY2ggfSA9IHRoaXM7XG4gICAgICBjb25zdCBuZXdEaXN0YW5jZSA9IGRpc3RhbmNlKHRvdWNoMSwgdG91Y2gyKTtcbiAgICAgIGNvbnN0IGRlbHRhRGlzdGFuY2UgPSBuZXdEaXN0YW5jZSAtIHBpbmNoLmRpc3RhbmNlO1xuICAgICAgaWYgKHBpbmNoLnN0YXR1cyA9PT0gMSAvKiBJbml0aWFsaXplZCAqLykge1xuICAgICAgICBpZiAoTWF0aC5hYnMoZGVsdGFEaXN0YW5jZSkgPiBNSU5fRElTVEFOQ0VfVE9fU1RBUlRfUElOQ0gpIHtcbiAgICAgICAgICBwaW5jaC5zdGF0dXMgPSAyIC8qIFJ1bm5pbmcgKi87XG4gICAgICAgICAgdGhpcy5jb3B5VG91Y2hEYXRhKGV2ZW50KTtcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoUGluY2hFdmVudChcInBpbmNoLXN0YXJ0XCIsIDAsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwaW5jaC5zdGF0dXMgPT09IDIgLyogUnVubmluZyAqLykge1xuICAgICAgICBwaW5jaC5kaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICB0aGlzLmNvcHlUb3VjaERhdGEoZXZlbnQpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoUGluY2hFdmVudChcInBpbmNoLW1vdmVcIiwgZGVsdGFEaXN0YW5jZSwgZXZlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgTG9nZ2VyLmVycm9yKGB1bmV4cGVjdGVkIHBpbmNoLnN0YXR1czogJHtwaW5jaC5zdGF0dXN9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIG9uVG91Y2hFbmQoZXZlbnQpIHtcbiAgICB0aGlzLnN0b3BQaW5jaFRyYWNraW5nKGV2ZW50KTtcbiAgfVxuICBvblRvdWNoQ2FuY2VsKGV2ZW50KSB7XG4gICAgdGhpcy5zdG9wUGluY2hUcmFja2luZyhldmVudCk7XG4gIH1cbiAgc3RvcFBpbmNoVHJhY2tpbmcoZXZlbnQpIHtcbiAgICBjb25zdCB7IHBpbmNoIH0gPSB0aGlzO1xuICAgIGlmIChwaW5jaC5zdGF0dXMgPT09IDIgLyogUnVubmluZyAqLykge1xuICAgICAgdGhpcy5kaXNwYXRjaFBpbmNoRXZlbnQoXCJwaW5jaC1lbmRcIiwgMCwgZXZlbnQpO1xuICAgIH1cbiAgICB0aGlzLnBpbmNoLnN0YXR1cyA9IDAgLyogT2ZmICovO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9pbnRlcmFjdGlvbi9oaWdobGlnaHRNYW5hZ2VyLnRzXG52YXIgSGlnaGxpZ2h0TWFuYWdlciA9IGNsYXNzIGV4dGVuZHMgQmFzZU1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuaGlnaGxpZ2h0U3RhdGVzID0gbmV3IFN0YXRlVHJhY2tlcigpO1xuICB9XG4gIHVwZGF0ZUhpZ2hsaWdodChjYWxsZXJJZCwgaGlnaGxpZ2h0ZWREYXR1bSkge1xuICAgIGNvbnN0IHsgYWN0aXZlSGlnaGxpZ2h0OiBwcmV2aW91c0hpZ2hsaWdodCB9ID0gdGhpcztcbiAgICB0aGlzLmhpZ2hsaWdodFN0YXRlcy5zZXQoY2FsbGVySWQsIGhpZ2hsaWdodGVkRGF0dW0pO1xuICAgIHRoaXMuYWN0aXZlSGlnaGxpZ2h0ID0gdGhpcy5oaWdobGlnaHRTdGF0ZXMuc3RhdGVWYWx1ZSgpO1xuICAgIGlmICghdGhpcy5pc0VxdWFsKHRoaXMuYWN0aXZlSGlnaGxpZ2h0LCBwcmV2aW91c0hpZ2hsaWdodCkpIHtcbiAgICAgIHRoaXMubGlzdGVuZXJzLmRpc3BhdGNoKFwiaGlnaGxpZ2h0LWNoYW5nZVwiLCB7XG4gICAgICAgIHR5cGU6IFwiaGlnaGxpZ2h0LWNoYW5nZVwiLFxuICAgICAgICBjdXJyZW50SGlnaGxpZ2h0OiB0aGlzLmFjdGl2ZUhpZ2hsaWdodCxcbiAgICAgICAgcHJldmlvdXNIaWdobGlnaHQsXG4gICAgICAgIGNhbGxlcklkXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZ2V0QWN0aXZlSGlnaGxpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmFjdGl2ZUhpZ2hsaWdodDtcbiAgfVxuICBpc0VxdWFsKGEsIGIpIHtcbiAgICByZXR1cm4gYSA9PT0gYiB8fCBhICE9IG51bGwgJiYgYiAhPSBudWxsICYmIGE/LnNlcmllcyA9PT0gYj8uc2VyaWVzICYmIGE/Lml0ZW1JZCA9PT0gYj8uaXRlbUlkICYmIGE/LmRhdHVtID09PSBiPy5kYXR1bTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvaW50ZXJhY3Rpb24va2V5TmF2TWFuYWdlci50c1xudmFyIEtleU5hdk1hbmFnZXIgPSBjbGFzcyBleHRlbmRzIEludGVyYWN0aW9uU3RhdGVMaXN0ZW5lciB7XG4gIGNvbnN0cnVjdG9yKGZvY3VzSW5kaWNhdG9yLCBpbnRlcmFjdGlvbk1hbmFnZXIsIG1vZGUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZm9jdXNJbmRpY2F0b3IgPSBmb2N1c0luZGljYXRvcjtcbiAgICB0aGlzLmludGVyYWN0aW9uTWFuYWdlciA9IGludGVyYWN0aW9uTWFuYWdlcjtcbiAgICAvLyBUaGlzIGlzIHRoZSBcInNlY29uZCBsYXN0XCIgaW5wdXQgZXZlbnQuIEl0IGNhbiBiZSB1c2VmdWwgZm9yIGtleWRvd25cbiAgICAvLyBldmVudHMgdGhhdCBmb3Igd2hpY2ggZG9uJ3QgdG8gc2V0IHRoZSBpc0ZvY3VzVmlzaWJsZSBzdGF0ZVxuICAgIC8vIChlLmcuIEJhY2tzcGFjZS9EZWxldGUga2V5IG9uIEZDIGFubm90YXRpb25zLCBzZWUgQUctMTMwNDEpLlxuICAgIC8vXG4gICAgLy8gVXNlIHdpdGggY2F1dGlvbiEgVGhlIGZvY3VzIGluZGljYXRvciBtdXN0IEFMV0FZUyBiZSB2aXNpYmxlIGZvclxuICAgIC8vIGtleWJvYXJkLW9ubHkgdXNlcnMuXG4gICAgdGhpcy5wcmV2aW91c0lucHV0RGV2aWNlID0gXCJrZXlib2FyZFwiO1xuICAgIGNvbnN0IG1vdXNlU3RhdGVzID0gMzIgLyogRGVmYXVsdCAqLyB8IDggLyogQW5ub3RhdGlvbnMgKi8gfCAxIC8qIEFubm90YXRpb25zU2VsZWN0ZWQgKi87XG4gICAgdGhpcy5kZXN0cm95Rm5zLnB1c2goXG4gICAgICBpbnRlcmFjdGlvbk1hbmFnZXIuYWRkTGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiB0aGlzLm9uQ2xpY2soKSwgbW91c2VTdGF0ZXMpLFxuICAgICAgaW50ZXJhY3Rpb25NYW5hZ2VyLmFkZExpc3RlbmVyKFwiaG92ZXJcIiwgKCkgPT4gdGhpcy5vbk1vdXNlKCksIG1vdXNlU3RhdGVzKSxcbiAgICAgIGludGVyYWN0aW9uTWFuYWdlci5hZGRMaXN0ZW5lcihcImRyYWctc3RhcnRcIiwgKCkgPT4gdGhpcy5vbk1vdXNlKCksIG1vdXNlU3RhdGVzKSxcbiAgICAgIGludGVyYWN0aW9uTWFuYWdlci5hZGRMaXN0ZW5lcihcImJsdXJcIiwgKGUpID0+IHRoaXMub25CbHVyKGUpLCA2MyAvKiBBbGwgKi8pLFxuICAgICAgaW50ZXJhY3Rpb25NYW5hZ2VyLmFkZExpc3RlbmVyKFwiZm9jdXNcIiwgKGUpID0+IHRoaXMub25Gb2N1cyhlKSwgNjMgLyogQWxsICovKSxcbiAgICAgIGludGVyYWN0aW9uTWFuYWdlci5hZGRMaXN0ZW5lcihcImtleWRvd25cIiwgKGUpID0+IHRoaXMub25LZXlEb3duKGUpLCA2MyAvKiBBbGwgKi8pXG4gICAgKTtcbiAgICB0aGlzLmZvY3VzSW5kaWNhdG9yLm92ZXJyaWRlRm9jdXNWaXNpYmxlKG1vZGUgPT09IFwiaW50ZWdyYXRlZFwiID8gZmFsc2UgOiB2b2lkIDApO1xuICB9XG4gIGdldFN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLmludGVyYWN0aW9uTWFuYWdlci5nZXRTdGF0ZSgpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICB9XG4gIG9uQ2xpY2soKSB7XG4gICAgdGhpcy5mb2N1c0luZGljYXRvci5vdmVycmlkZUZvY3VzVmlzaWJsZShmYWxzZSk7XG4gICAgdGhpcy5wcmV2aW91c0lucHV0RGV2aWNlID0gXCJtb3VzZVwiO1xuICB9XG4gIG9uTW91c2UoKSB7XG4gICAgdGhpcy5wcmV2aW91c0lucHV0RGV2aWNlID0gXCJtb3VzZVwiO1xuICB9XG4gIG9uQmx1cihldmVudCkge1xuICAgIHRoaXMuZm9jdXNJbmRpY2F0b3Iub3ZlcnJpZGVGb2N1c1Zpc2libGUodm9pZCAwKTtcbiAgICB0aGlzLmRpc3BhdGNoKFwiYmx1clwiLCAwLCBldmVudCk7XG4gIH1cbiAgb25Gb2N1cyhldmVudCkge1xuICAgIHRoaXMuZGlzcGF0Y2goXCJmb2N1c1wiLCAwLCBldmVudCk7XG4gIH1cbiAgb25LZXlEb3duKGV2ZW50KSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldFN0YXRlKCk7XG4gICAgY29uc3QgeyBrZXksIGNvZGUsIGFsdEtleSwgc2hpZnRLZXksIG1ldGFLZXksIGN0cmxLZXkgfSA9IGV2ZW50LnNvdXJjZUV2ZW50O1xuICAgIGlmIChjdHJsS2V5IHx8IG1ldGFLZXkpIHtcbiAgICAgIGlmIChrZXkgPT09IFwieVwiIHx8IGtleSA9PT0gXCJ6XCIgJiYgc2hpZnRLZXkpIHtcbiAgICAgICAgdGhpcy5mb2N1c0luZGljYXRvci5vdmVycmlkZUZvY3VzVmlzaWJsZSh0aGlzLnByZXZpb3VzSW5wdXREZXZpY2UgPT09IFwia2V5Ym9hcmRcIik7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwicmVkb1wiLCAwLCBldmVudCk7XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJ6XCIpIHtcbiAgICAgICAgdGhpcy5mb2N1c0luZGljYXRvci5vdmVycmlkZUZvY3VzVmlzaWJsZSh0aGlzLnByZXZpb3VzSW5wdXREZXZpY2UgPT09IFwia2V5Ym9hcmRcIik7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwidW5kb1wiLCAwLCBldmVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdGF0ZSAmICg4IC8qIEFubm90YXRpb25zICovIHwgMSAvKiBBbm5vdGF0aW9uc1NlbGVjdGVkICovKSkge1xuICAgICAgdGhpcy5mb2N1c0luZGljYXRvci5vdmVycmlkZUZvY3VzVmlzaWJsZShmYWxzZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICBjYXNlIFwiK1wiOlxuICAgICAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcIm5hdi16b29tXCIsIDEsIGV2ZW50KTtcbiAgICAgIGNhc2UgXCItXCI6XG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwibmF2LXpvb21cIiwgLTEsIGV2ZW50KTtcbiAgICB9XG4gICAgaWYgKGFsdEtleSB8fCBzaGlmdEtleSB8fCBtZXRhS2V5IHx8IGN0cmxLZXkpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5mb2N1c0luZGljYXRvci5vdmVycmlkZUZvY3VzVmlzaWJsZSh0cnVlKTtcbiAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgIGNhc2UgXCJBcnJvd0Rvd25cIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJuYXYtdmVydFwiLCAxLCBldmVudCk7XG4gICAgICBjYXNlIFwiQXJyb3dVcFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcIm5hdi12ZXJ0XCIsIC0xLCBldmVudCk7XG4gICAgICBjYXNlIFwiQXJyb3dMZWZ0XCI6XG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwibmF2LWhvcmlcIiwgLTEsIGV2ZW50KTtcbiAgICAgIGNhc2UgXCJBcnJvd1JpZ2h0XCI6XG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwibmF2LWhvcmlcIiwgMSwgZXZlbnQpO1xuICAgICAgY2FzZSBcIlpvb21JblwiOlxuICAgICAgY2FzZSBcIkFkZFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcIm5hdi16b29tXCIsIDEsIGV2ZW50KTtcbiAgICAgIGNhc2UgXCJab29tT3V0XCI6XG4gICAgICBjYXNlIFwiU3Vic3RyYWN0XCI6XG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwibmF2LXpvb21cIiwgLTEsIGV2ZW50KTtcbiAgICAgIGNhc2UgXCJTcGFjZVwiOlxuICAgICAgY2FzZSBcIkVudGVyXCI6XG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwic3VibWl0XCIsIDAsIGV2ZW50KTtcbiAgICB9XG4gIH1cbiAgZGlzcGF0Y2godHlwZSwgZGVsdGE0LCBzb3VyY2VFdmVudCkge1xuICAgIGNvbnN0IHsgcHJldmlvdXNJbnB1dERldmljZSB9ID0gdGhpcztcbiAgICBkaXNwYXRjaFR5cGVkRXZlbnQodGhpcy5saXN0ZW5lcnMsIHsgdHlwZSwgZGVsdGE6IGRlbHRhNCwgc291cmNlRXZlbnQsIHByZXZpb3VzSW5wdXREZXZpY2UgfSk7XG4gICAgY29uc3Qgc2hhcmVkS2JtVHlwZXMgPSBbXCJyZWRvXCIsIFwidW5kb1wiLCBcIm5hdi16b29tXCJdO1xuICAgIGlmIChzb3VyY2VFdmVudC50eXBlID09PSBcImtleWRvd25cIiAmJiAhc2hhcmVkS2JtVHlwZXMuaW5jbHVkZXModHlwZSkpIHtcbiAgICAgIHRoaXMucHJldmlvdXNJbnB1dERldmljZSA9IFwia2V5Ym9hcmRcIjtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2ludGVyYWN0aW9uL3JlZ2lvbnMudHNcbnZhciBSRUdJT05TID0gLyogQF9fUFVSRV9fICovICgoUkVHSU9OUzIpID0+IHtcbiAgUkVHSU9OUzJbXCJOQVZJR0FUT1JcIl0gPSBcIm5hdmlnYXRvclwiO1xuICBSRUdJT05TMltcIlJPT1RcIl0gPSBcInJvb3RcIjtcbiAgUkVHSU9OUzJbXCJTRVJJRVNcIl0gPSBcInNlcmllc1wiO1xuICBSRUdJT05TMltcIkhPUklaT05UQUxfQVhFU1wiXSA9IFwiaG9yaXpvbnRhbC1heGVzXCI7XG4gIFJFR0lPTlMyW1wiVkVSVElDQUxfQVhFU1wiXSA9IFwidmVydGljYWwtYXhlc1wiO1xuICByZXR1cm4gUkVHSU9OUzI7XG59KShSRUdJT05TIHx8IHt9KTtcbnZhciBOb2RlUmVnaW9uQkJveFByb3ZpZGVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihub2RlLCBvdmVycmlkZUlkKSB7XG4gICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICB0aGlzLm92ZXJyaWRlSWQgPSBvdmVycmlkZUlkO1xuICB9XG4gIGdldCBpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5vdmVycmlkZUlkID8/IHRoaXMubm9kZS5pZDtcbiAgfVxuICBnZXQgdmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlLnZpc2libGU7XG4gIH1cbiAgdG9DYW52YXNCQm94KCkge1xuICAgIHJldHVybiBUcmFuc2Zvcm1hYmxlLnRvQ2FudmFzKHRoaXMubm9kZSk7XG4gIH1cbiAgZnJvbUNhbnZhc1BvaW50KHgsIHkpIHtcbiAgICByZXR1cm4gVHJhbnNmb3JtYWJsZS5mcm9tQ2FudmFzUG9pbnQodGhpcy5ub2RlLCB4LCB5KTtcbiAgfVxufTtcbnZhciBTaW1wbGVSZWdpb25CQm94UHJvdmlkZXIgPSBjbGFzcyBleHRlbmRzIE5vZGVSZWdpb25CQm94UHJvdmlkZXIge1xuICBjb25zdHJ1Y3Rvcihub2RlLCBiYm94Rm4sIG92ZXJyaWRlSWQpIHtcbiAgICBzdXBlcihub2RlLCBvdmVycmlkZUlkKTtcbiAgICB0aGlzLmJib3hGbiA9IGJib3hGbjtcbiAgfVxuICB0b0NhbnZhc0JCb3goKSB7XG4gICAgcmV0dXJuIHRoaXMuYmJveEZuKCk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2ludGVyYWN0aW9uL3JlZ2lvbk1hbmFnZXIudHNcbnZhciBSZWdpb25MaXN0ZW5lcnMgPSBjbGFzcyBleHRlbmRzIExpc3RlbmVycyB7XG59O1xuZnVuY3Rpb24gYWRkSGFuZGxlcihsaXN0ZW5lcnMsIGludGVyYWN0aW9uTWFuYWdlciwgdHlwZSwgaGFuZGxlciwgdHJpZ2dlcmluZ1N0YXRlcyA9IDMyIC8qIERlZmF1bHQgKi8pIHtcbiAgcmV0dXJuIGxpc3RlbmVycz8uYWRkTGlzdGVuZXIodHlwZSwgKGUpID0+IHtcbiAgICBjb25zdCBjdXJyZW50U3RhdGUgPSBpbnRlcmFjdGlvbk1hbmFnZXIuZ2V0U3RhdGUoKTtcbiAgICBpZiAoY3VycmVudFN0YXRlICYgdHJpZ2dlcmluZ1N0YXRlcykge1xuICAgICAgaGFuZGxlcihlKTtcbiAgICB9XG4gIH0pID8/ICgoKSA9PiB7XG4gIH0pO1xufVxuZnVuY3Rpb24gbm9kZVRvQkJveFByb3ZpZGVyKG5vZGUpIHtcbiAgaWYgKG5vZGUgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgcmV0dXJuIG5ldyBOb2RlUmVnaW9uQkJveFByb3ZpZGVyKG5vZGUpO1xuICB9XG4gIGlmIChub2RlIGluc3RhbmNlb2YgTm9kZVJlZ2lvbkJCb3hQcm92aWRlcikge1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIHJldHVybiBuZXcgTm9kZVJlZ2lvbkJCb3hQcm92aWRlcihub2RlLm5vZGUsIG5vZGUuaWQpO1xufVxuZnVuY3Rpb24gZ2V0VG9vbHRpcENvbnRhaW5lcih0YXJnZXQpIHtcbiAgaWYgKHRhcmdldCA9PSBudWxsIHx8ICEodGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKVxuICAgIHJldHVybiB2b2lkIDA7XG4gIGxldCBjdXJyZW50ID0gdGFyZ2V0O1xuICB3aGlsZSAoY3VycmVudCAhPSBudWxsICYmICFjdXJyZW50Py5jbGFzc0xpc3QuY29udGFpbnMoXCJhZy1jaGFydHMtd3JhcHBlclwiKSkge1xuICAgIGlmIChjdXJyZW50LmNsYXNzTGlzdC5jb250YWlucyhcImFnLWNoYXJ0LXRvb2x0aXBcIikpIHtcbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH1cbiAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnRFbGVtZW50O1xuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG5mdW5jdGlvbiBzaG91bGRJZ25vcmUoZXZlbnQpIHtcbiAgY29uc3QgeyB0eXBlLCBzb3VyY2VFdmVudCB9ID0gZXZlbnQ7XG4gIGNvbnN0IHsgaWQsIGNsYXNzTmFtZSwgY2xhc3NMaXN0LCBhcmlhSGlkZGVuIH0gPSBzb3VyY2VFdmVudD8udGFyZ2V0ID8/IHt9O1xuICBpZiAoIShjbGFzc0xpc3QgaW5zdGFuY2VvZiBET01Ub2tlbkxpc3QpKVxuICAgIHJldHVybiBcImxlYXZlXCI7XG4gIGNvbnN0IGRyYWdUeXBlcyA9IERSQUdfSU5URVJBQ1RJT05fVFlQRVM7XG4gIGlmIChcbiAgICAvLyBIYW5kbGUgZHJhZyBldmVudCBvbiB0aGUgYXhpcyAnYWRkIGhvcml6b250YWwgbGluZSBhbm5vdGF0aW9uJyBidXR0b24gYXMgY2FudmFzIGV2ZW50cy5cbiAgICBjbGFzc0xpc3QuY29udGFpbnMoXCJhZy1jaGFydHMtYW5ub3RhdGlvbnNfX2F4aXMtYnV0dG9uLWljb25cIikgJiYgIWRyYWdUeXBlcy5pbmNsdWRlcyh0eXBlKSB8fCBjbGFzc05hbWUgPT09IFwiYWctY2hhcnRzLXNlcmllcy1hcmVhXCIgfHwgY2xhc3NOYW1lID09PSBcImFnLWNoYXJ0cy1jYW52YXMtcHJveHlcIiB8fCBjbGFzc05hbWUgPT09IFwiYWctY2hhcnRzLXByb3h5LWVsZW1cIiAmJiAhaWQ/LnRvU3RyaW5nKCkuc3RhcnRzV2l0aChcImFnLWNoYXJ0cy1sZWdlbmQtaXRlbS1cIikgfHwgLy8gbGVnZW5kIDxidXR0b25zPlxuICAgIHNvdXJjZUV2ZW50Py50YXJnZXQgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudFxuICApIHtcbiAgICByZXR1cm4gXCJub25lXCI7XG4gIH1cbiAgaWYgKGdldFRvb2x0aXBDb250YWluZXIoc291cmNlRXZlbnQudGFyZ2V0KSAmJiBhcmlhSGlkZGVuICE9PSBcInRydWVcIikge1xuICAgIHJldHVybiBcIndhaXRcIjtcbiAgfVxuICByZXR1cm4gXCJsZWF2ZVwiO1xufVxudmFyIFJlZ2lvbk1hbmFnZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGludGVyYWN0aW9uTWFuYWdlcikge1xuICAgIHRoaXMuaW50ZXJhY3Rpb25NYW5hZ2VyID0gaW50ZXJhY3Rpb25NYW5hZ2VyO1xuICAgIHRoaXMuZGVidWcgPSBEZWJ1Zy5jcmVhdGUodHJ1ZSwgXCJyZWdpb25cIik7XG4gICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgdGhpcy5sZWZ0Q2FudmFzID0gZmFsc2U7XG4gICAgdGhpcy5yZWdpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMgPSBbXTtcbiAgICB0aGlzLmFsbFJlZ2lvbnNMaXN0ZW5lcnMgPSBuZXcgUmVnaW9uTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5kZXN0cm95Rm5zLnB1c2goXG4gICAgICAuLi5QT0lOVEVSX0lOVEVSQUNUSU9OX1RZUEVTLm1hcChcbiAgICAgICAgKGV2ZW50TmFtZSkgPT4gaW50ZXJhY3Rpb25NYW5hZ2VyLmFkZExpc3RlbmVyKGV2ZW50TmFtZSwgdGhpcy5wcm9jZXNzUG9pbnRlckV2ZW50LmJpbmQodGhpcyksIDYzIC8qIEFsbCAqLylcbiAgICAgIClcbiAgICApO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXN0cm95Rm5zLmZvckVhY2goKGZuKSA9PiBmbigpKTtcbiAgICB0aGlzLmN1cnJlbnQgPSB2b2lkIDA7XG4gICAgZm9yIChjb25zdCByZWdpb24gb2YgdGhpcy5yZWdpb25zLnZhbHVlcygpKSB7XG4gICAgICByZWdpb24ubGlzdGVuZXJzLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5yZWdpb25zLmNsZWFyKCk7XG4gIH1cbiAgYWRkUmVnaW9uKG5hbWUsIC4uLm5vZGVzKSB7XG4gICAgaWYgKHRoaXMucmVnaW9ucy5oYXMobmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQUcgQ2hhcnRzIC0gUmVnaW9uOiAke25hbWV9IGFscmVhZHkgZXhpc3RzYCk7XG4gICAgfVxuICAgIGNvbnN0IHJlZ2lvbiA9IHtcbiAgICAgIHByb3BlcnRpZXM6IHsgbmFtZSwgYmJveHByb3ZpZGVyczogbm9kZXMubWFwKG5vZGVUb0JCb3hQcm92aWRlcikgfSxcbiAgICAgIGxpc3RlbmVyczogbmV3IFJlZ2lvbkxpc3RlbmVycygpXG4gICAgfTtcbiAgICB0aGlzLnJlZ2lvbnMuc2V0KG5hbWUsIHJlZ2lvbik7XG4gICAgcmV0dXJuIHRoaXMubWFrZU9ic2VydmVyKHJlZ2lvbik7XG4gIH1cbiAgdXBkYXRlUmVnaW9uKG5hbWUsIC4uLm5vZGVzKSB7XG4gICAgY29uc3QgcmVnaW9uID0gdGhpcy5yZWdpb25zLmdldChuYW1lKTtcbiAgICBpZiAocmVnaW9uKSB7XG4gICAgICByZWdpb24ucHJvcGVydGllcy5iYm94cHJvdmlkZXJzID0gbm9kZXMubWFwKG5vZGVUb0JCb3hQcm92aWRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFHIENoYXJ0cyAtIHVua25vd24gcmVnaW9uOiBcIiArIG5hbWUpO1xuICAgIH1cbiAgfVxuICBnZXRSZWdpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLm1ha2VPYnNlcnZlcih0aGlzLnJlZ2lvbnMuZ2V0KG5hbWUpKTtcbiAgfVxuICBsaXN0ZW5BbGwodHlwZSwgaGFuZGxlciwgdHJpZ2dlcmluZ1N0YXRlcyA9IDMyIC8qIERlZmF1bHQgKi8pIHtcbiAgICByZXR1cm4gYWRkSGFuZGxlcih0aGlzLmFsbFJlZ2lvbnNMaXN0ZW5lcnMsIHRoaXMuaW50ZXJhY3Rpb25NYW5hZ2VyLCB0eXBlLCBoYW5kbGVyLCB0cmlnZ2VyaW5nU3RhdGVzKTtcbiAgfVxuICAvLyBUaGlzIG1ldGhvZCByZXR1cm4gYSB3cmFwcGVyIG9iamVjdCB0aGF0IG1hdGNoZXMgdGhlIGludGVyZmFjZSBvZiBJbnRlcmFjdGlvbk1hbmFnZXIuYWRkTGlzdGVuZXIuXG4gIC8vIFRoZSBpbnRlbnQgaXMgdG8gYWxsb3cgdGhlIEludGVyYWN0aW9uTWFuYWdlciBhbmQgUmVnaW9uTWFuYWdlciB0byBiZSB1c2VkIGFsbW9zdCBpbnRlcmNoYW5nZWFibHkuXG4gIG1ha2VPYnNlcnZlcihyZWdpb24pIHtcbiAgICBjb25zdCB7IGludGVyYWN0aW9uTWFuYWdlciB9ID0gdGhpcztcbiAgICBjbGFzcyBPYnNlcnZhYmxlUmVnaW9uSW1wbGVtZW50YXRpb24ge1xuICAgICAgYWRkTGlzdGVuZXIodHlwZSwgaGFuZGxlciwgdHJpZ2dlcmluZ1N0YXRlcyA9IDMyIC8qIERlZmF1bHQgKi8pIHtcbiAgICAgICAgcmV0dXJuIGFkZEhhbmRsZXIocmVnaW9uPy5saXN0ZW5lcnMsIGludGVyYWN0aW9uTWFuYWdlciwgdHlwZSwgaGFuZGxlciwgdHJpZ2dlcmluZ1N0YXRlcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZVJlZ2lvbkltcGxlbWVudGF0aW9uKCk7XG4gIH1cbiAgY2hlY2tQb2ludGVySGlzdG9yeSh0YXJnZXRSZWdpb24sIGV2ZW50KSB7XG4gICAgZm9yIChjb25zdCBoaXN0b3J5RXZlbnQgb2YgZXZlbnQucG9pbnRlckhpc3RvcnkpIHtcbiAgICAgIGNvbnN0IHsgcmVnaW9uOiBoaXN0b3J5UmVnaW9uIH0gPSB0aGlzLnBpY2tSZWdpb24oaGlzdG9yeUV2ZW50Lm9mZnNldFgsIGhpc3RvcnlFdmVudC5vZmZzZXRZKSA/PyB7fTtcbiAgICAgIGlmICh0YXJnZXRSZWdpb24ucHJvcGVydGllcy5uYW1lICE9PSBoaXN0b3J5UmVnaW9uPy5wcm9wZXJ0aWVzLm5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvLyBDcmVhdGUgYW5kIGRpc3BhdGNoIGEgY29weSBvZiB0aGUgSW50ZXJhY3Rpb25FdmVudC5cbiAgZGlzcGF0Y2goY3VycmVudCwgcGFydGlhbEV2ZW50KSB7XG4gICAgaWYgKGN1cnJlbnQgPT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBtYWluQkJveFByb3ZpZGVyID0gY3VycmVudC5yZWdpb24ucHJvcGVydGllcy5iYm94cHJvdmlkZXJzWzBdO1xuICAgIGxldCByZWdpb25PZmZzZXRYID0gMDtcbiAgICBsZXQgcmVnaW9uT2Zmc2V0WSA9IDA7XG4gICAgaWYgKFwib2Zmc2V0WFwiIGluIHBhcnRpYWxFdmVudCAmJiBcIm9mZnNldFlcIiBpbiBwYXJ0aWFsRXZlbnQpIHtcbiAgICAgICh7IHg6IHJlZ2lvbk9mZnNldFgsIHk6IHJlZ2lvbk9mZnNldFkgfSA9IG1haW5CQm94UHJvdmlkZXIuZnJvbUNhbnZhc1BvaW50KFxuICAgICAgICBwYXJ0aWFsRXZlbnQub2Zmc2V0WCxcbiAgICAgICAgcGFydGlhbEV2ZW50Lm9mZnNldFlcbiAgICAgICkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByZWdpb25CQm94ID0gbWFpbkJCb3hQcm92aWRlci50b0NhbnZhc0JCb3goKTtcbiAgICAgIHJlZ2lvbk9mZnNldFggPSByZWdpb25CQm94LndpZHRoIC8gMjtcbiAgICAgIHJlZ2lvbk9mZnNldFkgPSByZWdpb25CQm94LmhlaWdodCAvIDI7XG4gICAgfVxuICAgIGNvbnN0IGV2ZW50ID0gYnVpbGRQcmV2ZW50YWJsZSh7XG4gICAgICAuLi5wYXJ0aWFsRXZlbnQsXG4gICAgICByZWdpb246IGN1cnJlbnQucmVnaW9uLnByb3BlcnRpZXMubmFtZSxcbiAgICAgIGJib3hQcm92aWRlcklkOiBjdXJyZW50LmJib3hQcm92aWRlcj8uaWQsXG4gICAgICByZWdpb25PZmZzZXRYLFxuICAgICAgcmVnaW9uT2Zmc2V0WVxuICAgIH0pO1xuICAgIHRoaXMuZGVidWcoXCJEaXNwYXRjaGluZyByZWdpb24gZXZlbnQ6IFwiLCBldmVudCk7XG4gICAgdGhpcy5hbGxSZWdpb25zTGlzdGVuZXJzLmRpc3BhdGNoKGV2ZW50LnR5cGUsIGV2ZW50KTtcbiAgICBjdXJyZW50LnJlZ2lvbi5saXN0ZW5lcnMuZGlzcGF0Y2goZXZlbnQudHlwZSwgZXZlbnQpO1xuICB9XG4gIC8vIFByb2Nlc3MgZXZlbnRzIGR1cmluZyBhIGRyYWcgYWN0aW9uLiBSZXR1cm5zIGZhbHNlIGlmIHRoaXMgZXZlbnQgc2hvdWxkIGZvbGxvdyB0aGUgc3RhbmRhcmRcbiAgLy8gUmVnaW9uTWFuYWdlci5wcm9jZXNzRXZlbnQgZmxvdywgb3IgdHJ1ZSBpZiB0aGlzIGV2ZW50IGFscmVhZHkgcHJvY2Vzc2VkIGJ5IHRoaXMgZnVuY3Rpb24uXG4gIGhhbmRsZURyYWdnaW5nKGV2ZW50KSB7XG4gICAgY29uc3QgeyBjdXJyZW50IH0gPSB0aGlzO1xuICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgY2FzZSBcImRyYWctc3RhcnRcIjpcbiAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5sZWZ0Q2FudmFzID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImxlYXZlXCI6XG4gICAgICAgIHRoaXMubGVmdENhbnZhcyA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLmlzRHJhZ2dpbmc7XG4gICAgICBjYXNlIFwiZW50ZXJcIjpcbiAgICAgICAgdGhpcy5sZWZ0Q2FudmFzID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzLmlzRHJhZ2dpbmc7XG4gICAgICBjYXNlIFwiZHJhZ1wiOlxuICAgICAgICBpZiAodGhpcy5pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaChjdXJyZW50LCBldmVudCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZHJhZy1lbmRcIjpcbiAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZykge1xuICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuZGlzcGF0Y2goY3VycmVudCwgZXZlbnQpO1xuICAgICAgICAgIGlmICh0aGlzLmxlZnRDYW52YXMpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goY3VycmVudCwgeyAuLi5ldmVudCwgdHlwZTogXCJsZWF2ZVwiIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHByb2Nlc3NQb2ludGVyRXZlbnQoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5oYW5kbGVEcmFnZ2luZyhldmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBjdXJyZW50IH0gPSB0aGlzO1xuICAgIGNvbnN0IGlnbm9yZSA9IHNob3VsZElnbm9yZShldmVudCk7XG4gICAgbGV0IG5ld0N1cnJlbnQ7XG4gICAgc3dpdGNoIChpZ25vcmUpIHtcbiAgICAgIGNhc2UgXCJ3YWl0XCI6XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJub25lXCI6XG4gICAgICAgIG5ld0N1cnJlbnQgPSB0aGlzLnBpY2tSZWdpb24oZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImxlYXZlXCI6XG4gICAgICAgIG5ld0N1cnJlbnQgPSB2b2lkIDA7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBuZXdSZWdpb24gPSBuZXdDdXJyZW50Py5yZWdpb247XG4gICAgaWYgKGN1cnJlbnQgIT09IHZvaWQgMCAmJiBuZXdSZWdpb24/LnByb3BlcnRpZXMubmFtZSAhPT0gY3VycmVudC5yZWdpb24ucHJvcGVydGllcy5uYW1lKSB7XG4gICAgICB0aGlzLmRpc3BhdGNoKGN1cnJlbnQsIHsgLi4uZXZlbnQsIHR5cGU6IFwibGVhdmVcIiB9KTtcbiAgICB9XG4gICAgaWYgKG5ld1JlZ2lvbiAhPT0gdm9pZCAwICYmIG5ld1JlZ2lvbi5wcm9wZXJ0aWVzLm5hbWUgIT09IGN1cnJlbnQ/LnJlZ2lvbi5wcm9wZXJ0aWVzLm5hbWUpIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2gobmV3Q3VycmVudCwgeyAuLi5ldmVudCwgdHlwZTogXCJlbnRlclwiIH0pO1xuICAgIH1cbiAgICBpZiAobmV3UmVnaW9uICE9PSB2b2lkIDAgJiYgdGhpcy5jaGVja1BvaW50ZXJIaXN0b3J5KG5ld1JlZ2lvbiwgZXZlbnQpKSB7XG4gICAgICB0aGlzLmRpc3BhdGNoKG5ld0N1cnJlbnQsIGV2ZW50KTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50ID0gbmV3Q3VycmVudDtcbiAgfVxuICBwaWNrUmVnaW9uKHgsIHkpIHtcbiAgICBsZXQgY3VycmVudEFyZWEgPSBJbmZpbml0eTtcbiAgICBsZXQgY3VycmVudFJlZ2lvbjtcbiAgICBsZXQgY3VycmVudEJCb3hQcm92aWRlcjtcbiAgICBmb3IgKGNvbnN0IHJlZ2lvbiBvZiB0aGlzLnJlZ2lvbnMudmFsdWVzKCkpIHtcbiAgICAgIGZvciAoY29uc3QgcHJvdmlkZXIgb2YgcmVnaW9uLnByb3BlcnRpZXMuYmJveHByb3ZpZGVycykge1xuICAgICAgICBpZiAocHJvdmlkZXIudmlzaWJsZSA9PT0gZmFsc2UpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IGJib3ggPSBwcm92aWRlci50b0NhbnZhc0JCb3goKTtcbiAgICAgICAgY29uc3QgYXJlYTIgPSBiYm94LndpZHRoICogYmJveC5oZWlnaHQ7XG4gICAgICAgIGlmIChhcmVhMiA8IGN1cnJlbnRBcmVhICYmIGJib3guY29udGFpbnNQb2ludCh4LCB5KSkge1xuICAgICAgICAgIGN1cnJlbnRBcmVhID0gYXJlYTI7XG4gICAgICAgICAgY3VycmVudFJlZ2lvbiA9IHJlZ2lvbjtcbiAgICAgICAgICBjdXJyZW50QkJveFByb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnRSZWdpb24gPyB7IHJlZ2lvbjogY3VycmVudFJlZ2lvbiwgYmJveFByb3ZpZGVyOiBjdXJyZW50QkJveFByb3ZpZGVyIH0gOiB2b2lkIDA7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Rvb2xiYXIvdG9vbGJhclR5cGVzLnRzXG52YXIgVE9PTEJBUl9BTElHTk1FTlRTID0gW1wic3RhcnRcIiwgXCJjZW50ZXJcIiwgXCJlbmRcIl07XG52YXIgVE9PTEJBUl9HUk9VUFMgPSBbXCJzZXJpZXNUeXBlXCIsIFwiYW5ub3RhdGlvbnNcIiwgXCJhbm5vdGF0aW9uT3B0aW9uc1wiLCBcInJhbmdlc1wiLCBcInpvb21cIl07XG52YXIgVE9PTEJBUl9HUk9VUF9PUkRFUklORyA9IHtcbiAgc2VyaWVzVHlwZTogMCxcbiAgYW5ub3RhdGlvbnM6IDEsXG4gIGFubm90YXRpb25PcHRpb25zOiAyLFxuICByYW5nZXM6IDMsXG4gIHpvb206IDRcbn07XG52YXIgVG9vbGJhclBvc2l0aW9uID0gLyogQF9fUFVSRV9fICovICgoVG9vbGJhclBvc2l0aW9uMikgPT4ge1xuICBUb29sYmFyUG9zaXRpb24yW1wiVG9wXCJdID0gXCJ0b3BcIjtcbiAgVG9vbGJhclBvc2l0aW9uMltcIkxlZnRcIl0gPSBcImxlZnRcIjtcbiAgVG9vbGJhclBvc2l0aW9uMltcIlJpZ2h0XCJdID0gXCJyaWdodFwiO1xuICBUb29sYmFyUG9zaXRpb24yW1wiQm90dG9tXCJdID0gXCJib3R0b21cIjtcbiAgVG9vbGJhclBvc2l0aW9uMltcIkZsb2F0aW5nXCJdID0gXCJmbG9hdGluZ1wiO1xuICBUb29sYmFyUG9zaXRpb24yW1wiRmxvYXRpbmdUb3BcIl0gPSBcImZsb2F0aW5nLXRvcFwiO1xuICBUb29sYmFyUG9zaXRpb24yW1wiRmxvYXRpbmdCb3R0b21cIl0gPSBcImZsb2F0aW5nLWJvdHRvbVwiO1xuICByZXR1cm4gVG9vbGJhclBvc2l0aW9uMjtcbn0pKFRvb2xiYXJQb3NpdGlvbiB8fCB7fSk7XG52YXIgVE9PTEJBUl9QT1NJVElPTlMgPSBPYmplY3QudmFsdWVzKFRvb2xiYXJQb3NpdGlvbik7XG5mdW5jdGlvbiBpc0FuaW1hdGluZ0Zsb2F0aW5nUG9zaXRpb24ocG9zaXRpb24pIHtcbiAgcmV0dXJuIFtcImZsb2F0aW5nLXRvcFwiIC8qIEZsb2F0aW5nVG9wICovLCBcImZsb2F0aW5nLWJvdHRvbVwiIC8qIEZsb2F0aW5nQm90dG9tICovXS5pbmNsdWRlcyhwb3NpdGlvbik7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2ludGVyYWN0aW9uL3Rvb2xiYXJNYW5hZ2VyLnRzXG52YXIgVG9vbGJhck1hbmFnZXIgPSBjbGFzcyBleHRlbmRzIEJhc2VNYW5hZ2VyIHtcbiAgc3RhdGljIGlzR3JvdXAoZ3JvdXAsIGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50Lmdyb3VwID09PSBncm91cDtcbiAgfVxuICBzdGF0aWMgaXNDaGlsZEVsZW1lbnQoZG9tTWFuYWdlciwgZWxlbWVudDIpIHtcbiAgICBmb3IgKGNvbnN0IHBvc2l0aW9uIG9mIFRPT0xCQVJfUE9TSVRJT05TKSB7XG4gICAgICBpZiAoZG9tTWFuYWdlci5pc01hbmFnZWRDaGlsZERPTUVsZW1lbnQoZWxlbWVudDIsIFwiY2FudmFzLW92ZXJsYXlcIiwgYHRvb2xiYXItJHtwb3NpdGlvbn1gKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHByZXNzQnV0dG9uKGdyb3VwLCBpZCwgdmFsdWUsIHJlY3QsIHNvdXJjZUV2ZW50KSB7XG4gICAgdGhpcy5saXN0ZW5lcnMuZGlzcGF0Y2goXCJidXR0b24tcHJlc3NlZFwiLCB7IHR5cGU6IFwiYnV0dG9uLXByZXNzZWRcIiwgZ3JvdXAsIGlkLCB2YWx1ZSwgcmVjdCwgc291cmNlRXZlbnQgfSk7XG4gIH1cbiAgY2FuY2VsKGdyb3VwKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMuZGlzcGF0Y2goXCJjYW5jZWxsZWRcIiwgeyB0eXBlOiBcImNhbmNlbGxlZFwiLCBncm91cCB9KTtcbiAgfVxuICB0b2dnbGVCdXR0b24oZ3JvdXAsIGlkLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBhY3RpdmUgPSBmYWxzZSwgZW5hYmxlZCA9IHRydWUsIHZpc2libGUgPSB0cnVlLCBjaGVja2VkID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gICAgdGhpcy5saXN0ZW5lcnMuZGlzcGF0Y2goXCJidXR0b24tdG9nZ2xlZFwiLCB7XG4gICAgICB0eXBlOiBcImJ1dHRvbi10b2dnbGVkXCIsXG4gICAgICBncm91cCxcbiAgICAgIGlkLFxuICAgICAgYWN0aXZlLFxuICAgICAgZW5hYmxlZCxcbiAgICAgIHZpc2libGUsXG4gICAgICBjaGVja2VkXG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlQnV0dG9uKGdyb3VwLCBpZCwgb3B0aW9ucykge1xuICAgIHRoaXMubGlzdGVuZXJzLmRpc3BhdGNoKFwiYnV0dG9uLXVwZGF0ZWRcIiwgeyB0eXBlOiBcImJ1dHRvbi11cGRhdGVkXCIsIGdyb3VwLCBpZCwgLi4ub3B0aW9ucyB9KTtcbiAgfVxuICB0b2dnbGVHcm91cChjYWxsZXIsIGdyb3VwLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBhY3RpdmUsIHZpc2libGUgfSA9IG9wdGlvbnM7XG4gICAgdGhpcy5saXN0ZW5lcnMuZGlzcGF0Y2goXCJncm91cC10b2dnbGVkXCIsIHsgdHlwZTogXCJncm91cC10b2dnbGVkXCIsIGNhbGxlciwgZ3JvdXAsIGFjdGl2ZSwgdmlzaWJsZSB9KTtcbiAgfVxuICB1cGRhdGVHcm91cChncm91cCkge1xuICAgIHRoaXMubGlzdGVuZXJzLmRpc3BhdGNoKFwiZ3JvdXAtdXBkYXRlZFwiLCB7IHR5cGU6IFwiZ3JvdXAtdXBkYXRlZFwiLCBncm91cCB9KTtcbiAgfVxuICBncm91cE1vdmVkKGdyb3VwKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMuZGlzcGF0Y2goXCJncm91cC1tb3ZlZFwiLCB7IHR5cGU6IFwiZ3JvdXAtbW92ZWRcIiwgZ3JvdXAgfSk7XG4gIH1cbiAgY2hhbmdlRmxvYXRpbmdBbmNob3IoZ3JvdXAsIGFuY2hvcikge1xuICAgIHRoaXMubGlzdGVuZXJzLmRpc3BhdGNoKFwiZmxvYXRpbmctYW5jaG9yLWNoYW5nZWRcIiwge1xuICAgICAgdHlwZTogXCJmbG9hdGluZy1hbmNob3ItY2hhbmdlZFwiLFxuICAgICAgZ3JvdXAsXG4gICAgICBhbmNob3JcbiAgICB9KTtcbiAgfVxuICBidXR0b25Nb3ZlZChncm91cCwgdmFsdWUsIHJlY3QsIGdyb3VwUmVjdCkge1xuICAgIHRoaXMubGlzdGVuZXJzLmRpc3BhdGNoKFwiYnV0dG9uLW1vdmVkXCIsIHsgdHlwZTogXCJidXR0b24tbW92ZWRcIiwgZ3JvdXAsIHZhbHVlLCByZWN0LCBncm91cFJlY3QgfSk7XG4gIH1cbiAgcHJveHlHcm91cE9wdGlvbnMoY2FsbGVyLCBncm91cCwgb3B0aW9ucykge1xuICAgIHRoaXMubGlzdGVuZXJzLmRpc3BhdGNoKFwicHJveHktZ3JvdXAtb3B0aW9uc1wiLCB7IHR5cGU6IFwicHJveHktZ3JvdXAtb3B0aW9uc1wiLCBjYWxsZXIsIGdyb3VwLCBvcHRpb25zIH0pO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9pbnRlcmFjdGlvbi90b29sdGlwTWFuYWdlci50c1xudmFyIFRvb2x0aXBNYW5hZ2VyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihkb21NYW5hZ2VyLCB0b29sdGlwKSB7XG4gICAgdGhpcy5kb21NYW5hZ2VyID0gZG9tTWFuYWdlcjtcbiAgICB0aGlzLnRvb2x0aXAgPSB0b29sdGlwO1xuICAgIHRoaXMuc3RhdGVUcmFja2VyID0gbmV3IFN0YXRlVHJhY2tlcigpO1xuICAgIHRoaXMuc3VwcHJlc3NTdGF0ZSA9IG5ldyBTdGF0ZVRyYWNrZXIoZmFsc2UpO1xuICAgIHRoaXMuYXBwbGllZFN0YXRlID0gbnVsbDtcbiAgICB0b29sdGlwLnNldHVwKGRvbU1hbmFnZXIpO1xuICAgIGRvbU1hbmFnZXIuYWRkTGlzdGVuZXIoXCJoaWRkZW5cIiwgKCkgPT4gdGhpcy50b29sdGlwLnRvZ2dsZShmYWxzZSkpO1xuICB9XG4gIHVwZGF0ZVRvb2x0aXAoY2FsbGVySWQsIG1ldGEsIGNvbnRlbnQpIHtcbiAgICBpZiAoIXRoaXMudG9vbHRpcC5lbmFibGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnRlbnQgPz8gKGNvbnRlbnQgPSB0aGlzLnN0YXRlVHJhY2tlci5nZXQoY2FsbGVySWQpPy5jb250ZW50KTtcbiAgICB0aGlzLnN0YXRlVHJhY2tlci5zZXQoY2FsbGVySWQsIHsgY29udGVudCwgbWV0YSB9KTtcbiAgICB0aGlzLmFwcGx5U3RhdGVzKCk7XG4gIH1cbiAgcmVtb3ZlVG9vbHRpcChjYWxsZXJJZCkge1xuICAgIGlmICghdGhpcy50b29sdGlwLmVuYWJsZWQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5zdGF0ZVRyYWNrZXIuZGVsZXRlKGNhbGxlcklkKTtcbiAgICB0aGlzLmFwcGx5U3RhdGVzKCk7XG4gIH1cbiAgc3VwcHJlc3NUb29sdGlwKGNhbGxlcklkKSB7XG4gICAgdGhpcy5zdXBwcmVzc1N0YXRlLnNldChjYWxsZXJJZCwgdHJ1ZSk7XG4gIH1cbiAgdW5zdXBwcmVzc1Rvb2x0aXAoY2FsbGVySWQpIHtcbiAgICB0aGlzLnN1cHByZXNzU3RhdGUuZGVsZXRlKGNhbGxlcklkKTtcbiAgfVxuICBnZXRUb29sdGlwTWV0YShjYWxsZXJJZCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlVHJhY2tlci5nZXQoY2FsbGVySWQpPy5tZXRhO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kb21NYW5hZ2VyLnJlbW92ZVN0eWxlcyhcInRvb2x0aXBcIik7XG4gIH1cbiAgYXBwbHlTdGF0ZXMoKSB7XG4gICAgY29uc3QgaWQgPSB0aGlzLnN0YXRlVHJhY2tlci5zdGF0ZUlkKCk7XG4gICAgY29uc3Qgc3RhdGUgPSBpZCA/IHRoaXMuc3RhdGVUcmFja2VyLmdldChpZCkgOiBudWxsO1xuICAgIGlmICh0aGlzLnN1cHByZXNzU3RhdGUuc3RhdGVWYWx1ZSgpIHx8IHN0YXRlPy5tZXRhID09IG51bGwgfHwgc3RhdGU/LmNvbnRlbnQgPT0gbnVsbCkge1xuICAgICAgdGhpcy5hcHBsaWVkU3RhdGUgPSBudWxsO1xuICAgICAgdGhpcy50b29sdGlwLnRvZ2dsZShmYWxzZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNhbnZhc1JlY3QgPSB0aGlzLmRvbU1hbmFnZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgYm91bmRpbmdSZWN0ID0gdGhpcy50b29sdGlwLmJvdW5kcyA9PT0gXCJleHRlbmRlZFwiID8gdGhpcy5kb21NYW5hZ2VyLmdldE92ZXJsYXlDbGllbnRSZWN0KCkgOiBjYW52YXNSZWN0O1xuICAgIGlmICh0aGlzLmFwcGxpZWRTdGF0ZT8uY29udGVudCA9PT0gc3RhdGU/LmNvbnRlbnQpIHtcbiAgICAgIGNvbnN0IHJlbmRlckluc3RhbnRseSA9IHRoaXMudG9vbHRpcC5pc1Zpc2libGUoKTtcbiAgICAgIHRoaXMudG9vbHRpcC5zaG93KGJvdW5kaW5nUmVjdCwgY2FudmFzUmVjdCwgc3RhdGU/Lm1ldGEsIG51bGwsIHJlbmRlckluc3RhbnRseSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudG9vbHRpcC5zaG93KGJvdW5kaW5nUmVjdCwgY2FudmFzUmVjdCwgc3RhdGU/Lm1ldGEsIHN0YXRlPy5jb250ZW50KTtcbiAgICB9XG4gICAgdGhpcy5hcHBsaWVkU3RhdGUgPSBzdGF0ZTtcbiAgfVxuICBzdGF0aWMgbWFrZVRvb2x0aXBNZXRhKGV2ZW50LCBkYXR1bSkge1xuICAgIGNvbnN0IHsgb2Zmc2V0WCwgb2Zmc2V0WSB9ID0gZXZlbnQ7XG4gICAgY29uc3QgdG9vbHRpcCA9IGRhdHVtLnNlcmllcy5wcm9wZXJ0aWVzLnRvb2x0aXA7XG4gICAgY29uc3QgbWV0YSA9IHtcbiAgICAgIG9mZnNldFgsXG4gICAgICBvZmZzZXRZLFxuICAgICAgZW5hYmxlSW50ZXJhY3Rpb246IHRvb2x0aXAuaW50ZXJhY3Rpb24/LmVuYWJsZWQgPz8gZmFsc2UsXG4gICAgICBsYXN0UG9pbnRlckV2ZW50OiB7IHR5cGU6IGV2ZW50LnR5cGUsIG9mZnNldFgsIG9mZnNldFkgfSxcbiAgICAgIHNob3dBcnJvdzogdG9vbHRpcC5zaG93QXJyb3csXG4gICAgICBwb3NpdGlvbjoge1xuICAgICAgICB0eXBlOiB0b29sdGlwLnBvc2l0aW9uLnR5cGUsXG4gICAgICAgIHhPZmZzZXQ6IHRvb2x0aXAucG9zaXRpb24ueE9mZnNldCxcbiAgICAgICAgeU9mZnNldDogdG9vbHRpcC5wb3NpdGlvbi55T2Zmc2V0XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZWZQb2ludCA9IGRhdHVtLnlCYXI/LnVwcGVyUG9pbnQgPz8gZGF0dW0ubWlkUG9pbnQgPz8gZGF0dW0uc2VyaWVzLmRhdHVtTWlkUG9pbnQ/LihkYXR1bSk7XG4gICAgaWYgKCh0b29sdGlwLnBvc2l0aW9uLnR5cGUgPT09IFwibm9kZVwiIHx8IHRvb2x0aXAucG9zaXRpb24udHlwZSA9PT0gXCJzcGFya2xpbmVcIikgJiYgcmVmUG9pbnQpIHtcbiAgICAgIGNvbnN0IHsgeCwgeSB9ID0gcmVmUG9pbnQ7XG4gICAgICBjb25zdCBwb2ludCA9IFRyYW5zZm9ybWFibGUudG9DYW52YXNQb2ludChkYXR1bS5zZXJpZXMuY29udGVudEdyb3VwLCB4LCB5KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm1ldGEsXG4gICAgICAgIG9mZnNldFg6IE1hdGgucm91bmQocG9pbnQueCksXG4gICAgICAgIG9mZnNldFk6IE1hdGgucm91bmQocG9pbnQueSlcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBtZXRhO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9pbnRlcmFjdGlvbi96b29tTWFuYWdlci50c1xudmFyIFpvb21NYW5hZ2VyID0gY2xhc3MgZXh0ZW5kcyBCYXNlTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5tZW1lbnRvT3JpZ2luYXRvcktleSA9IFwiem9vbVwiO1xuICAgIHRoaXMuYXhpc1pvb21NYW5hZ2VycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5zdGF0ZSA9IG5ldyBTdGF0ZVRyYWNrZXIodm9pZCAwLCBcImluaXRpYWxcIik7XG4gICAgdGhpcy5yZWplY3RDYWxsYmFja3MgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIGFkZExheW91dExpc3RlbmVycyhsYXlvdXRNYW5hZ2VyKSB7XG4gICAgdGhpcy5kZXN0cm95Rm5zLnB1c2goXG4gICAgICBsYXlvdXRNYW5hZ2VyLmFkZExpc3RlbmVyKFwibGF5b3V0OmNvbXBsZXRlXCIsIChldmVudCkgPT4ge1xuICAgICAgICB0aGlzLmF4ZXMgPSBldmVudC5heGVzO1xuICAgICAgfSlcbiAgICApO1xuICB9XG4gIGNyZWF0ZU1lbWVudG8oKSB7XG4gICAgY29uc3Qgem9vbTIgPSB0aGlzLmdldERlZmluZWRab29tKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJhbmdlWDogdGhpcy5nZXRSYW5nZURpcmVjdGlvbih6b29tMiwgXCJ4XCIgLyogWCAqLyksXG4gICAgICByYW5nZVk6IHRoaXMuZ2V0UmFuZ2VEaXJlY3Rpb24oem9vbTIsIFwieVwiIC8qIFkgKi8pLFxuICAgICAgcmF0aW9YOiB7IHN0YXJ0OiB6b29tMi54Lm1pbiwgZW5kOiB6b29tMi54Lm1heCB9LFxuICAgICAgcmF0aW9ZOiB7IHN0YXJ0OiB6b29tMi55Lm1pbiwgZW5kOiB6b29tMi55Lm1heCB9XG4gICAgfTtcbiAgfVxuICBndWFyZE1lbWVudG8oYmxvYikge1xuICAgIHJldHVybiBpc09iamVjdChibG9iKSAmJiAoYmxvYi5yYXRpb1ggIT0gbnVsbCB8fCBibG9iLnJhdGlvWSAhPSBudWxsIHx8IGJsb2IucmFuZ2VYICE9IG51bGwgfHwgYmxvYi5yYW5nZVkgIT0gbnVsbCk7XG4gIH1cbiAgcmVzdG9yZU1lbWVudG8oX3ZlcnNpb24sIF9tZW1lbnRvVmVyc2lvbiwgbWVtZW50bykge1xuICAgIHRoaXMubGlzdGVuZXJzLmRpc3BhdGNoKFwicmVzdG9yZS16b29tXCIsIHsgLi4ubWVtZW50bywgdHlwZTogXCJyZXN0b3JlLXpvb21cIiB9KTtcbiAgfVxuICB1cGRhdGVBeGVzKGF4ZXMpIHtcbiAgICBjb25zdCB6b29tTWFuYWdlcnMgPSBuZXcgTWFwKGF4ZXMubWFwKChheGlzKSA9PiBbYXhpcy5pZCwgdGhpcy5heGlzWm9vbU1hbmFnZXJzLmdldChheGlzLmlkKV0pKTtcbiAgICB0aGlzLmF4aXNab29tTWFuYWdlcnMuY2xlYXIoKTtcbiAgICBmb3IgKGNvbnN0IGF4aXMgb2YgYXhlcykge1xuICAgICAgdGhpcy5heGlzWm9vbU1hbmFnZXJzLnNldChheGlzLmlkLCB6b29tTWFuYWdlcnMuZ2V0KGF4aXMuaWQpID8/IG5ldyBBeGlzWm9vbU1hbmFnZXIoYXhpcykpO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdGF0ZS5zaXplID4gMCAmJiBheGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMudXBkYXRlWm9vbSh0aGlzLnN0YXRlLnN0YXRlSWQoKSwgdGhpcy5zdGF0ZS5zdGF0ZVZhbHVlKCkpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVab29tKGNhbGxlcklkLCBuZXdab29tLCBjYW5DaGFuZ2VJbml0aWFsID0gdHJ1ZSwgcmVqZWN0Q2FsbGJhY2spIHtcbiAgICBpZiAocmVqZWN0Q2FsbGJhY2spIHtcbiAgICAgIHRoaXMucmVqZWN0Q2FsbGJhY2tzLnNldChjYWxsZXJJZCwgcmVqZWN0Q2FsbGJhY2spO1xuICAgIH1cbiAgICBpZiAodGhpcy5heGlzWm9vbU1hbmFnZXJzLnNpemUgPT09IDApIHtcbiAgICAgIGNvbnN0IHN0YXRlSWQgPSB0aGlzLnN0YXRlLnN0YXRlSWQoKTtcbiAgICAgIGlmIChzdGF0ZUlkID09PSBcImluaXRpYWxcIiB8fCBzdGF0ZUlkID09PSBjYWxsZXJJZCB8fCBjYW5DaGFuZ2VJbml0aWFsKSB7XG4gICAgICAgIHRoaXMuc3RhdGUuc2V0KGNhbGxlcklkLCBuZXdab29tKTtcbiAgICAgICAgaWYgKHN0YXRlSWQgIT09IGNhbGxlcklkKSB7XG4gICAgICAgICAgdGhpcy5yZWplY3RDYWxsYmFja3MuZ2V0KHN0YXRlSWQpPy4oY2FsbGVySWQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWplY3RDYWxsYmFjaz8uKHN0YXRlSWQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlLnNldChjYWxsZXJJZCwgbmV3Wm9vbSk7XG4gICAgdGhpcy5heGlzWm9vbU1hbmFnZXJzLmZvckVhY2goKGF4aXMpID0+IHtcbiAgICAgIGF4aXMudXBkYXRlWm9vbShjYWxsZXJJZCwgbmV3Wm9vbT8uW2F4aXMuZ2V0RGlyZWN0aW9uKCldKTtcbiAgICB9KTtcbiAgICB0aGlzLmFwcGx5Q2hhbmdlcyhjYWxsZXJJZCk7XG4gIH1cbiAgdXBkYXRlQXhpc1pvb20oY2FsbGVySWQsIGF4aXNJZCwgbmV3Wm9vbSkge1xuICAgIHRoaXMuYXhpc1pvb21NYW5hZ2Vycy5nZXQoYXhpc0lkKT8udXBkYXRlWm9vbShjYWxsZXJJZCwgbmV3Wm9vbSk7XG4gICAgdGhpcy5hcHBseUNoYW5nZXMoY2FsbGVySWQpO1xuICB9XG4gIC8vIEZpcmUgdGhpcyBldmVudCB0byBzaWduYWwgdG8gbGlzdGVuZXJzIHRoYXQgdGhlIHZpZXcgaXMgY2hhbmdpbmcgdGhyb3VnaCBhIHpvb20gYW5kL29yIHBhbiBjaGFuZ2UuXG4gIGZpcmVab29tUGFuU3RhcnRFdmVudChjYWxsZXJJZCkge1xuICAgIHRoaXMubGlzdGVuZXJzLmRpc3BhdGNoKFwiem9vbS1wYW4tc3RhcnRcIiwgeyB0eXBlOiBcInpvb20tcGFuLXN0YXJ0XCIsIGNhbGxlcklkIH0pO1xuICB9XG4gIGdldFpvb20oKSB7XG4gICAgbGV0IHg7XG4gICAgbGV0IHk7XG4gICAgdGhpcy5heGlzWm9vbU1hbmFnZXJzLmZvckVhY2goKGF4aXMpID0+IHtcbiAgICAgIGlmIChheGlzLmdldERpcmVjdGlvbigpID09PSBcInhcIiAvKiBYICovKSB7XG4gICAgICAgIHggPz8gKHggPSBheGlzLmdldFpvb20oKSk7XG4gICAgICB9IGVsc2UgaWYgKGF4aXMuZ2V0RGlyZWN0aW9uKCkgPT09IFwieVwiIC8qIFkgKi8pIHtcbiAgICAgICAgeSA/PyAoeSA9IGF4aXMuZ2V0Wm9vbSgpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoeCB8fCB5KSB7XG4gICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgfVxuICB9XG4gIGdldEF4aXNab29tKGF4aXNJZCkge1xuICAgIHJldHVybiB0aGlzLmF4aXNab29tTWFuYWdlcnMuZ2V0KGF4aXNJZCk/LmdldFpvb20oKSA/PyB7IG1pbjogMCwgbWF4OiAxIH07XG4gIH1cbiAgZ2V0QXhpc1pvb21zKCkge1xuICAgIGNvbnN0IGF4ZXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtheGlzSWQsIGF4aXNdIG9mIHRoaXMuYXhpc1pvb21NYW5hZ2Vycy5lbnRyaWVzKCkpIHtcbiAgICAgIGF4ZXNbYXhpc0lkXSA9IHtcbiAgICAgICAgZGlyZWN0aW9uOiBheGlzLmdldERpcmVjdGlvbigpLFxuICAgICAgICB6b29tOiBheGlzLmdldFpvb20oKVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGF4ZXM7XG4gIH1cbiAgYXBwbHlDaGFuZ2VzKGNhbGxlcklkKSB7XG4gICAgY29uc3QgY2hhbmdlZCA9IEFycmF5LmZyb20odGhpcy5heGlzWm9vbU1hbmFnZXJzLnZhbHVlcygpLCAoYXhpcykgPT4gYXhpcy5hcHBseUNoYW5nZXMoKSkuc29tZShCb29sZWFuKTtcbiAgICBpZiAoIWNoYW5nZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYXhlcyA9IHt9O1xuICAgIGZvciAoY29uc3QgW2F4aXNJZCwgYXhpc10gb2YgdGhpcy5heGlzWm9vbU1hbmFnZXJzLmVudHJpZXMoKSkge1xuICAgICAgYXhlc1theGlzSWRdID0gYXhpcy5nZXRab29tKCk7XG4gICAgfVxuICAgIHRoaXMubGlzdGVuZXJzLmRpc3BhdGNoKFwiem9vbS1jaGFuZ2VcIiwgeyB0eXBlOiBcInpvb20tY2hhbmdlXCIsIC4uLnRoaXMuZ2V0Wm9vbSgpLCBheGVzLCBjYWxsZXJJZCB9KTtcbiAgfVxuICBnZXRSYW5nZURpcmVjdGlvbih6b29tMiwgZGlyZWN0aW9uKSB7XG4gICAgZm9yIChjb25zdCBheGlzIG9mIHRoaXMuYXhlcyA/PyBbXSkge1xuICAgICAgaWYgKGF4aXMuZGlyZWN0aW9uICE9PSBkaXJlY3Rpb24pXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3QgZG9tYWluID0gYXhpcy5zY2FsZS5nZXREb21haW4/LigpO1xuICAgICAgY29uc3QgZDAgPSBheGlzLnNjYWxlLmNvbnZlcnQ/Lihkb21haW4/LmF0KDApKTtcbiAgICAgIGNvbnN0IGQxID0gYXhpcy5zY2FsZS5jb252ZXJ0Py4oZG9tYWluPy5hdCgtMSkpO1xuICAgICAgaWYgKCFpc0Zpbml0ZU51bWJlcihkMCkgfHwgIWlzRmluaXRlTnVtYmVyKGQxKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgbGV0IHN0YXJ0MjtcbiAgICAgIGxldCBlbmQyO1xuICAgICAgaWYgKGQwIDw9IGQxKSB7XG4gICAgICAgIGNvbnN0IGRpZmYyID0gZDEgLSBkMDtcbiAgICAgICAgc3RhcnQyID0gYXhpcy5zY2FsZS5pbnZlcnQ/LigwKTtcbiAgICAgICAgZW5kMiA9IGF4aXMuc2NhbGUuaW52ZXJ0Py4oZDAgKyBkaWZmMiAqIHpvb20yW2RpcmVjdGlvbl0ubWF4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGRpZmYyID0gZDAgLSBkMTtcbiAgICAgICAgc3RhcnQyID0gYXhpcy5zY2FsZS5pbnZlcnQ/LihkMCAtIGRpZmYyICogem9vbTJbZGlyZWN0aW9uXS5taW4pO1xuICAgICAgICBlbmQyID0gYXhpcy5zY2FsZS5pbnZlcnQ/LigwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHN0YXJ0OiBzdGFydDIsIGVuZDogZW5kMiB9O1xuICAgIH1cbiAgfVxuICBnZXREZWZpbmVkWm9vbSgpIHtcbiAgICBjb25zdCB6b29tMiA9IHRoaXMuZ2V0Wm9vbSgpO1xuICAgIHJldHVybiB7XG4gICAgICB4OiB7IG1pbjogem9vbTI/Lng/Lm1pbiA/PyAwLCBtYXg6IHpvb20yPy54Py5tYXggPz8gMSB9LFxuICAgICAgeTogeyBtaW46IHpvb20yPy55Py5taW4gPz8gMCwgbWF4OiB6b29tMj8ueT8ubWF4ID8/IDEgfVxuICAgIH07XG4gIH1cbn07XG52YXIgQXhpc1pvb21NYW5hZ2VyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihheGlzKSB7XG4gICAgdGhpcy5heGlzID0gYXhpcztcbiAgICBjb25zdCBbbWluID0gMCwgbWF4ID0gMV0gPSBheGlzLnZpc2libGVSYW5nZTtcbiAgICB0aGlzLnN0YXRlID0gbmV3IFN0YXRlVHJhY2tlcih7IG1pbiwgbWF4IH0pO1xuICAgIHRoaXMuY3VycmVudFpvb20gPSB0aGlzLnN0YXRlLnN0YXRlVmFsdWUoKTtcbiAgfVxuICBnZXREaXJlY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYXhpcy5kaXJlY3Rpb247XG4gIH1cbiAgdXBkYXRlWm9vbShjYWxsZXJJZCwgbmV3Wm9vbSkge1xuICAgIHRoaXMuc3RhdGUuc2V0KGNhbGxlcklkLCBuZXdab29tKTtcbiAgfVxuICBnZXRab29tKCkge1xuICAgIHJldHVybiBkZWVwQ2xvbmUodGhpcy5zdGF0ZS5zdGF0ZVZhbHVlKCkpO1xuICB9XG4gIGFwcGx5Q2hhbmdlcygpIHtcbiAgICBjb25zdCBwcmV2Wm9vbSA9IHRoaXMuY3VycmVudFpvb207XG4gICAgdGhpcy5jdXJyZW50Wm9vbSA9IHRoaXMuc3RhdGUuc3RhdGVWYWx1ZSgpO1xuICAgIHJldHVybiBwcmV2Wm9vbS5taW4gIT09IHRoaXMuY3VycmVudFpvb20ubWluIHx8IHByZXZab29tLm1heCAhPT0gdGhpcy5jdXJyZW50Wm9vbS5tYXg7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9zZXJpZXNTdGF0ZU1hbmFnZXIudHNcbnZhciBTZXJpZXNTdGF0ZU1hbmFnZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZ3JvdXBzID0ge307XG4gIH1cbiAgcmVnaXN0ZXJTZXJpZXMoeyBpbnRlcm5hbElkLCBzZXJpZXNHcm91cGluZywgdmlzaWJsZSwgdHlwZSB9KSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghc2VyaWVzR3JvdXBpbmcpXG4gICAgICByZXR1cm47XG4gICAgKF9hID0gdGhpcy5ncm91cHMpW3R5cGVdID8/IChfYVt0eXBlXSA9IHt9KTtcbiAgICB0aGlzLmdyb3Vwc1t0eXBlXVtpbnRlcm5hbElkXSA9IHsgZ3JvdXBpbmc6IHNlcmllc0dyb3VwaW5nLCB2aXNpYmxlIH07XG4gIH1cbiAgdXBkYXRlU2VyaWVzKHsgaW50ZXJuYWxJZCwgc2VyaWVzR3JvdXBpbmcsIHZpc2libGUsIHR5cGUgfSkge1xuICAgIGlmICghc2VyaWVzR3JvdXBpbmcpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZW50cnkgPSB0aGlzLmdyb3Vwc1t0eXBlXT8uW2ludGVybmFsSWRdO1xuICAgIGlmIChlbnRyeSkge1xuICAgICAgZW50cnkuZ3JvdXBpbmcgPSBzZXJpZXNHcm91cGluZztcbiAgICAgIGVudHJ5LnZpc2libGUgPSB2aXNpYmxlO1xuICAgIH1cbiAgfVxuICBkZXJlZ2lzdGVyU2VyaWVzKHsgaW50ZXJuYWxJZCwgdHlwZSB9KSB7XG4gICAgaWYgKHRoaXMuZ3JvdXBzW3R5cGVdKSB7XG4gICAgICBkZWxldGUgdGhpcy5ncm91cHNbdHlwZV1baW50ZXJuYWxJZF07XG4gICAgfVxuICAgIGlmICh0aGlzLmdyb3Vwc1t0eXBlXSAmJiBPYmplY3Qua2V5cyh0aGlzLmdyb3Vwc1t0eXBlXSkubGVuZ3RoID09PSAwKSB7XG4gICAgICBkZWxldGUgdGhpcy5ncm91cHNbdHlwZV07XG4gICAgfVxuICB9XG4gIGdldFZpc2libGVQZWVyR3JvdXBJbmRleCh7IHR5cGUsIHNlcmllc0dyb3VwaW5nLCB2aXNpYmxlIH0pIHtcbiAgICBpZiAoIXNlcmllc0dyb3VwaW5nKVxuICAgICAgcmV0dXJuIHsgdmlzaWJsZUdyb3VwQ291bnQ6IHZpc2libGUgPyAxIDogMCwgdmlzaWJsZVNhbWVTdGFja0NvdW50OiB2aXNpYmxlID8gMSA6IDAsIGluZGV4OiAwIH07XG4gICAgY29uc3QgdmlzaWJsZUdyb3Vwc1NldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3QgdmlzaWJsZVNhbWVTdGFja1NldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiBPYmplY3QudmFsdWVzKHRoaXMuZ3JvdXBzW3R5cGVdID8/IHt9KSkge1xuICAgICAgaWYgKCFlbnRyeS52aXNpYmxlKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHZpc2libGVHcm91cHNTZXQuYWRkKGVudHJ5Lmdyb3VwaW5nLmdyb3VwSW5kZXgpO1xuICAgICAgaWYgKGVudHJ5Lmdyb3VwaW5nLmdyb3VwSW5kZXggPT09IHNlcmllc0dyb3VwaW5nLmdyb3VwSW5kZXgpIHtcbiAgICAgICAgdmlzaWJsZVNhbWVTdGFja1NldC5hZGQoZW50cnkuZ3JvdXBpbmcuc3RhY2tJbmRleCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHZpc2libGVHcm91cHMgPSBBcnJheS5mcm9tKHZpc2libGVHcm91cHNTZXQpO1xuICAgIHZpc2libGVHcm91cHMuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgIHJldHVybiB7XG4gICAgICB2aXNpYmxlR3JvdXBDb3VudDogdmlzaWJsZUdyb3Vwcy5sZW5ndGgsXG4gICAgICB2aXNpYmxlU2FtZVN0YWNrQ291bnQ6IHZpc2libGVTYW1lU3RhY2tTZXQuc2l6ZSxcbiAgICAgIGluZGV4OiB2aXNpYmxlR3JvdXBzLmluZGV4T2Yoc2VyaWVzR3JvdXBpbmcuZ3JvdXBJbmRleClcbiAgICB9O1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9jaGFydFVwZGF0ZVR5cGUudHNcbnZhciBDaGFydFVwZGF0ZVR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChDaGFydFVwZGF0ZVR5cGUyKSA9PiB7XG4gIENoYXJ0VXBkYXRlVHlwZTJbQ2hhcnRVcGRhdGVUeXBlMltcIkZVTExcIl0gPSAwXSA9IFwiRlVMTFwiO1xuICBDaGFydFVwZGF0ZVR5cGUyW0NoYXJ0VXBkYXRlVHlwZTJbXCJVUERBVEVfREFUQVwiXSA9IDFdID0gXCJVUERBVEVfREFUQVwiO1xuICBDaGFydFVwZGF0ZVR5cGUyW0NoYXJ0VXBkYXRlVHlwZTJbXCJQUk9DRVNTX0RBVEFcIl0gPSAyXSA9IFwiUFJPQ0VTU19EQVRBXCI7XG4gIENoYXJ0VXBkYXRlVHlwZTJbQ2hhcnRVcGRhdGVUeXBlMltcIlBFUkZPUk1fTEFZT1VUXCJdID0gM10gPSBcIlBFUkZPUk1fTEFZT1VUXCI7XG4gIENoYXJ0VXBkYXRlVHlwZTJbQ2hhcnRVcGRhdGVUeXBlMltcIlNFUklFU19VUERBVEVcIl0gPSA0XSA9IFwiU0VSSUVTX1VQREFURVwiO1xuICBDaGFydFVwZGF0ZVR5cGUyW0NoYXJ0VXBkYXRlVHlwZTJbXCJQUkVfU0NFTkVfUkVOREVSXCJdID0gNV0gPSBcIlBSRV9TQ0VORV9SRU5ERVJcIjtcbiAgQ2hhcnRVcGRhdGVUeXBlMltDaGFydFVwZGF0ZVR5cGUyW1wiU0NFTkVfUkVOREVSXCJdID0gNl0gPSBcIlNDRU5FX1JFTkRFUlwiO1xuICBDaGFydFVwZGF0ZVR5cGUyW0NoYXJ0VXBkYXRlVHlwZTJbXCJOT05FXCJdID0gN10gPSBcIk5PTkVcIjtcbiAgcmV0dXJuIENoYXJ0VXBkYXRlVHlwZTI7XG59KShDaGFydFVwZGF0ZVR5cGUgfHwge30pO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC91cGRhdGVTZXJ2aWNlLnRzXG52YXIgVXBkYXRlU2VydmljZSA9IGNsYXNzIGV4dGVuZHMgTGlzdGVuZXJzIHtcbiAgY29uc3RydWN0b3IodXBkYXRlQ2FsbGJhY2spIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMudXBkYXRlQ2FsbGJhY2sgPSB1cGRhdGVDYWxsYmFjaztcbiAgfVxuICB1cGRhdGUodHlwZSA9IDAgLyogRlVMTCAqLywgb3B0aW9ucykge1xuICAgIHRoaXMudXBkYXRlQ2FsbGJhY2sodHlwZSwgb3B0aW9ucyk7XG4gIH1cbiAgZGlzcGF0Y2hVcGRhdGVDb21wbGV0ZShyZWN0cykge1xuICAgIHRoaXMuZGlzcGF0Y2goXCJ1cGRhdGUtY29tcGxldGVcIiwge1xuICAgICAgdHlwZTogXCJ1cGRhdGUtY29tcGxldGVcIixcbiAgICAgIG1pblJlY3Q6IHJlY3RzPy5taW5SZWN0LFxuICAgICAgbWluVmlzaWJsZVJlY3Q6IHJlY3RzPy5taW5WaXNpYmxlUmVjdFxuICAgIH0pO1xuICB9XG4gIGRpc3BhdGNoUHJlRG9tVXBkYXRlKCkge1xuICAgIHRoaXMuZGlzcGF0Y2goXCJwcmUtZG9tLXVwZGF0ZVwiLCB7IHR5cGU6IFwicHJlLWRvbS11cGRhdGVcIiB9KTtcbiAgfVxuICBkaXNwYXRjaFByZVNjZW5lUmVuZGVyKHJlY3RzKSB7XG4gICAgdGhpcy5kaXNwYXRjaChcInByZS1zY2VuZS1yZW5kZXJcIiwgeyB0eXBlOiBcInByZS1zY2VuZS1yZW5kZXJcIiwgLi4ucmVjdHMgfSk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2NoYXJ0Q29udGV4dC50c1xudmFyIENoYXJ0Q29udGV4dCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2hhcnQsIHZhcnMpIHtcbiAgICB0aGlzLmNhbGxiYWNrQ2FjaGUgPSBuZXcgQ2FsbGJhY2tDYWNoZSgpO1xuICAgIHRoaXMuY2hhcnRFdmVudE1hbmFnZXIgPSBuZXcgQ2hhcnRFdmVudE1hbmFnZXIoKTtcbiAgICB0aGlzLmhpZ2hsaWdodE1hbmFnZXIgPSBuZXcgSGlnaGxpZ2h0TWFuYWdlcigpO1xuICAgIHRoaXMubGF5b3V0TWFuYWdlciA9IG5ldyBMYXlvdXRNYW5hZ2VyKCk7XG4gICAgdGhpcy5sb2NhbGVNYW5hZ2VyID0gbmV3IExvY2FsZU1hbmFnZXIoKTtcbiAgICB0aGlzLnNlcmllc1N0YXRlTWFuYWdlciA9IG5ldyBTZXJpZXNTdGF0ZU1hbmFnZXIoKTtcbiAgICB0aGlzLnN0YXRlTWFuYWdlciA9IG5ldyBTdGF0ZU1hbmFnZXIoKTtcbiAgICB0aGlzLnRvb2xiYXJNYW5hZ2VyID0gbmV3IFRvb2xiYXJNYW5hZ2VyKCk7XG4gICAgdGhpcy56b29tTWFuYWdlciA9IG5ldyBab29tTWFuYWdlcigpO1xuICAgIGNvbnN0IHsgc2NlbmUsIHJvb3QsIHN5bmNNYW5hZ2VyLCBjb250YWluZXIsIHVwZGF0ZUNhbGxiYWNrLCB1cGRhdGVNdXRleCwgcGl4ZWxSYXRpbywgc3R5bGVDb250YWluZXIgfSA9IHZhcnM7XG4gICAgdGhpcy5jaGFydFNlcnZpY2UgPSBjaGFydDtcbiAgICB0aGlzLnN5bmNNYW5hZ2VyID0gc3luY01hbmFnZXI7XG4gICAgdGhpcy5kb21NYW5hZ2VyID0gbmV3IERPTU1hbmFnZXIoY29udGFpbmVyLCBzdHlsZUNvbnRhaW5lcik7XG4gICAgY29uc3QgY2FudmFzRWxlbWVudCA9IHRoaXMuZG9tTWFuYWdlci5hZGRDaGlsZChcbiAgICAgIFwiY2FudmFzXCIsXG4gICAgICBcInNjZW5lLWNhbnZhc1wiLFxuICAgICAgc2NlbmU/LmNhbnZhcy5lbGVtZW50XG4gICAgKTtcbiAgICB0aGlzLnNjZW5lID0gc2NlbmUgPz8gbmV3IFNjZW5lKHsgcGl4ZWxSYXRpbywgY2FudmFzRWxlbWVudCB9KTtcbiAgICB0aGlzLnNjZW5lLnNldFJvb3Qocm9vdCk7XG4gICAgdGhpcy5heGlzTWFuYWdlciA9IG5ldyBBeGlzTWFuYWdlcihyb290KTtcbiAgICB0aGlzLmFubm90YXRpb25NYW5hZ2VyID0gbmV3IEFubm90YXRpb25NYW5hZ2VyKGNoYXJ0LmFubm90YXRpb25Sb290KTtcbiAgICB0aGlzLmN1cnNvck1hbmFnZXIgPSBuZXcgQ3Vyc29yTWFuYWdlcih0aGlzLmRvbU1hbmFnZXIpO1xuICAgIHRoaXMuaW50ZXJhY3Rpb25NYW5hZ2VyID0gbmV3IEludGVyYWN0aW9uTWFuYWdlcihjaGFydC5rZXlib2FyZCwgdGhpcy5kb21NYW5hZ2VyKTtcbiAgICB0aGlzLmZvY3VzSW5kaWNhdG9yID0gbmV3IEZvY3VzSW5kaWNhdG9yKHRoaXMuZG9tTWFuYWdlcik7XG4gICAgdGhpcy5rZXlOYXZNYW5hZ2VyID0gbmV3IEtleU5hdk1hbmFnZXIodGhpcy5mb2N1c0luZGljYXRvciwgdGhpcy5pbnRlcmFjdGlvbk1hbmFnZXIsIGNoYXJ0Lm1vZGUpO1xuICAgIHRoaXMucmVnaW9uTWFuYWdlciA9IG5ldyBSZWdpb25NYW5hZ2VyKHRoaXMuaW50ZXJhY3Rpb25NYW5hZ2VyKTtcbiAgICB0aGlzLmNvbnRleHRNZW51UmVnaXN0cnkgPSBuZXcgQ29udGV4dE1lbnVSZWdpc3RyeSh0aGlzLnJlZ2lvbk1hbmFnZXIpO1xuICAgIHRoaXMuZ2VzdHVyZURldGVjdG9yID0gbmV3IEdlc3R1cmVEZXRlY3Rvcih0aGlzLmRvbU1hbmFnZXIpO1xuICAgIHRoaXMudXBkYXRlU2VydmljZSA9IG5ldyBVcGRhdGVTZXJ2aWNlKHVwZGF0ZUNhbGxiYWNrKTtcbiAgICB0aGlzLnByb3h5SW50ZXJhY3Rpb25TZXJ2aWNlID0gbmV3IFByb3h5SW50ZXJhY3Rpb25TZXJ2aWNlKHRoaXMubG9jYWxlTWFuYWdlciwgdGhpcy5kb21NYW5hZ2VyKTtcbiAgICB0aGlzLmhpc3RvcnlNYW5hZ2VyID0gbmV3IEhpc3RvcnlNYW5hZ2VyKHRoaXMua2V5TmF2TWFuYWdlcik7XG4gICAgdGhpcy5hbmltYXRpb25NYW5hZ2VyID0gbmV3IEFuaW1hdGlvbk1hbmFnZXIodGhpcy5pbnRlcmFjdGlvbk1hbmFnZXIsIHVwZGF0ZU11dGV4KTtcbiAgICB0aGlzLmRhdGFTZXJ2aWNlID0gbmV3IERhdGFTZXJ2aWNlKHRoaXMuYW5pbWF0aW9uTWFuYWdlcik7XG4gICAgdGhpcy50b29sdGlwTWFuYWdlciA9IG5ldyBUb29sdGlwTWFuYWdlcih0aGlzLmRvbU1hbmFnZXIsIGNoYXJ0LnRvb2x0aXApO1xuICAgIHRoaXMuem9vbU1hbmFnZXIuYWRkTGF5b3V0TGlzdGVuZXJzKHRoaXMubGF5b3V0TWFuYWdlcik7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmFuaW1hdGlvbk1hbmFnZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuaGlnaGxpZ2h0TWFuYWdlci5kZXN0cm95KCk7XG4gICAgdGhpcy5heGlzTWFuYWdlci5kZXN0cm95KCk7XG4gICAgdGhpcy5jYWxsYmFja0NhY2hlLmludmFsaWRhdGVDYWNoZSgpO1xuICAgIHRoaXMuY2hhcnRFdmVudE1hbmFnZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuY29udGV4dE1lbnVSZWdpc3RyeS5kZXN0cm95KCk7XG4gICAgdGhpcy5kb21NYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmhpZ2hsaWdodE1hbmFnZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuaW50ZXJhY3Rpb25NYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmtleU5hdk1hbmFnZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuZm9jdXNJbmRpY2F0b3IuZGVzdHJveSgpO1xuICAgIHRoaXMucHJveHlJbnRlcmFjdGlvblNlcnZpY2UuZGVzdHJveSgpO1xuICAgIHRoaXMucmVnaW9uTWFuYWdlci5kZXN0cm95KCk7XG4gICAgdGhpcy5zeW5jTWFuYWdlci5kZXN0cm95KCk7XG4gICAgdGhpcy50b29sdGlwTWFuYWdlci5kZXN0cm95KCk7XG4gICAgdGhpcy56b29tTWFuYWdlci5kZXN0cm95KCk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2NoYXJ0SGlnaGxpZ2h0LnRzXG52YXIgQ2hhcnRIaWdobGlnaHQgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnJhbmdlID0gXCJ0b29sdGlwXCI7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShVTklPTihbXCJ0b29sdGlwXCIsIFwibm9kZVwiXSwgXCJhIHJhbmdlXCIpKVxuXSwgQ2hhcnRIaWdobGlnaHQucHJvdG90eXBlLCBcInJhbmdlXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9kYXRhL2RhdGFEb21haW4udHNcbnZhciBEaXNjcmV0ZURvbWFpbiA9IGNsYXNzIF9EaXNjcmV0ZURvbWFpbiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZG9tYWluID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgfVxuICBzdGF0aWMgaXModmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBfRGlzY3JldGVEb21haW47XG4gIH1cbiAgZXh0ZW5kKHZhbCkge1xuICAgIHRoaXMuZG9tYWluLmFkZCh2YWwpO1xuICB9XG4gIGdldERvbWFpbigpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmRvbWFpbik7XG4gIH1cbn07XG52YXIgQ29udGludW91c0RvbWFpbiA9IGNsYXNzIF9Db250aW51b3VzRG9tYWluIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5kb21haW4gPSBbSW5maW5pdHksIC1JbmZpbml0eV07XG4gIH1cbiAgc3RhdGljIGlzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgX0NvbnRpbnVvdXNEb21haW47XG4gIH1cbiAgc3RhdGljIGV4dGVuZERvbWFpbih2YWx1ZXMsIGRvbWFpbiA9IFtJbmZpbml0eSwgLUluZmluaXR5XSkge1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGRvbWFpblswXSA+IHZhbHVlKSB7XG4gICAgICAgIGRvbWFpblswXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGRvbWFpblsxXSA8IHZhbHVlKSB7XG4gICAgICAgIGRvbWFpblsxXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZG9tYWluO1xuICB9XG4gIGV4dGVuZCh2YWx1ZSkge1xuICAgIGlmICh0aGlzLmRvbWFpblswXSA+IHZhbHVlKSB7XG4gICAgICB0aGlzLmRvbWFpblswXSA9IHZhbHVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5kb21haW5bMV0gPCB2YWx1ZSkge1xuICAgICAgdGhpcy5kb21haW5bMV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgZ2V0RG9tYWluKCkge1xuICAgIHJldHVybiBbLi4udGhpcy5kb21haW5dO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9kYXRhL2RhdGFNb2RlbC50c1xuZnVuY3Rpb24gdG9LZXlTdHJpbmcoa2V5cykge1xuICByZXR1cm4ga2V5cy5tYXAoKGtleSkgPT4gaXNPYmplY3Qoa2V5KSA/IEpTT04uc3RyaW5naWZ5KGtleSkgOiBrZXkpLmpvaW4oXCItXCIpO1xufVxuZnVuY3Rpb24gcm91bmQyKHZhbCkge1xuICBjb25zdCBhY2N1cmFjeSA9IDFlNDtcbiAgaWYgKE51bWJlci5pc0ludGVnZXIodmFsKSkge1xuICAgIHJldHVybiB2YWw7XG4gIH0gZWxzZSBpZiAoTWF0aC5hYnModmFsKSA+IGFjY3VyYWN5KSB7XG4gICAgcmV0dXJuIE1hdGgudHJ1bmModmFsKTtcbiAgfVxuICByZXR1cm4gTWF0aC5yb3VuZCh2YWwgKiBhY2N1cmFjeSkgLyBhY2N1cmFjeTtcbn1cbmZ1bmN0aW9uIGZpeE51bWVyaWNFeHRlbnQoZXh0ZW50Mikge1xuICBpZiAoZXh0ZW50MiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGNvbnN0IFttaW4sIG1heF0gPSBleHRlbnQyLm1hcChOdW1iZXIpO1xuICBpZiAobWluID09PSAwICYmIG1heCA9PT0gMCkge1xuICAgIHJldHVybiBbMCwgMV07XG4gIH1cbiAgcmV0dXJuIGlzRmluaXRlTnVtYmVyKG1pbikgJiYgaXNGaW5pdGVOdW1iZXIobWF4KSA/IFttaW4sIG1heF0gOiBbXTtcbn1cbmZ1bmN0aW9uIGdldE1pc3NDb3VudChzY29wZVByb3ZpZGVyLCBtaXNzTWFwKSB7XG4gIHJldHVybiBtaXNzTWFwPy5nZXQoc2NvcGVQcm92aWRlci5pZCkgPz8gMDtcbn1cbnZhciBJTlZBTElEX1ZBTFVFID0gU3ltYm9sKFwiaW52YWxpZFwiKTtcbmZ1bmN0aW9uIGdldFBhdGhDb21wb25lbnRzKHBhdGgpIHtcbiAgY29uc3QgY29tcG9uZW50cyA9IFtdO1xuICBsZXQgbWF0Y2hJbmRleCA9IDA7XG4gIGxldCBtYXRjaEdyb3VwO1xuICBjb25zdCByZWdFeHAgPSAvKCg/Oig/Ol58XFwuKVxccypcXHcrfFxcW1xccyooPzonKD86W14nXXxcXFxcJykqJ3xcIig/OlteXCJdfFxcXFxcIikqXCJ8LT9cXGQrKVxccypcXF0pXFxzKikvZztcbiAgd2hpbGUgKG1hdGNoR3JvdXAgPSByZWdFeHAuZXhlYyhwYXRoKSkge1xuICAgIGlmIChtYXRjaEdyb3VwLmluZGV4ICE9PSBtYXRjaEluZGV4KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG1hdGNoSW5kZXggPSBtYXRjaEdyb3VwLmluZGV4ICsgbWF0Y2hHcm91cFswXS5sZW5ndGg7XG4gICAgY29uc3QgbWF0Y2ggPSBtYXRjaEdyb3VwWzFdLnRyaW0oKTtcbiAgICBpZiAobWF0Y2guc3RhcnRzV2l0aChcIi5cIikpIHtcbiAgICAgIGNvbXBvbmVudHMucHVzaChtYXRjaC5zbGljZSgxKS50cmltKCkpO1xuICAgIH0gZWxzZSBpZiAobWF0Y2guc3RhcnRzV2l0aChcIltcIikpIHtcbiAgICAgIGNvbnN0IGFjY2Vzc29yID0gbWF0Y2guc2xpY2UoMSwgLTEpLnRyaW0oKTtcbiAgICAgIGlmIChhY2Nlc3Nvci5zdGFydHNXaXRoKGAnYCkpIHtcbiAgICAgICAgY29tcG9uZW50cy5wdXNoKGFjY2Vzc29yLnNsaWNlKDEsIC0xKS5yZXBsYWNlKC9cXFxcJy9nLCBgJ2ApKTtcbiAgICAgIH0gZWxzZSBpZiAoYWNjZXNzb3Iuc3RhcnRzV2l0aChgXCJgKSkge1xuICAgICAgICBjb21wb25lbnRzLnB1c2goYWNjZXNzb3Iuc2xpY2UoMSwgLTEpLnJlcGxhY2UoL1xcXFxcIi9nLCBgXCJgKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21wb25lbnRzLnB1c2goYWNjZXNzb3IpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb21wb25lbnRzLnB1c2gobWF0Y2gpO1xuICAgIH1cbiAgfVxuICBpZiAobWF0Y2hJbmRleCAhPT0gcGF0aC5sZW5ndGgpXG4gICAgcmV0dXJuO1xuICByZXR1cm4gY29tcG9uZW50cztcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhdGhBY2Nlc3Nvcihjb21wb25lbnRzKSB7XG4gIHJldHVybiAoZGF0dW0pID0+IHtcbiAgICBsZXQgY3VycmVudCA9IGRhdHVtO1xuICAgIGZvciAoY29uc3QgY29tcG9uZW50IG9mIGNvbXBvbmVudHMpIHtcbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50W2NvbXBvbmVudF07XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50O1xuICB9O1xufVxudmFyIERhdGFNb2RlbCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0cywgbW9kZSA9IFwic3RhbmRhbG9uZVwiKSB7XG4gICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgIHRoaXMuZGVidWcgPSBEZWJ1Zy5jcmVhdGUodHJ1ZSwgXCJkYXRhLW1vZGVsXCIpO1xuICAgIHRoaXMuc2NvcGVDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5rZXlzID0gW107XG4gICAgdGhpcy52YWx1ZXMgPSBbXTtcbiAgICB0aGlzLmFnZ3JlZ2F0ZXMgPSBbXTtcbiAgICB0aGlzLmdyb3VwUHJvY2Vzc29ycyA9IFtdO1xuICAgIHRoaXMucHJvcGVydHlQcm9jZXNzb3JzID0gW107XG4gICAgdGhpcy5yZWR1Y2VycyA9IFtdO1xuICAgIHRoaXMucHJvY2Vzc29ycyA9IFtdO1xuICAgIGxldCBrZXlzID0gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IG5leHQgb2Ygb3B0cy5wcm9wcykge1xuICAgICAgaWYgKG5leHQudHlwZSA9PT0gXCJrZXlcIiAmJiAha2V5cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBRyBDaGFydHMgLSBpbnRlcm5hbCBjb25maWcgZXJyb3I6IGtleXMgbXVzdCBjb21lIGJlZm9yZSB2YWx1ZXMuXCIpO1xuICAgICAgfVxuICAgICAgaWYgKG5leHQudHlwZSA9PT0gXCJ2YWx1ZVwiICYmIGtleXMpIHtcbiAgICAgICAga2V5cyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB2ZXJpZnlNYXRjaEdyb3VwSWQgPSAoeyBtYXRjaEdyb3VwSWRzID0gW10gfSkgPT4ge1xuICAgICAgZm9yIChjb25zdCBtYXRjaEdyb3VwSWQgb2YgbWF0Y2hHcm91cElkcykge1xuICAgICAgICBpZiAodGhpcy52YWx1ZXMuZXZlcnkoKGRlZikgPT4gZGVmLmdyb3VwSWQgIT09IG1hdGNoR3JvdXBJZCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgQUcgQ2hhcnRzIC0gaW50ZXJuYWwgY29uZmlnIGVycm9yOiBtYXRjaEdyb3VwSWRzIHByb3BlcnRpZXMgbXVzdCBtYXRjaCBkZWZpbmVkIGdyb3VwcyAoJHttYXRjaEdyb3VwSWR9KS5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgZm9yIChjb25zdCBkZWYgb2Ygb3B0cy5wcm9wcykge1xuICAgICAgc3dpdGNoIChkZWYudHlwZSkge1xuICAgICAgICBjYXNlIFwia2V5XCI6XG4gICAgICAgICAgdGhpcy5rZXlzLnB1c2goeyAuLi5kZWYsIGluZGV4OiB0aGlzLmtleXMubGVuZ3RoLCBtaXNzaW5nOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwidmFsdWVcIjpcbiAgICAgICAgICBpZiAoZGVmLnByb3BlcnR5ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgYEFHIENoYXJ0cyAtIGludGVybmFsIGNvbmZpZyBlcnJvcjogbm8gcHJvcGVydGllcyBzcGVjaWZpZWQgZm9yIHZhbHVlIGRlZmluaXRpb25zOiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgIGRlZlxuICAgICAgICAgICAgICApfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMudmFsdWVzLnB1c2goeyAuLi5kZWYsIGluZGV4OiB0aGlzLnZhbHVlcy5sZW5ndGgsIG1pc3Npbmc6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJhZ2dyZWdhdGVcIjpcbiAgICAgICAgICB2ZXJpZnlNYXRjaEdyb3VwSWQoZGVmKTtcbiAgICAgICAgICB0aGlzLmFnZ3JlZ2F0ZXMucHVzaCh7IC4uLmRlZiwgaW5kZXg6IHRoaXMuYWdncmVnYXRlcy5sZW5ndGggfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJncm91cC12YWx1ZS1wcm9jZXNzb3JcIjpcbiAgICAgICAgICB2ZXJpZnlNYXRjaEdyb3VwSWQoZGVmKTtcbiAgICAgICAgICB0aGlzLmdyb3VwUHJvY2Vzc29ycy5wdXNoKHsgLi4uZGVmLCBpbmRleDogdGhpcy5ncm91cFByb2Nlc3NvcnMubGVuZ3RoIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicHJvcGVydHktdmFsdWUtcHJvY2Vzc29yXCI6XG4gICAgICAgICAgdGhpcy5wcm9wZXJ0eVByb2Nlc3NvcnMucHVzaCh7IC4uLmRlZiwgaW5kZXg6IHRoaXMucHJvcGVydHlQcm9jZXNzb3JzLmxlbmd0aCB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInJlZHVjZXJcIjpcbiAgICAgICAgICB0aGlzLnJlZHVjZXJzLnB1c2goeyAuLi5kZWYsIGluZGV4OiB0aGlzLnJlZHVjZXJzLmxlbmd0aCB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInByb2Nlc3NvclwiOlxuICAgICAgICAgIHRoaXMucHJvY2Vzc29ycy5wdXNoKHsgLi4uZGVmLCBpbmRleDogdGhpcy5wcm9jZXNzb3JzLmxlbmd0aCB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmVzb2x2ZVByb2Nlc3NlZERhdGFEZWZCeUlkKHNjb3BlLCBzZWFyY2hJZCkge1xuICAgIGNvbnN0IGRlZiA9IHRoaXMuc2NvcGVDYWNoZS5nZXQoc2NvcGUuaWQpPy5nZXQoc2VhcmNoSWQpO1xuICAgIGlmICghZGVmKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFHIENoYXJ0cyAtIGRpZG4ndCBmaW5kIHByb3BlcnR5IGRlZmluaXRpb24gZm9yIFske3NlYXJjaElkfSwgJHtzY29wZS5pZH1dYCk7XG4gICAgfVxuICAgIHJldHVybiB7IGluZGV4OiBkZWYuaW5kZXgsIGRlZiB9O1xuICB9XG4gIHJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHNjb3BlLCBzZWFyY2hJZCkge1xuICAgIHJldHVybiB0aGlzLnJlc29sdmVQcm9jZXNzZWREYXRhRGVmQnlJZChzY29wZSwgc2VhcmNoSWQpLmluZGV4O1xuICB9XG4gIHJlc29sdmVQcm9jZXNzZWREYXRhRGVmc0J5SWRzKHNjb3BlLCBzZWFyY2hJZHMpIHtcbiAgICByZXR1cm4gc2VhcmNoSWRzLm1hcCgoc2VhcmNoSWQpID0+IFtzZWFyY2hJZCwgdGhpcy5yZXNvbHZlUHJvY2Vzc2VkRGF0YURlZkJ5SWQoc2NvcGUsIHNlYXJjaElkKV0pO1xuICB9XG4gIHJlc29sdmVQcm9jZXNzZWREYXRhRGVmc1ZhbHVlcyhkZWZzLCB7IGtleXMsIHZhbHVlcyB9KSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBbc2VhcmNoSWQsIHsgaW5kZXgsIGRlZiB9XSBvZiBkZWZzKSB7XG4gICAgICBjb25zdCBwcm9jZXNzZWREYXRhID0gZGVmLnR5cGUgPT09IFwia2V5XCIgPyBrZXlzIDogdmFsdWVzO1xuICAgICAgcmVzdWx0W3NlYXJjaElkXSA9IHByb2Nlc3NlZERhdGFbaW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGdldERvbWFpbihzY29wZSwgc2VhcmNoSWQsIHR5cGUgPSBcInZhbHVlXCIsIHByb2Nlc3NlZERhdGEpIHtcbiAgICBjb25zdCBkb21haW5zID0gdGhpcy5nZXREb21haW5zQnlUeXBlKHR5cGUsIHByb2Nlc3NlZERhdGEpO1xuICAgIHJldHVybiBkb21haW5zPy5bdGhpcy5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZChzY29wZSwgc2VhcmNoSWQpXSA/PyBbXTtcbiAgfVxuICBnZXREb21haW5zQnlUeXBlKHR5cGUsIHByb2Nlc3NlZERhdGEpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgXCJrZXlcIjpcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NlZERhdGEuZG9tYWluLmtleXM7XG4gICAgICBjYXNlIFwidmFsdWVcIjpcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NlZERhdGEuZG9tYWluLnZhbHVlcztcbiAgICAgIGNhc2UgXCJhZ2dyZWdhdGVcIjpcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NlZERhdGEuZG9tYWluLmFnZ1ZhbHVlcztcbiAgICAgIGNhc2UgXCJncm91cC12YWx1ZS1wcm9jZXNzb3JcIjpcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NlZERhdGEuZG9tYWluLmdyb3VwcztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBwcm9jZXNzRGF0YShkYXRhLCBzb3VyY2VzKSB7XG4gICAgY29uc3Qge1xuICAgICAgb3B0czogeyBncm91cEJ5S2V5cywgZ3JvdXBCeUZuIH0sXG4gICAgICBhZ2dyZWdhdGVzLFxuICAgICAgZ3JvdXBQcm9jZXNzb3JzLFxuICAgICAgcmVkdWNlcnMsXG4gICAgICBwcm9jZXNzb3JzLFxuICAgICAgcHJvcGVydHlQcm9jZXNzb3JzXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgc3RhcnQyID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgaWYgKGdyb3VwQnlLZXlzICYmIHRoaXMua2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHByb2Nlc3NlZERhdGEgPSB0aGlzLmV4dHJhY3REYXRhKGRhdGEsIHNvdXJjZXMpO1xuICAgIGlmIChncm91cEJ5S2V5cykge1xuICAgICAgcHJvY2Vzc2VkRGF0YSA9IHRoaXMuZ3JvdXBEYXRhKHByb2Nlc3NlZERhdGEpO1xuICAgIH0gZWxzZSBpZiAoZ3JvdXBCeUZuKSB7XG4gICAgICBwcm9jZXNzZWREYXRhID0gdGhpcy5ncm91cERhdGEocHJvY2Vzc2VkRGF0YSwgZ3JvdXBCeUZuKHByb2Nlc3NlZERhdGEpKTtcbiAgICB9XG4gICAgaWYgKGdyb3VwUHJvY2Vzc29ycy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLnBvc3RQcm9jZXNzR3JvdXBzKHByb2Nlc3NlZERhdGEpO1xuICAgIH1cbiAgICBpZiAoYWdncmVnYXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmFnZ3JlZ2F0ZURhdGEocHJvY2Vzc2VkRGF0YSk7XG4gICAgfVxuICAgIGlmIChwcm9wZXJ0eVByb2Nlc3NvcnMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5wb3N0UHJvY2Vzc1Byb3BlcnRpZXMocHJvY2Vzc2VkRGF0YSk7XG4gICAgfVxuICAgIGlmIChyZWR1Y2Vycy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLnJlZHVjZURhdGEocHJvY2Vzc2VkRGF0YSk7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMucG9zdFByb2Nlc3NEYXRhKHByb2Nlc3NlZERhdGEpO1xuICAgIH1cbiAgICBpZiAoZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKGNvbnN0IGRlZiBvZiBpdGVyYXRlKHRoaXMua2V5cywgdGhpcy52YWx1ZXMpKSB7XG4gICAgICAgIGZvciAoY29uc3QgW3Njb3BlLCBtaXNzQ291bnRdIG9mIGRlZi5taXNzaW5nKSB7XG4gICAgICAgICAgaWYgKG1pc3NDb3VudCA+PSBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3Qgc2NvcGVIaW50ID0gc2NvcGUgPT0gbnVsbCA/IFwiXCIgOiBgIGZvciAke3Njb3BlfWA7XG4gICAgICAgICAgICBMb2dnZXIud2Fybk9uY2UoYHRoZSBrZXkgJyR7ZGVmLnByb3BlcnR5fScgd2FzIG5vdCBmb3VuZCBpbiBhbnkgZGF0YSBlbGVtZW50JHtzY29wZUhpbnR9LmApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBlbmQyID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgcHJvY2Vzc2VkRGF0YS50aW1lID0gZW5kMiAtIHN0YXJ0MjtcbiAgICBpZiAodGhpcy5kZWJ1Zy5jaGVjaygpKSB7XG4gICAgICBsb2dQcm9jZXNzZWREYXRhKHByb2Nlc3NlZERhdGEpO1xuICAgIH1cbiAgICB0aGlzLnNjb3BlQ2FjaGUuY2xlYXIoKTtcbiAgICBmb3IgKGNvbnN0IGRlZiBvZiBpdGVyYXRlKHRoaXMua2V5cywgdGhpcy52YWx1ZXMsIHRoaXMuYWdncmVnYXRlcykpIHtcbiAgICAgIGlmICghZGVmLmlkc01hcClcbiAgICAgICAgY29udGludWU7XG4gICAgICBmb3IgKGNvbnN0IFtzY29wZSwgaWRzXSBvZiBkZWYuaWRzTWFwKSB7XG4gICAgICAgIGZvciAoY29uc3QgaWQgb2YgaWRzKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLnNjb3BlQ2FjaGUuaGFzKHNjb3BlKSkge1xuICAgICAgICAgICAgdGhpcy5zY29wZUNhY2hlLnNldChzY29wZSwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1tpZCwgZGVmXV0pKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2NvcGVDYWNoZS5nZXQoc2NvcGUpPy5oYXMoaWQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkdXBsaWNhdGUgZGVmaW5pdGlvbiBpZHMgb24gdGhlIHNhbWUgc2NvcGUgYXJlIG5vdCBhbGxvd2VkLlwiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zY29wZUNhY2hlLmdldChzY29wZSkuc2V0KGlkLCBkZWYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvY2Vzc2VkRGF0YTtcbiAgfVxuICB2YWx1ZUdyb3VwSWR4TG9va3VwKHsgbWF0Y2hHcm91cElkcyB9KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIChjb25zdCBbaW5kZXgsIGRlZl0gb2YgdGhpcy52YWx1ZXMuZW50cmllcygpKSB7XG4gICAgICBpZiAoIW1hdGNoR3JvdXBJZHMgfHwgZGVmLmdyb3VwSWQgJiYgbWF0Y2hHcm91cElkcy5pbmNsdWRlcyhkZWYuZ3JvdXBJZCkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goaW5kZXgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHZhbHVlSWR4TG9va3VwKHNjb3BlcywgcHJvcCkge1xuICAgIGNvbnN0IG5vU2NvcGVzVG9NYXRjaCA9IHNjb3BlcyA9PSBudWxsIHx8IHNjb3Blcy5sZW5ndGggPT09IDA7XG4gICAgY29uc3QgcHJvcElkID0gdHlwZW9mIHByb3AgPT09IFwic3RyaW5nXCIgPyBwcm9wIDogcHJvcC5pZDtcbiAgICBjb25zdCBoYXNNYXRjaGluZ1Njb3BlSWQgPSAoZGVmKSA9PiB7XG4gICAgICBpZiAoZGVmLmlkc01hcCkge1xuICAgICAgICBmb3IgKGNvbnN0IFtzY29wZSwgaWRzXSBvZiBkZWYuaWRzTWFwKSB7XG4gICAgICAgICAgaWYgKHNjb3Blcz8uaW5jbHVkZXMoc2NvcGUpICYmIGlkcy5oYXMocHJvcElkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLnZhbHVlcy5maW5kSW5kZXgoKGRlZikgPT4ge1xuICAgICAgY29uc3QgdmFsaWREZWZTY29wZXMgPSBkZWYuc2NvcGVzID09IG51bGwgfHwgbm9TY29wZXNUb01hdGNoICYmICFkZWYuc2NvcGVzLmxlbmd0aCB8fCBkZWYuc2NvcGVzLnNvbWUoKHMpID0+IHNjb3Blcz8uaW5jbHVkZXMocykpO1xuICAgICAgcmV0dXJuIHZhbGlkRGVmU2NvcGVzICYmIChkZWYucHJvcGVydHkgPT09IHByb3BJZCB8fCBkZWYuaWQgPT09IHByb3BJZCB8fCBoYXNNYXRjaGluZ1Njb3BlSWQoZGVmKSk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEFHIENoYXJ0cyAtIGNvbmZpZ3VyYXRpb24gZXJyb3IsIHVua25vd24gcHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShwcm9wKX0gaW4gc2NvcGUocykgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICBzY29wZXNcbiAgICAgICAgKX1gXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGV4dHJhY3REYXRhKGRhdGEsIHNvdXJjZXMpIHtcbiAgICBjb25zdCB7IGRhdGFEb21haW4sIHByb2Nlc3NWYWx1ZSwgc2NvcGVzLCBhbGxTY29wZXNIYXZlU2FtZURlZnMgfSA9IHRoaXMuaW5pdERhdGFEb21haW5Qcm9jZXNzb3IoKTtcbiAgICBjb25zdCBzb3VyY2VzQnlJZCA9IG5ldyBNYXAoc291cmNlcz8ubWFwKChzKSA9PiBbcy5pZCwgc10pKTtcbiAgICBjb25zdCB7IGtleXM6IGtleURlZnMsIHZhbHVlczogdmFsdWVEZWZzIH0gPSB0aGlzO1xuICAgIGNvbnN0IHJlc3VsdERhdGEgPSBuZXcgQXJyYXkoZGF0YS5sZW5ndGgpO1xuICAgIGxldCByZXN1bHREYXRhSWR4ID0gMDtcbiAgICBsZXQgcGFydGlhbFZhbGlkRGF0YUNvdW50ID0gMDtcbiAgICBmb3IgKGNvbnN0IFtkYXR1bUlkeCwgZGF0dW1dIG9mIGRhdGEuZW50cmllcygpKSB7XG4gICAgICBjb25zdCBzb3VyY2VEYXR1bXMgPSB7fTtcbiAgICAgIGNvbnN0IHZhbGlkU2NvcGVzID0gc2NvcGVzLnNpemUgPiAwID8gbmV3IFNldChzY29wZXMpIDogdm9pZCAwO1xuICAgICAgY29uc3Qga2V5cyA9IG5ldyBBcnJheShrZXlEZWZzLmxlbmd0aCk7XG4gICAgICBsZXQga2V5SWR4ID0gMDtcbiAgICAgIGxldCBrZXk7XG4gICAgICBmb3IgKGNvbnN0IGRlZiBvZiBrZXlEZWZzKSB7XG4gICAgICAgIGtleSA9IHByb2Nlc3NWYWx1ZShkZWYsIGRhdHVtLCBrZXkpO1xuICAgICAgICBpZiAoa2V5ID09PSBJTlZBTElEX1ZBTFVFKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAoa2V5cykge1xuICAgICAgICAgIGtleXNba2V5SWR4KytdID0ga2V5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoa2V5ID09PSBJTlZBTElEX1ZBTFVFKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IHZhbHVlcyA9IHZhbHVlRGVmcy5sZW5ndGggPiAwID8gbmV3IEFycmF5KHZhbHVlRGVmcy5sZW5ndGgpIDogdm9pZCAwO1xuICAgICAgbGV0IHZhbHVlO1xuICAgICAgZm9yIChjb25zdCBbdmFsdWVEZWZJZHgsIGRlZl0gb2YgdmFsdWVEZWZzLmVudHJpZXMoKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHNjb3BlIG9mIGRlZi5zY29wZXMgPz8gc2NvcGVzKSB7XG4gICAgICAgICAgY29uc3Qgc291cmNlID0gc291cmNlc0J5SWQuZ2V0KHNjb3BlKTtcbiAgICAgICAgICBjb25zdCB2YWx1ZURhdHVtID0gc291cmNlPy5kYXRhW2RhdHVtSWR4XSA/PyBkYXR1bTtcbiAgICAgICAgICB2YWx1ZSA9IHByb2Nlc3NWYWx1ZShkZWYsIHZhbHVlRGF0dW0sIHZhbHVlLCBzY29wZSk7XG4gICAgICAgICAgaWYgKHZhbHVlID09PSBJTlZBTElEX1ZBTFVFIHx8ICF2YWx1ZXMpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBpZiAoc291cmNlICE9IG51bGwgJiYgZGVmLmluY2x1ZGVQcm9wZXJ0eSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5ID0gZGVmLmluY2x1ZGVQcm9wZXJ0eSAmJiBkZWYuaWQgIT0gbnVsbCA/IGRlZi5pZCA6IGRlZi5wcm9wZXJ0eTtcbiAgICAgICAgICAgIHNvdXJjZURhdHVtc1tzY29wZV0gPz8gKHNvdXJjZURhdHVtc1tzY29wZV0gPSB7fSk7XG4gICAgICAgICAgICBzb3VyY2VEYXR1bXNbc2NvcGVdW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YWx1ZXNbdmFsdWVEZWZJZHhdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID09PSBJTlZBTElEX1ZBTFVFKSB7XG4gICAgICAgICAgaWYgKGFsbFNjb3Blc0hhdmVTYW1lRGVmcylcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGZvciAoY29uc3Qgc2NvcGUgb2YgZGVmLnNjb3BlcyA/PyBzY29wZXMpIHtcbiAgICAgICAgICAgIHZhbGlkU2NvcGVzPy5kZWxldGUoc2NvcGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsaWRTY29wZXM/LnNpemUgPT09IDApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID09PSBJTlZBTElEX1ZBTFVFICYmIGFsbFNjb3Blc0hhdmVTYW1lRGVmcylcbiAgICAgICAgY29udGludWU7XG4gICAgICBpZiAodmFsaWRTY29wZXM/LnNpemUgPT09IDApXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3QgcmVzdWx0ID0geyBkYXR1bTogeyAuLi5kYXR1bSwgLi4uc291cmNlRGF0dW1zIH0sIGtleXMsIHZhbHVlcyB9O1xuICAgICAgaWYgKCFhbGxTY29wZXNIYXZlU2FtZURlZnMgJiYgdmFsaWRTY29wZXMgJiYgdmFsaWRTY29wZXMuc2l6ZSA8IHNjb3Blcy5zaXplKSB7XG4gICAgICAgIHBhcnRpYWxWYWxpZERhdGFDb3VudCsrO1xuICAgICAgICByZXN1bHQudmFsaWRTY29wZXMgPSBuZXcgU2V0KHZhbGlkU2NvcGVzKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdERhdGFbcmVzdWx0RGF0YUlkeCsrXSA9IHJlc3VsdDtcbiAgICB9XG4gICAgcmVzdWx0RGF0YS5sZW5ndGggPSByZXN1bHREYXRhSWR4O1xuICAgIGNvbnN0IHByb3BlcnR5RG9tYWluID0gKGRlZikgPT4ge1xuICAgICAgY29uc3QgZGVmRG9tYWluID0gZGF0YURvbWFpbi5nZXQoZGVmKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGRlZkRvbWFpbi5nZXREb21haW4oKTtcbiAgICAgIGlmIChDb250aW51b3VzRG9tYWluLmlzKGRlZkRvbWFpbikgJiYgcmVzdWx0WzBdID4gcmVzdWx0WzFdKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJ1bmdyb3VwZWRcIixcbiAgICAgIGlucHV0OiB7IGNvdW50OiBkYXRhLmxlbmd0aCB9LFxuICAgICAgZGF0YTogcmVzdWx0RGF0YSxcbiAgICAgIGRvbWFpbjoge1xuICAgICAgICBrZXlzOiBrZXlEZWZzLm1hcChwcm9wZXJ0eURvbWFpbiksXG4gICAgICAgIHZhbHVlczogdmFsdWVEZWZzLm1hcChwcm9wZXJ0eURvbWFpbilcbiAgICAgIH0sXG4gICAgICBkZWZzOiB7XG4gICAgICAgIGFsbFNjb3Blc0hhdmVTYW1lRGVmcyxcbiAgICAgICAga2V5czoga2V5RGVmcyxcbiAgICAgICAgdmFsdWVzOiB2YWx1ZURlZnNcbiAgICAgIH0sXG4gICAgICBwYXJ0aWFsVmFsaWREYXRhQ291bnQsXG4gICAgICB0aW1lOiAwXG4gICAgfTtcbiAgfVxuICBncm91cERhdGEoZGF0YSwgZ3JvdXBpbmdGbikge1xuICAgIGNvbnN0IHByb2Nlc3NlZERhdGEgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgZGF0YUVudHJ5IG9mIGRhdGEuZGF0YSkge1xuICAgICAgY29uc3QgeyBrZXlzLCB2YWx1ZXMsIGRhdHVtLCB2YWxpZFNjb3BlcyB9ID0gZGF0YUVudHJ5O1xuICAgICAgY29uc3QgZ3JvdXAgPSBncm91cGluZ0ZuPy4oZGF0YUVudHJ5KSA/PyBrZXlzO1xuICAgICAgY29uc3QgZ3JvdXBTdHIgPSB0b0tleVN0cmluZyhncm91cCk7XG4gICAgICBpZiAocHJvY2Vzc2VkRGF0YS5oYXMoZ3JvdXBTdHIpKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nRGF0YSA9IHByb2Nlc3NlZERhdGEuZ2V0KGdyb3VwU3RyKTtcbiAgICAgICAgZXhpc3RpbmdEYXRhLnZhbHVlcy5wdXNoKHZhbHVlcyk7XG4gICAgICAgIGV4aXN0aW5nRGF0YS5kYXR1bS5wdXNoKGRhdHVtKTtcbiAgICAgICAgaWYgKHZhbGlkU2NvcGVzICE9IG51bGwgJiYgZXhpc3RpbmdEYXRhLnZhbGlkU2NvcGVzICE9IG51bGwpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHNjb3BlIG9mIGV4aXN0aW5nRGF0YS52YWxpZFNjb3Blcykge1xuICAgICAgICAgICAgaWYgKCF2YWxpZFNjb3Blcy5oYXMoc2NvcGUpKSB7XG4gICAgICAgICAgICAgIGV4aXN0aW5nRGF0YS52YWxpZFNjb3Blcy5kZWxldGUoc2NvcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzc2VkRGF0YS5zZXQoZ3JvdXBTdHIsIHtcbiAgICAgICAgICBrZXlzOiBncm91cCxcbiAgICAgICAgICB2YWx1ZXM6IFt2YWx1ZXNdLFxuICAgICAgICAgIGRhdHVtOiBbZGF0dW1dLFxuICAgICAgICAgIHZhbGlkU2NvcGVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXN1bHREYXRhID0gbmV3IEFycmF5KHByb2Nlc3NlZERhdGEuc2l6ZSk7XG4gICAgY29uc3QgcmVzdWx0R3JvdXBzID0gbmV3IEFycmF5KHByb2Nlc3NlZERhdGEuc2l6ZSk7XG4gICAgbGV0IGRhdGFJbmRleCA9IDA7XG4gICAgZm9yIChjb25zdCB7IGtleXMsIHZhbHVlcywgZGF0dW0sIHZhbGlkU2NvcGVzIH0gb2YgcHJvY2Vzc2VkRGF0YS52YWx1ZXMoKSkge1xuICAgICAgaWYgKHZhbGlkU2NvcGVzPy5zaXplID09PSAwKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHJlc3VsdEdyb3Vwc1tkYXRhSW5kZXhdID0ga2V5cztcbiAgICAgIHJlc3VsdERhdGFbZGF0YUluZGV4KytdID0ge1xuICAgICAgICBrZXlzLFxuICAgICAgICB2YWx1ZXMsXG4gICAgICAgIGRhdHVtLFxuICAgICAgICB2YWxpZFNjb3Blc1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRhdGEsXG4gICAgICB0eXBlOiBcImdyb3VwZWRcIixcbiAgICAgIGRhdGE6IHJlc3VsdERhdGEsXG4gICAgICBkb21haW46IHtcbiAgICAgICAgLi4uZGF0YS5kb21haW4sXG4gICAgICAgIGdyb3VwczogcmVzdWx0R3JvdXBzXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBhZ2dyZWdhdGVEYXRhKHByb2Nlc3NlZERhdGEpIHtcbiAgICBjb25zdCBpc1VuZ3JvdXBlZCA9IHByb2Nlc3NlZERhdGEudHlwZSA9PT0gXCJ1bmdyb3VwZWRcIjtcbiAgICBwcm9jZXNzZWREYXRhLmRvbWFpbi5hZ2dWYWx1ZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtpbmRleCwgZGVmXSBvZiB0aGlzLmFnZ3JlZ2F0ZXMuZW50cmllcygpKSB7XG4gICAgICBjb25zdCBpbmRpY2VzID0gdGhpcy52YWx1ZUdyb3VwSWR4TG9va3VwKGRlZik7XG4gICAgICBjb25zdCBkb21haW4gPSBbSW5maW5pdHksIC1JbmZpbml0eV07XG4gICAgICBmb3IgKGNvbnN0IGRhdHVtIG9mIHByb2Nlc3NlZERhdGEuZGF0YSkge1xuICAgICAgICBkYXR1bS5hZ2dWYWx1ZXMgPz8gKGRhdHVtLmFnZ1ZhbHVlcyA9IG5ldyBBcnJheSh0aGlzLmFnZ3JlZ2F0ZXMubGVuZ3RoKSk7XG4gICAgICAgIGlmIChkYXR1bS52YWxpZFNjb3BlcylcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gaXNVbmdyb3VwZWQgPyBbZGF0dW0udmFsdWVzXSA6IGRhdHVtLnZhbHVlcztcbiAgICAgICAgbGV0IGdyb3VwQWdnVmFsdWVzID0gZGVmLmdyb3VwQWdncmVnYXRlRnVuY3Rpb24/LigpID8/IFtJbmZpbml0eSwgLUluZmluaXR5XTtcbiAgICAgICAgZm9yIChjb25zdCBkaXN0aW5jdFZhbHVlcyBvZiB2YWx1ZXMpIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZXNUb0FnZyA9IGluZGljZXMubWFwKCh2YWx1ZUlkeCkgPT4gZGlzdGluY3RWYWx1ZXNbdmFsdWVJZHhdKTtcbiAgICAgICAgICBjb25zdCB2YWx1ZXNBZ2cgPSBkZWYuYWdncmVnYXRlRnVuY3Rpb24odmFsdWVzVG9BZ2csIGRhdHVtLmtleXMpO1xuICAgICAgICAgIGlmICh2YWx1ZXNBZ2cpIHtcbiAgICAgICAgICAgIGdyb3VwQWdnVmFsdWVzID0gZGVmLmdyb3VwQWdncmVnYXRlRnVuY3Rpb24/Lih2YWx1ZXNBZ2csIGdyb3VwQWdnVmFsdWVzKSA/PyBDb250aW51b3VzRG9tYWluLmV4dGVuZERvbWFpbih2YWx1ZXNBZ2csIGdyb3VwQWdnVmFsdWVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmluYWxWYWx1ZXMgPSAoZGVmLmZpbmFsRnVuY3Rpb24/Lihncm91cEFnZ1ZhbHVlcykgPz8gZ3JvdXBBZ2dWYWx1ZXMpLm1hcCgodikgPT4gcm91bmQyKHYpKTtcbiAgICAgICAgZGF0dW0uYWdnVmFsdWVzW2luZGV4XSA9IGZpbmFsVmFsdWVzO1xuICAgICAgICBDb250aW51b3VzRG9tYWluLmV4dGVuZERvbWFpbihmaW5hbFZhbHVlcywgZG9tYWluKTtcbiAgICAgIH1cbiAgICAgIHByb2Nlc3NlZERhdGEuZG9tYWluLmFnZ1ZhbHVlcy5wdXNoKGRvbWFpbik7XG4gICAgfVxuICB9XG4gIHBvc3RQcm9jZXNzR3JvdXBzKHByb2Nlc3NlZERhdGEpIHtcbiAgICBjb25zdCB7IGdyb3VwUHJvY2Vzc29ycyB9ID0gdGhpcztcbiAgICBjb25zdCBhZmZlY3RlZEluZGljZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGNvbnN0IHVwZGF0ZWREb21haW5zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBjb25zdCBncm91cFByb2Nlc3NvckluZGljZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGdyb3VwUHJvY2Vzc29ySW5pdEZucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBwcm9jZXNzb3Igb2YgZ3JvdXBQcm9jZXNzb3JzKSB7XG4gICAgICBjb25zdCBpbmRpY2VzID0gdGhpcy52YWx1ZUdyb3VwSWR4TG9va3VwKHByb2Nlc3Nvcik7XG4gICAgICBncm91cFByb2Nlc3NvckluZGljZXMuc2V0KHByb2Nlc3NvciwgaW5kaWNlcyk7XG4gICAgICBncm91cFByb2Nlc3NvckluaXRGbnMuc2V0KHByb2Nlc3NvciwgcHJvY2Vzc29yLmFkanVzdCgpKTtcbiAgICAgIGZvciAoY29uc3QgaWR4IG9mIGluZGljZXMpIHtcbiAgICAgICAgY29uc3QgdmFsdWVEZWYgPSB0aGlzLnZhbHVlc1tpZHhdO1xuICAgICAgICBjb25zdCBpc0Rpc2NyZXRlID0gdmFsdWVEZWYudmFsdWVUeXBlID09PSBcImNhdGVnb3J5XCI7XG4gICAgICAgIGFmZmVjdGVkSW5kaWNlcy5hZGQoaWR4KTtcbiAgICAgICAgdXBkYXRlZERvbWFpbnMuc2V0KGlkeCwgaXNEaXNjcmV0ZSA/IG5ldyBEaXNjcmV0ZURvbWFpbigpIDogbmV3IENvbnRpbnVvdXNEb21haW4oKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHVwZGF0ZURvbWFpbnMgPSAodmFsdWVzKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IHZhbHVlSW5kZXggb2YgYWZmZWN0ZWRJbmRpY2VzKSB7XG4gICAgICAgIHVwZGF0ZWREb21haW5zLmdldCh2YWx1ZUluZGV4KT8uZXh0ZW5kKHZhbHVlc1t2YWx1ZUluZGV4XSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIHByb2Nlc3NlZERhdGEuZGF0YSkge1xuICAgICAgZm9yIChjb25zdCBwcm9jZXNzb3Igb2YgZ3JvdXBQcm9jZXNzb3JzKSB7XG4gICAgICAgIGlmIChncm91cC52YWxpZFNjb3BlcylcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgdmFsdWVJbmRleGVzID0gZ3JvdXBQcm9jZXNzb3JJbmRpY2VzLmdldChwcm9jZXNzb3IpID8/IFtdO1xuICAgICAgICBjb25zdCBhZGp1c3RGbiA9IGdyb3VwUHJvY2Vzc29ySW5pdEZucy5nZXQocHJvY2Vzc29yKT8uKCk7XG4gICAgICAgIGlmICghYWRqdXN0Rm4pXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChwcm9jZXNzZWREYXRhLnR5cGUgPT09IFwiZ3JvdXBlZFwiKSB7XG4gICAgICAgICAgZm9yIChjb25zdCB2YWx1ZXMgb2YgZ3JvdXAudmFsdWVzKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgICAgICAgIGFkanVzdEZuKHZhbHVlcywgdmFsdWVJbmRleGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZ3JvdXAudmFsdWVzKSB7XG4gICAgICAgICAgYWRqdXN0Rm4oZ3JvdXAudmFsdWVzLCB2YWx1ZUluZGV4ZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJvY2Vzc2VkRGF0YS50eXBlID09PSBcImdyb3VwZWRcIikge1xuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlcyBvZiBncm91cC52YWx1ZXMpIHtcbiAgICAgICAgICB1cGRhdGVEb21haW5zKHZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVwZGF0ZURvbWFpbnMoZ3JvdXAudmFsdWVzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBbaWR4LCBkYXRhRG9tYWluXSBvZiB1cGRhdGVkRG9tYWlucykge1xuICAgICAgcHJvY2Vzc2VkRGF0YS5kb21haW4udmFsdWVzW2lkeF0gPSBkYXRhRG9tYWluLmdldERvbWFpbigpO1xuICAgIH1cbiAgfVxuICBwb3N0UHJvY2Vzc1Byb3BlcnRpZXMocHJvY2Vzc2VkRGF0YSkge1xuICAgIGZvciAoY29uc3QgeyBhZGp1c3QsIHByb3BlcnR5LCBzY29wZXMgfSBvZiB0aGlzLnByb3BlcnR5UHJvY2Vzc29ycykge1xuICAgICAgYWRqdXN0KCkocHJvY2Vzc2VkRGF0YSwgdGhpcy52YWx1ZUlkeExvb2t1cChzY29wZXMsIHByb3BlcnR5KSk7XG4gICAgfVxuICB9XG4gIHJlZHVjZURhdGEocHJvY2Vzc2VkRGF0YSkge1xuICAgIHByb2Nlc3NlZERhdGEucmVkdWNlZCA/PyAocHJvY2Vzc2VkRGF0YS5yZWR1Y2VkID0ge30pO1xuICAgIGZvciAoY29uc3QgZGVmIG9mIHRoaXMucmVkdWNlcnMpIHtcbiAgICAgIGNvbnN0IHJlZHVjZXIgPSBkZWYucmVkdWNlcigpO1xuICAgICAgbGV0IGFjY1ZhbHVlID0gZGVmLmluaXRpYWxWYWx1ZTtcbiAgICAgIGZvciAoY29uc3QgZGF0dW0gb2YgcHJvY2Vzc2VkRGF0YS5kYXRhKSB7XG4gICAgICAgIGlmICghZGF0dW0udmFsaWRTY29wZXMgfHwgZGVmLnNjb3Blcz8uc29tZSgocykgPT4gZGF0dW0udmFsaWRTY29wZXM/LmhhcyhzKSkpIHtcbiAgICAgICAgICBhY2NWYWx1ZSA9IHJlZHVjZXIoYWNjVmFsdWUsIGRhdHVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHJvY2Vzc2VkRGF0YS5yZWR1Y2VkW2RlZi5wcm9wZXJ0eV0gPSBhY2NWYWx1ZTtcbiAgICB9XG4gIH1cbiAgcG9zdFByb2Nlc3NEYXRhKHByb2Nlc3NlZERhdGEpIHtcbiAgICBwcm9jZXNzZWREYXRhLnJlZHVjZWQgPz8gKHByb2Nlc3NlZERhdGEucmVkdWNlZCA9IHt9KTtcbiAgICBmb3IgKGNvbnN0IGRlZiBvZiB0aGlzLnByb2Nlc3NvcnMpIHtcbiAgICAgIHByb2Nlc3NlZERhdGEucmVkdWNlZFtkZWYucHJvcGVydHldID0gZGVmLmNhbGN1bGF0ZShwcm9jZXNzZWREYXRhKTtcbiAgICB9XG4gIH1cbiAgaW5pdERhdGFEb21haW5Qcm9jZXNzb3IoKSB7XG4gICAgY29uc3QgeyBrZXlzOiBrZXlEZWZzLCB2YWx1ZXM6IHZhbHVlRGVmcyB9ID0gdGhpcztcbiAgICBjb25zdCBzY29wZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgdmFsdWVEZWYgb2YgdmFsdWVEZWZzKSB7XG4gICAgICBpZiAoIXZhbHVlRGVmLnNjb3BlcylcbiAgICAgICAgY29udGludWU7XG4gICAgICBmb3IgKGNvbnN0IHNjb3BlIG9mIHZhbHVlRGVmLnNjb3Blcykge1xuICAgICAgICBzY29wZXMuYWRkKHNjb3BlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZGF0YURvbWFpbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgY29uc3QgcHJvY2Vzc29yRm5zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBsZXQgYWxsU2NvcGVzSGF2ZVNhbWVEZWZzID0gdHJ1ZTtcbiAgICBjb25zdCBpbml0RGF0YURvbWFpbiA9ICgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgZGVmIG9mIGl0ZXJhdGUoa2V5RGVmcywgdmFsdWVEZWZzKSkge1xuICAgICAgICBpZiAoZGVmLnZhbHVlVHlwZSA9PT0gXCJjYXRlZ29yeVwiKSB7XG4gICAgICAgICAgZGF0YURvbWFpbi5zZXQoZGVmLCBuZXcgRGlzY3JldGVEb21haW4oKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGF0YURvbWFpbi5zZXQoZGVmLCBuZXcgQ29udGludW91c0RvbWFpbigpKTtcbiAgICAgICAgICBhbGxTY29wZXNIYXZlU2FtZURlZnMgJiYgKGFsbFNjb3Blc0hhdmVTYW1lRGVmcyA9IChkZWYuc2NvcGVzID8/IFtdKS5sZW5ndGggPT09IHNjb3Blcy5zaXplKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgaW5pdERhdGFEb21haW4oKTtcbiAgICBjb25zdCBhY2Nlc3NvcnMgPSB0aGlzLmJ1aWxkQWNjZXNzb3JzKGl0ZXJhdGUoa2V5RGVmcywgdmFsdWVEZWZzKSk7XG4gICAgY29uc3QgcHJvY2Vzc1ZhbHVlID0gKGRlZiwgZGF0dW0sIHByZXZpb3VzRGF0dW0sIHNjb3BlKSA9PiB7XG4gICAgICBsZXQgdmFsdWVJbkRhdHVtO1xuICAgICAgbGV0IHZhbHVlO1xuICAgICAgaWYgKGFjY2Vzc29ycy5oYXMoZGVmLnByb3BlcnR5KSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhbHVlID0gYWNjZXNzb3JzLmdldChkZWYucHJvcGVydHkpKGRhdHVtKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZUluRGF0dW0gPSB2YWx1ZSAhPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVJbkRhdHVtID0gZGVmLnByb3BlcnR5IGluIGRhdHVtO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlSW5EYXR1bSA/IGRhdHVtW2RlZi5wcm9wZXJ0eV0gOiBkZWYubWlzc2luZ1ZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGRlZi5mb3JjZVZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgdmFsdWVOZWdhdGl2ZSA9IHZhbHVlSW5EYXR1bSAmJiBpc05lZ2F0aXZlKHZhbHVlKTtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZU5lZ2F0aXZlID8gLTEgKiBkZWYuZm9yY2VWYWx1ZSA6IGRlZi5mb3JjZVZhbHVlO1xuICAgICAgICB2YWx1ZUluRGF0dW0gPSB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgbWlzc2luZ1ZhbHVlRGVmID0gXCJtaXNzaW5nVmFsdWVcIiBpbiBkZWY7XG4gICAgICBpZiAoIXZhbHVlSW5EYXR1bSAmJiAhbWlzc2luZ1ZhbHVlRGVmKSB7XG4gICAgICAgIGNvbnN0IG1pc3NDb3VudCA9IGRlZi5taXNzaW5nLmdldChzY29wZSkgPz8gMDtcbiAgICAgICAgZGVmLm1pc3Npbmcuc2V0KHNjb3BlLCBtaXNzQ291bnQgKyAxKTtcbiAgICAgIH1cbiAgICAgIGlmICghZGF0YURvbWFpbi5oYXMoZGVmKSkge1xuICAgICAgICBpbml0RGF0YURvbWFpbigpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlSW5EYXR1bSAmJiBkZWYudmFsaWRhdGlvbj8uKHZhbHVlLCBkYXR1bSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGlmIChcImludmFsaWRWYWx1ZVwiIGluIGRlZikge1xuICAgICAgICAgIHZhbHVlID0gZGVmLmludmFsaWRWYWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5tb2RlICE9PSBcImludGVncmF0ZWRcIikge1xuICAgICAgICAgICAgTG9nZ2VyLndhcm5PbmNlKFxuICAgICAgICAgICAgICBgaW52YWxpZCB2YWx1ZSBvZiB0eXBlIFske3R5cGVvZiB2YWx1ZX1dIGZvciBbJHtkZWYuc2NvcGVzfSAvICR7ZGVmLmlkfV0gaWdub3JlZDpgLFxuICAgICAgICAgICAgICBgWyR7dmFsdWV9XWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBJTlZBTElEX1ZBTFVFO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZGVmLnByb2Nlc3Nvcikge1xuICAgICAgICBpZiAoIXByb2Nlc3NvckZucy5oYXMoZGVmKSkge1xuICAgICAgICAgIHByb2Nlc3NvckZucy5zZXQoZGVmLCBkZWYucHJvY2Vzc29yKCkpO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gcHJvY2Vzc29yRm5zLmdldChkZWYpPy4odmFsdWUsIHByZXZpb3VzRGF0dW0gPT09IElOVkFMSURfVkFMVUUgPyB2b2lkIDAgOiBwcmV2aW91c0RhdHVtKTtcbiAgICAgIH1cbiAgICAgIGRhdGFEb21haW4uZ2V0KGRlZik/LmV4dGVuZCh2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICByZXR1cm4geyBkYXRhRG9tYWluLCBwcm9jZXNzVmFsdWUsIGluaXREYXRhRG9tYWluLCBzY29wZXMsIGFsbFNjb3Blc0hhdmVTYW1lRGVmcyB9O1xuICB9XG4gIGJ1aWxkQWNjZXNzb3JzKGRlZnMpIHtcbiAgICBjb25zdCByZXN1bHQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGlmICh0aGlzLm1vZGUgPT09IFwiaW50ZWdyYXRlZFwiKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGRlZiBvZiBkZWZzKSB7XG4gICAgICBjb25zdCBpc1BhdGggPSBkZWYucHJvcGVydHkuaW5jbHVkZXMoXCIuXCIpIHx8IGRlZi5wcm9wZXJ0eS5pbmNsdWRlcyhcIltcIik7XG4gICAgICBpZiAoIWlzUGF0aClcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCBjb21wb25lbnRzID0gZ2V0UGF0aENvbXBvbmVudHMoZGVmLnByb3BlcnR5KTtcbiAgICAgIGlmIChjb21wb25lbnRzID09IG51bGwpIHtcbiAgICAgICAgTG9nZ2VyLndhcm5PbmNlKFwiSW52YWxpZCBwcm9wZXJ0eSBwYXRoIFslc11cIiwgZGVmLnByb3BlcnR5KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBhY2Nlc3NvciA9IGNyZWF0ZVBhdGhBY2Nlc3Nvcihjb21wb25lbnRzKTtcbiAgICAgIHJlc3VsdC5zZXQoZGVmLnByb3BlcnR5LCBhY2Nlc3Nvcik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5mdW5jdGlvbiBsb2dQcm9jZXNzZWREYXRhKHByb2Nlc3NlZERhdGEpIHtcbiAgY29uc3QgbG9nVmFsdWVzID0gKG5hbWUsIGRhdGEpID0+IHtcbiAgICBpZiAoZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICBMb2dnZXIubG9nKGBEYXRhTW9kZWwucHJvY2Vzc0RhdGEoKSAtICR7bmFtZX1gKTtcbiAgICAgIExvZ2dlci50YWJsZShkYXRhKTtcbiAgICB9XG4gIH07XG4gIExvZ2dlci5sb2coXCJEYXRhTW9kZWwucHJvY2Vzc0RhdGEoKSAtIHByb2Nlc3NlZERhdGFcIiwgcHJvY2Vzc2VkRGF0YSk7XG4gIGxvZ1ZhbHVlcyhcIktleSBEb21haW5zXCIsIHByb2Nlc3NlZERhdGEuZG9tYWluLmtleXMpO1xuICBsb2dWYWx1ZXMoXCJHcm91cCBEb21haW5zXCIsIHByb2Nlc3NlZERhdGEuZG9tYWluLmdyb3VwcyA/PyBbXSk7XG4gIGxvZ1ZhbHVlcyhcIlZhbHVlIERvbWFpbnNcIiwgcHJvY2Vzc2VkRGF0YS5kb21haW4udmFsdWVzKTtcbiAgbG9nVmFsdWVzKFwiQWdncmVnYXRlIERvbWFpbnNcIiwgcHJvY2Vzc2VkRGF0YS5kb21haW4uYWdnVmFsdWVzID8/IFtdKTtcbiAgaWYgKHByb2Nlc3NlZERhdGEudHlwZSA9PT0gXCJncm91cGVkXCIpIHtcbiAgICBjb25zdCBmbGF0dGVuZWRWYWx1ZXMgPSBwcm9jZXNzZWREYXRhLmRhdGEucmVkdWNlKChhY2MsIG5leHQpID0+IHtcbiAgICAgIGNvbnN0IGtleXMgPSBuZXh0LmtleXMgPz8gW107XG4gICAgICBjb25zdCBhZ2dWYWx1ZXMgPSBuZXh0LmFnZ1ZhbHVlcyA/PyBbXTtcbiAgICAgIGNvbnN0IHNraXBLZXlzID0gbmV4dC5rZXlzLm1hcCgoKSA9PiB2b2lkIDApO1xuICAgICAgY29uc3Qgc2tpcEFnZ1ZhbHVlcyA9IGFnZ1ZhbHVlcz8ubWFwKCgpID0+IHZvaWQgMCk7XG4gICAgICBhY2MucHVzaChcbiAgICAgICAgLi4ubmV4dC52YWx1ZXMubWFwKCh2LCBpKSA9PiBbXG4gICAgICAgICAgLi4uaSA9PT0gMCA/IGtleXMgOiBza2lwS2V5cyxcbiAgICAgICAgICAuLi52ID8/IFtdLFxuICAgICAgICAgIC4uLmkgPT0gMCA/IGFnZ1ZhbHVlcyA6IHNraXBBZ2dWYWx1ZXNcbiAgICAgICAgXSlcbiAgICAgICk7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFtdKTtcbiAgICBsb2dWYWx1ZXMoXCJWYWx1ZXNcIiwgZmxhdHRlbmVkVmFsdWVzKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBmbGF0dGVuZWRWYWx1ZXMgPSBwcm9jZXNzZWREYXRhLmRhdGEucmVkdWNlKChhY2MsIG5leHQpID0+IHtcbiAgICAgIGNvbnN0IGFnZ1ZhbHVlcyA9IG5leHQuYWdnVmFsdWVzID8/IFtdO1xuICAgICAgYWNjLnB1c2goWy4uLm5leHQua2V5cywgLi4ubmV4dC52YWx1ZXMsIC4uLmFnZ1ZhbHVlc10pO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBbXSk7XG4gICAgbG9nVmFsdWVzKFwiVmFsdWVzXCIsIGZsYXR0ZW5lZFZhbHVlcyk7XG4gIH1cbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvZGF0YS9kYXRhQ29udHJvbGxlci50c1xudmFyIF9EYXRhQ29udHJvbGxlciA9IGNsYXNzIF9EYXRhQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKG1vZGUpIHtcbiAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgIHRoaXMuZGVidWcgPSBEZWJ1Zy5jcmVhdGUodHJ1ZSwgXCJkYXRhLW1vZGVsXCIpO1xuICAgIHRoaXMucmVxdWVzdGVkID0gW107XG4gICAgdGhpcy5zdGF0dXMgPSBcInNldHVwXCI7XG4gIH1cbiAgYXN5bmMgcmVxdWVzdChpZCwgZGF0YSwgb3B0cykge1xuICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gXCJzZXR1cFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFHIENoYXJ0cyAtIGRhdGEgcmVxdWVzdCBhZnRlciBkYXRhIHNldHVwIHBoYXNlLmApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5yZXF1ZXN0ZWQucHVzaCh7IGlkLCBvcHRzLCBkYXRhLCByZXNvbHZlLCByZWplY3QgfSk7XG4gICAgfSk7XG4gIH1cbiAgZXhlY3V0ZSgpIHtcbiAgICBpZiAodGhpcy5zdGF0dXMgIT09IFwic2V0dXBcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBRyBDaGFydHMgLSBkYXRhIHJlcXVlc3QgYWZ0ZXIgZGF0YSBzZXR1cCBwaGFzZS5gKTtcbiAgICB9XG4gICAgdGhpcy5zdGF0dXMgPSBcImV4ZWN1dGVkXCI7XG4gICAgdGhpcy5kZWJ1ZyhcIkRhdGFDb250cm9sbGVyLmV4ZWN1dGUoKSAtIHJlcXVlc3RlZFwiLCB0aGlzLnJlcXVlc3RlZCk7XG4gICAgY29uc3QgdmFsaWQgPSB0aGlzLnZhbGlkYXRlUmVxdWVzdHModGhpcy5yZXF1ZXN0ZWQpO1xuICAgIHRoaXMuZGVidWcoXCJEYXRhQ29udHJvbGxlci5leGVjdXRlKCkgLSB2YWxpZGF0ZWRcIiwgdmFsaWQpO1xuICAgIGNvbnN0IG1lcmdlZCA9IHRoaXMubWVyZ2VSZXF1ZXN0ZWQodmFsaWQpO1xuICAgIHRoaXMuZGVidWcoXCJEYXRhQ29udHJvbGxlci5leGVjdXRlKCkgLSBtZXJnZWRcIiwgbWVyZ2VkKTtcbiAgICBpZiAodGhpcy5kZWJ1Zy5jaGVjaygpKSB7XG4gICAgICBnZXRXaW5kb3coKS5wcm9jZXNzZWREYXRhID0gW107XG4gICAgfVxuICAgIGNvbnN0IHNjb3BlcyA9IHRoaXMucmVxdWVzdGVkLm1hcCgoeyBpZCB9KSA9PiBpZCk7XG4gICAgY29uc3QgbmVlZHNWYWx1ZUV4dHJhY3Rpb24gPSB0aGlzLmhhc011bHRpcGxlRGF0YVNvdXJjZXModmFsaWQpO1xuICAgIGZvciAoY29uc3QgeyBvcHRzLCBkYXRhLCByZXNvbHZlcywgcmVqZWN0cywgaWRzIH0gb2YgbWVyZ2VkKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBkYXRhTW9kZWwgPSBuZXcgRGF0YU1vZGVsKG9wdHMsIHRoaXMubW9kZSk7XG4gICAgICAgIGNvbnN0IHByb2Nlc3NlZERhdGEgPSBkYXRhTW9kZWwucHJvY2Vzc0RhdGEoZGF0YSwgdmFsaWQpO1xuICAgICAgICBpZiAodGhpcy5kZWJ1Zy5jaGVjaygpKSB7XG4gICAgICAgICAgZ2V0V2luZG93KFwicHJvY2Vzc2VkRGF0YVwiKS5wdXNoKHByb2Nlc3NlZERhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9jZXNzZWREYXRhPy5wYXJ0aWFsVmFsaWREYXRhQ291bnQgPT09IDApIHtcbiAgICAgICAgICByZXNvbHZlcy5mb3JFYWNoKFxuICAgICAgICAgICAgKHJlc29sdmUsIHJlcXVlc3RJZHgpID0+IHJlc29sdmUoe1xuICAgICAgICAgICAgICBkYXRhTW9kZWwsXG4gICAgICAgICAgICAgIHByb2Nlc3NlZERhdGE6IHRoaXMucHJvY2Vzc1Njb3BlZERhdGEoXG4gICAgICAgICAgICAgICAgaWRzW3JlcXVlc3RJZHhdLFxuICAgICAgICAgICAgICAgIHByb2Nlc3NlZERhdGEsXG4gICAgICAgICAgICAgICAgc2NvcGVzLFxuICAgICAgICAgICAgICAgIG5lZWRzVmFsdWVFeHRyYWN0aW9uXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzZWREYXRhKSB7XG4gICAgICAgICAgdGhpcy5zcGxpdFJlc3VsdChkYXRhTW9kZWwsIHByb2Nlc3NlZERhdGEsIGlkcywgcmVzb2x2ZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdHMuZm9yRWFjaCgoY2IpID0+IGNiKG5ldyBFcnJvcihgQUcgQ2hhcnRzIC0gbm8gcHJvY2Vzc2VkIGRhdGEgZ2VuZXJhdGVkYCkpKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmVqZWN0cy5mb3JFYWNoKChjYikgPT4gY2IoZXJyb3IpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaGFzTXVsdGlwbGVEYXRhU291cmNlcyh2YWxpZFJlcXVlc3RzKSB7XG4gICAgaWYgKHZhbGlkUmVxdWVzdHMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBbeyBkYXRhIH0sIC4uLnJlc3RSZXF1ZXN0c10gPSB2YWxpZFJlcXVlc3RzO1xuICAgICAgcmV0dXJuIHJlc3RSZXF1ZXN0cy5zb21lKCh2KSA9PiBkYXRhICE9PSB2LmRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcHJvY2Vzc1Njb3BlZERhdGEoaWQsIHByb2Nlc3NlZERhdGEsIGlkcywgbmVlZHNWYWx1ZUV4dHJhY3Rpb24pIHtcbiAgICBjb25zdCBleHRyYWN0RGF0dW0gPSAoZGF0dW0pID0+IHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdHVtKSkge1xuICAgICAgICByZXR1cm4gZGF0dW0ubWFwKGV4dHJhY3REYXR1bSk7XG4gICAgICB9XG4gICAgICBjb25zdCBleHRyYWN0ZWQgPSBuZWVkc1ZhbHVlRXh0cmFjdGlvbiA/IHsgLi4uZGF0dW0sIC4uLmRhdHVtW2lkXSB9IDogZGF0dW07XG4gICAgICBmb3IgKGNvbnN0IG90aGVySWQgb2YgaWRzKSB7XG4gICAgICAgIGRlbGV0ZSBleHRyYWN0ZWRbb3RoZXJJZF07XG4gICAgICB9XG4gICAgICByZXR1cm4gZXh0cmFjdGVkO1xuICAgIH07XG4gICAgY29uc3QgZXh0cmFjdFZhbHVlcyA9ICh2YWx1ZXMpID0+IHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlcy5tYXAoZXh0cmFjdFZhbHVlcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWVzPy5baWRdID8/IHZhbHVlcztcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAuLi5wcm9jZXNzZWREYXRhLFxuICAgICAgZGF0YTogcHJvY2Vzc2VkRGF0YS5kYXRhLm1hcCgoZGF0dW0pID0+ICh7XG4gICAgICAgIC4uLmRhdHVtLFxuICAgICAgICBkYXR1bTogZXh0cmFjdERhdHVtKGRhdHVtLmRhdHVtKSxcbiAgICAgICAgdmFsdWVzOiBuZWVkc1ZhbHVlRXh0cmFjdGlvbiA/IGRhdHVtLnZhbHVlcz8ubWFwKGV4dHJhY3RWYWx1ZXMpIDogZGF0dW0udmFsdWVzXG4gICAgICB9KSlcbiAgICB9O1xuICB9XG4gIHZhbGlkYXRlUmVxdWVzdHMocmVxdWVzdGVkKSB7XG4gICAgY29uc3QgdmFsaWQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtpbmRleCwgcmVxdWVzdF0gb2YgcmVxdWVzdGVkLmVudHJpZXMoKSkge1xuICAgICAgaWYgKGluZGV4ID4gMCAmJiByZXF1ZXN0LmRhdGEubGVuZ3RoICE9PSByZXF1ZXN0ZWRbMF0uZGF0YS5sZW5ndGggJiYgcmVxdWVzdC5vcHRzLmdyb3VwQnlEYXRhID09PSBmYWxzZSkge1xuICAgICAgICByZXF1ZXN0LnJlamVjdChcbiAgICAgICAgICBuZXcgRXJyb3IoXCJhbGwgc2VyaWVzW10uZGF0YSBhcnJheXMgbXVzdCBiZSBvZiB0aGUgc2FtZSBsZW5ndGggYW5kIGhhdmUgbWF0Y2hpbmcga2V5cy5cIilcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbGlkLnB1c2gocmVxdWVzdCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWxpZDtcbiAgfVxuICBtZXJnZVJlcXVlc3RlZChyZXF1ZXN0ZWQpIHtcbiAgICBjb25zdCBncm91cGVkID0gW107XG4gICAgZm9yIChjb25zdCByZXF1ZXN0IG9mIHJlcXVlc3RlZCkge1xuICAgICAgY29uc3QgbWF0Y2ggPSBncm91cGVkLmZpbmQoX0RhdGFDb250cm9sbGVyLmdyb3VwTWF0Y2gocmVxdWVzdCkpO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIG1hdGNoLnB1c2gocmVxdWVzdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBncm91cGVkLnB1c2goW3JlcXVlc3RdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdyb3VwZWQubWFwKF9EYXRhQ29udHJvbGxlci5tZXJnZVJlcXVlc3RzKTtcbiAgfVxuICBzcGxpdFJlc3VsdChkYXRhTW9kZWwsIHByb2Nlc3NlZERhdGEsIHNjb3BlcywgcmVzb2x2ZXMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNjb3Blcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc2NvcGUgPSBzY29wZXNbaV07XG4gICAgICBjb25zdCByZXNvbHZlID0gcmVzb2x2ZXNbaV07XG4gICAgICByZXNvbHZlKHtcbiAgICAgICAgZGF0YU1vZGVsLFxuICAgICAgICBwcm9jZXNzZWREYXRhOiB7XG4gICAgICAgICAgLi4ucHJvY2Vzc2VkRGF0YSxcbiAgICAgICAgICBkYXRhOiBwcm9jZXNzZWREYXRhLmRhdGEuZmlsdGVyKCh7IHZhbGlkU2NvcGVzIH0pID0+IHZhbGlkU2NvcGVzPy5oYXMoc2NvcGUpID8/IHRydWUpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZ3JvdXBNYXRjaCh7IGRhdGEsIG9wdHMgfSkge1xuICAgIGZ1bmN0aW9uIGtleXMocHJvcHMpIHtcbiAgICAgIHJldHVybiBwcm9wcy5maWx0ZXIoKHApID0+IHAudHlwZSA9PT0gXCJrZXlcIikubWFwKChwKSA9PiBwLnByb3BlcnR5KS5qb2luKFwiO1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIChbZ3JvdXBdKSA9PiAob3B0cy5ncm91cEJ5RGF0YSA9PT0gZmFsc2UgfHwgZ3JvdXAuZGF0YSA9PT0gZGF0YSkgJiYgZ3JvdXAub3B0cy5ncm91cEJ5S2V5cyA9PT0gb3B0cy5ncm91cEJ5S2V5cyAmJiBncm91cC5vcHRzLmdyb3VwQnlGbiA9PT0gb3B0cy5ncm91cEJ5Rm4gJiYga2V5cyhncm91cC5vcHRzLnByb3BzKSA9PT0ga2V5cyhvcHRzLnByb3BzKTtcbiAgfVxuICBzdGF0aWMgbWVyZ2VSZXF1ZXN0cyhyZXF1ZXN0cykge1xuICAgIHJldHVybiByZXF1ZXN0cy5yZWR1Y2UoXG4gICAgICAocmVzdWx0LCB7IGlkLCBkYXRhLCByZXNvbHZlLCByZWplY3QsIG9wdHM6IHsgcHJvcHMsIC4uLm9wdHMgfSB9KSA9PiB7XG4gICAgICAgIHJlc3VsdC5pZHMucHVzaChpZCk7XG4gICAgICAgIHJlc3VsdC5yZWplY3RzLnB1c2gocmVqZWN0KTtcbiAgICAgICAgcmVzdWx0LnJlc29sdmVzLnB1c2gocmVzb2x2ZSk7XG4gICAgICAgIHJlc3VsdC5kYXRhID8/IChyZXN1bHQuZGF0YSA9IGRhdGEpO1xuICAgICAgICByZXN1bHQub3B0cyA/PyAocmVzdWx0Lm9wdHMgPSB7IC4uLm9wdHMsIHByb3BzOiBbXSB9KTtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wIG9mIHByb3BzKSB7XG4gICAgICAgICAgY29uc3QgY2xvbmUyID0geyAuLi5wcm9wLCBzY29wZXM6IFtpZF0gfTtcbiAgICAgICAgICBfRGF0YUNvbnRyb2xsZXIuY3JlYXRlSWRzTWFwKGlkLCBjbG9uZTIpO1xuICAgICAgICAgIGNvbnN0IG1hdGNoID0gcmVzdWx0Lm9wdHMucHJvcHMuZmluZChcbiAgICAgICAgICAgIChleGlzdGluZykgPT4gZXhpc3RpbmcudHlwZSA9PT0gY2xvbmUyLnR5cGUgJiYgX0RhdGFDb250cm9sbGVyLmRlZXBFcXVhbChleGlzdGluZywgY2xvbmUyKVxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgcmVzdWx0Lm9wdHMucHJvcHMucHVzaChjbG9uZTIpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1hdGNoLnNjb3BlcyA/PyAobWF0Y2guc2NvcGVzID0gW10pO1xuICAgICAgICAgIG1hdGNoLnNjb3Blcy5wdXNoKC4uLmNsb25lMi5zY29wZXMgPz8gW10pO1xuICAgICAgICAgIGlmICgobWF0Y2gudHlwZSA9PT0gXCJrZXlcIiB8fCBtYXRjaC50eXBlID09PSBcInZhbHVlXCIpICYmIGNsb25lMi5pZHNNYXA/LnNpemUpIHtcbiAgICAgICAgICAgIF9EYXRhQ29udHJvbGxlci5tZXJnZUlkc01hcChjbG9uZTIuaWRzTWFwLCBtYXRjaC5pZHNNYXApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSxcbiAgICAgIHsgaWRzOiBbXSwgcmVqZWN0czogW10sIHJlc29sdmVzOiBbXSwgZGF0YTogbnVsbCwgb3B0czogbnVsbCB9XG4gICAgKTtcbiAgfVxuICBzdGF0aWMgbWVyZ2VJZHNNYXAoZnJvbU1hcCwgdG9NYXApIHtcbiAgICBmb3IgKGNvbnN0IFtzY29wZSwgaWRzXSBvZiBmcm9tTWFwKSB7XG4gICAgICBjb25zdCB0b01hcFZhbHVlID0gdG9NYXAuZ2V0KHNjb3BlKTtcbiAgICAgIGlmICh0b01hcFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgZm9yIChjb25zdCBpZCBvZiBpZHMpIHtcbiAgICAgICAgICB0b01hcFZhbHVlLmFkZChpZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvTWFwLnNldChzY29wZSwgbmV3IFNldChpZHMpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc3RhdGljIGNyZWF0ZUlkc01hcChzY29wZSwgcHJvcCkge1xuICAgIGlmIChwcm9wLmlkID09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgcHJvcC5pZHNNYXAgPz8gKHByb3AuaWRzTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gICAgaWYgKHByb3AuaWRzTWFwLmhhcyhzY29wZSkpIHtcbiAgICAgIHByb3AuaWRzTWFwLmdldChzY29wZSkuYWRkKHByb3AuaWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9wLmlkc01hcC5zZXQoc2NvcGUsIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtwcm9wLmlkXSkpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZGVlcEVxdWFsKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gYikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChhICYmIGIgJiYgdHlwZW9mIGEgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgYiA9PSBcIm9iamVjdFwiKSB7XG4gICAgICBpZiAoYS5jb25zdHJ1Y3RvciAhPT0gYi5jb25zdHJ1Y3Rvcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBsZXQgaSwgbGVuZ3RoMjtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICAgIGxlbmd0aDIgPSBhLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aDIgIT09IGIubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IGxlbmd0aDIgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmICghX0RhdGFDb250cm9sbGVyLmRlZXBFcXVhbChhW2ldLCBiW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICAgIGxlbmd0aDIgPSBrZXlzLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGgyICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gbGVuZ3RoMiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgIGlmICghX0RhdGFDb250cm9sbGVyLnNraXBLZXlzLmhhcyhrZXkpICYmICghT2JqZWN0Lmhhc093bihiLCBrZXkpIHx8ICFfRGF0YUNvbnRyb2xsZXIuZGVlcEVxdWFsKGFba2V5XSwgYltrZXldKSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG4vLyBvcHRpbWl6ZWQgdmVyc2lvbiBvZiBkZWVwIGVxdWFsaXR5IGZvciBgbWVyZ2VSZXF1ZXN0c2Agd2hpY2ggY2FuIHBvdGVudGlhbGx5IGxvb3Agb3ZlciAxTSB0aW1lc1xuX0RhdGFDb250cm9sbGVyLnNraXBLZXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiaWRcIiwgXCJpZHNNYXBcIiwgXCJ0eXBlXCIsIFwic2NvcGVzXCJdKTtcbnZhciBEYXRhQ29udHJvbGxlciA9IF9EYXRhQ29udHJvbGxlcjtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvZmFjdG9yeS9heGlzUmVnaXN0cnkudHNcbnZhciBBeGlzUmVnaXN0cnkgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuYXhlc01hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5oaWRkZW4gPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMudGhlbWVUZW1wbGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIHJlZ2lzdGVyKGF4aXNUeXBlLCBtb2R1bGUpIHtcbiAgICB0aGlzLmF4ZXNNYXAuc2V0KGF4aXNUeXBlLCBtb2R1bGUubW9kdWxlRmFjdG9yeSk7XG4gICAgaWYgKG1vZHVsZS50aGVtZVRlbXBsYXRlKSB7XG4gICAgICB0aGlzLnNldFRoZW1lVGVtcGxhdGUoYXhpc1R5cGUsIG1vZHVsZS50aGVtZVRlbXBsYXRlKTtcbiAgICB9XG4gICAgaWYgKG1vZHVsZS5oaWRkZW4pIHtcbiAgICAgIHRoaXMuaGlkZGVuLmFkZChheGlzVHlwZSk7XG4gICAgfVxuICB9XG4gIGNyZWF0ZShheGlzVHlwZSwgbW9kdWxlQ29udGV4dCkge1xuICAgIGNvbnN0IGF4aXNGYWN0b3J5ID0gdGhpcy5heGVzTWFwLmdldChheGlzVHlwZSk7XG4gICAgaWYgKGF4aXNGYWN0b3J5KSB7XG4gICAgICByZXR1cm4gYXhpc0ZhY3RvcnkobW9kdWxlQ29udGV4dCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgQUcgQ2hhcnRzIC0gdW5rbm93biBheGlzIHR5cGU6ICR7YXhpc1R5cGV9YCk7XG4gIH1cbiAgaGFzKGF4aXNUeXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuYXhlc01hcC5oYXMoYXhpc1R5cGUpO1xuICB9XG4gIGtleXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXhlc01hcC5rZXlzKCk7XG4gIH1cbiAgcHVibGljS2V5cygpIHtcbiAgICByZXR1cm4gWy4uLnRoaXMua2V5cygpXS5maWx0ZXIoKGspID0+ICF0aGlzLmhpZGRlbi5oYXMoaykpO1xuICB9XG4gIHNldFRoZW1lVGVtcGxhdGUoYXhpc1R5cGUsIHRoZW1lVGVtcGxhdGUpIHtcbiAgICB0aGlzLnRoZW1lVGVtcGxhdGVzLnNldChheGlzVHlwZSwgdGhlbWVUZW1wbGF0ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZ2V0VGhlbWVUZW1wbGF0ZShheGlzVHlwZSkge1xuICAgIHJldHVybiB0aGlzLnRoZW1lVGVtcGxhdGVzLmdldChheGlzVHlwZSk7XG4gIH1cbn07XG52YXIgYXhpc1JlZ2lzdHJ5ID0gbmV3IEF4aXNSZWdpc3RyeSgpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9mYWN0b3J5L2V4cGVjdGVkRW50ZXJwcmlzZU1vZHVsZXMudHNcbnZhciBFWFBFQ1RFRF9FTlRFUlBSSVNFX01PRFVMRVMgPSBbXG4gIHtcbiAgICB0eXBlOiBcInJvb3RcIixcbiAgICBvcHRpb25zS2V5OiBcImFuaW1hdGlvblwiLFxuICAgIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiLCBcInBvbGFyXCIsIFwiaGllcmFyY2h5XCIsIFwidG9wb2xvZ3lcIiwgXCJmbG93LXByb3BvcnRpb25cIiwgXCJzdGFuZGFsb25lXCIsIFwiZ2F1Z2VcIl1cbiAgfSxcbiAgeyB0eXBlOiBcInJvb3RcIiwgb3B0aW9uc0tleTogXCJhbm5vdGF0aW9uc1wiLCBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIl0gfSxcbiAge1xuICAgIHR5cGU6IFwicm9vdFwiLFxuICAgIG9wdGlvbnNLZXk6IFwiYmFja2dyb3VuZFwiLFxuICAgIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiLCBcInBvbGFyXCIsIFwiaGllcmFyY2h5XCIsIFwidG9wb2xvZ3lcIiwgXCJmbG93LXByb3BvcnRpb25cIiwgXCJzdGFuZGFsb25lXCIsIFwiZ2F1Z2VcIl0sXG4gICAgb3B0aW9uc0lubmVyS2V5OiBcImltYWdlXCJcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwicm9vdFwiLFxuICAgIG9wdGlvbnNLZXk6IFwiZm9yZWdyb3VuZFwiLFxuICAgIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiLCBcInBvbGFyXCIsIFwiaGllcmFyY2h5XCIsIFwidG9wb2xvZ3lcIiwgXCJmbG93LXByb3BvcnRpb25cIiwgXCJzdGFuZGFsb25lXCIsIFwiZ2F1Z2VcIl0sXG4gICAgb3B0aW9uc0lubmVyS2V5OiBcImltYWdlXCJcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwicm9vdFwiLFxuICAgIG9wdGlvbnNLZXk6IFwiY2hhcnRUb29sYmFyXCIsXG4gICAgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCJdXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcInJvb3RcIixcbiAgICBvcHRpb25zS2V5OiBcImNvbnRleHRNZW51XCIsXG4gICAgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCIsIFwicG9sYXJcIiwgXCJoaWVyYXJjaHlcIiwgXCJ0b3BvbG9neVwiLCBcImZsb3ctcHJvcG9ydGlvblwiLCBcInN0YW5kYWxvbmVcIiwgXCJnYXVnZVwiXVxuICB9LFxuICB7IHR5cGU6IFwicm9vdFwiLCBvcHRpb25zS2V5OiBcInN0YXR1c0JhclwiLCBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIl0sIGlkZW50aWZpZXI6IFwic3RhdHVzLWJhclwiIH0sXG4gIHtcbiAgICB0eXBlOiBcInJvb3RcIixcbiAgICBvcHRpb25zS2V5OiBcImRhdGFTb3VyY2VcIixcbiAgICBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIiwgXCJwb2xhclwiLCBcImhpZXJhcmNoeVwiLCBcInRvcG9sb2d5XCIsIFwiZmxvdy1wcm9wb3J0aW9uXCIsIFwic3RhbmRhbG9uZVwiLCBcImdhdWdlXCJdXG4gIH0sXG4gIHsgdHlwZTogXCJyb290XCIsIG9wdGlvbnNLZXk6IFwic3luY1wiLCBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIl0gfSxcbiAgeyB0eXBlOiBcInJvb3RcIiwgb3B0aW9uc0tleTogXCJ6b29tXCIsIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiLCBcInRvcG9sb2d5XCJdIH0sXG4gIHtcbiAgICB0eXBlOiBcImxlZ2VuZFwiLFxuICAgIG9wdGlvbnNLZXk6IFwiZ3JhZGllbnRMZWdlbmRcIixcbiAgICBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIiwgXCJwb2xhclwiLCBcImhpZXJhcmNoeVwiLCBcInRvcG9sb2d5XCIsIFwiZmxvdy1wcm9wb3J0aW9uXCIsIFwic3RhbmRhbG9uZVwiLCBcImdhdWdlXCJdLFxuICAgIGlkZW50aWZpZXI6IFwiZ3JhZGllbnRcIlxuICB9LFxuICB7IHR5cGU6IFwicm9vdFwiLCBvcHRpb25zS2V5OiBcIm5hdmlnYXRvclwiLCBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIl0sIG9wdGlvbnNJbm5lcktleTogXCJtaW5pQ2hhcnRcIiB9LFxuICB7IHR5cGU6IFwiYXhpc1wiLCBvcHRpb25zS2V5OiBcImF4ZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJwb2xhclwiXSwgaWRlbnRpZmllcjogXCJhbmdsZS1jYXRlZ29yeVwiIH0sXG4gIHsgdHlwZTogXCJheGlzXCIsIG9wdGlvbnNLZXk6IFwiYXhlc1tdXCIsIGNoYXJ0VHlwZXM6IFtcInBvbGFyXCJdLCBpZGVudGlmaWVyOiBcImFuZ2xlLW51bWJlclwiIH0sXG4gIHsgdHlwZTogXCJheGlzXCIsIG9wdGlvbnNLZXk6IFwiYXhlc1tdXCIsIGNoYXJ0VHlwZXM6IFtcInBvbGFyXCJdLCBpZGVudGlmaWVyOiBcInJhZGl1cy1jYXRlZ29yeVwiIH0sXG4gIHsgdHlwZTogXCJheGlzXCIsIG9wdGlvbnNLZXk6IFwiYXhlc1tdXCIsIGNoYXJ0VHlwZXM6IFtcInBvbGFyXCJdLCBpZGVudGlmaWVyOiBcInJhZGl1cy1udW1iZXJcIiB9LFxuICB7IHR5cGU6IFwiYXhpc1wiLCBvcHRpb25zS2V5OiBcImF4ZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIl0sIGlkZW50aWZpZXI6IFwib3JkaW5hbC10aW1lXCIgfSxcbiAgeyB0eXBlOiBcImF4aXMtb3B0aW9uXCIsIG9wdGlvbnNLZXk6IFwiY3Jvc3NoYWlyXCIsIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiXSB9LFxuICB7IHR5cGU6IFwic2VyaWVzXCIsIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIiwgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCJdLCBpZGVudGlmaWVyOiBcImJveC1wbG90XCIgfSxcbiAgeyB0eXBlOiBcInNlcmllc1wiLCBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiXSwgaWRlbnRpZmllcjogXCJjYW5kbGVzdGlja1wiIH0sXG4gIHsgdHlwZTogXCJzZXJpZXNcIiwgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIl0sIGlkZW50aWZpZXI6IFwiY29uZS1mdW5uZWxcIiB9LFxuICB7IHR5cGU6IFwic2VyaWVzXCIsIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIiwgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCJdLCBpZGVudGlmaWVyOiBcImZ1bm5lbFwiIH0sXG4gIHsgdHlwZTogXCJzZXJpZXNcIiwgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIl0sIGlkZW50aWZpZXI6IFwib2hsY1wiIH0sXG4gIHsgdHlwZTogXCJzZXJpZXNcIiwgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIl0sIGlkZW50aWZpZXI6IFwiYnVsbGV0XCIgfSxcbiAgeyB0eXBlOiBcInNlcmllc1wiLCBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiXSwgaWRlbnRpZmllcjogXCJoZWF0bWFwXCIgfSxcbiAgeyB0eXBlOiBcInNlcmllc1wiLCBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiXSwgaWRlbnRpZmllcjogXCJyYW5nZS1hcmVhXCIgfSxcbiAgeyB0eXBlOiBcInNlcmllc1wiLCBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiXSwgaWRlbnRpZmllcjogXCJyYW5nZS1iYXJcIiB9LFxuICB7IHR5cGU6IFwic2VyaWVzXCIsIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIiwgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCJdLCBpZGVudGlmaWVyOiBcIndhdGVyZmFsbFwiIH0sXG4gIHsgdHlwZTogXCJzZXJpZXNcIiwgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJwb2xhclwiXSwgaWRlbnRpZmllcjogXCJuaWdodGluZ2FsZVwiIH0sXG4gIHsgdHlwZTogXCJzZXJpZXNcIiwgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJwb2xhclwiXSwgaWRlbnRpZmllcjogXCJyYWRhci1hcmVhXCIgfSxcbiAgeyB0eXBlOiBcInNlcmllc1wiLCBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsIGNoYXJ0VHlwZXM6IFtcInBvbGFyXCJdLCBpZGVudGlmaWVyOiBcInJhZGFyLWxpbmVcIiB9LFxuICB7IHR5cGU6IFwic2VyaWVzXCIsIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIiwgY2hhcnRUeXBlczogW1wicG9sYXJcIl0sIGlkZW50aWZpZXI6IFwicmFkaWFsLWJhclwiIH0sXG4gIHsgdHlwZTogXCJzZXJpZXNcIiwgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJwb2xhclwiXSwgaWRlbnRpZmllcjogXCJyYWRpYWwtY29sdW1uXCIgfSxcbiAgeyB0eXBlOiBcInNlcmllc1wiLCBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsIGNoYXJ0VHlwZXM6IFtcImhpZXJhcmNoeVwiXSwgaWRlbnRpZmllcjogXCJzdW5idXJzdFwiIH0sXG4gIHsgdHlwZTogXCJzZXJpZXNcIiwgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJoaWVyYXJjaHlcIl0sIGlkZW50aWZpZXI6IFwidHJlZW1hcFwiIH0sXG4gIHsgdHlwZTogXCJzZXJpZXNcIiwgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJ0b3BvbG9neVwiXSwgaWRlbnRpZmllcjogXCJtYXAtc2hhcGVcIiB9LFxuICB7IHR5cGU6IFwic2VyaWVzXCIsIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIiwgY2hhcnRUeXBlczogW1widG9wb2xvZ3lcIl0sIGlkZW50aWZpZXI6IFwibWFwLWxpbmVcIiB9LFxuICB7IHR5cGU6IFwic2VyaWVzXCIsIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIiwgY2hhcnRUeXBlczogW1widG9wb2xvZ3lcIl0sIGlkZW50aWZpZXI6IFwibWFwLW1hcmtlclwiIH0sXG4gIHsgdHlwZTogXCJzZXJpZXNcIiwgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJ0b3BvbG9neVwiXSwgaWRlbnRpZmllcjogXCJtYXAtc2hhcGUtYmFja2dyb3VuZFwiIH0sXG4gIHsgdHlwZTogXCJzZXJpZXNcIiwgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJ0b3BvbG9neVwiXSwgaWRlbnRpZmllcjogXCJtYXAtbGluZS1iYWNrZ3JvdW5kXCIgfSxcbiAgeyB0eXBlOiBcInNlcmllc1wiLCBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsIGNoYXJ0VHlwZXM6IFtcImZsb3ctcHJvcG9ydGlvblwiXSwgaWRlbnRpZmllcjogXCJjaG9yZFwiIH0sXG4gIHsgdHlwZTogXCJzZXJpZXNcIiwgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJmbG93LXByb3BvcnRpb25cIl0sIGlkZW50aWZpZXI6IFwic2Fua2V5XCIgfSxcbiAgeyB0eXBlOiBcInNlcmllc1wiLCBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsIGNoYXJ0VHlwZXM6IFtcInN0YW5kYWxvbmVcIl0sIGlkZW50aWZpZXI6IFwicHlyYW1pZFwiIH0sXG4gIHsgdHlwZTogXCJzZXJpZXNcIiwgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJnYXVnZVwiXSwgaWRlbnRpZmllcjogXCJsaW5lYXItZ2F1Z2VcIiB9LFxuICB7IHR5cGU6IFwic2VyaWVzXCIsIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIiwgY2hhcnRUeXBlczogW1wiZ2F1Z2VcIl0sIGlkZW50aWZpZXI6IFwicmFkaWFsLWdhdWdlXCIgfSxcbiAgeyB0eXBlOiBcInNlcmllcy1vcHRpb25cIiwgb3B0aW9uc0tleTogXCJlcnJvckJhclwiLCBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIl0sIGlkZW50aWZpZXI6IFwiZXJyb3ItYmFyc1wiIH1cbl07XG5mdW5jdGlvbiBpc0VudGVycHJpc2VTZXJpZXNUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIEVYUEVDVEVEX0VOVEVSUFJJU0VfTU9EVUxFUy5zb21lKChzKSA9PiBzLnR5cGUgPT09IFwic2VyaWVzXCIgJiYgcy5pZGVudGlmaWVyID09PSB0eXBlKTtcbn1cbmZ1bmN0aW9uIGdldEVudGVycHJpc2VTZXJpZXNDaGFydFR5cGVzKHR5cGUpIHtcbiAgcmV0dXJuIEVYUEVDVEVEX0VOVEVSUFJJU0VfTU9EVUxFUy5maW5kKChzKSA9PiBzLnR5cGUgPT09IFwic2VyaWVzXCIgJiYgcy5pZGVudGlmaWVyID09PSB0eXBlKT8uY2hhcnRUeXBlcztcbn1cbmZ1bmN0aW9uIGlzRW50ZXJwcmlzZUNhcnRlc2lhbihzZXJpZXNUeXBlMikge1xuICBjb25zdCB0eXBlID0gZ2V0RW50ZXJwcmlzZVNlcmllc0NoYXJ0VHlwZXMoc2VyaWVzVHlwZTIpPy5maW5kKCh2KSA9PiB2ID09PSBcImNhcnRlc2lhblwiKTtcbiAgcmV0dXJuIHR5cGUgPT09IFwiY2FydGVzaWFuXCI7XG59XG5mdW5jdGlvbiBpc0VudGVycHJpc2VQb2xhcihzZXJpZXNUeXBlMikge1xuICBjb25zdCB0eXBlID0gZ2V0RW50ZXJwcmlzZVNlcmllc0NoYXJ0VHlwZXMoc2VyaWVzVHlwZTIpPy5maW5kKCh2KSA9PiB2ID09PSBcInBvbGFyXCIpO1xuICByZXR1cm4gdHlwZSA9PT0gXCJwb2xhclwiO1xufVxuZnVuY3Rpb24gaXNFbnRlcnByaXNlSGllcmFyY2h5KHNlcmllc1R5cGUyKSB7XG4gIGNvbnN0IHR5cGUgPSBnZXRFbnRlcnByaXNlU2VyaWVzQ2hhcnRUeXBlcyhzZXJpZXNUeXBlMik/LmZpbmQoKHYpID0+IHYgPT09IFwiaGllcmFyY2h5XCIpO1xuICByZXR1cm4gdHlwZSA9PT0gXCJoaWVyYXJjaHlcIjtcbn1cbmZ1bmN0aW9uIGlzRW50ZXJwcmlzZVRvcG9sb2d5KHNlcmllc1R5cGUyKSB7XG4gIGNvbnN0IHR5cGUgPSBnZXRFbnRlcnByaXNlU2VyaWVzQ2hhcnRUeXBlcyhzZXJpZXNUeXBlMik/LmZpbmQoKHYpID0+IHYgPT09IFwidG9wb2xvZ3lcIik7XG4gIHJldHVybiB0eXBlID09PSBcInRvcG9sb2d5XCI7XG59XG5mdW5jdGlvbiBpc0VudGVycHJpc2VGbG93UHJvcG9ydGlvbihzZXJpZXNUeXBlMikge1xuICBjb25zdCB0eXBlID0gZ2V0RW50ZXJwcmlzZVNlcmllc0NoYXJ0VHlwZXMoc2VyaWVzVHlwZTIpPy5maW5kKCh2KSA9PiB2ID09PSBcImZsb3ctcHJvcG9ydGlvblwiKTtcbiAgcmV0dXJuIHR5cGUgPT09IFwiZmxvdy1wcm9wb3J0aW9uXCI7XG59XG5mdW5jdGlvbiBpc0VudGVycHJpc2VTdGFuZGFsb25lKHNlcmllc1R5cGUyKSB7XG4gIGNvbnN0IHR5cGUgPSBnZXRFbnRlcnByaXNlU2VyaWVzQ2hhcnRUeXBlcyhzZXJpZXNUeXBlMik/LmZpbmQoKHYpID0+IHYgPT09IFwic3RhbmRhbG9uZVwiKTtcbiAgcmV0dXJuIHR5cGUgPT09IFwic3RhbmRhbG9uZVwiO1xufVxuZnVuY3Rpb24gaXNFbnRlcnByaXNlR2F1Z2Uoc2VyaWVzVHlwZTIpIHtcbiAgY29uc3QgdHlwZSA9IGdldEVudGVycHJpc2VTZXJpZXNDaGFydFR5cGVzKHNlcmllc1R5cGUyKT8uZmluZCgodikgPT4gdiA9PT0gXCJnYXVnZVwiKTtcbiAgcmV0dXJuIHR5cGUgPT09IFwiZ2F1Z2VcIjtcbn1cbmZ1bmN0aW9uIGlzRW50ZXJwcmlzZU1vZHVsZShtb2R1bGUpIHtcbiAgcmV0dXJuIG1vZHVsZS5wYWNrYWdlVHlwZSA9PT0gXCJlbnRlcnByaXNlXCI7XG59XG5mdW5jdGlvbiB2ZXJpZnlJZk1vZHVsZUV4cGVjdGVkKG1vZHVsZSkge1xuICBpZiAoIWlzRW50ZXJwcmlzZU1vZHVsZShtb2R1bGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQUcgQ2hhcnRzIC0gaW50ZXJuYWwgY29uZmlndXJhdGlvbiBlcnJvciwgb25seSBlbnRlcnByaXNlIG1vZHVsZXMgbmVlZCB2ZXJpZmljYXRpb24uXCIpO1xuICB9XG4gIGNvbnN0IHN0dWIgPSBFWFBFQ1RFRF9FTlRFUlBSSVNFX01PRFVMRVMuZmluZCgocykgPT4ge1xuICAgIHJldHVybiBzLnR5cGUgPT09IG1vZHVsZS50eXBlICYmIHMub3B0aW9uc0tleSA9PT0gbW9kdWxlLm9wdGlvbnNLZXkgJiYgcy5pZGVudGlmaWVyID09PSBtb2R1bGUuaWRlbnRpZmllciAmJiBtb2R1bGUuY2hhcnRUeXBlcy5ldmVyeSgodCkgPT4gcy5jaGFydFR5cGVzLmluY2x1ZGVzKHQpKTtcbiAgfSk7XG4gIGlmIChzdHViKSB7XG4gICAgc3R1Yi51c2VDb3VudCA/PyAoc3R1Yi51c2VDb3VudCA9IDApO1xuICAgIHN0dWIudXNlQ291bnQrKztcbiAgfVxuICByZXR1cm4gc3R1YiAhPSBudWxsO1xufVxuZnVuY3Rpb24gZ2V0VW51c2VkRXhwZWN0ZWRNb2R1bGVzKCkge1xuICByZXR1cm4gRVhQRUNURURfRU5URVJQUklTRV9NT0RVTEVTLmZpbHRlcigoeyB1c2VDb3VudCB9KSA9PiB1c2VDb3VudCA9PSBudWxsIHx8IHVzZUNvdW50ID09PSAwKTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvZmFjdG9yeS9sZWdlbmRSZWdpc3RyeS50c1xudmFyIExlZ2VuZFJlZ2lzdHJ5ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmxlZ2VuZE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy50aGVtZVRlbXBsYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgcmVnaXN0ZXIobGVnZW5kVHlwZSwgeyBvcHRpb25zS2V5LCBtb2R1bGVGYWN0b3J5LCB0aGVtZVRlbXBsYXRlIH0pIHtcbiAgICB0aGlzLmxlZ2VuZE1hcC5zZXQobGVnZW5kVHlwZSwgeyBvcHRpb25zS2V5LCBtb2R1bGVGYWN0b3J5IH0pO1xuICAgIHRoaXMudGhlbWVUZW1wbGF0ZXMuc2V0KG9wdGlvbnNLZXksIHRoZW1lVGVtcGxhdGUpO1xuICB9XG4gIGNyZWF0ZShsZWdlbmRUeXBlLCBtb2R1bGVDb250ZXh0KSB7XG4gICAgY29uc3QgbGVnZW5kRmFjdG9yeSA9IHRoaXMubGVnZW5kTWFwLmdldChsZWdlbmRUeXBlKT8ubW9kdWxlRmFjdG9yeTtcbiAgICBpZiAobGVnZW5kRmFjdG9yeSkge1xuICAgICAgcmV0dXJuIGxlZ2VuZEZhY3RvcnkobW9kdWxlQ29udGV4dCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgQUcgQ2hhcnRzIC0gdW5rbm93biBsZWdlbmQgdHlwZTogJHtsZWdlbmRUeXBlfWApO1xuICB9XG4gIGdldFRoZW1lVGVtcGxhdGVzKCkge1xuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXModGhpcy50aGVtZVRlbXBsYXRlcyk7XG4gIH1cbiAgZ2V0S2V5cygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmxlZ2VuZE1hcC5lbnRyaWVzKCkpLnJlZHVjZShcbiAgICAgIChyZXN1bHQsIFtsZWdlbmRUeXBlLCByZWNvcmRdKSA9PiB7XG4gICAgICAgIHJlc3VsdFtsZWdlbmRUeXBlXSA9IHJlY29yZC5vcHRpb25zS2V5O1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSxcbiAgICAgIHt9XG4gICAgKTtcbiAgfVxufTtcbnZhciBsZWdlbmRSZWdpc3RyeSA9IG5ldyBMZWdlbmRSZWdpc3RyeSgpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9mYWN0b3J5L2NoYXJ0VHlwZXMudHNcbnZhciBDaGFydFR5cGVzID0gY2xhc3MgZXh0ZW5kcyBNYXAge1xuICBnZXQoc2VyaWVzVHlwZTIpIHtcbiAgICByZXR1cm4gc3VwZXIuZ2V0KHNlcmllc1R5cGUyKSA/PyBcInVua25vd25cIjtcbiAgfVxuICBpc0NhcnRlc2lhbihzZXJpZXNUeXBlMikge1xuICAgIHJldHVybiB0aGlzLmdldChzZXJpZXNUeXBlMikgPT09IFwiY2FydGVzaWFuXCI7XG4gIH1cbiAgaXNQb2xhcihzZXJpZXNUeXBlMikge1xuICAgIHJldHVybiB0aGlzLmdldChzZXJpZXNUeXBlMikgPT09IFwicG9sYXJcIjtcbiAgfVxuICBpc0hpZXJhcmNoeShzZXJpZXNUeXBlMikge1xuICAgIHJldHVybiB0aGlzLmdldChzZXJpZXNUeXBlMikgPT09IFwiaGllcmFyY2h5XCI7XG4gIH1cbiAgaXNUb3BvbG9neShzZXJpZXNUeXBlMikge1xuICAgIHJldHVybiB0aGlzLmdldChzZXJpZXNUeXBlMikgPT09IFwidG9wb2xvZ3lcIjtcbiAgfVxuICBpc0Zsb3dQcm9wb3J0aW9uKHNlcmllc1R5cGUyKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KHNlcmllc1R5cGUyKSA9PT0gXCJmbG93LXByb3BvcnRpb25cIjtcbiAgfVxuICBpc1N0YW5kYWxvbmUoc2VyaWVzVHlwZTIpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoc2VyaWVzVHlwZTIpID09PSBcInN0YW5kYWxvbmVcIjtcbiAgfVxuICBpc0dhdWdlKHNlcmllc1R5cGUyKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KHNlcmllc1R5cGUyKSA9PT0gXCJnYXVnZVwiO1xuICB9XG4gIGdldCBzZXJpZXNUeXBlcygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmtleXMoKSk7XG4gIH1cbiAgZ2V0IGNhcnRlc2lhblR5cGVzKCkge1xuICAgIHJldHVybiB0aGlzLnNlcmllc1R5cGVzLmZpbHRlcigodCkgPT4gdGhpcy5pc0NhcnRlc2lhbih0KSk7XG4gIH1cbiAgZ2V0IHBvbGFyVHlwZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VyaWVzVHlwZXMuZmlsdGVyKCh0KSA9PiB0aGlzLmlzUG9sYXIodCkpO1xuICB9XG4gIGdldCBoaWVyYXJjaHlUeXBlcygpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJpZXNUeXBlcy5maWx0ZXIoKHQpID0+IHRoaXMuaXNIaWVyYXJjaHkodCkpO1xuICB9XG4gIGdldCB0b3BvbG9neVR5cGVzKCkge1xuICAgIHJldHVybiB0aGlzLnNlcmllc1R5cGVzLmZpbHRlcigodCkgPT4gdGhpcy5pc1RvcG9sb2d5KHQpKTtcbiAgfVxuICBnZXQgZmxvd1Byb3BvcnRpb25UeXBlcygpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJpZXNUeXBlcy5maWx0ZXIoKHQpID0+IHRoaXMuaXNGbG93UHJvcG9ydGlvbih0KSk7XG4gIH1cbiAgZ2V0IHN0YW5kYWxvbmVUeXBlcygpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJpZXNUeXBlcy5maWx0ZXIoKHQpID0+IHRoaXMuaXNTdGFuZGFsb25lKHQpKTtcbiAgfVxuICBnZXQgZ2F1Z2VUeXBlcygpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJpZXNUeXBlcy5maWx0ZXIoKHQpID0+IHRoaXMuaXNHYXVnZSh0KSk7XG4gIH1cbn07XG52YXIgQ2hhcnREZWZhdWx0cyA9IGNsYXNzIGV4dGVuZHMgTWFwIHtcbiAgc2V0KGNoYXJ0VHlwZTIsIGRlZmF1bHRzKSB7XG4gICAgcmV0dXJuIHN1cGVyLnNldChjaGFydFR5cGUyLCBtZXJnZURlZmF1bHRzKGRlZmF1bHRzLCB0aGlzLmdldChjaGFydFR5cGUyKSkpO1xuICB9XG59O1xudmFyIGNoYXJ0VHlwZXMgPSBuZXcgQ2hhcnRUeXBlcygpO1xudmFyIHB1YmxpY0NoYXJ0VHlwZXMgPSBuZXcgQ2hhcnRUeXBlcygpO1xudmFyIGNoYXJ0RGVmYXVsdHMgPSBuZXcgQ2hhcnREZWZhdWx0cygpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9mYWN0b3J5L3Nlcmllc1JlZ2lzdHJ5LnRzXG52YXIgU2VyaWVzUmVnaXN0cnkgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc2VyaWVzTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLnRoZW1lVGVtcGxhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICByZWdpc3RlcihzZXJpZXNUeXBlMiwge1xuICAgIGNoYXJ0VHlwZXM6IFtjaGFydFR5cGUyXSxcbiAgICBtb2R1bGVGYWN0b3J5LFxuICAgIHRvb2x0aXBEZWZhdWx0cyxcbiAgICBkZWZhdWx0QXhlcyxcbiAgICB0aGVtZVRlbXBsYXRlLFxuICAgIHBhbGV0dGVGYWN0b3J5LFxuICAgIHNvbG8sXG4gICAgc3RhY2thYmxlLFxuICAgIGdyb3VwYWJsZSxcbiAgICBzdGFja2VkQnlEZWZhdWx0LFxuICAgIGhpZGRlblxuICB9KSB7XG4gICAgdGhpcy5zZXRUaGVtZVRlbXBsYXRlKHNlcmllc1R5cGUyLCB0aGVtZVRlbXBsYXRlKTtcbiAgICB0aGlzLnNlcmllc01hcC5zZXQoc2VyaWVzVHlwZTIsIHtcbiAgICAgIG1vZHVsZUZhY3RvcnksXG4gICAgICB0b29sdGlwRGVmYXVsdHMsXG4gICAgICBkZWZhdWx0QXhlcyxcbiAgICAgIHBhbGV0dGVGYWN0b3J5LFxuICAgICAgc29sbyxcbiAgICAgIHN0YWNrYWJsZSxcbiAgICAgIGdyb3VwYWJsZSxcbiAgICAgIHN0YWNrZWRCeURlZmF1bHRcbiAgICB9KTtcbiAgICBjaGFydFR5cGVzLnNldChzZXJpZXNUeXBlMiwgY2hhcnRUeXBlMik7XG4gICAgaWYgKCFoaWRkZW4pIHtcbiAgICAgIHB1YmxpY0NoYXJ0VHlwZXMuc2V0KHNlcmllc1R5cGUyLCBjaGFydFR5cGUyKTtcbiAgICB9XG4gIH1cbiAgY3JlYXRlKHNlcmllc1R5cGUyLCBtb2R1bGVDb250ZXh0KSB7XG4gICAgY29uc3Qgc2VyaWVzRmFjdG9yeSA9IHRoaXMuc2VyaWVzTWFwLmdldChzZXJpZXNUeXBlMik/Lm1vZHVsZUZhY3Rvcnk7XG4gICAgaWYgKHNlcmllc0ZhY3RvcnkpIHtcbiAgICAgIHJldHVybiBzZXJpZXNGYWN0b3J5KG1vZHVsZUNvbnRleHQpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYEFHIENoYXJ0cyAtIHVua25vd24gc2VyaWVzIHR5cGU6ICR7c2VyaWVzVHlwZTJ9YCk7XG4gIH1cbiAgY2xvbmVEZWZhdWx0QXhlcyhzZXJpZXNUeXBlMiwgb3B0aW9ucykge1xuICAgIGNvbnN0IGRlZmF1bHRBeGVzID0gdGhpcy5zZXJpZXNNYXAuZ2V0KHNlcmllc1R5cGUyKT8uZGVmYXVsdEF4ZXM7XG4gICAgaWYgKGRlZmF1bHRBeGVzID09IG51bGwpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBheGVzID0gdHlwZW9mIGRlZmF1bHRBeGVzID09PSBcImZ1bmN0aW9uXCIgPyBkZWZhdWx0QXhlcyhvcHRpb25zKSA6IGRlZmF1bHRBeGVzO1xuICAgIHJldHVybiB7IGF4ZXM6IGRlZXBDbG9uZShheGVzKSB9O1xuICB9XG4gIHNldFRoZW1lVGVtcGxhdGUoc2VyaWVzVHlwZTIsIHRoZW1lVGVtcGxhdGUpIHtcbiAgICBjb25zdCBjdXJyZW50VGVtcGxhdGUgPSB0aGlzLnRoZW1lVGVtcGxhdGVzLmdldChzZXJpZXNUeXBlMik7XG4gICAgdGhpcy50aGVtZVRlbXBsYXRlcy5zZXQoc2VyaWVzVHlwZTIsIG1lcmdlRGVmYXVsdHModGhlbWVUZW1wbGF0ZSwgY3VycmVudFRlbXBsYXRlKSk7XG4gIH1cbiAgZ2V0VGhlbWVUZW1wbGF0ZShzZXJpZXNUeXBlMikge1xuICAgIHJldHVybiB0aGlzLnRoZW1lVGVtcGxhdGVzLmdldChzZXJpZXNUeXBlMik7XG4gIH1cbiAgZ2V0UGFsZXR0ZUZhY3Rvcnkoc2VyaWVzVHlwZTIpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJpZXNNYXAuZ2V0KHNlcmllc1R5cGUyKT8ucGFsZXR0ZUZhY3Rvcnk7XG4gIH1cbiAgZ2V0VG9vbHRpcERlZmF1bHMoc2VyaWVzVHlwZTIpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJpZXNNYXAuZ2V0KHNlcmllc1R5cGUyKT8udG9vbHRpcERlZmF1bHRzO1xuICB9XG4gIGlzU29sbyhzZXJpZXNUeXBlMikge1xuICAgIHJldHVybiB0aGlzLnNlcmllc01hcC5nZXQoc2VyaWVzVHlwZTIpPy5zb2xvID8/IGZhbHNlO1xuICB9XG4gIGlzR3JvdXBhYmxlKHNlcmllc1R5cGUyKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VyaWVzTWFwLmdldChzZXJpZXNUeXBlMik/Lmdyb3VwYWJsZSA/PyBmYWxzZTtcbiAgfVxuICBpc1N0YWNrYWJsZShzZXJpZXNUeXBlMikge1xuICAgIHJldHVybiB0aGlzLnNlcmllc01hcC5nZXQoc2VyaWVzVHlwZTIpPy5zdGFja2FibGUgPz8gZmFsc2U7XG4gIH1cbiAgaXNTdGFja2VkQnlEZWZhdWx0KHNlcmllc1R5cGUyKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VyaWVzTWFwLmdldChzZXJpZXNUeXBlMik/LnN0YWNrZWRCeURlZmF1bHQgPz8gZmFsc2U7XG4gIH1cbn07XG52YXIgc2VyaWVzUmVnaXN0cnkgPSBuZXcgU2VyaWVzUmVnaXN0cnkoKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvaW50ZXJhY3Rpb24vc3luY01hbmFnZXIudHNcbnZhciBfU3luY01hbmFnZXIgPSBjbGFzcyBfU3luY01hbmFnZXIgZXh0ZW5kcyBCYXNlTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGNoYXJ0KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmNoYXJ0ID0gY2hhcnQ7XG4gIH1cbiAgc3Vic2NyaWJlKGdyb3VwSWQgPSBfU3luY01hbmFnZXIuREVGQVVMVF9HUk9VUCkge1xuICAgIGxldCBzeW5jR3JvdXAgPSB0aGlzLmdldChncm91cElkKTtcbiAgICBpZiAoIXN5bmNHcm91cCkge1xuICAgICAgc3luY0dyb3VwID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgIF9TeW5jTWFuYWdlci5jaGFydHNHcm91cHMuc2V0KGdyb3VwSWQsIHN5bmNHcm91cCk7XG4gICAgfVxuICAgIHN5bmNHcm91cC5hZGQodGhpcy5jaGFydCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdW5zdWJzY3JpYmUoZ3JvdXBJZCA9IF9TeW5jTWFuYWdlci5ERUZBVUxUX0dST1VQKSB7XG4gICAgdGhpcy5nZXQoZ3JvdXBJZCk/LmRlbGV0ZSh0aGlzLmNoYXJ0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBnZXRDaGFydCgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFydDtcbiAgfVxuICBnZXRHcm91cChncm91cElkID0gX1N5bmNNYW5hZ2VyLkRFRkFVTFRfR1JPVVApIHtcbiAgICBjb25zdCBzeW5jR3JvdXAgPSB0aGlzLmdldChncm91cElkKTtcbiAgICByZXR1cm4gc3luY0dyb3VwID8gQXJyYXkuZnJvbShzeW5jR3JvdXApIDogW107XG4gIH1cbiAgZ2V0R3JvdXBTaWJsaW5ncyhncm91cElkID0gX1N5bmNNYW5hZ2VyLkRFRkFVTFRfR1JPVVApIHtcbiAgICByZXR1cm4gdGhpcy5nZXRHcm91cChncm91cElkKS5maWx0ZXIoKGNoYXJ0KSA9PiBjaGFydCAhPT0gdGhpcy5jaGFydCk7XG4gIH1cbiAgZ2V0KGdyb3VwSWQpIHtcbiAgICByZXR1cm4gX1N5bmNNYW5hZ2VyLmNoYXJ0c0dyb3Vwcy5nZXQoZ3JvdXBJZCk7XG4gIH1cbn07XG5fU3luY01hbmFnZXIuY2hhcnRzR3JvdXBzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbl9TeW5jTWFuYWdlci5ERUZBVUxUX0dST1VQID0gU3ltYm9sKFwic3luYy1ncm91cC1kZWZhdWx0XCIpO1xudmFyIFN5bmNNYW5hZ2VyID0gX1N5bmNNYW5hZ2VyO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9rZXlib2FyZC50c1xudmFyIEtleWJvYXJkID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgS2V5Ym9hcmQucHJvdG90eXBlLCBcImVuYWJsZWRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShOVU1CRVIpXG5dLCBLZXlib2FyZC5wcm90b3R5cGUsIFwidGFiSW5kZXhcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L21hcHBpbmcvcHJlcGFyZUF4aXMudHNcbnZhciBDYXJ0ZXNpYW5BeGlzUG9zaXRpb25zID0gW1widG9wXCIsIFwicmlnaHRcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCJdO1xuZnVuY3Rpb24gaXNBeGlzUG9zaXRpb24ocG9zaXRpb24pIHtcbiAgcmV0dXJuIHR5cGVvZiBwb3NpdGlvbiA9PT0gXCJzdHJpbmdcIiAmJiBDYXJ0ZXNpYW5BeGlzUG9zaXRpb25zLmluY2x1ZGVzKHBvc2l0aW9uKTtcbn1cbmZ1bmN0aW9uIGd1ZXNzSW52YWxpZFBvc2l0aW9ucyhheGVzKSB7XG4gIGNvbnN0IGludmFsaWRBeGVzID0gW107XG4gIGNvbnN0IHVzZWRQb3NpdGlvbnMgPSBbXTtcbiAgY29uc3QgZ3Vlc3NlcyA9IFsuLi5DYXJ0ZXNpYW5BeGlzUG9zaXRpb25zXTtcbiAgZm9yIChjb25zdCBheGlzIG9mIGF4ZXMpIHtcbiAgICBpZiAoYXhpcyBpbnN0YW5jZW9mIENhcnRlc2lhbkF4aXMpIHtcbiAgICAgIGlmIChpc0F4aXNQb3NpdGlvbihheGlzLnBvc2l0aW9uKSkge1xuICAgICAgICB1c2VkUG9zaXRpb25zLnB1c2goYXhpcy5wb3NpdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnZhbGlkQXhlcy5wdXNoKGF4aXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IGF4aXMgb2YgaW52YWxpZEF4ZXMpIHtcbiAgICBsZXQgbmV4dEd1ZXNzO1xuICAgIGRvIHtcbiAgICAgIG5leHRHdWVzcyA9IGd1ZXNzZXMucG9wKCk7XG4gICAgfSB3aGlsZSAobmV4dEd1ZXNzICYmIHVzZWRQb3NpdGlvbnMuaW5jbHVkZXMobmV4dEd1ZXNzKSk7XG4gICAgaWYgKG5leHRHdWVzcyA9PSBudWxsKVxuICAgICAgYnJlYWs7XG4gICAgYXhpcy5wb3NpdGlvbiA9IG5leHRHdWVzcztcbiAgfVxufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9tYXBwaW5nL3ByZXBhcmVTZXJpZXMudHNcbnZhciBNQVRDSElOR19LRVlTID0gW1wiZGlyZWN0aW9uXCIsIFwieEtleVwiLCBcInlLZXlcIiwgXCJzaXplS2V5XCIsIFwiYW5nbGVLZXlcIiwgXCJyYWRpdXNLZXlcIiwgXCJub3JtYWxpemVkVG9cIl07XG5mdW5jdGlvbiBtYXRjaFNlcmllc09wdGlvbnMoc2VyaWVzLCBvcHRTZXJpZXMsIG9sZE9wdHNTZXJpZXMpIHtcbiAgY29uc3QgZ2VuZXJhdGVLZXkgPSAodHlwZSwgaSwgb3B0cykgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IFt0eXBlXTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBNQVRDSElOR19LRVlTKSB7XG4gICAgICBpZiAoa2V5IGluIGkgJiYgaVtrZXldICE9IG51bGwpXG4gICAgICAgIHJlc3VsdC5wdXNoKGAke2tleX09JHtpW2tleV19YCk7XG4gICAgfVxuICAgIGlmIChvcHRzPy5zZXJpZXNHcm91cGluZykge1xuICAgICAgcmVzdWx0LnB1c2goYHNlcmllc0dyb3VwaW5nLmdyb3VwSWQ9JHtvcHRzPy5zZXJpZXNHcm91cGluZy5ncm91cElkfWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LmpvaW4oXCI7XCIpO1xuICB9O1xuICBjb25zdCBzZXJpZXNNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBsZXQgaWR4ID0gMDtcbiAgZm9yIChjb25zdCBzIG9mIHNlcmllcykge1xuICAgIGNvbnN0IGtleSA9IGdlbmVyYXRlS2V5KHMudHlwZSwgcy5wcm9wZXJ0aWVzLCBvbGRPcHRzU2VyaWVzPy5baWR4XSk7XG4gICAgaWYgKCFzZXJpZXNNYXAuaGFzKGtleSkpIHtcbiAgICAgIHNlcmllc01hcC5zZXQoa2V5LCBbXSk7XG4gICAgfVxuICAgIHNlcmllc01hcC5nZXQoa2V5KT8ucHVzaChbcywgaWR4KytdKTtcbiAgfVxuICBjb25zdCBvcHRzTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgZm9yIChjb25zdCBvIG9mIG9wdFNlcmllcykge1xuICAgIGNvbnN0IGtleSA9IGdlbmVyYXRlS2V5KG8udHlwZSwgbywgbyk7XG4gICAgaWYgKCFvcHRzTWFwLmhhcyhrZXkpKSB7XG4gICAgICBvcHRzTWFwLnNldChrZXksIFtdKTtcbiAgICB9XG4gICAgb3B0c01hcC5nZXQoa2V5KT8ucHVzaChvKTtcbiAgfVxuICBjb25zdCBvdmVybGFwID0gWy4uLnNlcmllc01hcC5rZXlzKCldLnNvbWUoKGspID0+IG9wdHNNYXAuaGFzKGspKTtcbiAgaWYgKCFvdmVybGFwKSB7XG4gICAgcmV0dXJuIHsgc3RhdHVzOiBcIm5vLW92ZXJsYXBcIiwgb2xkS2V5czogc2VyaWVzTWFwLmtleXMoKSwgbmV3S2V5czogb3B0c01hcC5rZXlzKCkgfTtcbiAgfVxuICBjb25zdCBjaGFuZ2VzID0gW107XG4gIGxldCB0YXJnZXRJZHggPSAtMTtcbiAgZm9yIChjb25zdCBba2V5LCBvcHRBcnJheV0gb2Ygb3B0c01hcC5lbnRyaWVzKCkpIHtcbiAgICBmb3IgKGNvbnN0IG9wdHMgb2Ygb3B0QXJyYXkpIHtcbiAgICAgIHRhcmdldElkeCsrO1xuICAgICAgY29uc3Qgc2VyaWVzQXJyYXkgPSBzZXJpZXNNYXAuZ2V0KGtleSk7XG4gICAgICBpZiAoc2VyaWVzQXJyYXkgPT0gbnVsbCB8fCBzZXJpZXNBcnJheS5sZW5ndGggPCAxKSB7XG4gICAgICAgIGNoYW5nZXMucHVzaCh7IG9wdHMsIGlkeDogdGFyZ2V0SWR4LCBzdGF0dXM6IFwiYWRkXCIgfSk7XG4gICAgICAgIHNlcmllc01hcC5kZWxldGUoa2V5KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBbb3V0cHV0U2VyaWVzLCBvdXRwdXRJZHhdID0gc2VyaWVzQXJyYXkuc2hpZnQoKTtcbiAgICAgIGNvbnN0IHByZXZpb3VzT3B0cyA9IG9sZE9wdHNTZXJpZXM/LltvdXRwdXRJZHhdID8/IHt9O1xuICAgICAgY29uc3QgZGlmZjIgPSBqc29uRGlmZihwcmV2aW91c09wdHMsIG9wdHMgPz8ge30pO1xuICAgICAgY29uc3QgeyBncm91cEluZGV4LCBzdGFja0luZGV4IH0gPSBkaWZmMj8uc2VyaWVzR3JvdXBpbmcgPz8ge307XG4gICAgICBpZiAoZ3JvdXBJbmRleCAhPSBudWxsIHx8IHN0YWNrSW5kZXggIT0gbnVsbCkge1xuICAgICAgICBjaGFuZ2VzLnB1c2goeyBvcHRzLCBzZXJpZXM6IG91dHB1dFNlcmllcywgZGlmZjogZGlmZjIsIGlkeDogb3V0cHV0SWR4LCBzdGF0dXM6IFwic2VyaWVzLWdyb3VwaW5nXCIgfSk7XG4gICAgICB9IGVsc2UgaWYgKGRpZmYyKSB7XG4gICAgICAgIGNoYW5nZXMucHVzaCh7IG9wdHMsIHNlcmllczogb3V0cHV0U2VyaWVzLCBkaWZmOiBkaWZmMiwgaWR4OiBvdXRwdXRJZHgsIHN0YXR1czogXCJ1cGRhdGVcIiB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoYW5nZXMucHVzaCh7IG9wdHMsIHNlcmllczogb3V0cHV0U2VyaWVzLCBpZHg6IG91dHB1dElkeCwgc3RhdHVzOiBcIm5vLW9wXCIgfSk7XG4gICAgICB9XG4gICAgICBpZiAoc2VyaWVzQXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHNlcmllc01hcC5kZWxldGUoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBzZXJpZXNBcnJheSBvZiBzZXJpZXNNYXAudmFsdWVzKCkpIHtcbiAgICBmb3IgKGNvbnN0IFtvdXRwdXRTZXJpZXMsIG91dHB1dElkeF0gb2Ygc2VyaWVzQXJyYXkpIHtcbiAgICAgIGNoYW5nZXMucHVzaCh7IHNlcmllczogb3V0cHV0U2VyaWVzLCBpZHg6IG91dHB1dElkeCwgc3RhdHVzOiBcInJlbW92ZVwiIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4geyBzdGF0dXM6IFwib3ZlcmxhcFwiLCBjaGFuZ2VzIH07XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L21hcHBpbmcvdHlwZXMudHNcbmZ1bmN0aW9uIG9wdGlvbnNUeXBlKGlucHV0KSB7XG4gIGNvbnN0IHsgc2VyaWVzIH0gPSBpbnB1dDtcbiAgaWYgKCFzZXJpZXMpXG4gICAgcmV0dXJuO1xuICByZXR1cm4gc2VyaWVzWzBdPy50eXBlID8/IFwibGluZVwiO1xufVxuZnVuY3Rpb24gaXNBZ0NhcnRlc2lhbkNoYXJ0T3B0aW9ucyhpbnB1dCkge1xuICBjb25zdCBzcGVjaWZpZWRUeXBlID0gb3B0aW9uc1R5cGUoaW5wdXQpO1xuICBpZiAoc3BlY2lmaWVkVHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBjaGFydFR5cGVzLmlzQ2FydGVzaWFuKHNwZWNpZmllZFR5cGUpIHx8IGlzRW50ZXJwcmlzZUNhcnRlc2lhbihzcGVjaWZpZWRUeXBlKTtcbn1cbmZ1bmN0aW9uIGlzQWdQb2xhckNoYXJ0T3B0aW9ucyhpbnB1dCkge1xuICBjb25zdCBzcGVjaWZpZWRUeXBlID0gb3B0aW9uc1R5cGUoaW5wdXQpO1xuICBpZiAoc3BlY2lmaWVkVHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChzcGVjaWZpZWRUeXBlID09PSBcInBvbGFyXCIpIHtcbiAgICBMb2dnZXIud2Fybk9uY2UoYHR5cGUgJyR7c3BlY2lmaWVkVHlwZX0nIGlzIGRlcHJlY2F0ZWQsIHVzZSBhIHNlcmllcyB0eXBlIGluc3RlYWRgKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gY2hhcnRUeXBlcy5pc1BvbGFyKHNwZWNpZmllZFR5cGUpIHx8IGlzRW50ZXJwcmlzZVBvbGFyKHNwZWNpZmllZFR5cGUpO1xufVxuZnVuY3Rpb24gaXNBZ0hpZXJhcmNoeUNoYXJ0T3B0aW9ucyhpbnB1dCkge1xuICBjb25zdCBzcGVjaWZpZWRUeXBlID0gb3B0aW9uc1R5cGUoaW5wdXQpO1xuICBpZiAoc3BlY2lmaWVkVHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChzcGVjaWZpZWRUeXBlID09PSBcImhpZXJhcmNoeVwiKSB7XG4gICAgTG9nZ2VyLndhcm5PbmNlKGB0eXBlICcke3NwZWNpZmllZFR5cGV9JyBpcyBkZXByZWNhdGVkLCB1c2UgYSBzZXJpZXMgdHlwZSBpbnN0ZWFkYCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGNoYXJ0VHlwZXMuaXNIaWVyYXJjaHkoc3BlY2lmaWVkVHlwZSkgfHwgaXNFbnRlcnByaXNlSGllcmFyY2h5KHNwZWNpZmllZFR5cGUpO1xufVxuZnVuY3Rpb24gaXNBZ1RvcG9sb2d5Q2hhcnRPcHRpb25zKGlucHV0KSB7XG4gIGNvbnN0IHNwZWNpZmllZFR5cGUgPSBvcHRpb25zVHlwZShpbnB1dCk7XG4gIGlmIChzcGVjaWZpZWRUeXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHNwZWNpZmllZFR5cGUgPT09IFwidG9wb2xvZ3lcIikge1xuICAgIExvZ2dlci53YXJuT25jZShgdHlwZSAnJHtzcGVjaWZpZWRUeXBlfScgaXMgZGVwcmVjYXRlZCwgdXNlIGEgc2VyaWVzIHR5cGUgaW5zdGVhZGApO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBjaGFydFR5cGVzLmlzVG9wb2xvZ3koc3BlY2lmaWVkVHlwZSkgfHwgaXNFbnRlcnByaXNlVG9wb2xvZ3koc3BlY2lmaWVkVHlwZSk7XG59XG5mdW5jdGlvbiBpc0FnRmxvd1Byb3BvcnRpb25DaGFydE9wdGlvbnMoaW5wdXQpIHtcbiAgY29uc3Qgc3BlY2lmaWVkVHlwZSA9IG9wdGlvbnNUeXBlKGlucHV0KTtcbiAgaWYgKHNwZWNpZmllZFR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoc3BlY2lmaWVkVHlwZSA9PT0gXCJmbG93LXByb3BvcnRpb25cIikge1xuICAgIExvZ2dlci53YXJuT25jZShgdHlwZSAnJHtzcGVjaWZpZWRUeXBlfScgaXMgZGVwcmVjYXRlZCwgdXNlIGEgc2VyaWVzIHR5cGUgaW5zdGVhZGApO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBjaGFydFR5cGVzLmlzRmxvd1Byb3BvcnRpb24oc3BlY2lmaWVkVHlwZSkgfHwgaXNFbnRlcnByaXNlRmxvd1Byb3BvcnRpb24oc3BlY2lmaWVkVHlwZSk7XG59XG5mdW5jdGlvbiBpc0FnU3RhbmRhbG9uZUNoYXJ0T3B0aW9ucyhpbnB1dCkge1xuICBjb25zdCBzcGVjaWZpZWRUeXBlID0gb3B0aW9uc1R5cGUoaW5wdXQpO1xuICBpZiAoc3BlY2lmaWVkVHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChzcGVjaWZpZWRUeXBlID09PSBcInN0YW5kYWxvbmVcIikge1xuICAgIExvZ2dlci53YXJuT25jZShgdHlwZSAnJHtzcGVjaWZpZWRUeXBlfScgaXMgZGVwcmVjYXRlZCwgdXNlIGEgc2VyaWVzIHR5cGUgaW5zdGVhZGApO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBjaGFydFR5cGVzLmlzU3RhbmRhbG9uZShzcGVjaWZpZWRUeXBlKSB8fCBpc0VudGVycHJpc2VTdGFuZGFsb25lKHNwZWNpZmllZFR5cGUpO1xufVxuZnVuY3Rpb24gaXNBZ0dhdWdlQ2hhcnRPcHRpb25zKGlucHV0KSB7XG4gIGNvbnN0IHNwZWNpZmllZFR5cGUgPSBvcHRpb25zVHlwZShpbnB1dCk7XG4gIGlmIChzcGVjaWZpZWRUeXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHNwZWNpZmllZFR5cGUgPT09IFwiZ2F1Z2VcIikge1xuICAgIExvZ2dlci53YXJuT25jZShgdHlwZSAnJHtzcGVjaWZpZWRUeXBlfScgaXMgZGVwcmVjYXRlZCwgdXNlIGEgc2VyaWVzIHR5cGUgaW5zdGVhZGApO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBjaGFydFR5cGVzLmlzR2F1Z2Uoc3BlY2lmaWVkVHlwZSkgfHwgaXNFbnRlcnByaXNlR2F1Z2Uoc3BlY2lmaWVkVHlwZSk7XG59XG5mdW5jdGlvbiBpc0FnUG9sYXJDaGFydE9wdGlvbnNXaXRoU2VyaWVzQmFzZWRMZWdlbmQoaW5wdXQpIHtcbiAgY29uc3Qgc3BlY2lmaWVkVHlwZSA9IG9wdGlvbnNUeXBlKGlucHV0KTtcbiAgcmV0dXJuIGlzQWdQb2xhckNoYXJ0T3B0aW9ucyhpbnB1dCkgJiYgc3BlY2lmaWVkVHlwZSAhPT0gXCJwaWVcIiAmJiBzcGVjaWZpZWRUeXBlICE9PSBcImRvbnV0XCI7XG59XG5mdW5jdGlvbiBpc1Nlcmllc09wdGlvblR5cGUoaW5wdXQpIHtcbiAgaWYgKGlucHV0ID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGNoYXJ0VHlwZXMuaGFzKGlucHV0KTtcbn1cbmZ1bmN0aW9uIGlzQXhpc09wdGlvblR5cGUoaW5wdXQpIHtcbiAgaWYgKGlucHV0ID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGF4aXNSZWdpc3RyeS5oYXMoaW5wdXQpO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9tb2R1bGVzTWFuYWdlci50c1xudmFyIE1vZHVsZXNNYW5hZ2VyID0gY2xhc3MgZXh0ZW5kcyBNb2R1bGVNYXAge1xuICBhcHBseU9wdGlvbnMob3B0aW9ucykge1xuICAgIGZvciAoY29uc3QgbSBvZiB0aGlzLm1vZHVsZU1hcC52YWx1ZXMoKSkge1xuICAgICAgaWYgKG0ubW9kdWxlLm9wdGlvbnNLZXkgaW4gb3B0aW9ucyAmJiBpc1Byb3BlcnRpZXMobS5tb2R1bGVJbnN0YW5jZSkpIHtcbiAgICAgICAgbS5tb2R1bGVJbnN0YW5jZS5zZXQob3B0aW9uc1ttLm1vZHVsZS5vcHRpb25zS2V5XSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gICpsZWdlbmRzKCkge1xuICAgIGZvciAoY29uc3QgeyBtb2R1bGUsIG1vZHVsZUluc3RhbmNlIH0gb2YgdGhpcy5tb2R1bGVNYXAudmFsdWVzKCkpIHtcbiAgICAgIGlmIChtb2R1bGUudHlwZSAhPT0gXCJsZWdlbmRcIilcbiAgICAgICAgY29udGludWU7XG4gICAgICB5aWVsZCB7XG4gICAgICAgIGxlZ2VuZFR5cGU6IG1vZHVsZS5pZGVudGlmaWVyLFxuICAgICAgICBsZWdlbmQ6IG1vZHVsZUluc3RhbmNlXG4gICAgICB9O1xuICAgIH1cbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvb3ZlcmxheS9vdmVybGF5LnRzXG52YXIgREVGQVVMVF9PVkVSTEFZX0NMQVNTID0gXCJhZy1jaGFydC1vdmVybGF5XCI7XG52YXIgREVGQVVMVF9PVkVSTEFZX0RBUktfQ0xBU1MgPSBcImFnLWNoYXJ0LWRhcmstb3ZlcmxheVwiO1xudmFyIE92ZXJsYXkgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoY2xhc3NOYW1lLCBkZWZhdWx0TWVzc2FnZUlkKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICB0aGlzLmRlZmF1bHRNZXNzYWdlSWQgPSBkZWZhdWx0TWVzc2FnZUlkO1xuICB9XG4gIGdldFRleHQobG9jYWxlTWFuYWdlcikge1xuICAgIHJldHVybiBsb2NhbGVNYW5hZ2VyLnQodGhpcy50ZXh0ID8/IHRoaXMuZGVmYXVsdE1lc3NhZ2VJZCk7XG4gIH1cbiAgZ2V0RWxlbWVudChhbmltYXRpb25NYW5hZ2VyLCBsb2NhbGVNYW5hZ2VyLCByZWN0KSB7XG4gICAgdGhpcy5jb250ZW50Py5yZW1vdmUoKTtcbiAgICB0aGlzLmZvY3VzQm94ID0gcmVjdDtcbiAgICBpZiAodGhpcy5yZW5kZXJlcikge1xuICAgICAgY29uc3QgaHRtbENvbnRlbnQgPSB0aGlzLnJlbmRlcmVyKCk7XG4gICAgICBpZiAoaHRtbENvbnRlbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBodG1sQ29udGVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHRlbXBEaXYgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0ZW1wRGl2LmlubmVySFRNTCA9IGh0bWxDb250ZW50O1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSB0ZW1wRGl2LmZpcnN0RWxlbWVudENoaWxkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgICAgICBhbGlnbkl0ZW1zOiBcImNlbnRlclwiLFxuICAgICAgICBqdXN0aWZ5Q29udGVudDogXCJjZW50ZXJcIixcbiAgICAgICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcbiAgICAgICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICAgICAgbWFyZ2luOiBcIjhweFwiLFxuICAgICAgICBmb250OiBcIjEycHggVmVyZGFuYSwgc2Fucy1zZXJpZlwiXG4gICAgICB9KTtcbiAgICAgIGNvbnRlbnQuaW5uZXJUZXh0ID0gdGhpcy5nZXRUZXh0KGxvY2FsZU1hbmFnZXIpO1xuICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICAgIGFuaW1hdGlvbk1hbmFnZXI/LmFuaW1hdGUoe1xuICAgICAgICBmcm9tOiAwLFxuICAgICAgICB0bzogMSxcbiAgICAgICAgaWQ6IFwib3ZlcmxheVwiLFxuICAgICAgICBwaGFzZTogXCJhZGRcIixcbiAgICAgICAgZ3JvdXBJZDogXCJvcGFjaXR5XCIsXG4gICAgICAgIG9uVXBkYXRlKHZhbHVlKSB7XG4gICAgICAgICAgY29udGVudC5zdHlsZS5vcGFjaXR5ID0gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25TdG9wKCkge1xuICAgICAgICAgIGNvbnRlbnQuc3R5bGUub3BhY2l0eSA9IFwiMVwiO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGVudDtcbiAgfVxuICByZW1vdmVFbGVtZW50KGNsZWFudXAgPSAoKSA9PiB0aGlzLmNvbnRlbnQ/LnJlbW92ZSgpLCBhbmltYXRpb25NYW5hZ2VyKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnQpXG4gICAgICByZXR1cm47XG4gICAgaWYgKGFuaW1hdGlvbk1hbmFnZXIpIHtcbiAgICAgIGNvbnN0IHsgY29udGVudCB9ID0gdGhpcztcbiAgICAgIGFuaW1hdGlvbk1hbmFnZXIuYW5pbWF0ZSh7XG4gICAgICAgIGZyb206IDEsXG4gICAgICAgIHRvOiAwLFxuICAgICAgICBwaGFzZTogXCJyZW1vdmVcIixcbiAgICAgICAgaWQ6IFwib3ZlcmxheVwiLFxuICAgICAgICBncm91cElkOiBcIm9wYWNpdHlcIixcbiAgICAgICAgb25VcGRhdGUodmFsdWUpIHtcbiAgICAgICAgICBjb250ZW50LnN0eWxlLm9wYWNpdHkgPSBTdHJpbmcodmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBvblN0b3AoKSB7XG4gICAgICAgICAgY2xlYW51cD8uKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGVhbnVwPy4oKTtcbiAgICB9XG4gICAgdGhpcy5jb250ZW50ID0gdm9pZCAwO1xuICAgIHRoaXMuZm9jdXNCb3ggPSB2b2lkIDA7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIE92ZXJsYXkucHJvdG90eXBlLCBcInRleHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGVU5DVElPTiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgT3ZlcmxheS5wcm90b3R5cGUsIFwicmVuZGVyZXJcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L292ZXJsYXkvY2hhcnRPdmVybGF5cy50c1xudmFyIENoYXJ0T3ZlcmxheXMgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmRhcmtUaGVtZSA9IGZhbHNlO1xuICAgIHRoaXMubG9hZGluZyA9IG5ldyBPdmVybGF5KFwiYWctY2hhcnQtbG9hZGluZy1vdmVybGF5XCIsIFwib3ZlcmxheUxvYWRpbmdEYXRhXCIpO1xuICAgIHRoaXMubm9EYXRhID0gbmV3IE92ZXJsYXkoXCJhZy1jaGFydC1uby1kYXRhLW92ZXJsYXlcIiwgXCJvdmVybGF5Tm9EYXRhXCIpO1xuICAgIHRoaXMubm9WaXNpYmxlU2VyaWVzID0gbmV3IE92ZXJsYXkoXCJhZy1jaGFydC1uby12aXNpYmxlLXNlcmllc1wiLCBcIm92ZXJsYXlOb1Zpc2libGVTZXJpZXNcIik7XG4gIH1cbiAgZ2V0Rm9jdXNJbmZvKGxvY2FsZU1hbmFnZXIpIHtcbiAgICBmb3IgKGNvbnN0IG92ZXJsYXkgb2YgW3RoaXMubG9hZGluZywgdGhpcy5ub0RhdGEsIHRoaXMubm9WaXNpYmxlU2VyaWVzXSkge1xuICAgICAgaWYgKG92ZXJsYXkuZm9jdXNCb3ggIT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4geyB0ZXh0OiBvdmVybGF5LmdldFRleHQobG9jYWxlTWFuYWdlciksIHJlY3Q6IG92ZXJsYXkuZm9jdXNCb3ggfTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMubG9hZGluZy5yZW1vdmVFbGVtZW50KCk7XG4gICAgdGhpcy5ub0RhdGEucmVtb3ZlRWxlbWVudCgpO1xuICAgIHRoaXMubm9WaXNpYmxlU2VyaWVzLnJlbW92ZUVsZW1lbnQoKTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBDaGFydE92ZXJsYXlzLnByb3RvdHlwZSwgXCJkYXJrVGhlbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBDaGFydE92ZXJsYXlzLnByb3RvdHlwZSwgXCJsb2FkaW5nXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgQ2hhcnRPdmVybGF5cy5wcm90b3R5cGUsIFwibm9EYXRhXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgQ2hhcnRPdmVybGF5cy5wcm90b3R5cGUsIFwibm9WaXNpYmxlU2VyaWVzXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9vdmVybGF5L2xvYWRpbmdTcGlubmVyLnRzXG5mdW5jdGlvbiBnZXRMb2FkaW5nU3Bpbm5lcih0ZXh0LCBkZWZhdWx0RHVyYXRpb24pIHtcbiAgY29uc3QgeyBhbmltYXRpb25EdXJhdGlvbiB9ID0gUEhBU0VfTUVUQURBVEFbXCJhZGRcIl07XG4gIGNvbnN0IGR1cmF0aW9uID0gYW5pbWF0aW9uRHVyYXRpb24gKiBkZWZhdWx0RHVyYXRpb247XG4gIGNvbnN0IGNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgYCR7REVGQVVMVF9PVkVSTEFZX0NMQVNTfS0tbG9hZGluZ2AsIHtcbiAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICBhbGlnbkl0ZW1zOiBcImNlbnRlclwiLFxuICAgIGp1c3RpZnlDb250ZW50OiBcImNlbnRlclwiLFxuICAgIGZsZXhEaXJlY3Rpb246IFwiY29sdW1uXCIsXG4gICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgIGZvbnQ6IFwiMTNweCBWZXJkYW5hLCBzYW5zLXNlcmlmXCIsXG4gICAgLy8gRk9OVF9TSVpFLk1FRElVTVxuICAgIHVzZXJTZWxlY3Q6IFwibm9uZVwiLFxuICAgIGFuaW1hdGlvbjogYGFnLWNoYXJ0cy1sb2FkaW5nICR7ZHVyYXRpb259bXMgbGluZWFyIDUwbXMgYm90aGBcbiAgfSk7XG4gIGNvbnN0IG1hdHJpeCA9IGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICB3aWR0aDogXCI0NXB4XCIsXG4gICAgaGVpZ2h0OiBcIjQwcHhcIixcbiAgICBiYWNrZ3JvdW5kSW1hZ2U6IFtcbiAgICAgIFwibGluZWFyLWdyYWRpZW50KCMwMDAwIGNhbGMoMSAqIDEwMCUgLyA2KSwgI2NjYyAwIGNhbGMoMyAqIDEwMCUgLyA2KSwgIzAwMDAgMCksIFwiLFxuICAgICAgXCJsaW5lYXItZ3JhZGllbnQoIzAwMDAgY2FsYygyICogMTAwJSAvIDYpLCAjY2NjIDAgY2FsYyg0ICogMTAwJSAvIDYpLCAjMDAwMCAwKSwgXCIsXG4gICAgICBcImxpbmVhci1ncmFkaWVudCgjMDAwMCBjYWxjKDMgKiAxMDAlIC8gNiksICNjY2MgMCBjYWxjKDUgKiAxMDAlIC8gNiksICMwMDAwIDApXCJcbiAgICBdLmpvaW4oXCJcIiksXG4gICAgYmFja2dyb3VuZFNpemU6IFwiMTBweCA0MDAlXCIsXG4gICAgYmFja2dyb3VuZFJlcGVhdDogXCJuby1yZXBlYXRcIixcbiAgICBhbmltYXRpb246IFwiYWctY2hhcnRzLWxvYWRpbmctbWF0cml4IDFzIGluZmluaXRlIGxpbmVhclwiXG4gIH0pO1xuICBjb25zdCBsYWJlbCA9IGNyZWF0ZUVsZW1lbnQoXCJwXCIsIHsgbWFyZ2luVG9wOiBcIjFlbVwiIH0pO1xuICBsYWJlbC5pbm5lclRleHQgPSB0ZXh0O1xuICBjb25zdCBiYWNrZ3JvdW5kID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBgJHtERUZBVUxUX09WRVJMQVlfQ0xBU1N9X19sb2FkaW5nLWJhY2tncm91bmRgLCB7XG4gICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICBpbnNldDogXCIwXCIsXG4gICAgb3BhY2l0eTogXCIwLjVcIixcbiAgICB6SW5kZXg6IFwiLTFcIlxuICB9KTtcbiAgY29uc3QgYW5pbWF0aW9uU3R5bGVzID0gY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICBhbmltYXRpb25TdHlsZXMuaW5uZXJUZXh0ID0gW1xuICAgIFwiQGtleWZyYW1lcyBhZy1jaGFydHMtbG9hZGluZyB7IGZyb20geyBvcGFjaXR5OiAwIH0gdG8geyBvcGFjaXR5OiAxIH0gfVwiLFxuICAgIFwiQGtleWZyYW1lcyBhZy1jaGFydHMtbG9hZGluZy1tYXRyaXgge1wiLFxuICAgIFwiMCUgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAwJSAwJSwgNTAlIDAlLCAxMDAlIDAlOyB9XCIsXG4gICAgXCIxMDAlIHsgYmFja2dyb3VuZC1wb3NpdGlvbjogMCUgMTAwJSwgNTAlIDEwMCUsIDEwMCUgMTAwJTsgfVwiLFxuICAgIFwifVwiXG4gIF0uam9pbihcIiBcIik7XG4gIGNvbnRhaW5lci5yZXBsYWNlQ2hpbGRyZW4oYW5pbWF0aW9uU3R5bGVzLCBtYXRyaXgsIGxhYmVsLCBiYWNrZ3JvdW5kKTtcbiAgcmV0dXJuIGNvbnRhaW5lcjtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL3Nlcmllcy50c1xudmFyIFNlcmllc05vZGVQaWNrTW9kZSA9IC8qIEBfX1BVUkVfXyAqLyAoKFNlcmllc05vZGVQaWNrTW9kZTIpID0+IHtcbiAgU2VyaWVzTm9kZVBpY2tNb2RlMltTZXJpZXNOb2RlUGlja01vZGUyW1wiRVhBQ1RfU0hBUEVfTUFUQ0hcIl0gPSAwXSA9IFwiRVhBQ1RfU0hBUEVfTUFUQ0hcIjtcbiAgU2VyaWVzTm9kZVBpY2tNb2RlMltTZXJpZXNOb2RlUGlja01vZGUyW1wiTkVBUkVTVF9OT0RFXCJdID0gMV0gPSBcIk5FQVJFU1RfTk9ERVwiO1xuICBTZXJpZXNOb2RlUGlja01vZGUyW1Nlcmllc05vZGVQaWNrTW9kZTJbXCJBWElTX0FMSUdORURcIl0gPSAyXSA9IFwiQVhJU19BTElHTkVEXCI7XG4gIHJldHVybiBTZXJpZXNOb2RlUGlja01vZGUyO1xufSkoU2VyaWVzTm9kZVBpY2tNb2RlIHx8IHt9KTtcbnZhciBDUk9TU19GSUxURVJfTUFSS0VSX0ZJTExfT1BBQ0lUWV9GQUNUT1IgPSAwLjI1O1xudmFyIENST1NTX0ZJTFRFUl9NQVJLRVJfU1RST0tFX09QQUNJVFlfRkFDVE9SID0gMC4xMjU7XG52YXIgU2VyaWVzTm9kZUV2ZW50ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBldmVudCwgeyBkYXR1bSB9LCBzZXJpZXMpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuZXZlbnQgPSBldmVudDtcbiAgICB0aGlzLmRhdHVtID0gZGF0dW07XG4gICAgdGhpcy5zZXJpZXNJZCA9IHNlcmllcy5pZDtcbiAgfVxufTtcbnZhciBTZXJpZXNHcm91cGluZ0NoYW5nZWRFdmVudCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioc2VyaWVzLCBzZXJpZXNHcm91cGluZywgb2xkR3JvdXBpbmcpIHtcbiAgICB0aGlzLnNlcmllcyA9IHNlcmllcztcbiAgICB0aGlzLnNlcmllc0dyb3VwaW5nID0gc2VyaWVzR3JvdXBpbmc7XG4gICAgdGhpcy5vbGRHcm91cGluZyA9IG9sZEdyb3VwaW5nO1xuICAgIHRoaXMudHlwZSA9IFwiZ3JvdXBpbmdDaGFuZ2VkXCI7XG4gIH1cbn07XG52YXIgU2VyaWVzID0gY2xhc3MgZXh0ZW5kcyBPYnNlcnZhYmxlIHtcbiAgY29uc3RydWN0b3Ioc2VyaWVzT3B0cykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5kZXN0cm95Rm5zID0gW107XG4gICAgdGhpcy5zZXJpZXNHcm91cGluZyA9IHZvaWQgMDtcbiAgICB0aGlzLk5vZGVFdmVudCA9IFNlcmllc05vZGVFdmVudDtcbiAgICB0aGlzLmludGVybmFsSWQgPSBjcmVhdGVJZCh0aGlzKTtcbiAgICAvLyBUaGUgZ3JvdXAgbm9kZSB0aGF0IGNvbnRhaW5zIGFsbCB0aGUgbm9kZXMgdXNlZCB0byByZW5kZXIgdGhpcyBzZXJpZXMuXG4gICAgdGhpcy5yb290R3JvdXAgPSBuZXcgR3JvdXAoeyBuYW1lOiBcInNlcmllc1Jvb3RcIiwgaXNWaXJ0dWFsOiB0cnVlIH0pO1xuICAgIHRoaXMuYXhlcyA9IHtcbiAgICAgIFtcInhcIiAvKiBYICovXTogdm9pZCAwLFxuICAgICAgW1wieVwiIC8qIFkgKi9dOiB2b2lkIDBcbiAgICB9O1xuICAgIHRoaXMuZGlyZWN0aW9ucyA9IFtcInhcIiAvKiBYICovLCBcInlcIiAvKiBZICovXTtcbiAgICAvLyBGbGFnIHRvIGRldGVybWluZSBpZiB3ZSBzaG91bGQgcmVjYWxjdWxhdGUgbm9kZSBkYXRhLlxuICAgIHRoaXMubm9kZURhdGFSZWZyZXNoID0gdHJ1ZTtcbiAgICB0aGlzLm1vZHVsZU1hcCA9IG5ldyBNb2R1bGVNYXAoKTtcbiAgICB0aGlzLl9kZWNsYXJhdGlvbk9yZGVyID0gLTE7XG4gICAgdGhpcy5zZXJpZXNMaXN0ZW5lcnMgPSBuZXcgTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5fcGlja05vZGVDYWNoZSA9IG5ldyBMUlVDYWNoZSgpO1xuICAgIGNvbnN0IHtcbiAgICAgIG1vZHVsZUN0eCxcbiAgICAgIHBpY2tNb2RlcyxcbiAgICAgIGRpcmVjdGlvbktleXMgPSB7fSxcbiAgICAgIGRpcmVjdGlvbk5hbWVzID0ge30sXG4gICAgICBjb250ZW50R3JvdXBWaXJ0dWFsID0gdHJ1ZSxcbiAgICAgIGNhbkhhdmVBeGVzID0gZmFsc2VcbiAgICB9ID0gc2VyaWVzT3B0cztcbiAgICB0aGlzLmN0eCA9IG1vZHVsZUN0eDtcbiAgICB0aGlzLmRpcmVjdGlvbktleXMgPSBkaXJlY3Rpb25LZXlzO1xuICAgIHRoaXMuZGlyZWN0aW9uTmFtZXMgPSBkaXJlY3Rpb25OYW1lcztcbiAgICB0aGlzLmNhbkhhdmVBeGVzID0gY2FuSGF2ZUF4ZXM7XG4gICAgdGhpcy5jb250ZW50R3JvdXAgPSB0aGlzLnJvb3RHcm91cC5hcHBlbmRDaGlsZChcbiAgICAgIG5ldyBUcmFuc2xhdGFibGVHcm91cCh7XG4gICAgICAgIG5hbWU6IGAke3RoaXMuaW50ZXJuYWxJZH0tY29udGVudGAsXG4gICAgICAgIGlzVmlydHVhbDogY29udGVudEdyb3VwVmlydHVhbCxcbiAgICAgICAgekluZGV4OiA0IC8qIFNFUklFU19MQVlFUiAqLyxcbiAgICAgICAgekluZGV4U3ViT3JkZXI6IHRoaXMuZ2V0R3JvdXBaSW5kZXhTdWJPcmRlcihcImRhdGFcIilcbiAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzLmhpZ2hsaWdodEdyb3VwID0gbmV3IFRyYW5zbGF0YWJsZUdyb3VwKHtcbiAgICAgIG5hbWU6IGAke3RoaXMuaW50ZXJuYWxJZH0taGlnaGxpZ2h0YCxcbiAgICAgIGlzVmlydHVhbDogY29udGVudEdyb3VwVmlydHVhbCxcbiAgICAgIHpJbmRleDogNCAvKiBTRVJJRVNfTEFZRVIgKi8sXG4gICAgICB6SW5kZXhTdWJPcmRlcjogdGhpcy5nZXRHcm91cFpJbmRleFN1Yk9yZGVyKFwiaGlnaGxpZ2h0XCIpXG4gICAgfSk7XG4gICAgdGhpcy5oaWdobGlnaHROb2RlID0gdGhpcy5oaWdobGlnaHRHcm91cC5hcHBlbmRDaGlsZChuZXcgR3JvdXAoeyBuYW1lOiBcImhpZ2hsaWdodE5vZGVcIiwgekluZGV4OiAwIH0pKTtcbiAgICB0aGlzLmhpZ2hsaWdodExhYmVsID0gdGhpcy5oaWdobGlnaHRHcm91cC5hcHBlbmRDaGlsZChuZXcgR3JvdXAoeyBuYW1lOiBcImhpZ2hsaWdodExhYmVsXCIsIHpJbmRleDogMTAgfSkpO1xuICAgIHRoaXMucGlja01vZGVzID0gcGlja01vZGVzO1xuICAgIHRoaXMubGFiZWxHcm91cCA9IHRoaXMucm9vdEdyb3VwLmFwcGVuZENoaWxkKFxuICAgICAgbmV3IFRyYW5zbGF0YWJsZUdyb3VwKHtcbiAgICAgICAgbmFtZTogYCR7dGhpcy5pbnRlcm5hbElkfS1zZXJpZXMtbGFiZWxzYCxcbiAgICAgICAgekluZGV4OiAxNCAvKiBTRVJJRVNfTEFCRUwgKi9cbiAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzLmFubm90YXRpb25Hcm91cCA9IG5ldyBHcm91cCh7XG4gICAgICBuYW1lOiBgJHt0aGlzLmlkfS1hbm5vdGF0aW9uYCxcbiAgICAgIGlzVmlydHVhbDogY29udGVudEdyb3VwVmlydHVhbCxcbiAgICAgIHpJbmRleDogNCAvKiBTRVJJRVNfTEFZRVIgKi8sXG4gICAgICB6SW5kZXhTdWJPcmRlcjogdGhpcy5nZXRHcm91cFpJbmRleFN1Yk9yZGVyKFwiYW5ub3RhdGlvblwiKVxuICAgIH0pO1xuICB9XG4gIGdldCBwaWNrTW9kZUF4aXMoKSB7XG4gICAgcmV0dXJuIFwibWFpblwiO1xuICB9XG4gIGdldCBpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzPy5pZCA/PyB0aGlzLmludGVybmFsSWQ7XG4gIH1cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudHlwZSA/PyBcIlwiO1xuICB9XG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhID8/IHRoaXMuX2NoYXJ0RGF0YTtcbiAgfVxuICBzZXQgdmlzaWJsZSh2YWx1ZSkge1xuICAgIHRoaXMucHJvcGVydGllcy52aXNpYmxlID0gdmFsdWU7XG4gICAgdGhpcy52aXNpYmxlTWF5YmVDaGFuZ2VkKCk7XG4gIH1cbiAgZ2V0IHZpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcGVydGllcy52aXNpYmxlO1xuICB9XG4gIGdldCBoYXNEYXRhKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEgIT0gbnVsbCAmJiB0aGlzLmRhdGEubGVuZ3RoID4gMDtcbiAgfVxuICBnZXQgdG9vbHRpcEVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcGVydGllcy50b29sdGlwPy5lbmFibGVkID8/IGZhbHNlO1xuICB9XG4gIG9uRGF0YUNoYW5nZSgpIHtcbiAgICB0aGlzLm5vZGVEYXRhUmVmcmVzaCA9IHRydWU7XG4gICAgdGhpcy5fcGlja05vZGVDYWNoZS5jbGVhcigpO1xuICB9XG4gIHNldE9wdGlvbnNEYXRhKGlucHV0KSB7XG4gICAgdGhpcy5fZGF0YSA9IGlucHV0O1xuICAgIHRoaXMub25EYXRhQ2hhbmdlKCk7XG4gIH1cbiAgc2V0Q2hhcnREYXRhKGlucHV0KSB7XG4gICAgdGhpcy5fY2hhcnREYXRhID0gaW5wdXQ7XG4gICAgaWYgKHRoaXMuZGF0YSA9PT0gaW5wdXQpIHtcbiAgICAgIHRoaXMub25EYXRhQ2hhbmdlKCk7XG4gICAgfVxuICB9XG4gIG9uU2VyaWVzR3JvdXBpbmdDaGFuZ2UocHJldiwgbmV4dCkge1xuICAgIGNvbnN0IHsgaW50ZXJuYWxJZCwgdHlwZSwgdmlzaWJsZSB9ID0gdGhpcztcbiAgICBpZiAocHJldikge1xuICAgICAgdGhpcy5jdHguc2VyaWVzU3RhdGVNYW5hZ2VyLmRlcmVnaXN0ZXJTZXJpZXModGhpcyk7XG4gICAgfVxuICAgIGlmIChuZXh0KSB7XG4gICAgICB0aGlzLmN0eC5zZXJpZXNTdGF0ZU1hbmFnZXIucmVnaXN0ZXJTZXJpZXMoeyBpbnRlcm5hbElkLCB0eXBlLCB2aXNpYmxlLCBzZXJpZXNHcm91cGluZzogbmV4dCB9KTtcbiAgICB9XG4gICAgdGhpcy5maXJlRXZlbnQobmV3IFNlcmllc0dyb3VwaW5nQ2hhbmdlZEV2ZW50KHRoaXMsIG5leHQsIHByZXYpKTtcbiAgfVxuICBnZXRCYW5kU2NhbGVQYWRkaW5nKCkge1xuICAgIHJldHVybiB7IGlubmVyOiAxLCBvdXRlcjogMCB9O1xuICB9XG4gIGdldEdyb3VwWkluZGV4U3ViT3JkZXIodHlwZSwgc3ViSW5kZXggPSAwKSB7XG4gICAgbGV0IG1haW5BZGp1c3QgPSAwO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBcImRhdGFcIjpcbiAgICAgIGNhc2UgXCJwYXRoc1wiOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJsYWJlbHNcIjpcbiAgICAgICAgbWFpbkFkanVzdCArPSAyZTQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm1hcmtlclwiOlxuICAgICAgICBtYWluQWRqdXN0ICs9IDFlNDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiaGlnaGxpZ2h0XCI6XG4gICAgICAgIHN1YkluZGV4ICs9IDE1ZTM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImFubm90YXRpb25cIjpcbiAgICAgICAgbWFpbkFkanVzdCArPSAxNWUzO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgY29uc3QgbWFpbiA9ICgpID0+IHRoaXMuX2RlY2xhcmF0aW9uT3JkZXIgKyBtYWluQWRqdXN0O1xuICAgIHJldHVybiBbbWFpbiwgc3ViSW5kZXhdO1xuICB9XG4gIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VyaWVzTGlzdGVuZXJzLmFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuICBkaXNwYXRjaCh0eXBlLCBldmVudCkge1xuICAgIHRoaXMuc2VyaWVzTGlzdGVuZXJzLmRpc3BhdGNoKHR5cGUsIGV2ZW50KTtcbiAgfVxuICBhZGRDaGFydEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHJldHVybjtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveUZucy5mb3JFYWNoKChmKSA9PiBmKCkpO1xuICAgIHRoaXMuZGVzdHJveUZucyA9IFtdO1xuICAgIHRoaXMuY3R4LnNlcmllc1N0YXRlTWFuYWdlci5kZXJlZ2lzdGVyU2VyaWVzKHRoaXMpO1xuICB9XG4gIGdldERpcmVjdGlvblZhbHVlcyhkaXJlY3Rpb24sIHByb3BlcnRpZXMpIHtcbiAgICBjb25zdCByZXNvbHZlZERpcmVjdGlvbiA9IHRoaXMucmVzb2x2ZUtleURpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgIGNvbnN0IGtleXMgPSBwcm9wZXJ0aWVzPy5bcmVzb2x2ZWREaXJlY3Rpb25dO1xuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgIGlmICgha2V5cykge1xuICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG4gICAgY29uc3QgYWRkVmFsdWVzID0gKC4uLml0ZW1zKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGl0ZW1zKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIGFkZFZhbHVlcyguLi52YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgYWRkVmFsdWVzKC4uLk9iamVjdC52YWx1ZXModmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGFkZFZhbHVlcyguLi5rZXlzLm1hcCgoa2V5KSA9PiB0aGlzLnByb3BlcnRpZXNba2V5XSkpO1xuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cbiAgZ2V0S2V5cyhkaXJlY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy5nZXREaXJlY3Rpb25WYWx1ZXMoZGlyZWN0aW9uLCB0aGlzLmRpcmVjdGlvbktleXMpO1xuICB9XG4gIGdldEtleVByb3BlcnRpZXMoZGlyZWN0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlyZWN0aW9uS2V5c1t0aGlzLnJlc29sdmVLZXlEaXJlY3Rpb24oZGlyZWN0aW9uKV0gPz8gW107XG4gIH1cbiAgZ2V0TmFtZXMoZGlyZWN0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RGlyZWN0aW9uVmFsdWVzKGRpcmVjdGlvbiwgdGhpcy5kaXJlY3Rpb25OYW1lcyk7XG4gIH1cbiAgcmVzb2x2ZUtleURpcmVjdGlvbihkaXJlY3Rpb24pIHtcbiAgICByZXR1cm4gZGlyZWN0aW9uO1xuICB9XG4gIC8vIFRoZSB1bmlvbiBvZiB0aGUgc2VyaWVzIGRvbWFpbiAoJ2NvbW11bml0eScpIGFuZCBzZXJpZXMtb3B0aW9uIGRvbWFpbnMgKCdlbnRlcnByaXNlJykuXG4gIGdldERvbWFpbihkaXJlY3Rpb24pIHtcbiAgICBjb25zdCBzZXJpZXNEb21haW4gPSB0aGlzLmdldFNlcmllc0RvbWFpbihkaXJlY3Rpb24pO1xuICAgIGNvbnN0IG1vZHVsZURvbWFpbnMgPSB0aGlzLm1vZHVsZU1hcC5tYXBNb2R1bGVzKChtb2R1bGUpID0+IG1vZHVsZS5nZXREb21haW4oZGlyZWN0aW9uKSk7XG4gICAgcmV0dXJuIHNlcmllc0RvbWFpbi5jb25jYXQobW9kdWxlRG9tYWlucy5mbGF0KCkpO1xuICB9XG4gIC8vIEluZGljYXRlIHRoYXQgc29tZXRoaW5nIGV4dGVybmFsIGNoYW5nZWQgYW5kIHdlIHNob3VsZCByZWNhbGN1bGF0ZSBub2RlRGF0YS5cbiAgbWFya05vZGVEYXRhRGlydHkoKSB7XG4gICAgdGhpcy5ub2RlRGF0YVJlZnJlc2ggPSB0cnVlO1xuICAgIHRoaXMuX3BpY2tOb2RlQ2FjaGUuY2xlYXIoKTtcbiAgICB0aGlzLnZpc2libGVNYXliZUNoYW5nZWQoKTtcbiAgfVxuICB2aXNpYmxlTWF5YmVDaGFuZ2VkKCkge1xuICAgIHRoaXMuY3R4LnNlcmllc1N0YXRlTWFuYWdlci51cGRhdGVTZXJpZXModGhpcyk7XG4gIH1cbiAgZ2V0T3BhY2l0eSgpIHtcbiAgICBjb25zdCBkZWZhdWx0T3BhY2l0eSA9IDE7XG4gICAgY29uc3QgeyBkaW1PcGFjaXR5ID0gMSwgZW5hYmxlZCA9IHRydWUgfSA9IHRoaXMucHJvcGVydGllcy5oaWdobGlnaHRTdHlsZS5zZXJpZXM7XG4gICAgaWYgKCFlbmFibGVkIHx8IGRpbU9wYWNpdHkgPT09IGRlZmF1bHRPcGFjaXR5KSB7XG4gICAgICByZXR1cm4gZGVmYXVsdE9wYWNpdHk7XG4gICAgfVxuICAgIHN3aXRjaCAodGhpcy5pc0l0ZW1JZEhpZ2hsaWdodGVkKCkpIHtcbiAgICAgIGNhc2UgMCAvKiBOb25lICovOlxuICAgICAgY2FzZSAxIC8qIFRoaXMgKi86XG4gICAgICAgIHJldHVybiBkZWZhdWx0T3BhY2l0eTtcbiAgICAgIGNhc2UgMiAvKiBPdGhlciAqLzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBkaW1PcGFjaXR5O1xuICAgIH1cbiAgfVxuICBnZXRTdHJva2VXaWR0aChkZWZhdWx0U3Ryb2tlV2lkdGgpIHtcbiAgICBjb25zdCB7IHN0cm9rZVdpZHRoLCBlbmFibGVkID0gdHJ1ZSB9ID0gdGhpcy5wcm9wZXJ0aWVzLmhpZ2hsaWdodFN0eWxlLnNlcmllcztcbiAgICBpZiAoIWVuYWJsZWQgfHwgc3Ryb2tlV2lkdGggPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRTdHJva2VXaWR0aDtcbiAgICB9XG4gICAgc3dpdGNoICh0aGlzLmlzSXRlbUlkSGlnaGxpZ2h0ZWQoKSkge1xuICAgICAgY2FzZSAxIC8qIFRoaXMgKi86XG4gICAgICAgIHJldHVybiBzdHJva2VXaWR0aDtcbiAgICAgIGNhc2UgMCAvKiBOb25lICovOlxuICAgICAgY2FzZSAyIC8qIE90aGVyICovOlxuICAgICAgICByZXR1cm4gZGVmYXVsdFN0cm9rZVdpZHRoO1xuICAgIH1cbiAgfVxuICBpc0l0ZW1JZEhpZ2hsaWdodGVkKCkge1xuICAgIGNvbnN0IHNlcmllcyA9IHRoaXMuY3R4LmhpZ2hsaWdodE1hbmFnZXI/LmdldEFjdGl2ZUhpZ2hsaWdodCgpPy5zZXJpZXM7XG4gICAgaWYgKHNlcmllcyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gMCAvKiBOb25lICovO1xuICAgIH1cbiAgICBpZiAoc2VyaWVzICE9PSB0aGlzKSB7XG4gICAgICByZXR1cm4gMiAvKiBPdGhlciAqLztcbiAgICB9XG4gICAgcmV0dXJuIDEgLyogVGhpcyAqLztcbiAgfVxuICBnZXRNb2R1bGVUb29sdGlwUGFyYW1zKCkge1xuICAgIHJldHVybiB0aGlzLm1vZHVsZU1hcC5tYXBNb2R1bGVzKChtb2R1bGUpID0+IG1vZHVsZS5nZXRUb29sdGlwUGFyYW1zKCkpLnJlZHVjZSgodG90YWwsIGN1cnJlbnQpID0+IE9iamVjdC5hc3NpZ24odG90YWwsIGN1cnJlbnQpLCB7fSk7XG4gIH1cbiAgcGlja05vZGUocG9pbnQsIGludGVudCwgZXhhY3RNYXRjaE9ubHkgPSBmYWxzZSkge1xuICAgIGNvbnN0IHsgcGlja01vZGVzLCBwaWNrTW9kZUF4aXMsIHZpc2libGUsIHJvb3RHcm91cCB9ID0gdGhpcztcbiAgICBpZiAoIXZpc2libGUgfHwgIXJvb3RHcm91cC52aXNpYmxlKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChpbnRlbnQgPT09IFwiaGlnaGxpZ2h0XCIgJiYgIXRoaXMucHJvcGVydGllcy5oaWdobGlnaHQuZW5hYmxlZClcbiAgICAgIHJldHVybjtcbiAgICBpZiAoaW50ZW50ID09PSBcImhpZ2hsaWdodC10b29sdGlwXCIgJiYgIXRoaXMucHJvcGVydGllcy5oaWdobGlnaHQuZW5hYmxlZClcbiAgICAgIHJldHVybjtcbiAgICBsZXQgbWF4RGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICBpZiAoaW50ZW50ID09PSBcInRvb2x0aXBcIiB8fCBpbnRlbnQgPT09IFwiaGlnaGxpZ2h0LXRvb2x0aXBcIikge1xuICAgICAgY29uc3QgeyB0b29sdGlwIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgICBtYXhEaXN0YW5jZSA9IHR5cGVvZiB0b29sdGlwLnJhbmdlID09PSBcIm51bWJlclwiID8gdG9vbHRpcC5yYW5nZSA6IEluZmluaXR5O1xuICAgICAgZXhhY3RNYXRjaE9ubHkgfHwgKGV4YWN0TWF0Y2hPbmx5ID0gdG9vbHRpcC5yYW5nZSA9PT0gXCJleGFjdFwiKTtcbiAgICB9IGVsc2UgaWYgKGludGVudCA9PT0gXCJldmVudFwiIHx8IGludGVudCA9PT0gXCJjb250ZXh0LW1lbnVcIikge1xuICAgICAgY29uc3QgeyBub2RlQ2xpY2tSYW5nZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgICAgbWF4RGlzdGFuY2UgPSB0eXBlb2Ygbm9kZUNsaWNrUmFuZ2UgPT09IFwibnVtYmVyXCIgPyBub2RlQ2xpY2tSYW5nZSA6IEluZmluaXR5O1xuICAgICAgZXhhY3RNYXRjaE9ubHkgfHwgKGV4YWN0TWF0Y2hPbmx5ID0gbm9kZUNsaWNrUmFuZ2UgPT09IFwiZXhhY3RcIik7XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdGVkUGlja01vZGVzID0gcGlja01vZGVzLmZpbHRlcihcbiAgICAgIChtKSA9PiAhZXhhY3RNYXRjaE9ubHkgfHwgbSA9PT0gMCAvKiBFWEFDVF9TSEFQRV9NQVRDSCAqL1xuICAgICk7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBwb2ludDtcbiAgICBjb25zdCBrZXkgPSBKU09OLnN0cmluZ2lmeSh7IHgsIHksIG1heERpc3RhbmNlLCBzZWxlY3RlZFBpY2tNb2RlcyB9KTtcbiAgICBpZiAodGhpcy5fcGlja05vZGVDYWNoZS5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BpY2tOb2RlQ2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgcGlja01vZGUgb2Ygc2VsZWN0ZWRQaWNrTW9kZXMpIHtcbiAgICAgIGxldCBtYXRjaDtcbiAgICAgIHN3aXRjaCAocGlja01vZGUpIHtcbiAgICAgICAgY2FzZSAwIC8qIEVYQUNUX1NIQVBFX01BVENIICovOlxuICAgICAgICAgIG1hdGNoID0gdGhpcy5waWNrTm9kZUV4YWN0U2hhcGUocG9pbnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEgLyogTkVBUkVTVF9OT0RFICovOlxuICAgICAgICAgIG1hdGNoID0gdGhpcy5waWNrTm9kZUNsb3Nlc3REYXR1bShwb2ludCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMiAvKiBBWElTX0FMSUdORUQgKi86XG4gICAgICAgICAgbWF0Y2ggPSBwaWNrTW9kZSAhPSBudWxsID8gdGhpcy5waWNrTm9kZU1haW5BeGlzRmlyc3QocG9pbnQsIHBpY2tNb2RlQXhpcyA9PT0gXCJtYWluLWNhdGVnb3J5XCIpIDogdm9pZCAwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKG1hdGNoICYmIG1hdGNoLmRpc3RhbmNlIDw9IG1heERpc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9waWNrTm9kZUNhY2hlLnNldChrZXksIHsgcGlja01vZGUsIG1hdGNoOiBtYXRjaC5kYXR1bSwgZGlzdGFuY2U6IG1hdGNoLmRpc3RhbmNlIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcGlja05vZGVDYWNoZS5zZXQoa2V5LCB2b2lkIDApO1xuICB9XG4gIHBpY2tOb2RlRXhhY3RTaGFwZShwb2ludCkge1xuICAgIGNvbnN0IG1hdGNoID0gdGhpcy5jb250ZW50R3JvdXAucGlja05vZGUocG9pbnQueCwgcG9pbnQueSk7XG4gICAgaWYgKG1hdGNoICYmIG1hdGNoLmRhdHVtLm1pc3NpbmcgIT09IHRydWUpIHtcbiAgICAgIHJldHVybiB7IGRhdHVtOiBtYXRjaC5kYXR1bSwgZGlzdGFuY2U6IDAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBwaWNrTm9kZUNsb3Nlc3REYXR1bShfcG9pbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBRyBDaGFydHMgLSBTZXJpZXMucGlja05vZGVDbG9zZXN0RGF0dW0oKSBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgcGlja05vZGVOZWFyZXN0RGlzdGFudE9iamVjdChwb2ludCwgaXRlbXMpIHtcbiAgICBjb25zdCBtYXRjaCA9IG5lYXJlc3RTcXVhcmVkKHBvaW50LngsIHBvaW50LnksIGl0ZW1zKTtcbiAgICBpZiAobWF0Y2gubmVhcmVzdCAhPT0gdm9pZCAwICYmIG1hdGNoLm5lYXJlc3QuZGF0dW0ubWlzc2luZyAhPT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIHsgZGF0dW06IG1hdGNoLm5lYXJlc3QuZGF0dW0sIGRpc3RhbmNlOiBNYXRoLnNxcnQobWF0Y2guZGlzdGFuY2VTcXVhcmVkKSB9O1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHBpY2tOb2RlTWFpbkF4aXNGaXJzdChfcG9pbnQsIF9yZXF1aXJlQ2F0ZWdvcnlBeGlzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQUcgQ2hhcnRzIC0gU2VyaWVzLnBpY2tOb2RlTWFpbkF4aXNGaXJzdCgpIG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICBmaXJlTm9kZUNsaWNrRXZlbnQoZXZlbnQsIGRhdHVtKSB7XG4gICAgdGhpcy5maXJlRXZlbnQobmV3IHRoaXMuTm9kZUV2ZW50KFwibm9kZUNsaWNrXCIsIGV2ZW50LCBkYXR1bSwgdGhpcykpO1xuICB9XG4gIGZpcmVOb2RlRG91YmxlQ2xpY2tFdmVudChldmVudCwgZGF0dW0pIHtcbiAgICB0aGlzLmZpcmVFdmVudChuZXcgdGhpcy5Ob2RlRXZlbnQoXCJub2RlRG91YmxlQ2xpY2tcIiwgZXZlbnQsIGRhdHVtLCB0aGlzKSk7XG4gIH1cbiAgY3JlYXRlTm9kZUNvbnRleHRNZW51QWN0aW9uRXZlbnQoZXZlbnQsIGRhdHVtKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzLk5vZGVFdmVudChcIm5vZGVDb250ZXh0TWVudUFjdGlvblwiLCBldmVudCwgZGF0dW0sIHRoaXMpO1xuICB9XG4gIHRvZ2dsZVNlcmllc0l0ZW0oaXRlbUlkLCBlbmFibGVkKSB7XG4gICAgdGhpcy52aXNpYmxlID0gZW5hYmxlZDtcbiAgICB0aGlzLm5vZGVEYXRhUmVmcmVzaCA9IHRydWU7XG4gICAgdGhpcy5fcGlja05vZGVDYWNoZS5jbGVhcigpO1xuICAgIHRoaXMuZGlzcGF0Y2goXCJ2aXNpYmlsaXR5LWNoYW5nZWRcIiwgeyBpdGVtSWQsIGVuYWJsZWQgfSk7XG4gIH1cbiAgaXNFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLnZpc2libGU7XG4gIH1cbiAgZ2V0TW9kdWxlTWFwKCkge1xuICAgIHJldHVybiB0aGlzLm1vZHVsZU1hcDtcbiAgfVxuICBjcmVhdGVNb2R1bGVDb250ZXh0KCkge1xuICAgIHJldHVybiB7IC4uLnRoaXMuY3R4LCBzZXJpZXM6IHRoaXMgfTtcbiAgfVxuICBnZXRMYWJlbFRleHQobGFiZWwsIHBhcmFtcywgZGVmYXVsdEZvcm1hdHRlciA9IFN0cmluZykge1xuICAgIGlmIChsYWJlbC5mb3JtYXR0ZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmN0eC5jYWxsYmFja0NhY2hlLmNhbGwobGFiZWwuZm9ybWF0dGVyLCB7IHNlcmllc0lkOiB0aGlzLmlkLCAuLi5wYXJhbXMgfSkgPz8gZGVmYXVsdEZvcm1hdHRlcihwYXJhbXMudmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdEZvcm1hdHRlcihwYXJhbXMudmFsdWUpO1xuICB9XG4gIGdldE1hcmtlclN0eWxlKG1hcmtlciwgcGFyYW1zLCBkZWZhdWx0U3R5bGUgPSBtYXJrZXIuZ2V0U3R5bGUoKSkge1xuICAgIGNvbnN0IGRlZmF1bHRTaXplID0geyBzaXplOiBwYXJhbXMuZGF0dW0ucG9pbnQ/LnNpemUgPz8gMCB9O1xuICAgIGNvbnN0IG1hcmtlclN0eWxlID0gbWVyZ2VEZWZhdWx0cyhkZWZhdWx0U2l6ZSwgZGVmYXVsdFN0eWxlKTtcbiAgICBpZiAobWFya2VyLml0ZW1TdHlsZXIpIHtcbiAgICAgIGNvbnN0IHN0eWxlID0gdGhpcy5jdHguY2FsbGJhY2tDYWNoZS5jYWxsKG1hcmtlci5pdGVtU3R5bGVyLCB7XG4gICAgICAgIHNlcmllc0lkOiB0aGlzLmlkLFxuICAgICAgICAuLi5tYXJrZXJTdHlsZSxcbiAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICBkYXR1bTogcGFyYW1zLmRhdHVtLmRhdHVtXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBtZXJnZURlZmF1bHRzKHN0eWxlLCBtYXJrZXJTdHlsZSk7XG4gICAgfVxuICAgIHJldHVybiBtYXJrZXJTdHlsZTtcbiAgfVxuICB1cGRhdGVNYXJrZXJTdHlsZShtYXJrZXJOb2RlLCBtYXJrZXIsIHBhcmFtcywgZGVmYXVsdFN0eWxlID0gbWFya2VyLmdldFN0eWxlKCksIHsgYXBwbHlUcmFuc2xhdGlvbiA9IHRydWUsIHNlbGVjdGVkID0gdHJ1ZSB9ID0ge30pIHtcbiAgICBjb25zdCB7IHBvaW50IH0gPSBwYXJhbXMuZGF0dW07XG4gICAgY29uc3QgYWN0aXZlU3R5bGUgPSB0aGlzLmdldE1hcmtlclN0eWxlKG1hcmtlciwgcGFyYW1zLCBkZWZhdWx0U3R5bGUpO1xuICAgIGNvbnN0IHZpc2libGUgPSB0aGlzLnZpc2libGUgJiYgYWN0aXZlU3R5bGUuc2l6ZSA+IDAgJiYgcG9pbnQgJiYgIWlzTmFOKHBvaW50LngpICYmICFpc05hTihwb2ludC55KTtcbiAgICBpZiAoYXBwbHlUcmFuc2xhdGlvbikge1xuICAgICAgbWFya2VyTm9kZS5zZXRQcm9wZXJ0aWVzKHsgdmlzaWJsZSwgLi4uYWN0aXZlU3R5bGUsIHRyYW5zbGF0aW9uWDogcG9pbnQ/LngsIHRyYW5zbGF0aW9uWTogcG9pbnQ/LnkgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hcmtlck5vZGUuc2V0UHJvcGVydGllcyh7IHZpc2libGUsIC4uLmFjdGl2ZVN0eWxlIH0pO1xuICAgIH1cbiAgICBpZiAoIXNlbGVjdGVkKSB7XG4gICAgICBtYXJrZXJOb2RlLmZpbGxPcGFjaXR5ICo9IENST1NTX0ZJTFRFUl9NQVJLRVJfRklMTF9PUEFDSVRZX0ZBQ1RPUjtcbiAgICAgIG1hcmtlck5vZGUuc3Ryb2tlT3BhY2l0eSAqPSBDUk9TU19GSUxURVJfTUFSS0VSX1NUUk9LRV9PUEFDSVRZX0ZBQ1RPUjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBtYXJrZXIuc2hhcGUgPT09IFwiZnVuY3Rpb25cIiAmJiAhbWFya2VyTm9kZS5kaXJ0eVBhdGgpIHtcbiAgICAgIG1hcmtlck5vZGUucGF0aC5jbGVhcih0cnVlKTtcbiAgICAgIG1hcmtlck5vZGUudXBkYXRlUGF0aCgpO1xuICAgICAgbWFya2VyTm9kZS5jaGVja1BhdGhEaXJ0eSgpO1xuICAgICAgY29uc3QgYmIgPSBtYXJrZXJOb2RlLmdldEJCb3goKTtcbiAgICAgIGlmIChwb2ludCAhPT0gdm9pZCAwICYmIGJiLmlzRmluaXRlKCkpIHtcbiAgICAgICAgY29uc3QgY2VudGVyMiA9IGJiLmNvbXB1dGVDZW50ZXIoKTtcbiAgICAgICAgY29uc3QgW2R4LCBkeV0gPSBbXCJ4XCIsIFwieVwiXS5tYXAoXG4gICAgICAgICAgKGtleSkgPT4gKGFjdGl2ZVN0eWxlLnN0cm9rZVdpZHRoID8/IDApICsgTWF0aC5hYnMoY2VudGVyMltrZXldIC0gcG9pbnRba2V5XSlcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgY3VzdG9tU2l6ZSA9IE1hdGgubWF4KGJiLndpZHRoICsgZHgsIGJiLmhlaWdodCArIGR5KTtcbiAgICAgICAgcG9pbnQuZm9jdXNTaXplID0gY3VzdG9tU2l6ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0TWluUmVjdHMoX3dpZHRoLCBfaGVpZ2h0KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGdldCBub2RlRGF0YURlcGVuZGVuY2llcygpIHtcbiAgICByZXR1cm4gdGhpcy5fbm9kZURhdGFEZXBlbmRlbmNpZXMgPz8geyBzZXJpZXNSZWN0V2lkdGg6IE5hTiwgc2VyaWVzUmVjdEhlaWdodDogTmFOIH07XG4gIH1cbiAgY2hlY2tSZXNpemUobmV3U2VyaWVzUmVjdCkge1xuICAgIGNvbnN0IHsgd2lkdGg6IHNlcmllc1JlY3RXaWR0aCwgaGVpZ2h0OiBzZXJpZXNSZWN0SGVpZ2h0IH0gPSBuZXdTZXJpZXNSZWN0ID8/IHsgd2lkdGg6IE5hTiwgaGVpZ2h0OiBOYU4gfTtcbiAgICBjb25zdCBuZXdOb2RlRGF0YURlcGVuZGVuY2llcyA9IG5ld1Nlcmllc1JlY3QgPyB7IHNlcmllc1JlY3RXaWR0aCwgc2VyaWVzUmVjdEhlaWdodCB9IDogdm9pZCAwO1xuICAgIGNvbnN0IHJlc2l6ZSA9IGpzb25EaWZmKHRoaXMubm9kZURhdGFEZXBlbmRlbmNpZXMsIG5ld05vZGVEYXRhRGVwZW5kZW5jaWVzKSAhPSBudWxsO1xuICAgIGlmIChyZXNpemUpIHtcbiAgICAgIHRoaXMuX25vZGVEYXRhRGVwZW5kZW5jaWVzID0gbmV3Tm9kZURhdGFEZXBlbmRlbmNpZXM7XG4gICAgICB0aGlzLm1hcmtOb2RlRGF0YURpcnR5KCk7XG4gICAgfVxuICAgIHJldHVybiByZXNpemU7XG4gIH1cbiAgcGlja0ZvY3VzKF9vcHRzKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxufTtcblNlcmllcy5oaWdobGlnaHRlZFpJbmRleCA9IDFlMTI7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBBY3Rpb25PblNldCh7XG4gICAgY2hhbmdlVmFsdWU6IGZ1bmN0aW9uKG5ld1ZhbCwgb2xkVmFsKSB7XG4gICAgICB0aGlzLm9uU2VyaWVzR3JvdXBpbmdDaGFuZ2Uob2xkVmFsLCBuZXdWYWwpO1xuICAgIH1cbiAgfSlcbl0sIFNlcmllcy5wcm90b3R5cGUsIFwic2VyaWVzR3JvdXBpbmdcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2tleWJvYXJkVXRpbC50c1xuZnVuY3Rpb24gY29tcHV0ZUNlbnRlcihiYm94T3JQYXRoKSB7XG4gIGlmIChiYm94T3JQYXRoID09IG51bGwpXG4gICAgcmV0dXJuO1xuICBpZiAoYmJveE9yUGF0aCBpbnN0YW5jZW9mIEJCb3gpIHtcbiAgICByZXR1cm4gYmJveE9yUGF0aC5jb21wdXRlQ2VudGVyKCk7XG4gIH1cbiAgcmV0dXJuIFRyYW5zZm9ybWFibGUudG9DYW52YXMoYmJveE9yUGF0aCkuY29tcHV0ZUNlbnRlcigpO1xufVxuZnVuY3Rpb24gZHJhd1BpY2tlZEZvY3VzKGZvY3VzSW5kaWNhdG9yLCBwaWNrKSB7XG4gIGNvbnN0IHsgYm91bmRzLCBzaG93Rm9jdXNCb3ggfSA9IHBpY2s7XG4gIGlmIChzaG93Rm9jdXNCb3gpIHtcbiAgICBmb2N1c0luZGljYXRvcj8udXBkYXRlQm91bmRzKGJvdW5kcyk7XG4gIH1cbn1cbmZ1bmN0aW9uIG1ha2VLZXlib2FyZFBvaW50ZXJFdmVudChmb2N1c0luZGljYXRvciwgcGljaykge1xuICBkcmF3UGlja2VkRm9jdXMoZm9jdXNJbmRpY2F0b3IsIHBpY2spO1xuICBjb25zdCB7IHg6IG9mZnNldFgsIHk6IG9mZnNldFkgfSA9IGNvbXB1dGVDZW50ZXIocGljay5ib3VuZHMpID8/IHt9O1xuICBpZiAob2Zmc2V0WCAhPT0gdm9pZCAwICYmIG9mZnNldFkgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiB7IHR5cGU6IFwia2V5Ym9hcmRcIiwgb2Zmc2V0WCwgb2Zmc2V0WSB9O1xuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy91dGlsLnRzXG5mdW5jdGlvbiBjb252ZXJ0VmFsdWVzVG9TY2FsZUJ5RGVmcyh7XG4gIGRlZnMsXG4gIHZhbHVlcyxcbiAgeEF4aXMsXG4gIHlBeGlzXG59KSB7XG4gIGlmICghKHhBeGlzICYmIHlBeGlzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkF4ZXMgbXVzdCBiZSBkZWZpbmVkXCIpO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBmb3IgKGNvbnN0IFtzZWFyY2hJZCwgeyBkZWYgfV0gb2YgZGVmcykge1xuICAgIGlmIChPYmplY3QuaGFzT3duKHZhbHVlcywgc2VhcmNoSWQpKSB7XG4gICAgICBjb25zdCB7IHNjYWxlOiBzY2FsZTIgfSA9IGRlZi50eXBlID09PSBcImtleVwiID8geEF4aXMgOiB5QXhpcztcbiAgICAgIHJlc3VsdFtzZWFyY2hJZF0gPSBNYXRoLnJvdW5kKHNjYWxlMi5jb252ZXJ0KHZhbHVlc1tzZWFyY2hJZF0pKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHBpY2tOb2RlKGlucHV0U2VyaWVzLCBwb2ludCwgaW50ZW50LCBleGFjdE1hdGNoT25seSkge1xuICBjb25zdCByZXZlcnNlU2VyaWVzID0gWy4uLmlucHV0U2VyaWVzXS5yZXZlcnNlKCk7XG4gIGxldCByZXN1bHQ7XG4gIGZvciAoY29uc3Qgc2VyaWVzIG9mIHJldmVyc2VTZXJpZXMpIHtcbiAgICBpZiAoIXNlcmllcy52aXNpYmxlIHx8ICFzZXJpZXMucm9vdEdyb3VwLnZpc2libGUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB7IG1hdGNoLCBkaXN0YW5jZTogZGlzdGFuY2UzIH0gPSBzZXJpZXMucGlja05vZGUocG9pbnQsIGludGVudCwgZXhhY3RNYXRjaE9ubHkpID8/IHt9O1xuICAgIGlmICghbWF0Y2ggfHwgZGlzdGFuY2UzID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoIXJlc3VsdCB8fCByZXN1bHQuZGlzdGFuY2UgPiBkaXN0YW5jZTMpIHtcbiAgICAgIHJlc3VsdCA9IHsgc2VyaWVzLCBkaXN0YW5jZTogZGlzdGFuY2UzLCBkYXR1bTogbWF0Y2ggfTtcbiAgICB9XG4gICAgaWYgKGRpc3RhbmNlMyA9PT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9zZXJpZXNBcmVhTWFuYWdlci50c1xudmFyIFNlcmllc0FyZWFBcmlhTGFiZWwgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQyLCBpZCkge1xuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQyO1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICBlbGVtZW50Mi5pZCA9IGlkO1xuICAgIGVsZW1lbnQyLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICBzZXRBdHRyaWJ1dGUoZWxlbWVudDIucGFyZW50RWxlbWVudCwgXCJhcmlhLWxhYmVsbGVkYnlcIiwgaWQpO1xuICB9XG4gIGxheW91dENvbXBsZXRlKGV2ZW50KSB7XG4gICAgdGhpcy5lbGVtZW50LnBhcmVudEVsZW1lbnQuc3R5bGUud2lkdGggPSBgJHtldmVudC5jaGFydC53aWR0aH1weGA7XG4gICAgdGhpcy5lbGVtZW50LnBhcmVudEVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gYCR7ZXZlbnQuY2hhcnQuaGVpZ2h0fXB4YDtcbiAgfVxuICBzZXQgdGV4dCh0ZXh0KSB7XG4gICAgdGhpcy5lbGVtZW50LnRleHRDb250ZW50ID0gdGV4dDtcbiAgfVxufTtcbnZhciBTZXJpZXNBcmVhTWFuYWdlciA9IGNsYXNzIGV4dGVuZHMgQmFzZU1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihjaGFydCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jaGFydCA9IGNoYXJ0O1xuICAgIHRoaXMuaWQgPSBjcmVhdGVJZCh0aGlzKTtcbiAgICB0aGlzLnNlcmllcyA9IFtdO1xuICAgIHRoaXMuaGlnaGxpZ2h0ID0ge1xuICAgICAgLyoqIExhc3QgcmVjZWl2ZWQgZXZlbnQgdGhhdCBzdGlsbCBuZWVkcyB0byBiZSBhcHBsaWVkLiAqL1xuICAgICAgcGVuZGluZ0hvdmVyRXZlbnQ6IHZvaWQgMCxcbiAgICAgIC8qKiBMYXN0IGFwcGxpZWQgZXZlbnQuICovXG4gICAgICBhcHBsaWVkSG92ZXJFdmVudDogdm9pZCAwLFxuICAgICAgLyoqIExhc3QgYXBwbGllZCBldmVudCwgd2hpY2ggaGFzIGJlZW4gdGVtcG9yYXJpbHkgc3Rhc2hlZCBkdXJpbmcgdGhlIG1haW4gY2hhcnQgdXBkYXRlIGN5Y2xlLiAqL1xuICAgICAgc3Rhc2hlZEhvdmVyRXZlbnQ6IHZvaWQgMFxuICAgIH07XG4gICAgdGhpcy50b29sdGlwID0ge1xuICAgICAgbGFzdEhvdmVyOiB2b2lkIDBcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEExMXkgUmVxdWlyZW1lbnRzIGZvciBUb29sdGlwL0hpZ2hsaWdodCAoc2VlIEFHLTEzMDUxIGZvciBkZXRhaWxzKTpcbiAgICAgKlxuICAgICAqICAgLSAgIFdoZW4gdGhlIHNlcmllcy1hcmVhIGlzIGJsdXJyZWQsIGFsd2F5cyB0aGUgbW91c2UgdG8gdXBkYXRlIHRoZSB0b29sdGlwL2hpZ2hsaWdodC5cbiAgICAgKlxuICAgICAqICAgLSAgIFdoZW4gdGhlIHNlcmllcy1hcmVhIHJlY2VpdmVzIGEgYGZvY3VzYCBldmVudCwgdXNlIGA6Zm9jdXMtdmlzaWJsZWAgdG8gZ3Vlc3MgdGhlIGlucHV0IGRldmljZS5cbiAgICAgKiAgICAgICAodGhpcyBpcyBkZWNpZGVkIGJ5IHRoZSBicm93c2VyKS5cbiAgICAgKlxuICAgICAqICAgLSAgIEZvciBrZXlib2FyZCB1c2VycywgYGZvY3VzYCBhbmQgYGtleWRvd25gIGV2ZW50cyBhbHdheXMgdXBkYXRlcyAmIHNob3dzIHRoZSB0b29sdGlwL2hpZ2hsaWdodCBvblxuICAgICAqICAgICAgIHRoZSBjdXJyZW50bHkgKG9yIG5ld2x5KSBmb2N1c2VkIGRhdHVtLlxuICAgICAqXG4gICAgICogICAtICAgRm9yIGtleWJvYXJkIHVzZXJzLCBgbW91c2Vtb3ZlYCBldmVudHMgdXBkYXRlIHRoZSB0b29sdGlwL2hpZ2hsaWdodCBpZmYgYHBpY2tOb2RlYCBmaW5kcyBhIG1hdGNoXG4gICAgICogICAgICAgZm9yIHRoZSBtb3VzZSBldmVudCBvZmZzZXRzLlxuICAgICAqL1xuICAgIHRoaXMuaG92ZXJEZXZpY2UgPSBcIm1vdXNlXCI7XG4gICAgdGhpcy5mb2N1cyA9IHtcbiAgICAgIHNvcnRlZFNlcmllczogW10sXG4gICAgICBzZXJpZXM6IHZvaWQgMCxcbiAgICAgIHNlcmllc0luZGV4OiAwLFxuICAgICAgZGF0dW1JbmRleDogMCxcbiAgICAgIGRhdHVtOiB2b2lkIDBcbiAgICB9O1xuICAgIHRoaXMuaG92ZXJTY2hlZHVsZXIgPSBkZWJvdW5jZWRBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMudG9vbHRpcC5sYXN0SG92ZXIgJiYgIXRoaXMuaGlnaGxpZ2h0LnBlbmRpbmdIb3ZlckV2ZW50KVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAodGhpcy5jaGFydC5nZXRVcGRhdGVUeXBlKCkgPD0gNCAvKiBTRVJJRVNfVVBEQVRFICovKSB7XG4gICAgICAgIHRoaXMuaG92ZXJTY2hlZHVsZXIuc2NoZWR1bGUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaGlnaGxpZ2h0LnBlbmRpbmdIb3ZlckV2ZW50KSB7XG4gICAgICAgIHRoaXMuaGFuZGxlSG92ZXJIaWdobGlnaHQoZmFsc2UpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMudG9vbHRpcC5sYXN0SG92ZXIpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVIb3ZlclRvb2x0aXAodGhpcy50b29sdGlwLmxhc3RIb3ZlciwgZmFsc2UpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHNlcmllc1JlZ2lvbiA9IGNoYXJ0LmN0eC5yZWdpb25NYW5hZ2VyLmdldFJlZ2lvbihcInNlcmllc1wiIC8qIFNFUklFUyAqLyk7XG4gICAgY29uc3QgaG9yaXpvbnRhbEF4ZXNSZWdpb24gPSBjaGFydC5jdHgucmVnaW9uTWFuYWdlci5nZXRSZWdpb24oXCJob3Jpem9udGFsLWF4ZXNcIiAvKiBIT1JJWk9OVEFMX0FYRVMgKi8pO1xuICAgIGNvbnN0IHZlcnRpY2FsQXhlc1JlZ2lvbiA9IGNoYXJ0LmN0eC5yZWdpb25NYW5hZ2VyLmdldFJlZ2lvbihcInZlcnRpY2FsLWF4ZXNcIiAvKiBWRVJUSUNBTF9BWEVTICovKTtcbiAgICBjb25zdCBtb3VzZU1vdmVTdGF0ZXMgPSAzMiAvKiBEZWZhdWx0ICovIHwgOCAvKiBBbm5vdGF0aW9ucyAqLyB8IDEgLyogQW5ub3RhdGlvbnNTZWxlY3RlZCAqLztcbiAgICBjb25zdCBrZXlTdGF0ZSA9IDMyIC8qIERlZmF1bHQgKi8gfCAyIC8qIEFuaW1hdGlvbiAqLztcbiAgICBjb25zdCBsYWJlbEVsID0gY2hhcnQuY3R4LmRvbU1hbmFnZXIuYWRkQ2hpbGQoXCJzZXJpZXMtYXJlYVwiLCBcInNlcmllcy1hcmVhLWFyaWEtbGFiZWxcIik7XG4gICAgdGhpcy5hcmlhTGFiZWwgPSBuZXcgU2VyaWVzQXJlYUFyaWFMYWJlbChsYWJlbEVsLCBgJHt0aGlzLmlkfS1hcmlhLWxhYmVsYCk7XG4gICAgdGhpcy5kZXN0cm95Rm5zLnB1c2goXG4gICAgICAoKSA9PiBjaGFydC5jdHguZG9tTWFuYWdlci5yZW1vdmVDaGlsZChcInNlcmllcy1hcmVhXCIsIFwic2VyaWVzLWFyZWEtYXJpYS1sYWJlbFwiKSxcbiAgICAgIHNlcmllc1JlZ2lvbi5hZGRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIChldmVudCkgPT4gdGhpcy5vbkNvbnRleHRNZW51KGV2ZW50KSwgNjMgLyogQWxsICovKSxcbiAgICAgIHNlcmllc1JlZ2lvbi5hZGRMaXN0ZW5lcihcImRyYWdcIiwgKGV2ZW50KSA9PiB0aGlzLm9uSG92ZXJMaWtlRXZlbnQoZXZlbnQpLCBtb3VzZU1vdmVTdGF0ZXMpLFxuICAgICAgc2VyaWVzUmVnaW9uLmFkZExpc3RlbmVyKFwiaG92ZXJcIiwgKGV2ZW50KSA9PiB0aGlzLm9uSG92ZXIoZXZlbnQpLCBtb3VzZU1vdmVTdGF0ZXMpLFxuICAgICAgc2VyaWVzUmVnaW9uLmFkZExpc3RlbmVyKFwibGVhdmVcIiwgKCkgPT4gdGhpcy5vbkxlYXZlKCksIG1vdXNlTW92ZVN0YXRlcyksXG4gICAgICBob3Jpem9udGFsQXhlc1JlZ2lvbi5hZGRMaXN0ZW5lcihcImhvdmVyXCIsIChldmVudCkgPT4gdGhpcy5vbkhvdmVyKGV2ZW50KSwgbW91c2VNb3ZlU3RhdGVzKSxcbiAgICAgIGhvcml6b250YWxBeGVzUmVnaW9uLmFkZExpc3RlbmVyKFwibGVhdmVcIiwgKCkgPT4gdGhpcy5vbkxlYXZlKCkpLFxuICAgICAgdmVydGljYWxBeGVzUmVnaW9uLmFkZExpc3RlbmVyKFwiaG92ZXJcIiwgKGV2ZW50KSA9PiB0aGlzLm9uSG92ZXIoZXZlbnQpLCBtb3VzZU1vdmVTdGF0ZXMpLFxuICAgICAgdmVydGljYWxBeGVzUmVnaW9uLmFkZExpc3RlbmVyKFwibGVhdmVcIiwgKCkgPT4gdGhpcy5vbkxlYXZlKCkpLFxuICAgICAgY2hhcnQuY3R4LmFuaW1hdGlvbk1hbmFnZXIuYWRkTGlzdGVuZXIoXCJhbmltYXRpb24tc3RhcnRcIiwgKCkgPT4gdGhpcy5jbGVhckFsbCgpKSxcbiAgICAgIGNoYXJ0LmN0eC5kb21NYW5hZ2VyLmFkZExpc3RlbmVyKFwicmVzaXplXCIsICgpID0+IHRoaXMuY2xlYXJBbGwoKSksXG4gICAgICBjaGFydC5jdHguaGlnaGxpZ2h0TWFuYWdlci5hZGRMaXN0ZW5lcihcImhpZ2hsaWdodC1jaGFuZ2VcIiwgKGV2ZW50KSA9PiB0aGlzLmNoYW5nZUhpZ2hsaWdodERhdHVtKGV2ZW50KSksXG4gICAgICBjaGFydC5jdHgua2V5TmF2TWFuYWdlci5hZGRMaXN0ZW5lcihcImJsdXJcIiwgKCkgPT4gdGhpcy5vbkJsdXIoKSksXG4gICAgICBjaGFydC5jdHgua2V5TmF2TWFuYWdlci5hZGRMaXN0ZW5lcihcImZvY3VzXCIsIChldmVudCkgPT4gdGhpcy5vbkZvY3VzKGV2ZW50KSwga2V5U3RhdGUpLFxuICAgICAgY2hhcnQuY3R4LmtleU5hdk1hbmFnZXIuYWRkTGlzdGVuZXIoXCJuYXYtaG9yaVwiLCAoZXZlbnQpID0+IHRoaXMub25OYXZIb3JpKGV2ZW50KSwga2V5U3RhdGUpLFxuICAgICAgY2hhcnQuY3R4LmtleU5hdk1hbmFnZXIuYWRkTGlzdGVuZXIoXCJuYXYtdmVydFwiLCAoZXZlbnQpID0+IHRoaXMub25OYXZWZXJ0KGV2ZW50KSwga2V5U3RhdGUpLFxuICAgICAgY2hhcnQuY3R4LmtleU5hdk1hbmFnZXIuYWRkTGlzdGVuZXIoXCJzdWJtaXRcIiwgKGV2ZW50KSA9PiB0aGlzLm9uU3VibWl0KGV2ZW50KSwga2V5U3RhdGUpLFxuICAgICAgY2hhcnQuY3R4LmxheW91dE1hbmFnZXIuYWRkTGlzdGVuZXIoXCJsYXlvdXQ6Y29tcGxldGVcIiwgKGV2ZW50KSA9PiB0aGlzLmxheW91dENvbXBsZXRlKGV2ZW50KSksXG4gICAgICBjaGFydC5jdHgucmVnaW9uTWFuYWdlci5saXN0ZW5BbGwoXCJjbGlja1wiLCAoZXZlbnQpID0+IHRoaXMub25DbGljayhldmVudCkpLFxuICAgICAgY2hhcnQuY3R4LnJlZ2lvbk1hbmFnZXIubGlzdGVuQWxsKFwiZGJsY2xpY2tcIiwgKGV2ZW50KSA9PiB0aGlzLm9uQ2xpY2soZXZlbnQpKSxcbiAgICAgIGNoYXJ0LmN0eC51cGRhdGVTZXJ2aWNlLmFkZExpc3RlbmVyKFwicHJlLXNjZW5lLXJlbmRlclwiLCAoKSA9PiB0aGlzLnByZVNjZW5lUmVuZGVyKCkpLFxuICAgICAgY2hhcnQuY3R4Lnpvb21NYW5hZ2VyLmFkZExpc3RlbmVyKFwiem9vbS1jaGFuZ2VcIiwgKCkgPT4gdGhpcy5jbGVhckFsbCgpKSxcbiAgICAgIGNoYXJ0LmN0eC56b29tTWFuYWdlci5hZGRMaXN0ZW5lcihcInpvb20tcGFuLXN0YXJ0XCIsICgpID0+IHRoaXMuY2xlYXJBbGwoKSlcbiAgICApO1xuICB9XG4gIGRhdGFDaGFuZ2VkKCkge1xuICAgIHZhciBfYTtcbiAgICAoX2EgPSB0aGlzLmhpZ2hsaWdodCkuc3Rhc2hlZEhvdmVyRXZlbnQgPz8gKF9hLnN0YXNoZWRIb3ZlckV2ZW50ID0gdGhpcy5oaWdobGlnaHQuYXBwbGllZEhvdmVyRXZlbnQpO1xuICAgIHRoaXMuY2hhcnQuY3R4LnRvb2x0aXBNYW5hZ2VyLnJlbW92ZVRvb2x0aXAodGhpcy5pZCk7XG4gICAgdGhpcy5jaGFydC5jdHguZm9jdXNJbmRpY2F0b3IudXBkYXRlQm91bmRzKHZvaWQgMCk7XG4gICAgdGhpcy5jbGVhckhpZ2hsaWdodCgpO1xuICB9XG4gIHByZVNjZW5lUmVuZGVyKCkge1xuICAgIHRoaXMucmVmcmVzaEZvY3VzKCk7XG4gICAgaWYgKHRoaXMuaGlnaGxpZ2h0LnN0YXNoZWRIb3ZlckV2ZW50ICE9IG51bGwpIHtcbiAgICAgIHRoaXMuaGlnaGxpZ2h0LnBlbmRpbmdIb3ZlckV2ZW50ID0gdGhpcy5oaWdobGlnaHQuc3Rhc2hlZEhvdmVyRXZlbnQ7XG4gICAgICB0aGlzLmhpZ2hsaWdodC5zdGFzaGVkSG92ZXJFdmVudCA9IHZvaWQgMDtcbiAgICAgIHRoaXMuaGFuZGxlSG92ZXJIaWdobGlnaHQodHJ1ZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnRvb2x0aXAubGFzdEhvdmVyICE9IG51bGwpIHtcbiAgICAgIHRoaXMuaGFuZGxlSG92ZXJUb29sdGlwKHRoaXMudG9vbHRpcC5sYXN0SG92ZXIsIHRydWUpO1xuICAgIH1cbiAgfVxuICB1cGRhdGUodHlwZSwgb3B0cykge1xuICAgIHRoaXMuY2hhcnQuY3R4LnVwZGF0ZVNlcnZpY2UudXBkYXRlKHR5cGUsIG9wdHMpO1xuICB9XG4gIHNlcmllc0NoYW5nZWQoc2VyaWVzKSB7XG4gICAgdGhpcy5mb2N1cy5zb3J0ZWRTZXJpZXMgPSBbLi4uc2VyaWVzXS5zb3J0KChhLCBiKSA9PiB7XG4gICAgICBsZXQgZnBBID0gYS5wcm9wZXJ0aWVzLmZvY3VzUHJpb3JpdHkgPz8gSW5maW5pdHk7XG4gICAgICBsZXQgZnBCID0gYi5wcm9wZXJ0aWVzLmZvY3VzUHJpb3JpdHkgPz8gSW5maW5pdHk7XG4gICAgICBpZiAoZnBBID09PSBmcEIpIHtcbiAgICAgICAgW2ZwQSwgZnBCXSA9IFthLl9kZWNsYXJhdGlvbk9yZGVyLCBiLl9kZWNsYXJhdGlvbk9yZGVyXTtcbiAgICAgIH1cbiAgICAgIGlmIChmcEEgPCBmcEIpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfSBlbHNlIGlmIChmcEEgPiBmcEIpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9KTtcbiAgICB0aGlzLnNlcmllcyA9IHNlcmllcztcbiAgfVxuICBsYXlvdXRDb21wbGV0ZShldmVudCkge1xuICAgIHRoaXMuc2VyaWVzUmVjdCA9IGV2ZW50LnNlcmllcy5yZWN0O1xuICAgIHRoaXMuaG92ZXJSZWN0ID0gZXZlbnQuc2VyaWVzLnBhZGRlZFJlY3Q7XG4gICAgdGhpcy5hcmlhTGFiZWwubGF5b3V0Q29tcGxldGUoZXZlbnQpO1xuICB9XG4gIG9uQ29udGV4dE1lbnUoZXZlbnQpIHtcbiAgICBjb25zdCB7IERlZmF1bHQ6IERlZmF1bHQyLCBDb250ZXh0TWVudSB9ID0gSW50ZXJhY3Rpb25TdGF0ZTtcbiAgICBsZXQgcGlja2VkTm9kZTtcbiAgICBsZXQgcG9zaXRpb247XG4gICAgaWYgKHRoaXMuY2hhcnQuY3R4LmZvY3VzSW5kaWNhdG9yLmlzRm9jdXNWaXNpYmxlKCkpIHtcbiAgICAgIHBpY2tlZE5vZGUgPSB0aGlzLmNoYXJ0LmN0eC5oaWdobGlnaHRNYW5hZ2VyLmdldEFjdGl2ZUhpZ2hsaWdodCgpO1xuICAgICAgaWYgKHBpY2tlZE5vZGUgJiYgdGhpcy5zZXJpZXNSZWN0ICYmIHBpY2tlZE5vZGUubWlkUG9pbnQpIHtcbiAgICAgICAgcG9zaXRpb24gPSBUcmFuc2Zvcm1hYmxlLnRvQ2FudmFzUG9pbnQoXG4gICAgICAgICAgcGlja2VkTm9kZS5zZXJpZXMuY29udGVudEdyb3VwLFxuICAgICAgICAgIHBpY2tlZE5vZGUubWlkUG9pbnQueCxcbiAgICAgICAgICBwaWNrZWROb2RlLm1pZFBvaW50LnlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuY2hhcnQuY3R4LmludGVyYWN0aW9uTWFuYWdlci5nZXRTdGF0ZSgpICYgKERlZmF1bHQyIHwgQ29udGV4dE1lbnUpKSB7XG4gICAgICBjb25zdCBtYXRjaCA9IHBpY2tOb2RlKHRoaXMuc2VyaWVzLCB7IHg6IGV2ZW50LnJlZ2lvbk9mZnNldFgsIHk6IGV2ZW50LnJlZ2lvbk9mZnNldFkgfSwgXCJjb250ZXh0LW1lbnVcIik7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgdGhpcy5jaGFydC5jdHguaGlnaGxpZ2h0TWFuYWdlci51cGRhdGVIaWdobGlnaHQodGhpcy5pZCk7XG4gICAgICAgIHBpY2tlZE5vZGUgPSBtYXRjaC5kYXR1bTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jbGVhckFsbCgpO1xuICAgIHRoaXMuY2hhcnQuY3R4LmNvbnRleHRNZW51UmVnaXN0cnkuZGlzcGF0Y2hDb250ZXh0KFwic2VyaWVzXCIsIGV2ZW50LCB7IHBpY2tlZE5vZGUgfSwgcG9zaXRpb24pO1xuICB9XG4gIG9uTGVhdmUoKSB7XG4gICAgdGhpcy5jaGFydC5jdHguY3Vyc29yTWFuYWdlci51cGRhdGVDdXJzb3IodGhpcy5pZCk7XG4gICAgaWYgKCF0aGlzLmNoYXJ0LmN0eC5mb2N1c0luZGljYXRvci5pc0ZvY3VzVmlzaWJsZSgpKVxuICAgICAgdGhpcy5jbGVhckFsbCgpO1xuICB9XG4gIG9uSG92ZXIoZXZlbnQpIHtcbiAgICB0aGlzLmhvdmVyRGV2aWNlID0gXCJtb3VzZVwiO1xuICAgIHRoaXMub25Ib3Zlckxpa2VFdmVudChldmVudCk7XG4gIH1cbiAgb25Ib3Zlckxpa2VFdmVudChldmVudCkge1xuICAgIGlmIChleGNsdWRlc1R5cGUoZXZlbnQsIFwiZHJhZ1wiKSkge1xuICAgICAgdGhpcy50b29sdGlwLmxhc3RIb3ZlciA9IGV2ZW50O1xuICAgIH1cbiAgICB0aGlzLmhpZ2hsaWdodC5wZW5kaW5nSG92ZXJFdmVudCA9IGV2ZW50O1xuICAgIHRoaXMuaG92ZXJTY2hlZHVsZXIuc2NoZWR1bGUoKTtcbiAgICBpZiAodGhpcy5jaGFydC5jdHguaW50ZXJhY3Rpb25NYW5hZ2VyLmdldFN0YXRlKCkgPT09IDMyIC8qIERlZmF1bHQgKi8pIHtcbiAgICAgIGNvbnN0IHsgcmVnaW9uT2Zmc2V0WCwgcmVnaW9uT2Zmc2V0WSB9ID0gZXZlbnQ7XG4gICAgICBjb25zdCBmb3VuZCA9IHBpY2tOb2RlKHRoaXMuc2VyaWVzLCB7IHg6IHJlZ2lvbk9mZnNldFgsIHk6IHJlZ2lvbk9mZnNldFkgfSwgXCJldmVudFwiKTtcbiAgICAgIGlmIChmb3VuZD8uc2VyaWVzLmhhc0V2ZW50TGlzdGVuZXIoXCJub2RlQ2xpY2tcIikgfHwgZm91bmQ/LnNlcmllcy5oYXNFdmVudExpc3RlbmVyKFwibm9kZURvdWJsZUNsaWNrXCIpKSB7XG4gICAgICAgIHRoaXMuY2hhcnQuY3R4LmN1cnNvck1hbmFnZXIudXBkYXRlQ3Vyc29yKHRoaXMuaWQsIFwicG9pbnRlclwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2hhcnQuY3R4LmN1cnNvck1hbmFnZXIudXBkYXRlQ3Vyc29yKHRoaXMuaWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBvbkNsaWNrKGV2ZW50KSB7XG4gICAgdGhpcy5ob3ZlckRldmljZSA9IFwibW91c2VcIjtcbiAgICB0aGlzLm9uSG92ZXJMaWtlRXZlbnQoZXZlbnQpO1xuICAgIGlmICh0aGlzLnNlcmllc1JlY3Q/LmNvbnRhaW5zUG9pbnQoZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WSkgJiYgdGhpcy5jaGVja1Nlcmllc05vZGVDbGljayhldmVudCkpIHtcbiAgICAgIHRoaXMudXBkYXRlKDQgLyogU0VSSUVTX1VQREFURSAqLyk7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuZXdFdmVudCA9IHsgdHlwZTogZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiID8gXCJjbGlja1wiIDogXCJkb3VibGVDbGlja1wiLCBldmVudDogZXZlbnQuc291cmNlRXZlbnQgfTtcbiAgICB0aGlzLmNoYXJ0LmZpcmVFdmVudChuZXdFdmVudCk7XG4gIH1cbiAgb25Gb2N1cyhldmVudCkge1xuICAgIHRoaXMuaG92ZXJEZXZpY2UgPSB0aGlzLmNoYXJ0LmN0eC5mb2N1c0luZGljYXRvci5pc0ZvY3VzVmlzaWJsZSgpID8gXCJrZXlib2FyZFwiIDogXCJtb3VzZVwiO1xuICAgIHRoaXMuaGFuZGxlRm9jdXMoMCwgMCk7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICBvbkJsdXIoKSB7XG4gICAgdGhpcy5ob3ZlckRldmljZSA9IFwibW91c2VcIjtcbiAgICB0aGlzLmNsZWFyQWxsKCk7XG4gIH1cbiAgb25OYXZWZXJ0KGV2ZW50KSB7XG4gICAgdGhpcy5ob3ZlckRldmljZSA9IFwia2V5Ym9hcmRcIjtcbiAgICB0aGlzLmZvY3VzLnNlcmllc0luZGV4ICs9IGV2ZW50LmRlbHRhO1xuICAgIHRoaXMuaGFuZGxlRm9jdXMoZXZlbnQuZGVsdGEsIDApO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgb25OYXZIb3JpKGV2ZW50KSB7XG4gICAgdGhpcy5ob3ZlckRldmljZSA9IFwia2V5Ym9hcmRcIjtcbiAgICB0aGlzLmZvY3VzLmRhdHVtSW5kZXggKz0gZXZlbnQuZGVsdGE7XG4gICAgdGhpcy5oYW5kbGVGb2N1cygwLCBldmVudC5kZWx0YSk7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICBvblN1Ym1pdChldmVudCkge1xuICAgIGNvbnN0IHsgc2VyaWVzLCBkYXR1bSB9ID0gdGhpcy5mb2N1cztcbiAgICBjb25zdCBzb3VyY2VFdmVudCA9IGV2ZW50LnNvdXJjZUV2ZW50LnNvdXJjZUV2ZW50O1xuICAgIGlmIChzZXJpZXMgIT09IHZvaWQgMCAmJiBkYXR1bSAhPT0gdm9pZCAwKSB7XG4gICAgICBzZXJpZXMuZmlyZU5vZGVDbGlja0V2ZW50KHNvdXJjZUV2ZW50LCBkYXR1bSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2hhcnQuZmlyZUV2ZW50KHtcbiAgICAgICAgdHlwZTogXCJjbGlja1wiLFxuICAgICAgICBldmVudDogc291cmNlRXZlbnRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG4gIGNoZWNrU2VyaWVzTm9kZUNsaWNrKGV2ZW50KSB7XG4gICAgbGV0IHBvaW50ID0geyB4OiBldmVudC5yZWdpb25PZmZzZXRYLCB5OiBldmVudC5yZWdpb25PZmZzZXRZIH07XG4gICAgaWYgKGV2ZW50LnJlZ2lvbiAhPT0gXCJzZXJpZXNcIikge1xuICAgICAgcG9pbnQgPSBUcmFuc2Zvcm1hYmxlLmZyb21DYW52YXNQb2ludCh0aGlzLmNoYXJ0LnNlcmllc1Jvb3QsIGV2ZW50Lm9mZnNldFgsIGV2ZW50Lm9mZnNldFkpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBwaWNrTm9kZSh0aGlzLnNlcmllcywgcG9pbnQsIFwiZXZlbnRcIik7XG4gICAgaWYgKHJlc3VsdCA9PSBudWxsKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChldmVudC50eXBlID09PSBcImNsaWNrXCIpIHtcbiAgICAgIHJlc3VsdC5zZXJpZXMuZmlyZU5vZGVDbGlja0V2ZW50KGV2ZW50LnNvdXJjZUV2ZW50LCByZXN1bHQuZGF0dW0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChldmVudC50eXBlID09PSBcImRibGNsaWNrXCIpIHtcbiAgICAgIGV2ZW50LnByZXZlbnRab29tRGJsQ2xpY2sgPSByZXN1bHQuZGlzdGFuY2UgPT09IDA7XG4gICAgICByZXN1bHQuc2VyaWVzLmZpcmVOb2RlRG91YmxlQ2xpY2tFdmVudChldmVudC5zb3VyY2VFdmVudCwgcmVzdWx0LmRhdHVtKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmVmcmVzaEZvY3VzKCkge1xuICAgIGlmICh0aGlzLmNoYXJ0LmN0eC5mb2N1c0luZGljYXRvci5pc0ZvY3VzVmlzaWJsZSgpKSB7XG4gICAgICB0aGlzLmhhbmRsZVNlcmllc0ZvY3VzKDAsIDApO1xuICAgIH1cbiAgfVxuICBoYW5kbGVGb2N1cyhzZXJpZXNJbmRleERlbHRhLCBkYXR1bUluZGV4RGVsdGEpIHtcbiAgICBjb25zdCBvdmVybGF5Rm9jdXMgPSB0aGlzLmNoYXJ0Lm92ZXJsYXlzLmdldEZvY3VzSW5mbyh0aGlzLmNoYXJ0LmN0eC5sb2NhbGVNYW5hZ2VyKTtcbiAgICBpZiAob3ZlcmxheUZvY3VzID09IG51bGwpIHtcbiAgICAgIHRoaXMuaGFuZGxlU2VyaWVzRm9jdXMoc2VyaWVzSW5kZXhEZWx0YSwgZGF0dW1JbmRleERlbHRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jaGFydC5jdHguZm9jdXNJbmRpY2F0b3IudXBkYXRlQm91bmRzKG92ZXJsYXlGb2N1cy5yZWN0KTtcbiAgICB9XG4gIH1cbiAgaGFuZGxlU2VyaWVzRm9jdXMob3RoZXJJbmRleERlbHRhLCBkYXR1bUluZGV4RGVsdGEpIHtcbiAgICBpZiAodGhpcy5jaGFydC5jaGFydFR5cGUgPT09IFwiaGllcmFyY2h5XCIpIHtcbiAgICAgIHRoaXMuaGFuZGxlSGllcmFyY2h5U2VyaWVzRm9jdXMob3RoZXJJbmRleERlbHRhLCBkYXR1bUluZGV4RGVsdGEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGZvY3VzLCBzZXJpZXNSZWN0IH0gPSB0aGlzO1xuICAgIGNvbnN0IHZpc2libGVTZXJpZXMgPSBmb2N1cy5zb3J0ZWRTZXJpZXMuZmlsdGVyKChzKSA9PiBzLnZpc2libGUpO1xuICAgIGlmICh2aXNpYmxlU2VyaWVzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybjtcbiAgICBmb2N1cy5zZXJpZXNJbmRleCA9IGNsYW1wKDAsIGZvY3VzLnNlcmllc0luZGV4LCB2aXNpYmxlU2VyaWVzLmxlbmd0aCAtIDEpO1xuICAgIGZvY3VzLnNlcmllcyA9IHZpc2libGVTZXJpZXNbZm9jdXMuc2VyaWVzSW5kZXhdO1xuICAgIGNvbnN0IHsgZGF0dW1JbmRleCwgc2VyaWVzSW5kZXg6IG90aGVySW5kZXggfSA9IGZvY3VzO1xuICAgIGNvbnN0IHBpY2sgPSBmb2N1cy5zZXJpZXMucGlja0ZvY3VzKHsgZGF0dW1JbmRleCwgZGF0dW1JbmRleERlbHRhLCBvdGhlckluZGV4LCBvdGhlckluZGV4RGVsdGEsIHNlcmllc1JlY3QgfSk7XG4gICAgdGhpcy51cGRhdGVQaWNrZWRGb2N1cyhwaWNrKTtcbiAgfVxuICBoYW5kbGVIaWVyYXJjaHlTZXJpZXNGb2N1cyhvdGhlckluZGV4RGVsdGEsIGRhdHVtSW5kZXhEZWx0YSkge1xuICAgIHRoaXMuZm9jdXMuc2VyaWVzID0gdGhpcy5mb2N1cy5zb3J0ZWRTZXJpZXNbMF07XG4gICAgY29uc3Qge1xuICAgICAgZm9jdXM6IHsgc2VyaWVzLCBzZXJpZXNJbmRleDogb3RoZXJJbmRleCwgZGF0dW1JbmRleCB9LFxuICAgICAgc2VyaWVzUmVjdFxuICAgIH0gPSB0aGlzO1xuICAgIGlmIChzZXJpZXMgPT09IHZvaWQgMClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBwaWNrID0gc2VyaWVzLnBpY2tGb2N1cyh7IGRhdHVtSW5kZXgsIGRhdHVtSW5kZXhEZWx0YSwgb3RoZXJJbmRleCwgb3RoZXJJbmRleERlbHRhLCBzZXJpZXNSZWN0IH0pO1xuICAgIHRoaXMudXBkYXRlUGlja2VkRm9jdXMocGljayk7XG4gIH1cbiAgdXBkYXRlUGlja2VkRm9jdXMocGljaykge1xuICAgIGNvbnN0IHsgZm9jdXMgfSA9IHRoaXM7XG4gICAgaWYgKHBpY2sgPT09IHZvaWQgMCB8fCBmb2N1cy5zZXJpZXMgPT09IHZvaWQgMClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IGRhdHVtLCBkYXR1bUluZGV4IH0gPSBwaWNrO1xuICAgIGZvY3VzLmRhdHVtSW5kZXggPSBkYXR1bUluZGV4O1xuICAgIGZvY3VzLmRhdHVtID0gZGF0dW07XG4gICAgaWYgKHRoaXMuY2hhcnQuY3R4LmZvY3VzSW5kaWNhdG9yLmlzRm9jdXNWaXNpYmxlKCkpIHtcbiAgICAgIHRoaXMuY2hhcnQuY3R4LmFuaW1hdGlvbk1hbmFnZXIucmVzZXQoKTtcbiAgICB9XG4gICAgY29uc3Qga2V5Ym9hcmRFdmVudCA9IG1ha2VLZXlib2FyZFBvaW50ZXJFdmVudCh0aGlzLmNoYXJ0LmN0eC5mb2N1c0luZGljYXRvciwgcGljayk7XG4gICAgaWYgKGtleWJvYXJkRXZlbnQgIT09IHZvaWQgMCAmJiB0aGlzLmhvdmVyRGV2aWNlID09PSBcImtleWJvYXJkXCIpIHtcbiAgICAgIHRoaXMudG9vbHRpcC5sYXN0SG92ZXIgPSB2b2lkIDA7XG4gICAgICB0aGlzLmhpZ2hsaWdodC5hcHBsaWVkSG92ZXJFdmVudCA9IHZvaWQgMDtcbiAgICAgIHRoaXMuaGlnaGxpZ2h0LnBlbmRpbmdIb3ZlckV2ZW50ID0gdm9pZCAwO1xuICAgICAgdGhpcy5oaWdobGlnaHQuc3Rhc2hlZEhvdmVyRXZlbnQgPSB2b2lkIDA7XG4gICAgICBjb25zdCBodG1sID0gZm9jdXMuc2VyaWVzLmdldFRvb2x0aXBIdG1sKGRhdHVtKTtcbiAgICAgIGNvbnN0IG1ldGEgPSBUb29sdGlwTWFuYWdlci5tYWtlVG9vbHRpcE1ldGEoa2V5Ym9hcmRFdmVudCwgZGF0dW0pO1xuICAgICAgdGhpcy5jaGFydC5jdHguaGlnaGxpZ2h0TWFuYWdlci51cGRhdGVIaWdobGlnaHQodGhpcy5pZCwgZGF0dW0pO1xuICAgICAgdGhpcy5jaGFydC5jdHgudG9vbHRpcE1hbmFnZXIudXBkYXRlVG9vbHRpcCh0aGlzLmlkLCBtZXRhLCBodG1sKTtcbiAgICAgIHRoaXMuYXJpYUxhYmVsLnRleHQgPSB0aGlzLmdldERhdHVtQXJpYVRleHQoZGF0dW0sIGh0bWwpO1xuICAgIH1cbiAgfVxuICBnZXREYXR1bUFyaWFUZXh0KGRhdHVtLCBodG1sKSB7XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSBodG1sLmFyaWFMYWJlbDtcbiAgICByZXR1cm4gdGhpcy5jaGFydC5jdHgubG9jYWxlTWFuYWdlci50KFwiYXJpYUFubm91bmNlSG92ZXJEYXR1bVwiLCB7XG4gICAgICBkYXR1bTogZGF0dW0uc2VyaWVzLmdldERhdHVtQXJpYVRleHQ/LihkYXR1bSwgZGVzY3JpcHRpb24pID8/IGRlc2NyaXB0aW9uXG4gICAgfSk7XG4gIH1cbiAgY2xlYXJIaWdobGlnaHQoKSB7XG4gICAgdGhpcy5oaWdobGlnaHQucGVuZGluZ0hvdmVyRXZlbnQgPSB2b2lkIDA7XG4gICAgdGhpcy5oaWdobGlnaHQuYXBwbGllZEhvdmVyRXZlbnQgPSB2b2lkIDA7XG4gICAgdGhpcy5jaGFydC5jdHguaGlnaGxpZ2h0TWFuYWdlci51cGRhdGVIaWdobGlnaHQodGhpcy5pZCk7XG4gIH1cbiAgY2xlYXJUb29sdGlwKCkge1xuICAgIHRoaXMuY2hhcnQuY3R4LnRvb2x0aXBNYW5hZ2VyLnJlbW92ZVRvb2x0aXAodGhpcy5pZCk7XG4gICAgdGhpcy50b29sdGlwLmxhc3RIb3ZlciA9IHZvaWQgMDtcbiAgfVxuICBjbGVhckFsbCgpIHtcbiAgICB0aGlzLmNsZWFySGlnaGxpZ2h0KCk7XG4gICAgdGhpcy5jbGVhclRvb2x0aXAoKTtcbiAgICB0aGlzLmNoYXJ0LmN0eC5mb2N1c0luZGljYXRvci51cGRhdGVCb3VuZHModm9pZCAwKTtcbiAgfVxuICBoYW5kbGVIb3ZlckhpZ2hsaWdodChyZWRpc3BsYXkpIHtcbiAgICB0aGlzLmhpZ2hsaWdodC5hcHBsaWVkSG92ZXJFdmVudCA9IHRoaXMuaGlnaGxpZ2h0LnBlbmRpbmdIb3ZlckV2ZW50O1xuICAgIHRoaXMuaGlnaGxpZ2h0LnBlbmRpbmdIb3ZlckV2ZW50ID0gdm9pZCAwO1xuICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5oaWdobGlnaHQuYXBwbGllZEhvdmVyRXZlbnQ7XG4gICAgaWYgKCFldmVudClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuY2hhcnQuY3R4LmludGVyYWN0aW9uTWFuYWdlci5nZXRTdGF0ZSgpO1xuICAgIGlmIChzdGF0ZSAhPT0gMzIgLyogRGVmYXVsdCAqLyAmJiBzdGF0ZSAhPT0gOCAvKiBBbm5vdGF0aW9ucyAqLyAmJiBzdGF0ZSAhPT0gMSAvKiBBbm5vdGF0aW9uc1NlbGVjdGVkICovKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgb2Zmc2V0WCwgb2Zmc2V0WSB9ID0gZXZlbnQ7XG4gICAgaWYgKHJlZGlzcGxheSA/IHRoaXMuY2hhcnQuY3R4LmFuaW1hdGlvbk1hbmFnZXIuaXNBY3RpdmUoKSA6ICF0aGlzLmhvdmVyUmVjdD8uY29udGFpbnNQb2ludChvZmZzZXRYLCBvZmZzZXRZKSkge1xuICAgICAgdGhpcy5jbGVhckhpZ2hsaWdodCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgcGlja0Nvb3JkcyA9IHsgeDogZXZlbnQucmVnaW9uT2Zmc2V0WCwgeTogZXZlbnQucmVnaW9uT2Zmc2V0WSB9O1xuICAgIGlmIChldmVudC5yZWdpb24gIT09IFwic2VyaWVzXCIpIHtcbiAgICAgIHBpY2tDb29yZHMgPSBUcmFuc2Zvcm1hYmxlLmZyb21DYW52YXNQb2ludCh0aGlzLmNoYXJ0LnNlcmllc1Jvb3QsIG9mZnNldFgsIG9mZnNldFkpO1xuICAgIH1cbiAgICBjb25zdCB7IHJhbmdlOiByYW5nZTMgfSA9IHRoaXMuY2hhcnQuaGlnaGxpZ2h0O1xuICAgIGNvbnN0IGludGVudCA9IHJhbmdlMyA9PT0gXCJ0b29sdGlwXCIgPyBcImhpZ2hsaWdodC10b29sdGlwXCIgOiBcImhpZ2hsaWdodFwiO1xuICAgIGNvbnN0IGZvdW5kID0gcGlja05vZGUodGhpcy5zZXJpZXMsIHBpY2tDb29yZHMsIGludGVudCk7XG4gICAgaWYgKGZvdW5kKSB7XG4gICAgICB0aGlzLmNoYXJ0LmN0eC5oaWdobGlnaHRNYW5hZ2VyLnVwZGF0ZUhpZ2hsaWdodCh0aGlzLmlkLCBmb3VuZC5kYXR1bSk7XG4gICAgICB0aGlzLmhvdmVyRGV2aWNlID0gXCJtb3VzZVwiO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmNoYXJ0LmN0eC5oaWdobGlnaHRNYW5hZ2VyLnVwZGF0ZUhpZ2hsaWdodCh0aGlzLmlkKTtcbiAgfVxuICBoYW5kbGVIb3ZlclRvb2x0aXAoZXZlbnQsIHJlZGlzcGxheSkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5jaGFydC5jdHguaW50ZXJhY3Rpb25NYW5hZ2VyLmdldFN0YXRlKCk7XG4gICAgaWYgKHN0YXRlICE9PSAzMiAvKiBEZWZhdWx0ICovICYmIHN0YXRlICE9PSA4IC8qIEFubm90YXRpb25zICovICYmIHN0YXRlICE9PSAxIC8qIEFubm90YXRpb25zU2VsZWN0ZWQgKi8pXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBvZmZzZXRYLCBvZmZzZXRZLCB0YXJnZXRFbGVtZW50LCByZWdpb25PZmZzZXRYLCByZWdpb25PZmZzZXRZIH0gPSBldmVudDtcbiAgICBpZiAocmVkaXNwbGF5ID8gdGhpcy5jaGFydC5jdHguYW5pbWF0aW9uTWFuYWdlci5pc0FjdGl2ZSgpIDogIXRoaXMuaG92ZXJSZWN0Py5jb250YWluc1BvaW50KG9mZnNldFgsIG9mZnNldFkpKSB7XG4gICAgICBpZiAodGhpcy5ob3ZlckRldmljZSA9PSBcIm1vdXNlXCIpXG4gICAgICAgIHRoaXMuY2xlYXJUb29sdGlwKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0YXJnZXRFbGVtZW50ICYmIHRoaXMuY2hhcnQudG9vbHRpcC5pbnRlcmFjdGl2ZSAmJiB0aGlzLmNoYXJ0LmN0eC5kb21NYW5hZ2VyLmlzTWFuYWdlZENoaWxkRE9NRWxlbWVudCh0YXJnZXRFbGVtZW50LCBcImNhbnZhcy1vdmVybGF5XCIsIERFRkFVTFRfVE9PTFRJUF9DTEFTUykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHBpY2tDb29yZHMgPSB7IHg6IHJlZ2lvbk9mZnNldFgsIHk6IHJlZ2lvbk9mZnNldFkgfTtcbiAgICBpZiAoZXZlbnQucmVnaW9uICE9PSBcInNlcmllc1wiKSB7XG4gICAgICBwaWNrQ29vcmRzID0gVHJhbnNmb3JtYWJsZS5mcm9tQ2FudmFzUG9pbnQodGhpcy5jaGFydC5zZXJpZXNSb290LCBvZmZzZXRYLCBvZmZzZXRZKTtcbiAgICB9XG4gICAgY29uc3QgcGljayA9IHBpY2tOb2RlKHRoaXMuc2VyaWVzLCBwaWNrQ29vcmRzLCBcInRvb2x0aXBcIik7XG4gICAgaWYgKCFwaWNrKSB7XG4gICAgICBpZiAodGhpcy5ob3ZlckRldmljZSA9PSBcIm1vdXNlXCIpXG4gICAgICAgIHRoaXMuY2xlYXJUb29sdGlwKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuaG92ZXJEZXZpY2UgPSBcIm1vdXNlXCI7XG4gICAgY29uc3QgaHRtbCA9IHBpY2suc2VyaWVzLmdldFRvb2x0aXBIdG1sKHBpY2suZGF0dW0pO1xuICAgIGNvbnN0IHRvb2x0aXBFbmFibGVkID0gdGhpcy5jaGFydC50b29sdGlwLmVuYWJsZWQgJiYgcGljay5zZXJpZXMudG9vbHRpcEVuYWJsZWQ7XG4gICAgY29uc3Qgc2hvdWxkVXBkYXRlVG9vbHRpcCA9IHRvb2x0aXBFbmFibGVkICYmIGh0bWwgIT0gbnVsbDtcbiAgICBpZiAoc2hvdWxkVXBkYXRlVG9vbHRpcCkge1xuICAgICAgY29uc3QgbWV0YSA9IFRvb2x0aXBNYW5hZ2VyLm1ha2VUb29sdGlwTWV0YShldmVudCwgcGljay5kYXR1bSk7XG4gICAgICB0aGlzLmNoYXJ0LmN0eC50b29sdGlwTWFuYWdlci51cGRhdGVUb29sdGlwKHRoaXMuaWQsIG1ldGEsIGh0bWwpO1xuICAgIH1cbiAgfVxuICBjaGFuZ2VIaWdobGlnaHREYXR1bShldmVudCkge1xuICAgIGNvbnN0IHNlcmllc1RvVXBkYXRlID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjb25zdCB7IHNlcmllczogbmV3U2VyaWVzID0gdm9pZCAwLCBkYXR1bTogbmV3RGF0dW0gfSA9IGV2ZW50LmN1cnJlbnRIaWdobGlnaHQgPz8ge307XG4gICAgY29uc3QgeyBzZXJpZXM6IGxhc3RTZXJpZXMgPSB2b2lkIDAsIGRhdHVtOiBsYXN0RGF0dW0gfSA9IGV2ZW50LnByZXZpb3VzSGlnaGxpZ2h0ID8/IHt9O1xuICAgIGlmIChsYXN0U2VyaWVzKSB7XG4gICAgICBzZXJpZXNUb1VwZGF0ZS5hZGQobGFzdFNlcmllcyk7XG4gICAgfVxuICAgIGlmIChuZXdTZXJpZXMpIHtcbiAgICAgIHNlcmllc1RvVXBkYXRlLmFkZChuZXdTZXJpZXMpO1xuICAgIH1cbiAgICBpZiAobGFzdFNlcmllcz8ucHJvcGVydGllcy5jdXJzb3IgJiYgbGFzdERhdHVtKSB7XG4gICAgICB0aGlzLmNoYXJ0LmN0eC5jdXJzb3JNYW5hZ2VyLnVwZGF0ZUN1cnNvcihsYXN0U2VyaWVzLmlkKTtcbiAgICB9XG4gICAgaWYgKG5ld1Nlcmllcz8ucHJvcGVydGllcy5jdXJzb3IgJiYgbmV3U2VyaWVzPy5wcm9wZXJ0aWVzLmN1cnNvciAhPT0gXCJkZWZhdWx0XCIgJiYgbmV3RGF0dW0pIHtcbiAgICAgIHRoaXMuY2hhcnQuY3R4LmN1cnNvck1hbmFnZXIudXBkYXRlQ3Vyc29yKG5ld1Nlcmllcy5pZCwgbmV3U2VyaWVzLnByb3BlcnRpZXMuY3Vyc29yKTtcbiAgICB9XG4gICAgY29uc3QgdXBkYXRlQWxsID0gbmV3U2VyaWVzID09IG51bGwgfHwgbGFzdFNlcmllcyA9PSBudWxsO1xuICAgIGlmICh1cGRhdGVBbGwpIHtcbiAgICAgIHRoaXMudXBkYXRlKDQgLyogU0VSSUVTX1VQREFURSAqLyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudXBkYXRlKDQgLyogU0VSSUVTX1VQREFURSAqLywgeyBzZXJpZXNUb1VwZGF0ZSB9KTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9zZXJpZXNMYXllck1hbmFnZXIudHNcbnZhciBTRVJJRVNfVEhSRVNIT0xEX0ZPUl9BR0dSRVNTSVZFX0xBWUVSX1JFRFVDVElPTiA9IDMwO1xudmFyIFNlcmllc0xheWVyTWFuYWdlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioc2VyaWVzUm9vdCwgaGlnaGxpZ2h0Um9vdCwgYW5ub3RhdGlvblJvb3QpIHtcbiAgICB0aGlzLnNlcmllc1Jvb3QgPSBzZXJpZXNSb290O1xuICAgIHRoaXMuaGlnaGxpZ2h0Um9vdCA9IGhpZ2hsaWdodFJvb3Q7XG4gICAgdGhpcy5hbm5vdGF0aW9uUm9vdCA9IGFubm90YXRpb25Sb290O1xuICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgdGhpcy5zZXJpZXMgPSB7fTtcbiAgICB0aGlzLmV4cGVjdGVkU2VyaWVzQ291bnQgPSAxO1xuICAgIHRoaXMubW9kZSA9IFwibm9ybWFsXCI7XG4gIH1cbiAgc2V0U2VyaWVzQ291bnQoY291bnQpIHtcbiAgICB0aGlzLmV4cGVjdGVkU2VyaWVzQ291bnQgPSBjb3VudDtcbiAgfVxuICByZXF1ZXN0R3JvdXAoc2VyaWVzQ29uZmlnKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCB7XG4gICAgICBpbnRlcm5hbElkLFxuICAgICAgdHlwZSxcbiAgICAgIHJvb3RHcm91cDogc2VyaWVzUm9vdEdyb3VwLFxuICAgICAgaGlnaGxpZ2h0R3JvdXA6IHNlcmllc0hpZ2hsaWdodEdyb3VwLFxuICAgICAgYW5ub3RhdGlvbkdyb3VwOiBzZXJpZXNBbm5vdGF0aW9uR3JvdXAsXG4gICAgICBzZXJpZXNHcm91cGluZ1xuICAgIH0gPSBzZXJpZXNDb25maWc7XG4gICAgY29uc3QgeyBncm91cEluZGV4ID0gaW50ZXJuYWxJZCB9ID0gc2VyaWVzR3JvdXBpbmcgPz8ge307XG4gICAgaWYgKHRoaXMuc2VyaWVzW2ludGVybmFsSWRdICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQUcgQ2hhcnRzIC0gc2VyaWVzIGFscmVhZHkgaGFzIGFuIGFsbG9jYXRlZCBsYXllcjogJHt0aGlzLnNlcmllc1tpbnRlcm5hbElkXX1gKTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuc2VyaWVzKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMubW9kZSA9IHRoaXMuZXhwZWN0ZWRTZXJpZXNDb3VudCA+PSBTRVJJRVNfVEhSRVNIT0xEX0ZPUl9BR0dSRVNTSVZFX0xBWUVSX1JFRFVDVElPTiA/IFwiYWdncmVzc2l2ZS1ncm91cGluZ1wiIDogXCJub3JtYWxcIjtcbiAgICB9XG4gICAgKF9hID0gdGhpcy5ncm91cHMpW3R5cGVdID8/IChfYVt0eXBlXSA9IHt9KTtcbiAgICBjb25zdCBsb29rdXBJbmRleCA9IHRoaXMubG9va3VwSWR4KGdyb3VwSW5kZXgpO1xuICAgIGNvbnN0IGdyb3VwSW5mbyA9IChfYiA9IHRoaXMuZ3JvdXBzW3R5cGVdKVtsb29rdXBJbmRleF0gPz8gKF9iW2xvb2t1cEluZGV4XSA9IHtcbiAgICAgIHR5cGUsXG4gICAgICBpZDogbG9va3VwSW5kZXgsXG4gICAgICBzZXJpZXNJZHM6IFtdLFxuICAgICAgZ3JvdXA6IHRoaXMuc2VyaWVzUm9vdC5hcHBlbmRDaGlsZChcbiAgICAgICAgbmV3IExheWVyKHtcbiAgICAgICAgICBuYW1lOiBgJHt0eXBlfS1jb250ZW50YCxcbiAgICAgICAgICB6SW5kZXg6IDQgLyogU0VSSUVTX0xBWUVSICovLFxuICAgICAgICAgIHpJbmRleFN1Yk9yZGVyOiBzZXJpZXNDb25maWcuZ2V0R3JvdXBaSW5kZXhTdWJPcmRlcihcImRhdGFcIilcbiAgICAgICAgfSlcbiAgICAgICksXG4gICAgICBoaWdobGlnaHQ6IHRoaXMuaGlnaGxpZ2h0Um9vdC5hcHBlbmRDaGlsZChcbiAgICAgICAgbmV3IEdyb3VwKHtcbiAgICAgICAgICBuYW1lOiBgJHt0eXBlfS1oaWdobGlnaHRgLFxuICAgICAgICAgIHpJbmRleDogNCAvKiBTRVJJRVNfTEFZRVIgKi8sXG4gICAgICAgICAgekluZGV4U3ViT3JkZXI6IHNlcmllc0NvbmZpZy5nZXRHcm91cFpJbmRleFN1Yk9yZGVyKFwiaGlnaGxpZ2h0XCIpXG4gICAgICAgIH0pXG4gICAgICApLFxuICAgICAgYW5ub3RhdGlvbjogdGhpcy5hbm5vdGF0aW9uUm9vdC5hcHBlbmRDaGlsZChcbiAgICAgICAgbmV3IEdyb3VwKHtcbiAgICAgICAgICBuYW1lOiBgJHt0eXBlfS1hbm5vdGF0aW9uYCxcbiAgICAgICAgICB6SW5kZXg6IDQgLyogU0VSSUVTX0xBWUVSICovLFxuICAgICAgICAgIHpJbmRleFN1Yk9yZGVyOiBzZXJpZXNDb25maWcuZ2V0R3JvdXBaSW5kZXhTdWJPcmRlcihcImFubm90YXRpb25cIilcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICB9KTtcbiAgICB0aGlzLnNlcmllc1tpbnRlcm5hbElkXSA9IHsgbGF5ZXJTdGF0ZTogZ3JvdXBJbmZvLCBzZXJpZXNDb25maWcgfTtcbiAgICBncm91cEluZm8uc2VyaWVzSWRzLnB1c2goaW50ZXJuYWxJZCk7XG4gICAgZ3JvdXBJbmZvLmdyb3VwLmFwcGVuZENoaWxkKHNlcmllc1Jvb3RHcm91cCk7XG4gICAgZ3JvdXBJbmZvLmhpZ2hsaWdodC5hcHBlbmRDaGlsZChzZXJpZXNIaWdobGlnaHRHcm91cCk7XG4gICAgZ3JvdXBJbmZvLmFubm90YXRpb24uYXBwZW5kQ2hpbGQoc2VyaWVzQW5ub3RhdGlvbkdyb3VwKTtcbiAgICByZXR1cm4gZ3JvdXBJbmZvLmdyb3VwO1xuICB9XG4gIGNoYW5nZUdyb3VwKHNlcmllc0NvbmZpZykge1xuICAgIGNvbnN0IHsgaW50ZXJuYWxJZCwgc2VyaWVzR3JvdXBpbmcsIHR5cGUsIHJvb3RHcm91cCwgaGlnaGxpZ2h0R3JvdXAsIGFubm90YXRpb25Hcm91cCwgb2xkR3JvdXBpbmcgfSA9IHNlcmllc0NvbmZpZztcbiAgICBjb25zdCB7IGdyb3VwSW5kZXggPSBpbnRlcm5hbElkIH0gPSBzZXJpZXNHcm91cGluZyA/PyB7fTtcbiAgICBpZiAodGhpcy5ncm91cHNbdHlwZV0/Lltncm91cEluZGV4XT8uc2VyaWVzSWRzLmluY2x1ZGVzKGludGVybmFsSWQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnNlcmllc1tpbnRlcm5hbElkXSAhPSBudWxsKSB7XG4gICAgICB0aGlzLnJlbGVhc2VHcm91cCh7XG4gICAgICAgIGludGVybmFsSWQsXG4gICAgICAgIHNlcmllc0dyb3VwaW5nOiBvbGRHcm91cGluZyxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcm9vdEdyb3VwLFxuICAgICAgICBoaWdobGlnaHRHcm91cCxcbiAgICAgICAgYW5ub3RhdGlvbkdyb3VwXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5yZXF1ZXN0R3JvdXAoc2VyaWVzQ29uZmlnKTtcbiAgfVxuICByZWxlYXNlR3JvdXAoc2VyaWVzQ29uZmlnKSB7XG4gICAgY29uc3QgeyBpbnRlcm5hbElkLCByb290R3JvdXAsIGhpZ2hsaWdodEdyb3VwLCBhbm5vdGF0aW9uR3JvdXAsIHR5cGUgfSA9IHNlcmllc0NvbmZpZztcbiAgICBpZiAodGhpcy5zZXJpZXNbaW50ZXJuYWxJZF0gPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBRyBDaGFydHMgLSBzZXJpZXMgZG9lc24ndCBoYXZlIGFuIGFsbG9jYXRlZCBsYXllcjogJHtpbnRlcm5hbElkfWApO1xuICAgIH1cbiAgICBjb25zdCBncm91cEluZm8gPSB0aGlzLnNlcmllc1tpbnRlcm5hbElkXT8ubGF5ZXJTdGF0ZTtcbiAgICBpZiAoZ3JvdXBJbmZvKSB7XG4gICAgICBncm91cEluZm8uc2VyaWVzSWRzID0gZ3JvdXBJbmZvLnNlcmllc0lkcy5maWx0ZXIoKHYpID0+IHYgIT09IGludGVybmFsSWQpO1xuICAgICAgZ3JvdXBJbmZvLmdyb3VwLnJlbW92ZUNoaWxkKHJvb3RHcm91cCk7XG4gICAgICBncm91cEluZm8uaGlnaGxpZ2h0LnJlbW92ZUNoaWxkKGhpZ2hsaWdodEdyb3VwKTtcbiAgICAgIGdyb3VwSW5mby5hbm5vdGF0aW9uLnJlbW92ZUNoaWxkKGFubm90YXRpb25Hcm91cCk7XG4gICAgfVxuICAgIGlmIChncm91cEluZm8/LnNlcmllc0lkcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuc2VyaWVzUm9vdC5yZW1vdmVDaGlsZChncm91cEluZm8uZ3JvdXApO1xuICAgICAgdGhpcy5oaWdobGlnaHRSb290LnJlbW92ZUNoaWxkKGdyb3VwSW5mby5oaWdobGlnaHQpO1xuICAgICAgdGhpcy5hbm5vdGF0aW9uUm9vdC5yZW1vdmVDaGlsZChncm91cEluZm8uYW5ub3RhdGlvbik7XG4gICAgICBkZWxldGUgdGhpcy5ncm91cHNbZ3JvdXBJbmZvLnR5cGVdW2dyb3VwSW5mby5pZF07XG4gICAgICBkZWxldGUgdGhpcy5ncm91cHNbdHlwZV1baW50ZXJuYWxJZF07XG4gICAgfSBlbHNlIGlmIChncm91cEluZm8/LnNlcmllc0lkcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBsZWFkU2VyaWVzQ29uZmlnID0gdGhpcy5zZXJpZXNbZ3JvdXBJbmZvPy5zZXJpZXNJZHM/LlswXV0/LnNlcmllc0NvbmZpZztcbiAgICAgIGdyb3VwSW5mby5ncm91cC56SW5kZXhTdWJPcmRlciA9IGxlYWRTZXJpZXNDb25maWc/LmdldEdyb3VwWkluZGV4U3ViT3JkZXIoXCJkYXRhXCIpO1xuICAgICAgZ3JvdXBJbmZvLmhpZ2hsaWdodC56SW5kZXhTdWJPcmRlciA9IGxlYWRTZXJpZXNDb25maWc/LmdldEdyb3VwWkluZGV4U3ViT3JkZXIoXCJoaWdobGlnaHRcIik7XG4gICAgICBncm91cEluZm8uYW5ub3RhdGlvbi56SW5kZXhTdWJPcmRlciA9IGxlYWRTZXJpZXNDb25maWc/LmdldEdyb3VwWkluZGV4U3ViT3JkZXIoXCJhbm5vdGF0aW9uXCIpO1xuICAgIH1cbiAgICBkZWxldGUgdGhpcy5zZXJpZXNbaW50ZXJuYWxJZF07XG4gIH1cbiAgbG9va3VwSWR4KGdyb3VwSW5kZXgpIHtcbiAgICBpZiAodGhpcy5tb2RlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICByZXR1cm4gZ3JvdXBJbmRleDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBncm91cEluZGV4ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBncm91cEluZGV4ID0gTnVtYmVyKGdyb3VwSW5kZXguc3BsaXQoXCItXCIpLmF0KC0xKSk7XG4gICAgICBpZiAoIWdyb3VwSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBNYXRoLmZsb29yKFxuICAgICAgY2xhbXAoMCwgZ3JvdXBJbmRleCAvIHRoaXMuZXhwZWN0ZWRTZXJpZXNDb3VudCwgMSkgKiBTRVJJRVNfVEhSRVNIT0xEX0ZPUl9BR0dSRVNTSVZFX0xBWUVSX1JFRFVDVElPTlxuICAgICk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBmb3IgKGNvbnN0IGdyb3VwcyBvZiBPYmplY3QudmFsdWVzKHRoaXMuZ3JvdXBzKSkge1xuICAgICAgZm9yIChjb25zdCBncm91cEluZm8gb2YgT2JqZWN0LnZhbHVlcyhncm91cHMpKSB7XG4gICAgICAgIHRoaXMuc2VyaWVzUm9vdC5yZW1vdmVDaGlsZChncm91cEluZm8uZ3JvdXApO1xuICAgICAgICB0aGlzLmhpZ2hsaWdodFJvb3QucmVtb3ZlQ2hpbGQoZ3JvdXBJbmZvLmhpZ2hsaWdodCk7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvblJvb3QucmVtb3ZlQ2hpbGQoZ3JvdXBJbmZvLmFubm90YXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgIHRoaXMuc2VyaWVzID0ge307XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3VwZGF0ZS9kYXRhV2luZG93UHJvY2Vzc29yLnRzXG52YXIgRGF0YVdpbmRvd1Byb2Nlc3NvciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2hhcnQsIGRhdGFTZXJ2aWNlLCB1cGRhdGVTZXJ2aWNlLCB6b29tTWFuYWdlcikge1xuICAgIHRoaXMuY2hhcnQgPSBjaGFydDtcbiAgICB0aGlzLmRhdGFTZXJ2aWNlID0gZGF0YVNlcnZpY2U7XG4gICAgdGhpcy51cGRhdGVTZXJ2aWNlID0gdXBkYXRlU2VydmljZTtcbiAgICB0aGlzLnpvb21NYW5hZ2VyID0gem9vbU1hbmFnZXI7XG4gICAgdGhpcy5kaXJ0eVpvb20gPSBmYWxzZTtcbiAgICB0aGlzLmRpcnR5RGF0YVNvdXJjZSA9IGZhbHNlO1xuICAgIHRoaXMubGFzdEF4aXNab29tcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5kZXN0cm95Rm5zID0gW107XG4gICAgdGhpcy5kZXN0cm95Rm5zLnB1c2goXG4gICAgICB0aGlzLmRhdGFTZXJ2aWNlLmFkZExpc3RlbmVyKFwiZGF0YS1zb3VyY2UtY2hhbmdlXCIsICgpID0+IHRoaXMub25EYXRhU291cmNlQ2hhbmdlKCkpLFxuICAgICAgdGhpcy5kYXRhU2VydmljZS5hZGRMaXN0ZW5lcihcImRhdGEtbG9hZFwiLCAoKSA9PiB0aGlzLm9uRGF0YUxvYWQoKSksXG4gICAgICB0aGlzLmRhdGFTZXJ2aWNlLmFkZExpc3RlbmVyKFwiZGF0YS1lcnJvclwiLCAoKSA9PiB0aGlzLm9uRGF0YUVycm9yKCkpLFxuICAgICAgdGhpcy51cGRhdGVTZXJ2aWNlLmFkZExpc3RlbmVyKFwidXBkYXRlLWNvbXBsZXRlXCIsICgpID0+IHRoaXMub25VcGRhdGVDb21wbGV0ZSgpKSxcbiAgICAgIHRoaXMuem9vbU1hbmFnZXIuYWRkTGlzdGVuZXIoXCJ6b29tLWNoYW5nZVwiLCAoKSA9PiB0aGlzLm9uWm9vbUNoYW5nZSgpKVxuICAgICk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRlc3Ryb3lGbnMuZm9yRWFjaCgoY2IpID0+IGNiKCkpO1xuICB9XG4gIG9uRGF0YUxvYWQoKSB7XG4gICAgdGhpcy51cGRhdGVTZXJ2aWNlLnVwZGF0ZSgxIC8qIFVQREFURV9EQVRBICovKTtcbiAgfVxuICBvbkRhdGFFcnJvcigpIHtcbiAgICB0aGlzLnVwZGF0ZVNlcnZpY2UudXBkYXRlKDMgLyogUEVSRk9STV9MQVlPVVQgKi8pO1xuICB9XG4gIG9uRGF0YVNvdXJjZUNoYW5nZSgpIHtcbiAgICB0aGlzLmRpcnR5RGF0YVNvdXJjZSA9IHRydWU7XG4gIH1cbiAgb25VcGRhdGVDb21wbGV0ZSgpIHtcbiAgICBpZiAoIXRoaXMuZGlydHlab29tICYmICF0aGlzLmRpcnR5RGF0YVNvdXJjZSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLnVwZGF0ZVdpbmRvdygpLmNhdGNoKChlKSA9PiBMb2dnZXIuZXJyb3JPbmNlKGUpKTtcbiAgfVxuICBvblpvb21DaGFuZ2UoKSB7XG4gICAgdGhpcy5kaXJ0eVpvb20gPSB0cnVlO1xuICB9XG4gIGFzeW5jIHVwZGF0ZVdpbmRvdygpIHtcbiAgICBpZiAoIXRoaXMuZGF0YVNlcnZpY2UuaXNMYXp5KCkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgYXhpcyA9IHRoaXMuZ2V0VmFsaWRBeGlzKCk7XG4gICAgbGV0IHdpbmRvdzI7XG4gICAgbGV0IHNob3VsZFJlZnJlc2ggPSB0cnVlO1xuICAgIGlmIChheGlzKSB7XG4gICAgICBjb25zdCB6b29tMiA9IHRoaXMuem9vbU1hbmFnZXIuZ2V0QXhpc1pvb20oYXhpcy5pZCk7XG4gICAgICB3aW5kb3cyID0gdGhpcy5nZXRBeGlzV2luZG93KGF4aXMsIHpvb20yKTtcbiAgICAgIHNob3VsZFJlZnJlc2ggPSB0aGlzLnNob3VsZFJlZnJlc2goYXhpcywgem9vbTIpO1xuICAgIH1cbiAgICB0aGlzLmRpcnR5Wm9vbSA9IGZhbHNlO1xuICAgIHRoaXMuZGlydHlEYXRhU291cmNlID0gZmFsc2U7XG4gICAgaWYgKCFzaG91bGRSZWZyZXNoKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuZGF0YVNlcnZpY2UubG9hZCh7IHdpbmRvd1N0YXJ0OiB3aW5kb3cyPy5taW4sIHdpbmRvd0VuZDogd2luZG93Mj8ubWF4IH0pO1xuICB9XG4gIGdldFZhbGlkQXhpcygpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFydC5heGVzLmZpbmQoKGF4aXMpID0+IGF4aXMudHlwZSA9PT0gXCJ0aW1lXCIpO1xuICB9XG4gIHNob3VsZFJlZnJlc2goYXhpcywgem9vbTIpIHtcbiAgICBpZiAodGhpcy5kaXJ0eURhdGFTb3VyY2UpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoIXRoaXMuZGlydHlab29tKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGxhc3Rab29tID0gdGhpcy5sYXN0QXhpc1pvb21zLmdldChheGlzLmlkKTtcbiAgICBpZiAobGFzdFpvb20gJiYgem9vbTIubWluID09PSBsYXN0Wm9vbS5taW4gJiYgem9vbTIubWF4ID09PSBsYXN0Wm9vbS5tYXgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5sYXN0QXhpc1pvb21zLnNldChheGlzLmlkLCB6b29tMik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZ2V0QXhpc1dpbmRvdyhheGlzLCB6b29tMikge1xuICAgIGNvbnN0IGRvbWFpbiA9IGF4aXMuc2NhbGUuZ2V0RG9tYWluPy4oKTtcbiAgICBpZiAoIXpvb20yIHx8ICFkb21haW4gfHwgZG9tYWluLmxlbmd0aCA9PT0gMCB8fCBpc05hTihOdW1iZXIoZG9tYWluWzBdKSkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZGlmZjIgPSBOdW1iZXIoZG9tYWluWzFdKSAtIE51bWJlcihkb21haW5bMF0pO1xuICAgIGNvbnN0IG1pbiA9IG5ldyBEYXRlKE51bWJlcihkb21haW5bMF0pICsgZGlmZjIgKiB6b29tMi5taW4pO1xuICAgIGNvbnN0IG1heCA9IG5ldyBEYXRlKE51bWJlcihkb21haW5bMF0pICsgZGlmZjIgKiB6b29tMi5tYXgpO1xuICAgIHJldHVybiB7IG1pbiwgbWF4IH07XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3VwZGF0ZS9vdmVybGF5c1Byb2Nlc3Nvci50c1xudmFyIE92ZXJsYXlzUHJvY2Vzc29yID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjaGFydExpa2UsIG92ZXJsYXlzLCBkYXRhU2VydmljZSwgbGF5b3V0TWFuYWdlciwgbG9jYWxlTWFuYWdlciwgYW5pbWF0aW9uTWFuYWdlciwgZG9tTWFuYWdlcikge1xuICAgIHRoaXMuY2hhcnRMaWtlID0gY2hhcnRMaWtlO1xuICAgIHRoaXMub3ZlcmxheXMgPSBvdmVybGF5cztcbiAgICB0aGlzLmRhdGFTZXJ2aWNlID0gZGF0YVNlcnZpY2U7XG4gICAgdGhpcy5sYXlvdXRNYW5hZ2VyID0gbGF5b3V0TWFuYWdlcjtcbiAgICB0aGlzLmxvY2FsZU1hbmFnZXIgPSBsb2NhbGVNYW5hZ2VyO1xuICAgIHRoaXMuYW5pbWF0aW9uTWFuYWdlciA9IGFuaW1hdGlvbk1hbmFnZXI7XG4gICAgdGhpcy5kb21NYW5hZ2VyID0gZG9tTWFuYWdlcjtcbiAgICB0aGlzLmRlc3Ryb3lGbnMgPSBbXTtcbiAgICB0aGlzLm92ZXJsYXlFbGVtID0gdGhpcy5kb21NYW5hZ2VyLmFkZENoaWxkKFwiY2FudmFzLW92ZXJsYXlcIiwgXCJvdmVybGF5XCIpO1xuICAgIHRoaXMub3ZlcmxheUVsZW0ucm9sZSA9IFwic3RhdHVzXCI7XG4gICAgdGhpcy5vdmVybGF5RWxlbS5hcmlhQXRvbWljID0gXCJmYWxzZVwiO1xuICAgIHRoaXMub3ZlcmxheUVsZW0uYXJpYUxpdmUgPSBcInBvbGl0ZVwiO1xuICAgIHRoaXMub3ZlcmxheUVsZW0uY2xhc3NMaXN0LnRvZ2dsZShERUZBVUxUX09WRVJMQVlfQ0xBU1MpO1xuICAgIHRoaXMuZGVzdHJveUZucy5wdXNoKHRoaXMubGF5b3V0TWFuYWdlci5hZGRMaXN0ZW5lcihcImxheW91dDpjb21wbGV0ZVwiLCAoZSkgPT4gdGhpcy5vbkxheW91dENvbXBsZXRlKGUpKSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRlc3Ryb3lGbnMuZm9yRWFjaCgoY2IpID0+IGNiKCkpO1xuICAgIHRoaXMuZG9tTWFuYWdlci5yZW1vdmVTdHlsZXMoXCJvdmVybGF5c1wiKTtcbiAgICB0aGlzLmRvbU1hbmFnZXIucmVtb3ZlQ2hpbGQoXCJjYW52YXMtb3ZlcmxheVwiLCBcIm92ZXJsYXlcIik7XG4gIH1cbiAgb25MYXlvdXRDb21wbGV0ZSh7IHNlcmllczogeyByZWN0IH0gfSkge1xuICAgIGNvbnN0IGlzTG9hZGluZyA9IHRoaXMuZGF0YVNlcnZpY2UuaXNMb2FkaW5nKCk7XG4gICAgY29uc3QgaGFzRGF0YSA9IHRoaXMuY2hhcnRMaWtlLnNlcmllcy5zb21lKChzKSA9PiBzLmhhc0RhdGEpO1xuICAgIGNvbnN0IGFueVNlcmllc1Zpc2libGUgPSB0aGlzLmNoYXJ0TGlrZS5zZXJpZXMuc29tZSgocykgPT4gcy52aXNpYmxlKTtcbiAgICBpZiAodGhpcy5vdmVybGF5cy5kYXJrVGhlbWUpIHtcbiAgICAgIHRoaXMub3ZlcmxheUVsZW0uY2xhc3NMaXN0LmFkZChERUZBVUxUX09WRVJMQVlfREFSS19DTEFTUyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub3ZlcmxheUVsZW0uY2xhc3NMaXN0LnJlbW92ZShERUZBVUxUX09WRVJMQVlfREFSS19DTEFTUyk7XG4gICAgfVxuICAgIHRoaXMub3ZlcmxheUVsZW0uc3R5bGUubGVmdCA9IGAke3JlY3QueH1weGA7XG4gICAgdGhpcy5vdmVybGF5RWxlbS5zdHlsZS50b3AgPSBgJHtyZWN0Lnl9cHhgO1xuICAgIHRoaXMub3ZlcmxheUVsZW0uc3R5bGUud2lkdGggPSBgJHtyZWN0LndpZHRofXB4YDtcbiAgICB0aGlzLm92ZXJsYXlFbGVtLnN0eWxlLmhlaWdodCA9IGAke3JlY3QuaGVpZ2h0fXB4YDtcbiAgICBjb25zdCBsb2FkaW5nU2hvd24gPSBpc0xvYWRpbmc7XG4gICAgY29uc3Qgbm9EYXRhU2hvd24gPSAhaXNMb2FkaW5nICYmICFoYXNEYXRhO1xuICAgIGNvbnN0IG5vVmlzaWJsZVNlcmllc1Nob3duID0gaGFzRGF0YSAmJiAhYW55U2VyaWVzVmlzaWJsZTtcbiAgICBpZiAobG9hZGluZ1Nob3duKSB7XG4gICAgICB0aGlzLnNob3dPdmVybGF5KHRoaXMub3ZlcmxheXMubG9hZGluZywgcmVjdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGlkZU92ZXJsYXkodGhpcy5vdmVybGF5cy5sb2FkaW5nKTtcbiAgICB9XG4gICAgaWYgKG5vRGF0YVNob3duKSB7XG4gICAgICB0aGlzLnNob3dPdmVybGF5KHRoaXMub3ZlcmxheXMubm9EYXRhLCByZWN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oaWRlT3ZlcmxheSh0aGlzLm92ZXJsYXlzLm5vRGF0YSk7XG4gICAgfVxuICAgIGlmIChub1Zpc2libGVTZXJpZXNTaG93bikge1xuICAgICAgdGhpcy5zaG93T3ZlcmxheSh0aGlzLm92ZXJsYXlzLm5vVmlzaWJsZVNlcmllcywgcmVjdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGlkZU92ZXJsYXkodGhpcy5vdmVybGF5cy5ub1Zpc2libGVTZXJpZXMpO1xuICAgIH1cbiAgICBjb25zdCBzaG93biA9IGxvYWRpbmdTaG93biB8fCBub0RhdGFTaG93biB8fCBub1Zpc2libGVTZXJpZXNTaG93bjtcbiAgICBzZXRBdHRyaWJ1dGUodGhpcy5vdmVybGF5RWxlbSwgXCJhcmlhLWhpZGRlblwiLCAhc2hvd24pO1xuICB9XG4gIHNob3dPdmVybGF5KG92ZXJsYXksIHNlcmllc1JlY3QpIHtcbiAgICBjb25zdCBlbGVtZW50MiA9IG92ZXJsYXkuZ2V0RWxlbWVudCh0aGlzLmFuaW1hdGlvbk1hbmFnZXIsIHRoaXMubG9jYWxlTWFuYWdlciwgc2VyaWVzUmVjdCk7XG4gICAgdGhpcy5vdmVybGF5RWxlbS5hcHBlbmRDaGlsZChlbGVtZW50Mik7XG4gIH1cbiAgaGlkZU92ZXJsYXkob3ZlcmxheSkge1xuICAgIG92ZXJsYXkucmVtb3ZlRWxlbWVudCgoKSA9PiB7XG4gICAgICB0aGlzLm92ZXJsYXlFbGVtLmlubmVyVGV4dCA9IFwiXFx4QTBcIjtcbiAgICB9LCB0aGlzLmFuaW1hdGlvbk1hbmFnZXIpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9jaGFydC50c1xudmFyIGRlYnVnID0gRGVidWcuY3JlYXRlKHRydWUsIFwib3B0c1wiKTtcbnZhciBTZXJpZXNBcmVhID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5wYWRkaW5nID0gbmV3IFBhZGRpbmcoMCk7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBTZXJpZXNBcmVhLnByb3RvdHlwZSwgXCJjbGlwXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgU2VyaWVzQXJlYS5wcm90b3R5cGUsIFwicGFkZGluZ1wiLCAyKTtcbnZhciBfQ2hhcnQgPSBjbGFzcyBfQ2hhcnQgZXh0ZW5kcyBPYnNlcnZhYmxlIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucywgcmVzb3VyY2VzKSB7XG4gICAgdmFyIF9hO1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5pZCA9IGNyZWF0ZUlkKHRoaXMpO1xuICAgIHRoaXMuc2VyaWVzUm9vdCA9IG5ldyBUcmFuc2xhdGFibGVHcm91cCh7IG5hbWU6IGAke3RoaXMuaWR9LXNlcmllcy1yb290YCB9KTtcbiAgICB0aGlzLmhpZ2hsaWdodFJvb3QgPSBuZXcgVHJhbnNsYXRhYmxlTGF5ZXIoe1xuICAgICAgbmFtZTogYCR7dGhpcy5pZH0taGlnaGxpZ2h0LXJvb3RgLFxuICAgICAgekluZGV4OiA1IC8qIFNFUklFU19ISUdITElHSFQgKi8sXG4gICAgICBkZXJpdmVaSW5kZXhGcm9tQ2hpbGRyZW46IHRydWVcbiAgICAgIC8vIFRPRE8gcmVtb3ZlIGZlYXR1cmVcbiAgICB9KTtcbiAgICB0aGlzLmFubm90YXRpb25Sb290ID0gbmV3IFRyYW5zbGF0YWJsZUxheWVyKHtcbiAgICAgIG5hbWU6IGAke3RoaXMuaWR9LWFubm90YXRpb24tcm9vdGAsXG4gICAgICB6SW5kZXg6IDEwIC8qIFNFUklFU19BTk5PVEFUSU9OICovXG4gICAgfSk7XG4gICAgdGhpcy5kZWJ1ZyA9IERlYnVnLmNyZWF0ZSgpO1xuICAgIHRoaXMuZXh0cmFEZWJ1Z1N0YXRzID0ge307XG4gICAgdGhpcy5kYXRhID0gW107XG4gICAgdGhpcy5fZmlyc3RBdXRvU2l6ZSA9IHRydWU7XG4gICAgdGhpcy5wYWRkaW5nID0gbmV3IFBhZGRpbmcoMjApO1xuICAgIHRoaXMuc2VyaWVzQXJlYSA9IG5ldyBTZXJpZXNBcmVhKCk7XG4gICAgdGhpcy5rZXlib2FyZCA9IG5ldyBLZXlib2FyZCgpO1xuICAgIHRoaXMubW9kZSA9IFwic3RhbmRhbG9uZVwiO1xuICAgIHRoaXMuY2hhcnRDYXB0aW9ucyA9IG5ldyBDaGFydENhcHRpb25zKCk7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9kZXN0cm95Rm5zID0gW107XG4gICAgLy8gVXNlZCB0byBwcmV2ZW50IGluZmluaXRlIHVwZGF0ZSBsb29wcyB3aGVuIHN5bmNpbmcgY2hhcnRzLlxuICAgIHRoaXMuc2tpcFN5bmMgPSBmYWxzZTtcbiAgICB0aGlzLmNoYXJ0QW5pbWF0aW9uUGhhc2UgPSBcImluaXRpYWxcIjtcbiAgICB0aGlzLm1vZHVsZXNNYW5hZ2VyID0gbmV3IE1vZHVsZXNNYW5hZ2VyKCk7XG4gICAgdGhpcy5wcm9jZXNzb3JzID0gW107XG4gICAgdGhpcy5xdWV1ZWRVc2VyT3B0aW9ucyA9IFtdO1xuICAgIHRoaXMuX3BlbmRpbmdGYWN0b3J5VXBkYXRlc0NvdW50ID0gMDtcbiAgICB0aGlzLl9wZXJmb3JtVXBkYXRlTm9SZW5kZXJDb3VudCA9IDA7XG4gICAgdGhpcy5fcGVyZm9ybVVwZGF0ZVNraXBBbmltYXRpb25zID0gZmFsc2U7XG4gICAgdGhpcy5wZXJmb3JtVXBkYXRlVHlwZSA9IDcgLyogTk9ORSAqLztcbiAgICB0aGlzLnVwZGF0ZVNob3J0Y3V0Q291bnQgPSAwO1xuICAgIHRoaXMuc2VyaWVzVG9VcGRhdGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMudXBkYXRlTXV0ZXggPSBuZXcgTXV0ZXgoKTtcbiAgICB0aGlzLnVwZGF0ZVJlcXVlc3RvcnMgPSB7fTtcbiAgICB0aGlzLnBlcmZvcm1VcGRhdGVUcmlnZ2VyID0gZGVib3VuY2VkQ2FsbGJhY2soYXN5bmMgKHsgY291bnQgfSkgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKVxuICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLnVwZGF0ZU11dGV4LmFjcXVpcmUoYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHRoaXMucGVyZm9ybVVwZGF0ZShjb3VudCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgTG9nZ2VyLmVycm9yKFwidXBkYXRlIGVycm9yXCIsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfSkuY2F0Y2goKGUpID0+IExvZ2dlci5lcnJvck9uY2UoZSkpO1xuICAgIH0pO1xuICAgIHRoaXMuX3BlcmZvcm1VcGRhdGVTcGxpdHMgPSB7fTtcbiAgICB0aGlzLmF4ZXMgPSBbXTtcbiAgICB0aGlzLnNlcmllcyA9IFtdO1xuICAgIHRoaXMub25TZXJpZXNOb2RlQ2xpY2sgPSAoZXZlbnQpID0+IHtcbiAgICAgIHRoaXMuZmlyZUV2ZW50KHsgLi4uZXZlbnQsIHR5cGU6IFwic2VyaWVzTm9kZUNsaWNrXCIgfSk7XG4gICAgfTtcbiAgICB0aGlzLm9uU2VyaWVzTm9kZURvdWJsZUNsaWNrID0gKGV2ZW50KSA9PiB7XG4gICAgICB0aGlzLmZpcmVFdmVudCh7IC4uLmV2ZW50LCB0eXBlOiBcInNlcmllc05vZGVEb3VibGVDbGlja1wiIH0pO1xuICAgIH07XG4gICAgdGhpcy5zZXJpZXNHcm91cGluZ0NoYW5nZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgIGlmICghKGV2ZW50IGluc3RhbmNlb2YgU2VyaWVzR3JvdXBpbmdDaGFuZ2VkRXZlbnQpKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCB7IHNlcmllcywgc2VyaWVzR3JvdXBpbmcsIG9sZEdyb3VwaW5nIH0gPSBldmVudDtcbiAgICAgIGlmIChzZXJpZXMucm9vdEdyb3VwLmlzUm9vdCgpKVxuICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLnNlcmllc0xheWVyTWFuYWdlci5jaGFuZ2VHcm91cCh7XG4gICAgICAgIGludGVybmFsSWQ6IHNlcmllcy5pbnRlcm5hbElkLFxuICAgICAgICB0eXBlOiBzZXJpZXMudHlwZSxcbiAgICAgICAgcm9vdEdyb3VwOiBzZXJpZXMucm9vdEdyb3VwLFxuICAgICAgICBoaWdobGlnaHRHcm91cDogc2VyaWVzLmhpZ2hsaWdodEdyb3VwLFxuICAgICAgICBhbm5vdGF0aW9uR3JvdXA6IHNlcmllcy5hbm5vdGF0aW9uR3JvdXAsXG4gICAgICAgIGdldEdyb3VwWkluZGV4U3ViT3JkZXI6ICh0eXBlKSA9PiBzZXJpZXMuZ2V0R3JvdXBaSW5kZXhTdWJPcmRlcih0eXBlKSxcbiAgICAgICAgc2VyaWVzR3JvdXBpbmcsXG4gICAgICAgIG9sZEdyb3VwaW5nXG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMuY2hhcnRPcHRpb25zID0gb3B0aW9ucztcbiAgICBjb25zdCBzY2VuZSA9IHJlc291cmNlcz8uc2NlbmU7XG4gICAgY29uc3QgY29udGFpbmVyID0gcmVzb3VyY2VzPy5jb250YWluZXIgPz8gb3B0aW9ucy5wcm9jZXNzZWRPcHRpb25zLmNvbnRhaW5lciA/PyB2b2lkIDA7XG4gICAgY29uc3Qgc3R5bGVDb250YWluZXIgPSByZXNvdXJjZXM/LnN0eWxlQ29udGFpbmVyID8/IG9wdGlvbnMuc3BlY2lhbE92ZXJyaWRlcy5zdHlsZUNvbnRhaW5lcjtcbiAgICBjb25zdCByb290ID0gbmV3IEdyb3VwKHsgbmFtZTogXCJyb290XCIgfSk7XG4gICAgY29uc3QgdGl0bGVHcm91cCA9IG5ldyBMYXllcih7IG5hbWU6IFwidGl0bGVzXCIsIHpJbmRleDogMTQgLyogU0VSSUVTX0xBQkVMICovIH0pO1xuICAgIHJvb3QudmlzaWJsZSA9IGZhbHNlO1xuICAgIHJvb3QuYXBwZW5kKHRpdGxlR3JvdXApO1xuICAgIHJvb3QuYXBwZW5kKHRoaXMuc2VyaWVzUm9vdCk7XG4gICAgcm9vdC5hcHBlbmQodGhpcy5oaWdobGlnaHRSb290KTtcbiAgICByb290LmFwcGVuZCh0aGlzLmFubm90YXRpb25Sb290KTtcbiAgICB0aXRsZUdyb3VwLmFwcGVuZCh0aGlzLnRpdGxlLm5vZGUpO1xuICAgIHRpdGxlR3JvdXAuYXBwZW5kKHRoaXMuc3VidGl0bGUubm9kZSk7XG4gICAgdGl0bGVHcm91cC5hcHBlbmQodGhpcy5mb290bm90ZS5ub2RlKTtcbiAgICB0aGlzLnRvb2x0aXAgPSBuZXcgVG9vbHRpcCgpO1xuICAgIHRoaXMuc2VyaWVzTGF5ZXJNYW5hZ2VyID0gbmV3IFNlcmllc0xheWVyTWFuYWdlcih0aGlzLnNlcmllc1Jvb3QsIHRoaXMuaGlnaGxpZ2h0Um9vdCwgdGhpcy5hbm5vdGF0aW9uUm9vdCk7XG4gICAgdGhpcy5tb2RlID0gb3B0aW9ucy51c2VyT3B0aW9ucy5tb2RlID8/IHRoaXMubW9kZTtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eCA9IG5ldyBDaGFydENvbnRleHQodGhpcywge1xuICAgICAgc2NlbmUsXG4gICAgICByb290LFxuICAgICAgY29udGFpbmVyLFxuICAgICAgc3R5bGVDb250YWluZXIsXG4gICAgICBzeW5jTWFuYWdlcjogbmV3IFN5bmNNYW5hZ2VyKHRoaXMpLFxuICAgICAgcGl4ZWxSYXRpbzogb3B0aW9ucy5zcGVjaWFsT3ZlcnJpZGVzLm92ZXJyaWRlRGV2aWNlUGl4ZWxSYXRpbyxcbiAgICAgIHVwZGF0ZUNhbGxiYWNrOiAodHlwZSA9IDAgLyogRlVMTCAqLywgb3B0cykgPT4gdGhpcy51cGRhdGUodHlwZSwgb3B0cyksXG4gICAgICB1cGRhdGVNdXRleDogdGhpcy51cGRhdGVNdXRleFxuICAgIH0pO1xuICAgIHRoaXMuX2Rlc3Ryb3lGbnMucHVzaChcbiAgICAgIGN0eC5kb21NYW5hZ2VyLmFkZExpc3RlbmVyKFwicmVzaXplXCIsICgpID0+IHRoaXMucGFyZW50UmVzaXplKGN0eC5kb21NYW5hZ2VyLmNvbnRhaW5lclNpemUpKVxuICAgICk7XG4gICAgdGhpcy5vdmVybGF5cyA9IG5ldyBDaGFydE92ZXJsYXlzKCk7XG4gICAgKF9hID0gdGhpcy5vdmVybGF5cy5sb2FkaW5nKS5yZW5kZXJlciA/PyAoX2EucmVuZGVyZXIgPSAoKSA9PiBnZXRMb2FkaW5nU3Bpbm5lcih0aGlzLm92ZXJsYXlzLmxvYWRpbmcuZ2V0VGV4dChjdHgubG9jYWxlTWFuYWdlciksIGN0eC5hbmltYXRpb25NYW5hZ2VyLmRlZmF1bHREdXJhdGlvbikpO1xuICAgIHRoaXMucHJvY2Vzc29ycyA9IFtcbiAgICAgIG5ldyBEYXRhV2luZG93UHJvY2Vzc29yKHRoaXMsIGN0eC5kYXRhU2VydmljZSwgY3R4LnVwZGF0ZVNlcnZpY2UsIGN0eC56b29tTWFuYWdlciksXG4gICAgICBuZXcgT3ZlcmxheXNQcm9jZXNzb3IoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHRoaXMub3ZlcmxheXMsXG4gICAgICAgIGN0eC5kYXRhU2VydmljZSxcbiAgICAgICAgY3R4LmxheW91dE1hbmFnZXIsXG4gICAgICAgIGN0eC5sb2NhbGVNYW5hZ2VyLFxuICAgICAgICBjdHguYW5pbWF0aW9uTWFuYWdlcixcbiAgICAgICAgY3R4LmRvbU1hbmFnZXJcbiAgICAgIClcbiAgICBdO1xuICAgIHRoaXMuaGlnaGxpZ2h0ID0gbmV3IENoYXJ0SGlnaGxpZ2h0KCk7XG4gICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgY29uc3QgbW9kdWxlQ29udGV4dCA9IHRoaXMuZ2V0TW9kdWxlQ29udGV4dCgpO1xuICAgIGN0eC5yZWdpb25NYW5hZ2VyLmFkZFJlZ2lvbihcbiAgICAgIFwic2VyaWVzXCIgLyogU0VSSUVTICovLFxuICAgICAgdGhpcy5zZXJpZXNSb290LFxuICAgICAgbmV3IFNpbXBsZVJlZ2lvbkJCb3hQcm92aWRlcih0aGlzLnNlcmllc1Jvb3QsICgpID0+IHRoaXMuc2VyaWVzUmVjdCA/PyBCQm94Lnplcm8pLFxuICAgICAgdGhpcy5jdHguYXhpc01hbmFnZXIuYXhpc0dyaWRHcm91cFxuICAgICk7XG4gICAgY3R4LnJlZ2lvbk1hbmFnZXIuYWRkUmVnaW9uKFwiaG9yaXpvbnRhbC1heGVzXCIgLyogSE9SSVpPTlRBTF9BWEVTICovKTtcbiAgICBjdHgucmVnaW9uTWFuYWdlci5hZGRSZWdpb24oXCJ2ZXJ0aWNhbC1heGVzXCIgLyogVkVSVElDQUxfQVhFUyAqLyk7XG4gICAgY3R4LnJlZ2lvbk1hbmFnZXIuYWRkUmVnaW9uKFwicm9vdFwiLCByb290KTtcbiAgICBjdHguZG9tTWFuYWdlci5zZXREYXRhQm9vbGVhbihcImFuaW1hdGluZ1wiLCBmYWxzZSk7XG4gICAgdGhpcy5zZXJpZXNBcmVhTWFuYWdlciA9IG5ldyBTZXJpZXNBcmVhTWFuYWdlcih0aGlzLmluaXRTZXJpZXNBcmVhRGVwZW5kZW5jaWVzKCkpO1xuICAgIHRoaXMuX2Rlc3Ryb3lGbnMucHVzaChcbiAgICAgIGN0eC5sYXlvdXRNYW5hZ2VyLnJlZ2lzdGVyRWxlbWVudCgwIC8qIENhcHRpb24gKi8sIChlKSA9PiB7XG4gICAgICAgIGUubGF5b3V0Qm94LnNocmluayh0aGlzLnBhZGRpbmcudG9Kc29uKCkpO1xuICAgICAgICB0aGlzLmNoYXJ0Q2FwdGlvbnMucG9zaXRpb25DYXB0aW9ucyhlKTtcbiAgICAgIH0pLFxuICAgICAgY3R4LmxheW91dE1hbmFnZXIuYWRkTGlzdGVuZXIoXCJsYXlvdXQ6Y29tcGxldGVcIiwgKGUpID0+IHRoaXMuY2hhcnRDYXB0aW9ucy5wb3NpdGlvbkFic29sdXRlQ2FwdGlvbnMoZSkpLFxuICAgICAgY3R4LmRhdGFTZXJ2aWNlLmFkZExpc3RlbmVyKFwiZGF0YS1sb2FkXCIsIChldmVudCkgPT4ge1xuICAgICAgICB0aGlzLmRhdGEgPSBldmVudC5kYXRhO1xuICAgICAgfSksXG4gICAgICB0aGlzLnRpdGxlLnJlZ2lzdGVySW50ZXJhY3Rpb24obW9kdWxlQ29udGV4dCwgXCJiZWZvcmViZWdpblwiKSxcbiAgICAgIHRoaXMuc3VidGl0bGUucmVnaXN0ZXJJbnRlcmFjdGlvbihtb2R1bGVDb250ZXh0LCBcImJlZm9yZWJlZ2luXCIpLFxuICAgICAgdGhpcy5mb290bm90ZS5yZWdpc3RlckludGVyYWN0aW9uKG1vZHVsZUNvbnRleHQsIFwiYWZ0ZXJlbmRcIiksXG4gICAgICBjdHguaW50ZXJhY3Rpb25NYW5hZ2VyLmFkZExpc3RlbmVyKFwicGFnZS1sZWZ0XCIsICgpID0+IHRoaXMuZGVzdHJveSgpKSxcbiAgICAgIGN0eC5hbmltYXRpb25NYW5hZ2VyLmFkZExpc3RlbmVyKFwiYW5pbWF0aW9uLWZyYW1lXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy51cGRhdGUoNiAvKiBTQ0VORV9SRU5ERVIgKi8pO1xuICAgICAgfSksXG4gICAgICBjdHguYW5pbWF0aW9uTWFuYWdlci5hZGRMaXN0ZW5lcihcImFuaW1hdGlvbi1zdGFydFwiLCAoKSA9PiBjdHguZG9tTWFuYWdlci5zZXREYXRhQm9vbGVhbihcImFuaW1hdGluZ1wiLCB0cnVlKSksXG4gICAgICBjdHguYW5pbWF0aW9uTWFuYWdlci5hZGRMaXN0ZW5lcihcImFuaW1hdGlvbi1zdG9wXCIsICgpID0+IGN0eC5kb21NYW5hZ2VyLnNldERhdGFCb29sZWFuKFwiYW5pbWF0aW5nXCIsIGZhbHNlKSksXG4gICAgICBjdHguem9vbU1hbmFnZXIuYWRkTGlzdGVuZXIoXCJ6b29tLWNoYW5nZVwiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuc2VyaWVzLmZvckVhY2goKHMpID0+IHMuYW5pbWF0aW9uU3RhdGU/LnRyYW5zaXRpb24oXCJ1cGRhdGVEYXRhXCIpKTtcbiAgICAgICAgY29uc3Qgc2tpcEFuaW1hdGlvbnMgPSB0aGlzLmNoYXJ0QW5pbWF0aW9uUGhhc2UgIT09IFwiaW5pdGlhbFwiO1xuICAgICAgICB0aGlzLnVwZGF0ZSgzIC8qIFBFUkZPUk1fTEFZT1VUICovLCB7IGZvcmNlTm9kZURhdGFSZWZyZXNoOiB0cnVlLCBza2lwQW5pbWF0aW9ucyB9KTtcbiAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzLnBhcmVudFJlc2l6ZShjdHguZG9tTWFuYWdlci5jb250YWluZXJTaXplKTtcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UoZWxlbWVudDIpIHtcbiAgICByZXR1cm4gX0NoYXJ0LmNoYXJ0c0luc3RhbmNlcy5nZXQoZWxlbWVudDIpO1xuICB9XG4gIC8qKiBOT1RFOiBUaGlzIGlzIGV4cG9zZWQgZm9yIHVzZSBieSBJbnRlZ3JhdGVkIGNoYXJ0cyBvbmx5LiAqL1xuICBnZXQgY2FudmFzRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5jdHguc2NlbmUuY2FudmFzLmVsZW1lbnQ7XG4gIH1cbiAgZG93bmxvYWQoZmlsZU5hbWUsIGZpbGVGb3JtYXQpIHtcbiAgICB0aGlzLmN0eC5zY2VuZS5kb3dubG9hZChmaWxlTmFtZSwgZmlsZUZvcm1hdCk7XG4gIH1cbiAgZ2V0Q2FudmFzRGF0YVVSTChmaWxlRm9ybWF0KSB7XG4gICAgcmV0dXJuIHRoaXMuY3R4LnNjZW5lLmdldERhdGFVUkwoZmlsZUZvcm1hdCk7XG4gIH1cbiAgdG9TVkcoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3R4LnNjZW5lLnRvU1ZHKCk7XG4gIH1cbiAgZ2V0T3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5xdWV1ZWRVc2VyT3B0aW9ucy5hdCgtMSkgPz8gdGhpcy5jaGFydE9wdGlvbnMudXNlck9wdGlvbnM7XG4gIH1cbiAgaW5pdFNlcmllc0FyZWFEZXBlbmRlbmNpZXMoKSB7XG4gICAgY29uc3QgeyBjdHgsIHRvb2x0aXAsIGhpZ2hsaWdodCwgb3ZlcmxheXMsIHNlcmllc1Jvb3QgfSA9IHRoaXM7XG4gICAgY29uc3QgY2hhcnRUeXBlMiA9IHRoaXMuZ2V0Q2hhcnRUeXBlKCk7XG4gICAgY29uc3QgZmlyZUV2ZW50ID0gdGhpcy5maXJlRXZlbnQuYmluZCh0aGlzKTtcbiAgICBjb25zdCBnZXRVcGRhdGVUeXBlID0gKCkgPT4gdGhpcy5wZXJmb3JtVXBkYXRlVHlwZTtcbiAgICByZXR1cm4geyBmaXJlRXZlbnQsIGdldFVwZGF0ZVR5cGUsIGNoYXJ0VHlwZTogY2hhcnRUeXBlMiwgY3R4LCB0b29sdGlwLCBoaWdobGlnaHQsIG92ZXJsYXlzLCBzZXJpZXNSb290IH07XG4gIH1cbiAgZ2V0TW9kdWxlQ29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5jdHg7XG4gIH1cbiAgZ2V0Q2FwdGlvblRleHQoKSB7XG4gICAgcmV0dXJuIFt0aGlzLnRpdGxlLCB0aGlzLnN1YnRpdGxlLCB0aGlzLmZvb3Rub3RlXS5maWx0ZXIoKGNhcHRpb24pID0+IGNhcHRpb24uZW5hYmxlZCAmJiBjYXB0aW9uLnRleHQpLm1hcCgoY2FwdGlvbikgPT4gY2FwdGlvbi50ZXh0KS5qb2luKFwiLiBcIik7XG4gIH1cbiAgZ2V0QXJpYUxhYmVsKCkge1xuICAgIHJldHVybiB0aGlzLmN0eC5sb2NhbGVNYW5hZ2VyLnQoXCJhcmlhQW5ub3VuY2VDaGFydFwiLCB7IHNlcmllc0NvdW50OiB0aGlzLnNlcmllcy5sZW5ndGggfSk7XG4gIH1cbiAgcmVzZXRBbmltYXRpb25zKCkge1xuICAgIHRoaXMuY2hhcnRBbmltYXRpb25QaGFzZSA9IFwiaW5pdGlhbFwiO1xuICAgIGZvciAoY29uc3Qgc2VyaWVzIG9mIHRoaXMuc2VyaWVzKSB7XG4gICAgICBzZXJpZXMucmVzZXRBbmltYXRpb24odGhpcy5jaGFydEFuaW1hdGlvblBoYXNlKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBheGlzIG9mIHRoaXMuYXhlcykge1xuICAgICAgYXhpcy5yZXNldEFuaW1hdGlvbih0aGlzLmNoYXJ0QW5pbWF0aW9uUGhhc2UpO1xuICAgIH1cbiAgICB0aGlzLmFuaW1hdGlvblJlY3QgPSB2b2lkIDA7XG4gICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5yZXNldCgpO1xuICB9XG4gIHNraXBBbmltYXRpb25zKCkge1xuICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuc2tpcEN1cnJlbnRCYXRjaCgpO1xuICAgIHRoaXMuX3BlcmZvcm1VcGRhdGVTa2lwQW5pbWF0aW9ucyA9IHRydWU7XG4gIH1cbiAgZGVzdHJveShvcHRzKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGtlZXBUcmFuc2ZlcmFibGVSZXNvdXJjZXMgPSBvcHRzPy5rZWVwVHJhbnNmZXJhYmxlUmVzb3VyY2VzO1xuICAgIGxldCByZXN1bHQ7XG4gICAgdGhpcy5wZXJmb3JtVXBkYXRlVHlwZSA9IDcgLyogTk9ORSAqLztcbiAgICB0aGlzLl9kZXN0cm95Rm5zLmZvckVhY2goKGZuKSA9PiBmbigpKTtcbiAgICB0aGlzLnByb2Nlc3NvcnMuZm9yRWFjaCgocCkgPT4gcC5kZXN0cm95KCkpO1xuICAgIHRoaXMudG9vbHRpcC5kZXN0cm95KHRoaXMuY3R4LmRvbU1hbmFnZXIpO1xuICAgIHRoaXMub3ZlcmxheXMuZGVzdHJveSgpO1xuICAgIHRoaXMubW9kdWxlc01hbmFnZXIuZGVzdHJveSgpO1xuICAgIGlmIChrZWVwVHJhbnNmZXJhYmxlUmVzb3VyY2VzKSB7XG4gICAgICB0aGlzLmN0eC5zY2VuZS5zdHJpcCgpO1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBjb250YWluZXI6IHRoaXMuY29udGFpbmVyLFxuICAgICAgICBzY2VuZTogdGhpcy5jdHguc2NlbmVcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3R4LnNjZW5lLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuY29udGFpbmVyID0gdm9pZCAwO1xuICAgIH1cbiAgICB0aGlzLmRlc3Ryb3lTZXJpZXModGhpcy5zZXJpZXMpO1xuICAgIHRoaXMuc2VyaWVzTGF5ZXJNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmF4ZXMuZm9yRWFjaCgoYSkgPT4gYS5kZXN0cm95KCkpO1xuICAgIHRoaXMuYXhlcyA9IFtdO1xuICAgIHRoaXMuYW5pbWF0aW9uUmVjdCA9IHZvaWQgMDtcbiAgICB0aGlzLmN0eC5kZXN0cm95KCk7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICByZXF1ZXN0RmFjdG9yeVVwZGF0ZShjYikge1xuICAgIGlmICh0aGlzLmRlc3Ryb3llZClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9wZW5kaW5nRmFjdG9yeVVwZGF0ZXNDb3VudCsrO1xuICAgIHRoaXMudXBkYXRlTXV0ZXguYWNxdWlyZShhc3luYyAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGF3YWl0IGNiKHRoaXMpO1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKVxuICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLl9wZW5kaW5nRmFjdG9yeVVwZGF0ZXNDb3VudC0tO1xuICAgIH0pLmNhdGNoKChlKSA9PiBMb2dnZXIuZXJyb3JPbmNlKGUpKTtcbiAgfVxuICB1cGRhdGUodHlwZSA9IDAgLyogRlVMTCAqLywgb3B0cykge1xuICAgIGNvbnN0IHtcbiAgICAgIGZvcmNlTm9kZURhdGFSZWZyZXNoID0gZmFsc2UsXG4gICAgICBza2lwQW5pbWF0aW9ucyxcbiAgICAgIHNlcmllc1RvVXBkYXRlID0gdGhpcy5zZXJpZXMsXG4gICAgICBuZXdBbmltYXRpb25CYXRjaFxuICAgIH0gPSBvcHRzID8/IHt9O1xuICAgIGlmIChmb3JjZU5vZGVEYXRhUmVmcmVzaCkge1xuICAgICAgdGhpcy5zZXJpZXMuZm9yRWFjaCgoc2VyaWVzKSA9PiBzZXJpZXMubWFya05vZGVEYXRhRGlydHkoKSk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgc2VyaWVzIG9mIHNlcmllc1RvVXBkYXRlKSB7XG4gICAgICB0aGlzLnNlcmllc1RvVXBkYXRlLmFkZChzZXJpZXMpO1xuICAgIH1cbiAgICBpZiAoc2tpcEFuaW1hdGlvbnMpIHtcbiAgICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuc2tpcEN1cnJlbnRCYXRjaCgpO1xuICAgICAgdGhpcy5fcGVyZm9ybVVwZGF0ZVNraXBBbmltYXRpb25zID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG5ld0FuaW1hdGlvbkJhdGNoICYmIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuaXNBY3RpdmUoKSkge1xuICAgICAgdGhpcy5fcGVyZm9ybVVwZGF0ZVNraXBBbmltYXRpb25zID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5za2lwU3luYyA9IG9wdHM/LnNraXBTeW5jID8/IGZhbHNlO1xuICAgIGlmICh0aGlzLmRlYnVnLmNoZWNrKCkpIHtcbiAgICAgIGxldCBzdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrID8/IFwiPHVua25vd24+XCI7XG4gICAgICBzdGFjayA9IHN0YWNrLnJlcGxhY2UoL1xcKFteKV0qL2csIFwiXCIpO1xuICAgICAgdGhpcy51cGRhdGVSZXF1ZXN0b3JzW3N0YWNrXSA9IHR5cGU7XG4gICAgfVxuICAgIGlmICh0eXBlIDwgdGhpcy5wZXJmb3JtVXBkYXRlVHlwZSkge1xuICAgICAgdGhpcy5wZXJmb3JtVXBkYXRlVHlwZSA9IHR5cGU7XG4gICAgICB0aGlzLmN0eC5kb21NYW5hZ2VyLnNldERhdGFCb29sZWFuKFwidXBkYXRlUGVuZGluZ1wiLCB0cnVlKTtcbiAgICAgIHRoaXMucGVyZm9ybVVwZGF0ZVRyaWdnZXIuc2NoZWR1bGUob3B0cz8uYmFja09mZk1zKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgcGVyZm9ybVVwZGF0ZShjb3VudCkge1xuICAgIGNvbnN0IHsgcGVyZm9ybVVwZGF0ZVR5cGUsIGV4dHJhRGVidWdTdGF0cywgX3BlcmZvcm1VcGRhdGVTcGxpdHM6IHNwbGl0cywgY3R4IH0gPSB0aGlzO1xuICAgIGNvbnN0IHNlcmllc1RvVXBkYXRlID0gWy4uLnRoaXMuc2VyaWVzVG9VcGRhdGVdO1xuICAgIHRoaXMucGVyZm9ybVVwZGF0ZVR5cGUgPSA3IC8qIE5PTkUgKi87XG4gICAgdGhpcy5zZXJpZXNUb1VwZGF0ZS5jbGVhcigpO1xuICAgIGlmICh0aGlzLnVwZGF0ZVNob3J0Y3V0Q291bnQgPT09IDAgJiYgcGVyZm9ybVVwZGF0ZVR5cGUgPCA2IC8qIFNDRU5FX1JFTkRFUiAqLykge1xuICAgICAgY3R4LmFuaW1hdGlvbk1hbmFnZXIuc3RhcnRCYXRjaCh0aGlzLl9wZXJmb3JtVXBkYXRlU2tpcEFuaW1hdGlvbnMpO1xuICAgICAgY3R4LmFuaW1hdGlvbk1hbmFnZXIub25CYXRjaFN0b3AoKCkgPT4gdGhpcy5jaGFydEFuaW1hdGlvblBoYXNlID0gXCJyZWFkeVwiKTtcbiAgICB9XG4gICAgdGhpcy5kZWJ1ZyhcIkNoYXJ0LnBlcmZvcm1VcGRhdGUoKSAtIHN0YXJ0XCIsIENoYXJ0VXBkYXRlVHlwZVtwZXJmb3JtVXBkYXRlVHlwZV0pO1xuICAgIGxldCBwcmV2aW91c1NwbGl0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgc3BsaXRzLnN0YXJ0ID8/IChzcGxpdHMuc3RhcnQgPSBwcmV2aW91c1NwbGl0KTtcbiAgICBjb25zdCB1cGRhdGVTcGxpdHMgPSAoc3BsaXROYW1lKSA9PiB7XG4gICAgICBzcGxpdHNbc3BsaXROYW1lXSA/PyAoc3BsaXRzW3NwbGl0TmFtZV0gPSAwKTtcbiAgICAgIHNwbGl0c1tzcGxpdE5hbWVdICs9IHBlcmZvcm1hbmNlLm5vdygpIC0gcHJldmlvdXNTcGxpdDtcbiAgICAgIHByZXZpb3VzU3BsaXQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9O1xuICAgIGxldCB1cGRhdGVEZWZlcnJlZCA9IGZhbHNlO1xuICAgIHN3aXRjaCAocGVyZm9ybVVwZGF0ZVR5cGUpIHtcbiAgICAgIGNhc2UgMCAvKiBGVUxMICovOlxuICAgICAgICB0aGlzLmN0eC51cGRhdGVTZXJ2aWNlLmRpc3BhdGNoUHJlRG9tVXBkYXRlKCk7XG4gICAgICAgIHRoaXMudXBkYXRlRE9NKCk7XG4gICAgICBjYXNlIDEgLyogVVBEQVRFX0RBVEEgKi86XG4gICAgICAgIGF3YWl0IHRoaXMudXBkYXRlRGF0YSgpO1xuICAgICAgICB1cGRhdGVTcGxpdHMoXCJcXHUyQjA3XFx1RkUwRlwiKTtcbiAgICAgIGNhc2UgMiAvKiBQUk9DRVNTX0RBVEEgKi86XG4gICAgICAgIGF3YWl0IHRoaXMucHJvY2Vzc0RhdGEoKTtcbiAgICAgICAgdGhpcy5zZXJpZXNBcmVhTWFuYWdlci5kYXRhQ2hhbmdlZCgpO1xuICAgICAgICB1cGRhdGVTcGxpdHMoXCJcXHV7MUYzRUR9XCIpO1xuICAgICAgY2FzZSAzIC8qIFBFUkZPUk1fTEFZT1VUICovOlxuICAgICAgICBpZiAodGhpcy5jaGVja1VwZGF0ZVNob3J0Y3V0KDMgLyogUEVSRk9STV9MQVlPVVQgKi8pKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAoIXRoaXMuY2hlY2tGaXJzdEF1dG9TaXplKHNlcmllc1RvVXBkYXRlKSkge1xuICAgICAgICAgIHVwZGF0ZURlZmVycmVkID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLnByb2Nlc3NMYXlvdXQoKTtcbiAgICAgICAgdXBkYXRlU3BsaXRzKFwiXFx1MjMxNlwiKTtcbiAgICAgIGNhc2UgNCAvKiBTRVJJRVNfVVBEQVRFICovOiB7XG4gICAgICAgIGlmICh0aGlzLmNoZWNrVXBkYXRlU2hvcnRjdXQoNCAvKiBTRVJJRVNfVVBEQVRFICovKSlcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY29uc3QgeyBzZXJpZXNSZWN0IH0gPSB0aGlzO1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChzZXJpZXNUb1VwZGF0ZS5tYXAoKHNlcmllcykgPT4gc2VyaWVzLnVwZGF0ZSh7IHNlcmllc1JlY3QgfSkpKTtcbiAgICAgICAgdXBkYXRlU3BsaXRzKFwiXFx1ezFGOTE0fVwiKTtcbiAgICAgICAgdGhpcy51cGRhdGVBcmlhTGFiZWxzKCk7XG4gICAgICB9XG4gICAgICBjYXNlIDUgLyogUFJFX1NDRU5FX1JFTkRFUiAqLzpcbiAgICAgICAgaWYgKHRoaXMuY2hlY2tVcGRhdGVTaG9ydGN1dCg1IC8qIFBSRV9TQ0VORV9SRU5ERVIgKi8pKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjdHgudXBkYXRlU2VydmljZS5kaXNwYXRjaFByZVNjZW5lUmVuZGVyKHRoaXMuZ2V0TWluUmVjdHMoKSk7XG4gICAgICAgIHVwZGF0ZVNwbGl0cyhcIlxcdTIxOTZcIik7XG4gICAgICBjYXNlIDYgLyogU0NFTkVfUkVOREVSICovOlxuICAgICAgICBpZiAodGhpcy5jaGVja1VwZGF0ZVNob3J0Y3V0KDYgLyogU0NFTkVfUkVOREVSICovKSlcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY3R4LmFuaW1hdGlvbk1hbmFnZXIuZW5kQmF0Y2goKTtcbiAgICAgICAgZXh0cmFEZWJ1Z1N0YXRzW1widXBkYXRlU2hvcnRjdXRDb3VudFwiXSA9IHRoaXMudXBkYXRlU2hvcnRjdXRDb3VudDtcbiAgICAgICAgYXdhaXQgY3R4LnNjZW5lLnJlbmRlcih7IGRlYnVnU3BsaXRUaW1lczogc3BsaXRzLCBleHRyYURlYnVnU3RhdHMsIHNlcmllc1JlY3Q6IHRoaXMuc2VyaWVzUmVjdCB9KTtcbiAgICAgICAgdGhpcy5leHRyYURlYnVnU3RhdHMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc3BsaXRzKSB7XG4gICAgICAgICAgZGVsZXRlIHNwbGl0c1trZXldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3R4LmRvbU1hbmFnZXIuaW5jcmVtZW50RGF0YUNvdW50ZXIoXCJzY2VuZVJlbmRlcnNcIik7XG4gICAgICBjYXNlIDcgLyogTk9ORSAqLzpcbiAgICAgICAgdGhpcy51cGRhdGVTaG9ydGN1dENvdW50ID0gMDtcbiAgICAgICAgdGhpcy51cGRhdGVSZXF1ZXN0b3JzID0ge307XG4gICAgICAgIHRoaXMuX3BlcmZvcm1VcGRhdGVTa2lwQW5pbWF0aW9ucyA9IGZhbHNlO1xuICAgICAgICBjdHguYW5pbWF0aW9uTWFuYWdlci5lbmRCYXRjaCgpO1xuICAgIH1cbiAgICBpZiAoIXVwZGF0ZURlZmVycmVkKSB7XG4gICAgICBjdHgudXBkYXRlU2VydmljZS5kaXNwYXRjaFVwZGF0ZUNvbXBsZXRlKHRoaXMuZ2V0TWluUmVjdHMoKSk7XG4gICAgICB0aGlzLmN0eC5kb21NYW5hZ2VyLnNldERhdGFCb29sZWFuKFwidXBkYXRlUGVuZGluZ1wiLCBmYWxzZSk7XG4gICAgfVxuICAgIGNvbnN0IGVuZDIgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB0aGlzLmRlYnVnKFwiQ2hhcnQucGVyZm9ybVVwZGF0ZSgpIC0gZW5kXCIsIHtcbiAgICAgIGNoYXJ0OiB0aGlzLFxuICAgICAgZHVyYXRpb25NczogTWF0aC5yb3VuZCgoZW5kMiAtIHNwbGl0c1tcInN0YXJ0XCJdKSAqIDEwMCkgLyAxMDAsXG4gICAgICBjb3VudCxcbiAgICAgIHBlcmZvcm1VcGRhdGVUeXBlOiBDaGFydFVwZGF0ZVR5cGVbcGVyZm9ybVVwZGF0ZVR5cGVdXG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlVGhlbWVDbGFzc05hbWUoKSB7XG4gICAgY29uc3QgeyB0aGVtZSB9ID0gdGhpcy5jaGFydE9wdGlvbnMucHJvY2Vzc2VkT3B0aW9ucztcbiAgICBjb25zdCB0aGVtZUNsYXNzTmFtZVByZWZpeCA9IFwiYWctY2hhcnRzLXRoZW1lLVwiO1xuICAgIGNvbnN0IHZhbGlkVGhlbWVDbGFzc05hbWVzID0gW2Ake3RoZW1lQ2xhc3NOYW1lUHJlZml4fWRlZmF1bHRgLCBgJHt0aGVtZUNsYXNzTmFtZVByZWZpeH1kZWZhdWx0LWRhcmtgXTtcbiAgICBsZXQgdGhlbWVDbGFzc05hbWUgPSB2YWxpZFRoZW1lQ2xhc3NOYW1lc1swXTtcbiAgICBsZXQgaXNEYXJrID0gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiB0aGVtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhlbWVDbGFzc05hbWUgPSB0aGVtZS5yZXBsYWNlKFwiYWctXCIsIHRoZW1lQ2xhc3NOYW1lUHJlZml4KTtcbiAgICAgIGlzRGFyayA9IHRoZW1lLmluY2x1ZGVzKFwiLWRhcmtcIik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGhlbWU/LmJhc2VUaGVtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhlbWVDbGFzc05hbWUgPSB0aGVtZS5iYXNlVGhlbWUucmVwbGFjZShcImFnLVwiLCB0aGVtZUNsYXNzTmFtZVByZWZpeCk7XG4gICAgICBpc0RhcmsgPSB0aGVtZS5iYXNlVGhlbWUuaW5jbHVkZXMoXCItZGFya1wiKTtcbiAgICB9XG4gICAgaWYgKCF2YWxpZFRoZW1lQ2xhc3NOYW1lcy5pbmNsdWRlcyh0aGVtZUNsYXNzTmFtZSkpIHtcbiAgICAgIHRoZW1lQ2xhc3NOYW1lID0gaXNEYXJrID8gdmFsaWRUaGVtZUNsYXNzTmFtZXNbMV0gOiB2YWxpZFRoZW1lQ2xhc3NOYW1lc1swXTtcbiAgICB9XG4gICAgdGhpcy5jdHguZG9tTWFuYWdlci5zZXRUaGVtZUNsYXNzKHRoZW1lQ2xhc3NOYW1lKTtcbiAgfVxuICB1cGRhdGVET00oKSB7XG4gICAgdGhpcy51cGRhdGVUaGVtZUNsYXNzTmFtZSgpO1xuICAgIGNvbnN0IHsgZW5hYmxlZCwgdGFiSW5kZXggfSA9IHRoaXMua2V5Ym9hcmQ7XG4gICAgdGhpcy5jdHguZG9tTWFuYWdlci5zZXRUYWJJbmRleChlbmFibGVkID8gdGFiSW5kZXggPz8gMCA6IC0xKTtcbiAgfVxuICB1cGRhdGVBcmlhTGFiZWxzKCkge1xuICAgIHRoaXMuY3R4LmRvbU1hbmFnZXIudXBkYXRlQ2FudmFzTGFiZWwodGhpcy5nZXRBcmlhTGFiZWwoKSk7XG4gIH1cbiAgY2hlY2tVcGRhdGVTaG9ydGN1dChjaGVja1VwZGF0ZVR5cGUpIHtcbiAgICBjb25zdCBtYXhTaG9ydGN1dHMgPSAzO1xuICAgIGlmICh0aGlzLnVwZGF0ZVNob3J0Y3V0Q291bnQgPiBtYXhTaG9ydGN1dHMpIHtcbiAgICAgIExvZ2dlci53YXJuKFxuICAgICAgICBgZXhjZWVkZWQgdGhlIG1heGltdW0gbnVtYmVyIG9mIHNpbXVsdGFuZW91cyB1cGRhdGVzICgke21heFNob3J0Y3V0cyArIDF9KSwgZGlzY2FyZGluZyBjaGFuZ2VzIGFuZCByZW5kZXJpbmdgLFxuICAgICAgICB0aGlzLnVwZGF0ZVJlcXVlc3RvcnNcbiAgICAgICk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLnBlcmZvcm1VcGRhdGVUeXBlIDw9IGNoZWNrVXBkYXRlVHlwZSkge1xuICAgICAgdGhpcy51cGRhdGVTaG9ydGN1dENvdW50Kys7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNoZWNrRmlyc3RBdXRvU2l6ZShzZXJpZXNUb1VwZGF0ZSkge1xuICAgIGlmICh0aGlzLndpZHRoICE9IG51bGwgJiYgdGhpcy5oZWlnaHQgIT0gbnVsbCkge1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuX2xhc3RBdXRvU2l6ZSkge1xuICAgICAgY29uc3QgY291bnQgPSB0aGlzLl9wZXJmb3JtVXBkYXRlTm9SZW5kZXJDb3VudCsrO1xuICAgICAgY29uc3QgYmFja09mZk1zID0gKGNvdW50ICsgMSkgKiogMiAqIDQwO1xuICAgICAgaWYgKGNvdW50IDwgOCkge1xuICAgICAgICB0aGlzLnVwZGF0ZSgzIC8qIFBFUkZPUk1fTEFZT1VUICovLCB7IHNlcmllc1RvVXBkYXRlLCBiYWNrT2ZmTXMgfSk7XG4gICAgICAgIHRoaXMuZGVidWcoXCJDaGFydC5jaGVja0ZpcnN0QXV0b1NpemUoKSAtIGJhY2tpbmcgb2ZmIHVudGlsIGZpcnN0IHNpemUgdXBkYXRlXCIsIGJhY2tPZmZNcyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGVidWcoXCJDaGFydC5jaGVja0ZpcnN0QXV0b1NpemUoKSAtIHRpbWVvdXQgZm9yIGZpcnN0IHNpemUgdXBkYXRlLlwiKTtcbiAgICB9XG4gICAgdGhpcy5fcGVyZm9ybVVwZGF0ZU5vUmVuZGVyQ291bnQgPSAwO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIG9uQXhpc0NoYW5nZShuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcbiAgICBpZiAob2xkVmFsdWUgPT0gbnVsbCAmJiBuZXdWYWx1ZS5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5jdHguYXhpc01hbmFnZXIudXBkYXRlQXhlcyhvbGRWYWx1ZSA/PyBbXSwgbmV3VmFsdWUpO1xuICB9XG4gIG9uU2VyaWVzQ2hhbmdlKG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xuICAgIGNvbnN0IHNlcmllc1RvRGVzdHJveSA9IG9sZFZhbHVlPy5maWx0ZXIoKHNlcmllcykgPT4gIW5ld1ZhbHVlLmluY2x1ZGVzKHNlcmllcykpID8/IFtdO1xuICAgIHRoaXMuZGVzdHJveVNlcmllcyhzZXJpZXNUb0Rlc3Ryb3kpO1xuICAgIHRoaXMuc2VyaWVzTGF5ZXJNYW5hZ2VyPy5zZXRTZXJpZXNDb3VudChuZXdWYWx1ZS5sZW5ndGgpO1xuICAgIGZvciAoY29uc3Qgc2VyaWVzIG9mIG5ld1ZhbHVlKSB7XG4gICAgICBpZiAob2xkVmFsdWU/LmluY2x1ZGVzKHNlcmllcykpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgaWYgKHNlcmllcy5yb290R3JvdXAuaXNSb290KCkpIHtcbiAgICAgICAgdGhpcy5zZXJpZXNMYXllck1hbmFnZXIucmVxdWVzdEdyb3VwKHNlcmllcyk7XG4gICAgICB9XG4gICAgICBjb25zdCBjaGFydCA9IHRoaXM7XG4gICAgICBzZXJpZXMuY2hhcnQgPSB7XG4gICAgICAgIGdldCBtb2RlKCkge1xuICAgICAgICAgIHJldHVybiBjaGFydC5tb2RlO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgaXNNaW5pQ2hhcnQoKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgc2VyaWVzUmVjdCgpIHtcbiAgICAgICAgICByZXR1cm4gY2hhcnQuc2VyaWVzUmVjdDtcbiAgICAgICAgfSxcbiAgICAgICAgcGxhY2VMYWJlbHMocGFkZGluZykge1xuICAgICAgICAgIHJldHVybiBjaGFydC5wbGFjZUxhYmVscyhwYWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHNlcmllcy5yZXNldEFuaW1hdGlvbih0aGlzLmNoYXJ0QW5pbWF0aW9uUGhhc2UpO1xuICAgICAgdGhpcy5hZGRTZXJpZXNMaXN0ZW5lcnMoc2VyaWVzKTtcbiAgICAgIHNlcmllcy5hZGRDaGFydEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuICAgIHRoaXMuc2VyaWVzQXJlYU1hbmFnZXI/LnNlcmllc0NoYW5nZWQobmV3VmFsdWUpO1xuICB9XG4gIGRlc3Ryb3lTZXJpZXMoYWxsU2VyaWVzKSB7XG4gICAgYWxsU2VyaWVzPy5mb3JFYWNoKChzZXJpZXMpID0+IHtcbiAgICAgIHNlcmllcy5yZW1vdmVFdmVudExpc3RlbmVyKFwibm9kZUNsaWNrXCIsIHRoaXMub25TZXJpZXNOb2RlQ2xpY2spO1xuICAgICAgc2VyaWVzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJub2RlRG91YmxlQ2xpY2tcIiwgdGhpcy5vblNlcmllc05vZGVEb3VibGVDbGljayk7XG4gICAgICBzZXJpZXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImdyb3VwaW5nQ2hhbmdlZFwiLCB0aGlzLnNlcmllc0dyb3VwaW5nQ2hhbmdlZCk7XG4gICAgICBzZXJpZXMuZGVzdHJveSgpO1xuICAgICAgdGhpcy5zZXJpZXNMYXllck1hbmFnZXIucmVsZWFzZUdyb3VwKHNlcmllcyk7XG4gICAgICBzZXJpZXMuY2hhcnQgPSB2b2lkIDA7XG4gICAgfSk7XG4gIH1cbiAgYWRkU2VyaWVzTGlzdGVuZXJzKHNlcmllcykge1xuICAgIGlmICh0aGlzLmhhc0V2ZW50TGlzdGVuZXIoXCJzZXJpZXNOb2RlQ2xpY2tcIikpIHtcbiAgICAgIHNlcmllcy5hZGRFdmVudExpc3RlbmVyKFwibm9kZUNsaWNrXCIsIHRoaXMub25TZXJpZXNOb2RlQ2xpY2spO1xuICAgIH1cbiAgICBpZiAodGhpcy5oYXNFdmVudExpc3RlbmVyKFwic2VyaWVzTm9kZURvdWJsZUNsaWNrXCIpKSB7XG4gICAgICBzZXJpZXMuYWRkRXZlbnRMaXN0ZW5lcihcIm5vZGVEb3VibGVDbGlja1wiLCB0aGlzLm9uU2VyaWVzTm9kZURvdWJsZUNsaWNrKTtcbiAgICB9XG4gICAgc2VyaWVzLmFkZEV2ZW50TGlzdGVuZXIoXCJncm91cGluZ0NoYW5nZWRcIiwgdGhpcy5zZXJpZXNHcm91cGluZ0NoYW5nZWQpO1xuICB9XG4gIGFzc2lnblNlcmllc1RvQXhlcygpIHtcbiAgICBmb3IgKGNvbnN0IGF4aXMgb2YgdGhpcy5heGVzKSB7XG4gICAgICBheGlzLmJvdW5kU2VyaWVzID0gdGhpcy5zZXJpZXMuZmlsdGVyKChzKSA9PiBzLmF4ZXNbYXhpcy5kaXJlY3Rpb25dID09PSBheGlzKTtcbiAgICB9XG4gIH1cbiAgYXNzaWduQXhlc1RvU2VyaWVzKCkge1xuICAgIGNvbnN0IGRpcmVjdGlvblRvQXhlc01hcCA9IGdyb3VwQnkodGhpcy5heGVzLCAoYXhpcykgPT4gYXhpcy5kaXJlY3Rpb24pO1xuICAgIHRoaXMuc2VyaWVzLmZvckVhY2goKHNlcmllcykgPT4ge1xuICAgICAgc2VyaWVzLmRpcmVjdGlvbnMuZm9yRWFjaCgoZGlyZWN0aW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbkF4ZXMgPSBkaXJlY3Rpb25Ub0F4ZXNNYXBbZGlyZWN0aW9uXTtcbiAgICAgICAgaWYgKCFkaXJlY3Rpb25BeGVzKSB7XG4gICAgICAgICAgTG9nZ2VyLndhcm5PbmNlKFxuICAgICAgICAgICAgYG5vIGF2YWlsYWJsZSBheGlzIGZvciBkaXJlY3Rpb24gWyR7ZGlyZWN0aW9ufV07IGNoZWNrIHNlcmllcyBhbmQgYXhlcyBjb25maWd1cmF0aW9uLmBcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZXJpZXNLZXlzID0gc2VyaWVzLmdldEtleXMoZGlyZWN0aW9uKTtcbiAgICAgICAgY29uc3QgbmV3QXhpcyA9IGRpcmVjdGlvbkF4ZXMuZmluZChcbiAgICAgICAgICAoYXhpcykgPT4gIWF4aXMua2V5cy5sZW5ndGggfHwgc2VyaWVzS2V5cy5zb21lKChrZXkpID0+IGF4aXMua2V5cy5pbmNsdWRlcyhrZXkpKVxuICAgICAgICApO1xuICAgICAgICBpZiAoIW5ld0F4aXMpIHtcbiAgICAgICAgICBMb2dnZXIud2Fybk9uY2UoXG4gICAgICAgICAgICBgbm8gbWF0Y2hpbmcgYXhpcyBmb3IgZGlyZWN0aW9uIFske2RpcmVjdGlvbn1dIGFuZCBrZXlzIFske3Nlcmllc0tleXN9XTsgY2hlY2sgc2VyaWVzIGFuZCBheGVzIGNvbmZpZ3VyYXRpb24uYFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNlcmllcy5heGVzW2RpcmVjdGlvbl0gPSBuZXdBeGlzO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgcGFyZW50UmVzaXplKHNpemUpIHtcbiAgICBpZiAoc2l6ZSA9PSBudWxsIHx8IHRoaXMud2lkdGggIT0gbnVsbCAmJiB0aGlzLmhlaWdodCAhPSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGxldCB7IHdpZHRoOiB3aWR0aDIsIGhlaWdodDogaGVpZ2h0MiB9ID0gc2l6ZTtcbiAgICB3aWR0aDIgPSBNYXRoLmZsb29yKHdpZHRoMik7XG4gICAgaGVpZ2h0MiA9IE1hdGguZmxvb3IoaGVpZ2h0Mik7XG4gICAgaWYgKHdpZHRoMiA9PT0gMCAmJiBoZWlnaHQyID09PSAwKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IFthdXRvV2lkdGggPSAwLCBhdXRoSGVpZ2h0ID0gMF0gPSB0aGlzLl9sYXN0QXV0b1NpemUgPz8gW107XG4gICAgaWYgKGF1dG9XaWR0aCA9PT0gd2lkdGgyICYmIGF1dGhIZWlnaHQgPT09IGhlaWdodDIpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fbGFzdEF1dG9TaXplID0gW3dpZHRoMiwgaGVpZ2h0Ml07XG4gICAgdGhpcy5yZXNpemUoXCJTaXplTW9uaXRvclwiLCB7fSk7XG4gIH1cbiAgcmVzaXplKHNvdXJjZSwgb3B0cykge1xuICAgIGNvbnN0IHsgc2NlbmUsIGFuaW1hdGlvbk1hbmFnZXIgfSA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IHsgaW5XaWR0aCwgaW5IZWlnaHQsIGluTWluV2lkdGgsIGluTWluSGVpZ2h0IH0gPSBvcHRzO1xuICAgIHRoaXMuY3R4LmRvbU1hbmFnZXIuc2V0U2l6ZU9wdGlvbnMoXG4gICAgICBpbk1pbldpZHRoID8/IHRoaXMubWluV2lkdGgsXG4gICAgICBpbk1pbkhlaWdodCA/PyB0aGlzLm1pbkhlaWdodCxcbiAgICAgIGluV2lkdGggPz8gdGhpcy53aWR0aCxcbiAgICAgIGluSGVpZ2h0ID8/IHRoaXMuaGVpZ2h0XG4gICAgKTtcbiAgICBjb25zdCB3aWR0aDIgPSBpbldpZHRoID8/IHRoaXMud2lkdGggPz8gdGhpcy5fbGFzdEF1dG9TaXplPy5bMF07XG4gICAgY29uc3QgaGVpZ2h0MiA9IGluSGVpZ2h0ID8/IHRoaXMuaGVpZ2h0ID8/IHRoaXMuX2xhc3RBdXRvU2l6ZT8uWzFdO1xuICAgIHRoaXMuZGVidWcoYENoYXJ0LnJlc2l6ZSgpIGZyb20gJHtzb3VyY2V9YCwgeyB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIsIHN0YWNrOiBuZXcgRXJyb3IoKS5zdGFjayB9KTtcbiAgICBpZiAod2lkdGgyID09IG51bGwgfHwgaGVpZ2h0MiA9PSBudWxsIHx8ICFpc0Zpbml0ZU51bWJlcih3aWR0aDIpIHx8ICFpc0Zpbml0ZU51bWJlcihoZWlnaHQyKSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAoc2NlbmUucmVzaXplKHdpZHRoMiwgaGVpZ2h0MikpIHtcbiAgICAgIGFuaW1hdGlvbk1hbmFnZXIucmVzZXQoKTtcbiAgICAgIGxldCBza2lwQW5pbWF0aW9ucyA9IHRydWU7XG4gICAgICBpZiAoKHRoaXMud2lkdGggPT0gbnVsbCB8fCB0aGlzLmhlaWdodCA9PSBudWxsKSAmJiB0aGlzLl9maXJzdEF1dG9TaXplKSB7XG4gICAgICAgIHNraXBBbmltYXRpb25zID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2ZpcnN0QXV0b1NpemUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlKDMgLyogUEVSRk9STV9MQVlPVVQgKi8sIHsgZm9yY2VOb2RlRGF0YVJlZnJlc2g6IHRydWUsIHNraXBBbmltYXRpb25zIH0pO1xuICAgIH1cbiAgfVxuICBhc3luYyB1cGRhdGVEYXRhKCkge1xuICAgIHRoaXMuc2VyaWVzLmZvckVhY2goKHMpID0+IHMuc2V0Q2hhcnREYXRhKHRoaXMuZGF0YSkpO1xuICAgIGNvbnN0IG1vZHVsZVByb21pc2VzID0gdGhpcy5tb2R1bGVzTWFuYWdlci5tYXBNb2R1bGVzKChtKSA9PiBtLnVwZGF0ZURhdGE/Lih0aGlzLmRhdGEpKTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChtb2R1bGVQcm9taXNlcyk7XG4gIH1cbiAgYXN5bmMgcHJvY2Vzc0RhdGEoKSB7XG4gICAgaWYgKHRoaXMuc2VyaWVzLnNvbWUoKHMpID0+IHMuY2FuSGF2ZUF4ZXMpKSB7XG4gICAgICB0aGlzLmFzc2lnbkF4ZXNUb1NlcmllcygpO1xuICAgICAgdGhpcy5hc3NpZ25TZXJpZXNUb0F4ZXMoKTtcbiAgICB9XG4gICAgY29uc3QgZGF0YUNvbnRyb2xsZXIgPSBuZXcgRGF0YUNvbnRyb2xsZXIodGhpcy5tb2RlKTtcbiAgICBjb25zdCBzZXJpZXNQcm9taXNlcyA9IHRoaXMuc2VyaWVzLm1hcCgocykgPT4gcy5wcm9jZXNzRGF0YShkYXRhQ29udHJvbGxlcikpO1xuICAgIGNvbnN0IG1vZHVsZVByb21pc2VzID0gdGhpcy5tb2R1bGVzTWFuYWdlci5tYXBNb2R1bGVzKChtKSA9PiBtLnByb2Nlc3NEYXRhPy4oZGF0YUNvbnRyb2xsZXIpKTtcbiAgICBkYXRhQ29udHJvbGxlci5leGVjdXRlKCk7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoWy4uLnNlcmllc1Byb21pc2VzLCAuLi5tb2R1bGVQcm9taXNlc10pO1xuICAgIGZvciAoY29uc3QgeyBsZWdlbmRUeXBlLCBsZWdlbmQgfSBvZiB0aGlzLm1vZHVsZXNNYW5hZ2VyLmxlZ2VuZHMoKSkge1xuICAgICAgbGVnZW5kLmRhdGEgPSB0aGlzLmdldExlZ2VuZERhdGEobGVnZW5kVHlwZSwgdGhpcy5tb2RlICE9PSBcImludGVncmF0ZWRcIik7XG4gICAgfVxuICB9XG4gIHBsYWNlTGFiZWxzKHBhZGRpbmcpIHtcbiAgICBjb25zdCB2aXNpYmxlU2VyaWVzID0gW107XG4gICAgY29uc3QgZGF0YSA9IFtdO1xuICAgIGZvciAoY29uc3Qgc2VyaWVzIG9mIHRoaXMuc2VyaWVzKSB7XG4gICAgICBpZiAoIXNlcmllcy52aXNpYmxlKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IGxhYmVsRGF0YSA9IHNlcmllcy5nZXRMYWJlbERhdGEoKTtcbiAgICAgIGlmIChpc1BvaW50TGFiZWxEYXR1bShsYWJlbERhdGE/LlswXSkpIHtcbiAgICAgICAgZGF0YS5wdXNoKGxhYmVsRGF0YSk7XG4gICAgICAgIHZpc2libGVTZXJpZXMucHVzaChzZXJpZXMpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB7IHNlcmllc1JlY3QgfSA9IHRoaXM7XG4gICAgY29uc3QgeyB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQgfSA9IHRoaXMuc2VyaWVzQXJlYS5wYWRkaW5nO1xuICAgIGNvbnN0IGxhYmVscyA9IHNlcmllc1JlY3QgJiYgZGF0YS5sZW5ndGggPiAwID8gcGxhY2VMYWJlbHMoXG4gICAgICBkYXRhLFxuICAgICAge1xuICAgICAgICB4OiAtbGVmdCxcbiAgICAgICAgeTogLXRvcCxcbiAgICAgICAgd2lkdGg6IHNlcmllc1JlY3Qud2lkdGggKyBsZWZ0ICsgcmlnaHQsXG4gICAgICAgIGhlaWdodDogc2VyaWVzUmVjdC5oZWlnaHQgKyB0b3AgKyBib3R0b21cbiAgICAgIH0sXG4gICAgICBwYWRkaW5nXG4gICAgKSA6IFtdO1xuICAgIHJldHVybiBuZXcgTWFwKGxhYmVscy5tYXAoKGwsIGkpID0+IFt2aXNpYmxlU2VyaWVzW2ldLCBsXSkpO1xuICB9XG4gIGdldExlZ2VuZERhdGEobGVnZW5kVHlwZSwgd2FybkNvbmZsaWN0cykge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBsZWdlbmREYXRhID0gdGhpcy5zZXJpZXMuZmlsdGVyKChzKSA9PiBzLnByb3BlcnRpZXMuc2hvd0luTGVnZW5kKS5mbGF0TWFwKChzKSA9PiBzLmdldExlZ2VuZERhdGEobGVnZW5kVHlwZSkpO1xuICAgIGNvbnN0IGlzQ2F0ZWdvcnlMZWdlbmREYXRhID0gKGRhdGEpID0+IGRhdGEuZXZlcnkoKGQpID0+IGQubGVnZW5kVHlwZSA9PT0gXCJjYXRlZ29yeVwiKTtcbiAgICBpZiAod2FybkNvbmZsaWN0cyAmJiBpc0NhdGVnb3J5TGVnZW5kRGF0YShsZWdlbmREYXRhKSkge1xuICAgICAgY29uc3Qgc2VyaWVzTWFya2VyRmlsbHMgPSB7fTtcbiAgICAgIGNvbnN0IHNlcmllc1R5cGVNYXAgPSBuZXcgTWFwKHRoaXMuc2VyaWVzLm1hcCgocykgPT4gW3MuaWQsIHMudHlwZV0pKTtcbiAgICAgIGZvciAoY29uc3Qge1xuICAgICAgICBzZXJpZXNJZCxcbiAgICAgICAgc3ltYm9sczogW3sgbWFya2VyIH1dLFxuICAgICAgICBsYWJlbFxuICAgICAgfSBvZiBsZWdlbmREYXRhKSB7XG4gICAgICAgIGlmIChtYXJrZXIuZmlsbCA9PSBudWxsKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBzZXJpZXNUeXBlMiA9IHNlcmllc1R5cGVNYXAuZ2V0KHNlcmllc0lkKTtcbiAgICAgICAgY29uc3QgbWFya2VyRmlsbCA9IHNlcmllc01hcmtlckZpbGxzW3Nlcmllc1R5cGUyXSA/PyAoc2VyaWVzTWFya2VyRmlsbHNbc2VyaWVzVHlwZTJdID0ge30pO1xuICAgICAgICBtYXJrZXJGaWxsW19hID0gbGFiZWwudGV4dF0gPz8gKG1hcmtlckZpbGxbX2FdID0gbWFya2VyLmZpbGwpO1xuICAgICAgICBpZiAobWFya2VyRmlsbFtsYWJlbC50ZXh0XSAhPT0gbWFya2VyLmZpbGwpIHtcbiAgICAgICAgICBMb2dnZXIud2Fybk9uY2UoXG4gICAgICAgICAgICBgbGVnZW5kIGl0ZW0gJyR7bGFiZWwudGV4dH0nIGhhcyBtdWx0aXBsZSBmaWxsIGNvbG9ycywgdGhpcyBtYXkgY2F1c2UgdW5leHBlY3RlZCBiZWhhdmlvdXIuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxlZ2VuZERhdGE7XG4gIH1cbiAgYXN5bmMgcHJvY2Vzc0xheW91dCgpIHtcbiAgICBjb25zdCBvbGRSZWN0ID0gdGhpcy5hbmltYXRpb25SZWN0O1xuICAgIGNvbnN0IHsgd2lkdGg6IHdpZHRoMiwgaGVpZ2h0OiBoZWlnaHQyIH0gPSB0aGlzLmN0eC5zY2VuZTtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eC5sYXlvdXRNYW5hZ2VyLmNyZWF0ZUNvbnRleHQod2lkdGgyLCBoZWlnaHQyKTtcbiAgICBhd2FpdCB0aGlzLnBlcmZvcm1MYXlvdXQoY3R4KTtcbiAgICBpZiAob2xkUmVjdCAmJiAhdGhpcy5hbmltYXRpb25SZWN0Py5lcXVhbHMob2xkUmVjdCkpIHtcbiAgICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuc2tpcEN1cnJlbnRCYXRjaCgpO1xuICAgIH1cbiAgICB0aGlzLmRlYnVnKFwiQ2hhcnQucGVyZm9ybVVwZGF0ZSgpIC0gc2VyaWVzUmVjdFwiLCB0aGlzLnNlcmllc1JlY3QpO1xuICB9XG4gIGFzeW5jIHdhaXRGb3JVcGRhdGUodGltZW91dE1zID0gMWU0LCBmYWlsT25UaW1lb3V0ID0gZmFsc2UpIHtcbiAgICBjb25zdCBzdGFydDIgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBpZiAodGhpcy5fcGVuZGluZ0ZhY3RvcnlVcGRhdGVzQ291bnQgPiAwKSB7XG4gICAgICBhd2FpdCB0aGlzLnVwZGF0ZU11dGV4LndhaXRGb3JDbGVhckFjcXVpcmVRdWV1ZSgpO1xuICAgIH1cbiAgICB3aGlsZSAodGhpcy5wZXJmb3JtVXBkYXRlVHlwZSAhPT0gNyAvKiBOT05FICovKSB7XG4gICAgICBpZiAocGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydDIgPiB0aW1lb3V0TXMpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBDaGFydC53YWl0Rm9yVXBkYXRlKCkgdGltZW91dCBvZiAke3RpbWVvdXRNc30gcmVhY2hlZCAtIGZpcnN0IGNoYXJ0IHVwZGF0ZSB0YWtpbmcgdG9vIGxvbmcuYDtcbiAgICAgICAgaWYgKGZhaWxPblRpbWVvdXQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgTG9nZ2VyLndhcm5PbmNlKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhd2FpdCBzbGVlcCg1MCk7XG4gICAgfVxuICAgIGF3YWl0IHRoaXMudXBkYXRlTXV0ZXgud2FpdEZvckNsZWFyQWNxdWlyZVF1ZXVlKCk7XG4gIH1cbiAgZ2V0TWluUmVjdHMoKSB7XG4gICAgY29uc3QgeyB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIgfSA9IHRoaXMuY3R4LnNjZW5lO1xuICAgIGNvbnN0IG1pblJlY3RzID0gdGhpcy5zZXJpZXMubWFwKChzZXJpZXMpID0+IHNlcmllcy5nZXRNaW5SZWN0cyh3aWR0aDIsIGhlaWdodDIpKS5maWx0ZXIoaXNEZWZpbmVkKTtcbiAgICBpZiAobWluUmVjdHMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuO1xuICAgIGxldCBtYXhXaWR0aCA9IDA7XG4gICAgbGV0IG1heEhlaWdodCA9IDA7XG4gICAgbGV0IG1heFZpc2libGVXaWR0aCA9IDA7XG4gICAgbGV0IG1heFZpc2libGVIZWlnaHQgPSAwO1xuICAgIGZvciAoY29uc3QgeyBtaW5SZWN0OiBtaW5SZWN0MiwgbWluVmlzaWJsZVJlY3Q6IG1pblZpc2libGVSZWN0MiB9IG9mIG1pblJlY3RzKSB7XG4gICAgICBtYXhXaWR0aCA9IE1hdGgubWF4KG1heFdpZHRoLCBtaW5SZWN0Mi53aWR0aCk7XG4gICAgICBtYXhIZWlnaHQgPSBNYXRoLm1heChtYXhIZWlnaHQsIG1pblJlY3QyLmhlaWdodCk7XG4gICAgICBtYXhWaXNpYmxlV2lkdGggPSBNYXRoLm1heChtYXhWaXNpYmxlV2lkdGgsIG1pblZpc2libGVSZWN0Mi53aWR0aCk7XG4gICAgICBtYXhWaXNpYmxlSGVpZ2h0ID0gTWF0aC5tYXgobWF4VmlzaWJsZUhlaWdodCwgbWluVmlzaWJsZVJlY3QyLmhlaWdodCk7XG4gICAgfVxuICAgIGNvbnN0IG1pblJlY3QgPSBuZXcgQkJveCgwLCAwLCBtYXhXaWR0aCwgbWF4SGVpZ2h0KTtcbiAgICBsZXQgbWluVmlzaWJsZVJlY3QgPSBtaW5SZWN0LmNsb25lKCk7XG4gICAgaWYgKG1heFZpc2libGVXaWR0aCA+IDAgJiYgbWF4VmlzaWJsZUhlaWdodCA+IDApIHtcbiAgICAgIG1pblZpc2libGVSZWN0ID0gbmV3IEJCb3goMCwgMCwgbWF4VmlzaWJsZVdpZHRoLCBtYXhWaXNpYmxlSGVpZ2h0KTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbWluUmVjdCwgbWluVmlzaWJsZVJlY3QgfTtcbiAgfVxuICBmaWx0ZXJNaW5pQ2hhcnRTZXJpZXMoc2VyaWVzKSB7XG4gICAgcmV0dXJuIHNlcmllcz8uZmlsdGVyKChzKSA9PiBzLnNob3dJbk1pbmlDaGFydCAhPT0gZmFsc2UpO1xuICB9XG4gIGFwcGx5T3B0aW9ucyhuZXdDaGFydE9wdGlvbnMpIHtcbiAgICBjb25zdCBpc0RpZmZlcmVudE9wdHMgPSBuZXdDaGFydE9wdGlvbnMgIT09IHRoaXMuY2hhcnRPcHRpb25zO1xuICAgIGNvbnN0IG9sZE9wdHMgPSBpc0RpZmZlcmVudE9wdHMgPyB0aGlzLmNoYXJ0T3B0aW9ucy5wcm9jZXNzZWRPcHRpb25zIDoge307XG4gICAgY29uc3QgbmV3T3B0cyA9IG5ld0NoYXJ0T3B0aW9ucy5wcm9jZXNzZWRPcHRpb25zO1xuICAgIGNvbnN0IGRlbHRhT3B0aW9ucyA9IG5ld0NoYXJ0T3B0aW9ucy5kaWZmT3B0aW9ucyhvbGRPcHRzKTtcbiAgICBpZiAoZGVsdGFPcHRpb25zID09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgZGVidWcoXCJDaGFydC5hcHBseU9wdGlvbnMoKSAtIGFwcGx5aW5nIGRlbHRhXCIsIGRlbHRhT3B0aW9ucyk7XG4gICAgY29uc3QgbW9kdWxlc0NoYW5nZWQgPSB0aGlzLmFwcGx5TW9kdWxlcyhuZXdPcHRzKTtcbiAgICBjb25zdCBza2lwID0gW1xuICAgICAgXCJ0eXBlXCIsXG4gICAgICBcImRhdGFcIixcbiAgICAgIFwic2VyaWVzXCIsXG4gICAgICBcImxpc3RlbmVyc1wiLFxuICAgICAgXCJwcmVzZXRcIixcbiAgICAgIFwidGhlbWVcIixcbiAgICAgIFwibGVnZW5kLmxpc3RlbmVyc1wiLFxuICAgICAgXCJuYXZpZ2F0b3IubWluaUNoYXJ0LnNlcmllc1wiLFxuICAgICAgXCJuYXZpZ2F0b3IubWluaUNoYXJ0LmxhYmVsXCIsXG4gICAgICBcImxvY2FsZS5sb2NhbGVUZXh0XCIsXG4gICAgICBcImF4ZXNcIixcbiAgICAgIFwidG9wb2xvZ3lcIixcbiAgICAgIFwibm9kZXNcIixcbiAgICAgIFwiaW5pdGlhbFN0YXRlXCIsXG4gICAgICBcInN0eWxlQ29udGFpbmVyXCJcbiAgICBdO1xuICAgIGlmIChkZWx0YU9wdGlvbnMubGlzdGVuZXJzKSB7XG4gICAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKHRoaXMsIGRlbHRhT3B0aW9ucy5saXN0ZW5lcnMpO1xuICAgIH1cbiAgICBqc29uQXBwbHkodGhpcywgZGVsdGFPcHRpb25zLCB7IHNraXAgfSk7XG4gICAgbGV0IGZvcmNlTm9kZURhdGFSZWZyZXNoID0gZmFsc2U7XG4gICAgbGV0IHNlcmllc1N0YXR1cyA9IFwibm8tb3BcIjtcbiAgICBpZiAoZGVsdGFPcHRpb25zLnNlcmllcyAhPSBudWxsKSB7XG4gICAgICBzZXJpZXNTdGF0dXMgPSB0aGlzLmFwcGx5U2VyaWVzKHRoaXMsIGRlbHRhT3B0aW9ucy5zZXJpZXMsIG9sZE9wdHM/LnNlcmllcyk7XG4gICAgICBmb3JjZU5vZGVEYXRhUmVmcmVzaCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChzZXJpZXNTdGF0dXMgPT09IFwicmVwbGFjZWRcIikge1xuICAgICAgdGhpcy5yZXNldEFuaW1hdGlvbnMoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYXBwbHlBeGVzKHRoaXMsIG5ld09wdHMsIG9sZE9wdHMsIHNlcmllc1N0YXR1cywgW10sIHRydWUpKSB7XG4gICAgICBmb3JjZU5vZGVEYXRhUmVmcmVzaCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChkZWx0YU9wdGlvbnMuZGF0YSkge1xuICAgICAgdGhpcy5kYXRhID0gZGVsdGFPcHRpb25zLmRhdGE7XG4gICAgfVxuICAgIGlmIChkZWx0YU9wdGlvbnMubGVnZW5kPy5saXN0ZW5lcnMgJiYgdGhpcy5tb2R1bGVzTWFuYWdlci5pc0VuYWJsZWQoXCJsZWdlbmRcIikpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5sZWdlbmQubGlzdGVuZXJzLCBkZWx0YU9wdGlvbnMubGVnZW5kLmxpc3RlbmVycyk7XG4gICAgfVxuICAgIGlmIChkZWx0YU9wdGlvbnMubG9jYWxlPy5sb2NhbGVUZXh0KSB7XG4gICAgICB0aGlzLm1vZHVsZXNNYW5hZ2VyLmdldE1vZHVsZShcImxvY2FsZVwiKS5sb2NhbGVUZXh0ID0gZGVsdGFPcHRpb25zLmxvY2FsZT8ubG9jYWxlVGV4dDtcbiAgICB9XG4gICAgdGhpcy5jaGFydE9wdGlvbnMgPSBuZXdDaGFydE9wdGlvbnM7XG4gICAgY29uc3QgbmF2aWdhdG9yTW9kdWxlID0gdGhpcy5tb2R1bGVzTWFuYWdlci5nZXRNb2R1bGUoXCJuYXZpZ2F0b3JcIik7XG4gICAgY29uc3Qgem9vbU1vZHVsZSA9IHRoaXMubW9kdWxlc01hbmFnZXIuZ2V0TW9kdWxlKFwiem9vbVwiKTtcbiAgICBpZiAoIW5hdmlnYXRvck1vZHVsZT8uZW5hYmxlZCAmJiAhem9vbU1vZHVsZT8uZW5hYmxlZCkge1xuICAgICAgdGhpcy5jdHguem9vbU1hbmFnZXIudXBkYXRlWm9vbShcImNoYXJ0XCIpO1xuICAgIH1cbiAgICBjb25zdCBtaW5pQ2hhcnQgPSBuYXZpZ2F0b3JNb2R1bGU/Lm1pbmlDaGFydDtcbiAgICBjb25zdCBtaW5pQ2hhcnRTZXJpZXMgPSBuZXdPcHRzLm5hdmlnYXRvcj8ubWluaUNoYXJ0Py5zZXJpZXMgPz8gbmV3T3B0cy5zZXJpZXM7XG4gICAgaWYgKG1pbmlDaGFydD8uZW5hYmxlZCA9PT0gdHJ1ZSAmJiBtaW5pQ2hhcnRTZXJpZXMgIT0gbnVsbCkge1xuICAgICAgdGhpcy5hcHBseU1pbmlDaGFydE9wdGlvbnMobWluaUNoYXJ0LCBtaW5pQ2hhcnRTZXJpZXMsIG5ld09wdHMsIG9sZE9wdHMpO1xuICAgIH0gZWxzZSBpZiAobWluaUNoYXJ0Py5lbmFibGVkID09PSBmYWxzZSkge1xuICAgICAgbWluaUNoYXJ0LnNlcmllcyA9IFtdO1xuICAgICAgbWluaUNoYXJ0LmF4ZXMgPSBbXTtcbiAgICB9XG4gICAgdGhpcy5jdHguYW5ub3RhdGlvbk1hbmFnZXIuc2V0QW5ub3RhdGlvblN0eWxlcyhuZXdDaGFydE9wdGlvbnMuYW5ub3RhdGlvblRoZW1lcyk7XG4gICAgZm9yY2VOb2RlRGF0YVJlZnJlc2ggfHwgKGZvcmNlTm9kZURhdGFSZWZyZXNoID0gdGhpcy5zaG91bGRGb3JjZU5vZGVEYXRhUmVmcmVzaChkZWx0YU9wdGlvbnMsIHNlcmllc1N0YXR1cykpO1xuICAgIGNvbnN0IG1ham9yQ2hhbmdlID0gZm9yY2VOb2RlRGF0YVJlZnJlc2ggfHwgbW9kdWxlc0NoYW5nZWQ7XG4gICAgY29uc3QgdXBkYXRlVHlwZSA9IG1ham9yQ2hhbmdlID8gMCAvKiBGVUxMICovIDogMyAvKiBQRVJGT1JNX0xBWU9VVCAqLztcbiAgICB0aGlzLm1heWJlUmVzZXRBbmltYXRpb25zKHNlcmllc1N0YXR1cyk7XG4gICAgZGVidWcoXCJDaGFydC5hcHBseU9wdGlvbnMoKSAtIHVwZGF0ZSB0eXBlXCIsIENoYXJ0VXBkYXRlVHlwZVt1cGRhdGVUeXBlXSwge1xuICAgICAgc2VyaWVzU3RhdHVzLFxuICAgICAgZm9yY2VOb2RlRGF0YVJlZnJlc2hcbiAgICB9KTtcbiAgICB0aGlzLnVwZGF0ZSh1cGRhdGVUeXBlLCB7IGZvcmNlTm9kZURhdGFSZWZyZXNoLCBuZXdBbmltYXRpb25CYXRjaDogdHJ1ZSB9KTtcbiAgICBpZiAoZGVsdGFPcHRpb25zLmluaXRpYWxTdGF0ZSB8fCBkZWx0YU9wdGlvbnMudGhlbWUpIHtcbiAgICAgIHRoaXMuYXBwbHlJbml0aWFsU3RhdGUobmV3Q2hhcnRPcHRpb25zLnVzZXJPcHRpb25zLmluaXRpYWxTdGF0ZSk7XG4gICAgfVxuICB9XG4gIGFwcGx5SW5pdGlhbFN0YXRlKGluaXRpYWxTdGF0ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGN0eDogeyBhbm5vdGF0aW9uTWFuYWdlciwgaGlzdG9yeU1hbmFnZXIsIHN0YXRlTWFuYWdlciB9XG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKGluaXRpYWxTdGF0ZT8uYW5ub3RhdGlvbnMgIT0gbnVsbCkge1xuICAgICAgY29uc3QgYW5ub3RhdGlvbnMyID0gaW5pdGlhbFN0YXRlLmFubm90YXRpb25zLm1hcCgoYW5ub3RhdGlvbikgPT4ge1xuICAgICAgICBjb25zdCBhbm5vdGF0aW9uVGhlbWUgPSBhbm5vdGF0aW9uTWFuYWdlci5nZXRBbm5vdGF0aW9uVHlwZVN0eWxlcyhhbm5vdGF0aW9uLnR5cGUpO1xuICAgICAgICByZXR1cm4gbWVyZ2VEZWZhdWx0cyhhbm5vdGF0aW9uLCBhbm5vdGF0aW9uVGhlbWUpO1xuICAgICAgfSk7XG4gICAgICBzdGF0ZU1hbmFnZXIuc2V0U3RhdGUoYW5ub3RhdGlvbk1hbmFnZXIsIGFubm90YXRpb25zMik7XG4gICAgfVxuICAgIGlmIChpbml0aWFsU3RhdGUgIT0gbnVsbCkge1xuICAgICAgaGlzdG9yeU1hbmFnZXIuY2xlYXIoKTtcbiAgICB9XG4gIH1cbiAgbWF5YmVSZXNldEFuaW1hdGlvbnMoc2VyaWVzU3RhdHVzKSB7XG4gICAgaWYgKHRoaXMubW9kZSAhPT0gXCJzdGFuZGFsb25lXCIpXG4gICAgICByZXR1cm47XG4gICAgc3dpdGNoIChzZXJpZXNTdGF0dXMpIHtcbiAgICAgIGNhc2UgXCJzZXJpZXMtZ3JvdXBpbmctY2hhbmdlXCI6XG4gICAgICBjYXNlIFwicmVwbGFjZWRcIjpcbiAgICAgICAgdGhpcy5yZXNldEFuaW1hdGlvbnMoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgIH1cbiAgfVxuICBzaG91bGRGb3JjZU5vZGVEYXRhUmVmcmVzaChkZWx0YU9wdGlvbnMsIHNlcmllc1N0YXR1cykge1xuICAgIGNvbnN0IHNlcmllc0RhdGFVcGRhdGUgPSAhIWRlbHRhT3B0aW9ucy5kYXRhIHx8IHNlcmllc1N0YXR1cyA9PT0gXCJkYXRhLWNoYW5nZVwiIHx8IHNlcmllc1N0YXR1cyA9PT0gXCJyZXBsYWNlZFwiO1xuICAgIGNvbnN0IGxlZ2VuZEtleXMgPSBsZWdlbmRSZWdpc3RyeS5nZXRLZXlzKCk7XG4gICAgY29uc3Qgb3B0aW9uc0hhdmVMZWdlbmQgPSBPYmplY3QudmFsdWVzKGxlZ2VuZEtleXMpLnNvbWUoXG4gICAgICAobGVnZW5kS2V5KSA9PiBkZWx0YU9wdGlvbnNbbGVnZW5kS2V5XSAhPSBudWxsXG4gICAgKTtcbiAgICBjb25zdCBvdGhlclJlZnJlc2hVcGRhdGUgPSBkZWx0YU9wdGlvbnMudGl0bGUgIT0gbnVsbCAmJiBkZWx0YU9wdGlvbnMuc3VidGl0bGUgIT0gbnVsbDtcbiAgICByZXR1cm4gc2VyaWVzRGF0YVVwZGF0ZSB8fCBvcHRpb25zSGF2ZUxlZ2VuZCB8fCBvdGhlclJlZnJlc2hVcGRhdGU7XG4gIH1cbiAgYXBwbHlNaW5pQ2hhcnRPcHRpb25zKG1pbmlDaGFydCwgbWluaUNoYXJ0U2VyaWVzLCBjb21wbGV0ZU9wdGlvbnMsIG9sZE9wdHMpIHtcbiAgICBjb25zdCBvbGRTZXJpZXMgPSBvbGRPcHRzPy5uYXZpZ2F0b3I/Lm1pbmlDaGFydD8uc2VyaWVzID8/IG9sZE9wdHM/LnNlcmllcztcbiAgICBjb25zdCBtaW5pQ2hhcnRTZXJpZXNTdGF0dXMgPSB0aGlzLmFwcGx5U2VyaWVzKFxuICAgICAgbWluaUNoYXJ0LFxuICAgICAgdGhpcy5maWx0ZXJNaW5pQ2hhcnRTZXJpZXMobWluaUNoYXJ0U2VyaWVzKSxcbiAgICAgIHRoaXMuZmlsdGVyTWluaUNoYXJ0U2VyaWVzKG9sZFNlcmllcylcbiAgICApO1xuICAgIHRoaXMuYXBwbHlBeGVzKG1pbmlDaGFydCwgY29tcGxldGVPcHRpb25zLCBvbGRPcHRzLCBtaW5pQ2hhcnRTZXJpZXNTdGF0dXMsIFtcbiAgICAgIFwiYXhlc1tdLnRpY2tcIixcbiAgICAgIFwiYXhlc1tdLnRoaWNrbmVzc1wiLFxuICAgICAgXCJheGVzW10udGl0bGVcIixcbiAgICAgIFwiYXhlc1tdLmNyb3NzaGFpclwiLFxuICAgICAgXCJheGVzW10uZ3JpZExpbmVcIixcbiAgICAgIFwiYXhlc1tdLmxhYmVsXCJcbiAgICBdKTtcbiAgICBjb25zdCBzZXJpZXMgPSBtaW5pQ2hhcnQuc2VyaWVzO1xuICAgIGZvciAoY29uc3QgcyBvZiBzZXJpZXMpIHtcbiAgICAgIHMucHJvcGVydGllcy5pZCA9IHZvaWQgMDtcbiAgICB9XG4gICAgY29uc3QgYXhlcyA9IG1pbmlDaGFydC5heGVzO1xuICAgIGNvbnN0IGhvcml6b250YWxBeGlzID0gYXhlcy5maW5kKChheGlzKSA9PiBheGlzLmRpcmVjdGlvbiA9PT0gXCJ4XCIgLyogWCAqLyk7XG4gICAgZm9yIChjb25zdCBheGlzIG9mIGF4ZXMpIHtcbiAgICAgIGF4aXMuZ3JpZExpbmUuZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgYXhpcy5sYWJlbC5lbmFibGVkID0gYXhpcyA9PT0gaG9yaXpvbnRhbEF4aXM7XG4gICAgICBheGlzLnRpY2suZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgYXhpcy5pbnRlcmFjdGlvbkVuYWJsZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGhvcml6b250YWxBeGlzICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IG1pbmlDaGFydE9wdHMgPSBjb21wbGV0ZU9wdGlvbnMubmF2aWdhdG9yPy5taW5pQ2hhcnQ7XG4gICAgICBjb25zdCBsYWJlbE9wdGlvbnMgPSBtaW5pQ2hhcnRPcHRzPy5sYWJlbDtcbiAgICAgIGNvbnN0IGludGVydmFsT3B0aW9ucyA9IG1pbmlDaGFydE9wdHM/LmxhYmVsPy5pbnRlcnZhbDtcbiAgICAgIGhvcml6b250YWxBeGlzLmxpbmUuZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgaG9yaXpvbnRhbEF4aXMubGFiZWwuc2V0KFxuICAgICAgICB3aXRob3V0KGxhYmVsT3B0aW9ucywgW1wiaW50ZXJ2YWxcIiwgXCJyb3RhdGlvblwiLCBcIm1pblNwYWNpbmdcIiwgXCJhdXRvUm90YXRlXCIsIFwiYXV0b1JvdGF0ZUFuZ2xlXCJdKVxuICAgICAgKTtcbiAgICAgIGhvcml6b250YWxBeGlzLnRpY2suc2V0KFxuICAgICAgICB3aXRob3V0KGludGVydmFsT3B0aW9ucywgW1wiZW5hYmxlZFwiLCBcIndpZHRoXCIsIFwic2l6ZVwiLCBcImNvbG9yXCIsIFwiaW50ZXJ2YWxcIiwgXCJzdGVwXCJdKVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHN0ZXAgPSBpbnRlcnZhbE9wdGlvbnM/LnN0ZXA7XG4gICAgICBpZiAoc3RlcCAhPSBudWxsKSB7XG4gICAgICAgIGhvcml6b250YWxBeGlzLmludGVydmFsLnN0ZXAgPSBzdGVwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhcHBseU1vZHVsZXMob3B0aW9ucykge1xuICAgIGNvbnN0IHsgdHlwZTogY2hhcnRUeXBlMiB9ID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICBsZXQgbW9kdWxlc0NoYW5nZWQgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IG1vZHVsZSBvZiBtb2R1bGVSZWdpc3RyeS5ieVR5cGUoXCJyb290XCIsIFwibGVnZW5kXCIpKSB7XG4gICAgICBjb25zdCBpc0NvbmZpZ3VyZWQgPSBvcHRpb25zW21vZHVsZS5vcHRpb25zS2V5XSAhPSBudWxsO1xuICAgICAgY29uc3Qgc2hvdWxkQmVFbmFibGVkID0gaXNDb25maWd1cmVkICYmIG1vZHVsZS5jaGFydFR5cGVzLmluY2x1ZGVzKGNoYXJ0VHlwZTIpO1xuICAgICAgaWYgKHNob3VsZEJlRW5hYmxlZCA9PT0gdGhpcy5tb2R1bGVzTWFuYWdlci5pc0VuYWJsZWQobW9kdWxlKSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBpZiAoc2hvdWxkQmVFbmFibGVkKSB7XG4gICAgICAgIHRoaXMubW9kdWxlc01hbmFnZXIuYWRkTW9kdWxlKG1vZHVsZSwgKG0pID0+IG0ubW9kdWxlRmFjdG9yeSh0aGlzLmdldE1vZHVsZUNvbnRleHQoKSkpO1xuICAgICAgICBpZiAobW9kdWxlLnR5cGUgPT09IFwibGVnZW5kXCIpIHtcbiAgICAgICAgICB0aGlzLm1vZHVsZXNNYW5hZ2VyLmdldE1vZHVsZShtb2R1bGUpPy5hdHRhY2hMZWdlbmQodGhpcy5jdHguc2NlbmUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbbW9kdWxlLm9wdGlvbnNLZXldID0gdGhpcy5tb2R1bGVzTWFuYWdlci5nZXRNb2R1bGUobW9kdWxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubW9kdWxlc01hbmFnZXIucmVtb3ZlTW9kdWxlKG1vZHVsZSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzW21vZHVsZS5vcHRpb25zS2V5XTtcbiAgICAgIH1cbiAgICAgIG1vZHVsZXNDaGFuZ2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZHVsZXNDaGFuZ2VkO1xuICB9XG4gIGluaXRTZXJpZXNEZWNsYXJhdGlvbk9yZGVyKHNlcmllcykge1xuICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHNlcmllcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICBzZXJpZXNbaWR4XS5fZGVjbGFyYXRpb25PcmRlciA9IGlkeDtcbiAgICB9XG4gIH1cbiAgYXBwbHlTZXJpZXMoY2hhcnQsIG9wdFNlcmllcywgb2xkT3B0U2VyaWVzKSB7XG4gICAgaWYgKCFvcHRTZXJpZXMpIHtcbiAgICAgIHJldHVybiBcIm5vLWNoYW5nZVwiO1xuICAgIH1cbiAgICBjb25zdCBtYXRjaFJlc3VsdCA9IG1hdGNoU2VyaWVzT3B0aW9ucyhjaGFydC5zZXJpZXMsIG9wdFNlcmllcywgb2xkT3B0U2VyaWVzKTtcbiAgICBpZiAobWF0Y2hSZXN1bHQuc3RhdHVzID09PSBcIm5vLW92ZXJsYXBcIikge1xuICAgICAgZGVidWcoYENoYXJ0LmFwcGx5U2VyaWVzKCkgLSBjcmVhdGluZyBuZXcgc2VyaWVzIGluc3RhbmNlcywgc3RhdHVzOiAke21hdGNoUmVzdWx0LnN0YXR1c31gLCBtYXRjaFJlc3VsdCk7XG4gICAgICBjaGFydC5zZXJpZXMgPSBvcHRTZXJpZXMubWFwKChvcHRzKSA9PiB0aGlzLmNyZWF0ZVNlcmllcyhvcHRzKSk7XG4gICAgICB0aGlzLmluaXRTZXJpZXNEZWNsYXJhdGlvbk9yZGVyKGNoYXJ0LnNlcmllcyk7XG4gICAgICByZXR1cm4gXCJyZXBsYWNlZFwiO1xuICAgIH1cbiAgICBkZWJ1ZyhgQ2hhcnQuYXBwbHlTZXJpZXMoKSAtIG1hdGNoUmVzdWx0YCwgbWF0Y2hSZXN1bHQpO1xuICAgIGNvbnN0IHNlcmllc0luc3RhbmNlcyA9IFtdO1xuICAgIGxldCBkYXRhQ2hhbmdlZCA9IGZhbHNlO1xuICAgIGxldCBncm91cGluZ0NoYW5nZWQgPSBmYWxzZTtcbiAgICBsZXQgaXNVcGRhdGVkID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBjaGFuZ2Ugb2YgbWF0Y2hSZXN1bHQuY2hhbmdlcykge1xuICAgICAgZ3JvdXBpbmdDaGFuZ2VkIHx8IChncm91cGluZ0NoYW5nZWQgPSBjaGFuZ2Uuc3RhdHVzID09PSBcInNlcmllcy1ncm91cGluZ1wiKTtcbiAgICAgIGRhdGFDaGFuZ2VkIHx8IChkYXRhQ2hhbmdlZCA9IGNoYW5nZS5kaWZmPy5kYXRhICE9IG51bGwpO1xuICAgICAgaXNVcGRhdGVkIHx8IChpc1VwZGF0ZWQgPSBjaGFuZ2Uuc3RhdHVzICE9PSBcIm5vLW9wXCIpO1xuICAgICAgc3dpdGNoIChjaGFuZ2Uuc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgXCJhZGRcIjoge1xuICAgICAgICAgIGNvbnN0IG5ld1NlcmllcyA9IHRoaXMuY3JlYXRlU2VyaWVzKGNoYW5nZS5vcHRzKTtcbiAgICAgICAgICBzZXJpZXNJbnN0YW5jZXMucHVzaChuZXdTZXJpZXMpO1xuICAgICAgICAgIGRlYnVnKGBDaGFydC5hcHBseVNlcmllcygpIC0gY3JlYXRlZCBuZXcgc2VyaWVzYCwgbmV3U2VyaWVzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwicmVtb3ZlXCI6XG4gICAgICAgICAgZGVidWcoYENoYXJ0LmFwcGx5U2VyaWVzKCkgLSByZW1vdmluZyBzZXJpZXMgYXQgcHJldmlvdXMgaWR4ICR7Y2hhbmdlLmlkeH1gLCBjaGFuZ2Uuc2VyaWVzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm5vLW9wXCI6XG4gICAgICAgICAgc2VyaWVzSW5zdGFuY2VzLnB1c2goY2hhbmdlLnNlcmllcyk7XG4gICAgICAgICAgZGVidWcoYENoYXJ0LmFwcGx5U2VyaWVzKCkgLSBubyBjaGFuZ2UgdG8gc2VyaWVzIGF0IHByZXZpb3VzIGlkeCAke2NoYW5nZS5pZHh9YCwgY2hhbmdlLnNlcmllcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzZXJpZXMtZ3JvdXBpbmdcIjpcbiAgICAgICAgY2FzZSBcInVwZGF0ZVwiOlxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgY29uc3QgeyBzZXJpZXMsIGRpZmY6IGRpZmYyLCBpZHggfSA9IGNoYW5nZTtcbiAgICAgICAgICBkZWJ1ZyhgQ2hhcnQuYXBwbHlTZXJpZXMoKSAtIGFwcGx5aW5nIHNlcmllcyBkaWZmIHByZXZpb3VzIGlkeCAke2lkeH1gLCBkaWZmMiwgc2VyaWVzKTtcbiAgICAgICAgICB0aGlzLmFwcGx5U2VyaWVzVmFsdWVzKHNlcmllcywgZGlmZjIpO1xuICAgICAgICAgIHNlcmllcy5tYXJrTm9kZURhdGFEaXJ0eSgpO1xuICAgICAgICAgIHNlcmllc0luc3RhbmNlcy5wdXNoKHNlcmllcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5pbml0U2VyaWVzRGVjbGFyYXRpb25PcmRlcihzZXJpZXNJbnN0YW5jZXMpO1xuICAgIGRlYnVnKGBDaGFydC5hcHBseVNlcmllcygpIC0gZmluYWwgc2VyaWVzIGluc3RhbmNlc2AsIHNlcmllc0luc3RhbmNlcyk7XG4gICAgY2hhcnQuc2VyaWVzID0gc2VyaWVzSW5zdGFuY2VzO1xuICAgIGlmIChncm91cGluZ0NoYW5nZWQpIHtcbiAgICAgIHJldHVybiBcInNlcmllcy1ncm91cGluZy1jaGFuZ2VcIjtcbiAgICB9XG4gICAgaWYgKGRhdGFDaGFuZ2VkKSB7XG4gICAgICByZXR1cm4gXCJkYXRhLWNoYW5nZVwiO1xuICAgIH1cbiAgICByZXR1cm4gaXNVcGRhdGVkID8gXCJ1cGRhdGVkXCIgOiBcIm5vLW9wXCI7XG4gIH1cbiAgYXBwbHlBeGVzKGNoYXJ0LCBvcHRpb25zLCBvbGRPcHRzLCBzZXJpZXNTdGF0dXMsIHNraXAgPSBbXSwgcmVnaXN0ZXJSZWdpb25zID0gZmFsc2UpIHtcbiAgICBpZiAoIShcImF4ZXNcIiBpbiBvcHRpb25zKSB8fCAhb3B0aW9ucy5heGVzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNraXAgPSBbXCJheGVzW10udHlwZVwiLCAuLi5za2lwXTtcbiAgICBjb25zdCB7IGF4ZXMgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgZm9yY2VSZWNyZWF0ZSA9IHNlcmllc1N0YXR1cyA9PT0gXCJyZXBsYWNlZFwiO1xuICAgIGNvbnN0IG1hdGNoaW5nVHlwZXMgPSAhZm9yY2VSZWNyZWF0ZSAmJiBjaGFydC5heGVzLmxlbmd0aCA9PT0gYXhlcy5sZW5ndGggJiYgY2hhcnQuYXhlcy5ldmVyeSgoYSwgaSkgPT4gYS50eXBlID09PSBheGVzW2ldLnR5cGUpO1xuICAgIGlmIChtYXRjaGluZ1R5cGVzICYmIGlzQWdDYXJ0ZXNpYW5DaGFydE9wdGlvbnMob2xkT3B0cykpIHtcbiAgICAgIGNoYXJ0LmF4ZXMuZm9yRWFjaCgoYXhpcywgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgcHJldmlvdXNPcHRzID0gb2xkT3B0cy5heGVzPy5baW5kZXhdID8/IHt9O1xuICAgICAgICBjb25zdCBheGlzRGlmZiA9IGpzb25EaWZmKHByZXZpb3VzT3B0cywgYXhlc1tpbmRleF0pO1xuICAgICAgICBkZWJ1ZyhgQ2hhcnQuYXBwbHlBeGVzKCkgLSBhcHBseWluZyBheGlzIGRpZmYgaWR4ICR7aW5kZXh9YCwgYXhpc0RpZmYpO1xuICAgICAgICBjb25zdCBwYXRoID0gYGF4ZXNbJHtpbmRleH1dYDtcbiAgICAgICAganNvbkFwcGx5KGF4aXMsIGF4aXNEaWZmLCB7IHBhdGgsIHNraXAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBkZWJ1ZyhgQ2hhcnQuYXBwbHlBeGVzKCkgLSBjcmVhdGluZyBuZXcgYXhlcyBpbnN0YW5jZXM7IHNlcmllc1N0YXR1czogJHtzZXJpZXNTdGF0dXN9YCk7XG4gICAgY2hhcnQuYXhlcyA9IHRoaXMuY3JlYXRlQXhpcyhheGVzLCBza2lwKTtcbiAgICBjb25zdCBheGlzR3JvdXBzID0ge1xuICAgICAgW1wieFwiIC8qIFggKi9dOiBbXSxcbiAgICAgIFtcInlcIiAvKiBZICovXTogW11cbiAgICB9O1xuICAgIGNoYXJ0LmF4ZXMuZm9yRWFjaCgoYXhpcykgPT4ge1xuICAgICAgY29uc3QgeyBpZCB9ID0gYXhpcztcbiAgICAgIGNvbnN0IG5vZGUgPSBheGlzLmdldFJlZ2lvbk5vZGUoKTtcbiAgICAgIGlmIChub2RlICE9IG51bGwpIHtcbiAgICAgICAgYXhpc0dyb3Vwc1theGlzLmRpcmVjdGlvbl0ucHVzaCh7IGlkLCBub2RlIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChyZWdpc3RlclJlZ2lvbnMpIHtcbiAgICAgIHRoaXMuY3R4LnJlZ2lvbk1hbmFnZXIudXBkYXRlUmVnaW9uKFwiaG9yaXpvbnRhbC1heGVzXCIgLyogSE9SSVpPTlRBTF9BWEVTICovLCAuLi5heGlzR3JvdXBzW1wieFwiIC8qIFggKi9dKTtcbiAgICAgIHRoaXMuY3R4LnJlZ2lvbk1hbmFnZXIudXBkYXRlUmVnaW9uKFwidmVydGljYWwtYXhlc1wiIC8qIFZFUlRJQ0FMX0FYRVMgKi8sIC4uLmF4aXNHcm91cHNbXCJ5XCIgLyogWSAqL10pO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjcmVhdGVTZXJpZXMoc2VyaWVzT3B0aW9ucykge1xuICAgIGNvbnN0IHNlcmllc0luc3RhbmNlID0gc2VyaWVzUmVnaXN0cnkuY3JlYXRlKHNlcmllc09wdGlvbnMudHlwZSwgdGhpcy5nZXRNb2R1bGVDb250ZXh0KCkpO1xuICAgIHRoaXMuYXBwbHlTZXJpZXNPcHRpb25Nb2R1bGVzKHNlcmllc0luc3RhbmNlLCBzZXJpZXNPcHRpb25zKTtcbiAgICB0aGlzLmFwcGx5U2VyaWVzVmFsdWVzKHNlcmllc0luc3RhbmNlLCBzZXJpZXNPcHRpb25zKTtcbiAgICByZXR1cm4gc2VyaWVzSW5zdGFuY2U7XG4gIH1cbiAgYXBwbHlTZXJpZXNPcHRpb25Nb2R1bGVzKHNlcmllcywgb3B0aW9ucykge1xuICAgIGNvbnN0IG1vZHVsZUNvbnRleHQgPSBzZXJpZXMuY3JlYXRlTW9kdWxlQ29udGV4dCgpO1xuICAgIGNvbnN0IG1vZHVsZU1hcCA9IHNlcmllcy5nZXRNb2R1bGVNYXAoKTtcbiAgICBmb3IgKGNvbnN0IG1vZHVsZSBvZiBtb2R1bGVSZWdpc3RyeS5ieVR5cGUoXCJzZXJpZXMtb3B0aW9uXCIpKSB7XG4gICAgICBpZiAobW9kdWxlLm9wdGlvbnNLZXkgaW4gb3B0aW9ucyAmJiBtb2R1bGUuc2VyaWVzVHlwZXMuaW5jbHVkZXMoc2VyaWVzLnR5cGUpKSB7XG4gICAgICAgIG1vZHVsZU1hcC5hZGRNb2R1bGUobW9kdWxlLCAobSkgPT4gbS5tb2R1bGVGYWN0b3J5KG1vZHVsZUNvbnRleHQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYXBwbHlTZXJpZXNWYWx1ZXModGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgbW9kdWxlTWFwID0gdGFyZ2V0LmdldE1vZHVsZU1hcCgpO1xuICAgIGNvbnN0IHsgdHlwZTogXywgZGF0YSwgbGlzdGVuZXJzLCBzZXJpZXNHcm91cGluZywgc2hvd0luTWluaUNoYXJ0OiBfXywgLi4uc2VyaWVzT3B0aW9ucyB9ID0gb3B0aW9ucztcbiAgICBmb3IgKGNvbnN0IG1vZHVsZURlZiBvZiBFWFBFQ1RFRF9FTlRFUlBSSVNFX01PRFVMRVMpIHtcbiAgICAgIGlmIChtb2R1bGVEZWYudHlwZSAhPT0gXCJzZXJpZXMtb3B0aW9uXCIpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgaWYgKG1vZHVsZURlZi5vcHRpb25zS2V5IGluIHNlcmllc09wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbW9kdWxlID0gbW9kdWxlTWFwLmdldE1vZHVsZShtb2R1bGVEZWYub3B0aW9uc0tleSk7XG4gICAgICAgIGlmIChtb2R1bGUpIHtcbiAgICAgICAgICBjb25zdCBtb2R1bGVPcHRpb25zID0gc2VyaWVzT3B0aW9uc1ttb2R1bGVEZWYub3B0aW9uc0tleV07XG4gICAgICAgICAgZGVsZXRlIHNlcmllc09wdGlvbnNbbW9kdWxlRGVmLm9wdGlvbnNLZXldO1xuICAgICAgICAgIG1vZHVsZS5wcm9wZXJ0aWVzLnNldChtb2R1bGVPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0YXJnZXQucHJvcGVydGllcy5zZXQoc2VyaWVzT3B0aW9ucyk7XG4gICAgaWYgKFwiZGF0YVwiIGluIG9wdGlvbnMpIHtcbiAgICAgIHRhcmdldC5zZXRPcHRpb25zRGF0YShkYXRhKTtcbiAgICB9XG4gICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycyh0YXJnZXQsIGxpc3RlbmVycyk7XG4gICAgfVxuICAgIGlmIChcInNlcmllc0dyb3VwaW5nXCIgaW4gb3B0aW9ucykge1xuICAgICAgaWYgKHNlcmllc0dyb3VwaW5nID09IG51bGwpIHtcbiAgICAgICAgdGFyZ2V0LnNlcmllc0dyb3VwaW5nID0gdm9pZCAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0LnNlcmllc0dyb3VwaW5nID0geyAuLi50YXJnZXQuc2VyaWVzR3JvdXBpbmcsIC4uLnNlcmllc0dyb3VwaW5nIH07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNyZWF0ZUF4aXMob3B0aW9ucywgc2tpcCkge1xuICAgIGNvbnN0IG5ld0F4ZXMgPSBbXTtcbiAgICBjb25zdCBtb2R1bGVDb250ZXh0ID0gdGhpcy5nZXRNb2R1bGVDb250ZXh0KCk7XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IG9wdGlvbnMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBjb25zdCBheGlzT3B0aW9ucyA9IG9wdGlvbnNbaW5kZXhdO1xuICAgICAgY29uc3QgYXhpcyA9IGF4aXNSZWdpc3RyeS5jcmVhdGUoYXhpc09wdGlvbnMudHlwZSwgbW9kdWxlQ29udGV4dCk7XG4gICAgICB0aGlzLmFwcGx5QXhpc01vZHVsZXMoYXhpcywgYXhpc09wdGlvbnMpO1xuICAgICAganNvbkFwcGx5KGF4aXMsIGF4aXNPcHRpb25zLCB7IHBhdGg6IGBheGVzWyR7aW5kZXh9XWAsIHNraXAgfSk7XG4gICAgICBuZXdBeGVzLnB1c2goYXhpcyk7XG4gICAgfVxuICAgIGd1ZXNzSW52YWxpZFBvc2l0aW9ucyhuZXdBeGVzKTtcbiAgICByZXR1cm4gbmV3QXhlcztcbiAgfVxuICBhcHBseUF4aXNNb2R1bGVzKGF4aXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBtb2R1bGVDb250ZXh0ID0gYXhpcy5jcmVhdGVNb2R1bGVDb250ZXh0KCk7XG4gICAgY29uc3QgbW9kdWxlTWFwID0gYXhpcy5nZXRNb2R1bGVNYXAoKTtcbiAgICBmb3IgKGNvbnN0IG1vZHVsZSBvZiBtb2R1bGVSZWdpc3RyeS5ieVR5cGUoXCJheGlzLW9wdGlvblwiKSkge1xuICAgICAgY29uc3Qgc2hvdWxkQmVFbmFibGVkID0gb3B0aW9uc1ttb2R1bGUub3B0aW9uc0tleV0gIT0gbnVsbDtcbiAgICAgIGlmIChzaG91bGRCZUVuYWJsZWQgPT09IG1vZHVsZU1hcC5pc0VuYWJsZWQobW9kdWxlKSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBpZiAoc2hvdWxkQmVFbmFibGVkKSB7XG4gICAgICAgIG1vZHVsZU1hcC5hZGRNb2R1bGUobW9kdWxlLCAobSkgPT4gbS5tb2R1bGVGYWN0b3J5KG1vZHVsZUNvbnRleHQpKTtcbiAgICAgICAgYXhpc1ttb2R1bGUub3B0aW9uc0tleV0gPSBtb2R1bGVNYXAuZ2V0TW9kdWxlKG1vZHVsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtb2R1bGVNYXAucmVtb3ZlTW9kdWxlKG1vZHVsZSk7XG4gICAgICAgIGRlbGV0ZSBheGlzW21vZHVsZS5vcHRpb25zS2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmVnaXN0ZXJMaXN0ZW5lcnMoc291cmNlLCBsaXN0ZW5lcnMpIHtcbiAgICBzb3VyY2UuY2xlYXJFdmVudExpc3RlbmVycygpO1xuICAgIGZvciAoY29uc3QgW3Byb3BlcnR5LCBsaXN0ZW5lcl0gb2YgT2JqZWN0LmVudHJpZXMobGlzdGVuZXJzKSkge1xuICAgICAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXIpKSB7XG4gICAgICAgIHNvdXJjZS5hZGRFdmVudExpc3RlbmVyKHByb3BlcnR5LCBsaXN0ZW5lcik7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuX0NoYXJ0LmNoYXJ0c0luc3RhbmNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgQWN0aW9uT25TZXQoe1xuICAgIG5ld1ZhbHVlKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMuY3R4LmRvbU1hbmFnZXIuc2V0Q29udGFpbmVyKHZhbHVlKTtcbiAgICAgIF9DaGFydC5jaGFydHNJbnN0YW5jZXMuc2V0KHZhbHVlLCB0aGlzKTtcbiAgICB9LFxuICAgIG9sZFZhbHVlKHZhbHVlKSB7XG4gICAgICBfQ2hhcnQuY2hhcnRzSW5zdGFuY2VzLmRlbGV0ZSh2YWx1ZSk7XG4gICAgfVxuICB9KVxuXSwgX0NoYXJ0LnByb3RvdHlwZSwgXCJjb250YWluZXJcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBBY3Rpb25PblNldCh7XG4gICAgbmV3VmFsdWUodmFsdWUpIHtcbiAgICAgIHRoaXMucmVzaXplKFwid2lkdGggb3B0aW9uXCIsIHsgaW5XaWR0aDogdmFsdWUgfSk7XG4gICAgfVxuICB9KVxuXSwgX0NoYXJ0LnByb3RvdHlwZSwgXCJ3aWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEFjdGlvbk9uU2V0KHtcbiAgICBuZXdWYWx1ZSh2YWx1ZSkge1xuICAgICAgdGhpcy5yZXNpemUoXCJoZWlnaHQgb3B0aW9uXCIsIHsgaW5IZWlnaHQ6IHZhbHVlIH0pO1xuICAgIH1cbiAgfSlcbl0sIF9DaGFydC5wcm90b3R5cGUsIFwiaGVpZ2h0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgQWN0aW9uT25TZXQoe1xuICAgIG5ld1ZhbHVlKHZhbHVlKSB7XG4gICAgICB0aGlzLnJlc2l6ZShcIm1pbldpZHRoIG9wdGlvblwiLCB7IGluTWluV2lkdGg6IHZhbHVlIH0pO1xuICAgIH1cbiAgfSlcbl0sIF9DaGFydC5wcm90b3R5cGUsIFwibWluV2lkdGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBBY3Rpb25PblNldCh7XG4gICAgbmV3VmFsdWUodmFsdWUpIHtcbiAgICAgIHRoaXMucmVzaXplKFwibWluSGVpZ2h0IG9wdGlvblwiLCB7IGluTWluSGVpZ2h0OiB2YWx1ZSB9KTtcbiAgICB9XG4gIH0pXG5dLCBfQ2hhcnQucHJvdG90eXBlLCBcIm1pbkhlaWdodFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIF9DaGFydC5wcm90b3R5cGUsIFwicGFkZGluZ1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIF9DaGFydC5wcm90b3R5cGUsIFwic2VyaWVzQXJlYVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIF9DaGFydC5wcm90b3R5cGUsIFwia2V5Ym9hcmRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShVTklPTihbXCJzdGFuZGFsb25lXCIsIFwiaW50ZWdyYXRlZFwiXSwgXCJhIGNoYXJ0IG1vZGVcIikpXG5dLCBfQ2hhcnQucHJvdG90eXBlLCBcIm1vZGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBQcm94eVByb3BlcnR5KFwiY2hhcnRDYXB0aW9ucy50aXRsZVwiKVxuXSwgX0NoYXJ0LnByb3RvdHlwZSwgXCJ0aXRsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHkoXCJjaGFydENhcHRpb25zLnN1YnRpdGxlXCIpXG5dLCBfQ2hhcnQucHJvdG90eXBlLCBcInN1YnRpdGxlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgUHJveHlQcm9wZXJ0eShcImNoYXJ0Q2FwdGlvbnMuZm9vdG5vdGVcIilcbl0sIF9DaGFydC5wcm90b3R5cGUsIFwiZm9vdG5vdGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBBY3Rpb25PblNldCh7XG4gICAgY2hhbmdlVmFsdWUobmV3VmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICB0aGlzLm9uQXhpc0NoYW5nZShuZXdWYWx1ZSwgb2xkVmFsdWUpO1xuICAgIH1cbiAgfSlcbl0sIF9DaGFydC5wcm90b3R5cGUsIFwiYXhlc1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEFjdGlvbk9uU2V0KHtcbiAgICBjaGFuZ2VWYWx1ZShuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgIHRoaXMub25TZXJpZXNDaGFuZ2UobmV3VmFsdWUsIG9sZFZhbHVlKTtcbiAgICB9XG4gIH0pXG5dLCBfQ2hhcnQucHJvdG90eXBlLCBcInNlcmllc1wiLCAyKTtcbnZhciBDaGFydCA9IF9DaGFydDtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvdXRpbC9xdWFkdHJlZS50c1xudmFyIFF1YWR0cmVlTmVhcmVzdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2FwYWNpdHksIG1heGRlcHRoLCBib3VuZGFyeSkge1xuICAgIHRoaXMucm9vdCA9IG5ldyBRdWFkdHJlZU5vZGVOZWFyZXN0KGNhcGFjaXR5LCBtYXhkZXB0aCwgYm91bmRhcnkpO1xuICB9XG4gIGNsZWFyKGJvdW5kYXJ5KSB7XG4gICAgdGhpcy5yb290LmNsZWFyKGJvdW5kYXJ5KTtcbiAgfVxuICBhZGRWYWx1ZShoaXRUZXN0ZXIsIHZhbHVlKSB7XG4gICAgY29uc3QgZWxlbSA9IHtcbiAgICAgIGhpdFRlc3RlcixcbiAgICAgIHZhbHVlLFxuICAgICAgZGlzdGFuY2VTcXVhcmVkOiAoeCwgeSkgPT4ge1xuICAgICAgICByZXR1cm4gaGl0VGVzdGVyLmRpc3RhbmNlU3F1YXJlZCh4LCB5KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMucm9vdC5hZGRFbGVtKGVsZW0pO1xuICB9XG4gIGZpbmQoeCwgeSkge1xuICAgIGNvbnN0IGFyZyA9IHsgYmVzdDogeyBuZWFyZXN0OiB2b2lkIDAsIGRpc3RhbmNlU3F1YXJlZDogSW5maW5pdHkgfSB9O1xuICAgIHRoaXMucm9vdC5maW5kKHgsIHksIGFyZyk7XG4gICAgcmV0dXJuIGFyZy5iZXN0O1xuICB9XG59O1xudmFyIFF1YWR0cmVlU3ViZGl2aXNpb25zID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihudywgbmUsIHN3LCBzZSkge1xuICAgIHRoaXMubncgPSBudztcbiAgICB0aGlzLm5lID0gbmU7XG4gICAgdGhpcy5zdyA9IHN3O1xuICAgIHRoaXMuc2UgPSBzZTtcbiAgfVxuICBhZGRFbGVtKGVsZW0pIHtcbiAgICB0aGlzLm53LmFkZEVsZW0oZWxlbSk7XG4gICAgdGhpcy5uZS5hZGRFbGVtKGVsZW0pO1xuICAgIHRoaXMuc3cuYWRkRWxlbShlbGVtKTtcbiAgICB0aGlzLnNlLmFkZEVsZW0oZWxlbSk7XG4gIH1cbiAgZmluZCh4LCB5LCBhcmcpIHtcbiAgICB0aGlzLm53LmZpbmQoeCwgeSwgYXJnKTtcbiAgICB0aGlzLm5lLmZpbmQoeCwgeSwgYXJnKTtcbiAgICB0aGlzLnN3LmZpbmQoeCwgeSwgYXJnKTtcbiAgICB0aGlzLnNlLmZpbmQoeCwgeSwgYXJnKTtcbiAgfVxufTtcbnZhciBRdWFkdHJlZU5vZGUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNhcGFjaXR5LCBtYXhkZXB0aCwgYm91bmRhcnkpIHtcbiAgICB0aGlzLmNhcGFjaXR5ID0gY2FwYWNpdHk7XG4gICAgdGhpcy5tYXhkZXB0aCA9IG1heGRlcHRoO1xuICAgIHRoaXMuYm91bmRhcnkgPSBib3VuZGFyeSA/PyBCQm94Lk5hTjtcbiAgICB0aGlzLmVsZW1zID0gW107XG4gICAgdGhpcy5zdWJkaXZpc2lvbnMgPSB2b2lkIDA7XG4gIH1cbiAgY2xlYXIoYm91bmRhcnkpIHtcbiAgICB0aGlzLmVsZW1zLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5ib3VuZGFyeSA9IGJvdW5kYXJ5O1xuICAgIHRoaXMuc3ViZGl2aXNpb25zID0gdm9pZCAwO1xuICB9XG4gIGFkZEVsZW0oZSkge1xuICAgIGlmICh0aGlzLmFkZENvbmRpdGlvbihlKSkge1xuICAgICAgaWYgKHRoaXMuc3ViZGl2aXNpb25zID09PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKHRoaXMubWF4ZGVwdGggPT09IDAgfHwgdGhpcy5lbGVtcy5sZW5ndGggPCB0aGlzLmNhcGFjaXR5KSB7XG4gICAgICAgICAgdGhpcy5lbGVtcy5wdXNoKGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc3ViZGl2aWRlKGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN1YmRpdmlzaW9ucy5hZGRFbGVtKGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmaW5kKHgsIHksIGFyZykge1xuICAgIGlmICh0aGlzLmZpbmRDb25kaXRpb24oeCwgeSwgYXJnKSkge1xuICAgICAgaWYgKHRoaXMuc3ViZGl2aXNpb25zID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhpcy5maW5kQWN0aW9uKHgsIHksIGFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN1YmRpdmlzaW9ucy5maW5kKHgsIHksIGFyZyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHN1YmRpdmlkZShuZXdFbGVtKSB7XG4gICAgdGhpcy5zdWJkaXZpc2lvbnMgPSB0aGlzLm1ha2VTdWJkaXZpc2lvbnMoKTtcbiAgICBmb3IgKGNvbnN0IGUgb2YgdGhpcy5lbGVtcykge1xuICAgICAgdGhpcy5zdWJkaXZpc2lvbnMuYWRkRWxlbShlKTtcbiAgICB9XG4gICAgdGhpcy5zdWJkaXZpc2lvbnMuYWRkRWxlbShuZXdFbGVtKTtcbiAgICB0aGlzLmVsZW1zLmxlbmd0aCA9IDA7XG4gIH1cbiAgbWFrZVN1YmRpdmlzaW9ucygpIHtcbiAgICBjb25zdCB7IHgsIHksIHdpZHRoOiB3aWR0aDIsIGhlaWdodDogaGVpZ2h0MiB9ID0gdGhpcy5ib3VuZGFyeTtcbiAgICBjb25zdCB7IGNhcGFjaXR5IH0gPSB0aGlzO1xuICAgIGNvbnN0IGRlcHRoID0gdGhpcy5tYXhkZXB0aCAtIDE7XG4gICAgY29uc3QgaGFsZldpZHRoID0gd2lkdGgyIC8gMjtcbiAgICBjb25zdCBoYWxmSGVpZ2h0ID0gaGVpZ2h0MiAvIDI7XG4gICAgY29uc3QgbndCb3VuZGFyeSA9IG5ldyBCQm94KHgsIHksIGhhbGZXaWR0aCwgaGFsZkhlaWdodCk7XG4gICAgY29uc3QgbmVCb3VuZGFyeSA9IG5ldyBCQm94KHggKyBoYWxmV2lkdGgsIHksIGhhbGZXaWR0aCwgaGFsZkhlaWdodCk7XG4gICAgY29uc3Qgc3dCb3VuZGFyeSA9IG5ldyBCQm94KHgsIHkgKyBoYWxmSGVpZ2h0LCBoYWxmV2lkdGgsIGhhbGZIZWlnaHQpO1xuICAgIGNvbnN0IHNlQm91bmRhcnkgPSBuZXcgQkJveCh4ICsgaGFsZldpZHRoLCB5ICsgaGFsZkhlaWdodCwgaGFsZldpZHRoLCBoYWxmSGVpZ2h0KTtcbiAgICByZXR1cm4gbmV3IFF1YWR0cmVlU3ViZGl2aXNpb25zKFxuICAgICAgdGhpcy5jaGlsZChjYXBhY2l0eSwgZGVwdGgsIG53Qm91bmRhcnkpLFxuICAgICAgdGhpcy5jaGlsZChjYXBhY2l0eSwgZGVwdGgsIG5lQm91bmRhcnkpLFxuICAgICAgdGhpcy5jaGlsZChjYXBhY2l0eSwgZGVwdGgsIHN3Qm91bmRhcnkpLFxuICAgICAgdGhpcy5jaGlsZChjYXBhY2l0eSwgZGVwdGgsIHNlQm91bmRhcnkpXG4gICAgKTtcbiAgfVxufTtcbnZhciBRdWFkdHJlZU5vZGVOZWFyZXN0ID0gY2xhc3MgX1F1YWR0cmVlTm9kZU5lYXJlc3QgZXh0ZW5kcyBRdWFkdHJlZU5vZGUge1xuICBhZGRDb25kaXRpb24oZSkge1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gZS5oaXRUZXN0ZXIubWlkUG9pbnQ7XG4gICAgcmV0dXJuIHRoaXMuYm91bmRhcnkuY29udGFpbnNQb2ludCh4LCB5KTtcbiAgfVxuICBmaW5kQ29uZGl0aW9uKHgsIHksIGFyZykge1xuICAgIGNvbnN0IHsgYmVzdCB9ID0gYXJnO1xuICAgIHJldHVybiBiZXN0LmRpc3RhbmNlU3F1YXJlZCAhPT0gMCAmJiB0aGlzLmJvdW5kYXJ5LmRpc3RhbmNlU3F1YXJlZCh4LCB5KSA8IGJlc3QuZGlzdGFuY2VTcXVhcmVkO1xuICB9XG4gIGZpbmRBY3Rpb24oeCwgeSwgYXJnKSB7XG4gICAgY29uc3Qgb3RoZXIgPSBuZWFyZXN0U3F1YXJlZCh4LCB5LCB0aGlzLmVsZW1zLCBhcmcuYmVzdC5kaXN0YW5jZVNxdWFyZWQpO1xuICAgIGlmIChvdGhlci5uZWFyZXN0ICE9PSB2b2lkIDAgJiYgb3RoZXIuZGlzdGFuY2VTcXVhcmVkIDwgYXJnLmJlc3QuZGlzdGFuY2VTcXVhcmVkKSB7XG4gICAgICBhcmcuYmVzdCA9IG90aGVyO1xuICAgIH1cbiAgfVxuICBjaGlsZChjYXBhY2l0eSwgZGVwdGgsIGJvdW5kYXJ5KSB7XG4gICAgcmV0dXJuIG5ldyBfUXVhZHRyZWVOb2RlTmVhcmVzdChjYXBhY2l0eSwgZGVwdGgsIGJvdW5kYXJ5KTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbWFya2VyL21hcmtlci50c1xudmFyIEJVSUxUSU5fTUFSS0VSUyA9IFtcbiAgXCJBcnJvd0Rvd25cIixcbiAgXCJBcnJvd1VwXCIsXG4gIFwiQ2lyY2xlXCIsXG4gIFwiQ3Jvc3NcIixcbiAgXCJEaWFtb25kXCIsXG4gIFwiSGVhcnRcIixcbiAgXCJNYXBQaW5cIixcbiAgXCJQbHVzXCIsXG4gIFwiU3F1YXJlXCIsXG4gIFwiU3RhclwiLFxuICBcIlRyaWFuZ2xlXCJcbl07XG52YXIgREVGQVVMVF9DRU5URVJfUE9JTlQgPSBPYmplY3QuZnJlZXplKHsgeDogMC41LCB5OiAwLjUgfSk7XG52YXIgSW50ZXJuYWxNYXJrZXIgPSBjbGFzcyBleHRlbmRzIFBhdGgge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMueCA9IDA7XG4gICAgdGhpcy55ID0gMDtcbiAgICB0aGlzLnNpemUgPSAxMjtcbiAgfVxuICBpc0J1aWx0SW4oKSB7XG4gICAgcmV0dXJuIEJVSUxUSU5fTUFSS0VSUy5pbmNsdWRlcyh0aGlzLmNvbnN0cnVjdG9yLmNsYXNzTmFtZSA/PyBcIlwiKTtcbiAgfVxuICBjb21wdXRlQkJveCgpIHtcbiAgICBpZiAoIXRoaXMuaXNCdWlsdEluKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhdGguY29tcHV0ZUJCb3goKTtcbiAgICB9XG4gICAgY29uc3QgeyB4LCB5LCBzaXplIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgY2VudGVyOiBjZW50ZXIyIH0gPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBuZXcgQkJveCh4IC0gc2l6ZSAqIGNlbnRlcjIueCwgeSAtIHNpemUgKiBjZW50ZXIyLnksIHNpemUsIHNpemUpO1xuICB9XG4gIGFwcGx5UGF0aChzLCBtb3Zlcykge1xuICAgIGNvbnN0IHsgcGF0aCB9ID0gdGhpcztcbiAgICBsZXQgeyB4LCB5IH0gPSB0aGlzO1xuICAgIHBhdGguY2xlYXIoKTtcbiAgICBmb3IgKGNvbnN0IHsgeDogbXgsIHk6IG15LCB0IH0gb2YgbW92ZXMpIHtcbiAgICAgIHggKz0gbXggKiBzO1xuICAgICAgeSArPSBteSAqIHM7XG4gICAgICBpZiAodCA9PT0gXCJtb3ZlXCIpIHtcbiAgICAgICAgcGF0aC5tb3ZlVG8oeCwgeSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXRoLmxpbmVUbyh4LCB5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgfVxuICBleGVjdXRlRmlsbChjdHgsIHBhdGgpIHtcbiAgICBpZiAoIXBhdGgpXG4gICAgICByZXR1cm47XG4gICAgcmV0dXJuIHN1cGVyLmV4ZWN1dGVGaWxsKGN0eCwgcGF0aCk7XG4gIH1cbiAgZXhlY3V0ZVN0cm9rZShjdHgsIHBhdGgpIHtcbiAgICBpZiAoIXBhdGgpXG4gICAgICByZXR1cm47XG4gICAgcmV0dXJuIHN1cGVyLmV4ZWN1dGVTdHJva2UoY3R4LCBwYXRoKTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBJbnRlcm5hbE1hcmtlci5wcm90b3R5cGUsIFwieFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBJbnRlcm5hbE1hcmtlci5wcm90b3R5cGUsIFwieVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbih7IGNvbnZlcnRvcjogTWF0aC5hYnMgfSlcbl0sIEludGVybmFsTWFya2VyLnByb3RvdHlwZSwgXCJzaXplXCIsIDIpO1xudmFyIE1hcmtlciA9IGNsYXNzIGV4dGVuZHMgUm90YXRhYmxlKFNjYWxhYmxlKFRyYW5zbGF0YWJsZShJbnRlcm5hbE1hcmtlcikpKSB7XG59O1xuTWFya2VyLmNlbnRlciA9IERFRkFVTFRfQ0VOVEVSX1BPSU5UO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9tYXJrZXIvY2lyY2xlLnRzXG52YXIgQ2lyY2xlID0gY2xhc3MgZXh0ZW5kcyBNYXJrZXIge1xuICB1cGRhdGVQYXRoKCkge1xuICAgIGNvbnN0IHsgeCwgeSwgcGF0aCwgc2l6ZSB9ID0gdGhpcztcbiAgICBjb25zdCByID0gc2l6ZSAvIDI7XG4gICAgcGF0aC5jbGVhcigpO1xuICAgIHBhdGguYXJjKHgsIHksIHIsIDAsIE1hdGguUEkgKiAyKTtcbiAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICB9XG59O1xuQ2lyY2xlLmNsYXNzTmFtZSA9IFwiQ2lyY2xlXCI7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L21hcmtlci9jcm9zcy50c1xudmFyIF9Dcm9zcyA9IGNsYXNzIF9Dcm9zcyBleHRlbmRzIE1hcmtlciB7XG4gIHVwZGF0ZVBhdGgoKSB7XG4gICAgY29uc3QgcyA9IHRoaXMuc2l6ZSAvIDQuMjtcbiAgICBzdXBlci5hcHBseVBhdGgocywgX0Nyb3NzLm1vdmVzKTtcbiAgfVxufTtcbl9Dcm9zcy5jbGFzc05hbWUgPSBcIkNyb3NzXCI7XG5fQ3Jvc3MubW92ZXMgPSBbXG4gIHsgeDogLTEsIHk6IDAsIHQ6IFwibW92ZVwiIH0sXG4gIHsgeDogLTEsIHk6IC0xIH0sXG4gIHsgeDogMSwgeTogLTEgfSxcbiAgeyB4OiAxLCB5OiAxIH0sXG4gIHsgeDogMSwgeTogLTEgfSxcbiAgeyB4OiAxLCB5OiAxIH0sXG4gIHsgeDogLTEsIHk6IDEgfSxcbiAgeyB4OiAxLCB5OiAxIH0sXG4gIHsgeDogLTEsIHk6IDEgfSxcbiAgeyB4OiAtMSwgeTogLTEgfSxcbiAgeyB4OiAtMSwgeTogMSB9LFxuICB7IHg6IC0xLCB5OiAtMSB9XG5dO1xudmFyIENyb3NzID0gX0Nyb3NzO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9tYXJrZXIvZGlhbW9uZC50c1xudmFyIF9EaWFtb25kID0gY2xhc3MgX0RpYW1vbmQgZXh0ZW5kcyBNYXJrZXIge1xuICB1cGRhdGVQYXRoKCkge1xuICAgIGNvbnN0IHMgPSB0aGlzLnNpemUgLyAyO1xuICAgIHN1cGVyLmFwcGx5UGF0aChzLCBfRGlhbW9uZC5tb3Zlcyk7XG4gIH1cbn07XG5fRGlhbW9uZC5jbGFzc05hbWUgPSBcIkRpYW1vbmRcIjtcbl9EaWFtb25kLm1vdmVzID0gW1xuICB7IHg6IDAsIHk6IC0xLCB0OiBcIm1vdmVcIiB9LFxuICB7IHg6IDEsIHk6IDEgfSxcbiAgeyB4OiAtMSwgeTogMSB9LFxuICB7IHg6IC0xLCB5OiAtMSB9LFxuICB7IHg6IDEsIHk6IC0xIH1cbl07XG52YXIgRGlhbW9uZCA9IF9EaWFtb25kO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9tYXJrZXIvaGVhcnQudHNcbnZhciBIZWFydCA9IGNsYXNzIGV4dGVuZHMgTWFya2VyIHtcbiAgcmFkKGRlZ3JlZTIpIHtcbiAgICByZXR1cm4gZGVncmVlMiAvIDE4MCAqIE1hdGguUEk7XG4gIH1cbiAgdXBkYXRlUGF0aCgpIHtcbiAgICBjb25zdCB7IHgsIHBhdGgsIHNpemUsIHJhZCB9ID0gdGhpcztcbiAgICBjb25zdCByID0gc2l6ZSAvIDQ7XG4gICAgY29uc3QgeSA9IHRoaXMueSArIHIgLyAyO1xuICAgIHBhdGguY2xlYXIoKTtcbiAgICBwYXRoLmFyYyh4IC0gciwgeSAtIHIsIHIsIHJhZCgxMzApLCByYWQoMzMwKSk7XG4gICAgcGF0aC5hcmMoeCArIHIsIHkgLSByLCByLCByYWQoMjIwKSwgcmFkKDUwKSk7XG4gICAgcGF0aC5saW5lVG8oeCwgeSArIHIpO1xuICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gIH1cbn07XG5IZWFydC5jbGFzc05hbWUgPSBcIkhlYXJ0XCI7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L21hcmtlci9waW4udHNcbnZhciBQaW4gPSBjbGFzcyBleHRlbmRzIE1hcmtlciB7XG4gIHVwZGF0ZVBhdGgoKSB7XG4gICAgY29uc3QgeyBwYXRoLCB4LCB5IH0gPSB0aGlzO1xuICAgIGNvbnN0IHMgPSB0aGlzLnNpemU7XG4gICAgY29uc3QgY3ggPSAwLjU7XG4gICAgY29uc3QgY3kgPSAxO1xuICAgIHBhdGguY2xlYXIoKTtcbiAgICBwYXRoLm1vdmVUbyh4ICsgKDAuMTU2MjUgLSBjeCkgKiBzLCB5ICsgKDAuMzQzNzUgLSBjeSkgKiBzKTtcbiAgICBwYXRoLmN1YmljQ3VydmVUbyhcbiAgICAgIHggKyAoMC4xNTYyNSAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAuMTUxNDkxIC0gY3kpICogcyxcbiAgICAgIHggKyAoMC4zMDc3NDEgLSBjeCkgKiBzLFxuICAgICAgeSArICgwIC0gY3kpICogcyxcbiAgICAgIHggKyAoMC41IC0gY3gpICogcyxcbiAgICAgIHkgKyAoMCAtIGN5KSAqIHNcbiAgICApO1xuICAgIHBhdGguY3ViaWNDdXJ2ZVRvKFxuICAgICAgeCArICgwLjY5MjI1OSAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAgLSBjeSkgKiBzLFxuICAgICAgeCArICgwLjg0Mzc1IC0gY3gpICogcyxcbiAgICAgIHkgKyAoMC4xNTE0OTEgLSBjeSkgKiBzLFxuICAgICAgeCArICgwLjg0Mzc1IC0gY3gpICogcyxcbiAgICAgIHkgKyAoMC4zNDM3NSAtIGN5KSAqIHNcbiAgICApO1xuICAgIHBhdGguY3ViaWNDdXJ2ZVRvKFxuICAgICAgeCArICgwLjg0Mzc1IC0gY3gpICogcyxcbiAgICAgIHkgKyAoMC40OTM4MjQgLSBjeSkgKiBzLFxuICAgICAgeCArICgwLjc4NDYyNSAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAuNjAwMTgxIC0gY3kpICogcyxcbiAgICAgIHggKyAoMC43MTY0NjEgLSBjeCkgKiBzLFxuICAgICAgeSArICgwLjY5NTM5MyAtIGN5KSAqIHNcbiAgICApO1xuICAgIHBhdGguY3ViaWNDdXJ2ZVRvKFxuICAgICAgeCArICgwLjY5OTAwOSAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAuNzE5NzY5IC0gY3kpICogcyxcbiAgICAgIHggKyAoMC42ODEyNzEgLSBjeCkgKiBzLFxuICAgICAgeSArICgwLjc0MzEwNCAtIGN5KSAqIHMsXG4gICAgICB4ICsgKDAuNjYzNzg1IC0gY3gpICogcyxcbiAgICAgIHkgKyAoMC43NjYxMDUgLSBjeSkgKiBzXG4gICAgKTtcbiAgICBwYXRoLmN1YmljQ3VydmVUbyhcbiAgICAgIHggKyAoMC42MTE4OTMgLSBjeCkgKiBzLFxuICAgICAgeSArICgwLjgzNDM2NyAtIGN5KSAqIHMsXG4gICAgICB4ICsgKDAuNTYyMjI4IC0gY3gpICogcyxcbiAgICAgIHkgKyAoMC44OTk2OTkgLSBjeSkgKiBzLFxuICAgICAgeCArICgwLjUyODg5NiAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAuOTgwNjQ4IC0gY3kpICogc1xuICAgICk7XG4gICAgcGF0aC5jdWJpY0N1cnZlVG8oXG4gICAgICB4ICsgKDAuNTI0MDc1IC0gY3gpICogcyxcbiAgICAgIHkgKyAoMC45OTIzNTggLSBjeSkgKiBzLFxuICAgICAgeCArICgwLjUxMjY2MyAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDEgLSBjeSkgKiBzLFxuICAgICAgeCArICgwLjUgLSBjeCkgKiBzLFxuICAgICAgeSArICgxIC0gY3kpICogc1xuICAgICk7XG4gICAgcGF0aC5jdWJpY0N1cnZlVG8oXG4gICAgICB4ICsgKDAuNDg3MzM3IC0gY3gpICogcyxcbiAgICAgIHkgKyAoMSAtIGN5KSAqIHMsXG4gICAgICB4ICsgKDAuNDc1OTI1IC0gY3gpICogcyxcbiAgICAgIHkgKyAoMC45OTIzNTggLSBjeSkgKiBzLFxuICAgICAgeCArICgwLjQ3MTEwNCAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAuOTgwNjQ4IC0gY3kpICogc1xuICAgICk7XG4gICAgcGF0aC5jdWJpY0N1cnZlVG8oXG4gICAgICB4ICsgKDAuNDg3MzM3IC0gY3gpICogcyxcbiAgICAgIHkgKyAoMSAtIGN5KSAqIHMsXG4gICAgICB4ICsgKDAuNDc1OTI1IC0gY3gpICogcyxcbiAgICAgIHkgKyAoMC45OTIzNTggLSBjeSkgKiBzLFxuICAgICAgeCArICgwLjQ3MTEwNCAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAuOTgwNjQ4IC0gY3kpICogc1xuICAgICk7XG4gICAgcGF0aC5jdWJpY0N1cnZlVG8oXG4gICAgICB4ICsgKDAuNDM3NzcyIC0gY3gpICogcyxcbiAgICAgIHkgKyAoMC44OTk2OTkgLSBjeSkgKiBzLFxuICAgICAgeCArICgwLjM4ODEwNyAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAuODM0MzY3IC0gY3kpICogcyxcbiAgICAgIHggKyAoMC4zMzYyMTUgLSBjeCkgKiBzLFxuICAgICAgeSArICgwLjc2NjEwNSAtIGN5KSAqIHNcbiAgICApO1xuICAgIHBhdGguY3ViaWNDdXJ2ZVRvKFxuICAgICAgeCArICgwLjMxODcyOSAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAuNzQzMTA0IC0gY3kpICogcyxcbiAgICAgIHggKyAoMC4zMDA5OTEgLSBjeCkgKiBzLFxuICAgICAgeSArICgwLjcxOTc2OSAtIGN5KSAqIHMsXG4gICAgICB4ICsgKDAuMjgzNTM5IC0gY3gpICogcyxcbiAgICAgIHkgKyAoMC42OTUzOTMgLSBjeSkgKiBzXG4gICAgKTtcbiAgICBwYXRoLmN1YmljQ3VydmVUbyhcbiAgICAgIHggKyAoMC4yMTUzNzUgLSBjeCkgKiBzLFxuICAgICAgeSArICgwLjYwMDE4MSAtIGN5KSAqIHMsXG4gICAgICB4ICsgKDAuMTU2MjUgLSBjeCkgKiBzLFxuICAgICAgeSArICgwLjQ5MzgyNCAtIGN5KSAqIHMsXG4gICAgICB4ICsgKDAuMTU2MjUgLSBjeCkgKiBzLFxuICAgICAgeSArICgwLjM0Mzc1IC0gY3kpICogc1xuICAgICk7XG4gICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgfVxufTtcblBpbi5jbGFzc05hbWUgPSBcIk1hcFBpblwiO1xuUGluLmNlbnRlciA9IHsgeDogMC41LCB5OiAxIH07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L21hcmtlci9wbHVzLnRzXG52YXIgX1BsdXMgPSBjbGFzcyBfUGx1cyBleHRlbmRzIE1hcmtlciB7XG4gIHVwZGF0ZVBhdGgoKSB7XG4gICAgY29uc3QgcyA9IHRoaXMuc2l6ZSAvIDM7XG4gICAgc3VwZXIuYXBwbHlQYXRoKHMsIF9QbHVzLm1vdmVzKTtcbiAgfVxufTtcbl9QbHVzLmNsYXNzTmFtZSA9IFwiUGx1c1wiO1xuX1BsdXMubW92ZXMgPSBbXG4gIHsgeDogLTAuNSwgeTogLTAuNSwgdDogXCJtb3ZlXCIgfSxcbiAgeyB4OiAwLCB5OiAtMSB9LFxuICB7IHg6IDEsIHk6IDAgfSxcbiAgeyB4OiAwLCB5OiAxIH0sXG4gIHsgeDogMSwgeTogMCB9LFxuICB7IHg6IDAsIHk6IDEgfSxcbiAgeyB4OiAtMSwgeTogMCB9LFxuICB7IHg6IDAsIHk6IDEgfSxcbiAgeyB4OiAtMSwgeTogMCB9LFxuICB7IHg6IDAsIHk6IC0xIH0sXG4gIHsgeDogLTEsIHk6IDAgfSxcbiAgeyB4OiAwLCB5OiAtMSB9XG5dO1xudmFyIFBsdXMgPSBfUGx1cztcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbWFya2VyL3NxdWFyZS50c1xudmFyIFNxdWFyZSA9IGNsYXNzIGV4dGVuZHMgTWFya2VyIHtcbiAgdXBkYXRlUGF0aCgpIHtcbiAgICBjb25zdCB7IHBhdGgsIHgsIHkgfSA9IHRoaXM7XG4gICAgY29uc3QgaHMgPSB0aGlzLnNpemUgLyAyO1xuICAgIHBhdGguY2xlYXIoKTtcbiAgICBwYXRoLm1vdmVUbyh0aGlzLmFsaWduKHggLSBocyksIHRoaXMuYWxpZ24oeSAtIGhzKSk7XG4gICAgcGF0aC5saW5lVG8odGhpcy5hbGlnbih4ICsgaHMpLCB0aGlzLmFsaWduKHkgLSBocykpO1xuICAgIHBhdGgubGluZVRvKHRoaXMuYWxpZ24oeCArIGhzKSwgdGhpcy5hbGlnbih5ICsgaHMpKTtcbiAgICBwYXRoLmxpbmVUbyh0aGlzLmFsaWduKHggLSBocyksIHRoaXMuYWxpZ24oeSArIGhzKSk7XG4gICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgfVxufTtcblNxdWFyZS5jbGFzc05hbWUgPSBcIlNxdWFyZVwiO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9tYXJrZXIvc3Rhci50c1xudmFyIFN0YXIgPSBjbGFzcyBleHRlbmRzIE1hcmtlciB7XG4gIHVwZGF0ZVBhdGgoKSB7XG4gICAgY29uc3QgeyB4LCB5LCBwYXRoLCBzaXplIH0gPSB0aGlzO1xuICAgIGNvbnN0IHNwaWtlcyA9IDU7XG4gICAgY29uc3QgaW5uZXJSYWRpdXMgPSBzaXplIC8gMjtcbiAgICBjb25zdCByb3RhdGlvbiA9IE1hdGguUEkgLyAyO1xuICAgIHBhdGguY2xlYXIoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNwaWtlcyAqIDI7IGkrKykge1xuICAgICAgY29uc3QgcmFkaXVzID0gaSAlIDIgPT09IDAgPyBzaXplIDogaW5uZXJSYWRpdXM7XG4gICAgICBjb25zdCBhbmdsZTIgPSBpICogTWF0aC5QSSAvIHNwaWtlcyAtIHJvdGF0aW9uO1xuICAgICAgY29uc3QgeENvb3JkaW5hdGUgPSB4ICsgTWF0aC5jb3MoYW5nbGUyKSAqIHJhZGl1cztcbiAgICAgIGNvbnN0IHlDb29yZGluYXRlID0geSArIE1hdGguc2luKGFuZ2xlMikgKiByYWRpdXM7XG4gICAgICBwYXRoLmxpbmVUbyh4Q29vcmRpbmF0ZSwgeUNvb3JkaW5hdGUpO1xuICAgIH1cbiAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICB9XG59O1xuU3Rhci5jbGFzc05hbWUgPSBcIlN0YXJcIjtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbWFya2VyL3RyaWFuZ2xlLnRzXG52YXIgX1RyaWFuZ2xlID0gY2xhc3MgX1RyaWFuZ2xlIGV4dGVuZHMgTWFya2VyIHtcbiAgdXBkYXRlUGF0aCgpIHtcbiAgICBjb25zdCBzID0gdGhpcy5zaXplICogMS4xO1xuICAgIHN1cGVyLmFwcGx5UGF0aChzLCBfVHJpYW5nbGUubW92ZXMpO1xuICB9XG59O1xuX1RyaWFuZ2xlLmNsYXNzTmFtZSA9IFwiVHJpYW5nbGVcIjtcbl9UcmlhbmdsZS5tb3ZlcyA9IFtcbiAgeyB4OiAwLCB5OiAtMC40OCwgdDogXCJtb3ZlXCIgfSxcbiAgeyB4OiAwLjUsIHk6IDAuODcgfSxcbiAgeyB4OiAtMSwgeTogMCB9XG5dO1xudmFyIFRyaWFuZ2xlID0gX1RyaWFuZ2xlO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9tYXJrZXIvdXRpbC50c1xudmFyIE1BUktFUl9TSEFQRVMgPSB7XG4gIGNpcmNsZTogQ2lyY2xlLFxuICBjcm9zczogQ3Jvc3MsXG4gIGRpYW1vbmQ6IERpYW1vbmQsXG4gIGhlYXJ0OiBIZWFydCxcbiAgcGluOiBQaW4sXG4gIHBsdXM6IFBsdXMsXG4gIHNxdWFyZTogU3F1YXJlLFxuICBzdGFyOiBTdGFyLFxuICB0cmlhbmdsZTogVHJpYW5nbGVcbn07XG52YXIgTUFSS0VSX1NVUFBPUlRFRF9TSEFQRVMgPSBPYmplY3Qua2V5cyhNQVJLRVJfU0hBUEVTKTtcbmZ1bmN0aW9uIGlzTWFya2VyU2hhcGUoc2hhcGUpIHtcbiAgcmV0dXJuIHR5cGVvZiBzaGFwZSA9PT0gXCJzdHJpbmdcIiAmJiBNQVJLRVJfU1VQUE9SVEVEX1NIQVBFUy5pbmNsdWRlcyhzaGFwZSk7XG59XG5mdW5jdGlvbiBnZXRNYXJrZXIoc2hhcGUgPSBTcXVhcmUpIHtcbiAgaWYgKGlzTWFya2VyU2hhcGUoc2hhcGUpKSB7XG4gICAgcmV0dXJuIE1BUktFUl9TSEFQRVNbc2hhcGVdO1xuICB9XG4gIGlmICh0eXBlb2Ygc2hhcGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBzaGFwZTtcbiAgfVxuICByZXR1cm4gU3F1YXJlO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvZGF0YU1vZGVsU2VyaWVzLnRzXG52YXIgRGF0YU1vZGVsU2VyaWVzID0gY2xhc3MgZXh0ZW5kcyBTZXJpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuc2hvd0ZvY3VzQm94ID0gdHJ1ZTtcbiAgfVxuICBnZXRTY2FsZUluZm9ybWF0aW9uKHtcbiAgICB4U2NhbGUsXG4gICAgeVNjYWxlXG4gIH0pIHtcbiAgICBjb25zdCBpc0NvbnRpbnVvdXNYID0gQ29udGludW91c1NjYWxlLmlzKHhTY2FsZSk7XG4gICAgY29uc3QgaXNDb250aW51b3VzWSA9IENvbnRpbnVvdXNTY2FsZS5pcyh5U2NhbGUpO1xuICAgIHJldHVybiB7IGlzQ29udGludW91c1gsIGlzQ29udGludW91c1ksIHhTY2FsZVR5cGU6IHhTY2FsZT8udHlwZSwgeVNjYWxlVHlwZTogeVNjYWxlPy50eXBlIH07XG4gIH1cbiAgZ2V0TW9kdWxlUHJvcGVydHlEZWZpbml0aW9ucygpIHtcbiAgICBjb25zdCB4U2NhbGUgPSB0aGlzLmF4ZXNbXCJ4XCIgLyogWCAqL10/LnNjYWxlO1xuICAgIGNvbnN0IHlTY2FsZSA9IHRoaXMuYXhlc1tcInlcIiAvKiBZICovXT8uc2NhbGU7XG4gICAgcmV0dXJuIHRoaXMubW9kdWxlTWFwLm1hcE1vZHVsZXMoKG1vZDIpID0+IG1vZDIuZ2V0UHJvcGVydHlEZWZpbml0aW9ucyh0aGlzLmdldFNjYWxlSW5mb3JtYXRpb24oeyB4U2NhbGUsIHlTY2FsZSB9KSkpLmZsYXQoKTtcbiAgfVxuICAvLyBSZXF1ZXN0IGRhdGEsIGJ1dCB3aXRoIG1lc3NhZ2UgZGlzcGF0Y2hpbmcgdG8gc2VyaWVzLW9wdGlvbnMgKG1vZHVsZXMpLlxuICBhc3luYyByZXF1ZXN0RGF0YU1vZGVsKGRhdGFDb250cm9sbGVyLCBkYXRhLCBvcHRzKSB7XG4gICAgb3B0cy5wcm9wcy5wdXNoKC4uLnRoaXMuZ2V0TW9kdWxlUHJvcGVydHlEZWZpbml0aW9ucygpKTtcbiAgICBjb25zdCB7IGRhdGFNb2RlbCwgcHJvY2Vzc2VkRGF0YSB9ID0gYXdhaXQgZGF0YUNvbnRyb2xsZXIucmVxdWVzdCh0aGlzLmlkLCBkYXRhID8/IFtdLCBvcHRzKTtcbiAgICB0aGlzLmRhdGFNb2RlbCA9IGRhdGFNb2RlbDtcbiAgICB0aGlzLnByb2Nlc3NlZERhdGEgPSBwcm9jZXNzZWREYXRhO1xuICAgIHRoaXMuZGlzcGF0Y2goXCJkYXRhLXByb2Nlc3NlZFwiLCB7IGRhdGFNb2RlbCwgcHJvY2Vzc2VkRGF0YSB9KTtcbiAgICByZXR1cm4geyBkYXRhTW9kZWwsIHByb2Nlc3NlZERhdGEgfTtcbiAgfVxuICBpc1Byb2Nlc3NlZERhdGFBbmltYXRhYmxlKCkge1xuICAgIGNvbnN0IHZhbGlkYXRpb25SZXN1bHRzID0gdGhpcy5wcm9jZXNzZWREYXRhPy5yZWR1Y2VkPy5hbmltYXRpb25WYWxpZGF0aW9uO1xuICAgIGlmICghdmFsaWRhdGlvblJlc3VsdHMpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCB7IG9yZGVyZWRLZXlzLCB1bmlxdWVLZXlzIH0gPSB2YWxpZGF0aW9uUmVzdWx0cztcbiAgICByZXR1cm4gb3JkZXJlZEtleXMgJiYgdW5pcXVlS2V5cztcbiAgfVxuICBjaGVja1Byb2Nlc3NlZERhdGFBbmltYXRhYmxlKCkge1xuICAgIGlmICghdGhpcy5pc1Byb2Nlc3NlZERhdGFBbmltYXRhYmxlKCkpIHtcbiAgICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuc2tpcEN1cnJlbnRCYXRjaCgpO1xuICAgIH1cbiAgfVxuICBwaWNrRm9jdXMob3B0cykge1xuICAgIGNvbnN0IG5vZGVEYXRhID0gdGhpcy5nZXROb2RlRGF0YSgpO1xuICAgIGlmIChub2RlRGF0YSA9PT0gdm9pZCAwIHx8IG5vZGVEYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkYXR1bUluZGV4ID0gdGhpcy5jb21wdXRlRm9jdXNEYXR1bUluZGV4KG9wdHMsIG5vZGVEYXRhKTtcbiAgICBpZiAoZGF0dW1JbmRleCA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgc2hvd0ZvY3VzQm94IH0gPSB0aGlzO1xuICAgIGNvbnN0IGRhdHVtID0gbm9kZURhdGFbZGF0dW1JbmRleF07XG4gICAgY29uc3QgZGVyaXZlZE9wdHMgPSB7IC4uLm9wdHMsIGRhdHVtSW5kZXggfTtcbiAgICBjb25zdCBib3VuZHMgPSB0aGlzLmNvbXB1dGVGb2N1c0JvdW5kcyhkZXJpdmVkT3B0cyk7XG4gICAgaWYgKGJvdW5kcyAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4geyBib3VuZHMsIHNob3dGb2N1c0JveCwgZGF0dW0sIGRhdHVtSW5kZXggfTtcbiAgICB9XG4gIH1cbiAgY29tcHV0ZUZvY3VzRGF0dW1JbmRleChvcHRzLCBub2RlRGF0YSkge1xuICAgIGNvbnN0IGlzRGF0dW1FbmFibGVkID0gKGRhdHVtSW5kZXgyKSA9PiB7XG4gICAgICBjb25zdCB7IG1pc3NpbmcgPSBmYWxzZSwgZW5hYmxlZCA9IHRydWUsIGZvY3VzYWJsZSA9IHRydWUgfSA9IG5vZGVEYXRhW2RhdHVtSW5kZXgyXTtcbiAgICAgIHJldHVybiAhbWlzc2luZyAmJiBlbmFibGVkICYmIGZvY3VzYWJsZTtcbiAgICB9O1xuICAgIGNvbnN0IHNlYXJjaEJhY2t3YXJkID0gKGRhdHVtSW5kZXgyKSA9PiB7XG4gICAgICB3aGlsZSAoZGF0dW1JbmRleDIgPj0gMCAmJiAhaXNEYXR1bUVuYWJsZWQoZGF0dW1JbmRleDIpKSB7XG4gICAgICAgIGRhdHVtSW5kZXgyLS07XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0dW1JbmRleDIgPT09IC0xID8gdm9pZCAwIDogZGF0dW1JbmRleDI7XG4gICAgfTtcbiAgICBjb25zdCBzZWFyY2hGb3J3YXJkID0gKGRhdHVtSW5kZXgyKSA9PiB7XG4gICAgICB3aGlsZSAoZGF0dW1JbmRleDIgPCBub2RlRGF0YS5sZW5ndGggJiYgIWlzRGF0dW1FbmFibGVkKGRhdHVtSW5kZXgyKSkge1xuICAgICAgICBkYXR1bUluZGV4MisrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdHVtSW5kZXgyID09PSBub2RlRGF0YS5sZW5ndGggPyB2b2lkIDAgOiBkYXR1bUluZGV4MjtcbiAgICB9O1xuICAgIGxldCBkYXR1bUluZGV4O1xuICAgIGNvbnN0IGNsYW1wZWRJbmRleCA9IGNsYW1wKDAsIG9wdHMuZGF0dW1JbmRleCwgbm9kZURhdGEubGVuZ3RoIC0gMSk7XG4gICAgaWYgKG9wdHMuZGF0dW1JbmRleERlbHRhIDwgMCkge1xuICAgICAgZGF0dW1JbmRleCA9IHNlYXJjaEJhY2t3YXJkKGNsYW1wZWRJbmRleCk7XG4gICAgfSBlbHNlIGlmIChvcHRzLmRhdHVtSW5kZXhEZWx0YSA+IDApIHtcbiAgICAgIGRhdHVtSW5kZXggPSBzZWFyY2hGb3J3YXJkKGNsYW1wZWRJbmRleCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdHVtSW5kZXggPSBzZWFyY2hGb3J3YXJkKGNsYW1wZWRJbmRleCkgPz8gc2VhcmNoQmFja3dhcmQoY2xhbXBlZEluZGV4KTtcbiAgICB9XG4gICAgaWYgKGRhdHVtSW5kZXggPT09IHZvaWQgMCkge1xuICAgICAgaWYgKG9wdHMuZGF0dW1JbmRleERlbHRhID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBvcHRzLmRhdHVtSW5kZXggLSBvcHRzLmRhdHVtSW5kZXhEZWx0YTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGRhdHVtSW5kZXg7XG4gICAgfVxuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvc2VyaWVzUHJvcGVydGllcy50c1xudmFyIFNlcmllc0l0ZW1IaWdobGlnaHRTdHlsZSA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuZmlsbCA9IFwicmdiYSgyNTUsMjU1LDI1NSwgMC4zMylcIjtcbiAgICB0aGlzLnN0cm9rZSA9IGByZ2JhKDAsIDAsIDAsIDAuNClgO1xuICAgIHRoaXMuc3Ryb2tlV2lkdGggPSAyO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBTZXJpZXNJdGVtSGlnaGxpZ2h0U3R5bGUucHJvdG90eXBlLCBcImZpbGxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgU2VyaWVzSXRlbUhpZ2hsaWdodFN0eWxlLnByb3RvdHlwZSwgXCJmaWxsT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgU2VyaWVzSXRlbUhpZ2hsaWdodFN0eWxlLnByb3RvdHlwZSwgXCJzdHJva2VcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFNlcmllc0l0ZW1IaWdobGlnaHRTdHlsZS5wcm90b3R5cGUsIFwic3Ryb2tlV2lkdGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgU2VyaWVzSXRlbUhpZ2hsaWdodFN0eWxlLnByb3RvdHlwZSwgXCJzdHJva2VPcGFjaXR5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTElORV9EQVNILCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBTZXJpZXNJdGVtSGlnaGxpZ2h0U3R5bGUucHJvdG90eXBlLCBcImxpbmVEYXNoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBTZXJpZXNJdGVtSGlnaGxpZ2h0U3R5bGUucHJvdG90eXBlLCBcImxpbmVEYXNoT2Zmc2V0XCIsIDIpO1xudmFyIFNlcmllc0hpZ2hsaWdodFN0eWxlID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBTZXJpZXNIaWdobGlnaHRTdHlsZS5wcm90b3R5cGUsIFwic3Ryb2tlV2lkdGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgU2VyaWVzSGlnaGxpZ2h0U3R5bGUucHJvdG90eXBlLCBcImRpbU9wYWNpdHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBTZXJpZXNIaWdobGlnaHRTdHlsZS5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCAyKTtcbnZhciBUZXh0SGlnaGxpZ2h0U3R5bGUgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmNvbG9yID0gXCJibGFja1wiO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBUZXh0SGlnaGxpZ2h0U3R5bGUucHJvdG90eXBlLCBcImNvbG9yXCIsIDIpO1xudmFyIEhpZ2hsaWdodFByb3BlcnRpZXMgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgSGlnaGxpZ2h0UHJvcGVydGllcy5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCAyKTtcbnZhciBIaWdobGlnaHRTdHlsZSA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuaXRlbSA9IG5ldyBTZXJpZXNJdGVtSGlnaGxpZ2h0U3R5bGUoKTtcbiAgICB0aGlzLnNlcmllcyA9IG5ldyBTZXJpZXNIaWdobGlnaHRTdHlsZSgpO1xuICAgIHRoaXMudGV4dCA9IG5ldyBUZXh0SGlnaGxpZ2h0U3R5bGUoKTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIEhpZ2hsaWdodFN0eWxlLnByb3RvdHlwZSwgXCJpdGVtXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgSGlnaGxpZ2h0U3R5bGUucHJvdG90eXBlLCBcInNlcmllc1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIEhpZ2hsaWdodFN0eWxlLnByb3RvdHlwZSwgXCJ0ZXh0XCIsIDIpO1xudmFyIFNlcmllc1Byb3BlcnRpZXMgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuICAgIHRoaXMuZm9jdXNQcmlvcml0eSA9IEluZmluaXR5O1xuICAgIHRoaXMuc2hvd0luTGVnZW5kID0gdHJ1ZTtcbiAgICB0aGlzLmN1cnNvciA9IFwiZGVmYXVsdFwiO1xuICAgIHRoaXMubm9kZUNsaWNrUmFuZ2UgPSBcImV4YWN0XCI7XG4gICAgdGhpcy5oaWdobGlnaHQgPSBuZXcgSGlnaGxpZ2h0UHJvcGVydGllcygpO1xuICAgIHRoaXMuaGlnaGxpZ2h0U3R5bGUgPSBuZXcgSGlnaGxpZ2h0U3R5bGUoKTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiaWRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJFQUxfTlVNQkVSLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJmb2N1c1ByaW9yaXR5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInNob3dJbkxlZ2VuZFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORylcbl0sIFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImN1cnNvclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKElOVEVSQUNUSU9OX1JBTkdFKVxuXSwgU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibm9kZUNsaWNrUmFuZ2VcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJoaWdobGlnaHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJoaWdobGlnaHRTdHlsZVwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9jYXJ0ZXNpYW5TZXJpZXMudHNcbnZhciBERUZBVUxUX0NBUlRFU0lBTl9ESVJFQ1RJT05fS0VZUyA9IHtcbiAgW1wieFwiIC8qIFggKi9dOiBbXCJ4S2V5XCJdLFxuICBbXCJ5XCIgLyogWSAqL106IFtcInlLZXlcIl1cbn07XG52YXIgREVGQVVMVF9DQVJURVNJQU5fRElSRUNUSU9OX05BTUVTID0ge1xuICBbXCJ4XCIgLyogWCAqL106IFtcInhOYW1lXCJdLFxuICBbXCJ5XCIgLyogWSAqL106IFtcInlOYW1lXCJdXG59O1xudmFyIENhcnRlc2lhblNlcmllc05vZGVFdmVudCA9IGNsYXNzIGV4dGVuZHMgU2VyaWVzTm9kZUV2ZW50IHtcbiAgY29uc3RydWN0b3IodHlwZSwgbmF0aXZlRXZlbnQsIGRhdHVtLCBzZXJpZXMpIHtcbiAgICBzdXBlcih0eXBlLCBuYXRpdmVFdmVudCwgZGF0dW0sIHNlcmllcyk7XG4gICAgdGhpcy54S2V5ID0gc2VyaWVzLnByb3BlcnRpZXMueEtleTtcbiAgICB0aGlzLnlLZXkgPSBzZXJpZXMucHJvcGVydGllcy55S2V5O1xuICB9XG59O1xudmFyIENhcnRlc2lhblNlcmllc1Byb3BlcnRpZXMgPSBjbGFzcyBleHRlbmRzIFNlcmllc1Byb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMucGlja091dHNpZGVWaXNpYmxlTWlub3JBeGlzID0gZmFsc2U7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIENhcnRlc2lhblNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImxlZ2VuZEl0ZW1OYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQ2FydGVzaWFuU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwicGlja091dHNpZGVWaXNpYmxlTWlub3JBeGlzXCIsIDIpO1xudmFyIENhcnRlc2lhblNlcmllcyA9IGNsYXNzIGV4dGVuZHMgRGF0YU1vZGVsU2VyaWVzIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHBhdGhzUGVyU2VyaWVzID0gW1wicGF0aFwiXSxcbiAgICBoYXNNYXJrZXJzID0gZmFsc2UsXG4gICAgaGFzSGlnaGxpZ2h0ZWRMYWJlbHMgPSBmYWxzZSxcbiAgICBwYXRoc1pJbmRleFN1Yk9yZGVyT2Zmc2V0ID0gW10sXG4gICAgZGF0dW1TZWxlY3Rpb25HYXJiYWdlQ29sbGVjdGlvbiA9IHRydWUsXG4gICAgbWFya2VyU2VsZWN0aW9uR2FyYmFnZUNvbGxlY3Rpb24gPSB0cnVlLFxuICAgIGFuaW1hdGlvbkFsd2F5c1VwZGF0ZVNlbGVjdGlvbnMgPSBmYWxzZSxcbiAgICBhbmltYXRpb25SZXNldEZucyxcbiAgICBkaXJlY3Rpb25LZXlzLFxuICAgIGRpcmVjdGlvbk5hbWVzLFxuICAgIC4uLm90aGVyT3B0c1xuICB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgZGlyZWN0aW9uS2V5cyxcbiAgICAgIGRpcmVjdGlvbk5hbWVzLFxuICAgICAgY2FuSGF2ZUF4ZXM6IHRydWUsXG4gICAgICAuLi5vdGhlck9wdHNcbiAgICB9KTtcbiAgICB0aGlzLk5vZGVFdmVudCA9IENhcnRlc2lhblNlcmllc05vZGVFdmVudDtcbiAgICB0aGlzLmRhdGFOb2RlR3JvdXAgPSB0aGlzLmNvbnRlbnRHcm91cC5hcHBlbmRDaGlsZChcbiAgICAgIG5ldyBHcm91cCh7XG4gICAgICAgIG5hbWU6IGAke3RoaXMuaWR9LXNlcmllcy1kYXRhTm9kZXNgLFxuICAgICAgICB6SW5kZXg6IDQgLyogU0VSSUVTX0xBWUVSICovLFxuICAgICAgICB6SW5kZXhTdWJPcmRlcjogdGhpcy5nZXRHcm91cFpJbmRleFN1Yk9yZGVyKFwiZGF0YVwiKVxuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMubWFya2VyR3JvdXAgPSB0aGlzLmNvbnRlbnRHcm91cC5hcHBlbmRDaGlsZChcbiAgICAgIG5ldyBHcm91cCh7XG4gICAgICAgIG5hbWU6IGAke3RoaXMuaWR9LXNlcmllcy1tYXJrZXJzYCxcbiAgICAgICAgekluZGV4OiA0IC8qIFNFUklFU19MQVlFUiAqLyxcbiAgICAgICAgekluZGV4U3ViT3JkZXI6IHRoaXMuZ2V0R3JvdXBaSW5kZXhTdWJPcmRlcihcIm1hcmtlclwiKVxuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMubGFiZWxHcm91cCA9IHRoaXMuY29udGVudEdyb3VwLmFwcGVuZENoaWxkKFxuICAgICAgbmV3IFRyYW5zbGF0YWJsZUdyb3VwKHtcbiAgICAgICAgbmFtZTogYCR7dGhpcy5pZH0tc2VyaWVzLWxhYmVsc2AsXG4gICAgICAgIHpJbmRleDogMTQgLyogU0VSSUVTX0xBQkVMICovLFxuICAgICAgICB6SW5kZXhTdWJPcmRlcjogdGhpcy5nZXRHcm91cFpJbmRleFN1Yk9yZGVyKFwibGFiZWxzXCIpXG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy5sYWJlbFNlbGVjdGlvbiA9IFNlbGVjdGlvbi5zZWxlY3QodGhpcy5sYWJlbEdyb3VwLCBUZXh0KTtcbiAgICB0aGlzLmhpZ2hsaWdodFNlbGVjdGlvbiA9IFNlbGVjdGlvbi5zZWxlY3QoXG4gICAgICB0aGlzLmhpZ2hsaWdodE5vZGUsXG4gICAgICAoKSA9PiB0aGlzLm9wdHMuaGFzTWFya2VycyA/IHRoaXMubWFya2VyRmFjdG9yeSgpIDogdGhpcy5ub2RlRmFjdG9yeSgpXG4gICAgKTtcbiAgICB0aGlzLmhpZ2hsaWdodExhYmVsU2VsZWN0aW9uID0gU2VsZWN0aW9uLnNlbGVjdCh0aGlzLmhpZ2hsaWdodExhYmVsLCBUZXh0KTtcbiAgICB0aGlzLmFubm90YXRpb25TZWxlY3Rpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLm1pblJlY3RzQ2FjaGUgPSB7XG4gICAgICBkaXJ0eU5vZGVEYXRhOiB0cnVlXG4gICAgfTtcbiAgICB0aGlzLmRlYnVnID0gRGVidWcuY3JlYXRlKCk7XG4gICAgaWYgKCFkaXJlY3Rpb25LZXlzIHx8ICFkaXJlY3Rpb25OYW1lcylcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGluaXRpYWxpc2Ugc2VyaWVzIHR5cGUgJHt0aGlzLnR5cGV9YCk7XG4gICAgdGhpcy5vcHRzID0ge1xuICAgICAgcGF0aHNQZXJTZXJpZXMsXG4gICAgICBoYXNNYXJrZXJzLFxuICAgICAgaGFzSGlnaGxpZ2h0ZWRMYWJlbHMsXG4gICAgICBwYXRoc1pJbmRleFN1Yk9yZGVyT2Zmc2V0LFxuICAgICAgZGlyZWN0aW9uS2V5cyxcbiAgICAgIGRpcmVjdGlvbk5hbWVzLFxuICAgICAgYW5pbWF0aW9uUmVzZXRGbnMsXG4gICAgICBhbmltYXRpb25BbHdheXNVcGRhdGVTZWxlY3Rpb25zLFxuICAgICAgZGF0dW1TZWxlY3Rpb25HYXJiYWdlQ29sbGVjdGlvbixcbiAgICAgIG1hcmtlclNlbGVjdGlvbkdhcmJhZ2VDb2xsZWN0aW9uXG4gICAgfTtcbiAgICB0aGlzLnBhdGhzID0gW107XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHBhdGhzUGVyU2VyaWVzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdGhpcy5wYXRoc1tpbmRleF0gPSBuZXcgUGF0aCh7IG5hbWU6IGAke3RoaXMuaWR9LSR7cGF0aHNQZXJTZXJpZXNbaW5kZXhdfWAgfSk7XG4gICAgICB0aGlzLnBhdGhzW2luZGV4XS56SW5kZXggPSA0IC8qIFNFUklFU19MQVlFUiAqLztcbiAgICAgIHRoaXMucGF0aHNbaW5kZXhdLnpJbmRleFN1Yk9yZGVyID0gdGhpcy5nZXRHcm91cFpJbmRleFN1Yk9yZGVyKFwicGF0aHNcIiwgaW5kZXgpO1xuICAgICAgdGhpcy5jb250ZW50R3JvdXAuYXBwZW5kQ2hpbGQodGhpcy5wYXRoc1tpbmRleF0pO1xuICAgIH1cbiAgICB0aGlzLmRhdHVtU2VsZWN0aW9uID0gU2VsZWN0aW9uLnNlbGVjdChcbiAgICAgIHRoaXMuZGF0YU5vZGVHcm91cCxcbiAgICAgICgpID0+IHRoaXMubm9kZUZhY3RvcnkoKSxcbiAgICAgIGRhdHVtU2VsZWN0aW9uR2FyYmFnZUNvbGxlY3Rpb25cbiAgICApO1xuICAgIHRoaXMubWFya2VyU2VsZWN0aW9uID0gU2VsZWN0aW9uLnNlbGVjdChcbiAgICAgIHRoaXMubWFya2VyR3JvdXAsXG4gICAgICAoKSA9PiB0aGlzLm1hcmtlckZhY3RvcnkoKSxcbiAgICAgIG1hcmtlclNlbGVjdGlvbkdhcmJhZ2VDb2xsZWN0aW9uXG4gICAgKTtcbiAgICB0aGlzLmFuaW1hdGlvblN0YXRlID0gbmV3IFN0YXRlTWFjaGluZShcbiAgICAgIFwiZW1wdHlcIixcbiAgICAgIHtcbiAgICAgICAgZW1wdHk6IHtcbiAgICAgICAgICB1cGRhdGU6IHtcbiAgICAgICAgICAgIHRhcmdldDogXCJyZWFkeVwiLFxuICAgICAgICAgICAgYWN0aW9uOiAoZGF0YSkgPT4gdGhpcy5hbmltYXRlRW1wdHlVcGRhdGVSZWFkeShkYXRhKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVzZXQ6IFwiZW1wdHlcIixcbiAgICAgICAgICBza2lwOiBcInJlYWR5XCIsXG4gICAgICAgICAgZGlzYWJsZTogXCJkaXNhYmxlZFwiXG4gICAgICAgIH0sXG4gICAgICAgIHJlYWR5OiB7XG4gICAgICAgICAgdXBkYXRlRGF0YTogXCJ3YWl0aW5nXCIsXG4gICAgICAgICAgY2xlYXI6IFwiY2xlYXJpbmdcIixcbiAgICAgICAgICBoaWdobGlnaHQ6IChkYXRhKSA9PiB0aGlzLmFuaW1hdGVSZWFkeUhpZ2hsaWdodChkYXRhKSxcbiAgICAgICAgICBoaWdobGlnaHRNYXJrZXJzOiAoZGF0YSkgPT4gdGhpcy5hbmltYXRlUmVhZHlIaWdobGlnaHRNYXJrZXJzKGRhdGEpLFxuICAgICAgICAgIHJlc2l6ZTogKGRhdGEpID0+IHRoaXMuYW5pbWF0ZVJlYWR5UmVzaXplKGRhdGEpLFxuICAgICAgICAgIHJlc2V0OiBcImVtcHR5XCIsXG4gICAgICAgICAgc2tpcDogXCJyZWFkeVwiLFxuICAgICAgICAgIGRpc2FibGU6IFwiZGlzYWJsZWRcIlxuICAgICAgICB9LFxuICAgICAgICB3YWl0aW5nOiB7XG4gICAgICAgICAgdXBkYXRlOiB7XG4gICAgICAgICAgICB0YXJnZXQ6IFwicmVhZHlcIixcbiAgICAgICAgICAgIGFjdGlvbjogKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuaXNTa2lwcGVkKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0QWxsQW5pbWF0aW9uKGRhdGEpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0ZVdhaXRpbmdVcGRhdGVSZWFkeShkYXRhKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVzZXQ6IFwiZW1wdHlcIixcbiAgICAgICAgICBza2lwOiBcInJlYWR5XCIsXG4gICAgICAgICAgZGlzYWJsZTogXCJkaXNhYmxlZFwiXG4gICAgICAgIH0sXG4gICAgICAgIGRpc2FibGVkOiB7XG4gICAgICAgICAgdXBkYXRlOiAoZGF0YSkgPT4gdGhpcy5yZXNldEFsbEFuaW1hdGlvbihkYXRhKSxcbiAgICAgICAgICByZXNldDogXCJlbXB0eVwiXG4gICAgICAgIH0sXG4gICAgICAgIGNsZWFyaW5nOiB7XG4gICAgICAgICAgdXBkYXRlOiB7XG4gICAgICAgICAgICB0YXJnZXQ6IFwiZW1wdHlcIixcbiAgICAgICAgICAgIGFjdGlvbjogKGRhdGEpID0+IHRoaXMuYW5pbWF0ZUNsZWFyaW5nVXBkYXRlRW1wdHkoZGF0YSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc2V0OiBcImVtcHR5XCIsXG4gICAgICAgICAgc2tpcDogXCJyZWFkeVwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAoKSA9PiB0aGlzLmNoZWNrUHJvY2Vzc2VkRGF0YUFuaW1hdGFibGUoKVxuICAgICk7XG4gIH1cbiAgZ2V0IGNvbnRleHROb2RlRGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29udGV4dE5vZGVEYXRhO1xuICB9XG4gIGdldE5vZGVEYXRhKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHROb2RlRGF0YT8ubm9kZURhdGE7XG4gIH1cbiAgcmVzZXRBbmltYXRpb24ocGhhc2UpIHtcbiAgICBpZiAocGhhc2UgPT09IFwiaW5pdGlhbFwiKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJyZXNldFwiKTtcbiAgICB9IGVsc2UgaWYgKHBoYXNlID09PSBcInJlYWR5XCIpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcInNraXBcIik7XG4gICAgfSBlbHNlIGlmIChwaGFzZSA9PT0gXCJkaXNhYmxlZFwiKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJkaXNhYmxlXCIpO1xuICAgIH1cbiAgfVxuICBhZGRDaGFydEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuZGVzdHJveUZucy5wdXNoKFxuICAgICAgdGhpcy5jdHguY2hhcnRFdmVudE1hbmFnZXIuYWRkTGlzdGVuZXIoXCJsZWdlbmQtaXRlbS1jbGlja1wiLCAoZXZlbnQpID0+IHRoaXMub25MZWdlbmRJdGVtQ2xpY2soZXZlbnQpKSxcbiAgICAgIHRoaXMuY3R4LmNoYXJ0RXZlbnRNYW5hZ2VyLmFkZExpc3RlbmVyKFxuICAgICAgICBcImxlZ2VuZC1pdGVtLWRvdWJsZS1jbGlja1wiLFxuICAgICAgICAoZXZlbnQpID0+IHRoaXMub25MZWdlbmRJdGVtRG91YmxlQ2xpY2soZXZlbnQpXG4gICAgICApXG4gICAgKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLl9jb250ZXh0Tm9kZURhdGEgPSB2b2lkIDA7XG4gIH1cbiAgYXN5bmMgdXBkYXRlKHsgc2VyaWVzUmVjdCB9KSB7XG4gICAgY29uc3QgeyB2aXNpYmxlLCBfY29udGV4dE5vZGVEYXRhOiBwcmV2aW91c0NvbnRleHREYXRhIH0gPSB0aGlzO1xuICAgIGNvbnN0IHNlcmllcyA9IHRoaXMuY3R4LmhpZ2hsaWdodE1hbmFnZXI/LmdldEFjdGl2ZUhpZ2hsaWdodCgpPy5zZXJpZXM7XG4gICAgY29uc3Qgc2VyaWVzSGlnaGxpZ2h0ZWQgPSBzZXJpZXMgPT09IHRoaXM7XG4gICAgY29uc3QgcmVzaXplID0gdGhpcy5jaGVja1Jlc2l6ZShzZXJpZXNSZWN0KTtcbiAgICBjb25zdCBoaWdobGlnaHRJdGVtcyA9IGF3YWl0IHRoaXMudXBkYXRlSGlnaGxpZ2h0U2VsZWN0aW9uKHNlcmllc0hpZ2hsaWdodGVkKTtcbiAgICBhd2FpdCB0aGlzLnVwZGF0ZVNlbGVjdGlvbnModmlzaWJsZSk7XG4gICAgYXdhaXQgdGhpcy51cGRhdGVOb2RlcyhoaWdobGlnaHRJdGVtcywgc2VyaWVzSGlnaGxpZ2h0ZWQsIHZpc2libGUpO1xuICAgIGNvbnN0IGFuaW1hdGlvbkRhdGEgPSB0aGlzLmdldEFuaW1hdGlvbkRhdGEoc2VyaWVzUmVjdCwgcHJldmlvdXNDb250ZXh0RGF0YSk7XG4gICAgaWYgKCFhbmltYXRpb25EYXRhKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChyZXNpemUpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcInJlc2l6ZVwiLCBhbmltYXRpb25EYXRhKTtcbiAgICB9XG4gICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwidXBkYXRlXCIsIGFuaW1hdGlvbkRhdGEpO1xuICB9XG4gIGFzeW5jIHVwZGF0ZVNlbGVjdGlvbnMoYW55U2VyaWVzSXRlbUVuYWJsZWQpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgYW5pbWF0aW9uU2tpcFVwZGF0ZSA9ICF0aGlzLm9wdHMuYW5pbWF0aW9uQWx3YXlzVXBkYXRlU2VsZWN0aW9ucyAmJiB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLmlzU2tpcHBlZCgpO1xuICAgIGlmICghYW55U2VyaWVzSXRlbUVuYWJsZWQgJiYgYW5pbWF0aW9uU2tpcFVwZGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMubm9kZURhdGFSZWZyZXNoICYmICF0aGlzLmlzUGF0aE9yU2VsZWN0aW9uRGlydHkoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5ub2RlRGF0YVJlZnJlc2gpIHtcbiAgICAgIHRoaXMubm9kZURhdGFSZWZyZXNoID0gZmFsc2U7XG4gICAgICB0aGlzLmRlYnVnKGBDYXJ0ZXNpYW5TZXJpZXMudXBkYXRlU2VsZWN0aW9ucygpIC0gY2FsbGluZyBjcmVhdGVOb2RlRGF0YSgpIGZvcmAsIHRoaXMuaWQpO1xuICAgICAgdGhpcy5tYXJrUXVhZHRyZWVEaXJ0eSgpO1xuICAgICAgdGhpcy5fY29udGV4dE5vZGVEYXRhID0gYXdhaXQgdGhpcy5jcmVhdGVOb2RlRGF0YSgpO1xuICAgICAgY29uc3QgYW5pbWF0aW9uVmFsaWQgPSB0aGlzLmlzUHJvY2Vzc2VkRGF0YUFuaW1hdGFibGUoKTtcbiAgICAgIGlmICh0aGlzLl9jb250ZXh0Tm9kZURhdGEpIHtcbiAgICAgICAgKF9hID0gdGhpcy5fY29udGV4dE5vZGVEYXRhKS5hbmltYXRpb25WYWxpZCA/PyAoX2EuYW5pbWF0aW9uVmFsaWQgPSBhbmltYXRpb25WYWxpZCk7XG4gICAgICB9XG4gICAgICB0aGlzLm1pblJlY3RzQ2FjaGUuZGlydHlOb2RlRGF0YSA9IHRydWU7XG4gICAgICBjb25zdCB7IGRhdGFNb2RlbCwgcHJvY2Vzc2VkRGF0YSB9ID0gdGhpcztcbiAgICAgIGlmIChkYXRhTW9kZWwgIT09IHZvaWQgMCAmJiBwcm9jZXNzZWREYXRhICE9PSB2b2lkIDApIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaChcImRhdGEtdXBkYXRlXCIsIHsgZGF0YU1vZGVsLCBwcm9jZXNzZWREYXRhIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBhd2FpdCB0aGlzLnVwZGF0ZVNlcmllc1NlbGVjdGlvbnMoKTtcbiAgfVxuICBhc3luYyB1cGRhdGVTZXJpZXNTZWxlY3Rpb25zKHNlcmllc0hpZ2hsaWdodGVkKSB7XG4gICAgY29uc3QgeyBkYXR1bVNlbGVjdGlvbiwgbGFiZWxTZWxlY3Rpb24sIG1hcmtlclNlbGVjdGlvbiwgcGF0aHMgfSA9IHRoaXM7XG4gICAgY29uc3QgY29udGV4dERhdGEgPSB0aGlzLl9jb250ZXh0Tm9kZURhdGE7XG4gICAgaWYgKCFjb250ZXh0RGF0YSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IG5vZGVEYXRhLCBsYWJlbERhdGEsIGl0ZW1JZCB9ID0gY29udGV4dERhdGE7XG4gICAgYXdhaXQgdGhpcy51cGRhdGVQYXRocyh7IHNlcmllc0hpZ2hsaWdodGVkLCBpdGVtSWQsIGNvbnRleHREYXRhLCBwYXRocyB9KTtcbiAgICB0aGlzLmRhdHVtU2VsZWN0aW9uID0gYXdhaXQgdGhpcy51cGRhdGVEYXR1bVNlbGVjdGlvbih7IG5vZGVEYXRhLCBkYXR1bVNlbGVjdGlvbiB9KTtcbiAgICB0aGlzLmxhYmVsU2VsZWN0aW9uID0gYXdhaXQgdGhpcy51cGRhdGVMYWJlbFNlbGVjdGlvbih7IGxhYmVsRGF0YSwgbGFiZWxTZWxlY3Rpb24gfSk7XG4gICAgaWYgKHRoaXMub3B0cy5oYXNNYXJrZXJzKSB7XG4gICAgICB0aGlzLm1hcmtlclNlbGVjdGlvbiA9IGF3YWl0IHRoaXMudXBkYXRlTWFya2VyU2VsZWN0aW9uKHsgbm9kZURhdGEsIG1hcmtlclNlbGVjdGlvbiB9KTtcbiAgICB9XG4gIH1cbiAgbWFya2VyRmFjdG9yeSgpIHtcbiAgICBjb25zdCBNYXJrZXJTaGFwZSA9IGdldE1hcmtlcigpO1xuICAgIHJldHVybiBuZXcgTWFya2VyU2hhcGUoKTtcbiAgfVxuICBnZXRHcm91cFpJbmRleFN1Yk9yZGVyKHR5cGUsIHN1YkluZGV4ID0gMCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHN1cGVyLmdldEdyb3VwWkluZGV4U3ViT3JkZXIodHlwZSwgc3ViSW5kZXgpO1xuICAgIGlmICh0eXBlID09PSBcInBhdGhzXCIpIHtcbiAgICAgIGNvbnN0IFtzdXBlckZuXSA9IHJlc3VsdDtcbiAgICAgIGNvbnN0IHBhdGhPZmZzZXQgPSB0aGlzLm9wdHMucGF0aHNaSW5kZXhTdWJPcmRlck9mZnNldFtzdWJJbmRleF0gPz8gMDtcbiAgICAgIHJlc3VsdFswXSA9IGlzRnVuY3Rpb24oc3VwZXJGbikgPyAoKSA9PiBOdW1iZXIoc3VwZXJGbigpKSArIHBhdGhPZmZzZXQgOiBOdW1iZXIoc3VwZXJGbikgKyBwYXRoT2Zmc2V0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGFzeW5jIHVwZGF0ZU5vZGVzKGhpZ2hsaWdodGVkSXRlbXMsIHNlcmllc0hpZ2hsaWdodGVkLCBhbnlTZXJpZXNJdGVtRW5hYmxlZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhpZ2hsaWdodFNlbGVjdGlvbixcbiAgICAgIGhpZ2hsaWdodExhYmVsU2VsZWN0aW9uLFxuICAgICAgb3B0czogeyBoYXNNYXJrZXJzLCBoYXNIaWdobGlnaHRlZExhYmVscyB9XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgYW5pbWF0aW9uRW5hYmxlZCA9ICF0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLmlzU2tpcHBlZCgpO1xuICAgIGNvbnN0IHZpc2libGUgPSB0aGlzLnZpc2libGUgJiYgdGhpcy5fY29udGV4dE5vZGVEYXRhICE9IG51bGwgJiYgYW55U2VyaWVzSXRlbUVuYWJsZWQ7XG4gICAgdGhpcy5yb290R3JvdXAudmlzaWJsZSA9IGFuaW1hdGlvbkVuYWJsZWQgfHwgdmlzaWJsZTtcbiAgICB0aGlzLmNvbnRlbnRHcm91cC52aXNpYmxlID0gYW5pbWF0aW9uRW5hYmxlZCB8fCB2aXNpYmxlO1xuICAgIHRoaXMuaGlnaGxpZ2h0R3JvdXAudmlzaWJsZSA9IChhbmltYXRpb25FbmFibGVkIHx8IHZpc2libGUpICYmIHNlcmllc0hpZ2hsaWdodGVkO1xuICAgIGNvbnN0IG9wYWNpdHkgPSB0aGlzLmdldE9wYWNpdHkoKTtcbiAgICBpZiAoaGFzTWFya2Vycykge1xuICAgICAgYXdhaXQgdGhpcy51cGRhdGVNYXJrZXJOb2Rlcyh7XG4gICAgICAgIG1hcmtlclNlbGVjdGlvbjogaGlnaGxpZ2h0U2VsZWN0aW9uLFxuICAgICAgICBpc0hpZ2hsaWdodDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJoaWdobGlnaHRNYXJrZXJzXCIsIGhpZ2hsaWdodFNlbGVjdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF3YWl0IHRoaXMudXBkYXRlRGF0dW1Ob2Rlcyh7XG4gICAgICAgIGRhdHVtU2VsZWN0aW9uOiBoaWdobGlnaHRTZWxlY3Rpb24sXG4gICAgICAgIGlzSGlnaGxpZ2h0OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcImhpZ2hsaWdodFwiLCBoaWdobGlnaHRTZWxlY3Rpb24pO1xuICAgIH1cbiAgICBpZiAoaGFzSGlnaGxpZ2h0ZWRMYWJlbHMpIHtcbiAgICAgIGF3YWl0IHRoaXMudXBkYXRlTGFiZWxOb2Rlcyh7IGxhYmVsU2VsZWN0aW9uOiBoaWdobGlnaHRMYWJlbFNlbGVjdGlvbiB9KTtcbiAgICB9XG4gICAgY29uc3QgeyBkYXRhTm9kZUdyb3VwLCBtYXJrZXJHcm91cCwgZGF0dW1TZWxlY3Rpb24sIGxhYmVsU2VsZWN0aW9uLCBtYXJrZXJTZWxlY3Rpb24sIHBhdGhzLCBsYWJlbEdyb3VwIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgaXRlbUlkIH0gPSB0aGlzLmNvbnRleHROb2RlRGF0YSA/PyB7fTtcbiAgICBkYXRhTm9kZUdyb3VwLm9wYWNpdHkgPSBvcGFjaXR5O1xuICAgIGRhdGFOb2RlR3JvdXAudmlzaWJsZSA9IGFuaW1hdGlvbkVuYWJsZWQgfHwgdmlzaWJsZTtcbiAgICBsYWJlbEdyb3VwLnZpc2libGUgPSB2aXNpYmxlO1xuICAgIGlmIChoYXNNYXJrZXJzKSB7XG4gICAgICBtYXJrZXJHcm91cC5vcGFjaXR5ID0gb3BhY2l0eTtcbiAgICAgIG1hcmtlckdyb3VwLnpJbmRleCA9IGRhdGFOb2RlR3JvdXAuekluZGV4ID49IDQgLyogU0VSSUVTX0xBWUVSICovID8gZGF0YU5vZGVHcm91cC56SW5kZXggOiBkYXRhTm9kZUdyb3VwLnpJbmRleCArIDE7XG4gICAgICBtYXJrZXJHcm91cC52aXNpYmxlID0gdmlzaWJsZTtcbiAgICB9XG4gICAgaWYgKGxhYmVsR3JvdXApIHtcbiAgICAgIGxhYmVsR3JvdXAub3BhY2l0eSA9IG9wYWNpdHk7XG4gICAgfVxuICAgIGF3YWl0IHRoaXMudXBkYXRlUGF0aE5vZGVzKHtcbiAgICAgIHNlcmllc0hpZ2hsaWdodGVkLFxuICAgICAgaXRlbUlkLFxuICAgICAgcGF0aHMsXG4gICAgICBvcGFjaXR5LFxuICAgICAgdmlzaWJsZSxcbiAgICAgIGFuaW1hdGlvbkVuYWJsZWRcbiAgICB9KTtcbiAgICBpZiAoIWRhdGFOb2RlR3JvdXAudmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLnVwZGF0ZURhdHVtTm9kZXMoeyBkYXR1bVNlbGVjdGlvbiwgaGlnaGxpZ2h0ZWRJdGVtcywgaXNIaWdobGlnaHQ6IGZhbHNlIH0pO1xuICAgIGF3YWl0IHRoaXMudXBkYXRlTGFiZWxOb2Rlcyh7IGxhYmVsU2VsZWN0aW9uIH0pO1xuICAgIGlmIChoYXNNYXJrZXJzKSB7XG4gICAgICBhd2FpdCB0aGlzLnVwZGF0ZU1hcmtlck5vZGVzKHsgbWFya2VyU2VsZWN0aW9uLCBpc0hpZ2hsaWdodDogZmFsc2UgfSk7XG4gICAgfVxuICB9XG4gIGdldEhpZ2hsaWdodExhYmVsRGF0YShsYWJlbERhdGEsIGhpZ2hsaWdodGVkSXRlbSkge1xuICAgIGNvbnN0IGxhYmVsSXRlbXMgPSBsYWJlbERhdGEuZmlsdGVyKFxuICAgICAgKGxkKSA9PiBsZC5kYXR1bSA9PT0gaGlnaGxpZ2h0ZWRJdGVtLmRhdHVtICYmIGxkLml0ZW1JZCA9PT0gaGlnaGxpZ2h0ZWRJdGVtLml0ZW1JZFxuICAgICk7XG4gICAgcmV0dXJuIGxhYmVsSXRlbXMubGVuZ3RoID09PSAwID8gdm9pZCAwIDogbGFiZWxJdGVtcztcbiAgfVxuICBnZXRIaWdobGlnaHREYXRhKF9ub2RlRGF0YSwgaGlnaGxpZ2h0ZWRJdGVtKSB7XG4gICAgcmV0dXJuIGhpZ2hsaWdodGVkSXRlbSA/IFtoaWdobGlnaHRlZEl0ZW1dIDogdm9pZCAwO1xuICB9XG4gIGFzeW5jIHVwZGF0ZUhpZ2hsaWdodFNlbGVjdGlvbihzZXJpZXNIaWdobGlnaHRlZCkge1xuICAgIGNvbnN0IHsgaGlnaGxpZ2h0U2VsZWN0aW9uLCBoaWdobGlnaHRMYWJlbFNlbGVjdGlvbiwgX2NvbnRleHROb2RlRGF0YTogY29udGV4dE5vZGVEYXRhIH0gPSB0aGlzO1xuICAgIGlmICghY29udGV4dE5vZGVEYXRhKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGhpZ2hsaWdodGVkRGF0dW0gPSB0aGlzLmN0eC5oaWdobGlnaHRNYW5hZ2VyPy5nZXRBY3RpdmVIaWdobGlnaHQoKTtcbiAgICBjb25zdCBpdGVtID0gc2VyaWVzSGlnaGxpZ2h0ZWQgJiYgaGlnaGxpZ2h0ZWREYXR1bT8uZGF0dW0gPyBoaWdobGlnaHRlZERhdHVtIDogdm9pZCAwO1xuICAgIGxldCBsYWJlbEl0ZW1zO1xuICAgIGxldCBoaWdobGlnaHRJdGVtcztcbiAgICBpZiAoaXRlbSAhPSBudWxsKSB7XG4gICAgICBjb25zdCBsYWJlbHNFbmFibGVkID0gdGhpcy5pc0xhYmVsRW5hYmxlZCgpO1xuICAgICAgY29uc3QgeyBsYWJlbERhdGEsIG5vZGVEYXRhIH0gPSBjb250ZXh0Tm9kZURhdGE7XG4gICAgICBoaWdobGlnaHRJdGVtcyA9IHRoaXMuZ2V0SGlnaGxpZ2h0RGF0YShub2RlRGF0YSwgaXRlbSk7XG4gICAgICBsYWJlbEl0ZW1zID0gbGFiZWxzRW5hYmxlZCA/IHRoaXMuZ2V0SGlnaGxpZ2h0TGFiZWxEYXRhKGxhYmVsRGF0YSwgaXRlbSkgOiB2b2lkIDA7XG4gICAgfVxuICAgIHRoaXMuaGlnaGxpZ2h0U2VsZWN0aW9uID0gYXdhaXQgdGhpcy51cGRhdGVIaWdobGlnaHRTZWxlY3Rpb25JdGVtKHtcbiAgICAgIGl0ZW1zOiBoaWdobGlnaHRJdGVtcyxcbiAgICAgIGhpZ2hsaWdodFNlbGVjdGlvblxuICAgIH0pO1xuICAgIHRoaXMuaGlnaGxpZ2h0TGFiZWxTZWxlY3Rpb24gPSBhd2FpdCB0aGlzLnVwZGF0ZUhpZ2hsaWdodFNlbGVjdGlvbkxhYmVsKHtcbiAgICAgIGl0ZW1zOiBsYWJlbEl0ZW1zLFxuICAgICAgaGlnaGxpZ2h0TGFiZWxTZWxlY3Rpb25cbiAgICB9KTtcbiAgICByZXR1cm4gaGlnaGxpZ2h0SXRlbXM7XG4gIH1cbiAgbWFya1F1YWR0cmVlRGlydHkoKSB7XG4gICAgdGhpcy5xdWFkdHJlZSA9IHZvaWQgMDtcbiAgfVxuICAqZGF0dW1Ob2Rlc0l0ZXIoKSB7XG4gICAgZm9yIChjb25zdCB7IG5vZGUgfSBvZiB0aGlzLmRhdHVtU2VsZWN0aW9uKSB7XG4gICAgICBpZiAobm9kZS5kYXR1bS5taXNzaW5nID09PSB0cnVlKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHlpZWxkIG5vZGU7XG4gICAgfVxuICB9XG4gIGdldFF1YWRUcmVlKCkge1xuICAgIGlmICh0aGlzLnF1YWR0cmVlID09PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IHsgd2lkdGg6IHdpZHRoMiwgaGVpZ2h0OiBoZWlnaHQyIH0gPSB0aGlzLmN0eC5zY2VuZS5jYW52YXM7XG4gICAgICBjb25zdCBjYW52YXNSZWN0ID0gbmV3IEJCb3goMCwgMCwgd2lkdGgyLCBoZWlnaHQyKTtcbiAgICAgIHRoaXMucXVhZHRyZWUgPSBuZXcgUXVhZHRyZWVOZWFyZXN0KDEwMCwgMTAsIGNhbnZhc1JlY3QpO1xuICAgICAgdGhpcy5pbml0UXVhZFRyZWUodGhpcy5xdWFkdHJlZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnF1YWR0cmVlO1xuICB9XG4gIGluaXRRdWFkVHJlZShfcXVhZHRyZWUpIHtcbiAgfVxuICBwaWNrTm9kZUV4YWN0U2hhcGUocG9pbnQpIHtcbiAgICBjb25zdCByZXN1bHQgPSBzdXBlci5waWNrTm9kZUV4YWN0U2hhcGUocG9pbnQpO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGNvbnN0IHsgeCwgeSB9ID0gcG9pbnQ7XG4gICAgY29uc3Qge1xuICAgICAgb3B0czogeyBoYXNNYXJrZXJzIH1cbiAgICB9ID0gdGhpcztcbiAgICBsZXQgbWF0Y2g7XG4gICAgY29uc3QgeyBkYXRhTm9kZUdyb3VwLCBtYXJrZXJHcm91cCB9ID0gdGhpcztcbiAgICBtYXRjaCA9IGRhdGFOb2RlR3JvdXAucGlja05vZGUoeCwgeSk7XG4gICAgaWYgKCFtYXRjaCAmJiBoYXNNYXJrZXJzKSB7XG4gICAgICBtYXRjaCA9IG1hcmtlckdyb3VwPy5waWNrTm9kZSh4LCB5KTtcbiAgICB9XG4gICAgaWYgKG1hdGNoICYmIG1hdGNoLmRhdHVtLm1pc3NpbmcgIT09IHRydWUpIHtcbiAgICAgIHJldHVybiB7IGRhdHVtOiBtYXRjaC5kYXR1bSwgZGlzdGFuY2U6IDAgfTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBtb2QyIG9mIHRoaXMubW9kdWxlTWFwLm1vZHVsZXMoKSkge1xuICAgICAgY29uc3QgeyBkYXR1bSB9ID0gbW9kMi5waWNrTm9kZUV4YWN0KHBvaW50KSA/PyB7fTtcbiAgICAgIGlmIChkYXR1bSA9PSBudWxsKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGlmIChkYXR1bT8ubWlzc2luZyA9PT0gdHJ1ZSlcbiAgICAgICAgY29udGludWU7XG4gICAgICByZXR1cm4geyBkYXR1bSwgZGlzdGFuY2U6IDAgfTtcbiAgICB9XG4gIH1cbiAgcGlja05vZGVDbG9zZXN0RGF0dW0ocG9pbnQpIHtcbiAgICBjb25zdCB7IHgsIHkgfSA9IHBvaW50O1xuICAgIGNvbnN0IHsgYXhlcywgX2NvbnRleHROb2RlRGF0YTogY29udGV4dE5vZGVEYXRhIH0gPSB0aGlzO1xuICAgIGlmICghY29udGV4dE5vZGVEYXRhKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHhBeGlzID0gYXhlc1tcInhcIiAvKiBYICovXTtcbiAgICBjb25zdCB5QXhpcyA9IGF4ZXNbXCJ5XCIgLyogWSAqL107XG4gICAgY29uc3QgaGl0UG9pbnQgPSB7IHgsIHkgfTtcbiAgICBsZXQgbWluRGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICBsZXQgY2xvc2VzdERhdHVtO1xuICAgIGZvciAoY29uc3QgZGF0dW0gb2YgY29udGV4dE5vZGVEYXRhLm5vZGVEYXRhKSB7XG4gICAgICBjb25zdCB7IHBvaW50OiB7IHg6IGRhdHVtWCA9IE5hTiwgeTogZGF0dW1ZID0gTmFOIH0gPSB7fSB9ID0gZGF0dW07XG4gICAgICBpZiAoaXNOYU4oZGF0dW1YKSB8fCBpc05hTihkYXR1bVkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNJblJhbmdlID0geEF4aXM/LmluUmFuZ2UoZGF0dW1YKSAmJiB5QXhpcz8uaW5SYW5nZShkYXR1bVkpO1xuICAgICAgaWYgKCFpc0luUmFuZ2UpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBkaXN0YW5jZTMgPSBNYXRoLm1heCgoaGl0UG9pbnQueCAtIGRhdHVtWCkgKiogMiArIChoaXRQb2ludC55IC0gZGF0dW1ZKSAqKiAyLCAwKTtcbiAgICAgIGlmIChkaXN0YW5jZTMgPCBtaW5EaXN0YW5jZSkge1xuICAgICAgICBtaW5EaXN0YW5jZSA9IGRpc3RhbmNlMztcbiAgICAgICAgY2xvc2VzdERhdHVtID0gZGF0dW07XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgbW9kMiBvZiB0aGlzLm1vZHVsZU1hcC5tb2R1bGVzKCkpIHtcbiAgICAgIGNvbnN0IG1vZFBpY2sgPSBtb2QyLnBpY2tOb2RlTmVhcmVzdChwb2ludCk7XG4gICAgICBpZiAobW9kUGljayAhPT0gdm9pZCAwICYmIG1vZFBpY2suZGlzdGFuY2VTcXVhcmVkIDwgbWluRGlzdGFuY2UpIHtcbiAgICAgICAgbWluRGlzdGFuY2UgPSBtb2RQaWNrLmRpc3RhbmNlU3F1YXJlZDtcbiAgICAgICAgY2xvc2VzdERhdHVtID0gbW9kUGljay5kYXR1bTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjbG9zZXN0RGF0dW0pIHtcbiAgICAgIGNvbnN0IGRpc3RhbmNlMyA9IE1hdGgubWF4KE1hdGguc3FydChtaW5EaXN0YW5jZSkgLSAoY2xvc2VzdERhdHVtLnBvaW50Py5zaXplID8/IDApLCAwKTtcbiAgICAgIHJldHVybiB7IGRhdHVtOiBjbG9zZXN0RGF0dW0sIGRpc3RhbmNlOiBkaXN0YW5jZTMgfTtcbiAgICB9XG4gIH1cbiAgcGlja05vZGVNYWluQXhpc0ZpcnN0KHBvaW50LCByZXF1aXJlQ2F0ZWdvcnlBeGlzKSB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBwb2ludDtcbiAgICBjb25zdCB7IGF4ZXMsIF9jb250ZXh0Tm9kZURhdGE6IGNvbnRleHROb2RlRGF0YSB9ID0gdGhpcztcbiAgICBjb25zdCB7IHBpY2tPdXRzaWRlVmlzaWJsZU1pbm9yQXhpcyB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGlmICghY29udGV4dE5vZGVEYXRhKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHhBeGlzID0gYXhlc1tcInhcIiAvKiBYICovXTtcbiAgICBjb25zdCB5QXhpcyA9IGF4ZXNbXCJ5XCIgLyogWSAqL107XG4gICAgY29uc3QgZGlyZWN0aW9uczIgPSBbeEF4aXMsIHlBeGlzXS5maWx0ZXIoQ2F0ZWdvcnlBeGlzLmlzKS5tYXAoKGEpID0+IGEuZGlyZWN0aW9uKTtcbiAgICBpZiAocmVxdWlyZUNhdGVnb3J5QXhpcyAmJiBkaXJlY3Rpb25zMi5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgW21ham9yRGlyZWN0aW9uID0gXCJ4XCIgLyogWCAqL10gPSBkaXJlY3Rpb25zMjtcbiAgICBjb25zdCBoaXRQb2ludENvb3JkcyA9IFt4LCB5XTtcbiAgICBpZiAobWFqb3JEaXJlY3Rpb24gIT09IFwieFwiIC8qIFggKi8pXG4gICAgICBoaXRQb2ludENvb3Jkcy5yZXZlcnNlKCk7XG4gICAgY29uc3QgbWluRGlzdGFuY2UgPSBbSW5maW5pdHksIEluZmluaXR5XTtcbiAgICBsZXQgY2xvc2VzdERhdHVtO1xuICAgIGZvciAoY29uc3QgZGF0dW0gb2YgY29udGV4dE5vZGVEYXRhLm5vZGVEYXRhKSB7XG4gICAgICBjb25zdCB7IHg6IGRhdHVtWCA9IE5hTiwgeTogZGF0dW1ZID0gTmFOIH0gPSBkYXR1bS5wb2ludCA/PyBkYXR1bS5taWRQb2ludCA/PyB7fTtcbiAgICAgIGlmIChpc05hTihkYXR1bVgpIHx8IGlzTmFOKGRhdHVtWSkgfHwgZGF0dW0ubWlzc2luZyA9PT0gdHJ1ZSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCB2aXNpYmxlID0gW3hBeGlzPy5pblJhbmdlKGRhdHVtWCksIHlBeGlzPy5pblJhbmdlKGRhdHVtWSldO1xuICAgICAgaWYgKG1ham9yRGlyZWN0aW9uICE9PSBcInhcIiAvKiBYICovKSB7XG4gICAgICAgIHZpc2libGUucmV2ZXJzZSgpO1xuICAgICAgfVxuICAgICAgaWYgKCF2aXNpYmxlWzBdIHx8ICFwaWNrT3V0c2lkZVZpc2libGVNaW5vckF4aXMgJiYgIXZpc2libGVbMV0pXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3QgZGF0dW1Qb2ludCA9IFtkYXR1bVgsIGRhdHVtWV07XG4gICAgICBpZiAobWFqb3JEaXJlY3Rpb24gIT09IFwieFwiIC8qIFggKi8pIHtcbiAgICAgICAgZGF0dW1Qb2ludC5yZXZlcnNlKCk7XG4gICAgICB9XG4gICAgICBsZXQgbmV3TWluRGlzdGFuY2UgPSB0cnVlO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXR1bVBvaW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGRpc3QgPSBNYXRoLmFicyhkYXR1bVBvaW50W2ldIC0gaGl0UG9pbnRDb29yZHNbaV0pO1xuICAgICAgICBpZiAoZGlzdCA+IG1pbkRpc3RhbmNlW2ldKSB7XG4gICAgICAgICAgbmV3TWluRGlzdGFuY2UgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmIChkaXN0IDwgbWluRGlzdGFuY2VbaV0pIHtcbiAgICAgICAgICBtaW5EaXN0YW5jZVtpXSA9IGRpc3Q7XG4gICAgICAgICAgbWluRGlzdGFuY2UuZmlsbChJbmZpbml0eSwgaSArIDEsIG1pbkRpc3RhbmNlLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChuZXdNaW5EaXN0YW5jZSkge1xuICAgICAgICBjbG9zZXN0RGF0dW0gPSBkYXR1bTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNsb3Nlc3REYXR1bSkge1xuICAgICAgbGV0IGNsb3Nlc3REaXN0YW5jZVNxdWFyZWQgPSBNYXRoLm1heChcbiAgICAgICAgbWluRGlzdGFuY2VbMF0gKiogMiArIG1pbkRpc3RhbmNlWzFdICoqIDIgLSAoY2xvc2VzdERhdHVtLnBvaW50Py5zaXplID8/IDApLFxuICAgICAgICAwXG4gICAgICApO1xuICAgICAgZm9yIChjb25zdCBtb2QyIG9mIHRoaXMubW9kdWxlTWFwLm1vZHVsZXMoKSkge1xuICAgICAgICBjb25zdCBtb2RQaWNrID0gbW9kMi5waWNrTm9kZU1haW5BeGlzRmlyc3QocG9pbnQpO1xuICAgICAgICBpZiAobW9kUGljayAhPT0gdm9pZCAwICYmIG1vZFBpY2suZGlzdGFuY2VTcXVhcmVkIDwgY2xvc2VzdERpc3RhbmNlU3F1YXJlZCkge1xuICAgICAgICAgIGNsb3Nlc3REYXR1bSA9IG1vZFBpY2suZGF0dW07XG4gICAgICAgICAgY2xvc2VzdERpc3RhbmNlU3F1YXJlZCA9IG1vZFBpY2suZGlzdGFuY2VTcXVhcmVkO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4geyBkYXR1bTogY2xvc2VzdERhdHVtLCBkaXN0YW5jZTogTWF0aC5zcXJ0KGNsb3Nlc3REaXN0YW5jZVNxdWFyZWQpIH07XG4gICAgfVxuICB9XG4gIG9uTGVnZW5kSXRlbUNsaWNrKGV2ZW50KSB7XG4gICAgY29uc3QgeyBsZWdlbmRJdGVtTmFtZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHsgZW5hYmxlZCwgaXRlbUlkLCBzZXJpZXMgfSA9IGV2ZW50O1xuICAgIGNvbnN0IG1hdGNoZWRMZWdlbmRJdGVtTmFtZSA9IGxlZ2VuZEl0ZW1OYW1lICE9IG51bGwgJiYgbGVnZW5kSXRlbU5hbWUgPT09IGV2ZW50LmxlZ2VuZEl0ZW1OYW1lO1xuICAgIGlmIChzZXJpZXMuaWQgPT09IHRoaXMuaWQgfHwgbWF0Y2hlZExlZ2VuZEl0ZW1OYW1lKSB7XG4gICAgICB0aGlzLnRvZ2dsZVNlcmllc0l0ZW0oaXRlbUlkLCBlbmFibGVkKTtcbiAgICB9XG4gIH1cbiAgb25MZWdlbmRJdGVtRG91YmxlQ2xpY2soZXZlbnQpIHtcbiAgICBjb25zdCB7IGVuYWJsZWQsIGl0ZW1JZCwgc2VyaWVzLCBudW1WaXNpYmxlSXRlbXMgfSA9IGV2ZW50O1xuICAgIGNvbnN0IHsgbGVnZW5kSXRlbU5hbWUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCBtYXRjaGVkTGVnZW5kSXRlbU5hbWUgPSBsZWdlbmRJdGVtTmFtZSAhPSBudWxsICYmIGxlZ2VuZEl0ZW1OYW1lID09PSBldmVudC5sZWdlbmRJdGVtTmFtZTtcbiAgICBpZiAoc2VyaWVzLmlkID09PSB0aGlzLmlkIHx8IG1hdGNoZWRMZWdlbmRJdGVtTmFtZSkge1xuICAgICAgdGhpcy50b2dnbGVTZXJpZXNJdGVtKGl0ZW1JZCwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmIChlbmFibGVkICYmIG51bVZpc2libGVJdGVtcyA9PT0gMSkge1xuICAgICAgdGhpcy50b2dnbGVTZXJpZXNJdGVtKGl0ZW1JZCwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudG9nZ2xlU2VyaWVzSXRlbShpdGVtSWQsIGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgaXNQYXRoT3JTZWxlY3Rpb25EaXJ0eSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZ2V0TGFiZWxEYXRhKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBzaG91bGRGbGlwWFkoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIG1pbmltdW0gYm91bmRpbmcgYm94IHRoYXQgY29udGFpbnMgYW55IGFkamFjZW50IHR3byBub2Rlcy4gVGhlIGF4ZXMgYXJlIHRyZWF0ZWQgaW5kZXBlbmRlbnRseSwgc28gdGhpc1xuICAgKiBtYXkgbm90IHJlcHJlc2VudCB0aGUgc2FtZSB0d28gcG9pbnRzIGZvciBib3RoIGRpcmVjdGlvbnMuIFRoZSBkaW1lbnNpb25zIHJlcHJlc2VudCB0aGUgZ3JlYXRlc3QgZGlzdGFuY2VcbiAgICogYmV0d2VlbiBhbnkgdHdvIGFkamFjZW50IG5vZGVzLlxuICAgKi9cbiAgZ2V0TWluUmVjdHMod2lkdGgyLCBoZWlnaHQyKSB7XG4gICAgY29uc3QgeyBkaXJ0eU5vZGVEYXRhLCBzaXplQ2FjaGUsIG1pblJlY3QsIG1pblZpc2libGVSZWN0IH0gPSB0aGlzLm1pblJlY3RzQ2FjaGU7XG4gICAgY29uc3QgbmV3U2l6ZUNhY2hlID0gSlNPTi5zdHJpbmdpZnkoeyB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIgfSk7XG4gICAgY29uc3QgZGlydHlTaXplID0gbmV3U2l6ZUNhY2hlICE9PSBzaXplQ2FjaGU7XG4gICAgaWYgKCFkaXJ0eVNpemUgJiYgIWRpcnR5Tm9kZURhdGEgJiYgbWluUmVjdCAmJiBtaW5WaXNpYmxlUmVjdCkge1xuICAgICAgcmV0dXJuIHsgbWluUmVjdCwgbWluVmlzaWJsZVJlY3QgfTtcbiAgICB9XG4gICAgY29uc3QgcmVjdHMgPSB0aGlzLmNvbXB1dGVNaW5SZWN0cyh3aWR0aDIsIGhlaWdodDIpO1xuICAgIHRoaXMubWluUmVjdHNDYWNoZSA9IHtcbiAgICAgIGRpcnR5Tm9kZURhdGE6IGZhbHNlLFxuICAgICAgc2l6ZUNhY2hlOiBuZXdTaXplQ2FjaGUsXG4gICAgICBtaW5SZWN0OiByZWN0cz8ubWluUmVjdCxcbiAgICAgIG1pblZpc2libGVSZWN0OiByZWN0cz8ubWluVmlzaWJsZVJlY3RcbiAgICB9O1xuICAgIHJldHVybiByZWN0cztcbiAgfVxuICBjb21wdXRlTWluUmVjdHMod2lkdGgyLCBoZWlnaHQyKSB7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuX2NvbnRleHROb2RlRGF0YTtcbiAgICBpZiAoIWNvbnRleHQ/Lm5vZGVEYXRhLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IG5vZGVEYXRhIH0gPSBjb250ZXh0O1xuICAgIGNvbnN0IG1pblJlY3RYcyA9IEFycmF5KG5vZGVEYXRhLmxlbmd0aCk7XG4gICAgY29uc3QgbWluUmVjdFlzID0gQXJyYXkobm9kZURhdGEubGVuZ3RoKTtcbiAgICBmb3IgKGNvbnN0IFtpLCB7IG1pZFBvaW50IH1dIG9mIG5vZGVEYXRhLmVudHJpZXMoKSkge1xuICAgICAgbWluUmVjdFhzW2ldID0gbWlkUG9pbnQ/LnggPz8gMDtcbiAgICAgIG1pblJlY3RZc1tpXSA9IG1pZFBvaW50Py55ID8/IDA7XG4gICAgfVxuICAgIG1pblJlY3RYcy5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gICAgbWluUmVjdFlzLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgICBsZXQgemVyb1gsIHdpZHRoWCwgemVyb1ksIGhlaWdodFk7XG4gICAgbGV0IG1heFdpZHRoID0gMDtcbiAgICBsZXQgbWF4SGVpZ2h0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IG5vZGVEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobWluUmVjdFhzW2ldID49IDApXG4gICAgICAgIHplcm9YID8/ICh6ZXJvWCA9IGkpO1xuICAgICAgaWYgKG1pblJlY3RYc1tpXSA+IHdpZHRoMilcbiAgICAgICAgd2lkdGhYID8/ICh3aWR0aFggPSBpKTtcbiAgICAgIGlmIChtaW5SZWN0WXNbaV0gPj0gMClcbiAgICAgICAgemVyb1kgPz8gKHplcm9ZID0gaSk7XG4gICAgICBpZiAobWluUmVjdFlzW2ldID4gaGVpZ2h0MilcbiAgICAgICAgaGVpZ2h0WSA/PyAoaGVpZ2h0WSA9IGkpO1xuICAgICAgbWF4V2lkdGggPSBNYXRoLm1heChtYXhXaWR0aCwgbWluUmVjdFhzW2ldIC0gbWluUmVjdFhzW2kgLSAxXSk7XG4gICAgICBtYXhIZWlnaHQgPSBNYXRoLm1heChtYXhIZWlnaHQsIG1pblJlY3RZc1tpXSAtIG1pblJlY3RZc1tpIC0gMV0pO1xuICAgIH1cbiAgICB3aWR0aFggPz8gKHdpZHRoWCA9IG5vZGVEYXRhLmxlbmd0aCk7XG4gICAgaGVpZ2h0WSA/PyAoaGVpZ2h0WSA9IG5vZGVEYXRhLmxlbmd0aCk7XG4gICAgY29uc3QgbWluVmlzaWJsZVJlY3RYcyA9IHplcm9YICE9IG51bGwgJiYgd2lkdGhYICE9IG51bGwgPyBtaW5SZWN0WHMuc2xpY2UoemVyb1gsIHdpZHRoWCkgOiBbXTtcbiAgICBjb25zdCBtaW5WaXNpYmxlUmVjdFlzID0gemVyb1kgIT0gbnVsbCAmJiBoZWlnaHRZICE9IG51bGwgPyBtaW5SZWN0WXMuc2xpY2UoemVyb1ksIGhlaWdodFkpIDogW107XG4gICAgbGV0IG1heFZpc2libGVXaWR0aCA9IDA7XG4gICAgbGV0IG1heFZpc2libGVIZWlnaHQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgTWF0aC5tYXgobWluVmlzaWJsZVJlY3RYcy5sZW5ndGgsIG1pblZpc2libGVSZWN0WXMubGVuZ3RoKTsgaSsrKSB7XG4gICAgICBjb25zdCB4MSA9IG1pblZpc2libGVSZWN0WHNbaV07XG4gICAgICBjb25zdCB4MiA9IG1pblZpc2libGVSZWN0WHNbaSAtIDFdO1xuICAgICAgY29uc3QgeTEgPSBtaW5WaXNpYmxlUmVjdFlzW2ldO1xuICAgICAgY29uc3QgeTIgPSBtaW5WaXNpYmxlUmVjdFlzW2kgLSAxXTtcbiAgICAgIGlmICh4MSAhPSBudWxsICYmIHgyICE9IG51bGwpIHtcbiAgICAgICAgbWF4VmlzaWJsZVdpZHRoID0gTWF0aC5tYXgobWF4VmlzaWJsZVdpZHRoLCB4MSAtIHgyKTtcbiAgICAgIH1cbiAgICAgIGlmICh5MSAhPSBudWxsICYmIHkyICE9IG51bGwpIHtcbiAgICAgICAgbWF4VmlzaWJsZUhlaWdodCA9IE1hdGgubWF4KG1heFZpc2libGVIZWlnaHQsIHkxIC0geTIpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBtaW5SZWN0ID0gbmV3IEJCb3goMCwgMCwgbWF4V2lkdGgsIG1heEhlaWdodCk7XG4gICAgY29uc3QgbWluVmlzaWJsZVJlY3QgPSBuZXcgQkJveCgwLCAwLCBtYXhWaXNpYmxlV2lkdGgsIG1heFZpc2libGVIZWlnaHQpO1xuICAgIHJldHVybiB7IG1pblJlY3QsIG1pblZpc2libGVSZWN0IH07XG4gIH1cbiAgdXBkYXRlSGlnaGxpZ2h0U2VsZWN0aW9uSXRlbShvcHRzKSB7XG4gICAgY29uc3Qge1xuICAgICAgb3B0czogeyBoYXNNYXJrZXJzIH1cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB7IGl0ZW1zLCBoaWdobGlnaHRTZWxlY3Rpb24gfSA9IG9wdHM7XG4gICAgY29uc3Qgbm9kZURhdGEgPSBpdGVtcyA/PyBbXTtcbiAgICBpZiAoaGFzTWFya2Vycykge1xuICAgICAgY29uc3QgbWFya2VyU2VsZWN0aW9uID0gaGlnaGxpZ2h0U2VsZWN0aW9uO1xuICAgICAgcmV0dXJuIHRoaXMudXBkYXRlTWFya2VyU2VsZWN0aW9uKHsgbm9kZURhdGEsIG1hcmtlclNlbGVjdGlvbiB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMudXBkYXRlRGF0dW1TZWxlY3Rpb24oe1xuICAgICAgICBub2RlRGF0YSxcbiAgICAgICAgZGF0dW1TZWxlY3Rpb246IGhpZ2hsaWdodFNlbGVjdGlvblxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZUhpZ2hsaWdodFNlbGVjdGlvbkxhYmVsKG9wdHMpIHtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVMYWJlbFNlbGVjdGlvbih7XG4gICAgICBsYWJlbERhdGE6IG9wdHMuaXRlbXMgPz8gW10sXG4gICAgICBsYWJlbFNlbGVjdGlvbjogb3B0cy5oaWdobGlnaHRMYWJlbFNlbGVjdGlvblxuICAgIH0pO1xuICB9XG4gIGFzeW5jIHVwZGF0ZURhdHVtU2VsZWN0aW9uKG9wdHMpIHtcbiAgICByZXR1cm4gb3B0cy5kYXR1bVNlbGVjdGlvbjtcbiAgfVxuICBhc3luYyB1cGRhdGVEYXR1bU5vZGVzKF9vcHRzKSB7XG4gIH1cbiAgYXN5bmMgdXBkYXRlTWFya2VyU2VsZWN0aW9uKG9wdHMpIHtcbiAgICByZXR1cm4gb3B0cy5tYXJrZXJTZWxlY3Rpb247XG4gIH1cbiAgYXN5bmMgdXBkYXRlTWFya2VyTm9kZXMoX29wdHMpIHtcbiAgfVxuICBhc3luYyB1cGRhdGVQYXRocyhvcHRzKSB7XG4gICAgb3B0cy5wYXRocy5mb3JFYWNoKChwKSA9PiBwLnZpc2libGUgPSBmYWxzZSk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlUGF0aE5vZGVzKG9wdHMpIHtcbiAgICBjb25zdCB7IHBhdGhzLCBvcGFjaXR5LCB2aXNpYmxlIH0gPSBvcHRzO1xuICAgIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgICAgcGF0aC5vcGFjaXR5ID0gb3BhY2l0eTtcbiAgICAgIHBhdGgudmlzaWJsZSA9IHZpc2libGU7XG4gICAgfVxuICB9XG4gIHJlc2V0UGF0aEFuaW1hdGlvbihkYXRhKSB7XG4gICAgY29uc3QgeyBwYXRoIH0gPSB0aGlzLm9wdHM/LmFuaW1hdGlvblJlc2V0Rm5zID8/IHt9O1xuICAgIGlmIChwYXRoKSB7XG4gICAgICBkYXRhLnBhdGhzLmZvckVhY2goKHBhdGhzKSA9PiB7XG4gICAgICAgIHJlc2V0TW90aW9uKFtwYXRoc10sIHBhdGgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJlc2V0RGF0dW1BbmltYXRpb24oZGF0YSkge1xuICAgIGNvbnN0IHsgZGF0dW0gfSA9IHRoaXMub3B0cz8uYW5pbWF0aW9uUmVzZXRGbnMgPz8ge307XG4gICAgaWYgKGRhdHVtKSB7XG4gICAgICByZXNldE1vdGlvbihbZGF0YS5kYXR1bVNlbGVjdGlvbl0sIGRhdHVtKTtcbiAgICB9XG4gIH1cbiAgcmVzZXRMYWJlbEFuaW1hdGlvbihkYXRhKSB7XG4gICAgY29uc3QgeyBsYWJlbCB9ID0gdGhpcy5vcHRzPy5hbmltYXRpb25SZXNldEZucyA/PyB7fTtcbiAgICBpZiAobGFiZWwpIHtcbiAgICAgIHJlc2V0TW90aW9uKFtkYXRhLmxhYmVsU2VsZWN0aW9uXSwgbGFiZWwpO1xuICAgIH1cbiAgfVxuICByZXNldE1hcmtlckFuaW1hdGlvbihkYXRhKSB7XG4gICAgY29uc3QgeyBtYXJrZXIgfSA9IHRoaXMub3B0cz8uYW5pbWF0aW9uUmVzZXRGbnMgPz8ge307XG4gICAgaWYgKG1hcmtlciAmJiB0aGlzLm9wdHMuaGFzTWFya2Vycykge1xuICAgICAgcmVzZXRNb3Rpb24oW2RhdGEubWFya2VyU2VsZWN0aW9uXSwgbWFya2VyKTtcbiAgICB9XG4gIH1cbiAgcmVzZXRBbGxBbmltYXRpb24oZGF0YSkge1xuICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuc3RvcEJ5QW5pbWF0aW9uR3JvdXBJZCh0aGlzLmlkKTtcbiAgICB0aGlzLnJlc2V0UGF0aEFuaW1hdGlvbihkYXRhKTtcbiAgICB0aGlzLnJlc2V0RGF0dW1BbmltYXRpb24oZGF0YSk7XG4gICAgdGhpcy5yZXNldExhYmVsQW5pbWF0aW9uKGRhdGEpO1xuICAgIHRoaXMucmVzZXRNYXJrZXJBbmltYXRpb24oZGF0YSk7XG4gICAgaWYgKGRhdGEuY29udGV4dERhdGE/LmFuaW1hdGlvblZhbGlkID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5za2lwQ3VycmVudEJhdGNoKCk7XG4gICAgfVxuICB9XG4gIGFuaW1hdGVFbXB0eVVwZGF0ZVJlYWR5KGRhdGEpIHtcbiAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLnNraXBDdXJyZW50QmF0Y2goKTtcbiAgICB0aGlzLnJlc2V0QWxsQW5pbWF0aW9uKGRhdGEpO1xuICB9XG4gIGFuaW1hdGVXYWl0aW5nVXBkYXRlUmVhZHkoZGF0YSkge1xuICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuc2tpcEN1cnJlbnRCYXRjaCgpO1xuICAgIHRoaXMucmVzZXRBbGxBbmltYXRpb24oZGF0YSk7XG4gIH1cbiAgYW5pbWF0ZVJlYWR5SGlnaGxpZ2h0KGRhdGEpIHtcbiAgICBjb25zdCB7IGRhdHVtIH0gPSB0aGlzLm9wdHM/LmFuaW1hdGlvblJlc2V0Rm5zID8/IHt9O1xuICAgIGlmIChkYXR1bSkge1xuICAgICAgcmVzZXRNb3Rpb24oW2RhdGFdLCBkYXR1bSk7XG4gICAgfVxuICB9XG4gIGFuaW1hdGVSZWFkeUhpZ2hsaWdodE1hcmtlcnMoZGF0YSkge1xuICAgIGNvbnN0IHsgbWFya2VyIH0gPSB0aGlzLm9wdHM/LmFuaW1hdGlvblJlc2V0Rm5zID8/IHt9O1xuICAgIGlmIChtYXJrZXIpIHtcbiAgICAgIHJlc2V0TW90aW9uKFtkYXRhXSwgbWFya2VyKTtcbiAgICB9XG4gIH1cbiAgYW5pbWF0ZVJlYWR5UmVzaXplKGRhdGEpIHtcbiAgICB0aGlzLnJlc2V0QWxsQW5pbWF0aW9uKGRhdGEpO1xuICB9XG4gIGFuaW1hdGVDbGVhcmluZ1VwZGF0ZUVtcHR5KGRhdGEpIHtcbiAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLnNraXBDdXJyZW50QmF0Y2goKTtcbiAgICB0aGlzLnJlc2V0QWxsQW5pbWF0aW9uKGRhdGEpO1xuICB9XG4gIGFuaW1hdGlvblRyYW5zaXRpb25DbGVhcigpIHtcbiAgICBjb25zdCBhbmltYXRpb25EYXRhID0gdGhpcy5nZXRBbmltYXRpb25EYXRhKCk7XG4gICAgaWYgKCFhbmltYXRpb25EYXRhKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcImNsZWFyXCIsIGFuaW1hdGlvbkRhdGEpO1xuICB9XG4gIGdldEFuaW1hdGlvbkRhdGEoc2VyaWVzUmVjdCwgcHJldmlvdXNDb250ZXh0RGF0YSkge1xuICAgIGNvbnN0IHsgX2NvbnRleHROb2RlRGF0YTogY29udGV4dERhdGEgfSA9IHRoaXM7XG4gICAgaWYgKCFjb250ZXh0RGF0YSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBhbmltYXRpb25EYXRhID0ge1xuICAgICAgZGF0dW1TZWxlY3Rpb246IHRoaXMuZGF0dW1TZWxlY3Rpb24sXG4gICAgICBtYXJrZXJTZWxlY3Rpb246IHRoaXMubWFya2VyU2VsZWN0aW9uLFxuICAgICAgbGFiZWxTZWxlY3Rpb246IHRoaXMubGFiZWxTZWxlY3Rpb24sXG4gICAgICBhbm5vdGF0aW9uU2VsZWN0aW9uczogWy4uLnRoaXMuYW5ub3RhdGlvblNlbGVjdGlvbnNdLFxuICAgICAgY29udGV4dERhdGEsXG4gICAgICBwcmV2aW91c0NvbnRleHREYXRhLFxuICAgICAgcGF0aHM6IHRoaXMucGF0aHMsXG4gICAgICBzZXJpZXNSZWN0XG4gICAgfTtcbiAgICByZXR1cm4gYW5pbWF0aW9uRGF0YTtcbiAgfVxuICBjYWxjdWxhdGVTY2FsaW5nKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3QgZGlyZWN0aW9uIG9mIE9iamVjdC52YWx1ZXMoQ2hhcnRBeGlzRGlyZWN0aW9uKSkge1xuICAgICAgY29uc3QgYXhpcyA9IHRoaXMuYXhlc1tkaXJlY3Rpb25dO1xuICAgICAgaWYgKCFheGlzKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGlmIChheGlzLnNjYWxlIGluc3RhbmNlb2YgTG9nU2NhbGUpIHtcbiAgICAgICAgY29uc3QgeyByYW5nZTogcmFuZ2UzLCBkb21haW4gfSA9IGF4aXMuc2NhbGU7XG4gICAgICAgIHJlc3VsdFtkaXJlY3Rpb25dID0ge1xuICAgICAgICAgIHR5cGU6IFwibG9nXCIsXG4gICAgICAgICAgY29udmVydDogKGQpID0+IGF4aXMuc2NhbGUuY29udmVydChkKSxcbiAgICAgICAgICBkb21haW46IFtkb21haW5bMF0sIGRvbWFpblsxXV0sXG4gICAgICAgICAgcmFuZ2U6IFtyYW5nZTNbMF0sIHJhbmdlM1sxXV1cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoYXhpcy5zY2FsZSBpbnN0YW5jZW9mIENvbnRpbnVvdXNTY2FsZSkge1xuICAgICAgICBjb25zdCB7IHJhbmdlOiByYW5nZTMgfSA9IGF4aXMuc2NhbGU7XG4gICAgICAgIGNvbnN0IGRvbWFpbiA9IGF4aXMuc2NhbGUuZ2V0RG9tYWluKCk7XG4gICAgICAgIHJlc3VsdFtkaXJlY3Rpb25dID0ge1xuICAgICAgICAgIHR5cGU6IFwiY29udGludW91c1wiLFxuICAgICAgICAgIGRvbWFpbjogW2RvbWFpblswXSwgZG9tYWluWzFdXSxcbiAgICAgICAgICByYW5nZTogW3JhbmdlM1swXSwgcmFuZ2UzWzFdXVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChheGlzLnNjYWxlKSB7XG4gICAgICAgIGNvbnN0IHsgZG9tYWluIH0gPSBheGlzLnNjYWxlO1xuICAgICAgICByZXN1bHRbZGlyZWN0aW9uXSA9IHtcbiAgICAgICAgICB0eXBlOiBcImNhdGVnb3J5XCIsXG4gICAgICAgICAgZG9tYWluLFxuICAgICAgICAgIHJhbmdlOiBkb21haW4ubWFwKChkKSA9PiBheGlzLnNjYWxlLmNvbnZlcnQoZCkpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2NhcnRlc2lhbkNoYXJ0LnRzXG52YXIgZGlyZWN0aW9ucyA9IFtcInRvcFwiLCBcInJpZ2h0XCIsIFwiYm90dG9tXCIsIFwibGVmdFwiXTtcbnZhciBDYXJ0ZXNpYW5DaGFydCA9IGNsYXNzIGV4dGVuZHMgQ2hhcnQge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCByZXNvdXJjZXMpIHtcbiAgICBzdXBlcihvcHRpb25zLCByZXNvdXJjZXMpO1xuICAgIC8qKiBJbnRlZ3JhdGVkIENoYXJ0cyBmZWF0dXJlIHN0YXRlIC0gbm90IHVzZWQgaW4gU3RhbmRhbG9uZSBDaGFydHMuICovXG4gICAgdGhpcy5wYWlyZWQgPSB0cnVlO1xuICAgIHRoaXMuZmlyc3RTZXJpZXNUcmFuc2xhdGlvbiA9IHRydWU7XG4gICAgdGhpcy5sYXN0VXBkYXRlQ2xpcFJlY3QgPSB2b2lkIDA7XG4gICAgdGhpcy5fbGFzdENyb3NzTGluZUlkcyA9IHZvaWQgMDtcbiAgICB0aGlzLl9sYXN0QXhpc0FyZWFXaWR0aHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuX2xhc3RDbGlwU2VyaWVzID0gZmFsc2U7XG4gICAgdGhpcy5fbGFzdFZpc2liaWxpdHkgPSB7XG4gICAgICBjcm9zc0xpbmVzOiB0cnVlLFxuICAgICAgc2VyaWVzOiB0cnVlXG4gICAgfTtcbiAgfVxuICBvbkF4aXNDaGFuZ2UobmV3VmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgc3VwZXIub25BeGlzQ2hhbmdlKG5ld1ZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgdGhpcy5jdHg/Lnpvb21NYW5hZ2VyLnVwZGF0ZUF4ZXMobmV3VmFsdWUpO1xuICB9XG4gIGRlc3Ryb3lTZXJpZXMoc2VyaWVzKSB7XG4gICAgc3VwZXIuZGVzdHJveVNlcmllcyhzZXJpZXMpO1xuICAgIHRoaXMuZmlyc3RTZXJpZXNUcmFuc2xhdGlvbiA9IHRydWU7XG4gIH1cbiAgZ2V0Q2hhcnRUeXBlKCkge1xuICAgIHJldHVybiBcImNhcnRlc2lhblwiO1xuICB9XG4gIHNldFJvb3RDbGlwUmVjdHMoY2xpcFJlY3QpIHtcbiAgICBjb25zdCB7IHNlcmllc1Jvb3QsIGFubm90YXRpb25Sb290LCBoaWdobGlnaHRSb290IH0gPSB0aGlzO1xuICAgIHNlcmllc1Jvb3Quc2V0Q2xpcFJlY3QoY2xpcFJlY3QpO1xuICAgIGhpZ2hsaWdodFJvb3Quc2V0Q2xpcFJlY3QoY2xpcFJlY3QpO1xuICAgIGFubm90YXRpb25Sb290LnNldENsaXBSZWN0KGNsaXBSZWN0KTtcbiAgfVxuICBwZXJmb3JtTGF5b3V0KGN0eCkge1xuICAgIGNvbnN0IHsgZmlyc3RTZXJpZXNUcmFuc2xhdGlvbiwgc2VyaWVzUm9vdCwgYW5ub3RhdGlvblJvb3QsIGhpZ2hsaWdodFJvb3QgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBzZXJpZXNSZWN0LCB2aXNpYmlsaXR5LCBjbGlwU2VyaWVzIH0gPSB0aGlzLnVwZGF0ZUF4ZXMoY3R4LmxheW91dEJveCk7XG4gICAgdGhpcy5zZXJpZXNSb290LnZpc2libGUgPSB2aXNpYmlsaXR5LnNlcmllcztcbiAgICB0aGlzLnNlcmllc1JlY3QgPSBzZXJpZXNSZWN0O1xuICAgIHRoaXMuYW5pbWF0aW9uUmVjdCA9IGN0eC5sYXlvdXRCb3g7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBzZXJpZXNSZWN0O1xuICAgIGlmIChmaXJzdFNlcmllc1RyYW5zbGF0aW9uKSB7XG4gICAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIFtzZXJpZXNSb290LCBhbm5vdGF0aW9uUm9vdCwgaGlnaGxpZ2h0Um9vdF0pIHtcbiAgICAgICAgZ3JvdXAudHJhbnNsYXRpb25YID0gTWF0aC5mbG9vcih4KTtcbiAgICAgICAgZ3JvdXAudHJhbnNsYXRpb25ZID0gTWF0aC5mbG9vcih5KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZmlyc3RTZXJpZXNUcmFuc2xhdGlvbiA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7IHRyYW5zbGF0aW9uWCwgdHJhbnNsYXRpb25ZIH0gPSBzZXJpZXNSb290O1xuICAgICAgc3RhdGljRnJvbVRvTW90aW9uKFxuICAgICAgICB0aGlzLmlkLFxuICAgICAgICBcInNlcmllc1JlY3RcIixcbiAgICAgICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlcixcbiAgICAgICAgW3Nlcmllc1Jvb3QsIGhpZ2hsaWdodFJvb3QsIGFubm90YXRpb25Sb290XSxcbiAgICAgICAgeyB0cmFuc2xhdGlvblgsIHRyYW5zbGF0aW9uWSB9LFxuICAgICAgICB7IHRyYW5zbGF0aW9uWDogTWF0aC5mbG9vcih4KSwgdHJhbnNsYXRpb25ZOiBNYXRoLmZsb29yKHkpIH0sXG4gICAgICAgIHsgcGhhc2U6IFwidXBkYXRlXCIgfVxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3Qgc2VyaWVzUGFkZGVkUmVjdCA9IHNlcmllc1JlY3QuY2xvbmUoKS5ncm93KHRoaXMuc2VyaWVzQXJlYS5wYWRkaW5nKTtcbiAgICBjb25zdCBjbGlwUmVjdCA9IHRoaXMuc2VyaWVzQXJlYS5jbGlwIHx8IGNsaXBTZXJpZXMgPyBzZXJpZXNQYWRkZWRSZWN0IDogdm9pZCAwO1xuICAgIGNvbnN0IHsgbGFzdFVwZGF0ZUNsaXBSZWN0IH0gPSB0aGlzO1xuICAgIHRoaXMubGFzdFVwZGF0ZUNsaXBSZWN0ID0gY2xpcFJlY3Q7XG4gICAgaWYgKHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuaXNBY3RpdmUoKSAmJiBsYXN0VXBkYXRlQ2xpcFJlY3QgIT0gbnVsbCkge1xuICAgICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5hbmltYXRlKHtcbiAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgIGdyb3VwSWQ6IFwiY2xpcC1yZWN0XCIsXG4gICAgICAgIHBoYXNlOiBcInVwZGF0ZVwiLFxuICAgICAgICBmcm9tOiBsYXN0VXBkYXRlQ2xpcFJlY3QsXG4gICAgICAgIHRvOiBzZXJpZXNQYWRkZWRSZWN0LFxuICAgICAgICBvblVwZGF0ZTogKGludGVycG9sYXRlZENsaXBSZWN0KSA9PiB0aGlzLnNldFJvb3RDbGlwUmVjdHMoaW50ZXJwb2xhdGVkQ2xpcFJlY3QpLFxuICAgICAgICBvbkNvbXBsZXRlOiAoKSA9PiB0aGlzLnNldFJvb3RDbGlwUmVjdHMoY2xpcFJlY3QpXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRSb290Q2xpcFJlY3RzKGNsaXBSZWN0KTtcbiAgICB9XG4gICAgdGhpcy5jdHgubGF5b3V0TWFuYWdlci5lbWl0TGF5b3V0Q29tcGxldGUoY3R4LCB7XG4gICAgICBheGVzOiB0aGlzLmF4ZXMubWFwKChheGlzKSA9PiBheGlzLmdldExheW91dFN0YXRlKCkpLFxuICAgICAgc2VyaWVzOiB7XG4gICAgICAgIHJlY3Q6IHNlcmllc1JlY3QsXG4gICAgICAgIHBhZGRlZFJlY3Q6IHNlcmllc1BhZGRlZFJlY3QsXG4gICAgICAgIHZpc2libGU6IHZpc2liaWxpdHkuc2VyaWVzLFxuICAgICAgICBzaG91bGRGbGlwWFk6IHRoaXMuc2hvdWxkRmxpcFhZKClcbiAgICAgIH0sXG4gICAgICBjbGlwU2VyaWVzXG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlQXhlcyhsYXlvdXRCb3gpIHtcbiAgICBjb25zdCBjcm9zc0xpbmVJZHMgPSB0aGlzLmF4ZXMuZmxhdE1hcCgoYXhpcykgPT4gYXhpcy5jcm9zc0xpbmVzID8/IFtdKS5tYXAoKGNyb3NzTGluZSkgPT4gY3Jvc3NMaW5lLmlkKTtcbiAgICBjb25zdCBheGVzVmFsaWQgPSB0aGlzLl9sYXN0Q3Jvc3NMaW5lSWRzICE9IG51bGwgJiYgdGhpcy5fbGFzdENyb3NzTGluZUlkcy5sZW5ndGggPT09IGNyb3NzTGluZUlkcy5sZW5ndGggJiYgdGhpcy5fbGFzdENyb3NzTGluZUlkcy5ldmVyeSgoaWQsIGluZGV4KSA9PiBjcm9zc0xpbmVJZHNbaW5kZXhdID09PSBpZCk7XG4gICAgbGV0IGF4aXNBcmVhV2lkdGhzO1xuICAgIGxldCBjbGlwU2VyaWVzO1xuICAgIGxldCB2aXNpYmlsaXR5O1xuICAgIGlmIChheGVzVmFsaWQpIHtcbiAgICAgIGF4aXNBcmVhV2lkdGhzID0gbmV3IE1hcCh0aGlzLl9sYXN0QXhpc0FyZWFXaWR0aHMuZW50cmllcygpKTtcbiAgICAgIGNsaXBTZXJpZXMgPSB0aGlzLl9sYXN0Q2xpcFNlcmllcztcbiAgICAgIHZpc2liaWxpdHkgPSB7IC4uLnRoaXMuX2xhc3RWaXNpYmlsaXR5IH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGF4aXNBcmVhV2lkdGhzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIGNsaXBTZXJpZXMgPSBmYWxzZTtcbiAgICAgIHZpc2liaWxpdHkgPSB7IGNyb3NzTGluZXM6IHRydWUsIHNlcmllczogdHJ1ZSB9O1xuICAgICAgdGhpcy5fbGFzdENyb3NzTGluZUlkcyA9IGNyb3NzTGluZUlkcztcbiAgICB9XG4gICAgY29uc3QgbGl2ZUF4aXNXaWR0aHMgPSBuZXcgU2V0KHRoaXMuYXhlcy5tYXAoKGEpID0+IGEucG9zaXRpb24pKTtcbiAgICBmb3IgKGNvbnN0IHBvc2l0aW9uIG9mIGF4aXNBcmVhV2lkdGhzLmtleXMoKSkge1xuICAgICAgaWYgKCFsaXZlQXhpc1dpZHRocy5oYXMocG9zaXRpb24pKSB7XG4gICAgICAgIGF4aXNBcmVhV2lkdGhzLmRlbGV0ZShwb3NpdGlvbik7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHN0YWJsZU91dHB1dHMgPSAob3RoZXJBeGlzV2lkdGhzLCBvdGhlckNsaXBTZXJpZXMsIG90aGVyVmlzaWJpbGl0eSkgPT4ge1xuICAgICAgaWYgKFsuLi5vdGhlckF4aXNXaWR0aHMua2V5cygpXS5zb21lKChrKSA9PiAhYXhpc0FyZWFXaWR0aHMuaGFzKGspKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodmlzaWJpbGl0eS5jcm9zc0xpbmVzICE9PSBvdGhlclZpc2liaWxpdHkuY3Jvc3NMaW5lcyB8fCB2aXNpYmlsaXR5LnNlcmllcyAhPT0gb3RoZXJWaXNpYmlsaXR5LnNlcmllcyB8fCBjbGlwU2VyaWVzICE9PSBvdGhlckNsaXBTZXJpZXMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBbcCwgd10gb2YgYXhpc0FyZWFXaWR0aHMuZW50cmllcygpKSB7XG4gICAgICAgIGNvbnN0IG90aGVyVyA9IG90aGVyQXhpc1dpZHRocy5nZXQocCk7XG4gICAgICAgIGlmICgodyAhPSBudWxsIHx8IG90aGVyVyAhPSBudWxsKSAmJiB3ICE9PSBvdGhlclcpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgY29uc3QgY2VpbFZhbHVlcyA9IChtYXApID0+IHtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIG1hcC5lbnRyaWVzKCkpIHtcbiAgICAgICAgaWYgKHZhbHVlICYmIE1hdGguYWJzKHZhbHVlKSA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICBtYXAuc2V0KGtleSwgMCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbWFwLnNldChrZXksIHZhbHVlICE9IG51bGwgPyBNYXRoLmNlaWwodmFsdWUpIDogdmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hcDtcbiAgICB9O1xuICAgIGxldCBsYXN0UGFzc0F4aXNBcmVhV2lkdGhzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBsZXQgbGFzdFBhc3NWaXNpYmlsaXR5ID0ge307XG4gICAgbGV0IGxhc3RQYXNzQ2xpcFNlcmllcyA9IGZhbHNlO1xuICAgIGxldCBzZXJpZXNSZWN0ID0gdGhpcy5zZXJpZXNSZWN0Py5jbG9uZSgpO1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgZG8ge1xuICAgICAgYXhpc0FyZWFXaWR0aHMgPSBuZXcgTWFwKGxhc3RQYXNzQXhpc0FyZWFXaWR0aHMuZW50cmllcygpKTtcbiAgICAgIGNsaXBTZXJpZXMgPSBsYXN0UGFzc0NsaXBTZXJpZXM7XG4gICAgICBPYmplY3QuYXNzaWduKHZpc2liaWxpdHksIGxhc3RQYXNzVmlzaWJpbGl0eSk7XG4gICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnVwZGF0ZUF4ZXNQYXNzKGF4aXNBcmVhV2lkdGhzLCBsYXlvdXRCb3guY2xvbmUoKSwgc2VyaWVzUmVjdCk7XG4gICAgICBsYXN0UGFzc0F4aXNBcmVhV2lkdGhzID0gY2VpbFZhbHVlcyhyZXN1bHQuYXhpc0FyZWFXaWR0aHMpO1xuICAgICAgbGFzdFBhc3NWaXNpYmlsaXR5ID0gcmVzdWx0LnZpc2liaWxpdHk7XG4gICAgICBsYXN0UGFzc0NsaXBTZXJpZXMgPSByZXN1bHQuY2xpcFNlcmllcztcbiAgICAgICh7IHNlcmllc1JlY3QgfSA9IHJlc3VsdCk7XG4gICAgICBpZiAoY291bnQrKyA+IDEwKSB7XG4gICAgICAgIExvZ2dlci53YXJuKFwidW5hYmxlIHRvIGZpbmQgc3RhYmxlIGF4aXMgbGF5b3V0LlwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSB3aGlsZSAoIXN0YWJsZU91dHB1dHMobGFzdFBhc3NBeGlzQXJlYVdpZHRocywgbGFzdFBhc3NDbGlwU2VyaWVzLCBsYXN0UGFzc1Zpc2liaWxpdHkpKTtcbiAgICB0aGlzLmF4ZXMuZm9yRWFjaCgoYXhpcykgPT4ge1xuICAgICAgYXhpcy51cGRhdGUoKTtcbiAgICB9KTtcbiAgICBjb25zdCBjbGlwUmVjdFBhZGRpbmcgPSA1O1xuICAgIHRoaXMuYXhlcy5mb3JFYWNoKChheGlzKSA9PiB7XG4gICAgICBheGlzLnNldENyb3NzTGluZXNWaXNpYmxlKHZpc2liaWxpdHkuY3Jvc3NMaW5lcyk7XG4gICAgICBpZiAoIXNlcmllc1JlY3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYXhpcy5jbGlwR3JpZChcbiAgICAgICAgc2VyaWVzUmVjdC54LFxuICAgICAgICBzZXJpZXNSZWN0LnksXG4gICAgICAgIHNlcmllc1JlY3Qud2lkdGggKyBjbGlwUmVjdFBhZGRpbmcsXG4gICAgICAgIHNlcmllc1JlY3QuaGVpZ2h0ICsgY2xpcFJlY3RQYWRkaW5nXG4gICAgICApO1xuICAgICAgc3dpdGNoIChheGlzLnBvc2l0aW9uKSB7XG4gICAgICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgICAgIGF4aXMuY2xpcFRpY2tMaW5lcyhcbiAgICAgICAgICAgIGxheW91dEJveC54LFxuICAgICAgICAgICAgc2VyaWVzUmVjdC55LFxuICAgICAgICAgICAgbGF5b3V0Qm94LndpZHRoICsgY2xpcFJlY3RQYWRkaW5nLFxuICAgICAgICAgICAgc2VyaWVzUmVjdC5oZWlnaHQgKyBjbGlwUmVjdFBhZGRpbmdcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwidG9wXCI6XG4gICAgICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgICAgICBheGlzLmNsaXBUaWNrTGluZXMoXG4gICAgICAgICAgICBzZXJpZXNSZWN0LngsXG4gICAgICAgICAgICBsYXlvdXRCb3gueSxcbiAgICAgICAgICAgIHNlcmllc1JlY3Qud2lkdGggKyBjbGlwUmVjdFBhZGRpbmcsXG4gICAgICAgICAgICBsYXlvdXRCb3guaGVpZ2h0ICsgY2xpcFJlY3RQYWRkaW5nXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLl9sYXN0QXhpc0FyZWFXaWR0aHMgPSBheGlzQXJlYVdpZHRocztcbiAgICB0aGlzLl9sYXN0VmlzaWJpbGl0eSA9IHZpc2liaWxpdHk7XG4gICAgdGhpcy5fbGFzdENsaXBTZXJpZXMgPSBjbGlwU2VyaWVzO1xuICAgIHJldHVybiB7IHNlcmllc1JlY3QsIHZpc2liaWxpdHksIGNsaXBTZXJpZXMgfTtcbiAgfVxuICB1cGRhdGVBeGVzUGFzcyhheGlzQXJlYVdpZHRocywgYm91bmRzLCBsYXN0UGFzc1Nlcmllc1JlY3QpIHtcbiAgICBjb25zdCBheGlzV2lkdGhzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBjb25zdCBheGlzR3JvdXBzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBjb25zdCB2aXNpYmlsaXR5ID0ge1xuICAgICAgc2VyaWVzOiB0cnVlLFxuICAgICAgY3Jvc3NMaW5lczogdHJ1ZVxuICAgIH07XG4gICAgbGV0IGNsaXBTZXJpZXMgPSBmYWxzZTtcbiAgICBjb25zdCBwcmltYXJ5VGlja0NvdW50cyA9IHt9O1xuICAgIGNvbnN0IHBhZGRlZEJvdW5kcyA9IHRoaXMuYXBwbHlTZXJpZXNQYWRkaW5nKGJvdW5kcyk7XG4gICAgY29uc3QgY3Jvc3NMaW5lUGFkZGluZyA9IGxhc3RQYXNzU2VyaWVzUmVjdCA/IHRoaXMuYnVpbGRDcm9zc0xpbmVQYWRkaW5nKGF4aXNBcmVhV2lkdGhzKSA6IHt9O1xuICAgIGNvbnN0IGF4aXNBcmVhQm91bmQgPSB0aGlzLmJ1aWxkQXhpc0JvdW5kKHBhZGRlZEJvdW5kcywgYXhpc0FyZWFXaWR0aHMsIGNyb3NzTGluZVBhZGRpbmcsIHZpc2liaWxpdHkpO1xuICAgIGNvbnN0IHNlcmllc1JlY3QgPSB0aGlzLmJ1aWxkU2VyaWVzUmVjdChheGlzQXJlYUJvdW5kLCBheGlzQXJlYVdpZHRocyk7XG4gICAgZm9yIChjb25zdCBheGlzIG9mIHRoaXMuYXhlcykge1xuICAgICAgY29uc3QgeyBwb3NpdGlvbiA9IFwibGVmdFwiIH0gPSBheGlzO1xuICAgICAgY29uc3QgeyBjbGlwU2VyaWVzOiBuZXdDbGlwU2VyaWVzLCBheGlzVGhpY2tuZXNzIH0gPSB0aGlzLmNhbGN1bGF0ZUF4aXNEaW1lbnNpb25zKHtcbiAgICAgICAgYXhpcyxcbiAgICAgICAgc2VyaWVzUmVjdCxcbiAgICAgICAgcHJpbWFyeVRpY2tDb3VudHMsXG4gICAgICAgIGNsaXBTZXJpZXNcbiAgICAgIH0pO1xuICAgICAgYXhpc1dpZHRocy5zZXQoYXhpcy5pZCwgYXhpc1RoaWNrbmVzcyk7XG4gICAgICBpZiAoIWF4aXNHcm91cHMuaGFzKHBvc2l0aW9uKSlcbiAgICAgICAgYXhpc0dyb3Vwcy5zZXQocG9zaXRpb24sIFtdKTtcbiAgICAgIGF4aXNHcm91cHMuZ2V0KHBvc2l0aW9uKT8ucHVzaChheGlzKTtcbiAgICAgIGNsaXBTZXJpZXMgPSBjbGlwU2VyaWVzIHx8IG5ld0NsaXBTZXJpZXM7XG4gICAgfVxuICAgIGNvbnN0IG5ld0F4aXNBcmVhV2lkdGhzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBjb25zdCBheGlzT2Zmc2V0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBbcG9zaXRpb24sIGF4ZXNdIG9mIGF4aXNHcm91cHMuZW50cmllcygpKSB7XG4gICAgICBjb25zdCBpc1ZlcnRpY2FsID0gcG9zaXRpb24gPT09IFwibGVmdFwiIHx8IHBvc2l0aW9uID09PSBcInJpZ2h0XCI7XG4gICAgICBuZXdBeGlzQXJlYVdpZHRocy5zZXQocG9zaXRpb24sIHRoaXMuY2FsY3VsYXRlQXhpc0FyZWEoYXhlcywgYXhpc1dpZHRocywgYXhpc09mZnNldHMsIGlzVmVydGljYWwpKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBbcG9zaXRpb24sIGF4ZXNdIG9mIGF4aXNHcm91cHMuZW50cmllcygpKSB7XG4gICAgICB0aGlzLnBvc2l0aW9uQXhlcyh7XG4gICAgICAgIGF4ZXMsXG4gICAgICAgIHBvc2l0aW9uLFxuICAgICAgICBheGlzV2lkdGhzLFxuICAgICAgICBheGlzT2Zmc2V0cyxcbiAgICAgICAgYXhpc0FyZWFXaWR0aHM6IG5ld0F4aXNBcmVhV2lkdGhzLFxuICAgICAgICBheGlzQm91bmQ6IGF4aXNBcmVhQm91bmQsXG4gICAgICAgIHNlcmllc1JlY3RcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4geyBjbGlwU2VyaWVzLCBzZXJpZXNSZWN0LCBheGlzQXJlYVdpZHRoczogbmV3QXhpc0FyZWFXaWR0aHMsIHZpc2liaWxpdHkgfTtcbiAgfVxuICBidWlsZENyb3NzTGluZVBhZGRpbmcoYXhpc0FyZWFTaXplKSB7XG4gICAgY29uc3QgY3Jvc3NMaW5lUGFkZGluZyA9IHt9O1xuICAgIHRoaXMuYXhlcy5mb3JFYWNoKChheGlzKSA9PiB7XG4gICAgICBheGlzLmNyb3NzTGluZXM/LmZvckVhY2goKGNyb3NzTGluZSkgPT4ge1xuICAgICAgICBjcm9zc0xpbmUuY2FsY3VsYXRlUGFkZGluZz8uKGNyb3NzTGluZVBhZGRpbmcpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgZm9yIChjb25zdCBbc2lkZSwgcGFkZGluZyA9IDBdIG9mIE9iamVjdC5lbnRyaWVzKGNyb3NzTGluZVBhZGRpbmcpKSB7XG4gICAgICBjcm9zc0xpbmVQYWRkaW5nW3NpZGVdID0gTWF0aC5tYXgocGFkZGluZyAtIChheGlzQXJlYVNpemUuZ2V0KHNpZGUpID8/IDApLCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyb3NzTGluZVBhZGRpbmc7XG4gIH1cbiAgYXBwbHlTZXJpZXNQYWRkaW5nKGJvdW5kcykge1xuICAgIGNvbnN0IHBhZGRlZFJlY3QgPSBib3VuZHMuY2xvbmUoKTtcbiAgICBkaXJlY3Rpb25zLmZvckVhY2goKGRpcikgPT4ge1xuICAgICAgY29uc3QgcGFkZGluZyA9IHRoaXMuc2VyaWVzQXJlYS5wYWRkaW5nW2Rpcl07XG4gICAgICBjb25zdCBheGlzID0gdGhpcy5heGVzLmZpbmRMYXN0KChhKSA9PiBhLnBvc2l0aW9uID09PSBkaXIpO1xuICAgICAgaWYgKGF4aXMpIHtcbiAgICAgICAgYXhpcy5zZXJpZXNBcmVhUGFkZGluZyA9IHBhZGRpbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYWRkZWRSZWN0LnNocmluayhwYWRkaW5nLCBkaXIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwYWRkZWRSZWN0O1xuICB9XG4gIGJ1aWxkQXhpc0JvdW5kKGJvdW5kcywgYXhpc0FyZWFXaWR0aHMsIGNyb3NzTGluZVBhZGRpbmcsIHZpc2liaWxpdHkpIHtcbiAgICBjb25zdCByZXN1bHQgPSBib3VuZHMuY2xvbmUoKTtcbiAgICBjb25zdCB7IHRvcCA9IDAsIHJpZ2h0ID0gMCwgYm90dG9tID0gMCwgbGVmdCA9IDAgfSA9IGNyb3NzTGluZVBhZGRpbmc7XG4gICAgY29uc3QgaG9yaXpvbnRhbFBhZGRpbmcgPSBsZWZ0ICsgcmlnaHQ7XG4gICAgY29uc3QgdmVydGljYWxQYWRkaW5nID0gdG9wICsgYm90dG9tO1xuICAgIGNvbnN0IHRvdGFsV2lkdGggPSAoYXhpc0FyZWFXaWR0aHMuZ2V0KFwibGVmdFwiKSA/PyAwKSArIChheGlzQXJlYVdpZHRocy5nZXQoXCJyaWdodFwiKSA/PyAwKSArIGhvcml6b250YWxQYWRkaW5nO1xuICAgIGNvbnN0IHRvdGFsSGVpZ2h0ID0gKGF4aXNBcmVhV2lkdGhzLmdldChcInRvcFwiKSA/PyAwKSArIChheGlzQXJlYVdpZHRocy5nZXQoXCJib3R0b21cIikgPz8gMCkgKyB2ZXJ0aWNhbFBhZGRpbmc7XG4gICAgaWYgKHJlc3VsdC53aWR0aCA8PSB0b3RhbFdpZHRoIHx8IHJlc3VsdC5oZWlnaHQgPD0gdG90YWxIZWlnaHQpIHtcbiAgICAgIHZpc2liaWxpdHkuY3Jvc3NMaW5lcyA9IGZhbHNlO1xuICAgICAgdmlzaWJpbGl0eS5zZXJpZXMgPSBmYWxzZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJlc3VsdC54ICs9IGxlZnQ7XG4gICAgcmVzdWx0LnkgKz0gdG9wO1xuICAgIHJlc3VsdC53aWR0aCAtPSBob3Jpem9udGFsUGFkZGluZztcbiAgICByZXN1bHQuaGVpZ2h0IC09IHZlcnRpY2FsUGFkZGluZztcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGJ1aWxkU2VyaWVzUmVjdChheGlzQm91bmQsIGF4aXNBcmVhV2lkdGhzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXhpc0JvdW5kLmNsb25lKCk7XG4gICAgcmVzdWx0LnggKz0gYXhpc0FyZWFXaWR0aHMuZ2V0KFwibGVmdFwiKSA/PyAwO1xuICAgIHJlc3VsdC55ICs9IGF4aXNBcmVhV2lkdGhzLmdldChcInRvcFwiKSA/PyAwO1xuICAgIHJlc3VsdC53aWR0aCAtPSAoYXhpc0FyZWFXaWR0aHMuZ2V0KFwibGVmdFwiKSA/PyAwKSArIChheGlzQXJlYVdpZHRocy5nZXQoXCJyaWdodFwiKSA/PyAwKTtcbiAgICByZXN1bHQuaGVpZ2h0IC09IChheGlzQXJlYVdpZHRocy5nZXQoXCJ0b3BcIikgPz8gMCkgKyAoYXhpc0FyZWFXaWR0aHMuZ2V0KFwiYm90dG9tXCIpID8/IDApO1xuICAgIHJlc3VsdC53aWR0aCA9IE1hdGgubWF4KDAsIHJlc3VsdC53aWR0aCk7XG4gICAgcmVzdWx0LmhlaWdodCA9IE1hdGgubWF4KDAsIHJlc3VsdC5oZWlnaHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgY2xhbXBUb091dHNpZGVTZXJpZXNSZWN0KHNlcmllc1JlY3QsIHZhbHVlLCBkaW1lbnNpb24sIGRpcmVjdGlvbikge1xuICAgIGNvbnN0IHsgeCwgeSwgd2lkdGg6IHdpZHRoMiwgaGVpZ2h0OiBoZWlnaHQyIH0gPSBzZXJpZXNSZWN0O1xuICAgIGNvbnN0IGNsYW1wQm91bmRzID0gW3gsIHksIHggKyB3aWR0aDIsIHkgKyBoZWlnaHQyXTtcbiAgICBjb25zdCBjb21wYXJlVG8gPSBjbGFtcEJvdW5kc1soZGltZW5zaW9uID09PSBcInhcIiA/IDAgOiAxKSArIChkaXJlY3Rpb24gPT09IDEgPyAwIDogMildO1xuICAgIGNvbnN0IGNsYW1wRm4gPSBkaXJlY3Rpb24gPT09IDEgPyBNYXRoLm1pbiA6IE1hdGgubWF4O1xuICAgIHJldHVybiBjbGFtcEZuKHZhbHVlLCBjb21wYXJlVG8pO1xuICB9XG4gIGNhbGN1bGF0ZUF4aXNEaW1lbnNpb25zKG9wdHMpIHtcbiAgICBjb25zdCB7IGF4aXMsIHNlcmllc1JlY3QsIHByaW1hcnlUaWNrQ291bnRzIH0gPSBvcHRzO1xuICAgIGxldCB7IGNsaXBTZXJpZXMgfSA9IG9wdHM7XG4gICAgY29uc3QgeyBwb3NpdGlvbiA9IFwibGVmdFwiLCBkaXJlY3Rpb24gfSA9IGF4aXM7XG4gICAgdGhpcy5zaXplQXhpcyhheGlzLCBzZXJpZXNSZWN0LCBwb3NpdGlvbik7XG4gICAgY29uc3Qgc3luY2VkRG9tYWluID0gdGhpcy5nZXRTeW5jZWREb21haW4oYXhpcyk7XG4gICAgY29uc3QgbGF5b3V0ID0gYXhpcy5jYWxjdWxhdGVMYXlvdXQoc3luY2VkRG9tYWluLCBheGlzLm5pY2UgPyBwcmltYXJ5VGlja0NvdW50c1tkaXJlY3Rpb25dIDogdm9pZCAwKTtcbiAgICBjb25zdCBpc1ZlcnRpY2FsID0gZGlyZWN0aW9uID09PSBcInlcIiAvKiBZICovO1xuICAgIHByaW1hcnlUaWNrQ291bnRzW2RpcmVjdGlvbl0gPz8gKHByaW1hcnlUaWNrQ291bnRzW2RpcmVjdGlvbl0gPSBsYXlvdXQucHJpbWFyeVRpY2tDb3VudCk7XG4gICAgY2xpcFNlcmllcyB8fCAoY2xpcFNlcmllcyA9IGF4aXMuZGF0YURvbWFpbi5jbGlwcGVkIHx8IGF4aXMudmlzaWJsZVJhbmdlWzBdID4gMCB8fCBheGlzLnZpc2libGVSYW5nZVsxXSA8IDEpO1xuICAgIGxldCBheGlzVGhpY2tuZXNzO1xuICAgIGlmIChheGlzLnRoaWNrbmVzcyAhPSBudWxsICYmIGF4aXMudGhpY2tuZXNzID4gMCkge1xuICAgICAgYXhpc1RoaWNrbmVzcyA9IGF4aXMudGhpY2tuZXNzO1xuICAgIH0gZWxzZSB7XG4gICAgICBheGlzVGhpY2tuZXNzID0gaXNWZXJ0aWNhbCA/IGxheW91dC5iYm94LndpZHRoIDogbGF5b3V0LmJib3guaGVpZ2h0O1xuICAgIH1cbiAgICBheGlzVGhpY2tuZXNzID0gTWF0aC5jZWlsKGF4aXNUaGlja25lc3MpO1xuICAgIHJldHVybiB7IGNsaXBTZXJpZXMsIGF4aXNUaGlja25lc3MgfTtcbiAgfVxuICBnZXRTeW5jZWREb21haW4oYXhpcykge1xuICAgIGNvbnN0IHN5bmNNb2R1bGUgPSB0aGlzLm1vZHVsZXNNYW5hZ2VyLmdldE1vZHVsZShcInN5bmNcIik7XG4gICAgaWYgKCFzeW5jTW9kdWxlPy5lbmFibGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHN5bmNlZERvbWFpbiA9IHN5bmNNb2R1bGUuZ2V0U3luY2VkRG9tYWluKGF4aXMpO1xuICAgIGlmIChzeW5jZWREb21haW4gJiYgYXhpcy5kYXRhRG9tYWluLmRvbWFpbi5sZW5ndGgpIHtcbiAgICAgIGxldCBzaG91bGRVcGRhdGU7XG4gICAgICBjb25zdCB7IGRvbWFpbiB9ID0gYXhpcy5zY2FsZTtcbiAgICAgIGlmIChDb250aW51b3VzU2NhbGUuaXMoYXhpcy5zY2FsZSkpIHtcbiAgICAgICAgY29uc3QgW21pbiwgbWF4XSA9IGZpbmRNaW5NYXgoc3luY2VkRG9tYWluKTtcbiAgICAgICAgc2hvdWxkVXBkYXRlID0gbWluICE9PSBkb21haW5bMF0gfHwgbWF4ICE9PSBkb21haW5bMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaG91bGRVcGRhdGUgPSAhYXJyYXlzRXF1YWwoc3luY2VkRG9tYWluLCBkb21haW4pO1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZFVwZGF0ZSAmJiAhdGhpcy5za2lwU3luYykge1xuICAgICAgICBzeW5jTW9kdWxlLnVwZGF0ZVNpYmxpbmdzKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzeW5jZWREb21haW47XG4gIH1cbiAgc2l6ZUF4aXMoYXhpcywgc2VyaWVzUmVjdCwgcG9zaXRpb24pIHtcbiAgICBjb25zdCBpc0NhdGVnb3J5ID0gYXhpcyBpbnN0YW5jZW9mIENhdGVnb3J5QXhpcyB8fCBheGlzIGluc3RhbmNlb2YgR3JvdXBlZENhdGVnb3J5QXhpcztcbiAgICBjb25zdCBpc0xlZnRSaWdodCA9IHBvc2l0aW9uID09PSBcImxlZnRcIiB8fCBwb3NpdGlvbiA9PT0gXCJyaWdodFwiO1xuICAgIGxldCB7IG1pbiwgbWF4IH0gPSB0aGlzLmN0eC56b29tTWFuYWdlci5nZXRBeGlzWm9vbShheGlzLmlkKTtcbiAgICBjb25zdCB7IHdpZHRoOiB3aWR0aDIsIGhlaWdodDogaGVpZ2h0MiB9ID0gc2VyaWVzUmVjdDtcbiAgICBjb25zdCBtaW5TdGFydCA9IDA7XG4gICAgY29uc3QgbWF4RW5kID0gaXNMZWZ0UmlnaHQgPyBoZWlnaHQyIDogd2lkdGgyO1xuICAgIGxldCBzdGFydDIgPSBtaW5TdGFydDtcbiAgICBsZXQgZW5kMiA9IG1heEVuZDtcbiAgICBjb25zdCB7IHdpZHRoOiBheGlzV2lkdGgsIHVuaXQsIGFsaWduIH0gPSBheGlzLmxheW91dENvbnN0cmFpbnRzO1xuICAgIGlmICh1bml0ID09PSBcInB4XCIpIHtcbiAgICAgIGVuZDIgPSBzdGFydDIgKyBheGlzV2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVuZDIgPSBlbmQyICogYXhpc1dpZHRoIC8gMTAwO1xuICAgIH1cbiAgICBpZiAoYWxpZ24gPT09IFwiZW5kXCIpIHtcbiAgICAgIHN0YXJ0MiA9IG1heEVuZCAtIChlbmQyIC0gc3RhcnQyKTtcbiAgICAgIGVuZDIgPSBtYXhFbmQ7XG4gICAgfVxuICAgIGlmIChpc0NhdGVnb3J5ICYmIGlzTGVmdFJpZ2h0KSB7XG4gICAgICBbbWluLCBtYXhdID0gWzEgLSBtYXgsIDEgLSBtaW5dO1xuICAgIH0gZWxzZSBpZiAoaXNMZWZ0UmlnaHQpIHtcbiAgICAgIFtzdGFydDIsIGVuZDJdID0gW2VuZDIsIHN0YXJ0Ml07XG4gICAgfVxuICAgIGF4aXMucmFuZ2UgPSBbc3RhcnQyLCBlbmQyXTtcbiAgICBheGlzLnZpc2libGVSYW5nZSA9IFttaW4sIG1heF07XG4gICAgYXhpcy5ncmlkTGVuZ3RoID0gaXNMZWZ0UmlnaHQgPyB3aWR0aDIgOiBoZWlnaHQyO1xuICB9XG4gIGNhbGN1bGF0ZUF4aXNBcmVhKGF4ZXMsIGF4aXNXaWR0aHMsIGF4aXNPZmZzZXRzLCBpc1ZlcnRpY2FsKSB7XG4gICAgY29uc3QgeyB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIsIGNhbnZhcyB9ID0gdGhpcy5jdHguc2NlbmU7XG4gICAgbGV0IGN1cnJlbnRPZmZzZXQgPSBpc1ZlcnRpY2FsID8gaGVpZ2h0MiAlIGNhbnZhcy5waXhlbFJhdGlvIDogd2lkdGgyICUgY2FudmFzLnBpeGVsUmF0aW87XG4gICAgbGV0IHRvdGFsQXhpc1dpZHRoID0gMDtcbiAgICBmb3IgKGNvbnN0IGF4aXMgb2YgYXhlcykge1xuICAgICAgYXhpc09mZnNldHMuc2V0KGF4aXMuaWQsIGN1cnJlbnRPZmZzZXQpO1xuICAgICAgY29uc3QgYXhpc1RoaWNrbmVzcyA9IGF4aXNXaWR0aHMuZ2V0KGF4aXMuaWQpID8/IDA7XG4gICAgICB0b3RhbEF4aXNXaWR0aCA9IE1hdGgubWF4KHRvdGFsQXhpc1dpZHRoLCBjdXJyZW50T2Zmc2V0ICsgYXhpc1RoaWNrbmVzcyk7XG4gICAgICBpZiAoYXhpcy5sYXlvdXRDb25zdHJhaW50cy5zdGFja2VkKSB7XG4gICAgICAgIGN1cnJlbnRPZmZzZXQgKz0gYXhpc1RoaWNrbmVzcyArIDE1O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG90YWxBeGlzV2lkdGg7XG4gIH1cbiAgcG9zaXRpb25BeGVzKG9wdHMpIHtcbiAgICBjb25zdCB7IGF4ZXMsIGF4aXNCb3VuZCwgYXhpc1dpZHRocywgYXhpc09mZnNldHMsIGF4aXNBcmVhV2lkdGhzLCBzZXJpZXNSZWN0LCBwb3NpdGlvbiB9ID0gb3B0cztcbiAgICBjb25zdCBheGlzQXJlYVdpZHRoID0gYXhpc0FyZWFXaWR0aHMuZ2V0KHBvc2l0aW9uKSA/PyAwO1xuICAgIGxldCBtYWluRGltZW5zaW9uID0gXCJ4XCI7XG4gICAgbGV0IG1pbm9yRGltZW5zaW9uID0gXCJ5XCI7XG4gICAgbGV0IGRpcmVjdGlvbiA9IDE7XG4gICAgbGV0IGF4aXNCb3VuZE1haW5PZmZzZXQgPSAwO1xuICAgIGlmIChwb3NpdGlvbiA9PT0gXCJ0b3BcIiB8fCBwb3NpdGlvbiA9PT0gXCJib3R0b21cIikge1xuICAgICAgbWFpbkRpbWVuc2lvbiA9IFwieVwiO1xuICAgICAgbWlub3JEaW1lbnNpb24gPSBcInhcIjtcbiAgICAgIGF4aXNCb3VuZE1haW5PZmZzZXQgKz0gMTtcbiAgICB9XG4gICAgYXhpc0JvdW5kTWFpbk9mZnNldCArPSBheGlzQm91bmRbbWFpbkRpbWVuc2lvbl07XG4gICAgaWYgKHBvc2l0aW9uID09PSBcInJpZ2h0XCIgfHwgcG9zaXRpb24gPT09IFwiYm90dG9tXCIpIHtcbiAgICAgIGRpcmVjdGlvbiA9IC0xO1xuICAgICAgYXhpc0JvdW5kTWFpbk9mZnNldCArPSBtYWluRGltZW5zaW9uID09PSBcInhcIiA/IGF4aXNCb3VuZC53aWR0aCA6IGF4aXNCb3VuZC5oZWlnaHQ7XG4gICAgfVxuICAgIGZvciAoY29uc3QgYXhpcyBvZiBheGVzKSB7XG4gICAgICBjb25zdCBtaW5vck9mZnNldCA9IGF4aXNBcmVhV2lkdGhzLmdldChtaW5vckRpbWVuc2lvbiA9PT0gXCJ4XCIgPyBcImxlZnRcIiA6IFwidG9wXCIpID8/IDA7XG4gICAgICBheGlzLnRyYW5zbGF0aW9uW21pbm9yRGltZW5zaW9uXSA9IGF4aXNCb3VuZFttaW5vckRpbWVuc2lvbl0gKyBtaW5vck9mZnNldDtcbiAgICAgIGNvbnN0IGF4aXNUaGlja25lc3MgPSBheGlzV2lkdGhzLmdldChheGlzLmlkKSA/PyAwO1xuICAgICAgY29uc3QgYXhpc09mZnNldCA9IGF4aXNPZmZzZXRzLmdldChheGlzLmlkKSA/PyAwO1xuICAgICAgYXhpcy50cmFuc2xhdGlvblttYWluRGltZW5zaW9uXSA9IHRoaXMuY2xhbXBUb091dHNpZGVTZXJpZXNSZWN0KFxuICAgICAgICBzZXJpZXNSZWN0LFxuICAgICAgICBheGlzQm91bmRNYWluT2Zmc2V0ICsgZGlyZWN0aW9uICogKGF4aXNPZmZzZXQgKyBheGlzVGhpY2tuZXNzKSxcbiAgICAgICAgbWFpbkRpbWVuc2lvbixcbiAgICAgICAgZGlyZWN0aW9uXG4gICAgICApO1xuICAgICAgYXhpcy5ncmlkUGFkZGluZyA9IGF4aXNBcmVhV2lkdGggLSBheGlzT2Zmc2V0IC0gYXhpc1RoaWNrbmVzcztcbiAgICAgIGF4aXMudXBkYXRlUG9zaXRpb24oKTtcbiAgICB9XG4gIH1cbiAgc2hvdWxkRmxpcFhZKCkge1xuICAgIHJldHVybiB0aGlzLnNlcmllcy5ldmVyeSgoc2VyaWVzKSA9PiBzZXJpZXMgaW5zdGFuY2VvZiBDYXJ0ZXNpYW5TZXJpZXMgJiYgc2VyaWVzLnNob3VsZEZsaXBYWSgpKTtcbiAgfVxufTtcbkNhcnRlc2lhbkNoYXJ0LmNsYXNzTmFtZSA9IFwiQ2FydGVzaWFuQ2hhcnRcIjtcbkNhcnRlc2lhbkNoYXJ0LnR5cGUgPSBcImNhcnRlc2lhblwiO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9jaGFydFByb3h5LnRzXG52YXIgX0FnQ2hhcnRJbnN0YW5jZVByb3h5ID0gY2xhc3MgX0FnQ2hhcnRJbnN0YW5jZVByb3h5IHtcbiAgY29uc3RydWN0b3IoY2hhcnQsIGZhY3RvcnlBcGksIGxpY2Vuc2VNYW5hZ2VyKSB7XG4gICAgdGhpcy5mYWN0b3J5QXBpID0gZmFjdG9yeUFwaTtcbiAgICB0aGlzLmxpY2Vuc2VNYW5hZ2VyID0gbGljZW5zZU1hbmFnZXI7XG4gICAgdGhpcy5jaGFydCA9IGNoYXJ0O1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKHgpIHtcbiAgICBpZiAoeCBpbnN0YW5jZW9mIF9BZ0NoYXJ0SW5zdGFuY2VQcm94eSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh4LmNvbnN0cnVjdG9yPy5uYW1lID09PSBcIkFnQ2hhcnRJbnN0YW5jZVByb3h5XCIgJiYgeC5jaGFydCAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHguY2hhcnQgIT0gbnVsbCAmJiB0aGlzLnZhbGlkYXRlSW1wbGVtZW50YXRpb24oeCk7XG4gIH1cbiAgc3RhdGljIHZhbGlkYXRlSW1wbGVtZW50YXRpb24oeCkge1xuICAgIGNvbnN0IGNoYXJ0UHJvcHMgPSBbXCJnZXRPcHRpb25zXCIsIFwiZGVzdHJveVwiXTtcbiAgICBjb25zdCBzaWduYXR1cmVQcm9wcyA9IE9iamVjdC5rZXlzKE9iamVjdC5nZXRQcm90b3R5cGVPZih4KSA/PyB7fSk7XG4gICAgcmV0dXJuIGNoYXJ0UHJvcHMuZXZlcnkoKHByb3ApID0+IHNpZ25hdHVyZVByb3BzLmluY2x1ZGVzKHByb3ApKTtcbiAgfVxuICBhc3luYyB1cGRhdGUob3B0aW9ucykge1xuICAgIHRoaXMuZmFjdG9yeUFwaS51cGRhdGUob3B0aW9ucywgdGhpcyk7XG4gICAgYXdhaXQgdGhpcy5jaGFydC53YWl0Rm9yVXBkYXRlKCk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlRGVsdGEoZGVsdGFPcHRpb25zKSB7XG4gICAgdGhpcy5mYWN0b3J5QXBpLnVwZGF0ZVVzZXJEZWx0YSh0aGlzLCBkZWx0YU9wdGlvbnMpO1xuICAgIGF3YWl0IHRoaXMuY2hhcnQud2FpdEZvclVwZGF0ZSgpO1xuICB9XG4gIGdldE9wdGlvbnMoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGRlZXBDbG9uZSh0aGlzLmNoYXJ0LmdldE9wdGlvbnMoKSk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgaWYgKGtleS5zdGFydHNXaXRoKFwiX1wiKSkge1xuICAgICAgICBkZWxldGUgb3B0aW9uc1trZXldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfVxuICB3YWl0Rm9yVXBkYXRlKCkge1xuICAgIHJldHVybiB0aGlzLmNoYXJ0LndhaXRGb3JVcGRhdGUoKTtcbiAgfVxuICBhc3luYyBkb3dubG9hZChvcHRzKSB7XG4gICAgY29uc3QgY2xvbmUyID0gYXdhaXQgdGhpcy5wcmVwYXJlUmVzaXplZENoYXJ0KHRoaXMsIG9wdHMpO1xuICAgIHRyeSB7XG4gICAgICBjbG9uZTIuY2hhcnQuZG93bmxvYWQob3B0cz8uZmlsZU5hbWUsIG9wdHM/LmZpbGVGb3JtYXQpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBjbG9uZTIuZGVzdHJveSgpO1xuICAgIH1cbiAgfVxuICBhc3luYyBfX3RvU1ZHKG9wdHMpIHtcbiAgICBjb25zdCBjbG9uZTIgPSBhd2FpdCB0aGlzLnByZXBhcmVSZXNpemVkQ2hhcnQodGhpcywgeyB3aWR0aDogNjAwLCBoZWlnaHQ6IDMwMCwgLi4ub3B0cyB9KTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNsb25lMi5jaGFydC50b1NWRygpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBjbG9uZTIuZGVzdHJveSgpO1xuICAgIH1cbiAgfVxuICBhc3luYyBnZXRJbWFnZURhdGFVUkwob3B0cykge1xuICAgIGNvbnN0IGNsb25lMiA9IGF3YWl0IHRoaXMucHJlcGFyZVJlc2l6ZWRDaGFydCh0aGlzLCBvcHRzKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNsb25lMi5jaGFydC5nZXRDYW52YXNEYXRhVVJMKG9wdHM/LmZpbGVGb3JtYXQpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBjbG9uZTIuZGVzdHJveSgpO1xuICAgIH1cbiAgfVxuICBnZXRTdGF0ZSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBmYWN0b3J5QXBpOiB7IGNhcmV0YWtlciB9LFxuICAgICAgY2hhcnQ6IHtcbiAgICAgICAgY3R4OiB7IGFubm90YXRpb25NYW5hZ2VyIH1cbiAgICAgIH1cbiAgICB9ID0gdGhpcztcbiAgICByZXR1cm4gY2FyZXRha2VyLnNhdmUoYW5ub3RhdGlvbk1hbmFnZXIpO1xuICB9XG4gIGFzeW5jIHNldFN0YXRlKHN0YXRlKSB7XG4gICAgY29uc3Qge1xuICAgICAgZmFjdG9yeUFwaTogeyBjYXJldGFrZXIgfSxcbiAgICAgIGNoYXJ0OiB7XG4gICAgICAgIGN0eDogeyBhbm5vdGF0aW9uTWFuYWdlciB9XG4gICAgICB9XG4gICAgfSA9IHRoaXM7XG4gICAgY2FyZXRha2VyLnJlc3RvcmUoc3RhdGUsIGFubm90YXRpb25NYW5hZ2VyKTtcbiAgICBhd2FpdCB0aGlzLmNoYXJ0LndhaXRGb3JVcGRhdGUoKTtcbiAgfVxuICByZXNldEFuaW1hdGlvbnMoKSB7XG4gICAgdGhpcy5jaGFydC5yZXNldEFuaW1hdGlvbnMoKTtcbiAgfVxuICBza2lwQW5pbWF0aW9ucygpIHtcbiAgICB0aGlzLmNoYXJ0LnNraXBBbmltYXRpb25zKCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmNoYXJ0LnB1YmxpY0FwaSA9IHZvaWQgMDtcbiAgICB0aGlzLmNoYXJ0LmRlc3Ryb3koKTtcbiAgfVxuICBhc3luYyBwcmVwYXJlUmVzaXplZENoYXJ0KHByb3h5LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCB7IGNoYXJ0IH0gPSBwcm94eTtcbiAgICBjb25zdCB3aWR0aDIgPSBvcHRzLndpZHRoID8/IGNoYXJ0LndpZHRoID8/IGNoYXJ0LmN0eC5zY2VuZS5jYW52YXMud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0MiA9IG9wdHMuaGVpZ2h0ID8/IGNoYXJ0LmhlaWdodCA/PyBjaGFydC5jdHguc2NlbmUuY2FudmFzLmhlaWdodDtcbiAgICBjb25zdCBzdGF0ZSA9IHByb3h5LmdldFN0YXRlKCk7XG4gICAgY29uc3QgaXNFbnRlcnByaXNlID0gbW9kdWxlUmVnaXN0cnkuaGFzRW50ZXJwcmlzZU1vZHVsZXMoKTtcbiAgICBjb25zdCBwcm9jZXNzZWRPdmVycmlkZXMgPSB7XG4gICAgICAuLi5jaGFydC5jaGFydE9wdGlvbnMucHJvY2Vzc2VkT3ZlcnJpZGVzLFxuICAgICAgY29udGFpbmVyOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuICAgICAgd2lkdGg6IHdpZHRoMixcbiAgICAgIGhlaWdodDogaGVpZ2h0MlxuICAgIH07XG4gICAgY29uc3QgdXNlck9wdGlvbnMgPSBjaGFydC5nZXRPcHRpb25zKCk7XG4gICAgaWYgKGlzRW50ZXJwcmlzZSkge1xuICAgICAgcHJvY2Vzc2VkT3ZlcnJpZGVzLmFuaW1hdGlvbiA9IHsgZW5hYmxlZDogZmFsc2UgfTtcbiAgICAgIGlmIChpc0FnQ2FydGVzaWFuQ2hhcnRPcHRpb25zKHVzZXJPcHRpb25zKSkge1xuICAgICAgICBwcm9jZXNzZWRPdmVycmlkZXMudG9vbGJhciA9IHsgZW5hYmxlZDogZmFsc2UgfTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmxpY2Vuc2VNYW5hZ2VyPy5pc0Rpc3BsYXlXYXRlcm1hcmsoKSkge1xuICAgICAgICBwcm9jZXNzZWRPdmVycmlkZXMuZm9yZWdyb3VuZCA9IHtcbiAgICAgICAgICB0ZXh0OiB0aGlzLmxpY2Vuc2VNYW5hZ2VyLmdldFdhdGVybWFya01lc3NhZ2UoKSxcbiAgICAgICAgICBpbWFnZToge1xuICAgICAgICAgICAgdXJsOiBgZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTWpVNElpQm9aV2xuYUhROUlqUXdJaUIyYVdWM1FtOTRQU0l3SURBZ01qVTRJRFF3SWlCbWFXeHNQU0p1YjI1bElpQjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaVBnbzhjR0YwYUNCa1BTSk5NalV1TnpjNUlESTRMalkxTjBneE15NHpOVGxNTVRFdU1UY3pJRE0wTGpBeE1rZzFMalkzTWprM1RERTNMakU0TWlBM0xqQTFPVGs1U0RJeExqazFNMHd6TXk0ME5qSWdNelF1TURFeVNESTNMamsyTWt3eU5TNDNOellnTWpndU5qVTNTREkxTGpjM09WcE5NalF1TURZNElESTBMak01TjB3eE9TNDFPRGdnTVRNdU5ETTBUREUxTGpFd055QXlOQzR6T1RkSU1qUXVNRFk0V2swMk1pNHdPVElnTVRndU9ESXpTRFE1TGpneE4xWXlNeTR3T0RaSU5UWXVOemMxUXpVMkxqVTFOU0F5TlM0eU1qSWdOVFV1TnpVMUlESTJMamt5TnlBMU5DNHpOeklnTWpndU1qQXlRelV5TGprNE9TQXlPUzQwTnpZZ05URXVNVFkySURNd0xqRXhOU0EwT0M0NU1Ea2dNekF1TVRFMVF6UTNMall5TWlBek1DNHhNVFVnTkRZdU5EVWdNamt1T0RnMUlEUTFMak01TXlBeU9TNDBNak5ETkRRdU16VTRNeUF5T0M0NU56Z3hJRFF6TGpRek1qWWdNamd1TXpFek9DQTBNaTQyT0NBeU55NDBOelpETkRFdU9USTNJREkyTGpZek9TQTBNUzR6TkRRZ01qVXVOak14SURRd0xqa3pNU0F5TkM0ME5UTkROREF1TlRFNUlESXpMakkzTlNBME1DNHpNVEVnTWpFdU9UY2dOREF1TXpFeElESXdMalV6TjBNME1DNHpNVEVnTVRrdU1UQTFJRFF3TGpVeE5pQXhOeTQ0SURRd0xqa3pNU0F4Tmk0Mk1qRkROREV1TXpRMElERTFMalEwTXlBME1TNDVNamNnTVRRdU5ETTJJRFF5TGpZNElERXpMalU1T0VNME15NDBNemMySURFeUxqYzFOemNnTkRRdU16WTVOaUF4TWk0d09UTXlJRFExTGpReE1TQXhNUzQyTlRGRE5EWXVORGM0SURFeExqRTRPU0EwTnk0Mk5UWWdNVEF1T1RZZ05EZ3VPVFEySURFd0xqazJRelV4TGpZeE1pQXhNQzQ1TmlBMU15NDJNemNnTVRFdU5qQXlJRFUxTGpBeUlERXlMamc0TlV3MU9DNHpJRGt1TmpBME9UbEROVFV1T0RFM0lEY3VOalk1T1RrZ05USXVOamMySURZdU5qazVPVGtnTkRndU9EY3lJRFl1TmprNU9UbERORFl1TnpZZ05pNDJPVGs1T1NBME5DNDROVE1nTnk0d016UTVPU0EwTXk0eE5UUWdOeTQzTURBNU9VTTBNUzQwTlRVZ09DNHpOamM1T1NBek9TNDVPVGdnT1M0ek1ETTVPU0F6T0M0M09ETWdNVEF1TlRBMFF6TTNMalUyTnlBeE1TNDNNRGNnTXpZdU5qTTBJREV6TGpFMU9DQXpOUzQ1TnpjZ01UUXVPRFUzUXpNMUxqTXhPU0F4Tmk0MU5UWWdNelF1T1RrMElERTRMalExTVNBek5DNDVPVFFnTWpBdU5UUkRNelF1T1RrMElESXlMall6SURNMUxqTXlPU0F5TkM0ME9UUWdNelV1T1RrMUlESTJMakl3TlVNek5pNDJOaklnTWpjdU9URTJJRE0zTGpZd05TQXlPUzR6TnpRZ016Z3VPREUzSURNd0xqVTNOME0wTUM0d016SWdNekV1TnpnZ05ERXVORGcySURNeUxqY3hNeUEwTXk0eE9EZ2dNek11TXpnelF6UTBMamc0T0NBek5DNHdORGtnTkRZdU56Z3lJRE0wTGpNNE5DQTBPQzQ0TnpJZ016UXVNemcwUXpVd0xqazJNU0F6TkM0ek9EUWdOVEl1TnpVZ016UXVNRFE1SURVMExqTTVJRE16TGpNNE0wTTFOaTR3TXpFZ016SXVOekUySURVM0xqUXlOaUF6TVM0M09DQTFPQzQxTnprZ016QXVOVGMzUXpVNUxqY3pNeUF5T1M0ek56UWdOakF1TmpFNUlESTNMamt4TmlBMk1TNHlNemtnTWpZdU1qQTFRell4TGpnMklESTBMalE1TkNBMk1pNHhOeUF5TWk0Mk1EVWdOakl1TVRjZ01qQXVOVFJETmpJdU1UWTVOaUF4T1M0NU5qZzRJRFl5TGpFME5EVWdNVGt1TXprNElEWXlMakE1TlNBeE9DNDRNamxNTmpJdU1Ea3lJREU0TGpneU0xcE5NVFV4TGpneElERTJMams0TVVNeE5UTXVOREVnTVRRdU5qQTVJREUxTnk0ME1Ua2dNVFF1TXpVNElERTFPUzR3TWpJZ01UUXVNelU0VmpFNExqa3hRekUxTmk0NU5UY2dNVGd1T1RFZ01UVTBMams0TlNBeE9DNDVPVFlnTVRVekxqYzFOeUF4T1M0NE9USkRNVFV5TGpVeU9TQXlNQzQzT1RJZ01UVXhMamt4T1NBeU1TNDVPRElnTVRVeExqa3hPU0F5TXk0ME5qUldNek11T1RsSU1UUTJMamsyTkZZeE5DNHpOVGhJTVRVeExqY3pOa3d4TlRFdU9ERWdNVFl1T1RneFdrMHhORE11TURFeElERTBMak0yTVZZek5DNHdNekZJTVRNNExqSTBUREV6T0M0eE16RWdNekV1TURRMVF6RXpOeTQwTmpZZ016SXVNRGMySURFek5pNDFOVEVnTXpJdU9USXhPU0F4TXpVdU5EY3hJRE16TGpVd05FTXhNelF1TXpjMklETTBMakE1T1NBeE16TXVNRFk0SURNMExqTTVOaUF4TXpFdU5UTTJJRE0wTGpNNU5rTXhNekF1TWlBek5DNHpPVFlnTVRJNExqazJNeUF6TkM0eE5USWdNVEkzTGpneU1pQXpNeTQyTmpoRE1USTJMamNnTXpNdU1UazJOQ0F4TWpVdU5qZzVJRE15TGpRNU5TQXhNalF1T0RVMUlETXhMall3T1VNeE1qUXVNREU0SURNd0xqY3lNaUF4TWpNdU16VTBJREk1TGpZMk1pQXhNakl1T0RjeElESTRMalF5TWtNeE1qSXVNemcwSURJM0xqRTROU0F4TWpJdU1UUXlJREkxTGpneE1TQXhNakl1TVRReUlESTBMak13TkVNeE1qSXVNVFF5SURJeUxqYzVPQ0F4TWpJdU16ZzBJREl4TGpNM09DQXhNakl1T0RjeElESXdMakV4TmtNeE1qTXVNelUzSURFNExqZzFOQ0F4TWpRdU1ERTRJREUzTGpjM01pQXhNalF1T0RVMUlERTJMamczTTBNeE1qVXVOamc0SURFMUxqazNOalFnTVRJMkxqWTVPQ0F4TlM0eU5qTTJJREV5Tnk0NE1qSWdNVFF1TnpoRE1USTRMamsyTXlBeE5DNHlPREVnTVRNd0xqSXdNeUF4TkM0d016TWdNVE14TGpVek5pQXhOQzR3TXpORE1UTXpMakEwTXlBeE5DNHdNek1nTVRNMExqTXpJREUwTGpNeE9DQXhNelV1TXprM0lERTBMamc0T0VNeE16WXVORFl5SURFMUxqUTFPRGtnTVRNM0xqTTNOU0F4Tmk0eU56Z2dNVE00TGpBMU55QXhOeTR5TnpaV01UUXVNell4U0RFME15NHdNVEZhVFRFek1pNDJNekVnTXpBdU1UTXpRekV6TkM0eU5UWWdNekF1TVRNeklERXpOUzQxTmpjZ01qa3VOVGswSURFek5pNDFOalVnTWpndU5URXlRekV6Tnk0MU5qRWdNamN1TkRNZ01UTTRMakEySURJMUxqazVNU0F4TXpndU1EWWdNalF1TVRrMlF6RXpPQzR3TmlBeU1pNDBNREVnTVRNM0xqVTJNU0F5TUM0NU9TQXhNell1TlRZMUlERTVMamc1T1VNeE16VXVOVGNnTVRndU9EQTNJREV6TkM0eU5Ua2dNVGd1TWpVNElERXpNaTQyTXpFZ01UZ3VNalU0UXpFek1TNHdNRE1nTVRndU1qVTRJREV5T1M0M01qa2dNVGd1T0RBMElERXlPQzQzTXpRZ01Ua3VPRGs1UXpFeU55NDNNemdnTWpBdU9Ua3pJREV5Tnk0eU16a2dNakl1TkRNNElERXlOeTR5TXprZ01qUXVNak16UXpFeU55NHlNemtnTWpZdU1ESTRJREV5Tnk0M016VWdNamN1TkRNeklERXlPQzQzTXpRZ01qZ3VOVEUxUXpFeU9TNDNNamtnTWprdU5UazBJREV6TVM0d01qZ2dNekF1TVRNMklERXpNaTQyTXpFZ016QXVNVE0yVmpNd0xqRXpNMXBOT1RNdU5qazRJREkzTGpnM05rTTVNeTQxTnprMUlESTRMakF3TWpVZ09UTXVORFUyTkNBeU9DNHhNalEySURrekxqTXlPU0F5T0M0eU5ESkRPVEV1T1RRM0lESTVMalV4TmlBNU1DNHhNak1nTXpBdU1UVTFJRGczTGpnMk5pQXpNQzR4TlRWRE9EWXVOVGdnTXpBdU1UVTFJRGcxTGpRd09DQXlPUzQ1TWpZZ09EUXVNelVnTWprdU5EWTBRemd6TGpNeE5UVWdNamt1TURFNE9TQTRNaTR6T0RrNElESTRMak0xTkRZZ09ERXVOak0zSURJM0xqVXhOME00TUM0NE9EUWdNall1TmpjNUlEZ3dMak13TVNBeU5TNDJOeklnTnprdU9EZzVJREkwTGpRNU5FTTNPUzQwTnpZZ01qTXVNekUxSURjNUxqSTJPU0F5TWk0d01TQTNPUzR5TmprZ01qQXVOVGM0UXpjNUxqSTJPU0F4T1M0eE5EVWdOemt1TkRjeklERTNMamcwSURjNUxqZzRPU0F4Tmk0Mk5qSkRPREF1TXpBeElERTFMalE0TkNBNE1DNDRPRFFnTVRRdU5EYzJJRGd4TGpZek55QXhNeTQyTXpsRE9ESXVNemswT1NBeE1pNDNPVGczSURnekxqTXlOek1nTVRJdU1UTTBNaUE0TkM0ek5qa2dNVEV1TmpreVF6ZzFMalF6TmlBeE1TNHlNeUE0Tmk0Mk1UUWdNVEVnT0RjdU9UQXpJREV4UXprd0xqVTNJREV4SURreUxqVTVOU0F4TVM0Mk5ESWdPVE11T1RjM0lERXlMamt5Tmt3NU55NHlOVGdnT1M0Mk5EUTVPVU01TkM0M056UWdOeTQzTVRBNU9TQTVNUzQyTXpNZ05pNDNNems1T1NBNE55NDRNamtnTmk0M016azVPVU00TlM0M01UZ2dOaTQzTXprNU9TQTRNeTQ0TVRFZ055NHdOelE1T1NBNE1pNHhNVElnTnk0M05ERTVPVU00TUM0ME1UTWdPQzQwTURjNU9TQTNPQzQ1TlRZZ09TNHpORFE1T1NBM055NDNOQ0F4TUM0MU5EVkROell1TlRJMUlERXhMamMwTnlBM05TNDFPVElnTVRNdU1UazVJRGMwTGprek5DQXhOQzQ0T1RoRE56UXVNamMzSURFMkxqVTVOeUEzTXk0NU5URWdNVGd1TkRreElEY3pMamsxTVNBeU1DNDFPREZETnpNdU9UVXhJREl5TGpZM0lEYzBMakk0TmlBeU5DNDFNelFnTnpRdU9UVXpJREkyTGpJME5VTTNOUzQyTVRrZ01qY3VPVFUzSURjMkxqVTJNaUF5T1M0ME1UUWdOemN1TnpjMElETXdMall4TjBNM09DNDVPU0F6TVM0NE1pQTRNQzQwTkRRZ016SXVOelV6SURneUxqRTBOaUF6TXk0ME1qTkRPRE11T0RRMUlETTBMakE1SURnMUxqY3pPU0F6TkM0ME1qUWdPRGN1T0RJNUlETTBMalF5TkVNNE9TNDVNVGtnTXpRdU5ESTBJRGt4TGpjd09DQXpOQzR3T1NBNU15NHpORGdnTXpNdU5ESXpRemswTGpjeE9DQXpNaTQ0TmpVZ09UVXVPVEU0SURNeUxqRXlNU0E1Tmk0NU5EZ2dNekV1TVRreFF6azNMakUwT1NBek1TNHdNRGdnT1RjdU16UTRJRE13TGpneE5TQTVOeTQxTXpjZ016QXVOakpNT1RNdU56QXhJREkzTGpnNE5VdzVNeTQyT1RnZ01qY3VPRGMyV2sweE1UQXVPREF5SURFMExqQXhOVU14TURrdU1UazVJREUwTGpBeE5TQXhNRFl1T0RNMklERTBMalEzTVNBeE1EVXVOakV4SURFMkxqRTFPRXd4TURVdU5UTTNJRFl1TURFMU9UbElNVEF3TGpjMk5WWXpNeTQ1TXpsSU1UQTFMamN5VmpJeUxqWTBNVU14TURVdU56Y3hJREl4TGpRMk1EY2dNVEEyTGpJNE9DQXlNQzR6TkRnNElERXdOeTR4TlRjZ01Ua3VOVFE0T1VNeE1EZ3VNREkzSURFNExqYzBPVEVnTVRBNUxqRTNPQ0F4T0M0ek1qWTJJREV4TUM0ek5UZ2dNVGd1TXpjMFF6RXhNeTR6T1RjZ01UZ3VNemMwSURFeE5DNHlOamdnTWpFdU1UVTVJREV4TkM0eU5qZ2dNakl1TmpReFZqTXpMamt6T1VneE1Ua3VNakl6VmpJeExqQTFPVU14TVRrdU1qSXpJREl4TGpBMU9TQXhNVGt1TVRReUlERTBMakF4TlNBeE1UQXVPREF5SURFMExqQXhOVnBOTVRjekxqYzJNeUF4TkM0ek5UaElNVFk1TGprNU9WWTRMamN4TkRrNVNERTJOUzR3TkRoV01UUXVNelU0U0RFMk1TNHlPRFJXTVRndU9URTJTREUyTlM0d05EaFdNelF1TURBelNERTJPUzQ1T1RsV01UZ3VPVEUyU0RFM015NDNOak5XTVRRdU16VTRXazB4T1RBdU56ZzNJREkxTGpJMk1rTXhPVEF1TVRJNUlESTBMalV3TVRRZ01UZzVMak13TnlBeU15NDRPVGswSURFNE9DNHpPRFFnTWpNdU5UQXhRekU0Tnk0ME9EZ2dNak11TVRFM0lERTROaTR6TXpFZ01qSXVOek15SURFNE5DNDVORGdnTWpJdU16WTBRekU0TkM0eE5qVWdNakl1TVRRek9TQXhPRE11TXprZ01qRXVPRGszT0NBeE9ESXVOakl6SURJeExqWXlOa014T0RJdU1UWXpJREl4TGpRMk1qRWdNVGd4TGpjME1TQXlNUzR5TURZMklERTRNUzR6T0RNZ01qQXVPRGMxUXpFNE1TNHlNelVnTWpBdU56UXlNU0F4T0RFdU1URTRJREl3TGpVM09Ea2dNVGd4TGpBek9TQXlNQzR6T1RZMFF6RTRNQzQ1TmpFZ01qQXVNakUwSURFNE1DNDVNaklnTWpBdU1ERTJOaUF4T0RBdU9USTNJREU1TGpneE9FTXhPREF1T1RJM0lERTVMakkzTWlBeE9ERXVNVFUySURFNExqZzBOQ0F4T0RFdU5qSTFJREU0TGpVeFF6RTRNaTR4TWpFZ01UZ3VNVFUySURFNE1pNDROaklnTVRjdU9UYzJJREU0TXk0NE1qWWdNVGN1T1RjMlF6RTROQzQzT1NBeE55NDVOellnTVRnMUxqVTROeUF4T0M0eU1Ea2dNVGcyTGpFME9DQXhPQzQyTmpoRE1UZzJMamN3TmlBeE9TNHhNalFnTVRnM0xqQXdOeUF4T1M0M01qVWdNVGczTGpBM01pQXlNQzQxVERFNE55NHdPVFFnTWpBdU56Z3lTREU1TVM0Mk16Tk1NVGt4TGpZeE55QXlNQzQwTmtNeE9URXVOVEl4SURFNExqUTROU0F4T1RBdU56Y3hJREUyTGprZ01UZzVMak00TlNBeE5TNDNOVU14T0RndU1ERXlJREUwTGpZeE1pQXhPRFl1TVRnMUlERTBMakF6TXlBeE9ETXVPVFl5SURFMExqQXpNME14T0RJdU5EYzNJREUwTGpBek15QXhPREV1TVRReElERTBMakk0TnlBeE56a3VPVGswSURFMExqYzROa014TnpndU9ETXhJREUxTGpJNU1TQXhOemN1T1RJMklERTFMams1TlNBeE56Y3VNamsySURFMkxqZzRNa014TnpZdU5qY3pJREUzTGpjME5UVWdNVGMyTGpNek9DQXhPQzQzT0RRZ01UYzJMak0wTVNBeE9TNDRORGxETVRjMkxqTTBNU0F5TVM0eE5qY2dNVGMyTGpZNU9DQXlNaTR5TkRrZ01UYzNMak01T1NBeU15NHdOalJETVRjNExqQTJJREl6TGpnME16SWdNVGM0TGpnNU9DQXlOQzQwTlRNMElERTNPUzQ0TkRJZ01qUXVPRFEwUXpFNE1DNDNORFFnTWpVdU1qRTJJREU0TVM0NU1qZ2dNalV1TmpBM0lERTRNeTR6TmpFZ01qWkRNVGcwTGpnd05pQXlOaTQwTVNBeE9EVXVPRGN5SURJMkxqYzROU0F4T0RZdU5UTWdNamN1TVRJelF6RTROeTR4SURJM0xqUXhOQ0F4T0RjdU16YzVJREkzTGpnME5TQXhPRGN1TXpjNUlESTRMalEwTkVNeE9EY3VNemM1SURJNUxqQTBNaUF4T0RjdU1USXlJREk1TGpRMk55QXhPRFl1TlRrMUlESTVMamd6T1VNeE9EWXVNRFF6SURNd0xqSXlOaUF4T0RVdU1qTTNJRE13TGpReU5TQXhPRFF1TWpBeElETXdMalF5TlVNeE9ETXVNVFkySURNd0xqUXlOU0F4T0RJdU16azBJRE13TGpFM05DQXhPREV1TnpRNUlESTVMalkzTkVNeE9ERXVNVEV6SURJNUxqRTRNU0F4T0RBdU56Y3lJREk0TGpVNE9TQXhPREF1TnpFZ01qY3VPRFkwVERFNE1DNDJPRFVnTWpjdU5UZ3lTREUzTmk0d01UTk1NVGMyTGpBeU5TQXlOeTQ1TURGRE1UYzJMakEyTnlBeU9TNHdPVFUxSURFM05pNDBOeklnTXpBdU1qUTROeUF4TnpjdU1UZzRJRE14TGpJd05rTXhOemN1T1RBM0lETXlMakU0SURFM09DNDRPVE1nTXpJdU9UVTRJREU0TUM0eE1UZ2dNek11TlRFNVF6RTRNUzR6TXpZZ016UXVNRGMzSURFNE1pNDNNeklnTXpRdU16WXlJREU0TkM0eU5qWWdNelF1TXpZeVF6RTROUzQ0TURFZ016UXVNell5SURFNE55NHhNRGtnTXpRdU1UQTRJREU0T0M0eU16Z2dNek11TmpBNVF6RTRPUzR6TnpZZ016TXVNVEEwSURFNU1DNHlOeklnTXpJdU16azBJREU1TUM0NU1ERWdNekV1TkRrMFF6RTVNUzQxTXpRZ016QXVOVGt5SURFNU1TNDROVE1nTWprdU5UVTBJREU1TVM0NE5UTWdNamd1TkRBelF6RTVNUzQ0TWpnZ01qY3VNVEVnTVRreExqUTJOaUF5Tmk0d05UTWdNVGt3TGpjM055QXlOUzR5TmpKSU1Ua3dMamM0TjFvaUlHWnBiR3c5SWlNNVFqbENPVUlpTHo0S1BIQmhkR2dnWkQwaVRUSTBNUzQ1T0RJZ01qVXVOalU0TWxZeE55NDNNVEUzU0RJeU9DNDBOREZNTWpJd0xqUTVOQ0F5TlM0Mk5UZ3lTREkwTVM0NU9ESmFJaUJtYVd4c1BTSWpPVUk1UWpsQ0lpOCtDanh3WVhSb0lHUTlJazB5TlRjdU1qTTVJRFV1T1RVd09ERklNalF3TGpJMk5Vd3lNekl1TWpVMUlERXpMamc1TnpOSU1qVTNMakl6T1ZZMUxqazFNRGd4V2lJZ1ptbHNiRDBpSXpsQ09VSTVRaUl2UGdvOGNHRjBhQ0JrUFNKTk1qRXlMall4TVNBek15NDJNRFE0VERJeE5pNDJPQ0F5T1M0MU16WXhTREl6TUM0ME1USldNemN1TkRneU4wZ3lNVEl1TmpFeFZqTXpMall3TkRoYUlpQm1hV3hzUFNJak9VSTVRamxDSWk4K0NqeHdZWFJvSUdROUlrMHlNVFV1TlRrNUlESXhMamM0TUROSU1qSTBMak0zTWt3eU16SXVNemd5SURFekxqZ3pNemRJTWpFMUxqVTVPVll5TVM0M09EQXpXaUlnWm1sc2JEMGlJemxDT1VJNVFpSXZQZ284Y0dGMGFDQmtQU0pOTWpBMklETXpMall3TkRkSU1qRXlMall4TVV3eU1qQXVORGswSURJMUxqWTFPREpJTWpBMlZqTXpMall3TkRkYUlpQm1hV3hzUFNJak9VSTVRamxDSWk4K0NqeHdZWFJvSUdROUlrMHlOREF1TWpZMUlEVXVPVFV3T0RGTU1qTTJMakU1TnlBeE1DNHdNVGswU0RJeE1DNHlOVGxXTWk0d056STRPRWd5TkRBdU1qWTFWalV1T1RVd09ERmFJaUJtYVd4c1BTSWpPVUk1UWpsQ0lpOCtDand2YzNablBnbz1gLFxuICAgICAgICAgICAgd2lkdGg6IDE3MCxcbiAgICAgICAgICAgIGhlaWdodDogMjUsXG4gICAgICAgICAgICByaWdodDogMjUsXG4gICAgICAgICAgICBib3R0b206IDUwLFxuICAgICAgICAgICAgb3BhY2l0eTogMC43XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzcGVjaWFsT3ZlcnJpZGVzID0geyAuLi5jaGFydC5jaGFydE9wdGlvbnMuc3BlY2lhbE92ZXJyaWRlcyB9O1xuICAgIGNvbnN0IG9wdGlvbnNNZXRhZGF0YSA9IHsgLi4uY2hhcnQuY2hhcnRPcHRpb25zLm9wdGlvbk1ldGFkYXRhIH07XG4gICAgaWYgKG9wdHMud2lkdGggIT0gbnVsbCAmJiBvcHRzLmhlaWdodCAhPSBudWxsKSB7XG4gICAgICBzcGVjaWFsT3ZlcnJpZGVzLm92ZXJyaWRlRGV2aWNlUGl4ZWxSYXRpbyA9IDE7XG4gICAgfVxuICAgIGNvbnN0IGNsb25lUHJveHkgPSBhd2FpdCB0aGlzLmZhY3RvcnlBcGkuY3JlYXRlKFxuICAgICAgdXNlck9wdGlvbnMsXG4gICAgICBwcm9jZXNzZWRPdmVycmlkZXMsXG4gICAgICBzcGVjaWFsT3ZlcnJpZGVzLFxuICAgICAgb3B0aW9uc01ldGFkYXRhXG4gICAgKTtcbiAgICBhd2FpdCBjbG9uZVByb3h5LnNldFN0YXRlKHN0YXRlKTtcbiAgICBjbG9uZVByb3h5LmNoYXJ0LmN0eC56b29tTWFuYWdlci51cGRhdGVab29tKFwiY2hhcnRQcm94eVwiLCBjaGFydC5jdHguem9vbU1hbmFnZXIuZ2V0Wm9vbSgpKTtcbiAgICBjaGFydC5zZXJpZXMuZm9yRWFjaCgoc2VyaWVzLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKCFzZXJpZXMudmlzaWJsZSkge1xuICAgICAgICBjbG9uZVByb3h5LmNoYXJ0LnNlcmllc1tpbmRleF0udmlzaWJsZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNsb25lUHJveHkuY2hhcnQudXBkYXRlKDAgLyogRlVMTCAqLywgeyBmb3JjZU5vZGVEYXRhUmVmcmVzaDogdHJ1ZSB9KTtcbiAgICBhd2FpdCBjbG9uZVByb3h5LndhaXRGb3JVcGRhdGUoKTtcbiAgICByZXR1cm4gY2xvbmVQcm94eTtcbiAgfVxufTtcbl9BZ0NoYXJ0SW5zdGFuY2VQcm94eS5jaGFydEluc3RhbmNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgQWN0aW9uT25TZXQoe1xuICAgIG9sZFZhbHVlKGNoYXJ0KSB7XG4gICAgICBpZiAoIWNoYXJ0LmRlc3Ryb3llZCkge1xuICAgICAgICBjaGFydC5wdWJsaWNBcGkgPSB2b2lkIDA7XG4gICAgICB9XG4gICAgICBfQWdDaGFydEluc3RhbmNlUHJveHkuY2hhcnRJbnN0YW5jZXMuZGVsZXRlKGNoYXJ0KTtcbiAgICB9LFxuICAgIG5ld1ZhbHVlKGNoYXJ0KSB7XG4gICAgICBjaGFydC5wdWJsaWNBcGkgPSB0aGlzO1xuICAgICAgX0FnQ2hhcnRJbnN0YW5jZVByb3h5LmNoYXJ0SW5zdGFuY2VzLnNldChjaGFydCwgdGhpcyk7XG4gICAgfVxuICB9KVxuXSwgX0FnQ2hhcnRJbnN0YW5jZVByb3h5LnByb3RvdHlwZSwgXCJjaGFydFwiLCAyKTtcbnZhciBBZ0NoYXJ0SW5zdGFuY2VQcm94eSA9IF9BZ0NoYXJ0SW5zdGFuY2VQcm94eTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvbG9jYWxlL2xvY2FsZS50c1xudmFyIExvY2FsZSA9IGNsYXNzIGV4dGVuZHMgQmFzZU1vZHVsZUluc3RhbmNlIHtcbiAgY29uc3RydWN0b3IoY3R4KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLmxvY2FsZVRleHQgPSB2b2lkIDA7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBPYnNlcnZlQ2hhbmdlcygodGFyZ2V0KSA9PiB7XG4gICAgdGFyZ2V0LmN0eC5sb2NhbGVNYW5hZ2VyLnNldExvY2FsZVRleHQodGFyZ2V0LmxvY2FsZVRleHQpO1xuICB9KSxcbiAgVmFsaWRhdGUoUExBSU5fT0JKRUNULCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBMb2NhbGUucHJvdG90eXBlLCBcImxvY2FsZVRleHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBPYnNlcnZlQ2hhbmdlcygodGFyZ2V0KSA9PiB7XG4gICAgdGFyZ2V0LmN0eC5sb2NhbGVNYW5hZ2VyLnNldExvY2FsZVRleHRGb3JtYXR0ZXIodGFyZ2V0LmdldExvY2FsZVRleHQpO1xuICB9KSxcbiAgVmFsaWRhdGUoRlVOQ1RJT04sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIExvY2FsZS5wcm90b3R5cGUsIFwiZ2V0TG9jYWxlVGV4dFwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvbG9jYWxlL2xvY2FsZU1vZHVsZS50c1xudmFyIExvY2FsZU1vZHVsZSA9IHtcbiAgdHlwZTogXCJyb290XCIsXG4gIG9wdGlvbnNLZXk6IFwibG9jYWxlXCIsXG4gIHBhY2thZ2VUeXBlOiBcImNvbW11bml0eVwiLFxuICBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIiwgXCJwb2xhclwiLCBcImhpZXJhcmNoeVwiLCBcInRvcG9sb2d5XCIsIFwiZmxvdy1wcm9wb3J0aW9uXCIsIFwic3RhbmRhbG9uZVwiLCBcImdhdWdlXCJdLFxuICBtb2R1bGVGYWN0b3J5OiAoY3R4KSA9PiBuZXcgTG9jYWxlKGN0eClcbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjYWxlL2xpbmVhclNjYWxlLnRzXG52YXIgTGluZWFyU2NhbGUgPSBjbGFzcyBleHRlbmRzIENvbnRpbnVvdXNTY2FsZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFswLCAxXSwgWzAsIDFdKTtcbiAgICB0aGlzLnR5cGUgPSBcIm51bWJlclwiO1xuICB9XG4gIHRvRG9tYWluKGQpIHtcbiAgICByZXR1cm4gZDtcbiAgfVxuICB0aWNrcygpIHtcbiAgICBjb25zdCBjb3VudCA9IHRoaXMudGlja0NvdW50ID8/IENvbnRpbnVvdXNTY2FsZS5kZWZhdWx0VGlja0NvdW50O1xuICAgIGlmICghdGhpcy5kb21haW4gfHwgdGhpcy5kb21haW4ubGVuZ3RoIDwgMiB8fCBjb3VudCA8IDEgfHwgIXRoaXMuZG9tYWluLmV2ZXJ5KGlzRmluaXRlKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICB0aGlzLnJlZnJlc2goKTtcbiAgICBjb25zdCBbZDAsIGQxXSA9IHRoaXMuZ2V0RG9tYWluKCk7XG4gICAgaWYgKHRoaXMuaW50ZXJ2YWwpIHtcbiAgICAgIGNvbnN0IHN0ZXAgPSBNYXRoLmFicyh0aGlzLmludGVydmFsKTtcbiAgICAgIGlmICghaXNEZW5zZUludGVydmFsKChkMSAtIGQwKSAvIHN0ZXAsIHRoaXMuZ2V0UGl4ZWxSYW5nZSgpKSkge1xuICAgICAgICByZXR1cm4gcmFuZ2UoZDAsIGQxLCBzdGVwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZVRpY2tzKGQwLCBkMSwgY291bnQsIHRoaXMubWluVGlja0NvdW50LCB0aGlzLm1heFRpY2tDb3VudCk7XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIGlmICghdGhpcy5kb21haW4gfHwgdGhpcy5kb21haW4ubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5uaWNlKSB7XG4gICAgICB0aGlzLnVwZGF0ZU5pY2VEb21haW4oKTtcbiAgICB9XG4gIH1cbiAgZ2V0VGlja1N0ZXAoc3RhcnQyLCBzdG9wKSB7XG4gICAgcmV0dXJuIHRoaXMuaW50ZXJ2YWwgPz8gdGlja1N0ZXAoc3RhcnQyLCBzdG9wLCB0aGlzLnRpY2tDb3VudCwgdGhpcy5taW5UaWNrQ291bnQsIHRoaXMubWF4VGlja0NvdW50KTtcbiAgfVxuICAvKipcbiAgICogRXh0ZW5kcyB0aGUgZG9tYWluIHNvIHRoYXQgaXQgc3RhcnRzIGFuZCBlbmRzIG9uIG5pY2Ugcm91bmQgdmFsdWVzLlxuICAgKi9cbiAgdXBkYXRlTmljZURvbWFpbigpIHtcbiAgICBjb25zdCBjb3VudCA9IHRoaXMudGlja0NvdW50O1xuICAgIGlmIChjb3VudCA8IDEpIHtcbiAgICAgIHRoaXMubmljZURvbWFpbiA9IFsuLi50aGlzLmRvbWFpbl07XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBbc3RhcnQyLCBzdG9wXSA9IHRoaXMuZG9tYWluO1xuICAgIGlmIChjb3VudCA9PT0gMSkge1xuICAgICAgW3N0YXJ0Miwgc3RvcF0gPSBuaWNlVGlja3NEb21haW4oc3RhcnQyLCBzdG9wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgcm91bmRTdGFydCA9IHN0YXJ0MiA+IHN0b3AgPyBNYXRoLmNlaWwgOiBNYXRoLmZsb29yO1xuICAgICAgY29uc3Qgcm91bmRTdG9wID0gc3RvcCA8IHN0YXJ0MiA/IE1hdGguZmxvb3IgOiBNYXRoLmNlaWw7XG4gICAgICBjb25zdCBtYXhBdHRlbXB0cyA9IDQ7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heEF0dGVtcHRzOyBpKyspIHtcbiAgICAgICAgY29uc3QgcHJldjAgPSBzdGFydDI7XG4gICAgICAgIGNvbnN0IHByZXYxID0gc3RvcDtcbiAgICAgICAgY29uc3Qgc3RlcCA9IHRoaXMuZ2V0VGlja1N0ZXAoc3RhcnQyLCBzdG9wKTtcbiAgICAgICAgY29uc3QgW2QwLCBkMV0gPSB0aGlzLmRvbWFpbjtcbiAgICAgICAgaWYgKHN0ZXAgPj0gMSkge1xuICAgICAgICAgIHN0YXJ0MiA9IHJvdW5kU3RhcnQoZDAgLyBzdGVwKSAqIHN0ZXA7XG4gICAgICAgICAgc3RvcCA9IHJvdW5kU3RvcChkMSAvIHN0ZXApICogc3RlcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBzID0gMSAvIHN0ZXA7XG4gICAgICAgICAgc3RhcnQyID0gcm91bmRTdGFydChkMCAqIHMpIC8gcztcbiAgICAgICAgICBzdG9wID0gcm91bmRTdG9wKGQxICogcykgLyBzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydDIgPT09IHByZXYwICYmIHN0b3AgPT09IHByZXYxKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5uaWNlRG9tYWluID0gW3N0YXJ0Miwgc3RvcF07XG4gIH1cbiAgdGlja0Zvcm1hdCh7IHRpY2tzOiBzcGVjaWZpZWRUaWNrcywgc3BlY2lmaWVyIH0pIHtcbiAgICByZXR1cm4gdGlja0Zvcm1hdChzcGVjaWZpZWRUaWNrcyA/PyB0aGlzLnRpY2tzKCksIHNwZWNpZmllcik7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvc2Vjb25kYXJ5QXhpc1RpY2tzLnRzXG5mdW5jdGlvbiBjYWxjdWxhdGVOaWNlU2Vjb25kYXJ5QXhpcyhkb21haW4sIHByaW1hcnlUaWNrQ291bnQsIHJldmVyc2UpIHtcbiAgbGV0IFtzdGFydDIsIHN0b3BdID0gZmluZE1pbk1heChkb21haW4pO1xuICBzdGFydDIgPSBjYWxjdWxhdGVOaWNlU3RhcnQoTWF0aC5mbG9vcihzdGFydDIpLCBzdG9wLCBwcmltYXJ5VGlja0NvdW50KTtcbiAgY29uc3Qgc3RlcCA9IGdldFRpY2tTdGVwKHN0YXJ0Miwgc3RvcCwgcHJpbWFyeVRpY2tDb3VudCk7XG4gIGNvbnN0IHNlZ21lbnRzID0gcHJpbWFyeVRpY2tDb3VudCAtIDE7XG4gIHN0b3AgPSBzdGFydDIgKyBzZWdtZW50cyAqIHN0ZXA7XG4gIGNvbnN0IGQgPSByZXZlcnNlID8gW3N0b3AsIHN0YXJ0Ml0gOiBbc3RhcnQyLCBzdG9wXTtcbiAgY29uc3QgdGlja3MgPSBnZXRUaWNrcyhzdGFydDIsIHN0ZXAsIHByaW1hcnlUaWNrQ291bnQpO1xuICByZXR1cm4geyBkb21haW46IGQsIHRpY2tzIH07XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVOaWNlU3RhcnQoYSwgYiwgY291bnQpIHtcbiAgY29uc3QgcmF3U3RlcCA9IE1hdGguYWJzKGIgLSBhKSAvIChjb3VudCAtIDEpO1xuICBjb25zdCBvcmRlciA9IE1hdGguZmxvb3IoTWF0aC5sb2cxMChyYXdTdGVwKSk7XG4gIGNvbnN0IG1hZ25pdHVkZSA9IE1hdGgucG93KDEwLCBvcmRlcik7XG4gIHJldHVybiBNYXRoLmZsb29yKGEgLyBtYWduaXR1ZGUpICogbWFnbml0dWRlO1xufVxuZnVuY3Rpb24gZ2V0VGlja3Moc3RhcnQyLCBzdGVwLCBjb3VudCkge1xuICBjb25zdCBzdGVwUG93ZXIgPSBNYXRoLmZsb29yKE1hdGgubG9nMTAoc3RlcCkpO1xuICBjb25zdCBmcmFjdGlvbkRpZ2l0cyA9IHN0ZXAgPiAwICYmIHN0ZXAgPCAxID8gTWF0aC5hYnMoc3RlcFBvd2VyKSA6IDA7XG4gIGNvbnN0IGYgPSBNYXRoLnBvdygxMCwgZnJhY3Rpb25EaWdpdHMpO1xuICBjb25zdCB0aWNrcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICBjb25zdCB0aWNrID0gc3RhcnQyICsgc3RlcCAqIGk7XG4gICAgdGlja3NbaV0gPSBNYXRoLnJvdW5kKHRpY2sgKiBmKSAvIGY7XG4gIH1cbiAgcmV0dXJuIHRpY2tzO1xufVxuZnVuY3Rpb24gZ2V0VGlja1N0ZXAoc3RhcnQyLCBzdG9wLCBjb3VudCkge1xuICBjb25zdCBzZWdtZW50cyA9IGNvdW50IC0gMTtcbiAgY29uc3QgcmF3U3RlcCA9IChzdG9wIC0gc3RhcnQyKSAvIHNlZ21lbnRzO1xuICByZXR1cm4gY2FsY3VsYXRlTmV4dE5pY2VTdGVwKHJhd1N0ZXApO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlTmV4dE5pY2VTdGVwKHJhd1N0ZXApIHtcbiAgY29uc3Qgb3JkZXIgPSBNYXRoLmZsb29yKE1hdGgubG9nMTAocmF3U3RlcCkpO1xuICBjb25zdCBtYWduaXR1ZGUgPSBNYXRoLnBvdygxMCwgb3JkZXIpO1xuICBjb25zdCBzdGVwID0gcmF3U3RlcCAvIG1hZ25pdHVkZSAqIDEwO1xuICBpZiAoc3RlcCA+IDAgJiYgc3RlcCA8PSAxKSB7XG4gICAgcmV0dXJuIG1hZ25pdHVkZSAvIDEwO1xuICB9XG4gIGlmIChzdGVwID4gMSAmJiBzdGVwIDw9IDIpIHtcbiAgICByZXR1cm4gMiAqIG1hZ25pdHVkZSAvIDEwO1xuICB9XG4gIGlmIChzdGVwID4gMSAmJiBzdGVwIDw9IDUpIHtcbiAgICByZXR1cm4gNSAqIG1hZ25pdHVkZSAvIDEwO1xuICB9XG4gIGlmIChzdGVwID4gNSAmJiBzdGVwIDw9IDEwKSB7XG4gICAgcmV0dXJuIDEwICogbWFnbml0dWRlIC8gMTA7XG4gIH1cbiAgaWYgKHN0ZXAgPiAxMCAmJiBzdGVwIDw9IDIwKSB7XG4gICAgcmV0dXJuIDIwICogbWFnbml0dWRlIC8gMTA7XG4gIH1cbiAgaWYgKHN0ZXAgPiAyMCAmJiBzdGVwIDw9IDQwKSB7XG4gICAgcmV0dXJuIDQwICogbWFnbml0dWRlIC8gMTA7XG4gIH1cbiAgaWYgKHN0ZXAgPiA0MCAmJiBzdGVwIDw9IDUwKSB7XG4gICAgcmV0dXJuIDUwICogbWFnbml0dWRlIC8gMTA7XG4gIH1cbiAgaWYgKHN0ZXAgPiA1MCAmJiBzdGVwIDw9IDEwMCkge1xuICAgIHJldHVybiAxMDAgKiBtYWduaXR1ZGUgLyAxMDtcbiAgfVxuICByZXR1cm4gc3RlcDtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvYXhpcy9udW1iZXJBeGlzLnRzXG52YXIgTnVtYmVyQXhpcyA9IGNsYXNzIGV4dGVuZHMgQ2FydGVzaWFuQXhpcyB7XG4gIGNvbnN0cnVjdG9yKG1vZHVsZUN0eCwgc2NhbGUyID0gbmV3IExpbmVhclNjYWxlKCkpIHtcbiAgICBzdXBlcihtb2R1bGVDdHgsIHNjYWxlMik7XG4gICAgdGhpcy5taW4gPSBOYU47XG4gICAgdGhpcy5tYXggPSBOYU47XG4gIH1cbiAgbm9ybWFsaXNlRGF0YURvbWFpbihkKSB7XG4gICAgY29uc3QgeyBtaW4sIG1heCB9ID0gdGhpcztcbiAgICBjb25zdCB7IGV4dGVudDogZXh0ZW50MiwgY2xpcHBlZCB9ID0gbm9ybWFsaXNlZEV4dGVudFdpdGhNZXRhZGF0YShkLCBtaW4sIG1heCk7XG4gICAgcmV0dXJuIHsgZG9tYWluOiBleHRlbnQyLCBjbGlwcGVkIH07XG4gIH1cbiAgdXBkYXRlU2Vjb25kYXJ5QXhpc1RpY2tzKHByaW1hcnlUaWNrQ291bnQpIHtcbiAgICBpZiAodGhpcy5kYXRhRG9tYWluID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFHIENoYXJ0cyAtIGRhdGFEb21haW4gbm90IGNhbGN1bGF0ZWQsIGNhbm5vdCBwZXJmb3JtIHRpY2sgY2FsY3VsYXRpb24uXCIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5kYXRhRG9tYWluLmRvbWFpbi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgeyBkb21haW4sIHRpY2tzIH0gPSBjYWxjdWxhdGVOaWNlU2Vjb25kYXJ5QXhpcyhcbiAgICAgIHRoaXMuZGF0YURvbWFpbi5kb21haW4sXG4gICAgICBwcmltYXJ5VGlja0NvdW50ID8/IDAsXG4gICAgICB0aGlzLnJldmVyc2VcbiAgICApO1xuICAgIHRoaXMuc2NhbGUubmljZSA9IGZhbHNlO1xuICAgIHRoaXMuc2NhbGUuZG9tYWluID0gZG9tYWluO1xuICAgIHRoaXMuc2NhbGUudXBkYXRlKCk7XG4gICAgcmV0dXJuIHRpY2tzO1xuICB9XG59O1xuTnVtYmVyQXhpcy5jbGFzc05hbWUgPSBcIk51bWJlckF4aXNcIjtcbk51bWJlckF4aXMudHlwZSA9IFwibnVtYmVyXCI7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShBTkQoTlVNQkVSX09SX05BTiwgTEVTU19USEFOKFwibWF4XCIpKSksXG4gIERlZmF1bHQoTmFOKVxuXSwgTnVtYmVyQXhpcy5wcm90b3R5cGUsIFwibWluXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQU5EKE5VTUJFUl9PUl9OQU4sIEdSRUFURVJfVEhBTihcIm1pblwiKSkpLFxuICBEZWZhdWx0KE5hTilcbl0sIE51bWJlckF4aXMucHJvdG90eXBlLCBcIm1heFwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvYXhpcy9sb2dBeGlzLnRzXG52YXIgTk9OX1pFUk9fTlVNQkVSID0gcHJlZGljYXRlV2l0aE1lc3NhZ2UoKHZhbHVlKSA9PiBpc051bWJlcih2YWx1ZSkgJiYgdmFsdWUgIT09IDAsIFwiYSBub24temVybyBudW1iZXJcIik7XG52YXIgTG9nQXhpcyA9IGNsYXNzIGV4dGVuZHMgTnVtYmVyQXhpcyB7XG4gIGNvbnN0cnVjdG9yKG1vZHVsZUN0eCkge1xuICAgIHN1cGVyKG1vZHVsZUN0eCwgbmV3IExvZ1NjYWxlKCkpO1xuICAgIHRoaXMubWluID0gTmFOO1xuICAgIHRoaXMubWF4ID0gTmFOO1xuICB9XG4gIG5vcm1hbGlzZURhdGFEb21haW4oZCkge1xuICAgIGNvbnN0IHsgbWluLCBtYXggfSA9IHRoaXM7XG4gICAgY29uc3QgeyBleHRlbnQ6IGV4dGVudDIsIGNsaXBwZWQgfSA9IG5vcm1hbGlzZWRFeHRlbnRXaXRoTWV0YWRhdGEoZCwgbWluLCBtYXgpO1xuICAgIGNvbnN0IGlzSW52ZXJ0ZWQgPSBleHRlbnQyWzBdID4gZXh0ZW50MlsxXTtcbiAgICBjb25zdCBjcm9zc2VzWmVybyA9IGV4dGVudDJbMF0gPCAwICYmIGV4dGVudDJbMV0gPiAwO1xuICAgIGNvbnN0IGhhc1plcm9FeHRlbnQgPSBleHRlbnQyWzBdID09PSAwICYmIGV4dGVudDJbMV0gPT09IDA7XG4gICAgY29uc3QgaW52YWxpZERvbWFpbiA9IGlzSW52ZXJ0ZWQgfHwgY3Jvc3Nlc1plcm8gfHwgaGFzWmVyb0V4dGVudDtcbiAgICBpZiAoaW52YWxpZERvbWFpbikge1xuICAgICAgaWYgKGNyb3NzZXNaZXJvKSB7XG4gICAgICAgIExvZ2dlci53YXJuKFxuICAgICAgICAgIGB0aGUgZGF0YSBkb21haW4gY3Jvc3NlcyB6ZXJvLCB0aGUgY2hhcnQgZGF0YSBjYW5ub3QgYmUgcmVuZGVyZWQuIFNlZSBsb2cgYXhpcyBkb2N1bWVudGF0aW9uIGZvciBtb3JlIGluZm9ybWF0aW9uLmBcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoaGFzWmVyb0V4dGVudCkge1xuICAgICAgICBMb2dnZXIud2FybihgdGhlIGRhdGEgZG9tYWluIGhhcyAwIGV4dGVudCwgbm8gZGF0YSBpcyByZW5kZXJlZC5gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGV4dGVudDJbMF0gPT09IDApIHtcbiAgICAgIGV4dGVudDJbMF0gPSAxO1xuICAgIH1cbiAgICBpZiAoZXh0ZW50MlsxXSA9PT0gMCkge1xuICAgICAgZXh0ZW50MlsxXSA9IC0xO1xuICAgIH1cbiAgICByZXR1cm4geyBkb21haW46IGV4dGVudDIsIGNsaXBwZWQgfTtcbiAgfVxuICBzZXQgYmFzZSh2YWx1ZSkge1xuICAgIHRoaXMuc2NhbGUuYmFzZSA9IHZhbHVlO1xuICB9XG4gIGdldCBiYXNlKCkge1xuICAgIHJldHVybiB0aGlzLnNjYWxlLmJhc2U7XG4gIH1cbn07XG5Mb2dBeGlzLmNsYXNzTmFtZSA9IFwiTG9nQXhpc1wiO1xuTG9nQXhpcy50eXBlID0gXCJsb2dcIjtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEFORChOVU1CRVJfT1JfTkFOLCBOT05fWkVST19OVU1CRVIsIExFU1NfVEhBTihcIm1heFwiKSkpLFxuICBEZWZhdWx0KE5hTilcbl0sIExvZ0F4aXMucHJvdG90eXBlLCBcIm1pblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEFORChOVU1CRVJfT1JfTkFOLCBOT05fWkVST19OVU1CRVIsIEdSRUFURVJfVEhBTihcIm1pblwiKSkpLFxuICBEZWZhdWx0KE5hTilcbl0sIExvZ0F4aXMucHJvdG90eXBlLCBcIm1heFwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvYXhpcy90aW1lQXhpcy50c1xudmFyIFRpbWVBeGlzID0gY2xhc3MgZXh0ZW5kcyBDYXJ0ZXNpYW5BeGlzIHtcbiAgY29uc3RydWN0b3IobW9kdWxlQ3R4KSB7XG4gICAgc3VwZXIobW9kdWxlQ3R4LCBuZXcgVGltZVNjYWxlKCkpO1xuICAgIHRoaXMubWluID0gdm9pZCAwO1xuICAgIHRoaXMubWF4ID0gdm9pZCAwO1xuICB9XG4gIG5vcm1hbGlzZURhdGFEb21haW4oZCkge1xuICAgIGxldCB7IG1pbiwgbWF4IH0gPSB0aGlzO1xuICAgIGxldCBjbGlwcGVkID0gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBtaW4gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIG1pbiA9IG5ldyBEYXRlKG1pbik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbWF4ID09PSBcIm51bWJlclwiKSB7XG4gICAgICBtYXggPSBuZXcgRGF0ZShtYXgpO1xuICAgIH1cbiAgICBpZiAoZC5sZW5ndGggPiAyKSB7XG4gICAgICBkID0gZXh0ZW50KGQpPy5tYXAoKHgpID0+IG5ldyBEYXRlKHgpKSA/PyBbXTtcbiAgICB9XG4gICAgaWYgKG1pbiBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIGNsaXBwZWQgfHwgKGNsaXBwZWQgPSBtaW4gPiBkWzBdKTtcbiAgICAgIGQgPSBbbWluLCBkWzFdXTtcbiAgICB9XG4gICAgaWYgKG1heCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIGNsaXBwZWQgfHwgKGNsaXBwZWQgPSBtYXggPCBkWzFdKTtcbiAgICAgIGQgPSBbZFswXSwgbWF4XTtcbiAgICB9XG4gICAgaWYgKGRbMF0gPiBkWzFdKSB7XG4gICAgICBkID0gW107XG4gICAgfVxuICAgIHJldHVybiB7IGRvbWFpbjogZCwgY2xpcHBlZCB9O1xuICB9XG4gIG9uRm9ybWF0Q2hhbmdlKHRpY2tzLCBmcmFjdGlvbkRpZ2l0cywgZG9tYWluLCBmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0KSB7XG4gICAgICBzdXBlci5vbkZvcm1hdENoYW5nZSh0aWNrcywgZnJhY3Rpb25EaWdpdHMsIGRvbWFpbiwgZm9ybWF0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sYWJlbEZvcm1hdHRlciA9IHRoaXMuc2NhbGUudGlja0Zvcm1hdCh7IHRpY2tzLCBkb21haW4gfSk7XG4gICAgICB0aGlzLmRhdHVtRm9ybWF0dGVyID0gdGhpcy5zY2FsZS50aWNrRm9ybWF0KHsgdGlja3MsIGRvbWFpbiwgZm9ybWF0T2Zmc2V0OiAxIH0pO1xuICAgIH1cbiAgfVxufTtcblRpbWVBeGlzLmNsYXNzTmFtZSA9IFwiVGltZUF4aXNcIjtcblRpbWVBeGlzLnR5cGUgPSBcInRpbWVcIjtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEFORChEQVRFX09SX0RBVEVUSU1FX01TLCBMRVNTX1RIQU4oXCJtYXhcIikpLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBUaW1lQXhpcy5wcm90b3R5cGUsIFwibWluXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQU5EKERBVEVfT1JfREFURVRJTUVfTVMsIEdSRUFURVJfVEhBTihcIm1pblwiKSksIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFRpbWVBeGlzLnByb3RvdHlwZSwgXCJtYXhcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL3V0aWwvY29ybmVyLnRzXG52YXIgZHJhd0Nvcm5lciA9IChwYXRoLCB7IHgwLCB5MCwgeDEsIHkxLCBjeCwgY3kgfSwgY29ybmVyUmFkaXVzLCBtb3ZlKSA9PiB7XG4gIGlmIChtb3ZlKSB7XG4gICAgcGF0aC5tb3ZlVG8oeDAsIHkwKTtcbiAgfVxuICBpZiAoeDAgIT09IHgxIHx8IHkwICE9PSB5MSkge1xuICAgIGNvbnN0IHIwID0gTWF0aC5hdGFuMih5MCAtIGN5LCB4MCAtIGN4KTtcbiAgICBjb25zdCByMSA9IE1hdGguYXRhbjIoeTEgLSBjeSwgeDEgLSBjeCk7XG4gICAgcGF0aC5hcmMoY3gsIGN5LCBjb3JuZXJSYWRpdXMsIHIwLCByMSk7XG4gIH0gZWxzZSB7XG4gICAgcGF0aC5saW5lVG8oeDAsIHkwKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvc2hhcGUvcmVjdC50c1xudmFyIGVwc2lsb24gPSAxZS02O1xudmFyIGNvcm5lckVkZ2VzID0gKGxlYWRpbmdFZGdlLCB0cmFpbGluZ0VkZ2UsIGxlYWRpbmdJbnNldCwgdHJhaWxpbmdJbnNldCwgY29ybmVyUmFkaXVzKSA9PiB7XG4gIGxldCBsZWFkaW5nQ2xpcHBlZCA9IGZhbHNlO1xuICBsZXQgdHJhaWxpbmdDbGlwcGVkID0gZmFsc2U7XG4gIGxldCBsZWFkaW5nMCA9IHRyYWlsaW5nSW5zZXQgLSBNYXRoLnNxcnQoTWF0aC5tYXgoY29ybmVyUmFkaXVzICoqIDIgLSBsZWFkaW5nSW5zZXQgKiogMiwgMCkpO1xuICBsZXQgbGVhZGluZzEgPSAwO1xuICBsZXQgdHJhaWxpbmcwID0gMDtcbiAgbGV0IHRyYWlsaW5nMSA9IGxlYWRpbmdJbnNldCAtIE1hdGguc3FydChNYXRoLm1heChjb3JuZXJSYWRpdXMgKiogMiAtIHRyYWlsaW5nSW5zZXQgKiogMiwgMCkpO1xuICBpZiAobGVhZGluZzAgPiBsZWFkaW5nRWRnZSkge1xuICAgIGxlYWRpbmdDbGlwcGVkID0gdHJ1ZTtcbiAgICBsZWFkaW5nMCA9IGxlYWRpbmdFZGdlO1xuICAgIGxlYWRpbmcxID0gbGVhZGluZ0luc2V0IC0gTWF0aC5zcXJ0KE1hdGgubWF4KGNvcm5lclJhZGl1cyAqKiAyIC0gKHRyYWlsaW5nSW5zZXQgLSBsZWFkaW5nRWRnZSkgKiogMikpO1xuICB9IGVsc2UgaWYgKGxlYWRpbmcwIDwgZXBzaWxvbikge1xuICAgIGxlYWRpbmcwID0gMDtcbiAgfVxuICBpZiAodHJhaWxpbmcxID4gdHJhaWxpbmdFZGdlKSB7XG4gICAgdHJhaWxpbmdDbGlwcGVkID0gdHJ1ZTtcbiAgICB0cmFpbGluZzAgPSB0cmFpbGluZ0luc2V0IC0gTWF0aC5zcXJ0KE1hdGgubWF4KGNvcm5lclJhZGl1cyAqKiAyIC0gKGxlYWRpbmdJbnNldCAtIHRyYWlsaW5nRWRnZSkgKiogMikpO1xuICAgIHRyYWlsaW5nMSA9IHRyYWlsaW5nRWRnZTtcbiAgfSBlbHNlIGlmICh0cmFpbGluZzEgPCBlcHNpbG9uKSB7XG4gICAgdHJhaWxpbmcxID0gMDtcbiAgfVxuICByZXR1cm4geyBsZWFkaW5nMCwgbGVhZGluZzEsIHRyYWlsaW5nMCwgdHJhaWxpbmcxLCBsZWFkaW5nQ2xpcHBlZCwgdHJhaWxpbmdDbGlwcGVkIH07XG59O1xudmFyIGluc2V0Q29ybmVyUmFkaXVzUmVjdCA9IChwYXRoLCB4LCB5LCB3aWR0aDIsIGhlaWdodDIsIGNvcm5lclJhZGlpLCBjbGlwQkJveCkgPT4ge1xuICBsZXQge1xuICAgIHRvcExlZnQ6IHRvcExlZnRDb3JuZXJSYWRpdXMsXG4gICAgdG9wUmlnaHQ6IHRvcFJpZ2h0Q29ybmVyUmFkaXVzLFxuICAgIGJvdHRvbVJpZ2h0OiBib3R0b21SaWdodENvcm5lclJhZGl1cyxcbiAgICBib3R0b21MZWZ0OiBib3R0b21MZWZ0Q29ybmVyUmFkaXVzXG4gIH0gPSBjb3JuZXJSYWRpaTtcbiAgY29uc3QgbWF4VmVydGljYWxDb3JuZXJSYWRpdXMgPSBNYXRoLm1heChcbiAgICB0b3BMZWZ0Q29ybmVyUmFkaXVzICsgYm90dG9tTGVmdENvcm5lclJhZGl1cyxcbiAgICB0b3BSaWdodENvcm5lclJhZGl1cyArIGJvdHRvbVJpZ2h0Q29ybmVyUmFkaXVzXG4gICk7XG4gIGNvbnN0IG1heEhvcml6b250YWxDb3JuZXJSYWRpdXMgPSBNYXRoLm1heChcbiAgICB0b3BMZWZ0Q29ybmVyUmFkaXVzICsgdG9wUmlnaHRDb3JuZXJSYWRpdXMsXG4gICAgYm90dG9tTGVmdENvcm5lclJhZGl1cyArIGJvdHRvbVJpZ2h0Q29ybmVyUmFkaXVzXG4gICk7XG4gIGlmIChtYXhWZXJ0aWNhbENvcm5lclJhZGl1cyA8PSAwICYmIG1heEhvcml6b250YWxDb3JuZXJSYWRpdXMgPD0gMCkge1xuICAgIGlmIChjbGlwQkJveCA9PSBudWxsKSB7XG4gICAgICBwYXRoLnJlY3QoeCwgeSwgd2lkdGgyLCBoZWlnaHQyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aC5yZWN0KGNsaXBCQm94LngsIGNsaXBCQm94LnksIGNsaXBCQm94LndpZHRoLCBjbGlwQkJveC5oZWlnaHQpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAoY2xpcEJCb3ggPT0gbnVsbCAmJiB0b3BMZWZ0Q29ybmVyUmFkaXVzID09PSB0b3BSaWdodENvcm5lclJhZGl1cyAmJiB0b3BMZWZ0Q29ybmVyUmFkaXVzID09PSBib3R0b21SaWdodENvcm5lclJhZGl1cyAmJiB0b3BMZWZ0Q29ybmVyUmFkaXVzID09PSBib3R0b21MZWZ0Q29ybmVyUmFkaXVzKSB7XG4gICAgcGF0aC5yb3VuZFJlY3QoeCwgeSwgd2lkdGgyLCBoZWlnaHQyLCB0b3BMZWZ0Q29ybmVyUmFkaXVzKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHdpZHRoMiA8IDApIHtcbiAgICB4ICs9IHdpZHRoMjtcbiAgICB3aWR0aDIgPSBNYXRoLmFicyh3aWR0aDIpO1xuICB9XG4gIGlmIChoZWlnaHQyIDwgMCkge1xuICAgIHkgKz0gaGVpZ2h0MjtcbiAgICBoZWlnaHQyID0gTWF0aC5hYnMoaGVpZ2h0Mik7XG4gIH1cbiAgaWYgKHdpZHRoMiA8PSAwIHx8IGhlaWdodDIgPD0gMClcbiAgICByZXR1cm47XG4gIGlmIChjbGlwQkJveCA9PSBudWxsKSB7XG4gICAgY2xpcEJCb3ggPSBuZXcgQkJveCh4LCB5LCB3aWR0aDIsIGhlaWdodDIpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHgwID0gTWF0aC5tYXgoeCwgY2xpcEJCb3gueCk7XG4gICAgY29uc3QgeDEgPSBNYXRoLm1pbih4ICsgd2lkdGgyLCBjbGlwQkJveC54ICsgY2xpcEJCb3gud2lkdGgpO1xuICAgIGNvbnN0IHkwID0gTWF0aC5tYXgoeSwgY2xpcEJCb3gueSk7XG4gICAgY29uc3QgeTEgPSBNYXRoLm1pbih5ICsgaGVpZ2h0MiwgY2xpcEJCb3gueSArIGNsaXBCQm94LmhlaWdodCk7XG4gICAgY2xpcEJCb3ggPSBuZXcgQkJveCh4MCwgeTAsIHgxIC0geDAsIHkxIC0geTApO1xuICB9XG4gIGNvbnN0IGJvcmRlclNjYWxlID0gTWF0aC5tYXgobWF4VmVydGljYWxDb3JuZXJSYWRpdXMgLyBoZWlnaHQyLCBtYXhIb3Jpem9udGFsQ29ybmVyUmFkaXVzIC8gd2lkdGgyLCAxKTtcbiAgaWYgKGJvcmRlclNjYWxlID4gMSkge1xuICAgIHRvcExlZnRDb3JuZXJSYWRpdXMgLz0gYm9yZGVyU2NhbGU7XG4gICAgdG9wUmlnaHRDb3JuZXJSYWRpdXMgLz0gYm9yZGVyU2NhbGU7XG4gICAgYm90dG9tUmlnaHRDb3JuZXJSYWRpdXMgLz0gYm9yZGVyU2NhbGU7XG4gICAgYm90dG9tTGVmdENvcm5lclJhZGl1cyAvPSBib3JkZXJTY2FsZTtcbiAgfVxuICBsZXQgZHJhd1RvcExlZnRDb3JuZXIgPSB0cnVlO1xuICBsZXQgZHJhd1RvcFJpZ2h0Q29ybmVyID0gdHJ1ZTtcbiAgbGV0IGRyYXdCb3R0b21SaWdodENvcm5lciA9IHRydWU7XG4gIGxldCBkcmF3Qm90dG9tTGVmdENvcm5lciA9IHRydWU7XG4gIGxldCB0b3BMZWZ0Q29ybmVyO1xuICBsZXQgdG9wUmlnaHRDb3JuZXI7XG4gIGxldCBib3R0b21SaWdodENvcm5lcjtcbiAgbGV0IGJvdHRvbUxlZnRDb3JuZXI7XG4gIGlmIChkcmF3VG9wTGVmdENvcm5lcikge1xuICAgIGNvbnN0IG5vZGVzID0gY29ybmVyRWRnZXMoXG4gICAgICBjbGlwQkJveC5oZWlnaHQsXG4gICAgICBjbGlwQkJveC53aWR0aCxcbiAgICAgIE1hdGgubWF4KHggKyB0b3BMZWZ0Q29ybmVyUmFkaXVzIC0gY2xpcEJCb3gueCwgMCksXG4gICAgICBNYXRoLm1heCh5ICsgdG9wTGVmdENvcm5lclJhZGl1cyAtIGNsaXBCQm94LnksIDApLFxuICAgICAgdG9wTGVmdENvcm5lclJhZGl1c1xuICAgICk7XG4gICAgaWYgKG5vZGVzLmxlYWRpbmdDbGlwcGVkKVxuICAgICAgZHJhd0JvdHRvbUxlZnRDb3JuZXIgPSBmYWxzZTtcbiAgICBpZiAobm9kZXMudHJhaWxpbmdDbGlwcGVkKVxuICAgICAgZHJhd1RvcFJpZ2h0Q29ybmVyID0gZmFsc2U7XG4gICAgY29uc3QgeDAgPSBNYXRoLm1heChjbGlwQkJveC54ICsgbm9kZXMubGVhZGluZzEsIGNsaXBCQm94LngpO1xuICAgIGNvbnN0IHkwID0gTWF0aC5tYXgoY2xpcEJCb3gueSArIG5vZGVzLmxlYWRpbmcwLCBjbGlwQkJveC55KTtcbiAgICBjb25zdCB4MSA9IE1hdGgubWF4KGNsaXBCQm94LnggKyBub2Rlcy50cmFpbGluZzEsIGNsaXBCQm94LngpO1xuICAgIGNvbnN0IHkxID0gTWF0aC5tYXgoY2xpcEJCb3gueSArIG5vZGVzLnRyYWlsaW5nMCwgY2xpcEJCb3gueSk7XG4gICAgY29uc3QgY3ggPSB4ICsgdG9wTGVmdENvcm5lclJhZGl1cztcbiAgICBjb25zdCBjeSA9IHkgKyB0b3BMZWZ0Q29ybmVyUmFkaXVzO1xuICAgIHRvcExlZnRDb3JuZXIgPSB7IHgwLCB5MCwgeDEsIHkxLCBjeCwgY3kgfTtcbiAgfVxuICBpZiAoZHJhd1RvcFJpZ2h0Q29ybmVyKSB7XG4gICAgY29uc3Qgbm9kZXMgPSBjb3JuZXJFZGdlcyhcbiAgICAgIGNsaXBCQm94LndpZHRoLFxuICAgICAgY2xpcEJCb3guaGVpZ2h0LFxuICAgICAgTWF0aC5tYXgoeSArIHRvcFJpZ2h0Q29ybmVyUmFkaXVzIC0gY2xpcEJCb3gueSwgMCksXG4gICAgICBNYXRoLm1heChjbGlwQkJveC54ICsgY2xpcEJCb3gud2lkdGggLSAoeCArIHdpZHRoMiAtIHRvcFJpZ2h0Q29ybmVyUmFkaXVzKSwgMCksXG4gICAgICB0b3BSaWdodENvcm5lclJhZGl1c1xuICAgICk7XG4gICAgaWYgKG5vZGVzLmxlYWRpbmdDbGlwcGVkKVxuICAgICAgZHJhd1RvcExlZnRDb3JuZXIgPSBmYWxzZTtcbiAgICBpZiAobm9kZXMudHJhaWxpbmdDbGlwcGVkKVxuICAgICAgZHJhd0JvdHRvbVJpZ2h0Q29ybmVyID0gZmFsc2U7XG4gICAgY29uc3QgeDAgPSBNYXRoLm1pbihjbGlwQkJveC54ICsgY2xpcEJCb3gud2lkdGggLSBub2Rlcy5sZWFkaW5nMCwgY2xpcEJCb3gueCArIGNsaXBCQm94LndpZHRoKTtcbiAgICBjb25zdCB5MCA9IE1hdGgubWF4KGNsaXBCQm94LnkgKyBub2Rlcy5sZWFkaW5nMSwgY2xpcEJCb3gueSk7XG4gICAgY29uc3QgeDEgPSBNYXRoLm1pbihjbGlwQkJveC54ICsgY2xpcEJCb3gud2lkdGggLSBub2Rlcy50cmFpbGluZzAsIGNsaXBCQm94LnggKyBjbGlwQkJveC53aWR0aCk7XG4gICAgY29uc3QgeTEgPSBNYXRoLm1heChjbGlwQkJveC55ICsgbm9kZXMudHJhaWxpbmcxLCBjbGlwQkJveC55KTtcbiAgICBjb25zdCBjeCA9IHggKyB3aWR0aDIgLSB0b3BSaWdodENvcm5lclJhZGl1cztcbiAgICBjb25zdCBjeSA9IHkgKyB0b3BSaWdodENvcm5lclJhZGl1cztcbiAgICB0b3BSaWdodENvcm5lciA9IHsgeDAsIHkwLCB4MSwgeTEsIGN4LCBjeSB9O1xuICB9XG4gIGlmIChkcmF3Qm90dG9tUmlnaHRDb3JuZXIpIHtcbiAgICBjb25zdCBub2RlcyA9IGNvcm5lckVkZ2VzKFxuICAgICAgY2xpcEJCb3guaGVpZ2h0LFxuICAgICAgY2xpcEJCb3gud2lkdGgsXG4gICAgICBNYXRoLm1heChjbGlwQkJveC54ICsgY2xpcEJCb3gud2lkdGggLSAoeCArIHdpZHRoMiAtIGJvdHRvbVJpZ2h0Q29ybmVyUmFkaXVzKSwgMCksXG4gICAgICBNYXRoLm1heChjbGlwQkJveC55ICsgY2xpcEJCb3guaGVpZ2h0IC0gKHkgKyBoZWlnaHQyIC0gYm90dG9tUmlnaHRDb3JuZXJSYWRpdXMpLCAwKSxcbiAgICAgIGJvdHRvbVJpZ2h0Q29ybmVyUmFkaXVzXG4gICAgKTtcbiAgICBpZiAobm9kZXMubGVhZGluZ0NsaXBwZWQpXG4gICAgICBkcmF3VG9wUmlnaHRDb3JuZXIgPSBmYWxzZTtcbiAgICBpZiAobm9kZXMudHJhaWxpbmdDbGlwcGVkKVxuICAgICAgZHJhd0JvdHRvbUxlZnRDb3JuZXIgPSBmYWxzZTtcbiAgICBjb25zdCB4MCA9IE1hdGgubWluKGNsaXBCQm94LnggKyBjbGlwQkJveC53aWR0aCAtIG5vZGVzLmxlYWRpbmcxLCBjbGlwQkJveC54ICsgY2xpcEJCb3gud2lkdGgpO1xuICAgIGNvbnN0IHkwID0gTWF0aC5taW4oY2xpcEJCb3gueSArIGNsaXBCQm94LmhlaWdodCAtIG5vZGVzLmxlYWRpbmcwLCBjbGlwQkJveC55ICsgY2xpcEJCb3guaGVpZ2h0KTtcbiAgICBjb25zdCB4MSA9IE1hdGgubWluKGNsaXBCQm94LnggKyBjbGlwQkJveC53aWR0aCAtIG5vZGVzLnRyYWlsaW5nMSwgY2xpcEJCb3gueCArIGNsaXBCQm94LndpZHRoKTtcbiAgICBjb25zdCB5MSA9IE1hdGgubWluKGNsaXBCQm94LnkgKyBjbGlwQkJveC5oZWlnaHQgLSBub2Rlcy50cmFpbGluZzAsIGNsaXBCQm94LnkgKyBjbGlwQkJveC5oZWlnaHQpO1xuICAgIGNvbnN0IGN4ID0geCArIHdpZHRoMiAtIGJvdHRvbVJpZ2h0Q29ybmVyUmFkaXVzO1xuICAgIGNvbnN0IGN5ID0geSArIGhlaWdodDIgLSBib3R0b21SaWdodENvcm5lclJhZGl1cztcbiAgICBib3R0b21SaWdodENvcm5lciA9IHsgeDAsIHkwLCB4MSwgeTEsIGN4LCBjeSB9O1xuICB9XG4gIGlmIChkcmF3Qm90dG9tTGVmdENvcm5lcikge1xuICAgIGNvbnN0IG5vZGVzID0gY29ybmVyRWRnZXMoXG4gICAgICBjbGlwQkJveC53aWR0aCxcbiAgICAgIGNsaXBCQm94LmhlaWdodCxcbiAgICAgIE1hdGgubWF4KGNsaXBCQm94LnkgKyBjbGlwQkJveC5oZWlnaHQgLSAoeSArIGhlaWdodDIgLSBib3R0b21MZWZ0Q29ybmVyUmFkaXVzKSwgMCksXG4gICAgICBNYXRoLm1heCh4ICsgYm90dG9tTGVmdENvcm5lclJhZGl1cyAtIGNsaXBCQm94LngsIDApLFxuICAgICAgYm90dG9tTGVmdENvcm5lclJhZGl1c1xuICAgICk7XG4gICAgaWYgKG5vZGVzLmxlYWRpbmdDbGlwcGVkKVxuICAgICAgZHJhd0JvdHRvbVJpZ2h0Q29ybmVyID0gZmFsc2U7XG4gICAgaWYgKG5vZGVzLnRyYWlsaW5nQ2xpcHBlZClcbiAgICAgIGRyYXdUb3BMZWZ0Q29ybmVyID0gZmFsc2U7XG4gICAgY29uc3QgeDAgPSBNYXRoLm1heChjbGlwQkJveC54ICsgbm9kZXMubGVhZGluZzAsIGNsaXBCQm94LngpO1xuICAgIGNvbnN0IHkwID0gTWF0aC5taW4oY2xpcEJCb3gueSArIGNsaXBCQm94LmhlaWdodCAtIG5vZGVzLmxlYWRpbmcxLCBjbGlwQkJveC55ICsgY2xpcEJCb3guaGVpZ2h0KTtcbiAgICBjb25zdCB4MSA9IE1hdGgubWF4KGNsaXBCQm94LnggKyBub2Rlcy50cmFpbGluZzAsIGNsaXBCQm94LngpO1xuICAgIGNvbnN0IHkxID0gTWF0aC5taW4oY2xpcEJCb3gueSArIGNsaXBCQm94LmhlaWdodCAtIG5vZGVzLnRyYWlsaW5nMSwgY2xpcEJCb3gueSArIGNsaXBCQm94LmhlaWdodCk7XG4gICAgY29uc3QgY3ggPSB4ICsgYm90dG9tTGVmdENvcm5lclJhZGl1cztcbiAgICBjb25zdCBjeSA9IHkgKyBoZWlnaHQyIC0gYm90dG9tTGVmdENvcm5lclJhZGl1cztcbiAgICBib3R0b21MZWZ0Q29ybmVyID0geyB4MCwgeTAsIHgxLCB5MSwgY3gsIGN5IH07XG4gIH1cbiAgbGV0IGRpZE1vdmUgPSBmYWxzZTtcbiAgaWYgKGRyYXdUb3BMZWZ0Q29ybmVyICYmIHRvcExlZnRDb3JuZXIgIT0gbnVsbCkge1xuICAgIGRyYXdDb3JuZXIocGF0aCwgdG9wTGVmdENvcm5lciwgdG9wTGVmdENvcm5lclJhZGl1cywgIWRpZE1vdmUpO1xuICAgIGRpZE1vdmUgfHwgKGRpZE1vdmUgPSB0cnVlKTtcbiAgfVxuICBpZiAoZHJhd1RvcFJpZ2h0Q29ybmVyICYmIHRvcFJpZ2h0Q29ybmVyICE9IG51bGwpIHtcbiAgICBkcmF3Q29ybmVyKHBhdGgsIHRvcFJpZ2h0Q29ybmVyLCB0b3BSaWdodENvcm5lclJhZGl1cywgIWRpZE1vdmUpO1xuICAgIGRpZE1vdmUgfHwgKGRpZE1vdmUgPSB0cnVlKTtcbiAgfVxuICBpZiAoZHJhd0JvdHRvbVJpZ2h0Q29ybmVyICYmIGJvdHRvbVJpZ2h0Q29ybmVyICE9IG51bGwpIHtcbiAgICBkcmF3Q29ybmVyKHBhdGgsIGJvdHRvbVJpZ2h0Q29ybmVyLCBib3R0b21SaWdodENvcm5lclJhZGl1cywgIWRpZE1vdmUpO1xuICAgIGRpZE1vdmUgfHwgKGRpZE1vdmUgPSB0cnVlKTtcbiAgfVxuICBpZiAoZHJhd0JvdHRvbUxlZnRDb3JuZXIgJiYgYm90dG9tTGVmdENvcm5lciAhPSBudWxsKSB7XG4gICAgZHJhd0Nvcm5lcihwYXRoLCBib3R0b21MZWZ0Q29ybmVyLCBib3R0b21MZWZ0Q29ybmVyUmFkaXVzLCAhZGlkTW92ZSk7XG4gICAgZGlkTW92ZSB8fCAoZGlkTW92ZSA9IHRydWUpO1xuICB9XG4gIHBhdGguY2xvc2VQYXRoKCk7XG59O1xudmFyIFJlY3QgPSBjbGFzcyBleHRlbmRzIFBhdGgge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuYm9yZGVyUGF0aCA9IG5ldyBFeHRlbmRlZFBhdGgyRCgpO1xuICAgIHRoaXMueCA9IDA7XG4gICAgdGhpcy55ID0gMDtcbiAgICB0aGlzLndpZHRoID0gMTA7XG4gICAgdGhpcy5oZWlnaHQgPSAxMDtcbiAgICB0aGlzLnRvcExlZnRDb3JuZXJSYWRpdXMgPSAwO1xuICAgIHRoaXMudG9wUmlnaHRDb3JuZXJSYWRpdXMgPSAwO1xuICAgIHRoaXMuYm90dG9tUmlnaHRDb3JuZXJSYWRpdXMgPSAwO1xuICAgIHRoaXMuYm90dG9tTGVmdENvcm5lclJhZGl1cyA9IDA7XG4gICAgdGhpcy5jbGlwQkJveCA9IHZvaWQgMDtcbiAgICB0aGlzLmNyaXNwID0gZmFsc2U7XG4gICAgdGhpcy5sYXN0VXBkYXRlUGF0aFN0cm9rZVdpZHRoID0gU2hhcGUuZGVmYXVsdFN0eWxlcy5zdHJva2VXaWR0aDtcbiAgICB0aGlzLmVmZmVjdGl2ZVN0cm9rZVdpZHRoID0gU2hhcGUuZGVmYXVsdFN0eWxlcy5zdHJva2VXaWR0aDtcbiAgICB0aGlzLmhpdHRlc3RlciA9IHN1cGVyLmlzUG9pbnRJblBhdGg7XG4gICAgdGhpcy5kaXN0YW5jZUNhbGN1bGF0b3IgPSBzdXBlci5kaXN0YW5jZVNxdWFyZWRUcmFuc2Zvcm1lZFBvaW50O1xuICAgIC8qKlxuICAgICAqIFdoZW4gdGhlIHJlY3RhbmdsZSdzIHdpZHRoIG9yIGhlaWdodCBpcyBsZXNzIHRoYW4gYSBwaXhlbFxuICAgICAqIGFuZCBjcmlzcCBtb2RlIGlzIG9uLCB0aGUgcmVjdGFuZ2xlIHdpbGwgc3RpbGwgZml0IGludG8gdGhlIHBpeGVsLFxuICAgICAqIGJ1dCB3aWxsIGJlIGxlc3Mgb3BhcXVlIHRvIG1ha2UgYW4gZWZmZWN0IG9mIGhvbGRpbmcgbGVzcyBzcGFjZS5cbiAgICAgKi9cbiAgICB0aGlzLm1pY3JvUGl4ZWxFZmZlY3RPcGFjaXR5ID0gMTtcbiAgfVxuICBzZXQgY29ybmVyUmFkaXVzKGNvcm5lclJhZGl1cykge1xuICAgIHRoaXMudG9wTGVmdENvcm5lclJhZGl1cyA9IGNvcm5lclJhZGl1cztcbiAgICB0aGlzLnRvcFJpZ2h0Q29ybmVyUmFkaXVzID0gY29ybmVyUmFkaXVzO1xuICAgIHRoaXMuYm90dG9tUmlnaHRDb3JuZXJSYWRpdXMgPSBjb3JuZXJSYWRpdXM7XG4gICAgdGhpcy5ib3R0b21MZWZ0Q29ybmVyUmFkaXVzID0gY29ybmVyUmFkaXVzO1xuICB9XG4gIGlzRGlydHlQYXRoKCkge1xuICAgIHJldHVybiB0aGlzLmxhc3RVcGRhdGVQYXRoU3Ryb2tlV2lkdGggIT09IHRoaXMuc3Ryb2tlV2lkdGggfHwgQm9vbGVhbih0aGlzLnBhdGguaXNEaXJ0eSgpIHx8IHRoaXMuYm9yZGVyUGF0aC5pc0RpcnR5KCkpO1xuICB9XG4gIHVwZGF0ZVBhdGgoKSB7XG4gICAgY29uc3Qge1xuICAgICAgcGF0aCxcbiAgICAgIGJvcmRlclBhdGgsXG4gICAgICBjcmlzcCxcbiAgICAgIHRvcExlZnRDb3JuZXJSYWRpdXM6IHRvcExlZnQsXG4gICAgICB0b3BSaWdodENvcm5lclJhZGl1czogdG9wUmlnaHQsXG4gICAgICBib3R0b21SaWdodENvcm5lclJhZGl1czogYm90dG9tUmlnaHQsXG4gICAgICBib3R0b21MZWZ0Q29ybmVyUmFkaXVzOiBib3R0b21MZWZ0XG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IHsgeCwgeSwgd2lkdGg6IHcsIGhlaWdodDogaCwgc3Ryb2tlV2lkdGgsIGNsaXBCQm94IH0gPSB0aGlzO1xuICAgIGNvbnN0IHBpeGVsUmF0aW8gPSB0aGlzLmxheWVyTWFuYWdlcj8uY2FudmFzLnBpeGVsUmF0aW8gPz8gMTtcbiAgICBjb25zdCBwaXhlbFNpemUgPSAxIC8gcGl4ZWxSYXRpbztcbiAgICBsZXQgbWljcm9QaXhlbEVmZmVjdE9wYWNpdHkgPSAxO1xuICAgIHBhdGguY2xlYXIodHJ1ZSk7XG4gICAgYm9yZGVyUGF0aC5jbGVhcih0cnVlKTtcbiAgICBpZiAoY3Jpc3ApIHtcbiAgICAgIGlmICh3IDw9IHBpeGVsU2l6ZSkge1xuICAgICAgICBtaWNyb1BpeGVsRWZmZWN0T3BhY2l0eSAqPSB3IC8gcGl4ZWxTaXplO1xuICAgICAgfVxuICAgICAgaWYgKGggPD0gcGl4ZWxTaXplKSB7XG4gICAgICAgIG1pY3JvUGl4ZWxFZmZlY3RPcGFjaXR5ICo9IGggLyBwaXhlbFNpemU7XG4gICAgICB9XG4gICAgICB3ID0gdGhpcy5hbGlnbih4LCB3KTtcbiAgICAgIGggPSB0aGlzLmFsaWduKHksIGgpO1xuICAgICAgeCA9IHRoaXMuYWxpZ24oeCk7XG4gICAgICB5ID0gdGhpcy5hbGlnbih5KTtcbiAgICAgIGNsaXBCQm94ID0gY2xpcEJCb3ggIT0gbnVsbCA/IG5ldyBCQm94KFxuICAgICAgICB0aGlzLmFsaWduKGNsaXBCQm94LngpLFxuICAgICAgICB0aGlzLmFsaWduKGNsaXBCQm94LnkpLFxuICAgICAgICB0aGlzLmFsaWduKGNsaXBCQm94LngsIGNsaXBCQm94LndpZHRoKSxcbiAgICAgICAgdGhpcy5hbGlnbihjbGlwQkJveC55LCBjbGlwQkJveC5oZWlnaHQpXG4gICAgICApIDogdm9pZCAwO1xuICAgIH1cbiAgICBpZiAoc3Ryb2tlV2lkdGgpIHtcbiAgICAgIGlmICh3IDwgcGl4ZWxTaXplKSB7XG4gICAgICAgIGNvbnN0IGx4ID0geCArIHBpeGVsU2l6ZSAvIDI7XG4gICAgICAgIGJvcmRlclBhdGgubW92ZVRvKGx4LCB5KTtcbiAgICAgICAgYm9yZGVyUGF0aC5saW5lVG8obHgsIHkgKyBoKTtcbiAgICAgICAgc3Ryb2tlV2lkdGggPSBwaXhlbFNpemU7XG4gICAgICAgIHRoaXMuYm9yZGVyQ2xpcFBhdGggPSB2b2lkIDA7XG4gICAgICB9IGVsc2UgaWYgKGggPCBwaXhlbFNpemUpIHtcbiAgICAgICAgY29uc3QgbHkgPSB5ICsgcGl4ZWxTaXplIC8gMjtcbiAgICAgICAgYm9yZGVyUGF0aC5tb3ZlVG8oeCwgbHkpO1xuICAgICAgICBib3JkZXJQYXRoLmxpbmVUbyh4ICsgdywgbHkpO1xuICAgICAgICBzdHJva2VXaWR0aCA9IHBpeGVsU2l6ZTtcbiAgICAgICAgdGhpcy5ib3JkZXJDbGlwUGF0aCA9IHZvaWQgMDtcbiAgICAgIH0gZWxzZSBpZiAoc3Ryb2tlV2lkdGggPCB3ICYmIHN0cm9rZVdpZHRoIDwgaCkge1xuICAgICAgICBjb25zdCBoYWxmU3Ryb2tlV2lkdGggPSBzdHJva2VXaWR0aCAvIDI7XG4gICAgICAgIHggKz0gaGFsZlN0cm9rZVdpZHRoO1xuICAgICAgICB5ICs9IGhhbGZTdHJva2VXaWR0aDtcbiAgICAgICAgdyAtPSBzdHJva2VXaWR0aDtcbiAgICAgICAgaCAtPSBzdHJva2VXaWR0aDtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRDbGlwQkJveCA9IGNsaXBCQm94Py5jbG9uZSgpLnNocmluayhoYWxmU3Ryb2tlV2lkdGgpO1xuICAgICAgICBjb25zdCBjb3JuZXJSYWRpaSA9IHtcbiAgICAgICAgICB0b3BMZWZ0OiB0b3BMZWZ0ID4gMCA/IHRvcExlZnQgLSBzdHJva2VXaWR0aCA6IDAsXG4gICAgICAgICAgdG9wUmlnaHQ6IHRvcFJpZ2h0ID4gMCA/IHRvcFJpZ2h0IC0gc3Ryb2tlV2lkdGggOiAwLFxuICAgICAgICAgIGJvdHRvbVJpZ2h0OiBib3R0b21SaWdodCA+IDAgPyBib3R0b21SaWdodCAtIHN0cm9rZVdpZHRoIDogMCxcbiAgICAgICAgICBib3R0b21MZWZ0OiBib3R0b21MZWZ0ID4gMCA/IGJvdHRvbUxlZnQgLSBzdHJva2VXaWR0aCA6IDBcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ib3JkZXJDbGlwUGF0aCA9IHZvaWQgMDtcbiAgICAgICAgaWYgKHcgPiAwICYmIGggPiAwICYmIChhZGp1c3RlZENsaXBCQm94ID09IG51bGwgfHwgYWRqdXN0ZWRDbGlwQkJveD8ud2lkdGggPiAwICYmIGFkanVzdGVkQ2xpcEJCb3g/LmhlaWdodCA+IDApKSB7XG4gICAgICAgICAgaW5zZXRDb3JuZXJSYWRpdXNSZWN0KHBhdGgsIHgsIHksIHcsIGgsIGNvcm5lclJhZGlpLCBhZGp1c3RlZENsaXBCQm94KTtcbiAgICAgICAgICBpbnNldENvcm5lclJhZGl1c1JlY3QoYm9yZGVyUGF0aCwgeCwgeSwgdywgaCwgY29ybmVyUmFkaWksIGFkanVzdGVkQ2xpcEJCb3gpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJvcmRlckNsaXBQYXRoID0gdGhpcy5ib3JkZXJDbGlwUGF0aCA/PyBuZXcgRXh0ZW5kZWRQYXRoMkQoKTtcbiAgICAgICAgdGhpcy5ib3JkZXJDbGlwUGF0aC5jbGVhcih0cnVlKTtcbiAgICAgICAgdGhpcy5ib3JkZXJDbGlwUGF0aC5yZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICBib3JkZXJQYXRoLnJlY3QoeCwgeSwgdywgaCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNvcm5lclJhZGlpID0geyB0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tUmlnaHQsIGJvdHRvbUxlZnQgfTtcbiAgICAgIHRoaXMuYm9yZGVyQ2xpcFBhdGggPSB2b2lkIDA7XG4gICAgICBpbnNldENvcm5lclJhZGl1c1JlY3QocGF0aCwgeCwgeSwgdywgaCwgY29ybmVyUmFkaWksIGNsaXBCQm94KTtcbiAgICB9XG4gICAgaWYgKFt0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tUmlnaHQsIGJvdHRvbUxlZnRdLmV2ZXJ5KChyKSA9PiByID09PSAwKSkge1xuICAgICAgY29uc3QgYmJveCA9IHRoaXMuZ2V0QkJveCgpO1xuICAgICAgdGhpcy5oaXR0ZXN0ZXIgPSBiYm94LmNvbnRhaW5zUG9pbnQuYmluZChiYm94KTtcbiAgICAgIHRoaXMuZGlzdGFuY2VTcXVhcmVkID0gKGhpdFgsIGhpdFkpID0+IHRoaXMuZ2V0QkJveCgpLmRpc3RhbmNlU3F1YXJlZChoaXRYLCBoaXRZKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oaXR0ZXN0ZXIgPSBzdXBlci5pc1BvaW50SW5QYXRoO1xuICAgICAgdGhpcy5kaXN0YW5jZUNhbGN1bGF0b3IgPSBzdXBlci5kaXN0YW5jZVNxdWFyZWRUcmFuc2Zvcm1lZFBvaW50O1xuICAgIH1cbiAgICB0aGlzLmVmZmVjdGl2ZVN0cm9rZVdpZHRoID0gc3Ryb2tlV2lkdGg7XG4gICAgdGhpcy5sYXN0VXBkYXRlUGF0aFN0cm9rZVdpZHRoID0gc3Ryb2tlV2lkdGg7XG4gICAgdGhpcy5taWNyb1BpeGVsRWZmZWN0T3BhY2l0eSA9IG1pY3JvUGl4ZWxFZmZlY3RPcGFjaXR5O1xuICB9XG4gIGNvbXB1dGVCQm94KCkge1xuICAgIGNvbnN0IHsgeCwgeSwgd2lkdGg6IHdpZHRoMiwgaGVpZ2h0OiBoZWlnaHQyLCBjbGlwQkJveCB9ID0gdGhpcztcbiAgICByZXR1cm4gY2xpcEJCb3g/LmNsb25lKCkgPz8gbmV3IEJCb3goeCwgeSwgd2lkdGgyLCBoZWlnaHQyKTtcbiAgfVxuICBpc1BvaW50SW5QYXRoKHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy5oaXR0ZXN0ZXIoeCwgeSk7XG4gIH1cbiAgZ2V0IG1pZFBvaW50KCkge1xuICAgIHJldHVybiB7IHg6IHRoaXMueCArIHRoaXMud2lkdGggLyAyLCB5OiB0aGlzLnkgKyB0aGlzLmhlaWdodCAvIDIgfTtcbiAgfVxuICBkaXN0YW5jZVNxdWFyZWQoeCwgeSkge1xuICAgIHJldHVybiB0aGlzLmRpc3RhbmNlQ2FsY3VsYXRvcih4LCB5KTtcbiAgfVxuICBhcHBseUZpbGxBbHBoYShjdHgpIHtcbiAgICBjb25zdCB7IGZpbGxPcGFjaXR5LCBtaWNyb1BpeGVsRWZmZWN0T3BhY2l0eSwgb3BhY2l0eSB9ID0gdGhpcztcbiAgICBjdHguZ2xvYmFsQWxwaGEgKj0gb3BhY2l0eSAqIGZpbGxPcGFjaXR5ICogbWljcm9QaXhlbEVmZmVjdE9wYWNpdHk7XG4gIH1cbiAgcmVuZGVyU3Ryb2tlKGN0eCkge1xuICAgIGNvbnN0IHsgc3Ryb2tlLCBlZmZlY3RpdmVTdHJva2VXaWR0aCB9ID0gdGhpcztcbiAgICBpZiAoc3Ryb2tlICYmIGVmZmVjdGl2ZVN0cm9rZVdpZHRoKSB7XG4gICAgICBjb25zdCB7IGdsb2JhbEFscGhhIH0gPSBjdHg7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHN0cm9rZU9wYWNpdHksXG4gICAgICAgIGxpbmVEYXNoLFxuICAgICAgICBsaW5lRGFzaE9mZnNldCxcbiAgICAgICAgbGluZUNhcCxcbiAgICAgICAgbGluZUpvaW4sXG4gICAgICAgIGJvcmRlclBhdGgsXG4gICAgICAgIGJvcmRlckNsaXBQYXRoLFxuICAgICAgICBvcGFjaXR5LFxuICAgICAgICBtaWNyb1BpeGVsRWZmZWN0T3BhY2l0eVxuICAgICAgfSA9IHRoaXM7XG4gICAgICBpZiAoYm9yZGVyQ2xpcFBhdGgpIHtcbiAgICAgICAgY3R4LmNsaXAoYm9yZGVyQ2xpcFBhdGguZ2V0UGF0aDJEKCkpO1xuICAgICAgfVxuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlO1xuICAgICAgY3R4Lmdsb2JhbEFscGhhICo9IG9wYWNpdHkgKiBzdHJva2VPcGFjaXR5ICogbWljcm9QaXhlbEVmZmVjdE9wYWNpdHk7XG4gICAgICBjdHgubGluZVdpZHRoID0gZWZmZWN0aXZlU3Ryb2tlV2lkdGg7XG4gICAgICBpZiAobGluZURhc2gpIHtcbiAgICAgICAgY3R4LnNldExpbmVEYXNoKGxpbmVEYXNoKTtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lRGFzaE9mZnNldCkge1xuICAgICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBsaW5lRGFzaE9mZnNldDtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lQ2FwKSB7XG4gICAgICAgIGN0eC5saW5lQ2FwID0gbGluZUNhcDtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lSm9pbikge1xuICAgICAgICBjdHgubGluZUpvaW4gPSBsaW5lSm9pbjtcbiAgICAgIH1cbiAgICAgIGN0eC5zdHJva2UoYm9yZGVyUGF0aC5nZXRQYXRoMkQoKSk7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgPSBnbG9iYWxBbHBoYTtcbiAgICB9XG4gIH1cbn07XG5SZWN0LmNsYXNzTmFtZSA9IFwiUmVjdFwiO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFJlY3QucHJvdG90eXBlLCBcInhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgUmVjdC5wcm90b3R5cGUsIFwieVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBSZWN0LnByb3RvdHlwZSwgXCJ3aWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBSZWN0LnByb3RvdHlwZSwgXCJoZWlnaHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgUmVjdC5wcm90b3R5cGUsIFwidG9wTGVmdENvcm5lclJhZGl1c1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBSZWN0LnByb3RvdHlwZSwgXCJ0b3BSaWdodENvcm5lclJhZGl1c1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBSZWN0LnByb3RvdHlwZSwgXCJib3R0b21SaWdodENvcm5lclJhZGl1c1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBSZWN0LnByb3RvdHlwZSwgXCJib3R0b21MZWZ0Q29ybmVyUmFkaXVzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFJlY3QucHJvdG90eXBlLCBcImNsaXBCQm94XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFJlY3QucHJvdG90eXBlLCBcImNyaXNwXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9iYWNrZ3JvdW5kL2JhY2tncm91bmQudHNcbnZhciBCYWNrZ3JvdW5kID0gY2xhc3MgZXh0ZW5kcyBCYXNlTW9kdWxlSW5zdGFuY2Uge1xuICBjb25zdHJ1Y3RvcihjdHgpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMucmVjdE5vZGUgPSBuZXcgUmVjdCgpO1xuICAgIHRoaXMudGV4dE5vZGUgPSBuZXcgVGV4dCgpO1xuICAgIHRoaXMuZmlsbCA9IFwid2hpdGVcIjtcbiAgICB0aGlzLm5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcbiAgICB0aGlzLm5vZGUuYXBwZW5kKFt0aGlzLnJlY3ROb2RlLCB0aGlzLnRleHROb2RlXSk7XG4gICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMucHVzaChcbiAgICAgIGN0eC5zY2VuZS5hdHRhY2hOb2RlKHRoaXMubm9kZSksXG4gICAgICBjdHgubGF5b3V0TWFuYWdlci5hZGRMaXN0ZW5lcihcImxheW91dDpjb21wbGV0ZVwiLCAoZSkgPT4gdGhpcy5vbkxheW91dENvbXBsZXRlKGUpKVxuICAgICk7XG4gIH1cbiAgY3JlYXRlTm9kZSgpIHtcbiAgICByZXR1cm4gbmV3IEdyb3VwKHsgbmFtZTogXCJiYWNrZ3JvdW5kXCIsIHpJbmRleDogMCAvKiBTRVJJRVNfQkFDS0dST1VORCAqLyB9KTtcbiAgfVxuICBvbkxheW91dENvbXBsZXRlKGUpIHtcbiAgICBjb25zdCB7IHdpZHRoOiB3aWR0aDIsIGhlaWdodDogaGVpZ2h0MiB9ID0gZS5jaGFydDtcbiAgICB0aGlzLnJlY3ROb2RlLndpZHRoID0gd2lkdGgyO1xuICAgIHRoaXMucmVjdE5vZGUuaGVpZ2h0ID0gaGVpZ2h0MjtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pLFxuICBQcm94eVByb3BlcnR5T25Xcml0ZShcIm5vZGVcIiwgXCJ2aXNpYmxlXCIpXG5dLCBCYWNrZ3JvdW5kLnByb3RvdHlwZSwgXCJ2aXNpYmxlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pLFxuICBQcm94eVByb3BlcnR5T25Xcml0ZShcInJlY3ROb2RlXCIsIFwiZmlsbFwiKVxuXSwgQmFja2dyb3VuZC5wcm90b3R5cGUsIFwiZmlsbFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVCwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQmFja2dyb3VuZC5wcm90b3R5cGUsIFwiaW1hZ2VcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSksXG4gIFByb3h5UHJvcGVydHlPbldyaXRlKFwidGV4dE5vZGVcIilcbl0sIEJhY2tncm91bmQucHJvdG90eXBlLCBcInRleHRcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2JhY2tncm91bmQvYmFja2dyb3VuZE1vZHVsZS50c1xudmFyIEJhY2tncm91bmRNb2R1bGUgPSB7XG4gIHR5cGU6IFwicm9vdFwiLFxuICBvcHRpb25zS2V5OiBcImJhY2tncm91bmRcIixcbiAgcGFja2FnZVR5cGU6IFwiY29tbXVuaXR5XCIsXG4gIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiLCBcInBvbGFyXCIsIFwiaGllcmFyY2h5XCIsIFwidG9wb2xvZ3lcIiwgXCJmbG93LXByb3BvcnRpb25cIiwgXCJzdGFuZGFsb25lXCIsIFwiZ2F1Z2VcIl0sXG4gIG1vZHVsZUZhY3Rvcnk6IChjdHgpID0+IG5ldyBCYWNrZ3JvdW5kKGN0eClcbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2dyaWRMYXlvdXQudHNcbmZ1bmN0aW9uIGdyaWRMYXlvdXQoe1xuICBvcmllbnRhdGlvbixcbiAgYmJveGVzLFxuICBtYXhIZWlnaHQsXG4gIG1heFdpZHRoLFxuICBpdGVtUGFkZGluZ1kgPSAwLFxuICBpdGVtUGFkZGluZ1ggPSAwLFxuICBmb3JjZVJlc3VsdCA9IGZhbHNlXG59KSB7XG4gIGNvbnN0IGhvcml6b250YWwgPSBvcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCI7XG4gIGNvbnN0IHByaW1hcnkgPSB7XG4gICAgbWF4OiBob3Jpem9udGFsID8gbWF4V2lkdGggOiBtYXhIZWlnaHQsXG4gICAgZm46IGhvcml6b250YWwgPyAoYikgPT4gYi53aWR0aCA6IChiKSA9PiBiLmhlaWdodCxcbiAgICBwYWRkaW5nOiBob3Jpem9udGFsID8gaXRlbVBhZGRpbmdYIDogaXRlbVBhZGRpbmdZXG4gIH07XG4gIGNvbnN0IHNlY29uZGFyeSA9IHtcbiAgICBtYXg6IGhvcml6b250YWwgPyBtYXhIZWlnaHQgOiBtYXhXaWR0aCxcbiAgICBmbjogaG9yaXpvbnRhbCA/IChiKSA9PiBiLmhlaWdodCA6IChiKSA9PiBiLndpZHRoLFxuICAgIHBhZGRpbmc6IGhvcml6b250YWwgPyBpdGVtUGFkZGluZ1kgOiBpdGVtUGFkZGluZ1hcbiAgfTtcbiAgbGV0IHByb2Nlc3NlZEJCb3hDb3VudCA9IDA7XG4gIGNvbnN0IHJhd1BhZ2VzID0gW107XG4gIHdoaWxlIChwcm9jZXNzZWRCQm94Q291bnQgPCBiYm94ZXMubGVuZ3RoKSB7XG4gICAgY29uc3QgdW5wcm9jZXNzZWRCQm94ZXMgPSBiYm94ZXMuc2xpY2UocHJvY2Vzc2VkQkJveENvdW50KTtcbiAgICBjb25zdCByZXN1bHQgPSBwcm9jZXNzQkJveGVzKHVucHJvY2Vzc2VkQkJveGVzLCBwcm9jZXNzZWRCQm94Q291bnQsIHByaW1hcnksIHNlY29uZGFyeSwgZm9yY2VSZXN1bHQpO1xuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHByb2Nlc3NlZEJCb3hDb3VudCArPSByZXN1bHQucHJvY2Vzc2VkQkJveENvdW50O1xuICAgIHJhd1BhZ2VzLnB1c2gocmVzdWx0LnBhZ2VJbmRpY2VzKTtcbiAgfVxuICByZXR1cm4gYnVpbGRQYWdlcyhyYXdQYWdlcywgb3JpZW50YXRpb24sIGJib3hlcywgaXRlbVBhZGRpbmdZLCBpdGVtUGFkZGluZ1gpO1xufVxuZnVuY3Rpb24gcHJvY2Vzc0JCb3hlcyhiYm94ZXMsIGluZGV4T2Zmc2V0LCBwcmltYXJ5LCBzZWNvbmRhcnksIGZvcmNlUmVzdWx0KSB7XG4gIGNvbnN0IG1pbkd1ZXNzID0gMTtcbiAgbGV0IHN0YXJ0aW5nR3Vlc3MgPSBlc3RpbWF0ZVN0YXJ0aW5nR3Vlc3MoYmJveGVzLCBwcmltYXJ5KTtcbiAgaWYgKHN0YXJ0aW5nR3Vlc3MgPCBtaW5HdWVzcykge1xuICAgIGlmICghZm9yY2VSZXN1bHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3RhcnRpbmdHdWVzcyA9IG1pbkd1ZXNzO1xuICB9XG4gIGxldCBndWVzcyA9IHN0YXJ0aW5nR3Vlc3M7XG4gIHdoaWxlIChndWVzcyA+PSBtaW5HdWVzcykge1xuICAgIGNvbnN0IHBhZ2VJbmRpY2VzID0gY2FsY3VsYXRlUGFnZShiYm94ZXMsIGluZGV4T2Zmc2V0LCBndWVzcywgcHJpbWFyeSwgc2Vjb25kYXJ5LCBmb3JjZVJlc3VsdCk7XG4gICAgaWYgKHBhZ2VJbmRpY2VzID09IG51bGwgJiYgZ3Vlc3MgPD0gbWluR3Vlc3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHBhZ2VJbmRpY2VzID09IG51bGwpIHtcbiAgICAgIGd1ZXNzLS07XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwYWdlSW5kaWNlcyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgaWYgKHBhZ2VJbmRpY2VzIDw9IG1pbkd1ZXNzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGd1ZXNzID0gcGFnZUluZGljZXMgPCBndWVzcyAmJiBwYWdlSW5kaWNlcyA+IG1pbkd1ZXNzID8gcGFnZUluZGljZXMgOiBndWVzcztcbiAgICAgIGd1ZXNzLS07XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgcHJvY2Vzc2VkQkJveENvdW50ID0gcGFnZUluZGljZXMubGVuZ3RoICogcGFnZUluZGljZXNbMF0ubGVuZ3RoO1xuICAgIHJldHVybiB7IHByb2Nlc3NlZEJCb3hDb3VudCwgcGFnZUluZGljZXMgfTtcbiAgfVxufVxuZnVuY3Rpb24gY2FsY3VsYXRlUGFnZShiYm94ZXMsIGluZGV4T2Zmc2V0LCBwcmltYXJ5Q291bnQsIHByaW1hcnksIHNlY29uZGFyeSwgZm9yY2VSZXN1bHQpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBzdW1TZWNvbmRhcnkgPSAwO1xuICBsZXQgY3VycmVudE1heFNlY29uZGFyeSA9IDA7XG4gIGxldCBjdXJyZW50UHJpbWFyeUluZGljZXMgPSBbXTtcbiAgY29uc3QgbWF4UHJpbWFyeVZhbHVlcyA9IFtdO1xuICBmb3IgKGxldCBiYm94SW5kZXggPSAwOyBiYm94SW5kZXggPCBiYm94ZXMubGVuZ3RoOyBiYm94SW5kZXgrKykge1xuICAgIGNvbnN0IHByaW1hcnlWYWx1ZUlkeCA9IChiYm94SW5kZXggKyBwcmltYXJ5Q291bnQpICUgcHJpbWFyeUNvdW50O1xuICAgIGlmIChwcmltYXJ5VmFsdWVJZHggPT09IDApIHtcbiAgICAgIHN1bVNlY29uZGFyeSArPSBjdXJyZW50TWF4U2Vjb25kYXJ5O1xuICAgICAgY3VycmVudE1heFNlY29uZGFyeSA9IDA7XG4gICAgICBpZiAoY3VycmVudFByaW1hcnlJbmRpY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmVzdWx0LnB1c2goY3VycmVudFByaW1hcnlJbmRpY2VzKTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnRQcmltYXJ5SW5kaWNlcyA9IFtdO1xuICAgIH1cbiAgICBjb25zdCBwcmltYXJ5VmFsdWUgPSBwcmltYXJ5LmZuKGJib3hlc1tiYm94SW5kZXhdKSArIHByaW1hcnkucGFkZGluZztcbiAgICBtYXhQcmltYXJ5VmFsdWVzW3ByaW1hcnlWYWx1ZUlkeF0gPSBNYXRoLm1heChtYXhQcmltYXJ5VmFsdWVzW3ByaW1hcnlWYWx1ZUlkeF0gPz8gMCwgcHJpbWFyeVZhbHVlKTtcbiAgICBjdXJyZW50TWF4U2Vjb25kYXJ5ID0gTWF0aC5tYXgoY3VycmVudE1heFNlY29uZGFyeSwgc2Vjb25kYXJ5LmZuKGJib3hlc1tiYm94SW5kZXhdKSArIHNlY29uZGFyeS5wYWRkaW5nKTtcbiAgICBjb25zdCBjdXJyZW50U2Vjb25kYXJ5RGltZW5zaW9uID0gc3VtU2Vjb25kYXJ5ICsgY3VycmVudE1heFNlY29uZGFyeTtcbiAgICBjb25zdCByZXR1cm5SZXN1bHQgPSAhZm9yY2VSZXN1bHQgfHwgcmVzdWx0Lmxlbmd0aCA+IDA7XG4gICAgaWYgKGN1cnJlbnRTZWNvbmRhcnlEaW1lbnNpb24gPiBzZWNvbmRhcnkubWF4ICYmIHJldHVyblJlc3VsdCkge1xuICAgICAgY3VycmVudFByaW1hcnlJbmRpY2VzID0gW107XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY29uc3Qgc3VtUHJpbWFyeSA9IG1heFByaW1hcnlWYWx1ZXMucmVkdWNlKChzdW0yLCBuZXh0KSA9PiBzdW0yICsgbmV4dCwgMCk7XG4gICAgaWYgKHN1bVByaW1hcnkgPiBwcmltYXJ5Lm1heCAmJiAhZm9yY2VSZXN1bHQpIHtcbiAgICAgIGlmIChtYXhQcmltYXJ5VmFsdWVzLmxlbmd0aCA8IHByaW1hcnlDb3VudCkge1xuICAgICAgICByZXR1cm4gbWF4UHJpbWFyeVZhbHVlcy5sZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGN1cnJlbnRQcmltYXJ5SW5kaWNlcy5wdXNoKGJib3hJbmRleCArIGluZGV4T2Zmc2V0KTtcbiAgfVxuICBpZiAoY3VycmVudFByaW1hcnlJbmRpY2VzLmxlbmd0aCA+IDApIHtcbiAgICByZXN1bHQucHVzaChjdXJyZW50UHJpbWFyeUluZGljZXMpO1xuICB9XG4gIHJldHVybiByZXN1bHQubGVuZ3RoID4gMCA/IHJlc3VsdCA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGJ1aWxkUGFnZXMocmF3UGFnZXMsIG9yaWVudGF0aW9uLCBiYm94ZXMsIGl0ZW1QYWRkaW5nWSwgaXRlbVBhZGRpbmdYKSB7XG4gIGxldCBtYXhQYWdlV2lkdGggPSAwO1xuICBsZXQgbWF4UGFnZUhlaWdodCA9IDA7XG4gIGNvbnN0IHBhZ2VzID0gcmF3UGFnZXMubWFwKChpbmRpY2VzKSA9PiB7XG4gICAgaWYgKG9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIikge1xuICAgICAgaW5kaWNlcyA9IHRyYW5zcG9zZShpbmRpY2VzKTtcbiAgICB9XG4gICAgbGV0IGVuZEluZGV4ID0gMDtcbiAgICBjb25zdCBjb2x1bW5zID0gaW5kaWNlcy5tYXAoKGNvbEluZGljZXMpID0+IHtcbiAgICAgIGNvbnN0IGNvbEJCb3hlcyA9IGNvbEluZGljZXMubWFwKChiYm94SW5kZXgpID0+IHtcbiAgICAgICAgZW5kSW5kZXggPSBNYXRoLm1heChiYm94SW5kZXgsIGVuZEluZGV4KTtcbiAgICAgICAgcmV0dXJuIGJib3hlc1tiYm94SW5kZXhdO1xuICAgICAgfSk7XG4gICAgICBsZXQgY29sdW1uSGVpZ2h0ID0gMDtcbiAgICAgIGxldCBjb2x1bW5XaWR0aCA9IDA7XG4gICAgICBjb2xCQm94ZXMuZm9yRWFjaCgoYmJveCkgPT4ge1xuICAgICAgICBjb2x1bW5IZWlnaHQgKz0gYmJveC5oZWlnaHQgKyBpdGVtUGFkZGluZ1k7XG4gICAgICAgIGNvbHVtbldpZHRoID0gTWF0aC5tYXgoY29sdW1uV2lkdGgsIGJib3gud2lkdGggKyBpdGVtUGFkZGluZ1gpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbmRpY2VzOiBjb2xJbmRpY2VzLFxuICAgICAgICBiYm94ZXM6IGNvbEJCb3hlcyxcbiAgICAgICAgY29sdW1uSGVpZ2h0OiBNYXRoLmNlaWwoY29sdW1uSGVpZ2h0KSxcbiAgICAgICAgY29sdW1uV2lkdGg6IE1hdGguY2VpbChjb2x1bW5XaWR0aClcbiAgICAgIH07XG4gICAgfSk7XG4gICAgbGV0IHBhZ2VXaWR0aCA9IDA7XG4gICAgbGV0IHBhZ2VIZWlnaHQgPSAwO1xuICAgIGNvbHVtbnMuZm9yRWFjaCgoY29sdW1uKSA9PiB7XG4gICAgICBwYWdlV2lkdGggKz0gY29sdW1uLmNvbHVtbldpZHRoO1xuICAgICAgcGFnZUhlaWdodCA9IE1hdGgubWF4KHBhZ2VIZWlnaHQsIGNvbHVtbi5jb2x1bW5IZWlnaHQpO1xuICAgIH0pO1xuICAgIG1heFBhZ2VXaWR0aCA9IE1hdGgubWF4KHBhZ2VXaWR0aCwgbWF4UGFnZVdpZHRoKTtcbiAgICBtYXhQYWdlSGVpZ2h0ID0gTWF0aC5tYXgocGFnZUhlaWdodCwgbWF4UGFnZUhlaWdodCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbHVtbnMsXG4gICAgICBzdGFydEluZGV4OiBpbmRpY2VzWzBdWzBdLFxuICAgICAgZW5kSW5kZXgsXG4gICAgICBwYWdlV2lkdGgsXG4gICAgICBwYWdlSGVpZ2h0XG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiB7IHBhZ2VzLCBtYXhQYWdlV2lkdGgsIG1heFBhZ2VIZWlnaHQgfTtcbn1cbmZ1bmN0aW9uIHRyYW5zcG9zZShkYXRhKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBmb3IgKGNvbnN0IF8gb2YgZGF0YVswXSkge1xuICAgIHJlc3VsdC5wdXNoKFtdKTtcbiAgfVxuICBkYXRhLmZvckVhY2goKGlubmVyRGF0YSwgZGF0YUlkeCkgPT4ge1xuICAgIGlubmVyRGF0YS5mb3JFYWNoKChpdGVtLCBpdGVtSWR4KSA9PiB7XG4gICAgICByZXN1bHRbaXRlbUlkeF1bZGF0YUlkeF0gPSBpdGVtO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGVzdGltYXRlU3RhcnRpbmdHdWVzcyhiYm94ZXMsIHByaW1hcnkpIHtcbiAgY29uc3QgbiA9IGJib3hlcy5sZW5ndGg7XG4gIGxldCBwcmltYXJ5U3VtID0gMDtcbiAgZm9yIChsZXQgYmJveEluZGV4ID0gMDsgYmJveEluZGV4IDwgbjsgYmJveEluZGV4KyspIHtcbiAgICBwcmltYXJ5U3VtICs9IHByaW1hcnkuZm4oYmJveGVzW2Jib3hJbmRleF0pICsgcHJpbWFyeS5wYWRkaW5nO1xuICAgIGlmIChwcmltYXJ5U3VtID4gcHJpbWFyeS5tYXgpIHtcbiAgICAgIGNvbnN0IHJhdGlvMiA9IG4gLyBiYm94SW5kZXg7XG4gICAgICBpZiAocmF0aW8yIDwgMikge1xuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKG4gLyAyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYm94SW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiBuO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9pbWFnZS50c1xudmFyIEltYWdlID0gY2xhc3MgZXh0ZW5kcyBOb2RlIHtcbiAgY29uc3RydWN0b3Ioc291cmNlSW1hZ2UpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc291cmNlSW1hZ2UgPSBzb3VyY2VJbWFnZTtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gICAgdGhpcy53aWR0aCA9IDA7XG4gICAgdGhpcy5oZWlnaHQgPSAwO1xuICAgIHRoaXMub3BhY2l0eSA9IDE7XG4gIH1cbiAgdXBkYXRlQml0bWFwKG5ld0JpdG1hcCwgYml0bWFwUGl4ZWxSYXRpbywgeCwgeSkge1xuICAgIHRoaXMuc291cmNlSW1hZ2UgPSBuZXdCaXRtYXA7XG4gICAgdGhpcy53aWR0aCA9IG5ld0JpdG1hcC53aWR0aCAvIGJpdG1hcFBpeGVsUmF0aW87XG4gICAgdGhpcy5oZWlnaHQgPSBuZXdCaXRtYXAuaGVpZ2h0IC8gYml0bWFwUGl4ZWxSYXRpbztcbiAgICB0aGlzLnggPSB4IC8gYml0bWFwUGl4ZWxSYXRpbztcbiAgICB0aGlzLnkgPSB5IC8gYml0bWFwUGl4ZWxSYXRpbztcbiAgICB0aGlzLm1hcmtEaXJ0eSgzIC8qIE1BSk9SICovKTtcbiAgfVxuICByZW5kZXIocmVuZGVyQ3R4KSB7XG4gICAgY29uc3QgeyBjdHgsIGZvcmNlUmVuZGVyLCBzdGF0cyB9ID0gcmVuZGVyQ3R4O1xuICAgIGlmICh0aGlzLmRpcnR5ID09PSAwIC8qIE5PTkUgKi8gJiYgIWZvcmNlUmVuZGVyKSB7XG4gICAgICBpZiAoc3RhdHMpXG4gICAgICAgIHN0YXRzLm5vZGVzU2tpcHBlZCsrO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbWFnZSA9IHRoaXMuc291cmNlSW1hZ2U7XG4gICAgaWYgKCFpbWFnZSlcbiAgICAgIHJldHVybjtcbiAgICBjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLm9wYWNpdHk7XG4gICAgY3R4LmRyYXdJbWFnZShpbWFnZSwgMCwgMCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCwgdGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICBzdXBlci5yZW5kZXIocmVuZGVyQ3R4KTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBJbWFnZS5wcm90b3R5cGUsIFwieFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBJbWFnZS5wcm90b3R5cGUsIFwieVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBJbWFnZS5wcm90b3R5cGUsIFwid2lkdGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLyB9KVxuXSwgSW1hZ2UucHJvdG90eXBlLCBcImhlaWdodFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBJbWFnZS5wcm90b3R5cGUsIFwib3BhY2l0eVwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbGVnZW5kTWFya2VyTGFiZWwudHNcbnZhciBMZWdlbmRNYXJrZXJMYWJlbCA9IGNsYXNzIGV4dGVuZHMgVHJhbnNsYXRhYmxlKEdyb3VwKSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHsgbmFtZTogXCJtYXJrZXJMYWJlbEdyb3VwXCIgfSk7XG4gICAgdGhpcy5sYWJlbCA9IG5ldyBUZXh0KCk7XG4gICAgdGhpcy5zeW1ib2xzR3JvdXAgPSBuZXcgR3JvdXAoe1xuICAgICAgbmFtZTogXCJsZWdlbmQtbWFya2VyTGFiZWwtc3ltYm9sc1wiXG4gICAgfSk7XG4gICAgdGhpcy5iaXRtYXAgPSBuZXcgSW1hZ2UoKTtcbiAgICB0aGlzLmJpdG1hcERpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMucGFnZUluZGV4ID0gTmFOO1xuICAgIHRoaXMuX21hcmtlcnMgPSBbXTtcbiAgICB0aGlzLl9saW5lcyA9IFtdO1xuICAgIGNvbnN0IHsgbWFya2VycywgbGFiZWwsIGxpbmVzIH0gPSB0aGlzO1xuICAgIGxhYmVsLnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XG4gICAgbGFiZWwuZm9udFNpemUgPSAxMjtcbiAgICBsYWJlbC5mb250RmFtaWx5ID0gXCJWZXJkYW5hLCBzYW5zLXNlcmlmXCI7XG4gICAgbGFiZWwuZmlsbCA9IFwiYmxhY2tcIjtcbiAgICBsYWJlbC55ID0gMTtcbiAgICB0aGlzLnVwZGF0ZVN5bWJvbHMobWFya2VycywgbGluZXMpO1xuICAgIHRoaXMuYXBwZW5kKFt0aGlzLnN5bWJvbHNHcm91cCwgbGFiZWxdKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmRlc3Ryb3lQcm94eUJ1dHRvbigpO1xuICB9XG4gIGRlc3Ryb3lQcm94eUJ1dHRvbigpIHtcbiAgICB0aGlzLnByb3h5QnV0dG9uPy5idXR0b24ucmVtb3ZlKCk7XG4gICAgdGhpcy5wcm94eUJ1dHRvbj8ubGlzdGl0ZW0ucmVtb3ZlKCk7XG4gICAgdGhpcy5wcm94eUJ1dHRvbiA9IHZvaWQgMDtcbiAgfVxuICBnZXQgbWFya2VycygpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFya2VycztcbiAgfVxuICBnZXQgbGluZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xpbmVzO1xuICB9XG4gIHVwZGF0ZVN5bWJvbHMobWFya2VycywgbGluZXMpIHtcbiAgICBpZiAoYXJyYXlzRXF1YWwodGhpcy5fbWFya2VycywgbWFya2VycykgJiYgYXJyYXlzRXF1YWwodGhpcy5fbGluZXMsIGxpbmVzKSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmJpdG1hcERpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzLl9tYXJrZXJzID0gbWFya2VycztcbiAgICB0aGlzLl9saW5lcyA9IGxpbmVzO1xuICAgIHRoaXMuc3ltYm9sc0dyb3VwLmNsZWFyKCk7XG4gICAgdGhpcy5zeW1ib2xzR3JvdXAuYXBwZW5kKFt0aGlzLmJpdG1hcCwgLi4ubGluZXMsIC4uLm1hcmtlcnNdKTtcbiAgfVxuICBzZXRFbmFibGVkKGVuYWJsZWQpIHtcbiAgICB0aGlzLmVuYWJsZWQgPSBlbmFibGVkO1xuICAgIHRoaXMucmVmcmVzaFZpc2liaWxpdGllcygpO1xuICB9XG4gIHJlZnJlc2hWaXNpYmlsaXRpZXMoKSB7XG4gICAgY29uc3Qgb3BhY2l0eSA9IHRoaXMuZW5hYmxlZCA/IDEgOiAwLjU7XG4gICAgdGhpcy5sYWJlbC5vcGFjaXR5ID0gb3BhY2l0eTtcbiAgICB0aGlzLm9wYWNpdHkgPSBvcGFjaXR5O1xuICAgIHRoaXMuYml0bWFwLm9wYWNpdHkgPSBvcGFjaXR5O1xuICAgIHRoaXMuc2V0Qml0bWFwVmlzaWJpbGl0eSghdGhpcy5lbmFibGVkKTtcbiAgfVxuICBzZXRCaXRtYXBWaXNpYmlsaXR5KHZpc2libGUpIHtcbiAgICBjb25zdCB7IGxpbmVzLCBtYXJrZXJzIH0gPSB0aGlzO1xuICAgIFtsaW5lcywgbWFya2Vyc10uZm9yRWFjaCgoc2hhcGVzKSA9PiBzaGFwZXMuZm9yRWFjaCgoc2hhcGUpID0+IHNoYXBlLnZpc2libGUgPSAhdmlzaWJsZSkpO1xuICAgIHRoaXMuYml0bWFwLnZpc2libGUgPSB2aXNpYmxlO1xuICB9XG4gIC8vIFRoZSBCQm94IG9mIHRoaXMuYml0bWFwIGlzIGBzcHJpdGVQYWRkaW5nYCBwaXhlbHMgYmlnZ2VyIGluIGVhY2ggZGlyZWN0aW9uIHRoYW4gQkJveCBvZiB0aGUgbWFya2VycyBhbmQgbGluZXMuXG4gIC8vIFRoaXMgcGFkZGluZyBhbGxvd3MgdGhlIFNwcml0ZVJlbmRlcmVyIHRvIGRyYXcgYW50aWFsaWFzaW5nIHBpeGVscyB0aGF0IGNhbiBleHRlbmQgYmV5b25kIHRoZSBzaGFwZXMnIGJvdW5kcy5cbiAgdXBkYXRlKHNwcml0ZVJlbmRlcmVyLCB7IHNwcml0ZUFBUGFkZGluZywgc3ByaXRlUGl4ZWxSYXRpbzogc2NhbGUyIH0sIGRpbWVuc2lvblByb3BzKSB7XG4gICAgY29uc3QgeyBtYXJrZXJzLCBsaW5lcyB9ID0gdGhpcztcbiAgICBsZXQgc3ByaXRlWCA9IDA7XG4gICAgbGV0IHNwcml0ZVkgPSAwO1xuICAgIGxldCBzaGlmdCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNYXRoLm1heChtYXJrZXJzLmxlbmd0aCwgbGluZXMubGVuZ3RoKTsgaSsrKSB7XG4gICAgICBjb25zdCB7IGxlbmd0aDogbGVuZ3RoMiwgc3BhY2luZywgaXNDdXN0b21NYXJrZXIgfSA9IGRpbWVuc2lvblByb3BzW2ldID8/IDA7XG4gICAgICBjb25zdCBtYXJrZXIgPSBtYXJrZXJzW2ldO1xuICAgICAgY29uc3QgbGluZSA9IGxpbmVzW2ldO1xuICAgICAgY29uc3Qgc2l6ZSA9IG1hcmtlcj8uc2l6ZSA/PyAwO1xuICAgICAgbGV0IGxpbmVUb3AgPSBJbmZpbml0eTtcbiAgICAgIGxldCBsaW5lWDEgPSBJbmZpbml0eTtcbiAgICAgIGxldCBsaW5lWDIgPSBJbmZpbml0eTtcbiAgICAgIGxldCBtYXJrZXJUb3AgPSBJbmZpbml0eTtcbiAgICAgIGxldCBtYXJrZXJMZWZ0ID0gSW5maW5pdHk7XG4gICAgICBpZiAobWFya2VyKSB7XG4gICAgICAgIGNvbnN0IGNlbnRlcjIgPSBtYXJrZXIuY29uc3RydWN0b3IuY2VudGVyO1xuICAgICAgICBjb25zdCByYWRpdXMgPSAoc2l6ZSArIG1hcmtlci5zdHJva2VXaWR0aCkgLyAyO1xuICAgICAgICBpZiAoaXNDdXN0b21NYXJrZXIpIHtcbiAgICAgICAgICBtYXJrZXIueCA9IDA7XG4gICAgICAgICAgbWFya2VyLnkgPSAwO1xuICAgICAgICAgIG1hcmtlci50cmFuc2xhdGlvblggPSAoY2VudGVyMi54IC0gMC41KSAqIHNpemUgKyBsZW5ndGgyIC8gMiArIHNoaWZ0O1xuICAgICAgICAgIG1hcmtlci50cmFuc2xhdGlvblkgPSAoY2VudGVyMi55IC0gMC41KSAqIHNpemU7XG4gICAgICAgICAgbWFya2VyVG9wID0gbWFya2VyLnRyYW5zbGF0aW9uWSAtIHJhZGl1cztcbiAgICAgICAgICBtYXJrZXJMZWZ0ID0gbWFya2VyLnRyYW5zbGF0aW9uWCAtIHJhZGl1cztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXJrZXIueCA9IChjZW50ZXIyLnggLSAwLjUpICogc2l6ZSArIGxlbmd0aDIgLyAyICsgc2hpZnQ7XG4gICAgICAgICAgbWFya2VyLnkgPSAoY2VudGVyMi55IC0gMC41KSAqIHNpemU7XG4gICAgICAgICAgbWFya2VyVG9wID0gbWFya2VyLnkgLSByYWRpdXM7XG4gICAgICAgICAgbWFya2VyTGVmdCA9IG1hcmtlci54IC0gcmFkaXVzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobGluZSkge1xuICAgICAgICBsaW5lLngxID0gc2hpZnQ7XG4gICAgICAgIGxpbmUueDIgPSBzaGlmdCArIGxlbmd0aDI7XG4gICAgICAgIGxpbmUueTEgPSAwO1xuICAgICAgICBsaW5lLnkyID0gMDtcbiAgICAgICAgbGluZS5tYXJrRGlydHkoMyAvKiBNQUpPUiAqLyk7XG4gICAgICAgIGxpbmVUb3AgPSAtbGluZS5zdHJva2VXaWR0aCAvIDI7XG4gICAgICAgIGxpbmVYMSA9IGxpbmUueDE7XG4gICAgICAgIGxpbmVYMiA9IGxpbmUueDI7XG4gICAgICB9XG4gICAgICBzaGlmdCArPSBzcGFjaW5nICsgTWF0aC5tYXgobGVuZ3RoMiwgc2l6ZSk7XG4gICAgICBzcHJpdGVYID0gTWF0aC5taW4oc3ByaXRlWCwgbGluZVgxLCBsaW5lWDIsIG1hcmtlckxlZnQpO1xuICAgICAgc3ByaXRlWSA9IE1hdGgubWluKHNwcml0ZVksIGxpbmVUb3AsIG1hcmtlclRvcCk7XG4gICAgfVxuICAgIGNvbnN0IGxhc3RTeW1ib2xQcm9wcyA9IGRpbWVuc2lvblByb3BzLmF0KC0xKTtcbiAgICBjb25zdCBsYXN0TGluZSA9IHRoaXMubGluZXMuYXQoLTEpO1xuICAgIGNvbnN0IGxhc3RNYXJrZXIgPSB0aGlzLm1hcmtlcnMuYXQoLTEpO1xuICAgIGNvbnN0IGxpbmVFbmQgPSBsYXN0TGluZSA/IGxhc3RMaW5lLngyIDogLUluZmluaXR5O1xuICAgIGNvbnN0IG1hcmtlckVuZCA9IChsYXN0TWFya2VyPy54ID8/IDApICsgKGxhc3RNYXJrZXI/LnNpemUgPz8gMCkgLyAyO1xuICAgIHRoaXMubGFiZWwueCA9IE1hdGgubWF4KGxpbmVFbmQsIG1hcmtlckVuZCkgKyAobGFzdFN5bWJvbFByb3BzPy5zcGFjaW5nID8/IDApO1xuICAgIGlmICh0aGlzLmJpdG1hcERpcnR5KSB7XG4gICAgICB0aGlzLnNldEJpdG1hcFZpc2liaWxpdHkoZmFsc2UpO1xuICAgICAgY29uc3QgdHJhbnNsYXRlWCA9IChzcHJpdGVBQVBhZGRpbmcgKyBzcHJpdGVYKSAqIHNjYWxlMjtcbiAgICAgIGNvbnN0IHRyYW5zbGF0ZVkgPSAoc3ByaXRlQUFQYWRkaW5nIC0gc3ByaXRlWSkgKiBzY2FsZTI7XG4gICAgICBjb25zdCBzcHJpdGUgPSBzcHJpdGVSZW5kZXJlci5yZW5kZXJTcHJpdGUodGhpcy5zeW1ib2xzR3JvdXAsIHtcbiAgICAgICAgc2NhbGU6IHNjYWxlMixcbiAgICAgICAgdHJhbnNsYXRlWDogTWF0aC5mbG9vcih0cmFuc2xhdGVYKSxcbiAgICAgICAgdHJhbnNsYXRlWTogTWF0aC5mbG9vcih0cmFuc2xhdGVZKVxuICAgICAgfSk7XG4gICAgICB0aGlzLmJpdG1hcC51cGRhdGVCaXRtYXAoc3ByaXRlLCBzY2FsZTIsIE1hdGguY2VpbCgtdHJhbnNsYXRlWCksIE1hdGguY2VpbCgtdHJhbnNsYXRlWSkpO1xuICAgICAgdGhpcy5iaXRtYXBEaXJ0eSA9IGZhbHNlO1xuICAgICAgdGhpcy5yZWZyZXNoVmlzaWJpbGl0aWVzKCk7XG4gICAgfVxuICAgIGlmIChkaW1lbnNpb25Qcm9wcy5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGJib3ggPSB0aGlzLnN5bWJvbHNHcm91cC5nZXRCQm94KCk7XG4gICAgY29uc3QgY2xpcHBlZFdpZHRoID0gTWF0aC5tYXgobGFzdE1hcmtlcj8uc2l6ZSA/PyAwLCBsYXN0U3ltYm9sUHJvcHM/Lmxlbmd0aCA/PyAwKTtcbiAgICBjb25zdCBjbGlwUmVjdCA9IG5ldyBCQm94KGJib3gueCArIGNsaXBwZWRXaWR0aCAvIDIsIGJib3gueSwgY2xpcHBlZFdpZHRoLCBiYm94LmhlaWdodCk7XG4gICAgdGhpcy5zeW1ib2xzR3JvdXAuc2V0Q2xpcFJlY3QoY2xpcFJlY3QpO1xuICB9XG4gIGNvbXB1dGVCQm94KCkge1xuICAgIGNvbnN0IHsgbGFiZWwsIGxpbmVzLCBtYXJrZXJzIH0gPSB0aGlzO1xuICAgIHJldHVybiB0aGlzLnRvUGFyZW50KEdyb3VwLmNvbXB1dGVDaGlsZHJlbkJCb3goaXRlcmF0ZShbbGFiZWxdLCBsaW5lcywgbWFya2VycyksIGZhbHNlKSk7XG4gIH1cbn07XG5MZWdlbmRNYXJrZXJMYWJlbC5jbGFzc05hbWUgPSBcIk1hcmtlckxhYmVsXCI7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBQcm94eVByb3BlcnR5T25Xcml0ZShcImxhYmVsXCIpXG5dLCBMZWdlbmRNYXJrZXJMYWJlbC5wcm90b3R5cGUsIFwidGV4dFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHlPbldyaXRlKFwibGFiZWxcIilcbl0sIExlZ2VuZE1hcmtlckxhYmVsLnByb3RvdHlwZSwgXCJmb250U3R5bGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBQcm94eVByb3BlcnR5T25Xcml0ZShcImxhYmVsXCIpXG5dLCBMZWdlbmRNYXJrZXJMYWJlbC5wcm90b3R5cGUsIFwiZm9udFdlaWdodFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHlPbldyaXRlKFwibGFiZWxcIilcbl0sIExlZ2VuZE1hcmtlckxhYmVsLnByb3RvdHlwZSwgXCJmb250U2l6ZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHlPbldyaXRlKFwibGFiZWxcIilcbl0sIExlZ2VuZE1hcmtlckxhYmVsLnByb3RvdHlwZSwgXCJmb250RmFtaWx5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgUHJveHlQcm9wZXJ0eU9uV3JpdGUoXCJsYWJlbFwiLCBcImZpbGxcIilcbl0sIExlZ2VuZE1hcmtlckxhYmVsLnByb3RvdHlwZSwgXCJjb2xvclwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvcGFnaW5hdGlvbi9wYWdpbmF0aW9uLnRzXG52YXIgUGFnaW5hdGlvbkxhYmVsID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5jb2xvciA9IFwiYmxhY2tcIjtcbiAgICB0aGlzLmZvbnRTdHlsZSA9IHZvaWQgMDtcbiAgICB0aGlzLmZvbnRXZWlnaHQgPSB2b2lkIDA7XG4gICAgdGhpcy5mb250U2l6ZSA9IDEyO1xuICAgIHRoaXMuZm9udEZhbWlseSA9IFwiVmVyZGFuYSwgc2Fucy1zZXJpZlwiO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HKVxuXSwgUGFnaW5hdGlvbkxhYmVsLnByb3RvdHlwZSwgXCJjb2xvclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZPTlRfU1RZTEUsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFBhZ2luYXRpb25MYWJlbC5wcm90b3R5cGUsIFwiZm9udFN0eWxlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoRk9OVF9XRUlHSFQsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFBhZ2luYXRpb25MYWJlbC5wcm90b3R5cGUsIFwiZm9udFdlaWdodFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIFBhZ2luYXRpb25MYWJlbC5wcm90b3R5cGUsIFwiZm9udFNpemVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcpXG5dLCBQYWdpbmF0aW9uTGFiZWwucHJvdG90eXBlLCBcImZvbnRGYW1pbHlcIiwgMik7XG52YXIgUGFnaW5hdGlvbk1hcmtlclN0eWxlID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5zaXplID0gMTU7XG4gICAgdGhpcy5maWxsID0gdm9pZCAwO1xuICAgIHRoaXMuZmlsbE9wYWNpdHkgPSB2b2lkIDA7XG4gICAgdGhpcy5zdHJva2UgPSB2b2lkIDA7XG4gICAgdGhpcy5zdHJva2VXaWR0aCA9IDE7XG4gICAgdGhpcy5zdHJva2VPcGFjaXR5ID0gMTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIFBhZ2luYXRpb25NYXJrZXJTdHlsZS5wcm90b3R5cGUsIFwic2l6ZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgUGFnaW5hdGlvbk1hcmtlclN0eWxlLnByb3RvdHlwZSwgXCJmaWxsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFBhZ2luYXRpb25NYXJrZXJTdHlsZS5wcm90b3R5cGUsIFwiZmlsbE9wYWNpdHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFBhZ2luYXRpb25NYXJrZXJTdHlsZS5wcm90b3R5cGUsIFwic3Ryb2tlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgUGFnaW5hdGlvbk1hcmtlclN0eWxlLnByb3RvdHlwZSwgXCJzdHJva2VXaWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPKVxuXSwgUGFnaW5hdGlvbk1hcmtlclN0eWxlLnByb3RvdHlwZSwgXCJzdHJva2VPcGFjaXR5XCIsIDIpO1xudmFyIFBhZ2luYXRpb25NYXJrZXIgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IocGFyZW50KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLnNoYXBlID0gVHJpYW5nbGU7XG4gICAgdGhpcy5zaXplID0gMTU7XG4gICAgdGhpcy5wYWRkaW5nID0gODtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEFjdGlvbk9uU2V0KHtcbiAgICBjaGFuZ2VWYWx1ZSgpIHtcbiAgICAgIGlmICh0aGlzLnBhcmVudC5tYXJrZXIgPT09IHRoaXMpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQub25NYXJrZXJTaGFwZUNoYW5nZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSlcbl0sIFBhZ2luYXRpb25NYXJrZXIucHJvdG90eXBlLCBcInNoYXBlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgUGFnaW5hdGlvbk1hcmtlci5wcm90b3R5cGUsIFwic2l6ZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIFBhZ2luYXRpb25NYXJrZXIucHJvdG90eXBlLCBcInBhZGRpbmdcIiwgMik7XG52YXIgUGFnaW5hdGlvbiA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcihjaGFydFVwZGF0ZUNhbGxiYWNrLCBwYWdlVXBkYXRlQ2FsbGJhY2spIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY2hhcnRVcGRhdGVDYWxsYmFjayA9IGNoYXJ0VXBkYXRlQ2FsbGJhY2s7XG4gICAgdGhpcy5wYWdlVXBkYXRlQ2FsbGJhY2sgPSBwYWdlVXBkYXRlQ2FsbGJhY2s7XG4gICAgdGhpcy5pZCA9IGNyZWF0ZUlkKHRoaXMpO1xuICAgIHRoaXMubWFya2VyID0gbmV3IFBhZ2luYXRpb25NYXJrZXIodGhpcyk7XG4gICAgdGhpcy5hY3RpdmVTdHlsZSA9IG5ldyBQYWdpbmF0aW9uTWFya2VyU3R5bGUoKTtcbiAgICB0aGlzLmluYWN0aXZlU3R5bGUgPSBuZXcgUGFnaW5hdGlvbk1hcmtlclN0eWxlKCk7XG4gICAgdGhpcy5oaWdobGlnaHRTdHlsZSA9IG5ldyBQYWdpbmF0aW9uTWFya2VyU3R5bGUoKTtcbiAgICB0aGlzLmxhYmVsID0gbmV3IFBhZ2luYXRpb25MYWJlbCgpO1xuICAgIHRoaXMuZ3JvdXAgPSBuZXcgVHJhbnNsYXRhYmxlR3JvdXAoeyBuYW1lOiBcInBhZ2luYXRpb25cIiB9KTtcbiAgICB0aGlzLmxhYmVsTm9kZSA9IG5ldyBUZXh0KCk7XG4gICAgdGhpcy5kZXN0cm95Rm5zID0gW107XG4gICAgdGhpcy50b3RhbFBhZ2VzID0gMDtcbiAgICB0aGlzLmN1cnJlbnRQYWdlID0gMDtcbiAgICB0aGlzLnRyYW5zbGF0aW9uWCA9IDA7XG4gICAgdGhpcy50cmFuc2xhdGlvblkgPSAwO1xuICAgIHRoaXMubmV4dEJ1dHRvbkRpc2FibGVkID0gZmFsc2U7XG4gICAgdGhpcy5wcmV2aW91c0J1dHRvbkRpc2FibGVkID0gZmFsc2U7XG4gICAgdGhpcy5fdmlzaWJsZSA9IHRydWU7XG4gICAgdGhpcy5fZW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5fb3JpZW50YXRpb24gPSBcInZlcnRpY2FsXCI7XG4gICAgdGhpcy5fbmV4dEJ1dHRvbiA9IG5ldyBUcmlhbmdsZSgpO1xuICAgIHRoaXMuX3ByZXZpb3VzQnV0dG9uID0gbmV3IFRyaWFuZ2xlKCk7XG4gICAgdGhpcy5sYWJlbE5vZGUuc2V0UHJvcGVydGllcyh7XG4gICAgICB0ZXh0QmFzZWxpbmU6IFwibWlkZGxlXCIsXG4gICAgICBmb250U2l6ZTogMTIsXG4gICAgICBmb250RmFtaWx5OiBcIlZlcmRhbmEsIHNhbnMtc2VyaWZcIixcbiAgICAgIGZpbGw6IFwiYmxhY2tcIixcbiAgICAgIHk6IDFcbiAgICB9KTtcbiAgICB0aGlzLmdyb3VwLmFwcGVuZChbdGhpcy5uZXh0QnV0dG9uLCB0aGlzLnByZXZpb3VzQnV0dG9uLCB0aGlzLmxhYmVsTm9kZV0pO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gICAgdGhpcy51cGRhdGVNYXJrZXJzKCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRlc3Ryb3lGbnMuZm9yRWFjaCgoZikgPT4gZigpKTtcbiAgfVxuICBzZXQgdmlzaWJsZSh2YWx1ZSkge1xuICAgIHRoaXMuX3Zpc2libGUgPSB2YWx1ZTtcbiAgICB0aGlzLnVwZGF0ZUdyb3VwVmlzaWJpbGl0eSgpO1xuICB9XG4gIGdldCB2aXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl92aXNpYmxlO1xuICB9XG4gIHNldCBlbmFibGVkKHZhbHVlKSB7XG4gICAgdGhpcy5fZW5hYmxlZCA9IHZhbHVlO1xuICAgIHRoaXMudXBkYXRlR3JvdXBWaXNpYmlsaXR5KCk7XG4gIH1cbiAgZ2V0IGVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuYWJsZWQ7XG4gIH1cbiAgdXBkYXRlR3JvdXBWaXNpYmlsaXR5KCkge1xuICAgIHRoaXMuZ3JvdXAudmlzaWJsZSA9IHRoaXMuZW5hYmxlZCAmJiB0aGlzLnZpc2libGU7XG4gIH1cbiAgc2V0IG9yaWVudGF0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5fb3JpZW50YXRpb24gPSB2YWx1ZTtcbiAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICBjYXNlIFwiaG9yaXpvbnRhbFwiOiB7XG4gICAgICAgIHRoaXMucHJldmlvdXNCdXR0b24ucm90YXRpb24gPSAtTWF0aC5QSSAvIDI7XG4gICAgICAgIHRoaXMubmV4dEJ1dHRvbi5yb3RhdGlvbiA9IE1hdGguUEkgLyAyO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJ2ZXJ0aWNhbFwiOlxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICB0aGlzLnByZXZpb3VzQnV0dG9uLnJvdGF0aW9uID0gMDtcbiAgICAgICAgdGhpcy5uZXh0QnV0dG9uLnJvdGF0aW9uID0gTWF0aC5QSTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0IG9yaWVudGF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9vcmllbnRhdGlvbjtcbiAgfVxuICBzZXQgbmV4dEJ1dHRvbih2YWx1ZSkge1xuICAgIGlmICh0aGlzLl9uZXh0QnV0dG9uICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5ncm91cC5yZW1vdmVDaGlsZCh0aGlzLl9uZXh0QnV0dG9uKTtcbiAgICAgIHRoaXMuX25leHRCdXR0b24gPSB2YWx1ZTtcbiAgICAgIHRoaXMuZ3JvdXAuYXBwZW5kQ2hpbGQodmFsdWUpO1xuICAgIH1cbiAgfVxuICBnZXQgbmV4dEJ1dHRvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbmV4dEJ1dHRvbjtcbiAgfVxuICBzZXQgcHJldmlvdXNCdXR0b24odmFsdWUpIHtcbiAgICBpZiAodGhpcy5fcHJldmlvdXNCdXR0b24gIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLmdyb3VwLnJlbW92ZUNoaWxkKHRoaXMuX3ByZXZpb3VzQnV0dG9uKTtcbiAgICAgIHRoaXMuX3ByZXZpb3VzQnV0dG9uID0gdmFsdWU7XG4gICAgICB0aGlzLmdyb3VwLmFwcGVuZENoaWxkKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHByZXZpb3VzQnV0dG9uKCkge1xuICAgIHJldHVybiB0aGlzLl9wcmV2aW91c0J1dHRvbjtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgdGhpcy51cGRhdGVMYWJlbCgpO1xuICAgIHRoaXMudXBkYXRlUG9zaXRpb25zKCk7XG4gICAgdGhpcy5lbmFibGVPckRpc2FibGVCdXR0b25zKCk7XG4gIH1cbiAgdXBkYXRlUG9zaXRpb25zKCkge1xuICAgIHRoaXMuZ3JvdXAudHJhbnNsYXRpb25YID0gdGhpcy50cmFuc2xhdGlvblg7XG4gICAgdGhpcy5ncm91cC50cmFuc2xhdGlvblkgPSB0aGlzLnRyYW5zbGF0aW9uWTtcbiAgICB0aGlzLnVwZGF0ZUxhYmVsUG9zaXRpb24oKTtcbiAgICB0aGlzLnVwZGF0ZU5leHRCdXR0b25Qb3NpdGlvbigpO1xuICB9XG4gIHVwZGF0ZUxhYmVsUG9zaXRpb24oKSB7XG4gICAgY29uc3QgeyBzaXplOiBtYXJrZXJTaXplLCBwYWRkaW5nOiBtYXJrZXJQYWRkaW5nIH0gPSB0aGlzLm1hcmtlcjtcbiAgICB0aGlzLm5leHRCdXR0b24uc2l6ZSA9IG1hcmtlclNpemU7XG4gICAgdGhpcy5wcmV2aW91c0J1dHRvbi5zaXplID0gbWFya2VyU2l6ZTtcbiAgICB0aGlzLmxhYmVsTm9kZS54ID0gbWFya2VyU2l6ZSAvIDIgKyBtYXJrZXJQYWRkaW5nO1xuICB9XG4gIHVwZGF0ZU5leHRCdXR0b25Qb3NpdGlvbigpIHtcbiAgICBjb25zdCBsYWJlbEJCb3ggPSB0aGlzLmxhYmVsTm9kZS5nZXRCQm94KCk7XG4gICAgdGhpcy5uZXh0QnV0dG9uLnRyYW5zbGF0aW9uWCA9IGxhYmVsQkJveC53aWR0aCArICh0aGlzLm1hcmtlci5zaXplIC8gMiArIHRoaXMubWFya2VyLnBhZGRpbmcpICogMjtcbiAgfVxuICB1cGRhdGVMYWJlbCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBjdXJyZW50UGFnZSxcbiAgICAgIHRvdGFsUGFnZXM6IHBhZ2VzLFxuICAgICAgbGFiZWxOb2RlLFxuICAgICAgbGFiZWw6IHsgY29sb3IsIGZvbnRTdHlsZSwgZm9udFdlaWdodCwgZm9udFNpemUsIGZvbnRGYW1pbHkgfVxuICAgIH0gPSB0aGlzO1xuICAgIGxhYmVsTm9kZS50ZXh0ID0gYCR7Y3VycmVudFBhZ2UgKyAxfSAvICR7cGFnZXN9YDtcbiAgICBsYWJlbE5vZGUuZmlsbCA9IGNvbG9yO1xuICAgIGxhYmVsTm9kZS5mb250U3R5bGUgPSBmb250U3R5bGU7XG4gICAgbGFiZWxOb2RlLmZvbnRXZWlnaHQgPSBmb250V2VpZ2h0O1xuICAgIGxhYmVsTm9kZS5mb250U2l6ZSA9IGZvbnRTaXplO1xuICAgIGxhYmVsTm9kZS5mb250RmFtaWx5ID0gZm9udEZhbWlseTtcbiAgfVxuICB1cGRhdGVNYXJrZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG5leHRCdXR0b24sXG4gICAgICBwcmV2aW91c0J1dHRvbixcbiAgICAgIG5leHRCdXR0b25EaXNhYmxlZCxcbiAgICAgIHByZXZpb3VzQnV0dG9uRGlzYWJsZWQsXG4gICAgICBhY3RpdmVTdHlsZSxcbiAgICAgIGluYWN0aXZlU3R5bGUsXG4gICAgICBoaWdobGlnaHRTdHlsZSxcbiAgICAgIGhpZ2hsaWdodEFjdGl2ZVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGJ1dHRvblN0eWxlID0gKGJ1dHRvbiwgZGlzYWJsZWQpID0+IHtcbiAgICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgICByZXR1cm4gaW5hY3RpdmVTdHlsZTtcbiAgICAgIH0gZWxzZSBpZiAoYnV0dG9uID09PSBoaWdobGlnaHRBY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuIGhpZ2hsaWdodFN0eWxlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjdGl2ZVN0eWxlO1xuICAgIH07XG4gICAgdGhpcy51cGRhdGVNYXJrZXIobmV4dEJ1dHRvbiwgYnV0dG9uU3R5bGUoXCJuZXh0XCIsIG5leHRCdXR0b25EaXNhYmxlZCkpO1xuICAgIHRoaXMudXBkYXRlTWFya2VyKHByZXZpb3VzQnV0dG9uLCBidXR0b25TdHlsZShcInByZXZpb3VzXCIsIHByZXZpb3VzQnV0dG9uRGlzYWJsZWQpKTtcbiAgfVxuICB1cGRhdGVNYXJrZXIobWFya2VyLCBzdHlsZSkge1xuICAgIGNvbnN0IHsgc2l6ZSB9ID0gdGhpcy5tYXJrZXI7XG4gICAgbWFya2VyLnNpemUgPSBzaXplO1xuICAgIG1hcmtlci5maWxsID0gc3R5bGUuZmlsbDtcbiAgICBtYXJrZXIuZmlsbE9wYWNpdHkgPSBzdHlsZS5maWxsT3BhY2l0eSA/PyAxO1xuICAgIG1hcmtlci5zdHJva2UgPSBzdHlsZS5zdHJva2U7XG4gICAgbWFya2VyLnN0cm9rZVdpZHRoID0gc3R5bGUuc3Ryb2tlV2lkdGg7XG4gICAgbWFya2VyLnN0cm9rZU9wYWNpdHkgPSBzdHlsZS5zdHJva2VPcGFjaXR5O1xuICB9XG4gIGVuYWJsZU9yRGlzYWJsZUJ1dHRvbnMoKSB7XG4gICAgY29uc3QgeyBjdXJyZW50UGFnZSwgdG90YWxQYWdlcyB9ID0gdGhpcztcbiAgICBjb25zdCB6ZXJvUGFnZXNUb0Rpc3BsYXkgPSB0b3RhbFBhZ2VzID09PSAwO1xuICAgIGNvbnN0IG9uTGFzdFBhZ2UgPSBjdXJyZW50UGFnZSA9PT0gdG90YWxQYWdlcyAtIDE7XG4gICAgY29uc3Qgb25GaXJzdFBhZ2UgPSBjdXJyZW50UGFnZSA9PT0gMDtcbiAgICB0aGlzLm5leHRCdXR0b25EaXNhYmxlZCA9IG9uTGFzdFBhZ2UgfHwgemVyb1BhZ2VzVG9EaXNwbGF5O1xuICAgIHRoaXMucHJldmlvdXNCdXR0b25EaXNhYmxlZCA9IG9uRmlyc3RQYWdlIHx8IHplcm9QYWdlc1RvRGlzcGxheTtcbiAgfVxuICBzZXRQYWdlKHBhZ2VOdW1iZXIpIHtcbiAgICBwYWdlTnVtYmVyID0gY2xhbXAoMCwgcGFnZU51bWJlciwgdGhpcy50b3RhbFBhZ2VzIC0gMSk7XG4gICAgaWYgKHRoaXMuY3VycmVudFBhZ2UgIT09IHBhZ2VOdW1iZXIpIHtcbiAgICAgIHRoaXMuY3VycmVudFBhZ2UgPSBwYWdlTnVtYmVyO1xuICAgICAgdGhpcy5vblBhZ2luYXRpb25DaGFuZ2VkKCk7XG4gICAgfVxuICB9XG4gIGdldEN1cnNvcihub2RlKSB7XG4gICAgcmV0dXJuIHsgcHJldmlvdXM6IHRoaXMucHJldmlvdXNCdXR0b25EaXNhYmxlZCwgbmV4dDogdGhpcy5uZXh0QnV0dG9uRGlzYWJsZWQgfVtub2RlXSA/IHZvaWQgMCA6IFwicG9pbnRlclwiO1xuICB9XG4gIG9uQ2xpY2soZXZlbnQsIG5vZGUpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmIChub2RlID09PSBcIm5leHRcIiAmJiAhdGhpcy5uZXh0QnV0dG9uRGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuaW5jcmVtZW50UGFnZSgpO1xuICAgICAgdGhpcy5vblBhZ2luYXRpb25DaGFuZ2VkKCk7XG4gICAgfSBlbHNlIGlmIChub2RlID09PSBcInByZXZpb3VzXCIgJiYgIXRoaXMucHJldmlvdXNCdXR0b25EaXNhYmxlZCkge1xuICAgICAgdGhpcy5kZWNyZW1lbnRQYWdlKCk7XG4gICAgICB0aGlzLm9uUGFnaW5hdGlvbkNoYW5nZWQoKTtcbiAgICB9XG4gIH1cbiAgb25Nb3VzZUhvdmVyKG5vZGUpIHtcbiAgICB0aGlzLmhpZ2hsaWdodEFjdGl2ZSA9IG5vZGU7XG4gICAgdGhpcy51cGRhdGVNYXJrZXJzKCk7XG4gICAgdGhpcy5jaGFydFVwZGF0ZUNhbGxiYWNrKDYgLyogU0NFTkVfUkVOREVSICovKTtcbiAgfVxuICBvblBhZ2luYXRpb25DaGFuZ2VkKCkge1xuICAgIHRoaXMucGFnZVVwZGF0ZUNhbGxiYWNrKHRoaXMuY3VycmVudFBhZ2UpO1xuICB9XG4gIGluY3JlbWVudFBhZ2UoKSB7XG4gICAgdGhpcy5jdXJyZW50UGFnZSA9IE1hdGgubWluKHRoaXMuY3VycmVudFBhZ2UgKyAxLCB0aGlzLnRvdGFsUGFnZXMgLSAxKTtcbiAgfVxuICBkZWNyZW1lbnRQYWdlKCkge1xuICAgIHRoaXMuY3VycmVudFBhZ2UgPSBNYXRoLm1heCh0aGlzLmN1cnJlbnRQYWdlIC0gMSwgMCk7XG4gIH1cbiAgb25NYXJrZXJTaGFwZUNoYW5nZSgpIHtcbiAgICBjb25zdCBNYXJrZXIyID0gUm90YXRhYmxlKGdldE1hcmtlcih0aGlzLm1hcmtlci5zaGFwZSB8fCBUcmlhbmdsZSkpO1xuICAgIHRoaXMucHJldmlvdXNCdXR0b24gPSBuZXcgTWFya2VyMigpO1xuICAgIHRoaXMubmV4dEJ1dHRvbiA9IG5ldyBNYXJrZXIyKCk7XG4gICAgdGhpcy51cGRhdGVQb3NpdGlvbnMoKTtcbiAgICB0aGlzLnVwZGF0ZU1hcmtlcnMoKTtcbiAgICB0aGlzLmNoYXJ0VXBkYXRlQ2FsbGJhY2soNiAvKiBTQ0VORV9SRU5ERVIgKi8pO1xuICB9XG4gIGF0dGFjaFBhZ2luYXRpb24obm9kZSkge1xuICAgIG5vZGUuYXBwZW5kKHRoaXMuZ3JvdXApO1xuICB9XG4gIGdldEJCb3goKSB7XG4gICAgcmV0dXJuIHRoaXMuZ3JvdXAuZ2V0QkJveCgpO1xuICB9XG4gIGNvbXB1dGVDU1NCb3VuZHMoKSB7XG4gICAgY29uc3QgcHJldiA9IFRyYW5zZm9ybWFibGUudG9DYW52YXModGhpcy5wcmV2aW91c0J1dHRvbik7XG4gICAgY29uc3QgbmV4dCA9IFRyYW5zZm9ybWFibGUudG9DYW52YXModGhpcy5uZXh0QnV0dG9uKTtcbiAgICByZXR1cm4geyBwcmV2LCBuZXh0IH07XG4gIH1cbn07XG5QYWdpbmF0aW9uLmNsYXNzTmFtZSA9IFwiUGFnaW5hdGlvblwiO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgUGFnaW5hdGlvbi5wcm90b3R5cGUsIFwibWFya2VyXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgUGFnaW5hdGlvbi5wcm90b3R5cGUsIFwiYWN0aXZlU3R5bGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBQYWdpbmF0aW9uLnByb3RvdHlwZSwgXCJpbmFjdGl2ZVN0eWxlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgUGFnaW5hdGlvbi5wcm90b3R5cGUsIFwiaGlnaGxpZ2h0U3R5bGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBQYWdpbmF0aW9uLnByb3RvdHlwZSwgXCJsYWJlbFwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbGVnZW5kLnRzXG52YXIgTGVnZW5kTGFiZWwgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLm1heExlbmd0aCA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbG9yID0gXCJibGFja1wiO1xuICAgIHRoaXMuZm9udFN0eWxlID0gdm9pZCAwO1xuICAgIHRoaXMuZm9udFdlaWdodCA9IHZvaWQgMDtcbiAgICB0aGlzLmZvbnRTaXplID0gMTI7XG4gICAgdGhpcy5mb250RmFtaWx5ID0gXCJWZXJkYW5hLCBzYW5zLXNlcmlmXCI7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIExlZ2VuZExhYmVsLnByb3RvdHlwZSwgXCJtYXhMZW5ndGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcpXG5dLCBMZWdlbmRMYWJlbC5wcm90b3R5cGUsIFwiY29sb3JcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGT05UX1NUWUxFLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBMZWdlbmRMYWJlbC5wcm90b3R5cGUsIFwiZm9udFN0eWxlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoRk9OVF9XRUlHSFQsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIExlZ2VuZExhYmVsLnByb3RvdHlwZSwgXCJmb250V2VpZ2h0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgTGVnZW5kTGFiZWwucHJvdG90eXBlLCBcImZvbnRTaXplXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HKVxuXSwgTGVnZW5kTGFiZWwucHJvdG90eXBlLCBcImZvbnRGYW1pbHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGVU5DVElPTiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGVnZW5kTGFiZWwucHJvdG90eXBlLCBcImZvcm1hdHRlclwiLCAyKTtcbnZhciBMZWdlbmRNYXJrZXIgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnNpemUgPSAxNTtcbiAgICB0aGlzLnBhZGRpbmcgPSA4O1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgT2JzZXJ2ZUNoYW5nZXMoKHRhcmdldCkgPT4gdGFyZ2V0LnBhcmVudD8ub25NYXJrZXJTaGFwZUNoYW5nZSgpKVxuXSwgTGVnZW5kTWFya2VyLnByb3RvdHlwZSwgXCJzaGFwZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIExlZ2VuZE1hcmtlci5wcm90b3R5cGUsIFwic2l6ZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIExlZ2VuZE1hcmtlci5wcm90b3R5cGUsIFwicGFkZGluZ1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGVnZW5kTWFya2VyLnByb3RvdHlwZSwgXCJzdHJva2VXaWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBMZWdlbmRNYXJrZXIucHJvdG90eXBlLCBcImVuYWJsZWRcIiwgMik7XG52YXIgTGVnZW5kTGluZSA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGVnZW5kTGluZS5wcm90b3R5cGUsIFwic3Ryb2tlV2lkdGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIExlZ2VuZExpbmUucHJvdG90eXBlLCBcImxlbmd0aFwiLCAyKTtcbnZhciBMZWdlbmRJdGVtID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5wYWRkaW5nWCA9IDE2O1xuICAgIHRoaXMucGFkZGluZ1kgPSA4O1xuICAgIHRoaXMuc2hvd1Nlcmllc1N0cm9rZSA9IGZhbHNlO1xuICAgIHRoaXMubWFya2VyID0gbmV3IExlZ2VuZE1hcmtlcigpO1xuICAgIHRoaXMubGFiZWwgPSBuZXcgTGVnZW5kTGFiZWwoKTtcbiAgICB0aGlzLmxpbmUgPSBuZXcgTGVnZW5kTGluZSgpO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBMZWdlbmRJdGVtLnByb3RvdHlwZSwgXCJtYXhXaWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIExlZ2VuZEl0ZW0ucHJvdG90eXBlLCBcInBhZGRpbmdYXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgTGVnZW5kSXRlbS5wcm90b3R5cGUsIFwicGFkZGluZ1lcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgTGVnZW5kSXRlbS5wcm90b3R5cGUsIFwic2hvd1Nlcmllc1N0cm9rZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIExlZ2VuZEl0ZW0ucHJvdG90eXBlLCBcIm1hcmtlclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIExlZ2VuZEl0ZW0ucHJvdG90eXBlLCBcImxhYmVsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgTGVnZW5kSXRlbS5wcm90b3R5cGUsIFwibGluZVwiLCAyKTtcbnZhciBMZWdlbmRMaXN0ZW5lcnMgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGVU5DVElPTiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGVnZW5kTGlzdGVuZXJzLnByb3RvdHlwZSwgXCJsZWdlbmRJdGVtQ2xpY2tcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGVU5DVElPTiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGVnZW5kTGlzdGVuZXJzLnByb3RvdHlwZSwgXCJsZWdlbmRJdGVtRG91YmxlQ2xpY2tcIiwgMik7XG52YXIgSURfTEVHRU5EX1ZJU0lCSUxJVFkgPSBcImxlZ2VuZC12aXNpYmlsaXR5XCI7XG52YXIgSURfTEVHRU5EX09USEVSX1NFUklFUyA9IFwibGVnZW5kLW90aGVyLXNlcmllc1wiO1xudmFyIExlZ2VuZEl0ZW1FdmVudCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IodHlwZSwgZW5hYmxlZCwgaXRlbUlkLCBzZXJpZXNJZCwgZXZlbnQpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuZW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgdGhpcy5pdGVtSWQgPSBpdGVtSWQ7XG4gICAgdGhpcy5zZXJpZXNJZCA9IHNlcmllc0lkO1xuICAgIHRoaXMuZXZlbnQgPSBldmVudDtcbiAgICB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSBmYWxzZTtcbiAgfVxuICBwcmV2ZW50RGVmYXVsdCgpIHtcbiAgICB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICB9XG59O1xudmFyIExlZ2VuZCA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcihjdHgpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMuaWQgPSBjcmVhdGVJZCh0aGlzKTtcbiAgICB0aGlzLmdyb3VwID0gbmV3IFRyYW5zbGF0YWJsZUxheWVyKHsgbmFtZTogXCJsZWdlbmRcIiwgekluZGV4OiAxNSAvKiBMRUdFTkQgKi8gfSk7XG4gICAgdGhpcy5pdGVtU2VsZWN0aW9uID0gU2VsZWN0aW9uLnNlbGVjdChcbiAgICAgIHRoaXMuZ3JvdXAsXG4gICAgICBMZWdlbmRNYXJrZXJMYWJlbFxuICAgICk7XG4gICAgdGhpcy5zcHJpdGVSZW5kZXJlciA9IHZvaWQgMDtcbiAgICB0aGlzLm9sZFNpemUgPSBbMCwgMF07XG4gICAgdGhpcy5wYWdlcyA9IFtdO1xuICAgIHRoaXMubWF4UGFnZVNpemUgPSBbMCwgMF07XG4gICAgLyoqIEl0ZW0gaW5kZXggdG8gdHJhY2sgb24gcmUtcGFnaW5hdGlvbiwgc28gY3VycmVudCBwYWdlIHVwZGF0ZXMgYXBwcm9wcmlhdGVseS4gKi9cbiAgICB0aGlzLnBhZ2luYXRpb25UcmFja2luZ0luZGV4ID0gMDtcbiAgICB0aGlzLnRydW5jYXRlZEl0ZW1zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLl9kYXRhID0gW107XG4gICAgdGhpcy5fc3ltYm9sc0RpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzLnRvZ2dsZVNlcmllcyA9IHRydWU7XG4gICAgdGhpcy5pdGVtID0gbmV3IExlZ2VuZEl0ZW0oKTtcbiAgICB0aGlzLmxpc3RlbmVycyA9IG5ldyBMZWdlbmRMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMucG9zaXRpb24gPSBcImJvdHRvbVwiO1xuICAgIHRoaXMuc3BhY2luZyA9IDIwO1xuICAgIHRoaXMuZGVzdHJveUZucyA9IFtdO1xuICAgIHRoaXMucHJveHlMZWdlbmREaXJ0eSA9IHRydWU7XG4gICAgdGhpcy5wcm94eUxlZ2VuZFRvb2xiYXJEZXN0cm95Rm5zID0gbmV3IERlc3Ryb3lGbnMoKTtcbiAgICB0aGlzLnNpemUgPSBbMCwgMF07XG4gICAgdGhpcy5fdmlzaWJsZSA9IHRydWU7XG4gICAgdGhpcy5pdGVtLm1hcmtlci5wYXJlbnQgPSB0aGlzO1xuICAgIHRoaXMucGFnaW5hdGlvbiA9IG5ldyBQYWdpbmF0aW9uKFxuICAgICAgKHR5cGUpID0+IGN0eC51cGRhdGVTZXJ2aWNlLnVwZGF0ZSh0eXBlKSxcbiAgICAgIChwYWdlKSA9PiB0aGlzLnVwZGF0ZVBhZ2VOdW1iZXIocGFnZSlcbiAgICApO1xuICAgIHRoaXMucGFnaW5hdGlvbi5hdHRhY2hQYWdpbmF0aW9uKHRoaXMuZ3JvdXApO1xuICAgIHRoaXMuZGVzdHJveUZucy5wdXNoKFxuICAgICAgY3R4LmNvbnRleHRNZW51UmVnaXN0cnkucmVnaXN0ZXJEZWZhdWx0QWN0aW9uKHtcbiAgICAgICAgaWQ6IElEX0xFR0VORF9WSVNJQklMSVRZLFxuICAgICAgICB0eXBlOiBcImxlZ2VuZFwiLFxuICAgICAgICBsYWJlbDogXCJjb250ZXh0TWVudVRvZ2dsZVNlcmllc1Zpc2liaWxpdHlcIixcbiAgICAgICAgYWN0aW9uOiAocGFyYW1zKSA9PiB0aGlzLmNvbnRleHRUb2dnbGVWaXNpYmlsaXR5KHBhcmFtcylcbiAgICAgIH0pLFxuICAgICAgY3R4LmNvbnRleHRNZW51UmVnaXN0cnkucmVnaXN0ZXJEZWZhdWx0QWN0aW9uKHtcbiAgICAgICAgaWQ6IElEX0xFR0VORF9PVEhFUl9TRVJJRVMsXG4gICAgICAgIHR5cGU6IFwibGVnZW5kXCIsXG4gICAgICAgIGxhYmVsOiBcImNvbnRleHRNZW51VG9nZ2xlT3RoZXJTZXJpZXNcIixcbiAgICAgICAgYWN0aW9uOiAocGFyYW1zKSA9PiB0aGlzLmNvbnRleHRUb2dnbGVPdGhlclNlcmllcyhwYXJhbXMpXG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy5kZXN0cm95Rm5zLnB1c2goXG4gICAgICBjdHgubGF5b3V0TWFuYWdlci5yZWdpc3RlckVsZW1lbnQoMSAvKiBMZWdlbmQgKi8sIChlKSA9PiB0aGlzLnBvc2l0aW9uTGVnZW5kKGUpKSxcbiAgICAgIGN0eC5sb2NhbGVNYW5hZ2VyLmFkZExpc3RlbmVyKFwibG9jYWxlLWNoYW5nZWRcIiwgKCkgPT4gdGhpcy5vbkxvY2FsZUNoYW5nZWQoKSksXG4gICAgICAoKSA9PiB0aGlzLmdyb3VwLnJlbW92ZSgpXG4gICAgKTtcbiAgICB0aGlzLnByb3h5TGVnZW5kVG9vbGJhciA9IHRoaXMuY3R4LnByb3h5SW50ZXJhY3Rpb25TZXJ2aWNlLmNyZWF0ZVByb3h5Q29udGFpbmVyKHtcbiAgICAgIHR5cGU6IFwibGlzdFwiLFxuICAgICAgaWQ6IGAke3RoaXMuaWR9LXRvb2xiYXJgLFxuICAgICAgY2xhc3NMaXN0OiBbXCJhZy1jaGFydHMtcHJveHktbGVnZW5kLXRvb2xiYXJcIl0sXG4gICAgICBhcmlhTGFiZWw6IHsgaWQ6IFwiYXJpYUxhYmVsTGVnZW5kXCIgfSxcbiAgICAgIGFyaWFIaWRkZW46IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLnByb3h5TGVnZW5kUGFnaW5hdGlvbiA9IHRoaXMuY3R4LnByb3h5SW50ZXJhY3Rpb25TZXJ2aWNlLmNyZWF0ZVByb3h5Q29udGFpbmVyKHtcbiAgICAgIHR5cGU6IFwiZ3JvdXBcIixcbiAgICAgIGlkOiBgJHt0aGlzLmlkfS1wYWdpbmF0aW9uYCxcbiAgICAgIGNsYXNzTGlzdDogW1wiYWctY2hhcnRzLXByb3h5LWxlZ2VuZC1wYWdpbmF0aW9uXCJdLFxuICAgICAgYXJpYUxhYmVsOiB7IGlkOiBcImFyaWFMYWJlbExlZ2VuZFBhZ2luYXRpb25cIiB9LFxuICAgICAgYXJpYU9yaWVudGF0aW9uOiBcImhvcml6b250YWxcIixcbiAgICAgIGFyaWFIaWRkZW46IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLnByb3h5TGVnZW5kSXRlbURlc2NyaXB0aW9uID0gY3JlYXRlRWxlbWVudChcInBcIik7XG4gICAgdGhpcy5wcm94eUxlZ2VuZEl0ZW1EZXNjcmlwdGlvbi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgdGhpcy5wcm94eUxlZ2VuZEl0ZW1EZXNjcmlwdGlvbi5pZCA9IGAke3RoaXMuaWR9LWFyaWFEZXNjcmlwdGlvbmA7XG4gICAgdGhpcy5wcm94eUxlZ2VuZEl0ZW1EZXNjcmlwdGlvbi50ZXh0Q29udGVudCA9IHRoaXMuZ2V0SXRlbUFyaWFEZXNjcmlwdGlvbigpO1xuICAgIHRoaXMucHJveHlMZWdlbmRUb29sYmFyLmFwcGVuZCh0aGlzLnByb3h5TGVnZW5kSXRlbURlc2NyaXB0aW9uKTtcbiAgfVxuICBzZXQgZGF0YSh2YWx1ZSkge1xuICAgIHRoaXMub25EYXRhVXBkYXRlKHRoaXMuX2RhdGEsIHZhbHVlKTtcbiAgICB0aGlzLl9kYXRhID0gdmFsdWU7XG4gICAgdGhpcy5fc3ltYm9sc0RpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzLnVwZGF0ZUdyb3VwVmlzaWJpbGl0eSgpO1xuICB9XG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5jdHguZG9tTWFuYWdlci5yZW1vdmVDaGlsZChcImNhbnZhcy1vdmVybGF5XCIsIGAke3RoaXMuaWR9LXRvb2xiYXJgKTtcbiAgICB0aGlzLmN0eC5kb21NYW5hZ2VyLnJlbW92ZUNoaWxkKFwiY2FudmFzLW92ZXJsYXlcIiwgYCR7dGhpcy5pZH0tcGFnaW5hdGlvbmApO1xuICAgIHRoaXMuZGVzdHJveUZucy5mb3JFYWNoKChmKSA9PiBmKCkpO1xuICAgIHRoaXMucGFnaW5hdGlvbi5kZXN0cm95KCk7XG4gICAgdGhpcy5pdGVtU2VsZWN0aW9uLmNsZWFyKCk7XG4gICAgdGhpcy5wcm94eUxlZ2VuZFRvb2xiYXJEZXN0cm95Rm5zLmRlc3Ryb3koKTtcbiAgfVxuICBpbml0TGVnZW5kSXRlbVRvb2xiYXIoKSB7XG4gICAgaWYgKCF0aGlzLnByb3h5TGVnZW5kRGlydHkpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5pdGVtU2VsZWN0aW9uLmVhY2goKG1hcmtlckxhYmVsLCBfLCBpKSA9PiB7XG4gICAgICBtYXJrZXJMYWJlbC5kZXN0cm95UHJveHlCdXR0b24oKTtcbiAgICAgIG1hcmtlckxhYmVsLnByb3h5QnV0dG9uID8/IChtYXJrZXJMYWJlbC5wcm94eUJ1dHRvbiA9IHRoaXMuY3R4LnByb3h5SW50ZXJhY3Rpb25TZXJ2aWNlLmNyZWF0ZVByb3h5RWxlbWVudCh7XG4gICAgICAgIHR5cGU6IFwibGlzdHN3aXRjaFwiLFxuICAgICAgICBpZDogYGFnLWNoYXJ0cy1sZWdlbmQtaXRlbS0ke2l9YCxcbiAgICAgICAgdGV4dENvbnRlbnQ6IHRoaXMuZ2V0SXRlbUFyaWFUZXh0KGkpLFxuICAgICAgICBhcmlhQ2hlY2tlZDogISFtYXJrZXJMYWJlbC5kYXR1bS5lbmFibGVkLFxuICAgICAgICBhcmlhRGVzY3JpYmVkQnk6IHRoaXMucHJveHlMZWdlbmRJdGVtRGVzY3JpcHRpb24uaWQsXG4gICAgICAgIHBhcmVudDogdGhpcy5wcm94eUxlZ2VuZFRvb2xiYXIsXG4gICAgICAgIC8vIFJldHJpZXZlIHRoZSBkYXR1bSBmcm9tIHRoZSBub2RlIHJhdGhlciB0aGFuIGZyb20gdGhlIG1ldGhvZCBwYXJhbWV0ZXIuXG4gICAgICAgIC8vIFRoZSBtZXRob2QgcGFyYW1ldGVyIGBkYXR1bWAgZ2V0cyBkZXN0cm95ZWQgd2hlbiB0aGUgZGF0YSBpcyByZWZyZXNoZWRcbiAgICAgICAgLy8gdXNpbmcgU2VyaWVzLmdldExlZ2VuZERhdGEoKS4gQnV0IHRoZSBzY2VuZSBub2RlIHdpbGwgc3RheSB0aGUgc2FtZS5cbiAgICAgICAgb25jbGljazogKGV2KSA9PiB0aGlzLm9uQ2xpY2soZXYsIG1hcmtlckxhYmVsLmRhdHVtLCBtYXJrZXJMYWJlbC5wcm94eUJ1dHRvbi5idXR0b24pLFxuICAgICAgICBvbmRibGNsaWNrOiAoZXYpID0+IHRoaXMub25Eb3VibGVDbGljayhldiwgbWFya2VyTGFiZWwuZGF0dW0pLFxuICAgICAgICBvbm1vdXNlZW50ZXI6IChldikgPT4gdGhpcy5vbkhvdmVyKGV2LCBtYXJrZXJMYWJlbCksXG4gICAgICAgIG9ubW91c2VsZWF2ZTogKCkgPT4gdGhpcy5vbkxlYXZlKCksXG4gICAgICAgIG9uY29udGV4dG1lbnU6IChldikgPT4gdGhpcy5vbkNvbnRleHRDbGljayhldiwgbWFya2VyTGFiZWwpLFxuICAgICAgICBvbmJsdXI6ICgpID0+IHRoaXMub25MZWF2ZSgpLFxuICAgICAgICBvbmZvY3VzOiAoZXYpID0+IHRoaXMub25Ib3ZlcihldiwgbWFya2VyTGFiZWwpXG4gICAgICB9KSk7XG4gICAgfSk7XG4gICAgY29uc3QgYnV0dG9ucyA9IHRoaXMuaXRlbVNlbGVjdGlvbi5ub2RlcygpLm1hcCgobWFya2VyTGFiZWwpID0+IG1hcmtlckxhYmVsLnByb3h5QnV0dG9uPy5idXR0b24pLmZpbHRlcihpc0RlZmluZWQpO1xuICAgIHRoaXMucHJveHlMZWdlbmRUb29sYmFyRGVzdHJveUZucy5zZXRGbnMoW1xuICAgICAgLi4uaW5pdFJvdmluZ1RhYkluZGV4KHsgb3JpZW50YXRpb246IFwiaG9yaXpvbnRhbFwiLCBidXR0b25zIH0pLFxuICAgICAgLi4uaW5pdFJvdmluZ1RhYkluZGV4KHsgb3JpZW50YXRpb246IFwidmVydGljYWxcIiwgYnV0dG9ucyB9KVxuICAgIF0pO1xuICAgIHRoaXMucHJveHlMZWdlbmRUb29sYmFyLmFyaWFIaWRkZW4gPSAoYnV0dG9ucy5sZW5ndGggPT09IDApLnRvU3RyaW5nKCk7XG4gICAgdGhpcy5wcm94eUxlZ2VuZERpcnR5ID0gZmFsc2U7XG4gIH1cbiAgb25EYXRhVXBkYXRlKG9sZERhdGEsIG5ld0RhdGEpIHtcbiAgICB0aGlzLnByb3h5TGVnZW5kRGlydHkgPSBvbGREYXRhLmxlbmd0aCAhPT0gbmV3RGF0YS5sZW5ndGggfHwgb2xkRGF0YS5zb21lKChfdiwgaW5kZXgsIF9hKSA9PiB7XG4gICAgICBjb25zdCBbbmV3VmFsdWUsIG9sZFZhbHVlXSA9IFtuZXdEYXRhW2luZGV4XSwgb2xkRGF0YVtpbmRleF1dO1xuICAgICAgcmV0dXJuIG5ld1ZhbHVlLmlkICE9PSBvbGRWYWx1ZS5pZDtcbiAgICB9KTtcbiAgfVxuICBvbk1hcmtlclNoYXBlQ2hhbmdlKCkge1xuICAgIHRoaXMuaXRlbVNlbGVjdGlvbi5jbGVhcigpO1xuICAgIHRoaXMuZ3JvdXAubWFya0RpcnR5KDIgLyogTUlOT1IgKi8pO1xuICB9XG4gIGdldE9yaWVudGF0aW9uKCkge1xuICAgIGlmICh0aGlzLm9yaWVudGF0aW9uICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB0aGlzLm9yaWVudGF0aW9uO1xuICAgIH1cbiAgICBzd2l0Y2ggKHRoaXMucG9zaXRpb24pIHtcbiAgICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgcmV0dXJuIFwidmVydGljYWxcIjtcbiAgICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgIGNhc2UgXCJ0b3BcIjpcbiAgICAgICAgcmV0dXJuIFwiaG9yaXpvbnRhbFwiO1xuICAgIH1cbiAgfVxuICBzZXQgdmlzaWJsZSh2YWx1ZSkge1xuICAgIHRoaXMuX3Zpc2libGUgPSB2YWx1ZTtcbiAgICB0aGlzLnVwZGF0ZUdyb3VwVmlzaWJpbGl0eSgpO1xuICB9XG4gIGdldCB2aXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl92aXNpYmxlO1xuICB9XG4gIHVwZGF0ZUdyb3VwVmlzaWJpbGl0eSgpIHtcbiAgICB0aGlzLmdyb3VwLnZpc2libGUgPSB0aGlzLmVuYWJsZWQgJiYgdGhpcy52aXNpYmxlICYmIHRoaXMuZGF0YS5sZW5ndGggPiAwO1xuICB9XG4gIGF0dGFjaExlZ2VuZChzY2VuZSkge1xuICAgIHNjZW5lLmFwcGVuZENoaWxkKHRoaXMuZ3JvdXApO1xuICB9XG4gIGdldEl0ZW1MYWJlbChkYXR1bSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGN0eDogeyBjYWxsYmFja0NhY2hlIH1cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB7IGZvcm1hdHRlciB9ID0gdGhpcy5pdGVtLmxhYmVsO1xuICAgIGlmIChmb3JtYXR0ZXIpIHtcbiAgICAgIHJldHVybiBjYWxsYmFja0NhY2hlLmNhbGwoZm9ybWF0dGVyLCB7XG4gICAgICAgIGl0ZW1JZDogZGF0dW0uaXRlbUlkLFxuICAgICAgICB2YWx1ZTogZGF0dW0ubGFiZWwudGV4dCxcbiAgICAgICAgc2VyaWVzSWQ6IGRhdHVtLnNlcmllc0lkXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdHVtLmxhYmVsLnRleHQ7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBtZXRob2QgaXMgZ2l2ZW4gdGhlIGRlc2lyZWQgc2l6ZSBvZiB0aGUgbGVnZW5kLCB3aGljaCBvbmx5IHNlcnZlcyBhcyBhIGhpbnQuXG4gICAqIFRoZSB2ZXJ0aWNhbGx5IG9yaWVudGVkIGxlZ2VuZCB3aWxsIHRha2UgYXMgbXVjaCBob3Jpem9udGFsIHNwYWNlIGFzIG5lZWRlZCwgYnV0IHdpbGxcbiAgICogcmVzcGVjdCB0aGUgaGVpZ2h0IGNvbnN0cmFpbnRzLCBhbmQgdGhlIGhvcml6b250YWwgbGVnZW5kIHdpbGwgdGFrZSBhcyBtdWNoIHZlcnRpY2FsXG4gICAqIHNwYWNlIGFzIG5lZWRlZCBpbiBhbiBhdHRlbXB0IG5vdCB0byBleGNlZWQgdGhlIGdpdmVuIHdpZHRoLlxuICAgKiBBZnRlciB0aGUgbGF5b3V0IGlzIGRvbmUsIHRoZSB7QGxpbmsgc2l6ZX0gd2lsbCBjb250YWluIHRoZSBhY3R1YWwgc2l6ZSBvZiB0aGUgbGVnZW5kLlxuICAgKiBJZiB0aGUgYWN0dWFsIHNpemUgaXMgbm90IHRoZSBzYW1lIGFzIHRoZSBwcmV2aW91cyBhY3R1YWwgc2l6ZSwgdGhlIGxlZ2VuZCB3aWxsIGZpcmVcbiAgICogdGhlICdsYXlvdXRDaGFuZ2UnIGV2ZW50IHRvIGNvbW11bmljYXRlIHRoYXQgYW5vdGhlciBsYXlvdXQgaXMgbmVlZGVkLCBhbmQgdGhlIGFib3ZlXG4gICAqIHByb2Nlc3Mgc2hvdWxkIGJlIHJlcGVhdGVkLlxuICAgKiBAcGFyYW0gd2lkdGhcbiAgICogQHBhcmFtIGhlaWdodFxuICAgKi9cbiAgY2FsY0xheW91dCh3aWR0aDIsIGhlaWdodDIpIHtcbiAgICBjb25zdCB7XG4gICAgICBwYWRkaW5nWCxcbiAgICAgIHBhZGRpbmdZLFxuICAgICAgbGFiZWwsXG4gICAgICBtYXhXaWR0aCxcbiAgICAgIGxhYmVsOiB7IG1heExlbmd0aCA9IEluZmluaXR5LCBmb250U3R5bGUsIGZvbnRXZWlnaHQsIGZvbnRTaXplLCBmb250RmFtaWx5IH1cbiAgICB9ID0gdGhpcy5pdGVtO1xuICAgIGNvbnN0IGRhdGEgPSBbLi4udGhpcy5kYXRhXTtcbiAgICBpZiAodGhpcy5yZXZlcnNlT3JkZXIpIHtcbiAgICAgIGRhdGEucmV2ZXJzZSgpO1xuICAgIH1cbiAgICB0aGlzLml0ZW1TZWxlY3Rpb24udXBkYXRlKGRhdGEpO1xuICAgIHRoaXMuaW5pdExlZ2VuZEl0ZW1Ub29sYmFyKCk7XG4gICAgY29uc3QgYmJveGVzID0gW107XG4gICAgY29uc3QgZm9udCA9IFRleHRVdGlscy50b0ZvbnRTdHJpbmcobGFiZWwpO1xuICAgIGNvbnN0IGl0ZW1NYXhXaWR0aFBlcmNlbnRhZ2UgPSAwLjg7XG4gICAgY29uc3QgbWF4SXRlbVdpZHRoID0gbWF4V2lkdGggPz8gd2lkdGgyICogaXRlbU1heFdpZHRoUGVyY2VudGFnZTtcbiAgICBjb25zdCBzcHJpdGVEaW1zID0gdGhpcy5jYWxjdWxhdGVTcHJpdGVEaW1lbnNpb25zKCk7XG4gICAgdGhpcy5zcHJpdGVSZW5kZXJlciA/PyAodGhpcy5zcHJpdGVSZW5kZXJlciA9IG5ldyBTcHJpdGVSZW5kZXJlcigpKTtcbiAgICB0aGlzLnNwcml0ZVJlbmRlcmVyLnJlc2l6ZShzcHJpdGVEaW1zKTtcbiAgICB0aGlzLml0ZW1TZWxlY3Rpb24uZWFjaCgobWFya2VyTGFiZWwsIGRhdHVtKSA9PiB7XG4gICAgICBtYXJrZXJMYWJlbC5mb250U3R5bGUgPSBmb250U3R5bGU7XG4gICAgICBtYXJrZXJMYWJlbC5mb250V2VpZ2h0ID0gZm9udFdlaWdodDtcbiAgICAgIG1hcmtlckxhYmVsLmZvbnRTaXplID0gZm9udFNpemU7XG4gICAgICBtYXJrZXJMYWJlbC5mb250RmFtaWx5ID0gZm9udEZhbWlseTtcbiAgICAgIGNvbnN0IHBhZGRlZFN5bWJvbFdpZHRoID0gdGhpcy51cGRhdGVNYXJrZXJMYWJlbCh0aGlzLnNwcml0ZVJlbmRlcmVyLCBtYXJrZXJMYWJlbCwgZGF0dW0sIHNwcml0ZURpbXMpO1xuICAgICAgY29uc3QgaWQgPSBkYXR1bS5pdGVtSWQgPz8gZGF0dW0uaWQ7XG4gICAgICBjb25zdCBsYWJlbFRleHQgPSB0aGlzLmdldEl0ZW1MYWJlbChkYXR1bSk7XG4gICAgICBjb25zdCB0ZXh0ID0gKGxhYmVsVGV4dCA/PyBcIjx1bmtub3duPlwiKS5yZXBsYWNlKC9cXHI/XFxuL2csIFwiIFwiKTtcbiAgICAgIG1hcmtlckxhYmVsLnRleHQgPSB0aGlzLnRydW5jYXRlKHRleHQsIG1heExlbmd0aCwgbWF4SXRlbVdpZHRoLCBwYWRkZWRTeW1ib2xXaWR0aCwgZm9udCwgaWQpO1xuICAgICAgYmJveGVzLnB1c2gobWFya2VyTGFiZWwuZ2V0QkJveCgpKTtcbiAgICB9KTtcbiAgICB0aGlzLl9zeW1ib2xzRGlydHkgPSBmYWxzZTtcbiAgICB3aWR0aDIgPSBNYXRoLm1heCgxLCB3aWR0aDIpO1xuICAgIGhlaWdodDIgPSBNYXRoLm1heCgxLCBoZWlnaHQyKTtcbiAgICBpZiAoIWlzRmluaXRlKHdpZHRoMikpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICBjb25zdCBvbGRTaXplID0gdGhpcy5vbGRTaXplO1xuICAgIHNpemVbMF0gPSB3aWR0aDI7XG4gICAgc2l6ZVsxXSA9IGhlaWdodDI7XG4gICAgaWYgKHNpemVbMF0gIT09IG9sZFNpemVbMF0gfHwgc2l6ZVsxXSAhPT0gb2xkU2l6ZVsxXSkge1xuICAgICAgb2xkU2l6ZVswXSA9IHNpemVbMF07XG4gICAgICBvbGRTaXplWzFdID0gc2l6ZVsxXTtcbiAgICB9XG4gICAgY29uc3QgeyBwYWdlcywgbWF4UGFnZUhlaWdodCwgbWF4UGFnZVdpZHRoIH0gPSB0aGlzLnVwZGF0ZVBhZ2luYXRpb24oYmJveGVzLCB3aWR0aDIsIGhlaWdodDIpO1xuICAgIGNvbnN0IG9sZFBhZ2VzID0gdGhpcy5wYWdlcztcbiAgICB0aGlzLnBhZ2VzID0gcGFnZXM7XG4gICAgdGhpcy5tYXhQYWdlU2l6ZSA9IFttYXhQYWdlV2lkdGggLSBwYWRkaW5nWCwgbWF4UGFnZUhlaWdodCAtIHBhZGRpbmdZXTtcbiAgICBjb25zdCBwYWdlTnVtYmVyID0gdGhpcy5wYWdpbmF0aW9uLmN1cnJlbnRQYWdlO1xuICAgIGNvbnN0IHBhZ2UgPSB0aGlzLnBhZ2VzW3BhZ2VOdW1iZXJdO1xuICAgIGlmICh0aGlzLnBhZ2VzLmxlbmd0aCA8IDEgfHwgIXBhZ2UpIHtcbiAgICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHsgb2xkUGFnZXMgfTtcbiAgICB9XG4gICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICB0aGlzLnVwZGF0ZVBvc2l0aW9ucyhwYWdlTnVtYmVyKTtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIHJldHVybiB7IG9sZFBhZ2VzIH07XG4gIH1cbiAgaXNDdXN0b21NYXJrZXIobWFya2VyRW5hYmxlZCwgc2hhcGUpIHtcbiAgICByZXR1cm4gbWFya2VyRW5hYmxlZCAmJiBzaGFwZSAhPT0gdm9pZCAwICYmIHR5cGVvZiBzaGFwZSAhPT0gXCJzdHJpbmdcIjtcbiAgfVxuICBjYWxjU3ltYm9sc0VuYWJsZWQoc3ltYm9sKSB7XG4gICAgY29uc3QgeyBzaG93U2VyaWVzU3Ryb2tlLCBtYXJrZXIgfSA9IHRoaXMuaXRlbTtcbiAgICBjb25zdCBtYXJrZXJFbmFibGVkID0gISFtYXJrZXIuZW5hYmxlZCB8fCAhc2hvd1Nlcmllc1N0cm9rZSB8fCAoc3ltYm9sLm1hcmtlci5lbmFibGVkID8/IHRydWUpO1xuICAgIGNvbnN0IGxpbmVFbmFibGVkID0gISEoc3ltYm9sLmxpbmUgJiYgc2hvd1Nlcmllc1N0cm9rZSk7XG4gICAgY29uc3QgaXNDdXN0b21NYXJrZXIgPSB0aGlzLmlzQ3VzdG9tTWFya2VyKG1hcmtlckVuYWJsZWQsIHN5bWJvbC5tYXJrZXIuc2hhcGUpO1xuICAgIHJldHVybiB7IG1hcmtlckVuYWJsZWQsIGxpbmVFbmFibGVkLCBpc0N1c3RvbU1hcmtlciB9O1xuICB9XG4gIGNhbGNTeW1ib2xzTGVuZ3RocyhzeW1ib2wpIHtcbiAgICBjb25zdCB7IG1hcmtlciwgbGluZSB9ID0gdGhpcy5pdGVtO1xuICAgIGNvbnN0IHsgbWFya2VyRW5hYmxlZCwgbGluZUVuYWJsZWQgfSA9IHRoaXMuY2FsY1N5bWJvbHNFbmFibGVkKHN5bWJvbCk7XG4gICAgY29uc3QgeyBzdHJva2VXaWR0aDogbWFya2VyU3Ryb2tlV2lkdGggfSA9IHRoaXMuZ2V0TWFya2VyU3R5bGVzKHN5bWJvbCk7XG4gICAgY29uc3QgeyBzdHJva2VXaWR0aDogbGluZVN0cm9rZVdpZHRoIH0gPSBsaW5lRW5hYmxlZCA/IHRoaXMuZ2V0TGluZVN0eWxlcyhzeW1ib2wpIDogeyBzdHJva2VXaWR0aDogMCB9O1xuICAgIGxldCBjdXN0b21NYXJrZXJTaXplO1xuICAgIGNvbnN0IHsgc2hhcGUgfSA9IHN5bWJvbC5tYXJrZXI7XG4gICAgaWYgKHRoaXMuaXNDdXN0b21NYXJrZXIobWFya2VyRW5hYmxlZCwgc2hhcGUpKSB7XG4gICAgICBjb25zdCB0bXBTaGFwZSA9IG5ldyBzaGFwZSgpO1xuICAgICAgdG1wU2hhcGUudXBkYXRlUGF0aCgpO1xuICAgICAgY29uc3QgYmJveCA9IHRtcFNoYXBlLmdldEJCb3goKTtcbiAgICAgIGN1c3RvbU1hcmtlclNpemUgPSBNYXRoLm1heChiYm94LndpZHRoLCBiYm94LmhlaWdodCk7XG4gICAgfVxuICAgIGNvbnN0IG1hcmtlckxlbmd0aCA9IG1hcmtlckVuYWJsZWQgPyBtYXJrZXIuc2l6ZSA6IDA7XG4gICAgY29uc3QgbGluZUxlbmd0aCA9IGxpbmVFbmFibGVkID8gbGluZS5sZW5ndGggPz8gMjUgOiAwO1xuICAgIHJldHVybiB7IG1hcmtlckxlbmd0aCwgbWFya2VyU3Ryb2tlV2lkdGgsIGxpbmVMZW5ndGgsIGxpbmVTdHJva2VXaWR0aCwgY3VzdG9tTWFya2VyU2l6ZSB9O1xuICB9XG4gIGNhbGN1bGF0ZVNwcml0ZURpbWVuc2lvbnMoKSB7XG4gICAgbGV0IHNwcml0ZUFBUGFkZGluZyA9IDA7XG4gICAgbGV0IHNwcml0ZVdpZHRoID0gMDtcbiAgICBsZXQgc3ByaXRlSGVpZ2h0ID0gMDtcbiAgICBsZXQgbWFya2VyV2lkdGggPSAwO1xuICAgIHRoaXMuaXRlbVNlbGVjdGlvbi5lYWNoKChfLCBkYXR1bSkgPT4ge1xuICAgICAgZGF0dW0uc3ltYm9scy5mb3JFYWNoKChzeW1ib2wpID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIG1hcmtlckxlbmd0aCxcbiAgICAgICAgICBtYXJrZXJTdHJva2VXaWR0aCxcbiAgICAgICAgICBsaW5lTGVuZ3RoLFxuICAgICAgICAgIGxpbmVTdHJva2VXaWR0aCxcbiAgICAgICAgICBjdXN0b21NYXJrZXJTaXplID0gLUluZmluaXR5XG4gICAgICAgIH0gPSB0aGlzLmNhbGNTeW1ib2xzTGVuZ3RocyhzeW1ib2wpO1xuICAgICAgICBjb25zdCBtYXJrZXJUb3RhbExlbmd0aCA9IG1hcmtlckxlbmd0aCArIG1hcmtlclN0cm9rZVdpZHRoO1xuICAgICAgICBtYXJrZXJXaWR0aCA9IE1hdGgubWF4KG1hcmtlcldpZHRoLCBsaW5lTGVuZ3RoLCBjdXN0b21NYXJrZXJTaXplLCBtYXJrZXJMZW5ndGgpO1xuICAgICAgICBzcHJpdGVXaWR0aCA9IE1hdGgubWF4KHNwcml0ZVdpZHRoLCBsaW5lTGVuZ3RoLCBjdXN0b21NYXJrZXJTaXplLCBtYXJrZXJUb3RhbExlbmd0aCk7XG4gICAgICAgIHNwcml0ZUhlaWdodCA9IE1hdGgubWF4KHNwcml0ZUhlaWdodCwgbGluZVN0cm9rZVdpZHRoLCBtYXJrZXJUb3RhbExlbmd0aCk7XG4gICAgICAgIHNwcml0ZUFBUGFkZGluZyA9IE1hdGgubWF4KHNwcml0ZUFBUGFkZGluZywgbWFya2VyU3Ryb2tlV2lkdGggKyAwLjUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgc3ByaXRlV2lkdGggKz0gc3ByaXRlQUFQYWRkaW5nICogMjtcbiAgICBzcHJpdGVIZWlnaHQgKz0gc3ByaXRlQUFQYWRkaW5nICogMjtcbiAgICBjb25zdCBzcHJpdGVQaXhlbFJhdGlvID0gZ2V0V2luZG93KCkuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICByZXR1cm4geyBzcHJpdGVQaXhlbFJhdGlvLCBzcHJpdGVBQVBhZGRpbmcsIHNwcml0ZVdpZHRoLCBzcHJpdGVIZWlnaHQsIG1hcmtlcldpZHRoIH07XG4gIH1cbiAgdXBkYXRlTWFya2VyTGFiZWwoc3ByaXRlUmVuZGVyZXIsIG1hcmtlckxhYmVsLCBkYXR1bSwgc3ByaXRlRGltcykge1xuICAgIGNvbnN0IHsgbWFya2VyOiBpdGVtTWFya2VyLCBwYWRkaW5nWCB9ID0gdGhpcy5pdGVtO1xuICAgIGNvbnN0IHsgbWFya2VyV2lkdGggfSA9IHNwcml0ZURpbXM7XG4gICAgY29uc3QgZGltZW5zaW9uUHJvcHMgPSBbXTtcbiAgICBsZXQgcGFkZGVkU3ltYm9sV2lkdGggPSBwYWRkaW5nWDtcbiAgICBpZiAodGhpcy5fc3ltYm9sc0RpcnR5KSB7XG4gICAgICBjb25zdCBtYXJrZXJzID0gW107XG4gICAgICBjb25zdCBsaW5lcyA9IFtdO1xuICAgICAgZGF0dW0uc3ltYm9scy5mb3JFYWNoKChzeW1ib2wpID0+IHtcbiAgICAgICAgY29uc3QgeyBzaGFwZTogbWFya2VyU2hhcGUgPSBzeW1ib2wubWFya2VyLnNoYXBlIH0gPSBpdGVtTWFya2VyO1xuICAgICAgICBjb25zdCBNYXJrZXJDdHIgPSBnZXRNYXJrZXIobWFya2VyU2hhcGUpO1xuICAgICAgICBsaW5lcy5wdXNoKG5ldyBMaW5lKHsgekluZGV4OiAwIH0pKTtcbiAgICAgICAgbWFya2Vycy5wdXNoKG5ldyBNYXJrZXJDdHIoeyB6SW5kZXg6IDEgfSkpO1xuICAgICAgfSk7XG4gICAgICBtYXJrZXJMYWJlbC51cGRhdGVTeW1ib2xzKG1hcmtlcnMsIGxpbmVzKTtcbiAgICB9XG4gICAgZGF0dW0uc3ltYm9scy5mb3JFYWNoKChzeW1ib2wsIGkpID0+IHtcbiAgICAgIGNvbnN0IHNwYWNpbmcgPSBzeW1ib2wubWFya2VyLnBhZGRpbmcgPz8gaXRlbU1hcmtlci5wYWRkaW5nO1xuICAgICAgY29uc3QgeyBtYXJrZXJFbmFibGVkLCBsaW5lRW5hYmxlZCwgaXNDdXN0b21NYXJrZXIgfSA9IHRoaXMuY2FsY1N5bWJvbHNFbmFibGVkKHN5bWJvbCk7XG4gICAgICBtYXJrZXJMYWJlbC5tYXJrZXJzW2ldLnNpemUgPSBtYXJrZXJFbmFibGVkIHx8ICFsaW5lRW5hYmxlZCA/IGl0ZW1NYXJrZXIuc2l6ZSA6IDA7XG4gICAgICBkaW1lbnNpb25Qcm9wcy5wdXNoKHsgbGVuZ3RoOiBtYXJrZXJXaWR0aCwgc3BhY2luZywgaXNDdXN0b21NYXJrZXIgfSk7XG4gICAgICBpZiAobWFya2VyRW5hYmxlZCB8fCBsaW5lRW5hYmxlZCkge1xuICAgICAgICBwYWRkZWRTeW1ib2xXaWR0aCArPSBzcGFjaW5nICsgbWFya2VyV2lkdGg7XG4gICAgICB9XG4gICAgICBjb25zdCBtYXJrZXIgPSBtYXJrZXJMYWJlbC5tYXJrZXJzW2ldO1xuICAgICAgY29uc3QgbGluZSA9IG1hcmtlckxhYmVsLmxpbmVzW2ldO1xuICAgICAgaWYgKG1hcmtlcikge1xuICAgICAgICBjb25zdCB7IHN0cm9rZVdpZHRoLCBmaWxsLCBzdHJva2UsIGZpbGxPcGFjaXR5LCBzdHJva2VPcGFjaXR5IH0gPSB0aGlzLmdldE1hcmtlclN0eWxlcyhzeW1ib2wpO1xuICAgICAgICBtYXJrZXIuZmlsbCA9IGZpbGw7XG4gICAgICAgIG1hcmtlci5zdHJva2UgPSBzdHJva2U7XG4gICAgICAgIG1hcmtlci5zdHJva2VXaWR0aCA9IHN0cm9rZVdpZHRoO1xuICAgICAgICBtYXJrZXIuZmlsbE9wYWNpdHkgPSBmaWxsT3BhY2l0eTtcbiAgICAgICAgbWFya2VyLnN0cm9rZU9wYWNpdHkgPSBzdHJva2VPcGFjaXR5O1xuICAgICAgfVxuICAgICAgaWYgKGxpbmUpIHtcbiAgICAgICAgY29uc3QgbGluZVN0eWxlcyA9IHRoaXMuZ2V0TGluZVN0eWxlcyhzeW1ib2wpO1xuICAgICAgICBsaW5lLnN0cm9rZSA9IGxpbmVTdHlsZXMuc3Ryb2tlO1xuICAgICAgICBsaW5lLnN0cm9rZU9wYWNpdHkgPSBsaW5lU3R5bGVzLnN0cm9rZU9wYWNpdHk7XG4gICAgICAgIGxpbmUuc3Ryb2tlV2lkdGggPSBsaW5lU3R5bGVzLnN0cm9rZVdpZHRoO1xuICAgICAgICBsaW5lLmxpbmVEYXNoID0gbGluZVN0eWxlcy5saW5lRGFzaDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBtYXJrZXJMYWJlbC51cGRhdGUoc3ByaXRlUmVuZGVyZXIsIHNwcml0ZURpbXMsIGRpbWVuc2lvblByb3BzKTtcbiAgICByZXR1cm4gcGFkZGVkU3ltYm9sV2lkdGg7XG4gIH1cbiAgdHJ1bmNhdGUodGV4dCwgbWF4Q2hhckxlbmd0aCwgbWF4SXRlbVdpZHRoLCBwYWRkZWRNYXJrZXJXaWR0aCwgZm9udCwgaWQpIHtcbiAgICBsZXQgYWRkRWxsaXBzaXMgPSBmYWxzZTtcbiAgICBpZiAodGV4dC5sZW5ndGggPiBtYXhDaGFyTGVuZ3RoKSB7XG4gICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgbWF4Q2hhckxlbmd0aCk7XG4gICAgICBhZGRFbGxpcHNpcyA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IG1lYXN1cmVyID0gQ2FjaGVkVGV4dE1lYXN1cmVyUG9vbC5nZXRNZWFzdXJlcih7IGZvbnQgfSk7XG4gICAgY29uc3QgcmVzdWx0ID0gVGV4dFdyYXBwZXIudHJ1bmNhdGVMaW5lKHRleHQsIG1lYXN1cmVyLCBtYXhJdGVtV2lkdGggLSBwYWRkZWRNYXJrZXJXaWR0aCwgYWRkRWxsaXBzaXMpO1xuICAgIGlmIChyZXN1bHQuZW5kc1dpdGgoVGV4dFV0aWxzLkVsbGlwc2lzQ2hhcikpIHtcbiAgICAgIHRoaXMudHJ1bmNhdGVkSXRlbXMuYWRkKGlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50cnVuY2F0ZWRJdGVtcy5kZWxldGUoaWQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHVwZGF0ZVBhZ2luYXRpb24oYmJveGVzLCB3aWR0aDIsIGhlaWdodDIpIHtcbiAgICBjb25zdCBvcmllbnRhdGlvbiA9IHRoaXMuZ2V0T3JpZW50YXRpb24oKTtcbiAgICBjb25zdCB0cmFja2luZ0luZGV4ID0gTWF0aC5taW4odGhpcy5wYWdpbmF0aW9uVHJhY2tpbmdJbmRleCwgYmJveGVzLmxlbmd0aCk7XG4gICAgdGhpcy5wYWdpbmF0aW9uLm9yaWVudGF0aW9uID0gb3JpZW50YXRpb247XG4gICAgdGhpcy5wYWdpbmF0aW9uLnRyYW5zbGF0aW9uWCA9IDA7XG4gICAgdGhpcy5wYWdpbmF0aW9uLnRyYW5zbGF0aW9uWSA9IDA7XG4gICAgY29uc3QgeyBwYWdlcywgbWF4UGFnZUhlaWdodCwgbWF4UGFnZVdpZHRoLCBwYWdpbmF0aW9uQkJveCwgcGFnaW5hdGlvblZlcnRpY2FsIH0gPSB0aGlzLmNhbGN1bGF0ZVBhZ2luYXRpb24oXG4gICAgICBiYm94ZXMsXG4gICAgICB3aWR0aDIsXG4gICAgICBoZWlnaHQyXG4gICAgKTtcbiAgICBjb25zdCBuZXdDdXJyZW50UGFnZSA9IHBhZ2VzLmZpbmRJbmRleCgocCkgPT4gcC5lbmRJbmRleCA+PSB0cmFja2luZ0luZGV4KTtcbiAgICB0aGlzLnBhZ2luYXRpb24uY3VycmVudFBhZ2UgPSBjbGFtcCgwLCBuZXdDdXJyZW50UGFnZSwgcGFnZXMubGVuZ3RoIC0gMSk7XG4gICAgY29uc3QgeyBwYWRkaW5nWDogaXRlbVBhZGRpbmdYLCBwYWRkaW5nWTogaXRlbVBhZGRpbmdZIH0gPSB0aGlzLml0ZW07XG4gICAgY29uc3QgcGFnaW5hdGlvbkNvbXBvbmVudFBhZGRpbmcgPSA4O1xuICAgIGNvbnN0IGxlZ2VuZEl0ZW1zV2lkdGggPSBtYXhQYWdlV2lkdGggLSBpdGVtUGFkZGluZ1g7XG4gICAgY29uc3QgbGVnZW5kSXRlbXNIZWlnaHQgPSBtYXhQYWdlSGVpZ2h0IC0gaXRlbVBhZGRpbmdZO1xuICAgIGxldCBwYWdpbmF0aW9uWCA9IDA7XG4gICAgbGV0IHBhZ2luYXRpb25ZID0gLXBhZ2luYXRpb25CQm94LnkgLSB0aGlzLml0ZW0ubWFya2VyLnNpemUgLyAyO1xuICAgIGlmIChwYWdpbmF0aW9uVmVydGljYWwpIHtcbiAgICAgIHBhZ2luYXRpb25ZICs9IGxlZ2VuZEl0ZW1zSGVpZ2h0ICsgcGFnaW5hdGlvbkNvbXBvbmVudFBhZGRpbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhZ2luYXRpb25YICs9IC1wYWdpbmF0aW9uQkJveC54ICsgbGVnZW5kSXRlbXNXaWR0aCArIHBhZ2luYXRpb25Db21wb25lbnRQYWRkaW5nO1xuICAgICAgcGFnaW5hdGlvblkgKz0gKGxlZ2VuZEl0ZW1zSGVpZ2h0IC0gcGFnaW5hdGlvbkJCb3guaGVpZ2h0KSAvIDI7XG4gICAgfVxuICAgIHRoaXMucGFnaW5hdGlvbi50cmFuc2xhdGlvblggPSBwYWdpbmF0aW9uWDtcbiAgICB0aGlzLnBhZ2luYXRpb24udHJhbnNsYXRpb25ZID0gcGFnaW5hdGlvblk7XG4gICAgdGhpcy5wYWdpbmF0aW9uLnVwZGF0ZSgpO1xuICAgIHRoaXMucGFnaW5hdGlvbi51cGRhdGVNYXJrZXJzKCk7XG4gICAgbGV0IHBhZ2VJbmRleCA9IDA7XG4gICAgdGhpcy5pdGVtU2VsZWN0aW9uLmVhY2goKG1hcmtlckxhYmVsLCBfLCBub2RlSW5kZXgpID0+IHtcbiAgICAgIGlmIChub2RlSW5kZXggPiAocGFnZXNbcGFnZUluZGV4XT8uZW5kSW5kZXggPz8gSW5maW5pdHkpKSB7XG4gICAgICAgIHBhZ2VJbmRleCsrO1xuICAgICAgfVxuICAgICAgbWFya2VyTGFiZWwucGFnZUluZGV4ID0gcGFnZUluZGV4O1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBtYXhQYWdlSGVpZ2h0LFxuICAgICAgbWF4UGFnZVdpZHRoLFxuICAgICAgcGFnZXNcbiAgICB9O1xuICB9XG4gIHVwZGF0ZUl0ZW1Qcm94eUJ1dHRvbnMoKSB7XG4gICAgY29uc3QgcG9pbnRlciA9IHRoaXMudG9nZ2xlU2VyaWVzID8gXCJwb2ludGVyXCIgOiB2b2lkIDA7XG4gICAgY29uc3QgbWF4SGVpZ2h0ID0gTWF0aC5tYXgoLi4udGhpcy5pdGVtU2VsZWN0aW9uLm5vZGVzKCkubWFwKChsKSA9PiBsLmdldEJCb3goKS5oZWlnaHQpKTtcbiAgICB0aGlzLml0ZW1TZWxlY3Rpb24uZWFjaCgobCkgPT4ge1xuICAgICAgaWYgKGwucHJveHlCdXR0b24pIHtcbiAgICAgICAgY29uc3QgeyBsaXN0aXRlbSwgYnV0dG9uIH0gPSBsLnByb3h5QnV0dG9uO1xuICAgICAgICBjb25zdCB2aXNpYmxlID0gbC5wYWdlSW5kZXggPT09IHRoaXMucGFnaW5hdGlvbi5jdXJyZW50UGFnZTtcbiAgICAgICAgbGV0IGJib3ggPSBUcmFuc2Zvcm1hYmxlLnRvQ2FudmFzKGwpO1xuICAgICAgICBpZiAoYmJveC5oZWlnaHQgIT09IG1heEhlaWdodCkge1xuICAgICAgICAgIGNvbnN0IG1hcmdpbiA9IChtYXhIZWlnaHQgLSBiYm94LmhlaWdodCkgLyAyO1xuICAgICAgICAgIGJib3ggPSB7IHg6IGJib3gueCwgeTogYmJveC55IC0gbWFyZ2luLCBoZWlnaHQ6IG1heEhlaWdodCwgd2lkdGg6IGJib3gud2lkdGggfTtcbiAgICAgICAgfVxuICAgICAgICBzZXRFbGVtZW50U3R5bGUoYnV0dG9uLCBcInBvaW50ZXItZXZlbnRzXCIsIHZpc2libGUgPyBcImF1dG9cIiA6IFwibm9uZVwiKTtcbiAgICAgICAgc2V0RWxlbWVudFN0eWxlKGJ1dHRvbiwgXCJjdXJzb3JcIiwgcG9pbnRlcik7XG4gICAgICAgIHNldEVsZW1lbnRCQm94KGxpc3RpdGVtLCBiYm94KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB1cGRhdGVQYWdpbmF0aW9uUHJveHlCdXR0b25zKG9sZFBhZ2VzKSB7XG4gICAgdGhpcy5wcm94eUxlZ2VuZFBhZ2luYXRpb24uc3R5bGUuZGlzcGxheSA9IHRoaXMucGFnaW5hdGlvbi52aXNpYmxlID8gXCJhYnNvbHV0ZVwiIDogXCJub25lXCI7XG4gICAgY29uc3Qgb2xkTmVlZHNCdXR0b25zID0gKG9sZFBhZ2VzPy5sZW5ndGggPz8gdGhpcy5wYWdlcy5sZW5ndGgpID4gMTtcbiAgICBjb25zdCBuZXdOZWVkc0J1dHRvbnMgPSB0aGlzLnBhZ2VzLmxlbmd0aCA+IDE7XG4gICAgaWYgKG9sZE5lZWRzQnV0dG9ucyAhPT0gbmV3TmVlZHNCdXR0b25zKSB7XG4gICAgICBpZiAobmV3TmVlZHNCdXR0b25zKSB7XG4gICAgICAgIHRoaXMucHJveHlQcmV2QnV0dG9uID0gdGhpcy5jdHgucHJveHlJbnRlcmFjdGlvblNlcnZpY2UuY3JlYXRlUHJveHlFbGVtZW50KHtcbiAgICAgICAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgICAgICAgIGlkOiBgJHt0aGlzLmlkfS1wcmV2LXBhZ2VgLFxuICAgICAgICAgIHRleHRDb250ZW50OiB7IGlkOiBcImFyaWFMYWJlbExlZ2VuZFBhZ2VQcmV2aW91c1wiIH0sXG4gICAgICAgICAgdGFiSW5kZXg6IDAsXG4gICAgICAgICAgcGFyZW50OiB0aGlzLnByb3h5TGVnZW5kUGFnaW5hdGlvbixcbiAgICAgICAgICBvbmNsaWNrOiAoZXYpID0+IHRoaXMucGFnaW5hdGlvbi5vbkNsaWNrKGV2LCBcInByZXZpb3VzXCIpLFxuICAgICAgICAgIG9ubW91c2VlbnRlcjogKCkgPT4gdGhpcy5wYWdpbmF0aW9uLm9uTW91c2VIb3ZlcihcInByZXZpb3VzXCIpLFxuICAgICAgICAgIG9ubW91c2VsZWF2ZTogKCkgPT4gdGhpcy5wYWdpbmF0aW9uLm9uTW91c2VIb3Zlcih2b2lkIDApXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnByb3h5TmV4dEJ1dHRvbiA/PyAodGhpcy5wcm94eU5leHRCdXR0b24gPSB0aGlzLmN0eC5wcm94eUludGVyYWN0aW9uU2VydmljZS5jcmVhdGVQcm94eUVsZW1lbnQoe1xuICAgICAgICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgICAgICAgaWQ6IGAke3RoaXMuaWR9LW5leHQtcGFnZWAsXG4gICAgICAgICAgdGV4dENvbnRlbnQ6IHsgaWQ6IFwiYXJpYUxhYmVsTGVnZW5kUGFnZU5leHRcIiB9LFxuICAgICAgICAgIHRhYkluZGV4OiAwLFxuICAgICAgICAgIHBhcmVudDogdGhpcy5wcm94eUxlZ2VuZFBhZ2luYXRpb24sXG4gICAgICAgICAgb25jbGljazogKGV2KSA9PiB0aGlzLnBhZ2luYXRpb24ub25DbGljayhldiwgXCJuZXh0XCIpLFxuICAgICAgICAgIG9ubW91c2VlbnRlcjogKCkgPT4gdGhpcy5wYWdpbmF0aW9uLm9uTW91c2VIb3ZlcihcIm5leHRcIiksXG4gICAgICAgICAgb25tb3VzZWxlYXZlOiAoKSA9PiB0aGlzLnBhZ2luYXRpb24ub25Nb3VzZUhvdmVyKHZvaWQgMClcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLnByb3h5TGVnZW5kUGFnaW5hdGlvbi5hcmlhSGlkZGVuID0gXCJmYWxzZVwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcm94eU5leHRCdXR0b24/LnJlbW92ZSgpO1xuICAgICAgICB0aGlzLnByb3h5UHJldkJ1dHRvbj8ucmVtb3ZlKCk7XG4gICAgICAgIFt0aGlzLnByb3h5TmV4dEJ1dHRvbiwgdGhpcy5wcm94eVByZXZCdXR0b25dID0gW3ZvaWQgMCwgdm9pZCAwXTtcbiAgICAgICAgdGhpcy5wcm94eUxlZ2VuZFBhZ2luYXRpb24uYXJpYUhpZGRlbiA9IFwidHJ1ZVwiO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB7IHByZXYsIG5leHQgfSA9IHRoaXMucGFnaW5hdGlvbi5jb21wdXRlQ1NTQm91bmRzKCk7XG4gICAgc2V0RWxlbWVudEJCb3godGhpcy5wcm94eVByZXZCdXR0b24sIHByZXYpO1xuICAgIHNldEVsZW1lbnRCQm94KHRoaXMucHJveHlOZXh0QnV0dG9uLCBuZXh0KTtcbiAgICBzZXRFbGVtZW50U3R5bGUodGhpcy5wcm94eU5leHRCdXR0b24sIFwiY3Vyc29yXCIsIHRoaXMucGFnaW5hdGlvbi5nZXRDdXJzb3IoXCJuZXh0XCIpKTtcbiAgICBzZXRFbGVtZW50U3R5bGUodGhpcy5wcm94eVByZXZCdXR0b24sIFwiY3Vyc29yXCIsIHRoaXMucGFnaW5hdGlvbi5nZXRDdXJzb3IoXCJwcmV2aW91c1wiKSk7XG4gIH1cbiAgY2FsY3VsYXRlUGFnaW5hdGlvbihiYm94ZXMsIHdpZHRoMiwgaGVpZ2h0Mikge1xuICAgIGNvbnN0IHsgcGFkZGluZ1g6IGl0ZW1QYWRkaW5nWCwgcGFkZGluZ1k6IGl0ZW1QYWRkaW5nWSB9ID0gdGhpcy5pdGVtO1xuICAgIGNvbnN0IG9yaWVudGF0aW9uID0gdGhpcy5nZXRPcmllbnRhdGlvbigpO1xuICAgIGNvbnN0IHBhZ2luYXRpb25WZXJ0aWNhbCA9IFtcImxlZnRcIiwgXCJyaWdodFwiXS5pbmNsdWRlcyh0aGlzLnBvc2l0aW9uKTtcbiAgICBsZXQgcGFnaW5hdGlvbkJCb3ggPSB0aGlzLnBhZ2luYXRpb24uZ2V0QkJveCgpO1xuICAgIGxldCBsYXN0UGFzc1BhZ2luYXRpb25CQm94ID0gbmV3IEJCb3goMCwgMCwgMCwgMCk7XG4gICAgbGV0IHBhZ2VzID0gW107XG4gICAgbGV0IG1heFBhZ2VXaWR0aCA9IDA7XG4gICAgbGV0IG1heFBhZ2VIZWlnaHQgPSAwO1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgY29uc3Qgc3RhYmxlT3V0cHV0ID0gKGJib3gpID0+IHtcbiAgICAgIHJldHVybiBiYm94LndpZHRoID09PSBwYWdpbmF0aW9uQkJveC53aWR0aCAmJiBiYm94LmhlaWdodCA9PT0gcGFnaW5hdGlvbkJCb3guaGVpZ2h0O1xuICAgIH07XG4gICAgY29uc3QgZm9yY2VSZXN1bHQgPSB0aGlzLm1heFdpZHRoICE9PSB2b2lkIDAgJiYgdGhpcy5tYXhIZWlnaHQgIT09IHZvaWQgMDtcbiAgICBkbyB7XG4gICAgICBpZiAoY291bnQrKyA+IDEwKSB7XG4gICAgICAgIExvZ2dlci53YXJuKFwidW5hYmxlIHRvIGZpbmQgc3RhYmxlIGxlZ2VuZCBsYXlvdXQuXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHBhZ2luYXRpb25CQm94ID0gbGFzdFBhc3NQYWdpbmF0aW9uQkJveDtcbiAgICAgIGNvbnN0IG1heFdpZHRoID0gd2lkdGgyIC0gKHBhZ2luYXRpb25WZXJ0aWNhbCA/IDAgOiBwYWdpbmF0aW9uQkJveC53aWR0aCk7XG4gICAgICBjb25zdCBtYXhIZWlnaHQgPSBoZWlnaHQyIC0gKHBhZ2luYXRpb25WZXJ0aWNhbCA/IHBhZ2luYXRpb25CQm94LmhlaWdodCA6IDApO1xuICAgICAgY29uc3QgbGF5b3V0ID0gZ3JpZExheW91dCh7XG4gICAgICAgIG9yaWVudGF0aW9uLFxuICAgICAgICBiYm94ZXMsXG4gICAgICAgIG1heEhlaWdodCxcbiAgICAgICAgbWF4V2lkdGgsXG4gICAgICAgIGl0ZW1QYWRkaW5nWSxcbiAgICAgICAgaXRlbVBhZGRpbmdYLFxuICAgICAgICBmb3JjZVJlc3VsdFxuICAgICAgfSk7XG4gICAgICBwYWdlcyA9IGxheW91dD8ucGFnZXMgPz8gW107XG4gICAgICBtYXhQYWdlV2lkdGggPSBsYXlvdXQ/Lm1heFBhZ2VXaWR0aCA/PyAwO1xuICAgICAgbWF4UGFnZUhlaWdodCA9IGxheW91dD8ubWF4UGFnZUhlaWdodCA/PyAwO1xuICAgICAgY29uc3QgdG90YWxQYWdlcyA9IHBhZ2VzLmxlbmd0aDtcbiAgICAgIHRoaXMucGFnaW5hdGlvbi52aXNpYmxlID0gdG90YWxQYWdlcyA+IDE7XG4gICAgICB0aGlzLnBhZ2luYXRpb24udG90YWxQYWdlcyA9IHRvdGFsUGFnZXM7XG4gICAgICB0aGlzLnBhZ2luYXRpb24udXBkYXRlKCk7XG4gICAgICB0aGlzLnBhZ2luYXRpb24udXBkYXRlTWFya2VycygpO1xuICAgICAgbGFzdFBhc3NQYWdpbmF0aW9uQkJveCA9IHRoaXMucGFnaW5hdGlvbi5nZXRCQm94KCk7XG4gICAgICBpZiAoIXRoaXMucGFnaW5hdGlvbi52aXNpYmxlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKCFzdGFibGVPdXRwdXQobGFzdFBhc3NQYWdpbmF0aW9uQkJveCkpO1xuICAgIHJldHVybiB7IG1heFBhZ2VXaWR0aCwgbWF4UGFnZUhlaWdodCwgcGFnZXMsIHBhZ2luYXRpb25CQm94OiBsYXN0UGFzc1BhZ2luYXRpb25CQm94LCBwYWdpbmF0aW9uVmVydGljYWwgfTtcbiAgfVxuICB1cGRhdGVQb3NpdGlvbnMocGFnZU51bWJlciA9IDApIHtcbiAgICBjb25zdCB7XG4gICAgICBpdGVtOiB7IHBhZGRpbmdZIH0sXG4gICAgICBpdGVtU2VsZWN0aW9uLFxuICAgICAgcGFnZXNcbiAgICB9ID0gdGhpcztcbiAgICBpZiAocGFnZXMubGVuZ3RoIDwgMSB8fCAhcGFnZXNbcGFnZU51bWJlcl0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBjb2x1bW5zLCBzdGFydEluZGV4OiB2aXNpYmxlU3RhcnQsIGVuZEluZGV4OiB2aXNpYmxlRW5kIH0gPSBwYWdlc1twYWdlTnVtYmVyXTtcbiAgICBsZXQgeCA9IDA7XG4gICAgbGV0IHkgPSAwO1xuICAgIGNvbnN0IGNvbHVtbkNvdW50ID0gY29sdW1ucy5sZW5ndGg7XG4gICAgY29uc3Qgcm93Q291bnQgPSBjb2x1bW5zWzBdLmluZGljZXMubGVuZ3RoO1xuICAgIGNvbnN0IGhvcml6b250YWwgPSB0aGlzLmdldE9yaWVudGF0aW9uKCkgPT09IFwiaG9yaXpvbnRhbFwiO1xuICAgIGNvbnN0IGl0ZW1IZWlnaHQgPSBjb2x1bW5zWzBdLmJib3hlc1swXS5oZWlnaHQgKyBwYWRkaW5nWTtcbiAgICBjb25zdCByb3dTdW1Db2x1bW5XaWR0aHMgPSBbXTtcbiAgICBpdGVtU2VsZWN0aW9uLmVhY2goKG1hcmtlckxhYmVsLCBfLCBpKSA9PiB7XG4gICAgICBpZiAoaSA8IHZpc2libGVTdGFydCB8fCBpID4gdmlzaWJsZUVuZCkge1xuICAgICAgICBtYXJrZXJMYWJlbC52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhZ2VJbmRleCA9IGkgLSB2aXNpYmxlU3RhcnQ7XG4gICAgICBsZXQgY29sdW1uSW5kZXg7XG4gICAgICBsZXQgcm93SW5kZXg7XG4gICAgICBpZiAoaG9yaXpvbnRhbCkge1xuICAgICAgICBjb2x1bW5JbmRleCA9IHBhZ2VJbmRleCAlIGNvbHVtbkNvdW50O1xuICAgICAgICByb3dJbmRleCA9IE1hdGguZmxvb3IocGFnZUluZGV4IC8gY29sdW1uQ291bnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29sdW1uSW5kZXggPSBNYXRoLmZsb29yKHBhZ2VJbmRleCAvIHJvd0NvdW50KTtcbiAgICAgICAgcm93SW5kZXggPSBwYWdlSW5kZXggJSByb3dDb3VudDtcbiAgICAgIH1cbiAgICAgIG1hcmtlckxhYmVsLnZpc2libGUgPSB0cnVlO1xuICAgICAgY29uc3QgY29sdW1uID0gY29sdW1uc1tjb2x1bW5JbmRleF07XG4gICAgICBpZiAoIWNvbHVtbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB5ID0gTWF0aC5mbG9vcihpdGVtSGVpZ2h0ICogcm93SW5kZXgpO1xuICAgICAgeCA9IE1hdGguZmxvb3Iocm93U3VtQ29sdW1uV2lkdGhzW3Jvd0luZGV4XSA/PyAwKTtcbiAgICAgIHJvd1N1bUNvbHVtbldpZHRoc1tyb3dJbmRleF0gPSAocm93U3VtQ29sdW1uV2lkdGhzW3Jvd0luZGV4XSA/PyAwKSArIGNvbHVtbi5jb2x1bW5XaWR0aDtcbiAgICAgIG1hcmtlckxhYmVsLnRyYW5zbGF0aW9uWCA9IHg7XG4gICAgICBtYXJrZXJMYWJlbC50cmFuc2xhdGlvblkgPSB5O1xuICAgIH0pO1xuICAgIHRoaXMudXBkYXRlSXRlbVByb3h5QnV0dG9ucygpO1xuICB9XG4gIHVwZGF0ZVBhZ2VOdW1iZXIocGFnZU51bWJlcikge1xuICAgIGNvbnN0IHsgcGFnZXMgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBzdGFydEluZGV4LCBlbmRJbmRleCB9ID0gcGFnZXNbcGFnZU51bWJlcl07XG4gICAgaWYgKHN0YXJ0SW5kZXggPT09IDApIHtcbiAgICAgIHRoaXMucGFnaW5hdGlvblRyYWNraW5nSW5kZXggPSAwO1xuICAgIH0gZWxzZSBpZiAocGFnZU51bWJlciA9PT0gcGFnZXMubGVuZ3RoIC0gMSkge1xuICAgICAgdGhpcy5wYWdpbmF0aW9uVHJhY2tpbmdJbmRleCA9IGVuZEluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBhZ2luYXRpb25UcmFja2luZ0luZGV4ID0gTWF0aC5mbG9vcigoc3RhcnRJbmRleCArIGVuZEluZGV4KSAvIDIpO1xuICAgIH1cbiAgICB0aGlzLnBhZ2luYXRpb24udXBkYXRlKCk7XG4gICAgdGhpcy5wYWdpbmF0aW9uLnVwZGF0ZU1hcmtlcnMoKTtcbiAgICB0aGlzLnVwZGF0ZVBvc2l0aW9ucyhwYWdlTnVtYmVyKTtcbiAgICBzZXRFbGVtZW50U3R5bGUodGhpcy5wcm94eU5leHRCdXR0b24sIFwiY3Vyc29yXCIsIHRoaXMucGFnaW5hdGlvbi5nZXRDdXJzb3IoXCJuZXh0XCIpKTtcbiAgICBzZXRFbGVtZW50U3R5bGUodGhpcy5wcm94eVByZXZCdXR0b24sIFwiY3Vyc29yXCIsIHRoaXMucGFnaW5hdGlvbi5nZXRDdXJzb3IoXCJwcmV2aW91c1wiKSk7XG4gICAgdGhpcy5jdHgudXBkYXRlU2VydmljZS51cGRhdGUoNiAvKiBTQ0VORV9SRU5ERVIgKi8pO1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBsYWJlbDogeyBjb2xvciB9XG4gICAgfSA9IHRoaXMuaXRlbTtcbiAgICB0aGlzLml0ZW1TZWxlY3Rpb24uZWFjaCgobWFya2VyTGFiZWwsIGRhdHVtKSA9PiB7XG4gICAgICBtYXJrZXJMYWJlbC5zZXRFbmFibGVkKGRhdHVtLmVuYWJsZWQpO1xuICAgICAgbWFya2VyTGFiZWwuY29sb3IgPSBjb2xvcjtcbiAgICB9KTtcbiAgICB0aGlzLnVwZGF0ZUNvbnRleHRNZW51KCk7XG4gIH1cbiAgdXBkYXRlQ29udGV4dE1lbnUoKSB7XG4gICAgY29uc3Qge1xuICAgICAgdG9nZ2xlU2VyaWVzLFxuICAgICAgY3R4OiB7IGNvbnRleHRNZW51UmVnaXN0cnkgfVxuICAgIH0gPSB0aGlzO1xuICAgIGlmICh0b2dnbGVTZXJpZXMpIHtcbiAgICAgIGNvbnRleHRNZW51UmVnaXN0cnkuaGlkZUFjdGlvbihJRF9MRUdFTkRfVklTSUJJTElUWSk7XG4gICAgICBjb250ZXh0TWVudVJlZ2lzdHJ5LmhpZGVBY3Rpb24oSURfTEVHRU5EX09USEVSX1NFUklFUyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHRNZW51UmVnaXN0cnkuc2hvd0FjdGlvbihJRF9MRUdFTkRfVklTSUJJTElUWSk7XG4gICAgICBjb250ZXh0TWVudVJlZ2lzdHJ5LnNob3dBY3Rpb24oSURfTEVHRU5EX09USEVSX1NFUklFUyk7XG4gICAgfVxuICB9XG4gIGdldExpbmVTdHlsZXMoZGF0dW0pIHtcbiAgICBjb25zdCB7IHN0cm9rZSwgc3Ryb2tlT3BhY2l0eSA9IDEsIHN0cm9rZVdpZHRoLCBsaW5lRGFzaCB9ID0gZGF0dW0ubGluZSA/PyB7fTtcbiAgICBjb25zdCBkZWZhdWx0TGluZVN0cm9rZVdpZHRoID0gTWF0aC5taW4oMiwgc3Ryb2tlV2lkdGggPz8gMSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0cm9rZSxcbiAgICAgIHN0cm9rZU9wYWNpdHksXG4gICAgICBzdHJva2VXaWR0aDogdGhpcy5pdGVtLmxpbmUuc3Ryb2tlV2lkdGggPz8gZGVmYXVsdExpbmVTdHJva2VXaWR0aCxcbiAgICAgIGxpbmVEYXNoXG4gICAgfTtcbiAgfVxuICBnZXRNYXJrZXJTdHlsZXMoZGF0dW0pIHtcbiAgICBjb25zdCB7IGZpbGwsIHN0cm9rZSwgc3Ryb2tlT3BhY2l0eSA9IDEsIGZpbGxPcGFjaXR5ID0gMSwgc3Ryb2tlV2lkdGggfSA9IGRhdHVtLm1hcmtlcjtcbiAgICBjb25zdCBkZWZhdWx0TGluZVN0cm9rZVdpZHRoID0gTWF0aC5taW4oMiwgc3Ryb2tlV2lkdGggPz8gMSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpbGwsXG4gICAgICBzdHJva2UsXG4gICAgICBzdHJva2VPcGFjaXR5LFxuICAgICAgZmlsbE9wYWNpdHksXG4gICAgICBzdHJva2VXaWR0aDogdGhpcy5pdGVtLm1hcmtlci5zdHJva2VXaWR0aCA/PyBkZWZhdWx0TGluZVN0cm9rZVdpZHRoXG4gICAgfTtcbiAgfVxuICBjb21wdXRlUGFnZWRCQm94KCkge1xuICAgIGNvbnN0IGFjdHVhbEJCb3ggPSBHcm91cC5jb21wdXRlQ2hpbGRyZW5CQm94KHRoaXMuZ3JvdXAuY2hpbGRyZW4oKSk7XG4gICAgaWYgKHRoaXMucGFnZXMubGVuZ3RoID4gMSkge1xuICAgICAgY29uc3QgW21heFBhZ2VXaWR0aCwgbWF4UGFnZUhlaWdodF0gPSB0aGlzLm1heFBhZ2VTaXplO1xuICAgICAgYWN0dWFsQkJveC5oZWlnaHQgPSBNYXRoLm1heChtYXhQYWdlSGVpZ2h0LCBhY3R1YWxCQm94LmhlaWdodCk7XG4gICAgICBhY3R1YWxCQm94LndpZHRoID0gTWF0aC5tYXgobWF4UGFnZVdpZHRoLCBhY3R1YWxCQm94LndpZHRoKTtcbiAgICB9XG4gICAgcmV0dXJuIGFjdHVhbEJCb3g7XG4gIH1cbiAgZmluZE5vZGUocGFyYW1zKSB7XG4gICAgY29uc3QgeyBkYXR1bSwgcHJveHlCdXR0b24gfSA9IHRoaXMuaXRlbVNlbGVjdGlvbi5zZWxlY3QoKG1sKSA9PiBtbC5kYXR1bT8uaXRlbUlkID09PSBwYXJhbXMuaXRlbUlkKVswXSA/PyB7fTtcbiAgICBpZiAoZGF0dW0gPT09IHZvaWQgMCB8fCBwcm94eUJ1dHRvbiA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFHIENoYXJ0cyAtIE1pc3NpbmcgcmVxdWlyZWQgcHJvcGVydGllcyB7IGRhdHVtOiAke2RhdHVtfSwgcHJveHlCdXR0b246ICR7cHJveHlCdXR0b259IH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZGF0dW0sIHByb3h5QnV0dG9uIH07XG4gIH1cbiAgY29udGV4dFRvZ2dsZVZpc2liaWxpdHkocGFyYW1zKSB7XG4gICAgY29uc3QgeyBkYXR1bSwgcHJveHlCdXR0b24gfSA9IHRoaXMuZmluZE5vZGUocGFyYW1zKTtcbiAgICB0aGlzLmRvQ2xpY2socGFyYW1zLmV2ZW50LCBkYXR1bSwgcHJveHlCdXR0b24uYnV0dG9uKTtcbiAgfVxuICBjb250ZXh0VG9nZ2xlT3RoZXJTZXJpZXMocGFyYW1zKSB7XG4gICAgdGhpcy5kb0RvdWJsZUNsaWNrKHBhcmFtcy5ldmVudCwgdGhpcy5maW5kTm9kZShwYXJhbXMpLmRhdHVtKTtcbiAgfVxuICBvbkNvbnRleHRDbGljayhzb3VyY2VFdmVudCwgbm9kZSkge1xuICAgIGNvbnN0IGxlZ2VuZEl0ZW0gPSBub2RlLmRhdHVtO1xuICAgIGlmICh0aGlzLnByZXZlbnRIaWRpbmdBbGwgJiYgdGhpcy5jb250ZXh0TWVudURhdHVtPy5lbmFibGVkICYmIHRoaXMuZ2V0VmlzaWJsZUl0ZW1Db3VudCgpIDw9IDEpIHtcbiAgICAgIHRoaXMuY3R4LmNvbnRleHRNZW51UmVnaXN0cnkuZGlzYWJsZUFjdGlvbihJRF9MRUdFTkRfVklTSUJJTElUWSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3R4LmNvbnRleHRNZW51UmVnaXN0cnkuZW5hYmxlQWN0aW9uKElEX0xFR0VORF9WSVNJQklMSVRZKTtcbiAgICB9XG4gICAgY29uc3QgeyBidXR0b24sIG9mZnNldFgsIG9mZnNldFkgfSA9IHNvdXJjZUV2ZW50O1xuICAgIGNvbnN0IHsgeDogY2FudmFzT2Zmc2V0WCwgeTogY2FudmFzT2Zmc2V0WSB9ID0gVHJhbnNmb3JtYWJsZS50b0NhbnZhc1BvaW50KG5vZGUsIG9mZnNldFgsIG9mZnNldFkpO1xuICAgIGNvbnN0IGV2ZW50ID0ge1xuICAgICAgdHlwZTogXCJjb250ZXh0bWVudVwiLFxuICAgICAgc291cmNlRXZlbnQsXG4gICAgICBidXR0b24sXG4gICAgICBvZmZzZXRYOiBjYW52YXNPZmZzZXRYLFxuICAgICAgb2Zmc2V0WTogY2FudmFzT2Zmc2V0WSxcbiAgICAgIGRlbHRhWDogMCxcbiAgICAgIGRlbHRhWTogMCxcbiAgICAgIHBhZ2VYOiBOYU4sXG4gICAgICBwYWdlWTogTmFOLFxuICAgICAgcHJldmVudERlZmF1bHQ6ICgpID0+IHNvdXJjZUV2ZW50LnByZXZlbnREZWZhdWx0KCksXG4gICAgICBwb2ludGVySGlzdG9yeTogW11cbiAgICB9O1xuICAgIHRoaXMuY3R4LmNvbnRleHRNZW51UmVnaXN0cnkuZGlzcGF0Y2hDb250ZXh0KFwibGVnZW5kXCIsIGV2ZW50LCB7IGxlZ2VuZEl0ZW0gfSk7XG4gIH1cbiAgb25DbGljayhldmVudCwgZGF0dW0sIHByb3h5QnV0dG9uKSB7XG4gICAgaWYgKHRoaXMuZG9DbGljayhldmVudCwgZGF0dW0sIHByb3h5QnV0dG9uKSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cbiAgZ2V0VmlzaWJsZUl0ZW1Db3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5jdHguY2hhcnRTZXJ2aWNlLnNlcmllcy5mbGF0TWFwKChzKSA9PiBzLmdldExlZ2VuZERhdGEoXCJjYXRlZ29yeVwiKSkuZmlsdGVyKChkKSA9PiBkLmVuYWJsZWQpLmxlbmd0aDtcbiAgfVxuICBkb0NsaWNrKGV2ZW50LCBkYXR1bSwgcHJveHlCdXR0b24pIHtcbiAgICBjb25zdCB7XG4gICAgICBsaXN0ZW5lcnM6IHsgbGVnZW5kSXRlbUNsaWNrIH0sXG4gICAgICBjdHg6IHsgY2hhcnRTZXJ2aWNlLCBoaWdobGlnaHRNYW5hZ2VyIH0sXG4gICAgICBwcmV2ZW50SGlkaW5nQWxsLFxuICAgICAgdG9nZ2xlU2VyaWVzXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFkYXR1bSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB7IGlkLCBpdGVtSWQsIGVuYWJsZWQgfSA9IGRhdHVtO1xuICAgIGNvbnN0IHNlcmllcyA9IGNoYXJ0U2VydmljZS5zZXJpZXMuZmluZCgocykgPT4gcy5pZCA9PT0gaWQpO1xuICAgIGlmICghc2VyaWVzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBuZXdFbmFibGVkID0gZW5hYmxlZDtcbiAgICBjb25zdCBjbGlja0V2ZW50ID0gbmV3IExlZ2VuZEl0ZW1FdmVudChcImNsaWNrXCIsIG5ld0VuYWJsZWQsIGl0ZW1JZCwgc2VyaWVzLmlkLCBldmVudCk7XG4gICAgbGVnZW5kSXRlbUNsaWNrPy4oY2xpY2tFdmVudCk7XG4gICAgaWYgKGNsaWNrRXZlbnQuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmICh0b2dnbGVTZXJpZXMpIHtcbiAgICAgIG5ld0VuYWJsZWQgPSAhZW5hYmxlZDtcbiAgICAgIGlmIChwcmV2ZW50SGlkaW5nQWxsICYmICFuZXdFbmFibGVkKSB7XG4gICAgICAgIGNvbnN0IG51bVZpc2libGVJdGVtcyA9IHRoaXMuZ2V0VmlzaWJsZUl0ZW1Db3VudCgpO1xuICAgICAgICBpZiAobnVtVmlzaWJsZUl0ZW1zIDwgMikge1xuICAgICAgICAgIG5ld0VuYWJsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwcm94eUJ1dHRvbi5hcmlhQ2hlY2tlZCA9IG5ld0VuYWJsZWQudG9TdHJpbmcoKTtcbiAgICAgIHRoaXMuY3R4LmNoYXJ0RXZlbnRNYW5hZ2VyLmxlZ2VuZEl0ZW1DbGljayhzZXJpZXMsIGl0ZW1JZCwgbmV3RW5hYmxlZCwgZGF0dW0ubGVnZW5kSXRlbU5hbWUpO1xuICAgIH1cbiAgICBpZiAobmV3RW5hYmxlZCkge1xuICAgICAgaGlnaGxpZ2h0TWFuYWdlci51cGRhdGVIaWdobGlnaHQodGhpcy5pZCwge1xuICAgICAgICBzZXJpZXMsXG4gICAgICAgIGl0ZW1JZCxcbiAgICAgICAgZGF0dW06IHZvaWQgMFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhpZ2hsaWdodE1hbmFnZXIudXBkYXRlSGlnaGxpZ2h0KHRoaXMuaWQpO1xuICAgIH1cbiAgICB0aGlzLmN0eC51cGRhdGVTZXJ2aWNlLnVwZGF0ZSgyIC8qIFBST0NFU1NfREFUQSAqLywgeyBmb3JjZU5vZGVEYXRhUmVmcmVzaDogdHJ1ZSB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBvbkRvdWJsZUNsaWNrKGV2ZW50LCBkYXR1bSkge1xuICAgIGlmICh0aGlzLmRvRG91YmxlQ2xpY2soZXZlbnQsIGRhdHVtKSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cbiAgZG9Eb3VibGVDbGljayhldmVudCwgZGF0dW0pIHtcbiAgICBjb25zdCB7XG4gICAgICBsaXN0ZW5lcnM6IHsgbGVnZW5kSXRlbURvdWJsZUNsaWNrIH0sXG4gICAgICBjdHg6IHsgY2hhcnRTZXJ2aWNlIH0sXG4gICAgICB0b2dnbGVTZXJpZXNcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoY2hhcnRTZXJ2aWNlLm1vZGUgPT09IFwiaW50ZWdyYXRlZFwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghZGF0dW0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgeyBpZCwgaXRlbUlkLCBzZXJpZXNJZCB9ID0gZGF0dW07XG4gICAgY29uc3Qgc2VyaWVzID0gY2hhcnRTZXJ2aWNlLnNlcmllcy5maW5kKChzKSA9PiBzLmlkID09PSBpZCk7XG4gICAgaWYgKCFzZXJpZXMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgZG91YmxlQ2xpY2tFdmVudCA9IG5ldyBMZWdlbmRJdGVtRXZlbnQoXCJkYmxjbGlja1wiLCB0cnVlLCBpdGVtSWQsIHNlcmllcy5pZCwgZXZlbnQpO1xuICAgIGxlZ2VuZEl0ZW1Eb3VibGVDbGljaz8uKGRvdWJsZUNsaWNrRXZlbnQpO1xuICAgIGlmIChkb3VibGVDbGlja0V2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAodG9nZ2xlU2VyaWVzKSB7XG4gICAgICBjb25zdCBsZWdlbmREYXRhID0gY2hhcnRTZXJ2aWNlLnNlcmllcy5mbGF0TWFwKChzKSA9PiBzLmdldExlZ2VuZERhdGEoXCJjYXRlZ29yeVwiKSk7XG4gICAgICBjb25zdCBudW1WaXNpYmxlSXRlbXMgPSBsZWdlbmREYXRhLmZpbHRlcigoZCkgPT4gZC5lbmFibGVkKS5sZW5ndGg7XG4gICAgICBjb25zdCBjbGlja2VkSXRlbSA9IGxlZ2VuZERhdGEuZmluZCgoZCkgPT4gZC5pdGVtSWQgPT09IGl0ZW1JZCAmJiBkLnNlcmllc0lkID09PSBzZXJpZXNJZCk7XG4gICAgICB0aGlzLmN0eC5jaGFydEV2ZW50TWFuYWdlci5sZWdlbmRJdGVtRG91YmxlQ2xpY2soXG4gICAgICAgIHNlcmllcyxcbiAgICAgICAgaXRlbUlkLFxuICAgICAgICBjbGlja2VkSXRlbT8uZW5hYmxlZCA/PyBmYWxzZSxcbiAgICAgICAgbnVtVmlzaWJsZUl0ZW1zLFxuICAgICAgICBjbGlja2VkSXRlbT8ubGVnZW5kSXRlbU5hbWVcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuY3R4LnVwZGF0ZVNlcnZpY2UudXBkYXRlKDIgLyogUFJPQ0VTU19EQVRBICovLCB7IGZvcmNlTm9kZURhdGFSZWZyZXNoOiB0cnVlIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHRvVG9vbHRpcE1ldGEoZXZlbnQsIG5vZGUpIHtcbiAgICBsZXQgbGFzdFBvaW50ZXJFdmVudDtcbiAgICBpZiAoZXZlbnQgaW5zdGFuY2VvZiBGb2N1c0V2ZW50KSB7XG4gICAgICBjb25zdCB7IHgsIHkgfSA9IFRyYW5zZm9ybWFibGUudG9DYW52YXMobm9kZSkuY29tcHV0ZUNlbnRlcigpO1xuICAgICAgbGFzdFBvaW50ZXJFdmVudCA9IHsgdHlwZTogXCJrZXlib2FyZFwiLCBvZmZzZXRYOiB4LCBvZmZzZXRZOiB5IH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBjb25zdCB7IHgsIHkgfSA9IFRyYW5zZm9ybWFibGUudG9DYW52YXNQb2ludChub2RlLCBldmVudC5vZmZzZXRYLCBldmVudC5vZmZzZXRZKTtcbiAgICAgIGxhc3RQb2ludGVyRXZlbnQgPSB7IHR5cGU6IFwiaG92ZXJcIiwgb2Zmc2V0WDogeCwgb2Zmc2V0WTogeSB9O1xuICAgIH1cbiAgICBjb25zdCB7IG9mZnNldFgsIG9mZnNldFkgfSA9IGxhc3RQb2ludGVyRXZlbnQ7XG4gICAgcmV0dXJuIHsgb2Zmc2V0WCwgb2Zmc2V0WSwgbGFzdFBvaW50ZXJFdmVudCwgc2hvd0Fycm93OiBmYWxzZSB9O1xuICB9XG4gIG9uSG92ZXIoZXZlbnQsIG5vZGUpIHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlZClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFHIENoYXJ0cyAtIG9uSG92ZXIgaGFuZGxlciBjYWxsZWQgb24gZGlzYWJsZWQgbGVnZW5kXCIpO1xuICAgIHRoaXMucGFnaW5hdGlvbi5zZXRQYWdlKG5vZGUucGFnZUluZGV4KTtcbiAgICBjb25zdCBkYXR1bSA9IG5vZGUuZGF0dW07XG4gICAgY29uc3Qgc2VyaWVzID0gZGF0dW0gPyB0aGlzLmN0eC5jaGFydFNlcnZpY2Uuc2VyaWVzLmZpbmQoKHMpID0+IHMuaWQgPT09IGRhdHVtPy5pZCkgOiB2b2lkIDA7XG4gICAgaWYgKGRhdHVtICYmIHRoaXMudHJ1bmNhdGVkSXRlbXMuaGFzKGRhdHVtLml0ZW1JZCA/PyBkYXR1bS5pZCkpIHtcbiAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLnRvVG9vbHRpcE1ldGEoZXZlbnQsIG5vZGUpO1xuICAgICAgdGhpcy5jdHgudG9vbHRpcE1hbmFnZXIudXBkYXRlVG9vbHRpcCh0aGlzLmlkLCBtZXRhLCB0b1Rvb2x0aXBIdG1sKHsgY29udGVudDogdGhpcy5nZXRJdGVtTGFiZWwoZGF0dW0pIH0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jdHgudG9vbHRpcE1hbmFnZXIucmVtb3ZlVG9vbHRpcCh0aGlzLmlkKTtcbiAgICB9XG4gICAgaWYgKGRhdHVtPy5lbmFibGVkICYmIHNlcmllcykge1xuICAgICAgdGhpcy51cGRhdGVIaWdobGlnaHQoeyBzZXJpZXMsIGl0ZW1JZDogZGF0dW0/Lml0ZW1JZCwgZGF0dW06IHZvaWQgMCB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51cGRhdGVIaWdobGlnaHQoKTtcbiAgICB9XG4gIH1cbiAgb25MZWF2ZSgpIHtcbiAgICB0aGlzLmN0eC50b29sdGlwTWFuYWdlci5yZW1vdmVUb29sdGlwKHRoaXMuaWQpO1xuICAgIHRoaXMudXBkYXRlSGlnaGxpZ2h0KCk7XG4gIH1cbiAgdXBkYXRlSGlnaGxpZ2h0KGRhdHVtKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLmN0eC5pbnRlcmFjdGlvbk1hbmFnZXIuZ2V0U3RhdGUoKTtcbiAgICBpZiAoc3RhdGUgPT09IDMyIC8qIERlZmF1bHQgKi8pIHtcbiAgICAgIHRoaXMuY3R4LmhpZ2hsaWdodE1hbmFnZXIudXBkYXRlSGlnaGxpZ2h0KHRoaXMuaWQsIGRhdHVtKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlID09PSAyIC8qIEFuaW1hdGlvbiAqLykge1xuICAgICAgdGhpcy5wZW5kaW5nSGlnaGxpZ2h0RGF0dW0gPSBkYXR1bTtcbiAgICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIub25CYXRjaFN0b3AoKCkgPT4ge1xuICAgICAgICB0aGlzLmN0eC5oaWdobGlnaHRNYW5hZ2VyLnVwZGF0ZUhpZ2hsaWdodCh0aGlzLmlkLCB0aGlzLnBlbmRpbmdIaWdobGlnaHREYXR1bSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgb25Mb2NhbGVDaGFuZ2VkKCkge1xuICAgIHRoaXMuaXRlbVNlbGVjdGlvbi5lYWNoKCh7IHByb3h5QnV0dG9uIH0sIF8sIGkpID0+IHtcbiAgICAgIGlmIChwcm94eUJ1dHRvbj8uYnV0dG9uICE9IG51bGwpIHtcbiAgICAgICAgcHJveHlCdXR0b24uYnV0dG9uLnRleHRDb250ZW50ID0gdGhpcy5nZXRJdGVtQXJpYVRleHQoaSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5wcm94eUxlZ2VuZEl0ZW1EZXNjcmlwdGlvbi50ZXh0Q29udGVudCA9IHRoaXMuZ2V0SXRlbUFyaWFEZXNjcmlwdGlvbigpO1xuICB9XG4gIGdldEl0ZW1BcmlhVGV4dChub2RlSW5kZXgpIHtcbiAgICBjb25zdCBkYXR1bSA9IHRoaXMuZGF0YVtub2RlSW5kZXhdO1xuICAgIGNvbnN0IGxhYmVsID0gZGF0dW0gJiYgdGhpcy5nZXRJdGVtTGFiZWwoZGF0dW0pO1xuICAgIGNvbnN0IGxtID0gdGhpcy5jdHgubG9jYWxlTWFuYWdlcjtcbiAgICBpZiAobm9kZUluZGV4ID49IDAgJiYgbGFiZWwpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gbm9kZUluZGV4ICsgMTtcbiAgICAgIGNvbnN0IGNvdW50ID0gdGhpcy5kYXRhLmxlbmd0aDtcbiAgICAgIHJldHVybiBsbS50KFwiYXJpYUxhYmVsTGVnZW5kSXRlbVwiLCB7IGxhYmVsLCBpbmRleCwgY291bnQgfSk7XG4gICAgfVxuICAgIHJldHVybiBsbS50KFwiYXJpYUxhYmVsTGVnZW5kSXRlbVVua25vd25cIik7XG4gIH1cbiAgZ2V0SXRlbUFyaWFEZXNjcmlwdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jdHgubG9jYWxlTWFuYWdlci50KFwiYXJpYURlc2NyaXB0aW9uTGVnZW5kSXRlbVwiKTtcbiAgfVxuICBwb3NpdGlvbkxlZ2VuZChjdHgpIHtcbiAgICBzZXRFbGVtZW50U3R5bGUodGhpcy5wcm94eUxlZ2VuZFRvb2xiYXIsIFwiZGlzcGxheVwiLCB0aGlzLnZpc2libGUgJiYgdGhpcy5lbmFibGVkID8gdm9pZCAwIDogXCJub25lXCIpO1xuICAgIGlmICghdGhpcy5lbmFibGVkIHx8ICF0aGlzLmRhdGEubGVuZ3RoKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgbGF5b3V0Qm94IH0gPSBjdHg7XG4gICAgY29uc3QgeyB4LCB5LCB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIgfSA9IGxheW91dEJveDtcbiAgICBjb25zdCBbbGVnZW5kV2lkdGgsIGxlZ2VuZEhlaWdodF0gPSB0aGlzLmNhbGN1bGF0ZUxlZ2VuZERpbWVuc2lvbnMobGF5b3V0Qm94KTtcbiAgICBjb25zdCB7IG9sZFBhZ2VzIH0gPSB0aGlzLmNhbGNMYXlvdXQobGVnZW5kV2lkdGgsIGxlZ2VuZEhlaWdodCk7XG4gICAgY29uc3QgbGVnZW5kQkJveCA9IHRoaXMuY29tcHV0ZVBhZ2VkQkJveCgpO1xuICAgIGNvbnN0IGNhbGN1bGF0ZVRyYW5zbGF0aW9uUGVycGVuZGljdWxhckRpbWVuc2lvbiA9ICgpID0+IHtcbiAgICAgIHN3aXRjaCAodGhpcy5wb3NpdGlvbikge1xuICAgICAgICBjYXNlIFwidG9wXCI6XG4gICAgICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgICAgICByZXR1cm4gaGVpZ2h0MiAtIGxlZ2VuZEJCb3guaGVpZ2h0O1xuICAgICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gd2lkdGgyIC0gbGVnZW5kQkJveC53aWR0aDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmICh0aGlzLnZpc2libGUpIHtcbiAgICAgIGNvbnN0IGxlZ2VuZFBhZGRpbmcgPSB0aGlzLnNwYWNpbmc7XG4gICAgICBsZXQgdHJhbnNsYXRpb25YO1xuICAgICAgbGV0IHRyYW5zbGF0aW9uWTtcbiAgICAgIHN3aXRjaCAodGhpcy5wb3NpdGlvbikge1xuICAgICAgICBjYXNlIFwidG9wXCI6XG4gICAgICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgICAgICB0cmFuc2xhdGlvblggPSAod2lkdGgyIC0gbGVnZW5kQkJveC53aWR0aCkgLyAyO1xuICAgICAgICAgIHRyYW5zbGF0aW9uWSA9IGNhbGN1bGF0ZVRyYW5zbGF0aW9uUGVycGVuZGljdWxhckRpbWVuc2lvbigpO1xuICAgICAgICAgIGxheW91dEJveC5zaHJpbmsobGVnZW5kQkJveC5oZWlnaHQgKyBsZWdlbmRQYWRkaW5nLCB0aGlzLnBvc2l0aW9uKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdHJhbnNsYXRpb25YID0gY2FsY3VsYXRlVHJhbnNsYXRpb25QZXJwZW5kaWN1bGFyRGltZW5zaW9uKCk7XG4gICAgICAgICAgdHJhbnNsYXRpb25ZID0gKGhlaWdodDIgLSBsZWdlbmRCQm94LmhlaWdodCkgLyAyO1xuICAgICAgICAgIGxheW91dEJveC5zaHJpbmsobGVnZW5kQkJveC53aWR0aCArIGxlZ2VuZFBhZGRpbmcsIHRoaXMucG9zaXRpb24pO1xuICAgICAgfVxuICAgICAgdGhpcy5ncm91cC50cmFuc2xhdGlvblggPSBNYXRoLmZsb29yKHggKyB0cmFuc2xhdGlvblggLSBsZWdlbmRCQm94LngpO1xuICAgICAgdGhpcy5ncm91cC50cmFuc2xhdGlvblkgPSBNYXRoLmZsb29yKHkgKyB0cmFuc2xhdGlvblkgLSBsZWdlbmRCQm94LnkpO1xuICAgICAgdGhpcy5wcm94eUxlZ2VuZFRvb2xiYXIuYXJpYU9yaWVudGF0aW9uID0gdGhpcy5nZXRPcmllbnRhdGlvbigpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUl0ZW1Qcm94eUJ1dHRvbnMoKTtcbiAgICB0aGlzLnVwZGF0ZVBhZ2luYXRpb25Qcm94eUJ1dHRvbnMob2xkUGFnZXMpO1xuICB9XG4gIGNhbGN1bGF0ZUxlZ2VuZERpbWVuc2lvbnMoc2hyaW5rUmVjdCkge1xuICAgIGNvbnN0IHsgd2lkdGg6IHdpZHRoMiwgaGVpZ2h0OiBoZWlnaHQyIH0gPSBzaHJpbmtSZWN0O1xuICAgIGNvbnN0IGFzcGVjdFJhdGlvID0gd2lkdGgyIC8gaGVpZ2h0MjtcbiAgICBjb25zdCBtYXhDb2VmZmljaWVudCA9IDAuNTtcbiAgICBjb25zdCBtaW5IZWlnaHRDb2VmZmljaWVudCA9IDAuMjtcbiAgICBjb25zdCBtaW5XaWR0aENvZWZmaWNpZW50ID0gMC4yNTtcbiAgICBsZXQgbGVnZW5kV2lkdGgsIGxlZ2VuZEhlaWdodDtcbiAgICBzd2l0Y2ggKHRoaXMucG9zaXRpb24pIHtcbiAgICAgIGNhc2UgXCJ0b3BcIjpcbiAgICAgIGNhc2UgXCJib3R0b21cIjoge1xuICAgICAgICBjb25zdCBoZWlnaHRDb2VmZmljaWVudCA9IGFzcGVjdFJhdGlvIDwgMSA/IE1hdGgubWluKG1heENvZWZmaWNpZW50LCBtaW5IZWlnaHRDb2VmZmljaWVudCAqICgxIC8gYXNwZWN0UmF0aW8pKSA6IG1pbkhlaWdodENvZWZmaWNpZW50O1xuICAgICAgICBsZWdlbmRXaWR0aCA9IHRoaXMubWF4V2lkdGggPyBNYXRoLm1pbih0aGlzLm1heFdpZHRoLCB3aWR0aDIpIDogd2lkdGgyO1xuICAgICAgICBsZWdlbmRIZWlnaHQgPSB0aGlzLm1heEhlaWdodCA/IE1hdGgubWluKHRoaXMubWF4SGVpZ2h0LCBoZWlnaHQyKSA6IE1hdGgucm91bmQoaGVpZ2h0MiAqIGhlaWdodENvZWZmaWNpZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGNvbnN0IHdpZHRoQ29lZmZpY2llbnQgPSBhc3BlY3RSYXRpbyA+IDEgPyBNYXRoLm1pbihtYXhDb2VmZmljaWVudCwgbWluV2lkdGhDb2VmZmljaWVudCAqIGFzcGVjdFJhdGlvKSA6IG1pbldpZHRoQ29lZmZpY2llbnQ7XG4gICAgICAgIGxlZ2VuZFdpZHRoID0gdGhpcy5tYXhXaWR0aCA/IE1hdGgubWluKHRoaXMubWF4V2lkdGgsIHdpZHRoMikgOiBNYXRoLnJvdW5kKHdpZHRoMiAqIHdpZHRoQ29lZmZpY2llbnQpO1xuICAgICAgICBsZWdlbmRIZWlnaHQgPSB0aGlzLm1heEhlaWdodCA/IE1hdGgubWluKHRoaXMubWF4SGVpZ2h0LCBoZWlnaHQyKSA6IGhlaWdodDI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbbGVnZW5kV2lkdGgsIGxlZ2VuZEhlaWdodF07XG4gIH1cbn07XG5MZWdlbmQuY2xhc3NOYW1lID0gXCJMZWdlbmRcIjtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBMZWdlbmQucHJvdG90eXBlLCBcInRvZ2dsZVNlcmllc1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIExlZ2VuZC5wcm90b3R5cGUsIFwicGFnaW5hdGlvblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIExlZ2VuZC5wcm90b3R5cGUsIFwiaXRlbVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIExlZ2VuZC5wcm90b3R5cGUsIFwibGlzdGVuZXJzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgT2JzZXJ2ZUNoYW5nZXMoKHRhcmdldCkgPT4gdGFyZ2V0LnVwZGF0ZUdyb3VwVmlzaWJpbGl0eSgpKSxcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIExlZ2VuZC5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIE9ic2VydmVDaGFuZ2VzKCh0YXJnZXQpID0+IHRhcmdldC5wcm94eUxlZ2VuZERpcnR5ID0gdHJ1ZSksXG4gIFZhbGlkYXRlKFBPU0lUSU9OKVxuXSwgTGVnZW5kLnByb3RvdHlwZSwgXCJwb3NpdGlvblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGVnZW5kLnByb3RvdHlwZSwgXCJtYXhXaWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGVnZW5kLnByb3RvdHlwZSwgXCJtYXhIZWlnaHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBMZWdlbmQucHJvdG90eXBlLCBcInJldmVyc2VPcmRlclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFVOSU9OKFtcImhvcml6b250YWxcIiwgXCJ2ZXJ0aWNhbFwiXSwgXCJhbiBvcmllbnRhdGlvblwiKSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGVnZW5kLnByb3RvdHlwZSwgXCJvcmllbnRhdGlvblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIExlZ2VuZC5wcm90b3R5cGUsIFwicHJldmVudEhpZGluZ0FsbFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIExlZ2VuZC5wcm90b3R5cGUsIFwic3BhY2luZ1wiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbGVnZW5kTW9kdWxlLnRzXG52YXIgQ29tbXVuaXR5TGVnZW5kTW9kdWxlID0ge1xuICB0eXBlOiBcImxlZ2VuZFwiLFxuICBvcHRpb25zS2V5OiBcImxlZ2VuZFwiLFxuICBpZGVudGlmaWVyOiBcImNhdGVnb3J5XCIsXG4gIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiLCBcInBvbGFyXCIsIFwiaGllcmFyY2h5XCIsIFwidG9wb2xvZ3lcIiwgXCJmbG93LXByb3BvcnRpb25cIiwgXCJzdGFuZGFsb25lXCIsIFwiZ2F1Z2VcIl0sXG4gIG1vZHVsZUZhY3Rvcnk6IChjdHgpID0+IG5ldyBMZWdlbmQoY3R4KSxcbiAgcGFja2FnZVR5cGU6IFwiY29tbXVuaXR5XCJcbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L25hdmlnYXRvci9zaGFwZXMvcmFuZ2VIYW5kbGUudHNcbnZhciBSYW5nZUhhbmRsZSA9IGNsYXNzIGV4dGVuZHMgUGF0aCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy56SW5kZXggPSAzO1xuICAgIHRoaXMuY2VudGVyWCA9IDA7XG4gICAgdGhpcy5jZW50ZXJZID0gMDtcbiAgICB0aGlzLndpZHRoID0gODtcbiAgICB0aGlzLmhlaWdodCA9IDE2O1xuICAgIHRoaXMuZ3JpcExpbmVHYXAgPSAyO1xuICAgIHRoaXMuZ3JpcExpbmVMZW5ndGggPSA4O1xuICB9XG4gIHNldENlbnRlcih4LCB5KSB7XG4gICAgdGhpcy5kaXJ0eVBhdGggPSB0cnVlO1xuICAgIGlmICh0aGlzLmNlbnRlclggIT09IHggfHwgdGhpcy5jZW50ZXJZICE9PSB5KSB7XG4gICAgICB0aGlzLmNlbnRlclggPSB4O1xuICAgICAgdGhpcy5jZW50ZXJZID0geTtcbiAgICAgIHRoaXMubWFya0RpcnR5KDMgLyogTUFKT1IgKi8pO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgYWxpZ24obWluSGFuZGxlLCBtYXhIYW5kbGUsIHgsIHksIHdpZHRoMiwgaGVpZ2h0MiwgbWluLCBtYXgpIHtcbiAgICBjb25zdCBoYW5kbGVQaXhlbEFsaWduID0gbWluSGFuZGxlLnN0cm9rZVdpZHRoIC8gMjtcbiAgICBjb25zdCBtaW5IYW5kbGVYID0gbWluSGFuZGxlLmFsaWduKHggKyB3aWR0aDIgKiBtaW4pICsgaGFuZGxlUGl4ZWxBbGlnbjtcbiAgICBjb25zdCBtYXhIYW5kbGVYID0gbWluSGFuZGxlWCArIG1pbkhhbmRsZS5hbGlnbih4ICsgd2lkdGgyICogbWluLCB3aWR0aDIgKiAobWF4IC0gbWluKSkgLSAyICogaGFuZGxlUGl4ZWxBbGlnbjtcbiAgICBjb25zdCBoYW5kbGVZID0gbWluSGFuZGxlLmFsaWduKHkgKyBoZWlnaHQyIC8gMikgKyBoYW5kbGVQaXhlbEFsaWduO1xuICAgIG1pbkhhbmRsZS5zZXRDZW50ZXIobWluSGFuZGxlWCwgaGFuZGxlWSk7XG4gICAgbWF4SGFuZGxlLnNldENlbnRlcihtYXhIYW5kbGVYLCBoYW5kbGVZKTtcbiAgfVxuICBjb21wdXRlQkJveCgpIHtcbiAgICBjb25zdCB7IGNlbnRlclgsIGNlbnRlclksIHdpZHRoOiB3aWR0aDIsIGhlaWdodDogaGVpZ2h0MiB9ID0gdGhpcztcbiAgICBjb25zdCB4ID0gY2VudGVyWCAtIHdpZHRoMiAvIDI7XG4gICAgY29uc3QgeSA9IGNlbnRlclkgLSBoZWlnaHQyIC8gMjtcbiAgICByZXR1cm4gbmV3IEJCb3goeCwgeSwgd2lkdGgyLCBoZWlnaHQyKTtcbiAgfVxuICBpc1BvaW50SW5QYXRoKHgsIHkpIHtcbiAgICBjb25zdCBiYm94ID0gdGhpcy5nZXRCQm94KCk7XG4gICAgcmV0dXJuIGJib3guY29udGFpbnNQb2ludCh4LCB5KTtcbiAgfVxuICB1cGRhdGVQYXRoKCkge1xuICAgIGNvbnN0IHsgY2VudGVyWCwgY2VudGVyWSwgcGF0aCwgc3Ryb2tlV2lkdGgsIGdyaXBMaW5lR2FwLCBncmlwTGluZUxlbmd0aCB9ID0gdGhpcztcbiAgICBjb25zdCBwaXhlbFJhdGlvID0gdGhpcy5sYXllck1hbmFnZXI/LmNhbnZhcz8ucGl4ZWxSYXRpbyA/PyAxO1xuICAgIHBhdGguY2xlYXIoKTtcbiAgICBjb25zdCBoYWxmV2lkdGggPSBNYXRoLmZsb29yKHRoaXMud2lkdGggLyAyICogcGl4ZWxSYXRpbykgLyBwaXhlbFJhdGlvO1xuICAgIGNvbnN0IGhhbGZIZWlnaHQgPSBNYXRoLmZsb29yKHRoaXMuaGVpZ2h0IC8gMiAqIHBpeGVsUmF0aW8pIC8gcGl4ZWxSYXRpbztcbiAgICBwYXRoLm1vdmVUbyhjZW50ZXJYIC0gaGFsZldpZHRoLCBjZW50ZXJZIC0gaGFsZkhlaWdodCk7XG4gICAgcGF0aC5saW5lVG8oY2VudGVyWCArIGhhbGZXaWR0aCwgY2VudGVyWSAtIGhhbGZIZWlnaHQpO1xuICAgIHBhdGgubGluZVRvKGNlbnRlclggKyBoYWxmV2lkdGgsIGNlbnRlclkgKyBoYWxmSGVpZ2h0KTtcbiAgICBwYXRoLmxpbmVUbyhjZW50ZXJYIC0gaGFsZldpZHRoLCBjZW50ZXJZICsgaGFsZkhlaWdodCk7XG4gICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgICBjb25zdCBkeCA9IE1hdGguZmxvb3IoKGdyaXBMaW5lR2FwICsgc3Ryb2tlV2lkdGgpIC8gMiAqIHBpeGVsUmF0aW8pIC8gcGl4ZWxSYXRpbztcbiAgICBjb25zdCBkeSA9IE1hdGguZmxvb3IoZ3JpcExpbmVMZW5ndGggLyAyICogcGl4ZWxSYXRpbykgLyBwaXhlbFJhdGlvO1xuICAgIHBhdGgubW92ZVRvKGNlbnRlclggLSBkeCwgY2VudGVyWSAtIGR5KTtcbiAgICBwYXRoLmxpbmVUbyhjZW50ZXJYIC0gZHgsIGNlbnRlclkgKyBkeSk7XG4gICAgcGF0aC5tb3ZlVG8oY2VudGVyWCArIGR4LCBjZW50ZXJZIC0gZHkpO1xuICAgIHBhdGgubGluZVRvKGNlbnRlclggKyBkeCwgY2VudGVyWSArIGR5KTtcbiAgfVxufTtcblJhbmdlSGFuZGxlLmNsYXNzTmFtZSA9IFwiUmFuZ2VIYW5kbGVcIjtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiksXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovLCB0eXBlOiBcInBhdGhcIiB9KVxuXSwgUmFuZ2VIYW5kbGUucHJvdG90eXBlLCBcIndpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKSxcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8sIHR5cGU6IFwicGF0aFwiIH0pXG5dLCBSYW5nZUhhbmRsZS5wcm90b3R5cGUsIFwiaGVpZ2h0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKSxcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8sIHR5cGU6IFwicGF0aFwiIH0pXG5dLCBSYW5nZUhhbmRsZS5wcm90b3R5cGUsIFwiZ3JpcExpbmVHYXBcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpLFxuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLywgdHlwZTogXCJwYXRoXCIgfSlcbl0sIFJhbmdlSGFuZGxlLnByb3RvdHlwZSwgXCJncmlwTGluZUxlbmd0aFwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbmF2aWdhdG9yL3NoYXBlcy9yYW5nZU1hc2sudHNcbnZhciBSYW5nZU1hc2sgPSBjbGFzcyBleHRlbmRzIFBhdGgge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuekluZGV4ID0gMjtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gICAgdGhpcy53aWR0aCA9IDIwMDtcbiAgICB0aGlzLmhlaWdodCA9IDMwO1xuICAgIHRoaXMubWluID0gMDtcbiAgICB0aGlzLm1heCA9IDE7XG4gIH1cbiAgbGF5b3V0KHgsIHksIHdpZHRoMiwgaGVpZ2h0Mikge1xuICAgIGlmICh4ICE9PSB0aGlzLnggfHwgeSAhPT0gdGhpcy55IHx8IHdpZHRoMiAhPT0gdGhpcy53aWR0aCB8fCB0aGlzLmhlaWdodCAhPT0gaGVpZ2h0Mikge1xuICAgICAgdGhpcy54ID0geDtcbiAgICAgIHRoaXMueSA9IHk7XG4gICAgICB0aGlzLndpZHRoID0gd2lkdGgyO1xuICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQyO1xuICAgICAgdGhpcy5kaXJ0eVBhdGggPSB0cnVlO1xuICAgICAgdGhpcy5tYXJrRGlydHkoMyAvKiBNQUpPUiAqLyk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZShtaW4sIG1heCkge1xuICAgIG1pbiA9IGlzTmFOKG1pbikgPyB0aGlzLm1pbiA6IG1pbjtcbiAgICBtYXggPSBpc05hTihtYXgpID8gdGhpcy5tYXggOiBtYXg7XG4gICAgaWYgKG1pbiAhPT0gdGhpcy5taW4gfHwgbWF4ICE9PSB0aGlzLm1heCkge1xuICAgICAgdGhpcy5taW4gPSBtaW47XG4gICAgICB0aGlzLm1heCA9IG1heDtcbiAgICAgIHRoaXMuZGlydHlQYXRoID0gdHJ1ZTtcbiAgICAgIHRoaXMubWFya0RpcnR5KDMgLyogTUFKT1IgKi8pO1xuICAgIH1cbiAgfVxuICBjb21wdXRlQkJveCgpIHtcbiAgICBjb25zdCB7IHgsIHksIHdpZHRoOiB3aWR0aDIsIGhlaWdodDogaGVpZ2h0MiB9ID0gdGhpcztcbiAgICByZXR1cm4gbmV3IEJCb3goeCwgeSwgd2lkdGgyLCBoZWlnaHQyKTtcbiAgfVxuICBjb21wdXRlVmlzaWJsZVJhbmdlQkJveCgpIHtcbiAgICBjb25zdCB7IHgsIHksIHdpZHRoOiB3aWR0aDIsIGhlaWdodDogaGVpZ2h0MiwgbWluLCBtYXggfSA9IHRoaXM7XG4gICAgY29uc3QgbWluWCA9IHggKyB3aWR0aDIgKiBtaW47XG4gICAgY29uc3QgbWF4WCA9IHggKyB3aWR0aDIgKiBtYXg7XG4gICAgcmV0dXJuIG5ldyBCQm94KG1pblgsIHksIG1heFggLSBtaW5YLCBoZWlnaHQyKTtcbiAgfVxuICB1cGRhdGVQYXRoKCkge1xuICAgIGNvbnN0IHsgcGF0aCwgeCwgeSwgd2lkdGg6IHdpZHRoMiwgaGVpZ2h0OiBoZWlnaHQyLCBtaW4sIG1heCwgc3Ryb2tlV2lkdGggfSA9IHRoaXM7XG4gICAgY29uc3QgcGl4ZWxBbGlnbiA9IHN0cm9rZVdpZHRoIC8gMjtcbiAgICBwYXRoLmNsZWFyKCk7XG4gICAgY29uc3QgYXggPSB0aGlzLmFsaWduKHgpICsgcGl4ZWxBbGlnbjtcbiAgICBjb25zdCBheSA9IHRoaXMuYWxpZ24oeSkgKyBwaXhlbEFsaWduO1xuICAgIGNvbnN0IGF4dyA9IGF4ICsgdGhpcy5hbGlnbih4LCB3aWR0aDIpIC0gMiAqIHBpeGVsQWxpZ247XG4gICAgY29uc3QgYXloID0gYXkgKyB0aGlzLmFsaWduKHksIGhlaWdodDIpIC0gMiAqIHBpeGVsQWxpZ247XG4gICAgcGF0aC5tb3ZlVG8oYXgsIGF5KTtcbiAgICBwYXRoLmxpbmVUbyhheHcsIGF5KTtcbiAgICBwYXRoLmxpbmVUbyhheHcsIGF5aCk7XG4gICAgcGF0aC5saW5lVG8oYXgsIGF5aCk7XG4gICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgICBjb25zdCBtaW5YID0gdGhpcy5hbGlnbih4ICsgd2lkdGgyICogbWluKSArIHBpeGVsQWxpZ247XG4gICAgY29uc3QgbWF4WCA9IG1pblggKyB0aGlzLmFsaWduKHggKyB3aWR0aDIgKiBtaW4sIHdpZHRoMiAqIChtYXggLSBtaW4pKSAtIDIgKiBwaXhlbEFsaWduO1xuICAgIHBhdGgubW92ZVRvKG1pblgsIGF5KTtcbiAgICBwYXRoLmxpbmVUbyhtaW5YLCBheWgpO1xuICAgIHBhdGgubGluZVRvKG1heFgsIGF5aCk7XG4gICAgcGF0aC5saW5lVG8obWF4WCwgYXkpO1xuICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gIH1cbn07XG5SYW5nZU1hc2suY2xhc3NOYW1lID0gXCJSYW5nZU1hc2tcIjtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbmF2aWdhdG9yL3NoYXBlcy9yYW5nZVNlbGVjdG9yLnRzXG52YXIgUmFuZ2VTZWxlY3RvciA9IGNsYXNzIGV4dGVuZHMgTGF5ZXIge1xuICBjb25zdHJ1Y3RvcihjaGlsZHJlbikge1xuICAgIHN1cGVyKHsgbmFtZTogXCJyYW5nZVNlbGVjdG9yR3JvdXBcIiwgekluZGV4OiAxNiAvKiBOQVZJR0FUT1IgKi8gfSk7XG4gICAgdGhpcy54ID0gMDtcbiAgICB0aGlzLnkgPSAwO1xuICAgIHRoaXMud2lkdGggPSAyMDA7XG4gICAgdGhpcy5oZWlnaHQgPSAzMDtcbiAgICB0aGlzLmxPZmZzZXQgPSAwO1xuICAgIHRoaXMuck9mZnNldCA9IDA7XG4gICAgdGhpcy5iYWNrZ3JvdW5kID0gdGhpcy5hcHBlbmRDaGlsZChuZXcgVHJhbnNsYXRhYmxlR3JvdXAoeyBuYW1lOiBcIm5hdmlnYXRvci1iYWNrZ3JvdW5kXCIsIHpJbmRleDogMSB9KSk7XG4gICAgdGhpcy5hcHBlbmQoY2hpbGRyZW4pO1xuICB9XG4gIGxheW91dCh4LCB5LCB3aWR0aDIsIGhlaWdodDIsIGxPZmZzZXQsIHJPZmZzZXQpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoMjtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDI7XG4gICAgdGhpcy5sT2Zmc2V0ID0gbE9mZnNldDtcbiAgICB0aGlzLnJPZmZzZXQgPSByT2Zmc2V0O1xuICAgIHRoaXMuYmFja2dyb3VuZC50cmFuc2xhdGlvblggPSB4O1xuICAgIHRoaXMuYmFja2dyb3VuZC50cmFuc2xhdGlvblkgPSB5O1xuICAgIHRoaXMubWFya0RpcnR5KDMgLyogTUFKT1IgKi8pO1xuICB9XG4gIHVwZGF0ZUJhY2tncm91bmQob2xkR3JvdXAsIG5ld0dyb3VwKSB7XG4gICAgaWYgKG9sZEdyb3VwICE9IG51bGwpIHtcbiAgICAgIHRoaXMuYmFja2dyb3VuZC5yZW1vdmVDaGlsZChvbGRHcm91cCk7XG4gICAgfVxuICAgIGlmIChuZXdHcm91cCAhPSBudWxsKSB7XG4gICAgICB0aGlzLmJhY2tncm91bmQuYXBwZW5kQ2hpbGQobmV3R3JvdXApO1xuICAgIH1cbiAgICB0aGlzLm1hcmtEaXJ0eSgzIC8qIE1BSk9SICovKTtcbiAgfVxuICBjb21wdXRlQkJveCgpIHtcbiAgICBjb25zdCB7IHgsIHksIHdpZHRoOiB3aWR0aDIsIGhlaWdodDogaGVpZ2h0MiwgbE9mZnNldCwgck9mZnNldCB9ID0gdGhpcztcbiAgICByZXR1cm4gbmV3IEJCb3goeCAtIGxPZmZzZXQsIHksIHdpZHRoMiArIChsT2Zmc2V0ICsgck9mZnNldCksIGhlaWdodDIpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9uYXZpZ2F0b3IvbmF2aWdhdG9yLnRzXG52YXIgTmF2aWdhdG9yID0gY2xhc3MgZXh0ZW5kcyBCYXNlTW9kdWxlSW5zdGFuY2Uge1xuICBjb25zdHJ1Y3RvcihjdHgpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMubWluaUNoYXJ0ID0gdm9pZCAwO1xuICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMubWFzayA9IG5ldyBSYW5nZU1hc2soKTtcbiAgICB0aGlzLm1pbkhhbmRsZSA9IG5ldyBSYW5nZUhhbmRsZSgpO1xuICAgIHRoaXMubWF4SGFuZGxlID0gbmV3IFJhbmdlSGFuZGxlKCk7XG4gICAgdGhpcy5tYXNrVmlzaWJsZVJhbmdlID0ge1xuICAgICAgaWQ6IFwibmF2aWdhdG9yLW1hc2stdmlzaWJsZS1yYW5nZVwiLFxuICAgICAgZ2V0QkJveDogKCkgPT4gdGhpcy5tYXNrLmNvbXB1dGVWaXNpYmxlUmFuZ2VCQm94KCksXG4gICAgICB0b0NhbnZhc0JCb3g6ICgpID0+IHRoaXMubWFzay5jb21wdXRlVmlzaWJsZVJhbmdlQkJveCgpLFxuICAgICAgZnJvbUNhbnZhc1BvaW50OiAoeCwgeSkgPT4gKHsgeCwgeSB9KVxuICAgIH07XG4gICAgdGhpcy5oZWlnaHQgPSAzMDtcbiAgICB0aGlzLnNwYWNpbmcgPSAxMDtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gICAgdGhpcy53aWR0aCA9IDA7XG4gICAgdGhpcy5yYW5nZVNlbGVjdG9yID0gbmV3IFJhbmdlU2VsZWN0b3IoW3RoaXMubWFzaywgdGhpcy5taW5IYW5kbGUsIHRoaXMubWF4SGFuZGxlXSk7XG4gICAgdGhpcy5fbWluID0gMDtcbiAgICB0aGlzLl9tYXggPSAxO1xuICAgIHRoaXMubWluUmFuZ2UgPSAxZS0zO1xuICAgIGNvbnN0IHJlZ2lvbiA9IGN0eC5yZWdpb25NYW5hZ2VyLmFkZFJlZ2lvbihcIm5hdmlnYXRvclwiLCB0aGlzLnJhbmdlU2VsZWN0b3IpO1xuICAgIGNvbnN0IGRyYWdTdGF0ZXMgPSAzMiAvKiBEZWZhdWx0ICovIHwgMiAvKiBBbmltYXRpb24gKi8gfCAxNiAvKiBab29tRHJhZyAqLztcbiAgICB0aGlzLmRlc3Ryb3lGbnMucHVzaChcbiAgICAgIGN0eC5zY2VuZS5hdHRhY2hOb2RlKHRoaXMucmFuZ2VTZWxlY3RvciksXG4gICAgICByZWdpb24uYWRkTGlzdGVuZXIoXCJob3ZlclwiLCAoZXZlbnQpID0+IHRoaXMub25Ib3ZlcihldmVudCksIGRyYWdTdGF0ZXMpLFxuICAgICAgcmVnaW9uLmFkZExpc3RlbmVyKFwiZHJhZy1zdGFydFwiLCAoZXZlbnQpID0+IHRoaXMub25EcmFnU3RhcnQoZXZlbnQpLCBkcmFnU3RhdGVzKSxcbiAgICAgIHJlZ2lvbi5hZGRMaXN0ZW5lcihcImRyYWdcIiwgKGV2ZW50KSA9PiB0aGlzLm9uRHJhZyhldmVudCksIGRyYWdTdGF0ZXMpLFxuICAgICAgcmVnaW9uLmFkZExpc3RlbmVyKFwiZHJhZy1lbmRcIiwgKGV2ZW50KSA9PiB0aGlzLm9uRHJhZ0VuZChldmVudCksIGRyYWdTdGF0ZXMpLFxuICAgICAgcmVnaW9uLmFkZExpc3RlbmVyKFwibGVhdmVcIiwgKGV2ZW50KSA9PiB0aGlzLm9uTGVhdmUoZXZlbnQpLCBkcmFnU3RhdGVzKSxcbiAgICAgIHRoaXMuY3R4LmxvY2FsZU1hbmFnZXIuYWRkTGlzdGVuZXIoXCJsb2NhbGUtY2hhbmdlZFwiLCAoKSA9PiB0aGlzLnVwZGF0ZVpvb20oKSksXG4gICAgICB0aGlzLmN0eC5sYXlvdXRNYW5hZ2VyLnJlZ2lzdGVyRWxlbWVudCgzIC8qIE5hdmlnYXRvciAqLywgKGUpID0+IHRoaXMub25MYXlvdXRTdGFydChlKSksXG4gICAgICB0aGlzLmN0eC5sYXlvdXRNYW5hZ2VyLmFkZExpc3RlbmVyKFwibGF5b3V0OmNvbXBsZXRlXCIsIChlKSA9PiB0aGlzLm9uTGF5b3V0Q29tcGxldGUoZSkpLFxuICAgICAgY3R4Lnpvb21NYW5hZ2VyLmFkZExpc3RlbmVyKFwiem9vbS1jaGFuZ2VcIiwgKGV2ZW50KSA9PiB0aGlzLm9uWm9vbUNoYW5nZShldmVudCkpXG4gICAgKTtcbiAgICB0aGlzLnByb3h5TmF2aWdhdG9yVG9vbGJhciA9IHRoaXMuY3R4LnByb3h5SW50ZXJhY3Rpb25TZXJ2aWNlLmNyZWF0ZVByb3h5Q29udGFpbmVyKHtcbiAgICAgIHR5cGU6IFwidG9vbGJhclwiLFxuICAgICAgaWQ6IGBuYXZpZ2F0b3ItdG9vbGJhcmAsXG4gICAgICBjbGFzc0xpc3Q6IFtcImFnLWNoYXJ0cy1wcm94eS1uYXZpZ2F0b3ItdG9vbGJhclwiXSxcbiAgICAgIGFyaWFPcmllbnRhdGlvbjogXCJ2ZXJ0aWNhbFwiLFxuICAgICAgYXJpYUxhYmVsOiB7IGlkOiBcImFyaWFMYWJlbE5hdmlnYXRvclwiIH1cbiAgICB9KTtcbiAgICB0aGlzLnVwZGF0ZUdyb3VwVmlzaWJpbGl0eSgpO1xuICAgIHRoaXMucHJveHlOYXZpZ2F0b3JFbGVtZW50cyA9IFtcbiAgICAgIHRoaXMuY3R4LnByb3h5SW50ZXJhY3Rpb25TZXJ2aWNlLmNyZWF0ZVByb3h5RWxlbWVudCh7XG4gICAgICAgIHR5cGU6IFwic2xpZGVyXCIsXG4gICAgICAgIGlkOiBcImFnLWNoYXJ0cy1uYXZpZ2F0b3ItbWluXCIsXG4gICAgICAgIGFyaWFMYWJlbDogeyBpZDogXCJhcmlhTGFiZWxOYXZpZ2F0b3JNaW5pbXVtXCIgfSxcbiAgICAgICAgYXJpYU9yaWVudGF0aW9uOiBcImhvcml6b250YWxcIixcbiAgICAgICAgcGFyZW50OiB0aGlzLnByb3h5TmF2aWdhdG9yVG9vbGJhcixcbiAgICAgICAgb25jaGFuZ2U6IChldikgPT4gdGhpcy5vbk1pblNsaWRlckNoYW5nZShldilcbiAgICAgIH0pLFxuICAgICAgdGhpcy5jdHgucHJveHlJbnRlcmFjdGlvblNlcnZpY2UuY3JlYXRlUHJveHlFbGVtZW50KHtcbiAgICAgICAgdHlwZTogXCJzbGlkZXJcIixcbiAgICAgICAgaWQ6IFwiYWctY2hhcnRzLW5hdmlnYXRvci1wYW5cIixcbiAgICAgICAgYXJpYUxhYmVsOiB7IGlkOiBcImFyaWFMYWJlbE5hdmlnYXRvclJhbmdlXCIgfSxcbiAgICAgICAgYXJpYU9yaWVudGF0aW9uOiBcImhvcml6b250YWxcIixcbiAgICAgICAgcGFyZW50OiB0aGlzLnByb3h5TmF2aWdhdG9yVG9vbGJhcixcbiAgICAgICAgb25jaGFuZ2U6IChldikgPT4gdGhpcy5vblBhblNsaWRlckNoYW5nZShldilcbiAgICAgIH0pLFxuICAgICAgdGhpcy5jdHgucHJveHlJbnRlcmFjdGlvblNlcnZpY2UuY3JlYXRlUHJveHlFbGVtZW50KHtcbiAgICAgICAgdHlwZTogXCJzbGlkZXJcIixcbiAgICAgICAgaWQ6IFwiYWctY2hhcnRzLW5hdmlnYXRvci1tYXhcIixcbiAgICAgICAgYXJpYUxhYmVsOiB7IGlkOiBcImFyaWFMYWJlbE5hdmlnYXRvck1heGltdW1cIiB9LFxuICAgICAgICBhcmlhT3JpZW50YXRpb246IFwiaG9yaXpvbnRhbFwiLFxuICAgICAgICBwYXJlbnQ6IHRoaXMucHJveHlOYXZpZ2F0b3JUb29sYmFyLFxuICAgICAgICBvbmNoYW5nZTogKGV2KSA9PiB0aGlzLm9uTWF4U2xpZGVyQ2hhbmdlKGV2KVxuICAgICAgfSlcbiAgICBdO1xuICAgIHRoaXMucHJveHlOYXZpZ2F0b3JFbGVtZW50cy5mb3JFYWNoKChzbGlkZXIpID0+IHNldEF0dHJpYnV0ZShzbGlkZXIsIFwiZGF0YS1wcmV2ZW50ZGVmYXVsdFwiLCBmYWxzZSkpO1xuICAgIHRoaXMuc2V0U2xpZGVyUmF0aW8odGhpcy5wcm94eU5hdmlnYXRvckVsZW1lbnRzWzBdLCB0aGlzLl9taW4pO1xuICAgIHRoaXMuc2V0U2xpZGVyUmF0aW8odGhpcy5wcm94eU5hdmlnYXRvckVsZW1lbnRzWzJdLCB0aGlzLl9tYXgpO1xuICAgIHRoaXMuc2V0UGFuU2xpZGVyVmFsdWUodGhpcy5fbWluLCB0aGlzLl9tYXgpO1xuICAgIGluaXRUb29sYmFyS2V5TmF2KHtcbiAgICAgIG9yaWVudGF0aW9uOiBcInZlcnRpY2FsXCIsXG4gICAgICB0b29sYmFyOiB0aGlzLnByb3h5TmF2aWdhdG9yVG9vbGJhcixcbiAgICAgIGJ1dHRvbnM6IHRoaXMucHJveHlOYXZpZ2F0b3JFbGVtZW50c1xuICAgIH0pO1xuICAgIHRoaXMuZGVzdHJveUZucy5wdXNoKCgpID0+IHtcbiAgICAgIHRoaXMucHJveHlOYXZpZ2F0b3JFbGVtZW50cy5mb3JFYWNoKChlKSA9PiBlLnJlbW92ZSgpKTtcbiAgICAgIHRoaXMucHJveHlOYXZpZ2F0b3JUb29sYmFyLnJlbW92ZSgpO1xuICAgIH0pO1xuICB9XG4gIHVwZGF0ZUJhY2tncm91bmQob2xkR3JvdXAsIG5ld0dyb3VwKSB7XG4gICAgdGhpcy5yYW5nZVNlbGVjdG9yPy51cGRhdGVCYWNrZ3JvdW5kKG9sZEdyb3VwLCBuZXdHcm91cCk7XG4gIH1cbiAgdXBkYXRlR3JvdXBWaXNpYmlsaXR5KCkge1xuICAgIGNvbnN0IHsgZW5hYmxlZCB9ID0gdGhpcztcbiAgICBpZiAodGhpcy5yYW5nZVNlbGVjdG9yID09IG51bGwgfHwgZW5hYmxlZCA9PT0gdGhpcy5yYW5nZVNlbGVjdG9yLnZpc2libGUpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5yYW5nZVNlbGVjdG9yLnZpc2libGUgPSBlbmFibGVkO1xuICAgIHRoaXMucHJveHlOYXZpZ2F0b3JUb29sYmFyLmFyaWFIaWRkZW4gPSAoIWVuYWJsZWQpLnRvU3RyaW5nKCk7XG4gICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgIHRoaXMudXBkYXRlWm9vbSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmN0eC56b29tTWFuYWdlci51cGRhdGVab29tKFwibmF2aWdhdG9yXCIpO1xuICAgIH1cbiAgfVxuICBvbkxheW91dFN0YXJ0KGN0eCkge1xuICAgIGlmICh0aGlzLmVuYWJsZWQpIHtcbiAgICAgIGNvbnN0IHsgbGF5b3V0Qm94IH0gPSBjdHg7XG4gICAgICBjb25zdCBuYXZpZ2F0b3JUb3RhbEhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgdGhpcy5zcGFjaW5nO1xuICAgICAgbGF5b3V0Qm94LnNocmluayhuYXZpZ2F0b3JUb3RhbEhlaWdodCwgXCJib3R0b21cIik7XG4gICAgICB0aGlzLnkgPSBsYXlvdXRCb3gueSArIGxheW91dEJveC5oZWlnaHQgKyB0aGlzLnNwYWNpbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMueSA9IDA7XG4gICAgfVxuICB9XG4gIG9uTGF5b3V0Q29tcGxldGUob3B0cykge1xuICAgIGNvbnN0IHsgeCwgd2lkdGg6IHdpZHRoMiB9ID0gb3B0cy5zZXJpZXMucmVjdDtcbiAgICBpZiAodGhpcy5lbmFibGVkKSB7XG4gICAgICBjb25zdCB7IHksIGhlaWdodDogaGVpZ2h0MiB9ID0gdGhpcztcbiAgICAgIHRoaXMubGF5b3V0Tm9kZXMoeCwgeSwgd2lkdGgyLCBoZWlnaHQyKTtcbiAgICAgIHNldEVsZW1lbnRCQm94KHRoaXMucHJveHlOYXZpZ2F0b3JUb29sYmFyLCB7IHgsIHksIHdpZHRoOiB3aWR0aDIsIGhlaWdodDogaGVpZ2h0MiB9KTtcbiAgICAgIHRoaXMucHJveHlOYXZpZ2F0b3JUb29sYmFyLnN0eWxlLnJlbW92ZVByb3BlcnR5KFwiZGlzcGxheVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wcm94eU5hdmlnYXRvclRvb2xiYXIuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIH1cbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDI7XG4gIH1cbiAgb25Ib3ZlcihldmVudCkge1xuICAgIGlmICghdGhpcy5lbmFibGVkKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMudXBkYXRlQ3Vyc29yKGV2ZW50KTtcbiAgfVxuICB1cGRhdGVDdXJzb3IoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlZClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IG1hc2ssIG1pbkhhbmRsZSwgbWF4SGFuZGxlIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgcmVnaW9uT2Zmc2V0WCwgcmVnaW9uT2Zmc2V0WSB9ID0gZXZlbnQ7XG4gICAgaWYgKG1pbkhhbmRsZS5jb250YWluc1BvaW50KHJlZ2lvbk9mZnNldFgsIHJlZ2lvbk9mZnNldFkpIHx8IG1heEhhbmRsZS5jb250YWluc1BvaW50KHJlZ2lvbk9mZnNldFgsIHJlZ2lvbk9mZnNldFkpKSB7XG4gICAgICB0aGlzLmN0eC5jdXJzb3JNYW5hZ2VyLnVwZGF0ZUN1cnNvcihcIm5hdmlnYXRvclwiLCBcImV3LXJlc2l6ZVwiKTtcbiAgICB9IGVsc2UgaWYgKG1hc2suY29tcHV0ZVZpc2libGVSYW5nZUJCb3goKS5jb250YWluc1BvaW50KHJlZ2lvbk9mZnNldFgsIHJlZ2lvbk9mZnNldFkpKSB7XG4gICAgICB0aGlzLmN0eC5jdXJzb3JNYW5hZ2VyLnVwZGF0ZUN1cnNvcihcIm5hdmlnYXRvclwiLCBcImdyYWJcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3R4LmN1cnNvck1hbmFnZXIudXBkYXRlQ3Vyc29yKFwibmF2aWdhdG9yXCIpO1xuICAgIH1cbiAgfVxuICBvbkRyYWdTdGFydChldmVudCkge1xuICAgIGlmICghdGhpcy5lbmFibGVkKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMudXBkYXRlQ3Vyc29yKGV2ZW50KTtcbiAgICBjb25zdCB7IG1hc2ssIG1pbkhhbmRsZSwgbWF4SGFuZGxlLCB4LCB3aWR0aDogd2lkdGgyLCBfbWluOiBtaW4gfSA9IHRoaXM7XG4gICAgY29uc3QgeyByZWdpb25PZmZzZXRYLCByZWdpb25PZmZzZXRZIH0gPSBldmVudDtcbiAgICBpZiAobWluSGFuZGxlLnpJbmRleCA8IG1heEhhbmRsZS56SW5kZXgpIHtcbiAgICAgIGlmIChtYXhIYW5kbGUuY29udGFpbnNQb2ludChyZWdpb25PZmZzZXRYLCByZWdpb25PZmZzZXRZKSkge1xuICAgICAgICB0aGlzLmRyYWdnaW5nID0gXCJtYXhcIjtcbiAgICAgIH0gZWxzZSBpZiAobWluSGFuZGxlLmNvbnRhaW5zUG9pbnQocmVnaW9uT2Zmc2V0WCwgcmVnaW9uT2Zmc2V0WSkpIHtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IFwibWluXCI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtaW5IYW5kbGUuY29udGFpbnNQb2ludChyZWdpb25PZmZzZXRYLCByZWdpb25PZmZzZXRZKSkge1xuICAgICAgdGhpcy5kcmFnZ2luZyA9IFwibWluXCI7XG4gICAgfSBlbHNlIGlmIChtYXhIYW5kbGUuY29udGFpbnNQb2ludChyZWdpb25PZmZzZXRYLCByZWdpb25PZmZzZXRZKSkge1xuICAgICAgdGhpcy5kcmFnZ2luZyA9IFwibWF4XCI7XG4gICAgfVxuICAgIGlmICh0aGlzLmRyYWdnaW5nID09IG51bGwgJiYgbWFzay5jb21wdXRlVmlzaWJsZVJhbmdlQkJveCgpLmNvbnRhaW5zUG9pbnQocmVnaW9uT2Zmc2V0WCwgcmVnaW9uT2Zmc2V0WSkpIHtcbiAgICAgIHRoaXMuZHJhZ2dpbmcgPSBcInBhblwiO1xuICAgICAgdGhpcy5wYW5TdGFydCA9IChyZWdpb25PZmZzZXRYIC0geCkgLyB3aWR0aDIgLSBtaW47XG4gICAgfVxuICAgIGlmICh0aGlzLmRyYWdnaW5nICE9IG51bGwpIHtcbiAgICAgIHRoaXMuY3R4Lnpvb21NYW5hZ2VyLmZpcmVab29tUGFuU3RhcnRFdmVudChcIm5hdmlnYXRvclwiKTtcbiAgICB9XG4gIH1cbiAgb25EcmFnKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQgfHwgdGhpcy5kcmFnZ2luZyA9PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgZHJhZ2dpbmcsIG1pblJhbmdlLCBwYW5TdGFydCwgeCwgd2lkdGg6IHdpZHRoMiB9ID0gdGhpcztcbiAgICBsZXQgeyBfbWluOiBtaW4sIF9tYXg6IG1heCB9ID0gdGhpcztcbiAgICBjb25zdCB7IHJlZ2lvbk9mZnNldFggfSA9IGV2ZW50O1xuICAgIGNvbnN0IHJhdGlvMiA9IChyZWdpb25PZmZzZXRYIC0geCkgLyB3aWR0aDI7XG4gICAgaWYgKGRyYWdnaW5nID09PSBcIm1pblwiKSB7XG4gICAgICBtaW4gPSBjbGFtcCgwLCByYXRpbzIsIG1heCAtIG1pblJhbmdlKTtcbiAgICB9IGVsc2UgaWYgKGRyYWdnaW5nID09PSBcIm1heFwiKSB7XG4gICAgICBtYXggPSBjbGFtcChtaW4gKyBtaW5SYW5nZSwgcmF0aW8yLCAxKTtcbiAgICB9IGVsc2UgaWYgKGRyYWdnaW5nID09PSBcInBhblwiICYmIHBhblN0YXJ0ICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHNwYW4gPSBtYXggLSBtaW47XG4gICAgICBtaW4gPSBjbGFtcCgwLCByYXRpbzIgLSBwYW5TdGFydCwgMSAtIHNwYW4pO1xuICAgICAgbWF4ID0gbWluICsgc3BhbjtcbiAgICB9XG4gICAgdGhpcy5fbWluID0gbWluO1xuICAgIHRoaXMuX21heCA9IG1heDtcbiAgICB0aGlzLnVwZGF0ZVpvb20oKTtcbiAgfVxuICBvbkRyYWdFbmQoZXZlbnQpIHtcbiAgICB0aGlzLmRyYWdnaW5nID0gdm9pZCAwO1xuICAgIHRoaXMudXBkYXRlQ3Vyc29yKGV2ZW50KTtcbiAgfVxuICBvbkxlYXZlKF9ldmVudCkge1xuICAgIHRoaXMuY3R4LmN1cnNvck1hbmFnZXIudXBkYXRlQ3Vyc29yKFwibmF2aWdhdG9yXCIpO1xuICB9XG4gIG9uWm9vbUNoYW5nZShldmVudCkge1xuICAgIGNvbnN0IHsgeCB9ID0gZXZlbnQ7XG4gICAgaWYgKCF4KVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX21pbiA9IHgubWluO1xuICAgIHRoaXMuX21heCA9IHgubWF4O1xuICAgIHRoaXMudXBkYXRlTm9kZXMoeC5taW4sIHgubWF4KTtcbiAgICB0aGlzLnNldFBhblNsaWRlclZhbHVlKHgubWluLCB4Lm1heCk7XG4gICAgdGhpcy5zZXRTbGlkZXJSYXRpbyh0aGlzLnByb3h5TmF2aWdhdG9yRWxlbWVudHNbMF0sIHgubWluKTtcbiAgICB0aGlzLnNldFNsaWRlclJhdGlvKHRoaXMucHJveHlOYXZpZ2F0b3JFbGVtZW50c1syXSwgeC5tYXgpO1xuICB9XG4gIG9uUGFuU2xpZGVyQ2hhbmdlKF9ldmVudCkge1xuICAgIGNvbnN0IHJhdGlvMiA9IHRoaXMuZ2V0U2xpZGVyUmF0aW8odGhpcy5wcm94eU5hdmlnYXRvckVsZW1lbnRzWzFdKTtcbiAgICBjb25zdCBzcGFuID0gdGhpcy5fbWF4IC0gdGhpcy5fbWluO1xuICAgIHRoaXMuX21pbiA9IGNsYW1wKDAsIHJhdGlvMiwgMSAtIHNwYW4pO1xuICAgIHRoaXMuX21heCA9IHRoaXMuX21pbiArIHNwYW47XG4gICAgdGhpcy51cGRhdGVab29tKCk7XG4gIH1cbiAgb25NaW5TbGlkZXJDaGFuZ2UoX2V2ZW50KSB7XG4gICAgY29uc3Qgc2xpZGVyID0gdGhpcy5wcm94eU5hdmlnYXRvckVsZW1lbnRzWzBdO1xuICAgIHRoaXMuX21pbiA9IHRoaXMuc2V0U2xpZGVyUmF0aW9DbGFtcGVkKHNsaWRlciwgMCwgdGhpcy5fbWF4IC0gdGhpcy5taW5SYW5nZSk7XG4gICAgdGhpcy51cGRhdGVab29tKCk7XG4gIH1cbiAgb25NYXhTbGlkZXJDaGFuZ2UoX2V2ZW50KSB7XG4gICAgY29uc3Qgc2xpZGVyID0gdGhpcy5wcm94eU5hdmlnYXRvckVsZW1lbnRzWzJdO1xuICAgIHRoaXMuX21heCA9IHRoaXMuc2V0U2xpZGVyUmF0aW9DbGFtcGVkKHNsaWRlciwgdGhpcy5fbWluICsgdGhpcy5taW5SYW5nZSwgMSk7XG4gICAgdGhpcy51cGRhdGVab29tKCk7XG4gIH1cbiAgc2V0UGFuU2xpZGVyVmFsdWUobWluLCBtYXgpIHtcbiAgICB0aGlzLnByb3h5TmF2aWdhdG9yRWxlbWVudHNbMV0udmFsdWUgPSBgJHtNYXRoLnJvdW5kKG1pbiAqIDEwMCl9YDtcbiAgICB0aGlzLnByb3h5TmF2aWdhdG9yRWxlbWVudHNbMV0uYXJpYVZhbHVlVGV4dCA9IHRoaXMuY3R4LmxvY2FsZU1hbmFnZXIudChcImFyaWFWYWx1ZVBhblJhbmdlXCIsIHsgbWluLCBtYXggfSk7XG4gIH1cbiAgc2V0U2xpZGVyUmF0aW9DbGFtcGVkKHNsaWRlciwgY2xhbXBNaW4sIGNsYW1wTWF4KSB7XG4gICAgY29uc3QgcmF0aW8yID0gdGhpcy5nZXRTbGlkZXJSYXRpbyhzbGlkZXIpO1xuICAgIGNvbnN0IGNsYW1wZWRSYXRpbyA9IGNsYW1wKGNsYW1wTWluLCByYXRpbzIsIGNsYW1wTWF4KTtcbiAgICBpZiAoY2xhbXBlZFJhdGlvICE9PSByYXRpbzIpIHtcbiAgICAgIHRoaXMuc2V0U2xpZGVyUmF0aW8oc2xpZGVyLCBjbGFtcGVkUmF0aW8pO1xuICAgIH1cbiAgICByZXR1cm4gY2xhbXBlZFJhdGlvO1xuICB9XG4gIHNldFNsaWRlclJhdGlvKHNsaWRlciwgcmF0aW8yKSB7XG4gICAgY29uc3QgdmFsdWUgPSBNYXRoLnJvdW5kKHJhdGlvMiAqIDEwMCk7XG4gICAgc2xpZGVyLnZhbHVlID0gYCR7dmFsdWV9YDtcbiAgICBzbGlkZXIuYXJpYVZhbHVlVGV4dCA9IGZvcm1hdFBlcmNlbnRhZ2UodmFsdWUpO1xuICB9XG4gIGdldFNsaWRlclJhdGlvKHNsaWRlcikge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHNsaWRlci52YWx1ZSkgLyAxMDA7XG4gIH1cbiAgbGF5b3V0Tm9kZXMoeCwgeSwgd2lkdGgyLCBoZWlnaHQyKSB7XG4gICAgY29uc3QgeyByYW5nZVNlbGVjdG9yLCBtYXNrLCBtaW5IYW5kbGUsIG1heEhhbmRsZSwgX21pbjogbWluLCBfbWF4OiBtYXggfSA9IHRoaXM7XG4gICAgcmFuZ2VTZWxlY3Rvci5sYXlvdXQoeCwgeSwgd2lkdGgyLCBoZWlnaHQyLCBtaW5IYW5kbGUud2lkdGggLyAyLCBtYXhIYW5kbGUud2lkdGggLyAyKTtcbiAgICBtYXNrLmxheW91dCh4LCB5LCB3aWR0aDIsIGhlaWdodDIpO1xuICAgIFJhbmdlSGFuZGxlLmFsaWduKG1pbkhhbmRsZSwgbWF4SGFuZGxlLCB4LCB5LCB3aWR0aDIsIGhlaWdodDIsIG1pbiwgbWF4KTtcbiAgICBpZiAobWluICsgKG1heCAtIG1pbikgLyAyIDwgMC41KSB7XG4gICAgICBtaW5IYW5kbGUuekluZGV4ID0gMztcbiAgICAgIG1heEhhbmRsZS56SW5kZXggPSA0O1xuICAgIH0gZWxzZSB7XG4gICAgICBtaW5IYW5kbGUuekluZGV4ID0gNDtcbiAgICAgIG1heEhhbmRsZS56SW5kZXggPSAzO1xuICAgIH1cbiAgICBbbWluSGFuZGxlLCB0aGlzLm1hc2tWaXNpYmxlUmFuZ2UsIG1heEhhbmRsZV0uZm9yRWFjaCgobm9kZSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGJib3ggPSBub2RlLmdldEJCb3goKTtcbiAgICAgIGNvbnN0IHRib3ggPSB7IHg6IGJib3gueCAtIHgsIHk6IGJib3gueSAtIHksIGhlaWdodDogYmJveC5oZWlnaHQsIHdpZHRoOiBiYm94LndpZHRoIH07XG4gICAgICBzZXRFbGVtZW50QkJveCh0aGlzLnByb3h5TmF2aWdhdG9yRWxlbWVudHNbaW5kZXhdLCB0Ym94KTtcbiAgICB9KTtcbiAgfVxuICB1cGRhdGVOb2RlcyhtaW4sIG1heCkge1xuICAgIHRoaXMubWFzay51cGRhdGUobWluLCBtYXgpO1xuICB9XG4gIHVwZGF0ZVpvb20oKSB7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBfbWluOiBtaW4sIF9tYXg6IG1heCB9ID0gdGhpcztcbiAgICBpZiAobWluID09IG51bGwgfHwgbWF4ID09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgY29uc3Qgd2Fybk9uQ29uZmxpY3QgPSAoc3RhdGVJZCkgPT4ge1xuICAgICAgaWYgKHRoaXMubWluID09IG51bGwgJiYgdGhpcy5tYXggPT0gbnVsbClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgTG9nZ2VyLndhcm5PbmNlKFxuICAgICAgICBgQ291bGQgbm90IGFwcGx5IFtuYXZpZ2F0b3IubWluXSBvciBbbmF2aWdhdG9yLm1heF0gYXMgWyR7c3RhdGVJZH1dIGhhcyBtb2RpZmllZCB0aGUgaW5pdGlhbCB6b29tIHN0YXRlLmBcbiAgICAgICk7XG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5jdHguem9vbU1hbmFnZXIudXBkYXRlWm9vbShcIm5hdmlnYXRvclwiLCB7IHg6IHsgbWluLCBtYXggfSB9LCBmYWxzZSwgd2Fybk9uQ29uZmxpY3QpO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNULCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBOYXZpZ2F0b3IucHJvdG90eXBlLCBcIm1pbmlDaGFydFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pLFxuICBPYnNlcnZlQ2hhbmdlcygodGFyZ2V0KSA9PiB0YXJnZXQudXBkYXRlR3JvdXBWaXNpYmlsaXR5KCkpXG5dLCBOYXZpZ2F0b3IucHJvdG90eXBlLCBcImVuYWJsZWRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBOYXZpZ2F0b3IucHJvdG90eXBlLCBcImhlaWdodFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIE5hdmlnYXRvci5wcm90b3R5cGUsIFwic3BhY2luZ1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEFjdGlvbk9uU2V0KHtcbiAgICBuZXdWYWx1ZShtaW4pIHtcbiAgICAgIHRoaXMuX21pbiA9IG1pbjtcbiAgICAgIHRoaXMudXBkYXRlWm9vbSgpO1xuICAgIH1cbiAgfSksXG4gIFZhbGlkYXRlKEFORChSQVRJTywgTEVTU19USEFOKFwibWF4XCIpKSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTmF2aWdhdG9yLnByb3RvdHlwZSwgXCJtaW5cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBBY3Rpb25PblNldCh7XG4gICAgbmV3VmFsdWUobWF4KSB7XG4gICAgICB0aGlzLl9tYXggPSBtYXg7XG4gICAgICB0aGlzLnVwZGF0ZVpvb20oKTtcbiAgICB9XG4gIH0pLFxuICBWYWxpZGF0ZShBTkQoUkFUSU8sIEdSRUFURVJfVEhBTihcIm1pblwiKSksIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIE5hdmlnYXRvci5wcm90b3R5cGUsIFwibWF4XCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9uYXZpZ2F0b3IvbmF2aWdhdG9yTW9kdWxlLnRzXG52YXIgTmF2aWdhdG9yTW9kdWxlID0ge1xuICB0eXBlOiBcInJvb3RcIixcbiAgb3B0aW9uc0tleTogXCJuYXZpZ2F0b3JcIixcbiAgcGFja2FnZVR5cGU6IFwiY29tbXVuaXR5XCIsXG4gIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiXSxcbiAgbW9kdWxlRmFjdG9yeTogKGN0eCkgPT4gbmV3IE5hdmlnYXRvcihjdHgpLFxuICB0aGVtZVRlbXBsYXRlOiB7XG4gICAgbmF2aWdhdG9yOiB7XG4gICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgIGhlaWdodDogMzAsXG4gICAgICBtYXNrOiB7XG4gICAgICAgIGZpbGw6IFwiIzk5OTk5OVwiLFxuICAgICAgICBzdHJva2U6IFwiIzk5OTk5OVwiLFxuICAgICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgICAgZmlsbE9wYWNpdHk6IDAuMlxuICAgICAgfSxcbiAgICAgIG1pbkhhbmRsZToge1xuICAgICAgICBmaWxsOiBcIiNmMmYyZjJcIixcbiAgICAgICAgc3Ryb2tlOiBcIiM5OTk5OTlcIixcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDEsXG4gICAgICAgIHdpZHRoOiA5LFxuICAgICAgICBoZWlnaHQ6IDE2LFxuICAgICAgICBncmlwTGluZUdhcDogMSxcbiAgICAgICAgZ3JpcExpbmVMZW5ndGg6IDhcbiAgICAgIH0sXG4gICAgICBtYXhIYW5kbGU6IHtcbiAgICAgICAgZmlsbDogXCIjZjJmMmYyXCIsXG4gICAgICAgIHN0cm9rZTogXCIjOTk5OTk5XCIsXG4gICAgICAgIHN0cm9rZVdpZHRoOiAxLFxuICAgICAgICB3aWR0aDogOSxcbiAgICAgICAgaGVpZ2h0OiAxNixcbiAgICAgICAgZ3JpcExpbmVHYXA6IDEsXG4gICAgICAgIGdyaXBMaW5lTGVuZ3RoOiA4XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9tb2R1bGUvdGhlbWUudHNcbmZ1bmN0aW9uIHNpbmdsZVNlcmllc1BhbGV0dGVGYWN0b3J5KHsgdGFrZUNvbG9ycyB9KSB7XG4gIGNvbnN0IHtcbiAgICBmaWxsczogW2ZpbGxdLFxuICAgIHN0cm9rZXM6IFtzdHJva2VdXG4gIH0gPSB0YWtlQ29sb3JzKDEpO1xuICByZXR1cm4geyBmaWxsLCBzdHJva2UgfTtcbn1cbmZ1bmN0aW9uIG1hcmtlclBhbGV0dGVGYWN0b3J5KHBhcmFtcykge1xuICByZXR1cm4geyBtYXJrZXI6IHNpbmdsZVNlcmllc1BhbGV0dGVGYWN0b3J5KHBhcmFtcykgfTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvdGhlbWVzL2NvbnN0YW50cy50c1xudmFyIEZPTlRfU0laRSA9IC8qIEBfX1BVUkVfXyAqLyAoKEZPTlRfU0laRTIpID0+IHtcbiAgRk9OVF9TSVpFMltGT05UX1NJWkUyW1wiU01BTExcIl0gPSAxMl0gPSBcIlNNQUxMXCI7XG4gIEZPTlRfU0laRTJbRk9OVF9TSVpFMltcIk1FRElVTVwiXSA9IDEzXSA9IFwiTUVESVVNXCI7XG4gIEZPTlRfU0laRTJbRk9OVF9TSVpFMltcIkxBUkdFXCJdID0gMTddID0gXCJMQVJHRVwiO1xuICByZXR1cm4gRk9OVF9TSVpFMjtcbn0pKEZPTlRfU0laRSB8fCB7fSk7XG52YXIgRk9OVF9XRUlHSFQyID0gLyogQF9fUFVSRV9fICovICgoRk9OVF9XRUlHSFQzKSA9PiB7XG4gIEZPTlRfV0VJR0hUM1tcIk5PUk1BTFwiXSA9IFwibm9ybWFsXCI7XG4gIEZPTlRfV0VJR0hUM1tcIkJPTERcIl0gPSBcImJvbGRcIjtcbiAgRk9OVF9XRUlHSFQzW1wiQk9MREVSXCJdID0gXCJib2xkZXJcIjtcbiAgRk9OVF9XRUlHSFQzW1wiTElHSFRFUlwiXSA9IFwibGlnaHRlclwiO1xuICByZXR1cm4gRk9OVF9XRUlHSFQzO1xufSkoRk9OVF9XRUlHSFQyIHx8IHt9KTtcbnZhciBDQVJURVNJQU5fUE9TSVRJT04gPSAvKiBAX19QVVJFX18gKi8gKChDQVJURVNJQU5fUE9TSVRJT04yKSA9PiB7XG4gIENBUlRFU0lBTl9QT1NJVElPTjJbXCJUT1BcIl0gPSBcInRvcFwiO1xuICBDQVJURVNJQU5fUE9TSVRJT04yW1wiUklHSFRcIl0gPSBcInJpZ2h0XCI7XG4gIENBUlRFU0lBTl9QT1NJVElPTjJbXCJCT1RUT01cIl0gPSBcImJvdHRvbVwiO1xuICBDQVJURVNJQU5fUE9TSVRJT04yW1wiTEVGVFwiXSA9IFwibGVmdFwiO1xuICByZXR1cm4gQ0FSVEVTSUFOX1BPU0lUSU9OMjtcbn0pKENBUlRFU0lBTl9QT1NJVElPTiB8fCB7fSk7XG52YXIgQ0FSVEVTSUFOX0FYSVNfVFlQRSA9IC8qIEBfX1BVUkVfXyAqLyAoKENBUlRFU0lBTl9BWElTX1RZUEUyKSA9PiB7XG4gIENBUlRFU0lBTl9BWElTX1RZUEUyW1wiQ0FURUdPUllcIl0gPSBcImNhdGVnb3J5XCI7XG4gIENBUlRFU0lBTl9BWElTX1RZUEUyW1wiT1JESU5BTF9USU1FXCJdID0gXCJvcmRpbmFsLXRpbWVcIjtcbiAgQ0FSVEVTSUFOX0FYSVNfVFlQRTJbXCJOVU1CRVJcIl0gPSBcIm51bWJlclwiO1xuICBDQVJURVNJQU5fQVhJU19UWVBFMltcIlRJTUVcIl0gPSBcInRpbWVcIjtcbiAgQ0FSVEVTSUFOX0FYSVNfVFlQRTJbXCJMT0dcIl0gPSBcImxvZ1wiO1xuICByZXR1cm4gQ0FSVEVTSUFOX0FYSVNfVFlQRTI7XG59KShDQVJURVNJQU5fQVhJU19UWVBFIHx8IHt9KTtcbnZhciBQT0xBUl9BWElTX1RZUEUgPSAvKiBAX19QVVJFX18gKi8gKChQT0xBUl9BWElTX1RZUEUyKSA9PiB7XG4gIFBPTEFSX0FYSVNfVFlQRTJbXCJBTkdMRV9DQVRFR09SWVwiXSA9IFwiYW5nbGUtY2F0ZWdvcnlcIjtcbiAgUE9MQVJfQVhJU19UWVBFMltcIkFOR0xFX05VTUJFUlwiXSA9IFwiYW5nbGUtbnVtYmVyXCI7XG4gIFBPTEFSX0FYSVNfVFlQRTJbXCJSQURJVVNfQ0FURUdPUllcIl0gPSBcInJhZGl1cy1jYXRlZ29yeVwiO1xuICBQT0xBUl9BWElTX1RZUEUyW1wiUkFESVVTX05VTUJFUlwiXSA9IFwicmFkaXVzLW51bWJlclwiO1xuICByZXR1cm4gUE9MQVJfQVhJU19UWVBFMjtcbn0pKFBPTEFSX0FYSVNfVFlQRSB8fCB7fSk7XG52YXIgUE9MQVJfQVhJU19TSEFQRSA9IC8qIEBfX1BVUkVfXyAqLyAoKFBPTEFSX0FYSVNfU0hBUEUyKSA9PiB7XG4gIFBPTEFSX0FYSVNfU0hBUEUyW1wiQ0lSQ0xFXCJdID0gXCJjaXJjbGVcIjtcbiAgUE9MQVJfQVhJU19TSEFQRTJbXCJQT0xZR09OXCJdID0gXCJwb2x5Z29uXCI7XG4gIHJldHVybiBQT0xBUl9BWElTX1NIQVBFMjtcbn0pKFBPTEFSX0FYSVNfU0hBUEUgfHwge30pO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC90aGVtZXMvc3ltYm9scy50c1xudmFyIElTX0RBUktfVEhFTUUgPSBTeW1ib2woXCJpcy1kYXJrLXRoZW1lXCIpO1xudmFyIElTX0NPTU1VTklUWSA9IFN5bWJvbChcImlzLWNvbW11bml0eVwiKTtcbnZhciBJU19FTlRFUlBSSVNFID0gU3ltYm9sKFwiaXMtZW50ZXJwcmlzZVwiKTtcbnZhciBERUZBVUxUX0ZPTlRfRkFNSUxZID0gU3ltYm9sKFwiZGVmYXVsdC1mb250XCIpO1xudmFyIERFRkFVTFRfTEFCRUxfQ09MT1VSID0gU3ltYm9sKFwiZGVmYXVsdC1sYWJlbC1jb2xvdXJcIik7XG52YXIgREVGQVVMVF9JTlZFUlRFRF9MQUJFTF9DT0xPVVIgPSBTeW1ib2woXCJkZWZhdWx0LWludmVydGVkLWxhYmVsLWNvbG91clwiKTtcbnZhciBERUZBVUxUX0lOU0lERV9TRVJJRVNfTEFCRUxfQ09MT1VSID0gU3ltYm9sKFwiZGVmYXVsdC1pbnNpZGUtc2VyaWVzLWxhYmVsLWNvbG91clwiKTtcbnZhciBERUZBVUxUX01VVEVEX0xBQkVMX0NPTE9VUiA9IFN5bWJvbChcImRlZmF1bHQtbXV0ZWQtbGFiZWwtY29sb3VyXCIpO1xudmFyIERFRkFVTFRfQVhJU19HUklEX0NPTE9VUiA9IFN5bWJvbChcImRlZmF1bHQtYXhpcy1ncmlkLWNvbG91clwiKTtcbnZhciBERUZBVUxUX0FYSVNfTElORV9DT0xPVVIgPSBTeW1ib2woXCJkZWZhdWx0LWF4aXMtbGluZS1jb2xvdXJcIik7XG52YXIgREVGQVVMVF9DUk9TU19MSU5FU19DT0xPVVIgPSBTeW1ib2woXCJkZWZhdWx0LWNyb3NzLWxpbmVzLWNvbG91clwiKTtcbnZhciBERUZBVUxUX0JBQ0tHUk9VTkRfQ09MT1VSID0gU3ltYm9sKFwiZGVmYXVsdC1iYWNrZ3JvdW5kLWNvbG91clwiKTtcbnZhciBERUZBVUxUX1NIQURPV19DT0xPVVIgPSBTeW1ib2woXCJkZWZhdWx0LXNoYWRvdy1jb2xvdXJcIik7XG52YXIgREVGQVVMVF9DT0xPVVJTID0gU3ltYm9sKFwiZGVmYXVsdC1jb2xvdXJzXCIpO1xudmFyIERFRkFVTFRfUEFERElORyA9IFN5bWJvbChcImRlZmF1bHQtcGFkZGluZ1wiKTtcbnZhciBERUZBVUxUX0NBUFRJT05fTEFZT1VUX1NUWUxFID0gU3ltYm9sKFwiZGVmYXVsdC1jYXB0aW9uLWxheW91dC1zdHlsZVwiKTtcbnZhciBERUZBVUxUX0NBUFRJT05fQUxJR05NRU5UID0gU3ltYm9sKFwiZGVmYXVsdC1jYXB0aW9uLWFsaWdubWVudFwiKTtcbnZhciBQQUxFVFRFX1VQX1NUUk9LRSA9IFN5bWJvbChcInBhbGV0dGUtdXAtc3Ryb2tlXCIpO1xudmFyIFBBTEVUVEVfRE9XTl9TVFJPS0UgPSBTeW1ib2woXCJwYWxldHRlLWRvd24tc3Ryb2tlXCIpO1xudmFyIFBBTEVUVEVfVVBfRklMTCA9IFN5bWJvbChcInBhbGV0dGUtdXAtZmlsbFwiKTtcbnZhciBQQUxFVFRFX0RPV05fRklMTCA9IFN5bWJvbChcInBhbGV0dGUtZG93bi1maWxsXCIpO1xudmFyIFBBTEVUVEVfTkVVVFJBTF9TVFJPS0UgPSBTeW1ib2woXCJwYWxldHRlLW5ldXRyYWwtc3Ryb2tlXCIpO1xudmFyIFBBTEVUVEVfTkVVVFJBTF9GSUxMID0gU3ltYm9sKFwicGFsZXR0ZS1uZXV0cmFsLWZpbGxcIik7XG52YXIgUEFMRVRURV9BTFRfVVBfU1RST0tFID0gU3ltYm9sKFwicGFsZXR0ZS1hbHQtdXAtc3Ryb2tlXCIpO1xudmFyIFBBTEVUVEVfQUxUX0RPV05fU1RST0tFID0gU3ltYm9sKFwicGFsZXR0ZS1hbHQtZG93bi1zdHJva2VcIik7XG52YXIgUEFMRVRURV9BTFRfVVBfRklMTCA9IFN5bWJvbChcInBhbGV0dGUtYWx0LXVwLWZpbGxcIik7XG52YXIgUEFMRVRURV9BTFRfRE9XTl9GSUxMID0gU3ltYm9sKFwicGFsZXR0ZS1hbHQtZG93bi1maWxsXCIpO1xudmFyIFBBTEVUVEVfQUxUX05FVVRSQUxfRklMTCA9IFN5bWJvbChcInBhbGV0dGUtZ3JheS1maWxsXCIpO1xudmFyIFBBTEVUVEVfQUxUX05FVVRSQUxfU1RST0tFID0gU3ltYm9sKFwicGFsZXR0ZS1ncmF5LXN0cm9rZVwiKTtcbnZhciBERUZBVUxUX1BPTEFSX1NFUklFU19TVFJPS0UgPSBTeW1ib2woXCJkZWZhdWx0LXBvbGFyLXNlcmllcy1zdHJva2VcIik7XG52YXIgREVGQVVMVF9ESVZFUkdJTkdfU0VSSUVTX0NPTE9SX1JBTkdFID0gU3ltYm9sKFxuICBcImRlZmF1bHQtZGl2ZXJnaW5nLXNlcmllcy1jb2xvdXItcmFuZ2VcIlxuKTtcbnZhciBERUZBVUxUX0dBVUdFX1NFUklFU19DT0xPUl9SQU5HRSA9IFN5bWJvbChcImRlZmF1bHQtZ2F1Z2Utc2VyaWVzLWNvbG91ci1yYW5nZVwiKTtcbnZhciBERUZBVUxUX0ZVTk5FTF9TRVJJRVNfQ09MT1JfUkFOR0UgPSBTeW1ib2woXCJkZWZhdWx0LWZ1bm5lbC1zZXJpZXMtY29sb3VyLXJhbmdlXCIpO1xudmFyIERFRkFVTFRfSElFUkFSQ0hZX0ZJTExTID0gU3ltYm9sKFwiZGVmYXVsdC1oaWVyYXJjaHktZmlsbHNcIik7XG52YXIgREVGQVVMVF9ISUVSQVJDSFlfU1RST0tFUyA9IFN5bWJvbChcImRlZmF1bHQtaGllcmFyY2h5LXN0cm9rZXNcIik7XG52YXIgREVGQVVMVF9BTk5PVEFUSU9OX0NPTE9SID0gU3ltYm9sKFwiZGVmYXVsdC1hbm5vdGF0aW9uLXN0cm9rZVwiKTtcbnZhciBERUZBVUxUX1RFWFRfQU5OT1RBVElPTl9DT0xPUiA9IFN5bWJvbChcImRlZmF1bHQtdGV4dC1hbm5vdGF0aW9uLWNvbG9yXCIpO1xudmFyIERFRkFVTFRfQU5OT1RBVElPTl9CQUNLR1JPVU5EX0ZJTEwgPSBTeW1ib2woXCJkZWZhdWx0LWFubm90YXRpb24tYmFja2dyb3VuZC1maWxsXCIpO1xudmFyIERFRkFVTFRfQU5OT1RBVElPTl9IQU5ETEVfRklMTCA9IFN5bWJvbChcImRlZmF1bHQtYW5ub3RhdGlvbi1oYW5kbGUtZmlsbFwiKTtcbnZhciBERUZBVUxUX0FOTk9UQVRJT05fU1RBVElTVElDU19GSUxMID0gU3ltYm9sKFwiZGVmYXVsdC1hbm5vdGF0aW9uLXN0YXRpc3RpY3MtZmlsbFwiKTtcbnZhciBERUZBVUxUX0FOTk9UQVRJT05fU1RBVElTVElDU19TVFJPS0UgPSBTeW1ib2woXCJkZWZhdWx0LWFubm90YXRpb24tc3RhdGlzdGljcy1zdHJva2VcIik7XG52YXIgREVGQVVMVF9BTk5PVEFUSU9OX1NUQVRJU1RJQ1NfQ09MT1IgPSBTeW1ib2woXCJkZWZhdWx0LWFubm90YXRpb24tc3RhdGlzdGljcy1jb2xvclwiKTtcbnZhciBERUZBVUxUX0FOTk9UQVRJT05fU1RBVElTVElDU19ESVZJREVSX1NUUk9LRSA9IFN5bWJvbChcbiAgXCJkZWZhdWx0LWFubm90YXRpb24tc3RhdGlzdGljcy1kaXZpZGVyLXN0cm9rZVwiXG4pO1xudmFyIERFRkFVTFRfQU5OT1RBVElPTl9TVEFUSVNUSUNTX0RPV05fRklMTCA9IFN5bWJvbChcbiAgXCJkZWZhdWx0LWFubm90YXRpb24tc3RhdGlzdGljcy1maWxsXCJcbik7XG52YXIgREVGQVVMVF9BTk5PVEFUSU9OX1NUQVRJU1RJQ1NfRE9XTl9TVFJPS0UgPSBTeW1ib2woXG4gIFwiZGVmYXVsdC1hbm5vdGF0aW9uLXN0YXRpc3RpY3Mtc3Ryb2tlXCJcbik7XG52YXIgREVGQVVMVF9URVhUQk9YX0ZJTEwgPSBTeW1ib2woXCJkZWZhdWx0LXRleHRib3gtZmlsbFwiKTtcbnZhciBERUZBVUxUX1RFWFRCT1hfU1RST0tFID0gU3ltYm9sKFwiZGVmYXVsdC10ZXh0Ym94LXN0cm9rZVwiKTtcbnZhciBERUZBVUxUX1RFWFRCT1hfQ09MT1IgPSBTeW1ib2woXCJkZWZhdWx0LXRleHRib3gtY29sb3JcIik7XG52YXIgREVGQVVMVF9UT09MQkFSX1BPU0lUSU9OID0gU3ltYm9sKFwiZGVmYXVsdC10b29sYmFyLXBvc2l0aW9uXCIpO1xudmFyIERFRkFVTFRfR1JJRExJTkVfRU5BQkxFRCA9IFN5bWJvbChcImRlZmF1bHQtZ3JpZGxpbmUtZW5hYmxlZFwiKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvbW90aW9uL3BhdGhNb3Rpb24udHNcbmZ1bmN0aW9uIHBhdGhNb3Rpb24oZ3JvdXBJZCwgc3ViSWQsIGFuaW1hdGlvbk1hbmFnZXIsIHBhdGhzLCBmbnMpIHtcbiAgY29uc3QgeyBhZGRQaGFzZUZuLCB1cGRhdGVQaGFzZUZuLCByZW1vdmVQaGFzZUZuIH0gPSBmbnM7XG4gIGNvbnN0IGFuaW1hdGUgPSAocGhhc2UsIHBhdGgsIHVwZGF0ZUZuKSA9PiB7XG4gICAgYW5pbWF0aW9uTWFuYWdlci5hbmltYXRlKHtcbiAgICAgIGlkOiBgJHtncm91cElkfV8ke3N1YklkfV8ke3BhdGguaWR9XyR7cGhhc2V9YCxcbiAgICAgIGdyb3VwSWQsXG4gICAgICBmcm9tOiAwLFxuICAgICAgdG86IDEsXG4gICAgICBlYXNlOiBlYXNlT3V0LFxuICAgICAgY29sbGFwc2FibGU6IGZhbHNlLFxuICAgICAgb25VcGRhdGUocmF0aW8yLCBwcmVJbml0KSB7XG4gICAgICAgIGlmIChwcmVJbml0ICYmIHBoYXNlICE9PSBcInJlbW92ZWRcIilcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHBhdGgucGF0aC5jbGVhcih0cnVlKTtcbiAgICAgICAgdXBkYXRlRm4ocmF0aW8yLCBwYXRoKTtcbiAgICAgICAgcGF0aC5jaGVja1BhdGhEaXJ0eSgpO1xuICAgICAgfSxcbiAgICAgIG9uU3RvcCgpIHtcbiAgICAgICAgaWYgKHBoYXNlICE9PSBcImFkZGVkXCIpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBwYXRoLnBhdGguY2xlYXIodHJ1ZSk7XG4gICAgICAgIHVwZGF0ZUZuKDEsIHBhdGgpO1xuICAgICAgICBwYXRoLmNoZWNrUGF0aERpcnR5KCk7XG4gICAgICB9LFxuICAgICAgcGhhc2U6IE5PREVfVVBEQVRFX1NUQVRFX1RPX1BIQVNFX01BUFBJTkdbcGhhc2VdXG4gICAgfSk7XG4gIH07XG4gIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgIGlmICghYW5pbWF0aW9uTWFuYWdlci5pc1NraXBwZWQoKSkge1xuICAgICAgYW5pbWF0ZShcInJlbW92ZWRcIiwgcGF0aCwgcmVtb3ZlUGhhc2VGbik7XG4gICAgICBhbmltYXRlKFwidXBkYXRlZFwiLCBwYXRoLCB1cGRhdGVQaGFzZUZuKTtcbiAgICB9XG4gICAgYW5pbWF0ZShcImFkZGVkXCIsIHBhdGgsIGFkZFBoYXNlRm4pO1xuICB9XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvZm9ybWF0LnV0aWwudHNcbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gdmFsdWUudG9GaXhlZCgyKTtcbiAgfVxuICByZXR1cm4gU3RyaW5nKHZhbHVlID8/IFwiXCIpO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3Nhbml0aXplLnRzXG52YXIgZWxlbWVudCA9IG51bGw7XG5mdW5jdGlvbiBzYW5pdGl6ZUh0bWwodGV4dCkge1xuICBpZiAodGV4dCA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKHRleHQgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICBlbGVtZW50ID8/IChlbGVtZW50ID0gY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gIGVsZW1lbnQudGV4dENvbnRlbnQgPSBTdHJpbmcodGV4dCk7XG4gIHJldHVybiBlbGVtZW50LmlubmVySFRNTDtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9tZW1vLnRzXG52YXIgbWVtb3JpemVkRm5zID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBtZW1vKHBhcmFtcywgZm5HZW5lcmF0b3IpIHtcbiAgY29uc3Qgc2VyaWFsaXNlZFBhcmFtcyA9IEpTT04uc3RyaW5naWZ5KHBhcmFtcywgbnVsbCwgMCk7XG4gIGlmICghbWVtb3JpemVkRm5zLmhhcyhmbkdlbmVyYXRvcikpIHtcbiAgICBtZW1vcml6ZWRGbnMuc2V0KGZuR2VuZXJhdG9yLCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgfVxuICBpZiAoIW1lbW9yaXplZEZucy5nZXQoZm5HZW5lcmF0b3IpPy5oYXMoc2VyaWFsaXNlZFBhcmFtcykpIHtcbiAgICBtZW1vcml6ZWRGbnMuZ2V0KGZuR2VuZXJhdG9yKT8uc2V0KHNlcmlhbGlzZWRQYXJhbXMsIGZuR2VuZXJhdG9yKHBhcmFtcykpO1xuICB9XG4gIHJldHVybiBtZW1vcml6ZWRGbnMuZ2V0KGZuR2VuZXJhdG9yKT8uZ2V0KHNlcmlhbGlzZWRQYXJhbXMpO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9kYXRhL2FnZ3JlZ2F0ZUZ1bmN0aW9ucy50c1xuZnVuY3Rpb24gc3VtVmFsdWVzKHZhbHVlcywgYWNjdW11bGF0b3IgPSBbMCwgMF0pIHtcbiAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlIDwgMCkge1xuICAgICAgYWNjdW11bGF0b3JbMF0gKz0gdmFsdWU7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA+IDApIHtcbiAgICAgIGFjY3VtdWxhdG9yWzFdICs9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYWNjdW11bGF0b3I7XG59XG5mdW5jdGlvbiBzdW0oaWQsIG1hdGNoR3JvdXBJZCkge1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgaWQsXG4gICAgbWF0Y2hHcm91cElkczogW21hdGNoR3JvdXBJZF0sXG4gICAgdHlwZTogXCJhZ2dyZWdhdGVcIixcbiAgICBhZ2dyZWdhdGVGdW5jdGlvbjogKHZhbHVlcykgPT4gc3VtVmFsdWVzKHZhbHVlcylcbiAgfTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdyb3VwU3VtKGlkLCBtYXRjaEdyb3VwSWQpIHtcbiAgcmV0dXJuIHtcbiAgICBpZCxcbiAgICB0eXBlOiBcImFnZ3JlZ2F0ZVwiLFxuICAgIG1hdGNoR3JvdXBJZHM6IG1hdGNoR3JvdXBJZCA/IFttYXRjaEdyb3VwSWRdIDogdm9pZCAwLFxuICAgIGFnZ3JlZ2F0ZUZ1bmN0aW9uOiAodmFsdWVzKSA9PiBzdW1WYWx1ZXModmFsdWVzKSxcbiAgICBncm91cEFnZ3JlZ2F0ZUZ1bmN0aW9uOiAobmV4dCwgYWNjID0gWzAsIDBdKSA9PiB7XG4gICAgICBhY2NbMF0gKz0gbmV4dD8uWzBdID8/IDA7XG4gICAgICBhY2NbMV0gKz0gbmV4dD8uWzFdID8/IDA7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHJhbmdlMihpZCwgbWF0Y2hHcm91cElkKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBpZCxcbiAgICBtYXRjaEdyb3VwSWRzOiBbbWF0Y2hHcm91cElkXSxcbiAgICB0eXBlOiBcImFnZ3JlZ2F0ZVwiLFxuICAgIGFnZ3JlZ2F0ZUZ1bmN0aW9uOiAodmFsdWVzKSA9PiBDb250aW51b3VzRG9tYWluLmV4dGVuZERvbWFpbih2YWx1ZXMpXG4gIH07XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBncm91cENvdW50KGlkKSB7XG4gIHJldHVybiB7XG4gICAgaWQsXG4gICAgdHlwZTogXCJhZ2dyZWdhdGVcIixcbiAgICBhZ2dyZWdhdGVGdW5jdGlvbjogKCkgPT4gWzAsIDFdLFxuICAgIGdyb3VwQWdncmVnYXRlRnVuY3Rpb246IChuZXh0LCBhY2MgPSBbMCwgMF0pID0+IHtcbiAgICAgIGFjY1swXSArPSBuZXh0Py5bMF0gPz8gMDtcbiAgICAgIGFjY1sxXSArPSBuZXh0Py5bMV0gPz8gMDtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZ3JvdXBBdmVyYWdlKGlkLCBtYXRjaEdyb3VwSWQpIHtcbiAgY29uc3QgZGVmID0ge1xuICAgIGlkLFxuICAgIG1hdGNoR3JvdXBJZHM6IG1hdGNoR3JvdXBJZCA/IFttYXRjaEdyb3VwSWRdIDogdm9pZCAwLFxuICAgIHR5cGU6IFwiYWdncmVnYXRlXCIsXG4gICAgYWdncmVnYXRlRnVuY3Rpb246ICh2YWx1ZXMpID0+IHN1bVZhbHVlcyh2YWx1ZXMpLFxuICAgIGdyb3VwQWdncmVnYXRlRnVuY3Rpb246IChuZXh0LCBhY2MgPSBbMCwgMCwgLTFdKSA9PiB7XG4gICAgICBhY2NbMF0gKz0gbmV4dD8uWzBdID8/IDA7XG4gICAgICBhY2NbMV0gKz0gbmV4dD8uWzFdID8/IDA7XG4gICAgICBhY2NbMl0rKztcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSxcbiAgICBmaW5hbEZ1bmN0aW9uOiAoYWNjID0gWzAsIDAsIDBdKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhY2NbMF0gKyBhY2NbMV07XG4gICAgICBpZiAocmVzdWx0ID49IDApIHtcbiAgICAgICAgcmV0dXJuIFswLCByZXN1bHQgLyBhY2NbMl1dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtyZXN1bHQgLyBhY2NbMl0sIDBdO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGRlZjtcbn1cbmZ1bmN0aW9uIGFyZWEoaWQsIGFnZ0ZuLCBtYXRjaEdyb3VwSWQpIHtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIGlkLFxuICAgIG1hdGNoR3JvdXBJZHM6IG1hdGNoR3JvdXBJZCA/IFttYXRjaEdyb3VwSWRdIDogdm9pZCAwLFxuICAgIHR5cGU6IFwiYWdncmVnYXRlXCIsXG4gICAgYWdncmVnYXRlRnVuY3Rpb246ICh2YWx1ZXMsIGtleVJhbmdlID0gW10pID0+IHtcbiAgICAgIGNvbnN0IGtleVdpZHRoID0ga2V5UmFuZ2VbMV0gLSBrZXlSYW5nZVswXTtcbiAgICAgIHJldHVybiBhZ2dGbi5hZ2dyZWdhdGVGdW5jdGlvbih2YWx1ZXMpLm1hcCgodikgPT4gdiAvIGtleVdpZHRoKTtcbiAgICB9XG4gIH07XG4gIGlmIChhZ2dGbi5ncm91cEFnZ3JlZ2F0ZUZ1bmN0aW9uKSB7XG4gICAgcmVzdWx0Lmdyb3VwQWdncmVnYXRlRnVuY3Rpb24gPSBhZ2dGbi5ncm91cEFnZ3JlZ2F0ZUZ1bmN0aW9uO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBhY2N1bXVsYXRlZFZhbHVlKG9ubHlQb3NpdGl2ZSkge1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGxldCB2YWx1ZSA9IDA7XG4gICAgcmV0dXJuIChkYXR1bSkgPT4ge1xuICAgICAgaWYgKCFpc0Zpbml0ZU51bWJlcihkYXR1bSkpIHtcbiAgICAgICAgcmV0dXJuIGRhdHVtO1xuICAgICAgfVxuICAgICAgdmFsdWUgKz0gb25seVBvc2l0aXZlID8gTWF0aC5tYXgoMCwgZGF0dW0pIDogZGF0dW07XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHRyYWlsaW5nQWNjdW11bGF0ZWRWYWx1ZSgpIHtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBsZXQgdmFsdWUgPSAwO1xuICAgIHJldHVybiAoZGF0dW0pID0+IHtcbiAgICAgIGlmICghaXNGaW5pdGVOdW1iZXIoZGF0dW0pKSB7XG4gICAgICAgIHJldHVybiBkYXR1bTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRyYWlsaW5nVmFsdWUgPSB2YWx1ZTtcbiAgICAgIHZhbHVlICs9IGRhdHVtO1xuICAgICAgcmV0dXJuIHRyYWlsaW5nVmFsdWU7XG4gICAgfTtcbiAgfTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvZGF0YS9wcm9jZXNzb3JzLnRzXG5mdW5jdGlvbiBiYXNpY0NvbnRpbnVvdXNDaGVja0RhdHVtVmFsaWRhdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0NvbnRpbnVvdXModmFsdWUpO1xufVxuZnVuY3Rpb24gYmFzaWNEaXNjcmV0ZUNoZWNrRGF0dW1WYWxpZGF0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsO1xufVxuZnVuY3Rpb24gZ2V0VmFsaWRhdGlvbkZuKHNjYWxlVHlwZSkge1xuICBzd2l0Y2ggKHNjYWxlVHlwZSkge1xuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICBjYXNlIFwibG9nXCI6XG4gICAgY2FzZSBcIm9yZGluYWwtdGltZVwiOlxuICAgIGNhc2UgXCJ0aW1lXCI6XG4gICAgY2FzZSBcImNvbG9yXCI6XG4gICAgICByZXR1cm4gYmFzaWNDb250aW51b3VzQ2hlY2tEYXR1bVZhbGlkYXRpb247XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBiYXNpY0Rpc2NyZXRlQ2hlY2tEYXR1bVZhbGlkYXRpb247XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFZhbHVlVHlwZShzY2FsZVR5cGUpIHtcbiAgc3dpdGNoIChzY2FsZVR5cGUpIHtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgY2FzZSBcImxvZ1wiOlxuICAgIGNhc2UgXCJ0aW1lXCI6XG4gICAgY2FzZSBcImNvbG9yXCI6XG4gICAgICByZXR1cm4gXCJyYW5nZVwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gXCJjYXRlZ29yeVwiO1xuICB9XG59XG5mdW5jdGlvbiBrZXlQcm9wZXJ0eShwcm9wTmFtZSwgc2NhbGVUeXBlLCBvcHRzID0ge30pIHtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIHByb3BlcnR5OiBwcm9wTmFtZSxcbiAgICB0eXBlOiBcImtleVwiLFxuICAgIHZhbHVlVHlwZTogZ2V0VmFsdWVUeXBlKHNjYWxlVHlwZSksXG4gICAgdmFsaWRhdGlvbjogZ2V0VmFsaWRhdGlvbkZuKHNjYWxlVHlwZSksXG4gICAgLi4ub3B0c1xuICB9O1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdmFsdWVQcm9wZXJ0eShwcm9wTmFtZSwgc2NhbGVUeXBlLCBvcHRzID0ge30pIHtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIHByb3BlcnR5OiBwcm9wTmFtZSxcbiAgICB0eXBlOiBcInZhbHVlXCIsXG4gICAgdmFsdWVUeXBlOiBnZXRWYWx1ZVR5cGUoc2NhbGVUeXBlKSxcbiAgICB2YWxpZGF0aW9uOiBnZXRWYWxpZGF0aW9uRm4oc2NhbGVUeXBlKSxcbiAgICAuLi5vcHRzXG4gIH07XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiByYW5nZWRWYWx1ZVByb3BlcnR5KHByb3BOYW1lLCBvcHRzID0ge30pIHtcbiAgY29uc3QgeyBtaW4gPSAtSW5maW5pdHksIG1heCA9IEluZmluaXR5LCAuLi5kZWZPcHRzIH0gPSBvcHRzO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwidmFsdWVcIixcbiAgICBwcm9wZXJ0eTogcHJvcE5hbWUsXG4gICAgdmFsdWVUeXBlOiBcInJhbmdlXCIsXG4gICAgdmFsaWRhdGlvbjogYmFzaWNDb250aW51b3VzQ2hlY2tEYXR1bVZhbGlkYXRpb24sXG4gICAgcHJvY2Vzc29yOiAoKSA9PiAoZGF0dW0pID0+IGlzRmluaXRlTnVtYmVyKGRhdHVtKSA/IGNsYW1wKG1pbiwgZGF0dW0sIG1heCkgOiBkYXR1bSxcbiAgICAuLi5kZWZPcHRzXG4gIH07XG59XG5mdW5jdGlvbiBhY2N1bXVsYXRpdmVWYWx1ZVByb3BlcnR5KHByb3BOYW1lLCBzY2FsZVR5cGUsIG9wdHMgPSB7fSkge1xuICBjb25zdCB7IG9ubHlQb3NpdGl2ZSwgLi4uZGVmT3B0cyB9ID0gb3B0cztcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIC4uLnZhbHVlUHJvcGVydHkocHJvcE5hbWUsIHNjYWxlVHlwZSwgZGVmT3B0cyksXG4gICAgcHJvY2Vzc29yOiBhY2N1bXVsYXRlZFZhbHVlKG9ubHlQb3NpdGl2ZSlcbiAgfTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHRyYWlsaW5nQWNjdW11bGF0ZWRWYWx1ZVByb3BlcnR5KHByb3BOYW1lLCBzY2FsZVR5cGUsIG9wdHMgPSB7fSkge1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgLi4udmFsdWVQcm9wZXJ0eShwcm9wTmFtZSwgc2NhbGVUeXBlLCBvcHRzKSxcbiAgICBwcm9jZXNzb3I6IHRyYWlsaW5nQWNjdW11bGF0ZWRWYWx1ZSgpXG4gIH07XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBncm91cEFjY3VtdWxhdGl2ZVZhbHVlUHJvcGVydHkocHJvcE5hbWUsIG1vZGUsIHN1bTIgPSBcImN1cnJlbnRcIiwgb3B0cywgc2NhbGVUeXBlKSB7XG4gIHJldHVybiBbXG4gICAgdmFsdWVQcm9wZXJ0eShwcm9wTmFtZSwgc2NhbGVUeXBlLCBvcHRzKSxcbiAgICBhY2N1bXVsYXRlR3JvdXAob3B0cy5ncm91cElkLCBtb2RlLCBzdW0yLCBvcHRzLnNlcGFyYXRlTmVnYXRpdmUpLFxuICAgIC4uLm9wdHMucmFuZ2VJZCAhPSBudWxsID8gW3JhbmdlMihvcHRzLnJhbmdlSWQsIG9wdHMuZ3JvdXBJZCldIDogW11cbiAgXTtcbn1cbmZ1bmN0aW9uIGdyb3VwU3RhY2tWYWx1ZVByb3BlcnR5KHByb3BOYW1lLCBzY2FsZVR5cGUsIG9wdHMpIHtcbiAgcmV0dXJuIFt2YWx1ZVByb3BlcnR5KHByb3BOYW1lLCBzY2FsZVR5cGUsIG9wdHMpLCBhY2N1bXVsYXRlU3RhY2sob3B0cy5ncm91cElkKV07XG59XG52YXIgU01BTExFU1RfS0VZX0lOVEVSVkFMID0ge1xuICB0eXBlOiBcInJlZHVjZXJcIixcbiAgcHJvcGVydHk6IFwic21hbGxlc3RLZXlJbnRlcnZhbFwiLFxuICBpbml0aWFsVmFsdWU6IEluZmluaXR5LFxuICByZWR1Y2VyOiAoKSA9PiB7XG4gICAgbGV0IHByZXZYID0gTmFOO1xuICAgIHJldHVybiAoc21hbGxlc3RTb0ZhciA9IEluZmluaXR5LCBuZXh0KSA9PiB7XG4gICAgICBjb25zdCBuZXh0WCA9IG5leHQua2V5c1swXTtcbiAgICAgIGNvbnN0IGludGVydmFsID0gTWF0aC5hYnMobmV4dFggLSBwcmV2WCk7XG4gICAgICBwcmV2WCA9IG5leHRYO1xuICAgICAgaWYgKCFpc05hTihpbnRlcnZhbCkgJiYgaW50ZXJ2YWwgPiAwICYmIGludGVydmFsIDwgc21hbGxlc3RTb0Zhcikge1xuICAgICAgICByZXR1cm4gaW50ZXJ2YWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gc21hbGxlc3RTb0ZhcjtcbiAgICB9O1xuICB9XG59O1xudmFyIExBUkdFU1RfS0VZX0lOVEVSVkFMID0ge1xuICB0eXBlOiBcInJlZHVjZXJcIixcbiAgcHJvcGVydHk6IFwibGFyZ2VzdEtleUludGVydmFsXCIsXG4gIGluaXRpYWxWYWx1ZTogLUluZmluaXR5LFxuICByZWR1Y2VyOiAoKSA9PiB7XG4gICAgbGV0IHByZXZYID0gTmFOO1xuICAgIHJldHVybiAobGFyZ2VzdFNvRmFyID0gLUluZmluaXR5LCBuZXh0KSA9PiB7XG4gICAgICBjb25zdCBuZXh0WCA9IG5leHQua2V5c1swXTtcbiAgICAgIGNvbnN0IGludGVydmFsID0gTWF0aC5hYnMobmV4dFggLSBwcmV2WCk7XG4gICAgICBwcmV2WCA9IG5leHRYO1xuICAgICAgaWYgKCFpc05hTihpbnRlcnZhbCkgJiYgaW50ZXJ2YWwgPiAwICYmIGludGVydmFsID4gbGFyZ2VzdFNvRmFyKSB7XG4gICAgICAgIHJldHVybiBpbnRlcnZhbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsYXJnZXN0U29GYXI7XG4gICAgfTtcbiAgfVxufTtcbnZhciBTT1JUX0RPTUFJTl9HUk9VUFMgPSB7XG4gIHR5cGU6IFwicHJvY2Vzc29yXCIsXG4gIHByb3BlcnR5OiBcInNvcnRlZEdyb3VwRG9tYWluXCIsXG4gIGNhbGN1bGF0ZTogKHsgZG9tYWluOiB7IGdyb3VwcyB9IH0pID0+IGdyb3Vwcz8uc2xpY2UoKS5zb3J0KChhLCBiKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhW2ldIC0gYltpXTtcbiAgICAgIGlmIChyZXN1bHQgIT09IDApIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0pXG59O1xuZnVuY3Rpb24gbm9ybWFsaXNlRm5CdWlsZGVyKHsgbm9ybWFsaXNlVG8sIG1vZGUgfSkge1xuICBjb25zdCBub3JtYWxpc2UgPSAodmFsLCBleHRlbnQyKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gdmFsICogbm9ybWFsaXNlVG8gLyBleHRlbnQyO1xuICAgIGlmIChyZXN1bHQgPj0gMCkge1xuICAgICAgcmV0dXJuIE1hdGgubWluKG5vcm1hbGlzZVRvLCByZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5tYXgoLW5vcm1hbGlzZVRvLCByZXN1bHQpO1xuICB9O1xuICByZXR1cm4gKCkgPT4gKCkgPT4gKHZhbHVlcywgdmFsdWVJbmRleGVzKSA9PiB7XG4gICAgY29uc3QgdmFsdWVzRXh0ZW50ID0gWzAsIDBdO1xuICAgIGZvciAoY29uc3QgdmFsdWVJZHggb2YgdmFsdWVJbmRleGVzKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1t2YWx1ZUlkeF07XG4gICAgICBjb25zdCB2YWx1ZUV4dGVudCA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiA/IHZhbHVlIDogTWF0aC5tYXgoLi4udmFsdWUpO1xuICAgICAgY29uc3QgdmFsSWR4ID0gdmFsdWVFeHRlbnQgPCAwID8gMCA6IDE7XG4gICAgICBpZiAobW9kZSA9PT0gXCJzdW1cIikge1xuICAgICAgICB2YWx1ZXNFeHRlbnRbdmFsSWR4XSArPSB2YWx1ZUV4dGVudDtcbiAgICAgIH0gZWxzZSBpZiAodmFsSWR4ID09PSAwKSB7XG4gICAgICAgIHZhbHVlc0V4dGVudFt2YWxJZHhdID0gTWF0aC5taW4odmFsdWVzRXh0ZW50W3ZhbElkeF0sIHZhbHVlRXh0ZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlc0V4dGVudFt2YWxJZHhdID0gTWF0aC5tYXgodmFsdWVzRXh0ZW50W3ZhbElkeF0sIHZhbHVlRXh0ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZXh0ZW50MiA9IE1hdGgubWF4KE1hdGguYWJzKHZhbHVlc0V4dGVudFswXSksIHZhbHVlc0V4dGVudFsxXSk7XG4gICAgZm9yIChjb25zdCB2YWx1ZUlkeCBvZiB2YWx1ZUluZGV4ZXMpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW3ZhbHVlSWR4XTtcbiAgICAgIHZhbHVlc1t2YWx1ZUlkeF0gPSB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgPyBub3JtYWxpc2UodmFsdWUsIGV4dGVudDIpIDogdmFsdWUubWFwKCh2KSA9PiBub3JtYWxpc2UodiwgZXh0ZW50MikpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGlzZUdyb3VwVG8obWF0Y2hHcm91cElkcywgbm9ybWFsaXNlVG8sIG1vZGUgPSBcInN1bVwiKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJncm91cC12YWx1ZS1wcm9jZXNzb3JcIixcbiAgICBtYXRjaEdyb3VwSWRzLFxuICAgIGFkanVzdDogbWVtbyh7IG5vcm1hbGlzZVRvLCBtb2RlIH0sIG5vcm1hbGlzZUZuQnVpbGRlcilcbiAgfTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGlzZVByb3BlcnR5Rm5CdWlsZGVyKHtcbiAgbm9ybWFsaXNlVG8sXG4gIHplcm9Eb21haW4sXG4gIHJhbmdlTWluLFxuICByYW5nZU1heFxufSkge1xuICBjb25zdCBub3JtYWxpc2VTcGFuID0gbm9ybWFsaXNlVG9bMV0gLSBub3JtYWxpc2VUb1swXTtcbiAgY29uc3Qgbm9ybWFsaXNlID0gKHZhbCwgc3RhcnQyLCBzcGFuKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gbm9ybWFsaXNlVG9bMF0gKyAodmFsIC0gc3RhcnQyKSAvIHNwYW4gKiBub3JtYWxpc2VTcGFuO1xuICAgIGlmIChzcGFuID09PSAwKSB7XG4gICAgICByZXR1cm4gemVyb0RvbWFpbjtcbiAgICB9IGVsc2UgaWYgKHJlc3VsdCA+PSBub3JtYWxpc2VUb1sxXSkge1xuICAgICAgcmV0dXJuIG5vcm1hbGlzZVRvWzFdO1xuICAgIH0gZWxzZSBpZiAocmVzdWx0IDwgbm9ybWFsaXNlVG9bMF0pIHtcbiAgICAgIHJldHVybiBub3JtYWxpc2VUb1swXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgcmV0dXJuICgpID0+IChwRGF0YSwgcElkeCkgPT4ge1xuICAgIGxldCBbc3RhcnQyLCBlbmQyXSA9IHBEYXRhLmRvbWFpbi52YWx1ZXNbcElkeF07XG4gICAgaWYgKHJhbmdlTWluICE9IG51bGwpXG4gICAgICBzdGFydDIgPSByYW5nZU1pbjtcbiAgICBpZiAocmFuZ2VNYXggIT0gbnVsbClcbiAgICAgIGVuZDIgPSByYW5nZU1heDtcbiAgICBjb25zdCBzcGFuID0gZW5kMiAtIHN0YXJ0MjtcbiAgICBwRGF0YS5kb21haW4udmFsdWVzW3BJZHhdID0gW25vcm1hbGlzZVRvWzBdLCBub3JtYWxpc2VUb1sxXV07XG4gICAgZm9yIChjb25zdCBncm91cCBvZiBwRGF0YS5kYXRhKSB7XG4gICAgICBsZXQgZ3JvdXBWYWx1ZXMgPSBncm91cC52YWx1ZXM7XG4gICAgICBpZiAocERhdGEudHlwZSA9PT0gXCJ1bmdyb3VwZWRcIikge1xuICAgICAgICBncm91cFZhbHVlcyA9IFtncm91cFZhbHVlc107XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHZhbHVlcyBvZiBncm91cFZhbHVlcykge1xuICAgICAgICB2YWx1ZXNbcElkeF0gPSBub3JtYWxpc2UodmFsdWVzW3BJZHhdLCBzdGFydDIsIHNwYW4pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGlzZVByb3BlcnR5VG8ocHJvcGVydHksIG5vcm1hbGlzZVRvLCB6ZXJvRG9tYWluLCByYW5nZU1pbiwgcmFuZ2VNYXgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInByb3BlcnR5LXZhbHVlLXByb2Nlc3NvclwiLFxuICAgIHByb3BlcnR5LFxuICAgIGFkanVzdDogbWVtbyh7IG5vcm1hbGlzZVRvLCByYW5nZU1pbiwgcmFuZ2VNYXgsIHplcm9Eb21haW4gfSwgbm9ybWFsaXNlUHJvcGVydHlGbkJ1aWxkZXIpXG4gIH07XG59XG5mdW5jdGlvbiBhbmltYXRpb25WYWxpZGF0aW9uKHZhbHVlS2V5SWRzKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJwcm9jZXNzb3JcIixcbiAgICBwcm9wZXJ0eTogXCJhbmltYXRpb25WYWxpZGF0aW9uXCIsXG4gICAgY2FsY3VsYXRlKHJlc3VsdCkge1xuICAgICAgY29uc3QgeyBrZXlzLCB2YWx1ZXMgfSA9IHJlc3VsdC5kZWZzO1xuICAgICAgY29uc3QgeyBpbnB1dCwgZGF0YSB9ID0gcmVzdWx0O1xuICAgICAgbGV0IHVuaXF1ZUtleXMgPSB0cnVlO1xuICAgICAgbGV0IG9yZGVyZWRLZXlzID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHZhbHVlS2V5cyA9IFtdO1xuICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCB2YWx1ZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgaWYgKCF2YWx1ZUtleUlkcz8uaW5jbHVkZXModmFsdWVzW2tdLmlkKSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgdmFsdWVLZXlzLnB1c2goW2ssIHZhbHVlc1trXV0pO1xuICAgICAgfVxuICAgICAgY29uc3QgcHJvY2Vzc0tleSA9IChpZHgsIGRlZiwgdHlwZSkgPT4ge1xuICAgICAgICBpZiAoZGVmLnZhbHVlVHlwZSA9PT0gXCJjYXRlZ29yeVwiKSB7XG4gICAgICAgICAgY29uc3Qga2V5VmFsdWVzID0gcmVzdWx0LmRvbWFpblt0eXBlXVtpZHhdO1xuICAgICAgICAgIHVuaXF1ZUtleXMgJiYgKHVuaXF1ZUtleXMgPSBrZXlWYWx1ZXMubGVuZ3RoID09PSBpbnB1dC5jb3VudCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsYXN0VmFsdWUgPSBkYXRhWzBdPy5bdHlwZV1baWR4XTtcbiAgICAgICAgZm9yIChsZXQgZCA9IDE7ICh1bmlxdWVLZXlzIHx8IG9yZGVyZWRLZXlzKSAmJiBkIDwgZGF0YS5sZW5ndGg7IGQrKykge1xuICAgICAgICAgIGNvbnN0IGtleVZhbHVlID0gZGF0YVtkXVt0eXBlXVtpZHhdO1xuICAgICAgICAgIG9yZGVyZWRLZXlzICYmIChvcmRlcmVkS2V5cyA9IGxhc3RWYWx1ZSA8PSBrZXlWYWx1ZSk7XG4gICAgICAgICAgdW5pcXVlS2V5cyAmJiAodW5pcXVlS2V5cyA9IGxhc3RWYWx1ZSAhPT0ga2V5VmFsdWUpO1xuICAgICAgICAgIGxhc3RWYWx1ZSA9IGtleVZhbHVlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZm9yIChsZXQgayA9IDA7ICh1bmlxdWVLZXlzIHx8IG9yZGVyZWRLZXlzKSAmJiBrIDwga2V5cy5sZW5ndGg7IGsrKykge1xuICAgICAgICBwcm9jZXNzS2V5KGssIGtleXNba10sIFwia2V5c1wiKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGsgPSAwOyAodW5pcXVlS2V5cyB8fCBvcmRlcmVkS2V5cykgJiYgayA8IHZhbHVlS2V5cy5sZW5ndGg7IGsrKykge1xuICAgICAgICBjb25zdCBbaWR4LCBrZXldID0gdmFsdWVLZXlzW2tdO1xuICAgICAgICBwcm9jZXNzS2V5KGlkeCwga2V5LCBcInZhbHVlc1wiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHVuaXF1ZUtleXMsIG9yZGVyZWRLZXlzIH07XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gYnVpbGRHcm91cEFjY0ZuKHsgbW9kZSwgc2VwYXJhdGVOZWdhdGl2ZSB9KSB7XG4gIHJldHVybiAoKSA9PiAoKSA9PiAodmFsdWVzLCB2YWx1ZUluZGV4ZXMpID0+IHtcbiAgICBjb25zdCBhY2MgPSBbMCwgMF07XG4gICAgZm9yIChjb25zdCB2YWx1ZUlkeCBvZiB2YWx1ZUluZGV4ZXMpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRWYWwgPSB2YWx1ZXNbdmFsdWVJZHhdO1xuICAgICAgY29uc3QgYWNjSW5kZXggPSBpc05lZ2F0aXZlKGN1cnJlbnRWYWwpICYmIHNlcGFyYXRlTmVnYXRpdmUgPyAwIDogMTtcbiAgICAgIGlmICghaXNGaW5pdGVOdW1iZXIoY3VycmVudFZhbCkpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgaWYgKG1vZGUgPT09IFwibm9ybWFsXCIpXG4gICAgICAgIGFjY1thY2NJbmRleF0gKz0gY3VycmVudFZhbDtcbiAgICAgIHZhbHVlc1t2YWx1ZUlkeF0gPSBhY2NbYWNjSW5kZXhdO1xuICAgICAgaWYgKG1vZGUgPT09IFwidHJhaWxpbmdcIilcbiAgICAgICAgYWNjW2FjY0luZGV4XSArPSBjdXJyZW50VmFsO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkR3JvdXBXaW5kb3dBY2NGbih7IG1vZGUsIHN1bTogc3VtMiB9KSB7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgY29uc3QgbGFzdFZhbHVlcyA9IFtdO1xuICAgIGxldCBmaXJzdFJvdyA9IHRydWU7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHJldHVybiAodmFsdWVzLCB2YWx1ZUluZGV4ZXMpID0+IHtcbiAgICAgICAgbGV0IGFjYyA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgdmFsdWVJZHggb2YgdmFsdWVJbmRleGVzKSB7XG4gICAgICAgICAgY29uc3QgY3VycmVudFZhbCA9IHZhbHVlc1t2YWx1ZUlkeF07XG4gICAgICAgICAgY29uc3QgbGFzdFZhbHVlID0gZmlyc3RSb3cgJiYgc3VtMiA9PT0gXCJjdXJyZW50XCIgPyAwIDogbGFzdFZhbHVlc1t2YWx1ZUlkeF07XG4gICAgICAgICAgbGFzdFZhbHVlc1t2YWx1ZUlkeF0gPSBjdXJyZW50VmFsO1xuICAgICAgICAgIGNvbnN0IHN1bVZhbHVlID0gc3VtMiA9PT0gXCJjdXJyZW50XCIgPyBjdXJyZW50VmFsIDogbGFzdFZhbHVlO1xuICAgICAgICAgIGlmICghaXNGaW5pdGVOdW1iZXIoY3VycmVudFZhbCkgfHwgIWlzRmluaXRlTnVtYmVyKGxhc3RWYWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlc1t2YWx1ZUlkeF0gPSBhY2M7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1vZGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAgIGFjYyArPSBzdW1WYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsdWVzW3ZhbHVlSWR4XSA9IGFjYztcbiAgICAgICAgICBpZiAobW9kZSA9PT0gXCJ0cmFpbGluZ1wiKSB7XG4gICAgICAgICAgICBhY2MgKz0gc3VtVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpcnN0Um93ID0gZmFsc2U7XG4gICAgICB9O1xuICAgIH07XG4gIH07XG59XG5mdW5jdGlvbiBhY2N1bXVsYXRlR3JvdXAobWF0Y2hHcm91cElkLCBtb2RlLCBzdW0yLCBzZXBhcmF0ZU5lZ2F0aXZlID0gZmFsc2UpIHtcbiAgbGV0IGFkanVzdDtcbiAgaWYgKG1vZGUuc3RhcnRzV2l0aChcIndpbmRvd1wiKSkge1xuICAgIGNvbnN0IG1vZGVQYXJhbSA9IG1vZGUuZW5kc1dpdGgoXCItdHJhaWxpbmdcIikgPyBcInRyYWlsaW5nXCIgOiBcIm5vcm1hbFwiO1xuICAgIGFkanVzdCA9IG1lbW8oeyBtb2RlOiBtb2RlUGFyYW0sIHN1bTogc3VtMiB9LCBidWlsZEdyb3VwV2luZG93QWNjRm4pO1xuICB9IGVsc2Uge1xuICAgIGFkanVzdCA9IG1lbW8oeyBtb2RlLCBzZXBhcmF0ZU5lZ2F0aXZlIH0sIGJ1aWxkR3JvdXBBY2NGbik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImdyb3VwLXZhbHVlLXByb2Nlc3NvclwiLFxuICAgIG1hdGNoR3JvdXBJZHM6IFttYXRjaEdyb3VwSWRdLFxuICAgIGFkanVzdFxuICB9O1xufVxuZnVuY3Rpb24gZ3JvdXBTdGFja0FjY0ZuKCkge1xuICByZXR1cm4gKCkgPT4gKHZhbHVlcywgdmFsdWVJbmRleGVzKSA9PiB7XG4gICAgY29uc3QgYWNjID0gbmV3IEZsb2F0NjRBcnJheSgzMik7XG4gICAgbGV0IHN0YWNrQ291bnQgPSAwO1xuICAgIGZvciAoY29uc3QgdmFsdWVJZHggb2YgdmFsdWVJbmRleGVzKSB7XG4gICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB2YWx1ZXNbdmFsdWVJZHhdO1xuICAgICAgYWNjW3N0YWNrQ291bnRdID0gTnVtYmVyLmlzRmluaXRlKGN1cnJlbnRWYWx1ZSkgPyBjdXJyZW50VmFsdWUgOiBOYU47XG4gICAgICBzdGFja0NvdW50ICs9IDE7XG4gICAgICB2YWx1ZXNbdmFsdWVJZHhdID0gYWNjLnN1YmFycmF5KDAsIHN0YWNrQ291bnQpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGFjY3VtdWxhdGVTdGFjayhtYXRjaEdyb3VwSWQpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImdyb3VwLXZhbHVlLXByb2Nlc3NvclwiLFxuICAgIG1hdGNoR3JvdXBJZHM6IFttYXRjaEdyb3VwSWRdLFxuICAgIGFkanVzdDogZ3JvdXBTdGFja0FjY0ZuXG4gIH07XG59XG5mdW5jdGlvbiBkaWZmKHByZXZpb3VzRGF0YSwgdXBkYXRlTW92ZWREYXRhID0gdHJ1ZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwicHJvY2Vzc29yXCIsXG4gICAgcHJvcGVydHk6IFwiZGlmZlwiLFxuICAgIGNhbGN1bGF0ZTogKHByb2Nlc3NlZERhdGEpID0+IHtcbiAgICAgIGNvbnN0IG1vdmVkID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIGNvbnN0IGFkZGVkID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIGNvbnN0IHVwZGF0ZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgY29uc3QgcmVtb3ZlZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBjb25zdCBsZW5ndGgyID0gTWF0aC5tYXgocHJldmlvdXNEYXRhLmRhdGEubGVuZ3RoLCBwcm9jZXNzZWREYXRhLmRhdGEubGVuZ3RoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHByZXYgPSBwcmV2aW91c0RhdGEuZGF0YVtpXTtcbiAgICAgICAgY29uc3QgZGF0dW0gPSBwcm9jZXNzZWREYXRhLmRhdGFbaV07XG4gICAgICAgIGNvbnN0IHByZXZJZCA9IHByZXYgPyBjcmVhdGVEYXR1bUlkKHByZXYua2V5cykgOiBcIlwiO1xuICAgICAgICBjb25zdCBkYXR1bUlkID0gZGF0dW0gPyBjcmVhdGVEYXR1bUlkKGRhdHVtLmtleXMpIDogXCJcIjtcbiAgICAgICAgaWYgKGRhdHVtICYmIHByZXYgJiYgcHJldklkID09PSBkYXR1bUlkKSB7XG4gICAgICAgICAgaWYgKCFhcnJheXNFcXVhbChwcmV2LnZhbHVlcywgZGF0dW0udmFsdWVzKSkge1xuICAgICAgICAgICAgdXBkYXRlZC5zZXQoZGF0dW1JZCwgZGF0dW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVtb3ZlZC5oYXMoZGF0dW1JZCkpIHtcbiAgICAgICAgICBpZiAodXBkYXRlTW92ZWREYXRhIHx8ICFhcnJheXNFcXVhbChyZW1vdmVkLmdldChkYXR1bUlkKS52YWx1ZXMsIGRhdHVtLnZhbHVlcykpIHtcbiAgICAgICAgICAgIHVwZGF0ZWQuc2V0KGRhdHVtSWQsIGRhdHVtKTtcbiAgICAgICAgICAgIG1vdmVkLnNldChkYXR1bUlkLCBkYXR1bSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlbW92ZWQuZGVsZXRlKGRhdHVtSWQpO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdHVtKSB7XG4gICAgICAgICAgYWRkZWQuc2V0KGRhdHVtSWQsIGRhdHVtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWRkZWQuaGFzKHByZXZJZCkpIHtcbiAgICAgICAgICBpZiAodXBkYXRlTW92ZWREYXRhIHx8ICFhcnJheXNFcXVhbChhZGRlZC5nZXQocHJldklkKS52YWx1ZXMsIHByZXYudmFsdWVzKSkge1xuICAgICAgICAgICAgdXBkYXRlZC5zZXQocHJldklkLCBwcmV2KTtcbiAgICAgICAgICAgIG1vdmVkLnNldChwcmV2SWQsIHByZXYpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhZGRlZC5kZWxldGUocHJldklkKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcmV2KSB7XG4gICAgICAgICAgdXBkYXRlZC5kZWxldGUocHJldklkKTtcbiAgICAgICAgICByZW1vdmVkLnNldChwcmV2SWQsIHByZXYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBjaGFuZ2VkID0gYWRkZWQuc2l6ZSA+IDAgfHwgdXBkYXRlZC5zaXplID4gMCB8fCByZW1vdmVkLnNpemUgPiAwO1xuICAgICAgcmV0dXJuIHsgY2hhbmdlZCwgYWRkZWQsIHVwZGF0ZWQsIHJlbW92ZWQsIG1vdmVkIH07XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlRGF0dW1JZChrZXlzLCAuLi5leHRyYUtleXMpIHtcbiAgbGV0IHJlc3VsdDtcbiAgaWYgKGlzQXJyYXkoa2V5cykpIHtcbiAgICByZXN1bHQgPSBrZXlzLm1hcCgoa2V5KSA9PiB0cmFuc2Zvcm1JbnRlZ3JhdGVkQ2F0ZWdvcnlWYWx1ZShrZXkpKS5qb2luKFwiX19fXCIpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IHRyYW5zZm9ybUludGVncmF0ZWRDYXRlZ29yeVZhbHVlKGtleXMpO1xuICB9XG4gIGNvbnN0IHByaW1pdGl2ZVR5cGUgPSB0eXBlb2YgcmVzdWx0ID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiByZXN1bHQgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHJlc3VsdCA9PT0gXCJib29sZWFuXCIgfHwgcmVzdWx0IGluc3RhbmNlb2YgRGF0ZTtcbiAgaWYgKHByaW1pdGl2ZVR5cGUgJiYgZXh0cmFLZXlzLmxlbmd0aCA+IDApIHtcbiAgICByZXN1bHQgKz0gYF9fXyR7ZXh0cmFLZXlzLmpvaW4oXCJfX19cIil9YDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvc2VyaWVzTGFiZWxVdGlsLnRzXG5mdW5jdGlvbiBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih7IGlkIH0sIHN1YklkLCBhbmltYXRpb25NYW5hZ2VyLCAuLi5sYWJlbFNlbGVjdGlvbnMpIHtcbiAgc3RhdGljRnJvbVRvTW90aW9uKFxuICAgIGlkLFxuICAgIHN1YklkLFxuICAgIGFuaW1hdGlvbk1hbmFnZXIsXG4gICAgbGFiZWxTZWxlY3Rpb25zLFxuICAgIHsgb3BhY2l0eTogMCB9LFxuICAgIHsgb3BhY2l0eTogMSB9LFxuICAgIHsgcGhhc2U6IFwidHJhaWxpbmdcIiB9XG4gICk7XG59XG5mdW5jdGlvbiBzZXJpZXNMYWJlbEZhZGVPdXRBbmltYXRpb24oeyBpZCB9LCBzdWJJZCwgYW5pbWF0aW9uTWFuYWdlciwgLi4ubGFiZWxTZWxlY3Rpb25zKSB7XG4gIHN0YXRpY0Zyb21Ub01vdGlvbihcbiAgICBpZCxcbiAgICBzdWJJZCxcbiAgICBhbmltYXRpb25NYW5hZ2VyLFxuICAgIGxhYmVsU2VsZWN0aW9ucyxcbiAgICB7IG9wYWNpdHk6IDEgfSxcbiAgICB7IG9wYWNpdHk6IDAgfSxcbiAgICB7IHBoYXNlOiBcInJlbW92ZVwiIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIHJlc2V0TGFiZWxGbihfbm9kZSkge1xuICByZXR1cm4geyBvcGFjaXR5OiAxIH07XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL3V0aWwvY2hhbmdlRGV0ZWN0YWJsZVByb3BlcnRpZXMudHNcbnZhciBDaGFuZ2VEZXRlY3RhYmxlUHJvcGVydGllcyA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuX2RpcnR5ID0gMyAvKiBNQUpPUiAqLztcbiAgfVxuICBtYXJrRGlydHkodHlwZSA9IDEgLyogVFJJVklBTCAqLykge1xuICAgIGlmICh0aGlzLl9kaXJ0eSA8IHR5cGUpIHtcbiAgICAgIHRoaXMuX2RpcnR5ID0gdHlwZTtcbiAgICB9XG4gIH1cbiAgbWFya0NsZWFuKF9vcHRzKSB7XG4gICAgdGhpcy5fZGlydHkgPSAwIC8qIE5PTkUgKi87XG4gIH1cbiAgaXNEaXJ0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGlydHkgPiAwIC8qIE5PTkUgKi87XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL2Ryb3BTaGFkb3cudHNcbnZhciBEcm9wU2hhZG93ID0gY2xhc3MgZXh0ZW5kcyBDaGFuZ2VEZXRlY3RhYmxlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLmNvbG9yID0gXCJyZ2JhKDAsIDAsIDAsIDAuNSlcIjtcbiAgICB0aGlzLnhPZmZzZXQgPSAwO1xuICAgIHRoaXMueU9mZnNldCA9IDA7XG4gICAgdGhpcy5ibHVyID0gNTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pLFxuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLyB9KVxuXSwgRHJvcFNoYWRvdy5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORyksXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBEcm9wU2hhZG93LnByb3RvdHlwZSwgXCJjb2xvclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE5VTUJFUiksXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBEcm9wU2hhZG93LnByb3RvdHlwZSwgXCJ4T2Zmc2V0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTlVNQkVSKSxcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8gfSlcbl0sIERyb3BTaGFkb3cucHJvdG90eXBlLCBcInlPZmZzZXRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpLFxuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLyB9KVxuXSwgRHJvcFNoYWRvdy5wcm90b3R5cGUsIFwiYmx1clwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL3Nlcmllc01hcmtlci50c1xudmFyIE1BUktFUl9TSEFQRSA9IHByZWRpY2F0ZVdpdGhNZXNzYWdlKFxuICAodmFsdWUpID0+IGlzTWFya2VyU2hhcGUodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiICYmIE9iamVjdC5jcmVhdGUodmFsdWUucHJvdG90eXBlKSBpbnN0YW5jZW9mIE1hcmtlcixcbiAgYGEgbWFya2VyIHNoYXBlIGtleXdvcmQgc3VjaCBhcyAnY2lyY2xlJywgJ2RpYW1vbmQnIG9yICdzcXVhcmUnIG9yIGFuIG9iamVjdCBleHRlbmRpbmcgdGhlIE1hcmtlciBjbGFzc2Bcbik7XG52YXIgU2VyaWVzTWFya2VyID0gY2xhc3MgZXh0ZW5kcyBDaGFuZ2VEZXRlY3RhYmxlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLnNoYXBlID0gQ2lyY2xlO1xuICAgIHRoaXMuc2l6ZSA9IDY7XG4gICAgdGhpcy5maWxsT3BhY2l0eSA9IDE7XG4gICAgdGhpcy5zdHJva2VXaWR0aCA9IDE7XG4gICAgdGhpcy5zdHJva2VPcGFjaXR5ID0gMTtcbiAgfVxuICBnZXRTdHlsZSgpIHtcbiAgICBjb25zdCB7IHNpemUsIHNoYXBlLCBmaWxsLCBmaWxsT3BhY2l0eSwgc3Ryb2tlLCBzdHJva2VXaWR0aCwgc3Ryb2tlT3BhY2l0eSB9ID0gdGhpcztcbiAgICByZXR1cm4geyBzaXplLCBzaGFwZSwgZmlsbCwgZmlsbE9wYWNpdHksIHN0cm9rZSwgc3Ryb2tlV2lkdGgsIHN0cm9rZU9wYWNpdHkgfTtcbiAgfVxuICBnZXREaWFtZXRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5zaXplICsgdGhpcy5zdHJva2VXaWR0aDtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pLFxuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLyB9KVxuXSwgU2VyaWVzTWFya2VyLnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTUFSS0VSX1NIQVBFKSxcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8gfSlcbl0sIFNlcmllc01hcmtlci5wcm90b3R5cGUsIFwic2hhcGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpLFxuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLyB9KVxuXSwgU2VyaWVzTWFya2VyLnByb3RvdHlwZSwgXCJzaXplXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pLFxuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLyB9KVxuXSwgU2VyaWVzTWFya2VyLnByb3RvdHlwZSwgXCJmaWxsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8pLFxuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLyB9KVxuXSwgU2VyaWVzTWFya2VyLnByb3RvdHlwZSwgXCJmaWxsT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KSxcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8gfSlcbl0sIFNlcmllc01hcmtlci5wcm90b3R5cGUsIFwic3Ryb2tlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKSxcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8gfSlcbl0sIFNlcmllc01hcmtlci5wcm90b3R5cGUsIFwic3Ryb2tlV2lkdGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTyksXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBTZXJpZXNNYXJrZXIucHJvdG90eXBlLCBcInN0cm9rZU9wYWNpdHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGVU5DVElPTiwgeyBvcHRpb25hbDogdHJ1ZSB9KSxcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8gfSlcbl0sIFNlcmllc01hcmtlci5wcm90b3R5cGUsIFwiaXRlbVN0eWxlclwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL3Nlcmllc1Rvb2x0aXAudHNcbnZhciBTZXJpZXNUb29sdGlwSW50ZXJhY3Rpb24gPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBTZXJpZXNUb29sdGlwSW50ZXJhY3Rpb24ucHJvdG90eXBlLCBcImVuYWJsZWRcIiwgMik7XG52YXIgU2VyaWVzVG9vbHRpcCA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5pbnRlcmFjdGlvbiA9IG5ldyBTZXJpZXNUb29sdGlwSW50ZXJhY3Rpb24oKTtcbiAgICB0aGlzLnBvc2l0aW9uID0gbmV3IFRvb2x0aXBQb3NpdGlvbigpO1xuICAgIHRoaXMucmFuZ2UgPSB2b2lkIDA7XG4gIH1cbiAgdG9Ub29sdGlwSHRtbChkZWZhdWx0cywgcGFyYW1zKSB7XG4gICAgaWYgKHRoaXMucmVuZGVyZXIpIHtcbiAgICAgIHJldHVybiB0b1Rvb2x0aXBIdG1sKHRoaXMucmVuZGVyZXIocGFyYW1zKSwgZGVmYXVsdHMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9Ub29sdGlwSHRtbChkZWZhdWx0cyk7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgU2VyaWVzVG9vbHRpcC5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFNlcmllc1Rvb2x0aXAucHJvdG90eXBlLCBcInNob3dBcnJvd1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZVTkNUSU9OLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBTZXJpZXNUb29sdGlwLnByb3RvdHlwZSwgXCJyZW5kZXJlclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIFNlcmllc1Rvb2x0aXAucHJvdG90eXBlLCBcImludGVyYWN0aW9uXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgU2VyaWVzVG9vbHRpcC5wcm90b3R5cGUsIFwicG9zaXRpb25cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShJTlRFUkFDVElPTl9SQU5HRSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgU2VyaWVzVG9vbHRpcC5wcm90b3R5cGUsIFwicmFuZ2VcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vaW50ZXJwb2xhdGlvblByb3BlcnRpZXMudHNcbnZhciBJTlRFUlBPTEFUSU9OX1RZUEUgPSBVTklPTihbXCJsaW5lYXJcIiwgXCJzbW9vdGhcIiwgXCJzdGVwXCJdLCBcImEgbGluZSBzdHlsZVwiKTtcbnZhciBJTlRFUlBPTEFUSU9OX1NURVBfUE9TSVRJT04gPSBVTklPTihbXCJzdGFydFwiLCBcIm1pZGRsZVwiLCBcImVuZFwiXSk7XG52YXIgSW50ZXJwb2xhdGlvblByb3BlcnRpZXMgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnR5cGUgPSBcImxpbmVhclwiO1xuICAgIHRoaXMudGVuc2lvbiA9IDE7XG4gICAgdGhpcy5wb3NpdGlvbiA9IFwiZW5kXCI7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShJTlRFUlBPTEFUSU9OX1RZUEUpXG5dLCBJbnRlcnBvbGF0aW9uUHJvcGVydGllcy5wcm90b3R5cGUsIFwidHlwZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPKVxuXSwgSW50ZXJwb2xhdGlvblByb3BlcnRpZXMucHJvdG90eXBlLCBcInRlbnNpb25cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShJTlRFUlBPTEFUSU9OX1NURVBfUE9TSVRJT04pXG5dLCBJbnRlcnBvbGF0aW9uUHJvcGVydGllcy5wcm90b3R5cGUsIFwicG9zaXRpb25cIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vYXJlYVNlcmllc1Byb3BlcnRpZXMudHNcbnZhciBBcmVhU2VyaWVzUHJvcGVydGllcyA9IGNsYXNzIGV4dGVuZHMgQ2FydGVzaWFuU2VyaWVzUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy54TmFtZSA9IHZvaWQgMDtcbiAgICB0aGlzLmZpbGwgPSBcIiNjMTYwNjhcIjtcbiAgICB0aGlzLmZpbGxPcGFjaXR5ID0gMTtcbiAgICB0aGlzLnN0cm9rZSA9IFwiIzg3NDM0OVwiO1xuICAgIHRoaXMuc3Ryb2tlV2lkdGggPSAyO1xuICAgIHRoaXMuc3Ryb2tlT3BhY2l0eSA9IDE7XG4gICAgdGhpcy5saW5lRGFzaCA9IFswXTtcbiAgICB0aGlzLmxpbmVEYXNoT2Zmc2V0ID0gMDtcbiAgICB0aGlzLmludGVycG9sYXRpb24gPSBuZXcgSW50ZXJwb2xhdGlvblByb3BlcnRpZXMoKTtcbiAgICB0aGlzLnNoYWRvdyA9IG5ldyBEcm9wU2hhZG93KCk7XG4gICAgdGhpcy5tYXJrZXIgPSBuZXcgU2VyaWVzTWFya2VyKCk7XG4gICAgdGhpcy5sYWJlbCA9IG5ldyBMYWJlbCgpO1xuICAgIHRoaXMudG9vbHRpcCA9IG5ldyBTZXJpZXNUb29sdGlwKCk7XG4gICAgdGhpcy5jb25uZWN0TWlzc2luZ0RhdGEgPSBmYWxzZTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORylcbl0sIEFyZWFTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ4S2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBBcmVhU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwieE5hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcpXG5dLCBBcmVhU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwieUtleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQXJlYVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInlOYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBBcmVhU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwieUZpbHRlcktleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQXJlYVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcIm5vcm1hbGl6ZWRUb1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORylcbl0sIEFyZWFTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJmaWxsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8pXG5dLCBBcmVhU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiZmlsbE9wYWNpdHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcpXG5dLCBBcmVhU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic3Ryb2tlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgQXJlYVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0cm9rZVdpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8pXG5dLCBBcmVhU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic3Ryb2tlT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKExJTkVfREFTSClcbl0sIEFyZWFTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJsaW5lRGFzaFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIEFyZWFTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJsaW5lRGFzaE9mZnNldFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIEFyZWFTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJpbnRlcnBvbGF0aW9uXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgQXJlYVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInNoYWRvd1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIEFyZWFTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJtYXJrZXJcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBBcmVhU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGFiZWxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBBcmVhU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwidG9vbHRpcFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBBcmVhU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiY29ubmVjdE1pc3NpbmdEYXRhXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2xpbmVJbnRlcnBvbGF0aW9uLnRzXG5mdW5jdGlvbiBzcGFuUmFuZ2Uoc3Bhbikge1xuICBzd2l0Y2ggKHNwYW4udHlwZSkge1xuICAgIGNhc2UgXCJsaW5lYXJcIjpcbiAgICBjYXNlIFwic3RlcFwiOlxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgeyB4OiBzcGFuLngwLCB5OiBzcGFuLnkwIH0sXG4gICAgICAgIHsgeDogc3Bhbi54MSwgeTogc3Bhbi55MSB9XG4gICAgICBdO1xuICAgIGNhc2UgXCJjdWJpY1wiOlxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgeyB4OiBzcGFuLmNwMHgsIHk6IHNwYW4uY3AweSB9LFxuICAgICAgICB7IHg6IHNwYW4uY3AzeCwgeTogc3Bhbi5jcDN5IH1cbiAgICAgIF07XG4gIH1cbn1cbmZ1bmN0aW9uIHNwYW5SYW5nZU5vcm1hbGl6ZWQoc3Bhbikge1xuICBjb25zdCByYW5nZTMgPSBzcGFuUmFuZ2Uoc3Bhbik7XG4gIGlmIChyYW5nZTNbMF0ueCA+IHJhbmdlM1sxXS54KSB7XG4gICAgcmFuZ2UzLnJldmVyc2UoKTtcbiAgfVxuICByZXR1cm4gcmFuZ2UzO1xufVxuZnVuY3Rpb24gcmVzY2FsZVNwYW4oc3BhbiwgbmV4dFN0YXJ0LCBuZXh0RW5kKSB7XG4gIGNvbnN0IFtwcmV2U3RhcnQsIHByZXZFbmRdID0gc3BhblJhbmdlKHNwYW4pO1xuICBjb25zdCB3aWR0aFNjYWxlID0gcHJldkVuZC54ICE9PSBwcmV2U3RhcnQueCA/IChuZXh0RW5kLnggLSBuZXh0U3RhcnQueCkgLyAocHJldkVuZC54IC0gcHJldlN0YXJ0LngpIDogMDtcbiAgY29uc3QgaGVpZ2h0U2NhbGUgPSBwcmV2RW5kLnkgIT09IHByZXZTdGFydC55ID8gKG5leHRFbmQueSAtIG5leHRTdGFydC55KSAvIChwcmV2RW5kLnkgLSBwcmV2U3RhcnQueSkgOiAwO1xuICBzd2l0Y2ggKHNwYW4udHlwZSkge1xuICAgIGNhc2UgXCJsaW5lYXJcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwibGluZWFyXCIsXG4gICAgICAgIG1vdmVUbzogc3Bhbi5tb3ZlVG8sXG4gICAgICAgIHgwOiBuZXh0U3RhcnQueCxcbiAgICAgICAgeTA6IG5leHRTdGFydC55LFxuICAgICAgICB4MTogbmV4dEVuZC54LFxuICAgICAgICB5MTogbmV4dEVuZC55XG4gICAgICB9O1xuICAgIGNhc2UgXCJjdWJpY1wiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJjdWJpY1wiLFxuICAgICAgICBtb3ZlVG86IHNwYW4ubW92ZVRvLFxuICAgICAgICBjcDB4OiBuZXh0U3RhcnQueCxcbiAgICAgICAgY3AweTogbmV4dFN0YXJ0LnksXG4gICAgICAgIGNwMXg6IG5leHRFbmQueCAtIChzcGFuLmNwMnggLSBwcmV2U3RhcnQueCkgKiB3aWR0aFNjYWxlLFxuICAgICAgICBjcDF5OiBuZXh0RW5kLnkgLSAoc3Bhbi5jcDJ5IC0gcHJldlN0YXJ0LnkpICogaGVpZ2h0U2NhbGUsXG4gICAgICAgIGNwMng6IG5leHRFbmQueCAtIChzcGFuLmNwMXggLSBwcmV2U3RhcnQueCkgKiB3aWR0aFNjYWxlLFxuICAgICAgICBjcDJ5OiBuZXh0RW5kLnkgLSAoc3Bhbi5jcDF5IC0gcHJldlN0YXJ0LnkpICogaGVpZ2h0U2NhbGUsXG4gICAgICAgIGNwM3g6IG5leHRFbmQueCxcbiAgICAgICAgY3AzeTogbmV4dEVuZC55XG4gICAgICB9O1xuICAgIGNhc2UgXCJzdGVwXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInN0ZXBcIixcbiAgICAgICAgbW92ZVRvOiBzcGFuLm1vdmVUbyxcbiAgICAgICAgeDA6IG5leHRTdGFydC54LFxuICAgICAgICB5MDogbmV4dFN0YXJ0LnksXG4gICAgICAgIHgxOiBuZXh0RW5kLngsXG4gICAgICAgIHkxOiBuZXh0RW5kLnksXG4gICAgICAgIHN0ZXBYOiBuZXh0RW5kLnggLSAoc3Bhbi5zdGVwWCAtIHByZXZTdGFydC54KSAqIHdpZHRoU2NhbGVcbiAgICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGNsaXBTcGFuWChzcGFuLCB4MCwgeDEpIHtcbiAgY29uc3QgeyBtb3ZlVG8gfSA9IHNwYW47XG4gIGNvbnN0IFtzdGFydDIsIGVuZDJdID0gc3BhblJhbmdlTm9ybWFsaXplZChzcGFuKTtcbiAgY29uc3QgeyB4OiBzcGFuWDAsIHk6IHNwYW5ZMCB9ID0gc3RhcnQyO1xuICBjb25zdCB7IHg6IHNwYW5YMSwgeTogc3BhblkxIH0gPSBlbmQyO1xuICBpZiAoeDEgPCBzcGFuWDApIHtcbiAgICByZXR1cm4gcmVzY2FsZVNwYW4oc3Bhbiwgc3RhcnQyLCBzdGFydDIpO1xuICB9IGVsc2UgaWYgKHgwID4gc3BhblgxKSB7XG4gICAgcmV0dXJuIHJlc2NhbGVTcGFuKHNwYW4sIGVuZDIsIGVuZDIpO1xuICB9XG4gIHN3aXRjaCAoc3Bhbi50eXBlKSB7XG4gICAgY2FzZSBcImxpbmVhclwiOiB7XG4gICAgICBjb25zdCBtID0gc3BhblkwID09PSBzcGFuWTEgPyB2b2lkIDAgOiAoc3BhblkxIC0gc3BhblkwKSAvIChzcGFuWDEgLSBzcGFuWDApO1xuICAgICAgY29uc3QgeTAgPSBtID09IG51bGwgPyBzcGFuWTAgOiBtICogKHgwIC0gc3BhblgwKSArIHNwYW5ZMDtcbiAgICAgIGNvbnN0IHkxID0gbSA9PSBudWxsID8gc3BhblkwIDogbSAqICh4MSAtIHNwYW5YMCkgKyBzcGFuWTA7XG4gICAgICByZXR1cm4geyB0eXBlOiBcImxpbmVhclwiLCBtb3ZlVG8sIHgwLCB5MCwgeDEsIHkxIH07XG4gICAgfVxuICAgIGNhc2UgXCJzdGVwXCI6XG4gICAgICBpZiAoeDEgPD0gc3Bhbi5zdGVwWCkge1xuICAgICAgICBjb25zdCB5ID0gc3Bhbi55MDtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJzdGVwXCIsIG1vdmVUbywgeDAsIHkwOiB5LCB4MSwgeTE6IHksIHN0ZXBYOiB4MSB9O1xuICAgICAgfSBlbHNlIGlmICh4MCA+PSBzcGFuLnN0ZXBYKSB7XG4gICAgICAgIGNvbnN0IHkgPSBzcGFuLnkxO1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcInN0ZXBcIiwgbW92ZVRvLCB4MCwgeTA6IHksIHgxLCB5MTogeSwgc3RlcFg6IHgwIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB7IHkwLCB5MSwgc3RlcFggfSA9IHNwYW47XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwic3RlcFwiLCBtb3ZlVG8sIHgwLCB5MCwgeDEsIHkxLCBzdGVwWCB9O1xuICAgICAgfVxuICAgIGNhc2UgXCJjdWJpY1wiOiB7XG4gICAgICBjb25zdCB0MCA9IHNvbHZlQmV6aWVyKHNwYW4uY3AweCwgc3Bhbi5jcDF4LCBzcGFuLmNwMngsIHNwYW4uY3AzeCwgeDApO1xuICAgICAgbGV0IFtfdW51c2VkLCBiZXppZXJdID0gc3BsaXRCZXppZXIoXG4gICAgICAgIHNwYW4uY3AweCxcbiAgICAgICAgc3Bhbi5jcDB5LFxuICAgICAgICBzcGFuLmNwMXgsXG4gICAgICAgIHNwYW4uY3AxeSxcbiAgICAgICAgc3Bhbi5jcDJ4LFxuICAgICAgICBzcGFuLmNwMnksXG4gICAgICAgIHNwYW4uY3AzeCxcbiAgICAgICAgc3Bhbi5jcDN5LFxuICAgICAgICB0MFxuICAgICAgKTtcbiAgICAgIGNvbnN0IHQxID0gc29sdmVCZXppZXIoYmV6aWVyWzBdLngsIGJlemllclsxXS54LCBiZXppZXJbMl0ueCwgYmV6aWVyWzNdLngsIHgxKTtcbiAgICAgIFtiZXppZXIsIF91bnVzZWRdID0gc3BsaXRCZXppZXIoXG4gICAgICAgIGJlemllclswXS54LFxuICAgICAgICBiZXppZXJbMF0ueSxcbiAgICAgICAgYmV6aWVyWzFdLngsXG4gICAgICAgIGJlemllclsxXS55LFxuICAgICAgICBiZXppZXJbMl0ueCxcbiAgICAgICAgYmV6aWVyWzJdLnksXG4gICAgICAgIGJlemllclszXS54LFxuICAgICAgICBiZXppZXJbM10ueSxcbiAgICAgICAgdDFcbiAgICAgICk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImN1YmljXCIsXG4gICAgICAgIG1vdmVUbyxcbiAgICAgICAgY3AweDogYmV6aWVyWzBdLngsXG4gICAgICAgIGNwMHk6IGJlemllclswXS55LFxuICAgICAgICBjcDF4OiBiZXppZXJbMV0ueCxcbiAgICAgICAgY3AxeTogYmV6aWVyWzFdLnksXG4gICAgICAgIGNwMng6IGJlemllclsyXS54LFxuICAgICAgICBjcDJ5OiBiZXppZXJbMl0ueSxcbiAgICAgICAgY3AzeDogYmV6aWVyWzNdLngsXG4gICAgICAgIGNwM3k6IGJlemllclszXS55XG4gICAgICB9O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbGluZWFyUG9pbnRzKHBvaW50cykge1xuICBjb25zdCBzcGFucyA9IFtdO1xuICBsZXQgaSA9IDA7XG4gIGxldCB4MCA9IE5hTjtcbiAgbGV0IHkwID0gTmFOO1xuICBmb3IgKGNvbnN0IHsgeDogeDEsIHk6IHkxIH0gb2YgcG9pbnRzKSB7XG4gICAgaWYgKGkgPiAwKSB7XG4gICAgICBjb25zdCBtb3ZlVG8gPSBpID09PSAxO1xuICAgICAgc3BhbnMucHVzaCh7IHR5cGU6IFwibGluZWFyXCIsIG1vdmVUbywgeDAsIHkwLCB4MSwgeTEgfSk7XG4gICAgfVxuICAgIGkgKz0gMTtcbiAgICB4MCA9IHgxO1xuICAgIHkwID0geTE7XG4gIH1cbiAgcmV0dXJuIHNwYW5zO1xufVxudmFyIGxpbmVTdGVwcyA9IHtcbiAgc3RhcnQ6IDAsXG4gIG1pZGRsZTogMC41LFxuICBlbmQ6IDFcbn07XG5mdW5jdGlvbiBzdGVwUG9pbnRzKHBvaW50cywgcG9zaXRpb24pIHtcbiAgY29uc3Qgc3BhbnMgPSBbXTtcbiAgbGV0IGkgPSAwO1xuICBsZXQgeDAgPSBOYU47XG4gIGxldCB5MCA9IE5hTjtcbiAgY29uc3QgcDAgPSB0eXBlb2YgcG9zaXRpb24gPT09IFwibnVtYmVyXCIgPyBwb3NpdGlvbiA6IGxpbmVTdGVwc1twb3NpdGlvbl07XG4gIGZvciAoY29uc3QgeyB4OiB4MSwgeTogeTEgfSBvZiBwb2ludHMpIHtcbiAgICBpZiAoaSA+IDApIHtcbiAgICAgIGNvbnN0IG1vdmVUbyA9IGkgPT09IDE7XG4gICAgICBjb25zdCBzdGVwWCA9IHgwICsgKHgxIC0geDApICogcDA7XG4gICAgICBzcGFucy5wdXNoKHsgdHlwZTogXCJzdGVwXCIsIG1vdmVUbywgeDAsIHkwLCB4MSwgeTEsIHN0ZXBYIH0pO1xuICAgIH1cbiAgICBpICs9IDE7XG4gICAgeDAgPSB4MTtcbiAgICB5MCA9IHkxO1xuICB9XG4gIHJldHVybiBzcGFucztcbn1cbnZhciBmbGF0bmVzc1JhdGlvID0gMC4wNTtcbmZ1bmN0aW9uIHNtb290aFBvaW50cyhpUG9pbnRzLCB0ZW5zaW9uKSB7XG4gIGNvbnN0IHBvaW50cyA9IEFycmF5LmlzQXJyYXkoaVBvaW50cykgPyBpUG9pbnRzIDogQXJyYXkuZnJvbShpUG9pbnRzKTtcbiAgaWYgKHBvaW50cy5sZW5ndGggPD0gMSlcbiAgICByZXR1cm4gW107XG4gIGNvbnN0IGdyYWRpZW50cyA9IHBvaW50cy5tYXAoKGMsIGkpID0+IHtcbiAgICBjb25zdCBwID0gaSA9PT0gMCA/IGMgOiBwb2ludHNbaSAtIDFdO1xuICAgIGNvbnN0IG4gPSBpID09PSBwb2ludHMubGVuZ3RoIC0gMSA/IGMgOiBwb2ludHNbaSArIDFdO1xuICAgIGNvbnN0IGlzVGVybWluYWxQb2ludCA9IGkgPT09IDAgfHwgaSA9PT0gcG9pbnRzLmxlbmd0aCAtIDE7XG4gICAgaWYgKE1hdGguc2lnbihwLnkgLSBjLnkpID09PSBNYXRoLnNpZ24obi55IC0gYy55KSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmICghaXNUZXJtaW5hbFBvaW50KSB7XG4gICAgICBjb25zdCByYW5nZTMgPSBNYXRoLmFicyhwLnkgLSBuLnkpO1xuICAgICAgY29uc3QgcHJldlJhdGlvID0gTWF0aC5hYnMoYy55IC0gcC55KSAvIHJhbmdlMztcbiAgICAgIGNvbnN0IG5leHRSYXRpbyA9IE1hdGguYWJzKGMueSAtIG4ueSkgLyByYW5nZTM7XG4gICAgICBpZiAocHJldlJhdGlvIDw9IGZsYXRuZXNzUmF0aW8gfHwgMSAtIHByZXZSYXRpbyA8PSBmbGF0bmVzc1JhdGlvIHx8IG5leHRSYXRpbyA8PSBmbGF0bmVzc1JhdGlvIHx8IDEgLSBuZXh0UmF0aW8gPD0gZmxhdG5lc3NSYXRpbykge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIChuLnkgLSBwLnkpIC8gKG4ueCAtIHAueCk7XG4gIH0pO1xuICBpZiAoZ3JhZGllbnRzWzFdID09PSAwKSB7XG4gICAgZ3JhZGllbnRzWzBdICo9IDI7XG4gIH1cbiAgaWYgKGdyYWRpZW50c1tncmFkaWVudHMubGVuZ3RoIC0gMl0gPT09IDApIHtcbiAgICBncmFkaWVudHNbZ3JhZGllbnRzLmxlbmd0aCAtIDFdICo9IDI7XG4gIH1cbiAgY29uc3Qgc3BhbnMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBwb2ludHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBjb25zdCBwcmV2ID0gcG9pbnRzW2kgLSAxXTtcbiAgICBjb25zdCBwcmV2TSA9IGdyYWRpZW50c1tpIC0gMV07XG4gICAgY29uc3QgY3VyID0gcG9pbnRzW2ldO1xuICAgIGNvbnN0IGN1ck0gPSBncmFkaWVudHNbaV07XG4gICAgY29uc3QgZHggPSBjdXIueCAtIHByZXYueDtcbiAgICBjb25zdCBkeSA9IGN1ci55IC0gcHJldi55O1xuICAgIGxldCBkY3AxeCA9IGR4ICogdGVuc2lvbiAvIDM7XG4gICAgbGV0IGRjcDF5ID0gZHggKiBwcmV2TSAqIHRlbnNpb24gLyAzO1xuICAgIGxldCBkY3AyeCA9IGR4ICogdGVuc2lvbiAvIDM7XG4gICAgbGV0IGRjcDJ5ID0gZHggKiBjdXJNICogdGVuc2lvbiAvIDM7XG4gICAgaWYgKGN1ck0gPT09IDAgJiYgTWF0aC5hYnMoZGNwMXkpID4gTWF0aC5hYnMoZHkpKSB7XG4gICAgICBkY3AxeCAqPSBNYXRoLmFicyhkeSAvIGRjcDF5KTtcbiAgICAgIGRjcDF5ID0gTWF0aC5zaWduKGRjcDF5KSAqIE1hdGguYWJzKGR5KTtcbiAgICB9XG4gICAgaWYgKHByZXZNID09PSAwICYmIE1hdGguYWJzKGRjcDJ5KSA+IE1hdGguYWJzKGR5KSkge1xuICAgICAgZGNwMnggKj0gTWF0aC5hYnMoZHkgLyBkY3AyeSk7XG4gICAgICBkY3AyeSA9IE1hdGguc2lnbihkY3AyeSkgKiBNYXRoLmFicyhkeSk7XG4gICAgfVxuICAgIHNwYW5zLnB1c2goe1xuICAgICAgdHlwZTogXCJjdWJpY1wiLFxuICAgICAgbW92ZVRvOiBpID09PSAxLFxuICAgICAgY3AweDogcHJldi54LFxuICAgICAgY3AweTogcHJldi55LFxuICAgICAgY3AxeDogcHJldi54ICsgZGNwMXgsXG4gICAgICBjcDF5OiBwcmV2LnkgKyBkY3AxeSxcbiAgICAgIGNwMng6IGN1ci54IC0gZGNwMngsXG4gICAgICBjcDJ5OiBjdXIueSAtIGRjcDJ5LFxuICAgICAgY3AzeDogY3VyLngsXG4gICAgICBjcDN5OiBjdXIueVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBzcGFucztcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9saW5lSW50ZXJwb2xhdGlvblBsb3R0aW5nLnRzXG5mdW5jdGlvbiBsZXJwMihhLCBiLCByYXRpbzIpIHtcbiAgcmV0dXJuIChiIC0gYSkgKiByYXRpbzIgKyBhO1xufVxuZnVuY3Rpb24gbGluZWFyU3VwZXJ0eXBlKHNwYW4sIHN0ZXBYKSB7XG4gIGNvbnN0IHsgeDAsIHkwLCB4MSwgeTEgfSA9IHNwYW47XG4gIGNvbnN0IG0gPSAoeTEgLSB5MCkgLyAoeDEgLSB4MCk7XG4gIGNvbnN0IHN0ZXBZID0gbSAqIChzdGVwWCAtIHgwKSArIHkwO1xuICByZXR1cm4ge1xuICAgIGxlZnRDcDF4OiB4MCxcbiAgICBsZWZ0Q3AxeTogeTAsXG4gICAgbGVmdENwMng6IHN0ZXBYLFxuICAgIGxlZnRDcDJ5OiBzdGVwWSxcbiAgICBzdGVwWCxcbiAgICBzdGVwWTA6IHN0ZXBZLFxuICAgIHN0ZXBZMTogc3RlcFksXG4gICAgcmlnaHRDcDF4OiBzdGVwWCxcbiAgICByaWdodENwMXk6IHN0ZXBZLFxuICAgIHJpZ2h0Q3AyeDogeDEsXG4gICAgcmlnaHRDcDJ5OiB5MVxuICB9O1xufVxuZnVuY3Rpb24gYmV6aWVyU3VwZXJ0eXBlKHNwYW4sIHN0ZXBYKSB7XG4gIGNvbnN0IHsgY3AweCwgY3AweSwgY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgY3AzeCwgY3AzeSB9ID0gc3BhbjtcbiAgY29uc3QgdCA9IHNvbHZlQmV6aWVyKGNwMHgsIGNwMXgsIGNwMngsIGNwM3gsIHN0ZXBYKTtcbiAgY29uc3QgW2xlZnQsIHJpZ2h0XSA9IHNwbGl0QmV6aWVyKGNwMHgsIGNwMHksIGNwMXgsIGNwMXksIGNwMngsIGNwMnksIGNwM3gsIGNwM3ksIHQpO1xuICBjb25zdCBzdGVwWSA9IGxlZnRbM10ueTtcbiAgcmV0dXJuIHtcbiAgICBsZWZ0Q3AxeDogbGVmdFsxXS54LFxuICAgIGxlZnRDcDF5OiBsZWZ0WzFdLnksXG4gICAgbGVmdENwMng6IGxlZnRbMl0ueCxcbiAgICBsZWZ0Q3AyeTogbGVmdFsyXS55LFxuICAgIHN0ZXBYLFxuICAgIHN0ZXBZMDogc3RlcFksXG4gICAgc3RlcFkxOiBzdGVwWSxcbiAgICByaWdodENwMXg6IHJpZ2h0WzFdLngsXG4gICAgcmlnaHRDcDF5OiByaWdodFsxXS55LFxuICAgIHJpZ2h0Q3AyeDogcmlnaHRbMl0ueCxcbiAgICByaWdodENwMnk6IHJpZ2h0WzJdLnlcbiAgfTtcbn1cbmZ1bmN0aW9uIHN0ZXBTdXBlcnR5cGUoc3Bhbikge1xuICBjb25zdCB7IHgwLCB5MCwgeDEsIHkxLCBzdGVwWCB9ID0gc3BhbjtcbiAgcmV0dXJuIHtcbiAgICBsZWZ0Q3AxeDogKHgwICsgc3RlcFgpIC8gMixcbiAgICBsZWZ0Q3AxeTogeTAsXG4gICAgbGVmdENwMng6ICh4MCArIHN0ZXBYKSAvIDIsXG4gICAgbGVmdENwMnk6IHkwLFxuICAgIHN0ZXBYLFxuICAgIHN0ZXBZMDogeTAsXG4gICAgc3RlcFkxOiB5MSxcbiAgICByaWdodENwMXg6IChzdGVwWCArIHgxKSAvIDIsXG4gICAgcmlnaHRDcDF5OiB5MSxcbiAgICByaWdodENwMng6IChzdGVwWCArIHgxKSAvIDIsXG4gICAgcmlnaHRDcDJ5OiB5MVxuICB9O1xufVxuZnVuY3Rpb24gc3BhblN1cGVydHlwZShzcGFuLCBzdGVwWCkge1xuICBpZiAoc3Bhbi50eXBlID09PSBcImxpbmVhclwiKSB7XG4gICAgcmV0dXJuIGxpbmVhclN1cGVydHlwZShzcGFuLCBzdGVwWCk7XG4gIH0gZWxzZSBpZiAoc3Bhbi50eXBlID09PSBcImN1YmljXCIpIHtcbiAgICByZXR1cm4gYmV6aWVyU3VwZXJ0eXBlKHNwYW4sIHN0ZXBYKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RlcFN1cGVydHlwZShzcGFuKTtcbiAgfVxufVxuZnVuY3Rpb24gcGxvdFN0YXJ0KHBhdGgsIG1vdmVUbywgeDAsIHkwLCB4MSwgeTEsIHJldmVyc2VkKSB7XG4gIHN3aXRjaCAobW92ZVRvKSB7XG4gICAgY2FzZSAxIC8qIE1vdmVUbyAqLzpcbiAgICAgIGlmIChyZXZlcnNlZCkge1xuICAgICAgICBwYXRoLm1vdmVUbyh4MSwgeTEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGF0aC5tb3ZlVG8oeDAsIHkwKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMiAvKiBMaW5lVG8gKi86XG4gICAgICBpZiAocmV2ZXJzZWQpIHtcbiAgICAgICAgcGF0aC5saW5lVG8oeDEsIHkxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdGgubGluZVRvKHgwLCB5MCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxufVxuZnVuY3Rpb24gcGxvdExpbmVhcihwYXRoLCB4MCwgeTAsIHgxLCB5MSwgcmV2ZXJzZWQpIHtcbiAgaWYgKHJldmVyc2VkKSB7XG4gICAgcGF0aC5saW5lVG8oeDAsIHkwKTtcbiAgfSBlbHNlIHtcbiAgICBwYXRoLmxpbmVUbyh4MSwgeTEpO1xuICB9XG59XG5mdW5jdGlvbiBwbG90Q3ViaWMocGF0aCwgY3AweCwgY3AweSwgY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgY3AzeCwgY3AzeSwgcmV2ZXJzZWQpIHtcbiAgaWYgKHJldmVyc2VkKSB7XG4gICAgcGF0aC5jdWJpY0N1cnZlVG8oY3AyeCwgY3AyeSwgY3AxeCwgY3AxeSwgY3AweCwgY3AweSk7XG4gIH0gZWxzZSB7XG4gICAgcGF0aC5jdWJpY0N1cnZlVG8oY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgY3AzeCwgY3AzeSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBsb3RTdGVwKHBhdGgsIHgwLCB5MCwgeDEsIHkxLCBzdGVwWCwgcmV2ZXJzZWQpIHtcbiAgaWYgKHJldmVyc2VkKSB7XG4gICAgcGF0aC5saW5lVG8oc3RlcFgsIHkxKTtcbiAgICBwYXRoLmxpbmVUbyhzdGVwWCwgeTApO1xuICAgIHBhdGgubGluZVRvKHgwLCB5MCk7XG4gIH0gZWxzZSB7XG4gICAgcGF0aC5saW5lVG8oc3RlcFgsIHkwKTtcbiAgICBwYXRoLmxpbmVUbyhzdGVwWCwgeTEpO1xuICAgIHBhdGgubGluZVRvKHgxLCB5MSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBsb3RTcGFuKHBhdGgsIHNwYW4sIG1vdmVUbywgcmV2ZXJzZWQpIHtcbiAgY29uc3QgW3N0YXJ0MiwgZW5kMl0gPSBzcGFuUmFuZ2Uoc3Bhbik7XG4gIHBsb3RTdGFydChwYXRoLCBtb3ZlVG8sIHN0YXJ0Mi54LCBzdGFydDIueSwgZW5kMi54LCBlbmQyLnksIHJldmVyc2VkKTtcbiAgc3dpdGNoIChzcGFuLnR5cGUpIHtcbiAgICBjYXNlIFwibGluZWFyXCI6XG4gICAgICBwbG90TGluZWFyKHBhdGgsIHNwYW4ueDAsIHNwYW4ueTAsIHNwYW4ueDEsIHNwYW4ueTEsIHJldmVyc2VkKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjdWJpY1wiOlxuICAgICAgcGxvdEN1YmljKFxuICAgICAgICBwYXRoLFxuICAgICAgICBzcGFuLmNwMHgsXG4gICAgICAgIHNwYW4uY3AweSxcbiAgICAgICAgc3Bhbi5jcDF4LFxuICAgICAgICBzcGFuLmNwMXksXG4gICAgICAgIHNwYW4uY3AyeCxcbiAgICAgICAgc3Bhbi5jcDJ5LFxuICAgICAgICBzcGFuLmNwM3gsXG4gICAgICAgIHNwYW4uY3AzeSxcbiAgICAgICAgcmV2ZXJzZWRcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwic3RlcFwiOlxuICAgICAgcGxvdFN0ZXAocGF0aCwgc3Bhbi54MCwgc3Bhbi55MCwgc3Bhbi54MSwgc3Bhbi55MSwgc3Bhbi5zdGVwWCwgcmV2ZXJzZWQpO1xuICAgICAgYnJlYWs7XG4gIH1cbn1cbmZ1bmN0aW9uIHBsb3RJbnRlcnBvbGF0ZWRTcGFucyhwYXRoLCBhLCBiLCByYXRpbzIsIG1vdmVUbywgcmV2ZXJzZWQpIHtcbiAgY29uc3QgW2FTdGFydCwgYUVuZF0gPSBzcGFuUmFuZ2UoYSk7XG4gIGNvbnN0IFtiU3RhcnQsIGJFbmRdID0gc3BhblJhbmdlKGIpO1xuICBjb25zdCB4MCA9IGxlcnAyKGFTdGFydC54LCBiU3RhcnQueCwgcmF0aW8yKTtcbiAgY29uc3QgeTAgPSBsZXJwMihhU3RhcnQueSwgYlN0YXJ0LnksIHJhdGlvMik7XG4gIGNvbnN0IHgxID0gbGVycDIoYUVuZC54LCBiRW5kLngsIHJhdGlvMik7XG4gIGNvbnN0IHkxID0gbGVycDIoYUVuZC55LCBiRW5kLnksIHJhdGlvMik7XG4gIHBsb3RTdGFydChwYXRoLCBtb3ZlVG8sIHgwLCB5MCwgeDEsIHkxLCByZXZlcnNlZCk7XG4gIGlmIChhLnR5cGUgPT09IFwiY3ViaWNcIiAmJiBiLnR5cGUgPT09IFwiY3ViaWNcIikge1xuICAgIGNvbnN0IGNwMXggPSBsZXJwMihhLmNwMXgsIGIuY3AxeCwgcmF0aW8yKTtcbiAgICBjb25zdCBjcDF5ID0gbGVycDIoYS5jcDF5LCBiLmNwMXksIHJhdGlvMik7XG4gICAgY29uc3QgY3AyeCA9IGxlcnAyKGEuY3AyeCwgYi5jcDJ4LCByYXRpbzIpO1xuICAgIGNvbnN0IGNwMnkgPSBsZXJwMihhLmNwMnksIGIuY3AyeSwgcmF0aW8yKTtcbiAgICBwbG90Q3ViaWMocGF0aCwgeDAsIHkwLCBjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCB4MSwgeTEsIHJldmVyc2VkKTtcbiAgfSBlbHNlIGlmIChhLnR5cGUgPT09IFwic3RlcFwiICYmIGIudHlwZSA9PT0gXCJzdGVwXCIpIHtcbiAgICBjb25zdCBzdGVwWCA9IGxlcnAyKGEuc3RlcFgsIGIuc3RlcFgsIHJhdGlvMik7XG4gICAgcGxvdFN0ZXAocGF0aCwgeDAsIHkwLCB4MSwgeTEsIHN0ZXBYLCByZXZlcnNlZCk7XG4gIH0gZWxzZSBpZiAoYS50eXBlID09PSBcImxpbmVhclwiICYmIGIudHlwZSA9PT0gXCJsaW5lYXJcIikge1xuICAgIHBsb3RMaW5lYXIocGF0aCwgeDAsIHkwLCB4MSwgeTEsIHJldmVyc2VkKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgZGVmYXVsdFN0ZXBYO1xuICAgIGlmIChhLnR5cGUgPT09IFwic3RlcFwiKSB7XG4gICAgICBkZWZhdWx0U3RlcFggPSBhLnN0ZXBYO1xuICAgIH0gZWxzZSBpZiAoYi50eXBlID09PSBcInN0ZXBcIikge1xuICAgICAgZGVmYXVsdFN0ZXBYID0gYi5zdGVwWDtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVmYXVsdFN0ZXBYID0gKHgwICsgeDEpIC8gMjtcbiAgICB9XG4gICAgY29uc3QgYXMgPSBzcGFuU3VwZXJ0eXBlKGEsIGRlZmF1bHRTdGVwWCk7XG4gICAgY29uc3QgYnMgPSBzcGFuU3VwZXJ0eXBlKGIsIGRlZmF1bHRTdGVwWCk7XG4gICAgY29uc3QgbGVmdENwMXggPSBsZXJwMihhcy5sZWZ0Q3AxeCwgYnMubGVmdENwMXgsIHJhdGlvMik7XG4gICAgY29uc3QgbGVmdENwMXkgPSBsZXJwMihhcy5sZWZ0Q3AxeSwgYnMubGVmdENwMXksIHJhdGlvMik7XG4gICAgY29uc3QgbGVmdENwMnggPSBsZXJwMihhcy5sZWZ0Q3AyeCwgYnMubGVmdENwMngsIHJhdGlvMik7XG4gICAgY29uc3QgbGVmdENwMnkgPSBsZXJwMihhcy5sZWZ0Q3AyeSwgYnMubGVmdENwMnksIHJhdGlvMik7XG4gICAgY29uc3Qgc3RlcFggPSBsZXJwMihhcy5zdGVwWCwgYnMuc3RlcFgsIHJhdGlvMik7XG4gICAgY29uc3Qgc3RlcFkwID0gbGVycDIoYXMuc3RlcFkwLCBicy5zdGVwWTAsIHJhdGlvMik7XG4gICAgY29uc3Qgc3RlcFkxID0gbGVycDIoYXMuc3RlcFkxLCBicy5zdGVwWTEsIHJhdGlvMik7XG4gICAgY29uc3QgcmlnaHRDcDF4ID0gbGVycDIoYXMucmlnaHRDcDF4LCBicy5yaWdodENwMXgsIHJhdGlvMik7XG4gICAgY29uc3QgcmlnaHRDcDF5ID0gbGVycDIoYXMucmlnaHRDcDF5LCBicy5yaWdodENwMXksIHJhdGlvMik7XG4gICAgY29uc3QgcmlnaHRDcDJ4ID0gbGVycDIoYXMucmlnaHRDcDJ4LCBicy5yaWdodENwMngsIHJhdGlvMik7XG4gICAgY29uc3QgcmlnaHRDcDJ5ID0gbGVycDIoYXMucmlnaHRDcDJ5LCBicy5yaWdodENwMnksIHJhdGlvMik7XG4gICAgaWYgKHJldmVyc2VkKSB7XG4gICAgICBwYXRoLmN1YmljQ3VydmVUbyhyaWdodENwMngsIHJpZ2h0Q3AyeSwgcmlnaHRDcDF4LCByaWdodENwMXksIHN0ZXBYLCBzdGVwWTEpO1xuICAgICAgcGF0aC5saW5lVG8oc3RlcFgsIHN0ZXBZMCk7XG4gICAgICBwYXRoLmN1YmljQ3VydmVUbyhsZWZ0Q3AyeCwgbGVmdENwMnksIGxlZnRDcDF4LCBsZWZ0Q3AxeSwgeDAsIHkwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aC5jdWJpY0N1cnZlVG8obGVmdENwMXgsIGxlZnRDcDF5LCBsZWZ0Q3AyeCwgbGVmdENwMnksIHN0ZXBYLCBzdGVwWTApO1xuICAgICAgcGF0aC5saW5lVG8oc3RlcFgsIHN0ZXBZMSk7XG4gICAgICBwYXRoLmN1YmljQ3VydmVUbyhyaWdodENwMXgsIHJpZ2h0Q3AxeSwgcmlnaHRDcDJ4LCByaWdodENwMnksIHgxLCB5MSk7XG4gICAgfVxuICB9XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vbWFya2VyVXRpbC50c1xuZnVuY3Rpb24gbWFya2VyRmFkZUluQW5pbWF0aW9uKHsgaWQgfSwgYW5pbWF0aW9uTWFuYWdlciwgc3RhdHVzLCAuLi5tYXJrZXJTZWxlY3Rpb25zKSB7XG4gIGNvbnN0IHBhcmFtcyA9IHsgcGhhc2U6IHN0YXR1cyA/IE5PREVfVVBEQVRFX1NUQVRFX1RPX1BIQVNFX01BUFBJTkdbc3RhdHVzXSA6IFwidHJhaWxpbmdcIiB9O1xuICBzdGF0aWNGcm9tVG9Nb3Rpb24oaWQsIFwibWFya2Vyc1wiLCBhbmltYXRpb25NYW5hZ2VyLCBtYXJrZXJTZWxlY3Rpb25zLCB7IG9wYWNpdHk6IDAgfSwgeyBvcGFjaXR5OiAxIH0sIHBhcmFtcyk7XG4gIG1hcmtlclNlbGVjdGlvbnMuZm9yRWFjaCgocykgPT4gcy5jbGVhbnVwKCkpO1xufVxuZnVuY3Rpb24gbWFya2VyU2NhbGVJbkFuaW1hdGlvbih7IGlkIH0sIGFuaW1hdGlvbk1hbmFnZXIsIC4uLm1hcmtlclNlbGVjdGlvbnMpIHtcbiAgc3RhdGljRnJvbVRvTW90aW9uKFxuICAgIGlkLFxuICAgIFwibWFya2Vyc1wiLFxuICAgIGFuaW1hdGlvbk1hbmFnZXIsXG4gICAgbWFya2VyU2VsZWN0aW9ucyxcbiAgICB7IHNjYWxpbmdYOiAwLCBzY2FsaW5nWTogMCB9LFxuICAgIHsgc2NhbGluZ1g6IDEsIHNjYWxpbmdZOiAxIH0sXG4gICAgeyBwaGFzZTogXCJpbml0aWFsXCIgfVxuICApO1xuICBtYXJrZXJTZWxlY3Rpb25zLmZvckVhY2goKHMpID0+IHMuY2xlYW51cCgpKTtcbn1cbmZ1bmN0aW9uIG1hcmtlclN3aXBlU2NhbGVJbkFuaW1hdGlvbih7IGlkLCBub2RlRGF0YURlcGVuZGVuY2llcyB9LCBhbmltYXRpb25NYW5hZ2VyLCAuLi5tYXJrZXJTZWxlY3Rpb25zKSB7XG4gIGNvbnN0IHNlcmllc1dpZHRoID0gbm9kZURhdGFEZXBlbmRlbmNpZXMuc2VyaWVzUmVjdFdpZHRoO1xuICBjb25zdCBmcm9tRm4gPSAoXywgZGF0dW0pID0+IHtcbiAgICBjb25zdCB4ID0gZGF0dW0ubWlkUG9pbnQ/LnggPz8gc2VyaWVzV2lkdGg7XG4gICAgbGV0IGRlbGF5ID0gY2xhbXAoMCwgaW52ZXJzZUVhc2VPdXQoeCAvIHNlcmllc1dpZHRoKSwgMSk7XG4gICAgaWYgKGlzTmFOKGRlbGF5KSkge1xuICAgICAgZGVsYXkgPSAwO1xuICAgIH1cbiAgICByZXR1cm4geyBzY2FsaW5nWDogMCwgc2NhbGluZ1k6IDAsIGRlbGF5LCBkdXJhdGlvbjogUVVJQ0tfVFJBTlNJVElPTiwgcGhhc2U6IFwiaW5pdGlhbFwiIH07XG4gIH07XG4gIGNvbnN0IHRvRm4gPSAoKSA9PiB7XG4gICAgcmV0dXJuIHsgc2NhbGluZ1g6IDEsIHNjYWxpbmdZOiAxIH07XG4gIH07XG4gIGZyb21Ub01vdGlvbihpZCwgXCJtYXJrZXJzXCIsIGFuaW1hdGlvbk1hbmFnZXIsIG1hcmtlclNlbGVjdGlvbnMsIHsgZnJvbUZuLCB0b0ZuIH0pO1xufVxuZnVuY3Rpb24gcmVzZXRNYXJrZXJGbihfbm9kZSkge1xuICByZXR1cm4geyBvcGFjaXR5OiAxLCBzY2FsaW5nWDogMSwgc2NhbGluZ1k6IDEgfTtcbn1cbmZ1bmN0aW9uIHJlc2V0TWFya2VyUG9zaXRpb25Gbihfbm9kZSwgZGF0dW0pIHtcbiAgcmV0dXJuIHtcbiAgICB0cmFuc2xhdGlvblg6IGRhdHVtLnBvaW50Py54ID8/IE5hTixcbiAgICB0cmFuc2xhdGlvblk6IGRhdHVtLnBvaW50Py55ID8/IE5hTlxuICB9O1xufVxuZnVuY3Rpb24gcHJlcGFyZU1hcmtlckFuaW1hdGlvbihwYWlyTWFwLCBwYXJlbnRTdGF0dXMpIHtcbiAgY29uc3QgcmVhZEZpcnN0UGFpciA9ICh4VmFsdWUsIHR5cGUpID0+IHtcbiAgICBjb25zdCB2YWwgPSBwYWlyTWFwW3R5cGVdW3hWYWx1ZV07XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsKSA/IHZhbFswXSA6IHZhbDtcbiAgfTtcbiAgY29uc3QgbWFya2VyU3RhdHVzID0gKGRhdHVtKSA9PiB7XG4gICAgY29uc3QgeyB4VmFsdWUgfSA9IGRhdHVtO1xuICAgIGlmIChwYWlyTWFwLm1vdmVkW3hWYWx1ZV0pIHtcbiAgICAgIHJldHVybiB7IHBvaW50OiByZWFkRmlyc3RQYWlyKHhWYWx1ZSwgXCJtb3ZlZFwiKSwgc3RhdHVzOiBcInVwZGF0ZWRcIiB9O1xuICAgIH0gZWxzZSBpZiAocGFpck1hcC5yZW1vdmVkW3hWYWx1ZV0pIHtcbiAgICAgIHJldHVybiB7IHBvaW50OiByZWFkRmlyc3RQYWlyKHhWYWx1ZSwgXCJyZW1vdmVkXCIpLCBzdGF0dXM6IFwicmVtb3ZlZFwiIH07XG4gICAgfSBlbHNlIGlmIChwYWlyTWFwLmFkZGVkW3hWYWx1ZV0pIHtcbiAgICAgIHJldHVybiB7IHBvaW50OiByZWFkRmlyc3RQYWlyKHhWYWx1ZSwgXCJhZGRlZFwiKSwgc3RhdHVzOiBcImFkZGVkXCIgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhdHVzOiBcInVua25vd25cIiB9O1xuICB9O1xuICBjb25zdCBmcm9tRm4gPSAobWFya2VyLCBkYXR1bSkgPT4ge1xuICAgIGNvbnN0IHsgc3RhdHVzLCBwb2ludCB9ID0gbWFya2VyU3RhdHVzKGRhdHVtKTtcbiAgICBpZiAoc3RhdHVzID09PSBcInVua25vd25cIilcbiAgICAgIHJldHVybiB7IG9wYWNpdHk6IDAgfTtcbiAgICBjb25zdCBkZWZhdWx0cyA9IHtcbiAgICAgIHRyYW5zbGF0aW9uWDogcG9pbnQ/LmZyb20/LnggPz8gbWFya2VyLnRyYW5zbGF0aW9uWCxcbiAgICAgIHRyYW5zbGF0aW9uWTogcG9pbnQ/LmZyb20/LnkgPz8gbWFya2VyLnRyYW5zbGF0aW9uWSxcbiAgICAgIG9wYWNpdHk6IG1hcmtlci5vcGFjaXR5LFxuICAgICAgcGhhc2U6IE5PREVfVVBEQVRFX1NUQVRFX1RPX1BIQVNFX01BUFBJTkdbc3RhdHVzXVxuICAgIH07XG4gICAgaWYgKHBhcmVudFN0YXR1cyA9PT0gXCJhZGRlZFwiKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5kZWZhdWx0cyxcbiAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgdHJhbnNsYXRpb25YOiBwb2ludD8udG8/LngsXG4gICAgICAgIHRyYW5zbGF0aW9uWTogcG9pbnQ/LnRvPy55LFxuICAgICAgICBwaGFzZTogTk9ERV9VUERBVEVfU1RBVEVfVE9fUEhBU0VfTUFQUElOR1tcImFkZGVkXCJdXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoc3RhdHVzID09PSBcImFkZGVkXCIpIHtcbiAgICAgIGRlZmF1bHRzLm9wYWNpdHkgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdHM7XG4gIH07XG4gIGNvbnN0IHRvRm4gPSAoX21hcmtlciwgZGF0dW0pID0+IHtcbiAgICBjb25zdCB7IHN0YXR1cywgcG9pbnQgfSA9IG1hcmtlclN0YXR1cyhkYXR1bSk7XG4gICAgaWYgKHN0YXR1cyA9PT0gXCJ1bmtub3duXCIpXG4gICAgICByZXR1cm4geyBvcGFjaXR5OiAwIH07XG4gICAgY29uc3QgZGVmYXVsdHMgPSB7XG4gICAgICB0cmFuc2xhdGlvblg6IGRhdHVtLnBvaW50LngsXG4gICAgICB0cmFuc2xhdGlvblk6IGRhdHVtLnBvaW50LnksXG4gICAgICBvcGFjaXR5OiAxLFxuICAgICAgcGhhc2U6IE5PREVfVVBEQVRFX1NUQVRFX1RPX1BIQVNFX01BUFBJTkdbc3RhdHVzXVxuICAgIH07XG4gICAgaWYgKHN0YXR1cyA9PT0gXCJyZW1vdmVkXCIgfHwgcGFyZW50U3RhdHVzID09PSBcInJlbW92ZWRcIikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZGVmYXVsdHMsXG4gICAgICAgIHRyYW5zbGF0aW9uWDogcG9pbnQ/LnRvPy54LFxuICAgICAgICB0cmFuc2xhdGlvblk6IHBvaW50Py50bz8ueSxcbiAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgcGhhc2U6IE5PREVfVVBEQVRFX1NUQVRFX1RPX1BIQVNFX01BUFBJTkdbXCJyZW1vdmVkXCJdXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdHM7XG4gIH07XG4gIHJldHVybiB7IGZyb21GbiwgdG9GbiB9O1xufVxuZnVuY3Rpb24gY29tcHV0ZU1hcmtlckZvY3VzQm91bmRzKHNlcmllcywgeyBkYXR1bUluZGV4IH0pIHtcbiAgY29uc3Qgbm9kZURhdGEgPSBzZXJpZXMuZ2V0Tm9kZURhdGEoKTtcbiAgaWYgKG5vZGVEYXRhID09PSB2b2lkIDApXG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgY29uc3QgZGF0dW0gPSBub2RlRGF0YVtkYXR1bUluZGV4XTtcbiAgY29uc3QgeyBwb2ludCB9ID0gZGF0dW07XG4gIGlmIChkYXR1bSA9PSBudWxsIHx8IHBvaW50ID09IG51bGwpXG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgY29uc3Qgc2l6ZSA9IHBvaW50LmZvY3VzU2l6ZSA/PyBzZXJpZXMuZ2V0Rm9ybWF0dGVkTWFya2VyU3R5bGUoZGF0dW0pLnNpemU7XG4gIGNvbnN0IHJhZGl1cyA9IHNpemUgLyAyO1xuICBjb25zdCB4ID0gZGF0dW0ucG9pbnQueCAtIHJhZGl1cztcbiAgY29uc3QgeSA9IGRhdHVtLnBvaW50LnkgLSByYWRpdXM7XG4gIHJldHVybiBUcmFuc2Zvcm1hYmxlLnRvQ2FudmFzKHNlcmllcy5jb250ZW50R3JvdXAsIG5ldyBCQm94KHgsIHksIHNpemUsIHNpemUpKTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9saW5lUGxvdHRlci50c1xuZnVuY3Rpb24gcGxvdExpbmVhclBvaW50cyhwYXRoLCBwb2ludHMsIGNvbnRpbnVlUGF0aCkge1xuICBsZXQgZGlkTW92ZSA9IGNvbnRpbnVlUGF0aDtcbiAgZm9yIChjb25zdCB7IHgsIHkgfSBvZiBwb2ludHMpIHtcbiAgICBpZiAoZGlkTW92ZSkge1xuICAgICAgcGF0aC5saW5lVG8oeCwgeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGgubW92ZVRvKHgsIHkpO1xuICAgICAgZGlkTW92ZSA9IHRydWU7XG4gICAgfVxuICB9XG59XG52YXIgZmxhdG5lc3NSYXRpbzIgPSAwLjA1O1xuZnVuY3Rpb24gcGxvdFNtb290aFBvaW50cyhwYXRoLCBpUG9pbnRzLCB0ZW5zaW9uLCBjb250aW51ZVBhdGgpIHtcbiAgY29uc3QgcG9pbnRzID0gQXJyYXkuaXNBcnJheShpUG9pbnRzKSA/IGlQb2ludHMgOiBBcnJheS5mcm9tKGlQb2ludHMpO1xuICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm47XG4gIGlmIChjb250aW51ZVBhdGgpIHtcbiAgICBwYXRoLmxpbmVUbyhwb2ludHNbMF0ueCwgcG9pbnRzWzBdLnkpO1xuICB9IGVsc2Uge1xuICAgIHBhdGgubW92ZVRvKHBvaW50c1swXS54LCBwb2ludHNbMF0ueSk7XG4gIH1cbiAgaWYgKHBvaW50cy5sZW5ndGggPD0gMSlcbiAgICByZXR1cm47XG4gIGNvbnN0IGdyYWRpZW50cyA9IHBvaW50cy5tYXAoKGMsIGkpID0+IHtcbiAgICBjb25zdCBwID0gaSA9PT0gMCA/IGMgOiBwb2ludHNbaSAtIDFdO1xuICAgIGNvbnN0IG4gPSBpID09PSBwb2ludHMubGVuZ3RoIC0gMSA/IGMgOiBwb2ludHNbaSArIDFdO1xuICAgIGNvbnN0IGlzVGVybWluYWxQb2ludCA9IGkgPT09IDAgfHwgaSA9PT0gcG9pbnRzLmxlbmd0aCAtIDE7XG4gICAgaWYgKE1hdGguc2lnbihwLnkgLSBjLnkpID09PSBNYXRoLnNpZ24obi55IC0gYy55KSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmICghaXNUZXJtaW5hbFBvaW50KSB7XG4gICAgICBjb25zdCByYW5nZTMgPSBNYXRoLmFicyhwLnkgLSBuLnkpO1xuICAgICAgY29uc3QgcHJldlJhdGlvID0gTWF0aC5hYnMoYy55IC0gcC55KSAvIHJhbmdlMztcbiAgICAgIGNvbnN0IG5leHRSYXRpbyA9IE1hdGguYWJzKGMueSAtIG4ueSkgLyByYW5nZTM7XG4gICAgICBpZiAocHJldlJhdGlvIDw9IGZsYXRuZXNzUmF0aW8yIHx8IDEgLSBwcmV2UmF0aW8gPD0gZmxhdG5lc3NSYXRpbzIgfHwgbmV4dFJhdGlvIDw9IGZsYXRuZXNzUmF0aW8yIHx8IDEgLSBuZXh0UmF0aW8gPD0gZmxhdG5lc3NSYXRpbzIpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAobi55IC0gcC55KSAvIChuLnggLSBwLngpO1xuICB9KTtcbiAgaWYgKGdyYWRpZW50c1sxXSA9PT0gMCkge1xuICAgIGdyYWRpZW50c1swXSAqPSAyO1xuICB9XG4gIGlmIChncmFkaWVudHNbZ3JhZGllbnRzLmxlbmd0aCAtIDJdID09PSAwKSB7XG4gICAgZ3JhZGllbnRzW2dyYWRpZW50cy5sZW5ndGggLSAxXSAqPSAyO1xuICB9XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgY29uc3QgcHJldiA9IHBvaW50c1tpIC0gMV07XG4gICAgY29uc3QgcHJldk0gPSBncmFkaWVudHNbaSAtIDFdO1xuICAgIGNvbnN0IGN1ciA9IHBvaW50c1tpXTtcbiAgICBjb25zdCBjdXJNID0gZ3JhZGllbnRzW2ldO1xuICAgIGNvbnN0IGR4ID0gY3VyLnggLSBwcmV2Lng7XG4gICAgY29uc3QgZHkgPSBjdXIueSAtIHByZXYueTtcbiAgICBsZXQgZGNwMXggPSBkeCAqIHRlbnNpb24gLyAzO1xuICAgIGxldCBkY3AxeSA9IGR4ICogcHJldk0gKiB0ZW5zaW9uIC8gMztcbiAgICBsZXQgZGNwMnggPSBkeCAqIHRlbnNpb24gLyAzO1xuICAgIGxldCBkY3AyeSA9IGR4ICogY3VyTSAqIHRlbnNpb24gLyAzO1xuICAgIGlmIChjdXJNID09PSAwICYmIE1hdGguYWJzKGRjcDF5KSA+IE1hdGguYWJzKGR5KSkge1xuICAgICAgZGNwMXggKj0gTWF0aC5hYnMoZHkgLyBkY3AxeSk7XG4gICAgICBkY3AxeSA9IE1hdGguc2lnbihkY3AxeSkgKiBNYXRoLmFicyhkeSk7XG4gICAgfVxuICAgIGlmIChwcmV2TSA9PT0gMCAmJiBNYXRoLmFicyhkY3AyeSkgPiBNYXRoLmFicyhkeSkpIHtcbiAgICAgIGRjcDJ4ICo9IE1hdGguYWJzKGR5IC8gZGNwMnkpO1xuICAgICAgZGNwMnkgPSBNYXRoLnNpZ24oZGNwMnkpICogTWF0aC5hYnMoZHkpO1xuICAgIH1cbiAgICBwYXRoLmN1YmljQ3VydmVUbyhwcmV2LnggKyBkY3AxeCwgcHJldi55ICsgZGNwMXksIGN1ci54IC0gZGNwMngsIGN1ci55IC0gZGNwMnksIGN1ci54LCBjdXIueSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBsb3RTdGVwUG9pbnRzKHBhdGgsIHBvaW50cywgYWxpZ24sIGNvbnRpbnVlUGF0aCkge1xuICBsZXQgbGFzdFBvaW50O1xuICBmb3IgKGNvbnN0IHBvaW50IG9mIHBvaW50cykge1xuICAgIGlmIChsYXN0UG9pbnQgIT0gbnVsbCkge1xuICAgICAgY29uc3QgZGlyZWN0aW9uYWxBbGlnbiA9IGxhc3RQb2ludC54IDwgcG9pbnQueCA/IGFsaWduIDogMSAtIGFsaWduO1xuICAgICAgY29uc3QgeCA9IChwb2ludC54IC0gbGFzdFBvaW50LngpICogZGlyZWN0aW9uYWxBbGlnbiArIGxhc3RQb2ludC54O1xuICAgICAgcGF0aC5saW5lVG8oeCwgbGFzdFBvaW50Py55ID8/IHBvaW50LnkpO1xuICAgICAgcGF0aC5saW5lVG8oeCwgcG9pbnQueSk7XG4gICAgICBwYXRoLmxpbmVUbyhwb2ludC54LCBwb2ludC55KTtcbiAgICB9IGVsc2UgaWYgKGNvbnRpbnVlUGF0aCkge1xuICAgICAgcGF0aC5saW5lVG8ocG9pbnQueCwgcG9pbnQueSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGgubW92ZVRvKHBvaW50LngsIHBvaW50LnkpO1xuICAgIH1cbiAgICBsYXN0UG9pbnQgPSBwb2ludDtcbiAgfVxufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL3BhdGhVdGlsLnRzXG5mdW5jdGlvbiBtaW5NYXgobm9kZURhdGEpIHtcbiAgcmV0dXJuIG5vZGVEYXRhLnJlZHVjZShcbiAgICAoeyBtaW4sIG1heCB9LCBub2RlKSA9PiB7XG4gICAgICBpZiAobWluID09IG51bGwgfHwgbWluLnBvaW50LnggPiBub2RlLnBvaW50LngpIHtcbiAgICAgICAgbWluID0gbm9kZTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXggPT0gbnVsbCB8fCBtYXgucG9pbnQueCA8IG5vZGUucG9pbnQueCkge1xuICAgICAgICBtYXggPSBub2RlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgbWluLCBtYXggfTtcbiAgICB9LFxuICAgIHt9XG4gICk7XG59XG5mdW5jdGlvbiBpbnRlcnNlY3Rpb25PbkxpbmUoYSwgYiwgdGFyZ2V0WCkge1xuICBjb25zdCBtID0gKGIueSAtIGEueSkgLyAoYi54IC0gYS54KTtcbiAgY29uc3QgeSA9ICh0YXJnZXRYIC0gYS54KSAqIG0gKyBhLnk7XG4gIHJldHVybiB7IHg6IHRhcmdldFgsIHkgfTtcbn1cbmZ1bmN0aW9uIGJhY2tmaWxsUGF0aFBvaW50KHJlc3VsdHMsIHByb2Nlc3MsIHNraXAsIHByb2Nlc3NGbikge1xuICBsZXQgcHJldk1hcmtlcklkeCA9IC0xLCBuZXh0TWFya2VySWR4ID0gMDtcbiAgY29uc3QgdG9Qcm9jZXNzID0gW107XG4gIHdoaWxlIChuZXh0TWFya2VySWR4IDwgcmVzdWx0cy5sZW5ndGgpIHtcbiAgICBpZiAocmVzdWx0c1tuZXh0TWFya2VySWR4XS5jaGFuZ2UgPT09IHByb2Nlc3MpIHtcbiAgICAgIHRvUHJvY2Vzcy5wdXNoKHJlc3VsdHNbbmV4dE1hcmtlcklkeF0pO1xuICAgICAgbmV4dE1hcmtlcklkeCsrO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChyZXN1bHRzW25leHRNYXJrZXJJZHhdLmNoYW5nZSA9PT0gc2tpcCkge1xuICAgICAgbmV4dE1hcmtlcklkeCsrO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICh0b1Byb2Nlc3MubGVuZ3RoID4gMCkge1xuICAgICAgcHJvY2Vzc0ZuKHRvUHJvY2VzcywgcHJldk1hcmtlcklkeCwgbmV4dE1hcmtlcklkeCk7XG4gICAgICB0b1Byb2Nlc3MubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgcHJldk1hcmtlcklkeCA9IG5leHRNYXJrZXJJZHg7XG4gICAgbmV4dE1hcmtlcklkeCsrO1xuICB9XG4gIGlmICh0b1Byb2Nlc3MubGVuZ3RoID4gMCkge1xuICAgIHByb2Nlc3NGbih0b1Byb2Nlc3MsIHByZXZNYXJrZXJJZHgsIG5leHRNYXJrZXJJZHgpO1xuICB9XG59XG5mdW5jdGlvbiBiYWNrZmlsbFBhdGhQb2ludERhdGEocmVzdWx0LCBzcGxpdE1vZGUpIHtcbiAgYmFja2ZpbGxQYXRoUG9pbnQocmVzdWx0LCBcIm91dFwiLCBcImluXCIsICh0b1Byb2Nlc3MsIHNJZHgsIGVJZHgpID0+IHtcbiAgICBpZiAoc0lkeCA9PT0gLTEgJiYgcmVzdWx0W2VJZHhdKSB7XG4gICAgICB0b1Byb2Nlc3MuZm9yRWFjaCgoZCkgPT4gZC50byA9IHJlc3VsdFtlSWR4XS5mcm9tKTtcbiAgICB9IGVsc2UgaWYgKGVJZHggPT09IHJlc3VsdC5sZW5ndGggJiYgcmVzdWx0W3NJZHhdKSB7XG4gICAgICB0b1Byb2Nlc3MuZm9yRWFjaCgoZCkgPT4gZC50byA9IHJlc3VsdFtzSWR4XS5mcm9tKTtcbiAgICB9IGVsc2UgaWYgKHNwbGl0TW9kZSA9PT0gXCJpbnRlcnNlY3RcIiAmJiByZXN1bHRbc0lkeF0/LmZyb20gJiYgcmVzdWx0W2VJZHhdPy5mcm9tKSB7XG4gICAgICB0b1Byb2Nlc3MuZm9yRWFjaCgoZCkgPT4gZC50byA9IGludGVyc2VjdGlvbk9uTGluZShyZXN1bHRbc0lkeF0uZnJvbSwgcmVzdWx0W2VJZHhdLmZyb20sIGQuZnJvbS54KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvUHJvY2Vzcy5mb3JFYWNoKChkKSA9PiBkLnRvID0gZC5mcm9tKTtcbiAgICB9XG4gIH0pO1xuICBiYWNrZmlsbFBhdGhQb2ludChyZXN1bHQsIFwiaW5cIiwgXCJvdXRcIiwgKHRvUHJvY2Vzcywgc0lkeCwgZUlkeCkgPT4ge1xuICAgIGlmIChzSWR4ID09PSAtMSAmJiByZXN1bHRbZUlkeF0pIHtcbiAgICAgIHRvUHJvY2Vzcy5mb3JFYWNoKChkKSA9PiBkLmZyb20gPSByZXN1bHRbZUlkeF0udG8pO1xuICAgIH0gZWxzZSBpZiAoZUlkeCA9PT0gcmVzdWx0Lmxlbmd0aCAmJiByZXN1bHRbc0lkeF0pIHtcbiAgICAgIHRvUHJvY2Vzcy5mb3JFYWNoKChkKSA9PiBkLmZyb20gPSByZXN1bHRbc0lkeF0udG8pO1xuICAgIH0gZWxzZSBpZiAoc3BsaXRNb2RlID09PSBcImludGVyc2VjdFwiICYmIHJlc3VsdFtzSWR4XT8udG8gJiYgcmVzdWx0W2VJZHhdPy50bykge1xuICAgICAgdG9Qcm9jZXNzLmZvckVhY2goKGQpID0+IGQuZnJvbSA9IGludGVyc2VjdGlvbk9uTGluZShyZXN1bHRbc0lkeF0udG8sIHJlc3VsdFtlSWR4XS50bywgZC50by54KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvUHJvY2Vzcy5mb3JFYWNoKChkKSA9PiBkLmZyb20gPSBkLnRvKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlUG9pbnQoZnJvbTMsIHRvLCByYXRpbzIpIHtcbiAgY29uc3QgeDEgPSBpc05hTihmcm9tMy54KSA/IHRvLnggOiBmcm9tMy54O1xuICBjb25zdCB5MSA9IGlzTmFOKGZyb20zLnkpID8gdG8ueSA6IGZyb20zLnk7XG4gIGNvbnN0IHhkID0gdG8ueCAtIGZyb20zLng7XG4gIGNvbnN0IHlkID0gdG8ueSAtIGZyb20zLnk7XG4gIGNvbnN0IHhyID0gaXNOYU4oeGQpID8gMCA6IHhkICogcmF0aW8yO1xuICBjb25zdCB5ciA9IGlzTmFOKHlkKSA/IDAgOiB5ZCAqIHJhdGlvMjtcbiAgcmV0dXJuIHtcbiAgICB4OiB4MSArIHhyLFxuICAgIHk6IHkxICsgeXJcbiAgfTtcbn1cbnZhciBsaW5lU3RlcHMyID0ge1xuICBzdGFydDogMCxcbiAgbWlkZGxlOiAwLjUsXG4gIGVuZDogMVxufTtcbmZ1bmN0aW9uIHBsb3RQYXRoKHBvaW50cywgcGF0aCwgaW50ZXJwb2xhdGlvbiwgY29udGludWVQYXRoID0gZmFsc2UpIHtcbiAgY29uc3QgeyBwYXRoOiBsaW5lUGF0aCB9ID0gcGF0aDtcbiAgaWYgKGludGVycG9sYXRpb24/LnR5cGUgPT09IFwic21vb3RoXCIpIHtcbiAgICBwbG90U21vb3RoUG9pbnRzKGxpbmVQYXRoLCBwb2ludHMsIGludGVycG9sYXRpb24udGVuc2lvbiA/PyAxLCBjb250aW51ZVBhdGgpO1xuICB9IGVsc2UgaWYgKGludGVycG9sYXRpb24/LnR5cGUgPT09IFwic3RlcFwiKSB7XG4gICAgcGxvdFN0ZXBQb2ludHMobGluZVBhdGgsIHBvaW50cywgbGluZVN0ZXBzMltpbnRlcnBvbGF0aW9uLnBvc2l0aW9uID8/IFwiZW5kXCJdLCBjb250aW51ZVBhdGgpO1xuICB9IGVsc2Uge1xuICAgIHBsb3RMaW5lYXJQb2ludHMobGluZVBhdGgsIHBvaW50cywgY29udGludWVQYXRoKTtcbiAgfVxufVxuZnVuY3Rpb24gc3BsaXRQYWlyRGF0YShwYWlyRGF0YSwgcmF0aW9zKSB7XG4gIGxldCBwcmV2aW91c1RvO1xuICBsZXQgcG9pbnRzID0gdm9pZCAwO1xuICBjb25zdCBvdXQgPSBbXTtcbiAgY29uc3QgZmx1c2hDdXJyZW50ID0gKCkgPT4ge1xuICAgIGlmIChwb2ludHMgIT0gbnVsbCkge1xuICAgICAgb3V0LnB1c2gocG9pbnRzKTtcbiAgICAgIHBvaW50cyA9IHZvaWQgMDtcbiAgICB9XG4gIH07XG4gIGZvciAoY29uc3QgZGF0YSBvZiBwYWlyRGF0YSkge1xuICAgIGNvbnN0IHsgZnJvbTogZnJvbTMsIHRvIH0gPSBkYXRhO1xuICAgIGNvbnN0IHJhdGlvMiA9IHJhdGlvc1tkYXRhLmNoYW5nZV07XG4gICAgaWYgKHJhdGlvMiA9PSBudWxsIHx8IGZyb20zID09IG51bGwgfHwgdG8gPT0gbnVsbClcbiAgICAgIGNvbnRpbnVlO1xuICAgIGNvbnN0IHBvaW50ID0gY2FsY3VsYXRlUG9pbnQoZnJvbTMsIHRvLCByYXRpbzIpO1xuICAgIGlmIChkYXRhLm1vdmVUbyA9PT0gZmFsc2UpIHtcbiAgICAgIHBvaW50cyA/PyAocG9pbnRzID0gW10pO1xuICAgICAgcG9pbnRzLnB1c2gocG9pbnQpO1xuICAgIH0gZWxzZSBpZiAoZGF0YS5tb3ZlVG8gPT09IHRydWUgfHwgIXByZXZpb3VzVG8pIHtcbiAgICAgIGZsdXNoQ3VycmVudCgpO1xuICAgICAgcG9pbnRzID0gW3BvaW50XTtcbiAgICB9IGVsc2UgaWYgKHByZXZpb3VzVG8pIHtcbiAgICAgIGNvbnN0IG1vdmVUb1JhdGlvID0gZGF0YS5tb3ZlVG8gPT09IFwiaW5cIiA/IHJhdGlvMiA6IDEgLSByYXRpbzI7XG4gICAgICBjb25zdCB7IHg6IG1pZFBvaW50WCwgeTogbWlkUG9pbnRZIH0gPSBjYWxjdWxhdGVQb2ludChwcmV2aW91c1RvLCBwb2ludCwgbW92ZVRvUmF0aW8pO1xuICAgICAgcG9pbnRzID8/IChwb2ludHMgPSBbXSk7XG4gICAgICBwb2ludHMucHVzaCh7IHg6IG1pZFBvaW50WCwgeTogbWlkUG9pbnRZIH0pO1xuICAgICAgZmx1c2hDdXJyZW50KCk7XG4gICAgICBwb2ludHMgPSBbcG9pbnRdO1xuICAgIH1cbiAgICBwcmV2aW91c1RvID0gcG9pbnQ7XG4gIH1cbiAgZmx1c2hDdXJyZW50KCk7XG4gIHJldHVybiBvdXQ7XG59XG5mdW5jdGlvbiByZW5kZXJQYXJ0aWFsUGF0aChwYWlyRGF0YSwgcmF0aW9zLCBwYXRoLCBpbnRlcnBvbGF0aW9uKSB7XG4gIHNwbGl0UGFpckRhdGEocGFpckRhdGEsIHJhdGlvcykuZm9yRWFjaCgocG9pbnRzKSA9PiB7XG4gICAgcGxvdFBhdGgocG9pbnRzLCBwYXRoLCBpbnRlcnBvbGF0aW9uKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBwYXRoU3dpcGVJbkFuaW1hdGlvbih7IGlkLCB2aXNpYmxlLCBub2RlRGF0YURlcGVuZGVuY2llcyB9LCBhbmltYXRpb25NYW5hZ2VyLCAuLi5wYXRocykge1xuICBjb25zdCB7IHNlcmllc1JlY3RXaWR0aDogd2lkdGgyLCBzZXJpZXNSZWN0SGVpZ2h0OiBoZWlnaHQyIH0gPSBub2RlRGF0YURlcGVuZGVuY2llcztcbiAgc3RhdGljRnJvbVRvTW90aW9uKFxuICAgIGlkLFxuICAgIFwicGF0aF9wcm9wZXJ0aWVzXCIsXG4gICAgYW5pbWF0aW9uTWFuYWdlcixcbiAgICBwYXRocyxcbiAgICB7IGNsaXBYOiAwIH0sXG4gICAgeyBjbGlwWDogd2lkdGgyIH0sXG4gICAge1xuICAgICAgcGhhc2U6IFwiaW5pdGlhbFwiLFxuICAgICAgc3RhcnQ6IHsgY2xpcDogdHJ1ZSwgY2xpcFk6IGhlaWdodDIsIHZpc2libGUgfSxcbiAgICAgIGZpbmlzaDogeyBjbGlwOiBmYWxzZSwgdmlzaWJsZSB9XG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gcGF0aEZhZGVJbkFuaW1hdGlvbih7IGlkIH0sIHN1YklkLCBhbmltYXRpb25NYW5hZ2VyLCBwaGFzZSA9IFwiYWRkXCIsIC4uLnNlbGVjdGlvbikge1xuICBzdGF0aWNGcm9tVG9Nb3Rpb24oaWQsIHN1YklkLCBhbmltYXRpb25NYW5hZ2VyLCBzZWxlY3Rpb24sIHsgb3BhY2l0eTogMCB9LCB7IG9wYWNpdHk6IDEgfSwgeyBwaGFzZSB9KTtcbn1cbmZ1bmN0aW9uIHBhdGhGYWRlT3V0QW5pbWF0aW9uKHsgaWQgfSwgc3ViSWQsIGFuaW1hdGlvbk1hbmFnZXIsIC4uLnNlbGVjdGlvbikge1xuICBzdGF0aWNGcm9tVG9Nb3Rpb24oaWQsIHN1YklkLCBhbmltYXRpb25NYW5hZ2VyLCBzZWxlY3Rpb24sIHsgb3BhY2l0eTogMSB9LCB7IG9wYWNpdHk6IDAgfSwgeyBwaGFzZTogXCJyZW1vdmVcIiB9KTtcbn1cbmZ1bmN0aW9uIGJ1aWxkUmVzZXRQYXRoRm4ob3B0cykge1xuICByZXR1cm4gKF9ub2RlKSA9PiAoe1xuICAgIHZpc2libGU6IG9wdHMuZ2V0VmlzaWJsZSgpLFxuICAgIG9wYWNpdHk6IG9wdHMuZ2V0T3BhY2l0eSgpLFxuICAgIGNsaXBTY2FsaW5nWDogMSxcbiAgICBjbGlwOiBmYWxzZVxuICB9KTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUNsaXBQYXRoKHsgbm9kZURhdGFEZXBlbmRlbmNpZXMgfSwgcGF0aCkge1xuICBjb25zdCB0b0Zpbml0ZSA9ICh2YWx1ZSkgPT4gaXNGaW5pdGUodmFsdWUpID8gdmFsdWUgOiAwO1xuICBwYXRoLmNsaXBYID0gdG9GaW5pdGUobm9kZURhdGFEZXBlbmRlbmNpZXMuc2VyaWVzUmVjdFdpZHRoKTtcbiAgcGF0aC5jbGlwWSA9IHRvRmluaXRlKG5vZGVEYXRhRGVwZW5kZW5jaWVzLnNlcmllc1JlY3RIZWlnaHQpO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL3NjYWxpbmcudHNcbmZ1bmN0aW9uIGlzQ29udGludW91c1NjYWxpbmcoc2NhbGluZykge1xuICByZXR1cm4gc2NhbGluZy50eXBlID09PSBcImNvbnRpbnVvdXNcIiB8fCBzY2FsaW5nLnR5cGUgPT09IFwibG9nXCI7XG59XG5mdW5jdGlvbiBpc0NhdGVnb3J5U2NhbGluZyhzY2FsaW5nKSB7XG4gIHJldHVybiBzY2FsaW5nLnR5cGUgPT09IFwiY2F0ZWdvcnlcIjtcbn1cbmZ1bmN0aW9uIGFyZUVxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIGEuZG9tYWluLmxlbmd0aCA9PT0gYi5kb21haW4ubGVuZ3RoICYmIGEucmFuZ2UubGVuZ3RoID09PSBiLnJhbmdlLmxlbmd0aCAmJiBhLmRvbWFpbi5ldmVyeSgodmFsLCBpbmRleCkgPT4gdmFsID09PSBiLmRvbWFpbltpbmRleF0pICYmIGEucmFuZ2UuZXZlcnkoKHZhbCwgaW5kZXgpID0+IHZhbCA9PT0gYi5yYW5nZVtpbmRleF0pO1xufVxuZnVuY3Rpb24gYXJlU2NhbGluZ0VxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IHZvaWQgMCB8fCBiID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gYSAhPT0gdm9pZCAwIHx8IGIgIT09IHZvaWQgMDtcbiAgfVxuICBpZiAoaXNDb250aW51b3VzU2NhbGluZyhhKSAmJiBpc0NvbnRpbnVvdXNTY2FsaW5nKGIpKSB7XG4gICAgcmV0dXJuIGEudHlwZSA9PT0gYi50eXBlICYmIGFyZUVxdWFsKGEsIGIpO1xuICB9XG4gIGlmIChpc0NhdGVnb3J5U2NhbGluZyhhKSAmJiBpc0NhdGVnb3J5U2NhbGluZyhiKSkge1xuICAgIHJldHVybiBhcmVFcXVhbChhLCBiKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc1NjYWxlVmFsaWQoc2NhbGUyKSB7XG4gIGlmIChzY2FsZTIgPT0gbnVsbClcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmICghc2NhbGUyLnJhbmdlLmV2ZXJ5KCh2KSA9PiBOdW1iZXIuaXNGaW5pdGUodikpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKHNjYWxlMi50eXBlID09PSBcImNhdGVnb3J5XCIpIHtcbiAgICByZXR1cm4gc2NhbGUyLmRvbWFpbi5ldmVyeSgodikgPT4gdiAhPSBudWxsKTtcbiAgfVxuICByZXR1cm4gc2NhbGUyLmRvbWFpbi5ldmVyeSgodikgPT4gTnVtYmVyLmlzRmluaXRlKHYpIHx8IHYgaW5zdGFuY2VvZiBEYXRlKTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9saW5lVXRpbC50c1xuZnVuY3Rpb24qIHBhdGhSYW5nZXMocG9pbnRzKSB7XG4gIGxldCBzdGFydDIgPSAtMTtcbiAgbGV0IGVuZDIgPSAwO1xuICBmb3IgKGNvbnN0IHsgcG9pbnQgfSBvZiBwb2ludHMpIHtcbiAgICBpZiAocG9pbnQubW92ZVRvKSB7XG4gICAgICBjb25zdCByYW5nZTMgPSBzdGFydDIgPj0gMCA/IHsgc3RhcnQ6IHN0YXJ0MiwgZW5kOiBlbmQyIH0gOiB2b2lkIDA7XG4gICAgICBzdGFydDIgPSBlbmQyO1xuICAgICAgZW5kMiA9IHN0YXJ0MjtcbiAgICAgIGlmIChyYW5nZTMgIT09IHZvaWQgMCkge1xuICAgICAgICB5aWVsZCByYW5nZTM7XG4gICAgICB9XG4gICAgfVxuICAgIGVuZDIgKz0gMTtcbiAgfVxuICBpZiAoc3RhcnQyICE9PSAtMSkge1xuICAgIHlpZWxkIHsgc3RhcnQ6IHN0YXJ0MiwgZW5kOiBlbmQyIH07XG4gIH1cbn1cbmZ1bmN0aW9uKiBwYXRoUmFuZ2VQb2ludHMocG9pbnRzLCB7IHN0YXJ0OiBzdGFydDIsIGVuZDogZW5kMiB9KSB7XG4gIGZvciAobGV0IGkgPSBzdGFydDI7IGkgPCBlbmQyOyBpICs9IDEpIHtcbiAgICB5aWVsZCBwb2ludHNbaV0ucG9pbnQ7XG4gIH1cbn1cbmZ1bmN0aW9uKiBwYXRoUmFuZ2VQb2ludHNSZXZlcnNlKHBvaW50cywgeyBzdGFydDogc3RhcnQyLCBlbmQ6IGVuZDIgfSkge1xuICBmb3IgKGxldCBpID0gZW5kMiAtIDE7IGkgPj0gc3RhcnQyOyBpIC09IDEpIHtcbiAgICB5aWVsZCBwb2ludHNbaV0ucG9pbnQ7XG4gIH1cbn1cbmZ1bmN0aW9uIGludGVncmF0ZWRDYXRlZ29yeU1hdGNoKGEsIGIpIHtcbiAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIGEgIT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGIgIT09IFwib2JqZWN0XCIpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoXCJpZFwiIGluIGEgJiYgXCJpZFwiIGluIGIpIHtcbiAgICByZXR1cm4gYS5pZCA9PT0gYi5pZDtcbiAgfVxuICByZXR1cm4gYS50b1N0cmluZygpID09PSBiLnRvU3RyaW5nKCk7XG59XG5mdW5jdGlvbiBzY2FsZSh2YWwsIHNjYWxpbmcpIHtcbiAgaWYgKCFzY2FsaW5nKVxuICAgIHJldHVybiBOYU47XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgdmFsID0gdmFsLmdldFRpbWUoKTtcbiAgfVxuICBpZiAoc2NhbGluZy50eXBlID09PSBcImNvbnRpbnVvdXNcIiAmJiB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiKSB7XG4gICAgY29uc3QgZG9tYWluUmF0aW8gPSAodmFsIC0gc2NhbGluZy5kb21haW5bMF0pIC8gKHNjYWxpbmcuZG9tYWluWzFdIC0gc2NhbGluZy5kb21haW5bMF0pO1xuICAgIHJldHVybiBkb21haW5SYXRpbyAqIChzY2FsaW5nLnJhbmdlWzFdIC0gc2NhbGluZy5yYW5nZVswXSkgKyBzY2FsaW5nLnJhbmdlWzBdO1xuICB9XG4gIGlmIChzY2FsaW5nLnR5cGUgPT09IFwibG9nXCIgJiYgdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiBzY2FsaW5nLmNvbnZlcnQodmFsKTtcbiAgfVxuICBjb25zdCBtYXRjaGluZ0luZGV4ID0gc2NhbGluZy5kb21haW4uZmluZEluZGV4KChkKSA9PiBkID09PSB2YWwpO1xuICBpZiAobWF0Y2hpbmdJbmRleCA+PSAwKSB7XG4gICAgcmV0dXJuIHNjYWxpbmcucmFuZ2VbbWF0Y2hpbmdJbmRleF07XG4gIH1cbiAgY29uc3QgbWF0Y2hpbmdJbnRlZ3JhdGVkSW5kZXggPSBzY2FsaW5nLmRvbWFpbi5maW5kSW5kZXgoKGQpID0+IGludGVncmF0ZWRDYXRlZ29yeU1hdGNoKHZhbCwgZCkpO1xuICBpZiAobWF0Y2hpbmdJbnRlZ3JhdGVkSW5kZXggPj0gMCkge1xuICAgIHJldHVybiBzY2FsaW5nLnJhbmdlW21hdGNoaW5nSW50ZWdyYXRlZEluZGV4XTtcbiAgfVxuICByZXR1cm4gTmFOO1xufVxuZnVuY3Rpb24gc2NhbGVzQ2hhbmdlZChuZXdEYXRhLCBvbGREYXRhKSB7XG4gIHJldHVybiAhYXJlU2NhbGluZ0VxdWFsKG5ld0RhdGEuc2NhbGVzLngsIG9sZERhdGEuc2NhbGVzLngpIHx8ICFhcmVTY2FsaW5nRXF1YWwobmV3RGF0YS5zY2FsZXMueSwgb2xkRGF0YS5zY2FsZXMueSk7XG59XG5mdW5jdGlvbiBjbG9zZU1hdGNoKGEsIGIpIHtcbiAgY29uc3QgYW4gPSBOdW1iZXIoYSk7XG4gIGNvbnN0IGJuID0gTnVtYmVyKGIpO1xuICBpZiAoIWlzTmFOKGFuKSAmJiAhaXNOYU4oYm4pKSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKGJuIC0gYW4pIDwgMC4yNTtcbiAgfVxuICByZXR1cm4gYSA9PT0gYjtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZU1vdmVUbyhmcm9tMyA9IGZhbHNlLCB0byA9IGZhbHNlKSB7XG4gIGlmIChmcm9tMyA9PT0gdG8pIHtcbiAgICByZXR1cm4gQm9vbGVhbihmcm9tMyk7XG4gIH1cbiAgcmV0dXJuIGZyb20zID8gXCJpblwiIDogXCJvdXRcIjtcbn1cbmZ1bmN0aW9uIHBhaXJDb250aW51b3VzRGF0YShuZXdEYXRhLCBvbGREYXRhLCBvcHRzID0ge30pIHtcbiAgY29uc3QgeyBiYWNrZmlsbFNwbGl0TW9kZSA9IFwiaW50ZXJzZWN0XCIgfSA9IG9wdHM7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCByZXN1bHRNYXAgPSB7XG4gICAgYWRkZWQ6IHt9LFxuICAgIG1vdmVkOiB7fSxcbiAgICByZW1vdmVkOiB7fVxuICB9O1xuICBjb25zdCBwYWlyVXAgPSAoZnJvbTMsIHRvLCB4VmFsdWUsIGNoYW5nZSA9IFwibW92ZVwiKSA9PiB7XG4gICAgaWYgKGZyb20zICYmIChpc05hTihmcm9tMy5wb2ludC54KSB8fCBpc05hTihmcm9tMy5wb2ludC55KSkpIHtcbiAgICAgIGZyb20zID0gdG87XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdFBvaW50ID0ge1xuICAgICAgZnJvbTogZnJvbTM/LnBvaW50LFxuICAgICAgdG86IHRvPy5wb2ludCxcbiAgICAgIG1vdmVUbzogY2FsY3VsYXRlTW92ZVRvKGZyb20zPy5wb2ludC5tb3ZlVG8sIHRvPy5wb2ludC5tb3ZlVG8pLFxuICAgICAgY2hhbmdlXG4gICAgfTtcbiAgICBpZiAoY2hhbmdlID09PSBcIm1vdmVcIikge1xuICAgICAgcmVzdWx0TWFwLm1vdmVkW3hWYWx1ZV0gPSByZXN1bHRQb2ludDtcbiAgICAgIG9sZElkeCsrO1xuICAgICAgbmV3SWR4Kys7XG4gICAgfSBlbHNlIGlmIChjaGFuZ2UgPT09IFwiaW5cIikge1xuICAgICAgcmVzdWx0TWFwLmFkZGVkW3hWYWx1ZV0gPSByZXN1bHRQb2ludDtcbiAgICAgIG5ld0lkeCsrO1xuICAgIH0gZWxzZSBpZiAoY2hhbmdlID09PSBcIm91dFwiKSB7XG4gICAgICByZXN1bHRNYXAucmVtb3ZlZFt4VmFsdWVdID0gcmVzdWx0UG9pbnQ7XG4gICAgICBvbGRJZHgrKztcbiAgICB9XG4gICAgcmVzdWx0LnB1c2gocmVzdWx0UG9pbnQpO1xuICB9O1xuICBjb25zdCB7IG1pbjogbWluRnJvbU5vZGUsIG1heDogbWF4RnJvbU5vZGUgfSA9IG1pbk1heChvbGREYXRhLm5vZGVEYXRhKTtcbiAgY29uc3QgeyBtaW46IG1pblRvTm9kZSwgbWF4OiBtYXhUb05vZGUgfSA9IG1pbk1heChuZXdEYXRhLm5vZGVEYXRhKTtcbiAgbGV0IG9sZElkeCA9IDA7XG4gIGxldCBuZXdJZHggPSAwO1xuICB3aGlsZSAob2xkSWR4IDwgb2xkRGF0YS5ub2RlRGF0YS5sZW5ndGggfHwgbmV3SWR4IDwgbmV3RGF0YS5ub2RlRGF0YS5sZW5ndGgpIHtcbiAgICBjb25zdCBmcm9tMyA9IG9sZERhdGEubm9kZURhdGFbb2xkSWR4XTtcbiAgICBjb25zdCB0byA9IG5ld0RhdGEubm9kZURhdGFbbmV3SWR4XTtcbiAgICBjb25zdCBmcm9tU2hpZnRlZCA9IGZyb20zID8gc2NhbGUoZnJvbTMueFZhbHVlID8/IE5hTiwgbmV3RGF0YS5zY2FsZXMueCkgOiB2b2lkIDA7XG4gICAgY29uc3QgdG9VbnNoaWZ0ZWQgPSB0byA/IHNjYWxlKHRvLnhWYWx1ZSA/PyBOYU4sIG9sZERhdGEuc2NhbGVzLngpIDogdm9pZCAwO1xuICAgIGNvbnN0IE5BID0gdm9pZCAwO1xuICAgIGlmIChmcm9tU2hpZnRlZCAhPSBudWxsICYmIGNsb3NlTWF0Y2goZnJvbVNoaWZ0ZWQsIHRvPy5wb2ludC54KSkge1xuICAgICAgcGFpclVwKGZyb20zLCB0bywgdG8ueFZhbHVlLCBcIm1vdmVcIik7XG4gICAgfSBlbHNlIGlmIChmcm9tU2hpZnRlZCAhPSBudWxsICYmIGZyb21TaGlmdGVkIDwgKG1pblRvTm9kZT8ucG9pbnQueCA/PyAtSW5maW5pdHkpKSB7XG4gICAgICBwYWlyVXAoZnJvbTMsIE5BLCBmcm9tMy54VmFsdWUsIFwib3V0XCIpO1xuICAgIH0gZWxzZSBpZiAoZnJvbVNoaWZ0ZWQgIT0gbnVsbCAmJiBmcm9tU2hpZnRlZCA+IChtYXhUb05vZGU/LnBvaW50LnggPz8gSW5maW5pdHkpKSB7XG4gICAgICBwYWlyVXAoZnJvbTMsIE5BLCBmcm9tMy54VmFsdWUsIFwib3V0XCIpO1xuICAgIH0gZWxzZSBpZiAodG9VbnNoaWZ0ZWQgIT0gbnVsbCAmJiB0b1Vuc2hpZnRlZCA8IChtaW5Gcm9tTm9kZT8ucG9pbnQueCA/PyAtSW5maW5pdHkpKSB7XG4gICAgICBwYWlyVXAoTkEsIHRvLCB0by54VmFsdWUsIFwiaW5cIik7XG4gICAgfSBlbHNlIGlmICh0b1Vuc2hpZnRlZCAhPSBudWxsICYmIHRvVW5zaGlmdGVkID4gKG1heEZyb21Ob2RlPy5wb2ludC54ID8/IEluZmluaXR5KSkge1xuICAgICAgcGFpclVwKE5BLCB0bywgdG8ueFZhbHVlLCBcImluXCIpO1xuICAgIH0gZWxzZSBpZiAoZnJvbVNoaWZ0ZWQgIT0gbnVsbCAmJiBmcm9tU2hpZnRlZCA8IHRvPy5wb2ludC54KSB7XG4gICAgICBwYWlyVXAoZnJvbTMsIE5BLCBmcm9tMy54VmFsdWUsIFwib3V0XCIpO1xuICAgIH0gZWxzZSBpZiAodG9VbnNoaWZ0ZWQgIT0gbnVsbCAmJiB0b1Vuc2hpZnRlZCA8IGZyb20zPy5wb2ludC54KSB7XG4gICAgICBwYWlyVXAoTkEsIHRvLCB0by54VmFsdWUsIFwiaW5cIik7XG4gICAgfSBlbHNlIGlmIChmcm9tMykge1xuICAgICAgcGFpclVwKGZyb20zLCBOQSwgZnJvbTMueFZhbHVlLCBcIm91dFwiKTtcbiAgICB9IGVsc2UgaWYgKHRvKSB7XG4gICAgICBwYWlyVXAoTkEsIHRvLCB0by54VmFsdWUsIFwiaW5cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBwcm9jZXNzIHBvaW50c1wiKTtcbiAgICB9XG4gIH1cbiAgYmFja2ZpbGxQYXRoUG9pbnREYXRhKHJlc3VsdCwgYmFja2ZpbGxTcGxpdE1vZGUpO1xuICByZXR1cm4geyByZXN1bHQsIHJlc3VsdE1hcCB9O1xufVxuZnVuY3Rpb24gcGFpckNhdGVnb3J5RGF0YShuZXdEYXRhLCBvbGREYXRhLCBkaWZmMiwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IHsgYmFja2ZpbGxTcGxpdE1vZGUgPSBcImludGVyc2VjdFwiLCBtdWx0aURhdHVtID0gZmFsc2UgfSA9IG9wdHM7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCByZXN1bHRNYXBTaW5nbGUgPSB7XG4gICAgYWRkZWQ6IHt9LFxuICAgIG1vdmVkOiB7fSxcbiAgICByZW1vdmVkOiB7fVxuICB9O1xuICBjb25zdCByZXN1bHRNYXBNdWx0aSA9IHtcbiAgICBhZGRlZDoge30sXG4gICAgbW92ZWQ6IHt9LFxuICAgIHJlbW92ZWQ6IHt9XG4gIH07XG4gIGNvbnN0IHBvaW50UmVzdWx0TWFwcGluZyA9IHtcbiAgICBpbjogXCJhZGRlZFwiLFxuICAgIG1vdmU6IFwibW92ZWRcIixcbiAgICBvdXQ6IFwicmVtb3ZlZFwiXG4gIH07XG4gIGxldCBwcmV2aW91c1Jlc3VsdFBvaW50ID0gdm9pZCAwO1xuICBsZXQgcHJldmlvdXNYVmFsdWUgPSB2b2lkIDA7XG4gIGNvbnN0IGFkZFRvUmVzdWx0TWFwID0gKHhWYWx1ZSwgbmV3UG9pbnQpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgdHlwZSA9IHBvaW50UmVzdWx0TWFwcGluZ1tuZXdQb2ludC5jaGFuZ2VdO1xuICAgIGlmIChtdWx0aURhdHVtKSB7XG4gICAgICAoX2EgPSByZXN1bHRNYXBNdWx0aVt0eXBlXSlbeFZhbHVlXSA/PyAoX2FbeFZhbHVlXSA9IFtdKTtcbiAgICAgIHJlc3VsdE1hcE11bHRpW3R5cGVdW3hWYWx1ZV0ucHVzaChuZXdQb2ludCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdE1hcFNpbmdsZVt0eXBlXVt4VmFsdWVdID0gbmV3UG9pbnQ7XG4gICAgfVxuICAgIHByZXZpb3VzUmVzdWx0UG9pbnQgPSBuZXdQb2ludDtcbiAgICBwcmV2aW91c1hWYWx1ZSA9IHRyYW5zZm9ybUludGVncmF0ZWRDYXRlZ29yeVZhbHVlKHhWYWx1ZSk7XG4gIH07XG4gIGxldCBvbGRJbmRleCA9IDA7XG4gIGxldCBuZXdJbmRleCA9IDA7XG4gIGxldCBpc1hVbm9yZGVyZWQgPSBmYWxzZTtcbiAgd2hpbGUgKG9sZEluZGV4IDwgb2xkRGF0YS5ub2RlRGF0YS5sZW5ndGggfHwgbmV3SW5kZXggPCBuZXdEYXRhLm5vZGVEYXRhLmxlbmd0aCkge1xuICAgIGNvbnN0IGJlZm9yZSA9IG9sZERhdGEubm9kZURhdGFbb2xkSW5kZXhdO1xuICAgIGNvbnN0IGFmdGVyID0gbmV3RGF0YS5ub2RlRGF0YVtuZXdJbmRleF07XG4gICAgY29uc3QgYlhWYWx1ZSA9IHRyYW5zZm9ybUludGVncmF0ZWRDYXRlZ29yeVZhbHVlKGJlZm9yZT8ueFZhbHVlKTtcbiAgICBjb25zdCBhWFZhbHVlID0gdHJhbnNmb3JtSW50ZWdyYXRlZENhdGVnb3J5VmFsdWUoYWZ0ZXI/LnhWYWx1ZSk7XG4gICAgbGV0IHJlc3VsdFBvaW50O1xuICAgIGlmIChiWFZhbHVlID09PSBhWFZhbHVlKSB7XG4gICAgICByZXN1bHRQb2ludCA9IHtcbiAgICAgICAgY2hhbmdlOiBcIm1vdmVcIixcbiAgICAgICAgbW92ZVRvOiBjYWxjdWxhdGVNb3ZlVG8oYmVmb3JlLnBvaW50Lm1vdmVUbyA/PyBmYWxzZSwgYWZ0ZXIucG9pbnQubW92ZVRvKSxcbiAgICAgICAgZnJvbTogYmVmb3JlLnBvaW50LFxuICAgICAgICB0bzogYWZ0ZXIucG9pbnRcbiAgICAgIH07XG4gICAgICBhZGRUb1Jlc3VsdE1hcChiZWZvcmU/LnhWYWx1ZSwgcmVzdWx0UG9pbnQpO1xuICAgICAgb2xkSW5kZXgrKztcbiAgICAgIG5ld0luZGV4Kys7XG4gICAgfSBlbHNlIGlmIChkaWZmMj8ucmVtb3ZlZC5oYXMoU3RyaW5nKGJYVmFsdWUpKSkge1xuICAgICAgcmVzdWx0UG9pbnQgPSB7XG4gICAgICAgIGNoYW5nZTogXCJvdXRcIixcbiAgICAgICAgbW92ZVRvOiBiZWZvcmUucG9pbnQubW92ZVRvID8/IGZhbHNlLFxuICAgICAgICBmcm9tOiBiZWZvcmUucG9pbnRcbiAgICAgIH07XG4gICAgICBhZGRUb1Jlc3VsdE1hcChiZWZvcmU/LnhWYWx1ZSwgcmVzdWx0UG9pbnQpO1xuICAgICAgb2xkSW5kZXgrKztcbiAgICB9IGVsc2UgaWYgKGRpZmYyPy5hZGRlZC5oYXMoU3RyaW5nKGFYVmFsdWUpKSkge1xuICAgICAgcmVzdWx0UG9pbnQgPSB7XG4gICAgICAgIGNoYW5nZTogXCJpblwiLFxuICAgICAgICBtb3ZlVG86IGFmdGVyLnBvaW50Lm1vdmVUbyA/PyBmYWxzZSxcbiAgICAgICAgdG86IGFmdGVyLnBvaW50XG4gICAgICB9O1xuICAgICAgYWRkVG9SZXN1bHRNYXAoYWZ0ZXI/LnhWYWx1ZSwgcmVzdWx0UG9pbnQpO1xuICAgICAgbmV3SW5kZXgrKztcbiAgICB9IGVsc2UgaWYgKG11bHRpRGF0dW0gJiYgcHJldmlvdXNSZXN1bHRQb2ludCAmJiBwcmV2aW91c1hWYWx1ZSA9PT0gYlhWYWx1ZSkge1xuICAgICAgcmVzdWx0UG9pbnQgPSB7XG4gICAgICAgIC4uLnByZXZpb3VzUmVzdWx0UG9pbnRcbiAgICAgIH07XG4gICAgICBhZGRUb1Jlc3VsdE1hcChiZWZvcmU/LnhWYWx1ZSwgcmVzdWx0UG9pbnQpO1xuICAgICAgb2xkSW5kZXgrKztcbiAgICB9IGVsc2UgaWYgKG11bHRpRGF0dW0gJiYgcHJldmlvdXNSZXN1bHRQb2ludCAmJiBwcmV2aW91c1hWYWx1ZSA9PT0gYVhWYWx1ZSkge1xuICAgICAgcmVzdWx0UG9pbnQgPSB7XG4gICAgICAgIC4uLnByZXZpb3VzUmVzdWx0UG9pbnRcbiAgICAgIH07XG4gICAgICBhZGRUb1Jlc3VsdE1hcChhZnRlcj8ueFZhbHVlLCByZXN1bHRQb2ludCk7XG4gICAgICBuZXdJbmRleCsrO1xuICAgIH0gZWxzZSB7XG4gICAgICBpc1hVbm9yZGVyZWQgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKHJlc3VsdFBvaW50KTtcbiAgfVxuICBsZXQgcHJldmlvdXNYID0gLUluZmluaXR5O1xuICBpc1hVbm9yZGVyZWQgfHwgKGlzWFVub3JkZXJlZCA9IHJlc3VsdC5zb21lKChwYXRoUG9pbnQpID0+IHtcbiAgICBjb25zdCB7IGNoYW5nZTogbWFya2VyLCB0bzogeyB4ID0gLUluZmluaXR5IH0gPSB7fSB9ID0gcGF0aFBvaW50O1xuICAgIGlmIChtYXJrZXIgPT09IFwib3V0XCIpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdW5vcmRlcmVkID0geCA8IHByZXZpb3VzWDtcbiAgICBwcmV2aW91c1ggPSB4O1xuICAgIHJldHVybiB1bm9yZGVyZWQ7XG4gIH0pKTtcbiAgaWYgKGlzWFVub3JkZXJlZCkge1xuICAgIHJldHVybiB7IHJlc3VsdDogdm9pZCAwLCByZXN1bHRNYXA6IHZvaWQgMCB9O1xuICB9XG4gIGJhY2tmaWxsUGF0aFBvaW50RGF0YShyZXN1bHQsIGJhY2tmaWxsU3BsaXRNb2RlKTtcbiAgcmV0dXJuIHsgcmVzdWx0LCByZXN1bHRNYXA6IG11bHRpRGF0dW0gPyByZXN1bHRNYXBNdWx0aSA6IHJlc3VsdE1hcFNpbmdsZSB9O1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5lUGF0aFN0YXR1cyhuZXdEYXRhLCBvbGREYXRhLCBwYWlyRGF0YSkge1xuICBsZXQgc3RhdHVzID0gXCJ1cGRhdGVkXCI7XG4gIGNvbnN0IHZpc2libGUgPSAoZGF0YSkgPT4ge1xuICAgIHJldHVybiBkYXRhLnZpc2libGU7XG4gIH07XG4gIGlmICghdmlzaWJsZShvbGREYXRhKSAmJiB2aXNpYmxlKG5ld0RhdGEpKSB7XG4gICAgc3RhdHVzID0gXCJhZGRlZFwiO1xuICB9IGVsc2UgaWYgKHZpc2libGUob2xkRGF0YSkgJiYgIXZpc2libGUobmV3RGF0YSkpIHtcbiAgICBzdGF0dXMgPSBcInJlbW92ZWRcIjtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhaXJEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocGFpckRhdGFbaV0uY2hhbmdlICE9PSBcIm1vdmVcIilcbiAgICAgICAgYnJlYWs7XG4gICAgICBpZiAocGFpckRhdGFbaV0uZnJvbT8ueCAhPT0gcGFpckRhdGFbaV0udG8/LngpXG4gICAgICAgIGJyZWFrO1xuICAgICAgaWYgKHBhaXJEYXRhW2ldLmZyb20/LnkgIT09IHBhaXJEYXRhW2ldLnRvPy55KVxuICAgICAgICBicmVhaztcbiAgICAgIGlmIChpID09PSBwYWlyRGF0YS5sZW5ndGggLSAxKVxuICAgICAgICByZXR1cm4gXCJuby1vcFwiO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RhdHVzO1xufVxuZnVuY3Rpb24gcHJlcGFyZUxpbmVQYXRoUHJvcGVydHlBbmltYXRpb24oc3RhdHVzLCB2aXNpYmxlVG9nZ2xlTW9kZSkge1xuICBjb25zdCBwaGFzZSA9IHZpc2libGVUb2dnbGVNb2RlID09PSBcIm5vbmVcIiA/IFwidXBkYXRlZFwiIDogc3RhdHVzO1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgZnJvbUZuOiAoX3BhdGgpID0+IHtcbiAgICAgIGxldCBtaXhpbjtcbiAgICAgIGlmIChzdGF0dXMgPT09IFwicmVtb3ZlZFwiKSB7XG4gICAgICAgIG1peGluID0geyBmaW5pc2g6IHsgdmlzaWJsZTogZmFsc2UgfSB9O1xuICAgICAgfSBlbHNlIGlmIChzdGF0dXMgPT09IFwiYWRkZWRcIikge1xuICAgICAgICBtaXhpbiA9IHsgc3RhcnQ6IHsgdmlzaWJsZTogdHJ1ZSB9IH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtaXhpbiA9IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgcGhhc2U6IE5PREVfVVBEQVRFX1NUQVRFX1RPX1BIQVNFX01BUFBJTkdbcGhhc2VdLCAuLi5taXhpbiB9O1xuICAgIH0sXG4gICAgdG9GbjogKF9wYXRoKSA9PiB7XG4gICAgICByZXR1cm4geyBwaGFzZTogTk9ERV9VUERBVEVfU1RBVEVfVE9fUEhBU0VfTUFQUElOR1twaGFzZV0gfTtcbiAgICB9XG4gIH07XG4gIGlmICh2aXNpYmxlVG9nZ2xlTW9kZSA9PT0gXCJmYWRlXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZnJvbUZuOiAocGF0aCkgPT4ge1xuICAgICAgICBjb25zdCBvcGFjaXR5ID0gc3RhdHVzID09PSBcImFkZGVkXCIgPyAwIDogcGF0aC5vcGFjaXR5O1xuICAgICAgICByZXR1cm4geyBvcGFjaXR5LCAuLi5yZXN1bHQuZnJvbUZuKHBhdGgpIH07XG4gICAgICB9LFxuICAgICAgdG9GbjogKHBhdGgpID0+IHtcbiAgICAgICAgY29uc3Qgb3BhY2l0eSA9IHN0YXR1cyA9PT0gXCJyZW1vdmVkXCIgPyAwIDogMTtcbiAgICAgICAgcmV0dXJuIHsgb3BhY2l0eSwgLi4ucmVzdWx0LnRvRm4ocGF0aCkgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwcmVwYXJlTGluZVBhdGhBbmltYXRpb25GbnMobmV3RGF0YSwgb2xkRGF0YSwgcGFpckRhdGEsIHZpc2libGVUb2dnbGVNb2RlLCBpbnRlcnBvbGF0aW9uLCByZW5kZXIpIHtcbiAgY29uc3Qgc3RhdHVzID0gZGV0ZXJtaW5lUGF0aFN0YXR1cyhuZXdEYXRhLCBvbGREYXRhLCBwYWlyRGF0YSk7XG4gIGNvbnN0IHJlbW92ZVBoYXNlRm4gPSAocmF0aW8yLCBwYXRoKSA9PiB7XG4gICAgcmVuZGVyKHBhaXJEYXRhLCB7IG1vdmU6IDAsIG91dDogcmF0aW8yIH0sIHBhdGgsIGludGVycG9sYXRpb24pO1xuICB9O1xuICBjb25zdCB1cGRhdGVQaGFzZUZuID0gKHJhdGlvMiwgcGF0aCkgPT4ge1xuICAgIHJlbmRlcihwYWlyRGF0YSwgeyBtb3ZlOiByYXRpbzIgfSwgcGF0aCwgaW50ZXJwb2xhdGlvbik7XG4gIH07XG4gIGNvbnN0IGFkZFBoYXNlRm4gPSAocmF0aW8yLCBwYXRoKSA9PiB7XG4gICAgcmVuZGVyKHBhaXJEYXRhLCB7IG1vdmU6IDEsIGluOiByYXRpbzIgfSwgcGF0aCwgaW50ZXJwb2xhdGlvbik7XG4gIH07XG4gIGNvbnN0IHBhdGhQcm9wZXJ0aWVzID0gcHJlcGFyZUxpbmVQYXRoUHJvcGVydHlBbmltYXRpb24oc3RhdHVzLCB2aXNpYmxlVG9nZ2xlTW9kZSk7XG4gIHJldHVybiB7IHN0YXR1cywgcGF0aDogeyBhZGRQaGFzZUZuLCB1cGRhdGVQaGFzZUZuLCByZW1vdmVQaGFzZUZuIH0sIHBhdGhQcm9wZXJ0aWVzIH07XG59XG5mdW5jdGlvbiBwcmVwYXJlTGluZVBhdGhBbmltYXRpb24obmV3RGF0YSwgb2xkRGF0YSwgZGlmZjIsIGludGVycG9sYXRpb24pIHtcbiAgY29uc3QgaXNDYXRlZ29yeUJhc2VkID0gbmV3RGF0YS5zY2FsZXMueD8udHlwZSA9PT0gXCJjYXRlZ29yeVwiO1xuICBjb25zdCB3YXNDYXRlZ29yeUJhc2VkID0gb2xkRGF0YS5zY2FsZXMueD8udHlwZSA9PT0gXCJjYXRlZ29yeVwiO1xuICBpZiAoaXNDYXRlZ29yeUJhc2VkICE9PSB3YXNDYXRlZ29yeUJhc2VkIHx8ICFpc1NjYWxlVmFsaWQobmV3RGF0YS5zY2FsZXMueCkgfHwgIWlzU2NhbGVWYWxpZChvbGREYXRhLnNjYWxlcy54KSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB7IHJlc3VsdDogcGFpckRhdGEsIHJlc3VsdE1hcDogcGFpck1hcCB9ID0gaXNDYXRlZ29yeUJhc2VkID8gcGFpckNhdGVnb3J5RGF0YShuZXdEYXRhLCBvbGREYXRhLCBkaWZmMikgOiBwYWlyQ29udGludW91c0RhdGEobmV3RGF0YSwgb2xkRGF0YSk7XG4gIGxldCBzdGF0dXMgPSBcInVwZGF0ZWRcIjtcbiAgaWYgKG9sZERhdGEudmlzaWJsZSAmJiAhbmV3RGF0YS52aXNpYmxlKSB7XG4gICAgc3RhdHVzID0gXCJyZW1vdmVkXCI7XG4gIH0gZWxzZSBpZiAoIW9sZERhdGEudmlzaWJsZSAmJiBuZXdEYXRhLnZpc2libGUpIHtcbiAgICBzdGF0dXMgPSBcImFkZGVkXCI7XG4gIH1cbiAgaWYgKHBhaXJEYXRhID09PSB2b2lkIDAgfHwgcGFpck1hcCA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGhhc01vdGlvbiA9IChkaWZmMj8uY2hhbmdlZCA/PyB0cnVlKSB8fCBzY2FsZXNDaGFuZ2VkKG5ld0RhdGEsIG9sZERhdGEpIHx8IHN0YXR1cyAhPT0gXCJ1cGRhdGVkXCI7XG4gIGNvbnN0IHBhdGhGbnMgPSBwcmVwYXJlTGluZVBhdGhBbmltYXRpb25GbnMobmV3RGF0YSwgb2xkRGF0YSwgcGFpckRhdGEsIFwiZmFkZVwiLCBpbnRlcnBvbGF0aW9uLCByZW5kZXJQYXJ0aWFsUGF0aCk7XG4gIGNvbnN0IG1hcmtlciA9IHByZXBhcmVNYXJrZXJBbmltYXRpb24ocGFpck1hcCwgc3RhdHVzKTtcbiAgcmV0dXJuIHsgLi4ucGF0aEZucywgbWFya2VyLCBoYXNNb3Rpb24gfTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9saW5lSW50ZXJwb2xhdGlvblV0aWwudHNcbmZ1bmN0aW9uIHRvQXhpc1ZhbHVlKHZhbHVlKSB7XG4gIHJldHVybiB0cmFuc2Zvcm1JbnRlZ3JhdGVkQ2F0ZWdvcnlWYWx1ZSh2YWx1ZSkudmFsdWVPZigpO1xufVxuZnVuY3Rpb24gZ2V0QXhpc0luZGljZXMoeyBkYXRhIH0sIGF4aXNWYWx1ZXMpIHtcbiAgcmV0dXJuIGRhdGEubWFwKChkYXR1bSwgZGF0dW1JbmRleCkgPT4gKHtcbiAgICB4VmFsdWUwSW5kZXg6IGF4aXNWYWx1ZXMuaW5kZXhPZih0b0F4aXNWYWx1ZShkYXR1bS54VmFsdWUwKSksXG4gICAgeFZhbHVlMUluZGV4OiBheGlzVmFsdWVzLmluZGV4T2YodG9BeGlzVmFsdWUoZGF0dW0ueFZhbHVlMSkpLFxuICAgIGRhdHVtSW5kZXhcbiAgfSkpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVBeGlzVmFsdWVzT3JkZXIoYXhpc1ZhbHVlcywgZGF0YSkge1xuICBsZXQgeDAgPSAtSW5maW5pdHk7XG4gIGZvciAoY29uc3QgYXhpc1ZhbHVlIG9mIGF4aXNWYWx1ZXMpIHtcbiAgICBjb25zdCB4ID0gc2NhbGUoYXhpc1ZhbHVlLCBkYXRhLnNjYWxlcy54KTtcbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZSh4KSkge1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmICh4IDwgeDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgeDAgPSB4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGdldEF4aXNWYWx1ZXMobmV3RGF0YSwgb2xkRGF0YSkge1xuICBjb25zdCBhbGxBeGlzVmFsdWVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgZm9yIChjb25zdCB7IHhWYWx1ZTAsIHhWYWx1ZTEgfSBvZiBuZXdEYXRhLmRhdGEpIHtcbiAgICBjb25zdCB4VmFsdWUwVmFsdWUgPSB0b0F4aXNWYWx1ZSh4VmFsdWUwKTtcbiAgICBjb25zdCB4VmFsdWUxVmFsdWUgPSB0b0F4aXNWYWx1ZSh4VmFsdWUxKTtcbiAgICBhbGxBeGlzVmFsdWVzLmFkZCh4VmFsdWUwVmFsdWUpLmFkZCh4VmFsdWUxVmFsdWUpO1xuICB9XG4gIGNvbnN0IG5ld0F4aXNWYWx1ZXMgPSBBcnJheS5mcm9tKGFsbEF4aXNWYWx1ZXMpLnNvcnQoKGEsIGIpID0+IHtcbiAgICByZXR1cm4gc2NhbGUoYSwgbmV3RGF0YS5zY2FsZXMueCkgLSBzY2FsZShiLCBuZXdEYXRhLnNjYWxlcy54KTtcbiAgfSk7XG4gIGNvbnN0IGV4Y2x1c2l2ZWx5T2xkQXhpc1ZhbHVlcyA9IFtdO1xuICBmb3IgKGNvbnN0IHsgeFZhbHVlMCwgeFZhbHVlMSB9IG9mIG9sZERhdGEuZGF0YSkge1xuICAgIGNvbnN0IHhWYWx1ZTBWYWx1ZSA9IHRvQXhpc1ZhbHVlKHhWYWx1ZTApO1xuICAgIGNvbnN0IHhWYWx1ZTFWYWx1ZSA9IHRvQXhpc1ZhbHVlKHhWYWx1ZTEpO1xuICAgIGlmICghYWxsQXhpc1ZhbHVlcy5oYXMoeFZhbHVlMFZhbHVlKSkge1xuICAgICAgYWxsQXhpc1ZhbHVlcy5hZGQoeFZhbHVlMFZhbHVlKTtcbiAgICAgIGV4Y2x1c2l2ZWx5T2xkQXhpc1ZhbHVlcy5wdXNoKHhWYWx1ZTBWYWx1ZSk7XG4gICAgfVxuICAgIGlmICghYWxsQXhpc1ZhbHVlcy5oYXMoeFZhbHVlMVZhbHVlKSkge1xuICAgICAgYWxsQXhpc1ZhbHVlcy5hZGQoeFZhbHVlMVZhbHVlKTtcbiAgICAgIGV4Y2x1c2l2ZWx5T2xkQXhpc1ZhbHVlcy5wdXNoKHhWYWx1ZTFWYWx1ZSk7XG4gICAgfVxuICB9XG4gIGV4Y2x1c2l2ZWx5T2xkQXhpc1ZhbHVlcy5zb3J0KChhLCBiKSA9PiB7XG4gICAgcmV0dXJuIHNjYWxlKGEsIG9sZERhdGEuc2NhbGVzLngpIC0gc2NhbGUoYiwgb2xkRGF0YS5zY2FsZXMueCk7XG4gIH0pO1xuICBjb25zdCBheGlzVmFsdWVzID0gbmV3QXhpc1ZhbHVlcztcbiAgbGV0IGluc2VydGlvbkluZGV4ID0gMDtcbiAgZm9yIChjb25zdCBvbGRWYWx1ZSBvZiBleGNsdXNpdmVseU9sZEF4aXNWYWx1ZXMpIHtcbiAgICBpbm5lcjpcbiAgICAgIGZvciAobGV0IGkgPSBheGlzVmFsdWVzLmxlbmd0aDsgaSA+IGluc2VydGlvbkluZGV4OyBpIC09IDEpIHtcbiAgICAgICAgY29uc3Qgb2xkVmFsdWVYID0gc2NhbGUob2xkVmFsdWUsIG9sZERhdGEuc2NhbGVzLngpO1xuICAgICAgICBjb25zdCBuZXdWYWx1ZVggPSBzY2FsZShheGlzVmFsdWVzW2ldLCBvbGREYXRhLnNjYWxlcy54KTtcbiAgICAgICAgaWYgKG9sZFZhbHVlWCA+IG5ld1ZhbHVlWCkge1xuICAgICAgICAgIGluc2VydGlvbkluZGV4ID0gaSArIDE7XG4gICAgICAgICAgYnJlYWsgaW5uZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBheGlzVmFsdWVzLnNwbGljZShpbnNlcnRpb25JbmRleCwgMCwgb2xkVmFsdWUpO1xuICAgIGluc2VydGlvbkluZGV4ICs9IDE7XG4gIH1cbiAgaWYgKCF2YWxpZGF0ZUF4aXNWYWx1ZXNPcmRlcihheGlzVmFsdWVzLCBvbGREYXRhKSlcbiAgICByZXR1cm47XG4gIGNvbnN0IG9sZERhdGFBeGlzSW5kaWNlcyA9IGdldEF4aXNJbmRpY2VzKG9sZERhdGEsIGF4aXNWYWx1ZXMpO1xuICBjb25zdCBuZXdEYXRhQXhpc0luZGljZXMgPSBnZXRBeGlzSW5kaWNlcyhuZXdEYXRhLCBheGlzVmFsdWVzKTtcbiAgcmV0dXJuIHsgYXhpc1ZhbHVlcywgb2xkRGF0YUF4aXNJbmRpY2VzLCBuZXdEYXRhQXhpc0luZGljZXMgfTtcbn1cbmZ1bmN0aW9uIGNsaXBTcGFuKHNwYW4sIHhWYWx1ZTBJbmRleCwgeEluZGljZXMpIHtcbiAgaWYgKHhJbmRpY2VzLnhWYWx1ZTFJbmRleCA9PT0geEluZGljZXMueFZhbHVlMEluZGV4ICsgMSlcbiAgICByZXR1cm4gc3BhbjtcbiAgY29uc3QgcmFuZ2UzID0gc3BhblJhbmdlKHNwYW4pO1xuICBjb25zdCBzdGVwID0gKHJhbmdlM1sxXS54IC0gcmFuZ2UzWzBdLngpIC8gKHhJbmRpY2VzLnhWYWx1ZTFJbmRleCAtIHhJbmRpY2VzLnhWYWx1ZTBJbmRleCk7XG4gIGNvbnN0IHN0YXJ0MiA9IHJhbmdlM1swXS54ICsgKHhWYWx1ZTBJbmRleCAtIHhJbmRpY2VzLnhWYWx1ZTBJbmRleCkgKiBzdGVwO1xuICBjb25zdCBlbmQyID0gc3RhcnQyICsgc3RlcDtcbiAgcmV0dXJuIGNsaXBTcGFuWChzcGFuLCBzdGFydDIsIGVuZDIpO1xufVxuZnVuY3Rpb24gYXhpc1plcm9TcGFuKHNwYW4sIGRhdGEpIHtcbiAgY29uc3QgW3IwLCByMV0gPSBzcGFuUmFuZ2Uoc3Bhbik7XG4gIGNvbnN0IHkwID0gc2NhbGUoMCwgZGF0YS5zY2FsZXMueSk7XG4gIHJldHVybiByZXNjYWxlU3BhbihzcGFuLCB7IHg6IHIwLngsIHk6IHkwIH0sIHsgeDogcjEueCwgeTogeTAgfSk7XG59XG5mdW5jdGlvbiBjb2xsYXBzZVNwYW4oc3BhbiwgZGF0YSwgYXhpc0luZGljZXMsIGluZGljZXMsIHJhbmdlMykge1xuICBsZXQgeFZhbHVlO1xuICBsZXQgeVZhbHVlO1xuICBpZiAoaW5kaWNlcy54VmFsdWUwSW5kZXggPj0gcmFuZ2UzLnhWYWx1ZTFJbmRleCkge1xuICAgIGNvbnN0IGRhdHVtSW5kZXggPSBheGlzSW5kaWNlcy5maW5kTGFzdCgoaSkgPT4gaS54VmFsdWUxSW5kZXggPD0gcmFuZ2UzLnhWYWx1ZTFJbmRleCk/LmRhdHVtSW5kZXg7XG4gICAgY29uc3QgZGF0dW0gPSBkYXR1bUluZGV4ICE9IG51bGwgPyBkYXRhLmRhdGFbZGF0dW1JbmRleF0gOiB2b2lkIDA7XG4gICAgeFZhbHVlID0gZGF0dW0/LnhWYWx1ZTE7XG4gICAgeVZhbHVlID0gZGF0dW0/LnlWYWx1ZTE7XG4gIH0gZWxzZSBpZiAoaW5kaWNlcy54VmFsdWUwSW5kZXggPD0gcmFuZ2UzLnhWYWx1ZTBJbmRleCkge1xuICAgIGNvbnN0IGRhdHVtSW5kZXggPSBheGlzSW5kaWNlcy5maW5kKChpKSA9PiBpLnhWYWx1ZTBJbmRleCA+PSByYW5nZTMueFZhbHVlMEluZGV4KT8uZGF0dW1JbmRleDtcbiAgICBjb25zdCBkYXR1bSA9IGRhdHVtSW5kZXggIT0gbnVsbCA/IGRhdGEuZGF0YVtkYXR1bUluZGV4XSA6IHZvaWQgMDtcbiAgICB4VmFsdWUgPSBkYXR1bT8ueFZhbHVlMDtcbiAgICB5VmFsdWUgPSBkYXR1bT8ueVZhbHVlMDtcbiAgfVxuICBpZiAoeFZhbHVlID09IG51bGwgfHwgeVZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gYXhpc1plcm9TcGFuKHNwYW4sIGRhdGEpO1xuICB9XG4gIGNvbnN0IHggPSBzY2FsZSh4VmFsdWUsIGRhdGEuc2NhbGVzLngpO1xuICBjb25zdCB5ID0gc2NhbGUoeVZhbHVlLCBkYXRhLnNjYWxlcy55KTtcbiAgY29uc3QgcG9pbnQgPSB7IHgsIHkgfTtcbiAgcmV0dXJuIHJlc2NhbGVTcGFuKHNwYW4sIHBvaW50LCBwb2ludCk7XG59XG5mdW5jdGlvbiB6ZXJvRGF0YVNwYW4oc3BhbkRhdHVtLCB6ZXJvRGF0YSkge1xuICBjb25zdCBuZXdTcGFuWFZhbHVlMCA9IHRvQXhpc1ZhbHVlKHNwYW5EYXR1bS54VmFsdWUwKTtcbiAgY29uc3QgbmV3U3BhblhWYWx1ZTEgPSB0b0F4aXNWYWx1ZShzcGFuRGF0dW0ueFZhbHVlMSk7XG4gIHJldHVybiB6ZXJvRGF0YT8uZmluZChcbiAgICAoc3BhbikgPT4gdG9BeGlzVmFsdWUoc3Bhbi54VmFsdWUwKSA9PT0gbmV3U3BhblhWYWx1ZTAgJiYgdG9BeGlzVmFsdWUoc3Bhbi54VmFsdWUxKSA9PT0gbmV3U3BhblhWYWx1ZTFcbiAgKT8uc3Bhbjtcbn1cbmZ1bmN0aW9uIGFkZFNwYW4obmV3RGF0YSwgbmV3QXhpc0luZGljZXMsIG5ld0luZGljZXMsIG9sZFplcm9EYXRhLCByYW5nZTMsIG91dCkge1xuICBjb25zdCBuZXdTcGFuRGF0dW0gPSBuZXdEYXRhLmRhdGFbbmV3SW5kaWNlcy5kYXR1bUluZGV4XTtcbiAgY29uc3QgbmV3U3BhbiA9IG5ld1NwYW5EYXR1bS5zcGFuO1xuICBjb25zdCB6ZXJvU3BhbiA9IHplcm9EYXRhU3BhbihuZXdTcGFuRGF0dW0sIG9sZFplcm9EYXRhKTtcbiAgaWYgKHplcm9TcGFuICE9IG51bGwpIHtcbiAgICBvdXQucmVtb3ZlZC5wdXNoKHsgZnJvbTogemVyb1NwYW4sIHRvOiB6ZXJvU3BhbiB9KTtcbiAgICBvdXQubW92ZWQucHVzaCh7IGZyb206IHplcm9TcGFuLCB0bzogbmV3U3BhbiB9KTtcbiAgICBvdXQuYWRkZWQucHVzaCh7IGZyb206IG5ld1NwYW4sIHRvOiBuZXdTcGFuIH0pO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG9sZFNwYW4gPSBjb2xsYXBzZVNwYW4obmV3U3BhbiwgbmV3RGF0YSwgbmV3QXhpc0luZGljZXMsIG5ld0luZGljZXMsIHJhbmdlMyk7XG4gICAgb3V0LmFkZGVkLnB1c2goeyBmcm9tOiBvbGRTcGFuLCB0bzogbmV3U3BhbiB9KTtcbiAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlU3BhbihvbGREYXRhLCBvbGRBeGlzSW5kaWNlcywgb2xkSW5kaWNlcywgbmV3WmVyb0RhdGEsIHJhbmdlMywgb3V0KSB7XG4gIGNvbnN0IG9sZFNwYW5EYXR1bSA9IG9sZERhdGEuZGF0YVtvbGRJbmRpY2VzLmRhdHVtSW5kZXhdO1xuICBjb25zdCBvbGRTcGFuID0gb2xkU3BhbkRhdHVtLnNwYW47XG4gIGNvbnN0IHplcm9TcGFuID0gemVyb0RhdGFTcGFuKG9sZFNwYW5EYXR1bSwgbmV3WmVyb0RhdGEpO1xuICBpZiAoemVyb1NwYW4gIT0gbnVsbCkge1xuICAgIG91dC5yZW1vdmVkLnB1c2goeyBmcm9tOiBvbGRTcGFuLCB0bzogb2xkU3BhbiB9KTtcbiAgICBvdXQubW92ZWQucHVzaCh7IGZyb206IG9sZFNwYW4sIHRvOiB6ZXJvU3BhbiB9KTtcbiAgICBvdXQuYWRkZWQucHVzaCh7IGZyb206IHplcm9TcGFuLCB0bzogemVyb1NwYW4gfSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbmV3U3BhbiA9IGNvbGxhcHNlU3BhbihvbGRTcGFuLCBvbGREYXRhLCBvbGRBeGlzSW5kaWNlcywgb2xkSW5kaWNlcywgcmFuZ2UzKTtcbiAgICBvdXQucmVtb3ZlZC5wdXNoKHsgZnJvbTogb2xkU3BhbiwgdG86IG5ld1NwYW4gfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFsaWduU3BhblRvQ29udGFpbmluZ1NwYW4oc3BhbiwgYXhpc1ZhbHVlcywgcHJlRGF0YSwgcG9zdERhdGEsIHBvc3RTcGFuSW5kaWNlcykge1xuICBjb25zdCBzdGFydFhWYWx1ZTAgPSBheGlzVmFsdWVzW3Bvc3RTcGFuSW5kaWNlcy54VmFsdWUwSW5kZXhdO1xuICBjb25zdCBzdGFydERhdHVtID0gcHJlRGF0YS5kYXRhLmZpbmQoKHNwYW5EYXR1bSkgPT4gdG9BeGlzVmFsdWUoc3BhbkRhdHVtLnhWYWx1ZTApID09PSBzdGFydFhWYWx1ZTApO1xuICBjb25zdCBlbmRYVmFsdWUxID0gYXhpc1ZhbHVlc1twb3N0U3BhbkluZGljZXMueFZhbHVlMUluZGV4XTtcbiAgY29uc3QgZW5kRGF0dW0gPSBwcmVEYXRhLmRhdGEuZmluZCgoc3BhbkRhdHVtKSA9PiB0b0F4aXNWYWx1ZShzcGFuRGF0dW0ueFZhbHVlMSkgPT09IGVuZFhWYWx1ZTEpO1xuICBpZiAoc3RhcnREYXR1bSA9PSBudWxsIHx8IGVuZERhdHVtID09IG51bGwpXG4gICAgcmV0dXJuO1xuICBjb25zdCBbeyB4OiB4MCB9LCB7IHg6IHgxIH1dID0gc3BhblJhbmdlKHNwYW4pO1xuICBjb25zdCBzdGFydFggPSBzY2FsZShzdGFydERhdHVtLnhWYWx1ZTAsIHByZURhdGEuc2NhbGVzLngpO1xuICBjb25zdCBzdGFydFkgPSBzY2FsZShzdGFydERhdHVtLnlWYWx1ZTAsIHByZURhdGEuc2NhbGVzLnkpO1xuICBjb25zdCBlbmRYID0gc2NhbGUoZW5kRGF0dW0ueFZhbHVlMSwgcHJlRGF0YS5zY2FsZXMueCk7XG4gIGNvbnN0IGVuZFkgPSBzY2FsZShlbmREYXR1bS55VmFsdWUxLCBwcmVEYXRhLnNjYWxlcy55KTtcbiAgbGV0IGFsdFNwYW4gPSBwb3N0RGF0YS5kYXRhW3Bvc3RTcGFuSW5kaWNlcy5kYXR1bUluZGV4XS5zcGFuO1xuICBhbHRTcGFuID0gcmVzY2FsZVNwYW4oYWx0U3BhbiwgeyB4OiBzdGFydFgsIHk6IHN0YXJ0WSB9LCB7IHg6IGVuZFgsIHk6IGVuZFkgfSk7XG4gIGFsdFNwYW4gPSBjbGlwU3BhblgoYWx0U3BhbiwgeDAsIHgxKTtcbiAgcmV0dXJuIGFsdFNwYW47XG59XG5mdW5jdGlvbiBhcHBlbmRTcGFuUGhhc2VzKG5ld0RhdGEsIG9sZERhdGEsIGF4aXNWYWx1ZXMsIHhWYWx1ZTBJbmRleCwgbmV3QXhpc0luZGljZXMsIG9sZEF4aXNJbmRpY2VzLCByYW5nZTMsIG91dCkge1xuICBjb25zdCB4VmFsdWUxSW5kZXggPSB4VmFsdWUwSW5kZXggKyAxO1xuICBjb25zdCBvbGRJbmRpY2VzID0gb2xkQXhpc0luZGljZXMuZmluZCgoaSkgPT4gaS54VmFsdWUwSW5kZXggPD0geFZhbHVlMEluZGV4ICYmIGkueFZhbHVlMUluZGV4ID49IHhWYWx1ZTFJbmRleCk7XG4gIGNvbnN0IG5ld0luZGljZXMgPSBuZXdBeGlzSW5kaWNlcy5maW5kKChpKSA9PiBpLnhWYWx1ZTBJbmRleCA8PSB4VmFsdWUwSW5kZXggJiYgaS54VmFsdWUxSW5kZXggPj0geFZhbHVlMUluZGV4KTtcbiAgY29uc3Qgb2xkWmVyb0RhdGEgPSBvbGREYXRhLnplcm9EYXRhO1xuICBjb25zdCBuZXdaZXJvRGF0YSA9IG5ld0RhdGEuemVyb0RhdGE7XG4gIGlmIChvbGRJbmRpY2VzID09IG51bGwgJiYgbmV3SW5kaWNlcyAhPSBudWxsKSB7XG4gICAgYWRkU3BhbihuZXdEYXRhLCBuZXdBeGlzSW5kaWNlcywgbmV3SW5kaWNlcywgb2xkWmVyb0RhdGEsIHJhbmdlMywgb3V0KTtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAob2xkSW5kaWNlcyAhPSBudWxsICYmIG5ld0luZGljZXMgPT0gbnVsbCkge1xuICAgIHJlbW92ZVNwYW4ob2xkRGF0YSwgb2xkQXhpc0luZGljZXMsIG9sZEluZGljZXMsIG5ld1plcm9EYXRhLCByYW5nZTMsIG91dCk7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKG9sZEluZGljZXMgPT0gbnVsbCB8fCBuZXdJbmRpY2VzID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IG9yZGVyaW5nO1xuICBpZiAob2xkSW5kaWNlcy54VmFsdWUwSW5kZXggPT09IG5ld0luZGljZXMueFZhbHVlMEluZGV4ICYmIG9sZEluZGljZXMueFZhbHVlMUluZGV4ID09PSBuZXdJbmRpY2VzLnhWYWx1ZTFJbmRleCkge1xuICAgIG9yZGVyaW5nID0gMDtcbiAgfSBlbHNlIGlmIChvbGRJbmRpY2VzLnhWYWx1ZTBJbmRleCA8PSBuZXdJbmRpY2VzLnhWYWx1ZTBJbmRleCAmJiBvbGRJbmRpY2VzLnhWYWx1ZTFJbmRleCA+PSBuZXdJbmRpY2VzLnhWYWx1ZTFJbmRleCkge1xuICAgIG9yZGVyaW5nID0gLTE7XG4gIH0gZWxzZSBpZiAob2xkSW5kaWNlcy54VmFsdWUwSW5kZXggPj0gbmV3SW5kaWNlcy54VmFsdWUwSW5kZXggJiYgb2xkSW5kaWNlcy54VmFsdWUxSW5kZXggPD0gbmV3SW5kaWNlcy54VmFsdWUxSW5kZXgpIHtcbiAgICBvcmRlcmluZyA9IDE7XG4gIH0gZWxzZSB7XG4gICAgb3JkZXJpbmcgPSAwO1xuICB9XG4gIGNvbnN0IG9sZFNwYW5EYXR1bSA9IG9sZERhdGEuZGF0YVtvbGRJbmRpY2VzLmRhdHVtSW5kZXhdO1xuICBjb25zdCBjbGlwcGVkT2xkU3Bhbk9sZFNjYWxlID0gY2xpcFNwYW4ob2xkU3BhbkRhdHVtLnNwYW4sIHhWYWx1ZTBJbmRleCwgb2xkSW5kaWNlcyk7XG4gIGNvbnN0IG5ld1NwYW5EYXR1bSA9IG5ld0RhdGEuZGF0YVtuZXdJbmRpY2VzLmRhdHVtSW5kZXhdO1xuICBjb25zdCBjbGlwcGVkTmV3U3Bhbk5ld1NjYWxlID0gY2xpcFNwYW4obmV3U3BhbkRhdHVtLnNwYW4sIHhWYWx1ZTBJbmRleCwgbmV3SW5kaWNlcyk7XG4gIGlmIChvcmRlcmluZyA9PT0gMSkge1xuICAgIGNvbnN0IGNsaXBwZWRQb3N0UmVtb3ZlT2xkU3Bhbk9sZFNjYWxlID0gYWxpZ25TcGFuVG9Db250YWluaW5nU3BhbihcbiAgICAgIGNsaXBwZWRPbGRTcGFuT2xkU2NhbGUsXG4gICAgICBheGlzVmFsdWVzLFxuICAgICAgb2xkRGF0YSxcbiAgICAgIG5ld0RhdGEsXG4gICAgICBuZXdJbmRpY2VzXG4gICAgKTtcbiAgICBpZiAoY2xpcHBlZFBvc3RSZW1vdmVPbGRTcGFuT2xkU2NhbGUgIT0gbnVsbCkge1xuICAgICAgb3V0LnJlbW92ZWQucHVzaCh7IGZyb206IGNsaXBwZWRPbGRTcGFuT2xkU2NhbGUsIHRvOiBjbGlwcGVkUG9zdFJlbW92ZU9sZFNwYW5PbGRTY2FsZSB9KTtcbiAgICAgIG91dC5tb3ZlZC5wdXNoKHsgZnJvbTogY2xpcHBlZFBvc3RSZW1vdmVPbGRTcGFuT2xkU2NhbGUsIHRvOiBjbGlwcGVkTmV3U3Bhbk5ld1NjYWxlIH0pO1xuICAgICAgb3V0LmFkZGVkLnB1c2goeyBmcm9tOiBjbGlwcGVkTmV3U3Bhbk5ld1NjYWxlLCB0bzogY2xpcHBlZE5ld1NwYW5OZXdTY2FsZSB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlU3BhbihvbGREYXRhLCBvbGRBeGlzSW5kaWNlcywgb2xkSW5kaWNlcywgbmV3WmVyb0RhdGEsIHJhbmdlMywgb3V0KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAob3JkZXJpbmcgPT09IC0xKSB7XG4gICAgY29uc3QgY2xpcHBlZFByZUFkZGVkTmV3U3Bhbk5ld1NjYWxlID0gYWxpZ25TcGFuVG9Db250YWluaW5nU3BhbihcbiAgICAgIGNsaXBwZWROZXdTcGFuTmV3U2NhbGUsXG4gICAgICBheGlzVmFsdWVzLFxuICAgICAgbmV3RGF0YSxcbiAgICAgIG9sZERhdGEsXG4gICAgICBvbGRJbmRpY2VzXG4gICAgKTtcbiAgICBpZiAoY2xpcHBlZFByZUFkZGVkTmV3U3Bhbk5ld1NjYWxlICE9IG51bGwpIHtcbiAgICAgIG91dC5yZW1vdmVkLnB1c2goeyBmcm9tOiBjbGlwcGVkT2xkU3Bhbk9sZFNjYWxlLCB0bzogY2xpcHBlZE9sZFNwYW5PbGRTY2FsZSB9KTtcbiAgICAgIG91dC5tb3ZlZC5wdXNoKHsgZnJvbTogY2xpcHBlZE9sZFNwYW5PbGRTY2FsZSwgdG86IGNsaXBwZWRQcmVBZGRlZE5ld1NwYW5OZXdTY2FsZSB9KTtcbiAgICAgIG91dC5hZGRlZC5wdXNoKHsgZnJvbTogY2xpcHBlZFByZUFkZGVkTmV3U3Bhbk5ld1NjYWxlLCB0bzogY2xpcHBlZE5ld1NwYW5OZXdTY2FsZSB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWRkU3BhbihuZXdEYXRhLCBuZXdBeGlzSW5kaWNlcywgbmV3SW5kaWNlcywgb2xkWmVyb0RhdGEsIHJhbmdlMywgb3V0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgb3V0LnJlbW92ZWQucHVzaCh7IGZyb206IGNsaXBwZWRPbGRTcGFuT2xkU2NhbGUsIHRvOiBjbGlwcGVkT2xkU3Bhbk9sZFNjYWxlIH0pO1xuICAgIG91dC5tb3ZlZC5wdXNoKHsgZnJvbTogY2xpcHBlZE9sZFNwYW5PbGRTY2FsZSwgdG86IGNsaXBwZWROZXdTcGFuTmV3U2NhbGUgfSk7XG4gICAgb3V0LmFkZGVkLnB1c2goeyBmcm9tOiBjbGlwcGVkTmV3U3Bhbk5ld1NjYWxlLCB0bzogY2xpcHBlZE5ld1NwYW5OZXdTY2FsZSB9KTtcbiAgfVxufVxuZnVuY3Rpb24gcGhhc2VBbmltYXRpb24oYXhpc0NvbnRleHQsIG5ld0RhdGEsIG9sZERhdGEsIG91dCkge1xuICBjb25zdCB7IGF4aXNWYWx1ZXMsIG9sZERhdGFBeGlzSW5kaWNlcywgbmV3RGF0YUF4aXNJbmRpY2VzIH0gPSBheGlzQ29udGV4dDtcbiAgY29uc3QgcmFuZ2UzID0ge1xuICAgIHhWYWx1ZTBJbmRleDogTWF0aC5tYXgoXG4gICAgICBvbGREYXRhQXhpc0luZGljZXMuYXQoMCk/LnhWYWx1ZTBJbmRleCA/PyAtSW5maW5pdHksXG4gICAgICBuZXdEYXRhQXhpc0luZGljZXMuYXQoMCk/LnhWYWx1ZTBJbmRleCA/PyAtSW5maW5pdHlcbiAgICApLFxuICAgIHhWYWx1ZTFJbmRleDogTWF0aC5taW4oXG4gICAgICBvbGREYXRhQXhpc0luZGljZXMuYXQoLTEpPy54VmFsdWUxSW5kZXggPz8gSW5maW5pdHksXG4gICAgICBuZXdEYXRhQXhpc0luZGljZXMuYXQoLTEpPy54VmFsdWUxSW5kZXggPz8gSW5maW5pdHlcbiAgICApXG4gIH07XG4gIGZvciAobGV0IHhWYWx1ZTBJbmRleCA9IDA7IHhWYWx1ZTBJbmRleCA8IGF4aXNWYWx1ZXMubGVuZ3RoIC0gMTsgeFZhbHVlMEluZGV4ICs9IDEpIHtcbiAgICBhcHBlbmRTcGFuUGhhc2VzKFxuICAgICAgbmV3RGF0YSxcbiAgICAgIG9sZERhdGEsXG4gICAgICBheGlzVmFsdWVzLFxuICAgICAgeFZhbHVlMEluZGV4LFxuICAgICAgbmV3RGF0YUF4aXNJbmRpY2VzLFxuICAgICAgb2xkRGF0YUF4aXNJbmRpY2VzLFxuICAgICAgcmFuZ2UzLFxuICAgICAgb3V0XG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gcmVzZXRBbmltYXRpb24obmV3RGF0YSwgb2xkRGF0YSwgb3V0KSB7XG4gIGZvciAoY29uc3Qgb2xkU3BhbkRhdHVtIG9mIG9sZERhdGEuZGF0YSkge1xuICAgIGNvbnN0IG9sZFNwYW4gPSBvbGRTcGFuRGF0dW0uc3BhbjtcbiAgICBjb25zdCB6ZXJvU3BhbiA9IHplcm9EYXRhU3BhbihvbGRTcGFuRGF0dW0sIG9sZERhdGEuemVyb0RhdGEpID8/IGF4aXNaZXJvU3BhbihvbGRTcGFuLCBvbGREYXRhKTtcbiAgICBvdXQucmVtb3ZlZC5wdXNoKHsgZnJvbTogb2xkU3BhbiwgdG86IHplcm9TcGFuIH0pO1xuICB9XG4gIGZvciAoY29uc3QgbmV3U3BhbkRhdHVtIG9mIG5ld0RhdGEuZGF0YSkge1xuICAgIGNvbnN0IG5ld1NwYW4gPSBuZXdTcGFuRGF0dW0uc3BhbjtcbiAgICBjb25zdCB6ZXJvU3BhbiA9IHplcm9EYXRhU3BhbihuZXdTcGFuRGF0dW0sIG5ld0RhdGEuemVyb0RhdGEpID8/IGF4aXNaZXJvU3BhbihuZXdTcGFuLCBuZXdEYXRhKTtcbiAgICBvdXQuYWRkZWQucHVzaCh7IGZyb206IHplcm9TcGFuLCB0bzogbmV3U3BhbiB9KTtcbiAgfVxufVxuZnVuY3Rpb24gcGFpclVwU3BhbnMobmV3RGF0YSwgb2xkRGF0YSkge1xuICBjb25zdCBvdXQgPSB7XG4gICAgcmVtb3ZlZDogW10sXG4gICAgbW92ZWQ6IFtdLFxuICAgIGFkZGVkOiBbXVxuICB9O1xuICBjb25zdCBheGlzQ29udGV4dCA9IGdldEF4aXNWYWx1ZXMobmV3RGF0YSwgb2xkRGF0YSk7XG4gIGlmIChheGlzQ29udGV4dCA9PSBudWxsKSB7XG4gICAgcmVzZXRBbmltYXRpb24obmV3RGF0YSwgb2xkRGF0YSwgb3V0KTtcbiAgfSBlbHNlIHtcbiAgICBwaGFzZUFuaW1hdGlvbihheGlzQ29udGV4dCwgbmV3RGF0YSwgb2xkRGF0YSwgb3V0KTtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2FyZWFVdGlsLnRzXG5mdW5jdGlvbiBwbG90RmlsbFNwYW5zKHJhdGlvMiwgcGF0aCwgc3BhbnMsIGZpbGxQaGFudG9tU3BhbnMpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGFucy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IHNwYW4gPSBzcGFuc1tpXTtcbiAgICBjb25zdCByZXZlcnNlZFBoYW50b21TcGFuID0gZmlsbFBoYW50b21TcGFuc1tpXTtcbiAgICBwbG90SW50ZXJwb2xhdGVkU3BhbnMocGF0aC5wYXRoLCBzcGFuLmZyb20sIHNwYW4udG8sIHJhdGlvMiwgMSAvKiBNb3ZlVG8gKi8sIGZhbHNlKTtcbiAgICBwbG90SW50ZXJwb2xhdGVkU3BhbnMoXG4gICAgICBwYXRoLnBhdGgsXG4gICAgICByZXZlcnNlZFBoYW50b21TcGFuLmZyb20sXG4gICAgICByZXZlcnNlZFBoYW50b21TcGFuLnRvLFxuICAgICAgcmF0aW8yLFxuICAgICAgMiAvKiBMaW5lVG8gKi8sXG4gICAgICB0cnVlXG4gICAgKTtcbiAgICBwYXRoLnBhdGguY2xvc2VQYXRoKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHByZXBhcmVBcmVhRmlsbEFuaW1hdGlvbkZucyhzdGF0dXMsIHNwYW5zLCBmaWxsUGhhbnRvbVNwYW5zLCB2aXNpYmxlVG9nZ2xlTW9kZSkge1xuICBjb25zdCByZW1vdmVQaGFzZUZuID0gKHJhdGlvMiwgcGF0aCkgPT4gcGxvdEZpbGxTcGFucyhyYXRpbzIsIHBhdGgsIHNwYW5zLnJlbW92ZWQsIGZpbGxQaGFudG9tU3BhbnMucmVtb3ZlZCk7XG4gIGNvbnN0IHVwZGF0ZVBoYXNlRm4gPSAocmF0aW8yLCBwYXRoKSA9PiBwbG90RmlsbFNwYW5zKHJhdGlvMiwgcGF0aCwgc3BhbnMubW92ZWQsIGZpbGxQaGFudG9tU3BhbnMubW92ZWQpO1xuICBjb25zdCBhZGRQaGFzZUZuID0gKHJhdGlvMiwgcGF0aCkgPT4gcGxvdEZpbGxTcGFucyhyYXRpbzIsIHBhdGgsIHNwYW5zLmFkZGVkLCBmaWxsUGhhbnRvbVNwYW5zLmFkZGVkKTtcbiAgY29uc3QgcGF0aFByb3BlcnRpZXMgPSBwcmVwYXJlTGluZVBhdGhQcm9wZXJ0eUFuaW1hdGlvbihzdGF0dXMsIHZpc2libGVUb2dnbGVNb2RlKTtcbiAgcmV0dXJuIHsgc3RhdHVzLCBwYXRoOiB7IGFkZFBoYXNlRm4sIHVwZGF0ZVBoYXNlRm4sIHJlbW92ZVBoYXNlRm4gfSwgcGF0aFByb3BlcnRpZXMgfTtcbn1cbmZ1bmN0aW9uIHBsb3RTdHJva2VTcGFucyhyYXRpbzIsIHBhdGgsIHNwYW5zKSB7XG4gIGZvciAoY29uc3Qgc3BhbiBvZiBzcGFucykge1xuICAgIHBsb3RJbnRlcnBvbGF0ZWRTcGFucyhwYXRoLnBhdGgsIHNwYW4uZnJvbSwgc3Bhbi50bywgcmF0aW8yLCAxIC8qIE1vdmVUbyAqLywgZmFsc2UpO1xuICB9XG59XG5mdW5jdGlvbiBwcmVwYXJlQXJlYVN0cm9rZUFuaW1hdGlvbkZucyhzdGF0dXMsIHNwYW5zLCB2aXNpYmxlVG9nZ2xlTW9kZSkge1xuICBjb25zdCByZW1vdmVQaGFzZUZuID0gKHJhdGlvMiwgcGF0aCkgPT4gcGxvdFN0cm9rZVNwYW5zKHJhdGlvMiwgcGF0aCwgc3BhbnMucmVtb3ZlZCk7XG4gIGNvbnN0IHVwZGF0ZVBoYXNlRm4gPSAocmF0aW8yLCBwYXRoKSA9PiBwbG90U3Ryb2tlU3BhbnMocmF0aW8yLCBwYXRoLCBzcGFucy5tb3ZlZCk7XG4gIGNvbnN0IGFkZFBoYXNlRm4gPSAocmF0aW8yLCBwYXRoKSA9PiBwbG90U3Ryb2tlU3BhbnMocmF0aW8yLCBwYXRoLCBzcGFucy5hZGRlZCk7XG4gIGNvbnN0IHBhdGhQcm9wZXJ0aWVzID0gcHJlcGFyZUxpbmVQYXRoUHJvcGVydHlBbmltYXRpb24oc3RhdHVzLCB2aXNpYmxlVG9nZ2xlTW9kZSk7XG4gIHJldHVybiB7IHN0YXR1cywgcGF0aDogeyBhZGRQaGFzZUZuLCB1cGRhdGVQaGFzZUZuLCByZW1vdmVQaGFzZUZuIH0sIHBhdGhQcm9wZXJ0aWVzIH07XG59XG5mdW5jdGlvbiBwcmVwYXJlQXJlYVBhdGhBbmltYXRpb24obmV3RGF0YSwgb2xkRGF0YSkge1xuICBjb25zdCBpc0NhdGVnb3J5QmFzZWQgPSBuZXdEYXRhLnNjYWxlcy54Py50eXBlID09PSBcImNhdGVnb3J5XCI7XG4gIGNvbnN0IHdhc0NhdGVnb3J5QmFzZWQgPSBvbGREYXRhLnNjYWxlcy54Py50eXBlID09PSBcImNhdGVnb3J5XCI7XG4gIGlmIChpc0NhdGVnb3J5QmFzZWQgIT09IHdhc0NhdGVnb3J5QmFzZWQgfHwgIWlzU2NhbGVWYWxpZChuZXdEYXRhLnNjYWxlcy54KSB8fCAhaXNTY2FsZVZhbGlkKG9sZERhdGEuc2NhbGVzLngpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBzdGF0dXMgPSBcInVwZGF0ZWRcIjtcbiAgaWYgKG9sZERhdGEudmlzaWJsZSAmJiAhbmV3RGF0YS52aXNpYmxlKSB7XG4gICAgc3RhdHVzID0gXCJyZW1vdmVkXCI7XG4gIH0gZWxzZSBpZiAoIW9sZERhdGEudmlzaWJsZSAmJiBuZXdEYXRhLnZpc2libGUpIHtcbiAgICBzdGF0dXMgPSBcImFkZGVkXCI7XG4gIH1cbiAgY29uc3QgZmlsbFNwYW5zID0gcGFpclVwU3BhbnMoXG4gICAgeyBzY2FsZXM6IG5ld0RhdGEuc2NhbGVzLCBkYXRhOiBuZXdEYXRhLmZpbGxEYXRhLnNwYW5zLCB2aXNpYmxlOiBuZXdEYXRhLnZpc2libGUgfSxcbiAgICB7IHNjYWxlczogb2xkRGF0YS5zY2FsZXMsIGRhdGE6IG9sZERhdGEuZmlsbERhdGEuc3BhbnMsIHZpc2libGU6IG9sZERhdGEudmlzaWJsZSB9XG4gICk7XG4gIGNvbnN0IGZpbGxQaGFudG9tU3BhbnMgPSBwYWlyVXBTcGFucyhcbiAgICB7IHNjYWxlczogbmV3RGF0YS5zY2FsZXMsIGRhdGE6IG5ld0RhdGEuZmlsbERhdGEucGhhbnRvbVNwYW5zLCB2aXNpYmxlOiBuZXdEYXRhLnZpc2libGUgfSxcbiAgICB7IHNjYWxlczogb2xkRGF0YS5zY2FsZXMsIGRhdGE6IG9sZERhdGEuZmlsbERhdGEucGhhbnRvbVNwYW5zLCB2aXNpYmxlOiBvbGREYXRhLnZpc2libGUgfVxuICApO1xuICBjb25zdCBzdHJva2VTcGFucyA9IHBhaXJVcFNwYW5zKFxuICAgIHtcbiAgICAgIHNjYWxlczogbmV3RGF0YS5zY2FsZXMsXG4gICAgICBkYXRhOiBuZXdEYXRhLnN0cm9rZURhdGEuc3BhbnMsXG4gICAgICB2aXNpYmxlOiBuZXdEYXRhLnZpc2libGUsXG4gICAgICB6ZXJvRGF0YTogbmV3RGF0YS5maWxsRGF0YS5waGFudG9tU3BhbnNcbiAgICB9LFxuICAgIHtcbiAgICAgIHNjYWxlczogb2xkRGF0YS5zY2FsZXMsXG4gICAgICBkYXRhOiBvbGREYXRhLnN0cm9rZURhdGEuc3BhbnMsXG4gICAgICB2aXNpYmxlOiBvbGREYXRhLnZpc2libGUsXG4gICAgICB6ZXJvRGF0YTogb2xkRGF0YS5maWxsRGF0YS5waGFudG9tU3BhbnNcbiAgICB9XG4gICk7XG4gIGNvbnN0IGZhZGVNb2RlID0gXCJub25lXCI7XG4gIGNvbnN0IGZpbGwgPSBwcmVwYXJlQXJlYUZpbGxBbmltYXRpb25GbnMoc3RhdHVzLCBmaWxsU3BhbnMsIGZpbGxQaGFudG9tU3BhbnMsIGZhZGVNb2RlKTtcbiAgY29uc3Qgc3Ryb2tlID0gcHJlcGFyZUFyZWFTdHJva2VBbmltYXRpb25GbnMoc3RhdHVzLCBzdHJva2VTcGFucywgZmFkZU1vZGUpO1xuICByZXR1cm4geyBzdGF0dXMsIGZpbGwsIHN0cm9rZSB9O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2FyZWFTZXJpZXMudHNcbnZhciBDUk9TU19GSUxURVJfQVJFQV9GSUxMX09QQUNJVFlfRkFDVE9SID0gMC4xMjU7XG52YXIgQ1JPU1NfRklMVEVSX0FSRUFfU1RST0tFX09QQUNJVFlfRkFDVE9SID0gMC4yNTtcbnZhciBBcmVhU2VyaWVzID0gY2xhc3MgZXh0ZW5kcyBDYXJ0ZXNpYW5TZXJpZXMge1xuICBjb25zdHJ1Y3Rvcihtb2R1bGVDdHgpIHtcbiAgICBzdXBlcih7XG4gICAgICBtb2R1bGVDdHgsXG4gICAgICBkaXJlY3Rpb25LZXlzOiBERUZBVUxUX0NBUlRFU0lBTl9ESVJFQ1RJT05fS0VZUyxcbiAgICAgIGRpcmVjdGlvbk5hbWVzOiBERUZBVUxUX0NBUlRFU0lBTl9ESVJFQ1RJT05fTkFNRVMsXG4gICAgICBwYXRoc1BlclNlcmllczogW1wiZmlsbFwiLCBcInN0cm9rZVwiXSxcbiAgICAgIHBhdGhzWkluZGV4U3ViT3JkZXJPZmZzZXQ6IFswLCAxZTNdLFxuICAgICAgaGFzTWFya2VyczogdHJ1ZSxcbiAgICAgIG1hcmtlclNlbGVjdGlvbkdhcmJhZ2VDb2xsZWN0aW9uOiBmYWxzZSxcbiAgICAgIHBpY2tNb2RlczogWzIgLyogQVhJU19BTElHTkVEICovLCAwIC8qIEVYQUNUX1NIQVBFX01BVENIICovXSxcbiAgICAgIGFuaW1hdGlvblJlc2V0Rm5zOiB7XG4gICAgICAgIHBhdGg6IGJ1aWxkUmVzZXRQYXRoRm4oeyBnZXRWaXNpYmxlOiAoKSA9PiB0aGlzLnZpc2libGUsIGdldE9wYWNpdHk6ICgpID0+IHRoaXMuZ2V0T3BhY2l0eSgpIH0pLFxuICAgICAgICBsYWJlbDogcmVzZXRMYWJlbEZuLFxuICAgICAgICBtYXJrZXI6IChub2RlLCBkYXR1bSkgPT4gKHsgLi4ucmVzZXRNYXJrZXJGbihub2RlKSwgLi4ucmVzZXRNYXJrZXJQb3NpdGlvbkZuKG5vZGUsIGRhdHVtKSB9KVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMucHJvcGVydGllcyA9IG5ldyBBcmVhU2VyaWVzUHJvcGVydGllcygpO1xuICB9XG4gIGFzeW5jIHByb2Nlc3NEYXRhKGRhdGFDb250cm9sbGVyKSB7XG4gICAgaWYgKHRoaXMuZGF0YSA9PSBudWxsIHx8ICF0aGlzLnByb3BlcnRpZXMuaXNWYWxpZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgZGF0YSwgdmlzaWJsZSwgc2VyaWVzR3JvdXBpbmc6IHsgZ3JvdXBJbmRleCA9IHRoaXMuaWQsIHN0YWNrQ291bnQgPSAxIH0gPSB7fSB9ID0gdGhpcztcbiAgICBjb25zdCB7IHhLZXksIHlLZXksIHlGaWx0ZXJLZXksIGNvbm5lY3RNaXNzaW5nRGF0YSwgbm9ybWFsaXplZFRvIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgYW5pbWF0aW9uRW5hYmxlZCA9ICF0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLmlzU2tpcHBlZCgpO1xuICAgIGNvbnN0IHhTY2FsZSA9IHRoaXMuYXhlc1tcInhcIiAvKiBYICovXT8uc2NhbGU7XG4gICAgY29uc3QgeVNjYWxlID0gdGhpcy5heGVzW1wieVwiIC8qIFkgKi9dPy5zY2FsZTtcbiAgICBjb25zdCB7IHhTY2FsZVR5cGUsIHlTY2FsZVR5cGUgfSA9IHRoaXMuZ2V0U2NhbGVJbmZvcm1hdGlvbih7IHhTY2FsZSwgeVNjYWxlIH0pO1xuICAgIGNvbnN0IGlkTWFwID0ge1xuICAgICAgdmFsdWU6IGBhcmVhLXN0YWNrLSR7Z3JvdXBJbmRleH0teVZhbHVlYCxcbiAgICAgIHZhbHVlczogYGFyZWEtc3RhY2stJHtncm91cEluZGV4fS15VmFsdWVzYCxcbiAgICAgIHN0YWNrOiBgYXJlYS1zdGFjay0ke2dyb3VwSW5kZXh9LXlWYWx1ZS1zdGFja2AsXG4gICAgICBtYXJrZXI6IGBhcmVhLXN0YWNrLSR7Z3JvdXBJbmRleH0teVZhbHVlcy1tYXJrZXJgXG4gICAgfTtcbiAgICBjb25zdCBleHRyYVByb3BzID0gW107XG4gICAgaWYgKGlzRGVmaW5lZChub3JtYWxpemVkVG8pKSB7XG4gICAgICBleHRyYVByb3BzLnB1c2gobm9ybWFsaXNlR3JvdXBUbyhPYmplY3QudmFsdWVzKGlkTWFwKSwgbm9ybWFsaXplZFRvLCBcInJhbmdlXCIpKTtcbiAgICB9XG4gICAgaWYgKGFuaW1hdGlvbkVuYWJsZWQpIHtcbiAgICAgIGV4dHJhUHJvcHMucHVzaChhbmltYXRpb25WYWxpZGF0aW9uKCkpO1xuICAgIH1cbiAgICBjb25zdCBjb21tb24gPSB7IGludmFsaWRWYWx1ZTogbnVsbCB9O1xuICAgIGlmIChjb25uZWN0TWlzc2luZ0RhdGEgJiYgc3RhY2tDb3VudCA+IDEpIHtcbiAgICAgIGNvbW1vbi5pbnZhbGlkVmFsdWUgPSAwO1xuICAgIH1cbiAgICBpZiAoIXZpc2libGUpIHtcbiAgICAgIGNvbW1vbi5mb3JjZVZhbHVlID0gMDtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5yZXF1ZXN0RGF0YU1vZGVsKGRhdGFDb250cm9sbGVyLCBkYXRhLCB7XG4gICAgICBwcm9wczogW1xuICAgICAgICBrZXlQcm9wZXJ0eSh4S2V5LCB4U2NhbGVUeXBlLCB7IGlkOiBcInhWYWx1ZVwiIH0pLFxuICAgICAgICB2YWx1ZVByb3BlcnR5KHlLZXksIHlTY2FsZVR5cGUsIHsgaWQ6IGB5VmFsdWVSYXdgLCAuLi5jb21tb24gfSksXG4gICAgICAgIC4uLnlGaWx0ZXJLZXkgIT0gbnVsbCA/IFt2YWx1ZVByb3BlcnR5KHlGaWx0ZXJLZXksIHlTY2FsZVR5cGUsIHsgaWQ6IFwieUZpbHRlclJhd1wiIH0pXSA6IFtdLFxuICAgICAgICAuLi5ncm91cFN0YWNrVmFsdWVQcm9wZXJ0eSh5S2V5LCB5U2NhbGVUeXBlLCB7IGlkOiBgeVZhbHVlU3RhY2tgLCAuLi5jb21tb24sIGdyb3VwSWQ6IGlkTWFwLnN0YWNrIH0pLFxuICAgICAgICB2YWx1ZVByb3BlcnR5KHlLZXksIHlTY2FsZVR5cGUsIHsgaWQ6IGB5VmFsdWVgLCAuLi5jb21tb24sIGdyb3VwSWQ6IGlkTWFwLnZhbHVlIH0pLFxuICAgICAgICAuLi5ncm91cEFjY3VtdWxhdGl2ZVZhbHVlUHJvcGVydHkoXG4gICAgICAgICAgeUtleSxcbiAgICAgICAgICBcIndpbmRvd1wiLFxuICAgICAgICAgIFwiY3VycmVudFwiLFxuICAgICAgICAgIHsgaWQ6IGB5VmFsdWVFbmRgLCAuLi5jb21tb24sIGdyb3VwSWQ6IGlkTWFwLnZhbHVlcyB9LFxuICAgICAgICAgIHlTY2FsZVR5cGVcbiAgICAgICAgKSxcbiAgICAgICAgLi4uZ3JvdXBBY2N1bXVsYXRpdmVWYWx1ZVByb3BlcnR5KFxuICAgICAgICAgIHlLZXksXG4gICAgICAgICAgXCJub3JtYWxcIixcbiAgICAgICAgICBcImN1cnJlbnRcIixcbiAgICAgICAgICB7IGlkOiBgeVZhbHVlQ3VtdWxhdGl2ZWAsIC4uLmNvbW1vbiwgZ3JvdXBJZDogaWRNYXAubWFya2VyIH0sXG4gICAgICAgICAgeVNjYWxlVHlwZVxuICAgICAgICApLFxuICAgICAgICAuLi5leHRyYVByb3BzXG4gICAgICBdLFxuICAgICAgZ3JvdXBCeUtleXM6IHRydWUsXG4gICAgICBncm91cEJ5RGF0YTogZmFsc2VcbiAgICB9KTtcbiAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJ1cGRhdGVEYXRhXCIpO1xuICB9XG4gIGdldFNlcmllc0RvbWFpbihkaXJlY3Rpb24pIHtcbiAgICBjb25zdCB7IHByb2Nlc3NlZERhdGEsIGRhdGFNb2RlbCwgYXhlcyB9ID0gdGhpcztcbiAgICBpZiAoIXByb2Nlc3NlZERhdGEgfHwgIWRhdGFNb2RlbCB8fCBwcm9jZXNzZWREYXRhLmRhdGEubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIFtdO1xuICAgIGNvbnN0IHlBeGlzID0gYXhlc1tcInlcIiAvKiBZICovXTtcbiAgICBjb25zdCBrZXlEZWYgPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFEZWZCeUlkKHRoaXMsIGB4VmFsdWVgKTtcbiAgICBjb25zdCBrZXlzID0gZGF0YU1vZGVsLmdldERvbWFpbih0aGlzLCBgeFZhbHVlYCwgXCJrZXlcIiwgcHJvY2Vzc2VkRGF0YSk7XG4gICAgY29uc3QgeUV4dGVudCA9IGRhdGFNb2RlbC5nZXREb21haW4odGhpcywgYHlWYWx1ZUVuZGAsIFwidmFsdWVcIiwgcHJvY2Vzc2VkRGF0YSk7XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJ4XCIgLyogWCAqLykge1xuICAgICAgaWYgKGtleURlZj8uZGVmLnR5cGUgPT09IFwia2V5XCIgJiYga2V5RGVmLmRlZi52YWx1ZVR5cGUgPT09IFwiY2F0ZWdvcnlcIikge1xuICAgICAgICByZXR1cm4ga2V5cztcbiAgICAgIH1cbiAgICAgIHJldHVybiBmaXhOdW1lcmljRXh0ZW50KGV4dGVudChrZXlzKSk7XG4gICAgfSBlbHNlIGlmICh5QXhpcyBpbnN0YW5jZW9mIExvZ0F4aXMgfHwgeUF4aXMgaW5zdGFuY2VvZiBUaW1lQXhpcykge1xuICAgICAgcmV0dXJuIGZpeE51bWVyaWNFeHRlbnQoeUV4dGVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGZpeGVkWUV4dGVudCA9IFt5RXh0ZW50WzBdID4gMCA/IDAgOiB5RXh0ZW50WzBdLCB5RXh0ZW50WzFdIDwgMCA/IDAgOiB5RXh0ZW50WzFdXTtcbiAgICAgIHJldHVybiBmaXhOdW1lcmljRXh0ZW50KGZpeGVkWUV4dGVudCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGNyZWF0ZU5vZGVEYXRhKCkge1xuICAgIGNvbnN0IHsgYXhlcywgZGF0YSwgcHJvY2Vzc2VkRGF0YTogeyBkYXRhOiBncm91cGVkRGF0YSB9ID0ge30sIGRhdGFNb2RlbCB9ID0gdGhpcztcbiAgICBjb25zdCB4QXhpcyA9IGF4ZXNbXCJ4XCIgLyogWCAqL107XG4gICAgY29uc3QgeUF4aXMgPSBheGVzW1wieVwiIC8qIFkgKi9dO1xuICAgIGlmICgheEF4aXMgfHwgIXlBeGlzIHx8ICFkYXRhIHx8ICFkYXRhTW9kZWwgfHwgIXRoaXMucHJvcGVydGllcy5pc1ZhbGlkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgeUtleSxcbiAgICAgIHhLZXksXG4gICAgICB5RmlsdGVyS2V5LFxuICAgICAgbWFya2VyLFxuICAgICAgbGFiZWwsXG4gICAgICBmaWxsOiBzZXJpZXNGaWxsLFxuICAgICAgc3Ryb2tlOiBzZXJpZXNTdHJva2UsXG4gICAgICBjb25uZWN0TWlzc2luZ0RhdGFcbiAgICB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHsgc2NhbGU6IHhTY2FsZSB9ID0geEF4aXM7XG4gICAgY29uc3QgeyBzY2FsZTogeVNjYWxlIH0gPSB5QXhpcztcbiAgICBjb25zdCB7IGlzQ29udGludW91c1kgfSA9IHRoaXMuZ2V0U2NhbGVJbmZvcm1hdGlvbih7IHhTY2FsZSwgeVNjYWxlIH0pO1xuICAgIGNvbnN0IHhPZmZzZXQgPSAoeFNjYWxlLmJhbmR3aWR0aCA/PyAwKSAvIDI7XG4gICAgY29uc3QgZGVmcyA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YURlZnNCeUlkcyh0aGlzLCBbYHlWYWx1ZUVuZGAsIGB5VmFsdWVSYXdgLCBgeVZhbHVlQ3VtdWxhdGl2ZWBdKTtcbiAgICBjb25zdCB5RmlsdGVySW5kZXggPSB5RmlsdGVyS2V5ICE9IG51bGwgPyBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgXCJ5RmlsdGVyUmF3XCIpIDogdm9pZCAwO1xuICAgIGNvbnN0IHlWYWx1ZVN0YWNrSW5kZXggPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgXCJ5VmFsdWVTdGFja1wiKTtcbiAgICBjb25zdCBjcmVhdGVNYXJrZXJDb29yZGluYXRlID0gKHhEYXR1bSwgeUVuZCwgcmF3WURhdHVtKSA9PiB7XG4gICAgICBsZXQgY3Vyclk7XG4gICAgICBpZiAoaXNEZWZpbmVkKHRoaXMucHJvcGVydGllcy5ub3JtYWxpemVkVG8pID8gaXNDb250aW51b3VzWSAmJiBpc0NvbnRpbnVvdXMocmF3WURhdHVtKSA6ICFpc05hTihyYXdZRGF0dW0pKSB7XG4gICAgICAgIGN1cnJZID0geUVuZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHhTY2FsZS5jb252ZXJ0KHhEYXR1bSkgKyB4T2Zmc2V0LFxuICAgICAgICB5OiB5U2NhbGUuY29udmVydChjdXJyWSksXG4gICAgICAgIHNpemU6IG1hcmtlci5zaXplXG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgaXRlbUlkID0geUtleTtcbiAgICBjb25zdCBsYWJlbERhdGEgPSBbXTtcbiAgICBjb25zdCBtYXJrZXJEYXRhID0gW107XG4gICAgY29uc3QgeyB2aXNpYmxlU2FtZVN0YWNrQ291bnQgfSA9IHRoaXMuY3R4LnNlcmllc1N0YXRlTWFuYWdlci5nZXRWaXNpYmxlUGVlckdyb3VwSW5kZXgodGhpcyk7XG4gICAgbGV0IGRhdHVtSWR4ID0gLTE7XG4gICAgbGV0IGNyb3NzRmlsdGVyaW5nID0gZmFsc2U7XG4gICAgZ3JvdXBlZERhdGE/LmZvckVhY2goKGRhdHVtR3JvdXApID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAga2V5cyxcbiAgICAgICAga2V5czogW3hEYXR1bV0sXG4gICAgICAgIGRhdHVtOiBkYXR1bUFycmF5LFxuICAgICAgICB2YWx1ZXM6IHZhbHVlc0FycmF5XG4gICAgICB9ID0gZGF0dW1Hcm91cDtcbiAgICAgIHZhbHVlc0FycmF5LmZvckVhY2goKHZhbHVlcywgdmFsdWVJZHgpID0+IHtcbiAgICAgICAgZGF0dW1JZHgrKztcbiAgICAgICAgY29uc3Qgc2VyaWVzRGF0dW0gPSBkYXR1bUFycmF5W3ZhbHVlSWR4XTtcbiAgICAgICAgY29uc3QgZGF0YVZhbHVlczIgPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFEZWZzVmFsdWVzKGRlZnMsIHsga2V5cywgdmFsdWVzIH0pO1xuICAgICAgICBjb25zdCB7IHlWYWx1ZVJhdzogeURhdHVtLCB5VmFsdWVDdW11bGF0aXZlLCB5VmFsdWVFbmQgfSA9IGRhdGFWYWx1ZXMyO1xuICAgICAgICBjb25zdCB2YWxpZFBvaW50ID0gTnVtYmVyLmlzRmluaXRlKHlEYXR1bSk7XG4gICAgICAgIGNvbnN0IHBvaW50ID0gY3JlYXRlTWFya2VyQ29vcmRpbmF0ZSh4RGF0dW0sICt5VmFsdWVDdW11bGF0aXZlLCB5RGF0dW0pO1xuICAgICAgICBjb25zdCBzZWxlY3RlZCA9IHlGaWx0ZXJJbmRleCAhPSBudWxsID8gdmFsdWVzW3lGaWx0ZXJJbmRleF0gPT09IHlEYXR1bSA6IHZvaWQgMDtcbiAgICAgICAgaWYgKHNlbGVjdGVkID09PSBmYWxzZSkge1xuICAgICAgICAgIGNyb3NzRmlsdGVyaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsaWRQb2ludCAmJiBtYXJrZXIpIHtcbiAgICAgICAgICBtYXJrZXJEYXRhLnB1c2goe1xuICAgICAgICAgICAgaW5kZXg6IGRhdHVtSWR4LFxuICAgICAgICAgICAgc2VyaWVzOiB0aGlzLFxuICAgICAgICAgICAgaXRlbUlkLFxuICAgICAgICAgICAgZGF0dW06IHNlcmllc0RhdHVtLFxuICAgICAgICAgICAgbWlkUG9pbnQ6IHsgeDogcG9pbnQueCwgeTogcG9pbnQueSB9LFxuICAgICAgICAgICAgY3VtdWxhdGl2ZVZhbHVlOiB5VmFsdWVFbmQsXG4gICAgICAgICAgICB5VmFsdWU6IHlEYXR1bSxcbiAgICAgICAgICAgIHhWYWx1ZTogeERhdHVtLFxuICAgICAgICAgICAgeUtleSxcbiAgICAgICAgICAgIHhLZXksXG4gICAgICAgICAgICBwb2ludCxcbiAgICAgICAgICAgIGZpbGw6IG1hcmtlci5maWxsID8/IHNlcmllc0ZpbGwsXG4gICAgICAgICAgICBzdHJva2U6IG1hcmtlci5zdHJva2UgPz8gc2VyaWVzU3Ryb2tlLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IG1hcmtlci5zdHJva2VXaWR0aCA/PyB0aGlzLmdldFN0cm9rZVdpZHRoKHRoaXMucHJvcGVydGllcy5zdHJva2VXaWR0aCksXG4gICAgICAgICAgICBzZWxlY3RlZFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWxpZFBvaW50ICYmIGxhYmVsKSB7XG4gICAgICAgICAgY29uc3QgbGFiZWxUZXh0ID0gdGhpcy5nZXRMYWJlbFRleHQoXG4gICAgICAgICAgICBsYWJlbCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHlEYXR1bSxcbiAgICAgICAgICAgICAgZGF0dW06IHNlcmllc0RhdHVtLFxuICAgICAgICAgICAgICB4S2V5LFxuICAgICAgICAgICAgICB5S2V5LFxuICAgICAgICAgICAgICB4TmFtZTogdGhpcy5wcm9wZXJ0aWVzLnhOYW1lLFxuICAgICAgICAgICAgICB5TmFtZTogdGhpcy5wcm9wZXJ0aWVzLnlOYW1lXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9ybWF0VmFsdWVcbiAgICAgICAgICApO1xuICAgICAgICAgIGxhYmVsRGF0YS5wdXNoKHtcbiAgICAgICAgICAgIGluZGV4OiBkYXR1bUlkeCxcbiAgICAgICAgICAgIHNlcmllczogdGhpcyxcbiAgICAgICAgICAgIGl0ZW1JZDogeUtleSxcbiAgICAgICAgICAgIGRhdHVtOiBzZXJpZXNEYXR1bSxcbiAgICAgICAgICAgIHg6IHBvaW50LngsXG4gICAgICAgICAgICB5OiBwb2ludC55LFxuICAgICAgICAgICAgbGFiZWxUZXh0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGNvbnN0IHsgaW50ZXJwb2xhdGlvbiB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGludGVycG9sYXRlUG9pbnRzID0gKHBvaW50cykgPT4ge1xuICAgICAgbGV0IHNwYW5zO1xuICAgICAgY29uc3QgcG9pbnRzSXRlciA9IHBvaW50cy5tYXAoKHBvaW50KSA9PiBwb2ludC5wb2ludCk7XG4gICAgICBzd2l0Y2ggKGludGVycG9sYXRpb24udHlwZSkge1xuICAgICAgICBjYXNlIFwibGluZWFyXCI6XG4gICAgICAgICAgc3BhbnMgPSBsaW5lYXJQb2ludHMocG9pbnRzSXRlcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzbW9vdGhcIjpcbiAgICAgICAgICBzcGFucyA9IHNtb290aFBvaW50cyhwb2ludHNJdGVyLCBpbnRlcnBvbGF0aW9uLnRlbnNpb24pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic3RlcFwiOlxuICAgICAgICAgIHNwYW5zID0gc3RlcFBvaW50cyhwb2ludHNJdGVyLCBpbnRlcnBvbGF0aW9uLnBvc2l0aW9uKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBzcGFucy5tYXAoKHNwYW4sIGkpID0+ICh7XG4gICAgICAgIHNwYW4sXG4gICAgICAgIHhWYWx1ZTA6IHBvaW50c1tpXS54RGF0dW0sXG4gICAgICAgIHlWYWx1ZTA6IHBvaW50c1tpXS55RGF0dW0sXG4gICAgICAgIHhWYWx1ZTE6IHBvaW50c1tpICsgMV0ueERhdHVtLFxuICAgICAgICB5VmFsdWUxOiBwb2ludHNbaSArIDFdLnlEYXR1bVxuICAgICAgfSkpO1xuICAgIH07XG4gICAgY29uc3Qgc3BhbnNGb3JQb2ludHMgPSAocG9pbnRzKSA9PiB7XG4gICAgICByZXR1cm4gcG9pbnRzLmZsYXRNYXAoKHApID0+IHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocCkgPyBpbnRlcnBvbGF0ZVBvaW50cyhwKSA6IG5ldyBBcnJheShwLnNraXApLmZpbGwobnVsbCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGRhdGFWYWx1ZXMgPSBncm91cGVkRGF0YT8uZmxhdE1hcCgoZGF0dW1Hcm91cCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBrZXlzOiBbeERhdHVtXSxcbiAgICAgICAgdmFsdWVzOiB2YWx1ZXNBcnJheVxuICAgICAgfSA9IGRhdHVtR3JvdXA7XG4gICAgICByZXR1cm4gdmFsdWVzQXJyYXkubWFwKCh2YWx1ZXMpID0+ICh7IHhEYXR1bSwgdmFsdWVzIH0pKTtcbiAgICB9KTtcbiAgICBjb25zdCBjcmVhdGVQb2ludCA9ICh4RGF0dW0sIHlEYXR1bSkgPT4gKHtcbiAgICAgIHBvaW50OiB7XG4gICAgICAgIHg6IHhTY2FsZS5jb252ZXJ0KHhEYXR1bSkgKyB4T2Zmc2V0LFxuICAgICAgICB5OiB5U2NhbGUuY29udmVydCh5RGF0dW0pXG4gICAgICB9LFxuICAgICAgeERhdHVtLFxuICAgICAgeURhdHVtXG4gICAgfSk7XG4gICAgY29uc3QgZ2V0U2VyaWVzU3BhbnMgPSAoaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuICAgICAgaWYgKGRhdGFWYWx1ZXMgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhVmFsdWVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IHsgeERhdHVtLCB2YWx1ZXMgfSA9IGRhdGFWYWx1ZXNbaV07XG4gICAgICAgIGNvbnN0IHlWYWx1ZVN0YWNrID0gdmFsdWVzW3lWYWx1ZVN0YWNrSW5kZXhdO1xuICAgICAgICBjb25zdCB5RGF0dW0gPSB5VmFsdWVTdGFja1tpbmRleF07XG4gICAgICAgIGNvbnN0IHlEYXR1bUlzRmluaXRlID0gTnVtYmVyLmlzRmluaXRlKHlEYXR1bSk7XG4gICAgICAgIGlmIChjb25uZWN0TWlzc2luZ0RhdGEgJiYgIXlEYXR1bUlzRmluaXRlKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBsYXN0WVZhbHVlU3RhY2sgPSBkYXRhVmFsdWVzW2kgLSAxXT8udmFsdWVzW3lWYWx1ZVN0YWNrSW5kZXhdO1xuICAgICAgICBjb25zdCBuZXh0WVZhbHVlU3RhY2sgPSBkYXRhVmFsdWVzW2kgKyAxXT8udmFsdWVzW3lWYWx1ZVN0YWNrSW5kZXhdO1xuICAgICAgICBsZXQgeVZhbHVlRW5kQmFja3dhcmRzID0gMDtcbiAgICAgICAgbGV0IHlWYWx1ZUVuZEZvcndhcmRzID0gMDtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPD0gaW5kZXg7IGogKz0gMSkge1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0geVZhbHVlU3RhY2tbal07XG4gICAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RXYXNGaW5pdGUgPSBsYXN0WVZhbHVlU3RhY2sgPT0gbnVsbCB8fCBOdW1iZXIuaXNGaW5pdGUobGFzdFlWYWx1ZVN0YWNrW2pdKTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRXYXNGaW5pdGUgPSBuZXh0WVZhbHVlU3RhY2sgPT0gbnVsbCB8fCBOdW1iZXIuaXNGaW5pdGUobmV4dFlWYWx1ZVN0YWNrW2pdKTtcbiAgICAgICAgICAgIGlmIChsYXN0V2FzRmluaXRlKSB7XG4gICAgICAgICAgICAgIHlWYWx1ZUVuZEJhY2t3YXJkcyArPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0V2FzRmluaXRlKSB7XG4gICAgICAgICAgICAgIHlWYWx1ZUVuZEZvcndhcmRzICs9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50UG9pbnRzID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKCFjb25uZWN0TWlzc2luZ0RhdGEgJiYgKHlWYWx1ZUVuZEJhY2t3YXJkcyAhPT0geVZhbHVlRW5kRm9yd2FyZHMgfHwgIXlEYXR1bUlzRmluaXRlKSkge1xuICAgICAgICAgIGlmICgheURhdHVtSXNGaW5pdGUgJiYgQXJyYXkuaXNBcnJheShjdXJyZW50UG9pbnRzKSAmJiBjdXJyZW50UG9pbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSA9IHsgc2tpcDogMSB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwb2ludEJhY2t3YXJkcyA9IGNyZWF0ZVBvaW50KHhEYXR1bSwgeVZhbHVlRW5kQmFja3dhcmRzKTtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50Rm9yd2FyZHMgPSBjcmVhdGVQb2ludCh4RGF0dW0sIHlWYWx1ZUVuZEZvcndhcmRzKTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnRQb2ludHMpKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRQb2ludHMucHVzaChwb2ludEJhY2t3YXJkcyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRQb2ludHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBjdXJyZW50UG9pbnRzLnNraXAgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHlEYXR1bUlzRmluaXRlID8gW3BvaW50Rm9yd2FyZHNdIDogeyBza2lwOiAwIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCB5VmFsdWVFbmQgPSBNYXRoLm1heCh5VmFsdWVFbmRCYWNrd2FyZHMsIHlWYWx1ZUVuZEZvcndhcmRzKTtcbiAgICAgICAgICBjb25zdCBwb2ludCA9IGNyZWF0ZVBvaW50KHhEYXR1bSwgeVZhbHVlRW5kKTtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50UG9pbnRzKSkge1xuICAgICAgICAgICAgY3VycmVudFBvaW50cy5wdXNoKHBvaW50KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRQb2ludHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgY3VycmVudFBvaW50cy5za2lwICs9IDE7XG4gICAgICAgICAgICBwb2ludHMucHVzaChbcG9pbnRdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goW3BvaW50XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc3BhbnNGb3JQb2ludHMocG9pbnRzKTtcbiAgICB9O1xuICAgIGNvbnN0IHN0YWNrSW5kZXggPSB0aGlzLnNlcmllc0dyb3VwaW5nPy5zdGFja0luZGV4ID8/IDA7XG4gICAgY29uc3QgZ2V0QXhpc1NwYW5zID0gKCkgPT4ge1xuICAgICAgaWYgKGRhdGFWYWx1ZXMgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgY29uc3QgeVZhbHVlWmVyb1BvaW50cyA9IGRhdGFWYWx1ZXMubWFwKCh7IHhEYXR1bSwgdmFsdWVzIH0pID0+IHtcbiAgICAgICAgY29uc3QgeVZhbHVlU3RhY2sgPSB2YWx1ZXNbeVZhbHVlU3RhY2tJbmRleF07XG4gICAgICAgIGNvbnN0IHlEYXR1bSA9IHlWYWx1ZVN0YWNrW3N0YWNrSW5kZXhdO1xuICAgICAgICBpZiAoY29ubmVjdE1pc3NpbmdEYXRhICYmICFOdW1iZXIuaXNGaW5pdGUoeURhdHVtKSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJldHVybiBjcmVhdGVQb2ludCh4RGF0dW0sIDApO1xuICAgICAgfSkuZmlsdGVyKCh4KSA9PiB4ICE9IG51bGwpO1xuICAgICAgcmV0dXJuIGludGVycG9sYXRlUG9pbnRzKHlWYWx1ZVplcm9Qb2ludHMpO1xuICAgIH07XG4gICAgY29uc3QgY3VycmVudFNlcmllc1NwYW5zID0gZ2V0U2VyaWVzU3BhbnMoc3RhY2tJbmRleCk7XG4gICAgY29uc3QgcGhhbnRvbVNwYW5zID0gY3VycmVudFNlcmllc1NwYW5zLm1hcCgoKSA9PiBudWxsKTtcbiAgICBmb3IgKGxldCBqID0gc3RhY2tJbmRleCAtIDE7IGogPj0gLTE7IGogLT0gMSkge1xuICAgICAgbGV0IHNwYW5zO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwaGFudG9tU3BhbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKHBoYW50b21TcGFuc1tpXSAhPSBudWxsKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBzcGFucyA/PyAoc3BhbnMgPSBqICE9PSAtMSA/IGdldFNlcmllc1NwYW5zKGopIDogZ2V0QXhpc1NwYW5zKCkpO1xuICAgICAgICBwaGFudG9tU3BhbnNbaV0gPSBzcGFuc1tpXTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZmlsbFNwYW5zID0gY3VycmVudFNlcmllc1NwYW5zLm1hcCgoc3BhbiwgaW5kZXgpID0+IHNwYW4gPz8gcGhhbnRvbVNwYW5zW2luZGV4XSk7XG4gICAgY29uc3Qgc3Ryb2tlU3BhbnMgPSBjdXJyZW50U2VyaWVzU3BhbnMuZmlsdGVyKChzcGFuKSA9PiBzcGFuICE9IG51bGwpO1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBpdGVtSWQsXG4gICAgICBmaWxsRGF0YTogeyBpdGVtSWQsIHNwYW5zOiBmaWxsU3BhbnMsIHBoYW50b21TcGFucyB9LFxuICAgICAgc3Ryb2tlRGF0YTogeyBpdGVtSWQsIHNwYW5zOiBzdHJva2VTcGFucyB9LFxuICAgICAgbGFiZWxEYXRhLFxuICAgICAgbm9kZURhdGE6IG1hcmtlckRhdGEsXG4gICAgICBzY2FsZXM6IHRoaXMuY2FsY3VsYXRlU2NhbGluZygpLFxuICAgICAgdmlzaWJsZTogdGhpcy52aXNpYmxlLFxuICAgICAgc3RhY2tWaXNpYmxlOiB2aXNpYmxlU2FtZVN0YWNrQ291bnQgPiAwLFxuICAgICAgY3Jvc3NGaWx0ZXJpbmdcbiAgICB9O1xuICAgIHJldHVybiBjb250ZXh0O1xuICB9XG4gIGlzUGF0aE9yU2VsZWN0aW9uRGlydHkoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcGVydGllcy5tYXJrZXIuaXNEaXJ0eSgpO1xuICB9XG4gIG1hcmtlckZhY3RvcnkoKSB7XG4gICAgY29uc3QgeyBzaGFwZSB9ID0gdGhpcy5wcm9wZXJ0aWVzLm1hcmtlcjtcbiAgICBjb25zdCBNYXJrZXJTaGFwZSA9IGdldE1hcmtlcihzaGFwZSk7XG4gICAgcmV0dXJuIG5ldyBNYXJrZXJTaGFwZSgpO1xuICB9XG4gIGFzeW5jIHVwZGF0ZVBhdGhOb2RlcyhvcHRzKSB7XG4gICAgY29uc3QgeyBvcGFjaXR5LCB2aXNpYmxlLCBhbmltYXRpb25FbmFibGVkIH0gPSBvcHRzO1xuICAgIGNvbnN0IFtmaWxsLCBzdHJva2VdID0gb3B0cy5wYXRocztcbiAgICBjb25zdCBjcm9zc0ZpbHRlcmluZyA9IHRoaXMuY29udGV4dE5vZGVEYXRhPy5jcm9zc0ZpbHRlcmluZyA9PT0gdHJ1ZTtcbiAgICBjb25zdCBzdHJva2VXaWR0aCA9IHRoaXMuZ2V0U3Ryb2tlV2lkdGgodGhpcy5wcm9wZXJ0aWVzLnN0cm9rZVdpZHRoKTtcbiAgICBzdHJva2Uuc2V0UHJvcGVydGllcyh7XG4gICAgICBmaWxsOiB2b2lkIDAsXG4gICAgICBsaW5lSm9pbjogc3Ryb2tlLmxpbmVDYXAgPSBcInJvdW5kXCIsXG4gICAgICBwb2ludGVyRXZlbnRzOiAxIC8qIE5vbmUgKi8sXG4gICAgICBzdHJva2U6IHRoaXMucHJvcGVydGllcy5zdHJva2UsXG4gICAgICBzdHJva2VXaWR0aCxcbiAgICAgIHN0cm9rZU9wYWNpdHk6IHRoaXMucHJvcGVydGllcy5zdHJva2VPcGFjaXR5ICogKGNyb3NzRmlsdGVyaW5nID8gQ1JPU1NfRklMVEVSX0FSRUFfU1RST0tFX09QQUNJVFlfRkFDVE9SIDogMSksXG4gICAgICBsaW5lRGFzaDogdGhpcy5wcm9wZXJ0aWVzLmxpbmVEYXNoLFxuICAgICAgbGluZURhc2hPZmZzZXQ6IHRoaXMucHJvcGVydGllcy5saW5lRGFzaE9mZnNldCxcbiAgICAgIG9wYWNpdHksXG4gICAgICB2aXNpYmxlOiB2aXNpYmxlIHx8IGFuaW1hdGlvbkVuYWJsZWRcbiAgICB9KTtcbiAgICBmaWxsLnNldFByb3BlcnRpZXMoe1xuICAgICAgc3Ryb2tlOiB2b2lkIDAsXG4gICAgICBsaW5lSm9pbjogXCJyb3VuZFwiLFxuICAgICAgcG9pbnRlckV2ZW50czogMSAvKiBOb25lICovLFxuICAgICAgZmlsbDogdGhpcy5wcm9wZXJ0aWVzLmZpbGwsXG4gICAgICBmaWxsT3BhY2l0eTogdGhpcy5wcm9wZXJ0aWVzLmZpbGxPcGFjaXR5ICogKGNyb3NzRmlsdGVyaW5nID8gQ1JPU1NfRklMVEVSX0FSRUFfRklMTF9PUEFDSVRZX0ZBQ1RPUiA6IDEpLFxuICAgICAgZmlsbFNoYWRvdzogdGhpcy5wcm9wZXJ0aWVzLnNoYWRvdyxcbiAgICAgIG9wYWNpdHksXG4gICAgICB2aXNpYmxlOiB2aXNpYmxlIHx8IGFuaW1hdGlvbkVuYWJsZWRcbiAgICB9KTtcbiAgICB1cGRhdGVDbGlwUGF0aCh0aGlzLCBzdHJva2UpO1xuICAgIHVwZGF0ZUNsaXBQYXRoKHRoaXMsIGZpbGwpO1xuICB9XG4gIGFzeW5jIHVwZGF0ZVBhdGhzKG9wdHMpIHtcbiAgICB0aGlzLnVwZGF0ZUFyZWFQYXRocyhvcHRzLnBhdGhzLCBvcHRzLmNvbnRleHREYXRhKTtcbiAgfVxuICB1cGRhdGVBcmVhUGF0aHMocGF0aHMsIGNvbnRleHREYXRhKSB7XG4gICAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzKSB7XG4gICAgICBwYXRoLnZpc2libGUgPSBjb250ZXh0RGF0YS52aXNpYmxlO1xuICAgIH1cbiAgICBpZiAoY29udGV4dERhdGEudmlzaWJsZSkge1xuICAgICAgdGhpcy51cGRhdGVGaWxsUGF0aChwYXRocywgY29udGV4dERhdGEpO1xuICAgICAgdGhpcy51cGRhdGVTdHJva2VQYXRoKHBhdGhzLCBjb250ZXh0RGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgICAgICBwYXRoLnBhdGguY2xlYXIoKTtcbiAgICAgICAgcGF0aC5jaGVja1BhdGhEaXJ0eSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB1cGRhdGVGaWxsUGF0aChwYXRocywgY29udGV4dERhdGEpIHtcbiAgICBjb25zdCB7IHNwYW5zLCBwaGFudG9tU3BhbnMgfSA9IGNvbnRleHREYXRhLmZpbGxEYXRhO1xuICAgIGNvbnN0IFtmaWxsXSA9IHBhdGhzO1xuICAgIGNvbnN0IHsgcGF0aCB9ID0gZmlsbDtcbiAgICBwYXRoLmNsZWFyKHRydWUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3BhbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGNvbnN0IHsgc3BhbiB9ID0gc3BhbnNbaV07XG4gICAgICBjb25zdCBwaGFudG9tU3BhbiA9IHBoYW50b21TcGFuc1tpXS5zcGFuO1xuICAgICAgcGxvdFNwYW4ocGF0aCwgc3BhbiwgMSAvKiBNb3ZlVG8gKi8sIGZhbHNlKTtcbiAgICAgIHBsb3RTcGFuKHBhdGgsIHBoYW50b21TcGFuLCAyIC8qIExpbmVUbyAqLywgdHJ1ZSk7XG4gICAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgICBmaWxsLmNoZWNrUGF0aERpcnR5KCk7XG4gIH1cbiAgdXBkYXRlU3Ryb2tlUGF0aChwYXRocywgY29udGV4dERhdGEpIHtcbiAgICBjb25zdCB7IHNwYW5zIH0gPSBjb250ZXh0RGF0YS5zdHJva2VEYXRhO1xuICAgIGNvbnN0IFssIHN0cm9rZV0gPSBwYXRocztcbiAgICBjb25zdCB7IHBhdGggfSA9IHN0cm9rZTtcbiAgICBwYXRoLmNsZWFyKHRydWUpO1xuICAgIGZvciAoY29uc3QgeyBzcGFuIH0gb2Ygc3BhbnMpIHtcbiAgICAgIHBsb3RTcGFuKHBhdGgsIHNwYW4sIDEgLyogTW92ZVRvICovLCBmYWxzZSk7XG4gICAgfVxuICAgIHN0cm9rZS5jaGVja1BhdGhEaXJ0eSgpO1xuICB9XG4gIGFzeW5jIHVwZGF0ZU1hcmtlclNlbGVjdGlvbihvcHRzKSB7XG4gICAgY29uc3QgeyBub2RlRGF0YSwgbWFya2VyU2VsZWN0aW9uIH0gPSBvcHRzO1xuICAgIGNvbnN0IG1hcmtlcnNFbmFibGVkID0gdGhpcy5wcm9wZXJ0aWVzLm1hcmtlci5lbmFibGVkIHx8IHRoaXMuY29udGV4dE5vZGVEYXRhPy5jcm9zc0ZpbHRlcmluZyA9PT0gdHJ1ZTtcbiAgICBpZiAodGhpcy5wcm9wZXJ0aWVzLm1hcmtlci5pc0RpcnR5KCkpIHtcbiAgICAgIG1hcmtlclNlbGVjdGlvbi5jbGVhcigpO1xuICAgICAgbWFya2VyU2VsZWN0aW9uLmNsZWFudXAoKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcmtlclNlbGVjdGlvbi51cGRhdGUobWFya2Vyc0VuYWJsZWQgPyBub2RlRGF0YSA6IFtdKTtcbiAgfVxuICBhc3luYyB1cGRhdGVNYXJrZXJOb2RlcyhvcHRzKSB7XG4gICAgY29uc3QgeyBtYXJrZXJTZWxlY3Rpb24sIGlzSGlnaGxpZ2h0OiBoaWdobGlnaHRlZCB9ID0gb3B0cztcbiAgICBjb25zdCB7IHhLZXksIHlLZXksIG1hcmtlciwgZmlsbCwgc3Ryb2tlLCBzdHJva2VXaWR0aCwgZmlsbE9wYWNpdHksIHN0cm9rZU9wYWNpdHksIGhpZ2hsaWdodFN0eWxlIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgYmFzZVN0eWxlID0gbWVyZ2VEZWZhdWx0cyhoaWdobGlnaHRlZCAmJiBoaWdobGlnaHRTdHlsZS5pdGVtLCBtYXJrZXIuZ2V0U3R5bGUoKSwge1xuICAgICAgZmlsbCxcbiAgICAgIHN0cm9rZSxcbiAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgZmlsbE9wYWNpdHksXG4gICAgICBzdHJva2VPcGFjaXR5XG4gICAgfSk7XG4gICAgbWFya2VyU2VsZWN0aW9uLmVhY2goKG5vZGUsIGRhdHVtKSA9PiB7XG4gICAgICB0aGlzLnVwZGF0ZU1hcmtlclN0eWxlKG5vZGUsIG1hcmtlciwgeyBkYXR1bSwgaGlnaGxpZ2h0ZWQsIHhLZXksIHlLZXkgfSwgYmFzZVN0eWxlLCB7XG4gICAgICAgIHNlbGVjdGVkOiBkYXR1bS5zZWxlY3RlZFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKCFoaWdobGlnaHRlZCkge1xuICAgICAgdGhpcy5wcm9wZXJ0aWVzLm1hcmtlci5tYXJrQ2xlYW4oKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgdXBkYXRlTGFiZWxTZWxlY3Rpb24ob3B0cykge1xuICAgIGNvbnN0IHsgbGFiZWxEYXRhLCBsYWJlbFNlbGVjdGlvbiB9ID0gb3B0cztcbiAgICByZXR1cm4gbGFiZWxTZWxlY3Rpb24udXBkYXRlKGxhYmVsRGF0YSk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlTGFiZWxOb2RlcyhvcHRzKSB7XG4gICAgY29uc3QgeyBsYWJlbFNlbGVjdGlvbiB9ID0gb3B0cztcbiAgICBjb25zdCB7IGVuYWJsZWQ6IGxhYmVsRW5hYmxlZCwgZm9udFN0eWxlLCBmb250V2VpZ2h0LCBmb250U2l6ZSwgZm9udEZhbWlseSwgY29sb3IgfSA9IHRoaXMucHJvcGVydGllcy5sYWJlbDtcbiAgICBsYWJlbFNlbGVjdGlvbi5lYWNoKCh0ZXh0LCBkYXR1bSkgPT4ge1xuICAgICAgY29uc3QgeyB4LCB5LCBsYWJlbFRleHQgfSA9IGRhdHVtO1xuICAgICAgaWYgKGxhYmVsVGV4dCAmJiBsYWJlbEVuYWJsZWQgJiYgdGhpcy52aXNpYmxlKSB7XG4gICAgICAgIHRleHQuZm9udFN0eWxlID0gZm9udFN0eWxlO1xuICAgICAgICB0ZXh0LmZvbnRXZWlnaHQgPSBmb250V2VpZ2h0O1xuICAgICAgICB0ZXh0LmZvbnRTaXplID0gZm9udFNpemU7XG4gICAgICAgIHRleHQuZm9udEZhbWlseSA9IGZvbnRGYW1pbHk7XG4gICAgICAgIHRleHQudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICAgICAgdGV4dC50ZXh0QmFzZWxpbmUgPSBcImJvdHRvbVwiO1xuICAgICAgICB0ZXh0LnRleHQgPSBsYWJlbFRleHQ7XG4gICAgICAgIHRleHQueCA9IHg7XG4gICAgICAgIHRleHQueSA9IHkgLSAxMDtcbiAgICAgICAgdGV4dC5maWxsID0gY29sb3I7XG4gICAgICAgIHRleHQudmlzaWJsZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZXh0LnZpc2libGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXRUb29sdGlwSHRtbChub2RlRGF0dW0pIHtcbiAgICBjb25zdCB7IGlkOiBzZXJpZXNJZCwgYXhlcywgZGF0YU1vZGVsIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgeEtleSwgeE5hbWUsIHlOYW1lLCB0b29sdGlwLCBtYXJrZXIgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCB7IHlLZXksIHhWYWx1ZSwgeVZhbHVlLCBkYXR1bSwgaXRlbUlkIH0gPSBub2RlRGF0dW07XG4gICAgY29uc3QgeEF4aXMgPSBheGVzW1wieFwiIC8qIFggKi9dO1xuICAgIGNvbnN0IHlBeGlzID0gYXhlc1tcInlcIiAvKiBZICovXTtcbiAgICBpZiAoIXRoaXMucHJvcGVydGllcy5pc1ZhbGlkKCkgfHwgISh4QXhpcyAmJiB5QXhpcyAmJiBpc0Zpbml0ZU51bWJlcih5VmFsdWUpKSB8fCAhZGF0YU1vZGVsKSB7XG4gICAgICByZXR1cm4gRU1QVFlfVE9PTFRJUF9DT05URU5UO1xuICAgIH1cbiAgICBjb25zdCB4U3RyaW5nID0geEF4aXMuZm9ybWF0RGF0dW0oeFZhbHVlKTtcbiAgICBjb25zdCB5U3RyaW5nID0geUF4aXMuZm9ybWF0RGF0dW0oeVZhbHVlKTtcbiAgICBjb25zdCB0aXRsZSA9IHNhbml0aXplSHRtbCh5TmFtZSk7XG4gICAgY29uc3QgY29udGVudCA9IHNhbml0aXplSHRtbCh4U3RyaW5nICsgXCI6IFwiICsgeVN0cmluZyk7XG4gICAgY29uc3QgYmFzZVN0eWxlID0gbWVyZ2VEZWZhdWx0cyh7IGZpbGw6IHRoaXMucHJvcGVydGllcy5maWxsIH0sIG1hcmtlci5nZXRTdHlsZSgpLCB7XG4gICAgICBzdHJva2U6IHRoaXMucHJvcGVydGllcy5zdHJva2UsXG4gICAgICBzdHJva2VXaWR0aDogdGhpcy5wcm9wZXJ0aWVzLnN0cm9rZVdpZHRoXG4gICAgfSk7XG4gICAgY29uc3QgeyBmaWxsOiBjb2xvciB9ID0gdGhpcy5nZXRNYXJrZXJTdHlsZShcbiAgICAgIG1hcmtlcixcbiAgICAgIHsgZGF0dW06IG5vZGVEYXR1bSwgeEtleSwgeUtleSwgaGlnaGxpZ2h0ZWQ6IGZhbHNlIH0sXG4gICAgICBiYXNlU3R5bGVcbiAgICApO1xuICAgIHJldHVybiB0b29sdGlwLnRvVG9vbHRpcEh0bWwoXG4gICAgICB7IHRpdGxlLCBjb250ZW50LCBiYWNrZ3JvdW5kQ29sb3I6IGNvbG9yIH0sXG4gICAgICB7XG4gICAgICAgIGRhdHVtLFxuICAgICAgICBpdGVtSWQsXG4gICAgICAgIHhLZXksXG4gICAgICAgIHhOYW1lLFxuICAgICAgICB5S2V5LFxuICAgICAgICB5TmFtZSxcbiAgICAgICAgY29sb3IsXG4gICAgICAgIHRpdGxlLFxuICAgICAgICBzZXJpZXNJZFxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgZ2V0TGVnZW5kRGF0YShsZWdlbmRUeXBlKSB7XG4gICAgaWYgKCF0aGlzLmRhdGE/Lmxlbmd0aCB8fCAhdGhpcy5wcm9wZXJ0aWVzLmlzVmFsaWQoKSB8fCAhdGhpcy5wcm9wZXJ0aWVzLnNob3dJbkxlZ2VuZCB8fCBsZWdlbmRUeXBlICE9PSBcImNhdGVnb3J5XCIpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgeUtleSxcbiAgICAgIHlOYW1lLFxuICAgICAgZmlsbCxcbiAgICAgIHN0cm9rZSxcbiAgICAgIGZpbGxPcGFjaXR5LFxuICAgICAgc3Ryb2tlT3BhY2l0eSxcbiAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgbGluZURhc2gsXG4gICAgICBtYXJrZXIsXG4gICAgICB2aXNpYmxlLFxuICAgICAgbGVnZW5kSXRlbU5hbWVcbiAgICB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHVzZUFyZWFGaWxsID0gIW1hcmtlci5lbmFibGVkIHx8IG1hcmtlci5maWxsID09PSB2b2lkIDA7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgbGVnZW5kVHlwZSxcbiAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgIGl0ZW1JZDogeUtleSxcbiAgICAgICAgc2VyaWVzSWQ6IHRoaXMuaWQsXG4gICAgICAgIGVuYWJsZWQ6IHZpc2libGUsXG4gICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgdGV4dDogbGVnZW5kSXRlbU5hbWUgPz8geU5hbWUgPz8geUtleVxuICAgICAgICB9LFxuICAgICAgICBzeW1ib2xzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgbWFya2VyOiB7XG4gICAgICAgICAgICAgIHNoYXBlOiBtYXJrZXIuc2hhcGUsXG4gICAgICAgICAgICAgIGZpbGw6IHVzZUFyZWFGaWxsID8gZmlsbCA6IG1hcmtlci5maWxsLFxuICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogdXNlQXJlYUZpbGwgPyBmaWxsT3BhY2l0eSA6IG1hcmtlci5maWxsT3BhY2l0eSxcbiAgICAgICAgICAgICAgc3Ryb2tlOiBtYXJrZXIuc3Ryb2tlID8/IHN0cm9rZSxcbiAgICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogbWFya2VyLnN0cm9rZU9wYWNpdHkgPz8gc3Ryb2tlT3BhY2l0eSxcbiAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IG1hcmtlci5zdHJva2VXaWR0aCA/PyAwLFxuICAgICAgICAgICAgICBlbmFibGVkOiBtYXJrZXIuZW5hYmxlZCB8fCBzdHJva2VXaWR0aCA8PSAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGluZToge1xuICAgICAgICAgICAgICBzdHJva2UsXG4gICAgICAgICAgICAgIHN0cm9rZU9wYWNpdHksXG4gICAgICAgICAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgICAgICAgICBsaW5lRGFzaFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgbGVnZW5kSXRlbU5hbWVcbiAgICAgIH1cbiAgICBdO1xuICB9XG4gIGFuaW1hdGVFbXB0eVVwZGF0ZVJlYWR5KGFuaW1hdGlvbkRhdGEpIHtcbiAgICBjb25zdCB7IG1hcmtlclNlbGVjdGlvbiwgbGFiZWxTZWxlY3Rpb24sIGNvbnRleHREYXRhLCBwYXRocyB9ID0gYW5pbWF0aW9uRGF0YTtcbiAgICBjb25zdCB7IGFuaW1hdGlvbk1hbmFnZXIgfSA9IHRoaXMuY3R4O1xuICAgIHRoaXMudXBkYXRlQXJlYVBhdGhzKHBhdGhzLCBjb250ZXh0RGF0YSk7XG4gICAgcGF0aFN3aXBlSW5BbmltYXRpb24odGhpcywgYW5pbWF0aW9uTWFuYWdlciwgLi4ucGF0aHMpO1xuICAgIHJlc2V0TW90aW9uKFttYXJrZXJTZWxlY3Rpb25dLCByZXNldE1hcmtlclBvc2l0aW9uRm4pO1xuICAgIG1hcmtlclN3aXBlU2NhbGVJbkFuaW1hdGlvbih0aGlzLCBhbmltYXRpb25NYW5hZ2VyLCBtYXJrZXJTZWxlY3Rpb24pO1xuICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwibGFiZWxzXCIsIGFuaW1hdGlvbk1hbmFnZXIsIGxhYmVsU2VsZWN0aW9uKTtcbiAgfVxuICBhbmltYXRlUmVhZHlSZXNpemUoYW5pbWF0aW9uRGF0YSkge1xuICAgIGNvbnN0IHsgY29udGV4dERhdGEsIHBhdGhzIH0gPSBhbmltYXRpb25EYXRhO1xuICAgIHRoaXMudXBkYXRlQXJlYVBhdGhzKHBhdGhzLCBjb250ZXh0RGF0YSk7XG4gICAgc3VwZXIuYW5pbWF0ZVJlYWR5UmVzaXplKGFuaW1hdGlvbkRhdGEpO1xuICB9XG4gIGFuaW1hdGVXYWl0aW5nVXBkYXRlUmVhZHkoYW5pbWF0aW9uRGF0YSkge1xuICAgIGNvbnN0IHsgYW5pbWF0aW9uTWFuYWdlciB9ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgeyBtYXJrZXJTZWxlY3Rpb24sIGxhYmVsU2VsZWN0aW9uLCBjb250ZXh0RGF0YSwgcGF0aHMsIHByZXZpb3VzQ29udGV4dERhdGEgfSA9IGFuaW1hdGlvbkRhdGE7XG4gICAgY29uc3QgW2ZpbGwsIHN0cm9rZV0gPSBwYXRocztcbiAgICBpZiAoZmlsbCA9PSBudWxsICYmIHN0cm9rZSA9PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMucmVzZXRNYXJrZXJBbmltYXRpb24oYW5pbWF0aW9uRGF0YSk7XG4gICAgdGhpcy5yZXNldExhYmVsQW5pbWF0aW9uKGFuaW1hdGlvbkRhdGEpO1xuICAgIGNvbnN0IHVwZGF0ZSA9ICgpID0+IHtcbiAgICAgIHRoaXMucmVzZXRQYXRoQW5pbWF0aW9uKGFuaW1hdGlvbkRhdGEpO1xuICAgICAgdGhpcy51cGRhdGVBcmVhUGF0aHMocGF0aHMsIGNvbnRleHREYXRhKTtcbiAgICB9O1xuICAgIGNvbnN0IHNraXAgPSAoKSA9PiB7XG4gICAgICBhbmltYXRpb25NYW5hZ2VyLnNraXBDdXJyZW50QmF0Y2goKTtcbiAgICAgIHVwZGF0ZSgpO1xuICAgIH07XG4gICAgaWYgKGNvbnRleHREYXRhID09IG51bGwgfHwgcHJldmlvdXNDb250ZXh0RGF0YSA9PSBudWxsKSB7XG4gICAgICB1cGRhdGUoKTtcbiAgICAgIG1hcmtlckZhZGVJbkFuaW1hdGlvbih0aGlzLCBhbmltYXRpb25NYW5hZ2VyLCBcImFkZGVkXCIsIG1hcmtlclNlbGVjdGlvbik7XG4gICAgICBwYXRoRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwiZmlsbF9wYXRoX3Byb3BlcnRpZXNcIiwgYW5pbWF0aW9uTWFuYWdlciwgXCJhZGRcIiwgZmlsbCk7XG4gICAgICBwYXRoRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwic3Ryb2tlX3BhdGhfcHJvcGVydGllc1wiLCBhbmltYXRpb25NYW5hZ2VyLCBcImFkZFwiLCBzdHJva2UpO1xuICAgICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJsYWJlbHNcIiwgYW5pbWF0aW9uTWFuYWdlciwgbGFiZWxTZWxlY3Rpb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY29udGV4dERhdGEuY3Jvc3NGaWx0ZXJpbmcgIT09IHByZXZpb3VzQ29udGV4dERhdGEuY3Jvc3NGaWx0ZXJpbmcpIHtcbiAgICAgIHNraXAoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZm5zID0gcHJlcGFyZUFyZWFQYXRoQW5pbWF0aW9uKGNvbnRleHREYXRhLCBwcmV2aW91c0NvbnRleHREYXRhKTtcbiAgICBpZiAoZm5zID09PSB2b2lkIDApIHtcbiAgICAgIHNraXAoKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKGZucy5zdGF0dXMgPT09IFwibm8tb3BcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBtYXJrZXJGYWRlSW5BbmltYXRpb24odGhpcywgYW5pbWF0aW9uTWFuYWdlciwgdm9pZCAwLCBtYXJrZXJTZWxlY3Rpb24pO1xuICAgIGZyb21Ub01vdGlvbih0aGlzLmlkLCBcImZpbGxfcGF0aF9wcm9wZXJ0aWVzXCIsIGFuaW1hdGlvbk1hbmFnZXIsIFtmaWxsXSwgZm5zLmZpbGwucGF0aFByb3BlcnRpZXMpO1xuICAgIHBhdGhNb3Rpb24odGhpcy5pZCwgXCJmaWxsX3BhdGhfdXBkYXRlXCIsIGFuaW1hdGlvbk1hbmFnZXIsIFtmaWxsXSwgZm5zLmZpbGwucGF0aCk7XG4gICAgZnJvbVRvTW90aW9uKHRoaXMuaWQsIFwic3Ryb2tlX3BhdGhfcHJvcGVydGllc1wiLCBhbmltYXRpb25NYW5hZ2VyLCBbc3Ryb2tlXSwgZm5zLnN0cm9rZS5wYXRoUHJvcGVydGllcyk7XG4gICAgcGF0aE1vdGlvbih0aGlzLmlkLCBcInN0cm9rZV9wYXRoX3VwZGF0ZVwiLCBhbmltYXRpb25NYW5hZ2VyLCBbc3Ryb2tlXSwgZm5zLnN0cm9rZS5wYXRoKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImxhYmVsc1wiLCBhbmltYXRpb25NYW5hZ2VyLCBsYWJlbFNlbGVjdGlvbik7XG4gICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5hbmltYXRlKHtcbiAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgZ3JvdXBJZDogXCJyZXNldF9hZnRlcl9hbmltYXRpb25cIixcbiAgICAgIHBoYXNlOiBcInRyYWlsaW5nXCIsXG4gICAgICBmcm9tOiB7fSxcbiAgICAgIHRvOiB7fSxcbiAgICAgIG9uQ29tcGxldGU6ICgpID0+IHRoaXMudXBkYXRlQXJlYVBhdGhzKHBhdGhzLCBjb250ZXh0RGF0YSlcbiAgICB9KTtcbiAgfVxuICBpc0xhYmVsRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLmxhYmVsLmVuYWJsZWQ7XG4gIH1cbiAgbm9kZUZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIG5ldyBHcm91cCgpO1xuICB9XG4gIGdldEZvcm1hdHRlZE1hcmtlclN0eWxlKGRhdHVtKSB7XG4gICAgY29uc3QgeyB4S2V5LCB5S2V5IH0gPSBkYXR1bTtcbiAgICByZXR1cm4gdGhpcy5nZXRNYXJrZXJTdHlsZSh0aGlzLnByb3BlcnRpZXMubWFya2VyLCB7IGRhdHVtLCB4S2V5LCB5S2V5LCBoaWdobGlnaHRlZDogdHJ1ZSB9KTtcbiAgfVxuICBjb21wdXRlRm9jdXNCb3VuZHMob3B0cykge1xuICAgIHJldHVybiBjb21wdXRlTWFya2VyRm9jdXNCb3VuZHModGhpcywgb3B0cyk7XG4gIH1cbn07XG5BcmVhU2VyaWVzLmNsYXNzTmFtZSA9IFwiQXJlYVNlcmllc1wiO1xuQXJlYVNlcmllcy50eXBlID0gXCJhcmVhXCI7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vYXJlYVNlcmllc01vZHVsZS50c1xudmFyIEFyZWFTZXJpZXNNb2R1bGUgPSB7XG4gIHR5cGU6IFwic2VyaWVzXCIsXG4gIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIixcbiAgcGFja2FnZVR5cGU6IFwiY29tbXVuaXR5XCIsXG4gIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiXSxcbiAgaWRlbnRpZmllcjogXCJhcmVhXCIsXG4gIG1vZHVsZUZhY3Rvcnk6IChjdHgpID0+IG5ldyBBcmVhU2VyaWVzKGN0eCksXG4gIHN0YWNrYWJsZTogdHJ1ZSxcbiAgdG9vbHRpcERlZmF1bHRzOiB7IHJhbmdlOiBcIm5lYXJlc3RcIiB9LFxuICBkZWZhdWx0QXhlczogW1xuICAgIHtcbiAgICAgIHR5cGU6IFwibnVtYmVyXCIgLyogTlVNQkVSICovLFxuICAgICAgcG9zaXRpb246IFwibGVmdFwiIC8qIExFRlQgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIHR5cGU6IFwiY2F0ZWdvcnlcIiAvKiBDQVRFR09SWSAqLyxcbiAgICAgIHBvc2l0aW9uOiBcImJvdHRvbVwiIC8qIEJPVFRPTSAqL1xuICAgIH1cbiAgXSxcbiAgdGhlbWVUZW1wbGF0ZToge1xuICAgIHNlcmllczoge1xuICAgICAgbm9kZUNsaWNrUmFuZ2U6IFwibmVhcmVzdFwiLFxuICAgICAgdG9vbHRpcDogeyBwb3NpdGlvbjogeyB0eXBlOiBcIm5vZGVcIiB9IH0sXG4gICAgICBmaWxsT3BhY2l0eTogMC44LFxuICAgICAgc3Ryb2tlT3BhY2l0eTogMSxcbiAgICAgIHN0cm9rZVdpZHRoOiAwLFxuICAgICAgbGluZURhc2g6IFswXSxcbiAgICAgIGxpbmVEYXNoT2Zmc2V0OiAwLFxuICAgICAgc2hhZG93OiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBjb2xvcjogREVGQVVMVF9TSEFET1dfQ09MT1VSLFxuICAgICAgICB4T2Zmc2V0OiAzLFxuICAgICAgICB5T2Zmc2V0OiAzLFxuICAgICAgICBibHVyOiA1XG4gICAgICB9LFxuICAgICAgaW50ZXJwb2xhdGlvbjoge1xuICAgICAgICB0eXBlOiBcImxpbmVhclwiLFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gdXNlcnMgc2hvdWxkbid0IHNwZWNpZnkgYWxsIG9wdGlvbnMsIGJ1dCB3ZSBoYXZlIHRvIGZvciB0aGVtaW5nIHRvIHdvcmtcbiAgICAgICAgdGVuc2lvbjogMSxcbiAgICAgICAgcG9zaXRpb246IFwiZW5kXCJcbiAgICAgIH0sXG4gICAgICBtYXJrZXI6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIHNoYXBlOiBcImNpcmNsZVwiLFxuICAgICAgICBzaXplOiA3LFxuICAgICAgICBzdHJva2VXaWR0aDogMFxuICAgICAgfSxcbiAgICAgIGxhYmVsOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBmb250U2l6ZTogMTIsXG4gICAgICAgIGZvbnRGYW1pbHk6IERFRkFVTFRfRk9OVF9GQU1JTFksXG4gICAgICAgIGNvbG9yOiBERUZBVUxUX0xBQkVMX0NPTE9VUlxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcGFsZXR0ZUZhY3Rvcnk6IChwYXJhbXMpID0+IHtcbiAgICBjb25zdCB7IG1hcmtlciB9ID0gbWFya2VyUGFsZXR0ZUZhY3RvcnkocGFyYW1zKTtcbiAgICByZXR1cm4geyBmaWxsOiBtYXJrZXIuZmlsbCwgc3Ryb2tlOiBtYXJrZXIuc3Ryb2tlLCBtYXJrZXIgfTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvdGhlbWVzL3V0aWwudHNcbmZ1bmN0aW9uIHN3YXBBeGlzQ29uZGl0aW9uKGF4ZXMsIHN3YXApIHtcbiAgcmV0dXJuIChzZXJpZXMpID0+IHtcbiAgICBpZiAoIXN3YXAoc2VyaWVzKSlcbiAgICAgIHJldHVybiBheGVzO1xuICAgIHJldHVybiBbXG4gICAgICB7IC4uLmF4ZXNbMF0sIHBvc2l0aW9uOiBheGVzWzFdLnBvc2l0aW9uIH0sXG4gICAgICB7IC4uLmF4ZXNbMV0sIHBvc2l0aW9uOiBheGVzWzBdLnBvc2l0aW9uIH1cbiAgICBdO1xuICB9O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL3F1YWR0cmVlVXRpbC50c1xuZnVuY3Rpb24gYWRkSGl0VGVzdGVyc1RvUXVhZHRyZWUocXVhZHRyZWUsIGhpdFRlc3RlcnMpIHtcbiAgZm9yIChjb25zdCBub2RlIG9mIGhpdFRlc3RlcnMpIHtcbiAgICBjb25zdCBkYXR1bSA9IG5vZGUuZGF0dW07XG4gICAgaWYgKGRhdHVtID09PSB2b2lkIDApIHtcbiAgICAgIExvZ2dlci5lcnJvcihcInVuZGVmaW5lZCBkYXR1bVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcXVhZHRyZWUuYWRkVmFsdWUobm9kZSwgZGF0dW0pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZmluZFF1YWR0cmVlTWF0Y2goc2VyaWVzLCBwb2ludCkge1xuICBjb25zdCB7IHgsIHkgfSA9IHBvaW50O1xuICBjb25zdCB7IG5lYXJlc3QsIGRpc3RhbmNlU3F1YXJlZDogZGlzdGFuY2VTcXVhcmVkMyB9ID0gc2VyaWVzLmdldFF1YWRUcmVlKCkuZmluZCh4LCB5KTtcbiAgaWYgKG5lYXJlc3QgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiB7IGRhdHVtOiBuZWFyZXN0LnZhbHVlLCBkaXN0YW5jZTogTWF0aC5zcXJ0KGRpc3RhbmNlU3F1YXJlZDMpIH07XG4gIH1cbiAgcmV0dXJuIHZvaWQgMDtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9hYnN0cmFjdEJhclNlcmllcy50c1xudmFyIEFic3RyYWN0QmFyU2VyaWVzUHJvcGVydGllcyA9IGNsYXNzIGV4dGVuZHMgQ2FydGVzaWFuU2VyaWVzUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5kaXJlY3Rpb24gPSBcInZlcnRpY2FsXCI7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShESVJFQ1RJT04pXG5dLCBBYnN0cmFjdEJhclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImRpcmVjdGlvblwiLCAyKTtcbnZhciBBYnN0cmFjdEJhclNlcmllcyA9IGNsYXNzIGV4dGVuZHMgQ2FydGVzaWFuU2VyaWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGdldCB0aGUgcG9zaXRpb24gb2YgYmFycyB3aXRoaW4gZWFjaCBncm91cC5cbiAgICAgKi9cbiAgICB0aGlzLmdyb3VwU2NhbGUgPSBuZXcgQmFuZFNjYWxlKCk7XG4gICAgdGhpcy5zbWFsbGVzdERhdGFJbnRlcnZhbCA9IHZvaWQgMDtcbiAgICB0aGlzLmxhcmdlc3REYXRhSW50ZXJ2YWwgPSB2b2lkIDA7XG4gIH1cbiAgcGFkQmFuZEV4dGVudChrZXlzLCBhbGlnblN0YXJ0KSB7XG4gICAgY29uc3QgcmF0aW8yID0gdHlwZW9mIGFsaWduU3RhcnQgPT09IFwiYm9vbGVhblwiID8gMSA6IDAuNTtcbiAgICBjb25zdCBzY2FsZVBhZGRpbmcgPSBpc0Zpbml0ZU51bWJlcih0aGlzLnNtYWxsZXN0RGF0YUludGVydmFsKSA/IHRoaXMuc21hbGxlc3REYXRhSW50ZXJ2YWwgKiByYXRpbzIgOiAwO1xuICAgIGNvbnN0IGtleXNFeHRlbnQgPSBleHRlbnQoa2V5cykgPz8gW05hTiwgTmFOXTtcbiAgICBpZiAodHlwZW9mIGFsaWduU3RhcnQgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICBrZXlzRXh0ZW50W2FsaWduU3RhcnQgPyAwIDogMV0gLT0gKGFsaWduU3RhcnQgPyAxIDogLTEpICogc2NhbGVQYWRkaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzRXh0ZW50WzBdIC09IHNjYWxlUGFkZGluZztcbiAgICAgIGtleXNFeHRlbnRbMV0gKz0gc2NhbGVQYWRkaW5nO1xuICAgIH1cbiAgICByZXR1cm4gZml4TnVtZXJpY0V4dGVudChrZXlzRXh0ZW50KTtcbiAgfVxuICBnZXRCYW5kU2NhbGVQYWRkaW5nKCkge1xuICAgIHJldHVybiB7IGlubmVyOiAwLjMsIG91dGVyOiAwLjE1IH07XG4gIH1cbiAgc2hvdWxkRmxpcFhZKCkge1xuICAgIHJldHVybiAhdGhpcy5pc1ZlcnRpY2FsKCk7XG4gIH1cbiAgaXNWZXJ0aWNhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLmRpcmVjdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiO1xuICB9XG4gIGdldEJhckRpcmVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zaG91bGRGbGlwWFkoKSA/IFwieFwiIC8qIFggKi8gOiBcInlcIiAvKiBZICovO1xuICB9XG4gIGdldENhdGVnb3J5RGlyZWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnNob3VsZEZsaXBYWSgpID8gXCJ5XCIgLyogWSAqLyA6IFwieFwiIC8qIFggKi87XG4gIH1cbiAgZ2V0VmFsdWVBeGlzKCkge1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IHRoaXMuZ2V0QmFyRGlyZWN0aW9uKCk7XG4gICAgcmV0dXJuIHRoaXMuYXhlc1tkaXJlY3Rpb25dO1xuICB9XG4gIGdldENhdGVnb3J5QXhpcygpIHtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLmdldENhdGVnb3J5RGlyZWN0aW9uKCk7XG4gICAgcmV0dXJuIHRoaXMuYXhlc1tkaXJlY3Rpb25dO1xuICB9XG4gIGdldEJhbmR3aWR0aCh4QXhpcykge1xuICAgIHJldHVybiBDb250aW51b3VzU2NhbGUuaXMoeEF4aXMuc2NhbGUpID8geEF4aXMuc2NhbGUuY2FsY0JhbmR3aWR0aCh0aGlzLnNtYWxsZXN0RGF0YUludGVydmFsKSA6IHhBeGlzLnNjYWxlLmJhbmR3aWR0aDtcbiAgfVxuICB1cGRhdGVHcm91cFNjYWxlKHhBeGlzKSB7XG4gICAgY29uc3QgZG9tYWluID0gW107XG4gICAgY29uc3QgeyBncm91cFNjYWxlIH0gPSB0aGlzO1xuICAgIGNvbnN0IHhCYW5kV2lkdGggPSB0aGlzLmdldEJhbmR3aWR0aCh4QXhpcyk7XG4gICAgY29uc3QgeyBpbmRleDogZ3JvdXBJbmRleCwgdmlzaWJsZUdyb3VwQ291bnQgfSA9IHRoaXMuY3R4LnNlcmllc1N0YXRlTWFuYWdlci5nZXRWaXNpYmxlUGVlckdyb3VwSW5kZXgodGhpcyk7XG4gICAgZm9yIChsZXQgZ3JvdXBJZHggPSAwOyBncm91cElkeCA8IHZpc2libGVHcm91cENvdW50OyBncm91cElkeCsrKSB7XG4gICAgICBkb21haW4ucHVzaChTdHJpbmcoZ3JvdXBJZHgpKTtcbiAgICB9XG4gICAgZ3JvdXBTY2FsZS5kb21haW4gPSBkb21haW47XG4gICAgZ3JvdXBTY2FsZS5yYW5nZSA9IFswLCB4QmFuZFdpZHRoID8/IDBdO1xuICAgIGlmICh4QXhpcyBpbnN0YW5jZW9mIENhdGVnb3J5QXhpcykge1xuICAgICAgZ3JvdXBTY2FsZS5wYWRkaW5nSW5uZXIgPSB4QXhpcy5ncm91cFBhZGRpbmdJbm5lcjtcbiAgICB9IGVsc2UgaWYgKHhBeGlzIGluc3RhbmNlb2YgR3JvdXBlZENhdGVnb3J5QXhpcykge1xuICAgICAgZ3JvdXBTY2FsZS5wYWRkaW5nID0gMC4xO1xuICAgIH0gZWxzZSB7XG4gICAgICBncm91cFNjYWxlLnBhZGRpbmcgPSAwO1xuICAgIH1cbiAgICBncm91cFNjYWxlLnJvdW5kID0gZ3JvdXBTY2FsZS5wYWRkaW5nICE9PSAwO1xuICAgIGNvbnN0IGJhcldpZHRoID0gZ3JvdXBTY2FsZS5iYW5kd2lkdGggPj0gMSA/IChcbiAgICAgIC8vIFBpeGVsLXJvdW5kZWQgdmFsdWUgZm9yIGxvdy12b2x1bWUgYmFyIGNoYXJ0cy5cbiAgICAgIGdyb3VwU2NhbGUuYmFuZHdpZHRoXG4gICAgKSA6IChcbiAgICAgIC8vIEhhbmRsZSBoaWdoLXZvbHVtZSBiYXIgY2hhcnRzIGdyYWNlZnVsbHkuXG4gICAgICBncm91cFNjYWxlLnJhd0JhbmR3aWR0aFxuICAgICk7XG4gICAgcmV0dXJuIHsgYmFyV2lkdGgsIGdyb3VwSW5kZXggfTtcbiAgfVxuICByZXNvbHZlS2V5RGlyZWN0aW9uKGRpcmVjdGlvbikge1xuICAgIGlmICh0aGlzLmdldEJhckRpcmVjdGlvbigpID09PSBcInhcIiAvKiBYICovKSB7XG4gICAgICBpZiAoZGlyZWN0aW9uID09PSBcInhcIiAvKiBYICovKSB7XG4gICAgICAgIHJldHVybiBcInlcIiAvKiBZICovO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwieFwiIC8qIFggKi87XG4gICAgfVxuICAgIHJldHVybiBkaXJlY3Rpb247XG4gIH1cbiAgaW5pdFF1YWRUcmVlKHF1YWR0cmVlKSB7XG4gICAgYWRkSGl0VGVzdGVyc1RvUXVhZHRyZWUocXVhZHRyZWUsIHRoaXMuZGF0dW1Ob2Rlc0l0ZXIoKSk7XG4gIH1cbiAgcGlja05vZGVDbG9zZXN0RGF0dW0ocG9pbnQpIHtcbiAgICByZXR1cm4gZmluZFF1YWR0cmVlTWF0Y2godGhpcywgcG9pbnQpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2JhclNlcmllc1Byb3BlcnRpZXMudHNcbnZhciBCYXJTZXJpZXNMYWJlbCA9IGNsYXNzIGV4dGVuZHMgTGFiZWwge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMucGxhY2VtZW50ID0gXCJpbnNpZGUtY2VudGVyXCI7XG4gICAgdGhpcy5wYWRkaW5nID0gMDtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFxuICAgIFVOSU9OKFxuICAgICAgW1xuICAgICAgICBcImluc2lkZS1jZW50ZXJcIixcbiAgICAgICAgXCJpbnNpZGUtc3RhcnRcIixcbiAgICAgICAgXCJpbnNpZGUtZW5kXCIsXG4gICAgICAgIFwib3V0c2lkZS1zdGFydFwiLFxuICAgICAgICBcIm91dHNpZGUtZW5kXCIsXG4gICAgICAgIC8vIEB0b2RvKEFHLTU5NTApIERlcHJlY2F0ZVxuICAgICAgICB7IHZhbHVlOiBcImluc2lkZVwiLCBkZXByZWNhdGVkVG86IFwiaW5zaWRlLWNlbnRlclwiIH0sXG4gICAgICAgIHsgdmFsdWU6IFwib3V0c2lkZVwiLCBkZXByZWNhdGVkVG86IFwib3V0c2lkZS1lbmRcIiB9XG4gICAgICBdLFxuICAgICAgXCJhIHBsYWNlbWVudFwiXG4gICAgKVxuICApXG5dLCBCYXJTZXJpZXNMYWJlbC5wcm90b3R5cGUsIFwicGxhY2VtZW50XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTlVNQkVSKVxuXSwgQmFyU2VyaWVzTGFiZWwucHJvdG90eXBlLCBcInBhZGRpbmdcIiwgMik7XG52YXIgQmFyU2VyaWVzUHJvcGVydGllcyA9IGNsYXNzIGV4dGVuZHMgQWJzdHJhY3RCYXJTZXJpZXNQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmZpbGwgPSBcIiNjMTYwNjhcIjtcbiAgICB0aGlzLmZpbGxPcGFjaXR5ID0gMTtcbiAgICB0aGlzLnN0cm9rZSA9IFwiIzg3NDM0OVwiO1xuICAgIHRoaXMuc3Ryb2tlV2lkdGggPSAxO1xuICAgIHRoaXMuc3Ryb2tlT3BhY2l0eSA9IDE7XG4gICAgdGhpcy5saW5lRGFzaCA9IFswXTtcbiAgICB0aGlzLmxpbmVEYXNoT2Zmc2V0ID0gMDtcbiAgICB0aGlzLmNvcm5lclJhZGl1cyA9IDA7XG4gICAgdGhpcy5jcmlzcCA9IHZvaWQgMDtcbiAgICB0aGlzLnNoYWRvdyA9IG5ldyBEcm9wU2hhZG93KCk7XG4gICAgdGhpcy5sYWJlbCA9IG5ldyBCYXJTZXJpZXNMYWJlbCgpO1xuICAgIHRoaXMudG9vbHRpcCA9IG5ldyBTZXJpZXNUb29sdGlwKCk7XG4gICAgdGhpcy5zcGFya2xpbmVNb2RlID0gZmFsc2U7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcpXG5dLCBCYXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ4S2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBCYXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ4TmFtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORylcbl0sIEJhclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInlLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEJhclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInlOYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBCYXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ5RmlsdGVyS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBCYXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdGFja0dyb3VwXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTlVNQkVSLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBCYXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJub3JtYWxpemVkVG9cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcpXG5dLCBCYXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJmaWxsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8pXG5dLCBCYXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJmaWxsT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORylcbl0sIEJhclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0cm9rZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIEJhclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0cm9rZVdpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8pXG5dLCBCYXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdHJva2VPcGFjaXR5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTElORV9EQVNIKVxuXSwgQmFyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGluZURhc2hcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBCYXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJsaW5lRGFzaE9mZnNldFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIEJhclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNvcm5lclJhZGl1c1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEJhclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNyaXNwXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoRlVOQ1RJT04sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEJhclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcIml0ZW1TdHlsZXJcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEJhclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInNoYWRvd1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIEJhclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImxhYmVsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgQmFyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwidG9vbHRpcFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBCYXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzcGFya2xpbmVNb2RlXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2JhclV0aWwudHNcbmZ1bmN0aW9uIHVwZGF0ZVJlY3QocmVjdCwgY29uZmlnKSB7XG4gIHJlY3QuY3Jpc3AgPSBjb25maWcuY3Jpc3AgPz8gdHJ1ZTtcbiAgcmVjdC5maWxsID0gY29uZmlnLmZpbGw7XG4gIHJlY3Quc3Ryb2tlID0gY29uZmlnLnN0cm9rZTtcbiAgcmVjdC5zdHJva2VXaWR0aCA9IGNvbmZpZy5zdHJva2VXaWR0aDtcbiAgcmVjdC5maWxsT3BhY2l0eSA9IGNvbmZpZy5maWxsT3BhY2l0eTtcbiAgcmVjdC5zdHJva2VPcGFjaXR5ID0gY29uZmlnLnN0cm9rZU9wYWNpdHk7XG4gIHJlY3QubGluZURhc2ggPSBjb25maWcubGluZURhc2g7XG4gIHJlY3QubGluZURhc2hPZmZzZXQgPSBjb25maWcubGluZURhc2hPZmZzZXQ7XG4gIHJlY3QuZmlsbFNoYWRvdyA9IGNvbmZpZy5maWxsU2hhZG93O1xuICByZWN0LnRvcExlZnRDb3JuZXJSYWRpdXMgPSBjb25maWcudG9wTGVmdENvcm5lclJhZGl1cyAhPT0gZmFsc2UgPyBjb25maWcuY29ybmVyUmFkaXVzID8/IDAgOiAwO1xuICByZWN0LnRvcFJpZ2h0Q29ybmVyUmFkaXVzID0gY29uZmlnLnRvcFJpZ2h0Q29ybmVyUmFkaXVzICE9PSBmYWxzZSA/IGNvbmZpZy5jb3JuZXJSYWRpdXMgPz8gMCA6IDA7XG4gIHJlY3QuYm90dG9tUmlnaHRDb3JuZXJSYWRpdXMgPSBjb25maWcuYm90dG9tUmlnaHRDb3JuZXJSYWRpdXMgIT09IGZhbHNlID8gY29uZmlnLmNvcm5lclJhZGl1cyA/PyAwIDogMDtcbiAgcmVjdC5ib3R0b21MZWZ0Q29ybmVyUmFkaXVzID0gY29uZmlnLmJvdHRvbUxlZnRDb3JuZXJSYWRpdXMgIT09IGZhbHNlID8gY29uZmlnLmNvcm5lclJhZGl1cyA/PyAwIDogMDtcbiAgcmVjdC52aXNpYmxlID0gY29uZmlnLnZpc2libGUgPz8gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGdldFJlY3RDb25maWcoe1xuICBkYXR1bSxcbiAgaXNIaWdobGlnaHRlZCxcbiAgc3R5bGUsXG4gIGhpZ2hsaWdodFN0eWxlLFxuICBpdGVtU3R5bGVyLFxuICBzZXJpZXNJZCxcbiAgY3R4OiB7IGNhbGxiYWNrQ2FjaGUgfSxcbiAgLi4ub3B0c1xufSkge1xuICBjb25zdCB7XG4gICAgZmlsbCxcbiAgICBmaWxsT3BhY2l0eSxcbiAgICBzdHJva2UsXG4gICAgc3Ryb2tlV2lkdGgsXG4gICAgc3Ryb2tlT3BhY2l0eSxcbiAgICBsaW5lRGFzaCxcbiAgICBsaW5lRGFzaE9mZnNldCxcbiAgICBjb3JuZXJSYWRpdXMgPSAwXG4gIH0gPSBtZXJnZURlZmF1bHRzKGlzSGlnaGxpZ2h0ZWQgJiYgaGlnaGxpZ2h0U3R5bGUsIHN0eWxlKTtcbiAgbGV0IGZvcm1hdDtcbiAgaWYgKGl0ZW1TdHlsZXIpIHtcbiAgICBmb3JtYXQgPSBjYWxsYmFja0NhY2hlLmNhbGwoaXRlbVN0eWxlciwge1xuICAgICAgZGF0dW06IGRhdHVtLmRhdHVtLFxuICAgICAgeEtleTogZGF0dW0ueEtleSxcbiAgICAgIGZpbGwsXG4gICAgICBmaWxsT3BhY2l0eSxcbiAgICAgIHN0cm9rZSxcbiAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgc3Ryb2tlT3BhY2l0eSxcbiAgICAgIGxpbmVEYXNoLFxuICAgICAgbGluZURhc2hPZmZzZXQsXG4gICAgICBjb3JuZXJSYWRpdXMsXG4gICAgICBoaWdobGlnaHRlZDogaXNIaWdobGlnaHRlZCxcbiAgICAgIHNlcmllc0lkLFxuICAgICAgLi4ub3B0c1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgZmlsbDogZm9ybWF0Py5maWxsID8/IGZpbGwsXG4gICAgZmlsbE9wYWNpdHk6IGZvcm1hdD8uZmlsbE9wYWNpdHkgPz8gZmlsbE9wYWNpdHksXG4gICAgc3Ryb2tlOiBmb3JtYXQ/LnN0cm9rZSA/PyBzdHJva2UsXG4gICAgc3Ryb2tlV2lkdGg6IGZvcm1hdD8uc3Ryb2tlV2lkdGggPz8gc3Ryb2tlV2lkdGgsXG4gICAgc3Ryb2tlT3BhY2l0eTogZm9ybWF0Py5zdHJva2VPcGFjaXR5ID8/IHN0cm9rZU9wYWNpdHksXG4gICAgbGluZURhc2g6IGZvcm1hdD8ubGluZURhc2ggPz8gbGluZURhc2gsXG4gICAgbGluZURhc2hPZmZzZXQ6IGZvcm1hdD8ubGluZURhc2hPZmZzZXQgPz8gbGluZURhc2hPZmZzZXQsXG4gICAgY29ybmVyUmFkaXVzOiBmb3JtYXQ/LmNvcm5lclJhZGl1cyA/PyBjb3JuZXJSYWRpdXMsXG4gICAgdG9wTGVmdENvcm5lclJhZGl1czogc3R5bGUudG9wTGVmdENvcm5lclJhZGl1cyxcbiAgICB0b3BSaWdodENvcm5lclJhZGl1czogc3R5bGUudG9wUmlnaHRDb3JuZXJSYWRpdXMsXG4gICAgYm90dG9tUmlnaHRDb3JuZXJSYWRpdXM6IHN0eWxlLmJvdHRvbVJpZ2h0Q29ybmVyUmFkaXVzLFxuICAgIGJvdHRvbUxlZnRDb3JuZXJSYWRpdXM6IHN0eWxlLmJvdHRvbUxlZnRDb3JuZXJSYWRpdXMsXG4gICAgZmlsbFNoYWRvdzogc3R5bGUuZmlsbFNoYWRvd1xuICB9O1xufVxuZnVuY3Rpb24gY2hlY2tDcmlzcChzY2FsZTIsIHZpc2libGVSYW5nZSwgc21hbGxlc3REYXRhSW50ZXJ2YWwsIGxhcmdlc3REYXRhSW50ZXJ2YWwpIHtcbiAgaWYgKHZpc2libGVSYW5nZSAhPSBudWxsKSB7XG4gICAgY29uc3QgW3Zpc2libGVNaW4sIHZpc2libGVNYXhdID0gdmlzaWJsZVJhbmdlO1xuICAgIGNvbnN0IGlzWm9vbWVkID0gdmlzaWJsZU1pbiAhPT0gMCB8fCB2aXNpYmxlTWF4ICE9PSAxO1xuICAgIGlmIChpc1pvb21lZClcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoQ29udGludW91c1NjYWxlLmlzKHNjYWxlMikpIHtcbiAgICBjb25zdCBzcGFjaW5nID0gc2NhbGUyLmNhbGNCYW5kd2lkdGgobGFyZ2VzdERhdGFJbnRlcnZhbCkgLSBzY2FsZTIuY2FsY0JhbmR3aWR0aChzbWFsbGVzdERhdGFJbnRlcnZhbCk7XG4gICAgaWYgKHNwYWNpbmcgPiAwICYmIHNwYWNpbmcgPCAxKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxudmFyIGlzRGF0dW1OZWdhdGl2ZSA9IChkYXR1bSkgPT4ge1xuICByZXR1cm4gaXNOZWdhdGl2ZShkYXR1bS55VmFsdWUgPz8gMCk7XG59O1xuZnVuY3Rpb24gY29sbGFwc2VkU3RhcnRpbmdCYXJQb3NpdGlvbihpc1ZlcnRpY2FsLCBheGVzLCBtb2RlKSB7XG4gIGNvbnN0IHsgc3RhcnRpbmdYLCBzdGFydGluZ1kgfSA9IGdldFN0YXJ0aW5nVmFsdWVzKGlzVmVydGljYWwsIGF4ZXMpO1xuICBjb25zdCBjYWxjdWxhdGUgPSAoZGF0dW0sIHByZXZEYXR1bSkgPT4ge1xuICAgIGxldCB4ID0gaXNWZXJ0aWNhbCA/IGRhdHVtLnggOiBzdGFydGluZ1g7XG4gICAgbGV0IHkgPSBpc1ZlcnRpY2FsID8gc3RhcnRpbmdZIDogZGF0dW0ueTtcbiAgICBsZXQgd2lkdGgyID0gaXNWZXJ0aWNhbCA/IGRhdHVtLndpZHRoIDogMDtcbiAgICBsZXQgaGVpZ2h0MiA9IGlzVmVydGljYWwgPyAwIDogZGF0dW0uaGVpZ2h0O1xuICAgIGNvbnN0IHsgb3BhY2l0eSB9ID0gZGF0dW07XG4gICAgaWYgKHByZXZEYXR1bSAmJiAoaXNOYU4oeCkgfHwgaXNOYU4oeSkpKSB7XG4gICAgICAoeyB4LCB5IH0gPSBwcmV2RGF0dW0pO1xuICAgICAgd2lkdGgyID0gaXNWZXJ0aWNhbCA/IHByZXZEYXR1bS53aWR0aCA6IDA7XG4gICAgICBoZWlnaHQyID0gaXNWZXJ0aWNhbCA/IDAgOiBwcmV2RGF0dW0uaGVpZ2h0O1xuICAgICAgaWYgKGlzVmVydGljYWwgJiYgIWlzRGF0dW1OZWdhdGl2ZShwcmV2RGF0dW0pKSB7XG4gICAgICAgIHkgKz0gcHJldkRhdHVtLmhlaWdodDtcbiAgICAgIH0gZWxzZSBpZiAoIWlzVmVydGljYWwgJiYgaXNEYXR1bU5lZ2F0aXZlKHByZXZEYXR1bSkpIHtcbiAgICAgICAgeCArPSBwcmV2RGF0dW0ud2lkdGg7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBjbGlwQkJveDtcbiAgICBpZiAoZGF0dW0uY2xpcEJCb3ggPT0gbnVsbCkge1xuICAgICAgY2xpcEJCb3ggPSB2b2lkIDA7XG4gICAgfSBlbHNlIGlmIChpc0RhdHVtTmVnYXRpdmUoZGF0dW0pKSB7XG4gICAgICBjbGlwQkJveCA9IGlzVmVydGljYWwgPyBuZXcgQkJveCh4LCB5IC0gaGVpZ2h0Miwgd2lkdGgyLCBoZWlnaHQyKSA6IG5ldyBCQm94KHggLSB3aWR0aDIsIHksIHdpZHRoMiwgaGVpZ2h0Mik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsaXBCQm94ID0gbmV3IEJCb3goeCwgeSwgd2lkdGgyLCBoZWlnaHQyKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgeCwgeSwgd2lkdGg6IHdpZHRoMiwgaGVpZ2h0OiBoZWlnaHQyLCBjbGlwQkJveCwgb3BhY2l0eSB9O1xuICB9O1xuICByZXR1cm4geyBpc1ZlcnRpY2FsLCBjYWxjdWxhdGUsIG1vZGUgfTtcbn1cbmZ1bmN0aW9uIG1pZHBvaW50U3RhcnRpbmdCYXJQb3NpdGlvbihpc1ZlcnRpY2FsLCBtb2RlKSB7XG4gIHJldHVybiB7XG4gICAgaXNWZXJ0aWNhbCxcbiAgICBjYWxjdWxhdGU6IChkYXR1bSkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogaXNWZXJ0aWNhbCA/IGRhdHVtLnggOiBkYXR1bS54ICsgZGF0dW0ud2lkdGggLyAyLFxuICAgICAgICB5OiBpc1ZlcnRpY2FsID8gZGF0dW0ueSArIGRhdHVtLmhlaWdodCAvIDIgOiBkYXR1bS55LFxuICAgICAgICB3aWR0aDogaXNWZXJ0aWNhbCA/IGRhdHVtLndpZHRoIDogMCxcbiAgICAgICAgaGVpZ2h0OiBpc1ZlcnRpY2FsID8gMCA6IGRhdHVtLmhlaWdodCxcbiAgICAgICAgY2xpcEJCb3g6IGRhdHVtLmNsaXBCQm94LFxuICAgICAgICBvcGFjaXR5OiBkYXR1bS5vcGFjaXR5XG4gICAgICB9O1xuICAgIH0sXG4gICAgbW9kZVxuICB9O1xufVxuZnVuY3Rpb24gcHJlcGFyZUJhckFuaW1hdGlvbkZ1bmN0aW9ucyhpbml0UG9zKSB7XG4gIGNvbnN0IGlzUmVtb3ZlZCA9IChkYXR1bSkgPT4gZGF0dW0gPT0gbnVsbCB8fCBpc05hTihkYXR1bS54KSB8fCBpc05hTihkYXR1bS55KTtcbiAgY29uc3QgZnJvbUZuID0gKHJlY3QsIGRhdHVtLCBzdGF0dXMpID0+IHtcbiAgICBpZiAoc3RhdHVzID09PSBcInVwZGF0ZWRcIiAmJiBpc1JlbW92ZWQoZGF0dW0pKSB7XG4gICAgICBzdGF0dXMgPSBcInJlbW92ZWRcIjtcbiAgICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gXCJ1cGRhdGVkXCIgJiYgaXNSZW1vdmVkKHJlY3QucHJldmlvdXNEYXR1bSkpIHtcbiAgICAgIHN0YXR1cyA9IFwiYWRkZWRcIjtcbiAgICB9XG4gICAgbGV0IHNvdXJjZTtcbiAgICBpZiAoc3RhdHVzID09PSBcImFkZGVkXCIgJiYgcmVjdC5wcmV2aW91c0RhdHVtID09IG51bGwgJiYgaW5pdFBvcy5tb2RlID09PSBcImZhZGVcIikge1xuICAgICAgc291cmNlID0geyAuLi5yZXNldEJhclNlbGVjdGlvbnNGbihyZWN0LCBkYXR1bSksIG9wYWNpdHk6IDAgfTtcbiAgICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gXCJ1bmtub3duXCIgfHwgc3RhdHVzID09PSBcImFkZGVkXCIpIHtcbiAgICAgIHNvdXJjZSA9IGluaXRQb3MuY2FsY3VsYXRlKGRhdHVtLCByZWN0LnByZXZpb3VzRGF0dW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzb3VyY2UgPSB7XG4gICAgICAgIHg6IHJlY3QueCxcbiAgICAgICAgeTogcmVjdC55LFxuICAgICAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodCxcbiAgICAgICAgY2xpcEJCb3g6IHJlY3QuY2xpcEJCb3gsXG4gICAgICAgIG9wYWNpdHk6IHJlY3Qub3BhY2l0eVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcGhhc2UgPSBOT0RFX1VQREFURV9TVEFURV9UT19QSEFTRV9NQVBQSU5HW3N0YXR1c107XG4gICAgcmV0dXJuIHsgLi4uc291cmNlLCBwaGFzZSB9O1xuICB9O1xuICBjb25zdCB0b0ZuID0gKHJlY3QsIGRhdHVtLCBzdGF0dXMpID0+IHtcbiAgICBsZXQgc291cmNlO1xuICAgIGlmIChzdGF0dXMgPT09IFwicmVtb3ZlZFwiICYmIHJlY3QuZGF0dW0gPT0gbnVsbCAmJiBpbml0UG9zLm1vZGUgPT09IFwiZmFkZVwiKSB7XG4gICAgICBzb3VyY2UgPSB7IC4uLnJlc2V0QmFyU2VsZWN0aW9uc0ZuKHJlY3QsIGRhdHVtKSwgb3BhY2l0eTogMCB9O1xuICAgIH0gZWxzZSBpZiAoc3RhdHVzID09PSBcInJlbW92ZWRcIiB8fCBpc1JlbW92ZWQoZGF0dW0pKSB7XG4gICAgICBzb3VyY2UgPSBpbml0UG9zLmNhbGN1bGF0ZShkYXR1bSwgcmVjdC5wcmV2aW91c0RhdHVtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc291cmNlID0ge1xuICAgICAgICB4OiBkYXR1bS54LFxuICAgICAgICB5OiBkYXR1bS55LFxuICAgICAgICB3aWR0aDogZGF0dW0ud2lkdGgsXG4gICAgICAgIGhlaWdodDogZGF0dW0uaGVpZ2h0LFxuICAgICAgICBjbGlwQkJveDogZGF0dW0uY2xpcEJCb3gsXG4gICAgICAgIG9wYWNpdHk6IGRhdHVtLm9wYWNpdHlcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2U7XG4gIH07XG4gIHJldHVybiB7IHRvRm4sIGZyb21GbiB9O1xufVxuZnVuY3Rpb24gZ2V0U3RhcnRpbmdWYWx1ZXMoaXNWZXJ0aWNhbCwgYXhlcykge1xuICBjb25zdCBheGlzID0gYXhlc1tpc1ZlcnRpY2FsID8gXCJ5XCIgLyogWSAqLyA6IFwieFwiIC8qIFggKi9dO1xuICBsZXQgc3RhcnRpbmdYID0gSW5maW5pdHk7XG4gIGxldCBzdGFydGluZ1kgPSAwO1xuICBpZiAoIWF4aXMpIHtcbiAgICByZXR1cm4geyBzdGFydGluZ1gsIHN0YXJ0aW5nWSB9O1xuICB9XG4gIGlmIChpc1ZlcnRpY2FsKSB7XG4gICAgc3RhcnRpbmdZID0gYXhpcy5zY2FsZS5jb252ZXJ0KENvbnRpbnVvdXNTY2FsZS5pcyhheGlzLnNjYWxlKSA/IDAgOiBNYXRoLm1heCguLi5heGlzLnJhbmdlKSk7XG4gIH0gZWxzZSB7XG4gICAgc3RhcnRpbmdYID0gYXhpcy5zY2FsZS5jb252ZXJ0KENvbnRpbnVvdXNTY2FsZS5pcyhheGlzLnNjYWxlKSA/IDAgOiBNYXRoLm1pbiguLi5heGlzLnJhbmdlKSk7XG4gIH1cbiAgcmV0dXJuIHsgc3RhcnRpbmdYLCBzdGFydGluZ1kgfTtcbn1cbmZ1bmN0aW9uIHJlc2V0QmFyU2VsZWN0aW9uc0ZuKF9ub2RlLCB7IHgsIHksIHdpZHRoOiB3aWR0aDIsIGhlaWdodDogaGVpZ2h0MiwgY2xpcEJCb3gsIG9wYWNpdHkgfSkge1xuICByZXR1cm4geyB4LCB5LCB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIsIGNsaXBCQm94LCBvcGFjaXR5IH07XG59XG5mdW5jdGlvbiBjb21wdXRlQmFyRm9jdXNCb3VuZHMoZGF0dW0sIGJhckdyb3VwLCBzZXJpZXNSZWN0KSB7XG4gIGlmIChkYXR1bSA9PT0gdm9pZCAwKVxuICAgIHJldHVybiB2b2lkIDA7XG4gIGNvbnN0IHsgeCwgeSwgd2lkdGg6IHdpZHRoMiwgaGVpZ2h0OiBoZWlnaHQyIH0gPSBkYXR1bTtcbiAgcmV0dXJuIFRyYW5zZm9ybWFibGUudG9DYW52YXMoYmFyR3JvdXAsIG5ldyBCQm94KHgsIHksIHdpZHRoMiwgaGVpZ2h0MikpLmNsaXAoc2VyaWVzUmVjdCk7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vbGFiZWxVdGlsLnRzXG5mdW5jdGlvbiB1cGRhdGVMYWJlbE5vZGUodGV4dE5vZGUsIGxhYmVsLCBsYWJlbERhdHVtKSB7XG4gIGlmIChsYWJlbC5lbmFibGVkICYmIGxhYmVsRGF0dW0pIHtcbiAgICBjb25zdCB7IHgsIHksIHRleHQsIHRleHRBbGlnbiwgdGV4dEJhc2VsaW5lIH0gPSBsYWJlbERhdHVtO1xuICAgIGNvbnN0IHsgY29sb3I6IGZpbGwsIGZvbnRTdHlsZSwgZm9udFdlaWdodCwgZm9udFNpemUsIGZvbnRGYW1pbHkgfSA9IGxhYmVsO1xuICAgIHRleHROb2RlLnNldFByb3BlcnRpZXMoe1xuICAgICAgdmlzaWJsZTogdHJ1ZSxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgdGV4dCxcbiAgICAgIGZpbGwsXG4gICAgICBmb250U3R5bGUsXG4gICAgICBmb250V2VpZ2h0LFxuICAgICAgZm9udFNpemUsXG4gICAgICBmb250RmFtaWx5LFxuICAgICAgdGV4dEFsaWduLFxuICAgICAgdGV4dEJhc2VsaW5lXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdGV4dE5vZGUudmlzaWJsZSA9IGZhbHNlO1xuICB9XG59XG52YXIgcGxhY2VtZW50cyA9IHtcbiAgXCJpbnNpZGUtc3RhcnRcIjogeyBpbnNpZGU6IHRydWUsIGRpcmVjdGlvbjogLTEsIHRleHRBbGlnbm1lbnQ6IDEgfSxcbiAgXCJpbnNpZGUtZW5kXCI6IHsgaW5zaWRlOiB0cnVlLCBkaXJlY3Rpb246IDEsIHRleHRBbGlnbm1lbnQ6IC0xIH0sXG4gIFwib3V0c2lkZS1zdGFydFwiOiB7IGluc2lkZTogZmFsc2UsIGRpcmVjdGlvbjogLTEsIHRleHRBbGlnbm1lbnQ6IC0xIH0sXG4gIFwib3V0c2lkZS1lbmRcIjogeyBpbnNpZGU6IGZhbHNlLCBkaXJlY3Rpb246IDEsIHRleHRBbGlnbm1lbnQ6IDEgfVxufTtcbmZ1bmN0aW9uIGFkanVzdExhYmVsUGxhY2VtZW50KHtcbiAgaXNVcHdhcmQsXG4gIGlzVmVydGljYWwsXG4gIHBsYWNlbWVudCxcbiAgcGFkZGluZyA9IDAsXG4gIHJlY3Rcbn0pIHtcbiAgbGV0IHggPSByZWN0LnggKyByZWN0LndpZHRoIC8gMjtcbiAgbGV0IHkgPSByZWN0LnkgKyByZWN0LmhlaWdodCAvIDI7XG4gIGxldCB0ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICBsZXQgdGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIjtcbiAgaWYgKHBsYWNlbWVudCAhPT0gXCJpbnNpZGUtY2VudGVyXCIpIHtcbiAgICBjb25zdCBiYXJEaXJlY3Rpb24gPSAoaXNVcHdhcmQgPyAxIDogLTEpICogKGlzVmVydGljYWwgPyAtMSA6IDEpO1xuICAgIGNvbnN0IHsgZGlyZWN0aW9uLCB0ZXh0QWxpZ25tZW50IH0gPSBwbGFjZW1lbnRzW3BsYWNlbWVudF07XG4gICAgY29uc3QgZGlzcGxhY2VtZW50UmF0aW8gPSAoZGlyZWN0aW9uICsgMSkgKiAwLjU7XG4gICAgaWYgKGlzVmVydGljYWwpIHtcbiAgICAgIGNvbnN0IHkwID0gaXNVcHdhcmQgPyByZWN0LnkgKyByZWN0LmhlaWdodCA6IHJlY3QueTtcbiAgICAgIGNvbnN0IGhlaWdodDIgPSByZWN0LmhlaWdodCAqIGJhckRpcmVjdGlvbjtcbiAgICAgIHkgPSB5MCArIGhlaWdodDIgKiBkaXNwbGFjZW1lbnRSYXRpbyArIHBhZGRpbmcgKiB0ZXh0QWxpZ25tZW50ICogYmFyRGlyZWN0aW9uO1xuICAgICAgdGV4dEJhc2VsaW5lID0gdGV4dEFsaWdubWVudCA9PT0gYmFyRGlyZWN0aW9uID8gXCJ0b3BcIiA6IFwiYm90dG9tXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHgwID0gaXNVcHdhcmQgPyByZWN0LnggOiByZWN0LnggKyByZWN0LndpZHRoO1xuICAgICAgY29uc3Qgd2lkdGgyID0gcmVjdC53aWR0aCAqIGJhckRpcmVjdGlvbjtcbiAgICAgIHggPSB4MCArIHdpZHRoMiAqIGRpc3BsYWNlbWVudFJhdGlvICsgcGFkZGluZyAqIHRleHRBbGlnbm1lbnQgKiBiYXJEaXJlY3Rpb247XG4gICAgICB0ZXh0QWxpZ24gPSB0ZXh0QWxpZ25tZW50ID09PSBiYXJEaXJlY3Rpb24gPyBcImxlZnRcIiA6IFwicmlnaHRcIjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgeCwgeSwgdGV4dEFsaWduLCB0ZXh0QmFzZWxpbmUgfTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9iYXJTZXJpZXMudHNcbnZhciBsYWJlbFBsYWNlbWVudHMyID0ge1xuICBcImluc2lkZS1jZW50ZXJcIjogXCJpbnNpZGUtY2VudGVyXCIsXG4gIFwiaW5zaWRlLXN0YXJ0XCI6IFwiaW5zaWRlLXN0YXJ0XCIsXG4gIFwiaW5zaWRlLWVuZFwiOiBcImluc2lkZS1lbmRcIixcbiAgXCJvdXRzaWRlLXN0YXJ0XCI6IFwib3V0c2lkZS1zdGFydFwiLFxuICBcIm91dHNpZGUtZW5kXCI6IFwib3V0c2lkZS1lbmRcIixcbiAgaW5zaWRlOiBcImluc2lkZS1jZW50ZXJcIixcbiAgb3V0c2lkZTogXCJvdXRzaWRlLWVuZFwiXG59O1xudmFyIEJhclNlcmllcyA9IGNsYXNzIGV4dGVuZHMgQWJzdHJhY3RCYXJTZXJpZXMge1xuICBjb25zdHJ1Y3Rvcihtb2R1bGVDdHgpIHtcbiAgICBzdXBlcih7XG4gICAgICBtb2R1bGVDdHgsXG4gICAgICBkaXJlY3Rpb25LZXlzOiBERUZBVUxUX0NBUlRFU0lBTl9ESVJFQ1RJT05fS0VZUyxcbiAgICAgIGRpcmVjdGlvbk5hbWVzOiBERUZBVUxUX0NBUlRFU0lBTl9ESVJFQ1RJT05fTkFNRVMsXG4gICAgICBwaWNrTW9kZXM6IFtcbiAgICAgICAgMiAvKiBBWElTX0FMSUdORUQgKi8sXG4gICAgICAgIC8vIE9ubHkgdXNlZCBpbiBzcGFya2xpbmVNb2RlXG4gICAgICAgIDEgLyogTkVBUkVTVF9OT0RFICovLFxuICAgICAgICAwIC8qIEVYQUNUX1NIQVBFX01BVENIICovXG4gICAgICBdLFxuICAgICAgcGF0aHNQZXJTZXJpZXM6IFtdLFxuICAgICAgaGFzSGlnaGxpZ2h0ZWRMYWJlbHM6IHRydWUsXG4gICAgICBkYXR1bVNlbGVjdGlvbkdhcmJhZ2VDb2xsZWN0aW9uOiBmYWxzZSxcbiAgICAgIGFuaW1hdGlvbkFsd2F5c1VwZGF0ZVNlbGVjdGlvbnM6IHRydWUsXG4gICAgICBhbmltYXRpb25SZXNldEZuczoge1xuICAgICAgICBkYXR1bTogcmVzZXRCYXJTZWxlY3Rpb25zRm4sXG4gICAgICAgIGxhYmVsOiByZXNldExhYmVsRm5cbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnByb3BlcnRpZXMgPSBuZXcgQmFyU2VyaWVzUHJvcGVydGllcygpO1xuICB9XG4gIGdldCBwaWNrTW9kZUF4aXMoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcGVydGllcy5zcGFya2xpbmVNb2RlID8gXCJtYWluXCIgOiB2b2lkIDA7XG4gIH1cbiAgY3Jvc3NGaWx0ZXJpbmdFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXMueUZpbHRlcktleSAhPSBudWxsICYmICh0aGlzLnNlcmllc0dyb3VwaW5nID09IG51bGwgfHwgdGhpcy5zZXJpZXNHcm91cGluZy5zdGFja0luZGV4ID09PSAwKTtcbiAgfVxuICBhc3luYyBwcm9jZXNzRGF0YShkYXRhQ29udHJvbGxlcikge1xuICAgIGlmICghdGhpcy5wcm9wZXJ0aWVzLmlzVmFsaWQoKSB8fCAhdGhpcy5kYXRhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgc2VyaWVzR3JvdXBpbmc6IHsgZ3JvdXBJbmRleCA9IHRoaXMuaWQgfSA9IHt9LCBkYXRhID0gW10gfSA9IHRoaXM7XG4gICAgY29uc3QgeyB4S2V5LCB5S2V5LCB5RmlsdGVyS2V5LCBub3JtYWxpemVkVG8gfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCBhbmltYXRpb25FbmFibGVkID0gIXRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuaXNTa2lwcGVkKCk7XG4gICAgY29uc3QgeFNjYWxlID0gdGhpcy5nZXRDYXRlZ29yeUF4aXMoKT8uc2NhbGU7XG4gICAgY29uc3QgeVNjYWxlID0gdGhpcy5nZXRWYWx1ZUF4aXMoKT8uc2NhbGU7XG4gICAgY29uc3QgeyBpc0NvbnRpbnVvdXNYLCB4U2NhbGVUeXBlLCB5U2NhbGVUeXBlIH0gPSB0aGlzLmdldFNjYWxlSW5mb3JtYXRpb24oeyB4U2NhbGUsIHlTY2FsZSB9KTtcbiAgICBjb25zdCBzdGFja0dyb3VwTmFtZSA9IGBiYXItc3RhY2stJHtncm91cEluZGV4fS15VmFsdWVzYDtcbiAgICBjb25zdCBzdGFja0dyb3VwVHJhaWxpbmdOYW1lID0gYCR7c3RhY2tHcm91cE5hbWV9LXRyYWlsaW5nYDtcbiAgICBjb25zdCBleHRyYVByb3BzID0gW107XG4gICAgaWYgKGlzRmluaXRlTnVtYmVyKG5vcm1hbGl6ZWRUbykpIHtcbiAgICAgIGV4dHJhUHJvcHMucHVzaChcbiAgICAgICAgbm9ybWFsaXNlR3JvdXBUbyhbc3RhY2tHcm91cE5hbWUsIHN0YWNrR3JvdXBUcmFpbGluZ05hbWVdLCBNYXRoLmFicyhub3JtYWxpemVkVG8pLCBcInJhbmdlXCIpXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoYW5pbWF0aW9uRW5hYmxlZCAmJiB0aGlzLnByb2Nlc3NlZERhdGEpIHtcbiAgICAgIGV4dHJhUHJvcHMucHVzaChkaWZmKHRoaXMucHJvY2Vzc2VkRGF0YSkpO1xuICAgIH1cbiAgICBpZiAoYW5pbWF0aW9uRW5hYmxlZCkge1xuICAgICAgZXh0cmFQcm9wcy5wdXNoKGFuaW1hdGlvblZhbGlkYXRpb24oKSk7XG4gICAgfVxuICAgIGNvbnN0IHZpc2libGVQcm9wcyA9IHRoaXMudmlzaWJsZSA/IHt9IDogeyBmb3JjZVZhbHVlOiAwIH07XG4gICAgY29uc3QgeyBwcm9jZXNzZWREYXRhIH0gPSBhd2FpdCB0aGlzLnJlcXVlc3REYXRhTW9kZWwoZGF0YUNvbnRyb2xsZXIsIGRhdGEsIHtcbiAgICAgIHByb3BzOiBbXG4gICAgICAgIGtleVByb3BlcnR5KHhLZXksIHhTY2FsZVR5cGUsIHsgaWQ6IFwieFZhbHVlXCIgfSksXG4gICAgICAgIHZhbHVlUHJvcGVydHkoeUtleSwgeVNjYWxlVHlwZSwgeyBpZDogYHlWYWx1ZS1yYXdgLCBpbnZhbGlkVmFsdWU6IG51bGwsIC4uLnZpc2libGVQcm9wcyB9KSxcbiAgICAgICAgLi4udGhpcy5jcm9zc0ZpbHRlcmluZ0VuYWJsZWQoKSA/IFtcbiAgICAgICAgICB2YWx1ZVByb3BlcnR5KHlGaWx0ZXJLZXksIHlTY2FsZVR5cGUsIHtcbiAgICAgICAgICAgIGlkOiBgeUZpbHRlclZhbHVlYCxcbiAgICAgICAgICAgIGludmFsaWRWYWx1ZTogbnVsbCxcbiAgICAgICAgICAgIC4uLnZpc2libGVQcm9wc1xuICAgICAgICAgIH0pXG4gICAgICAgIF0gOiBbXSxcbiAgICAgICAgLi4uZ3JvdXBBY2N1bXVsYXRpdmVWYWx1ZVByb3BlcnR5KFxuICAgICAgICAgIHlLZXksXG4gICAgICAgICAgXCJub3JtYWxcIixcbiAgICAgICAgICBcImN1cnJlbnRcIixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZDogYHlWYWx1ZS1lbmRgLFxuICAgICAgICAgICAgcmFuZ2VJZDogYHlWYWx1ZS1yYW5nZWAsXG4gICAgICAgICAgICBpbnZhbGlkVmFsdWU6IG51bGwsXG4gICAgICAgICAgICBtaXNzaW5nVmFsdWU6IDAsXG4gICAgICAgICAgICBncm91cElkOiBzdGFja0dyb3VwTmFtZSxcbiAgICAgICAgICAgIHNlcGFyYXRlTmVnYXRpdmU6IHRydWUsXG4gICAgICAgICAgICAuLi52aXNpYmxlUHJvcHNcbiAgICAgICAgICB9LFxuICAgICAgICAgIHlTY2FsZVR5cGVcbiAgICAgICAgKSxcbiAgICAgICAgLi4uZ3JvdXBBY2N1bXVsYXRpdmVWYWx1ZVByb3BlcnR5KFxuICAgICAgICAgIHlLZXksXG4gICAgICAgICAgXCJ0cmFpbGluZ1wiLFxuICAgICAgICAgIFwiY3VycmVudFwiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkOiBgeVZhbHVlLXN0YXJ0YCxcbiAgICAgICAgICAgIGludmFsaWRWYWx1ZTogbnVsbCxcbiAgICAgICAgICAgIG1pc3NpbmdWYWx1ZTogMCxcbiAgICAgICAgICAgIGdyb3VwSWQ6IHN0YWNrR3JvdXBUcmFpbGluZ05hbWUsXG4gICAgICAgICAgICBzZXBhcmF0ZU5lZ2F0aXZlOiB0cnVlLFxuICAgICAgICAgICAgLi4udmlzaWJsZVByb3BzXG4gICAgICAgICAgfSxcbiAgICAgICAgICB5U2NhbGVUeXBlXG4gICAgICAgICksXG4gICAgICAgIC4uLmlzQ29udGludW91c1ggPyBbU01BTExFU1RfS0VZX0lOVEVSVkFMLCBMQVJHRVNUX0tFWV9JTlRFUlZBTF0gOiBbXSxcbiAgICAgICAgLi4uZXh0cmFQcm9wc1xuICAgICAgXSxcbiAgICAgIGdyb3VwQnlLZXlzOiB0cnVlLFxuICAgICAgZ3JvdXBCeURhdGE6IGZhbHNlXG4gICAgfSk7XG4gICAgdGhpcy5zbWFsbGVzdERhdGFJbnRlcnZhbCA9IHByb2Nlc3NlZERhdGEucmVkdWNlZD8uc21hbGxlc3RLZXlJbnRlcnZhbDtcbiAgICB0aGlzLmxhcmdlc3REYXRhSW50ZXJ2YWwgPSBwcm9jZXNzZWREYXRhLnJlZHVjZWQ/Lmxhcmdlc3RLZXlJbnRlcnZhbDtcbiAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJ1cGRhdGVEYXRhXCIpO1xuICB9XG4gIGdldFNlcmllc0RvbWFpbihkaXJlY3Rpb24pIHtcbiAgICBjb25zdCB7IHByb2Nlc3NlZERhdGEsIGRhdGFNb2RlbCB9ID0gdGhpcztcbiAgICBpZiAoIWRhdGFNb2RlbCB8fCAhcHJvY2Vzc2VkRGF0YT8uZGF0YS5sZW5ndGgpXG4gICAgICByZXR1cm4gW107XG4gICAgY29uc3Qga2V5RGVmID0gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhRGVmQnlJZCh0aGlzLCBgeFZhbHVlYCk7XG4gICAgY29uc3Qga2V5cyA9IGRhdGFNb2RlbC5nZXREb21haW4odGhpcywgYHhWYWx1ZWAsIFwia2V5XCIsIHByb2Nlc3NlZERhdGEpO1xuICAgIGxldCB5RXh0ZW50ID0gZGF0YU1vZGVsLmdldERvbWFpbih0aGlzLCBgeVZhbHVlLWVuZGAsIFwidmFsdWVcIiwgcHJvY2Vzc2VkRGF0YSk7XG4gICAgY29uc3QgeUZpbHRlckV4dGVudCA9IHRoaXMuY3Jvc3NGaWx0ZXJpbmdFbmFibGVkKCkgPyBkYXRhTW9kZWwuZ2V0RG9tYWluKHRoaXMsIGB5RmlsdGVyVmFsdWVgLCBcInZhbHVlXCIsIHByb2Nlc3NlZERhdGEpIDogdm9pZCAwO1xuICAgIGlmICh5RmlsdGVyRXh0ZW50ICE9IG51bGwpIHtcbiAgICAgIHlFeHRlbnQgPSBbTWF0aC5taW4oeUV4dGVudFswXSwgeUZpbHRlckV4dGVudFswXSksIE1hdGgubWF4KHlFeHRlbnRbMV0sIHlGaWx0ZXJFeHRlbnRbMV0pXTtcbiAgICB9XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gdGhpcy5nZXRDYXRlZ29yeURpcmVjdGlvbigpKSB7XG4gICAgICBpZiAoa2V5RGVmPy5kZWYudHlwZSA9PT0gXCJrZXlcIiAmJiBrZXlEZWYuZGVmLnZhbHVlVHlwZSA9PT0gXCJjYXRlZ29yeVwiKSB7XG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucGFkQmFuZEV4dGVudChrZXlzKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZ2V0VmFsdWVBeGlzKCkgaW5zdGFuY2VvZiBMb2dBeGlzKSB7XG4gICAgICByZXR1cm4gZml4TnVtZXJpY0V4dGVudCh5RXh0ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZml4ZWRZRXh0ZW50ID0gW01hdGgubWluKDAsIHlFeHRlbnRbMF0pLCBNYXRoLm1heCgwLCB5RXh0ZW50WzFdKV07XG4gICAgICByZXR1cm4gZml4TnVtZXJpY0V4dGVudChmaXhlZFlFeHRlbnQpO1xuICAgIH1cbiAgfVxuICBhc3luYyBjcmVhdGVOb2RlRGF0YSgpIHtcbiAgICBjb25zdCB7IGRhdGFNb2RlbCB9ID0gdGhpcztcbiAgICBjb25zdCB4QXhpcyA9IHRoaXMuZ2V0Q2F0ZWdvcnlBeGlzKCk7XG4gICAgY29uc3QgeUF4aXMgPSB0aGlzLmdldFZhbHVlQXhpcygpO1xuICAgIGlmICghZGF0YU1vZGVsIHx8ICF4QXhpcyB8fCAheUF4aXMgfHwgIXRoaXMucHJvcGVydGllcy5pc1ZhbGlkKCkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeFNjYWxlID0geEF4aXMuc2NhbGU7XG4gICAgY29uc3QgeVNjYWxlID0geUF4aXMuc2NhbGU7XG4gICAgY29uc3QgeyB4S2V5LCB5S2V5LCB4TmFtZSwgeU5hbWUsIGZpbGwsIHN0cm9rZSwgc3Ryb2tlV2lkdGgsIGNvcm5lclJhZGl1cywgbGVnZW5kSXRlbU5hbWUsIGxhYmVsIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgeVJldmVyc2VkID0geUF4aXMuaXNSZXZlcnNlZCgpO1xuICAgIGNvbnN0IHsgYmFyV2lkdGgsIGdyb3VwSW5kZXggfSA9IHRoaXMudXBkYXRlR3JvdXBTY2FsZSh4QXhpcyk7XG4gICAgY29uc3QgYmFyT2Zmc2V0ID0gQ29udGludW91c1NjYWxlLmlzKHhTY2FsZSkgPyBiYXJXaWR0aCAqIC0wLjUgOiAwO1xuICAgIGNvbnN0IHhJbmRleCA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgeFZhbHVlYCk7XG4gICAgY29uc3QgeVJhd0luZGV4ID0gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGB5VmFsdWUtcmF3YCk7XG4gICAgY29uc3QgeUZpbHRlckluZGV4ID0gdGhpcy5jcm9zc0ZpbHRlcmluZ0VuYWJsZWQoKSA/IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgeUZpbHRlclZhbHVlYCkgOiB2b2lkIDA7XG4gICAgY29uc3QgeVN0YXJ0SW5kZXggPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYHlWYWx1ZS1zdGFydGApO1xuICAgIGNvbnN0IHlFbmRJbmRleCA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgeVZhbHVlLWVuZGApO1xuICAgIGNvbnN0IHlSYW5nZUluZGV4ID0gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGB5VmFsdWUtcmFuZ2VgKTtcbiAgICBjb25zdCBhbmltYXRpb25FbmFibGVkID0gIXRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuaXNTa2lwcGVkKCk7XG4gICAgY29uc3Qgbm9kZURhdHVtID0gKHtcbiAgICAgIGRhdHVtLFxuICAgICAgdmFsdWVJbmRleCxcbiAgICAgIHhWYWx1ZSxcbiAgICAgIHlWYWx1ZSxcbiAgICAgIGN1bXVsYXRpdmVWYWx1ZSxcbiAgICAgIHBoYW50b20sXG4gICAgICBjdXJyWSxcbiAgICAgIHByZXZZLFxuICAgICAgaXNQb3NpdGl2ZSxcbiAgICAgIHlSYW5nZSxcbiAgICAgIGxhYmVsVGV4dCxcbiAgICAgIGNyb3NzU2NhbGUgPSAxXG4gICAgfSkgPT4ge1xuICAgICAgY29uc3QgeCA9IHhTY2FsZS5jb252ZXJ0KHhWYWx1ZSk7XG4gICAgICBjb25zdCBpc1Vwd2FyZCA9IGlzUG9zaXRpdmUgIT09IHlSZXZlcnNlZDtcbiAgICAgIGNvbnN0IGJhclggPSB4ICsgZ3JvdXBTY2FsZS5jb252ZXJ0KFN0cmluZyhncm91cEluZGV4KSkgKyBiYXJPZmZzZXQ7XG4gICAgICBjb25zdCB5ID0geVNjYWxlLmNvbnZlcnQoY3VyclkpO1xuICAgICAgY29uc3QgYm90dG9tWSA9IHlTY2FsZS5jb252ZXJ0KHByZXZZKTtcbiAgICAgIGNvbnN0IGJhckFsb25nWCA9IHRoaXMuZ2V0QmFyRGlyZWN0aW9uKCkgPT09IFwieFwiIC8qIFggKi87XG4gICAgICBjb25zdCBiYm94SGVpZ2h0ID0geVNjYWxlLmNvbnZlcnQoeVJhbmdlKTtcbiAgICAgIGNvbnN0IGJib3hCb3R0b20gPSB5U2NhbGUuY29udmVydCgwKTtcbiAgICAgIGNvbnN0IHhPZmZzZXQgPSBiYXJXaWR0aCAqIDAuNSAqICgxIC0gY3Jvc3NTY2FsZSk7XG4gICAgICBjb25zdCByZWN0ID0ge1xuICAgICAgICB4OiBiYXJBbG9uZ1ggPyBNYXRoLm1pbih5LCBib3R0b21ZKSA6IGJhclggKyB4T2Zmc2V0LFxuICAgICAgICB5OiBiYXJBbG9uZ1ggPyBiYXJYICsgeE9mZnNldCA6IE1hdGgubWluKHksIGJvdHRvbVkpLFxuICAgICAgICB3aWR0aDogYmFyQWxvbmdYID8gTWF0aC5hYnMoYm90dG9tWSAtIHkpIDogYmFyV2lkdGggKiBjcm9zc1NjYWxlLFxuICAgICAgICBoZWlnaHQ6IGJhckFsb25nWCA/IGJhcldpZHRoICogY3Jvc3NTY2FsZSA6IE1hdGguYWJzKGJvdHRvbVkgLSB5KVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGNsaXBCQm94ID0gbmV3IEJCb3gocmVjdC54LCByZWN0LnksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcbiAgICAgIGNvbnN0IGJhclJlY3QgPSB7XG4gICAgICAgIHg6IGJhckFsb25nWCA/IE1hdGgubWluKGJib3hCb3R0b20sIGJib3hIZWlnaHQpIDogYmFyWCArIHhPZmZzZXQsXG4gICAgICAgIHk6IGJhckFsb25nWCA/IGJhclggKyB4T2Zmc2V0IDogTWF0aC5taW4oYmJveEJvdHRvbSwgYmJveEhlaWdodCksXG4gICAgICAgIHdpZHRoOiBiYXJBbG9uZ1ggPyBNYXRoLmFicyhiYm94Qm90dG9tIC0gYmJveEhlaWdodCkgOiBiYXJXaWR0aCAqIGNyb3NzU2NhbGUsXG4gICAgICAgIGhlaWdodDogYmFyQWxvbmdYID8gYmFyV2lkdGggKiBjcm9zc1NjYWxlIDogTWF0aC5hYnMoYmJveEJvdHRvbSAtIGJib3hIZWlnaHQpXG4gICAgICB9O1xuICAgICAgY29uc3QgbGVuZ3RoUmF0aW9NdWx0aXBsaWVyID0gdGhpcy5zaG91bGRGbGlwWFkoKSA/IHJlY3QuaGVpZ2h0IDogcmVjdC53aWR0aDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNlcmllczogdGhpcyxcbiAgICAgICAgaXRlbUlkOiBwaGFudG9tID8gY3JlYXRlRGF0dW1JZCh5S2V5LCBwaGFudG9tKSA6IHlLZXksXG4gICAgICAgIGRhdHVtLFxuICAgICAgICB2YWx1ZUluZGV4LFxuICAgICAgICBjdW11bGF0aXZlVmFsdWUsXG4gICAgICAgIHBoYW50b20sXG4gICAgICAgIHhWYWx1ZSxcbiAgICAgICAgeVZhbHVlLFxuICAgICAgICB5S2V5LFxuICAgICAgICB4S2V5LFxuICAgICAgICBjYXBEZWZhdWx0czoge1xuICAgICAgICAgIGxlbmd0aFJhdGlvTXVsdGlwbGllcixcbiAgICAgICAgICBsZW5ndGhNYXg6IGxlbmd0aFJhdGlvTXVsdGlwbGllclxuICAgICAgICB9LFxuICAgICAgICB4OiBiYXJSZWN0LngsXG4gICAgICAgIHk6IGJhclJlY3QueSxcbiAgICAgICAgd2lkdGg6IGJhclJlY3Qud2lkdGgsXG4gICAgICAgIGhlaWdodDogYmFyUmVjdC5oZWlnaHQsXG4gICAgICAgIG1pZFBvaW50OiB7IHg6IHJlY3QueCArIHJlY3Qud2lkdGggLyAyLCB5OiByZWN0LnkgKyByZWN0LmhlaWdodCAvIDIgfSxcbiAgICAgICAgZmlsbCxcbiAgICAgICAgc3Ryb2tlLFxuICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICBzdHJva2VXaWR0aCxcbiAgICAgICAgY29ybmVyUmFkaXVzLFxuICAgICAgICB0b3BMZWZ0Q29ybmVyUmFkaXVzOiBiYXJBbG9uZ1ggIT09IGlzVXB3YXJkLFxuICAgICAgICB0b3BSaWdodENvcm5lclJhZGl1czogaXNVcHdhcmQsXG4gICAgICAgIGJvdHRvbVJpZ2h0Q29ybmVyUmFkaXVzOiBiYXJBbG9uZ1ggPT09IGlzVXB3YXJkLFxuICAgICAgICBib3R0b21MZWZ0Q29ybmVyUmFkaXVzOiAhaXNVcHdhcmQsXG4gICAgICAgIGNsaXBCQm94LFxuICAgICAgICBsYWJlbDogbGFiZWxUZXh0ICE9IG51bGwgPyB7XG4gICAgICAgICAgdGV4dDogbGFiZWxUZXh0LFxuICAgICAgICAgIC4uLmFkanVzdExhYmVsUGxhY2VtZW50KHtcbiAgICAgICAgICAgIGlzVXB3YXJkLFxuICAgICAgICAgICAgaXNWZXJ0aWNhbDogIWJhckFsb25nWCxcbiAgICAgICAgICAgIHBsYWNlbWVudDogbGFiZWxQbGFjZW1lbnRzMltsYWJlbC5wbGFjZW1lbnRdLFxuICAgICAgICAgICAgcGFkZGluZzogbGFiZWwucGFkZGluZyxcbiAgICAgICAgICAgIHJlY3RcbiAgICAgICAgICB9KVxuICAgICAgICB9IDogdm9pZCAwLFxuICAgICAgICBtaXNzaW5nOiB5VmFsdWUgPT0gbnVsbCxcbiAgICAgICAgZm9jdXNhYmxlOiAhcGhhbnRvbVxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IHsgZ3JvdXBTY2FsZSwgcHJvY2Vzc2VkRGF0YSB9ID0gdGhpcztcbiAgICBjb25zdCBwaGFudG9tTm9kZXMgPSBbXTtcbiAgICBjb25zdCBub2RlcyA9IFtdO1xuICAgIGNvbnN0IGxhYmVscyA9IFtdO1xuICAgIHByb2Nlc3NlZERhdGE/LmRhdGEuZm9yRWFjaCgoeyBrZXlzLCBkYXR1bTogc2VyaWVzRGF0dW0sIHZhbHVlcywgYWdnVmFsdWVzIH0pID0+IHtcbiAgICAgIHZhbHVlcy5mb3JFYWNoKCh2YWx1ZSwgdmFsdWVJbmRleCkgPT4ge1xuICAgICAgICBjb25zdCB4VmFsdWUgPSBrZXlzW3hJbmRleF07XG4gICAgICAgIGNvbnN0IHlSYXdWYWx1ZSA9IHZhbHVlW3lSYXdJbmRleF07XG4gICAgICAgIGNvbnN0IHlTdGFydCA9IE51bWJlcih2YWx1ZVt5U3RhcnRJbmRleF0pO1xuICAgICAgICBjb25zdCB5RmlsdGVyVmFsdWUgPSB5RmlsdGVySW5kZXggIT0gbnVsbCA/IE51bWJlcih2YWx1ZVt5RmlsdGVySW5kZXhdKSA6IHZvaWQgMDtcbiAgICAgICAgY29uc3QgeUVuZCA9IE51bWJlcih2YWx1ZVt5RW5kSW5kZXhdKTtcbiAgICAgICAgY29uc3QgaXNQb3NpdGl2ZSA9IHlSYXdWYWx1ZSA+PSAwICYmICFPYmplY3QuaXMoeVJhd1ZhbHVlLCAtMCk7XG4gICAgICAgIGNvbnN0IHlSYW5nZSA9IGFnZ1ZhbHVlcz8uW3lSYW5nZUluZGV4XVtpc1Bvc2l0aXZlID8gMSA6IDBdID8/IDA7XG4gICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHlFbmQpKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHlGaWx0ZXJWYWx1ZSAhPSBudWxsICYmICFOdW1iZXIuaXNGaW5pdGUoeUZpbHRlclZhbHVlKSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGxhYmVsVGV4dCA9IHlSYXdWYWx1ZSAhPSBudWxsID8gdGhpcy5nZXRMYWJlbFRleHQoXG4gICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLmxhYmVsLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGRhdHVtOiBzZXJpZXNEYXR1bVt2YWx1ZUluZGV4XSxcbiAgICAgICAgICAgIHZhbHVlOiB5RmlsdGVyVmFsdWUgPz8geVJhd1ZhbHVlLFxuICAgICAgICAgICAgeEtleSxcbiAgICAgICAgICAgIHlLZXksXG4gICAgICAgICAgICB4TmFtZSxcbiAgICAgICAgICAgIHlOYW1lLFxuICAgICAgICAgICAgbGVnZW5kSXRlbU5hbWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZvcm1hdFZhbHVlXG4gICAgICAgICkgOiB2b2lkIDA7XG4gICAgICAgIGNvbnN0IGluc2V0ID0geUZpbHRlclZhbHVlICE9IG51bGwgJiYgeUZpbHRlclZhbHVlID4geVJhd1ZhbHVlO1xuICAgICAgICBjb25zdCBub2RlRGF0YSA9IG5vZGVEYXR1bSh7XG4gICAgICAgICAgZGF0dW06IHNlcmllc0RhdHVtW3ZhbHVlSW5kZXhdLFxuICAgICAgICAgIHZhbHVlSW5kZXgsXG4gICAgICAgICAgeFZhbHVlLFxuICAgICAgICAgIHlWYWx1ZTogeUZpbHRlclZhbHVlID8/IHlSYXdWYWx1ZSxcbiAgICAgICAgICBjdW11bGF0aXZlVmFsdWU6IHlGaWx0ZXJWYWx1ZSA/PyB5RW5kLFxuICAgICAgICAgIHBoYW50b206IGZhbHNlLFxuICAgICAgICAgIGN1cnJZOiB5RmlsdGVyVmFsdWUgIT0gbnVsbCA/IHlTdGFydCArIHlGaWx0ZXJWYWx1ZSA6IHlFbmQsXG4gICAgICAgICAgcHJldlk6IHlTdGFydCxcbiAgICAgICAgICBpc1Bvc2l0aXZlLFxuICAgICAgICAgIHlSYW5nZTogTWF0aC5tYXgoeVN0YXJ0ICsgKHlGaWx0ZXJWYWx1ZSA/PyAtSW5maW5pdHkpLCB5UmFuZ2UpLFxuICAgICAgICAgIGxhYmVsVGV4dCxcbiAgICAgICAgICBjcm9zc1NjYWxlOiBpbnNldCA/IDAuNiA6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgbm9kZXMucHVzaChub2RlRGF0YSk7XG4gICAgICAgIGxhYmVscy5wdXNoKG5vZGVEYXRhKTtcbiAgICAgICAgaWYgKHlGaWx0ZXJWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgcGhhbnRvbU5vZGVEYXRhID0gbm9kZURhdHVtKHtcbiAgICAgICAgICAgIGRhdHVtOiBzZXJpZXNEYXR1bVt2YWx1ZUluZGV4XSxcbiAgICAgICAgICAgIHZhbHVlSW5kZXgsXG4gICAgICAgICAgICB4VmFsdWUsXG4gICAgICAgICAgICB5VmFsdWU6IHlGaWx0ZXJWYWx1ZSxcbiAgICAgICAgICAgIGN1bXVsYXRpdmVWYWx1ZTogeUZpbHRlclZhbHVlLFxuICAgICAgICAgICAgcGhhbnRvbTogdHJ1ZSxcbiAgICAgICAgICAgIGN1cnJZOiB5RW5kLFxuICAgICAgICAgICAgcHJldlk6IHlTdGFydCxcbiAgICAgICAgICAgIGlzUG9zaXRpdmUsXG4gICAgICAgICAgICB5UmFuZ2UsXG4gICAgICAgICAgICBsYWJlbFRleHQ6IHZvaWQgMCxcbiAgICAgICAgICAgIGNyb3NzU2NhbGU6IHZvaWQgMFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHBoYW50b21Ob2Rlcy5wdXNoKHBoYW50b21Ob2RlRGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBpdGVtSWQ6IHlLZXksXG4gICAgICBub2RlRGF0YTogcGhhbnRvbU5vZGVzLmxlbmd0aCA+IDAgPyBbLi4ucGhhbnRvbU5vZGVzLCAuLi5ub2Rlc10gOiBub2RlcyxcbiAgICAgIGxhYmVsRGF0YTogbGFiZWxzLFxuICAgICAgc2NhbGVzOiB0aGlzLmNhbGN1bGF0ZVNjYWxpbmcoKSxcbiAgICAgIHZpc2libGU6IHRoaXMudmlzaWJsZSB8fCBhbmltYXRpb25FbmFibGVkXG4gICAgfTtcbiAgfVxuICBub2RlRmFjdG9yeSgpIHtcbiAgICByZXR1cm4gbmV3IFJlY3QoKTtcbiAgfVxuICBnZXRIaWdobGlnaHREYXRhKG5vZGVEYXRhLCBoaWdobGlnaHRlZEl0ZW0pIHtcbiAgICBjb25zdCBoaWdobGlnaHRJdGVtID0gbm9kZURhdGEuZmluZChcbiAgICAgIChub2RlRGF0dW0pID0+IG5vZGVEYXR1bS5kYXR1bSA9PT0gaGlnaGxpZ2h0ZWRJdGVtLmRhdHVtICYmICFub2RlRGF0dW0ucGhhbnRvbVxuICAgICk7XG4gICAgcmV0dXJuIGhpZ2hsaWdodEl0ZW0gIT0gbnVsbCA/IFtoaWdobGlnaHRJdGVtXSA6IHZvaWQgMDtcbiAgfVxuICBhc3luYyB1cGRhdGVEYXR1bVNlbGVjdGlvbihvcHRzKSB7XG4gICAgcmV0dXJuIG9wdHMuZGF0dW1TZWxlY3Rpb24udXBkYXRlKFxuICAgICAgb3B0cy5ub2RlRGF0YSxcbiAgICAgIHZvaWQgMCxcbiAgICAgIChkYXR1bSkgPT4gY3JlYXRlRGF0dW1JZChkYXR1bS54VmFsdWUsIGRhdHVtLnZhbHVlSW5kZXgsIGRhdHVtLnBoYW50b20pXG4gICAgKTtcbiAgfVxuICBhc3luYyB1cGRhdGVEYXR1bU5vZGVzKG9wdHMpIHtcbiAgICBpZiAoIXRoaXMucHJvcGVydGllcy5pc1ZhbGlkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgeUtleSxcbiAgICAgIHN0YWNrR3JvdXAsXG4gICAgICBmaWxsLFxuICAgICAgZmlsbE9wYWNpdHksXG4gICAgICBzdHJva2UsXG4gICAgICBzdHJva2VXaWR0aCxcbiAgICAgIHN0cm9rZU9wYWNpdHksXG4gICAgICBsaW5lRGFzaCxcbiAgICAgIGxpbmVEYXNoT2Zmc2V0LFxuICAgICAgaXRlbVN0eWxlcixcbiAgICAgIHNoYWRvdyxcbiAgICAgIGhpZ2hsaWdodFN0eWxlOiB7IGl0ZW06IGl0ZW1IaWdobGlnaHRTdHlsZSB9XG4gICAgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCB4QXhpcyA9IHRoaXMuYXhlc1tcInhcIiAvKiBYICovXTtcbiAgICBjb25zdCBjcmlzcCA9IHRoaXMucHJvcGVydGllcy5jcmlzcCA/PyBjaGVja0NyaXNwKHhBeGlzPy5zY2FsZSwgeEF4aXM/LnZpc2libGVSYW5nZSwgdGhpcy5zbWFsbGVzdERhdGFJbnRlcnZhbCwgdGhpcy5sYXJnZXN0RGF0YUludGVydmFsKTtcbiAgICBjb25zdCBjYXRlZ29yeUFsb25nWCA9IHRoaXMuZ2V0Q2F0ZWdvcnlEaXJlY3Rpb24oKSA9PT0gXCJ4XCIgLyogWCAqLztcbiAgICBjb25zdCBzdHlsZSA9IHtcbiAgICAgIGZpbGwsXG4gICAgICBzdHJva2UsXG4gICAgICBsaW5lRGFzaCxcbiAgICAgIGxpbmVEYXNoT2Zmc2V0LFxuICAgICAgZmlsbFNoYWRvdzogc2hhZG93LFxuICAgICAgc3Ryb2tlV2lkdGg6IHRoaXMuZ2V0U3Ryb2tlV2lkdGgoc3Ryb2tlV2lkdGgpLFxuICAgICAgZmlsbE9wYWNpdHk6IDAsXG4gICAgICBzdHJva2VPcGFjaXR5OiAwXG4gICAgfTtcbiAgICBjb25zdCByZWN0UGFyYW1zID0ge1xuICAgICAgZGF0dW06IHZvaWQgMCxcbiAgICAgIGN0eDogdGhpcy5jdHgsXG4gICAgICBzZXJpZXNJZDogdGhpcy5pZCxcbiAgICAgIGlzSGlnaGxpZ2h0ZWQ6IG9wdHMuaXNIaWdobGlnaHQsXG4gICAgICBoaWdobGlnaHRTdHlsZTogaXRlbUhpZ2hsaWdodFN0eWxlLFxuICAgICAgeUtleSxcbiAgICAgIHN0eWxlLFxuICAgICAgaXRlbVN0eWxlcixcbiAgICAgIHN0YWNrR3JvdXBcbiAgICB9O1xuICAgIG9wdHMuZGF0dW1TZWxlY3Rpb24uZWFjaCgocmVjdCwgZGF0dW0pID0+IHtcbiAgICAgIHN0eWxlLmZpbGxPcGFjaXR5ID0gZmlsbE9wYWNpdHkgKiAoZGF0dW0ucGhhbnRvbSA/IDAuMiA6IDEpO1xuICAgICAgc3R5bGUuc3Ryb2tlT3BhY2l0eSA9IHN0cm9rZU9wYWNpdHkgKiAoZGF0dW0ucGhhbnRvbSA/IDAuMiA6IDEpO1xuICAgICAgc3R5bGUuY29ybmVyUmFkaXVzID0gZGF0dW0uY29ybmVyUmFkaXVzO1xuICAgICAgc3R5bGUudG9wTGVmdENvcm5lclJhZGl1cyA9IGRhdHVtLnRvcExlZnRDb3JuZXJSYWRpdXM7XG4gICAgICBzdHlsZS50b3BSaWdodENvcm5lclJhZGl1cyA9IGRhdHVtLnRvcFJpZ2h0Q29ybmVyUmFkaXVzO1xuICAgICAgc3R5bGUuYm90dG9tUmlnaHRDb3JuZXJSYWRpdXMgPSBkYXR1bS5ib3R0b21SaWdodENvcm5lclJhZGl1cztcbiAgICAgIHN0eWxlLmJvdHRvbUxlZnRDb3JuZXJSYWRpdXMgPSBkYXR1bS5ib3R0b21MZWZ0Q29ybmVyUmFkaXVzO1xuICAgICAgY29uc3QgdmlzaWJsZSA9IGNhdGVnb3J5QWxvbmdYID8gKGRhdHVtLmNsaXBCQm94Py53aWR0aCA/PyBkYXR1bS53aWR0aCkgPiAwIDogKGRhdHVtLmNsaXBCQm94Py5oZWlnaHQgPz8gZGF0dW0uaGVpZ2h0KSA+IDA7XG4gICAgICByZWN0UGFyYW1zLmRhdHVtID0gZGF0dW07XG4gICAgICBjb25zdCBjb25maWcgPSBnZXRSZWN0Q29uZmlnKHJlY3RQYXJhbXMpO1xuICAgICAgY29uZmlnLmNyaXNwID0gY3Jpc3A7XG4gICAgICBjb25maWcudmlzaWJsZSA9IHZpc2libGU7XG4gICAgICB1cGRhdGVSZWN0KHJlY3QsIGNvbmZpZyk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlTGFiZWxTZWxlY3Rpb24ob3B0cykge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmlzTGFiZWxFbmFibGVkKCkgPyBvcHRzLmxhYmVsRGF0YSA6IFtdO1xuICAgIHJldHVybiBvcHRzLmxhYmVsU2VsZWN0aW9uLnVwZGF0ZShkYXRhLCAodGV4dCkgPT4ge1xuICAgICAgdGV4dC5wb2ludGVyRXZlbnRzID0gMSAvKiBOb25lICovO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIHVwZGF0ZUxhYmVsTm9kZXMob3B0cykge1xuICAgIG9wdHMubGFiZWxTZWxlY3Rpb24uZWFjaCgodGV4dE5vZGUsIGRhdHVtKSA9PiB7XG4gICAgICB1cGRhdGVMYWJlbE5vZGUodGV4dE5vZGUsIHRoaXMucHJvcGVydGllcy5sYWJlbCwgZGF0dW0ubGFiZWwpO1xuICAgIH0pO1xuICB9XG4gIGdldFRvb2x0aXBIdG1sKG5vZGVEYXR1bSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlkOiBzZXJpZXNJZCxcbiAgICAgIHByb2Nlc3NlZERhdGEsXG4gICAgICBjdHg6IHsgY2FsbGJhY2tDYWNoZSB9XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgeEF4aXMgPSB0aGlzLmdldENhdGVnb3J5QXhpcygpO1xuICAgIGNvbnN0IHlBeGlzID0gdGhpcy5nZXRWYWx1ZUF4aXMoKTtcbiAgICBpZiAoIXByb2Nlc3NlZERhdGEgfHwgIXRoaXMucHJvcGVydGllcy5pc1ZhbGlkKCkgfHwgIXhBeGlzIHx8ICF5QXhpcykge1xuICAgICAgcmV0dXJuIEVNUFRZX1RPT0xUSVBfQ09OVEVOVDtcbiAgICB9XG4gICAgY29uc3QgeyB4S2V5LCB5S2V5LCB4TmFtZSwgeU5hbWUsIGZpbGwsIHN0cm9rZSwgc3Ryb2tlV2lkdGgsIHRvb2x0aXAsIGl0ZW1TdHlsZXIsIHN0YWNrR3JvdXAsIGxlZ2VuZEl0ZW1OYW1lIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgeyB4VmFsdWUsIHlWYWx1ZSwgZGF0dW0sIGl0ZW1JZCB9ID0gbm9kZURhdHVtO1xuICAgIGNvbnN0IHhTdHJpbmcgPSB4QXhpcy5mb3JtYXREYXR1bSh4VmFsdWUpO1xuICAgIGNvbnN0IHlTdHJpbmcgPSB5QXhpcy5mb3JtYXREYXR1bSh5VmFsdWUpO1xuICAgIGNvbnN0IHRpdGxlID0gc2FuaXRpemVIdG1sKHlOYW1lKTtcbiAgICBjb25zdCBjb250ZW50ID0gc2FuaXRpemVIdG1sKHhTdHJpbmcgKyBcIjogXCIgKyB5U3RyaW5nKTtcbiAgICBsZXQgZm9ybWF0O1xuICAgIGlmIChpdGVtU3R5bGVyKSB7XG4gICAgICBmb3JtYXQgPSBjYWxsYmFja0NhY2hlLmNhbGwoaXRlbVN0eWxlciwge1xuICAgICAgICBzZXJpZXNJZCxcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIHhLZXksXG4gICAgICAgIHlLZXksXG4gICAgICAgIHN0YWNrR3JvdXAsXG4gICAgICAgIGZpbGwsXG4gICAgICAgIHN0cm9rZSxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IHRoaXMuZ2V0U3Ryb2tlV2lkdGgoc3Ryb2tlV2lkdGgpLFxuICAgICAgICBoaWdobGlnaHRlZDogZmFsc2UsXG4gICAgICAgIGNvcm5lclJhZGl1czogdGhpcy5wcm9wZXJ0aWVzLmNvcm5lclJhZGl1cyxcbiAgICAgICAgZmlsbE9wYWNpdHk6IHRoaXMucHJvcGVydGllcy5maWxsT3BhY2l0eSxcbiAgICAgICAgc3Ryb2tlT3BhY2l0eTogdGhpcy5wcm9wZXJ0aWVzLnN0cm9rZU9wYWNpdHksXG4gICAgICAgIGxpbmVEYXNoOiB0aGlzLnByb3BlcnRpZXMubGluZURhc2ggPz8gW10sXG4gICAgICAgIGxpbmVEYXNoT2Zmc2V0OiB0aGlzLnByb3BlcnRpZXMubGluZURhc2hPZmZzZXRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBjb2xvciA9IGZvcm1hdD8uZmlsbCA/PyBmaWxsO1xuICAgIHJldHVybiB0b29sdGlwLnRvVG9vbHRpcEh0bWwoXG4gICAgICB7IHRpdGxlLCBjb250ZW50LCBiYWNrZ3JvdW5kQ29sb3I6IGNvbG9yIH0sXG4gICAgICB7XG4gICAgICAgIHNlcmllc0lkLFxuICAgICAgICBpdGVtSWQsXG4gICAgICAgIGRhdHVtLFxuICAgICAgICB4S2V5LFxuICAgICAgICB5S2V5LFxuICAgICAgICB4TmFtZSxcbiAgICAgICAgeU5hbWUsXG4gICAgICAgIHN0YWNrR3JvdXAsXG4gICAgICAgIHRpdGxlLFxuICAgICAgICBjb2xvcixcbiAgICAgICAgbGVnZW5kSXRlbU5hbWUsXG4gICAgICAgIC4uLnRoaXMuZ2V0TW9kdWxlVG9vbHRpcFBhcmFtcygpXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBnZXRMZWdlbmREYXRhKGxlZ2VuZFR5cGUpIHtcbiAgICBjb25zdCB7IHNob3dJbkxlZ2VuZCB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGlmIChsZWdlbmRUeXBlICE9PSBcImNhdGVnb3J5XCIgfHwgIXRoaXMuZGF0YT8ubGVuZ3RoIHx8ICF0aGlzLnByb3BlcnRpZXMuaXNWYWxpZCgpIHx8ICFzaG93SW5MZWdlbmQpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgeyB5S2V5LCB5TmFtZSwgZmlsbCwgc3Ryb2tlLCBzdHJva2VXaWR0aCwgZmlsbE9wYWNpdHksIHN0cm9rZU9wYWNpdHksIGxlZ2VuZEl0ZW1OYW1lLCB2aXNpYmxlIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgbGVnZW5kVHlwZTogXCJjYXRlZ29yeVwiLFxuICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgaXRlbUlkOiB5S2V5LFxuICAgICAgICBzZXJpZXNJZDogdGhpcy5pZCxcbiAgICAgICAgZW5hYmxlZDogdmlzaWJsZSxcbiAgICAgICAgbGFiZWw6IHsgdGV4dDogbGVnZW5kSXRlbU5hbWUgPz8geU5hbWUgPz8geUtleSB9LFxuICAgICAgICBzeW1ib2xzOiBbeyBtYXJrZXI6IHsgZmlsbCwgZmlsbE9wYWNpdHksIHN0cm9rZSwgc3Ryb2tlV2lkdGgsIHN0cm9rZU9wYWNpdHkgfSB9XSxcbiAgICAgICAgbGVnZW5kSXRlbU5hbWVcbiAgICAgIH1cbiAgICBdO1xuICB9XG4gIGFuaW1hdGVFbXB0eVVwZGF0ZVJlYWR5KHsgZGF0dW1TZWxlY3Rpb24sIGxhYmVsU2VsZWN0aW9uLCBhbm5vdGF0aW9uU2VsZWN0aW9ucyB9KSB7XG4gICAgY29uc3QgZm5zID0gcHJlcGFyZUJhckFuaW1hdGlvbkZ1bmN0aW9ucyhjb2xsYXBzZWRTdGFydGluZ0JhclBvc2l0aW9uKHRoaXMuaXNWZXJ0aWNhbCgpLCB0aGlzLmF4ZXMsIFwibm9ybWFsXCIpKTtcbiAgICBmcm9tVG9Nb3Rpb24odGhpcy5pZCwgXCJub2Rlc1wiLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCBbZGF0dW1TZWxlY3Rpb25dLCBmbnMpO1xuICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwibGFiZWxzXCIsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIGxhYmVsU2VsZWN0aW9uKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImFubm90YXRpb25zXCIsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIC4uLmFubm90YXRpb25TZWxlY3Rpb25zKTtcbiAgfVxuICBhbmltYXRlV2FpdGluZ1VwZGF0ZVJlYWR5KGRhdGEpIHtcbiAgICBjb25zdCB7IGRhdHVtU2VsZWN0aW9uLCBsYWJlbFNlbGVjdGlvbiwgYW5ub3RhdGlvblNlbGVjdGlvbnMsIHByZXZpb3VzQ29udGV4dERhdGEgfSA9IGRhdGE7XG4gICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5zdG9wQnlBbmltYXRpb25Hcm91cElkKHRoaXMuaWQpO1xuICAgIGNvbnN0IGRhdGFEaWZmID0gdGhpcy5wcm9jZXNzZWREYXRhPy5yZWR1Y2VkPy5kaWZmO1xuICAgIGNvbnN0IG1vZGUgPSBwcmV2aW91c0NvbnRleHREYXRhID09IG51bGwgPyBcImZhZGVcIiA6IFwibm9ybWFsXCI7XG4gICAgY29uc3QgZm5zID0gcHJlcGFyZUJhckFuaW1hdGlvbkZ1bmN0aW9ucyhjb2xsYXBzZWRTdGFydGluZ0JhclBvc2l0aW9uKHRoaXMuaXNWZXJ0aWNhbCgpLCB0aGlzLmF4ZXMsIG1vZGUpKTtcbiAgICBmcm9tVG9Nb3Rpb24oXG4gICAgICB0aGlzLmlkLFxuICAgICAgXCJub2Rlc1wiLFxuICAgICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlcixcbiAgICAgIFtkYXR1bVNlbGVjdGlvbl0sXG4gICAgICBmbnMsXG4gICAgICAoXywgZGF0dW0pID0+IGNyZWF0ZURhdHVtSWQoZGF0dW0ueFZhbHVlLCBkYXR1bS52YWx1ZUluZGV4LCBkYXR1bS5waGFudG9tKSxcbiAgICAgIGRhdGFEaWZmXG4gICAgKTtcbiAgICBjb25zdCBoYXNNb3Rpb24gPSBkYXRhRGlmZj8uY2hhbmdlZCA/PyB0cnVlO1xuICAgIGlmIChoYXNNb3Rpb24pIHtcbiAgICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwibGFiZWxzXCIsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIGxhYmVsU2VsZWN0aW9uKTtcbiAgICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwiYW5ub3RhdGlvbnNcIiwgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgLi4uYW5ub3RhdGlvblNlbGVjdGlvbnMpO1xuICAgIH1cbiAgfVxuICBpc0xhYmVsRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLmxhYmVsLmVuYWJsZWQ7XG4gIH1cbiAgY29tcHV0ZUZvY3VzQm91bmRzKHsgZGF0dW1JbmRleCwgc2VyaWVzUmVjdCB9KSB7XG4gICAgY29uc3QgZGF0dW1Cb3ggPSB0aGlzLmNvbnRleHROb2RlRGF0YT8ubm9kZURhdGFbZGF0dW1JbmRleF0uY2xpcEJCb3g7XG4gICAgcmV0dXJuIGNvbXB1dGVCYXJGb2N1c0JvdW5kcyhkYXR1bUJveCwgdGhpcy5jb250ZW50R3JvdXAsIHNlcmllc1JlY3QpO1xuICB9XG59O1xuQmFyU2VyaWVzLmNsYXNzTmFtZSA9IFwiQmFyU2VyaWVzXCI7XG5CYXJTZXJpZXMudHlwZSA9IFwiYmFyXCI7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vYmFyU2VyaWVzTW9kdWxlLnRzXG52YXIgQmFyU2VyaWVzTW9kdWxlID0ge1xuICB0eXBlOiBcInNlcmllc1wiLFxuICBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsXG4gIHBhY2thZ2VUeXBlOiBcImNvbW11bml0eVwiLFxuICBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIl0sXG4gIGlkZW50aWZpZXI6IFwiYmFyXCIsXG4gIG1vZHVsZUZhY3Rvcnk6IChjdHgpID0+IG5ldyBCYXJTZXJpZXMoY3R4KSxcbiAgc3RhY2thYmxlOiB0cnVlLFxuICBncm91cGFibGU6IHRydWUsXG4gIHRvb2x0aXBEZWZhdWx0czogeyByYW5nZTogXCJleGFjdFwiIH0sXG4gIGRlZmF1bHRBeGVzOiBzd2FwQXhpc0NvbmRpdGlvbihcbiAgICBbXG4gICAgICB7IHR5cGU6IFwibnVtYmVyXCIgLyogTlVNQkVSICovLCBwb3NpdGlvbjogXCJsZWZ0XCIgLyogTEVGVCAqLyB9LFxuICAgICAgeyB0eXBlOiBcImNhdGVnb3J5XCIgLyogQ0FURUdPUlkgKi8sIHBvc2l0aW9uOiBcImJvdHRvbVwiIC8qIEJPVFRPTSAqLyB9XG4gICAgXSxcbiAgICAoc2VyaWVzKSA9PiBzZXJpZXM/LmRpcmVjdGlvbiA9PT0gXCJob3Jpem9udGFsXCJcbiAgKSxcbiAgdGhlbWVUZW1wbGF0ZToge1xuICAgIHNlcmllczoge1xuICAgICAgZGlyZWN0aW9uOiBcInZlcnRpY2FsXCIsXG4gICAgICBmaWxsT3BhY2l0eTogMSxcbiAgICAgIHN0cm9rZVdpZHRoOiAwLFxuICAgICAgbGluZURhc2g6IFswXSxcbiAgICAgIGxpbmVEYXNoT2Zmc2V0OiAwLFxuICAgICAgbGFiZWw6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIGZvbnRXZWlnaHQ6IFwibm9ybWFsXCIgLyogTk9STUFMICovLFxuICAgICAgICBmb250U2l6ZTogMTIsXG4gICAgICAgIGZvbnRGYW1pbHk6IERFRkFVTFRfRk9OVF9GQU1JTFksXG4gICAgICAgIGNvbG9yOiBERUZBVUxUX0lOU0lERV9TRVJJRVNfTEFCRUxfQ09MT1VSLFxuICAgICAgICBwbGFjZW1lbnQ6IFwiaW5zaWRlLWNlbnRlclwiXG4gICAgICB9LFxuICAgICAgc2hhZG93OiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBjb2xvcjogREVGQVVMVF9TSEFET1dfQ09MT1VSLFxuICAgICAgICB4T2Zmc2V0OiAzLFxuICAgICAgICB5T2Zmc2V0OiAzLFxuICAgICAgICBibHVyOiA1XG4gICAgICB9LFxuICAgICAgZXJyb3JCYXI6IHtcbiAgICAgICAgY2FwOiB7XG4gICAgICAgICAgbGVuZ3RoUmF0aW86IDAuM1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwYWxldHRlRmFjdG9yeTogc2luZ2xlU2VyaWVzUGFsZXR0ZUZhY3Rvcnlcbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vYnViYmxlU2VyaWVzUHJvcGVydGllcy50c1xudmFyIEJ1YmJsZVNlcmllc01hcmtlciA9IGNsYXNzIGV4dGVuZHMgU2VyaWVzTWFya2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLm1heFNpemUgPSAzMDtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiksXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBCdWJibGVTZXJpZXNNYXJrZXIucHJvdG90eXBlLCBcIm1heFNpemVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShOVU1CRVJfQVJSQVksIHsgb3B0aW9uYWw6IHRydWUgfSksXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBCdWJibGVTZXJpZXNNYXJrZXIucHJvdG90eXBlLCBcImRvbWFpblwiLCAyKTtcbnZhciBCdWJibGVTZXJpZXNMYWJlbCA9IGNsYXNzIGV4dGVuZHMgTGFiZWwge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMucGxhY2VtZW50ID0gXCJ0b3BcIjtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKExBQkVMX1BMQUNFTUVOVClcbl0sIEJ1YmJsZVNlcmllc0xhYmVsLnByb3RvdHlwZSwgXCJwbGFjZW1lbnRcIiwgMik7XG52YXIgQnViYmxlU2VyaWVzUHJvcGVydGllcyA9IGNsYXNzIGV4dGVuZHMgQ2FydGVzaWFuU2VyaWVzUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5jb2xvclJhbmdlID0gW1wiI2ZmZmYwMFwiLCBcIiMwMGZmMDBcIiwgXCIjMDAwMGZmXCJdO1xuICAgIHRoaXMubGFiZWwgPSBuZXcgQnViYmxlU2VyaWVzTGFiZWwoKTtcbiAgICB0aGlzLnRvb2x0aXAgPSBuZXcgU2VyaWVzVG9vbHRpcCgpO1xuICAgIC8vIE5vIHZhbGlkYXRpb24uIE5vdCBhIHBhcnQgb2YgdGhlIG9wdGlvbnMgY29udHJhY3QuXG4gICAgdGhpcy5tYXJrZXIgPSBuZXcgQnViYmxlU2VyaWVzTWFya2VyKCk7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcpXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ4S2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HKVxuXSwgQnViYmxlU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwieUtleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORylcbl0sIEJ1YmJsZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInNpemVLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEJ1YmJsZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImxhYmVsS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjb2xvcktleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQnViYmxlU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwieEZpbHRlcktleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQnViYmxlU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwieUZpbHRlcktleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQnViYmxlU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic2l6ZUZpbHRlcktleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQnViYmxlU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwieE5hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEJ1YmJsZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInlOYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzaXplTmFtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQnViYmxlU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGFiZWxOYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjb2xvck5hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShOVU1CRVJfQVJSQVksIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEJ1YmJsZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNvbG9yRG9tYWluXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HX0FSUkFZKVxuXSwgQnViYmxlU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiY29sb3JSYW5nZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQnViYmxlU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwidGl0bGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBQcm94eVByb3BlcnR5KFwibWFya2VyLnNoYXBlXCIpXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzaGFwZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHkoXCJtYXJrZXIuc2l6ZVwiKVxuXSwgQnViYmxlU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic2l6ZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHkoXCJtYXJrZXIubWF4U2l6ZVwiKVxuXSwgQnViYmxlU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibWF4U2l6ZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHkoXCJtYXJrZXIuZG9tYWluXCIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEJ1YmJsZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImRvbWFpblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHkoXCJtYXJrZXIuZmlsbFwiLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJmaWxsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgUHJveHlQcm9wZXJ0eShcIm1hcmtlci5maWxsT3BhY2l0eVwiKVxuXSwgQnViYmxlU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiZmlsbE9wYWNpdHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBQcm94eVByb3BlcnR5KFwibWFya2VyLnN0cm9rZVwiLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdHJva2VcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBQcm94eVByb3BlcnR5KFwibWFya2VyLnN0cm9rZVdpZHRoXCIpXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdHJva2VXaWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHkoXCJtYXJrZXIuc3Ryb2tlT3BhY2l0eVwiKVxuXSwgQnViYmxlU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic3Ryb2tlT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHkoXCJtYXJrZXIuaXRlbVN0eWxlclwiLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJpdGVtU3R5bGVyXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgQnViYmxlU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGFiZWxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ0b29sdGlwXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2J1YmJsZVNlcmllcy50c1xudmFyIEJ1YmJsZVNlcmllc05vZGVFdmVudCA9IGNsYXNzIGV4dGVuZHMgQ2FydGVzaWFuU2VyaWVzTm9kZUV2ZW50IHtcbiAgY29uc3RydWN0b3IodHlwZSwgbmF0aXZlRXZlbnQsIGRhdHVtLCBzZXJpZXMpIHtcbiAgICBzdXBlcih0eXBlLCBuYXRpdmVFdmVudCwgZGF0dW0sIHNlcmllcyk7XG4gICAgdGhpcy5zaXplS2V5ID0gc2VyaWVzLnByb3BlcnRpZXMuc2l6ZUtleTtcbiAgfVxufTtcbnZhciBCdWJibGVTZXJpZXMgPSBjbGFzcyBleHRlbmRzIENhcnRlc2lhblNlcmllcyB7XG4gIGNvbnN0cnVjdG9yKG1vZHVsZUN0eCkge1xuICAgIHN1cGVyKHtcbiAgICAgIG1vZHVsZUN0eCxcbiAgICAgIGRpcmVjdGlvbktleXM6IERFRkFVTFRfQ0FSVEVTSUFOX0RJUkVDVElPTl9LRVlTLFxuICAgICAgZGlyZWN0aW9uTmFtZXM6IERFRkFVTFRfQ0FSVEVTSUFOX0RJUkVDVElPTl9OQU1FUyxcbiAgICAgIHBpY2tNb2RlczogW1xuICAgICAgICAyIC8qIEFYSVNfQUxJR05FRCAqLyxcbiAgICAgICAgMSAvKiBORUFSRVNUX05PREUgKi8sXG4gICAgICAgIDAgLyogRVhBQ1RfU0hBUEVfTUFUQ0ggKi9cbiAgICAgIF0sXG4gICAgICBwYXRoc1BlclNlcmllczogW10sXG4gICAgICBoYXNNYXJrZXJzOiB0cnVlLFxuICAgICAgbWFya2VyU2VsZWN0aW9uR2FyYmFnZUNvbGxlY3Rpb246IGZhbHNlLFxuICAgICAgYW5pbWF0aW9uUmVzZXRGbnM6IHtcbiAgICAgICAgbGFiZWw6IHJlc2V0TGFiZWxGbixcbiAgICAgICAgbWFya2VyOiByZXNldE1hcmtlckZuXG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5Ob2RlRXZlbnQgPSBCdWJibGVTZXJpZXNOb2RlRXZlbnQ7XG4gICAgdGhpcy5wcm9wZXJ0aWVzID0gbmV3IEJ1YmJsZVNlcmllc1Byb3BlcnRpZXMoKTtcbiAgICB0aGlzLnNpemVTY2FsZSA9IG5ldyBMaW5lYXJTY2FsZSgpO1xuICAgIHRoaXMuY29sb3JTY2FsZSA9IG5ldyBDb2xvclNjYWxlKCk7XG4gIH1cbiAgZ2V0IHBpY2tNb2RlQXhpcygpIHtcbiAgICByZXR1cm4gXCJtYWluLWNhdGVnb3J5XCI7XG4gIH1cbiAgYXN5bmMgcHJvY2Vzc0RhdGEoZGF0YUNvbnRyb2xsZXIpIHtcbiAgICBpZiAoIXRoaXMucHJvcGVydGllcy5pc1ZhbGlkKCkgfHwgdGhpcy5kYXRhID09IG51bGwgfHwgIXRoaXMudmlzaWJsZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB4U2NhbGUgPSB0aGlzLmF4ZXNbXCJ4XCIgLyogWCAqL10/LnNjYWxlO1xuICAgIGNvbnN0IHlTY2FsZSA9IHRoaXMuYXhlc1tcInlcIiAvKiBZICovXT8uc2NhbGU7XG4gICAgY29uc3QgeyB4U2NhbGVUeXBlLCB5U2NhbGVUeXBlIH0gPSB0aGlzLmdldFNjYWxlSW5mb3JtYXRpb24oeyB4U2NhbGUsIHlTY2FsZSB9KTtcbiAgICBjb25zdCBjb2xvclNjYWxlVHlwZSA9IHRoaXMuY29sb3JTY2FsZS50eXBlO1xuICAgIGNvbnN0IHNpemVTY2FsZVR5cGUgPSB0aGlzLnNpemVTY2FsZS50eXBlO1xuICAgIGNvbnN0IHtcbiAgICAgIHhLZXksXG4gICAgICB5S2V5LFxuICAgICAgc2l6ZUtleSxcbiAgICAgIHhGaWx0ZXJLZXksXG4gICAgICB5RmlsdGVyS2V5LFxuICAgICAgc2l6ZUZpbHRlcktleSxcbiAgICAgIGxhYmVsS2V5LFxuICAgICAgY29sb3JEb21haW4sXG4gICAgICBjb2xvclJhbmdlLFxuICAgICAgY29sb3JLZXksXG4gICAgICBtYXJrZXJcbiAgICB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHsgZGF0YU1vZGVsLCBwcm9jZXNzZWREYXRhIH0gPSBhd2FpdCB0aGlzLnJlcXVlc3REYXRhTW9kZWwoZGF0YUNvbnRyb2xsZXIsIHRoaXMuZGF0YSwge1xuICAgICAgcHJvcHM6IFtcbiAgICAgICAgdmFsdWVQcm9wZXJ0eSh4S2V5LCB4U2NhbGVUeXBlLCB7IGlkOiBgeFZhbHVlYCB9KSxcbiAgICAgICAgdmFsdWVQcm9wZXJ0eSh5S2V5LCB5U2NhbGVUeXBlLCB7IGlkOiBgeVZhbHVlYCB9KSxcbiAgICAgICAgLi4ueEZpbHRlcktleSAhPSBudWxsID8gW3ZhbHVlUHJvcGVydHkoeEZpbHRlcktleSwgeFNjYWxlVHlwZSwgeyBpZDogYHhGaWx0ZXJWYWx1ZWAgfSldIDogW10sXG4gICAgICAgIC4uLnlGaWx0ZXJLZXkgIT0gbnVsbCA/IFt2YWx1ZVByb3BlcnR5KHlGaWx0ZXJLZXksIHlTY2FsZVR5cGUsIHsgaWQ6IGB5RmlsdGVyVmFsdWVgIH0pXSA6IFtdLFxuICAgICAgICAuLi5zaXplRmlsdGVyS2V5ICE9IG51bGwgPyBbdmFsdWVQcm9wZXJ0eShzaXplRmlsdGVyS2V5LCBzaXplU2NhbGVUeXBlLCB7IGlkOiBgc2l6ZUZpbHRlclZhbHVlYCB9KV0gOiBbXSxcbiAgICAgICAgdmFsdWVQcm9wZXJ0eShzaXplS2V5LCBzaXplU2NhbGVUeXBlLCB7IGlkOiBgc2l6ZVZhbHVlYCB9KSxcbiAgICAgICAgLi4uY29sb3JLZXkgPyBbdmFsdWVQcm9wZXJ0eShjb2xvcktleSwgY29sb3JTY2FsZVR5cGUsIHsgaWQ6IGBjb2xvclZhbHVlYCB9KV0gOiBbXSxcbiAgICAgICAgLi4ubGFiZWxLZXkgPyBbdmFsdWVQcm9wZXJ0eShsYWJlbEtleSwgXCJiYW5kXCIsIHsgaWQ6IGBsYWJlbFZhbHVlYCB9KV0gOiBbXVxuICAgICAgXVxuICAgIH0pO1xuICAgIGNvbnN0IHNpemVLZXlJZHggPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYHNpemVWYWx1ZWApO1xuICAgIGNvbnN0IHByb2Nlc3NlZFNpemUgPSBwcm9jZXNzZWREYXRhLmRvbWFpbi52YWx1ZXNbc2l6ZUtleUlkeF0gPz8gW107XG4gICAgdGhpcy5zaXplU2NhbGUuZG9tYWluID0gbWFya2VyLmRvbWFpbiA/IG1hcmtlci5kb21haW4gOiBwcm9jZXNzZWRTaXplO1xuICAgIGlmIChjb2xvcktleSkge1xuICAgICAgY29uc3QgY29sb3JLZXlJZHggPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYGNvbG9yVmFsdWVgKTtcbiAgICAgIHRoaXMuY29sb3JTY2FsZS5kb21haW4gPSBjb2xvckRvbWFpbiA/PyBwcm9jZXNzZWREYXRhLmRvbWFpbi52YWx1ZXNbY29sb3JLZXlJZHhdID8/IFtdO1xuICAgICAgdGhpcy5jb2xvclNjYWxlLnJhbmdlID0gY29sb3JSYW5nZTtcbiAgICAgIHRoaXMuY29sb3JTY2FsZS51cGRhdGUoKTtcbiAgICB9XG4gICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwidXBkYXRlRGF0YVwiKTtcbiAgfVxuICBnZXRTZXJpZXNEb21haW4oZGlyZWN0aW9uKSB7XG4gICAgY29uc3QgeyBkYXRhTW9kZWwsIHByb2Nlc3NlZERhdGEgfSA9IHRoaXM7XG4gICAgaWYgKCFwcm9jZXNzZWREYXRhIHx8ICFkYXRhTW9kZWwpXG4gICAgICByZXR1cm4gW107XG4gICAgY29uc3QgaWQgPSBkaXJlY3Rpb24gPT09IFwieFwiIC8qIFggKi8gPyBgeFZhbHVlYCA6IGB5VmFsdWVgO1xuICAgIGNvbnN0IGRhdGFEZWYgPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFEZWZCeUlkKHRoaXMsIGlkKTtcbiAgICBjb25zdCBkb21haW4gPSBkYXRhTW9kZWwuZ2V0RG9tYWluKHRoaXMsIGlkLCBcInZhbHVlXCIsIHByb2Nlc3NlZERhdGEpO1xuICAgIGlmIChkYXRhRGVmPy5kZWYudHlwZSA9PT0gXCJ2YWx1ZVwiICYmIGRhdGFEZWY/LmRlZi52YWx1ZVR5cGUgPT09IFwiY2F0ZWdvcnlcIikge1xuICAgICAgcmV0dXJuIGRvbWFpbjtcbiAgICB9XG4gICAgcmV0dXJuIGZpeE51bWVyaWNFeHRlbnQoZXh0ZW50KGRvbWFpbikpO1xuICB9XG4gIGFzeW5jIGNyZWF0ZU5vZGVEYXRhKCkge1xuICAgIGNvbnN0IHsgYXhlcywgZGF0YU1vZGVsLCBwcm9jZXNzZWREYXRhLCBjb2xvclNjYWxlLCBzaXplU2NhbGUgfSA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgeEtleSxcbiAgICAgIHlLZXksXG4gICAgICBzaXplS2V5LFxuICAgICAgeEZpbHRlcktleSxcbiAgICAgIHlGaWx0ZXJLZXksXG4gICAgICBzaXplRmlsdGVyS2V5LFxuICAgICAgbGFiZWxLZXksXG4gICAgICB4TmFtZSxcbiAgICAgIHlOYW1lLFxuICAgICAgc2l6ZU5hbWUsXG4gICAgICBsYWJlbE5hbWUsXG4gICAgICBsYWJlbCxcbiAgICAgIGNvbG9yS2V5LFxuICAgICAgbWFya2VyLFxuICAgICAgdmlzaWJsZVxuICAgIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgbWFya2VyU2hhcGUgPSBnZXRNYXJrZXIobWFya2VyLnNoYXBlKTtcbiAgICBjb25zdCB7IHBsYWNlbWVudCB9ID0gbGFiZWw7XG4gICAgY29uc3QgeEF4aXMgPSBheGVzW1wieFwiIC8qIFggKi9dO1xuICAgIGNvbnN0IHlBeGlzID0gYXhlc1tcInlcIiAvKiBZICovXTtcbiAgICBpZiAoIShkYXRhTW9kZWwgJiYgcHJvY2Vzc2VkRGF0YSAmJiB2aXNpYmxlICYmIHhBeGlzICYmIHlBeGlzKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB4RGF0YUlkeCA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgeFZhbHVlYCk7XG4gICAgY29uc3QgeURhdGFJZHggPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYHlWYWx1ZWApO1xuICAgIGNvbnN0IHNpemVEYXRhSWR4ID0gc2l6ZUtleSAhPSBudWxsID8gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGBzaXplVmFsdWVgKSA6IHZvaWQgMDtcbiAgICBjb25zdCBjb2xvckRhdGFJZHggPSBjb2xvcktleSAhPSBudWxsID8gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGBjb2xvclZhbHVlYCkgOiAtMTtcbiAgICBjb25zdCBsYWJlbERhdGFJZHggPSBsYWJlbEtleSAhPSBudWxsID8gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGBsYWJlbFZhbHVlYCkgOiAtMTtcbiAgICBjb25zdCB4RmlsdGVyRGF0YUlkeCA9IHhGaWx0ZXJLZXkgIT0gbnVsbCA/IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgeEZpbHRlclZhbHVlYCkgOiB2b2lkIDA7XG4gICAgY29uc3QgeUZpbHRlckRhdGFJZHggPSB5RmlsdGVyS2V5ICE9IG51bGwgPyBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYHlGaWx0ZXJWYWx1ZWApIDogdm9pZCAwO1xuICAgIGNvbnN0IHNpemVGaWx0ZXJEYXRhSWR4ID0gc2l6ZUZpbHRlcktleSAhPSBudWxsID8gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGBzaXplRmlsdGVyVmFsdWVgKSA6IHZvaWQgMDtcbiAgICBjb25zdCB4U2NhbGUgPSB4QXhpcy5zY2FsZTtcbiAgICBjb25zdCB5U2NhbGUgPSB5QXhpcy5zY2FsZTtcbiAgICBjb25zdCB4T2Zmc2V0ID0gKHhTY2FsZS5iYW5kd2lkdGggPz8gMCkgLyAyO1xuICAgIGNvbnN0IHlPZmZzZXQgPSAoeVNjYWxlLmJhbmR3aWR0aCA/PyAwKSAvIDI7XG4gICAgY29uc3Qgbm9kZURhdGEgPSBbXTtcbiAgICBzaXplU2NhbGUucmFuZ2UgPSBbbWFya2VyLnNpemUsIG1hcmtlci5tYXhTaXplXTtcbiAgICBjb25zdCBmb250ID0gbGFiZWwuZ2V0Rm9udCgpO1xuICAgIGNvbnN0IHRleHRNZWFzdXJlciA9IENhY2hlZFRleHRNZWFzdXJlclBvb2wuZ2V0TWVhc3VyZXIoeyBmb250IH0pO1xuICAgIGZvciAoY29uc3QgeyB2YWx1ZXMsIGRhdHVtIH0gb2YgcHJvY2Vzc2VkRGF0YS5kYXRhID8/IFtdKSB7XG4gICAgICBjb25zdCB4RGF0dW0gPSB2YWx1ZXNbeERhdGFJZHhdO1xuICAgICAgY29uc3QgeURhdHVtID0gdmFsdWVzW3lEYXRhSWR4XTtcbiAgICAgIGNvbnN0IHNpemVWYWx1ZSA9IHNpemVEYXRhSWR4ICE9IG51bGwgPyB2YWx1ZXNbc2l6ZURhdGFJZHhdIDogdm9pZCAwO1xuICAgICAgY29uc3QgeCA9IHhTY2FsZS5jb252ZXJ0KHhEYXR1bSkgKyB4T2Zmc2V0O1xuICAgICAgY29uc3QgeSA9IHlTY2FsZS5jb252ZXJ0KHlEYXR1bSkgKyB5T2Zmc2V0O1xuICAgICAgbGV0IHNlbGVjdGVkO1xuICAgICAgaWYgKHhGaWx0ZXJEYXRhSWR4ICE9IG51bGwgJiYgeUZpbHRlckRhdGFJZHggIT0gbnVsbCkge1xuICAgICAgICBzZWxlY3RlZCA9IHZhbHVlc1t4RmlsdGVyRGF0YUlkeF0gPT09IHhEYXR1bSAmJiB2YWx1ZXNbeUZpbHRlckRhdGFJZHhdID09PSB5RGF0dW07XG4gICAgICAgIGlmIChzaXplRmlsdGVyRGF0YUlkeCAhPSBudWxsKSB7XG4gICAgICAgICAgc2VsZWN0ZWQgJiYgKHNlbGVjdGVkID0gdmFsdWVzW3NpemVGaWx0ZXJEYXRhSWR4XSA9PT0gc2l6ZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgbGFiZWxUZXh0ID0gdGhpcy5nZXRMYWJlbFRleHQobGFiZWwsIHtcbiAgICAgICAgdmFsdWU6IGxhYmVsS2V5ID8gdmFsdWVzW2xhYmVsRGF0YUlkeF0gOiB5RGF0dW0sXG4gICAgICAgIGRhdHVtLFxuICAgICAgICB4S2V5LFxuICAgICAgICB5S2V5LFxuICAgICAgICBzaXplS2V5LFxuICAgICAgICBsYWJlbEtleSxcbiAgICAgICAgeE5hbWUsXG4gICAgICAgIHlOYW1lLFxuICAgICAgICBzaXplTmFtZSxcbiAgICAgICAgbGFiZWxOYW1lXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHNpemUgPSB0ZXh0TWVhc3VyZXIubWVhc3VyZVRleHQoU3RyaW5nKGxhYmVsVGV4dCkpO1xuICAgICAgY29uc3QgbWFya2VyU2l6ZSA9IHNpemVWYWx1ZSA/IHNpemVTY2FsZS5jb252ZXJ0KHNpemVWYWx1ZSkgOiBtYXJrZXIuc2l6ZTtcbiAgICAgIGNvbnN0IGZpbGwgPSBjb2xvcktleSA/IGNvbG9yU2NhbGUuY29udmVydCh2YWx1ZXNbY29sb3JEYXRhSWR4XSkgOiB2b2lkIDA7XG4gICAgICBub2RlRGF0YS5wdXNoKHtcbiAgICAgICAgc2VyaWVzOiB0aGlzLFxuICAgICAgICBpdGVtSWQ6IHlLZXksXG4gICAgICAgIHlLZXksXG4gICAgICAgIHhLZXksXG4gICAgICAgIGRhdHVtLFxuICAgICAgICB4VmFsdWU6IHhEYXR1bSxcbiAgICAgICAgeVZhbHVlOiB5RGF0dW0sXG4gICAgICAgIHNpemVWYWx1ZSxcbiAgICAgICAgcG9pbnQ6IHsgeCwgeSwgc2l6ZTogbWFya2VyU2l6ZSB9LFxuICAgICAgICBtaWRQb2ludDogeyB4LCB5IH0sXG4gICAgICAgIGZpbGwsXG4gICAgICAgIGxhYmVsOiB7IHRleHQ6IGxhYmVsVGV4dCwgLi4uc2l6ZSB9LFxuICAgICAgICBtYXJrZXI6IG1hcmtlclNoYXBlLFxuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIHNlbGVjdGVkXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGl0ZW1JZDogeUtleSxcbiAgICAgIG5vZGVEYXRhLFxuICAgICAgbGFiZWxEYXRhOiBub2RlRGF0YSxcbiAgICAgIHNjYWxlczogdGhpcy5jYWxjdWxhdGVTY2FsaW5nKCksXG4gICAgICB2aXNpYmxlOiB0aGlzLnZpc2libGVcbiAgICB9O1xuICB9XG4gIGlzUGF0aE9yU2VsZWN0aW9uRGlydHkoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcGVydGllcy5tYXJrZXIuaXNEaXJ0eSgpO1xuICB9XG4gIGdldExhYmVsRGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0Tm9kZURhdGE/LmxhYmVsRGF0YSA/PyBbXTtcbiAgfVxuICBtYXJrZXJGYWN0b3J5KCkge1xuICAgIGNvbnN0IHsgc2hhcGUgfSA9IHRoaXMucHJvcGVydGllcy5tYXJrZXI7XG4gICAgY29uc3QgTWFya2VyU2hhcGUgPSBnZXRNYXJrZXIoc2hhcGUpO1xuICAgIHJldHVybiBuZXcgTWFya2VyU2hhcGUoKTtcbiAgfVxuICBhc3luYyB1cGRhdGVNYXJrZXJTZWxlY3Rpb24ob3B0cykge1xuICAgIGNvbnN0IHsgbm9kZURhdGEsIG1hcmtlclNlbGVjdGlvbiB9ID0gb3B0cztcbiAgICBpZiAodGhpcy5wcm9wZXJ0aWVzLm1hcmtlci5pc0RpcnR5KCkpIHtcbiAgICAgIG1hcmtlclNlbGVjdGlvbi5jbGVhcigpO1xuICAgICAgbWFya2VyU2VsZWN0aW9uLmNsZWFudXAoKTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IHRoaXMucHJvcGVydGllcy5tYXJrZXIuZW5hYmxlZCA/IG5vZGVEYXRhIDogW107XG4gICAgcmV0dXJuIG1hcmtlclNlbGVjdGlvbi51cGRhdGUoXG4gICAgICBkYXRhLFxuICAgICAgdm9pZCAwLFxuICAgICAgKGRhdHVtKSA9PiBjcmVhdGVEYXR1bUlkKFtkYXR1bS54VmFsdWUsIGRhdHVtLnlWYWx1ZSwgZGF0dW0ubGFiZWwudGV4dF0pXG4gICAgKTtcbiAgfVxuICBhc3luYyB1cGRhdGVNYXJrZXJOb2RlcyhvcHRzKSB7XG4gICAgY29uc3QgeyBtYXJrZXJTZWxlY3Rpb24sIGlzSGlnaGxpZ2h0OiBoaWdobGlnaHRlZCB9ID0gb3B0cztcbiAgICBjb25zdCB7IHhLZXksIHlLZXksIHNpemVLZXksIGxhYmVsS2V5LCBtYXJrZXIgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCB7IHNpemUsIHNoYXBlLCBmaWxsLCBmaWxsT3BhY2l0eSwgc3Ryb2tlLCBzdHJva2VXaWR0aCwgc3Ryb2tlT3BhY2l0eSB9ID0gbWVyZ2VEZWZhdWx0cyhcbiAgICAgIGhpZ2hsaWdodGVkICYmIHRoaXMucHJvcGVydGllcy5oaWdobGlnaHRTdHlsZS5pdGVtLFxuICAgICAgbWFya2VyLmdldFN0eWxlKClcbiAgICApO1xuICAgIGNvbnN0IGJhc2VTdHlsZSA9IHsgc2l6ZSwgc2hhcGUsIGZpbGwsIGZpbGxPcGFjaXR5LCBzdHJva2UsIHN0cm9rZVdpZHRoLCBzdHJva2VPcGFjaXR5IH07XG4gICAgdGhpcy5zaXplU2NhbGUucmFuZ2UgPSBbbWFya2VyLnNpemUsIG1hcmtlci5tYXhTaXplXTtcbiAgICBtYXJrZXJTZWxlY3Rpb24uZWFjaCgobm9kZSwgZGF0dW0pID0+IHtcbiAgICAgIHRoaXMudXBkYXRlTWFya2VyU3R5bGUobm9kZSwgbWFya2VyLCB7IGRhdHVtLCBoaWdobGlnaHRlZCwgeEtleSwgeUtleSwgc2l6ZUtleSwgbGFiZWxLZXkgfSwgYmFzZVN0eWxlLCB7XG4gICAgICAgIHNlbGVjdGVkOiBkYXR1bS5zZWxlY3RlZFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKCFoaWdobGlnaHRlZCkge1xuICAgICAgdGhpcy5wcm9wZXJ0aWVzLm1hcmtlci5tYXJrQ2xlYW4oKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgdXBkYXRlTGFiZWxTZWxlY3Rpb24ob3B0cykge1xuICAgIGNvbnN0IHBsYWNlZExhYmVscyA9IHRoaXMucHJvcGVydGllcy5sYWJlbC5lbmFibGVkID8gdGhpcy5jaGFydD8ucGxhY2VMYWJlbHMoKS5nZXQodGhpcykgPz8gW10gOiBbXTtcbiAgICByZXR1cm4gb3B0cy5sYWJlbFNlbGVjdGlvbi51cGRhdGUoXG4gICAgICBwbGFjZWRMYWJlbHMubWFwKCh2KSA9PiAoe1xuICAgICAgICAuLi52LmRhdHVtLFxuICAgICAgICBwb2ludDoge1xuICAgICAgICAgIHg6IHYueCxcbiAgICAgICAgICB5OiB2LnksXG4gICAgICAgICAgc2l6ZTogdi5kYXR1bS5wb2ludC5zaXplXG4gICAgICAgIH1cbiAgICAgIH0pKVxuICAgICk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlTGFiZWxOb2RlcyhvcHRzKSB7XG4gICAgY29uc3QgeyBsYWJlbCB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIG9wdHMubGFiZWxTZWxlY3Rpb24uZWFjaCgodGV4dCwgZGF0dW0pID0+IHtcbiAgICAgIHRleHQudGV4dCA9IGRhdHVtLmxhYmVsLnRleHQ7XG4gICAgICB0ZXh0LmZpbGwgPSBsYWJlbC5jb2xvcjtcbiAgICAgIHRleHQueCA9IGRhdHVtLnBvaW50Py54ID8/IDA7XG4gICAgICB0ZXh0LnkgPSBkYXR1bS5wb2ludD8ueSA/PyAwO1xuICAgICAgdGV4dC5mb250U3R5bGUgPSBsYWJlbC5mb250U3R5bGU7XG4gICAgICB0ZXh0LmZvbnRXZWlnaHQgPSBsYWJlbC5mb250V2VpZ2h0O1xuICAgICAgdGV4dC5mb250U2l6ZSA9IGxhYmVsLmZvbnRTaXplO1xuICAgICAgdGV4dC5mb250RmFtaWx5ID0gbGFiZWwuZm9udEZhbWlseTtcbiAgICAgIHRleHQudGV4dEFsaWduID0gXCJsZWZ0XCI7XG4gICAgICB0ZXh0LnRleHRCYXNlbGluZSA9IFwidG9wXCI7XG4gICAgfSk7XG4gIH1cbiAgZ2V0VG9vbHRpcEh0bWwobm9kZURhdHVtKSB7XG4gICAgY29uc3QgeEF4aXMgPSB0aGlzLmF4ZXNbXCJ4XCIgLyogWCAqL107XG4gICAgY29uc3QgeUF4aXMgPSB0aGlzLmF4ZXNbXCJ5XCIgLyogWSAqL107XG4gICAgaWYgKCF0aGlzLnByb3BlcnRpZXMuaXNWYWxpZCgpIHx8ICF4QXhpcyB8fCAheUF4aXMpIHtcbiAgICAgIHJldHVybiBFTVBUWV9UT09MVElQX0NPTlRFTlQ7XG4gICAgfVxuICAgIGNvbnN0IHsgeEtleSwgeUtleSwgc2l6ZUtleSwgbGFiZWxLZXksIHhOYW1lLCB5TmFtZSwgc2l6ZU5hbWUsIGxhYmVsTmFtZSwgbWFya2VyLCB0b29sdGlwIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgdGl0bGUgPSB0aGlzLnByb3BlcnRpZXMudGl0bGUgPz8geU5hbWU7XG4gICAgY29uc3QgYmFzZVN0eWxlID0gbWVyZ2VEZWZhdWx0cyhcbiAgICAgIHsgZmlsbDogbm9kZURhdHVtLmZpbGwsIHN0cm9rZVdpZHRoOiB0aGlzLmdldFN0cm9rZVdpZHRoKG1hcmtlci5zdHJva2VXaWR0aCkgfSxcbiAgICAgIG1hcmtlci5nZXRTdHlsZSgpXG4gICAgKTtcbiAgICBjb25zdCB7IGZpbGw6IGNvbG9yID0gXCJncmF5XCIgfSA9IHRoaXMuZ2V0TWFya2VyU3R5bGUoXG4gICAgICBtYXJrZXIsXG4gICAgICB7IGRhdHVtOiBub2RlRGF0dW0sIGhpZ2hsaWdodGVkOiBmYWxzZSwgeEtleSwgeUtleSwgc2l6ZUtleSwgbGFiZWxLZXkgfSxcbiAgICAgIGJhc2VTdHlsZVxuICAgICk7XG4gICAgY29uc3Qge1xuICAgICAgZGF0dW0sXG4gICAgICB4VmFsdWUsXG4gICAgICB5VmFsdWUsXG4gICAgICBzaXplVmFsdWUsXG4gICAgICBsYWJlbDogeyB0ZXh0OiBsYWJlbFRleHQgfSxcbiAgICAgIGl0ZW1JZFxuICAgIH0gPSBub2RlRGF0dW07XG4gICAgY29uc3QgeFN0cmluZyA9IHNhbml0aXplSHRtbCh4QXhpcy5mb3JtYXREYXR1bSh4VmFsdWUpKTtcbiAgICBjb25zdCB5U3RyaW5nID0gc2FuaXRpemVIdG1sKHlBeGlzLmZvcm1hdERhdHVtKHlWYWx1ZSkpO1xuICAgIGxldCBjb250ZW50ID0gYDxiPiR7c2FuaXRpemVIdG1sKHhOYW1lID8/IHhLZXkpfTwvYj46ICR7eFN0cmluZ308YnI+PGI+JHtzYW5pdGl6ZUh0bWwoeU5hbWUgPz8geUtleSl9PC9iPjogJHt5U3RyaW5nfWA7XG4gICAgaWYgKHNpemVLZXkpIHtcbiAgICAgIGNvbnRlbnQgKz0gYDxicj48Yj4ke3Nhbml0aXplSHRtbChzaXplTmFtZSA/PyBzaXplS2V5KX08L2I+OiAke3Nhbml0aXplSHRtbChTdHJpbmcoc2l6ZVZhbHVlKSl9YDtcbiAgICB9XG4gICAgaWYgKGxhYmVsS2V5KSB7XG4gICAgICBjb250ZW50ID0gYDxiPiR7c2FuaXRpemVIdG1sKGxhYmVsTmFtZSA/PyBsYWJlbEtleSl9PC9iPjogJHtzYW5pdGl6ZUh0bWwobGFiZWxUZXh0KX08YnI+YCArIGNvbnRlbnQ7XG4gICAgfVxuICAgIHJldHVybiB0b29sdGlwLnRvVG9vbHRpcEh0bWwoXG4gICAgICB7IHRpdGxlLCBjb250ZW50LCBiYWNrZ3JvdW5kQ29sb3I6IGNvbG9yIH0sXG4gICAgICB7XG4gICAgICAgIGRhdHVtLFxuICAgICAgICBpdGVtSWQsXG4gICAgICAgIHhLZXksXG4gICAgICAgIHhOYW1lLFxuICAgICAgICB5S2V5LFxuICAgICAgICB5TmFtZSxcbiAgICAgICAgc2l6ZUtleSxcbiAgICAgICAgc2l6ZU5hbWUsXG4gICAgICAgIGxhYmVsS2V5LFxuICAgICAgICBsYWJlbE5hbWUsXG4gICAgICAgIHRpdGxlLFxuICAgICAgICBjb2xvcixcbiAgICAgICAgc2VyaWVzSWQ6IHRoaXMuaWRcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGdldExlZ2VuZERhdGEoKSB7XG4gICAgaWYgKCF0aGlzLmRhdGE/Lmxlbmd0aCB8fCAhdGhpcy5wcm9wZXJ0aWVzLmlzVmFsaWQoKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCB7IHlLZXksIHlOYW1lLCB0aXRsZSwgbWFya2VyLCB2aXNpYmxlIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgeyBzaGFwZSwgZmlsbCwgc3Ryb2tlLCBmaWxsT3BhY2l0eSwgc3Ryb2tlT3BhY2l0eSwgc3Ryb2tlV2lkdGggfSA9IG1hcmtlcjtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICBsZWdlbmRUeXBlOiBcImNhdGVnb3J5XCIsXG4gICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICBpdGVtSWQ6IHlLZXksXG4gICAgICAgIHNlcmllc0lkOiB0aGlzLmlkLFxuICAgICAgICBlbmFibGVkOiB2aXNpYmxlLFxuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgIHRleHQ6IHRpdGxlID8/IHlOYW1lID8/IHlLZXlcbiAgICAgICAgfSxcbiAgICAgICAgc3ltYm9sczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1hcmtlcjoge1xuICAgICAgICAgICAgICBzaGFwZSxcbiAgICAgICAgICAgICAgZmlsbDogZmlsbCA/PyBcInJnYmEoMCwgMCwgMCwgMClcIixcbiAgICAgICAgICAgICAgc3Ryb2tlOiBzdHJva2UgPz8gXCJyZ2JhKDAsIDAsIDAsIDApXCIsXG4gICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiBmaWxsT3BhY2l0eSA/PyAxLFxuICAgICAgICAgICAgICBzdHJva2VPcGFjaXR5OiBzdHJva2VPcGFjaXR5ID8/IDEsXG4gICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCA/PyAwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9XG4gICAgXTtcbiAgfVxuICBhbmltYXRlRW1wdHlVcGRhdGVSZWFkeSh7IG1hcmtlclNlbGVjdGlvbiwgbGFiZWxTZWxlY3Rpb24gfSkge1xuICAgIG1hcmtlclNjYWxlSW5BbmltYXRpb24odGhpcywgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgbWFya2VyU2VsZWN0aW9uKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImxhYmVsc1wiLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCBsYWJlbFNlbGVjdGlvbik7XG4gIH1cbiAgaXNMYWJlbEVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcGVydGllcy5sYWJlbC5lbmFibGVkO1xuICB9XG4gIG5vZGVGYWN0b3J5KCkge1xuICAgIHJldHVybiBuZXcgR3JvdXAoKTtcbiAgfVxuICBnZXRGb3JtYXR0ZWRNYXJrZXJTdHlsZShkYXR1bSkge1xuICAgIGNvbnN0IHsgeEtleSwgeUtleSwgc2l6ZUtleSwgbGFiZWxLZXkgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICByZXR1cm4gdGhpcy5nZXRNYXJrZXJTdHlsZSh0aGlzLnByb3BlcnRpZXMubWFya2VyLCB7XG4gICAgICBkYXR1bSxcbiAgICAgIHhLZXksXG4gICAgICB5S2V5LFxuICAgICAgc2l6ZUtleSxcbiAgICAgIGxhYmVsS2V5LFxuICAgICAgaGlnaGxpZ2h0ZWQ6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgY29tcHV0ZUZvY3VzQm91bmRzKG9wdHMpIHtcbiAgICByZXR1cm4gY29tcHV0ZU1hcmtlckZvY3VzQm91bmRzKHRoaXMsIG9wdHMpO1xuICB9XG59O1xuQnViYmxlU2VyaWVzLmNsYXNzTmFtZSA9IFwiQnViYmxlU2VyaWVzXCI7XG5CdWJibGVTZXJpZXMudHlwZSA9IFwiYnViYmxlXCI7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vYnViYmxlU2VyaWVzTW9kdWxlLnRzXG52YXIgQnViYmxlU2VyaWVzTW9kdWxlID0ge1xuICB0eXBlOiBcInNlcmllc1wiLFxuICBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsXG4gIHBhY2thZ2VUeXBlOiBcImNvbW11bml0eVwiLFxuICBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIl0sXG4gIGlkZW50aWZpZXI6IFwiYnViYmxlXCIsXG4gIG1vZHVsZUZhY3Rvcnk6IChjdHgpID0+IG5ldyBCdWJibGVTZXJpZXMoY3R4KSxcbiAgdG9vbHRpcERlZmF1bHRzOiB7IHJhbmdlOiBcIm5lYXJlc3RcIiB9LFxuICBkZWZhdWx0QXhlczogW1xuICAgIHtcbiAgICAgIHR5cGU6IFwibnVtYmVyXCIgLyogTlVNQkVSICovLFxuICAgICAgcG9zaXRpb246IFwiYm90dG9tXCIgLyogQk9UVE9NICovXG4gICAgfSxcbiAgICB7XG4gICAgICB0eXBlOiBcIm51bWJlclwiIC8qIE5VTUJFUiAqLyxcbiAgICAgIHBvc2l0aW9uOiBcImxlZnRcIiAvKiBMRUZUICovXG4gICAgfVxuICBdLFxuICB0aGVtZVRlbXBsYXRlOiB7XG4gICAgc2VyaWVzOiB7XG4gICAgICBzaGFwZTogXCJjaXJjbGVcIixcbiAgICAgIHNpemU6IDcsXG4gICAgICBtYXhTaXplOiAzMCxcbiAgICAgIGZpbGxPcGFjaXR5OiAwLjgsXG4gICAgICB0b29sdGlwOiB7IHBvc2l0aW9uOiB7IHR5cGU6IFwibm9kZVwiIH0gfSxcbiAgICAgIGxhYmVsOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBmb250U2l6ZTogMTIsXG4gICAgICAgIGZvbnRGYW1pbHk6IERFRkFVTFRfRk9OVF9GQU1JTFksXG4gICAgICAgIGNvbG9yOiBERUZBVUxUX0xBQkVMX0NPTE9VUlxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcGFsZXR0ZUZhY3Rvcnk6IHNpbmdsZVNlcmllc1BhbGV0dGVGYWN0b3J5XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2hpc3RvZ3JhbVNlcmllc1Byb3BlcnRpZXMudHNcbnZhciBIaXN0b2dyYW1TZXJpZXNQcm9wZXJ0aWVzID0gY2xhc3MgZXh0ZW5kcyBDYXJ0ZXNpYW5TZXJpZXNQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmZpbGxPcGFjaXR5ID0gMTtcbiAgICB0aGlzLnN0cm9rZVdpZHRoID0gMTtcbiAgICB0aGlzLnN0cm9rZU9wYWNpdHkgPSAxO1xuICAgIHRoaXMubGluZURhc2ggPSBbMF07XG4gICAgdGhpcy5saW5lRGFzaE9mZnNldCA9IDA7XG4gICAgdGhpcy5jb3JuZXJSYWRpdXMgPSAwO1xuICAgIHRoaXMuYXJlYVBsb3QgPSBmYWxzZTtcbiAgICB0aGlzLmFnZ3JlZ2F0aW9uID0gXCJzdW1cIjtcbiAgICB0aGlzLnNoYWRvdyA9IG5ldyBEcm9wU2hhZG93KCk7XG4gICAgdGhpcy5sYWJlbCA9IG5ldyBMYWJlbCgpO1xuICAgIHRoaXMudG9vbHRpcCA9IG5ldyBTZXJpZXNUb29sdGlwKCk7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcpXG5dLCBIaXN0b2dyYW1TZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ4S2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBIaXN0b2dyYW1TZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ5S2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBIaXN0b2dyYW1TZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ4TmFtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgSGlzdG9ncmFtU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwieU5hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEhpc3RvZ3JhbVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImZpbGxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTylcbl0sIEhpc3RvZ3JhbVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImZpbGxPcGFjaXR5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBIaXN0b2dyYW1TZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdHJva2VcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBIaXN0b2dyYW1TZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdHJva2VXaWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPKVxuXSwgSGlzdG9ncmFtU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic3Ryb2tlT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKExJTkVfREFTSClcbl0sIEhpc3RvZ3JhbVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImxpbmVEYXNoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgSGlzdG9ncmFtU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGluZURhc2hPZmZzZXRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBIaXN0b2dyYW1TZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjb3JuZXJSYWRpdXNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgSGlzdG9ncmFtU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiYXJlYVBsb3RcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShBUlJBWSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgSGlzdG9ncmFtU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiYmluc1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFVOSU9OKFtcImNvdW50XCIsIFwic3VtXCIsIFwibWVhblwiXSwgXCJhIGhpc3RvZ3JhbSBhZ2dyZWdhdGlvblwiKSlcbl0sIEhpc3RvZ3JhbVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImFnZ3JlZ2F0aW9uXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBIaXN0b2dyYW1TZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJiaW5Db3VudFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIEhpc3RvZ3JhbVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInNoYWRvd1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIEhpc3RvZ3JhbVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImxhYmVsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgSGlzdG9ncmFtU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwidG9vbHRpcFwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9oaXN0b2dyYW1TZXJpZXMudHNcbnZhciBkZWZhdWx0QmluQ291bnQgPSAxMDtcbnZhciBIaXN0b2dyYW1TZXJpZXMgPSBjbGFzcyBleHRlbmRzIENhcnRlc2lhblNlcmllcyB7XG4gIGNvbnN0cnVjdG9yKG1vZHVsZUN0eCkge1xuICAgIHN1cGVyKHtcbiAgICAgIG1vZHVsZUN0eCxcbiAgICAgIGRpcmVjdGlvbktleXM6IERFRkFVTFRfQ0FSVEVTSUFOX0RJUkVDVElPTl9LRVlTLFxuICAgICAgZGlyZWN0aW9uTmFtZXM6IERFRkFVTFRfQ0FSVEVTSUFOX0RJUkVDVElPTl9OQU1FUyxcbiAgICAgIHBpY2tNb2RlczogWzEgLyogTkVBUkVTVF9OT0RFICovLCAwIC8qIEVYQUNUX1NIQVBFX01BVENIICovXSxcbiAgICAgIGRhdHVtU2VsZWN0aW9uR2FyYmFnZUNvbGxlY3Rpb246IGZhbHNlLFxuICAgICAgYW5pbWF0aW9uUmVzZXRGbnM6IHtcbiAgICAgICAgZGF0dW06IHJlc2V0QmFyU2VsZWN0aW9uc0ZuLFxuICAgICAgICBsYWJlbDogcmVzZXRMYWJlbEZuXG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5wcm9wZXJ0aWVzID0gbmV3IEhpc3RvZ3JhbVNlcmllc1Byb3BlcnRpZXMoKTtcbiAgICB0aGlzLmNhbGN1bGF0ZWRCaW5zID0gW107XG4gIH1cbiAgLy8gRHVyaW5nIHByb2Nlc3NEYXRhIHBoYXNlLCB1c2VkIHRvIHVuaWZ5IGRpZmZlcmVudCB3YXlzIG9mIHRoZSB1c2VyIHNwZWNpZnlpbmdcbiAgLy8gdGhlIGJpbnMuIFJldHVybnMgYmlucyBpbiBmb3JtYXRbW21pbjEsIG1heDFdLCBbbWluMiwgbWF4Ml0sIC4uLiBdLlxuICBkZXJpdmVCaW5zKHhEb21haW4pIHtcbiAgICBjb25zdCBiaW5TdGFydHMgPSBjcmVhdGVUaWNrcyh4RG9tYWluWzBdLCB4RG9tYWluWzFdLCBkZWZhdWx0QmluQ291bnQpO1xuICAgIGNvbnN0IGJpblNpemUgPSB0aWNrU3RlcCh4RG9tYWluWzBdLCB4RG9tYWluWzFdLCBkZWZhdWx0QmluQ291bnQpO1xuICAgIGNvbnN0IFtmaXJzdEJpbkVuZF0gPSBiaW5TdGFydHM7XG4gICAgY29uc3QgZXhwYW5kU3RhcnRUb0JpbiA9IChuKSA9PiBbbiwgbiArIGJpblNpemVdO1xuICAgIHJldHVybiBbW2ZpcnN0QmluRW5kIC0gYmluU2l6ZSwgZmlyc3RCaW5FbmRdLCAuLi5iaW5TdGFydHMubWFwKGV4cGFuZFN0YXJ0VG9CaW4pXTtcbiAgfVxuICBjYWxjdWxhdGVOaWNlQmlucyhkb21haW4sIGJpbkNvdW50KSB7XG4gICAgY29uc3Qgc3RhcnRHdWVzcyA9IE1hdGguZmxvb3IoZG9tYWluWzBdKTtcbiAgICBjb25zdCBzdG9wID0gZG9tYWluWzFdO1xuICAgIGNvbnN0IHNlZ21lbnRzID0gYmluQ291bnQgfHwgMTtcbiAgICBjb25zdCB7IHN0YXJ0OiBzdGFydDIsIGJpblNpemUgfSA9IHRoaXMuY2FsY3VsYXRlTmljZVN0YXJ0KHN0YXJ0R3Vlc3MsIHN0b3AsIHNlZ21lbnRzKTtcbiAgICByZXR1cm4gdGhpcy5nZXRCaW5zKHN0YXJ0Miwgc3RvcCwgYmluU2l6ZSwgc2VnbWVudHMpO1xuICB9XG4gIGdldEJpbnMoc3RhcnQyLCBzdG9wLCBzdGVwLCBjb3VudCkge1xuICAgIGNvbnN0IGJpbnMgPSBbXTtcbiAgICBjb25zdCBwcmVjaXNpb24gPSB0aGlzLmNhbGN1bGF0ZVByZWNpc2lvbihzdGVwKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IGEgPSBNYXRoLnJvdW5kKChzdGFydDIgKyBpICogc3RlcCkgKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uO1xuICAgICAgbGV0IGIgPSBNYXRoLnJvdW5kKChzdGFydDIgKyAoaSArIDEpICogc3RlcCkgKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uO1xuICAgICAgaWYgKGkgPT09IGNvdW50IC0gMSkge1xuICAgICAgICBiID0gTWF0aC5tYXgoYiwgc3RvcCk7XG4gICAgICB9XG4gICAgICBiaW5zW2ldID0gW2EsIGJdO1xuICAgIH1cbiAgICByZXR1cm4gYmlucztcbiAgfVxuICBjYWxjdWxhdGVQcmVjaXNpb24oc3RlcCkge1xuICAgIGxldCBwcmVjaXNpb24gPSAxMDtcbiAgICBpZiAoaXNGaW5pdGUoc3RlcCkgJiYgc3RlcCA+IDApIHtcbiAgICAgIHdoaWxlIChzdGVwIDwgMSkge1xuICAgICAgICBwcmVjaXNpb24gKj0gMTA7XG4gICAgICAgIHN0ZXAgKj0gMTA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcmVjaXNpb247XG4gIH1cbiAgY2FsY3VsYXRlTmljZVN0YXJ0KGEsIGIsIHNlZ21lbnRzKSB7XG4gICAgY29uc3QgYmluU2l6ZSA9IE1hdGguYWJzKGIgLSBhKSAvIHNlZ21lbnRzO1xuICAgIGNvbnN0IG9yZGVyID0gTWF0aC5mbG9vcihNYXRoLmxvZzEwKGJpblNpemUpKTtcbiAgICBjb25zdCBtYWduaXR1ZGUgPSBNYXRoLnBvdygxMCwgb3JkZXIpO1xuICAgIGNvbnN0IHN0YXJ0MiA9IE1hdGguZmxvb3IoYSAvIG1hZ25pdHVkZSkgKiBtYWduaXR1ZGU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBzdGFydDIsXG4gICAgICBiaW5TaXplXG4gICAgfTtcbiAgfVxuICBhc3luYyBwcm9jZXNzRGF0YShkYXRhQ29udHJvbGxlcikge1xuICAgIGlmICghdGhpcy52aXNpYmxlKSB7XG4gICAgICB0aGlzLnByb2Nlc3NlZERhdGEgPSB2b2lkIDA7XG4gICAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJ1cGRhdGVEYXRhXCIpO1xuICAgIH1cbiAgICBjb25zdCB7IHhLZXksIHlLZXksIGFyZWFQbG90LCBhZ2dyZWdhdGlvbiB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHhTY2FsZSA9IHRoaXMuYXhlc1tcInhcIiAvKiBYICovXT8uc2NhbGU7XG4gICAgY29uc3QgeVNjYWxlID0gdGhpcy5heGVzW1wieVwiIC8qIFkgKi9dPy5zY2FsZTtcbiAgICBjb25zdCB7IHhTY2FsZVR5cGUsIHlTY2FsZVR5cGUgfSA9IHRoaXMuZ2V0U2NhbGVJbmZvcm1hdGlvbih7IHlTY2FsZSwgeFNjYWxlIH0pO1xuICAgIGNvbnN0IHByb3BzID0gW2tleVByb3BlcnR5KHhLZXksIHhTY2FsZVR5cGUpLCBTT1JUX0RPTUFJTl9HUk9VUFNdO1xuICAgIGlmICh5S2V5KSB7XG4gICAgICBsZXQgYWdnUHJvcCA9IGdyb3VwQ291bnQoXCJncm91cEFnZ1wiKTtcbiAgICAgIGlmIChhZ2dyZWdhdGlvbiA9PT0gXCJjb3VudFwiKSB7XG4gICAgICB9IGVsc2UgaWYgKGFnZ3JlZ2F0aW9uID09PSBcInN1bVwiKSB7XG4gICAgICAgIGFnZ1Byb3AgPSBncm91cFN1bShcImdyb3VwQWdnXCIpO1xuICAgICAgfSBlbHNlIGlmIChhZ2dyZWdhdGlvbiA9PT0gXCJtZWFuXCIpIHtcbiAgICAgICAgYWdnUHJvcCA9IGdyb3VwQXZlcmFnZShcImdyb3VwQWdnXCIpO1xuICAgICAgfVxuICAgICAgaWYgKGFyZWFQbG90KSB7XG4gICAgICAgIGFnZ1Byb3AgPSBhcmVhKFwiZ3JvdXBBZ2dcIiwgYWdnUHJvcCk7XG4gICAgICB9XG4gICAgICBwcm9wcy5wdXNoKHZhbHVlUHJvcGVydHkoeUtleSwgeVNjYWxlVHlwZSwgeyBpbnZhbGlkVmFsdWU6IHZvaWQgMCB9KSwgYWdnUHJvcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBhZ2dQcm9wID0gZ3JvdXBDb3VudChcImdyb3VwQWdnXCIpO1xuICAgICAgaWYgKGFyZWFQbG90KSB7XG4gICAgICAgIGFnZ1Byb3AgPSBhcmVhKFwiZ3JvdXBBZ2dcIiwgYWdnUHJvcCk7XG4gICAgICB9XG4gICAgICBwcm9wcy5wdXNoKGFnZ1Byb3ApO1xuICAgIH1cbiAgICBjb25zdCBncm91cEJ5Rm4gPSAoZGF0YVNldCkgPT4ge1xuICAgICAgY29uc3QgeEV4dGVudCA9IGZpeE51bWVyaWNFeHRlbnQoZGF0YVNldC5kb21haW4ua2V5c1swXSk7XG4gICAgICBpZiAoeEV4dGVudC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZGF0YVNldC5kb21haW4uZ3JvdXBzID0gW107XG4gICAgICAgIHJldHVybiAoKSA9PiBbXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJpbnMgPSBpc051bWJlcih0aGlzLnByb3BlcnRpZXMuYmluQ291bnQpID8gdGhpcy5jYWxjdWxhdGVOaWNlQmlucyh4RXh0ZW50LCB0aGlzLnByb3BlcnRpZXMuYmluQ291bnQpIDogdGhpcy5wcm9wZXJ0aWVzLmJpbnMgPz8gdGhpcy5kZXJpdmVCaW5zKHhFeHRlbnQpO1xuICAgICAgY29uc3QgYmluQ291bnQgPSBiaW5zLmxlbmd0aDtcbiAgICAgIHRoaXMuY2FsY3VsYXRlZEJpbnMgPSBbLi4uYmluc107XG4gICAgICByZXR1cm4gKGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3QgeFZhbHVlID0gaXRlbS5rZXlzWzBdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbkNvdW50OyBpKyspIHtcbiAgICAgICAgICBjb25zdCBuZXh0QmluID0gYmluc1tpXTtcbiAgICAgICAgICBpZiAoeFZhbHVlID49IG5leHRCaW5bMF0gJiYgeFZhbHVlIDwgbmV4dEJpblsxXSkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHRCaW47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpID09PSBiaW5Db3VudCAtIDEgJiYgeFZhbHVlIDw9IG5leHRCaW5bMV0pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0QmluO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgICB9O1xuICAgIH07XG4gICAgaWYgKCF0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLmlzU2tpcHBlZCgpICYmIHRoaXMucHJvY2Vzc2VkRGF0YSkge1xuICAgICAgcHJvcHMucHVzaChkaWZmKHRoaXMucHJvY2Vzc2VkRGF0YSwgZmFsc2UpKTtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5yZXF1ZXN0RGF0YU1vZGVsKGRhdGFDb250cm9sbGVyLCB0aGlzLmRhdGEsIHsgcHJvcHMsIGdyb3VwQnlGbiB9KTtcbiAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJ1cGRhdGVEYXRhXCIpO1xuICB9XG4gIGdldFNlcmllc0RvbWFpbihkaXJlY3Rpb24pIHtcbiAgICBjb25zdCB7IHByb2Nlc3NlZERhdGEsIGRhdGFNb2RlbCB9ID0gdGhpcztcbiAgICBpZiAoIXByb2Nlc3NlZERhdGEgfHwgIWRhdGFNb2RlbCB8fCAhdGhpcy5jYWxjdWxhdGVkQmlucy5sZW5ndGgpXG4gICAgICByZXR1cm4gW107XG4gICAgY29uc3QgeURvbWFpbiA9IGRhdGFNb2RlbC5nZXREb21haW4odGhpcywgYGdyb3VwQWdnYCwgXCJhZ2dyZWdhdGVcIiwgcHJvY2Vzc2VkRGF0YSk7XG4gICAgY29uc3QgeERvbWFpbk1pbiA9IHRoaXMuY2FsY3VsYXRlZEJpbnM/LlswXVswXTtcbiAgICBjb25zdCB4RG9tYWluTWF4ID0gdGhpcy5jYWxjdWxhdGVkQmlucz8uWyh0aGlzLmNhbGN1bGF0ZWRCaW5zPy5sZW5ndGggPz8gMCkgLSAxXVsxXTtcbiAgICBpZiAoZGlyZWN0aW9uID09PSBcInhcIiAvKiBYICovKSB7XG4gICAgICByZXR1cm4gZml4TnVtZXJpY0V4dGVudChbeERvbWFpbk1pbiwgeERvbWFpbk1heF0pO1xuICAgIH1cbiAgICByZXR1cm4gZml4TnVtZXJpY0V4dGVudCh5RG9tYWluKTtcbiAgfVxuICBhc3luYyBjcmVhdGVOb2RlRGF0YSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBpZDogc2VyaWVzSWQsXG4gICAgICBheGVzLFxuICAgICAgcHJvY2Vzc2VkRGF0YSxcbiAgICAgIGN0eDogeyBjYWxsYmFja0NhY2hlIH1cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB4QXhpcyA9IGF4ZXNbXCJ4XCIgLyogWCAqL107XG4gICAgY29uc3QgeUF4aXMgPSBheGVzW1wieVwiIC8qIFkgKi9dO1xuICAgIGlmICgheEF4aXMgfHwgIXlBeGlzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgc2NhbGU6IHhTY2FsZSB9ID0geEF4aXM7XG4gICAgY29uc3QgeyBzY2FsZTogeVNjYWxlIH0gPSB5QXhpcztcbiAgICBjb25zdCB7IHhLZXksIHlLZXksIHhOYW1lLCB5TmFtZSwgZmlsbCwgc3Ryb2tlLCBzdHJva2VXaWR0aCwgY29ybmVyUmFkaXVzIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgbGFiZWxGb3JtYXR0ZXIgPSB0aGlzLnByb3BlcnRpZXMubGFiZWwuZm9ybWF0dGVyID8/ICgocGFyYW1zKSA9PiBTdHJpbmcocGFyYW1zLnZhbHVlKSk7XG4gICAgY29uc3Qgbm9kZURhdGEgPSBbXTtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgaXRlbUlkOiB0aGlzLnByb3BlcnRpZXMueUtleSA/PyB0aGlzLmlkLFxuICAgICAgbm9kZURhdGEsXG4gICAgICBsYWJlbERhdGE6IG5vZGVEYXRhLFxuICAgICAgc2NhbGVzOiB0aGlzLmNhbGN1bGF0ZVNjYWxpbmcoKSxcbiAgICAgIGFuaW1hdGlvblZhbGlkOiB0cnVlLFxuICAgICAgdmlzaWJsZTogdGhpcy52aXNpYmxlXG4gICAgfTtcbiAgICBpZiAoIXRoaXMudmlzaWJsZSB8fCAhcHJvY2Vzc2VkRGF0YSB8fCBwcm9jZXNzZWREYXRhLnR5cGUgIT09IFwiZ3JvdXBlZFwiKVxuICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgcHJvY2Vzc2VkRGF0YS5kYXRhLmZvckVhY2goKGdyb3VwKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFnZ1ZhbHVlczogW1tuZWdhdGl2ZUFnZywgcG9zaXRpdmVBZ2ddXSA9IFtbMCwgMF1dLFxuICAgICAgICBkYXR1bSxcbiAgICAgICAgZGF0dW06IHsgbGVuZ3RoOiBmcmVxdWVuY3kgfSxcbiAgICAgICAga2V5czogZG9tYWluLFxuICAgICAgICBrZXlzOiBbeERvbWFpbk1pbiwgeERvbWFpbk1heF1cbiAgICAgIH0gPSBncm91cDtcbiAgICAgIGNvbnN0IHhNaW5QeCA9IHhTY2FsZS5jb252ZXJ0KHhEb21haW5NaW4pO1xuICAgICAgY29uc3QgeE1heFB4ID0geFNjYWxlLmNvbnZlcnQoeERvbWFpbk1heCk7XG4gICAgICBjb25zdCB0b3RhbCA9IG5lZ2F0aXZlQWdnICsgcG9zaXRpdmVBZ2c7XG4gICAgICBjb25zdCB5WmVyb1B4ID0geVNjYWxlLmNvbnZlcnQoMCk7XG4gICAgICBjb25zdCB5TWF4UHggPSB5U2NhbGUuY29udmVydCh0b3RhbCk7XG4gICAgICBjb25zdCB3ID0gTWF0aC5hYnMoeE1heFB4IC0geE1pblB4KTtcbiAgICAgIGNvbnN0IGggPSBNYXRoLmFicyh5TWF4UHggLSB5WmVyb1B4KTtcbiAgICAgIGNvbnN0IHggPSBNYXRoLm1pbih4TWluUHgsIHhNYXhQeCk7XG4gICAgICBjb25zdCB5ID0gTWF0aC5taW4oeVplcm9QeCwgeU1heFB4KTtcbiAgICAgIGxldCBzZWxlY3Rpb25EYXR1bUxhYmVsID0gdm9pZCAwO1xuICAgICAgaWYgKHRvdGFsICE9PSAwKSB7XG4gICAgICAgIHNlbGVjdGlvbkRhdHVtTGFiZWwgPSB7XG4gICAgICAgICAgeDogeCArIHcgLyAyLFxuICAgICAgICAgIHk6IHkgKyBoIC8gMixcbiAgICAgICAgICB0ZXh0OiBjYWxsYmFja0NhY2hlLmNhbGwobGFiZWxGb3JtYXR0ZXIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0b3RhbCxcbiAgICAgICAgICAgIGRhdHVtLFxuICAgICAgICAgICAgc2VyaWVzSWQsXG4gICAgICAgICAgICB4S2V5LFxuICAgICAgICAgICAgeUtleSxcbiAgICAgICAgICAgIHhOYW1lLFxuICAgICAgICAgICAgeU5hbWVcbiAgICAgICAgICB9KSA/PyBTdHJpbmcodG90YWwpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBub2RlTWlkUG9pbnQgPSB7XG4gICAgICAgIHg6IHggKyB3IC8gMixcbiAgICAgICAgeTogeSArIGggLyAyXG4gICAgICB9O1xuICAgICAgY29uc3QgeUF4aXNSZXZlcnNlZCA9IHlBeGlzLmlzUmV2ZXJzZWQoKTtcbiAgICAgIG5vZGVEYXRhLnB1c2goe1xuICAgICAgICBzZXJpZXM6IHRoaXMsXG4gICAgICAgIGRhdHVtLFxuICAgICAgICAvLyByZXF1aXJlZCBieSBTZXJpZXNOb2RlRGF0dW0sIGJ1dCBtaWdodCBub3QgbWFrZSBzZW5zZSBoZXJlXG4gICAgICAgIC8vIHNpbmNlIGVhY2ggc2VsZWN0aW9uIGlzIGFuIGFnZ3JlZ2F0aW9uIG9mIG11bHRpcGxlIGRhdGEuXG4gICAgICAgIGFnZ3JlZ2F0ZWRWYWx1ZTogdG90YWwsXG4gICAgICAgIGZyZXF1ZW5jeSxcbiAgICAgICAgZG9tYWluLFxuICAgICAgICB5S2V5LFxuICAgICAgICB4S2V5LFxuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICB4VmFsdWU6IHhNaW5QeCxcbiAgICAgICAgeVZhbHVlOiB5TWF4UHgsXG4gICAgICAgIHdpZHRoOiB3LFxuICAgICAgICBoZWlnaHQ6IGgsXG4gICAgICAgIG1pZFBvaW50OiBub2RlTWlkUG9pbnQsXG4gICAgICAgIGZpbGwsXG4gICAgICAgIHN0cm9rZSxcbiAgICAgICAgY29ybmVyUmFkaXVzLFxuICAgICAgICB0b3BMZWZ0Q29ybmVyUmFkaXVzOiAheUF4aXNSZXZlcnNlZCxcbiAgICAgICAgdG9wUmlnaHRDb3JuZXJSYWRpdXM6ICF5QXhpc1JldmVyc2VkLFxuICAgICAgICBib3R0b21SaWdodENvcm5lclJhZGl1czogeUF4aXNSZXZlcnNlZCxcbiAgICAgICAgYm90dG9tTGVmdENvcm5lclJhZGl1czogeUF4aXNSZXZlcnNlZCxcbiAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICAgIGxhYmVsOiBzZWxlY3Rpb25EYXR1bUxhYmVsXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBub2RlRGF0YS5zb3J0KChhLCBiKSA9PiBhLnggLSBiLngpO1xuICAgIHJldHVybiBjb250ZXh0O1xuICB9XG4gIG5vZGVGYWN0b3J5KCkge1xuICAgIHJldHVybiBuZXcgUmVjdCgpO1xuICB9XG4gIGFzeW5jIHVwZGF0ZURhdHVtU2VsZWN0aW9uKG9wdHMpIHtcbiAgICBjb25zdCB7IG5vZGVEYXRhLCBkYXR1bVNlbGVjdGlvbiB9ID0gb3B0cztcbiAgICByZXR1cm4gZGF0dW1TZWxlY3Rpb24udXBkYXRlKFxuICAgICAgbm9kZURhdGEsXG4gICAgICAocmVjdCkgPT4ge1xuICAgICAgICByZWN0LmNyaXNwID0gdHJ1ZTtcbiAgICAgIH0sXG4gICAgICAoZGF0dW0pID0+IGRhdHVtLmRvbWFpbi5qb2luKFwiX1wiKVxuICAgICk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlRGF0dW1Ob2RlcyhvcHRzKSB7XG4gICAgY29uc3QgeyBpc0hpZ2hsaWdodDogaXNEYXR1bUhpZ2hsaWdodGVkIH0gPSBvcHRzO1xuICAgIGNvbnN0IHtcbiAgICAgIGZpbGxPcGFjaXR5OiBzZXJpZXNGaWxsT3BhY2l0eSxcbiAgICAgIHN0cm9rZU9wYWNpdHksXG4gICAgICBsaW5lRGFzaCxcbiAgICAgIGxpbmVEYXNoT2Zmc2V0LFxuICAgICAgc2hhZG93LFxuICAgICAgaGlnaGxpZ2h0U3R5bGU6IHtcbiAgICAgICAgaXRlbToge1xuICAgICAgICAgIGZpbGw6IGhpZ2hsaWdodGVkRmlsbCxcbiAgICAgICAgICBmaWxsT3BhY2l0eTogaGlnaGxpZ2h0RmlsbE9wYWNpdHkgPSBzZXJpZXNGaWxsT3BhY2l0eSxcbiAgICAgICAgICBzdHJva2U6IGhpZ2hsaWdodGVkU3Ryb2tlLFxuICAgICAgICAgIHN0cm9rZVdpZHRoOiBoaWdobGlnaHRlZERhdHVtU3Ryb2tlV2lkdGhcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgb3B0cy5kYXR1bVNlbGVjdGlvbi5lYWNoKChyZWN0LCBkYXR1bSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29ybmVyUmFkaXVzLFxuICAgICAgICB0b3BMZWZ0Q29ybmVyUmFkaXVzLFxuICAgICAgICB0b3BSaWdodENvcm5lclJhZGl1cyxcbiAgICAgICAgYm90dG9tUmlnaHRDb3JuZXJSYWRpdXMsXG4gICAgICAgIGJvdHRvbUxlZnRDb3JuZXJSYWRpdXNcbiAgICAgIH0gPSBkYXR1bTtcbiAgICAgIGNvbnN0IHN0cm9rZVdpZHRoID0gaXNEYXR1bUhpZ2hsaWdodGVkICYmIGhpZ2hsaWdodGVkRGF0dW1TdHJva2VXaWR0aCAhPT0gdm9pZCAwID8gaGlnaGxpZ2h0ZWREYXR1bVN0cm9rZVdpZHRoIDogZGF0dW0uc3Ryb2tlV2lkdGg7XG4gICAgICBjb25zdCBmaWxsT3BhY2l0eSA9IGlzRGF0dW1IaWdobGlnaHRlZCA/IGhpZ2hsaWdodEZpbGxPcGFjaXR5IDogc2VyaWVzRmlsbE9wYWNpdHk7XG4gICAgICByZWN0LmZpbGwgPSAoaXNEYXR1bUhpZ2hsaWdodGVkID8gaGlnaGxpZ2h0ZWRGaWxsIDogdm9pZCAwKSA/PyBkYXR1bS5maWxsO1xuICAgICAgcmVjdC5zdHJva2UgPSAoaXNEYXR1bUhpZ2hsaWdodGVkID8gaGlnaGxpZ2h0ZWRTdHJva2UgOiB2b2lkIDApID8/IGRhdHVtLnN0cm9rZTtcbiAgICAgIHJlY3QuZmlsbE9wYWNpdHkgPSBmaWxsT3BhY2l0eTtcbiAgICAgIHJlY3Quc3Ryb2tlT3BhY2l0eSA9IHN0cm9rZU9wYWNpdHk7XG4gICAgICByZWN0LnN0cm9rZVdpZHRoID0gc3Ryb2tlV2lkdGg7XG4gICAgICByZWN0LmxpbmVEYXNoID0gbGluZURhc2g7XG4gICAgICByZWN0LmxpbmVEYXNoT2Zmc2V0ID0gbGluZURhc2hPZmZzZXQ7XG4gICAgICByZWN0LnRvcExlZnRDb3JuZXJSYWRpdXMgPSB0b3BMZWZ0Q29ybmVyUmFkaXVzID8gY29ybmVyUmFkaXVzIDogMDtcbiAgICAgIHJlY3QudG9wUmlnaHRDb3JuZXJSYWRpdXMgPSB0b3BSaWdodENvcm5lclJhZGl1cyA/IGNvcm5lclJhZGl1cyA6IDA7XG4gICAgICByZWN0LmJvdHRvbVJpZ2h0Q29ybmVyUmFkaXVzID0gYm90dG9tUmlnaHRDb3JuZXJSYWRpdXMgPyBjb3JuZXJSYWRpdXMgOiAwO1xuICAgICAgcmVjdC5ib3R0b21MZWZ0Q29ybmVyUmFkaXVzID0gYm90dG9tTGVmdENvcm5lclJhZGl1cyA/IGNvcm5lclJhZGl1cyA6IDA7XG4gICAgICByZWN0LmZpbGxTaGFkb3cgPSBzaGFkb3c7XG4gICAgICByZWN0LnpJbmRleCA9IGlzRGF0dW1IaWdobGlnaHRlZCA/IFNlcmllcy5oaWdobGlnaHRlZFpJbmRleCA6IGluZGV4O1xuICAgICAgcmVjdC52aXNpYmxlID0gZGF0dW0uaGVpZ2h0ID4gMDtcbiAgICB9KTtcbiAgfVxuICBhc3luYyB1cGRhdGVMYWJlbFNlbGVjdGlvbihvcHRzKSB7XG4gICAgY29uc3QgeyBsYWJlbERhdGEsIGxhYmVsU2VsZWN0aW9uIH0gPSBvcHRzO1xuICAgIHJldHVybiBsYWJlbFNlbGVjdGlvbi51cGRhdGUobGFiZWxEYXRhLCAodGV4dCkgPT4ge1xuICAgICAgdGV4dC5wb2ludGVyRXZlbnRzID0gMSAvKiBOb25lICovO1xuICAgICAgdGV4dC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgdGV4dC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIHVwZGF0ZUxhYmVsTm9kZXMob3B0cykge1xuICAgIGNvbnN0IHsgZm9udFN0eWxlLCBmb250V2VpZ2h0LCBmb250RmFtaWx5LCBmb250U2l6ZSwgY29sb3IgfSA9IHRoaXMucHJvcGVydGllcy5sYWJlbDtcbiAgICBjb25zdCBsYWJlbEVuYWJsZWQgPSB0aGlzLmlzTGFiZWxFbmFibGVkKCk7XG4gICAgb3B0cy5sYWJlbFNlbGVjdGlvbi5lYWNoKCh0ZXh0LCBkYXR1bSkgPT4ge1xuICAgICAgaWYgKGxhYmVsRW5hYmxlZCAmJiBkYXR1bT8ubGFiZWwpIHtcbiAgICAgICAgdGV4dC50ZXh0ID0gZGF0dW0ubGFiZWwudGV4dDtcbiAgICAgICAgdGV4dC54ID0gZGF0dW0ubGFiZWwueDtcbiAgICAgICAgdGV4dC55ID0gZGF0dW0ubGFiZWwueTtcbiAgICAgICAgdGV4dC5mb250U3R5bGUgPSBmb250U3R5bGU7XG4gICAgICAgIHRleHQuZm9udFdlaWdodCA9IGZvbnRXZWlnaHQ7XG4gICAgICAgIHRleHQuZm9udEZhbWlseSA9IGZvbnRGYW1pbHk7XG4gICAgICAgIHRleHQuZm9udFNpemUgPSBmb250U2l6ZTtcbiAgICAgICAgdGV4dC5maWxsID0gY29sb3I7XG4gICAgICAgIHRleHQudmlzaWJsZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZXh0LnZpc2libGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBpbml0UXVhZFRyZWUocXVhZHRyZWUpIHtcbiAgICBjb25zdCB7IHZhbHVlOiBjaGlsZE5vZGUgfSA9IHRoaXMuY29udGVudEdyb3VwLmNoaWxkcmVuKCkubmV4dCgpO1xuICAgIGlmIChjaGlsZE5vZGUpIHtcbiAgICAgIGFkZEhpdFRlc3RlcnNUb1F1YWR0cmVlKHF1YWR0cmVlLCBjaGlsZE5vZGUuY2hpbGRyZW4oKSk7XG4gICAgfVxuICB9XG4gIHBpY2tOb2RlQ2xvc2VzdERhdHVtKHBvaW50KSB7XG4gICAgcmV0dXJuIGZpbmRRdWFkdHJlZU1hdGNoKHRoaXMsIHBvaW50KTtcbiAgfVxuICBnZXRUb29sdGlwSHRtbChub2RlRGF0dW0pIHtcbiAgICBjb25zdCB4QXhpcyA9IHRoaXMuYXhlc1tcInhcIiAvKiBYICovXTtcbiAgICBjb25zdCB5QXhpcyA9IHRoaXMuYXhlc1tcInlcIiAvKiBZICovXTtcbiAgICBpZiAoIXRoaXMucHJvcGVydGllcy5pc1ZhbGlkKCkgfHwgIXhBeGlzIHx8ICF5QXhpcykge1xuICAgICAgcmV0dXJuIEVNUFRZX1RPT0xUSVBfQ09OVEVOVDtcbiAgICB9XG4gICAgY29uc3QgeyB4S2V5LCB5S2V5LCB4TmFtZSwgeU5hbWUsIGZpbGw6IGNvbG9yLCBhZ2dyZWdhdGlvbiwgdG9vbHRpcCB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHtcbiAgICAgIGFnZ3JlZ2F0ZWRWYWx1ZSxcbiAgICAgIGZyZXF1ZW5jeSxcbiAgICAgIGRvbWFpbjogW3JhbmdlTWluLCByYW5nZU1heF0sXG4gICAgICBpdGVtSWRcbiAgICB9ID0gbm9kZURhdHVtO1xuICAgIGNvbnN0IHRpdGxlID0gYCR7c2FuaXRpemVIdG1sKHhOYW1lID8/IHhLZXkpfTogJHt4QXhpcy5mb3JtYXREYXR1bShyYW5nZU1pbil9IC0gJHt4QXhpcy5mb3JtYXREYXR1bShyYW5nZU1heCl9YDtcbiAgICBsZXQgY29udGVudCA9IHlLZXkgPyBgPGI+JHtzYW5pdGl6ZUh0bWwoeU5hbWUgPz8geUtleSl9ICgke2FnZ3JlZ2F0aW9ufSk8L2I+OiAke3lBeGlzLmZvcm1hdERhdHVtKGFnZ3JlZ2F0ZWRWYWx1ZSl9PGJyPmAgOiBcIlwiO1xuICAgIGNvbnRlbnQgKz0gYDxiPkZyZXF1ZW5jeTwvYj46ICR7ZnJlcXVlbmN5fWA7XG4gICAgY29uc3QgZGVmYXVsdHMgPSB7XG4gICAgICB0aXRsZSxcbiAgICAgIGJhY2tncm91bmRDb2xvcjogY29sb3IsXG4gICAgICBjb250ZW50XG4gICAgfTtcbiAgICByZXR1cm4gdG9vbHRpcC50b1Rvb2x0aXBIdG1sKGRlZmF1bHRzLCB7XG4gICAgICBkYXR1bToge1xuICAgICAgICBkYXRhOiBub2RlRGF0dW0uZGF0dW0sXG4gICAgICAgIGFnZ3JlZ2F0ZWRWYWx1ZTogbm9kZURhdHVtLmFnZ3JlZ2F0ZWRWYWx1ZSxcbiAgICAgICAgZG9tYWluOiBub2RlRGF0dW0uZG9tYWluLFxuICAgICAgICBmcmVxdWVuY3k6IG5vZGVEYXR1bS5mcmVxdWVuY3lcbiAgICAgIH0sXG4gICAgICBpdGVtSWQsXG4gICAgICB4S2V5LFxuICAgICAgeE5hbWUsXG4gICAgICB5S2V5LFxuICAgICAgeU5hbWUsXG4gICAgICBjb2xvcixcbiAgICAgIHRpdGxlLFxuICAgICAgc2VyaWVzSWQ6IHRoaXMuaWRcbiAgICB9KTtcbiAgfVxuICBnZXRMZWdlbmREYXRhKGxlZ2VuZFR5cGUpIHtcbiAgICBpZiAoIXRoaXMuZGF0YT8ubGVuZ3RoIHx8IGxlZ2VuZFR5cGUgIT09IFwiY2F0ZWdvcnlcIikge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCB7IHhLZXksIHlOYW1lLCBmaWxsLCBmaWxsT3BhY2l0eSwgc3Ryb2tlLCBzdHJva2VXaWR0aCwgc3Ryb2tlT3BhY2l0eSwgdmlzaWJsZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIGxlZ2VuZFR5cGU6IFwiY2F0ZWdvcnlcIixcbiAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgIGl0ZW1JZDogeEtleSxcbiAgICAgICAgc2VyaWVzSWQ6IHRoaXMuaWQsXG4gICAgICAgIGVuYWJsZWQ6IHZpc2libGUsXG4gICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgdGV4dDogeU5hbWUgPz8geEtleSA/PyBcIkZyZXF1ZW5jeVwiXG4gICAgICAgIH0sXG4gICAgICAgIHN5bWJvbHM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBtYXJrZXI6IHtcbiAgICAgICAgICAgICAgZmlsbDogZmlsbCA/PyBcInJnYmEoMCwgMCwgMCwgMClcIixcbiAgICAgICAgICAgICAgc3Ryb2tlOiBzdHJva2UgPz8gXCJyZ2JhKDAsIDAsIDAsIDApXCIsXG4gICAgICAgICAgICAgIGZpbGxPcGFjaXR5LFxuICAgICAgICAgICAgICBzdHJva2VPcGFjaXR5LFxuICAgICAgICAgICAgICBzdHJva2VXaWR0aFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfVxuICAgIF07XG4gIH1cbiAgYW5pbWF0ZUVtcHR5VXBkYXRlUmVhZHkoeyBkYXR1bVNlbGVjdGlvbiwgbGFiZWxTZWxlY3Rpb24gfSkge1xuICAgIGNvbnN0IGZucyA9IHByZXBhcmVCYXJBbmltYXRpb25GdW5jdGlvbnMoY29sbGFwc2VkU3RhcnRpbmdCYXJQb3NpdGlvbih0cnVlLCB0aGlzLmF4ZXMsIFwibm9ybWFsXCIpKTtcbiAgICBmcm9tVG9Nb3Rpb24odGhpcy5pZCwgXCJkYXR1bXNcIiwgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgW2RhdHVtU2VsZWN0aW9uXSwgZm5zKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImxhYmVsc1wiLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCBsYWJlbFNlbGVjdGlvbik7XG4gIH1cbiAgYW5pbWF0ZVdhaXRpbmdVcGRhdGVSZWFkeShkYXRhKSB7XG4gICAgY29uc3QgZGF0YURpZmYgPSB0aGlzLnByb2Nlc3NlZERhdGE/LnJlZHVjZWQ/LmRpZmY7XG4gICAgY29uc3QgZm5zID0gcHJlcGFyZUJhckFuaW1hdGlvbkZ1bmN0aW9ucyhjb2xsYXBzZWRTdGFydGluZ0JhclBvc2l0aW9uKHRydWUsIHRoaXMuYXhlcywgXCJub3JtYWxcIikpO1xuICAgIGZyb21Ub01vdGlvbihcbiAgICAgIHRoaXMuaWQsXG4gICAgICBcImRhdHVtc1wiLFxuICAgICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlcixcbiAgICAgIFtkYXRhLmRhdHVtU2VsZWN0aW9uXSxcbiAgICAgIGZucyxcbiAgICAgIChfLCBkYXR1bSkgPT4gY3JlYXRlRGF0dW1JZChkYXR1bS5kb21haW4pLFxuICAgICAgZGF0YURpZmZcbiAgICApO1xuICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwibGFiZWxzXCIsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIGRhdGEubGFiZWxTZWxlY3Rpb24pO1xuICB9XG4gIGlzTGFiZWxFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXMubGFiZWwuZW5hYmxlZDtcbiAgfVxuICBjb21wdXRlRm9jdXNCb3VuZHMoeyBkYXR1bUluZGV4LCBzZXJpZXNSZWN0IH0pIHtcbiAgICByZXR1cm4gY29tcHV0ZUJhckZvY3VzQm91bmRzKHRoaXMuY29udGV4dE5vZGVEYXRhPy5ub2RlRGF0YVtkYXR1bUluZGV4XSwgdGhpcy5jb250ZW50R3JvdXAsIHNlcmllc1JlY3QpO1xuICB9XG59O1xuSGlzdG9ncmFtU2VyaWVzLmNsYXNzTmFtZSA9IFwiSGlzdG9ncmFtU2VyaWVzXCI7XG5IaXN0b2dyYW1TZXJpZXMudHlwZSA9IFwiaGlzdG9ncmFtXCI7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vaGlzdG9ncmFtU2VyaWVzTW9kdWxlLnRzXG52YXIgSGlzdG9ncmFtU2VyaWVzTW9kdWxlID0ge1xuICB0eXBlOiBcInNlcmllc1wiLFxuICBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsXG4gIHBhY2thZ2VUeXBlOiBcImNvbW11bml0eVwiLFxuICBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIl0sXG4gIGlkZW50aWZpZXI6IFwiaGlzdG9ncmFtXCIsXG4gIG1vZHVsZUZhY3Rvcnk6IChjdHgpID0+IG5ldyBIaXN0b2dyYW1TZXJpZXMoY3R4KSxcbiAgdG9vbHRpcERlZmF1bHRzOiB7IHJhbmdlOiBcImV4YWN0XCIgfSxcbiAgZGVmYXVsdEF4ZXM6IFtcbiAgICB7XG4gICAgICB0eXBlOiBcIm51bWJlclwiIC8qIE5VTUJFUiAqLyxcbiAgICAgIHBvc2l0aW9uOiBcImJvdHRvbVwiIC8qIEJPVFRPTSAqL1xuICAgIH0sXG4gICAge1xuICAgICAgdHlwZTogXCJudW1iZXJcIiAvKiBOVU1CRVIgKi8sXG4gICAgICBwb3NpdGlvbjogXCJsZWZ0XCIgLyogTEVGVCAqL1xuICAgIH1cbiAgXSxcbiAgdGhlbWVUZW1wbGF0ZToge1xuICAgIHNlcmllczoge1xuICAgICAgc3Ryb2tlV2lkdGg6IDEsXG4gICAgICBmaWxsT3BhY2l0eTogMSxcbiAgICAgIHN0cm9rZU9wYWNpdHk6IDEsXG4gICAgICBsaW5lRGFzaDogWzBdLFxuICAgICAgbGluZURhc2hPZmZzZXQ6IDAsXG4gICAgICBsYWJlbDoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgZm9udFNpemU6IDEyLFxuICAgICAgICBmb250RmFtaWx5OiBERUZBVUxUX0ZPTlRfRkFNSUxZLFxuICAgICAgICBjb2xvcjogREVGQVVMVF9JTlNJREVfU0VSSUVTX0xBQkVMX0NPTE9VUlxuICAgICAgfSxcbiAgICAgIHNoYWRvdzoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgY29sb3I6IERFRkFVTFRfU0hBRE9XX0NPTE9VUixcbiAgICAgICAgeE9mZnNldDogMyxcbiAgICAgICAgeU9mZnNldDogMyxcbiAgICAgICAgYmx1cjogNVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcGFsZXR0ZUZhY3Rvcnk6ICh7IHRha2VDb2xvcnMgfSkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGZpbGxzOiBbZmlsbF0sXG4gICAgICBzdHJva2VzOiBbc3Ryb2tlXVxuICAgIH0gPSB0YWtlQ29sb3JzKDEpO1xuICAgIHJldHVybiB7IGZpbGwsIHN0cm9rZSB9O1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2xpbmVTZXJpZXNQcm9wZXJ0aWVzLnRzXG52YXIgTGluZVNlcmllc1Byb3BlcnRpZXMgPSBjbGFzcyBleHRlbmRzIENhcnRlc2lhblNlcmllc1Byb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuc3Ryb2tlID0gXCIjODc0MzQ5XCI7XG4gICAgdGhpcy5zdHJva2VXaWR0aCA9IDI7XG4gICAgdGhpcy5zdHJva2VPcGFjaXR5ID0gMTtcbiAgICB0aGlzLmxpbmVEYXNoID0gWzBdO1xuICAgIHRoaXMubGluZURhc2hPZmZzZXQgPSAwO1xuICAgIHRoaXMuaW50ZXJwb2xhdGlvbiA9IG5ldyBJbnRlcnBvbGF0aW9uUHJvcGVydGllcygpO1xuICAgIHRoaXMubWFya2VyID0gbmV3IFNlcmllc01hcmtlcigpO1xuICAgIHRoaXMubGFiZWwgPSBuZXcgTGFiZWwoKTtcbiAgICB0aGlzLnRvb2x0aXAgPSBuZXcgU2VyaWVzVG9vbHRpcCgpO1xuICAgIHRoaXMuY29ubmVjdE1pc3NpbmdEYXRhID0gZmFsc2U7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcpXG5dLCBMaW5lU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwieEtleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORylcbl0sIExpbmVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ5S2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBMaW5lU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwieE5hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIExpbmVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ5TmFtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGluZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInlGaWx0ZXJLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIExpbmVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdGFja0dyb3VwXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBMaW5lU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibm9ybWFsaXplZFRvXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBMaW5lU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwidGl0bGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcpXG5dLCBMaW5lU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic3Ryb2tlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgTGluZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0cm9rZVdpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8pXG5dLCBMaW5lU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic3Ryb2tlT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKExJTkVfREFTSClcbl0sIExpbmVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJsaW5lRGFzaFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIExpbmVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJsaW5lRGFzaE9mZnNldFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIExpbmVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJpbnRlcnBvbGF0aW9uXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgTGluZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcIm1hcmtlclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIExpbmVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJsYWJlbFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIExpbmVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ0b29sdGlwXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIExpbmVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjb25uZWN0TWlzc2luZ0RhdGFcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vbGluZVNlcmllcy50c1xudmFyIENST1NTX0ZJTFRFUl9MSU5FX1NUUk9LRV9PUEFDSVRZX0ZBQ1RPUiA9IDAuMjU7XG52YXIgTGluZVNlcmllcyA9IGNsYXNzIGV4dGVuZHMgQ2FydGVzaWFuU2VyaWVzIHtcbiAgY29uc3RydWN0b3IobW9kdWxlQ3R4KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbW9kdWxlQ3R4LFxuICAgICAgZGlyZWN0aW9uS2V5czogREVGQVVMVF9DQVJURVNJQU5fRElSRUNUSU9OX0tFWVMsXG4gICAgICBkaXJlY3Rpb25OYW1lczogREVGQVVMVF9DQVJURVNJQU5fRElSRUNUSU9OX05BTUVTLFxuICAgICAgaGFzTWFya2VyczogdHJ1ZSxcbiAgICAgIHBpY2tNb2RlczogW1xuICAgICAgICAyIC8qIEFYSVNfQUxJR05FRCAqLyxcbiAgICAgICAgMSAvKiBORUFSRVNUX05PREUgKi8sXG4gICAgICAgIDAgLyogRVhBQ1RfU0hBUEVfTUFUQ0ggKi9cbiAgICAgIF0sXG4gICAgICBtYXJrZXJTZWxlY3Rpb25HYXJiYWdlQ29sbGVjdGlvbjogZmFsc2UsXG4gICAgICBhbmltYXRpb25SZXNldEZuczoge1xuICAgICAgICBwYXRoOiBidWlsZFJlc2V0UGF0aEZuKHsgZ2V0VmlzaWJsZTogKCkgPT4gdGhpcy52aXNpYmxlLCBnZXRPcGFjaXR5OiAoKSA9PiB0aGlzLmdldE9wYWNpdHkoKSB9KSxcbiAgICAgICAgbGFiZWw6IHJlc2V0TGFiZWxGbixcbiAgICAgICAgbWFya2VyOiAobm9kZSwgZGF0dW0pID0+ICh7IC4uLnJlc2V0TWFya2VyRm4obm9kZSksIC4uLnJlc2V0TWFya2VyUG9zaXRpb25Gbihub2RlLCBkYXR1bSkgfSlcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnByb3BlcnRpZXMgPSBuZXcgTGluZVNlcmllc1Byb3BlcnRpZXMoKTtcbiAgfVxuICBnZXQgcGlja01vZGVBeGlzKCkge1xuICAgIHJldHVybiBcIm1haW4tY2F0ZWdvcnlcIjtcbiAgfVxuICBhc3luYyBwcm9jZXNzRGF0YShkYXRhQ29udHJvbGxlcikge1xuICAgIGlmICh0aGlzLmRhdGEgPT0gbnVsbCB8fCAhdGhpcy5wcm9wZXJ0aWVzLmlzVmFsaWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGRhdGEsIHZpc2libGUsIHNlcmllc0dyb3VwaW5nOiB7IGdyb3VwSW5kZXggPSB0aGlzLmlkLCBzdGFja0NvdW50ID0gMSB9ID0ge30gfSA9IHRoaXM7XG4gICAgY29uc3QgeyB4S2V5LCB5S2V5LCB5RmlsdGVyS2V5LCBjb25uZWN0TWlzc2luZ0RhdGEsIG5vcm1hbGl6ZWRUbyB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGFuaW1hdGlvbkVuYWJsZWQgPSAhdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5pc1NraXBwZWQoKTtcbiAgICBjb25zdCB4U2NhbGUgPSB0aGlzLmF4ZXNbXCJ4XCIgLyogWCAqL10/LnNjYWxlO1xuICAgIGNvbnN0IHlTY2FsZSA9IHRoaXMuYXhlc1tcInlcIiAvKiBZICovXT8uc2NhbGU7XG4gICAgY29uc3QgeyBpc0NvbnRpbnVvdXNYLCB4U2NhbGVUeXBlLCB5U2NhbGVUeXBlIH0gPSB0aGlzLmdldFNjYWxlSW5mb3JtYXRpb24oeyB4U2NhbGUsIHlTY2FsZSB9KTtcbiAgICBjb25zdCBjb21tb24gPSB7IGludmFsaWRWYWx1ZTogbnVsbCB9O1xuICAgIGlmIChjb25uZWN0TWlzc2luZ0RhdGEgJiYgc3RhY2tDb3VudCA+IDEpIHtcbiAgICAgIGNvbW1vbi5pbnZhbGlkVmFsdWUgPSAwO1xuICAgIH1cbiAgICBpZiAoIXZpc2libGUpIHtcbiAgICAgIGNvbW1vbi5mb3JjZVZhbHVlID0gMDtcbiAgICB9XG4gICAgY29uc3QgcHJvcHMgPSBbXTtcbiAgICBpZiAoIWlzQ29udGludW91c1gpIHtcbiAgICAgIHByb3BzLnB1c2goa2V5UHJvcGVydHkoeEtleSwgeFNjYWxlVHlwZSwgeyBpZDogXCJ4S2V5XCIgfSkpO1xuICAgIH1cbiAgICBwcm9wcy5wdXNoKFxuICAgICAgdmFsdWVQcm9wZXJ0eSh4S2V5LCB4U2NhbGVUeXBlLCB7IGlkOiBcInhWYWx1ZVwiIH0pLFxuICAgICAgdmFsdWVQcm9wZXJ0eSh5S2V5LCB5U2NhbGVUeXBlLCB7XG4gICAgICAgIGlkOiBgeVZhbHVlUmF3YCxcbiAgICAgICAgLi4uY29tbW9uLFxuICAgICAgICBpbnZhbGlkVmFsdWU6IHZvaWQgMFxuICAgICAgfSlcbiAgICApO1xuICAgIGlmICh5RmlsdGVyS2V5ICE9IG51bGwpIHtcbiAgICAgIHByb3BzLnB1c2godmFsdWVQcm9wZXJ0eSh5RmlsdGVyS2V5LCB5U2NhbGVUeXBlLCB7IGlkOiBcInlGaWx0ZXJSYXdcIiB9KSk7XG4gICAgfVxuICAgIGlmIChzdGFja0NvdW50ID4gMSkge1xuICAgICAgY29uc3QgaWRzID0gW1xuICAgICAgICBgbGluZS1zdGFjay0ke2dyb3VwSW5kZXh9LXlWYWx1ZXNgLFxuICAgICAgICBgbGluZS1zdGFjay0ke2dyb3VwSW5kZXh9LXlWYWx1ZXMtdHJhaWxpbmdgLFxuICAgICAgICBgbGluZS1zdGFjay0ke2dyb3VwSW5kZXh9LXlWYWx1ZXMtbWFya2VyYFxuICAgICAgXTtcbiAgICAgIHByb3BzLnB1c2goXG4gICAgICAgIC4uLmdyb3VwQWNjdW11bGF0aXZlVmFsdWVQcm9wZXJ0eShcbiAgICAgICAgICB5S2V5LFxuICAgICAgICAgIFwid2luZG93XCIsXG4gICAgICAgICAgXCJjdXJyZW50XCIsXG4gICAgICAgICAgeyBpZDogYHlWYWx1ZUVuZGAsIC4uLmNvbW1vbiwgZ3JvdXBJZDogaWRzWzBdIH0sXG4gICAgICAgICAgeVNjYWxlVHlwZVxuICAgICAgICApLFxuICAgICAgICAuLi5ncm91cEFjY3VtdWxhdGl2ZVZhbHVlUHJvcGVydHkoXG4gICAgICAgICAgeUtleSxcbiAgICAgICAgICBcIndpbmRvdy10cmFpbGluZ1wiLFxuICAgICAgICAgIFwiY3VycmVudFwiLFxuICAgICAgICAgIHsgaWQ6IGB5VmFsdWVTdGFydGAsIC4uLmNvbW1vbiwgZ3JvdXBJZDogaWRzWzFdIH0sXG4gICAgICAgICAgeVNjYWxlVHlwZVxuICAgICAgICApLFxuICAgICAgICAuLi5ncm91cEFjY3VtdWxhdGl2ZVZhbHVlUHJvcGVydHkoXG4gICAgICAgICAgeUtleSxcbiAgICAgICAgICBcIm5vcm1hbFwiLFxuICAgICAgICAgIFwiY3VycmVudFwiLFxuICAgICAgICAgIHsgaWQ6IGB5VmFsdWVDdW11bGF0aXZlYCwgLi4uY29tbW9uLCBncm91cElkOiBpZHNbMl0gfSxcbiAgICAgICAgICB5U2NhbGVUeXBlXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICBpZiAoaXNEZWZpbmVkKG5vcm1hbGl6ZWRUbykpIHtcbiAgICAgICAgcHJvcHMucHVzaChub3JtYWxpc2VHcm91cFRvKFtpZHNbMF0sIGlkc1sxXSwgaWRzWzJdXSwgbm9ybWFsaXplZFRvLCBcInJhbmdlXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFuaW1hdGlvbkVuYWJsZWQpIHtcbiAgICAgIHByb3BzLnB1c2goYW5pbWF0aW9uVmFsaWRhdGlvbihpc0NvbnRpbnVvdXNYID8gW1wieFZhbHVlXCJdIDogdm9pZCAwKSk7XG4gICAgICBpZiAodGhpcy5wcm9jZXNzZWREYXRhKSB7XG4gICAgICAgIHByb3BzLnB1c2goZGlmZih0aGlzLnByb2Nlc3NlZERhdGEpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXdhaXQgdGhpcy5yZXF1ZXN0RGF0YU1vZGVsKGRhdGFDb250cm9sbGVyLCBkYXRhLCB7IHByb3BzIH0pO1xuICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcInVwZGF0ZURhdGFcIik7XG4gIH1cbiAgZ2V0U2VyaWVzRG9tYWluKGRpcmVjdGlvbikge1xuICAgIGNvbnN0IHsgZGF0YU1vZGVsLCBwcm9jZXNzZWREYXRhIH0gPSB0aGlzO1xuICAgIGlmICghZGF0YU1vZGVsIHx8ICFwcm9jZXNzZWREYXRhPy5kYXRhLmxlbmd0aClcbiAgICAgIHJldHVybiBbXTtcbiAgICBjb25zdCB4RGVmID0gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhRGVmQnlJZCh0aGlzLCBgeFZhbHVlYCk7XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJ4XCIgLyogWCAqLykge1xuICAgICAgY29uc3QgZG9tYWluID0gZGF0YU1vZGVsLmdldERvbWFpbih0aGlzLCBgeFZhbHVlYCwgXCJ2YWx1ZVwiLCBwcm9jZXNzZWREYXRhKTtcbiAgICAgIGlmICh4RGVmPy5kZWYudHlwZSA9PT0gXCJ2YWx1ZVwiICYmIHhEZWYuZGVmLnZhbHVlVHlwZSA9PT0gXCJjYXRlZ29yeVwiKSB7XG4gICAgICAgIHJldHVybiBkb21haW47XG4gICAgICB9XG4gICAgICByZXR1cm4gZml4TnVtZXJpY0V4dGVudChleHRlbnQoZG9tYWluKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHN0YWNrQ291bnQgPSB0aGlzLnNlcmllc0dyb3VwaW5nPy5zdGFja0NvdW50ID8/IDE7XG4gICAgICBjb25zdCBkb21haW4gPSBzdGFja0NvdW50ID4gMSA/IGRhdGFNb2RlbC5nZXREb21haW4odGhpcywgYHlWYWx1ZUVuZGAsIFwidmFsdWVcIiwgcHJvY2Vzc2VkRGF0YSkgOiBkYXRhTW9kZWwuZ2V0RG9tYWluKHRoaXMsIGB5VmFsdWVSYXdgLCBcInZhbHVlXCIsIHByb2Nlc3NlZERhdGEpO1xuICAgICAgcmV0dXJuIGZpeE51bWVyaWNFeHRlbnQoZG9tYWluKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgY3JlYXRlTm9kZURhdGEoKSB7XG4gICAgY29uc3QgeyBwcm9jZXNzZWREYXRhLCBkYXRhTW9kZWwsIGF4ZXMgfSA9IHRoaXM7XG4gICAgY29uc3QgeEF4aXMgPSBheGVzW1wieFwiIC8qIFggKi9dO1xuICAgIGNvbnN0IHlBeGlzID0gYXhlc1tcInlcIiAvKiBZICovXTtcbiAgICBpZiAoIXByb2Nlc3NlZERhdGEgfHwgIWRhdGFNb2RlbCB8fCAheEF4aXMgfHwgIXlBeGlzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgeEtleSwgeUtleSwgeUZpbHRlcktleSwgeE5hbWUsIHlOYW1lLCBtYXJrZXIsIGxhYmVsLCBjb25uZWN0TWlzc2luZ0RhdGEsIGxlZ2VuZEl0ZW1OYW1lIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3Qgc3RhY2tlZCA9ICh0aGlzLnNlcmllc0dyb3VwaW5nPy5zdGFja0NvdW50ID8/IDEpID4gMTtcbiAgICBjb25zdCB4U2NhbGUgPSB4QXhpcy5zY2FsZTtcbiAgICBjb25zdCB5U2NhbGUgPSB5QXhpcy5zY2FsZTtcbiAgICBjb25zdCB4T2Zmc2V0ID0gKHhTY2FsZS5iYW5kd2lkdGggPz8gMCkgLyAyO1xuICAgIGNvbnN0IHlPZmZzZXQgPSAoeVNjYWxlLmJhbmR3aWR0aCA/PyAwKSAvIDI7XG4gICAgY29uc3Qgbm9kZURhdGEgPSBbXTtcbiAgICBjb25zdCBzaXplID0gbWFya2VyLmVuYWJsZWQgPyBtYXJrZXIuc2l6ZSA6IDA7XG4gICAgY29uc3QgeElkeCA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgeFZhbHVlYCk7XG4gICAgY29uc3QgeUlkeCA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgeVZhbHVlUmF3YCk7XG4gICAgY29uc3QgeVNlbGVjdGlvbklkeCA9IHlGaWx0ZXJLZXkgIT0gbnVsbCA/IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgeUZpbHRlclJhd2ApIDogdm9pZCAwO1xuICAgIGNvbnN0IHlDdW11bGF0aXZlSWR4ID0gc3RhY2tlZCA/IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgeVZhbHVlQ3VtdWxhdGl2ZWApIDogeUlkeDtcbiAgICBjb25zdCB5RW5kSWR4ID0gc3RhY2tlZCA/IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgeVZhbHVlRW5kYCkgOiB2b2lkIDA7XG4gICAgbGV0IG1vdmVUbyA9IHRydWU7XG4gICAgbGV0IGNyb3NzRmlsdGVyaW5nID0gZmFsc2U7XG4gICAgcHJvY2Vzc2VkRGF0YS5kYXRhPy5mb3JFYWNoKCh7IGRhdHVtLCB2YWx1ZXMgfSkgPT4ge1xuICAgICAgY29uc3QgeERhdHVtID0gdmFsdWVzW3hJZHhdO1xuICAgICAgY29uc3QgeURhdHVtID0gdmFsdWVzW3lJZHhdO1xuICAgICAgY29uc3QgeUN1bXVsYXRpdmVEYXR1bSA9IHZhbHVlc1t5Q3VtdWxhdGl2ZUlkeF07XG4gICAgICBjb25zdCB5RW5kRGF0dW0gPSB5RW5kSWR4ICE9IG51bGwgPyB2YWx1ZXNbeUVuZElkeF0gOiB2b2lkIDA7XG4gICAgICBpZiAoeURhdHVtID09IG51bGwpIHtcbiAgICAgICAgbW92ZVRvIHx8IChtb3ZlVG8gPSAhY29ubmVjdE1pc3NpbmdEYXRhKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgeCA9IHhTY2FsZS5jb252ZXJ0KHhEYXR1bSkgKyB4T2Zmc2V0O1xuICAgICAgaWYgKGlzTmFOKHgpKSB7XG4gICAgICAgIG1vdmVUbyB8fCAobW92ZVRvID0gIWNvbm5lY3RNaXNzaW5nRGF0YSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHkgPSB5U2NhbGUuY29udmVydCh5Q3VtdWxhdGl2ZURhdHVtKSArIHlPZmZzZXQ7XG4gICAgICBjb25zdCBzZWxlY3RlZCA9IHlTZWxlY3Rpb25JZHggIT0gbnVsbCA/IHZhbHVlc1t5U2VsZWN0aW9uSWR4XSA9PT0geURhdHVtIDogdm9pZCAwO1xuICAgICAgaWYgKHNlbGVjdGVkID09PSBmYWxzZSkge1xuICAgICAgICBjcm9zc0ZpbHRlcmluZyA9IHRydWU7XG4gICAgICB9XG4gICAgICBjb25zdCBsYWJlbFRleHQgPSB0aGlzLmdldExhYmVsVGV4dChcbiAgICAgICAgbGFiZWwsXG4gICAgICAgIHsgdmFsdWU6IHlEYXR1bSwgZGF0dW0sIHhLZXksIHlLZXksIHhOYW1lLCB5TmFtZSwgbGVnZW5kSXRlbU5hbWUgfSxcbiAgICAgICAgZm9ybWF0VmFsdWVcbiAgICAgICk7XG4gICAgICBub2RlRGF0YS5wdXNoKHtcbiAgICAgICAgc2VyaWVzOiB0aGlzLFxuICAgICAgICBkYXR1bSxcbiAgICAgICAgeUtleSxcbiAgICAgICAgeEtleSxcbiAgICAgICAgcG9pbnQ6IHsgeCwgeSwgbW92ZVRvLCBzaXplIH0sXG4gICAgICAgIG1pZFBvaW50OiB7IHgsIHkgfSxcbiAgICAgICAgY3VtdWxhdGl2ZVZhbHVlOiB5RW5kRGF0dW0sXG4gICAgICAgIHlWYWx1ZTogeURhdHVtLFxuICAgICAgICB4VmFsdWU6IHhEYXR1bSxcbiAgICAgICAgY2FwRGVmYXVsdHM6IHtcbiAgICAgICAgICBsZW5ndGhSYXRpb011bHRpcGxpZXI6IHRoaXMucHJvcGVydGllcy5tYXJrZXIuZ2V0RGlhbWV0ZXIoKSxcbiAgICAgICAgICBsZW5ndGhNYXg6IEluZmluaXR5XG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsVGV4dCxcbiAgICAgICAgc2VsZWN0ZWRcbiAgICAgIH0pO1xuICAgICAgbW92ZVRvID0gZmFsc2U7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGl0ZW1JZDogeUtleSxcbiAgICAgIG5vZGVEYXRhLFxuICAgICAgbGFiZWxEYXRhOiBub2RlRGF0YSxcbiAgICAgIHNjYWxlczogdGhpcy5jYWxjdWxhdGVTY2FsaW5nKCksXG4gICAgICB2aXNpYmxlOiB0aGlzLnZpc2libGUsXG4gICAgICBjcm9zc0ZpbHRlcmluZ1xuICAgIH07XG4gIH1cbiAgaXNQYXRoT3JTZWxlY3Rpb25EaXJ0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLm1hcmtlci5pc0RpcnR5KCk7XG4gIH1cbiAgbWFya2VyRmFjdG9yeSgpIHtcbiAgICBjb25zdCB7IHNoYXBlIH0gPSB0aGlzLnByb3BlcnRpZXMubWFya2VyO1xuICAgIGNvbnN0IE1hcmtlclNoYXBlID0gZ2V0TWFya2VyKHNoYXBlKTtcbiAgICByZXR1cm4gbmV3IE1hcmtlclNoYXBlKCk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlUGF0aE5vZGVzKG9wdHMpIHtcbiAgICBjb25zdCB7XG4gICAgICBwYXRoczogW2xpbmVOb2RlXSxcbiAgICAgIG9wYWNpdHksXG4gICAgICB2aXNpYmxlLFxuICAgICAgYW5pbWF0aW9uRW5hYmxlZFxuICAgIH0gPSBvcHRzO1xuICAgIGNvbnN0IGNyb3NzRmlsdGVyaW5nID0gdGhpcy5jb250ZXh0Tm9kZURhdGE/LmNyb3NzRmlsdGVyaW5nID09PSB0cnVlO1xuICAgIGxpbmVOb2RlLnNldFByb3BlcnRpZXMoe1xuICAgICAgZmlsbDogdm9pZCAwLFxuICAgICAgbGluZUpvaW46IFwicm91bmRcIixcbiAgICAgIHBvaW50ZXJFdmVudHM6IDEgLyogTm9uZSAqLyxcbiAgICAgIG9wYWNpdHksXG4gICAgICBzdHJva2U6IHRoaXMucHJvcGVydGllcy5zdHJva2UsXG4gICAgICBzdHJva2VXaWR0aDogdGhpcy5nZXRTdHJva2VXaWR0aCh0aGlzLnByb3BlcnRpZXMuc3Ryb2tlV2lkdGgpLFxuICAgICAgc3Ryb2tlT3BhY2l0eTogdGhpcy5wcm9wZXJ0aWVzLnN0cm9rZU9wYWNpdHkgKiAoY3Jvc3NGaWx0ZXJpbmcgPyBDUk9TU19GSUxURVJfTElORV9TVFJPS0VfT1BBQ0lUWV9GQUNUT1IgOiAxKSxcbiAgICAgIGxpbmVEYXNoOiB0aGlzLnByb3BlcnRpZXMubGluZURhc2gsXG4gICAgICBsaW5lRGFzaE9mZnNldDogdGhpcy5wcm9wZXJ0aWVzLmxpbmVEYXNoT2Zmc2V0XG4gICAgfSk7XG4gICAgaWYgKCFhbmltYXRpb25FbmFibGVkKSB7XG4gICAgICBsaW5lTm9kZS52aXNpYmxlID0gdmlzaWJsZTtcbiAgICB9XG4gICAgdXBkYXRlQ2xpcFBhdGgodGhpcywgbGluZU5vZGUpO1xuICB9XG4gIGFzeW5jIHVwZGF0ZU1hcmtlclNlbGVjdGlvbihvcHRzKSB7XG4gICAgbGV0IHsgbm9kZURhdGEgfSA9IG9wdHM7XG4gICAgY29uc3QgeyBtYXJrZXJTZWxlY3Rpb24gfSA9IG9wdHM7XG4gICAgY29uc3QgbWFya2Vyc0VuYWJsZWQgPSB0aGlzLnByb3BlcnRpZXMubWFya2VyLmVuYWJsZWQgfHwgdGhpcy5jb250ZXh0Tm9kZURhdGE/LmNyb3NzRmlsdGVyaW5nID09PSB0cnVlO1xuICAgIG5vZGVEYXRhID0gbWFya2Vyc0VuYWJsZWQgPyBub2RlRGF0YSA6IFtdO1xuICAgIGlmICh0aGlzLnByb3BlcnRpZXMubWFya2VyLmlzRGlydHkoKSkge1xuICAgICAgbWFya2VyU2VsZWN0aW9uLmNsZWFyKCk7XG4gICAgICBtYXJrZXJTZWxlY3Rpb24uY2xlYW51cCgpO1xuICAgIH1cbiAgICByZXR1cm4gbWFya2VyU2VsZWN0aW9uLnVwZGF0ZShub2RlRGF0YSwgdm9pZCAwLCAoZGF0dW0pID0+IGNyZWF0ZURhdHVtSWQoZGF0dW0ueFZhbHVlKSk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlTWFya2VyTm9kZXMob3B0cykge1xuICAgIGNvbnN0IHsgbWFya2VyU2VsZWN0aW9uLCBpc0hpZ2hsaWdodDogaGlnaGxpZ2h0ZWQgfSA9IG9wdHM7XG4gICAgY29uc3QgeyB4S2V5LCB5S2V5LCBzdHJva2UsIHN0cm9rZVdpZHRoLCBzdHJva2VPcGFjaXR5LCBtYXJrZXIsIGhpZ2hsaWdodFN0eWxlIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgYmFzZVN0eWxlID0gbWVyZ2VEZWZhdWx0cyhoaWdobGlnaHRlZCAmJiBoaWdobGlnaHRTdHlsZS5pdGVtLCBtYXJrZXIuZ2V0U3R5bGUoKSwge1xuICAgICAgc3Ryb2tlLFxuICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICBzdHJva2VPcGFjaXR5XG4gICAgfSk7XG4gICAgY29uc3QgYXBwbHlUcmFuc2xhdGlvbiA9IHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuaXNTa2lwcGVkKCk7XG4gICAgbWFya2VyU2VsZWN0aW9uLmVhY2goKG5vZGUsIGRhdHVtKSA9PiB7XG4gICAgICB0aGlzLnVwZGF0ZU1hcmtlclN0eWxlKG5vZGUsIG1hcmtlciwgeyBkYXR1bSwgaGlnaGxpZ2h0ZWQsIHhLZXksIHlLZXkgfSwgYmFzZVN0eWxlLCB7XG4gICAgICAgIGFwcGx5VHJhbnNsYXRpb24sXG4gICAgICAgIHNlbGVjdGVkOiBkYXR1bS5zZWxlY3RlZFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKCFoaWdobGlnaHRlZCkge1xuICAgICAgbWFya2VyLm1hcmtDbGVhbigpO1xuICAgIH1cbiAgfVxuICBhc3luYyB1cGRhdGVMYWJlbFNlbGVjdGlvbihvcHRzKSB7XG4gICAgcmV0dXJuIG9wdHMubGFiZWxTZWxlY3Rpb24udXBkYXRlKHRoaXMuaXNMYWJlbEVuYWJsZWQoKSA/IG9wdHMubGFiZWxEYXRhIDogW10pO1xuICB9XG4gIGFzeW5jIHVwZGF0ZUxhYmVsTm9kZXMob3B0cykge1xuICAgIGNvbnN0IHsgZW5hYmxlZCwgZm9udFN0eWxlLCBmb250V2VpZ2h0LCBmb250U2l6ZSwgZm9udEZhbWlseSwgY29sb3IgfSA9IHRoaXMucHJvcGVydGllcy5sYWJlbDtcbiAgICBvcHRzLmxhYmVsU2VsZWN0aW9uLmVhY2goKHRleHQsIGRhdHVtKSA9PiB7XG4gICAgICBpZiAoZW5hYmxlZCAmJiBkYXR1bT8ubGFiZWxUZXh0KSB7XG4gICAgICAgIHRleHQuZm9udFN0eWxlID0gZm9udFN0eWxlO1xuICAgICAgICB0ZXh0LmZvbnRXZWlnaHQgPSBmb250V2VpZ2h0O1xuICAgICAgICB0ZXh0LmZvbnRTaXplID0gZm9udFNpemU7XG4gICAgICAgIHRleHQuZm9udEZhbWlseSA9IGZvbnRGYW1pbHk7XG4gICAgICAgIHRleHQudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICAgICAgdGV4dC50ZXh0QmFzZWxpbmUgPSBcImJvdHRvbVwiO1xuICAgICAgICB0ZXh0LnRleHQgPSBkYXR1bS5sYWJlbFRleHQ7XG4gICAgICAgIHRleHQueCA9IGRhdHVtLnBvaW50Lng7XG4gICAgICAgIHRleHQueSA9IGRhdHVtLnBvaW50LnkgLSAxMDtcbiAgICAgICAgdGV4dC5maWxsID0gY29sb3I7XG4gICAgICAgIHRleHQudmlzaWJsZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZXh0LnZpc2libGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXRUb29sdGlwSHRtbChub2RlRGF0dW0pIHtcbiAgICBjb25zdCB4QXhpcyA9IHRoaXMuYXhlc1tcInhcIiAvKiBYICovXTtcbiAgICBjb25zdCB5QXhpcyA9IHRoaXMuYXhlc1tcInlcIiAvKiBZICovXTtcbiAgICBpZiAoIXRoaXMucHJvcGVydGllcy5pc1ZhbGlkKCkgfHwgIXhBeGlzIHx8ICF5QXhpcykge1xuICAgICAgcmV0dXJuIEVNUFRZX1RPT0xUSVBfQ09OVEVOVDtcbiAgICB9XG4gICAgY29uc3QgeyB4S2V5LCB5S2V5LCB4TmFtZSwgeU5hbWUsIHN0cm9rZVdpZHRoLCBtYXJrZXIsIHRvb2x0aXAgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCB7IGRhdHVtLCB4VmFsdWUsIHlWYWx1ZSwgaXRlbUlkIH0gPSBub2RlRGF0dW07XG4gICAgY29uc3QgeFN0cmluZyA9IHhBeGlzLmZvcm1hdERhdHVtKHhWYWx1ZSk7XG4gICAgY29uc3QgeVN0cmluZyA9IHlBeGlzLmZvcm1hdERhdHVtKHlWYWx1ZSk7XG4gICAgY29uc3QgdGl0bGUgPSBzYW5pdGl6ZUh0bWwodGhpcy5wcm9wZXJ0aWVzLnRpdGxlID8/IHlOYW1lKTtcbiAgICBjb25zdCBjb250ZW50ID0gc2FuaXRpemVIdG1sKHhTdHJpbmcgKyBcIjogXCIgKyB5U3RyaW5nKTtcbiAgICBjb25zdCBiYXNlU3R5bGUgPSBtZXJnZURlZmF1bHRzKHsgZmlsbDogbWFya2VyLnN0cm9rZSB9LCBtYXJrZXIuZ2V0U3R5bGUoKSwgeyBzdHJva2VXaWR0aCB9KTtcbiAgICBjb25zdCB7IGZpbGw6IGNvbG9yIH0gPSB0aGlzLmdldE1hcmtlclN0eWxlKFxuICAgICAgbWFya2VyLFxuICAgICAgeyBkYXR1bTogbm9kZURhdHVtLCB4S2V5LCB5S2V5LCBoaWdobGlnaHRlZDogZmFsc2UgfSxcbiAgICAgIGJhc2VTdHlsZVxuICAgICk7XG4gICAgcmV0dXJuIHRvb2x0aXAudG9Ub29sdGlwSHRtbChcbiAgICAgIHsgdGl0bGUsIGNvbnRlbnQsIGJhY2tncm91bmRDb2xvcjogY29sb3IgfSxcbiAgICAgIHtcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIGl0ZW1JZCxcbiAgICAgICAgeEtleSxcbiAgICAgICAgeE5hbWUsXG4gICAgICAgIHlLZXksXG4gICAgICAgIHlOYW1lLFxuICAgICAgICB0aXRsZSxcbiAgICAgICAgY29sb3IsXG4gICAgICAgIHNlcmllc0lkOiB0aGlzLmlkLFxuICAgICAgICAuLi50aGlzLmdldE1vZHVsZVRvb2x0aXBQYXJhbXMoKVxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgZ2V0TGVnZW5kRGF0YShsZWdlbmRUeXBlKSB7XG4gICAgaWYgKCEodGhpcy5kYXRhPy5sZW5ndGggJiYgdGhpcy5wcm9wZXJ0aWVzLmlzVmFsaWQoKSAmJiBsZWdlbmRUeXBlID09PSBcImNhdGVnb3J5XCIpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IHsgeUtleSwgeU5hbWUsIHN0cm9rZSwgc3Ryb2tlT3BhY2l0eSwgc3Ryb2tlV2lkdGgsIGxpbmVEYXNoLCB0aXRsZSwgbWFya2VyLCB2aXNpYmxlLCBsZWdlbmRJdGVtTmFtZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGNvbG9yMCA9IFwicmdiYSgwLCAwLCAwLCAwKVwiO1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIGxlZ2VuZFR5cGU6IFwiY2F0ZWdvcnlcIixcbiAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgIGl0ZW1JZDogeUtleSxcbiAgICAgICAgbGVnZW5kSXRlbU5hbWUsXG4gICAgICAgIHNlcmllc0lkOiB0aGlzLmlkLFxuICAgICAgICBlbmFibGVkOiB2aXNpYmxlLFxuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgIHRleHQ6IGxlZ2VuZEl0ZW1OYW1lID8/IHRpdGxlID8/IHlOYW1lID8/IHlLZXlcbiAgICAgICAgfSxcbiAgICAgICAgc3ltYm9sczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1hcmtlcjoge1xuICAgICAgICAgICAgICBzaGFwZTogbWFya2VyLnNoYXBlLFxuICAgICAgICAgICAgICBmaWxsOiBtYXJrZXIuZmlsbCA/PyBjb2xvcjAsXG4gICAgICAgICAgICAgIHN0cm9rZTogbWFya2VyLnN0cm9rZSA/PyBzdHJva2UgPz8gY29sb3IwLFxuICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogbWFya2VyLmZpbGxPcGFjaXR5ID8/IDEsXG4gICAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IG1hcmtlci5zdHJva2VPcGFjaXR5ID8/IHN0cm9rZU9wYWNpdHkgPz8gMSxcbiAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IG1hcmtlci5zdHJva2VXaWR0aCA/PyAwLFxuICAgICAgICAgICAgICBlbmFibGVkOiBtYXJrZXIuZW5hYmxlZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpbmU6IHtcbiAgICAgICAgICAgICAgc3Ryb2tlOiBzdHJva2UgPz8gY29sb3IwLFxuICAgICAgICAgICAgICBzdHJva2VPcGFjaXR5LFxuICAgICAgICAgICAgICBzdHJva2VXaWR0aCxcbiAgICAgICAgICAgICAgbGluZURhc2hcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH1cbiAgICBdO1xuICB9XG4gIGFzeW5jIHVwZGF0ZVBhdGhzKG9wdHMpIHtcbiAgICB0aGlzLnVwZGF0ZUxpbmVQYXRocyhvcHRzLnBhdGhzLCBvcHRzLmNvbnRleHREYXRhKTtcbiAgfVxuICB1cGRhdGVMaW5lUGF0aHMocGF0aHMsIGNvbnRleHREYXRhKSB7XG4gICAgY29uc3QgeyBpbnRlcnBvbGF0aW9uIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgeyBub2RlRGF0YSB9ID0gY29udGV4dERhdGE7XG4gICAgY29uc3QgW2xpbmVOb2RlXSA9IHBhdGhzO1xuICAgIGxpbmVOb2RlLnBhdGguY2xlYXIodHJ1ZSk7XG4gICAgZm9yIChjb25zdCByYW5nZTMgb2YgcGF0aFJhbmdlcyhub2RlRGF0YSkpIHtcbiAgICAgIHBsb3RQYXRoKHBhdGhSYW5nZVBvaW50cyhub2RlRGF0YSwgcmFuZ2UzKSwgbGluZU5vZGUsIGludGVycG9sYXRpb24pO1xuICAgIH1cbiAgICBsaW5lTm9kZS5jaGVja1BhdGhEaXJ0eSgpO1xuICB9XG4gIGFuaW1hdGVFbXB0eVVwZGF0ZVJlYWR5KGFuaW1hdGlvbkRhdGEpIHtcbiAgICBjb25zdCB7IG1hcmtlclNlbGVjdGlvbiwgbGFiZWxTZWxlY3Rpb24sIGFubm90YXRpb25TZWxlY3Rpb25zLCBjb250ZXh0RGF0YSwgcGF0aHMgfSA9IGFuaW1hdGlvbkRhdGE7XG4gICAgY29uc3QgeyBhbmltYXRpb25NYW5hZ2VyIH0gPSB0aGlzLmN0eDtcbiAgICB0aGlzLnVwZGF0ZUxpbmVQYXRocyhwYXRocywgY29udGV4dERhdGEpO1xuICAgIHBhdGhTd2lwZUluQW5pbWF0aW9uKHRoaXMsIGFuaW1hdGlvbk1hbmFnZXIsIC4uLnBhdGhzKTtcbiAgICByZXNldE1vdGlvbihbbWFya2VyU2VsZWN0aW9uXSwgcmVzZXRNYXJrZXJQb3NpdGlvbkZuKTtcbiAgICBtYXJrZXJTd2lwZVNjYWxlSW5BbmltYXRpb24odGhpcywgYW5pbWF0aW9uTWFuYWdlciwgbWFya2VyU2VsZWN0aW9uKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImxhYmVsc1wiLCBhbmltYXRpb25NYW5hZ2VyLCBsYWJlbFNlbGVjdGlvbik7XG4gICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJhbm5vdGF0aW9uc1wiLCBhbmltYXRpb25NYW5hZ2VyLCAuLi5hbm5vdGF0aW9uU2VsZWN0aW9ucyk7XG4gIH1cbiAgYW5pbWF0ZVJlYWR5UmVzaXplKGFuaW1hdGlvbkRhdGEpIHtcbiAgICBjb25zdCB7IGNvbnRleHREYXRhLCBwYXRocyB9ID0gYW5pbWF0aW9uRGF0YTtcbiAgICB0aGlzLnVwZGF0ZUxpbmVQYXRocyhwYXRocywgY29udGV4dERhdGEpO1xuICAgIHN1cGVyLmFuaW1hdGVSZWFkeVJlc2l6ZShhbmltYXRpb25EYXRhKTtcbiAgfVxuICBhbmltYXRlV2FpdGluZ1VwZGF0ZVJlYWR5KGFuaW1hdGlvbkRhdGEpIHtcbiAgICBjb25zdCB7IGFuaW1hdGlvbk1hbmFnZXIgfSA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IHtcbiAgICAgIG1hcmtlclNlbGVjdGlvbjogbWFya2VyU2VsZWN0aW9ucyxcbiAgICAgIGxhYmVsU2VsZWN0aW9uOiBsYWJlbFNlbGVjdGlvbnMsXG4gICAgICBhbm5vdGF0aW9uU2VsZWN0aW9ucyxcbiAgICAgIGNvbnRleHREYXRhLFxuICAgICAgcGF0aHMsXG4gICAgICBwcmV2aW91c0NvbnRleHREYXRhXG4gICAgfSA9IGFuaW1hdGlvbkRhdGE7XG4gICAgY29uc3QgW3BhdGhdID0gcGF0aHM7XG4gICAgdGhpcy5yZXNldE1hcmtlckFuaW1hdGlvbihhbmltYXRpb25EYXRhKTtcbiAgICB0aGlzLnJlc2V0TGFiZWxBbmltYXRpb24oYW5pbWF0aW9uRGF0YSk7XG4gICAgY29uc3QgdXBkYXRlID0gKCkgPT4ge1xuICAgICAgdGhpcy5yZXNldFBhdGhBbmltYXRpb24oYW5pbWF0aW9uRGF0YSk7XG4gICAgICB0aGlzLnVwZGF0ZUxpbmVQYXRocyhwYXRocywgY29udGV4dERhdGEpO1xuICAgIH07XG4gICAgY29uc3Qgc2tpcCA9ICgpID0+IHtcbiAgICAgIGFuaW1hdGlvbk1hbmFnZXIuc2tpcEN1cnJlbnRCYXRjaCgpO1xuICAgICAgdXBkYXRlKCk7XG4gICAgfTtcbiAgICBpZiAoY29udGV4dERhdGEgPT0gbnVsbCB8fCBwcmV2aW91c0NvbnRleHREYXRhID09IG51bGwpIHtcbiAgICAgIHVwZGF0ZSgpO1xuICAgICAgbWFya2VyRmFkZUluQW5pbWF0aW9uKHRoaXMsIGFuaW1hdGlvbk1hbmFnZXIsIFwiYWRkZWRcIiwgbWFya2VyU2VsZWN0aW9ucyk7XG4gICAgICBwYXRoRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwicGF0aF9wcm9wZXJ0aWVzXCIsIGFuaW1hdGlvbk1hbmFnZXIsIFwiYWRkXCIsIHBhdGgpO1xuICAgICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJsYWJlbHNcIiwgYW5pbWF0aW9uTWFuYWdlciwgbGFiZWxTZWxlY3Rpb25zKTtcbiAgICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwiYW5ub3RhdGlvbnNcIiwgYW5pbWF0aW9uTWFuYWdlciwgLi4uYW5ub3RhdGlvblNlbGVjdGlvbnMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY29udGV4dERhdGEuY3Jvc3NGaWx0ZXJpbmcgIT09IHByZXZpb3VzQ29udGV4dERhdGEuY3Jvc3NGaWx0ZXJpbmcpIHtcbiAgICAgIHNraXAoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGZucztcbiAgICB0cnkge1xuICAgICAgZm5zID0gcHJlcGFyZUxpbmVQYXRoQW5pbWF0aW9uKFxuICAgICAgICBjb250ZXh0RGF0YSxcbiAgICAgICAgcHJldmlvdXNDb250ZXh0RGF0YSxcbiAgICAgICAgdGhpcy5wcm9jZXNzZWREYXRhPy5yZWR1Y2VkPy5kaWZmLFxuICAgICAgICB0aGlzLnByb3BlcnRpZXMuaW50ZXJwb2xhdGlvblxuICAgICAgKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIGZucyA9IHZvaWQgMDtcbiAgICB9XG4gICAgaWYgKGZucyA9PT0gdm9pZCAwKSB7XG4gICAgICBza2lwKCk7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChmbnMuc3RhdHVzID09PSBcIm5vLW9wXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbWFya2VyRmFkZUluQW5pbWF0aW9uKHRoaXMsIGFuaW1hdGlvbk1hbmFnZXIsIHZvaWQgMCwgbWFya2VyU2VsZWN0aW9ucyk7XG4gICAgZnJvbVRvTW90aW9uKHRoaXMuaWQsIFwicGF0aF9wcm9wZXJ0aWVzXCIsIGFuaW1hdGlvbk1hbmFnZXIsIFtwYXRoXSwgZm5zLnBhdGhQcm9wZXJ0aWVzKTtcbiAgICBpZiAoZm5zLnN0YXR1cyA9PT0gXCJhZGRlZFwiKSB7XG4gICAgICB0aGlzLnVwZGF0ZUxpbmVQYXRocyhwYXRocywgY29udGV4dERhdGEpO1xuICAgIH0gZWxzZSBpZiAoZm5zLnN0YXR1cyA9PT0gXCJyZW1vdmVkXCIpIHtcbiAgICAgIHRoaXMudXBkYXRlTGluZVBhdGhzKHBhdGhzLCBwcmV2aW91c0NvbnRleHREYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aE1vdGlvbih0aGlzLmlkLCBcInBhdGhfdXBkYXRlXCIsIGFuaW1hdGlvbk1hbmFnZXIsIFtwYXRoXSwgZm5zLnBhdGgpO1xuICAgIH1cbiAgICBpZiAoZm5zLmhhc01vdGlvbikge1xuICAgICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJsYWJlbHNcIiwgYW5pbWF0aW9uTWFuYWdlciwgbGFiZWxTZWxlY3Rpb25zKTtcbiAgICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwiYW5ub3RhdGlvbnNcIiwgYW5pbWF0aW9uTWFuYWdlciwgLi4uYW5ub3RhdGlvblNlbGVjdGlvbnMpO1xuICAgIH1cbiAgfVxuICBpc0xhYmVsRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLmxhYmVsLmVuYWJsZWQ7XG4gIH1cbiAgZ2V0QmFuZFNjYWxlUGFkZGluZygpIHtcbiAgICByZXR1cm4geyBpbm5lcjogMSwgb3V0ZXI6IDAuMSB9O1xuICB9XG4gIG5vZGVGYWN0b3J5KCkge1xuICAgIHJldHVybiBuZXcgR3JvdXAoKTtcbiAgfVxuICBnZXRGb3JtYXR0ZWRNYXJrZXJTdHlsZShkYXR1bSkge1xuICAgIGNvbnN0IHsgeEtleSwgeUtleSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIHJldHVybiB0aGlzLmdldE1hcmtlclN0eWxlKHRoaXMucHJvcGVydGllcy5tYXJrZXIsIHsgZGF0dW0sIHhLZXksIHlLZXksIGhpZ2hsaWdodGVkOiB0cnVlIH0pO1xuICB9XG4gIGNvbXB1dGVGb2N1c0JvdW5kcyhvcHRzKSB7XG4gICAgcmV0dXJuIGNvbXB1dGVNYXJrZXJGb2N1c0JvdW5kcyh0aGlzLCBvcHRzKTtcbiAgfVxufTtcbkxpbmVTZXJpZXMuY2xhc3NOYW1lID0gXCJMaW5lU2VyaWVzXCI7XG5MaW5lU2VyaWVzLnR5cGUgPSBcImxpbmVcIjtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9saW5lU2VyaWVzTW9kdWxlLnRzXG52YXIgTGluZVNlcmllc01vZHVsZSA9IHtcbiAgdHlwZTogXCJzZXJpZXNcIixcbiAgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLFxuICBwYWNrYWdlVHlwZTogXCJjb21tdW5pdHlcIixcbiAgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCJdLFxuICBpZGVudGlmaWVyOiBcImxpbmVcIixcbiAgbW9kdWxlRmFjdG9yeTogKGN0eCkgPT4gbmV3IExpbmVTZXJpZXMoY3R4KSxcbiAgc3RhY2thYmxlOiB0cnVlLFxuICB0b29sdGlwRGVmYXVsdHM6IHsgcmFuZ2U6IFwibmVhcmVzdFwiIH0sXG4gIGRlZmF1bHRBeGVzOiBbXG4gICAge1xuICAgICAgdHlwZTogXCJudW1iZXJcIiAvKiBOVU1CRVIgKi8sXG4gICAgICBwb3NpdGlvbjogXCJsZWZ0XCIgLyogTEVGVCAqL1xuICAgIH0sXG4gICAge1xuICAgICAgdHlwZTogXCJjYXRlZ29yeVwiIC8qIENBVEVHT1JZICovLFxuICAgICAgcG9zaXRpb246IFwiYm90dG9tXCIgLyogQk9UVE9NICovXG4gICAgfVxuICBdLFxuICB0aGVtZVRlbXBsYXRlOiB7XG4gICAgc2VyaWVzOiB7XG4gICAgICB0b29sdGlwOiB7IHBvc2l0aW9uOiB7IHR5cGU6IFwibm9kZVwiIH0gfSxcbiAgICAgIHN0cm9rZVdpZHRoOiAyLFxuICAgICAgc3Ryb2tlT3BhY2l0eTogMSxcbiAgICAgIGxpbmVEYXNoOiBbMF0sXG4gICAgICBsaW5lRGFzaE9mZnNldDogMCxcbiAgICAgIGludGVycG9sYXRpb246IHtcbiAgICAgICAgdHlwZTogXCJsaW5lYXJcIixcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtIHVzZXJzIHNob3VsZG4ndCBzcGVjaWZ5IGFsbCBvcHRpb25zLCBidXQgd2UgaGF2ZSB0byBmb3IgdGhlbWluZyB0byB3b3JrXG4gICAgICAgIHRlbnNpb246IDEsXG4gICAgICAgIHBvc2l0aW9uOiBcImVuZFwiXG4gICAgICB9LFxuICAgICAgbWFya2VyOiB7XG4gICAgICAgIHNoYXBlOiBcImNpcmNsZVwiLFxuICAgICAgICBzaXplOiA3LFxuICAgICAgICBzdHJva2VXaWR0aDogMFxuICAgICAgfSxcbiAgICAgIGxhYmVsOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBmb250U2l6ZTogMTIsXG4gICAgICAgIGZvbnRGYW1pbHk6IERFRkFVTFRfRk9OVF9GQU1JTFksXG4gICAgICAgIGNvbG9yOiBERUZBVUxUX0xBQkVMX0NPTE9VUlxuICAgICAgfSxcbiAgICAgIGVycm9yQmFyOiB7XG4gICAgICAgIGNhcDoge1xuICAgICAgICAgIGxlbmd0aFJhdGlvOiAxXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHBhbGV0dGVGYWN0b3J5OiAocGFyYW1zKSA9PiB7XG4gICAgY29uc3QgeyBtYXJrZXIgfSA9IG1hcmtlclBhbGV0dGVGYWN0b3J5KHBhcmFtcyk7XG4gICAgcmV0dXJuIHsgc3Ryb2tlOiBtYXJrZXIuZmlsbCwgbWFya2VyIH07XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vc2NhdHRlclNlcmllc1Byb3BlcnRpZXMudHNcbnZhciBTY2F0dGVyU2VyaWVzTGFiZWwgPSBjbGFzcyBleHRlbmRzIExhYmVsIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnBsYWNlbWVudCA9IFwidG9wXCI7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShMQUJFTF9QTEFDRU1FTlQpXG5dLCBTY2F0dGVyU2VyaWVzTGFiZWwucHJvdG90eXBlLCBcInBsYWNlbWVudFwiLCAyKTtcbnZhciBTY2F0dGVyU2VyaWVzUHJvcGVydGllcyA9IGNsYXNzIGV4dGVuZHMgQ2FydGVzaWFuU2VyaWVzUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5jb2xvclJhbmdlID0gW1wiI2ZmZmYwMFwiLCBcIiMwMGZmMDBcIiwgXCIjMDAwMGZmXCJdO1xuICAgIHRoaXMubGFiZWwgPSBuZXcgU2NhdHRlclNlcmllc0xhYmVsKCk7XG4gICAgdGhpcy50b29sdGlwID0gbmV3IFNlcmllc1Rvb2x0aXAoKTtcbiAgICAvLyBObyB2YWxpZGF0aW9uLiBOb3QgYSBwYXJ0IG9mIHRoZSBvcHRpb25zIGNvbnRyYWN0LlxuICAgIHRoaXMubWFya2VyID0gbmV3IFNlcmllc01hcmtlcigpO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HKVxuXSwgU2NhdHRlclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInhLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcpXG5dLCBTY2F0dGVyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwieUtleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgU2NhdHRlclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImxhYmVsS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBTY2F0dGVyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiY29sb3JLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFNjYXR0ZXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ4RmlsdGVyS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBTY2F0dGVyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwieUZpbHRlcktleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgU2NhdHRlclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInhOYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBTY2F0dGVyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwieU5hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFNjYXR0ZXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJsYWJlbE5hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFNjYXR0ZXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjb2xvck5hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShOVU1CRVJfQVJSQVksIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFNjYXR0ZXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjb2xvckRvbWFpblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklOR19BUlJBWSlcbl0sIFNjYXR0ZXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjb2xvclJhbmdlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBTY2F0dGVyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwidGl0bGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBQcm94eVByb3BlcnR5KFwibWFya2VyLnNoYXBlXCIpXG5dLCBTY2F0dGVyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic2hhcGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBQcm94eVByb3BlcnR5KFwibWFya2VyLnNpemVcIilcbl0sIFNjYXR0ZXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzaXplXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgUHJveHlQcm9wZXJ0eShcIm1hcmtlci5maWxsXCIpXG5dLCBTY2F0dGVyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiZmlsbFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHkoXCJtYXJrZXIuZmlsbE9wYWNpdHlcIilcbl0sIFNjYXR0ZXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJmaWxsT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHkoXCJtYXJrZXIuc3Ryb2tlXCIpXG5dLCBTY2F0dGVyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic3Ryb2tlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgUHJveHlQcm9wZXJ0eShcIm1hcmtlci5zdHJva2VXaWR0aFwiKVxuXSwgU2NhdHRlclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0cm9rZVdpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgUHJveHlQcm9wZXJ0eShcIm1hcmtlci5zdHJva2VPcGFjaXR5XCIpXG5dLCBTY2F0dGVyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic3Ryb2tlT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHkoXCJtYXJrZXIuaXRlbVN0eWxlclwiLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBTY2F0dGVyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiaXRlbVN0eWxlclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIFNjYXR0ZXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJsYWJlbFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIFNjYXR0ZXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ0b29sdGlwXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL3NjYXR0ZXJTZXJpZXMudHNcbnZhciBTY2F0dGVyU2VyaWVzID0gY2xhc3MgZXh0ZW5kcyBDYXJ0ZXNpYW5TZXJpZXMge1xuICBjb25zdHJ1Y3Rvcihtb2R1bGVDdHgpIHtcbiAgICBzdXBlcih7XG4gICAgICBtb2R1bGVDdHgsXG4gICAgICBkaXJlY3Rpb25LZXlzOiBERUZBVUxUX0NBUlRFU0lBTl9ESVJFQ1RJT05fS0VZUyxcbiAgICAgIGRpcmVjdGlvbk5hbWVzOiBERUZBVUxUX0NBUlRFU0lBTl9ESVJFQ1RJT05fTkFNRVMsXG4gICAgICBwaWNrTW9kZXM6IFtcbiAgICAgICAgMiAvKiBBWElTX0FMSUdORUQgKi8sXG4gICAgICAgIDEgLyogTkVBUkVTVF9OT0RFICovLFxuICAgICAgICAwIC8qIEVYQUNUX1NIQVBFX01BVENIICovXG4gICAgICBdLFxuICAgICAgcGF0aHNQZXJTZXJpZXM6IFtdLFxuICAgICAgaGFzTWFya2VyczogdHJ1ZSxcbiAgICAgIG1hcmtlclNlbGVjdGlvbkdhcmJhZ2VDb2xsZWN0aW9uOiBmYWxzZSxcbiAgICAgIGFuaW1hdGlvblJlc2V0Rm5zOiB7XG4gICAgICAgIG1hcmtlcjogcmVzZXRNYXJrZXJGbixcbiAgICAgICAgbGFiZWw6IHJlc2V0TGFiZWxGblxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMucHJvcGVydGllcyA9IG5ldyBTY2F0dGVyU2VyaWVzUHJvcGVydGllcygpO1xuICAgIHRoaXMuY29sb3JTY2FsZSA9IG5ldyBDb2xvclNjYWxlKCk7XG4gIH1cbiAgZ2V0IHBpY2tNb2RlQXhpcygpIHtcbiAgICByZXR1cm4gXCJtYWluLWNhdGVnb3J5XCI7XG4gIH1cbiAgYXN5bmMgcHJvY2Vzc0RhdGEoZGF0YUNvbnRyb2xsZXIpIHtcbiAgICBpZiAoIXRoaXMucHJvcGVydGllcy5pc1ZhbGlkKCkgfHwgdGhpcy5kYXRhID09IG51bGwgfHwgIXRoaXMudmlzaWJsZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB4U2NhbGUgPSB0aGlzLmF4ZXNbXCJ4XCIgLyogWCAqL10/LnNjYWxlO1xuICAgIGNvbnN0IHlTY2FsZSA9IHRoaXMuYXhlc1tcInlcIiAvKiBZICovXT8uc2NhbGU7XG4gICAgY29uc3QgeyB4U2NhbGVUeXBlLCB5U2NhbGVUeXBlIH0gPSB0aGlzLmdldFNjYWxlSW5mb3JtYXRpb24oeyB4U2NhbGUsIHlTY2FsZSB9KTtcbiAgICBjb25zdCBjb2xvclNjYWxlVHlwZSA9IHRoaXMuY29sb3JTY2FsZS50eXBlO1xuICAgIGNvbnN0IHsgeEtleSwgeUtleSwgeEZpbHRlcktleSwgeUZpbHRlcktleSwgbGFiZWxLZXksIGNvbG9yS2V5LCBjb2xvckRvbWFpbiwgY29sb3JSYW5nZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHsgZGF0YU1vZGVsLCBwcm9jZXNzZWREYXRhIH0gPSBhd2FpdCB0aGlzLnJlcXVlc3REYXRhTW9kZWwoZGF0YUNvbnRyb2xsZXIsIHRoaXMuZGF0YSwge1xuICAgICAgcHJvcHM6IFtcbiAgICAgICAgdmFsdWVQcm9wZXJ0eSh4S2V5LCB4U2NhbGVUeXBlLCB7IGlkOiBgeFZhbHVlYCB9KSxcbiAgICAgICAgdmFsdWVQcm9wZXJ0eSh5S2V5LCB5U2NhbGVUeXBlLCB7IGlkOiBgeVZhbHVlYCB9KSxcbiAgICAgICAgLi4ueEZpbHRlcktleSAhPSBudWxsID8gW3ZhbHVlUHJvcGVydHkoeEZpbHRlcktleSwgeFNjYWxlVHlwZSwgeyBpZDogXCJ4RmlsdGVyVmFsdWVcIiB9KV0gOiBbXSxcbiAgICAgICAgLi4ueUZpbHRlcktleSAhPSBudWxsID8gW3ZhbHVlUHJvcGVydHkoeUZpbHRlcktleSwgeVNjYWxlVHlwZSwgeyBpZDogXCJ5RmlsdGVyVmFsdWVcIiB9KV0gOiBbXSxcbiAgICAgICAgLi4uY29sb3JLZXkgPyBbdmFsdWVQcm9wZXJ0eShjb2xvcktleSwgY29sb3JTY2FsZVR5cGUsIHsgaWQ6IGBjb2xvclZhbHVlYCB9KV0gOiBbXSxcbiAgICAgICAgLi4ubGFiZWxLZXkgPyBbdmFsdWVQcm9wZXJ0eShsYWJlbEtleSwgXCJiYW5kXCIsIHsgaWQ6IGBsYWJlbFZhbHVlYCB9KV0gOiBbXVxuICAgICAgXVxuICAgIH0pO1xuICAgIGlmIChjb2xvcktleSkge1xuICAgICAgY29uc3QgY29sb3JLZXlJZHggPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYGNvbG9yVmFsdWVgKTtcbiAgICAgIHRoaXMuY29sb3JTY2FsZS5kb21haW4gPSBjb2xvckRvbWFpbiA/PyBwcm9jZXNzZWREYXRhLmRvbWFpbi52YWx1ZXNbY29sb3JLZXlJZHhdID8/IFtdO1xuICAgICAgdGhpcy5jb2xvclNjYWxlLnJhbmdlID0gY29sb3JSYW5nZTtcbiAgICAgIHRoaXMuY29sb3JTY2FsZS51cGRhdGUoKTtcbiAgICB9XG4gICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwidXBkYXRlRGF0YVwiKTtcbiAgfVxuICBnZXRTZXJpZXNEb21haW4oZGlyZWN0aW9uKSB7XG4gICAgY29uc3QgeyBkYXRhTW9kZWwsIHByb2Nlc3NlZERhdGEgfSA9IHRoaXM7XG4gICAgaWYgKCFwcm9jZXNzZWREYXRhIHx8ICFkYXRhTW9kZWwpXG4gICAgICByZXR1cm4gW107XG4gICAgY29uc3QgaWQgPSBkaXJlY3Rpb24gPT09IFwieFwiIC8qIFggKi8gPyBgeFZhbHVlYCA6IGB5VmFsdWVgO1xuICAgIGNvbnN0IGRhdGFEZWYgPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFEZWZCeUlkKHRoaXMsIGlkKTtcbiAgICBjb25zdCBkb21haW4gPSBkYXRhTW9kZWwuZ2V0RG9tYWluKHRoaXMsIGlkLCBcInZhbHVlXCIsIHByb2Nlc3NlZERhdGEpO1xuICAgIGlmIChkYXRhRGVmPy5kZWYudHlwZSA9PT0gXCJ2YWx1ZVwiICYmIGRhdGFEZWY/LmRlZi52YWx1ZVR5cGUgPT09IFwiY2F0ZWdvcnlcIikge1xuICAgICAgcmV0dXJuIGRvbWFpbjtcbiAgICB9XG4gICAgcmV0dXJuIGZpeE51bWVyaWNFeHRlbnQoZXh0ZW50KGRvbWFpbikpO1xuICB9XG4gIGFzeW5jIGNyZWF0ZU5vZGVEYXRhKCkge1xuICAgIGNvbnN0IHsgYXhlcywgZGF0YU1vZGVsLCBwcm9jZXNzZWREYXRhLCBjb2xvclNjYWxlIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIHhLZXksXG4gICAgICB5S2V5LFxuICAgICAgeEZpbHRlcktleSxcbiAgICAgIHlGaWx0ZXJLZXksXG4gICAgICBsYWJlbEtleSxcbiAgICAgIGNvbG9yS2V5LFxuICAgICAgeE5hbWUsXG4gICAgICB5TmFtZSxcbiAgICAgIGxhYmVsTmFtZSxcbiAgICAgIG1hcmtlcixcbiAgICAgIGxhYmVsLFxuICAgICAgdmlzaWJsZVxuICAgIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgeyBwbGFjZW1lbnQgfSA9IGxhYmVsO1xuICAgIGNvbnN0IG1hcmtlclNoYXBlID0gZ2V0TWFya2VyKG1hcmtlci5zaGFwZSk7XG4gICAgY29uc3QgeEF4aXMgPSBheGVzW1wieFwiIC8qIFggKi9dO1xuICAgIGNvbnN0IHlBeGlzID0gYXhlc1tcInlcIiAvKiBZICovXTtcbiAgICBpZiAoIShkYXRhTW9kZWwgJiYgcHJvY2Vzc2VkRGF0YSAmJiB2aXNpYmxlICYmIHhBeGlzICYmIHlBeGlzKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB4RGF0YUlkeCA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgeFZhbHVlYCk7XG4gICAgY29uc3QgeURhdGFJZHggPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYHlWYWx1ZWApO1xuICAgIGNvbnN0IGNvbG9yRGF0YUlkeCA9IGNvbG9yS2V5ICE9IG51bGwgPyBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYGNvbG9yVmFsdWVgKSA6IC0xO1xuICAgIGNvbnN0IGxhYmVsRGF0YUlkeCA9IGxhYmVsS2V5ICE9IG51bGwgPyBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYGxhYmVsVmFsdWVgKSA6IC0xO1xuICAgIGNvbnN0IHhGaWx0ZXJEYXRhSWR4ID0geEZpbHRlcktleSAhPSBudWxsID8gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGB4RmlsdGVyVmFsdWVgKSA6IHZvaWQgMDtcbiAgICBjb25zdCB5RmlsdGVyRGF0YUlkeCA9IHlGaWx0ZXJLZXkgIT0gbnVsbCA/IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgeUZpbHRlclZhbHVlYCkgOiB2b2lkIDA7XG4gICAgY29uc3QgeFNjYWxlID0geEF4aXMuc2NhbGU7XG4gICAgY29uc3QgeVNjYWxlID0geUF4aXMuc2NhbGU7XG4gICAgY29uc3QgeE9mZnNldCA9ICh4U2NhbGUuYmFuZHdpZHRoID8/IDApIC8gMjtcbiAgICBjb25zdCB5T2Zmc2V0ID0gKHlTY2FsZS5iYW5kd2lkdGggPz8gMCkgLyAyO1xuICAgIGNvbnN0IG5vZGVEYXRhID0gW107XG4gICAgY29uc3QgZm9udCA9IGxhYmVsLmdldEZvbnQoKTtcbiAgICBjb25zdCB0ZXh0TWVhc3VyZXIgPSBDYWNoZWRUZXh0TWVhc3VyZXJQb29sLmdldE1lYXN1cmVyKHsgZm9udCB9KTtcbiAgICBmb3IgKGNvbnN0IHsgdmFsdWVzLCBkYXR1bSB9IG9mIHByb2Nlc3NlZERhdGEuZGF0YSA/PyBbXSkge1xuICAgICAgY29uc3QgeERhdHVtID0gdmFsdWVzW3hEYXRhSWR4XTtcbiAgICAgIGNvbnN0IHlEYXR1bSA9IHZhbHVlc1t5RGF0YUlkeF07XG4gICAgICBjb25zdCB4ID0geFNjYWxlLmNvbnZlcnQoeERhdHVtKSArIHhPZmZzZXQ7XG4gICAgICBjb25zdCB5ID0geVNjYWxlLmNvbnZlcnQoeURhdHVtKSArIHlPZmZzZXQ7XG4gICAgICBjb25zdCBzZWxlY3RlZCA9IHhGaWx0ZXJEYXRhSWR4ICE9IG51bGwgJiYgeUZpbHRlckRhdGFJZHggIT0gbnVsbCA/IHZhbHVlc1t4RmlsdGVyRGF0YUlkeF0gPT09IHhEYXR1bSAmJiB2YWx1ZXNbeUZpbHRlckRhdGFJZHhdID09PSB5RGF0dW0gOiB2b2lkIDA7XG4gICAgICBjb25zdCBsYWJlbFRleHQgPSB0aGlzLmdldExhYmVsVGV4dChsYWJlbCwge1xuICAgICAgICB2YWx1ZTogbGFiZWxLZXkgPyB2YWx1ZXNbbGFiZWxEYXRhSWR4XSA6IHlEYXR1bSxcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIHhLZXksXG4gICAgICAgIHlLZXksXG4gICAgICAgIGxhYmVsS2V5LFxuICAgICAgICB4TmFtZSxcbiAgICAgICAgeU5hbWUsXG4gICAgICAgIGxhYmVsTmFtZVxuICAgICAgfSk7XG4gICAgICBjb25zdCBzaXplID0gdGV4dE1lYXN1cmVyLm1lYXN1cmVUZXh0KGxhYmVsVGV4dCk7XG4gICAgICBjb25zdCBmaWxsID0gY29sb3JLZXkgPyBjb2xvclNjYWxlLmNvbnZlcnQodmFsdWVzW2NvbG9yRGF0YUlkeF0pIDogdm9pZCAwO1xuICAgICAgbm9kZURhdGEucHVzaCh7XG4gICAgICAgIHNlcmllczogdGhpcyxcbiAgICAgICAgaXRlbUlkOiB5S2V5LFxuICAgICAgICB5S2V5LFxuICAgICAgICB4S2V5LFxuICAgICAgICBkYXR1bSxcbiAgICAgICAgeFZhbHVlOiB4RGF0dW0sXG4gICAgICAgIHlWYWx1ZTogeURhdHVtLFxuICAgICAgICBjYXBEZWZhdWx0czogeyBsZW5ndGhSYXRpb011bHRpcGxpZXI6IG1hcmtlci5nZXREaWFtZXRlcigpLCBsZW5ndGhNYXg6IEluZmluaXR5IH0sXG4gICAgICAgIHBvaW50OiB7IHgsIHksIHNpemU6IG1hcmtlci5zaXplIH0sXG4gICAgICAgIG1pZFBvaW50OiB7IHgsIHkgfSxcbiAgICAgICAgZmlsbCxcbiAgICAgICAgbGFiZWw6IHsgdGV4dDogbGFiZWxUZXh0LCAuLi5zaXplIH0sXG4gICAgICAgIG1hcmtlcjogbWFya2VyU2hhcGUsXG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgc2VsZWN0ZWRcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgaXRlbUlkOiB5S2V5LFxuICAgICAgbm9kZURhdGEsXG4gICAgICBsYWJlbERhdGE6IG5vZGVEYXRhLFxuICAgICAgc2NhbGVzOiB0aGlzLmNhbGN1bGF0ZVNjYWxpbmcoKSxcbiAgICAgIHZpc2libGU6IHRoaXMudmlzaWJsZVxuICAgIH07XG4gIH1cbiAgaXNQYXRoT3JTZWxlY3Rpb25EaXJ0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLm1hcmtlci5pc0RpcnR5KCk7XG4gIH1cbiAgZ2V0TGFiZWxEYXRhKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHROb2RlRGF0YT8ubGFiZWxEYXRhID8/IFtdO1xuICB9XG4gIG1hcmtlckZhY3RvcnkoKSB7XG4gICAgY29uc3QgeyBzaGFwZSB9ID0gdGhpcy5wcm9wZXJ0aWVzLm1hcmtlcjtcbiAgICBjb25zdCBNYXJrZXJTaGFwZSA9IGdldE1hcmtlcihzaGFwZSk7XG4gICAgcmV0dXJuIG5ldyBNYXJrZXJTaGFwZSgpO1xuICB9XG4gIGFzeW5jIHVwZGF0ZU1hcmtlclNlbGVjdGlvbihvcHRzKSB7XG4gICAgY29uc3QgeyBub2RlRGF0YSwgbWFya2VyU2VsZWN0aW9uIH0gPSBvcHRzO1xuICAgIGlmICh0aGlzLnByb3BlcnRpZXMubWFya2VyLmlzRGlydHkoKSkge1xuICAgICAgbWFya2VyU2VsZWN0aW9uLmNsZWFyKCk7XG4gICAgICBtYXJrZXJTZWxlY3Rpb24uY2xlYW51cCgpO1xuICAgIH1cbiAgICByZXR1cm4gbWFya2VyU2VsZWN0aW9uLnVwZGF0ZSh0aGlzLnByb3BlcnRpZXMubWFya2VyLmVuYWJsZWQgPyBub2RlRGF0YSA6IFtdKTtcbiAgfVxuICBhc3luYyB1cGRhdGVNYXJrZXJOb2RlcyhvcHRzKSB7XG4gICAgY29uc3QgeyBtYXJrZXJTZWxlY3Rpb24sIGlzSGlnaGxpZ2h0OiBoaWdobGlnaHRlZCB9ID0gb3B0cztcbiAgICBjb25zdCB7IHhLZXksIHlLZXksIGxhYmVsS2V5LCBtYXJrZXIsIGhpZ2hsaWdodFN0eWxlIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgYmFzZVN0eWxlID0gbWVyZ2VEZWZhdWx0cyhoaWdobGlnaHRlZCAmJiBoaWdobGlnaHRTdHlsZS5pdGVtLCBtYXJrZXIuZ2V0U3R5bGUoKSk7XG4gICAgbWFya2VyU2VsZWN0aW9uLmVhY2goKG5vZGUsIGRhdHVtKSA9PiB7XG4gICAgICB0aGlzLnVwZGF0ZU1hcmtlclN0eWxlKG5vZGUsIG1hcmtlciwgeyBkYXR1bSwgaGlnaGxpZ2h0ZWQsIHhLZXksIHlLZXksIGxhYmVsS2V5IH0sIGJhc2VTdHlsZSwge1xuICAgICAgICBzZWxlY3RlZDogZGF0dW0uc2VsZWN0ZWRcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmICghaGlnaGxpZ2h0ZWQpIHtcbiAgICAgIG1hcmtlci5tYXJrQ2xlYW4oKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgdXBkYXRlTGFiZWxTZWxlY3Rpb24ob3B0cykge1xuICAgIGNvbnN0IHBsYWNlZExhYmVscyA9IHRoaXMuaXNMYWJlbEVuYWJsZWQoKSA/IHRoaXMuY2hhcnQ/LnBsYWNlTGFiZWxzKCkuZ2V0KHRoaXMpID8/IFtdIDogW107XG4gICAgcmV0dXJuIG9wdHMubGFiZWxTZWxlY3Rpb24udXBkYXRlKFxuICAgICAgcGxhY2VkTGFiZWxzLm1hcCgoeyBkYXR1bSwgeCwgeSB9KSA9PiAoe1xuICAgICAgICAuLi5kYXR1bSxcbiAgICAgICAgcG9pbnQ6IHsgeCwgeSwgc2l6ZTogZGF0dW0ucG9pbnQuc2l6ZSB9LFxuICAgICAgICBwbGFjZW1lbnQ6IFwidG9wXCJcbiAgICAgIH0pKSxcbiAgICAgICh0ZXh0KSA9PiB7XG4gICAgICAgIHRleHQucG9pbnRlckV2ZW50cyA9IDEgLyogTm9uZSAqLztcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGFzeW5jIHVwZGF0ZUxhYmVsTm9kZXMob3B0cykge1xuICAgIGNvbnN0IHsgbGFiZWwgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBvcHRzLmxhYmVsU2VsZWN0aW9uLmVhY2goKHRleHQsIGRhdHVtKSA9PiB7XG4gICAgICB0ZXh0LnRleHQgPSBkYXR1bS5sYWJlbC50ZXh0O1xuICAgICAgdGV4dC5maWxsID0gbGFiZWwuY29sb3I7XG4gICAgICB0ZXh0LnggPSBkYXR1bS5wb2ludD8ueCA/PyAwO1xuICAgICAgdGV4dC55ID0gZGF0dW0ucG9pbnQ/LnkgPz8gMDtcbiAgICAgIHRleHQuZm9udFN0eWxlID0gbGFiZWwuZm9udFN0eWxlO1xuICAgICAgdGV4dC5mb250V2VpZ2h0ID0gbGFiZWwuZm9udFdlaWdodDtcbiAgICAgIHRleHQuZm9udFNpemUgPSBsYWJlbC5mb250U2l6ZTtcbiAgICAgIHRleHQuZm9udEZhbWlseSA9IGxhYmVsLmZvbnRGYW1pbHk7XG4gICAgICB0ZXh0LnRleHRBbGlnbiA9IFwibGVmdFwiO1xuICAgICAgdGV4dC50ZXh0QmFzZWxpbmUgPSBcInRvcFwiO1xuICAgIH0pO1xuICB9XG4gIGdldFRvb2x0aXBIdG1sKG5vZGVEYXR1bSkge1xuICAgIGNvbnN0IHhBeGlzID0gdGhpcy5heGVzW1wieFwiIC8qIFggKi9dO1xuICAgIGNvbnN0IHlBeGlzID0gdGhpcy5heGVzW1wieVwiIC8qIFkgKi9dO1xuICAgIGlmICghdGhpcy5wcm9wZXJ0aWVzLmlzVmFsaWQoKSB8fCAheEF4aXMgfHwgIXlBeGlzKSB7XG4gICAgICByZXR1cm4gRU1QVFlfVE9PTFRJUF9DT05URU5UO1xuICAgIH1cbiAgICBjb25zdCB7IHhLZXksIHlLZXksIGxhYmVsS2V5LCB4TmFtZSwgeU5hbWUsIGxhYmVsTmFtZSwgdGl0bGUgPSB5TmFtZSwgbWFya2VyLCB0b29sdGlwIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgeyBkYXR1bSwgeFZhbHVlLCB5VmFsdWUsIGxhYmVsLCBpdGVtSWQgfSA9IG5vZGVEYXR1bTtcbiAgICBjb25zdCBiYXNlU3R5bGUgPSBtZXJnZURlZmF1bHRzKFxuICAgICAgeyBmaWxsOiBub2RlRGF0dW0uZmlsbCwgc3Ryb2tlV2lkdGg6IHRoaXMuZ2V0U3Ryb2tlV2lkdGgobWFya2VyLnN0cm9rZVdpZHRoKSB9LFxuICAgICAgbWFya2VyLmdldFN0eWxlKClcbiAgICApO1xuICAgIGNvbnN0IHsgZmlsbDogY29sb3IgPSBcImdyYXlcIiB9ID0gdGhpcy5nZXRNYXJrZXJTdHlsZShcbiAgICAgIG1hcmtlcixcbiAgICAgIHsgZGF0dW06IG5vZGVEYXR1bSwgaGlnaGxpZ2h0ZWQ6IGZhbHNlLCB4S2V5LCB5S2V5LCBsYWJlbEtleSB9LFxuICAgICAgYmFzZVN0eWxlXG4gICAgKTtcbiAgICBjb25zdCB4U3RyaW5nID0gc2FuaXRpemVIdG1sKHhBeGlzLmZvcm1hdERhdHVtKHhWYWx1ZSkpO1xuICAgIGNvbnN0IHlTdHJpbmcgPSBzYW5pdGl6ZUh0bWwoeUF4aXMuZm9ybWF0RGF0dW0oeVZhbHVlKSk7XG4gICAgbGV0IGNvbnRlbnQgPSBgPGI+JHtzYW5pdGl6ZUh0bWwoeE5hbWUgPz8geEtleSl9PC9iPjogJHt4U3RyaW5nfTxicj48Yj4ke3Nhbml0aXplSHRtbCh5TmFtZSA/PyB5S2V5KX08L2I+OiAke3lTdHJpbmd9YDtcbiAgICBpZiAobGFiZWxLZXkpIHtcbiAgICAgIGNvbnRlbnQgPSBgPGI+JHtzYW5pdGl6ZUh0bWwobGFiZWxOYW1lID8/IGxhYmVsS2V5KX08L2I+OiAke3Nhbml0aXplSHRtbChsYWJlbC50ZXh0KX08YnI+YCArIGNvbnRlbnQ7XG4gICAgfVxuICAgIHJldHVybiB0b29sdGlwLnRvVG9vbHRpcEh0bWwoXG4gICAgICB7IHRpdGxlLCBjb250ZW50LCBiYWNrZ3JvdW5kQ29sb3I6IGNvbG9yIH0sXG4gICAgICB7XG4gICAgICAgIGRhdHVtLFxuICAgICAgICBpdGVtSWQsXG4gICAgICAgIHhLZXksXG4gICAgICAgIHhOYW1lLFxuICAgICAgICB5S2V5LFxuICAgICAgICB5TmFtZSxcbiAgICAgICAgbGFiZWxLZXksXG4gICAgICAgIGxhYmVsTmFtZSxcbiAgICAgICAgdGl0bGUsXG4gICAgICAgIGNvbG9yLFxuICAgICAgICBzZXJpZXNJZDogdGhpcy5pZCxcbiAgICAgICAgLi4udGhpcy5nZXRNb2R1bGVUb29sdGlwUGFyYW1zKClcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGdldExlZ2VuZERhdGEobGVnZW5kVHlwZSkge1xuICAgIGNvbnN0IHsgeUtleSwgeU5hbWUsIHRpdGxlLCBtYXJrZXIsIHZpc2libGUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCB7IGZpbGwsIHN0cm9rZSwgZmlsbE9wYWNpdHksIHN0cm9rZU9wYWNpdHksIHN0cm9rZVdpZHRoIH0gPSBtYXJrZXI7XG4gICAgaWYgKCF0aGlzLmRhdGE/Lmxlbmd0aCB8fCAhdGhpcy5wcm9wZXJ0aWVzLmlzVmFsaWQoKSB8fCBsZWdlbmRUeXBlICE9PSBcImNhdGVnb3J5XCIpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgbGVnZW5kVHlwZTogXCJjYXRlZ29yeVwiLFxuICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgaXRlbUlkOiB5S2V5LFxuICAgICAgICBzZXJpZXNJZDogdGhpcy5pZCxcbiAgICAgICAgZW5hYmxlZDogdmlzaWJsZSxcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICB0ZXh0OiB0aXRsZSA/PyB5TmFtZSA/PyB5S2V5XG4gICAgICAgIH0sXG4gICAgICAgIHN5bWJvbHM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBtYXJrZXI6IHtcbiAgICAgICAgICAgICAgc2hhcGU6IG1hcmtlci5zaGFwZSxcbiAgICAgICAgICAgICAgZmlsbDogbWFya2VyLmZpbGwgPz8gZmlsbCA/PyBcInJnYmEoMCwgMCwgMCwgMClcIixcbiAgICAgICAgICAgICAgc3Ryb2tlOiBtYXJrZXIuc3Ryb2tlID8/IHN0cm9rZSA/PyBcInJnYmEoMCwgMCwgMCwgMClcIixcbiAgICAgICAgICAgICAgZmlsbE9wYWNpdHk6IGZpbGxPcGFjaXR5ID8/IDEsXG4gICAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IHN0cm9rZU9wYWNpdHkgPz8gMSxcbiAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoID8/IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH1cbiAgICBdO1xuICB9XG4gIGFuaW1hdGVFbXB0eVVwZGF0ZVJlYWR5KGRhdGEpIHtcbiAgICBjb25zdCB7IG1hcmtlclNlbGVjdGlvbiwgbGFiZWxTZWxlY3Rpb24sIGFubm90YXRpb25TZWxlY3Rpb25zIH0gPSBkYXRhO1xuICAgIG1hcmtlclNjYWxlSW5BbmltYXRpb24odGhpcywgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgbWFya2VyU2VsZWN0aW9uKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImxhYmVsc1wiLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCBsYWJlbFNlbGVjdGlvbik7XG4gICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJhbm5vdGF0aW9uc1wiLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCAuLi5hbm5vdGF0aW9uU2VsZWN0aW9ucyk7XG4gIH1cbiAgaXNMYWJlbEVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcGVydGllcy5sYWJlbC5lbmFibGVkO1xuICB9XG4gIG5vZGVGYWN0b3J5KCkge1xuICAgIHJldHVybiBuZXcgR3JvdXAoKTtcbiAgfVxuICBnZXRGb3JtYXR0ZWRNYXJrZXJTdHlsZShkYXR1bSkge1xuICAgIGNvbnN0IHsgeEtleSwgeUtleSwgbGFiZWxLZXkgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICByZXR1cm4gdGhpcy5nZXRNYXJrZXJTdHlsZSh0aGlzLnByb3BlcnRpZXMubWFya2VyLCB7IGRhdHVtLCB4S2V5LCB5S2V5LCBsYWJlbEtleSwgaGlnaGxpZ2h0ZWQ6IHRydWUgfSk7XG4gIH1cbiAgY29tcHV0ZUZvY3VzQm91bmRzKG9wdHMpIHtcbiAgICByZXR1cm4gY29tcHV0ZU1hcmtlckZvY3VzQm91bmRzKHRoaXMsIG9wdHMpO1xuICB9XG59O1xuU2NhdHRlclNlcmllcy5jbGFzc05hbWUgPSBcIlNjYXR0ZXJTZXJpZXNcIjtcblNjYXR0ZXJTZXJpZXMudHlwZSA9IFwic2NhdHRlclwiO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL3NjYXR0ZXJTZXJpZXNNb2R1bGUudHNcbnZhciBTY2F0dGVyU2VyaWVzTW9kdWxlID0ge1xuICB0eXBlOiBcInNlcmllc1wiLFxuICBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsXG4gIHBhY2thZ2VUeXBlOiBcImNvbW11bml0eVwiLFxuICBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIl0sXG4gIGlkZW50aWZpZXI6IFwic2NhdHRlclwiLFxuICBtb2R1bGVGYWN0b3J5OiAoY3R4KSA9PiBuZXcgU2NhdHRlclNlcmllcyhjdHgpLFxuICB0b29sdGlwRGVmYXVsdHM6IHsgcmFuZ2U6IFwibmVhcmVzdFwiIH0sXG4gIGRlZmF1bHRBeGVzOiBbXG4gICAge1xuICAgICAgdHlwZTogXCJudW1iZXJcIiAvKiBOVU1CRVIgKi8sXG4gICAgICBwb3NpdGlvbjogXCJib3R0b21cIiAvKiBCT1RUT00gKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIHR5cGU6IFwibnVtYmVyXCIgLyogTlVNQkVSICovLFxuICAgICAgcG9zaXRpb246IFwibGVmdFwiIC8qIExFRlQgKi9cbiAgICB9XG4gIF0sXG4gIHRoZW1lVGVtcGxhdGU6IHtcbiAgICBzZXJpZXM6IHtcbiAgICAgIHNoYXBlOiBcImNpcmNsZVwiLFxuICAgICAgc2l6ZTogNyxcbiAgICAgIGZpbGxPcGFjaXR5OiAwLjgsXG4gICAgICB0b29sdGlwOiB7IHBvc2l0aW9uOiB7IHR5cGU6IFwibm9kZVwiIH0gfSxcbiAgICAgIGxhYmVsOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBmb250U2l6ZTogMTIsXG4gICAgICAgIGZvbnRGYW1pbHk6IERFRkFVTFRfRk9OVF9GQU1JTFksXG4gICAgICAgIGNvbG9yOiBERUZBVUxUX0xBQkVMX0NPTE9VUlxuICAgICAgfSxcbiAgICAgIGVycm9yQmFyOiB7XG4gICAgICAgIGNhcDoge1xuICAgICAgICAgIGxlbmd0aFJhdGlvOiAxXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHBhbGV0dGVGYWN0b3J5OiBzaW5nbGVTZXJpZXNQYWxldHRlRmFjdG9yeVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvc2VjdG9yQm94LnRzXG52YXIgU2VjdG9yQm94ID0gY2xhc3MgX1NlY3RvckJveCB7XG4gIGNvbnN0cnVjdG9yKHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMpIHtcbiAgICB0aGlzLnN0YXJ0QW5nbGUgPSBzdGFydEFuZ2xlO1xuICAgIHRoaXMuZW5kQW5nbGUgPSBlbmRBbmdsZTtcbiAgICB0aGlzLmlubmVyUmFkaXVzID0gaW5uZXJSYWRpdXM7XG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IG91dGVyUmFkaXVzO1xuICB9XG4gIGNsb25lKCkge1xuICAgIGNvbnN0IHsgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cyB9ID0gdGhpcztcbiAgICByZXR1cm4gbmV3IF9TZWN0b3JCb3goc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cyk7XG4gIH1cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhcnRBbmdsZSA9PT0gb3RoZXIuc3RhcnRBbmdsZSAmJiB0aGlzLmVuZEFuZ2xlID09PSBvdGhlci5lbmRBbmdsZSAmJiB0aGlzLmlubmVyUmFkaXVzID09PSBvdGhlci5pbm5lclJhZGl1cyAmJiB0aGlzLm91dGVyUmFkaXVzID09PSBvdGhlci5vdXRlclJhZGl1cztcbiAgfVxuICBbaW50ZXJwb2xhdGVdKG90aGVyLCBkKSB7XG4gICAgcmV0dXJuIG5ldyBfU2VjdG9yQm94KFxuICAgICAgdGhpcy5zdGFydEFuZ2xlICogKDEgLSBkKSArIG90aGVyLnN0YXJ0QW5nbGUgKiBkLFxuICAgICAgdGhpcy5lbmRBbmdsZSAqICgxIC0gZCkgKyBvdGhlci5lbmRBbmdsZSAqIGQsXG4gICAgICB0aGlzLmlubmVyUmFkaXVzICogKDEgLSBkKSArIG90aGVyLmlubmVyUmFkaXVzICogZCxcbiAgICAgIHRoaXMub3V0ZXJSYWRpdXMgKiAoMSAtIGQpICsgb3RoZXIub3V0ZXJSYWRpdXMgKiBkXG4gICAgKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvdXRpbC9zZWN0b3IudHNcbmZ1bmN0aW9uIHNlY3RvckJveCh7IHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMgfSkge1xuICBsZXQgeDAgPSBJbmZpbml0eTtcbiAgbGV0IHkwID0gSW5maW5pdHk7XG4gIGxldCB4MSA9IC1JbmZpbml0eTtcbiAgbGV0IHkxID0gLUluZmluaXR5O1xuICBjb25zdCBhZGRQb2ludCA9ICh4LCB5KSA9PiB7XG4gICAgeDAgPSBNYXRoLm1pbih4LCB4MCk7XG4gICAgeTAgPSBNYXRoLm1pbih5LCB5MCk7XG4gICAgeDEgPSBNYXRoLm1heCh4LCB4MSk7XG4gICAgeTEgPSBNYXRoLm1heCh5LCB5MSk7XG4gIH07XG4gIGFkZFBvaW50KGlubmVyUmFkaXVzICogTWF0aC5jb3Moc3RhcnRBbmdsZSksIGlubmVyUmFkaXVzICogTWF0aC5zaW4oc3RhcnRBbmdsZSkpO1xuICBhZGRQb2ludChpbm5lclJhZGl1cyAqIE1hdGguY29zKGVuZEFuZ2xlKSwgaW5uZXJSYWRpdXMgKiBNYXRoLnNpbihlbmRBbmdsZSkpO1xuICBhZGRQb2ludChvdXRlclJhZGl1cyAqIE1hdGguY29zKHN0YXJ0QW5nbGUpLCBvdXRlclJhZGl1cyAqIE1hdGguc2luKHN0YXJ0QW5nbGUpKTtcbiAgYWRkUG9pbnQob3V0ZXJSYWRpdXMgKiBNYXRoLmNvcyhlbmRBbmdsZSksIG91dGVyUmFkaXVzICogTWF0aC5zaW4oZW5kQW5nbGUpKTtcbiAgaWYgKGlzQmV0d2VlbkFuZ2xlcygwLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSkpIHtcbiAgICBhZGRQb2ludChvdXRlclJhZGl1cywgMCk7XG4gIH1cbiAgaWYgKGlzQmV0d2VlbkFuZ2xlcyhNYXRoLlBJICogMC41LCBzdGFydEFuZ2xlLCBlbmRBbmdsZSkpIHtcbiAgICBhZGRQb2ludCgwLCBvdXRlclJhZGl1cyk7XG4gIH1cbiAgaWYgKGlzQmV0d2VlbkFuZ2xlcyhNYXRoLlBJLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSkpIHtcbiAgICBhZGRQb2ludCgtb3V0ZXJSYWRpdXMsIDApO1xuICB9XG4gIGlmIChpc0JldHdlZW5BbmdsZXMoTWF0aC5QSSAqIDEuNSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpKSB7XG4gICAgYWRkUG9pbnQoMCwgLW91dGVyUmFkaXVzKTtcbiAgfVxuICByZXR1cm4gbmV3IEJCb3goeDAsIHkwLCB4MSAtIHgwLCB5MSAtIHkwKTtcbn1cbmZ1bmN0aW9uIGlzUG9pbnRJblNlY3Rvcih4LCB5LCBzZWN0b3IpIHtcbiAgY29uc3QgcmFkaXVzID0gTWF0aC5zcXJ0KE1hdGgucG93KHgsIDIpICsgTWF0aC5wb3coeSwgMikpO1xuICBjb25zdCB7IGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cyB9ID0gc2VjdG9yO1xuICBpZiAoc2VjdG9yLnN0YXJ0QW5nbGUgPT09IHNlY3Rvci5lbmRBbmdsZSB8fCByYWRpdXMgPCBNYXRoLm1pbihpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMpIHx8IHJhZGl1cyA+IE1hdGgubWF4KGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qgc3RhcnRBbmdsZSA9IG5vcm1hbGl6ZUFuZ2xlMTgwKHNlY3Rvci5zdGFydEFuZ2xlKTtcbiAgY29uc3QgZW5kQW5nbGUgPSBub3JtYWxpemVBbmdsZTE4MChzZWN0b3IuZW5kQW5nbGUpO1xuICBjb25zdCBhbmdsZTIgPSBNYXRoLmF0YW4yKHksIHgpO1xuICByZXR1cm4gc3RhcnRBbmdsZSA8IGVuZEFuZ2xlID8gYW5nbGUyIDw9IGVuZEFuZ2xlICYmIGFuZ2xlMiA+PSBzdGFydEFuZ2xlIDogYW5nbGUyIDw9IGVuZEFuZ2xlICYmIGFuZ2xlMiA+PSAtTWF0aC5QSSB8fCBhbmdsZTIgPj0gc3RhcnRBbmdsZSAmJiBhbmdsZTIgPD0gTWF0aC5QSTtcbn1cbmZ1bmN0aW9uIGxpbmVDb2xsaWRlc1NlY3RvcihsaW5lLCBzZWN0b3IpIHtcbiAgY29uc3QgeyBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzIH0gPSBzZWN0b3I7XG4gIGNvbnN0IG91dGVyU3RhcnQgPSB7IHg6IG91dGVyUmFkaXVzICogTWF0aC5jb3Moc3RhcnRBbmdsZSksIHk6IG91dGVyUmFkaXVzICogTWF0aC5zaW4oc3RhcnRBbmdsZSkgfTtcbiAgY29uc3Qgb3V0ZXJFbmQgPSB7IHg6IG91dGVyUmFkaXVzICogTWF0aC5jb3MoZW5kQW5nbGUpLCB5OiBvdXRlclJhZGl1cyAqIE1hdGguc2luKGVuZEFuZ2xlKSB9O1xuICBjb25zdCBpbm5lclN0YXJ0ID0gaW5uZXJSYWRpdXMgPT09IDAgPyB7IHg6IDAsIHk6IDAgfSA6IHsgeDogaW5uZXJSYWRpdXMgKiBNYXRoLmNvcyhzdGFydEFuZ2xlKSwgeTogaW5uZXJSYWRpdXMgKiBNYXRoLnNpbihzdGFydEFuZ2xlKSB9O1xuICBjb25zdCBpbm5lckVuZCA9IGlubmVyUmFkaXVzID09PSAwID8geyB4OiAwLCB5OiAwIH0gOiB7IHg6IGlubmVyUmFkaXVzICogTWF0aC5jb3MoZW5kQW5nbGUpLCB5OiBpbm5lclJhZGl1cyAqIE1hdGguc2luKGVuZEFuZ2xlKSB9O1xuICByZXR1cm4gc2VnbWVudEludGVyc2VjdGlvbihcbiAgICBsaW5lLnN0YXJ0LngsXG4gICAgbGluZS5zdGFydC55LFxuICAgIGxpbmUuZW5kLngsXG4gICAgbGluZS5lbmQueSxcbiAgICBvdXRlclN0YXJ0LngsXG4gICAgb3V0ZXJTdGFydC55LFxuICAgIGlubmVyU3RhcnQueCxcbiAgICBpbm5lclN0YXJ0LnlcbiAgKSB8fCBzZWdtZW50SW50ZXJzZWN0aW9uKFxuICAgIGxpbmUuc3RhcnQueCxcbiAgICBsaW5lLnN0YXJ0LnksXG4gICAgbGluZS5lbmQueCxcbiAgICBsaW5lLmVuZC55LFxuICAgIG91dGVyRW5kLngsXG4gICAgb3V0ZXJFbmQueSxcbiAgICBpbm5lckVuZC54LFxuICAgIGlubmVyRW5kLnlcbiAgKSB8fCBhcmNJbnRlcnNlY3Rpb25zKFxuICAgIDAsXG4gICAgMCxcbiAgICBvdXRlclJhZGl1cyxcbiAgICBzdGFydEFuZ2xlLFxuICAgIGVuZEFuZ2xlLFxuICAgIHRydWUsXG4gICAgbGluZS5zdGFydC54LFxuICAgIGxpbmUuc3RhcnQueSxcbiAgICBsaW5lLmVuZC54LFxuICAgIGxpbmUuZW5kLnlcbiAgKTtcbn1cbmZ1bmN0aW9uIGJveENvbGxpZGVzU2VjdG9yKGJveCwgc2VjdG9yKSB7XG4gIGNvbnN0IHRvcExlZnQgPSB7IHg6IGJveC54LCB5OiBib3gueSB9O1xuICBjb25zdCB0b3BSaWdodCA9IHsgeDogYm94LnggKyBib3gud2lkdGgsIHk6IGJveC55IH07XG4gIGNvbnN0IGJvdHRvbUxlZnQgPSB7IHg6IGJveC54LCB5OiBib3gueSArIGJveC5oZWlnaHQgfTtcbiAgY29uc3QgYm90dG9tUmlnaHQgPSB7IHg6IGJveC54ICsgYm94LndpZHRoLCB5OiBib3gueSArIGJveC5oZWlnaHQgfTtcbiAgcmV0dXJuIGxpbmVDb2xsaWRlc1NlY3Rvcih7IHN0YXJ0OiB0b3BMZWZ0LCBlbmQ6IHRvcFJpZ2h0IH0sIHNlY3RvcikgfHwgbGluZUNvbGxpZGVzU2VjdG9yKHsgc3RhcnQ6IGJvdHRvbUxlZnQsIGVuZDogYm90dG9tUmlnaHQgfSwgc2VjdG9yKTtcbn1cbmZ1bmN0aW9uIHJhZGlpU2NhbGluZ0ZhY3RvcihyLCBzd2VlcCwgYSwgYikge1xuICBpZiAoYSA9PT0gMCAmJiBiID09PSAwKVxuICAgIHJldHVybiAwO1xuICBjb25zdCBmczEgPSBNYXRoLmFzaW4oTWF0aC5hYnMoMSAqIGEpIC8gKHIgKyAxICogYSkpICsgTWF0aC5hc2luKE1hdGguYWJzKDEgKiBiKSAvIChyICsgMSAqIGIpKSAtIHN3ZWVwO1xuICBpZiAoZnMxIDwgMClcbiAgICByZXR1cm4gMTtcbiAgbGV0IHN0YXJ0MiA9IDA7XG4gIGxldCBlbmQyID0gMTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpICs9IDEpIHtcbiAgICBjb25zdCBzID0gKHN0YXJ0MiArIGVuZDIpIC8gMjtcbiAgICBjb25zdCBmcyA9IE1hdGguYXNpbihNYXRoLmFicyhzICogYSkgLyAociArIHMgKiBhKSkgKyBNYXRoLmFzaW4oTWF0aC5hYnMocyAqIGIpIC8gKHIgKyBzICogYikpIC0gc3dlZXA7XG4gICAgaWYgKGZzIDwgMCkge1xuICAgICAgc3RhcnQyID0gcztcbiAgICB9IGVsc2Uge1xuICAgICAgZW5kMiA9IHM7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdGFydDI7XG59XG52YXIgZGVsdGEzID0gMWUtNjtcbmZ1bmN0aW9uIGNsb2Nrd2lzZUFuZ2xlMihhbmdsZTIsIHJlbGF0aXZlVG9TdGFydEFuZ2xlKSB7XG4gIGlmIChhbmdsZUJldHdlZW4oYW5nbGUyLCByZWxhdGl2ZVRvU3RhcnRBbmdsZSkgPCBkZWx0YTMpIHtcbiAgICByZXR1cm4gcmVsYXRpdmVUb1N0YXJ0QW5nbGU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZUFuZ2xlMzYwKGFuZ2xlMiAtIHJlbGF0aXZlVG9TdGFydEFuZ2xlKSArIHJlbGF0aXZlVG9TdGFydEFuZ2xlO1xuICB9XG59XG5mdW5jdGlvbiBjbG9ja3dpc2VBbmdsZXMyKHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCByZWxhdGl2ZVRvU3RhcnRBbmdsZSA9IDApIHtcbiAgY29uc3QgZnVsbFBpZSA9IE1hdGguYWJzKGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSkgPj0gMiAqIE1hdGguUEk7XG4gIGNvbnN0IHN3ZWVwQW5nbGUgPSBmdWxsUGllID8gMiAqIE1hdGguUEkgOiBub3JtYWxpemVBbmdsZTM2MChlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpO1xuICBzdGFydEFuZ2xlID0gY2xvY2t3aXNlQW5nbGUyKHN0YXJ0QW5nbGUsIHJlbGF0aXZlVG9TdGFydEFuZ2xlKTtcbiAgZW5kQW5nbGUgPSBzdGFydEFuZ2xlICsgc3dlZXBBbmdsZTtcbiAgcmV0dXJuIHsgc3RhcnRBbmdsZSwgZW5kQW5nbGUgfTtcbn1cbmZ1bmN0aW9uIGFyY1JhZGlhbExpbmVJbnRlcnNlY3Rpb25BbmdsZShjeCwgY3ksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBjbGlwQW5nbGUpIHtcbiAgY29uc3Qgc2luQSA9IE1hdGguc2luKGNsaXBBbmdsZSk7XG4gIGNvbnN0IGNvc0EgPSBNYXRoLmNvcyhjbGlwQW5nbGUpO1xuICBjb25zdCBjID0gY3ggKiogMiArIGN5ICoqIDIgLSByICoqIDI7XG4gIGxldCBwMHggPSBOYU47XG4gIGxldCBwMHkgPSBOYU47XG4gIGxldCBwMXggPSBOYU47XG4gIGxldCBwMXkgPSBOYU47XG4gIGlmIChjb3NBID4gMC41KSB7XG4gICAgY29uc3QgdGFuQSA9IHNpbkEgLyBjb3NBO1xuICAgIGNvbnN0IGEgPSAxICsgdGFuQSAqKiAyO1xuICAgIGNvbnN0IGIgPSAtMiAqIChjeCArIGN5ICogdGFuQSk7XG4gICAgY29uc3QgZCA9IGIgKiogMiAtIDQgKiBhICogYztcbiAgICBpZiAoZCA8IDApXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeDAgPSAoLWIgKyBNYXRoLnNxcnQoZCkpIC8gKDIgKiBhKTtcbiAgICBjb25zdCB4MSA9ICgtYiAtIE1hdGguc3FydChkKSkgLyAoMiAqIGEpO1xuICAgIHAweCA9IHgwO1xuICAgIHAweSA9IHgwICogdGFuQTtcbiAgICBwMXggPSB4MTtcbiAgICBwMXkgPSB4MSAqIHRhbkE7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgY290QSA9IGNvc0EgLyBzaW5BO1xuICAgIGNvbnN0IGEgPSAxICsgY290QSAqKiAyO1xuICAgIGNvbnN0IGIgPSAtMiAqIChjeSArIGN4ICogY290QSk7XG4gICAgY29uc3QgZCA9IGIgKiogMiAtIDQgKiBhICogYztcbiAgICBpZiAoZCA8IDApXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeTAgPSAoLWIgKyBNYXRoLnNxcnQoZCkpIC8gKDIgKiBhKTtcbiAgICBjb25zdCB5MSA9ICgtYiAtIE1hdGguc3FydChkKSkgLyAoMiAqIGEpO1xuICAgIHAweCA9IHkwICogY290QTtcbiAgICBwMHkgPSB5MDtcbiAgICBwMXggPSB5MSAqIGNvdEE7XG4gICAgcDF5ID0geTE7XG4gIH1cbiAgY29uc3Qgbm9ybWFsaXNlZFggPSBjb3NBO1xuICBjb25zdCBub3JtYWxpc2VkWSA9IHNpbkE7XG4gIGNvbnN0IHAwRG90Tm9ybWFsaXplZCA9IHAweCAqIG5vcm1hbGlzZWRYICsgcDB5ICogbm9ybWFsaXNlZFk7XG4gIGNvbnN0IHAxRG90Tm9ybWFsaXplZCA9IHAxeCAqIG5vcm1hbGlzZWRYICsgcDF5ICogbm9ybWFsaXNlZFk7XG4gIGNvbnN0IGEwID0gcDBEb3ROb3JtYWxpemVkID4gMCA/IGNsb2Nrd2lzZUFuZ2xlMihNYXRoLmF0YW4yKHAweSAtIGN5LCBwMHggLSBjeCksIHN0YXJ0QW5nbGUpIDogTmFOO1xuICBjb25zdCBhMSA9IHAxRG90Tm9ybWFsaXplZCA+IDAgPyBjbG9ja3dpc2VBbmdsZTIoTWF0aC5hdGFuMihwMXkgLSBjeSwgcDF4IC0gY3gpLCBzdGFydEFuZ2xlKSA6IE5hTjtcbiAgaWYgKGEwID49IHN0YXJ0QW5nbGUgJiYgYTAgPD0gZW5kQW5nbGUpIHtcbiAgICByZXR1cm4gYTA7XG4gIH0gZWxzZSBpZiAoYTEgPj0gc3RhcnRBbmdsZSAmJiBhMSA8PSBlbmRBbmdsZSkge1xuICAgIHJldHVybiBhMTtcbiAgfVxufVxuZnVuY3Rpb24gYXJjQ2lyY2xlSW50ZXJzZWN0aW9uQW5nbGUoY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgY2lyY2xlUikge1xuICBjb25zdCBkID0gTWF0aC5oeXBvdChjeCwgY3kpO1xuICBjb25zdCBkMSA9IChkICoqIDIgLSByICoqIDIgKyBjaXJjbGVSICoqIDIpIC8gKDIgKiBkKTtcbiAgY29uc3QgZDIgPSBkIC0gZDE7XG4gIGNvbnN0IHRoZXRhID0gTWF0aC5hdGFuMihjeSwgY3gpO1xuICBjb25zdCBkZWx0YVRoZXRhID0gTWF0aC5hY29zKC1kMiAvIHIpO1xuICBjb25zdCBhMCA9IGNsb2Nrd2lzZUFuZ2xlMih0aGV0YSArIGRlbHRhVGhldGEsIHN0YXJ0QW5nbGUpO1xuICBjb25zdCBhMSA9IGNsb2Nrd2lzZUFuZ2xlMih0aGV0YSAtIGRlbHRhVGhldGEsIHN0YXJ0QW5nbGUpO1xuICBpZiAoYTAgPj0gc3RhcnRBbmdsZSAmJiBhMCA8PSBlbmRBbmdsZSkge1xuICAgIHJldHVybiBhMDtcbiAgfSBlbHNlIGlmIChhMSA+PSBzdGFydEFuZ2xlICYmIGExIDw9IGVuZEFuZ2xlKSB7XG4gICAgcmV0dXJuIGExO1xuICB9XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL3NoYXBlL3NlY3Rvci50c1xudmFyIEFyYyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY3gsIGN5LCByLCBhMCwgYTEpIHtcbiAgICB0aGlzLmN4ID0gY3g7XG4gICAgdGhpcy5jeSA9IGN5O1xuICAgIHRoaXMuciA9IHI7XG4gICAgdGhpcy5hMCA9IGEwO1xuICAgIHRoaXMuYTEgPSBhMTtcbiAgICBpZiAodGhpcy5hMCA+PSB0aGlzLmExKSB7XG4gICAgICB0aGlzLmEwID0gTmFOO1xuICAgICAgdGhpcy5hMSA9IE5hTjtcbiAgICB9XG4gIH1cbiAgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKHRoaXMuYTApICYmIE51bWJlci5pc0Zpbml0ZSh0aGlzLmExKTtcbiAgfVxuICBwb2ludEF0KGEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogdGhpcy5jeCArIHRoaXMuciAqIE1hdGguY29zKGEpLFxuICAgICAgeTogdGhpcy5jeSArIHRoaXMuciAqIE1hdGguc2luKGEpXG4gICAgfTtcbiAgfVxuICBjbGlwU3RhcnQoYSkge1xuICAgIGlmIChhID09IG51bGwgfHwgIXRoaXMuaXNWYWxpZCgpIHx8IGEgPCB0aGlzLmEwKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuYTAgPSBhO1xuICAgIGlmIChOdW1iZXIuaXNOYU4oYSkgfHwgdGhpcy5hMCA+PSB0aGlzLmExKSB7XG4gICAgICB0aGlzLmEwID0gTmFOO1xuICAgICAgdGhpcy5hMSA9IE5hTjtcbiAgICB9XG4gIH1cbiAgY2xpcEVuZChhKSB7XG4gICAgaWYgKGEgPT0gbnVsbCB8fCAhdGhpcy5pc1ZhbGlkKCkgfHwgYSA+IHRoaXMuYTEpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5hMSA9IGE7XG4gICAgaWYgKE51bWJlci5pc05hTihhKSB8fCB0aGlzLmEwID49IHRoaXMuYTEpIHtcbiAgICAgIHRoaXMuYTAgPSBOYU47XG4gICAgICB0aGlzLmExID0gTmFOO1xuICAgIH1cbiAgfVxufTtcbnZhciBTZWN0b3IgPSBjbGFzcyBleHRlbmRzIFBhdGgge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuY2VudGVyWCA9IDA7XG4gICAgdGhpcy5jZW50ZXJZID0gMDtcbiAgICB0aGlzLmlubmVyUmFkaXVzID0gMTA7XG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IDIwO1xuICAgIHRoaXMuc3RhcnRBbmdsZSA9IDA7XG4gICAgdGhpcy5lbmRBbmdsZSA9IE1hdGguUEkgKiAyO1xuICAgIHRoaXMuY2xpcFNlY3RvciA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbmNlbnRyaWNFZGdlSW5zZXQgPSAwO1xuICAgIHRoaXMucmFkaWFsRWRnZUluc2V0ID0gMDtcbiAgICB0aGlzLnN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXMgPSAwO1xuICAgIHRoaXMuZW5kT3V0ZXJDb3JuZXJSYWRpdXMgPSAwO1xuICAgIHRoaXMuc3RhcnRJbm5lckNvcm5lclJhZGl1cyA9IDA7XG4gICAgdGhpcy5lbmRJbm5lckNvcm5lclJhZGl1cyA9IDA7XG4gIH1cbiAgc2V0IGluc2V0KHZhbHVlKSB7XG4gICAgdGhpcy5jb25jZW50cmljRWRnZUluc2V0ID0gdmFsdWU7XG4gICAgdGhpcy5yYWRpYWxFZGdlSW5zZXQgPSB2YWx1ZTtcbiAgfVxuICBzZXQgY29ybmVyUmFkaXVzKHZhbHVlKSB7XG4gICAgdGhpcy5zdGFydE91dGVyQ29ybmVyUmFkaXVzID0gdmFsdWU7XG4gICAgdGhpcy5lbmRPdXRlckNvcm5lclJhZGl1cyA9IHZhbHVlO1xuICAgIHRoaXMuc3RhcnRJbm5lckNvcm5lclJhZGl1cyA9IHZhbHVlO1xuICAgIHRoaXMuZW5kSW5uZXJDb3JuZXJSYWRpdXMgPSB2YWx1ZTtcbiAgfVxuICBjb21wdXRlQkJveCgpIHtcbiAgICByZXR1cm4gc2VjdG9yQm94KHRoaXMpLnRyYW5zbGF0ZSh0aGlzLmNlbnRlclgsIHRoaXMuY2VudGVyWSk7XG4gIH1cbiAgbm9ybWFsaXplZFJhZGlpKCkge1xuICAgIGNvbnN0IHsgY29uY2VudHJpY0VkZ2VJbnNldCB9ID0gdGhpcztcbiAgICBsZXQgeyBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMgfSA9IHRoaXM7XG4gICAgaW5uZXJSYWRpdXMgPSBpbm5lclJhZGl1cyA+IDAgPyBpbm5lclJhZGl1cyArIGNvbmNlbnRyaWNFZGdlSW5zZXQgOiAwO1xuICAgIG91dGVyUmFkaXVzID0gTWF0aC5tYXgob3V0ZXJSYWRpdXMgLSBjb25jZW50cmljRWRnZUluc2V0LCAwKTtcbiAgICByZXR1cm4geyBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMgfTtcbiAgfVxuICBub3JtYWxpemVkQ2xpcFNlY3RvcigpIHtcbiAgICBjb25zdCB7IGNsaXBTZWN0b3IgfSA9IHRoaXM7XG4gICAgaWYgKGNsaXBTZWN0b3IgPT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IHN0YXJ0QW5nbGUsIGVuZEFuZ2xlIH0gPSBjbG9ja3dpc2VBbmdsZXMyKHRoaXMuc3RhcnRBbmdsZSwgdGhpcy5lbmRBbmdsZSk7XG4gICAgY29uc3QgeyBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMgfSA9IHRoaXMubm9ybWFsaXplZFJhZGlpKCk7XG4gICAgY29uc3QgY2xpcEFuZ2xlcyA9IGNsb2Nrd2lzZUFuZ2xlczIoY2xpcFNlY3Rvci5zdGFydEFuZ2xlLCBjbGlwU2VjdG9yLmVuZEFuZ2xlLCBzdGFydEFuZ2xlKTtcbiAgICByZXR1cm4gbmV3IFNlY3RvckJveChcbiAgICAgIE1hdGgubWF4KHN0YXJ0QW5nbGUsIGNsaXBBbmdsZXMuc3RhcnRBbmdsZSksXG4gICAgICBNYXRoLm1pbihlbmRBbmdsZSwgY2xpcEFuZ2xlcy5lbmRBbmdsZSksXG4gICAgICBNYXRoLm1heChpbm5lclJhZGl1cywgY2xpcFNlY3Rvci5pbm5lclJhZGl1cyksXG4gICAgICBNYXRoLm1pbihvdXRlclJhZGl1cywgY2xpcFNlY3Rvci5vdXRlclJhZGl1cylcbiAgICApO1xuICB9XG4gIGdldEFuZ2xlT2Zmc2V0KHJhZGl1cykge1xuICAgIHJldHVybiByYWRpdXMgPiAwID8gdGhpcy5yYWRpYWxFZGdlSW5zZXQgLyByYWRpdXMgOiAwO1xuICB9XG4gIGFyYyhyLCBhbmdsZVN3ZWVwLCBhMCwgYTEsIG91dGVyQXJjLCBpbm5lckFyYywgc3RhcnQyLCBpbm5lcikge1xuICAgIGlmIChyIDw9IDApXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBzdGFydEFuZ2xlLCBlbmRBbmdsZSB9ID0gY2xvY2t3aXNlQW5nbGVzMih0aGlzLnN0YXJ0QW5nbGUsIHRoaXMuZW5kQW5nbGUpO1xuICAgIGNvbnN0IHsgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzIH0gPSB0aGlzLm5vcm1hbGl6ZWRSYWRpaSgpO1xuICAgIGNvbnN0IGNsaXBTZWN0b3IgPSB0aGlzLm5vcm1hbGl6ZWRDbGlwU2VjdG9yKCk7XG4gICAgaWYgKGlubmVyICYmIGlubmVyUmFkaXVzIDw9IDApXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgYW5nbGVPZmZzZXQgPSBpbm5lciA/IHRoaXMuZ2V0QW5nbGVPZmZzZXQoaW5uZXJSYWRpdXMgKyByKSA6IHRoaXMuZ2V0QW5nbGVPZmZzZXQob3V0ZXJSYWRpdXMgLSByKTtcbiAgICBjb25zdCBhbmdsZTIgPSBzdGFydDIgPyBzdGFydEFuZ2xlICsgYW5nbGVPZmZzZXQgKyBhbmdsZVN3ZWVwIDogZW5kQW5nbGUgLSBhbmdsZU9mZnNldCAtIGFuZ2xlU3dlZXA7XG4gICAgY29uc3QgcmFkaXVzID0gaW5uZXIgPyBpbm5lclJhZGl1cyArIHIgOiBvdXRlclJhZGl1cyAtIHI7XG4gICAgY29uc3QgY3ggPSByYWRpdXMgKiBNYXRoLmNvcyhhbmdsZTIpO1xuICAgIGNvbnN0IGN5ID0gcmFkaXVzICogTWF0aC5zaW4oYW5nbGUyKTtcbiAgICBpZiAoY2xpcFNlY3RvciAhPSBudWxsKSB7XG4gICAgICBjb25zdCBkZWx0YTQgPSAxZS02O1xuICAgICAgaWYgKCFzdGFydDIgJiYgIShhbmdsZTIgPj0gc3RhcnRBbmdsZSAtIGRlbHRhNCAmJiBhbmdsZTIgPD0gY2xpcFNlY3Rvci5lbmRBbmdsZSAtIGRlbHRhNCkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmIChzdGFydDIgJiYgIShhbmdsZTIgPj0gY2xpcFNlY3Rvci5zdGFydEFuZ2xlICsgZGVsdGE0ICYmIGFuZ2xlMiA8PSBlbmRBbmdsZSAtIGRlbHRhNCkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmIChpbm5lciAmJiByYWRpdXMgPCBjbGlwU2VjdG9yLmlubmVyUmFkaXVzIC0gZGVsdGE0KVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAoIWlubmVyICYmIHJhZGl1cyA+IGNsaXBTZWN0b3Iub3V0ZXJSYWRpdXMgKyBkZWx0YTQpXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYXJjID0gbmV3IEFyYyhjeCwgY3ksIHIsIGEwLCBhMSk7XG4gICAgaWYgKGNsaXBTZWN0b3IgIT0gbnVsbCkge1xuICAgICAgaWYgKGlubmVyKSB7XG4gICAgICAgIGFyYy5jbGlwU3RhcnQoYXJjUmFkaWFsTGluZUludGVyc2VjdGlvbkFuZ2xlKGN4LCBjeSwgciwgYTAsIGExLCBjbGlwU2VjdG9yLmVuZEFuZ2xlKSk7XG4gICAgICAgIGFyYy5jbGlwRW5kKGFyY1JhZGlhbExpbmVJbnRlcnNlY3Rpb25BbmdsZShjeCwgY3ksIHIsIGEwLCBhMSwgY2xpcFNlY3Rvci5zdGFydEFuZ2xlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcmMuY2xpcFN0YXJ0KGFyY1JhZGlhbExpbmVJbnRlcnNlY3Rpb25BbmdsZShjeCwgY3ksIHIsIGEwLCBhMSwgY2xpcFNlY3Rvci5zdGFydEFuZ2xlKSk7XG4gICAgICAgIGFyYy5jbGlwRW5kKGFyY1JhZGlhbExpbmVJbnRlcnNlY3Rpb25BbmdsZShjeCwgY3ksIHIsIGEwLCBhMSwgY2xpcFNlY3Rvci5lbmRBbmdsZSkpO1xuICAgICAgfVxuICAgICAgbGV0IGNpcmNsZUNsaXBTdGFydDtcbiAgICAgIGxldCBjaXJjbGVDbGlwRW5kO1xuICAgICAgaWYgKHN0YXJ0Mikge1xuICAgICAgICBjaXJjbGVDbGlwU3RhcnQgPSBhcmNDaXJjbGVJbnRlcnNlY3Rpb25BbmdsZShjeCwgY3ksIHIsIGEwLCBhMSwgY2xpcFNlY3Rvci5pbm5lclJhZGl1cyk7XG4gICAgICAgIGNpcmNsZUNsaXBFbmQgPSBhcmNDaXJjbGVJbnRlcnNlY3Rpb25BbmdsZShjeCwgY3ksIHIsIGEwLCBhMSwgY2xpcFNlY3Rvci5vdXRlclJhZGl1cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaXJjbGVDbGlwU3RhcnQgPSBhcmNDaXJjbGVJbnRlcnNlY3Rpb25BbmdsZShjeCwgY3ksIHIsIGEwLCBhMSwgY2xpcFNlY3Rvci5vdXRlclJhZGl1cyk7XG4gICAgICAgIGNpcmNsZUNsaXBFbmQgPSBhcmNDaXJjbGVJbnRlcnNlY3Rpb25BbmdsZShjeCwgY3ksIHIsIGEwLCBhMSwgY2xpcFNlY3Rvci5pbm5lclJhZGl1cyk7XG4gICAgICB9XG4gICAgICBhcmMuY2xpcFN0YXJ0KGNpcmNsZUNsaXBTdGFydCk7XG4gICAgICBhcmMuY2xpcEVuZChjaXJjbGVDbGlwRW5kKTtcbiAgICAgIGlmIChjaXJjbGVDbGlwU3RhcnQgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCB7IHg6IHgyLCB5OiB5MiB9ID0gYXJjLnBvaW50QXQoY2lyY2xlQ2xpcFN0YXJ0KTtcbiAgICAgICAgY29uc3QgdGhldGEyID0gY2xvY2t3aXNlQW5nbGUyKE1hdGguYXRhbjIoeTIsIHgyKSwgc3RhcnRBbmdsZSk7XG4gICAgICAgIGlmIChzdGFydDIpIHtcbiAgICAgICAgICBpbm5lckFyYz8uY2xpcFN0YXJ0KHRoZXRhMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ZXJBcmMuY2xpcEVuZCh0aGV0YTIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2lyY2xlQ2xpcEVuZCAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHsgeDogeDIsIHk6IHkyIH0gPSBhcmMucG9pbnRBdChjaXJjbGVDbGlwRW5kKTtcbiAgICAgICAgY29uc3QgdGhldGEyID0gY2xvY2t3aXNlQW5nbGUyKE1hdGguYXRhbjIoeTIsIHgyKSwgc3RhcnRBbmdsZSk7XG4gICAgICAgIGlmIChzdGFydDIpIHtcbiAgICAgICAgICBvdXRlckFyYy5jbGlwU3RhcnQodGhldGEyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbm5lckFyYz8uY2xpcEVuZCh0aGV0YTIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjbGlwU2VjdG9yICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHsgeDogeDIsIHk6IHkyIH0gPSBhcmMucG9pbnRBdCgoYXJjLmEwICsgYXJjLmExKSAvIDIpO1xuICAgICAgaWYgKCFpc1BvaW50SW5TZWN0b3IoeDIsIHkyLCBjbGlwU2VjdG9yKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IHgsIHkgfSA9IGFyYy5wb2ludEF0KHN0YXJ0MiA9PT0gaW5uZXIgPyBhcmMuYTAgOiBhcmMuYTEpO1xuICAgIGNvbnN0IHRoZXRhID0gY2xvY2t3aXNlQW5nbGUyKE1hdGguYXRhbjIoeSwgeCksIHN0YXJ0QW5nbGUpO1xuICAgIGNvbnN0IHJhZGlhbEFyYyA9IGlubmVyID8gaW5uZXJBcmMgOiBvdXRlckFyYztcbiAgICBpZiAoc3RhcnQyKSB7XG4gICAgICByYWRpYWxBcmM/LmNsaXBTdGFydCh0aGV0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhZGlhbEFyYz8uY2xpcEVuZCh0aGV0YSk7XG4gICAgfVxuICAgIHJldHVybiBhcmM7XG4gIH1cbiAgdXBkYXRlUGF0aCgpIHtcbiAgICBjb25zdCBkZWx0YTQgPSAxZS02O1xuICAgIGNvbnN0IHsgcGF0aCwgY2VudGVyWCwgY2VudGVyWSwgY29uY2VudHJpY0VkZ2VJbnNldCwgcmFkaWFsRWRnZUluc2V0IH0gPSB0aGlzO1xuICAgIGxldCB7IHN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXMsIGVuZE91dGVyQ29ybmVyUmFkaXVzLCBzdGFydElubmVyQ29ybmVyUmFkaXVzLCBlbmRJbm5lckNvcm5lclJhZGl1cyB9ID0gdGhpcztcbiAgICBjb25zdCB7IHN0YXJ0QW5nbGUsIGVuZEFuZ2xlIH0gPSBjbG9ja3dpc2VBbmdsZXMyKHRoaXMuc3RhcnRBbmdsZSwgdGhpcy5lbmRBbmdsZSk7XG4gICAgY29uc3QgeyBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMgfSA9IHRoaXMubm9ybWFsaXplZFJhZGlpKCk7XG4gICAgY29uc3QgY2xpcFNlY3RvciA9IHRoaXMubm9ybWFsaXplZENsaXBTZWN0b3IoKTtcbiAgICBjb25zdCBzd2VlcEFuZ2xlID0gZW5kQW5nbGUgLSBzdGFydEFuZ2xlO1xuICAgIGNvbnN0IGZ1bGxQaWUgPSBzd2VlcEFuZ2xlID49IDIgKiBNYXRoLlBJIC0gZGVsdGE0O1xuICAgIHBhdGguY2xlYXIoKTtcbiAgICBpZiAoaW5uZXJSYWRpdXMgPT09IDAgJiYgb3V0ZXJSYWRpdXMgPT09IDAgfHwgaW5uZXJSYWRpdXMgPiBvdXRlclJhZGl1cykge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoKGNsaXBTZWN0b3I/LnN0YXJ0QW5nbGUgPz8gc3RhcnRBbmdsZSkgPT09IChjbGlwU2VjdG9yPy5lbmRBbmdsZSA/PyBlbmRBbmdsZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKGZ1bGxQaWUgJiYgdGhpcy5jbGlwU2VjdG9yID09IG51bGwgJiYgc3RhcnRPdXRlckNvcm5lclJhZGl1cyA9PT0gMCAmJiBlbmRPdXRlckNvcm5lclJhZGl1cyA9PT0gMCAmJiBzdGFydElubmVyQ29ybmVyUmFkaXVzID09PSAwICYmIGVuZElubmVyQ29ybmVyUmFkaXVzID09PSAwKSB7XG4gICAgICBwYXRoLm1vdmVUbyhjZW50ZXJYICsgb3V0ZXJSYWRpdXMgKiBNYXRoLmNvcyhzdGFydEFuZ2xlKSwgY2VudGVyWSArIG91dGVyUmFkaXVzICogTWF0aC5zaW4oc3RhcnRBbmdsZSkpO1xuICAgICAgcGF0aC5hcmMoY2VudGVyWCwgY2VudGVyWSwgb3V0ZXJSYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKTtcbiAgICAgIGlmIChpbm5lclJhZGl1cyA+IGNvbmNlbnRyaWNFZGdlSW5zZXQpIHtcbiAgICAgICAgcGF0aC5tb3ZlVG8oY2VudGVyWCArIGlubmVyUmFkaXVzICogTWF0aC5jb3MoZW5kQW5nbGUpLCBjZW50ZXJZICsgaW5uZXJSYWRpdXMgKiBNYXRoLnNpbihlbmRBbmdsZSkpO1xuICAgICAgICBwYXRoLmFyYyhjZW50ZXJYLCBjZW50ZXJZLCBpbm5lclJhZGl1cywgZW5kQW5nbGUsIHN0YXJ0QW5nbGUsIHRydWUpO1xuICAgICAgfVxuICAgICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKHRoaXMuY2xpcFNlY3RvciA9PSBudWxsICYmIE1hdGguYWJzKGlubmVyUmFkaXVzIC0gb3V0ZXJSYWRpdXMpIDwgMWUtNikge1xuICAgICAgcGF0aC5hcmMoY2VudGVyWCwgY2VudGVyWSwgb3V0ZXJSYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBmYWxzZSk7XG4gICAgICBwYXRoLmFyYyhjZW50ZXJYLCBjZW50ZXJZLCBvdXRlclJhZGl1cywgZW5kQW5nbGUsIHN0YXJ0QW5nbGUsIHRydWUpO1xuICAgICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW5uZXJBbmdsZU9mZnNldCA9IHRoaXMuZ2V0QW5nbGVPZmZzZXQoaW5uZXJSYWRpdXMpO1xuICAgIGNvbnN0IG91dGVyQW5nbGVPZmZzZXQgPSB0aGlzLmdldEFuZ2xlT2Zmc2V0KG91dGVyUmFkaXVzKTtcbiAgICBjb25zdCBvdXRlckFuZ2xlRXhjZWVkZWQgPSBzd2VlcEFuZ2xlIDwgMiAqIG91dGVyQW5nbGVPZmZzZXQ7XG4gICAgaWYgKG91dGVyQW5nbGVFeGNlZWRlZClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBoYXNJbm5lclN3ZWVwID0gKGNsaXBTZWN0b3I/LmlubmVyUmFkaXVzID8/IGlubmVyUmFkaXVzKSA+IGNvbmNlbnRyaWNFZGdlSW5zZXQ7XG4gICAgY29uc3QgaW5uZXJBbmdsZUV4Y2VlZGVkID0gaW5uZXJSYWRpdXMgPCBjb25jZW50cmljRWRnZUluc2V0IHx8IHN3ZWVwQW5nbGUgPCAyICogaW5uZXJBbmdsZU9mZnNldDtcbiAgICBjb25zdCByYWRpYWxMZW5ndGggPSBvdXRlclJhZGl1cyAtIGlubmVyUmFkaXVzO1xuICAgIGNvbnN0IG1heFJhZGlhbExlbmd0aCA9IE1hdGgubWF4KFxuICAgICAgc3RhcnRPdXRlckNvcm5lclJhZGl1cyxcbiAgICAgIHN0YXJ0SW5uZXJDb3JuZXJSYWRpdXMsXG4gICAgICBlbmRPdXRlckNvcm5lclJhZGl1cyxcbiAgICAgIGVuZElubmVyQ29ybmVyUmFkaXVzXG4gICAgKTtcbiAgICBjb25zdCBpbml0aWFsU2NhbGluZ0ZhY3RvciA9IG1heFJhZGlhbExlbmd0aCA+IDAgPyBNYXRoLm1pbihyYWRpYWxMZW5ndGggLyBtYXhSYWRpYWxMZW5ndGgsIDEpIDogMTtcbiAgICBzdGFydE91dGVyQ29ybmVyUmFkaXVzICo9IGluaXRpYWxTY2FsaW5nRmFjdG9yO1xuICAgIGVuZE91dGVyQ29ybmVyUmFkaXVzICo9IGluaXRpYWxTY2FsaW5nRmFjdG9yO1xuICAgIHN0YXJ0SW5uZXJDb3JuZXJSYWRpdXMgKj0gaW5pdGlhbFNjYWxpbmdGYWN0b3I7XG4gICAgZW5kSW5uZXJDb3JuZXJSYWRpdXMgKj0gaW5pdGlhbFNjYWxpbmdGYWN0b3I7XG4gICAgY29uc3Qgb3V0ZXJTY2FsaW5nRmFjdG9yID0gcmFkaWlTY2FsaW5nRmFjdG9yKFxuICAgICAgb3V0ZXJSYWRpdXMsXG4gICAgICBzd2VlcEFuZ2xlIC0gMiAqIG91dGVyQW5nbGVPZmZzZXQsXG4gICAgICAtc3RhcnRPdXRlckNvcm5lclJhZGl1cyxcbiAgICAgIC1lbmRPdXRlckNvcm5lclJhZGl1c1xuICAgICk7XG4gICAgc3RhcnRPdXRlckNvcm5lclJhZGl1cyAqPSBvdXRlclNjYWxpbmdGYWN0b3I7XG4gICAgZW5kT3V0ZXJDb3JuZXJSYWRpdXMgKj0gb3V0ZXJTY2FsaW5nRmFjdG9yO1xuICAgIGlmICghaW5uZXJBbmdsZUV4Y2VlZGVkICYmIGhhc0lubmVyU3dlZXApIHtcbiAgICAgIGNvbnN0IGlubmVyU2NhbGluZ0ZhY3RvciA9IHJhZGlpU2NhbGluZ0ZhY3RvcihcbiAgICAgICAgaW5uZXJSYWRpdXMsXG4gICAgICAgIHN3ZWVwQW5nbGUgLSAyICogaW5uZXJBbmdsZU9mZnNldCxcbiAgICAgICAgc3RhcnRJbm5lckNvcm5lclJhZGl1cyxcbiAgICAgICAgZW5kSW5uZXJDb3JuZXJSYWRpdXNcbiAgICAgICk7XG4gICAgICBzdGFydElubmVyQ29ybmVyUmFkaXVzICo9IGlubmVyU2NhbGluZ0ZhY3RvcjtcbiAgICAgIGVuZElubmVyQ29ybmVyUmFkaXVzICo9IGlubmVyU2NhbGluZ0ZhY3RvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRJbm5lckNvcm5lclJhZGl1cyA9IDA7XG4gICAgICBlbmRJbm5lckNvcm5lclJhZGl1cyA9IDA7XG4gICAgfVxuICAgIGNvbnN0IG1heENvbWJpbmVkUmFkaWFsTGVuZ3RoID0gTWF0aC5tYXgoXG4gICAgICBzdGFydE91dGVyQ29ybmVyUmFkaXVzICsgc3RhcnRJbm5lckNvcm5lclJhZGl1cyxcbiAgICAgIGVuZE91dGVyQ29ybmVyUmFkaXVzICsgZW5kSW5uZXJDb3JuZXJSYWRpdXNcbiAgICApO1xuICAgIGNvbnN0IGVkZ2VzU2NhbGluZ0ZhY3RvciA9IG1heENvbWJpbmVkUmFkaWFsTGVuZ3RoID4gMCA/IE1hdGgubWluKHJhZGlhbExlbmd0aCAvIG1heENvbWJpbmVkUmFkaWFsTGVuZ3RoLCAxKSA6IDE7XG4gICAgc3RhcnRPdXRlckNvcm5lclJhZGl1cyAqPSBlZGdlc1NjYWxpbmdGYWN0b3I7XG4gICAgZW5kT3V0ZXJDb3JuZXJSYWRpdXMgKj0gZWRnZXNTY2FsaW5nRmFjdG9yO1xuICAgIHN0YXJ0SW5uZXJDb3JuZXJSYWRpdXMgKj0gZWRnZXNTY2FsaW5nRmFjdG9yO1xuICAgIGVuZElubmVyQ29ybmVyUmFkaXVzICo9IGVkZ2VzU2NhbGluZ0ZhY3RvcjtcbiAgICBsZXQgc3RhcnRPdXRlckNvcm5lclJhZGl1c0FuZ2xlU3dlZXAgPSAwO1xuICAgIGxldCBlbmRPdXRlckNvcm5lclJhZGl1c0FuZ2xlU3dlZXAgPSAwO1xuICAgIGNvbnN0IHN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXNTd2VlcCA9IHN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXMgLyAob3V0ZXJSYWRpdXMgLSBzdGFydE91dGVyQ29ybmVyUmFkaXVzKTtcbiAgICBjb25zdCBlbmRPdXRlckNvcm5lclJhZGl1c1N3ZWVwID0gZW5kT3V0ZXJDb3JuZXJSYWRpdXMgLyAob3V0ZXJSYWRpdXMgLSBlbmRPdXRlckNvcm5lclJhZGl1cyk7XG4gICAgaWYgKHN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXNTd2VlcCA+PSAwICYmIHN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXNTd2VlcCA8IDEgLSBkZWx0YTQpIHtcbiAgICAgIHN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXNBbmdsZVN3ZWVwID0gTWF0aC5hc2luKHN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXNTd2VlcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXNBbmdsZVN3ZWVwID0gc3dlZXBBbmdsZSAvIDI7XG4gICAgICBjb25zdCBtYXhTdGFydE91dGVyQ29ybmVyUmFkaXVzID0gb3V0ZXJSYWRpdXMgLyAoMSAvIE1hdGguc2luKHN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXNBbmdsZVN3ZWVwKSArIDEpO1xuICAgICAgc3RhcnRPdXRlckNvcm5lclJhZGl1cyA9IE1hdGgubWluKG1heFN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXMsIHN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXMpO1xuICAgIH1cbiAgICBpZiAoZW5kT3V0ZXJDb3JuZXJSYWRpdXNTd2VlcCA+PSAwICYmIGVuZE91dGVyQ29ybmVyUmFkaXVzU3dlZXAgPCAxIC0gZGVsdGE0KSB7XG4gICAgICBlbmRPdXRlckNvcm5lclJhZGl1c0FuZ2xlU3dlZXAgPSBNYXRoLmFzaW4oZW5kT3V0ZXJDb3JuZXJSYWRpdXNTd2VlcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVuZE91dGVyQ29ybmVyUmFkaXVzQW5nbGVTd2VlcCA9IHN3ZWVwQW5nbGUgLyAyO1xuICAgICAgY29uc3QgbWF4RW5kT3V0ZXJDb3JuZXJSYWRpdXMgPSBvdXRlclJhZGl1cyAvICgxIC8gTWF0aC5zaW4oZW5kT3V0ZXJDb3JuZXJSYWRpdXNBbmdsZVN3ZWVwKSArIDEpO1xuICAgICAgZW5kT3V0ZXJDb3JuZXJSYWRpdXMgPSBNYXRoLm1pbihtYXhFbmRPdXRlckNvcm5lclJhZGl1cywgZW5kT3V0ZXJDb3JuZXJSYWRpdXMpO1xuICAgIH1cbiAgICBjb25zdCBzdGFydElubmVyQ29ybmVyUmFkaXVzQW5nbGVTd2VlcCA9IE1hdGguYXNpbihcbiAgICAgIHN0YXJ0SW5uZXJDb3JuZXJSYWRpdXMgLyAoaW5uZXJSYWRpdXMgKyBzdGFydElubmVyQ29ybmVyUmFkaXVzKVxuICAgICk7XG4gICAgY29uc3QgZW5kSW5uZXJDb3JuZXJSYWRpdXNBbmdsZVN3ZWVwID0gTWF0aC5hc2luKGVuZElubmVyQ29ybmVyUmFkaXVzIC8gKGlubmVyUmFkaXVzICsgZW5kSW5uZXJDb3JuZXJSYWRpdXMpKTtcbiAgICBjb25zdCBvdXRlckFyY1JhZGl1cyA9IGNsaXBTZWN0b3I/Lm91dGVyUmFkaXVzID8/IG91dGVyUmFkaXVzO1xuICAgIGNvbnN0IG91dGVyQXJjUmFkaXVzT2Zmc2V0ID0gdGhpcy5nZXRBbmdsZU9mZnNldChvdXRlckFyY1JhZGl1cyk7XG4gICAgY29uc3Qgb3V0ZXJBcmMgPSBuZXcgQXJjKFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICBvdXRlckFyY1JhZGl1cyxcbiAgICAgIHN0YXJ0QW5nbGUgKyBvdXRlckFyY1JhZGl1c09mZnNldCxcbiAgICAgIGVuZEFuZ2xlIC0gb3V0ZXJBcmNSYWRpdXNPZmZzZXRcbiAgICApO1xuICAgIGNvbnN0IGlubmVyQXJjUmFkaXVzID0gY2xpcFNlY3Rvcj8uaW5uZXJSYWRpdXMgPz8gaW5uZXJSYWRpdXM7XG4gICAgY29uc3QgaW5uZXJBcmNSYWRpdXNPZmZzZXQgPSB0aGlzLmdldEFuZ2xlT2Zmc2V0KGlubmVyQXJjUmFkaXVzKTtcbiAgICBjb25zdCBpbm5lckFyYyA9IGhhc0lubmVyU3dlZXAgPyBuZXcgQXJjKDAsIDAsIGlubmVyQXJjUmFkaXVzLCBzdGFydEFuZ2xlICsgaW5uZXJBcmNSYWRpdXNPZmZzZXQsIGVuZEFuZ2xlIC0gaW5uZXJBcmNSYWRpdXNPZmZzZXQpIDogdm9pZCAwO1xuICAgIGlmIChjbGlwU2VjdG9yICE9IG51bGwpIHtcbiAgICAgIG91dGVyQXJjLmNsaXBTdGFydChjbGlwU2VjdG9yLnN0YXJ0QW5nbGUpO1xuICAgICAgb3V0ZXJBcmMuY2xpcEVuZChjbGlwU2VjdG9yLmVuZEFuZ2xlKTtcbiAgICAgIGlubmVyQXJjPy5jbGlwU3RhcnQoY2xpcFNlY3Rvci5zdGFydEFuZ2xlKTtcbiAgICAgIGlubmVyQXJjPy5jbGlwRW5kKGNsaXBTZWN0b3IuZW5kQW5nbGUpO1xuICAgIH1cbiAgICBjb25zdCBzdGFydE91dGVyQXJjID0gdGhpcy5hcmMoXG4gICAgICBzdGFydE91dGVyQ29ybmVyUmFkaXVzLFxuICAgICAgc3RhcnRPdXRlckNvcm5lclJhZGl1c0FuZ2xlU3dlZXAsXG4gICAgICBzdGFydEFuZ2xlIC0gTWF0aC5QSSAqIDAuNSxcbiAgICAgIHN0YXJ0QW5nbGUgKyBzdGFydE91dGVyQ29ybmVyUmFkaXVzQW5nbGVTd2VlcCxcbiAgICAgIG91dGVyQXJjLFxuICAgICAgaW5uZXJBcmMsXG4gICAgICB0cnVlLFxuICAgICAgZmFsc2VcbiAgICApO1xuICAgIGNvbnN0IGVuZE91dGVyQXJjID0gdGhpcy5hcmMoXG4gICAgICBlbmRPdXRlckNvcm5lclJhZGl1cyxcbiAgICAgIGVuZE91dGVyQ29ybmVyUmFkaXVzQW5nbGVTd2VlcCxcbiAgICAgIGVuZEFuZ2xlIC0gZW5kT3V0ZXJDb3JuZXJSYWRpdXNBbmdsZVN3ZWVwLFxuICAgICAgZW5kQW5nbGUgKyBNYXRoLlBJICogMC41LFxuICAgICAgb3V0ZXJBcmMsXG4gICAgICBpbm5lckFyYyxcbiAgICAgIGZhbHNlLFxuICAgICAgZmFsc2VcbiAgICApO1xuICAgIGNvbnN0IGVuZElubmVyQXJjID0gdGhpcy5hcmMoXG4gICAgICBlbmRJbm5lckNvcm5lclJhZGl1cyxcbiAgICAgIGVuZElubmVyQ29ybmVyUmFkaXVzQW5nbGVTd2VlcCxcbiAgICAgIGVuZEFuZ2xlICsgTWF0aC5QSSAqIDAuNSxcbiAgICAgIGVuZEFuZ2xlICsgTWF0aC5QSSAtIGVuZElubmVyQ29ybmVyUmFkaXVzQW5nbGVTd2VlcCxcbiAgICAgIG91dGVyQXJjLFxuICAgICAgaW5uZXJBcmMsXG4gICAgICBmYWxzZSxcbiAgICAgIHRydWVcbiAgICApO1xuICAgIGNvbnN0IHN0YXJ0SW5uZXJBcmMgPSB0aGlzLmFyYyhcbiAgICAgIHN0YXJ0SW5uZXJDb3JuZXJSYWRpdXMsXG4gICAgICBzdGFydElubmVyQ29ybmVyUmFkaXVzQW5nbGVTd2VlcCxcbiAgICAgIHN0YXJ0QW5nbGUgKyBNYXRoLlBJICsgc3RhcnRJbm5lckNvcm5lclJhZGl1c0FuZ2xlU3dlZXAsXG4gICAgICBzdGFydEFuZ2xlICsgTWF0aC5QSSAqIDEuNSxcbiAgICAgIG91dGVyQXJjLFxuICAgICAgaW5uZXJBcmMsXG4gICAgICB0cnVlLFxuICAgICAgdHJ1ZVxuICAgICk7XG4gICAgaWYgKGlubmVyQW5nbGVFeGNlZWRlZCkge1xuICAgICAgY29uc3QgeCA9IHN3ZWVwQW5nbGUgPCBNYXRoLlBJICogMC41ID8gcmFkaWFsRWRnZUluc2V0ICogKDEgKyBNYXRoLmNvcyhzd2VlcEFuZ2xlKSkgLyBNYXRoLnNpbihzd2VlcEFuZ2xlKSA6IE5hTjtcbiAgICAgIGxldCByO1xuICAgICAgaWYgKHggPiAwICYmIHggPCBvdXRlclJhZGl1cykge1xuICAgICAgICByID0gTWF0aC5tYXgoTWF0aC5oeXBvdChyYWRpYWxFZGdlSW5zZXQsIHgpLCBpbm5lclJhZGl1cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByID0gcmFkaWFsRWRnZUluc2V0O1xuICAgICAgfVxuICAgICAgciA9IE1hdGgubWF4KHIsIGlubmVyUmFkaXVzKTtcbiAgICAgIGNvbnN0IG1pZEFuZ2xlID0gc3RhcnRBbmdsZSArIHN3ZWVwQW5nbGUgKiAwLjU7XG4gICAgICBwYXRoLm1vdmVUbyhjZW50ZXJYICsgciAqIE1hdGguY29zKG1pZEFuZ2xlKSwgY2VudGVyWSArIHIgKiBNYXRoLnNpbihtaWRBbmdsZSkpO1xuICAgIH0gZWxzZSBpZiAoc3RhcnRJbm5lckFyYz8uaXNWYWxpZCgpID09PSB0cnVlIHx8IGlubmVyQXJjPy5pc1ZhbGlkKCkgPT09IHRydWUpIHtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbWlkQW5nbGUgPSBzdGFydEFuZ2xlICsgc3dlZXBBbmdsZSAvIDI7XG4gICAgICBjb25zdCBjeCA9IGlubmVyUmFkaXVzICogTWF0aC5jb3MobWlkQW5nbGUpO1xuICAgICAgY29uc3QgY3kgPSBpbm5lclJhZGl1cyAqIE1hdGguc2luKG1pZEFuZ2xlKTtcbiAgICAgIHBhdGgubW92ZVRvKGNlbnRlclggKyBjeCwgY2VudGVyWSArIGN5KTtcbiAgICB9XG4gICAgaWYgKHN0YXJ0T3V0ZXJBcmM/LmlzVmFsaWQoKSA9PT0gdHJ1ZSkge1xuICAgICAgY29uc3QgeyBjeCwgY3ksIHIsIGEwLCBhMSB9ID0gc3RhcnRPdXRlckFyYztcbiAgICAgIHBhdGguYXJjKGNlbnRlclggKyBjeCwgY2VudGVyWSArIGN5LCByLCBhMCwgYTEpO1xuICAgIH1cbiAgICBpZiAob3V0ZXJBcmMuaXNWYWxpZCgpKSB7XG4gICAgICBjb25zdCB7IHIsIGEwLCBhMSB9ID0gb3V0ZXJBcmM7XG4gICAgICBwYXRoLmFyYyhjZW50ZXJYLCBjZW50ZXJZLCByLCBhMCwgYTEpO1xuICAgIH1cbiAgICBpZiAoZW5kT3V0ZXJBcmM/LmlzVmFsaWQoKSA9PT0gdHJ1ZSkge1xuICAgICAgY29uc3QgeyBjeCwgY3ksIHIsIGEwLCBhMSB9ID0gZW5kT3V0ZXJBcmM7XG4gICAgICBwYXRoLmFyYyhjZW50ZXJYICsgY3gsIGNlbnRlclkgKyBjeSwgciwgYTAsIGExKTtcbiAgICB9XG4gICAgaWYgKCFpbm5lckFuZ2xlRXhjZWVkZWQpIHtcbiAgICAgIGlmIChlbmRJbm5lckFyYz8uaXNWYWxpZCgpID09PSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgY3gsIGN5LCByLCBhMCwgYTEgfSA9IGVuZElubmVyQXJjO1xuICAgICAgICBwYXRoLmFyYyhjZW50ZXJYICsgY3gsIGNlbnRlclkgKyBjeSwgciwgYTAsIGExKTtcbiAgICAgIH1cbiAgICAgIGlmIChpbm5lckFyYz8uaXNWYWxpZCgpID09PSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgciwgYTAsIGExIH0gPSBpbm5lckFyYztcbiAgICAgICAgcGF0aC5hcmMoY2VudGVyWCwgY2VudGVyWSwgciwgYTEsIGEwLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydElubmVyQXJjPy5pc1ZhbGlkKCkgPT09IHRydWUpIHtcbiAgICAgICAgY29uc3QgeyBjeCwgY3ksIHIsIGEwLCBhMSB9ID0gc3RhcnRJbm5lckFyYztcbiAgICAgICAgcGF0aC5hcmMoY2VudGVyWCArIGN4LCBjZW50ZXJZICsgY3ksIHIsIGEwLCBhMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gIH1cbiAgaXNQb2ludEluUGF0aCh4LCB5KSB7XG4gICAgY29uc3QgeyBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzIH0gPSB0aGlzLmNsaXBTZWN0b3IgPz8gdGhpcztcbiAgICByZXR1cm4gaXNQb2ludEluU2VjdG9yKHggLSB0aGlzLmNlbnRlclgsIHkgLSB0aGlzLmNlbnRlclksIHtcbiAgICAgIHN0YXJ0QW5nbGUsXG4gICAgICBlbmRBbmdsZSxcbiAgICAgIGlubmVyUmFkaXVzOiBNYXRoLm1pbihpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMpLFxuICAgICAgb3V0ZXJSYWRpdXM6IE1hdGgubWF4KGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cylcbiAgICB9KTtcbiAgfVxufTtcblNlY3Rvci5jbGFzc05hbWUgPSBcIlNlY3RvclwiO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFNlY3Rvci5wcm90b3R5cGUsIFwiY2VudGVyWFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBTZWN0b3IucHJvdG90eXBlLCBcImNlbnRlcllcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgU2VjdG9yLnByb3RvdHlwZSwgXCJpbm5lclJhZGl1c1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBTZWN0b3IucHJvdG90eXBlLCBcIm91dGVyUmFkaXVzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFNlY3Rvci5wcm90b3R5cGUsIFwic3RhcnRBbmdsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBTZWN0b3IucHJvdG90eXBlLCBcImVuZEFuZ2xlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFNlY3Rvci5wcm90b3R5cGUsIFwiY2xpcFNlY3RvclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBTZWN0b3IucHJvdG90eXBlLCBcImNvbmNlbnRyaWNFZGdlSW5zZXRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgU2VjdG9yLnByb3RvdHlwZSwgXCJyYWRpYWxFZGdlSW5zZXRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgU2VjdG9yLnByb3RvdHlwZSwgXCJzdGFydE91dGVyQ29ybmVyUmFkaXVzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFNlY3Rvci5wcm90b3R5cGUsIFwiZW5kT3V0ZXJDb3JuZXJSYWRpdXNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgU2VjdG9yLnByb3RvdHlwZSwgXCJzdGFydElubmVyQ29ybmVyUmFkaXVzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFNlY3Rvci5wcm90b3R5cGUsIFwiZW5kSW5uZXJDb3JuZXJSYWRpdXNcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3RoZW1lcy9kZWZhdWx0Q29sb3JzLnRzXG52YXIgREVGQVVMVF9GSUxMUyA9IHtcbiAgQkxVRTogXCIjNTA5MGRjXCIsXG4gIE9SQU5HRTogXCIjZmZhMDNhXCIsXG4gIEdSRUVOOiBcIiM0NTlkNTVcIixcbiAgQ1lBTjogXCIjMzRiZmUxXCIsXG4gIFlFTExPVzogXCIjZTFjYzAwXCIsXG4gIFZJT0xFVDogXCIjOTY2OWNiXCIsXG4gIEdSQVk6IFwiI2I1YjViNVwiLFxuICBNQUdFTlRBOiBcIiNiZDVhYTdcIixcbiAgQlJPV046IFwiIzhhNjIyNFwiLFxuICBSRUQ6IFwiI2VmNTQ1MlwiXG59O1xudmFyIERFRkFVTFRfU1RST0tFUyA9IHtcbiAgQkxVRTogXCIjMmI1Yzk1XCIsXG4gIE9SQU5HRTogXCIjY2M2ZjEwXCIsXG4gIEdSRUVOOiBcIiMxZTY1MmVcIixcbiAgQ1lBTjogXCIjMTg4NTllXCIsXG4gIFlFTExPVzogXCIjYTY5NDAwXCIsXG4gIFZJT0xFVDogXCIjNjAzYzg4XCIsXG4gIEdSQVk6IFwiIzU3NTc1N1wiLFxuICBNQUdFTlRBOiBcIiM3ZDJmNmRcIixcbiAgQlJPV046IFwiIzRmMzUwOFwiLFxuICBSRUQ6IFwiI2E4MjUyOVwiXG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvcG9sYXIvZG9udXRTZXJpZXNQcm9wZXJ0aWVzLnRzXG52YXIgRG9udXRUaXRsZSA9IGNsYXNzIGV4dGVuZHMgQ2FwdGlvbiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5zaG93SW5MZWdlbmQgPSBmYWxzZTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBEb251dFRpdGxlLnByb3RvdHlwZSwgXCJzaG93SW5MZWdlbmRcIiwgMik7XG52YXIgRG9udXRJbm5lckxhYmVsID0gY2xhc3MgZXh0ZW5kcyBMYWJlbCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5zcGFjaW5nID0gMjtcbiAgfVxuICBzZXQocHJvcGVydGllcywgX3Jlc2V0KSB7XG4gICAgcmV0dXJuIHN1cGVyLnNldChwcm9wZXJ0aWVzKTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORylcbl0sIERvbnV0SW5uZXJMYWJlbC5wcm90b3R5cGUsIFwidGV4dFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE5VTUJFUilcbl0sIERvbnV0SW5uZXJMYWJlbC5wcm90b3R5cGUsIFwic3BhY2luZ1wiLCAyKTtcbnZhciBEb251dElubmVyQ2lyY2xlID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5maWxsID0gXCJ0cmFuc3BhcmVudFwiO1xuICAgIHRoaXMuZmlsbE9wYWNpdHkgPSAxO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HKVxuXSwgRG9udXRJbm5lckNpcmNsZS5wcm90b3R5cGUsIFwiZmlsbFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPKVxuXSwgRG9udXRJbm5lckNpcmNsZS5wcm90b3R5cGUsIFwiZmlsbE9wYWNpdHlcIiwgMik7XG52YXIgRG9udXRTZXJpZXNDYWxsb3V0TGFiZWwgPSBjbGFzcyBleHRlbmRzIExhYmVsIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLm9mZnNldCA9IDM7XG4gICAgdGhpcy5taW5BbmdsZSA9IDA7XG4gICAgdGhpcy5taW5TcGFjaW5nID0gNDtcbiAgICB0aGlzLm1heENvbGxpc2lvbk9mZnNldCA9IDUwO1xuICAgIHRoaXMuYXZvaWRDb2xsaXNpb25zID0gdHJ1ZTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIERvbnV0U2VyaWVzQ2FsbG91dExhYmVsLnByb3RvdHlwZSwgXCJvZmZzZXRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShERUdSRUUpXG5dLCBEb251dFNlcmllc0NhbGxvdXRMYWJlbC5wcm90b3R5cGUsIFwibWluQW5nbGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBEb251dFNlcmllc0NhbGxvdXRMYWJlbC5wcm90b3R5cGUsIFwibWluU3BhY2luZ1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIERvbnV0U2VyaWVzQ2FsbG91dExhYmVsLnByb3RvdHlwZSwgXCJtYXhDb2xsaXNpb25PZmZzZXRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgRG9udXRTZXJpZXNDYWxsb3V0TGFiZWwucHJvdG90eXBlLCBcImF2b2lkQ29sbGlzaW9uc1wiLCAyKTtcbnZhciBEb251dFNlcmllc1NlY3RvckxhYmVsID0gY2xhc3MgZXh0ZW5kcyBMYWJlbCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5wb3NpdGlvbk9mZnNldCA9IDA7XG4gICAgdGhpcy5wb3NpdGlvblJhdGlvID0gMC41O1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTlVNQkVSKVxuXSwgRG9udXRTZXJpZXNTZWN0b3JMYWJlbC5wcm90b3R5cGUsIFwicG9zaXRpb25PZmZzZXRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTylcbl0sIERvbnV0U2VyaWVzU2VjdG9yTGFiZWwucHJvdG90eXBlLCBcInBvc2l0aW9uUmF0aW9cIiwgMik7XG52YXIgRG9udXRTZXJpZXNDYWxsb3V0TGluZSA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMubGVuZ3RoID0gMTA7XG4gICAgdGhpcy5zdHJva2VXaWR0aCA9IDE7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkdfQVJSQVksIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIERvbnV0U2VyaWVzQ2FsbG91dExpbmUucHJvdG90eXBlLCBcImNvbG9yc1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIERvbnV0U2VyaWVzQ2FsbG91dExpbmUucHJvdG90eXBlLCBcImxlbmd0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIERvbnV0U2VyaWVzQ2FsbG91dExpbmUucHJvdG90eXBlLCBcInN0cm9rZVdpZHRoXCIsIDIpO1xudmFyIERvbnV0U2VyaWVzUHJvcGVydGllcyA9IGNsYXNzIGV4dGVuZHMgU2VyaWVzUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5maWxscyA9IE9iamVjdC52YWx1ZXMoREVGQVVMVF9GSUxMUyk7XG4gICAgdGhpcy5zdHJva2VzID0gT2JqZWN0LnZhbHVlcyhERUZBVUxUX1NUUk9LRVMpO1xuICAgIHRoaXMuZmlsbE9wYWNpdHkgPSAxO1xuICAgIHRoaXMuc3Ryb2tlT3BhY2l0eSA9IDE7XG4gICAgdGhpcy5saW5lRGFzaCA9IFswXTtcbiAgICB0aGlzLmxpbmVEYXNoT2Zmc2V0ID0gMDtcbiAgICB0aGlzLmNvcm5lclJhZGl1cyA9IDA7XG4gICAgdGhpcy5yb3RhdGlvbiA9IDA7XG4gICAgdGhpcy5vdXRlclJhZGl1c09mZnNldCA9IDA7XG4gICAgdGhpcy5vdXRlclJhZGl1c1JhdGlvID0gMTtcbiAgICB0aGlzLnN0cm9rZVdpZHRoID0gMTtcbiAgICB0aGlzLnNlY3RvclNwYWNpbmcgPSAwO1xuICAgIHRoaXMuaW5uZXJMYWJlbHMgPSBuZXcgUHJvcGVydGllc0FycmF5KERvbnV0SW5uZXJMYWJlbCk7XG4gICAgdGhpcy50aXRsZSA9IG5ldyBEb251dFRpdGxlKCk7XG4gICAgdGhpcy5pbm5lckNpcmNsZSA9IG5ldyBEb251dElubmVyQ2lyY2xlKCk7XG4gICAgdGhpcy5zaGFkb3cgPSBuZXcgRHJvcFNoYWRvdygpO1xuICAgIHRoaXMuY2FsbG91dExhYmVsID0gbmV3IERvbnV0U2VyaWVzQ2FsbG91dExhYmVsKCk7XG4gICAgdGhpcy5zZWN0b3JMYWJlbCA9IG5ldyBEb251dFNlcmllc1NlY3RvckxhYmVsKCk7XG4gICAgdGhpcy5jYWxsb3V0TGluZSA9IG5ldyBEb251dFNlcmllc0NhbGxvdXRMaW5lKCk7XG4gICAgdGhpcy50b29sdGlwID0gbmV3IFNlcmllc1Rvb2x0aXAoKTtcbiAgfVxuICBpc1ZhbGlkKCkge1xuICAgIGNvbnN0IHN1cGVySXNWYWxpZCA9IHN1cGVyLmlzVmFsaWQoKTtcbiAgICBpZiAodGhpcy5pbm5lclJhZGl1c1JhdGlvID09IG51bGwgJiYgdGhpcy5pbm5lclJhZGl1c09mZnNldCA9PSBudWxsKSB7XG4gICAgICBMb2dnZXIud2Fybk9uY2UoXG4gICAgICAgIFwiRWl0aGVyIGFuIFtpbm5lclJhZGl1c1JhdGlvXSBvciBhbiBbaW5uZXJSYWRpdXNPZmZzZXRdIG11c3QgYmUgc2V0IHRvIHJlbmRlciBhIGRvbnV0IHNlcmllcy5cIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVySXNWYWxpZDtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORylcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiYW5nbGVLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiYW5nbGVOYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImFuZ2xlRmlsdGVyS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInJhZGl1c0tleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJyYWRpdXNOYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInJhZGl1c01pblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJyYWRpdXNNYXhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiY2FsbG91dExhYmVsS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNhbGxvdXRMYWJlbE5hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic2VjdG9yTGFiZWxLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic2VjdG9yTGFiZWxOYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImxlZ2VuZEl0ZW1LZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkdfQVJSQVkpXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImZpbGxzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HX0FSUkFZKVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdHJva2VzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8pXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImZpbGxPcGFjaXR5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8pXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0cm9rZU9wYWNpdHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShMSU5FX0RBU0gpXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImxpbmVEYXNoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJsaW5lRGFzaE9mZnNldFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiY29ybmVyUmFkaXVzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoRlVOQ1RJT04sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiaXRlbVN0eWxlclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKERFR1JFRSlcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwicm90YXRpb25cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShOVU1CRVIpXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcIm91dGVyUmFkaXVzT2Zmc2V0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8pXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcIm91dGVyUmFkaXVzUmF0aW9cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShOVU1CRVIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiaW5uZXJSYWRpdXNPZmZzZXRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJpbm5lclJhZGl1c1JhdGlvXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdHJva2VXaWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE5VTUJFUilcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic2VjdG9yU3BhY2luZ1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVF9BUlJBWSlcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiaW5uZXJMYWJlbHNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInRpdGxlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJpbm5lckNpcmNsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic2hhZG93XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjYWxsb3V0TGFiZWxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInNlY3RvckxhYmVsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjYWxsb3V0TGluZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwidG9vbHRpcFwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL3BvbGFyL3BpZVV0aWwudHNcbmZ1bmN0aW9uIHByZXBhcmVQaWVTZXJpZXNBbmltYXRpb25GdW5jdGlvbnMoaW5pdGlhbExvYWQsIHJvdGF0aW9uRGVncmVlcywgc2NhbGVGbiwgb2xkU2NhbGVGbikge1xuICBjb25zdCBzY2FsZTIgPSBbc2NhbGVGbi5jb252ZXJ0KDApLCBzY2FsZUZuLmNvbnZlcnQoMSldO1xuICBjb25zdCBvbGRTY2FsZSA9IFtvbGRTY2FsZUZuLmNvbnZlcnQoMCksIG9sZFNjYWxlRm4uY29udmVydCgxKV07XG4gIGNvbnN0IHJvdGF0aW9uID0gTWF0aC5QSSAvIC0yICsgdG9SYWRpYW5zKHJvdGF0aW9uRGVncmVlcyk7XG4gIGNvbnN0IHBoYXNlID0gaW5pdGlhbExvYWQgPyBcImluaXRpYWxcIiA6IFwidXBkYXRlXCI7XG4gIGNvbnN0IHNjYWxlVG9OZXdSYWRpdXMgPSAoeyByYWRpdXMgfSkgPT4ge1xuICAgIHJldHVybiB7IGlubmVyUmFkaXVzOiBzY2FsZTJbMF0sIG91dGVyUmFkaXVzOiBzY2FsZTJbMF0gKyAoc2NhbGUyWzFdIC0gc2NhbGUyWzBdKSAqIHJhZGl1cyB9O1xuICB9O1xuICBjb25zdCBzY2FsZVRvT2xkUmFkaXVzID0gKHsgcmFkaXVzIH0pID0+IHtcbiAgICByZXR1cm4geyBpbm5lclJhZGl1czogb2xkU2NhbGVbMF0sIG91dGVyUmFkaXVzOiBvbGRTY2FsZVswXSArIChvbGRTY2FsZVsxXSAtIG9sZFNjYWxlWzBdKSAqIHJhZGl1cyB9O1xuICB9O1xuICBjb25zdCBmcm9tRm4gPSAoc2VjdCwgZGF0dW0sIHN0YXR1cywgeyBwcmV2RnJvbVByb3BzIH0pID0+IHtcbiAgICBsZXQgeyBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzIH0gPSBzZWN0O1xuICAgIGxldCB7IGZpbGwsIHN0cm9rZSB9ID0gZGF0dW0uc2VjdG9yRm9ybWF0O1xuICAgIGlmIChzdGF0dXMgPT09IFwidW5rbm93blwiIHx8IHN0YXR1cyA9PT0gXCJhZGRlZFwiICYmICFwcmV2RnJvbVByb3BzKSB7XG4gICAgICBzdGFydEFuZ2xlID0gcm90YXRpb247XG4gICAgICBlbmRBbmdsZSA9IHJvdGF0aW9uO1xuICAgICAgaW5uZXJSYWRpdXMgPSBkYXR1bS5pbm5lclJhZGl1cztcbiAgICAgIG91dGVyUmFkaXVzID0gZGF0dW0ub3V0ZXJSYWRpdXM7XG4gICAgfSBlbHNlIGlmIChzdGF0dXMgPT09IFwiYWRkZWRcIiAmJiBwcmV2RnJvbVByb3BzKSB7XG4gICAgICBzdGFydEFuZ2xlID0gcHJldkZyb21Qcm9wcy5lbmRBbmdsZSA/PyByb3RhdGlvbjtcbiAgICAgIGVuZEFuZ2xlID0gcHJldkZyb21Qcm9wcy5lbmRBbmdsZSA/PyByb3RhdGlvbjtcbiAgICAgIGlubmVyUmFkaXVzID0gcHJldkZyb21Qcm9wcy5pbm5lclJhZGl1cyA/PyBkYXR1bS5pbm5lclJhZGl1cztcbiAgICAgIG91dGVyUmFkaXVzID0gcHJldkZyb21Qcm9wcy5vdXRlclJhZGl1cyA/PyBkYXR1bS5vdXRlclJhZGl1cztcbiAgICB9XG4gICAgaWYgKHN0YXR1cyA9PT0gXCJhZGRlZFwiICYmICFpbml0aWFsTG9hZCkge1xuICAgICAgY29uc3QgcmFkaWkgPSBzY2FsZVRvT2xkUmFkaXVzKGRhdHVtKTtcbiAgICAgIGlubmVyUmFkaXVzID0gcmFkaWkuaW5uZXJSYWRpdXM7XG4gICAgICBvdXRlclJhZGl1cyA9IHJhZGlpLm91dGVyUmFkaXVzO1xuICAgIH1cbiAgICBpZiAoc3RhdHVzID09PSBcInVwZGF0ZWRcIikge1xuICAgICAgZmlsbCA9IHNlY3QuZmlsbCA/PyBmaWxsO1xuICAgICAgc3Ryb2tlID0gc2VjdC5zdHJva2UgPz8gc3Ryb2tlO1xuICAgIH1cbiAgICByZXR1cm4geyBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCBmaWxsLCBzdHJva2UsIHBoYXNlIH07XG4gIH07XG4gIGNvbnN0IHRvRm4gPSAoX3NlY3QsIGRhdHVtLCBzdGF0dXMsIHsgcHJldkxpdmUgfSkgPT4ge1xuICAgIGxldCB7IHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMgfSA9IGRhdHVtO1xuICAgIGNvbnN0IHsgc3Ryb2tlLCBmaWxsIH0gPSBkYXR1bS5zZWN0b3JGb3JtYXQ7XG4gICAgaWYgKHN0YXR1cyA9PT0gXCJyZW1vdmVkXCIgJiYgcHJldkxpdmUpIHtcbiAgICAgIHN0YXJ0QW5nbGUgPSBwcmV2TGl2ZS5kYXR1bT8uZW5kQW5nbGU7XG4gICAgICBlbmRBbmdsZSA9IHByZXZMaXZlLmRhdHVtPy5lbmRBbmdsZTtcbiAgICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gXCJyZW1vdmVkXCIgJiYgIXByZXZMaXZlKSB7XG4gICAgICBzdGFydEFuZ2xlID0gcm90YXRpb247XG4gICAgICBlbmRBbmdsZSA9IHJvdGF0aW9uO1xuICAgIH1cbiAgICBpZiAoc3RhdHVzID09PSBcInJlbW92ZWRcIikge1xuICAgICAgY29uc3QgcmFkaWkgPSBzY2FsZVRvTmV3UmFkaXVzKGRhdHVtKTtcbiAgICAgIGlubmVyUmFkaXVzID0gcmFkaWkuaW5uZXJSYWRpdXM7XG4gICAgICBvdXRlclJhZGl1cyA9IHJhZGlpLm91dGVyUmFkaXVzO1xuICAgIH1cbiAgICByZXR1cm4geyBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgb3V0ZXJSYWRpdXMsIGlubmVyUmFkaXVzLCBzdHJva2UsIGZpbGwgfTtcbiAgfTtcbiAgY29uc3QgaW5uZXJDaXJjbGVGcm9tRm4gPSAobm9kZSwgXykgPT4ge1xuICAgIHJldHVybiB7IHNpemU6IG5vZGUucHJldmlvdXNEYXR1bT8ucmFkaXVzID8/IG5vZGUuc2l6ZSA/PyAwLCBwaGFzZSB9O1xuICB9O1xuICBjb25zdCBpbm5lckNpcmNsZVRvRm4gPSAoXywgZGF0dW0pID0+IHtcbiAgICByZXR1cm4geyBzaXplOiBkYXR1bS5yYWRpdXMgPz8gMCB9O1xuICB9O1xuICByZXR1cm4geyBub2RlczogeyB0b0ZuLCBmcm9tRm4gfSwgaW5uZXJDaXJjbGU6IHsgZnJvbUZuOiBpbm5lckNpcmNsZUZyb21GbiwgdG9GbjogaW5uZXJDaXJjbGVUb0ZuIH0gfTtcbn1cbmZ1bmN0aW9uIHJlc2V0UGllU2VsZWN0aW9uc0ZuKF9ub2RlLCBkYXR1bSkge1xuICByZXR1cm4ge1xuICAgIHN0YXJ0QW5nbGU6IGRhdHVtLnN0YXJ0QW5nbGUsXG4gICAgZW5kQW5nbGU6IGRhdHVtLmVuZEFuZ2xlLFxuICAgIGlubmVyUmFkaXVzOiBkYXR1bS5pbm5lclJhZGl1cyxcbiAgICBvdXRlclJhZGl1czogZGF0dW0ub3V0ZXJSYWRpdXMsXG4gICAgZmlsbDogZGF0dW0uc2VjdG9yRm9ybWF0LmZpbGwsXG4gICAgc3Ryb2tlOiBkYXR1bS5zZWN0b3JGb3JtYXQuc3Ryb2tlXG4gIH07XG59XG5mdW5jdGlvbiBwaWNrQnlNYXRjaGluZ0FuZ2xlKHNlcmllcywgcG9pbnQpIHtcbiAgY29uc3QgZHkgPSBwb2ludC55IC0gc2VyaWVzLmNlbnRlclk7XG4gIGNvbnN0IGR4ID0gcG9pbnQueCAtIHNlcmllcy5jZW50ZXJYO1xuICBjb25zdCBhbmdsZTIgPSBNYXRoLmF0YW4yKGR5LCBkeCk7XG4gIGNvbnN0IHNlY3RvcnMgPSBzZXJpZXMuZ2V0SXRlbU5vZGVzKCk7XG4gIGZvciAoY29uc3Qgc2VjdG9yIG9mIHNlY3RvcnMpIHtcbiAgICBpZiAoc2VjdG9yLmRhdHVtLm1pc3NpbmcgPT09IHRydWUpXG4gICAgICBjb250aW51ZTtcbiAgICBpZiAoaXNCZXR3ZWVuQW5nbGVzKGFuZ2xlMiwgc2VjdG9yLnN0YXJ0QW5nbGUsIHNlY3Rvci5lbmRBbmdsZSkpIHtcbiAgICAgIGNvbnN0IHJhZGl1cyA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICBsZXQgZGlzdGFuY2UzID0gMDtcbiAgICAgIGlmIChyYWRpdXMgPCBzZWN0b3IuaW5uZXJSYWRpdXMpIHtcbiAgICAgICAgZGlzdGFuY2UzID0gc2VjdG9yLmlubmVyUmFkaXVzIC0gcmFkaXVzO1xuICAgICAgfSBlbHNlIGlmIChyYWRpdXMgPiBzZWN0b3Iub3V0ZXJSYWRpdXMpIHtcbiAgICAgICAgZGlzdGFuY2UzID0gcmFkaXVzIC0gc2VjdG9yLm91dGVyUmFkaXVzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgZGF0dW06IHNlY3Rvci5kYXR1bSwgZGlzdGFuY2U6IGRpc3RhbmNlMyB9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvcG9sYXIvcG9sYXJTZXJpZXMudHNcbnZhciBQb2xhclNlcmllcyA9IGNsYXNzIGV4dGVuZHMgRGF0YU1vZGVsU2VyaWVzIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHVzZUxhYmVsTGF5ZXIgPSBmYWxzZSxcbiAgICBwaWNrTW9kZXMgPSBbMSAvKiBORUFSRVNUX05PREUgKi8sIDAgLyogRVhBQ1RfU0hBUEVfTUFUQ0ggKi9dLFxuICAgIGNhbkhhdmVBeGVzID0gZmFsc2UsXG4gICAgYW5pbWF0aW9uUmVzZXRGbnMsXG4gICAgLi4ub3B0c1xuICB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ub3B0cyxcbiAgICAgIHVzZUxhYmVsTGF5ZXIsXG4gICAgICBwaWNrTW9kZXMsXG4gICAgICBjb250ZW50R3JvdXBWaXJ0dWFsOiBmYWxzZSxcbiAgICAgIGRpcmVjdGlvbktleXM6IHtcbiAgICAgICAgW1wieFwiIC8qIFggKi9dOiBbXCJhbmdsZUtleVwiXSxcbiAgICAgICAgW1wieVwiIC8qIFkgKi9dOiBbXCJyYWRpdXNLZXlcIl1cbiAgICAgIH0sXG4gICAgICBkaXJlY3Rpb25OYW1lczoge1xuICAgICAgICBbXCJ4XCIgLyogWCAqL106IFtcImFuZ2xlTmFtZVwiXSxcbiAgICAgICAgW1wieVwiIC8qIFkgKi9dOiBbXCJyYWRpdXNOYW1lXCJdXG4gICAgICB9LFxuICAgICAgY2FuSGF2ZUF4ZXNcbiAgICB9KTtcbiAgICB0aGlzLml0ZW1Hcm91cCA9IHRoaXMuY29udGVudEdyb3VwLmFwcGVuZENoaWxkKG5ldyBHcm91cCgpKTtcbiAgICB0aGlzLm5vZGVEYXRhID0gW107XG4gICAgdGhpcy5pdGVtU2VsZWN0aW9uID0gU2VsZWN0aW9uLnNlbGVjdChcbiAgICAgIHRoaXMuaXRlbUdyb3VwLFxuICAgICAgKCkgPT4gdGhpcy5ub2RlRmFjdG9yeSgpLFxuICAgICAgZmFsc2VcbiAgICApO1xuICAgIHRoaXMubGFiZWxTZWxlY3Rpb24gPSBTZWxlY3Rpb24uc2VsZWN0KFxuICAgICAgdGhpcy5sYWJlbEdyb3VwLFxuICAgICAgKCkgPT4gdGhpcy5sYWJlbEZhY3RvcnkoKSxcbiAgICAgIGZhbHNlXG4gICAgKTtcbiAgICB0aGlzLmhpZ2hsaWdodFNlbGVjdGlvbiA9IFNlbGVjdGlvbi5zZWxlY3QoXG4gICAgICB0aGlzLmhpZ2hsaWdodEdyb3VwLFxuICAgICAgKCkgPT4gdGhpcy5ub2RlRmFjdG9yeSgpXG4gICAgKTtcbiAgICB0aGlzLmhpZ2hsaWdodExhYmVsU2VsZWN0aW9uID0gU2VsZWN0aW9uLnNlbGVjdChcbiAgICAgIHRoaXMuaGlnaGxpZ2h0TGFiZWwsXG4gICAgICAoKSA9PiB0aGlzLmxhYmVsRmFjdG9yeSgpXG4gICAgKTtcbiAgICAvKipcbiAgICAgKiBUaGUgY2VudGVyIG9mIHRoZSBwb2xhciBzZXJpZXMgKGZvciBleGFtcGxlLCB0aGUgY2VudGVyIG9mIGEgcGllKS5cbiAgICAgKiBJZiB0aGUgcG9sYXIgY2hhcnQgaGFzIG11bHRpcGxlIHNlcmllcywgYWxsIG9mIHRoZW0gd2lsbCBoYXZlIHRoZWlyXG4gICAgICogY2VudGVyIHNldCB0byB0aGUgc2FtZSB2YWx1ZSBhcyBhIHJlc3VsdCBvZiB0aGUgcG9sYXIgY2hhcnQgbGF5b3V0LlxuICAgICAqIFRoZSBjZW50ZXIgY29vcmRpbmF0ZXMgYXJlIG5vdCBzdXBwb3NlZCB0byBiZSBzZXQgYnkgdGhlIHVzZXIuXG4gICAgICovXG4gICAgdGhpcy5jZW50ZXJYID0gMDtcbiAgICB0aGlzLmNlbnRlclkgPSAwO1xuICAgIC8qKlxuICAgICAqIFRoZSBtYXhpbXVtIHJhZGl1cyB0aGUgc2VyaWVzIGNhbiB1c2UuXG4gICAgICogVGhpcyB2YWx1ZSBpcyBzZXQgYXV0b21hdGljYWxseSBhcyBhIHJlc3VsdCBvZiB0aGUgcG9sYXIgY2hhcnQgbGF5b3V0XG4gICAgICogYW5kIGlzIG5vdCBzdXBwb3NlZCB0byBiZSBzZXQgYnkgdGhlIHVzZXIuXG4gICAgICovXG4gICAgdGhpcy5yYWRpdXMgPSAwO1xuICAgIHRoaXMuaXRlbUdyb3VwLnpJbmRleFN1Yk9yZGVyID0gWygpID0+IHRoaXMuX2RlY2xhcmF0aW9uT3JkZXIsIDFdO1xuICAgIHRoaXMuYW5pbWF0aW9uUmVzZXRGbnMgPSBhbmltYXRpb25SZXNldEZucztcbiAgICB0aGlzLmFuaW1hdGlvblN0YXRlID0gbmV3IFN0YXRlTWFjaGluZShcbiAgICAgIFwiZW1wdHlcIixcbiAgICAgIHtcbiAgICAgICAgZW1wdHk6IHtcbiAgICAgICAgICB1cGRhdGU6IHtcbiAgICAgICAgICAgIHRhcmdldDogXCJyZWFkeVwiLFxuICAgICAgICAgICAgYWN0aW9uOiAoZGF0YSkgPT4gdGhpcy5hbmltYXRlRW1wdHlVcGRhdGVSZWFkeShkYXRhKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVzZXQ6IFwiZW1wdHlcIixcbiAgICAgICAgICBza2lwOiBcInJlYWR5XCJcbiAgICAgICAgfSxcbiAgICAgICAgcmVhZHk6IHtcbiAgICAgICAgICB1cGRhdGVEYXRhOiBcIndhaXRpbmdcIixcbiAgICAgICAgICBjbGVhcjogXCJjbGVhcmluZ1wiLFxuICAgICAgICAgIGhpZ2hsaWdodDogKGRhdGEpID0+IHRoaXMuYW5pbWF0ZVJlYWR5SGlnaGxpZ2h0KGRhdGEpLFxuICAgICAgICAgIGhpZ2hsaWdodE1hcmtlcnM6IChkYXRhKSA9PiB0aGlzLmFuaW1hdGVSZWFkeUhpZ2hsaWdodE1hcmtlcnMoZGF0YSksXG4gICAgICAgICAgcmVzaXplOiAoZGF0YSkgPT4gdGhpcy5hbmltYXRlUmVhZHlSZXNpemUoZGF0YSksXG4gICAgICAgICAgcmVzZXQ6IFwiZW1wdHlcIixcbiAgICAgICAgICBza2lwOiBcInJlYWR5XCJcbiAgICAgICAgfSxcbiAgICAgICAgd2FpdGluZzoge1xuICAgICAgICAgIHVwZGF0ZToge1xuICAgICAgICAgICAgdGFyZ2V0OiBcInJlYWR5XCIsXG4gICAgICAgICAgICBhY3Rpb246IChkYXRhKSA9PiB0aGlzLmFuaW1hdGVXYWl0aW5nVXBkYXRlUmVhZHkoZGF0YSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc2V0OiBcImVtcHR5XCIsXG4gICAgICAgICAgc2tpcDogXCJyZWFkeVwiXG4gICAgICAgIH0sXG4gICAgICAgIGNsZWFyaW5nOiB7XG4gICAgICAgICAgdXBkYXRlOiB7XG4gICAgICAgICAgICB0YXJnZXQ6IFwiZW1wdHlcIixcbiAgICAgICAgICAgIGFjdGlvbjogKGRhdGEpID0+IHRoaXMuYW5pbWF0ZUNsZWFyaW5nVXBkYXRlRW1wdHkoZGF0YSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc2V0OiBcImVtcHR5XCIsXG4gICAgICAgICAgc2tpcDogXCJyZWFkeVwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAoKSA9PiB0aGlzLmNoZWNrUHJvY2Vzc2VkRGF0YUFuaW1hdGFibGUoKVxuICAgICk7XG4gIH1cbiAgZ2V0SXRlbU5vZGVzKCkge1xuICAgIHJldHVybiBbLi4udGhpcy5pdGVtR3JvdXAuY2hpbGRyZW4oKV07XG4gIH1cbiAgZ2V0Tm9kZURhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZURhdGE7XG4gIH1cbiAgcmVzZXRBbmltYXRpb24ocGhhc2UpIHtcbiAgICBpZiAocGhhc2UgPT09IFwiaW5pdGlhbFwiKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJyZXNldFwiKTtcbiAgICB9IGVsc2UgaWYgKHBoYXNlID09PSBcInJlYWR5XCIpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcInNraXBcIik7XG4gICAgfVxuICB9XG4gIGxhYmVsRmFjdG9yeSgpIHtcbiAgICBjb25zdCB0ZXh0ID0gbmV3IFRleHQoKTtcbiAgICB0ZXh0LnBvaW50ZXJFdmVudHMgPSAxIC8qIE5vbmUgKi87XG4gICAgcmV0dXJuIHRleHQ7XG4gIH1cbiAgZ2V0SW5uZXJSYWRpdXMoKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgZ2V0TGFiZWxEYXRhKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBjb21wdXRlTGFiZWxzQkJveChfb3B0aW9ucywgX3Nlcmllc1JlY3QpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXNldEFsbEFuaW1hdGlvbigpIHtcbiAgICBjb25zdCB7IGl0ZW0sIGxhYmVsIH0gPSB0aGlzLmFuaW1hdGlvblJlc2V0Rm5zID8/IHt9O1xuICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuc3RvcEJ5QW5pbWF0aW9uR3JvdXBJZCh0aGlzLmlkKTtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgcmVzZXRNb3Rpb24oW3RoaXMuaXRlbVNlbGVjdGlvbiwgdGhpcy5oaWdobGlnaHRTZWxlY3Rpb25dLCBpdGVtKTtcbiAgICB9XG4gICAgaWYgKGxhYmVsKSB7XG4gICAgICByZXNldE1vdGlvbihbdGhpcy5sYWJlbFNlbGVjdGlvbiwgdGhpcy5oaWdobGlnaHRMYWJlbFNlbGVjdGlvbl0sIGxhYmVsKTtcbiAgICB9XG4gICAgdGhpcy5pdGVtU2VsZWN0aW9uLmNsZWFudXAoKTtcbiAgICB0aGlzLmxhYmVsU2VsZWN0aW9uLmNsZWFudXAoKTtcbiAgICB0aGlzLmhpZ2hsaWdodFNlbGVjdGlvbi5jbGVhbnVwKCk7XG4gICAgdGhpcy5oaWdobGlnaHRMYWJlbFNlbGVjdGlvbi5jbGVhbnVwKCk7XG4gIH1cbiAgYW5pbWF0ZUVtcHR5VXBkYXRlUmVhZHkoX2RhdGEpIHtcbiAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLnNraXBDdXJyZW50QmF0Y2goKTtcbiAgICB0aGlzLnJlc2V0QWxsQW5pbWF0aW9uKCk7XG4gIH1cbiAgYW5pbWF0ZVdhaXRpbmdVcGRhdGVSZWFkeShfZGF0YSkge1xuICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuc2tpcEN1cnJlbnRCYXRjaCgpO1xuICAgIHRoaXMucmVzZXRBbGxBbmltYXRpb24oKTtcbiAgfVxuICBhbmltYXRlUmVhZHlIaWdobGlnaHQoX2RhdGEpIHtcbiAgICBjb25zdCB7IGl0ZW0sIGxhYmVsIH0gPSB0aGlzLmFuaW1hdGlvblJlc2V0Rm5zID8/IHt9O1xuICAgIGlmIChpdGVtKSB7XG4gICAgICByZXNldE1vdGlvbihbdGhpcy5oaWdobGlnaHRTZWxlY3Rpb25dLCBpdGVtKTtcbiAgICB9XG4gICAgaWYgKGxhYmVsKSB7XG4gICAgICByZXNldE1vdGlvbihbdGhpcy5oaWdobGlnaHRMYWJlbFNlbGVjdGlvbl0sIGxhYmVsKTtcbiAgICB9XG4gIH1cbiAgYW5pbWF0ZVJlYWR5SGlnaGxpZ2h0TWFya2VycyhfZGF0YSkge1xuICB9XG4gIGFuaW1hdGVSZWFkeVJlc2l6ZShfZGF0YSkge1xuICAgIHRoaXMucmVzZXRBbGxBbmltYXRpb24oKTtcbiAgfVxuICBhbmltYXRlQ2xlYXJpbmdVcGRhdGVFbXB0eShfZGF0YSkge1xuICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuc2tpcEN1cnJlbnRCYXRjaCgpO1xuICAgIHRoaXMucmVzZXRBbGxBbmltYXRpb24oKTtcbiAgfVxuICBhbmltYXRpb25UcmFuc2l0aW9uQ2xlYXIoKSB7XG4gICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwiY2xlYXJcIiwgdGhpcy5nZXRBbmltYXRpb25EYXRhKCkpO1xuICB9XG4gIGdldEFuaW1hdGlvbkRhdGEoc2VyaWVzUmVjdCkge1xuICAgIHJldHVybiB7IHNlcmllc1JlY3QgfTtcbiAgfVxuICBjb21wdXRlRm9jdXNCb3VuZHMob3B0cykge1xuICAgIGNvbnN0IGRhdHVtID0gdGhpcy5nZXROb2RlRGF0YSgpPy5bb3B0cy5kYXR1bUluZGV4XTtcbiAgICBpZiAoZGF0dW0gIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXRlbVNlbGVjdGlvbi5zZWxlY3QoKG5vZGUpID0+IG5vZGUgaW5zdGFuY2VvZiBQYXRoICYmIG5vZGUuZGF0dW0gPT09IGRhdHVtKVswXTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL3BvbGFyL2RvbnV0U2VyaWVzLnRzXG52YXIgRG9udXRTZXJpZXNOb2RlRXZlbnQgPSBjbGFzcyBleHRlbmRzIFNlcmllc05vZGVFdmVudCB7XG4gIGNvbnN0cnVjdG9yKHR5cGUsIG5hdGl2ZUV2ZW50LCBkYXR1bSwgc2VyaWVzKSB7XG4gICAgc3VwZXIodHlwZSwgbmF0aXZlRXZlbnQsIGRhdHVtLCBzZXJpZXMpO1xuICAgIHRoaXMuYW5nbGVLZXkgPSBzZXJpZXMucHJvcGVydGllcy5hbmdsZUtleTtcbiAgICB0aGlzLnJhZGl1c0tleSA9IHNlcmllcy5wcm9wZXJ0aWVzLnJhZGl1c0tleTtcbiAgICB0aGlzLmNhbGxvdXRMYWJlbEtleSA9IHNlcmllcy5wcm9wZXJ0aWVzLmNhbGxvdXRMYWJlbEtleTtcbiAgICB0aGlzLnNlY3RvckxhYmVsS2V5ID0gc2VyaWVzLnByb3BlcnRpZXMuc2VjdG9yTGFiZWxLZXk7XG4gIH1cbn07XG52YXIgRG9udXRTZXJpZXMgPSBjbGFzcyBleHRlbmRzIFBvbGFyU2VyaWVzIHtcbiAgY29uc3RydWN0b3IobW9kdWxlQ3R4KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbW9kdWxlQ3R4LFxuICAgICAgcGlja01vZGVzOiBbMSAvKiBORUFSRVNUX05PREUgKi8sIDAgLyogRVhBQ1RfU0hBUEVfTUFUQ0ggKi9dLFxuICAgICAgdXNlTGFiZWxMYXllcjogdHJ1ZSxcbiAgICAgIGFuaW1hdGlvblJlc2V0Rm5zOiB7IGl0ZW06IHJlc2V0UGllU2VsZWN0aW9uc0ZuLCBsYWJlbDogcmVzZXRMYWJlbEZuIH1cbiAgICB9KTtcbiAgICB0aGlzLnByb3BlcnRpZXMgPSBuZXcgRG9udXRTZXJpZXNQcm9wZXJ0aWVzKCk7XG4gICAgdGhpcy5waGFudG9tTm9kZURhdGEgPSB2b2lkIDA7XG4gICAgdGhpcy5wcmV2aW91c1JhZGl1c1NjYWxlID0gbmV3IExpbmVhclNjYWxlKCk7XG4gICAgdGhpcy5yYWRpdXNTY2FsZSA9IG5ldyBMaW5lYXJTY2FsZSgpO1xuICAgIHRoaXMucGhhbnRvbUdyb3VwID0gdGhpcy5jb250ZW50R3JvdXAuYXBwZW5kQ2hpbGQobmV3IEdyb3VwKCkpO1xuICAgIHRoaXMucGhhbnRvbVNlbGVjdGlvbiA9IFNlbGVjdGlvbi5zZWxlY3QoXG4gICAgICB0aGlzLnBoYW50b21Hcm91cCxcbiAgICAgICgpID0+IHRoaXMubm9kZUZhY3RvcnkoKSxcbiAgICAgIGZhbHNlXG4gICAgKTtcbiAgICB0aGlzLmNhbGxvdXRMYWJlbEdyb3VwID0gdGhpcy5jb250ZW50R3JvdXAuYXBwZW5kQ2hpbGQobmV3IEdyb3VwKHsgbmFtZTogXCJwaWVDYWxsb3V0TGFiZWxzXCIgfSkpO1xuICAgIHRoaXMuY2FsbG91dExhYmVsU2VsZWN0aW9uID0gbmV3IFNlbGVjdGlvbihcbiAgICAgIHRoaXMuY2FsbG91dExhYmVsR3JvdXAsXG4gICAgICBHcm91cFxuICAgICk7XG4gICAgLy8gVGhlIGdyb3VwIG5vZGUgdGhhdCBjb250YWlucyB0aGUgYmFja2dyb3VuZCBncmFwaGljcy5cbiAgICB0aGlzLmJhY2tncm91bmRHcm91cCA9IHRoaXMucm9vdEdyb3VwLmFwcGVuZENoaWxkKFxuICAgICAgbmV3IFRyYW5zbGF0YWJsZUxheWVyKHtcbiAgICAgICAgbmFtZTogYCR7dGhpcy5pZH0tYmFja2dyb3VuZGAsXG4gICAgICAgIHpJbmRleDogMCAvKiBTRVJJRVNfQkFDS0dST1VORCAqL1xuICAgICAgfSlcbiAgICApO1xuICAgIC8vIEFHLTYxOTMgSWYgdGhlIHN1bSBvZiBhbGwgZGF0dW1zIGlzIDAsIHRoZW4gd2UnbGwgZHJhdyAxIG9yIDIgcmluZ3MgdG8gcmVwcmVzZW50IHRoZSBlbXB0eSBzZXJpZXMuXG4gICAgdGhpcy56ZXJvc3VtUmluZ3NHcm91cCA9IHRoaXMuYmFja2dyb3VuZEdyb3VwLmFwcGVuZENoaWxkKG5ldyBHcm91cCh7IG5hbWU6IGAke3RoaXMuaWR9LXplcm9zdW1SaW5nc2AgfSkpO1xuICAgIHRoaXMuemVyb3N1bU91dGVyUmluZyA9IHRoaXMuemVyb3N1bVJpbmdzR3JvdXAuYXBwZW5kQ2hpbGQobmV3IENpcmNsZSgpKTtcbiAgICB0aGlzLnplcm9zdW1Jbm5lclJpbmcgPSB0aGlzLnplcm9zdW1SaW5nc0dyb3VwLmFwcGVuZENoaWxkKG5ldyBDaXJjbGUoKSk7XG4gICAgdGhpcy5pbm5lckxhYmVsc0dyb3VwID0gdGhpcy5jb250ZW50R3JvdXAuYXBwZW5kQ2hpbGQobmV3IEdyb3VwKHsgbmFtZTogXCJpbm5lckxhYmVsc1wiIH0pKTtcbiAgICB0aGlzLmlubmVyQ2lyY2xlR3JvdXAgPSB0aGlzLmJhY2tncm91bmRHcm91cC5hcHBlbmRDaGlsZChuZXcgR3JvdXAoeyBuYW1lOiBgJHt0aGlzLmlkfS1pbm5lckNpcmNsZWAgfSkpO1xuICAgIHRoaXMuaW5uZXJMYWJlbHNTZWxlY3Rpb24gPSBTZWxlY3Rpb24uc2VsZWN0KHRoaXMuaW5uZXJMYWJlbHNHcm91cCwgVGV4dCk7XG4gICAgdGhpcy5pbm5lckNpcmNsZVNlbGVjdGlvbiA9IFNlbGVjdGlvbi5zZWxlY3QoXG4gICAgICB0aGlzLmlubmVyQ2lyY2xlR3JvdXAsXG4gICAgICBDaXJjbGVcbiAgICApO1xuICAgIC8vIFdoZW4gYSB1c2VyIHRvZ2dsZXMgYSBzZXJpZXMgaXRlbSAoZS5nLiBmcm9tIHRoZSBsZWdlbmQpLCBpdHMgYm9vbGVhbiBzdGF0ZSBpcyByZWNvcmRlZCBoZXJlLlxuICAgIHRoaXMuc2VyaWVzSXRlbUVuYWJsZWQgPSBbXTtcbiAgICB0aGlzLmxlZ2VuZEl0ZW1FbmFibGVkID0gW107XG4gICAgdGhpcy5zdXJyb3VuZGluZ1JhZGl1cyA9IHZvaWQgMDtcbiAgICB0aGlzLk5vZGVFdmVudCA9IERvbnV0U2VyaWVzTm9kZUV2ZW50O1xuICAgIHRoaXMuYW5nbGVTY2FsZSA9IG5ldyBMaW5lYXJTY2FsZSgpO1xuICAgIHRoaXMuYW5nbGVTY2FsZS5kb21haW4gPSBbMCwgMV07XG4gICAgdGhpcy5hbmdsZVNjYWxlLnJhbmdlID0gWy1NYXRoLlBJLCBNYXRoLlBJXS5tYXAoKGFuZ2xlMikgPT4gYW5nbGUyICsgTWF0aC5QSSAvIDIpO1xuICAgIHRoaXMucGhhbnRvbUdyb3VwLm9wYWNpdHkgPSAwLjI7XG4gICAgdGhpcy5waGFudG9tR3JvdXAuekluZGV4U3ViT3JkZXIgPSBbKCkgPT4gdGhpcy5fZGVjbGFyYXRpb25PcmRlciwgMF07XG4gIH1cbiAgZ2V0IGNhbGxvdXROb2RlRGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5waGFudG9tTm9kZURhdGEgPz8gdGhpcy5ub2RlRGF0YTtcbiAgfVxuICBhZGRDaGFydEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuZGVzdHJveUZucy5wdXNoKFxuICAgICAgdGhpcy5jdHguY2hhcnRFdmVudE1hbmFnZXI/LmFkZExpc3RlbmVyKFwibGVnZW5kLWl0ZW0tY2xpY2tcIiwgKGV2ZW50KSA9PiB0aGlzLm9uTGVnZW5kSXRlbUNsaWNrKGV2ZW50KSlcbiAgICApO1xuICB9XG4gIGdldCB2aXNpYmxlKCkge1xuICAgIHJldHVybiBzdXBlci52aXNpYmxlICYmICh0aGlzLnNlcmllc0l0ZW1FbmFibGVkLmxlbmd0aCA9PT0gMCB8fCB0aGlzLnNlcmllc0l0ZW1FbmFibGVkLmluY2x1ZGVzKHRydWUpKTtcbiAgfVxuICBub2RlRmFjdG9yeSgpIHtcbiAgICByZXR1cm4gbmV3IFNlY3RvcigpO1xuICB9XG4gIGdldFNlcmllc0RvbWFpbihkaXJlY3Rpb24pIHtcbiAgICBpZiAoZGlyZWN0aW9uID09PSBcInhcIiAvKiBYICovKSB7XG4gICAgICByZXR1cm4gdGhpcy5hbmdsZVNjYWxlLmRvbWFpbjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMucmFkaXVzU2NhbGUuZG9tYWluO1xuICAgIH1cbiAgfVxuICBhc3luYyBwcm9jZXNzRGF0YShkYXRhQ29udHJvbGxlcikge1xuICAgIGlmICh0aGlzLmRhdGEgPT0gbnVsbCB8fCAhdGhpcy5wcm9wZXJ0aWVzLmlzVmFsaWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgeyBkYXRhIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgdmlzaWJsZSwgc2VyaWVzSXRlbUVuYWJsZWQgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBhbmdsZUtleSwgYW5nbGVGaWx0ZXJLZXksIHJhZGl1c0tleSwgY2FsbG91dExhYmVsS2V5LCBzZWN0b3JMYWJlbEtleSwgbGVnZW5kSXRlbUtleSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGFuaW1hdGlvbkVuYWJsZWQgPSAhdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5pc1NraXBwZWQoKTtcbiAgICBjb25zdCBleHRyYUtleVByb3BzID0gW107XG4gICAgY29uc3QgZXh0cmFQcm9wcyA9IFtdO1xuICAgIGlmIChsZWdlbmRJdGVtS2V5KSB7XG4gICAgICBleHRyYUtleVByb3BzLnB1c2goa2V5UHJvcGVydHkobGVnZW5kSXRlbUtleSwgXCJiYW5kXCIsIHsgaWQ6IGBsZWdlbmRJdGVtS2V5YCB9KSk7XG4gICAgfSBlbHNlIGlmIChjYWxsb3V0TGFiZWxLZXkpIHtcbiAgICAgIGV4dHJhS2V5UHJvcHMucHVzaChrZXlQcm9wZXJ0eShjYWxsb3V0TGFiZWxLZXksIFwiYmFuZFwiLCB7IGlkOiBgY2FsbG91dExhYmVsS2V5YCB9KSk7XG4gICAgfSBlbHNlIGlmIChzZWN0b3JMYWJlbEtleSkge1xuICAgICAgZXh0cmFLZXlQcm9wcy5wdXNoKGtleVByb3BlcnR5KHNlY3RvckxhYmVsS2V5LCBcImJhbmRcIiwgeyBpZDogYHNlY3RvckxhYmVsS2V5YCB9KSk7XG4gICAgfVxuICAgIGNvbnN0IHJhZGl1c1NjYWxlVHlwZSA9IHRoaXMucmFkaXVzU2NhbGUudHlwZTtcbiAgICBjb25zdCBhbmdsZVNjYWxlVHlwZSA9IHRoaXMucmFkaXVzU2NhbGUudHlwZTtcbiAgICBpZiAocmFkaXVzS2V5KSB7XG4gICAgICBleHRyYVByb3BzLnB1c2goXG4gICAgICAgIHJhbmdlZFZhbHVlUHJvcGVydHkocmFkaXVzS2V5LCB7XG4gICAgICAgICAgaWQ6IFwicmFkaXVzVmFsdWVcIixcbiAgICAgICAgICBtaW46IHRoaXMucHJvcGVydGllcy5yYWRpdXNNaW4gPz8gMCxcbiAgICAgICAgICBtYXg6IHRoaXMucHJvcGVydGllcy5yYWRpdXNNYXhcbiAgICAgICAgfSksXG4gICAgICAgIHZhbHVlUHJvcGVydHkocmFkaXVzS2V5LCByYWRpdXNTY2FsZVR5cGUsIHsgaWQ6IGByYWRpdXNSYXdgIH0pLFxuICAgICAgICAvLyBSYXcgdmFsdWUgcGFzcy10aHJvdWdoLlxuICAgICAgICBub3JtYWxpc2VQcm9wZXJ0eVRvKFwicmFkaXVzVmFsdWVcIiwgWzAsIDFdLCAxLCB0aGlzLnByb3BlcnRpZXMucmFkaXVzTWluID8/IDAsIHRoaXMucHJvcGVydGllcy5yYWRpdXNNYXgpXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoY2FsbG91dExhYmVsS2V5KSB7XG4gICAgICBleHRyYVByb3BzLnB1c2godmFsdWVQcm9wZXJ0eShjYWxsb3V0TGFiZWxLZXksIFwiYmFuZFwiLCB7IGlkOiBgY2FsbG91dExhYmVsVmFsdWVgIH0pKTtcbiAgICB9XG4gICAgaWYgKHNlY3RvckxhYmVsS2V5KSB7XG4gICAgICBleHRyYVByb3BzLnB1c2godmFsdWVQcm9wZXJ0eShzZWN0b3JMYWJlbEtleSwgXCJiYW5kXCIsIHsgaWQ6IGBzZWN0b3JMYWJlbFZhbHVlYCB9KSk7XG4gICAgfVxuICAgIGlmIChsZWdlbmRJdGVtS2V5KSB7XG4gICAgICBleHRyYVByb3BzLnB1c2godmFsdWVQcm9wZXJ0eShsZWdlbmRJdGVtS2V5LCBcImJhbmRcIiwgeyBpZDogYGxlZ2VuZEl0ZW1WYWx1ZWAgfSkpO1xuICAgIH1cbiAgICBpZiAoYW5nbGVGaWx0ZXJLZXkpIHtcbiAgICAgIGV4dHJhUHJvcHMucHVzaChcbiAgICAgICAgYWNjdW11bGF0aXZlVmFsdWVQcm9wZXJ0eShhbmdsZUZpbHRlcktleSwgYW5nbGVTY2FsZVR5cGUsIHtcbiAgICAgICAgICBpZDogYGFuZ2xlRmlsdGVyVmFsdWVgLFxuICAgICAgICAgIG9ubHlQb3NpdGl2ZTogdHJ1ZVxuICAgICAgICB9KSxcbiAgICAgICAgdmFsdWVQcm9wZXJ0eShhbmdsZUZpbHRlcktleSwgYW5nbGVTY2FsZVR5cGUsIHsgaWQ6IGBhbmdsZUZpbHRlclJhd2AgfSksXG4gICAgICAgIG5vcm1hbGlzZVByb3BlcnR5VG8oXCJhbmdsZUZpbHRlclZhbHVlXCIsIFswLCAxXSwgMCwgMClcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChhbmltYXRpb25FbmFibGVkICYmIHRoaXMucHJvY2Vzc2VkRGF0YSAmJiBleHRyYUtleVByb3BzLmxlbmd0aCA+IDApIHtcbiAgICAgIGV4dHJhUHJvcHMucHVzaChkaWZmKHRoaXMucHJvY2Vzc2VkRGF0YSkpO1xuICAgIH1cbiAgICBleHRyYVByb3BzLnB1c2goYW5pbWF0aW9uVmFsaWRhdGlvbigpKTtcbiAgICBkYXRhID0gZGF0YS5tYXAoKGQsIGlkeCkgPT4gdmlzaWJsZSAmJiBzZXJpZXNJdGVtRW5hYmxlZFtpZHhdID8gZCA6IHsgLi4uZCwgW2FuZ2xlS2V5XTogMCB9KTtcbiAgICBhd2FpdCB0aGlzLnJlcXVlc3REYXRhTW9kZWwoZGF0YUNvbnRyb2xsZXIsIGRhdGEsIHtcbiAgICAgIHByb3BzOiBbXG4gICAgICAgIC4uLmV4dHJhS2V5UHJvcHMsXG4gICAgICAgIGFjY3VtdWxhdGl2ZVZhbHVlUHJvcGVydHkoYW5nbGVLZXksIGFuZ2xlU2NhbGVUeXBlLCB7IGlkOiBgYW5nbGVWYWx1ZWAsIG9ubHlQb3NpdGl2ZTogdHJ1ZSB9KSxcbiAgICAgICAgdmFsdWVQcm9wZXJ0eShhbmdsZUtleSwgYW5nbGVTY2FsZVR5cGUsIHsgaWQ6IGBhbmdsZVJhd2AgfSksXG4gICAgICAgIC8vIFJhdyB2YWx1ZSBwYXNzLXRocm91Z2guXG4gICAgICAgIG5vcm1hbGlzZVByb3BlcnR5VG8oXCJhbmdsZVZhbHVlXCIsIFswLCAxXSwgMCwgMCksXG4gICAgICAgIC4uLmV4dHJhUHJvcHNcbiAgICAgIF1cbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IHZhbHVlRGVmIG9mIHRoaXMucHJvY2Vzc2VkRGF0YT8uZGVmcz8udmFsdWVzID8/IFtdKSB7XG4gICAgICBjb25zdCB7IGlkLCBtaXNzaW5nLCBwcm9wZXJ0eSB9ID0gdmFsdWVEZWY7XG4gICAgICBjb25zdCBtaXNzQ291bnQgPSBnZXRNaXNzQ291bnQodGhpcywgbWlzc2luZyk7XG4gICAgICBpZiAoaWQgIT09IFwiYW5nbGVSYXdcIiAmJiBtaXNzQ291bnQgPiAwKSB7XG4gICAgICAgIExvZ2dlci53YXJuT25jZShcbiAgICAgICAgICBgbm8gdmFsdWUgd2FzIGZvdW5kIGZvciB0aGUga2V5ICcke1N0cmluZyhwcm9wZXJ0eSl9JyBvbiAke21pc3NDb3VudH0gZGF0YSBlbGVtZW50JHttaXNzQ291bnQgPiAxID8gXCJzXCIgOiBcIlwifWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwidXBkYXRlRGF0YVwiKTtcbiAgfVxuICBhc3luYyBtYXliZVJlZnJlc2hOb2RlRGF0YSgpIHtcbiAgICBpZiAoIXRoaXMubm9kZURhdGFSZWZyZXNoKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgbm9kZURhdGEgPSBbXSwgcGhhbnRvbU5vZGVEYXRhIH0gPSBhd2FpdCB0aGlzLmNyZWF0ZU5vZGVEYXRhKCkgPz8ge307XG4gICAgdGhpcy5ub2RlRGF0YSA9IG5vZGVEYXRhO1xuICAgIHRoaXMucGhhbnRvbU5vZGVEYXRhID0gcGhhbnRvbU5vZGVEYXRhO1xuICAgIHRoaXMubm9kZURhdGFSZWZyZXNoID0gZmFsc2U7XG4gIH1cbiAgZ2V0UHJvY2Vzc2VkRGF0YUluZGV4ZXMoZGF0YU1vZGVsKSB7XG4gICAgY29uc3QgYW5nbGVJZHggPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYGFuZ2xlVmFsdWVgKTtcbiAgICBjb25zdCBhbmdsZVJhd0lkeCA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgYW5nbGVSYXdgKTtcbiAgICBjb25zdCBhbmdsZUZpbHRlcklkeCA9IHRoaXMucHJvcGVydGllcy5hbmdsZUZpbHRlcktleSAhPSBudWxsID8gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGBhbmdsZUZpbHRlclZhbHVlYCkgOiB2b2lkIDA7XG4gICAgY29uc3QgYW5nbGVGaWx0ZXJSYXdJZHggPSB0aGlzLnByb3BlcnRpZXMuYW5nbGVGaWx0ZXJLZXkgIT0gbnVsbCA/IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgYW5nbGVGaWx0ZXJSYXdgKSA6IHZvaWQgMDtcbiAgICBjb25zdCByYWRpdXNJZHggPSB0aGlzLnByb3BlcnRpZXMucmFkaXVzS2V5ID8gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGByYWRpdXNWYWx1ZWApIDogdm9pZCAwO1xuICAgIGNvbnN0IHJhZGl1c1Jhd0lkeCA9IHRoaXMucHJvcGVydGllcy5yYWRpdXNLZXkgPyBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYHJhZGl1c1Jhd2ApIDogdm9pZCAwO1xuICAgIGNvbnN0IGNhbGxvdXRMYWJlbElkeCA9IHRoaXMucHJvcGVydGllcy5jYWxsb3V0TGFiZWxLZXkgPyBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYGNhbGxvdXRMYWJlbFZhbHVlYCkgOiB2b2lkIDA7XG4gICAgY29uc3Qgc2VjdG9yTGFiZWxJZHggPSB0aGlzLnByb3BlcnRpZXMuc2VjdG9yTGFiZWxLZXkgPyBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYHNlY3RvckxhYmVsVmFsdWVgKSA6IHZvaWQgMDtcbiAgICBjb25zdCBsZWdlbmRJdGVtSWR4ID0gdGhpcy5wcm9wZXJ0aWVzLmxlZ2VuZEl0ZW1LZXkgPyBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYGxlZ2VuZEl0ZW1WYWx1ZWApIDogdm9pZCAwO1xuICAgIHJldHVybiB7XG4gICAgICBhbmdsZUlkeCxcbiAgICAgIGFuZ2xlUmF3SWR4LFxuICAgICAgYW5nbGVGaWx0ZXJJZHgsXG4gICAgICBhbmdsZUZpbHRlclJhd0lkeCxcbiAgICAgIHJhZGl1c0lkeCxcbiAgICAgIHJhZGl1c1Jhd0lkeCxcbiAgICAgIGNhbGxvdXRMYWJlbElkeCxcbiAgICAgIHNlY3RvckxhYmVsSWR4LFxuICAgICAgbGVnZW5kSXRlbUlkeFxuICAgIH07XG4gIH1cbiAgYXN5bmMgY3JlYXRlTm9kZURhdGEoKSB7XG4gICAgY29uc3QgeyBpZDogc2VyaWVzSWQsIHByb2Nlc3NlZERhdGEsIGRhdGFNb2RlbCwgYW5nbGVTY2FsZSB9ID0gdGhpcztcbiAgICBjb25zdCB7IHJvdGF0aW9uLCBpbm5lclJhZGl1c1JhdGlvIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgaWYgKCF0aGlzLnByb3BlcnRpZXMuaXNWYWxpZCgpKSB7XG4gICAgICB0aGlzLnplcm9zdW1PdXRlclJpbmcudmlzaWJsZSA9IHRydWU7XG4gICAgICB0aGlzLnplcm9zdW1Jbm5lclJpbmcudmlzaWJsZSA9IHRydWU7XG4gICAgICByZXR1cm4geyBpdGVtSWQ6IHNlcmllc0lkLCBub2RlRGF0YTogW10sIGxhYmVsRGF0YTogW10gfTtcbiAgICB9XG4gICAgaWYgKCFwcm9jZXNzZWREYXRhIHx8ICFkYXRhTW9kZWwgfHwgcHJvY2Vzc2VkRGF0YS50eXBlICE9PSBcInVuZ3JvdXBlZFwiKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHtcbiAgICAgIGFuZ2xlSWR4LFxuICAgICAgYW5nbGVSYXdJZHgsXG4gICAgICBhbmdsZUZpbHRlcklkeCxcbiAgICAgIGFuZ2xlRmlsdGVyUmF3SWR4LFxuICAgICAgcmFkaXVzSWR4LFxuICAgICAgcmFkaXVzUmF3SWR4LFxuICAgICAgY2FsbG91dExhYmVsSWR4LFxuICAgICAgc2VjdG9yTGFiZWxJZHgsXG4gICAgICBsZWdlbmRJdGVtSWR4XG4gICAgfSA9IHRoaXMuZ2V0UHJvY2Vzc2VkRGF0YUluZGV4ZXMoZGF0YU1vZGVsKTtcbiAgICBjb25zdCB1c2VGaWx0ZXJBbmdsZXMgPSBhbmdsZUZpbHRlclJhd0lkeCAhPSBudWxsICYmIHByb2Nlc3NlZERhdGEuZGF0YS5zb21lKCh7IHZhbHVlcyB9KSA9PiB7XG4gICAgICByZXR1cm4gdmFsdWVzW2FuZ2xlRmlsdGVyUmF3SWR4XSA+IHZhbHVlc1thbmdsZVJhd0lkeF07XG4gICAgfSk7XG4gICAgbGV0IGN1cnJlbnRTdGFydCA9IDA7XG4gICAgbGV0IHN1bTIgPSAwO1xuICAgIGNvbnN0IG5vZGVzID0gW107XG4gICAgY29uc3QgcGhhbnRvbU5vZGVzID0gYW5nbGVGaWx0ZXJSYXdJZHggIT0gbnVsbCA/IFtdIDogdm9pZCAwO1xuICAgIHByb2Nlc3NlZERhdGEuZGF0YS5mb3JFYWNoKChncm91cCwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHsgZGF0dW0sIHZhbHVlcyB9ID0gZ3JvdXA7XG4gICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB1c2VGaWx0ZXJBbmdsZXMgPyB2YWx1ZXNbYW5nbGVGaWx0ZXJJZHhdIDogdmFsdWVzW2FuZ2xlSWR4XTtcbiAgICAgIGNvbnN0IGNyb3NzRmlsdGVyU2NhbGUgPSBhbmdsZUZpbHRlclJhd0lkeCAhPSBudWxsICYmICF1c2VGaWx0ZXJBbmdsZXMgPyBNYXRoLnNxcnQodmFsdWVzW2FuZ2xlRmlsdGVyUmF3SWR4XSAvIHZhbHVlc1thbmdsZVJhd0lkeF0pIDogMTtcbiAgICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSBhbmdsZVNjYWxlLmNvbnZlcnQoY3VycmVudFN0YXJ0KSArIHRvUmFkaWFucyhyb3RhdGlvbik7XG4gICAgICBjdXJyZW50U3RhcnQgPSBjdXJyZW50VmFsdWU7XG4gICAgICBzdW0yICs9IGN1cnJlbnRWYWx1ZTtcbiAgICAgIGNvbnN0IGVuZEFuZ2xlID0gYW5nbGVTY2FsZS5jb252ZXJ0KGN1cnJlbnRTdGFydCkgKyB0b1JhZGlhbnMocm90YXRpb24pO1xuICAgICAgY29uc3Qgc3BhbiA9IE1hdGguYWJzKGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSk7XG4gICAgICBjb25zdCBtaWRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBzcGFuIC8gMjtcbiAgICAgIGNvbnN0IGFuZ2xlVmFsdWUgPSB2YWx1ZXNbYW5nbGVSYXdJZHhdO1xuICAgICAgY29uc3QgcmFkaXVzUmF3ID0gcmFkaXVzSWR4ICE9IG51bGwgPyB2YWx1ZXNbcmFkaXVzSWR4XSA/PyAxIDogMTtcbiAgICAgIGNvbnN0IHJhZGl1cyA9IHJhZGl1c1JhdyAqIGNyb3NzRmlsdGVyU2NhbGU7XG4gICAgICBjb25zdCByYWRpdXNWYWx1ZSA9IHJhZGl1c1Jhd0lkeCAhPSBudWxsID8gdmFsdWVzW3JhZGl1c1Jhd0lkeF0gOiB2b2lkIDA7XG4gICAgICBjb25zdCBsZWdlbmRJdGVtVmFsdWUgPSBsZWdlbmRJdGVtSWR4ICE9IG51bGwgPyB2YWx1ZXNbbGVnZW5kSXRlbUlkeF0gOiB2b2lkIDA7XG4gICAgICBjb25zdCBub2RlTGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoXG4gICAgICAgIGRhdHVtLFxuICAgICAgICBtaWRBbmdsZSxcbiAgICAgICAgc3BhbixcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgY2FsbG91dExhYmVsSWR4ICE9IG51bGwgPyB2YWx1ZXNbY2FsbG91dExhYmVsSWR4XSA6IHZvaWQgMCxcbiAgICAgICAgc2VjdG9yTGFiZWxJZHggIT0gbnVsbCA/IHZhbHVlc1tzZWN0b3JMYWJlbElkeF0gOiB2b2lkIDAsXG4gICAgICAgIGxlZ2VuZEl0ZW1WYWx1ZVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHNlY3RvckZvcm1hdCA9IHRoaXMuZ2V0U2VjdG9yRm9ybWF0KGRhdHVtLCBpbmRleCwgZmFsc2UpO1xuICAgICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgICAgaXRlbUlkOiBpbmRleCxcbiAgICAgICAgc2VyaWVzOiB0aGlzLFxuICAgICAgICBkYXR1bSxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIGFuZ2xlVmFsdWUsXG4gICAgICAgIG1pZEFuZ2xlLFxuICAgICAgICBtaWRDb3M6IE1hdGguY29zKG1pZEFuZ2xlKSxcbiAgICAgICAgbWlkU2luOiBNYXRoLnNpbihtaWRBbmdsZSksXG4gICAgICAgIHN0YXJ0QW5nbGUsXG4gICAgICAgIGVuZEFuZ2xlLFxuICAgICAgICByYWRpdXMsXG4gICAgICAgIGlubmVyUmFkaXVzOiBNYXRoLm1heCh0aGlzLnJhZGl1c1NjYWxlLmNvbnZlcnQoMCksIDApLFxuICAgICAgICBvdXRlclJhZGl1czogTWF0aC5tYXgodGhpcy5yYWRpdXNTY2FsZS5jb252ZXJ0KHJhZGl1cyksIDApLFxuICAgICAgICBzZWN0b3JGb3JtYXQsXG4gICAgICAgIHJhZGl1c1ZhbHVlLFxuICAgICAgICBsZWdlbmRJdGVtVmFsdWUsXG4gICAgICAgIGVuYWJsZWQ6IHRoaXMuc2VyaWVzSXRlbUVuYWJsZWRbaW5kZXhdLFxuICAgICAgICBmb2N1c2FibGU6IHRydWUsXG4gICAgICAgIC4uLm5vZGVMYWJlbHNcbiAgICAgIH07XG4gICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgaWYgKHBoYW50b21Ob2RlcyAhPSBudWxsKSB7XG4gICAgICAgIHBoYW50b21Ob2Rlcy5wdXNoKHtcbiAgICAgICAgICAuLi5ub2RlLFxuICAgICAgICAgIHJhZGl1czogMSxcbiAgICAgICAgICBpbm5lclJhZGl1czogTWF0aC5tYXgodGhpcy5yYWRpdXNTY2FsZS5jb252ZXJ0KDApLCAwKSxcbiAgICAgICAgICBvdXRlclJhZGl1czogTWF0aC5tYXgodGhpcy5yYWRpdXNTY2FsZS5jb252ZXJ0KDEpLCAwKSxcbiAgICAgICAgICBmb2N1c2FibGU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuemVyb3N1bU91dGVyUmluZy52aXNpYmxlID0gc3VtMiA9PT0gMDtcbiAgICB0aGlzLnplcm9zdW1Jbm5lclJpbmcudmlzaWJsZSA9IHN1bTIgPT09IDAgJiYgaW5uZXJSYWRpdXNSYXRpbyAhPSBudWxsICYmIGlubmVyUmFkaXVzUmF0aW8gIT09IDEgJiYgaW5uZXJSYWRpdXNSYXRpbyA+IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIGl0ZW1JZDogc2VyaWVzSWQsXG4gICAgICBub2RlRGF0YTogbm9kZXMsXG4gICAgICBsYWJlbERhdGE6IG5vZGVzLFxuICAgICAgcGhhbnRvbU5vZGVEYXRhOiBwaGFudG9tTm9kZXNcbiAgICB9O1xuICB9XG4gIGdldExhYmVscyhkYXR1bSwgbWlkQW5nbGUsIHNwYW4sIHNraXBEaXNhYmxlZCwgY2FsbG91dExhYmVsVmFsdWUsIHNlY3RvckxhYmVsVmFsdWUsIGxlZ2VuZEl0ZW1WYWx1ZSkge1xuICAgIGNvbnN0IHsgY2FsbG91dExhYmVsLCBzZWN0b3JMYWJlbCwgbGVnZW5kSXRlbUtleSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGNhbGxvdXRMYWJlbEtleSA9ICFza2lwRGlzYWJsZWQgfHwgY2FsbG91dExhYmVsLmVuYWJsZWQgPyB0aGlzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsS2V5IDogdm9pZCAwO1xuICAgIGNvbnN0IHNlY3RvckxhYmVsS2V5ID0gIXNraXBEaXNhYmxlZCB8fCBzZWN0b3JMYWJlbC5lbmFibGVkID8gdGhpcy5wcm9wZXJ0aWVzLnNlY3RvckxhYmVsS2V5IDogdm9pZCAwO1xuICAgIGlmICghY2FsbG91dExhYmVsS2V5ICYmICFzZWN0b3JMYWJlbEtleSAmJiAhbGVnZW5kSXRlbUtleSkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBjb25zdCBsYWJlbEZvcm1hdHRlclBhcmFtcyA9IHtcbiAgICAgIGRhdHVtLFxuICAgICAgYW5nbGVLZXk6IHRoaXMucHJvcGVydGllcy5hbmdsZUtleSxcbiAgICAgIGFuZ2xlTmFtZTogdGhpcy5wcm9wZXJ0aWVzLmFuZ2xlTmFtZSxcbiAgICAgIHJhZGl1c0tleTogdGhpcy5wcm9wZXJ0aWVzLnJhZGl1c0tleSxcbiAgICAgIHJhZGl1c05hbWU6IHRoaXMucHJvcGVydGllcy5yYWRpdXNOYW1lLFxuICAgICAgY2FsbG91dExhYmVsS2V5OiB0aGlzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsS2V5LFxuICAgICAgY2FsbG91dExhYmVsTmFtZTogdGhpcy5wcm9wZXJ0aWVzLmNhbGxvdXRMYWJlbE5hbWUsXG4gICAgICBzZWN0b3JMYWJlbEtleTogdGhpcy5wcm9wZXJ0aWVzLnNlY3RvckxhYmVsS2V5LFxuICAgICAgc2VjdG9yTGFiZWxOYW1lOiB0aGlzLnByb3BlcnRpZXMuc2VjdG9yTGFiZWxOYW1lLFxuICAgICAgbGVnZW5kSXRlbUtleTogdGhpcy5wcm9wZXJ0aWVzLmxlZ2VuZEl0ZW1LZXlcbiAgICB9O1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGlmIChjYWxsb3V0TGFiZWxLZXkgJiYgc3BhbiA+IHRvUmFkaWFucyhjYWxsb3V0TGFiZWwubWluQW5nbGUpKSB7XG4gICAgICByZXN1bHQuY2FsbG91dExhYmVsID0ge1xuICAgICAgICAuLi50aGlzLmdldFRleHRBbGlnbm1lbnQobWlkQW5nbGUpLFxuICAgICAgICB0ZXh0OiB0aGlzLmdldExhYmVsVGV4dChjYWxsb3V0TGFiZWwsIHtcbiAgICAgICAgICAuLi5sYWJlbEZvcm1hdHRlclBhcmFtcyxcbiAgICAgICAgICB2YWx1ZTogY2FsbG91dExhYmVsVmFsdWVcbiAgICAgICAgfSksXG4gICAgICAgIGhpZGRlbjogZmFsc2UsXG4gICAgICAgIGNvbGxpc2lvblRleHRBbGlnbjogdm9pZCAwLFxuICAgICAgICBjb2xsaXNpb25PZmZzZXRZOiAwLFxuICAgICAgICBib3g6IHZvaWQgMFxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHNlY3RvckxhYmVsS2V5KSB7XG4gICAgICByZXN1bHQuc2VjdG9yTGFiZWwgPSB7XG4gICAgICAgIHRleHQ6IHRoaXMuZ2V0TGFiZWxUZXh0KHNlY3RvckxhYmVsLCB7XG4gICAgICAgICAgLi4ubGFiZWxGb3JtYXR0ZXJQYXJhbXMsXG4gICAgICAgICAgdmFsdWU6IHNlY3RvckxhYmVsVmFsdWVcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChsZWdlbmRJdGVtS2V5ICE9IG51bGwgJiYgbGVnZW5kSXRlbVZhbHVlICE9IG51bGwpIHtcbiAgICAgIHJlc3VsdC5sZWdlbmRJdGVtID0geyBrZXk6IGxlZ2VuZEl0ZW1LZXksIHRleHQ6IGxlZ2VuZEl0ZW1WYWx1ZSB9O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGdldFRleHRBbGlnbm1lbnQobWlkQW5nbGUpIHtcbiAgICBjb25zdCBxdWFkcmFudFRleHRPcHRzID0gW1xuICAgICAgeyB0ZXh0QWxpZ246IFwiY2VudGVyXCIsIHRleHRCYXNlbGluZTogXCJib3R0b21cIiB9LFxuICAgICAgeyB0ZXh0QWxpZ246IFwibGVmdFwiLCB0ZXh0QmFzZWxpbmU6IFwibWlkZGxlXCIgfSxcbiAgICAgIHsgdGV4dEFsaWduOiBcImNlbnRlclwiLCB0ZXh0QmFzZWxpbmU6IFwiaGFuZ2luZ1wiIH0sXG4gICAgICB7IHRleHRBbGlnbjogXCJyaWdodFwiLCB0ZXh0QmFzZWxpbmU6IFwibWlkZGxlXCIgfVxuICAgIF07XG4gICAgY29uc3QgbWlkQW5nbGUxODAgPSBub3JtYWxpemVBbmdsZTE4MChtaWRBbmdsZSk7XG4gICAgY29uc3QgcXVhZHJhbnRTdGFydCA9IC0wLjc1ICogTWF0aC5QSTtcbiAgICBjb25zdCBxdWFkcmFudE9mZnNldCA9IG1pZEFuZ2xlMTgwIC0gcXVhZHJhbnRTdGFydDtcbiAgICBjb25zdCBxdWFkcmFudCA9IE1hdGguZmxvb3IocXVhZHJhbnRPZmZzZXQgLyAoTWF0aC5QSSAvIDIpKTtcbiAgICBjb25zdCBxdWFkcmFudEluZGV4ID0gbW9kKHF1YWRyYW50LCBxdWFkcmFudFRleHRPcHRzLmxlbmd0aCk7XG4gICAgcmV0dXJuIHF1YWRyYW50VGV4dE9wdHNbcXVhZHJhbnRJbmRleF07XG4gIH1cbiAgZ2V0U2VjdG9yRm9ybWF0KGRhdHVtLCBmb3JtYXRJbmRleCwgaGlnaGxpZ2h0ZWQpIHtcbiAgICBjb25zdCB7IGNhbGxiYWNrQ2FjaGUgfSA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IHsgYW5nbGVLZXksIHJhZGl1c0tleSwgY2FsbG91dExhYmVsS2V5LCBzZWN0b3JMYWJlbEtleSwgbGVnZW5kSXRlbUtleSwgZmlsbHMsIHN0cm9rZXMsIGl0ZW1TdHlsZXIgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCBkZWZhdWx0U3Ryb2tlID0gc3Ryb2tlc1tmb3JtYXRJbmRleCAlIHN0cm9rZXMubGVuZ3RoXTtcbiAgICBjb25zdCB7IGZpbGwsIGZpbGxPcGFjaXR5LCBzdHJva2UsIHN0cm9rZVdpZHRoLCBzdHJva2VPcGFjaXR5LCBsaW5lRGFzaCwgbGluZURhc2hPZmZzZXQsIGNvcm5lclJhZGl1cyB9ID0gbWVyZ2VEZWZhdWx0cyhcbiAgICAgIGhpZ2hsaWdodGVkICYmIHRoaXMucHJvcGVydGllcy5oaWdobGlnaHRTdHlsZS5pdGVtLFxuICAgICAge1xuICAgICAgICBmaWxsOiBmaWxscy5sZW5ndGggPiAwID8gZmlsbHNbZm9ybWF0SW5kZXggJSBmaWxscy5sZW5ndGhdIDogdm9pZCAwLFxuICAgICAgICBzdHJva2U6IGRlZmF1bHRTdHJva2UsXG4gICAgICAgIHN0cm9rZVdpZHRoOiB0aGlzLmdldFN0cm9rZVdpZHRoKHRoaXMucHJvcGVydGllcy5zdHJva2VXaWR0aCksXG4gICAgICAgIHN0cm9rZU9wYWNpdHk6IHRoaXMuZ2V0T3BhY2l0eSgpXG4gICAgICB9LFxuICAgICAgdGhpcy5wcm9wZXJ0aWVzXG4gICAgKTtcbiAgICBsZXQgZm9ybWF0O1xuICAgIGlmIChpdGVtU3R5bGVyKSB7XG4gICAgICBmb3JtYXQgPSBjYWxsYmFja0NhY2hlLmNhbGwoaXRlbVN0eWxlciwge1xuICAgICAgICBkYXR1bSxcbiAgICAgICAgYW5nbGVLZXksXG4gICAgICAgIHJhZGl1c0tleSxcbiAgICAgICAgY2FsbG91dExhYmVsS2V5LFxuICAgICAgICBzZWN0b3JMYWJlbEtleSxcbiAgICAgICAgbGVnZW5kSXRlbUtleSxcbiAgICAgICAgZmlsbCxcbiAgICAgICAgZmlsbE9wYWNpdHksXG4gICAgICAgIHN0cm9rZSxcbiAgICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICAgIHN0cm9rZU9wYWNpdHksXG4gICAgICAgIGxpbmVEYXNoLFxuICAgICAgICBsaW5lRGFzaE9mZnNldCxcbiAgICAgICAgY29ybmVyUmFkaXVzLFxuICAgICAgICBoaWdobGlnaHRlZCxcbiAgICAgICAgc2VyaWVzSWQ6IHRoaXMuaWRcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZmlsbDogZm9ybWF0Py5maWxsID8/IGZpbGwsXG4gICAgICBmaWxsT3BhY2l0eTogZm9ybWF0Py5maWxsT3BhY2l0eSA/PyBmaWxsT3BhY2l0eSxcbiAgICAgIHN0cm9rZTogZm9ybWF0Py5zdHJva2UgPz8gc3Ryb2tlLFxuICAgICAgc3Ryb2tlV2lkdGg6IGZvcm1hdD8uc3Ryb2tlV2lkdGggPz8gc3Ryb2tlV2lkdGgsXG4gICAgICBzdHJva2VPcGFjaXR5OiBmb3JtYXQ/LnN0cm9rZU9wYWNpdHkgPz8gc3Ryb2tlT3BhY2l0eSxcbiAgICAgIGxpbmVEYXNoOiBmb3JtYXQ/LmxpbmVEYXNoID8/IGxpbmVEYXNoLFxuICAgICAgbGluZURhc2hPZmZzZXQ6IGZvcm1hdD8ubGluZURhc2hPZmZzZXQgPz8gbGluZURhc2hPZmZzZXQsXG4gICAgICBjb3JuZXJSYWRpdXM6IGZvcm1hdD8uY29ybmVyUmFkaXVzID8/IGNvcm5lclJhZGl1c1xuICAgIH07XG4gIH1cbiAgZ2V0SW5uZXJSYWRpdXMoKSB7XG4gICAgY29uc3QgeyByYWRpdXMgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBpbm5lclJhZGl1c1JhdGlvID0gMSwgaW5uZXJSYWRpdXNPZmZzZXQgPSAwIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgaW5uZXJSYWRpdXMgPSByYWRpdXMgKiBpbm5lclJhZGl1c1JhdGlvICsgaW5uZXJSYWRpdXNPZmZzZXQ7XG4gICAgaWYgKGlubmVyUmFkaXVzID09PSByYWRpdXMgfHwgaW5uZXJSYWRpdXMgPCAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIGlubmVyUmFkaXVzO1xuICB9XG4gIGdldE91dGVyUmFkaXVzKCkge1xuICAgIGNvbnN0IHsgb3V0ZXJSYWRpdXNSYXRpbywgb3V0ZXJSYWRpdXNPZmZzZXQgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5yYWRpdXMgKiBvdXRlclJhZGl1c1JhdGlvICsgb3V0ZXJSYWRpdXNPZmZzZXQsIDApO1xuICB9XG4gIHVwZGF0ZVJhZGl1c1NjYWxlKHJlc2l6ZSkge1xuICAgIGNvbnN0IG5ld1JhbmdlID0gW3RoaXMuZ2V0SW5uZXJSYWRpdXMoKSwgdGhpcy5nZXRPdXRlclJhZGl1cygpXTtcbiAgICB0aGlzLnJhZGl1c1NjYWxlLnJhbmdlID0gbmV3UmFuZ2U7XG4gICAgaWYgKHJlc2l6ZSkge1xuICAgICAgdGhpcy5wcmV2aW91c1JhZGl1c1NjYWxlLnJhbmdlID0gbmV3UmFuZ2U7XG4gICAgfVxuICAgIGNvbnN0IHNldFJhZGlpID0gKGQpID0+ICh7XG4gICAgICAuLi5kLFxuICAgICAgaW5uZXJSYWRpdXM6IE1hdGgubWF4KHRoaXMucmFkaXVzU2NhbGUuY29udmVydCgwKSwgMCksXG4gICAgICBvdXRlclJhZGl1czogTWF0aC5tYXgodGhpcy5yYWRpdXNTY2FsZS5jb252ZXJ0KGQucmFkaXVzKSwgMClcbiAgICB9KTtcbiAgICB0aGlzLm5vZGVEYXRhID0gdGhpcy5ub2RlRGF0YS5tYXAoc2V0UmFkaWkpO1xuICAgIHRoaXMucGhhbnRvbU5vZGVEYXRhID0gdGhpcy5waGFudG9tTm9kZURhdGE/Lm1hcChzZXRSYWRpaSk7XG4gIH1cbiAgZ2V0VGl0bGVUcmFuc2xhdGlvblkoKSB7XG4gICAgY29uc3Qgb3V0ZXJSYWRpdXMgPSBNYXRoLm1heCgwLCB0aGlzLnJhZGl1c1NjYWxlLnJhbmdlWzFdKTtcbiAgICBpZiAob3V0ZXJSYWRpdXMgPT09IDApIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIGNvbnN0IHNwYWNpbmcgPSB0aGlzLnByb3BlcnRpZXMudGl0bGU/LnNwYWNpbmcgPz8gMDtcbiAgICBjb25zdCB0aXRsZU9mZnNldCA9IDIgKyBzcGFjaW5nO1xuICAgIGNvbnN0IGR5ID0gTWF0aC5tYXgoMCwgLW91dGVyUmFkaXVzKTtcbiAgICByZXR1cm4gLW91dGVyUmFkaXVzIC0gdGl0bGVPZmZzZXQgLSBkeTtcbiAgfVxuICBhc3luYyB1cGRhdGUoeyBzZXJpZXNSZWN0IH0pIHtcbiAgICBjb25zdCB7IHRpdGxlIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgbmV3Tm9kZURhdGFEZXBlbmRlbmNpZXMgPSB7XG4gICAgICBzZXJpZXNSZWN0V2lkdGg6IHNlcmllc1JlY3Q/LndpZHRoLFxuICAgICAgc2VyaWVzUmVjdEhlaWdodDogc2VyaWVzUmVjdD8uaGVpZ2h0XG4gICAgfTtcbiAgICBjb25zdCByZXNpemUgPSBqc29uRGlmZih0aGlzLm5vZGVEYXRhRGVwZW5kZW5jaWVzLCBuZXdOb2RlRGF0YURlcGVuZGVuY2llcykgIT0gbnVsbDtcbiAgICBpZiAocmVzaXplKSB7XG4gICAgICB0aGlzLl9ub2RlRGF0YURlcGVuZGVuY2llcyA9IG5ld05vZGVEYXRhRGVwZW5kZW5jaWVzO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLm1heWJlUmVmcmVzaE5vZGVEYXRhKCk7XG4gICAgdGhpcy51cGRhdGVUaXRsZU5vZGVzKCk7XG4gICAgdGhpcy51cGRhdGVSYWRpdXNTY2FsZShyZXNpemUpO1xuICAgIHRoaXMuY29udGVudEdyb3VwLnRyYW5zbGF0aW9uWCA9IHRoaXMuY2VudGVyWDtcbiAgICB0aGlzLmNvbnRlbnRHcm91cC50cmFuc2xhdGlvblkgPSB0aGlzLmNlbnRlclk7XG4gICAgdGhpcy5oaWdobGlnaHRHcm91cC50cmFuc2xhdGlvblggPSB0aGlzLmNlbnRlclg7XG4gICAgdGhpcy5oaWdobGlnaHRHcm91cC50cmFuc2xhdGlvblkgPSB0aGlzLmNlbnRlclk7XG4gICAgdGhpcy5iYWNrZ3JvdW5kR3JvdXAudHJhbnNsYXRpb25YID0gdGhpcy5jZW50ZXJYO1xuICAgIHRoaXMuYmFja2dyb3VuZEdyb3VwLnRyYW5zbGF0aW9uWSA9IHRoaXMuY2VudGVyWTtcbiAgICBpZiAodGhpcy5sYWJlbEdyb3VwKSB7XG4gICAgICB0aGlzLmxhYmVsR3JvdXAudHJhbnNsYXRpb25YID0gdGhpcy5jZW50ZXJYO1xuICAgICAgdGhpcy5sYWJlbEdyb3VwLnRyYW5zbGF0aW9uWSA9IHRoaXMuY2VudGVyWTtcbiAgICB9XG4gICAgaWYgKHRpdGxlKSB7XG4gICAgICBjb25zdCBkeSA9IHRoaXMuZ2V0VGl0bGVUcmFuc2xhdGlvblkoKTtcbiAgICAgIHRpdGxlLm5vZGUueSA9IGlzRmluaXRlKGR5KSA/IGR5IDogMDtcbiAgICAgIGNvbnN0IHRpdGxlQm94ID0gdGl0bGUubm9kZS5nZXRCQm94KCk7XG4gICAgICB0aXRsZS5ub2RlLnZpc2libGUgPSB0aXRsZS5lbmFibGVkICYmIGlzRmluaXRlKGR5KSAmJiAhdGhpcy5iYm94SW50ZXJzZWN0c1N1cnJvdW5kaW5nU2VyaWVzKHRpdGxlQm94KTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBjaXJjbGUgb2YgW3RoaXMuemVyb3N1bUlubmVyUmluZywgdGhpcy56ZXJvc3VtT3V0ZXJSaW5nXSkge1xuICAgICAgY2lyY2xlLmZpbGxPcGFjaXR5ID0gMDtcbiAgICAgIGNpcmNsZS5zdHJva2UgPSB0aGlzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsLmNvbG9yO1xuICAgICAgY2lyY2xlLnN0cm9rZVdpZHRoID0gMTtcbiAgICAgIGNpcmNsZS5zdHJva2VPcGFjaXR5ID0gMTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVOb2RlTWlkUG9pbnQoKTtcbiAgICBhd2FpdCB0aGlzLnVwZGF0ZVNlbGVjdGlvbnMoKTtcbiAgICBhd2FpdCB0aGlzLnVwZGF0ZU5vZGVzKHNlcmllc1JlY3QpO1xuICB9XG4gIHVwZGF0ZVRpdGxlTm9kZXMoKSB7XG4gICAgY29uc3QgeyBvbGRUaXRsZSB9ID0gdGhpcztcbiAgICBjb25zdCB7IHRpdGxlIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgaWYgKG9sZFRpdGxlICE9PSB0aXRsZSkge1xuICAgICAgaWYgKG9sZFRpdGxlKSB7XG4gICAgICAgIHRoaXMubGFiZWxHcm91cD8ucmVtb3ZlQ2hpbGQob2xkVGl0bGUubm9kZSk7XG4gICAgICB9XG4gICAgICBpZiAodGl0bGUpIHtcbiAgICAgICAgdGl0bGUubm9kZS50ZXh0QmFzZWxpbmUgPSBcImJvdHRvbVwiO1xuICAgICAgICB0aGlzLmxhYmVsR3JvdXA/LmFwcGVuZENoaWxkKHRpdGxlLm5vZGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5vbGRUaXRsZSA9IHRpdGxlO1xuICAgIH1cbiAgfVxuICB1cGRhdGVOb2RlTWlkUG9pbnQoKSB7XG4gICAgY29uc3Qgc2V0TWlkUG9pbnQgPSAoZCkgPT4ge1xuICAgICAgY29uc3QgcmFkaXVzID0gZC5pbm5lclJhZGl1cyArIChkLm91dGVyUmFkaXVzIC0gZC5pbm5lclJhZGl1cykgLyAyO1xuICAgICAgZC5taWRQb2ludCA9IHtcbiAgICAgICAgeDogZC5taWRDb3MgKiBNYXRoLm1heCgwLCByYWRpdXMpLFxuICAgICAgICB5OiBkLm1pZFNpbiAqIE1hdGgubWF4KDAsIHJhZGl1cylcbiAgICAgIH07XG4gICAgfTtcbiAgICB0aGlzLm5vZGVEYXRhLmZvckVhY2goc2V0TWlkUG9pbnQpO1xuICAgIHRoaXMucGhhbnRvbU5vZGVEYXRhPy5mb3JFYWNoKHNldE1pZFBvaW50KTtcbiAgfVxuICBhc3luYyB1cGRhdGVTZWxlY3Rpb25zKCkge1xuICAgIGF3YWl0IHRoaXMudXBkYXRlR3JvdXBTZWxlY3Rpb24oKTtcbiAgICB0aGlzLnVwZGF0ZUlubmVyQ2lyY2xlU2VsZWN0aW9uKCk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlR3JvdXBTZWxlY3Rpb24oKSB7XG4gICAgY29uc3Qge1xuICAgICAgaXRlbVNlbGVjdGlvbixcbiAgICAgIGhpZ2hsaWdodFNlbGVjdGlvbixcbiAgICAgIHBoYW50b21TZWxlY3Rpb24sXG4gICAgICBoaWdobGlnaHRMYWJlbFNlbGVjdGlvbixcbiAgICAgIGNhbGxvdXRMYWJlbFNlbGVjdGlvbixcbiAgICAgIGxhYmVsU2VsZWN0aW9uLFxuICAgICAgaW5uZXJMYWJlbHNTZWxlY3Rpb25cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBoaWdobGlnaHRlZE5vZGVEYXRhID0gdGhpcy5ub2RlRGF0YS5tYXAoKGRhdHVtKSA9PiAoe1xuICAgICAgLi4uZGF0dW0sXG4gICAgICAvLyBBbGxvdyBtdXRhYmxlIHNlY3RvckZvcm1hdCwgc28gZm9ybWF0dGVkIHNlY3RvciBzdHlsZXMgY2FuIGJlIHVwZGF0ZWQgYW5kIHZhcmllZFxuICAgICAgLy8gYmV0d2VlbiBub3JtYWwgYW5kIGhpZ2hsaWdodGVkIGNhc2VzLlxuICAgICAgc2VjdG9yRm9ybWF0OiB7IC4uLmRhdHVtLnNlY3RvckZvcm1hdCB9XG4gICAgfSkpO1xuICAgIGNvbnN0IHVwZGF0ZSA9IChzZWxlY3Rpb24sIG5vZGVEYXRhKSA9PiB7XG4gICAgICBzZWxlY3Rpb24udXBkYXRlKG5vZGVEYXRhLCB2b2lkIDAsIChkYXR1bSkgPT4gdGhpcy5nZXREYXR1bUlkKGRhdHVtKSk7XG4gICAgICBpZiAodGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5pc1NraXBwZWQoKSkge1xuICAgICAgICBzZWxlY3Rpb24uY2xlYW51cCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgdXBkYXRlKGl0ZW1TZWxlY3Rpb24sIHRoaXMubm9kZURhdGEpO1xuICAgIHVwZGF0ZShoaWdobGlnaHRTZWxlY3Rpb24sIGhpZ2hsaWdodGVkTm9kZURhdGEpO1xuICAgIHVwZGF0ZShwaGFudG9tU2VsZWN0aW9uLCB0aGlzLnBoYW50b21Ob2RlRGF0YSA/PyBbXSk7XG4gICAgY2FsbG91dExhYmVsU2VsZWN0aW9uLnVwZGF0ZSh0aGlzLmNhbGxvdXROb2RlRGF0YSwgKGdyb3VwKSA9PiB7XG4gICAgICBjb25zdCBsaW5lID0gbmV3IExpbmUoKTtcbiAgICAgIGxpbmUudGFnID0gMCAvKiBDYWxsb3V0ICovO1xuICAgICAgbGluZS5wb2ludGVyRXZlbnRzID0gMSAvKiBOb25lICovO1xuICAgICAgZ3JvdXAuYXBwZW5kQ2hpbGQobGluZSk7XG4gICAgICBjb25zdCB0ZXh0ID0gbmV3IFRleHQoKTtcbiAgICAgIHRleHQudGFnID0gMSAvKiBMYWJlbCAqLztcbiAgICAgIHRleHQucG9pbnRlckV2ZW50cyA9IDEgLyogTm9uZSAqLztcbiAgICAgIGdyb3VwLmFwcGVuZENoaWxkKHRleHQpO1xuICAgIH0pO1xuICAgIGxhYmVsU2VsZWN0aW9uLnVwZGF0ZSh0aGlzLm5vZGVEYXRhKTtcbiAgICBoaWdobGlnaHRMYWJlbFNlbGVjdGlvbi51cGRhdGUoaGlnaGxpZ2h0ZWROb2RlRGF0YSk7XG4gICAgaW5uZXJMYWJlbHNTZWxlY3Rpb24udXBkYXRlKHRoaXMucHJvcGVydGllcy5pbm5lckxhYmVscywgKG5vZGUpID0+IHtcbiAgICAgIG5vZGUucG9pbnRlckV2ZW50cyA9IDEgLyogTm9uZSAqLztcbiAgICB9KTtcbiAgfVxuICB1cGRhdGVJbm5lckNpcmNsZVNlbGVjdGlvbigpIHtcbiAgICBjb25zdCB7IGlubmVyQ2lyY2xlIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgbGV0IHJhZGl1cyA9IDA7XG4gICAgY29uc3QgaW5uZXJSYWRpdXMgPSB0aGlzLmdldElubmVyUmFkaXVzKCk7XG4gICAgaWYgKGlubmVyUmFkaXVzID4gMCkge1xuICAgICAgY29uc3QgY2lyY2xlUmFkaXVzID0gTWF0aC5taW4oaW5uZXJSYWRpdXMsIHRoaXMuZ2V0T3V0ZXJSYWRpdXMoKSk7XG4gICAgICBjb25zdCBhbnRpQWxpYXNpbmdQYWRkaW5nID0gMTtcbiAgICAgIHJhZGl1cyA9IE1hdGguY2VpbChjaXJjbGVSYWRpdXMgKiAyICsgYW50aUFsaWFzaW5nUGFkZGluZyk7XG4gICAgfVxuICAgIGNvbnN0IGRhdHVtcyA9IGlubmVyQ2lyY2xlID8gW3sgcmFkaXVzIH1dIDogW107XG4gICAgdGhpcy5pbm5lckNpcmNsZVNlbGVjdGlvbi51cGRhdGUoZGF0dW1zKTtcbiAgfVxuICBhc3luYyB1cGRhdGVOb2RlcyhzZXJpZXNSZWN0KSB7XG4gICAgY29uc3QgaGlnaGxpZ2h0ZWREYXR1bSA9IHRoaXMuY3R4LmhpZ2hsaWdodE1hbmFnZXIuZ2V0QWN0aXZlSGlnaGxpZ2h0KCk7XG4gICAgY29uc3QgaXNWaXNpYmxlID0gdGhpcy52aXNpYmxlICYmIHRoaXMuc2VyaWVzSXRlbUVuYWJsZWQuaW5jbHVkZXModHJ1ZSk7XG4gICAgdGhpcy5yb290R3JvdXAudmlzaWJsZSA9IGlzVmlzaWJsZTtcbiAgICB0aGlzLmJhY2tncm91bmRHcm91cC52aXNpYmxlID0gaXNWaXNpYmxlO1xuICAgIHRoaXMuY29udGVudEdyb3VwLnZpc2libGUgPSBpc1Zpc2libGU7XG4gICAgdGhpcy5oaWdobGlnaHRHcm91cC52aXNpYmxlID0gaXNWaXNpYmxlICYmIGhpZ2hsaWdodGVkRGF0dW0/LnNlcmllcyA9PT0gdGhpcztcbiAgICB0aGlzLmhpZ2hsaWdodExhYmVsLnZpc2libGUgPSBpc1Zpc2libGUgJiYgaGlnaGxpZ2h0ZWREYXR1bT8uc2VyaWVzID09PSB0aGlzO1xuICAgIHRoaXMubGFiZWxHcm91cC52aXNpYmxlID0gaXNWaXNpYmxlO1xuICAgIHRoaXMuY29udGVudEdyb3VwLm9wYWNpdHkgPSB0aGlzLmdldE9wYWNpdHkoKTtcbiAgICB0aGlzLmlubmVyQ2lyY2xlU2VsZWN0aW9uLmVhY2goKG5vZGUsIHsgcmFkaXVzIH0pID0+IHtcbiAgICAgIG5vZGUuc2V0UHJvcGVydGllcyh7XG4gICAgICAgIGZpbGw6IHRoaXMucHJvcGVydGllcy5pbm5lckNpcmNsZT8uZmlsbCxcbiAgICAgICAgb3BhY2l0eTogdGhpcy5wcm9wZXJ0aWVzLmlubmVyQ2lyY2xlPy5maWxsT3BhY2l0eSxcbiAgICAgICAgc2l6ZTogcmFkaXVzXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBjb25zdCBhbmltYXRpb25EaXNhYmxlZCA9IHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuaXNTa2lwcGVkKCk7XG4gICAgY29uc3QgdXBkYXRlU2VjdG9yRm4gPSAoc2VjdG9yLCBkYXR1bSwgX2luZGV4LCBpc0RhdHVtSGlnaGxpZ2h0ZWQpID0+IHtcbiAgICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMuZ2V0U2VjdG9yRm9ybWF0KGRhdHVtLmRhdHVtLCBkYXR1bS5pdGVtSWQsIGlzRGF0dW1IaWdobGlnaHRlZCk7XG4gICAgICBkYXR1bS5zZWN0b3JGb3JtYXQuZmlsbCA9IGZvcm1hdC5maWxsO1xuICAgICAgZGF0dW0uc2VjdG9yRm9ybWF0LnN0cm9rZSA9IGZvcm1hdC5zdHJva2U7XG4gICAgICBpZiAoYW5pbWF0aW9uRGlzYWJsZWQpIHtcbiAgICAgICAgc2VjdG9yLnN0YXJ0QW5nbGUgPSBkYXR1bS5zdGFydEFuZ2xlO1xuICAgICAgICBzZWN0b3IuZW5kQW5nbGUgPSBkYXR1bS5lbmRBbmdsZTtcbiAgICAgICAgc2VjdG9yLmlubmVyUmFkaXVzID0gZGF0dW0uaW5uZXJSYWRpdXM7XG4gICAgICAgIHNlY3Rvci5vdXRlclJhZGl1cyA9IGRhdHVtLm91dGVyUmFkaXVzO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGF0dW1IaWdobGlnaHRlZCB8fCBhbmltYXRpb25EaXNhYmxlZCkge1xuICAgICAgICBzZWN0b3IuZmlsbCA9IGZvcm1hdC5maWxsO1xuICAgICAgICBzZWN0b3Iuc3Ryb2tlID0gZm9ybWF0LnN0cm9rZTtcbiAgICAgIH1cbiAgICAgIHNlY3Rvci5zdHJva2VXaWR0aCA9IGZvcm1hdC5zdHJva2VXaWR0aDtcbiAgICAgIHNlY3Rvci5maWxsT3BhY2l0eSA9IGZvcm1hdC5maWxsT3BhY2l0eTtcbiAgICAgIHNlY3Rvci5zdHJva2VPcGFjaXR5ID0gZm9ybWF0LnN0cm9rZU9wYWNpdHk7XG4gICAgICBzZWN0b3IubGluZURhc2ggPSBmb3JtYXQubGluZURhc2g7XG4gICAgICBzZWN0b3IubGluZURhc2hPZmZzZXQgPSBmb3JtYXQubGluZURhc2hPZmZzZXQ7XG4gICAgICBzZWN0b3IuY29ybmVyUmFkaXVzID0gZm9ybWF0LmNvcm5lclJhZGl1cztcbiAgICAgIHNlY3Rvci5maWxsU2hhZG93ID0gdGhpcy5wcm9wZXJ0aWVzLnNoYWRvdztcbiAgICAgIGNvbnN0IGluc2V0ID0gTWF0aC5tYXgoXG4gICAgICAgICh0aGlzLnByb3BlcnRpZXMuc2VjdG9yU3BhY2luZyArIChmb3JtYXQuc3Ryb2tlICE9IG51bGwgPyBmb3JtYXQuc3Ryb2tlV2lkdGggOiAwKSkgLyAyLFxuICAgICAgICAwXG4gICAgICApO1xuICAgICAgc2VjdG9yLmluc2V0ID0gaW5zZXQ7XG4gICAgICBzZWN0b3IubGluZUpvaW4gPSB0aGlzLnByb3BlcnRpZXMuc2VjdG9yU3BhY2luZyA+PSAwIHx8IGluc2V0ID4gMCA/IFwibWl0ZXJcIiA6IFwicm91bmRcIjtcbiAgICB9O1xuICAgIHRoaXMuaXRlbVNlbGVjdGlvbi5lYWNoKChub2RlLCBkYXR1bSwgaW5kZXgpID0+IHVwZGF0ZVNlY3RvckZuKG5vZGUsIGRhdHVtLCBpbmRleCwgZmFsc2UpKTtcbiAgICB0aGlzLmhpZ2hsaWdodFNlbGVjdGlvbi5lYWNoKChub2RlLCBkYXR1bSwgaW5kZXgpID0+IHtcbiAgICAgIHVwZGF0ZVNlY3RvckZuKG5vZGUsIGRhdHVtLCBpbmRleCwgdHJ1ZSk7XG4gICAgICBub2RlLnZpc2libGUgPSBkYXR1bS5pdGVtSWQgPT09IGhpZ2hsaWdodGVkRGF0dW0/Lml0ZW1JZDtcbiAgICB9KTtcbiAgICB0aGlzLnBoYW50b21TZWxlY3Rpb24uZWFjaCgobm9kZSwgZGF0dW0sIGluZGV4KSA9PiB1cGRhdGVTZWN0b3JGbihub2RlLCBkYXR1bSwgaW5kZXgsIGZhbHNlKSk7XG4gICAgdGhpcy51cGRhdGVDYWxsb3V0TGluZU5vZGVzKCk7XG4gICAgdGhpcy51cGRhdGVDYWxsb3V0TGFiZWxOb2RlcyhzZXJpZXNSZWN0KTtcbiAgICB0aGlzLnVwZGF0ZVNlY3RvckxhYmVsTm9kZXMoKTtcbiAgICB0aGlzLnVwZGF0ZUlubmVyTGFiZWxOb2RlcygpO1xuICAgIHRoaXMudXBkYXRlWmVyb3N1bVJpbmdzKCk7XG4gICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwidXBkYXRlXCIpO1xuICB9XG4gIHVwZGF0ZUNhbGxvdXRMaW5lTm9kZXMoKSB7XG4gICAgY29uc3QgeyBjYWxsb3V0TGluZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGNhbGxvdXRMZW5ndGggPSBjYWxsb3V0TGluZS5sZW5ndGg7XG4gICAgY29uc3QgY2FsbG91dFN0cm9rZVdpZHRoID0gY2FsbG91dExpbmUuc3Ryb2tlV2lkdGg7XG4gICAgY29uc3QgY2FsbG91dENvbG9ycyA9IGNhbGxvdXRMaW5lLmNvbG9ycyA/PyB0aGlzLnByb3BlcnRpZXMuc3Ryb2tlcztcbiAgICBjb25zdCB7IG9mZnNldDogb2Zmc2V0NCB9ID0gdGhpcy5wcm9wZXJ0aWVzLmNhbGxvdXRMYWJlbDtcbiAgICB0aGlzLmNhbGxvdXRMYWJlbFNlbGVjdGlvbi5zZWxlY3RCeVRhZygwIC8qIENhbGxvdXQgKi8pLmZvckVhY2goKGxpbmUsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBkYXR1bSA9IGxpbmUuZGF0dW07XG4gICAgICBjb25zdCB7IGNhbGxvdXRMYWJlbDogbGFiZWwsIG91dGVyUmFkaXVzIH0gPSBkYXR1bTtcbiAgICAgIGlmIChsYWJlbD8udGV4dCAmJiAhbGFiZWwuaGlkZGVuICYmIG91dGVyUmFkaXVzICE9PSAwKSB7XG4gICAgICAgIGxpbmUudmlzaWJsZSA9IHRydWU7XG4gICAgICAgIGxpbmUuc3Ryb2tlV2lkdGggPSBjYWxsb3V0U3Ryb2tlV2lkdGg7XG4gICAgICAgIGxpbmUuc3Ryb2tlID0gY2FsbG91dENvbG9yc1tpbmRleCAlIGNhbGxvdXRDb2xvcnMubGVuZ3RoXTtcbiAgICAgICAgbGluZS5maWxsID0gdm9pZCAwO1xuICAgICAgICBjb25zdCB4MSA9IGRhdHVtLm1pZENvcyAqIG91dGVyUmFkaXVzO1xuICAgICAgICBjb25zdCB5MSA9IGRhdHVtLm1pZFNpbiAqIG91dGVyUmFkaXVzO1xuICAgICAgICBsZXQgeDIgPSBkYXR1bS5taWRDb3MgKiAob3V0ZXJSYWRpdXMgKyBjYWxsb3V0TGVuZ3RoKTtcbiAgICAgICAgbGV0IHkyID0gZGF0dW0ubWlkU2luICogKG91dGVyUmFkaXVzICsgY2FsbG91dExlbmd0aCk7XG4gICAgICAgIGNvbnN0IGlzTW92ZWQgPSBsYWJlbC5jb2xsaXNpb25UZXh0QWxpZ24gPz8gbGFiZWwuY29sbGlzaW9uT2Zmc2V0WSAhPT0gMDtcbiAgICAgICAgaWYgKGlzTW92ZWQgJiYgbGFiZWwuYm94ICE9IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBib3ggPSBsYWJlbC5ib3g7XG4gICAgICAgICAgbGV0IGN4ID0geDI7XG4gICAgICAgICAgbGV0IGN5ID0geTI7XG4gICAgICAgICAgaWYgKHgyIDwgYm94LngpIHtcbiAgICAgICAgICAgIGN4ID0gYm94Lng7XG4gICAgICAgICAgfSBlbHNlIGlmICh4MiA+IGJveC54ICsgYm94LndpZHRoKSB7XG4gICAgICAgICAgICBjeCA9IGJveC54ICsgYm94LndpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoeTIgPCBib3gueSkge1xuICAgICAgICAgICAgY3kgPSBib3gueTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHkyID4gYm94LnkgKyBib3guaGVpZ2h0KSB7XG4gICAgICAgICAgICBjeSA9IGJveC55ICsgYm94LmhlaWdodDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZHggPSBjeCAtIHgyO1xuICAgICAgICAgIGNvbnN0IGR5ID0gY3kgLSB5MjtcbiAgICAgICAgICBjb25zdCBsZW5ndGgyID0gTWF0aC5zcXJ0KE1hdGgucG93KGR4LCAyKSArIE1hdGgucG93KGR5LCAyKSk7XG4gICAgICAgICAgY29uc3QgcGFkZGVkTGVuZ3RoID0gbGVuZ3RoMiAtIG9mZnNldDQ7XG4gICAgICAgICAgaWYgKHBhZGRlZExlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHgyID0geDIgKyBkeCAqIHBhZGRlZExlbmd0aCAvIGxlbmd0aDI7XG4gICAgICAgICAgICB5MiA9IHkyICsgZHkgKiBwYWRkZWRMZW5ndGggLyBsZW5ndGgyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsaW5lLngxID0geDE7XG4gICAgICAgIGxpbmUueTEgPSB5MTtcbiAgICAgICAgbGluZS54MiA9IHgyO1xuICAgICAgICBsaW5lLnkyID0geTI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaW5lLnZpc2libGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXRMYWJlbE92ZXJmbG93KHRleHQsIGJveCwgc2VyaWVzUmVjdCkge1xuICAgIGNvbnN0IHNlcmllc0xlZnQgPSBzZXJpZXNSZWN0LnggLSB0aGlzLmNlbnRlclg7XG4gICAgY29uc3Qgc2VyaWVzUmlnaHQgPSBzZXJpZXNSZWN0LnggKyBzZXJpZXNSZWN0LndpZHRoIC0gdGhpcy5jZW50ZXJYO1xuICAgIGNvbnN0IHNlcmllc1RvcCA9IHNlcmllc1JlY3QueSAtIHRoaXMuY2VudGVyWTtcbiAgICBjb25zdCBzZXJpZXNCb3R0b20gPSBzZXJpZXNSZWN0LnkgKyBzZXJpZXNSZWN0LmhlaWdodCAtIHRoaXMuY2VudGVyWTtcbiAgICBjb25zdCBlcnJQeCA9IDE7XG4gICAgbGV0IHZpc2libGVUZXh0UGFydCA9IDE7XG4gICAgaWYgKGJveC54ICsgZXJyUHggPCBzZXJpZXNMZWZ0KSB7XG4gICAgICB2aXNpYmxlVGV4dFBhcnQgPSAoYm94LnggKyBib3gud2lkdGggLSBzZXJpZXNMZWZ0KSAvIGJveC53aWR0aDtcbiAgICB9IGVsc2UgaWYgKGJveC54ICsgYm94LndpZHRoIC0gZXJyUHggPiBzZXJpZXNSaWdodCkge1xuICAgICAgdmlzaWJsZVRleHRQYXJ0ID0gKHNlcmllc1JpZ2h0IC0gYm94LngpIC8gYm94LndpZHRoO1xuICAgIH1cbiAgICBjb25zdCBoYXNWZXJ0aWNhbE92ZXJmbG93ID0gYm94LnkgKyBlcnJQeCA8IHNlcmllc1RvcCB8fCBib3gueSArIGJveC5oZWlnaHQgLSBlcnJQeCA+IHNlcmllc0JvdHRvbTtcbiAgICBjb25zdCB0ZXh0TGVuZ3RoID0gdmlzaWJsZVRleHRQYXJ0ID09PSAxID8gdGV4dC5sZW5ndGggOiBNYXRoLmZsb29yKHRleHQubGVuZ3RoICogdmlzaWJsZVRleHRQYXJ0KSAtIDE7XG4gICAgY29uc3QgaGFzU3Vycm91bmRpbmdTZXJpZXNPdmVyZmxvdyA9IHRoaXMuYmJveEludGVyc2VjdHNTdXJyb3VuZGluZ1Nlcmllcyhib3gpO1xuICAgIHJldHVybiB7IHRleHRMZW5ndGgsIGhhc1ZlcnRpY2FsT3ZlcmZsb3csIGhhc1N1cnJvdW5kaW5nU2VyaWVzT3ZlcmZsb3cgfTtcbiAgfVxuICBiYm94SW50ZXJzZWN0c1N1cnJvdW5kaW5nU2VyaWVzKGJveCkge1xuICAgIGNvbnN0IHsgc3Vycm91bmRpbmdSYWRpdXMgfSA9IHRoaXM7XG4gICAgaWYgKHN1cnJvdW5kaW5nUmFkaXVzID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgY29ybmVycyA9IFtcbiAgICAgIHsgeDogYm94LngsIHk6IGJveC55IH0sXG4gICAgICB7IHg6IGJveC54ICsgYm94LndpZHRoLCB5OiBib3gueSB9LFxuICAgICAgeyB4OiBib3gueCArIGJveC53aWR0aCwgeTogYm94LnkgKyBib3guaGVpZ2h0IH0sXG4gICAgICB7IHg6IGJveC54LCB5OiBib3gueSArIGJveC5oZWlnaHQgfVxuICAgIF07XG4gICAgY29uc3Qgc3VyMiA9IHN1cnJvdW5kaW5nUmFkaXVzICoqIDI7XG4gICAgcmV0dXJuIGNvcm5lcnMuc29tZSgoY29ybmVyKSA9PiBjb3JuZXIueCAqKiAyICsgY29ybmVyLnkgKiogMiA+IHN1cjIpO1xuICB9XG4gIGNvbXB1dGVDYWxsb3V0TGFiZWxDb2xsaXNpb25PZmZzZXRzKCkge1xuICAgIGNvbnN0IHsgcmFkaXVzU2NhbGUgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBjYWxsb3V0TGFiZWwsIGNhbGxvdXRMaW5lIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgeyBvZmZzZXQ6IG9mZnNldDQsIG1pblNwYWNpbmcgfSA9IGNhbGxvdXRMYWJlbDtcbiAgICBjb25zdCBpbm5lclJhZGl1cyA9IHJhZGl1c1NjYWxlLmNvbnZlcnQoMCk7XG4gICAgY29uc3Qgc2hvdWxkU2tpcCA9IChkYXR1bSkgPT4ge1xuICAgICAgY29uc3QgbGFiZWwgPSBkYXR1bS5jYWxsb3V0TGFiZWw7XG4gICAgICByZXR1cm4gIWxhYmVsIHx8IGRhdHVtLm91dGVyUmFkaXVzID09PSAwO1xuICAgIH07XG4gICAgY29uc3QgZnVsbERhdGEgPSB0aGlzLmNhbGxvdXROb2RlRGF0YTtcbiAgICBjb25zdCBkYXRhID0gZnVsbERhdGEuZmlsdGVyKCh0KSA9PiAhc2hvdWxkU2tpcCh0KSk7XG4gICAgZGF0YS5mb3JFYWNoKChkYXR1bSkgPT4ge1xuICAgICAgY29uc3QgbGFiZWwgPSBkYXR1bS5jYWxsb3V0TGFiZWw7XG4gICAgICBpZiAobGFiZWwgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgbGFiZWwuaGlkZGVuID0gZmFsc2U7XG4gICAgICBsYWJlbC5jb2xsaXNpb25UZXh0QWxpZ24gPSB2b2lkIDA7XG4gICAgICBsYWJlbC5jb2xsaXNpb25PZmZzZXRZID0gMDtcbiAgICB9KTtcbiAgICBpZiAoZGF0YS5sZW5ndGggPD0gMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsZWZ0TGFiZWxzID0gZGF0YS5maWx0ZXIoKGQpID0+IGQubWlkQ29zIDwgMCkuc29ydCgoYSwgYikgPT4gYS5taWRTaW4gLSBiLm1pZFNpbik7XG4gICAgY29uc3QgcmlnaHRMYWJlbHMgPSBkYXRhLmZpbHRlcigoZCkgPT4gZC5taWRDb3MgPj0gMCkuc29ydCgoYSwgYikgPT4gYS5taWRTaW4gLSBiLm1pZFNpbik7XG4gICAgY29uc3QgdG9wTGFiZWxzID0gZGF0YS5maWx0ZXIoKGQpID0+IGQubWlkU2luIDwgMCAmJiBkLmNhbGxvdXRMYWJlbD8udGV4dEFsaWduID09PSBcImNlbnRlclwiKS5zb3J0KChhLCBiKSA9PiBhLm1pZENvcyAtIGIubWlkQ29zKTtcbiAgICBjb25zdCBib3R0b21MYWJlbHMgPSBkYXRhLmZpbHRlcigoZCkgPT4gZC5taWRTaW4gPj0gMCAmJiBkLmNhbGxvdXRMYWJlbD8udGV4dEFsaWduID09PSBcImNlbnRlclwiKS5zb3J0KChhLCBiKSA9PiBhLm1pZENvcyAtIGIubWlkQ29zKTtcbiAgICBjb25zdCBnZXRUZXh0QkJveCA9IChkYXR1bSkgPT4ge1xuICAgICAgY29uc3QgbGFiZWwgPSBkYXR1bS5jYWxsb3V0TGFiZWw7XG4gICAgICBpZiAobGFiZWwgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIEJCb3guemVyby5jbG9uZSgpO1xuICAgICAgY29uc3QgbGFiZWxSYWRpdXMgPSBkYXR1bS5vdXRlclJhZGl1cyArIGNhbGxvdXRMaW5lLmxlbmd0aCArIG9mZnNldDQ7XG4gICAgICBjb25zdCB4ID0gZGF0dW0ubWlkQ29zICogbGFiZWxSYWRpdXM7XG4gICAgICBjb25zdCB5ID0gZGF0dW0ubWlkU2luICogbGFiZWxSYWRpdXMgKyBsYWJlbC5jb2xsaXNpb25PZmZzZXRZO1xuICAgICAgY29uc3QgdGV4dEFsaWduID0gbGFiZWwuY29sbGlzaW9uVGV4dEFsaWduID8/IGxhYmVsLnRleHRBbGlnbjtcbiAgICAgIGNvbnN0IHRleHRCYXNlbGluZSA9IGxhYmVsLnRleHRCYXNlbGluZTtcbiAgICAgIHJldHVybiBUZXh0LmNvbXB1dGVCQm94KGxhYmVsLnRleHQsIHgsIHksIHtcbiAgICAgICAgZm9udDogdGhpcy5wcm9wZXJ0aWVzLmNhbGxvdXRMYWJlbCxcbiAgICAgICAgdGV4dEFsaWduLFxuICAgICAgICB0ZXh0QmFzZWxpbmVcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgYXZvaWROZWlnaGJvdXJZQ29sbGlzaW9uID0gKGxhYmVsLCBuZXh0LCBkaXJlY3Rpb24pID0+IHtcbiAgICAgIGNvbnN0IGJveCA9IGdldFRleHRCQm94KGxhYmVsKS5ncm93KG1pblNwYWNpbmcgLyAyKTtcbiAgICAgIGNvbnN0IG90aGVyID0gZ2V0VGV4dEJCb3gobmV4dCkuZ3JvdyhtaW5TcGFjaW5nIC8gMik7XG4gICAgICBjb25zdCBjb2xsaWRlc09yQmVoaW5kID0gYm94LnggPCBvdGhlci54ICsgb3RoZXIud2lkdGggJiYgYm94LnggKyBib3gud2lkdGggPiBvdGhlci54ICYmIChkaXJlY3Rpb24gPT09IFwidG8tdG9wXCIgPyBib3gueSA8IG90aGVyLnkgKyBvdGhlci5oZWlnaHQgOiBib3gueSArIGJveC5oZWlnaHQgPiBvdGhlci55KTtcbiAgICAgIGlmIChjb2xsaWRlc09yQmVoaW5kKSB7XG4gICAgICAgIGNvbnN0IGR5ID0gZGlyZWN0aW9uID09PSBcInRvLXRvcFwiID8gYm94LnkgLSBvdGhlci55IC0gb3RoZXIuaGVpZ2h0IDogYm94LnkgKyBib3guaGVpZ2h0IC0gb3RoZXIueTtcbiAgICAgICAgbmV4dC5jYWxsb3V0TGFiZWwuY29sbGlzaW9uT2Zmc2V0WSA9IGR5O1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgYXZvaWRZQ29sbGlzaW9ucyA9IChsYWJlbHMpID0+IHtcbiAgICAgIGNvbnN0IG1pZExhYmVsID0gbGFiZWxzLnNsaWNlKCkuc29ydCgoYSwgYikgPT4gTWF0aC5hYnMoYS5taWRTaW4pIC0gTWF0aC5hYnMoYi5taWRTaW4pKVswXTtcbiAgICAgIGNvbnN0IG1pZEluZGV4ID0gbGFiZWxzLmluZGV4T2YobWlkTGFiZWwpO1xuICAgICAgZm9yIChsZXQgaSA9IG1pZEluZGV4IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgcHJldiA9IGxhYmVsc1tpICsgMV07XG4gICAgICAgIGNvbnN0IG5leHQgPSBsYWJlbHNbaV07XG4gICAgICAgIGF2b2lkTmVpZ2hib3VyWUNvbGxpc2lvbihwcmV2LCBuZXh0LCBcInRvLXRvcFwiKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSBtaWRJbmRleCArIDE7IGkgPCBsYWJlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcHJldiA9IGxhYmVsc1tpIC0gMV07XG4gICAgICAgIGNvbnN0IG5leHQgPSBsYWJlbHNbaV07XG4gICAgICAgIGF2b2lkTmVpZ2hib3VyWUNvbGxpc2lvbihwcmV2LCBuZXh0LCBcInRvLWJvdHRvbVwiKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGF2b2lkWENvbGxpc2lvbnMgPSAobGFiZWxzKSA9PiB7XG4gICAgICBjb25zdCBsYWJlbHNDb2xsaWRlTGFiZWxzQnlZID0gZGF0YS5zb21lKChkYXR1bSkgPT4gZGF0dW0uY2FsbG91dExhYmVsLmNvbGxpc2lvbk9mZnNldFkgIT09IDApO1xuICAgICAgY29uc3QgYm94ZXMgPSBsYWJlbHMubWFwKChsYWJlbCkgPT4gZ2V0VGV4dEJCb3gobGFiZWwpKTtcbiAgICAgIGNvbnN0IHBhZGRlZEJveGVzID0gYm94ZXMubWFwKChib3gpID0+IGJveC5jbG9uZSgpLmdyb3cobWluU3BhY2luZyAvIDIpKTtcbiAgICAgIGxldCBsYWJlbHNDb2xsaWRlTGFiZWxzQnlYID0gZmFsc2U7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZGRlZEJveGVzLmxlbmd0aCAmJiAhbGFiZWxzQ29sbGlkZUxhYmVsc0J5WDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGJveCA9IHBhZGRlZEJveGVzW2ldO1xuICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBsYWJlbHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjb25zdCBvdGhlciA9IHBhZGRlZEJveGVzW2pdO1xuICAgICAgICAgIGlmIChib3guY29sbGlkZXNCQm94KG90aGVyKSkge1xuICAgICAgICAgICAgbGFiZWxzQ29sbGlkZUxhYmVsc0J5WCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHNlY3RvcnMgPSBmdWxsRGF0YS5tYXAoKGRhdHVtKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIG91dGVyUmFkaXVzIH0gPSBkYXR1bTtcbiAgICAgICAgcmV0dXJuIHsgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cyB9O1xuICAgICAgfSk7XG4gICAgICBjb25zdCBsYWJlbHNDb2xsaWRlU2VjdG9ycyA9IGJveGVzLnNvbWUoKGJveCkgPT4ge1xuICAgICAgICByZXR1cm4gc2VjdG9ycy5zb21lKChzZWN0b3IpID0+IGJveENvbGxpZGVzU2VjdG9yKGJveCwgc2VjdG9yKSk7XG4gICAgICB9KTtcbiAgICAgIGlmICghbGFiZWxzQ29sbGlkZUxhYmVsc0J5WCAmJiAhbGFiZWxzQ29sbGlkZUxhYmVsc0J5WSAmJiAhbGFiZWxzQ29sbGlkZVNlY3RvcnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGFiZWxzLmZpbHRlcigoZCkgPT4gZC5jYWxsb3V0TGFiZWwudGV4dEFsaWduID09PSBcImNlbnRlclwiKS5mb3JFYWNoKChkKSA9PiB7XG4gICAgICAgIGNvbnN0IGxhYmVsID0gZC5jYWxsb3V0TGFiZWw7XG4gICAgICAgIGlmIChkLm1pZENvcyA8IDApIHtcbiAgICAgICAgICBsYWJlbC5jb2xsaXNpb25UZXh0QWxpZ24gPSBcInJpZ2h0XCI7XG4gICAgICAgIH0gZWxzZSBpZiAoZC5taWRDb3MgPiAwKSB7XG4gICAgICAgICAgbGFiZWwuY29sbGlzaW9uVGV4dEFsaWduID0gXCJsZWZ0XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGFiZWwuY29sbGlzaW9uVGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBhdm9pZFlDb2xsaXNpb25zKGxlZnRMYWJlbHMpO1xuICAgIGF2b2lkWUNvbGxpc2lvbnMocmlnaHRMYWJlbHMpO1xuICAgIGF2b2lkWENvbGxpc2lvbnModG9wTGFiZWxzKTtcbiAgICBhdm9pZFhDb2xsaXNpb25zKGJvdHRvbUxhYmVscyk7XG4gIH1cbiAgdXBkYXRlQ2FsbG91dExhYmVsTm9kZXMoc2VyaWVzUmVjdCkge1xuICAgIGNvbnN0IHsgcmFkaXVzU2NhbGUgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBjYWxsb3V0TGFiZWwsIGNhbGxvdXRMaW5lIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgY2FsbG91dExlbmd0aCA9IGNhbGxvdXRMaW5lLmxlbmd0aDtcbiAgICBjb25zdCB7IG9mZnNldDogb2Zmc2V0NCwgY29sb3IgfSA9IGNhbGxvdXRMYWJlbDtcbiAgICBjb25zdCB0ZW1wVGV4dE5vZGUgPSBuZXcgVGV4dCgpO1xuICAgIHRoaXMuY2FsbG91dExhYmVsU2VsZWN0aW9uLnNlbGVjdEJ5VGFnKDEgLyogTGFiZWwgKi8pLmZvckVhY2goKHRleHQpID0+IHtcbiAgICAgIGNvbnN0IHsgZGF0dW0gfSA9IHRleHQ7XG4gICAgICBjb25zdCBsYWJlbCA9IGRhdHVtLmNhbGxvdXRMYWJlbDtcbiAgICAgIGNvbnN0IHJhZGl1cyA9IHJhZGl1c1NjYWxlLmNvbnZlcnQoZGF0dW0ucmFkaXVzKTtcbiAgICAgIGNvbnN0IG91dGVyUmFkaXVzID0gTWF0aC5tYXgoMCwgcmFkaXVzKTtcbiAgICAgIGlmICghbGFiZWw/LnRleHQgfHwgb3V0ZXJSYWRpdXMgPT09IDAgfHwgbGFiZWwuaGlkZGVuKSB7XG4gICAgICAgIHRleHQudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBsYWJlbFJhZGl1cyA9IG91dGVyUmFkaXVzICsgY2FsbG91dExlbmd0aCArIG9mZnNldDQ7XG4gICAgICBjb25zdCB4ID0gZGF0dW0ubWlkQ29zICogbGFiZWxSYWRpdXM7XG4gICAgICBjb25zdCB5ID0gZGF0dW0ubWlkU2luICogbGFiZWxSYWRpdXMgKyBsYWJlbC5jb2xsaXNpb25PZmZzZXRZO1xuICAgICAgY29uc3QgYWxpZ24gPSB7XG4gICAgICAgIHRleHRBbGlnbjogbGFiZWwuY29sbGlzaW9uVGV4dEFsaWduID8/IGxhYmVsLnRleHRBbGlnbixcbiAgICAgICAgdGV4dEJhc2VsaW5lOiBsYWJlbC50ZXh0QmFzZWxpbmVcbiAgICAgIH07XG4gICAgICB0ZW1wVGV4dE5vZGUudGV4dCA9IGxhYmVsLnRleHQ7XG4gICAgICB0ZW1wVGV4dE5vZGUueCA9IHg7XG4gICAgICB0ZW1wVGV4dE5vZGUueSA9IHk7XG4gICAgICB0ZW1wVGV4dE5vZGUuc2V0Rm9udCh0aGlzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsKTtcbiAgICAgIHRlbXBUZXh0Tm9kZS5zZXRBbGlnbihhbGlnbik7XG4gICAgICBjb25zdCBib3ggPSB0ZW1wVGV4dE5vZGUuZ2V0QkJveCgpO1xuICAgICAgbGV0IGRpc3BsYXlUZXh0ID0gbGFiZWwudGV4dDtcbiAgICAgIGxldCB2aXNpYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChjYWxsb3V0TGFiZWwuYXZvaWRDb2xsaXNpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgdGV4dExlbmd0aCwgaGFzVmVydGljYWxPdmVyZmxvdyB9ID0gdGhpcy5nZXRMYWJlbE92ZXJmbG93KGxhYmVsLnRleHQsIGJveCwgc2VyaWVzUmVjdCk7XG4gICAgICAgIGRpc3BsYXlUZXh0ID0gbGFiZWwudGV4dC5sZW5ndGggPT09IHRleHRMZW5ndGggPyBsYWJlbC50ZXh0IDogYCR7bGFiZWwudGV4dC5zdWJzdHJpbmcoMCwgdGV4dExlbmd0aCl9XFx1MjAyNmA7XG4gICAgICAgIHZpc2libGUgPSAhaGFzVmVydGljYWxPdmVyZmxvdztcbiAgICAgIH1cbiAgICAgIHRleHQudGV4dCA9IGRpc3BsYXlUZXh0O1xuICAgICAgdGV4dC54ID0geDtcbiAgICAgIHRleHQueSA9IHk7XG4gICAgICB0ZXh0LnNldEZvbnQodGhpcy5wcm9wZXJ0aWVzLmNhbGxvdXRMYWJlbCk7XG4gICAgICB0ZXh0LnNldEFsaWduKGFsaWduKTtcbiAgICAgIHRleHQuZmlsbCA9IGNvbG9yO1xuICAgICAgdGV4dC52aXNpYmxlID0gdmlzaWJsZTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBjb21wdXRlTGFiZWxzQkJveChvcHRpb25zLCBzZXJpZXNSZWN0KSB7XG4gICAgY29uc3QgeyBjYWxsb3V0TGFiZWwsIGNhbGxvdXRMaW5lIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgY2FsbG91dExlbmd0aCA9IGNhbGxvdXRMaW5lLmxlbmd0aDtcbiAgICBjb25zdCB7IG9mZnNldDogb2Zmc2V0NCwgbWF4Q29sbGlzaW9uT2Zmc2V0LCBtaW5TcGFjaW5nIH0gPSBjYWxsb3V0TGFiZWw7XG4gICAgaWYgKCFjYWxsb3V0TGFiZWwuYXZvaWRDb2xsaXNpb25zKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5tYXliZVJlZnJlc2hOb2RlRGF0YSgpO1xuICAgIHRoaXMudXBkYXRlUmFkaXVzU2NhbGUoZmFsc2UpO1xuICAgIHRoaXMuY29tcHV0ZUNhbGxvdXRMYWJlbENvbGxpc2lvbk9mZnNldHMoKTtcbiAgICBjb25zdCB0ZXh0Qm94ZXMgPSBbXTtcbiAgICBjb25zdCB0ZXh0ID0gbmV3IFRleHQoKTtcbiAgICBsZXQgdGl0bGVCb3g7XG4gICAgY29uc3QgeyB0aXRsZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGlmICh0aXRsZT8udGV4dCAmJiB0aXRsZS5lbmFibGVkKSB7XG4gICAgICBjb25zdCBkeSA9IHRoaXMuZ2V0VGl0bGVUcmFuc2xhdGlvblkoKTtcbiAgICAgIGlmIChpc0Zpbml0ZShkeSkpIHtcbiAgICAgICAgdGV4dC50ZXh0ID0gdGl0bGUudGV4dDtcbiAgICAgICAgdGV4dC54ID0gMDtcbiAgICAgICAgdGV4dC55ID0gZHk7XG4gICAgICAgIHRleHQuc2V0Rm9udCh0aXRsZSk7XG4gICAgICAgIHRleHQuc2V0QWxpZ24oe1xuICAgICAgICAgIHRleHRCYXNlbGluZTogXCJib3R0b21cIixcbiAgICAgICAgICB0ZXh0QWxpZ246IFwiY2VudGVyXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHRpdGxlQm94ID0gdGV4dC5nZXRCQm94KCk7XG4gICAgICAgIHRleHRCb3hlcy5wdXNoKHRpdGxlQm94KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jYWxsb3V0Tm9kZURhdGEuZm9yRWFjaCgoZGF0dW0pID0+IHtcbiAgICAgIGNvbnN0IGxhYmVsID0gZGF0dW0uY2FsbG91dExhYmVsO1xuICAgICAgaWYgKCFsYWJlbCB8fCBkYXR1bS5vdXRlclJhZGl1cyA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxhYmVsUmFkaXVzID0gZGF0dW0ub3V0ZXJSYWRpdXMgKyBjYWxsb3V0TGVuZ3RoICsgb2Zmc2V0NDtcbiAgICAgIGNvbnN0IHggPSBkYXR1bS5taWRDb3MgKiBsYWJlbFJhZGl1cztcbiAgICAgIGNvbnN0IHkgPSBkYXR1bS5taWRTaW4gKiBsYWJlbFJhZGl1cyArIGxhYmVsLmNvbGxpc2lvbk9mZnNldFk7XG4gICAgICB0ZXh0LnRleHQgPSBsYWJlbC50ZXh0O1xuICAgICAgdGV4dC54ID0geDtcbiAgICAgIHRleHQueSA9IHk7XG4gICAgICB0ZXh0LnNldEZvbnQodGhpcy5wcm9wZXJ0aWVzLmNhbGxvdXRMYWJlbCk7XG4gICAgICB0ZXh0LnNldEFsaWduKHtcbiAgICAgICAgdGV4dEFsaWduOiBsYWJlbC5jb2xsaXNpb25UZXh0QWxpZ24gPz8gbGFiZWwudGV4dEFsaWduLFxuICAgICAgICB0ZXh0QmFzZWxpbmU6IGxhYmVsLnRleHRCYXNlbGluZVxuICAgICAgfSk7XG4gICAgICBjb25zdCBib3ggPSB0ZXh0LmdldEJCb3goKTtcbiAgICAgIGxhYmVsLmJveCA9IGJveDtcbiAgICAgIGlmIChNYXRoLmFicyhsYWJlbC5jb2xsaXNpb25PZmZzZXRZKSA+IG1heENvbGxpc2lvbk9mZnNldCkge1xuICAgICAgICBsYWJlbC5oaWRkZW4gPSB0cnVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGl0bGVCb3gpIHtcbiAgICAgICAgY29uc3Qgc2VyaWVzVG9wID0gc2VyaWVzUmVjdC55IC0gdGhpcy5jZW50ZXJZO1xuICAgICAgICBjb25zdCB0aXRsZUNsZWFuQXJlYSA9IG5ldyBCQm94KFxuICAgICAgICAgIHRpdGxlQm94LnggLSBtaW5TcGFjaW5nLFxuICAgICAgICAgIHNlcmllc1RvcCxcbiAgICAgICAgICB0aXRsZUJveC53aWR0aCArIDIgKiBtaW5TcGFjaW5nLFxuICAgICAgICAgIHRpdGxlQm94LnkgKyB0aXRsZUJveC5oZWlnaHQgKyBtaW5TcGFjaW5nIC0gc2VyaWVzVG9wXG4gICAgICAgICk7XG4gICAgICAgIGlmIChib3guY29sbGlkZXNCQm94KHRpdGxlQ2xlYW5BcmVhKSkge1xuICAgICAgICAgIGxhYmVsLmhpZGRlbiA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5oaWRlV2hlbk5lY2Vzc2FyeSkge1xuICAgICAgICBjb25zdCB7IHRleHRMZW5ndGgsIGhhc1ZlcnRpY2FsT3ZlcmZsb3csIGhhc1N1cnJvdW5kaW5nU2VyaWVzT3ZlcmZsb3cgfSA9IHRoaXMuZ2V0TGFiZWxPdmVyZmxvdyhcbiAgICAgICAgICBsYWJlbC50ZXh0LFxuICAgICAgICAgIGJveCxcbiAgICAgICAgICBzZXJpZXNSZWN0XG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGlzVG9vU2hvcnQgPSBsYWJlbC50ZXh0Lmxlbmd0aCA+IDIgJiYgdGV4dExlbmd0aCA8IDI7XG4gICAgICAgIGlmIChoYXNWZXJ0aWNhbE92ZXJmbG93IHx8IGlzVG9vU2hvcnQgfHwgaGFzU3Vycm91bmRpbmdTZXJpZXNPdmVyZmxvdykge1xuICAgICAgICAgIGxhYmVsLmhpZGRlbiA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsYWJlbC5oaWRkZW4gPSBmYWxzZTtcbiAgICAgIHRleHRCb3hlcy5wdXNoKGJveCk7XG4gICAgfSk7XG4gICAgaWYgKHRleHRCb3hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gQkJveC5tZXJnZSh0ZXh0Qm94ZXMpO1xuICB9XG4gIHVwZGF0ZVNlY3RvckxhYmVsTm9kZXMoKSB7XG4gICAgY29uc3QgeyByYWRpdXNTY2FsZSB9ID0gdGhpcztcbiAgICBjb25zdCBpbm5lclJhZGl1cyA9IHJhZGl1c1NjYWxlLmNvbnZlcnQoMCk7XG4gICAgY29uc3QgeyBmb250U2l6ZSwgZm9udFN0eWxlLCBmb250V2VpZ2h0LCBmb250RmFtaWx5LCBwb3NpdGlvbk9mZnNldCwgcG9zaXRpb25SYXRpbywgY29sb3IgfSA9IHRoaXMucHJvcGVydGllcy5zZWN0b3JMYWJlbDtcbiAgICBjb25zdCB1cGRhdGVTZWN0b3JMYWJlbCA9ICh0ZXh0LCBkYXR1bSkgPT4ge1xuICAgICAgY29uc3QgeyBzZWN0b3JMYWJlbCwgb3V0ZXJSYWRpdXMgfSA9IGRhdHVtO1xuICAgICAgbGV0IGlzVGV4dFZpc2libGUgPSBmYWxzZTtcbiAgICAgIGlmIChzZWN0b3JMYWJlbCAmJiBvdXRlclJhZGl1cyAhPT0gMCkge1xuICAgICAgICBjb25zdCBsYWJlbFJhZGl1cyA9IGlubmVyUmFkaXVzICogKDEgLSBwb3NpdGlvblJhdGlvKSArIG91dGVyUmFkaXVzICogcG9zaXRpb25SYXRpbyArIHBvc2l0aW9uT2Zmc2V0O1xuICAgICAgICB0ZXh0LmZpbGwgPSBjb2xvcjtcbiAgICAgICAgdGV4dC5mb250U3R5bGUgPSBmb250U3R5bGU7XG4gICAgICAgIHRleHQuZm9udFdlaWdodCA9IGZvbnRXZWlnaHQ7XG4gICAgICAgIHRleHQuZm9udFNpemUgPSBmb250U2l6ZTtcbiAgICAgICAgdGV4dC5mb250RmFtaWx5ID0gZm9udEZhbWlseTtcbiAgICAgICAgdGV4dC50ZXh0ID0gc2VjdG9yTGFiZWwudGV4dDtcbiAgICAgICAgdGV4dC54ID0gZGF0dW0ubWlkQ29zICogbGFiZWxSYWRpdXM7XG4gICAgICAgIHRleHQueSA9IGRhdHVtLm1pZFNpbiAqIGxhYmVsUmFkaXVzO1xuICAgICAgICB0ZXh0LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgICAgIHRleHQudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIjtcbiAgICAgICAgY29uc3QgYmJveCA9IHRleHQuZ2V0QkJveCgpO1xuICAgICAgICBjb25zdCBjb3JuZXJzID0gW1xuICAgICAgICAgIFtiYm94LngsIGJib3gueV0sXG4gICAgICAgICAgW2Jib3gueCArIGJib3gud2lkdGgsIGJib3gueV0sXG4gICAgICAgICAgW2Jib3gueCArIGJib3gud2lkdGgsIGJib3gueSArIGJib3guaGVpZ2h0XSxcbiAgICAgICAgICBbYmJveC54LCBiYm94LnkgKyBiYm94LmhlaWdodF1cbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgeyBzdGFydEFuZ2xlLCBlbmRBbmdsZSB9ID0gZGF0dW07XG4gICAgICAgIGNvbnN0IHNlY3RvckJvdW5kcyA9IHsgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cyB9O1xuICAgICAgICBpZiAoY29ybmVycy5ldmVyeSgoW3gsIHldKSA9PiBpc1BvaW50SW5TZWN0b3IoeCwgeSwgc2VjdG9yQm91bmRzKSkpIHtcbiAgICAgICAgICBpc1RleHRWaXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGV4dC52aXNpYmxlID0gaXNUZXh0VmlzaWJsZTtcbiAgICB9O1xuICAgIHRoaXMubGFiZWxTZWxlY3Rpb24uZWFjaCh1cGRhdGVTZWN0b3JMYWJlbCk7XG4gICAgdGhpcy5oaWdobGlnaHRMYWJlbFNlbGVjdGlvbi5lYWNoKHVwZGF0ZVNlY3RvckxhYmVsKTtcbiAgfVxuICB1cGRhdGVJbm5lckxhYmVsTm9kZXMoKSB7XG4gICAgY29uc3QgdGV4dEJCb3hlcyA9IFtdO1xuICAgIGNvbnN0IG1hcmdpbnMgPSBbXTtcbiAgICB0aGlzLmlubmVyTGFiZWxzU2VsZWN0aW9uLmVhY2goKHRleHQsIGRhdHVtKSA9PiB7XG4gICAgICBjb25zdCB7IGZvbnRTdHlsZSwgZm9udFdlaWdodCwgZm9udFNpemUsIGZvbnRGYW1pbHksIGNvbG9yIH0gPSBkYXR1bTtcbiAgICAgIHRleHQuZm9udFN0eWxlID0gZm9udFN0eWxlO1xuICAgICAgdGV4dC5mb250V2VpZ2h0ID0gZm9udFdlaWdodDtcbiAgICAgIHRleHQuZm9udFNpemUgPSBmb250U2l6ZTtcbiAgICAgIHRleHQuZm9udEZhbWlseSA9IGZvbnRGYW1pbHk7XG4gICAgICB0ZXh0LnRleHQgPSBkYXR1bS50ZXh0O1xuICAgICAgdGV4dC54ID0gMDtcbiAgICAgIHRleHQueSA9IDA7XG4gICAgICB0ZXh0LmZpbGwgPSBjb2xvcjtcbiAgICAgIHRleHQudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICAgIHRleHQudGV4dEJhc2VsaW5lID0gXCJhbHBoYWJldGljXCI7XG4gICAgICB0ZXh0QkJveGVzLnB1c2godGV4dC5nZXRCQm94KCkpO1xuICAgICAgbWFyZ2lucy5wdXNoKGRhdHVtLnNwYWNpbmcpO1xuICAgIH0pO1xuICAgIGNvbnN0IGdldE1hcmdpblRvcCA9IChpbmRleCkgPT4gaW5kZXggPT09IDAgPyAwIDogbWFyZ2luc1tpbmRleF07XG4gICAgY29uc3QgZ2V0TWFyZ2luQm90dG9tID0gKGluZGV4KSA9PiBpbmRleCA9PT0gbWFyZ2lucy5sZW5ndGggLSAxID8gMCA6IG1hcmdpbnNbaW5kZXhdO1xuICAgIGNvbnN0IHRvdGFsSGVpZ2h0ID0gdGV4dEJCb3hlcy5yZWR1Y2UoKHN1bTIsIGJib3gsIGkpID0+IHtcbiAgICAgIHJldHVybiBzdW0yICsgYmJveC5oZWlnaHQgKyBnZXRNYXJnaW5Ub3AoaSkgKyBnZXRNYXJnaW5Cb3R0b20oaSk7XG4gICAgfSwgMCk7XG4gICAgY29uc3QgdG90YWxXaWR0aCA9IE1hdGgubWF4KC4uLnRleHRCQm94ZXMubWFwKChiYm94KSA9PiBiYm94LndpZHRoKSk7XG4gICAgY29uc3QgaW5uZXJSYWRpdXMgPSB0aGlzLmdldElubmVyUmFkaXVzKCk7XG4gICAgY29uc3QgbGFiZWxSYWRpdXMgPSBNYXRoLnNxcnQoTWF0aC5wb3codG90YWxXaWR0aCAvIDIsIDIpICsgTWF0aC5wb3codG90YWxIZWlnaHQgLyAyLCAyKSk7XG4gICAgY29uc3QgbGFiZWxzVmlzaWJsZSA9IGxhYmVsUmFkaXVzIDw9IChpbm5lclJhZGl1cyA+IDAgPyBpbm5lclJhZGl1cyA6IHRoaXMuZ2V0T3V0ZXJSYWRpdXMoKSk7XG4gICAgY29uc3QgdGV4dEJvdHRvbXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgcHJldiA9IC10b3RhbEhlaWdodCAvIDI7IGkgPCB0ZXh0QkJveGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBiYm94ID0gdGV4dEJCb3hlc1tpXTtcbiAgICAgIGNvbnN0IGJvdHRvbSA9IGJib3guaGVpZ2h0ICsgcHJldiArIGdldE1hcmdpblRvcChpKTtcbiAgICAgIHRleHRCb3R0b21zLnB1c2goYm90dG9tKTtcbiAgICAgIHByZXYgPSBib3R0b20gKyBnZXRNYXJnaW5Cb3R0b20oaSk7XG4gICAgfVxuICAgIHRoaXMuaW5uZXJMYWJlbHNTZWxlY3Rpb24uZWFjaCgodGV4dCwgX2RhdHVtLCBpbmRleCkgPT4ge1xuICAgICAgdGV4dC55ID0gdGV4dEJvdHRvbXNbaW5kZXhdO1xuICAgICAgdGV4dC52aXNpYmxlID0gbGFiZWxzVmlzaWJsZTtcbiAgICB9KTtcbiAgfVxuICB1cGRhdGVaZXJvc3VtUmluZ3MoKSB7XG4gICAgdGhpcy56ZXJvc3VtT3V0ZXJSaW5nLnNpemUgPSB0aGlzLmdldE91dGVyUmFkaXVzKCkgKiAyO1xuICAgIHRoaXMuemVyb3N1bUlubmVyUmluZy5zaXplID0gdGhpcy5nZXRJbm5lclJhZGl1cygpICogMjtcbiAgfVxuICBnZXREYXR1bUxlZ2VuZE5hbWUobm9kZURhdHVtKSB7XG4gICAgY29uc3QgeyBhbmdsZUtleSwgY2FsbG91dExhYmVsS2V5LCBzZWN0b3JMYWJlbEtleSwgbGVnZW5kSXRlbUtleSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHsgc2VjdG9yTGFiZWwsIGNhbGxvdXRMYWJlbCwgbGVnZW5kSXRlbSB9ID0gbm9kZURhdHVtO1xuICAgIGlmIChsZWdlbmRJdGVtS2V5ICYmIGxlZ2VuZEl0ZW0gIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIGxlZ2VuZEl0ZW0udGV4dDtcbiAgICB9IGVsc2UgaWYgKGNhbGxvdXRMYWJlbEtleSAmJiBjYWxsb3V0TGFiZWxLZXkgIT09IGFuZ2xlS2V5ICYmIGNhbGxvdXRMYWJlbD8udGV4dCAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gY2FsbG91dExhYmVsLnRleHQ7XG4gICAgfSBlbHNlIGlmIChzZWN0b3JMYWJlbEtleSAmJiBzZWN0b3JMYWJlbEtleSAhPT0gYW5nbGVLZXkgJiYgc2VjdG9yTGFiZWw/LnRleHQgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHNlY3RvckxhYmVsLnRleHQ7XG4gICAgfVxuICB9XG4gIHBpY2tOb2RlQ2xvc2VzdERhdHVtKHBvaW50KSB7XG4gICAgcmV0dXJuIHBpY2tCeU1hdGNoaW5nQW5nbGUodGhpcywgcG9pbnQpO1xuICB9XG4gIGdldFRvb2x0aXBIdG1sKG5vZGVEYXR1bSkge1xuICAgIGlmICghdGhpcy5wcm9wZXJ0aWVzLmlzVmFsaWQoKSkge1xuICAgICAgcmV0dXJuIEVNUFRZX1RPT0xUSVBfQ09OVEVOVDtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgZGF0dW0sXG4gICAgICBhbmdsZVZhbHVlLFxuICAgICAgc2VjdG9yRm9ybWF0OiB7IGZpbGw6IGNvbG9yIH0sXG4gICAgICBpdGVtSWRcbiAgICB9ID0gbm9kZURhdHVtO1xuICAgIGNvbnN0IHRpdGxlID0gc2FuaXRpemVIdG1sKHRoaXMucHJvcGVydGllcy50aXRsZT8udGV4dCk7XG4gICAgY29uc3QgY29udGVudCA9IGlzRmluaXRlTnVtYmVyKGFuZ2xlVmFsdWUpID8gdG9GaXhlZChhbmdsZVZhbHVlKSA6IFN0cmluZyhhbmdsZVZhbHVlKTtcbiAgICBjb25zdCBsYWJlbFRleHQgPSB0aGlzLmdldERhdHVtTGVnZW5kTmFtZShub2RlRGF0dW0pO1xuICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXMudG9vbHRpcC50b1Rvb2x0aXBIdG1sKFxuICAgICAge1xuICAgICAgICB0aXRsZTogdGl0bGUgPz8gbGFiZWxUZXh0LFxuICAgICAgICBjb250ZW50OiB0aXRsZSAmJiBsYWJlbFRleHQgPyBgJHtsYWJlbFRleHR9OiAke2NvbnRlbnR9YCA6IGNvbnRlbnQsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogY29sb3JcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGRhdHVtLFxuICAgICAgICBpdGVtSWQsXG4gICAgICAgIHRpdGxlLFxuICAgICAgICBjb2xvcixcbiAgICAgICAgc2VyaWVzSWQ6IHRoaXMuaWQsXG4gICAgICAgIGFuZ2xlS2V5OiB0aGlzLnByb3BlcnRpZXMuYW5nbGVLZXksXG4gICAgICAgIGFuZ2xlTmFtZTogdGhpcy5wcm9wZXJ0aWVzLmFuZ2xlTmFtZSxcbiAgICAgICAgcmFkaXVzS2V5OiB0aGlzLnByb3BlcnRpZXMucmFkaXVzS2V5LFxuICAgICAgICByYWRpdXNOYW1lOiB0aGlzLnByb3BlcnRpZXMucmFkaXVzTmFtZSxcbiAgICAgICAgY2FsbG91dExhYmVsS2V5OiB0aGlzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsS2V5LFxuICAgICAgICBjYWxsb3V0TGFiZWxOYW1lOiB0aGlzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsTmFtZSxcbiAgICAgICAgc2VjdG9yTGFiZWxLZXk6IHRoaXMucHJvcGVydGllcy5zZWN0b3JMYWJlbEtleSxcbiAgICAgICAgc2VjdG9yTGFiZWxOYW1lOiB0aGlzLnByb3BlcnRpZXMuc2VjdG9yTGFiZWxOYW1lLFxuICAgICAgICBsZWdlbmRJdGVtS2V5OiB0aGlzLnByb3BlcnRpZXMubGVnZW5kSXRlbUtleVxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgZ2V0TGVnZW5kRGF0YShsZWdlbmRUeXBlKSB7XG4gICAgY29uc3QgeyB2aXNpYmxlLCBwcm9jZXNzZWREYXRhLCBkYXRhTW9kZWwgfSA9IHRoaXM7XG4gICAgaWYgKCFkYXRhTW9kZWwgfHwgIXByb2Nlc3NlZERhdGE/LmRhdGEubGVuZ3RoIHx8ICF0aGlzLnByb3BlcnRpZXMuaXNWYWxpZCgpIHx8IGxlZ2VuZFR5cGUgIT09IFwiY2F0ZWdvcnlcIikge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCB7IGFuZ2xlS2V5LCBjYWxsb3V0TGFiZWxLZXksIHNlY3RvckxhYmVsS2V5LCBsZWdlbmRJdGVtS2V5IH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgaWYgKCFsZWdlbmRJdGVtS2V5ICYmICghY2FsbG91dExhYmVsS2V5IHx8IGNhbGxvdXRMYWJlbEtleSA9PT0gYW5nbGVLZXkpICYmICghc2VjdG9yTGFiZWxLZXkgfHwgc2VjdG9yTGFiZWxLZXkgPT09IGFuZ2xlS2V5KSlcbiAgICAgIHJldHVybiBbXTtcbiAgICBjb25zdCB7IGNhbGxvdXRMYWJlbElkeCwgc2VjdG9yTGFiZWxJZHgsIGxlZ2VuZEl0ZW1JZHggfSA9IHRoaXMuZ2V0UHJvY2Vzc2VkRGF0YUluZGV4ZXMoZGF0YU1vZGVsKTtcbiAgICBjb25zdCB0aXRsZVRleHQgPSB0aGlzLnByb3BlcnRpZXMudGl0bGU/LnNob3dJbkxlZ2VuZCAmJiB0aGlzLnByb3BlcnRpZXMudGl0bGUudGV4dDtcbiAgICBjb25zdCBsZWdlbmREYXRhID0gW107XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHByb2Nlc3NlZERhdGEuZGF0YS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGNvbnN0IHsgZGF0dW0sIHZhbHVlcyB9ID0gcHJvY2Vzc2VkRGF0YS5kYXRhW2luZGV4XTtcbiAgICAgIGNvbnN0IGxhYmVsUGFydHMgPSBbXTtcbiAgICAgIGlmICh0aXRsZVRleHQpIHtcbiAgICAgICAgbGFiZWxQYXJ0cy5wdXNoKHRpdGxlVGV4dCk7XG4gICAgICB9XG4gICAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmdldExhYmVscyhcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIDIgKiBNYXRoLlBJLFxuICAgICAgICAyICogTWF0aC5QSSxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIGNhbGxvdXRMYWJlbElkeCAhPSBudWxsID8gdmFsdWVzW2NhbGxvdXRMYWJlbElkeF0gOiB2b2lkIDAsXG4gICAgICAgIHNlY3RvckxhYmVsSWR4ICE9IG51bGwgPyB2YWx1ZXNbc2VjdG9yTGFiZWxJZHhdIDogdm9pZCAwLFxuICAgICAgICBsZWdlbmRJdGVtSWR4ICE9IG51bGwgPyB2YWx1ZXNbbGVnZW5kSXRlbUlkeF0gOiB2b2lkIDBcbiAgICAgICk7XG4gICAgICBpZiAobGVnZW5kSXRlbUtleSAmJiBsYWJlbHMubGVnZW5kSXRlbSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGxhYmVsUGFydHMucHVzaChsYWJlbHMubGVnZW5kSXRlbS50ZXh0KTtcbiAgICAgIH0gZWxzZSBpZiAoY2FsbG91dExhYmVsS2V5ICYmIGNhbGxvdXRMYWJlbEtleSAhPT0gYW5nbGVLZXkgJiYgbGFiZWxzLmNhbGxvdXRMYWJlbD8udGV4dCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGxhYmVsUGFydHMucHVzaChsYWJlbHMuY2FsbG91dExhYmVsPy50ZXh0KTtcbiAgICAgIH0gZWxzZSBpZiAoc2VjdG9yTGFiZWxLZXkgJiYgc2VjdG9yTGFiZWxLZXkgIT09IGFuZ2xlS2V5ICYmIGxhYmVscy5zZWN0b3JMYWJlbD8udGV4dCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGxhYmVsUGFydHMucHVzaChsYWJlbHMuc2VjdG9yTGFiZWw/LnRleHQpO1xuICAgICAgfVxuICAgICAgaWYgKGxhYmVsUGFydHMubGVuZ3RoID09PSAwKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IHNlY3RvckZvcm1hdCA9IHRoaXMuZ2V0U2VjdG9yRm9ybWF0KGRhdHVtLCBpbmRleCwgZmFsc2UpO1xuICAgICAgbGVnZW5kRGF0YS5wdXNoKHtcbiAgICAgICAgbGVnZW5kVHlwZTogXCJjYXRlZ29yeVwiLFxuICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgaXRlbUlkOiBpbmRleCxcbiAgICAgICAgc2VyaWVzSWQ6IHRoaXMuaWQsXG4gICAgICAgIGVuYWJsZWQ6IHZpc2libGUgJiYgdGhpcy5sZWdlbmRJdGVtRW5hYmxlZFtpbmRleF0sXG4gICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgdGV4dDogbGFiZWxQYXJ0cy5qb2luKFwiIC0gXCIpXG4gICAgICAgIH0sXG4gICAgICAgIHN5bWJvbHM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBtYXJrZXI6IHtcbiAgICAgICAgICAgICAgZmlsbDogc2VjdG9yRm9ybWF0LmZpbGwsXG4gICAgICAgICAgICAgIHN0cm9rZTogc2VjdG9yRm9ybWF0LnN0cm9rZSxcbiAgICAgICAgICAgICAgZmlsbE9wYWNpdHk6IHRoaXMucHJvcGVydGllcy5maWxsT3BhY2l0eSxcbiAgICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogdGhpcy5wcm9wZXJ0aWVzLnN0cm9rZU9wYWNpdHksXG4gICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiB0aGlzLnByb3BlcnRpZXMuc3Ryb2tlV2lkdGhcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIGxlZ2VuZEl0ZW1OYW1lOiBsZWdlbmRJdGVtS2V5ICE9IG51bGwgPyBkYXR1bVtsZWdlbmRJdGVtS2V5XSA6IHZvaWQgMFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBsZWdlbmREYXRhO1xuICB9XG4gIG9uTGVnZW5kSXRlbUNsaWNrKGV2ZW50KSB7XG4gICAgY29uc3QgeyBlbmFibGVkLCBpdGVtSWQsIHNlcmllcywgbGVnZW5kSXRlbU5hbWUgfSA9IGV2ZW50O1xuICAgIGlmIChzZXJpZXMuaWQgPT09IHRoaXMuaWQpIHtcbiAgICAgIHRoaXMudG9nZ2xlU2VyaWVzSXRlbShpdGVtSWQsIGVuYWJsZWQpO1xuICAgIH0gZWxzZSBpZiAobGVnZW5kSXRlbU5hbWUgIT0gbnVsbCkge1xuICAgICAgdGhpcy50b2dnbGVPdGhlclNlcmllc0l0ZW1zKGxlZ2VuZEl0ZW1OYW1lLCBlbmFibGVkKTtcbiAgICB9XG4gIH1cbiAgdG9nZ2xlU2VyaWVzSXRlbShpdGVtSWQsIGVuYWJsZWQpIHtcbiAgICB0aGlzLnNlcmllc0l0ZW1FbmFibGVkW2l0ZW1JZF0gPSBlbmFibGVkO1xuICAgIHRoaXMubGVnZW5kSXRlbUVuYWJsZWRbaXRlbUlkXSA9IGVuYWJsZWQ7XG4gICAgaWYgKHRoaXMubm9kZURhdGFbaXRlbUlkXSkge1xuICAgICAgdGhpcy5ub2RlRGF0YVtpdGVtSWRdLmVuYWJsZWQgPSBlbmFibGVkO1xuICAgIH1cbiAgICB0aGlzLm5vZGVEYXRhUmVmcmVzaCA9IHRydWU7XG4gIH1cbiAgLy8gVXNlZCBmb3IgZ3JpZFxuICBzZXRMZWdlbmRTdGF0ZShlbmFibGVkSXRlbXMpIHtcbiAgICB0aGlzLmxlZ2VuZEl0ZW1FbmFibGVkID0gZW5hYmxlZEl0ZW1zO1xuICAgIHRoaXMuY3R4LnVwZGF0ZVNlcnZpY2UudXBkYXRlKDQgLyogU0VSSUVTX1VQREFURSAqLyk7XG4gIH1cbiAgdG9nZ2xlT3RoZXJTZXJpZXNJdGVtcyhsZWdlbmRJdGVtTmFtZSwgZW5hYmxlZCkge1xuICAgIGlmICghdGhpcy5wcm9wZXJ0aWVzLmxlZ2VuZEl0ZW1LZXkgfHwgIXRoaXMuZGF0YU1vZGVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxlZ2VuZEl0ZW1JZHggPSB0aGlzLmRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgbGVnZW5kSXRlbVZhbHVlYCk7XG4gICAgdGhpcy5wcm9jZXNzZWREYXRhPy5kYXRhLmZvckVhY2goKHsgdmFsdWVzIH0sIGRhdHVtSXRlbUlkKSA9PiB7XG4gICAgICBpZiAodmFsdWVzW2xlZ2VuZEl0ZW1JZHhdID09PSBsZWdlbmRJdGVtTmFtZSkge1xuICAgICAgICB0aGlzLnRvZ2dsZVNlcmllc0l0ZW0oZGF0dW1JdGVtSWQsIGVuYWJsZWQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFuaW1hdGVFbXB0eVVwZGF0ZVJlYWR5KF9kYXRhKSB7XG4gICAgY29uc3QgeyBhbmltYXRpb25NYW5hZ2VyIH0gPSB0aGlzLmN0eDtcbiAgICBjb25zdCBmbnMgPSBwcmVwYXJlUGllU2VyaWVzQW5pbWF0aW9uRnVuY3Rpb25zKFxuICAgICAgdHJ1ZSxcbiAgICAgIHRoaXMucHJvcGVydGllcy5yb3RhdGlvbixcbiAgICAgIHRoaXMucmFkaXVzU2NhbGUsXG4gICAgICB0aGlzLnByZXZpb3VzUmFkaXVzU2NhbGVcbiAgICApO1xuICAgIGZyb21Ub01vdGlvbihcbiAgICAgIHRoaXMuaWQsXG4gICAgICBcIm5vZGVzXCIsXG4gICAgICBhbmltYXRpb25NYW5hZ2VyLFxuICAgICAgW3RoaXMuaXRlbVNlbGVjdGlvbiwgdGhpcy5oaWdobGlnaHRTZWxlY3Rpb24sIHRoaXMucGhhbnRvbVNlbGVjdGlvbl0sXG4gICAgICBmbnMubm9kZXMsXG4gICAgICAoXywgZGF0dW0pID0+IHRoaXMuZ2V0RGF0dW1JZChkYXR1bSlcbiAgICApO1xuICAgIGZyb21Ub01vdGlvbih0aGlzLmlkLCBgaW5uZXJDaXJjbGVgLCBhbmltYXRpb25NYW5hZ2VyLCBbdGhpcy5pbm5lckNpcmNsZVNlbGVjdGlvbl0sIGZucy5pbm5lckNpcmNsZSk7XG4gICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJjYWxsb3V0XCIsIGFuaW1hdGlvbk1hbmFnZXIsIHRoaXMuY2FsbG91dExhYmVsU2VsZWN0aW9uKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcInNlY3RvclwiLCBhbmltYXRpb25NYW5hZ2VyLCB0aGlzLmxhYmVsU2VsZWN0aW9uKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImhpZ2hsaWdodFwiLCBhbmltYXRpb25NYW5hZ2VyLCB0aGlzLmhpZ2hsaWdodExhYmVsU2VsZWN0aW9uKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImlubmVyXCIsIGFuaW1hdGlvbk1hbmFnZXIsIHRoaXMuaW5uZXJMYWJlbHNTZWxlY3Rpb24pO1xuICAgIHRoaXMucHJldmlvdXNSYWRpdXNTY2FsZS5yYW5nZSA9IHRoaXMucmFkaXVzU2NhbGUucmFuZ2U7XG4gIH1cbiAgYW5pbWF0ZVdhaXRpbmdVcGRhdGVSZWFkeSgpIHtcbiAgICBjb25zdCB7IGl0ZW1TZWxlY3Rpb24sIGhpZ2hsaWdodFNlbGVjdGlvbiwgcGhhbnRvbVNlbGVjdGlvbiwgcHJvY2Vzc2VkRGF0YSwgcmFkaXVzU2NhbGUsIHByZXZpb3VzUmFkaXVzU2NhbGUgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBhbmltYXRpb25NYW5hZ2VyIH0gPSB0aGlzLmN0eDtcbiAgICBjb25zdCBkYXRhRGlmZiA9IHByb2Nlc3NlZERhdGE/LnJlZHVjZWQ/LmRpZmY7XG4gICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5zdG9wQnlBbmltYXRpb25Hcm91cElkKHRoaXMuaWQpO1xuICAgIGNvbnN0IHN1cHBvcnRlZERpZmYgPSAoZGF0YURpZmY/Lm1vdmVkLnNpemUgPz8gMCkgPT09IDA7XG4gICAgY29uc3QgaGFzS2V5cyA9IChwcm9jZXNzZWREYXRhPy5kZWZzLmtleXMubGVuZ3RoID8/IDApID4gMDtcbiAgICBjb25zdCBoYXNVbmlxdWVLZXlzID0gcHJvY2Vzc2VkRGF0YT8ucmVkdWNlZD8uYW5pbWF0aW9uVmFsaWRhdGlvbj8udW5pcXVlS2V5cyA/PyB0cnVlO1xuICAgIGlmICghc3VwcG9ydGVkRGlmZiB8fCAhaGFzS2V5cyB8fCAhaGFzVW5pcXVlS2V5cykge1xuICAgICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5za2lwQ3VycmVudEJhdGNoKCk7XG4gICAgfVxuICAgIGNvbnN0IGZucyA9IHByZXBhcmVQaWVTZXJpZXNBbmltYXRpb25GdW5jdGlvbnMoXG4gICAgICBmYWxzZSxcbiAgICAgIHRoaXMucHJvcGVydGllcy5yb3RhdGlvbixcbiAgICAgIHJhZGl1c1NjYWxlLFxuICAgICAgcHJldmlvdXNSYWRpdXNTY2FsZVxuICAgICk7XG4gICAgZnJvbVRvTW90aW9uKFxuICAgICAgdGhpcy5pZCxcbiAgICAgIFwibm9kZXNcIixcbiAgICAgIGFuaW1hdGlvbk1hbmFnZXIsXG4gICAgICBbaXRlbVNlbGVjdGlvbiwgaGlnaGxpZ2h0U2VsZWN0aW9uLCBwaGFudG9tU2VsZWN0aW9uXSxcbiAgICAgIGZucy5ub2RlcyxcbiAgICAgIChfLCBkYXR1bSkgPT4gdGhpcy5nZXREYXR1bUlkKGRhdHVtKSxcbiAgICAgIGRhdGFEaWZmXG4gICAgKTtcbiAgICBmcm9tVG9Nb3Rpb24odGhpcy5pZCwgYGlubmVyQ2lyY2xlYCwgYW5pbWF0aW9uTWFuYWdlciwgW3RoaXMuaW5uZXJDaXJjbGVTZWxlY3Rpb25dLCBmbnMuaW5uZXJDaXJjbGUpO1xuICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwiY2FsbG91dFwiLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCB0aGlzLmNhbGxvdXRMYWJlbFNlbGVjdGlvbik7XG4gICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJzZWN0b3JcIiwgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgdGhpcy5sYWJlbFNlbGVjdGlvbik7XG4gICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJoaWdobGlnaHRcIiwgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgdGhpcy5oaWdobGlnaHRMYWJlbFNlbGVjdGlvbik7XG4gICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJpbm5lclwiLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCB0aGlzLmlubmVyTGFiZWxzU2VsZWN0aW9uKTtcbiAgICB0aGlzLnByZXZpb3VzUmFkaXVzU2NhbGUucmFuZ2UgPSB0aGlzLnJhZGl1c1NjYWxlLnJhbmdlO1xuICB9XG4gIGFuaW1hdGVDbGVhcmluZ1VwZGF0ZUVtcHR5KCkge1xuICAgIGNvbnN0IHsgaXRlbVNlbGVjdGlvbiwgaGlnaGxpZ2h0U2VsZWN0aW9uLCBwaGFudG9tU2VsZWN0aW9uLCByYWRpdXNTY2FsZSwgcHJldmlvdXNSYWRpdXNTY2FsZSB9ID0gdGhpcztcbiAgICBjb25zdCB7IGFuaW1hdGlvbk1hbmFnZXIgfSA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGZucyA9IHByZXBhcmVQaWVTZXJpZXNBbmltYXRpb25GdW5jdGlvbnMoXG4gICAgICBmYWxzZSxcbiAgICAgIHRoaXMucHJvcGVydGllcy5yb3RhdGlvbixcbiAgICAgIHJhZGl1c1NjYWxlLFxuICAgICAgcHJldmlvdXNSYWRpdXNTY2FsZVxuICAgICk7XG4gICAgZnJvbVRvTW90aW9uKFxuICAgICAgdGhpcy5pZCxcbiAgICAgIFwibm9kZXNcIixcbiAgICAgIGFuaW1hdGlvbk1hbmFnZXIsXG4gICAgICBbaXRlbVNlbGVjdGlvbiwgaGlnaGxpZ2h0U2VsZWN0aW9uLCBwaGFudG9tU2VsZWN0aW9uXSxcbiAgICAgIGZucy5ub2RlcyxcbiAgICAgIChfLCBkYXR1bSkgPT4gdGhpcy5nZXREYXR1bUlkKGRhdHVtKVxuICAgICk7XG4gICAgZnJvbVRvTW90aW9uKHRoaXMuaWQsIGBpbm5lckNpcmNsZWAsIGFuaW1hdGlvbk1hbmFnZXIsIFt0aGlzLmlubmVyQ2lyY2xlU2VsZWN0aW9uXSwgZm5zLmlubmVyQ2lyY2xlKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVPdXRBbmltYXRpb24odGhpcywgXCJjYWxsb3V0XCIsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIHRoaXMuY2FsbG91dExhYmVsU2VsZWN0aW9uKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVPdXRBbmltYXRpb24odGhpcywgXCJzZWN0b3JcIiwgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgdGhpcy5sYWJlbFNlbGVjdGlvbik7XG4gICAgc2VyaWVzTGFiZWxGYWRlT3V0QW5pbWF0aW9uKHRoaXMsIFwiaGlnaGxpZ2h0XCIsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIHRoaXMuaGlnaGxpZ2h0TGFiZWxTZWxlY3Rpb24pO1xuICAgIHNlcmllc0xhYmVsRmFkZU91dEFuaW1hdGlvbih0aGlzLCBcImlubmVyXCIsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIHRoaXMuaW5uZXJMYWJlbHNTZWxlY3Rpb24pO1xuICAgIHRoaXMucHJldmlvdXNSYWRpdXNTY2FsZS5yYW5nZSA9IHRoaXMucmFkaXVzU2NhbGUucmFuZ2U7XG4gIH1cbiAgZ2V0RGF0dW1JZEZyb21EYXRhKGRhdHVtKSB7XG4gICAgY29uc3QgeyBjYWxsb3V0TGFiZWxLZXksIHNlY3RvckxhYmVsS2V5LCBsZWdlbmRJdGVtS2V5IH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgaWYgKCF0aGlzLnByb2Nlc3NlZERhdGE/LnJlZHVjZWQ/LmFuaW1hdGlvblZhbGlkYXRpb24/LnVuaXF1ZUtleXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGxlZ2VuZEl0ZW1LZXkpIHtcbiAgICAgIHJldHVybiBkYXR1bVtsZWdlbmRJdGVtS2V5XTtcbiAgICB9IGVsc2UgaWYgKGNhbGxvdXRMYWJlbEtleSkge1xuICAgICAgcmV0dXJuIGRhdHVtW2NhbGxvdXRMYWJlbEtleV07XG4gICAgfSBlbHNlIGlmIChzZWN0b3JMYWJlbEtleSkge1xuICAgICAgcmV0dXJuIGRhdHVtW3NlY3RvckxhYmVsS2V5XTtcbiAgICB9XG4gIH1cbiAgZ2V0RGF0dW1JZChkYXR1bSkge1xuICAgIGNvbnN0IHsgaW5kZXggfSA9IGRhdHVtO1xuICAgIGNvbnN0IGRhdHVtSWQgPSB0aGlzLmdldERhdHVtSWRGcm9tRGF0YShkYXR1bS5kYXR1bSk7XG4gICAgcmV0dXJuIGRhdHVtSWQgIT0gbnVsbCA/IFN0cmluZyhkYXR1bUlkKSA6IGAke2luZGV4fWA7XG4gIH1cbiAgb25EYXRhQ2hhbmdlKCkge1xuICAgIGNvbnN0IHsgZGF0YSwgc2VyaWVzSXRlbUVuYWJsZWQsIGxlZ2VuZEl0ZW1FbmFibGVkIH0gPSB0aGlzO1xuICAgIHRoaXMuc2VyaWVzSXRlbUVuYWJsZWQgPSBkYXRhPy5tYXAoKF8sIGluZGV4KSA9PiBzZXJpZXNJdGVtRW5hYmxlZFtpbmRleF0gPz8gdHJ1ZSkgPz8gW107XG4gICAgdGhpcy5sZWdlbmRJdGVtRW5hYmxlZCA9IGRhdGE/Lm1hcCgoXywgaW5kZXgpID0+IGxlZ2VuZEl0ZW1FbmFibGVkW2luZGV4XSA/PyB0cnVlKSA/PyBbXTtcbiAgfVxufTtcbkRvbnV0U2VyaWVzLmNsYXNzTmFtZSA9IFwiRG9udXRTZXJpZXNcIjtcbkRvbnV0U2VyaWVzLnR5cGUgPSBcImRvbnV0XCI7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9wb2xhci9kb251dFRoZW1lLnRzXG52YXIgZG9udXRUaGVtZSA9IHtcbiAgc2VyaWVzOiB7XG4gICAgdGl0bGU6IHtcbiAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICBmb250V2VpZ2h0OiBcIm5vcm1hbFwiIC8qIE5PUk1BTCAqLyxcbiAgICAgIGZvbnRTaXplOiAxNCxcbiAgICAgIGZvbnRGYW1pbHk6IERFRkFVTFRfRk9OVF9GQU1JTFksXG4gICAgICBjb2xvcjogREVGQVVMVF9NVVRFRF9MQUJFTF9DT0xPVVIsXG4gICAgICBzcGFjaW5nOiA1XG4gICAgfSxcbiAgICBjYWxsb3V0TGFiZWw6IHtcbiAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICBmb250U2l6ZTogMTIgLyogU01BTEwgKi8sXG4gICAgICBmb250RmFtaWx5OiBERUZBVUxUX0ZPTlRfRkFNSUxZLFxuICAgICAgY29sb3I6IERFRkFVTFRfTEFCRUxfQ09MT1VSLFxuICAgICAgb2Zmc2V0OiAzLFxuICAgICAgbWluQW5nbGU6IDBcbiAgICB9LFxuICAgIHNlY3RvckxhYmVsOiB7XG4gICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgZm9udFdlaWdodDogXCJub3JtYWxcIiAvKiBOT1JNQUwgKi8sXG4gICAgICBmb250U2l6ZTogMTIgLyogU01BTEwgKi8sXG4gICAgICBmb250RmFtaWx5OiBERUZBVUxUX0ZPTlRfRkFNSUxZLFxuICAgICAgY29sb3I6IERFRkFVTFRfSU5TSURFX1NFUklFU19MQUJFTF9DT0xPVVIsXG4gICAgICBwb3NpdGlvbk9mZnNldDogMCxcbiAgICAgIHBvc2l0aW9uUmF0aW86IDAuNVxuICAgIH0sXG4gICAgY2FsbG91dExpbmU6IHtcbiAgICAgIGxlbmd0aDogMTAsXG4gICAgICBzdHJva2VXaWR0aDogMlxuICAgIH0sXG4gICAgZmlsbE9wYWNpdHk6IDEsXG4gICAgc3Ryb2tlT3BhY2l0eTogMSxcbiAgICBzdHJva2VXaWR0aDogMCxcbiAgICBsaW5lRGFzaDogWzBdLFxuICAgIGxpbmVEYXNoT2Zmc2V0OiAwLFxuICAgIHJvdGF0aW9uOiAwLFxuICAgIHNlY3RvclNwYWNpbmc6IDEsXG4gICAgc2hhZG93OiB7XG4gICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgIGNvbG9yOiBERUZBVUxUX1NIQURPV19DT0xPVVIsXG4gICAgICB4T2Zmc2V0OiAzLFxuICAgICAgeU9mZnNldDogMyxcbiAgICAgIGJsdXI6IDVcbiAgICB9LFxuICAgIGlubmVyTGFiZWxzOiB7XG4gICAgICBmb250U2l6ZTogMTIgLyogU01BTEwgKi8sXG4gICAgICBmb250RmFtaWx5OiBERUZBVUxUX0ZPTlRfRkFNSUxZLFxuICAgICAgY29sb3I6IERFRkFVTFRfTEFCRUxfQ09MT1VSLFxuICAgICAgc3BhY2luZzogMlxuICAgIH1cbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL3BvbGFyL3BpZVRoZW1lLnRzXG52YXIgcGllVGhlbWUgPSB7XG4gIHNlcmllczoge1xuICAgIHRpdGxlOiB7XG4gICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgZm9udFdlaWdodDogXCJub3JtYWxcIiAvKiBOT1JNQUwgKi8sXG4gICAgICBmb250U2l6ZTogMTQsXG4gICAgICBmb250RmFtaWx5OiBERUZBVUxUX0ZPTlRfRkFNSUxZLFxuICAgICAgY29sb3I6IERFRkFVTFRfTVVURURfTEFCRUxfQ09MT1VSLFxuICAgICAgc3BhY2luZzogNVxuICAgIH0sXG4gICAgY2FsbG91dExhYmVsOiB7XG4gICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgZm9udFNpemU6IDEyIC8qIFNNQUxMICovLFxuICAgICAgZm9udEZhbWlseTogREVGQVVMVF9GT05UX0ZBTUlMWSxcbiAgICAgIGNvbG9yOiBERUZBVUxUX0xBQkVMX0NPTE9VUixcbiAgICAgIG9mZnNldDogMyxcbiAgICAgIG1pbkFuZ2xlOiAwXG4gICAgfSxcbiAgICBzZWN0b3JMYWJlbDoge1xuICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgIGZvbnRXZWlnaHQ6IFwibm9ybWFsXCIgLyogTk9STUFMICovLFxuICAgICAgZm9udFNpemU6IDEyIC8qIFNNQUxMICovLFxuICAgICAgZm9udEZhbWlseTogREVGQVVMVF9GT05UX0ZBTUlMWSxcbiAgICAgIGNvbG9yOiBERUZBVUxUX0lOU0lERV9TRVJJRVNfTEFCRUxfQ09MT1VSLFxuICAgICAgcG9zaXRpb25PZmZzZXQ6IDAsXG4gICAgICBwb3NpdGlvblJhdGlvOiAwLjVcbiAgICB9LFxuICAgIGNhbGxvdXRMaW5lOiB7XG4gICAgICBsZW5ndGg6IDEwLFxuICAgICAgc3Ryb2tlV2lkdGg6IDJcbiAgICB9LFxuICAgIGZpbGxPcGFjaXR5OiAxLFxuICAgIHN0cm9rZU9wYWNpdHk6IDEsXG4gICAgc3Ryb2tlV2lkdGg6IDAsXG4gICAgbGluZURhc2g6IFswXSxcbiAgICBsaW5lRGFzaE9mZnNldDogMCxcbiAgICByb3RhdGlvbjogMCxcbiAgICBzZWN0b3JTcGFjaW5nOiAxLFxuICAgIHNoYWRvdzoge1xuICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICBjb2xvcjogREVGQVVMVF9TSEFET1dfQ09MT1VSLFxuICAgICAgeE9mZnNldDogMyxcbiAgICAgIHlPZmZzZXQ6IDMsXG4gICAgICBibHVyOiA1XG4gICAgfVxuICB9XG59O1xudmFyIHBpZVBhbGV0dGVGYWN0b3J5ID0gKHsgdGFrZUNvbG9ycywgY29sb3JzQ291bnQgfSkgPT4ge1xuICBjb25zdCB7IGZpbGxzLCBzdHJva2VzIH0gPSB0YWtlQ29sb3JzKGNvbG9yc0NvdW50KTtcbiAgcmV0dXJuIHsgZmlsbHMsIHN0cm9rZXMsIGNhbGxvdXRMaW5lOiB7IGNvbG9yczogc3Ryb2tlcyB9IH07XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvcG9sYXIvZG9udXRTZXJpZXNNb2R1bGUudHNcbnZhciBEb251dFNlcmllc01vZHVsZSA9IHtcbiAgdHlwZTogXCJzZXJpZXNcIixcbiAgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLFxuICBwYWNrYWdlVHlwZTogXCJjb21tdW5pdHlcIixcbiAgY2hhcnRUeXBlczogW1wicG9sYXJcIl0sXG4gIGlkZW50aWZpZXI6IFwiZG9udXRcIixcbiAgbW9kdWxlRmFjdG9yeTogKGN0eCkgPT4gbmV3IERvbnV0U2VyaWVzKGN0eCksXG4gIHRvb2x0aXBEZWZhdWx0czogeyByYW5nZTogXCJleGFjdFwiIH0sXG4gIHRoZW1lVGVtcGxhdGU6IGRvbnV0VGhlbWUsXG4gIHBhbGV0dGVGYWN0b3J5OiBwaWVQYWxldHRlRmFjdG9yeVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL3BvbGFyL3BpZVNlcmllc1Byb3BlcnRpZXMudHNcbnZhciBQaWVUaXRsZSA9IGNsYXNzIGV4dGVuZHMgQ2FwdGlvbiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5zaG93SW5MZWdlbmQgPSBmYWxzZTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBQaWVUaXRsZS5wcm90b3R5cGUsIFwic2hvd0luTGVnZW5kXCIsIDIpO1xudmFyIFBpZVNlcmllc0NhbGxvdXRMYWJlbCA9IGNsYXNzIGV4dGVuZHMgTGFiZWwge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMub2Zmc2V0ID0gMztcbiAgICB0aGlzLm1pbkFuZ2xlID0gMDtcbiAgICB0aGlzLm1pblNwYWNpbmcgPSA0O1xuICAgIHRoaXMubWF4Q29sbGlzaW9uT2Zmc2V0ID0gNTA7XG4gICAgdGhpcy5hdm9pZENvbGxpc2lvbnMgPSB0cnVlO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgUGllU2VyaWVzQ2FsbG91dExhYmVsLnByb3RvdHlwZSwgXCJvZmZzZXRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShERUdSRUUpXG5dLCBQaWVTZXJpZXNDYWxsb3V0TGFiZWwucHJvdG90eXBlLCBcIm1pbkFuZ2xlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgUGllU2VyaWVzQ2FsbG91dExhYmVsLnByb3RvdHlwZSwgXCJtaW5TcGFjaW5nXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgUGllU2VyaWVzQ2FsbG91dExhYmVsLnByb3RvdHlwZSwgXCJtYXhDb2xsaXNpb25PZmZzZXRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgUGllU2VyaWVzQ2FsbG91dExhYmVsLnByb3RvdHlwZSwgXCJhdm9pZENvbGxpc2lvbnNcIiwgMik7XG52YXIgUGllU2VyaWVzU2VjdG9yTGFiZWwgPSBjbGFzcyBleHRlbmRzIExhYmVsIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnBvc2l0aW9uT2Zmc2V0ID0gMDtcbiAgICB0aGlzLnBvc2l0aW9uUmF0aW8gPSAwLjU7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShOVU1CRVIpXG5dLCBQaWVTZXJpZXNTZWN0b3JMYWJlbC5wcm90b3R5cGUsIFwicG9zaXRpb25PZmZzZXRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTylcbl0sIFBpZVNlcmllc1NlY3RvckxhYmVsLnByb3RvdHlwZSwgXCJwb3NpdGlvblJhdGlvXCIsIDIpO1xudmFyIFBpZVNlcmllc0NhbGxvdXRMaW5lID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5sZW5ndGggPSAxMDtcbiAgICB0aGlzLnN0cm9rZVdpZHRoID0gMTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklOR19BUlJBWSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgUGllU2VyaWVzQ2FsbG91dExpbmUucHJvdG90eXBlLCBcImNvbG9yc1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIFBpZVNlcmllc0NhbGxvdXRMaW5lLnByb3RvdHlwZSwgXCJsZW5ndGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBQaWVTZXJpZXNDYWxsb3V0TGluZS5wcm90b3R5cGUsIFwic3Ryb2tlV2lkdGhcIiwgMik7XG52YXIgUGllU2VyaWVzUHJvcGVydGllcyA9IGNsYXNzIGV4dGVuZHMgU2VyaWVzUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5maWxscyA9IE9iamVjdC52YWx1ZXMoREVGQVVMVF9GSUxMUyk7XG4gICAgdGhpcy5zdHJva2VzID0gT2JqZWN0LnZhbHVlcyhERUZBVUxUX1NUUk9LRVMpO1xuICAgIHRoaXMuZmlsbE9wYWNpdHkgPSAxO1xuICAgIHRoaXMuc3Ryb2tlT3BhY2l0eSA9IDE7XG4gICAgdGhpcy5saW5lRGFzaCA9IFswXTtcbiAgICB0aGlzLmxpbmVEYXNoT2Zmc2V0ID0gMDtcbiAgICB0aGlzLmNvcm5lclJhZGl1cyA9IDA7XG4gICAgdGhpcy5yb3RhdGlvbiA9IDA7XG4gICAgdGhpcy5vdXRlclJhZGl1c09mZnNldCA9IDA7XG4gICAgdGhpcy5vdXRlclJhZGl1c1JhdGlvID0gMTtcbiAgICB0aGlzLnN0cm9rZVdpZHRoID0gMTtcbiAgICB0aGlzLnNlY3RvclNwYWNpbmcgPSAwO1xuICAgIHRoaXMudGl0bGUgPSBuZXcgUGllVGl0bGUoKTtcbiAgICB0aGlzLnNoYWRvdyA9IG5ldyBEcm9wU2hhZG93KCk7XG4gICAgdGhpcy5jYWxsb3V0TGFiZWwgPSBuZXcgUGllU2VyaWVzQ2FsbG91dExhYmVsKCk7XG4gICAgdGhpcy5zZWN0b3JMYWJlbCA9IG5ldyBQaWVTZXJpZXNTZWN0b3JMYWJlbCgpO1xuICAgIHRoaXMuY2FsbG91dExpbmUgPSBuZXcgUGllU2VyaWVzQ2FsbG91dExpbmUoKTtcbiAgICB0aGlzLnRvb2x0aXAgPSBuZXcgU2VyaWVzVG9vbHRpcCgpO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HKVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiYW5nbGVLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImFuZ2xlTmFtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiYW5nbGVGaWx0ZXJLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInJhZGl1c0tleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwicmFkaXVzTmFtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwicmFkaXVzTWluXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJyYWRpdXNNYXhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNhbGxvdXRMYWJlbEtleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiY2FsbG91dExhYmVsTmFtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic2VjdG9yTGFiZWxLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInNlY3RvckxhYmVsTmFtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGVnZW5kSXRlbUtleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklOR19BUlJBWSlcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImZpbGxzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HX0FSUkFZKVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic3Ryb2tlc1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPKVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiZmlsbE9wYWNpdHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTylcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0cm9rZU9wYWNpdHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShMSU5FX0RBU0gpXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJsaW5lRGFzaFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImxpbmVEYXNoT2Zmc2V0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiY29ybmVyUmFkaXVzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoRlVOQ1RJT04sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcIml0ZW1TdHlsZXJcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShERUdSRUUpXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJyb3RhdGlvblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE5VTUJFUilcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcIm91dGVyUmFkaXVzT2Zmc2V0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8pXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJvdXRlclJhZGl1c1JhdGlvXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic3Ryb2tlV2lkdGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShOVU1CRVIpXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzZWN0b3JTcGFjaW5nXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwidGl0bGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzaGFkb3dcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjYWxsb3V0TGFiZWxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzZWN0b3JMYWJlbFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNhbGxvdXRMaW5lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwidG9vbHRpcFwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL3BvbGFyL3BpZVNlcmllcy50c1xudmFyIFBpZVNlcmllc05vZGVFdmVudCA9IGNsYXNzIGV4dGVuZHMgU2VyaWVzTm9kZUV2ZW50IHtcbiAgY29uc3RydWN0b3IodHlwZSwgbmF0aXZlRXZlbnQsIGRhdHVtLCBzZXJpZXMpIHtcbiAgICBzdXBlcih0eXBlLCBuYXRpdmVFdmVudCwgZGF0dW0sIHNlcmllcyk7XG4gICAgdGhpcy5hbmdsZUtleSA9IHNlcmllcy5wcm9wZXJ0aWVzLmFuZ2xlS2V5O1xuICAgIHRoaXMucmFkaXVzS2V5ID0gc2VyaWVzLnByb3BlcnRpZXMucmFkaXVzS2V5O1xuICAgIHRoaXMuY2FsbG91dExhYmVsS2V5ID0gc2VyaWVzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsS2V5O1xuICAgIHRoaXMuc2VjdG9yTGFiZWxLZXkgPSBzZXJpZXMucHJvcGVydGllcy5zZWN0b3JMYWJlbEtleTtcbiAgfVxufTtcbnZhciBQaWVTZXJpZXMgPSBjbGFzcyBleHRlbmRzIFBvbGFyU2VyaWVzIHtcbiAgY29uc3RydWN0b3IobW9kdWxlQ3R4KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbW9kdWxlQ3R4LFxuICAgICAgcGlja01vZGVzOiBbMSAvKiBORUFSRVNUX05PREUgKi8sIDAgLyogRVhBQ1RfU0hBUEVfTUFUQ0ggKi9dLFxuICAgICAgdXNlTGFiZWxMYXllcjogdHJ1ZSxcbiAgICAgIGFuaW1hdGlvblJlc2V0Rm5zOiB7IGl0ZW06IHJlc2V0UGllU2VsZWN0aW9uc0ZuLCBsYWJlbDogcmVzZXRMYWJlbEZuIH1cbiAgICB9KTtcbiAgICB0aGlzLnByb3BlcnRpZXMgPSBuZXcgUGllU2VyaWVzUHJvcGVydGllcygpO1xuICAgIHRoaXMucGhhbnRvbU5vZGVEYXRhID0gdm9pZCAwO1xuICAgIHRoaXMucHJldmlvdXNSYWRpdXNTY2FsZSA9IG5ldyBMaW5lYXJTY2FsZSgpO1xuICAgIHRoaXMucmFkaXVzU2NhbGUgPSBuZXcgTGluZWFyU2NhbGUoKTtcbiAgICB0aGlzLnBoYW50b21Hcm91cCA9IHRoaXMuY29udGVudEdyb3VwLmFwcGVuZENoaWxkKG5ldyBHcm91cCgpKTtcbiAgICB0aGlzLnBoYW50b21TZWxlY3Rpb24gPSBTZWxlY3Rpb24uc2VsZWN0KFxuICAgICAgdGhpcy5waGFudG9tR3JvdXAsXG4gICAgICAoKSA9PiB0aGlzLm5vZGVGYWN0b3J5KCksXG4gICAgICBmYWxzZVxuICAgICk7XG4gICAgdGhpcy5jYWxsb3V0TGFiZWxHcm91cCA9IHRoaXMuY29udGVudEdyb3VwLmFwcGVuZENoaWxkKG5ldyBHcm91cCh7IG5hbWU6IFwicGllQ2FsbG91dExhYmVsc1wiIH0pKTtcbiAgICB0aGlzLmNhbGxvdXRMYWJlbFNlbGVjdGlvbiA9IG5ldyBTZWxlY3Rpb24oXG4gICAgICB0aGlzLmNhbGxvdXRMYWJlbEdyb3VwLFxuICAgICAgR3JvdXBcbiAgICApO1xuICAgIC8vIFRoZSBncm91cCBub2RlIHRoYXQgY29udGFpbnMgdGhlIGJhY2tncm91bmQgZ3JhcGhpY3MuXG4gICAgdGhpcy5iYWNrZ3JvdW5kR3JvdXAgPSB0aGlzLnJvb3RHcm91cC5hcHBlbmRDaGlsZChcbiAgICAgIG5ldyBUcmFuc2xhdGFibGVMYXllcih7XG4gICAgICAgIG5hbWU6IGAke3RoaXMuaWR9LWJhY2tncm91bmRgLFxuICAgICAgICB6SW5kZXg6IDAgLyogU0VSSUVTX0JBQ0tHUk9VTkQgKi9cbiAgICAgIH0pXG4gICAgKTtcbiAgICAvLyBBRy02MTkzIElmIHRoZSBzdW0gb2YgYWxsIGRhdHVtcyBpcyAwLCB0aGVuIHdlJ2xsIGRyYXcgMSBvciAyIHJpbmdzIHRvIHJlcHJlc2VudCB0aGUgZW1wdHkgc2VyaWVzLlxuICAgIHRoaXMuemVyb3N1bVJpbmdzR3JvdXAgPSB0aGlzLmJhY2tncm91bmRHcm91cC5hcHBlbmRDaGlsZChuZXcgR3JvdXAoeyBuYW1lOiBgJHt0aGlzLmlkfS16ZXJvc3VtUmluZ3NgIH0pKTtcbiAgICB0aGlzLnplcm9zdW1PdXRlclJpbmcgPSB0aGlzLnplcm9zdW1SaW5nc0dyb3VwLmFwcGVuZENoaWxkKG5ldyBDaXJjbGUoKSk7XG4gICAgLy8gV2hlbiBhIHVzZXIgdG9nZ2xlcyBhIHNlcmllcyBpdGVtIChlLmcuIGZyb20gdGhlIGxlZ2VuZCksIGl0cyBib29sZWFuIHN0YXRlIGlzIHJlY29yZGVkIGhlcmUuXG4gICAgdGhpcy5zZXJpZXNJdGVtRW5hYmxlZCA9IFtdO1xuICAgIHRoaXMubGVnZW5kSXRlbUVuYWJsZWQgPSBbXTtcbiAgICB0aGlzLnN1cnJvdW5kaW5nUmFkaXVzID0gdm9pZCAwO1xuICAgIHRoaXMuTm9kZUV2ZW50ID0gUGllU2VyaWVzTm9kZUV2ZW50O1xuICAgIHRoaXMuYW5nbGVTY2FsZSA9IG5ldyBMaW5lYXJTY2FsZSgpO1xuICAgIHRoaXMuYW5nbGVTY2FsZS5kb21haW4gPSBbMCwgMV07XG4gICAgdGhpcy5hbmdsZVNjYWxlLnJhbmdlID0gWy1NYXRoLlBJLCBNYXRoLlBJXS5tYXAoKGFuZ2xlMikgPT4gYW5nbGUyICsgTWF0aC5QSSAvIDIpO1xuICAgIHRoaXMucGhhbnRvbUdyb3VwLm9wYWNpdHkgPSAwLjI7XG4gICAgdGhpcy5waGFudG9tR3JvdXAuekluZGV4U3ViT3JkZXIgPSBbKCkgPT4gdGhpcy5fZGVjbGFyYXRpb25PcmRlciwgMF07XG4gIH1cbiAgZ2V0IGNhbGxvdXROb2RlRGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5waGFudG9tTm9kZURhdGEgPz8gdGhpcy5ub2RlRGF0YTtcbiAgfVxuICBhZGRDaGFydEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuZGVzdHJveUZucy5wdXNoKFxuICAgICAgdGhpcy5jdHguY2hhcnRFdmVudE1hbmFnZXI/LmFkZExpc3RlbmVyKFwibGVnZW5kLWl0ZW0tY2xpY2tcIiwgKGV2ZW50KSA9PiB0aGlzLm9uTGVnZW5kSXRlbUNsaWNrKGV2ZW50KSlcbiAgICApO1xuICB9XG4gIGdldCB2aXNpYmxlKCkge1xuICAgIHJldHVybiBzdXBlci52aXNpYmxlICYmICh0aGlzLnNlcmllc0l0ZW1FbmFibGVkLmxlbmd0aCA9PT0gMCB8fCB0aGlzLnNlcmllc0l0ZW1FbmFibGVkLmluY2x1ZGVzKHRydWUpKTtcbiAgfVxuICBub2RlRmFjdG9yeSgpIHtcbiAgICBjb25zdCBzZWN0b3IgPSBuZXcgU2VjdG9yKCk7XG4gICAgc2VjdG9yLm1pdGVyTGltaXQgPSAxZTk7XG4gICAgcmV0dXJuIHNlY3RvcjtcbiAgfVxuICBnZXRTZXJpZXNEb21haW4oZGlyZWN0aW9uKSB7XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJ4XCIgLyogWCAqLykge1xuICAgICAgcmV0dXJuIHRoaXMuYW5nbGVTY2FsZS5kb21haW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnJhZGl1c1NjYWxlLmRvbWFpbjtcbiAgICB9XG4gIH1cbiAgYXN5bmMgcHJvY2Vzc0RhdGEoZGF0YUNvbnRyb2xsZXIpIHtcbiAgICBpZiAodGhpcy5kYXRhID09IG51bGwgfHwgIXRoaXMucHJvcGVydGllcy5pc1ZhbGlkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHsgZGF0YSB9ID0gdGhpcztcbiAgICBjb25zdCB7IHZpc2libGUsIHNlcmllc0l0ZW1FbmFibGVkIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgYW5nbGVLZXksIGFuZ2xlRmlsdGVyS2V5LCByYWRpdXNLZXksIGNhbGxvdXRMYWJlbEtleSwgc2VjdG9yTGFiZWxLZXksIGxlZ2VuZEl0ZW1LZXkgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCBhbmltYXRpb25FbmFibGVkID0gIXRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuaXNTa2lwcGVkKCk7XG4gICAgY29uc3QgZXh0cmFLZXlQcm9wcyA9IFtdO1xuICAgIGNvbnN0IGV4dHJhUHJvcHMgPSBbXTtcbiAgICBpZiAobGVnZW5kSXRlbUtleSkge1xuICAgICAgZXh0cmFLZXlQcm9wcy5wdXNoKGtleVByb3BlcnR5KGxlZ2VuZEl0ZW1LZXksIFwiYmFuZFwiLCB7IGlkOiBgbGVnZW5kSXRlbUtleWAgfSkpO1xuICAgIH0gZWxzZSBpZiAoY2FsbG91dExhYmVsS2V5KSB7XG4gICAgICBleHRyYUtleVByb3BzLnB1c2goa2V5UHJvcGVydHkoY2FsbG91dExhYmVsS2V5LCBcImJhbmRcIiwgeyBpZDogYGNhbGxvdXRMYWJlbEtleWAgfSkpO1xuICAgIH0gZWxzZSBpZiAoc2VjdG9yTGFiZWxLZXkpIHtcbiAgICAgIGV4dHJhS2V5UHJvcHMucHVzaChrZXlQcm9wZXJ0eShzZWN0b3JMYWJlbEtleSwgXCJiYW5kXCIsIHsgaWQ6IGBzZWN0b3JMYWJlbEtleWAgfSkpO1xuICAgIH1cbiAgICBjb25zdCByYWRpdXNTY2FsZVR5cGUgPSB0aGlzLnJhZGl1c1NjYWxlLnR5cGU7XG4gICAgY29uc3QgYW5nbGVTY2FsZVR5cGUgPSB0aGlzLnJhZGl1c1NjYWxlLnR5cGU7XG4gICAgaWYgKHJhZGl1c0tleSkge1xuICAgICAgZXh0cmFQcm9wcy5wdXNoKFxuICAgICAgICByYW5nZWRWYWx1ZVByb3BlcnR5KHJhZGl1c0tleSwge1xuICAgICAgICAgIGlkOiBcInJhZGl1c1ZhbHVlXCIsXG4gICAgICAgICAgbWluOiB0aGlzLnByb3BlcnRpZXMucmFkaXVzTWluID8/IDAsXG4gICAgICAgICAgbWF4OiB0aGlzLnByb3BlcnRpZXMucmFkaXVzTWF4XG4gICAgICAgIH0pLFxuICAgICAgICB2YWx1ZVByb3BlcnR5KHJhZGl1c0tleSwgcmFkaXVzU2NhbGVUeXBlLCB7IGlkOiBgcmFkaXVzUmF3YCB9KSxcbiAgICAgICAgLy8gUmF3IHZhbHVlIHBhc3MtdGhyb3VnaC5cbiAgICAgICAgbm9ybWFsaXNlUHJvcGVydHlUbyhcInJhZGl1c1ZhbHVlXCIsIFswLCAxXSwgMSwgdGhpcy5wcm9wZXJ0aWVzLnJhZGl1c01pbiA/PyAwLCB0aGlzLnByb3BlcnRpZXMucmFkaXVzTWF4KVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGNhbGxvdXRMYWJlbEtleSkge1xuICAgICAgZXh0cmFQcm9wcy5wdXNoKHZhbHVlUHJvcGVydHkoY2FsbG91dExhYmVsS2V5LCBcImJhbmRcIiwgeyBpZDogYGNhbGxvdXRMYWJlbFZhbHVlYCB9KSk7XG4gICAgfVxuICAgIGlmIChzZWN0b3JMYWJlbEtleSkge1xuICAgICAgZXh0cmFQcm9wcy5wdXNoKHZhbHVlUHJvcGVydHkoc2VjdG9yTGFiZWxLZXksIFwiYmFuZFwiLCB7IGlkOiBgc2VjdG9yTGFiZWxWYWx1ZWAgfSkpO1xuICAgIH1cbiAgICBpZiAobGVnZW5kSXRlbUtleSkge1xuICAgICAgZXh0cmFQcm9wcy5wdXNoKHZhbHVlUHJvcGVydHkobGVnZW5kSXRlbUtleSwgXCJiYW5kXCIsIHsgaWQ6IGBsZWdlbmRJdGVtVmFsdWVgIH0pKTtcbiAgICB9XG4gICAgaWYgKGFuZ2xlRmlsdGVyS2V5KSB7XG4gICAgICBleHRyYVByb3BzLnB1c2goXG4gICAgICAgIGFjY3VtdWxhdGl2ZVZhbHVlUHJvcGVydHkoYW5nbGVGaWx0ZXJLZXksIGFuZ2xlU2NhbGVUeXBlLCB7XG4gICAgICAgICAgaWQ6IGBhbmdsZUZpbHRlclZhbHVlYCxcbiAgICAgICAgICBvbmx5UG9zaXRpdmU6IHRydWVcbiAgICAgICAgfSksXG4gICAgICAgIHZhbHVlUHJvcGVydHkoYW5nbGVGaWx0ZXJLZXksIGFuZ2xlU2NhbGVUeXBlLCB7IGlkOiBgYW5nbGVGaWx0ZXJSYXdgIH0pLFxuICAgICAgICBub3JtYWxpc2VQcm9wZXJ0eVRvKFwiYW5nbGVGaWx0ZXJWYWx1ZVwiLCBbMCwgMV0sIDAsIDApXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoYW5pbWF0aW9uRW5hYmxlZCAmJiB0aGlzLnByb2Nlc3NlZERhdGE/LnJlZHVjZWQ/LmFuaW1hdGlvblZhbGlkYXRpb24/LnVuaXF1ZUtleXMgJiYgZXh0cmFLZXlQcm9wcy5sZW5ndGggPiAwKSB7XG4gICAgICBleHRyYVByb3BzLnB1c2goZGlmZih0aGlzLnByb2Nlc3NlZERhdGEpKTtcbiAgICB9XG4gICAgZXh0cmFQcm9wcy5wdXNoKGFuaW1hdGlvblZhbGlkYXRpb24oKSk7XG4gICAgZGF0YSA9IGRhdGEubWFwKChkLCBpZHgpID0+IHZpc2libGUgJiYgc2VyaWVzSXRlbUVuYWJsZWRbaWR4XSA/IGQgOiB7IC4uLmQsIFthbmdsZUtleV06IDAgfSk7XG4gICAgYXdhaXQgdGhpcy5yZXF1ZXN0RGF0YU1vZGVsKGRhdGFDb250cm9sbGVyLCBkYXRhLCB7XG4gICAgICBwcm9wczogW1xuICAgICAgICAuLi5leHRyYUtleVByb3BzLFxuICAgICAgICBhY2N1bXVsYXRpdmVWYWx1ZVByb3BlcnR5KGFuZ2xlS2V5LCBhbmdsZVNjYWxlVHlwZSwgeyBpZDogYGFuZ2xlVmFsdWVgLCBvbmx5UG9zaXRpdmU6IHRydWUgfSksXG4gICAgICAgIHZhbHVlUHJvcGVydHkoYW5nbGVLZXksIGFuZ2xlU2NhbGVUeXBlLCB7IGlkOiBgYW5nbGVSYXdgIH0pLFxuICAgICAgICAvLyBSYXcgdmFsdWUgcGFzcy10aHJvdWdoLlxuICAgICAgICBub3JtYWxpc2VQcm9wZXJ0eVRvKFwiYW5nbGVWYWx1ZVwiLCBbMCwgMV0sIDAsIDApLFxuICAgICAgICAuLi5leHRyYVByb3BzXG4gICAgICBdXG4gICAgfSk7XG4gICAgZm9yIChjb25zdCB2YWx1ZURlZiBvZiB0aGlzLnByb2Nlc3NlZERhdGE/LmRlZnM/LnZhbHVlcyA/PyBbXSkge1xuICAgICAgY29uc3QgeyBpZCwgbWlzc2luZywgcHJvcGVydHkgfSA9IHZhbHVlRGVmO1xuICAgICAgY29uc3QgbWlzc0NvdW50ID0gZ2V0TWlzc0NvdW50KHRoaXMsIG1pc3NpbmcpO1xuICAgICAgaWYgKGlkICE9PSBcImFuZ2xlUmF3XCIgJiYgbWlzc0NvdW50ID4gMCkge1xuICAgICAgICBMb2dnZXIud2Fybk9uY2UoXG4gICAgICAgICAgYG5vIHZhbHVlIHdhcyBmb3VuZCBmb3IgdGhlIGtleSAnJHtTdHJpbmcocHJvcGVydHkpfScgb24gJHttaXNzQ291bnR9IGRhdGEgZWxlbWVudCR7bWlzc0NvdW50ID4gMSA/IFwic1wiIDogXCJcIn1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcInVwZGF0ZURhdGFcIik7XG4gIH1cbiAgYXN5bmMgbWF5YmVSZWZyZXNoTm9kZURhdGEoKSB7XG4gICAgaWYgKCF0aGlzLm5vZGVEYXRhUmVmcmVzaClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IG5vZGVEYXRhID0gW10sIHBoYW50b21Ob2RlRGF0YSB9ID0gYXdhaXQgdGhpcy5jcmVhdGVOb2RlRGF0YSgpID8/IHt9O1xuICAgIHRoaXMubm9kZURhdGEgPSBub2RlRGF0YTtcbiAgICB0aGlzLnBoYW50b21Ob2RlRGF0YSA9IHBoYW50b21Ob2RlRGF0YTtcbiAgICB0aGlzLm5vZGVEYXRhUmVmcmVzaCA9IGZhbHNlO1xuICB9XG4gIGdldFByb2Nlc3NlZERhdGFJbmRleGVzKGRhdGFNb2RlbCkge1xuICAgIGNvbnN0IGFuZ2xlSWR4ID0gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGBhbmdsZVZhbHVlYCk7XG4gICAgY29uc3QgYW5nbGVSYXdJZHggPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYGFuZ2xlUmF3YCk7XG4gICAgY29uc3QgYW5nbGVGaWx0ZXJJZHggPSB0aGlzLnByb3BlcnRpZXMuYW5nbGVGaWx0ZXJLZXkgIT0gbnVsbCA/IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgYW5nbGVGaWx0ZXJWYWx1ZWApIDogdm9pZCAwO1xuICAgIGNvbnN0IGFuZ2xlRmlsdGVyUmF3SWR4ID0gdGhpcy5wcm9wZXJ0aWVzLmFuZ2xlRmlsdGVyS2V5ICE9IG51bGwgPyBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYGFuZ2xlRmlsdGVyUmF3YCkgOiB2b2lkIDA7XG4gICAgY29uc3QgcmFkaXVzSWR4ID0gdGhpcy5wcm9wZXJ0aWVzLnJhZGl1c0tleSA/IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgcmFkaXVzVmFsdWVgKSA6IHZvaWQgMDtcbiAgICBjb25zdCByYWRpdXNSYXdJZHggPSB0aGlzLnByb3BlcnRpZXMucmFkaXVzS2V5ID8gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGByYWRpdXNSYXdgKSA6IHZvaWQgMDtcbiAgICBjb25zdCBjYWxsb3V0TGFiZWxJZHggPSB0aGlzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsS2V5ID8gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGBjYWxsb3V0TGFiZWxWYWx1ZWApIDogdm9pZCAwO1xuICAgIGNvbnN0IHNlY3RvckxhYmVsSWR4ID0gdGhpcy5wcm9wZXJ0aWVzLnNlY3RvckxhYmVsS2V5ID8gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGBzZWN0b3JMYWJlbFZhbHVlYCkgOiB2b2lkIDA7XG4gICAgY29uc3QgbGVnZW5kSXRlbUlkeCA9IHRoaXMucHJvcGVydGllcy5sZWdlbmRJdGVtS2V5ID8gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGBsZWdlbmRJdGVtVmFsdWVgKSA6IHZvaWQgMDtcbiAgICByZXR1cm4ge1xuICAgICAgYW5nbGVJZHgsXG4gICAgICBhbmdsZVJhd0lkeCxcbiAgICAgIGFuZ2xlRmlsdGVySWR4LFxuICAgICAgYW5nbGVGaWx0ZXJSYXdJZHgsXG4gICAgICByYWRpdXNJZHgsXG4gICAgICByYWRpdXNSYXdJZHgsXG4gICAgICBjYWxsb3V0TGFiZWxJZHgsXG4gICAgICBzZWN0b3JMYWJlbElkeCxcbiAgICAgIGxlZ2VuZEl0ZW1JZHhcbiAgICB9O1xuICB9XG4gIGFzeW5jIGNyZWF0ZU5vZGVEYXRhKCkge1xuICAgIGNvbnN0IHsgaWQ6IHNlcmllc0lkLCBwcm9jZXNzZWREYXRhLCBkYXRhTW9kZWwsIGFuZ2xlU2NhbGUgfSA9IHRoaXM7XG4gICAgY29uc3QgeyByb3RhdGlvbiB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGlmICghcHJvY2Vzc2VkRGF0YSB8fCAhZGF0YU1vZGVsIHx8IHByb2Nlc3NlZERhdGEudHlwZSAhPT0gXCJ1bmdyb3VwZWRcIilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7XG4gICAgICBhbmdsZUlkeCxcbiAgICAgIGFuZ2xlUmF3SWR4LFxuICAgICAgYW5nbGVGaWx0ZXJJZHgsXG4gICAgICBhbmdsZUZpbHRlclJhd0lkeCxcbiAgICAgIHJhZGl1c0lkeCxcbiAgICAgIHJhZGl1c1Jhd0lkeCxcbiAgICAgIGNhbGxvdXRMYWJlbElkeCxcbiAgICAgIHNlY3RvckxhYmVsSWR4LFxuICAgICAgbGVnZW5kSXRlbUlkeFxuICAgIH0gPSB0aGlzLmdldFByb2Nlc3NlZERhdGFJbmRleGVzKGRhdGFNb2RlbCk7XG4gICAgY29uc3QgdXNlRmlsdGVyQW5nbGVzID0gYW5nbGVGaWx0ZXJSYXdJZHggIT0gbnVsbCAmJiBwcm9jZXNzZWREYXRhLmRhdGEuc29tZSgoeyB2YWx1ZXMgfSkgPT4ge1xuICAgICAgcmV0dXJuIHZhbHVlc1thbmdsZUZpbHRlclJhd0lkeF0gPiB2YWx1ZXNbYW5nbGVSYXdJZHhdO1xuICAgIH0pO1xuICAgIGxldCBjdXJyZW50U3RhcnQgPSAwO1xuICAgIGxldCBzdW0yID0gMDtcbiAgICBjb25zdCBub2RlcyA9IFtdO1xuICAgIGNvbnN0IHBoYW50b21Ob2RlcyA9IGFuZ2xlRmlsdGVyUmF3SWR4ICE9IG51bGwgPyBbXSA6IHZvaWQgMDtcbiAgICBwcm9jZXNzZWREYXRhLmRhdGEuZm9yRWFjaCgoZ3JvdXAsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCB7IGRhdHVtLCB2YWx1ZXMgfSA9IGdyb3VwO1xuICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gdXNlRmlsdGVyQW5nbGVzID8gdmFsdWVzW2FuZ2xlRmlsdGVySWR4XSA6IHZhbHVlc1thbmdsZUlkeF07XG4gICAgICBjb25zdCBjcm9zc0ZpbHRlclNjYWxlID0gYW5nbGVGaWx0ZXJSYXdJZHggIT0gbnVsbCAmJiAhdXNlRmlsdGVyQW5nbGVzID8gTWF0aC5zcXJ0KHZhbHVlc1thbmdsZUZpbHRlclJhd0lkeF0gLyB2YWx1ZXNbYW5nbGVSYXdJZHhdKSA6IDE7XG4gICAgICBjb25zdCBzdGFydEFuZ2xlID0gYW5nbGVTY2FsZS5jb252ZXJ0KGN1cnJlbnRTdGFydCkgKyB0b1JhZGlhbnMocm90YXRpb24pO1xuICAgICAgY3VycmVudFN0YXJ0ID0gY3VycmVudFZhbHVlO1xuICAgICAgc3VtMiArPSBjdXJyZW50VmFsdWU7XG4gICAgICBjb25zdCBlbmRBbmdsZSA9IGFuZ2xlU2NhbGUuY29udmVydChjdXJyZW50U3RhcnQpICsgdG9SYWRpYW5zKHJvdGF0aW9uKTtcbiAgICAgIGNvbnN0IHNwYW4gPSBNYXRoLmFicyhlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpO1xuICAgICAgY29uc3QgbWlkQW5nbGUgPSBzdGFydEFuZ2xlICsgc3BhbiAvIDI7XG4gICAgICBjb25zdCBhbmdsZVZhbHVlID0gdmFsdWVzW2FuZ2xlUmF3SWR4XTtcbiAgICAgIGNvbnN0IHJhZGl1c1JhdyA9IHJhZGl1c0lkeCAhPSBudWxsID8gdmFsdWVzW3JhZGl1c0lkeF0gPz8gMSA6IDE7XG4gICAgICBjb25zdCByYWRpdXMgPSByYWRpdXNSYXcgKiBjcm9zc0ZpbHRlclNjYWxlO1xuICAgICAgY29uc3QgcmFkaXVzVmFsdWUgPSByYWRpdXNSYXdJZHggIT0gbnVsbCA/IHZhbHVlc1tyYWRpdXNSYXdJZHhdIDogdm9pZCAwO1xuICAgICAgY29uc3QgbGVnZW5kSXRlbVZhbHVlID0gbGVnZW5kSXRlbUlkeCAhPSBudWxsID8gdmFsdWVzW2xlZ2VuZEl0ZW1JZHhdIDogdm9pZCAwO1xuICAgICAgY29uc3Qgbm9kZUxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKFxuICAgICAgICBkYXR1bSxcbiAgICAgICAgbWlkQW5nbGUsXG4gICAgICAgIHNwYW4sXG4gICAgICAgIHRydWUsXG4gICAgICAgIGNhbGxvdXRMYWJlbElkeCAhPSBudWxsID8gdmFsdWVzW2NhbGxvdXRMYWJlbElkeF0gOiB2b2lkIDAsXG4gICAgICAgIHNlY3RvckxhYmVsSWR4ICE9IG51bGwgPyB2YWx1ZXNbc2VjdG9yTGFiZWxJZHhdIDogdm9pZCAwLFxuICAgICAgICBsZWdlbmRJdGVtVmFsdWVcbiAgICAgICk7XG4gICAgICBjb25zdCBzZWN0b3JGb3JtYXQgPSB0aGlzLmdldFNlY3RvckZvcm1hdChkYXR1bSwgaW5kZXgsIGZhbHNlKTtcbiAgICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICAgIGl0ZW1JZDogaW5kZXgsXG4gICAgICAgIHNlcmllczogdGhpcyxcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIGluZGV4LFxuICAgICAgICBhbmdsZVZhbHVlLFxuICAgICAgICBtaWRBbmdsZSxcbiAgICAgICAgbWlkQ29zOiBNYXRoLmNvcyhtaWRBbmdsZSksXG4gICAgICAgIG1pZFNpbjogTWF0aC5zaW4obWlkQW5nbGUpLFxuICAgICAgICBzdGFydEFuZ2xlLFxuICAgICAgICBlbmRBbmdsZSxcbiAgICAgICAgcmFkaXVzLFxuICAgICAgICBpbm5lclJhZGl1czogTWF0aC5tYXgodGhpcy5yYWRpdXNTY2FsZS5jb252ZXJ0KDApLCAwKSxcbiAgICAgICAgb3V0ZXJSYWRpdXM6IE1hdGgubWF4KHRoaXMucmFkaXVzU2NhbGUuY29udmVydChyYWRpdXMpLCAwKSxcbiAgICAgICAgc2VjdG9yRm9ybWF0LFxuICAgICAgICByYWRpdXNWYWx1ZSxcbiAgICAgICAgbGVnZW5kSXRlbVZhbHVlLFxuICAgICAgICBlbmFibGVkOiB0aGlzLnNlcmllc0l0ZW1FbmFibGVkW2luZGV4XSxcbiAgICAgICAgLi4ubm9kZUxhYmVsc1xuICAgICAgfTtcbiAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgICBpZiAocGhhbnRvbU5vZGVzICE9IG51bGwpIHtcbiAgICAgICAgcGhhbnRvbU5vZGVzLnB1c2goe1xuICAgICAgICAgIC4uLm5vZGUsXG4gICAgICAgICAgcmFkaXVzOiAxLFxuICAgICAgICAgIGlubmVyUmFkaXVzOiBNYXRoLm1heCh0aGlzLnJhZGl1c1NjYWxlLmNvbnZlcnQoMCksIDApLFxuICAgICAgICAgIG91dGVyUmFkaXVzOiBNYXRoLm1heCh0aGlzLnJhZGl1c1NjYWxlLmNvbnZlcnQoMSksIDApXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuemVyb3N1bU91dGVyUmluZy52aXNpYmxlID0gc3VtMiA9PT0gMDtcbiAgICByZXR1cm4ge1xuICAgICAgaXRlbUlkOiBzZXJpZXNJZCxcbiAgICAgIG5vZGVEYXRhOiBub2RlcyxcbiAgICAgIGxhYmVsRGF0YTogbm9kZXMsXG4gICAgICBwaGFudG9tTm9kZURhdGE6IHBoYW50b21Ob2Rlc1xuICAgIH07XG4gIH1cbiAgZ2V0TGFiZWxzKGRhdHVtLCBtaWRBbmdsZSwgc3Bhbiwgc2tpcERpc2FibGVkLCBjYWxsb3V0TGFiZWxWYWx1ZSwgc2VjdG9yTGFiZWxWYWx1ZSwgbGVnZW5kSXRlbVZhbHVlKSB7XG4gICAgY29uc3QgeyBjYWxsb3V0TGFiZWwsIHNlY3RvckxhYmVsLCBsZWdlbmRJdGVtS2V5IH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgY2FsbG91dExhYmVsS2V5ID0gIXNraXBEaXNhYmxlZCB8fCBjYWxsb3V0TGFiZWwuZW5hYmxlZCA/IHRoaXMucHJvcGVydGllcy5jYWxsb3V0TGFiZWxLZXkgOiB2b2lkIDA7XG4gICAgY29uc3Qgc2VjdG9yTGFiZWxLZXkgPSAhc2tpcERpc2FibGVkIHx8IHNlY3RvckxhYmVsLmVuYWJsZWQgPyB0aGlzLnByb3BlcnRpZXMuc2VjdG9yTGFiZWxLZXkgOiB2b2lkIDA7XG4gICAgaWYgKCFjYWxsb3V0TGFiZWxLZXkgJiYgIXNlY3RvckxhYmVsS2V5ICYmICFsZWdlbmRJdGVtS2V5KSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IGxhYmVsRm9ybWF0dGVyUGFyYW1zID0ge1xuICAgICAgZGF0dW0sXG4gICAgICBhbmdsZUtleTogdGhpcy5wcm9wZXJ0aWVzLmFuZ2xlS2V5LFxuICAgICAgYW5nbGVOYW1lOiB0aGlzLnByb3BlcnRpZXMuYW5nbGVOYW1lLFxuICAgICAgcmFkaXVzS2V5OiB0aGlzLnByb3BlcnRpZXMucmFkaXVzS2V5LFxuICAgICAgcmFkaXVzTmFtZTogdGhpcy5wcm9wZXJ0aWVzLnJhZGl1c05hbWUsXG4gICAgICBjYWxsb3V0TGFiZWxLZXk6IHRoaXMucHJvcGVydGllcy5jYWxsb3V0TGFiZWxLZXksXG4gICAgICBjYWxsb3V0TGFiZWxOYW1lOiB0aGlzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsTmFtZSxcbiAgICAgIHNlY3RvckxhYmVsS2V5OiB0aGlzLnByb3BlcnRpZXMuc2VjdG9yTGFiZWxLZXksXG4gICAgICBzZWN0b3JMYWJlbE5hbWU6IHRoaXMucHJvcGVydGllcy5zZWN0b3JMYWJlbE5hbWUsXG4gICAgICBsZWdlbmRJdGVtS2V5OiB0aGlzLnByb3BlcnRpZXMubGVnZW5kSXRlbUtleVxuICAgIH07XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgaWYgKGNhbGxvdXRMYWJlbEtleSAmJiBzcGFuID4gdG9SYWRpYW5zKGNhbGxvdXRMYWJlbC5taW5BbmdsZSkpIHtcbiAgICAgIHJlc3VsdC5jYWxsb3V0TGFiZWwgPSB7XG4gICAgICAgIC4uLnRoaXMuZ2V0VGV4dEFsaWdubWVudChtaWRBbmdsZSksXG4gICAgICAgIHRleHQ6IHRoaXMuZ2V0TGFiZWxUZXh0KGNhbGxvdXRMYWJlbCwge1xuICAgICAgICAgIC4uLmxhYmVsRm9ybWF0dGVyUGFyYW1zLFxuICAgICAgICAgIHZhbHVlOiBjYWxsb3V0TGFiZWxWYWx1ZVxuICAgICAgICB9KSxcbiAgICAgICAgaGlkZGVuOiBmYWxzZSxcbiAgICAgICAgY29sbGlzaW9uVGV4dEFsaWduOiB2b2lkIDAsXG4gICAgICAgIGNvbGxpc2lvbk9mZnNldFk6IDAsXG4gICAgICAgIGJveDogdm9pZCAwXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoc2VjdG9yTGFiZWxLZXkpIHtcbiAgICAgIHJlc3VsdC5zZWN0b3JMYWJlbCA9IHtcbiAgICAgICAgdGV4dDogdGhpcy5nZXRMYWJlbFRleHQoc2VjdG9yTGFiZWwsIHtcbiAgICAgICAgICAuLi5sYWJlbEZvcm1hdHRlclBhcmFtcyxcbiAgICAgICAgICB2YWx1ZTogc2VjdG9yTGFiZWxWYWx1ZVxuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGxlZ2VuZEl0ZW1LZXkgIT0gbnVsbCAmJiBsZWdlbmRJdGVtVmFsdWUgIT0gbnVsbCkge1xuICAgICAgcmVzdWx0LmxlZ2VuZEl0ZW0gPSB7IGtleTogbGVnZW5kSXRlbUtleSwgdGV4dDogbGVnZW5kSXRlbVZhbHVlIH07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZ2V0VGV4dEFsaWdubWVudChtaWRBbmdsZSkge1xuICAgIGNvbnN0IHF1YWRyYW50VGV4dE9wdHMgPSBbXG4gICAgICB7IHRleHRBbGlnbjogXCJjZW50ZXJcIiwgdGV4dEJhc2VsaW5lOiBcImJvdHRvbVwiIH0sXG4gICAgICB7IHRleHRBbGlnbjogXCJsZWZ0XCIsIHRleHRCYXNlbGluZTogXCJtaWRkbGVcIiB9LFxuICAgICAgeyB0ZXh0QWxpZ246IFwiY2VudGVyXCIsIHRleHRCYXNlbGluZTogXCJoYW5naW5nXCIgfSxcbiAgICAgIHsgdGV4dEFsaWduOiBcInJpZ2h0XCIsIHRleHRCYXNlbGluZTogXCJtaWRkbGVcIiB9XG4gICAgXTtcbiAgICBjb25zdCBtaWRBbmdsZTE4MCA9IG5vcm1hbGl6ZUFuZ2xlMTgwKG1pZEFuZ2xlKTtcbiAgICBjb25zdCBxdWFkcmFudFN0YXJ0ID0gLTAuNzUgKiBNYXRoLlBJO1xuICAgIGNvbnN0IHF1YWRyYW50T2Zmc2V0ID0gbWlkQW5nbGUxODAgLSBxdWFkcmFudFN0YXJ0O1xuICAgIGNvbnN0IHF1YWRyYW50ID0gTWF0aC5mbG9vcihxdWFkcmFudE9mZnNldCAvIChNYXRoLlBJIC8gMikpO1xuICAgIGNvbnN0IHF1YWRyYW50SW5kZXggPSBtb2QocXVhZHJhbnQsIHF1YWRyYW50VGV4dE9wdHMubGVuZ3RoKTtcbiAgICByZXR1cm4gcXVhZHJhbnRUZXh0T3B0c1txdWFkcmFudEluZGV4XTtcbiAgfVxuICBnZXRTZWN0b3JGb3JtYXQoZGF0dW0sIGZvcm1hdEluZGV4LCBoaWdobGlnaHRlZCkge1xuICAgIGNvbnN0IHsgY2FsbGJhY2tDYWNoZSB9ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgeyBhbmdsZUtleSwgcmFkaXVzS2V5LCBjYWxsb3V0TGFiZWxLZXksIHNlY3RvckxhYmVsS2V5LCBsZWdlbmRJdGVtS2V5LCBmaWxscywgc3Ryb2tlcywgaXRlbVN0eWxlciB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGRlZmF1bHRTdHJva2UgPSBzdHJva2VzW2Zvcm1hdEluZGV4ICUgc3Ryb2tlcy5sZW5ndGhdO1xuICAgIGNvbnN0IHsgZmlsbCwgZmlsbE9wYWNpdHksIHN0cm9rZSwgc3Ryb2tlV2lkdGgsIHN0cm9rZU9wYWNpdHksIGxpbmVEYXNoLCBsaW5lRGFzaE9mZnNldCwgY29ybmVyUmFkaXVzIH0gPSBtZXJnZURlZmF1bHRzKFxuICAgICAgaGlnaGxpZ2h0ZWQgJiYgdGhpcy5wcm9wZXJ0aWVzLmhpZ2hsaWdodFN0eWxlLml0ZW0sXG4gICAgICB7XG4gICAgICAgIGZpbGw6IGZpbGxzLmxlbmd0aCA+IDAgPyBmaWxsc1tmb3JtYXRJbmRleCAlIGZpbGxzLmxlbmd0aF0gOiB2b2lkIDAsXG4gICAgICAgIHN0cm9rZTogZGVmYXVsdFN0cm9rZSxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IHRoaXMuZ2V0U3Ryb2tlV2lkdGgodGhpcy5wcm9wZXJ0aWVzLnN0cm9rZVdpZHRoKSxcbiAgICAgICAgc3Ryb2tlT3BhY2l0eTogdGhpcy5nZXRPcGFjaXR5KClcbiAgICAgIH0sXG4gICAgICB0aGlzLnByb3BlcnRpZXNcbiAgICApO1xuICAgIGxldCBmb3JtYXQ7XG4gICAgaWYgKGl0ZW1TdHlsZXIpIHtcbiAgICAgIGZvcm1hdCA9IGNhbGxiYWNrQ2FjaGUuY2FsbChpdGVtU3R5bGVyLCB7XG4gICAgICAgIGRhdHVtLFxuICAgICAgICBhbmdsZUtleSxcbiAgICAgICAgcmFkaXVzS2V5LFxuICAgICAgICBjYWxsb3V0TGFiZWxLZXksXG4gICAgICAgIHNlY3RvckxhYmVsS2V5LFxuICAgICAgICBsZWdlbmRJdGVtS2V5LFxuICAgICAgICBmaWxsLFxuICAgICAgICBzdHJva2VPcGFjaXR5LFxuICAgICAgICBzdHJva2UsXG4gICAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgICBmaWxsT3BhY2l0eSxcbiAgICAgICAgbGluZURhc2gsXG4gICAgICAgIGxpbmVEYXNoT2Zmc2V0LFxuICAgICAgICBjb3JuZXJSYWRpdXMsXG4gICAgICAgIGhpZ2hsaWdodGVkLFxuICAgICAgICBzZXJpZXNJZDogdGhpcy5pZFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBmaWxsOiBmb3JtYXQ/LmZpbGwgPz8gZmlsbCxcbiAgICAgIGZpbGxPcGFjaXR5OiBmb3JtYXQ/LmZpbGxPcGFjaXR5ID8/IGZpbGxPcGFjaXR5LFxuICAgICAgc3Ryb2tlOiBmb3JtYXQ/LnN0cm9rZSA/PyBzdHJva2UsXG4gICAgICBzdHJva2VXaWR0aDogZm9ybWF0Py5zdHJva2VXaWR0aCA/PyBzdHJva2VXaWR0aCxcbiAgICAgIHN0cm9rZU9wYWNpdHk6IGZvcm1hdD8uc3Ryb2tlT3BhY2l0eSA/PyBzdHJva2VPcGFjaXR5LFxuICAgICAgbGluZURhc2g6IGZvcm1hdD8ubGluZURhc2ggPz8gbGluZURhc2gsXG4gICAgICBsaW5lRGFzaE9mZnNldDogZm9ybWF0Py5saW5lRGFzaE9mZnNldCA/PyBsaW5lRGFzaE9mZnNldCxcbiAgICAgIGNvcm5lclJhZGl1czogZm9ybWF0Py5jb3JuZXJSYWRpdXMgPz8gY29ybmVyUmFkaXVzXG4gICAgfTtcbiAgfVxuICBnZXRPdXRlclJhZGl1cygpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5yYWRpdXMgKiB0aGlzLnByb3BlcnRpZXMub3V0ZXJSYWRpdXNSYXRpbyArIHRoaXMucHJvcGVydGllcy5vdXRlclJhZGl1c09mZnNldCwgMCk7XG4gIH1cbiAgdXBkYXRlUmFkaXVzU2NhbGUocmVzaXplKSB7XG4gICAgY29uc3QgbmV3UmFuZ2UgPSBbMCwgdGhpcy5nZXRPdXRlclJhZGl1cygpXTtcbiAgICB0aGlzLnJhZGl1c1NjYWxlLnJhbmdlID0gbmV3UmFuZ2U7XG4gICAgaWYgKHJlc2l6ZSkge1xuICAgICAgdGhpcy5wcmV2aW91c1JhZGl1c1NjYWxlLnJhbmdlID0gbmV3UmFuZ2U7XG4gICAgfVxuICAgIGNvbnN0IHNldFJhZGlpID0gKGQpID0+ICh7XG4gICAgICAuLi5kLFxuICAgICAgaW5uZXJSYWRpdXM6IE1hdGgubWF4KHRoaXMucmFkaXVzU2NhbGUuY29udmVydCgwKSwgMCksXG4gICAgICBvdXRlclJhZGl1czogTWF0aC5tYXgodGhpcy5yYWRpdXNTY2FsZS5jb252ZXJ0KGQucmFkaXVzKSwgMClcbiAgICB9KTtcbiAgICB0aGlzLm5vZGVEYXRhID0gdGhpcy5ub2RlRGF0YS5tYXAoc2V0UmFkaWkpO1xuICAgIHRoaXMucGhhbnRvbU5vZGVEYXRhID0gdGhpcy5waGFudG9tTm9kZURhdGE/Lm1hcChzZXRSYWRpaSk7XG4gIH1cbiAgZ2V0VGl0bGVUcmFuc2xhdGlvblkoKSB7XG4gICAgY29uc3Qgb3V0ZXJSYWRpdXMgPSBNYXRoLm1heCgwLCB0aGlzLnJhZGl1c1NjYWxlLnJhbmdlWzFdKTtcbiAgICBpZiAob3V0ZXJSYWRpdXMgPT09IDApIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIGNvbnN0IHNwYWNpbmcgPSB0aGlzLnByb3BlcnRpZXMudGl0bGU/LnNwYWNpbmcgPz8gMDtcbiAgICBjb25zdCB0aXRsZU9mZnNldCA9IDIgKyBzcGFjaW5nO1xuICAgIGNvbnN0IGR5ID0gTWF0aC5tYXgoMCwgLW91dGVyUmFkaXVzKTtcbiAgICByZXR1cm4gLW91dGVyUmFkaXVzIC0gdGl0bGVPZmZzZXQgLSBkeTtcbiAgfVxuICBhc3luYyB1cGRhdGUoeyBzZXJpZXNSZWN0IH0pIHtcbiAgICBjb25zdCB7IHRpdGxlIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgbmV3Tm9kZURhdGFEZXBlbmRlbmNpZXMgPSB7XG4gICAgICBzZXJpZXNSZWN0V2lkdGg6IHNlcmllc1JlY3Q/LndpZHRoLFxuICAgICAgc2VyaWVzUmVjdEhlaWdodDogc2VyaWVzUmVjdD8uaGVpZ2h0XG4gICAgfTtcbiAgICBjb25zdCByZXNpemUgPSBqc29uRGlmZih0aGlzLm5vZGVEYXRhRGVwZW5kZW5jaWVzLCBuZXdOb2RlRGF0YURlcGVuZGVuY2llcykgIT0gbnVsbDtcbiAgICBpZiAocmVzaXplKSB7XG4gICAgICB0aGlzLl9ub2RlRGF0YURlcGVuZGVuY2llcyA9IG5ld05vZGVEYXRhRGVwZW5kZW5jaWVzO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLm1heWJlUmVmcmVzaE5vZGVEYXRhKCk7XG4gICAgdGhpcy51cGRhdGVUaXRsZU5vZGVzKCk7XG4gICAgdGhpcy51cGRhdGVSYWRpdXNTY2FsZShyZXNpemUpO1xuICAgIHRoaXMuY29udGVudEdyb3VwLnRyYW5zbGF0aW9uWCA9IHRoaXMuY2VudGVyWDtcbiAgICB0aGlzLmNvbnRlbnRHcm91cC50cmFuc2xhdGlvblkgPSB0aGlzLmNlbnRlclk7XG4gICAgdGhpcy5oaWdobGlnaHRHcm91cC50cmFuc2xhdGlvblggPSB0aGlzLmNlbnRlclg7XG4gICAgdGhpcy5oaWdobGlnaHRHcm91cC50cmFuc2xhdGlvblkgPSB0aGlzLmNlbnRlclk7XG4gICAgdGhpcy5iYWNrZ3JvdW5kR3JvdXAudHJhbnNsYXRpb25YID0gdGhpcy5jZW50ZXJYO1xuICAgIHRoaXMuYmFja2dyb3VuZEdyb3VwLnRyYW5zbGF0aW9uWSA9IHRoaXMuY2VudGVyWTtcbiAgICBpZiAodGhpcy5sYWJlbEdyb3VwKSB7XG4gICAgICB0aGlzLmxhYmVsR3JvdXAudHJhbnNsYXRpb25YID0gdGhpcy5jZW50ZXJYO1xuICAgICAgdGhpcy5sYWJlbEdyb3VwLnRyYW5zbGF0aW9uWSA9IHRoaXMuY2VudGVyWTtcbiAgICB9XG4gICAgaWYgKHRpdGxlKSB7XG4gICAgICBjb25zdCBkeSA9IHRoaXMuZ2V0VGl0bGVUcmFuc2xhdGlvblkoKTtcbiAgICAgIHRpdGxlLm5vZGUueSA9IGlzRmluaXRlKGR5KSA/IGR5IDogMDtcbiAgICAgIGNvbnN0IHRpdGxlQm94ID0gdGl0bGUubm9kZS5nZXRCQm94KCk7XG4gICAgICB0aXRsZS5ub2RlLnZpc2libGUgPSB0aXRsZS5lbmFibGVkICYmIGlzRmluaXRlKGR5KSAmJiAhdGhpcy5iYm94SW50ZXJzZWN0c1N1cnJvdW5kaW5nU2VyaWVzKHRpdGxlQm94KTtcbiAgICB9XG4gICAgdGhpcy56ZXJvc3VtT3V0ZXJSaW5nLmZpbGxPcGFjaXR5ID0gMDtcbiAgICB0aGlzLnplcm9zdW1PdXRlclJpbmcuc3Ryb2tlID0gdGhpcy5wcm9wZXJ0aWVzLmNhbGxvdXRMYWJlbC5jb2xvcjtcbiAgICB0aGlzLnplcm9zdW1PdXRlclJpbmcuc3Ryb2tlV2lkdGggPSAxO1xuICAgIHRoaXMuemVyb3N1bU91dGVyUmluZy5zdHJva2VPcGFjaXR5ID0gMTtcbiAgICB0aGlzLnVwZGF0ZU5vZGVNaWRQb2ludCgpO1xuICAgIGF3YWl0IHRoaXMudXBkYXRlU2VsZWN0aW9ucygpO1xuICAgIGF3YWl0IHRoaXMudXBkYXRlTm9kZXMoc2VyaWVzUmVjdCk7XG4gIH1cbiAgdXBkYXRlVGl0bGVOb2RlcygpIHtcbiAgICBjb25zdCB7IG9sZFRpdGxlIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgdGl0bGUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBpZiAob2xkVGl0bGUgIT09IHRpdGxlKSB7XG4gICAgICBpZiAob2xkVGl0bGUpIHtcbiAgICAgICAgdGhpcy5sYWJlbEdyb3VwPy5yZW1vdmVDaGlsZChvbGRUaXRsZS5ub2RlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aXRsZSkge1xuICAgICAgICB0aXRsZS5ub2RlLnRleHRCYXNlbGluZSA9IFwiYm90dG9tXCI7XG4gICAgICAgIHRoaXMubGFiZWxHcm91cD8uYXBwZW5kQ2hpbGQodGl0bGUubm9kZSk7XG4gICAgICB9XG4gICAgICB0aGlzLm9sZFRpdGxlID0gdGl0bGU7XG4gICAgfVxuICB9XG4gIHVwZGF0ZU5vZGVNaWRQb2ludCgpIHtcbiAgICBjb25zdCBzZXRNaWRQb2ludCA9IChkKSA9PiB7XG4gICAgICBjb25zdCByYWRpdXMgPSBkLmlubmVyUmFkaXVzICsgKGQub3V0ZXJSYWRpdXMgLSBkLmlubmVyUmFkaXVzKSAvIDI7XG4gICAgICBkLm1pZFBvaW50ID0ge1xuICAgICAgICB4OiBkLm1pZENvcyAqIE1hdGgubWF4KDAsIHJhZGl1cyksXG4gICAgICAgIHk6IGQubWlkU2luICogTWF0aC5tYXgoMCwgcmFkaXVzKVxuICAgICAgfTtcbiAgICB9O1xuICAgIHRoaXMubm9kZURhdGEuZm9yRWFjaChzZXRNaWRQb2ludCk7XG4gICAgdGhpcy5waGFudG9tTm9kZURhdGE/LmZvckVhY2goc2V0TWlkUG9pbnQpO1xuICB9XG4gIGFzeW5jIHVwZGF0ZVNlbGVjdGlvbnMoKSB7XG4gICAgYXdhaXQgdGhpcy51cGRhdGVHcm91cFNlbGVjdGlvbigpO1xuICB9XG4gIGFzeW5jIHVwZGF0ZUdyb3VwU2VsZWN0aW9uKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGl0ZW1TZWxlY3Rpb24sXG4gICAgICBoaWdobGlnaHRTZWxlY3Rpb24sXG4gICAgICBwaGFudG9tU2VsZWN0aW9uLFxuICAgICAgaGlnaGxpZ2h0TGFiZWxTZWxlY3Rpb24sXG4gICAgICBjYWxsb3V0TGFiZWxTZWxlY3Rpb24sXG4gICAgICBsYWJlbFNlbGVjdGlvblxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGhpZ2hsaWdodGVkTm9kZURhdGEgPSB0aGlzLm5vZGVEYXRhLm1hcCgoZGF0dW0pID0+ICh7XG4gICAgICAuLi5kYXR1bSxcbiAgICAgIC8vIEFsbG93IG11dGFibGUgc2VjdG9yRm9ybWF0LCBzbyBmb3JtYXR0ZWQgc2VjdG9yIHN0eWxlcyBjYW4gYmUgdXBkYXRlZCBhbmQgdmFyaWVkXG4gICAgICAvLyBiZXR3ZWVuIG5vcm1hbCBhbmQgaGlnaGxpZ2h0ZWQgY2FzZXMuXG4gICAgICBzZWN0b3JGb3JtYXQ6IHsgLi4uZGF0dW0uc2VjdG9yRm9ybWF0IH1cbiAgICB9KSk7XG4gICAgY29uc3QgdXBkYXRlID0gKHNlbGVjdGlvbiwgbm9kZURhdGEpID0+IHtcbiAgICAgIHNlbGVjdGlvbi51cGRhdGUobm9kZURhdGEsIHZvaWQgMCwgKGRhdHVtKSA9PiB0aGlzLmdldERhdHVtSWQoZGF0dW0pKTtcbiAgICAgIGlmICh0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLmlzU2tpcHBlZCgpKSB7XG4gICAgICAgIHNlbGVjdGlvbi5jbGVhbnVwKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB1cGRhdGUoaXRlbVNlbGVjdGlvbiwgdGhpcy5ub2RlRGF0YSk7XG4gICAgdXBkYXRlKGhpZ2hsaWdodFNlbGVjdGlvbiwgaGlnaGxpZ2h0ZWROb2RlRGF0YSk7XG4gICAgdXBkYXRlKHBoYW50b21TZWxlY3Rpb24sIHRoaXMucGhhbnRvbU5vZGVEYXRhID8/IFtdKTtcbiAgICBjYWxsb3V0TGFiZWxTZWxlY3Rpb24udXBkYXRlKHRoaXMuY2FsbG91dE5vZGVEYXRhLCAoZ3JvdXApID0+IHtcbiAgICAgIGNvbnN0IGxpbmUgPSBuZXcgTGluZSgpO1xuICAgICAgbGluZS50YWcgPSAwIC8qIENhbGxvdXQgKi87XG4gICAgICBsaW5lLnBvaW50ZXJFdmVudHMgPSAxIC8qIE5vbmUgKi87XG4gICAgICBncm91cC5hcHBlbmRDaGlsZChsaW5lKTtcbiAgICAgIGNvbnN0IHRleHQgPSBuZXcgVGV4dCgpO1xuICAgICAgdGV4dC50YWcgPSAxIC8qIExhYmVsICovO1xuICAgICAgdGV4dC5wb2ludGVyRXZlbnRzID0gMSAvKiBOb25lICovO1xuICAgICAgZ3JvdXAuYXBwZW5kQ2hpbGQodGV4dCk7XG4gICAgfSk7XG4gICAgbGFiZWxTZWxlY3Rpb24udXBkYXRlKHRoaXMubm9kZURhdGEpO1xuICAgIGhpZ2hsaWdodExhYmVsU2VsZWN0aW9uLnVwZGF0ZShoaWdobGlnaHRlZE5vZGVEYXRhKTtcbiAgfVxuICBhc3luYyB1cGRhdGVOb2RlcyhzZXJpZXNSZWN0KSB7XG4gICAgY29uc3QgaGlnaGxpZ2h0ZWREYXR1bSA9IHRoaXMuY3R4LmhpZ2hsaWdodE1hbmFnZXIuZ2V0QWN0aXZlSGlnaGxpZ2h0KCk7XG4gICAgY29uc3QgaXNWaXNpYmxlID0gdGhpcy52aXNpYmxlICYmIHRoaXMuc2VyaWVzSXRlbUVuYWJsZWQuaW5jbHVkZXModHJ1ZSk7XG4gICAgdGhpcy5yb290R3JvdXAudmlzaWJsZSA9IGlzVmlzaWJsZTtcbiAgICB0aGlzLmJhY2tncm91bmRHcm91cC52aXNpYmxlID0gaXNWaXNpYmxlO1xuICAgIHRoaXMuY29udGVudEdyb3VwLnZpc2libGUgPSBpc1Zpc2libGU7XG4gICAgdGhpcy5oaWdobGlnaHRHcm91cC52aXNpYmxlID0gaXNWaXNpYmxlICYmIGhpZ2hsaWdodGVkRGF0dW0/LnNlcmllcyA9PT0gdGhpcztcbiAgICB0aGlzLmhpZ2hsaWdodExhYmVsLnZpc2libGUgPSBpc1Zpc2libGUgJiYgaGlnaGxpZ2h0ZWREYXR1bT8uc2VyaWVzID09PSB0aGlzO1xuICAgIGlmICh0aGlzLmxhYmVsR3JvdXApIHtcbiAgICAgIHRoaXMubGFiZWxHcm91cC52aXNpYmxlID0gaXNWaXNpYmxlO1xuICAgIH1cbiAgICB0aGlzLmNvbnRlbnRHcm91cC5vcGFjaXR5ID0gdGhpcy5nZXRPcGFjaXR5KCk7XG4gICAgY29uc3QgYW5pbWF0aW9uRGlzYWJsZWQgPSB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLmlzU2tpcHBlZCgpO1xuICAgIGNvbnN0IHVwZGF0ZVNlY3RvckZuID0gKHNlY3RvciwgZGF0dW0sIF9pbmRleCwgaXNEYXR1bUhpZ2hsaWdodGVkKSA9PiB7XG4gICAgICBjb25zdCBmb3JtYXQgPSB0aGlzLmdldFNlY3RvckZvcm1hdChkYXR1bS5kYXR1bSwgZGF0dW0uaXRlbUlkLCBpc0RhdHVtSGlnaGxpZ2h0ZWQpO1xuICAgICAgZGF0dW0uc2VjdG9yRm9ybWF0LmZpbGwgPSBmb3JtYXQuZmlsbDtcbiAgICAgIGRhdHVtLnNlY3RvckZvcm1hdC5zdHJva2UgPSBmb3JtYXQuc3Ryb2tlO1xuICAgICAgaWYgKGFuaW1hdGlvbkRpc2FibGVkKSB7XG4gICAgICAgIHNlY3Rvci5zdGFydEFuZ2xlID0gZGF0dW0uc3RhcnRBbmdsZTtcbiAgICAgICAgc2VjdG9yLmVuZEFuZ2xlID0gZGF0dW0uZW5kQW5nbGU7XG4gICAgICAgIHNlY3Rvci5pbm5lclJhZGl1cyA9IGRhdHVtLmlubmVyUmFkaXVzO1xuICAgICAgICBzZWN0b3Iub3V0ZXJSYWRpdXMgPSBkYXR1bS5vdXRlclJhZGl1cztcbiAgICAgIH1cbiAgICAgIGlmIChpc0RhdHVtSGlnaGxpZ2h0ZWQgfHwgYW5pbWF0aW9uRGlzYWJsZWQpIHtcbiAgICAgICAgc2VjdG9yLmZpbGwgPSBmb3JtYXQuZmlsbDtcbiAgICAgICAgc2VjdG9yLnN0cm9rZSA9IGZvcm1hdC5zdHJva2U7XG4gICAgICB9XG4gICAgICBzZWN0b3Iuc3Ryb2tlV2lkdGggPSBmb3JtYXQuc3Ryb2tlV2lkdGg7XG4gICAgICBzZWN0b3IuZmlsbE9wYWNpdHkgPSBmb3JtYXQuZmlsbE9wYWNpdHk7XG4gICAgICBzZWN0b3Iuc3Ryb2tlT3BhY2l0eSA9IGZvcm1hdC5zdHJva2VPcGFjaXR5O1xuICAgICAgc2VjdG9yLmxpbmVEYXNoID0gZm9ybWF0LmxpbmVEYXNoO1xuICAgICAgc2VjdG9yLmxpbmVEYXNoT2Zmc2V0ID0gZm9ybWF0LmxpbmVEYXNoT2Zmc2V0O1xuICAgICAgc2VjdG9yLmNvcm5lclJhZGl1cyA9IGZvcm1hdC5jb3JuZXJSYWRpdXM7XG4gICAgICBzZWN0b3IuZmlsbFNoYWRvdyA9IHRoaXMucHJvcGVydGllcy5zaGFkb3c7XG4gICAgICBjb25zdCBpbnNldCA9IE1hdGgubWF4KFxuICAgICAgICAodGhpcy5wcm9wZXJ0aWVzLnNlY3RvclNwYWNpbmcgKyAoZm9ybWF0LnN0cm9rZSAhPSBudWxsID8gZm9ybWF0LnN0cm9rZVdpZHRoIDogMCkpIC8gMixcbiAgICAgICAgMFxuICAgICAgKTtcbiAgICAgIHNlY3Rvci5pbnNldCA9IGluc2V0O1xuICAgICAgc2VjdG9yLmxpbmVKb2luID0gdGhpcy5wcm9wZXJ0aWVzLnNlY3RvclNwYWNpbmcgPj0gMCB8fCBpbnNldCA+IDAgPyBcIm1pdGVyXCIgOiBcInJvdW5kXCI7XG4gICAgfTtcbiAgICB0aGlzLml0ZW1TZWxlY3Rpb24uZWFjaCgobm9kZSwgZGF0dW0sIGluZGV4KSA9PiB1cGRhdGVTZWN0b3JGbihub2RlLCBkYXR1bSwgaW5kZXgsIGZhbHNlKSk7XG4gICAgdGhpcy5oaWdobGlnaHRTZWxlY3Rpb24uZWFjaCgobm9kZSwgZGF0dW0sIGluZGV4KSA9PiB7XG4gICAgICB1cGRhdGVTZWN0b3JGbihub2RlLCBkYXR1bSwgaW5kZXgsIHRydWUpO1xuICAgICAgbm9kZS52aXNpYmxlID0gZGF0dW0uaXRlbUlkID09PSBoaWdobGlnaHRlZERhdHVtPy5pdGVtSWQ7XG4gICAgfSk7XG4gICAgdGhpcy5waGFudG9tU2VsZWN0aW9uLmVhY2goKG5vZGUsIGRhdHVtLCBpbmRleCkgPT4gdXBkYXRlU2VjdG9yRm4obm9kZSwgZGF0dW0sIGluZGV4LCBmYWxzZSkpO1xuICAgIHRoaXMudXBkYXRlQ2FsbG91dExpbmVOb2RlcygpO1xuICAgIHRoaXMudXBkYXRlQ2FsbG91dExhYmVsTm9kZXMoc2VyaWVzUmVjdCk7XG4gICAgdGhpcy51cGRhdGVTZWN0b3JMYWJlbE5vZGVzKCk7XG4gICAgdGhpcy51cGRhdGVaZXJvc3VtUmluZ3MoKTtcbiAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJ1cGRhdGVcIik7XG4gIH1cbiAgdXBkYXRlQ2FsbG91dExpbmVOb2RlcygpIHtcbiAgICBjb25zdCB7IGNhbGxvdXRMaW5lIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgY2FsbG91dExlbmd0aCA9IGNhbGxvdXRMaW5lLmxlbmd0aDtcbiAgICBjb25zdCBjYWxsb3V0U3Ryb2tlV2lkdGggPSBjYWxsb3V0TGluZS5zdHJva2VXaWR0aDtcbiAgICBjb25zdCBjYWxsb3V0Q29sb3JzID0gY2FsbG91dExpbmUuY29sb3JzID8/IHRoaXMucHJvcGVydGllcy5zdHJva2VzO1xuICAgIGNvbnN0IHsgb2Zmc2V0OiBvZmZzZXQ0IH0gPSB0aGlzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsO1xuICAgIHRoaXMuY2FsbG91dExhYmVsU2VsZWN0aW9uLnNlbGVjdEJ5VGFnKDAgLyogQ2FsbG91dCAqLykuZm9yRWFjaCgobGluZSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGRhdHVtID0gbGluZS5kYXR1bTtcbiAgICAgIGNvbnN0IHsgY2FsbG91dExhYmVsOiBsYWJlbCwgb3V0ZXJSYWRpdXMgfSA9IGRhdHVtO1xuICAgICAgaWYgKGxhYmVsPy50ZXh0ICYmICFsYWJlbC5oaWRkZW4gJiYgb3V0ZXJSYWRpdXMgIT09IDApIHtcbiAgICAgICAgbGluZS52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgbGluZS5zdHJva2VXaWR0aCA9IGNhbGxvdXRTdHJva2VXaWR0aDtcbiAgICAgICAgbGluZS5zdHJva2UgPSBjYWxsb3V0Q29sb3JzW2luZGV4ICUgY2FsbG91dENvbG9ycy5sZW5ndGhdO1xuICAgICAgICBsaW5lLmZpbGwgPSB2b2lkIDA7XG4gICAgICAgIGNvbnN0IHgxID0gZGF0dW0ubWlkQ29zICogb3V0ZXJSYWRpdXM7XG4gICAgICAgIGNvbnN0IHkxID0gZGF0dW0ubWlkU2luICogb3V0ZXJSYWRpdXM7XG4gICAgICAgIGxldCB4MiA9IGRhdHVtLm1pZENvcyAqIChvdXRlclJhZGl1cyArIGNhbGxvdXRMZW5ndGgpO1xuICAgICAgICBsZXQgeTIgPSBkYXR1bS5taWRTaW4gKiAob3V0ZXJSYWRpdXMgKyBjYWxsb3V0TGVuZ3RoKTtcbiAgICAgICAgY29uc3QgaXNNb3ZlZCA9IGxhYmVsLmNvbGxpc2lvblRleHRBbGlnbiA/PyBsYWJlbC5jb2xsaXNpb25PZmZzZXRZICE9PSAwO1xuICAgICAgICBpZiAoaXNNb3ZlZCAmJiBsYWJlbC5ib3ggIT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IGJveCA9IGxhYmVsLmJveDtcbiAgICAgICAgICBsZXQgY3ggPSB4MjtcbiAgICAgICAgICBsZXQgY3kgPSB5MjtcbiAgICAgICAgICBpZiAoeDIgPCBib3gueCkge1xuICAgICAgICAgICAgY3ggPSBib3gueDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHgyID4gYm94LnggKyBib3gud2lkdGgpIHtcbiAgICAgICAgICAgIGN4ID0gYm94LnggKyBib3gud2lkdGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh5MiA8IGJveC55KSB7XG4gICAgICAgICAgICBjeSA9IGJveC55O1xuICAgICAgICAgIH0gZWxzZSBpZiAoeTIgPiBib3gueSArIGJveC5oZWlnaHQpIHtcbiAgICAgICAgICAgIGN5ID0gYm94LnkgKyBib3guaGVpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBkeCA9IGN4IC0geDI7XG4gICAgICAgICAgY29uc3QgZHkgPSBjeSAtIHkyO1xuICAgICAgICAgIGNvbnN0IGxlbmd0aDIgPSBNYXRoLnNxcnQoTWF0aC5wb3coZHgsIDIpICsgTWF0aC5wb3coZHksIDIpKTtcbiAgICAgICAgICBjb25zdCBwYWRkZWRMZW5ndGggPSBsZW5ndGgyIC0gb2Zmc2V0NDtcbiAgICAgICAgICBpZiAocGFkZGVkTGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgeDIgPSB4MiArIGR4ICogcGFkZGVkTGVuZ3RoIC8gbGVuZ3RoMjtcbiAgICAgICAgICAgIHkyID0geTIgKyBkeSAqIHBhZGRlZExlbmd0aCAvIGxlbmd0aDI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxpbmUueDEgPSB4MTtcbiAgICAgICAgbGluZS55MSA9IHkxO1xuICAgICAgICBsaW5lLngyID0geDI7XG4gICAgICAgIGxpbmUueTIgPSB5MjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpbmUudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGdldExhYmVsT3ZlcmZsb3codGV4dCwgYm94LCBzZXJpZXNSZWN0KSB7XG4gICAgY29uc3Qgc2VyaWVzTGVmdCA9IHNlcmllc1JlY3QueCAtIHRoaXMuY2VudGVyWDtcbiAgICBjb25zdCBzZXJpZXNSaWdodCA9IHNlcmllc1JlY3QueCArIHNlcmllc1JlY3Qud2lkdGggLSB0aGlzLmNlbnRlclg7XG4gICAgY29uc3Qgc2VyaWVzVG9wID0gc2VyaWVzUmVjdC55IC0gdGhpcy5jZW50ZXJZO1xuICAgIGNvbnN0IHNlcmllc0JvdHRvbSA9IHNlcmllc1JlY3QueSArIHNlcmllc1JlY3QuaGVpZ2h0IC0gdGhpcy5jZW50ZXJZO1xuICAgIGNvbnN0IGVyclB4ID0gMTtcbiAgICBsZXQgdmlzaWJsZVRleHRQYXJ0ID0gMTtcbiAgICBpZiAoYm94LnggKyBlcnJQeCA8IHNlcmllc0xlZnQpIHtcbiAgICAgIHZpc2libGVUZXh0UGFydCA9IChib3gueCArIGJveC53aWR0aCAtIHNlcmllc0xlZnQpIC8gYm94LndpZHRoO1xuICAgIH0gZWxzZSBpZiAoYm94LnggKyBib3gud2lkdGggLSBlcnJQeCA+IHNlcmllc1JpZ2h0KSB7XG4gICAgICB2aXNpYmxlVGV4dFBhcnQgPSAoc2VyaWVzUmlnaHQgLSBib3gueCkgLyBib3gud2lkdGg7XG4gICAgfVxuICAgIGNvbnN0IGhhc1ZlcnRpY2FsT3ZlcmZsb3cgPSBib3gueSArIGVyclB4IDwgc2VyaWVzVG9wIHx8IGJveC55ICsgYm94LmhlaWdodCAtIGVyclB4ID4gc2VyaWVzQm90dG9tO1xuICAgIGNvbnN0IHRleHRMZW5ndGggPSB2aXNpYmxlVGV4dFBhcnQgPT09IDEgPyB0ZXh0Lmxlbmd0aCA6IE1hdGguZmxvb3IodGV4dC5sZW5ndGggKiB2aXNpYmxlVGV4dFBhcnQpIC0gMTtcbiAgICBjb25zdCBoYXNTdXJyb3VuZGluZ1Nlcmllc092ZXJmbG93ID0gdGhpcy5iYm94SW50ZXJzZWN0c1N1cnJvdW5kaW5nU2VyaWVzKGJveCk7XG4gICAgcmV0dXJuIHsgdGV4dExlbmd0aCwgaGFzVmVydGljYWxPdmVyZmxvdywgaGFzU3Vycm91bmRpbmdTZXJpZXNPdmVyZmxvdyB9O1xuICB9XG4gIGJib3hJbnRlcnNlY3RzU3Vycm91bmRpbmdTZXJpZXMoYm94KSB7XG4gICAgY29uc3QgeyBzdXJyb3VuZGluZ1JhZGl1cyB9ID0gdGhpcztcbiAgICBpZiAoc3Vycm91bmRpbmdSYWRpdXMgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBjb3JuZXJzID0gW1xuICAgICAgeyB4OiBib3gueCwgeTogYm94LnkgfSxcbiAgICAgIHsgeDogYm94LnggKyBib3gud2lkdGgsIHk6IGJveC55IH0sXG4gICAgICB7IHg6IGJveC54ICsgYm94LndpZHRoLCB5OiBib3gueSArIGJveC5oZWlnaHQgfSxcbiAgICAgIHsgeDogYm94LngsIHk6IGJveC55ICsgYm94LmhlaWdodCB9XG4gICAgXTtcbiAgICBjb25zdCBzdXIyID0gc3Vycm91bmRpbmdSYWRpdXMgKiogMjtcbiAgICByZXR1cm4gY29ybmVycy5zb21lKChjb3JuZXIpID0+IGNvcm5lci54ICoqIDIgKyBjb3JuZXIueSAqKiAyID4gc3VyMik7XG4gIH1cbiAgY29tcHV0ZUNhbGxvdXRMYWJlbENvbGxpc2lvbk9mZnNldHMoKSB7XG4gICAgY29uc3QgeyByYWRpdXNTY2FsZSB9ID0gdGhpcztcbiAgICBjb25zdCB7IGNhbGxvdXRMYWJlbCwgY2FsbG91dExpbmUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCB7IG9mZnNldDogb2Zmc2V0NCwgbWluU3BhY2luZyB9ID0gY2FsbG91dExhYmVsO1xuICAgIGNvbnN0IGlubmVyUmFkaXVzID0gcmFkaXVzU2NhbGUuY29udmVydCgwKTtcbiAgICBjb25zdCBzaG91bGRTa2lwID0gKGRhdHVtKSA9PiB7XG4gICAgICBjb25zdCBsYWJlbCA9IGRhdHVtLmNhbGxvdXRMYWJlbDtcbiAgICAgIHJldHVybiAhbGFiZWwgfHwgZGF0dW0ub3V0ZXJSYWRpdXMgPT09IDA7XG4gICAgfTtcbiAgICBjb25zdCBmdWxsRGF0YSA9IHRoaXMuY2FsbG91dE5vZGVEYXRhO1xuICAgIGNvbnN0IGRhdGEgPSBmdWxsRGF0YS5maWx0ZXIoKHQpID0+ICFzaG91bGRTa2lwKHQpKTtcbiAgICBkYXRhLmZvckVhY2goKGRhdHVtKSA9PiB7XG4gICAgICBjb25zdCBsYWJlbCA9IGRhdHVtLmNhbGxvdXRMYWJlbDtcbiAgICAgIGlmIChsYWJlbCA9PSBudWxsKVxuICAgICAgICByZXR1cm47XG4gICAgICBsYWJlbC5oaWRkZW4gPSBmYWxzZTtcbiAgICAgIGxhYmVsLmNvbGxpc2lvblRleHRBbGlnbiA9IHZvaWQgMDtcbiAgICAgIGxhYmVsLmNvbGxpc2lvbk9mZnNldFkgPSAwO1xuICAgIH0pO1xuICAgIGlmIChkYXRhLmxlbmd0aCA8PSAxKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxlZnRMYWJlbHMgPSBkYXRhLmZpbHRlcigoZCkgPT4gZC5taWRDb3MgPCAwKS5zb3J0KChhLCBiKSA9PiBhLm1pZFNpbiAtIGIubWlkU2luKTtcbiAgICBjb25zdCByaWdodExhYmVscyA9IGRhdGEuZmlsdGVyKChkKSA9PiBkLm1pZENvcyA+PSAwKS5zb3J0KChhLCBiKSA9PiBhLm1pZFNpbiAtIGIubWlkU2luKTtcbiAgICBjb25zdCB0b3BMYWJlbHMgPSBkYXRhLmZpbHRlcigoZCkgPT4gZC5taWRTaW4gPCAwICYmIGQuY2FsbG91dExhYmVsPy50ZXh0QWxpZ24gPT09IFwiY2VudGVyXCIpLnNvcnQoKGEsIGIpID0+IGEubWlkQ29zIC0gYi5taWRDb3MpO1xuICAgIGNvbnN0IGJvdHRvbUxhYmVscyA9IGRhdGEuZmlsdGVyKChkKSA9PiBkLm1pZFNpbiA+PSAwICYmIGQuY2FsbG91dExhYmVsPy50ZXh0QWxpZ24gPT09IFwiY2VudGVyXCIpLnNvcnQoKGEsIGIpID0+IGEubWlkQ29zIC0gYi5taWRDb3MpO1xuICAgIGNvbnN0IGdldFRleHRCQm94ID0gKGRhdHVtKSA9PiB7XG4gICAgICBjb25zdCBsYWJlbCA9IGRhdHVtLmNhbGxvdXRMYWJlbDtcbiAgICAgIGlmIChsYWJlbCA9PSBudWxsKVxuICAgICAgICByZXR1cm4gQkJveC56ZXJvLmNsb25lKCk7XG4gICAgICBjb25zdCBsYWJlbFJhZGl1cyA9IGRhdHVtLm91dGVyUmFkaXVzICsgY2FsbG91dExpbmUubGVuZ3RoICsgb2Zmc2V0NDtcbiAgICAgIGNvbnN0IHggPSBkYXR1bS5taWRDb3MgKiBsYWJlbFJhZGl1cztcbiAgICAgIGNvbnN0IHkgPSBkYXR1bS5taWRTaW4gKiBsYWJlbFJhZGl1cyArIGxhYmVsLmNvbGxpc2lvbk9mZnNldFk7XG4gICAgICBjb25zdCB0ZXh0QWxpZ24gPSBsYWJlbC5jb2xsaXNpb25UZXh0QWxpZ24gPz8gbGFiZWwudGV4dEFsaWduO1xuICAgICAgY29uc3QgdGV4dEJhc2VsaW5lID0gbGFiZWwudGV4dEJhc2VsaW5lO1xuICAgICAgcmV0dXJuIFRleHQuY29tcHV0ZUJCb3gobGFiZWwudGV4dCwgeCwgeSwge1xuICAgICAgICBmb250OiB0aGlzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsLFxuICAgICAgICB0ZXh0QWxpZ24sXG4gICAgICAgIHRleHRCYXNlbGluZVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBhdm9pZE5laWdoYm91cllDb2xsaXNpb24gPSAobGFiZWwsIG5leHQsIGRpcmVjdGlvbikgPT4ge1xuICAgICAgY29uc3QgYm94ID0gZ2V0VGV4dEJCb3gobGFiZWwpLmdyb3cobWluU3BhY2luZyAvIDIpO1xuICAgICAgY29uc3Qgb3RoZXIgPSBnZXRUZXh0QkJveChuZXh0KS5ncm93KG1pblNwYWNpbmcgLyAyKTtcbiAgICAgIGNvbnN0IGNvbGxpZGVzT3JCZWhpbmQgPSBib3gueCA8IG90aGVyLnggKyBvdGhlci53aWR0aCAmJiBib3gueCArIGJveC53aWR0aCA+IG90aGVyLnggJiYgKGRpcmVjdGlvbiA9PT0gXCJ0by10b3BcIiA/IGJveC55IDwgb3RoZXIueSArIG90aGVyLmhlaWdodCA6IGJveC55ICsgYm94LmhlaWdodCA+IG90aGVyLnkpO1xuICAgICAgaWYgKGNvbGxpZGVzT3JCZWhpbmQpIHtcbiAgICAgICAgY29uc3QgZHkgPSBkaXJlY3Rpb24gPT09IFwidG8tdG9wXCIgPyBib3gueSAtIG90aGVyLnkgLSBvdGhlci5oZWlnaHQgOiBib3gueSArIGJveC5oZWlnaHQgLSBvdGhlci55O1xuICAgICAgICBuZXh0LmNhbGxvdXRMYWJlbC5jb2xsaXNpb25PZmZzZXRZID0gZHk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBhdm9pZFlDb2xsaXNpb25zID0gKGxhYmVscykgPT4ge1xuICAgICAgY29uc3QgbWlkTGFiZWwgPSBsYWJlbHMuc2xpY2UoKS5zb3J0KChhLCBiKSA9PiBNYXRoLmFicyhhLm1pZFNpbikgLSBNYXRoLmFicyhiLm1pZFNpbikpWzBdO1xuICAgICAgY29uc3QgbWlkSW5kZXggPSBsYWJlbHMuaW5kZXhPZihtaWRMYWJlbCk7XG4gICAgICBmb3IgKGxldCBpID0gbWlkSW5kZXggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBwcmV2ID0gbGFiZWxzW2kgKyAxXTtcbiAgICAgICAgY29uc3QgbmV4dCA9IGxhYmVsc1tpXTtcbiAgICAgICAgYXZvaWROZWlnaGJvdXJZQ29sbGlzaW9uKHByZXYsIG5leHQsIFwidG8tdG9wXCIpO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IG1pZEluZGV4ICsgMTsgaSA8IGxhYmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwcmV2ID0gbGFiZWxzW2kgLSAxXTtcbiAgICAgICAgY29uc3QgbmV4dCA9IGxhYmVsc1tpXTtcbiAgICAgICAgYXZvaWROZWlnaGJvdXJZQ29sbGlzaW9uKHByZXYsIG5leHQsIFwidG8tYm90dG9tXCIpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgYXZvaWRYQ29sbGlzaW9ucyA9IChsYWJlbHMpID0+IHtcbiAgICAgIGNvbnN0IGxhYmVsc0NvbGxpZGVMYWJlbHNCeVkgPSBkYXRhLnNvbWUoKGRhdHVtKSA9PiBkYXR1bS5jYWxsb3V0TGFiZWwuY29sbGlzaW9uT2Zmc2V0WSAhPT0gMCk7XG4gICAgICBjb25zdCBib3hlcyA9IGxhYmVscy5tYXAoKGxhYmVsKSA9PiBnZXRUZXh0QkJveChsYWJlbCkpO1xuICAgICAgY29uc3QgcGFkZGVkQm94ZXMgPSBib3hlcy5tYXAoKGJveCkgPT4gYm94LmNsb25lKCkuZ3JvdyhtaW5TcGFjaW5nIC8gMikpO1xuICAgICAgbGV0IGxhYmVsc0NvbGxpZGVMYWJlbHNCeVggPSBmYWxzZTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkZGVkQm94ZXMubGVuZ3RoICYmICFsYWJlbHNDb2xsaWRlTGFiZWxzQnlYOyBpKyspIHtcbiAgICAgICAgY29uc3QgYm94ID0gcGFkZGVkQm94ZXNbaV07XG4gICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IGxhYmVscy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNvbnN0IG90aGVyID0gcGFkZGVkQm94ZXNbal07XG4gICAgICAgICAgaWYgKGJveC5jb2xsaWRlc0JCb3gob3RoZXIpKSB7XG4gICAgICAgICAgICBsYWJlbHNDb2xsaWRlTGFiZWxzQnlYID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qgc2VjdG9ycyA9IGZ1bGxEYXRhLm1hcCgoZGF0dW0pID0+IHtcbiAgICAgICAgY29uc3QgeyBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgb3V0ZXJSYWRpdXMgfSA9IGRhdHVtO1xuICAgICAgICByZXR1cm4geyBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzIH07XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGxhYmVsc0NvbGxpZGVTZWN0b3JzID0gYm94ZXMuc29tZSgoYm94KSA9PiB7XG4gICAgICAgIHJldHVybiBzZWN0b3JzLnNvbWUoKHNlY3RvcikgPT4gYm94Q29sbGlkZXNTZWN0b3IoYm94LCBzZWN0b3IpKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKCFsYWJlbHNDb2xsaWRlTGFiZWxzQnlYICYmICFsYWJlbHNDb2xsaWRlTGFiZWxzQnlZICYmICFsYWJlbHNDb2xsaWRlU2VjdG9ycykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsYWJlbHMuZmlsdGVyKChkKSA9PiBkLmNhbGxvdXRMYWJlbC50ZXh0QWxpZ24gPT09IFwiY2VudGVyXCIpLmZvckVhY2goKGQpID0+IHtcbiAgICAgICAgY29uc3QgbGFiZWwgPSBkLmNhbGxvdXRMYWJlbDtcbiAgICAgICAgaWYgKGQubWlkQ29zIDwgMCkge1xuICAgICAgICAgIGxhYmVsLmNvbGxpc2lvblRleHRBbGlnbiA9IFwicmlnaHRcIjtcbiAgICAgICAgfSBlbHNlIGlmIChkLm1pZENvcyA+IDApIHtcbiAgICAgICAgICBsYWJlbC5jb2xsaXNpb25UZXh0QWxpZ24gPSBcImxlZnRcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYWJlbC5jb2xsaXNpb25UZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGF2b2lkWUNvbGxpc2lvbnMobGVmdExhYmVscyk7XG4gICAgYXZvaWRZQ29sbGlzaW9ucyhyaWdodExhYmVscyk7XG4gICAgYXZvaWRYQ29sbGlzaW9ucyh0b3BMYWJlbHMpO1xuICAgIGF2b2lkWENvbGxpc2lvbnMoYm90dG9tTGFiZWxzKTtcbiAgfVxuICB1cGRhdGVDYWxsb3V0TGFiZWxOb2RlcyhzZXJpZXNSZWN0KSB7XG4gICAgY29uc3QgeyByYWRpdXNTY2FsZSB9ID0gdGhpcztcbiAgICBjb25zdCB7IGNhbGxvdXRMYWJlbCwgY2FsbG91dExpbmUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCBjYWxsb3V0TGVuZ3RoID0gY2FsbG91dExpbmUubGVuZ3RoO1xuICAgIGNvbnN0IHsgb2Zmc2V0OiBvZmZzZXQ0LCBjb2xvciB9ID0gY2FsbG91dExhYmVsO1xuICAgIGNvbnN0IHRlbXBUZXh0Tm9kZSA9IG5ldyBUZXh0KCk7XG4gICAgdGhpcy5jYWxsb3V0TGFiZWxTZWxlY3Rpb24uc2VsZWN0QnlUYWcoMSAvKiBMYWJlbCAqLykuZm9yRWFjaCgodGV4dCkgPT4ge1xuICAgICAgY29uc3QgeyBkYXR1bSB9ID0gdGV4dDtcbiAgICAgIGNvbnN0IGxhYmVsID0gZGF0dW0uY2FsbG91dExhYmVsO1xuICAgICAgY29uc3QgcmFkaXVzID0gcmFkaXVzU2NhbGUuY29udmVydChkYXR1bS5yYWRpdXMpO1xuICAgICAgY29uc3Qgb3V0ZXJSYWRpdXMgPSBNYXRoLm1heCgwLCByYWRpdXMpO1xuICAgICAgaWYgKCFsYWJlbD8udGV4dCB8fCBvdXRlclJhZGl1cyA9PT0gMCB8fCBsYWJlbC5oaWRkZW4pIHtcbiAgICAgICAgdGV4dC52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxhYmVsUmFkaXVzID0gb3V0ZXJSYWRpdXMgKyBjYWxsb3V0TGVuZ3RoICsgb2Zmc2V0NDtcbiAgICAgIGNvbnN0IHggPSBkYXR1bS5taWRDb3MgKiBsYWJlbFJhZGl1cztcbiAgICAgIGNvbnN0IHkgPSBkYXR1bS5taWRTaW4gKiBsYWJlbFJhZGl1cyArIGxhYmVsLmNvbGxpc2lvbk9mZnNldFk7XG4gICAgICBjb25zdCBhbGlnbiA9IHtcbiAgICAgICAgdGV4dEFsaWduOiBsYWJlbC5jb2xsaXNpb25UZXh0QWxpZ24gPz8gbGFiZWwudGV4dEFsaWduLFxuICAgICAgICB0ZXh0QmFzZWxpbmU6IGxhYmVsLnRleHRCYXNlbGluZVxuICAgICAgfTtcbiAgICAgIHRlbXBUZXh0Tm9kZS50ZXh0ID0gbGFiZWwudGV4dDtcbiAgICAgIHRlbXBUZXh0Tm9kZS54ID0geDtcbiAgICAgIHRlbXBUZXh0Tm9kZS55ID0geTtcbiAgICAgIHRlbXBUZXh0Tm9kZS5zZXRGb250KHRoaXMucHJvcGVydGllcy5jYWxsb3V0TGFiZWwpO1xuICAgICAgdGVtcFRleHROb2RlLnNldEFsaWduKGFsaWduKTtcbiAgICAgIGNvbnN0IGJveCA9IHRlbXBUZXh0Tm9kZS5nZXRCQm94KCk7XG4gICAgICBsZXQgZGlzcGxheVRleHQgPSBsYWJlbC50ZXh0O1xuICAgICAgbGV0IHZpc2libGUgPSB0cnVlO1xuICAgICAgaWYgKGNhbGxvdXRMYWJlbC5hdm9pZENvbGxpc2lvbnMpIHtcbiAgICAgICAgY29uc3QgeyB0ZXh0TGVuZ3RoLCBoYXNWZXJ0aWNhbE92ZXJmbG93IH0gPSB0aGlzLmdldExhYmVsT3ZlcmZsb3cobGFiZWwudGV4dCwgYm94LCBzZXJpZXNSZWN0KTtcbiAgICAgICAgZGlzcGxheVRleHQgPSBsYWJlbC50ZXh0Lmxlbmd0aCA9PT0gdGV4dExlbmd0aCA/IGxhYmVsLnRleHQgOiBgJHtsYWJlbC50ZXh0LnN1YnN0cmluZygwLCB0ZXh0TGVuZ3RoKX1cXHUyMDI2YDtcbiAgICAgICAgdmlzaWJsZSA9ICFoYXNWZXJ0aWNhbE92ZXJmbG93O1xuICAgICAgfVxuICAgICAgdGV4dC50ZXh0ID0gZGlzcGxheVRleHQ7XG4gICAgICB0ZXh0LnggPSB4O1xuICAgICAgdGV4dC55ID0geTtcbiAgICAgIHRleHQuc2V0Rm9udCh0aGlzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsKTtcbiAgICAgIHRleHQuc2V0QWxpZ24oYWxpZ24pO1xuICAgICAgdGV4dC5maWxsID0gY29sb3I7XG4gICAgICB0ZXh0LnZpc2libGUgPSB2aXNpYmxlO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGNvbXB1dGVMYWJlbHNCQm94KG9wdGlvbnMsIHNlcmllc1JlY3QpIHtcbiAgICBjb25zdCB7IGNhbGxvdXRMYWJlbCwgY2FsbG91dExpbmUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCBjYWxsb3V0TGVuZ3RoID0gY2FsbG91dExpbmUubGVuZ3RoO1xuICAgIGNvbnN0IHsgb2Zmc2V0OiBvZmZzZXQ0LCBtYXhDb2xsaXNpb25PZmZzZXQsIG1pblNwYWNpbmcgfSA9IGNhbGxvdXRMYWJlbDtcbiAgICBpZiAoIWNhbGxvdXRMYWJlbC5hdm9pZENvbGxpc2lvbnMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLm1heWJlUmVmcmVzaE5vZGVEYXRhKCk7XG4gICAgdGhpcy51cGRhdGVSYWRpdXNTY2FsZShmYWxzZSk7XG4gICAgdGhpcy5jb21wdXRlQ2FsbG91dExhYmVsQ29sbGlzaW9uT2Zmc2V0cygpO1xuICAgIGNvbnN0IHRleHRCb3hlcyA9IFtdO1xuICAgIGNvbnN0IHRleHQgPSBuZXcgVGV4dCgpO1xuICAgIGxldCB0aXRsZUJveDtcbiAgICBjb25zdCB7IHRpdGxlIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgaWYgKHRpdGxlPy50ZXh0ICYmIHRpdGxlLmVuYWJsZWQpIHtcbiAgICAgIGNvbnN0IGR5ID0gdGhpcy5nZXRUaXRsZVRyYW5zbGF0aW9uWSgpO1xuICAgICAgaWYgKGlzRmluaXRlKGR5KSkge1xuICAgICAgICB0ZXh0LnRleHQgPSB0aXRsZS50ZXh0O1xuICAgICAgICB0ZXh0LnggPSAwO1xuICAgICAgICB0ZXh0LnkgPSBkeTtcbiAgICAgICAgdGV4dC5zZXRGb250KHRpdGxlKTtcbiAgICAgICAgdGV4dC5zZXRBbGlnbih7XG4gICAgICAgICAgdGV4dEJhc2VsaW5lOiBcImJvdHRvbVwiLFxuICAgICAgICAgIHRleHRBbGlnbjogXCJjZW50ZXJcIlxuICAgICAgICB9KTtcbiAgICAgICAgdGl0bGVCb3ggPSB0ZXh0LmdldEJCb3goKTtcbiAgICAgICAgdGV4dEJveGVzLnB1c2godGl0bGVCb3gpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNhbGxvdXROb2RlRGF0YS5mb3JFYWNoKChkYXR1bSkgPT4ge1xuICAgICAgY29uc3QgbGFiZWwgPSBkYXR1bS5jYWxsb3V0TGFiZWw7XG4gICAgICBpZiAoIWxhYmVsIHx8IGRhdHVtLm91dGVyUmFkaXVzID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgbGFiZWxSYWRpdXMgPSBkYXR1bS5vdXRlclJhZGl1cyArIGNhbGxvdXRMZW5ndGggKyBvZmZzZXQ0O1xuICAgICAgY29uc3QgeCA9IGRhdHVtLm1pZENvcyAqIGxhYmVsUmFkaXVzO1xuICAgICAgY29uc3QgeSA9IGRhdHVtLm1pZFNpbiAqIGxhYmVsUmFkaXVzICsgbGFiZWwuY29sbGlzaW9uT2Zmc2V0WTtcbiAgICAgIHRleHQudGV4dCA9IGxhYmVsLnRleHQ7XG4gICAgICB0ZXh0LnggPSB4O1xuICAgICAgdGV4dC55ID0geTtcbiAgICAgIHRleHQuc2V0Rm9udCh0aGlzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsKTtcbiAgICAgIHRleHQuc2V0QWxpZ24oe1xuICAgICAgICB0ZXh0QWxpZ246IGxhYmVsLmNvbGxpc2lvblRleHRBbGlnbiA/PyBsYWJlbC50ZXh0QWxpZ24sXG4gICAgICAgIHRleHRCYXNlbGluZTogbGFiZWwudGV4dEJhc2VsaW5lXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGJveCA9IHRleHQuZ2V0QkJveCgpO1xuICAgICAgbGFiZWwuYm94ID0gYm94O1xuICAgICAgaWYgKE1hdGguYWJzKGxhYmVsLmNvbGxpc2lvbk9mZnNldFkpID4gbWF4Q29sbGlzaW9uT2Zmc2V0KSB7XG4gICAgICAgIGxhYmVsLmhpZGRlbiA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aXRsZUJveCkge1xuICAgICAgICBjb25zdCBzZXJpZXNUb3AgPSBzZXJpZXNSZWN0LnkgLSB0aGlzLmNlbnRlclk7XG4gICAgICAgIGNvbnN0IHRpdGxlQ2xlYW5BcmVhID0gbmV3IEJCb3goXG4gICAgICAgICAgdGl0bGVCb3gueCAtIG1pblNwYWNpbmcsXG4gICAgICAgICAgc2VyaWVzVG9wLFxuICAgICAgICAgIHRpdGxlQm94LndpZHRoICsgMiAqIG1pblNwYWNpbmcsXG4gICAgICAgICAgdGl0bGVCb3gueSArIHRpdGxlQm94LmhlaWdodCArIG1pblNwYWNpbmcgLSBzZXJpZXNUb3BcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGJveC5jb2xsaWRlc0JCb3godGl0bGVDbGVhbkFyZWEpKSB7XG4gICAgICAgICAgbGFiZWwuaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmhpZGVXaGVuTmVjZXNzYXJ5KSB7XG4gICAgICAgIGNvbnN0IHsgdGV4dExlbmd0aCwgaGFzVmVydGljYWxPdmVyZmxvdywgaGFzU3Vycm91bmRpbmdTZXJpZXNPdmVyZmxvdyB9ID0gdGhpcy5nZXRMYWJlbE92ZXJmbG93KFxuICAgICAgICAgIGxhYmVsLnRleHQsXG4gICAgICAgICAgYm94LFxuICAgICAgICAgIHNlcmllc1JlY3RcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgaXNUb29TaG9ydCA9IGxhYmVsLnRleHQubGVuZ3RoID4gMiAmJiB0ZXh0TGVuZ3RoIDwgMjtcbiAgICAgICAgaWYgKGhhc1ZlcnRpY2FsT3ZlcmZsb3cgfHwgaXNUb29TaG9ydCB8fCBoYXNTdXJyb3VuZGluZ1Nlcmllc092ZXJmbG93KSB7XG4gICAgICAgICAgbGFiZWwuaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxhYmVsLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgdGV4dEJveGVzLnB1c2goYm94KTtcbiAgICB9KTtcbiAgICBpZiAodGV4dEJveGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBCQm94Lm1lcmdlKHRleHRCb3hlcyk7XG4gIH1cbiAgdXBkYXRlU2VjdG9yTGFiZWxOb2RlcygpIHtcbiAgICBjb25zdCB7IHJhZGl1c1NjYWxlIH0gPSB0aGlzO1xuICAgIGNvbnN0IGlubmVyUmFkaXVzID0gcmFkaXVzU2NhbGUuY29udmVydCgwKTtcbiAgICBjb25zdCB7IGZvbnRTaXplLCBmb250U3R5bGUsIGZvbnRXZWlnaHQsIGZvbnRGYW1pbHksIHBvc2l0aW9uT2Zmc2V0LCBwb3NpdGlvblJhdGlvLCBjb2xvciB9ID0gdGhpcy5wcm9wZXJ0aWVzLnNlY3RvckxhYmVsO1xuICAgIGNvbnN0IGlzRG9udXQgPSBpbm5lclJhZGl1cyA+IDA7XG4gICAgY29uc3Qgc2luZ2xlVmlzaWJsZVNlY3RvciA9IHRoaXMuc2VyaWVzSXRlbUVuYWJsZWQuZmlsdGVyKEJvb2xlYW4pLmxlbmd0aCA9PT0gMTtcbiAgICBjb25zdCB1cGRhdGVTZWN0b3JMYWJlbCA9ICh0ZXh0LCBkYXR1bSkgPT4ge1xuICAgICAgY29uc3QgeyBzZWN0b3JMYWJlbCwgb3V0ZXJSYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlIH0gPSBkYXR1bTtcbiAgICAgIGxldCBpc1RleHRWaXNpYmxlID0gZmFsc2U7XG4gICAgICBpZiAoc2VjdG9yTGFiZWwgJiYgb3V0ZXJSYWRpdXMgIT09IDApIHtcbiAgICAgICAgY29uc3QgbGFiZWxSYWRpdXMgPSBpbm5lclJhZGl1cyAqICgxIC0gcG9zaXRpb25SYXRpbykgKyBvdXRlclJhZGl1cyAqIHBvc2l0aW9uUmF0aW8gKyBwb3NpdGlvbk9mZnNldDtcbiAgICAgICAgdGV4dC5maWxsID0gY29sb3I7XG4gICAgICAgIHRleHQuZm9udFN0eWxlID0gZm9udFN0eWxlO1xuICAgICAgICB0ZXh0LmZvbnRXZWlnaHQgPSBmb250V2VpZ2h0O1xuICAgICAgICB0ZXh0LmZvbnRTaXplID0gZm9udFNpemU7XG4gICAgICAgIHRleHQuZm9udEZhbWlseSA9IGZvbnRGYW1pbHk7XG4gICAgICAgIHRleHQudGV4dCA9IHNlY3RvckxhYmVsLnRleHQ7XG4gICAgICAgIGNvbnN0IHNob3VsZFB1dFRleHRJbkNlbnRlciA9ICFpc0RvbnV0ICYmIHNpbmdsZVZpc2libGVTZWN0b3I7XG4gICAgICAgIGlmIChzaG91bGRQdXRUZXh0SW5DZW50ZXIpIHtcbiAgICAgICAgICB0ZXh0LnggPSAwO1xuICAgICAgICAgIHRleHQueSA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dC54ID0gZGF0dW0ubWlkQ29zICogbGFiZWxSYWRpdXM7XG4gICAgICAgICAgdGV4dC55ID0gZGF0dW0ubWlkU2luICogbGFiZWxSYWRpdXM7XG4gICAgICAgIH1cbiAgICAgICAgdGV4dC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgICB0ZXh0LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XG4gICAgICAgIGNvbnN0IGJib3ggPSB0ZXh0LmdldEJCb3goKTtcbiAgICAgICAgY29uc3QgY29ybmVycyA9IFtcbiAgICAgICAgICBbYmJveC54LCBiYm94LnldLFxuICAgICAgICAgIFtiYm94LnggKyBiYm94LndpZHRoLCBiYm94LnldLFxuICAgICAgICAgIFtiYm94LnggKyBiYm94LndpZHRoLCBiYm94LnkgKyBiYm94LmhlaWdodF0sXG4gICAgICAgICAgW2Jib3gueCwgYmJveC55ICsgYmJveC5oZWlnaHRdXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IHNlY3RvckJvdW5kcyA9IHsgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cyB9O1xuICAgICAgICBpZiAoY29ybmVycy5ldmVyeSgoW3gsIHldKSA9PiBpc1BvaW50SW5TZWN0b3IoeCwgeSwgc2VjdG9yQm91bmRzKSkpIHtcbiAgICAgICAgICBpc1RleHRWaXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGV4dC52aXNpYmxlID0gaXNUZXh0VmlzaWJsZTtcbiAgICB9O1xuICAgIHRoaXMubGFiZWxTZWxlY3Rpb24uZWFjaCh1cGRhdGVTZWN0b3JMYWJlbCk7XG4gICAgdGhpcy5oaWdobGlnaHRMYWJlbFNlbGVjdGlvbi5lYWNoKHVwZGF0ZVNlY3RvckxhYmVsKTtcbiAgfVxuICB1cGRhdGVaZXJvc3VtUmluZ3MoKSB7XG4gICAgdGhpcy56ZXJvc3VtT3V0ZXJSaW5nLnNpemUgPSB0aGlzLmdldE91dGVyUmFkaXVzKCkgKiAyO1xuICB9XG4gIGdldERhdHVtTGVnZW5kTmFtZShub2RlRGF0dW0pIHtcbiAgICBjb25zdCB7IGFuZ2xlS2V5LCBjYWxsb3V0TGFiZWxLZXksIHNlY3RvckxhYmVsS2V5LCBsZWdlbmRJdGVtS2V5IH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgeyBzZWN0b3JMYWJlbCwgY2FsbG91dExhYmVsLCBsZWdlbmRJdGVtIH0gPSBub2RlRGF0dW07XG4gICAgaWYgKGxlZ2VuZEl0ZW1LZXkgJiYgbGVnZW5kSXRlbSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbGVnZW5kSXRlbS50ZXh0O1xuICAgIH0gZWxzZSBpZiAoY2FsbG91dExhYmVsS2V5ICYmIGNhbGxvdXRMYWJlbEtleSAhPT0gYW5nbGVLZXkgJiYgY2FsbG91dExhYmVsPy50ZXh0ICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBjYWxsb3V0TGFiZWwudGV4dDtcbiAgICB9IGVsc2UgaWYgKHNlY3RvckxhYmVsS2V5ICYmIHNlY3RvckxhYmVsS2V5ICE9PSBhbmdsZUtleSAmJiBzZWN0b3JMYWJlbD8udGV4dCAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gc2VjdG9yTGFiZWwudGV4dDtcbiAgICB9XG4gIH1cbiAgcGlja05vZGVDbG9zZXN0RGF0dW0ocG9pbnQpIHtcbiAgICByZXR1cm4gcGlja0J5TWF0Y2hpbmdBbmdsZSh0aGlzLCBwb2ludCk7XG4gIH1cbiAgZ2V0VG9vbHRpcEh0bWwobm9kZURhdHVtKSB7XG4gICAgaWYgKCF0aGlzLnByb3BlcnRpZXMuaXNWYWxpZCgpKSB7XG4gICAgICByZXR1cm4gRU1QVFlfVE9PTFRJUF9DT05URU5UO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBkYXR1bSxcbiAgICAgIGFuZ2xlVmFsdWUsXG4gICAgICBzZWN0b3JGb3JtYXQ6IHsgZmlsbDogY29sb3IgfSxcbiAgICAgIGl0ZW1JZFxuICAgIH0gPSBub2RlRGF0dW07XG4gICAgY29uc3QgdGl0bGUgPSBzYW5pdGl6ZUh0bWwodGhpcy5wcm9wZXJ0aWVzLnRpdGxlPy50ZXh0KTtcbiAgICBjb25zdCBjb250ZW50ID0gaXNGaW5pdGVOdW1iZXIoYW5nbGVWYWx1ZSkgPyB0b0ZpeGVkKGFuZ2xlVmFsdWUpIDogU3RyaW5nKGFuZ2xlVmFsdWUpO1xuICAgIGNvbnN0IGxhYmVsVGV4dCA9IHRoaXMuZ2V0RGF0dW1MZWdlbmROYW1lKG5vZGVEYXR1bSk7XG4gICAgcmV0dXJuIHRoaXMucHJvcGVydGllcy50b29sdGlwLnRvVG9vbHRpcEh0bWwoXG4gICAgICB7XG4gICAgICAgIHRpdGxlOiB0aXRsZSA/PyBsYWJlbFRleHQsXG4gICAgICAgIGNvbnRlbnQ6IHRpdGxlICYmIGxhYmVsVGV4dCA/IGAke2xhYmVsVGV4dH06ICR7Y29udGVudH1gIDogY29udGVudCxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjb2xvclxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIGl0ZW1JZCxcbiAgICAgICAgdGl0bGUsXG4gICAgICAgIGNvbG9yLFxuICAgICAgICBzZXJpZXNJZDogdGhpcy5pZCxcbiAgICAgICAgYW5nbGVLZXk6IHRoaXMucHJvcGVydGllcy5hbmdsZUtleSxcbiAgICAgICAgYW5nbGVOYW1lOiB0aGlzLnByb3BlcnRpZXMuYW5nbGVOYW1lLFxuICAgICAgICByYWRpdXNLZXk6IHRoaXMucHJvcGVydGllcy5yYWRpdXNLZXksXG4gICAgICAgIHJhZGl1c05hbWU6IHRoaXMucHJvcGVydGllcy5yYWRpdXNOYW1lLFxuICAgICAgICBjYWxsb3V0TGFiZWxLZXk6IHRoaXMucHJvcGVydGllcy5jYWxsb3V0TGFiZWxLZXksXG4gICAgICAgIGNhbGxvdXRMYWJlbE5hbWU6IHRoaXMucHJvcGVydGllcy5jYWxsb3V0TGFiZWxOYW1lLFxuICAgICAgICBzZWN0b3JMYWJlbEtleTogdGhpcy5wcm9wZXJ0aWVzLnNlY3RvckxhYmVsS2V5LFxuICAgICAgICBzZWN0b3JMYWJlbE5hbWU6IHRoaXMucHJvcGVydGllcy5zZWN0b3JMYWJlbE5hbWUsXG4gICAgICAgIGxlZ2VuZEl0ZW1LZXk6IHRoaXMucHJvcGVydGllcy5sZWdlbmRJdGVtS2V5XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBnZXRMZWdlbmREYXRhKGxlZ2VuZFR5cGUpIHtcbiAgICBjb25zdCB7IHZpc2libGUsIHByb2Nlc3NlZERhdGEsIGRhdGFNb2RlbCB9ID0gdGhpcztcbiAgICBpZiAoIWRhdGFNb2RlbCB8fCAhcHJvY2Vzc2VkRGF0YT8uZGF0YS5sZW5ndGggfHwgbGVnZW5kVHlwZSAhPT0gXCJjYXRlZ29yeVwiKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IHsgYW5nbGVLZXksIGNhbGxvdXRMYWJlbEtleSwgc2VjdG9yTGFiZWxLZXksIGxlZ2VuZEl0ZW1LZXkgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBpZiAoIWxlZ2VuZEl0ZW1LZXkgJiYgKCFjYWxsb3V0TGFiZWxLZXkgfHwgY2FsbG91dExhYmVsS2V5ID09PSBhbmdsZUtleSkgJiYgKCFzZWN0b3JMYWJlbEtleSB8fCBzZWN0b3JMYWJlbEtleSA9PT0gYW5nbGVLZXkpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IHsgY2FsbG91dExhYmVsSWR4LCBzZWN0b3JMYWJlbElkeCwgbGVnZW5kSXRlbUlkeCB9ID0gdGhpcy5nZXRQcm9jZXNzZWREYXRhSW5kZXhlcyhkYXRhTW9kZWwpO1xuICAgIGNvbnN0IHRpdGxlVGV4dCA9IHRoaXMucHJvcGVydGllcy50aXRsZT8uc2hvd0luTGVnZW5kICYmIHRoaXMucHJvcGVydGllcy50aXRsZS50ZXh0O1xuICAgIGNvbnN0IGxlZ2VuZERhdGEgPSBbXTtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcHJvY2Vzc2VkRGF0YS5kYXRhLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgY29uc3QgeyBkYXR1bSwgdmFsdWVzIH0gPSBwcm9jZXNzZWREYXRhLmRhdGFbaW5kZXhdO1xuICAgICAgY29uc3QgbGFiZWxQYXJ0cyA9IFtdO1xuICAgICAgaWYgKHRpdGxlVGV4dCkge1xuICAgICAgICBsYWJlbFBhcnRzLnB1c2godGl0bGVUZXh0KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKFxuICAgICAgICBkYXR1bSxcbiAgICAgICAgMiAqIE1hdGguUEksXG4gICAgICAgIDIgKiBNYXRoLlBJLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgY2FsbG91dExhYmVsSWR4ICE9IG51bGwgPyB2YWx1ZXNbY2FsbG91dExhYmVsSWR4XSA6IHZvaWQgMCxcbiAgICAgICAgc2VjdG9yTGFiZWxJZHggIT0gbnVsbCA/IHZhbHVlc1tzZWN0b3JMYWJlbElkeF0gOiB2b2lkIDAsXG4gICAgICAgIGxlZ2VuZEl0ZW1JZHggIT0gbnVsbCA/IHZhbHVlc1tsZWdlbmRJdGVtSWR4XSA6IHZvaWQgMFxuICAgICAgKTtcbiAgICAgIGlmIChsZWdlbmRJdGVtS2V5ICYmIGxhYmVscy5sZWdlbmRJdGVtICE9PSB2b2lkIDApIHtcbiAgICAgICAgbGFiZWxQYXJ0cy5wdXNoKGxhYmVscy5sZWdlbmRJdGVtLnRleHQpO1xuICAgICAgfSBlbHNlIGlmIChjYWxsb3V0TGFiZWxLZXkgJiYgY2FsbG91dExhYmVsS2V5ICE9PSBhbmdsZUtleSAmJiBsYWJlbHMuY2FsbG91dExhYmVsPy50ZXh0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgbGFiZWxQYXJ0cy5wdXNoKGxhYmVscy5jYWxsb3V0TGFiZWw/LnRleHQpO1xuICAgICAgfSBlbHNlIGlmIChzZWN0b3JMYWJlbEtleSAmJiBzZWN0b3JMYWJlbEtleSAhPT0gYW5nbGVLZXkgJiYgbGFiZWxzLnNlY3RvckxhYmVsPy50ZXh0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgbGFiZWxQYXJ0cy5wdXNoKGxhYmVscy5zZWN0b3JMYWJlbD8udGV4dCk7XG4gICAgICB9XG4gICAgICBpZiAobGFiZWxQYXJ0cy5sZW5ndGggPT09IDApXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3Qgc2VjdG9yRm9ybWF0ID0gdGhpcy5nZXRTZWN0b3JGb3JtYXQoZGF0dW0sIGluZGV4LCBmYWxzZSk7XG4gICAgICBsZWdlbmREYXRhLnB1c2goe1xuICAgICAgICBsZWdlbmRUeXBlOiBcImNhdGVnb3J5XCIsXG4gICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICBpdGVtSWQ6IGluZGV4LFxuICAgICAgICBzZXJpZXNJZDogdGhpcy5pZCxcbiAgICAgICAgZW5hYmxlZDogdmlzaWJsZSAmJiB0aGlzLmxlZ2VuZEl0ZW1FbmFibGVkW2luZGV4XSxcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICB0ZXh0OiBsYWJlbFBhcnRzLmpvaW4oXCIgLSBcIilcbiAgICAgICAgfSxcbiAgICAgICAgc3ltYm9sczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1hcmtlcjoge1xuICAgICAgICAgICAgICBmaWxsOiBzZWN0b3JGb3JtYXQuZmlsbCxcbiAgICAgICAgICAgICAgc3Ryb2tlOiBzZWN0b3JGb3JtYXQuc3Ryb2tlLFxuICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogdGhpcy5wcm9wZXJ0aWVzLmZpbGxPcGFjaXR5LFxuICAgICAgICAgICAgICBzdHJva2VPcGFjaXR5OiB0aGlzLnByb3BlcnRpZXMuc3Ryb2tlT3BhY2l0eSxcbiAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IHRoaXMucHJvcGVydGllcy5zdHJva2VXaWR0aFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgbGVnZW5kSXRlbU5hbWU6IGxlZ2VuZEl0ZW1LZXkgIT0gbnVsbCA/IGRhdHVtW2xlZ2VuZEl0ZW1LZXldIDogdm9pZCAwXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGxlZ2VuZERhdGE7XG4gIH1cbiAgb25MZWdlbmRJdGVtQ2xpY2soZXZlbnQpIHtcbiAgICBjb25zdCB7IGVuYWJsZWQsIGl0ZW1JZCwgc2VyaWVzLCBsZWdlbmRJdGVtTmFtZSB9ID0gZXZlbnQ7XG4gICAgaWYgKHNlcmllcy5pZCA9PT0gdGhpcy5pZCkge1xuICAgICAgdGhpcy50b2dnbGVTZXJpZXNJdGVtKGl0ZW1JZCwgZW5hYmxlZCk7XG4gICAgfSBlbHNlIGlmIChsZWdlbmRJdGVtTmFtZSAhPSBudWxsKSB7XG4gICAgICB0aGlzLnRvZ2dsZU90aGVyU2VyaWVzSXRlbXMobGVnZW5kSXRlbU5hbWUsIGVuYWJsZWQpO1xuICAgIH1cbiAgfVxuICB0b2dnbGVTZXJpZXNJdGVtKGl0ZW1JZCwgZW5hYmxlZCkge1xuICAgIHRoaXMuc2VyaWVzSXRlbUVuYWJsZWRbaXRlbUlkXSA9IGVuYWJsZWQ7XG4gICAgdGhpcy5sZWdlbmRJdGVtRW5hYmxlZFtpdGVtSWRdID0gZW5hYmxlZDtcbiAgICBpZiAodGhpcy5ub2RlRGF0YVtpdGVtSWRdKSB7XG4gICAgICB0aGlzLm5vZGVEYXRhW2l0ZW1JZF0uZW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgfVxuICAgIHRoaXMubm9kZURhdGFSZWZyZXNoID0gdHJ1ZTtcbiAgfVxuICAvLyBVc2VkIGZvciBncmlkXG4gIHNldExlZ2VuZFN0YXRlKGVuYWJsZWRJdGVtcykge1xuICAgIHRoaXMubGVnZW5kSXRlbUVuYWJsZWQgPSBlbmFibGVkSXRlbXM7XG4gICAgdGhpcy5jdHgudXBkYXRlU2VydmljZS51cGRhdGUoNCAvKiBTRVJJRVNfVVBEQVRFICovKTtcbiAgfVxuICB0b2dnbGVPdGhlclNlcmllc0l0ZW1zKGxlZ2VuZEl0ZW1OYW1lLCBlbmFibGVkKSB7XG4gICAgaWYgKCF0aGlzLnByb3BlcnRpZXMubGVnZW5kSXRlbUtleSB8fCAhdGhpcy5kYXRhTW9kZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGVnZW5kSXRlbUlkeCA9IHRoaXMuZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGBsZWdlbmRJdGVtVmFsdWVgKTtcbiAgICB0aGlzLnByb2Nlc3NlZERhdGE/LmRhdGEuZm9yRWFjaCgoeyB2YWx1ZXMgfSwgZGF0dW1JdGVtSWQpID0+IHtcbiAgICAgIGlmICh2YWx1ZXNbbGVnZW5kSXRlbUlkeF0gPT09IGxlZ2VuZEl0ZW1OYW1lKSB7XG4gICAgICAgIHRoaXMudG9nZ2xlU2VyaWVzSXRlbShkYXR1bUl0ZW1JZCwgZW5hYmxlZCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYW5pbWF0ZUVtcHR5VXBkYXRlUmVhZHkoX2RhdGEpIHtcbiAgICBjb25zdCB7IGFuaW1hdGlvbk1hbmFnZXIgfSA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGZucyA9IHByZXBhcmVQaWVTZXJpZXNBbmltYXRpb25GdW5jdGlvbnMoXG4gICAgICB0cnVlLFxuICAgICAgdGhpcy5wcm9wZXJ0aWVzLnJvdGF0aW9uLFxuICAgICAgdGhpcy5yYWRpdXNTY2FsZSxcbiAgICAgIHRoaXMucHJldmlvdXNSYWRpdXNTY2FsZVxuICAgICk7XG4gICAgZnJvbVRvTW90aW9uKFxuICAgICAgdGhpcy5pZCxcbiAgICAgIFwibm9kZXNcIixcbiAgICAgIGFuaW1hdGlvbk1hbmFnZXIsXG4gICAgICBbdGhpcy5pdGVtU2VsZWN0aW9uLCB0aGlzLmhpZ2hsaWdodFNlbGVjdGlvbiwgdGhpcy5waGFudG9tU2VsZWN0aW9uXSxcbiAgICAgIGZucy5ub2RlcyxcbiAgICAgIChfLCBkYXR1bSkgPT4gdGhpcy5nZXREYXR1bUlkKGRhdHVtKVxuICAgICk7XG4gICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJjYWxsb3V0XCIsIGFuaW1hdGlvbk1hbmFnZXIsIHRoaXMuY2FsbG91dExhYmVsU2VsZWN0aW9uKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcInNlY3RvclwiLCBhbmltYXRpb25NYW5hZ2VyLCB0aGlzLmxhYmVsU2VsZWN0aW9uKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImhpZ2hsaWdodFwiLCBhbmltYXRpb25NYW5hZ2VyLCB0aGlzLmhpZ2hsaWdodExhYmVsU2VsZWN0aW9uKTtcbiAgICB0aGlzLnByZXZpb3VzUmFkaXVzU2NhbGUucmFuZ2UgPSB0aGlzLnJhZGl1c1NjYWxlLnJhbmdlO1xuICB9XG4gIGFuaW1hdGVXYWl0aW5nVXBkYXRlUmVhZHkoKSB7XG4gICAgY29uc3QgeyBpdGVtU2VsZWN0aW9uLCBoaWdobGlnaHRTZWxlY3Rpb24sIHBoYW50b21TZWxlY3Rpb24sIHByb2Nlc3NlZERhdGEsIHJhZGl1c1NjYWxlLCBwcmV2aW91c1JhZGl1c1NjYWxlIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgYW5pbWF0aW9uTWFuYWdlciB9ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgZGF0YURpZmYgPSBwcm9jZXNzZWREYXRhPy5yZWR1Y2VkPy5kaWZmO1xuICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuc3RvcEJ5QW5pbWF0aW9uR3JvdXBJZCh0aGlzLmlkKTtcbiAgICBjb25zdCBzdXBwb3J0ZWREaWZmID0gKGRhdGFEaWZmPy5tb3ZlZC5zaXplID8/IDApID09PSAwO1xuICAgIGNvbnN0IGhhc0tleXMgPSAocHJvY2Vzc2VkRGF0YT8uZGVmcy5rZXlzLmxlbmd0aCA/PyAwKSA+IDA7XG4gICAgY29uc3QgaGFzVW5pcXVlS2V5cyA9IHByb2Nlc3NlZERhdGE/LnJlZHVjZWQ/LmFuaW1hdGlvblZhbGlkYXRpb24/LnVuaXF1ZUtleXMgPz8gdHJ1ZTtcbiAgICBpZiAoIXN1cHBvcnRlZERpZmYgfHwgIWhhc0tleXMgfHwgIWhhc1VuaXF1ZUtleXMpIHtcbiAgICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuc2tpcEN1cnJlbnRCYXRjaCgpO1xuICAgIH1cbiAgICBjb25zdCBmbnMgPSBwcmVwYXJlUGllU2VyaWVzQW5pbWF0aW9uRnVuY3Rpb25zKFxuICAgICAgZmFsc2UsXG4gICAgICB0aGlzLnByb3BlcnRpZXMucm90YXRpb24sXG4gICAgICByYWRpdXNTY2FsZSxcbiAgICAgIHByZXZpb3VzUmFkaXVzU2NhbGVcbiAgICApO1xuICAgIGZyb21Ub01vdGlvbihcbiAgICAgIHRoaXMuaWQsXG4gICAgICBcIm5vZGVzXCIsXG4gICAgICBhbmltYXRpb25NYW5hZ2VyLFxuICAgICAgW2l0ZW1TZWxlY3Rpb24sIGhpZ2hsaWdodFNlbGVjdGlvbiwgcGhhbnRvbVNlbGVjdGlvbl0sXG4gICAgICBmbnMubm9kZXMsXG4gICAgICAoXywgZGF0dW0pID0+IHRoaXMuZ2V0RGF0dW1JZChkYXR1bSksXG4gICAgICBkYXRhRGlmZlxuICAgICk7XG4gICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJjYWxsb3V0XCIsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIHRoaXMuY2FsbG91dExhYmVsU2VsZWN0aW9uKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcInNlY3RvclwiLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCB0aGlzLmxhYmVsU2VsZWN0aW9uKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImhpZ2hsaWdodFwiLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCB0aGlzLmhpZ2hsaWdodExhYmVsU2VsZWN0aW9uKTtcbiAgICB0aGlzLnByZXZpb3VzUmFkaXVzU2NhbGUucmFuZ2UgPSB0aGlzLnJhZGl1c1NjYWxlLnJhbmdlO1xuICB9XG4gIGFuaW1hdGVDbGVhcmluZ1VwZGF0ZUVtcHR5KCkge1xuICAgIGNvbnN0IHsgaXRlbVNlbGVjdGlvbiwgaGlnaGxpZ2h0U2VsZWN0aW9uLCBwaGFudG9tU2VsZWN0aW9uLCByYWRpdXNTY2FsZSwgcHJldmlvdXNSYWRpdXNTY2FsZSB9ID0gdGhpcztcbiAgICBjb25zdCB7IGFuaW1hdGlvbk1hbmFnZXIgfSA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGZucyA9IHByZXBhcmVQaWVTZXJpZXNBbmltYXRpb25GdW5jdGlvbnMoXG4gICAgICBmYWxzZSxcbiAgICAgIHRoaXMucHJvcGVydGllcy5yb3RhdGlvbixcbiAgICAgIHJhZGl1c1NjYWxlLFxuICAgICAgcHJldmlvdXNSYWRpdXNTY2FsZVxuICAgICk7XG4gICAgZnJvbVRvTW90aW9uKFxuICAgICAgdGhpcy5pZCxcbiAgICAgIFwibm9kZXNcIixcbiAgICAgIGFuaW1hdGlvbk1hbmFnZXIsXG4gICAgICBbaXRlbVNlbGVjdGlvbiwgaGlnaGxpZ2h0U2VsZWN0aW9uLCBwaGFudG9tU2VsZWN0aW9uXSxcbiAgICAgIGZucy5ub2RlcyxcbiAgICAgIChfLCBkYXR1bSkgPT4gdGhpcy5nZXREYXR1bUlkKGRhdHVtKVxuICAgICk7XG4gICAgc2VyaWVzTGFiZWxGYWRlT3V0QW5pbWF0aW9uKHRoaXMsIFwiY2FsbG91dFwiLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCB0aGlzLmNhbGxvdXRMYWJlbFNlbGVjdGlvbik7XG4gICAgc2VyaWVzTGFiZWxGYWRlT3V0QW5pbWF0aW9uKHRoaXMsIFwic2VjdG9yXCIsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIHRoaXMubGFiZWxTZWxlY3Rpb24pO1xuICAgIHNlcmllc0xhYmVsRmFkZU91dEFuaW1hdGlvbih0aGlzLCBcImhpZ2hsaWdodFwiLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCB0aGlzLmhpZ2hsaWdodExhYmVsU2VsZWN0aW9uKTtcbiAgICB0aGlzLnByZXZpb3VzUmFkaXVzU2NhbGUucmFuZ2UgPSB0aGlzLnJhZGl1c1NjYWxlLnJhbmdlO1xuICB9XG4gIGdldERhdHVtSWRGcm9tRGF0YShkYXR1bSkge1xuICAgIGNvbnN0IHsgY2FsbG91dExhYmVsS2V5LCBzZWN0b3JMYWJlbEtleSwgbGVnZW5kSXRlbUtleSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGlmICghdGhpcy5wcm9jZXNzZWREYXRhPy5yZWR1Y2VkPy5hbmltYXRpb25WYWxpZGF0aW9uPy51bmlxdWVLZXlzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChsZWdlbmRJdGVtS2V5KSB7XG4gICAgICByZXR1cm4gZGF0dW1bbGVnZW5kSXRlbUtleV07XG4gICAgfSBlbHNlIGlmIChjYWxsb3V0TGFiZWxLZXkpIHtcbiAgICAgIHJldHVybiBkYXR1bVtjYWxsb3V0TGFiZWxLZXldO1xuICAgIH0gZWxzZSBpZiAoc2VjdG9yTGFiZWxLZXkpIHtcbiAgICAgIHJldHVybiBkYXR1bVtzZWN0b3JMYWJlbEtleV07XG4gICAgfVxuICB9XG4gIGdldERhdHVtSWQoZGF0dW0pIHtcbiAgICBjb25zdCB7IGluZGV4IH0gPSBkYXR1bTtcbiAgICBjb25zdCBkYXR1bUlkID0gdGhpcy5nZXREYXR1bUlkRnJvbURhdGEoZGF0dW0uZGF0dW0pO1xuICAgIHJldHVybiBkYXR1bUlkICE9IG51bGwgPyBTdHJpbmcoZGF0dW1JZCkgOiBgJHtpbmRleH1gO1xuICB9XG4gIG9uRGF0YUNoYW5nZSgpIHtcbiAgICBjb25zdCB7IGRhdGEsIHNlcmllc0l0ZW1FbmFibGVkLCBsZWdlbmRJdGVtRW5hYmxlZCB9ID0gdGhpcztcbiAgICB0aGlzLnNlcmllc0l0ZW1FbmFibGVkID0gZGF0YT8ubWFwKChfLCBpbmRleCkgPT4gc2VyaWVzSXRlbUVuYWJsZWRbaW5kZXhdID8/IHRydWUpID8/IFtdO1xuICAgIHRoaXMubGVnZW5kSXRlbUVuYWJsZWQgPSBkYXRhPy5tYXAoKF8sIGluZGV4KSA9PiBsZWdlbmRJdGVtRW5hYmxlZFtpbmRleF0gPz8gdHJ1ZSkgPz8gW107XG4gIH1cbn07XG5QaWVTZXJpZXMuY2xhc3NOYW1lID0gXCJQaWVTZXJpZXNcIjtcblBpZVNlcmllcy50eXBlID0gXCJwaWVcIjtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL3BvbGFyL3BpZVNlcmllc01vZHVsZS50c1xudmFyIFBpZVNlcmllc01vZHVsZSA9IHtcbiAgdHlwZTogXCJzZXJpZXNcIixcbiAgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLFxuICBwYWNrYWdlVHlwZTogXCJjb21tdW5pdHlcIixcbiAgY2hhcnRUeXBlczogW1wicG9sYXJcIl0sXG4gIGlkZW50aWZpZXI6IFwicGllXCIsXG4gIG1vZHVsZUZhY3Rvcnk6IChjdHgpID0+IG5ldyBQaWVTZXJpZXMoY3R4KSxcbiAgdG9vbHRpcERlZmF1bHRzOiB7IHJhbmdlOiBcImV4YWN0XCIgfSxcbiAgdGhlbWVUZW1wbGF0ZTogcGllVGhlbWUsXG4gIHBhbGV0dGVGYWN0b3J5OiBwaWVQYWxldHRlRmFjdG9yeVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC92ZWN0b3IudHNcbnZhciBWZWMyID0ge1xuICBhZGQsXG4gIGFuZ2xlLFxuICBhcHBseSxcbiAgZXF1YWwsXG4gIGRpc3RhbmNlOiBkaXN0YW5jZTIsXG4gIGRpc3RhbmNlU3F1YXJlZDogZGlzdGFuY2VTcXVhcmVkMixcbiAgZnJvbSxcbiAgZ3JhZGllbnQsXG4gIGludGVyY2VwdCxcbiAgaW50ZXJzZWN0QXRYLFxuICBpbnRlcnNlY3RBdFksXG4gIGxlbmd0aCxcbiAgbGVuZ3RoU3F1YXJlZCxcbiAgbXVsdGlwbHksXG4gIG5vcm1hbGl6ZWQsXG4gIG9yaWdpbixcbiAgcmVxdWlyZWQsXG4gIHJvdGF0ZSxcbiAgcm91bmQ6IHJvdW5kMyxcbiAgc3ViXG59O1xuZnVuY3Rpb24gYWRkKGEsIGIpIHtcbiAgaWYgKHR5cGVvZiBiID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIHsgeDogYS54ICsgYiwgeTogYS55ICsgYiB9O1xuICB9XG4gIHJldHVybiB7IHg6IGEueCArIGIueCwgeTogYS55ICsgYi55IH07XG59XG5mdW5jdGlvbiBzdWIoYSwgYikge1xuICBpZiAodHlwZW9mIGIgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4geyB4OiBhLnggLSBiLCB5OiBhLnkgLSBiIH07XG4gIH1cbiAgcmV0dXJuIHsgeDogYS54IC0gYi54LCB5OiBhLnkgLSBiLnkgfTtcbn1cbmZ1bmN0aW9uIG11bHRpcGx5KGEsIGIpIHtcbiAgaWYgKHR5cGVvZiBiID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIHsgeDogYS54ICogYiwgeTogYS55ICogYiB9O1xuICB9XG4gIHJldHVybiB7IHg6IGEueCAqIGIueCwgeTogYS55ICogYi55IH07XG59XG5mdW5jdGlvbiBsZW5ndGgoYSkge1xuICByZXR1cm4gTWF0aC5zcXJ0KGEueCAqIGEueCArIGEueSAqIGEueSk7XG59XG5mdW5jdGlvbiBsZW5ndGhTcXVhcmVkKGEpIHtcbiAgcmV0dXJuIGEueCAqIGEueCArIGEueSAqIGEueTtcbn1cbmZ1bmN0aW9uIGRpc3RhbmNlMihhLCBiKSB7XG4gIGNvbnN0IGQgPSBzdWIoYSwgYik7XG4gIHJldHVybiBNYXRoLnNxcnQoZC54ICogZC54ICsgZC55ICogZC55KTtcbn1cbmZ1bmN0aW9uIGRpc3RhbmNlU3F1YXJlZDIoYSwgYikge1xuICBjb25zdCBkID0gc3ViKGEsIGIpO1xuICByZXR1cm4gZC54ICogZC54ICsgZC55ICogZC55O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplZChhKSB7XG4gIGNvbnN0IGwgPSBsZW5ndGgoYSk7XG4gIHJldHVybiB7IHg6IGEueCAvIGwsIHk6IGEueSAvIGwgfTtcbn1cbmZ1bmN0aW9uIGFuZ2xlKGEsIGIgPSBvcmlnaW4oKSkge1xuICByZXR1cm4gTWF0aC5hdGFuMihhLnksIGEueCkgLSBNYXRoLmF0YW4yKGIueSwgYi54KTtcbn1cbmZ1bmN0aW9uIHJvdGF0ZShhLCB0aGV0YSwgYiA9IG9yaWdpbigpKSB7XG4gIGNvbnN0IGwgPSBsZW5ndGgoYSk7XG4gIHJldHVybiB7IHg6IGIueCArIGwgKiBNYXRoLmNvcyh0aGV0YSksIHk6IGIueSArIGwgKiBNYXRoLnNpbih0aGV0YSkgfTtcbn1cbmZ1bmN0aW9uIGdyYWRpZW50KGEsIGIsIHJlZmxlY3Rpb24pIHtcbiAgY29uc3QgZHggPSBiLnggLSBhLng7XG4gIGNvbnN0IGR5ID0gcmVmbGVjdGlvbiA9PSBudWxsID8gYi55IC0gYS55IDogcmVmbGVjdGlvbiAtIGIueSAtIChyZWZsZWN0aW9uIC0gYS55KTtcbiAgcmV0dXJuIGR5IC8gZHg7XG59XG5mdW5jdGlvbiBpbnRlcmNlcHQoYSwgZ3JhZGllbnQyLCByZWZsZWN0aW9uKSB7XG4gIGNvbnN0IHkgPSByZWZsZWN0aW9uID09IG51bGwgPyBhLnkgOiByZWZsZWN0aW9uIC0gYS55O1xuICByZXR1cm4geSAtIGdyYWRpZW50MiAqIGEueDtcbn1cbmZ1bmN0aW9uIGludGVyc2VjdEF0WShncmFkaWVudDIsIGNvZWZmaWNpZW50LCB5ID0gMCwgcmVmbGVjdGlvbikge1xuICByZXR1cm4ge1xuICAgIHg6IGdyYWRpZW50MiA9PT0gSW5maW5pdHkgPyBJbmZpbml0eSA6ICh5IC0gY29lZmZpY2llbnQpIC8gZ3JhZGllbnQyLFxuICAgIHk6IHJlZmxlY3Rpb24gPT0gbnVsbCA/IHkgOiByZWZsZWN0aW9uIC0geVxuICB9O1xufVxuZnVuY3Rpb24gaW50ZXJzZWN0QXRYKGdyYWRpZW50MiwgY29lZmZpY2llbnQsIHggPSAwLCByZWZsZWN0aW9uKSB7XG4gIGNvbnN0IHkgPSBncmFkaWVudDIgPT09IEluZmluaXR5ID8gSW5maW5pdHkgOiBncmFkaWVudDIgKiB4ICsgY29lZmZpY2llbnQ7XG4gIHJldHVybiB7IHgsIHk6IHJlZmxlY3Rpb24gPT0gbnVsbCA/IHkgOiByZWZsZWN0aW9uIC0geSB9O1xufVxuZnVuY3Rpb24gcm91bmQzKGEpIHtcbiAgcmV0dXJuIHsgeDogTWF0aC5yb3VuZChhLngpLCB5OiBNYXRoLnJvdW5kKGEueSkgfTtcbn1cbmZ1bmN0aW9uIGVxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIGEueCA9PT0gYi54ICYmIGEueSA9PT0gYi55O1xufVxuZnVuY3Rpb24gZnJvbShhLCBiKSB7XG4gIGlmICh0eXBlb2YgYSA9PT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiB7IHg6IGEsIHk6IGIgfTtcbiAgfVxuICBpZiAoXCJyZWdpb25PZmZzZXRYXCIgaW4gYSkge1xuICAgIHJldHVybiB7IHg6IGEucmVnaW9uT2Zmc2V0WCwgeTogYS5yZWdpb25PZmZzZXRZIH07XG4gIH1cbiAgaWYgKFwib2Zmc2V0V2lkdGhcIiBpbiBhKSB7XG4gICAgcmV0dXJuIHsgeDogYS5vZmZzZXRXaWR0aCwgeTogYS5vZmZzZXRIZWlnaHQgfTtcbiAgfVxuICBpZiAoXCJ3aWR0aFwiIGluIGEpIHtcbiAgICByZXR1cm4gW1xuICAgICAgeyB4OiBhLngsIHk6IGEueSB9LFxuICAgICAgeyB4OiBhLnggKyBhLndpZHRoLCB5OiBhLnkgKyBhLmhlaWdodCB9XG4gICAgXTtcbiAgfVxuICBpZiAoXCJ4MVwiIGluIGEpIHtcbiAgICByZXR1cm4gW1xuICAgICAgeyB4OiBhLngxLCB5OiBhLnkxIH0sXG4gICAgICB7IHg6IGEueDIsIHk6IGEueTIgfVxuICAgIF07XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBWYWx1ZXMgY2FuIG5vdCBiZSBjb252ZXJ0ZWQgaW50byBhIHZlY3RvcjogWyR7YX1dIFske2J9XWApO1xufVxuZnVuY3Rpb24gYXBwbHkoYSwgYikge1xuICBhLnggPSBiLng7XG4gIGEueSA9IGIueTtcbiAgcmV0dXJuIGE7XG59XG5mdW5jdGlvbiByZXF1aXJlZChhKSB7XG4gIHJldHVybiB7IHg6IGE/LnggPz8gMCwgeTogYT8ueSA/PyAwIH07XG59XG5mdW5jdGlvbiBvcmlnaW4oKSB7XG4gIHJldHVybiB7IHg6IDAsIHk6IDAgfTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvdG9vbGJhci90b29sYmFyUHJvcGVydGllcy50c1xudmFyIFRvb2xiYXJHcm91cFByb3BlcnRpZXMgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3Iob25DaGFuZ2UsIG9uQnV0dG9uc0NoYW5nZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vbkNoYW5nZSA9IG9uQ2hhbmdlO1xuICAgIHRoaXMub25CdXR0b25zQ2hhbmdlID0gb25CdXR0b25zQ2hhbmdlO1xuICAgIHRoaXMuYWxpZ24gPSBcInN0YXJ0XCI7XG4gICAgdGhpcy5wb3NpdGlvbiA9IFwidG9wXCIgLyogVG9wICovO1xuICAgIHRoaXMuc2l6ZSA9IFwibm9ybWFsXCI7XG4gICAgdGhpcy5idXR0b25PdmVycmlkZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIGJ1dHRvbkNvbmZpZ3VyYXRpb25zKCkge1xuICAgIGNvbnN0IGJ1dHRvbnMgPSBbLi4udGhpcy5idXR0b25zID8/IFtdXTtcbiAgICBpZiAodGhpcy5kcmFnZ2FibGUpIHtcbiAgICAgIGJ1dHRvbnMudW5zaGlmdCh7XG4gICAgICAgIGljb246IFwiZHJhZy1oYW5kbGVcIixcbiAgICAgICAgdG9vbHRpcDogXCJ0b29sYmFyQW5ub3RhdGlvbnNEcmFnSGFuZGxlXCIsXG4gICAgICAgIHZhbHVlOiBcImRyYWdcIixcbiAgICAgICAgaWQ6IFwiZHJhZ1wiXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1dHRvbnM/Lm1hcCgoYnV0dG9uKSA9PiB7XG4gICAgICBjb25zdCBpZCA9IGJ1dHRvbi5pZCA/PyBidXR0b24udmFsdWU7XG4gICAgICBjb25zdCBvdmVycmlkZXMgPSB0aGlzLmJ1dHRvbk92ZXJyaWRlcy5nZXQoaWQpO1xuICAgICAgcmV0dXJuIG92ZXJyaWRlcyAhPSBudWxsID8geyAuLi5idXR0b24sIC4uLm92ZXJyaWRlcyB9IDogYnV0dG9uO1xuICAgIH0pID8/IFtdO1xuICB9XG4gIGJ1dHRvbnNDaGFuZ2VkKGNvbmZpZ3VyYXRpb25Pbmx5KSB7XG4gICAgdGhpcy5vbkJ1dHRvbnNDaGFuZ2UodGhpcy5idXR0b25Db25maWd1cmF0aW9ucygpLCBjb25maWd1cmF0aW9uT25seSk7XG4gIH1cbiAgb3ZlcnJpZGVCdXR0b25Db25maWd1cmF0aW9uKGlkLCBvcHRpb25zKSB7XG4gICAgbGV0IG92ZXJyaWRlcyA9IHRoaXMuYnV0dG9uT3ZlcnJpZGVzLmdldChpZCk7XG4gICAgaWYgKG92ZXJyaWRlcyA9PSBudWxsKSB7XG4gICAgICBvdmVycmlkZXMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHRoaXMuYnV0dG9uT3ZlcnJpZGVzLnNldChpZCwgb3ZlcnJpZGVzKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgY29uc3QgdmFsdWUgPSBvcHRpb25zW2tleV07XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBkZWxldGUgb3ZlcnJpZGVzW2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdmVycmlkZXNba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmJ1dHRvbnNDaGFuZ2VkKHRydWUpO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgT2JzZXJ2ZUNoYW5nZXMoKHRhcmdldCkgPT4ge1xuICAgIHRhcmdldC5vbkNoYW5nZSh0YXJnZXQuZW5hYmxlZCk7XG4gIH0pLFxuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgVG9vbGJhckdyb3VwUHJvcGVydGllcy5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIE9ic2VydmVDaGFuZ2VzKCh0YXJnZXQpID0+IHtcbiAgICB0YXJnZXQub25DaGFuZ2UodGFyZ2V0LmVuYWJsZWQpO1xuICB9KSxcbiAgVmFsaWRhdGUoVU5JT04oWy4uLlRPT0xCQVJfQUxJR05NRU5UU10pLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBUb29sYmFyR3JvdXBQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJhbGlnblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIE9ic2VydmVDaGFuZ2VzKCh0YXJnZXQpID0+IHtcbiAgICB0YXJnZXQub25DaGFuZ2UodGFyZ2V0LmVuYWJsZWQpO1xuICB9KSxcbiAgVmFsaWRhdGUoVU5JT04oVE9PTEJBUl9QT1NJVElPTlMpLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBUb29sYmFyR3JvdXBQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJwb3NpdGlvblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBUb29sYmFyR3JvdXBQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJkcmFnZ2FibGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBPYnNlcnZlQ2hhbmdlcygodGFyZ2V0KSA9PiB7XG4gICAgdGFyZ2V0Lm9uQ2hhbmdlKHRhcmdldC5lbmFibGVkKTtcbiAgfSksXG4gIFZhbGlkYXRlKFVOSU9OKFtcInNtYWxsXCIsIFwibm9ybWFsXCJdKSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgVG9vbGJhckdyb3VwUHJvcGVydGllcy5wcm90b3R5cGUsIFwic2l6ZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIE9ic2VydmVDaGFuZ2VzKCh0YXJnZXQpID0+IHtcbiAgICBmb3IgKGNvbnN0IGJ1dHRvbiBvZiB0YXJnZXQuYnV0dG9ucyA/PyBbXSkge1xuICAgICAgaWYgKGJ1dHRvbi5pY29uICE9IG51bGwgJiYgSUNPTlNfTEVHQUNZLmluY2x1ZGVzKGJ1dHRvbi5pY29uKSkge1xuICAgICAgICBMb2dnZXIud2Fybk9uY2UoYEljb24gJyR7YnV0dG9uLmljb259JyBpcyBkZXByZWNhdGVkLCB1c2UgYW5vdGhlciBpY29uIGluc3RlYWQuYCk7XG4gICAgICB9XG4gICAgICBpZiAoYnV0dG9uLmFyaWFMYWJlbCA9PT0gXCJ0b29sYmFyQW5ub3RhdGlvbnNDb2xvclwiKSB7XG4gICAgICAgIExvZ2dlci53YXJuT25jZShcbiAgICAgICAgICBgQXJpYSBsYWJlbCAnJHtidXR0b24uYXJpYUxhYmVsfScgaXMgZGVwcmVjYXRlZCwgdXNlICd0b29sYmFyQW5ub3RhdGlvbnNMaW5lQ29sb3InIGluc3RlYWQuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB0YXJnZXQuYnV0dG9uc0NoYW5nZWQoZmFsc2UpO1xuICB9KSxcbiAgVmFsaWRhdGUoQVJSQVksIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFRvb2xiYXJHcm91cFByb3BlcnRpZXMucHJvdG90eXBlLCBcImJ1dHRvbnNcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Rvb2xiYXIvdG9vbGJhclN0eWxlcy50c1xudmFyIGJsb2NrID0gXCJhZy1jaGFydHMtdG9vbGJhclwiO1xudmFyIGVsZW1lbnRzID0ge1xuICBhbGlnbjogXCJhZy1jaGFydHMtdG9vbGJhcl9fYWxpZ25cIixcbiAgc2VjdGlvbjogXCJhZy1jaGFydHMtdG9vbGJhcl9fc2VjdGlvblwiLFxuICBidXR0b246IFwiYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvblwiLFxuICBpY29uOiBcImFnLWNoYXJ0cy10b29sYmFyX19pY29uXCIsXG4gIGxhYmVsOiBcImFnLWNoYXJ0cy10b29sYmFyX19sYWJlbFwiXG59O1xudmFyIG1vZGlmaWVycyA9IHtcbiAgW1widG9wXCIgLyogVG9wICovXTogXCJhZy1jaGFydHMtdG9vbGJhci0tdG9wXCIsXG4gIFtcInJpZ2h0XCIgLyogUmlnaHQgKi9dOiBcImFnLWNoYXJ0cy10b29sYmFyLS1yaWdodFwiLFxuICBbXCJib3R0b21cIiAvKiBCb3R0b20gKi9dOiBcImFnLWNoYXJ0cy10b29sYmFyLS1ib3R0b21cIixcbiAgW1wibGVmdFwiIC8qIExlZnQgKi9dOiBcImFnLWNoYXJ0cy10b29sYmFyLS1sZWZ0XCIsXG4gIFtcImZsb2F0aW5nXCIgLyogRmxvYXRpbmcgKi9dOiBcImFnLWNoYXJ0cy10b29sYmFyLS1mbG9hdGluZ1wiLFxuICBbXCJmbG9hdGluZy10b3BcIiAvKiBGbG9hdGluZ1RvcCAqL106IFwiYWctY2hhcnRzLXRvb2xiYXItLWZsb2F0aW5nLXRvcFwiLFxuICBbXCJmbG9hdGluZy1ib3R0b21cIiAvKiBGbG9hdGluZ0JvdHRvbSAqL106IFwiYWctY2hhcnRzLXRvb2xiYXItLWZsb2F0aW5nLWJvdHRvbVwiLFxuICBzbWFsbDogXCJhZy1jaGFydHMtdG9vbGJhci0tc21hbGxcIixcbiAgbm9ybWFsOiBcImFnLWNoYXJ0cy10b29sYmFyLS1ub3JtYWxcIixcbiAgaGlkZGVuOiBcImFnLWNoYXJ0cy10b29sYmFyLS1oaWRkZW5cIixcbiAgcHJldmVudEZsYXNoOiBcImFnLWNoYXJ0cy10b29sYmFyLS1wcmV2ZW50LWZsYXNoXCIsXG4gIGZsb2F0aW5nSGlkZGVuOiBcImFnLWNoYXJ0cy10b29sYmFyLS1mbG9hdGluZy1oaWRkZW5cIixcbiAgYWxpZ246IHtcbiAgICBzdGFydDogXCJhZy1jaGFydHMtdG9vbGJhcl9fYWxpZ24tLXN0YXJ0XCIsXG4gICAgY2VudGVyOiBcImFnLWNoYXJ0cy10b29sYmFyX19hbGlnbi0tY2VudGVyXCIsXG4gICAgZW5kOiBcImFnLWNoYXJ0cy10b29sYmFyX19hbGlnbi0tZW5kXCJcbiAgfSxcbiAgYnV0dG9uOiB7XG4gICAgZmlyc3Q6IFwiYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvbi0tZmlyc3RcIixcbiAgICBsYXN0OiBcImFnLWNoYXJ0cy10b29sYmFyX19idXR0b24tLWxhc3RcIixcbiAgICBhY3RpdmU6IFwiYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvbi0tYWN0aXZlXCIsXG4gICAgaGlkZGVuVmFsdWU6IFwiYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvbi0taGlkZGVuLXZhbHVlXCIsXG4gICAgaGlkZGVuVG9nZ2xlZDogXCJhZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uLS1oaWRkZW4tdG9nZ2xlZFwiLFxuICAgIGZpbGxWaXNpYmxlOiBcImFnLWNoYXJ0cy10b29sYmFyX19idXR0b24tLWZpbGwtdmlzaWJsZVwiLFxuICAgIHN0cm9rZVdpZHRoVmlzaWJsZTogXCJhZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uLS1zdHJva2Utd2lkdGgtdmlzaWJsZVwiLFxuICAgIHdpdGhUcmFuc2l0aW9uOiBcImFnLWNoYXJ0cy10b29sYmFyX19idXR0b24tLXdpdGgtdHJhbnNpdGlvblwiLFxuICAgIGRyYWdIYW5kbGU6IFwiYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvbi0tZHJhZy1oYW5kbGVcIixcbiAgICBkcmFnZ2luZzogXCJhZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uLS1kcmFnZ2luZ1wiXG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Rvb2xiYXIvdG9vbGJhci50c1xudmFyIFRvb2xiYXIgPSBjbGFzcyBleHRlbmRzIEJhc2VNb2R1bGVJbnN0YW5jZSB7XG4gIGNvbnN0cnVjdG9yKGN0eCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLnNlcmllc1R5cGUgPSBuZXcgVG9vbGJhckdyb3VwUHJvcGVydGllcyhcbiAgICAgIHRoaXMub25Hcm91cENoYW5nZWQuYmluZCh0aGlzLCBcInNlcmllc1R5cGVcIiksXG4gICAgICB0aGlzLm9uR3JvdXBCdXR0b25zQ2hhbmdlZC5iaW5kKHRoaXMsIFwic2VyaWVzVHlwZVwiKVxuICAgICk7XG4gICAgdGhpcy5hbm5vdGF0aW9ucyA9IG5ldyBUb29sYmFyR3JvdXBQcm9wZXJ0aWVzKFxuICAgICAgdGhpcy5vbkdyb3VwQ2hhbmdlZC5iaW5kKHRoaXMsIFwiYW5ub3RhdGlvbnNcIiksXG4gICAgICB0aGlzLm9uR3JvdXBCdXR0b25zQ2hhbmdlZC5iaW5kKHRoaXMsIFwiYW5ub3RhdGlvbnNcIilcbiAgICApO1xuICAgIHRoaXMuYW5ub3RhdGlvbk9wdGlvbnMgPSBuZXcgVG9vbGJhckdyb3VwUHJvcGVydGllcyhcbiAgICAgIHRoaXMub25Hcm91cENoYW5nZWQuYmluZCh0aGlzLCBcImFubm90YXRpb25PcHRpb25zXCIpLFxuICAgICAgdGhpcy5vbkdyb3VwQnV0dG9uc0NoYW5nZWQuYmluZCh0aGlzLCBcImFubm90YXRpb25PcHRpb25zXCIpXG4gICAgKTtcbiAgICB0aGlzLnJhbmdlcyA9IG5ldyBUb29sYmFyR3JvdXBQcm9wZXJ0aWVzKFxuICAgICAgdGhpcy5vbkdyb3VwQ2hhbmdlZC5iaW5kKHRoaXMsIFwicmFuZ2VzXCIpLFxuICAgICAgdGhpcy5vbkdyb3VwQnV0dG9uc0NoYW5nZWQuYmluZCh0aGlzLCBcInJhbmdlc1wiKVxuICAgICk7XG4gICAgdGhpcy56b29tID0gbmV3IFRvb2xiYXJHcm91cFByb3BlcnRpZXMoXG4gICAgICB0aGlzLm9uR3JvdXBDaGFuZ2VkLmJpbmQodGhpcywgXCJ6b29tXCIpLFxuICAgICAgdGhpcy5vbkdyb3VwQnV0dG9uc0NoYW5nZWQuYmluZCh0aGlzLCBcInpvb21cIilcbiAgICApO1xuICAgIHRoaXMuZHJhZ1N0YXRlID0ge1xuICAgICAgY2xpZW50OiB7IHg6IDAsIHk6IDAgfSxcbiAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH0sXG4gICAgICBkZXRhY2hlZDogZmFsc2VcbiAgICB9O1xuICAgIHRoaXMuaG9yaXpvbnRhbFNwYWNpbmcgPSAxMDtcbiAgICB0aGlzLnZlcnRpY2FsU3BhY2luZyA9IDEwO1xuICAgIHRoaXMuZmxvYXRpbmdEZXRlY3Rpb25SYW5nZSA9IDM4O1xuICAgIHRoaXMucG9zaXRpb25zID0ge1xuICAgICAgW1widG9wXCIgLyogVG9wICovXTogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSxcbiAgICAgIFtcImxlZnRcIiAvKiBMZWZ0ICovXTogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSxcbiAgICAgIFtcInJpZ2h0XCIgLyogUmlnaHQgKi9dOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxuICAgICAgW1wiYm90dG9tXCIgLyogQm90dG9tICovXTogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSxcbiAgICAgIFtcImZsb2F0aW5nXCIgLyogRmxvYXRpbmcgKi9dOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxuICAgICAgW1wiZmxvYXRpbmctdG9wXCIgLyogRmxvYXRpbmdUb3AgKi9dOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxuICAgICAgW1wiZmxvYXRpbmctYm90dG9tXCIgLyogRmxvYXRpbmdCb3R0b20gKi9dOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpXG4gICAgfTtcbiAgICB0aGlzLnBvc2l0aW9uQWxpZ25tZW50cyA9IHtcbiAgICAgIFtcInRvcFwiIC8qIFRvcCAqL106IHt9LFxuICAgICAgW1wibGVmdFwiIC8qIExlZnQgKi9dOiB7fSxcbiAgICAgIFtcInJpZ2h0XCIgLyogUmlnaHQgKi9dOiB7fSxcbiAgICAgIFtcImJvdHRvbVwiIC8qIEJvdHRvbSAqL106IHt9LFxuICAgICAgW1wiZmxvYXRpbmdcIiAvKiBGbG9hdGluZyAqL106IHt9LFxuICAgICAgW1wiZmxvYXRpbmctdG9wXCIgLyogRmxvYXRpbmdUb3AgKi9dOiB7fSxcbiAgICAgIFtcImZsb2F0aW5nLWJvdHRvbVwiIC8qIEZsb2F0aW5nQm90dG9tICovXToge31cbiAgICB9O1xuICAgIHRoaXMuZ3JvdXBDYWxsZXJzID0ge1xuICAgICAgc2VyaWVzVHlwZTogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSxcbiAgICAgIGFubm90YXRpb25zOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxuICAgICAgYW5ub3RhdGlvbk9wdGlvbnM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksXG4gICAgICByYW5nZXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksXG4gICAgICB6b29tOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpXG4gICAgfTtcbiAgICB0aGlzLmdyb3VwQnV0dG9ucyA9IHtcbiAgICAgIHNlcmllc1R5cGU6IFtdLFxuICAgICAgYW5ub3RhdGlvbnM6IFtdLFxuICAgICAgYW5ub3RhdGlvbk9wdGlvbnM6IFtdLFxuICAgICAgcmFuZ2VzOiBbXSxcbiAgICAgIHpvb206IFtdXG4gICAgfTtcbiAgICB0aGlzLmFyaWFUb29sYmFycyA9IFtcbiAgICAgIHsgZ3JvdXBzOiBbXCJzZXJpZXNUeXBlXCIsIFwiYW5ub3RhdGlvbnNcIl0sIGRlc3Ryb3lGbnM6IFtdLCByZXNldExpc3RlbmVyczogKCkgPT4ge1xuICAgICAgfSB9LFxuICAgICAgeyBncm91cHM6IFtcImFubm90YXRpb25PcHRpb25zXCJdLCBkZXN0cm95Rm5zOiBbXSwgcmVzZXRMaXN0ZW5lcnM6ICgpID0+IHtcbiAgICAgIH0gfSxcbiAgICAgIHsgZ3JvdXBzOiBbXCJyYW5nZXNcIl0sIGRlc3Ryb3lGbnM6IFtdLCByZXNldExpc3RlbmVyczogKCkgPT4ge1xuICAgICAgfSB9LFxuICAgICAgeyBncm91cHM6IFtcInpvb21cIl0sIGRlc3Ryb3lGbnM6IFtdLCByZXNldExpc3RlbmVyczogKCkgPT4ge1xuICAgICAgfSB9XG4gICAgXTtcbiAgICB0aGlzLnBlbmRpbmdCdXR0b25Ub2dnbGVkRXZlbnRzID0gW107XG4gICAgdGhpcy5ncm91cFByb3hpZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuaGFzTmV3TG9jYWxlID0gdHJ1ZTtcbiAgICB0aGlzLmVsZW1lbnRzID0ge307XG4gICAgZm9yIChjb25zdCBwb3NpdGlvbiBvZiBUT09MQkFSX1BPU0lUSU9OUykge1xuICAgICAgdGhpcy5lbGVtZW50c1twb3NpdGlvbl0gPSBjdHguZG9tTWFuYWdlci5hZGRDaGlsZChcImNhbnZhcy1vdmVybGF5XCIsIGB0b29sYmFyLSR7cG9zaXRpb259YCk7XG4gICAgICB0aGlzLmVsZW1lbnRzW3Bvc2l0aW9uXS5yb2xlID0gXCJwcmVzZW50YXRpb25cIjtcbiAgICAgIHRoaXMucmVuZGVyVG9vbGJhcihwb3NpdGlvbik7XG4gICAgfVxuICAgIHRoaXMudG9nZ2xlVmlzaWJpbGl0aWVzKCk7XG4gICAgY29uc3QgZHJhZ1N0YXRlcyA9IDMyIC8qIERlZmF1bHQgKi8gfCA4IC8qIEFubm90YXRpb25zICovO1xuICAgIGNvbnN0IHNlcmllc1JlZ2lvbiA9IGN0eC5yZWdpb25NYW5hZ2VyLmdldFJlZ2lvbihcInNlcmllc1wiKTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMucHVzaChcbiAgICAgIGN0eC5pbnRlcmFjdGlvbk1hbmFnZXIuYWRkTGlzdGVuZXIoXCJob3ZlclwiLCB0aGlzLm9uSG92ZXIuYmluZCh0aGlzKSwgNjMgLyogQWxsICovKSxcbiAgICAgIGN0eC5pbnRlcmFjdGlvbk1hbmFnZXIuYWRkTGlzdGVuZXIoXCJsZWF2ZVwiLCB0aGlzLm9uTGVhdmUuYmluZCh0aGlzKSwgNjMgLyogQWxsICovKSxcbiAgICAgIHNlcmllc1JlZ2lvbi5hZGRMaXN0ZW5lcihcImRyYWctc3RhcnRcIiwgdGhpcy50b2dnbGVOb1BvaW50ZXJFdmVudHMuYmluZCh0aGlzLCB0cnVlKSwgZHJhZ1N0YXRlcyksXG4gICAgICBzZXJpZXNSZWdpb24uYWRkTGlzdGVuZXIoXCJkcmFnLWVuZFwiLCB0aGlzLnRvZ2dsZU5vUG9pbnRlckV2ZW50cy5iaW5kKHRoaXMsIGZhbHNlKSwgNjMgLyogQWxsICovKSxcbiAgICAgIGN0eC50b29sYmFyTWFuYWdlci5hZGRMaXN0ZW5lcihcImJ1dHRvbi10b2dnbGVkXCIsIHRoaXMub25CdXR0b25Ub2dnbGVkLmJpbmQodGhpcykpLFxuICAgICAgY3R4LnRvb2xiYXJNYW5hZ2VyLmFkZExpc3RlbmVyKFwiYnV0dG9uLXVwZGF0ZWRcIiwgdGhpcy5vbkJ1dHRvblVwZGF0ZWQuYmluZCh0aGlzKSksXG4gICAgICBjdHgudG9vbGJhck1hbmFnZXIuYWRkTGlzdGVuZXIoXCJncm91cC10b2dnbGVkXCIsIHRoaXMub25Hcm91cFRvZ2dsZWQuYmluZCh0aGlzKSksXG4gICAgICBjdHgudG9vbGJhck1hbmFnZXIuYWRkTGlzdGVuZXIoXCJncm91cC11cGRhdGVkXCIsIHRoaXMub25Hcm91cFVwZGF0ZWQuYmluZCh0aGlzKSksXG4gICAgICBjdHgudG9vbGJhck1hbmFnZXIuYWRkTGlzdGVuZXIoXCJmbG9hdGluZy1hbmNob3ItY2hhbmdlZFwiLCB0aGlzLm9uRmxvYXRpbmdBbmNob3JDaGFuZ2VkLmJpbmQodGhpcykpLFxuICAgICAgY3R4LnRvb2xiYXJNYW5hZ2VyLmFkZExpc3RlbmVyKFwicHJveHktZ3JvdXAtb3B0aW9uc1wiLCB0aGlzLm9uUHJveHlHcm91cE9wdGlvbnMuYmluZCh0aGlzKSksXG4gICAgICBjdHgubGF5b3V0TWFuYWdlci5yZWdpc3RlckVsZW1lbnQoMiAvKiBUb29sYmFyICovLCB0aGlzLm9uTGF5b3V0U3RhcnQuYmluZCh0aGlzKSksXG4gICAgICBjdHgubGF5b3V0TWFuYWdlci5hZGRMaXN0ZW5lcihcImxheW91dDpjb21wbGV0ZVwiLCB0aGlzLm9uTGF5b3V0Q29tcGxldGUuYmluZCh0aGlzKSksXG4gICAgICBjdHgudXBkYXRlU2VydmljZS5hZGRMaXN0ZW5lcihcInByZS1kb20tdXBkYXRlXCIsIHRoaXMub25QcmVEb21VcGRhdGUuYmluZCh0aGlzKSksXG4gICAgICBjdHgudXBkYXRlU2VydmljZS5hZGRMaXN0ZW5lcihcInVwZGF0ZS1jb21wbGV0ZVwiLCB0aGlzLm9uVXBkYXRlQ29tcGxldGUuYmluZCh0aGlzKSksXG4gICAgICBjdHgubG9jYWxlTWFuYWdlci5hZGRMaXN0ZW5lcihcImxvY2FsZS1jaGFuZ2VkXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy5oYXNOZXdMb2NhbGUgPSB0cnVlO1xuICAgICAgfSksXG4gICAgICAoKSA9PiB0aGlzLmRlc3Ryb3lFbGVtZW50cygpXG4gICAgKTtcbiAgfVxuICBkZXN0cm95RWxlbWVudHMoKSB7XG4gICAgdGhpcy5jdHguZG9tTWFuYWdlci5yZW1vdmVTdHlsZXMoYmxvY2spO1xuICAgIGZvciAoY29uc3QgZWxlbWVudDIgb2YgT2JqZWN0LmtleXModGhpcy5lbGVtZW50cykpIHtcbiAgICAgIHRoaXMuY3R4LmRvbU1hbmFnZXIucmVtb3ZlQ2hpbGQoXCJjYW52YXMtb3ZlcmxheVwiLCBgdG9vbGJhci0ke2VsZW1lbnQyfWApO1xuICAgIH1cbiAgfVxuICBvbkhvdmVyKGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgZW5hYmxlZCxcbiAgICAgIGVsZW1lbnRzOiBlbGVtZW50czIsXG4gICAgICBmbG9hdGluZ0RldGVjdGlvblJhbmdlLFxuICAgICAgY3R4OiB7IHNjZW5lIH1cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB7XG4gICAgICBvZmZzZXRZLFxuICAgICAgc291cmNlRXZlbnQ6IHsgdGFyZ2V0IH1cbiAgICB9ID0gZXZlbnQ7XG4gICAgY29uc3QgeyBGbG9hdGluZ0JvdHRvbSwgRmxvYXRpbmdUb3AgfSA9IFRvb2xiYXJQb3NpdGlvbjtcbiAgICBpZiAoIWVuYWJsZWQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgYm90dG9tID0gZWxlbWVudHMyW0Zsb2F0aW5nQm90dG9tXTtcbiAgICBjb25zdCB0b3AgPSBlbGVtZW50czJbRmxvYXRpbmdUb3BdO1xuICAgIGNvbnN0IGJvdHRvbURldGVjdGlvblkgPSBib3R0b20ub2Zmc2V0VG9wIC0gZmxvYXRpbmdEZXRlY3Rpb25SYW5nZTtcbiAgICBjb25zdCBib3R0b21WaXNpYmxlID0gb2Zmc2V0WSA+IGJvdHRvbURldGVjdGlvblkgJiYgb2Zmc2V0WSA8IHNjZW5lLmNhbnZhcy5lbGVtZW50Lm9mZnNldEhlaWdodCB8fCB0YXJnZXQgPT09IGJvdHRvbTtcbiAgICBjb25zdCB0b3BEZXRlY3Rpb25ZID0gdG9wLm9mZnNldFRvcCArIHRvcC5vZmZzZXRIZWlnaHQgKyBmbG9hdGluZ0RldGVjdGlvblJhbmdlO1xuICAgIGNvbnN0IHRvcFZpc2libGUgPSBvZmZzZXRZID4gMCAmJiBvZmZzZXRZIDwgdG9wRGV0ZWN0aW9uWSB8fCB0YXJnZXQgPT09IHRvcDtcbiAgICB0aGlzLnRyYW5zbGF0ZUZsb2F0aW5nRWxlbWVudHMoRmxvYXRpbmdCb3R0b20sIGJvdHRvbVZpc2libGUpO1xuICAgIHRoaXMudHJhbnNsYXRlRmxvYXRpbmdFbGVtZW50cyhGbG9hdGluZ1RvcCwgdG9wVmlzaWJsZSk7XG4gIH1cbiAgb25MZWF2ZShldmVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGVuYWJsZWQsXG4gICAgICBjdHg6IHsgc2NlbmUgfVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgcmVsYXRlZEVsZW1lbnQsIHRhcmdldEVsZW1lbnQgfSA9IGV2ZW50O1xuICAgIGNvbnN0IHsgRmxvYXRpbmdCb3R0b20sIEZsb2F0aW5nVG9wIH0gPSBUb29sYmFyUG9zaXRpb247XG4gICAgaWYgKCFlbmFibGVkIHx8IHRhcmdldEVsZW1lbnQgIT09IHNjZW5lLmNhbnZhcy5lbGVtZW50KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGlzVGFyZ2V0QnV0dG9uID0gVE9PTEJBUl9HUk9VUFMuc29tZShcbiAgICAgIChncm91cCkgPT4gdGhpcy5ncm91cEJ1dHRvbnNbZ3JvdXBdLnNvbWUoKGJ1dHRvbikgPT4gYnV0dG9uID09PSByZWxhdGVkRWxlbWVudClcbiAgICApO1xuICAgIGlmIChpc1RhcmdldEJ1dHRvbilcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLnRyYW5zbGF0ZUZsb2F0aW5nRWxlbWVudHMoRmxvYXRpbmdCb3R0b20sIGZhbHNlKTtcbiAgICB0aGlzLnRyYW5zbGF0ZUZsb2F0aW5nRWxlbWVudHMoRmxvYXRpbmdUb3AsIGZhbHNlKTtcbiAgfVxuICAvLyBBRy0xMjY5NSBUZW1wb3JhcmlseSBzZXQgYHBvaW50ZXItZXZlbnRzOiBub25lYCBvbiB0aGUgYW5ub3RhdGlvbk9wdGlvbnMgd2hlbiBkcmFnZ2luZywgYmVjYXVzZSB0aGVcbiAgLy8gYnV0dG9ucyBibG9jayB0byBtb3VzZSBmcm9tIGhvdmVyaW5nIG92ZXIgdGhlIGNhbnZhcy5cbiAgdG9nZ2xlTm9Qb2ludGVyRXZlbnRzKG9uKSB7XG4gICAgY29uc3QgY2xhc3NOYW1lID0gXCJhZy1jaGFydHMtdG9vbGJhcl9fbm8tcG9pbnRlci1ldmVudHNcIjtcbiAgICB0aGlzLmdyb3VwQnV0dG9uc1tcImFubm90YXRpb25PcHRpb25zXCJdLmZvckVhY2goKGIpID0+IGIuY2xhc3NMaXN0LnRvZ2dsZShjbGFzc05hbWUsIG9uKSk7XG4gIH1cbiAgb25Hcm91cENoYW5nZWQoZ3JvdXApIHtcbiAgICBpZiAodGhpc1tncm91cF0gPT0gbnVsbCB8fCB0aGlzLmdyb3VwUHJveGllZC5oYXMoZ3JvdXApKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuY3JlYXRlR3JvdXAoZ3JvdXApO1xuICAgIHRoaXMudG9nZ2xlVmlzaWJpbGl0aWVzKCk7XG4gIH1cbiAgb25Hcm91cEJ1dHRvbnNDaGFuZ2VkKGdyb3VwLCBidXR0b25zLCBjb25maWd1cmF0aW9uT25seSkge1xuICAgIGlmICghdGhpcy5lbmFibGVkIHx8IHRoaXMuZ3JvdXBQcm94aWVkLmhhcyhncm91cCkpXG4gICAgICByZXR1cm47XG4gICAgaWYgKGNvbmZpZ3VyYXRpb25Pbmx5KSB7XG4gICAgICBmb3IgKGNvbnN0IGJ1dHRvbk9wdGlvbnMgb2YgdGhpc1tncm91cF0uYnV0dG9uQ29uZmlndXJhdGlvbnMoKSkge1xuICAgICAgICB0aGlzLnJlZnJlc2hCdXR0b25Db250ZW50KGdyb3VwLCBidXR0b25PcHRpb25zKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jcmVhdGVHcm91cEJ1dHRvbnMoZ3JvdXAsIGJ1dHRvbnMpO1xuICAgIH1cbiAgICB0aGlzLnRvZ2dsZVZpc2liaWxpdGllcygpO1xuICB9XG4gIG9uTGF5b3V0Q29tcGxldGUob3B0cykge1xuICAgIGZvciAoY29uc3QgcG9zaXRpb24gb2YgVE9PTEJBUl9QT1NJVElPTlMpIHtcbiAgICAgIHRoaXMuZWxlbWVudHNbcG9zaXRpb25dLmNsYXNzTGlzdC5yZW1vdmUobW9kaWZpZXJzLnByZXZlbnRGbGFzaCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmVuYWJsZWQpIHtcbiAgICAgIHRoaXMucmVmcmVzaElubmVyTGF5b3V0KG9wdHMuc2VyaWVzLnJlY3QpO1xuICAgIH1cbiAgfVxuICB0b2dnbGVCdXR0b25zVHJhbnNpdGlvbihlbmFibGVkKSB7XG4gICAgY29uc3QgY2xhc3NOYW1lID0gbW9kaWZpZXJzLmJ1dHRvbi53aXRoVHJhbnNpdGlvbjtcbiAgICBmb3IgKGNvbnN0IGJ1dHRvbiBvZiBPYmplY3QudmFsdWVzKHRoaXMuZ3JvdXBCdXR0b25zKS5mbGF0KCkpIHtcbiAgICAgIGlmIChlbmFibGVkICYmICFidXR0b24uY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSkpIHtcbiAgICAgICAgYnV0dG9uLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgfVxuICAgICAgYnV0dG9uLmNsYXNzTGlzdC50b2dnbGUoY2xhc3NOYW1lLCBlbmFibGVkKTtcbiAgICB9XG4gIH1cbiAgb25QcmVEb21VcGRhdGUoKSB7XG4gICAgdGhpcy50b2dnbGVCdXR0b25zVHJhbnNpdGlvbihmYWxzZSk7XG4gIH1cbiAgb25VcGRhdGVDb21wbGV0ZSgpIHtcbiAgICB0aGlzLnRvZ2dsZUJ1dHRvbnNUcmFuc2l0aW9uKHRydWUpO1xuICB9XG4gIG9uQnV0dG9uVXBkYXRlZChldmVudCkge1xuICAgIGNvbnN0IHsgdHlwZTogX3R5cGUsIGdyb3VwLCBpZCwgLi4ucGFyYW1zIH0gPSBldmVudDtcbiAgICB0aGlzW2dyb3VwXS5vdmVycmlkZUJ1dHRvbkNvbmZpZ3VyYXRpb24oaWQsIHBhcmFtcyk7XG4gIH1cbiAgc2V0QnV0dG9uQWN0aXZlKGJ1dHRvbiwgYWN0aXZlKSB7XG4gICAgYnV0dG9uLmNsYXNzTGlzdC50b2dnbGUobW9kaWZpZXJzLmJ1dHRvbi5hY3RpdmUsIGFjdGl2ZSk7XG4gIH1cbiAgc2V0QnV0dG9uQ2hlY2tlZChidXR0b24sIGNoZWNrZWQpIHtcbiAgICBpZiAoYnV0dG9uLnJvbGUgPT09IFwic3dpdGNoXCIpIHtcbiAgICAgIGJ1dHRvbi5hcmlhQ2hlY2tlZCA9IGNoZWNrZWQudG9TdHJpbmcoKTtcbiAgICB9XG4gIH1cbiAgc2V0QnV0dG9uR3JvdXBGaXJzdExhc3QoZ3JvdXApIHtcbiAgICBjb25zdCBjaGlsZE5vZGVzID0gQXJyYXkuZnJvbShncm91cC5jaGlsZE5vZGVzID8/IFtdKTtcbiAgICBjb25zdCBzZXRGaXJzdENsYXNzID0gKGZpcnN0MiwgYnV0dG9uLCBtb2RpZmllcikgPT4ge1xuICAgICAgY29uc3QgYnV0dG9uVmlzaWJsZSA9ICFidXR0b24uY2xhc3NMaXN0LmNvbnRhaW5zKG1vZGlmaWVycy5idXR0b24uaGlkZGVuVG9nZ2xlZCk7XG4gICAgICBidXR0b24uY2xhc3NMaXN0LnRvZ2dsZShtb2RpZmllciwgYnV0dG9uVmlzaWJsZSAmJiBmaXJzdDIpO1xuICAgICAgcmV0dXJuIGJ1dHRvblZpc2libGUgPyBmYWxzZSA6IGZpcnN0MjtcbiAgICB9O1xuICAgIGxldCBmaXJzdCA9IHRydWU7XG4gICAgY2hpbGROb2Rlcy5mb3JFYWNoKChidXR0b24pID0+IGZpcnN0ID0gc2V0Rmlyc3RDbGFzcyhmaXJzdCwgYnV0dG9uLCBtb2RpZmllcnMuYnV0dG9uLmZpcnN0KSk7XG4gICAgbGV0IGxhc3QgPSB0cnVlO1xuICAgIGNoaWxkTm9kZXMudG9SZXZlcnNlZCgpLmZvckVhY2goKGJ1dHRvbikgPT4gbGFzdCA9IHNldEZpcnN0Q2xhc3MobGFzdCwgYnV0dG9uLCBtb2RpZmllcnMuYnV0dG9uLmxhc3QpKTtcbiAgfVxuICBvbkJ1dHRvblRvZ2dsZWQoZXZlbnQpIHtcbiAgICBjb25zdCB7IGdyb3VwLCBpZCwgYWN0aXZlLCBlbmFibGVkLCB2aXNpYmxlLCBjaGVja2VkIH0gPSBldmVudDtcbiAgICBpZiAodGhpcy5ncm91cEJ1dHRvbnNbZ3JvdXBdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5wZW5kaW5nQnV0dG9uVG9nZ2xlZEV2ZW50cy5wdXNoKGV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYnV0dG9uID0gdGhpcy5ncm91cEJ1dHRvbnNbZ3JvdXBdLmZpbmQoKGIpID0+IGIuZGF0YXNldC50b29sYmFySWQgPT09IGAke2lkfWApO1xuICAgIGlmIChidXR0b24gPT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICBidXR0b24uYXJpYURpc2FibGVkID0gYCR7IWVuYWJsZWR9YDtcbiAgICBidXR0b24uY2xhc3NMaXN0LnRvZ2dsZShtb2RpZmllcnMuYnV0dG9uLmhpZGRlblRvZ2dsZWQsICF2aXNpYmxlKTtcbiAgICB0aGlzLnNldEJ1dHRvbkFjdGl2ZShidXR0b24sIGFjdGl2ZSk7XG4gICAgdGhpcy5zZXRCdXR0b25DaGVja2VkKGJ1dHRvbiwgY2hlY2tlZCk7XG4gICAgdGhpcy5zZXRCdXR0b25Hcm91cEZpcnN0TGFzdChidXR0b24ucGFyZW50Tm9kZSk7XG4gIH1cbiAgb25Hcm91cFRvZ2dsZWQoZXZlbnQpIHtcbiAgICBjb25zdCB7IGNhbGxlciwgZ3JvdXAsIGFjdGl2ZSwgdmlzaWJsZSB9ID0gZXZlbnQ7XG4gICAgdGhpcy50b2dnbGVHcm91cChjYWxsZXIsIGdyb3VwLCBhY3RpdmUsIHZpc2libGUpO1xuICAgIHRoaXMudG9nZ2xlVmlzaWJpbGl0aWVzKCk7XG4gIH1cbiAgb25Hcm91cFVwZGF0ZWQoZXZlbnQpIHtcbiAgICBjb25zdCB7IGdyb3VwIH0gPSBldmVudDtcbiAgICBmb3IgKGNvbnN0IGFyaWFUb29sYmFyIG9mIHRoaXMuYXJpYVRvb2xiYXJzKSB7XG4gICAgICBpZiAoYXJpYVRvb2xiYXIuZ3JvdXBzLmluY2x1ZGVzKGdyb3VwKSkge1xuICAgICAgICBhcmlhVG9vbGJhci5yZXNldExpc3RlbmVycygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG4gIG9uRmxvYXRpbmdBbmNob3JDaGFuZ2VkKGV2ZW50KSB7XG4gICAgY29uc3QgeyBlbGVtZW50czogZWxlbWVudHMyLCBwb3NpdGlvbnMsIGhvcml6b250YWxTcGFjaW5nLCB2ZXJ0aWNhbFNwYWNpbmcgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBncm91cCwgYW5jaG9yIH0gPSBldmVudDtcbiAgICBjb25zdCBlbGVtZW50MiA9IGVsZW1lbnRzMltcImZsb2F0aW5nXCIgLyogRmxvYXRpbmcgKi9dO1xuICAgIGlmICh0aGlzLmRyYWdTdGF0ZS5kZXRhY2hlZCB8fCBlbGVtZW50Mi5jbGFzc0xpc3QuY29udGFpbnMobW9kaWZpZXJzLmhpZGRlbikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kcmFnU3RhdGUuZGV0YWNoZWQgPSBmYWxzZTtcbiAgICBpZiAoIXBvc2l0aW9uc1tcImZsb2F0aW5nXCIgLyogRmxvYXRpbmcgKi9dLmhhcyhncm91cCkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgcG9zaXRpb24gPSBhbmNob3IucG9zaXRpb24gPz8gXCJhYm92ZVwiO1xuICAgIGNvbnN0IHsgb2Zmc2V0V2lkdGg6IHdpZHRoMiwgb2Zmc2V0SGVpZ2h0OiBoZWlnaHQyIH0gPSBlbGVtZW50MjtcbiAgICBsZXQgdG9wID0gYW5jaG9yLnkgLSBoZWlnaHQyIC0gdmVydGljYWxTcGFjaW5nO1xuICAgIGxldCBsZWZ0ID0gYW5jaG9yLnggLSB3aWR0aDIgLyAyO1xuICAgIGlmIChwb3NpdGlvbiA9PT0gXCJiZWxvd1wiKSB7XG4gICAgICB0b3AgPSBhbmNob3IueSArIHZlcnRpY2FsU3BhY2luZztcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSBcInJpZ2h0XCIpIHtcbiAgICAgIHRvcCA9IGFuY2hvci55IC0gaGVpZ2h0MiAvIDI7XG4gICAgICBsZWZ0ID0gYW5jaG9yLnggKyBob3Jpem9udGFsU3BhY2luZztcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSBcImFib3ZlLWxlZnRcIikge1xuICAgICAgbGVmdCA9IGFuY2hvci54O1xuICAgIH1cbiAgICBjb25zdCBncm91cEJCb3ggPSBuZXcgQkJveChsZWZ0LCB0b3AsIHdpZHRoMiwgaGVpZ2h0Mik7XG4gICAgdGhpcy5wb3NpdGlvbkdyb3VwKGVsZW1lbnQyLCBncm91cCwgZ3JvdXBCQm94KTtcbiAgfVxuICBwb3NpdGlvbkdyb3VwKGVsZW1lbnQyLCBncm91cCwgYmJveCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGN0eDogeyBkb21NYW5hZ2VyIH1cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBjYW52YXNSZWN0ID0gZG9tTWFuYWdlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBiYm94LnggPSBjbGFtcCgwLCBiYm94LngsIGNhbnZhc1JlY3Qud2lkdGggLSBiYm94LndpZHRoKTtcbiAgICBiYm94LnkgPSBjbGFtcCgwLCBiYm94LnksIGNhbnZhc1JlY3QuaGVpZ2h0IC0gYmJveC5oZWlnaHQpO1xuICAgIGNvbnN0IGxlZnQgPSBgJHtNYXRoLmZsb29yKGJib3gueCl9cHhgO1xuICAgIGNvbnN0IHRvcCA9IGAke01hdGguZmxvb3IoYmJveC55KX1weGA7XG4gICAgY29uc3QgZGlydHkgPSBlbGVtZW50Mi5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwibGVmdFwiKSAhPT0gbGVmdCB8fCBlbGVtZW50Mi5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwidG9wXCIpICE9PSB0b3A7XG4gICAgaWYgKCFkaXJ0eSlcbiAgICAgIHJldHVybjtcbiAgICBlbGVtZW50Mi5zdHlsZS5zZXRQcm9wZXJ0eShcImxlZnRcIiwgbGVmdCk7XG4gICAgZWxlbWVudDIuc3R5bGUuc2V0UHJvcGVydHkoXCJ0b3BcIiwgdG9wKTtcbiAgICB0aGlzLm9uR3JvdXBNb3ZlZChncm91cCwgYmJveCk7XG4gIH1cbiAgb25Hcm91cE1vdmVkKGdyb3VwLCBiYm94KSB7XG4gICAgY29uc3Qge1xuICAgICAgZ3JvdXBCdXR0b25zLFxuICAgICAgY3R4OiB7IHRvb2xiYXJNYW5hZ2VyIH1cbiAgICB9ID0gdGhpcztcbiAgICBmb3IgKGNvbnN0IGJ1dHRvbiBvZiBncm91cEJ1dHRvbnNbZ3JvdXBdKSB7XG4gICAgICBpZiAoYnV0dG9uLmNsYXNzTGlzdC5jb250YWlucyhtb2RpZmllcnMuYnV0dG9uLmhpZGRlblRvZ2dsZWQpKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IHBhcmVudCA9IGJ1dHRvbi5vZmZzZXRQYXJlbnQ7XG4gICAgICB0b29sYmFyTWFuYWdlci5idXR0b25Nb3ZlZChcbiAgICAgICAgZ3JvdXAsXG4gICAgICAgIGJ1dHRvbi5kYXRhc2V0LnRvb2xiYXJJZCxcbiAgICAgICAgbmV3IEJCb3goXG4gICAgICAgICAgYnV0dG9uLm9mZnNldExlZnQgKyAocGFyZW50Py5vZmZzZXRMZWZ0ID8/IDApLFxuICAgICAgICAgIGJ1dHRvbi5vZmZzZXRUb3AgKyAocGFyZW50Py5vZmZzZXRUb3AgPz8gMCksXG4gICAgICAgICAgYnV0dG9uLm9mZnNldFdpZHRoLFxuICAgICAgICAgIGJ1dHRvbi5vZmZzZXRIZWlnaHRcbiAgICAgICAgKSxcbiAgICAgICAgYmJveFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgYnV0dG9uUmVjdChidXR0b24sIGNhbnZhc1JlY3QgPSB0aGlzLmN0eC5kb21NYW5hZ2VyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKSB7XG4gICAgY29uc3QgYnV0dG9uUmVjdCA9IGJ1dHRvbi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4gbmV3IEJCb3goXG4gICAgICBidXR0b25SZWN0LmxlZnQgLSBjYW52YXNSZWN0LmxlZnQsXG4gICAgICBidXR0b25SZWN0LnRvcCAtIGNhbnZhc1JlY3QudG9wLFxuICAgICAgYnV0dG9uUmVjdC53aWR0aCxcbiAgICAgIGJ1dHRvblJlY3QuaGVpZ2h0XG4gICAgKTtcbiAgfVxuICBvblByb3h5R3JvdXBPcHRpb25zKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBjYWxsZXIsIGdyb3VwLCBvcHRpb25zIH0gPSBldmVudDtcbiAgICB0aGlzLmdyb3VwUHJveGllZC5zZXQoZ3JvdXAsIG9wdGlvbnMpO1xuICAgIHRoaXNbZ3JvdXBdLnNldChvcHRpb25zKTtcbiAgICB0aGlzLnRvZ2dsZUdyb3VwKGNhbGxlciwgZ3JvdXAsIHZvaWQgMCwgb3B0aW9ucy5lbmFibGVkKTtcbiAgICB0aGlzLmNyZWF0ZUdyb3VwKGdyb3VwLCBvcHRpb25zLmVuYWJsZWQsIG9wdGlvbnMucG9zaXRpb24pO1xuICAgIGlmIChvcHRpb25zLmVuYWJsZWQpIHtcbiAgICAgIHRoaXMuY3JlYXRlR3JvdXBCdXR0b25zKGdyb3VwLCBvcHRpb25zLmJ1dHRvbnMpO1xuICAgIH1cbiAgfVxuICBjcmVhdGVHcm91cChncm91cCwgZW5hYmxlZCwgcG9zaXRpb24pIHtcbiAgICBlbmFibGVkID8/IChlbmFibGVkID0gdGhpc1tncm91cF0uZW5hYmxlZCk7XG4gICAgcG9zaXRpb24gPz8gKHBvc2l0aW9uID0gdGhpc1tncm91cF0ucG9zaXRpb24pO1xuICAgIGZvciAoY29uc3QgcG9zIG9mIFRPT0xCQVJfUE9TSVRJT05TKSB7XG4gICAgICBpZiAoZW5hYmxlZCAmJiBwb3NpdGlvbiA9PT0gcG9zKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb25zW3Bvc10uYWRkKGdyb3VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucG9zaXRpb25zW3Bvc10uZGVsZXRlKGdyb3VwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY3JlYXRlR3JvdXBCdXR0b25zKGdyb3VwLCBidXR0b25zID0gW10pIHtcbiAgICBmb3IgKGNvbnN0IGJ1dHRvbiBvZiB0aGlzLmdyb3VwQnV0dG9uc1tncm91cF0pIHtcbiAgICAgIGJ1dHRvbi5yZW1vdmUoKTtcbiAgICB9XG4gICAgdGhpcy5ncm91cEJ1dHRvbnNbZ3JvdXBdID0gW107XG4gICAgaWYgKGJ1dHRvbnMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgYWxpZ24sIHBvc2l0aW9uIH0gPSB0aGlzW2dyb3VwXTtcbiAgICBjb25zdCBhbGlnbkVsZW1lbnQgPSB0aGlzLnBvc2l0aW9uQWxpZ25tZW50c1twb3NpdGlvbl1bYWxpZ25dO1xuICAgIGlmICghYWxpZ25FbGVtZW50KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG5leHRTZWN0aW9uID0gKHNlY3Rpb24yKSA9PiB7XG4gICAgICBjb25zdCBhbGlnbkVsZW1lbnRDaGlsZHJlbiA9IEFycmF5LmZyb20oYWxpZ25FbGVtZW50LmNoaWxkcmVuKTtcbiAgICAgIGNvbnN0IGRhdGFHcm91cCA9IFwiZGF0YS1ncm91cFwiO1xuICAgICAgY29uc3QgZGF0YVNlY3Rpb24gPSBcImRhdGEtc2VjdGlvblwiO1xuICAgICAgbGV0IHNlY3Rpb25FbGVtZW50ID0gYWxpZ25FbGVtZW50Q2hpbGRyZW4uZmluZCgocHJldlNlY3Rpb24yKSA9PiB7XG4gICAgICAgIHJldHVybiBwcmV2U2VjdGlvbjIuZ2V0QXR0cmlidXRlKGRhdGFHcm91cCkgPT09IGdyb3VwICYmIHByZXZTZWN0aW9uMi5nZXRBdHRyaWJ1dGUoZGF0YVNlY3Rpb24pID09PSAoc2VjdGlvbjIgPz8gXCJcIik7XG4gICAgICB9KTtcbiAgICAgIGlmICghc2VjdGlvbkVsZW1lbnQpIHtcbiAgICAgICAgc2VjdGlvbkVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBzZWN0aW9uRWxlbWVudC5yb2xlID0gXCJwcmVzZW50YXRpb25cIjtcbiAgICAgICAgc2VjdGlvbkVsZW1lbnQuc2V0QXR0cmlidXRlKGRhdGFHcm91cCwgZ3JvdXApO1xuICAgICAgICBzZWN0aW9uRWxlbWVudC5zZXRBdHRyaWJ1dGUoZGF0YVNlY3Rpb24sIHNlY3Rpb24yID8/IFwiXCIpO1xuICAgICAgICBjb25zdCBncm91cEluZGV4ID0gVE9PTEJBUl9HUk9VUF9PUkRFUklOR1tncm91cF07XG4gICAgICAgIGNvbnN0IGluc2VydEJlZm9yZUVsZW1lbnQgPSBhbGlnbkVsZW1lbnRDaGlsZHJlbi5maW5kKChwcmV2U2VjdGlvbjIpID0+IHtcbiAgICAgICAgICBjb25zdCBwcmV2R3JvdXAgPSBwcmV2U2VjdGlvbjIuZ2V0QXR0cmlidXRlKGRhdGFHcm91cCk7XG4gICAgICAgICAgY29uc3QgcHJldkdyb3VwSW5kZXggPSBUT09MQkFSX0dST1VQX09SREVSSU5HW3ByZXZHcm91cF07XG4gICAgICAgICAgcmV0dXJuIHByZXZHcm91cEluZGV4ID4gZ3JvdXBJbmRleDtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpbnNlcnRCZWZvcmVFbGVtZW50ICE9IG51bGwpIHtcbiAgICAgICAgICBhbGlnbkVsZW1lbnQuaW5zZXJ0QmVmb3JlKHNlY3Rpb25FbGVtZW50LCBpbnNlcnRCZWZvcmVFbGVtZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhbGlnbkVsZW1lbnQuYXBwZW5kQ2hpbGQoc2VjdGlvbkVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVzdHJveUZucy5wdXNoKCgpID0+IHNlY3Rpb25FbGVtZW50LnJlbW92ZSgpKTtcbiAgICAgIH1cbiAgICAgIHNlY3Rpb25FbGVtZW50LmNsYXNzTGlzdC5hZGQoZWxlbWVudHMuc2VjdGlvbiwgbW9kaWZpZXJzW3RoaXNbZ3JvdXBdLnNpemVdKTtcbiAgICAgIHJldHVybiBzZWN0aW9uRWxlbWVudDtcbiAgICB9O1xuICAgIGxldCBwcmV2U2VjdGlvbiA9IGJ1dHRvbnMuYXQoMCk/LnNlY3Rpb247XG4gICAgbGV0IHNlY3Rpb24gPSBuZXh0U2VjdGlvbihwcmV2U2VjdGlvbik7XG4gICAgZm9yIChjb25zdCBvcHRpb25zIG9mIGJ1dHRvbnMpIHtcbiAgICAgIGlmIChwcmV2U2VjdGlvbiAhPT0gb3B0aW9ucy5zZWN0aW9uKSB7XG4gICAgICAgIHRoaXMuc2V0QnV0dG9uR3JvdXBGaXJzdExhc3Qoc2VjdGlvbik7XG4gICAgICAgIHNlY3Rpb24gPSBuZXh0U2VjdGlvbihvcHRpb25zLnNlY3Rpb24pO1xuICAgICAgfVxuICAgICAgcHJldlNlY3Rpb24gPSBvcHRpb25zLnNlY3Rpb247XG4gICAgICBjb25zdCBidXR0b24gPSB0aGlzLmNyZWF0ZUJ1dHRvbkVsZW1lbnQoZ3JvdXAsIG9wdGlvbnMpO1xuICAgICAgc2VjdGlvbi5hcHBlbmRDaGlsZChidXR0b24pO1xuICAgICAgdGhpcy5ncm91cEJ1dHRvbnNbZ3JvdXBdLnB1c2goYnV0dG9uKTtcbiAgICB9XG4gICAgdGhpcy5zZXRCdXR0b25Hcm91cEZpcnN0TGFzdChzZWN0aW9uKTtcbiAgICBjb25zdCBvbkVzY2FwZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuY3R4LnRvb2xiYXJNYW5hZ2VyLmNhbmNlbChncm91cCk7XG4gICAgfTtcbiAgICBsZXQgb25Gb2N1cztcbiAgICBsZXQgb25CbHVyO1xuICAgIGlmIChpc0FuaW1hdGluZ0Zsb2F0aW5nUG9zaXRpb24ocG9zaXRpb24pKSB7XG4gICAgICBvbkZvY3VzID0gKCkgPT4gdGhpcy50cmFuc2xhdGVGbG9hdGluZ0VsZW1lbnRzKHBvc2l0aW9uLCB0cnVlKTtcbiAgICAgIG9uQmx1ciA9ICgpID0+IHRoaXMudHJhbnNsYXRlRmxvYXRpbmdFbGVtZW50cyhwb3NpdGlvbiwgZmFsc2UpO1xuICAgIH1cbiAgICB0aGlzLmNyZWF0ZUFyaWFUb29sYmFyKGdyb3VwLCBhbGlnbkVsZW1lbnQsIG9uRm9jdXMsIG9uQmx1ciwgb25Fc2NhcGUpO1xuICB9XG4gIGNyZWF0ZUFyaWFUb29sYmFyKGdyb3VwLCB0b29sYmFyLCBvbkZvY3VzLCBvbkJsdXIsIG9uRXNjYXBlKSB7XG4gICAgY29uc3Qgb3JpZW50YXRpb24gPSB0aGlzLmNvbXB1dGVBcmlhT3JpZW50YXRpb24odGhpc1tncm91cF0ucG9zaXRpb24pO1xuICAgIGNvbnN0IGFyaWFUb29sYmFyID0gdGhpcy5nZXRBcmlhVG9vbGJhcihncm91cCk7XG4gICAgYXJpYVRvb2xiYXIucmVzZXRMaXN0ZW5lcnMgPSAoKSA9PiB7XG4gICAgICBjb25zdCBidXR0b25zID0gYXJpYVRvb2xiYXIuZ3JvdXBzLm1hcCgoZykgPT4gdGhpcy5ncm91cEJ1dHRvbnNbZ10pLmZsYXQoKS5maWx0ZXIoXG4gICAgICAgIChiKSA9PiAhYi5jbGFzc0xpc3QuY29udGFpbnMobW9kaWZpZXJzLmJ1dHRvbi5oaWRkZW5Ub2dnbGVkKSAmJiAhYi5jbGFzc0xpc3QuY29udGFpbnMobW9kaWZpZXJzLmJ1dHRvbi5kcmFnSGFuZGxlKVxuICAgICAgKTtcbiAgICAgIGFyaWFUb29sYmFyLmRlc3Ryb3lGbnMuZm9yRWFjaCgoZCkgPT4gZCgpKTtcbiAgICAgIGFyaWFUb29sYmFyLmRlc3Ryb3lGbnMgPSBpbml0VG9vbGJhcktleU5hdih7IG9yaWVudGF0aW9uLCB0b29sYmFyLCBidXR0b25zLCBvbkVzY2FwZSwgb25Gb2N1cywgb25CbHVyIH0pO1xuICAgIH07XG4gICAgYXJpYVRvb2xiYXIucmVzZXRMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLnVwZGF0ZVRvb2xiYXJBcmlhTGFiZWwoZ3JvdXAsIHRvb2xiYXIpO1xuICB9XG4gIGNvbXB1dGVBcmlhT3JpZW50YXRpb24ocG9zaXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9wOiBcImhvcml6b250YWxcIixcbiAgICAgIHJpZ2h0OiBcInZlcnRpY2FsXCIsXG4gICAgICBib3R0b206IFwiaG9yaXpvbnRhbFwiLFxuICAgICAgbGVmdDogXCJ2ZXJ0aWNhbFwiLFxuICAgICAgZmxvYXRpbmc6IFwiaG9yaXpvbnRhbFwiLFxuICAgICAgXCJmbG9hdGluZy10b3BcIjogXCJob3Jpem9udGFsXCIsXG4gICAgICBcImZsb2F0aW5nLWJvdHRvbVwiOiBcImhvcml6b250YWxcIlxuICAgIH1bcG9zaXRpb25dO1xuICB9XG4gIHRvZ2dsZUdyb3VwKGNhbGxlciwgZ3JvdXAsIGFjdGl2ZSwgZW5hYmxlZCkge1xuICAgIGlmIChlbmFibGVkID09PSB0cnVlKSB7XG4gICAgICB0aGlzLmdyb3VwQ2FsbGVyc1tncm91cF0uYWRkKGNhbGxlcik7XG4gICAgfSBlbHNlIGlmIChlbmFibGVkID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5ncm91cENhbGxlcnNbZ3JvdXBdLmRlbGV0ZShjYWxsZXIpO1xuICAgIH1cbiAgICBpZiAoYWN0aXZlICE9IG51bGwpIHtcbiAgICAgIGZvciAoY29uc3QgYnV0dG9uIG9mIHRoaXMuZ3JvdXBCdXR0b25zW2dyb3VwXSkge1xuICAgICAgICB0aGlzLnNldEJ1dHRvbkFjdGl2ZShidXR0b24sIGFjdGl2ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHByb2Nlc3NQZW5kaW5nRXZlbnRzKCkge1xuICAgIGNvbnN0IHBlbmRpbmdCdXR0b25Ub2dnbGVkRXZlbnRzID0gKHRoaXMucGVuZGluZ0J1dHRvblRvZ2dsZWRFdmVudHMgPz8gW10pLnNsaWNlKCk7XG4gICAgZm9yIChjb25zdCBldmVudCBvZiBwZW5kaW5nQnV0dG9uVG9nZ2xlZEV2ZW50cykge1xuICAgICAgdGhpcy5vbkJ1dHRvblRvZ2dsZWQoZXZlbnQpO1xuICAgIH1cbiAgICB0aGlzLnBlbmRpbmdCdXR0b25Ub2dnbGVkRXZlbnRzID0gW107XG4gIH1cbiAgb25MYXlvdXRTdGFydChjdHgpIHtcbiAgICBpZiAodGhpcy5lbmFibGVkKSB7XG4gICAgICB0aGlzLnJlZnJlc2hPdXRlckxheW91dChjdHgubGF5b3V0Qm94KTtcbiAgICAgIHRoaXMucmVmcmVzaExvY2FsZSgpO1xuICAgIH1cbiAgfVxuICByZWZyZXNoT3V0ZXJMYXlvdXQoc2hyaW5rUmVjdCkge1xuICAgIGNvbnN0IHsgZWxlbWVudHM6IGVsZW1lbnRzMiwgaG9yaXpvbnRhbFNwYWNpbmcsIHZlcnRpY2FsU3BhY2luZyB9ID0gdGhpcztcbiAgICBpZiAoIWVsZW1lbnRzMi50b3AuY2xhc3NMaXN0LmNvbnRhaW5zKG1vZGlmaWVycy5oaWRkZW4pKSB7XG4gICAgICBzaHJpbmtSZWN0LnNocmluayhlbGVtZW50czIudG9wLm9mZnNldEhlaWdodCArIHZlcnRpY2FsU3BhY2luZywgXCJ0b3BcIik7XG4gICAgfVxuICAgIGlmICghZWxlbWVudHMyLnJpZ2h0LmNsYXNzTGlzdC5jb250YWlucyhtb2RpZmllcnMuaGlkZGVuKSkge1xuICAgICAgc2hyaW5rUmVjdC5zaHJpbmsoZWxlbWVudHMyLnJpZ2h0Lm9mZnNldFdpZHRoICsgaG9yaXpvbnRhbFNwYWNpbmcsIFwicmlnaHRcIik7XG4gICAgfVxuICAgIGlmICghZWxlbWVudHMyLmJvdHRvbS5jbGFzc0xpc3QuY29udGFpbnMobW9kaWZpZXJzLmhpZGRlbikpIHtcbiAgICAgIHNocmlua1JlY3Quc2hyaW5rKGVsZW1lbnRzMi5ib3R0b20ub2Zmc2V0SGVpZ2h0ICsgdmVydGljYWxTcGFjaW5nLCBcImJvdHRvbVwiKTtcbiAgICAgIGVsZW1lbnRzMi5ib3R0b20uc3R5bGUudG9wID0gYCR7c2hyaW5rUmVjdC55ICsgc2hyaW5rUmVjdC5oZWlnaHQgKyB2ZXJ0aWNhbFNwYWNpbmd9cHhgO1xuICAgIH1cbiAgICBpZiAoIWVsZW1lbnRzMi5sZWZ0LmNsYXNzTGlzdC5jb250YWlucyhtb2RpZmllcnMuaGlkZGVuKSkge1xuICAgICAgc2hyaW5rUmVjdC5zaHJpbmsoZWxlbWVudHMyLmxlZnQub2Zmc2V0V2lkdGggKyBob3Jpem9udGFsU3BhY2luZywgXCJsZWZ0XCIpO1xuICAgIH1cbiAgfVxuICByZWZyZXNoTG9jYWxlKCkge1xuICAgIGNvbnN0IHsgaGFzTmV3TG9jYWxlIH0gPSB0aGlzO1xuICAgIGlmICghaGFzTmV3TG9jYWxlKVxuICAgICAgcmV0dXJuO1xuICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgVE9PTEJBUl9HUk9VUFMpIHtcbiAgICAgIGNvbnN0IGJ1dHRvbnMgPSB0aGlzW2dyb3VwXS5idXR0b25Db25maWd1cmF0aW9ucygpO1xuICAgICAgZm9yIChjb25zdCBidXR0b25PcHRpb25zIG9mIGJ1dHRvbnMpIHtcbiAgICAgICAgdGhpcy5yZWZyZXNoQnV0dG9uQ29udGVudChncm91cCwgYnV0dG9uT3B0aW9ucyk7XG4gICAgICB9XG4gICAgICB0aGlzLnVwZGF0ZVRvb2xiYXJBcmlhTGFiZWwoZ3JvdXApO1xuICAgIH1cbiAgICB0aGlzLmhhc05ld0xvY2FsZSA9IGZhbHNlO1xuICB9XG4gIHJlZnJlc2hJbm5lckxheW91dChyZWN0KSB7XG4gICAgY29uc3QgeyBlbGVtZW50czogZWxlbWVudHMyLCB2ZXJ0aWNhbFNwYWNpbmcgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBGbG9hdGluZ0JvdHRvbSwgRmxvYXRpbmdUb3AgfSA9IFRvb2xiYXJQb3NpdGlvbjtcbiAgICBlbGVtZW50czIudG9wLnN0eWxlLnRvcCA9IGAke3JlY3QueSAtIGVsZW1lbnRzMi50b3Aub2Zmc2V0SGVpZ2h0IC0gdmVydGljYWxTcGFjaW5nfXB4YDtcbiAgICBlbGVtZW50czIudG9wLnN0eWxlLmxlZnQgPSBgJHtyZWN0Lnh9cHhgO1xuICAgIGVsZW1lbnRzMi50b3Auc3R5bGUud2lkdGggPSBgJHtyZWN0LndpZHRofXB4YDtcbiAgICBlbGVtZW50czIuYm90dG9tLnN0eWxlLmxlZnQgPSBgJHtyZWN0Lnh9cHhgO1xuICAgIGVsZW1lbnRzMi5ib3R0b20uc3R5bGUud2lkdGggPSBgJHtyZWN0LndpZHRofXB4YDtcbiAgICBlbGVtZW50czIucmlnaHQuc3R5bGUudG9wID0gYCR7cmVjdC55fXB4YDtcbiAgICBlbGVtZW50czIucmlnaHQuc3R5bGUucmlnaHQgPSBgMHB4YDtcbiAgICBlbGVtZW50czIucmlnaHQuc3R5bGUuaGVpZ2h0ID0gYCR7cmVjdC5oZWlnaHR9cHhgO1xuICAgIGVsZW1lbnRzMi5sZWZ0LnN0eWxlLnRvcCA9IGAke3JlY3QueX1weGA7XG4gICAgZWxlbWVudHMyLmxlZnQuc3R5bGUubGVmdCA9IGAwcHhgO1xuICAgIGVsZW1lbnRzMi5sZWZ0LnN0eWxlLmhlaWdodCA9IGAke3JlY3QuaGVpZ2h0fXB4YDtcbiAgICBlbGVtZW50czJbRmxvYXRpbmdUb3BdLnN0eWxlLnRvcCA9IGAke3JlY3QueX1weGA7XG4gICAgZWxlbWVudHMyW0Zsb2F0aW5nQm90dG9tXS5zdHlsZS50b3AgPSBgJHtyZWN0LnkgKyByZWN0LmhlaWdodCAtIGVsZW1lbnRzMltGbG9hdGluZ0JvdHRvbV0ub2Zmc2V0SGVpZ2h0fXB4YDtcbiAgfVxuICByZWZyZXNoQnV0dG9uQ29udGVudChncm91cCwgYnV0dG9uT3B0aW9ucykge1xuICAgIGNvbnN0IGlkID0gdGhpcy5idXR0b25JZChidXR0b25PcHRpb25zKTtcbiAgICBjb25zdCBidXR0b24gPSB0aGlzLmdyb3VwUHJveGllZC5nZXQoZ3JvdXApPy5idXR0b25zPy5maW5kKChiKSA9PiB0aGlzLmJ1dHRvbklkKGIpID09PSBpZCkgPz8gYnV0dG9uT3B0aW9ucztcbiAgICBjb25zdCBlbGVtZW50MiA9IHRoaXMuZ3JvdXBCdXR0b25zW2dyb3VwXS5maW5kKChiKSA9PiBiLmdldEF0dHJpYnV0ZShcImRhdGEtdG9vbGJhci1pZFwiKSA9PT0gaWQpO1xuICAgIGlmIChlbGVtZW50MiA9PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMudXBkYXRlQnV0dG9uKGVsZW1lbnQyLCBidXR0b24pO1xuICB9XG4gIHRvZ2dsZVZpc2liaWxpdGllcygpIHtcbiAgICBpZiAodGhpcy5lbGVtZW50cyA9PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGlzR3JvdXBWaXNpYmxlID0gKGdyb3VwKSA9PiB0aGlzW2dyb3VwXS5lbmFibGVkICYmIHRoaXMuZ3JvdXBDYWxsZXJzW2dyb3VwXS5zaXplID4gMDtcbiAgICBjb25zdCBpc0J1dHRvblZpc2libGUgPSAoZWxlbWVudDIpID0+IChidXR0b24pID0+IHtcbiAgICAgIGNvbnN0IGlkID0gdGhpcy5idXR0b25JZChidXR0b24pO1xuICAgICAgcmV0dXJuIGlkID09IG51bGwgfHwgaWQgPT09IGVsZW1lbnQyLmRhdGFzZXQudG9vbGJhcklkO1xuICAgIH07XG4gICAgZm9yIChjb25zdCBwb3NpdGlvbiBvZiBUT09MQkFSX1BPU0lUSU9OUykge1xuICAgICAgY29uc3QgdmlzaWJsZSA9IHRoaXMuZW5hYmxlZCAmJiBBcnJheS5mcm9tKHRoaXMucG9zaXRpb25zW3Bvc2l0aW9uXS52YWx1ZXMoKSkuc29tZShpc0dyb3VwVmlzaWJsZSk7XG4gICAgICBpZiAocG9zaXRpb24gPT09IFwiZmxvYXRpbmdcIiAvKiBGbG9hdGluZyAqLyAmJiAhdmlzaWJsZSkge1xuICAgICAgICB0aGlzLmRyYWdTdGF0ZS5kZXRhY2hlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhpcy5lbGVtZW50c1twb3NpdGlvbl0uY2xhc3NMaXN0LnRvZ2dsZShtb2RpZmllcnMuaGlkZGVuLCAhdmlzaWJsZSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgVE9PTEJBUl9HUk9VUFMpIHtcbiAgICAgIGlmICh0aGlzW2dyb3VwXSA9PSBudWxsKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IGdyb3VwVmlzaWJsZSA9IGlzR3JvdXBWaXNpYmxlKGdyb3VwKTtcbiAgICAgIGZvciAoY29uc3QgYnV0dG9uIG9mIHRoaXMuZ3JvdXBCdXR0b25zW2dyb3VwXSkge1xuICAgICAgICBjb25zdCBidXR0b25WaXNpYmxlID0gZ3JvdXBWaXNpYmxlICYmIHRoaXNbZ3JvdXBdLmJ1dHRvbkNvbmZpZ3VyYXRpb25zKCkuc29tZShpc0J1dHRvblZpc2libGUoYnV0dG9uKSk7XG4gICAgICAgIGJ1dHRvbi5jbGFzc0xpc3QudG9nZ2xlKG1vZGlmaWVycy5idXR0b24uaGlkZGVuVmFsdWUsICFidXR0b25WaXNpYmxlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdHJhbnNsYXRlRmxvYXRpbmdFbGVtZW50cyhwb3NpdGlvbiwgdmlzaWJsZSkge1xuICAgIGNvbnN0IHsgZWxlbWVudHM6IGVsZW1lbnRzMiwgdmVydGljYWxTcGFjaW5nOiB2ZXJ0aWNhbE1hcmdpbiwgcG9zaXRpb25BbGlnbm1lbnRzIH0gPSB0aGlzO1xuICAgIGNvbnN0IGVsZW1lbnQyID0gZWxlbWVudHMyW3Bvc2l0aW9uXTtcbiAgICBjb25zdCBhbGlnbm1lbnRzID0gT2JqZWN0LnZhbHVlcyhwb3NpdGlvbkFsaWdubWVudHNbcG9zaXRpb25dKTtcbiAgICBlbGVtZW50Mi5jbGFzc0xpc3QudG9nZ2xlKG1vZGlmaWVycy5mbG9hdGluZ0hpZGRlbiwgIXZpc2libGUpO1xuICAgIGNvbnN0IGRpciA9IHBvc2l0aW9uID09PSBcImZsb2F0aW5nLWJvdHRvbVwiIC8qIEZsb2F0aW5nQm90dG9tICovID8gMSA6IC0xO1xuICAgIGZvciAoY29uc3QgYWxpZ24gb2YgYWxpZ25tZW50cykge1xuICAgICAgYWxpZ24uc3R5bGUudHJhbnNmb3JtID0gdmlzaWJsZSAmJiBhbGlnbi5zdHlsZS50cmFuc2Zvcm0gIT09IFwiXCIgPyBcInRyYW5zbGF0ZVkoMClcIiA6IGB0cmFuc2xhdGVZKCR7KGVsZW1lbnQyLm9mZnNldEhlaWdodCArIHZlcnRpY2FsTWFyZ2luKSAqIGRpcn1weClgO1xuICAgIH1cbiAgfVxuICByZW5kZXJUb29sYmFyKHBvc2l0aW9uID0gXCJ0b3BcIiAvKiBUb3AgKi8pIHtcbiAgICBjb25zdCBlbGVtZW50MiA9IHRoaXMuZWxlbWVudHNbcG9zaXRpb25dO1xuICAgIGVsZW1lbnQyLmNsYXNzTGlzdC5hZGQoYmxvY2ssIG1vZGlmaWVyc1twb3NpdGlvbl0sIG1vZGlmaWVycy5wcmV2ZW50Rmxhc2gpO1xuICAgIGlmIChpc0FuaW1hdGluZ0Zsb2F0aW5nUG9zaXRpb24ocG9zaXRpb24pKSB7XG4gICAgICBlbGVtZW50Mi5jbGFzc0xpc3QuYWRkKG1vZGlmaWVycy5mbG9hdGluZ0hpZGRlbik7XG4gICAgfVxuICAgIGZvciAoY29uc3QgYWxpZ24gb2YgVE9PTEJBUl9BTElHTk1FTlRTKSB7XG4gICAgICBjb25zdCBhbGlnbm1lbnRFbGVtZW50ID0gY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGFsaWdubWVudEVsZW1lbnQucm9sZSA9IFwicHJlc2VudGF0aW9uXCI7XG4gICAgICBhbGlnbm1lbnRFbGVtZW50LmNsYXNzTGlzdC5hZGQoZWxlbWVudHMuYWxpZ24sIG1vZGlmaWVycy5hbGlnblthbGlnbl0pO1xuICAgICAgZWxlbWVudDIuYXBwZW5kQ2hpbGQoYWxpZ25tZW50RWxlbWVudCk7XG4gICAgICB0aGlzLnBvc2l0aW9uQWxpZ25tZW50c1twb3NpdGlvbl1bYWxpZ25dID0gYWxpZ25tZW50RWxlbWVudDtcbiAgICB9XG4gIH1cbiAgY3JlYXRlQnV0dG9uRWxlbWVudChncm91cCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGJ1dHRvbiA9IGNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgYnV0dG9uLmNsYXNzTGlzdC5hZGQoZWxlbWVudHMuYnV0dG9uKTtcbiAgICBidXR0b24uZGF0YXNldC50b29sYmFyR3JvdXAgPSBncm91cDtcbiAgICBzZXRBdHRyaWJ1dGUoYnV0dG9uLCBcInRhYmluZGV4XCIsIC0xKTtcbiAgICBpZiAob3B0aW9ucy5oYXNwb3B1cCkge1xuICAgICAgc2V0QXR0cmlidXRlcyhidXR0b24sIHsgXCJhcmlhLWhhc3BvcHVwXCI6IHRydWUsIFwiYXJpYS1leHBhbmRlZFwiOiBmYWxzZSB9KTtcbiAgICB9XG4gICAgYnV0dG9uLmRhdGFzZXQudG9vbGJhcklkID0gdGhpcy5idXR0b25JZChvcHRpb25zKTtcbiAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwiY2xpY2tcIixcbiAgICAgIG1ha2VBY2Nlc3NpYmxlQ2xpY2tMaXN0ZW5lcihcbiAgICAgICAgYnV0dG9uLFxuICAgICAgICAoZXZlbnQpID0+IHRoaXMub25CdXR0b25QcmVzcyhldmVudCwgYnV0dG9uLCBncm91cCwgb3B0aW9ucy5pZCwgb3B0aW9ucy52YWx1ZSlcbiAgICAgIClcbiAgICApO1xuICAgIGlmIChvcHRpb25zLnZhbHVlID09PSBcImRyYWdcIikge1xuICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwibW91c2Vkb3duXCIsXG4gICAgICAgIG1ha2VBY2Nlc3NpYmxlQ2xpY2tMaXN0ZW5lcihidXR0b24sIChldmVudCkgPT4gdGhpcy5vbkRyYWdTdGFydChldmVudCwgYnV0dG9uLCBncm91cCkpXG4gICAgICApO1xuICAgICAgYnV0dG9uLmNsYXNzTGlzdC5hZGQobW9kaWZpZXJzLmJ1dHRvbi5kcmFnSGFuZGxlKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucm9sZSA9PT0gXCJzd2l0Y2hcIikge1xuICAgICAgc2V0QXR0cmlidXRlcyhidXR0b24sIHsgcm9sZTogb3B0aW9ucy5yb2xlLCBcImFyaWEtY2hlY2tlZFwiOiBmYWxzZSB9KTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVCdXR0b24oYnV0dG9uLCBvcHRpb25zKTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMucHVzaCgoKSA9PiBidXR0b24ucmVtb3ZlKCkpO1xuICAgIHJldHVybiBidXR0b247XG4gIH1cbiAgZ2V0QXJpYVRvb2xiYXIoZ3JvdXApIHtcbiAgICBmb3IgKGNvbnN0IGFyaWFUb29sYmFyIG9mIHRoaXMuYXJpYVRvb2xiYXJzKSB7XG4gICAgICBpZiAoYXJpYVRvb2xiYXIuZ3JvdXBzLmluY2x1ZGVzKGdyb3VwKSkge1xuICAgICAgICByZXR1cm4gYXJpYVRvb2xiYXI7XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgQUcgQ2hhcnRzIC0gY2Fubm90IGZpbmQgYXJpYS10b29sYmFyIG9mICcke2dyb3VwfSdgKTtcbiAgfVxuICB1cGRhdGVUb29sYmFyQXJpYUxhYmVsKGdyb3VwLCBhbGlnbkVsZW1lbnQpIHtcbiAgICBpZiAoIWFsaWduRWxlbWVudCkge1xuICAgICAgY29uc3QgeyBhbGlnbiwgcG9zaXRpb24gfSA9IHRoaXNbZ3JvdXBdO1xuICAgICAgYWxpZ25FbGVtZW50ID0gdGhpcy5wb3NpdGlvbkFsaWdubWVudHNbcG9zaXRpb25dW2FsaWduXTtcbiAgICAgIGlmICghYWxpZ25FbGVtZW50KVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1hcCA9IHtcbiAgICAgIHNlcmllc1R5cGU6IFwiYXJpYUxhYmVsRmluYW5jaWFsQ2hhcnRzXCIsXG4gICAgICBhbm5vdGF0aW9uczogXCJhcmlhTGFiZWxGaW5hbmNpYWxDaGFydHNcIixcbiAgICAgIGFubm90YXRpb25PcHRpb25zOiBcImFyaWFMYWJlbEFubm90YXRpb25PcHRpb25zVG9vbGJhclwiLFxuICAgICAgcmFuZ2VzOiBcImFyaWFMYWJlbFJhbmdlc1Rvb2xiYXJcIixcbiAgICAgIHpvb206IFwiYXJpYUxhYmVsWm9vbVRvb2xiYXJcIlxuICAgIH07XG4gICAgYWxpZ25FbGVtZW50LmFyaWFMYWJlbCA9IHRoaXMuY3R4LmxvY2FsZU1hbmFnZXIudChtYXBbZ3JvdXBdKTtcbiAgfVxuICBleHBhbmRCdXR0b25Db25maWcoYnV0dG9uLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMucm9sZSAhPT0gXCJzd2l0Y2hcIiB8fCBidXR0b24uYXJpYUNoZWNrZWQgIT09IFwidHJ1ZVwiIHx8IG9wdGlvbnMuY2hlY2tlZE92ZXJyaWRlcyA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgcmV0dXJuIHtcbiAgICAgIGljb246IG9wdGlvbnMuY2hlY2tlZE92ZXJyaWRlcy5pY29uID8/IG9wdGlvbnMuaWNvbixcbiAgICAgIGxhYmVsOiBvcHRpb25zLmNoZWNrZWRPdmVycmlkZXMubGFiZWwgPz8gb3B0aW9ucy5sYWJlbCxcbiAgICAgIGFyaWFMYWJlbDogb3B0aW9ucy5jaGVja2VkT3ZlcnJpZGVzLmFyaWFMYWJlbCA/PyBvcHRpb25zLmFyaWFMYWJlbCxcbiAgICAgIHRvb2x0aXA6IG9wdGlvbnMuY2hlY2tlZE92ZXJyaWRlcy50b29sdGlwID8/IG9wdGlvbnMudG9vbHRpcFxuICAgIH07XG4gIH1cbiAgdXBkYXRlQnV0dG9uKGJ1dHRvbiwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgZG9tTWFuYWdlciwgbG9jYWxlTWFuYWdlciB9ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgeyBpY29uLCBsYWJlbCwgYXJpYUxhYmVsLCB0b29sdGlwIH0gPSB0aGlzLmV4cGFuZEJ1dHRvbkNvbmZpZyhidXR0b24sIG9wdGlvbnMpO1xuICAgIGlmICh0b29sdGlwKSB7XG4gICAgICBidXR0b24udGl0bGUgPSBsb2NhbGVNYW5hZ2VyLnQodG9vbHRpcCk7XG4gICAgfVxuICAgIGxldCBpbm5lciA9IFwiXCI7XG4gICAgaWYgKGljb24gIT0gbnVsbCkge1xuICAgICAgaW5uZXIgPSBgPHNwYW4gY2xhc3M9XCIke2RvbU1hbmFnZXIuZ2V0SWNvbkNsYXNzTmFtZXMoaWNvbil9ICR7ZWxlbWVudHMuaWNvbn1cIj48L3NwYW4+YDtcbiAgICB9XG4gICAgaWYgKGxhYmVsICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHRsYWJlbCA9IGxvY2FsZU1hbmFnZXIudChsYWJlbCk7XG4gICAgICBpbm5lciA9IGAke2lubmVyfTxzcGFuIGNsYXNzPVwiJHtlbGVtZW50cy5sYWJlbH1cIj4ke3RsYWJlbH08L3NwYW4+YDtcbiAgICB9XG4gICAgYnV0dG9uLmlubmVySFRNTCA9IGlubmVyO1xuICAgIGJ1dHRvbi5jbGFzc0xpc3QudG9nZ2xlKG1vZGlmaWVycy5idXR0b24uZmlsbFZpc2libGUsIG9wdGlvbnMuZmlsbCAhPSBudWxsKTtcbiAgICBidXR0b24uc3R5bGUuc2V0UHJvcGVydHkoXCItLWZpbGxcIiwgb3B0aW9ucy5maWxsID8/IG51bGwpO1xuICAgIGNvbnN0IHN0cm9rZVdpZHRoVmlzaWJsZSA9IG9wdGlvbnMuc3Ryb2tlV2lkdGggIT0gbnVsbDtcbiAgICBidXR0b24uY2xhc3NMaXN0LnRvZ2dsZShtb2RpZmllcnMuYnV0dG9uLnN0cm9rZVdpZHRoVmlzaWJsZSwgc3Ryb2tlV2lkdGhWaXNpYmxlKTtcbiAgICBidXR0b24uc3R5bGUuc2V0UHJvcGVydHkoXCItLXN0cm9rZVdpZHRoXCIsIHN0cm9rZVdpZHRoVmlzaWJsZSA/IGAke29wdGlvbnMuc3Ryb2tlV2lkdGh9cHhgIDogbnVsbCk7XG4gICAgY29uc3QgdEFyaWFMYWJlbCA9IGFyaWFMYWJlbCA/IHRoaXMuY3R4LmxvY2FsZU1hbmFnZXIudChhcmlhTGFiZWwpIDogdm9pZCAwO1xuICAgIHNldEF0dHJpYnV0ZShidXR0b24sIFwiYXJpYS1sYWJlbFwiLCB0QXJpYUxhYmVsKTtcbiAgfVxuICBvbkJ1dHRvblByZXNzKGV2ZW50LCBidXR0b24sIGdyb3VwLCBpZCwgdmFsdWUpIHtcbiAgICB0aGlzLmN0eC50b29sYmFyTWFuYWdlci5wcmVzc0J1dHRvbihncm91cCwgdGhpcy5idXR0b25JZCh7IGlkLCB2YWx1ZSB9KSwgdmFsdWUsIHRoaXMuYnV0dG9uUmVjdChidXR0b24pLCBldmVudCk7XG4gIH1cbiAgb25EcmFnU3RhcnQoZXZlbnQsIGJ1dHRvbiwgZ3JvdXApIHtcbiAgICBjb25zdCBlbGVtZW50MiA9IHRoaXMuZWxlbWVudHNbXCJmbG9hdGluZ1wiIC8qIEZsb2F0aW5nICovXTtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIHRoaXMuZHJhZ1N0YXRlID0ge1xuICAgICAgY2xpZW50OiBWZWMyLmZyb20oZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSksXG4gICAgICBwb3NpdGlvbjogVmVjMi5mcm9tKFxuICAgICAgICBOdW1iZXIoZWxlbWVudDIuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcImxlZnRcIikucmVwbGFjZShcInB4XCIsIFwiXCIpKSxcbiAgICAgICAgTnVtYmVyKGVsZW1lbnQyLnN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCJ0b3BcIikucmVwbGFjZShcInB4XCIsIFwiXCIpKVxuICAgICAgKSxcbiAgICAgIGRldGFjaGVkOiB0cnVlXG4gICAgfTtcbiAgICBidXR0b24uY2xhc3NMaXN0LnRvZ2dsZShtb2RpZmllcnMuYnV0dG9uLmRyYWdnaW5nLCB0cnVlKTtcbiAgICBjb25zdCBvbkRyYWcgPSAoZSkgPT4gdGhpcy5vbkRyYWcoZSwgZ3JvdXApO1xuICAgIGNvbnN0IG9uRHJhZ0VuZCA9ICgpID0+IHtcbiAgICAgIGJ1dHRvbi5jbGFzc0xpc3QudG9nZ2xlKG1vZGlmaWVycy5idXR0b24uZHJhZ2dpbmcsIGZhbHNlKTtcbiAgICAgIHdpbmRvdzIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBvbkRyYWcpO1xuICAgIH07XG4gICAgY29uc3Qgd2luZG93MiA9IGdldFdpbmRvdygpO1xuICAgIHdpbmRvdzIuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBvbkRyYWcpO1xuICAgIHdpbmRvdzIuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgb25EcmFnRW5kLCB7XG4gICAgICBvbmNlOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5jdHgudG9vbGJhck1hbmFnZXIuZ3JvdXBNb3ZlZChncm91cCk7XG4gIH1cbiAgb25EcmFnKGV2ZW50LCBncm91cCkge1xuICAgIGNvbnN0IHsgZWxlbWVudHM6IGVsZW1lbnRzMiwgZHJhZ1N0YXRlIH0gPSB0aGlzO1xuICAgIGNvbnN0IGVsZW1lbnQyID0gZWxlbWVudHMyW1wiZmxvYXRpbmdcIiAvKiBGbG9hdGluZyAqL107XG4gICAgY29uc3QgeyBvZmZzZXRXaWR0aDogd2lkdGgyLCBvZmZzZXRIZWlnaHQ6IGhlaWdodDIgfSA9IGVsZW1lbnQyO1xuICAgIGNvbnN0IG9mZnNldDQgPSBWZWMyLnN1YihWZWMyLmZyb20oZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSksIGRyYWdTdGF0ZS5jbGllbnQpO1xuICAgIGNvbnN0IHBvc2l0aW9uID0gVmVjMi5hZGQoZHJhZ1N0YXRlLnBvc2l0aW9uLCBvZmZzZXQ0KTtcbiAgICBjb25zdCBncm91cEJCb3ggPSBuZXcgQkJveChwb3NpdGlvbi54LCBwb3NpdGlvbi55LCB3aWR0aDIsIGhlaWdodDIpO1xuICAgIHRoaXMucG9zaXRpb25Hcm91cChlbGVtZW50MiwgZ3JvdXAsIGdyb3VwQkJveCk7XG4gIH1cbiAgYnV0dG9uSWQoYnV0dG9uKSB7XG4gICAgY29uc3QgeyBpZCwgdmFsdWUsIGxhYmVsIH0gPSBidXR0b247XG4gICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBpZDtcbiAgICB9IGVsc2UgaWYgKHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGxhYmVsID8/IFwiXCI7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBPYnNlcnZlQ2hhbmdlcygodGFyZ2V0KSA9PiB7XG4gICAgdGFyZ2V0LnByb2Nlc3NQZW5kaW5nRXZlbnRzKCk7XG4gICAgdGFyZ2V0LnRvZ2dsZVZpc2liaWxpdGllcygpO1xuICB9KSxcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIFRvb2xiYXIucHJvdG90eXBlLCBcImVuYWJsZWRcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Rvb2xiYXIvdG9vbGJhck1vZHVsZS50c1xudmFyIERBWSA9IDFlMyAqIDYwICogNjAgKiAyNDtcbnZhciBNT05USCA9IERBWSAqIDMwO1xudmFyIFlFQVIgPSBEQVkgKiAzNjU7XG52YXIgc2VyaWVzVHlwZSA9IHtcbiAgZW5hYmxlZDogZmFsc2UsXG4gIHBvc2l0aW9uOiBcImxlZnRcIixcbiAgYWxpZ246IFwic3RhcnRcIixcbiAgYnV0dG9uczogW1xuICAgIHtcbiAgICAgIHRvb2x0aXA6IFwidG9vbGJhclNlcmllc1R5cGVEcm9wZG93blwiLFxuICAgICAgdmFsdWU6IFwidHlwZVwiLFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgaGFzcG9wdXA6IHRydWVcbiAgICB9XG4gIF1cbn07XG52YXIgYW5ub3RhdGlvbnMgPSB7XG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBvc2l0aW9uOiBcImxlZnRcIixcbiAgYWxpZ246IFwic3RhcnRcIixcbiAgYnV0dG9uczogW1xuICAgIHtcbiAgICAgIGljb246IFwidHJlbmQtbGluZS1kcmF3aW5nXCIsXG4gICAgICB0b29sdGlwOiBcInRvb2xiYXJBbm5vdGF0aW9uc0xpbmVBbm5vdGF0aW9uc1wiLFxuICAgICAgdmFsdWU6IFwibGluZS1tZW51XCIsXG4gICAgICBzZWN0aW9uOiBcImxpbmUtYW5ub3RhdGlvbnNcIixcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgIGhhc3BvcHVwOiB0cnVlXG4gICAgfSxcbiAgICB7XG4gICAgICBpY29uOiBcInRleHQtYW5ub3RhdGlvblwiLFxuICAgICAgdG9vbHRpcDogXCJ0b29sYmFyQW5ub3RhdGlvbnNUZXh0QW5ub3RhdGlvbnNcIixcbiAgICAgIHZhbHVlOiBcInRleHQtbWVudVwiLFxuICAgICAgc2VjdGlvbjogXCJ0ZXh0LWFubm90YXRpb25zXCIsXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICBoYXNwb3B1cDogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgaWNvbjogXCJhcnJvdy1kcmF3aW5nXCIsXG4gICAgICB0b29sdGlwOiBcInRvb2xiYXJBbm5vdGF0aW9uc1NoYXBlQW5ub3RhdGlvbnNcIixcbiAgICAgIHZhbHVlOiBcInNoYXBlLW1lbnVcIixcbiAgICAgIHNlY3Rpb246IFwic2hhcGUtYW5ub3RhdGlvbnNcIixcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgIGhhc3BvcHVwOiB0cnVlXG4gICAgfSxcbiAgICB7XG4gICAgICBpY29uOiBcIm1lYXN1cmVyLWRyYXdpbmdcIixcbiAgICAgIHRvb2x0aXA6IFwidG9vbGJhckFubm90YXRpb25zTWVhc3VyZXJBbm5vdGF0aW9uc1wiLFxuICAgICAgdmFsdWU6IFwibWVhc3VyZXItbWVudVwiLFxuICAgICAgc2VjdGlvbjogXCJtZWFzdXJlLWFubm90YXRpb25zXCIsXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICBoYXNwb3B1cDogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgaWNvbjogXCJkZWxldGVcIixcbiAgICAgIHRvb2x0aXA6IFwidG9vbGJhckFubm90YXRpb25zQ2xlYXJBbGxcIixcbiAgICAgIHZhbHVlOiBcImNsZWFyXCIsXG4gICAgICBzZWN0aW9uOiBcInRvb2xzXCJcbiAgICB9XG4gIF1cbn07XG52YXIgYW5ub3RhdGlvbk9wdGlvbnMgPSB7XG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBvc2l0aW9uOiBcImZsb2F0aW5nXCIsXG4gIGFsaWduOiBcInN0YXJ0XCIsXG4gIGRyYWdnYWJsZTogdHJ1ZSxcbiAgYnV0dG9uczogW1xuICAgIHtcbiAgICAgIGljb246IFwidGV4dC1hbm5vdGF0aW9uXCIsXG4gICAgICB0b29sdGlwOiBcInRvb2xiYXJBbm5vdGF0aW9uc1RleHRDb2xvclwiLFxuICAgICAgdmFsdWU6IFwidGV4dC1jb2xvclwiLFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgaGFzcG9wdXA6IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgIGljb246IFwibGluZS1jb2xvclwiLFxuICAgICAgdG9vbHRpcDogXCJ0b29sYmFyQW5ub3RhdGlvbnNMaW5lQ29sb3JcIixcbiAgICAgIHZhbHVlOiBcImxpbmUtY29sb3JcIixcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgIGhhc3BvcHVwOiB0cnVlXG4gICAgfSxcbiAgICB7XG4gICAgICBpY29uOiBcImZpbGwtY29sb3JcIixcbiAgICAgIHRvb2x0aXA6IFwidG9vbGJhckFubm90YXRpb25zRmlsbENvbG9yXCIsXG4gICAgICB2YWx1ZTogXCJmaWxsLWNvbG9yXCIsXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICBoYXNwb3B1cDogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgdG9vbHRpcDogXCJ0b29sYmFyQW5ub3RhdGlvbnNUZXh0U2l6ZVwiLFxuICAgICAgdmFsdWU6IFwidGV4dC1zaXplXCIsXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICBoYXNwb3B1cDogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgdG9vbHRpcDogXCJ0b29sYmFyQW5ub3RhdGlvbnNMaW5lU3Ryb2tlV2lkdGhcIixcbiAgICAgIHZhbHVlOiBcImxpbmUtc3Ryb2tlLXdpZHRoXCIsXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICBoYXNwb3B1cDogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgaWNvbjogXCJsaW5lLXN0eWxlLXNvbGlkXCIsXG4gICAgICB0b29sdGlwOiBcInRvb2xiYXJBbm5vdGF0aW9uc0xpbmVTdHlsZVwiLFxuICAgICAgdmFsdWU6IFwibGluZS1zdHlsZS10eXBlXCIsXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICBoYXNwb3B1cDogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgaWNvbjogXCJzZXR0aW5nc1wiLFxuICAgICAgdG9vbHRpcDogXCJ0b29sYmFyQW5ub3RhdGlvbnNTZXR0aW5nc1wiLFxuICAgICAgdmFsdWU6IFwic2V0dGluZ3NcIixcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgIGhhc3BvcHVwOiB0cnVlXG4gICAgfSxcbiAgICB7XG4gICAgICByb2xlOiBcInN3aXRjaFwiLFxuICAgICAgaWNvbjogXCJ1bmxvY2tlZFwiLFxuICAgICAgdG9vbHRpcDogXCJ0b29sYmFyQW5ub3RhdGlvbnNMb2NrXCIsXG4gICAgICBhcmlhTGFiZWw6IFwidG9vbGJhckFubm90YXRpb25zTG9ja1wiLFxuICAgICAgY2hlY2tlZE92ZXJyaWRlczoge1xuICAgICAgICBpY29uOiBcImxvY2tlZFwiLFxuICAgICAgICB0b29sdGlwOiBcInRvb2xiYXJBbm5vdGF0aW9uc1VubG9ja1wiXG4gICAgICB9LFxuICAgICAgdmFsdWU6IFwibG9ja1wiXG4gICAgfSxcbiAgICB7XG4gICAgICBpY29uOiBcImRlbGV0ZVwiLFxuICAgICAgdG9vbHRpcDogXCJ0b29sYmFyQW5ub3RhdGlvbnNEZWxldGVcIixcbiAgICAgIHZhbHVlOiBcImRlbGV0ZVwiXG4gICAgfVxuICBdXG59O1xudmFyIHJhbmdlcyA9IHtcbiAgZW5hYmxlZDogZmFsc2UsXG4gIHBvc2l0aW9uOiBERUZBVUxUX1RPT0xCQVJfUE9TSVRJT04sXG4gIGFsaWduOiBcInN0YXJ0XCIsXG4gIGJ1dHRvbnM6IFtcbiAgICB7XG4gICAgICBsYWJlbDogXCJ0b29sYmFyUmFuZ2UxTW9udGhcIixcbiAgICAgIGFyaWFMYWJlbDogXCJ0b29sYmFyUmFuZ2UxTW9udGhBcmlhXCIsXG4gICAgICB2YWx1ZTogTU9OVEhcbiAgICB9LFxuICAgIHtcbiAgICAgIGxhYmVsOiBcInRvb2xiYXJSYW5nZTNNb250aHNcIixcbiAgICAgIGFyaWFMYWJlbDogXCJ0b29sYmFyUmFuZ2UzTW9udGhzQXJpYVwiLFxuICAgICAgdmFsdWU6IDMgKiBNT05USFxuICAgIH0sXG4gICAge1xuICAgICAgbGFiZWw6IFwidG9vbGJhclJhbmdlNk1vbnRoc1wiLFxuICAgICAgYXJpYUxhYmVsOiBcInRvb2xiYXJSYW5nZTZNb250aHNBcmlhXCIsXG4gICAgICB2YWx1ZTogNiAqIE1PTlRIXG4gICAgfSxcbiAgICB7XG4gICAgICBsYWJlbDogXCJ0b29sYmFyUmFuZ2VZZWFyVG9EYXRlXCIsXG4gICAgICBhcmlhTGFiZWw6IFwidG9vbGJhclJhbmdlWWVhclRvRGF0ZUFyaWFcIixcbiAgICAgIHZhbHVlOiAoX3N0YXJ0LCBlbmQyKSA9PiBbKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZShgJHtuZXcgRGF0ZShlbmQyKS5nZXRGdWxsWWVhcigpfS0wMS0wMWApKS5nZXRUaW1lKCksIGVuZDJdLFxuICAgICAgaWQ6IFwieWVhci10by1kYXRlXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIGxhYmVsOiBcInRvb2xiYXJSYW5nZTFZZWFyXCIsXG4gICAgICBhcmlhTGFiZWw6IFwidG9vbGJhclJhbmdlMVllYXJBcmlhXCIsXG4gICAgICB2YWx1ZTogWUVBUlxuICAgIH0sXG4gICAge1xuICAgICAgbGFiZWw6IFwidG9vbGJhclJhbmdlQWxsXCIsXG4gICAgICBhcmlhTGFiZWw6IFwidG9vbGJhclJhbmdlQWxsQXJpYVwiLFxuICAgICAgdmFsdWU6IChzdGFydDIsIGVuZDIpID0+IFtzdGFydDIsIGVuZDJdLFxuICAgICAgaWQ6IFwiYWxsXCJcbiAgICB9XG4gIF1cbn07XG52YXIgem9vbSA9IHtcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcG9zaXRpb246IFwidG9wXCIsXG4gIGFsaWduOiBcImVuZFwiLFxuICBidXR0b25zOiBbXG4gICAge1xuICAgICAgaWNvbjogXCJ6b29tLW91dFwiLFxuICAgICAgdG9vbHRpcDogXCJ0b29sYmFyWm9vbVpvb21PdXRcIixcbiAgICAgIHZhbHVlOiBcInpvb20tb3V0XCJcbiAgICB9LFxuICAgIHtcbiAgICAgIGljb246IFwiem9vbS1pblwiLFxuICAgICAgdG9vbHRpcDogXCJ0b29sYmFyWm9vbVpvb21JblwiLFxuICAgICAgdmFsdWU6IFwiem9vbS1pblwiXG4gICAgfSxcbiAgICB7XG4gICAgICBpY29uOiBcInBhbi1sZWZ0XCIsXG4gICAgICB0b29sdGlwOiBcInRvb2xiYXJab29tUGFuTGVmdFwiLFxuICAgICAgdmFsdWU6IFwicGFuLWxlZnRcIlxuICAgIH0sXG4gICAge1xuICAgICAgaWNvbjogXCJwYW4tcmlnaHRcIixcbiAgICAgIHRvb2x0aXA6IFwidG9vbGJhclpvb21QYW5SaWdodFwiLFxuICAgICAgdmFsdWU6IFwicGFuLXJpZ2h0XCJcbiAgICB9LFxuICAgIHtcbiAgICAgIGljb246IFwicGFuLXN0YXJ0XCIsXG4gICAgICB0b29sdGlwOiBcInRvb2xiYXJab29tUGFuU3RhcnRcIixcbiAgICAgIHZhbHVlOiBcInBhbi1zdGFydFwiXG4gICAgfSxcbiAgICB7XG4gICAgICBpY29uOiBcInBhbi1lbmRcIixcbiAgICAgIHRvb2x0aXA6IFwidG9vbGJhclpvb21QYW5FbmRcIixcbiAgICAgIHZhbHVlOiBcInBhbi1lbmRcIlxuICAgIH0sXG4gICAge1xuICAgICAgaWNvbjogXCJyZXNldFwiLFxuICAgICAgdG9vbHRpcDogXCJ0b29sYmFyWm9vbVJlc2V0XCIsXG4gICAgICB2YWx1ZTogXCJyZXNldFwiXG4gICAgfVxuICBdXG59O1xudmFyIFRvb2xiYXJNb2R1bGUgPSB7XG4gIHR5cGU6IFwicm9vdFwiLFxuICBvcHRpb25zS2V5OiBcInRvb2xiYXJcIixcbiAgcGFja2FnZVR5cGU6IFwiY29tbXVuaXR5XCIsXG4gIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiXSxcbiAgbW9kdWxlRmFjdG9yeTogKGN0eCkgPT4gbmV3IFRvb2xiYXIoY3R4KSxcbiAgdGhlbWVUZW1wbGF0ZToge1xuICAgIHRvb2xiYXI6IHtcbiAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICBzZXJpZXNUeXBlLFxuICAgICAgYW5ub3RhdGlvbnMsXG4gICAgICBhbm5vdGF0aW9uT3B0aW9ucyxcbiAgICAgIHJhbmdlcyxcbiAgICAgIHpvb21cbiAgICB9XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2ZhY3RvcnkvcmVnaXN0ZXJJbmJ1aWx0TW9kdWxlcy50c1xuZnVuY3Rpb24gcmVnaXN0ZXJJbmJ1aWx0TW9kdWxlcygpIHtcbiAgbW9kdWxlUmVnaXN0cnkucmVnaXN0ZXIoXG4gICAgQmFja2dyb3VuZE1vZHVsZSxcbiAgICBDb21tdW5pdHlMZWdlbmRNb2R1bGUsXG4gICAgTG9jYWxlTW9kdWxlLFxuICAgIE5hdmlnYXRvck1vZHVsZSxcbiAgICBUb29sYmFyTW9kdWxlLFxuICAgIEFyZWFTZXJpZXNNb2R1bGUsXG4gICAgQmFyU2VyaWVzTW9kdWxlLFxuICAgIEJ1YmJsZVNlcmllc01vZHVsZSxcbiAgICBMaW5lU2VyaWVzTW9kdWxlLFxuICAgIFNjYXR0ZXJTZXJpZXNNb2R1bGUsXG4gICAgRG9udXRTZXJpZXNNb2R1bGUsXG4gICAgUGllU2VyaWVzTW9kdWxlLFxuICAgIEhpc3RvZ3JhbVNlcmllc01vZHVsZVxuICApO1xuICBmb3IgKGNvbnN0IEF4aXNDb25zdHJ1Y3RvciBvZiBbTnVtYmVyQXhpcywgQ2F0ZWdvcnlBeGlzLCBUaW1lQXhpcywgR3JvdXBlZENhdGVnb3J5QXhpcywgTG9nQXhpc10pIHtcbiAgICBheGlzUmVnaXN0cnkucmVnaXN0ZXIoQXhpc0NvbnN0cnVjdG9yLnR5cGUsIHtcbiAgICAgIG1vZHVsZUZhY3Rvcnk6IChjdHgpID0+IG5ldyBBeGlzQ29uc3RydWN0b3IoY3R4KSxcbiAgICAgIGhpZGRlbjogQXhpc0NvbnN0cnVjdG9yID09PSBHcm91cGVkQ2F0ZWdvcnlBeGlzXG4gICAgfSk7XG4gIH1cbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvZmFjdG9yeS9zZXR1cE1vZHVsZXMudHNcbmZ1bmN0aW9uIHNldHVwTW9kdWxlcygpIHtcbiAgZm9yIChjb25zdCBtIG9mIG1vZHVsZVJlZ2lzdHJ5Lm1vZHVsZXMpIHtcbiAgICBpZiAobS5wYWNrYWdlVHlwZSA9PT0gXCJlbnRlcnByaXNlXCIgJiYgIXZlcmlmeUlmTW9kdWxlRXhwZWN0ZWQobSkpIHtcbiAgICAgIExvZ2dlci5lcnJvck9uY2UoXCJVbmV4cGVjdGVkIGVudGVycHJpc2UgbW9kdWxlIHJlZ2lzdGVyZWQ6IFwiICsgbS5pZGVudGlmaWVyKTtcbiAgICB9XG4gICAgaWYgKG0udHlwZSA9PT0gXCJyb290XCIgJiYgbS50aGVtZVRlbXBsYXRlKSB7XG4gICAgICBmb3IgKGNvbnN0IGNoYXJ0VHlwZTIgb2YgbS5jaGFydFR5cGVzKSB7XG4gICAgICAgIGNoYXJ0RGVmYXVsdHMuc2V0KGNoYXJ0VHlwZTIsIG0udGhlbWVUZW1wbGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtLnR5cGUgPT09IFwic2VyaWVzXCIpIHtcbiAgICAgIGlmIChtLmNoYXJ0VHlwZXMubGVuZ3RoID4gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFHIENoYXJ0cyAtIE1vZHVsZSBkZWZpbml0aW9uIGVycm9yOiAke20uaWRlbnRpZmllcn1gKTtcbiAgICAgIH1cbiAgICAgIHNlcmllc1JlZ2lzdHJ5LnJlZ2lzdGVyKG0uaWRlbnRpZmllciwgbSk7XG4gICAgfVxuICAgIGlmIChtLnR5cGUgPT09IFwic2VyaWVzLW9wdGlvblwiICYmIG0udGhlbWVUZW1wbGF0ZSkge1xuICAgICAgZm9yIChjb25zdCBzZXJpZXNUeXBlMiBvZiBtLnNlcmllc1R5cGVzKSB7XG4gICAgICAgIHNlcmllc1JlZ2lzdHJ5LnNldFRoZW1lVGVtcGxhdGUoc2VyaWVzVHlwZTIsIG0udGhlbWVUZW1wbGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtLnR5cGUgPT09IFwiYXhpcy1vcHRpb25cIiAmJiBtLnRoZW1lVGVtcGxhdGUpIHtcbiAgICAgIGZvciAoY29uc3QgYXhpc1R5cGUgb2YgbS5heGlzVHlwZXMpIHtcbiAgICAgICAgY29uc3QgYXhpc1R5cGVUaGVtZSA9IGF4aXNSZWdpc3RyeS5nZXRUaGVtZVRlbXBsYXRlKGF4aXNUeXBlKTtcbiAgICAgICAgY29uc3QgdGhlbWUgPSBtZXJnZURlZmF1bHRzKG0udGhlbWVUZW1wbGF0ZSwgYXhpc1R5cGVUaGVtZSk7XG4gICAgICAgIGF4aXNSZWdpc3RyeS5zZXRUaGVtZVRlbXBsYXRlKGF4aXNUeXBlLCB0aGVtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtLnR5cGUgPT09IFwiYXhpc1wiKSB7XG4gICAgICBheGlzUmVnaXN0cnkucmVnaXN0ZXIobS5pZGVudGlmaWVyLCBtKTtcbiAgICB9XG4gICAgaWYgKG0udHlwZSA9PT0gXCJsZWdlbmRcIikge1xuICAgICAgbGVnZW5kUmVnaXN0cnkucmVnaXN0ZXIobS5pZGVudGlmaWVyLCBtKTtcbiAgICB9XG4gIH1cbiAgaWYgKG1vZHVsZVJlZ2lzdHJ5Lmhhc0VudGVycHJpc2VNb2R1bGVzKCkpIHtcbiAgICBjb25zdCBleHBlY3RlZEJ1dFVudXNlZCA9IGdldFVudXNlZEV4cGVjdGVkTW9kdWxlcygpO1xuICAgIGlmIChleHBlY3RlZEJ1dFVudXNlZC5sZW5ndGggPiAwKSB7XG4gICAgICBMb2dnZXIuZXJyb3JPbmNlKFwiRW50ZXJwcmlzZSBtb2R1bGVzIGV4cGVjdGVkIGJ1dCBub3QgcmVnaXN0ZXJlZDogXCIsIGV4cGVjdGVkQnV0VW51c2VkKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvZmxvd1Byb3BvcnRpb25DaGFydC50c1xuZnVuY3Rpb24gaXNGbG93UHJvcG9ydGlvbihzZXJpZXMpIHtcbiAgcmV0dXJuIHNlcmllcy50eXBlID09PSBcInNhbmtleVwiIHx8IHNlcmllcy50eXBlID09PSBcImNob3JkXCI7XG59XG52YXIgRmxvd1Byb3BvcnRpb25DaGFydCA9IGNsYXNzIGV4dGVuZHMgQ2hhcnQge1xuICBnZXRDaGFydFR5cGUoKSB7XG4gICAgcmV0dXJuIFwiZmxvdy1wcm9wb3J0aW9uXCI7XG4gIH1cbiAgYXN5bmMgdXBkYXRlRGF0YSgpIHtcbiAgICBhd2FpdCBzdXBlci51cGRhdGVEYXRhKCk7XG4gICAgY29uc3QgeyBub2RlcyB9ID0gdGhpcy5nZXRPcHRpb25zKCk7XG4gICAgdGhpcy5zZXJpZXMuZm9yRWFjaCgoc2VyaWVzKSA9PiB7XG4gICAgICBpZiAoaXNGbG93UHJvcG9ydGlvbihzZXJpZXMpKSB7XG4gICAgICAgIHNlcmllcy5zZXRDaGFydE5vZGVzKG5vZGVzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBwZXJmb3JtTGF5b3V0KGN0eCkge1xuICAgIGNvbnN0IHsgc2VyaWVzUm9vdCwgYW5ub3RhdGlvblJvb3QsIGhpZ2hsaWdodFJvb3QgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBsYXlvdXRCb3ggfSA9IGN0eDtcbiAgICBjb25zdCBzZXJpZXNSZWN0ID0gbGF5b3V0Qm94LmNsb25lKCk7XG4gICAgbGF5b3V0Qm94LnNocmluayh0aGlzLnNlcmllc0FyZWEucGFkZGluZy50b0pzb24oKSk7XG4gICAgdGhpcy5zZXJpZXNSZWN0ID0gbGF5b3V0Qm94O1xuICAgIHRoaXMuYW5pbWF0aW9uUmVjdCA9IGxheW91dEJveDtcbiAgICBzZXJpZXNSb290LnZpc2libGUgPSB0aGlzLnNlcmllcy5zb21lKChzKSA9PiBzLnZpc2libGUpO1xuICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgW3Nlcmllc1Jvb3QsIGFubm90YXRpb25Sb290LCBoaWdobGlnaHRSb290XSkge1xuICAgICAgZ3JvdXAudHJhbnNsYXRpb25YID0gTWF0aC5mbG9vcihsYXlvdXRCb3gueCk7XG4gICAgICBncm91cC50cmFuc2xhdGlvblkgPSBNYXRoLmZsb29yKGxheW91dEJveC55KTtcbiAgICAgIGdyb3VwLnNldENsaXBSZWN0KHNlcmllc1JlY3QuY2xvbmUoKSk7XG4gICAgfVxuICAgIHRoaXMuY3R4LmxheW91dE1hbmFnZXIuZW1pdExheW91dENvbXBsZXRlKGN0eCwge1xuICAgICAgc2VyaWVzOiB7IHZpc2libGU6IHNlcmllc1Jvb3QudmlzaWJsZSwgcmVjdDogc2VyaWVzUmVjdCwgcGFkZGVkUmVjdDogbGF5b3V0Qm94IH1cbiAgICB9KTtcbiAgfVxufTtcbkZsb3dQcm9wb3J0aW9uQ2hhcnQuY2xhc3NOYW1lID0gXCJGbG93UHJvcG9ydGlvbkNoYXJ0XCI7XG5GbG93UHJvcG9ydGlvbkNoYXJ0LnR5cGUgPSBcImZsb3ctcHJvcG9ydGlvblwiO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9heGlzL3BvbGFyQXhpcy50c1xudmFyIFBvbGFyQXhpcyA9IGNsYXNzIGV4dGVuZHMgQXhpcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5zaGFwZSA9IFwicG9seWdvblwiO1xuICAgIHRoaXMuaW5uZXJSYWRpdXNSYXRpbyA9IDA7XG4gICAgdGhpcy5kZWZhdWx0VGlja01pblNwYWNpbmcgPSAyMDtcbiAgfVxuICBjb21wdXRlTGFiZWxzQkJveChfb3B0aW9ucywgX3Nlcmllc1JlY3QpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb21wdXRlUmFuZ2UoKSB7XG4gIH1cbiAgZ2V0QXhpc0xpbmVQb2ludHMoKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFVOSU9OKFtcInBvbHlnb25cIiwgXCJjaXJjbGVcIl0sIFwiYSBwb2xhciBheGlzIHNoYXBlXCIpKVxuXSwgUG9sYXJBeGlzLnByb3RvdHlwZSwgXCJzaGFwZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPKVxuXSwgUG9sYXJBeGlzLnByb3RvdHlwZSwgXCJpbm5lclJhZGl1c1JhdGlvXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9nYXVnZUNoYXJ0LnRzXG5mdW5jdGlvbiBpc1JhZGlhbEdhdWdlU2VyaWVzKHNlcmllcykge1xuICByZXR1cm4gc2VyaWVzLnR5cGUgPT09IFwicmFkaWFsLWdhdWdlXCI7XG59XG5mdW5jdGlvbiBpc0xpbmVhckdhdWdlU2VyaWVzKHNlcmllcykge1xuICByZXR1cm4gc2VyaWVzLnR5cGUgPT09IFwibGluZWFyLWdhdWdlXCI7XG59XG52YXIgR2F1Z2VDaGFydCA9IGNsYXNzIGV4dGVuZHMgQ2hhcnQge1xuICBnZXRDaGFydFR5cGUoKSB7XG4gICAgcmV0dXJuIFwiZ2F1Z2VcIjtcbiAgfVxuICB1cGRhdGVSYWRpYWxHYXVnZShzZXJpZXNSZWN0LCBzZXJpZXMpIHtcbiAgICBjb25zdCBhbmdsZUF4aXMgPSB0aGlzLmF4ZXMuZmluZCgoYXhpcykgPT4gYXhpcy5kaXJlY3Rpb24gPT09IFwieFwiIC8qIFggKi8pO1xuICAgIGlmICghKGFuZ2xlQXhpcyBpbnN0YW5jZW9mIFBvbGFyQXhpcykpXG4gICAgICByZXR1cm47XG4gICAgYW5nbGVBeGlzLmNvbXB1dGVSYW5nZSgpO1xuICAgIGNvbnN0IHNlcmllc1JlY3RYMCA9IHNlcmllc1JlY3QueDtcbiAgICBjb25zdCBzZXJpZXNSZWN0WDEgPSBzZXJpZXNSZWN0WDAgKyBzZXJpZXNSZWN0LndpZHRoO1xuICAgIGNvbnN0IHNlcmllc1JlY3RZMCA9IHNlcmllc1JlY3QueTtcbiAgICBjb25zdCBzZXJpZXNSZWN0WTEgPSBzZXJpZXNSZWN0WTAgKyBzZXJpZXNSZWN0LmhlaWdodDtcbiAgICBjb25zdCBbc3RhcnRBbmdsZSwgZW5kQW5nbGVdID0gYW5nbGVBeGlzLnJhbmdlO1xuICAgIGNvbnN0IHN3ZWVwQW5nbGUgPSBub3JtYWxpemVBbmdsZTM2MEluY2x1c2l2ZShlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpO1xuICAgIGNvbnN0IGxhcmdlclRoYW5IYWxmID0gc3dlZXBBbmdsZSA+IE1hdGguUEk7XG4gICAgY29uc3QgY29udGFpbnNUb3AgPSBsYXJnZXJUaGFuSGFsZiB8fCBpc0JldHdlZW5BbmdsZXMoMS41ICogTWF0aC5QSSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpO1xuICAgIGNvbnN0IGNvbnRhaW5zUmlnaHQgPSBsYXJnZXJUaGFuSGFsZiB8fCBpc0JldHdlZW5BbmdsZXMoMCAqIE1hdGguUEksIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKTtcbiAgICBjb25zdCBjb250YWluc0JvdHRvbSA9IGxhcmdlclRoYW5IYWxmIHx8IGlzQmV0d2VlbkFuZ2xlcygwLjUgKiBNYXRoLlBJLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSk7XG4gICAgY29uc3QgY29udGFpbnNMZWZ0ID0gbGFyZ2VyVGhhbkhhbGYgfHwgaXNCZXR3ZWVuQW5nbGVzKDEgKiBNYXRoLlBJLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSk7XG4gICAgbGV0IHRleHRBbGlnbjtcbiAgICBpZiAoY29udGFpbnNMZWZ0ICYmICFjb250YWluc1JpZ2h0KSB7XG4gICAgICB0ZXh0QWxpZ24gPSBcInJpZ2h0XCI7XG4gICAgfSBlbHNlIGlmICghY29udGFpbnNMZWZ0ICYmIGNvbnRhaW5zUmlnaHQpIHtcbiAgICAgIHRleHRBbGlnbiA9IFwibGVmdFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICB0ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgIH1cbiAgICBsZXQgdmVydGljYWxBbGlnbjtcbiAgICBpZiAoY29udGFpbnNUb3AgJiYgIWNvbnRhaW5zQm90dG9tKSB7XG4gICAgICB2ZXJ0aWNhbEFsaWduID0gXCJib3R0b21cIjtcbiAgICB9IGVsc2UgaWYgKCFjb250YWluc1RvcCAmJiBjb250YWluc0JvdHRvbSkge1xuICAgICAgdmVydGljYWxBbGlnbiA9IFwidG9wXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZlcnRpY2FsQWxpZ24gPSBcIm1pZGRsZVwiO1xuICAgIH1cbiAgICBjb25zdCB1bml0Qm94ID0gc2VjdG9yQm94KHtcbiAgICAgIHN0YXJ0QW5nbGUsXG4gICAgICBlbmRBbmdsZSxcbiAgICAgIGlubmVyUmFkaXVzOiAwLFxuICAgICAgb3V0ZXJSYWRpdXM6IDAuNVxuICAgIH0pO1xuICAgIGNvbnN0IGNlbnRlclhPZmZzZXQgPSAtKHVuaXRCb3gueCArIHVuaXRCb3gud2lkdGggLyAyKSAqIDI7XG4gICAgY29uc3QgY2VudGVyWU9mZnNldCA9IC0odW5pdEJveC55ICsgdW5pdEJveC5oZWlnaHQgLyAyKSAqIDI7XG4gICAgY29uc3QgeyBtaW5pbXVtUmFkaXVzID0gMCwgbWF4aW11bVJhZGl1cyB9ID0gc2VyaWVzO1xuICAgIGNvbnN0IHJhZGl1c0JvdW5kcyA9IE1hdGgubWF4KFxuICAgICAgMC41ICogTWF0aC5taW4oc2VyaWVzUmVjdC53aWR0aCAvIHVuaXRCb3gud2lkdGgsIHNlcmllc1JlY3QuaGVpZ2h0IC8gdW5pdEJveC5oZWlnaHQpLFxuICAgICAgLy8gc2VyaWVzUmVjdCBtYXkgaGF2ZSBuZWdhdGl2ZSBzaXplXG4gICAgICAwXG4gICAgKTtcbiAgICBsZXQgcmFkaXVzID0gTWF0aC5taW4obWF4aW11bVJhZGl1cyA/PyBJbmZpbml0eSwgTWF0aC5tYXgocmFkaXVzQm91bmRzLCBtaW5pbXVtUmFkaXVzID8/IDApKTtcbiAgICBjb25zdCBNQVhfSVRFUkFUSU9OUyA9IDg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNQVhfSVRFUkFUSU9OUzsgaSArPSAxKSB7XG4gICAgICBjb25zdCBpc0ZpbmFsSXRlcmF0aW9uID0gcmFkaXVzIDw9IG1pbmltdW1SYWRpdXMgfHwgaSA9PT0gTUFYX0lURVJBVElPTlMgLSAxO1xuICAgICAgY29uc3QgY2VudGVyWCA9IHNlcmllc1JlY3QueCArIHNlcmllc1JlY3Qud2lkdGggLyAyICsgY2VudGVyWE9mZnNldCAqIHJhZGl1cztcbiAgICAgIGNvbnN0IGNlbnRlclkgPSBzZXJpZXNSZWN0LnkgKyBzZXJpZXNSZWN0LmhlaWdodCAvIDIgKyBjZW50ZXJZT2Zmc2V0ICogcmFkaXVzO1xuICAgICAgYW5nbGVBeGlzLnRyYW5zbGF0aW9uLnggPSBjZW50ZXJYO1xuICAgICAgYW5nbGVBeGlzLnRyYW5zbGF0aW9uLnkgPSBjZW50ZXJZO1xuICAgICAgYW5nbGVBeGlzLmdyaWRMZW5ndGggPSByYWRpdXM7XG4gICAgICBhbmdsZUF4aXMuY2FsY3VsYXRlTGF5b3V0KCk7XG4gICAgICBjb25zdCBiYm94ID0gYW5nbGVBeGlzLmNvbXB1dGVMYWJlbHNCQm94KHsgaGlkZVdoZW5OZWNlc3Nhcnk6IGlzRmluYWxJdGVyYXRpb24gfSwgc2VyaWVzUmVjdCk7XG4gICAgICBpZiAoaXNGaW5hbEl0ZXJhdGlvbilcbiAgICAgICAgYnJlYWs7XG4gICAgICBsZXQgc2hyaW5rRGVsdGEgPSAwO1xuICAgICAgaWYgKGJib3ggIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBiYm94WDAgPSBiYm94LnggKyBjZW50ZXJYO1xuICAgICAgICBjb25zdCBiYm94WDEgPSBiYm94WDAgKyBiYm94LndpZHRoO1xuICAgICAgICBjb25zdCBiYm94WTAgPSBiYm94LnkgKyBjZW50ZXJZO1xuICAgICAgICBjb25zdCBiYm94WTEgPSBiYm94WTAgKyBiYm94LmhlaWdodDtcbiAgICAgICAgc2hyaW5rRGVsdGEgPSBNYXRoLm1heChcbiAgICAgICAgICBzZXJpZXNSZWN0WTAgLSBiYm94WTAsXG4gICAgICAgICAgc2VyaWVzUmVjdFgwIC0gYmJveFgwLFxuICAgICAgICAgIGJib3hZMSAtIHNlcmllc1JlY3RZMSxcbiAgICAgICAgICBiYm94WDEgLSBzZXJpZXNSZWN0WDEsXG4gICAgICAgICAgMFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHNocmlua0RlbHRhID4gMCkge1xuICAgICAgICByYWRpdXMgPSBNYXRoLm1heChyYWRpdXMgLSBzaHJpbmtEZWx0YSwgbWluaW11bVJhZGl1cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgYW5nbGVBeGlzLnRyYW5zbGF0aW9uLnggPSBzZXJpZXNSZWN0LnggKyBzZXJpZXNSZWN0LndpZHRoIC8gMiArIGNlbnRlclhPZmZzZXQgKiByYWRpdXM7XG4gICAgYW5nbGVBeGlzLnRyYW5zbGF0aW9uLnkgPSBzZXJpZXNSZWN0LnkgKyBzZXJpZXNSZWN0LmhlaWdodCAvIDIgKyBjZW50ZXJZT2Zmc2V0ICogcmFkaXVzO1xuICAgIHNlcmllcy5jZW50ZXJYID0gc2VyaWVzUmVjdC53aWR0aCAvIDIgKyBjZW50ZXJYT2Zmc2V0ICogcmFkaXVzO1xuICAgIHNlcmllcy5jZW50ZXJZID0gc2VyaWVzUmVjdC5oZWlnaHQgLyAyICsgY2VudGVyWU9mZnNldCAqIHJhZGl1cztcbiAgICBzZXJpZXMucmFkaXVzID0gcmFkaXVzO1xuICAgIHNlcmllcy50ZXh0QWxpZ24gPSB0ZXh0QWxpZ247XG4gICAgc2VyaWVzLnZlcnRpY2FsQWxpZ24gPSB2ZXJ0aWNhbEFsaWduO1xuICAgIGlmIChyYWRpdXMgPT09IDAgfHwgcmFkaXVzID4gcmFkaXVzQm91bmRzKSB7XG4gICAgICBMb2dnZXIud2Fybk9uY2UoXCJUaGVyZSB3YXMgaW5zdWZmaWNpZW50IHNwYWNlIHRvIGRpc3BsYXkgdGhlIFJhZGlhbCBHYXVnZS5cIik7XG4gICAgfVxuICB9XG4gIHVwZGF0ZUxpbmVhckdhdWdlKHNlcmllc1JlY3QsIHNlcmllcykge1xuICAgIGNvbnN0IHhBeGlzID0gdGhpcy5heGVzLmZpbmQoKGF4aXMpID0+IGF4aXMuZGlyZWN0aW9uID09PSBcInhcIiAvKiBYICovKTtcbiAgICBjb25zdCB5QXhpcyA9IHRoaXMuYXhlcy5maW5kKChheGlzKSA9PiBheGlzLmRpcmVjdGlvbiA9PT0gXCJ5XCIgLyogWSAqLyk7XG4gICAgaWYgKCEoeEF4aXMgaW5zdGFuY2VvZiBDYXJ0ZXNpYW5BeGlzKSlcbiAgICAgIHJldHVybiBzZXJpZXNSZWN0O1xuICAgIGlmICghKHlBeGlzIGluc3RhbmNlb2YgQ2FydGVzaWFuQXhpcykpXG4gICAgICByZXR1cm4gc2VyaWVzUmVjdDtcbiAgICBjb25zdCB7IGhvcml6b250YWwsIHRoaWNrbmVzcyB9ID0gc2VyaWVzO1xuICAgIGxldCBob3Jpem9udGFsSW5zZXQgPSAwO1xuICAgIGxldCB2ZXJ0aWNhbEluc2V0ID0gMDtcbiAgICBjb25zdCBzY2FsZTIgPSBuZXcgTGluZWFyU2NhbGUoKTtcbiAgICBzY2FsZTIuZG9tYWluID0gWzAsIDEwMF07XG4gICAgc2NhbGUyLnJhbmdlID0gaG9yaXpvbnRhbCA/IHhBeGlzLnJhbmdlIDogeUF4aXMucmFuZ2U7XG4gICAgY29uc3QgdGlja3MgPSBzY2FsZTIudGlja3MoKTtcbiAgICBpZiAoaG9yaXpvbnRhbCkge1xuICAgICAgaG9yaXpvbnRhbEluc2V0ID0gc2VyaWVzLmNvbXB1dGVJbnNldChcInhcIiAvKiBYICovLCB0aWNrcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZlcnRpY2FsSW5zZXQgPSBzZXJpZXMuY29tcHV0ZUluc2V0KFwieVwiIC8qIFkgKi8sIHRpY2tzKTtcbiAgICB9XG4gICAgY29uc3Qgc2VyaWVzV2lkdGggPSBzZXJpZXNSZWN0LndpZHRoIC0gTWF0aC5hYnMoaG9yaXpvbnRhbEluc2V0KTtcbiAgICBjb25zdCBzZXJpZXNIZWlnaHQgPSBzZXJpZXNSZWN0LmhlaWdodCAtIE1hdGguYWJzKHZlcnRpY2FsSW5zZXQpO1xuICAgIGNvbnN0IHdpZHRoMiA9IE1hdGgubWF4KGhvcml6b250YWwgPyBzZXJpZXNXaWR0aCA6IHRoaWNrbmVzcywgMCk7XG4gICAgY29uc3QgaGVpZ2h0MiA9IE1hdGgubWF4KGhvcml6b250YWwgPyB0aGlja25lc3MgOiBzZXJpZXNIZWlnaHQsIDApO1xuICAgIGNvbnN0IHgwID0gc2VyaWVzUmVjdC54ICsgKHNlcmllc1dpZHRoIC0gd2lkdGgyKSAvIDIgKyBNYXRoLm1heChob3Jpem9udGFsSW5zZXQsIDApO1xuICAgIGNvbnN0IHkwID0gc2VyaWVzUmVjdC55ICsgKHNlcmllc0hlaWdodCAtIGhlaWdodDIpIC8gMiAtIE1hdGgubWluKHZlcnRpY2FsSW5zZXQsIDApO1xuICAgIHhBeGlzLnJhbmdlID0gWzAsIHdpZHRoMl07XG4gICAgeEF4aXMuZ3JpZExlbmd0aCA9IHdpZHRoMjtcbiAgICB4QXhpcy5jYWxjdWxhdGVMYXlvdXQoKTtcbiAgICB4QXhpcy50cmFuc2xhdGlvbi54ID0geDA7XG4gICAgeEF4aXMudHJhbnNsYXRpb24ueSA9IHkwICsgKHhBeGlzLnBvc2l0aW9uID09PSBcImJvdHRvbVwiID8gdGhpY2tuZXNzIDogMCk7XG4gICAgeUF4aXMucmFuZ2UgPSBbMCwgaGVpZ2h0Ml07XG4gICAgeUF4aXMuZ3JpZExlbmd0aCA9IGhlaWdodDI7XG4gICAgeUF4aXMuY2FsY3VsYXRlTGF5b3V0KCk7XG4gICAgeUF4aXMudHJhbnNsYXRpb24ueCA9IHgwICsgKHlBeGlzLnBvc2l0aW9uID09PSBcInJpZ2h0XCIgPyB0aGlja25lc3MgOiAwKTtcbiAgICB5QXhpcy50cmFuc2xhdGlvbi55ID0geTA7XG4gICAgc2VyaWVzLm9yaWdpblggPSB4MCAtIHNlcmllc1JlY3QueDtcbiAgICBzZXJpZXMub3JpZ2luWSA9IHkwIC0gc2VyaWVzUmVjdC55O1xuICAgIGlmICh3aWR0aDIgPT09IDAgfHwgaGVpZ2h0MiA9PT0gMCkge1xuICAgICAgTG9nZ2VyLndhcm5PbmNlKFwiVGhlcmUgd2FzIGluc3VmZmljaWVudCBzcGFjZSB0byBkaXNwbGF5IHRoZSBMaW5lYXIgR2F1Z2UuXCIpO1xuICAgIH1cbiAgfVxuICBwZXJmb3JtTGF5b3V0KGN0eCkge1xuICAgIGNvbnN0IHsgc2VyaWVzUm9vdCwgYW5ub3RhdGlvblJvb3QsIGhpZ2hsaWdodFJvb3QsIHNlcmllcywgc2VyaWVzQXJlYSB9ID0gdGhpcztcbiAgICBjb25zdCB7IGxheW91dEJveCB9ID0gY3R4O1xuICAgIGNvbnN0IHNlcmllc1JlY3QgPSBsYXlvdXRCb3guY2xvbmUoKTtcbiAgICBsYXlvdXRCb3guc2hyaW5rKHNlcmllc0FyZWEucGFkZGluZy50b0pzb24oKSk7XG4gICAgY29uc3QgZmlyc3RTZXJpZXMgPSB0aGlzLnNlcmllc1swXTtcbiAgICBpZiAoaXNSYWRpYWxHYXVnZVNlcmllcyhmaXJzdFNlcmllcykpIHtcbiAgICAgIHRoaXMudXBkYXRlUmFkaWFsR2F1Z2UobGF5b3V0Qm94LCBmaXJzdFNlcmllcyk7XG4gICAgfSBlbHNlIGlmIChpc0xpbmVhckdhdWdlU2VyaWVzKGZpcnN0U2VyaWVzKSkge1xuICAgICAgdGhpcy51cGRhdGVMaW5lYXJHYXVnZShsYXlvdXRCb3gsIGZpcnN0U2VyaWVzKTtcbiAgICB9XG4gICAgdGhpcy5heGVzLmZvckVhY2goKGF4aXMpID0+IGF4aXMudXBkYXRlKCkpO1xuICAgIHRoaXMuc2VyaWVzUmVjdCA9IHNlcmllc1JlY3QuY2xvbmUoKS50cmFuc2xhdGUoc2VyaWVzUmVjdC54IC0gbGF5b3V0Qm94LngsIHNlcmllc1JlY3QueSAtIGxheW91dEJveC55KTtcbiAgICB0aGlzLmFuaW1hdGlvblJlY3QgPSBsYXlvdXRCb3g7XG4gICAgc2VyaWVzUm9vdC52aXNpYmxlID0gc2VyaWVzLnNvbWUoKHMpID0+IHMudmlzaWJsZSk7XG4gICAgZm9yIChjb25zdCBncm91cCBvZiBbc2VyaWVzUm9vdCwgYW5ub3RhdGlvblJvb3QsIGhpZ2hsaWdodFJvb3RdKSB7XG4gICAgICBncm91cC50cmFuc2xhdGlvblggPSBNYXRoLmZsb29yKGxheW91dEJveC54KTtcbiAgICAgIGdyb3VwLnRyYW5zbGF0aW9uWSA9IE1hdGguZmxvb3IobGF5b3V0Qm94LnkpO1xuICAgIH1cbiAgICB0aGlzLmN0eC5sYXlvdXRNYW5hZ2VyLmVtaXRMYXlvdXRDb21wbGV0ZShjdHgsIHtcbiAgICAgIHNlcmllczogeyB2aXNpYmxlOiBzZXJpZXNSb290LnZpc2libGUsIHJlY3Q6IHNlcmllc1JlY3QsIHBhZGRlZFJlY3Q6IGxheW91dEJveCB9XG4gICAgfSk7XG4gIH1cbiAgZ2V0QXJpYUxhYmVsKCkge1xuICAgIGNvbnN0IGNhcHRpb25zID0gW107XG4gICAgY29uc3QgY2hhcnRDYXB0aW9uID0gdGhpcy5nZXRDYXB0aW9uVGV4dCgpO1xuICAgIGlmIChjaGFydENhcHRpb24ubGVuZ3RoICE9PSAwKSB7XG4gICAgICBjYXB0aW9ucy5wdXNoKGNoYXJ0Q2FwdGlvbik7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgc2VyaWVzIG9mIHRoaXMuc2VyaWVzKSB7XG4gICAgICBjYXB0aW9ucy5wdXNoKHNlcmllcy5nZXRDYXB0aW9uVGV4dCgpKTtcbiAgICB9XG4gICAgY29uc3QgY2FwdGlvbiA9IGNhcHRpb25zLmpvaW4oXCIuIFwiKTtcbiAgICByZXR1cm4gdGhpcy5jdHgubG9jYWxlTWFuYWdlci50KFwiYXJpYUFubm91bmNlR2F1Z2VDaGFydFwiLCB7IGNhcHRpb24gfSk7XG4gIH1cbn07XG5HYXVnZUNoYXJ0LmNsYXNzTmFtZSA9IFwiR2F1Z2VDaGFydFwiO1xuR2F1Z2VDaGFydC50eXBlID0gXCJnYXVnZVwiO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9oaWVyYXJjaHlDaGFydC50c1xudmFyIEhpZXJhcmNoeUNoYXJ0ID0gY2xhc3MgZXh0ZW5kcyBDaGFydCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIHJlc291cmNlcykge1xuICAgIHN1cGVyKG9wdGlvbnMsIHJlc291cmNlcyk7XG4gIH1cbiAgZ2V0Q2hhcnRUeXBlKCkge1xuICAgIHJldHVybiBcImhpZXJhcmNoeVwiO1xuICB9XG4gIHBlcmZvcm1MYXlvdXQoY3R4KSB7XG4gICAgY29uc3QgeyBzZXJpZXNSb290LCBhbm5vdGF0aW9uUm9vdCwgaGlnaGxpZ2h0Um9vdCB9ID0gdGhpcztcbiAgICBjb25zdCB7IGxheW91dEJveCB9ID0gY3R4O1xuICAgIGNvbnN0IHNlcmllc1JlY3QgPSBsYXlvdXRCb3guY2xvbmUoKTtcbiAgICBsYXlvdXRCb3guc2hyaW5rKHRoaXMuc2VyaWVzQXJlYS5wYWRkaW5nLnRvSnNvbigpKTtcbiAgICB0aGlzLnNlcmllc1JlY3QgPSBsYXlvdXRCb3g7XG4gICAgdGhpcy5hbmltYXRpb25SZWN0ID0gbGF5b3V0Qm94O1xuICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgW3Nlcmllc1Jvb3QsIGFubm90YXRpb25Sb290LCBoaWdobGlnaHRSb290XSkge1xuICAgICAgZ3JvdXAudHJhbnNsYXRpb25YID0gTWF0aC5mbG9vcihsYXlvdXRCb3gueCk7XG4gICAgICBncm91cC50cmFuc2xhdGlvblkgPSBNYXRoLmZsb29yKGxheW91dEJveC55KTtcbiAgICB9XG4gICAgc2VyaWVzUm9vdC52aXNpYmxlID0gdGhpcy5zZXJpZXNbMF0udmlzaWJsZTtcbiAgICBzZXJpZXNSb290LnNldENsaXBSZWN0KGxheW91dEJveC5jbG9uZSgpKTtcbiAgICB0aGlzLmN0eC5sYXlvdXRNYW5hZ2VyLmVtaXRMYXlvdXRDb21wbGV0ZShjdHgsIHtcbiAgICAgIHNlcmllczogeyB2aXNpYmxlOiB0cnVlLCByZWN0OiBzZXJpZXNSZWN0LCBwYWRkZWRSZWN0OiBsYXlvdXRCb3ggfVxuICAgIH0pO1xuICB9XG4gIGdldEFyaWFMYWJlbCgpIHtcbiAgICBjb25zdCBjYXB0aW9uID0gdGhpcy5nZXRDYXB0aW9uVGV4dCgpO1xuICAgIHJldHVybiB0aGlzLmN0eC5sb2NhbGVNYW5hZ2VyLnQoXCJhcmlhQW5ub3VuY2VIaWVyYXJjaHlDaGFydFwiLCB7IGNhcHRpb24gfSk7XG4gIH1cbn07XG5IaWVyYXJjaHlDaGFydC5jbGFzc05hbWUgPSBcIkhpZXJhcmNoeUNoYXJ0XCI7XG5IaWVyYXJjaHlDaGFydC50eXBlID0gXCJoaWVyYXJjaHlcIjtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvcG9sYXJDaGFydC50c1xudmFyIFBvbGFyQ2hhcnQgPSBjbGFzcyBleHRlbmRzIENoYXJ0IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucywgcmVzb3VyY2VzKSB7XG4gICAgc3VwZXIob3B0aW9ucywgcmVzb3VyY2VzKTtcbiAgICB0aGlzLnBhZGRpbmcgPSBuZXcgUGFkZGluZyg0MCk7XG4gICAgdGhpcy5jdHguYXhpc01hbmFnZXIuYXhpc0dyb3VwLnpJbmRleCA9IDYgLyogQVhJU19GT1JFR1JPVU5EICovO1xuICB9XG4gIGdldENoYXJ0VHlwZSgpIHtcbiAgICByZXR1cm4gXCJwb2xhclwiO1xuICB9XG4gIGFzeW5jIHBlcmZvcm1MYXlvdXQoY3R4KSB7XG4gICAgY29uc3QgeyBsYXlvdXRCb3ggfSA9IGN0eDtcbiAgICBjb25zdCBzZXJpZXNSZWN0ID0gbGF5b3V0Qm94LmNsb25lKCk7XG4gICAgbGF5b3V0Qm94LnNocmluayh0aGlzLnNlcmllc0FyZWEucGFkZGluZy50b0pzb24oKSk7XG4gICAgdGhpcy5zZXJpZXNSZWN0ID0gbGF5b3V0Qm94O1xuICAgIHRoaXMuYW5pbWF0aW9uUmVjdCA9IGxheW91dEJveDtcbiAgICBhd2FpdCB0aGlzLmNvbXB1dGVDaXJjbGUobGF5b3V0Qm94KTtcbiAgICB0aGlzLmF4ZXMuZm9yRWFjaCgoYXhpcykgPT4gYXhpcy51cGRhdGUoKSk7XG4gICAgdGhpcy5jdHgubGF5b3V0TWFuYWdlci5lbWl0TGF5b3V0Q29tcGxldGUoY3R4LCB7XG4gICAgICBzZXJpZXM6IHsgdmlzaWJsZTogdHJ1ZSwgcmVjdDogc2VyaWVzUmVjdCwgcGFkZGVkUmVjdDogbGF5b3V0Qm94IH1cbiAgICB9KTtcbiAgfVxuICB1cGRhdGVBeGVzKGN4LCBjeSwgcmFkaXVzKSB7XG4gICAgY29uc3QgYW5nbGVBeGlzID0gdGhpcy5heGVzLmZpbmQoKGF4aXMpID0+IGF4aXMuZGlyZWN0aW9uID09PSBcInhcIiAvKiBYICovKTtcbiAgICBjb25zdCByYWRpdXNBeGlzID0gdGhpcy5heGVzLmZpbmQoKGF4aXMpID0+IGF4aXMuZGlyZWN0aW9uID09PSBcInlcIiAvKiBZICovKTtcbiAgICBpZiAoIShhbmdsZUF4aXMgaW5zdGFuY2VvZiBQb2xhckF4aXMpIHx8ICEocmFkaXVzQXhpcyBpbnN0YW5jZW9mIFBvbGFyQXhpcykpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgYW5nbGVTY2FsZSA9IGFuZ2xlQXhpcy5zY2FsZTtcbiAgICBjb25zdCBpbm5lclJhZGl1c1JhdGlvID0gcmFkaXVzQXhpcy5pbm5lclJhZGl1c1JhdGlvO1xuICAgIGFuZ2xlQXhpcy5pbm5lclJhZGl1c1JhdGlvID0gaW5uZXJSYWRpdXNSYXRpbztcbiAgICBhbmdsZUF4aXMuY29tcHV0ZVJhbmdlKCk7XG4gICAgYW5nbGVBeGlzLmdyaWRMZW5ndGggPSByYWRpdXM7XG4gICAgcmFkaXVzQXhpcy5ncmlkQW5nbGVzID0gYW5nbGVTY2FsZS50aWNrcz8uKCkubWFwKCh2YWx1ZSkgPT4gYW5nbGVTY2FsZS5jb252ZXJ0KHZhbHVlKSk7XG4gICAgcmFkaXVzQXhpcy5ncmlkUmFuZ2UgPSBhbmdsZUF4aXMucmFuZ2U7XG4gICAgcmFkaXVzQXhpcy5yYW5nZSA9IFtyYWRpdXMsIHJhZGl1cyAqIGlubmVyUmFkaXVzUmF0aW9dO1xuICAgIFthbmdsZUF4aXMsIHJhZGl1c0F4aXNdLmZvckVhY2goKGF4aXMpID0+IHtcbiAgICAgIGF4aXMudHJhbnNsYXRpb24ueCA9IGN4O1xuICAgICAgYXhpcy50cmFuc2xhdGlvbi55ID0gY3k7XG4gICAgICBheGlzLmNhbGN1bGF0ZUxheW91dCgpO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGNvbXB1dGVDaXJjbGUoc2VyaWVzQm94KSB7XG4gICAgY29uc3QgcG9sYXJTZXJpZXMgPSB0aGlzLnNlcmllcy5maWx0ZXIoaXNQb2xhclNlcmllcyk7XG4gICAgY29uc3QgcG9sYXJBeGVzID0gdGhpcy5heGVzLmZpbHRlcihpc1BvbGFyQXhpcyk7XG4gICAgY29uc3Qgc2V0U2VyaWVzQ2lyY2xlID0gKGN4LCBjeSwgcikgPT4ge1xuICAgICAgdGhpcy51cGRhdGVBeGVzKGN4LCBjeSwgcik7XG4gICAgICBwb2xhclNlcmllcy5mb3JFYWNoKChzZXJpZXMpID0+IHtcbiAgICAgICAgc2VyaWVzLmNlbnRlclggPSBjeDtcbiAgICAgICAgc2VyaWVzLmNlbnRlclkgPSBjeTtcbiAgICAgICAgc2VyaWVzLnJhZGl1cyA9IHI7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHBpZVNlcmllcyA9IHBvbGFyU2VyaWVzLmZpbHRlcigocykgPT4gcy50eXBlID09PSBcImRvbnV0XCIgfHwgcy50eXBlID09PSBcInBpZVwiKTtcbiAgICAgIGlmIChwaWVTZXJpZXMubGVuZ3RoID4gMSkge1xuICAgICAgICBjb25zdCBpbm5lclJhZGlpID0gcGllU2VyaWVzLm1hcCgoc2VyaWVzKSA9PiB7XG4gICAgICAgICAgY29uc3QgaW5uZXJSYWRpdXMgPSBzZXJpZXMuZ2V0SW5uZXJSYWRpdXMoKTtcbiAgICAgICAgICByZXR1cm4geyBzZXJpZXMsIGlubmVyUmFkaXVzIH07XG4gICAgICAgIH0pLnNvcnQoKGEsIGIpID0+IGEuaW5uZXJSYWRpdXMgLSBiLmlubmVyUmFkaXVzKTtcbiAgICAgICAgaW5uZXJSYWRpaS5hdCgtMSkuc2VyaWVzLnN1cnJvdW5kaW5nUmFkaXVzID0gdm9pZCAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlubmVyUmFkaWkubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgaW5uZXJSYWRpaVtpXS5zZXJpZXMuc3Vycm91bmRpbmdSYWRpdXMgPSBpbm5lclJhZGlpW2kgKyAxXS5pbm5lclJhZGl1cztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgY2VudGVyWCA9IHNlcmllc0JveC54ICsgc2VyaWVzQm94LndpZHRoIC8gMjtcbiAgICBjb25zdCBjZW50ZXJZID0gc2VyaWVzQm94LnkgKyBzZXJpZXNCb3guaGVpZ2h0IC8gMjtcbiAgICBjb25zdCBpbml0aWFsUmFkaXVzID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oc2VyaWVzQm94LndpZHRoLCBzZXJpZXNCb3guaGVpZ2h0KSAvIDIpO1xuICAgIGxldCByYWRpdXMgPSBpbml0aWFsUmFkaXVzO1xuICAgIHNldFNlcmllc0NpcmNsZShjZW50ZXJYLCBjZW50ZXJZLCByYWRpdXMpO1xuICAgIGNvbnN0IHNoYWtlID0gYXN5bmMgKHsgaGlkZVdoZW5OZWNlc3NhcnkgPSBmYWxzZSB9ID0ge30pID0+IHtcbiAgICAgIGNvbnN0IGxhYmVsQm94ZXMgPSBbXTtcbiAgICAgIGZvciAoY29uc3Qgc2VyaWVzIG9mIGl0ZXJhdGUocG9sYXJBeGVzLCBwb2xhclNlcmllcykpIHtcbiAgICAgICAgY29uc3QgYm94ID0gYXdhaXQgc2VyaWVzLmNvbXB1dGVMYWJlbHNCQm94KHsgaGlkZVdoZW5OZWNlc3NhcnkgfSwgc2VyaWVzQm94KTtcbiAgICAgICAgaWYgKGJveCkge1xuICAgICAgICAgIGxhYmVsQm94ZXMucHVzaChib3gpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobGFiZWxCb3hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgc2V0U2VyaWVzQ2lyY2xlKGNlbnRlclgsIGNlbnRlclksIGluaXRpYWxSYWRpdXMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBsYWJlbEJveCA9IEJCb3gubWVyZ2UobGFiZWxCb3hlcyk7XG4gICAgICBjb25zdCByZWZpbmVkID0gdGhpcy5yZWZpbmVDaXJjbGUobGFiZWxCb3gsIHJhZGl1cywgc2VyaWVzQm94KTtcbiAgICAgIHNldFNlcmllc0NpcmNsZShyZWZpbmVkLmNlbnRlclgsIHJlZmluZWQuY2VudGVyWSwgcmVmaW5lZC5yYWRpdXMpO1xuICAgICAgcmFkaXVzID0gcmVmaW5lZC5yYWRpdXM7XG4gICAgfTtcbiAgICBhd2FpdCBzaGFrZSgpO1xuICAgIGF3YWl0IHNoYWtlKCk7XG4gICAgYXdhaXQgc2hha2UoKTtcbiAgICBhd2FpdCBzaGFrZSh7IGhpZGVXaGVuTmVjZXNzYXJ5OiB0cnVlIH0pO1xuICAgIGF3YWl0IHNoYWtlKHsgaGlkZVdoZW5OZWNlc3Nhcnk6IHRydWUgfSk7XG4gICAgZm9yIChjb25zdCBzZXJpZXMgb2YgaXRlcmF0ZShwb2xhckF4ZXMsIHBvbGFyU2VyaWVzKSkge1xuICAgICAgYXdhaXQgc2VyaWVzLmNvbXB1dGVMYWJlbHNCQm94KHsgaGlkZVdoZW5OZWNlc3Nhcnk6IHRydWUgfSwgc2VyaWVzQm94KTtcbiAgICB9XG4gICAgcmV0dXJuIHsgcmFkaXVzLCBjZW50ZXJYLCBjZW50ZXJZIH07XG4gIH1cbiAgcmVmaW5lQ2lyY2xlKGxhYmVsc0JveCwgcmFkaXVzLCBzZXJpZXNCb3gpIHtcbiAgICBjb25zdCBtaW5DaXJjbGVSYXRpbyA9IDAuNTtcbiAgICBjb25zdCBjaXJjbGVMZWZ0ID0gLXJhZGl1cztcbiAgICBjb25zdCBjaXJjbGVUb3AgPSAtcmFkaXVzO1xuICAgIGNvbnN0IGNpcmNsZVJpZ2h0ID0gcmFkaXVzO1xuICAgIGNvbnN0IGNpcmNsZUJvdHRvbSA9IHJhZGl1cztcbiAgICBsZXQgcGFkTGVmdCA9IE1hdGgubWF4KDAsIGNpcmNsZUxlZnQgLSBsYWJlbHNCb3gueCk7XG4gICAgbGV0IHBhZFRvcCA9IE1hdGgubWF4KDAsIGNpcmNsZVRvcCAtIGxhYmVsc0JveC55KTtcbiAgICBsZXQgcGFkUmlnaHQgPSBNYXRoLm1heCgwLCBsYWJlbHNCb3gueCArIGxhYmVsc0JveC53aWR0aCAtIGNpcmNsZVJpZ2h0KTtcbiAgICBsZXQgcGFkQm90dG9tID0gTWF0aC5tYXgoMCwgbGFiZWxzQm94LnkgKyBsYWJlbHNCb3guaGVpZ2h0IC0gY2lyY2xlQm90dG9tKTtcbiAgICBwYWRMZWZ0ID0gcGFkUmlnaHQgPSBNYXRoLm1heChwYWRMZWZ0LCBwYWRSaWdodCk7XG4gICAgcGFkVG9wID0gcGFkQm90dG9tID0gTWF0aC5tYXgocGFkVG9wLCBwYWRCb3R0b20pO1xuICAgIGNvbnN0IGF2YWlsQ2lyY2xlV2lkdGggPSBzZXJpZXNCb3gud2lkdGggLSBwYWRMZWZ0IC0gcGFkUmlnaHQ7XG4gICAgY29uc3QgYXZhaWxDaXJjbGVIZWlnaHQgPSBzZXJpZXNCb3guaGVpZ2h0IC0gcGFkVG9wIC0gcGFkQm90dG9tO1xuICAgIGxldCBuZXdSYWRpdXMgPSBNYXRoLm1pbihhdmFpbENpcmNsZVdpZHRoLCBhdmFpbENpcmNsZUhlaWdodCkgLyAyO1xuICAgIGNvbnN0IG1pbkhvcml6b250YWxSYWRpdXMgPSBtaW5DaXJjbGVSYXRpbyAqIHNlcmllc0JveC53aWR0aCAvIDI7XG4gICAgY29uc3QgbWluVmVydGljYWxSYWRpdXMgPSBtaW5DaXJjbGVSYXRpbyAqIHNlcmllc0JveC5oZWlnaHQgLyAyO1xuICAgIGNvbnN0IG1pblJhZGl1cyA9IE1hdGgubWluKG1pbkhvcml6b250YWxSYWRpdXMsIG1pblZlcnRpY2FsUmFkaXVzKTtcbiAgICBpZiAobmV3UmFkaXVzIDwgbWluUmFkaXVzKSB7XG4gICAgICBuZXdSYWRpdXMgPSBtaW5SYWRpdXM7XG4gICAgICBjb25zdCBob3Jpem9udGFsUGFkZGluZyA9IHBhZExlZnQgKyBwYWRSaWdodDtcbiAgICAgIGNvbnN0IHZlcnRpY2FsUGFkZGluZyA9IHBhZFRvcCArIHBhZEJvdHRvbTtcbiAgICAgIGlmICgyICogbmV3UmFkaXVzICsgdmVydGljYWxQYWRkaW5nID4gc2VyaWVzQm94LmhlaWdodCkge1xuICAgICAgICBjb25zdCBwYWRIZWlnaHQgPSBzZXJpZXNCb3guaGVpZ2h0IC0gMiAqIG5ld1JhZGl1cztcbiAgICAgICAgaWYgKE1hdGgubWluKHBhZFRvcCwgcGFkQm90dG9tKSAqIDIgPiBwYWRIZWlnaHQpIHtcbiAgICAgICAgICBwYWRUb3AgPSBwYWRIZWlnaHQgLyAyO1xuICAgICAgICAgIHBhZEJvdHRvbSA9IHBhZEhlaWdodCAvIDI7XG4gICAgICAgIH0gZWxzZSBpZiAocGFkVG9wID4gcGFkQm90dG9tKSB7XG4gICAgICAgICAgcGFkVG9wID0gcGFkSGVpZ2h0IC0gcGFkQm90dG9tO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhZEJvdHRvbSA9IHBhZEhlaWdodCAtIHBhZFRvcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKDIgKiBuZXdSYWRpdXMgKyBob3Jpem9udGFsUGFkZGluZyA+IHNlcmllc0JveC53aWR0aCkge1xuICAgICAgICBjb25zdCBwYWRXaWR0aCA9IHNlcmllc0JveC53aWR0aCAtIDIgKiBuZXdSYWRpdXM7XG4gICAgICAgIGlmIChNYXRoLm1pbihwYWRMZWZ0LCBwYWRSaWdodCkgKiAyID4gcGFkV2lkdGgpIHtcbiAgICAgICAgICBwYWRMZWZ0ID0gcGFkV2lkdGggLyAyO1xuICAgICAgICAgIHBhZFJpZ2h0ID0gcGFkV2lkdGggLyAyO1xuICAgICAgICB9IGVsc2UgaWYgKHBhZExlZnQgPiBwYWRSaWdodCkge1xuICAgICAgICAgIHBhZExlZnQgPSBwYWRXaWR0aCAtIHBhZFJpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhZFJpZ2h0ID0gcGFkV2lkdGggLSBwYWRMZWZ0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5ld1dpZHRoID0gcGFkTGVmdCArIDIgKiBuZXdSYWRpdXMgKyBwYWRSaWdodDtcbiAgICBjb25zdCBuZXdIZWlnaHQgPSBwYWRUb3AgKyAyICogbmV3UmFkaXVzICsgcGFkQm90dG9tO1xuICAgIHJldHVybiB7XG4gICAgICBjZW50ZXJYOiBzZXJpZXNCb3gueCArIChzZXJpZXNCb3gud2lkdGggLSBuZXdXaWR0aCkgLyAyICsgcGFkTGVmdCArIG5ld1JhZGl1cyxcbiAgICAgIGNlbnRlclk6IHNlcmllc0JveC55ICsgKHNlcmllc0JveC5oZWlnaHQgLSBuZXdIZWlnaHQpIC8gMiArIHBhZFRvcCArIG5ld1JhZGl1cyxcbiAgICAgIHJhZGl1czogbmV3UmFkaXVzXG4gICAgfTtcbiAgfVxufTtcblBvbGFyQ2hhcnQuY2xhc3NOYW1lID0gXCJQb2xhckNoYXJ0XCI7XG5Qb2xhckNoYXJ0LnR5cGUgPSBcInBvbGFyXCI7XG5mdW5jdGlvbiBpc1BvbGFyU2VyaWVzKHNlcmllcykge1xuICByZXR1cm4gc2VyaWVzIGluc3RhbmNlb2YgUG9sYXJTZXJpZXM7XG59XG5mdW5jdGlvbiBpc1BvbGFyQXhpcyhheGlzKSB7XG4gIHJldHVybiBheGlzIGluc3RhbmNlb2YgUG9sYXJBeGlzO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zdGFuZGFsb25lQ2hhcnQudHNcbnZhciBTdGFuZGFsb25lQ2hhcnQgPSBjbGFzcyBleHRlbmRzIENoYXJ0IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucywgcmVzb3VyY2VzKSB7XG4gICAgc3VwZXIob3B0aW9ucywgcmVzb3VyY2VzKTtcbiAgfVxuICBnZXRDaGFydFR5cGUoKSB7XG4gICAgcmV0dXJuIFwic3RhbmRhbG9uZVwiO1xuICB9XG4gIHBlcmZvcm1MYXlvdXQoY3R4KSB7XG4gICAgY29uc3QgeyBzZXJpZXNSb290LCBhbm5vdGF0aW9uUm9vdCwgaGlnaGxpZ2h0Um9vdCB9ID0gdGhpcztcbiAgICBjb25zdCB7IGxheW91dEJveCB9ID0gY3R4O1xuICAgIGNvbnN0IHNlcmllc1JlY3QgPSBsYXlvdXRCb3guY2xvbmUoKTtcbiAgICBsYXlvdXRCb3guc2hyaW5rKHRoaXMuc2VyaWVzQXJlYS5wYWRkaW5nLnRvSnNvbigpKTtcbiAgICB0aGlzLnNlcmllc1JlY3QgPSBsYXlvdXRCb3g7XG4gICAgdGhpcy5hbmltYXRpb25SZWN0ID0gbGF5b3V0Qm94O1xuICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgW3Nlcmllc1Jvb3QsIGFubm90YXRpb25Sb290LCBoaWdobGlnaHRSb290XSkge1xuICAgICAgZ3JvdXAudHJhbnNsYXRpb25YID0gTWF0aC5mbG9vcihsYXlvdXRCb3gueCk7XG4gICAgICBncm91cC50cmFuc2xhdGlvblkgPSBNYXRoLmZsb29yKGxheW91dEJveC55KTtcbiAgICB9XG4gICAgc2VyaWVzUm9vdC52aXNpYmxlID0gdGhpcy5zZXJpZXNbMF0udmlzaWJsZTtcbiAgICB0aGlzLmN0eC5sYXlvdXRNYW5hZ2VyLmVtaXRMYXlvdXRDb21wbGV0ZShjdHgsIHtcbiAgICAgIHNlcmllczogeyB2aXNpYmxlOiB0cnVlLCByZWN0OiBzZXJpZXNSZWN0LCBwYWRkZWRSZWN0OiBsYXlvdXRCb3ggfVxuICAgIH0pO1xuICB9XG4gIGdldEFyaWFMYWJlbCgpIHtcbiAgICBjb25zdCBjYXB0aW9uID0gdGhpcy5nZXRDYXB0aW9uVGV4dCgpO1xuICAgIHJldHVybiB0aGlzLmN0eC5sb2NhbGVNYW5hZ2VyLnQoXCJhcmlhQW5ub3VuY2VIaWVyYXJjaHlDaGFydFwiLCB7IGNhcHRpb24gfSk7XG4gIH1cbn07XG5TdGFuZGFsb25lQ2hhcnQuY2xhc3NOYW1lID0gXCJTdGFuZGFsb25lQ2hhcnRcIjtcblN0YW5kYWxvbmVDaGFydC50eXBlID0gXCJzdGFuZGFsb25lXCI7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy90b3BvbG9neS9tZXJjYXRvclNjYWxlLnRzXG52YXIgcmFkc0luRGVnID0gTWF0aC5QSSAvIDE4MDtcbnZhciBsb25YID0gKGxvbikgPT4gbG9uICogcmFkc0luRGVnO1xudmFyIGxhdFkgPSAobGF0KSA9PiAtTWF0aC5sb2coTWF0aC50YW4oTWF0aC5QSSAqIDAuMjUgKyBsYXQgKiByYWRzSW5EZWcgKiAwLjUpKTtcbnZhciB4TG9uID0gKHgpID0+IHggLyByYWRzSW5EZWc7XG52YXIgeUxhdCA9ICh5KSA9PiAoTWF0aC5hdGFuKE1hdGguZXhwKC15KSkgLSBNYXRoLlBJICogMC4yNSkgLyAocmFkc0luRGVnICogMC41KTtcbnZhciBNZXJjYXRvclNjYWxlID0gY2xhc3MgX01lcmNhdG9yU2NhbGUge1xuICBjb25zdHJ1Y3Rvcihkb21haW4sIHJhbmdlMykge1xuICAgIHRoaXMuZG9tYWluID0gZG9tYWluO1xuICAgIHRoaXMucmFuZ2UgPSByYW5nZTM7XG4gICAgdGhpcy50eXBlID0gXCJtZXJjYXRvclwiO1xuICAgIHRoaXMuYm91bmRzID0gX01lcmNhdG9yU2NhbGUuYm91bmRzKGRvbWFpbik7XG4gIH1cbiAgc3RhdGljIGJvdW5kcyhkb21haW4pIHtcbiAgICBjb25zdCBbW2xvbjAsIGxhdDBdLCBbbG9uMSwgbGF0MV1dID0gZG9tYWluO1xuICAgIGNvbnN0IHgwID0gbG9uWChsb24wKTtcbiAgICBjb25zdCB5MCA9IGxhdFkobGF0MCk7XG4gICAgY29uc3QgeDEgPSBsb25YKGxvbjEpO1xuICAgIGNvbnN0IHkxID0gbGF0WShsYXQxKTtcbiAgICByZXR1cm4gbmV3IEJCb3goTWF0aC5taW4oeDAsIHgxKSwgTWF0aC5taW4oeTAsIHkxKSwgTWF0aC5hYnMoeDEgLSB4MCksIE1hdGguYWJzKHkxIC0geTApKTtcbiAgfVxuICBzdGF0aWMgZml4ZWRTY2FsZSgpIHtcbiAgICByZXR1cm4gbmV3IF9NZXJjYXRvclNjYWxlKFxuICAgICAgW1xuICAgICAgICBbeExvbigwKSwgeUxhdCgwKV0sXG4gICAgICAgIFt4TG9uKDEpLCB5TGF0KDEpXVxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgWzAsIDBdLFxuICAgICAgICBbMSwgMV1cbiAgICAgIF1cbiAgICApO1xuICB9XG4gIGNvbnZlcnQoW2xvbiwgbGF0XSkge1xuICAgIGNvbnN0IFtbeDAsIHkwXSwgW3gxLCB5MV1dID0gdGhpcy5yYW5nZTtcbiAgICBjb25zdCB4U2NhbGUgPSAoeDEgLSB4MCkgLyB0aGlzLmJvdW5kcy53aWR0aDtcbiAgICBjb25zdCB5U2NhbGUgPSAoeTEgLSB5MCkgLyB0aGlzLmJvdW5kcy5oZWlnaHQ7XG4gICAgcmV0dXJuIFsobG9uWChsb24pIC0gdGhpcy5ib3VuZHMueCkgKiB4U2NhbGUgKyB4MCwgKGxhdFkobGF0KSAtIHRoaXMuYm91bmRzLnkpICogeVNjYWxlICsgeTBdO1xuICB9XG4gIGludmVydChbeCwgeV0pIHtcbiAgICBjb25zdCBbW3gwLCB5MF0sIFt4MSwgeTFdXSA9IHRoaXMucmFuZ2U7XG4gICAgY29uc3QgeFNjYWxlID0gKHgxIC0geDApIC8gdGhpcy5ib3VuZHMud2lkdGg7XG4gICAgY29uc3QgeVNjYWxlID0gKHkxIC0geTApIC8gdGhpcy5ib3VuZHMuaGVpZ2h0O1xuICAgIHJldHVybiBbeExvbigoeCAtIHgwKSAvIHhTY2FsZSArIHRoaXMuYm91bmRzLngpLCB5TGF0KCh5IC0geTApIC8geVNjYWxlICsgdGhpcy5ib3VuZHMueSldO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC90b3BvbG9neUNoYXJ0LnRzXG5mdW5jdGlvbiBpc1RvcG9sb2d5U2VyaWVzKHNlcmllcykge1xuICByZXR1cm4gc2VyaWVzLnR5cGUgPT09IFwibWFwLXNoYXBlXCIgfHwgc2VyaWVzLnR5cGUgPT09IFwibWFwLWxpbmVcIiB8fCBzZXJpZXMudHlwZSA9PT0gXCJtYXAtbWFya2VyXCIgfHwgc2VyaWVzLnR5cGUgPT09IFwibWFwLXNoYXBlLWJhY2tncm91bmRcIiB8fCBzZXJpZXMudHlwZSA9PT0gXCJtYXAtbGluZS1iYWNrZ3JvdW5kXCI7XG59XG52YXIgVG9wb2xvZ3lDaGFydCA9IGNsYXNzIGV4dGVuZHMgQ2hhcnQge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCByZXNvdXJjZXMpIHtcbiAgICBzdXBlcihvcHRpb25zLCByZXNvdXJjZXMpO1xuICAgIHRoaXMueEF4aXMgPSBuZXcgTnVtYmVyQXhpcyh0aGlzLmdldE1vZHVsZUNvbnRleHQoKSk7XG4gICAgdGhpcy54QXhpcy5wb3NpdGlvbiA9IFwiYm90dG9tXCI7XG4gICAgdGhpcy55QXhpcyA9IG5ldyBOdW1iZXJBeGlzKHRoaXMuZ2V0TW9kdWxlQ29udGV4dCgpKTtcbiAgICB0aGlzLnlBeGlzLnBvc2l0aW9uID0gXCJsZWZ0XCI7XG4gICAgdGhpcy5jdHguem9vbU1hbmFnZXIudXBkYXRlQXhlcyhbdGhpcy54QXhpcywgdGhpcy55QXhpc10pO1xuICB9XG4gIGdldENoYXJ0VHlwZSgpIHtcbiAgICByZXR1cm4gXCJ0b3BvbG9neVwiO1xuICB9XG4gIGFzeW5jIHVwZGF0ZURhdGEoKSB7XG4gICAgYXdhaXQgc3VwZXIudXBkYXRlRGF0YSgpO1xuICAgIGNvbnN0IHsgdG9wb2xvZ3kgfSA9IHRoaXMuZ2V0T3B0aW9ucygpO1xuICAgIHRoaXMuc2VyaWVzLmZvckVhY2goKHNlcmllcykgPT4ge1xuICAgICAgaWYgKGlzVG9wb2xvZ3lTZXJpZXMoc2VyaWVzKSkge1xuICAgICAgICBzZXJpZXMuc2V0Q2hhcnRUb3BvbG9neSh0b3BvbG9neSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcGVyZm9ybUxheW91dChjdHgpIHtcbiAgICBjb25zdCB7IHNlcmllc1Jvb3QsIGFubm90YXRpb25Sb290LCBoaWdobGlnaHRSb290IH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgbGF5b3V0Qm94IH0gPSBjdHg7XG4gICAgY29uc3Qgc2VyaWVzUmVjdCA9IGxheW91dEJveC5jbG9uZSgpO1xuICAgIGxheW91dEJveC5zaHJpbmsodGhpcy5zZXJpZXNBcmVhLnBhZGRpbmcudG9Kc29uKCkpO1xuICAgIHRoaXMuc2VyaWVzUmVjdCA9IGxheW91dEJveDtcbiAgICB0aGlzLmFuaW1hdGlvblJlY3QgPSBsYXlvdXRCb3g7XG4gICAgY29uc3QgbWFwU2VyaWVzID0gdGhpcy5zZXJpZXMuZmlsdGVyKGlzVG9wb2xvZ3lTZXJpZXMpO1xuICAgIGNvbnN0IGNvbWJpbmVkQmJveCA9IG1hcFNlcmllcy5yZWR1Y2UoKGNvbWJpbmVkLCBzZXJpZXMpID0+IHtcbiAgICAgIGlmICghc2VyaWVzLnZpc2libGUpXG4gICAgICAgIHJldHVybiBjb21iaW5lZDtcbiAgICAgIGNvbnN0IGJib3ggPSBzZXJpZXMudG9wb2xvZ3lCb3VuZHM7XG4gICAgICBpZiAoYmJveCA9PSBudWxsKVxuICAgICAgICByZXR1cm4gY29tYmluZWQ7XG4gICAgICBpZiAoY29tYmluZWQgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIGJib3g7XG4gICAgICBjb21iaW5lZC5tZXJnZShiYm94KTtcbiAgICAgIHJldHVybiBjb21iaW5lZDtcbiAgICB9LCB2b2lkIDApO1xuICAgIGxldCBzY2FsZTI7XG4gICAgaWYgKGNvbWJpbmVkQmJveCAhPSBudWxsKSB7XG4gICAgICBjb25zdCB7IGxvbjAsIGxhdDAsIGxvbjEsIGxhdDEgfSA9IGNvbWJpbmVkQmJveDtcbiAgICAgIGNvbnN0IGRvbWFpbiA9IFtcbiAgICAgICAgW2xvbjAsIGxhdDBdLFxuICAgICAgICBbbG9uMSwgbGF0MV1cbiAgICAgIF07XG4gICAgICBjb25zdCBib3VuZHMgPSBNZXJjYXRvclNjYWxlLmJvdW5kcyhkb21haW4pO1xuICAgICAgY29uc3QgeyB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIgfSA9IGxheW91dEJveDtcbiAgICAgIGNvbnN0IHZpZXdCb3hTY2FsZSA9IE1hdGgubWluKHdpZHRoMiAvIGJvdW5kcy53aWR0aCwgaGVpZ2h0MiAvIGJvdW5kcy5oZWlnaHQpO1xuICAgICAgY29uc3Qgdmlld0JveFdpZHRoID0gYm91bmRzLndpZHRoICogdmlld0JveFNjYWxlO1xuICAgICAgY29uc3Qgdmlld0JveEhlaWdodCA9IGJvdW5kcy5oZWlnaHQgKiB2aWV3Qm94U2NhbGU7XG4gICAgICBjb25zdCB2aWV3Qm94T3JpZ2luWCA9ICh3aWR0aDIgLSB2aWV3Qm94V2lkdGgpIC8gMjtcbiAgICAgIGNvbnN0IHZpZXdCb3hPcmlnaW5ZID0gKGhlaWdodDIgLSB2aWV3Qm94SGVpZ2h0KSAvIDI7XG4gICAgICBjb25zdCB4MCA9IHZpZXdCb3hPcmlnaW5YO1xuICAgICAgY29uc3QgeTAgPSB2aWV3Qm94T3JpZ2luWTtcbiAgICAgIGNvbnN0IHgxID0gdmlld0JveE9yaWdpblggKyB2aWV3Qm94V2lkdGg7XG4gICAgICBjb25zdCB5MSA9IHZpZXdCb3hPcmlnaW5ZICsgdmlld0JveEhlaWdodDtcbiAgICAgIGNvbnN0IHhab29tID0gdGhpcy5jdHguem9vbU1hbmFnZXIuZ2V0QXhpc1pvb20odGhpcy54QXhpcy5pZCk7XG4gICAgICBjb25zdCB5Wm9vbSA9IHRoaXMuY3R4Lnpvb21NYW5hZ2VyLmdldEF4aXNab29tKHRoaXMueUF4aXMuaWQpO1xuICAgICAgY29uc3QgeFNwYW4gPSAoeDEgLSB4MCkgLyAoeFpvb20ubWF4IC0geFpvb20ubWluKTtcbiAgICAgIGNvbnN0IHhTdGFydCA9IHgwIC0geFNwYW4gKiB4Wm9vbS5taW47XG4gICAgICBjb25zdCB5U3BhbiA9ICh5MSAtIHkwKSAvICgxIC0geVpvb20ubWluIC0gKDEgLSB5Wm9vbS5tYXgpKTtcbiAgICAgIGNvbnN0IHlTdGFydCA9IHkwIC0geVNwYW4gKiAoMSAtIHlab29tLm1heCk7XG4gICAgICBzY2FsZTIgPSBuZXcgTWVyY2F0b3JTY2FsZShkb21haW4sIFtcbiAgICAgICAgW3hTdGFydCwgeVN0YXJ0XSxcbiAgICAgICAgW3hTdGFydCArIHhTcGFuLCB5U3RhcnQgKyB5U3Bhbl1cbiAgICAgIF0pO1xuICAgIH1cbiAgICBtYXBTZXJpZXMuZm9yRWFjaCgoc2VyaWVzKSA9PiB7XG4gICAgICBzZXJpZXMuc2NhbGUgPSBzY2FsZTI7XG4gICAgfSk7XG4gICAgY29uc3Qgc2VyaWVzVmlzaWJsZSA9IHRoaXMuc2VyaWVzLnNvbWUoKHMpID0+IHMudmlzaWJsZSk7XG4gICAgc2VyaWVzUm9vdC52aXNpYmxlID0gc2VyaWVzVmlzaWJsZTtcbiAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIFtzZXJpZXNSb290LCBhbm5vdGF0aW9uUm9vdCwgaGlnaGxpZ2h0Um9vdF0pIHtcbiAgICAgIGdyb3VwLnRyYW5zbGF0aW9uWCA9IE1hdGguZmxvb3IobGF5b3V0Qm94LngpO1xuICAgICAgZ3JvdXAudHJhbnNsYXRpb25ZID0gTWF0aC5mbG9vcihsYXlvdXRCb3gueSk7XG4gICAgICBncm91cC5zZXRDbGlwUmVjdChsYXlvdXRCb3guY2xvbmUoKSk7XG4gICAgfVxuICAgIHRoaXMuY3R4LmxheW91dE1hbmFnZXIuZW1pdExheW91dENvbXBsZXRlKGN0eCwge1xuICAgICAgc2VyaWVzOiB7IHZpc2libGU6IHNlcmllc1Zpc2libGUsIHJlY3Q6IHNlcmllc1JlY3QsIHBhZGRlZFJlY3Q6IGxheW91dEJveCB9XG4gICAgfSk7XG4gIH1cbn07XG5Ub3BvbG9neUNoYXJ0LmNsYXNzTmFtZSA9IFwiVG9wb2xvZ3lDaGFydFwiO1xuVG9wb2xvZ3lDaGFydC50eXBlID0gXCJ0b3BvbG9neVwiO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9hcGkvcHJlc2V0L3ByZXNldFV0aWxzLnRzXG5mdW5jdGlvbiBhc3NlcnRFbXB0eShfdCkge1xufVxudmFyIElHTk9SRURfUFJPUCA9IFN5bWJvbChcIklHTk9SRURfUFJPUFwiKTtcbmZ1bmN0aW9uIHBpY2tQcm9wcyhvcHRzLCB2YWx1ZXMpIHtcbiAgY29uc3Qgb3V0ID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIHZhbHVlcykge1xuICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2tleV07XG4gICAgaWYgKHZhbHVlICE9PSBJR05PUkVEX1BST1AgJiYgT2JqZWN0Lmhhc093bihvcHRzLCBrZXkpKSB7XG4gICAgICBvdXRba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9hcGkvcHJlc2V0L2dhdWdlLnRzXG5mdW5jdGlvbiBpc1JhZGlhbEdhdWdlKG9wdHMpIHtcbiAgcmV0dXJuIG9wdHMudHlwZSA9PT0gXCJyYWRpYWwtZ2F1Z2VcIjtcbn1cbmZ1bmN0aW9uIGlzTGluZWFyR2F1Z2Uob3B0cykge1xuICByZXR1cm4gb3B0cy50eXBlID09PSBcImxpbmVhci1nYXVnZVwiO1xufVxuZnVuY3Rpb24gcmFkaWFsR2F1Z2VPcHRpb25zKG9wdHMpIHtcbiAgY29uc3Qge1xuICAgIGFuaW1hdGlvbixcbiAgICBiYWNrZ3JvdW5kLFxuICAgIGNvbnRhaW5lcixcbiAgICBjb250ZXh0TWVudSxcbiAgICBmb290bm90ZSxcbiAgICBoZWlnaHQ6IGhlaWdodDIsXG4gICAgbGlzdGVuZXJzLFxuICAgIGxvY2FsZSxcbiAgICBtaW5IZWlnaHQsXG4gICAgbWluV2lkdGgsXG4gICAgcGFkZGluZyxcbiAgICBzdWJ0aXRsZSxcbiAgICB0aGVtZSxcbiAgICB0aXRsZSxcbiAgICB3aWR0aDogd2lkdGgyLFxuICAgIHR5cGUsXG4gICAgY3Vyc29yLFxuICAgIG5vZGVDbGlja1JhbmdlLFxuICAgIHRvb2x0aXAsXG4gICAgdmFsdWUsXG4gICAgc2NhbGU6IHNjYWxlMiA9IHt9LFxuICAgIHN0YXJ0QW5nbGUsXG4gICAgZW5kQW5nbGUsXG4gICAgaGlnaGxpZ2h0U3R5bGUsXG4gICAgc2VnbWVudGF0aW9uLFxuICAgIGJhcixcbiAgICBuZWVkbGUsXG4gICAgdGFyZ2V0cyxcbiAgICBvdXRlclJhZGl1cyxcbiAgICBpbm5lclJhZGl1cyxcbiAgICBvdXRlclJhZGl1c1JhdGlvLFxuICAgIGlubmVyUmFkaXVzUmF0aW8sXG4gICAgY29ybmVyUmFkaXVzLFxuICAgIGNvcm5lck1vZGUsXG4gICAgbGFiZWwsXG4gICAgc2Vjb25kYXJ5TGFiZWwsXG4gICAgc3BhY2luZyxcbiAgICAuLi5yZXN0XG4gIH0gPSBvcHRzO1xuICBhc3NlcnRFbXB0eShyZXN0KTtcbiAgY29uc3Qge1xuICAgIGZpbGxzOiBzY2FsZUZpbGxzLFxuICAgIGZpbGxNb2RlOiBzY2FsZUZpbGxNb2RlLFxuICAgIGZpbGw6IHNjYWxlRmlsbCxcbiAgICBmaWxsT3BhY2l0eTogc2NhbGVGaWxsT3BhY2l0eSxcbiAgICBzdHJva2U6IHNjYWxlU3Ryb2tlLFxuICAgIHN0cm9rZVdpZHRoOiBzY2FsZVN0cm9rZVdpZHRoLFxuICAgIHN0cm9rZU9wYWNpdHk6IHNjYWxlU3Ryb2tlT3BhY2l0eSxcbiAgICBsaW5lRGFzaDogc2NhbGVMaW5lRGFzaCxcbiAgICBsaW5lRGFzaE9mZnNldDogc2NhbGVMaW5lRGFzaE9mZnNldCxcbiAgICBtaW46IHNjYWxlTWluID0gMCxcbiAgICBtYXg6IHNjYWxlTWF4ID0gMSxcbiAgICBpbnRlcnZhbDogc2NhbGVJbnRlcnZhbCA9IHt9LFxuICAgIGxhYmVsOiBzY2FsZUxhYmVsID0ge30sXG4gICAgLi4uc2NhbGVSZXN0XG4gIH0gPSBzY2FsZTI7XG4gIGFzc2VydEVtcHR5KHNjYWxlUmVzdCk7XG4gIGNvbnN0IGNoYXJ0T3B0cyA9IHBpY2tQcm9wcyhvcHRzLCB7XG4gICAgYW5pbWF0aW9uLFxuICAgIGJhY2tncm91bmQsXG4gICAgY29udGFpbmVyLFxuICAgIGNvbnRleHRNZW51LFxuICAgIGZvb3Rub3RlLFxuICAgIGhlaWdodDogaGVpZ2h0MixcbiAgICBsaXN0ZW5lcnMsXG4gICAgbG9jYWxlLFxuICAgIG1pbkhlaWdodCxcbiAgICBtaW5XaWR0aCxcbiAgICBwYWRkaW5nLFxuICAgIHN1YnRpdGxlLFxuICAgIHRoZW1lLFxuICAgIHRpdGxlLFxuICAgIHdpZHRoOiB3aWR0aDJcbiAgfSk7XG4gIGNvbnN0IHNjYWxlT3B0cyA9IHBpY2tQcm9wcyhzY2FsZTIsIHtcbiAgICBmaWxsczogc2NhbGVGaWxscyxcbiAgICBmaWxsTW9kZTogc2NhbGVGaWxsTW9kZSxcbiAgICBmaWxsOiBzY2FsZUZpbGwsXG4gICAgZmlsbE9wYWNpdHk6IHNjYWxlRmlsbE9wYWNpdHksXG4gICAgc3Ryb2tlOiBzY2FsZVN0cm9rZSxcbiAgICBzdHJva2VXaWR0aDogc2NhbGVTdHJva2VXaWR0aCxcbiAgICBzdHJva2VPcGFjaXR5OiBzY2FsZVN0cm9rZU9wYWNpdHksXG4gICAgbGluZURhc2g6IHNjYWxlTGluZURhc2gsXG4gICAgbGluZURhc2hPZmZzZXQ6IHNjYWxlTGluZURhc2hPZmZzZXRcbiAgfSk7XG4gIGNvbnN0IHNlcmllc09wdHMgPSBwaWNrUHJvcHMob3B0cywge1xuICAgIHN0YXJ0QW5nbGU6IElHTk9SRURfUFJPUCxcbiAgICBlbmRBbmdsZTogSUdOT1JFRF9QUk9QLFxuICAgIG5lZWRsZTogbmVlZGxlICE9IG51bGwgPyB7IGVuYWJsZWQ6IHRydWUsIC4uLm5lZWRsZSB9IDogSUdOT1JFRF9QUk9QLFxuICAgIHNjYWxlOiBzY2FsZU9wdHMsXG4gICAgdHlwZSxcbiAgICBjdXJzb3IsXG4gICAgbm9kZUNsaWNrUmFuZ2UsXG4gICAgbGlzdGVuZXJzLFxuICAgIHRvb2x0aXAsXG4gICAgdmFsdWUsXG4gICAgaGlnaGxpZ2h0U3R5bGUsXG4gICAgc2VnbWVudGF0aW9uLFxuICAgIGJhcixcbiAgICB0YXJnZXRzLFxuICAgIG91dGVyUmFkaXVzLFxuICAgIGlubmVyUmFkaXVzLFxuICAgIG91dGVyUmFkaXVzUmF0aW8sXG4gICAgaW5uZXJSYWRpdXNSYXRpbyxcbiAgICBjb3JuZXJSYWRpdXMsXG4gICAgY29ybmVyTW9kZSxcbiAgICBsYWJlbCxcbiAgICBzZWNvbmRhcnlMYWJlbCxcbiAgICBzcGFjaW5nLFxuICAgIC4uLnJlc3RcbiAgfSk7XG4gIGNvbnN0IGF4ZXNPcHRzID0gW1xuICAgIHtcbiAgICAgIHR5cGU6IFwiYW5nbGUtbnVtYmVyXCIsXG4gICAgICBtaW46IHNjYWxlTWluLFxuICAgICAgbWF4OiBzY2FsZU1heCxcbiAgICAgIHN0YXJ0QW5nbGUsXG4gICAgICBlbmRBbmdsZSxcbiAgICAgIGludGVydmFsOiBzY2FsZUludGVydmFsID8/IHt9LFxuICAgICAgbGFiZWw6IHNjYWxlTGFiZWwgPz8ge31cbiAgICB9LFxuICAgIHsgdHlwZTogXCJyYWRpdXMtbnVtYmVyXCIgfVxuICBdO1xuICByZXR1cm4ge1xuICAgIC4uLmNoYXJ0T3B0cyxcbiAgICBzZXJpZXM6IFtzZXJpZXNPcHRzXSxcbiAgICBheGVzOiBheGVzT3B0c1xuICB9O1xufVxuZnVuY3Rpb24gbGluZWFyR2F1Z2VPcHRpb25zKG9wdHMpIHtcbiAgY29uc3Qge1xuICAgIGFuaW1hdGlvbixcbiAgICBiYWNrZ3JvdW5kLFxuICAgIGNvbnRhaW5lcixcbiAgICBjb250ZXh0TWVudSxcbiAgICBmb290bm90ZSxcbiAgICBoZWlnaHQ6IGhlaWdodDIsXG4gICAgbGlzdGVuZXJzLFxuICAgIGxvY2FsZSxcbiAgICBtaW5IZWlnaHQsXG4gICAgbWluV2lkdGgsXG4gICAgcGFkZGluZyxcbiAgICBzdWJ0aXRsZSxcbiAgICB0aGVtZSxcbiAgICB0aXRsZSxcbiAgICB3aWR0aDogd2lkdGgyLFxuICAgIHR5cGUsXG4gICAgY3Vyc29yLFxuICAgIG5vZGVDbGlja1JhbmdlLFxuICAgIHRvb2x0aXAsXG4gICAgdmFsdWUsXG4gICAgc2NhbGU6IHNjYWxlMiA9IHt9LFxuICAgIGRpcmVjdGlvbiA9IFwidmVydGljYWxcIixcbiAgICB0aGlja25lc3MsXG4gICAgaGlnaGxpZ2h0U3R5bGUsXG4gICAgc2VnbWVudGF0aW9uLFxuICAgIGJhcixcbiAgICB0YXJnZXRzLFxuICAgIGNvcm5lclJhZGl1cyxcbiAgICBjb3JuZXJNb2RlLFxuICAgIGxhYmVsLFxuICAgIC4uLnJlc3RcbiAgfSA9IG9wdHM7XG4gIGFzc2VydEVtcHR5KHJlc3QpO1xuICBjb25zdCB7XG4gICAgZmlsbHM6IHNjYWxlRmlsbHMsXG4gICAgZmlsbE1vZGU6IHNjYWxlRmlsbE1vZGUsXG4gICAgZmlsbDogc2NhbGVGaWxsLFxuICAgIGZpbGxPcGFjaXR5OiBzY2FsZUZpbGxPcGFjaXR5LFxuICAgIHN0cm9rZTogc2NhbGVTdHJva2UsXG4gICAgc3Ryb2tlV2lkdGg6IHNjYWxlU3Ryb2tlV2lkdGgsXG4gICAgc3Ryb2tlT3BhY2l0eTogc2NhbGVTdHJva2VPcGFjaXR5LFxuICAgIGxpbmVEYXNoOiBzY2FsZUxpbmVEYXNoLFxuICAgIGxpbmVEYXNoT2Zmc2V0OiBzY2FsZUxpbmVEYXNoT2Zmc2V0LFxuICAgIG1pbjogc2NhbGVNaW4gPSAwLFxuICAgIG1heDogc2NhbGVNYXggPSAxLFxuICAgIGludGVydmFsOiBzY2FsZUludGVydmFsID0ge30sXG4gICAgbGFiZWw6IHNjYWxlTGFiZWwgPSB7fSxcbiAgICAuLi5zY2FsZVJlc3RcbiAgfSA9IHNjYWxlMjtcbiAgYXNzZXJ0RW1wdHkoc2NhbGVSZXN0KTtcbiAgY29uc3QgY2hhcnRPcHRzID0gcGlja1Byb3BzKG9wdHMsIHtcbiAgICBhbmltYXRpb24sXG4gICAgYmFja2dyb3VuZCxcbiAgICBjb250YWluZXIsXG4gICAgY29udGV4dE1lbnUsXG4gICAgZm9vdG5vdGUsXG4gICAgaGVpZ2h0OiBoZWlnaHQyLFxuICAgIGxpc3RlbmVycyxcbiAgICBsb2NhbGUsXG4gICAgbWluSGVpZ2h0LFxuICAgIG1pbldpZHRoLFxuICAgIHBhZGRpbmcsXG4gICAgc3VidGl0bGUsXG4gICAgdGhlbWUsXG4gICAgdGl0bGUsXG4gICAgd2lkdGg6IHdpZHRoMlxuICB9KTtcbiAgY29uc3Qgc2NhbGVPcHRzID0gcGlja1Byb3BzKHNjYWxlMiwge1xuICAgIGZpbGxzOiBzY2FsZUZpbGxzLFxuICAgIGZpbGxNb2RlOiBzY2FsZUZpbGxNb2RlLFxuICAgIGZpbGw6IHNjYWxlRmlsbCxcbiAgICBmaWxsT3BhY2l0eTogc2NhbGVGaWxsT3BhY2l0eSxcbiAgICBzdHJva2U6IHNjYWxlU3Ryb2tlLFxuICAgIHN0cm9rZVdpZHRoOiBzY2FsZVN0cm9rZVdpZHRoLFxuICAgIHN0cm9rZU9wYWNpdHk6IHNjYWxlU3Ryb2tlT3BhY2l0eSxcbiAgICBsaW5lRGFzaDogc2NhbGVMaW5lRGFzaCxcbiAgICBsaW5lRGFzaE9mZnNldDogc2NhbGVMaW5lRGFzaE9mZnNldFxuICB9KTtcbiAgY29uc3Qgc2VyaWVzT3B0cyA9IHBpY2tQcm9wcyhvcHRzLCB7XG4gICAgc2NhbGU6IHNjYWxlT3B0cyxcbiAgICB0eXBlLFxuICAgIGN1cnNvcixcbiAgICBub2RlQ2xpY2tSYW5nZSxcbiAgICBsaXN0ZW5lcnMsXG4gICAgdG9vbHRpcCxcbiAgICB2YWx1ZSxcbiAgICBkaXJlY3Rpb24sXG4gICAgdGhpY2tuZXNzLFxuICAgIGhpZ2hsaWdodFN0eWxlLFxuICAgIHNlZ21lbnRhdGlvbixcbiAgICBiYXIsXG4gICAgdGFyZ2V0cyxcbiAgICBjb3JuZXJSYWRpdXMsXG4gICAgY29ybmVyTW9kZSxcbiAgICBsYWJlbCxcbiAgICAuLi5yZXN0XG4gIH0pO1xuICBjb25zdCB7IHBsYWNlbWVudDogbGFiZWxQbGFjZW1lbnQsIC4uLmF4aXNMYWJlbCB9ID0gc2NhbGVMYWJlbDtcbiAgbGV0IG1haW5BeGlzUG9zaXRpb247XG4gIGxldCBjcm9zc0F4aXNQb3NpdGlvbjtcbiAgY29uc3QgaG9yaXpvbnRhbCA9IGRpcmVjdGlvbiA9PT0gXCJob3Jpem9udGFsXCI7XG4gIGlmIChob3Jpem9udGFsKSB7XG4gICAgbWFpbkF4aXNQb3NpdGlvbiA9IGxhYmVsUGxhY2VtZW50ID09PSBcImJlZm9yZVwiID8gXCJ0b3BcIiA6IFwiYm90dG9tXCI7XG4gICAgY3Jvc3NBeGlzUG9zaXRpb24gPSBcImxlZnRcIjtcbiAgfSBlbHNlIHtcbiAgICBtYWluQXhpc1Bvc2l0aW9uID0gbGFiZWxQbGFjZW1lbnQgPT09IFwiYWZ0ZXJcIiA/IFwicmlnaHRcIiA6IFwibGVmdFwiO1xuICAgIGNyb3NzQXhpc1Bvc2l0aW9uID0gXCJib3R0b21cIjtcbiAgfVxuICBjb25zdCBtYWluQXhpcyA9IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIHBvc2l0aW9uOiBtYWluQXhpc1Bvc2l0aW9uLFxuICAgIG1pbjogc2NhbGVNaW4sXG4gICAgbWF4OiBzY2FsZU1heCxcbiAgICByZXZlcnNlOiAhaG9yaXpvbnRhbCxcbiAgICBpbnRlcnZhbDogc2NhbGVJbnRlcnZhbCxcbiAgICBsYWJlbDogYXhpc0xhYmVsLFxuICAgIG5pY2U6IGZhbHNlXG4gIH07XG4gIGNvbnN0IGNyb3NzQXhpcyA9IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIHBvc2l0aW9uOiBjcm9zc0F4aXNQb3NpdGlvbixcbiAgICBtaW46IDAsXG4gICAgbWF4OiAxLFxuICAgIGxhYmVsOiB7XG4gICAgICBlbmFibGVkOiBmYWxzZVxuICAgIH1cbiAgfTtcbiAgY29uc3QgYXhlc09wdHMgPSBob3Jpem9udGFsID8gW21haW5BeGlzLCBjcm9zc0F4aXNdIDogW2Nyb3NzQXhpcywgbWFpbkF4aXNdO1xuICByZXR1cm4ge1xuICAgIC4uLmNoYXJ0T3B0cyxcbiAgICBzZXJpZXM6IFtzZXJpZXNPcHRzXSxcbiAgICBheGVzOiBheGVzT3B0c1xuICB9O1xufVxuZnVuY3Rpb24gYXBwbHlUaGVtZURlZmF1bHRzKG9wdHMsIHByZXNldFRoZW1lKSB7XG4gIGlmIChwcmVzZXRUaGVtZSA9PSBudWxsKVxuICAgIHJldHVybiBvcHRzO1xuICBjb25zdCB7IHRhcmdldHM6IHRhcmdldHNUaGVtZSwgLi4uZ2F1Z2VUaGVtZSB9ID0gcHJlc2V0VGhlbWU7XG4gIG9wdHMgPSBtZXJnZURlZmF1bHRzKG9wdHMsIGdhdWdlVGhlbWUpO1xuICBpZiAob3B0cy50YXJnZXRzICE9IG51bGwgJiYgdGFyZ2V0c1RoZW1lICE9IG51bGwpIHtcbiAgICBvcHRzLnRhcmdldHMgPSBtZXJnZUFycmF5RGVmYXVsdHMob3B0cy50YXJnZXRzLCB0YXJnZXRzVGhlbWUpO1xuICB9XG4gIHJldHVybiBvcHRzO1xufVxuZnVuY3Rpb24gZ2F1Z2Uob3B0cywgcHJlc2V0VGhlbWUpIHtcbiAgaWYgKGlzUmFkaWFsR2F1Z2Uob3B0cykpIHtcbiAgICBjb25zdCByYWRpYWxHYXVnZU9wdHMgPSBhcHBseVRoZW1lRGVmYXVsdHMob3B0cywgcHJlc2V0VGhlbWUpO1xuICAgIHJldHVybiByYWRpYWxHYXVnZU9wdGlvbnMocmFkaWFsR2F1Z2VPcHRzKTtcbiAgfSBlbHNlIGlmIChpc0xpbmVhckdhdWdlKG9wdHMpKSB7XG4gICAgY29uc3QgbGluZWFyR2F1Z2VPcHRzID0gYXBwbHlUaGVtZURlZmF1bHRzKG9wdHMsIHByZXNldFRoZW1lKTtcbiAgICByZXR1cm4gbGluZWFyR2F1Z2VPcHRpb25zKGxpbmVhckdhdWdlT3B0cyk7XG4gIH1cbiAgY29uc3Qge1xuICAgIGFuaW1hdGlvbixcbiAgICBiYWNrZ3JvdW5kLFxuICAgIGNvbnRhaW5lcixcbiAgICBjb250ZXh0TWVudSxcbiAgICBmb290bm90ZSxcbiAgICBoZWlnaHQ6IGhlaWdodDIsXG4gICAgbGlzdGVuZXJzLFxuICAgIGxvY2FsZSxcbiAgICBtaW5IZWlnaHQsXG4gICAgbWluV2lkdGgsXG4gICAgcGFkZGluZyxcbiAgICBzdWJ0aXRsZSxcbiAgICB0aGVtZSxcbiAgICB0aXRsZSxcbiAgICB3aWR0aDogd2lkdGgyXG4gIH0gPSBvcHRzO1xuICByZXR1cm4gcGlja1Byb3BzKG9wdHMsIHtcbiAgICBhbmltYXRpb24sXG4gICAgYmFja2dyb3VuZCxcbiAgICBjb250YWluZXIsXG4gICAgY29udGV4dE1lbnUsXG4gICAgZm9vdG5vdGUsXG4gICAgaGVpZ2h0OiBoZWlnaHQyLFxuICAgIGxpc3RlbmVycyxcbiAgICBsb2NhbGUsXG4gICAgbWluSGVpZ2h0LFxuICAgIG1pbldpZHRoLFxuICAgIHBhZGRpbmcsXG4gICAgc3VidGl0bGUsXG4gICAgdGhlbWUsXG4gICAgdGl0bGUsXG4gICAgd2lkdGg6IHdpZHRoMlxuICB9KTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvYXBpL3ByZXNldC9wcmljZVZvbHVtZVByZXNldC50c1xuZnVuY3Rpb24gZnJvbVRoZW1lKHRoZW1lLCBjYikge1xuICBpZiAoaXNPYmplY3QodGhlbWUpKSB7XG4gICAgcmV0dXJuIGNiKHRoZW1lKTtcbiAgfVxufVxudmFyIGNoYXJ0VHlwZXMyID0gW1wib2hsY1wiLCBcImxpbmVcIiwgXCJzdGVwLWxpbmVcIiwgXCJobGNcIiwgXCJoaWdoLWxvd1wiLCBcImNhbmRsZXN0aWNrXCIsIFwiaG9sbG93LWNhbmRsZXN0aWNrXCJdO1xuZnVuY3Rpb24gcHJpY2VWb2x1bWUob3B0cywgX3ByZXNldFRoZW1lLCBnZXRUaGVtZSkge1xuICBjb25zdCB7XG4gICAgeEtleSxcbiAgICBkYXRlS2V5ID0geEtleSA/PyBcImRhdGVcIixcbiAgICBoaWdoS2V5ID0gXCJoaWdoXCIsXG4gICAgb3BlbktleSA9IFwib3BlblwiLFxuICAgIGxvd0tleSA9IFwibG93XCIsXG4gICAgY2xvc2VLZXkgPSBcImNsb3NlXCIsXG4gICAgdm9sdW1lS2V5ID0gXCJ2b2x1bWVcIixcbiAgICBjaGFydFR5cGU6IGNoYXJ0VHlwZTIgPSBcImNhbmRsZXN0aWNrXCIsXG4gICAgbmF2aWdhdG9yOiBuYXZpZ2F0b3IyID0gZmFsc2UsXG4gICAgdm9sdW1lID0gdHJ1ZSxcbiAgICByYW5nZVRvb2xiYXIsXG4gICAgcmFuZ2VCdXR0b25zID0gcmFuZ2VUb29sYmFyID8/IHRydWUsXG4gICAgc3RhdHVzQmFyID0gdHJ1ZSxcbiAgICBhbm5vdGF0aW9uczogYW5ub3RhdGlvbnMyLFxuICAgIHRvb2xiYXIgPSBhbm5vdGF0aW9uczIgPz8gdHJ1ZSxcbiAgICB6b29tOiB6b29tMiA9IHRydWUsXG4gICAgdGhlbWUsXG4gICAgZGF0YSxcbiAgICAuLi51bnVzZWRPcHRzXG4gIH0gPSBvcHRzO1xuICBpZiAoeEtleSAhPSBudWxsKSB7XG4gICAgTG9nZ2VyLndhcm5PbmNlKFwiUHJvcGVydHkgW3hLZXldIGlzIGRlcHJlY2F0ZWQsIHVzZSBbZGF0ZUtleV0gaW5zdGVhZC5cIik7XG4gIH1cbiAgaWYgKHJhbmdlVG9vbGJhciAhPSBudWxsKSB7XG4gICAgTG9nZ2VyLndhcm5PbmNlKFwiUHJvcGVydHkgW3JhbmdlVG9vbGJhcl0gaXMgZGVwcmVjYXRlZCwgdXNlIFtyYW5nZUJ1dHRvbnNdIGluc3RlYWQuXCIpO1xuICB9XG4gIGlmIChhbm5vdGF0aW9uczIgIT0gbnVsbCkge1xuICAgIExvZ2dlci53YXJuT25jZShcIlByb3BlcnR5IFthbm5vdGF0aW9uc10gaXMgZGVwcmVjYXRlZCwgdXNlIFt0b29sYmFyXSBpbnN0ZWFkLlwiKTtcbiAgfVxuICBjb25zdCBwcmljZVNlcmllcyA9IGNyZWF0ZVByaWNlU2VyaWVzKHRoZW1lLCBjaGFydFR5cGUyLCBkYXRlS2V5LCBoaWdoS2V5LCBsb3dLZXksIG9wZW5LZXksIGNsb3NlS2V5KTtcbiAgY29uc3Qgdm9sdW1lU2VyaWVzID0gY3JlYXRlVm9sdW1lU2VyaWVzKHRoZW1lLCBnZXRUaGVtZSwgb3BlbktleSwgY2xvc2VLZXksIHZvbHVtZSwgdm9sdW1lS2V5KTtcbiAgY29uc3QgbWluaUNoYXJ0ID0gdm9sdW1lID8ge1xuICAgIG1pbmlDaGFydDoge1xuICAgICAgZW5hYmxlZDogbmF2aWdhdG9yMixcbiAgICAgIHNlcmllczogW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogXCJsaW5lXCIsXG4gICAgICAgICAgeEtleTogZGF0ZUtleSxcbiAgICAgICAgICB5S2V5OiB2b2x1bWVLZXksXG4gICAgICAgICAgbWFya2VyOiB7IGVuYWJsZWQ6IGZhbHNlIH1cbiAgICAgICAgfVxuICAgICAgXVxuICAgIH1cbiAgfSA6IG51bGw7XG4gIGNvbnN0IG5hdmlnYXRvck9wdHMgPSB7XG4gICAgbmF2aWdhdG9yOiB7XG4gICAgICBlbmFibGVkOiBuYXZpZ2F0b3IyLFxuICAgICAgLi4ubWluaUNoYXJ0XG4gICAgfVxuICB9O1xuICBjb25zdCBhbm5vdGF0aW9uT3B0cyA9IHtcbiAgICBhbm5vdGF0aW9uczoge1xuICAgICAgZW5hYmxlZDogdG9vbGJhcixcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgIGRhdGEsXG4gICAgICB4S2V5OiBkYXRlS2V5LFxuICAgICAgdm9sdW1lS2V5OiB2b2x1bWUgPyB2b2x1bWVLZXkgOiB2b2lkIDBcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN0YXR1c0Jhck9wdHMgPSBzdGF0dXNCYXIgPyB7XG4gICAgc3RhdHVzQmFyOiB7XG4gICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgZGF0YSxcbiAgICAgIGhpZ2hLZXksXG4gICAgICBvcGVuS2V5LFxuICAgICAgbG93S2V5LFxuICAgICAgY2xvc2VLZXksXG4gICAgICB2b2x1bWVLZXk6IHZvbHVtZSA/IHZvbHVtZUtleSA6IHZvaWQgMFxuICAgIH1cbiAgfSA6IG51bGw7XG4gIGNvbnN0IHpvb21PcHRzID0ge1xuICAgIHpvb206IHtcbiAgICAgIGVuYWJsZWQ6IHpvb20yLFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgZW5hYmxlSW5kZXBlbmRlbnRBeGVzOiB0cnVlXG4gICAgfVxuICB9O1xuICBjb25zdCB0b29sYmFyT3B0cyA9IHtcbiAgICBjaGFydFRvb2xiYXI6IHsgZW5hYmxlZDogdHJ1ZSB9LFxuICAgIHRvb2xiYXI6IHtcbiAgICAgIHNlcmllc1R5cGU6IHtcbiAgICAgICAgZW5hYmxlZDogdG9vbGJhclxuICAgICAgfSxcbiAgICAgIGFubm90YXRpb25PcHRpb25zOiB7XG4gICAgICAgIGVuYWJsZWQ6IHRvb2xiYXJcbiAgICAgIH0sXG4gICAgICBhbm5vdGF0aW9uczoge1xuICAgICAgICBlbmFibGVkOiB0b29sYmFyXG4gICAgICB9LFxuICAgICAgcmFuZ2VzOiB7XG4gICAgICAgIGVuYWJsZWQ6IHJhbmdlQnV0dG9uc1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3Qgdm9sdW1lQXhpcyA9IHZvbHVtZSA/IFtcbiAgICB7XG4gICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgcG9zaXRpb246IFwibGVmdFwiLFxuICAgICAga2V5czogW3ZvbHVtZUtleV0sXG4gICAgICBsYWJlbDogeyBlbmFibGVkOiBmYWxzZSB9LFxuICAgICAgY3Jvc3NoYWlyOiB7IGVuYWJsZWQ6IGZhbHNlIH0sXG4gICAgICBncmlkTGluZTogeyBlbmFibGVkOiBmYWxzZSB9LFxuICAgICAgbmljZTogZmFsc2UsXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICBsYXlvdXRDb25zdHJhaW50czoge1xuICAgICAgICBzdGFja2VkOiBmYWxzZSxcbiAgICAgICAgd2lkdGg6IDIwLFxuICAgICAgICB1bml0OiBcInBlcmNlbnRhZ2VcIixcbiAgICAgICAgYWxpZ246IFwiZW5kXCJcbiAgICAgIH1cbiAgICB9XG4gIF0gOiBbXTtcbiAgcmV0dXJuIHtcbiAgICB0aGVtZToge1xuICAgICAgYmFzZVRoZW1lOiB0eXBlb2YgdGhlbWUgPT09IFwic3RyaW5nXCIgPyB0aGVtZSA6IFwiYWctZmluYW5jaWFsXCIsXG4gICAgICAuLi5tZXJnZURlZmF1bHRzKHR5cGVvZiB0aGVtZSA9PT0gXCJvYmplY3RcIiA/IHRoZW1lIDogbnVsbCwge1xuICAgICAgICBvdmVycmlkZXM6IHtcbiAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgIHRpdGxlOiB7IHBhZGRpbmc6IDQgfSxcbiAgICAgICAgICAgIHBhZGRpbmc6IHtcbiAgICAgICAgICAgICAgdG9wOiA2LFxuICAgICAgICAgICAgICByaWdodDogOCxcbiAgICAgICAgICAgICAgYm90dG9tOiA1XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0sXG4gICAgYW5pbWF0aW9uOiB7IGVuYWJsZWQ6IGZhbHNlIH0sXG4gICAgbGVnZW5kOiB7IGVuYWJsZWQ6IGZhbHNlIH0sXG4gICAgc2VyaWVzOiBbLi4udm9sdW1lU2VyaWVzLCAuLi5wcmljZVNlcmllc10sXG4gICAgYXhlczogW1xuICAgICAge1xuICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICBwb3NpdGlvbjogXCJyaWdodFwiLFxuICAgICAgICBrZXlzOiBbb3BlbktleSwgY2xvc2VLZXksIGhpZ2hLZXksIGxvd0tleV0sXG4gICAgICAgIGludGVydmFsOiB7XG4gICAgICAgICAgbWF4U3BhY2luZzogZnJvbVRoZW1lKHRoZW1lLCAodCkgPT4gdC5vdmVycmlkZXM/LmNvbW1vbj8uYXhlcz8ubnVtYmVyPy5pbnRlcnZhbD8ubWF4U3BhY2luZykgPz8gNDVcbiAgICAgICAgfSxcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICBmb3JtYXQ6IGZyb21UaGVtZSh0aGVtZSwgKHQpID0+IHQub3ZlcnJpZGVzPy5jb21tb24/LmF4ZXM/Lm51bWJlcj8ubGFiZWw/LmZvcm1hdCkgPz8gXCIuMmZcIlxuICAgICAgICB9LFxuICAgICAgICBjcm9zc2hhaXI6IHtcbiAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgIHNuYXA6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgbGF5b3V0Q29uc3RyYWludHM6IHtcbiAgICAgICAgICBzdGFja2VkOiBmYWxzZSxcbiAgICAgICAgICB3aWR0aDogMTAwLFxuICAgICAgICAgIHVuaXQ6IFwicGVyY2VudGFnZVwiLFxuICAgICAgICAgIGFsaWduOiBcInN0YXJ0XCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC4uLnZvbHVtZUF4aXMsXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwib3JkaW5hbC10aW1lXCIsXG4gICAgICAgIHBvc2l0aW9uOiBcImJvdHRvbVwiLFxuICAgICAgICBsaW5lOiB7XG4gICAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICBlbmFibGVkOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIGNyb3NzaGFpcjoge1xuICAgICAgICAgIGVuYWJsZWQ6IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIF0sXG4gICAgdG9vbHRpcDogeyBlbmFibGVkOiBmYWxzZSB9LFxuICAgIGRhdGEsXG4gICAgLi4uYW5ub3RhdGlvbk9wdHMsXG4gICAgLi4ubmF2aWdhdG9yT3B0cyxcbiAgICAuLi5zdGF0dXNCYXJPcHRzLFxuICAgIC4uLnpvb21PcHRzLFxuICAgIC4uLnRvb2xiYXJPcHRzLFxuICAgIC4uLnVudXNlZE9wdHNcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVZvbHVtZVNlcmllcyh0aGVtZSwgZ2V0VGhlbWUsIG9wZW5LZXksIGNsb3NlS2V5LCB2b2x1bWUsIHZvbHVtZUtleSkge1xuICBpZiAoIXZvbHVtZSlcbiAgICByZXR1cm4gW107XG4gIGNvbnN0IGJhclNlcmllc0ZpbGwgPSBmcm9tVGhlbWUodGhlbWUsICh0KSA9PiB0Lm92ZXJyaWRlcz8uYmFyPy5zZXJpZXM/LmZpbGwpO1xuICBjb25zdCBpdGVtU3R5bGVyID0gYmFyU2VyaWVzRmlsbCA/IHsgZmlsbDogYmFyU2VyaWVzRmlsbCB9IDoge1xuICAgIGl0ZW1TdHlsZXIoeyBkYXR1bSB9KSB7XG4gICAgICBjb25zdCB7IHVwLCBkb3duIH0gPSBnZXRUaGVtZSgpLnBhbGV0dGU7XG4gICAgICByZXR1cm4geyBmaWxsOiBkYXR1bVtvcGVuS2V5XSA8IGRhdHVtW2Nsb3NlS2V5XSA/IHVwPy5maWxsIDogZG93bj8uZmlsbCB9O1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIFtcbiAgICB7XG4gICAgICB0eXBlOiBcImJhclwiLFxuICAgICAgeEtleTogXCJkYXRlXCIsXG4gICAgICB5S2V5OiB2b2x1bWVLZXksXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICBmb2N1c1ByaW9yaXR5OiAxLFxuICAgICAgdG9vbHRpcDogeyBlbmFibGVkOiBmYWxzZSB9LFxuICAgICAgaGlnaGxpZ2h0OiB7IGVuYWJsZWQ6IGZhbHNlIH0sXG4gICAgICBmaWxsT3BhY2l0eTogZnJvbVRoZW1lKHRoZW1lLCAodCkgPT4gdC5vdmVycmlkZXM/LmJhcj8uc2VyaWVzPy5maWxsT3BhY2l0eSkgPz8gMC41LFxuICAgICAgLi4uaXRlbVN0eWxlclxuICAgIH1cbiAgXTtcbn1cbnZhciBSQU5HRV9BUkVBX1RZUEUgPSBcInJhbmdlLWFyZWFcIjtcbmZ1bmN0aW9uIGNyZWF0ZVByaWNlU2VyaWVzKHRoZW1lLCBjaGFydFR5cGUyLCB4S2V5LCBoaWdoS2V5LCBsb3dLZXksIG9wZW5LZXksIGNsb3NlS2V5KSB7XG4gIGlmIChjaGFydFR5cGUyID09PSBSQU5HRV9BUkVBX1RZUEUpIHtcbiAgICBMb2dnZXIud2Fybk9uY2UoYHR5cGUgJyR7Y2hhcnRUeXBlMn0nIGlzIGRlcHJlY2F0ZWQsIHVzZSAnaGxjJyBjaGFydCB0eXBlIGluc3RlYWRgKTtcbiAgICBjaGFydFR5cGUyID0gXCJobGNcIjtcbiAgfVxuICBjb25zdCBrZXlzID0ge1xuICAgIHhLZXksXG4gICAgb3BlbktleSxcbiAgICBjbG9zZUtleSxcbiAgICBoaWdoS2V5LFxuICAgIGxvd0tleVxuICB9O1xuICBjb25zdCBzaW5nbGVLZXlzID0ge1xuICAgIHhLZXksXG4gICAgeUtleTogY2xvc2VLZXlcbiAgfTtcbiAgY29uc3QgY29tbW9uID0ge1xuICAgIHBpY2tPdXRzaWRlVmlzaWJsZU1pbm9yQXhpczogdHJ1ZVxuICB9O1xuICBzd2l0Y2ggKGNoYXJ0VHlwZTIgPz8gXCJjYW5kbGVzdGlja1wiKSB7XG4gICAgY2FzZSBcIm9obGNcIjpcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcIm9obGNcIixcbiAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgZm9jdXNQcmlvcml0eTogMCxcbiAgICAgICAgICAuLi5jb21tb24sXG4gICAgICAgICAgLi4ua2V5c1xuICAgICAgICB9XG4gICAgICBdO1xuICAgIGNhc2UgXCJsaW5lXCI6XG4gICAgICByZXR1cm4gW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogXCJsaW5lXCIsXG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgIGZvY3VzUHJpb3JpdHk6IDAsXG4gICAgICAgICAgLi4uY29tbW9uLFxuICAgICAgICAgIC4uLnNpbmdsZUtleXMsXG4gICAgICAgICAgc3Ryb2tlOiBmcm9tVGhlbWUodGhlbWUsICh0KSA9PiB0Lm92ZXJyaWRlcz8ubGluZT8uc2VyaWVzPy5zdHJva2UpID8/IFBBTEVUVEVfTkVVVFJBTF9TVFJPS0UsXG4gICAgICAgICAgbWFya2VyOiBmcm9tVGhlbWUodGhlbWUsICh0KSA9PiB0Lm92ZXJyaWRlcz8ubGluZT8uc2VyaWVzPy5tYXJrZXIpID8/IHsgZW5hYmxlZDogZmFsc2UgfVxuICAgICAgICB9XG4gICAgICBdO1xuICAgIGNhc2UgXCJzdGVwLWxpbmVcIjpcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcImxpbmVcIixcbiAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgZm9jdXNQcmlvcml0eTogMCxcbiAgICAgICAgICAuLi5jb21tb24sXG4gICAgICAgICAgLi4uc2luZ2xlS2V5cyxcbiAgICAgICAgICBzdHJva2U6IGZyb21UaGVtZSh0aGVtZSwgKHQpID0+IHQub3ZlcnJpZGVzPy5saW5lPy5zZXJpZXM/LnN0cm9rZSkgPz8gUEFMRVRURV9ORVVUUkFMX1NUUk9LRSxcbiAgICAgICAgICBpbnRlcnBvbGF0aW9uOiBmcm9tVGhlbWUodGhlbWUsICh0KSA9PiB0Lm92ZXJyaWRlcz8ubGluZT8uc2VyaWVzPy5pbnRlcnBvbGF0aW9uKSA/PyB7XG4gICAgICAgICAgICB0eXBlOiBcInN0ZXBcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgbWFya2VyOiBmcm9tVGhlbWUodGhlbWUsICh0KSA9PiB0Lm92ZXJyaWRlcz8ubGluZT8uc2VyaWVzPy5tYXJrZXIpID8/IHsgZW5hYmxlZDogZmFsc2UgfVxuICAgICAgICB9XG4gICAgICBdO1xuICAgIGNhc2UgXCJobGNcIjoge1xuICAgICAgY29uc3QgcmFuZ2VBcmVhQ29sb3JzID0gZ2V0VGhlbWVDb2xvcnMoUkFOR0VfQVJFQV9UWVBFLCB0aGVtZSk7XG4gICAgICByZXR1cm4gW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogUkFOR0VfQVJFQV9UWVBFLFxuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICBmb2N1c1ByaW9yaXR5OiAwLFxuICAgICAgICAgIC4uLmNvbW1vbixcbiAgICAgICAgICB4S2V5LFxuICAgICAgICAgIHlIaWdoS2V5OiBoaWdoS2V5LFxuICAgICAgICAgIHlMb3dLZXk6IGNsb3NlS2V5LFxuICAgICAgICAgIGZpbGw6IHJhbmdlQXJlYUNvbG9ycy5maWxsID8/IFBBTEVUVEVfVVBfRklMTCxcbiAgICAgICAgICBzdHJva2U6IHJhbmdlQXJlYUNvbG9ycy5zdHJva2UgPz8gUEFMRVRURV9VUF9TVFJPS0UsXG4gICAgICAgICAgZmlsbE9wYWNpdHk6IGZyb21UaGVtZSh0aGVtZSwgKHQpID0+IHQub3ZlcnJpZGVzPy5bXCJyYW5nZS1hcmVhXCJdPy5zZXJpZXM/LmZpbGxPcGFjaXR5KSA/PyAwLjMsXG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IGZyb21UaGVtZSh0aGVtZSwgKHQpID0+IHQub3ZlcnJpZGVzPy5bXCJyYW5nZS1hcmVhXCJdPy5zZXJpZXM/LnN0cm9rZVdpZHRoKSA/PyAyXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBSQU5HRV9BUkVBX1RZUEUsXG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgIGZvY3VzUHJpb3JpdHk6IDAsXG4gICAgICAgICAgLi4uY29tbW9uLFxuICAgICAgICAgIHhLZXksXG4gICAgICAgICAgeUhpZ2hLZXk6IGNsb3NlS2V5LFxuICAgICAgICAgIHlMb3dLZXk6IGxvd0tleSxcbiAgICAgICAgICBmaWxsOiByYW5nZUFyZWFDb2xvcnMuZmlsbCA/PyBQQUxFVFRFX0RPV05fRklMTCxcbiAgICAgICAgICBzdHJva2U6IHJhbmdlQXJlYUNvbG9ycy5zdHJva2UgPz8gUEFMRVRURV9ET1dOX1NUUk9LRSxcbiAgICAgICAgICBmaWxsT3BhY2l0eTogZnJvbVRoZW1lKHRoZW1lLCAodCkgPT4gdC5vdmVycmlkZXM/LltcInJhbmdlLWFyZWFcIl0/LnNlcmllcz8uZmlsbE9wYWNpdHkpID8/IDAuMyxcbiAgICAgICAgICBzdHJva2VXaWR0aDogZnJvbVRoZW1lKHRoZW1lLCAodCkgPT4gdC5vdmVycmlkZXM/LltcInJhbmdlLWFyZWFcIl0/LnNlcmllcz8uc3Ryb2tlV2lkdGgpID8/IDJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwibGluZVwiLFxuICAgICAgICAgIC4uLmNvbW1vbixcbiAgICAgICAgICAuLi5zaW5nbGVLZXlzLFxuICAgICAgICAgIHN0cm9rZTogZnJvbVRoZW1lKHRoZW1lLCAodCkgPT4gdC5vdmVycmlkZXM/LmxpbmU/LnNlcmllcz8uc3Ryb2tlKSA/PyBQQUxFVFRFX0FMVF9ORVVUUkFMX1NUUk9LRSxcbiAgICAgICAgICBzdHJva2VXaWR0aDogZnJvbVRoZW1lKHRoZW1lLCAodCkgPT4gdC5vdmVycmlkZXM/LmxpbmU/LnNlcmllcz8uc3Ryb2tlV2lkdGgpID8/IDIsXG4gICAgICAgICAgbWFya2VyOiBmcm9tVGhlbWUodGhlbWUsICh0KSA9PiB0Lm92ZXJyaWRlcz8ubGluZT8uc2VyaWVzPy5tYXJrZXIpID8/IHsgZW5hYmxlZDogZmFsc2UgfVxuICAgICAgICB9XG4gICAgICBdO1xuICAgIH1cbiAgICBjYXNlIFwiaGlnaC1sb3dcIjoge1xuICAgICAgY29uc3QgcmFuZ2VCYXJDb2xvcnMgPSBnZXRUaGVtZUNvbG9ycyhcInJhbmdlLWJhclwiLCB0aGVtZSk7XG4gICAgICByZXR1cm4gW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogXCJyYW5nZS1iYXJcIixcbiAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgZm9jdXNQcmlvcml0eTogMCxcbiAgICAgICAgICAuLi5jb21tb24sXG4gICAgICAgICAgeEtleSxcbiAgICAgICAgICB5SGlnaEtleTogaGlnaEtleSxcbiAgICAgICAgICB5TG93S2V5OiBsb3dLZXksXG4gICAgICAgICAgZmlsbDogcmFuZ2VCYXJDb2xvcnMuZmlsbCA/PyBQQUxFVFRFX05FVVRSQUxfRklMTCxcbiAgICAgICAgICBzdHJva2U6IHJhbmdlQmFyQ29sb3JzLnN0cm9rZSA/PyBQQUxFVFRFX05FVVRSQUxfU1RST0tFLFxuICAgICAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgICAgIHJhbmdlOiBcIm5lYXJlc3RcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgXTtcbiAgICB9XG4gICAgY2FzZSBcImNhbmRsZXN0aWNrXCI6XG4gICAgICByZXR1cm4gW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogXCJjYW5kbGVzdGlja1wiLFxuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICBmb2N1c1ByaW9yaXR5OiAwLFxuICAgICAgICAgIC4uLmNvbW1vbixcbiAgICAgICAgICAuLi5rZXlzXG4gICAgICAgIH1cbiAgICAgIF07XG4gICAgY2FzZSBcImhvbGxvdy1jYW5kbGVzdGlja1wiOiB7XG4gICAgICBjb25zdCBpdGVtID0gZnJvbVRoZW1lKHRoZW1lLCAodCkgPT4gdC5vdmVycmlkZXM/LmNhbmRsZXN0aWNrPy5zZXJpZXM/Lml0ZW0pO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwiY2FuZGxlc3RpY2tcIixcbiAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgZm9jdXNQcmlvcml0eTogMCxcbiAgICAgICAgICAuLi5jb21tb24sXG4gICAgICAgICAgLi4ua2V5cyxcbiAgICAgICAgICBpdGVtOiB7XG4gICAgICAgICAgICB1cDoge1xuICAgICAgICAgICAgICBmaWxsOiBpdGVtPy51cD8uZmlsbCA/PyBcInRyYW5zcGFyZW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIF07XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICBMb2dnZXIud2Fybk9uY2UoYHVua25vd24gY2hhcnQgdHlwZTogJHtjaGFydFR5cGUyfTsgZXhwZWN0ZWQgb25lIG9mOiAke2NoYXJ0VHlwZXMyLmpvaW4oXCIsIFwiKX1gKTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcImNhbmRsZXN0aWNrXCIsXG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgIGZvY3VzUHJpb3JpdHk6IDAsXG4gICAgICAgICAgLi4uY29tbW9uLFxuICAgICAgICAgIC4uLmtleXNcbiAgICAgICAgfVxuICAgICAgXTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0VGhlbWVDb2xvcnMoc2VyaWVzVHlwZTIsIHRoZW1lKSB7XG4gIGNvbnN0IGZpbGwgPSBmcm9tVGhlbWUodGhlbWUsICh0KSA9PiB0Lm92ZXJyaWRlcz8uW3Nlcmllc1R5cGUyXT8uc2VyaWVzPy5maWxsKTtcbiAgY29uc3Qgc3Ryb2tlID0gZnJvbVRoZW1lKHRoZW1lLCAodCkgPT4gdC5vdmVycmlkZXM/LltzZXJpZXNUeXBlMl0/LnNlcmllcz8uc3Ryb2tlKTtcbiAgcmV0dXJuIHsgZmlsbCwgc3Ryb2tlIH07XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2FwaS9wcmVzZXQvc3BhcmtsaW5lLnRzXG52YXIgY29tbW9uQXhpc1Byb3BlcnRpZXMgPSB7XG4gIGxpbmU6IHtcbiAgICBlbmFibGVkOiBmYWxzZVxuICB9LFxuICB0aXRsZToge1xuICAgIGVuYWJsZWQ6IGZhbHNlXG4gIH0sXG4gIGxhYmVsOiB7XG4gICAgZW5hYmxlZDogZmFsc2VcbiAgfSxcbiAgY3Jvc3NoYWlyOiB7XG4gICAgZW5hYmxlZDogZmFsc2UsXG4gICAgc3Ryb2tlT3BhY2l0eTogMC4yNSxcbiAgICBsaW5lRGFzaDogWzBdLFxuICAgIGxhYmVsOiB7XG4gICAgICBlbmFibGVkOiBmYWxzZVxuICAgIH1cbiAgfVxufTtcbnZhciBudW1lcmljQXhpc1Byb3BlcnRpZXMgPSB7XG4gIC4uLmNvbW1vbkF4aXNQcm9wZXJ0aWVzLFxuICBuaWNlOiBmYWxzZVxufTtcbnZhciBib3R0b21Dcm9zc0hhaXJBeGlzUHJvcGVydGllcyA9IHtcbiAgYm90dG9tOiB7XG4gICAgY3Jvc3NoYWlyOiB7XG4gICAgICBlbmFibGVkOiBJU19FTlRFUlBSSVNFXG4gICAgfVxuICB9XG59O1xudmFyIGNyb3NzSGFpckF4ZXMgPSB7XG4gIGNhdGVnb3J5OiBib3R0b21Dcm9zc0hhaXJBeGlzUHJvcGVydGllcyxcbiAgbnVtYmVyOiBib3R0b21Dcm9zc0hhaXJBeGlzUHJvcGVydGllcyxcbiAgbG9nOiBib3R0b21Dcm9zc0hhaXJBeGlzUHJvcGVydGllcyxcbiAgdGltZTogYm90dG9tQ3Jvc3NIYWlyQXhpc1Byb3BlcnRpZXNcbn07XG52YXIgY3Jvc3NIYWlyVG9vbHRpcCA9IHtcbiAgcG9zaXRpb246IHtcbiAgICB0eXBlOiBcInNwYXJrbGluZVwiXG4gIH1cbn07XG52YXIgU1BBUktMSU5FX1RIRU1FID0ge1xuICBvdmVycmlkZXM6IHtcbiAgICBjb21tb246IHtcbiAgICAgIGFuaW1hdGlvbjoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgfSxcbiAgICAgIHBhZGRpbmc6IHtcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICByaWdodDogMCxcbiAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICBsZWZ0OiAwXG4gICAgICB9LFxuICAgICAgYXhlczoge1xuICAgICAgICBudW1iZXI6IHtcbiAgICAgICAgICAuLi5udW1lcmljQXhpc1Byb3BlcnRpZXMsXG4gICAgICAgICAgaW50ZXJ2YWw6IHtcbiAgICAgICAgICAgIHZhbHVlczogWzBdXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBsb2c6IHtcbiAgICAgICAgICAuLi5udW1lcmljQXhpc1Byb3BlcnRpZXNcbiAgICAgICAgfSxcbiAgICAgICAgdGltZToge1xuICAgICAgICAgIC4uLm51bWVyaWNBeGlzUHJvcGVydGllc1xuICAgICAgICB9LFxuICAgICAgICBjYXRlZ29yeToge1xuICAgICAgICAgIC4uLmNvbW1vbkF4aXNQcm9wZXJ0aWVzLFxuICAgICAgICAgIGdyaWRMaW5lOiB7XG4gICAgICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgYmFyOiB7XG4gICAgICBzZXJpZXM6IHtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBzcGFya2xpbmVNb2RlOiB0cnVlXG4gICAgICB9LFxuICAgICAgdG9vbHRpcDoge1xuICAgICAgICByYW5nZTogXCJuZWFyZXN0XCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGxpbmU6IHtcbiAgICAgIHNlcmllc0FyZWE6IHtcbiAgICAgICAgcGFkZGluZzoge1xuICAgICAgICAgIHRvcDogMixcbiAgICAgICAgICByaWdodDogMixcbiAgICAgICAgICBib3R0b206IDIsXG4gICAgICAgICAgbGVmdDogMlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYXhlczogY3Jvc3NIYWlyQXhlcyxcbiAgICAgIHNlcmllczoge1xuICAgICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgICAgbWFya2VyOiB7XG4gICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgc2l6ZTogM1xuICAgICAgICB9LFxuICAgICAgICB0b29sdGlwOiBjcm9zc0hhaXJUb29sdGlwXG4gICAgICB9XG4gICAgfSxcbiAgICBhcmVhOiB7XG4gICAgICBzZXJpZXNBcmVhOiB7XG4gICAgICAgIHBhZGRpbmc6IHtcbiAgICAgICAgICB0b3A6IDEsXG4gICAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgICAgYm90dG9tOiAxLFxuICAgICAgICAgIGxlZnQ6IDBcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGF4ZXM6IGNyb3NzSGFpckF4ZXMsXG4gICAgICBzZXJpZXM6IHtcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDEsXG4gICAgICAgIGZpbGxPcGFjaXR5OiAwLjQsXG4gICAgICAgIHRvb2x0aXA6IGNyb3NzSGFpclRvb2x0aXBcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBzZXRJbml0aWFsQmFzZVRoZW1lKGJhc2VUaGVtZSwgaW5pdGlhbEJhc2VUaGVtZSkge1xuICBpZiAodHlwZW9mIGJhc2VUaGVtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5pbml0aWFsQmFzZVRoZW1lLFxuICAgICAgYmFzZVRoZW1lXG4gICAgfTtcbiAgfVxuICBpZiAoYmFzZVRoZW1lICE9IG51bGwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uYmFzZVRoZW1lLFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBpbnRlcm5hbCBpbXBsZW1lbnRhdGlvblxuICAgICAgYmFzZVRoZW1lOiBzZXRJbml0aWFsQmFzZVRoZW1lKGJhc2VUaGVtZS5iYXNlVGhlbWUsIGluaXRpYWxCYXNlVGhlbWUpXG4gICAgfTtcbiAgfVxuICByZXR1cm4gaW5pdGlhbEJhc2VUaGVtZTtcbn1cbmZ1bmN0aW9uIHNwYXJrbGluZShvcHRzKSB7XG4gIGNvbnN0IHtcbiAgICBiYWNrZ3JvdW5kLFxuICAgIGNvbnRhaW5lcixcbiAgICBoZWlnaHQ6IGhlaWdodDIsXG4gICAgbGlzdGVuZXJzLFxuICAgIGxvY2FsZSxcbiAgICBtaW5IZWlnaHQsXG4gICAgbWluV2lkdGgsXG4gICAgcGFkZGluZyxcbiAgICB3aWR0aDogd2lkdGgyLFxuICAgIHRoZW1lOiBiYXNlVGhlbWUsXG4gICAgZGF0YSxcbiAgICB4QXhpcyxcbiAgICB5QXhpcyxcbiAgICAuLi5vcHRzUmVzdFxuICB9ID0gb3B0cztcbiAgYXNzZXJ0RW1wdHkob3B0c1Jlc3QpO1xuICBjb25zdCBzZXJpZXNPcHRpb25zID0gb3B0c1Jlc3Q7XG4gIGNvbnN0IHN3YXBBeGVzID0gc2VyaWVzT3B0aW9ucy50eXBlICE9PSBcImJhclwiIHx8IHNlcmllc09wdGlvbnMuZGlyZWN0aW9uICE9PSBcImhvcml6b250YWxcIjtcbiAgY29uc3QgY2hhcnRPcHRzID0gcGlja1Byb3BzKG9wdHMsIHtcbiAgICBiYWNrZ3JvdW5kLFxuICAgIGNvbnRhaW5lcixcbiAgICBoZWlnaHQ6IGhlaWdodDIsXG4gICAgbGlzdGVuZXJzLFxuICAgIGxvY2FsZSxcbiAgICBtaW5IZWlnaHQsXG4gICAgbWluV2lkdGgsXG4gICAgcGFkZGluZyxcbiAgICB3aWR0aDogd2lkdGgyLFxuICAgIGRhdGEsXG4gICAgeEF4aXM6IElHTk9SRURfUFJPUCxcbiAgICB5QXhpczogSUdOT1JFRF9QUk9QLFxuICAgIHRoZW1lOiBJR05PUkVEX1BST1BcbiAgfSk7XG4gIGNoYXJ0T3B0cy50aGVtZSA9IHNldEluaXRpYWxCYXNlVGhlbWUoYmFzZVRoZW1lLCBTUEFSS0xJTkVfVEhFTUUpO1xuICBjaGFydE9wdHMuc2VyaWVzID0gW3Nlcmllc09wdGlvbnNdO1xuICBjaGFydE9wdHMuYXhlcyA9IHN3YXBBeGVzID8gW1xuICAgIHsgdHlwZTogXCJudW1iZXJcIiwgLi4ueUF4aXMsIHBvc2l0aW9uOiBcImxlZnRcIiB9LFxuICAgIHsgdHlwZTogXCJjYXRlZ29yeVwiLCAuLi54QXhpcywgcG9zaXRpb246IFwiYm90dG9tXCIgfVxuICBdIDogW1xuICAgIHsgdHlwZTogXCJjYXRlZ29yeVwiLCAuLi54QXhpcywgcG9zaXRpb246IFwibGVmdFwiIH0sXG4gICAgeyB0eXBlOiBcIm51bWJlclwiLCAuLi55QXhpcywgcG9zaXRpb246IFwiYm90dG9tXCIgfVxuICBdO1xuICByZXR1cm4gY2hhcnRPcHRzO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9hcGkvcHJlc2V0L3ByZXNldHMudHNcbnZhciBQUkVTRVRTID0ge1xuICBcInByaWNlLXZvbHVtZVwiOiBwcmljZVZvbHVtZSxcbiAgZ2F1Z2UsXG4gIHNwYXJrbGluZVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvZmFjdG9yeS9wcm9jZXNzRW50ZXJwcmlzZU9wdGlvbnMudHNcbmZ1bmN0aW9uIHJlbW92ZVVzZWRFbnRlcnByaXNlT3B0aW9ucyhvcHRpb25zLCBzaWxlbnQpIHtcbiAgbGV0IHVzZWRPcHRpb25zID0gW107XG4gIGNvbnN0IGlzR2F1Z2VDaGFydCA9IGlzQWdHYXVnZUNoYXJ0T3B0aW9ucyhvcHRpb25zKTtcbiAgY29uc3QgdHlwZSA9IG9wdGlvbnNUeXBlKG9wdGlvbnMpO1xuICBjb25zdCBvcHRpb25zQ2hhcnRUeXBlID0gdHlwZSA/IGNoYXJ0VHlwZXMuZ2V0KHR5cGUpIDogXCJ1bmtub3duXCI7XG4gIGZvciAoY29uc3Qge1xuICAgIHR5cGU6IHR5cGUyLFxuICAgIGNoYXJ0VHlwZXM6IG1vZHVsZUNoYXJ0VHlwZXMsXG4gICAgb3B0aW9uc0tleSxcbiAgICBvcHRpb25zSW5uZXJLZXksXG4gICAgaWRlbnRpZmllclxuICB9IG9mIEVYUEVDVEVEX0VOVEVSUFJJU0VfTU9EVUxFUykge1xuICAgIGlmIChvcHRpb25zQ2hhcnRUeXBlICE9PSBcInVua25vd25cIiAmJiAhbW9kdWxlQ2hhcnRUeXBlcy5pbmNsdWRlcyhvcHRpb25zQ2hhcnRUeXBlKSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIGlmICh0eXBlMiA9PT0gXCJyb290XCIgfHwgdHlwZTIgPT09IFwibGVnZW5kXCIpIHtcbiAgICAgIGNvbnN0IG9wdGlvblZhbHVlID0gb3B0aW9uc1tvcHRpb25zS2V5XTtcbiAgICAgIGlmIChvcHRpb25WYWx1ZSA9PSBudWxsKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGlmICghb3B0aW9uc0lubmVyS2V5KSB7XG4gICAgICAgIHVzZWRPcHRpb25zLnB1c2gob3B0aW9uc0tleSk7XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zW29wdGlvbnNLZXldO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25WYWx1ZVtvcHRpb25zSW5uZXJLZXldKSB7XG4gICAgICAgIHVzZWRPcHRpb25zLnB1c2goYCR7b3B0aW9uc0tleX0uJHtvcHRpb25zSW5uZXJLZXl9YCk7XG4gICAgICAgIGRlbGV0ZSBvcHRpb25WYWx1ZVtvcHRpb25zSW5uZXJLZXldO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZTIgPT09IFwiYXhpc1wiKSB7XG4gICAgICBpZiAoIShcImF4ZXNcIiBpbiBvcHRpb25zKSB8fCAhb3B0aW9ucy5heGVzPy5zb21lKChheGlzKSA9PiBheGlzLnR5cGUgPT09IGlkZW50aWZpZXIpKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHVzZWRPcHRpb25zLnB1c2goYGF4aXNbdHlwZT0ke2lkZW50aWZpZXJ9XWApO1xuICAgICAgb3B0aW9ucy5heGVzID0gb3B0aW9ucy5heGVzLmZpbHRlcigoYXhpcykgPT4gYXhpcy50eXBlICE9PSBpZGVudGlmaWVyKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUyID09PSBcImF4aXMtb3B0aW9uXCIpIHtcbiAgICAgIGlmICghKFwiYXhlc1wiIGluIG9wdGlvbnMpIHx8ICFvcHRpb25zLmF4ZXM/LnNvbWUoKGF4aXMpID0+IGF4aXNbb3B0aW9uc0tleV0pKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHVzZWRPcHRpb25zLnB1c2goYGF4aXMuJHtvcHRpb25zS2V5fWApO1xuICAgICAgb3B0aW9ucy5heGVzLmZvckVhY2goKGF4aXMpID0+IHtcbiAgICAgICAgaWYgKGF4aXNbb3B0aW9uc0tleV0pIHtcbiAgICAgICAgICBkZWxldGUgYXhpc1tvcHRpb25zS2V5XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlMiA9PT0gXCJzZXJpZXNcIikge1xuICAgICAgaWYgKCFvcHRpb25zLnNlcmllcz8uc29tZSgoc2VyaWVzKSA9PiBzZXJpZXMudHlwZSA9PT0gaWRlbnRpZmllcikpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgdXNlZE9wdGlvbnMucHVzaChgc2VyaWVzW3R5cGU9JHtpZGVudGlmaWVyfV1gKTtcbiAgICAgIG9wdGlvbnMuc2VyaWVzID0gb3B0aW9ucy5zZXJpZXMuZmlsdGVyKChzZXJpZXMpID0+IHNlcmllcy50eXBlICE9PSBpZGVudGlmaWVyKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUyID09PSBcInNlcmllcy1vcHRpb25cIikge1xuICAgICAgaWYgKCFvcHRpb25zLnNlcmllcz8uc29tZSgoc2VyaWVzKSA9PiBzZXJpZXNbb3B0aW9uc0tleV0pKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHVzZWRPcHRpb25zLnB1c2goYHNlcmllcy4ke29wdGlvbnNLZXl9YCk7XG4gICAgICBvcHRpb25zLnNlcmllcy5mb3JFYWNoKChzZXJpZXMpID0+IHtcbiAgICAgICAgaWYgKHNlcmllc1tvcHRpb25zS2V5XSkge1xuICAgICAgICAgIGRlbGV0ZSBzZXJpZXNbb3B0aW9uc0tleV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAodXNlZE9wdGlvbnMubGVuZ3RoICYmICFzaWxlbnQpIHtcbiAgICBpZiAoaXNHYXVnZUNoYXJ0KSB7XG4gICAgICB1c2VkT3B0aW9ucyA9IFtcIkFnQ2hhcnRzLmNyZWF0ZUdhdWdlXCJdO1xuICAgIH1cbiAgICBsZXQgZW50ZXJwcmlzZVBhY2thZ2VOYW1lID0gXCJhZy1jaGFydHMtZW50ZXJwcmlzZVwiO1xuICAgIGxldCBlbnRlcnByaXNlUmVmZXJlbmNlVXJsID0gXCJodHRwczovL2FnLWdyaWQuY29tL2NoYXJ0cy9qYXZhc2NyaXB0L2luc3RhbGxhdGlvbi9cIjtcbiAgICBpZiAob3B0aW9ucy5tb2RlID09PSBcImludGVncmF0ZWRcIikge1xuICAgICAgZW50ZXJwcmlzZVBhY2thZ2VOYW1lID0gXCJhZy1ncmlkLWNoYXJ0cy1lbnRlcnByaXNlJyBvciAnYWctZ3JpZC1lbnRlcnByaXNlL2NoYXJ0cy1lbnRlcnByaXNlXCI7XG4gICAgICBlbnRlcnByaXNlUmVmZXJlbmNlVXJsID0gXCJodHRwczovL3d3dy5hZy1ncmlkLmNvbS9qYXZhc2NyaXB0LWRhdGEtZ3JpZC9pbnRlZ3JhdGVkLWNoYXJ0cy1pbnN0YWxsYXRpb24vXCI7XG4gICAgfVxuICAgIExvZ2dlci53YXJuT25jZShcbiAgICAgIFtcbiAgICAgICAgYHVuYWJsZSB0byB1c2UgdGhlc2UgZW50ZXJwcmlzZSBmZWF0dXJlcyBhcyAnJHtlbnRlcnByaXNlUGFja2FnZU5hbWV9JyBoYXMgbm90IGJlZW4gbG9hZGVkOmAsXG4gICAgICAgIFwiXCIsXG4gICAgICAgIC4uLnVzZWRPcHRpb25zLFxuICAgICAgICBcIlwiLFxuICAgICAgICBgU2VlOiAke2VudGVycHJpc2VSZWZlcmVuY2VVcmx9YFxuICAgICAgXS5qb2luKFwiXFxuXCIpXG4gICAgKTtcbiAgfVxufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3N0cmluZy51dGlsLnRzXG5mdW5jdGlvbiBzdHJpbmdpZnlWYWx1ZSh2YWx1ZSwgbWF4TGVuZ3RoID0gSW5maW5pdHkpIHtcbiAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICByZXR1cm4gXCJ1bmRlZmluZWRcIjtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBcIk5hTlwiO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgcmV0dXJuIFwiSW5maW5pdHlcIjtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IC1JbmZpbml0eSkge1xuICAgICAgICByZXR1cm4gXCItSW5maW5pdHlcIjtcbiAgICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgdmFsdWUgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICBpZiAodmFsdWUubGVuZ3RoID4gbWF4TGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBgJHt2YWx1ZS5zbGljZSgwLCBtYXhMZW5ndGgpfS4uLiAoKyR7dmFsdWUubGVuZ3RoIC0gbWF4TGVuZ3RofSBjaGFyYWN0ZXJzKWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC92YWxpZGF0ZS50c1xudmFyIGRlc2NyaXB0aW9uU3ltYm9sID0gU3ltYm9sKFwiZGVzY3JpcHRpb25cIik7XG52YXIgcmVxdWlyZWRTeW1ib2wgPSBTeW1ib2woXCJyZXF1aXJlZFwiKTtcbmZ1bmN0aW9uIGlzVmFsaWQob3B0aW9ucywgb3B0aW9uc0RlZnMsIHBhdGgpIHtcbiAgY29uc3QgeyBlcnJvcnMgfSA9IHZhbGlkYXRlKG9wdGlvbnMsIG9wdGlvbnNEZWZzLCBwYXRoKTtcbiAgZm9yIChjb25zdCB7IG1lc3NhZ2UgfSBvZiBlcnJvcnMpIHtcbiAgICBMb2dnZXIud2FybihtZXNzYWdlKTtcbiAgfVxuICByZXR1cm4gZXJyb3JzLmxlbmd0aCA9PT0gMDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlTWVzc2FnZShwYXRoLCB2YWx1ZSwgdmFsaWRhdG9yT3JEZWZzKSB7XG4gIGNvbnN0IGRlc2NyaXB0aW9uID0gaXNTdHJpbmcodmFsaWRhdG9yT3JEZWZzKSA/IHZhbGlkYXRvck9yRGVmcyA6IHZhbGlkYXRvck9yRGVmc1tkZXNjcmlwdGlvblN5bWJvbF07XG4gIGNvbnN0IGV4cGVjdGluZyA9IGRlc2NyaXB0aW9uID8gYDsgZXhwZWN0aW5nICR7ZGVzY3JpcHRpb259YCA6IFwiXCI7XG4gIGNvbnN0IHByZWZpeCA9IHBhdGggPyBgT3B0aW9uIFxcYCR7cGF0aH1cXGBgIDogXCJWYWx1ZVwiO1xuICByZXR1cm4gYCR7cHJlZml4fSBjYW5ub3QgYmUgc2V0IHRvIFxcYCR7c3RyaW5naWZ5VmFsdWUodmFsdWUpfVxcYCR7ZXhwZWN0aW5nfSwgaWdub3JpbmcuYDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlKG9wdGlvbnMsIG9wdGlvbnNEZWZzLCBwYXRoID0gXCJcIikge1xuICBpZiAoIWlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbGlkOiBudWxsLFxuICAgICAgZXJyb3JzOiBbeyBwYXRoLCB2YWx1ZTogb3B0aW9ucywgbWVzc2FnZTogdmFsaWRhdGVNZXNzYWdlKHBhdGgsIG9wdGlvbnMsIFwiYW4gb2JqZWN0XCIpIH1dXG4gICAgfTtcbiAgfVxuICBjb25zdCBvcHRpb25zS2V5cyA9IG5ldyBTZXQoT2JqZWN0LmtleXMob3B0aW9ucykpO1xuICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgY29uc3QgdmFsaWQgPSB7fTtcbiAgZnVuY3Rpb24gZXh0ZW5kUGF0aChrZXkpIHtcbiAgICBpZiAoaXNBcnJheShvcHRpb25zRGVmcykpIHtcbiAgICAgIHJldHVybiBgJHtwYXRofVske2tleX1dYDtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGggPyBgJHtwYXRofS4ke2tleX1gIDoga2V5O1xuICB9XG4gIGZvciAoY29uc3QgW2tleSwgdmFsaWRhdG9yT3JEZWZzXSBvZiBPYmplY3QuZW50cmllcyhvcHRpb25zRGVmcykpIHtcbiAgICBvcHRpb25zS2V5cy5kZWxldGUoa2V5KTtcbiAgICBjb25zdCB2YWx1ZSA9IG9wdGlvbnNba2V5XTtcbiAgICBpZiAoIXZhbGlkYXRvck9yRGVmc1tyZXF1aXJlZFN5bWJvbF0gJiYgdHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgY29udGludWU7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsaWRhdG9yT3JEZWZzKSkge1xuICAgICAgaWYgKHZhbGlkYXRvck9yRGVmcyh2YWx1ZSkpIHtcbiAgICAgICAgdmFsaWRba2V5XSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3JzLnB1c2goeyBrZXksIHBhdGgsIHZhbHVlLCBtZXNzYWdlOiB2YWxpZGF0ZU1lc3NhZ2UoZXh0ZW5kUGF0aChrZXkpLCB2YWx1ZSwgdmFsaWRhdG9yT3JEZWZzKSB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbmVzdGVkUmVzdWx0ID0gdmFsaWRhdGUodmFsdWUsIHZhbGlkYXRvck9yRGVmcywgZXh0ZW5kUGF0aChrZXkpKTtcbiAgICAgIHZhbGlkW2tleV0gPSBuZXN0ZWRSZXN1bHQudmFsaWQ7XG4gICAgICBlcnJvcnMucHVzaCguLi5uZXN0ZWRSZXN1bHQuZXJyb3JzKTtcbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgb2Ygb3B0aW9uc0tleXMpIHtcbiAgICBlcnJvcnMucHVzaCh7XG4gICAgICBrZXksXG4gICAgICBwYXRoLFxuICAgICAgdW5rbm93bjogdHJ1ZSxcbiAgICAgIG1lc3NhZ2U6IGBVbmtub3duIG9wdGlvbiBcXGAke2V4dGVuZFBhdGgoa2V5KX1cXGAsIGlnbm9yaW5nLmBcbiAgICB9KTtcbiAgfVxuICByZXR1cm4geyB2YWxpZCwgZXJyb3JzIH07XG59XG5mdW5jdGlvbiBhdHRhY2hEZXNjcmlwdGlvbih2YWxpZGF0b3IsIGRlc2NyaXB0aW9uKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKCh2YWx1ZSkgPT4gdmFsaWRhdG9yKHZhbHVlKSwgeyBbZGVzY3JpcHRpb25TeW1ib2xdOiBkZXNjcmlwdGlvbiB9KTtcbn1cbnZhciBvciA9ICguLi52YWxpZGF0b3JzKSA9PiBhdHRhY2hEZXNjcmlwdGlvbihcbiAgKHZhbHVlKSA9PiB2YWxpZGF0b3JzLnNvbWUoKHZhbGlkYXRvcikgPT4gdmFsaWRhdG9yKHZhbHVlKSksXG4gIHZhbGlkYXRvcnMubWFwKCh2KSA9PiB2W2Rlc2NyaXB0aW9uU3ltYm9sXSkuZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCIgb3IgXCIpXG4pO1xudmFyIGFycmF5ID0gYXR0YWNoRGVzY3JpcHRpb24oaXNBcnJheSwgXCJhbiBhcnJheVwiKTtcbnZhciBib29sZWFuID0gYXR0YWNoRGVzY3JpcHRpb24oaXNCb29sZWFuLCBcImEgYm9vbGVhblwiKTtcbnZhciBjYWxsYmFjayA9IGF0dGFjaERlc2NyaXB0aW9uKGlzRnVuY3Rpb24sIFwiYSBmdW5jdGlvblwiKTtcbnZhciBudW1iZXIgPSBhdHRhY2hEZXNjcmlwdGlvbihpc0Zpbml0ZU51bWJlciwgXCJhIG51bWJlclwiKTtcbnZhciBvYmplY3QgPSBhdHRhY2hEZXNjcmlwdGlvbihpc09iamVjdCwgXCJhbiBvYmplY3RcIik7XG52YXIgc3RyaW5nID0gYXR0YWNoRGVzY3JpcHRpb24oaXNTdHJpbmcsIFwiYSBzdHJpbmdcIik7XG52YXIgbnVtYmVyTWluID0gKG1pbiwgaW5jbHVzaXZlID0gdHJ1ZSkgPT4gYXR0YWNoRGVzY3JpcHRpb24oXG4gICh2YWx1ZSkgPT4gaXNGaW5pdGVOdW1iZXIodmFsdWUpICYmICh2YWx1ZSA+IG1pbiB8fCBpbmNsdXNpdmUgJiYgdmFsdWUgPT09IG1pbiksXG4gIGBhIG51bWJlciBncmVhdGVyIHRoYW4gJHtpbmNsdXNpdmUgPyBcIm9yIGVxdWFsIHRvIFwiIDogXCJcIn0ke21pbn1gXG4pO1xudmFyIG51bWJlclJhbmdlID0gKG1pbiwgbWF4KSA9PiBhdHRhY2hEZXNjcmlwdGlvbihcbiAgKHZhbHVlKSA9PiBpc0Zpbml0ZU51bWJlcih2YWx1ZSkgJiYgdmFsdWUgPj0gbWluICYmIHZhbHVlIDw9IG1heCxcbiAgYGEgbnVtYmVyIGJldHdlZW4gJHttaW59IGFuZCAke21heH0gaW5jbHVzaXZlYFxuKTtcbnZhciBwb3NpdGl2ZU51bWJlciA9IG51bWJlck1pbigwKTtcbnZhciBtaW5PbmVOdW1iZXIgPSBudW1iZXJNaW4oMSk7XG52YXIgcmF0aW8gPSBudW1iZXJSYW5nZSgwLCAxKTtcbnZhciBkZWdyZWUgPSBudW1iZXJSYW5nZSgwLCAzNjApO1xudmFyIGFycmF5T2YgPSAodmFsaWRhdG9yLCBkZXNjcmlwdGlvbikgPT4gYXR0YWNoRGVzY3JpcHRpb24oXG4gICh2YWx1ZSkgPT4gaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUuZXZlcnkodmFsaWRhdG9yKSxcbiAgZGVzY3JpcHRpb24gPz8gYCR7dmFsaWRhdG9yW2Rlc2NyaXB0aW9uU3ltYm9sXX0gYXJyYXlgXG4pO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9tb2R1bGUvY29yZU1vZHVsZXNUeXBlcy50c1xuZnVuY3Rpb24gcGFsZXR0ZVR5cGUocGFydGlhbCkge1xuICBpZiAocGFydGlhbD8udXAgfHwgcGFydGlhbD8uZG93biB8fCBwYXJ0aWFsPy5uZXV0cmFsKSB7XG4gICAgcmV0dXJuIFwidXNlci1mdWxsXCI7XG4gIH0gZWxzZSBpZiAocGFydGlhbD8uZmlsbHMgfHwgcGFydGlhbD8uc3Ryb2tlcykge1xuICAgIHJldHVybiBcInVzZXItaW5kZXhlZFwiO1xuICB9XG4gIHJldHVybiBcImluYnVpbHRcIjtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvdGhlbWVzL2NoYXJ0VGhlbWUudHNcbnZhciBERUZBVUxUX0JBQ0tHUk9VTkRfRklMTCA9IFwid2hpdGVcIjtcbnZhciBDSEFSVF9UWVBFX0NPTkZJRyA9IHtcbiAgZ2V0IGNhcnRlc2lhbigpIHtcbiAgICByZXR1cm4geyBzZXJpZXNUeXBlczogY2hhcnRUeXBlcy5jYXJ0ZXNpYW5UeXBlcywgY29tbW9uT3B0aW9uczogW1wiem9vbVwiLCBcIm5hdmlnYXRvclwiXSB9O1xuICB9LFxuICBnZXQgcG9sYXIoKSB7XG4gICAgcmV0dXJuIHsgc2VyaWVzVHlwZXM6IGNoYXJ0VHlwZXMucG9sYXJUeXBlcywgY29tbW9uT3B0aW9uczogW10gfTtcbiAgfSxcbiAgZ2V0IGhpZXJhcmNoeSgpIHtcbiAgICByZXR1cm4geyBzZXJpZXNUeXBlczogY2hhcnRUeXBlcy5oaWVyYXJjaHlUeXBlcywgY29tbW9uT3B0aW9uczogW10gfTtcbiAgfSxcbiAgZ2V0IHRvcG9sb2d5KCkge1xuICAgIHJldHVybiB7IHNlcmllc1R5cGVzOiBjaGFydFR5cGVzLnRvcG9sb2d5VHlwZXMsIGNvbW1vbk9wdGlvbnM6IFtdIH07XG4gIH0sXG4gIGdldCBcImZsb3ctcHJvcG9ydGlvblwiKCkge1xuICAgIHJldHVybiB7IHNlcmllc1R5cGVzOiBjaGFydFR5cGVzLmZsb3dQcm9wb3J0aW9uVHlwZXMsIGNvbW1vbk9wdGlvbnM6IFtdIH07XG4gIH0sXG4gIGdldCBzdGFuZGFsb25lKCkge1xuICAgIHJldHVybiB7IHNlcmllc1R5cGVzOiBjaGFydFR5cGVzLnN0YW5kYWxvbmVUeXBlcywgY29tbW9uT3B0aW9uczogW10gfTtcbiAgfSxcbiAgZ2V0IGdhdWdlKCkge1xuICAgIHJldHVybiB7IHNlcmllc1R5cGVzOiBjaGFydFR5cGVzLmdhdWdlVHlwZXMsIGNvbW1vbk9wdGlvbnM6IFtdIH07XG4gIH1cbn07XG52YXIgUFJFU0VUX09WRVJSSURFU19UWVBFUyA9IHtcbiAgXCJyYWRpYWwtZ2F1Z2VcIjogdHJ1ZSxcbiAgXCJsaW5lYXItZ2F1Z2VcIjogdHJ1ZVxufTtcbmZ1bmN0aW9uIGlzUHJlc2V0T3ZlcnJpZGVzVHlwZSh0eXBlKSB7XG4gIHJldHVybiBQUkVTRVRfT1ZFUlJJREVTX1RZUEVTW3R5cGVdID09PSB0cnVlO1xufVxudmFyIENIQVJUX1RZUEVfU1BFQ0lGSUNfQ09NTU9OX09QVElPTlMgPSBPYmplY3QudmFsdWVzKENIQVJUX1RZUEVfQ09ORklHKS5yZWR1Y2UoKHIsIHsgY29tbW9uT3B0aW9ucyB9KSA9PiByLmNvbmNhdChjb21tb25PcHRpb25zKSwgW10pO1xudmFyIF9DaGFydFRoZW1lID0gY2xhc3MgX0NoYXJ0VGhlbWUge1xuICBzdGF0aWMgZ2V0QXhpc0RlZmF1bHRzKG92ZXJyaWRlRGVmYXVsdHMpIHtcbiAgICByZXR1cm4gbWVyZ2VEZWZhdWx0cyhvdmVycmlkZURlZmF1bHRzLCB7XG4gICAgICB0aXRsZToge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgdGV4dDogXCJBeGlzIFRpdGxlXCIsXG4gICAgICAgIHNwYWNpbmc6IDI1LFxuICAgICAgICBmb250V2VpZ2h0OiBcIm5vcm1hbFwiIC8qIE5PUk1BTCAqLyxcbiAgICAgICAgZm9udFNpemU6IDEzIC8qIE1FRElVTSAqLyxcbiAgICAgICAgZm9udEZhbWlseTogREVGQVVMVF9GT05UX0ZBTUlMWSxcbiAgICAgICAgY29sb3I6IERFRkFVTFRfTEFCRUxfQ09MT1VSXG4gICAgICB9LFxuICAgICAgbGFiZWw6IHtcbiAgICAgICAgZm9udFNpemU6IDEyIC8qIFNNQUxMICovLFxuICAgICAgICBmb250RmFtaWx5OiBERUZBVUxUX0ZPTlRfRkFNSUxZLFxuICAgICAgICBwYWRkaW5nOiA1LFxuICAgICAgICBjb2xvcjogREVGQVVMVF9MQUJFTF9DT0xPVVIsXG4gICAgICAgIGF2b2lkQ29sbGlzaW9uczogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGxpbmU6IHtcbiAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgIHN0cm9rZTogREVGQVVMVF9BWElTX0xJTkVfQ09MT1VSXG4gICAgICB9LFxuICAgICAgdGljazoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgIHN0cm9rZTogREVGQVVMVF9BWElTX0xJTkVfQ09MT1VSXG4gICAgICB9LFxuICAgICAgZ3JpZExpbmU6IHtcbiAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgc3R5bGU6IFt7IHN0cm9rZTogREVGQVVMVF9BWElTX0dSSURfQ09MT1VSLCBsaW5lRGFzaDogW10gfV1cbiAgICAgIH0sXG4gICAgICBjcm9zc0xpbmVzOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBmaWxsOiBERUZBVUxUX0NST1NTX0xJTkVTX0NPTE9VUixcbiAgICAgICAgc3Ryb2tlOiBERUZBVUxUX0NST1NTX0xJTkVTX0NPTE9VUixcbiAgICAgICAgZmlsbE9wYWNpdHk6IDAuMSxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDEsXG4gICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgZm9udFNpemU6IDEyIC8qIFNNQUxMICovLFxuICAgICAgICAgIGZvbnRGYW1pbHk6IERFRkFVTFRfRk9OVF9GQU1JTFksXG4gICAgICAgICAgcGFkZGluZzogNSxcbiAgICAgICAgICBjb2xvcjogREVGQVVMVF9MQUJFTF9DT0xPVVJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNyb3NzaGFpcjoge1xuICAgICAgICBlbmFibGVkOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZ2V0Q2hhcnREZWZhdWx0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWluSGVpZ2h0OiAzMDAsXG4gICAgICBtaW5XaWR0aDogMzAwLFxuICAgICAgYmFja2dyb3VuZDogeyB2aXNpYmxlOiB0cnVlLCBmaWxsOiBERUZBVUxUX0JBQ0tHUk9VTkRfQ09MT1VSIH0sXG4gICAgICBwYWRkaW5nOiB7IHRvcDogREVGQVVMVF9QQURESU5HLCByaWdodDogREVGQVVMVF9QQURESU5HLCBib3R0b206IERFRkFVTFRfUEFERElORywgbGVmdDogREVGQVVMVF9QQURESU5HIH0sXG4gICAgICBrZXlib2FyZDogeyBlbmFibGVkOiB0cnVlIH0sXG4gICAgICB0aXRsZToge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgdGV4dDogXCJUaXRsZVwiLFxuICAgICAgICBmb250V2VpZ2h0OiBcIm5vcm1hbFwiIC8qIE5PUk1BTCAqLyxcbiAgICAgICAgZm9udFNpemU6IDE3IC8qIExBUkdFICovLFxuICAgICAgICBmb250RmFtaWx5OiBERUZBVUxUX0ZPTlRfRkFNSUxZLFxuICAgICAgICBjb2xvcjogREVGQVVMVF9MQUJFTF9DT0xPVVIsXG4gICAgICAgIHdyYXBwaW5nOiBcImh5cGhlbmF0ZVwiLFxuICAgICAgICBsYXlvdXRTdHlsZTogREVGQVVMVF9DQVBUSU9OX0xBWU9VVF9TVFlMRSxcbiAgICAgICAgdGV4dEFsaWduOiBERUZBVUxUX0NBUFRJT05fQUxJR05NRU5UXG4gICAgICB9LFxuICAgICAgc3VidGl0bGU6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIHRleHQ6IFwiU3VidGl0bGVcIixcbiAgICAgICAgc3BhY2luZzogMjAsXG4gICAgICAgIGZvbnRTaXplOiAxMyAvKiBNRURJVU0gKi8sXG4gICAgICAgIGZvbnRGYW1pbHk6IERFRkFVTFRfRk9OVF9GQU1JTFksXG4gICAgICAgIGNvbG9yOiBERUZBVUxUX01VVEVEX0xBQkVMX0NPTE9VUixcbiAgICAgICAgd3JhcHBpbmc6IFwiaHlwaGVuYXRlXCIsXG4gICAgICAgIGxheW91dFN0eWxlOiBERUZBVUxUX0NBUFRJT05fTEFZT1VUX1NUWUxFLFxuICAgICAgICB0ZXh0QWxpZ246IERFRkFVTFRfQ0FQVElPTl9BTElHTk1FTlRcbiAgICAgIH0sXG4gICAgICBmb290bm90ZToge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgdGV4dDogXCJGb290bm90ZVwiLFxuICAgICAgICBzcGFjaW5nOiAyMCxcbiAgICAgICAgZm9udFNpemU6IDEzIC8qIE1FRElVTSAqLyxcbiAgICAgICAgZm9udEZhbWlseTogREVGQVVMVF9GT05UX0ZBTUlMWSxcbiAgICAgICAgY29sb3I6IFwicmdiKDE0MCwgMTQwLCAxNDApXCIsXG4gICAgICAgIHdyYXBwaW5nOiBcImh5cGhlbmF0ZVwiLFxuICAgICAgICBsYXlvdXRTdHlsZTogREVGQVVMVF9DQVBUSU9OX0xBWU9VVF9TVFlMRSxcbiAgICAgICAgdGV4dEFsaWduOiBERUZBVUxUX0NBUFRJT05fQUxJR05NRU5UXG4gICAgICB9LFxuICAgICAgbGVnZW5kOiB7XG4gICAgICAgIHBvc2l0aW9uOiBcImJvdHRvbVwiIC8qIEJPVFRPTSAqLyxcbiAgICAgICAgc3BhY2luZzogMzAsXG4gICAgICAgIGxpc3RlbmVyczoge30sXG4gICAgICAgIHRvZ2dsZVNlcmllczogdHJ1ZSxcbiAgICAgICAgaXRlbToge1xuICAgICAgICAgIHBhZGRpbmdYOiAxNixcbiAgICAgICAgICBwYWRkaW5nWTogOCxcbiAgICAgICAgICBtYXJrZXI6IHsgc2l6ZTogMTUsIHBhZGRpbmc6IDggfSxcbiAgICAgICAgICBzaG93U2VyaWVzU3Ryb2tlOiB0cnVlLFxuICAgICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgICBjb2xvcjogREVGQVVMVF9MQUJFTF9DT0xPVVIsXG4gICAgICAgICAgICBmb250U2l6ZTogMTIgLyogU01BTEwgKi8sXG4gICAgICAgICAgICBmb250RmFtaWx5OiBERUZBVUxUX0ZPTlRfRkFNSUxZXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZXZlcnNlT3JkZXI6IGZhbHNlLFxuICAgICAgICBwYWdpbmF0aW9uOiB7XG4gICAgICAgICAgbWFya2VyOiB7IHNpemU6IDEyIH0sXG4gICAgICAgICAgYWN0aXZlU3R5bGU6IHsgZmlsbDogREVGQVVMVF9MQUJFTF9DT0xPVVIgfSxcbiAgICAgICAgICBpbmFjdGl2ZVN0eWxlOiB7IGZpbGw6IERFRkFVTFRfTVVURURfTEFCRUxfQ09MT1VSIH0sXG4gICAgICAgICAgaGlnaGxpZ2h0U3R5bGU6IHsgZmlsbDogREVGQVVMVF9MQUJFTF9DT0xPVVIgfSxcbiAgICAgICAgICBsYWJlbDogeyBjb2xvcjogREVGQVVMVF9MQUJFTF9DT0xPVVIgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdG9vbHRpcDoge1xuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBkYXJrVGhlbWU6IElTX0RBUktfVEhFTUUsXG4gICAgICAgIGRlbGF5OiAwXG4gICAgICB9LFxuICAgICAgb3ZlcmxheXM6IHsgZGFya1RoZW1lOiBJU19EQVJLX1RIRU1FIH0sXG4gICAgICBsaXN0ZW5lcnM6IHt9XG4gICAgfTtcbiAgfVxuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IG92ZXJyaWRlcywgcGFsZXR0ZSB9ID0gZGVlcENsb25lKG9wdGlvbnMpO1xuICAgIGNvbnN0IGRlZmF1bHRzID0gdGhpcy5jcmVhdGVDaGFydENvbmZpZ1BlckNoYXJ0VHlwZSh0aGlzLmdldERlZmF1bHRzKCkpO1xuICAgIGNvbnN0IHByZXNldHMgPSB7fTtcbiAgICBpZiAob3ZlcnJpZGVzKSB7XG4gICAgICB0aGlzLm1lcmdlT3ZlcnJpZGVzKGRlZmF1bHRzLCBwcmVzZXRzLCBvdmVycmlkZXMpO1xuICAgIH1cbiAgICBjb25zdCB7IGZpbGxzLCBzdHJva2VzLCAuLi5vdGhlckNvbG9ycyB9ID0gdGhpcy5nZXREZWZhdWx0Q29sb3JzKCk7XG4gICAgdGhpcy5wYWxldHRlID0gbWVyZ2VEZWZhdWx0cyhwYWxldHRlLCB7XG4gICAgICBmaWxsczogT2JqZWN0LnZhbHVlcyhmaWxscyksXG4gICAgICBzdHJva2VzOiBPYmplY3QudmFsdWVzKHN0cm9rZXMpLFxuICAgICAgLi4ub3RoZXJDb2xvcnNcbiAgICB9KTtcbiAgICB0aGlzLnBhbGV0dGVUeXBlID0gcGFsZXR0ZVR5cGUocGFsZXR0ZSk7XG4gICAgdGhpcy5jb25maWcgPSBPYmplY3QuZnJlZXplKHRoaXMudGVtcGxhdGVUaGVtZShkZWZhdWx0cykpO1xuICAgIHRoaXMucHJlc2V0cyA9IHByZXNldHM7XG4gIH1cbiAgbWVyZ2VPdmVycmlkZXMoZGVmYXVsdHMsIHByZXNldHMsIG92ZXJyaWRlcykge1xuICAgIGZvciAoY29uc3QgeyBzZXJpZXNUeXBlcywgY29tbW9uT3B0aW9ucyB9IG9mIE9iamVjdC52YWx1ZXMoQ0hBUlRfVFlQRV9DT05GSUcpKSB7XG4gICAgICBjb25zdCBjbGVhbmVkQ29tbW9uID0geyAuLi5vdmVycmlkZXMuY29tbW9uIH07XG4gICAgICBmb3IgKGNvbnN0IGNvbW1vbktleSBvZiBDSEFSVF9UWVBFX1NQRUNJRklDX0NPTU1PTl9PUFRJT05TKSB7XG4gICAgICAgIGlmICghY29tbW9uT3B0aW9ucy5pbmNsdWRlcyhjb21tb25LZXkpKSB7XG4gICAgICAgICAgZGVsZXRlIGNsZWFuZWRDb21tb25bY29tbW9uS2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFjbGVhbmVkQ29tbW9uKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGZvciAoY29uc3QgcyBvZiBzZXJpZXNUeXBlcykge1xuICAgICAgICBjb25zdCBzZXJpZXNUeXBlMiA9IHM7XG4gICAgICAgIGlmICghaXNQcmVzZXRPdmVycmlkZXNUeXBlKHNlcmllc1R5cGUyKSkge1xuICAgICAgICAgIGRlZmF1bHRzW3Nlcmllc1R5cGUyXSA9IG1lcmdlRGVmYXVsdHMoY2xlYW5lZENvbW1vbiwgZGVmYXVsdHNbc2VyaWVzVHlwZTJdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjaGFydFR5cGVzLnNlcmllc1R5cGVzLmZvckVhY2goKHMpID0+IHtcbiAgICAgIGNvbnN0IHNlcmllc1R5cGUyID0gcztcbiAgICAgIGNvbnN0IHNlcmllc092ZXJyaWRlcyA9IG92ZXJyaWRlc1tzZXJpZXNUeXBlMl07XG4gICAgICBpZiAoaXNQcmVzZXRPdmVycmlkZXNUeXBlKHNlcmllc1R5cGUyKSkge1xuICAgICAgICBwcmVzZXRzW3Nlcmllc1R5cGUyXSA9IHNlcmllc092ZXJyaWRlcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZmF1bHRzW3Nlcmllc1R5cGUyXSA9IG1lcmdlRGVmYXVsdHMoc2VyaWVzT3ZlcnJpZGVzLCBkZWZhdWx0c1tzZXJpZXNUeXBlMl0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGNyZWF0ZUNoYXJ0Q29uZmlnUGVyQ2hhcnRUeXBlKGNvbmZpZykge1xuICAgIGZvciAoY29uc3QgW25leHRUeXBlLCB7IHNlcmllc1R5cGVzIH1dIG9mIE9iamVjdC5lbnRyaWVzKENIQVJUX1RZUEVfQ09ORklHKSkge1xuICAgICAgY29uc3QgdHlwZURlZmF1bHRzID0gY2hhcnREZWZhdWx0cy5nZXQobmV4dFR5cGUpO1xuICAgICAgZm9yIChjb25zdCBzZXJpZXNUeXBlMiBvZiBzZXJpZXNUeXBlcykge1xuICAgICAgICBjb25maWdbc2VyaWVzVHlwZTJdIHx8IChjb25maWdbc2VyaWVzVHlwZTJdID0gZGVlcENsb25lKHR5cGVEZWZhdWx0cykpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29uZmlnO1xuICB9XG4gIGdldERlZmF1bHRzKCkge1xuICAgIGNvbnN0IGdldE92ZXJyaWRlc0J5VHlwZSA9IChjaGFydFR5cGUyLCBzZXJpZXNUeXBlcykgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICBjb25zdCBjaGFydFR5cGVEZWZhdWx0cyA9IHtcbiAgICAgICAgYXhlczoge30sXG4gICAgICAgIC4uLmxlZ2VuZFJlZ2lzdHJ5LmdldFRoZW1lVGVtcGxhdGVzKCksXG4gICAgICAgIC4uLnRoaXMuZ2V0Q2hhcnREZWZhdWx0cygpLFxuICAgICAgICAuLi5jaGFydERlZmF1bHRzLmdldChjaGFydFR5cGUyKVxuICAgICAgfTtcbiAgICAgIGZvciAoY29uc3Qgc2VyaWVzVHlwZTIgb2Ygc2VyaWVzVHlwZXMpIHtcbiAgICAgICAgcmVzdWx0W3Nlcmllc1R5cGUyXSA9IG1lcmdlRGVmYXVsdHMoXG4gICAgICAgICAgc2VyaWVzUmVnaXN0cnkuZ2V0VGhlbWVUZW1wbGF0ZShzZXJpZXNUeXBlMiksXG4gICAgICAgICAgcmVzdWx0W3Nlcmllc1R5cGUyXSA/PyBkZWVwQ2xvbmUoY2hhcnRUeXBlRGVmYXVsdHMpXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHsgYXhlcyB9ID0gcmVzdWx0W3Nlcmllc1R5cGUyXTtcbiAgICAgICAgZm9yIChjb25zdCBheGlzVHlwZSBvZiBheGlzUmVnaXN0cnkua2V5cygpKSB7XG4gICAgICAgICAgYXhlc1theGlzVHlwZV0gPSBtZXJnZURlZmF1bHRzKFxuICAgICAgICAgICAgYXhlc1theGlzVHlwZV0sXG4gICAgICAgICAgICBheGlzUmVnaXN0cnkuZ2V0VGhlbWVUZW1wbGF0ZShheGlzVHlwZSksXG4gICAgICAgICAgICBfQ2hhcnRUaGVtZS5jYXJ0ZXNpYW5BeGlzRGVmYXVsdFtheGlzVHlwZV1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgcmV0dXJuIG1lcmdlRGVmYXVsdHMoXG4gICAgICBnZXRPdmVycmlkZXNCeVR5cGUoXCJjYXJ0ZXNpYW5cIiwgY2hhcnRUeXBlcy5jYXJ0ZXNpYW5UeXBlcyksXG4gICAgICBnZXRPdmVycmlkZXNCeVR5cGUoXCJwb2xhclwiLCBjaGFydFR5cGVzLnBvbGFyVHlwZXMpLFxuICAgICAgZ2V0T3ZlcnJpZGVzQnlUeXBlKFwiaGllcmFyY2h5XCIsIGNoYXJ0VHlwZXMuaGllcmFyY2h5VHlwZXMpLFxuICAgICAgZ2V0T3ZlcnJpZGVzQnlUeXBlKFwidG9wb2xvZ3lcIiwgY2hhcnRUeXBlcy50b3BvbG9neVR5cGVzKSxcbiAgICAgIGdldE92ZXJyaWRlc0J5VHlwZShcImZsb3ctcHJvcG9ydGlvblwiLCBjaGFydFR5cGVzLmZsb3dQcm9wb3J0aW9uVHlwZXMpLFxuICAgICAgZ2V0T3ZlcnJpZGVzQnlUeXBlKFwic3RhbmRhbG9uZVwiLCBjaGFydFR5cGVzLnN0YW5kYWxvbmVUeXBlcyksXG4gICAgICBnZXRPdmVycmlkZXNCeVR5cGUoXCJnYXVnZVwiLCBjaGFydFR5cGVzLmdhdWdlVHlwZXMpXG4gICAgKTtcbiAgfVxuICB0ZW1wbGF0ZVRoZW1lKHRoZW1lVGVtcGxhdGUpIHtcbiAgICBjb25zdCB0aGVtZUluc3RhbmNlID0gZGVlcENsb25lKHRoZW1lVGVtcGxhdGUpO1xuICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMuZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKCk7XG4gICAganNvbldhbGsodGhlbWVJbnN0YW5jZSwgKG5vZGUpID0+IHtcbiAgICAgIGlmIChpc0FycmF5KG5vZGUpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHN5bWJvbCA9IG5vZGVbaV07XG4gICAgICAgICAgaWYgKHBhcmFtcy5oYXMoc3ltYm9sKSkge1xuICAgICAgICAgICAgbm9kZVtpXSA9IHBhcmFtcy5nZXQoc3ltYm9sKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhub2RlKSkge1xuICAgICAgICAgIGlmIChwYXJhbXMuaGFzKHZhbHVlKSkge1xuICAgICAgICAgICAgbm9kZVtuYW1lXSA9IHBhcmFtcy5nZXQodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBkZWVwQ2xvbmUodGhlbWVJbnN0YW5jZSk7XG4gIH1cbiAgZ2V0RGVmYXVsdENvbG9ycygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZmlsbHM6IERFRkFVTFRfRklMTFMsXG4gICAgICBzdHJva2VzOiBERUZBVUxUX1NUUk9LRVMsXG4gICAgICB1cDogeyBmaWxsOiBERUZBVUxUX0ZJTExTLkdSRUVOLCBzdHJva2U6IERFRkFVTFRfU1RST0tFUy5HUkVFTiB9LFxuICAgICAgZG93bjogeyBmaWxsOiBERUZBVUxUX0ZJTExTLlJFRCwgc3Ryb2tlOiBERUZBVUxUX1NUUk9LRVMuUkVEIH0sXG4gICAgICBuZXV0cmFsOiB7IGZpbGw6IERFRkFVTFRfRklMTFMuR1JBWSwgc3Ryb2tlOiBERUZBVUxUX1NUUk9LRVMuR1JBWSB9LFxuICAgICAgYWx0VXA6IHsgZmlsbDogREVGQVVMVF9GSUxMUy5CTFVFLCBzdHJva2U6IERFRkFVTFRfU1RST0tFUy5CTFVFIH0sXG4gICAgICBhbHREb3duOiB7IGZpbGw6IERFRkFVTFRfRklMTFMuT1JBTkdFLCBzdHJva2U6IERFRkFVTFRfU1RST0tFUy5PUkFOR0UgfSxcbiAgICAgIGFsdE5ldXRyYWw6IHsgZmlsbDogREVGQVVMVF9GSUxMUy5HUkFZLCBzdHJva2U6IERFRkFVTFRfU1RST0tFUy5HUkFZIH1cbiAgICB9O1xuICB9XG4gIGdldFRlbXBsYXRlUGFyYW1ldGVycygpIHtcbiAgICBjb25zdCB7IGlzRW50ZXJwcmlzZSB9ID0gZW50ZXJwcmlzZU1vZHVsZTtcbiAgICBjb25zdCBwYXJhbXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHBhcmFtcy5zZXQoSVNfREFSS19USEVNRSwgZmFsc2UpO1xuICAgIHBhcmFtcy5zZXQoSVNfRU5URVJQUklTRSwgaXNFbnRlcnByaXNlKTtcbiAgICBwYXJhbXMuc2V0KElTX0NPTU1VTklUWSwgIWlzRW50ZXJwcmlzZSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0ZPTlRfRkFNSUxZLCBcIlZlcmRhbmEsIHNhbnMtc2VyaWZcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0xBQkVMX0NPTE9VUiwgXCJyZ2IoNzAsIDcwLCA3MClcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0lOVkVSVEVEX0xBQkVMX0NPTE9VUiwgXCJ3aGl0ZVwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfTVVURURfTEFCRUxfQ09MT1VSLCBcInJnYigxNDAsIDE0MCwgMTQwKVwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQVhJU19HUklEX0NPTE9VUiwgXCJyZ2IoMjI0LDIzNCwyNDEpXCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BWElTX0xJTkVfQ09MT1VSLCBcInJnYigxOTUsIDE5NSwgMTk1KVwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQ1JPU1NfTElORVNfQ09MT1VSLCBcInJnYig3MCwgNzAsIDcwKVwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfSU5TSURFX1NFUklFU19MQUJFTF9DT0xPVVIsIERFRkFVTFRfQkFDS0dST1VORF9GSUxMKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQkFDS0dST1VORF9DT0xPVVIsIERFRkFVTFRfQkFDS0dST1VORF9GSUxMKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfU0hBRE9XX0NPTE9VUiwgXCJyZ2JhKDAsIDAsIDAsIDAuNSlcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0RJVkVSR0lOR19TRVJJRVNfQ09MT1JfUkFOR0UsIFtcbiAgICAgIERFRkFVTFRfRklMTFMuT1JBTkdFLFxuICAgICAgREVGQVVMVF9GSUxMUy5ZRUxMT1csXG4gICAgICBERUZBVUxUX0ZJTExTLkdSRUVOXG4gICAgXSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0dBVUdFX1NFUklFU19DT0xPUl9SQU5HRSwgW0RFRkFVTFRfRklMTFMuR1JFRU4sIERFRkFVTFRfRklMTFMuWUVMTE9XLCBERUZBVUxUX0ZJTExTLlJFRF0pO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9GVU5ORUxfU0VSSUVTX0NPTE9SX1JBTkdFLCBbXG4gICAgICBcIiM1MDkwZGNcIixcbiAgICAgIFwiIzYyOWJlMFwiLFxuICAgICAgXCIjNzNhNmUzXCIsXG4gICAgICBcIiM4NWIxZTdcIixcbiAgICAgIFwiIzk2YmNlYVwiLFxuICAgICAgXCIjYThjOGVlXCIsXG4gICAgICBcIiNiOWQzZjFcIixcbiAgICAgIFwiI2NiZGVmNVwiXG4gICAgXSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX1BBRERJTkcsIDIwKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQ0FQVElPTl9MQVlPVVRfU1RZTEUsIFwiYmxvY2tcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0NBUFRJT05fQUxJR05NRU5ULCBcImNlbnRlclwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfSElFUkFSQ0hZX0ZJTExTLCBbXCIjZmZmZmZmXCIsIFwiI2UwZTVlYVwiLCBcIiNjMWNjZDVcIiwgXCIjYTNiNGMxXCIsIFwiIzg1OWNhZFwiXSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0hJRVJBUkNIWV9TVFJPS0VTLCBbXCIjZmZmZmZmXCIsIFwiI2M1Y2JkMVwiLCBcIiNhNGIxYmRcIiwgXCIjODQ5OGE5XCIsIFwiIzY0ODA5NlwiXSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX1BPTEFSX1NFUklFU19TVFJPS0UsIERFRkFVTFRfQkFDS0dST1VORF9GSUxMKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQU5OT1RBVElPTl9DT0xPUiwgREVGQVVMVF9GSUxMUy5CTFVFKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfVEVYVF9BTk5PVEFUSU9OX0NPTE9SLCBERUZBVUxUX0ZJTExTLkJMVUUpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX0JBQ0tHUk9VTkRfRklMTCwgREVGQVVMVF9GSUxMUy5CTFVFKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQU5OT1RBVElPTl9IQU5ETEVfRklMTCwgREVGQVVMVF9CQUNLR1JPVU5EX0ZJTEwpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX1NUQVRJU1RJQ1NfRklMTCwgXCIjZmFmYWZhXCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX1NUQVRJU1RJQ1NfU1RST0tFLCBcIiNkZGRkZGRcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fU1RBVElTVElDU19DT0xPUiwgXCIjMDAwMDAwXCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX1NUQVRJU1RJQ1NfRElWSURFUl9TVFJPS0UsIFwiIzE4MWQxZlwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQU5OT1RBVElPTl9TVEFUSVNUSUNTX0RPV05fRklMTCwgXCIjZTM1YzVjXCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX1NUQVRJU1RJQ1NfRE9XTl9TVFJPS0UsIFwiI2UzNWM1Y1wiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfVEVYVEJPWF9GSUxMLCBcIiNmYWZhZmFcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX1RFWFRCT1hfU1RST0tFLCBcIiNkZGRkZGRcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX1RFWFRCT1hfQ09MT1IsIFwiIzAwMDAwMFwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfVE9PTEJBUl9QT1NJVElPTiwgXCJ0b3BcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0dSSURMSU5FX0VOQUJMRUQsIGZhbHNlKTtcbiAgICBjb25zdCBkZWZhdWx0Q29sb3JzID0gdGhpcy5nZXREZWZhdWx0Q29sb3JzKCk7XG4gICAgcGFyYW1zLnNldChQQUxFVFRFX1VQX1NUUk9LRSwgdGhpcy5wYWxldHRlLnVwPy5zdHJva2UgPz8gZGVmYXVsdENvbG9ycy51cC5zdHJva2UpO1xuICAgIHBhcmFtcy5zZXQoUEFMRVRURV9VUF9GSUxMLCB0aGlzLnBhbGV0dGUudXA/LmZpbGwgPz8gZGVmYXVsdENvbG9ycy51cC5maWxsKTtcbiAgICBwYXJhbXMuc2V0KFBBTEVUVEVfRE9XTl9TVFJPS0UsIHRoaXMucGFsZXR0ZS5kb3duPy5zdHJva2UgPz8gZGVmYXVsdENvbG9ycy5kb3duLnN0cm9rZSk7XG4gICAgcGFyYW1zLnNldChQQUxFVFRFX0RPV05fRklMTCwgdGhpcy5wYWxldHRlLmRvd24/LmZpbGwgPz8gZGVmYXVsdENvbG9ycy5kb3duLmZpbGwpO1xuICAgIHBhcmFtcy5zZXQoUEFMRVRURV9ORVVUUkFMX1NUUk9LRSwgdGhpcy5wYWxldHRlLm5ldXRyYWw/LnN0cm9rZSA/PyBkZWZhdWx0Q29sb3JzLm5ldXRyYWwuc3Ryb2tlKTtcbiAgICBwYXJhbXMuc2V0KFBBTEVUVEVfTkVVVFJBTF9GSUxMLCB0aGlzLnBhbGV0dGUubmV1dHJhbD8uZmlsbCA/PyBkZWZhdWx0Q29sb3JzLm5ldXRyYWwuZmlsbCk7XG4gICAgcGFyYW1zLnNldChQQUxFVFRFX0FMVF9VUF9TVFJPS0UsIHRoaXMucGFsZXR0ZS5hbHRVcD8uc3Ryb2tlID8/IGRlZmF1bHRDb2xvcnMudXAuc3Ryb2tlKTtcbiAgICBwYXJhbXMuc2V0KFBBTEVUVEVfQUxUX1VQX0ZJTEwsIHRoaXMucGFsZXR0ZS5hbHRVcD8uZmlsbCA/PyBkZWZhdWx0Q29sb3JzLnVwLmZpbGwpO1xuICAgIHBhcmFtcy5zZXQoUEFMRVRURV9BTFRfRE9XTl9TVFJPS0UsIHRoaXMucGFsZXR0ZS5hbHREb3duPy5zdHJva2UgPz8gZGVmYXVsdENvbG9ycy5kb3duLnN0cm9rZSk7XG4gICAgcGFyYW1zLnNldChQQUxFVFRFX0FMVF9ET1dOX0ZJTEwsIHRoaXMucGFsZXR0ZS5hbHREb3duPy5maWxsID8/IGRlZmF1bHRDb2xvcnMuZG93bi5maWxsKTtcbiAgICBwYXJhbXMuc2V0KFBBTEVUVEVfQUxUX05FVVRSQUxfRklMTCwgdGhpcy5wYWxldHRlLmFsdE5ldXRyYWw/LmZpbGwgPz8gZGVmYXVsdENvbG9ycy5hbHROZXV0cmFsLmZpbGwpO1xuICAgIHBhcmFtcy5zZXQoUEFMRVRURV9BTFRfTkVVVFJBTF9TVFJPS0UsIHRoaXMucGFsZXR0ZS5hbHROZXV0cmFsPy5zdHJva2UgPz8gZGVmYXVsdENvbG9ycy5hbHROZXV0cmFsLnN0cm9rZSk7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxufTtcbl9DaGFydFRoZW1lLmNhcnRlc2lhbkF4aXNEZWZhdWx0ID0ge1xuICBbXCJudW1iZXJcIiAvKiBOVU1CRVIgKi9dOiBfQ2hhcnRUaGVtZS5nZXRBeGlzRGVmYXVsdHMoe1xuICAgIGxpbmU6IHsgZW5hYmxlZDogZmFsc2UgfVxuICB9KSxcbiAgW1wibG9nXCIgLyogTE9HICovXTogX0NoYXJ0VGhlbWUuZ2V0QXhpc0RlZmF1bHRzKHtcbiAgICBiYXNlOiAxMCxcbiAgICBsaW5lOiB7IGVuYWJsZWQ6IGZhbHNlIH0sXG4gICAgaW50ZXJ2YWw6IHsgbWluU3BhY2luZzogTmFOIH1cbiAgfSksXG4gIFtcImNhdGVnb3J5XCIgLyogQ0FURUdPUlkgKi9dOiBfQ2hhcnRUaGVtZS5nZXRBeGlzRGVmYXVsdHMoe1xuICAgIGdyb3VwUGFkZGluZ0lubmVyOiAwLjEsXG4gICAgbGFiZWw6IHsgYXV0b1JvdGF0ZTogdHJ1ZSB9LFxuICAgIGdyaWRMaW5lOiB7IGVuYWJsZWQ6IERFRkFVTFRfR1JJRExJTkVfRU5BQkxFRCB9LFxuICAgIGNyb3NzaGFpcjogeyBlbmFibGVkOiBmYWxzZSB9XG4gIH0pLFxuICBbXCJ0aW1lXCIgLyogVElNRSAqL106IF9DaGFydFRoZW1lLmdldEF4aXNEZWZhdWx0cyh7IGdyaWRMaW5lOiB7IGVuYWJsZWQ6IERFRkFVTFRfR1JJRExJTkVfRU5BQkxFRCB9IH0pLFxuICBbXCJvcmRpbmFsLXRpbWVcIiAvKiBPUkRJTkFMX1RJTUUgKi9dOiBfQ2hhcnRUaGVtZS5nZXRBeGlzRGVmYXVsdHMoe1xuICAgIGdyb3VwUGFkZGluZ0lubmVyOiAwLFxuICAgIGxhYmVsOiB7IGF1dG9Sb3RhdGU6IGZhbHNlIH0sXG4gICAgZ3JpZExpbmU6IHsgZW5hYmxlZDogREVGQVVMVF9HUklETElORV9FTkFCTEVEIH1cbiAgfSksXG4gIFtcImFuZ2xlLWNhdGVnb3J5XCIgLyogQU5HTEVfQ0FURUdPUlkgKi9dOiBfQ2hhcnRUaGVtZS5nZXRBeGlzRGVmYXVsdHMoe1xuICAgIGdyaWRMaW5lOiB7IGVuYWJsZWQ6IERFRkFVTFRfR1JJRExJTkVfRU5BQkxFRCB9XG4gIH0pLFxuICBbXCJhbmdsZS1udW1iZXJcIiAvKiBBTkdMRV9OVU1CRVIgKi9dOiBfQ2hhcnRUaGVtZS5nZXRBeGlzRGVmYXVsdHMoeyBncmlkTGluZTogeyBlbmFibGVkOiBERUZBVUxUX0dSSURMSU5FX0VOQUJMRUQgfSB9KSxcbiAgW1wicmFkaXVzLWNhdGVnb3J5XCIgLyogUkFESVVTX0NBVEVHT1JZICovXTogX0NoYXJ0VGhlbWUuZ2V0QXhpc0RlZmF1bHRzKHtcbiAgICBsaW5lOiB7IGVuYWJsZWQ6IGZhbHNlIH1cbiAgfSksXG4gIFtcInJhZGl1cy1udW1iZXJcIiAvKiBSQURJVVNfTlVNQkVSICovXTogX0NoYXJ0VGhlbWUuZ2V0QXhpc0RlZmF1bHRzKHtcbiAgICBsaW5lOiB7IGVuYWJsZWQ6IGZhbHNlIH1cbiAgfSksXG4gIFwiZ3JvdXBlZC1jYXRlZ29yeVwiOiBfQ2hhcnRUaGVtZS5nZXRBeGlzRGVmYXVsdHMoe1xuICAgIHRpY2s6IHsgZW5hYmxlZDogdHJ1ZSB9XG4gIH0pXG59O1xudmFyIENoYXJ0VGhlbWUgPSBfQ2hhcnRUaGVtZTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvdGhlbWVzL2RhcmtUaGVtZS50c1xudmFyIERFRkFVTFRfREFSS19CQUNLR1JPVU5EX0ZJTEwgPSBcIiMxOTIyMzJcIjtcbnZhciBERUZBVUxUX0RBUktfRklMTFMgPSB7XG4gIEJMVUU6IFwiIzUwOTBkY1wiLFxuICBPUkFOR0U6IFwiI2ZmYTAzYVwiLFxuICBHUkVFTjogXCIjNDU5ZDU1XCIsXG4gIENZQU46IFwiIzM0YmZlMVwiLFxuICBZRUxMT1c6IFwiI2UxY2MwMFwiLFxuICBWSU9MRVQ6IFwiIzk2NjljYlwiLFxuICBHUkFZOiBcIiNiNWI1YjVcIixcbiAgTUFHRU5UQTogXCIjYmQ1YWE3XCIsXG4gIEJST1dOOiBcIiM4YTYyMjRcIixcbiAgUkVEOiBcIiNlZjU0NTJcIlxufTtcbnZhciBERUZBVUxUX0RBUktfU1RST0tFUyA9IHtcbiAgQkxVRTogXCIjNzRhOGU2XCIsXG4gIE9SQU5HRTogXCIjZmZiZTcwXCIsXG4gIEdSRUVOOiBcIiM2Y2IxNzZcIixcbiAgQ1lBTjogXCIjNzVkNGVmXCIsXG4gIFlFTExPVzogXCIjZjZlNTU5XCIsXG4gIFZJT0xFVDogXCIjYWE4NmQ4XCIsXG4gIEdSQVk6IFwiI2ExYTFhMVwiLFxuICBNQUdFTlRBOiBcIiNjZTdhYjlcIixcbiAgQlJPV046IFwiIzk5N2I1MlwiLFxuICBSRUQ6IFwiI2ZmNzg3MlwiXG59O1xudmFyIERhcmtUaGVtZSA9IGNsYXNzIGV4dGVuZHMgQ2hhcnRUaGVtZSB7XG4gIGdldERlZmF1bHRDb2xvcnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpbGxzOiBERUZBVUxUX0RBUktfRklMTFMsXG4gICAgICBzdHJva2VzOiBERUZBVUxUX0RBUktfU1RST0tFUyxcbiAgICAgIHVwOiB7IGZpbGw6IERFRkFVTFRfREFSS19GSUxMUy5HUkVFTiwgc3Ryb2tlOiBERUZBVUxUX0RBUktfU1RST0tFUy5HUkVFTiB9LFxuICAgICAgZG93bjogeyBmaWxsOiBERUZBVUxUX0RBUktfRklMTFMuUkVELCBzdHJva2U6IERFRkFVTFRfREFSS19TVFJPS0VTLlJFRCB9LFxuICAgICAgbmV1dHJhbDogeyBmaWxsOiBERUZBVUxUX0RBUktfRklMTFMuR1JBWSwgc3Ryb2tlOiBERUZBVUxUX0RBUktfU1RST0tFUy5HUkFZIH0sXG4gICAgICBhbHRVcDogeyBmaWxsOiBERUZBVUxUX0RBUktfRklMTFMuQkxVRSwgc3Ryb2tlOiBERUZBVUxUX0RBUktfU1RST0tFUy5CTFVFIH0sXG4gICAgICBhbHREb3duOiB7IGZpbGw6IERFRkFVTFRfREFSS19GSUxMUy5PUkFOR0UsIHN0cm9rZTogREVGQVVMVF9EQVJLX1NUUk9LRVMuT1JBTkdFIH0sXG4gICAgICBhbHROZXV0cmFsOiB7IGZpbGw6IERFRkFVTFRfREFSS19GSUxMUy5HUkFZLCBzdHJva2U6IERFRkFVTFRfREFSS19TVFJPS0VTLkdSQVkgfVxuICAgIH07XG4gIH1cbiAgZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHN1cGVyLmdldFRlbXBsYXRlUGFyYW1ldGVycygpO1xuICAgIHBhcmFtcy5zZXQoSVNfREFSS19USEVNRSwgdHJ1ZSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX1BPTEFSX1NFUklFU19TVFJPS0UsIERFRkFVTFRfREFSS19CQUNLR1JPVU5EX0ZJTEwpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9MQUJFTF9DT0xPVVIsIFwid2hpdGVcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX01VVEVEX0xBQkVMX0NPTE9VUiwgXCIjN0Q5MUEwXCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BWElTX0dSSURfQ09MT1VSLCBcIiM1NDVBNkVcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0NST1NTX0xJTkVTX0NPTE9VUiwgXCJ3aGl0ZVwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfRElWRVJHSU5HX1NFUklFU19DT0xPUl9SQU5HRSwgW1xuICAgICAgREVGQVVMVF9EQVJLX0ZJTExTLk9SQU5HRSxcbiAgICAgIERFRkFVTFRfREFSS19GSUxMUy5ZRUxMT1csXG4gICAgICBERUZBVUxUX0RBUktfRklMTFMuR1JFRU5cbiAgICBdKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfR0FVR0VfU0VSSUVTX0NPTE9SX1JBTkdFLCBbXG4gICAgICBERUZBVUxUX0RBUktfRklMTFMuR1JFRU4sXG4gICAgICBERUZBVUxUX0RBUktfRklMTFMuWUVMTE9XLFxuICAgICAgREVGQVVMVF9EQVJLX0ZJTExTLlJFRFxuICAgIF0pO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9GVU5ORUxfU0VSSUVTX0NPTE9SX1JBTkdFLCBbXG4gICAgICBcIiM1MDkwZGNcIixcbiAgICAgIFwiIzQ4ODJjNlwiLFxuICAgICAgXCIjNDA3M2IwXCIsXG4gICAgICBcIiMzODY1OWFcIixcbiAgICAgIFwiIzMwNTY4NFwiLFxuICAgICAgXCIjMjg0ODZlXCIsXG4gICAgICBcIiMyMDNhNThcIixcbiAgICAgIFwiIzE4MmI0MlwiXG4gICAgXSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0hJRVJBUkNIWV9GSUxMUywgW1wiIzE5MjgzNFwiLCBcIiMyNTM3NDZcIiwgXCIjMzI0ODU5XCIsIFwiIzNmNTk2Y1wiLCBcIiM0ZDZhODBcIl0pO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9ISUVSQVJDSFlfU1RST0tFUywgW1wiIzE5MjgzNFwiLCBcIiMzYjUxNjRcIiwgXCIjNDk2Mjc1XCIsIFwiIzU3NzI4N1wiLCBcIiM2NjgzOTlcIl0pO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9CQUNLR1JPVU5EX0NPTE9VUiwgREVGQVVMVF9EQVJLX0JBQ0tHUk9VTkRfRklMTCk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0lOU0lERV9TRVJJRVNfTEFCRUxfQ09MT1VSLCBERUZBVUxUX0RBUktfQkFDS0dST1VORF9GSUxMKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQU5OT1RBVElPTl9DT0xPUiwgREVGQVVMVF9EQVJLX0ZJTExTLkJMVUUpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9URVhUX0FOTk9UQVRJT05fQ09MT1IsIFwid2hpdGVcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fQkFDS0dST1VORF9GSUxMLCBERUZBVUxUX0RBUktfRklMTFMuQkxVRSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fSEFORExFX0ZJTEwsIERFRkFVTFRfREFSS19CQUNLR1JPVU5EX0ZJTEwpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX1NUQVRJU1RJQ1NfRklMTCwgXCIjMjgzMTNlXCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX1NUQVRJU1RJQ1NfU1RST0tFLCBcIiM0YjUyNWRcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fU1RBVElTVElDU19DT0xPUiwgXCIjZmZmZmZmXCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX1NUQVRJU1RJQ1NfRElWSURFUl9TVFJPS0UsIFwiI2ZmZmZmZlwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfVEVYVEJPWF9GSUxMLCBcIiMyODMxM2VcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX1RFWFRCT1hfU1RST0tFLCBcIiM0YjUyNWRcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX1RFWFRCT1hfQ09MT1IsIFwiI2ZmZmZmZlwiKTtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihvcHRpb25zKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvdGhlbWVzL2ZpbmFuY2lhbERhcmsudHNcbnZhciBGSU5BTkNJQUxfREFSS19GSUxMUyA9IHtcbiAgR1JFRU46IFwiIzA4OTk4MVwiLFxuICBSRUQ6IFwiI0YyMzY0NVwiLFxuICBCTFVFOiBcIiM1MDkwZGNcIixcbiAgR1JBWTogXCIjQTlBOUE5XCJcbn07XG52YXIgRklOQU5DSUFMX0RBUktfU1RST0tFUyA9IHtcbiAgR1JFRU46IFwiIzA4OTk4MVwiLFxuICBSRUQ6IFwiI0YyMzY0NVwiLFxuICBCTFVFOiBcIiM1MDkwZGNcIixcbiAgR1JBWTogXCIjOTA5MDkwXCJcbn07XG52YXIgRmluYW5jaWFsRGFyayA9IGNsYXNzIGV4dGVuZHMgRGFya1RoZW1lIHtcbiAgZ2V0RGVmYXVsdENvbG9ycygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZmlsbHM6IHsgLi4uRklOQU5DSUFMX0RBUktfRklMTFMgfSxcbiAgICAgIHN0cm9rZXM6IHsgLi4uRklOQU5DSUFMX0RBUktfU1RST0tFUyB9LFxuICAgICAgdXA6IHsgZmlsbDogRklOQU5DSUFMX0RBUktfRklMTFMuR1JFRU4sIHN0cm9rZTogRklOQU5DSUFMX0RBUktfU1RST0tFUy5HUkVFTiB9LFxuICAgICAgZG93bjogeyBmaWxsOiBGSU5BTkNJQUxfREFSS19GSUxMUy5SRUQsIHN0cm9rZTogRklOQU5DSUFMX0RBUktfU1RST0tFUy5SRUQgfSxcbiAgICAgIG5ldXRyYWw6IHsgZmlsbDogRklOQU5DSUFMX0RBUktfRklMTFMuQkxVRSwgc3Ryb2tlOiBGSU5BTkNJQUxfREFSS19TVFJPS0VTLkJMVUUgfSxcbiAgICAgIGFsdFVwOiB7IGZpbGw6IEZJTkFOQ0lBTF9EQVJLX0ZJTExTLkdSRUVOLCBzdHJva2U6IEZJTkFOQ0lBTF9EQVJLX1NUUk9LRVMuR1JFRU4gfSxcbiAgICAgIGFsdERvd246IHsgZmlsbDogRklOQU5DSUFMX0RBUktfRklMTFMuUkVELCBzdHJva2U6IEZJTkFOQ0lBTF9EQVJLX1NUUk9LRVMuUkVEIH0sXG4gICAgICBhbHROZXV0cmFsOiB7IGZpbGw6IEZJTkFOQ0lBTF9EQVJLX0ZJTExTLkdSQVksIHN0cm9rZTogRklOQU5DSUFMX0RBUktfU1RST0tFUy5HUkFZIH1cbiAgICB9O1xuICB9XG4gIGdldFRlbXBsYXRlUGFyYW1ldGVycygpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBzdXBlci5nZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfRElWRVJHSU5HX1NFUklFU19DT0xPUl9SQU5HRSwgW1xuICAgICAgRklOQU5DSUFMX0RBUktfRklMTFMuR1JFRU4sXG4gICAgICBGSU5BTkNJQUxfREFSS19GSUxMUy5CTFVFLFxuICAgICAgRklOQU5DSUFMX0RBUktfRklMTFMuUkVEXG4gICAgXSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fQ09MT1IsIEZJTkFOQ0lBTF9EQVJLX0ZJTExTLkJMVUUpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX0JBQ0tHUk9VTkRfRklMTCwgRklOQU5DSUFMX0RBUktfRklMTFMuQkxVRSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FYSVNfR1JJRF9DT0xPVVIsIFwiIzM0M0E0RVwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfUEFERElORywgMCk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0NBUFRJT05fTEFZT1VUX1NUWUxFLCBcIm92ZXJsYXlcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0NBUFRJT05fQUxJR05NRU5ULCBcImxlZnRcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX1RPT0xCQVJfUE9TSVRJT04sIFwiYm90dG9tXCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9HUklETElORV9FTkFCTEVELCB0cnVlKTtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC90aGVtZXMvZmluYW5jaWFsTGlnaHQudHNcbnZhciBGSU5BTkNJQUxfTElHSFRfRklMTFMgPSB7XG4gIEdSRUVOOiBcIiMwODk5ODFcIixcbiAgUkVEOiBcIiNGMjM2NDVcIixcbiAgQkxVRTogXCIjNTA5MGRjXCIsXG4gIEdSQVk6IFwiI0E5QTlBOVwiXG59O1xudmFyIEZJTkFOQ0lBTF9MSUdIVF9TVFJPS0VTID0ge1xuICBHUkVFTjogXCIjMDg5OTgxXCIsXG4gIFJFRDogXCIjRjIzNjQ1XCIsXG4gIEJMVUU6IFwiIzUwOTBkY1wiLFxuICBHUkFZOiBcIiM5MDkwOTBcIlxufTtcbnZhciBGaW5hbmNpYWxMaWdodCA9IGNsYXNzIGV4dGVuZHMgQ2hhcnRUaGVtZSB7XG4gIGdldERlZmF1bHRDb2xvcnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpbGxzOiB7IC4uLkZJTkFOQ0lBTF9MSUdIVF9GSUxMUyB9LFxuICAgICAgc3Ryb2tlczogeyAuLi5GSU5BTkNJQUxfTElHSFRfU1RST0tFUyB9LFxuICAgICAgdXA6IHsgZmlsbDogRklOQU5DSUFMX0xJR0hUX0ZJTExTLkdSRUVOLCBzdHJva2U6IEZJTkFOQ0lBTF9MSUdIVF9TVFJPS0VTLkdSRUVOIH0sXG4gICAgICBkb3duOiB7IGZpbGw6IEZJTkFOQ0lBTF9MSUdIVF9GSUxMUy5SRUQsIHN0cm9rZTogRklOQU5DSUFMX0xJR0hUX1NUUk9LRVMuUkVEIH0sXG4gICAgICBuZXV0cmFsOiB7IGZpbGw6IEZJTkFOQ0lBTF9MSUdIVF9GSUxMUy5CTFVFLCBzdHJva2U6IEZJTkFOQ0lBTF9MSUdIVF9TVFJPS0VTLkJMVUUgfSxcbiAgICAgIGFsdFVwOiB7IGZpbGw6IEZJTkFOQ0lBTF9MSUdIVF9GSUxMUy5HUkVFTiwgc3Ryb2tlOiBGSU5BTkNJQUxfTElHSFRfU1RST0tFUy5HUkVFTiB9LFxuICAgICAgYWx0RG93bjogeyBmaWxsOiBGSU5BTkNJQUxfTElHSFRfRklMTFMuUkVELCBzdHJva2U6IEZJTkFOQ0lBTF9MSUdIVF9TVFJPS0VTLlJFRCB9LFxuICAgICAgYWx0TmV1dHJhbDogeyBmaWxsOiBGSU5BTkNJQUxfTElHSFRfRklMTFMuR1JBWSwgc3Ryb2tlOiBGSU5BTkNJQUxfTElHSFRfU1RST0tFUy5HUkFZIH1cbiAgICB9O1xuICB9XG4gIGdldFRlbXBsYXRlUGFyYW1ldGVycygpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBzdXBlci5nZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfRElWRVJHSU5HX1NFUklFU19DT0xPUl9SQU5HRSwgW1xuICAgICAgRklOQU5DSUFMX0xJR0hUX0ZJTExTLkdSRUVOLFxuICAgICAgRklOQU5DSUFMX0xJR0hUX0ZJTExTLkJMVUUsXG4gICAgICBGSU5BTkNJQUxfTElHSFRfRklMTFMuUkVEXG4gICAgXSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fQ09MT1IsIEZJTkFOQ0lBTF9MSUdIVF9GSUxMUy5CTFVFKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQU5OT1RBVElPTl9CQUNLR1JPVU5EX0ZJTEwsIEZJTkFOQ0lBTF9MSUdIVF9GSUxMUy5CTFVFKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQVhJU19HUklEX0NPTE9VUiwgXCIjRjJGM0YzXCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9QQURESU5HLCAwKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQ0FQVElPTl9MQVlPVVRfU1RZTEUsIFwib3ZlcmxheVwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQ0FQVElPTl9BTElHTk1FTlQsIFwibGVmdFwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfVE9PTEJBUl9QT1NJVElPTiwgXCJib3R0b21cIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0dSSURMSU5FX0VOQUJMRUQsIHRydWUpO1xuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3RoZW1lcy9tYXRlcmlhbERhcmsudHNcbnZhciBNQVRFUklBTF9EQVJLX0ZJTExTID0ge1xuICBCTFVFOiBcIiMyMTk2RjNcIixcbiAgT1JBTkdFOiBcIiNGRjk4MDBcIixcbiAgR1JFRU46IFwiIzRDQUY1MFwiLFxuICBDWUFOOiBcIiMwMEJDRDRcIixcbiAgWUVMTE9XOiBcIiNGRkVCM0JcIixcbiAgVklPTEVUOiBcIiM3RTU3QzJcIixcbiAgR1JBWTogXCIjOUU5RTlFXCIsXG4gIE1BR0VOVEE6IFwiI0YwNjI5MlwiLFxuICBCUk9XTjogXCIjNzk1NTQ4XCIsXG4gIFJFRDogXCIjRjQ0MzM2XCJcbn07XG52YXIgTUFURVJJQUxfREFSS19TVFJPS0VTID0ge1xuICBCTFVFOiBcIiM5MENBRjlcIixcbiAgT1JBTkdFOiBcIiNGRkNDODBcIixcbiAgR1JFRU46IFwiI0E1RDZBN1wiLFxuICBDWUFOOiBcIiM4MERFRUFcIixcbiAgWUVMTE9XOiBcIiNGRkY5QzRcIixcbiAgVklPTEVUOiBcIiNCMzlEREJcIixcbiAgR1JBWTogXCIjRTBFMEUwXCIsXG4gIE1BR0VOVEE6IFwiI0Y0OEZCMVwiLFxuICBCUk9XTjogXCIjQTE4ODdGXCIsXG4gIFJFRDogXCIjRUY5QTlBXCJcbn07XG52YXIgTWF0ZXJpYWxEYXJrID0gY2xhc3MgZXh0ZW5kcyBEYXJrVGhlbWUge1xuICBnZXREZWZhdWx0Q29sb3JzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBmaWxsczogTUFURVJJQUxfREFSS19GSUxMUyxcbiAgICAgIHN0cm9rZXM6IE1BVEVSSUFMX0RBUktfU1RST0tFUyxcbiAgICAgIHVwOiB7IGZpbGw6IE1BVEVSSUFMX0RBUktfRklMTFMuR1JFRU4sIHN0cm9rZTogTUFURVJJQUxfREFSS19TVFJPS0VTLkdSRUVOIH0sXG4gICAgICBkb3duOiB7IGZpbGw6IE1BVEVSSUFMX0RBUktfRklMTFMuUkVELCBzdHJva2U6IE1BVEVSSUFMX0RBUktfU1RST0tFUy5SRUQgfSxcbiAgICAgIG5ldXRyYWw6IHsgZmlsbDogTUFURVJJQUxfREFSS19GSUxMUy5HUkFZLCBzdHJva2U6IE1BVEVSSUFMX0RBUktfU1RST0tFUy5HUkFZIH0sXG4gICAgICBhbHRVcDogeyBmaWxsOiBNQVRFUklBTF9EQVJLX0ZJTExTLkJMVUUsIHN0cm9rZTogTUFURVJJQUxfREFSS19TVFJPS0VTLkJMVUUgfSxcbiAgICAgIGFsdERvd246IHsgZmlsbDogTUFURVJJQUxfREFSS19GSUxMUy5SRUQsIHN0cm9rZTogTUFURVJJQUxfREFSS19TVFJPS0VTLlJFRCB9LFxuICAgICAgYWx0TmV1dHJhbDogeyBmaWxsOiBNQVRFUklBTF9EQVJLX0ZJTExTLkdSQVksIHN0cm9rZTogTUFURVJJQUxfREFSS19TVFJPS0VTLkdSQVkgfVxuICAgIH07XG4gIH1cbiAgZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHN1cGVyLmdldFRlbXBsYXRlUGFyYW1ldGVycygpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9ESVZFUkdJTkdfU0VSSUVTX0NPTE9SX1JBTkdFLCBbXG4gICAgICBNQVRFUklBTF9EQVJLX0ZJTExTLk9SQU5HRSxcbiAgICAgIE1BVEVSSUFMX0RBUktfRklMTFMuWUVMTE9XLFxuICAgICAgTUFURVJJQUxfREFSS19GSUxMUy5HUkVFTlxuICAgIF0pO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9GVU5ORUxfU0VSSUVTX0NPTE9SX1JBTkdFLCBbXG4gICAgICBcIiMyMTk2ZjNcIixcbiAgICAgIC8vIDUwMFxuICAgICAgXCIjMjA4RkVDXCIsXG4gICAgICAvLyAoaW50ZXJwb2xhdGVkKVxuICAgICAgXCIjMUU4OEU1XCIsXG4gICAgICAvLyA2MDBcbiAgICAgIFwiIzFDN0ZEQ1wiLFxuICAgICAgLy8gKGludGVycG9sYXRlZClcbiAgICAgIFwiIzE5NzZkMlwiLFxuICAgICAgLy8gNzAwXG4gICAgICBcIiMxNzZFQzlcIixcbiAgICAgIC8vIChpbnRlcnBvbGF0ZWQpXG4gICAgICBcIiMxNTY1YzBcIlxuICAgICAgLy8gODAwXG4gICAgXSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0dBVUdFX1NFUklFU19DT0xPUl9SQU5HRSwgW1xuICAgICAgTUFURVJJQUxfREFSS19GSUxMUy5HUkVFTixcbiAgICAgIE1BVEVSSUFMX0RBUktfRklMTFMuWUVMTE9XLFxuICAgICAgTUFURVJJQUxfREFSS19GSUxMUy5SRURcbiAgICBdKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQU5OT1RBVElPTl9DT0xPUiwgTUFURVJJQUxfREFSS19GSUxMUy5CTFVFKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQU5OT1RBVElPTl9CQUNLR1JPVU5EX0ZJTEwsIE1BVEVSSUFMX0RBUktfRklMTFMuQkxVRSk7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvdGhlbWVzL21hdGVyaWFsTGlnaHQudHNcbnZhciBNQVRFUklBTF9MSUdIVF9GSUxMUyA9IHtcbiAgQkxVRTogXCIjMjE5NkYzXCIsXG4gIE9SQU5HRTogXCIjRkY5ODAwXCIsXG4gIEdSRUVOOiBcIiM0Q0FGNTBcIixcbiAgQ1lBTjogXCIjMDBCQ0Q0XCIsXG4gIFlFTExPVzogXCIjRkZFQjNCXCIsXG4gIFZJT0xFVDogXCIjN0U1N0MyXCIsXG4gIEdSQVk6IFwiIzlFOUU5RVwiLFxuICBNQUdFTlRBOiBcIiNGMDYyOTJcIixcbiAgQlJPV046IFwiIzc5NTU0OFwiLFxuICBSRUQ6IFwiI0Y0NDMzNlwiXG59O1xudmFyIE1BVEVSSUFMX0xJR0hUX1NUUk9LRVMgPSB7XG4gIEJMVUU6IFwiIzE1NjVDMFwiLFxuICBPUkFOR0U6IFwiI0U2NTEwMFwiLFxuICBHUkVFTjogXCIjMkU3RDMyXCIsXG4gIENZQU46IFwiIzAwODM4RlwiLFxuICBZRUxMT1c6IFwiI0Y5QTgyNVwiLFxuICBWSU9MRVQ6IFwiIzQ1MjdBMFwiLFxuICBHUkFZOiBcIiM2MTYxNjFcIixcbiAgTUFHRU5UQTogXCIjQzIxODVCXCIsXG4gIEJST1dOOiBcIiM0RTM0MkVcIixcbiAgUkVEOiBcIiNCNzFDMUNcIlxufTtcbnZhciBNYXRlcmlhbExpZ2h0ID0gY2xhc3MgZXh0ZW5kcyBDaGFydFRoZW1lIHtcbiAgZ2V0RGVmYXVsdENvbG9ycygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZmlsbHM6IE1BVEVSSUFMX0xJR0hUX0ZJTExTLFxuICAgICAgc3Ryb2tlczogTUFURVJJQUxfTElHSFRfU1RST0tFUyxcbiAgICAgIHVwOiB7IGZpbGw6IE1BVEVSSUFMX0xJR0hUX0ZJTExTLkdSRUVOLCBzdHJva2U6IE1BVEVSSUFMX0xJR0hUX1NUUk9LRVMuR1JFRU4gfSxcbiAgICAgIGRvd246IHsgZmlsbDogTUFURVJJQUxfTElHSFRfRklMTFMuUkVELCBzdHJva2U6IE1BVEVSSUFMX0xJR0hUX1NUUk9LRVMuUkVEIH0sXG4gICAgICBuZXV0cmFsOiB7IGZpbGw6IE1BVEVSSUFMX0xJR0hUX0ZJTExTLkdSQVksIHN0cm9rZTogTUFURVJJQUxfTElHSFRfU1RST0tFUy5HUkFZIH0sXG4gICAgICBhbHRVcDogeyBmaWxsOiBNQVRFUklBTF9MSUdIVF9GSUxMUy5CTFVFLCBzdHJva2U6IE1BVEVSSUFMX0xJR0hUX1NUUk9LRVMuQkxVRSB9LFxuICAgICAgYWx0RG93bjogeyBmaWxsOiBNQVRFUklBTF9MSUdIVF9GSUxMUy5SRUQsIHN0cm9rZTogTUFURVJJQUxfTElHSFRfU1RST0tFUy5SRUQgfSxcbiAgICAgIGFsdE5ldXRyYWw6IHsgZmlsbDogTUFURVJJQUxfTElHSFRfRklMTFMuR1JBWSwgc3Ryb2tlOiBNQVRFUklBTF9MSUdIVF9TVFJPS0VTLkdSQVkgfVxuICAgIH07XG4gIH1cbiAgZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHN1cGVyLmdldFRlbXBsYXRlUGFyYW1ldGVycygpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9ESVZFUkdJTkdfU0VSSUVTX0NPTE9SX1JBTkdFLCBbXG4gICAgICBNQVRFUklBTF9MSUdIVF9GSUxMUy5PUkFOR0UsXG4gICAgICBNQVRFUklBTF9MSUdIVF9GSUxMUy5ZRUxMT1csXG4gICAgICBNQVRFUklBTF9MSUdIVF9GSUxMUy5HUkVFTlxuICAgIF0pO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9GVU5ORUxfU0VSSUVTX0NPTE9SX1JBTkdFLCBbXG4gICAgICBcIiMyMTk2ZjNcIixcbiAgICAgIC8vIDUwMFxuICAgICAgXCIjMzI5RUY0XCIsXG4gICAgICAvLyAoaW50ZXJwb2xhdGVkKVxuICAgICAgXCIjNDJhNWY1XCIsXG4gICAgICAvLyA0MDBcbiAgICAgIFwiIzUzQURGNlwiLFxuICAgICAgLy8gKGludGVycG9sYXRlZClcbiAgICAgIFwiIzY0YjVmNlwiLFxuICAgICAgLy8gMzAwXG4gICAgICBcIiM3QUMwRjhcIixcbiAgICAgIC8vIChpbnRlcnBvbGF0ZWQpXG4gICAgICBcIiM5MGNhZjlcIlxuICAgICAgLy8gMjAwXG4gICAgXSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0dBVUdFX1NFUklFU19DT0xPUl9SQU5HRSwgW1xuICAgICAgTUFURVJJQUxfTElHSFRfRklMTFMuR1JFRU4sXG4gICAgICBNQVRFUklBTF9MSUdIVF9GSUxMUy5ZRUxMT1csXG4gICAgICBNQVRFUklBTF9MSUdIVF9GSUxMUy5SRURcbiAgICBdKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQU5OT1RBVElPTl9DT0xPUiwgTUFURVJJQUxfTElHSFRfRklMTFMuQkxVRSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fQkFDS0dST1VORF9GSUxMLCBNQVRFUklBTF9MSUdIVF9GSUxMUy5CTFVFKTtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC90aGVtZXMvcG9seWNocm9tYURhcmsudHNcbnZhciBQT0xZQ0hST01BX0RBUktfRklMTFMgPSB7XG4gIEJMVUU6IFwiIzQzNmZmNFwiLFxuICBQVVJQTEU6IFwiIzlhN2JmZlwiLFxuICBNQUdFTlRBOiBcIiNkMTY1ZDJcIixcbiAgUElOSzogXCIjZjA1OThiXCIsXG4gIFJFRDogXCIjZjQ3MzQ4XCIsXG4gIE9SQU5HRTogXCIjZjJhNjAyXCIsXG4gIFlFTExPVzogXCIjZTllMjAxXCIsXG4gIEdSRUVOOiBcIiMyMWI0NDhcIixcbiAgQ1lBTjogXCIjMDBiOWEyXCIsXG4gIE1PREVSQVRFX0JMVUU6IFwiIzAwYWVlNFwiLFxuICBHUkFZOiBcIiNiYmJiYmJcIlxufTtcbnZhciBQT0xZQ0hST01BX0RBUktfU1RST0tFUyA9IHtcbiAgQkxVRTogXCIjNjY5OGZmXCIsXG4gIFBVUlBMRTogXCIjYzBhM2ZmXCIsXG4gIE1BR0VOVEE6IFwiI2ZjOGRmY1wiLFxuICBQSU5LOiBcIiNmZjgyYjFcIixcbiAgUkVEOiBcIiNmZjliNzBcIixcbiAgT1JBTkdFOiBcIiNmZmNmNGVcIixcbiAgWUVMTE9XOiBcIiNmZmZmNThcIixcbiAgR1JFRU46IFwiIzU4ZGQ3MFwiLFxuICBDWUFOOiBcIiM1MWUyYzlcIixcbiAgTU9ERVJBVEVfQkxVRTogXCIjNGZkN2ZmXCIsXG4gIEdSQVk6IFwiI2VlZWVlZVwiXG59O1xudmFyIFBvbHljaHJvbWFEYXJrID0gY2xhc3MgZXh0ZW5kcyBEYXJrVGhlbWUge1xuICBnZXREZWZhdWx0Q29sb3JzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBmaWxsczogUE9MWUNIUk9NQV9EQVJLX0ZJTExTLFxuICAgICAgc3Ryb2tlczogUE9MWUNIUk9NQV9EQVJLX1NUUk9LRVMsXG4gICAgICB1cDogeyBmaWxsOiBQT0xZQ0hST01BX0RBUktfRklMTFMuR1JFRU4sIHN0cm9rZTogUE9MWUNIUk9NQV9EQVJLX1NUUk9LRVMuR1JFRU4gfSxcbiAgICAgIGRvd246IHsgZmlsbDogUE9MWUNIUk9NQV9EQVJLX0ZJTExTLlJFRCwgc3Ryb2tlOiBQT0xZQ0hST01BX0RBUktfU1RST0tFUy5SRUQgfSxcbiAgICAgIG5ldXRyYWw6IHsgZmlsbDogUE9MWUNIUk9NQV9EQVJLX0ZJTExTLkdSQVksIHN0cm9rZTogUE9MWUNIUk9NQV9EQVJLX1NUUk9LRVMuR1JBWSB9LFxuICAgICAgYWx0VXA6IHsgZmlsbDogUE9MWUNIUk9NQV9EQVJLX0ZJTExTLkJMVUUsIHN0cm9rZTogUE9MWUNIUk9NQV9EQVJLX1NUUk9LRVMuQkxVRSB9LFxuICAgICAgYWx0RG93bjogeyBmaWxsOiBQT0xZQ0hST01BX0RBUktfRklMTFMuUkVELCBzdHJva2U6IFBPTFlDSFJPTUFfREFSS19TVFJPS0VTLlJFRCB9LFxuICAgICAgYWx0TmV1dHJhbDogeyBmaWxsOiBQT0xZQ0hST01BX0RBUktfRklMTFMuR1JBWSwgc3Ryb2tlOiBQT0xZQ0hST01BX0RBUktfU1RST0tFUy5HUkFZIH1cbiAgICB9O1xuICB9XG4gIGdldFRlbXBsYXRlUGFyYW1ldGVycygpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBzdXBlci5nZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfRElWRVJHSU5HX1NFUklFU19DT0xPUl9SQU5HRSwgW1BPTFlDSFJPTUFfREFSS19GSUxMUy5CTFVFLCBQT0xZQ0hST01BX0RBUktfRklMTFMuUkVEXSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0ZVTk5FTF9TRVJJRVNfQ09MT1JfUkFOR0UsIFtcbiAgICAgIFBPTFlDSFJPTUFfREFSS19GSUxMUy5CTFVFLFxuICAgICAgUE9MWUNIUk9NQV9EQVJLX0ZJTExTLlBVUlBMRSxcbiAgICAgIFBPTFlDSFJPTUFfREFSS19GSUxMUy5NQUdFTlRBLFxuICAgICAgUE9MWUNIUk9NQV9EQVJLX0ZJTExTLlBJTkssXG4gICAgICBQT0xZQ0hST01BX0RBUktfRklMTFMuUkVELFxuICAgICAgUE9MWUNIUk9NQV9EQVJLX0ZJTExTLk9SQU5HRSxcbiAgICAgIFBPTFlDSFJPTUFfREFSS19GSUxMUy5ZRUxMT1csXG4gICAgICBQT0xZQ0hST01BX0RBUktfRklMTFMuR1JFRU5cbiAgICBdKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfR0FVR0VfU0VSSUVTX0NPTE9SX1JBTkdFLCBbUE9MWUNIUk9NQV9EQVJLX0ZJTExTLkJMVUUsIFBPTFlDSFJPTUFfREFSS19GSUxMUy5SRURdKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQU5OT1RBVElPTl9DT0xPUiwgUE9MWUNIUk9NQV9EQVJLX0ZJTExTLkJMVUUpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX0JBQ0tHUk9VTkRfRklMTCwgUE9MWUNIUk9NQV9EQVJLX0ZJTExTLkJMVUUpO1xuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3RoZW1lcy9wb2x5Y2hyb21hTGlnaHQudHNcbnZhciBQT0xZQ0hST01BX0xJR0hUX0ZJTExTID0ge1xuICBCTFVFOiBcIiM0MzZmZjRcIixcbiAgUFVSUExFOiBcIiM5YTdiZmZcIixcbiAgTUFHRU5UQTogXCIjZDE2NWQyXCIsXG4gIFBJTks6IFwiI2YwNTk4YlwiLFxuICBSRUQ6IFwiI2Y0NzM0OFwiLFxuICBPUkFOR0U6IFwiI2YyYTYwMlwiLFxuICBZRUxMT1c6IFwiI2U5ZTIwMVwiLFxuICBHUkVFTjogXCIjMjFiNDQ4XCIsXG4gIENZQU46IFwiIzAwYjlhMlwiLFxuICBNT0RFUkFURV9CTFVFOiBcIiMwMGFlZTRcIixcbiAgR1JBWTogXCIjYmJiYmJiXCJcbn07XG52YXIgUE9MWUNIUk9NQV9MSUdIVF9TVFJPS0VTID0ge1xuICBCTFVFOiBcIiMyMzQ2YzlcIixcbiAgUFVSUExFOiBcIiM3NjUzZDRcIixcbiAgTUFHRU5UQTogXCIjYTczZGE5XCIsXG4gIFBJTks6IFwiI2MzMmQ2NlwiLFxuICBSRUQ6IFwiI2M4NGIxY1wiLFxuICBPUkFOR0U6IFwiI2M4N2YwMFwiLFxuICBZRUxMT1c6IFwiI2MxYjkwMFwiLFxuICBHUkVFTjogXCIjMDA4YzFjXCIsXG4gIENZQU46IFwiIzAwOTI3Y1wiLFxuICBNT0RFUkFURV9CTFVFOiBcIiMwMDg3YmJcIixcbiAgR1JBWTogXCIjODg4ODg4XCJcbn07XG52YXIgUG9seWNocm9tYUxpZ2h0ID0gY2xhc3MgZXh0ZW5kcyBDaGFydFRoZW1lIHtcbiAgZ2V0RGVmYXVsdENvbG9ycygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZmlsbHM6IFBPTFlDSFJPTUFfTElHSFRfRklMTFMsXG4gICAgICBzdHJva2VzOiBQT0xZQ0hST01BX0xJR0hUX1NUUk9LRVMsXG4gICAgICB1cDogeyBmaWxsOiBQT0xZQ0hST01BX0xJR0hUX0ZJTExTLkdSRUVOLCBzdHJva2U6IFBPTFlDSFJPTUFfTElHSFRfU1RST0tFUy5HUkVFTiB9LFxuICAgICAgZG93bjogeyBmaWxsOiBQT0xZQ0hST01BX0xJR0hUX0ZJTExTLlJFRCwgc3Ryb2tlOiBQT0xZQ0hST01BX0xJR0hUX1NUUk9LRVMuUkVEIH0sXG4gICAgICBuZXV0cmFsOiB7IGZpbGw6IFBPTFlDSFJPTUFfTElHSFRfRklMTFMuR1JBWSwgc3Ryb2tlOiBQT0xZQ0hST01BX0xJR0hUX1NUUk9LRVMuR1JBWSB9LFxuICAgICAgYWx0VXA6IHsgZmlsbDogUE9MWUNIUk9NQV9MSUdIVF9GSUxMUy5CTFVFLCBzdHJva2U6IFBPTFlDSFJPTUFfTElHSFRfU1RST0tFUy5CTFVFIH0sXG4gICAgICBhbHREb3duOiB7IGZpbGw6IFBPTFlDSFJPTUFfTElHSFRfRklMTFMuUkVELCBzdHJva2U6IFBPTFlDSFJPTUFfTElHSFRfU1RST0tFUy5SRUQgfSxcbiAgICAgIGFsdE5ldXRyYWw6IHsgZmlsbDogUE9MWUNIUk9NQV9MSUdIVF9GSUxMUy5HUkFZLCBzdHJva2U6IFBPTFlDSFJPTUFfTElHSFRfU1RST0tFUy5HUkFZIH1cbiAgICB9O1xuICB9XG4gIGdldFRlbXBsYXRlUGFyYW1ldGVycygpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBzdXBlci5nZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfRElWRVJHSU5HX1NFUklFU19DT0xPUl9SQU5HRSwgW1BPTFlDSFJPTUFfTElHSFRfRklMTFMuQkxVRSwgUE9MWUNIUk9NQV9MSUdIVF9GSUxMUy5SRURdKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfRlVOTkVMX1NFUklFU19DT0xPUl9SQU5HRSwgW1xuICAgICAgUE9MWUNIUk9NQV9MSUdIVF9GSUxMUy5CTFVFLFxuICAgICAgUE9MWUNIUk9NQV9MSUdIVF9GSUxMUy5QVVJQTEUsXG4gICAgICBQT0xZQ0hST01BX0xJR0hUX0ZJTExTLk1BR0VOVEEsXG4gICAgICBQT0xZQ0hST01BX0xJR0hUX0ZJTExTLlBJTkssXG4gICAgICBQT0xZQ0hST01BX0xJR0hUX0ZJTExTLlJFRCxcbiAgICAgIFBPTFlDSFJPTUFfTElHSFRfRklMTFMuT1JBTkdFLFxuICAgICAgUE9MWUNIUk9NQV9MSUdIVF9GSUxMUy5ZRUxMT1csXG4gICAgICBQT0xZQ0hST01BX0xJR0hUX0ZJTExTLkdSRUVOXG4gICAgXSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0dBVUdFX1NFUklFU19DT0xPUl9SQU5HRSwgW1BPTFlDSFJPTUFfTElHSFRfRklMTFMuQkxVRSwgUE9MWUNIUk9NQV9MSUdIVF9GSUxMUy5SRURdKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQU5OT1RBVElPTl9DT0xPUiwgUE9MWUNIUk9NQV9MSUdIVF9GSUxMUy5CTFVFKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQU5OT1RBVElPTl9CQUNLR1JPVU5EX0ZJTEwsIFBPTFlDSFJPTUFfTElHSFRfRklMTFMuQkxVRSk7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvdGhlbWVzL3NoZWV0c0RhcmsudHNcbnZhciBTSEVFVFNfREFSS19GSUxMUyA9IHtcbiAgQkxVRTogXCIjNDQ3MkM0XCIsXG4gIE9SQU5HRTogXCIjRUQ3RDMxXCIsXG4gIEdSQVk6IFwiI0E1QTVBNVwiLFxuICBZRUxMT1c6IFwiI0ZGQzAwMFwiLFxuICBNT0RFUkFURV9CTFVFOiBcIiM1QjlCRDVcIixcbiAgR1JFRU46IFwiIzcwQUQ0N1wiLFxuICBEQVJLX0dSQVk6IFwiIzdCN0I3QlwiLFxuICBEQVJLX0JMVUU6IFwiIzI2NDQ3OFwiLFxuICBWRVJZX0RBUktfR1JBWTogXCIjNjM2MzYzXCIsXG4gIERBUktfWUVMTE9XOiBcIiM5OTczMDBcIlxufTtcbnZhciBTSEVFVFNfREFSS19TVFJPS0VTID0ge1xuICBCTFVFOiBcIiM2ODk5ZWVcIixcbiAgT1JBTkdFOiBcIiNmZmE1NWRcIixcbiAgR1JBWTogXCIjY2RjZGNkXCIsXG4gIFlFTExPVzogXCIjZmZlYTUzXCIsXG4gIE1PREVSQVRFX0JMVUU6IFwiIzgyYzNmZlwiLFxuICBHUkVFTjogXCIjOTZkNTZmXCIsXG4gIERBUktfR1JBWTogXCIjYTFhMWExXCIsXG4gIERBUktfQkxVRTogXCIjNDc2ODlmXCIsXG4gIFZFUllfREFSS19HUkFZOiBcIiM4Nzg3ODdcIixcbiAgREFSS19ZRUxMT1c6IFwiI2MwOTkzZFwiXG59O1xudmFyIFNoZWV0c0RhcmsgPSBjbGFzcyBleHRlbmRzIERhcmtUaGVtZSB7XG4gIGdldERlZmF1bHRDb2xvcnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpbGxzOiB7IC4uLlNIRUVUU19EQVJLX0ZJTExTLCBSRUQ6IFNIRUVUU19EQVJLX0ZJTExTLk9SQU5HRSB9LFxuICAgICAgc3Ryb2tlczogeyAuLi5TSEVFVFNfREFSS19TVFJPS0VTLCBSRUQ6IFNIRUVUU19EQVJLX1NUUk9LRVMuT1JBTkdFIH0sXG4gICAgICB1cDogeyBmaWxsOiBTSEVFVFNfREFSS19GSUxMUy5HUkVFTiwgc3Ryb2tlOiBTSEVFVFNfREFSS19TVFJPS0VTLkdSRUVOIH0sXG4gICAgICBkb3duOiB7IGZpbGw6IFNIRUVUU19EQVJLX0ZJTExTLk9SQU5HRSwgc3Ryb2tlOiBTSEVFVFNfREFSS19TVFJPS0VTLk9SQU5HRSB9LFxuICAgICAgbmV1dHJhbDogeyBmaWxsOiBTSEVFVFNfREFSS19GSUxMUy5HUkFZLCBzdHJva2U6IFNIRUVUU19EQVJLX1NUUk9LRVMuR1JBWSB9LFxuICAgICAgYWx0VXA6IHsgZmlsbDogU0hFRVRTX0RBUktfRklMTFMuQkxVRSwgc3Ryb2tlOiBTSEVFVFNfREFSS19TVFJPS0VTLkJMVUUgfSxcbiAgICAgIGFsdERvd246IHsgZmlsbDogU0hFRVRTX0RBUktfRklMTFMuT1JBTkdFLCBzdHJva2U6IFNIRUVUU19EQVJLX1NUUk9LRVMuT1JBTkdFIH0sXG4gICAgICBhbHROZXV0cmFsOiB7IGZpbGw6IFNIRUVUU19EQVJLX0ZJTExTLkdSQVksIHN0cm9rZTogU0hFRVRTX0RBUktfU1RST0tFUy5HUkFZIH1cbiAgICB9O1xuICB9XG4gIGdldFRlbXBsYXRlUGFyYW1ldGVycygpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBzdXBlci5nZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfRElWRVJHSU5HX1NFUklFU19DT0xPUl9SQU5HRSwgW1xuICAgICAgU0hFRVRTX0RBUktfRklMTFMuT1JBTkdFLFxuICAgICAgU0hFRVRTX0RBUktfRklMTFMuWUVMTE9XLFxuICAgICAgU0hFRVRTX0RBUktfRklMTFMuR1JFRU5cbiAgICBdKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfR0FVR0VfU0VSSUVTX0NPTE9SX1JBTkdFLCBbXG4gICAgICBTSEVFVFNfREFSS19GSUxMUy5HUkVFTixcbiAgICAgIFNIRUVUU19EQVJLX0ZJTExTLllFTExPVyxcbiAgICAgIFNIRUVUU19EQVJLX0ZJTExTLk9SQU5HRVxuICAgIF0pO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX0NPTE9SLCBTSEVFVFNfREFSS19GSUxMUy5CTFVFKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQU5OT1RBVElPTl9CQUNLR1JPVU5EX0ZJTEwsIFNIRUVUU19EQVJLX0ZJTExTLkJMVUUpO1xuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3RoZW1lcy9zaGVldHNMaWdodC50c1xudmFyIFNIRUVUU19MSUdIVF9GSUxMUyA9IHtcbiAgQkxVRTogXCIjNTI4MWQ1XCIsXG4gIE9SQU5HRTogXCIjZmY4ZDQ0XCIsXG4gIEdSQVk6IFwiI2I1YjViNVwiLFxuICBZRUxMT1c6IFwiI2ZmZDAyZlwiLFxuICBNT0RFUkFURV9CTFVFOiBcIiM2YWFiZTZcIixcbiAgR1JFRU46IFwiIzdmYmQ1N1wiLFxuICBEQVJLX0dSQVk6IFwiIzhhOGE4YVwiLFxuICBEQVJLX0JMVUU6IFwiIzMzNTI4N1wiLFxuICBWRVJZX0RBUktfR1JBWTogXCIjNzE3MTcxXCIsXG4gIERBUktfWUVMTE9XOiBcIiNhOTgyMjBcIlxufTtcbnZhciBTSEVFVFNfTElHSFRfU1RST0tFUyA9IHtcbiAgQkxVRTogXCIjMjE0ZDliXCIsXG4gIE9SQU5HRTogXCIjYzI1NjAwXCIsXG4gIEdSQVk6IFwiIzdmN2Y3ZlwiLFxuICBZRUxMT1c6IFwiI2Q1OTgwMFwiLFxuICBNT0RFUkFURV9CTFVFOiBcIiMzNTc1YWNcIixcbiAgR1JFRU46IFwiIzRiODYxYVwiLFxuICBEQVJLX0dSQVk6IFwiIzU3NTc1N1wiLFxuICBEQVJLX0JMVUU6IFwiIzA2MjI1M1wiLFxuICBWRVJZX0RBUktfR1JBWTogXCIjNDE0MTQxXCIsXG4gIERBUktfWUVMTE9XOiBcIiM3MzRmMDBcIlxufTtcbnZhciBTaGVldHNMaWdodCA9IGNsYXNzIGV4dGVuZHMgQ2hhcnRUaGVtZSB7XG4gIGdldERlZmF1bHRDb2xvcnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpbGxzOiB7IC4uLlNIRUVUU19MSUdIVF9GSUxMUywgUkVEOiBTSEVFVFNfTElHSFRfRklMTFMuT1JBTkdFIH0sXG4gICAgICBzdHJva2VzOiB7IC4uLlNIRUVUU19MSUdIVF9TVFJPS0VTLCBSRUQ6IFNIRUVUU19MSUdIVF9TVFJPS0VTLk9SQU5HRSB9LFxuICAgICAgdXA6IHsgZmlsbDogU0hFRVRTX0xJR0hUX0ZJTExTLkdSRUVOLCBzdHJva2U6IFNIRUVUU19MSUdIVF9TVFJPS0VTLkdSRUVOIH0sXG4gICAgICBkb3duOiB7IGZpbGw6IFNIRUVUU19MSUdIVF9GSUxMUy5PUkFOR0UsIHN0cm9rZTogU0hFRVRTX0xJR0hUX1NUUk9LRVMuT1JBTkdFIH0sXG4gICAgICBuZXV0cmFsOiB7IGZpbGw6IFNIRUVUU19MSUdIVF9TVFJPS0VTLkdSQVksIHN0cm9rZTogU0hFRVRTX0xJR0hUX1NUUk9LRVMuR1JBWSB9LFxuICAgICAgYWx0VXA6IHsgZmlsbDogU0hFRVRTX0xJR0hUX0ZJTExTLkJMVUUsIHN0cm9rZTogU0hFRVRTX0xJR0hUX1NUUk9LRVMuQkxVRSB9LFxuICAgICAgYWx0RG93bjogeyBmaWxsOiBTSEVFVFNfTElHSFRfRklMTFMuT1JBTkdFLCBzdHJva2U6IFNIRUVUU19MSUdIVF9TVFJPS0VTLk9SQU5HRSB9LFxuICAgICAgYWx0TmV1dHJhbDogeyBmaWxsOiBTSEVFVFNfTElHSFRfRklMTFMuR1JBWSwgc3Ryb2tlOiBTSEVFVFNfTElHSFRfU1RST0tFUy5HUkFZIH1cbiAgICB9O1xuICB9XG4gIGdldFRlbXBsYXRlUGFyYW1ldGVycygpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBzdXBlci5nZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfRElWRVJHSU5HX1NFUklFU19DT0xPUl9SQU5HRSwgW1xuICAgICAgU0hFRVRTX0xJR0hUX0ZJTExTLk9SQU5HRSxcbiAgICAgIFNIRUVUU19MSUdIVF9GSUxMUy5ZRUxMT1csXG4gICAgICBTSEVFVFNfTElHSFRfRklMTFMuR1JFRU5cbiAgICBdKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfR0FVR0VfU0VSSUVTX0NPTE9SX1JBTkdFLCBbXG4gICAgICBTSEVFVFNfTElHSFRfRklMTFMuR1JFRU4sXG4gICAgICBTSEVFVFNfTElHSFRfRklMTFMuWUVMTE9XLFxuICAgICAgU0hFRVRTX0xJR0hUX0ZJTExTLk9SQU5HRVxuICAgIF0pO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX0NPTE9SLCBTSEVFVFNfTElHSFRfRklMTFMuQkxVRSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fQkFDS0dST1VORF9GSUxMLCBTSEVFVFNfTElHSFRfRklMTFMuQkxVRSk7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvdGhlbWVzL3ZpdmlkRGFyay50c1xudmFyIFZJVklEX0RBUktfRklMTFMgPSB7XG4gIEJMVUU6IFwiIzAwODNmZlwiLFxuICBPUkFOR0U6IFwiI2ZmNjYwMFwiLFxuICBHUkVFTjogXCIjMDBhZjAwXCIsXG4gIENZQU46IFwiIzAwY2NmZlwiLFxuICBZRUxMT1c6IFwiI2Y3YzcwMFwiLFxuICBWSU9MRVQ6IFwiI2FjMjZmZlwiLFxuICBHUkFZOiBcIiNhN2E3YjdcIixcbiAgTUFHRU5UQTogXCIjZTgwMGM1XCIsXG4gIEJST1dOOiBcIiNiNTQzMDBcIixcbiAgUkVEOiBcIiNmZjAwMDBcIlxufTtcbnZhciBWSVZJRF9EQVJLX1NUUk9LRVMgPSB7XG4gIEJMVUU6IFwiIzY3YjdmZlwiLFxuICBPUkFOR0U6IFwiI2ZmYzI0ZFwiLFxuICBHUkVFTjogXCIjNWNjODZmXCIsXG4gIENZQU46IFwiIzU0ZWJmZlwiLFxuICBWSU9MRVQ6IFwiI2ZmZjY1M1wiLFxuICBZRUxMT1c6IFwiI2MxOGFmZlwiLFxuICBHUkFZOiBcIiNhZWFlYWVcIixcbiAgTUFHRU5UQTogXCIjZjA3OGQ0XCIsXG4gIEJST1dOOiBcIiNiYTg0MzhcIixcbiAgUkVEOiBcIiNmZjcyNmVcIlxufTtcbnZhciBWaXZpZERhcmsgPSBjbGFzcyBleHRlbmRzIERhcmtUaGVtZSB7XG4gIGdldERlZmF1bHRDb2xvcnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpbGxzOiBWSVZJRF9EQVJLX0ZJTExTLFxuICAgICAgc3Ryb2tlczogVklWSURfREFSS19TVFJPS0VTLFxuICAgICAgdXA6IHsgZmlsbDogVklWSURfREFSS19GSUxMUy5HUkVFTiwgc3Ryb2tlOiBWSVZJRF9EQVJLX1NUUk9LRVMuR1JFRU4gfSxcbiAgICAgIGRvd246IHsgZmlsbDogVklWSURfREFSS19GSUxMUy5SRUQsIHN0cm9rZTogVklWSURfREFSS19TVFJPS0VTLlJFRCB9LFxuICAgICAgbmV1dHJhbDogeyBmaWxsOiBWSVZJRF9EQVJLX0ZJTExTLkdSQVksIHN0cm9rZTogVklWSURfREFSS19TVFJPS0VTLkdSQVkgfSxcbiAgICAgIGFsdFVwOiB7IGZpbGw6IFZJVklEX0RBUktfRklMTFMuQkxVRSwgc3Ryb2tlOiBWSVZJRF9EQVJLX1NUUk9LRVMuQkxVRSB9LFxuICAgICAgYWx0RG93bjogeyBmaWxsOiBWSVZJRF9EQVJLX0ZJTExTLk9SQU5HRSwgc3Ryb2tlOiBWSVZJRF9EQVJLX1NUUk9LRVMuT1JBTkdFIH0sXG4gICAgICBhbHROZXV0cmFsOiB7IGZpbGw6IFZJVklEX0RBUktfRklMTFMuR1JBWSwgc3Ryb2tlOiBWSVZJRF9EQVJLX1NUUk9LRVMuR1JBWSB9XG4gICAgfTtcbiAgfVxuICBnZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKSB7XG4gICAgY29uc3QgcGFyYW1zID0gc3VwZXIuZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKCk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0RJVkVSR0lOR19TRVJJRVNfQ09MT1JfUkFOR0UsIFtcbiAgICAgIFZJVklEX0RBUktfRklMTFMuT1JBTkdFLFxuICAgICAgVklWSURfREFSS19GSUxMUy5ZRUxMT1csXG4gICAgICBWSVZJRF9EQVJLX0ZJTExTLkdSRUVOXG4gICAgXSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0ZVTk5FTF9TRVJJRVNfQ09MT1JfUkFOR0UsIFtcbiAgICAgIFwiIzAwODNmZlwiLFxuICAgICAgXCIjMDA3NmU2XCIsXG4gICAgICBcIiMwMDY5Y2NcIixcbiAgICAgIFwiIzAwNWNiM1wiLFxuICAgICAgXCIjMDA0Zjk5XCIsXG4gICAgICBcIiMwMDQyODBcIixcbiAgICAgIFwiIzAwMzQ2NlwiLFxuICAgICAgXCIjMDAyNzRjXCJcbiAgICBdKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfR0FVR0VfU0VSSUVTX0NPTE9SX1JBTkdFLCBbXG4gICAgICBWSVZJRF9EQVJLX0ZJTExTLkdSRUVOLFxuICAgICAgVklWSURfREFSS19GSUxMUy5ZRUxMT1csXG4gICAgICBWSVZJRF9EQVJLX0ZJTExTLlJFRFxuICAgIF0pO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX0NPTE9SLCBWSVZJRF9EQVJLX0ZJTExTLkJMVUUpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX0JBQ0tHUk9VTkRfRklMTCwgVklWSURfREFSS19GSUxMUy5CTFVFKTtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC90aGVtZXMvdml2aWRMaWdodC50c1xudmFyIFZJVklEX0ZJTExTID0ge1xuICBCTFVFOiBcIiMwMDgzZmZcIixcbiAgT1JBTkdFOiBcIiNmZjY2MDBcIixcbiAgR1JFRU46IFwiIzAwYWYwMFwiLFxuICBDWUFOOiBcIiMwMGNjZmZcIixcbiAgWUVMTE9XOiBcIiNmN2M3MDBcIixcbiAgVklPTEVUOiBcIiNhYzI2ZmZcIixcbiAgR1JBWTogXCIjYTdhN2I3XCIsXG4gIE1BR0VOVEE6IFwiI2U4MDBjNVwiLFxuICBCUk9XTjogXCIjYjU0MzAwXCIsXG4gIFJFRDogXCIjZmYwMDAwXCJcbn07XG52YXIgVklWSURfU1RST0tFUyA9IHtcbiAgQkxVRTogXCIjMGY2OGMwXCIsXG4gIE9SQU5HRTogXCIjZDQ3MTAwXCIsXG4gIEdSRUVOOiBcIiMwMDc5MjJcIixcbiAgQ1lBTjogXCIjMDA5YWMyXCIsXG4gIFZJT0xFVDogXCIjYmNhNDAwXCIsXG4gIFlFTExPVzogXCIjNzUzY2FjXCIsXG4gIEdSQVk6IFwiIzY0NjQ2NFwiLFxuICBNQUdFTlRBOiBcIiM5YjI2ODVcIixcbiAgQlJPV046IFwiIzZjM2IwMFwiLFxuICBSRUQ6IFwiI2NiMDAyMVwiXG59O1xudmFyIFZpdmlkTGlnaHQgPSBjbGFzcyBleHRlbmRzIENoYXJ0VGhlbWUge1xuICBnZXREZWZhdWx0Q29sb3JzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBmaWxsczogVklWSURfRklMTFMsXG4gICAgICBzdHJva2VzOiBWSVZJRF9TVFJPS0VTLFxuICAgICAgdXA6IHsgZmlsbDogVklWSURfRklMTFMuR1JFRU4sIHN0cm9rZTogVklWSURfU1RST0tFUy5HUkVFTiB9LFxuICAgICAgZG93bjogeyBmaWxsOiBWSVZJRF9GSUxMUy5SRUQsIHN0cm9rZTogVklWSURfU1RST0tFUy5SRUQgfSxcbiAgICAgIG5ldXRyYWw6IHsgZmlsbDogVklWSURfRklMTFMuR1JBWSwgc3Ryb2tlOiBWSVZJRF9TVFJPS0VTLkdSQVkgfSxcbiAgICAgIGFsdFVwOiB7IGZpbGw6IFZJVklEX0ZJTExTLkJMVUUsIHN0cm9rZTogVklWSURfU1RST0tFUy5CTFVFIH0sXG4gICAgICBhbHREb3duOiB7IGZpbGw6IFZJVklEX0ZJTExTLk9SQU5HRSwgc3Ryb2tlOiBWSVZJRF9TVFJPS0VTLk9SQU5HRSB9LFxuICAgICAgYWx0TmV1dHJhbDogeyBmaWxsOiBWSVZJRF9GSUxMUy5HUkFZLCBzdHJva2U6IFZJVklEX1NUUk9LRVMuR1JBWSB9XG4gICAgfTtcbiAgfVxuICBnZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKSB7XG4gICAgY29uc3QgcGFyYW1zID0gc3VwZXIuZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKCk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0RJVkVSR0lOR19TRVJJRVNfQ09MT1JfUkFOR0UsIFtWSVZJRF9GSUxMUy5PUkFOR0UsIFZJVklEX0ZJTExTLllFTExPVywgVklWSURfRklMTFMuR1JFRU5dKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfRlVOTkVMX1NFUklFU19DT0xPUl9SQU5HRSwgW1xuICAgICAgXCIjMDA4M2ZmXCIsXG4gICAgICBcIiMxYThmZmZcIixcbiAgICAgIFwiIzMzOWNmZlwiLFxuICAgICAgXCIjNGRhOGZmXCIsXG4gICAgICBcIiM2NmI1ZmZcIixcbiAgICAgIFwiIzgwYzFmZlwiLFxuICAgICAgXCIjOTljZGZmXCIsXG4gICAgICBcIiNiM2RhZmZcIlxuICAgIF0pO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9HQVVHRV9TRVJJRVNfQ09MT1JfUkFOR0UsIFtWSVZJRF9GSUxMUy5HUkVFTiwgVklWSURfRklMTFMuWUVMTE9XLCBWSVZJRF9GSUxMUy5SRURdKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQU5OT1RBVElPTl9DT0xPUiwgVklWSURfRklMTFMuQkxVRSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fQkFDS0dST1VORF9GSUxMLCBWSVZJRF9GSUxMUy5CTFVFKTtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9tYXBwaW5nL3RoZW1lcy50c1xudmFyIGxpZ2h0VGhlbWUgPSAoKSA9PiBuZXcgQ2hhcnRUaGVtZSgpO1xudmFyIGRhcmtUaGVtZSA9ICgpID0+IG5ldyBEYXJrVGhlbWUoKTtcbnZhciB0aGVtZXMgPSB7XG4gIC8vIGRhcmtUaGVtZXMsXG4gIFwiYWctZGVmYXVsdC1kYXJrXCI6IGRhcmtUaGVtZSxcbiAgXCJhZy1zaGVldHMtZGFya1wiOiAoKSA9PiBuZXcgU2hlZXRzRGFyaygpLFxuICBcImFnLXBvbHljaHJvbWEtZGFya1wiOiAoKSA9PiBuZXcgUG9seWNocm9tYURhcmsoKSxcbiAgXCJhZy12aXZpZC1kYXJrXCI6ICgpID0+IG5ldyBWaXZpZERhcmsoKSxcbiAgXCJhZy1tYXRlcmlhbC1kYXJrXCI6ICgpID0+IG5ldyBNYXRlcmlhbERhcmsoKSxcbiAgXCJhZy1maW5hbmNpYWwtZGFya1wiOiAoKSA9PiBuZXcgRmluYW5jaWFsRGFyaygpLFxuICAvLyBsaWdodFRoZW1lcyxcbiAgbnVsbDogbGlnaHRUaGVtZSxcbiAgdW5kZWZpbmVkOiBsaWdodFRoZW1lLFxuICBcImFnLWRlZmF1bHRcIjogbGlnaHRUaGVtZSxcbiAgXCJhZy1zaGVldHNcIjogKCkgPT4gbmV3IFNoZWV0c0xpZ2h0KCksXG4gIFwiYWctcG9seWNocm9tYVwiOiAoKSA9PiBuZXcgUG9seWNocm9tYUxpZ2h0KCksXG4gIFwiYWctdml2aWRcIjogKCkgPT4gbmV3IFZpdmlkTGlnaHQoKSxcbiAgXCJhZy1tYXRlcmlhbFwiOiAoKSA9PiBuZXcgTWF0ZXJpYWxMaWdodCgpLFxuICBcImFnLWZpbmFuY2lhbFwiOiAoKSA9PiBuZXcgRmluYW5jaWFsTGlnaHQoKVxufTtcbmZ1bmN0aW9uIGdldENoYXJ0VGhlbWUodmFsdWUpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQ2hhcnRUaGVtZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICBjb25zdCBzdG9ja1RoZW1lID0gdGhlbWVzW3ZhbHVlXTtcbiAgICBpZiAoc3RvY2tUaGVtZSkge1xuICAgICAgcmV0dXJuIHN0b2NrVGhlbWUoKTtcbiAgICB9XG4gICAgTG9nZ2VyLndhcm5PbmNlKGB0aGUgdGhlbWUgWyR7dmFsdWV9XSBpcyBpbnZhbGlkLCB1c2luZyBbYWctZGVmYXVsdF0gaW5zdGVhZC5gKTtcbiAgICByZXR1cm4gbGlnaHRUaGVtZSgpO1xuICB9XG4gIGlmIChpc1ZhbGlkKHZhbHVlLCB0aGVtZU9wdGlvbnNEZWYsIFwidGhlbWVcIikpIHtcbiAgICBjb25zdCBmbGF0dGVuZWRUaGVtZSA9IHJlZHVjZVRoZW1lT3B0aW9ucyh2YWx1ZSk7XG4gICAgY29uc3QgYmFzZVRoZW1lID0gZmxhdHRlbmVkVGhlbWUuYmFzZVRoZW1lID8gZ2V0Q2hhcnRUaGVtZShmbGF0dGVuZWRUaGVtZS5iYXNlVGhlbWUpIDogbGlnaHRUaGVtZSgpO1xuICAgIHJldHVybiBuZXcgYmFzZVRoZW1lLmNvbnN0cnVjdG9yKGZsYXR0ZW5lZFRoZW1lKTtcbiAgfVxuICByZXR1cm4gbGlnaHRUaGVtZSgpO1xufVxuZnVuY3Rpb24gcmVkdWNlVGhlbWVPcHRpb25zKG9wdGlvbnMpIHtcbiAgbGV0IG1heWJlTmVzdGVkID0gb3B0aW9ucztcbiAgbGV0IHBhbGV0dGU7XG4gIGNvbnN0IG92ZXJyaWRlcyA9IFtdO1xuICB3aGlsZSAodHlwZW9mIG1heWJlTmVzdGVkID09PSBcIm9iamVjdFwiKSB7XG4gICAgcGFsZXR0ZSA/PyAocGFsZXR0ZSA9IG1heWJlTmVzdGVkLnBhbGV0dGUpO1xuICAgIGlmIChtYXliZU5lc3RlZC5vdmVycmlkZXMpIHtcbiAgICAgIG92ZXJyaWRlcy5wdXNoKG1heWJlTmVzdGVkLm92ZXJyaWRlcyk7XG4gICAgfVxuICAgIG1heWJlTmVzdGVkID0gbWF5YmVOZXN0ZWQuYmFzZVRoZW1lO1xuICB9XG4gIHJldHVybiB7XG4gICAgYmFzZVRoZW1lOiBtYXliZU5lc3RlZCxcbiAgICBvdmVycmlkZXM6IG1lcmdlRGVmYXVsdHMoLi4ub3ZlcnJpZGVzKSxcbiAgICBwYWxldHRlXG4gIH07XG59XG52YXIgdGhlbWVPcHRpb25zRGVmID0ge1xuICBiYXNlVGhlbWU6IG9yKHN0cmluZywgb2JqZWN0KSxcbiAgb3ZlcnJpZGVzOiBvYmplY3QsXG4gIHBhbGV0dGU6IHtcbiAgICBmaWxsczogYXJyYXlPZihzdHJpbmcpLFxuICAgIHN0cm9rZXM6IGFycmF5T2Yoc3RyaW5nKSxcbiAgICB1cDogeyBmaWxsOiBzdHJpbmcsIHN0cm9rZTogc3RyaW5nIH0sXG4gICAgZG93bjogeyBmaWxsOiBzdHJpbmcsIHN0cm9rZTogc3RyaW5nIH0sXG4gICAgbmV1dHJhbDogeyBmaWxsOiBzdHJpbmcsIHN0cm9rZTogc3RyaW5nIH1cbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvbW9kdWxlL29wdGlvbnNNb2R1bGUudHNcbnZhciB1bnRoZW1lZFNlcmllcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcIm1hcC1zaGFwZS1iYWNrZ3JvdW5kXCIsIFwibWFwLWxpbmUtYmFja2dyb3VuZFwiXSk7XG52YXIgQ2hhcnRPcHRpb25zID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih1c2VyT3B0aW9ucywgcHJvY2Vzc2VkT3ZlcnJpZGVzLCBzcGVjaWFsT3ZlcnJpZGVzLCBtZXRhZGF0YSkge1xuICAgIHRoaXMuZGVidWcgPSBEZWJ1Zy5jcmVhdGUodHJ1ZSwgXCJvcHRzXCIpO1xuICAgIHZhciBfYTtcbiAgICB0aGlzLm9wdGlvbk1ldGFkYXRhID0gbWV0YWRhdGEgPz8ge307XG4gICAgdGhpcy5wcm9jZXNzZWRPdmVycmlkZXMgPSBwcm9jZXNzZWRPdmVycmlkZXMgPz8ge307XG4gICAgY29uc3QgY2xvbmVPcHRpb25zID0geyBzaGFsbG93OiBbXCJkYXRhXCJdIH07XG4gICAgdGhpcy51c2VyT3B0aW9ucyA9IGRlZXBDbG9uZSh1c2VyT3B0aW9ucywgY2xvbmVPcHRpb25zKTtcbiAgICBsZXQgb3B0aW9ucyA9IGRlZXBDbG9uZSh1c2VyT3B0aW9ucywgY2xvbmVPcHRpb25zKTtcbiAgICBjb25zdCB7IHByZXNldFR5cGUgfSA9IHRoaXMub3B0aW9uTWV0YWRhdGE7XG4gICAgaWYgKHByZXNldFR5cGUgIT0gbnVsbCkge1xuICAgICAgY29uc3QgcHJlc2V0Q29uc3RydWN0b3IgPSBQUkVTRVRTW3ByZXNldFR5cGVdO1xuICAgICAgY29uc3QgcHJlc2V0UGFyYW1zID0gb3B0aW9ucztcbiAgICAgIGNvbnN0IHByZXNldFN1YlR5cGUgPSBvcHRpb25zLnR5cGU7XG4gICAgICBjb25zdCBwcmVzZXRUaGVtZSA9IHByZXNldFN1YlR5cGUgIT0gbnVsbCA/IGdldENoYXJ0VGhlbWUob3B0aW9ucy50aGVtZSkucHJlc2V0c1twcmVzZXRTdWJUeXBlXSA6IHZvaWQgMDtcbiAgICAgIHRoaXMuZGVidWcoXCI+Pj4gQWdDaGFydHMuY3JlYXRlT3JVcGRhdGUoKSAtIGFwcGx5aW5nIHByZXNldFwiLCBwcmVzZXRQYXJhbXMpO1xuICAgICAgb3B0aW9ucyA9IHByZXNldENvbnN0cnVjdG9yPy4ocHJlc2V0UGFyYW1zLCBwcmVzZXRUaGVtZSwgKCkgPT4gdGhpcy5hY3RpdmVUaGVtZSkgPz8gb3B0aW9ucztcbiAgICB9XG4gICAgaWYgKCFlbnRlcnByaXNlTW9kdWxlLmlzRW50ZXJwcmlzZSkge1xuICAgICAgcmVtb3ZlVXNlZEVudGVycHJpc2VPcHRpb25zKG9wdGlvbnMpO1xuICAgIH1cbiAgICB0aGlzLmFjdGl2ZVRoZW1lID0gZ2V0Q2hhcnRUaGVtZShvcHRpb25zLnRoZW1lKTtcbiAgICBpZiAocHJlc2V0VHlwZSkge1xuICAgICAgb3B0aW9ucyA9IHRoaXMuYWN0aXZlVGhlbWUudGVtcGxhdGVUaGVtZShvcHRpb25zKTtcbiAgICB9XG4gICAgdGhpcy5zYW5pdHlDaGVja0FuZENsZWFudXAob3B0aW9ucyk7XG4gICAgdGhpcy5kZWZhdWx0QXhlcyA9IHRoaXMuZ2V0RGVmYXVsdEF4ZXMob3B0aW9ucyk7XG4gICAgdGhpcy5zcGVjaWFsT3ZlcnJpZGVzID0gdGhpcy5zcGVjaWFsT3ZlcnJpZGVzRGVmYXVsdHMoeyAuLi5zcGVjaWFsT3ZlcnJpZGVzIH0pO1xuICAgIGNvbnN0IGNoYXJ0VHlwZTIgPSB0aGlzLm9wdGlvbnNUeXBlKG9wdGlvbnMpO1xuICAgIGNvbnN0IHtcbiAgICAgIGF4ZXM6IGF4ZXNUaGVtZXMgPSB7fSxcbiAgICAgIGFubm90YXRpb25zOiB7IGF4ZXNCdXR0b25zID0gbnVsbCwgLi4uYW5ub3RhdGlvbnNUaGVtZXMgfSA9IHt9LFxuICAgICAgc2VyaWVzOiBfLFxuICAgICAgLi4udGhlbWVEZWZhdWx0c1xuICAgIH0gPSB0aGlzLmdldFNlcmllc1RoZW1lQ29uZmlnKGNoYXJ0VHlwZTIpO1xuICAgIHRoaXMucHJvY2Vzc2VkT3B0aW9ucyA9IGRlZXBDbG9uZShcbiAgICAgIG1lcmdlRGVmYXVsdHMoXG4gICAgICAgIHByb2Nlc3NlZE92ZXJyaWRlcyxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgYXhlc0J1dHRvbnMgIT0gbnVsbCA/IHsgYW5ub3RhdGlvbnM6IHsgYXhlc0J1dHRvbnMgfSB9IDoge30sXG4gICAgICAgIHRoZW1lRGVmYXVsdHMsXG4gICAgICAgIHRoaXMuZGVmYXVsdEF4ZXNcbiAgICAgICksXG4gICAgICBjbG9uZU9wdGlvbnNcbiAgICApO1xuICAgIHRoaXMucHJvY2Vzc0F4ZXNPcHRpb25zKHRoaXMucHJvY2Vzc2VkT3B0aW9ucywgYXhlc1RoZW1lcyk7XG4gICAgdGhpcy5wcm9jZXNzU2VyaWVzT3B0aW9ucyh0aGlzLnByb2Nlc3NlZE9wdGlvbnMpO1xuICAgIHRoaXMucHJvY2Vzc01pbmlDaGFydFNlcmllc09wdGlvbnModGhpcy5wcm9jZXNzZWRPcHRpb25zKTtcbiAgICB0aGlzLmFubm90YXRpb25UaGVtZXMgPSBhbm5vdGF0aW9uc1RoZW1lcztcbiAgICBpZiAoKGlzQWdDYXJ0ZXNpYW5DaGFydE9wdGlvbnModGhpcy5wcm9jZXNzZWRPcHRpb25zKSB8fCBpc0FnUG9sYXJDaGFydE9wdGlvbnNXaXRoU2VyaWVzQmFzZWRMZWdlbmQodGhpcy5wcm9jZXNzZWRPcHRpb25zKSkgJiYgdGhpcy5wcm9jZXNzZWRPcHRpb25zLmxlZ2VuZD8uZW5hYmxlZCA9PSBudWxsKSB7XG4gICAgICAoX2EgPSB0aGlzLnByb2Nlc3NlZE9wdGlvbnMpLmxlZ2VuZCA/PyAoX2EubGVnZW5kID0ge30pO1xuICAgICAgdGhpcy5wcm9jZXNzZWRPcHRpb25zLmxlZ2VuZC5lbmFibGVkID0gdGhpcy5wcm9jZXNzZWRPcHRpb25zLnNlcmllcy5sZW5ndGggPiAxO1xuICAgIH1cbiAgICB0aGlzLmVuYWJsZUNvbmZpZ3VyZWRPcHRpb25zKHRoaXMucHJvY2Vzc2VkT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgaWYgKCFlbnRlcnByaXNlTW9kdWxlLmlzRW50ZXJwcmlzZSkge1xuICAgICAgcmVtb3ZlVXNlZEVudGVycHJpc2VPcHRpb25zKHRoaXMucHJvY2Vzc2VkT3B0aW9ucywgdHJ1ZSk7XG4gICAgfVxuICB9XG4gIGdldE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvY2Vzc2VkT3B0aW9ucyA/PyB7fTtcbiAgfVxuICBkaWZmT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIGpzb25EaWZmKG9wdGlvbnMsIHRoaXMucHJvY2Vzc2VkT3B0aW9ucyk7XG4gIH1cbiAgZ2V0U2VyaWVzVGhlbWVDb25maWcoc2VyaWVzVHlwZTIpIHtcbiAgICBjb25zdCB0aGVtZUNvbmZpZyA9IGRlZXBDbG9uZSh0aGlzLmFjdGl2ZVRoZW1lPy5jb25maWdbc2VyaWVzVHlwZTJdID8/IHt9KTtcbiAgICB0aGlzLnJlbW92ZUxlZnRvdmVyU3ltYm9scyh0aGVtZUNvbmZpZyk7XG4gICAgcmV0dXJuIHRoZW1lQ29uZmlnO1xuICB9XG4gIGdldERlZmF1bHRBeGVzKG9wdGlvbnMpIHtcbiAgICBjb25zdCBvcHRpb25zVHlwZTIgPSB0aGlzLm9wdGlvbnNUeXBlKG9wdGlvbnMpO1xuICAgIGNvbnN0IGZpcnN0U2VyaWVzT3B0aW9ucyA9IG9wdGlvbnMuc2VyaWVzPy5maW5kKChzZXJpZXMpID0+IChzZXJpZXMudHlwZSA/PyBcImxpbmVcIikgPT09IG9wdGlvbnNUeXBlMikgPz8ge307XG4gICAgcmV0dXJuIHNlcmllc1JlZ2lzdHJ5LmNsb25lRGVmYXVsdEF4ZXMob3B0aW9uc1R5cGUyLCBmaXJzdFNlcmllc09wdGlvbnMpO1xuICB9XG4gIG9wdGlvbnNUeXBlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5zZXJpZXM/LlswXT8udHlwZSA/PyBcImxpbmVcIjtcbiAgfVxuICBzYW5pdHlDaGVja0FuZENsZWFudXAob3B0aW9ucykge1xuICAgIHRoaXMuZGVwcmVjYXRpb25XYXJuaW5ncyhvcHRpb25zKTtcbiAgICB0aGlzLmF4ZXNUeXBlSW50ZWdyaXR5KG9wdGlvbnMpO1xuICAgIHRoaXMuc2VyaWVzVHlwZUludGVncml0eShvcHRpb25zKTtcbiAgICB0aGlzLnNvbG9TZXJpZXNJbnRlZ3JpdHkob3B0aW9ucyk7XG4gICAgdGhpcy5yZW1vdmVEaXNhYmxlZE9wdGlvbnMob3B0aW9ucyk7XG4gICAgdGhpcy5yZW1vdmVMZWZ0b3ZlclN5bWJvbHMob3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuc2VyaWVzPy5zb21lKChzKSA9PiBzLnR5cGUgPT09IFwiYnVsbGV0XCIpICYmIG9wdGlvbnMuc3luYyAhPSBudWxsICYmIG9wdGlvbnMuc3luYy5lbmFibGVkICE9PSBmYWxzZSkge1xuICAgICAgTG9nZ2VyLndhcm5PbmNlKFwiYnVsbGV0IHNlcmllcyBjYW5ub3QgYmUgc3luY2VkLCBkaXNhYmxpbmcgc3luY2hyb25pemF0aW9uLlwiKTtcbiAgICAgIGRlbGV0ZSBvcHRpb25zLnN5bmM7XG4gICAgfVxuICB9XG4gIHByb2Nlc3NBeGVzT3B0aW9ucyhvcHRpb25zLCBheGVzVGhlbWVzKSB7XG4gICAgaWYgKCEoXCJheGVzXCIgaW4gb3B0aW9ucykpXG4gICAgICByZXR1cm47XG4gICAgb3B0aW9ucy5heGVzID0gb3B0aW9ucy5heGVzLm1hcCgoYXhpcykgPT4ge1xuICAgICAgY29uc3QgeyBjcm9zc0xpbmVzOiBjcm9zc0xpbmVzVGhlbWUsIC4uLmF4aXNUaGVtZSB9ID0gbWVyZ2VEZWZhdWx0cyhcbiAgICAgICAgYXhlc1RoZW1lc1theGlzLnR5cGVdPy5bYXhpcy5wb3NpdGlvbl0sXG4gICAgICAgIGF4ZXNUaGVtZXNbYXhpcy50eXBlXVxuICAgICAgKTtcbiAgICAgIGlmIChheGlzLmNyb3NzTGluZXMpIHtcbiAgICAgICAgYXhpcy5jcm9zc0xpbmVzID0gbWVyZ2VBcnJheURlZmF1bHRzKGF4aXMuY3Jvc3NMaW5lcywgY3Jvc3NMaW5lc1RoZW1lKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGdyaWRMaW5lU3R5bGUgPSBheGlzVGhlbWUuZ3JpZExpbmU/LnN0eWxlO1xuICAgICAgaWYgKGF4aXMuZ3JpZExpbmU/LnN0eWxlICYmIGdyaWRMaW5lU3R5bGU/Lmxlbmd0aCkge1xuICAgICAgICBheGlzLmdyaWRMaW5lLnN0eWxlID0gYXhpcy5ncmlkTGluZS5zdHlsZS5tYXAoXG4gICAgICAgICAgKHN0eWxlLCBpbmRleCkgPT4gc3R5bGUuc3Ryb2tlICE9IG51bGwgfHwgc3R5bGUubGluZURhc2ggIT0gbnVsbCA/IG1lcmdlRGVmYXVsdHMoc3R5bGUsIGdyaWRMaW5lU3R5bGUuYXQoaW5kZXggJSBncmlkTGluZVN0eWxlLmxlbmd0aCkpIDogc3R5bGVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgdG9wOiBfMSwgcmlnaHQ6IF8yLCBib3R0b206IF8zLCBsZWZ0OiBfNCwgLi4uYXhpc09wdGlvbnMgfSA9IG1lcmdlRGVmYXVsdHMoYXhpcywgYXhpc1RoZW1lKTtcbiAgICAgIHJldHVybiBheGlzT3B0aW9ucztcbiAgICB9KTtcbiAgfVxuICBwcm9jZXNzU2VyaWVzT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgY29uc3QgZGVmYXVsdFRvb2x0aXBQb3NpdGlvbiA9IHRoaXMuZ2V0VG9vbHRpcFBvc2l0aW9uRGVmYXVsdHMob3B0aW9ucyk7XG4gICAgY29uc3QgdXNlclBhbGV0dGUgPSBpc09iamVjdChvcHRpb25zLnRoZW1lKSA/IHBhbGV0dGVUeXBlKG9wdGlvbnMudGhlbWU/LnBhbGV0dGUpIDogXCJpbmJ1aWx0XCI7XG4gICAgY29uc3QgcGFsZXR0ZU9wdGlvbnMgPSB7XG4gICAgICBjb2xvdXJJbmRleDogMCxcbiAgICAgIHVzZXJQYWxldHRlXG4gICAgfTtcbiAgICBjb25zdCBwcm9jZXNzZWRTZXJpZXMgPSBvcHRpb25zLnNlcmllcz8ubWFwKChzZXJpZXMpID0+IHtcbiAgICAgIHNlcmllcy50eXBlID8/IChzZXJpZXMudHlwZSA9IHRoaXMuZ2V0RGVmYXVsdFNlcmllc1R5cGUob3B0aW9ucykpO1xuICAgICAgY29uc3QgeyBpbm5lckxhYmVsczogaW5uZXJMYWJlbHNUaGVtZSwgLi4uc2VyaWVzVGhlbWUgfSA9IHRoaXMuZ2V0U2VyaWVzVGhlbWVDb25maWcoc2VyaWVzLnR5cGUpLnNlcmllcyA/PyB7fTtcbiAgICAgIGNvbnN0IHNlcmllc1BhbGV0dGVPcHRpb25zID0gdW50aGVtZWRTZXJpZXMuaGFzKHNlcmllcy50eXBlKSA/IHsgY29sb3VySW5kZXg6IDAsIHVzZXJQYWxldHRlIH0gOiBwYWxldHRlT3B0aW9ucztcbiAgICAgIGNvbnN0IHBhbGV0dGUgPSB0aGlzLmdldFNlcmllc1BhbGV0dGUoc2VyaWVzLnR5cGUsIHNlcmllc1BhbGV0dGVPcHRpb25zKTtcbiAgICAgIGNvbnN0IGRlZmF1bHRUb29sdGlwUmFuZ2UgPSB0aGlzLmdldFRvb2x0aXBSYW5nZURlZmF1bHRzKG9wdGlvbnMsIHNlcmllcy50eXBlKTtcbiAgICAgIGNvbnN0IHNlcmllc09wdGlvbnMgPSBtZXJnZURlZmF1bHRzKFxuICAgICAgICB0aGlzLmdldFNlcmllc0dyb3VwaW5nT3B0aW9ucyhzZXJpZXMpLFxuICAgICAgICBzZXJpZXMsXG4gICAgICAgIGRlZmF1bHRUb29sdGlwUG9zaXRpb24sXG4gICAgICAgIGRlZmF1bHRUb29sdGlwUmFuZ2UsXG4gICAgICAgIHNlcmllc1RoZW1lLFxuICAgICAgICBwYWxldHRlLFxuICAgICAgICB7IHZpc2libGU6IHRydWUgfVxuICAgICAgKTtcbiAgICAgIGlmIChzZXJpZXNPcHRpb25zLmlubmVyTGFiZWxzKSB7XG4gICAgICAgIHNlcmllc09wdGlvbnMuaW5uZXJMYWJlbHMgPSBtZXJnZUFycmF5RGVmYXVsdHMoc2VyaWVzT3B0aW9ucy5pbm5lckxhYmVscywgaW5uZXJMYWJlbHNUaGVtZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5hY3RpdmVUaGVtZS50ZW1wbGF0ZVRoZW1lKHNlcmllc09wdGlvbnMpO1xuICAgIH0pO1xuICAgIG9wdGlvbnMuc2VyaWVzID0gdGhpcy5zZXRTZXJpZXNHcm91cGluZ09wdGlvbnMocHJvY2Vzc2VkU2VyaWVzID8/IFtdKTtcbiAgfVxuICBwcm9jZXNzTWluaUNoYXJ0U2VyaWVzT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgbGV0IG1pbmlDaGFydFNlcmllcyA9IG9wdGlvbnMubmF2aWdhdG9yPy5taW5pQ2hhcnQ/LnNlcmllcztcbiAgICBpZiAobWluaUNoYXJ0U2VyaWVzID09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgcGFsZXR0ZU9wdGlvbnMgPSB7XG4gICAgICBjb2xvdXJJbmRleDogMCxcbiAgICAgIHVzZXJQYWxldHRlOiBpc09iamVjdChvcHRpb25zLnRoZW1lKSA/IHBhbGV0dGVUeXBlKG9wdGlvbnMudGhlbWUucGFsZXR0ZSkgOiBcImluYnVpbHRcIlxuICAgIH07XG4gICAgbWluaUNoYXJ0U2VyaWVzID0gbWluaUNoYXJ0U2VyaWVzLm1hcCgoc2VyaWVzKSA9PiB7XG4gICAgICBzZXJpZXMudHlwZSA/PyAoc2VyaWVzLnR5cGUgPSBcImxpbmVcIik7XG4gICAgICBjb25zdCB7IGlubmVyTGFiZWxzOiBfLCAuLi5zZXJpZXNUaGVtZSB9ID0gdGhpcy5nZXRTZXJpZXNUaGVtZUNvbmZpZyhzZXJpZXMudHlwZSkuc2VyaWVzID8/IHt9O1xuICAgICAgY29uc3Qgc2VyaWVzT3B0aW9ucyA9IG1lcmdlRGVmYXVsdHMoXG4gICAgICAgIHRoaXMuZ2V0U2VyaWVzR3JvdXBpbmdPcHRpb25zKHNlcmllcyksXG4gICAgICAgIHNlcmllcyxcbiAgICAgICAgc2VyaWVzVGhlbWUsXG4gICAgICAgIHRoaXMuZ2V0U2VyaWVzUGFsZXR0ZShzZXJpZXMudHlwZSwgcGFsZXR0ZU9wdGlvbnMpXG4gICAgICApO1xuICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlVGhlbWUudGVtcGxhdGVUaGVtZShzZXJpZXNPcHRpb25zKTtcbiAgICB9KTtcbiAgICBvcHRpb25zLm5hdmlnYXRvci5taW5pQ2hhcnQuc2VyaWVzID0gdGhpcy5zZXRTZXJpZXNHcm91cGluZ09wdGlvbnMobWluaUNoYXJ0U2VyaWVzKTtcbiAgfVxuICBnZXRTZXJpZXNQYWxldHRlKHNlcmllc1R5cGUyLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcGFsZXR0ZUZhY3RvcnkgPSBzZXJpZXNSZWdpc3RyeS5nZXRQYWxldHRlRmFjdG9yeShzZXJpZXNUeXBlMik7XG4gICAgY29uc3QgeyBjb2xvdXJJbmRleDogY29sb3VyT2Zmc2V0LCB1c2VyUGFsZXR0ZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCB7IGZpbGxzID0gW10sIHN0cm9rZXMgPSBbXSB9ID0gdGhpcy5hY3RpdmVUaGVtZS5wYWxldHRlO1xuICAgIHJldHVybiBwYWxldHRlRmFjdG9yeT8uKHtcbiAgICAgIHVzZXJQYWxldHRlLFxuICAgICAgY29sb3JzQ291bnQ6IE1hdGgubWF4KGZpbGxzLmxlbmd0aCwgc3Ryb2tlcy5sZW5ndGgpLFxuICAgICAgdGhlbWVUZW1wbGF0ZVBhcmFtZXRlcnM6IHRoaXMuYWN0aXZlVGhlbWUuZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKCksXG4gICAgICBwYWxldHRlOiB0aGlzLmFjdGl2ZVRoZW1lLnBhbGV0dGUsXG4gICAgICB0YWtlQ29sb3JzKGNvdW50KSB7XG4gICAgICAgIG9wdGlvbnMuY29sb3VySW5kZXggKz0gY291bnQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZmlsbHM6IGNpcmN1bGFyU2xpY2VBcnJheShmaWxscywgY291bnQsIGNvbG91ck9mZnNldCksXG4gICAgICAgICAgc3Ryb2tlczogY2lyY3VsYXJTbGljZUFycmF5KHN0cm9rZXMsIGNvdW50LCBjb2xvdXJPZmZzZXQpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZ2V0U2VyaWVzR3JvdXBpbmdPcHRpb25zKHNlcmllcykge1xuICAgIGNvbnN0IGdyb3VwYWJsZSA9IHNlcmllc1JlZ2lzdHJ5LmlzR3JvdXBhYmxlKHNlcmllcy50eXBlKTtcbiAgICBjb25zdCBzdGFja2FibGUgPSBzZXJpZXNSZWdpc3RyeS5pc1N0YWNrYWJsZShzZXJpZXMudHlwZSk7XG4gICAgY29uc3Qgc3RhY2tlZEJ5RGVmYXVsdCA9IHNlcmllc1JlZ2lzdHJ5LmlzU3RhY2tlZEJ5RGVmYXVsdChzZXJpZXMudHlwZSk7XG4gICAgaWYgKHNlcmllcy5ncm91cGVkICYmICFncm91cGFibGUpIHtcbiAgICAgIExvZ2dlci53YXJuT25jZShgdW5zdXBwb3J0ZWQgZ3JvdXBpbmcgb2Ygc2VyaWVzIHR5cGUgXCIke3Nlcmllcy50eXBlfVwiLmApO1xuICAgIH1cbiAgICBpZiAoKHNlcmllcy5zdGFja2VkIHx8IHNlcmllcy5zdGFja0dyb3VwKSAmJiAhc3RhY2thYmxlKSB7XG4gICAgICBMb2dnZXIud2Fybk9uY2UoYHVuc3VwcG9ydGVkIHN0YWNraW5nIG9mIHNlcmllcyB0eXBlIFwiJHtzZXJpZXMudHlwZX1cIi5gKTtcbiAgICB9XG4gICAgbGV0IHsgZ3JvdXBlZCwgc3RhY2tlZCB9ID0gc2VyaWVzO1xuICAgIHN0YWNrZWQgPz8gKHN0YWNrZWQgPSAoc3RhY2tlZEJ5RGVmYXVsdCB8fCBzZXJpZXMuc3RhY2tHcm91cCAhPSBudWxsKSAmJiAhKGdyb3VwYWJsZSAmJiBncm91cGVkKSk7XG4gICAgZ3JvdXBlZCA/PyAoZ3JvdXBlZCA9IHRydWUpO1xuICAgIHJldHVybiB7XG4gICAgICBzdGFja2VkOiBzdGFja2FibGUgJiYgc3RhY2tlZCxcbiAgICAgIGdyb3VwZWQ6IGdyb3VwYWJsZSAmJiBncm91cGVkICYmICEoc3RhY2thYmxlICYmIHN0YWNrZWQpXG4gICAgfTtcbiAgfVxuICBzZXRTZXJpZXNHcm91cGluZ09wdGlvbnMoYWxsU2VyaWVzKSB7XG4gICAgY29uc3Qgc2VyaWVzR3JvdXBzID0gdGhpcy5nZXRTZXJpZXNHcm91cGluZyhhbGxTZXJpZXMpO1xuICAgIHRoaXMuZGVidWcoXCJzZXRTZXJpZXNHcm91cGluZ09wdGlvbnMoKSAtIHNlcmllcyBncm91cGluZzogXCIsIHNlcmllc0dyb3Vwcyk7XG4gICAgY29uc3QgZ3JvdXBJZHggPSB7fTtcbiAgICBjb25zdCBncm91cENvdW50MiA9IHNlcmllc0dyb3Vwcy5yZWR1Y2UoKGNvdW50TWFwLCBzZXJpZXNHcm91cCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKHNlcmllc0dyb3VwLmdyb3VwVHlwZSA9PT0gXCJkZWZhdWx0XCIgLyogREVGQVVMVCAqLykge1xuICAgICAgICByZXR1cm4gY291bnRNYXA7XG4gICAgICB9XG4gICAgICBjb3VudE1hcFtfYSA9IHNlcmllc0dyb3VwLnNlcmllc1R5cGVdID8/IChjb3VudE1hcFtfYV0gPSAwKTtcbiAgICAgIGNvdW50TWFwW3Nlcmllc0dyb3VwLnNlcmllc1R5cGVdICs9IHNlcmllc0dyb3VwLmdyb3VwVHlwZSA9PT0gXCJzdGFja1wiIC8qIFNUQUNLICovID8gMSA6IHNlcmllc0dyb3VwLnNlcmllcy5sZW5ndGg7XG4gICAgICByZXR1cm4gY291bnRNYXA7XG4gICAgfSwge30pO1xuICAgIHJldHVybiBzZXJpZXNHcm91cHMuZmxhdE1hcCgoc2VyaWVzR3JvdXApID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGdyb3VwSWR4W19hID0gc2VyaWVzR3JvdXAuc2VyaWVzVHlwZV0gPz8gKGdyb3VwSWR4W19hXSA9IDApO1xuICAgICAgc3dpdGNoIChzZXJpZXNHcm91cC5ncm91cFR5cGUpIHtcbiAgICAgICAgY2FzZSBcInN0YWNrXCIgLyogU1RBQ0sgKi86IHtcbiAgICAgICAgICBjb25zdCBncm91cEluZGV4ID0gZ3JvdXBJZHhbc2VyaWVzR3JvdXAuc2VyaWVzVHlwZV0rKztcbiAgICAgICAgICByZXR1cm4gc2VyaWVzR3JvdXAuc2VyaWVzLm1hcChcbiAgICAgICAgICAgIChzZXJpZXMsIHN0YWNrSW5kZXgpID0+IE9iamVjdC5hc3NpZ24oc2VyaWVzLCB7XG4gICAgICAgICAgICAgIHNlcmllc0dyb3VwaW5nOiB7XG4gICAgICAgICAgICAgICAgZ3JvdXBJZDogc2VyaWVzR3JvdXAuZ3JvdXBJZCxcbiAgICAgICAgICAgICAgICBncm91cEluZGV4LFxuICAgICAgICAgICAgICAgIGdyb3VwQ291bnQ6IGdyb3VwQ291bnQyW3Nlcmllc0dyb3VwLnNlcmllc1R5cGVdLFxuICAgICAgICAgICAgICAgIHN0YWNrSW5kZXgsXG4gICAgICAgICAgICAgICAgc3RhY2tDb3VudDogc2VyaWVzR3JvdXAuc2VyaWVzLmxlbmd0aFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImdyb3VwXCIgLyogR1JPVVAgKi86XG4gICAgICAgICAgcmV0dXJuIHNlcmllc0dyb3VwLnNlcmllcy5tYXAoXG4gICAgICAgICAgICAoc2VyaWVzKSA9PiBPYmplY3QuYXNzaWduKHNlcmllcywge1xuICAgICAgICAgICAgICBzZXJpZXNHcm91cGluZzoge1xuICAgICAgICAgICAgICAgIGdyb3VwSWQ6IHNlcmllc0dyb3VwLmdyb3VwSWQsXG4gICAgICAgICAgICAgICAgZ3JvdXBJbmRleDogZ3JvdXBJZHhbc2VyaWVzR3JvdXAuc2VyaWVzVHlwZV0rKyxcbiAgICAgICAgICAgICAgICBncm91cENvdW50OiBncm91cENvdW50MltzZXJpZXNHcm91cC5zZXJpZXNUeXBlXSxcbiAgICAgICAgICAgICAgICBzdGFja0luZGV4OiAwLFxuICAgICAgICAgICAgICAgIHN0YWNrQ291bnQ6IDBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlcmllc0dyb3VwLnNlcmllcztcbiAgICB9KS5tYXAoKHsgc3RhY2tlZDogXywgZ3JvdXBlZDogX18sIC4uLnNlcmllc09wdGlvbnMgfSkgPT4gc2VyaWVzT3B0aW9ucyk7XG4gIH1cbiAgZ2V0U2VyaWVzR3JvdXBJZChzZXJpZXMpIHtcbiAgICByZXR1cm4gW3Nlcmllcy50eXBlLCBzZXJpZXMueEtleSwgc2VyaWVzLnN0YWNrZWQgPyBzZXJpZXMuc3RhY2tHcm91cCA/PyBcInN0YWNrZWRcIiA6IFwiZ3JvdXBlZFwiXS5maWx0ZXIoQm9vbGVhbikuam9pbihcIi1cIik7XG4gIH1cbiAgZ2V0U2VyaWVzR3JvdXBpbmcoYWxsU2VyaWVzKSB7XG4gICAgY29uc3QgZ3JvdXBNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHJldHVybiBhbGxTZXJpZXMucmVkdWNlKChyZXN1bHQsIHNlcmllcykgPT4ge1xuICAgICAgY29uc3Qgc2VyaWVzVHlwZTIgPSBzZXJpZXMudHlwZTtcbiAgICAgIGlmICghc2VyaWVzLnN0YWNrZWQgJiYgIXNlcmllcy5ncm91cGVkKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHsgZ3JvdXBUeXBlOiBcImRlZmF1bHRcIiAvKiBERUZBVUxUICovLCBzZXJpZXNUeXBlOiBzZXJpZXNUeXBlMiwgc2VyaWVzOiBbc2VyaWVzXSwgZ3JvdXBJZDogXCJfX2RlZmF1bHRfX1wiIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZ3JvdXBJZCA9IHRoaXMuZ2V0U2VyaWVzR3JvdXBJZChzZXJpZXMpO1xuICAgICAgICBpZiAoIWdyb3VwTWFwLmhhcyhncm91cElkKSkge1xuICAgICAgICAgIGNvbnN0IGdyb3VwVHlwZSA9IHNlcmllcy5zdGFja2VkID8gXCJzdGFja1wiIC8qIFNUQUNLICovIDogXCJncm91cFwiIC8qIEdST1VQICovO1xuICAgICAgICAgIGNvbnN0IHJlY29yZCA9IHsgZ3JvdXBUeXBlLCBzZXJpZXNUeXBlOiBzZXJpZXNUeXBlMiwgc2VyaWVzOiBbXSwgZ3JvdXBJZCB9O1xuICAgICAgICAgIGdyb3VwTWFwLnNldChncm91cElkLCByZWNvcmQpO1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHJlY29yZCk7XG4gICAgICAgIH1cbiAgICAgICAgZ3JvdXBNYXAuZ2V0KGdyb3VwSWQpLnNlcmllcy5wdXNoKHNlcmllcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIFtdKTtcbiAgfVxuICBnZXREZWZhdWx0U2VyaWVzVHlwZShvcHRpb25zKSB7XG4gICAgaWYgKGlzQWdDYXJ0ZXNpYW5DaGFydE9wdGlvbnMob3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBcImxpbmVcIjtcbiAgICB9IGVsc2UgaWYgKGlzQWdQb2xhckNoYXJ0T3B0aW9ucyhvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIFwicGllXCI7XG4gICAgfSBlbHNlIGlmIChpc0FnSGllcmFyY2h5Q2hhcnRPcHRpb25zKG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gXCJ0cmVlbWFwXCI7XG4gICAgfSBlbHNlIGlmIChpc0FnVG9wb2xvZ3lDaGFydE9wdGlvbnMob3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBcIm1hcC1zaGFwZVwiO1xuICAgIH0gZWxzZSBpZiAoaXNBZ0Zsb3dQcm9wb3J0aW9uQ2hhcnRPcHRpb25zKG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gXCJzYW5rZXlcIjtcbiAgICB9IGVsc2UgaWYgKGlzQWdTdGFuZGFsb25lQ2hhcnRPcHRpb25zKG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gXCJweXJhbWlkXCI7XG4gICAgfSBlbHNlIGlmIChpc0FnR2F1Z2VDaGFydE9wdGlvbnMob3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBcInJhZGlhbC1nYXVnZVwiO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNoYXJ0IG9wdGlvbnMgdHlwZSBkZXRlY3RlZC5cIik7XG4gIH1cbiAgZ2V0VG9vbHRpcFBvc2l0aW9uRGVmYXVsdHMob3B0aW9ucykge1xuICAgIGNvbnN0IHBvc2l0aW9uID0gb3B0aW9ucy50b29sdGlwPy5wb3NpdGlvbjtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QocG9zaXRpb24pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgdHlwZSwgeE9mZnNldCwgeU9mZnNldCB9ID0gcG9zaXRpb247XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgaWYgKGlzU3RyaW5nKHR5cGUpICYmIGlzRW51bVZhbHVlKEFnVG9vbHRpcFBvc2l0aW9uVHlwZSwgdHlwZSkpIHtcbiAgICAgIHJlc3VsdC50eXBlID0gdHlwZTtcbiAgICB9XG4gICAgaWYgKGlzRmluaXRlTnVtYmVyKHhPZmZzZXQpKSB7XG4gICAgICByZXN1bHQueE9mZnNldCA9IHhPZmZzZXQ7XG4gICAgfVxuICAgIGlmIChpc0Zpbml0ZU51bWJlcih5T2Zmc2V0KSkge1xuICAgICAgcmVzdWx0LnlPZmZzZXQgPSB5T2Zmc2V0O1xuICAgIH1cbiAgICByZXR1cm4geyB0b29sdGlwOiB7IHBvc2l0aW9uOiByZXN1bHQgfSB9O1xuICB9XG4gIC8vIEFHLTExNTkxIFN1cHBvcnQgZm9yIG5ldyBzZXJpZXMtc3BlY2lmaWMgJiBsZWdhY3kgY2hhcnQtZ2xvYmFsICd0b29sdGlwLnJhbmdlJyBvcHRpb25zXG4gIC8vXG4gIC8vIFRoZSBgY2hhcnQuc2VyaWVzW10udG9vbHRpcC5yYW5nZWAgb3B0aW9uIGlzIGEgYml0IGRpZmZlcmVudCBmb3IgbGVnYWN5IHJlYXNvbi4gVGhpcyB1c2UgdG8gYmVcbiAgLy8gZ2xvYmFsIG9wdGlvbiAoYGNoYXJ0LnRvb2x0aXAucmFuZ2VgKSB0aGF0IGNvdWxkIG92ZXJyaWRlIHRoZSB0aGVtZS4gQnV0IG5vdywgdGhlIHRvb2x0aXAgcmFuZ2VcbiAgLy8gb3B0aW9uIGlzIHNlcmllcy1zcGVjaWZpYy5cbiAgLy9cbiAgLy8gVG8gcHJlc2VydmUgYmFja3dhcmQgY29tcGF0aWJsaXR5LCB0aGUgYGNoYXJ0LnRvb2x0aXAucmFuZ2VgIHRoZW1lIGRlZmF1bHQgaGFzIGJlZW4gY2hhbmdlZCBmcm9tXG4gIC8vICduZWFyZXN0JyB0byB1bmRlZmluZWQuXG4gIGdldFRvb2x0aXBSYW5nZURlZmF1bHRzKG9wdGlvbnMsIHNlcmllc1R5cGUyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgcmFuZ2U6IG9wdGlvbnMudG9vbHRpcD8ucmFuZ2UgPz8gc2VyaWVzUmVnaXN0cnkuZ2V0VG9vbHRpcERlZmF1bHMoc2VyaWVzVHlwZTIpPy5yYW5nZVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZGVwcmVjYXRpb25XYXJuaW5ncyhvcHRpb25zKSB7XG4gICAgY29uc3QgZGVwcmVjYXRlZEFycmF5UHJvcHMgPSB7IHlLZXlzOiBcInlLZXlcIiwgeU5hbWVzOiBcInlOYW1lXCIgfTtcbiAgICBPYmplY3QuZW50cmllcyhkZXByZWNhdGVkQXJyYXlQcm9wcykuZm9yRWFjaCgoW29sZFByb3AsIG5ld1Byb3BdKSA9PiB7XG4gICAgICBpZiAob3B0aW9ucy5zZXJpZXM/LnNvbWUoKHMpID0+IHNbb2xkUHJvcF0gIT0gbnVsbCkpIHtcbiAgICAgICAgTG9nZ2VyLndhcm5PbmNlKFxuICAgICAgICAgIGBQcm9wZXJ0eSBbc2VyaWVzLiR7b2xkUHJvcH1dIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgW3Nlcmllcy4ke25ld1Byb3B9XSBhbmQgbXVsdGlwbGUgc2VyaWVzIGluc3RlYWQuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGF4ZXNUeXBlSW50ZWdyaXR5KG9wdGlvbnMpIHtcbiAgICBpZiAoXCJheGVzXCIgaW4gb3B0aW9ucykge1xuICAgICAgY29uc3QgYXhlcyA9IG9wdGlvbnMuYXhlcyA/PyBbXTtcbiAgICAgIGZvciAoY29uc3QgeyB0eXBlIH0gb2YgYXhlcykge1xuICAgICAgICBpZiAoIWlzQXhpc09wdGlvblR5cGUodHlwZSkpIHtcbiAgICAgICAgICBkZWxldGUgb3B0aW9ucy5heGVzO1xuICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVHlwZXMgPSBheGlzUmVnaXN0cnkucHVibGljS2V5cygpLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgICBMb2dnZXIud2Fybk9uY2UoYHVua25vd24gYXhpcyB0eXBlOiAke3R5cGV9OyBleHBlY3RlZCBvbmUgb2Y6ICR7ZXhwZWN0ZWRUeXBlc31gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBzZXJpZXNUeXBlSW50ZWdyaXR5KG9wdGlvbnMpIHtcbiAgICBvcHRpb25zLnNlcmllcyA9IG9wdGlvbnMuc2VyaWVzPy5maWx0ZXIoKHsgdHlwZSB9KSA9PiB7XG4gICAgICBpZiAodHlwZSA9PSBudWxsIHx8IGlzU2VyaWVzT3B0aW9uVHlwZSh0eXBlKSB8fCBpc0VudGVycHJpc2VTZXJpZXNUeXBlKHR5cGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgTG9nZ2VyLndhcm5PbmNlKFxuICAgICAgICBgdW5rbm93biBzZXJpZXMgdHlwZTogJHt0eXBlfTsgZXhwZWN0ZWQgb25lIG9mOiAke3B1YmxpY0NoYXJ0VHlwZXMuc2VyaWVzVHlwZXMuam9pbihcIiwgXCIpfWBcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbiAgc29sb1Nlcmllc0ludGVncml0eShvcHRpb25zKSB7XG4gICAgY29uc3QgYWxsU2VyaWVzID0gb3B0aW9ucy5zZXJpZXM7XG4gICAgaWYgKGFsbFNlcmllcyAmJiBhbGxTZXJpZXMubGVuZ3RoID4gMSAmJiBhbGxTZXJpZXMuc29tZSgoc2VyaWVzKSA9PiBzZXJpZXNSZWdpc3RyeS5pc1NvbG8oc2VyaWVzLnR5cGUpKSkge1xuICAgICAgY29uc3QgbWFpblNlcmllc1R5cGUgPSB0aGlzLm9wdGlvbnNUeXBlKG9wdGlvbnMpO1xuICAgICAgaWYgKHNlcmllc1JlZ2lzdHJ5LmlzU29sbyhtYWluU2VyaWVzVHlwZSkpIHtcbiAgICAgICAgTG9nZ2VyLndhcm4oXG4gICAgICAgICAgYHNlcmllc1swXSBvZiB0eXBlICcke21haW5TZXJpZXNUeXBlfScgaXMgaW5jb21wYXRpYmxlIHdpdGggb3RoZXIgc2VyaWVzIHR5cGVzLiBPbmx5IHByb2Nlc3Npbmcgc2VyaWVzWzBdYFxuICAgICAgICApO1xuICAgICAgICBvcHRpb25zLnNlcmllcyA9IGFsbFNlcmllcy5zbGljZSgwLCAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHsgc29sbywgbm9uU29sbyB9ID0gZ3JvdXBCeShcbiAgICAgICAgICBhbGxTZXJpZXMsXG4gICAgICAgICAgKHMpID0+IHNlcmllc1JlZ2lzdHJ5LmlzU29sbyhzLnR5cGUpID8gXCJzb2xvXCIgOiBcIm5vblNvbG9cIlxuICAgICAgICApO1xuICAgICAgICBjb25zdCByZWplY3RzID0gdW5pcXVlKHNvbG8ubWFwKChzKSA9PiBzLnR5cGUpKS5qb2luKFwiLCBcIik7XG4gICAgICAgIExvZ2dlci53YXJuKGBVbmFibGUgdG8gbWl4IHRoZXNlIHNlcmllcyB0eXBlcyB3aXRoIHRoZSBsZWFkIHNlcmllcyB0eXBlOiAke3JlamVjdHN9YCk7XG4gICAgICAgIG9wdGlvbnMuc2VyaWVzID0gbm9uU29sbztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZW5hYmxlQ29uZmlndXJlZE9wdGlvbnMob3B0aW9ucywgdXNlck9wdGlvbnMpIHtcbiAgICBqc29uV2FsayhcbiAgICAgIHVzZXJPcHRpb25zLFxuICAgICAgKHZpc2l0aW5nVXNlck9wdHMsIHZpc2l0aW5nTWVyZ2VkT3B0cykgPT4ge1xuICAgICAgICBpZiAodmlzaXRpbmdNZXJnZWRPcHRzICYmIFwiZW5hYmxlZFwiIGluIHZpc2l0aW5nTWVyZ2VkT3B0cyAmJiAhdmlzaXRpbmdNZXJnZWRPcHRzLl9lbmFibGVkRnJvbVRoZW1lICYmIHZpc2l0aW5nVXNlck9wdHMuZW5hYmxlZCA9PSBudWxsKSB7XG4gICAgICAgICAgdmlzaXRpbmdNZXJnZWRPcHRzLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgeyBza2lwOiBbXCJkYXRhXCIsIFwidGhlbWVcIl0gfSxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIGpzb25XYWxrKFxuICAgICAgb3B0aW9ucyxcbiAgICAgICh2aXNpdGluZ01lcmdlZE9wdHMpID0+IHtcbiAgICAgICAgaWYgKHZpc2l0aW5nTWVyZ2VkT3B0cy5fZW5hYmxlZEZyb21UaGVtZSAhPSBudWxsKSB7XG4gICAgICAgICAgZGVsZXRlIHZpc2l0aW5nTWVyZ2VkT3B0cy5fZW5hYmxlZEZyb21UaGVtZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHsgc2tpcDogW1wiZGF0YVwiLCBcInRoZW1lXCJdIH1cbiAgICApO1xuICB9XG4gIHJlbW92ZURpc2FibGVkT3B0aW9ucyhvcHRpb25zKSB7XG4gICAganNvbldhbGsoXG4gICAgICBvcHRpb25zLFxuICAgICAgKG9wdGlvbnNOb2RlKSA9PiB7XG4gICAgICAgIGlmIChcImVuYWJsZWRcIiBpbiBvcHRpb25zTm9kZSAmJiBvcHRpb25zTm9kZS5lbmFibGVkID09PSBmYWxzZSkge1xuICAgICAgICAgIE9iamVjdC5rZXlzKG9wdGlvbnNOb2RlKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IFwiZW5hYmxlZFwiKVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBkZWxldGUgb3B0aW9uc05vZGVba2V5XTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHsgc2tpcDogW1wiZGF0YVwiLCBcInRoZW1lXCJdIH1cbiAgICApO1xuICB9XG4gIHJlbW92ZUxlZnRvdmVyU3ltYm9scyhvcHRpb25zKSB7XG4gICAganNvbldhbGsoXG4gICAgICBvcHRpb25zLFxuICAgICAgKG9wdGlvbnNOb2RlKSA9PiB7XG4gICAgICAgIGlmICghb3B0aW9uc05vZGUgfHwgIWlzT2JqZWN0KG9wdGlvbnNOb2RlKSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG9wdGlvbnNOb2RlKSkge1xuICAgICAgICAgIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zTm9kZVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHsgc2tpcDogW1wiZGF0YVwiXSB9XG4gICAgKTtcbiAgfVxuICBzcGVjaWFsT3ZlcnJpZGVzRGVmYXVsdHMob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLndpbmRvdyAhPSBudWxsKSB7XG4gICAgICBzZXRXaW5kb3cob3B0aW9ucy53aW5kb3cpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgb3B0aW9ucy53aW5kb3cgPSB3aW5kb3c7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBvcHRpb25zLndpbmRvdyA9IGdsb2JhbC53aW5kb3c7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmRvY3VtZW50ICE9IG51bGwpIHtcbiAgICAgIHNldERvY3VtZW50KG9wdGlvbnMuZG9jdW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBvcHRpb25zLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBvcHRpb25zLmRvY3VtZW50ID0gZ2xvYmFsLmRvY3VtZW50O1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy53aW5kb3cgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQUcgQ2hhcnRzIC0gdW5hYmxlIHRvIHJlc29sdmUgZ2xvYmFsIHdpbmRvd1wiKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZG9jdW1lbnQgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQUcgQ2hhcnRzIC0gdW5hYmxlIHRvIHJlc29sdmUgZ2xvYmFsIGRvY3VtZW50XCIpO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvYXBpL2FnQ2hhcnRzLnRzXG52YXIgZGVidWcyID0gRGVidWcuY3JlYXRlKHRydWUsIFwib3B0c1wiKTtcbmZ1bmN0aW9uIGNoYXJ0VHlwZShvcHRpb25zKSB7XG4gIGlmIChpc0FnQ2FydGVzaWFuQ2hhcnRPcHRpb25zKG9wdGlvbnMpKSB7XG4gICAgcmV0dXJuIFwiY2FydGVzaWFuXCI7XG4gIH0gZWxzZSBpZiAoaXNBZ1BvbGFyQ2hhcnRPcHRpb25zKG9wdGlvbnMpKSB7XG4gICAgcmV0dXJuIFwicG9sYXJcIjtcbiAgfSBlbHNlIGlmIChpc0FnSGllcmFyY2h5Q2hhcnRPcHRpb25zKG9wdGlvbnMpKSB7XG4gICAgcmV0dXJuIFwiaGllcmFyY2h5XCI7XG4gIH0gZWxzZSBpZiAoaXNBZ1RvcG9sb2d5Q2hhcnRPcHRpb25zKG9wdGlvbnMpKSB7XG4gICAgcmV0dXJuIFwidG9wb2xvZ3lcIjtcbiAgfSBlbHNlIGlmIChpc0FnRmxvd1Byb3BvcnRpb25DaGFydE9wdGlvbnMob3B0aW9ucykpIHtcbiAgICByZXR1cm4gXCJmbG93LXByb3BvcnRpb25cIjtcbiAgfSBlbHNlIGlmIChpc0FnU3RhbmRhbG9uZUNoYXJ0T3B0aW9ucyhvcHRpb25zKSkge1xuICAgIHJldHVybiBcInN0YW5kYWxvbmVcIjtcbiAgfSBlbHNlIGlmIChpc0FnR2F1Z2VDaGFydE9wdGlvbnMob3B0aW9ucykpIHtcbiAgICByZXR1cm4gXCJnYXVnZVwiO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihgQUcgQ2hhcnQgLSB1bmtub3duIHR5cGUgb2YgY2hhcnQgZm9yIG9wdGlvbnMgd2l0aCB0eXBlOiAke29wdGlvbnMudHlwZX1gKTtcbn1cbnZhciBBZ0NoYXJ0cyA9IGNsYXNzIHtcbiAgc3RhdGljIGxpY2Vuc2VDaGVjayhvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMubGljZW5zZUNoZWNrZWQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5saWNlbnNlTWFuYWdlciA9IGVudGVycHJpc2VNb2R1bGUubGljZW5zZU1hbmFnZXI/LihvcHRpb25zKTtcbiAgICB0aGlzLmxpY2Vuc2VNYW5hZ2VyPy5zZXRMaWNlbnNlS2V5KHRoaXMubGljZW5zZUtleSwgdGhpcy5ncmlkQ29udGV4dCk7XG4gICAgdGhpcy5saWNlbnNlTWFuYWdlcj8udmFsaWRhdGVMaWNlbnNlKCk7XG4gICAgdGhpcy5saWNlbnNlQ2hlY2tlZCA9IHRydWU7XG4gIH1cbiAgc3RhdGljIHNldExpY2Vuc2VLZXkobGljZW5zZUtleSkge1xuICAgIHRoaXMubGljZW5zZUtleSA9IGxpY2Vuc2VLZXk7XG4gIH1cbiAgc3RhdGljIHNldEdyaWRDb250ZXh0KGdyaWRDb250ZXh0KSB7XG4gICAgdGhpcy5ncmlkQ29udGV4dCA9IGdyaWRDb250ZXh0O1xuICB9XG4gIHN0YXRpYyBnZXRMaWNlbnNlRGV0YWlscyhsaWNlbnNlS2V5KSB7XG4gICAgcmV0dXJuIGVudGVycHJpc2VNb2R1bGUubGljZW5zZU1hbmFnZXI/Lih7fSkuZ2V0TGljZW5zZURldGFpbHMobGljZW5zZUtleSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGBBZ0NoYXJ0SW5zdGFuY2VgIGZvciBhIERPTSBub2RlLCBpZiB0aGVyZSBpcyBvbmUuXG4gICAqL1xuICBzdGF0aWMgZ2V0SW5zdGFuY2UoZWxlbWVudDIpIHtcbiAgICByZXR1cm4gQWdDaGFydHNJbnRlcm5hbC5nZXRJbnN0YW5jZShlbGVtZW50Mik7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgQWdDaGFydEluc3RhbmNlYCBiYXNlZCB1cG9uIHRoZSBnaXZlbiBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlKHVzZXJPcHRpb25zLCBvcHRpb25zTWV0YWRhdGEpIHtcbiAgICB0aGlzLmxpY2Vuc2VDaGVjayh1c2VyT3B0aW9ucyk7XG4gICAgY29uc3QgY2hhcnQgPSBBZ0NoYXJ0c0ludGVybmFsLmNyZWF0ZU9yVXBkYXRlKHtcbiAgICAgIHVzZXJPcHRpb25zLFxuICAgICAgbGljZW5zZU1hbmFnZXI6IHRoaXMubGljZW5zZU1hbmFnZXIsXG4gICAgICBzdHlsZXM6IGVudGVycHJpc2VNb2R1bGUuc3R5bGVzICE9IG51bGwgPyBbW1wiYWctY2hhcnRzLWVudGVycHJpc2VcIiwgZW50ZXJwcmlzZU1vZHVsZS5zdHlsZXNdXSA6IFtdLFxuICAgICAgb3B0aW9uc01ldGFkYXRhXG4gICAgfSk7XG4gICAgaWYgKHRoaXMubGljZW5zZU1hbmFnZXI/LmlzRGlzcGxheVdhdGVybWFyaygpICYmIHRoaXMubGljZW5zZU1hbmFnZXIpIHtcbiAgICAgIGVudGVycHJpc2VNb2R1bGUuaW5qZWN0V2F0ZXJtYXJrPy4oY2hhcnQuY2hhcnQuY3R4LmRvbU1hbmFnZXIsIHRoaXMubGljZW5zZU1hbmFnZXIuZ2V0V2F0ZXJtYXJrTWVzc2FnZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9XG4gIHN0YXRpYyBjcmVhdGVGaW5hbmNpYWxDaGFydChvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlKG9wdGlvbnMsIHsgcHJlc2V0VHlwZTogXCJwcmljZS12b2x1bWVcIiB9KTtcbiAgfVxuICBzdGF0aWMgY3JlYXRlR2F1Z2Uob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZShvcHRpb25zLCB7IHByZXNldFR5cGU6IFwiZ2F1Z2VcIiB9KTtcbiAgfVxuICBzdGF0aWMgX19jcmVhdGVTcGFya2xpbmUob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZShvcHRpb25zLCB7IHByZXNldFR5cGU6IFwic3BhcmtsaW5lXCIgfSk7XG4gIH1cbn07XG5BZ0NoYXJ0cy5saWNlbnNlQ2hlY2tlZCA9IGZhbHNlO1xuQWdDaGFydHMuZ3JpZENvbnRleHQgPSBmYWxzZTtcbnZhciBfQWdDaGFydHNJbnRlcm5hbCA9IGNsYXNzIF9BZ0NoYXJ0c0ludGVybmFsIHtcbiAgc3RhdGljIGdldEluc3RhbmNlKGVsZW1lbnQyKSB7XG4gICAgY29uc3QgY2hhcnQgPSBDaGFydC5nZXRJbnN0YW5jZShlbGVtZW50Mik7XG4gICAgcmV0dXJuIGNoYXJ0ID8gQWdDaGFydEluc3RhbmNlUHJveHkuY2hhcnRJbnN0YW5jZXMuZ2V0KGNoYXJ0KSA6IHZvaWQgMDtcbiAgfVxuICBzdGF0aWMgaW5pdGlhbGlzZU1vZHVsZXMoKSB7XG4gICAgaWYgKF9BZ0NoYXJ0c0ludGVybmFsLmluaXRpYWxpc2VkKVxuICAgICAgcmV0dXJuO1xuICAgIHJlZ2lzdGVySW5idWlsdE1vZHVsZXMoKTtcbiAgICBzZXR1cE1vZHVsZXMoKTtcbiAgICBfQWdDaGFydHNJbnRlcm5hbC5pbml0aWFsaXNlZCA9IHRydWU7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZU9yVXBkYXRlKG9wdHMpIHtcbiAgICBsZXQgeyBwcm94eSB9ID0gb3B0cztcbiAgICBjb25zdCB7XG4gICAgICB1c2VyT3B0aW9ucyxcbiAgICAgIGxpY2Vuc2VNYW5hZ2VyLFxuICAgICAgc3R5bGVzLFxuICAgICAgcHJvY2Vzc2VkT3ZlcnJpZGVzID0gcHJveHk/LmNoYXJ0LmNoYXJ0T3B0aW9ucy5wcm9jZXNzZWRPdmVycmlkZXMgPz8ge30sXG4gICAgICBzcGVjaWFsT3ZlcnJpZGVzID0gcHJveHk/LmNoYXJ0LmNoYXJ0T3B0aW9ucy5zcGVjaWFsT3ZlcnJpZGVzID8/IHt9LFxuICAgICAgb3B0aW9uc01ldGFkYXRhID0gcHJveHk/LmNoYXJ0LmNoYXJ0T3B0aW9ucy5vcHRpb25NZXRhZGF0YSA/PyB7fVxuICAgIH0gPSBvcHRzO1xuICAgIGNvbnN0IHsgcHJlc2V0VHlwZSB9ID0gb3B0aW9uc01ldGFkYXRhO1xuICAgIF9BZ0NoYXJ0c0ludGVybmFsLmluaXRpYWxpc2VNb2R1bGVzKCk7XG4gICAgZGVidWcyKFwiPj4+IEFnQ2hhcnRzLmNyZWF0ZU9yVXBkYXRlKCkgdXNlciBvcHRpb25zXCIsIHVzZXJPcHRpb25zKTtcbiAgICBsZXQgbXV0YWJsZU9wdGlvbnMgPSB1c2VyT3B0aW9ucztcbiAgICBpZiAoQWdDaGFydHMub3B0aW9uc011dGF0aW9uRm4pIHtcbiAgICAgIG11dGFibGVPcHRpb25zID0gQWdDaGFydHMub3B0aW9uc011dGF0aW9uRm4obXV0YWJsZU9wdGlvbnMsIHByZXNldFR5cGUpO1xuICAgICAgZGVidWcyKFwiPj4+IEFnQ2hhcnRzLmNyZWF0ZU9yVXBkYXRlKCkgTVVUQVRFRCB1c2VyIG9wdGlvbnNcIiwgbXV0YWJsZU9wdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdCB7IG92ZXJyaWRlRGV2aWNlUGl4ZWxSYXRpbywgZG9jdW1lbnQ6IGRvY3VtZW50Miwgd2luZG93OiB1c2VyV2luZG93LCBzdHlsZUNvbnRhaW5lciwgLi4ub3B0aW9ucyB9ID0gbXV0YWJsZU9wdGlvbnM7XG4gICAgY29uc3QgY2hhcnRPcHRpb25zID0gbmV3IENoYXJ0T3B0aW9ucyhcbiAgICAgIG9wdGlvbnMsXG4gICAgICBwcm9jZXNzZWRPdmVycmlkZXMsXG4gICAgICB7XG4gICAgICAgIC4uLnNwZWNpYWxPdmVycmlkZXMsXG4gICAgICAgIGRvY3VtZW50OiBkb2N1bWVudDIsXG4gICAgICAgIHdpbmRvdzogdXNlcldpbmRvdyxcbiAgICAgICAgb3ZlcnJpZGVEZXZpY2VQaXhlbFJhdGlvLFxuICAgICAgICBzdHlsZUNvbnRhaW5lclxuICAgICAgfSxcbiAgICAgIG9wdGlvbnNNZXRhZGF0YVxuICAgICk7XG4gICAgbGV0IGNoYXJ0ID0gcHJveHk/LmNoYXJ0O1xuICAgIGlmIChjaGFydCA9PSBudWxsIHx8IGNoYXJ0VHlwZShjaGFydE9wdGlvbnMucHJvY2Vzc2VkT3B0aW9ucykgIT09IGNoYXJ0VHlwZShjaGFydD8uY2hhcnRPcHRpb25zLnByb2Nlc3NlZE9wdGlvbnMpKSB7XG4gICAgICBjaGFydCA9IF9BZ0NoYXJ0c0ludGVybmFsLmNyZWF0ZUNoYXJ0SW5zdGFuY2UoY2hhcnRPcHRpb25zLCBjaGFydCk7XG4gICAgICBzdHlsZXM/LmZvckVhY2goKFtpZCwgY3NzXSkgPT4ge1xuICAgICAgICBjaGFydD8uY3R4LmRvbU1hbmFnZXIuYWRkU3R5bGVzKGlkLCBjc3MpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChwcm94eSA9PSBudWxsKSB7XG4gICAgICBwcm94eSA9IG5ldyBBZ0NoYXJ0SW5zdGFuY2VQcm94eShjaGFydCwgX0FnQ2hhcnRzSW50ZXJuYWwuY2FsbGJhY2tBcGksIGxpY2Vuc2VNYW5hZ2VyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJveHkuY2hhcnQgPSBjaGFydDtcbiAgICB9XG4gICAgaWYgKGRlYnVnMi5jaGVjaygpICYmIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHdpbmRvdy5hZ0NoYXJ0SW5zdGFuY2VzID8/ICh3aW5kb3cuYWdDaGFydEluc3RhbmNlcyA9IHt9KTtcbiAgICAgIHdpbmRvdy5hZ0NoYXJ0SW5zdGFuY2VzW2NoYXJ0LmlkXSA9IGNoYXJ0O1xuICAgIH1cbiAgICBjaGFydC5xdWV1ZWRVc2VyT3B0aW9ucy5wdXNoKHVzZXJPcHRpb25zKTtcbiAgICBjaGFydC5yZXF1ZXN0RmFjdG9yeVVwZGF0ZSgoY2hhcnRSZWYpID0+IHtcbiAgICAgIGNoYXJ0UmVmLmFwcGx5T3B0aW9ucyhjaGFydE9wdGlvbnMpO1xuICAgICAgY29uc3QgcXVldWVJZHggPSBjaGFydFJlZi5xdWV1ZWRVc2VyT3B0aW9ucy5pbmRleE9mKHVzZXJPcHRpb25zKSArIDE7XG4gICAgICBjaGFydFJlZi5xdWV1ZWRVc2VyT3B0aW9ucy5zcGxpY2UoMCwgcXVldWVJZHgpO1xuICAgIH0pO1xuICAgIHJldHVybiBwcm94eTtcbiAgfVxuICBzdGF0aWMgdXBkYXRlVXNlckRlbHRhKHByb3h5LCBkZWx0YU9wdGlvbnMpIHtcbiAgICBkZWx0YU9wdGlvbnMgPSBkZWVwQ2xvbmUoZGVsdGFPcHRpb25zLCB7IHNoYWxsb3c6IFtcImRhdGFcIl0gfSk7XG4gICAganNvbldhbGsoXG4gICAgICBkZWx0YU9wdGlvbnMsXG4gICAgICAobm9kZSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIG5vZGUgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhub2RlKSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obm9kZSwgeyBba2V5XTogU3ltYm9sKFwiVU5TRVRcIikgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgeyBza2lwOiBbXCJkYXRhXCJdIH1cbiAgICApO1xuICAgIGNvbnN0IHsgY2hhcnQgfSA9IHByb3h5O1xuICAgIGNvbnN0IGxhc3RVcGRhdGVPcHRpb25zID0gY2hhcnQuZ2V0T3B0aW9ucygpO1xuICAgIGNvbnN0IHVzZXJPcHRpb25zID0gbWVyZ2VEZWZhdWx0cyhkZWx0YU9wdGlvbnMsIGxhc3RVcGRhdGVPcHRpb25zKTtcbiAgICBkZWJ1ZzIoXCI+Pj4gQWdDaGFydHMudXBkYXRlVXNlckRlbHRhKCkgdXNlciBkZWx0YVwiLCBkZWx0YU9wdGlvbnMpO1xuICAgIGRlYnVnMihcIkFnQ2hhcnRzLnVwZGF0ZVVzZXJEZWx0YSgpIC0gYmFzZSBvcHRpb25zXCIsIGxhc3RVcGRhdGVPcHRpb25zKTtcbiAgICBfQWdDaGFydHNJbnRlcm5hbC5jcmVhdGVPclVwZGF0ZSh7IHVzZXJPcHRpb25zLCBwcm94eSB9KTtcbiAgfVxuICBzdGF0aWMgY3JlYXRlQ2hhcnRJbnN0YW5jZShvcHRpb25zLCBvbGRDaGFydCkge1xuICAgIGNvbnN0IHRyYW5zZmVyYWJsZVJlc291cmNlID0gb2xkQ2hhcnQ/LmRlc3Ryb3koeyBrZWVwVHJhbnNmZXJhYmxlUmVzb3VyY2VzOiB0cnVlIH0pO1xuICAgIGNvbnN0IENoYXJ0Q29uc3RydWN0b3IgPSBfQWdDaGFydHNJbnRlcm5hbC5nZXRDaGFydEJ5T3B0aW9ucyhvcHRpb25zLnByb2Nlc3NlZE9wdGlvbnMpO1xuICAgIHJldHVybiBuZXcgQ2hhcnRDb25zdHJ1Y3RvcihvcHRpb25zLCB0cmFuc2ZlcmFibGVSZXNvdXJjZSk7XG4gIH1cbiAgc3RhdGljIGdldENoYXJ0QnlPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBpZiAoaXNBZ0NhcnRlc2lhbkNoYXJ0T3B0aW9ucyhvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIENhcnRlc2lhbkNoYXJ0O1xuICAgIH0gZWxzZSBpZiAoaXNBZ0hpZXJhcmNoeUNoYXJ0T3B0aW9ucyhvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIEhpZXJhcmNoeUNoYXJ0O1xuICAgIH0gZWxzZSBpZiAoaXNBZ1BvbGFyQ2hhcnRPcHRpb25zKG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gUG9sYXJDaGFydDtcbiAgICB9IGVsc2UgaWYgKGlzQWdUb3BvbG9neUNoYXJ0T3B0aW9ucyhvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIFRvcG9sb2d5Q2hhcnQ7XG4gICAgfSBlbHNlIGlmIChpc0FnRmxvd1Byb3BvcnRpb25DaGFydE9wdGlvbnMob3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBGbG93UHJvcG9ydGlvbkNoYXJ0O1xuICAgIH0gZWxzZSBpZiAoaXNBZ1N0YW5kYWxvbmVDaGFydE9wdGlvbnMob3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBTdGFuZGFsb25lQ2hhcnQ7XG4gICAgfSBlbHNlIGlmIChpc0FnR2F1Z2VDaGFydE9wdGlvbnMob3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBHYXVnZUNoYXJ0O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgQUcgQ2hhcnRzIC0gY291bGRuJ3QgYXBwbHkgY29uZmlndXJhdGlvbiwgY2hlY2sgb3B0aW9ucyBhcmUgY29ycmVjdGx5IHN0cnVjdHVyZWQgYW5kIHNlcmllcyB0eXBlcyBhcmUgc3BlY2lmaWVkYFxuICAgICk7XG4gIH1cbn07XG5fQWdDaGFydHNJbnRlcm5hbC5jYXJldGFrZXIgPSBuZXcgTWVtZW50b0NhcmV0YWtlcihWRVJTSU9OKTtcbl9BZ0NoYXJ0c0ludGVybmFsLmluaXRpYWxpc2VkID0gZmFsc2U7XG5fQWdDaGFydHNJbnRlcm5hbC5jYWxsYmFja0FwaSA9IHtcbiAgY2FyZXRha2VyOiBfQWdDaGFydHNJbnRlcm5hbC5jYXJldGFrZXIsXG4gIGNyZWF0ZSh1c2VyT3B0aW9ucywgcHJvY2Vzc2VkT3ZlcnJpZGVzLCBzcGVjaWFsT3ZlcnJpZGVzLCBvcHRpb25zTWV0YWRhdGEpIHtcbiAgICByZXR1cm4gX0FnQ2hhcnRzSW50ZXJuYWwuY3JlYXRlT3JVcGRhdGUoe1xuICAgICAgdXNlck9wdGlvbnMsXG4gICAgICBwcm9jZXNzZWRPdmVycmlkZXMsXG4gICAgICBzcGVjaWFsT3ZlcnJpZGVzLFxuICAgICAgb3B0aW9uc01ldGFkYXRhXG4gICAgfSk7XG4gIH0sXG4gIHVwZGF0ZShvcHRzLCBjaGFydCkge1xuICAgIHJldHVybiBfQWdDaGFydHNJbnRlcm5hbC5jcmVhdGVPclVwZGF0ZSh7IHVzZXJPcHRpb25zOiBvcHRzLCBwcm94eTogY2hhcnQgfSk7XG4gIH0sXG4gIHVwZGF0ZVVzZXJEZWx0YShjaGFydCwgZGVsdGFPcHRpb25zKSB7XG4gICAgcmV0dXJuIF9BZ0NoYXJ0c0ludGVybmFsLnVwZGF0ZVVzZXJEZWx0YShjaGFydCwgZGVsdGFPcHRpb25zKTtcbiAgfVxufTtcbnZhciBBZ0NoYXJ0c0ludGVybmFsID0gX0FnQ2hhcnRzSW50ZXJuYWw7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL21haW4tbW9kdWxlcy50c1xuZnVuY3Rpb24gc2V0dXBDb21tdW5pdHlNb2R1bGVzKCkge1xuICByZWdpc3RlckluYnVpbHRNb2R1bGVzKCk7XG4gIHJldHVybiB7IEFnQ2hhcnRzLCB2ZXJzaW9uOiBWRVJTSU9OIH07XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2ludGVncmF0ZWQtY2hhcnRzLXNjZW5lLnRzXG52YXIgaW50ZWdyYXRlZF9jaGFydHNfc2NlbmVfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoaW50ZWdyYXRlZF9jaGFydHNfc2NlbmVfZXhwb3J0cywge1xuICBBcmM6ICgpID0+IEFyYzIsXG4gIEFycm93RG93bjogKCkgPT4gQXJyb3dEb3duLFxuICBBcnJvd1VwOiAoKSA9PiBBcnJvd1VwLFxuICBCQm94OiAoKSA9PiBCQm94LFxuICBCYW5kU2NhbGU6ICgpID0+IEJhbmRTY2FsZSxcbiAgQ2FwdGlvbjogKCkgPT4gQ2FwdGlvbixcbiAgQ2hhbmdlRGV0ZWN0YWJsZVByb3BlcnRpZXM6ICgpID0+IENoYW5nZURldGVjdGFibGVQcm9wZXJ0aWVzLFxuICBDaXJjbGU6ICgpID0+IENpcmNsZSxcbiAgQ29uaWNHcmFkaWVudDogKCkgPT4gQ29uaWNHcmFkaWVudCxcbiAgQ29udGludW91c1NjYWxlOiAoKSA9PiBDb250aW51b3VzU2NhbGUsXG4gIERpYW1vbmQ6ICgpID0+IERpYW1vbmQsXG4gIERyb3BTaGFkb3c6ICgpID0+IERyb3BTaGFkb3csXG4gIEV4dGVuZGVkUGF0aDJEOiAoKSA9PiBFeHRlbmRlZFBhdGgyRCxcbiAgR3JhZGllbnQ6ICgpID0+IEdyYWRpZW50LFxuICBHcm91cDogKCkgPT4gR3JvdXAsXG4gIEhkcGlDYW52YXM6ICgpID0+IEhkcGlDYW52YXMsXG4gIEltYWdlOiAoKSA9PiBJbWFnZSxcbiAgTGFiZWw6ICgpID0+IExhYmVsLFxuICBMYXllcjogKCkgPT4gTGF5ZXIsXG4gIExpbmU6ICgpID0+IExpbmUsXG4gIExpbmVhckdyYWRpZW50OiAoKSA9PiBMaW5lYXJHcmFkaWVudCxcbiAgTGluZWFyU2NhbGU6ICgpID0+IExpbmVhclNjYWxlLFxuICBNYXJrZXI6ICgpID0+IE1hcmtlcixcbiAgTm9kZTogKCkgPT4gTm9kZSxcbiAgT3JkaW5hbFRpbWVTY2FsZTogKCkgPT4gT3JkaW5hbFRpbWVTY2FsZSxcbiAgUGF0aDogKCkgPT4gUGF0aCxcbiAgUG9pbnRlckV2ZW50czogKCkgPT4gUG9pbnRlckV2ZW50cyxcbiAgUmFkaWFsQ29sdW1uU2hhcGU6ICgpID0+IFJhZGlhbENvbHVtblNoYXBlLFxuICBSZWN0OiAoKSA9PiBSZWN0LFxuICBSZWRyYXdUeXBlOiAoKSA9PiBSZWRyYXdUeXBlLFxuICBSb3RhdGFibGU6ICgpID0+IFJvdGF0YWJsZSxcbiAgUm90YXRhYmxlR3JvdXA6ICgpID0+IFJvdGF0YWJsZUdyb3VwLFxuICBSb3RhdGFibGVUZXh0OiAoKSA9PiBSb3RhdGFibGVUZXh0LFxuICBTY2FsYWJsZTogKCkgPT4gU2NhbGFibGUsXG4gIFNjYWxhYmxlR3JvdXA6ICgpID0+IFNjYWxhYmxlR3JvdXAsXG4gIFNjZW5lOiAoKSA9PiBTY2VuZSxcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb246ICgpID0+IFNjZW5lQ2hhbmdlRGV0ZWN0aW9uLFxuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb246ICgpID0+IFNjZW5lUGF0aENoYW5nZURldGVjdGlvbixcbiAgU2VjdG9yOiAoKSA9PiBTZWN0b3IsXG4gIFNlY3RvckJveDogKCkgPT4gU2VjdG9yQm94LFxuICBTZWxlY3Rpb246ICgpID0+IFNlbGVjdGlvbixcbiAgU2hhcGU6ICgpID0+IFNoYXBlLFxuICBTcXVhcmU6ICgpID0+IFNxdWFyZSxcbiAgU3ZnUGF0aDogKCkgPT4gU3ZnUGF0aCxcbiAgVGV4dDogKCkgPT4gVGV4dCxcbiAgVG9vbHRpcDogKCkgPT4gVG9vbHRpcCxcbiAgVHJhbnNmb3JtYWJsZTogKCkgPT4gVHJhbnNmb3JtYWJsZSxcbiAgVHJhbnNmb3JtYWJsZVRleHQ6ICgpID0+IFRyYW5zZm9ybWFibGVUZXh0LFxuICBUcmFuc2xhdGFibGU6ICgpID0+IFRyYW5zbGF0YWJsZSxcbiAgVHJhbnNsYXRhYmxlR3JvdXA6ICgpID0+IFRyYW5zbGF0YWJsZUdyb3VwLFxuICBUcmFuc2xhdGFibGVMYXllcjogKCkgPT4gVHJhbnNsYXRhYmxlTGF5ZXIsXG4gIFRyaWFuZ2xlOiAoKSA9PiBUcmlhbmdsZSxcbiAgY2FsY3VsYXRlRGVyaXZhdGl2ZUV4dHJlbWE6ICgpID0+IGNhbGN1bGF0ZURlcml2YXRpdmVFeHRyZW1hLFxuICBjYWxjdWxhdGVEZXJpdmF0aXZlRXh0cmVtYVhZOiAoKSA9PiBjYWxjdWxhdGVEZXJpdmF0aXZlRXh0cmVtYVhZLFxuICBkcmF3Q29ybmVyOiAoKSA9PiBkcmF3Q29ybmVyLFxuICBlYXNpbmc6ICgpID0+IGVhc2luZ19leHBvcnRzLFxuICBldmFsdWF0ZUJlemllcjogKCkgPT4gZXZhbHVhdGVCZXppZXIsXG4gIGdldEZvbnQ6ICgpID0+IGdldEZvbnQsXG4gIGdldE1hcmtlcjogKCkgPT4gZ2V0TWFya2VyLFxuICBnZXRSYWRpYWxDb2x1bW5XaWR0aDogKCkgPT4gZ2V0UmFkaWFsQ29sdW1uV2lkdGgsXG4gIG1vdGlvbjogKCkgPT4gbW90aW9uLFxuICBzZWN0b3JCb3g6ICgpID0+IHNlY3RvckJveCxcbiAgc29sdmVCZXppZXI6ICgpID0+IHNvbHZlQmV6aWVyLFxuICBzcGxpdEJlemllcjogKCkgPT4gc3BsaXRCZXppZXIsXG4gIHRvUmFkaWFuczogKCkgPT4gdG9SYWRpYW5zLFxuICB0b1Rvb2x0aXBIdG1sOiAoKSA9PiB0b1Rvb2x0aXBIdG1sXG59KTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvc2hhcGUvYXJjLnRzXG52YXIgQXJjMiA9IGNsYXNzIGV4dGVuZHMgUGF0aCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jZW50ZXJYID0gMDtcbiAgICB0aGlzLmNlbnRlclkgPSAwO1xuICAgIHRoaXMucmFkaXVzID0gMTA7XG4gICAgdGhpcy5zdGFydEFuZ2xlID0gMDtcbiAgICB0aGlzLmVuZEFuZ2xlID0gTWF0aC5QSSAqIDI7XG4gICAgdGhpcy5jb3VudGVyQ2xvY2t3aXNlID0gZmFsc2U7XG4gICAgdGhpcy50eXBlID0gMCAvKiBPcGVuICovO1xuICAgIHRoaXMucmVzdG9yZU93blN0eWxlcygpO1xuICB9XG4gIGdldCBmdWxsUGllKCkge1xuICAgIHJldHVybiBpc0VxdWFsKG5vcm1hbGl6ZUFuZ2xlMzYwKHRoaXMuc3RhcnRBbmdsZSksIG5vcm1hbGl6ZUFuZ2xlMzYwKHRoaXMuZW5kQW5nbGUpKTtcbiAgfVxuICB1cGRhdGVQYXRoKCkge1xuICAgIGNvbnN0IHBhdGggPSB0aGlzLnBhdGg7XG4gICAgcGF0aC5jbGVhcigpO1xuICAgIHBhdGguYXJjKHRoaXMuY2VudGVyWCwgdGhpcy5jZW50ZXJZLCB0aGlzLnJhZGl1cywgdGhpcy5zdGFydEFuZ2xlLCB0aGlzLmVuZEFuZ2xlLCB0aGlzLmNvdW50ZXJDbG9ja3dpc2UpO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IDEgLyogQ2hvcmQgKi8pIHtcbiAgICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IDIgLyogUm91bmQgKi8gJiYgIXRoaXMuZnVsbFBpZSkge1xuICAgICAgcGF0aC5saW5lVG8odGhpcy5jZW50ZXJYLCB0aGlzLmNlbnRlclkpO1xuICAgICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gIH1cbiAgY29tcHV0ZUJCb3goKSB7XG4gICAgcmV0dXJuIG5ldyBCQm94KHRoaXMuY2VudGVyWCAtIHRoaXMucmFkaXVzLCB0aGlzLmNlbnRlclkgLSB0aGlzLnJhZGl1cywgdGhpcy5yYWRpdXMgKiAyLCB0aGlzLnJhZGl1cyAqIDIpO1xuICB9XG4gIGlzUG9pbnRJblBhdGgoeCwgeSkge1xuICAgIGNvbnN0IGJib3ggPSB0aGlzLmdldEJCb3goKTtcbiAgICByZXR1cm4gdGhpcy50eXBlICE9PSAwIC8qIE9wZW4gKi8gJiYgYmJveC5jb250YWluc1BvaW50KHgsIHkpICYmIHRoaXMucGF0aC5pc1BvaW50SW5QYXRoKHgsIHkpO1xuICB9XG59O1xuQXJjMi5jbGFzc05hbWUgPSBcIkFyY1wiO1xuQXJjMi5kZWZhdWx0U3R5bGVzID0geyAuLi5TaGFwZS5kZWZhdWx0U3R5bGVzLCBsaW5lV2lkdGg6IDEsIGZpbGxTdHlsZTogbnVsbCB9O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIEFyYzIucHJvdG90eXBlLCBcImNlbnRlclhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgQXJjMi5wcm90b3R5cGUsIFwiY2VudGVyWVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBBcmMyLnByb3RvdHlwZSwgXCJyYWRpdXNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgQXJjMi5wcm90b3R5cGUsIFwic3RhcnRBbmdsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBBcmMyLnByb3RvdHlwZSwgXCJlbmRBbmdsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBBcmMyLnByb3RvdHlwZSwgXCJjb3VudGVyQ2xvY2t3aXNlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIEFyYzIucHJvdG90eXBlLCBcInR5cGVcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL2dyYWRpZW50L2NvbmljR3JhZGllbnQudHNcbnZhciBDb25pY0dyYWRpZW50ID0gY2xhc3MgZXh0ZW5kcyBHcmFkaWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbG9yU3BhY2UsIHN0b3BzLCBhbmdsZTIgPSAwLCBiYm94KSB7XG4gICAgc3VwZXIoY29sb3JTcGFjZSwgc3RvcHMsIGJib3gpO1xuICAgIHRoaXMuYW5nbGUgPSBhbmdsZTI7XG4gIH1cbiAgY3JlYXRlQ2FudmFzR3JhZGllbnQoY3R4LCBiYm94KSB7XG4gICAgY29uc3QgYW5nbGVPZmZzZXQgPSA5MDtcbiAgICBjb25zdCB7IGNvbG9yU3BhY2UsIHN0b3BzLCBhbmdsZTogYW5nbGUyIH0gPSB0aGlzO1xuICAgIGNvbnN0IHJhZGlhbnMgPSBub3JtYWxpemVBbmdsZTM2MCh0b1JhZGlhbnMoYW5nbGUyICsgYW5nbGVPZmZzZXQpKTtcbiAgICBpZiAoIShcImNyZWF0ZUNvbmljR3JhZGllbnRcIiBpbiBjdHgpKSB7XG4gICAgICBjb25zdCBsaW5lYXJHcmFkaWVudCA9IG5ldyBMaW5lYXJHcmFkaWVudChjb2xvclNwYWNlLCBzdG9wcywgYW5nbGUyKTtcbiAgICAgIHJldHVybiBsaW5lYXJHcmFkaWVudC5jcmVhdGVDYW52YXNHcmFkaWVudChjdHgsIGJib3gpO1xuICAgIH1cbiAgICBjb25zdCBjeCA9IGJib3gueCArIGJib3gud2lkdGggKiAwLjU7XG4gICAgY29uc3QgY3kgPSBiYm94LnkgKyBiYm94LmhlaWdodCAqIDAuNTtcbiAgICByZXR1cm4gY3R4LmNyZWF0ZUNvbmljR3JhZGllbnQocmFkaWFucywgY3gsIGN5KTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvc2hhcGUvcmFkaWFsQ29sdW1uU2hhcGUudHNcbmZ1bmN0aW9uIHJvdGF0ZVBvaW50KHgsIHksIHJvdGF0aW9uKSB7XG4gIGNvbnN0IHJhZGl1cyA9IE1hdGguc3FydCh4ICoqIDIgKyB5ICoqIDIpO1xuICBjb25zdCBhbmdsZTIgPSBNYXRoLmF0YW4yKHksIHgpO1xuICBjb25zdCByb3RhdGVkID0gYW5nbGUyICsgcm90YXRpb247XG4gIHJldHVybiB7XG4gICAgeDogTWF0aC5jb3Mocm90YXRlZCkgKiByYWRpdXMsXG4gICAgeTogTWF0aC5zaW4ocm90YXRlZCkgKiByYWRpdXNcbiAgfTtcbn1cbnZhciBSYWRpYWxDb2x1bW5TaGFwZSA9IGNsYXNzIGV4dGVuZHMgUGF0aCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5pc0JldmVsZWQgPSB0cnVlO1xuICAgIHRoaXMuY29sdW1uV2lkdGggPSAwO1xuICAgIHRoaXMuc3RhcnRBbmdsZSA9IDA7XG4gICAgdGhpcy5lbmRBbmdsZSA9IDA7XG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IDA7XG4gICAgdGhpcy5pbm5lclJhZGl1cyA9IDA7XG4gICAgdGhpcy5heGlzSW5uZXJSYWRpdXMgPSAwO1xuICAgIHRoaXMuYXhpc091dGVyUmFkaXVzID0gMDtcbiAgICB0aGlzLmlzUmFkaXVzQXhpc1JldmVyc2VkID0gZmFsc2U7XG4gIH1cbiAgc2V0IGNvcm5lclJhZGl1cyhfdmFsdWUpIHtcbiAgfVxuICBjb21wdXRlQkJveCgpIHtcbiAgICBjb25zdCB7IGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cywgY29sdW1uV2lkdGggfSA9IHRoaXM7XG4gICAgY29uc3Qgcm90YXRpb24gPSB0aGlzLmdldFJvdGF0aW9uKCk7XG4gICAgY29uc3QgbGVmdCA9IC1jb2x1bW5XaWR0aCAvIDI7XG4gICAgY29uc3QgcmlnaHQgPSBjb2x1bW5XaWR0aCAvIDI7XG4gICAgY29uc3QgdG9wID0gLW91dGVyUmFkaXVzO1xuICAgIGNvbnN0IGJvdHRvbSA9IC1pbm5lclJhZGl1cztcbiAgICBsZXQgeDAgPSBJbmZpbml0eTtcbiAgICBsZXQgeTAgPSBJbmZpbml0eTtcbiAgICBsZXQgeDEgPSAtSW5maW5pdHk7XG4gICAgbGV0IHkxID0gLUluZmluaXR5O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSArPSAxKSB7XG4gICAgICBjb25zdCB7IHgsIHkgfSA9IHJvdGF0ZVBvaW50KGkgJSAyID09PSAwID8gbGVmdCA6IHJpZ2h0LCBpIDwgMiA/IHRvcCA6IGJvdHRvbSwgcm90YXRpb24pO1xuICAgICAgeDAgPSBNYXRoLm1pbih4LCB4MCk7XG4gICAgICB5MCA9IE1hdGgubWluKHksIHkwKTtcbiAgICAgIHgxID0gTWF0aC5tYXgoeCwgeDEpO1xuICAgICAgeTEgPSBNYXRoLm1heCh5LCB5MSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQkJveCh4MCwgeTAsIHgxIC0geDAsIHkxIC0geTApO1xuICB9XG4gIGdldFJvdGF0aW9uKCkge1xuICAgIGNvbnN0IHsgc3RhcnRBbmdsZSwgZW5kQW5nbGUgfSA9IHRoaXM7XG4gICAgY29uc3QgbWlkQW5nbGUgPSBhbmdsZUJldHdlZW4oc3RhcnRBbmdsZSwgZW5kQW5nbGUpO1xuICAgIHJldHVybiBub3JtYWxpemVBbmdsZTM2MChzdGFydEFuZ2xlICsgbWlkQW5nbGUgLyAyICsgTWF0aC5QSSAvIDIpO1xuICB9XG4gIHVwZGF0ZVBhdGgoKSB7XG4gICAgY29uc3QgeyBpc0JldmVsZWQgfSA9IHRoaXM7XG4gICAgaWYgKGlzQmV2ZWxlZCkge1xuICAgICAgdGhpcy51cGRhdGVCZXZlbGVkUGF0aCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVwZGF0ZVJlY3Rhbmd1bGFyUGF0aCgpO1xuICAgIH1cbiAgICB0aGlzLmNoZWNrUGF0aERpcnR5KCk7XG4gIH1cbiAgdXBkYXRlUmVjdGFuZ3VsYXJQYXRoKCkge1xuICAgIGNvbnN0IHsgY29sdW1uV2lkdGgsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cywgcGF0aCB9ID0gdGhpcztcbiAgICBjb25zdCBsZWZ0ID0gLWNvbHVtbldpZHRoIC8gMjtcbiAgICBjb25zdCByaWdodCA9IGNvbHVtbldpZHRoIC8gMjtcbiAgICBjb25zdCB0b3AgPSAtb3V0ZXJSYWRpdXM7XG4gICAgY29uc3QgYm90dG9tID0gLWlubmVyUmFkaXVzO1xuICAgIGNvbnN0IHJvdGF0aW9uID0gdGhpcy5nZXRSb3RhdGlvbigpO1xuICAgIGNvbnN0IHBvaW50cyA9IFtcbiAgICAgIFtsZWZ0LCBib3R0b21dLFxuICAgICAgW2xlZnQsIHRvcF0sXG4gICAgICBbcmlnaHQsIHRvcF0sXG4gICAgICBbcmlnaHQsIGJvdHRvbV1cbiAgICBdLm1hcCgoW3gsIHldKSA9PiByb3RhdGVQb2ludCh4LCB5LCByb3RhdGlvbikpO1xuICAgIHBhdGguY2xlYXIodHJ1ZSk7XG4gICAgcGF0aC5tb3ZlVG8ocG9pbnRzWzBdLngsIHBvaW50c1swXS55KTtcbiAgICBwYXRoLmxpbmVUbyhwb2ludHNbMV0ueCwgcG9pbnRzWzFdLnkpO1xuICAgIHBhdGgubGluZVRvKHBvaW50c1syXS54LCBwb2ludHNbMl0ueSk7XG4gICAgcGF0aC5saW5lVG8ocG9pbnRzWzNdLngsIHBvaW50c1szXS55KTtcbiAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICB9XG4gIHVwZGF0ZUJldmVsZWRQYXRoKCkge1xuICAgIGNvbnN0IHsgY29sdW1uV2lkdGgsIHBhdGgsIG91dGVyUmFkaXVzLCBpbm5lclJhZGl1cywgYXhpc0lubmVyUmFkaXVzLCBheGlzT3V0ZXJSYWRpdXMsIGlzUmFkaXVzQXhpc1JldmVyc2VkIH0gPSB0aGlzO1xuICAgIGNvbnN0IGlzU3RhY2tCb3R0b20gPSBpc0VxdWFsKGlubmVyUmFkaXVzLCBheGlzSW5uZXJSYWRpdXMpO1xuICAgIGNvbnN0IHNpZGVSb3RhdGlvbiA9IE1hdGguYXNpbihjb2x1bW5XaWR0aCAvIDIgLyBpbm5lclJhZGl1cyk7XG4gICAgY29uc3QgcG9pbnRSb3RhdGlvbiA9IHRoaXMuZ2V0Um90YXRpb24oKTtcbiAgICBjb25zdCByb3RhdGUyID0gKHgsIHkpID0+IHJvdGF0ZVBvaW50KHgsIHksIHBvaW50Um90YXRpb24pO1xuICAgIGNvbnN0IGdldFRyaWFuZ2xlSHlwb3RlbnVzZSA9IChsZWcsIG90aGVyTGVnKSA9PiBNYXRoLnNxcnQobGVnICoqIDIgKyBvdGhlckxlZyAqKiAyKTtcbiAgICBjb25zdCBnZXRUcmlhbmdsZUxlZyA9IChoeXBvdGVudXNlLCBvdGhlckxlZykgPT4ge1xuICAgICAgaWYgKG90aGVyTGVnID4gaHlwb3RlbnVzZSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBNYXRoLnNxcnQoaHlwb3RlbnVzZSAqKiAyIC0gb3RoZXJMZWcgKiogMik7XG4gICAgfTtcbiAgICBjb25zdCBjb21wYXJlID0gKHZhbHVlLCBvdGhlclZhbHVlLCBsZXNzVGhhbikgPT4gbGVzc1RoYW4gPyB2YWx1ZSA8IG90aGVyVmFsdWUgOiB2YWx1ZSA+IG90aGVyVmFsdWU7XG4gICAgY29uc3Qgc2hvdWxkQ29ubmVjdEJvdHRvbUNpcmNsZSA9IGlzU3RhY2tCb3R0b20gJiYgIWlzTmFOKHNpZGVSb3RhdGlvbikgJiYgc2lkZVJvdGF0aW9uIDwgTWF0aC5QSSAvIDY7XG4gICAgbGV0IGxlZnQgPSAtY29sdW1uV2lkdGggLyAyO1xuICAgIGxldCByaWdodCA9IGNvbHVtbldpZHRoIC8gMjtcbiAgICBjb25zdCB0b3AgPSAtb3V0ZXJSYWRpdXM7XG4gICAgY29uc3QgYm90dG9tID0gLWlubmVyUmFkaXVzICogKHNob3VsZENvbm5lY3RCb3R0b21DaXJjbGUgPyBNYXRoLmNvcyhzaWRlUm90YXRpb24pIDogMSk7XG4gICAgY29uc3QgaGFzQm90dG9tSW50ZXJzZWN0aW9uID0gY29tcGFyZShcbiAgICAgIGF4aXNPdXRlclJhZGl1cyxcbiAgICAgIGdldFRyaWFuZ2xlSHlwb3RlbnVzZShpbm5lclJhZGl1cywgY29sdW1uV2lkdGggLyAyKSxcbiAgICAgICFpc1JhZGl1c0F4aXNSZXZlcnNlZFxuICAgICk7XG4gICAgaWYgKGhhc0JvdHRvbUludGVyc2VjdGlvbikge1xuICAgICAgY29uc3QgYm90dG9tSW50ZXJzZWN0aW9uWCA9IGdldFRyaWFuZ2xlTGVnKGF4aXNPdXRlclJhZGl1cywgaW5uZXJSYWRpdXMpO1xuICAgICAgbGVmdCA9IC1ib3R0b21JbnRlcnNlY3Rpb25YO1xuICAgICAgcmlnaHQgPSBib3R0b21JbnRlcnNlY3Rpb25YO1xuICAgIH1cbiAgICBwYXRoLmNsZWFyKHRydWUpO1xuICAgIGNvbnN0IGJvdHRvbUxlZnRQdCA9IHJvdGF0ZTIobGVmdCwgYm90dG9tKTtcbiAgICBwYXRoLm1vdmVUbyhib3R0b21MZWZ0UHQueCwgYm90dG9tTGVmdFB0LnkpO1xuICAgIGNvbnN0IGlzRW1wdHkgPSBpc0VxdWFsKGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cyk7XG4gICAgY29uc3QgaGFzU2lkZUludGVyc2VjdGlvbiA9IGNvbXBhcmUoXG4gICAgICBheGlzT3V0ZXJSYWRpdXMsXG4gICAgICBnZXRUcmlhbmdsZUh5cG90ZW51c2Uob3V0ZXJSYWRpdXMsIGNvbHVtbldpZHRoIC8gMiksXG4gICAgICAhaXNSYWRpdXNBeGlzUmV2ZXJzZWRcbiAgICApO1xuICAgIGlmIChpc0VtcHR5ICYmIHNob3VsZENvbm5lY3RCb3R0b21DaXJjbGUpIHtcbiAgICAgIHBhdGguYXJjKFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICBpbm5lclJhZGl1cyxcbiAgICAgICAgbm9ybWFsaXplQW5nbGUzNjAoLXNpZGVSb3RhdGlvbiAtIE1hdGguUEkgLyAyKSArIHBvaW50Um90YXRpb24sXG4gICAgICAgIG5vcm1hbGl6ZUFuZ2xlMzYwKHNpZGVSb3RhdGlvbiAtIE1hdGguUEkgLyAyKSArIHBvaW50Um90YXRpb24sXG4gICAgICAgIGZhbHNlXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaGFzU2lkZUludGVyc2VjdGlvbikge1xuICAgICAgY29uc3Qgc2lkZUludGVyc2VjdGlvblkgPSAtZ2V0VHJpYW5nbGVMZWcoYXhpc091dGVyUmFkaXVzLCBjb2x1bW5XaWR0aCAvIDIpO1xuICAgICAgY29uc3QgdG9wSW50ZXJzZWN0aW9uWCA9IGdldFRyaWFuZ2xlTGVnKGF4aXNPdXRlclJhZGl1cywgb3V0ZXJSYWRpdXMpO1xuICAgICAgaWYgKCFoYXNCb3R0b21JbnRlcnNlY3Rpb24pIHtcbiAgICAgICAgY29uc3QgdG9wTGVmdFB0ID0gcm90YXRlMihsZWZ0LCBzaWRlSW50ZXJzZWN0aW9uWSk7XG4gICAgICAgIHBhdGgubGluZVRvKHRvcExlZnRQdC54LCB0b3BMZWZ0UHQueSk7XG4gICAgICB9XG4gICAgICBwYXRoLmFyYyhcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgYXhpc091dGVyUmFkaXVzLFxuICAgICAgICBNYXRoLmF0YW4yKHNpZGVJbnRlcnNlY3Rpb25ZLCBsZWZ0KSArIHBvaW50Um90YXRpb24sXG4gICAgICAgIE1hdGguYXRhbjIodG9wLCAtdG9wSW50ZXJzZWN0aW9uWCkgKyBwb2ludFJvdGF0aW9uLFxuICAgICAgICBmYWxzZVxuICAgICAgKTtcbiAgICAgIGlmICghaXNFcXVhbCh0b3BJbnRlcnNlY3Rpb25YLCAwKSkge1xuICAgICAgICBjb25zdCB0b3BSaWdodEJldmVsUHQgPSByb3RhdGUyKHRvcEludGVyc2VjdGlvblgsIHRvcCk7XG4gICAgICAgIHBhdGgubGluZVRvKHRvcFJpZ2h0QmV2ZWxQdC54LCB0b3BSaWdodEJldmVsUHQueSk7XG4gICAgICB9XG4gICAgICBwYXRoLmFyYyhcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgYXhpc091dGVyUmFkaXVzLFxuICAgICAgICBNYXRoLmF0YW4yKHRvcCwgdG9wSW50ZXJzZWN0aW9uWCkgKyBwb2ludFJvdGF0aW9uLFxuICAgICAgICBNYXRoLmF0YW4yKHNpZGVJbnRlcnNlY3Rpb25ZLCByaWdodCkgKyBwb2ludFJvdGF0aW9uLFxuICAgICAgICBmYWxzZVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdG9wTGVmdFB0ID0gcm90YXRlMihsZWZ0LCB0b3ApO1xuICAgICAgY29uc3QgdG9wUmlnaHRQdCA9IHJvdGF0ZTIocmlnaHQsIHRvcCk7XG4gICAgICBwYXRoLmxpbmVUbyh0b3BMZWZ0UHQueCwgdG9wTGVmdFB0LnkpO1xuICAgICAgcGF0aC5saW5lVG8odG9wUmlnaHRQdC54LCB0b3BSaWdodFB0LnkpO1xuICAgIH1cbiAgICBjb25zdCBib3R0b21SaWdodFB0ID0gcm90YXRlMihyaWdodCwgYm90dG9tKTtcbiAgICBwYXRoLmxpbmVUbyhib3R0b21SaWdodFB0LngsIGJvdHRvbVJpZ2h0UHQueSk7XG4gICAgaWYgKHNob3VsZENvbm5lY3RCb3R0b21DaXJjbGUpIHtcbiAgICAgIHBhdGguYXJjKFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICBpbm5lclJhZGl1cyxcbiAgICAgICAgbm9ybWFsaXplQW5nbGUzNjAoc2lkZVJvdGF0aW9uIC0gTWF0aC5QSSAvIDIpICsgcG9pbnRSb3RhdGlvbixcbiAgICAgICAgbm9ybWFsaXplQW5nbGUzNjAoLXNpZGVSb3RhdGlvbiAtIE1hdGguUEkgLyAyKSArIHBvaW50Um90YXRpb24sXG4gICAgICAgIHRydWVcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJvdGF0ZWRCb3R0b21MZWZ0UHQgPSByb3RhdGUyKGxlZnQsIGJvdHRvbSk7XG4gICAgICBwYXRoLmxpbmVUbyhyb3RhdGVkQm90dG9tTGVmdFB0LngsIHJvdGF0ZWRCb3R0b21MZWZ0UHQueSk7XG4gICAgfVxuICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gIH1cbn07XG5SYWRpYWxDb2x1bW5TaGFwZS5jbGFzc05hbWUgPSBcIlJhZGlhbENvbHVtblNoYXBlXCI7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgUmFkaWFsQ29sdW1uU2hhcGUucHJvdG90eXBlLCBcImlzQmV2ZWxlZFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBSYWRpYWxDb2x1bW5TaGFwZS5wcm90b3R5cGUsIFwiY29sdW1uV2lkdGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgUmFkaWFsQ29sdW1uU2hhcGUucHJvdG90eXBlLCBcInN0YXJ0QW5nbGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgUmFkaWFsQ29sdW1uU2hhcGUucHJvdG90eXBlLCBcImVuZEFuZ2xlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFJhZGlhbENvbHVtblNoYXBlLnByb3RvdHlwZSwgXCJvdXRlclJhZGl1c1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBSYWRpYWxDb2x1bW5TaGFwZS5wcm90b3R5cGUsIFwiaW5uZXJSYWRpdXNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgUmFkaWFsQ29sdW1uU2hhcGUucHJvdG90eXBlLCBcImF4aXNJbm5lclJhZGl1c1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBSYWRpYWxDb2x1bW5TaGFwZS5wcm90b3R5cGUsIFwiYXhpc091dGVyUmFkaXVzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFJhZGlhbENvbHVtblNoYXBlLnByb3RvdHlwZSwgXCJpc1JhZGl1c0F4aXNSZXZlcnNlZFwiLCAyKTtcbmZ1bmN0aW9uIGdldFJhZGlhbENvbHVtbldpZHRoKHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBheGlzT3V0ZXJSYWRpdXMsIGNvbHVtbldpZHRoUmF0aW8sIG1heENvbHVtbldpZHRoUmF0aW8pIHtcbiAgY29uc3Qgcm90YXRpb24gPSBhbmdsZUJldHdlZW4oc3RhcnRBbmdsZSwgZW5kQW5nbGUpO1xuICBjb25zdCBwYWQyID0gcm90YXRpb24gKiAoMSAtIGNvbHVtbldpZHRoUmF0aW8pIC8gMjtcbiAgc3RhcnRBbmdsZSArPSBwYWQyO1xuICBlbmRBbmdsZSAtPSBwYWQyO1xuICBpZiAocm90YXRpb24gPCAxZS0zKSB7XG4gICAgcmV0dXJuIDIgKiBheGlzT3V0ZXJSYWRpdXMgKiBtYXhDb2x1bW5XaWR0aFJhdGlvO1xuICB9XG4gIGlmIChyb3RhdGlvbiA+PSAyICogTWF0aC5QSSkge1xuICAgIGNvbnN0IG1pZEFuZ2xlID0gc3RhcnRBbmdsZSArIHJvdGF0aW9uIC8gMjtcbiAgICBzdGFydEFuZ2xlID0gbWlkQW5nbGUgLSBNYXRoLlBJO1xuICAgIGVuZEFuZ2xlID0gbWlkQW5nbGUgKyBNYXRoLlBJO1xuICB9XG4gIGNvbnN0IHN0YXJ0WCA9IGF4aXNPdXRlclJhZGl1cyAqIE1hdGguY29zKHN0YXJ0QW5nbGUpO1xuICBjb25zdCBzdGFydFkgPSBheGlzT3V0ZXJSYWRpdXMgKiBNYXRoLnNpbihzdGFydEFuZ2xlKTtcbiAgY29uc3QgZW5kWCA9IGF4aXNPdXRlclJhZGl1cyAqIE1hdGguY29zKGVuZEFuZ2xlKTtcbiAgY29uc3QgZW5kWSA9IGF4aXNPdXRlclJhZGl1cyAqIE1hdGguc2luKGVuZEFuZ2xlKTtcbiAgY29uc3QgY29sV2lkdGggPSBNYXRoLmZsb29yKE1hdGguc3FydCgoc3RhcnRYIC0gZW5kWCkgKiogMiArIChzdGFydFkgLSBlbmRZKSAqKiAyKSk7XG4gIGNvbnN0IG1heFdpZHRoID0gMiAqIGF4aXNPdXRlclJhZGl1cyAqIG1heENvbHVtbldpZHRoUmF0aW87XG4gIHJldHVybiBNYXRoLm1heCgxLCBNYXRoLm1pbihtYXhXaWR0aCwgY29sV2lkdGgpKTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvc2hhcGUvc3ZnUGF0aC50c1xudmFyIFN2Z1BhdGggPSBjbGFzcyBleHRlbmRzIFBhdGgge1xuICBjb25zdHJ1Y3RvcihkID0gXCJcIikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy54ID0gMDtcbiAgICB0aGlzLnkgPSAwO1xuICAgIHRoaXMuY29tbWFuZHMgPSBbXTtcbiAgICB0aGlzLl9kID0gXCJcIjtcbiAgICB0aGlzLmQgPSBkO1xuICB9XG4gIGdldCBkKCkge1xuICAgIHJldHVybiB0aGlzLl9kO1xuICB9XG4gIHNldCBkKGQpIHtcbiAgICBpZiAoZCA9PT0gdGhpcy5fZClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9kID0gZDtcbiAgICB0aGlzLmNvbW1hbmRzLmxlbmd0aCA9IDA7XG4gICAgZm9yIChjb25zdCBbXywgY29tbWFuZCwgcGFyYW1zU3RyaW5nXSBvZiBkLm1hdGNoQWxsKC8oW0EtWl0pKFswLTkuIF0qKS9nKSkge1xuICAgICAgY29uc3QgcGFyYW1zID0gcGFyYW1zU3RyaW5nLnNwbGl0KC9cXHMrL2cpLm1hcChOdW1iZXIpO1xuICAgICAgdGhpcy5jb21tYW5kcy5wdXNoKFtjb21tYW5kLCBwYXJhbXNdKTtcbiAgICB9XG4gICAgdGhpcy5jaGVja1BhdGhEaXJ0eSgpO1xuICB9XG4gIHVwZGF0ZVBhdGgoKSB7XG4gICAgY29uc3QgeyBwYXRoLCB4LCB5IH0gPSB0aGlzO1xuICAgIHBhdGguY2xlYXIoKTtcbiAgICBsZXQgbGFzdFggPSB4O1xuICAgIGxldCBsYXN0WSA9IHk7XG4gICAgZm9yIChjb25zdCBbY29tbWFuZCwgcGFyYW1zXSBvZiB0aGlzLmNvbW1hbmRzKSB7XG4gICAgICBzd2l0Y2ggKGNvbW1hbmQpIHtcbiAgICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgICBwYXRoLm1vdmVUbyh4ICsgcGFyYW1zWzBdLCB5ICsgcGFyYW1zWzFdKTtcbiAgICAgICAgICBsYXN0WCA9IHggKyBwYXJhbXNbMF07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJDXCI6XG4gICAgICAgICAgcGF0aC5jdWJpY0N1cnZlVG8oXG4gICAgICAgICAgICB4ICsgcGFyYW1zWzBdLFxuICAgICAgICAgICAgeSArIHBhcmFtc1sxXSxcbiAgICAgICAgICAgIHggKyBwYXJhbXNbMl0sXG4gICAgICAgICAgICB5ICsgcGFyYW1zWzNdLFxuICAgICAgICAgICAgeCArIHBhcmFtc1s0XSxcbiAgICAgICAgICAgIHkgKyBwYXJhbXNbNV1cbiAgICAgICAgICApO1xuICAgICAgICAgIGxhc3RYID0geCArIHBhcmFtc1s0XTtcbiAgICAgICAgICBsYXN0WSA9IHkgKyBwYXJhbXNbNV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJIXCI6XG4gICAgICAgICAgcGF0aC5saW5lVG8oeCArIHBhcmFtc1swXSwgbGFzdFkpO1xuICAgICAgICAgIGxhc3RYID0geSArIHBhcmFtc1swXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkxcIjpcbiAgICAgICAgICBwYXRoLmxpbmVUbyh4ICsgcGFyYW1zWzBdLCB5ICsgcGFyYW1zWzFdKTtcbiAgICAgICAgICBsYXN0WCA9IHggKyBwYXJhbXNbMF07XG4gICAgICAgICAgbGFzdFkgPSB5ICsgcGFyYW1zWzFdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiVlwiOlxuICAgICAgICAgIHBhdGgubGluZVRvKGxhc3RYLCB5ICsgcGFyYW1zWzBdKTtcbiAgICAgICAgICBsYXN0WSA9IHkgKyBwYXJhbXNbMF07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJaXCI6XG4gICAgICAgICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCB0cmFuc2xhdGUgY29tbWFuZCAnJHtjb21tYW5kfScgd2l0aCAnJHtwYXJhbXMuam9pbihcIiBcIil9J2ApO1xuICAgICAgfVxuICAgIH1cbiAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFN2Z1BhdGgucHJvdG90eXBlLCBcInhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgU3ZnUGF0aC5wcm90b3R5cGUsIFwieVwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbWFya2VyL2Fycm93VXAudHNcbnZhciBfQXJyb3dVcCA9IGNsYXNzIF9BcnJvd1VwIGV4dGVuZHMgTWFya2VyIHtcbiAgdXBkYXRlUGF0aCgpIHtcbiAgICBjb25zdCBzID0gdGhpcy5zaXplIC8gMjtcbiAgICBzdXBlci5hcHBseVBhdGgocywgX0Fycm93VXAubW92ZXMpO1xuICB9XG59O1xuX0Fycm93VXAuY2xhc3NOYW1lID0gXCJBcnJvd1VwXCI7XG5fQXJyb3dVcC5tb3ZlcyA9IFtcbiAgeyB4OiAwLCB5OiAwLCB0OiBcIm1vdmVcIiB9LFxuICB7IHg6IDEsIHk6IDEuMiB9LFxuICB7IHg6IC0wLjUsIHk6IDAgfSxcbiAgeyB4OiAwLCB5OiAwLjggfSxcbiAgeyB4OiAtMSwgeTogMCB9LFxuICB7IHg6IDAsIHk6IC0wLjggfSxcbiAgeyB4OiAtMC41LCB5OiAwIH1cbl07XG52YXIgQXJyb3dVcCA9IF9BcnJvd1VwO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9tYXJrZXIvYXJyb3dEb3duLnRzXG52YXIgQXJyb3dEb3duID0gY2xhc3MgZXh0ZW5kcyBNYXJrZXIge1xuICB1cGRhdGVQYXRoKCkge1xuICAgIGNvbnN0IHMgPSB0aGlzLnNpemUgLyAyO1xuICAgIHN1cGVyLmFwcGx5UGF0aChcbiAgICAgIHMsXG4gICAgICBBcnJvd1VwLm1vdmVzLm1hcCgobSkgPT4gKHsgeDogbS54ICogLTEsIHk6IG0ueSAqIC0xIH0pKVxuICAgICk7XG4gIH1cbn07XG5BcnJvd0Rvd24uY2xhc3NOYW1lID0gXCJBcnJvd0Rvd25cIjtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvaW50ZWdyYXRlZC1jaGFydHMtc2NlbmUudHNcbnZhciBtb3Rpb24gPSB7IC4uLmZyb21Ub01vdGlvbl9leHBvcnRzLCAuLi5yZXNldE1vdGlvbl9leHBvcnRzIH07XG52YXIgZ2V0Rm9udCA9IFRleHRVdGlscy50b0ZvbnRTdHJpbmc7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2ludGVncmF0ZWQtY2hhcnRzLXRoZW1lLnRzXG52YXIgaW50ZWdyYXRlZF9jaGFydHNfdGhlbWVfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoaW50ZWdyYXRlZF9jaGFydHNfdGhlbWVfZXhwb3J0cywge1xuICBDQVJURVNJQU5fQVhJU19UWVBFOiAoKSA9PiBDQVJURVNJQU5fQVhJU19UWVBFLFxuICBDQVJURVNJQU5fUE9TSVRJT046ICgpID0+IENBUlRFU0lBTl9QT1NJVElPTixcbiAgQ2hhcnRUaGVtZTogKCkgPT4gQ2hhcnRUaGVtZSxcbiAgREVGQVVMVF9BTk5PVEFUSU9OX0JBQ0tHUk9VTkRfRklMTDogKCkgPT4gREVGQVVMVF9BTk5PVEFUSU9OX0JBQ0tHUk9VTkRfRklMTCxcbiAgREVGQVVMVF9BTk5PVEFUSU9OX0NPTE9SOiAoKSA9PiBERUZBVUxUX0FOTk9UQVRJT05fQ09MT1IsXG4gIERFRkFVTFRfQU5OT1RBVElPTl9IQU5ETEVfRklMTDogKCkgPT4gREVGQVVMVF9BTk5PVEFUSU9OX0hBTkRMRV9GSUxMLFxuICBERUZBVUxUX0FOTk9UQVRJT05fU1RBVElTVElDU19DT0xPUjogKCkgPT4gREVGQVVMVF9BTk5PVEFUSU9OX1NUQVRJU1RJQ1NfQ09MT1IsXG4gIERFRkFVTFRfQU5OT1RBVElPTl9TVEFUSVNUSUNTX0RJVklERVJfU1RST0tFOiAoKSA9PiBERUZBVUxUX0FOTk9UQVRJT05fU1RBVElTVElDU19ESVZJREVSX1NUUk9LRSxcbiAgREVGQVVMVF9BTk5PVEFUSU9OX1NUQVRJU1RJQ1NfRE9XTl9GSUxMOiAoKSA9PiBERUZBVUxUX0FOTk9UQVRJT05fU1RBVElTVElDU19ET1dOX0ZJTEwsXG4gIERFRkFVTFRfQU5OT1RBVElPTl9TVEFUSVNUSUNTX0RPV05fU1RST0tFOiAoKSA9PiBERUZBVUxUX0FOTk9UQVRJT05fU1RBVElTVElDU19ET1dOX1NUUk9LRSxcbiAgREVGQVVMVF9BTk5PVEFUSU9OX1NUQVRJU1RJQ1NfRklMTDogKCkgPT4gREVGQVVMVF9BTk5PVEFUSU9OX1NUQVRJU1RJQ1NfRklMTCxcbiAgREVGQVVMVF9BTk5PVEFUSU9OX1NUQVRJU1RJQ1NfU1RST0tFOiAoKSA9PiBERUZBVUxUX0FOTk9UQVRJT05fU1RBVElTVElDU19TVFJPS0UsXG4gIERFRkFVTFRfQVhJU19HUklEX0NPTE9VUjogKCkgPT4gREVGQVVMVF9BWElTX0dSSURfQ09MT1VSLFxuICBERUZBVUxUX0FYSVNfTElORV9DT0xPVVI6ICgpID0+IERFRkFVTFRfQVhJU19MSU5FX0NPTE9VUixcbiAgREVGQVVMVF9CQUNLR1JPVU5EX0NPTE9VUjogKCkgPT4gREVGQVVMVF9CQUNLR1JPVU5EX0NPTE9VUixcbiAgREVGQVVMVF9DQVBUSU9OX0FMSUdOTUVOVDogKCkgPT4gREVGQVVMVF9DQVBUSU9OX0FMSUdOTUVOVCxcbiAgREVGQVVMVF9DQVBUSU9OX0xBWU9VVF9TVFlMRTogKCkgPT4gREVGQVVMVF9DQVBUSU9OX0xBWU9VVF9TVFlMRSxcbiAgREVGQVVMVF9DT0xPVVJTOiAoKSA9PiBERUZBVUxUX0NPTE9VUlMsXG4gIERFRkFVTFRfQ1JPU1NfTElORVNfQ09MT1VSOiAoKSA9PiBERUZBVUxUX0NST1NTX0xJTkVTX0NPTE9VUixcbiAgREVGQVVMVF9ESVZFUkdJTkdfU0VSSUVTX0NPTE9SX1JBTkdFOiAoKSA9PiBERUZBVUxUX0RJVkVSR0lOR19TRVJJRVNfQ09MT1JfUkFOR0UsXG4gIERFRkFVTFRfRk9OVF9GQU1JTFk6ICgpID0+IERFRkFVTFRfRk9OVF9GQU1JTFksXG4gIERFRkFVTFRfRlVOTkVMX1NFUklFU19DT0xPUl9SQU5HRTogKCkgPT4gREVGQVVMVF9GVU5ORUxfU0VSSUVTX0NPTE9SX1JBTkdFLFxuICBERUZBVUxUX0dBVUdFX1NFUklFU19DT0xPUl9SQU5HRTogKCkgPT4gREVGQVVMVF9HQVVHRV9TRVJJRVNfQ09MT1JfUkFOR0UsXG4gIERFRkFVTFRfR1JJRExJTkVfRU5BQkxFRDogKCkgPT4gREVGQVVMVF9HUklETElORV9FTkFCTEVELFxuICBERUZBVUxUX0hJRVJBUkNIWV9GSUxMUzogKCkgPT4gREVGQVVMVF9ISUVSQVJDSFlfRklMTFMsXG4gIERFRkFVTFRfSElFUkFSQ0hZX1NUUk9LRVM6ICgpID0+IERFRkFVTFRfSElFUkFSQ0hZX1NUUk9LRVMsXG4gIERFRkFVTFRfSU5TSURFX1NFUklFU19MQUJFTF9DT0xPVVI6ICgpID0+IERFRkFVTFRfSU5TSURFX1NFUklFU19MQUJFTF9DT0xPVVIsXG4gIERFRkFVTFRfSU5WRVJURURfTEFCRUxfQ09MT1VSOiAoKSA9PiBERUZBVUxUX0lOVkVSVEVEX0xBQkVMX0NPTE9VUixcbiAgREVGQVVMVF9MQUJFTF9DT0xPVVI6ICgpID0+IERFRkFVTFRfTEFCRUxfQ09MT1VSLFxuICBERUZBVUxUX01VVEVEX0xBQkVMX0NPTE9VUjogKCkgPT4gREVGQVVMVF9NVVRFRF9MQUJFTF9DT0xPVVIsXG4gIERFRkFVTFRfUEFERElORzogKCkgPT4gREVGQVVMVF9QQURESU5HLFxuICBERUZBVUxUX1BPTEFSX1NFUklFU19TVFJPS0U6ICgpID0+IERFRkFVTFRfUE9MQVJfU0VSSUVTX1NUUk9LRSxcbiAgREVGQVVMVF9TSEFET1dfQ09MT1VSOiAoKSA9PiBERUZBVUxUX1NIQURPV19DT0xPVVIsXG4gIERFRkFVTFRfVEVYVEJPWF9DT0xPUjogKCkgPT4gREVGQVVMVF9URVhUQk9YX0NPTE9SLFxuICBERUZBVUxUX1RFWFRCT1hfRklMTDogKCkgPT4gREVGQVVMVF9URVhUQk9YX0ZJTEwsXG4gIERFRkFVTFRfVEVYVEJPWF9TVFJPS0U6ICgpID0+IERFRkFVTFRfVEVYVEJPWF9TVFJPS0UsXG4gIERFRkFVTFRfVEVYVF9BTk5PVEFUSU9OX0NPTE9SOiAoKSA9PiBERUZBVUxUX1RFWFRfQU5OT1RBVElPTl9DT0xPUixcbiAgREVGQVVMVF9UT09MQkFSX1BPU0lUSU9OOiAoKSA9PiBERUZBVUxUX1RPT0xCQVJfUE9TSVRJT04sXG4gIEZPTlRfU0laRTogKCkgPT4gRk9OVF9TSVpFLFxuICBGT05UX1dFSUdIVDogKCkgPT4gRk9OVF9XRUlHSFQyLFxuICBJU19DT01NVU5JVFk6ICgpID0+IElTX0NPTU1VTklUWSxcbiAgSVNfREFSS19USEVNRTogKCkgPT4gSVNfREFSS19USEVNRSxcbiAgSVNfRU5URVJQUklTRTogKCkgPT4gSVNfRU5URVJQUklTRSxcbiAgUEFMRVRURV9BTFRfRE9XTl9GSUxMOiAoKSA9PiBQQUxFVFRFX0FMVF9ET1dOX0ZJTEwsXG4gIFBBTEVUVEVfQUxUX0RPV05fU1RST0tFOiAoKSA9PiBQQUxFVFRFX0FMVF9ET1dOX1NUUk9LRSxcbiAgUEFMRVRURV9BTFRfTkVVVFJBTF9GSUxMOiAoKSA9PiBQQUxFVFRFX0FMVF9ORVVUUkFMX0ZJTEwsXG4gIFBBTEVUVEVfQUxUX05FVVRSQUxfU1RST0tFOiAoKSA9PiBQQUxFVFRFX0FMVF9ORVVUUkFMX1NUUk9LRSxcbiAgUEFMRVRURV9BTFRfVVBfRklMTDogKCkgPT4gUEFMRVRURV9BTFRfVVBfRklMTCxcbiAgUEFMRVRURV9BTFRfVVBfU1RST0tFOiAoKSA9PiBQQUxFVFRFX0FMVF9VUF9TVFJPS0UsXG4gIFBBTEVUVEVfRE9XTl9GSUxMOiAoKSA9PiBQQUxFVFRFX0RPV05fRklMTCxcbiAgUEFMRVRURV9ET1dOX1NUUk9LRTogKCkgPT4gUEFMRVRURV9ET1dOX1NUUk9LRSxcbiAgUEFMRVRURV9ORVVUUkFMX0ZJTEw6ICgpID0+IFBBTEVUVEVfTkVVVFJBTF9GSUxMLFxuICBQQUxFVFRFX05FVVRSQUxfU1RST0tFOiAoKSA9PiBQQUxFVFRFX05FVVRSQUxfU1RST0tFLFxuICBQQUxFVFRFX1VQX0ZJTEw6ICgpID0+IFBBTEVUVEVfVVBfRklMTCxcbiAgUEFMRVRURV9VUF9TVFJPS0U6ICgpID0+IFBBTEVUVEVfVVBfU1RST0tFLFxuICBQT0xBUl9BWElTX1NIQVBFOiAoKSA9PiBQT0xBUl9BWElTX1NIQVBFLFxuICBQT0xBUl9BWElTX1RZUEU6ICgpID0+IFBPTEFSX0FYSVNfVFlQRSxcbiAgZ2V0Q2hhcnRUaGVtZTogKCkgPT4gZ2V0Q2hhcnRUaGVtZSxcbiAgbWFya2VyUGFsZXR0ZUZhY3Rvcnk6ICgpID0+IG1hcmtlclBhbGV0dGVGYWN0b3J5LFxuICBzaW5nbGVTZXJpZXNQYWxldHRlRmFjdG9yeTogKCkgPT4gc2luZ2xlU2VyaWVzUGFsZXR0ZUZhY3RvcnksXG4gIHN3YXBBeGlzQ29uZGl0aW9uOiAoKSA9PiBzd2FwQXhpc0NvbmRpdGlvbixcbiAgdGhlbWVzOiAoKSA9PiB0aGVtZXMyXG59KTtcbnZhciB0aGVtZXMyID0gbWFwVmFsdWVzKFxuICB0aGVtZXMsXG4gICh0aGVtZUZhY3RvcnkpID0+IHRoZW1lRmFjdG9yeT8uKClcbik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NwYXJrbGluZXMtc2NhbGUudHNcbnZhciBzcGFya2xpbmVzX3NjYWxlX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHNwYXJrbGluZXNfc2NhbGVfZXhwb3J0cywge1xuICBCYW5kU2NhbGU6ICgpID0+IEJhbmRTY2FsZSxcbiAgQ29sb3JTY2FsZTogKCkgPT4gQ29sb3JTY2FsZSxcbiAgQ29udGludW91c1NjYWxlOiAoKSA9PiBDb250aW51b3VzU2NhbGUsXG4gIEludmFsaWRhdGluZzogKCkgPT4gSW52YWxpZGF0aW5nLFxuICBMaW5lYXJTY2FsZTogKCkgPT4gTGluZWFyU2NhbGUsXG4gIE9yZGluYWxUaW1lU2NhbGU6ICgpID0+IE9yZGluYWxUaW1lU2NhbGUsXG4gIFRpbWVTY2FsZTogKCkgPT4gVGltZVNjYWxlXG59KTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc3BhcmtsaW5lcy11dGlsLnRzXG52YXIgc3BhcmtsaW5lc191dGlsX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHNwYXJrbGluZXNfdXRpbF9leHBvcnRzLCB7XG4gIENvbG9yOiAoKSA9PiBDb2xvcixcbiAgRGVidWc6ICgpID0+IERlYnVnLFxuICBMb2dnZXI6ICgpID0+IExvZ2dlcixcbiAgUGFkZGluZzogKCkgPT4gUGFkZGluZyxcbiAgVGltZUludGVydmFsOiAoKSA9PiBUaW1lSW50ZXJ2YWwsXG4gIGFuZ2xlQmV0d2VlbjogKCkgPT4gYW5nbGVCZXR3ZWVuLFxuICBhbmdsZURpZmY6ICgpID0+IGFuZ2xlRGlmZixcbiAgYXJjRGlzdGFuY2VTcXVhcmVkOiAoKSA9PiBhcmNEaXN0YW5jZVNxdWFyZWQsXG4gIGFyZUFycmF5TnVtYmVyc0VxdWFsOiAoKSA9PiBhcmVBcnJheU51bWJlcnNFcXVhbCxcbiAgY2hlY2tEYXR1bTogKCkgPT4gY2hlY2tEYXR1bSxcbiAgY2xhbXA6ICgpID0+IGNsYW1wLFxuICBjbGFtcEFycmF5OiAoKSA9PiBjbGFtcEFycmF5LFxuICBjbG9ja3dpc2VBbmdsZTogKCkgPT4gY2xvY2t3aXNlQW5nbGUsXG4gIGNsb2Nrd2lzZUFuZ2xlczogKCkgPT4gY2xvY2t3aXNlQW5nbGVzLFxuICBjb3VudEZyYWN0aW9uRGlnaXRzOiAoKSA9PiBjb3VudEZyYWN0aW9uRGlnaXRzLFxuICBjcmVhdGVJZDogKCkgPT4gY3JlYXRlSWQsXG4gIGRheTogKCkgPT4gZGF5LFxuICBkZWVwQ2xvbmU6ICgpID0+IGRlZXBDbG9uZSxcbiAgZGlzcGxhY2VQb2ludEZyb21WZWN0b3I6ICgpID0+IGRpc3BsYWNlUG9pbnRGcm9tVmVjdG9yLFxuICBleHRlbnQ6ICgpID0+IGV4dGVudCxcbiAgZmluZE1pbk1heDogKCkgPT4gZmluZE1pbk1heCxcbiAgZmluZFJhbmdlRXh0ZW50OiAoKSA9PiBmaW5kUmFuZ2VFeHRlbnQsXG4gIGZvcm1hdE5vcm1hbGl6ZWRQZXJjZW50YWdlOiAoKSA9PiBmb3JtYXROb3JtYWxpemVkUGVyY2VudGFnZSxcbiAgZm9ybWF0UGVyY2VudGFnZTogKCkgPT4gZm9ybWF0UGVyY2VudGFnZSxcbiAgZnJpZGF5OiAoKSA9PiBmcmlkYXksXG4gIGdlbmVyYXRlVVVJRDogKCkgPT4gZ2VuZXJhdGVVVUlELFxuICBnZXRBdHRyaWJ1dGU6ICgpID0+IGdldEF0dHJpYnV0ZSxcbiAgaG91cjogKCkgPT4gaG91cixcbiAgaW50ZXJwb2xhdGVDb2xvcjogKCkgPT4gaW50ZXJwb2xhdGVDb2xvcixcbiAgaW50ZXJwb2xhdGVOdW1iZXI6ICgpID0+IGludGVycG9sYXRlTnVtYmVyLFxuICBpc0JldHdlZW5BbmdsZXM6ICgpID0+IGlzQmV0d2VlbkFuZ2xlcyxcbiAgaXNDb250aW51b3VzOiAoKSA9PiBpc0NvbnRpbnVvdXMsXG4gIGlzRGF0ZTogKCkgPT4gaXNWYWxpZERhdGUsXG4gIGlzRGVuc2VJbnRlcnZhbDogKCkgPT4gaXNEZW5zZUludGVydmFsLFxuICBpc0VxdWFsOiAoKSA9PiBpc0VxdWFsLFxuICBpc05lZ2F0aXZlOiAoKSA9PiBpc05lZ2F0aXZlLFxuICBpc051bWJlcjogKCkgPT4gaXNGaW5pdGVOdW1iZXIsXG4gIGlzTnVtYmVyRXF1YWw6ICgpID0+IGlzRXF1YWwsXG4gIGlzTnVtYmVyT2JqZWN0OiAoKSA9PiBpc051bWJlck9iamVjdCxcbiAgaXNTdHJpbmc6ICgpID0+IGlzU3RyaW5nLFxuICBpc1N0cmluZ09iamVjdDogKCkgPT4gaXNTdHJpbmdPYmplY3QsXG4gIGpzb25BcHBseTogKCkgPT4ganNvbkFwcGx5LFxuICBqc29uRGlmZjogKCkgPT4ganNvbkRpZmYsXG4gIGpzb25XYWxrOiAoKSA9PiBqc29uV2FsayxcbiAgbGluZURpc3RhbmNlU3F1YXJlZDogKCkgPT4gbGluZURpc3RhbmNlU3F1YXJlZCxcbiAgbWlsbGlzZWNvbmQ6ICgpID0+IG1pbGxpc2Vjb25kLFxuICBtaW51dGU6ICgpID0+IG1pbnV0ZSxcbiAgbW9kOiAoKSA9PiBtb2QsXG4gIG1vbmRheTogKCkgPT4gbW9uZGF5LFxuICBtb250aDogKCkgPT4gbW9udGgsXG4gIG5vcm1hbGlzZWRFeHRlbnRXaXRoTWV0YWRhdGE6ICgpID0+IG5vcm1hbGlzZWRFeHRlbnRXaXRoTWV0YWRhdGEsXG4gIG5vcm1hbGl6ZUFuZ2xlMTgwOiAoKSA9PiBub3JtYWxpemVBbmdsZTE4MCxcbiAgbm9ybWFsaXplQW5nbGUzNjA6ICgpID0+IG5vcm1hbGl6ZUFuZ2xlMzYwLFxuICBub3JtYWxpemVBbmdsZTM2MEluY2x1c2l2ZTogKCkgPT4gbm9ybWFsaXplQW5nbGUzNjBJbmNsdXNpdmUsXG4gIHJhbmdlOiAoKSA9PiByYW5nZSxcbiAgcmVzZXRJZHM6ICgpID0+IHJlc2V0SWRzLFxuICByb3VuZDogKCkgPT4gcm91bmQsXG4gIHNhbml0aXplSHRtbDogKCkgPT4gc2FuaXRpemVIdG1sLFxuICBzYXR1cmRheTogKCkgPT4gc2F0dXJkYXksXG4gIHNlY29uZDogKCkgPT4gc2Vjb25kLFxuICBzZXRBdHRyaWJ1dGU6ICgpID0+IHNldEF0dHJpYnV0ZSxcbiAgc2V0QXR0cmlidXRlczogKCkgPT4gc2V0QXR0cmlidXRlcyxcbiAgc2V0RWxlbWVudFN0eWxlOiAoKSA9PiBzZXRFbGVtZW50U3R5bGUsXG4gIHNoYWxsb3dDbG9uZTogKCkgPT4gc2hhbGxvd0Nsb25lLFxuICBzdW5kYXk6ICgpID0+IHN1bmRheSxcbiAgdGh1cnNkYXk6ICgpID0+IHRodXJzZGF5LFxuICB0aWNrRm9ybWF0OiAoKSA9PiB0aWNrRm9ybWF0LFxuICB0aWNrU3RlcDogKCkgPT4gdGlja1N0ZXAsXG4gIHRpY2tzOiAoKSA9PiBjcmVhdGVUaWNrcyxcbiAgdG9EZWdyZWVzOiAoKSA9PiB0b0RlZ3JlZXMsXG4gIHRvRml4ZWQ6ICgpID0+IHRvRml4ZWQsXG4gIHRvUmFkaWFuczogKCkgPT4gdG9SYWRpYW5zLFxuICB0cmFuc2Zvcm1JbnRlZ3JhdGVkQ2F0ZWdvcnlWYWx1ZTogKCkgPT4gdHJhbnNmb3JtSW50ZWdyYXRlZENhdGVnb3J5VmFsdWUsXG4gIHR1ZXNkYXk6ICgpID0+IHR1ZXNkYXksXG4gIHV0Y0RheTogKCkgPT4gdXRjRGF5LFxuICB1dGNIb3VyOiAoKSA9PiB1dGNIb3VyLFxuICB1dGNNaW51dGU6ICgpID0+IHV0Y01pbnV0ZSxcbiAgdXRjTW9udGg6ICgpID0+IHV0Y01vbnRoLFxuICB1dGNZZWFyOiAoKSA9PiB1dGNZZWFyLFxuICB3ZWRuZXNkYXk6ICgpID0+IHdlZG5lc2RheSxcbiAgeWVhcjogKCkgPT4geWVhclxufSk7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL21vZHVsZS1zdXBwb3J0LnRzXG52YXIgbW9kdWxlX3N1cHBvcnRfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobW9kdWxlX3N1cHBvcnRfZXhwb3J0cywge1xuICBBTkQ6ICgpID0+IEFORCxcbiAgQVJSQVk6ICgpID0+IEFSUkFZLFxuICBBUlJBWV9PRjogKCkgPT4gQVJSQVlfT0YsXG4gIEFic3RyYWN0QmFyU2VyaWVzOiAoKSA9PiBBYnN0cmFjdEJhclNlcmllcyxcbiAgQWJzdHJhY3RCYXJTZXJpZXNQcm9wZXJ0aWVzOiAoKSA9PiBBYnN0cmFjdEJhclNlcmllc1Byb3BlcnRpZXMsXG4gIEFjdGlvbk9uU2V0OiAoKSA9PiBBY3Rpb25PblNldCxcbiAgQW5pbWF0aW9uOiAoKSA9PiBBbmltYXRpb24sXG4gIEFuaW1hdGlvbk1hbmFnZXI6ICgpID0+IEFuaW1hdGlvbk1hbmFnZXIsXG4gIEF4aXM6ICgpID0+IEF4aXMsXG4gIEF4aXNJbnRlcnZhbDogKCkgPT4gQXhpc0ludGVydmFsLFxuICBBeGlzTGFiZWw6ICgpID0+IEF4aXNMYWJlbCxcbiAgQXhpc1RpY2s6ICgpID0+IEF4aXNUaWNrLFxuICBBeGlzVGlja3M6ICgpID0+IEF4aXNUaWNrcyxcbiAgQk9PTEVBTjogKCkgPT4gQk9PTEVBTixcbiAgQk9PTEVBTl9BUlJBWTogKCkgPT4gQk9PTEVBTl9BUlJBWSxcbiAgQmFja2dyb3VuZDogKCkgPT4gQmFja2dyb3VuZCxcbiAgQmFja2dyb3VuZE1vZHVsZTogKCkgPT4gQmFja2dyb3VuZE1vZHVsZSxcbiAgQmFzZU1vZHVsZUluc3RhbmNlOiAoKSA9PiBCYXNlTW9kdWxlSW5zdGFuY2UsXG4gIEJhc2VQcm9wZXJ0aWVzOiAoKSA9PiBCYXNlUHJvcGVydGllcyxcbiAgQ09MT1JfU1RSSU5HOiAoKSA9PiBDT0xPUl9TVFJJTkcsXG4gIENPTE9SX1NUUklOR19BUlJBWTogKCkgPT4gQ09MT1JfU1RSSU5HX0FSUkFZLFxuICBDYWNoZWRUZXh0TWVhc3VyZXI6ICgpID0+IENhY2hlZFRleHRNZWFzdXJlcixcbiAgQ2FjaGVkVGV4dE1lYXN1cmVyUG9vbDogKCkgPT4gQ2FjaGVkVGV4dE1lYXN1cmVyUG9vbCxcbiAgQ2FydGVzaWFuQXhpczogKCkgPT4gQ2FydGVzaWFuQXhpcyxcbiAgQ2FydGVzaWFuU2VyaWVzOiAoKSA9PiBDYXJ0ZXNpYW5TZXJpZXMsXG4gIENhcnRlc2lhblNlcmllc05vZGVFdmVudDogKCkgPT4gQ2FydGVzaWFuU2VyaWVzTm9kZUV2ZW50LFxuICBDYXJ0ZXNpYW5TZXJpZXNQcm9wZXJ0aWVzOiAoKSA9PiBDYXJ0ZXNpYW5TZXJpZXNQcm9wZXJ0aWVzLFxuICBDYXRlZ29yeUF4aXM6ICgpID0+IENhdGVnb3J5QXhpcyxcbiAgQ2hhcnRBeGlzRGlyZWN0aW9uOiAoKSA9PiBDaGFydEF4aXNEaXJlY3Rpb24sXG4gIENoYXJ0RXZlbnRNYW5hZ2VyOiAoKSA9PiBDaGFydEV2ZW50TWFuYWdlcixcbiAgQ2hhcnRPcHRpb25zOiAoKSA9PiBDaGFydE9wdGlvbnMsXG4gIENoYXJ0VXBkYXRlVHlwZTogKCkgPT4gQ2hhcnRVcGRhdGVUeXBlLFxuICBDb250ZXh0TWVudVJlZ2lzdHJ5OiAoKSA9PiBDb250ZXh0TWVudVJlZ2lzdHJ5LFxuICBDdXJzb3I6ICgpID0+IEN1cnNvcixcbiAgQ3Vyc29yTWFuYWdlcjogKCkgPT4gQ3Vyc29yTWFuYWdlcixcbiAgREFURTogKCkgPT4gREFURSxcbiAgREFURV9BUlJBWTogKCkgPT4gREFURV9BUlJBWSxcbiAgREFURV9PUl9EQVRFVElNRV9NUzogKCkgPT4gREFURV9PUl9EQVRFVElNRV9NUyxcbiAgREVGQVVMVF9DQVJURVNJQU5fRElSRUNUSU9OX0tFWVM6ICgpID0+IERFRkFVTFRfQ0FSVEVTSUFOX0RJUkVDVElPTl9LRVlTLFxuICBERUZBVUxUX0NBUlRFU0lBTl9ESVJFQ1RJT05fTkFNRVM6ICgpID0+IERFRkFVTFRfQ0FSVEVTSUFOX0RJUkVDVElPTl9OQU1FUyxcbiAgREVGQVVMVF9UT09MVElQX0NMQVNTOiAoKSA9PiBERUZBVUxUX1RPT0xUSVBfQ0xBU1MsXG4gIERFRkFVTFRfVE9PTFRJUF9EQVJLX0NMQVNTOiAoKSA9PiBERUZBVUxUX1RPT0xUSVBfREFSS19DTEFTUyxcbiAgREVHUkVFOiAoKSA9PiBERUdSRUUsXG4gIERJUkVDVElPTjogKCkgPT4gRElSRUNUSU9OLFxuICBET01NYW5hZ2VyOiAoKSA9PiBET01NYW5hZ2VyLFxuICBEUkFHX0lOVEVSQUNUSU9OX1RZUEVTOiAoKSA9PiBEUkFHX0lOVEVSQUNUSU9OX1RZUEVTLFxuICBEYXRhQ29udHJvbGxlcjogKCkgPT4gRGF0YUNvbnRyb2xsZXIsXG4gIERhdGFNb2RlbDogKCkgPT4gRGF0YU1vZGVsLFxuICBEYXRhTW9kZWxTZXJpZXM6ICgpID0+IERhdGFNb2RlbFNlcmllcyxcbiAgRGF0YVNlcnZpY2U6ICgpID0+IERhdGFTZXJ2aWNlLFxuICBEZWZhdWx0OiAoKSA9PiBEZWZhdWx0LFxuICBEZXByZWNhdGVkOiAoKSA9PiBEZXByZWNhdGVkLFxuICBEZXByZWNhdGVkQW5kUmVuYW1lZFRvOiAoKSA9PiBEZXByZWNhdGVkQW5kUmVuYW1lZFRvLFxuICBFTVBUWV9UT09MVElQX0NPTlRFTlQ6ICgpID0+IEVNUFRZX1RPT0xUSVBfQ09OVEVOVCxcbiAgRk9OVF9TVFlMRTogKCkgPT4gRk9OVF9TVFlMRSxcbiAgRk9OVF9XRUlHSFQ6ICgpID0+IEZPTlRfV0VJR0hULFxuICBGVU5DVElPTjogKCkgPT4gRlVOQ1RJT04sXG4gIEdSRUFURVJfVEhBTjogKCkgPT4gR1JFQVRFUl9USEFOLFxuICBHZXN0dXJlRGV0ZWN0b3I6ICgpID0+IEdlc3R1cmVEZXRlY3RvcixcbiAgR3JvdXBlZENhdGVnb3J5QXhpczogKCkgPT4gR3JvdXBlZENhdGVnb3J5QXhpcyxcbiAgSGllcmFyY2h5Tm9kZTogKCkgPT4gSGllcmFyY2h5Tm9kZSxcbiAgSGllcmFyY2h5U2VyaWVzOiAoKSA9PiBIaWVyYXJjaHlTZXJpZXMsXG4gIEhpZXJhcmNoeVNlcmllc1Byb3BlcnRpZXM6ICgpID0+IEhpZXJhcmNoeVNlcmllc1Byb3BlcnRpZXMsXG4gIEhpZ2hsaWdodE1hbmFnZXI6ICgpID0+IEhpZ2hsaWdodE1hbmFnZXIsXG4gIEhpZ2hsaWdodFByb3BlcnRpZXM6ICgpID0+IEhpZ2hsaWdodFByb3BlcnRpZXMsXG4gIEhpZ2hsaWdodFN0eWxlOiAoKSA9PiBIaWdobGlnaHRTdHlsZSxcbiAgSU5URVJBQ1RJT05fUkFOR0U6ICgpID0+IElOVEVSQUNUSU9OX1JBTkdFLFxuICBJTlRFUlBPTEFUSU9OX1NURVBfUE9TSVRJT046ICgpID0+IElOVEVSUE9MQVRJT05fU1RFUF9QT1NJVElPTixcbiAgSU5URVJQT0xBVElPTl9UWVBFOiAoKSA9PiBJTlRFUlBPTEFUSU9OX1RZUEUsXG4gIEludGVyYWN0aW9uTWFuYWdlcjogKCkgPT4gSW50ZXJhY3Rpb25NYW5hZ2VyLFxuICBJbnRlcmFjdGlvblN0YXRlOiAoKSA9PiBJbnRlcmFjdGlvblN0YXRlLFxuICBJbnRlcnBvbGF0aW9uUHJvcGVydGllczogKCkgPT4gSW50ZXJwb2xhdGlvblByb3BlcnRpZXMsXG4gIEtleU5hdk1hbmFnZXI6ICgpID0+IEtleU5hdk1hbmFnZXIsXG4gIExBQkVMX1BMQUNFTUVOVDogKCkgPT4gTEFCRUxfUExBQ0VNRU5ULFxuICBMQVJHRVNUX0tFWV9JTlRFUlZBTDogKCkgPT4gTEFSR0VTVF9LRVlfSU5URVJWQUwsXG4gIExFU1NfVEhBTjogKCkgPT4gTEVTU19USEFOLFxuICBMSU5FX0NBUDogKCkgPT4gTElORV9DQVAsXG4gIExJTkVfREFTSDogKCkgPT4gTElORV9EQVNILFxuICBMSU5FX0pPSU46ICgpID0+IExJTkVfSk9JTixcbiAgTElORV9TVFlMRTogKCkgPT4gTElORV9TVFlMRSxcbiAgTGF5b3V0RWxlbWVudDogKCkgPT4gTGF5b3V0RWxlbWVudCxcbiAgTGF5b3V0TWFuYWdlcjogKCkgPT4gTGF5b3V0TWFuYWdlcixcbiAgTG9uTGF0QkJveDogKCkgPT4gTG9uTGF0QkJveCxcbiAgTUFSS0VSX1NIQVBFOiAoKSA9PiBNQVJLRVJfU0hBUEUsXG4gIE1BVENISU5HX0NST1NTTElORV9UWVBFOiAoKSA9PiBNQVRDSElOR19DUk9TU0xJTkVfVFlQRSxcbiAgTUFYX1NQQUNJTkc6ICgpID0+IE1BWF9TUEFDSU5HLFxuICBNSU5fU1BBQ0lORzogKCkgPT4gTUlOX1NQQUNJTkcsXG4gIE1lcmNhdG9yU2NhbGU6ICgpID0+IE1lcmNhdG9yU2NhbGUsXG4gIE1vZHVsZVJlZ2lzdHJ5OiAoKSA9PiBNb2R1bGVSZWdpc3RyeSxcbiAgTW90aW9uOiAoKSA9PiBlYXNpbmdfZXhwb3J0cyxcbiAgTkFOOiAoKSA9PiBOQU4sXG4gIE5PREVfVVBEQVRFX1NUQVRFX1RPX1BIQVNFX01BUFBJTkc6ICgpID0+IE5PREVfVVBEQVRFX1NUQVRFX1RPX1BIQVNFX01BUFBJTkcsXG4gIE5VTUJFUjogKCkgPT4gTlVNQkVSLFxuICBOVU1CRVJfQVJSQVk6ICgpID0+IE5VTUJFUl9BUlJBWSxcbiAgTlVNQkVSX09SX05BTjogKCkgPT4gTlVNQkVSX09SX05BTixcbiAgTmF2aWdhdG9yOiAoKSA9PiBOYXZpZ2F0b3IsXG4gIE5hdmlnYXRvck1vZHVsZTogKCkgPT4gTmF2aWdhdG9yTW9kdWxlLFxuICBOb2RlUmVnaW9uQkJveFByb3ZpZGVyOiAoKSA9PiBOb2RlUmVnaW9uQkJveFByb3ZpZGVyLFxuICBPQkpFQ1Q6ICgpID0+IE9CSkVDVCxcbiAgT0JKRUNUX0FSUkFZOiAoKSA9PiBPQkpFQ1RfQVJSQVksXG4gIE9SOiAoKSA9PiBPUixcbiAgT1ZFUkZMT1dfU1RSQVRFR1k6ICgpID0+IE9WRVJGTE9XX1NUUkFURUdZLFxuICBPYnNlcnZlQ2hhbmdlczogKCkgPT4gT2JzZXJ2ZUNoYW5nZXMsXG4gIFBIQVNFX01FVEFEQVRBOiAoKSA9PiBQSEFTRV9NRVRBREFUQSxcbiAgUEhBU0VfT1JERVI6ICgpID0+IFBIQVNFX09SREVSLFxuICBQTEFDRU1FTlQ6ICgpID0+IFBMQUNFTUVOVCxcbiAgUExBSU5fT0JKRUNUOiAoKSA9PiBQTEFJTl9PQkpFQ1QsXG4gIFBPSU5URVJfSU5URVJBQ1RJT05fVFlQRVM6ICgpID0+IFBPSU5URVJfSU5URVJBQ1RJT05fVFlQRVMsXG4gIFBPU0lUSU9OOiAoKSA9PiBQT1NJVElPTixcbiAgUE9TSVRJT05fVE9QX0NPT1JESU5BVEVTOiAoKSA9PiBQT1NJVElPTl9UT1BfQ09PUkRJTkFURVMsXG4gIFBPU0lUSVZFX05VTUJFUjogKCkgPT4gUE9TSVRJVkVfTlVNQkVSLFxuICBQb2xhckF4aXM6ICgpID0+IFBvbGFyQXhpcyxcbiAgUG9sYXJTZXJpZXM6ICgpID0+IFBvbGFyU2VyaWVzLFxuICBQcm9wZXJ0aWVzQXJyYXk6ICgpID0+IFByb3BlcnRpZXNBcnJheSxcbiAgUHJveHlPbldyaXRlOiAoKSA9PiBQcm94eU9uV3JpdGUsXG4gIFByb3h5UHJvcGVydHk6ICgpID0+IFByb3h5UHJvcGVydHksXG4gIFByb3h5UHJvcGVydHlPbldyaXRlOiAoKSA9PiBQcm94eVByb3BlcnR5T25Xcml0ZSxcbiAgUVVJQ0tfVFJBTlNJVElPTjogKCkgPT4gUVVJQ0tfVFJBTlNJVElPTixcbiAgUkFUSU86ICgpID0+IFJBVElPLFxuICBSRUFMX05VTUJFUjogKCkgPT4gUkVBTF9OVU1CRVIsXG4gIFJFR0lPTlM6ICgpID0+IFJFR0lPTlMsXG4gIFJlZ2lvbk1hbmFnZXI6ICgpID0+IFJlZ2lvbk1hbmFnZXIsXG4gIFJlcGVhdFR5cGU6ICgpID0+IFJlcGVhdFR5cGUsXG4gIFNLSVBfSlNfQlVJTFRJTlM6ICgpID0+IFNLSVBfSlNfQlVJTFRJTlMsXG4gIFNNQUxMRVNUX0tFWV9JTlRFUlZBTDogKCkgPT4gU01BTExFU1RfS0VZX0lOVEVSVkFMLFxuICBTT1JUX0RPTUFJTl9HUk9VUFM6ICgpID0+IFNPUlRfRE9NQUlOX0dST1VQUyxcbiAgU1RSSU5HOiAoKSA9PiBTVFJJTkcsXG4gIFNUUklOR19BUlJBWTogKCkgPT4gU1RSSU5HX0FSUkFZLFxuICBTZXJpZXM6ICgpID0+IFNlcmllcyxcbiAgU2VyaWVzR3JvdXBpbmdDaGFuZ2VkRXZlbnQ6ICgpID0+IFNlcmllc0dyb3VwaW5nQ2hhbmdlZEV2ZW50LFxuICBTZXJpZXNJdGVtSGlnaGxpZ2h0U3R5bGU6ICgpID0+IFNlcmllc0l0ZW1IaWdobGlnaHRTdHlsZSxcbiAgU2VyaWVzTWFya2VyOiAoKSA9PiBTZXJpZXNNYXJrZXIsXG4gIFNlcmllc05vZGVFdmVudDogKCkgPT4gU2VyaWVzTm9kZUV2ZW50LFxuICBTZXJpZXNOb2RlUGlja01vZGU6ICgpID0+IFNlcmllc05vZGVQaWNrTW9kZSxcbiAgU2VyaWVzUHJvcGVydGllczogKCkgPT4gU2VyaWVzUHJvcGVydGllcyxcbiAgU2VyaWVzVG9vbHRpcDogKCkgPT4gU2VyaWVzVG9vbHRpcCxcbiAgU2ltcGxlUmVnaW9uQkJveFByb3ZpZGVyOiAoKSA9PiBTaW1wbGVSZWdpb25CQm94UHJvdmlkZXIsXG4gIFNpbXBsZVRleHRNZWFzdXJlcjogKCkgPT4gU2ltcGxlVGV4dE1lYXN1cmVyLFxuICBTdGF0ZU1hY2hpbmU6ICgpID0+IFN0YXRlTWFjaGluZSxcbiAgVEVYVF9BTElHTjogKCkgPT4gVEVYVF9BTElHTixcbiAgVEVYVF9XUkFQOiAoKSA9PiBURVhUX1dSQVAsXG4gIFRJQ0tfSU5URVJWQUw6ICgpID0+IFRJQ0tfSU5URVJWQUwsXG4gIFRPT0xCQVJfQUxJR05NRU5UUzogKCkgPT4gVE9PTEJBUl9BTElHTk1FTlRTLFxuICBUT09MQkFSX0dST1VQUzogKCkgPT4gVE9PTEJBUl9HUk9VUFMsXG4gIFRPT0xCQVJfR1JPVVBfT1JERVJJTkc6ICgpID0+IFRPT0xCQVJfR1JPVVBfT1JERVJJTkcsXG4gIFRPT0xCQVJfUE9TSVRJT05TOiAoKSA9PiBUT09MQkFSX1BPU0lUSU9OUyxcbiAgVGV4dFV0aWxzOiAoKSA9PiBUZXh0VXRpbHMsXG4gIFRleHRXcmFwcGVyOiAoKSA9PiBUZXh0V3JhcHBlcixcbiAgVG9vbGJhck1hbmFnZXI6ICgpID0+IFRvb2xiYXJNYW5hZ2VyLFxuICBUb29sYmFyUG9zaXRpb246ICgpID0+IFRvb2xiYXJQb3NpdGlvbixcbiAgVG9vbHRpcDogKCkgPT4gVG9vbHRpcCxcbiAgVG9vbHRpcE1hbmFnZXI6ICgpID0+IFRvb2x0aXBNYW5hZ2VyLFxuICBUb29sdGlwUG9zaXRpb246ICgpID0+IFRvb2x0aXBQb3NpdGlvbixcbiAgVU5JT046ICgpID0+IFVOSU9OLFxuICBVcGRhdGVTZXJ2aWNlOiAoKSA9PiBVcGRhdGVTZXJ2aWNlLFxuICBWRVJUSUNBTF9BTElHTjogKCkgPT4gVkVSVElDQUxfQUxJR04sXG4gIFZhbGlkYXRlOiAoKSA9PiBWYWxpZGF0ZSxcbiAgVmVjMjogKCkgPT4gVmVjMixcbiAgVmVjNDogKCkgPT4gVmVjNCxcbiAgWkluZGV4TWFwOiAoKSA9PiBaSW5kZXhNYXAsXG4gIFpvb21NYW5hZ2VyOiAoKSA9PiBab29tTWFuYWdlcixcbiAgX19GT1JDRV9NT0RVTEVfREVURUNUSU9OOiAoKSA9PiBfX0ZPUkNFX01PRFVMRV9ERVRFQ1RJT04sXG4gIGFjY3VtdWxhdGVHcm91cDogKCkgPT4gYWNjdW11bGF0ZUdyb3VwLFxuICBhY2N1bXVsYXRlU3RhY2s6ICgpID0+IGFjY3VtdWxhdGVTdGFjayxcbiAgYWNjdW11bGF0ZWRWYWx1ZTogKCkgPT4gYWNjdW11bGF0ZWRWYWx1ZSxcbiAgYWNjdW11bGF0aXZlVmFsdWVQcm9wZXJ0eTogKCkgPT4gYWNjdW11bGF0aXZlVmFsdWVQcm9wZXJ0eSxcbiAgYWRkSGl0VGVzdGVyc1RvUXVhZHRyZWU6ICgpID0+IGFkZEhpdFRlc3RlcnNUb1F1YWR0cmVlLFxuICBhZGp1c3RMYWJlbFBsYWNlbWVudDogKCkgPT4gYWRqdXN0TGFiZWxQbGFjZW1lbnQsXG4gIGFuaW1hdGlvblZhbGlkYXRpb246ICgpID0+IGFuaW1hdGlvblZhbGlkYXRpb24sXG4gIGFyZWE6ICgpID0+IGFyZWEsXG4gIGFycmF5c0VxdWFsOiAoKSA9PiBhcnJheXNFcXVhbCxcbiAgYmFja2ZpbGxQYXRoUG9pbnREYXRhOiAoKSA9PiBiYWNrZmlsbFBhdGhQb2ludERhdGEsXG4gIGJ1aWxkRm9ybWF0dGVyOiAoKSA9PiBidWlsZEZvcm1hdHRlcixcbiAgYnVpbGRSZXNldFBhdGhGbjogKCkgPT4gYnVpbGRSZXNldFBhdGhGbixcbiAgY2FsY3VsYXRlRGVmYXVsdFRpbWVUaWNrRm9ybWF0OiAoKSA9PiBjYWxjdWxhdGVEZWZhdWx0VGltZVRpY2tGb3JtYXQsXG4gIGNhbGN1bGF0ZUxhYmVsQ2hhcnRQYWRkaW5nOiAoKSA9PiBjYWxjdWxhdGVMYWJlbENoYXJ0UGFkZGluZyxcbiAgY2FsY3VsYXRlTGFiZWxUcmFuc2xhdGlvbjogKCkgPT4gY2FsY3VsYXRlTGFiZWxUcmFuc2xhdGlvbixcbiAgY2FsY3VsYXRlUGxhY2VtZW50OiAoKSA9PiBjYWxjdWxhdGVQbGFjZW1lbnQsXG4gIGNoZWNrQ3Jpc3A6ICgpID0+IGNoZWNrQ3Jpc3AsXG4gIGNpcmN1bGFyU2xpY2VBcnJheTogKCkgPT4gY2lyY3VsYXJTbGljZUFycmF5LFxuICBjbGFtcDogKCkgPT4gY2xhbXAsXG4gIGNsYW1wQXJyYXk6ICgpID0+IGNsYW1wQXJyYXksXG4gIGNvbGxhcHNlZFN0YXJ0aW5nQmFyUG9zaXRpb246ICgpID0+IGNvbGxhcHNlZFN0YXJ0aW5nQmFyUG9zaXRpb24sXG4gIGNvbXB1dGVCYXJGb2N1c0JvdW5kczogKCkgPT4gY29tcHV0ZUJhckZvY3VzQm91bmRzLFxuICBjb21wdXRlTWFya2VyRm9jdXNCb3VuZHM6ICgpID0+IGNvbXB1dGVNYXJrZXJGb2N1c0JvdW5kcyxcbiAgY29udmVydFZhbHVlc1RvU2NhbGVCeURlZnM6ICgpID0+IGNvbnZlcnRWYWx1ZXNUb1NjYWxlQnlEZWZzLFxuICBjb3VudEZyYWN0aW9uRGlnaXRzOiAoKSA9PiBjb3VudEZyYWN0aW9uRGlnaXRzLFxuICBjcmVhdGVCdXR0b246ICgpID0+IGNyZWF0ZUJ1dHRvbixcbiAgY3JlYXRlQ2hlY2tib3g6ICgpID0+IGNyZWF0ZUNoZWNrYm94LFxuICBjcmVhdGVEYXR1bUlkOiAoKSA9PiBjcmVhdGVEYXR1bUlkLFxuICBjcmVhdGVEZXByZWNhdGlvbldhcm5pbmc6ICgpID0+IGNyZWF0ZURlcHJlY2F0aW9uV2FybmluZyxcbiAgY3JlYXRlRWxlbWVudDogKCkgPT4gY3JlYXRlRWxlbWVudCxcbiAgY3JlYXRlRWxlbWVudElkOiAoKSA9PiBjcmVhdGVFbGVtZW50SWQsXG4gIGNyZWF0ZUVsZW1lbnROUzogKCkgPT4gY3JlYXRlRWxlbWVudE5TLFxuICBjcmVhdGVJY29uOiAoKSA9PiBjcmVhdGVJY29uLFxuICBjcmVhdGVTZWxlY3Q6ICgpID0+IGNyZWF0ZVNlbGVjdCxcbiAgY3JlYXRlVGV4dEFyZWE6ICgpID0+IGNyZWF0ZVRleHRBcmVhLFxuICBkYXRlVG9OdW1iZXI6ICgpID0+IGRhdGVUb051bWJlcixcbiAgZGVjb25zdHJ1Y3RTZWxlY3Rpb25zT3JOb2RlczogKCkgPT4gZGVjb25zdHJ1Y3RTZWxlY3Rpb25zT3JOb2RlcyxcbiAgZGVlcENsb25lOiAoKSA9PiBkZWVwQ2xvbmUsXG4gIGRlZXBNZXJnZTogKCkgPT4gZGVlcE1lcmdlLFxuICBkZWZhdWx0VGltZVRpY2tGb3JtYXQ6ICgpID0+IGRlZmF1bHRUaW1lVGlja0Zvcm1hdCxcbiAgZGV0ZXJtaW5lUGF0aFN0YXR1czogKCkgPT4gZGV0ZXJtaW5lUGF0aFN0YXR1cyxcbiAgZGlmZjogKCkgPT4gZGlmZixcbiAgZG93bmxvYWRVcmw6ICgpID0+IGRvd25sb2FkVXJsLFxuICBlbnRlcnByaXNlTW9kdWxlOiAoKSA9PiBlbnRlcnByaXNlTW9kdWxlLFxuICBleGNsdWRlc1R5cGU6ICgpID0+IGV4Y2x1ZGVzVHlwZSxcbiAgZXh0ZW50OiAoKSA9PiBleHRlbnQsXG4gIGV4dHJhY3REZWNvcmF0ZWRQcm9wZXJ0aWVzOiAoKSA9PiBleHRyYWN0RGVjb3JhdGVkUHJvcGVydGllcyxcbiAgZmluZE1heFZhbHVlOiAoKSA9PiBmaW5kTWF4VmFsdWUsXG4gIGZpbmRNaW5NYXg6ICgpID0+IGZpbmRNaW5NYXgsXG4gIGZpbmRRdWFkdHJlZU1hdGNoOiAoKSA9PiBmaW5kUXVhZHRyZWVNYXRjaCxcbiAgZmluZFJhbmdlRXh0ZW50OiAoKSA9PiBmaW5kUmFuZ2VFeHRlbnQsXG4gIGZpeE51bWVyaWNFeHRlbnQ6ICgpID0+IGZpeE51bWVyaWNFeHRlbnQsXG4gIGZvY3VzQ3Vyc29yQXRFbmQ6ICgpID0+IGZvY3VzQ3Vyc29yQXRFbmQsXG4gIGZvcm1hdE5vcm1hbGl6ZWRQZXJjZW50YWdlOiAoKSA9PiBmb3JtYXROb3JtYWxpemVkUGVyY2VudGFnZSxcbiAgZm9ybWF0UGVyY2VudGFnZTogKCkgPT4gZm9ybWF0UGVyY2VudGFnZSxcbiAgZm9ybWF0VmFsdWU6ICgpID0+IGZvcm1hdFZhbHVlLFxuICBmcm9tVG9Nb3Rpb246ICgpID0+IGZyb21Ub01vdGlvbixcbiAgZ2V0RG9jdW1lbnQ6ICgpID0+IGdldERvY3VtZW50LFxuICBnZXRMYXN0Rm9jdXM6ICgpID0+IGdldExhc3RGb2N1cyxcbiAgZ2V0TWlzc0NvdW50OiAoKSA9PiBnZXRNaXNzQ291bnQsXG4gIGdldFBhdGg6ICgpID0+IGdldFBhdGgsXG4gIGdldFBhdGhDb21wb25lbnRzOiAoKSA9PiBnZXRQYXRoQ29tcG9uZW50cyxcbiAgZ2V0UmVjdENvbmZpZzogKCkgPT4gZ2V0UmVjdENvbmZpZyxcbiAgZ2V0V2luZG93OiAoKSA9PiBnZXRXaW5kb3csXG4gIGdyb3VwQWNjdW11bGF0aXZlVmFsdWVQcm9wZXJ0eTogKCkgPT4gZ3JvdXBBY2N1bXVsYXRpdmVWYWx1ZVByb3BlcnR5LFxuICBncm91cEF2ZXJhZ2U6ICgpID0+IGdyb3VwQXZlcmFnZSxcbiAgZ3JvdXBCeTogKCkgPT4gZ3JvdXBCeSxcbiAgZ3JvdXBDb3VudDogKCkgPT4gZ3JvdXBDb3VudCxcbiAgZ3JvdXBTdGFja1ZhbHVlUHJvcGVydHk6ICgpID0+IGdyb3VwU3RhY2tWYWx1ZVByb3BlcnR5LFxuICBncm91cFN1bTogKCkgPT4gZ3JvdXBTdW0sXG4gIGluaXRNZW51S2V5TmF2OiAoKSA9PiBpbml0TWVudUtleU5hdixcbiAgaW5pdFJvdmluZ1RhYkluZGV4OiAoKSA9PiBpbml0Um92aW5nVGFiSW5kZXgsXG4gIGluaXRUb29sYmFyS2V5TmF2OiAoKSA9PiBpbml0VG9vbGJhcktleU5hdixcbiAgaXNBbmltYXRpbmdGbG9hdGluZ1Bvc2l0aW9uOiAoKSA9PiBpc0FuaW1hdGluZ0Zsb2F0aW5nUG9zaXRpb24sXG4gIGlzQXJyYXk6ICgpID0+IGlzQXJyYXksXG4gIGlzQm9vbGVhbjogKCkgPT4gaXNCb29sZWFuLFxuICBpc0J1dHRvbkNsaWNrRXZlbnQ6ICgpID0+IGlzQnV0dG9uQ2xpY2tFdmVudCxcbiAgaXNEYXRlOiAoKSA9PiBpc0RhdGUsXG4gIGlzRGVjb3JhdGVkT2JqZWN0OiAoKSA9PiBpc0RlY29yYXRlZE9iamVjdCxcbiAgaXNEZWZpbmVkOiAoKSA9PiBpc0RlZmluZWQsXG4gIGlzRW51bUtleTogKCkgPT4gaXNFbnVtS2V5LFxuICBpc0VudW1WYWx1ZTogKCkgPT4gaXNFbnVtVmFsdWUsXG4gIGlzRXF1YWw6ICgpID0+IGlzRXF1YWwsXG4gIGlzRmluaXRlTnVtYmVyOiAoKSA9PiBpc0Zpbml0ZU51bWJlcixcbiAgaXNGdW5jdGlvbjogKCkgPT4gaXNGdW5jdGlvbixcbiAgaXNIdG1sRWxlbWVudDogKCkgPT4gaXNIdG1sRWxlbWVudCxcbiAgaXNOZWdhdGl2ZTogKCkgPT4gaXNOZWdhdGl2ZSxcbiAgaXNOdW1iZXI6ICgpID0+IGlzTnVtYmVyLFxuICBpc09iamVjdDogKCkgPT4gaXNPYmplY3QsXG4gIGlzT2JqZWN0TGlrZTogKCkgPT4gaXNPYmplY3RMaWtlLFxuICBpc1BsYWluT2JqZWN0OiAoKSA9PiBpc1BsYWluT2JqZWN0LFxuICBpc1Byb3BlcnRpZXM6ICgpID0+IGlzUHJvcGVydGllcyxcbiAgaXNSZWdFeHA6ICgpID0+IGlzUmVnRXhwLFxuICBpc1N0cmluZzogKCkgPT4gaXNTdHJpbmcsXG4gIGlzU3ltYm9sOiAoKSA9PiBpc1N5bWJvbCxcbiAgaXNWYWxpZERhdGU6ICgpID0+IGlzVmFsaWREYXRlLFxuICBqc29uQXBwbHk6ICgpID0+IGpzb25BcHBseSxcbiAganNvbkRpZmY6ICgpID0+IGpzb25EaWZmLFxuICBqc29uV2FsazogKCkgPT4ganNvbldhbGssXG4gIGtleVByb3BlcnR5OiAoKSA9PiBrZXlQcm9wZXJ0eSxcbiAgbGFiZWxEaXJlY3Rpb25IYW5kbGluZzogKCkgPT4gbGFiZWxEaXJlY3Rpb25IYW5kbGluZyxcbiAgbGlzdERlY29yYXRlZFByb3BlcnRpZXM6ICgpID0+IGxpc3REZWNvcmF0ZWRQcm9wZXJ0aWVzLFxuICBtYWtlQWNjZXNzaWJsZUNsaWNrTGlzdGVuZXI6ICgpID0+IG1ha2VBY2Nlc3NpYmxlQ2xpY2tMaXN0ZW5lcixcbiAgbWFwVmFsdWVzOiAoKSA9PiBtYXBWYWx1ZXMsXG4gIG1hcmtlckZhZGVJbkFuaW1hdGlvbjogKCkgPT4gbWFya2VyRmFkZUluQW5pbWF0aW9uLFxuICBtYXJrZXJQYWxldHRlRmFjdG9yeTogKCkgPT4gbWFya2VyUGFsZXR0ZUZhY3RvcnksXG4gIG1hcmtlclNjYWxlSW5BbmltYXRpb246ICgpID0+IG1hcmtlclNjYWxlSW5BbmltYXRpb24sXG4gIG1hcmtlclN3aXBlU2NhbGVJbkFuaW1hdGlvbjogKCkgPT4gbWFya2VyU3dpcGVTY2FsZUluQW5pbWF0aW9uLFxuICBtZXJnZUFycmF5RGVmYXVsdHM6ICgpID0+IG1lcmdlQXJyYXlEZWZhdWx0cyxcbiAgbWVyZ2VEZWZhdWx0czogKCkgPT4gbWVyZ2VEZWZhdWx0cyxcbiAgbWlkcG9pbnRTdGFydGluZ0JhclBvc2l0aW9uOiAoKSA9PiBtaWRwb2ludFN0YXJ0aW5nQmFyUG9zaXRpb24sXG4gIG1pbk1heDogKCkgPT4gbWluTWF4LFxuICBtb2Q6ICgpID0+IG1vZCxcbiAgbW9kdWxlUmVnaXN0cnk6ICgpID0+IG1vZHVsZVJlZ2lzdHJ5LFxuICBuZWFyZXN0U3F1YXJlZDogKCkgPT4gbmVhcmVzdFNxdWFyZWQsXG4gIG5lYXJlc3RTcXVhcmVkSW5Db250YWluZXI6ICgpID0+IG5lYXJlc3RTcXVhcmVkSW5Db250YWluZXIsXG4gIG5vcm1hbGlzZUdyb3VwVG86ICgpID0+IG5vcm1hbGlzZUdyb3VwVG8sXG4gIG5vcm1hbGlzZVByb3BlcnR5VG86ICgpID0+IG5vcm1hbGlzZVByb3BlcnR5VG8sXG4gIG5vcm1hbGlzZWRFeHRlbnRXaXRoTWV0YWRhdGE6ICgpID0+IG5vcm1hbGlzZWRFeHRlbnRXaXRoTWV0YWRhdGEsXG4gIG9iamVjdEVxdWFsV2l0aDogKCkgPT4gb2JqZWN0RXF1YWxXaXRoLFxuICBwYWlyQ2F0ZWdvcnlEYXRhOiAoKSA9PiBwYWlyQ2F0ZWdvcnlEYXRhLFxuICBwYWlyQ29udGludW91c0RhdGE6ICgpID0+IHBhaXJDb250aW51b3VzRGF0YSxcbiAgcGFydGlhbEFzc2lnbjogKCkgPT4gcGFydGlhbEFzc2lnbixcbiAgcGF0aEZhZGVJbkFuaW1hdGlvbjogKCkgPT4gcGF0aEZhZGVJbkFuaW1hdGlvbixcbiAgcGF0aEZhZGVPdXRBbmltYXRpb246ICgpID0+IHBhdGhGYWRlT3V0QW5pbWF0aW9uLFxuICBwYXRoUmFuZ2VQb2ludHM6ICgpID0+IHBhdGhSYW5nZVBvaW50cyxcbiAgcGF0aFJhbmdlUG9pbnRzUmV2ZXJzZTogKCkgPT4gcGF0aFJhbmdlUG9pbnRzUmV2ZXJzZSxcbiAgcGF0aFJhbmdlczogKCkgPT4gcGF0aFJhbmdlcyxcbiAgcGF0aFN3aXBlSW5BbmltYXRpb246ICgpID0+IHBhdGhTd2lwZUluQW5pbWF0aW9uLFxuICBwaWNrQnlNYXRjaGluZ0FuZ2xlOiAoKSA9PiBwaWNrQnlNYXRjaGluZ0FuZ2xlLFxuICBwaWNrTm9kZTogKCkgPT4gcGlja05vZGUsXG4gIHBsb3RQYXRoOiAoKSA9PiBwbG90UGF0aCxcbiAgcHJlZGljYXRlV2l0aE1lc3NhZ2U6ICgpID0+IHByZWRpY2F0ZVdpdGhNZXNzYWdlLFxuICBwcmVwYXJlQXJlYVBhdGhBbmltYXRpb246ICgpID0+IHByZXBhcmVBcmVhUGF0aEFuaW1hdGlvbixcbiAgcHJlcGFyZUF4aXNBbmltYXRpb25Db250ZXh0OiAoKSA9PiBwcmVwYXJlQXhpc0FuaW1hdGlvbkNvbnRleHQsXG4gIHByZXBhcmVBeGlzQW5pbWF0aW9uRnVuY3Rpb25zOiAoKSA9PiBwcmVwYXJlQXhpc0FuaW1hdGlvbkZ1bmN0aW9ucyxcbiAgcHJlcGFyZUJhckFuaW1hdGlvbkZ1bmN0aW9uczogKCkgPT4gcHJlcGFyZUJhckFuaW1hdGlvbkZ1bmN0aW9ucyxcbiAgcHJlcGFyZUxpbmVQYXRoQW5pbWF0aW9uOiAoKSA9PiBwcmVwYXJlTGluZVBhdGhBbmltYXRpb24sXG4gIHByZXBhcmVMaW5lUGF0aEFuaW1hdGlvbkZuczogKCkgPT4gcHJlcGFyZUxpbmVQYXRoQW5pbWF0aW9uRm5zLFxuICBwcmVwYXJlTGluZVBhdGhQcm9wZXJ0eUFuaW1hdGlvbjogKCkgPT4gcHJlcGFyZUxpbmVQYXRoUHJvcGVydHlBbmltYXRpb24sXG4gIHByZXBhcmVNYXJrZXJBbmltYXRpb246ICgpID0+IHByZXBhcmVNYXJrZXJBbmltYXRpb24sXG4gIHByZXBhcmVQaWVTZXJpZXNBbmltYXRpb25GdW5jdGlvbnM6ICgpID0+IHByZXBhcmVQaWVTZXJpZXNBbmltYXRpb25GdW5jdGlvbnMsXG4gIHJhbmdlOiAoKSA9PiByYW5nZTIsXG4gIHJhbmdlZFZhbHVlUHJvcGVydHk6ICgpID0+IHJhbmdlZFZhbHVlUHJvcGVydHksXG4gIHJlbmRlclBhcnRpYWxQYXRoOiAoKSA9PiByZW5kZXJQYXJ0aWFsUGF0aCxcbiAgcmVzZXRBeGlzR3JvdXBGbjogKCkgPT4gcmVzZXRBeGlzR3JvdXBGbixcbiAgcmVzZXRBeGlzTGFiZWxTZWxlY3Rpb25GbjogKCkgPT4gcmVzZXRBeGlzTGFiZWxTZWxlY3Rpb25GbixcbiAgcmVzZXRBeGlzTGluZVNlbGVjdGlvbkZuOiAoKSA9PiByZXNldEF4aXNMaW5lU2VsZWN0aW9uRm4sXG4gIHJlc2V0QXhpc1NlbGVjdGlvbkZuOiAoKSA9PiByZXNldEF4aXNTZWxlY3Rpb25GbixcbiAgcmVzZXRCYXJTZWxlY3Rpb25zRm46ICgpID0+IHJlc2V0QmFyU2VsZWN0aW9uc0ZuLFxuICByZXNldElkczogKCkgPT4gcmVzZXRJZHMsXG4gIHJlc2V0TGFiZWxGbjogKCkgPT4gcmVzZXRMYWJlbEZuLFxuICByZXNldE1hcmtlckZuOiAoKSA9PiByZXNldE1hcmtlckZuLFxuICByZXNldE1hcmtlclBvc2l0aW9uRm46ICgpID0+IHJlc2V0TWFya2VyUG9zaXRpb25GbixcbiAgcmVzZXRNb3Rpb246ICgpID0+IHJlc2V0TW90aW9uLFxuICByZXNldFBpZVNlbGVjdGlvbnNGbjogKCkgPT4gcmVzZXRQaWVTZWxlY3Rpb25zRm4sXG4gIHJvdW5kOiAoKSA9PiByb3VuZCxcbiAgc2NhbGU6ICgpID0+IHNjYWxlLFxuICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbjogKCkgPT4gc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24sXG4gIHNlcmllc0xhYmVsRmFkZU91dEFuaW1hdGlvbjogKCkgPT4gc2VyaWVzTGFiZWxGYWRlT3V0QW5pbWF0aW9uLFxuICBzZXREb2N1bWVudDogKCkgPT4gc2V0RG9jdW1lbnQsXG4gIHNldEVsZW1lbnRCQm94OiAoKSA9PiBzZXRFbGVtZW50QkJveCxcbiAgc2V0UGF0aDogKCkgPT4gc2V0UGF0aCxcbiAgc2V0V2luZG93OiAoKSA9PiBzZXRXaW5kb3csXG4gIHNoYWxsb3dDbG9uZTogKCkgPT4gc2hhbGxvd0Nsb25lLFxuICBzaW5nbGVTZXJpZXNQYWxldHRlRmFjdG9yeTogKCkgPT4gc2luZ2xlU2VyaWVzUGFsZXR0ZUZhY3RvcnksXG4gIHNvcnRCYXNlZE9uQXJyYXk6ICgpID0+IHNvcnRCYXNlZE9uQXJyYXksXG4gIHNwbGl0UGFpckRhdGE6ICgpID0+IHNwbGl0UGFpckRhdGEsXG4gIHN0YXRpY0Zyb21Ub01vdGlvbjogKCkgPT4gc3RhdGljRnJvbVRvTW90aW9uLFxuICBzdG9wUGFnZVNjcm9sbGluZzogKCkgPT4gc3RvcFBhZ2VTY3JvbGxpbmcsXG4gIHN0cmluZ2lmeTogKCkgPT4gc3RyaW5naWZ5LFxuICBzdW06ICgpID0+IHN1bSxcbiAgc3VtVmFsdWVzOiAoKSA9PiBzdW1WYWx1ZXMsXG4gIHRvQXJyYXk6ICgpID0+IHRvQXJyYXksXG4gIHRvRml4ZWQ6ICgpID0+IHRvRml4ZWQsXG4gIHRvVG9vbHRpcEh0bWw6ICgpID0+IHRvVG9vbHRpcEh0bWwsXG4gIHRyYWlsaW5nQWNjdW11bGF0ZWRWYWx1ZTogKCkgPT4gdHJhaWxpbmdBY2N1bXVsYXRlZFZhbHVlLFxuICB0cmFpbGluZ0FjY3VtdWxhdGVkVmFsdWVQcm9wZXJ0eTogKCkgPT4gdHJhaWxpbmdBY2N1bXVsYXRlZFZhbHVlUHJvcGVydHksXG4gIHVuaXF1ZTogKCkgPT4gdW5pcXVlLFxuICB1cGRhdGVDbGlwUGF0aDogKCkgPT4gdXBkYXRlQ2xpcFBhdGgsXG4gIHVwZGF0ZUxhYmVsTm9kZTogKCkgPT4gdXBkYXRlTGFiZWxOb2RlLFxuICB1cGRhdGVSZWN0OiAoKSA9PiB1cGRhdGVSZWN0LFxuICB2YWxpZGF0ZUNyb3NzTGluZVZhbHVlczogKCkgPT4gdmFsaWRhdGVDcm9zc0xpbmVWYWx1ZXMsXG4gIHZhbHVlUHJvcGVydHk6ICgpID0+IHZhbHVlUHJvcGVydHksXG4gIHdpdGhvdXQ6ICgpID0+IHdpdGhvdXRcbn0pO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2RlcHJlY2F0aW9uLnRzXG5mdW5jdGlvbiBjcmVhdGVEZXByZWNhdGlvbldhcm5pbmcoKSB7XG4gIHJldHVybiAoa2V5LCBtZXNzYWdlKSA9PiB7XG4gICAgY29uc3QgbXNnID0gW2BQcm9wZXJ0eSBbJHtrZXl9XSBpcyBkZXByZWNhdGVkLmAsIG1lc3NhZ2VdLmZpbHRlcihCb29sZWFuKS5qb2luKFwiIFwiKTtcbiAgICBMb2dnZXIud2Fybk9uY2UobXNnKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIERlcHJlY2F0ZWQobWVzc2FnZSwgb3B0cykge1xuICBjb25zdCB3YXJuRGVwcmVjYXRlZCA9IGNyZWF0ZURlcHJlY2F0aW9uV2FybmluZygpO1xuICBjb25zdCBkZWYgPSBvcHRzPy5kZWZhdWx0O1xuICByZXR1cm4gYWRkVHJhbnNmb3JtVG9JbnN0YW5jZVByb3BlcnR5KChfLCBrZXksIHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlICE9PSBkZWYpIHtcbiAgICAgIHdhcm5EZXByZWNhdGVkKGtleS50b1N0cmluZygpLCBtZXNzYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9KTtcbn1cbmZ1bmN0aW9uIERlcHJlY2F0ZWRBbmRSZW5hbWVkVG8obmV3UHJvcE5hbWUsIG1hcFZhbHVlKSB7XG4gIGNvbnN0IHdhcm5EZXByZWNhdGVkID0gY3JlYXRlRGVwcmVjYXRpb25XYXJuaW5nKCk7XG4gIHJldHVybiBhZGRUcmFuc2Zvcm1Ub0luc3RhbmNlUHJvcGVydHkoXG4gICAgKHRhcmdldCwga2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgaWYgKHZhbHVlICE9PSB0YXJnZXRbbmV3UHJvcE5hbWVdKSB7XG4gICAgICAgIHdhcm5EZXByZWNhdGVkKGtleS50b1N0cmluZygpLCBgVXNlIFske25ld1Byb3BOYW1lfV0gaW5zdGVhZC5gKTtcbiAgICAgICAgc2V0UGF0aCh0YXJnZXQsIG5ld1Byb3BOYW1lLCBtYXBWYWx1ZSA/IG1hcFZhbHVlKHZhbHVlKSA6IHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBCUkVBS19UUkFOU0ZPUk1fQ0hBSU47XG4gICAgfSxcbiAgICAodGFyZ2V0LCBrZXkpID0+IHtcbiAgICAgIHdhcm5EZXByZWNhdGVkKGtleS50b1N0cmluZygpLCBgVXNlIFske25ld1Byb3BOYW1lfV0gaW5zdGVhZC5gKTtcbiAgICAgIHJldHVybiBnZXRQYXRoKHRhcmdldCwgbmV3UHJvcE5hbWUpO1xuICAgIH1cbiAgKTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9zZWFyY2gudXRpbC50c1xuZnVuY3Rpb24gZmluZE1heFZhbHVlKG1pbiwgbWF4LCBpdGVyYXRlZSkge1xuICBpZiAobWluID4gbWF4KVxuICAgIHJldHVybjtcbiAgbGV0IGZvdW5kO1xuICB3aGlsZSAobWF4ID49IG1pbikge1xuICAgIGNvbnN0IGluZGV4ID0gTWF0aC5mbG9vcigobWF4ICsgbWluKSAvIDIpO1xuICAgIGNvbnN0IHZhbHVlID0gaXRlcmF0ZWUoaW5kZXgpO1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICBtYXggPSBpbmRleCAtIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvdW5kID0gdmFsdWU7XG4gICAgICBtaW4gPSBpbmRleCArIDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBmb3VuZDtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC92ZWN0b3I0LnRzXG52YXIgVmVjNCA9IHtcbiAgYm90dG9tQ2VudGVyLFxuICBjZW50ZXIsXG4gIGNsb25lLFxuICBlbmQsXG4gIGZyb206IGZyb20yLFxuICBoZWlnaHQsXG4gIHJvdW5kOiByb3VuZDQsXG4gIHN0YXJ0LFxuICB0b3BDZW50ZXIsXG4gIG9yaWdpbjogb3JpZ2luMixcbiAgd2lkdGhcbn07XG5mdW5jdGlvbiBzdGFydChhKSB7XG4gIHJldHVybiB7IHg6IGEueDEsIHk6IGEueTEgfTtcbn1cbmZ1bmN0aW9uIGVuZChhKSB7XG4gIHJldHVybiB7IHg6IGEueDIsIHk6IGEueTIgfTtcbn1cbmZ1bmN0aW9uIHRvcENlbnRlcihhKSB7XG4gIHJldHVybiB7IHg6IChhLngxICsgYS54MikgLyAyLCB5OiBNYXRoLm1pbihhLnkxLCBhLnkyKSB9O1xufVxuZnVuY3Rpb24gY2VudGVyKGEpIHtcbiAgcmV0dXJuIHsgeDogKGEueDEgKyBhLngyKSAvIDIsIHk6IChhLnkxICsgYS55MikgLyAyIH07XG59XG5mdW5jdGlvbiBib3R0b21DZW50ZXIoYSkge1xuICByZXR1cm4geyB4OiAoYS54MSArIGEueDIpIC8gMiwgeTogTWF0aC5tYXgoYS55MSwgYS55MikgfTtcbn1cbmZ1bmN0aW9uIHdpZHRoKGEpIHtcbiAgcmV0dXJuIE1hdGguYWJzKGEueDIgLSBhLngxKTtcbn1cbmZ1bmN0aW9uIGhlaWdodChhKSB7XG4gIHJldHVybiBNYXRoLmFicyhhLnkyIC0gYS55MSk7XG59XG5mdW5jdGlvbiByb3VuZDQoYSkge1xuICByZXR1cm4geyB4MTogTWF0aC5yb3VuZChhLngxKSwgeTE6IE1hdGgucm91bmQoYS55MSksIHgyOiBNYXRoLnJvdW5kKGEueDIpLCB5MjogTWF0aC5yb3VuZChhLnkyKSB9O1xufVxuZnVuY3Rpb24gY2xvbmUoYSkge1xuICByZXR1cm4geyB4MTogYS54MSwgeTE6IGEueTEsIHgyOiBhLngyLCB5MjogYS55MiB9O1xufVxuZnVuY3Rpb24gZnJvbTIoYSwgYiwgYywgZCkge1xuICBpZiAodHlwZW9mIGEgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4geyB4MTogYSwgeTE6IGIsIHgyOiBjLCB5MjogZCB9O1xuICB9XG4gIGlmIChcIndpZHRoXCIgaW4gYSkge1xuICAgIHJldHVybiB7XG4gICAgICB4MTogYS54LFxuICAgICAgeTE6IGEueSxcbiAgICAgIHgyOiBhLnggKyBhLndpZHRoLFxuICAgICAgeTI6IGEueSArIGEuaGVpZ2h0XG4gICAgfTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYFZhbHVlcyBjYW4gbm90IGJlIGNvbnZlcnRlZCBpbnRvIGEgdmVjdG9yNDogWyR7YX1dIFske2J9XSBbJHtjfV0gWyR7ZH1dYCk7XG59XG5mdW5jdGlvbiBvcmlnaW4yKCkge1xuICByZXR1cm4geyB4MTogMCwgeTE6IDAsIHgyOiAwLCB5MjogMCB9O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvaGllcmFyY2h5L2hpZXJhcmNoeVNlcmllcy50c1xudmFyIF9IaWVyYXJjaHlOb2RlID0gY2xhc3MgX0hpZXJhcmNoeU5vZGUge1xuICBjb25zdHJ1Y3RvcihzZXJpZXMsIGluZGV4LCBkYXR1bSwgc2l6ZSwgY29sb3JWYWx1ZSwgZmlsbCwgc3Ryb2tlLCBzdW1TaXplLCBkZXB0aCwgcGFyZW50LCBjaGlsZHJlbikge1xuICAgIHRoaXMuc2VyaWVzID0gc2VyaWVzO1xuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICB0aGlzLmRhdHVtID0gZGF0dW07XG4gICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICB0aGlzLmNvbG9yVmFsdWUgPSBjb2xvclZhbHVlO1xuICAgIHRoaXMuZmlsbCA9IGZpbGw7XG4gICAgdGhpcy5zdHJva2UgPSBzdHJva2U7XG4gICAgdGhpcy5zdW1TaXplID0gc3VtU2l6ZTtcbiAgICB0aGlzLmRlcHRoID0gZGVwdGg7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIHRoaXMubWlkUG9pbnQgPSB7IHg6IDAsIHk6IDAgfTtcbiAgfVxuICBjb250YWlucyhvdGhlcikge1xuICAgIGxldCBjdXJyZW50ID0gb3RoZXI7XG4gICAgd2hpbGUgKGN1cnJlbnQgIT0gbnVsbCAmJiBjdXJyZW50LmluZGV4ID49IHRoaXMuaW5kZXgpIHtcbiAgICAgIGlmIChjdXJyZW50ID09PSB0aGlzKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgd2FsayhjYWxsYmFjazIsIG9yZGVyID0gX0hpZXJhcmNoeU5vZGUuV2Fsay5QcmVPcmRlcikge1xuICAgIGlmIChvcmRlciA9PT0gX0hpZXJhcmNoeU5vZGUuV2Fsay5QcmVPcmRlcikge1xuICAgICAgY2FsbGJhY2syKHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICBjaGlsZC53YWxrKGNhbGxiYWNrMiwgb3JkZXIpO1xuICAgIH0pO1xuICAgIGlmIChvcmRlciA9PT0gX0hpZXJhcmNoeU5vZGUuV2Fsay5Qb3N0T3JkZXIpIHtcbiAgICAgIGNhbGxiYWNrMih0aGlzKTtcbiAgICB9XG4gIH1cbiAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHlpZWxkIHRoaXM7XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICB5aWVsZCogY2hpbGQ7XG4gICAgfVxuICB9XG59O1xuX0hpZXJhcmNoeU5vZGUuV2FsayA9IHtcbiAgUHJlT3JkZXI6IDAsXG4gIFBvc3RPcmRlcjogMVxufTtcbnZhciBIaWVyYXJjaHlOb2RlID0gX0hpZXJhcmNoeU5vZGU7XG52YXIgSGllcmFyY2h5U2VyaWVzID0gY2xhc3MgZXh0ZW5kcyBTZXJpZXMge1xuICBjb25zdHJ1Y3Rvcihtb2R1bGVDdHgpIHtcbiAgICBzdXBlcih7XG4gICAgICBtb2R1bGVDdHgsXG4gICAgICBwaWNrTW9kZXM6IFsxIC8qIE5FQVJFU1RfTk9ERSAqLywgMCAvKiBFWEFDVF9TSEFQRV9NQVRDSCAqL10sXG4gICAgICBjb250ZW50R3JvdXBWaXJ0dWFsOiBmYWxzZVxuICAgIH0pO1xuICAgIHRoaXMucm9vdE5vZGUgPSBuZXcgSGllcmFyY2h5Tm9kZShcbiAgICAgIHRoaXMsXG4gICAgICAwLFxuICAgICAgdm9pZCAwLFxuICAgICAgMCxcbiAgICAgIHZvaWQgMCxcbiAgICAgIHZvaWQgMCxcbiAgICAgIHZvaWQgMCxcbiAgICAgIDAsXG4gICAgICB2b2lkIDAsXG4gICAgICB2b2lkIDAsXG4gICAgICBbXVxuICAgICk7XG4gICAgdGhpcy5jb2xvckRvbWFpbiA9IFswLCAwXTtcbiAgICB0aGlzLm1heERlcHRoID0gMDtcbiAgICB0aGlzLmZvY3VzUGF0aCA9IFtdO1xuICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUgPSBuZXcgU3RhdGVNYWNoaW5lKFxuICAgICAgXCJlbXB0eVwiLFxuICAgICAge1xuICAgICAgICBlbXB0eToge1xuICAgICAgICAgIHVwZGF0ZToge1xuICAgICAgICAgICAgdGFyZ2V0OiBcInJlYWR5XCIsXG4gICAgICAgICAgICBhY3Rpb246IChkYXRhKSA9PiB0aGlzLmFuaW1hdGVFbXB0eVVwZGF0ZVJlYWR5KGRhdGEpXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXNldDogXCJlbXB0eVwiLFxuICAgICAgICAgIHNraXA6IFwicmVhZHlcIlxuICAgICAgICB9LFxuICAgICAgICByZWFkeToge1xuICAgICAgICAgIHVwZGF0ZURhdGE6IFwid2FpdGluZ1wiLFxuICAgICAgICAgIGNsZWFyOiBcImNsZWFyaW5nXCIsXG4gICAgICAgICAgaGlnaGxpZ2h0OiAoZGF0YSkgPT4gdGhpcy5hbmltYXRlUmVhZHlIaWdobGlnaHQoZGF0YSksXG4gICAgICAgICAgcmVzaXplOiAoZGF0YSkgPT4gdGhpcy5hbmltYXRlUmVhZHlSZXNpemUoZGF0YSksXG4gICAgICAgICAgcmVzZXQ6IFwiZW1wdHlcIixcbiAgICAgICAgICBza2lwOiBcInJlYWR5XCJcbiAgICAgICAgfSxcbiAgICAgICAgd2FpdGluZzoge1xuICAgICAgICAgIHVwZGF0ZToge1xuICAgICAgICAgICAgdGFyZ2V0OiBcInJlYWR5XCIsXG4gICAgICAgICAgICBhY3Rpb246IChkYXRhKSA9PiB0aGlzLmFuaW1hdGVXYWl0aW5nVXBkYXRlUmVhZHkoZGF0YSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc2V0OiBcImVtcHR5XCIsXG4gICAgICAgICAgc2tpcDogXCJyZWFkeVwiXG4gICAgICAgIH0sXG4gICAgICAgIGNsZWFyaW5nOiB7XG4gICAgICAgICAgdXBkYXRlOiB7XG4gICAgICAgICAgICB0YXJnZXQ6IFwiZW1wdHlcIixcbiAgICAgICAgICAgIGFjdGlvbjogKGRhdGEpID0+IHRoaXMuYW5pbWF0ZUNsZWFyaW5nVXBkYXRlRW1wdHkoZGF0YSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc2V0OiBcImVtcHR5XCIsXG4gICAgICAgICAgc2tpcDogXCJyZWFkeVwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAoKSA9PiB0aGlzLmNoZWNrUHJvY2Vzc2VkRGF0YUFuaW1hdGFibGUoKVxuICAgICk7XG4gIH1cbiAgcmVzZXRBbmltYXRpb24ocGhhc2UpIHtcbiAgICBpZiAocGhhc2UgPT09IFwiaW5pdGlhbFwiKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJyZXNldFwiKTtcbiAgICB9IGVsc2UgaWYgKHBoYXNlID09PSBcInJlYWR5XCIpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcInNraXBcIik7XG4gICAgfVxuICB9XG4gIGFzeW5jIHByb2Nlc3NEYXRhKCkge1xuICAgIGNvbnN0IHsgY2hpbGRyZW5LZXksIHNpemVLZXksIGNvbG9yS2V5LCBmaWxscywgc3Ryb2tlcywgY29sb3JSYW5nZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgY29uc3QgZ2V0SW5kZXggPSAoKSA9PiB7XG4gICAgICBpbmRleCArPSAxO1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH07XG4gICAgbGV0IG1heERlcHRoID0gMDtcbiAgICBsZXQgbWluQ29sb3IgPSBJbmZpbml0eTtcbiAgICBsZXQgbWF4Q29sb3IgPSAtSW5maW5pdHk7XG4gICAgY29uc3QgY29sb3JzID0gbmV3IEFycmF5KCh0aGlzLmRhdGE/Lmxlbmd0aCA/PyAwKSArIDEpLmZpbGwodm9pZCAwKTtcbiAgICBjb25zdCBjcmVhdGVOb2RlID0gKGRhdHVtLCBwYXJlbnQpID0+IHtcbiAgICAgIGNvbnN0IG5vZGVJbmRleCA9IGdldEluZGV4KCk7XG4gICAgICBjb25zdCBkZXB0aCA9IHBhcmVudC5kZXB0aCAhPSBudWxsID8gcGFyZW50LmRlcHRoICsgMSA6IDA7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IGNoaWxkcmVuS2V5ICE9IG51bGwgPyBkYXR1bVtjaGlsZHJlbktleV0gOiB2b2lkIDA7XG4gICAgICBjb25zdCBpc0xlYWYgPSBjaGlsZHJlbiA9PSBudWxsIHx8IGNoaWxkcmVuLmxlbmd0aCA9PT0gMDtcbiAgICAgIGxldCBzaXplID0gc2l6ZUtleSAhPSBudWxsID8gZGF0dW1bc2l6ZUtleV0gOiB2b2lkIDA7XG4gICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHNpemUpKSB7XG4gICAgICAgIHNpemUgPSBNYXRoLm1heChzaXplLCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNpemUgPSBpc0xlYWYgPyAxIDogMDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN1bVNpemUgPSBzaXplO1xuICAgICAgbWF4RGVwdGggPSBNYXRoLm1heChtYXhEZXB0aCwgZGVwdGgpO1xuICAgICAgY29uc3QgY29sb3IgPSBjb2xvcktleSAhPSBudWxsID8gZGF0dW1bY29sb3JLZXldIDogdm9pZCAwO1xuICAgICAgaWYgKHR5cGVvZiBjb2xvciA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBjb2xvcnNbbm9kZUluZGV4XSA9IGNvbG9yO1xuICAgICAgICBtaW5Db2xvciA9IE1hdGgubWluKG1pbkNvbG9yLCBjb2xvcik7XG4gICAgICAgIG1heENvbG9yID0gTWF0aC5tYXgobWF4Q29sb3IsIGNvbG9yKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcHBlbmRDaGlsZHJlbihcbiAgICAgICAgbmV3IEhpZXJhcmNoeU5vZGUoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICBub2RlSW5kZXgsXG4gICAgICAgICAgZGF0dW0sXG4gICAgICAgICAgc2l6ZSxcbiAgICAgICAgICBjb2xvcixcbiAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgIHN1bVNpemUsXG4gICAgICAgICAgZGVwdGgsXG4gICAgICAgICAgcGFyZW50LFxuICAgICAgICAgIFtdXG4gICAgICAgICksXG4gICAgICAgIGNoaWxkcmVuXG4gICAgICApO1xuICAgIH07XG4gICAgY29uc3QgYXBwZW5kQ2hpbGRyZW4gPSAobm9kZSwgZGF0YSkgPT4ge1xuICAgICAgZGF0YT8uZm9yRWFjaCgoZGF0dW0pID0+IHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjcmVhdGVOb2RlKGRhdHVtLCBub2RlKTtcbiAgICAgICAgbm9kZS5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgbm9kZS5zdW1TaXplICs9IGNoaWxkLnN1bVNpemU7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG4gICAgY29uc3Qgcm9vdE5vZGUgPSBhcHBlbmRDaGlsZHJlbihcbiAgICAgIG5ldyBIaWVyYXJjaHlOb2RlKFxuICAgICAgICB0aGlzLFxuICAgICAgICAwLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIDAsXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIDAsXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICBbXVxuICAgICAgKSxcbiAgICAgIHRoaXMuZGF0YVxuICAgICk7XG4gICAgY29uc3QgY29sb3JEb21haW4gPSBbbWluQ29sb3IsIG1heENvbG9yXTtcbiAgICBsZXQgY29sb3JTY2FsZTtcbiAgICBpZiAoY29sb3JSYW5nZSAhPSBudWxsICYmIE51bWJlci5pc0Zpbml0ZShtaW5Db2xvcikgJiYgTnVtYmVyLmlzRmluaXRlKG1heENvbG9yKSkge1xuICAgICAgY29sb3JTY2FsZSA9IG5ldyBDb2xvclNjYWxlKCk7XG4gICAgICBjb2xvclNjYWxlLmRvbWFpbiA9IGNvbG9yRG9tYWluO1xuICAgICAgY29sb3JTY2FsZS5yYW5nZSA9IGNvbG9yUmFuZ2U7XG4gICAgICBjb2xvclNjYWxlLnVwZGF0ZSgpO1xuICAgIH1cbiAgICByb290Tm9kZS5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCwgY2hpbGRJbmRleCkgPT4ge1xuICAgICAgY2hpbGQud2Fsaygobm9kZSkgPT4ge1xuICAgICAgICBsZXQgZmlsbDtcbiAgICAgICAgY29uc3QgY29sb3IgPSBjb2xvcnNbbm9kZS5pbmRleF07XG4gICAgICAgIGlmIChjb2xvciAhPSBudWxsKSB7XG4gICAgICAgICAgZmlsbCA9IGNvbG9yU2NhbGU/LmNvbnZlcnQoY29sb3IpO1xuICAgICAgICB9XG4gICAgICAgIGZpbGwgPz8gKGZpbGwgPSBmaWxscz8uW2NoaWxkSW5kZXggJSBmaWxscy5sZW5ndGhdKTtcbiAgICAgICAgbm9kZS5maWxsID0gZmlsbDtcbiAgICAgICAgbm9kZS5zdHJva2UgPSBjb2xvclNjYWxlID09IG51bGwgPyBzdHJva2VzPy5bY2hpbGRJbmRleCAlIHN0cm9rZXMubGVuZ3RoXSA6IFwicmdiYSgwLCAwLCAwLCAwLjIpXCI7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0aGlzLnJvb3ROb2RlID0gcm9vdE5vZGU7XG4gICAgdGhpcy5tYXhEZXB0aCA9IG1heERlcHRoO1xuICAgIHRoaXMuY29sb3JEb21haW4gPSBjb2xvckRvbWFpbjtcbiAgICB0aGlzLmZvY3VzUGF0aCA9IFt7IG5vZGVEYXR1bTogdGhpcy5yb290Tm9kZSwgY2hpbGRJbmRleDogMCB9XTtcbiAgfVxuICBhc3luYyB1cGRhdGUoeyBzZXJpZXNSZWN0IH0pIHtcbiAgICBhd2FpdCB0aGlzLnVwZGF0ZVNlbGVjdGlvbnMoKTtcbiAgICBhd2FpdCB0aGlzLnVwZGF0ZU5vZGVzKCk7XG4gICAgY29uc3QgYW5pbWF0aW9uRGF0YSA9IHRoaXMuZ2V0QW5pbWF0aW9uRGF0YSgpO1xuICAgIGNvbnN0IHJlc2l6ZSA9IHRoaXMuY2hlY2tSZXNpemUoc2VyaWVzUmVjdCk7XG4gICAgaWYgKHJlc2l6ZSkge1xuICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwicmVzaXplXCIsIGFuaW1hdGlvbkRhdGEpO1xuICAgIH1cbiAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJ1cGRhdGVcIiwgYW5pbWF0aW9uRGF0YSk7XG4gIH1cbiAgcmVzZXRBbGxBbmltYXRpb24oZGF0YSkge1xuICAgIGNvbnN0IGRhdHVtID0gdGhpcy5hbmltYXRpb25SZXNldEZucz8uZGF0dW07XG4gICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5zdG9wQnlBbmltYXRpb25Hcm91cElkKHRoaXMuaWQpO1xuICAgIGlmIChkYXR1bSAhPSBudWxsKSB7XG4gICAgICByZXNldE1vdGlvbihkYXRhLmRhdHVtU2VsZWN0aW9ucywgZGF0dW0pO1xuICAgIH1cbiAgfVxuICBhbmltYXRlRW1wdHlVcGRhdGVSZWFkeShkYXRhKSB7XG4gICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5za2lwQ3VycmVudEJhdGNoKCk7XG4gICAgdGhpcy5yZXNldEFsbEFuaW1hdGlvbihkYXRhKTtcbiAgfVxuICBhbmltYXRlV2FpdGluZ1VwZGF0ZVJlYWR5KGRhdGEpIHtcbiAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLnNraXBDdXJyZW50QmF0Y2goKTtcbiAgICB0aGlzLnJlc2V0QWxsQW5pbWF0aW9uKGRhdGEpO1xuICB9XG4gIGFuaW1hdGVSZWFkeUhpZ2hsaWdodChkYXRhKSB7XG4gICAgY29uc3QgZGF0dW0gPSB0aGlzLmFuaW1hdGlvblJlc2V0Rm5zPy5kYXR1bTtcbiAgICBpZiAoZGF0dW0gIT0gbnVsbCkge1xuICAgICAgcmVzZXRNb3Rpb24oW2RhdGFdLCBkYXR1bSk7XG4gICAgfVxuICB9XG4gIGFuaW1hdGVSZWFkeVJlc2l6ZShkYXRhKSB7XG4gICAgdGhpcy5yZXNldEFsbEFuaW1hdGlvbihkYXRhKTtcbiAgfVxuICBhbmltYXRlQ2xlYXJpbmdVcGRhdGVFbXB0eShkYXRhKSB7XG4gICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5za2lwQ3VycmVudEJhdGNoKCk7XG4gICAgdGhpcy5yZXNldEFsbEFuaW1hdGlvbihkYXRhKTtcbiAgfVxuICBhbmltYXRpb25UcmFuc2l0aW9uQ2xlYXIoKSB7XG4gICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwiY2xlYXJcIiwgdGhpcy5nZXRBbmltYXRpb25EYXRhKCkpO1xuICB9XG4gIGdldEFuaW1hdGlvbkRhdGEoKSB7XG4gICAgY29uc3QgYW5pbWF0aW9uRGF0YSA9IHtcbiAgICAgIGRhdHVtU2VsZWN0aW9uczogW3RoaXMuZ3JvdXBTZWxlY3Rpb25dXG4gICAgfTtcbiAgICByZXR1cm4gYW5pbWF0aW9uRGF0YTtcbiAgfVxuICBpc1Byb2Nlc3NlZERhdGFBbmltYXRhYmxlKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNoZWNrUHJvY2Vzc2VkRGF0YUFuaW1hdGFibGUoKSB7XG4gICAgaWYgKCF0aGlzLmlzUHJvY2Vzc2VkRGF0YUFuaW1hdGFibGUoKSkge1xuICAgICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5za2lwQ3VycmVudEJhdGNoKCk7XG4gICAgfVxuICB9XG4gIGdldExhYmVsRGF0YSgpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgZ2V0U2VyaWVzRG9tYWluKCkge1xuICAgIHJldHVybiBbTmFOLCBOYU5dO1xuICB9XG4gIGdldExlZ2VuZERhdGEobGVnZW5kVHlwZSkge1xuICAgIGNvbnN0IHsgY29sb3JLZXksIGNvbG9yTmFtZSwgY29sb3JSYW5nZSwgdmlzaWJsZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIHJldHVybiBsZWdlbmRUeXBlID09PSBcImdyYWRpZW50XCIgJiYgY29sb3JLZXkgIT0gbnVsbCAmJiBjb2xvclJhbmdlICE9IG51bGwgPyBbXG4gICAgICB7XG4gICAgICAgIGxlZ2VuZFR5cGU6IFwiZ3JhZGllbnRcIixcbiAgICAgICAgZW5hYmxlZDogdmlzaWJsZSxcbiAgICAgICAgc2VyaWVzSWQ6IHRoaXMuaWQsXG4gICAgICAgIGNvbG9yTmFtZSxcbiAgICAgICAgY29sb3JSYW5nZSxcbiAgICAgICAgY29sb3JEb21haW46IHRoaXMuY29sb3JEb21haW5cbiAgICAgIH1cbiAgICBdIDogW107XG4gIH1cbiAgZ2V0RGF0dW1JZEZyb21EYXRhKG5vZGUpIHtcbiAgICByZXR1cm4gYCR7bm9kZS5pbmRleH1gO1xuICB9XG4gIGdldERhdHVtSWQobm9kZSkge1xuICAgIHJldHVybiB0aGlzLmdldERhdHVtSWRGcm9tRGF0YShub2RlKTtcbiAgfVxuICBwaWNrRm9jdXMob3B0cykge1xuICAgIGlmICh0aGlzLnJvb3ROb2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgaWYgKHRoaXMuZm9jdXNQYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgTG9nZ2VyLmVycm9yKFwidGhpcy5mb2N1c1BhdGggc2hvdWxkIG5vdCBiZSBlbXB0eVwiKTtcbiAgICB9XG4gICAgY29uc3QgeyBkYXR1bUluZGV4RGVsdGE6IGNoaWxkRGVsdGEsIG90aGVySW5kZXhEZWx0YTogZGVwdGhEZWx0YSB9ID0gb3B0cztcbiAgICBjb25zdCB7IGZvY3VzUGF0aDogcGF0aCB9ID0gdGhpcztcbiAgICBjb25zdCBkZXB0aCA9IHBhdGgubGVuZ3RoIC0gMjtcbiAgICBpZiAoZGVwdGhEZWx0YSAhPT0gMCB8fCBwYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgdGFyZ2V0RGVwdGggPSBNYXRoLm1heCgwLCBkZXB0aCArIGRlcHRoRGVsdGEpO1xuICAgICAgaWYgKHBhdGhbdGFyZ2V0RGVwdGggKyAxXSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHBhdGgubGVuZ3RoID0gdGFyZ2V0RGVwdGggKyAyO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlRm9jdXNPdXRwdXRzKHBhdGhbdGFyZ2V0RGVwdGggKyAxXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgZGVlcGVzdCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgd2hpbGUgKGRlZXBlc3Qubm9kZURhdHVtLmNoaWxkcmVuLmxlbmd0aCA+IDAgJiYgKGRlZXBlc3Qubm9kZURhdHVtLmRlcHRoID8/IC0xKSA8IHRhcmdldERlcHRoKSB7XG4gICAgICAgICAgY29uc3QgbmV4dERlZXBlc3QgPSB7IG5vZGVEYXR1bTogZGVlcGVzdC5ub2RlRGF0dW0uY2hpbGRyZW5bMF0sIGNoaWxkSW5kZXg6IDAgfTtcbiAgICAgICAgICBwYXRoLnB1c2gobmV4dERlZXBlc3QpO1xuICAgICAgICAgIGRlZXBlc3QgPSBuZXh0RGVlcGVzdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlRm9jdXNPdXRwdXRzKGRlZXBlc3QpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2hpbGREZWx0YSAhPT0gMCkge1xuICAgICAgY29uc3QgdGFyZ2V0Q2hpbGQgPSBwYXRoW2RlcHRoICsgMV0uY2hpbGRJbmRleCArIGNoaWxkRGVsdGE7XG4gICAgICBjb25zdCBjdXJyZW50UGFyZW50ID0gcGF0aFtkZXB0aF0ubm9kZURhdHVtO1xuICAgICAgY29uc3QgY2hpbGRDb3VudCA9IGN1cnJlbnRQYXJlbnQ/LmNoaWxkcmVuPy5sZW5ndGg7XG4gICAgICBpZiAoY2hpbGRDb3VudCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IG5ld0NoaWxkID0gY2xhbXAoMCwgdGFyZ2V0Q2hpbGQsIGNoaWxkQ291bnQgLSAxKTtcbiAgICAgICAgY29uc3QgbmV3Rm9jdXMgPSB7IG5vZGVEYXR1bTogY3VycmVudFBhcmVudC5jaGlsZHJlbltuZXdDaGlsZF0sIGNoaWxkSW5kZXg6IG5ld0NoaWxkIH07XG4gICAgICAgIHBhdGhbZGVwdGggKyAxXSA9IG5ld0ZvY3VzO1xuICAgICAgICBwYXRoLmxlbmd0aCA9IGRlcHRoICsgMjtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZUZvY3VzT3V0cHV0cyhuZXdGb2N1cyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVGb2N1c091dHB1dHMocGF0aFtwYXRoLmxlbmd0aCAtIDFdKTtcbiAgICB9XG4gIH1cbiAgZ2V0RGF0dW1BcmlhVGV4dChkYXR1bSwgZGVzY3JpcHRpb24pIHtcbiAgICBpZiAoIShkYXR1bSBpbnN0YW5jZW9mIEhpZXJhcmNoeU5vZGUpKSB7XG4gICAgICBMb2dnZXIuZXJyb3IoYGRhdHVtIGlzIG5vdCBIaWVyYXJjaHlOb2RlOiAke2RhdHVtfWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jdHgubG9jYWxlTWFuYWdlci50KFwiYXJpYUFubm91bmNlSGllcmFyY2h5RGF0dW1cIiwge1xuICAgICAgbGV2ZWw6IChkYXR1bS5kZXB0aCA/PyAtMSkgKyAxLFxuICAgICAgY291bnQ6IGRhdHVtLmNoaWxkcmVuLmxlbmd0aCxcbiAgICAgIGRlc2NyaXB0aW9uXG4gICAgfSk7XG4gIH1cbiAgY29tcHV0ZUZvY3VzT3V0cHV0cyh7IG5vZGVEYXR1bSwgY2hpbGRJbmRleCB9KSB7XG4gICAgY29uc3QgYm91bmRzID0gdGhpcy5jb21wdXRlRm9jdXNCb3VuZHMobm9kZURhdHVtKTtcbiAgICBpZiAoYm91bmRzKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXR1bTogbm9kZURhdHVtLFxuICAgICAgICBkYXR1bUluZGV4OiBjaGlsZEluZGV4LFxuICAgICAgICBvdGhlckluZGV4OiBub2RlRGF0dW0uZGVwdGgsXG4gICAgICAgIGJvdW5kcyxcbiAgICAgICAgc2hvd0ZvY3VzQm94OiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvaGllcmFyY2h5L2hpZXJhcmNoeVNlcmllc1Byb3BlcnRpZXMudHNcbnZhciBIaWVyYXJjaHlTZXJpZXNQcm9wZXJ0aWVzID0gY2xhc3MgZXh0ZW5kcyBTZXJpZXNQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmNoaWxkcmVuS2V5ID0gXCJjaGlsZHJlblwiO1xuICAgIHRoaXMuZmlsbHMgPSBPYmplY3QudmFsdWVzKERFRkFVTFRfRklMTFMpO1xuICAgIHRoaXMuc3Ryb2tlcyA9IE9iamVjdC52YWx1ZXMoREVGQVVMVF9TVFJPS0VTKTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORylcbl0sIEhpZXJhcmNoeVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNoaWxkcmVuS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBIaWVyYXJjaHlTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzaXplS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBIaWVyYXJjaHlTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjb2xvcktleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgSGllcmFyY2h5U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiY29sb3JOYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HX0FSUkFZKVxuXSwgSGllcmFyY2h5U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiZmlsbHNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkdfQVJSQVkpXG5dLCBIaWVyYXJjaHlTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdHJva2VzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HX0FSUkFZLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBIaWVyYXJjaHlTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjb2xvclJhbmdlXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvdG9wb2xvZ3kvbG9uTGF0QmJveC50c1xudmFyIExvbkxhdEJCb3ggPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGxvbjAsIGxhdDAsIGxvbjEsIGxhdDEpIHtcbiAgICB0aGlzLmxvbjAgPSBsb24wO1xuICAgIHRoaXMubGF0MCA9IGxhdDA7XG4gICAgdGhpcy5sb24xID0gbG9uMTtcbiAgICB0aGlzLmxhdDEgPSBsYXQxO1xuICB9XG4gIG1lcmdlKG90aGVyKSB7XG4gICAgdGhpcy5sb24wID0gTWF0aC5taW4odGhpcy5sb24wLCBvdGhlci5sb24wKTtcbiAgICB0aGlzLmxhdDAgPSBNYXRoLm1pbih0aGlzLmxhdDAsIG90aGVyLmxhdDApO1xuICAgIHRoaXMubG9uMSA9IE1hdGgubWF4KHRoaXMubG9uMSwgb3RoZXIubG9uMSk7XG4gICAgdGhpcy5sYXQxID0gTWF0aC5tYXgodGhpcy5sYXQxLCBvdGhlci5sYXQxKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC90ZW1wVXRpbHMudHNcbmZ1bmN0aW9uIGNyZWF0ZUlkc0dlbmVyYXRvcigpIHtcbiAgY29uc3QgaWRzQ291bnRlciA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIHJldHVybiAobmFtZSkgPT4ge1xuICAgIGNvbnN0IGNvdW50ZXIgPSBpZHNDb3VudGVyLmdldChuYW1lKTtcbiAgICBpZiAoY291bnRlcikge1xuICAgICAgaWRzQ291bnRlci5zZXQobmFtZSwgY291bnRlciArIDEpO1xuICAgICAgcmV0dXJuIGAke25hbWV9JHtjb3VudGVyfWA7XG4gICAgfVxuICAgIGlkc0NvdW50ZXIuc2V0KG5hbWUsIDEpO1xuICAgIHJldHVybiBuYW1lO1xuICB9O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9heGlzL2F4aXNUaWNrcy50c1xudmFyIF9BeGlzVGlja3MgPSBjbGFzcyBfQXhpc1RpY2tzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5pZCA9IGNyZWF0ZUlkKHRoaXMpO1xuICAgIHRoaXMuYXhpc0dyb3VwID0gbmV3IFRyYW5zbGF0YWJsZUdyb3VwKHsgbmFtZTogYCR7dGhpcy5pZH0tQXhpc1RpY2tzYCwgekluZGV4OiAyIC8qIEFYSVMgKi8gfSk7XG4gICAgdGhpcy5sYWJlbFNlbGVjdGlvbiA9IFNlbGVjdGlvbi5zZWxlY3QodGhpcy5heGlzR3JvdXAsIFRleHQpO1xuICAgIHRoaXMuaW50ZXJ2YWwgPSBuZXcgQXhpc0ludGVydmFsKCk7XG4gICAgdGhpcy5sYWJlbCA9IG5ldyBBeGlzTGFiZWwoKTtcbiAgICB0aGlzLnNjYWxlID0gbmV3IExpbmVhclNjYWxlKCk7XG4gICAgdGhpcy5wb3NpdGlvbiA9IFwiYm90dG9tXCI7XG4gICAgdGhpcy50cmFuc2xhdGlvblggPSAwO1xuICAgIHRoaXMudHJhbnNsYXRpb25ZID0gMDtcbiAgICB0aGlzLnBhZGRpbmcgPSAwO1xuICB9XG4gIGF0dGFjaEF4aXMoYXhpc05vZGUpIHtcbiAgICBheGlzTm9kZS5hcHBlbmRDaGlsZCh0aGlzLmF4aXNHcm91cCk7XG4gIH1cbiAgY2FsY3VsYXRlTGF5b3V0KCkge1xuICAgIHRoaXMuc2NhbGUuaW50ZXJ2YWwgPSB0aGlzLmludGVydmFsLnN0ZXA7XG4gICAgY29uc3QgYm94ZXMgPSBbXTtcbiAgICBjb25zdCB0aWNrRGF0YSA9IHRoaXMuZ2VuZXJhdGVUaWNrcygpO1xuICAgIGNvbnN0IHsgdHJhbnNsYXRpb25YLCB0cmFuc2xhdGlvblkgfSA9IHRoaXM7XG4gICAgdGhpcy5sYWJlbFNlbGVjdGlvbi51cGRhdGUoXG4gICAgICB0aWNrRGF0YS50aWNrcy5tYXAoKGQpID0+IHRoaXMuY3JlYXRlTGFiZWxEYXR1bShkKSksXG4gICAgICB2b2lkIDAsXG4gICAgICAoZGF0dW0pID0+IGRhdHVtLnRpY2tJZFxuICAgICk7XG4gICAgdGhpcy5sYWJlbFNlbGVjdGlvbi5lYWNoKChub2RlLCBkYXR1bSkgPT4ge1xuICAgICAgbm9kZS5zZXRQcm9wZXJ0aWVzKGRhdHVtKTtcbiAgICAgIGlmIChkYXR1bS52aXNpYmxlKSB7XG4gICAgICAgIGJveGVzLnB1c2gobm9kZS5nZXRCQm94KCkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuYXhpc0dyb3VwLnNldFByb3BlcnRpZXMoeyB0cmFuc2xhdGlvblgsIHRyYW5zbGF0aW9uWSB9KTtcbiAgICByZXR1cm4gQkJveC5tZXJnZShib3hlcyk7XG4gIH1cbiAgZ2V0TGFiZWxQYXJhbXMoZGF0dW0pIHtcbiAgICBjb25zdCB7IHBhZGRpbmcgfSA9IHRoaXM7XG4gICAgY29uc3QgeyB0cmFuc2xhdGUgfSA9IGRhdHVtO1xuICAgIHN3aXRjaCAodGhpcy5wb3NpdGlvbikge1xuICAgICAgY2FzZSBcInRvcFwiOlxuICAgICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IHRyYW5zbGF0ZSxcbiAgICAgICAgICB5OiBwYWRkaW5nLFxuICAgICAgICAgIHRleHRBbGlnbjogXCJjZW50ZXJcIixcbiAgICAgICAgICB0ZXh0QmFzZWxpbmU6IFwidG9wXCJcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiBwYWRkaW5nLFxuICAgICAgICAgIHk6IHRyYW5zbGF0ZSxcbiAgICAgICAgICB0ZXh0QWxpZ246IFwic3RhcnRcIixcbiAgICAgICAgICB0ZXh0QmFzZWxpbmU6IFwibWlkZGxlXCJcbiAgICAgICAgfTtcbiAgICB9XG4gIH1cbiAgaW5SYW5nZSh4LCB0b2xlcmFuY2UgPSAxZS0zKSB7XG4gICAgY29uc3QgW21pbiwgbWF4XSA9IGZpbmRNaW5NYXgodGhpcy5zY2FsZS5yYW5nZSk7XG4gICAgcmV0dXJuIHggPj0gbWluIC0gdG9sZXJhbmNlICYmIHggPD0gbWF4ICsgdG9sZXJhbmNlO1xuICB9XG4gIGNyZWF0ZUxhYmVsRGF0dW0oZGF0dW0pIHtcbiAgICBjb25zdCB7IHgsIHksIHRleHRCYXNlbGluZSwgdGV4dEFsaWduIH0gPSB0aGlzLmdldExhYmVsUGFyYW1zKGRhdHVtKTtcbiAgICByZXR1cm4ge1xuICAgICAgdmlzaWJsZTogQm9vbGVhbihkYXR1bS50aWNrTGFiZWwpLFxuICAgICAgdGlja0lkOiBkYXR1bS50aWNrSWQsXG4gICAgICBmaWxsOiB0aGlzLmxhYmVsLmNvbG9yLFxuICAgICAgZm9udEZhbWlseTogdGhpcy5sYWJlbC5mb250RmFtaWx5LFxuICAgICAgZm9udFNpemU6IHRoaXMubGFiZWwuZm9udFNpemUsXG4gICAgICBmb250U3R5bGU6IHRoaXMubGFiZWwuZm9udFN0eWxlLFxuICAgICAgZm9udFdlaWdodDogdGhpcy5sYWJlbC5mb250V2VpZ2h0LFxuICAgICAgcm90YXRpb246IDAsXG4gICAgICByb3RhdGlvbkNlbnRlclg6IDAsXG4gICAgICB0ZXh0OiBkYXR1bS50aWNrTGFiZWwsXG4gICAgICB0ZXh0QWxpZ24sXG4gICAgICB0ZXh0QmFzZWxpbmUsXG4gICAgICB4LFxuICAgICAgeVxuICAgIH07XG4gIH1cbiAgZ2VuZXJhdGVUaWNrcygpIHtcbiAgICBjb25zdCB7IG1pblNwYWNpbmcsIG1heFNwYWNpbmcgfSA9IHRoaXMuaW50ZXJ2YWw7XG4gICAgY29uc3QgZXh0ZW50V2l0aEJsZWVkID0gcm91bmQoZmluZFJhbmdlRXh0ZW50KHRoaXMuc2NhbGUucmFuZ2UpLCAyKTtcbiAgICBjb25zdCB7IG1heFRpY2tDb3VudCwgbWluVGlja0NvdW50LCB0aWNrQ291bnQgfSA9IGVzdGltYXRlVGlja0NvdW50KFxuICAgICAgZXh0ZW50V2l0aEJsZWVkLFxuICAgICAgbWluU3BhY2luZyxcbiAgICAgIG1heFNwYWNpbmcsXG4gICAgICBfQXhpc1RpY2tzLkRlZmF1bHRUaWNrQ291bnQsXG4gICAgICBfQXhpc1RpY2tzLkRlZmF1bHRNaW5TcGFjaW5nXG4gICAgKTtcbiAgICBpZiAodGlja0NvdW50KSB7XG4gICAgICB0aGlzLnNjYWxlLnRpY2tDb3VudCA9IHRpY2tDb3VudDtcbiAgICAgIHRoaXMuc2NhbGUubWluVGlja0NvdW50ID0gbWluVGlja0NvdW50O1xuICAgICAgdGhpcy5zY2FsZS5tYXhUaWNrQ291bnQgPSBtYXhUaWNrQ291bnQ7XG4gICAgfVxuICAgIGNvbnN0IHRpY2tEYXRhID0gdGhpcy5nZXRUaWNrc0RhdGEoKTtcbiAgICBpZiAodGhpcy5wb3NpdGlvbiA9PT0gXCJib3R0b21cIiB8fCB0aGlzLnBvc2l0aW9uID09PSBcInRvcFwiKSB7XG4gICAgICBjb25zdCBtZWFzdXJlciA9IENhY2hlZFRleHRNZWFzdXJlclBvb2wuZ2V0TWVhc3VyZXIoeyBmb250OiB0aGlzLmxhYmVsIH0pO1xuICAgICAgY29uc3QgZG9tYWluID0gdGhpcy5zY2FsZS5nZXREb21haW4oKTtcbiAgICAgIGNvbnN0IHJldmVyc2VkID0gZG9tYWluWzBdID4gZG9tYWluWzFdO1xuICAgICAgY29uc3QgZGlyZWN0aW9uID0gcmV2ZXJzZWQgPyAtMSA6IDE7XG4gICAgICBsZXQgbGFzdFRpY2tQb3NpdGlvbiA9IC1JbmZpbml0eSAqIGRpcmVjdGlvbjtcbiAgICAgIHRpY2tEYXRhLnRpY2tzID0gdGlja0RhdGEudGlja3MuZmlsdGVyKChkYXRhKSA9PiB7XG4gICAgICAgIGlmIChNYXRoLnNpZ24oZGF0YS50cmFuc2xhdGUgLSBsYXN0VGlja1Bvc2l0aW9uKSAhPT0gZGlyZWN0aW9uKVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGFzdFRpY2tQb3NpdGlvbiA9IGRhdGEudHJhbnNsYXRlICsgbWVhc3VyZXIudGV4dFdpZHRoKGRhdGEudGlja0xhYmVsLCB0cnVlKSAqIGRpcmVjdGlvbjtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRpY2tEYXRhO1xuICB9XG4gIGdldFRpY2tzRGF0YSgpIHtcbiAgICBjb25zdCB0aWNrcyA9IFtdO1xuICAgIGNvbnN0IHJhd1RpY2tzID0gdGhpcy5zY2FsZS50aWNrcygpO1xuICAgIGNvbnN0IGZyYWN0aW9uRGlnaXRzID0gcmF3VGlja3MucmVkdWNlKFxuICAgICAgKG1heCwgdGljaykgPT4gTWF0aC5tYXgobWF4LCB0eXBlb2YgdGljayA9PT0gXCJudW1iZXJcIiA/IGNvdW50RnJhY3Rpb25EaWdpdHModGljaykgOiAwKSxcbiAgICAgIDBcbiAgICApO1xuICAgIGNvbnN0IGlkR2VuZXJhdG9yID0gY3JlYXRlSWRzR2VuZXJhdG9yKCk7XG4gICAgY29uc3QgbGFiZWxGb3JtYXR0ZXIgPSB0aGlzLmxhYmVsLmZvcm1hdCA/IHRoaXMuc2NhbGUudGlja0Zvcm1hdCh7IHRpY2tzOiByYXdUaWNrcywgc3BlY2lmaWVyOiB0aGlzLmxhYmVsLmZvcm1hdCB9KSA6ICh4KSA9PiBpc051bWJlcih4KSA/IHgudG9GaXhlZChmcmFjdGlvbkRpZ2l0cykgOiBTdHJpbmcoeCk7XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHJhd1RpY2tzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgY29uc3QgdGljayA9IHJhd1RpY2tzW2luZGV4XTtcbiAgICAgIGNvbnN0IHRyYW5zbGF0ZSA9IHRoaXMuc2NhbGUuY29udmVydCh0aWNrKTtcbiAgICAgIGlmICghdGhpcy5pblJhbmdlKHRyYW5zbGF0ZSkpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3QgdGlja0xhYmVsID0gdGhpcy5sYWJlbC5mb3JtYXR0ZXI/Lih7IHZhbHVlOiB0aWNrLCBpbmRleCwgZnJhY3Rpb25EaWdpdHMgfSkgPz8gbGFiZWxGb3JtYXR0ZXIodGljayk7XG4gICAgICBjb25zdCB0aWNrSWQgPSBpZEdlbmVyYXRvcih0aWNrTGFiZWwpO1xuICAgICAgdGlja3MucHVzaCh7IHRpY2ssIHRpY2tJZCwgdGlja0xhYmVsLCB0cmFuc2xhdGUgfSk7XG4gICAgfVxuICAgIHJldHVybiB7IHJhd1RpY2tzLCBmcmFjdGlvbkRpZ2l0cywgdGlja3MgfTtcbiAgfVxufTtcbl9BeGlzVGlja3MuRGVmYXVsdFRpY2tDb3VudCA9IDU7XG5fQXhpc1RpY2tzLkRlZmF1bHRNaW5TcGFjaW5nID0gNTA7XG52YXIgQXhpc1RpY2tzID0gX0F4aXNUaWNrcztcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbGVnZW5kRGF0dW0udHNcbnZhciBfX0ZPUkNFX01PRFVMRV9ERVRFQ1RJT04gPSAwO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9kb20vZWxlbWVudHMudHNcbmZ1bmN0aW9uIGNyZWF0ZUJ1dHRvbihvcHRpb25zLCBhdHRycykge1xuICBjb25zdCBidXR0b24gPSBjcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIGdldENsYXNzTmFtZShcImFnLWNoYXJ0cy1pbnB1dCBhZy1jaGFydHMtYnV0dG9uXCIsIGF0dHJzKSk7XG4gIGlmIChvcHRpb25zLmxhYmVsICE9PSB2b2lkIDApIHtcbiAgICBidXR0b24uYXBwZW5kKG9wdGlvbnMubGFiZWwpO1xuICB9IGVsc2Uge1xuICAgIGJ1dHRvbi5hcHBlbmQoY3JlYXRlSWNvbihvcHRpb25zLmljb24pKTtcbiAgICBidXR0b24uYXJpYUxhYmVsID0gb3B0aW9ucy5hbHRUZXh0O1xuICB9XG4gIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgb3B0aW9ucy5vblByZXNzKTtcbiAgc2V0QXR0cmlidXRlcyhidXR0b24sIGF0dHJzKTtcbiAgcmV0dXJuIGJ1dHRvbjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNoZWNrYm94KG9wdGlvbnMsIGF0dHJzKSB7XG4gIGNvbnN0IGNoZWNrYm94ID0gY3JlYXRlRWxlbWVudChcImlucHV0XCIsIGdldENsYXNzTmFtZShcImFnLWNoYXJ0cy1pbnB1dCBhZy1jaGFydHMtY2hlY2tib3hcIiwgYXR0cnMpKTtcbiAgY2hlY2tib3gudHlwZSA9IFwiY2hlY2tib3hcIjtcbiAgY2hlY2tib3guY2hlY2tlZCA9IG9wdGlvbnMuY2hlY2tlZDtcbiAgY2hlY2tib3guYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoZXZlbnQpID0+IG9wdGlvbnMub25DaGFuZ2UoY2hlY2tib3guY2hlY2tlZCwgZXZlbnQpKTtcbiAgY2hlY2tib3guYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgKGV2ZW50KSA9PiB7XG4gICAgaWYgKGlzQnV0dG9uQ2xpY2tFdmVudChldmVudCkpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBjaGVja2JveC5jbGljaygpO1xuICAgIH1cbiAgfSk7XG4gIHNldEF0dHJpYnV0ZXMoY2hlY2tib3gsIGF0dHJzKTtcbiAgcmV0dXJuIGNoZWNrYm94O1xufVxuZnVuY3Rpb24gY3JlYXRlU2VsZWN0KG9wdGlvbnMsIGF0dHJzKSB7XG4gIGNvbnN0IHNlbGVjdCA9IGNyZWF0ZUVsZW1lbnQoXCJzZWxlY3RcIiwgZ2V0Q2xhc3NOYW1lKFwiYWctY2hhcnRzLWlucHV0IGFnLWNoYXJ0cy1zZWxlY3RcIiwgYXR0cnMpKTtcbiAgc2VsZWN0LmFwcGVuZChcbiAgICAuLi5vcHRpb25zLm9wdGlvbnMubWFwKChvcHRpb24pID0+IHtcbiAgICAgIGNvbnN0IG9wdGlvbkVsID0gY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcbiAgICAgIG9wdGlvbkVsLnZhbHVlID0gb3B0aW9uLnZhbHVlO1xuICAgICAgb3B0aW9uRWwudGV4dENvbnRlbnQgPSBvcHRpb24ubGFiZWw7XG4gICAgICByZXR1cm4gb3B0aW9uRWw7XG4gICAgfSlcbiAgKTtcbiAgc2V0QXR0cmlidXRlKHNlbGVjdCwgXCJkYXRhLXByZXZlbnRkZWZhdWx0XCIsIGZhbHNlKTtcbiAgc2VsZWN0LnZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgc2VsZWN0LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgKGV2ZW50KSA9PiBvcHRpb25zLm9uQ2hhbmdlKHNlbGVjdC52YWx1ZSwgZXZlbnQpKTtcbiAgc2V0QXR0cmlidXRlcyhzZWxlY3QsIGF0dHJzKTtcbiAgcmV0dXJuIHNlbGVjdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRleHRBcmVhKG9wdGlvbnMsIGF0dHJzKSB7XG4gIGNvbnN0IHRleHRBcmVhID0gY3JlYXRlRWxlbWVudChcInRleHRhcmVhXCIsIGdldENsYXNzTmFtZShcImFnLWNoYXJ0cy1pbnB1dCBhZy1jaGFydHMtdGV4dGFyZWFcIiwgYXR0cnMpKTtcbiAgdGV4dEFyZWEudmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICB0ZXh0QXJlYS5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgKGV2ZW50KSA9PiBvcHRpb25zLm9uQ2hhbmdlKHRleHRBcmVhLnZhbHVlLCBldmVudCkpO1xuICBzZXRBdHRyaWJ1dGVzKHRleHRBcmVhLCBhdHRycyk7XG4gIHJldHVybiB0ZXh0QXJlYTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUljb24oaWNvbikge1xuICBjb25zdCBlbCA9IGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIGBhZy1jaGFydHMtaWNvbiBhZy1jaGFydHMtaWNvbi0ke2ljb259YCk7XG4gIHNldEF0dHJpYnV0ZShlbCwgXCJhcmlhLWhpZGRlblwiLCB0cnVlKTtcbiAgcmV0dXJuIGVsO1xufVxuZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKGJhc2VDbGFzcywgYXR0cnMpIHtcbiAgaWYgKGF0dHJzID09IG51bGwpXG4gICAgcmV0dXJuIGJhc2VDbGFzcztcbiAgcmV0dXJuIGAke2Jhc2VDbGFzc30gJHthdHRycy5jbGFzc31gO1xufVxuZXhwb3J0IHtcbiAgQUdfQ0hBUlRTX0xPQ0FMRV9FTl9VUyxcbiAgQWdDaGFydHMsXG4gIEFnRXJyb3JCYXJTdXBwb3J0ZWRTZXJpZXNUeXBlcyxcbiAgQWdUb29sdGlwUG9zaXRpb25UeXBlLFxuICBJQ09OU19MRUdBQ1ksXG4gIE1hcmtlcixcbiAgVkVSU0lPTixcbiAgbW9kdWxlX3N1cHBvcnRfZXhwb3J0cyBhcyBfTW9kdWxlU3VwcG9ydCxcbiAgc3BhcmtsaW5lc19zY2FsZV9leHBvcnRzIGFzIF9TY2FsZSxcbiAgaW50ZWdyYXRlZF9jaGFydHNfc2NlbmVfZXhwb3J0cyBhcyBfU2NlbmUsXG4gIGludGVncmF0ZWRfY2hhcnRzX3RoZW1lX2V4cG9ydHMgYXMgX1RoZW1lLFxuICBzcGFya2xpbmVzX3V0aWxfZXhwb3J0cyBhcyBfVXRpbCxcbiAgc2V0dXBDb21tdW5pdHlNb2R1bGVzLFxuICB0aW1lX2V4cG9ydHMgYXMgdGltZVxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ag-charts-community/dist/package/main.esm.mjs\n");

/***/ })

};
;